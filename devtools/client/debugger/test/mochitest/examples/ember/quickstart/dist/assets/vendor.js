window
.
EmberENV
=
{
"
FEATURES
"
:
{
}
"
EXTEND_PROTOTYPES
"
:
{
"
Date
"
:
false
}
}
;
var
runningTests
=
false
;
;
var
loader
define
requireModule
require
requirejs
;
(
function
(
global
)
{
'
use
strict
'
;
function
dict
(
)
{
var
obj
=
Object
.
create
(
null
)
;
obj
[
'
__
'
]
=
undefined
;
delete
obj
[
'
__
'
]
;
return
obj
;
}
var
oldGlobals
=
{
loader
:
loader
define
:
define
requireModule
:
requireModule
require
:
require
requirejs
:
requirejs
}
;
requirejs
=
require
=
requireModule
=
function
(
id
)
{
var
pending
=
[
]
;
var
mod
=
findModule
(
id
'
(
require
)
'
pending
)
;
for
(
var
i
=
pending
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
pending
[
i
]
.
exports
(
)
;
}
return
mod
.
module
.
exports
;
}
;
loader
=
{
noConflict
:
function
(
aliases
)
{
var
oldName
newName
;
for
(
oldName
in
aliases
)
{
if
(
aliases
.
hasOwnProperty
(
oldName
)
)
{
if
(
oldGlobals
.
hasOwnProperty
(
oldName
)
)
{
newName
=
aliases
[
oldName
]
;
global
[
newName
]
=
global
[
oldName
]
;
global
[
oldName
]
=
oldGlobals
[
oldName
]
;
}
}
}
}
makeDefaultExport
:
true
}
;
var
registry
=
dict
(
)
;
var
seen
=
dict
(
)
;
var
uuid
=
0
;
function
unsupportedModule
(
length
)
{
throw
new
Error
(
'
an
unsupported
module
was
defined
expected
define
(
id
deps
module
)
instead
got
:
'
+
length
+
'
arguments
to
define
'
)
;
}
var
defaultDeps
=
[
'
require
'
'
exports
'
'
module
'
]
;
function
Module
(
id
deps
callback
alias
)
{
this
.
uuid
=
uuid
+
+
;
this
.
id
=
id
;
this
.
deps
=
!
deps
.
length
&
&
callback
.
length
?
defaultDeps
:
deps
;
this
.
module
=
{
exports
:
{
}
}
;
this
.
callback
=
callback
;
this
.
hasExportsAsDep
=
false
;
this
.
isAlias
=
alias
;
this
.
reified
=
new
Array
(
deps
.
length
)
;
this
.
state
=
'
new
'
;
}
Module
.
prototype
.
makeDefaultExport
=
function
(
)
{
var
exports
=
this
.
module
.
exports
;
if
(
exports
!
=
=
null
&
&
(
typeof
exports
=
=
=
'
object
'
|
|
typeof
exports
=
=
=
'
function
'
)
&
&
exports
[
'
default
'
]
=
=
=
undefined
&
&
Object
.
isExtensible
(
exports
)
)
{
exports
[
'
default
'
]
=
exports
;
}
}
;
Module
.
prototype
.
exports
=
function
(
)
{
if
(
this
.
state
=
=
=
'
finalized
'
|
|
this
.
state
=
=
=
'
reifying
'
)
{
return
this
.
module
.
exports
;
}
if
(
loader
.
wrapModules
)
{
this
.
callback
=
loader
.
wrapModules
(
this
.
id
this
.
callback
)
;
}
this
.
reify
(
)
;
var
result
=
this
.
callback
.
apply
(
this
this
.
reified
)
;
this
.
reified
.
length
=
0
;
this
.
state
=
'
finalized
'
;
if
(
!
(
this
.
hasExportsAsDep
&
&
result
=
=
=
undefined
)
)
{
this
.
module
.
exports
=
result
;
}
if
(
loader
.
makeDefaultExport
)
{
this
.
makeDefaultExport
(
)
;
}
return
this
.
module
.
exports
;
}
;
Module
.
prototype
.
unsee
=
function
(
)
{
this
.
state
=
'
new
'
;
this
.
module
=
{
exports
:
{
}
}
;
}
;
Module
.
prototype
.
reify
=
function
(
)
{
if
(
this
.
state
=
=
=
'
reified
'
)
{
return
;
}
this
.
state
=
'
reifying
'
;
try
{
this
.
reified
=
this
.
_reify
(
)
;
this
.
state
=
'
reified
'
;
}
finally
{
if
(
this
.
state
=
=
=
'
reifying
'
)
{
this
.
state
=
'
errored
'
;
}
}
}
;
Module
.
prototype
.
_reify
=
function
(
)
{
var
reified
=
this
.
reified
.
slice
(
)
;
for
(
var
i
=
0
;
i
<
reified
.
length
;
i
+
+
)
{
var
mod
=
reified
[
i
]
;
reified
[
i
]
=
mod
.
exports
?
mod
.
exports
:
mod
.
module
.
exports
(
)
;
}
return
reified
;
}
;
Module
.
prototype
.
findDeps
=
function
(
pending
)
{
if
(
this
.
state
!
=
=
'
new
'
)
{
return
;
}
this
.
state
=
'
pending
'
;
var
deps
=
this
.
deps
;
for
(
var
i
=
0
;
i
<
deps
.
length
;
i
+
+
)
{
var
dep
=
deps
[
i
]
;
var
entry
=
this
.
reified
[
i
]
=
{
exports
:
undefined
module
:
undefined
}
;
if
(
dep
=
=
=
'
exports
'
)
{
this
.
hasExportsAsDep
=
true
;
entry
.
exports
=
this
.
module
.
exports
;
}
else
if
(
dep
=
=
=
'
require
'
)
{
entry
.
exports
=
this
.
makeRequire
(
)
;
}
else
if
(
dep
=
=
=
'
module
'
)
{
entry
.
exports
=
this
.
module
;
}
else
{
entry
.
module
=
findModule
(
resolve
(
dep
this
.
id
)
this
.
id
pending
)
;
}
}
}
;
Module
.
prototype
.
makeRequire
=
function
(
)
{
var
id
=
this
.
id
;
var
r
=
function
(
dep
)
{
return
require
(
resolve
(
dep
id
)
)
;
}
;
r
[
'
default
'
]
=
r
;
r
.
moduleId
=
id
;
r
.
has
=
function
(
dep
)
{
return
has
(
resolve
(
dep
id
)
)
;
}
;
return
r
;
}
;
define
=
function
(
id
deps
callback
)
{
var
module
=
registry
[
id
]
;
if
(
module
&
&
module
.
state
!
=
=
'
new
'
)
{
return
;
}
if
(
arguments
.
length
<
2
)
{
unsupportedModule
(
arguments
.
length
)
;
}
if
(
!
Array
.
isArray
(
deps
)
)
{
callback
=
deps
;
deps
=
[
]
;
}
if
(
callback
instanceof
Alias
)
{
registry
[
id
]
=
new
Module
(
callback
.
id
deps
callback
true
)
;
}
else
{
registry
[
id
]
=
new
Module
(
id
deps
callback
false
)
;
}
}
;
define
.
exports
=
function
(
name
defaultExport
)
{
var
module
=
registry
[
name
]
;
if
(
module
&
&
module
.
state
!
=
=
'
new
'
)
{
return
;
}
module
=
new
Module
(
name
[
]
noop
null
)
;
module
.
module
.
exports
=
defaultExport
;
module
.
state
=
'
finalized
'
;
registry
[
name
]
=
module
;
return
module
;
}
;
function
noop
(
)
{
}
function
Alias
(
id
)
{
this
.
id
=
id
;
}
define
.
alias
=
function
(
id
target
)
{
if
(
arguments
.
length
=
=
=
2
)
{
return
define
(
target
new
Alias
(
id
)
)
;
}
return
new
Alias
(
id
)
;
}
;
function
missingModule
(
id
referrer
)
{
throw
new
Error
(
'
Could
not
find
module
'
+
id
+
'
imported
from
'
+
referrer
+
'
'
)
;
}
function
findModule
(
id
referrer
pending
)
{
var
mod
=
registry
[
id
]
|
|
registry
[
id
+
'
/
index
'
]
;
while
(
mod
&
&
mod
.
isAlias
)
{
mod
=
registry
[
mod
.
id
]
;
}
if
(
!
mod
)
{
missingModule
(
id
referrer
)
;
}
if
(
pending
&
&
mod
.
state
!
=
=
'
pending
'
&
&
mod
.
state
!
=
=
'
finalized
'
)
{
mod
.
findDeps
(
pending
)
;
pending
.
push
(
mod
)
;
}
return
mod
;
}
function
resolve
(
child
id
)
{
if
(
child
.
charAt
(
0
)
!
=
=
'
.
'
)
{
return
child
;
}
var
parts
=
child
.
split
(
'
/
'
)
;
var
nameParts
=
id
.
split
(
'
/
'
)
;
var
parentBase
=
nameParts
.
slice
(
0
-
1
)
;
for
(
var
i
=
0
l
=
parts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
.
'
)
{
if
(
parentBase
.
length
=
=
=
0
)
{
throw
new
Error
(
'
Cannot
access
parent
module
of
root
'
)
;
}
parentBase
.
pop
(
)
;
}
else
if
(
part
=
=
=
'
.
'
)
{
continue
;
}
else
{
parentBase
.
push
(
part
)
;
}
}
return
parentBase
.
join
(
'
/
'
)
;
}
function
has
(
id
)
{
return
!
!
(
registry
[
id
]
|
|
registry
[
id
+
'
/
index
'
]
)
;
}
requirejs
.
entries
=
requirejs
.
_eak_seen
=
registry
;
requirejs
.
has
=
has
;
requirejs
.
unsee
=
function
(
id
)
{
findModule
(
id
'
(
unsee
)
'
false
)
.
unsee
(
)
;
}
;
requirejs
.
clear
=
function
(
)
{
requirejs
.
entries
=
requirejs
.
_eak_seen
=
registry
=
dict
(
)
;
seen
=
dict
(
)
;
}
;
define
(
'
foo
'
function
(
)
{
}
)
;
define
(
'
foo
/
bar
'
[
]
function
(
)
{
}
)
;
define
(
'
foo
/
asdf
'
[
'
module
'
'
exports
'
'
require
'
]
function
(
module
exports
require
)
{
if
(
require
.
has
(
'
foo
/
bar
'
)
)
{
require
(
'
foo
/
bar
'
)
;
}
}
)
;
define
(
'
foo
/
baz
'
[
]
define
.
alias
(
'
foo
'
)
)
;
define
(
'
foo
/
quz
'
define
.
alias
(
'
foo
'
)
)
;
define
.
alias
(
'
foo
'
'
foo
/
qux
'
)
;
define
(
'
foo
/
bar
'
[
'
foo
'
'
.
/
quz
'
'
.
/
baz
'
'
.
/
asdf
'
'
.
/
bar
'
'
.
.
/
foo
'
]
function
(
)
{
}
)
;
define
(
'
foo
/
main
'
[
'
foo
/
bar
'
]
function
(
)
{
}
)
;
define
.
exports
(
'
foo
/
exports
'
{
}
)
;
require
(
'
foo
/
exports
'
)
;
require
(
'
foo
/
main
'
)
;
require
.
unsee
(
'
foo
/
bar
'
)
;
requirejs
.
clear
(
)
;
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
&
&
module
.
exports
)
{
module
.
exports
=
{
require
:
require
define
:
define
}
;
}
}
)
(
this
)
;
;
(
function
(
global
factory
)
{
"
use
strict
"
;
if
(
typeof
module
=
=
=
"
object
"
&
&
typeof
module
.
exports
=
=
=
"
object
"
)
{
module
.
exports
=
global
.
document
?
factory
(
global
true
)
:
function
(
w
)
{
if
(
!
w
.
document
)
{
throw
new
Error
(
"
jQuery
requires
a
window
with
a
document
"
)
;
}
return
factory
(
w
)
;
}
;
}
else
{
factory
(
global
)
;
}
}
)
(
typeof
window
!
=
=
"
undefined
"
?
window
:
this
function
(
window
noGlobal
)
{
"
use
strict
"
;
var
arr
=
[
]
;
var
document
=
window
.
document
;
var
getProto
=
Object
.
getPrototypeOf
;
var
slice
=
arr
.
slice
;
var
concat
=
arr
.
concat
;
var
push
=
arr
.
push
;
var
indexOf
=
arr
.
indexOf
;
var
class2type
=
{
}
;
var
toString
=
class2type
.
toString
;
var
hasOwn
=
class2type
.
hasOwnProperty
;
var
fnToString
=
hasOwn
.
toString
;
var
ObjectFunctionString
=
fnToString
.
call
(
Object
)
;
var
support
=
{
}
;
var
isFunction
=
function
isFunction
(
obj
)
{
return
typeof
obj
=
=
=
"
function
"
&
&
typeof
obj
.
nodeType
!
=
=
"
number
"
;
}
;
var
isWindow
=
function
isWindow
(
obj
)
{
return
obj
!
=
null
&
&
obj
=
=
=
obj
.
window
;
}
;
var
preservedScriptAttributes
=
{
type
:
true
src
:
true
noModule
:
true
}
;
function
DOMEval
(
code
doc
node
)
{
doc
=
doc
|
|
document
;
var
i
script
=
doc
.
createElement
(
"
script
"
)
;
script
.
text
=
code
;
if
(
node
)
{
for
(
i
in
preservedScriptAttributes
)
{
if
(
node
[
i
]
)
{
script
[
i
]
=
node
[
i
]
;
}
}
}
doc
.
head
.
appendChild
(
script
)
.
parentNode
.
removeChild
(
script
)
;
}
function
toType
(
obj
)
{
if
(
obj
=
=
null
)
{
return
obj
+
"
"
;
}
return
typeof
obj
=
=
=
"
object
"
|
|
typeof
obj
=
=
=
"
function
"
?
class2type
[
toString
.
call
(
obj
)
]
|
|
"
object
"
:
typeof
obj
;
}
var
version
=
"
3
.
3
.
1
"
jQuery
=
function
(
selector
context
)
{
return
new
jQuery
.
fn
.
init
(
selector
context
)
;
}
rtrim
=
/
^
[
\
s
\
uFEFF
\
xA0
]
+
|
[
\
s
\
uFEFF
\
xA0
]
+
/
g
;
jQuery
.
fn
=
jQuery
.
prototype
=
{
jquery
:
version
constructor
:
jQuery
length
:
0
toArray
:
function
(
)
{
return
slice
.
call
(
this
)
;
}
get
:
function
(
num
)
{
if
(
num
=
=
null
)
{
return
slice
.
call
(
this
)
;
}
return
num
<
0
?
this
[
num
+
this
.
length
]
:
this
[
num
]
;
}
pushStack
:
function
(
elems
)
{
var
ret
=
jQuery
.
merge
(
this
.
constructor
(
)
elems
)
;
ret
.
prevObject
=
this
;
return
ret
;
}
each
:
function
(
callback
)
{
return
jQuery
.
each
(
this
callback
)
;
}
map
:
function
(
callback
)
{
return
this
.
pushStack
(
jQuery
.
map
(
this
function
(
elem
i
)
{
return
callback
.
call
(
elem
i
elem
)
;
}
)
)
;
}
slice
:
function
(
)
{
return
this
.
pushStack
(
slice
.
apply
(
this
arguments
)
)
;
}
first
:
function
(
)
{
return
this
.
eq
(
0
)
;
}
last
:
function
(
)
{
return
this
.
eq
(
-
1
)
;
}
eq
:
function
(
i
)
{
var
len
=
this
.
length
j
=
+
i
+
(
i
<
0
?
len
:
0
)
;
return
this
.
pushStack
(
j
>
=
0
&
&
j
<
len
?
[
this
[
j
]
]
:
[
]
)
;
}
end
:
function
(
)
{
return
this
.
prevObject
|
|
this
.
constructor
(
)
;
}
push
:
push
sort
:
arr
.
sort
splice
:
arr
.
splice
}
;
jQuery
.
extend
=
jQuery
.
fn
.
extend
=
function
(
)
{
var
options
name
src
copy
copyIsArray
clone
target
=
arguments
[
0
]
|
|
{
}
i
=
1
length
=
arguments
.
length
deep
=
false
;
if
(
typeof
target
=
=
=
"
boolean
"
)
{
deep
=
target
;
target
=
arguments
[
i
]
|
|
{
}
;
i
+
+
;
}
if
(
typeof
target
!
=
=
"
object
"
&
&
!
isFunction
(
target
)
)
{
target
=
{
}
;
}
if
(
i
=
=
=
length
)
{
target
=
this
;
i
-
-
;
}
for
(
;
i
<
length
;
i
+
+
)
{
if
(
(
options
=
arguments
[
i
]
)
!
=
null
)
{
for
(
name
in
options
)
{
src
=
target
[
name
]
;
copy
=
options
[
name
]
;
if
(
target
=
=
=
copy
)
{
continue
;
}
if
(
deep
&
&
copy
&
&
(
jQuery
.
isPlainObject
(
copy
)
|
|
(
copyIsArray
=
Array
.
isArray
(
copy
)
)
)
)
{
if
(
copyIsArray
)
{
copyIsArray
=
false
;
clone
=
src
&
&
Array
.
isArray
(
src
)
?
src
:
[
]
;
}
else
{
clone
=
src
&
&
jQuery
.
isPlainObject
(
src
)
?
src
:
{
}
;
}
target
[
name
]
=
jQuery
.
extend
(
deep
clone
copy
)
;
}
else
if
(
copy
!
=
=
undefined
)
{
target
[
name
]
=
copy
;
}
}
}
}
return
target
;
}
;
jQuery
.
extend
(
{
expando
:
"
jQuery
"
+
(
version
+
Math
.
random
(
)
)
.
replace
(
/
\
D
/
g
"
"
)
isReady
:
true
error
:
function
(
msg
)
{
throw
new
Error
(
msg
)
;
}
noop
:
function
(
)
{
}
isPlainObject
:
function
(
obj
)
{
var
proto
Ctor
;
if
(
!
obj
|
|
toString
.
call
(
obj
)
!
=
=
"
[
object
Object
]
"
)
{
return
false
;
}
proto
=
getProto
(
obj
)
;
if
(
!
proto
)
{
return
true
;
}
Ctor
=
hasOwn
.
call
(
proto
"
constructor
"
)
&
&
proto
.
constructor
;
return
typeof
Ctor
=
=
=
"
function
"
&
&
fnToString
.
call
(
Ctor
)
=
=
=
ObjectFunctionString
;
}
isEmptyObject
:
function
(
obj
)
{
var
name
;
for
(
name
in
obj
)
{
return
false
;
}
return
true
;
}
globalEval
:
function
(
code
)
{
DOMEval
(
code
)
;
}
each
:
function
(
obj
callback
)
{
var
length
i
=
0
;
if
(
isArrayLike
(
obj
)
)
{
length
=
obj
.
length
;
for
(
;
i
<
length
;
i
+
+
)
{
if
(
callback
.
call
(
obj
[
i
]
i
obj
[
i
]
)
=
=
=
false
)
{
break
;
}
}
}
else
{
for
(
i
in
obj
)
{
if
(
callback
.
call
(
obj
[
i
]
i
obj
[
i
]
)
=
=
=
false
)
{
break
;
}
}
}
return
obj
;
}
trim
:
function
(
text
)
{
return
text
=
=
null
?
"
"
:
(
text
+
"
"
)
.
replace
(
rtrim
"
"
)
;
}
makeArray
:
function
(
arr
results
)
{
var
ret
=
results
|
|
[
]
;
if
(
arr
!
=
null
)
{
if
(
isArrayLike
(
Object
(
arr
)
)
)
{
jQuery
.
merge
(
ret
typeof
arr
=
=
=
"
string
"
?
[
arr
]
:
arr
)
;
}
else
{
push
.
call
(
ret
arr
)
;
}
}
return
ret
;
}
inArray
:
function
(
elem
arr
i
)
{
return
arr
=
=
null
?
-
1
:
indexOf
.
call
(
arr
elem
i
)
;
}
merge
:
function
(
first
second
)
{
var
len
=
+
second
.
length
j
=
0
i
=
first
.
length
;
for
(
;
j
<
len
;
j
+
+
)
{
first
[
i
+
+
]
=
second
[
j
]
;
}
first
.
length
=
i
;
return
first
;
}
grep
:
function
(
elems
callback
invert
)
{
var
callbackInverse
matches
=
[
]
i
=
0
length
=
elems
.
length
callbackExpect
=
!
invert
;
for
(
;
i
<
length
;
i
+
+
)
{
callbackInverse
=
!
callback
(
elems
[
i
]
i
)
;
if
(
callbackInverse
!
=
=
callbackExpect
)
{
matches
.
push
(
elems
[
i
]
)
;
}
}
return
matches
;
}
map
:
function
(
elems
callback
arg
)
{
var
length
value
i
=
0
ret
=
[
]
;
if
(
isArrayLike
(
elems
)
)
{
length
=
elems
.
length
;
for
(
;
i
<
length
;
i
+
+
)
{
value
=
callback
(
elems
[
i
]
i
arg
)
;
if
(
value
!
=
null
)
{
ret
.
push
(
value
)
;
}
}
}
else
{
for
(
i
in
elems
)
{
value
=
callback
(
elems
[
i
]
i
arg
)
;
if
(
value
!
=
null
)
{
ret
.
push
(
value
)
;
}
}
}
return
concat
.
apply
(
[
]
ret
)
;
}
guid
:
1
support
:
support
}
)
;
if
(
typeof
Symbol
=
=
=
"
function
"
)
{
jQuery
.
fn
[
Symbol
.
iterator
]
=
arr
[
Symbol
.
iterator
]
;
}
jQuery
.
each
(
"
Boolean
Number
String
Function
Array
Date
RegExp
Object
Error
Symbol
"
.
split
(
"
"
)
function
(
i
name
)
{
class2type
[
"
[
object
"
+
name
+
"
]
"
]
=
name
.
toLowerCase
(
)
;
}
)
;
function
isArrayLike
(
obj
)
{
var
length
=
!
!
obj
&
&
"
length
"
in
obj
&
&
obj
.
length
type
=
toType
(
obj
)
;
if
(
isFunction
(
obj
)
|
|
isWindow
(
obj
)
)
{
return
false
;
}
return
type
=
=
=
"
array
"
|
|
length
=
=
=
0
|
|
typeof
length
=
=
=
"
number
"
&
&
length
>
0
&
&
(
length
-
1
)
in
obj
;
}
var
Sizzle
=
(
function
(
window
)
{
var
i
support
Expr
getText
isXML
tokenize
compile
select
outermostContext
sortInput
hasDuplicate
setDocument
document
docElem
documentIsHTML
rbuggyQSA
rbuggyMatches
matches
contains
expando
=
"
sizzle
"
+
1
*
new
Date
(
)
preferredDoc
=
window
.
document
dirruns
=
0
done
=
0
classCache
=
createCache
(
)
tokenCache
=
createCache
(
)
compilerCache
=
createCache
(
)
sortOrder
=
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
}
return
0
;
}
hasOwn
=
(
{
}
)
.
hasOwnProperty
arr
=
[
]
pop
=
arr
.
pop
push_native
=
arr
.
push
push
=
arr
.
push
slice
=
arr
.
slice
indexOf
=
function
(
list
elem
)
{
var
i
=
0
len
=
list
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
list
[
i
]
=
=
=
elem
)
{
return
i
;
}
}
return
-
1
;
}
booleans
=
"
checked
|
selected
|
async
|
autofocus
|
autoplay
|
controls
|
defer
|
disabled
|
hidden
|
ismap
|
loop
|
multiple
|
open
|
readonly
|
required
|
scoped
"
whitespace
=
"
[
\
\
x20
\
\
t
\
\
r
\
\
n
\
\
f
]
"
identifier
=
"
(
?
:
\
\
\
\
.
|
[
\
\
w
-
]
|
[
^
\
0
-
\
\
xa0
]
)
+
"
attributes
=
"
\
\
[
"
+
whitespace
+
"
*
(
"
+
identifier
+
"
)
(
?
:
"
+
whitespace
+
"
*
(
[
*
^
|
!
~
]
?
=
)
"
+
whitespace
+
"
*
(
?
:
'
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
'
]
)
*
)
'
|
\
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
\
"
]
)
*
)
\
"
|
(
"
+
identifier
+
"
)
)
|
)
"
+
whitespace
+
"
*
\
\
]
"
pseudos
=
"
:
(
"
+
identifier
+
"
)
(
?
:
\
\
(
(
"
+
"
(
'
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
'
]
)
*
)
'
|
\
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
\
"
]
)
*
)
\
"
)
|
"
+
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
(
)
[
\
\
]
]
|
"
+
attributes
+
"
)
*
)
|
"
+
"
.
*
"
+
"
)
\
\
)
|
)
"
rwhitespace
=
new
RegExp
(
whitespace
+
"
+
"
"
g
"
)
rtrim
=
new
RegExp
(
"
^
"
+
whitespace
+
"
+
|
(
(
?
:
^
|
[
^
\
\
\
\
]
)
(
?
:
\
\
\
\
.
)
*
)
"
+
whitespace
+
"
+
"
"
g
"
)
rcomma
=
new
RegExp
(
"
^
"
+
whitespace
+
"
*
"
+
whitespace
+
"
*
"
)
rcombinators
=
new
RegExp
(
"
^
"
+
whitespace
+
"
*
(
[
>
+
~
]
|
"
+
whitespace
+
"
)
"
+
whitespace
+
"
*
"
)
rattributeQuotes
=
new
RegExp
(
"
=
"
+
whitespace
+
"
*
(
[
^
\
\
]
'
\
"
]
*
?
)
"
+
whitespace
+
"
*
\
\
]
"
"
g
"
)
rpseudo
=
new
RegExp
(
pseudos
)
ridentifier
=
new
RegExp
(
"
^
"
+
identifier
+
"
"
)
matchExpr
=
{
"
ID
"
:
new
RegExp
(
"
^
#
(
"
+
identifier
+
"
)
"
)
"
CLASS
"
:
new
RegExp
(
"
^
\
\
.
(
"
+
identifier
+
"
)
"
)
"
TAG
"
:
new
RegExp
(
"
^
(
"
+
identifier
+
"
|
[
*
]
)
"
)
"
ATTR
"
:
new
RegExp
(
"
^
"
+
attributes
)
"
PSEUDO
"
:
new
RegExp
(
"
^
"
+
pseudos
)
"
CHILD
"
:
new
RegExp
(
"
^
:
(
only
|
first
|
last
|
nth
|
nth
-
last
)
-
(
child
|
of
-
type
)
(
?
:
\
\
(
"
+
whitespace
+
"
*
(
even
|
odd
|
(
(
[
+
-
]
|
)
(
\
\
d
*
)
n
|
)
"
+
whitespace
+
"
*
(
?
:
(
[
+
-
]
|
)
"
+
whitespace
+
"
*
(
\
\
d
+
)
|
)
)
"
+
whitespace
+
"
*
\
\
)
|
)
"
"
i
"
)
"
bool
"
:
new
RegExp
(
"
^
(
?
:
"
+
booleans
+
"
)
"
"
i
"
)
"
needsContext
"
:
new
RegExp
(
"
^
"
+
whitespace
+
"
*
[
>
+
~
]
|
:
(
even
|
odd
|
eq
|
gt
|
lt
|
nth
|
first
|
last
)
(
?
:
\
\
(
"
+
whitespace
+
"
*
(
(
?
:
-
\
\
d
)
?
\
\
d
*
)
"
+
whitespace
+
"
*
\
\
)
|
)
(
?
=
[
^
-
]
|
)
"
"
i
"
)
}
rinputs
=
/
^
(
?
:
input
|
select
|
textarea
|
button
)
/
i
rheader
=
/
^
h
\
d
/
i
rnative
=
/
^
[
^
{
]
+
\
{
\
s
*
\
[
native
\
w
/
rquickExpr
=
/
^
(
?
:
#
(
[
\
w
-
]
+
)
|
(
\
w
+
)
|
\
.
(
[
\
w
-
]
+
)
)
/
rsibling
=
/
[
+
~
]
/
runescape
=
new
RegExp
(
"
\
\
\
\
(
[
\
\
da
-
f
]
{
1
6
}
"
+
whitespace
+
"
?
|
(
"
+
whitespace
+
"
)
|
.
)
"
"
ig
"
)
funescape
=
function
(
_
escaped
escapedWhitespace
)
{
var
high
=
"
0x
"
+
escaped
-
0x10000
;
return
high
!
=
=
high
|
|
escapedWhitespace
?
escaped
:
high
<
0
?
String
.
fromCharCode
(
high
+
0x10000
)
:
String
.
fromCharCode
(
high
>
>
10
|
0xD800
high
&
0x3FF
|
0xDC00
)
;
}
rcssescape
=
/
(
[
\
0
-
\
x1f
\
x7f
]
|
^
-
?
\
d
)
|
^
-
|
[
^
\
0
-
\
x1f
\
x7f
-
\
uFFFF
\
w
-
]
/
g
fcssescape
=
function
(
ch
asCodePoint
)
{
if
(
asCodePoint
)
{
if
(
ch
=
=
=
"
\
0
"
)
{
return
"
\
uFFFD
"
;
}
return
ch
.
slice
(
0
-
1
)
+
"
\
\
"
+
ch
.
charCodeAt
(
ch
.
length
-
1
)
.
toString
(
16
)
+
"
"
;
}
return
"
\
\
"
+
ch
;
}
unloadHandler
=
function
(
)
{
setDocument
(
)
;
}
disabledAncestor
=
addCombinator
(
function
(
elem
)
{
return
elem
.
disabled
=
=
=
true
&
&
(
"
form
"
in
elem
|
|
"
label
"
in
elem
)
;
}
{
dir
:
"
parentNode
"
next
:
"
legend
"
}
)
;
try
{
push
.
apply
(
(
arr
=
slice
.
call
(
preferredDoc
.
childNodes
)
)
preferredDoc
.
childNodes
)
;
arr
[
preferredDoc
.
childNodes
.
length
]
.
nodeType
;
}
catch
(
e
)
{
push
=
{
apply
:
arr
.
length
?
function
(
target
els
)
{
push_native
.
apply
(
target
slice
.
call
(
els
)
)
;
}
:
function
(
target
els
)
{
var
j
=
target
.
length
i
=
0
;
while
(
(
target
[
j
+
+
]
=
els
[
i
+
+
]
)
)
{
}
target
.
length
=
j
-
1
;
}
}
;
}
function
Sizzle
(
selector
context
results
seed
)
{
var
m
i
elem
nid
match
groups
newSelector
newContext
=
context
&
&
context
.
ownerDocument
nodeType
=
context
?
context
.
nodeType
:
9
;
results
=
results
|
|
[
]
;
if
(
typeof
selector
!
=
=
"
string
"
|
|
!
selector
|
|
nodeType
!
=
=
1
&
&
nodeType
!
=
=
9
&
&
nodeType
!
=
=
11
)
{
return
results
;
}
if
(
!
seed
)
{
if
(
(
context
?
context
.
ownerDocument
|
|
context
:
preferredDoc
)
!
=
=
document
)
{
setDocument
(
context
)
;
}
context
=
context
|
|
document
;
if
(
documentIsHTML
)
{
if
(
nodeType
!
=
=
11
&
&
(
match
=
rquickExpr
.
exec
(
selector
)
)
)
{
if
(
(
m
=
match
[
1
]
)
)
{
if
(
nodeType
=
=
=
9
)
{
if
(
(
elem
=
context
.
getElementById
(
m
)
)
)
{
if
(
elem
.
id
=
=
=
m
)
{
results
.
push
(
elem
)
;
return
results
;
}
}
else
{
return
results
;
}
}
else
{
if
(
newContext
&
&
(
elem
=
newContext
.
getElementById
(
m
)
)
&
&
contains
(
context
elem
)
&
&
elem
.
id
=
=
=
m
)
{
results
.
push
(
elem
)
;
return
results
;
}
}
}
else
if
(
match
[
2
]
)
{
push
.
apply
(
results
context
.
getElementsByTagName
(
selector
)
)
;
return
results
;
}
else
if
(
(
m
=
match
[
3
]
)
&
&
support
.
getElementsByClassName
&
&
context
.
getElementsByClassName
)
{
push
.
apply
(
results
context
.
getElementsByClassName
(
m
)
)
;
return
results
;
}
}
if
(
support
.
qsa
&
&
!
compilerCache
[
selector
+
"
"
]
&
&
(
!
rbuggyQSA
|
|
!
rbuggyQSA
.
test
(
selector
)
)
)
{
if
(
nodeType
!
=
=
1
)
{
newContext
=
context
;
newSelector
=
selector
;
}
else
if
(
context
.
nodeName
.
toLowerCase
(
)
!
=
=
"
object
"
)
{
if
(
(
nid
=
context
.
getAttribute
(
"
id
"
)
)
)
{
nid
=
nid
.
replace
(
rcssescape
fcssescape
)
;
}
else
{
context
.
setAttribute
(
"
id
"
(
nid
=
expando
)
)
;
}
groups
=
tokenize
(
selector
)
;
i
=
groups
.
length
;
while
(
i
-
-
)
{
groups
[
i
]
=
"
#
"
+
nid
+
"
"
+
toSelector
(
groups
[
i
]
)
;
}
newSelector
=
groups
.
join
(
"
"
)
;
newContext
=
rsibling
.
test
(
selector
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
;
}
if
(
newSelector
)
{
try
{
push
.
apply
(
results
newContext
.
querySelectorAll
(
newSelector
)
)
;
return
results
;
}
catch
(
qsaError
)
{
}
finally
{
if
(
nid
=
=
=
expando
)
{
context
.
removeAttribute
(
"
id
"
)
;
}
}
}
}
}
}
return
select
(
selector
.
replace
(
rtrim
"
1
"
)
context
results
seed
)
;
}
function
createCache
(
)
{
var
keys
=
[
]
;
function
cache
(
key
value
)
{
if
(
keys
.
push
(
key
+
"
"
)
>
Expr
.
cacheLength
)
{
delete
cache
[
keys
.
shift
(
)
]
;
}
return
(
cache
[
key
+
"
"
]
=
value
)
;
}
return
cache
;
}
function
markFunction
(
fn
)
{
fn
[
expando
]
=
true
;
return
fn
;
}
function
assert
(
fn
)
{
var
el
=
document
.
createElement
(
"
fieldset
"
)
;
try
{
return
!
!
fn
(
el
)
;
}
catch
(
e
)
{
return
false
;
}
finally
{
if
(
el
.
parentNode
)
{
el
.
parentNode
.
removeChild
(
el
)
;
}
el
=
null
;
}
}
function
addHandle
(
attrs
handler
)
{
var
arr
=
attrs
.
split
(
"
|
"
)
i
=
arr
.
length
;
while
(
i
-
-
)
{
Expr
.
attrHandle
[
arr
[
i
]
]
=
handler
;
}
}
function
siblingCheck
(
a
b
)
{
var
cur
=
b
&
&
a
diff
=
cur
&
&
a
.
nodeType
=
=
=
1
&
&
b
.
nodeType
=
=
=
1
&
&
a
.
sourceIndex
-
b
.
sourceIndex
;
if
(
diff
)
{
return
diff
;
}
if
(
cur
)
{
while
(
(
cur
=
cur
.
nextSibling
)
)
{
if
(
cur
=
=
=
b
)
{
return
-
1
;
}
}
}
return
a
?
1
:
-
1
;
}
function
createInputPseudo
(
type
)
{
return
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
type
;
}
;
}
function
createButtonPseudo
(
type
)
{
return
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
(
name
=
=
=
"
input
"
|
|
name
=
=
=
"
button
"
)
&
&
elem
.
type
=
=
=
type
;
}
;
}
function
createDisabledPseudo
(
disabled
)
{
return
function
(
elem
)
{
if
(
"
form
"
in
elem
)
{
if
(
elem
.
parentNode
&
&
elem
.
disabled
=
=
=
false
)
{
if
(
"
label
"
in
elem
)
{
if
(
"
label
"
in
elem
.
parentNode
)
{
return
elem
.
parentNode
.
disabled
=
=
=
disabled
;
}
else
{
return
elem
.
disabled
=
=
=
disabled
;
}
}
return
elem
.
isDisabled
=
=
=
disabled
|
|
elem
.
isDisabled
!
=
=
!
disabled
&
&
disabledAncestor
(
elem
)
=
=
=
disabled
;
}
return
elem
.
disabled
=
=
=
disabled
;
}
else
if
(
"
label
"
in
elem
)
{
return
elem
.
disabled
=
=
=
disabled
;
}
return
false
;
}
;
}
function
createPositionalPseudo
(
fn
)
{
return
markFunction
(
function
(
argument
)
{
argument
=
+
argument
;
return
markFunction
(
function
(
seed
matches
)
{
var
j
matchIndexes
=
fn
(
[
]
seed
.
length
argument
)
i
=
matchIndexes
.
length
;
while
(
i
-
-
)
{
if
(
seed
[
(
j
=
matchIndexes
[
i
]
)
]
)
{
seed
[
j
]
=
!
(
matches
[
j
]
=
seed
[
j
]
)
;
}
}
}
)
;
}
)
;
}
function
testContext
(
context
)
{
return
context
&
&
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
&
&
context
;
}
support
=
Sizzle
.
support
=
{
}
;
isXML
=
Sizzle
.
isXML
=
function
(
elem
)
{
var
documentElement
=
elem
&
&
(
elem
.
ownerDocument
|
|
elem
)
.
documentElement
;
return
documentElement
?
documentElement
.
nodeName
!
=
=
"
HTML
"
:
false
;
}
;
setDocument
=
Sizzle
.
setDocument
=
function
(
node
)
{
var
hasCompare
subWindow
doc
=
node
?
node
.
ownerDocument
|
|
node
:
preferredDoc
;
if
(
doc
=
=
=
document
|
|
doc
.
nodeType
!
=
=
9
|
|
!
doc
.
documentElement
)
{
return
document
;
}
document
=
doc
;
docElem
=
document
.
documentElement
;
documentIsHTML
=
!
isXML
(
document
)
;
if
(
preferredDoc
!
=
=
document
&
&
(
subWindow
=
document
.
defaultView
)
&
&
subWindow
.
top
!
=
=
subWindow
)
{
if
(
subWindow
.
addEventListener
)
{
subWindow
.
addEventListener
(
"
unload
"
unloadHandler
false
)
;
}
else
if
(
subWindow
.
attachEvent
)
{
subWindow
.
attachEvent
(
"
onunload
"
unloadHandler
)
;
}
}
support
.
attributes
=
assert
(
function
(
el
)
{
el
.
className
=
"
i
"
;
return
!
el
.
getAttribute
(
"
className
"
)
;
}
)
;
support
.
getElementsByTagName
=
assert
(
function
(
el
)
{
el
.
appendChild
(
document
.
createComment
(
"
"
)
)
;
return
!
el
.
getElementsByTagName
(
"
*
"
)
.
length
;
}
)
;
support
.
getElementsByClassName
=
rnative
.
test
(
document
.
getElementsByClassName
)
;
support
.
getById
=
assert
(
function
(
el
)
{
docElem
.
appendChild
(
el
)
.
id
=
expando
;
return
!
document
.
getElementsByName
|
|
!
document
.
getElementsByName
(
expando
)
.
length
;
}
)
;
if
(
support
.
getById
)
{
Expr
.
filter
[
"
ID
"
]
=
function
(
id
)
{
var
attrId
=
id
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
return
elem
.
getAttribute
(
"
id
"
)
=
=
=
attrId
;
}
;
}
;
Expr
.
find
[
"
ID
"
]
=
function
(
id
context
)
{
if
(
typeof
context
.
getElementById
!
=
=
"
undefined
"
&
&
documentIsHTML
)
{
var
elem
=
context
.
getElementById
(
id
)
;
return
elem
?
[
elem
]
:
[
]
;
}
}
;
}
else
{
Expr
.
filter
[
"
ID
"
]
=
function
(
id
)
{
var
attrId
=
id
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
var
node
=
typeof
elem
.
getAttributeNode
!
=
=
"
undefined
"
&
&
elem
.
getAttributeNode
(
"
id
"
)
;
return
node
&
&
node
.
value
=
=
=
attrId
;
}
;
}
;
Expr
.
find
[
"
ID
"
]
=
function
(
id
context
)
{
if
(
typeof
context
.
getElementById
!
=
=
"
undefined
"
&
&
documentIsHTML
)
{
var
node
i
elems
elem
=
context
.
getElementById
(
id
)
;
if
(
elem
)
{
node
=
elem
.
getAttributeNode
(
"
id
"
)
;
if
(
node
&
&
node
.
value
=
=
=
id
)
{
return
[
elem
]
;
}
elems
=
context
.
getElementsByName
(
id
)
;
i
=
0
;
while
(
(
elem
=
elems
[
i
+
+
]
)
)
{
node
=
elem
.
getAttributeNode
(
"
id
"
)
;
if
(
node
&
&
node
.
value
=
=
=
id
)
{
return
[
elem
]
;
}
}
}
return
[
]
;
}
}
;
}
Expr
.
find
[
"
TAG
"
]
=
support
.
getElementsByTagName
?
function
(
tag
context
)
{
if
(
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
)
{
return
context
.
getElementsByTagName
(
tag
)
;
}
else
if
(
support
.
qsa
)
{
return
context
.
querySelectorAll
(
tag
)
;
}
}
:
function
(
tag
context
)
{
var
elem
tmp
=
[
]
i
=
0
results
=
context
.
getElementsByTagName
(
tag
)
;
if
(
tag
=
=
=
"
*
"
)
{
while
(
(
elem
=
results
[
i
+
+
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
tmp
.
push
(
elem
)
;
}
}
return
tmp
;
}
return
results
;
}
;
Expr
.
find
[
"
CLASS
"
]
=
support
.
getElementsByClassName
&
&
function
(
className
context
)
{
if
(
typeof
context
.
getElementsByClassName
!
=
=
"
undefined
"
&
&
documentIsHTML
)
{
return
context
.
getElementsByClassName
(
className
)
;
}
}
;
rbuggyMatches
=
[
]
;
rbuggyQSA
=
[
]
;
if
(
(
support
.
qsa
=
rnative
.
test
(
document
.
querySelectorAll
)
)
)
{
assert
(
function
(
el
)
{
docElem
.
appendChild
(
el
)
.
innerHTML
=
"
<
a
id
=
'
"
+
expando
+
"
'
>
<
/
a
>
"
+
"
<
select
id
=
'
"
+
expando
+
"
-
\
r
\
\
'
msallowcapture
=
'
'
>
"
+
"
<
option
selected
=
'
'
>
<
/
option
>
<
/
select
>
"
;
if
(
el
.
querySelectorAll
(
"
[
msallowcapture
^
=
'
'
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
[
*
^
]
=
"
+
whitespace
+
"
*
(
?
:
'
'
|
\
"
\
"
)
"
)
;
}
if
(
!
el
.
querySelectorAll
(
"
[
selected
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
\
\
[
"
+
whitespace
+
"
*
(
?
:
value
|
"
+
booleans
+
"
)
"
)
;
}
if
(
!
el
.
querySelectorAll
(
"
[
id
~
=
"
+
expando
+
"
-
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
~
=
"
)
;
}
if
(
!
el
.
querySelectorAll
(
"
:
checked
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
:
checked
"
)
;
}
if
(
!
el
.
querySelectorAll
(
"
a
#
"
+
expando
+
"
+
*
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
.
#
.
+
[
+
~
]
"
)
;
}
}
)
;
assert
(
function
(
el
)
{
el
.
innerHTML
=
"
<
a
href
=
'
'
disabled
=
'
disabled
'
>
<
/
a
>
"
+
"
<
select
disabled
=
'
disabled
'
>
<
option
/
>
<
/
select
>
"
;
var
input
=
document
.
createElement
(
"
input
"
)
;
input
.
setAttribute
(
"
type
"
"
hidden
"
)
;
el
.
appendChild
(
input
)
.
setAttribute
(
"
name
"
"
D
"
)
;
if
(
el
.
querySelectorAll
(
"
[
name
=
d
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
name
"
+
whitespace
+
"
*
[
*
^
|
!
~
]
?
=
"
)
;
}
if
(
el
.
querySelectorAll
(
"
:
enabled
"
)
.
length
!
=
=
2
)
{
rbuggyQSA
.
push
(
"
:
enabled
"
"
:
disabled
"
)
;
}
docElem
.
appendChild
(
el
)
.
disabled
=
true
;
if
(
el
.
querySelectorAll
(
"
:
disabled
"
)
.
length
!
=
=
2
)
{
rbuggyQSA
.
push
(
"
:
enabled
"
"
:
disabled
"
)
;
}
el
.
querySelectorAll
(
"
*
:
x
"
)
;
rbuggyQSA
.
push
(
"
.
*
:
"
)
;
}
)
;
}
if
(
(
support
.
matchesSelector
=
rnative
.
test
(
(
matches
=
docElem
.
matches
|
|
docElem
.
webkitMatchesSelector
|
|
docElem
.
mozMatchesSelector
|
|
docElem
.
oMatchesSelector
|
|
docElem
.
msMatchesSelector
)
)
)
)
{
assert
(
function
(
el
)
{
support
.
disconnectedMatch
=
matches
.
call
(
el
"
*
"
)
;
matches
.
call
(
el
"
[
s
!
=
'
'
]
:
x
"
)
;
rbuggyMatches
.
push
(
"
!
=
"
pseudos
)
;
}
)
;
}
rbuggyQSA
=
rbuggyQSA
.
length
&
&
new
RegExp
(
rbuggyQSA
.
join
(
"
|
"
)
)
;
rbuggyMatches
=
rbuggyMatches
.
length
&
&
new
RegExp
(
rbuggyMatches
.
join
(
"
|
"
)
)
;
hasCompare
=
rnative
.
test
(
docElem
.
compareDocumentPosition
)
;
contains
=
hasCompare
|
|
rnative
.
test
(
docElem
.
contains
)
?
function
(
a
b
)
{
var
adown
=
a
.
nodeType
=
=
=
9
?
a
.
documentElement
:
a
bup
=
b
&
&
b
.
parentNode
;
return
a
=
=
=
bup
|
|
!
!
(
bup
&
&
bup
.
nodeType
=
=
=
1
&
&
(
adown
.
contains
?
adown
.
contains
(
bup
)
:
a
.
compareDocumentPosition
&
&
a
.
compareDocumentPosition
(
bup
)
&
16
)
)
;
}
:
function
(
a
b
)
{
if
(
b
)
{
while
(
(
b
=
b
.
parentNode
)
)
{
if
(
b
=
=
=
a
)
{
return
true
;
}
}
}
return
false
;
}
;
sortOrder
=
hasCompare
?
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
return
0
;
}
var
compare
=
!
a
.
compareDocumentPosition
-
!
b
.
compareDocumentPosition
;
if
(
compare
)
{
return
compare
;
}
compare
=
(
a
.
ownerDocument
|
|
a
)
=
=
=
(
b
.
ownerDocument
|
|
b
)
?
a
.
compareDocumentPosition
(
b
)
:
1
;
if
(
compare
&
1
|
|
(
!
support
.
sortDetached
&
&
b
.
compareDocumentPosition
(
a
)
=
=
=
compare
)
)
{
if
(
a
=
=
=
document
|
|
a
.
ownerDocument
=
=
=
preferredDoc
&
&
contains
(
preferredDoc
a
)
)
{
return
-
1
;
}
if
(
b
=
=
=
document
|
|
b
.
ownerDocument
=
=
=
preferredDoc
&
&
contains
(
preferredDoc
b
)
)
{
return
1
;
}
return
sortInput
?
(
indexOf
(
sortInput
a
)
-
indexOf
(
sortInput
b
)
)
:
0
;
}
return
compare
&
4
?
-
1
:
1
;
}
:
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
return
0
;
}
var
cur
i
=
0
aup
=
a
.
parentNode
bup
=
b
.
parentNode
ap
=
[
a
]
bp
=
[
b
]
;
if
(
!
aup
|
|
!
bup
)
{
return
a
=
=
=
document
?
-
1
:
b
=
=
=
document
?
1
:
aup
?
-
1
:
bup
?
1
:
sortInput
?
(
indexOf
(
sortInput
a
)
-
indexOf
(
sortInput
b
)
)
:
0
;
}
else
if
(
aup
=
=
=
bup
)
{
return
siblingCheck
(
a
b
)
;
}
cur
=
a
;
while
(
(
cur
=
cur
.
parentNode
)
)
{
ap
.
unshift
(
cur
)
;
}
cur
=
b
;
while
(
(
cur
=
cur
.
parentNode
)
)
{
bp
.
unshift
(
cur
)
;
}
while
(
ap
[
i
]
=
=
=
bp
[
i
]
)
{
i
+
+
;
}
return
i
?
siblingCheck
(
ap
[
i
]
bp
[
i
]
)
:
ap
[
i
]
=
=
=
preferredDoc
?
-
1
:
bp
[
i
]
=
=
=
preferredDoc
?
1
:
0
;
}
;
return
document
;
}
;
Sizzle
.
matches
=
function
(
expr
elements
)
{
return
Sizzle
(
expr
null
null
elements
)
;
}
;
Sizzle
.
matchesSelector
=
function
(
elem
expr
)
{
if
(
(
elem
.
ownerDocument
|
|
elem
)
!
=
=
document
)
{
setDocument
(
elem
)
;
}
expr
=
expr
.
replace
(
rattributeQuotes
"
=
'
1
'
]
"
)
;
if
(
support
.
matchesSelector
&
&
documentIsHTML
&
&
!
compilerCache
[
expr
+
"
"
]
&
&
(
!
rbuggyMatches
|
|
!
rbuggyMatches
.
test
(
expr
)
)
&
&
(
!
rbuggyQSA
|
|
!
rbuggyQSA
.
test
(
expr
)
)
)
{
try
{
var
ret
=
matches
.
call
(
elem
expr
)
;
if
(
ret
|
|
support
.
disconnectedMatch
|
|
elem
.
document
&
&
elem
.
document
.
nodeType
!
=
=
11
)
{
return
ret
;
}
}
catch
(
e
)
{
}
}
return
Sizzle
(
expr
document
null
[
elem
]
)
.
length
>
0
;
}
;
Sizzle
.
contains
=
function
(
context
elem
)
{
if
(
(
context
.
ownerDocument
|
|
context
)
!
=
=
document
)
{
setDocument
(
context
)
;
}
return
contains
(
context
elem
)
;
}
;
Sizzle
.
attr
=
function
(
elem
name
)
{
if
(
(
elem
.
ownerDocument
|
|
elem
)
!
=
=
document
)
{
setDocument
(
elem
)
;
}
var
fn
=
Expr
.
attrHandle
[
name
.
toLowerCase
(
)
]
val
=
fn
&
&
hasOwn
.
call
(
Expr
.
attrHandle
name
.
toLowerCase
(
)
)
?
fn
(
elem
name
!
documentIsHTML
)
:
undefined
;
return
val
!
=
=
undefined
?
val
:
support
.
attributes
|
|
!
documentIsHTML
?
elem
.
getAttribute
(
name
)
:
(
val
=
elem
.
getAttributeNode
(
name
)
)
&
&
val
.
specified
?
val
.
value
:
null
;
}
;
Sizzle
.
escape
=
function
(
sel
)
{
return
(
sel
+
"
"
)
.
replace
(
rcssescape
fcssescape
)
;
}
;
Sizzle
.
error
=
function
(
msg
)
{
throw
new
Error
(
"
Syntax
error
unrecognized
expression
:
"
+
msg
)
;
}
;
Sizzle
.
uniqueSort
=
function
(
results
)
{
var
elem
duplicates
=
[
]
j
=
0
i
=
0
;
hasDuplicate
=
!
support
.
detectDuplicates
;
sortInput
=
!
support
.
sortStable
&
&
results
.
slice
(
0
)
;
results
.
sort
(
sortOrder
)
;
if
(
hasDuplicate
)
{
while
(
(
elem
=
results
[
i
+
+
]
)
)
{
if
(
elem
=
=
=
results
[
i
]
)
{
j
=
duplicates
.
push
(
i
)
;
}
}
while
(
j
-
-
)
{
results
.
splice
(
duplicates
[
j
]
1
)
;
}
}
sortInput
=
null
;
return
results
;
}
;
getText
=
Sizzle
.
getText
=
function
(
elem
)
{
var
node
ret
=
"
"
i
=
0
nodeType
=
elem
.
nodeType
;
if
(
!
nodeType
)
{
while
(
(
node
=
elem
[
i
+
+
]
)
)
{
ret
+
=
getText
(
node
)
;
}
}
else
if
(
nodeType
=
=
=
1
|
|
nodeType
=
=
=
9
|
|
nodeType
=
=
=
11
)
{
if
(
typeof
elem
.
textContent
=
=
=
"
string
"
)
{
return
elem
.
textContent
;
}
else
{
for
(
elem
=
elem
.
firstChild
;
elem
;
elem
=
elem
.
nextSibling
)
{
ret
+
=
getText
(
elem
)
;
}
}
}
else
if
(
nodeType
=
=
=
3
|
|
nodeType
=
=
=
4
)
{
return
elem
.
nodeValue
;
}
return
ret
;
}
;
Expr
=
Sizzle
.
selectors
=
{
cacheLength
:
50
createPseudo
:
markFunction
match
:
matchExpr
attrHandle
:
{
}
find
:
{
}
relative
:
{
"
>
"
:
{
dir
:
"
parentNode
"
first
:
true
}
"
"
:
{
dir
:
"
parentNode
"
}
"
+
"
:
{
dir
:
"
previousSibling
"
first
:
true
}
"
~
"
:
{
dir
:
"
previousSibling
"
}
}
preFilter
:
{
"
ATTR
"
:
function
(
match
)
{
match
[
1
]
=
match
[
1
]
.
replace
(
runescape
funescape
)
;
match
[
3
]
=
(
match
[
3
]
|
|
match
[
4
]
|
|
match
[
5
]
|
|
"
"
)
.
replace
(
runescape
funescape
)
;
if
(
match
[
2
]
=
=
=
"
~
=
"
)
{
match
[
3
]
=
"
"
+
match
[
3
]
+
"
"
;
}
return
match
.
slice
(
0
4
)
;
}
"
CHILD
"
:
function
(
match
)
{
match
[
1
]
=
match
[
1
]
.
toLowerCase
(
)
;
if
(
match
[
1
]
.
slice
(
0
3
)
=
=
=
"
nth
"
)
{
if
(
!
match
[
3
]
)
{
Sizzle
.
error
(
match
[
0
]
)
;
}
match
[
4
]
=
+
(
match
[
4
]
?
match
[
5
]
+
(
match
[
6
]
|
|
1
)
:
2
*
(
match
[
3
]
=
=
=
"
even
"
|
|
match
[
3
]
=
=
=
"
odd
"
)
)
;
match
[
5
]
=
+
(
(
match
[
7
]
+
match
[
8
]
)
|
|
match
[
3
]
=
=
=
"
odd
"
)
;
}
else
if
(
match
[
3
]
)
{
Sizzle
.
error
(
match
[
0
]
)
;
}
return
match
;
}
"
PSEUDO
"
:
function
(
match
)
{
var
excess
unquoted
=
!
match
[
6
]
&
&
match
[
2
]
;
if
(
matchExpr
[
"
CHILD
"
]
.
test
(
match
[
0
]
)
)
{
return
null
;
}
if
(
match
[
3
]
)
{
match
[
2
]
=
match
[
4
]
|
|
match
[
5
]
|
|
"
"
;
}
else
if
(
unquoted
&
&
rpseudo
.
test
(
unquoted
)
&
&
(
excess
=
tokenize
(
unquoted
true
)
)
&
&
(
excess
=
unquoted
.
indexOf
(
"
)
"
unquoted
.
length
-
excess
)
-
unquoted
.
length
)
)
{
match
[
0
]
=
match
[
0
]
.
slice
(
0
excess
)
;
match
[
2
]
=
unquoted
.
slice
(
0
excess
)
;
}
return
match
.
slice
(
0
3
)
;
}
}
filter
:
{
"
TAG
"
:
function
(
nodeNameSelector
)
{
var
nodeName
=
nodeNameSelector
.
replace
(
runescape
funescape
)
.
toLowerCase
(
)
;
return
nodeNameSelector
=
=
=
"
*
"
?
function
(
)
{
return
true
;
}
:
function
(
elem
)
{
return
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
nodeName
;
}
;
}
"
CLASS
"
:
function
(
className
)
{
var
pattern
=
classCache
[
className
+
"
"
]
;
return
pattern
|
|
(
pattern
=
new
RegExp
(
"
(
^
|
"
+
whitespace
+
"
)
"
+
className
+
"
(
"
+
whitespace
+
"
|
)
"
)
)
&
&
classCache
(
className
function
(
elem
)
{
return
pattern
.
test
(
typeof
elem
.
className
=
=
=
"
string
"
&
&
elem
.
className
|
|
typeof
elem
.
getAttribute
!
=
=
"
undefined
"
&
&
elem
.
getAttribute
(
"
class
"
)
|
|
"
"
)
;
}
)
;
}
"
ATTR
"
:
function
(
name
operator
check
)
{
return
function
(
elem
)
{
var
result
=
Sizzle
.
attr
(
elem
name
)
;
if
(
result
=
=
null
)
{
return
operator
=
=
=
"
!
=
"
;
}
if
(
!
operator
)
{
return
true
;
}
result
+
=
"
"
;
return
operator
=
=
=
"
=
"
?
result
=
=
=
check
:
operator
=
=
=
"
!
=
"
?
result
!
=
=
check
:
operator
=
=
=
"
^
=
"
?
check
&
&
result
.
indexOf
(
check
)
=
=
=
0
:
operator
=
=
=
"
*
=
"
?
check
&
&
result
.
indexOf
(
check
)
>
-
1
:
operator
=
=
=
"
=
"
?
check
&
&
result
.
slice
(
-
check
.
length
)
=
=
=
check
:
operator
=
=
=
"
~
=
"
?
(
"
"
+
result
.
replace
(
rwhitespace
"
"
)
+
"
"
)
.
indexOf
(
check
)
>
-
1
:
operator
=
=
=
"
|
=
"
?
result
=
=
=
check
|
|
result
.
slice
(
0
check
.
length
+
1
)
=
=
=
check
+
"
-
"
:
false
;
}
;
}
"
CHILD
"
:
function
(
type
what
argument
first
last
)
{
var
simple
=
type
.
slice
(
0
3
)
!
=
=
"
nth
"
forward
=
type
.
slice
(
-
4
)
!
=
=
"
last
"
ofType
=
what
=
=
=
"
of
-
type
"
;
return
first
=
=
=
1
&
&
last
=
=
=
0
?
function
(
elem
)
{
return
!
!
elem
.
parentNode
;
}
:
function
(
elem
context
xml
)
{
var
cache
uniqueCache
outerCache
node
nodeIndex
start
dir
=
simple
!
=
=
forward
?
"
nextSibling
"
:
"
previousSibling
"
parent
=
elem
.
parentNode
name
=
ofType
&
&
elem
.
nodeName
.
toLowerCase
(
)
useCache
=
!
xml
&
&
!
ofType
diff
=
false
;
if
(
parent
)
{
if
(
simple
)
{
while
(
dir
)
{
node
=
elem
;
while
(
(
node
=
node
[
dir
]
)
)
{
if
(
ofType
?
node
.
nodeName
.
toLowerCase
(
)
=
=
=
name
:
node
.
nodeType
=
=
=
1
)
{
return
false
;
}
}
start
=
dir
=
type
=
=
=
"
only
"
&
&
!
start
&
&
"
nextSibling
"
;
}
return
true
;
}
start
=
[
forward
?
parent
.
firstChild
:
parent
.
lastChild
]
;
if
(
forward
&
&
useCache
)
{
node
=
parent
;
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
cache
=
uniqueCache
[
type
]
|
|
[
]
;
nodeIndex
=
cache
[
0
]
=
=
=
dirruns
&
&
cache
[
1
]
;
diff
=
nodeIndex
&
&
cache
[
2
]
;
node
=
nodeIndex
&
&
parent
.
childNodes
[
nodeIndex
]
;
while
(
(
node
=
+
+
nodeIndex
&
&
node
&
&
node
[
dir
]
|
|
(
diff
=
nodeIndex
=
0
)
|
|
start
.
pop
(
)
)
)
{
if
(
node
.
nodeType
=
=
=
1
&
&
+
+
diff
&
&
node
=
=
=
elem
)
{
uniqueCache
[
type
]
=
[
dirruns
nodeIndex
diff
]
;
break
;
}
}
}
else
{
if
(
useCache
)
{
node
=
elem
;
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
cache
=
uniqueCache
[
type
]
|
|
[
]
;
nodeIndex
=
cache
[
0
]
=
=
=
dirruns
&
&
cache
[
1
]
;
diff
=
nodeIndex
;
}
if
(
diff
=
=
=
false
)
{
while
(
(
node
=
+
+
nodeIndex
&
&
node
&
&
node
[
dir
]
|
|
(
diff
=
nodeIndex
=
0
)
|
|
start
.
pop
(
)
)
)
{
if
(
(
ofType
?
node
.
nodeName
.
toLowerCase
(
)
=
=
=
name
:
node
.
nodeType
=
=
=
1
)
&
&
+
+
diff
)
{
if
(
useCache
)
{
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
uniqueCache
[
type
]
=
[
dirruns
diff
]
;
}
if
(
node
=
=
=
elem
)
{
break
;
}
}
}
}
}
diff
-
=
last
;
return
diff
=
=
=
first
|
|
(
diff
%
first
=
=
=
0
&
&
diff
/
first
>
=
0
)
;
}
}
;
}
"
PSEUDO
"
:
function
(
pseudo
argument
)
{
var
args
fn
=
Expr
.
pseudos
[
pseudo
]
|
|
Expr
.
setFilters
[
pseudo
.
toLowerCase
(
)
]
|
|
Sizzle
.
error
(
"
unsupported
pseudo
:
"
+
pseudo
)
;
if
(
fn
[
expando
]
)
{
return
fn
(
argument
)
;
}
if
(
fn
.
length
>
1
)
{
args
=
[
pseudo
pseudo
"
"
argument
]
;
return
Expr
.
setFilters
.
hasOwnProperty
(
pseudo
.
toLowerCase
(
)
)
?
markFunction
(
function
(
seed
matches
)
{
var
idx
matched
=
fn
(
seed
argument
)
i
=
matched
.
length
;
while
(
i
-
-
)
{
idx
=
indexOf
(
seed
matched
[
i
]
)
;
seed
[
idx
]
=
!
(
matches
[
idx
]
=
matched
[
i
]
)
;
}
}
)
:
function
(
elem
)
{
return
fn
(
elem
0
args
)
;
}
;
}
return
fn
;
}
}
pseudos
:
{
"
not
"
:
markFunction
(
function
(
selector
)
{
var
input
=
[
]
results
=
[
]
matcher
=
compile
(
selector
.
replace
(
rtrim
"
1
"
)
)
;
return
matcher
[
expando
]
?
markFunction
(
function
(
seed
matches
context
xml
)
{
var
elem
unmatched
=
matcher
(
seed
null
xml
[
]
)
i
=
seed
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
unmatched
[
i
]
)
)
{
seed
[
i
]
=
!
(
matches
[
i
]
=
elem
)
;
}
}
}
)
:
function
(
elem
context
xml
)
{
input
[
0
]
=
elem
;
matcher
(
input
null
xml
results
)
;
input
[
0
]
=
null
;
return
!
results
.
pop
(
)
;
}
;
}
)
"
has
"
:
markFunction
(
function
(
selector
)
{
return
function
(
elem
)
{
return
Sizzle
(
selector
elem
)
.
length
>
0
;
}
;
}
)
"
contains
"
:
markFunction
(
function
(
text
)
{
text
=
text
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
return
(
elem
.
textContent
|
|
elem
.
innerText
|
|
getText
(
elem
)
)
.
indexOf
(
text
)
>
-
1
;
}
;
}
)
"
lang
"
:
markFunction
(
function
(
lang
)
{
if
(
!
ridentifier
.
test
(
lang
|
|
"
"
)
)
{
Sizzle
.
error
(
"
unsupported
lang
:
"
+
lang
)
;
}
lang
=
lang
.
replace
(
runescape
funescape
)
.
toLowerCase
(
)
;
return
function
(
elem
)
{
var
elemLang
;
do
{
if
(
(
elemLang
=
documentIsHTML
?
elem
.
lang
:
elem
.
getAttribute
(
"
xml
:
lang
"
)
|
|
elem
.
getAttribute
(
"
lang
"
)
)
)
{
elemLang
=
elemLang
.
toLowerCase
(
)
;
return
elemLang
=
=
=
lang
|
|
elemLang
.
indexOf
(
lang
+
"
-
"
)
=
=
=
0
;
}
}
while
(
(
elem
=
elem
.
parentNode
)
&
&
elem
.
nodeType
=
=
=
1
)
;
return
false
;
}
;
}
)
"
target
"
:
function
(
elem
)
{
var
hash
=
window
.
location
&
&
window
.
location
.
hash
;
return
hash
&
&
hash
.
slice
(
1
)
=
=
=
elem
.
id
;
}
"
root
"
:
function
(
elem
)
{
return
elem
=
=
=
docElem
;
}
"
focus
"
:
function
(
elem
)
{
return
elem
=
=
=
document
.
activeElement
&
&
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
&
&
!
!
(
elem
.
type
|
|
elem
.
href
|
|
~
elem
.
tabIndex
)
;
}
"
enabled
"
:
createDisabledPseudo
(
false
)
"
disabled
"
:
createDisabledPseudo
(
true
)
"
checked
"
:
function
(
elem
)
{
var
nodeName
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
(
nodeName
=
=
=
"
input
"
&
&
!
!
elem
.
checked
)
|
|
(
nodeName
=
=
=
"
option
"
&
&
!
!
elem
.
selected
)
;
}
"
selected
"
:
function
(
elem
)
{
if
(
elem
.
parentNode
)
{
elem
.
parentNode
.
selectedIndex
;
}
return
elem
.
selected
=
=
=
true
;
}
"
empty
"
:
function
(
elem
)
{
for
(
elem
=
elem
.
firstChild
;
elem
;
elem
=
elem
.
nextSibling
)
{
if
(
elem
.
nodeType
<
6
)
{
return
false
;
}
}
return
true
;
}
"
parent
"
:
function
(
elem
)
{
return
!
Expr
.
pseudos
[
"
empty
"
]
(
elem
)
;
}
"
header
"
:
function
(
elem
)
{
return
rheader
.
test
(
elem
.
nodeName
)
;
}
"
input
"
:
function
(
elem
)
{
return
rinputs
.
test
(
elem
.
nodeName
)
;
}
"
button
"
:
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
"
button
"
|
|
name
=
=
=
"
button
"
;
}
"
text
"
:
function
(
elem
)
{
var
attr
;
return
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
"
text
"
&
&
(
(
attr
=
elem
.
getAttribute
(
"
type
"
)
)
=
=
null
|
|
attr
.
toLowerCase
(
)
=
=
=
"
text
"
)
;
}
"
first
"
:
createPositionalPseudo
(
function
(
)
{
return
[
0
]
;
}
)
"
last
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
return
[
length
-
1
]
;
}
)
"
eq
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
return
[
argument
<
0
?
argument
+
length
:
argument
]
;
}
)
"
even
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
var
i
=
0
;
for
(
;
i
<
length
;
i
+
=
2
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
odd
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
var
i
=
1
;
for
(
;
i
<
length
;
i
+
=
2
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
lt
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
var
i
=
argument
<
0
?
argument
+
length
:
argument
;
for
(
;
-
-
i
>
=
0
;
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
gt
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
var
i
=
argument
<
0
?
argument
+
length
:
argument
;
for
(
;
+
+
i
<
length
;
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
}
}
;
Expr
.
pseudos
[
"
nth
"
]
=
Expr
.
pseudos
[
"
eq
"
]
;
for
(
i
in
{
radio
:
true
checkbox
:
true
file
:
true
password
:
true
image
:
true
}
)
{
Expr
.
pseudos
[
i
]
=
createInputPseudo
(
i
)
;
}
for
(
i
in
{
submit
:
true
reset
:
true
}
)
{
Expr
.
pseudos
[
i
]
=
createButtonPseudo
(
i
)
;
}
function
setFilters
(
)
{
}
setFilters
.
prototype
=
Expr
.
filters
=
Expr
.
pseudos
;
Expr
.
setFilters
=
new
setFilters
(
)
;
tokenize
=
Sizzle
.
tokenize
=
function
(
selector
parseOnly
)
{
var
matched
match
tokens
type
soFar
groups
preFilters
cached
=
tokenCache
[
selector
+
"
"
]
;
if
(
cached
)
{
return
parseOnly
?
0
:
cached
.
slice
(
0
)
;
}
soFar
=
selector
;
groups
=
[
]
;
preFilters
=
Expr
.
preFilter
;
while
(
soFar
)
{
if
(
!
matched
|
|
(
match
=
rcomma
.
exec
(
soFar
)
)
)
{
if
(
match
)
{
soFar
=
soFar
.
slice
(
match
[
0
]
.
length
)
|
|
soFar
;
}
groups
.
push
(
(
tokens
=
[
]
)
)
;
}
matched
=
false
;
if
(
(
match
=
rcombinators
.
exec
(
soFar
)
)
)
{
matched
=
match
.
shift
(
)
;
tokens
.
push
(
{
value
:
matched
type
:
match
[
0
]
.
replace
(
rtrim
"
"
)
}
)
;
soFar
=
soFar
.
slice
(
matched
.
length
)
;
}
for
(
type
in
Expr
.
filter
)
{
if
(
(
match
=
matchExpr
[
type
]
.
exec
(
soFar
)
)
&
&
(
!
preFilters
[
type
]
|
|
(
match
=
preFilters
[
type
]
(
match
)
)
)
)
{
matched
=
match
.
shift
(
)
;
tokens
.
push
(
{
value
:
matched
type
:
type
matches
:
match
}
)
;
soFar
=
soFar
.
slice
(
matched
.
length
)
;
}
}
if
(
!
matched
)
{
break
;
}
}
return
parseOnly
?
soFar
.
length
:
soFar
?
Sizzle
.
error
(
selector
)
:
tokenCache
(
selector
groups
)
.
slice
(
0
)
;
}
;
function
toSelector
(
tokens
)
{
var
i
=
0
len
=
tokens
.
length
selector
=
"
"
;
for
(
;
i
<
len
;
i
+
+
)
{
selector
+
=
tokens
[
i
]
.
value
;
}
return
selector
;
}
function
addCombinator
(
matcher
combinator
base
)
{
var
dir
=
combinator
.
dir
skip
=
combinator
.
next
key
=
skip
|
|
dir
checkNonElements
=
base
&
&
key
=
=
=
"
parentNode
"
doneName
=
done
+
+
;
return
combinator
.
first
?
function
(
elem
context
xml
)
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
return
matcher
(
elem
context
xml
)
;
}
}
return
false
;
}
:
function
(
elem
context
xml
)
{
var
oldCache
uniqueCache
outerCache
newCache
=
[
dirruns
doneName
]
;
if
(
xml
)
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
if
(
matcher
(
elem
context
xml
)
)
{
return
true
;
}
}
}
}
else
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
outerCache
=
elem
[
expando
]
|
|
(
elem
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
elem
.
uniqueID
]
|
|
(
outerCache
[
elem
.
uniqueID
]
=
{
}
)
;
if
(
skip
&
&
skip
=
=
=
elem
.
nodeName
.
toLowerCase
(
)
)
{
elem
=
elem
[
dir
]
|
|
elem
;
}
else
if
(
(
oldCache
=
uniqueCache
[
key
]
)
&
&
oldCache
[
0
]
=
=
=
dirruns
&
&
oldCache
[
1
]
=
=
=
doneName
)
{
return
(
newCache
[
2
]
=
oldCache
[
2
]
)
;
}
else
{
uniqueCache
[
key
]
=
newCache
;
if
(
(
newCache
[
2
]
=
matcher
(
elem
context
xml
)
)
)
{
return
true
;
}
}
}
}
}
return
false
;
}
;
}
function
elementMatcher
(
matchers
)
{
return
matchers
.
length
>
1
?
function
(
elem
context
xml
)
{
var
i
=
matchers
.
length
;
while
(
i
-
-
)
{
if
(
!
matchers
[
i
]
(
elem
context
xml
)
)
{
return
false
;
}
}
return
true
;
}
:
matchers
[
0
]
;
}
function
multipleContexts
(
selector
contexts
results
)
{
var
i
=
0
len
=
contexts
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
Sizzle
(
selector
contexts
[
i
]
results
)
;
}
return
results
;
}
function
condense
(
unmatched
map
filter
context
xml
)
{
var
elem
newUnmatched
=
[
]
i
=
0
len
=
unmatched
.
length
mapped
=
map
!
=
null
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
(
elem
=
unmatched
[
i
]
)
)
{
if
(
!
filter
|
|
filter
(
elem
context
xml
)
)
{
newUnmatched
.
push
(
elem
)
;
if
(
mapped
)
{
map
.
push
(
i
)
;
}
}
}
}
return
newUnmatched
;
}
function
setMatcher
(
preFilter
selector
matcher
postFilter
postFinder
postSelector
)
{
if
(
postFilter
&
&
!
postFilter
[
expando
]
)
{
postFilter
=
setMatcher
(
postFilter
)
;
}
if
(
postFinder
&
&
!
postFinder
[
expando
]
)
{
postFinder
=
setMatcher
(
postFinder
postSelector
)
;
}
return
markFunction
(
function
(
seed
results
context
xml
)
{
var
temp
i
elem
preMap
=
[
]
postMap
=
[
]
preexisting
=
results
.
length
elems
=
seed
|
|
multipleContexts
(
selector
|
|
"
*
"
context
.
nodeType
?
[
context
]
:
context
[
]
)
matcherIn
=
preFilter
&
&
(
seed
|
|
!
selector
)
?
condense
(
elems
preMap
preFilter
context
xml
)
:
elems
matcherOut
=
matcher
?
postFinder
|
|
(
seed
?
preFilter
:
preexisting
|
|
postFilter
)
?
[
]
:
results
:
matcherIn
;
if
(
matcher
)
{
matcher
(
matcherIn
matcherOut
context
xml
)
;
}
if
(
postFilter
)
{
temp
=
condense
(
matcherOut
postMap
)
;
postFilter
(
temp
[
]
context
xml
)
;
i
=
temp
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
temp
[
i
]
)
)
{
matcherOut
[
postMap
[
i
]
]
=
!
(
matcherIn
[
postMap
[
i
]
]
=
elem
)
;
}
}
}
if
(
seed
)
{
if
(
postFinder
|
|
preFilter
)
{
if
(
postFinder
)
{
temp
=
[
]
;
i
=
matcherOut
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
matcherOut
[
i
]
)
)
{
temp
.
push
(
(
matcherIn
[
i
]
=
elem
)
)
;
}
}
postFinder
(
null
(
matcherOut
=
[
]
)
temp
xml
)
;
}
i
=
matcherOut
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
matcherOut
[
i
]
)
&
&
(
temp
=
postFinder
?
indexOf
(
seed
elem
)
:
preMap
[
i
]
)
>
-
1
)
{
seed
[
temp
]
=
!
(
results
[
temp
]
=
elem
)
;
}
}
}
}
else
{
matcherOut
=
condense
(
matcherOut
=
=
=
results
?
matcherOut
.
splice
(
preexisting
matcherOut
.
length
)
:
matcherOut
)
;
if
(
postFinder
)
{
postFinder
(
null
results
matcherOut
xml
)
;
}
else
{
push
.
apply
(
results
matcherOut
)
;
}
}
}
)
;
}
function
matcherFromTokens
(
tokens
)
{
var
checkContext
matcher
j
len
=
tokens
.
length
leadingRelative
=
Expr
.
relative
[
tokens
[
0
]
.
type
]
implicitRelative
=
leadingRelative
|
|
Expr
.
relative
[
"
"
]
i
=
leadingRelative
?
1
:
0
matchContext
=
addCombinator
(
function
(
elem
)
{
return
elem
=
=
=
checkContext
;
}
implicitRelative
true
)
matchAnyContext
=
addCombinator
(
function
(
elem
)
{
return
indexOf
(
checkContext
elem
)
>
-
1
;
}
implicitRelative
true
)
matchers
=
[
function
(
elem
context
xml
)
{
var
ret
=
(
!
leadingRelative
&
&
(
xml
|
|
context
!
=
=
outermostContext
)
)
|
|
(
(
checkContext
=
context
)
.
nodeType
?
matchContext
(
elem
context
xml
)
:
matchAnyContext
(
elem
context
xml
)
)
;
checkContext
=
null
;
return
ret
;
}
]
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
(
matcher
=
Expr
.
relative
[
tokens
[
i
]
.
type
]
)
)
{
matchers
=
[
addCombinator
(
elementMatcher
(
matchers
)
matcher
)
]
;
}
else
{
matcher
=
Expr
.
filter
[
tokens
[
i
]
.
type
]
.
apply
(
null
tokens
[
i
]
.
matches
)
;
if
(
matcher
[
expando
]
)
{
j
=
+
+
i
;
for
(
;
j
<
len
;
j
+
+
)
{
if
(
Expr
.
relative
[
tokens
[
j
]
.
type
]
)
{
break
;
}
}
return
setMatcher
(
i
>
1
&
&
elementMatcher
(
matchers
)
i
>
1
&
&
toSelector
(
tokens
.
slice
(
0
i
-
1
)
.
concat
(
{
value
:
tokens
[
i
-
2
]
.
type
=
=
=
"
"
?
"
*
"
:
"
"
}
)
)
.
replace
(
rtrim
"
1
"
)
matcher
i
<
j
&
&
matcherFromTokens
(
tokens
.
slice
(
i
j
)
)
j
<
len
&
&
matcherFromTokens
(
(
tokens
=
tokens
.
slice
(
j
)
)
)
j
<
len
&
&
toSelector
(
tokens
)
)
;
}
matchers
.
push
(
matcher
)
;
}
}
return
elementMatcher
(
matchers
)
;
}
function
matcherFromGroupMatchers
(
elementMatchers
setMatchers
)
{
var
bySet
=
setMatchers
.
length
>
0
byElement
=
elementMatchers
.
length
>
0
superMatcher
=
function
(
seed
context
xml
results
outermost
)
{
var
elem
j
matcher
matchedCount
=
0
i
=
"
0
"
unmatched
=
seed
&
&
[
]
setMatched
=
[
]
contextBackup
=
outermostContext
elems
=
seed
|
|
byElement
&
&
Expr
.
find
[
"
TAG
"
]
(
"
*
"
outermost
)
dirrunsUnique
=
(
dirruns
+
=
contextBackup
=
=
null
?
1
:
Math
.
random
(
)
|
|
0
.
1
)
len
=
elems
.
length
;
if
(
outermost
)
{
outermostContext
=
context
=
=
=
document
|
|
context
|
|
outermost
;
}
for
(
;
i
!
=
=
len
&
&
(
elem
=
elems
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
byElement
&
&
elem
)
{
j
=
0
;
if
(
!
context
&
&
elem
.
ownerDocument
!
=
=
document
)
{
setDocument
(
elem
)
;
xml
=
!
documentIsHTML
;
}
while
(
(
matcher
=
elementMatchers
[
j
+
+
]
)
)
{
if
(
matcher
(
elem
context
|
|
document
xml
)
)
{
results
.
push
(
elem
)
;
break
;
}
}
if
(
outermost
)
{
dirruns
=
dirrunsUnique
;
}
}
if
(
bySet
)
{
if
(
(
elem
=
!
matcher
&
&
elem
)
)
{
matchedCount
-
-
;
}
if
(
seed
)
{
unmatched
.
push
(
elem
)
;
}
}
}
matchedCount
+
=
i
;
if
(
bySet
&
&
i
!
=
=
matchedCount
)
{
j
=
0
;
while
(
(
matcher
=
setMatchers
[
j
+
+
]
)
)
{
matcher
(
unmatched
setMatched
context
xml
)
;
}
if
(
seed
)
{
if
(
matchedCount
>
0
)
{
while
(
i
-
-
)
{
if
(
!
(
unmatched
[
i
]
|
|
setMatched
[
i
]
)
)
{
setMatched
[
i
]
=
pop
.
call
(
results
)
;
}
}
}
setMatched
=
condense
(
setMatched
)
;
}
push
.
apply
(
results
setMatched
)
;
if
(
outermost
&
&
!
seed
&
&
setMatched
.
length
>
0
&
&
(
matchedCount
+
setMatchers
.
length
)
>
1
)
{
Sizzle
.
uniqueSort
(
results
)
;
}
}
if
(
outermost
)
{
dirruns
=
dirrunsUnique
;
outermostContext
=
contextBackup
;
}
return
unmatched
;
}
;
return
bySet
?
markFunction
(
superMatcher
)
:
superMatcher
;
}
compile
=
Sizzle
.
compile
=
function
(
selector
match
)
{
var
i
setMatchers
=
[
]
elementMatchers
=
[
]
cached
=
compilerCache
[
selector
+
"
"
]
;
if
(
!
cached
)
{
if
(
!
match
)
{
match
=
tokenize
(
selector
)
;
}
i
=
match
.
length
;
while
(
i
-
-
)
{
cached
=
matcherFromTokens
(
match
[
i
]
)
;
if
(
cached
[
expando
]
)
{
setMatchers
.
push
(
cached
)
;
}
else
{
elementMatchers
.
push
(
cached
)
;
}
}
cached
=
compilerCache
(
selector
matcherFromGroupMatchers
(
elementMatchers
setMatchers
)
)
;
cached
.
selector
=
selector
;
}
return
cached
;
}
;
select
=
Sizzle
.
select
=
function
(
selector
context
results
seed
)
{
var
i
tokens
token
type
find
compiled
=
typeof
selector
=
=
=
"
function
"
&
&
selector
match
=
!
seed
&
&
tokenize
(
(
selector
=
compiled
.
selector
|
|
selector
)
)
;
results
=
results
|
|
[
]
;
if
(
match
.
length
=
=
=
1
)
{
tokens
=
match
[
0
]
=
match
[
0
]
.
slice
(
0
)
;
if
(
tokens
.
length
>
2
&
&
(
token
=
tokens
[
0
]
)
.
type
=
=
=
"
ID
"
&
&
context
.
nodeType
=
=
=
9
&
&
documentIsHTML
&
&
Expr
.
relative
[
tokens
[
1
]
.
type
]
)
{
context
=
(
Expr
.
find
[
"
ID
"
]
(
token
.
matches
[
0
]
.
replace
(
runescape
funescape
)
context
)
|
|
[
]
)
[
0
]
;
if
(
!
context
)
{
return
results
;
}
else
if
(
compiled
)
{
context
=
context
.
parentNode
;
}
selector
=
selector
.
slice
(
tokens
.
shift
(
)
.
value
.
length
)
;
}
i
=
matchExpr
[
"
needsContext
"
]
.
test
(
selector
)
?
0
:
tokens
.
length
;
while
(
i
-
-
)
{
token
=
tokens
[
i
]
;
if
(
Expr
.
relative
[
(
type
=
token
.
type
)
]
)
{
break
;
}
if
(
(
find
=
Expr
.
find
[
type
]
)
)
{
if
(
(
seed
=
find
(
token
.
matches
[
0
]
.
replace
(
runescape
funescape
)
rsibling
.
test
(
tokens
[
0
]
.
type
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
)
)
)
{
tokens
.
splice
(
i
1
)
;
selector
=
seed
.
length
&
&
toSelector
(
tokens
)
;
if
(
!
selector
)
{
push
.
apply
(
results
seed
)
;
return
results
;
}
break
;
}
}
}
}
(
compiled
|
|
compile
(
selector
match
)
)
(
seed
context
!
documentIsHTML
results
!
context
|
|
rsibling
.
test
(
selector
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
)
;
return
results
;
}
;
support
.
sortStable
=
expando
.
split
(
"
"
)
.
sort
(
sortOrder
)
.
join
(
"
"
)
=
=
=
expando
;
support
.
detectDuplicates
=
!
!
hasDuplicate
;
setDocument
(
)
;
support
.
sortDetached
=
assert
(
function
(
el
)
{
return
el
.
compareDocumentPosition
(
document
.
createElement
(
"
fieldset
"
)
)
&
1
;
}
)
;
if
(
!
assert
(
function
(
el
)
{
el
.
innerHTML
=
"
<
a
href
=
'
#
'
>
<
/
a
>
"
;
return
el
.
firstChild
.
getAttribute
(
"
href
"
)
=
=
=
"
#
"
;
}
)
)
{
addHandle
(
"
type
|
href
|
height
|
width
"
function
(
elem
name
isXML
)
{
if
(
!
isXML
)
{
return
elem
.
getAttribute
(
name
name
.
toLowerCase
(
)
=
=
=
"
type
"
?
1
:
2
)
;
}
}
)
;
}
if
(
!
support
.
attributes
|
|
!
assert
(
function
(
el
)
{
el
.
innerHTML
=
"
<
input
/
>
"
;
el
.
firstChild
.
setAttribute
(
"
value
"
"
"
)
;
return
el
.
firstChild
.
getAttribute
(
"
value
"
)
=
=
=
"
"
;
}
)
)
{
addHandle
(
"
value
"
function
(
elem
name
isXML
)
{
if
(
!
isXML
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
"
input
"
)
{
return
elem
.
defaultValue
;
}
}
)
;
}
if
(
!
assert
(
function
(
el
)
{
return
el
.
getAttribute
(
"
disabled
"
)
=
=
null
;
}
)
)
{
addHandle
(
booleans
function
(
elem
name
isXML
)
{
var
val
;
if
(
!
isXML
)
{
return
elem
[
name
]
=
=
=
true
?
name
.
toLowerCase
(
)
:
(
val
=
elem
.
getAttributeNode
(
name
)
)
&
&
val
.
specified
?
val
.
value
:
null
;
}
}
)
;
}
return
Sizzle
;
}
)
(
window
)
;
jQuery
.
find
=
Sizzle
;
jQuery
.
expr
=
Sizzle
.
selectors
;
jQuery
.
expr
[
"
:
"
]
=
jQuery
.
expr
.
pseudos
;
jQuery
.
uniqueSort
=
jQuery
.
unique
=
Sizzle
.
uniqueSort
;
jQuery
.
text
=
Sizzle
.
getText
;
jQuery
.
isXMLDoc
=
Sizzle
.
isXML
;
jQuery
.
contains
=
Sizzle
.
contains
;
jQuery
.
escapeSelector
=
Sizzle
.
escape
;
var
dir
=
function
(
elem
dir
until
)
{
var
matched
=
[
]
truncate
=
until
!
=
=
undefined
;
while
(
(
elem
=
elem
[
dir
]
)
&
&
elem
.
nodeType
!
=
=
9
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
if
(
truncate
&
&
jQuery
(
elem
)
.
is
(
until
)
)
{
break
;
}
matched
.
push
(
elem
)
;
}
}
return
matched
;
}
;
var
siblings
=
function
(
n
elem
)
{
var
matched
=
[
]
;
for
(
;
n
;
n
=
n
.
nextSibling
)
{
if
(
n
.
nodeType
=
=
=
1
&
&
n
!
=
=
elem
)
{
matched
.
push
(
n
)
;
}
}
return
matched
;
}
;
var
rneedsContext
=
jQuery
.
expr
.
match
.
needsContext
;
function
nodeName
(
elem
name
)
{
return
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
name
.
toLowerCase
(
)
;
}
;
var
rsingleTag
=
(
/
^
<
(
[
a
-
z
]
[
^
\
/
\
0
>
:
\
x20
\
t
\
r
\
n
\
f
]
*
)
[
\
x20
\
t
\
r
\
n
\
f
]
*
\
/
?
>
(
?
:
<
\
/
\
1
>
|
)
/
i
)
;
function
winnow
(
elements
qualifier
not
)
{
if
(
isFunction
(
qualifier
)
)
{
return
jQuery
.
grep
(
elements
function
(
elem
i
)
{
return
!
!
qualifier
.
call
(
elem
i
elem
)
!
=
=
not
;
}
)
;
}
if
(
qualifier
.
nodeType
)
{
return
jQuery
.
grep
(
elements
function
(
elem
)
{
return
(
elem
=
=
=
qualifier
)
!
=
=
not
;
}
)
;
}
if
(
typeof
qualifier
!
=
=
"
string
"
)
{
return
jQuery
.
grep
(
elements
function
(
elem
)
{
return
(
indexOf
.
call
(
qualifier
elem
)
>
-
1
)
!
=
=
not
;
}
)
;
}
return
jQuery
.
filter
(
qualifier
elements
not
)
;
}
jQuery
.
filter
=
function
(
expr
elems
not
)
{
var
elem
=
elems
[
0
]
;
if
(
not
)
{
expr
=
"
:
not
(
"
+
expr
+
"
)
"
;
}
if
(
elems
.
length
=
=
=
1
&
&
elem
.
nodeType
=
=
=
1
)
{
return
jQuery
.
find
.
matchesSelector
(
elem
expr
)
?
[
elem
]
:
[
]
;
}
return
jQuery
.
find
.
matches
(
expr
jQuery
.
grep
(
elems
function
(
elem
)
{
return
elem
.
nodeType
=
=
=
1
;
}
)
)
;
}
;
jQuery
.
fn
.
extend
(
{
find
:
function
(
selector
)
{
var
i
ret
len
=
this
.
length
self
=
this
;
if
(
typeof
selector
!
=
=
"
string
"
)
{
return
this
.
pushStack
(
jQuery
(
selector
)
.
filter
(
function
(
)
{
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
jQuery
.
contains
(
self
[
i
]
this
)
)
{
return
true
;
}
}
}
)
)
;
}
ret
=
this
.
pushStack
(
[
]
)
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
jQuery
.
find
(
selector
self
[
i
]
ret
)
;
}
return
len
>
1
?
jQuery
.
uniqueSort
(
ret
)
:
ret
;
}
filter
:
function
(
selector
)
{
return
this
.
pushStack
(
winnow
(
this
selector
|
|
[
]
false
)
)
;
}
not
:
function
(
selector
)
{
return
this
.
pushStack
(
winnow
(
this
selector
|
|
[
]
true
)
)
;
}
is
:
function
(
selector
)
{
return
!
!
winnow
(
this
typeof
selector
=
=
=
"
string
"
&
&
rneedsContext
.
test
(
selector
)
?
jQuery
(
selector
)
:
selector
|
|
[
]
false
)
.
length
;
}
}
)
;
var
rootjQuery
rquickExpr
=
/
^
(
?
:
\
s
*
(
<
[
\
w
\
W
]
+
>
)
[
^
>
]
*
|
#
(
[
\
w
-
]
+
)
)
/
init
=
jQuery
.
fn
.
init
=
function
(
selector
context
root
)
{
var
match
elem
;
if
(
!
selector
)
{
return
this
;
}
root
=
root
|
|
rootjQuery
;
if
(
typeof
selector
=
=
=
"
string
"
)
{
if
(
selector
[
0
]
=
=
=
"
<
"
&
&
selector
[
selector
.
length
-
1
]
=
=
=
"
>
"
&
&
selector
.
length
>
=
3
)
{
match
=
[
null
selector
null
]
;
}
else
{
match
=
rquickExpr
.
exec
(
selector
)
;
}
if
(
match
&
&
(
match
[
1
]
|
|
!
context
)
)
{
if
(
match
[
1
]
)
{
context
=
context
instanceof
jQuery
?
context
[
0
]
:
context
;
jQuery
.
merge
(
this
jQuery
.
parseHTML
(
match
[
1
]
context
&
&
context
.
nodeType
?
context
.
ownerDocument
|
|
context
:
document
true
)
)
;
if
(
rsingleTag
.
test
(
match
[
1
]
)
&
&
jQuery
.
isPlainObject
(
context
)
)
{
for
(
match
in
context
)
{
if
(
isFunction
(
this
[
match
]
)
)
{
this
[
match
]
(
context
[
match
]
)
;
}
else
{
this
.
attr
(
match
context
[
match
]
)
;
}
}
}
return
this
;
}
else
{
elem
=
document
.
getElementById
(
match
[
2
]
)
;
if
(
elem
)
{
this
[
0
]
=
elem
;
this
.
length
=
1
;
}
return
this
;
}
}
else
if
(
!
context
|
|
context
.
jquery
)
{
return
(
context
|
|
root
)
.
find
(
selector
)
;
}
else
{
return
this
.
constructor
(
context
)
.
find
(
selector
)
;
}
}
else
if
(
selector
.
nodeType
)
{
this
[
0
]
=
selector
;
this
.
length
=
1
;
return
this
;
}
else
if
(
isFunction
(
selector
)
)
{
return
root
.
ready
!
=
=
undefined
?
root
.
ready
(
selector
)
:
selector
(
jQuery
)
;
}
return
jQuery
.
makeArray
(
selector
this
)
;
}
;
init
.
prototype
=
jQuery
.
fn
;
rootjQuery
=
jQuery
(
document
)
;
var
rparentsprev
=
/
^
(
?
:
parents
|
prev
(
?
:
Until
|
All
)
)
/
guaranteedUnique
=
{
children
:
true
contents
:
true
next
:
true
prev
:
true
}
;
jQuery
.
fn
.
extend
(
{
has
:
function
(
target
)
{
var
targets
=
jQuery
(
target
this
)
l
=
targets
.
length
;
return
this
.
filter
(
function
(
)
{
var
i
=
0
;
for
(
;
i
<
l
;
i
+
+
)
{
if
(
jQuery
.
contains
(
this
targets
[
i
]
)
)
{
return
true
;
}
}
}
)
;
}
closest
:
function
(
selectors
context
)
{
var
cur
i
=
0
l
=
this
.
length
matched
=
[
]
targets
=
typeof
selectors
!
=
=
"
string
"
&
&
jQuery
(
selectors
)
;
if
(
!
rneedsContext
.
test
(
selectors
)
)
{
for
(
;
i
<
l
;
i
+
+
)
{
for
(
cur
=
this
[
i
]
;
cur
&
&
cur
!
=
=
context
;
cur
=
cur
.
parentNode
)
{
if
(
cur
.
nodeType
<
11
&
&
(
targets
?
targets
.
index
(
cur
)
>
-
1
:
cur
.
nodeType
=
=
=
1
&
&
jQuery
.
find
.
matchesSelector
(
cur
selectors
)
)
)
{
matched
.
push
(
cur
)
;
break
;
}
}
}
}
return
this
.
pushStack
(
matched
.
length
>
1
?
jQuery
.
uniqueSort
(
matched
)
:
matched
)
;
}
index
:
function
(
elem
)
{
if
(
!
elem
)
{
return
(
this
[
0
]
&
&
this
[
0
]
.
parentNode
)
?
this
.
first
(
)
.
prevAll
(
)
.
length
:
-
1
;
}
if
(
typeof
elem
=
=
=
"
string
"
)
{
return
indexOf
.
call
(
jQuery
(
elem
)
this
[
0
]
)
;
}
return
indexOf
.
call
(
this
elem
.
jquery
?
elem
[
0
]
:
elem
)
;
}
add
:
function
(
selector
context
)
{
return
this
.
pushStack
(
jQuery
.
uniqueSort
(
jQuery
.
merge
(
this
.
get
(
)
jQuery
(
selector
context
)
)
)
)
;
}
addBack
:
function
(
selector
)
{
return
this
.
add
(
selector
=
=
null
?
this
.
prevObject
:
this
.
prevObject
.
filter
(
selector
)
)
;
}
}
)
;
function
sibling
(
cur
dir
)
{
while
(
(
cur
=
cur
[
dir
]
)
&
&
cur
.
nodeType
!
=
=
1
)
{
}
return
cur
;
}
jQuery
.
each
(
{
parent
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
return
parent
&
&
parent
.
nodeType
!
=
=
11
?
parent
:
null
;
}
parents
:
function
(
elem
)
{
return
dir
(
elem
"
parentNode
"
)
;
}
parentsUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
parentNode
"
until
)
;
}
next
:
function
(
elem
)
{
return
sibling
(
elem
"
nextSibling
"
)
;
}
prev
:
function
(
elem
)
{
return
sibling
(
elem
"
previousSibling
"
)
;
}
nextAll
:
function
(
elem
)
{
return
dir
(
elem
"
nextSibling
"
)
;
}
prevAll
:
function
(
elem
)
{
return
dir
(
elem
"
previousSibling
"
)
;
}
nextUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
nextSibling
"
until
)
;
}
prevUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
previousSibling
"
until
)
;
}
siblings
:
function
(
elem
)
{
return
siblings
(
(
elem
.
parentNode
|
|
{
}
)
.
firstChild
elem
)
;
}
children
:
function
(
elem
)
{
return
siblings
(
elem
.
firstChild
)
;
}
contents
:
function
(
elem
)
{
if
(
nodeName
(
elem
"
iframe
"
)
)
{
return
elem
.
contentDocument
;
}
if
(
nodeName
(
elem
"
template
"
)
)
{
elem
=
elem
.
content
|
|
elem
;
}
return
jQuery
.
merge
(
[
]
elem
.
childNodes
)
;
}
}
function
(
name
fn
)
{
jQuery
.
fn
[
name
]
=
function
(
until
selector
)
{
var
matched
=
jQuery
.
map
(
this
fn
until
)
;
if
(
name
.
slice
(
-
5
)
!
=
=
"
Until
"
)
{
selector
=
until
;
}
if
(
selector
&
&
typeof
selector
=
=
=
"
string
"
)
{
matched
=
jQuery
.
filter
(
selector
matched
)
;
}
if
(
this
.
length
>
1
)
{
if
(
!
guaranteedUnique
[
name
]
)
{
jQuery
.
uniqueSort
(
matched
)
;
}
if
(
rparentsprev
.
test
(
name
)
)
{
matched
.
reverse
(
)
;
}
}
return
this
.
pushStack
(
matched
)
;
}
;
}
)
;
var
rnothtmlwhite
=
(
/
[
^
\
x20
\
t
\
r
\
n
\
f
]
+
/
g
)
;
function
createOptions
(
options
)
{
var
object
=
{
}
;
jQuery
.
each
(
options
.
match
(
rnothtmlwhite
)
|
|
[
]
function
(
_
flag
)
{
object
[
flag
]
=
true
;
}
)
;
return
object
;
}
jQuery
.
Callbacks
=
function
(
options
)
{
options
=
typeof
options
=
=
=
"
string
"
?
createOptions
(
options
)
:
jQuery
.
extend
(
{
}
options
)
;
var
firing
memory
fired
locked
list
=
[
]
queue
=
[
]
firingIndex
=
-
1
fire
=
function
(
)
{
locked
=
locked
|
|
options
.
once
;
fired
=
firing
=
true
;
for
(
;
queue
.
length
;
firingIndex
=
-
1
)
{
memory
=
queue
.
shift
(
)
;
while
(
+
+
firingIndex
<
list
.
length
)
{
if
(
list
[
firingIndex
]
.
apply
(
memory
[
0
]
memory
[
1
]
)
=
=
=
false
&
&
options
.
stopOnFalse
)
{
firingIndex
=
list
.
length
;
memory
=
false
;
}
}
}
if
(
!
options
.
memory
)
{
memory
=
false
;
}
firing
=
false
;
if
(
locked
)
{
if
(
memory
)
{
list
=
[
]
;
}
else
{
list
=
"
"
;
}
}
}
self
=
{
add
:
function
(
)
{
if
(
list
)
{
if
(
memory
&
&
!
firing
)
{
firingIndex
=
list
.
length
-
1
;
queue
.
push
(
memory
)
;
}
(
function
add
(
args
)
{
jQuery
.
each
(
args
function
(
_
arg
)
{
if
(
isFunction
(
arg
)
)
{
if
(
!
options
.
unique
|
|
!
self
.
has
(
arg
)
)
{
list
.
push
(
arg
)
;
}
}
else
if
(
arg
&
&
arg
.
length
&
&
toType
(
arg
)
!
=
=
"
string
"
)
{
add
(
arg
)
;
}
}
)
;
}
)
(
arguments
)
;
if
(
memory
&
&
!
firing
)
{
fire
(
)
;
}
}
return
this
;
}
remove
:
function
(
)
{
jQuery
.
each
(
arguments
function
(
_
arg
)
{
var
index
;
while
(
(
index
=
jQuery
.
inArray
(
arg
list
index
)
)
>
-
1
)
{
list
.
splice
(
index
1
)
;
if
(
index
<
=
firingIndex
)
{
firingIndex
-
-
;
}
}
}
)
;
return
this
;
}
has
:
function
(
fn
)
{
return
fn
?
jQuery
.
inArray
(
fn
list
)
>
-
1
:
list
.
length
>
0
;
}
empty
:
function
(
)
{
if
(
list
)
{
list
=
[
]
;
}
return
this
;
}
disable
:
function
(
)
{
locked
=
queue
=
[
]
;
list
=
memory
=
"
"
;
return
this
;
}
disabled
:
function
(
)
{
return
!
list
;
}
lock
:
function
(
)
{
locked
=
queue
=
[
]
;
if
(
!
memory
&
&
!
firing
)
{
list
=
memory
=
"
"
;
}
return
this
;
}
locked
:
function
(
)
{
return
!
!
locked
;
}
fireWith
:
function
(
context
args
)
{
if
(
!
locked
)
{
args
=
args
|
|
[
]
;
args
=
[
context
args
.
slice
?
args
.
slice
(
)
:
args
]
;
queue
.
push
(
args
)
;
if
(
!
firing
)
{
fire
(
)
;
}
}
return
this
;
}
fire
:
function
(
)
{
self
.
fireWith
(
this
arguments
)
;
return
this
;
}
fired
:
function
(
)
{
return
!
!
fired
;
}
}
;
return
self
;
}
;
function
Identity
(
v
)
{
return
v
;
}
function
Thrower
(
ex
)
{
throw
ex
;
}
function
adoptValue
(
value
resolve
reject
noValue
)
{
var
method
;
try
{
if
(
value
&
&
isFunction
(
(
method
=
value
.
promise
)
)
)
{
method
.
call
(
value
)
.
done
(
resolve
)
.
fail
(
reject
)
;
}
else
if
(
value
&
&
isFunction
(
(
method
=
value
.
then
)
)
)
{
method
.
call
(
value
resolve
reject
)
;
}
else
{
resolve
.
apply
(
undefined
[
value
]
.
slice
(
noValue
)
)
;
}
}
catch
(
value
)
{
reject
.
apply
(
undefined
[
value
]
)
;
}
}
jQuery
.
extend
(
{
Deferred
:
function
(
func
)
{
var
tuples
=
[
[
"
notify
"
"
progress
"
jQuery
.
Callbacks
(
"
memory
"
)
jQuery
.
Callbacks
(
"
memory
"
)
2
]
[
"
resolve
"
"
done
"
jQuery
.
Callbacks
(
"
once
memory
"
)
jQuery
.
Callbacks
(
"
once
memory
"
)
0
"
resolved
"
]
[
"
reject
"
"
fail
"
jQuery
.
Callbacks
(
"
once
memory
"
)
jQuery
.
Callbacks
(
"
once
memory
"
)
1
"
rejected
"
]
]
state
=
"
pending
"
promise
=
{
state
:
function
(
)
{
return
state
;
}
always
:
function
(
)
{
deferred
.
done
(
arguments
)
.
fail
(
arguments
)
;
return
this
;
}
"
catch
"
:
function
(
fn
)
{
return
promise
.
then
(
null
fn
)
;
}
pipe
:
function
(
)
{
var
fns
=
arguments
;
return
jQuery
.
Deferred
(
function
(
newDefer
)
{
jQuery
.
each
(
tuples
function
(
i
tuple
)
{
var
fn
=
isFunction
(
fns
[
tuple
[
4
]
]
)
&
&
fns
[
tuple
[
4
]
]
;
deferred
[
tuple
[
1
]
]
(
function
(
)
{
var
returned
=
fn
&
&
fn
.
apply
(
this
arguments
)
;
if
(
returned
&
&
isFunction
(
returned
.
promise
)
)
{
returned
.
promise
(
)
.
progress
(
newDefer
.
notify
)
.
done
(
newDefer
.
resolve
)
.
fail
(
newDefer
.
reject
)
;
}
else
{
newDefer
[
tuple
[
0
]
+
"
With
"
]
(
this
fn
?
[
returned
]
:
arguments
)
;
}
}
)
;
}
)
;
fns
=
null
;
}
)
.
promise
(
)
;
}
then
:
function
(
onFulfilled
onRejected
onProgress
)
{
var
maxDepth
=
0
;
function
resolve
(
depth
deferred
handler
special
)
{
return
function
(
)
{
var
that
=
this
args
=
arguments
mightThrow
=
function
(
)
{
var
returned
then
;
if
(
depth
<
maxDepth
)
{
return
;
}
returned
=
handler
.
apply
(
that
args
)
;
if
(
returned
=
=
=
deferred
.
promise
(
)
)
{
throw
new
TypeError
(
"
Thenable
self
-
resolution
"
)
;
}
then
=
returned
&
&
(
typeof
returned
=
=
=
"
object
"
|
|
typeof
returned
=
=
=
"
function
"
)
&
&
returned
.
then
;
if
(
isFunction
(
then
)
)
{
if
(
special
)
{
then
.
call
(
returned
resolve
(
maxDepth
deferred
Identity
special
)
resolve
(
maxDepth
deferred
Thrower
special
)
)
;
}
else
{
maxDepth
+
+
;
then
.
call
(
returned
resolve
(
maxDepth
deferred
Identity
special
)
resolve
(
maxDepth
deferred
Thrower
special
)
resolve
(
maxDepth
deferred
Identity
deferred
.
notifyWith
)
)
;
}
}
else
{
if
(
handler
!
=
=
Identity
)
{
that
=
undefined
;
args
=
[
returned
]
;
}
(
special
|
|
deferred
.
resolveWith
)
(
that
args
)
;
}
}
process
=
special
?
mightThrow
:
function
(
)
{
try
{
mightThrow
(
)
;
}
catch
(
e
)
{
if
(
jQuery
.
Deferred
.
exceptionHook
)
{
jQuery
.
Deferred
.
exceptionHook
(
e
process
.
stackTrace
)
;
}
if
(
depth
+
1
>
=
maxDepth
)
{
if
(
handler
!
=
=
Thrower
)
{
that
=
undefined
;
args
=
[
e
]
;
}
deferred
.
rejectWith
(
that
args
)
;
}
}
}
;
if
(
depth
)
{
process
(
)
;
}
else
{
if
(
jQuery
.
Deferred
.
getStackHook
)
{
process
.
stackTrace
=
jQuery
.
Deferred
.
getStackHook
(
)
;
}
window
.
setTimeout
(
process
)
;
}
}
;
}
return
jQuery
.
Deferred
(
function
(
newDefer
)
{
tuples
[
0
]
[
3
]
.
add
(
resolve
(
0
newDefer
isFunction
(
onProgress
)
?
onProgress
:
Identity
newDefer
.
notifyWith
)
)
;
tuples
[
1
]
[
3
]
.
add
(
resolve
(
0
newDefer
isFunction
(
onFulfilled
)
?
onFulfilled
:
Identity
)
)
;
tuples
[
2
]
[
3
]
.
add
(
resolve
(
0
newDefer
isFunction
(
onRejected
)
?
onRejected
:
Thrower
)
)
;
}
)
.
promise
(
)
;
}
promise
:
function
(
obj
)
{
return
obj
!
=
null
?
jQuery
.
extend
(
obj
promise
)
:
promise
;
}
}
deferred
=
{
}
;
jQuery
.
each
(
tuples
function
(
i
tuple
)
{
var
list
=
tuple
[
2
]
stateString
=
tuple
[
5
]
;
promise
[
tuple
[
1
]
]
=
list
.
add
;
if
(
stateString
)
{
list
.
add
(
function
(
)
{
state
=
stateString
;
}
tuples
[
3
-
i
]
[
2
]
.
disable
tuples
[
3
-
i
]
[
3
]
.
disable
tuples
[
0
]
[
2
]
.
lock
tuples
[
0
]
[
3
]
.
lock
)
;
}
list
.
add
(
tuple
[
3
]
.
fire
)
;
deferred
[
tuple
[
0
]
]
=
function
(
)
{
deferred
[
tuple
[
0
]
+
"
With
"
]
(
this
=
=
=
deferred
?
undefined
:
this
arguments
)
;
return
this
;
}
;
deferred
[
tuple
[
0
]
+
"
With
"
]
=
list
.
fireWith
;
}
)
;
promise
.
promise
(
deferred
)
;
if
(
func
)
{
func
.
call
(
deferred
deferred
)
;
}
return
deferred
;
}
when
:
function
(
singleValue
)
{
var
remaining
=
arguments
.
length
i
=
remaining
resolveContexts
=
Array
(
i
)
resolveValues
=
slice
.
call
(
arguments
)
master
=
jQuery
.
Deferred
(
)
updateFunc
=
function
(
i
)
{
return
function
(
value
)
{
resolveContexts
[
i
]
=
this
;
resolveValues
[
i
]
=
arguments
.
length
>
1
?
slice
.
call
(
arguments
)
:
value
;
if
(
!
(
-
-
remaining
)
)
{
master
.
resolveWith
(
resolveContexts
resolveValues
)
;
}
}
;
}
;
if
(
remaining
<
=
1
)
{
adoptValue
(
singleValue
master
.
done
(
updateFunc
(
i
)
)
.
resolve
master
.
reject
!
remaining
)
;
if
(
master
.
state
(
)
=
=
=
"
pending
"
|
|
isFunction
(
resolveValues
[
i
]
&
&
resolveValues
[
i
]
.
then
)
)
{
return
master
.
then
(
)
;
}
}
while
(
i
-
-
)
{
adoptValue
(
resolveValues
[
i
]
updateFunc
(
i
)
master
.
reject
)
;
}
return
master
.
promise
(
)
;
}
}
)
;
var
rerrorNames
=
/
^
(
Eval
|
Internal
|
Range
|
Reference
|
Syntax
|
Type
|
URI
)
Error
/
;
jQuery
.
Deferred
.
exceptionHook
=
function
(
error
stack
)
{
if
(
window
.
console
&
&
window
.
console
.
warn
&
&
error
&
&
rerrorNames
.
test
(
error
.
name
)
)
{
window
.
console
.
warn
(
"
jQuery
.
Deferred
exception
:
"
+
error
.
message
error
.
stack
stack
)
;
}
}
;
jQuery
.
readyException
=
function
(
error
)
{
window
.
setTimeout
(
function
(
)
{
throw
error
;
}
)
;
}
;
var
readyList
=
jQuery
.
Deferred
(
)
;
jQuery
.
fn
.
ready
=
function
(
fn
)
{
readyList
.
then
(
fn
)
.
catch
(
function
(
error
)
{
jQuery
.
readyException
(
error
)
;
}
)
;
return
this
;
}
;
jQuery
.
extend
(
{
isReady
:
false
readyWait
:
1
ready
:
function
(
wait
)
{
if
(
wait
=
=
=
true
?
-
-
jQuery
.
readyWait
:
jQuery
.
isReady
)
{
return
;
}
jQuery
.
isReady
=
true
;
if
(
wait
!
=
=
true
&
&
-
-
jQuery
.
readyWait
>
0
)
{
return
;
}
readyList
.
resolveWith
(
document
[
jQuery
]
)
;
}
}
)
;
jQuery
.
ready
.
then
=
readyList
.
then
;
function
completed
(
)
{
document
.
removeEventListener
(
"
DOMContentLoaded
"
completed
)
;
window
.
removeEventListener
(
"
load
"
completed
)
;
jQuery
.
ready
(
)
;
}
if
(
document
.
readyState
=
=
=
"
complete
"
|
|
(
document
.
readyState
!
=
=
"
loading
"
&
&
!
document
.
documentElement
.
doScroll
)
)
{
window
.
setTimeout
(
jQuery
.
ready
)
;
}
else
{
document
.
addEventListener
(
"
DOMContentLoaded
"
completed
)
;
window
.
addEventListener
(
"
load
"
completed
)
;
}
var
access
=
function
(
elems
fn
key
value
chainable
emptyGet
raw
)
{
var
i
=
0
len
=
elems
.
length
bulk
=
key
=
=
null
;
if
(
toType
(
key
)
=
=
=
"
object
"
)
{
chainable
=
true
;
for
(
i
in
key
)
{
access
(
elems
fn
i
key
[
i
]
true
emptyGet
raw
)
;
}
}
else
if
(
value
!
=
=
undefined
)
{
chainable
=
true
;
if
(
!
isFunction
(
value
)
)
{
raw
=
true
;
}
if
(
bulk
)
{
if
(
raw
)
{
fn
.
call
(
elems
value
)
;
fn
=
null
;
}
else
{
bulk
=
fn
;
fn
=
function
(
elem
key
value
)
{
return
bulk
.
call
(
jQuery
(
elem
)
value
)
;
}
;
}
}
if
(
fn
)
{
for
(
;
i
<
len
;
i
+
+
)
{
fn
(
elems
[
i
]
key
raw
?
value
:
value
.
call
(
elems
[
i
]
i
fn
(
elems
[
i
]
key
)
)
)
;
}
}
}
if
(
chainable
)
{
return
elems
;
}
if
(
bulk
)
{
return
fn
.
call
(
elems
)
;
}
return
len
?
fn
(
elems
[
0
]
key
)
:
emptyGet
;
}
;
var
rmsPrefix
=
/
^
-
ms
-
/
rdashAlpha
=
/
-
(
[
a
-
z
]
)
/
g
;
function
fcamelCase
(
all
letter
)
{
return
letter
.
toUpperCase
(
)
;
}
function
camelCase
(
string
)
{
return
string
.
replace
(
rmsPrefix
"
ms
-
"
)
.
replace
(
rdashAlpha
fcamelCase
)
;
}
var
acceptData
=
function
(
owner
)
{
return
owner
.
nodeType
=
=
=
1
|
|
owner
.
nodeType
=
=
=
9
|
|
!
(
+
owner
.
nodeType
)
;
}
;
function
Data
(
)
{
this
.
expando
=
jQuery
.
expando
+
Data
.
uid
+
+
;
}
Data
.
uid
=
1
;
Data
.
prototype
=
{
cache
:
function
(
owner
)
{
var
value
=
owner
[
this
.
expando
]
;
if
(
!
value
)
{
value
=
{
}
;
if
(
acceptData
(
owner
)
)
{
if
(
owner
.
nodeType
)
{
owner
[
this
.
expando
]
=
value
;
}
else
{
Object
.
defineProperty
(
owner
this
.
expando
{
value
:
value
configurable
:
true
}
)
;
}
}
}
return
value
;
}
set
:
function
(
owner
data
value
)
{
var
prop
cache
=
this
.
cache
(
owner
)
;
if
(
typeof
data
=
=
=
"
string
"
)
{
cache
[
camelCase
(
data
)
]
=
value
;
}
else
{
for
(
prop
in
data
)
{
cache
[
camelCase
(
prop
)
]
=
data
[
prop
]
;
}
}
return
cache
;
}
get
:
function
(
owner
key
)
{
return
key
=
=
=
undefined
?
this
.
cache
(
owner
)
:
owner
[
this
.
expando
]
&
&
owner
[
this
.
expando
]
[
camelCase
(
key
)
]
;
}
access
:
function
(
owner
key
value
)
{
if
(
key
=
=
=
undefined
|
|
(
(
key
&
&
typeof
key
=
=
=
"
string
"
)
&
&
value
=
=
=
undefined
)
)
{
return
this
.
get
(
owner
key
)
;
}
this
.
set
(
owner
key
value
)
;
return
value
!
=
=
undefined
?
value
:
key
;
}
remove
:
function
(
owner
key
)
{
var
i
cache
=
owner
[
this
.
expando
]
;
if
(
cache
=
=
=
undefined
)
{
return
;
}
if
(
key
!
=
=
undefined
)
{
if
(
Array
.
isArray
(
key
)
)
{
key
=
key
.
map
(
camelCase
)
;
}
else
{
key
=
camelCase
(
key
)
;
key
=
key
in
cache
?
[
key
]
:
(
key
.
match
(
rnothtmlwhite
)
|
|
[
]
)
;
}
i
=
key
.
length
;
while
(
i
-
-
)
{
delete
cache
[
key
[
i
]
]
;
}
}
if
(
key
=
=
=
undefined
|
|
jQuery
.
isEmptyObject
(
cache
)
)
{
if
(
owner
.
nodeType
)
{
owner
[
this
.
expando
]
=
undefined
;
}
else
{
delete
owner
[
this
.
expando
]
;
}
}
}
hasData
:
function
(
owner
)
{
var
cache
=
owner
[
this
.
expando
]
;
return
cache
!
=
=
undefined
&
&
!
jQuery
.
isEmptyObject
(
cache
)
;
}
}
;
var
dataPriv
=
new
Data
(
)
;
var
dataUser
=
new
Data
(
)
;
var
rbrace
=
/
^
(
?
:
\
{
[
\
w
\
W
]
*
\
}
|
\
[
[
\
w
\
W
]
*
\
]
)
/
rmultiDash
=
/
[
A
-
Z
]
/
g
;
function
getData
(
data
)
{
if
(
data
=
=
=
"
true
"
)
{
return
true
;
}
if
(
data
=
=
=
"
false
"
)
{
return
false
;
}
if
(
data
=
=
=
"
null
"
)
{
return
null
;
}
if
(
data
=
=
=
+
data
+
"
"
)
{
return
+
data
;
}
if
(
rbrace
.
test
(
data
)
)
{
return
JSON
.
parse
(
data
)
;
}
return
data
;
}
function
dataAttr
(
elem
key
data
)
{
var
name
;
if
(
data
=
=
=
undefined
&
&
elem
.
nodeType
=
=
=
1
)
{
name
=
"
data
-
"
+
key
.
replace
(
rmultiDash
"
-
&
"
)
.
toLowerCase
(
)
;
data
=
elem
.
getAttribute
(
name
)
;
if
(
typeof
data
=
=
=
"
string
"
)
{
try
{
data
=
getData
(
data
)
;
}
catch
(
e
)
{
}
dataUser
.
set
(
elem
key
data
)
;
}
else
{
data
=
undefined
;
}
}
return
data
;
}
jQuery
.
extend
(
{
hasData
:
function
(
elem
)
{
return
dataUser
.
hasData
(
elem
)
|
|
dataPriv
.
hasData
(
elem
)
;
}
data
:
function
(
elem
name
data
)
{
return
dataUser
.
access
(
elem
name
data
)
;
}
removeData
:
function
(
elem
name
)
{
dataUser
.
remove
(
elem
name
)
;
}
_data
:
function
(
elem
name
data
)
{
return
dataPriv
.
access
(
elem
name
data
)
;
}
_removeData
:
function
(
elem
name
)
{
dataPriv
.
remove
(
elem
name
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
data
:
function
(
key
value
)
{
var
i
name
data
elem
=
this
[
0
]
attrs
=
elem
&
&
elem
.
attributes
;
if
(
key
=
=
=
undefined
)
{
if
(
this
.
length
)
{
data
=
dataUser
.
get
(
elem
)
;
if
(
elem
.
nodeType
=
=
=
1
&
&
!
dataPriv
.
get
(
elem
"
hasDataAttrs
"
)
)
{
i
=
attrs
.
length
;
while
(
i
-
-
)
{
if
(
attrs
[
i
]
)
{
name
=
attrs
[
i
]
.
name
;
if
(
name
.
indexOf
(
"
data
-
"
)
=
=
=
0
)
{
name
=
camelCase
(
name
.
slice
(
5
)
)
;
dataAttr
(
elem
name
data
[
name
]
)
;
}
}
}
dataPriv
.
set
(
elem
"
hasDataAttrs
"
true
)
;
}
}
return
data
;
}
if
(
typeof
key
=
=
=
"
object
"
)
{
return
this
.
each
(
function
(
)
{
dataUser
.
set
(
this
key
)
;
}
)
;
}
return
access
(
this
function
(
value
)
{
var
data
;
if
(
elem
&
&
value
=
=
=
undefined
)
{
data
=
dataUser
.
get
(
elem
key
)
;
if
(
data
!
=
=
undefined
)
{
return
data
;
}
data
=
dataAttr
(
elem
key
)
;
if
(
data
!
=
=
undefined
)
{
return
data
;
}
return
;
}
this
.
each
(
function
(
)
{
dataUser
.
set
(
this
key
value
)
;
}
)
;
}
null
value
arguments
.
length
>
1
null
true
)
;
}
removeData
:
function
(
key
)
{
return
this
.
each
(
function
(
)
{
dataUser
.
remove
(
this
key
)
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
queue
:
function
(
elem
type
data
)
{
var
queue
;
if
(
elem
)
{
type
=
(
type
|
|
"
fx
"
)
+
"
queue
"
;
queue
=
dataPriv
.
get
(
elem
type
)
;
if
(
data
)
{
if
(
!
queue
|
|
Array
.
isArray
(
data
)
)
{
queue
=
dataPriv
.
access
(
elem
type
jQuery
.
makeArray
(
data
)
)
;
}
else
{
queue
.
push
(
data
)
;
}
}
return
queue
|
|
[
]
;
}
}
dequeue
:
function
(
elem
type
)
{
type
=
type
|
|
"
fx
"
;
var
queue
=
jQuery
.
queue
(
elem
type
)
startLength
=
queue
.
length
fn
=
queue
.
shift
(
)
hooks
=
jQuery
.
_queueHooks
(
elem
type
)
next
=
function
(
)
{
jQuery
.
dequeue
(
elem
type
)
;
}
;
if
(
fn
=
=
=
"
inprogress
"
)
{
fn
=
queue
.
shift
(
)
;
startLength
-
-
;
}
if
(
fn
)
{
if
(
type
=
=
=
"
fx
"
)
{
queue
.
unshift
(
"
inprogress
"
)
;
}
delete
hooks
.
stop
;
fn
.
call
(
elem
next
hooks
)
;
}
if
(
!
startLength
&
&
hooks
)
{
hooks
.
empty
.
fire
(
)
;
}
}
_queueHooks
:
function
(
elem
type
)
{
var
key
=
type
+
"
queueHooks
"
;
return
dataPriv
.
get
(
elem
key
)
|
|
dataPriv
.
access
(
elem
key
{
empty
:
jQuery
.
Callbacks
(
"
once
memory
"
)
.
add
(
function
(
)
{
dataPriv
.
remove
(
elem
[
type
+
"
queue
"
key
]
)
;
}
)
}
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
queue
:
function
(
type
data
)
{
var
setter
=
2
;
if
(
typeof
type
!
=
=
"
string
"
)
{
data
=
type
;
type
=
"
fx
"
;
setter
-
-
;
}
if
(
arguments
.
length
<
setter
)
{
return
jQuery
.
queue
(
this
[
0
]
type
)
;
}
return
data
=
=
=
undefined
?
this
:
this
.
each
(
function
(
)
{
var
queue
=
jQuery
.
queue
(
this
type
data
)
;
jQuery
.
_queueHooks
(
this
type
)
;
if
(
type
=
=
=
"
fx
"
&
&
queue
[
0
]
!
=
=
"
inprogress
"
)
{
jQuery
.
dequeue
(
this
type
)
;
}
}
)
;
}
dequeue
:
function
(
type
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
dequeue
(
this
type
)
;
}
)
;
}
clearQueue
:
function
(
type
)
{
return
this
.
queue
(
type
|
|
"
fx
"
[
]
)
;
}
promise
:
function
(
type
obj
)
{
var
tmp
count
=
1
defer
=
jQuery
.
Deferred
(
)
elements
=
this
i
=
this
.
length
resolve
=
function
(
)
{
if
(
!
(
-
-
count
)
)
{
defer
.
resolveWith
(
elements
[
elements
]
)
;
}
}
;
if
(
typeof
type
!
=
=
"
string
"
)
{
obj
=
type
;
type
=
undefined
;
}
type
=
type
|
|
"
fx
"
;
while
(
i
-
-
)
{
tmp
=
dataPriv
.
get
(
elements
[
i
]
type
+
"
queueHooks
"
)
;
if
(
tmp
&
&
tmp
.
empty
)
{
count
+
+
;
tmp
.
empty
.
add
(
resolve
)
;
}
}
resolve
(
)
;
return
defer
.
promise
(
obj
)
;
}
}
)
;
var
pnum
=
(
/
[
+
-
]
?
(
?
:
\
d
*
\
.
|
)
\
d
+
(
?
:
[
eE
]
[
+
-
]
?
\
d
+
|
)
/
)
.
source
;
var
rcssNum
=
new
RegExp
(
"
^
(
?
:
(
[
+
-
]
)
=
|
)
(
"
+
pnum
+
"
)
(
[
a
-
z
%
]
*
)
"
"
i
"
)
;
var
cssExpand
=
[
"
Top
"
"
Right
"
"
Bottom
"
"
Left
"
]
;
var
isHiddenWithinTree
=
function
(
elem
el
)
{
elem
=
el
|
|
elem
;
return
elem
.
style
.
display
=
=
=
"
none
"
|
|
elem
.
style
.
display
=
=
=
"
"
&
&
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
&
&
jQuery
.
css
(
elem
"
display
"
)
=
=
=
"
none
"
;
}
;
var
swap
=
function
(
elem
options
callback
args
)
{
var
ret
name
old
=
{
}
;
for
(
name
in
options
)
{
old
[
name
]
=
elem
.
style
[
name
]
;
elem
.
style
[
name
]
=
options
[
name
]
;
}
ret
=
callback
.
apply
(
elem
args
|
|
[
]
)
;
for
(
name
in
options
)
{
elem
.
style
[
name
]
=
old
[
name
]
;
}
return
ret
;
}
;
function
adjustCSS
(
elem
prop
valueParts
tween
)
{
var
adjusted
scale
maxIterations
=
20
currentValue
=
tween
?
function
(
)
{
return
tween
.
cur
(
)
;
}
:
function
(
)
{
return
jQuery
.
css
(
elem
prop
"
"
)
;
}
initial
=
currentValue
(
)
unit
=
valueParts
&
&
valueParts
[
3
]
|
|
(
jQuery
.
cssNumber
[
prop
]
?
"
"
:
"
px
"
)
initialInUnit
=
(
jQuery
.
cssNumber
[
prop
]
|
|
unit
!
=
=
"
px
"
&
&
+
initial
)
&
&
rcssNum
.
exec
(
jQuery
.
css
(
elem
prop
)
)
;
if
(
initialInUnit
&
&
initialInUnit
[
3
]
!
=
=
unit
)
{
initial
=
initial
/
2
;
unit
=
unit
|
|
initialInUnit
[
3
]
;
initialInUnit
=
+
initial
|
|
1
;
while
(
maxIterations
-
-
)
{
jQuery
.
style
(
elem
prop
initialInUnit
+
unit
)
;
if
(
(
1
-
scale
)
*
(
1
-
(
scale
=
currentValue
(
)
/
initial
|
|
0
.
5
)
)
<
=
0
)
{
maxIterations
=
0
;
}
initialInUnit
=
initialInUnit
/
scale
;
}
initialInUnit
=
initialInUnit
*
2
;
jQuery
.
style
(
elem
prop
initialInUnit
+
unit
)
;
valueParts
=
valueParts
|
|
[
]
;
}
if
(
valueParts
)
{
initialInUnit
=
+
initialInUnit
|
|
+
initial
|
|
0
;
adjusted
=
valueParts
[
1
]
?
initialInUnit
+
(
valueParts
[
1
]
+
1
)
*
valueParts
[
2
]
:
+
valueParts
[
2
]
;
if
(
tween
)
{
tween
.
unit
=
unit
;
tween
.
start
=
initialInUnit
;
tween
.
end
=
adjusted
;
}
}
return
adjusted
;
}
var
defaultDisplayMap
=
{
}
;
function
getDefaultDisplay
(
elem
)
{
var
temp
doc
=
elem
.
ownerDocument
nodeName
=
elem
.
nodeName
display
=
defaultDisplayMap
[
nodeName
]
;
if
(
display
)
{
return
display
;
}
temp
=
doc
.
body
.
appendChild
(
doc
.
createElement
(
nodeName
)
)
;
display
=
jQuery
.
css
(
temp
"
display
"
)
;
temp
.
parentNode
.
removeChild
(
temp
)
;
if
(
display
=
=
=
"
none
"
)
{
display
=
"
block
"
;
}
defaultDisplayMap
[
nodeName
]
=
display
;
return
display
;
}
function
showHide
(
elements
show
)
{
var
display
elem
values
=
[
]
index
=
0
length
=
elements
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
elem
=
elements
[
index
]
;
if
(
!
elem
.
style
)
{
continue
;
}
display
=
elem
.
style
.
display
;
if
(
show
)
{
if
(
display
=
=
=
"
none
"
)
{
values
[
index
]
=
dataPriv
.
get
(
elem
"
display
"
)
|
|
null
;
if
(
!
values
[
index
]
)
{
elem
.
style
.
display
=
"
"
;
}
}
if
(
elem
.
style
.
display
=
=
=
"
"
&
&
isHiddenWithinTree
(
elem
)
)
{
values
[
index
]
=
getDefaultDisplay
(
elem
)
;
}
}
else
{
if
(
display
!
=
=
"
none
"
)
{
values
[
index
]
=
"
none
"
;
dataPriv
.
set
(
elem
"
display
"
display
)
;
}
}
}
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
if
(
values
[
index
]
!
=
null
)
{
elements
[
index
]
.
style
.
display
=
values
[
index
]
;
}
}
return
elements
;
}
jQuery
.
fn
.
extend
(
{
show
:
function
(
)
{
return
showHide
(
this
true
)
;
}
hide
:
function
(
)
{
return
showHide
(
this
)
;
}
toggle
:
function
(
state
)
{
if
(
typeof
state
=
=
=
"
boolean
"
)
{
return
state
?
this
.
show
(
)
:
this
.
hide
(
)
;
}
return
this
.
each
(
function
(
)
{
if
(
isHiddenWithinTree
(
this
)
)
{
jQuery
(
this
)
.
show
(
)
;
}
else
{
jQuery
(
this
)
.
hide
(
)
;
}
}
)
;
}
}
)
;
var
rcheckableType
=
(
/
^
(
?
:
checkbox
|
radio
)
/
i
)
;
var
rtagName
=
(
/
<
(
[
a
-
z
]
[
^
\
/
\
0
>
\
x20
\
t
\
r
\
n
\
f
]
+
)
/
i
)
;
var
rscriptType
=
(
/
^
|
^
module
|
\
/
(
?
:
java
|
ecma
)
script
/
i
)
;
var
wrapMap
=
{
option
:
[
1
"
<
select
multiple
=
'
multiple
'
>
"
"
<
/
select
>
"
]
thead
:
[
1
"
<
table
>
"
"
<
/
table
>
"
]
col
:
[
2
"
<
table
>
<
colgroup
>
"
"
<
/
colgroup
>
<
/
table
>
"
]
tr
:
[
2
"
<
table
>
<
tbody
>
"
"
<
/
tbody
>
<
/
table
>
"
]
td
:
[
3
"
<
table
>
<
tbody
>
<
tr
>
"
"
<
/
tr
>
<
/
tbody
>
<
/
table
>
"
]
_default
:
[
0
"
"
"
"
]
}
;
wrapMap
.
optgroup
=
wrapMap
.
option
;
wrapMap
.
tbody
=
wrapMap
.
tfoot
=
wrapMap
.
colgroup
=
wrapMap
.
caption
=
wrapMap
.
thead
;
wrapMap
.
th
=
wrapMap
.
td
;
function
getAll
(
context
tag
)
{
var
ret
;
if
(
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
)
{
ret
=
context
.
getElementsByTagName
(
tag
|
|
"
*
"
)
;
}
else
if
(
typeof
context
.
querySelectorAll
!
=
=
"
undefined
"
)
{
ret
=
context
.
querySelectorAll
(
tag
|
|
"
*
"
)
;
}
else
{
ret
=
[
]
;
}
if
(
tag
=
=
=
undefined
|
|
tag
&
&
nodeName
(
context
tag
)
)
{
return
jQuery
.
merge
(
[
context
]
ret
)
;
}
return
ret
;
}
function
setGlobalEval
(
elems
refElements
)
{
var
i
=
0
l
=
elems
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
dataPriv
.
set
(
elems
[
i
]
"
globalEval
"
!
refElements
|
|
dataPriv
.
get
(
refElements
[
i
]
"
globalEval
"
)
)
;
}
}
var
rhtml
=
/
<
|
&
#
?
\
w
+
;
/
;
function
buildFragment
(
elems
context
scripts
selection
ignored
)
{
var
elem
tmp
tag
wrap
contains
j
fragment
=
context
.
createDocumentFragment
(
)
nodes
=
[
]
i
=
0
l
=
elems
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
elem
=
elems
[
i
]
;
if
(
elem
|
|
elem
=
=
=
0
)
{
if
(
toType
(
elem
)
=
=
=
"
object
"
)
{
jQuery
.
merge
(
nodes
elem
.
nodeType
?
[
elem
]
:
elem
)
;
}
else
if
(
!
rhtml
.
test
(
elem
)
)
{
nodes
.
push
(
context
.
createTextNode
(
elem
)
)
;
}
else
{
tmp
=
tmp
|
|
fragment
.
appendChild
(
context
.
createElement
(
"
div
"
)
)
;
tag
=
(
rtagName
.
exec
(
elem
)
|
|
[
"
"
"
"
]
)
[
1
]
.
toLowerCase
(
)
;
wrap
=
wrapMap
[
tag
]
|
|
wrapMap
.
_default
;
tmp
.
innerHTML
=
wrap
[
1
]
+
jQuery
.
htmlPrefilter
(
elem
)
+
wrap
[
2
]
;
j
=
wrap
[
0
]
;
while
(
j
-
-
)
{
tmp
=
tmp
.
lastChild
;
}
jQuery
.
merge
(
nodes
tmp
.
childNodes
)
;
tmp
=
fragment
.
firstChild
;
tmp
.
textContent
=
"
"
;
}
}
}
fragment
.
textContent
=
"
"
;
i
=
0
;
while
(
(
elem
=
nodes
[
i
+
+
]
)
)
{
if
(
selection
&
&
jQuery
.
inArray
(
elem
selection
)
>
-
1
)
{
if
(
ignored
)
{
ignored
.
push
(
elem
)
;
}
continue
;
}
contains
=
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
;
tmp
=
getAll
(
fragment
.
appendChild
(
elem
)
"
script
"
)
;
if
(
contains
)
{
setGlobalEval
(
tmp
)
;
}
if
(
scripts
)
{
j
=
0
;
while
(
(
elem
=
tmp
[
j
+
+
]
)
)
{
if
(
rscriptType
.
test
(
elem
.
type
|
|
"
"
)
)
{
scripts
.
push
(
elem
)
;
}
}
}
}
return
fragment
;
}
(
function
(
)
{
var
fragment
=
document
.
createDocumentFragment
(
)
div
=
fragment
.
appendChild
(
document
.
createElement
(
"
div
"
)
)
input
=
document
.
createElement
(
"
input
"
)
;
input
.
setAttribute
(
"
type
"
"
radio
"
)
;
input
.
setAttribute
(
"
checked
"
"
checked
"
)
;
input
.
setAttribute
(
"
name
"
"
t
"
)
;
div
.
appendChild
(
input
)
;
support
.
checkClone
=
div
.
cloneNode
(
true
)
.
cloneNode
(
true
)
.
lastChild
.
checked
;
div
.
innerHTML
=
"
<
textarea
>
x
<
/
textarea
>
"
;
support
.
noCloneChecked
=
!
!
div
.
cloneNode
(
true
)
.
lastChild
.
defaultValue
;
}
)
(
)
;
var
documentElement
=
document
.
documentElement
;
var
rkeyEvent
=
/
^
key
/
rmouseEvent
=
/
^
(
?
:
mouse
|
pointer
|
contextmenu
|
drag
|
drop
)
|
click
/
rtypenamespace
=
/
^
(
[
^
.
]
*
)
(
?
:
\
.
(
.
+
)
|
)
/
;
function
returnTrue
(
)
{
return
true
;
}
function
returnFalse
(
)
{
return
false
;
}
function
safeActiveElement
(
)
{
try
{
return
document
.
activeElement
;
}
catch
(
err
)
{
}
}
function
on
(
elem
types
selector
data
fn
one
)
{
var
origFn
type
;
if
(
typeof
types
=
=
=
"
object
"
)
{
if
(
typeof
selector
!
=
=
"
string
"
)
{
data
=
data
|
|
selector
;
selector
=
undefined
;
}
for
(
type
in
types
)
{
on
(
elem
type
selector
data
types
[
type
]
one
)
;
}
return
elem
;
}
if
(
data
=
=
null
&
&
fn
=
=
null
)
{
fn
=
selector
;
data
=
selector
=
undefined
;
}
else
if
(
fn
=
=
null
)
{
if
(
typeof
selector
=
=
=
"
string
"
)
{
fn
=
data
;
data
=
undefined
;
}
else
{
fn
=
data
;
data
=
selector
;
selector
=
undefined
;
}
}
if
(
fn
=
=
=
false
)
{
fn
=
returnFalse
;
}
else
if
(
!
fn
)
{
return
elem
;
}
if
(
one
=
=
=
1
)
{
origFn
=
fn
;
fn
=
function
(
event
)
{
jQuery
(
)
.
off
(
event
)
;
return
origFn
.
apply
(
this
arguments
)
;
}
;
fn
.
guid
=
origFn
.
guid
|
|
(
origFn
.
guid
=
jQuery
.
guid
+
+
)
;
}
return
elem
.
each
(
function
(
)
{
jQuery
.
event
.
add
(
this
types
fn
data
selector
)
;
}
)
;
}
jQuery
.
event
=
{
global
:
{
}
add
:
function
(
elem
types
handler
data
selector
)
{
var
handleObjIn
eventHandle
tmp
events
t
handleObj
special
handlers
type
namespaces
origType
elemData
=
dataPriv
.
get
(
elem
)
;
if
(
!
elemData
)
{
return
;
}
if
(
handler
.
handler
)
{
handleObjIn
=
handler
;
handler
=
handleObjIn
.
handler
;
selector
=
handleObjIn
.
selector
;
}
if
(
selector
)
{
jQuery
.
find
.
matchesSelector
(
documentElement
selector
)
;
}
if
(
!
handler
.
guid
)
{
handler
.
guid
=
jQuery
.
guid
+
+
;
}
if
(
!
(
events
=
elemData
.
events
)
)
{
events
=
elemData
.
events
=
{
}
;
}
if
(
!
(
eventHandle
=
elemData
.
handle
)
)
{
eventHandle
=
elemData
.
handle
=
function
(
e
)
{
return
typeof
jQuery
!
=
=
"
undefined
"
&
&
jQuery
.
event
.
triggered
!
=
=
e
.
type
?
jQuery
.
event
.
dispatch
.
apply
(
elem
arguments
)
:
undefined
;
}
;
}
types
=
(
types
|
|
"
"
)
.
match
(
rnothtmlwhite
)
|
|
[
"
"
]
;
t
=
types
.
length
;
while
(
t
-
-
)
{
tmp
=
rtypenamespace
.
exec
(
types
[
t
]
)
|
|
[
]
;
type
=
origType
=
tmp
[
1
]
;
namespaces
=
(
tmp
[
2
]
|
|
"
"
)
.
split
(
"
.
"
)
.
sort
(
)
;
if
(
!
type
)
{
continue
;
}
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
type
=
(
selector
?
special
.
delegateType
:
special
.
bindType
)
|
|
type
;
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
handleObj
=
jQuery
.
extend
(
{
type
:
type
origType
:
origType
data
:
data
handler
:
handler
guid
:
handler
.
guid
selector
:
selector
needsContext
:
selector
&
&
jQuery
.
expr
.
match
.
needsContext
.
test
(
selector
)
namespace
:
namespaces
.
join
(
"
.
"
)
}
handleObjIn
)
;
if
(
!
(
handlers
=
events
[
type
]
)
)
{
handlers
=
events
[
type
]
=
[
]
;
handlers
.
delegateCount
=
0
;
if
(
!
special
.
setup
|
|
special
.
setup
.
call
(
elem
data
namespaces
eventHandle
)
=
=
=
false
)
{
if
(
elem
.
addEventListener
)
{
elem
.
addEventListener
(
type
eventHandle
)
;
}
}
}
if
(
special
.
add
)
{
special
.
add
.
call
(
elem
handleObj
)
;
if
(
!
handleObj
.
handler
.
guid
)
{
handleObj
.
handler
.
guid
=
handler
.
guid
;
}
}
if
(
selector
)
{
handlers
.
splice
(
handlers
.
delegateCount
+
+
0
handleObj
)
;
}
else
{
handlers
.
push
(
handleObj
)
;
}
jQuery
.
event
.
global
[
type
]
=
true
;
}
}
remove
:
function
(
elem
types
handler
selector
mappedTypes
)
{
var
j
origCount
tmp
events
t
handleObj
special
handlers
type
namespaces
origType
elemData
=
dataPriv
.
hasData
(
elem
)
&
&
dataPriv
.
get
(
elem
)
;
if
(
!
elemData
|
|
!
(
events
=
elemData
.
events
)
)
{
return
;
}
types
=
(
types
|
|
"
"
)
.
match
(
rnothtmlwhite
)
|
|
[
"
"
]
;
t
=
types
.
length
;
while
(
t
-
-
)
{
tmp
=
rtypenamespace
.
exec
(
types
[
t
]
)
|
|
[
]
;
type
=
origType
=
tmp
[
1
]
;
namespaces
=
(
tmp
[
2
]
|
|
"
"
)
.
split
(
"
.
"
)
.
sort
(
)
;
if
(
!
type
)
{
for
(
type
in
events
)
{
jQuery
.
event
.
remove
(
elem
type
+
types
[
t
]
handler
selector
true
)
;
}
continue
;
}
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
type
=
(
selector
?
special
.
delegateType
:
special
.
bindType
)
|
|
type
;
handlers
=
events
[
type
]
|
|
[
]
;
tmp
=
tmp
[
2
]
&
&
new
RegExp
(
"
(
^
|
\
\
.
)
"
+
namespaces
.
join
(
"
\
\
.
(
?
:
.
*
\
\
.
|
)
"
)
+
"
(
\
\
.
|
)
"
)
;
origCount
=
j
=
handlers
.
length
;
while
(
j
-
-
)
{
handleObj
=
handlers
[
j
]
;
if
(
(
mappedTypes
|
|
origType
=
=
=
handleObj
.
origType
)
&
&
(
!
handler
|
|
handler
.
guid
=
=
=
handleObj
.
guid
)
&
&
(
!
tmp
|
|
tmp
.
test
(
handleObj
.
namespace
)
)
&
&
(
!
selector
|
|
selector
=
=
=
handleObj
.
selector
|
|
selector
=
=
=
"
*
*
"
&
&
handleObj
.
selector
)
)
{
handlers
.
splice
(
j
1
)
;
if
(
handleObj
.
selector
)
{
handlers
.
delegateCount
-
-
;
}
if
(
special
.
remove
)
{
special
.
remove
.
call
(
elem
handleObj
)
;
}
}
}
if
(
origCount
&
&
!
handlers
.
length
)
{
if
(
!
special
.
teardown
|
|
special
.
teardown
.
call
(
elem
namespaces
elemData
.
handle
)
=
=
=
false
)
{
jQuery
.
removeEvent
(
elem
type
elemData
.
handle
)
;
}
delete
events
[
type
]
;
}
}
if
(
jQuery
.
isEmptyObject
(
events
)
)
{
dataPriv
.
remove
(
elem
"
handle
events
"
)
;
}
}
dispatch
:
function
(
nativeEvent
)
{
var
event
=
jQuery
.
event
.
fix
(
nativeEvent
)
;
var
i
j
ret
matched
handleObj
handlerQueue
args
=
new
Array
(
arguments
.
length
)
handlers
=
(
dataPriv
.
get
(
this
"
events
"
)
|
|
{
}
)
[
event
.
type
]
|
|
[
]
special
=
jQuery
.
event
.
special
[
event
.
type
]
|
|
{
}
;
args
[
0
]
=
event
;
for
(
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
]
;
}
event
.
delegateTarget
=
this
;
if
(
special
.
preDispatch
&
&
special
.
preDispatch
.
call
(
this
event
)
=
=
=
false
)
{
return
;
}
handlerQueue
=
jQuery
.
event
.
handlers
.
call
(
this
event
handlers
)
;
i
=
0
;
while
(
(
matched
=
handlerQueue
[
i
+
+
]
)
&
&
!
event
.
isPropagationStopped
(
)
)
{
event
.
currentTarget
=
matched
.
elem
;
j
=
0
;
while
(
(
handleObj
=
matched
.
handlers
[
j
+
+
]
)
&
&
!
event
.
isImmediatePropagationStopped
(
)
)
{
if
(
!
event
.
rnamespace
|
|
event
.
rnamespace
.
test
(
handleObj
.
namespace
)
)
{
event
.
handleObj
=
handleObj
;
event
.
data
=
handleObj
.
data
;
ret
=
(
(
jQuery
.
event
.
special
[
handleObj
.
origType
]
|
|
{
}
)
.
handle
|
|
handleObj
.
handler
)
.
apply
(
matched
.
elem
args
)
;
if
(
ret
!
=
=
undefined
)
{
if
(
(
event
.
result
=
ret
)
=
=
=
false
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
}
}
}
if
(
special
.
postDispatch
)
{
special
.
postDispatch
.
call
(
this
event
)
;
}
return
event
.
result
;
}
handlers
:
function
(
event
handlers
)
{
var
i
handleObj
sel
matchedHandlers
matchedSelectors
handlerQueue
=
[
]
delegateCount
=
handlers
.
delegateCount
cur
=
event
.
target
;
if
(
delegateCount
&
&
cur
.
nodeType
&
&
!
(
event
.
type
=
=
=
"
click
"
&
&
event
.
button
>
=
1
)
)
{
for
(
;
cur
!
=
=
this
;
cur
=
cur
.
parentNode
|
|
this
)
{
if
(
cur
.
nodeType
=
=
=
1
&
&
!
(
event
.
type
=
=
=
"
click
"
&
&
cur
.
disabled
=
=
=
true
)
)
{
matchedHandlers
=
[
]
;
matchedSelectors
=
{
}
;
for
(
i
=
0
;
i
<
delegateCount
;
i
+
+
)
{
handleObj
=
handlers
[
i
]
;
sel
=
handleObj
.
selector
+
"
"
;
if
(
matchedSelectors
[
sel
]
=
=
=
undefined
)
{
matchedSelectors
[
sel
]
=
handleObj
.
needsContext
?
jQuery
(
sel
this
)
.
index
(
cur
)
>
-
1
:
jQuery
.
find
(
sel
this
null
[
cur
]
)
.
length
;
}
if
(
matchedSelectors
[
sel
]
)
{
matchedHandlers
.
push
(
handleObj
)
;
}
}
if
(
matchedHandlers
.
length
)
{
handlerQueue
.
push
(
{
elem
:
cur
handlers
:
matchedHandlers
}
)
;
}
}
}
}
cur
=
this
;
if
(
delegateCount
<
handlers
.
length
)
{
handlerQueue
.
push
(
{
elem
:
cur
handlers
:
handlers
.
slice
(
delegateCount
)
}
)
;
}
return
handlerQueue
;
}
addProp
:
function
(
name
hook
)
{
Object
.
defineProperty
(
jQuery
.
Event
.
prototype
name
{
enumerable
:
true
configurable
:
true
get
:
isFunction
(
hook
)
?
function
(
)
{
if
(
this
.
originalEvent
)
{
return
hook
(
this
.
originalEvent
)
;
}
}
:
function
(
)
{
if
(
this
.
originalEvent
)
{
return
this
.
originalEvent
[
name
]
;
}
}
set
:
function
(
value
)
{
Object
.
defineProperty
(
this
name
{
enumerable
:
true
configurable
:
true
writable
:
true
value
:
value
}
)
;
}
}
)
;
}
fix
:
function
(
originalEvent
)
{
return
originalEvent
[
jQuery
.
expando
]
?
originalEvent
:
new
jQuery
.
Event
(
originalEvent
)
;
}
special
:
{
load
:
{
noBubble
:
true
}
focus
:
{
trigger
:
function
(
)
{
if
(
this
!
=
=
safeActiveElement
(
)
&
&
this
.
focus
)
{
this
.
focus
(
)
;
return
false
;
}
}
delegateType
:
"
focusin
"
}
blur
:
{
trigger
:
function
(
)
{
if
(
this
=
=
=
safeActiveElement
(
)
&
&
this
.
blur
)
{
this
.
blur
(
)
;
return
false
;
}
}
delegateType
:
"
focusout
"
}
click
:
{
trigger
:
function
(
)
{
if
(
this
.
type
=
=
=
"
checkbox
"
&
&
this
.
click
&
&
nodeName
(
this
"
input
"
)
)
{
this
.
click
(
)
;
return
false
;
}
}
_default
:
function
(
event
)
{
return
nodeName
(
event
.
target
"
a
"
)
;
}
}
beforeunload
:
{
postDispatch
:
function
(
event
)
{
if
(
event
.
result
!
=
=
undefined
&
&
event
.
originalEvent
)
{
event
.
originalEvent
.
returnValue
=
event
.
result
;
}
}
}
}
}
;
jQuery
.
removeEvent
=
function
(
elem
type
handle
)
{
if
(
elem
.
removeEventListener
)
{
elem
.
removeEventListener
(
type
handle
)
;
}
}
;
jQuery
.
Event
=
function
(
src
props
)
{
if
(
!
(
this
instanceof
jQuery
.
Event
)
)
{
return
new
jQuery
.
Event
(
src
props
)
;
}
if
(
src
&
&
src
.
type
)
{
this
.
originalEvent
=
src
;
this
.
type
=
src
.
type
;
this
.
isDefaultPrevented
=
src
.
defaultPrevented
|
|
src
.
defaultPrevented
=
=
=
undefined
&
&
src
.
returnValue
=
=
=
false
?
returnTrue
:
returnFalse
;
this
.
target
=
(
src
.
target
&
&
src
.
target
.
nodeType
=
=
=
3
)
?
src
.
target
.
parentNode
:
src
.
target
;
this
.
currentTarget
=
src
.
currentTarget
;
this
.
relatedTarget
=
src
.
relatedTarget
;
}
else
{
this
.
type
=
src
;
}
if
(
props
)
{
jQuery
.
extend
(
this
props
)
;
}
this
.
timeStamp
=
src
&
&
src
.
timeStamp
|
|
Date
.
now
(
)
;
this
[
jQuery
.
expando
]
=
true
;
}
;
jQuery
.
Event
.
prototype
=
{
constructor
:
jQuery
.
Event
isDefaultPrevented
:
returnFalse
isPropagationStopped
:
returnFalse
isImmediatePropagationStopped
:
returnFalse
isSimulated
:
false
preventDefault
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isDefaultPrevented
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
preventDefault
(
)
;
}
}
stopPropagation
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isPropagationStopped
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
stopPropagation
(
)
;
}
}
stopImmediatePropagation
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isImmediatePropagationStopped
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
stopImmediatePropagation
(
)
;
}
this
.
stopPropagation
(
)
;
}
}
;
jQuery
.
each
(
{
altKey
:
true
bubbles
:
true
cancelable
:
true
changedTouches
:
true
ctrlKey
:
true
detail
:
true
eventPhase
:
true
metaKey
:
true
pageX
:
true
pageY
:
true
shiftKey
:
true
view
:
true
"
char
"
:
true
charCode
:
true
key
:
true
keyCode
:
true
button
:
true
buttons
:
true
clientX
:
true
clientY
:
true
offsetX
:
true
offsetY
:
true
pointerId
:
true
pointerType
:
true
screenX
:
true
screenY
:
true
targetTouches
:
true
toElement
:
true
touches
:
true
which
:
function
(
event
)
{
var
button
=
event
.
button
;
if
(
event
.
which
=
=
null
&
&
rkeyEvent
.
test
(
event
.
type
)
)
{
return
event
.
charCode
!
=
null
?
event
.
charCode
:
event
.
keyCode
;
}
if
(
!
event
.
which
&
&
button
!
=
=
undefined
&
&
rmouseEvent
.
test
(
event
.
type
)
)
{
if
(
button
&
1
)
{
return
1
;
}
if
(
button
&
2
)
{
return
3
;
}
if
(
button
&
4
)
{
return
2
;
}
return
0
;
}
return
event
.
which
;
}
}
jQuery
.
event
.
addProp
)
;
jQuery
.
each
(
{
mouseenter
:
"
mouseover
"
mouseleave
:
"
mouseout
"
pointerenter
:
"
pointerover
"
pointerleave
:
"
pointerout
"
}
function
(
orig
fix
)
{
jQuery
.
event
.
special
[
orig
]
=
{
delegateType
:
fix
bindType
:
fix
handle
:
function
(
event
)
{
var
ret
target
=
this
related
=
event
.
relatedTarget
handleObj
=
event
.
handleObj
;
if
(
!
related
|
|
(
related
!
=
=
target
&
&
!
jQuery
.
contains
(
target
related
)
)
)
{
event
.
type
=
handleObj
.
origType
;
ret
=
handleObj
.
handler
.
apply
(
this
arguments
)
;
event
.
type
=
fix
;
}
return
ret
;
}
}
;
}
)
;
jQuery
.
fn
.
extend
(
{
on
:
function
(
types
selector
data
fn
)
{
return
on
(
this
types
selector
data
fn
)
;
}
one
:
function
(
types
selector
data
fn
)
{
return
on
(
this
types
selector
data
fn
1
)
;
}
off
:
function
(
types
selector
fn
)
{
var
handleObj
type
;
if
(
types
&
&
types
.
preventDefault
&
&
types
.
handleObj
)
{
handleObj
=
types
.
handleObj
;
jQuery
(
types
.
delegateTarget
)
.
off
(
handleObj
.
namespace
?
handleObj
.
origType
+
"
.
"
+
handleObj
.
namespace
:
handleObj
.
origType
handleObj
.
selector
handleObj
.
handler
)
;
return
this
;
}
if
(
typeof
types
=
=
=
"
object
"
)
{
for
(
type
in
types
)
{
this
.
off
(
type
selector
types
[
type
]
)
;
}
return
this
;
}
if
(
selector
=
=
=
false
|
|
typeof
selector
=
=
=
"
function
"
)
{
fn
=
selector
;
selector
=
undefined
;
}
if
(
fn
=
=
=
false
)
{
fn
=
returnFalse
;
}
return
this
.
each
(
function
(
)
{
jQuery
.
event
.
remove
(
this
types
fn
selector
)
;
}
)
;
}
}
)
;
var
rxhtmlTag
=
/
<
(
?
!
area
|
br
|
col
|
embed
|
hr
|
img
|
input
|
link
|
meta
|
param
)
(
(
[
a
-
z
]
[
^
\
/
\
0
>
\
x20
\
t
\
r
\
n
\
f
]
*
)
[
^
>
]
*
)
\
/
>
/
gi
rnoInnerhtml
=
/
<
script
|
<
style
|
<
link
/
i
rchecked
=
/
checked
\
s
*
(
?
:
[
^
=
]
|
=
\
s
*
.
checked
.
)
/
i
rcleanScript
=
/
^
\
s
*
<
!
(
?
:
\
[
CDATA
\
[
|
-
-
)
|
(
?
:
\
]
\
]
|
-
-
)
>
\
s
*
/
g
;
function
manipulationTarget
(
elem
content
)
{
if
(
nodeName
(
elem
"
table
"
)
&
&
nodeName
(
content
.
nodeType
!
=
=
11
?
content
:
content
.
firstChild
"
tr
"
)
)
{
return
jQuery
(
elem
)
.
children
(
"
tbody
"
)
[
0
]
|
|
elem
;
}
return
elem
;
}
function
disableScript
(
elem
)
{
elem
.
type
=
(
elem
.
getAttribute
(
"
type
"
)
!
=
=
null
)
+
"
/
"
+
elem
.
type
;
return
elem
;
}
function
restoreScript
(
elem
)
{
if
(
(
elem
.
type
|
|
"
"
)
.
slice
(
0
5
)
=
=
=
"
true
/
"
)
{
elem
.
type
=
elem
.
type
.
slice
(
5
)
;
}
else
{
elem
.
removeAttribute
(
"
type
"
)
;
}
return
elem
;
}
function
cloneCopyEvent
(
src
dest
)
{
var
i
l
type
pdataOld
pdataCur
udataOld
udataCur
events
;
if
(
dest
.
nodeType
!
=
=
1
)
{
return
;
}
if
(
dataPriv
.
hasData
(
src
)
)
{
pdataOld
=
dataPriv
.
access
(
src
)
;
pdataCur
=
dataPriv
.
set
(
dest
pdataOld
)
;
events
=
pdataOld
.
events
;
if
(
events
)
{
delete
pdataCur
.
handle
;
pdataCur
.
events
=
{
}
;
for
(
type
in
events
)
{
for
(
i
=
0
l
=
events
[
type
]
.
length
;
i
<
l
;
i
+
+
)
{
jQuery
.
event
.
add
(
dest
type
events
[
type
]
[
i
]
)
;
}
}
}
}
if
(
dataUser
.
hasData
(
src
)
)
{
udataOld
=
dataUser
.
access
(
src
)
;
udataCur
=
jQuery
.
extend
(
{
}
udataOld
)
;
dataUser
.
set
(
dest
udataCur
)
;
}
}
function
fixInput
(
src
dest
)
{
var
nodeName
=
dest
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
"
input
"
&
&
rcheckableType
.
test
(
src
.
type
)
)
{
dest
.
checked
=
src
.
checked
;
}
else
if
(
nodeName
=
=
=
"
input
"
|
|
nodeName
=
=
=
"
textarea
"
)
{
dest
.
defaultValue
=
src
.
defaultValue
;
}
}
function
domManip
(
collection
args
callback
ignored
)
{
args
=
concat
.
apply
(
[
]
args
)
;
var
fragment
first
scripts
hasScripts
node
doc
i
=
0
l
=
collection
.
length
iNoClone
=
l
-
1
value
=
args
[
0
]
valueIsFunction
=
isFunction
(
value
)
;
if
(
valueIsFunction
|
|
(
l
>
1
&
&
typeof
value
=
=
=
"
string
"
&
&
!
support
.
checkClone
&
&
rchecked
.
test
(
value
)
)
)
{
return
collection
.
each
(
function
(
index
)
{
var
self
=
collection
.
eq
(
index
)
;
if
(
valueIsFunction
)
{
args
[
0
]
=
value
.
call
(
this
index
self
.
html
(
)
)
;
}
domManip
(
self
args
callback
ignored
)
;
}
)
;
}
if
(
l
)
{
fragment
=
buildFragment
(
args
collection
[
0
]
.
ownerDocument
false
collection
ignored
)
;
first
=
fragment
.
firstChild
;
if
(
fragment
.
childNodes
.
length
=
=
=
1
)
{
fragment
=
first
;
}
if
(
first
|
|
ignored
)
{
scripts
=
jQuery
.
map
(
getAll
(
fragment
"
script
"
)
disableScript
)
;
hasScripts
=
scripts
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
node
=
fragment
;
if
(
i
!
=
=
iNoClone
)
{
node
=
jQuery
.
clone
(
node
true
true
)
;
if
(
hasScripts
)
{
jQuery
.
merge
(
scripts
getAll
(
node
"
script
"
)
)
;
}
}
callback
.
call
(
collection
[
i
]
node
i
)
;
}
if
(
hasScripts
)
{
doc
=
scripts
[
scripts
.
length
-
1
]
.
ownerDocument
;
jQuery
.
map
(
scripts
restoreScript
)
;
for
(
i
=
0
;
i
<
hasScripts
;
i
+
+
)
{
node
=
scripts
[
i
]
;
if
(
rscriptType
.
test
(
node
.
type
|
|
"
"
)
&
&
!
dataPriv
.
access
(
node
"
globalEval
"
)
&
&
jQuery
.
contains
(
doc
node
)
)
{
if
(
node
.
src
&
&
(
node
.
type
|
|
"
"
)
.
toLowerCase
(
)
!
=
=
"
module
"
)
{
if
(
jQuery
.
_evalUrl
)
{
jQuery
.
_evalUrl
(
node
.
src
)
;
}
}
else
{
DOMEval
(
node
.
textContent
.
replace
(
rcleanScript
"
"
)
doc
node
)
;
}
}
}
}
}
}
return
collection
;
}
function
remove
(
elem
selector
keepData
)
{
var
node
nodes
=
selector
?
jQuery
.
filter
(
selector
elem
)
:
elem
i
=
0
;
for
(
;
(
node
=
nodes
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
!
keepData
&
&
node
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
node
)
)
;
}
if
(
node
.
parentNode
)
{
if
(
keepData
&
&
jQuery
.
contains
(
node
.
ownerDocument
node
)
)
{
setGlobalEval
(
getAll
(
node
"
script
"
)
)
;
}
node
.
parentNode
.
removeChild
(
node
)
;
}
}
return
elem
;
}
jQuery
.
extend
(
{
htmlPrefilter
:
function
(
html
)
{
return
html
.
replace
(
rxhtmlTag
"
<
1
>
<
/
2
>
"
)
;
}
clone
:
function
(
elem
dataAndEvents
deepDataAndEvents
)
{
var
i
l
srcElements
destElements
clone
=
elem
.
cloneNode
(
true
)
inPage
=
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
;
if
(
!
support
.
noCloneChecked
&
&
(
elem
.
nodeType
=
=
=
1
|
|
elem
.
nodeType
=
=
=
11
)
&
&
!
jQuery
.
isXMLDoc
(
elem
)
)
{
destElements
=
getAll
(
clone
)
;
srcElements
=
getAll
(
elem
)
;
for
(
i
=
0
l
=
srcElements
.
length
;
i
<
l
;
i
+
+
)
{
fixInput
(
srcElements
[
i
]
destElements
[
i
]
)
;
}
}
if
(
dataAndEvents
)
{
if
(
deepDataAndEvents
)
{
srcElements
=
srcElements
|
|
getAll
(
elem
)
;
destElements
=
destElements
|
|
getAll
(
clone
)
;
for
(
i
=
0
l
=
srcElements
.
length
;
i
<
l
;
i
+
+
)
{
cloneCopyEvent
(
srcElements
[
i
]
destElements
[
i
]
)
;
}
}
else
{
cloneCopyEvent
(
elem
clone
)
;
}
}
destElements
=
getAll
(
clone
"
script
"
)
;
if
(
destElements
.
length
>
0
)
{
setGlobalEval
(
destElements
!
inPage
&
&
getAll
(
elem
"
script
"
)
)
;
}
return
clone
;
}
cleanData
:
function
(
elems
)
{
var
data
elem
type
special
=
jQuery
.
event
.
special
i
=
0
;
for
(
;
(
elem
=
elems
[
i
]
)
!
=
=
undefined
;
i
+
+
)
{
if
(
acceptData
(
elem
)
)
{
if
(
(
data
=
elem
[
dataPriv
.
expando
]
)
)
{
if
(
data
.
events
)
{
for
(
type
in
data
.
events
)
{
if
(
special
[
type
]
)
{
jQuery
.
event
.
remove
(
elem
type
)
;
}
else
{
jQuery
.
removeEvent
(
elem
type
data
.
handle
)
;
}
}
}
elem
[
dataPriv
.
expando
]
=
undefined
;
}
if
(
elem
[
dataUser
.
expando
]
)
{
elem
[
dataUser
.
expando
]
=
undefined
;
}
}
}
}
}
)
;
jQuery
.
fn
.
extend
(
{
detach
:
function
(
selector
)
{
return
remove
(
this
selector
true
)
;
}
remove
:
function
(
selector
)
{
return
remove
(
this
selector
)
;
}
text
:
function
(
value
)
{
return
access
(
this
function
(
value
)
{
return
value
=
=
=
undefined
?
jQuery
.
text
(
this
)
:
this
.
empty
(
)
.
each
(
function
(
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
this
.
textContent
=
value
;
}
}
)
;
}
null
value
arguments
.
length
)
;
}
append
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
var
target
=
manipulationTarget
(
this
elem
)
;
target
.
appendChild
(
elem
)
;
}
}
)
;
}
prepend
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
var
target
=
manipulationTarget
(
this
elem
)
;
target
.
insertBefore
(
elem
target
.
firstChild
)
;
}
}
)
;
}
before
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
parentNode
)
{
this
.
parentNode
.
insertBefore
(
elem
this
)
;
}
}
)
;
}
after
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
parentNode
)
{
this
.
parentNode
.
insertBefore
(
elem
this
.
nextSibling
)
;
}
}
)
;
}
empty
:
function
(
)
{
var
elem
i
=
0
;
for
(
;
(
elem
=
this
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
elem
false
)
)
;
elem
.
textContent
=
"
"
;
}
}
return
this
;
}
clone
:
function
(
dataAndEvents
deepDataAndEvents
)
{
dataAndEvents
=
dataAndEvents
=
=
null
?
false
:
dataAndEvents
;
deepDataAndEvents
=
deepDataAndEvents
=
=
null
?
dataAndEvents
:
deepDataAndEvents
;
return
this
.
map
(
function
(
)
{
return
jQuery
.
clone
(
this
dataAndEvents
deepDataAndEvents
)
;
}
)
;
}
html
:
function
(
value
)
{
return
access
(
this
function
(
value
)
{
var
elem
=
this
[
0
]
|
|
{
}
i
=
0
l
=
this
.
length
;
if
(
value
=
=
=
undefined
&
&
elem
.
nodeType
=
=
=
1
)
{
return
elem
.
innerHTML
;
}
if
(
typeof
value
=
=
=
"
string
"
&
&
!
rnoInnerhtml
.
test
(
value
)
&
&
!
wrapMap
[
(
rtagName
.
exec
(
value
)
|
|
[
"
"
"
"
]
)
[
1
]
.
toLowerCase
(
)
]
)
{
value
=
jQuery
.
htmlPrefilter
(
value
)
;
try
{
for
(
;
i
<
l
;
i
+
+
)
{
elem
=
this
[
i
]
|
|
{
}
;
if
(
elem
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
elem
false
)
)
;
elem
.
innerHTML
=
value
;
}
}
elem
=
0
;
}
catch
(
e
)
{
}
}
if
(
elem
)
{
this
.
empty
(
)
.
append
(
value
)
;
}
}
null
value
arguments
.
length
)
;
}
replaceWith
:
function
(
)
{
var
ignored
=
[
]
;
return
domManip
(
this
arguments
function
(
elem
)
{
var
parent
=
this
.
parentNode
;
if
(
jQuery
.
inArray
(
this
ignored
)
<
0
)
{
jQuery
.
cleanData
(
getAll
(
this
)
)
;
if
(
parent
)
{
parent
.
replaceChild
(
elem
this
)
;
}
}
}
ignored
)
;
}
}
)
;
jQuery
.
each
(
{
appendTo
:
"
append
"
prependTo
:
"
prepend
"
insertBefore
:
"
before
"
insertAfter
:
"
after
"
replaceAll
:
"
replaceWith
"
}
function
(
name
original
)
{
jQuery
.
fn
[
name
]
=
function
(
selector
)
{
var
elems
ret
=
[
]
insert
=
jQuery
(
selector
)
last
=
insert
.
length
-
1
i
=
0
;
for
(
;
i
<
=
last
;
i
+
+
)
{
elems
=
i
=
=
=
last
?
this
:
this
.
clone
(
true
)
;
jQuery
(
insert
[
i
]
)
[
original
]
(
elems
)
;
push
.
apply
(
ret
elems
.
get
(
)
)
;
}
return
this
.
pushStack
(
ret
)
;
}
;
}
)
;
var
rnumnonpx
=
new
RegExp
(
"
^
(
"
+
pnum
+
"
)
(
?
!
px
)
[
a
-
z
%
]
+
"
"
i
"
)
;
var
getStyles
=
function
(
elem
)
{
var
view
=
elem
.
ownerDocument
.
defaultView
;
if
(
!
view
|
|
!
view
.
opener
)
{
view
=
window
;
}
return
view
.
getComputedStyle
(
elem
)
;
}
;
var
rboxStyle
=
new
RegExp
(
cssExpand
.
join
(
"
|
"
)
"
i
"
)
;
(
function
(
)
{
function
computeStyleTests
(
)
{
if
(
!
div
)
{
return
;
}
container
.
style
.
cssText
=
"
position
:
absolute
;
left
:
-
11111px
;
width
:
60px
;
"
+
"
margin
-
top
:
1px
;
padding
:
0
;
border
:
0
"
;
div
.
style
.
cssText
=
"
position
:
relative
;
display
:
block
;
box
-
sizing
:
border
-
box
;
overflow
:
scroll
;
"
+
"
margin
:
auto
;
border
:
1px
;
padding
:
1px
;
"
+
"
width
:
60
%
;
top
:
1
%
"
;
documentElement
.
appendChild
(
container
)
.
appendChild
(
div
)
;
var
divStyle
=
window
.
getComputedStyle
(
div
)
;
pixelPositionVal
=
divStyle
.
top
!
=
=
"
1
%
"
;
reliableMarginLeftVal
=
roundPixelMeasures
(
divStyle
.
marginLeft
)
=
=
=
12
;
div
.
style
.
right
=
"
60
%
"
;
pixelBoxStylesVal
=
roundPixelMeasures
(
divStyle
.
right
)
=
=
=
36
;
boxSizingReliableVal
=
roundPixelMeasures
(
divStyle
.
width
)
=
=
=
36
;
div
.
style
.
position
=
"
absolute
"
;
scrollboxSizeVal
=
div
.
offsetWidth
=
=
=
36
|
|
"
absolute
"
;
documentElement
.
removeChild
(
container
)
;
div
=
null
;
}
function
roundPixelMeasures
(
measure
)
{
return
Math
.
round
(
parseFloat
(
measure
)
)
;
}
var
pixelPositionVal
boxSizingReliableVal
scrollboxSizeVal
pixelBoxStylesVal
reliableMarginLeftVal
container
=
document
.
createElement
(
"
div
"
)
div
=
document
.
createElement
(
"
div
"
)
;
if
(
!
div
.
style
)
{
return
;
}
div
.
style
.
backgroundClip
=
"
content
-
box
"
;
div
.
cloneNode
(
true
)
.
style
.
backgroundClip
=
"
"
;
support
.
clearCloneStyle
=
div
.
style
.
backgroundClip
=
=
=
"
content
-
box
"
;
jQuery
.
extend
(
support
{
boxSizingReliable
:
function
(
)
{
computeStyleTests
(
)
;
return
boxSizingReliableVal
;
}
pixelBoxStyles
:
function
(
)
{
computeStyleTests
(
)
;
return
pixelBoxStylesVal
;
}
pixelPosition
:
function
(
)
{
computeStyleTests
(
)
;
return
pixelPositionVal
;
}
reliableMarginLeft
:
function
(
)
{
computeStyleTests
(
)
;
return
reliableMarginLeftVal
;
}
scrollboxSize
:
function
(
)
{
computeStyleTests
(
)
;
return
scrollboxSizeVal
;
}
}
)
;
}
)
(
)
;
function
curCSS
(
elem
name
computed
)
{
var
width
minWidth
maxWidth
ret
style
=
elem
.
style
;
computed
=
computed
|
|
getStyles
(
elem
)
;
if
(
computed
)
{
ret
=
computed
.
getPropertyValue
(
name
)
|
|
computed
[
name
]
;
if
(
ret
=
=
=
"
"
&
&
!
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
)
{
ret
=
jQuery
.
style
(
elem
name
)
;
}
if
(
!
support
.
pixelBoxStyles
(
)
&
&
rnumnonpx
.
test
(
ret
)
&
&
rboxStyle
.
test
(
name
)
)
{
width
=
style
.
width
;
minWidth
=
style
.
minWidth
;
maxWidth
=
style
.
maxWidth
;
style
.
minWidth
=
style
.
maxWidth
=
style
.
width
=
ret
;
ret
=
computed
.
width
;
style
.
width
=
width
;
style
.
minWidth
=
minWidth
;
style
.
maxWidth
=
maxWidth
;
}
}
return
ret
!
=
=
undefined
?
ret
+
"
"
:
ret
;
}
function
addGetHookIf
(
conditionFn
hookFn
)
{
return
{
get
:
function
(
)
{
if
(
conditionFn
(
)
)
{
delete
this
.
get
;
return
;
}
return
(
this
.
get
=
hookFn
)
.
apply
(
this
arguments
)
;
}
}
;
}
var
rdisplayswap
=
/
^
(
none
|
table
(
?
!
-
c
[
ea
]
)
.
+
)
/
rcustomProp
=
/
^
-
-
/
cssShow
=
{
position
:
"
absolute
"
visibility
:
"
hidden
"
display
:
"
block
"
}
cssNormalTransform
=
{
letterSpacing
:
"
0
"
fontWeight
:
"
400
"
}
cssPrefixes
=
[
"
Webkit
"
"
Moz
"
"
ms
"
]
emptyStyle
=
document
.
createElement
(
"
div
"
)
.
style
;
function
vendorPropName
(
name
)
{
if
(
name
in
emptyStyle
)
{
return
name
;
}
var
capName
=
name
[
0
]
.
toUpperCase
(
)
+
name
.
slice
(
1
)
i
=
cssPrefixes
.
length
;
while
(
i
-
-
)
{
name
=
cssPrefixes
[
i
]
+
capName
;
if
(
name
in
emptyStyle
)
{
return
name
;
}
}
}
function
finalPropName
(
name
)
{
var
ret
=
jQuery
.
cssProps
[
name
]
;
if
(
!
ret
)
{
ret
=
jQuery
.
cssProps
[
name
]
=
vendorPropName
(
name
)
|
|
name
;
}
return
ret
;
}
function
setPositiveNumber
(
elem
value
subtract
)
{
var
matches
=
rcssNum
.
exec
(
value
)
;
return
matches
?
Math
.
max
(
0
matches
[
2
]
-
(
subtract
|
|
0
)
)
+
(
matches
[
3
]
|
|
"
px
"
)
:
value
;
}
function
boxModelAdjustment
(
elem
dimension
box
isBorderBox
styles
computedVal
)
{
var
i
=
dimension
=
=
=
"
width
"
?
1
:
0
extra
=
0
delta
=
0
;
if
(
box
=
=
=
(
isBorderBox
?
"
border
"
:
"
content
"
)
)
{
return
0
;
}
for
(
;
i
<
4
;
i
+
=
2
)
{
if
(
box
=
=
=
"
margin
"
)
{
delta
+
=
jQuery
.
css
(
elem
box
+
cssExpand
[
i
]
true
styles
)
;
}
if
(
!
isBorderBox
)
{
delta
+
=
jQuery
.
css
(
elem
"
padding
"
+
cssExpand
[
i
]
true
styles
)
;
if
(
box
!
=
=
"
padding
"
)
{
delta
+
=
jQuery
.
css
(
elem
"
border
"
+
cssExpand
[
i
]
+
"
Width
"
true
styles
)
;
}
else
{
extra
+
=
jQuery
.
css
(
elem
"
border
"
+
cssExpand
[
i
]
+
"
Width
"
true
styles
)
;
}
}
else
{
if
(
box
=
=
=
"
content
"
)
{
delta
-
=
jQuery
.
css
(
elem
"
padding
"
+
cssExpand
[
i
]
true
styles
)
;
}
if
(
box
!
=
=
"
margin
"
)
{
delta
-
=
jQuery
.
css
(
elem
"
border
"
+
cssExpand
[
i
]
+
"
Width
"
true
styles
)
;
}
}
}
if
(
!
isBorderBox
&
&
computedVal
>
=
0
)
{
delta
+
=
Math
.
max
(
0
Math
.
ceil
(
elem
[
"
offset
"
+
dimension
[
0
]
.
toUpperCase
(
)
+
dimension
.
slice
(
1
)
]
-
computedVal
-
delta
-
extra
-
0
.
5
)
)
;
}
return
delta
;
}
function
getWidthOrHeight
(
elem
dimension
extra
)
{
var
styles
=
getStyles
(
elem
)
val
=
curCSS
(
elem
dimension
styles
)
isBorderBox
=
jQuery
.
css
(
elem
"
boxSizing
"
false
styles
)
=
=
=
"
border
-
box
"
valueIsBorderBox
=
isBorderBox
;
if
(
rnumnonpx
.
test
(
val
)
)
{
if
(
!
extra
)
{
return
val
;
}
val
=
"
auto
"
;
}
valueIsBorderBox
=
valueIsBorderBox
&
&
(
support
.
boxSizingReliable
(
)
|
|
val
=
=
=
elem
.
style
[
dimension
]
)
;
if
(
val
=
=
=
"
auto
"
|
|
!
parseFloat
(
val
)
&
&
jQuery
.
css
(
elem
"
display
"
false
styles
)
=
=
=
"
inline
"
)
{
val
=
elem
[
"
offset
"
+
dimension
[
0
]
.
toUpperCase
(
)
+
dimension
.
slice
(
1
)
]
;
valueIsBorderBox
=
true
;
}
val
=
parseFloat
(
val
)
|
|
0
;
return
(
val
+
boxModelAdjustment
(
elem
dimension
extra
|
|
(
isBorderBox
?
"
border
"
:
"
content
"
)
valueIsBorderBox
styles
val
)
)
+
"
px
"
;
}
jQuery
.
extend
(
{
cssHooks
:
{
opacity
:
{
get
:
function
(
elem
computed
)
{
if
(
computed
)
{
var
ret
=
curCSS
(
elem
"
opacity
"
)
;
return
ret
=
=
=
"
"
?
"
1
"
:
ret
;
}
}
}
}
cssNumber
:
{
"
animationIterationCount
"
:
true
"
columnCount
"
:
true
"
fillOpacity
"
:
true
"
flexGrow
"
:
true
"
flexShrink
"
:
true
"
fontWeight
"
:
true
"
lineHeight
"
:
true
"
opacity
"
:
true
"
order
"
:
true
"
orphans
"
:
true
"
widows
"
:
true
"
zIndex
"
:
true
"
zoom
"
:
true
}
cssProps
:
{
}
style
:
function
(
elem
name
value
extra
)
{
if
(
!
elem
|
|
elem
.
nodeType
=
=
=
3
|
|
elem
.
nodeType
=
=
=
8
|
|
!
elem
.
style
)
{
return
;
}
var
ret
type
hooks
origName
=
camelCase
(
name
)
isCustomProp
=
rcustomProp
.
test
(
name
)
style
=
elem
.
style
;
if
(
!
isCustomProp
)
{
name
=
finalPropName
(
origName
)
;
}
hooks
=
jQuery
.
cssHooks
[
name
]
|
|
jQuery
.
cssHooks
[
origName
]
;
if
(
value
!
=
=
undefined
)
{
type
=
typeof
value
;
if
(
type
=
=
=
"
string
"
&
&
(
ret
=
rcssNum
.
exec
(
value
)
)
&
&
ret
[
1
]
)
{
value
=
adjustCSS
(
elem
name
ret
)
;
type
=
"
number
"
;
}
if
(
value
=
=
null
|
|
value
!
=
=
value
)
{
return
;
}
if
(
type
=
=
=
"
number
"
)
{
value
+
=
ret
&
&
ret
[
3
]
|
|
(
jQuery
.
cssNumber
[
origName
]
?
"
"
:
"
px
"
)
;
}
if
(
!
support
.
clearCloneStyle
&
&
value
=
=
=
"
"
&
&
name
.
indexOf
(
"
background
"
)
=
=
=
0
)
{
style
[
name
]
=
"
inherit
"
;
}
if
(
!
hooks
|
|
!
(
"
set
"
in
hooks
)
|
|
(
value
=
hooks
.
set
(
elem
value
extra
)
)
!
=
=
undefined
)
{
if
(
isCustomProp
)
{
style
.
setProperty
(
name
value
)
;
}
else
{
style
[
name
]
=
value
;
}
}
}
else
{
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
false
extra
)
)
!
=
=
undefined
)
{
return
ret
;
}
return
style
[
name
]
;
}
}
css
:
function
(
elem
name
extra
styles
)
{
var
val
num
hooks
origName
=
camelCase
(
name
)
isCustomProp
=
rcustomProp
.
test
(
name
)
;
if
(
!
isCustomProp
)
{
name
=
finalPropName
(
origName
)
;
}
hooks
=
jQuery
.
cssHooks
[
name
]
|
|
jQuery
.
cssHooks
[
origName
]
;
if
(
hooks
&
&
"
get
"
in
hooks
)
{
val
=
hooks
.
get
(
elem
true
extra
)
;
}
if
(
val
=
=
=
undefined
)
{
val
=
curCSS
(
elem
name
styles
)
;
}
if
(
val
=
=
=
"
normal
"
&
&
name
in
cssNormalTransform
)
{
val
=
cssNormalTransform
[
name
]
;
}
if
(
extra
=
=
=
"
"
|
|
extra
)
{
num
=
parseFloat
(
val
)
;
return
extra
=
=
=
true
|
|
isFinite
(
num
)
?
num
|
|
0
:
val
;
}
return
val
;
}
}
)
;
jQuery
.
each
(
[
"
height
"
"
width
"
]
function
(
i
dimension
)
{
jQuery
.
cssHooks
[
dimension
]
=
{
get
:
function
(
elem
computed
extra
)
{
if
(
computed
)
{
return
rdisplayswap
.
test
(
jQuery
.
css
(
elem
"
display
"
)
)
&
&
(
!
elem
.
getClientRects
(
)
.
length
|
|
!
elem
.
getBoundingClientRect
(
)
.
width
)
?
swap
(
elem
cssShow
function
(
)
{
return
getWidthOrHeight
(
elem
dimension
extra
)
;
}
)
:
getWidthOrHeight
(
elem
dimension
extra
)
;
}
}
set
:
function
(
elem
value
extra
)
{
var
matches
styles
=
getStyles
(
elem
)
isBorderBox
=
jQuery
.
css
(
elem
"
boxSizing
"
false
styles
)
=
=
=
"
border
-
box
"
subtract
=
extra
&
&
boxModelAdjustment
(
elem
dimension
extra
isBorderBox
styles
)
;
if
(
isBorderBox
&
&
support
.
scrollboxSize
(
)
=
=
=
styles
.
position
)
{
subtract
-
=
Math
.
ceil
(
elem
[
"
offset
"
+
dimension
[
0
]
.
toUpperCase
(
)
+
dimension
.
slice
(
1
)
]
-
parseFloat
(
styles
[
dimension
]
)
-
boxModelAdjustment
(
elem
dimension
"
border
"
false
styles
)
-
0
.
5
)
;
}
if
(
subtract
&
&
(
matches
=
rcssNum
.
exec
(
value
)
)
&
&
(
matches
[
3
]
|
|
"
px
"
)
!
=
=
"
px
"
)
{
elem
.
style
[
dimension
]
=
value
;
value
=
jQuery
.
css
(
elem
dimension
)
;
}
return
setPositiveNumber
(
elem
value
subtract
)
;
}
}
;
}
)
;
jQuery
.
cssHooks
.
marginLeft
=
addGetHookIf
(
support
.
reliableMarginLeft
function
(
elem
computed
)
{
if
(
computed
)
{
return
(
parseFloat
(
curCSS
(
elem
"
marginLeft
"
)
)
|
|
elem
.
getBoundingClientRect
(
)
.
left
-
swap
(
elem
{
marginLeft
:
0
}
function
(
)
{
return
elem
.
getBoundingClientRect
(
)
.
left
;
}
)
)
+
"
px
"
;
}
}
)
;
jQuery
.
each
(
{
margin
:
"
"
padding
:
"
"
border
:
"
Width
"
}
function
(
prefix
suffix
)
{
jQuery
.
cssHooks
[
prefix
+
suffix
]
=
{
expand
:
function
(
value
)
{
var
i
=
0
expanded
=
{
}
parts
=
typeof
value
=
=
=
"
string
"
?
value
.
split
(
"
"
)
:
[
value
]
;
for
(
;
i
<
4
;
i
+
+
)
{
expanded
[
prefix
+
cssExpand
[
i
]
+
suffix
]
=
parts
[
i
]
|
|
parts
[
i
-
2
]
|
|
parts
[
0
]
;
}
return
expanded
;
}
}
;
if
(
prefix
!
=
=
"
margin
"
)
{
jQuery
.
cssHooks
[
prefix
+
suffix
]
.
set
=
setPositiveNumber
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
css
:
function
(
name
value
)
{
return
access
(
this
function
(
elem
name
value
)
{
var
styles
len
map
=
{
}
i
=
0
;
if
(
Array
.
isArray
(
name
)
)
{
styles
=
getStyles
(
elem
)
;
len
=
name
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
map
[
name
[
i
]
]
=
jQuery
.
css
(
elem
name
[
i
]
false
styles
)
;
}
return
map
;
}
return
value
!
=
=
undefined
?
jQuery
.
style
(
elem
name
value
)
:
jQuery
.
css
(
elem
name
)
;
}
name
value
arguments
.
length
>
1
)
;
}
}
)
;
function
Tween
(
elem
options
prop
end
easing
)
{
return
new
Tween
.
prototype
.
init
(
elem
options
prop
end
easing
)
;
}
jQuery
.
Tween
=
Tween
;
Tween
.
prototype
=
{
constructor
:
Tween
init
:
function
(
elem
options
prop
end
easing
unit
)
{
this
.
elem
=
elem
;
this
.
prop
=
prop
;
this
.
easing
=
easing
|
|
jQuery
.
easing
.
_default
;
this
.
options
=
options
;
this
.
start
=
this
.
now
=
this
.
cur
(
)
;
this
.
end
=
end
;
this
.
unit
=
unit
|
|
(
jQuery
.
cssNumber
[
prop
]
?
"
"
:
"
px
"
)
;
}
cur
:
function
(
)
{
var
hooks
=
Tween
.
propHooks
[
this
.
prop
]
;
return
hooks
&
&
hooks
.
get
?
hooks
.
get
(
this
)
:
Tween
.
propHooks
.
_default
.
get
(
this
)
;
}
run
:
function
(
percent
)
{
var
eased
hooks
=
Tween
.
propHooks
[
this
.
prop
]
;
if
(
this
.
options
.
duration
)
{
this
.
pos
=
eased
=
jQuery
.
easing
[
this
.
easing
]
(
percent
this
.
options
.
duration
*
percent
0
1
this
.
options
.
duration
)
;
}
else
{
this
.
pos
=
eased
=
percent
;
}
this
.
now
=
(
this
.
end
-
this
.
start
)
*
eased
+
this
.
start
;
if
(
this
.
options
.
step
)
{
this
.
options
.
step
.
call
(
this
.
elem
this
.
now
this
)
;
}
if
(
hooks
&
&
hooks
.
set
)
{
hooks
.
set
(
this
)
;
}
else
{
Tween
.
propHooks
.
_default
.
set
(
this
)
;
}
return
this
;
}
}
;
Tween
.
prototype
.
init
.
prototype
=
Tween
.
prototype
;
Tween
.
propHooks
=
{
_default
:
{
get
:
function
(
tween
)
{
var
result
;
if
(
tween
.
elem
.
nodeType
!
=
=
1
|
|
tween
.
elem
[
tween
.
prop
]
!
=
null
&
&
tween
.
elem
.
style
[
tween
.
prop
]
=
=
null
)
{
return
tween
.
elem
[
tween
.
prop
]
;
}
result
=
jQuery
.
css
(
tween
.
elem
tween
.
prop
"
"
)
;
return
!
result
|
|
result
=
=
=
"
auto
"
?
0
:
result
;
}
set
:
function
(
tween
)
{
if
(
jQuery
.
fx
.
step
[
tween
.
prop
]
)
{
jQuery
.
fx
.
step
[
tween
.
prop
]
(
tween
)
;
}
else
if
(
tween
.
elem
.
nodeType
=
=
=
1
&
&
(
tween
.
elem
.
style
[
jQuery
.
cssProps
[
tween
.
prop
]
]
!
=
null
|
|
jQuery
.
cssHooks
[
tween
.
prop
]
)
)
{
jQuery
.
style
(
tween
.
elem
tween
.
prop
tween
.
now
+
tween
.
unit
)
;
}
else
{
tween
.
elem
[
tween
.
prop
]
=
tween
.
now
;
}
}
}
}
;
Tween
.
propHooks
.
scrollTop
=
Tween
.
propHooks
.
scrollLeft
=
{
set
:
function
(
tween
)
{
if
(
tween
.
elem
.
nodeType
&
&
tween
.
elem
.
parentNode
)
{
tween
.
elem
[
tween
.
prop
]
=
tween
.
now
;
}
}
}
;
jQuery
.
easing
=
{
linear
:
function
(
p
)
{
return
p
;
}
swing
:
function
(
p
)
{
return
0
.
5
-
Math
.
cos
(
p
*
Math
.
PI
)
/
2
;
}
_default
:
"
swing
"
}
;
jQuery
.
fx
=
Tween
.
prototype
.
init
;
jQuery
.
fx
.
step
=
{
}
;
var
fxNow
inProgress
rfxtypes
=
/
^
(
?
:
toggle
|
show
|
hide
)
/
rrun
=
/
queueHooks
/
;
function
schedule
(
)
{
if
(
inProgress
)
{
if
(
document
.
hidden
=
=
=
false
&
&
window
.
requestAnimationFrame
)
{
window
.
requestAnimationFrame
(
schedule
)
;
}
else
{
window
.
setTimeout
(
schedule
jQuery
.
fx
.
interval
)
;
}
jQuery
.
fx
.
tick
(
)
;
}
}
function
createFxNow
(
)
{
window
.
setTimeout
(
function
(
)
{
fxNow
=
undefined
;
}
)
;
return
(
fxNow
=
Date
.
now
(
)
)
;
}
function
genFx
(
type
includeWidth
)
{
var
which
i
=
0
attrs
=
{
height
:
type
}
;
includeWidth
=
includeWidth
?
1
:
0
;
for
(
;
i
<
4
;
i
+
=
2
-
includeWidth
)
{
which
=
cssExpand
[
i
]
;
attrs
[
"
margin
"
+
which
]
=
attrs
[
"
padding
"
+
which
]
=
type
;
}
if
(
includeWidth
)
{
attrs
.
opacity
=
attrs
.
width
=
type
;
}
return
attrs
;
}
function
createTween
(
value
prop
animation
)
{
var
tween
collection
=
(
Animation
.
tweeners
[
prop
]
|
|
[
]
)
.
concat
(
Animation
.
tweeners
[
"
*
"
]
)
index
=
0
length
=
collection
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
if
(
(
tween
=
collection
[
index
]
.
call
(
animation
prop
value
)
)
)
{
return
tween
;
}
}
}
function
defaultPrefilter
(
elem
props
opts
)
{
var
prop
value
toggle
hooks
oldfire
propTween
restoreDisplay
display
isBox
=
"
width
"
in
props
|
|
"
height
"
in
props
anim
=
this
orig
=
{
}
style
=
elem
.
style
hidden
=
elem
.
nodeType
&
&
isHiddenWithinTree
(
elem
)
dataShow
=
dataPriv
.
get
(
elem
"
fxshow
"
)
;
if
(
!
opts
.
queue
)
{
hooks
=
jQuery
.
_queueHooks
(
elem
"
fx
"
)
;
if
(
hooks
.
unqueued
=
=
null
)
{
hooks
.
unqueued
=
0
;
oldfire
=
hooks
.
empty
.
fire
;
hooks
.
empty
.
fire
=
function
(
)
{
if
(
!
hooks
.
unqueued
)
{
oldfire
(
)
;
}
}
;
}
hooks
.
unqueued
+
+
;
anim
.
always
(
function
(
)
{
anim
.
always
(
function
(
)
{
hooks
.
unqueued
-
-
;
if
(
!
jQuery
.
queue
(
elem
"
fx
"
)
.
length
)
{
hooks
.
empty
.
fire
(
)
;
}
}
)
;
}
)
;
}
for
(
prop
in
props
)
{
value
=
props
[
prop
]
;
if
(
rfxtypes
.
test
(
value
)
)
{
delete
props
[
prop
]
;
toggle
=
toggle
|
|
value
=
=
=
"
toggle
"
;
if
(
value
=
=
=
(
hidden
?
"
hide
"
:
"
show
"
)
)
{
if
(
value
=
=
=
"
show
"
&
&
dataShow
&
&
dataShow
[
prop
]
!
=
=
undefined
)
{
hidden
=
true
;
}
else
{
continue
;
}
}
orig
[
prop
]
=
dataShow
&
&
dataShow
[
prop
]
|
|
jQuery
.
style
(
elem
prop
)
;
}
}
propTween
=
!
jQuery
.
isEmptyObject
(
props
)
;
if
(
!
propTween
&
&
jQuery
.
isEmptyObject
(
orig
)
)
{
return
;
}
if
(
isBox
&
&
elem
.
nodeType
=
=
=
1
)
{
opts
.
overflow
=
[
style
.
overflow
style
.
overflowX
style
.
overflowY
]
;
restoreDisplay
=
dataShow
&
&
dataShow
.
display
;
if
(
restoreDisplay
=
=
null
)
{
restoreDisplay
=
dataPriv
.
get
(
elem
"
display
"
)
;
}
display
=
jQuery
.
css
(
elem
"
display
"
)
;
if
(
display
=
=
=
"
none
"
)
{
if
(
restoreDisplay
)
{
display
=
restoreDisplay
;
}
else
{
showHide
(
[
elem
]
true
)
;
restoreDisplay
=
elem
.
style
.
display
|
|
restoreDisplay
;
display
=
jQuery
.
css
(
elem
"
display
"
)
;
showHide
(
[
elem
]
)
;
}
}
if
(
display
=
=
=
"
inline
"
|
|
display
=
=
=
"
inline
-
block
"
&
&
restoreDisplay
!
=
null
)
{
if
(
jQuery
.
css
(
elem
"
float
"
)
=
=
=
"
none
"
)
{
if
(
!
propTween
)
{
anim
.
done
(
function
(
)
{
style
.
display
=
restoreDisplay
;
}
)
;
if
(
restoreDisplay
=
=
null
)
{
display
=
style
.
display
;
restoreDisplay
=
display
=
=
=
"
none
"
?
"
"
:
display
;
}
}
style
.
display
=
"
inline
-
block
"
;
}
}
}
if
(
opts
.
overflow
)
{
style
.
overflow
=
"
hidden
"
;
anim
.
always
(
function
(
)
{
style
.
overflow
=
opts
.
overflow
[
0
]
;
style
.
overflowX
=
opts
.
overflow
[
1
]
;
style
.
overflowY
=
opts
.
overflow
[
2
]
;
}
)
;
}
propTween
=
false
;
for
(
prop
in
orig
)
{
if
(
!
propTween
)
{
if
(
dataShow
)
{
if
(
"
hidden
"
in
dataShow
)
{
hidden
=
dataShow
.
hidden
;
}
}
else
{
dataShow
=
dataPriv
.
access
(
elem
"
fxshow
"
{
display
:
restoreDisplay
}
)
;
}
if
(
toggle
)
{
dataShow
.
hidden
=
!
hidden
;
}
if
(
hidden
)
{
showHide
(
[
elem
]
true
)
;
}
anim
.
done
(
function
(
)
{
if
(
!
hidden
)
{
showHide
(
[
elem
]
)
;
}
dataPriv
.
remove
(
elem
"
fxshow
"
)
;
for
(
prop
in
orig
)
{
jQuery
.
style
(
elem
prop
orig
[
prop
]
)
;
}
}
)
;
}
propTween
=
createTween
(
hidden
?
dataShow
[
prop
]
:
0
prop
anim
)
;
if
(
!
(
prop
in
dataShow
)
)
{
dataShow
[
prop
]
=
propTween
.
start
;
if
(
hidden
)
{
propTween
.
end
=
propTween
.
start
;
propTween
.
start
=
0
;
}
}
}
}
function
propFilter
(
props
specialEasing
)
{
var
index
name
easing
value
hooks
;
for
(
index
in
props
)
{
name
=
camelCase
(
index
)
;
easing
=
specialEasing
[
name
]
;
value
=
props
[
index
]
;
if
(
Array
.
isArray
(
value
)
)
{
easing
=
value
[
1
]
;
value
=
props
[
index
]
=
value
[
0
]
;
}
if
(
index
!
=
=
name
)
{
props
[
name
]
=
value
;
delete
props
[
index
]
;
}
hooks
=
jQuery
.
cssHooks
[
name
]
;
if
(
hooks
&
&
"
expand
"
in
hooks
)
{
value
=
hooks
.
expand
(
value
)
;
delete
props
[
name
]
;
for
(
index
in
value
)
{
if
(
!
(
index
in
props
)
)
{
props
[
index
]
=
value
[
index
]
;
specialEasing
[
index
]
=
easing
;
}
}
}
else
{
specialEasing
[
name
]
=
easing
;
}
}
}
function
Animation
(
elem
properties
options
)
{
var
result
stopped
index
=
0
length
=
Animation
.
prefilters
.
length
deferred
=
jQuery
.
Deferred
(
)
.
always
(
function
(
)
{
delete
tick
.
elem
;
}
)
tick
=
function
(
)
{
if
(
stopped
)
{
return
false
;
}
var
currentTime
=
fxNow
|
|
createFxNow
(
)
remaining
=
Math
.
max
(
0
animation
.
startTime
+
animation
.
duration
-
currentTime
)
temp
=
remaining
/
animation
.
duration
|
|
0
percent
=
1
-
temp
index
=
0
length
=
animation
.
tweens
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
animation
.
tweens
[
index
]
.
run
(
percent
)
;
}
deferred
.
notifyWith
(
elem
[
animation
percent
remaining
]
)
;
if
(
percent
<
1
&
&
length
)
{
return
remaining
;
}
if
(
!
length
)
{
deferred
.
notifyWith
(
elem
[
animation
1
0
]
)
;
}
deferred
.
resolveWith
(
elem
[
animation
]
)
;
return
false
;
}
animation
=
deferred
.
promise
(
{
elem
:
elem
props
:
jQuery
.
extend
(
{
}
properties
)
opts
:
jQuery
.
extend
(
true
{
specialEasing
:
{
}
easing
:
jQuery
.
easing
.
_default
}
options
)
originalProperties
:
properties
originalOptions
:
options
startTime
:
fxNow
|
|
createFxNow
(
)
duration
:
options
.
duration
tweens
:
[
]
createTween
:
function
(
prop
end
)
{
var
tween
=
jQuery
.
Tween
(
elem
animation
.
opts
prop
end
animation
.
opts
.
specialEasing
[
prop
]
|
|
animation
.
opts
.
easing
)
;
animation
.
tweens
.
push
(
tween
)
;
return
tween
;
}
stop
:
function
(
gotoEnd
)
{
var
index
=
0
length
=
gotoEnd
?
animation
.
tweens
.
length
:
0
;
if
(
stopped
)
{
return
this
;
}
stopped
=
true
;
for
(
;
index
<
length
;
index
+
+
)
{
animation
.
tweens
[
index
]
.
run
(
1
)
;
}
if
(
gotoEnd
)
{
deferred
.
notifyWith
(
elem
[
animation
1
0
]
)
;
deferred
.
resolveWith
(
elem
[
animation
gotoEnd
]
)
;
}
else
{
deferred
.
rejectWith
(
elem
[
animation
gotoEnd
]
)
;
}
return
this
;
}
}
)
props
=
animation
.
props
;
propFilter
(
props
animation
.
opts
.
specialEasing
)
;
for
(
;
index
<
length
;
index
+
+
)
{
result
=
Animation
.
prefilters
[
index
]
.
call
(
animation
elem
props
animation
.
opts
)
;
if
(
result
)
{
if
(
isFunction
(
result
.
stop
)
)
{
jQuery
.
_queueHooks
(
animation
.
elem
animation
.
opts
.
queue
)
.
stop
=
result
.
stop
.
bind
(
result
)
;
}
return
result
;
}
}
jQuery
.
map
(
props
createTween
animation
)
;
if
(
isFunction
(
animation
.
opts
.
start
)
)
{
animation
.
opts
.
start
.
call
(
elem
animation
)
;
}
animation
.
progress
(
animation
.
opts
.
progress
)
.
done
(
animation
.
opts
.
done
animation
.
opts
.
complete
)
.
fail
(
animation
.
opts
.
fail
)
.
always
(
animation
.
opts
.
always
)
;
jQuery
.
fx
.
timer
(
jQuery
.
extend
(
tick
{
elem
:
elem
anim
:
animation
queue
:
animation
.
opts
.
queue
}
)
)
;
return
animation
;
}
jQuery
.
Animation
=
jQuery
.
extend
(
Animation
{
tweeners
:
{
"
*
"
:
[
function
(
prop
value
)
{
var
tween
=
this
.
createTween
(
prop
value
)
;
adjustCSS
(
tween
.
elem
prop
rcssNum
.
exec
(
value
)
tween
)
;
return
tween
;
}
]
}
tweener
:
function
(
props
callback
)
{
if
(
isFunction
(
props
)
)
{
callback
=
props
;
props
=
[
"
*
"
]
;
}
else
{
props
=
props
.
match
(
rnothtmlwhite
)
;
}
var
prop
index
=
0
length
=
props
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
prop
=
props
[
index
]
;
Animation
.
tweeners
[
prop
]
=
Animation
.
tweeners
[
prop
]
|
|
[
]
;
Animation
.
tweeners
[
prop
]
.
unshift
(
callback
)
;
}
}
prefilters
:
[
defaultPrefilter
]
prefilter
:
function
(
callback
prepend
)
{
if
(
prepend
)
{
Animation
.
prefilters
.
unshift
(
callback
)
;
}
else
{
Animation
.
prefilters
.
push
(
callback
)
;
}
}
}
)
;
jQuery
.
speed
=
function
(
speed
easing
fn
)
{
var
opt
=
speed
&
&
typeof
speed
=
=
=
"
object
"
?
jQuery
.
extend
(
{
}
speed
)
:
{
complete
:
fn
|
|
!
fn
&
&
easing
|
|
isFunction
(
speed
)
&
&
speed
duration
:
speed
easing
:
fn
&
&
easing
|
|
easing
&
&
!
isFunction
(
easing
)
&
&
easing
}
;
if
(
jQuery
.
fx
.
off
)
{
opt
.
duration
=
0
;
}
else
{
if
(
typeof
opt
.
duration
!
=
=
"
number
"
)
{
if
(
opt
.
duration
in
jQuery
.
fx
.
speeds
)
{
opt
.
duration
=
jQuery
.
fx
.
speeds
[
opt
.
duration
]
;
}
else
{
opt
.
duration
=
jQuery
.
fx
.
speeds
.
_default
;
}
}
}
if
(
opt
.
queue
=
=
null
|
|
opt
.
queue
=
=
=
true
)
{
opt
.
queue
=
"
fx
"
;
}
opt
.
old
=
opt
.
complete
;
opt
.
complete
=
function
(
)
{
if
(
isFunction
(
opt
.
old
)
)
{
opt
.
old
.
call
(
this
)
;
}
if
(
opt
.
queue
)
{
jQuery
.
dequeue
(
this
opt
.
queue
)
;
}
}
;
return
opt
;
}
;
jQuery
.
fn
.
extend
(
{
fadeTo
:
function
(
speed
to
easing
callback
)
{
return
this
.
filter
(
isHiddenWithinTree
)
.
css
(
"
opacity
"
0
)
.
show
(
)
.
end
(
)
.
animate
(
{
opacity
:
to
}
speed
easing
callback
)
;
}
animate
:
function
(
prop
speed
easing
callback
)
{
var
empty
=
jQuery
.
isEmptyObject
(
prop
)
optall
=
jQuery
.
speed
(
speed
easing
callback
)
doAnimation
=
function
(
)
{
var
anim
=
Animation
(
this
jQuery
.
extend
(
{
}
prop
)
optall
)
;
if
(
empty
|
|
dataPriv
.
get
(
this
"
finish
"
)
)
{
anim
.
stop
(
true
)
;
}
}
;
doAnimation
.
finish
=
doAnimation
;
return
empty
|
|
optall
.
queue
=
=
=
false
?
this
.
each
(
doAnimation
)
:
this
.
queue
(
optall
.
queue
doAnimation
)
;
}
stop
:
function
(
type
clearQueue
gotoEnd
)
{
var
stopQueue
=
function
(
hooks
)
{
var
stop
=
hooks
.
stop
;
delete
hooks
.
stop
;
stop
(
gotoEnd
)
;
}
;
if
(
typeof
type
!
=
=
"
string
"
)
{
gotoEnd
=
clearQueue
;
clearQueue
=
type
;
type
=
undefined
;
}
if
(
clearQueue
&
&
type
!
=
=
false
)
{
this
.
queue
(
type
|
|
"
fx
"
[
]
)
;
}
return
this
.
each
(
function
(
)
{
var
dequeue
=
true
index
=
type
!
=
null
&
&
type
+
"
queueHooks
"
timers
=
jQuery
.
timers
data
=
dataPriv
.
get
(
this
)
;
if
(
index
)
{
if
(
data
[
index
]
&
&
data
[
index
]
.
stop
)
{
stopQueue
(
data
[
index
]
)
;
}
}
else
{
for
(
index
in
data
)
{
if
(
data
[
index
]
&
&
data
[
index
]
.
stop
&
&
rrun
.
test
(
index
)
)
{
stopQueue
(
data
[
index
]
)
;
}
}
}
for
(
index
=
timers
.
length
;
index
-
-
;
)
{
if
(
timers
[
index
]
.
elem
=
=
=
this
&
&
(
type
=
=
null
|
|
timers
[
index
]
.
queue
=
=
=
type
)
)
{
timers
[
index
]
.
anim
.
stop
(
gotoEnd
)
;
dequeue
=
false
;
timers
.
splice
(
index
1
)
;
}
}
if
(
dequeue
|
|
!
gotoEnd
)
{
jQuery
.
dequeue
(
this
type
)
;
}
}
)
;
}
finish
:
function
(
type
)
{
if
(
type
!
=
=
false
)
{
type
=
type
|
|
"
fx
"
;
}
return
this
.
each
(
function
(
)
{
var
index
data
=
dataPriv
.
get
(
this
)
queue
=
data
[
type
+
"
queue
"
]
hooks
=
data
[
type
+
"
queueHooks
"
]
timers
=
jQuery
.
timers
length
=
queue
?
queue
.
length
:
0
;
data
.
finish
=
true
;
jQuery
.
queue
(
this
type
[
]
)
;
if
(
hooks
&
&
hooks
.
stop
)
{
hooks
.
stop
.
call
(
this
true
)
;
}
for
(
index
=
timers
.
length
;
index
-
-
;
)
{
if
(
timers
[
index
]
.
elem
=
=
=
this
&
&
timers
[
index
]
.
queue
=
=
=
type
)
{
timers
[
index
]
.
anim
.
stop
(
true
)
;
timers
.
splice
(
index
1
)
;
}
}
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
if
(
queue
[
index
]
&
&
queue
[
index
]
.
finish
)
{
queue
[
index
]
.
finish
.
call
(
this
)
;
}
}
delete
data
.
finish
;
}
)
;
}
}
)
;
jQuery
.
each
(
[
"
toggle
"
"
show
"
"
hide
"
]
function
(
i
name
)
{
var
cssFn
=
jQuery
.
fn
[
name
]
;
jQuery
.
fn
[
name
]
=
function
(
speed
easing
callback
)
{
return
speed
=
=
null
|
|
typeof
speed
=
=
=
"
boolean
"
?
cssFn
.
apply
(
this
arguments
)
:
this
.
animate
(
genFx
(
name
true
)
speed
easing
callback
)
;
}
;
}
)
;
jQuery
.
each
(
{
slideDown
:
genFx
(
"
show
"
)
slideUp
:
genFx
(
"
hide
"
)
slideToggle
:
genFx
(
"
toggle
"
)
fadeIn
:
{
opacity
:
"
show
"
}
fadeOut
:
{
opacity
:
"
hide
"
}
fadeToggle
:
{
opacity
:
"
toggle
"
}
}
function
(
name
props
)
{
jQuery
.
fn
[
name
]
=
function
(
speed
easing
callback
)
{
return
this
.
animate
(
props
speed
easing
callback
)
;
}
;
}
)
;
jQuery
.
timers
=
[
]
;
jQuery
.
fx
.
tick
=
function
(
)
{
var
timer
i
=
0
timers
=
jQuery
.
timers
;
fxNow
=
Date
.
now
(
)
;
for
(
;
i
<
timers
.
length
;
i
+
+
)
{
timer
=
timers
[
i
]
;
if
(
!
timer
(
)
&
&
timers
[
i
]
=
=
=
timer
)
{
timers
.
splice
(
i
-
-
1
)
;
}
}
if
(
!
timers
.
length
)
{
jQuery
.
fx
.
stop
(
)
;
}
fxNow
=
undefined
;
}
;
jQuery
.
fx
.
timer
=
function
(
timer
)
{
jQuery
.
timers
.
push
(
timer
)
;
jQuery
.
fx
.
start
(
)
;
}
;
jQuery
.
fx
.
interval
=
13
;
jQuery
.
fx
.
start
=
function
(
)
{
if
(
inProgress
)
{
return
;
}
inProgress
=
true
;
schedule
(
)
;
}
;
jQuery
.
fx
.
stop
=
function
(
)
{
inProgress
=
null
;
}
;
jQuery
.
fx
.
speeds
=
{
slow
:
600
fast
:
200
_default
:
400
}
;
jQuery
.
fn
.
delay
=
function
(
time
type
)
{
time
=
jQuery
.
fx
?
jQuery
.
fx
.
speeds
[
time
]
|
|
time
:
time
;
type
=
type
|
|
"
fx
"
;
return
this
.
queue
(
type
function
(
next
hooks
)
{
var
timeout
=
window
.
setTimeout
(
next
time
)
;
hooks
.
stop
=
function
(
)
{
window
.
clearTimeout
(
timeout
)
;
}
;
}
)
;
}
;
(
function
(
)
{
var
input
=
document
.
createElement
(
"
input
"
)
select
=
document
.
createElement
(
"
select
"
)
opt
=
select
.
appendChild
(
document
.
createElement
(
"
option
"
)
)
;
input
.
type
=
"
checkbox
"
;
support
.
checkOn
=
input
.
value
!
=
=
"
"
;
support
.
optSelected
=
opt
.
selected
;
input
=
document
.
createElement
(
"
input
"
)
;
input
.
value
=
"
t
"
;
input
.
type
=
"
radio
"
;
support
.
radioValue
=
input
.
value
=
=
=
"
t
"
;
}
)
(
)
;
var
boolHook
attrHandle
=
jQuery
.
expr
.
attrHandle
;
jQuery
.
fn
.
extend
(
{
attr
:
function
(
name
value
)
{
return
access
(
this
jQuery
.
attr
name
value
arguments
.
length
>
1
)
;
}
removeAttr
:
function
(
name
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
removeAttr
(
this
name
)
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
attr
:
function
(
elem
name
value
)
{
var
ret
hooks
nType
=
elem
.
nodeType
;
if
(
nType
=
=
=
3
|
|
nType
=
=
=
8
|
|
nType
=
=
=
2
)
{
return
;
}
if
(
typeof
elem
.
getAttribute
=
=
=
"
undefined
"
)
{
return
jQuery
.
prop
(
elem
name
value
)
;
}
if
(
nType
!
=
=
1
|
|
!
jQuery
.
isXMLDoc
(
elem
)
)
{
hooks
=
jQuery
.
attrHooks
[
name
.
toLowerCase
(
)
]
|
|
(
jQuery
.
expr
.
match
.
bool
.
test
(
name
)
?
boolHook
:
undefined
)
;
}
if
(
value
!
=
=
undefined
)
{
if
(
value
=
=
=
null
)
{
jQuery
.
removeAttr
(
elem
name
)
;
return
;
}
if
(
hooks
&
&
"
set
"
in
hooks
&
&
(
ret
=
hooks
.
set
(
elem
value
name
)
)
!
=
=
undefined
)
{
return
ret
;
}
elem
.
setAttribute
(
name
value
+
"
"
)
;
return
value
;
}
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
name
)
)
!
=
=
null
)
{
return
ret
;
}
ret
=
jQuery
.
find
.
attr
(
elem
name
)
;
return
ret
=
=
null
?
undefined
:
ret
;
}
attrHooks
:
{
type
:
{
set
:
function
(
elem
value
)
{
if
(
!
support
.
radioValue
&
&
value
=
=
=
"
radio
"
&
&
nodeName
(
elem
"
input
"
)
)
{
var
val
=
elem
.
value
;
elem
.
setAttribute
(
"
type
"
value
)
;
if
(
val
)
{
elem
.
value
=
val
;
}
return
value
;
}
}
}
}
removeAttr
:
function
(
elem
value
)
{
var
name
i
=
0
attrNames
=
value
&
&
value
.
match
(
rnothtmlwhite
)
;
if
(
attrNames
&
&
elem
.
nodeType
=
=
=
1
)
{
while
(
(
name
=
attrNames
[
i
+
+
]
)
)
{
elem
.
removeAttribute
(
name
)
;
}
}
}
}
)
;
boolHook
=
{
set
:
function
(
elem
value
name
)
{
if
(
value
=
=
=
false
)
{
jQuery
.
removeAttr
(
elem
name
)
;
}
else
{
elem
.
setAttribute
(
name
name
)
;
}
return
name
;
}
}
;
jQuery
.
each
(
jQuery
.
expr
.
match
.
bool
.
source
.
match
(
/
\
w
+
/
g
)
function
(
i
name
)
{
var
getter
=
attrHandle
[
name
]
|
|
jQuery
.
find
.
attr
;
attrHandle
[
name
]
=
function
(
elem
name
isXML
)
{
var
ret
handle
lowercaseName
=
name
.
toLowerCase
(
)
;
if
(
!
isXML
)
{
handle
=
attrHandle
[
lowercaseName
]
;
attrHandle
[
lowercaseName
]
=
ret
;
ret
=
getter
(
elem
name
isXML
)
!
=
null
?
lowercaseName
:
null
;
attrHandle
[
lowercaseName
]
=
handle
;
}
return
ret
;
}
;
}
)
;
var
rfocusable
=
/
^
(
?
:
input
|
select
|
textarea
|
button
)
/
i
rclickable
=
/
^
(
?
:
a
|
area
)
/
i
;
jQuery
.
fn
.
extend
(
{
prop
:
function
(
name
value
)
{
return
access
(
this
jQuery
.
prop
name
value
arguments
.
length
>
1
)
;
}
removeProp
:
function
(
name
)
{
return
this
.
each
(
function
(
)
{
delete
this
[
jQuery
.
propFix
[
name
]
|
|
name
]
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
prop
:
function
(
elem
name
value
)
{
var
ret
hooks
nType
=
elem
.
nodeType
;
if
(
nType
=
=
=
3
|
|
nType
=
=
=
8
|
|
nType
=
=
=
2
)
{
return
;
}
if
(
nType
!
=
=
1
|
|
!
jQuery
.
isXMLDoc
(
elem
)
)
{
name
=
jQuery
.
propFix
[
name
]
|
|
name
;
hooks
=
jQuery
.
propHooks
[
name
]
;
}
if
(
value
!
=
=
undefined
)
{
if
(
hooks
&
&
"
set
"
in
hooks
&
&
(
ret
=
hooks
.
set
(
elem
value
name
)
)
!
=
=
undefined
)
{
return
ret
;
}
return
(
elem
[
name
]
=
value
)
;
}
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
name
)
)
!
=
=
null
)
{
return
ret
;
}
return
elem
[
name
]
;
}
propHooks
:
{
tabIndex
:
{
get
:
function
(
elem
)
{
var
tabindex
=
jQuery
.
find
.
attr
(
elem
"
tabindex
"
)
;
if
(
tabindex
)
{
return
parseInt
(
tabindex
10
)
;
}
if
(
rfocusable
.
test
(
elem
.
nodeName
)
|
|
rclickable
.
test
(
elem
.
nodeName
)
&
&
elem
.
href
)
{
return
0
;
}
return
-
1
;
}
}
}
propFix
:
{
"
for
"
:
"
htmlFor
"
"
class
"
:
"
className
"
}
}
)
;
if
(
!
support
.
optSelected
)
{
jQuery
.
propHooks
.
selected
=
{
get
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
if
(
parent
&
&
parent
.
parentNode
)
{
parent
.
parentNode
.
selectedIndex
;
}
return
null
;
}
set
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
if
(
parent
)
{
parent
.
selectedIndex
;
if
(
parent
.
parentNode
)
{
parent
.
parentNode
.
selectedIndex
;
}
}
}
}
;
}
jQuery
.
each
(
[
"
tabIndex
"
"
readOnly
"
"
maxLength
"
"
cellSpacing
"
"
cellPadding
"
"
rowSpan
"
"
colSpan
"
"
useMap
"
"
frameBorder
"
"
contentEditable
"
]
function
(
)
{
jQuery
.
propFix
[
this
.
toLowerCase
(
)
]
=
this
;
}
)
;
function
stripAndCollapse
(
value
)
{
var
tokens
=
value
.
match
(
rnothtmlwhite
)
|
|
[
]
;
return
tokens
.
join
(
"
"
)
;
}
function
getClass
(
elem
)
{
return
elem
.
getAttribute
&
&
elem
.
getAttribute
(
"
class
"
)
|
|
"
"
;
}
function
classesToArray
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
value
;
}
if
(
typeof
value
=
=
=
"
string
"
)
{
return
value
.
match
(
rnothtmlwhite
)
|
|
[
]
;
}
return
[
]
;
}
jQuery
.
fn
.
extend
(
{
addClass
:
function
(
value
)
{
var
classes
elem
cur
curValue
clazz
j
finalValue
i
=
0
;
if
(
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
j
)
{
jQuery
(
this
)
.
addClass
(
value
.
call
(
this
j
getClass
(
this
)
)
)
;
}
)
;
}
classes
=
classesToArray
(
value
)
;
if
(
classes
.
length
)
{
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
curValue
=
getClass
(
elem
)
;
cur
=
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
stripAndCollapse
(
curValue
)
+
"
"
)
;
if
(
cur
)
{
j
=
0
;
while
(
(
clazz
=
classes
[
j
+
+
]
)
)
{
if
(
cur
.
indexOf
(
"
"
+
clazz
+
"
"
)
<
0
)
{
cur
+
=
clazz
+
"
"
;
}
}
finalValue
=
stripAndCollapse
(
cur
)
;
if
(
curValue
!
=
=
finalValue
)
{
elem
.
setAttribute
(
"
class
"
finalValue
)
;
}
}
}
}
return
this
;
}
removeClass
:
function
(
value
)
{
var
classes
elem
cur
curValue
clazz
j
finalValue
i
=
0
;
if
(
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
j
)
{
jQuery
(
this
)
.
removeClass
(
value
.
call
(
this
j
getClass
(
this
)
)
)
;
}
)
;
}
if
(
!
arguments
.
length
)
{
return
this
.
attr
(
"
class
"
"
"
)
;
}
classes
=
classesToArray
(
value
)
;
if
(
classes
.
length
)
{
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
curValue
=
getClass
(
elem
)
;
cur
=
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
stripAndCollapse
(
curValue
)
+
"
"
)
;
if
(
cur
)
{
j
=
0
;
while
(
(
clazz
=
classes
[
j
+
+
]
)
)
{
while
(
cur
.
indexOf
(
"
"
+
clazz
+
"
"
)
>
-
1
)
{
cur
=
cur
.
replace
(
"
"
+
clazz
+
"
"
"
"
)
;
}
}
finalValue
=
stripAndCollapse
(
cur
)
;
if
(
curValue
!
=
=
finalValue
)
{
elem
.
setAttribute
(
"
class
"
finalValue
)
;
}
}
}
}
return
this
;
}
toggleClass
:
function
(
value
stateVal
)
{
var
type
=
typeof
value
isValidValue
=
type
=
=
=
"
string
"
|
|
Array
.
isArray
(
value
)
;
if
(
typeof
stateVal
=
=
=
"
boolean
"
&
&
isValidValue
)
{
return
stateVal
?
this
.
addClass
(
value
)
:
this
.
removeClass
(
value
)
;
}
if
(
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
toggleClass
(
value
.
call
(
this
i
getClass
(
this
)
stateVal
)
stateVal
)
;
}
)
;
}
return
this
.
each
(
function
(
)
{
var
className
i
self
classNames
;
if
(
isValidValue
)
{
i
=
0
;
self
=
jQuery
(
this
)
;
classNames
=
classesToArray
(
value
)
;
while
(
(
className
=
classNames
[
i
+
+
]
)
)
{
if
(
self
.
hasClass
(
className
)
)
{
self
.
removeClass
(
className
)
;
}
else
{
self
.
addClass
(
className
)
;
}
}
}
else
if
(
value
=
=
=
undefined
|
|
type
=
=
=
"
boolean
"
)
{
className
=
getClass
(
this
)
;
if
(
className
)
{
dataPriv
.
set
(
this
"
__className__
"
className
)
;
}
if
(
this
.
setAttribute
)
{
this
.
setAttribute
(
"
class
"
className
|
|
value
=
=
=
false
?
"
"
:
dataPriv
.
get
(
this
"
__className__
"
)
|
|
"
"
)
;
}
}
}
)
;
}
hasClass
:
function
(
selector
)
{
var
className
elem
i
=
0
;
className
=
"
"
+
selector
+
"
"
;
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
stripAndCollapse
(
getClass
(
elem
)
)
+
"
"
)
.
indexOf
(
className
)
>
-
1
)
{
return
true
;
}
}
return
false
;
}
}
)
;
var
rreturn
=
/
\
r
/
g
;
jQuery
.
fn
.
extend
(
{
val
:
function
(
value
)
{
var
hooks
ret
valueIsFunction
elem
=
this
[
0
]
;
if
(
!
arguments
.
length
)
{
if
(
elem
)
{
hooks
=
jQuery
.
valHooks
[
elem
.
type
]
|
|
jQuery
.
valHooks
[
elem
.
nodeName
.
toLowerCase
(
)
]
;
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
"
value
"
)
)
!
=
=
undefined
)
{
return
ret
;
}
ret
=
elem
.
value
;
if
(
typeof
ret
=
=
=
"
string
"
)
{
return
ret
.
replace
(
rreturn
"
"
)
;
}
return
ret
=
=
null
?
"
"
:
ret
;
}
return
;
}
valueIsFunction
=
isFunction
(
value
)
;
return
this
.
each
(
function
(
i
)
{
var
val
;
if
(
this
.
nodeType
!
=
=
1
)
{
return
;
}
if
(
valueIsFunction
)
{
val
=
value
.
call
(
this
i
jQuery
(
this
)
.
val
(
)
)
;
}
else
{
val
=
value
;
}
if
(
val
=
=
null
)
{
val
=
"
"
;
}
else
if
(
typeof
val
=
=
=
"
number
"
)
{
val
+
=
"
"
;
}
else
if
(
Array
.
isArray
(
val
)
)
{
val
=
jQuery
.
map
(
val
function
(
value
)
{
return
value
=
=
null
?
"
"
:
value
+
"
"
;
}
)
;
}
hooks
=
jQuery
.
valHooks
[
this
.
type
]
|
|
jQuery
.
valHooks
[
this
.
nodeName
.
toLowerCase
(
)
]
;
if
(
!
hooks
|
|
!
(
"
set
"
in
hooks
)
|
|
hooks
.
set
(
this
val
"
value
"
)
=
=
=
undefined
)
{
this
.
value
=
val
;
}
}
)
;
}
}
)
;
jQuery
.
extend
(
{
valHooks
:
{
option
:
{
get
:
function
(
elem
)
{
var
val
=
jQuery
.
find
.
attr
(
elem
"
value
"
)
;
return
val
!
=
null
?
val
:
stripAndCollapse
(
jQuery
.
text
(
elem
)
)
;
}
}
select
:
{
get
:
function
(
elem
)
{
var
value
option
i
options
=
elem
.
options
index
=
elem
.
selectedIndex
one
=
elem
.
type
=
=
=
"
select
-
one
"
values
=
one
?
null
:
[
]
max
=
one
?
index
+
1
:
options
.
length
;
if
(
index
<
0
)
{
i
=
max
;
}
else
{
i
=
one
?
index
:
0
;
}
for
(
;
i
<
max
;
i
+
+
)
{
option
=
options
[
i
]
;
if
(
(
option
.
selected
|
|
i
=
=
=
index
)
&
&
!
option
.
disabled
&
&
(
!
option
.
parentNode
.
disabled
|
|
!
nodeName
(
option
.
parentNode
"
optgroup
"
)
)
)
{
value
=
jQuery
(
option
)
.
val
(
)
;
if
(
one
)
{
return
value
;
}
values
.
push
(
value
)
;
}
}
return
values
;
}
set
:
function
(
elem
value
)
{
var
optionSet
option
options
=
elem
.
options
values
=
jQuery
.
makeArray
(
value
)
i
=
options
.
length
;
while
(
i
-
-
)
{
option
=
options
[
i
]
;
if
(
option
.
selected
=
jQuery
.
inArray
(
jQuery
.
valHooks
.
option
.
get
(
option
)
values
)
>
-
1
)
{
optionSet
=
true
;
}
}
if
(
!
optionSet
)
{
elem
.
selectedIndex
=
-
1
;
}
return
values
;
}
}
}
}
)
;
jQuery
.
each
(
[
"
radio
"
"
checkbox
"
]
function
(
)
{
jQuery
.
valHooks
[
this
]
=
{
set
:
function
(
elem
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
(
elem
.
checked
=
jQuery
.
inArray
(
jQuery
(
elem
)
.
val
(
)
value
)
>
-
1
)
;
}
}
}
;
if
(
!
support
.
checkOn
)
{
jQuery
.
valHooks
[
this
]
.
get
=
function
(
elem
)
{
return
elem
.
getAttribute
(
"
value
"
)
=
=
=
null
?
"
on
"
:
elem
.
value
;
}
;
}
}
)
;
support
.
focusin
=
"
onfocusin
"
in
window
;
var
rfocusMorph
=
/
^
(
?
:
focusinfocus
|
focusoutblur
)
/
stopPropagationCallback
=
function
(
e
)
{
e
.
stopPropagation
(
)
;
}
;
jQuery
.
extend
(
jQuery
.
event
{
trigger
:
function
(
event
data
elem
onlyHandlers
)
{
var
i
cur
tmp
bubbleType
ontype
handle
special
lastElement
eventPath
=
[
elem
|
|
document
]
type
=
hasOwn
.
call
(
event
"
type
"
)
?
event
.
type
:
event
namespaces
=
hasOwn
.
call
(
event
"
namespace
"
)
?
event
.
namespace
.
split
(
"
.
"
)
:
[
]
;
cur
=
lastElement
=
tmp
=
elem
=
elem
|
|
document
;
if
(
elem
.
nodeType
=
=
=
3
|
|
elem
.
nodeType
=
=
=
8
)
{
return
;
}
if
(
rfocusMorph
.
test
(
type
+
jQuery
.
event
.
triggered
)
)
{
return
;
}
if
(
type
.
indexOf
(
"
.
"
)
>
-
1
)
{
namespaces
=
type
.
split
(
"
.
"
)
;
type
=
namespaces
.
shift
(
)
;
namespaces
.
sort
(
)
;
}
ontype
=
type
.
indexOf
(
"
:
"
)
<
0
&
&
"
on
"
+
type
;
event
=
event
[
jQuery
.
expando
]
?
event
:
new
jQuery
.
Event
(
type
typeof
event
=
=
=
"
object
"
&
&
event
)
;
event
.
isTrigger
=
onlyHandlers
?
2
:
3
;
event
.
namespace
=
namespaces
.
join
(
"
.
"
)
;
event
.
rnamespace
=
event
.
namespace
?
new
RegExp
(
"
(
^
|
\
\
.
)
"
+
namespaces
.
join
(
"
\
\
.
(
?
:
.
*
\
\
.
|
)
"
)
+
"
(
\
\
.
|
)
"
)
:
null
;
event
.
result
=
undefined
;
if
(
!
event
.
target
)
{
event
.
target
=
elem
;
}
data
=
data
=
=
null
?
[
event
]
:
jQuery
.
makeArray
(
data
[
event
]
)
;
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
if
(
!
onlyHandlers
&
&
special
.
trigger
&
&
special
.
trigger
.
apply
(
elem
data
)
=
=
=
false
)
{
return
;
}
if
(
!
onlyHandlers
&
&
!
special
.
noBubble
&
&
!
isWindow
(
elem
)
)
{
bubbleType
=
special
.
delegateType
|
|
type
;
if
(
!
rfocusMorph
.
test
(
bubbleType
+
type
)
)
{
cur
=
cur
.
parentNode
;
}
for
(
;
cur
;
cur
=
cur
.
parentNode
)
{
eventPath
.
push
(
cur
)
;
tmp
=
cur
;
}
if
(
tmp
=
=
=
(
elem
.
ownerDocument
|
|
document
)
)
{
eventPath
.
push
(
tmp
.
defaultView
|
|
tmp
.
parentWindow
|
|
window
)
;
}
}
i
=
0
;
while
(
(
cur
=
eventPath
[
i
+
+
]
)
&
&
!
event
.
isPropagationStopped
(
)
)
{
lastElement
=
cur
;
event
.
type
=
i
>
1
?
bubbleType
:
special
.
bindType
|
|
type
;
handle
=
(
dataPriv
.
get
(
cur
"
events
"
)
|
|
{
}
)
[
event
.
type
]
&
&
dataPriv
.
get
(
cur
"
handle
"
)
;
if
(
handle
)
{
handle
.
apply
(
cur
data
)
;
}
handle
=
ontype
&
&
cur
[
ontype
]
;
if
(
handle
&
&
handle
.
apply
&
&
acceptData
(
cur
)
)
{
event
.
result
=
handle
.
apply
(
cur
data
)
;
if
(
event
.
result
=
=
=
false
)
{
event
.
preventDefault
(
)
;
}
}
}
event
.
type
=
type
;
if
(
!
onlyHandlers
&
&
!
event
.
isDefaultPrevented
(
)
)
{
if
(
(
!
special
.
_default
|
|
special
.
_default
.
apply
(
eventPath
.
pop
(
)
data
)
=
=
=
false
)
&
&
acceptData
(
elem
)
)
{
if
(
ontype
&
&
isFunction
(
elem
[
type
]
)
&
&
!
isWindow
(
elem
)
)
{
tmp
=
elem
[
ontype
]
;
if
(
tmp
)
{
elem
[
ontype
]
=
null
;
}
jQuery
.
event
.
triggered
=
type
;
if
(
event
.
isPropagationStopped
(
)
)
{
lastElement
.
addEventListener
(
type
stopPropagationCallback
)
;
}
elem
[
type
]
(
)
;
if
(
event
.
isPropagationStopped
(
)
)
{
lastElement
.
removeEventListener
(
type
stopPropagationCallback
)
;
}
jQuery
.
event
.
triggered
=
undefined
;
if
(
tmp
)
{
elem
[
ontype
]
=
tmp
;
}
}
}
}
return
event
.
result
;
}
simulate
:
function
(
type
elem
event
)
{
var
e
=
jQuery
.
extend
(
new
jQuery
.
Event
(
)
event
{
type
:
type
isSimulated
:
true
}
)
;
jQuery
.
event
.
trigger
(
e
null
elem
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
trigger
:
function
(
type
data
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
event
.
trigger
(
type
data
this
)
;
}
)
;
}
triggerHandler
:
function
(
type
data
)
{
var
elem
=
this
[
0
]
;
if
(
elem
)
{
return
jQuery
.
event
.
trigger
(
type
data
elem
true
)
;
}
}
}
)
;
if
(
!
support
.
focusin
)
{
jQuery
.
each
(
{
focus
:
"
focusin
"
blur
:
"
focusout
"
}
function
(
orig
fix
)
{
var
handler
=
function
(
event
)
{
jQuery
.
event
.
simulate
(
fix
event
.
target
jQuery
.
event
.
fix
(
event
)
)
;
}
;
jQuery
.
event
.
special
[
fix
]
=
{
setup
:
function
(
)
{
var
doc
=
this
.
ownerDocument
|
|
this
attaches
=
dataPriv
.
access
(
doc
fix
)
;
if
(
!
attaches
)
{
doc
.
addEventListener
(
orig
handler
true
)
;
}
dataPriv
.
access
(
doc
fix
(
attaches
|
|
0
)
+
1
)
;
}
teardown
:
function
(
)
{
var
doc
=
this
.
ownerDocument
|
|
this
attaches
=
dataPriv
.
access
(
doc
fix
)
-
1
;
if
(
!
attaches
)
{
doc
.
removeEventListener
(
orig
handler
true
)
;
dataPriv
.
remove
(
doc
fix
)
;
}
else
{
dataPriv
.
access
(
doc
fix
attaches
)
;
}
}
}
;
}
)
;
}
var
location
=
window
.
location
;
var
nonce
=
Date
.
now
(
)
;
var
rquery
=
(
/
\
?
/
)
;
jQuery
.
parseXML
=
function
(
data
)
{
var
xml
;
if
(
!
data
|
|
typeof
data
!
=
=
"
string
"
)
{
return
null
;
}
try
{
xml
=
(
new
window
.
DOMParser
(
)
)
.
parseFromString
(
data
"
text
/
xml
"
)
;
}
catch
(
e
)
{
xml
=
undefined
;
}
if
(
!
xml
|
|
xml
.
getElementsByTagName
(
"
parsererror
"
)
.
length
)
{
jQuery
.
error
(
"
Invalid
XML
:
"
+
data
)
;
}
return
xml
;
}
;
var
rbracket
=
/
\
[
\
]
/
rCRLF
=
/
\
r
?
\
n
/
g
rsubmitterTypes
=
/
^
(
?
:
submit
|
button
|
image
|
reset
|
file
)
/
i
rsubmittable
=
/
^
(
?
:
input
|
select
|
textarea
|
keygen
)
/
i
;
function
buildParams
(
prefix
obj
traditional
add
)
{
var
name
;
if
(
Array
.
isArray
(
obj
)
)
{
jQuery
.
each
(
obj
function
(
i
v
)
{
if
(
traditional
|
|
rbracket
.
test
(
prefix
)
)
{
add
(
prefix
v
)
;
}
else
{
buildParams
(
prefix
+
"
[
"
+
(
typeof
v
=
=
=
"
object
"
&
&
v
!
=
null
?
i
:
"
"
)
+
"
]
"
v
traditional
add
)
;
}
}
)
;
}
else
if
(
!
traditional
&
&
toType
(
obj
)
=
=
=
"
object
"
)
{
for
(
name
in
obj
)
{
buildParams
(
prefix
+
"
[
"
+
name
+
"
]
"
obj
[
name
]
traditional
add
)
;
}
}
else
{
add
(
prefix
obj
)
;
}
}
jQuery
.
param
=
function
(
a
traditional
)
{
var
prefix
s
=
[
]
add
=
function
(
key
valueOrFunction
)
{
var
value
=
isFunction
(
valueOrFunction
)
?
valueOrFunction
(
)
:
valueOrFunction
;
s
[
s
.
length
]
=
encodeURIComponent
(
key
)
+
"
=
"
+
encodeURIComponent
(
value
=
=
null
?
"
"
:
value
)
;
}
;
if
(
Array
.
isArray
(
a
)
|
|
(
a
.
jquery
&
&
!
jQuery
.
isPlainObject
(
a
)
)
)
{
jQuery
.
each
(
a
function
(
)
{
add
(
this
.
name
this
.
value
)
;
}
)
;
}
else
{
for
(
prefix
in
a
)
{
buildParams
(
prefix
a
[
prefix
]
traditional
add
)
;
}
}
return
s
.
join
(
"
&
"
)
;
}
;
jQuery
.
fn
.
extend
(
{
serialize
:
function
(
)
{
return
jQuery
.
param
(
this
.
serializeArray
(
)
)
;
}
serializeArray
:
function
(
)
{
return
this
.
map
(
function
(
)
{
var
elements
=
jQuery
.
prop
(
this
"
elements
"
)
;
return
elements
?
jQuery
.
makeArray
(
elements
)
:
this
;
}
)
.
filter
(
function
(
)
{
var
type
=
this
.
type
;
return
this
.
name
&
&
!
jQuery
(
this
)
.
is
(
"
:
disabled
"
)
&
&
rsubmittable
.
test
(
this
.
nodeName
)
&
&
!
rsubmitterTypes
.
test
(
type
)
&
&
(
this
.
checked
|
|
!
rcheckableType
.
test
(
type
)
)
;
}
)
.
map
(
function
(
i
elem
)
{
var
val
=
jQuery
(
this
)
.
val
(
)
;
if
(
val
=
=
null
)
{
return
null
;
}
if
(
Array
.
isArray
(
val
)
)
{
return
jQuery
.
map
(
val
function
(
val
)
{
return
{
name
:
elem
.
name
value
:
val
.
replace
(
rCRLF
"
\
r
\
n
"
)
}
;
}
)
;
}
return
{
name
:
elem
.
name
value
:
val
.
replace
(
rCRLF
"
\
r
\
n
"
)
}
;
}
)
.
get
(
)
;
}
}
)
;
var
r20
=
/
%
20
/
g
rhash
=
/
#
.
*
/
rantiCache
=
/
(
[
?
&
]
)
_
=
[
^
&
]
*
/
rheaders
=
/
^
(
.
*
?
)
:
[
\
t
]
*
(
[
^
\
r
\
n
]
*
)
/
mg
rlocalProtocol
=
/
^
(
?
:
about
|
app
|
app
-
storage
|
.
+
-
extension
|
file
|
res
|
widget
)
:
/
rnoContent
=
/
^
(
?
:
GET
|
HEAD
)
/
rprotocol
=
/
^
\
/
\
/
/
prefilters
=
{
}
transports
=
{
}
allTypes
=
"
*
/
"
.
concat
(
"
*
"
)
originAnchor
=
document
.
createElement
(
"
a
"
)
;
originAnchor
.
href
=
location
.
href
;
function
addToPrefiltersOrTransports
(
structure
)
{
return
function
(
dataTypeExpression
func
)
{
if
(
typeof
dataTypeExpression
!
=
=
"
string
"
)
{
func
=
dataTypeExpression
;
dataTypeExpression
=
"
*
"
;
}
var
dataType
i
=
0
dataTypes
=
dataTypeExpression
.
toLowerCase
(
)
.
match
(
rnothtmlwhite
)
|
|
[
]
;
if
(
isFunction
(
func
)
)
{
while
(
(
dataType
=
dataTypes
[
i
+
+
]
)
)
{
if
(
dataType
[
0
]
=
=
=
"
+
"
)
{
dataType
=
dataType
.
slice
(
1
)
|
|
"
*
"
;
(
structure
[
dataType
]
=
structure
[
dataType
]
|
|
[
]
)
.
unshift
(
func
)
;
}
else
{
(
structure
[
dataType
]
=
structure
[
dataType
]
|
|
[
]
)
.
push
(
func
)
;
}
}
}
}
;
}
function
inspectPrefiltersOrTransports
(
structure
options
originalOptions
jqXHR
)
{
var
inspected
=
{
}
seekingTransport
=
(
structure
=
=
=
transports
)
;
function
inspect
(
dataType
)
{
var
selected
;
inspected
[
dataType
]
=
true
;
jQuery
.
each
(
structure
[
dataType
]
|
|
[
]
function
(
_
prefilterOrFactory
)
{
var
dataTypeOrTransport
=
prefilterOrFactory
(
options
originalOptions
jqXHR
)
;
if
(
typeof
dataTypeOrTransport
=
=
=
"
string
"
&
&
!
seekingTransport
&
&
!
inspected
[
dataTypeOrTransport
]
)
{
options
.
dataTypes
.
unshift
(
dataTypeOrTransport
)
;
inspect
(
dataTypeOrTransport
)
;
return
false
;
}
else
if
(
seekingTransport
)
{
return
!
(
selected
=
dataTypeOrTransport
)
;
}
}
)
;
return
selected
;
}
return
inspect
(
options
.
dataTypes
[
0
]
)
|
|
!
inspected
[
"
*
"
]
&
&
inspect
(
"
*
"
)
;
}
function
ajaxExtend
(
target
src
)
{
var
key
deep
flatOptions
=
jQuery
.
ajaxSettings
.
flatOptions
|
|
{
}
;
for
(
key
in
src
)
{
if
(
src
[
key
]
!
=
=
undefined
)
{
(
flatOptions
[
key
]
?
target
:
(
deep
|
|
(
deep
=
{
}
)
)
)
[
key
]
=
src
[
key
]
;
}
}
if
(
deep
)
{
jQuery
.
extend
(
true
target
deep
)
;
}
return
target
;
}
function
ajaxHandleResponses
(
s
jqXHR
responses
)
{
var
ct
type
finalDataType
firstDataType
contents
=
s
.
contents
dataTypes
=
s
.
dataTypes
;
while
(
dataTypes
[
0
]
=
=
=
"
*
"
)
{
dataTypes
.
shift
(
)
;
if
(
ct
=
=
=
undefined
)
{
ct
=
s
.
mimeType
|
|
jqXHR
.
getResponseHeader
(
"
Content
-
Type
"
)
;
}
}
if
(
ct
)
{
for
(
type
in
contents
)
{
if
(
contents
[
type
]
&
&
contents
[
type
]
.
test
(
ct
)
)
{
dataTypes
.
unshift
(
type
)
;
break
;
}
}
}
if
(
dataTypes
[
0
]
in
responses
)
{
finalDataType
=
dataTypes
[
0
]
;
}
else
{
for
(
type
in
responses
)
{
if
(
!
dataTypes
[
0
]
|
|
s
.
converters
[
type
+
"
"
+
dataTypes
[
0
]
]
)
{
finalDataType
=
type
;
break
;
}
if
(
!
firstDataType
)
{
firstDataType
=
type
;
}
}
finalDataType
=
finalDataType
|
|
firstDataType
;
}
if
(
finalDataType
)
{
if
(
finalDataType
!
=
=
dataTypes
[
0
]
)
{
dataTypes
.
unshift
(
finalDataType
)
;
}
return
responses
[
finalDataType
]
;
}
}
function
ajaxConvert
(
s
response
jqXHR
isSuccess
)
{
var
conv2
current
conv
tmp
prev
converters
=
{
}
dataTypes
=
s
.
dataTypes
.
slice
(
)
;
if
(
dataTypes
[
1
]
)
{
for
(
conv
in
s
.
converters
)
{
converters
[
conv
.
toLowerCase
(
)
]
=
s
.
converters
[
conv
]
;
}
}
current
=
dataTypes
.
shift
(
)
;
while
(
current
)
{
if
(
s
.
responseFields
[
current
]
)
{
jqXHR
[
s
.
responseFields
[
current
]
]
=
response
;
}
if
(
!
prev
&
&
isSuccess
&
&
s
.
dataFilter
)
{
response
=
s
.
dataFilter
(
response
s
.
dataType
)
;
}
prev
=
current
;
current
=
dataTypes
.
shift
(
)
;
if
(
current
)
{
if
(
current
=
=
=
"
*
"
)
{
current
=
prev
;
}
else
if
(
prev
!
=
=
"
*
"
&
&
prev
!
=
=
current
)
{
conv
=
converters
[
prev
+
"
"
+
current
]
|
|
converters
[
"
*
"
+
current
]
;
if
(
!
conv
)
{
for
(
conv2
in
converters
)
{
tmp
=
conv2
.
split
(
"
"
)
;
if
(
tmp
[
1
]
=
=
=
current
)
{
conv
=
converters
[
prev
+
"
"
+
tmp
[
0
]
]
|
|
converters
[
"
*
"
+
tmp
[
0
]
]
;
if
(
conv
)
{
if
(
conv
=
=
=
true
)
{
conv
=
converters
[
conv2
]
;
}
else
if
(
converters
[
conv2
]
!
=
=
true
)
{
current
=
tmp
[
0
]
;
dataTypes
.
unshift
(
tmp
[
1
]
)
;
}
break
;
}
}
}
}
if
(
conv
!
=
=
true
)
{
if
(
conv
&
&
s
.
throws
)
{
response
=
conv
(
response
)
;
}
else
{
try
{
response
=
conv
(
response
)
;
}
catch
(
e
)
{
return
{
state
:
"
parsererror
"
error
:
conv
?
e
:
"
No
conversion
from
"
+
prev
+
"
to
"
+
current
}
;
}
}
}
}
}
}
return
{
state
:
"
success
"
data
:
response
}
;
}
jQuery
.
extend
(
{
active
:
0
lastModified
:
{
}
etag
:
{
}
ajaxSettings
:
{
url
:
location
.
href
type
:
"
GET
"
isLocal
:
rlocalProtocol
.
test
(
location
.
protocol
)
global
:
true
processData
:
true
async
:
true
contentType
:
"
application
/
x
-
www
-
form
-
urlencoded
;
charset
=
UTF
-
8
"
accepts
:
{
"
*
"
:
allTypes
text
:
"
text
/
plain
"
html
:
"
text
/
html
"
xml
:
"
application
/
xml
text
/
xml
"
json
:
"
application
/
json
text
/
javascript
"
}
contents
:
{
xml
:
/
\
bxml
\
b
/
html
:
/
\
bhtml
/
json
:
/
\
bjson
\
b
/
}
responseFields
:
{
xml
:
"
responseXML
"
text
:
"
responseText
"
json
:
"
responseJSON
"
}
converters
:
{
"
*
text
"
:
String
"
text
html
"
:
true
"
text
json
"
:
JSON
.
parse
"
text
xml
"
:
jQuery
.
parseXML
}
flatOptions
:
{
url
:
true
context
:
true
}
}
ajaxSetup
:
function
(
target
settings
)
{
return
settings
?
ajaxExtend
(
ajaxExtend
(
target
jQuery
.
ajaxSettings
)
settings
)
:
ajaxExtend
(
jQuery
.
ajaxSettings
target
)
;
}
ajaxPrefilter
:
addToPrefiltersOrTransports
(
prefilters
)
ajaxTransport
:
addToPrefiltersOrTransports
(
transports
)
ajax
:
function
(
url
options
)
{
if
(
typeof
url
=
=
=
"
object
"
)
{
options
=
url
;
url
=
undefined
;
}
options
=
options
|
|
{
}
;
var
transport
cacheURL
responseHeadersString
responseHeaders
timeoutTimer
urlAnchor
completed
fireGlobals
i
uncached
s
=
jQuery
.
ajaxSetup
(
{
}
options
)
callbackContext
=
s
.
context
|
|
s
globalEventContext
=
s
.
context
&
&
(
callbackContext
.
nodeType
|
|
callbackContext
.
jquery
)
?
jQuery
(
callbackContext
)
:
jQuery
.
event
deferred
=
jQuery
.
Deferred
(
)
completeDeferred
=
jQuery
.
Callbacks
(
"
once
memory
"
)
statusCode
=
s
.
statusCode
|
|
{
}
requestHeaders
=
{
}
requestHeadersNames
=
{
}
strAbort
=
"
canceled
"
jqXHR
=
{
readyState
:
0
getResponseHeader
:
function
(
key
)
{
var
match
;
if
(
completed
)
{
if
(
!
responseHeaders
)
{
responseHeaders
=
{
}
;
while
(
(
match
=
rheaders
.
exec
(
responseHeadersString
)
)
)
{
responseHeaders
[
match
[
1
]
.
toLowerCase
(
)
]
=
match
[
2
]
;
}
}
match
=
responseHeaders
[
key
.
toLowerCase
(
)
]
;
}
return
match
=
=
null
?
null
:
match
;
}
getAllResponseHeaders
:
function
(
)
{
return
completed
?
responseHeadersString
:
null
;
}
setRequestHeader
:
function
(
name
value
)
{
if
(
completed
=
=
null
)
{
name
=
requestHeadersNames
[
name
.
toLowerCase
(
)
]
=
requestHeadersNames
[
name
.
toLowerCase
(
)
]
|
|
name
;
requestHeaders
[
name
]
=
value
;
}
return
this
;
}
overrideMimeType
:
function
(
type
)
{
if
(
completed
=
=
null
)
{
s
.
mimeType
=
type
;
}
return
this
;
}
statusCode
:
function
(
map
)
{
var
code
;
if
(
map
)
{
if
(
completed
)
{
jqXHR
.
always
(
map
[
jqXHR
.
status
]
)
;
}
else
{
for
(
code
in
map
)
{
statusCode
[
code
]
=
[
statusCode
[
code
]
map
[
code
]
]
;
}
}
}
return
this
;
}
abort
:
function
(
statusText
)
{
var
finalText
=
statusText
|
|
strAbort
;
if
(
transport
)
{
transport
.
abort
(
finalText
)
;
}
done
(
0
finalText
)
;
return
this
;
}
}
;
deferred
.
promise
(
jqXHR
)
;
s
.
url
=
(
(
url
|
|
s
.
url
|
|
location
.
href
)
+
"
"
)
.
replace
(
rprotocol
location
.
protocol
+
"
/
/
"
)
;
s
.
type
=
options
.
method
|
|
options
.
type
|
|
s
.
method
|
|
s
.
type
;
s
.
dataTypes
=
(
s
.
dataType
|
|
"
*
"
)
.
toLowerCase
(
)
.
match
(
rnothtmlwhite
)
|
|
[
"
"
]
;
if
(
s
.
crossDomain
=
=
null
)
{
urlAnchor
=
document
.
createElement
(
"
a
"
)
;
try
{
urlAnchor
.
href
=
s
.
url
;
urlAnchor
.
href
=
urlAnchor
.
href
;
s
.
crossDomain
=
originAnchor
.
protocol
+
"
/
/
"
+
originAnchor
.
host
!
=
=
urlAnchor
.
protocol
+
"
/
/
"
+
urlAnchor
.
host
;
}
catch
(
e
)
{
s
.
crossDomain
=
true
;
}
}
if
(
s
.
data
&
&
s
.
processData
&
&
typeof
s
.
data
!
=
=
"
string
"
)
{
s
.
data
=
jQuery
.
param
(
s
.
data
s
.
traditional
)
;
}
inspectPrefiltersOrTransports
(
prefilters
s
options
jqXHR
)
;
if
(
completed
)
{
return
jqXHR
;
}
fireGlobals
=
jQuery
.
event
&
&
s
.
global
;
if
(
fireGlobals
&
&
jQuery
.
active
+
+
=
=
=
0
)
{
jQuery
.
event
.
trigger
(
"
ajaxStart
"
)
;
}
s
.
type
=
s
.
type
.
toUpperCase
(
)
;
s
.
hasContent
=
!
rnoContent
.
test
(
s
.
type
)
;
cacheURL
=
s
.
url
.
replace
(
rhash
"
"
)
;
if
(
!
s
.
hasContent
)
{
uncached
=
s
.
url
.
slice
(
cacheURL
.
length
)
;
if
(
s
.
data
&
&
(
s
.
processData
|
|
typeof
s
.
data
=
=
=
"
string
"
)
)
{
cacheURL
+
=
(
rquery
.
test
(
cacheURL
)
?
"
&
"
:
"
?
"
)
+
s
.
data
;
delete
s
.
data
;
}
if
(
s
.
cache
=
=
=
false
)
{
cacheURL
=
cacheURL
.
replace
(
rantiCache
"
1
"
)
;
uncached
=
(
rquery
.
test
(
cacheURL
)
?
"
&
"
:
"
?
"
)
+
"
_
=
"
+
(
nonce
+
+
)
+
uncached
;
}
s
.
url
=
cacheURL
+
uncached
;
}
else
if
(
s
.
data
&
&
s
.
processData
&
&
(
s
.
contentType
|
|
"
"
)
.
indexOf
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
=
=
=
0
)
{
s
.
data
=
s
.
data
.
replace
(
r20
"
+
"
)
;
}
if
(
s
.
ifModified
)
{
if
(
jQuery
.
lastModified
[
cacheURL
]
)
{
jqXHR
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
jQuery
.
lastModified
[
cacheURL
]
)
;
}
if
(
jQuery
.
etag
[
cacheURL
]
)
{
jqXHR
.
setRequestHeader
(
"
If
-
None
-
Match
"
jQuery
.
etag
[
cacheURL
]
)
;
}
}
if
(
s
.
data
&
&
s
.
hasContent
&
&
s
.
contentType
!
=
=
false
|
|
options
.
contentType
)
{
jqXHR
.
setRequestHeader
(
"
Content
-
Type
"
s
.
contentType
)
;
}
jqXHR
.
setRequestHeader
(
"
Accept
"
s
.
dataTypes
[
0
]
&
&
s
.
accepts
[
s
.
dataTypes
[
0
]
]
?
s
.
accepts
[
s
.
dataTypes
[
0
]
]
+
(
s
.
dataTypes
[
0
]
!
=
=
"
*
"
?
"
"
+
allTypes
+
"
;
q
=
0
.
01
"
:
"
"
)
:
s
.
accepts
[
"
*
"
]
)
;
for
(
i
in
s
.
headers
)
{
jqXHR
.
setRequestHeader
(
i
s
.
headers
[
i
]
)
;
}
if
(
s
.
beforeSend
&
&
(
s
.
beforeSend
.
call
(
callbackContext
jqXHR
s
)
=
=
=
false
|
|
completed
)
)
{
return
jqXHR
.
abort
(
)
;
}
strAbort
=
"
abort
"
;
completeDeferred
.
add
(
s
.
complete
)
;
jqXHR
.
done
(
s
.
success
)
;
jqXHR
.
fail
(
s
.
error
)
;
transport
=
inspectPrefiltersOrTransports
(
transports
s
options
jqXHR
)
;
if
(
!
transport
)
{
done
(
-
1
"
No
Transport
"
)
;
}
else
{
jqXHR
.
readyState
=
1
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
"
ajaxSend
"
[
jqXHR
s
]
)
;
}
if
(
completed
)
{
return
jqXHR
;
}
if
(
s
.
async
&
&
s
.
timeout
>
0
)
{
timeoutTimer
=
window
.
setTimeout
(
function
(
)
{
jqXHR
.
abort
(
"
timeout
"
)
;
}
s
.
timeout
)
;
}
try
{
completed
=
false
;
transport
.
send
(
requestHeaders
done
)
;
}
catch
(
e
)
{
if
(
completed
)
{
throw
e
;
}
done
(
-
1
e
)
;
}
}
function
done
(
status
nativeStatusText
responses
headers
)
{
var
isSuccess
success
error
response
modified
statusText
=
nativeStatusText
;
if
(
completed
)
{
return
;
}
completed
=
true
;
if
(
timeoutTimer
)
{
window
.
clearTimeout
(
timeoutTimer
)
;
}
transport
=
undefined
;
responseHeadersString
=
headers
|
|
"
"
;
jqXHR
.
readyState
=
status
>
0
?
4
:
0
;
isSuccess
=
status
>
=
200
&
&
status
<
300
|
|
status
=
=
=
304
;
if
(
responses
)
{
response
=
ajaxHandleResponses
(
s
jqXHR
responses
)
;
}
response
=
ajaxConvert
(
s
response
jqXHR
isSuccess
)
;
if
(
isSuccess
)
{
if
(
s
.
ifModified
)
{
modified
=
jqXHR
.
getResponseHeader
(
"
Last
-
Modified
"
)
;
if
(
modified
)
{
jQuery
.
lastModified
[
cacheURL
]
=
modified
;
}
modified
=
jqXHR
.
getResponseHeader
(
"
etag
"
)
;
if
(
modified
)
{
jQuery
.
etag
[
cacheURL
]
=
modified
;
}
}
if
(
status
=
=
=
204
|
|
s
.
type
=
=
=
"
HEAD
"
)
{
statusText
=
"
nocontent
"
;
}
else
if
(
status
=
=
=
304
)
{
statusText
=
"
notmodified
"
;
}
else
{
statusText
=
response
.
state
;
success
=
response
.
data
;
error
=
response
.
error
;
isSuccess
=
!
error
;
}
}
else
{
error
=
statusText
;
if
(
status
|
|
!
statusText
)
{
statusText
=
"
error
"
;
if
(
status
<
0
)
{
status
=
0
;
}
}
}
jqXHR
.
status
=
status
;
jqXHR
.
statusText
=
(
nativeStatusText
|
|
statusText
)
+
"
"
;
if
(
isSuccess
)
{
deferred
.
resolveWith
(
callbackContext
[
success
statusText
jqXHR
]
)
;
}
else
{
deferred
.
rejectWith
(
callbackContext
[
jqXHR
statusText
error
]
)
;
}
jqXHR
.
statusCode
(
statusCode
)
;
statusCode
=
undefined
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
isSuccess
?
"
ajaxSuccess
"
:
"
ajaxError
"
[
jqXHR
s
isSuccess
?
success
:
error
]
)
;
}
completeDeferred
.
fireWith
(
callbackContext
[
jqXHR
statusText
]
)
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
"
ajaxComplete
"
[
jqXHR
s
]
)
;
if
(
!
(
-
-
jQuery
.
active
)
)
{
jQuery
.
event
.
trigger
(
"
ajaxStop
"
)
;
}
}
}
return
jqXHR
;
}
getJSON
:
function
(
url
data
callback
)
{
return
jQuery
.
get
(
url
data
callback
"
json
"
)
;
}
getScript
:
function
(
url
callback
)
{
return
jQuery
.
get
(
url
undefined
callback
"
script
"
)
;
}
}
)
;
jQuery
.
each
(
[
"
get
"
"
post
"
]
function
(
i
method
)
{
jQuery
[
method
]
=
function
(
url
data
callback
type
)
{
if
(
isFunction
(
data
)
)
{
type
=
type
|
|
callback
;
callback
=
data
;
data
=
undefined
;
}
return
jQuery
.
ajax
(
jQuery
.
extend
(
{
url
:
url
type
:
method
dataType
:
type
data
:
data
success
:
callback
}
jQuery
.
isPlainObject
(
url
)
&
&
url
)
)
;
}
;
}
)
;
jQuery
.
_evalUrl
=
function
(
url
)
{
return
jQuery
.
ajax
(
{
url
:
url
type
:
"
GET
"
dataType
:
"
script
"
cache
:
true
async
:
false
global
:
false
"
throws
"
:
true
}
)
;
}
;
jQuery
.
fn
.
extend
(
{
wrapAll
:
function
(
html
)
{
var
wrap
;
if
(
this
[
0
]
)
{
if
(
isFunction
(
html
)
)
{
html
=
html
.
call
(
this
[
0
]
)
;
}
wrap
=
jQuery
(
html
this
[
0
]
.
ownerDocument
)
.
eq
(
0
)
.
clone
(
true
)
;
if
(
this
[
0
]
.
parentNode
)
{
wrap
.
insertBefore
(
this
[
0
]
)
;
}
wrap
.
map
(
function
(
)
{
var
elem
=
this
;
while
(
elem
.
firstElementChild
)
{
elem
=
elem
.
firstElementChild
;
}
return
elem
;
}
)
.
append
(
this
)
;
}
return
this
;
}
wrapInner
:
function
(
html
)
{
if
(
isFunction
(
html
)
)
{
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
wrapInner
(
html
.
call
(
this
i
)
)
;
}
)
;
}
return
this
.
each
(
function
(
)
{
var
self
=
jQuery
(
this
)
contents
=
self
.
contents
(
)
;
if
(
contents
.
length
)
{
contents
.
wrapAll
(
html
)
;
}
else
{
self
.
append
(
html
)
;
}
}
)
;
}
wrap
:
function
(
html
)
{
var
htmlIsFunction
=
isFunction
(
html
)
;
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
wrapAll
(
htmlIsFunction
?
html
.
call
(
this
i
)
:
html
)
;
}
)
;
}
unwrap
:
function
(
selector
)
{
this
.
parent
(
selector
)
.
not
(
"
body
"
)
.
each
(
function
(
)
{
jQuery
(
this
)
.
replaceWith
(
this
.
childNodes
)
;
}
)
;
return
this
;
}
}
)
;
jQuery
.
expr
.
pseudos
.
hidden
=
function
(
elem
)
{
return
!
jQuery
.
expr
.
pseudos
.
visible
(
elem
)
;
}
;
jQuery
.
expr
.
pseudos
.
visible
=
function
(
elem
)
{
return
!
!
(
elem
.
offsetWidth
|
|
elem
.
offsetHeight
|
|
elem
.
getClientRects
(
)
.
length
)
;
}
;
jQuery
.
ajaxSettings
.
xhr
=
function
(
)
{
try
{
return
new
window
.
XMLHttpRequest
(
)
;
}
catch
(
e
)
{
}
}
;
var
xhrSuccessStatus
=
{
0
:
200
1223
:
204
}
xhrSupported
=
jQuery
.
ajaxSettings
.
xhr
(
)
;
support
.
cors
=
!
!
xhrSupported
&
&
(
"
withCredentials
"
in
xhrSupported
)
;
support
.
ajax
=
xhrSupported
=
!
!
xhrSupported
;
jQuery
.
ajaxTransport
(
function
(
options
)
{
var
callback
errorCallback
;
if
(
support
.
cors
|
|
xhrSupported
&
&
!
options
.
crossDomain
)
{
return
{
send
:
function
(
headers
complete
)
{
var
i
xhr
=
options
.
xhr
(
)
;
xhr
.
open
(
options
.
type
options
.
url
options
.
async
options
.
username
options
.
password
)
;
if
(
options
.
xhrFields
)
{
for
(
i
in
options
.
xhrFields
)
{
xhr
[
i
]
=
options
.
xhrFields
[
i
]
;
}
}
if
(
options
.
mimeType
&
&
xhr
.
overrideMimeType
)
{
xhr
.
overrideMimeType
(
options
.
mimeType
)
;
}
if
(
!
options
.
crossDomain
&
&
!
headers
[
"
X
-
Requested
-
With
"
]
)
{
headers
[
"
X
-
Requested
-
With
"
]
=
"
XMLHttpRequest
"
;
}
for
(
i
in
headers
)
{
xhr
.
setRequestHeader
(
i
headers
[
i
]
)
;
}
callback
=
function
(
type
)
{
return
function
(
)
{
if
(
callback
)
{
callback
=
errorCallback
=
xhr
.
onload
=
xhr
.
onerror
=
xhr
.
onabort
=
xhr
.
ontimeout
=
xhr
.
onreadystatechange
=
null
;
if
(
type
=
=
=
"
abort
"
)
{
xhr
.
abort
(
)
;
}
else
if
(
type
=
=
=
"
error
"
)
{
if
(
typeof
xhr
.
status
!
=
=
"
number
"
)
{
complete
(
0
"
error
"
)
;
}
else
{
complete
(
xhr
.
status
xhr
.
statusText
)
;
}
}
else
{
complete
(
xhrSuccessStatus
[
xhr
.
status
]
|
|
xhr
.
status
xhr
.
statusText
(
xhr
.
responseType
|
|
"
text
"
)
!
=
=
"
text
"
|
|
typeof
xhr
.
responseText
!
=
=
"
string
"
?
{
binary
:
xhr
.
response
}
:
{
text
:
xhr
.
responseText
}
xhr
.
getAllResponseHeaders
(
)
)
;
}
}
}
;
}
;
xhr
.
onload
=
callback
(
)
;
errorCallback
=
xhr
.
onerror
=
xhr
.
ontimeout
=
callback
(
"
error
"
)
;
if
(
xhr
.
onabort
!
=
=
undefined
)
{
xhr
.
onabort
=
errorCallback
;
}
else
{
xhr
.
onreadystatechange
=
function
(
)
{
if
(
xhr
.
readyState
=
=
=
4
)
{
window
.
setTimeout
(
function
(
)
{
if
(
callback
)
{
errorCallback
(
)
;
}
}
)
;
}
}
;
}
callback
=
callback
(
"
abort
"
)
;
try
{
xhr
.
send
(
options
.
hasContent
&
&
options
.
data
|
|
null
)
;
}
catch
(
e
)
{
if
(
callback
)
{
throw
e
;
}
}
}
abort
:
function
(
)
{
if
(
callback
)
{
callback
(
)
;
}
}
}
;
}
}
)
;
jQuery
.
ajaxPrefilter
(
function
(
s
)
{
if
(
s
.
crossDomain
)
{
s
.
contents
.
script
=
false
;
}
}
)
;
jQuery
.
ajaxSetup
(
{
accepts
:
{
script
:
"
text
/
javascript
application
/
javascript
"
+
"
application
/
ecmascript
application
/
x
-
ecmascript
"
}
contents
:
{
script
:
/
\
b
(
?
:
java
|
ecma
)
script
\
b
/
}
converters
:
{
"
text
script
"
:
function
(
text
)
{
jQuery
.
globalEval
(
text
)
;
return
text
;
}
}
}
)
;
jQuery
.
ajaxPrefilter
(
"
script
"
function
(
s
)
{
if
(
s
.
cache
=
=
=
undefined
)
{
s
.
cache
=
false
;
}
if
(
s
.
crossDomain
)
{
s
.
type
=
"
GET
"
;
}
}
)
;
jQuery
.
ajaxTransport
(
"
script
"
function
(
s
)
{
if
(
s
.
crossDomain
)
{
var
script
callback
;
return
{
send
:
function
(
_
complete
)
{
script
=
jQuery
(
"
<
script
>
"
)
.
prop
(
{
charset
:
s
.
scriptCharset
src
:
s
.
url
}
)
.
on
(
"
load
error
"
callback
=
function
(
evt
)
{
script
.
remove
(
)
;
callback
=
null
;
if
(
evt
)
{
complete
(
evt
.
type
=
=
=
"
error
"
?
404
:
200
evt
.
type
)
;
}
}
)
;
document
.
head
.
appendChild
(
script
[
0
]
)
;
}
abort
:
function
(
)
{
if
(
callback
)
{
callback
(
)
;
}
}
}
;
}
}
)
;
var
oldCallbacks
=
[
]
rjsonp
=
/
(
=
)
\
?
(
?
=
&
|
)
|
\
?
\
?
/
;
jQuery
.
ajaxSetup
(
{
jsonp
:
"
callback
"
jsonpCallback
:
function
(
)
{
var
callback
=
oldCallbacks
.
pop
(
)
|
|
(
jQuery
.
expando
+
"
_
"
+
(
nonce
+
+
)
)
;
this
[
callback
]
=
true
;
return
callback
;
}
}
)
;
jQuery
.
ajaxPrefilter
(
"
json
jsonp
"
function
(
s
originalSettings
jqXHR
)
{
var
callbackName
overwritten
responseContainer
jsonProp
=
s
.
jsonp
!
=
=
false
&
&
(
rjsonp
.
test
(
s
.
url
)
?
"
url
"
:
typeof
s
.
data
=
=
=
"
string
"
&
&
(
s
.
contentType
|
|
"
"
)
.
indexOf
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
=
=
=
0
&
&
rjsonp
.
test
(
s
.
data
)
&
&
"
data
"
)
;
if
(
jsonProp
|
|
s
.
dataTypes
[
0
]
=
=
=
"
jsonp
"
)
{
callbackName
=
s
.
jsonpCallback
=
isFunction
(
s
.
jsonpCallback
)
?
s
.
jsonpCallback
(
)
:
s
.
jsonpCallback
;
if
(
jsonProp
)
{
s
[
jsonProp
]
=
s
[
jsonProp
]
.
replace
(
rjsonp
"
1
"
+
callbackName
)
;
}
else
if
(
s
.
jsonp
!
=
=
false
)
{
s
.
url
+
=
(
rquery
.
test
(
s
.
url
)
?
"
&
"
:
"
?
"
)
+
s
.
jsonp
+
"
=
"
+
callbackName
;
}
s
.
converters
[
"
script
json
"
]
=
function
(
)
{
if
(
!
responseContainer
)
{
jQuery
.
error
(
callbackName
+
"
was
not
called
"
)
;
}
return
responseContainer
[
0
]
;
}
;
s
.
dataTypes
[
0
]
=
"
json
"
;
overwritten
=
window
[
callbackName
]
;
window
[
callbackName
]
=
function
(
)
{
responseContainer
=
arguments
;
}
;
jqXHR
.
always
(
function
(
)
{
if
(
overwritten
=
=
=
undefined
)
{
jQuery
(
window
)
.
removeProp
(
callbackName
)
;
}
else
{
window
[
callbackName
]
=
overwritten
;
}
if
(
s
[
callbackName
]
)
{
s
.
jsonpCallback
=
originalSettings
.
jsonpCallback
;
oldCallbacks
.
push
(
callbackName
)
;
}
if
(
responseContainer
&
&
isFunction
(
overwritten
)
)
{
overwritten
(
responseContainer
[
0
]
)
;
}
responseContainer
=
overwritten
=
undefined
;
}
)
;
return
"
script
"
;
}
}
)
;
support
.
createHTMLDocument
=
(
function
(
)
{
var
body
=
document
.
implementation
.
createHTMLDocument
(
"
"
)
.
body
;
body
.
innerHTML
=
"
<
form
>
<
/
form
>
<
form
>
<
/
form
>
"
;
return
body
.
childNodes
.
length
=
=
=
2
;
}
)
(
)
;
jQuery
.
parseHTML
=
function
(
data
context
keepScripts
)
{
if
(
typeof
data
!
=
=
"
string
"
)
{
return
[
]
;
}
if
(
typeof
context
=
=
=
"
boolean
"
)
{
keepScripts
=
context
;
context
=
false
;
}
var
base
parsed
scripts
;
if
(
!
context
)
{
if
(
support
.
createHTMLDocument
)
{
context
=
document
.
implementation
.
createHTMLDocument
(
"
"
)
;
base
=
context
.
createElement
(
"
base
"
)
;
base
.
href
=
document
.
location
.
href
;
context
.
head
.
appendChild
(
base
)
;
}
else
{
context
=
document
;
}
}
parsed
=
rsingleTag
.
exec
(
data
)
;
scripts
=
!
keepScripts
&
&
[
]
;
if
(
parsed
)
{
return
[
context
.
createElement
(
parsed
[
1
]
)
]
;
}
parsed
=
buildFragment
(
[
data
]
context
scripts
)
;
if
(
scripts
&
&
scripts
.
length
)
{
jQuery
(
scripts
)
.
remove
(
)
;
}
return
jQuery
.
merge
(
[
]
parsed
.
childNodes
)
;
}
;
jQuery
.
fn
.
load
=
function
(
url
params
callback
)
{
var
selector
type
response
self
=
this
off
=
url
.
indexOf
(
"
"
)
;
if
(
off
>
-
1
)
{
selector
=
stripAndCollapse
(
url
.
slice
(
off
)
)
;
url
=
url
.
slice
(
0
off
)
;
}
if
(
isFunction
(
params
)
)
{
callback
=
params
;
params
=
undefined
;
}
else
if
(
params
&
&
typeof
params
=
=
=
"
object
"
)
{
type
=
"
POST
"
;
}
if
(
self
.
length
>
0
)
{
jQuery
.
ajax
(
{
url
:
url
type
:
type
|
|
"
GET
"
dataType
:
"
html
"
data
:
params
}
)
.
done
(
function
(
responseText
)
{
response
=
arguments
;
self
.
html
(
selector
?
jQuery
(
"
<
div
>
"
)
.
append
(
jQuery
.
parseHTML
(
responseText
)
)
.
find
(
selector
)
:
responseText
)
;
}
)
.
always
(
callback
&
&
function
(
jqXHR
status
)
{
self
.
each
(
function
(
)
{
callback
.
apply
(
this
response
|
|
[
jqXHR
.
responseText
status
jqXHR
]
)
;
}
)
;
}
)
;
}
return
this
;
}
;
jQuery
.
each
(
[
"
ajaxStart
"
"
ajaxStop
"
"
ajaxComplete
"
"
ajaxError
"
"
ajaxSuccess
"
"
ajaxSend
"
]
function
(
i
type
)
{
jQuery
.
fn
[
type
]
=
function
(
fn
)
{
return
this
.
on
(
type
fn
)
;
}
;
}
)
;
jQuery
.
expr
.
pseudos
.
animated
=
function
(
elem
)
{
return
jQuery
.
grep
(
jQuery
.
timers
function
(
fn
)
{
return
elem
=
=
=
fn
.
elem
;
}
)
.
length
;
}
;
jQuery
.
offset
=
{
setOffset
:
function
(
elem
options
i
)
{
var
curPosition
curLeft
curCSSTop
curTop
curOffset
curCSSLeft
calculatePosition
position
=
jQuery
.
css
(
elem
"
position
"
)
curElem
=
jQuery
(
elem
)
props
=
{
}
;
if
(
position
=
=
=
"
static
"
)
{
elem
.
style
.
position
=
"
relative
"
;
}
curOffset
=
curElem
.
offset
(
)
;
curCSSTop
=
jQuery
.
css
(
elem
"
top
"
)
;
curCSSLeft
=
jQuery
.
css
(
elem
"
left
"
)
;
calculatePosition
=
(
position
=
=
=
"
absolute
"
|
|
position
=
=
=
"
fixed
"
)
&
&
(
curCSSTop
+
curCSSLeft
)
.
indexOf
(
"
auto
"
)
>
-
1
;
if
(
calculatePosition
)
{
curPosition
=
curElem
.
position
(
)
;
curTop
=
curPosition
.
top
;
curLeft
=
curPosition
.
left
;
}
else
{
curTop
=
parseFloat
(
curCSSTop
)
|
|
0
;
curLeft
=
parseFloat
(
curCSSLeft
)
|
|
0
;
}
if
(
isFunction
(
options
)
)
{
options
=
options
.
call
(
elem
i
jQuery
.
extend
(
{
}
curOffset
)
)
;
}
if
(
options
.
top
!
=
null
)
{
props
.
top
=
(
options
.
top
-
curOffset
.
top
)
+
curTop
;
}
if
(
options
.
left
!
=
null
)
{
props
.
left
=
(
options
.
left
-
curOffset
.
left
)
+
curLeft
;
}
if
(
"
using
"
in
options
)
{
options
.
using
.
call
(
elem
props
)
;
}
else
{
curElem
.
css
(
props
)
;
}
}
}
;
jQuery
.
fn
.
extend
(
{
offset
:
function
(
options
)
{
if
(
arguments
.
length
)
{
return
options
=
=
=
undefined
?
this
:
this
.
each
(
function
(
i
)
{
jQuery
.
offset
.
setOffset
(
this
options
i
)
;
}
)
;
}
var
rect
win
elem
=
this
[
0
]
;
if
(
!
elem
)
{
return
;
}
if
(
!
elem
.
getClientRects
(
)
.
length
)
{
return
{
top
:
0
left
:
0
}
;
}
rect
=
elem
.
getBoundingClientRect
(
)
;
win
=
elem
.
ownerDocument
.
defaultView
;
return
{
top
:
rect
.
top
+
win
.
pageYOffset
left
:
rect
.
left
+
win
.
pageXOffset
}
;
}
position
:
function
(
)
{
if
(
!
this
[
0
]
)
{
return
;
}
var
offsetParent
offset
doc
elem
=
this
[
0
]
parentOffset
=
{
top
:
0
left
:
0
}
;
if
(
jQuery
.
css
(
elem
"
position
"
)
=
=
=
"
fixed
"
)
{
offset
=
elem
.
getBoundingClientRect
(
)
;
}
else
{
offset
=
this
.
offset
(
)
;
doc
=
elem
.
ownerDocument
;
offsetParent
=
elem
.
offsetParent
|
|
doc
.
documentElement
;
while
(
offsetParent
&
&
(
offsetParent
=
=
=
doc
.
body
|
|
offsetParent
=
=
=
doc
.
documentElement
)
&
&
jQuery
.
css
(
offsetParent
"
position
"
)
=
=
=
"
static
"
)
{
offsetParent
=
offsetParent
.
parentNode
;
}
if
(
offsetParent
&
&
offsetParent
!
=
=
elem
&
&
offsetParent
.
nodeType
=
=
=
1
)
{
parentOffset
=
jQuery
(
offsetParent
)
.
offset
(
)
;
parentOffset
.
top
+
=
jQuery
.
css
(
offsetParent
"
borderTopWidth
"
true
)
;
parentOffset
.
left
+
=
jQuery
.
css
(
offsetParent
"
borderLeftWidth
"
true
)
;
}
}
return
{
top
:
offset
.
top
-
parentOffset
.
top
-
jQuery
.
css
(
elem
"
marginTop
"
true
)
left
:
offset
.
left
-
parentOffset
.
left
-
jQuery
.
css
(
elem
"
marginLeft
"
true
)
}
;
}
offsetParent
:
function
(
)
{
return
this
.
map
(
function
(
)
{
var
offsetParent
=
this
.
offsetParent
;
while
(
offsetParent
&
&
jQuery
.
css
(
offsetParent
"
position
"
)
=
=
=
"
static
"
)
{
offsetParent
=
offsetParent
.
offsetParent
;
}
return
offsetParent
|
|
documentElement
;
}
)
;
}
}
)
;
jQuery
.
each
(
{
scrollLeft
:
"
pageXOffset
"
scrollTop
:
"
pageYOffset
"
}
function
(
method
prop
)
{
var
top
=
"
pageYOffset
"
=
=
=
prop
;
jQuery
.
fn
[
method
]
=
function
(
val
)
{
return
access
(
this
function
(
elem
method
val
)
{
var
win
;
if
(
isWindow
(
elem
)
)
{
win
=
elem
;
}
else
if
(
elem
.
nodeType
=
=
=
9
)
{
win
=
elem
.
defaultView
;
}
if
(
val
=
=
=
undefined
)
{
return
win
?
win
[
prop
]
:
elem
[
method
]
;
}
if
(
win
)
{
win
.
scrollTo
(
!
top
?
val
:
win
.
pageXOffset
top
?
val
:
win
.
pageYOffset
)
;
}
else
{
elem
[
method
]
=
val
;
}
}
method
val
arguments
.
length
)
;
}
;
}
)
;
jQuery
.
each
(
[
"
top
"
"
left
"
]
function
(
i
prop
)
{
jQuery
.
cssHooks
[
prop
]
=
addGetHookIf
(
support
.
pixelPosition
function
(
elem
computed
)
{
if
(
computed
)
{
computed
=
curCSS
(
elem
prop
)
;
return
rnumnonpx
.
test
(
computed
)
?
jQuery
(
elem
)
.
position
(
)
[
prop
]
+
"
px
"
:
computed
;
}
}
)
;
}
)
;
jQuery
.
each
(
{
Height
:
"
height
"
Width
:
"
width
"
}
function
(
name
type
)
{
jQuery
.
each
(
{
padding
:
"
inner
"
+
name
content
:
type
"
"
:
"
outer
"
+
name
}
function
(
defaultExtra
funcName
)
{
jQuery
.
fn
[
funcName
]
=
function
(
margin
value
)
{
var
chainable
=
arguments
.
length
&
&
(
defaultExtra
|
|
typeof
margin
!
=
=
"
boolean
"
)
extra
=
defaultExtra
|
|
(
margin
=
=
=
true
|
|
value
=
=
=
true
?
"
margin
"
:
"
border
"
)
;
return
access
(
this
function
(
elem
type
value
)
{
var
doc
;
if
(
isWindow
(
elem
)
)
{
return
funcName
.
indexOf
(
"
outer
"
)
=
=
=
0
?
elem
[
"
inner
"
+
name
]
:
elem
.
document
.
documentElement
[
"
client
"
+
name
]
;
}
if
(
elem
.
nodeType
=
=
=
9
)
{
doc
=
elem
.
documentElement
;
return
Math
.
max
(
elem
.
body
[
"
scroll
"
+
name
]
doc
[
"
scroll
"
+
name
]
elem
.
body
[
"
offset
"
+
name
]
doc
[
"
offset
"
+
name
]
doc
[
"
client
"
+
name
]
)
;
}
return
value
=
=
=
undefined
?
jQuery
.
css
(
elem
type
extra
)
:
jQuery
.
style
(
elem
type
value
extra
)
;
}
type
chainable
?
margin
:
undefined
chainable
)
;
}
;
}
)
;
}
)
;
jQuery
.
each
(
(
"
blur
focus
focusin
focusout
resize
scroll
click
dblclick
"
+
"
mousedown
mouseup
mousemove
mouseover
mouseout
mouseenter
mouseleave
"
+
"
change
select
submit
keydown
keypress
keyup
contextmenu
"
)
.
split
(
"
"
)
function
(
i
name
)
{
jQuery
.
fn
[
name
]
=
function
(
data
fn
)
{
return
arguments
.
length
>
0
?
this
.
on
(
name
null
data
fn
)
:
this
.
trigger
(
name
)
;
}
;
}
)
;
jQuery
.
fn
.
extend
(
{
hover
:
function
(
fnOver
fnOut
)
{
return
this
.
mouseenter
(
fnOver
)
.
mouseleave
(
fnOut
|
|
fnOver
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
bind
:
function
(
types
data
fn
)
{
return
this
.
on
(
types
null
data
fn
)
;
}
unbind
:
function
(
types
fn
)
{
return
this
.
off
(
types
null
fn
)
;
}
delegate
:
function
(
selector
types
data
fn
)
{
return
this
.
on
(
types
selector
data
fn
)
;
}
undelegate
:
function
(
selector
types
fn
)
{
return
arguments
.
length
=
=
=
1
?
this
.
off
(
selector
"
*
*
"
)
:
this
.
off
(
types
selector
|
|
"
*
*
"
fn
)
;
}
}
)
;
jQuery
.
proxy
=
function
(
fn
context
)
{
var
tmp
args
proxy
;
if
(
typeof
context
=
=
=
"
string
"
)
{
tmp
=
fn
[
context
]
;
context
=
fn
;
fn
=
tmp
;
}
if
(
!
isFunction
(
fn
)
)
{
return
undefined
;
}
args
=
slice
.
call
(
arguments
2
)
;
proxy
=
function
(
)
{
return
fn
.
apply
(
context
|
|
this
args
.
concat
(
slice
.
call
(
arguments
)
)
)
;
}
;
proxy
.
guid
=
fn
.
guid
=
fn
.
guid
|
|
jQuery
.
guid
+
+
;
return
proxy
;
}
;
jQuery
.
holdReady
=
function
(
hold
)
{
if
(
hold
)
{
jQuery
.
readyWait
+
+
;
}
else
{
jQuery
.
ready
(
true
)
;
}
}
;
jQuery
.
isArray
=
Array
.
isArray
;
jQuery
.
parseJSON
=
JSON
.
parse
;
jQuery
.
nodeName
=
nodeName
;
jQuery
.
isFunction
=
isFunction
;
jQuery
.
isWindow
=
isWindow
;
jQuery
.
camelCase
=
camelCase
;
jQuery
.
type
=
toType
;
jQuery
.
now
=
Date
.
now
;
jQuery
.
isNumeric
=
function
(
obj
)
{
var
type
=
jQuery
.
type
(
obj
)
;
return
(
type
=
=
=
"
number
"
|
|
type
=
=
=
"
string
"
)
&
&
!
isNaN
(
obj
-
parseFloat
(
obj
)
)
;
}
;
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
"
jquery
"
[
]
function
(
)
{
return
jQuery
;
}
)
;
}
var
_jQuery
=
window
.
jQuery
_
=
window
.
;
jQuery
.
noConflict
=
function
(
deep
)
{
if
(
window
.
=
=
=
jQuery
)
{
window
.
=
_
;
}
if
(
deep
&
&
window
.
jQuery
=
=
=
jQuery
)
{
window
.
jQuery
=
_jQuery
;
}
return
jQuery
;
}
;
if
(
!
noGlobal
)
{
window
.
jQuery
=
window
.
=
jQuery
;
}
return
jQuery
;
}
)
;
;
(
function
(
)
{
var
enifed
requireModule
Ember
;
mainContext
=
this
;
(
function
(
)
{
function
missingModule
(
name
referrerName
)
{
if
(
referrerName
)
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
+
'
required
by
:
'
+
referrerName
)
;
}
else
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
)
;
}
}
function
internalRequire
(
_name
referrerName
)
{
var
name
=
_name
;
var
mod
=
registry
[
name
]
;
if
(
!
mod
)
{
name
=
name
+
'
/
index
'
;
mod
=
registry
[
name
]
;
}
var
exports
=
seen
[
name
]
;
if
(
exports
!
=
=
undefined
)
{
return
exports
;
}
exports
=
seen
[
name
]
=
{
}
;
if
(
!
mod
)
{
missingModule
(
_name
referrerName
)
;
}
var
deps
=
mod
.
deps
;
var
callback
=
mod
.
callback
;
var
reified
=
new
Array
(
deps
.
length
)
;
for
(
var
i
=
0
;
i
<
deps
.
length
;
i
+
+
)
{
if
(
deps
[
i
]
=
=
=
'
exports
'
)
{
reified
[
i
]
=
exports
;
}
else
if
(
deps
[
i
]
=
=
=
'
require
'
)
{
reified
[
i
]
=
requireModule
;
}
else
{
reified
[
i
]
=
internalRequire
(
deps
[
i
]
name
)
;
}
}
callback
.
apply
(
this
reified
)
;
return
exports
;
}
var
isNode
=
typeof
window
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
{
}
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
if
(
!
isNode
)
{
Ember
=
this
.
Ember
=
this
.
Ember
|
|
{
}
;
}
if
(
typeof
Ember
=
=
=
'
undefined
'
)
{
Ember
=
{
}
;
}
if
(
typeof
Ember
.
__loader
=
=
=
'
undefined
'
)
{
var
registry
=
{
}
;
var
seen
=
{
}
;
enifed
=
function
(
name
deps
callback
)
{
var
value
=
{
}
;
if
(
!
callback
)
{
value
.
deps
=
[
]
;
value
.
callback
=
deps
;
}
else
{
value
.
deps
=
deps
;
value
.
callback
=
callback
;
}
registry
[
name
]
=
value
;
}
;
requireModule
=
function
(
name
)
{
return
internalRequire
(
name
null
)
;
}
;
requireModule
[
'
default
'
]
=
requireModule
;
requireModule
.
has
=
function
registryHas
(
moduleName
)
{
return
!
!
registry
[
moduleName
]
|
|
!
!
registry
[
moduleName
+
'
/
index
'
]
;
}
;
requireModule
.
_eak_seen
=
registry
;
Ember
.
__loader
=
{
define
:
enifed
require
:
requireModule
registry
:
registry
}
;
}
else
{
enifed
=
Ember
.
__loader
.
define
;
requireModule
=
Ember
.
__loader
.
require
;
}
}
)
(
)
;
enifed
(
"
glimmer
/
node
"
[
"
exports
"
"
glimmer
/
runtime
"
]
function
(
exports
_runtime
)
{
"
use
strict
"
;
exports
.
NodeDOMTreeConstruction
=
undefined
;
function
_defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
(
subClass
superClass
)
;
}
var
NodeDOMTreeConstruction
=
function
(
_DOMTreeConstruction
)
{
_inherits
(
NodeDOMTreeConstruction
_DOMTreeConstruction
)
;
function
NodeDOMTreeConstruction
(
doc
)
{
_classCallCheck
(
this
NodeDOMTreeConstruction
)
;
return
_possibleConstructorReturn
(
this
_DOMTreeConstruction
.
call
(
this
doc
)
)
;
}
NodeDOMTreeConstruction
.
prototype
.
setupUselessElement
=
function
setupUselessElement
(
)
{
}
;
NodeDOMTreeConstruction
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
reference
html
)
{
var
prev
=
reference
?
reference
.
previousSibling
:
parent
.
lastChild
;
var
raw
=
this
.
document
.
createRawHTMLSection
(
html
)
;
parent
.
insertBefore
(
raw
reference
)
;
var
first
=
prev
?
prev
.
nextSibling
:
parent
.
firstChild
;
var
last
=
reference
?
reference
.
previousSibling
:
parent
.
lastChild
;
return
new
_runtime
.
ConcreteBounds
(
parent
first
last
)
;
}
;
NodeDOMTreeConstruction
.
prototype
.
createElement
=
function
createElement
(
tag
)
{
return
this
.
document
.
createElement
(
tag
)
;
}
;
NodeDOMTreeConstruction
.
prototype
.
setAttribute
=
function
setAttribute
(
element
name
value
)
{
element
.
setAttribute
(
name
value
)
;
}
;
return
NodeDOMTreeConstruction
;
}
(
_runtime
.
DOMTreeConstruction
)
;
exports
.
NodeDOMTreeConstruction
=
NodeDOMTreeConstruction
;
}
)
;
enifed
(
"
glimmer
/
reference
"
[
"
exports
"
"
glimmer
/
util
"
]
function
(
exports
_util
)
{
"
use
strict
"
;
exports
.
isModified
=
exports
.
ReferenceCache
=
exports
.
map
=
exports
.
CachedReference
=
exports
.
UpdatableTag
=
exports
.
CachedTag
=
exports
.
combine
=
exports
.
combineSlice
=
exports
.
combineTagged
=
exports
.
DirtyableTag
=
exports
.
CURRENT_TAG
=
exports
.
VOLATILE_TAG
=
exports
.
CONSTANT_TAG
=
exports
.
TagWrapper
=
exports
.
RevisionTag
=
exports
.
VOLATILE
=
exports
.
INITIAL
=
exports
.
CONSTANT
=
exports
.
IteratorSynchronizer
=
exports
.
ReferenceIterator
=
exports
.
IterationArtifacts
=
exports
.
referenceFromParts
=
exports
.
ListItem
=
exports
.
isConst
=
exports
.
ConstReference
=
undefined
;
function
_defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
(
subClass
superClass
)
;
}
function
_classCallCheck
1
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
CONSTANT
=
0
;
var
INITIAL
=
1
;
var
VOLATILE
=
NaN
;
var
RevisionTag
=
function
(
)
{
function
RevisionTag
(
)
{
_classCallCheck
1
(
this
RevisionTag
)
;
}
RevisionTag
.
prototype
.
validate
=
function
validate
(
snapshot
)
{
return
this
.
value
(
)
=
=
=
snapshot
;
}
;
return
RevisionTag
;
}
(
)
;
RevisionTag
.
id
=
0
;
var
VALUE
=
[
]
;
var
VALIDATE
=
[
]
;
var
TagWrapper
=
function
(
)
{
function
TagWrapper
(
type
inner
)
{
_classCallCheck
1
(
this
TagWrapper
)
;
this
.
type
=
type
;
this
.
inner
=
inner
;
}
TagWrapper
.
prototype
.
value
=
function
value
(
)
{
var
func
=
VALUE
[
this
.
type
]
;
return
func
(
this
.
inner
)
;
}
;
TagWrapper
.
prototype
.
validate
=
function
validate
(
snapshot
)
{
var
func
=
VALIDATE
[
this
.
type
]
;
return
func
(
this
.
inner
snapshot
)
;
}
;
return
TagWrapper
;
}
(
)
;
function
register
(
Type
)
{
var
type
=
VALUE
.
length
;
VALUE
.
push
(
function
(
tag
)
{
return
tag
.
value
(
)
;
}
)
;
VALIDATE
.
push
(
function
(
tag
snapshot
)
{
return
tag
.
validate
(
snapshot
)
;
}
)
;
Type
.
id
=
type
;
}
VALUE
.
push
(
function
(
)
{
return
CONSTANT
;
}
)
;
VALIDATE
.
push
(
function
(
_tag
snapshot
)
{
return
snapshot
=
=
=
CONSTANT
;
}
)
;
var
CONSTANT_TAG
=
new
TagWrapper
(
0
null
)
;
VALUE
.
push
(
function
(
)
{
return
VOLATILE
;
}
)
;
VALIDATE
.
push
(
function
(
_tag
snapshot
)
{
return
snapshot
=
=
=
VOLATILE
;
}
)
;
var
VOLATILE_TAG
=
new
TagWrapper
(
1
null
)
;
VALUE
.
push
(
function
(
)
{
return
REVISION
;
}
)
;
VALIDATE
.
push
(
function
(
_tag
snapshot
)
{
return
snapshot
=
=
=
REVISION
;
}
)
;
var
CURRENT_TAG
=
new
TagWrapper
(
2
null
)
;
var
REVISION
=
INITIAL
;
var
DirtyableTag
=
function
(
_RevisionTag
)
{
_inherits
(
DirtyableTag
_RevisionTag
)
;
DirtyableTag
.
create
=
function
create
(
)
{
var
revision
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
REVISION
;
return
new
TagWrapper
(
this
.
id
new
DirtyableTag
(
revision
)
)
;
}
;
function
DirtyableTag
(
)
{
var
revision
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
REVISION
;
_classCallCheck
1
(
this
DirtyableTag
)
;
var
_this
=
_possibleConstructorReturn
(
this
_RevisionTag
.
call
(
this
)
)
;
_this
.
revision
=
revision
;
return
_this
;
}
DirtyableTag
.
prototype
.
value
=
function
value
(
)
{
return
this
.
revision
;
}
;
DirtyableTag
.
prototype
.
dirty
=
function
dirty
(
)
{
this
.
revision
=
+
+
REVISION
;
}
;
return
DirtyableTag
;
}
(
RevisionTag
)
;
register
(
DirtyableTag
)
;
function
combineTagged
(
tagged
)
{
var
optimized
=
[
]
;
for
(
var
i
=
0
l
=
tagged
.
length
;
i
<
l
;
i
+
+
)
{
var
tag
=
tagged
[
i
]
.
tag
;
if
(
tag
=
=
=
VOLATILE_TAG
)
return
VOLATILE_TAG
;
if
(
tag
=
=
=
CONSTANT_TAG
)
continue
;
optimized
.
push
(
tag
)
;
}
return
_combine
(
optimized
)
;
}
function
combineSlice
(
slice
)
{
var
optimized
=
[
]
;
var
node
=
slice
.
head
(
)
;
while
(
node
!
=
=
null
)
{
var
tag
=
node
.
tag
;
if
(
tag
=
=
=
VOLATILE_TAG
)
return
VOLATILE_TAG
;
if
(
tag
!
=
=
CONSTANT_TAG
)
optimized
.
push
(
tag
)
;
node
=
slice
.
nextNode
(
node
)
;
}
return
_combine
(
optimized
)
;
}
function
combine
(
tags
)
{
var
optimized
=
[
]
;
for
(
var
i
=
0
l
=
tags
.
length
;
i
<
l
;
i
+
+
)
{
var
tag
=
tags
[
i
]
;
if
(
tag
=
=
=
VOLATILE_TAG
)
return
VOLATILE_TAG
;
if
(
tag
=
=
=
CONSTANT_TAG
)
continue
;
optimized
.
push
(
tag
)
;
}
return
_combine
(
optimized
)
;
}
function
_combine
(
tags
)
{
switch
(
tags
.
length
)
{
case
0
:
return
CONSTANT_TAG
;
case
1
:
return
tags
[
0
]
;
case
2
:
return
TagsPair
.
create
(
tags
[
0
]
tags
[
1
]
)
;
default
:
return
TagsCombinator
.
create
(
tags
)
;
}
}
var
CachedTag
=
function
(
_RevisionTag2
)
{
_inherits
(
CachedTag
_RevisionTag2
)
;
function
CachedTag
(
)
{
_classCallCheck
1
(
this
CachedTag
)
;
var
_this2
=
_possibleConstructorReturn
(
this
_RevisionTag2
.
apply
(
this
arguments
)
)
;
_this2
.
lastChecked
=
null
;
_this2
.
lastValue
=
null
;
return
_this2
;
}
CachedTag
.
prototype
.
value
=
function
value
(
)
{
var
lastChecked
=
this
.
lastChecked
lastValue
=
this
.
lastValue
;
if
(
lastChecked
!
=
=
REVISION
)
{
this
.
lastChecked
=
REVISION
;
this
.
lastValue
=
lastValue
=
this
.
compute
(
)
;
}
return
this
.
lastValue
;
}
;
CachedTag
.
prototype
.
invalidate
=
function
invalidate
(
)
{
this
.
lastChecked
=
null
;
}
;
return
CachedTag
;
}
(
RevisionTag
)
;
var
TagsPair
=
function
(
_CachedTag
)
{
_inherits
(
TagsPair
_CachedTag
)
;
TagsPair
.
create
=
function
create
(
first
second
)
{
return
new
TagWrapper
(
this
.
id
new
TagsPair
(
first
second
)
)
;
}
;
function
TagsPair
(
first
second
)
{
_classCallCheck
1
(
this
TagsPair
)
;
var
_this3
=
_possibleConstructorReturn
(
this
_CachedTag
.
call
(
this
)
)
;
_this3
.
first
=
first
;
_this3
.
second
=
second
;
return
_this3
;
}
TagsPair
.
prototype
.
compute
=
function
compute
(
)
{
return
Math
.
max
(
this
.
first
.
value
(
)
this
.
second
.
value
(
)
)
;
}
;
return
TagsPair
;
}
(
CachedTag
)
;
register
(
TagsPair
)
;
var
TagsCombinator
=
function
(
_CachedTag2
)
{
_inherits
(
TagsCombinator
_CachedTag2
)
;
TagsCombinator
.
create
=
function
create
(
tags
)
{
return
new
TagWrapper
(
this
.
id
new
TagsCombinator
(
tags
)
)
;
}
;
function
TagsCombinator
(
tags
)
{
_classCallCheck
1
(
this
TagsCombinator
)
;
var
_this4
=
_possibleConstructorReturn
(
this
_CachedTag2
.
call
(
this
)
)
;
_this4
.
tags
=
tags
;
return
_this4
;
}
TagsCombinator
.
prototype
.
compute
=
function
compute
(
)
{
var
tags
=
this
.
tags
;
var
max
=
-
1
;
for
(
var
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
var
value
=
tags
[
i
]
.
value
(
)
;
max
=
Math
.
max
(
value
max
)
;
}
return
max
;
}
;
return
TagsCombinator
;
}
(
CachedTag
)
;
register
(
TagsCombinator
)
;
var
UpdatableTag
=
function
(
_CachedTag3
)
{
_inherits
(
UpdatableTag
_CachedTag3
)
;
UpdatableTag
.
create
=
function
create
(
tag
)
{
return
new
TagWrapper
(
this
.
id
new
UpdatableTag
(
tag
)
)
;
}
;
function
UpdatableTag
(
tag
)
{
_classCallCheck
1
(
this
UpdatableTag
)
;
var
_this5
=
_possibleConstructorReturn
(
this
_CachedTag3
.
call
(
this
)
)
;
_this5
.
tag
=
tag
;
_this5
.
lastUpdated
=
INITIAL
;
return
_this5
;
}
UpdatableTag
.
prototype
.
compute
=
function
compute
(
)
{
return
Math
.
max
(
this
.
lastUpdated
this
.
tag
.
value
(
)
)
;
}
;
UpdatableTag
.
prototype
.
update
=
function
update
(
tag
)
{
if
(
tag
!
=
=
this
.
tag
)
{
this
.
tag
=
tag
;
this
.
lastUpdated
=
REVISION
;
this
.
invalidate
(
)
;
}
}
;
return
UpdatableTag
;
}
(
CachedTag
)
;
register
(
UpdatableTag
)
;
var
CachedReference
=
function
(
)
{
function
CachedReference
(
)
{
_classCallCheck
1
(
this
CachedReference
)
;
this
.
lastRevision
=
null
;
this
.
lastValue
=
null
;
}
CachedReference
.
prototype
.
value
=
function
value
(
)
{
var
tag
=
this
.
tag
lastRevision
=
this
.
lastRevision
lastValue
=
this
.
lastValue
;
if
(
!
lastRevision
|
|
!
tag
.
validate
(
lastRevision
)
)
{
lastValue
=
this
.
lastValue
=
this
.
compute
(
)
;
this
.
lastRevision
=
tag
.
value
(
)
;
}
return
lastValue
;
}
;
CachedReference
.
prototype
.
invalidate
=
function
invalidate
(
)
{
this
.
lastRevision
=
null
;
}
;
return
CachedReference
;
}
(
)
;
var
MapperReference
=
function
(
_CachedReference
)
{
_inherits
(
MapperReference
_CachedReference
)
;
function
MapperReference
(
reference
mapper
)
{
_classCallCheck
1
(
this
MapperReference
)
;
var
_this6
=
_possibleConstructorReturn
(
this
_CachedReference
.
call
(
this
)
)
;
_this6
.
tag
=
reference
.
tag
;
_this6
.
reference
=
reference
;
_this6
.
mapper
=
mapper
;
return
_this6
;
}
MapperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
reference
=
this
.
reference
mapper
=
this
.
mapper
;
return
mapper
(
reference
.
value
(
)
)
;
}
;
return
MapperReference
;
}
(
CachedReference
)
;
function
map
(
reference
mapper
)
{
return
new
MapperReference
(
reference
mapper
)
;
}
var
ReferenceCache
=
function
(
)
{
function
ReferenceCache
(
reference
)
{
_classCallCheck
1
(
this
ReferenceCache
)
;
this
.
lastValue
=
null
;
this
.
lastRevision
=
null
;
this
.
initialized
=
false
;
this
.
tag
=
reference
.
tag
;
this
.
reference
=
reference
;
}
ReferenceCache
.
prototype
.
peek
=
function
peek
(
)
{
if
(
!
this
.
initialized
)
{
return
this
.
initialize
(
)
;
}
return
this
.
lastValue
;
}
;
ReferenceCache
.
prototype
.
revalidate
=
function
revalidate
(
)
{
if
(
!
this
.
initialized
)
{
return
this
.
initialize
(
)
;
}
var
reference
=
this
.
reference
lastRevision
=
this
.
lastRevision
;
var
tag
=
reference
.
tag
;
if
(
tag
.
validate
(
lastRevision
)
)
return
NOT_MODIFIED
;
this
.
lastRevision
=
tag
.
value
(
)
;
var
lastValue
=
this
.
lastValue
;
var
value
=
reference
.
value
(
)
;
if
(
value
=
=
=
lastValue
)
return
NOT_MODIFIED
;
this
.
lastValue
=
value
;
return
value
;
}
;
ReferenceCache
.
prototype
.
initialize
=
function
initialize
(
)
{
var
reference
=
this
.
reference
;
var
value
=
this
.
lastValue
=
reference
.
value
(
)
;
this
.
lastRevision
=
reference
.
tag
.
value
(
)
;
this
.
initialized
=
true
;
return
value
;
}
;
return
ReferenceCache
;
}
(
)
;
var
NOT_MODIFIED
=
"
adb3b78e
-
3d22
-
4e4b
-
877a
-
6317c2c5c145
"
;
function
isModified
(
value
)
{
return
value
!
=
=
NOT_MODIFIED
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
ConstReference
=
function
(
)
{
function
ConstReference
(
inner
)
{
_classCallCheck
(
this
ConstReference
)
;
this
.
inner
=
inner
;
this
.
tag
=
CONSTANT_TAG
;
}
ConstReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
inner
;
}
;
return
ConstReference
;
}
(
)
;
function
isConst
(
reference
)
{
return
reference
.
tag
=
=
=
CONSTANT_TAG
;
}
function
_defaults
1
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
2
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
1
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
1
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
1
(
subClass
superClass
)
;
}
var
ListItem
=
function
(
_ListNode
)
{
_inherits
1
(
ListItem
_ListNode
)
;
function
ListItem
(
iterable
result
)
{
_classCallCheck
2
(
this
ListItem
)
;
var
_this
=
_possibleConstructorReturn
1
(
this
_ListNode
.
call
(
this
iterable
.
valueReferenceFor
(
result
)
)
)
;
_this
.
retained
=
false
;
_this
.
seen
=
false
;
_this
.
key
=
result
.
key
;
_this
.
iterable
=
iterable
;
_this
.
memo
=
iterable
.
memoReferenceFor
(
result
)
;
return
_this
;
}
ListItem
.
prototype
.
update
=
function
update
(
item
)
{
this
.
retained
=
true
;
this
.
iterable
.
updateValueReference
(
this
.
value
item
)
;
this
.
iterable
.
updateMemoReference
(
this
.
memo
item
)
;
}
;
ListItem
.
prototype
.
shouldRemove
=
function
shouldRemove
(
)
{
return
!
this
.
retained
;
}
;
ListItem
.
prototype
.
reset
=
function
reset
(
)
{
this
.
retained
=
false
;
this
.
seen
=
false
;
}
;
return
ListItem
;
}
(
_util
.
ListNode
)
;
var
IterationArtifacts
=
function
(
)
{
function
IterationArtifacts
(
iterable
)
{
_classCallCheck
2
(
this
IterationArtifacts
)
;
this
.
map
=
(
0
_util
.
dict
)
(
)
;
this
.
list
=
new
_util
.
LinkedList
(
)
;
this
.
tag
=
iterable
.
tag
;
this
.
iterable
=
iterable
;
}
IterationArtifacts
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
var
iterator
=
this
.
iterator
=
this
.
iterable
.
iterate
(
)
;
return
iterator
.
isEmpty
(
)
;
}
;
IterationArtifacts
.
prototype
.
iterate
=
function
iterate
(
)
{
var
iterator
=
this
.
iterator
|
|
this
.
iterable
.
iterate
(
)
;
this
.
iterator
=
null
;
return
iterator
;
}
;
IterationArtifacts
.
prototype
.
has
=
function
has
(
key
)
{
return
!
!
this
.
map
[
key
]
;
}
;
IterationArtifacts
.
prototype
.
get
=
function
get
(
key
)
{
return
this
.
map
[
key
]
;
}
;
IterationArtifacts
.
prototype
.
wasSeen
=
function
wasSeen
(
key
)
{
var
node
=
this
.
map
[
key
]
;
return
node
&
&
node
.
seen
;
}
;
IterationArtifacts
.
prototype
.
append
=
function
append
(
item
)
{
var
map
=
this
.
map
list
=
this
.
list
iterable
=
this
.
iterable
;
var
node
=
map
[
item
.
key
]
=
new
ListItem
(
iterable
item
)
;
list
.
append
(
node
)
;
return
node
;
}
;
IterationArtifacts
.
prototype
.
insertBefore
=
function
insertBefore
(
item
reference
)
{
var
map
=
this
.
map
list
=
this
.
list
iterable
=
this
.
iterable
;
var
node
=
map
[
item
.
key
]
=
new
ListItem
(
iterable
item
)
;
node
.
retained
=
true
;
list
.
insertBefore
(
node
reference
)
;
return
node
;
}
;
IterationArtifacts
.
prototype
.
move
=
function
move
(
item
reference
)
{
var
list
=
this
.
list
;
item
.
retained
=
true
;
list
.
remove
(
item
)
;
list
.
insertBefore
(
item
reference
)
;
}
;
IterationArtifacts
.
prototype
.
remove
=
function
remove
(
item
)
{
var
list
=
this
.
list
;
list
.
remove
(
item
)
;
delete
this
.
map
[
item
.
key
]
;
}
;
IterationArtifacts
.
prototype
.
nextNode
=
function
nextNode
(
item
)
{
return
this
.
list
.
nextNode
(
item
)
;
}
;
IterationArtifacts
.
prototype
.
head
=
function
head
(
)
{
return
this
.
list
.
head
(
)
;
}
;
return
IterationArtifacts
;
}
(
)
;
var
ReferenceIterator
=
function
(
)
{
function
ReferenceIterator
(
iterable
)
{
_classCallCheck
2
(
this
ReferenceIterator
)
;
this
.
iterator
=
null
;
var
artifacts
=
new
IterationArtifacts
(
iterable
)
;
this
.
artifacts
=
artifacts
;
}
ReferenceIterator
.
prototype
.
next
=
function
next
(
)
{
var
artifacts
=
this
.
artifacts
;
var
iterator
=
this
.
iterator
=
this
.
iterator
|
|
artifacts
.
iterate
(
)
;
var
item
=
iterator
.
next
(
)
;
if
(
!
item
)
return
null
;
return
artifacts
.
append
(
item
)
;
}
;
return
ReferenceIterator
;
}
(
)
;
var
Phase
;
(
function
(
Phase
)
{
Phase
[
Phase
[
"
Append
"
]
=
0
]
=
"
Append
"
;
Phase
[
Phase
[
"
Prune
"
]
=
1
]
=
"
Prune
"
;
Phase
[
Phase
[
"
Done
"
]
=
2
]
=
"
Done
"
;
}
)
(
Phase
|
|
(
Phase
=
{
}
)
)
;
var
IteratorSynchronizer
=
function
(
)
{
function
IteratorSynchronizer
(
_ref
)
{
var
target
=
_ref
.
target
artifacts
=
_ref
.
artifacts
;
_classCallCheck
2
(
this
IteratorSynchronizer
)
;
this
.
target
=
target
;
this
.
artifacts
=
artifacts
;
this
.
iterator
=
artifacts
.
iterate
(
)
;
this
.
current
=
artifacts
.
head
(
)
;
}
IteratorSynchronizer
.
prototype
.
sync
=
function
sync
(
)
{
var
phase
=
Phase
.
Append
;
while
(
true
)
{
switch
(
phase
)
{
case
Phase
.
Append
:
phase
=
this
.
nextAppend
(
)
;
break
;
case
Phase
.
Prune
:
phase
=
this
.
nextPrune
(
)
;
break
;
case
Phase
.
Done
:
this
.
nextDone
(
)
;
return
;
}
}
}
;
IteratorSynchronizer
.
prototype
.
advanceToKey
=
function
advanceToKey
(
key
)
{
var
current
=
this
.
current
artifacts
=
this
.
artifacts
;
var
seek
=
current
;
while
(
seek
&
&
seek
.
key
!
=
=
key
)
{
seek
.
seen
=
true
;
seek
=
artifacts
.
nextNode
(
seek
)
;
}
this
.
current
=
seek
&
&
artifacts
.
nextNode
(
seek
)
;
}
;
IteratorSynchronizer
.
prototype
.
nextAppend
=
function
nextAppend
(
)
{
var
iterator
=
this
.
iterator
current
=
this
.
current
artifacts
=
this
.
artifacts
;
var
item
=
iterator
.
next
(
)
;
if
(
item
=
=
=
null
)
{
return
this
.
startPrune
(
)
;
}
var
key
=
item
.
key
;
if
(
current
&
&
current
.
key
=
=
=
key
)
{
this
.
nextRetain
(
item
)
;
}
else
if
(
artifacts
.
has
(
key
)
)
{
this
.
nextMove
(
item
)
;
}
else
{
this
.
nextInsert
(
item
)
;
}
return
Phase
.
Append
;
}
;
IteratorSynchronizer
.
prototype
.
nextRetain
=
function
nextRetain
(
item
)
{
var
artifacts
=
this
.
artifacts
current
=
this
.
current
;
current
=
current
;
current
.
update
(
item
)
;
this
.
current
=
artifacts
.
nextNode
(
current
)
;
this
.
target
.
retain
(
item
.
key
current
.
value
current
.
memo
)
;
}
;
IteratorSynchronizer
.
prototype
.
nextMove
=
function
nextMove
(
item
)
{
var
current
=
this
.
current
artifacts
=
this
.
artifacts
target
=
this
.
target
;
var
key
=
item
.
key
;
var
found
=
artifacts
.
get
(
item
.
key
)
;
found
.
update
(
item
)
;
if
(
artifacts
.
wasSeen
(
item
.
key
)
)
{
artifacts
.
move
(
found
current
)
;
target
.
move
(
found
.
key
found
.
value
found
.
memo
current
?
current
.
key
:
null
)
;
}
else
{
this
.
advanceToKey
(
key
)
;
}
}
;
IteratorSynchronizer
.
prototype
.
nextInsert
=
function
nextInsert
(
item
)
{
var
artifacts
=
this
.
artifacts
target
=
this
.
target
current
=
this
.
current
;
var
node
=
artifacts
.
insertBefore
(
item
current
)
;
target
.
insert
(
node
.
key
node
.
value
node
.
memo
current
?
current
.
key
:
null
)
;
}
;
IteratorSynchronizer
.
prototype
.
startPrune
=
function
startPrune
(
)
{
this
.
current
=
this
.
artifacts
.
head
(
)
;
return
Phase
.
Prune
;
}
;
IteratorSynchronizer
.
prototype
.
nextPrune
=
function
nextPrune
(
)
{
var
artifacts
=
this
.
artifacts
target
=
this
.
target
current
=
this
.
current
;
if
(
current
=
=
=
null
)
{
return
Phase
.
Done
;
}
var
node
=
current
;
this
.
current
=
artifacts
.
nextNode
(
node
)
;
if
(
node
.
shouldRemove
(
)
)
{
artifacts
.
remove
(
node
)
;
target
.
delete
(
node
.
key
)
;
}
else
{
node
.
reset
(
)
;
}
return
Phase
.
Prune
;
}
;
IteratorSynchronizer
.
prototype
.
nextDone
=
function
nextDone
(
)
{
this
.
target
.
done
(
)
;
}
;
return
IteratorSynchronizer
;
}
(
)
;
function
referenceFromParts
(
root
parts
)
{
var
reference
=
root
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
reference
=
reference
.
get
(
parts
[
i
]
)
;
}
return
reference
;
}
exports
.
ConstReference
=
ConstReference
;
exports
.
isConst
=
isConst
;
exports
.
ListItem
=
ListItem
;
exports
.
referenceFromParts
=
referenceFromParts
;
exports
.
IterationArtifacts
=
IterationArtifacts
;
exports
.
ReferenceIterator
=
ReferenceIterator
;
exports
.
IteratorSynchronizer
=
IteratorSynchronizer
;
exports
.
CONSTANT
=
CONSTANT
;
exports
.
INITIAL
=
INITIAL
;
exports
.
VOLATILE
=
VOLATILE
;
exports
.
RevisionTag
=
RevisionTag
;
exports
.
TagWrapper
=
TagWrapper
;
exports
.
CONSTANT_TAG
=
CONSTANT_TAG
;
exports
.
VOLATILE_TAG
=
VOLATILE_TAG
;
exports
.
CURRENT_TAG
=
CURRENT_TAG
;
exports
.
DirtyableTag
=
DirtyableTag
;
exports
.
combineTagged
=
combineTagged
;
exports
.
combineSlice
=
combineSlice
;
exports
.
combine
=
combine
;
exports
.
CachedTag
=
CachedTag
;
exports
.
UpdatableTag
=
UpdatableTag
;
exports
.
CachedReference
=
CachedReference
;
exports
.
map
=
map
;
exports
.
ReferenceCache
=
ReferenceCache
;
exports
.
isModified
=
isModified
;
}
)
;
enifed
(
'
glimmer
/
runtime
'
[
'
exports
'
'
glimmer
/
util
'
'
glimmer
/
reference
'
'
glimmer
/
wire
-
format
'
]
function
(
exports
_util
_reference2
_wireFormat
)
{
'
use
strict
'
;
exports
.
ConcreteBounds
=
exports
.
ElementStack
=
exports
.
insertHTMLBefore
=
exports
.
isWhitespace
=
exports
.
DOMTreeConstruction
=
exports
.
IDOMChanges
=
exports
.
DOMChanges
=
exports
.
isComponentDefinition
=
exports
.
ComponentDefinition
=
exports
.
PartialDefinition
=
exports
.
Environment
=
exports
.
Scope
=
exports
.
isSafeString
=
exports
.
RenderResult
=
exports
.
UpdatingVM
=
exports
.
compileExpression
=
exports
.
compileList
=
exports
.
InlineMacros
=
exports
.
BlockMacros
=
exports
.
getDynamicVar
=
exports
.
resetDebuggerCallback
=
exports
.
setDebuggerCallback
=
exports
.
normalizeTextValue
=
exports
.
debugSlice
=
exports
.
Register
=
exports
.
readDOMAttr
=
exports
.
defaultPropertyManagers
=
exports
.
defaultAttributeManagers
=
exports
.
defaultManagers
=
exports
.
INPUT_VALUE_PROPERTY_MANAGER
=
exports
.
PropertyManager
=
exports
.
AttributeManager
=
exports
.
IAttributeManager
=
exports
.
CompiledDynamicTemplate
=
exports
.
CompiledStaticTemplate
=
exports
.
compileLayout
=
exports
.
OpcodeBuilderDSL
=
exports
.
ConditionalReference
=
exports
.
PrimitiveReference
=
exports
.
UNDEFINED_REFERENCE
=
exports
.
NULL_REFERENCE
=
exports
.
templateFactory
=
exports
.
Simple
=
undefined
;
function
_defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
(
subClass
superClass
)
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Register
;
(
function
(
Register
)
{
Register
[
Register
[
"
pc
"
]
=
0
]
=
"
pc
"
;
Register
[
Register
[
"
ra
"
]
=
1
]
=
"
ra
"
;
Register
[
Register
[
"
fp
"
]
=
2
]
=
"
fp
"
;
Register
[
Register
[
"
sp
"
]
=
3
]
=
"
sp
"
;
Register
[
Register
[
"
s0
"
]
=
4
]
=
"
s0
"
;
Register
[
Register
[
"
s1
"
]
=
5
]
=
"
s1
"
;
Register
[
Register
[
"
t0
"
]
=
6
]
=
"
t0
"
;
Register
[
Register
[
"
t1
"
]
=
7
]
=
"
t1
"
;
}
)
(
Register
|
|
(
exports
.
Register
=
Register
=
{
}
)
)
;
function
debugSlice
(
env
start
end
)
{
}
var
AppendOpcodes
=
function
(
)
{
function
AppendOpcodes
(
)
{
_classCallCheck
(
this
AppendOpcodes
)
;
this
.
evaluateOpcode
=
(
0
_util
.
fillNulls
)
(
72
)
.
slice
(
)
;
}
AppendOpcodes
.
prototype
.
add
=
function
add
(
name
evaluate
)
{
this
.
evaluateOpcode
[
name
]
=
evaluate
;
}
;
AppendOpcodes
.
prototype
.
evaluate
=
function
evaluate
(
vm
opcode
type
)
{
var
func
=
this
.
evaluateOpcode
[
type
]
;
func
(
vm
opcode
)
;
}
;
return
AppendOpcodes
;
}
(
)
;
var
APPEND_OPCODES
=
new
AppendOpcodes
(
)
;
var
AbstractOpcode
=
function
(
)
{
function
AbstractOpcode
(
)
{
_classCallCheck
(
this
AbstractOpcode
)
;
(
0
_util
.
initializeGuid
)
(
this
)
;
}
AbstractOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
guid
:
this
.
_guid
type
:
this
.
type
}
;
}
;
return
AbstractOpcode
;
}
(
)
;
var
UpdatingOpcode
=
function
(
_AbstractOpcode
)
{
_inherits
(
UpdatingOpcode
_AbstractOpcode
)
;
function
UpdatingOpcode
(
)
{
_classCallCheck
(
this
UpdatingOpcode
)
;
var
_this
=
_possibleConstructorReturn
(
this
_AbstractOpcode
.
apply
(
this
arguments
)
)
;
_this
.
next
=
null
;
_this
.
prev
=
null
;
return
_this
;
}
return
UpdatingOpcode
;
}
(
AbstractOpcode
)
;
function
_defaults
1
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
1
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
1
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
1
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
1
(
subClass
superClass
)
;
}
var
PrimitiveReference
=
function
(
_ConstReference
)
{
_inherits
1
(
PrimitiveReference
_ConstReference
)
;
function
PrimitiveReference
(
value
)
{
_classCallCheck
1
(
this
PrimitiveReference
)
;
return
_possibleConstructorReturn
1
(
this
_ConstReference
.
call
(
this
value
)
)
;
}
PrimitiveReference
.
create
=
function
create
(
value
)
{
if
(
value
=
=
=
undefined
)
{
return
UNDEFINED_REFERENCE
;
}
else
if
(
value
=
=
=
null
)
{
return
NULL_REFERENCE
;
}
else
if
(
value
=
=
=
true
)
{
return
TRUE_REFERENCE
;
}
else
if
(
value
=
=
=
false
)
{
return
FALSE_REFERENCE
;
}
else
if
(
typeof
value
=
=
=
'
number
'
)
{
return
new
ValueReference
(
value
)
;
}
else
{
return
new
StringReference
(
value
)
;
}
}
;
PrimitiveReference
.
prototype
.
get
=
function
get
(
_key
)
{
return
UNDEFINED_REFERENCE
;
}
;
return
PrimitiveReference
;
}
(
_reference2
.
ConstReference
)
;
var
StringReference
=
function
(
_PrimitiveReference
)
{
_inherits
1
(
StringReference
_PrimitiveReference
)
;
function
StringReference
(
)
{
_classCallCheck
1
(
this
StringReference
)
;
var
_this2
=
_possibleConstructorReturn
1
(
this
_PrimitiveReference
.
apply
(
this
arguments
)
)
;
_this2
.
lengthReference
=
null
;
return
_this2
;
}
StringReference
.
prototype
.
get
=
function
get
(
key
)
{
if
(
key
=
=
=
'
length
'
)
{
var
lengthReference
=
this
.
lengthReference
;
if
(
lengthReference
=
=
=
null
)
{
lengthReference
=
this
.
lengthReference
=
new
ValueReference
(
this
.
inner
.
length
)
;
}
return
lengthReference
;
}
else
{
return
_PrimitiveReference
.
prototype
.
get
.
call
(
this
key
)
;
}
}
;
return
StringReference
;
}
(
PrimitiveReference
)
;
var
ValueReference
=
function
(
_PrimitiveReference2
)
{
_inherits
1
(
ValueReference
_PrimitiveReference2
)
;
function
ValueReference
(
value
)
{
_classCallCheck
1
(
this
ValueReference
)
;
return
_possibleConstructorReturn
1
(
this
_PrimitiveReference2
.
call
(
this
value
)
)
;
}
return
ValueReference
;
}
(
PrimitiveReference
)
;
var
UNDEFINED_REFERENCE
=
new
ValueReference
(
undefined
)
;
var
NULL_REFERENCE
=
new
ValueReference
(
null
)
;
var
TRUE_REFERENCE
=
new
ValueReference
(
true
)
;
var
FALSE_REFERENCE
=
new
ValueReference
(
false
)
;
var
ConditionalReference
=
function
(
)
{
function
ConditionalReference
(
inner
)
{
_classCallCheck
1
(
this
ConditionalReference
)
;
this
.
inner
=
inner
;
this
.
tag
=
inner
.
tag
;
}
ConditionalReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
toBool
(
this
.
inner
.
value
(
)
)
;
}
;
ConditionalReference
.
prototype
.
toBool
=
function
toBool
(
value
)
{
return
!
!
value
;
}
;
return
ConditionalReference
;
}
(
)
;
function
_defaults
2
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
2
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
2
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
2
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
2
(
subClass
superClass
)
;
}
var
ConcatReference
=
function
(
_CachedReference
)
{
_inherits
2
(
ConcatReference
_CachedReference
)
;
function
ConcatReference
(
parts
)
{
_classCallCheck
2
(
this
ConcatReference
)
;
var
_this
=
_possibleConstructorReturn
2
(
this
_CachedReference
.
call
(
this
)
)
;
_this
.
parts
=
parts
;
_this
.
tag
=
(
0
_reference2
.
combineTagged
)
(
parts
)
;
return
_this
;
}
ConcatReference
.
prototype
.
compute
=
function
compute
(
)
{
var
parts
=
new
Array
(
)
;
for
(
var
i
=
0
;
i
<
this
.
parts
.
length
;
i
+
+
)
{
var
value
=
this
.
parts
[
i
]
.
value
(
)
;
if
(
value
!
=
=
null
&
&
value
!
=
=
undefined
)
{
parts
[
i
]
=
castToString
(
value
)
;
}
}
if
(
parts
.
length
>
0
)
{
return
parts
.
join
(
'
'
)
;
}
return
null
;
}
;
return
ConcatReference
;
}
(
_reference2
.
CachedReference
)
;
function
castToString
(
value
)
{
if
(
typeof
value
.
toString
!
=
=
'
function
'
)
{
return
'
'
;
}
return
String
(
value
)
;
}
APPEND_OPCODES
.
add
(
1
function
(
vm
_ref
)
{
var
_helper
=
_ref
.
op1
;
var
stack
=
vm
.
stack
;
var
helper
=
vm
.
constants
.
getFunction
(
_helper
)
;
var
args
=
stack
.
pop
(
)
;
var
value
=
helper
(
vm
args
)
;
args
.
clear
(
)
;
vm
.
stack
.
push
(
value
)
;
}
)
;
APPEND_OPCODES
.
add
(
2
function
(
vm
_ref2
)
{
var
_function
=
_ref2
.
op1
;
var
func
=
vm
.
constants
.
getFunction
(
_function
)
;
vm
.
stack
.
push
(
func
(
vm
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
5
function
(
vm
_ref3
)
{
var
symbol
=
_ref3
.
op1
;
var
expr
=
vm
.
referenceForSymbol
(
symbol
)
;
vm
.
stack
.
push
(
expr
)
;
}
)
;
APPEND_OPCODES
.
add
(
4
function
(
vm
_ref4
)
{
var
symbol
=
_ref4
.
op1
;
var
expr
=
vm
.
stack
.
pop
(
)
;
vm
.
scope
(
)
.
bindSymbol
(
symbol
expr
)
;
}
)
;
APPEND_OPCODES
.
add
(
70
function
(
vm
_ref5
)
{
var
_name
=
_ref5
.
op1
;
var
name
=
vm
.
constants
.
getString
(
_name
)
;
var
locals
=
vm
.
scope
(
)
.
getPartialMap
(
)
;
var
ref
=
locals
[
name
]
;
if
(
ref
=
=
=
undefined
)
{
ref
=
vm
.
getSelf
(
)
.
get
(
name
)
;
}
vm
.
stack
.
push
(
ref
)
;
}
)
;
APPEND_OPCODES
.
add
(
19
function
(
vm
_ref6
)
{
var
symbols
=
_ref6
.
op1
bindCallerScope
=
_ref6
.
op2
;
vm
.
pushRootScope
(
symbols
!
!
bindCallerScope
)
;
}
)
;
APPEND_OPCODES
.
add
(
6
function
(
vm
_ref7
)
{
var
_key
=
_ref7
.
op1
;
var
key
=
vm
.
constants
.
getString
(
_key
)
;
var
expr
=
vm
.
stack
.
pop
(
)
;
vm
.
stack
.
push
(
expr
.
get
(
key
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
7
function
(
vm
_ref8
)
{
var
_block
=
_ref8
.
op1
;
var
block
=
_block
?
vm
.
constants
.
getBlock
(
_block
)
:
null
;
vm
.
stack
.
push
(
block
)
;
}
)
;
APPEND_OPCODES
.
add
(
8
function
(
vm
_ref9
)
{
var
_block
=
_ref9
.
op1
;
vm
.
stack
.
push
(
vm
.
scope
(
)
.
getBlock
(
_block
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
9
function
(
vm
_ref10
)
{
var
_block
=
_ref10
.
op1
;
var
hasBlock
=
!
!
vm
.
scope
(
)
.
getBlock
(
_block
)
;
vm
.
stack
.
push
(
hasBlock
?
TRUE_REFERENCE
:
FALSE_REFERENCE
)
;
}
)
;
APPEND_OPCODES
.
add
(
10
function
(
vm
_ref11
)
{
var
_block
=
_ref11
.
op1
;
var
block
=
vm
.
scope
(
)
.
getBlock
(
_block
)
;
var
hasBlockParams
=
block
&
&
block
.
symbolTable
.
parameters
.
length
;
vm
.
stack
.
push
(
hasBlockParams
?
TRUE_REFERENCE
:
FALSE_REFERENCE
)
;
}
)
;
APPEND_OPCODES
.
add
(
11
function
(
vm
_ref12
)
{
var
count
=
_ref12
.
op1
;
var
out
=
[
]
;
for
(
var
i
=
count
;
i
>
0
;
i
-
-
)
{
out
.
push
(
vm
.
stack
.
pop
(
)
)
;
}
vm
.
stack
.
push
(
new
ConcatReference
(
out
.
reverse
(
)
)
)
;
}
)
;
var
_createClass
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_classCallCheck
4
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Arguments
=
function
(
)
{
function
Arguments
(
)
{
_classCallCheck
4
(
this
Arguments
)
;
this
.
stack
=
null
;
this
.
positional
=
new
PositionalArguments
(
)
;
this
.
named
=
new
NamedArguments
(
)
;
}
Arguments
.
prototype
.
empty
=
function
empty
(
)
{
this
.
setup
(
null
true
)
;
return
this
;
}
;
Arguments
.
prototype
.
setup
=
function
setup
(
stack
synthetic
)
{
this
.
stack
=
stack
;
var
names
=
stack
.
fromTop
(
0
)
;
var
namedCount
=
names
.
length
;
var
positionalCount
=
stack
.
fromTop
(
namedCount
+
1
)
;
var
start
=
positionalCount
+
namedCount
+
2
;
var
positional
=
this
.
positional
;
positional
.
setup
(
stack
start
positionalCount
)
;
var
named
=
this
.
named
;
named
.
setup
(
stack
namedCount
names
synthetic
)
;
}
;
Arguments
.
prototype
.
at
=
function
at
(
pos
)
{
return
this
.
positional
.
at
(
pos
)
;
}
;
Arguments
.
prototype
.
get
=
function
get
(
name
)
{
return
this
.
named
.
get
(
name
)
;
}
;
Arguments
.
prototype
.
capture
=
function
capture
(
)
{
return
{
tag
:
this
.
tag
length
:
this
.
length
positional
:
this
.
positional
.
capture
(
)
named
:
this
.
named
.
capture
(
)
}
;
}
;
Arguments
.
prototype
.
clear
=
function
clear
(
)
{
var
stack
=
this
.
stack
length
=
this
.
length
;
stack
.
pop
(
length
+
2
)
;
}
;
_createClass
(
Arguments
[
{
key
:
'
tag
'
get
:
function
(
)
{
return
(
0
_reference2
.
combineTagged
)
(
[
this
.
positional
this
.
named
]
)
;
}
}
{
key
:
'
length
'
get
:
function
(
)
{
return
this
.
positional
.
length
+
this
.
named
.
length
;
}
}
]
)
;
return
Arguments
;
}
(
)
;
var
PositionalArguments
=
function
(
)
{
function
PositionalArguments
(
)
{
_classCallCheck
4
(
this
PositionalArguments
)
;
this
.
length
=
0
;
this
.
stack
=
null
;
this
.
start
=
0
;
this
.
_tag
=
null
;
this
.
_references
=
null
;
}
PositionalArguments
.
prototype
.
setup
=
function
setup
(
stack
start
length
)
{
this
.
stack
=
stack
;
this
.
start
=
start
;
this
.
length
=
length
;
this
.
_tag
=
null
;
this
.
_references
=
null
;
}
;
PositionalArguments
.
prototype
.
at
=
function
at
(
position
)
{
var
start
=
this
.
start
length
=
this
.
length
;
if
(
position
<
0
|
|
position
>
=
length
)
{
return
UNDEFINED_REFERENCE
;
}
var
fromTop
=
start
-
position
-
1
;
return
this
.
stack
.
fromTop
(
fromTop
)
;
}
;
PositionalArguments
.
prototype
.
capture
=
function
capture
(
)
{
return
new
CapturedPositionalArguments
(
this
.
tag
this
.
references
)
;
}
;
_createClass
(
PositionalArguments
[
{
key
:
'
tag
'
get
:
function
(
)
{
var
tag
=
this
.
_tag
;
if
(
!
tag
)
{
tag
=
this
.
_tag
=
(
0
_reference2
.
combineTagged
)
(
this
.
references
)
;
}
return
tag
;
}
}
{
key
:
'
references
'
get
:
function
(
)
{
var
references
=
this
.
_references
;
if
(
!
references
)
{
var
length
=
this
.
length
;
references
=
this
.
_references
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
references
[
i
]
=
this
.
at
(
i
)
;
}
}
return
references
;
}
}
]
)
;
return
PositionalArguments
;
}
(
)
;
var
CapturedPositionalArguments
=
function
(
)
{
function
CapturedPositionalArguments
(
tag
references
)
{
var
length
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
references
.
length
;
_classCallCheck
4
(
this
CapturedPositionalArguments
)
;
this
.
tag
=
tag
;
this
.
references
=
references
;
this
.
length
=
length
;
}
CapturedPositionalArguments
.
prototype
.
at
=
function
at
(
position
)
{
return
this
.
references
[
position
]
;
}
;
CapturedPositionalArguments
.
prototype
.
value
=
function
value
(
)
{
return
this
.
references
.
map
(
this
.
valueOf
)
;
}
;
CapturedPositionalArguments
.
prototype
.
get
=
function
get
(
name
)
{
var
references
=
this
.
references
length
=
this
.
length
;
if
(
name
=
=
=
'
length
'
)
{
return
PrimitiveReference
.
create
(
length
)
;
}
else
{
var
idx
=
parseInt
(
name
10
)
;
if
(
idx
<
0
|
|
idx
>
=
length
)
{
return
UNDEFINED_REFERENCE
;
}
else
{
return
references
[
idx
]
;
}
}
}
;
CapturedPositionalArguments
.
prototype
.
valueOf
=
function
valueOf
(
reference
1
)
{
return
reference
1
.
value
(
)
;
}
;
return
CapturedPositionalArguments
;
}
(
)
;
var
NamedArguments
=
function
(
)
{
function
NamedArguments
(
)
{
_classCallCheck
4
(
this
NamedArguments
)
;
this
.
length
=
0
;
this
.
_tag
=
null
;
this
.
_references
=
null
;
this
.
_names
=
null
;
this
.
_realNames
=
_util
.
EMPTY_ARRAY
;
}
NamedArguments
.
prototype
.
setup
=
function
setup
(
stack
length
names
synthetic
)
{
this
.
stack
=
stack
;
this
.
length
=
length
;
this
.
_tag
=
null
;
this
.
_references
=
null
;
if
(
synthetic
)
{
this
.
_names
=
names
;
this
.
_realNames
=
_util
.
EMPTY_ARRAY
;
}
else
{
this
.
_names
=
null
;
this
.
_realNames
=
names
;
}
}
;
NamedArguments
.
prototype
.
has
=
function
has
(
name
)
{
return
this
.
names
.
indexOf
(
name
)
!
=
=
-
1
;
}
;
NamedArguments
.
prototype
.
get
=
function
get
(
name
)
{
var
names
=
this
.
names
length
=
this
.
length
;
var
idx
=
names
.
indexOf
(
name
)
;
if
(
idx
=
=
=
-
1
)
{
return
UNDEFINED_REFERENCE
;
}
var
fromTop
=
length
-
idx
;
return
this
.
stack
.
fromTop
(
fromTop
)
;
}
;
NamedArguments
.
prototype
.
capture
=
function
capture
(
)
{
return
new
CapturedNamedArguments
(
this
.
tag
this
.
names
this
.
references
)
;
}
;
NamedArguments
.
prototype
.
sliceName
=
function
sliceName
(
name
)
{
return
name
.
slice
(
1
)
;
}
;
_createClass
(
NamedArguments
[
{
key
:
'
tag
'
get
:
function
(
)
{
return
(
0
_reference2
.
combineTagged
)
(
this
.
references
)
;
}
}
{
key
:
'
names
'
get
:
function
(
)
{
var
names
=
this
.
_names
;
if
(
!
names
)
{
names
=
this
.
_names
=
this
.
_realNames
.
map
(
this
.
sliceName
)
;
}
return
names
;
}
}
{
key
:
'
references
'
get
:
function
(
)
{
var
references
=
this
.
_references
;
if
(
!
references
)
{
var
names
=
this
.
names
length
=
this
.
length
;
references
=
this
.
_references
=
[
]
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
references
[
i
]
=
this
.
get
(
names
[
i
]
)
;
}
}
return
references
;
}
}
]
)
;
return
NamedArguments
;
}
(
)
;
var
CapturedNamedArguments
=
function
(
)
{
function
CapturedNamedArguments
(
tag
names
references
)
{
_classCallCheck
4
(
this
CapturedNamedArguments
)
;
this
.
tag
=
tag
;
this
.
names
=
names
;
this
.
references
=
references
;
this
.
length
=
names
.
length
;
this
.
_map
=
null
;
}
CapturedNamedArguments
.
prototype
.
has
=
function
has
(
name
)
{
return
this
.
names
.
indexOf
(
name
)
!
=
=
-
1
;
}
;
CapturedNamedArguments
.
prototype
.
get
=
function
get
(
name
)
{
var
names
=
this
.
names
references
=
this
.
references
;
var
idx
=
names
.
indexOf
(
name
)
;
if
(
idx
=
=
=
-
1
)
{
return
UNDEFINED_REFERENCE
;
}
else
{
return
references
[
idx
]
;
}
}
;
CapturedNamedArguments
.
prototype
.
value
=
function
value
(
)
{
var
names
=
this
.
names
references
=
this
.
references
;
var
out
=
(
0
_util
.
dict
)
(
)
;
for
(
var
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
var
name
=
names
[
i
]
;
out
[
name
]
=
references
[
i
]
.
value
(
)
;
}
return
out
;
}
;
_createClass
(
CapturedNamedArguments
[
{
key
:
'
map
'
get
:
function
(
)
{
var
map
1
=
this
.
_map
;
if
(
!
map
1
)
{
var
names
=
this
.
names
references
=
this
.
references
;
map
1
=
this
.
_map
=
(
0
_util
.
dict
)
(
)
;
for
(
var
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
var
name
=
names
[
i
]
;
map
1
[
name
]
=
references
[
i
]
;
}
}
return
map
1
;
}
}
]
)
;
return
CapturedNamedArguments
;
}
(
)
;
var
ARGS
=
new
Arguments
(
)
;
function
_defaults
5
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
6
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
5
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
5
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
5
(
subClass
superClass
)
;
}
APPEND_OPCODES
.
add
(
20
function
(
vm
)
{
return
vm
.
pushChildScope
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
21
function
(
vm
)
{
return
vm
.
popScope
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
39
function
(
vm
)
{
return
vm
.
pushDynamicScope
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
40
function
(
vm
)
{
return
vm
.
popDynamicScope
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
12
function
(
vm
_ref
)
{
var
number
=
_ref
.
op1
;
vm
.
stack
.
push
(
number
)
;
}
)
;
APPEND_OPCODES
.
add
(
13
function
(
vm
_ref2
)
{
var
other
=
_ref2
.
op1
;
vm
.
stack
.
push
(
vm
.
constants
.
getOther
(
other
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
14
function
(
vm
_ref3
)
{
var
primitive
=
_ref3
.
op1
;
var
stack
=
vm
.
stack
;
var
flag
=
(
primitive
&
3
<
<
30
)
>
>
>
30
;
var
value
=
primitive
&
~
(
3
<
<
30
)
;
switch
(
flag
)
{
case
0
:
stack
.
push
(
PrimitiveReference
.
create
(
value
)
)
;
break
;
case
1
:
stack
.
push
(
PrimitiveReference
.
create
(
vm
.
constants
.
getFloat
(
value
)
)
)
;
break
;
case
2
:
stack
.
push
(
PrimitiveReference
.
create
(
vm
.
constants
.
getString
(
value
)
)
)
;
break
;
case
3
:
switch
(
value
)
{
case
0
:
stack
.
push
(
FALSE_REFERENCE
)
;
break
;
case
1
:
stack
.
push
(
TRUE_REFERENCE
)
;
break
;
case
2
:
stack
.
push
(
NULL_REFERENCE
)
;
break
;
case
3
:
stack
.
push
(
UNDEFINED_REFERENCE
)
;
break
;
}
break
;
}
}
)
;
APPEND_OPCODES
.
add
(
15
function
(
vm
_ref4
)
{
var
register
=
_ref4
.
op1
offset
=
_ref4
.
op2
;
var
position
=
vm
.
fetchValue
(
register
)
-
offset
;
vm
.
stack
.
dup
(
position
)
;
}
)
;
APPEND_OPCODES
.
add
(
16
function
(
vm
_ref5
)
{
var
count
=
_ref5
.
op1
;
return
vm
.
stack
.
pop
(
count
)
;
}
)
;
APPEND_OPCODES
.
add
(
17
function
(
vm
_ref6
)
{
var
register
=
_ref6
.
op1
;
return
vm
.
load
(
register
)
;
}
)
;
APPEND_OPCODES
.
add
(
18
function
(
vm
_ref7
)
{
var
register
=
_ref7
.
op1
;
return
vm
.
fetch
(
register
)
;
}
)
;
APPEND_OPCODES
.
add
(
38
function
(
vm
_ref8
)
{
var
_names
=
_ref8
.
op1
;
var
names
=
vm
.
constants
.
getArray
(
_names
)
;
vm
.
bindDynamicScope
(
names
)
;
}
)
;
APPEND_OPCODES
.
add
(
47
function
(
vm
)
{
return
vm
.
pushFrame
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
48
function
(
vm
)
{
return
vm
.
popFrame
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
49
function
(
vm
_ref9
)
{
var
args
=
_ref9
.
op1
;
return
vm
.
enter
(
args
)
;
}
)
;
APPEND_OPCODES
.
add
(
50
function
(
vm
)
{
return
vm
.
exit
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
41
function
(
vm
)
{
var
stack
=
vm
.
stack
;
var
block
=
stack
.
pop
(
)
;
stack
.
push
(
block
?
block
.
compileDynamic
(
vm
.
env
)
:
null
)
;
}
)
;
APPEND_OPCODES
.
add
(
42
function
(
vm
_ref10
)
{
var
_block
=
_ref10
.
op1
;
var
block
=
vm
.
constants
.
getBlock
(
_block
)
;
var
compiled
=
block
.
compileStatic
(
vm
.
env
)
;
vm
.
call
(
compiled
.
handle
)
;
}
)
;
APPEND_OPCODES
.
add
(
43
function
(
vm
_ref11
)
{
var
_invoker
=
_ref11
.
op1
;
var
invoker
=
vm
.
constants
.
getOther
(
_invoker
)
;
var
block
=
vm
.
stack
.
pop
(
)
;
invoker
.
invoke
(
vm
block
)
;
}
)
;
APPEND_OPCODES
.
add
(
44
function
(
vm
_ref12
)
{
var
target
=
_ref12
.
op1
;
return
vm
.
goto
(
target
)
;
}
)
;
APPEND_OPCODES
.
add
(
45
function
(
vm
_ref13
)
{
var
target
=
_ref13
.
op1
;
var
reference
1
=
vm
.
stack
.
pop
(
)
;
if
(
(
0
_reference2
.
isConst
)
(
reference
1
)
)
{
if
(
reference
1
.
value
(
)
)
{
vm
.
goto
(
target
)
;
}
}
else
{
var
cache
=
new
_reference2
.
ReferenceCache
(
reference
1
)
;
if
(
cache
.
peek
(
)
)
{
vm
.
goto
(
target
)
;
}
vm
.
updateWith
(
new
Assert
(
cache
)
)
;
}
}
)
;
APPEND_OPCODES
.
add
(
46
function
(
vm
_ref14
)
{
var
target
=
_ref14
.
op1
;
var
reference
1
=
vm
.
stack
.
pop
(
)
;
if
(
(
0
_reference2
.
isConst
)
(
reference
1
)
)
{
if
(
!
reference
1
.
value
(
)
)
{
vm
.
goto
(
target
)
;
}
}
else
{
var
cache
=
new
_reference2
.
ReferenceCache
(
reference
1
)
;
if
(
!
cache
.
peek
(
)
)
{
vm
.
goto
(
target
)
;
}
vm
.
updateWith
(
new
Assert
(
cache
)
)
;
}
}
)
;
APPEND_OPCODES
.
add
(
22
function
(
vm
)
{
return
vm
.
return
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
23
function
(
vm
_ref15
)
{
var
relative
=
_ref15
.
op1
;
vm
.
returnTo
(
relative
)
;
}
)
;
var
ConstTest
=
function
(
ref
_env
)
{
return
new
_reference2
.
ConstReference
(
!
!
ref
.
value
(
)
)
;
}
;
var
SimpleTest
=
function
(
ref
_env
)
{
return
ref
;
}
;
var
EnvironmentTest
=
function
(
ref
env
)
{
return
env
.
toConditionalReference
(
ref
)
;
}
;
APPEND_OPCODES
.
add
(
51
function
(
vm
_ref16
)
{
var
_func
=
_ref16
.
op1
;
var
stack
=
vm
.
stack
;
var
operand
=
stack
.
pop
(
)
;
var
func
=
vm
.
constants
.
getFunction
(
_func
)
;
stack
.
push
(
func
(
operand
vm
.
env
)
)
;
}
)
;
var
Assert
=
function
(
_UpdatingOpcode
)
{
_inherits
5
(
Assert
_UpdatingOpcode
)
;
function
Assert
(
cache
)
{
_classCallCheck
6
(
this
Assert
)
;
var
_this
=
_possibleConstructorReturn
5
(
this
_UpdatingOpcode
.
call
(
this
)
)
;
_this
.
type
=
'
assert
'
;
_this
.
tag
=
cache
.
tag
;
_this
.
cache
=
cache
;
return
_this
;
}
Assert
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
cache
=
this
.
cache
;
if
(
(
0
_reference2
.
isModified
)
(
cache
.
revalidate
(
)
)
)
{
vm
.
throw
(
)
;
}
}
;
Assert
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
type
=
this
.
type
_guid
=
this
.
_guid
cache
=
this
.
cache
;
var
expected
=
void
0
;
try
{
expected
=
JSON
.
stringify
(
cache
.
peek
(
)
)
;
}
catch
(
e
)
{
expected
=
String
(
cache
.
peek
(
)
)
;
}
return
{
args
:
[
]
details
:
{
expected
:
expected
}
guid
:
_guid
type
:
type
}
;
}
;
return
Assert
;
}
(
UpdatingOpcode
)
;
var
JumpIfNotModifiedOpcode
=
function
(
_UpdatingOpcode2
)
{
_inherits
5
(
JumpIfNotModifiedOpcode
_UpdatingOpcode2
)
;
function
JumpIfNotModifiedOpcode
(
tag
target
)
{
_classCallCheck
6
(
this
JumpIfNotModifiedOpcode
)
;
var
_this2
=
_possibleConstructorReturn
5
(
this
_UpdatingOpcode2
.
call
(
this
)
)
;
_this2
.
target
=
target
;
_this2
.
type
=
'
jump
-
if
-
not
-
modified
'
;
_this2
.
tag
=
tag
;
_this2
.
lastRevision
=
tag
.
value
(
)
;
return
_this2
;
}
JumpIfNotModifiedOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
tag
=
this
.
tag
target
=
this
.
target
lastRevision
=
this
.
lastRevision
;
if
(
!
vm
.
alwaysRevalidate
&
&
tag
.
validate
(
lastRevision
)
)
{
vm
.
goto
(
target
)
;
}
}
;
JumpIfNotModifiedOpcode
.
prototype
.
didModify
=
function
didModify
(
)
{
this
.
lastRevision
=
this
.
tag
.
value
(
)
;
}
;
JumpIfNotModifiedOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
args
:
[
JSON
.
stringify
(
this
.
target
.
inspect
(
)
)
]
guid
:
this
.
_guid
type
:
this
.
type
}
;
}
;
return
JumpIfNotModifiedOpcode
;
}
(
UpdatingOpcode
)
;
var
DidModifyOpcode
=
function
(
_UpdatingOpcode3
)
{
_inherits
5
(
DidModifyOpcode
_UpdatingOpcode3
)
;
function
DidModifyOpcode
(
target
)
{
_classCallCheck
6
(
this
DidModifyOpcode
)
;
var
_this3
=
_possibleConstructorReturn
5
(
this
_UpdatingOpcode3
.
call
(
this
)
)
;
_this3
.
target
=
target
;
_this3
.
type
=
'
did
-
modify
'
;
_this3
.
tag
=
_reference2
.
CONSTANT_TAG
;
return
_this3
;
}
DidModifyOpcode
.
prototype
.
evaluate
=
function
evaluate
(
)
{
this
.
target
.
didModify
(
)
;
}
;
return
DidModifyOpcode
;
}
(
UpdatingOpcode
)
;
var
LabelOpcode
=
function
(
)
{
function
LabelOpcode
(
label
)
{
_classCallCheck
6
(
this
LabelOpcode
)
;
this
.
tag
=
_reference2
.
CONSTANT_TAG
;
this
.
type
=
'
label
'
;
this
.
label
=
null
;
this
.
prev
=
null
;
this
.
next
=
null
;
(
0
_util
.
initializeGuid
)
(
this
)
;
this
.
label
=
label
;
}
LabelOpcode
.
prototype
.
evaluate
=
function
evaluate
(
)
{
}
;
LabelOpcode
.
prototype
.
inspect
=
function
inspect
1
(
)
{
return
this
.
label
+
'
[
'
+
this
.
_guid
+
'
]
'
;
}
;
LabelOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
args
:
[
JSON
.
stringify
(
this
.
inspect
(
)
)
]
guid
:
this
.
_guid
type
:
this
.
type
}
;
}
;
return
LabelOpcode
;
}
(
)
;
function
_defaults
4
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
4
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
4
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
4
(
subClass
superClass
)
;
}
function
_classCallCheck
5
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
APPEND_OPCODES
.
add
(
24
function
(
vm
_ref
)
{
var
text
=
_ref
.
op1
;
vm
.
elements
(
)
.
appendText
(
vm
.
constants
.
getString
(
text
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
25
function
(
vm
_ref2
)
{
var
text
=
_ref2
.
op1
;
vm
.
elements
(
)
.
appendComment
(
vm
.
constants
.
getString
(
text
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
27
function
(
vm
_ref3
)
{
var
tag
=
_ref3
.
op1
;
vm
.
elements
(
)
.
openElement
(
vm
.
constants
.
getString
(
tag
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
28
function
(
vm
_ref4
)
{
var
tag
=
_ref4
.
op1
;
var
tagName
=
vm
.
constants
.
getString
(
tag
)
;
var
operations
=
vm
.
stack
.
pop
(
)
;
vm
.
elements
(
)
.
openElement
(
tagName
operations
)
;
}
)
;
APPEND_OPCODES
.
add
(
29
function
(
vm
)
{
var
operations
=
vm
.
stack
.
pop
(
)
;
var
tagName
=
vm
.
stack
.
pop
(
)
.
value
(
)
;
vm
.
elements
(
)
.
openElement
(
tagName
operations
)
;
}
)
;
APPEND_OPCODES
.
add
(
36
function
(
vm
)
{
var
elementRef
=
vm
.
stack
.
pop
(
)
;
var
nextSiblingRef
=
vm
.
stack
.
pop
(
)
;
var
element
=
void
0
;
var
nextSibling
=
void
0
;
if
(
(
0
_reference2
.
isConst
)
(
elementRef
)
)
{
element
=
elementRef
.
value
(
)
;
}
else
{
var
cache
=
new
_reference2
.
ReferenceCache
(
elementRef
)
;
element
=
cache
.
peek
(
)
;
vm
.
updateWith
(
new
Assert
(
cache
)
)
;
}
if
(
(
0
_reference2
.
isConst
)
(
nextSiblingRef
)
)
{
nextSibling
=
nextSiblingRef
.
value
(
)
;
}
else
{
var
_cache
=
new
_reference2
.
ReferenceCache
(
nextSiblingRef
)
;
nextSibling
=
_cache
.
peek
(
)
;
vm
.
updateWith
(
new
Assert
(
_cache
)
)
;
}
vm
.
elements
(
)
.
pushRemoteElement
(
element
nextSibling
)
;
}
)
;
APPEND_OPCODES
.
add
(
37
function
(
vm
)
{
return
vm
.
elements
(
)
.
popRemoteElement
(
)
;
}
)
;
var
ClassList
=
function
(
)
{
function
ClassList
(
)
{
_classCallCheck
5
(
this
ClassList
)
;
this
.
list
=
null
;
this
.
isConst
=
true
;
}
ClassList
.
prototype
.
append
=
function
append
(
reference
1
)
{
var
list
=
this
.
list
isConst
1
=
this
.
isConst
;
if
(
list
=
=
=
null
)
list
=
this
.
list
=
[
]
;
list
.
push
(
reference
1
)
;
this
.
isConst
=
isConst
1
&
&
(
0
_reference2
.
isConst
)
(
reference
1
)
;
}
;
ClassList
.
prototype
.
toReference
=
function
toReference
(
)
{
var
list
=
this
.
list
isConst
1
=
this
.
isConst
;
if
(
!
list
)
return
NULL_REFERENCE
;
if
(
isConst
1
)
return
PrimitiveReference
.
create
(
toClassName
(
list
)
)
;
return
new
ClassListReference
(
list
)
;
}
;
return
ClassList
;
}
(
)
;
var
ClassListReference
=
function
(
_CachedReference
)
{
_inherits
4
(
ClassListReference
_CachedReference
)
;
function
ClassListReference
(
list
)
{
_classCallCheck
5
(
this
ClassListReference
)
;
var
_this
=
_possibleConstructorReturn
4
(
this
_CachedReference
.
call
(
this
)
)
;
_this
.
list
=
[
]
;
_this
.
tag
=
(
0
_reference2
.
combineTagged
)
(
list
)
;
_this
.
list
=
list
;
return
_this
;
}
ClassListReference
.
prototype
.
compute
=
function
compute
(
)
{
return
toClassName
(
this
.
list
)
;
}
;
return
ClassListReference
;
}
(
_reference2
.
CachedReference
)
;
function
toClassName
(
list
)
{
var
ret
=
[
]
;
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
var
value
=
list
[
i
]
.
value
(
)
;
if
(
value
!
=
=
false
&
&
value
!
=
=
null
&
&
value
!
=
=
undefined
)
ret
.
push
(
value
)
;
}
return
ret
.
length
=
=
=
0
?
null
:
ret
.
join
(
'
'
)
;
}
var
SimpleElementOperations
=
function
(
)
{
function
SimpleElementOperations
(
env
)
{
_classCallCheck
5
(
this
SimpleElementOperations
)
;
this
.
env
=
env
;
this
.
opcodes
=
null
;
this
.
classList
=
null
;
}
SimpleElementOperations
.
prototype
.
addStaticAttribute
=
function
addStaticAttribute
(
element
name
value
)
{
if
(
name
=
=
=
'
class
'
)
{
this
.
addClass
(
PrimitiveReference
.
create
(
value
)
)
;
}
else
{
this
.
env
.
getAppendOperations
(
)
.
setAttribute
(
element
name
value
)
;
}
}
;
SimpleElementOperations
.
prototype
.
addStaticAttributeNS
=
function
addStaticAttributeNS
(
element
namespace
name
value
)
{
this
.
env
.
getAppendOperations
(
)
.
setAttribute
(
element
name
value
namespace
)
;
}
;
SimpleElementOperations
.
prototype
.
addDynamicAttribute
=
function
addDynamicAttribute
(
element
name
reference
1
isTrusting
)
{
if
(
name
=
=
=
'
class
'
)
{
this
.
addClass
(
reference
1
)
;
}
else
{
var
attributeManager
=
this
.
env
.
attributeFor
(
element
name
isTrusting
)
;
var
attribute
=
new
DynamicAttribute
(
element
attributeManager
name
reference
1
)
;
this
.
addAttribute
(
attribute
)
;
}
}
;
SimpleElementOperations
.
prototype
.
addDynamicAttributeNS
=
function
addDynamicAttributeNS
(
element
namespace
name
reference
1
isTrusting
)
{
var
attributeManager
=
this
.
env
.
attributeFor
(
element
name
isTrusting
namespace
)
;
var
nsAttribute
=
new
DynamicAttribute
(
element
attributeManager
name
reference
1
namespace
)
;
this
.
addAttribute
(
nsAttribute
)
;
}
;
SimpleElementOperations
.
prototype
.
flush
=
function
flush
(
element
vm
)
{
var
env
=
vm
.
env
;
var
opcodes
=
this
.
opcodes
classList
=
this
.
classList
;
for
(
var
i
=
0
;
opcodes
&
&
i
<
opcodes
.
length
;
i
+
+
)
{
vm
.
updateWith
(
opcodes
[
i
]
)
;
}
if
(
classList
)
{
var
attributeManager
=
env
.
attributeFor
(
element
'
class
'
false
)
;
var
attribute
=
new
DynamicAttribute
(
element
attributeManager
'
class
'
classList
.
toReference
(
)
)
;
var
opcode
=
attribute
.
flush
(
env
)
;
if
(
opcode
)
{
vm
.
updateWith
(
opcode
)
;
}
}
this
.
opcodes
=
null
;
this
.
classList
=
null
;
}
;
SimpleElementOperations
.
prototype
.
addClass
=
function
addClass
(
reference
1
)
{
var
classList
=
this
.
classList
;
if
(
!
classList
)
{
classList
=
this
.
classList
=
new
ClassList
(
)
;
}
classList
.
append
(
reference
1
)
;
}
;
SimpleElementOperations
.
prototype
.
addAttribute
=
function
addAttribute
(
attribute
)
{
var
opcode
=
attribute
.
flush
(
this
.
env
)
;
if
(
opcode
)
{
var
opcodes
=
this
.
opcodes
;
if
(
!
opcodes
)
{
opcodes
=
this
.
opcodes
=
[
]
;
}
opcodes
.
push
(
opcode
)
;
}
}
;
return
SimpleElementOperations
;
}
(
)
;
var
ComponentElementOperations
=
function
(
)
{
function
ComponentElementOperations
(
env
)
{
_classCallCheck
5
(
this
ComponentElementOperations
)
;
this
.
env
=
env
;
this
.
attributeNames
=
null
;
this
.
attributes
=
null
;
this
.
classList
=
null
;
}
ComponentElementOperations
.
prototype
.
addStaticAttribute
=
function
addStaticAttribute
(
element
name
value
)
{
if
(
name
=
=
=
'
class
'
)
{
this
.
addClass
(
PrimitiveReference
.
create
(
value
)
)
;
}
else
if
(
this
.
shouldAddAttribute
(
name
)
)
{
this
.
addAttribute
(
name
new
StaticAttribute
(
element
name
value
)
)
;
}
}
;
ComponentElementOperations
.
prototype
.
addStaticAttributeNS
=
function
addStaticAttributeNS
(
element
namespace
name
value
)
{
if
(
this
.
shouldAddAttribute
(
name
)
)
{
this
.
addAttribute
(
name
new
StaticAttribute
(
element
name
value
namespace
)
)
;
}
}
;
ComponentElementOperations
.
prototype
.
addDynamicAttribute
=
function
addDynamicAttribute
(
element
name
reference
1
isTrusting
)
{
if
(
name
=
=
=
'
class
'
)
{
this
.
addClass
(
reference
1
)
;
}
else
if
(
this
.
shouldAddAttribute
(
name
)
)
{
var
attributeManager
=
this
.
env
.
attributeFor
(
element
name
isTrusting
)
;
var
attribute
=
new
DynamicAttribute
(
element
attributeManager
name
reference
1
)
;
this
.
addAttribute
(
name
attribute
)
;
}
}
;
ComponentElementOperations
.
prototype
.
addDynamicAttributeNS
=
function
addDynamicAttributeNS
(
element
namespace
name
reference
1
isTrusting
)
{
if
(
this
.
shouldAddAttribute
(
name
)
)
{
var
attributeManager
=
this
.
env
.
attributeFor
(
element
name
isTrusting
namespace
)
;
var
nsAttribute
=
new
DynamicAttribute
(
element
attributeManager
name
reference
1
namespace
)
;
this
.
addAttribute
(
name
nsAttribute
)
;
}
}
;
ComponentElementOperations
.
prototype
.
flush
=
function
flush
(
element
vm
)
{
var
env
=
this
.
env
;
var
attributes
=
this
.
attributes
classList
=
this
.
classList
;
for
(
var
i
=
0
;
attributes
&
&
i
<
attributes
.
length
;
i
+
+
)
{
var
opcode
=
attributes
[
i
]
.
flush
(
env
)
;
if
(
opcode
)
{
vm
.
updateWith
(
opcode
)
;
}
}
if
(
classList
)
{
var
attributeManager
=
env
.
attributeFor
(
element
'
class
'
false
)
;
var
attribute
=
new
DynamicAttribute
(
element
attributeManager
'
class
'
classList
.
toReference
(
)
)
;
var
_opcode
=
attribute
.
flush
(
env
)
;
if
(
_opcode
)
{
vm
.
updateWith
(
_opcode
)
;
}
}
}
;
ComponentElementOperations
.
prototype
.
shouldAddAttribute
=
function
shouldAddAttribute
(
name
)
{
return
!
this
.
attributeNames
|
|
this
.
attributeNames
.
indexOf
(
name
)
=
=
=
-
1
;
}
;
ComponentElementOperations
.
prototype
.
addClass
=
function
addClass
(
reference
1
)
{
var
classList
=
this
.
classList
;
if
(
!
classList
)
{
classList
=
this
.
classList
=
new
ClassList
(
)
;
}
classList
.
append
(
reference
1
)
;
}
;
ComponentElementOperations
.
prototype
.
addAttribute
=
function
addAttribute
(
name
attribute
)
{
var
attributeNames
=
this
.
attributeNames
attributes
=
this
.
attributes
;
if
(
!
attributeNames
)
{
attributeNames
=
this
.
attributeNames
=
[
]
;
attributes
=
this
.
attributes
=
[
]
;
}
attributeNames
.
push
(
name
)
;
attributes
.
push
(
attribute
)
;
}
;
return
ComponentElementOperations
;
}
(
)
;
APPEND_OPCODES
.
add
(
33
function
(
vm
)
{
var
stack
=
vm
.
elements
(
)
;
var
action
=
'
FlushElementOpcode
#
evaluate
'
;
stack
.
expectOperations
(
action
)
.
flush
(
stack
.
expectConstructing
(
action
)
vm
)
;
stack
.
flushElement
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
34
function
(
vm
)
{
return
vm
.
elements
(
)
.
closeElement
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
30
function
(
vm
_ref5
)
{
var
_name
=
_ref5
.
op1
_value
=
_ref5
.
op2
_namespace
=
_ref5
.
op3
;
var
name
=
vm
.
constants
.
getString
(
_name
)
;
var
value
=
vm
.
constants
.
getString
(
_value
)
;
if
(
_namespace
)
{
var
namespace
=
vm
.
constants
.
getString
(
_namespace
)
;
vm
.
elements
(
)
.
setStaticAttributeNS
(
namespace
name
value
)
;
}
else
{
vm
.
elements
(
)
.
setStaticAttribute
(
name
value
)
;
}
}
)
;
APPEND_OPCODES
.
add
(
35
function
(
vm
_ref6
)
{
var
_manager
=
_ref6
.
op1
;
var
manager
=
vm
.
constants
.
getOther
(
_manager
)
;
var
stack
=
vm
.
stack
;
var
args
=
stack
.
pop
(
)
;
var
tag
=
args
.
tag
;
var
_vm
elements
=
vm
.
elements
(
)
element
=
_vm
elements
.
constructing
updateOperations
=
_vm
elements
.
updateOperations
;
var
dynamicScope
=
vm
.
dynamicScope
(
)
;
var
modifier
=
manager
.
create
(
element
args
dynamicScope
updateOperations
)
;
args
.
clear
(
)
;
vm
.
env
.
scheduleInstallModifier
(
modifier
manager
)
;
var
destructor
=
manager
.
getDestructor
(
modifier
)
;
if
(
destructor
)
{
vm
.
newDestroyable
(
destructor
)
;
}
vm
.
updateWith
(
new
UpdateModifierOpcode
(
tag
manager
modifier
)
)
;
}
)
;
var
UpdateModifierOpcode
=
function
(
_UpdatingOpcode
)
{
_inherits
4
(
UpdateModifierOpcode
_UpdatingOpcode
)
;
function
UpdateModifierOpcode
(
tag
manager
modifier
)
{
_classCallCheck
5
(
this
UpdateModifierOpcode
)
;
var
_this2
=
_possibleConstructorReturn
4
(
this
_UpdatingOpcode
.
call
(
this
)
)
;
_this2
.
tag
=
tag
;
_this2
.
manager
=
manager
;
_this2
.
modifier
=
modifier
;
_this2
.
type
=
'
update
-
modifier
'
;
_this2
.
lastUpdated
=
tag
.
value
(
)
;
return
_this2
;
}
UpdateModifierOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
manager
=
this
.
manager
modifier
=
this
.
modifier
tag
=
this
.
tag
lastUpdated
=
this
.
lastUpdated
;
if
(
!
tag
.
validate
(
lastUpdated
)
)
{
vm
.
env
.
scheduleUpdateModifier
(
modifier
manager
)
;
this
.
lastUpdated
=
tag
.
value
(
)
;
}
}
;
UpdateModifierOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
guid
:
this
.
_guid
type
:
this
.
type
}
;
}
;
return
UpdateModifierOpcode
;
}
(
UpdatingOpcode
)
;
var
StaticAttribute
=
function
(
)
{
function
StaticAttribute
(
element
name
value
namespace
)
{
_classCallCheck
5
(
this
StaticAttribute
)
;
this
.
element
=
element
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
namespace
=
namespace
;
}
StaticAttribute
.
prototype
.
flush
=
function
flush
(
env
)
{
env
.
getAppendOperations
(
)
.
setAttribute
(
this
.
element
this
.
name
this
.
value
this
.
namespace
)
;
return
null
;
}
;
return
StaticAttribute
;
}
(
)
;
var
DynamicAttribute
=
function
(
)
{
function
DynamicAttribute
(
element
attributeManager
name
reference
1
namespace
)
{
_classCallCheck
5
(
this
DynamicAttribute
)
;
this
.
element
=
element
;
this
.
attributeManager
=
attributeManager
;
this
.
name
=
name
;
this
.
reference
=
reference
1
;
this
.
namespace
=
namespace
;
this
.
cache
=
null
;
this
.
tag
=
reference
1
.
tag
;
}
DynamicAttribute
.
prototype
.
patch
=
function
patch
(
env
)
{
var
element
=
this
.
element
cache
=
this
.
cache
;
var
value
=
cache
.
revalidate
(
)
;
if
(
(
0
_reference2
.
isModified
)
(
value
)
)
{
this
.
attributeManager
.
updateAttribute
(
env
element
value
this
.
namespace
)
;
}
}
;
DynamicAttribute
.
prototype
.
flush
=
function
flush
(
env
)
{
var
reference
1
=
this
.
reference
element
=
this
.
element
;
if
(
(
0
_reference2
.
isConst
)
(
reference
1
)
)
{
var
value
=
reference
1
.
value
(
)
;
this
.
attributeManager
.
setAttribute
(
env
element
value
this
.
namespace
)
;
return
null
;
}
else
{
var
cache
=
this
.
cache
=
new
_reference2
.
ReferenceCache
(
reference
1
)
;
var
_value2
=
cache
.
peek
(
)
;
this
.
attributeManager
.
setAttribute
(
env
element
_value2
this
.
namespace
)
;
return
new
PatchElementOpcode
(
this
)
;
}
}
;
DynamicAttribute
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
element
=
this
.
element
namespace
=
this
.
namespace
name
=
this
.
name
cache
=
this
.
cache
;
var
formattedElement
=
formatElement
(
element
)
;
var
lastValue
=
cache
.
peek
(
)
;
if
(
namespace
)
{
return
{
element
:
formattedElement
lastValue
:
lastValue
name
:
name
namespace
:
namespace
type
:
'
attribute
'
}
;
}
return
{
element
:
formattedElement
lastValue
:
lastValue
name
:
name
namespace
:
namespace
=
=
=
undefined
?
null
:
namespace
type
:
'
attribute
'
}
;
}
;
return
DynamicAttribute
;
}
(
)
;
function
formatElement
(
element
)
{
return
JSON
.
stringify
(
'
<
'
+
element
.
tagName
.
toLowerCase
(
)
+
'
/
>
'
)
;
}
APPEND_OPCODES
.
add
(
32
function
(
vm
_ref7
)
{
var
_name
=
_ref7
.
op1
_namespace
=
_ref7
.
op2
trusting
=
_ref7
.
op3
;
var
name
=
vm
.
constants
.
getString
(
_name
)
;
var
namespace
=
vm
.
constants
.
getString
(
_namespace
)
;
var
reference
1
=
vm
.
stack
.
pop
(
)
;
vm
.
elements
(
)
.
setDynamicAttributeNS
(
namespace
name
reference
1
!
!
trusting
)
;
}
)
;
APPEND_OPCODES
.
add
(
31
function
(
vm
_ref8
)
{
var
_name
=
_ref8
.
op1
trusting
=
_ref8
.
op2
;
var
name
=
vm
.
constants
.
getString
(
_name
)
;
var
reference
1
=
vm
.
stack
.
pop
(
)
;
vm
.
elements
(
)
.
setDynamicAttribute
(
name
reference
1
!
!
trusting
)
;
}
)
;
var
PatchElementOpcode
=
function
(
_UpdatingOpcode2
)
{
_inherits
4
(
PatchElementOpcode
_UpdatingOpcode2
)
;
function
PatchElementOpcode
(
operation
)
{
_classCallCheck
5
(
this
PatchElementOpcode
)
;
var
_this3
=
_possibleConstructorReturn
4
(
this
_UpdatingOpcode2
.
call
(
this
)
)
;
_this3
.
type
=
'
patch
-
element
'
;
_this3
.
tag
=
operation
.
tag
;
_this3
.
operation
=
operation
;
return
_this3
;
}
PatchElementOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
this
.
operation
.
patch
(
vm
.
env
)
;
}
;
PatchElementOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
_guid
=
this
.
_guid
type
=
this
.
type
operation
=
this
.
operation
;
return
{
details
:
operation
.
toJSON
(
)
guid
:
_guid
type
:
type
}
;
}
;
return
PatchElementOpcode
;
}
(
UpdatingOpcode
)
;
function
_defaults
3
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
3
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
3
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
3
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
3
(
subClass
superClass
)
;
}
APPEND_OPCODES
.
add
(
56
function
(
vm
_ref
)
{
var
_definition
=
_ref
.
op1
;
var
definition
=
vm
.
constants
.
getOther
(
_definition
)
;
var
stack
=
vm
.
stack
;
stack
.
push
(
{
definition
:
definition
manager
:
definition
.
manager
component
:
null
}
)
;
}
)
;
APPEND_OPCODES
.
add
(
57
function
(
vm
)
{
var
stack
=
vm
.
stack
;
var
reference
1
=
stack
.
pop
(
)
;
var
cache
=
(
0
_reference2
.
isConst
)
(
reference
1
)
?
undefined
:
new
_reference2
.
ReferenceCache
(
reference
1
)
;
var
definition
=
cache
?
cache
.
peek
(
)
:
reference
1
.
value
(
)
;
stack
.
push
(
{
definition
:
definition
manager
:
definition
.
manager
component
:
null
}
)
;
if
(
cache
)
{
vm
.
updateWith
(
new
Assert
(
cache
)
)
;
}
}
)
;
APPEND_OPCODES
.
add
(
58
function
(
vm
_ref2
)
{
var
synthetic
=
_ref2
.
op1
;
var
stack
=
vm
.
stack
;
ARGS
.
setup
(
stack
!
!
synthetic
)
;
stack
.
push
(
ARGS
)
;
}
)
;
APPEND_OPCODES
.
add
(
59
function
(
vm
_ref3
)
{
var
_state
=
_ref3
.
op1
;
var
stack
=
vm
.
stack
;
var
_vm
fetchValue
=
vm
.
fetchValue
(
_state
)
definition
=
_vm
fetchValue
.
definition
manager
=
_vm
fetchValue
.
manager
;
var
args
=
stack
.
pop
(
)
;
var
preparedArgs
=
manager
.
prepareArgs
(
definition
args
)
;
if
(
preparedArgs
)
{
args
.
clear
(
)
;
var
positional
=
preparedArgs
.
positional
named
=
preparedArgs
.
named
;
var
positionalCount
=
positional
.
length
;
for
(
var
i
=
0
;
i
<
positionalCount
;
i
+
+
)
{
stack
.
push
(
positional
[
i
]
)
;
}
stack
.
push
(
positionalCount
)
;
var
names
=
Object
.
keys
(
named
)
;
var
namedCount
=
names
.
length
;
var
atNames
=
[
]
;
for
(
var
_i
=
0
;
_i
<
namedCount
;
_i
+
+
)
{
var
value
=
named
[
names
[
_i
]
]
;
var
atName
=
'
'
+
names
[
_i
]
;
stack
.
push
(
value
)
;
atNames
.
push
(
atName
)
;
}
stack
.
push
(
atNames
)
;
args
.
setup
(
stack
false
)
;
}
stack
.
push
(
args
)
;
}
)
;
APPEND_OPCODES
.
add
(
60
function
(
vm
_ref4
)
{
var
_vm
fetchValue2
;
var
flags
=
_ref4
.
op1
_state
=
_ref4
.
op2
;
var
definition
=
void
0
;
var
manager
=
void
0
;
var
args
=
vm
.
stack
.
pop
(
)
;
var
dynamicScope
=
vm
.
dynamicScope
(
)
;
var
state
=
(
_vm
fetchValue2
=
vm
.
fetchValue
(
_state
)
definition
=
_vm
fetchValue2
.
definition
manager
=
_vm
fetchValue2
.
manager
_vm
fetchValue2
)
;
var
hasDefaultBlock
=
flags
&
1
;
var
component
=
manager
.
create
(
vm
.
env
definition
args
dynamicScope
vm
.
getSelf
(
)
!
!
hasDefaultBlock
)
;
state
.
component
=
component
;
vm
.
updateWith
(
new
UpdateComponentOpcode
(
args
.
tag
definition
.
name
component
manager
dynamicScope
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
61
function
(
vm
_ref5
)
{
var
_state
=
_ref5
.
op1
;
var
_vm
fetchValue3
=
vm
.
fetchValue
(
_state
)
manager
=
_vm
fetchValue3
.
manager
component
=
_vm
fetchValue3
.
component
;
var
destructor
=
manager
.
getDestructor
(
component
)
;
if
(
destructor
)
vm
.
newDestroyable
(
destructor
)
;
}
)
;
APPEND_OPCODES
.
add
(
65
function
(
vm
)
{
vm
.
beginCacheGroup
(
)
;
vm
.
elements
(
)
.
pushSimpleBlock
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
62
function
(
vm
)
{
vm
.
stack
.
push
(
new
ComponentElementOperations
(
vm
.
env
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
67
function
(
vm
_ref6
)
{
var
_state
=
_ref6
.
op1
;
var
_vm
fetchValue4
=
vm
.
fetchValue
(
_state
)
manager
=
_vm
fetchValue4
.
manager
component
=
_vm
fetchValue4
.
component
;
var
action
=
'
DidCreateElementOpcode
#
evaluate
'
;
manager
.
didCreateElement
(
component
vm
.
elements
(
)
.
expectConstructing
(
action
)
vm
.
elements
(
)
.
expectOperations
(
action
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
63
function
(
vm
_ref7
)
{
var
_state
=
_ref7
.
op1
;
var
state
=
vm
.
fetchValue
(
_state
)
;
vm
.
stack
.
push
(
state
.
manager
.
getSelf
(
state
.
component
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
64
function
(
vm
_ref8
)
{
var
_state
=
_ref8
.
op1
;
var
_vm
fetchValue5
=
vm
.
fetchValue
(
_state
)
manager
=
_vm
fetchValue5
.
manager
definition
=
_vm
fetchValue5
.
definition
component
=
_vm
fetchValue5
.
component
;
vm
.
stack
.
push
(
manager
.
layoutFor
(
definition
component
vm
.
env
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
68
function
(
vm
_ref9
)
{
var
_state
=
_ref9
.
op1
;
var
_vm
fetchValue6
=
vm
.
fetchValue
(
_state
)
manager
=
_vm
fetchValue6
.
manager
component
=
_vm
fetchValue6
.
component
;
var
bounds
=
vm
.
elements
(
)
.
popBlock
(
)
;
manager
.
didRenderLayout
(
component
bounds
)
;
vm
.
env
.
didCreate
(
component
manager
)
;
vm
.
updateWith
(
new
DidUpdateLayoutOpcode
(
manager
component
bounds
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
66
function
(
vm
)
{
return
vm
.
commitCacheGroup
(
)
;
}
)
;
var
UpdateComponentOpcode
=
function
(
_UpdatingOpcode
)
{
_inherits
3
(
UpdateComponentOpcode
_UpdatingOpcode
)
;
function
UpdateComponentOpcode
(
tag
name
component
manager
dynamicScope
)
{
_classCallCheck
3
(
this
UpdateComponentOpcode
)
;
var
_this
=
_possibleConstructorReturn
3
(
this
_UpdatingOpcode
.
call
(
this
)
)
;
_this
.
name
=
name
;
_this
.
component
=
component
;
_this
.
manager
=
manager
;
_this
.
dynamicScope
=
dynamicScope
;
_this
.
type
=
'
update
-
component
'
;
var
componentTag
=
manager
.
getTag
(
component
)
;
if
(
componentTag
)
{
_this
.
tag
=
(
0
_reference2
.
combine
)
(
[
tag
componentTag
]
)
;
}
else
{
_this
.
tag
=
tag
;
}
return
_this
;
}
UpdateComponentOpcode
.
prototype
.
evaluate
=
function
evaluate
(
_vm
)
{
var
component
=
this
.
component
manager
=
this
.
manager
dynamicScope
=
this
.
dynamicScope
;
manager
.
update
(
component
dynamicScope
)
;
}
;
UpdateComponentOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
args
:
[
JSON
.
stringify
(
this
.
name
)
]
guid
:
this
.
_guid
type
:
this
.
type
}
;
}
;
return
UpdateComponentOpcode
;
}
(
UpdatingOpcode
)
;
var
DidUpdateLayoutOpcode
=
function
(
_UpdatingOpcode2
)
{
_inherits
3
(
DidUpdateLayoutOpcode
_UpdatingOpcode2
)
;
function
DidUpdateLayoutOpcode
(
manager
component
bounds
)
{
_classCallCheck
3
(
this
DidUpdateLayoutOpcode
)
;
var
_this2
=
_possibleConstructorReturn
3
(
this
_UpdatingOpcode2
.
call
(
this
)
)
;
_this2
.
manager
=
manager
;
_this2
.
component
=
component
;
_this2
.
bounds
=
bounds
;
_this2
.
type
=
'
did
-
update
-
layout
'
;
_this2
.
tag
=
_reference2
.
CONSTANT_TAG
;
return
_this2
;
}
DidUpdateLayoutOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
manager
=
this
.
manager
component
=
this
.
component
bounds
=
this
.
bounds
;
manager
.
didUpdateLayout
(
component
bounds
)
;
vm
.
env
.
didUpdate
(
component
manager
)
;
}
;
return
DidUpdateLayoutOpcode
;
}
(
UpdatingOpcode
)
;
function
_classCallCheck
8
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Cursor
=
function
Cursor
(
element
nextSibling
)
{
_classCallCheck
8
(
this
Cursor
)
;
this
.
element
=
element
;
this
.
nextSibling
=
nextSibling
;
}
;
var
ConcreteBounds
=
function
(
)
{
function
ConcreteBounds
(
parentNode
first
last
)
{
_classCallCheck
8
(
this
ConcreteBounds
)
;
this
.
parentNode
=
parentNode
;
this
.
first
=
first
;
this
.
last
=
last
;
}
ConcreteBounds
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
parentNode
;
}
;
ConcreteBounds
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
first
;
}
;
ConcreteBounds
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
last
;
}
;
return
ConcreteBounds
;
}
(
)
;
var
SingleNodeBounds
=
function
(
)
{
function
SingleNodeBounds
(
parentNode
node
)
{
_classCallCheck
8
(
this
SingleNodeBounds
)
;
this
.
parentNode
=
parentNode
;
this
.
node
=
node
;
}
SingleNodeBounds
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
parentNode
;
}
;
SingleNodeBounds
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
node
;
}
;
SingleNodeBounds
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
node
;
}
;
return
SingleNodeBounds
;
}
(
)
;
function
single
(
parent
node
)
{
return
new
SingleNodeBounds
(
parent
node
)
;
}
function
move
(
bounds
reference
1
)
{
var
parent
=
bounds
.
parentElement
(
)
;
var
first
=
bounds
.
firstNode
(
)
;
var
last
=
bounds
.
lastNode
(
)
;
var
node
=
first
;
while
(
node
)
{
var
next
=
node
.
nextSibling
;
parent
.
insertBefore
(
node
reference
1
)
;
if
(
node
=
=
=
last
)
return
next
;
node
=
next
;
}
return
null
;
}
function
clear
(
bounds
)
{
var
parent
=
bounds
.
parentElement
(
)
;
var
first
=
bounds
.
firstNode
(
)
;
var
last
=
bounds
.
lastNode
(
)
;
var
node
=
first
;
while
(
node
)
{
var
next
=
node
.
nextSibling
;
parent
.
removeChild
(
node
)
;
if
(
node
=
=
=
last
)
return
next
;
node
=
next
;
}
return
null
;
}
function
_defaults
7
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
7
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
7
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
7
(
subClass
superClass
)
;
}
function
_classCallCheck
9
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
First
=
function
(
)
{
function
First
(
node
)
{
_classCallCheck
9
(
this
First
)
;
this
.
node
=
node
;
}
First
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
node
;
}
;
return
First
;
}
(
)
;
var
Last
=
function
(
)
{
function
Last
(
node
)
{
_classCallCheck
9
(
this
Last
)
;
this
.
node
=
node
;
}
Last
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
node
;
}
;
return
Last
;
}
(
)
;
var
Fragment
=
function
(
)
{
function
Fragment
(
bounds
1
)
{
_classCallCheck
9
(
this
Fragment
)
;
this
.
bounds
=
bounds
1
;
}
Fragment
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
bounds
.
parentElement
(
)
;
}
;
Fragment
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
bounds
.
firstNode
(
)
;
}
;
Fragment
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
bounds
.
lastNode
(
)
;
}
;
Fragment
.
prototype
.
update
=
function
update
(
bounds
1
)
{
this
.
bounds
=
bounds
1
;
}
;
return
Fragment
;
}
(
)
;
var
ElementStack
=
function
(
)
{
function
ElementStack
(
env
parentNode
nextSibling
)
{
_classCallCheck
9
(
this
ElementStack
)
;
this
.
constructing
=
null
;
this
.
operations
=
null
;
this
.
elementStack
=
new
_util
.
Stack
(
)
;
this
.
nextSiblingStack
=
new
_util
.
Stack
(
)
;
this
.
blockStack
=
new
_util
.
Stack
(
)
;
this
.
env
=
env
;
this
.
dom
=
env
.
getAppendOperations
(
)
;
this
.
updateOperations
=
env
.
getDOM
(
)
;
this
.
element
=
parentNode
;
this
.
nextSibling
=
nextSibling
;
this
.
defaultOperations
=
new
SimpleElementOperations
(
env
)
;
this
.
pushSimpleBlock
(
)
;
this
.
elementStack
.
push
(
this
.
element
)
;
this
.
nextSiblingStack
.
push
(
this
.
nextSibling
)
;
}
ElementStack
.
forInitialRender
=
function
forInitialRender
(
env
parentNode
nextSibling
)
{
return
new
ElementStack
(
env
parentNode
nextSibling
)
;
}
;
ElementStack
.
resume
=
function
resume
(
env
tracker
nextSibling
)
{
var
parentNode
=
tracker
.
parentElement
(
)
;
var
stack
=
new
ElementStack
(
env
parentNode
nextSibling
)
;
stack
.
pushBlockTracker
(
tracker
)
;
return
stack
;
}
;
ElementStack
.
prototype
.
expectConstructing
=
function
expectConstructing
(
method
)
{
return
this
.
constructing
;
}
;
ElementStack
.
prototype
.
expectOperations
=
function
expectOperations
(
method
)
{
return
this
.
operations
;
}
;
ElementStack
.
prototype
.
block
=
function
block
(
)
{
return
this
.
blockStack
.
current
;
}
;
ElementStack
.
prototype
.
popElement
=
function
popElement
(
)
{
var
elementStack
=
this
.
elementStack
nextSiblingStack
=
this
.
nextSiblingStack
;
var
topElement
=
elementStack
.
pop
(
)
;
nextSiblingStack
.
pop
(
)
;
this
.
element
=
elementStack
.
current
;
this
.
nextSibling
=
nextSiblingStack
.
current
;
return
topElement
;
}
;
ElementStack
.
prototype
.
pushSimpleBlock
=
function
pushSimpleBlock
(
)
{
var
tracker
=
new
SimpleBlockTracker
(
this
.
element
)
;
this
.
pushBlockTracker
(
tracker
)
;
return
tracker
;
}
;
ElementStack
.
prototype
.
pushUpdatableBlock
=
function
pushUpdatableBlock
(
)
{
var
tracker
=
new
UpdatableBlockTracker
(
this
.
element
)
;
this
.
pushBlockTracker
(
tracker
)
;
return
tracker
;
}
;
ElementStack
.
prototype
.
pushBlockTracker
=
function
pushBlockTracker
(
tracker
)
{
var
isRemote
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
false
;
var
current
=
this
.
blockStack
.
current
;
if
(
current
!
=
=
null
)
{
current
.
newDestroyable
(
tracker
)
;
if
(
!
isRemote
)
{
current
.
newBounds
(
tracker
)
;
}
}
this
.
blockStack
.
push
(
tracker
)
;
return
tracker
;
}
;
ElementStack
.
prototype
.
pushBlockList
=
function
pushBlockList
(
list
)
{
var
tracker
=
new
BlockListTracker
(
this
.
element
list
)
;
var
current
=
this
.
blockStack
.
current
;
if
(
current
!
=
=
null
)
{
current
.
newDestroyable
(
tracker
)
;
current
.
newBounds
(
tracker
)
;
}
this
.
blockStack
.
push
(
tracker
)
;
return
tracker
;
}
;
ElementStack
.
prototype
.
popBlock
=
function
popBlock
(
)
{
this
.
block
(
)
.
finalize
(
this
)
;
return
this
.
blockStack
.
pop
(
)
;
}
;
ElementStack
.
prototype
.
openElement
=
function
openElement
(
tag
_operations
)
{
var
operations
=
_operations
=
=
=
undefined
?
this
.
defaultOperations
:
_operations
;
var
element
=
this
.
dom
.
createElement
(
tag
this
.
element
)
;
this
.
constructing
=
element
;
this
.
operations
=
operations
;
return
element
;
}
;
ElementStack
.
prototype
.
flushElement
=
function
flushElement
(
)
{
var
parent
=
this
.
element
;
var
element
=
this
.
constructing
;
this
.
dom
.
insertBefore
(
parent
element
this
.
nextSibling
)
;
this
.
constructing
=
null
;
this
.
operations
=
null
;
this
.
pushElement
(
element
null
)
;
this
.
block
(
)
.
openElement
(
element
)
;
}
;
ElementStack
.
prototype
.
pushRemoteElement
=
function
pushRemoteElement
(
element
)
{
var
nextSibling
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
this
.
pushElement
(
element
nextSibling
)
;
var
tracker
=
new
RemoteBlockTracker
(
element
)
;
this
.
pushBlockTracker
(
tracker
true
)
;
}
;
ElementStack
.
prototype
.
popRemoteElement
=
function
popRemoteElement
(
)
{
this
.
popBlock
(
)
;
this
.
popElement
(
)
;
}
;
ElementStack
.
prototype
.
pushElement
=
function
pushElement
(
element
nextSibling
)
{
this
.
element
=
element
;
this
.
elementStack
.
push
(
element
)
;
this
.
nextSibling
=
nextSibling
;
this
.
nextSiblingStack
.
push
(
nextSibling
)
;
}
;
ElementStack
.
prototype
.
newDestroyable
=
function
newDestroyable
(
d
)
{
this
.
block
(
)
.
newDestroyable
(
d
)
;
}
;
ElementStack
.
prototype
.
newBounds
=
function
newBounds
(
bounds
1
)
{
this
.
block
(
)
.
newBounds
(
bounds
1
)
;
}
;
ElementStack
.
prototype
.
appendText
=
function
appendText
(
string
)
{
var
dom
=
this
.
dom
;
var
text
=
dom
.
createTextNode
(
string
)
;
dom
.
insertBefore
(
this
.
element
text
this
.
nextSibling
)
;
this
.
block
(
)
.
newNode
(
text
)
;
return
text
;
}
;
ElementStack
.
prototype
.
appendComment
=
function
appendComment
(
string
)
{
var
dom
=
this
.
dom
;
var
comment
=
dom
.
createComment
(
string
)
;
dom
.
insertBefore
(
this
.
element
comment
this
.
nextSibling
)
;
this
.
block
(
)
.
newNode
(
comment
)
;
return
comment
;
}
;
ElementStack
.
prototype
.
setStaticAttribute
=
function
setStaticAttribute
(
name
value
)
{
this
.
expectOperations
(
'
setStaticAttribute
'
)
.
addStaticAttribute
(
this
.
expectConstructing
(
'
setStaticAttribute
'
)
name
value
)
;
}
;
ElementStack
.
prototype
.
setStaticAttributeNS
=
function
setStaticAttributeNS
(
namespace
name
value
)
{
this
.
expectOperations
(
'
setStaticAttributeNS
'
)
.
addStaticAttributeNS
(
this
.
expectConstructing
(
'
setStaticAttributeNS
'
)
namespace
name
value
)
;
}
;
ElementStack
.
prototype
.
setDynamicAttribute
=
function
setDynamicAttribute
(
name
reference
1
isTrusting
)
{
this
.
expectOperations
(
'
setDynamicAttribute
'
)
.
addDynamicAttribute
(
this
.
expectConstructing
(
'
setDynamicAttribute
'
)
name
reference
1
isTrusting
)
;
}
;
ElementStack
.
prototype
.
setDynamicAttributeNS
=
function
setDynamicAttributeNS
(
namespace
name
reference
1
isTrusting
)
{
this
.
expectOperations
(
'
setDynamicAttributeNS
'
)
.
addDynamicAttributeNS
(
this
.
expectConstructing
(
'
setDynamicAttributeNS
'
)
namespace
name
reference
1
isTrusting
)
;
}
;
ElementStack
.
prototype
.
closeElement
=
function
closeElement
(
)
{
this
.
block
(
)
.
closeElement
(
)
;
this
.
popElement
(
)
;
}
;
return
ElementStack
;
}
(
)
;
var
SimpleBlockTracker
=
function
(
)
{
function
SimpleBlockTracker
(
parent
)
{
_classCallCheck
9
(
this
SimpleBlockTracker
)
;
this
.
parent
=
parent
;
this
.
first
=
null
;
this
.
last
=
null
;
this
.
destroyables
=
null
;
this
.
nesting
=
0
;
}
SimpleBlockTracker
.
prototype
.
destroy
=
function
destroy
(
)
{
var
destroyables
=
this
.
destroyables
;
if
(
destroyables
&
&
destroyables
.
length
)
{
for
(
var
i
=
0
;
i
<
destroyables
.
length
;
i
+
+
)
{
destroyables
[
i
]
.
destroy
(
)
;
}
}
}
;
SimpleBlockTracker
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
parent
;
}
;
SimpleBlockTracker
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
first
&
&
this
.
first
.
firstNode
(
)
;
}
;
SimpleBlockTracker
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
last
&
&
this
.
last
.
lastNode
(
)
;
}
;
SimpleBlockTracker
.
prototype
.
openElement
=
function
openElement
(
element
)
{
this
.
newNode
(
element
)
;
this
.
nesting
+
+
;
}
;
SimpleBlockTracker
.
prototype
.
closeElement
=
function
closeElement
(
)
{
this
.
nesting
-
-
;
}
;
SimpleBlockTracker
.
prototype
.
newNode
=
function
newNode
(
node
)
{
if
(
this
.
nesting
!
=
=
0
)
return
;
if
(
!
this
.
first
)
{
this
.
first
=
new
First
(
node
)
;
}
this
.
last
=
new
Last
(
node
)
;
}
;
SimpleBlockTracker
.
prototype
.
newBounds
=
function
newBounds
(
bounds
1
)
{
if
(
this
.
nesting
!
=
=
0
)
return
;
if
(
!
this
.
first
)
{
this
.
first
=
bounds
1
;
}
this
.
last
=
bounds
1
;
}
;
SimpleBlockTracker
.
prototype
.
newDestroyable
=
function
newDestroyable
(
d
)
{
this
.
destroyables
=
this
.
destroyables
|
|
[
]
;
this
.
destroyables
.
push
(
d
)
;
}
;
SimpleBlockTracker
.
prototype
.
finalize
=
function
finalize
(
stack
)
{
if
(
!
this
.
first
)
{
stack
.
appendComment
(
'
'
)
;
}
}
;
return
SimpleBlockTracker
;
}
(
)
;
var
RemoteBlockTracker
=
function
(
_SimpleBlockTracker
)
{
_inherits
7
(
RemoteBlockTracker
_SimpleBlockTracker
)
;
function
RemoteBlockTracker
(
)
{
_classCallCheck
9
(
this
RemoteBlockTracker
)
;
return
_possibleConstructorReturn
7
(
this
_SimpleBlockTracker
.
apply
(
this
arguments
)
)
;
}
RemoteBlockTracker
.
prototype
.
destroy
=
function
destroy
(
)
{
_SimpleBlockTracker
.
prototype
.
destroy
.
call
(
this
)
;
clear
(
this
)
;
}
;
return
RemoteBlockTracker
;
}
(
SimpleBlockTracker
)
;
var
UpdatableBlockTracker
=
function
(
_SimpleBlockTracker2
)
{
_inherits
7
(
UpdatableBlockTracker
_SimpleBlockTracker2
)
;
function
UpdatableBlockTracker
(
)
{
_classCallCheck
9
(
this
UpdatableBlockTracker
)
;
return
_possibleConstructorReturn
7
(
this
_SimpleBlockTracker2
.
apply
(
this
arguments
)
)
;
}
UpdatableBlockTracker
.
prototype
.
reset
=
function
reset
(
env
)
{
var
destroyables
=
this
.
destroyables
;
if
(
destroyables
&
&
destroyables
.
length
)
{
for
(
var
i
=
0
;
i
<
destroyables
.
length
;
i
+
+
)
{
env
.
didDestroy
(
destroyables
[
i
]
)
;
}
}
var
nextSibling
=
clear
(
this
)
;
this
.
first
=
null
;
this
.
last
=
null
;
this
.
destroyables
=
null
;
this
.
nesting
=
0
;
return
nextSibling
;
}
;
return
UpdatableBlockTracker
;
}
(
SimpleBlockTracker
)
;
var
BlockListTracker
=
function
(
)
{
function
BlockListTracker
(
parent
boundList
)
{
_classCallCheck
9
(
this
BlockListTracker
)
;
this
.
parent
=
parent
;
this
.
boundList
=
boundList
;
this
.
parent
=
parent
;
this
.
boundList
=
boundList
;
}
BlockListTracker
.
prototype
.
destroy
=
function
destroy
(
)
{
this
.
boundList
.
forEachNode
(
function
(
node
)
{
return
node
.
destroy
(
)
;
}
)
;
}
;
BlockListTracker
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
parent
;
}
;
BlockListTracker
.
prototype
.
firstNode
=
function
firstNode
(
)
{
var
head
=
this
.
boundList
.
head
(
)
;
return
head
&
&
head
.
firstNode
(
)
;
}
;
BlockListTracker
.
prototype
.
lastNode
=
function
lastNode
(
)
{
var
tail
=
this
.
boundList
.
tail
(
)
;
return
tail
&
&
tail
.
lastNode
(
)
;
}
;
BlockListTracker
.
prototype
.
openElement
=
function
openElement
(
_element
)
{
(
0
_util
.
assert
)
(
false
'
Cannot
openElement
directly
inside
a
block
list
'
)
;
}
;
BlockListTracker
.
prototype
.
closeElement
=
function
closeElement
(
)
{
(
0
_util
.
assert
)
(
false
'
Cannot
closeElement
directly
inside
a
block
list
'
)
;
}
;
BlockListTracker
.
prototype
.
newNode
=
function
newNode
(
_node
)
{
(
0
_util
.
assert
)
(
false
'
Cannot
create
a
new
node
directly
inside
a
block
list
'
)
;
}
;
BlockListTracker
.
prototype
.
newBounds
=
function
newBounds
(
_bounds
)
{
}
;
BlockListTracker
.
prototype
.
newDestroyable
=
function
newDestroyable
(
_d
)
{
}
;
BlockListTracker
.
prototype
.
finalize
=
function
finalize
(
_stack
)
{
}
;
return
BlockListTracker
;
}
(
)
;
function
_classCallCheck
10
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
COMPONENT_DEFINITION_BRAND
=
'
COMPONENT
DEFINITION
[
id
=
e59c754e
-
61eb
-
4392
-
8c4a
-
2c0ac72bfcd4
]
'
;
function
isComponentDefinition
(
obj
)
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
!
=
=
null
&
&
obj
[
COMPONENT_DEFINITION_BRAND
]
;
}
var
ComponentDefinition
=
function
ComponentDefinition
(
name
manager
ComponentClass
)
{
_classCallCheck
10
(
this
ComponentDefinition
)
;
this
[
COMPONENT_DEFINITION_BRAND
]
=
true
;
this
.
name
=
name
;
this
.
manager
=
manager
;
this
.
ComponentClass
=
ComponentClass
;
}
;
function
_defaults
8
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
8
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
8
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
8
(
subClass
superClass
)
;
}
function
_classCallCheck
11
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
isSafeString
(
value
)
{
return
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
toHTML
=
=
=
'
function
'
;
}
function
isNode
(
value
)
{
return
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
nodeType
=
=
=
'
number
'
;
}
function
isString
(
value
)
{
return
typeof
value
=
=
=
'
string
'
;
}
var
Upsert
=
function
Upsert
(
bounds
1
)
{
_classCallCheck
11
(
this
Upsert
)
;
this
.
bounds
=
bounds
1
;
}
;
function
cautiousInsert
(
dom
cursor
value
)
{
if
(
isString
(
value
)
)
{
return
TextUpsert
.
insert
(
dom
cursor
value
)
;
}
if
(
isSafeString
(
value
)
)
{
return
SafeStringUpsert
.
insert
(
dom
cursor
value
)
;
}
if
(
isNode
(
value
)
)
{
return
NodeUpsert
.
insert
(
dom
cursor
value
)
;
}
throw
(
0
_util
.
unreachable
)
(
)
;
}
function
trustingInsert
(
dom
cursor
value
)
{
if
(
isString
(
value
)
)
{
return
HTMLUpsert
.
insert
(
dom
cursor
value
)
;
}
if
(
isNode
(
value
)
)
{
return
NodeUpsert
.
insert
(
dom
cursor
value
)
;
}
throw
(
0
_util
.
unreachable
)
(
)
;
}
var
TextUpsert
=
function
(
_Upsert
)
{
_inherits
8
(
TextUpsert
_Upsert
)
;
TextUpsert
.
insert
=
function
insert
(
dom
cursor
value
)
{
var
textNode
=
dom
.
createTextNode
(
value
)
;
dom
.
insertBefore
(
cursor
.
element
textNode
cursor
.
nextSibling
)
;
var
bounds
1
=
new
SingleNodeBounds
(
cursor
.
element
textNode
)
;
return
new
TextUpsert
(
bounds
1
textNode
)
;
}
;
function
TextUpsert
(
bounds
1
textNode
)
{
_classCallCheck
11
(
this
TextUpsert
)
;
var
_this
=
_possibleConstructorReturn
8
(
this
_Upsert
.
call
(
this
bounds
1
)
)
;
_this
.
textNode
=
textNode
;
return
_this
;
}
TextUpsert
.
prototype
.
update
=
function
update
(
_dom
value
)
{
if
(
isString
(
value
)
)
{
var
textNode
=
this
.
textNode
;
textNode
.
nodeValue
=
value
;
return
true
;
}
else
{
return
false
;
}
}
;
return
TextUpsert
;
}
(
Upsert
)
;
var
HTMLUpsert
=
function
(
_Upsert2
)
{
_inherits
8
(
HTMLUpsert
_Upsert2
)
;
function
HTMLUpsert
(
)
{
_classCallCheck
11
(
this
HTMLUpsert
)
;
return
_possibleConstructorReturn
8
(
this
_Upsert2
.
apply
(
this
arguments
)
)
;
}
HTMLUpsert
.
insert
=
function
insert
(
dom
cursor
value
)
{
var
bounds
1
=
dom
.
insertHTMLBefore
(
cursor
.
element
cursor
.
nextSibling
value
)
;
return
new
HTMLUpsert
(
bounds
1
)
;
}
;
HTMLUpsert
.
prototype
.
update
=
function
update
(
dom
value
)
{
if
(
isString
(
value
)
)
{
var
bounds
1
=
this
.
bounds
;
var
parentElement
=
bounds
1
.
parentElement
(
)
;
var
nextSibling
=
clear
(
bounds
1
)
;
this
.
bounds
=
dom
.
insertHTMLBefore
(
parentElement
nextSibling
value
)
;
return
true
;
}
else
{
return
false
;
}
}
;
return
HTMLUpsert
;
}
(
Upsert
)
;
var
SafeStringUpsert
=
function
(
_Upsert3
)
{
_inherits
8
(
SafeStringUpsert
_Upsert3
)
;
function
SafeStringUpsert
(
bounds
1
lastStringValue
)
{
_classCallCheck
11
(
this
SafeStringUpsert
)
;
var
_this3
=
_possibleConstructorReturn
8
(
this
_Upsert3
.
call
(
this
bounds
1
)
)
;
_this3
.
lastStringValue
=
lastStringValue
;
return
_this3
;
}
SafeStringUpsert
.
insert
=
function
insert
(
dom
cursor
value
)
{
var
stringValue
=
value
.
toHTML
(
)
;
var
bounds
1
=
dom
.
insertHTMLBefore
(
cursor
.
element
cursor
.
nextSibling
stringValue
)
;
return
new
SafeStringUpsert
(
bounds
1
stringValue
)
;
}
;
SafeStringUpsert
.
prototype
.
update
=
function
update
(
dom
value
)
{
if
(
isSafeString
(
value
)
)
{
var
stringValue
=
value
.
toHTML
(
)
;
if
(
stringValue
!
=
=
this
.
lastStringValue
)
{
var
bounds
1
=
this
.
bounds
;
var
parentElement
=
bounds
1
.
parentElement
(
)
;
var
nextSibling
=
clear
(
bounds
1
)
;
this
.
bounds
=
dom
.
insertHTMLBefore
(
parentElement
nextSibling
stringValue
)
;
this
.
lastStringValue
=
stringValue
;
}
return
true
;
}
else
{
return
false
;
}
}
;
return
SafeStringUpsert
;
}
(
Upsert
)
;
var
NodeUpsert
=
function
(
_Upsert4
)
{
_inherits
8
(
NodeUpsert
_Upsert4
)
;
function
NodeUpsert
(
)
{
_classCallCheck
11
(
this
NodeUpsert
)
;
return
_possibleConstructorReturn
8
(
this
_Upsert4
.
apply
(
this
arguments
)
)
;
}
NodeUpsert
.
insert
=
function
insert
(
dom
cursor
node
)
{
dom
.
insertBefore
(
cursor
.
element
node
cursor
.
nextSibling
)
;
return
new
NodeUpsert
(
single
(
cursor
.
element
node
)
)
;
}
;
NodeUpsert
.
prototype
.
update
=
function
update
(
dom
value
)
{
if
(
isNode
(
value
)
)
{
var
bounds
1
=
this
.
bounds
;
var
parentElement
=
bounds
1
.
parentElement
(
)
;
var
nextSibling
=
clear
(
bounds
1
)
;
this
.
bounds
=
dom
.
insertNodeBefore
(
parentElement
value
nextSibling
)
;
return
true
;
}
else
{
return
false
;
}
}
;
return
NodeUpsert
;
}
(
Upsert
)
;
function
_defaults
6
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
6
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
6
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
6
(
subClass
superClass
)
;
}
function
_classCallCheck
7
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
APPEND_OPCODES
.
add
(
26
function
(
vm
_ref
)
{
var
append
=
_ref
.
op1
;
var
opcode
=
vm
.
constants
.
getOther
(
append
)
;
opcode
.
evaluate
(
vm
)
;
}
)
;
function
isEmpty
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
|
|
typeof
value
.
toString
!
=
=
'
function
'
;
}
function
normalizeTextValue
(
value
)
{
if
(
isEmpty
(
value
)
)
{
return
'
'
;
}
return
String
(
value
)
;
}
function
normalizeTrustedValue
(
value
)
{
if
(
isEmpty
(
value
)
)
{
return
'
'
;
}
if
(
isString
(
value
)
)
{
return
value
;
}
if
(
isSafeString
(
value
)
)
{
return
value
.
toHTML
(
)
;
}
if
(
isNode
(
value
)
)
{
return
value
;
}
return
String
(
value
)
;
}
function
normalizeValue
(
value
)
{
if
(
isEmpty
(
value
)
)
{
return
'
'
;
}
if
(
isString
(
value
)
)
{
return
value
;
}
if
(
isSafeString
(
value
)
|
|
isNode
(
value
)
)
{
return
value
;
}
return
String
(
value
)
;
}
var
AppendDynamicOpcode
=
function
(
)
{
function
AppendDynamicOpcode
(
)
{
_classCallCheck
7
(
this
AppendDynamicOpcode
)
;
}
AppendDynamicOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
reference
1
=
vm
.
stack
.
pop
(
)
;
var
normalized
=
this
.
normalize
(
reference
1
)
;
var
value
=
void
0
;
var
cache
=
void
0
;
if
(
(
0
_reference2
.
isConst
)
(
reference
1
)
)
{
value
=
normalized
.
value
(
)
;
}
else
{
cache
=
new
_reference2
.
ReferenceCache
(
normalized
)
;
value
=
cache
.
peek
(
)
;
}
var
stack
=
vm
.
elements
(
)
;
var
upsert
=
this
.
insert
(
vm
.
env
.
getAppendOperations
(
)
stack
value
)
;
var
bounds
1
=
new
Fragment
(
upsert
.
bounds
)
;
stack
.
newBounds
(
bounds
1
)
;
if
(
cache
)
{
vm
.
updateWith
(
this
.
updateWith
(
vm
reference
1
cache
bounds
1
upsert
)
)
;
}
}
;
return
AppendDynamicOpcode
;
}
(
)
;
var
IsComponentDefinitionReference
=
function
(
_ConditionalReference
)
{
_inherits
6
(
IsComponentDefinitionReference
_ConditionalReference
)
;
function
IsComponentDefinitionReference
(
)
{
_classCallCheck
7
(
this
IsComponentDefinitionReference
)
;
return
_possibleConstructorReturn
6
(
this
_ConditionalReference
.
apply
(
this
arguments
)
)
;
}
IsComponentDefinitionReference
.
create
=
function
create
(
inner
)
{
return
new
IsComponentDefinitionReference
(
inner
)
;
}
;
IsComponentDefinitionReference
.
prototype
.
toBool
=
function
toBool
(
value
)
{
return
isComponentDefinition
(
value
)
;
}
;
return
IsComponentDefinitionReference
;
}
(
ConditionalReference
)
;
var
UpdateOpcode
=
function
(
_UpdatingOpcode
)
{
_inherits
6
(
UpdateOpcode
_UpdatingOpcode
)
;
function
UpdateOpcode
(
cache
bounds
1
upsert
)
{
_classCallCheck
7
(
this
UpdateOpcode
)
;
var
_this2
=
_possibleConstructorReturn
6
(
this
_UpdatingOpcode
.
call
(
this
)
)
;
_this2
.
cache
=
cache
;
_this2
.
bounds
=
bounds
1
;
_this2
.
upsert
=
upsert
;
_this2
.
tag
=
cache
.
tag
;
return
_this2
;
}
UpdateOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
value
=
this
.
cache
.
revalidate
(
)
;
if
(
(
0
_reference2
.
isModified
)
(
value
)
)
{
var
bounds
1
=
this
.
bounds
upsert
=
this
.
upsert
;
var
dom
=
vm
.
dom
;
if
(
!
this
.
upsert
.
update
(
dom
value
)
)
{
var
cursor
=
new
Cursor
(
bounds
1
.
parentElement
(
)
clear
(
bounds
1
)
)
;
upsert
=
this
.
upsert
=
this
.
insert
(
vm
.
env
.
getAppendOperations
(
)
cursor
value
)
;
}
bounds
1
.
update
(
upsert
.
bounds
)
;
}
}
;
UpdateOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
guid
=
this
.
_guid
type
=
this
.
type
cache
=
this
.
cache
;
return
{
details
:
{
lastValue
:
JSON
.
stringify
(
cache
.
peek
(
)
)
}
guid
:
guid
type
:
type
}
;
}
;
return
UpdateOpcode
;
}
(
UpdatingOpcode
)
;
var
OptimizedCautiousAppendOpcode
=
function
(
_AppendDynamicOpcode
)
{
_inherits
6
(
OptimizedCautiousAppendOpcode
_AppendDynamicOpcode
)
;
function
OptimizedCautiousAppendOpcode
(
)
{
_classCallCheck
7
(
this
OptimizedCautiousAppendOpcode
)
;
var
_this3
=
_possibleConstructorReturn
6
(
this
_AppendDynamicOpcode
.
apply
(
this
arguments
)
)
;
_this3
.
type
=
'
optimized
-
cautious
-
append
'
;
return
_this3
;
}
OptimizedCautiousAppendOpcode
.
prototype
.
normalize
=
function
normalize
(
reference
1
)
{
return
(
0
_reference2
.
map
)
(
reference
1
normalizeValue
)
;
}
;
OptimizedCautiousAppendOpcode
.
prototype
.
insert
=
function
insert
(
dom
cursor
value
)
{
return
cautiousInsert
(
dom
cursor
value
)
;
}
;
OptimizedCautiousAppendOpcode
.
prototype
.
updateWith
=
function
updateWith
(
_vm
_reference
cache
bounds
1
upsert
)
{
return
new
OptimizedCautiousUpdateOpcode
(
cache
bounds
1
upsert
)
;
}
;
return
OptimizedCautiousAppendOpcode
;
}
(
AppendDynamicOpcode
)
;
var
OptimizedCautiousUpdateOpcode
=
function
(
_UpdateOpcode
)
{
_inherits
6
(
OptimizedCautiousUpdateOpcode
_UpdateOpcode
)
;
function
OptimizedCautiousUpdateOpcode
(
)
{
_classCallCheck
7
(
this
OptimizedCautiousUpdateOpcode
)
;
var
_this4
=
_possibleConstructorReturn
6
(
this
_UpdateOpcode
.
apply
(
this
arguments
)
)
;
_this4
.
type
=
'
optimized
-
cautious
-
update
'
;
return
_this4
;
}
OptimizedCautiousUpdateOpcode
.
prototype
.
insert
=
function
insert
(
dom
cursor
value
)
{
return
cautiousInsert
(
dom
cursor
value
)
;
}
;
return
OptimizedCautiousUpdateOpcode
;
}
(
UpdateOpcode
)
;
var
OptimizedTrustingAppendOpcode
=
function
(
_AppendDynamicOpcode2
)
{
_inherits
6
(
OptimizedTrustingAppendOpcode
_AppendDynamicOpcode2
)
;
function
OptimizedTrustingAppendOpcode
(
)
{
_classCallCheck
7
(
this
OptimizedTrustingAppendOpcode
)
;
var
_this5
=
_possibleConstructorReturn
6
(
this
_AppendDynamicOpcode2
.
apply
(
this
arguments
)
)
;
_this5
.
type
=
'
optimized
-
trusting
-
append
'
;
return
_this5
;
}
OptimizedTrustingAppendOpcode
.
prototype
.
normalize
=
function
normalize
(
reference
1
)
{
return
(
0
_reference2
.
map
)
(
reference
1
normalizeTrustedValue
)
;
}
;
OptimizedTrustingAppendOpcode
.
prototype
.
insert
=
function
insert
(
dom
cursor
value
)
{
return
trustingInsert
(
dom
cursor
value
)
;
}
;
OptimizedTrustingAppendOpcode
.
prototype
.
updateWith
=
function
updateWith
(
_vm
_reference
cache
bounds
1
upsert
)
{
return
new
OptimizedTrustingUpdateOpcode
(
cache
bounds
1
upsert
)
;
}
;
return
OptimizedTrustingAppendOpcode
;
}
(
AppendDynamicOpcode
)
;
var
OptimizedTrustingUpdateOpcode
=
function
(
_UpdateOpcode2
)
{
_inherits
6
(
OptimizedTrustingUpdateOpcode
_UpdateOpcode2
)
;
function
OptimizedTrustingUpdateOpcode
(
)
{
_classCallCheck
7
(
this
OptimizedTrustingUpdateOpcode
)
;
var
_this6
=
_possibleConstructorReturn
6
(
this
_UpdateOpcode2
.
apply
(
this
arguments
)
)
;
_this6
.
type
=
'
optimized
-
trusting
-
update
'
;
return
_this6
;
}
OptimizedTrustingUpdateOpcode
.
prototype
.
insert
=
function
insert
(
dom
cursor
value
)
{
return
trustingInsert
(
dom
cursor
value
)
;
}
;
return
OptimizedTrustingUpdateOpcode
;
}
(
UpdateOpcode
)
;
function
_classCallCheck
12
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
debugCallback
(
context
get
)
{
console
.
info
(
'
Use
context
and
get
(
<
path
>
)
to
debug
this
template
.
'
)
;
context
=
=
=
get
(
'
this
'
)
;
debugger
;
}
var
callback
=
debugCallback
;
function
setDebuggerCallback
(
cb
)
{
callback
=
cb
;
}
function
resetDebuggerCallback
(
)
{
callback
=
debugCallback
;
}
var
ScopeInspector
=
function
(
)
{
function
ScopeInspector
(
scope
symbols
evalInfo
)
{
_classCallCheck
12
(
this
ScopeInspector
)
;
this
.
scope
=
scope
;
this
.
locals
=
(
0
_util
.
dict
)
(
)
;
for
(
var
i
=
0
;
i
<
evalInfo
.
length
;
i
+
+
)
{
var
slot
=
evalInfo
[
i
]
;
var
name
=
symbols
[
slot
-
1
]
;
var
ref
=
scope
.
getSymbol
(
slot
)
;
this
.
locals
[
name
]
=
ref
;
}
}
ScopeInspector
.
prototype
.
get
=
function
get
(
path
)
{
var
scope
=
this
.
scope
locals
=
this
.
locals
;
var
parts
=
path
.
split
(
'
.
'
)
;
var
_path
split
=
path
.
split
(
'
.
'
)
head
=
_path
split
[
0
]
tail
=
_path
split
.
slice
(
1
)
;
var
evalScope
=
scope
.
getEvalScope
(
)
;
var
ref
=
void
0
;
if
(
head
=
=
=
'
this
'
)
{
ref
=
scope
.
getSelf
(
)
;
}
else
if
(
locals
[
head
]
)
{
ref
=
locals
[
head
]
;
}
else
if
(
head
.
indexOf
(
'
'
)
=
=
=
0
&
&
evalScope
[
head
]
)
{
ref
=
evalScope
[
head
]
;
}
else
{
ref
=
this
.
scope
.
getSelf
(
)
;
tail
=
parts
;
}
return
tail
.
reduce
(
function
(
r
part
)
{
return
r
.
get
(
part
)
;
}
ref
)
;
}
;
return
ScopeInspector
;
}
(
)
;
APPEND_OPCODES
.
add
(
71
function
(
vm
_ref
)
{
var
_symbols
=
_ref
.
op1
_evalInfo
=
_ref
.
op2
;
var
symbols
=
vm
.
constants
.
getOther
(
_symbols
)
;
var
evalInfo
=
vm
.
constants
.
getArray
(
_evalInfo
)
;
var
inspector
=
new
ScopeInspector
(
vm
.
scope
(
)
symbols
evalInfo
)
;
callback
(
vm
.
getSelf
(
)
.
value
(
)
function
(
path
)
{
return
inspector
.
get
(
path
)
.
value
(
)
;
}
)
;
}
)
;
APPEND_OPCODES
.
add
(
69
function
(
vm
)
{
var
stack
=
vm
.
stack
;
var
definition
=
stack
.
pop
(
)
;
stack
.
push
(
definition
.
value
(
)
.
template
.
asPartial
(
)
)
;
}
)
;
function
_classCallCheck
13
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
IterablePresenceReference
=
function
(
)
{
function
IterablePresenceReference
(
artifacts
)
{
_classCallCheck
13
(
this
IterablePresenceReference
)
;
this
.
tag
=
artifacts
.
tag
;
this
.
artifacts
=
artifacts
;
}
IterablePresenceReference
.
prototype
.
value
=
function
value
(
)
{
return
!
this
.
artifacts
.
isEmpty
(
)
;
}
;
return
IterablePresenceReference
;
}
(
)
;
APPEND_OPCODES
.
add
(
54
function
(
vm
)
{
var
stack
=
vm
.
stack
;
var
listRef
=
stack
.
pop
(
)
;
var
key
=
stack
.
pop
(
)
;
var
iterable
=
vm
.
env
.
iterableFor
(
listRef
key
.
value
(
)
)
;
var
iterator
=
new
_reference2
.
ReferenceIterator
(
iterable
)
;
stack
.
push
(
iterator
)
;
stack
.
push
(
new
IterablePresenceReference
(
iterator
.
artifacts
)
)
;
}
)
;
APPEND_OPCODES
.
add
(
52
function
(
vm
_ref
)
{
var
relativeStart
=
_ref
.
op1
;
vm
.
enterList
(
relativeStart
)
;
}
)
;
APPEND_OPCODES
.
add
(
53
function
(
vm
)
{
return
vm
.
exitList
(
)
;
}
)
;
APPEND_OPCODES
.
add
(
55
function
(
vm
_ref2
)
{
var
breaks
=
_ref2
.
op1
;
var
stack
=
vm
.
stack
;
var
item
=
stack
.
peek
(
)
.
next
(
)
;
if
(
item
)
{
var
tryOpcode
=
vm
.
iterate
(
item
.
memo
item
.
value
)
;
vm
.
enterItem
(
item
.
key
tryOpcode
)
;
}
else
{
vm
.
goto
(
breaks
)
;
}
}
)
;
var
Ops
2
;
(
function
(
Ops
1
)
{
Ops
1
[
Ops
1
[
"
OpenComponentElement
"
]
=
0
]
=
"
OpenComponentElement
"
;
Ops
1
[
Ops
1
[
"
DidCreateElement
"
]
=
1
]
=
"
DidCreateElement
"
;
Ops
1
[
Ops
1
[
"
DidRenderLayout
"
]
=
2
]
=
"
DidRenderLayout
"
;
Ops
1
[
Ops
1
[
"
FunctionExpression
"
]
=
3
]
=
"
FunctionExpression
"
;
}
)
(
Ops
2
|
|
(
Ops
2
=
{
}
)
)
;
function
_classCallCheck
17
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
CompiledStaticTemplate
=
function
CompiledStaticTemplate
(
handle
)
{
_classCallCheck
17
(
this
CompiledStaticTemplate
)
;
this
.
handle
=
handle
;
}
;
var
CompiledDynamicTemplate
=
function
CompiledDynamicTemplate
(
handle
symbolTable
)
{
_classCallCheck
17
(
this
CompiledDynamicTemplate
)
;
this
.
handle
=
handle
;
this
.
symbolTable
=
symbolTable
;
}
;
var
_createClass
2
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_classCallCheck
20
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
compileLayout
(
compilable
env
)
{
var
builder
=
new
ComponentLayoutBuilder
(
env
)
;
compilable
.
compile
(
builder
)
;
return
builder
.
compile
(
)
;
}
var
ComponentLayoutBuilder
=
function
(
)
{
function
ComponentLayoutBuilder
(
env
)
{
_classCallCheck
20
(
this
ComponentLayoutBuilder
)
;
this
.
env
=
env
;
}
ComponentLayoutBuilder
.
prototype
.
wrapLayout
=
function
wrapLayout
(
layout
)
{
this
.
inner
=
new
WrappedBuilder
(
this
.
env
layout
)
;
}
;
ComponentLayoutBuilder
.
prototype
.
fromLayout
=
function
fromLayout
(
componentName
layout
)
{
this
.
inner
=
new
UnwrappedBuilder
(
this
.
env
componentName
layout
)
;
}
;
ComponentLayoutBuilder
.
prototype
.
compile
=
function
compile
(
)
{
return
this
.
inner
.
compile
(
)
;
}
;
_createClass
2
(
ComponentLayoutBuilder
[
{
key
:
'
tag
'
get
:
function
(
)
{
return
this
.
inner
.
tag
;
}
}
{
key
:
'
attrs
'
get
:
function
(
)
{
return
this
.
inner
.
attrs
;
}
}
]
)
;
return
ComponentLayoutBuilder
;
}
(
)
;
var
WrappedBuilder
=
function
(
)
{
function
WrappedBuilder
(
env
layout
)
{
_classCallCheck
20
(
this
WrappedBuilder
)
;
this
.
env
=
env
;
this
.
layout
=
layout
;
this
.
tag
=
new
ComponentTagBuilder
(
)
;
this
.
attrs
=
new
ComponentAttrsBuilder
(
)
;
}
WrappedBuilder
.
prototype
.
compile
=
function
compile
(
)
{
var
env
=
this
.
env
layout
=
this
.
layout
;
var
meta
=
{
templateMeta
:
layout
.
meta
symbols
:
layout
.
symbols
asPartial
:
false
}
;
var
dynamicTag
=
this
.
tag
.
getDynamic
(
)
;
var
staticTag
=
this
.
tag
.
getStatic
(
)
;
var
b
=
builder
(
env
meta
)
;
b
.
startLabels
(
)
;
if
(
dynamicTag
)
{
b
.
fetch
(
Register
.
s1
)
;
expr
(
dynamicTag
b
)
;
b
.
dup
(
)
;
b
.
load
(
Register
.
s1
)
;
b
.
test
(
'
simple
'
)
;
b
.
jumpUnless
(
'
BODY
'
)
;
b
.
fetch
(
Register
.
s1
)
;
b
.
pushComponentOperations
(
)
;
b
.
openDynamicElement
(
)
;
}
else
if
(
staticTag
)
{
b
.
pushComponentOperations
(
)
;
b
.
openElementWithOperations
(
staticTag
)
;
}
if
(
dynamicTag
|
|
staticTag
)
{
b
.
didCreateElement
(
Register
.
s0
)
;
var
attrs
=
this
.
attrs
.
buffer
;
for
(
var
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
compileStatement
(
attrs
[
i
]
b
)
;
}
b
.
flushElement
(
)
;
}
b
.
label
(
'
BODY
'
)
;
b
.
invokeStatic
(
layout
.
asBlock
(
)
)
;
if
(
dynamicTag
)
{
b
.
fetch
(
Register
.
s1
)
;
b
.
test
(
'
simple
'
)
;
b
.
jumpUnless
(
'
END
'
)
;
b
.
closeElement
(
)
;
}
else
if
(
staticTag
)
{
b
.
closeElement
(
)
;
}
b
.
label
(
'
END
'
)
;
b
.
didRenderLayout
(
Register
.
s0
)
;
if
(
dynamicTag
)
{
b
.
load
(
Register
.
s1
)
;
}
b
.
stopLabels
(
)
;
var
start
=
b
.
start
;
var
end
=
b
.
finalize
(
)
;
return
new
CompiledDynamicTemplate
(
start
{
meta
:
meta
hasEval
:
layout
.
hasEval
symbols
:
layout
.
symbols
.
concat
(
[
ATTRS_BLOCK
]
)
}
)
;
}
;
return
WrappedBuilder
;
}
(
)
;
var
UnwrappedBuilder
=
function
(
)
{
function
UnwrappedBuilder
(
env
componentName
layout
)
{
_classCallCheck
20
(
this
UnwrappedBuilder
)
;
this
.
env
=
env
;
this
.
componentName
=
componentName
;
this
.
layout
=
layout
;
this
.
attrs
=
new
ComponentAttrsBuilder
(
)
;
}
UnwrappedBuilder
.
prototype
.
compile
=
function
compile
(
)
{
var
env
=
this
.
env
layout
=
this
.
layout
;
return
layout
.
asLayout
(
this
.
componentName
this
.
attrs
.
buffer
)
.
compileDynamic
(
env
)
;
}
;
_createClass
2
(
UnwrappedBuilder
[
{
key
:
'
tag
'
get
:
function
(
)
{
throw
new
Error
(
'
BUG
:
Cannot
call
tag
on
an
UnwrappedBuilder
'
)
;
}
}
]
)
;
return
UnwrappedBuilder
;
}
(
)
;
var
ComponentTagBuilder
=
function
(
)
{
function
ComponentTagBuilder
(
)
{
_classCallCheck
20
(
this
ComponentTagBuilder
)
;
this
.
isDynamic
=
null
;
this
.
isStatic
=
null
;
this
.
staticTagName
=
null
;
this
.
dynamicTagName
=
null
;
}
ComponentTagBuilder
.
prototype
.
getDynamic
=
function
getDynamic
(
)
{
if
(
this
.
isDynamic
)
{
return
this
.
dynamicTagName
;
}
}
;
ComponentTagBuilder
.
prototype
.
getStatic
=
function
getStatic
(
)
{
if
(
this
.
isStatic
)
{
return
this
.
staticTagName
;
}
}
;
ComponentTagBuilder
.
prototype
.
static
=
function
_static
(
tagName
)
{
this
.
isStatic
=
true
;
this
.
staticTagName
=
tagName
;
}
;
ComponentTagBuilder
.
prototype
.
dynamic
=
function
dynamic
(
tagName
)
{
this
.
isDynamic
=
true
;
this
.
dynamicTagName
=
[
_wireFormat
.
Ops
.
ClientSideExpression
Ops
2
.
FunctionExpression
tagName
]
;
}
;
return
ComponentTagBuilder
;
}
(
)
;
var
ComponentAttrsBuilder
=
function
(
)
{
function
ComponentAttrsBuilder
(
)
{
_classCallCheck
20
(
this
ComponentAttrsBuilder
)
;
this
.
buffer
=
[
]
;
}
ComponentAttrsBuilder
.
prototype
.
static
=
function
_static
(
name
value
)
{
this
.
buffer
.
push
(
[
_wireFormat
.
Ops
.
StaticAttr
name
value
null
]
)
;
}
;
ComponentAttrsBuilder
.
prototype
.
dynamic
=
function
dynamic
(
name
value
)
{
this
.
buffer
.
push
(
[
_wireFormat
.
Ops
.
DynamicAttr
name
[
_wireFormat
.
Ops
.
ClientSideExpression
Ops
2
.
FunctionExpression
value
]
null
]
)
;
}
;
return
ComponentAttrsBuilder
;
}
(
)
;
var
ComponentBuilder
=
function
(
)
{
function
ComponentBuilder
(
builder
)
{
_classCallCheck
20
(
this
ComponentBuilder
)
;
this
.
builder
=
builder
;
this
.
env
=
builder
.
env
;
}
ComponentBuilder
.
prototype
.
static
=
function
_static
(
definition
args
)
{
var
params
=
args
[
0
]
hash
=
args
[
1
]
_default
=
args
[
2
]
inverse
=
args
[
3
]
;
var
builder
=
this
.
builder
;
builder
.
pushComponentManager
(
definition
)
;
builder
.
invokeComponent
(
null
params
hash
_default
inverse
)
;
}
;
ComponentBuilder
.
prototype
.
dynamic
=
function
dynamic
(
definitionArgs
getDefinition
args
)
{
var
params
=
args
[
0
]
hash
=
args
[
1
]
block
=
args
[
2
]
inverse
=
args
[
3
]
;
var
builder
=
this
.
builder
;
if
(
!
definitionArgs
|
|
definitionArgs
.
length
=
=
=
0
)
{
throw
new
Error
(
"
Dynamic
syntax
without
an
argument
"
)
;
}
var
meta
=
this
.
builder
.
meta
.
templateMeta
;
function
helper
(
vm
a
)
{
return
getDefinition
(
vm
a
meta
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
builder
.
compileArgs
(
definitionArgs
[
0
]
definitionArgs
[
1
]
true
)
;
builder
.
helper
(
helper
)
;
builder
.
dup
(
)
;
builder
.
test
(
'
simple
'
)
;
builder
.
enter
(
2
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
pushDynamicComponentManager
(
)
;
builder
.
invokeComponent
(
null
params
hash
block
inverse
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
;
return
ComponentBuilder
;
}
(
)
;
function
builder
(
env
meta
)
{
return
new
OpcodeBuilder
(
env
meta
)
;
}
function
_classCallCheck
21
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
RawInlineBlock
=
function
(
)
{
function
RawInlineBlock
(
meta
statements
parameters
)
{
_classCallCheck
21
(
this
RawInlineBlock
)
;
this
.
meta
=
meta
;
this
.
statements
=
statements
;
this
.
parameters
=
parameters
;
}
RawInlineBlock
.
prototype
.
scan
=
function
scan
(
)
{
return
new
CompilableTemplate
(
this
.
statements
{
parameters
:
this
.
parameters
meta
:
this
.
meta
}
)
;
}
;
return
RawInlineBlock
;
}
(
)
;
var
_createClass
1
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_defaults
9
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
9
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
9
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
9
(
subClass
superClass
)
;
}
function
_classCallCheck
19
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Labels
=
function
(
)
{
function
Labels
(
)
{
_classCallCheck
19
(
this
Labels
)
;
this
.
labels
=
(
0
_util
.
dict
)
(
)
;
this
.
targets
=
[
]
;
}
Labels
.
prototype
.
label
=
function
label
(
name
index
)
{
this
.
labels
[
name
]
=
index
;
}
;
Labels
.
prototype
.
target
=
function
target
(
at
Target
_target
)
{
this
.
targets
.
push
(
{
at
:
at
Target
:
Target
target
:
_target
}
)
;
}
;
Labels
.
prototype
.
patch
=
function
patch
(
program
)
{
var
targets
=
this
.
targets
labels
=
this
.
labels
;
for
(
var
i
=
0
;
i
<
targets
.
length
;
i
+
+
)
{
var
_targets
i
=
targets
[
i
]
at
=
_targets
i
.
at
target
=
_targets
i
.
target
;
var
goto
=
labels
[
target
]
-
at
;
program
.
heap
.
setbyaddr
(
at
+
1
goto
)
;
}
}
;
return
Labels
;
}
(
)
;
var
BasicOpcodeBuilder
=
function
(
)
{
function
BasicOpcodeBuilder
(
env
meta
program
)
{
_classCallCheck
19
(
this
BasicOpcodeBuilder
)
;
this
.
env
=
env
;
this
.
meta
=
meta
;
this
.
program
=
program
;
this
.
labelsStack
=
new
_util
.
Stack
(
)
;
this
.
constants
=
program
.
constants
;
this
.
heap
=
program
.
heap
;
this
.
start
=
this
.
heap
.
malloc
(
)
;
}
BasicOpcodeBuilder
.
prototype
.
upvars
=
function
upvars
(
count
)
{
return
(
0
_util
.
fillNulls
)
(
count
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
reserve
=
function
reserve
(
name
)
{
this
.
push
(
name
0
0
0
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
push
=
function
push
(
name
)
{
var
op1
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
0
;
var
op2
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
0
;
var
op3
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
0
;
this
.
heap
.
push
(
name
)
;
this
.
heap
.
push
(
op1
)
;
this
.
heap
.
push
(
op2
)
;
this
.
heap
.
push
(
op3
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
finalize
=
function
finalize
(
)
{
this
.
push
(
22
)
;
this
.
heap
.
finishMalloc
(
this
.
start
)
;
return
this
.
start
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushArgs
=
function
pushArgs
(
synthetic
)
{
this
.
push
(
58
synthetic
=
=
=
true
?
1
:
0
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
startLabels
=
function
startLabels
(
)
{
this
.
labelsStack
.
push
(
new
Labels
(
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
stopLabels
=
function
stopLabels
(
)
{
var
label
=
this
.
labelsStack
.
pop
(
)
;
label
.
patch
(
this
.
program
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushComponentManager
=
function
pushComponentManager
(
definition
)
{
this
.
push
(
56
this
.
other
(
definition
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushDynamicComponentManager
=
function
pushDynamicComponentManager
(
)
{
this
.
push
(
57
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
prepareArgs
=
function
prepareArgs
(
state
)
{
this
.
push
(
59
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
createComponent
=
function
createComponent
(
state
hasDefault
hasInverse
)
{
var
flag
=
(
hasDefault
=
=
=
true
?
1
:
0
)
|
(
hasInverse
=
=
=
true
?
1
:
0
)
<
<
1
;
this
.
push
(
60
flag
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
registerComponentDestructor
=
function
registerComponentDestructor
(
state
)
{
this
.
push
(
61
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
beginComponentTransaction
=
function
beginComponentTransaction
(
)
{
this
.
push
(
65
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
commitComponentTransaction
=
function
commitComponentTransaction
(
)
{
this
.
push
(
66
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushComponentOperations
=
function
pushComponentOperations
(
)
{
this
.
push
(
62
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getComponentSelf
=
function
getComponentSelf
(
state
)
{
this
.
push
(
63
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getComponentLayout
=
function
getComponentLayout
(
state
)
{
this
.
push
(
64
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
didCreateElement
=
function
didCreateElement
(
state
)
{
this
.
push
(
67
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
didRenderLayout
=
function
didRenderLayout
(
state
)
{
this
.
push
(
68
state
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getPartialTemplate
=
function
getPartialTemplate
(
)
{
this
.
push
(
69
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
resolveMaybeLocal
=
function
resolveMaybeLocal
(
name
)
{
this
.
push
(
70
this
.
string
(
name
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
debugger
=
function
_debugger
(
symbols
evalInfo
)
{
this
.
push
(
71
this
.
constants
.
other
(
symbols
)
this
.
constants
.
array
(
evalInfo
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
dynamicContent
=
function
dynamicContent
(
Opcode
)
{
this
.
push
(
26
this
.
other
(
Opcode
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
cautiousAppend
=
function
cautiousAppend
(
)
{
this
.
dynamicContent
(
new
OptimizedCautiousAppendOpcode
(
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
trustingAppend
=
function
trustingAppend
(
)
{
this
.
dynamicContent
(
new
OptimizedTrustingAppendOpcode
(
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
text
=
function
text
(
_text
)
{
this
.
push
(
24
this
.
constants
.
string
(
_text
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
openPrimitiveElement
=
function
openPrimitiveElement
(
tag
)
{
this
.
push
(
27
this
.
constants
.
string
(
tag
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
openElementWithOperations
=
function
openElementWithOperations
(
tag
)
{
this
.
push
(
28
this
.
constants
.
string
(
tag
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
openDynamicElement
=
function
openDynamicElement
(
)
{
this
.
push
(
29
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
flushElement
=
function
flushElement
(
)
{
this
.
push
(
33
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
closeElement
=
function
closeElement
(
)
{
this
.
push
(
34
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
staticAttr
=
function
staticAttr
(
_name
_namespace
_value
)
{
var
name
=
this
.
constants
.
string
(
_name
)
;
var
namespace
=
_namespace
?
this
.
constants
.
string
(
_namespace
)
:
0
;
var
value
=
this
.
constants
.
string
(
_value
)
;
this
.
push
(
30
name
value
namespace
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
dynamicAttrNS
=
function
dynamicAttrNS
(
_name
_namespace
trusting
)
{
var
name
=
this
.
constants
.
string
(
_name
)
;
var
namespace
=
this
.
constants
.
string
(
_namespace
)
;
this
.
push
(
32
name
namespace
trusting
=
=
=
true
?
1
:
0
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
dynamicAttr
=
function
dynamicAttr
(
_name
trusting
)
{
var
name
=
this
.
constants
.
string
(
_name
)
;
this
.
push
(
31
name
trusting
=
=
=
true
?
1
:
0
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
comment
=
function
comment
(
_comment
)
{
var
comment
=
this
.
constants
.
string
(
_comment
)
;
this
.
push
(
25
comment
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
modifier
=
function
modifier
(
_definition
)
{
this
.
push
(
35
this
.
other
(
_definition
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
putIterator
=
function
putIterator
(
)
{
this
.
push
(
54
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
enterList
=
function
enterList
(
start
)
{
this
.
reserve
(
52
)
;
this
.
labels
.
target
(
this
.
pos
52
start
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
exitList
=
function
exitList
(
)
{
this
.
push
(
53
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
iterate
=
function
iterate
(
breaks
)
{
this
.
reserve
(
55
)
;
this
.
labels
.
target
(
this
.
pos
55
breaks
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
setVariable
=
function
setVariable
(
symbol
)
{
this
.
push
(
4
symbol
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getVariable
=
function
getVariable
(
symbol
)
{
this
.
push
(
5
symbol
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getProperty
=
function
getProperty
(
key
)
{
this
.
push
(
6
this
.
string
(
key
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
getBlock
=
function
getBlock
(
symbol
)
{
this
.
push
(
8
symbol
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
hasBlock
=
function
hasBlock
(
symbol
)
{
this
.
push
(
9
symbol
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
hasBlockParams
=
function
hasBlockParams
(
symbol
)
{
this
.
push
(
10
symbol
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
concat
=
function
concat
(
size
)
{
this
.
push
(
11
size
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
function
=
function
_function
(
f
)
{
this
.
push
(
2
this
.
func
(
f
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
load
=
function
load
(
register
)
{
this
.
push
(
17
register
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
fetch
=
function
fetch
(
register
)
{
this
.
push
(
18
register
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
dup
=
function
dup
(
)
{
var
register
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
Register
.
sp
;
var
offset
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
0
;
return
this
.
push
(
15
register
offset
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pop
=
function
pop
(
)
{
var
count
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
1
;
return
this
.
push
(
16
count
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushRemoteElement
=
function
pushRemoteElement
(
)
{
this
.
push
(
36
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
popRemoteElement
=
function
popRemoteElement
(
)
{
this
.
push
(
37
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
label
=
function
label
(
name
)
{
this
.
labels
.
label
(
name
this
.
nextPos
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushRootScope
=
function
pushRootScope
(
symbols
bindCallerScope
)
{
this
.
push
(
19
symbols
bindCallerScope
?
1
:
0
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushChildScope
=
function
pushChildScope
(
)
{
this
.
push
(
20
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
popScope
=
function
popScope
(
)
{
this
.
push
(
21
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
returnTo
=
function
returnTo
(
label
)
{
this
.
reserve
(
23
)
;
this
.
labels
.
target
(
this
.
pos
23
label
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushDynamicScope
=
function
pushDynamicScope
(
)
{
this
.
push
(
39
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
popDynamicScope
=
function
popDynamicScope
(
)
{
this
.
push
(
40
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushImmediate
=
function
pushImmediate
(
value
)
{
this
.
push
(
13
this
.
other
(
value
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
primitive
=
function
primitive
(
_primitive
)
{
var
flag
=
0
;
var
primitive
=
void
0
;
switch
(
typeof
_primitive
)
{
case
'
number
'
:
if
(
_primitive
%
1
=
=
=
0
&
&
_primitive
>
0
)
{
primitive
=
_primitive
;
}
else
{
primitive
=
this
.
float
(
_primitive
)
;
flag
=
1
;
}
break
;
case
'
string
'
:
primitive
=
this
.
string
(
_primitive
)
;
flag
=
2
;
break
;
case
'
boolean
'
:
primitive
=
_primitive
|
0
;
flag
=
3
;
break
;
case
'
object
'
:
primitive
=
2
;
flag
=
3
;
break
;
case
'
undefined
'
:
primitive
=
3
;
flag
=
3
;
break
;
default
:
throw
new
Error
(
'
Invalid
primitive
passed
to
pushPrimitive
'
)
;
}
this
.
push
(
14
flag
<
<
30
|
primitive
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
helper
=
function
helper
(
func
)
{
this
.
push
(
1
this
.
func
(
func
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushBlock
=
function
pushBlock
(
block
)
{
this
.
push
(
7
this
.
block
(
block
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
bindDynamicScope
=
function
bindDynamicScope
(
_names
)
{
this
.
push
(
38
this
.
names
(
_names
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
enter
=
function
enter
(
args
)
{
this
.
push
(
49
args
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
exit
=
function
exit
(
)
{
this
.
push
(
50
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
return
=
function
_return
(
)
{
this
.
push
(
22
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
pushFrame
=
function
pushFrame
(
)
{
this
.
push
(
47
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
popFrame
=
function
popFrame
(
)
{
this
.
push
(
48
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
compileDynamicBlock
=
function
compileDynamicBlock
(
)
{
this
.
push
(
41
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
invokeDynamic
=
function
invokeDynamic
(
invoker
)
{
this
.
push
(
43
this
.
other
(
invoker
)
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
invokeStatic
=
function
invokeStatic
(
block
)
{
var
callerCount
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
0
;
var
parameters
=
block
.
symbolTable
.
parameters
;
var
calleeCount
=
parameters
.
length
;
var
count
=
Math
.
min
(
callerCount
calleeCount
)
;
this
.
pushFrame
(
)
;
if
(
count
)
{
this
.
pushChildScope
(
)
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
{
this
.
dup
(
Register
.
fp
callerCount
-
i
)
;
this
.
setVariable
(
parameters
[
i
]
)
;
}
}
var
_block
=
this
.
constants
.
block
(
block
)
;
this
.
push
(
42
_block
)
;
if
(
count
)
{
this
.
popScope
(
)
;
}
this
.
popFrame
(
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
test
=
function
test
(
testFunc
)
{
var
_func
=
void
0
;
if
(
testFunc
=
=
=
'
const
'
)
{
_func
=
ConstTest
;
}
else
if
(
testFunc
=
=
=
'
simple
'
)
{
_func
=
SimpleTest
;
}
else
if
(
testFunc
=
=
=
'
environment
'
)
{
_func
=
EnvironmentTest
;
}
else
if
(
typeof
testFunc
=
=
=
'
function
'
)
{
_func
=
testFunc
;
}
else
{
throw
new
Error
(
'
unreachable
'
)
;
}
var
func
=
this
.
constants
.
function
(
_func
)
;
this
.
push
(
51
func
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
jump
=
function
jump
(
target
)
{
this
.
reserve
(
44
)
;
this
.
labels
.
target
(
this
.
pos
44
target
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
jumpIf
=
function
jumpIf
(
target
)
{
this
.
reserve
(
45
)
;
this
.
labels
.
target
(
this
.
pos
45
target
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
jumpUnless
=
function
jumpUnless
(
target
)
{
this
.
reserve
(
46
)
;
this
.
labels
.
target
(
this
.
pos
46
target
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
string
=
function
string
(
_string
)
{
return
this
.
constants
.
string
(
_string
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
float
=
function
float
(
num
)
{
return
this
.
constants
.
float
(
num
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
names
=
function
names
(
_names
)
{
var
names
=
[
]
;
for
(
var
i
=
0
;
i
<
_names
.
length
;
i
+
+
)
{
var
n
=
_names
[
i
]
;
names
[
i
]
=
this
.
constants
.
string
(
n
)
;
}
return
this
.
constants
.
array
(
names
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
symbols
=
function
symbols
(
_symbols
)
{
return
this
.
constants
.
array
(
_symbols
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
other
=
function
other
(
value
)
{
return
this
.
constants
.
other
(
value
)
;
}
;
BasicOpcodeBuilder
.
prototype
.
block
=
function
block
(
_block2
)
{
return
_block2
?
this
.
constants
.
block
(
_block2
)
:
0
;
}
;
BasicOpcodeBuilder
.
prototype
.
func
=
function
func
(
_func2
)
{
return
this
.
constants
.
function
(
_func2
)
;
}
;
_createClass
1
(
BasicOpcodeBuilder
[
{
key
:
'
pos
'
get
:
function
(
)
{
return
(
0
_util
.
typePos
)
(
this
.
heap
.
size
(
)
)
;
}
}
{
key
:
'
nextPos
'
get
:
function
(
)
{
return
this
.
heap
.
size
(
)
;
}
}
{
key
:
'
labels
'
get
:
function
(
)
{
return
this
.
labelsStack
.
current
;
}
}
]
)
;
return
BasicOpcodeBuilder
;
}
(
)
;
function
isCompilableExpression
(
expr
1
)
{
return
typeof
expr
1
=
=
=
'
object
'
&
&
expr
1
!
=
=
null
&
&
typeof
expr
1
.
compile
=
=
=
'
function
'
;
}
var
OpcodeBuilder
=
function
(
_BasicOpcodeBuilder
)
{
_inherits
9
(
OpcodeBuilder
_BasicOpcodeBuilder
)
;
function
OpcodeBuilder
(
env
meta
)
{
var
program
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
env
.
program
;
_classCallCheck
19
(
this
OpcodeBuilder
)
;
var
_this
=
_possibleConstructorReturn
9
(
this
_BasicOpcodeBuilder
.
call
(
this
env
meta
program
)
)
;
_this
.
component
=
new
ComponentBuilder
(
_this
)
;
return
_this
;
}
OpcodeBuilder
.
prototype
.
compileArgs
=
function
compileArgs
(
params
hash
synthetic
)
{
var
positional
=
0
;
if
(
params
)
{
for
(
var
i
=
0
;
i
<
params
.
length
;
i
+
+
)
{
expr
(
params
[
i
]
this
)
;
}
positional
=
params
.
length
;
}
this
.
pushImmediate
(
positional
)
;
var
names
=
_util
.
EMPTY_ARRAY
;
if
(
hash
)
{
names
=
hash
[
0
]
;
var
val
=
hash
[
1
]
;
for
(
var
_i
=
0
;
_i
<
val
.
length
;
_i
+
+
)
{
expr
(
val
[
_i
]
this
)
;
}
}
this
.
pushImmediate
(
names
)
;
this
.
pushArgs
(
synthetic
)
;
}
;
OpcodeBuilder
.
prototype
.
compile
=
function
compile
(
expr
1
)
{
if
(
isCompilableExpression
(
expr
1
)
)
{
return
expr
1
.
compile
(
this
)
;
}
else
{
return
expr
1
;
}
}
;
OpcodeBuilder
.
prototype
.
guardedAppend
=
function
guardedAppend
(
expression
trusting
)
{
this
.
startLabels
(
)
;
this
.
pushFrame
(
)
;
this
.
returnTo
(
'
END
'
)
;
expr
(
expression
this
)
;
this
.
dup
(
)
;
this
.
test
(
function
(
reference
1
)
{
return
IsComponentDefinitionReference
.
create
(
reference
1
)
;
}
)
;
this
.
enter
(
2
)
;
this
.
jumpUnless
(
'
ELSE
'
)
;
this
.
pushDynamicComponentManager
(
)
;
this
.
invokeComponent
(
null
null
null
null
null
)
;
this
.
exit
(
)
;
this
.
return
(
)
;
this
.
label
(
'
ELSE
'
)
;
if
(
trusting
)
{
this
.
trustingAppend
(
)
;
}
else
{
this
.
cautiousAppend
(
)
;
}
this
.
exit
(
)
;
this
.
return
(
)
;
this
.
label
(
'
END
'
)
;
this
.
popFrame
(
)
;
this
.
stopLabels
(
)
;
}
;
OpcodeBuilder
.
prototype
.
invokeComponent
=
function
invokeComponent
(
attrs
params
hash
block
)
{
var
inverse
=
arguments
.
length
>
4
&
&
arguments
[
4
]
!
=
=
undefined
?
arguments
[
4
]
:
null
;
this
.
fetch
(
Register
.
s0
)
;
this
.
dup
(
Register
.
sp
1
)
;
this
.
load
(
Register
.
s0
)
;
this
.
pushBlock
(
block
)
;
this
.
pushBlock
(
inverse
)
;
this
.
compileArgs
(
params
hash
false
)
;
this
.
prepareArgs
(
Register
.
s0
)
;
this
.
beginComponentTransaction
(
)
;
this
.
pushDynamicScope
(
)
;
this
.
createComponent
(
Register
.
s0
block
!
=
=
null
inverse
!
=
=
null
)
;
this
.
registerComponentDestructor
(
Register
.
s0
)
;
this
.
getComponentSelf
(
Register
.
s0
)
;
this
.
getComponentLayout
(
Register
.
s0
)
;
this
.
invokeDynamic
(
new
InvokeDynamicLayout
(
attrs
&
&
attrs
.
scan
(
)
)
)
;
this
.
popFrame
(
)
;
this
.
popScope
(
)
;
this
.
popDynamicScope
(
)
;
this
.
commitComponentTransaction
(
)
;
this
.
load
(
Register
.
s0
)
;
}
;
OpcodeBuilder
.
prototype
.
template
=
function
template
(
block
)
{
if
(
!
block
)
return
null
;
return
new
RawInlineBlock
(
this
.
meta
block
.
statements
block
.
parameters
)
;
}
;
return
OpcodeBuilder
;
}
(
BasicOpcodeBuilder
)
;
function
_classCallCheck
18
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Ops
3
=
_wireFormat
.
Ops
;
var
ATTRS_BLOCK
=
'
&
attrs
'
;
var
Compilers
=
function
(
)
{
function
Compilers
(
)
{
var
offset
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
0
;
_classCallCheck
18
(
this
Compilers
)
;
this
.
offset
=
offset
;
this
.
names
=
(
0
_util
.
dict
)
(
)
;
this
.
funcs
=
[
]
;
}
Compilers
.
prototype
.
add
=
function
add
(
name
func
)
{
this
.
funcs
.
push
(
func
)
;
this
.
names
[
name
]
=
this
.
funcs
.
length
-
1
;
}
;
Compilers
.
prototype
.
compile
=
function
compile
(
sexp
builder
)
{
var
name
=
sexp
[
this
.
offset
]
;
var
index
=
this
.
names
[
name
]
;
var
func
=
this
.
funcs
[
index
]
;
(
0
_util
.
assert
)
(
!
!
func
'
expected
an
implementation
for
'
+
(
this
.
offset
=
=
=
0
?
Ops
3
[
sexp
[
0
]
]
:
Ops
2
[
sexp
[
1
]
]
)
)
;
func
(
sexp
builder
)
;
}
;
return
Compilers
;
}
(
)
;
var
STATEMENTS
=
new
Compilers
(
)
;
var
CLIENT_SIDE
=
new
Compilers
(
1
)
;
STATEMENTS
.
add
(
Ops
3
.
Text
function
(
sexp
builder
)
{
builder
.
text
(
sexp
[
1
]
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
Comment
function
(
sexp
builder
)
{
builder
.
comment
(
sexp
[
1
]
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
CloseElement
function
(
_sexp
builder
)
{
builder
.
closeElement
(
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
FlushElement
function
(
_sexp
builder
)
{
builder
.
flushElement
(
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
Modifier
function
(
sexp
builder
)
{
var
env
=
builder
.
env
meta
=
builder
.
meta
;
var
name
=
sexp
[
1
]
params
=
sexp
[
2
]
hash
=
sexp
[
3
]
;
if
(
env
.
hasModifier
(
name
meta
.
templateMeta
)
)
{
builder
.
compileArgs
(
params
hash
true
)
;
builder
.
modifier
(
env
.
lookupModifier
(
name
meta
.
templateMeta
)
)
;
}
else
{
throw
new
Error
(
'
Compile
Error
'
+
name
+
'
is
not
a
modifier
:
Helpers
may
not
be
used
in
the
element
form
.
'
)
;
}
}
)
;
STATEMENTS
.
add
(
Ops
3
.
StaticAttr
function
(
sexp
builder
)
{
var
name
=
sexp
[
1
]
value
=
sexp
[
2
]
namespace
=
sexp
[
3
]
;
builder
.
staticAttr
(
name
namespace
value
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
DynamicAttr
function
(
sexp
builder
)
{
dynamicAttr
(
sexp
false
builder
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
TrustingAttr
function
(
sexp
builder
)
{
dynamicAttr
(
sexp
true
builder
)
;
}
)
;
function
dynamicAttr
(
sexp
trusting
builder
)
{
var
name
=
sexp
[
1
]
value
=
sexp
[
2
]
namespace
=
sexp
[
3
]
;
expr
(
value
builder
)
;
if
(
namespace
)
{
builder
.
dynamicAttrNS
(
name
namespace
trusting
)
;
}
else
{
builder
.
dynamicAttr
(
name
trusting
)
;
}
}
STATEMENTS
.
add
(
Ops
3
.
OpenElement
function
(
sexp
builder
)
{
builder
.
openPrimitiveElement
(
sexp
[
1
]
)
;
}
)
;
CLIENT_SIDE
.
add
(
Ops
2
.
OpenComponentElement
function
(
sexp
builder
)
{
builder
.
pushComponentOperations
(
)
;
builder
.
openElementWithOperations
(
sexp
[
2
]
)
;
}
)
;
CLIENT_SIDE
.
add
(
Ops
2
.
DidCreateElement
function
(
_sexp
builder
)
{
builder
.
didCreateElement
(
Register
.
s0
)
;
}
)
;
CLIENT_SIDE
.
add
(
Ops
2
.
DidRenderLayout
function
(
_sexp
builder
)
{
builder
.
didRenderLayout
(
Register
.
s0
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
Append
function
(
sexp
builder
)
{
var
value
=
sexp
[
1
]
trusting
=
sexp
[
2
]
;
var
_builder
env
macros
=
builder
.
env
.
macros
(
)
inlines
=
_builder
env
macros
.
inlines
;
var
returned
=
inlines
.
compile
(
sexp
builder
)
|
|
value
;
if
(
returned
=
=
=
true
)
return
;
var
isGet
=
E
.
isGet
(
value
)
;
var
isMaybeLocal
=
E
.
isMaybeLocal
(
value
)
;
if
(
trusting
)
{
builder
.
guardedAppend
(
value
true
)
;
}
else
{
if
(
isGet
|
|
isMaybeLocal
)
{
builder
.
guardedAppend
(
value
false
)
;
}
else
{
expr
(
value
builder
)
;
builder
.
cautiousAppend
(
)
;
}
}
}
)
;
STATEMENTS
.
add
(
Ops
3
.
Block
function
(
sexp
builder
)
{
var
name
=
sexp
[
1
]
params
=
sexp
[
2
]
hash
=
sexp
[
3
]
_template
=
sexp
[
4
]
_inverse
=
sexp
[
5
]
;
var
template
=
builder
.
template
(
_template
)
;
var
inverse
=
builder
.
template
(
_inverse
)
;
var
templateBlock
=
template
&
&
template
.
scan
(
)
;
var
inverseBlock
=
inverse
&
&
inverse
.
scan
(
)
;
var
_builder
env
macros2
=
builder
.
env
.
macros
(
)
blocks
=
_builder
env
macros2
.
blocks
;
blocks
.
compile
(
name
params
hash
templateBlock
inverseBlock
builder
)
;
}
)
;
var
InvokeDynamicLayout
=
function
(
)
{
function
InvokeDynamicLayout
(
attrs
)
{
_classCallCheck
18
(
this
InvokeDynamicLayout
)
;
this
.
attrs
=
attrs
;
}
InvokeDynamicLayout
.
prototype
.
invoke
=
function
invoke
(
vm
layout
)
{
var
_layout
symbolTable
=
layout
.
symbolTable
symbols
=
_layout
symbolTable
.
symbols
hasEval
=
_layout
symbolTable
.
hasEval
;
var
stack
=
vm
.
stack
;
var
scope
=
vm
.
pushRootScope
(
symbols
.
length
+
1
true
)
;
scope
.
bindSelf
(
stack
.
pop
(
)
)
;
scope
.
bindBlock
(
symbols
.
indexOf
(
ATTRS_BLOCK
)
+
1
this
.
attrs
)
;
var
lookup
=
null
;
var
eval
=
-
1
;
if
(
hasEval
)
{
eval
=
symbols
.
indexOf
(
'
eval
'
)
+
1
;
lookup
=
(
0
_util
.
dict
)
(
)
;
}
var
callerNames
=
stack
.
pop
(
)
;
for
(
var
i
=
callerNames
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
symbol
=
symbols
.
indexOf
(
callerNames
[
i
]
)
;
var
value
=
stack
.
pop
(
)
;
if
(
symbol
!
=
=
-
1
)
scope
.
bindSymbol
(
symbol
+
1
value
)
;
if
(
hasEval
)
lookup
[
callerNames
[
i
]
]
=
value
;
}
var
numPositionalArgs
=
stack
.
pop
(
)
;
(
0
_util
.
assert
)
(
typeof
numPositionalArgs
=
=
=
'
number
'
'
[
BUG
]
Incorrect
value
of
positional
argument
count
found
during
invoke
-
dynamic
-
layout
.
'
)
;
stack
.
pop
(
numPositionalArgs
)
;
var
inverseSymbol
=
symbols
.
indexOf
(
'
&
inverse
'
)
;
var
inverse
=
stack
.
pop
(
)
;
if
(
inverseSymbol
!
=
=
-
1
)
{
scope
.
bindBlock
(
inverseSymbol
+
1
inverse
)
;
}
if
(
lookup
)
lookup
[
'
&
inverse
'
]
=
inverse
;
var
defaultSymbol
=
symbols
.
indexOf
(
'
&
default
'
)
;
var
defaultBlock
=
stack
.
pop
(
)
;
if
(
defaultSymbol
!
=
=
-
1
)
{
scope
.
bindBlock
(
defaultSymbol
+
1
defaultBlock
)
;
}
if
(
lookup
)
lookup
[
'
&
default
'
]
=
defaultBlock
;
if
(
lookup
)
scope
.
bindEvalScope
(
lookup
)
;
vm
.
pushFrame
(
)
;
vm
.
call
(
layout
.
handle
)
;
}
;
InvokeDynamicLayout
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
GlimmerDebug
:
'
<
invoke
-
dynamic
-
layout
>
'
}
;
}
;
return
InvokeDynamicLayout
;
}
(
)
;
STATEMENTS
.
add
(
Ops
3
.
Component
function
(
sexp
builder
)
{
var
tag
=
sexp
[
1
]
attrs
=
sexp
[
2
]
args
=
sexp
[
3
]
block
=
sexp
[
4
]
;
if
(
builder
.
env
.
hasComponentDefinition
(
tag
builder
.
meta
.
templateMeta
)
)
{
var
child
=
builder
.
template
(
block
)
;
var
attrsBlock
=
new
RawInlineBlock
(
builder
.
meta
attrs
_util
.
EMPTY_ARRAY
)
;
var
definition
=
builder
.
env
.
getComponentDefinition
(
tag
builder
.
meta
.
templateMeta
)
;
builder
.
pushComponentManager
(
definition
)
;
builder
.
invokeComponent
(
attrsBlock
null
args
child
&
&
child
.
scan
(
)
)
;
}
else
if
(
block
&
&
block
.
parameters
.
length
)
{
throw
new
Error
(
'
Compile
Error
:
Cannot
find
component
'
+
tag
)
;
}
else
{
builder
.
openPrimitiveElement
(
tag
)
;
for
(
var
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
STATEMENTS
.
compile
(
attrs
[
i
]
builder
)
;
}
builder
.
flushElement
(
)
;
if
(
block
)
{
var
stmts
=
block
.
statements
;
for
(
var
_i
=
0
;
_i
<
stmts
.
length
;
_i
+
+
)
{
STATEMENTS
.
compile
(
stmts
[
_i
]
builder
)
;
}
}
builder
.
closeElement
(
)
;
}
}
)
;
var
PartialInvoker
=
function
(
)
{
function
PartialInvoker
(
outerSymbols
evalInfo
)
{
_classCallCheck
18
(
this
PartialInvoker
)
;
this
.
outerSymbols
=
outerSymbols
;
this
.
evalInfo
=
evalInfo
;
}
PartialInvoker
.
prototype
.
invoke
=
function
invoke
(
vm
_partial
)
{
var
partial
=
_partial
;
var
partialSymbols
=
partial
.
symbolTable
.
symbols
;
var
outerScope
=
vm
.
scope
(
)
;
var
evalScope
=
outerScope
.
getEvalScope
(
)
;
var
partialScope
=
vm
.
pushRootScope
(
partialSymbols
.
length
false
)
;
partialScope
.
bindCallerScope
(
outerScope
.
getCallerScope
(
)
)
;
partialScope
.
bindEvalScope
(
evalScope
)
;
partialScope
.
bindSelf
(
outerScope
.
getSelf
(
)
)
;
var
evalInfo
=
this
.
evalInfo
outerSymbols
=
this
.
outerSymbols
;
var
locals
=
Object
.
create
(
outerScope
.
getPartialMap
(
)
)
;
for
(
var
i
=
0
;
i
<
evalInfo
.
length
;
i
+
+
)
{
var
slot
=
evalInfo
[
i
]
;
var
name
=
outerSymbols
[
slot
-
1
]
;
var
ref
=
outerScope
.
getSymbol
(
slot
)
;
locals
[
name
]
=
ref
;
}
if
(
evalScope
)
{
for
(
var
_i2
=
0
;
_i2
<
partialSymbols
.
length
;
_i2
+
+
)
{
var
_name
=
partialSymbols
[
_i2
]
;
var
symbol
=
_i2
+
1
;
var
value
=
evalScope
[
_name
]
;
if
(
value
!
=
=
undefined
)
partialScope
.
bind
(
symbol
value
)
;
}
}
partialScope
.
bindPartialMap
(
locals
)
;
vm
.
pushFrame
(
)
;
vm
.
call
(
partial
.
handle
)
;
}
;
return
PartialInvoker
;
}
(
)
;
STATEMENTS
.
add
(
Ops
3
.
Partial
function
(
sexp
builder
)
{
var
name
=
sexp
[
1
]
evalInfo
=
sexp
[
2
]
;
var
_builder
meta
=
builder
.
meta
templateMeta
=
_builder
meta
.
templateMeta
symbols
=
_builder
meta
.
symbols
;
function
helper
(
vm
args
)
{
var
env
=
vm
.
env
;
var
nameRef
=
args
.
positional
.
at
(
0
)
;
return
(
0
_reference2
.
map
)
(
nameRef
function
(
n
)
{
if
(
typeof
n
=
=
=
'
string
'
&
&
n
)
{
if
(
!
env
.
hasPartial
(
n
templateMeta
)
)
{
throw
new
Error
(
'
Could
not
find
a
partial
named
"
'
+
n
+
'
"
'
)
;
}
return
env
.
lookupPartial
(
n
templateMeta
)
;
}
else
if
(
n
)
{
throw
new
Error
(
'
Could
not
find
a
partial
named
"
'
+
String
(
n
)
+
'
"
'
)
;
}
else
{
return
null
;
}
}
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
expr
(
name
builder
)
;
builder
.
pushImmediate
(
1
)
;
builder
.
pushImmediate
(
_util
.
EMPTY_ARRAY
)
;
builder
.
pushArgs
(
true
)
;
builder
.
helper
(
helper
)
;
builder
.
dup
(
)
;
builder
.
test
(
'
simple
'
)
;
builder
.
enter
(
2
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
getPartialTemplate
(
)
;
builder
.
compileDynamicBlock
(
)
;
builder
.
invokeDynamic
(
new
PartialInvoker
(
symbols
evalInfo
)
)
;
builder
.
popScope
(
)
;
builder
.
popFrame
(
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
var
InvokeDynamicYield
=
function
(
)
{
function
InvokeDynamicYield
(
callerCount
)
{
_classCallCheck
18
(
this
InvokeDynamicYield
)
;
this
.
callerCount
=
callerCount
;
}
InvokeDynamicYield
.
prototype
.
invoke
=
function
invoke
(
vm
block
)
{
var
callerCount
=
this
.
callerCount
;
var
stack
=
vm
.
stack
;
if
(
!
block
)
{
vm
.
pushFrame
(
)
;
vm
.
pushCallerScope
(
)
;
return
;
}
var
table
=
block
.
symbolTable
;
var
locals
=
table
.
parameters
;
var
calleeCount
=
locals
?
locals
.
length
:
0
;
var
count
=
Math
.
min
(
callerCount
calleeCount
)
;
vm
.
pushFrame
(
)
;
vm
.
pushCallerScope
(
calleeCount
>
0
)
;
var
scope
=
vm
.
scope
(
)
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
{
scope
.
bindSymbol
(
locals
[
i
]
stack
.
fromBase
(
callerCount
-
i
)
)
;
}
vm
.
call
(
block
.
handle
)
;
}
;
InvokeDynamicYield
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
GlimmerDebug
:
'
<
invoke
-
dynamic
-
yield
caller
-
count
=
'
+
this
.
callerCount
+
'
>
'
}
;
}
;
return
InvokeDynamicYield
;
}
(
)
;
STATEMENTS
.
add
(
Ops
3
.
Yield
function
(
sexp
builder
)
{
var
to
=
sexp
[
1
]
params
=
sexp
[
2
]
;
var
count
=
compileList
(
params
builder
)
;
builder
.
getBlock
(
to
)
;
builder
.
compileDynamicBlock
(
)
;
builder
.
invokeDynamic
(
new
InvokeDynamicYield
(
count
)
)
;
builder
.
popScope
(
)
;
builder
.
popFrame
(
)
;
if
(
count
)
{
builder
.
pop
(
count
)
;
}
}
)
;
STATEMENTS
.
add
(
Ops
3
.
Debugger
function
(
sexp
builder
)
{
var
evalInfo
=
sexp
[
1
]
;
builder
.
debugger
(
builder
.
meta
.
symbols
evalInfo
)
;
}
)
;
STATEMENTS
.
add
(
Ops
3
.
ClientSideStatement
function
(
sexp
builder
)
{
CLIENT_SIDE
.
compile
(
sexp
builder
)
;
}
)
;
var
EXPRESSIONS
=
new
Compilers
(
)
;
var
CLIENT_SIDE_EXPRS
=
new
Compilers
(
1
)
;
var
E
=
_wireFormat
.
Expressions
;
function
expr
(
expression
builder
)
{
if
(
Array
.
isArray
(
expression
)
)
{
EXPRESSIONS
.
compile
(
expression
builder
)
;
}
else
{
builder
.
primitive
(
expression
)
;
}
}
EXPRESSIONS
.
add
(
Ops
3
.
Unknown
function
(
sexp
builder
)
{
var
name
=
sexp
[
1
]
;
if
(
builder
.
env
.
hasHelper
(
name
builder
.
meta
.
templateMeta
)
)
{
EXPRESSIONS
.
compile
(
[
Ops
3
.
Helper
name
_util
.
EMPTY_ARRAY
null
]
builder
)
;
}
else
if
(
builder
.
meta
.
asPartial
)
{
builder
.
resolveMaybeLocal
(
name
)
;
}
else
{
builder
.
getVariable
(
0
)
;
builder
.
getProperty
(
name
)
;
}
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
Concat
function
(
sexp
builder
)
{
var
parts
=
sexp
[
1
]
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
expr
(
parts
[
i
]
builder
)
;
}
builder
.
concat
(
parts
.
length
)
;
}
)
;
CLIENT_SIDE_EXPRS
.
add
(
Ops
2
.
FunctionExpression
function
(
sexp
builder
)
{
builder
.
function
(
sexp
[
2
]
)
;
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
Helper
function
(
sexp
builder
)
{
var
env
=
builder
.
env
meta
=
builder
.
meta
;
var
name
=
sexp
[
1
]
params
=
sexp
[
2
]
hash
=
sexp
[
3
]
;
if
(
env
.
hasHelper
(
name
meta
.
templateMeta
)
)
{
builder
.
compileArgs
(
params
hash
true
)
;
builder
.
helper
(
env
.
lookupHelper
(
name
meta
.
templateMeta
)
)
;
}
else
{
throw
new
Error
(
'
Compile
Error
:
'
+
name
+
'
is
not
a
helper
'
)
;
}
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
Get
function
(
sexp
builder
)
{
var
head
=
sexp
[
1
]
path
=
sexp
[
2
]
;
builder
.
getVariable
(
head
)
;
for
(
var
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
builder
.
getProperty
(
path
[
i
]
)
;
}
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
MaybeLocal
function
(
sexp
builder
)
{
var
path
=
sexp
[
1
]
;
if
(
builder
.
meta
.
asPartial
)
{
var
head
=
path
[
0
]
;
path
=
path
.
slice
(
1
)
;
builder
.
resolveMaybeLocal
(
head
)
;
}
else
{
builder
.
getVariable
(
0
)
;
}
for
(
var
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
builder
.
getProperty
(
path
[
i
]
)
;
}
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
Undefined
function
(
_sexp
builder
)
{
return
builder
.
primitive
(
undefined
)
;
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
HasBlock
function
(
sexp
builder
)
{
builder
.
hasBlock
(
sexp
[
1
]
)
;
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
HasBlockParams
function
(
sexp
builder
)
{
builder
.
hasBlockParams
(
sexp
[
1
]
)
;
}
)
;
EXPRESSIONS
.
add
(
Ops
3
.
ClientSideExpression
function
(
sexp
builder
)
{
CLIENT_SIDE_EXPRS
.
compile
(
sexp
builder
)
;
}
)
;
function
compileList
(
params
builder
)
{
if
(
!
params
)
return
0
;
for
(
var
i
=
0
;
i
<
params
.
length
;
i
+
+
)
{
expr
(
params
[
i
]
builder
)
;
}
return
params
.
length
;
}
var
Blocks
=
function
(
)
{
function
Blocks
(
)
{
_classCallCheck
18
(
this
Blocks
)
;
this
.
names
=
(
0
_util
.
dict
)
(
)
;
this
.
funcs
=
[
]
;
}
Blocks
.
prototype
.
add
=
function
add
(
name
func
)
{
this
.
funcs
.
push
(
func
)
;
this
.
names
[
name
]
=
this
.
funcs
.
length
-
1
;
}
;
Blocks
.
prototype
.
addMissing
=
function
addMissing
(
func
)
{
this
.
missing
=
func
;
}
;
Blocks
.
prototype
.
compile
=
function
compile
(
name
params
hash
template
inverse
builder
)
{
var
index
=
this
.
names
[
name
]
;
if
(
index
=
=
=
undefined
)
{
(
0
_util
.
assert
)
(
!
!
this
.
missing
name
+
'
not
found
and
no
catch
-
all
block
handler
was
registered
'
)
;
var
func
=
this
.
missing
;
var
handled
=
func
(
name
params
hash
template
inverse
builder
)
;
(
0
_util
.
assert
)
(
!
!
handled
name
+
'
not
found
and
the
catch
-
all
block
handler
didn
\
'
t
handle
it
'
)
;
}
else
{
var
_func
=
this
.
funcs
[
index
]
;
_func
(
params
hash
template
inverse
builder
)
;
}
}
;
return
Blocks
;
}
(
)
;
var
BLOCKS
=
new
Blocks
(
)
;
var
Inlines
=
function
(
)
{
function
Inlines
(
)
{
_classCallCheck
18
(
this
Inlines
)
;
this
.
names
=
(
0
_util
.
dict
)
(
)
;
this
.
funcs
=
[
]
;
}
Inlines
.
prototype
.
add
=
function
add
(
name
func
)
{
this
.
funcs
.
push
(
func
)
;
this
.
names
[
name
]
=
this
.
funcs
.
length
-
1
;
}
;
Inlines
.
prototype
.
addMissing
=
function
addMissing
(
func
)
{
this
.
missing
=
func
;
}
;
Inlines
.
prototype
.
compile
=
function
compile
(
sexp
builder
)
{
var
value
=
sexp
[
1
]
;
if
(
!
Array
.
isArray
(
value
)
)
return
[
'
expr
'
value
]
;
var
name
=
void
0
;
var
params
=
void
0
;
var
hash
=
void
0
;
if
(
value
[
0
]
=
=
=
Ops
3
.
Helper
)
{
name
=
value
[
1
]
;
params
=
value
[
2
]
;
hash
=
value
[
3
]
;
}
else
if
(
value
[
0
]
=
=
=
Ops
3
.
Unknown
)
{
name
=
value
[
1
]
;
params
=
hash
=
null
;
}
else
{
return
[
'
expr
'
value
]
;
}
var
index
=
this
.
names
[
name
]
;
if
(
index
=
=
=
undefined
&
&
this
.
missing
)
{
var
func
=
this
.
missing
;
var
returned
=
func
(
name
params
hash
builder
)
;
return
returned
=
=
=
false
?
[
'
expr
'
value
]
:
returned
;
}
else
if
(
index
!
=
=
undefined
)
{
var
_func2
=
this
.
funcs
[
index
]
;
var
_returned
=
_func2
(
name
params
hash
builder
)
;
return
_returned
=
=
=
false
?
[
'
expr
'
value
]
:
_returned
;
}
else
{
return
[
'
expr
'
value
]
;
}
}
;
return
Inlines
;
}
(
)
;
var
INLINES
=
new
Inlines
(
)
;
populateBuiltins
(
BLOCKS
INLINES
)
;
function
populateBuiltins
(
)
{
var
blocks
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
new
Blocks
(
)
;
var
inlines
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
new
Inlines
(
)
;
blocks
.
add
(
'
if
'
function
(
params
_hash
template
inverse
builder
)
{
if
(
!
params
|
|
params
.
length
!
=
=
1
)
{
throw
new
Error
(
'
SYNTAX
ERROR
:
#
if
requires
a
single
argument
'
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
expr
(
params
[
0
]
builder
)
;
builder
.
test
(
'
environment
'
)
;
builder
.
enter
(
1
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
template
)
;
if
(
inverse
)
{
builder
.
jump
(
'
EXIT
'
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
inverse
)
;
builder
.
label
(
'
EXIT
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
else
{
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
blocks
.
add
(
'
unless
'
function
(
params
_hash
template
inverse
builder
)
{
if
(
!
params
|
|
params
.
length
!
=
=
1
)
{
throw
new
Error
(
'
SYNTAX
ERROR
:
#
unless
requires
a
single
argument
'
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
expr
(
params
[
0
]
builder
)
;
builder
.
test
(
'
environment
'
)
;
builder
.
enter
(
1
)
;
builder
.
jumpIf
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
template
)
;
if
(
inverse
)
{
builder
.
jump
(
'
EXIT
'
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
inverse
)
;
builder
.
label
(
'
EXIT
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
else
{
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
blocks
.
add
(
'
with
'
function
(
params
_hash
template
inverse
builder
)
{
if
(
!
params
|
|
params
.
length
!
=
=
1
)
{
throw
new
Error
(
'
SYNTAX
ERROR
:
#
with
requires
a
single
argument
'
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
expr
(
params
[
0
]
builder
)
;
builder
.
dup
(
)
;
builder
.
test
(
'
environment
'
)
;
builder
.
enter
(
2
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
template
1
)
;
if
(
inverse
)
{
builder
.
jump
(
'
EXIT
'
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
inverse
)
;
builder
.
label
(
'
EXIT
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
else
{
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
blocks
.
add
(
'
each
'
function
(
params
hash
template
inverse
builder
)
{
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
if
(
hash
&
&
hash
[
0
]
[
0
]
=
=
=
'
key
'
)
{
expr
(
hash
[
1
]
[
0
]
builder
)
;
}
else
{
builder
.
primitive
(
null
)
;
}
expr
(
params
[
0
]
builder
)
;
builder
.
enter
(
2
)
;
builder
.
putIterator
(
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
ITER
'
)
;
builder
.
dup
(
Register
.
fp
1
)
;
builder
.
enterList
(
'
BODY
'
)
;
builder
.
label
(
'
ITER
'
)
;
builder
.
iterate
(
'
BREAK
'
)
;
builder
.
label
(
'
BODY
'
)
;
builder
.
invokeStatic
(
template
2
)
;
builder
.
pop
(
2
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
builder
.
label
(
'
BREAK
'
)
;
builder
.
exitList
(
)
;
builder
.
popFrame
(
)
;
if
(
inverse
)
{
builder
.
jump
(
'
EXIT
'
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
invokeStatic
(
inverse
)
;
builder
.
label
(
'
EXIT
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
else
{
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
}
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
blocks
.
add
(
'
-
in
-
element
'
function
(
params
hash
template
_inverse
builder
)
{
if
(
!
params
|
|
params
.
length
!
=
=
1
)
{
throw
new
Error
(
'
SYNTAX
ERROR
:
#
-
in
-
element
requires
a
single
argument
'
)
;
}
builder
.
startLabels
(
)
;
builder
.
pushFrame
(
)
;
builder
.
returnTo
(
'
END
'
)
;
if
(
hash
&
&
hash
[
0
]
.
length
)
{
var
keys
=
hash
[
0
]
values
=
hash
[
1
]
;
if
(
keys
.
length
=
=
=
1
&
&
keys
[
0
]
=
=
=
'
nextSibling
'
)
{
expr
(
values
[
0
]
builder
)
;
}
else
{
throw
new
Error
(
'
SYNTAX
ERROR
:
#
-
in
-
element
does
not
take
a
'
+
keys
[
0
]
+
'
option
'
)
;
}
}
else
{
expr
(
null
builder
)
;
}
expr
(
params
[
0
]
builder
)
;
builder
.
dup
(
)
;
builder
.
test
(
'
simple
'
)
;
builder
.
enter
(
3
)
;
builder
.
jumpUnless
(
'
ELSE
'
)
;
builder
.
pushRemoteElement
(
)
;
builder
.
invokeStatic
(
template
)
;
builder
.
popRemoteElement
(
)
;
builder
.
label
(
'
ELSE
'
)
;
builder
.
exit
(
)
;
builder
.
return
(
)
;
builder
.
label
(
'
END
'
)
;
builder
.
popFrame
(
)
;
builder
.
stopLabels
(
)
;
}
)
;
blocks
.
add
(
'
-
with
-
dynamic
-
vars
'
function
(
_params
hash
template
_inverse
builder
)
{
if
(
hash
)
{
var
names
=
hash
[
0
]
expressions
=
hash
[
1
]
;
compileList
(
expressions
builder
)
;
builder
.
pushDynamicScope
(
)
;
builder
.
bindDynamicScope
(
names
)
;
builder
.
invokeStatic
(
template
)
;
builder
.
popDynamicScope
(
)
;
}
else
{
builder
.
invokeStatic
(
template
)
;
}
}
)
;
return
{
blocks
:
blocks
inlines
:
inlines
}
;
}
function
compileStatement
(
statement
builder
)
{
STATEMENTS
.
compile
(
statement
builder
)
;
}
function
compileStatements
(
statements
meta
env
)
{
var
b
=
new
OpcodeBuilder
(
env
meta
)
;
for
(
var
i
=
0
;
i
<
statements
.
length
;
i
+
+
)
{
compileStatement
(
statements
[
i
]
b
)
;
}
return
b
;
}
function
_classCallCheck
16
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
CompilableTemplate
=
function
(
)
{
function
CompilableTemplate
(
statements
symbolTable
)
{
_classCallCheck
16
(
this
CompilableTemplate
)
;
this
.
statements
=
statements
;
this
.
symbolTable
=
symbolTable
;
this
.
compiledStatic
=
null
;
this
.
compiledDynamic
=
null
;
}
CompilableTemplate
.
prototype
.
compileStatic
=
function
compileStatic
(
env
)
{
var
compiledStatic
=
this
.
compiledStatic
;
if
(
!
compiledStatic
)
{
var
builder
=
compileStatements
(
this
.
statements
this
.
symbolTable
.
meta
env
)
;
builder
.
finalize
(
)
;
var
handle
=
builder
.
start
;
compiledStatic
=
this
.
compiledStatic
=
new
CompiledStaticTemplate
(
handle
)
;
}
return
compiledStatic
;
}
;
CompilableTemplate
.
prototype
.
compileDynamic
=
function
compileDynamic
(
env
)
{
var
compiledDynamic
=
this
.
compiledDynamic
;
if
(
!
compiledDynamic
)
{
var
staticBlock
=
this
.
compileStatic
(
env
)
;
compiledDynamic
=
new
CompiledDynamicTemplate
(
staticBlock
.
handle
this
.
symbolTable
)
;
}
return
compiledDynamic
;
}
;
return
CompilableTemplate
;
}
(
)
;
function
_classCallCheck
15
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Ops
1
=
_wireFormat
.
Ops
;
var
Scanner
=
function
(
)
{
function
Scanner
(
block
env
)
{
_classCallCheck
15
(
this
Scanner
)
;
this
.
block
=
block
;
this
.
env
=
env
;
}
Scanner
.
prototype
.
scanEntryPoint
=
function
scanEntryPoint
(
meta
)
{
var
block
=
this
.
block
;
var
statements
=
block
.
statements
symbols
=
block
.
symbols
hasEval
=
block
.
hasEval
;
return
new
CompilableTemplate
(
statements
{
meta
:
meta
symbols
:
symbols
hasEval
:
hasEval
}
)
;
}
;
Scanner
.
prototype
.
scanBlock
=
function
scanBlock
(
meta
)
{
var
block
=
this
.
block
;
var
statements
=
block
.
statements
;
return
new
CompilableTemplate
(
statements
{
meta
:
meta
parameters
:
_util
.
EMPTY_ARRAY
}
)
;
}
;
Scanner
.
prototype
.
scanLayout
=
function
scanLayout
(
meta
attrs
componentName
)
{
var
block
=
this
.
block
;
var
statements
=
block
.
statements
symbols
=
block
.
symbols
hasEval
=
block
.
hasEval
;
var
symbolTable
=
{
meta
:
meta
hasEval
:
hasEval
symbols
:
symbols
}
;
var
newStatements
=
[
]
;
var
toplevel
=
void
0
;
var
inTopLevel
=
false
;
for
(
var
i
=
0
;
i
<
statements
.
length
;
i
+
+
)
{
var
statement
=
statements
[
i
]
;
if
(
_wireFormat
.
Statements
.
isComponent
(
statement
)
)
{
var
tagName
=
statement
[
1
]
;
if
(
!
this
.
env
.
hasComponentDefinition
(
tagName
meta
.
templateMeta
)
)
{
if
(
toplevel
!
=
=
undefined
)
{
newStatements
.
push
(
[
Ops
1
.
OpenElement
tagName
]
)
;
}
else
{
toplevel
=
tagName
;
decorateTopLevelElement
(
tagName
symbols
attrs
newStatements
)
;
}
addFallback
(
statement
newStatements
)
;
}
else
{
if
(
toplevel
=
=
=
undefined
&
&
tagName
=
=
=
componentName
)
{
toplevel
=
tagName
;
decorateTopLevelElement
(
tagName
symbols
attrs
newStatements
)
;
addFallback
(
statement
newStatements
)
;
}
else
{
newStatements
.
push
(
statement
)
;
}
}
}
else
{
if
(
toplevel
=
=
=
undefined
&
&
_wireFormat
.
Statements
.
isOpenElement
(
statement
)
)
{
toplevel
=
statement
[
1
]
;
inTopLevel
=
true
;
decorateTopLevelElement
(
toplevel
symbols
attrs
newStatements
)
;
}
else
{
if
(
inTopLevel
)
{
if
(
_wireFormat
.
Statements
.
isFlushElement
(
statement
)
)
{
inTopLevel
=
false
;
}
else
if
(
_wireFormat
.
Statements
.
isModifier
(
statement
)
)
{
throw
Error
(
'
Found
modifier
"
'
+
statement
[
1
]
+
'
"
on
the
top
-
level
element
of
"
'
+
componentName
+
'
"
.
Modifiers
cannot
be
on
the
top
-
level
element
'
)
;
}
}
newStatements
.
push
(
statement
)
;
}
}
}
newStatements
.
push
(
[
Ops
1
.
ClientSideStatement
Ops
2
.
DidRenderLayout
]
)
;
return
new
CompilableTemplate
(
newStatements
symbolTable
)
;
}
;
return
Scanner
;
}
(
)
;
function
addFallback
(
statement
buffer
)
{
var
attrs
=
statement
[
2
]
block
=
statement
[
4
]
;
for
(
var
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
buffer
.
push
(
attrs
[
i
]
)
;
}
buffer
.
push
(
[
Ops
1
.
FlushElement
]
)
;
if
(
block
)
{
var
statements
=
block
.
statements
;
for
(
var
_i
=
0
;
_i
<
statements
.
length
;
_i
+
+
)
{
buffer
.
push
(
statements
[
_i
]
)
;
}
}
buffer
.
push
(
[
Ops
1
.
CloseElement
]
)
;
}
function
decorateTopLevelElement
(
tagName
symbols
attrs
buffer
)
{
var
attrsSymbol
=
symbols
.
push
(
ATTRS_BLOCK
)
;
buffer
.
push
(
[
Ops
1
.
ClientSideStatement
Ops
2
.
OpenComponentElement
tagName
]
)
;
buffer
.
push
(
[
Ops
1
.
ClientSideStatement
Ops
2
.
DidCreateElement
]
)
;
buffer
.
push
(
[
Ops
1
.
Yield
attrsSymbol
_util
.
EMPTY_ARRAY
]
)
;
buffer
.
push
.
apply
(
buffer
attrs
)
;
}
function
_classCallCheck
24
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Constants
=
function
(
)
{
function
Constants
(
)
{
_classCallCheck
24
(
this
Constants
)
;
this
.
references
=
[
]
;
this
.
strings
=
[
]
;
this
.
expressions
=
[
]
;
this
.
floats
=
[
]
;
this
.
arrays
=
[
]
;
this
.
blocks
=
[
]
;
this
.
functions
=
[
]
;
this
.
others
=
[
]
;
}
Constants
.
prototype
.
getReference
=
function
getReference
(
value
)
{
return
this
.
references
[
value
-
1
]
;
}
;
Constants
.
prototype
.
reference
=
function
reference
1
(
value
)
{
var
index
=
this
.
references
.
length
;
this
.
references
.
push
(
value
)
;
return
index
+
1
;
}
;
Constants
.
prototype
.
getString
=
function
getString
(
value
)
{
return
this
.
strings
[
value
-
1
]
;
}
;
Constants
.
prototype
.
getFloat
=
function
getFloat
(
value
)
{
return
this
.
floats
[
value
-
1
]
;
}
;
Constants
.
prototype
.
float
=
function
float
(
value
)
{
return
this
.
floats
.
push
(
value
)
;
}
;
Constants
.
prototype
.
string
=
function
string
(
value
)
{
var
index
=
this
.
strings
.
length
;
this
.
strings
.
push
(
value
)
;
return
index
+
1
;
}
;
Constants
.
prototype
.
getExpression
=
function
getExpression
(
value
)
{
return
this
.
expressions
[
value
-
1
]
;
}
;
Constants
.
prototype
.
getArray
=
function
getArray
(
value
)
{
return
this
.
arrays
[
value
-
1
]
;
}
;
Constants
.
prototype
.
getNames
=
function
getNames
(
value
)
{
var
_names
=
[
]
;
var
names
=
this
.
getArray
(
value
)
;
for
(
var
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
var
n
=
names
[
i
]
;
_names
[
i
]
=
this
.
getString
(
n
)
;
}
return
_names
;
}
;
Constants
.
prototype
.
array
=
function
array
(
values
)
{
var
index
=
this
.
arrays
.
length
;
this
.
arrays
.
push
(
values
)
;
return
index
+
1
;
}
;
Constants
.
prototype
.
getBlock
=
function
getBlock
(
value
)
{
return
this
.
blocks
[
value
-
1
]
;
}
;
Constants
.
prototype
.
block
=
function
block
(
_block
)
{
var
index
=
this
.
blocks
.
length
;
this
.
blocks
.
push
(
_block
)
;
return
index
+
1
;
}
;
Constants
.
prototype
.
getFunction
=
function
getFunction
(
value
)
{
return
this
.
functions
[
value
-
1
]
;
}
;
Constants
.
prototype
.
function
=
function
_function
(
f
)
{
var
index
=
this
.
functions
.
length
;
this
.
functions
.
push
(
f
)
;
return
index
+
1
;
}
;
Constants
.
prototype
.
getOther
=
function
getOther
(
value
)
{
return
this
.
others
[
value
-
1
]
;
}
;
Constants
.
prototype
.
other
=
function
other
(
_other
)
{
var
index
=
this
.
others
.
length
;
this
.
others
.
push
(
_other
)
;
return
index
+
1
;
}
;
return
Constants
;
}
(
)
;
var
badProtocols
=
[
'
javascript
:
'
'
vbscript
:
'
]
;
var
badTags
=
[
'
A
'
'
BODY
'
'
LINK
'
'
IMG
'
'
IFRAME
'
'
BASE
'
'
FORM
'
]
;
var
badTagsForDataURI
=
[
'
EMBED
'
]
;
var
badAttributes
=
[
'
href
'
'
src
'
'
background
'
'
action
'
]
;
var
badAttributesForDataURI
=
[
'
src
'
]
;
function
has
(
array
item
)
{
return
array
.
indexOf
(
item
)
!
=
=
-
1
;
}
function
checkURI
(
tagName
attribute
)
{
return
(
tagName
=
=
=
null
|
|
has
(
badTags
tagName
)
)
&
&
has
(
badAttributes
attribute
)
;
}
function
checkDataURI
(
tagName
attribute
)
{
if
(
tagName
=
=
=
null
)
return
false
;
return
has
(
badTagsForDataURI
tagName
)
&
&
has
(
badAttributesForDataURI
attribute
)
;
}
function
requiresSanitization
(
tagName
attribute
)
{
return
checkURI
(
tagName
attribute
)
|
|
checkDataURI
(
tagName
attribute
)
;
}
function
sanitizeAttributeValue
(
env
element
attribute
value
)
{
var
tagName
=
null
;
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
value
;
}
if
(
isSafeString
(
value
)
)
{
return
value
.
toHTML
(
)
;
}
if
(
!
element
)
{
tagName
=
null
;
}
else
{
tagName
=
element
.
tagName
.
toUpperCase
(
)
;
}
var
str
=
normalizeTextValue
(
value
)
;
if
(
checkURI
(
tagName
attribute
)
)
{
var
protocol
=
env
.
protocolForURL
(
str
)
;
if
(
has
(
badProtocols
protocol
)
)
{
return
'
unsafe
:
'
+
str
;
}
}
if
(
checkDataURI
(
tagName
attribute
)
)
{
return
'
unsafe
:
'
+
str
;
}
return
str
;
}
function
normalizeProperty
(
element
slotName
)
{
var
type
=
void
0
normalized
=
void
0
;
if
(
slotName
in
element
)
{
normalized
=
slotName
;
type
=
'
prop
'
;
}
else
{
var
lower
=
slotName
.
toLowerCase
(
)
;
if
(
lower
in
element
)
{
type
=
'
prop
'
;
normalized
=
lower
;
}
else
{
type
=
'
attr
'
;
normalized
=
slotName
;
}
}
if
(
type
=
=
=
'
prop
'
&
&
(
normalized
.
toLowerCase
(
)
=
=
=
'
style
'
|
|
preferAttr
(
element
.
tagName
normalized
)
)
)
{
type
=
'
attr
'
;
}
return
{
normalized
:
normalized
type
:
type
}
;
}
var
ATTR_OVERRIDES
=
{
BUTTON
:
{
type
:
true
form
:
true
}
INPUT
:
{
type
:
true
form
:
true
autocorrect
:
true
list
:
true
}
SELECT
:
{
form
:
true
}
OPTION
:
{
form
:
true
}
TEXTAREA
:
{
form
:
true
}
LABEL
:
{
form
:
true
}
FIELDSET
:
{
form
:
true
}
LEGEND
:
{
form
:
true
}
OBJECT
:
{
form
:
true
}
}
;
function
preferAttr
(
tagName
propName
)
{
var
tag
=
ATTR_OVERRIDES
[
tagName
.
toUpperCase
(
)
]
;
return
tag
&
&
tag
[
propName
.
toLowerCase
(
)
]
|
|
false
;
}
function
_defaults
12
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
27
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
12
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
12
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
12
(
subClass
superClass
)
;
}
var
innerHTMLWrapper
=
{
colgroup
:
{
depth
:
2
before
:
'
<
table
>
<
colgroup
>
'
after
:
'
<
/
colgroup
>
<
/
table
>
'
}
table
:
{
depth
:
1
before
:
'
<
table
>
'
after
:
'
<
/
table
>
'
}
tbody
:
{
depth
:
2
before
:
'
<
table
>
<
tbody
>
'
after
:
'
<
/
tbody
>
<
/
table
>
'
}
tfoot
:
{
depth
:
2
before
:
'
<
table
>
<
tfoot
>
'
after
:
'
<
/
tfoot
>
<
/
table
>
'
}
thead
:
{
depth
:
2
before
:
'
<
table
>
<
thead
>
'
after
:
'
<
/
thead
>
<
/
table
>
'
}
tr
:
{
depth
:
3
before
:
'
<
table
>
<
tbody
>
<
tr
>
'
after
:
'
<
/
tr
>
<
/
tbody
>
<
/
table
>
'
}
}
;
function
domChanges
(
document
DOMChangesClass
)
{
if
(
!
document
)
return
DOMChangesClass
;
if
(
!
shouldApplyFix
(
document
)
)
{
return
DOMChangesClass
;
}
var
div
=
document
.
createElement
(
'
div
'
)
;
return
function
(
_DOMChangesClass
)
{
_inherits
12
(
DOMChangesWithInnerHTMLFix
_DOMChangesClass
)
;
function
DOMChangesWithInnerHTMLFix
(
)
{
_classCallCheck
27
(
this
DOMChangesWithInnerHTMLFix
)
;
return
_possibleConstructorReturn
12
(
this
_DOMChangesClass
.
apply
(
this
arguments
)
)
;
}
DOMChangesWithInnerHTMLFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
nextSibling
html
)
{
if
(
html
=
=
=
null
|
|
html
=
=
=
'
'
)
{
return
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
}
var
parentTag
=
parent
.
tagName
.
toLowerCase
(
)
;
var
wrapper
=
innerHTMLWrapper
[
parentTag
]
;
if
(
wrapper
=
=
=
undefined
)
{
return
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
}
return
fixInnerHTML
(
parent
wrapper
div
html
nextSibling
)
;
}
;
return
DOMChangesWithInnerHTMLFix
;
}
(
DOMChangesClass
)
;
}
function
treeConstruction
(
document
DOMTreeConstructionClass
)
{
if
(
!
document
)
return
DOMTreeConstructionClass
;
if
(
!
shouldApplyFix
(
document
)
)
{
return
DOMTreeConstructionClass
;
}
var
div
=
document
.
createElement
(
'
div
'
)
;
return
function
(
_DOMTreeConstructionC
)
{
_inherits
12
(
DOMTreeConstructionWithInnerHTMLFix
_DOMTreeConstructionC
)
;
function
DOMTreeConstructionWithInnerHTMLFix
(
)
{
_classCallCheck
27
(
this
DOMTreeConstructionWithInnerHTMLFix
)
;
return
_possibleConstructorReturn
12
(
this
_DOMTreeConstructionC
.
apply
(
this
arguments
)
)
;
}
DOMTreeConstructionWithInnerHTMLFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
referenceNode
html
)
{
if
(
html
=
=
=
null
|
|
html
=
=
=
'
'
)
{
return
_DOMTreeConstructionC
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
referenceNode
html
)
;
}
var
parentTag
=
parent
.
tagName
.
toLowerCase
(
)
;
var
wrapper
=
innerHTMLWrapper
[
parentTag
]
;
if
(
wrapper
=
=
=
undefined
)
{
return
_DOMTreeConstructionC
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
referenceNode
html
)
;
}
return
fixInnerHTML
(
parent
wrapper
div
html
referenceNode
)
;
}
;
return
DOMTreeConstructionWithInnerHTMLFix
;
}
(
DOMTreeConstructionClass
)
;
}
function
fixInnerHTML
(
parent
wrapper
div
html
reference
1
)
{
var
wrappedHtml
=
wrapper
.
before
+
html
+
wrapper
.
after
;
div
.
innerHTML
=
wrappedHtml
;
var
parentNode
=
div
;
for
(
var
i
=
0
;
i
<
wrapper
.
depth
;
i
+
+
)
{
parentNode
=
parentNode
.
childNodes
[
0
]
;
}
var
_moveNodesBefore
=
moveNodesBefore
(
parentNode
parent
reference
1
)
first
=
_moveNodesBefore
[
0
]
last
=
_moveNodesBefore
[
1
]
;
return
new
ConcreteBounds
(
parent
first
last
)
;
}
function
shouldApplyFix
(
document
)
{
var
table
=
document
.
createElement
(
'
table
'
)
;
try
{
table
.
innerHTML
=
'
<
tbody
>
<
/
tbody
>
'
;
}
catch
(
e
)
{
}
finally
{
if
(
table
.
childNodes
.
length
!
=
=
0
)
{
return
false
;
}
}
return
true
;
}
function
_defaults
13
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
28
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
13
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
13
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
13
(
subClass
superClass
)
;
}
var
SVG_NAMESPACE
1
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
function
domChanges
1
(
document
DOMChangesClass
svgNamespace
)
{
if
(
!
document
)
return
DOMChangesClass
;
if
(
!
shouldApplyFix
1
(
document
svgNamespace
)
)
{
return
DOMChangesClass
;
}
var
div
=
document
.
createElement
(
'
div
'
)
;
return
function
(
_DOMChangesClass
)
{
_inherits
13
(
DOMChangesWithSVGInnerHTMLFix
_DOMChangesClass
)
;
function
DOMChangesWithSVGInnerHTMLFix
(
)
{
_classCallCheck
28
(
this
DOMChangesWithSVGInnerHTMLFix
)
;
return
_possibleConstructorReturn
13
(
this
_DOMChangesClass
.
apply
(
this
arguments
)
)
;
}
DOMChangesWithSVGInnerHTMLFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
nextSibling
html
)
{
if
(
html
=
=
=
null
|
|
html
=
=
=
'
'
)
{
return
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
}
if
(
parent
.
namespaceURI
!
=
=
svgNamespace
)
{
return
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
}
return
fixSVG
(
parent
div
html
nextSibling
)
;
}
;
return
DOMChangesWithSVGInnerHTMLFix
;
}
(
DOMChangesClass
)
;
}
function
treeConstruction
1
(
document
TreeConstructionClass
svgNamespace
)
{
if
(
!
document
)
return
TreeConstructionClass
;
if
(
!
shouldApplyFix
1
(
document
svgNamespace
)
)
{
return
TreeConstructionClass
;
}
var
div
=
document
.
createElement
(
'
div
'
)
;
return
function
(
_TreeConstructionClas
)
{
_inherits
13
(
TreeConstructionWithSVGInnerHTMLFix
_TreeConstructionClas
)
;
function
TreeConstructionWithSVGInnerHTMLFix
(
)
{
_classCallCheck
28
(
this
TreeConstructionWithSVGInnerHTMLFix
)
;
return
_possibleConstructorReturn
13
(
this
_TreeConstructionClas
.
apply
(
this
arguments
)
)
;
}
TreeConstructionWithSVGInnerHTMLFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
reference
1
html
)
{
if
(
html
=
=
=
null
|
|
html
=
=
=
'
'
)
{
return
_TreeConstructionClas
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
reference
1
html
)
;
}
if
(
parent
.
namespaceURI
!
=
=
svgNamespace
)
{
return
_TreeConstructionClas
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
reference
1
html
)
;
}
return
fixSVG
(
parent
div
html
reference
1
)
;
}
;
return
TreeConstructionWithSVGInnerHTMLFix
;
}
(
TreeConstructionClass
)
;
}
function
fixSVG
(
parent
div
html
reference
1
)
{
var
wrappedHtml
=
'
<
svg
>
'
+
html
+
'
<
/
svg
>
'
;
div
.
innerHTML
=
wrappedHtml
;
var
_moveNodesBefore
=
moveNodesBefore
(
div
.
firstChild
parent
reference
1
)
first
=
_moveNodesBefore
[
0
]
last
=
_moveNodesBefore
[
1
]
;
return
new
ConcreteBounds
(
parent
first
last
)
;
}
function
shouldApplyFix
1
(
document
svgNamespace
)
{
var
svg
=
document
.
createElementNS
(
svgNamespace
'
svg
'
)
;
try
{
svg
[
'
insertAdjacentHTML
'
]
(
'
beforeend
'
'
<
circle
>
<
/
circle
>
'
)
;
}
catch
(
e
)
{
}
finally
{
if
(
svg
.
childNodes
.
length
=
=
=
1
&
&
svg
.
firstChild
.
namespaceURI
=
=
=
SVG_NAMESPACE
1
)
{
return
false
;
}
return
true
;
}
}
function
_defaults
14
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_classCallCheck
29
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
14
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
14
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
14
(
subClass
superClass
)
;
}
function
domChanges
2
(
document
DOMChangesClass
)
{
if
(
!
document
)
return
DOMChangesClass
;
if
(
!
shouldApplyFix
2
(
document
)
)
{
return
DOMChangesClass
;
}
return
function
(
_DOMChangesClass
)
{
_inherits
14
(
DOMChangesWithTextNodeMergingFix
_DOMChangesClass
)
;
function
DOMChangesWithTextNodeMergingFix
(
document
)
{
_classCallCheck
29
(
this
DOMChangesWithTextNodeMergingFix
)
;
var
_this
=
_possibleConstructorReturn
14
(
this
_DOMChangesClass
.
call
(
this
document
)
)
;
_this
.
uselessComment
=
document
.
createComment
(
'
'
)
;
return
_this
;
}
DOMChangesWithTextNodeMergingFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
nextSibling
html
)
{
if
(
html
=
=
=
null
)
{
return
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
}
var
didSetUselessComment
=
false
;
var
nextPrevious
=
nextSibling
?
nextSibling
.
previousSibling
:
parent
.
lastChild
;
if
(
nextPrevious
&
&
nextPrevious
instanceof
Text
)
{
didSetUselessComment
=
true
;
parent
.
insertBefore
(
this
.
uselessComment
nextSibling
)
;
}
var
bounds
=
_DOMChangesClass
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
nextSibling
html
)
;
if
(
didSetUselessComment
)
{
parent
.
removeChild
(
this
.
uselessComment
)
;
}
return
bounds
;
}
;
return
DOMChangesWithTextNodeMergingFix
;
}
(
DOMChangesClass
)
;
}
function
treeConstruction
2
(
document
TreeConstructionClass
)
{
if
(
!
document
)
return
TreeConstructionClass
;
if
(
!
shouldApplyFix
2
(
document
)
)
{
return
TreeConstructionClass
;
}
return
function
(
_TreeConstructionClas
)
{
_inherits
14
(
TreeConstructionWithTextNodeMergingFix
_TreeConstructionClas
)
;
function
TreeConstructionWithTextNodeMergingFix
(
document
)
{
_classCallCheck
29
(
this
TreeConstructionWithTextNodeMergingFix
)
;
var
_this2
=
_possibleConstructorReturn
14
(
this
_TreeConstructionClas
.
call
(
this
document
)
)
;
_this2
.
uselessComment
=
_this2
.
createComment
(
'
'
)
;
return
_this2
;
}
TreeConstructionWithTextNodeMergingFix
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
parent
reference
1
html
)
{
if
(
html
=
=
=
null
)
{
return
_TreeConstructionClas
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
reference
1
html
)
;
}
var
didSetUselessComment
=
false
;
var
nextPrevious
=
reference
1
?
reference
1
.
previousSibling
:
parent
.
lastChild
;
if
(
nextPrevious
&
&
nextPrevious
instanceof
Text
)
{
didSetUselessComment
=
true
;
parent
.
insertBefore
(
this
.
uselessComment
reference
1
)
;
}
var
bounds
=
_TreeConstructionClas
.
prototype
.
insertHTMLBefore
.
call
(
this
parent
reference
1
html
)
;
if
(
didSetUselessComment
)
{
parent
.
removeChild
(
this
.
uselessComment
)
;
}
return
bounds
;
}
;
return
TreeConstructionWithTextNodeMergingFix
;
}
(
TreeConstructionClass
)
;
}
function
shouldApplyFix
2
(
document
)
{
var
mergingTextDiv
=
document
.
createElement
(
'
div
'
)
;
mergingTextDiv
.
innerHTML
=
'
first
'
;
mergingTextDiv
.
insertAdjacentHTML
(
'
beforeend
'
'
second
'
)
;
if
(
mergingTextDiv
.
childNodes
.
length
=
=
=
2
)
{
return
false
;
}
return
true
;
}
function
_defaults
11
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
11
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
11
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
11
(
subClass
superClass
)
;
}
function
_classCallCheck
26
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
SVG_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
var
SVG_INTEGRATION_POINTS
=
{
foreignObject
:
1
desc
:
1
title
:
1
}
;
var
BLACKLIST_TABLE
=
Object
.
create
(
null
)
;
[
"
b
"
"
big
"
"
blockquote
"
"
body
"
"
br
"
"
center
"
"
code
"
"
dd
"
"
div
"
"
dl
"
"
dt
"
"
em
"
"
embed
"
"
h1
"
"
h2
"
"
h3
"
"
h4
"
"
h5
"
"
h6
"
"
head
"
"
hr
"
"
i
"
"
img
"
"
li
"
"
listing
"
"
main
"
"
meta
"
"
nobr
"
"
ol
"
"
p
"
"
pre
"
"
ruby
"
"
s
"
"
small
"
"
span
"
"
strong
"
"
strike
"
"
sub
"
"
sup
"
"
table
"
"
tt
"
"
u
"
"
ul
"
"
var
"
]
.
forEach
(
function
(
tag
)
{
return
BLACKLIST_TABLE
[
tag
]
=
1
;
}
)
;
var
WHITESPACE
=
/
[
\
t
-
\
r
\
xA0
\
u1680
\
u180E
\
u2000
-
\
u200A
\
u2028
\
u2029
\
u202F
\
u205F
\
u3000
\
uFEFF
]
/
;
var
doc
=
typeof
document
=
=
=
'
undefined
'
?
null
:
document
;
function
isWhitespace
(
string
)
{
return
WHITESPACE
.
test
(
string
)
;
}
function
moveNodesBefore
(
source
target
nextSibling
)
{
var
first
=
source
.
firstChild
;
var
last
=
null
;
var
current
=
first
;
while
(
current
)
{
last
=
current
;
current
=
current
.
nextSibling
;
target
.
insertBefore
(
last
nextSibling
)
;
}
return
[
first
last
]
;
}
var
DOMOperations
=
function
(
)
{
function
DOMOperations
(
document
)
{
_classCallCheck
26
(
this
DOMOperations
)
;
this
.
document
=
document
;
this
.
setupUselessElement
(
)
;
}
DOMOperations
.
prototype
.
setupUselessElement
=
function
setupUselessElement
(
)
{
this
.
uselessElement
=
this
.
document
.
createElement
(
'
div
'
)
;
}
;
DOMOperations
.
prototype
.
createElement
=
function
createElement
(
tag
context
)
{
var
isElementInSVGNamespace
=
void
0
isHTMLIntegrationPoint
=
void
0
;
if
(
context
)
{
isElementInSVGNamespace
=
context
.
namespaceURI
=
=
=
SVG_NAMESPACE
|
|
tag
=
=
=
'
svg
'
;
isHTMLIntegrationPoint
=
SVG_INTEGRATION_POINTS
[
context
.
tagName
]
;
}
else
{
isElementInSVGNamespace
=
tag
=
=
=
'
svg
'
;
isHTMLIntegrationPoint
=
false
;
}
if
(
isElementInSVGNamespace
&
&
!
isHTMLIntegrationPoint
)
{
if
(
BLACKLIST_TABLE
[
tag
]
)
{
throw
new
Error
(
'
Cannot
create
a
'
+
tag
+
'
inside
an
SVG
context
'
)
;
}
return
this
.
document
.
createElementNS
(
SVG_NAMESPACE
tag
)
;
}
else
{
return
this
.
document
.
createElement
(
tag
)
;
}
}
;
DOMOperations
.
prototype
.
insertBefore
=
function
insertBefore
(
parent
node
reference
1
)
{
parent
.
insertBefore
(
node
reference
1
)
;
}
;
DOMOperations
.
prototype
.
insertHTMLBefore
=
function
insertHTMLBefore
(
_parent
nextSibling
html
)
{
return
_insertHTMLBefore
(
this
.
uselessElement
_parent
nextSibling
html
)
;
}
;
DOMOperations
.
prototype
.
createTextNode
=
function
createTextNode
(
text
)
{
return
this
.
document
.
createTextNode
(
text
)
;
}
;
DOMOperations
.
prototype
.
createComment
=
function
createComment
(
data
)
{
return
this
.
document
.
createComment
(
data
)
;
}
;
return
DOMOperations
;
}
(
)
;
var
DOM
;
(
function
(
DOM
)
{
var
TreeConstruction
=
function
(
_DOMOperations
)
{
_inherits
11
(
TreeConstruction
_DOMOperations
)
;
function
TreeConstruction
(
)
{
_classCallCheck
26
(
this
TreeConstruction
)
;
return
_possibleConstructorReturn
11
(
this
_DOMOperations
.
apply
(
this
arguments
)
)
;
}
TreeConstruction
.
prototype
.
createElementNS
=
function
createElementNS
(
namespace
tag
)
{
return
this
.
document
.
createElementNS
(
namespace
tag
)
;
}
;
TreeConstruction
.
prototype
.
setAttribute
=
function
setAttribute
(
element
name
value
namespace
)
{
if
(
namespace
)
{
element
.
setAttributeNS
(
namespace
name
value
)
;
}
else
{
element
.
setAttribute
(
name
value
)
;
}
}
;
return
TreeConstruction
;
}
(
DOMOperations
)
;
DOM
.
TreeConstruction
=
TreeConstruction
;
var
appliedTreeContruction
=
TreeConstruction
;
appliedTreeContruction
=
treeConstruction
2
(
doc
appliedTreeContruction
)
;
appliedTreeContruction
=
treeConstruction
(
doc
appliedTreeContruction
)
;
appliedTreeContruction
=
treeConstruction
1
(
doc
appliedTreeContruction
SVG_NAMESPACE
)
;
DOM
.
DOMTreeConstruction
=
appliedTreeContruction
;
}
)
(
DOM
|
|
(
DOM
=
{
}
)
)
;
var
DOMChanges
=
function
(
_DOMOperations2
)
{
_inherits
11
(
DOMChanges
_DOMOperations2
)
;
function
DOMChanges
(
document
)
{
_classCallCheck
26
(
this
DOMChanges
)
;
var
_this2
=
_possibleConstructorReturn
11
(
this
_DOMOperations2
.
call
(
this
document
)
)
;
_this2
.
document
=
document
;
_this2
.
namespace
=
null
;
return
_this2
;
}
DOMChanges
.
prototype
.
setAttribute
=
function
setAttribute
(
element
name
value
)
{
element
.
setAttribute
(
name
value
)
;
}
;
DOMChanges
.
prototype
.
setAttributeNS
=
function
setAttributeNS
(
element
namespace
name
value
)
{
element
.
setAttributeNS
(
namespace
name
value
)
;
}
;
DOMChanges
.
prototype
.
removeAttribute
=
function
removeAttribute
(
element
name
)
{
element
.
removeAttribute
(
name
)
;
}
;
DOMChanges
.
prototype
.
removeAttributeNS
=
function
removeAttributeNS
(
element
namespace
name
)
{
element
.
removeAttributeNS
(
namespace
name
)
;
}
;
DOMChanges
.
prototype
.
insertNodeBefore
=
function
insertNodeBefore
(
parent
node
reference
1
)
{
if
(
isDocumentFragment
(
node
)
)
{
var
firstChild
=
node
.
firstChild
lastChild
=
node
.
lastChild
;
this
.
insertBefore
(
parent
node
reference
1
)
;
return
new
ConcreteBounds
(
parent
firstChild
lastChild
)
;
}
else
{
this
.
insertBefore
(
parent
node
reference
1
)
;
return
new
SingleNodeBounds
(
parent
node
)
;
}
}
;
DOMChanges
.
prototype
.
insertTextBefore
=
function
insertTextBefore
(
parent
nextSibling
text
)
{
var
textNode
=
this
.
createTextNode
(
text
)
;
this
.
insertBefore
(
parent
textNode
nextSibling
)
;
return
textNode
;
}
;
DOMChanges
.
prototype
.
insertBefore
=
function
insertBefore
(
element
node
reference
1
)
{
element
.
insertBefore
(
node
reference
1
)
;
}
;
DOMChanges
.
prototype
.
insertAfter
=
function
insertAfter
(
element
node
reference
1
)
{
this
.
insertBefore
(
element
node
reference
1
.
nextSibling
)
;
}
;
return
DOMChanges
;
}
(
DOMOperations
)
;
function
_insertHTMLBefore
(
_useless
_parent
_nextSibling
html
)
{
var
parent
=
_parent
;
var
useless
=
_useless
;
var
nextSibling
=
_nextSibling
;
var
prev
=
nextSibling
?
nextSibling
.
previousSibling
:
parent
.
lastChild
;
var
last
=
void
0
;
if
(
html
=
=
=
null
|
|
html
=
=
=
'
'
)
{
return
new
ConcreteBounds
(
parent
null
null
)
;
}
if
(
nextSibling
=
=
=
null
)
{
parent
.
insertAdjacentHTML
(
'
beforeend
'
html
)
;
last
=
parent
.
lastChild
;
}
else
if
(
nextSibling
instanceof
HTMLElement
)
{
nextSibling
.
insertAdjacentHTML
(
'
beforebegin
'
html
)
;
last
=
nextSibling
.
previousSibling
;
}
else
{
parent
.
insertBefore
(
useless
nextSibling
)
;
useless
.
insertAdjacentHTML
(
'
beforebegin
'
html
)
;
last
=
useless
.
previousSibling
;
parent
.
removeChild
(
useless
)
;
}
var
first
=
prev
?
prev
.
nextSibling
:
parent
.
firstChild
;
return
new
ConcreteBounds
(
parent
first
last
)
;
}
function
isDocumentFragment
(
node
)
{
return
node
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
;
}
var
helper
=
DOMChanges
;
helper
=
domChanges
2
(
doc
helper
)
;
helper
=
domChanges
(
doc
helper
)
;
helper
=
domChanges
1
(
doc
helper
SVG_NAMESPACE
)
;
var
helper
1
=
helper
;
var
DOMTreeConstruction
=
DOM
.
DOMTreeConstruction
;
function
_defaults
10
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
_possibleConstructorReturn
10
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
10
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
10
(
subClass
superClass
)
;
}
function
_classCallCheck
25
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
defaultManagers
(
element
attr
_isTrusting
_namespace
)
{
var
tagName
=
element
.
tagName
;
var
isSVG
=
element
.
namespaceURI
=
=
=
SVG_NAMESPACE
;
if
(
isSVG
)
{
return
defaultAttributeManagers
(
tagName
attr
)
;
}
var
_normalizeProperty
=
normalizeProperty
(
element
attr
)
type
=
_normalizeProperty
.
type
normalized
=
_normalizeProperty
.
normalized
;
if
(
type
=
=
=
'
attr
'
)
{
return
defaultAttributeManagers
(
tagName
normalized
)
;
}
else
{
return
defaultPropertyManagers
(
tagName
normalized
)
;
}
}
function
defaultPropertyManagers
(
tagName
attr
)
{
if
(
requiresSanitization
(
tagName
attr
)
)
{
return
new
SafePropertyManager
(
attr
)
;
}
if
(
isUserInputValue
(
tagName
attr
)
)
{
return
INPUT_VALUE_PROPERTY_MANAGER
;
}
if
(
isOptionSelected
(
tagName
attr
)
)
{
return
OPTION_SELECTED_MANAGER
;
}
return
new
PropertyManager
(
attr
)
;
}
function
defaultAttributeManagers
(
tagName
attr
)
{
if
(
requiresSanitization
(
tagName
attr
)
)
{
return
new
SafeAttributeManager
(
attr
)
;
}
return
new
AttributeManager
(
attr
)
;
}
function
readDOMAttr
(
element
attr
)
{
var
isSVG
=
element
.
namespaceURI
=
=
=
SVG_NAMESPACE
;
var
_normalizeProperty2
=
normalizeProperty
(
element
attr
)
type
=
_normalizeProperty2
.
type
normalized
=
_normalizeProperty2
.
normalized
;
if
(
isSVG
)
{
return
element
.
getAttribute
(
normalized
)
;
}
if
(
type
=
=
=
'
attr
'
)
{
return
element
.
getAttribute
(
normalized
)
;
}
{
return
element
[
normalized
]
;
}
}
var
AttributeManager
=
function
(
)
{
function
AttributeManager
(
attr
)
{
_classCallCheck
25
(
this
AttributeManager
)
;
this
.
attr
=
attr
;
}
AttributeManager
.
prototype
.
setAttribute
=
function
setAttribute
(
env
element
value
namespace
)
{
var
dom
=
env
.
getAppendOperations
(
)
;
var
normalizedValue
=
normalizeAttributeValue
(
value
)
;
if
(
!
isAttrRemovalValue
(
normalizedValue
)
)
{
dom
.
setAttribute
(
element
this
.
attr
normalizedValue
namespace
)
;
}
}
;
AttributeManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
env
element
value
namespace
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
|
|
value
=
=
=
false
)
{
if
(
namespace
)
{
env
.
getDOM
(
)
.
removeAttributeNS
(
element
namespace
this
.
attr
)
;
}
else
{
env
.
getDOM
(
)
.
removeAttribute
(
element
this
.
attr
)
;
}
}
else
{
this
.
setAttribute
(
env
element
value
)
;
}
}
;
return
AttributeManager
;
}
(
)
;
var
PropertyManager
=
function
(
_AttributeManager
)
{
_inherits
10
(
PropertyManager
_AttributeManager
)
;
function
PropertyManager
(
)
{
_classCallCheck
25
(
this
PropertyManager
)
;
return
_possibleConstructorReturn
10
(
this
_AttributeManager
.
apply
(
this
arguments
)
)
;
}
PropertyManager
.
prototype
.
setAttribute
=
function
setAttribute
(
_env
element
value
_namespace
)
{
if
(
!
isAttrRemovalValue
(
value
)
)
{
element
[
this
.
attr
]
=
value
;
}
}
;
PropertyManager
.
prototype
.
removeAttribute
=
function
removeAttribute
(
env
element
namespace
)
{
var
attr
=
this
.
attr
;
if
(
namespace
)
{
env
.
getDOM
(
)
.
removeAttributeNS
(
element
namespace
attr
)
;
}
else
{
env
.
getDOM
(
)
.
removeAttribute
(
element
attr
)
;
}
}
;
PropertyManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
env
element
value
namespace
)
{
element
[
this
.
attr
]
=
value
;
if
(
isAttrRemovalValue
(
value
)
)
{
this
.
removeAttribute
(
env
element
namespace
)
;
}
}
;
return
PropertyManager
;
}
(
AttributeManager
)
;
function
normalizeAttributeValue
(
value
)
{
if
(
value
=
=
=
false
|
|
value
=
=
=
undefined
|
|
value
=
=
=
null
)
{
return
null
;
}
if
(
value
=
=
=
true
)
{
return
'
'
;
}
if
(
typeof
value
=
=
=
'
function
'
)
{
return
null
;
}
return
String
(
value
)
;
}
function
isAttrRemovalValue
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
;
}
var
SafePropertyManager
=
function
(
_PropertyManager
)
{
_inherits
10
(
SafePropertyManager
_PropertyManager
)
;
function
SafePropertyManager
(
)
{
_classCallCheck
25
(
this
SafePropertyManager
)
;
return
_possibleConstructorReturn
10
(
this
_PropertyManager
.
apply
(
this
arguments
)
)
;
}
SafePropertyManager
.
prototype
.
setAttribute
=
function
setAttribute
(
env
element
value
)
{
_PropertyManager
.
prototype
.
setAttribute
.
call
(
this
env
element
sanitizeAttributeValue
(
env
element
this
.
attr
value
)
)
;
}
;
SafePropertyManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
env
element
value
)
{
_PropertyManager
.
prototype
.
updateAttribute
.
call
(
this
env
element
sanitizeAttributeValue
(
env
element
this
.
attr
value
)
)
;
}
;
return
SafePropertyManager
;
}
(
PropertyManager
)
;
function
isUserInputValue
(
tagName
attribute
)
{
return
(
tagName
=
=
=
'
INPUT
'
|
|
tagName
=
=
=
'
TEXTAREA
'
)
&
&
attribute
=
=
=
'
value
'
;
}
var
InputValuePropertyManager
=
function
(
_AttributeManager2
)
{
_inherits
10
(
InputValuePropertyManager
_AttributeManager2
)
;
function
InputValuePropertyManager
(
)
{
_classCallCheck
25
(
this
InputValuePropertyManager
)
;
return
_possibleConstructorReturn
10
(
this
_AttributeManager2
.
apply
(
this
arguments
)
)
;
}
InputValuePropertyManager
.
prototype
.
setAttribute
=
function
setAttribute
(
_env
element
value
)
{
var
input
=
element
;
input
.
value
=
normalizeTextValue
(
value
)
;
}
;
InputValuePropertyManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
_env
element
value
)
{
var
input
=
element
;
var
currentValue
=
input
.
value
;
var
normalizedValue
=
normalizeTextValue
(
value
)
;
if
(
currentValue
!
=
=
normalizedValue
)
{
input
.
value
=
normalizedValue
;
}
}
;
return
InputValuePropertyManager
;
}
(
AttributeManager
)
;
var
INPUT_VALUE_PROPERTY_MANAGER
=
new
InputValuePropertyManager
(
'
value
'
)
;
function
isOptionSelected
(
tagName
attribute
)
{
return
tagName
=
=
=
'
OPTION
'
&
&
attribute
=
=
=
'
selected
'
;
}
var
OptionSelectedManager
=
function
(
_PropertyManager2
)
{
_inherits
10
(
OptionSelectedManager
_PropertyManager2
)
;
function
OptionSelectedManager
(
)
{
_classCallCheck
25
(
this
OptionSelectedManager
)
;
return
_possibleConstructorReturn
10
(
this
_PropertyManager2
.
apply
(
this
arguments
)
)
;
}
OptionSelectedManager
.
prototype
.
setAttribute
=
function
setAttribute
(
_env
element
value
)
{
if
(
value
!
=
=
null
&
&
value
!
=
=
undefined
&
&
value
!
=
=
false
)
{
var
option
=
element
;
option
.
selected
=
true
;
}
}
;
OptionSelectedManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
_env
element
value
)
{
var
option
=
element
;
if
(
value
)
{
option
.
selected
=
true
;
}
else
{
option
.
selected
=
false
;
}
}
;
return
OptionSelectedManager
;
}
(
PropertyManager
)
;
var
OPTION_SELECTED_MANAGER
=
new
OptionSelectedManager
(
'
selected
'
)
;
var
SafeAttributeManager
=
function
(
_AttributeManager3
)
{
_inherits
10
(
SafeAttributeManager
_AttributeManager3
)
;
function
SafeAttributeManager
(
)
{
_classCallCheck
25
(
this
SafeAttributeManager
)
;
return
_possibleConstructorReturn
10
(
this
_AttributeManager3
.
apply
(
this
arguments
)
)
;
}
SafeAttributeManager
.
prototype
.
setAttribute
=
function
setAttribute
(
env
element
value
)
{
_AttributeManager3
.
prototype
.
setAttribute
.
call
(
this
env
element
sanitizeAttributeValue
(
env
element
this
.
attr
value
)
)
;
}
;
SafeAttributeManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
env
element
value
_namespace
)
{
_AttributeManager3
.
prototype
.
updateAttribute
.
call
(
this
env
element
sanitizeAttributeValue
(
env
element
this
.
attr
value
)
)
;
}
;
return
SafeAttributeManager
;
}
(
AttributeManager
)
;
var
_createClass
4
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_classCallCheck
23
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
Scope
=
function
(
)
{
function
Scope
(
slots
callerScope
evalScope
partialMap
)
{
_classCallCheck
23
(
this
Scope
)
;
this
.
slots
=
slots
;
this
.
callerScope
=
callerScope
;
this
.
evalScope
=
evalScope
;
this
.
partialMap
=
partialMap
;
}
Scope
.
root
=
function
root
(
self
)
{
var
size
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
0
;
var
refs
=
new
Array
(
size
+
1
)
;
for
(
var
i
=
0
;
i
<
=
size
;
i
+
+
)
{
refs
[
i
]
=
UNDEFINED_REFERENCE
;
}
return
new
Scope
(
refs
null
null
null
)
.
init
(
{
self
:
self
}
)
;
}
;
Scope
.
sized
=
function
sized
(
)
{
var
size
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
0
;
var
refs
=
new
Array
(
size
+
1
)
;
for
(
var
i
=
0
;
i
<
=
size
;
i
+
+
)
{
refs
[
i
]
=
UNDEFINED_REFERENCE
;
}
return
new
Scope
(
refs
null
null
null
)
;
}
;
Scope
.
prototype
.
init
=
function
init
(
_ref
)
{
var
self
=
_ref
.
self
;
this
.
slots
[
0
]
=
self
;
return
this
;
}
;
Scope
.
prototype
.
getSelf
=
function
getSelf
(
)
{
return
this
.
get
(
0
)
;
}
;
Scope
.
prototype
.
getSymbol
=
function
getSymbol
(
symbol
)
{
return
this
.
get
(
symbol
)
;
}
;
Scope
.
prototype
.
getBlock
=
function
getBlock
(
symbol
)
{
return
this
.
get
(
symbol
)
;
}
;
Scope
.
prototype
.
getEvalScope
=
function
getEvalScope
(
)
{
return
this
.
evalScope
;
}
;
Scope
.
prototype
.
getPartialMap
=
function
getPartialMap
(
)
{
return
this
.
partialMap
;
}
;
Scope
.
prototype
.
bind
=
function
bind
(
symbol
value
)
{
this
.
set
(
symbol
value
)
;
}
;
Scope
.
prototype
.
bindSelf
=
function
bindSelf
(
self
)
{
this
.
set
(
0
self
)
;
}
;
Scope
.
prototype
.
bindSymbol
=
function
bindSymbol
(
symbol
value
)
{
this
.
set
(
symbol
value
)
;
}
;
Scope
.
prototype
.
bindBlock
=
function
bindBlock
(
symbol
value
)
{
this
.
set
(
symbol
value
)
;
}
;
Scope
.
prototype
.
bindEvalScope
=
function
bindEvalScope
(
map
1
)
{
this
.
evalScope
=
map
1
;
}
;
Scope
.
prototype
.
bindPartialMap
=
function
bindPartialMap
(
map
1
)
{
this
.
partialMap
=
map
1
;
}
;
Scope
.
prototype
.
bindCallerScope
=
function
bindCallerScope
(
scope
)
{
this
.
callerScope
=
scope
;
}
;
Scope
.
prototype
.
getCallerScope
=
function
getCallerScope
(
)
{
return
this
.
callerScope
;
}
;
Scope
.
prototype
.
child
=
function
child
(
)
{
return
new
Scope
(
this
.
slots
.
slice
(
)
this
.
callerScope
this
.
evalScope
this
.
partialMap
)
;
}
;
Scope
.
prototype
.
get
=
function
get
(
index
)
{
if
(
index
>
=
this
.
slots
.
length
)
{
throw
new
RangeError
(
'
BUG
:
cannot
get
'
+
index
+
'
from
scope
;
length
=
'
+
this
.
slots
.
length
)
;
}
return
this
.
slots
[
index
]
;
}
;
Scope
.
prototype
.
set
=
function
set
(
index
value
)
{
if
(
index
>
=
this
.
slots
.
length
)
{
throw
new
RangeError
(
'
BUG
:
cannot
get
'
+
index
+
'
from
scope
;
length
=
'
+
this
.
slots
.
length
)
;
}
this
.
slots
[
index
]
=
value
;
}
;
return
Scope
;
}
(
)
;
var
Transaction
=
function
(
)
{
function
Transaction
(
)
{
_classCallCheck
23
(
this
Transaction
)
;
this
.
scheduledInstallManagers
=
[
]
;
this
.
scheduledInstallModifiers
=
[
]
;
this
.
scheduledUpdateModifierManagers
=
[
]
;
this
.
scheduledUpdateModifiers
=
[
]
;
this
.
createdComponents
=
[
]
;
this
.
createdManagers
=
[
]
;
this
.
updatedComponents
=
[
]
;
this
.
updatedManagers
=
[
]
;
this
.
destructors
=
[
]
;
}
Transaction
.
prototype
.
didCreate
=
function
didCreate
(
component
manager
)
{
this
.
createdComponents
.
push
(
component
)
;
this
.
createdManagers
.
push
(
manager
)
;
}
;
Transaction
.
prototype
.
didUpdate
=
function
didUpdate
(
component
manager
)
{
this
.
updatedComponents
.
push
(
component
)
;
this
.
updatedManagers
.
push
(
manager
)
;
}
;
Transaction
.
prototype
.
scheduleInstallModifier
=
function
scheduleInstallModifier
(
modifier
manager
)
{
this
.
scheduledInstallManagers
.
push
(
manager
)
;
this
.
scheduledInstallModifiers
.
push
(
modifier
)
;
}
;
Transaction
.
prototype
.
scheduleUpdateModifier
=
function
scheduleUpdateModifier
(
modifier
manager
)
{
this
.
scheduledUpdateModifierManagers
.
push
(
manager
)
;
this
.
scheduledUpdateModifiers
.
push
(
modifier
)
;
}
;
Transaction
.
prototype
.
didDestroy
=
function
didDestroy
(
d
)
{
this
.
destructors
.
push
(
d
)
;
}
;
Transaction
.
prototype
.
commit
=
function
commit
(
)
{
var
createdComponents
=
this
.
createdComponents
createdManagers
=
this
.
createdManagers
;
for
(
var
i
=
0
;
i
<
createdComponents
.
length
;
i
+
+
)
{
var
component
=
createdComponents
[
i
]
;
var
manager
=
createdManagers
[
i
]
;
manager
.
didCreate
(
component
)
;
}
var
updatedComponents
=
this
.
updatedComponents
updatedManagers
=
this
.
updatedManagers
;
for
(
var
_i
=
0
;
_i
<
updatedComponents
.
length
;
_i
+
+
)
{
var
_component
=
updatedComponents
[
_i
]
;
var
_manager
=
updatedManagers
[
_i
]
;
_manager
.
didUpdate
(
_component
)
;
}
var
destructors
=
this
.
destructors
;
for
(
var
_i2
=
0
;
_i2
<
destructors
.
length
;
_i2
+
+
)
{
destructors
[
_i2
]
.
destroy
(
)
;
}
var
scheduledInstallManagers
=
this
.
scheduledInstallManagers
scheduledInstallModifiers
=
this
.
scheduledInstallModifiers
;
for
(
var
_i3
=
0
;
_i3
<
scheduledInstallManagers
.
length
;
_i3
+
+
)
{
var
_manager2
=
scheduledInstallManagers
[
_i3
]
;
var
modifier
=
scheduledInstallModifiers
[
_i3
]
;
_manager2
.
install
(
modifier
)
;
}
var
scheduledUpdateModifierManagers
=
this
.
scheduledUpdateModifierManagers
scheduledUpdateModifiers
=
this
.
scheduledUpdateModifiers
;
for
(
var
_i4
=
0
;
_i4
<
scheduledUpdateModifierManagers
.
length
;
_i4
+
+
)
{
var
_manager3
=
scheduledUpdateModifierManagers
[
_i4
]
;
var
_modifier
=
scheduledUpdateModifiers
[
_i4
]
;
_manager3
.
update
(
_modifier
)
;
}
}
;
return
Transaction
;
}
(
)
;
var
Opcode
=
function
(
)
{
function
Opcode
(
heap
)
{
_classCallCheck
23
(
this
Opcode
)
;
this
.
heap
=
heap
;
this
.
offset
=
0
;
}
_createClass
4
(
Opcode
[
{
key
:
'
type
'
get
:
function
(
)
{
return
this
.
heap
.
getbyaddr
(
this
.
offset
)
;
}
}
{
key
:
'
op1
'
get
:
function
(
)
{
return
this
.
heap
.
getbyaddr
(
this
.
offset
+
1
)
;
}
}
{
key
:
'
op2
'
get
:
function
(
)
{
return
this
.
heap
.
getbyaddr
(
this
.
offset
+
2
)
;
}
}
{
key
:
'
op3
'
get
:
function
(
)
{
return
this
.
heap
.
getbyaddr
(
this
.
offset
+
3
)
;
}
}
]
)
;
return
Opcode
;
}
(
)
;
var
TableSlotState
;
(
function
(
TableSlotState
)
{
TableSlotState
[
TableSlotState
[
"
Allocated
"
]
=
0
]
=
"
Allocated
"
;
TableSlotState
[
TableSlotState
[
"
Freed
"
]
=
1
]
=
"
Freed
"
;
TableSlotState
[
TableSlotState
[
"
Purged
"
]
=
2
]
=
"
Purged
"
;
TableSlotState
[
TableSlotState
[
"
Pointer
"
]
=
3
]
=
"
Pointer
"
;
}
)
(
TableSlotState
|
|
(
TableSlotState
=
{
}
)
)
;
var
Heap
=
function
(
)
{
function
Heap
(
)
{
_classCallCheck
23
(
this
Heap
)
;
this
.
heap
=
[
]
;
this
.
offset
=
0
;
this
.
handle
=
0
;
this
.
table
=
[
]
;
}
Heap
.
prototype
.
push
=
function
push
(
item
)
{
this
.
heap
[
this
.
offset
+
+
]
=
item
;
}
;
Heap
.
prototype
.
getbyaddr
=
function
getbyaddr
(
address
)
{
return
this
.
heap
[
address
]
;
}
;
Heap
.
prototype
.
setbyaddr
=
function
setbyaddr
(
address
value
)
{
this
.
heap
[
address
]
=
value
;
}
;
Heap
.
prototype
.
malloc
=
function
malloc
(
)
{
this
.
table
.
push
(
this
.
offset
0
0
)
;
var
handle
=
this
.
handle
;
this
.
handle
+
=
3
;
return
handle
;
}
;
Heap
.
prototype
.
finishMalloc
=
function
finishMalloc
(
handle
)
{
var
start
=
this
.
table
[
handle
]
;
var
finish
=
this
.
offset
;
this
.
table
[
handle
+
1
]
=
finish
-
start
;
}
;
Heap
.
prototype
.
size
=
function
size
(
)
{
return
this
.
offset
;
}
;
Heap
.
prototype
.
getaddr
=
function
getaddr
(
handle
)
{
return
this
.
table
[
handle
]
;
}
;
Heap
.
prototype
.
gethandle
=
function
gethandle
(
address
)
{
this
.
table
.
push
(
address
0
TableSlotState
.
Pointer
)
;
var
handle
=
this
.
handle
;
this
.
handle
+
=
3
;
return
handle
;
}
;
Heap
.
prototype
.
sizeof
=
function
sizeof
(
handle
)
{
return
-
1
;
}
;
Heap
.
prototype
.
free
=
function
free
(
handle
)
{
this
.
table
[
handle
+
2
]
=
1
;
}
;
Heap
.
prototype
.
compact
=
function
compact
(
)
{
var
compactedSize
=
0
;
var
table
=
this
.
table
length
=
this
.
table
.
length
heap
=
this
.
heap
;
for
(
var
i
=
0
;
i
<
length
;
i
+
=
3
)
{
var
offset
=
table
[
i
]
;
var
size
=
table
[
i
+
1
]
;
var
state
=
table
[
i
+
2
]
;
if
(
state
=
=
=
TableSlotState
.
Purged
)
{
continue
;
}
else
if
(
state
=
=
=
TableSlotState
.
Freed
)
{
table
[
i
+
2
]
=
2
;
compactedSize
+
=
size
;
}
else
if
(
state
=
=
=
TableSlotState
.
Allocated
)
{
for
(
var
j
=
offset
;
j
<
=
i
+
size
;
j
+
+
)
{
heap
[
j
-
compactedSize
]
=
heap
[
j
]
;
}
table
[
i
]
=
offset
-
compactedSize
;
}
else
if
(
state
=
=
=
TableSlotState
.
Pointer
)
{
table
[
i
]
=
offset
-
compactedSize
;
}
}
this
.
offset
=
this
.
offset
-
compactedSize
;
}
;
return
Heap
;
}
(
)
;
var
Program
=
function
(
)
{
function
Program
(
)
{
_classCallCheck
23
(
this
Program
)
;
this
.
heap
=
new
Heap
(
)
;
this
.
_opcode
=
new
Opcode
(
this
.
heap
)
;
this
.
constants
=
new
Constants
(
)
;
}
Program
.
prototype
.
opcode
=
function
opcode
(
offset
)
{
this
.
_opcode
.
offset
=
offset
;
return
this
.
_opcode
;
}
;
return
Program
;
}
(
)
;
var
Environment
=
function
(
)
{
function
Environment
(
_ref2
)
{
var
appendOperations
=
_ref2
.
appendOperations
updateOperations
=
_ref2
.
updateOperations
;
_classCallCheck
23
(
this
Environment
)
;
this
.
_macros
=
null
;
this
.
_transaction
=
null
;
this
.
program
=
new
Program
(
)
;
this
.
appendOperations
=
appendOperations
;
this
.
updateOperations
=
updateOperations
;
}
Environment
.
prototype
.
toConditionalReference
=
function
toConditionalReference
(
reference
1
)
{
return
new
ConditionalReference
(
reference
1
)
;
}
;
Environment
.
prototype
.
getAppendOperations
=
function
getAppendOperations
(
)
{
return
this
.
appendOperations
;
}
;
Environment
.
prototype
.
getDOM
=
function
getDOM
(
)
{
return
this
.
updateOperations
;
}
;
Environment
.
prototype
.
getIdentity
=
function
getIdentity
(
object
)
{
return
(
0
_util
.
ensureGuid
)
(
object
)
+
'
'
;
}
;
Environment
.
prototype
.
begin
=
function
begin
(
)
{
(
0
_util
.
assert
)
(
!
this
.
_transaction
'
a
glimmer
transaction
was
begun
but
one
already
exists
.
You
may
have
a
nested
transaction
'
)
;
this
.
_transaction
=
new
Transaction
(
)
;
}
;
Environment
.
prototype
.
didCreate
=
function
didCreate
(
component
manager
)
{
this
.
transaction
.
didCreate
(
component
manager
)
;
}
;
Environment
.
prototype
.
didUpdate
=
function
didUpdate
(
component
manager
)
{
this
.
transaction
.
didUpdate
(
component
manager
)
;
}
;
Environment
.
prototype
.
scheduleInstallModifier
=
function
scheduleInstallModifier
(
modifier
manager
)
{
this
.
transaction
.
scheduleInstallModifier
(
modifier
manager
)
;
}
;
Environment
.
prototype
.
scheduleUpdateModifier
=
function
scheduleUpdateModifier
(
modifier
manager
)
{
this
.
transaction
.
scheduleUpdateModifier
(
modifier
manager
)
;
}
;
Environment
.
prototype
.
didDestroy
=
function
didDestroy
(
d
)
{
this
.
transaction
.
didDestroy
(
d
)
;
}
;
Environment
.
prototype
.
commit
=
function
commit
(
)
{
var
transaction
=
this
.
transaction
;
this
.
_transaction
=
null
;
transaction
.
commit
(
)
;
}
;
Environment
.
prototype
.
attributeFor
=
function
attributeFor
(
element
attr
isTrusting
namespace
)
{
return
defaultManagers
(
element
attr
isTrusting
namespace
=
=
=
undefined
?
null
:
namespace
)
;
}
;
Environment
.
prototype
.
macros
=
function
macros
(
)
{
var
macros
=
this
.
_macros
;
if
(
!
macros
)
{
this
.
_macros
=
macros
=
this
.
populateBuiltins
(
)
;
}
return
macros
;
}
;
Environment
.
prototype
.
populateBuiltins
=
function
populateBuiltins
1
(
)
{
return
populateBuiltins
(
)
;
}
;
_createClass
4
(
Environment
[
{
key
:
'
transaction
'
get
:
function
(
)
{
return
this
.
_transaction
;
}
}
]
)
;
return
Environment
;
}
(
)
;
function
_defaults
15
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
var
_createClass
5
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_possibleConstructorReturn
15
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
15
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
_defaults
15
(
subClass
superClass
)
;
}
function
_classCallCheck
30
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
UpdatingVM
=
function
(
)
{
function
UpdatingVM
(
env
_ref
)
{
var
_ref
alwaysRevalidate
=
_ref
.
alwaysRevalidate
alwaysRevalidate
=
_ref
alwaysRevalidate
=
=
=
undefined
?
false
:
_ref
alwaysRevalidate
;
_classCallCheck
30
(
this
UpdatingVM
)
;
this
.
frameStack
=
new
_util
.
Stack
(
)
;
this
.
env
=
env
;
this
.
constants
=
env
.
program
.
constants
;
this
.
dom
=
env
.
getDOM
(
)
;
this
.
alwaysRevalidate
=
alwaysRevalidate
;
}
UpdatingVM
.
prototype
.
execute
=
function
execute
(
opcodes
handler
)
{
var
frameStack
=
this
.
frameStack
;
this
.
try
(
opcodes
handler
)
;
while
(
true
)
{
if
(
frameStack
.
isEmpty
(
)
)
break
;
var
opcode
=
this
.
frame
.
nextStatement
(
)
;
if
(
opcode
=
=
=
null
)
{
this
.
frameStack
.
pop
(
)
;
continue
;
}
opcode
.
evaluate
(
this
)
;
}
}
;
UpdatingVM
.
prototype
.
goto
=
function
goto
(
op
)
{
this
.
frame
.
goto
(
op
)
;
}
;
UpdatingVM
.
prototype
.
try
=
function
_try
(
ops
handler
)
{
this
.
frameStack
.
push
(
new
UpdatingVMFrame
(
this
ops
handler
)
)
;
}
;
UpdatingVM
.
prototype
.
throw
=
function
_throw
(
)
{
this
.
frame
.
handleException
(
)
;
this
.
frameStack
.
pop
(
)
;
}
;
UpdatingVM
.
prototype
.
evaluateOpcode
=
function
evaluateOpcode
(
opcode
)
{
opcode
.
evaluate
(
this
)
;
}
;
_createClass
5
(
UpdatingVM
[
{
key
:
'
frame
'
get
:
function
(
)
{
return
this
.
frameStack
.
current
;
}
}
]
)
;
return
UpdatingVM
;
}
(
)
;
var
BlockOpcode
=
function
(
_UpdatingOpcode
)
{
_inherits
15
(
BlockOpcode
_UpdatingOpcode
)
;
function
BlockOpcode
(
start
state
bounds
1
children
)
{
_classCallCheck
30
(
this
BlockOpcode
)
;
var
_this
=
_possibleConstructorReturn
15
(
this
_UpdatingOpcode
.
call
(
this
)
)
;
_this
.
start
=
start
;
_this
.
type
=
"
block
"
;
_this
.
next
=
null
;
_this
.
prev
=
null
;
var
env
=
state
.
env
scope
=
state
.
scope
dynamicScope
=
state
.
dynamicScope
stack
=
state
.
stack
;
_this
.
children
=
children
;
_this
.
env
=
env
;
_this
.
scope
=
scope
;
_this
.
dynamicScope
=
dynamicScope
;
_this
.
stack
=
stack
;
_this
.
bounds
=
bounds
1
;
return
_this
;
}
BlockOpcode
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
bounds
.
parentElement
(
)
;
}
;
BlockOpcode
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
bounds
.
firstNode
(
)
;
}
;
BlockOpcode
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
bounds
.
lastNode
(
)
;
}
;
BlockOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
vm
.
try
(
this
.
children
null
)
;
}
;
BlockOpcode
.
prototype
.
destroy
=
function
destroy
(
)
{
this
.
bounds
.
destroy
(
)
;
}
;
BlockOpcode
.
prototype
.
didDestroy
=
function
didDestroy
(
)
{
this
.
env
.
didDestroy
(
this
.
bounds
)
;
}
;
BlockOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
details
=
(
0
_util
.
dict
)
(
)
;
details
[
"
guid
"
]
=
'
'
+
this
.
_guid
;
return
{
guid
:
this
.
_guid
type
:
this
.
type
details
:
details
children
:
this
.
children
.
toArray
(
)
.
map
(
function
(
op
)
{
return
op
.
toJSON
(
)
;
}
)
}
;
}
;
return
BlockOpcode
;
}
(
UpdatingOpcode
)
;
var
TryOpcode
=
function
(
_BlockOpcode
)
{
_inherits
15
(
TryOpcode
_BlockOpcode
)
;
function
TryOpcode
(
start
state
bounds
1
children
)
{
_classCallCheck
30
(
this
TryOpcode
)
;
var
_this2
=
_possibleConstructorReturn
15
(
this
_BlockOpcode
.
call
(
this
start
state
bounds
1
children
)
)
;
_this2
.
type
=
"
try
"
;
_this2
.
tag
=
_this2
.
_tag
=
_reference2
.
UpdatableTag
.
create
(
_reference2
.
CONSTANT_TAG
)
;
return
_this2
;
}
TryOpcode
.
prototype
.
didInitializeChildren
=
function
didInitializeChildren
(
)
{
this
.
_tag
.
inner
.
update
(
(
0
_reference2
.
combineSlice
)
(
this
.
children
)
)
;
}
;
TryOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
vm
.
try
(
this
.
children
this
)
;
}
;
TryOpcode
.
prototype
.
handleException
=
function
handleException
(
)
{
var
_this3
=
this
;
var
env
=
this
.
env
bounds
1
=
this
.
bounds
children
=
this
.
children
scope
=
this
.
scope
dynamicScope
=
this
.
dynamicScope
start
=
this
.
start
stack
=
this
.
stack
prev
=
this
.
prev
next
=
this
.
next
;
children
.
clear
(
)
;
var
elementStack
=
ElementStack
.
resume
(
env
bounds
1
bounds
1
.
reset
(
env
)
)
;
var
vm
=
new
VM
(
env
scope
dynamicScope
elementStack
)
;
var
updating
=
new
_util
.
LinkedList
(
)
;
vm
.
execute
(
start
function
(
vm
)
{
vm
.
stack
=
EvaluationStack
.
restore
(
stack
)
;
vm
.
updatingOpcodeStack
.
push
(
updating
)
;
vm
.
updateWith
(
_this3
)
;
vm
.
updatingOpcodeStack
.
push
(
children
)
;
}
)
;
this
.
prev
=
prev
;
this
.
next
=
next
;
}
;
TryOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
json
=
_BlockOpcode
.
prototype
.
toJSON
.
call
(
this
)
;
var
details
=
json
[
"
details
"
]
;
if
(
!
details
)
{
details
=
json
[
"
details
"
]
=
{
}
;
}
return
_BlockOpcode
.
prototype
.
toJSON
.
call
(
this
)
;
}
;
return
TryOpcode
;
}
(
BlockOpcode
)
;
var
ListRevalidationDelegate
=
function
(
)
{
function
ListRevalidationDelegate
(
opcode
marker
)
{
_classCallCheck
30
(
this
ListRevalidationDelegate
)
;
this
.
opcode
=
opcode
;
this
.
marker
=
marker
;
this
.
didInsert
=
false
;
this
.
didDelete
=
false
;
this
.
map
=
opcode
.
map
;
this
.
updating
=
opcode
[
'
children
'
]
;
}
ListRevalidationDelegate
.
prototype
.
insert
=
function
insert
(
key
item
memo
before
)
{
var
map
1
=
this
.
map
opcode
=
this
.
opcode
updating
=
this
.
updating
;
var
nextSibling
=
null
;
var
reference
1
=
null
;
if
(
before
)
{
reference
1
=
map
1
[
before
]
;
nextSibling
=
reference
1
[
'
bounds
'
]
.
firstNode
(
)
;
}
else
{
nextSibling
=
this
.
marker
;
}
var
vm
=
opcode
.
vmForInsertion
(
nextSibling
)
;
var
tryOpcode
=
null
;
var
start
=
opcode
.
start
;
vm
.
execute
(
start
function
(
vm
)
{
map
1
[
key
]
=
tryOpcode
=
vm
.
iterate
(
memo
item
)
;
vm
.
updatingOpcodeStack
.
push
(
new
_util
.
LinkedList
(
)
)
;
vm
.
updateWith
(
tryOpcode
)
;
vm
.
updatingOpcodeStack
.
push
(
tryOpcode
.
children
)
;
}
)
;
updating
.
insertBefore
(
tryOpcode
reference
1
)
;
this
.
didInsert
=
true
;
}
;
ListRevalidationDelegate
.
prototype
.
retain
=
function
retain
(
_key
_item
_memo
)
{
}
;
ListRevalidationDelegate
.
prototype
.
move
=
function
move
1
(
key
_item
_memo
before
)
{
var
map
1
=
this
.
map
updating
=
this
.
updating
;
var
entry
=
map
1
[
key
]
;
var
reference
1
=
map
1
[
before
]
|
|
null
;
if
(
before
)
{
move
(
entry
reference
1
.
firstNode
(
)
)
;
}
else
{
move
(
entry
this
.
marker
)
;
}
updating
.
remove
(
entry
)
;
updating
.
insertBefore
(
entry
reference
1
)
;
}
;
ListRevalidationDelegate
.
prototype
.
delete
=
function
_delete
(
key
)
{
var
map
1
=
this
.
map
;
var
opcode
=
map
1
[
key
]
;
opcode
.
didDestroy
(
)
;
clear
(
opcode
)
;
this
.
updating
.
remove
(
opcode
)
;
delete
map
1
[
key
]
;
this
.
didDelete
=
true
;
}
;
ListRevalidationDelegate
.
prototype
.
done
=
function
done
(
)
{
this
.
opcode
.
didInitializeChildren
(
this
.
didInsert
|
|
this
.
didDelete
)
;
}
;
return
ListRevalidationDelegate
;
}
(
)
;
var
ListBlockOpcode
=
function
(
_BlockOpcode2
)
{
_inherits
15
(
ListBlockOpcode
_BlockOpcode2
)
;
function
ListBlockOpcode
(
start
state
bounds
1
children
artifacts
)
{
_classCallCheck
30
(
this
ListBlockOpcode
)
;
var
_this4
=
_possibleConstructorReturn
15
(
this
_BlockOpcode2
.
call
(
this
start
state
bounds
1
children
)
)
;
_this4
.
type
=
"
list
-
block
"
;
_this4
.
map
=
(
0
_util
.
dict
)
(
)
;
_this4
.
lastIterated
=
_reference2
.
INITIAL
;
_this4
.
artifacts
=
artifacts
;
var
_tag
=
_this4
.
_tag
=
_reference2
.
UpdatableTag
.
create
(
_reference2
.
CONSTANT_TAG
)
;
_this4
.
tag
=
(
0
_reference2
.
combine
)
(
[
artifacts
.
tag
_tag
]
)
;
return
_this4
;
}
ListBlockOpcode
.
prototype
.
didInitializeChildren
=
function
didInitializeChildren
(
)
{
var
listDidChange
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
true
;
this
.
lastIterated
=
this
.
artifacts
.
tag
.
value
(
)
;
if
(
listDidChange
)
{
this
.
_tag
.
inner
.
update
(
(
0
_reference2
.
combineSlice
)
(
this
.
children
)
)
;
}
}
;
ListBlockOpcode
.
prototype
.
evaluate
=
function
evaluate
(
vm
)
{
var
artifacts
=
this
.
artifacts
lastIterated
=
this
.
lastIterated
;
if
(
!
artifacts
.
tag
.
validate
(
lastIterated
)
)
{
var
bounds
1
=
this
.
bounds
;
var
dom
=
vm
.
dom
;
var
marker
=
dom
.
createComment
(
'
'
)
;
dom
.
insertAfter
(
bounds
1
.
parentElement
(
)
marker
bounds
1
.
lastNode
(
)
)
;
var
target
=
new
ListRevalidationDelegate
(
this
marker
)
;
var
synchronizer
=
new
_reference2
.
IteratorSynchronizer
(
{
target
:
target
artifacts
:
artifacts
}
)
;
synchronizer
.
sync
(
)
;
this
.
parentElement
(
)
.
removeChild
(
marker
)
;
}
_BlockOpcode2
.
prototype
.
evaluate
.
call
(
this
vm
)
;
}
;
ListBlockOpcode
.
prototype
.
vmForInsertion
=
function
vmForInsertion
(
nextSibling
)
{
var
env
=
this
.
env
scope
=
this
.
scope
dynamicScope
=
this
.
dynamicScope
;
var
elementStack
=
ElementStack
.
forInitialRender
(
this
.
env
this
.
bounds
.
parentElement
(
)
nextSibling
)
;
return
new
VM
(
env
scope
dynamicScope
elementStack
)
;
}
;
ListBlockOpcode
.
prototype
.
toJSON
=
function
toJSON
(
)
{
var
json
=
_BlockOpcode2
.
prototype
.
toJSON
.
call
(
this
)
;
var
map
1
=
this
.
map
;
var
inner
=
Object
.
keys
(
map
1
)
.
map
(
function
(
key
)
{
return
JSON
.
stringify
(
key
)
+
'
:
'
+
map
1
[
key
]
.
_guid
;
}
)
.
join
(
"
"
)
;
var
details
=
json
[
"
details
"
]
;
if
(
!
details
)
{
details
=
json
[
"
details
"
]
=
{
}
;
}
details
[
"
map
"
]
=
'
{
'
+
inner
+
'
}
'
;
return
json
;
}
;
return
ListBlockOpcode
;
}
(
BlockOpcode
)
;
var
UpdatingVMFrame
=
function
(
)
{
function
UpdatingVMFrame
(
vm
ops
exceptionHandler
)
{
_classCallCheck
30
(
this
UpdatingVMFrame
)
;
this
.
vm
=
vm
;
this
.
ops
=
ops
;
this
.
exceptionHandler
=
exceptionHandler
;
this
.
vm
=
vm
;
this
.
ops
=
ops
;
this
.
current
=
ops
.
head
(
)
;
}
UpdatingVMFrame
.
prototype
.
goto
=
function
goto
(
op
)
{
this
.
current
=
op
;
}
;
UpdatingVMFrame
.
prototype
.
nextStatement
=
function
nextStatement
(
)
{
var
current
=
this
.
current
ops
=
this
.
ops
;
if
(
current
)
this
.
current
=
ops
.
nextNode
(
current
)
;
return
current
;
}
;
UpdatingVMFrame
.
prototype
.
handleException
=
function
handleException
(
)
{
if
(
this
.
exceptionHandler
)
{
this
.
exceptionHandler
.
handleException
(
)
;
}
}
;
return
UpdatingVMFrame
;
}
(
)
;
function
_classCallCheck
31
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
RenderResult
=
function
(
)
{
function
RenderResult
(
env
updating
bounds
1
)
{
_classCallCheck
31
(
this
RenderResult
)
;
this
.
env
=
env
;
this
.
updating
=
updating
;
this
.
bounds
=
bounds
1
;
}
RenderResult
.
prototype
.
rerender
=
function
rerender
(
)
{
var
_ref
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
alwaysRevalidate
:
false
}
_ref
alwaysRevalidate
=
_ref
.
alwaysRevalidate
alwaysRevalidate
=
_ref
alwaysRevalidate
=
=
=
undefined
?
false
:
_ref
alwaysRevalidate
;
var
env
=
this
.
env
updating
=
this
.
updating
;
var
vm
=
new
UpdatingVM
(
env
{
alwaysRevalidate
:
alwaysRevalidate
}
)
;
vm
.
execute
(
updating
this
)
;
}
;
RenderResult
.
prototype
.
parentElement
=
function
parentElement
(
)
{
return
this
.
bounds
.
parentElement
(
)
;
}
;
RenderResult
.
prototype
.
firstNode
=
function
firstNode
(
)
{
return
this
.
bounds
.
firstNode
(
)
;
}
;
RenderResult
.
prototype
.
lastNode
=
function
lastNode
(
)
{
return
this
.
bounds
.
lastNode
(
)
;
}
;
RenderResult
.
prototype
.
opcodes
=
function
opcodes
(
)
{
return
this
.
updating
;
}
;
RenderResult
.
prototype
.
handleException
=
function
handleException
(
)
{
throw
"
this
should
never
happen
"
;
}
;
RenderResult
.
prototype
.
destroy
=
function
destroy
(
)
{
this
.
bounds
.
destroy
(
)
;
clear
(
this
.
bounds
)
;
}
;
return
RenderResult
;
}
(
)
;
var
_createClass
3
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_classCallCheck
22
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
EvaluationStack
=
function
(
)
{
function
EvaluationStack
(
stack
fp
sp
)
{
_classCallCheck
22
(
this
EvaluationStack
)
;
this
.
stack
=
stack
;
this
.
fp
=
fp
;
this
.
sp
=
sp
;
}
EvaluationStack
.
empty
=
function
empty
(
)
{
return
new
this
(
[
]
0
-
1
)
;
}
;
EvaluationStack
.
restore
=
function
restore
(
snapshot
)
{
return
new
this
(
snapshot
.
slice
(
)
0
snapshot
.
length
-
1
)
;
}
;
EvaluationStack
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
this
.
sp
=
=
=
-
1
;
}
;
EvaluationStack
.
prototype
.
push
=
function
push
(
value
)
{
this
.
stack
[
+
+
this
.
sp
]
=
value
;
}
;
EvaluationStack
.
prototype
.
dup
=
function
dup
(
)
{
var
position
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
this
.
sp
;
this
.
push
(
this
.
stack
[
position
]
)
;
}
;
EvaluationStack
.
prototype
.
pop
=
function
pop
(
)
{
var
n
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
1
;
var
top
=
this
.
stack
[
this
.
sp
]
;
this
.
sp
-
=
n
;
return
top
;
}
;
EvaluationStack
.
prototype
.
peek
=
function
peek
(
)
{
return
this
.
stack
[
this
.
sp
]
;
}
;
EvaluationStack
.
prototype
.
fromBase
=
function
fromBase
(
offset
)
{
return
this
.
stack
[
this
.
fp
-
offset
]
;
}
;
EvaluationStack
.
prototype
.
fromTop
=
function
fromTop
(
offset
)
{
return
this
.
stack
[
this
.
sp
-
offset
]
;
}
;
EvaluationStack
.
prototype
.
capture
=
function
capture
(
items
)
{
var
end
=
this
.
sp
+
1
;
var
start
=
end
-
items
;
return
this
.
stack
.
slice
(
start
end
)
;
}
;
EvaluationStack
.
prototype
.
reset
=
function
reset
(
)
{
this
.
stack
.
length
=
0
;
}
;
EvaluationStack
.
prototype
.
toArray
=
function
toArray
(
)
{
return
this
.
stack
.
slice
(
this
.
fp
this
.
sp
+
1
)
;
}
;
return
EvaluationStack
;
}
(
)
;
var
VM
=
function
(
)
{
function
VM
(
env
scope
dynamicScope
elementStack
)
{
_classCallCheck
22
(
this
VM
)
;
this
.
env
=
env
;
this
.
elementStack
=
elementStack
;
this
.
dynamicScopeStack
=
new
_util
.
Stack
(
)
;
this
.
scopeStack
=
new
_util
.
Stack
(
)
;
this
.
updatingOpcodeStack
=
new
_util
.
Stack
(
)
;
this
.
cacheGroups
=
new
_util
.
Stack
(
)
;
this
.
listBlockStack
=
new
_util
.
Stack
(
)
;
this
.
stack
=
EvaluationStack
.
empty
(
)
;
this
.
pc
=
-
1
;
this
.
ra
=
-
1
;
this
.
s0
=
null
;
this
.
s1
=
null
;
this
.
t0
=
null
;
this
.
t1
=
null
;
this
.
env
=
env
;
this
.
heap
=
env
.
program
.
heap
;
this
.
constants
=
env
.
program
.
constants
;
this
.
elementStack
=
elementStack
;
this
.
scopeStack
.
push
(
scope
)
;
this
.
dynamicScopeStack
.
push
(
dynamicScope
)
;
}
VM
.
prototype
.
fetch
=
function
fetch
(
register
)
{
this
.
stack
.
push
(
this
[
Register
[
register
]
]
)
;
}
;
VM
.
prototype
.
load
=
function
load
(
register
)
{
this
[
Register
[
register
]
]
=
this
.
stack
.
pop
(
)
;
}
;
VM
.
prototype
.
fetchValue
=
function
fetchValue
(
register
)
{
return
this
[
Register
[
register
]
]
;
}
;
VM
.
prototype
.
loadValue
=
function
loadValue
(
register
value
)
{
this
[
Register
[
register
]
]
=
value
;
}
;
VM
.
prototype
.
pushFrame
=
function
pushFrame
(
)
{
this
.
stack
.
push
(
this
.
ra
)
;
this
.
stack
.
push
(
this
.
fp
)
;
this
.
fp
=
this
.
sp
-
1
;
}
;
VM
.
prototype
.
popFrame
=
function
popFrame
(
)
{
this
.
sp
=
this
.
fp
-
1
;
this
.
ra
=
this
.
stack
.
fromBase
(
0
)
;
this
.
fp
=
this
.
stack
.
fromBase
(
-
1
)
;
}
;
VM
.
prototype
.
goto
=
function
goto
(
offset
)
{
this
.
pc
=
(
0
_util
.
typePos
)
(
this
.
pc
+
offset
)
;
}
;
VM
.
prototype
.
call
=
function
call
(
handle
)
{
var
pc
=
this
.
heap
.
getaddr
(
handle
)
;
this
.
ra
=
this
.
pc
;
this
.
pc
=
pc
;
}
;
VM
.
prototype
.
returnTo
=
function
returnTo
(
offset
)
{
this
.
ra
=
(
0
_util
.
typePos
)
(
this
.
pc
+
offset
)
;
}
;
VM
.
prototype
.
return
=
function
_return
(
)
{
this
.
pc
=
this
.
ra
;
}
;
VM
.
initial
=
function
initial
(
env
self
dynamicScope
elementStack
program
)
{
var
scope
=
Scope
.
root
(
self
program
.
symbolTable
.
symbols
.
length
)
;
var
vm
=
new
VM
(
env
scope
dynamicScope
elementStack
)
;
vm
.
pc
=
vm
.
heap
.
getaddr
(
program
.
handle
)
;
vm
.
updatingOpcodeStack
.
push
(
new
_util
.
LinkedList
(
)
)
;
return
vm
;
}
;
VM
.
prototype
.
capture
=
function
capture
(
args
)
{
return
{
dynamicScope
:
this
.
dynamicScope
(
)
env
:
this
.
env
scope
:
this
.
scope
(
)
stack
:
this
.
stack
.
capture
(
args
)
}
;
}
;
VM
.
prototype
.
beginCacheGroup
=
function
beginCacheGroup
(
)
{
this
.
cacheGroups
.
push
(
this
.
updating
(
)
.
tail
(
)
)
;
}
;
VM
.
prototype
.
commitCacheGroup
=
function
commitCacheGroup
(
)
{
var
END
=
new
LabelOpcode
(
"
END
"
)
;
var
opcodes
=
this
.
updating
(
)
;
var
marker
=
this
.
cacheGroups
.
pop
(
)
;
var
head
=
marker
?
opcodes
.
nextNode
(
marker
)
:
opcodes
.
head
(
)
;
var
tail
=
opcodes
.
tail
(
)
;
var
tag
=
(
0
_reference2
.
combineSlice
)
(
new
_util
.
ListSlice
(
head
tail
)
)
;
var
guard
=
new
JumpIfNotModifiedOpcode
(
tag
END
)
;
opcodes
.
insertBefore
(
guard
head
)
;
opcodes
.
append
(
new
DidModifyOpcode
(
guard
)
)
;
opcodes
.
append
(
END
)
;
}
;
VM
.
prototype
.
enter
=
function
enter
(
args
)
{
var
updating
=
new
_util
.
LinkedList
(
)
;
var
state
=
this
.
capture
(
args
)
;
var
tracker
=
this
.
elements
(
)
.
pushUpdatableBlock
(
)
;
var
tryOpcode
=
new
TryOpcode
(
this
.
heap
.
gethandle
(
this
.
pc
)
state
tracker
updating
)
;
this
.
didEnter
(
tryOpcode
)
;
}
;
VM
.
prototype
.
iterate
=
function
iterate
(
memo
value
)
{
var
stack
=
this
.
stack
;
stack
.
push
(
value
)
;
stack
.
push
(
memo
)
;
var
state
=
this
.
capture
(
2
)
;
var
tracker
=
this
.
elements
(
)
.
pushUpdatableBlock
(
)
;
return
new
TryOpcode
(
this
.
heap
.
gethandle
(
this
.
pc
)
state
tracker
new
_util
.
LinkedList
(
)
)
;
}
;
VM
.
prototype
.
enterItem
=
function
enterItem
(
key
opcode
)
{
this
.
listBlock
(
)
.
map
[
key
]
=
opcode
;
this
.
didEnter
(
opcode
)
;
}
;
VM
.
prototype
.
enterList
=
function
enterList
(
relativeStart
)
{
var
updating
=
new
_util
.
LinkedList
(
)
;
var
state
=
this
.
capture
(
0
)
;
var
tracker
=
this
.
elements
(
)
.
pushBlockList
(
updating
)
;
var
artifacts
=
this
.
stack
.
peek
(
)
.
artifacts
;
var
start
=
this
.
heap
.
gethandle
(
(
0
_util
.
typePos
)
(
this
.
pc
+
relativeStart
)
)
;
var
opcode
=
new
ListBlockOpcode
(
start
state
tracker
updating
artifacts
)
;
this
.
listBlockStack
.
push
(
opcode
)
;
this
.
didEnter
(
opcode
)
;
}
;
VM
.
prototype
.
didEnter
=
function
didEnter
(
opcode
)
{
this
.
updateWith
(
opcode
)
;
this
.
updatingOpcodeStack
.
push
(
opcode
.
children
)
;
}
;
VM
.
prototype
.
exit
=
function
exit
(
)
{
this
.
elements
(
)
.
popBlock
(
)
;
this
.
updatingOpcodeStack
.
pop
(
)
;
var
parent
=
this
.
updating
(
)
.
tail
(
)
;
parent
.
didInitializeChildren
(
)
;
}
;
VM
.
prototype
.
exitList
=
function
exitList
(
)
{
this
.
exit
(
)
;
this
.
listBlockStack
.
pop
(
)
;
}
;
VM
.
prototype
.
updateWith
=
function
updateWith
(
opcode
)
{
this
.
updating
(
)
.
append
(
opcode
)
;
}
;
VM
.
prototype
.
listBlock
=
function
listBlock
(
)
{
return
this
.
listBlockStack
.
current
;
}
;
VM
.
prototype
.
updating
=
function
updating
(
)
{
return
this
.
updatingOpcodeStack
.
current
;
}
;
VM
.
prototype
.
elements
=
function
elements
(
)
{
return
this
.
elementStack
;
}
;
VM
.
prototype
.
scope
=
function
scope
(
)
{
return
this
.
scopeStack
.
current
;
}
;
VM
.
prototype
.
dynamicScope
=
function
dynamicScope
(
)
{
return
this
.
dynamicScopeStack
.
current
;
}
;
VM
.
prototype
.
pushChildScope
=
function
pushChildScope
(
)
{
this
.
scopeStack
.
push
(
this
.
scope
(
)
.
child
(
)
)
;
}
;
VM
.
prototype
.
pushCallerScope
=
function
pushCallerScope
(
)
{
var
childScope
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
false
;
var
callerScope
=
this
.
scope
(
)
.
getCallerScope
(
)
;
this
.
scopeStack
.
push
(
childScope
?
callerScope
.
child
(
)
:
callerScope
)
;
}
;
VM
.
prototype
.
pushDynamicScope
=
function
pushDynamicScope
(
)
{
var
child
=
this
.
dynamicScope
(
)
.
child
(
)
;
this
.
dynamicScopeStack
.
push
(
child
)
;
return
child
;
}
;
VM
.
prototype
.
pushRootScope
=
function
pushRootScope
(
size
bindCaller
)
{
var
scope
=
Scope
.
sized
(
size
)
;
if
(
bindCaller
)
scope
.
bindCallerScope
(
this
.
scope
(
)
)
;
this
.
scopeStack
.
push
(
scope
)
;
return
scope
;
}
;
VM
.
prototype
.
popScope
=
function
popScope
(
)
{
this
.
scopeStack
.
pop
(
)
;
}
;
VM
.
prototype
.
popDynamicScope
=
function
popDynamicScope
(
)
{
this
.
dynamicScopeStack
.
pop
(
)
;
}
;
VM
.
prototype
.
newDestroyable
=
function
newDestroyable
(
d
)
{
this
.
elements
(
)
.
newDestroyable
(
d
)
;
}
;
VM
.
prototype
.
getSelf
=
function
getSelf
(
)
{
return
this
.
scope
(
)
.
getSelf
(
)
;
}
;
VM
.
prototype
.
referenceForSymbol
=
function
referenceForSymbol
(
symbol
)
{
return
this
.
scope
(
)
.
getSymbol
(
symbol
)
;
}
;
VM
.
prototype
.
execute
=
function
execute
(
start
initialize
)
{
this
.
pc
=
this
.
heap
.
getaddr
(
start
)
;
if
(
initialize
)
initialize
(
this
)
;
var
result
=
void
0
;
while
(
true
)
{
result
=
this
.
next
(
)
;
if
(
result
.
done
)
break
;
}
return
result
.
value
;
}
;
VM
.
prototype
.
next
=
function
next
(
)
{
var
env
=
this
.
env
updatingOpcodeStack
=
this
.
updatingOpcodeStack
elementStack
=
this
.
elementStack
;
var
opcode
=
this
.
nextStatement
(
env
)
;
var
result
=
void
0
;
if
(
opcode
!
=
=
null
)
{
APPEND_OPCODES
.
evaluate
(
this
opcode
opcode
.
type
)
;
result
=
{
done
:
false
value
:
null
}
;
}
else
{
this
.
stack
.
reset
(
)
;
result
=
{
done
:
true
value
:
new
RenderResult
(
env
updatingOpcodeStack
.
pop
(
)
elementStack
.
popBlock
(
)
)
}
;
}
return
result
;
}
;
VM
.
prototype
.
nextStatement
=
function
nextStatement
(
env
)
{
var
pc
=
this
.
pc
;
if
(
pc
=
=
=
-
1
)
{
return
null
;
}
var
program
=
env
.
program
;
this
.
pc
+
=
4
;
return
program
.
opcode
(
pc
)
;
}
;
VM
.
prototype
.
evaluateOpcode
=
function
evaluateOpcode
(
opcode
)
{
APPEND_OPCODES
.
evaluate
(
this
opcode
opcode
.
type
)
;
}
;
VM
.
prototype
.
bindDynamicScope
=
function
bindDynamicScope
(
names
)
{
var
scope
=
this
.
dynamicScope
(
)
;
for
(
var
i
=
names
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
name
=
this
.
constants
.
getString
(
names
[
i
]
)
;
scope
.
set
(
name
this
.
stack
.
pop
(
)
)
;
}
}
;
_createClass
3
(
VM
[
{
key
:
'
fp
'
get
:
function
(
)
{
return
this
.
stack
.
fp
;
}
set
:
function
(
fp
)
{
this
.
stack
.
fp
=
fp
;
}
}
{
key
:
'
sp
'
get
:
function
(
)
{
return
this
.
stack
.
sp
;
}
set
:
function
(
sp
)
{
this
.
stack
.
sp
=
sp
;
}
}
]
)
;
return
VM
;
}
(
)
;
function
_classCallCheck
14
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
TemplateIterator
=
function
(
)
{
function
TemplateIterator
(
vm
)
{
_classCallCheck
14
(
this
TemplateIterator
)
;
this
.
vm
=
vm
;
}
TemplateIterator
.
prototype
.
next
=
function
next
(
)
{
return
this
.
vm
.
next
(
)
;
}
;
return
TemplateIterator
;
}
(
)
;
var
clientId
=
0
;
function
templateFactory
(
_ref
)
{
var
templateId
=
_ref
.
id
meta
=
_ref
.
meta
block
=
_ref
.
block
;
var
parsedBlock
=
void
0
;
var
id
=
templateId
|
|
'
client
-
'
+
clientId
+
+
;
var
create
=
function
(
env
envMeta
)
{
var
newMeta
=
envMeta
?
(
0
_util
.
assign
)
(
{
}
envMeta
meta
)
:
meta
;
if
(
!
parsedBlock
)
{
parsedBlock
=
JSON
.
parse
(
block
)
;
}
return
new
ScannableTemplate
(
id
newMeta
env
parsedBlock
)
;
}
;
return
{
id
:
id
meta
:
meta
create
:
create
}
;
}
var
ScannableTemplate
=
function
(
)
{
function
ScannableTemplate
(
id
meta
env
rawBlock
)
{
_classCallCheck
14
(
this
ScannableTemplate
)
;
this
.
id
=
id
;
this
.
meta
=
meta
;
this
.
env
=
env
;
this
.
entryPoint
=
null
;
this
.
layout
=
null
;
this
.
partial
=
null
;
this
.
block
=
null
;
this
.
scanner
=
new
Scanner
(
rawBlock
env
)
;
this
.
symbols
=
rawBlock
.
symbols
;
this
.
hasEval
=
rawBlock
.
hasEval
;
}
ScannableTemplate
.
prototype
.
render
=
function
render
(
self
appendTo
dynamicScope
)
{
var
env
=
this
.
env
;
var
elementStack
=
ElementStack
.
forInitialRender
(
env
appendTo
null
)
;
var
compiled
=
this
.
asEntryPoint
(
)
.
compileDynamic
(
env
)
;
var
vm
=
VM
.
initial
(
env
self
dynamicScope
elementStack
compiled
)
;
return
new
TemplateIterator
(
vm
)
;
}
;
ScannableTemplate
.
prototype
.
asEntryPoint
=
function
asEntryPoint
(
)
{
if
(
!
this
.
entryPoint
)
this
.
entryPoint
=
this
.
scanner
.
scanEntryPoint
(
this
.
compilationMeta
(
)
)
;
return
this
.
entryPoint
;
}
;
ScannableTemplate
.
prototype
.
asLayout
=
function
asLayout
(
componentName
attrs
)
{
if
(
!
this
.
layout
)
this
.
layout
=
this
.
scanner
.
scanLayout
(
this
.
compilationMeta
(
)
attrs
|
|
_util
.
EMPTY_ARRAY
componentName
)
;
return
this
.
layout
;
}
;
ScannableTemplate
.
prototype
.
asPartial
=
function
asPartial
(
)
{
if
(
!
this
.
partial
)
this
.
partial
=
this
.
scanner
.
scanEntryPoint
(
this
.
compilationMeta
(
true
)
)
;
return
this
.
partial
;
}
;
ScannableTemplate
.
prototype
.
asBlock
=
function
asBlock
(
)
{
if
(
!
this
.
block
)
this
.
block
=
this
.
scanner
.
scanBlock
(
this
.
compilationMeta
(
)
)
;
return
this
.
block
;
}
;
ScannableTemplate
.
prototype
.
compilationMeta
=
function
compilationMeta
(
)
{
var
asPartial
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
false
;
return
{
templateMeta
:
this
.
meta
symbols
:
this
.
symbols
asPartial
:
asPartial
}
;
}
;
return
ScannableTemplate
;
}
(
)
;
function
_classCallCheck
32
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
DynamicVarReference
=
function
(
)
{
function
DynamicVarReference
(
scope
nameRef
)
{
_classCallCheck
32
(
this
DynamicVarReference
)
;
this
.
scope
=
scope
;
this
.
nameRef
=
nameRef
;
var
varTag
=
this
.
varTag
=
_reference2
.
UpdatableTag
.
create
(
_reference2
.
CONSTANT_TAG
)
;
this
.
tag
=
(
0
_reference2
.
combine
)
(
[
nameRef
.
tag
varTag
]
)
;
}
DynamicVarReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
getVar
(
)
.
value
(
)
;
}
;
DynamicVarReference
.
prototype
.
get
=
function
get
(
key
)
{
return
this
.
getVar
(
)
.
get
(
key
)
;
}
;
DynamicVarReference
.
prototype
.
getVar
=
function
getVar
(
)
{
var
name
=
String
(
this
.
nameRef
.
value
(
)
)
;
var
ref
=
this
.
scope
.
get
(
name
)
;
this
.
varTag
.
inner
.
update
(
ref
.
tag
)
;
return
ref
;
}
;
return
DynamicVarReference
;
}
(
)
;
function
getDynamicVar
(
vm
args
)
{
var
scope
=
vm
.
dynamicScope
(
)
;
var
nameRef
=
args
.
positional
.
at
(
0
)
;
return
new
DynamicVarReference
(
scope
nameRef
)
;
}
function
_classCallCheck
33
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
PartialDefinition
=
function
PartialDefinition
(
name
template
)
{
_classCallCheck
33
(
this
PartialDefinition
)
;
this
.
name
=
name
;
this
.
template
=
template
;
}
;
var
NodeType
;
(
function
(
NodeType
)
{
NodeType
[
NodeType
[
"
Element
"
]
=
0
]
=
"
Element
"
;
NodeType
[
NodeType
[
"
Attribute
"
]
=
1
]
=
"
Attribute
"
;
NodeType
[
NodeType
[
"
Text
"
]
=
2
]
=
"
Text
"
;
NodeType
[
NodeType
[
"
CdataSection
"
]
=
3
]
=
"
CdataSection
"
;
NodeType
[
NodeType
[
"
EntityReference
"
]
=
4
]
=
"
EntityReference
"
;
NodeType
[
NodeType
[
"
Entity
"
]
=
5
]
=
"
Entity
"
;
NodeType
[
NodeType
[
"
ProcessingInstruction
"
]
=
6
]
=
"
ProcessingInstruction
"
;
NodeType
[
NodeType
[
"
Comment
"
]
=
7
]
=
"
Comment
"
;
NodeType
[
NodeType
[
"
Document
"
]
=
8
]
=
"
Document
"
;
NodeType
[
NodeType
[
"
DocumentType
"
]
=
9
]
=
"
DocumentType
"
;
NodeType
[
NodeType
[
"
DocumentFragment
"
]
=
10
]
=
"
DocumentFragment
"
;
NodeType
[
NodeType
[
"
Notation
"
]
=
11
]
=
"
Notation
"
;
}
)
(
NodeType
|
|
(
NodeType
=
{
}
)
)
;
var
interfaces
=
Object
.
freeze
(
{
get
NodeType
(
)
{
return
NodeType
;
}
}
)
;
exports
.
Simple
=
interfaces
;
exports
.
templateFactory
=
templateFactory
;
exports
.
NULL_REFERENCE
=
NULL_REFERENCE
;
exports
.
UNDEFINED_REFERENCE
=
UNDEFINED_REFERENCE
;
exports
.
PrimitiveReference
=
PrimitiveReference
;
exports
.
ConditionalReference
=
ConditionalReference
;
exports
.
OpcodeBuilderDSL
=
OpcodeBuilder
;
exports
.
compileLayout
=
compileLayout
;
exports
.
CompiledStaticTemplate
=
CompiledStaticTemplate
;
exports
.
CompiledDynamicTemplate
=
CompiledDynamicTemplate
;
exports
.
IAttributeManager
=
AttributeManager
;
exports
.
AttributeManager
=
AttributeManager
;
exports
.
PropertyManager
=
PropertyManager
;
exports
.
INPUT_VALUE_PROPERTY_MANAGER
=
INPUT_VALUE_PROPERTY_MANAGER
;
exports
.
defaultManagers
=
defaultManagers
;
exports
.
defaultAttributeManagers
=
defaultAttributeManagers
;
exports
.
defaultPropertyManagers
=
defaultPropertyManagers
;
exports
.
readDOMAttr
=
readDOMAttr
;
exports
.
Register
=
Register
;
exports
.
debugSlice
=
debugSlice
;
exports
.
normalizeTextValue
=
normalizeTextValue
;
exports
.
setDebuggerCallback
=
setDebuggerCallback
;
exports
.
resetDebuggerCallback
=
resetDebuggerCallback
;
exports
.
getDynamicVar
=
getDynamicVar
;
exports
.
BlockMacros
=
Blocks
;
exports
.
InlineMacros
=
Inlines
;
exports
.
compileList
=
compileList
;
exports
.
compileExpression
=
expr
;
exports
.
UpdatingVM
=
UpdatingVM
;
exports
.
RenderResult
=
RenderResult
;
exports
.
isSafeString
=
isSafeString
;
exports
.
Scope
=
Scope
;
exports
.
Environment
=
Environment
;
exports
.
PartialDefinition
=
PartialDefinition
;
exports
.
ComponentDefinition
=
ComponentDefinition
;
exports
.
isComponentDefinition
=
isComponentDefinition
;
exports
.
DOMChanges
=
helper
1
;
exports
.
IDOMChanges
=
DOMChanges
;
exports
.
DOMTreeConstruction
=
DOMTreeConstruction
;
exports
.
isWhitespace
=
isWhitespace
;
exports
.
insertHTMLBefore
=
_insertHTMLBefore
;
exports
.
ElementStack
=
ElementStack
;
exports
.
ConcreteBounds
=
ConcreteBounds
;
}
)
;
enifed
(
'
glimmer
/
util
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
XLINK
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
;
var
XML
=
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
;
var
XMLNS
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
xmlns
/
'
;
var
WHITELIST
=
{
'
xlink
:
actuate
'
:
XLINK
'
xlink
:
arcrole
'
:
XLINK
'
xlink
:
href
'
:
XLINK
'
xlink
:
role
'
:
XLINK
'
xlink
:
show
'
:
XLINK
'
xlink
:
title
'
:
XLINK
'
xlink
:
type
'
:
XLINK
'
xml
:
base
'
:
XML
'
xml
:
lang
'
:
XML
'
xml
:
space
'
:
XML
'
xmlns
'
:
XMLNS
'
xmlns
:
xlink
'
:
XMLNS
}
;
function
getAttrNamespace
(
attrName
)
{
return
WHITELIST
[
attrName
]
|
|
null
;
}
function
unwrap
(
val
)
{
if
(
val
=
=
=
null
|
|
val
=
=
=
undefined
)
throw
new
Error
(
'
Expected
value
to
be
present
'
)
;
return
val
;
}
function
expect
(
val
message
)
{
if
(
val
=
=
=
null
|
|
val
=
=
=
undefined
)
throw
new
Error
(
message
)
;
return
val
;
}
function
unreachable
(
)
{
return
new
Error
(
'
unreachable
'
)
;
}
function
typePos
(
lastOperand
)
{
return
lastOperand
-
4
;
}
function
debugAssert
(
test
msg
)
{
if
(
!
test
)
{
throw
new
Error
(
msg
|
|
"
assertion
failure
"
)
;
}
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
LogLevel
;
(
function
(
LogLevel
)
{
LogLevel
[
LogLevel
[
"
Trace
"
]
=
0
]
=
"
Trace
"
;
LogLevel
[
LogLevel
[
"
Debug
"
]
=
1
]
=
"
Debug
"
;
LogLevel
[
LogLevel
[
"
Warn
"
]
=
2
]
=
"
Warn
"
;
LogLevel
[
LogLevel
[
"
Error
"
]
=
3
]
=
"
Error
"
;
}
)
(
LogLevel
|
|
(
exports
.
LogLevel
=
LogLevel
=
{
}
)
)
;
var
NullConsole
=
function
(
)
{
function
NullConsole
(
)
{
_classCallCheck
(
this
NullConsole
)
;
}
NullConsole
.
prototype
.
log
=
function
log
(
_message
)
{
}
;
NullConsole
.
prototype
.
warn
=
function
warn
(
_message
)
{
}
;
NullConsole
.
prototype
.
error
=
function
error
(
_message
)
{
}
;
NullConsole
.
prototype
.
trace
=
function
trace
(
)
{
}
;
return
NullConsole
;
}
(
)
;
var
ALWAYS
=
void
0
;
var
Logger
=
function
(
)
{
function
Logger
(
_ref
)
{
var
console
=
_ref
.
console
level
=
_ref
.
level
;
_classCallCheck
(
this
Logger
)
;
this
.
f
=
ALWAYS
;
this
.
force
=
ALWAYS
;
this
.
console
=
console
;
this
.
level
=
level
;
}
Logger
.
prototype
.
skipped
=
function
skipped
(
level
)
{
return
level
<
this
.
level
;
}
;
Logger
.
prototype
.
trace
=
function
trace
(
message
)
{
var
_ref2
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
_ref2
stackTrace
=
_ref2
.
stackTrace
stackTrace
=
_ref2
stackTrace
=
=
=
undefined
?
false
:
_ref2
stackTrace
;
if
(
this
.
skipped
(
LogLevel
.
Trace
)
)
return
;
this
.
console
.
log
(
message
)
;
if
(
stackTrace
)
this
.
console
.
trace
(
)
;
}
;
Logger
.
prototype
.
debug
=
function
debug
(
message
)
{
var
_ref3
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
_ref3
stackTrace
=
_ref3
.
stackTrace
stackTrace
=
_ref3
stackTrace
=
=
=
undefined
?
false
:
_ref3
stackTrace
;
if
(
this
.
skipped
(
LogLevel
.
Debug
)
)
return
;
this
.
console
.
log
(
message
)
;
if
(
stackTrace
)
this
.
console
.
trace
(
)
;
}
;
Logger
.
prototype
.
warn
=
function
warn
(
message
)
{
var
_ref4
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
_ref4
stackTrace
=
_ref4
.
stackTrace
stackTrace
=
_ref4
stackTrace
=
=
=
undefined
?
false
:
_ref4
stackTrace
;
if
(
this
.
skipped
(
LogLevel
.
Warn
)
)
return
;
this
.
console
.
warn
(
message
)
;
if
(
stackTrace
)
this
.
console
.
trace
(
)
;
}
;
Logger
.
prototype
.
error
=
function
error
(
message
)
{
if
(
this
.
skipped
(
LogLevel
.
Error
)
)
return
;
this
.
console
.
error
(
message
)
;
}
;
return
Logger
;
}
(
)
;
var
_console
=
typeof
console
=
=
=
'
undefined
'
?
new
NullConsole
(
)
:
console
;
ALWAYS
=
new
Logger
(
{
console
:
_console
level
:
LogLevel
.
Trace
}
)
;
var
LOG_LEVEL
=
LogLevel
.
Debug
;
var
logger
=
new
Logger
(
{
console
:
_console
level
:
LOG_LEVEL
}
)
;
var
objKeys
=
Object
.
keys
;
function
assign
(
obj
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
assignment
=
arguments
[
i
]
;
if
(
assignment
=
=
=
null
|
|
typeof
assignment
!
=
=
'
object
'
)
continue
;
var
keys
=
objKeys
(
assignment
)
;
for
(
var
j
=
0
;
j
<
keys
.
length
;
j
+
+
)
{
var
key
=
keys
[
j
]
;
obj
[
key
]
=
assignment
[
key
]
;
}
}
return
obj
;
}
function
fillNulls
(
count
)
{
var
arr
=
new
Array
(
count
)
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
{
arr
[
i
]
=
null
;
}
return
arr
;
}
var
GUID
=
0
;
function
initializeGuid
(
object
)
{
return
object
.
_guid
=
+
+
GUID
;
}
function
ensureGuid
(
object
)
{
return
object
.
_guid
|
|
initializeGuid
(
object
)
;
}
function
_classCallCheck
1
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
proto
=
Object
.
create
(
null
{
constructor
:
{
value
:
undefined
enumerable
:
false
writable
:
true
}
}
)
;
function
EmptyObject
(
)
{
}
EmptyObject
.
prototype
=
proto
;
function
dict
(
)
{
return
new
EmptyObject
(
)
;
}
var
DictSet
=
function
(
)
{
function
DictSet
(
)
{
_classCallCheck
1
(
this
DictSet
)
;
this
.
dict
=
dict
(
)
;
}
DictSet
.
prototype
.
add
=
function
add
(
obj
)
{
if
(
typeof
obj
=
=
=
'
string
'
)
this
.
dict
[
obj
]
=
obj
;
else
this
.
dict
[
ensureGuid
(
obj
)
]
=
obj
;
return
this
;
}
;
DictSet
.
prototype
.
delete
=
function
_delete
(
obj
)
{
if
(
typeof
obj
=
=
=
'
string
'
)
delete
this
.
dict
[
obj
]
;
else
if
(
obj
.
_guid
)
delete
this
.
dict
[
obj
.
_guid
]
;
}
;
DictSet
.
prototype
.
forEach
=
function
forEach
(
callback
)
{
var
dict
=
this
.
dict
;
var
dictKeys
=
Object
.
keys
(
dict
)
;
for
(
var
i
=
0
;
dictKeys
.
length
;
i
+
+
)
{
callback
(
dict
[
dictKeys
[
i
]
]
)
;
}
}
;
DictSet
.
prototype
.
toArray
=
function
toArray
(
)
{
return
Object
.
keys
(
this
.
dict
)
;
}
;
return
DictSet
;
}
(
)
;
var
Stack
=
function
(
)
{
function
Stack
(
)
{
_classCallCheck
1
(
this
Stack
)
;
this
.
stack
=
[
]
;
this
.
current
=
null
;
}
Stack
.
prototype
.
toArray
=
function
toArray
(
)
{
return
this
.
stack
;
}
;
Stack
.
prototype
.
push
=
function
push
(
item
)
{
this
.
current
=
item
;
this
.
stack
.
push
(
item
)
;
}
;
Stack
.
prototype
.
pop
=
function
pop
(
)
{
var
item
=
this
.
stack
.
pop
(
)
;
var
len
=
this
.
stack
.
length
;
this
.
current
=
len
=
=
=
0
?
null
:
this
.
stack
[
len
-
1
]
;
return
item
=
=
=
undefined
?
null
:
item
;
}
;
Stack
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
this
.
stack
.
length
=
=
=
0
;
}
;
return
Stack
;
}
(
)
;
function
_classCallCheck
2
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
ListNode
=
function
ListNode
(
value
)
{
_classCallCheck
2
(
this
ListNode
)
;
this
.
next
=
null
;
this
.
prev
=
null
;
this
.
value
=
value
;
}
;
var
LinkedList
=
function
(
)
{
function
LinkedList
(
)
{
_classCallCheck
2
(
this
LinkedList
)
;
this
.
clear
(
)
;
}
LinkedList
.
fromSlice
=
function
fromSlice
(
slice
)
{
var
list
=
new
LinkedList
(
)
;
slice
.
forEachNode
(
function
(
n
)
{
return
list
.
append
(
n
.
clone
(
)
)
;
}
)
;
return
list
;
}
;
LinkedList
.
prototype
.
head
=
function
head
(
)
{
return
this
.
_head
;
}
;
LinkedList
.
prototype
.
tail
=
function
tail
(
)
{
return
this
.
_tail
;
}
;
LinkedList
.
prototype
.
clear
=
function
clear
(
)
{
this
.
_head
=
this
.
_tail
=
null
;
}
;
LinkedList
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
this
.
_head
=
=
=
null
;
}
;
LinkedList
.
prototype
.
toArray
=
function
toArray
(
)
{
var
out
=
[
]
;
this
.
forEachNode
(
function
(
n
)
{
return
out
.
push
(
n
)
;
}
)
;
return
out
;
}
;
LinkedList
.
prototype
.
splice
=
function
splice
(
start
end
reference
)
{
var
before
=
void
0
;
if
(
reference
=
=
=
null
)
{
before
=
this
.
_tail
;
this
.
_tail
=
end
;
}
else
{
before
=
reference
.
prev
;
end
.
next
=
reference
;
reference
.
prev
=
end
;
}
if
(
before
)
{
before
.
next
=
start
;
start
.
prev
=
before
;
}
}
;
LinkedList
.
prototype
.
nextNode
=
function
nextNode
(
node
)
{
return
node
.
next
;
}
;
LinkedList
.
prototype
.
prevNode
=
function
prevNode
(
node
)
{
return
node
.
prev
;
}
;
LinkedList
.
prototype
.
forEachNode
=
function
forEachNode
(
callback
)
{
var
node
=
this
.
_head
;
while
(
node
!
=
=
null
)
{
callback
(
node
)
;
node
=
node
.
next
;
}
}
;
LinkedList
.
prototype
.
contains
=
function
contains
(
needle
)
{
var
node
=
this
.
_head
;
while
(
node
!
=
=
null
)
{
if
(
node
=
=
=
needle
)
return
true
;
node
=
node
.
next
;
}
return
false
;
}
;
LinkedList
.
prototype
.
insertBefore
=
function
insertBefore
(
node
)
{
var
reference
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
if
(
reference
=
=
=
null
)
return
this
.
append
(
node
)
;
if
(
reference
.
prev
)
reference
.
prev
.
next
=
node
;
else
this
.
_head
=
node
;
node
.
prev
=
reference
.
prev
;
node
.
next
=
reference
;
reference
.
prev
=
node
;
return
node
;
}
;
LinkedList
.
prototype
.
append
=
function
append
(
node
)
{
var
tail
=
this
.
_tail
;
if
(
tail
)
{
tail
.
next
=
node
;
node
.
prev
=
tail
;
node
.
next
=
null
;
}
else
{
this
.
_head
=
node
;
}
return
this
.
_tail
=
node
;
}
;
LinkedList
.
prototype
.
pop
=
function
pop
(
)
{
if
(
this
.
_tail
)
return
this
.
remove
(
this
.
_tail
)
;
return
null
;
}
;
LinkedList
.
prototype
.
prepend
=
function
prepend
(
node
)
{
if
(
this
.
_head
)
return
this
.
insertBefore
(
node
this
.
_head
)
;
return
this
.
_head
=
this
.
_tail
=
node
;
}
;
LinkedList
.
prototype
.
remove
=
function
remove
(
node
)
{
if
(
node
.
prev
)
node
.
prev
.
next
=
node
.
next
;
else
this
.
_head
=
node
.
next
;
if
(
node
.
next
)
node
.
next
.
prev
=
node
.
prev
;
else
this
.
_tail
=
node
.
prev
;
return
node
;
}
;
return
LinkedList
;
}
(
)
;
var
ListSlice
=
function
(
)
{
function
ListSlice
(
head
tail
)
{
_classCallCheck
2
(
this
ListSlice
)
;
this
.
_head
=
head
;
this
.
_tail
=
tail
;
}
ListSlice
.
toList
=
function
toList
(
slice
)
{
var
list
=
new
LinkedList
(
)
;
slice
.
forEachNode
(
function
(
n
)
{
return
list
.
append
(
n
.
clone
(
)
)
;
}
)
;
return
list
;
}
;
ListSlice
.
prototype
.
forEachNode
=
function
forEachNode
(
callback
)
{
var
node
=
this
.
_head
;
while
(
node
!
=
=
null
)
{
callback
(
node
)
;
node
=
this
.
nextNode
(
node
)
;
}
}
;
ListSlice
.
prototype
.
contains
=
function
contains
(
needle
)
{
var
node
=
this
.
_head
;
while
(
node
!
=
=
null
)
{
if
(
node
=
=
=
needle
)
return
true
;
node
=
node
.
next
;
}
return
false
;
}
;
ListSlice
.
prototype
.
head
=
function
head
(
)
{
return
this
.
_head
;
}
;
ListSlice
.
prototype
.
tail
=
function
tail
(
)
{
return
this
.
_tail
;
}
;
ListSlice
.
prototype
.
toArray
=
function
toArray
(
)
{
var
out
=
[
]
;
this
.
forEachNode
(
function
(
n
)
{
return
out
.
push
(
n
)
;
}
)
;
return
out
;
}
;
ListSlice
.
prototype
.
nextNode
=
function
nextNode
(
node
)
{
if
(
node
=
=
=
this
.
_tail
)
return
null
;
return
node
.
next
;
}
;
ListSlice
.
prototype
.
prevNode
=
function
prevNode
(
node
)
{
if
(
node
=
=
=
this
.
_head
)
return
null
;
return
node
.
prev
;
}
;
ListSlice
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
false
;
}
;
return
ListSlice
;
}
(
)
;
var
EMPTY_SLICE
=
new
ListSlice
(
null
null
)
;
var
HAS_NATIVE_WEAKMAP
=
function
(
)
{
var
hasWeakMap
=
typeof
WeakMap
=
=
=
'
function
'
;
if
(
!
hasWeakMap
)
{
return
false
;
}
var
instance
=
new
WeakMap
(
)
;
return
Object
.
prototype
.
toString
.
call
(
instance
)
=
=
=
'
[
object
WeakMap
]
'
;
}
(
)
;
var
HAS_TYPED_ARRAYS
=
typeof
Uint32Array
!
=
=
'
undefined
'
;
var
A
=
void
0
;
if
(
HAS_TYPED_ARRAYS
)
{
A
=
Uint32Array
;
}
else
{
A
=
Array
;
}
var
A
1
=
A
;
var
EMPTY_ARRAY
=
HAS_NATIVE_WEAKMAP
?
Object
.
freeze
(
[
]
)
:
[
]
;
exports
.
getAttrNamespace
=
getAttrNamespace
;
exports
.
assert
=
debugAssert
;
exports
.
LOGGER
=
logger
;
exports
.
Logger
=
Logger
;
exports
.
LogLevel
=
LogLevel
;
exports
.
assign
=
assign
;
exports
.
fillNulls
=
fillNulls
;
exports
.
ensureGuid
=
ensureGuid
;
exports
.
initializeGuid
=
initializeGuid
;
exports
.
Stack
=
Stack
;
exports
.
DictSet
=
DictSet
;
exports
.
dict
=
dict
;
exports
.
EMPTY_SLICE
=
EMPTY_SLICE
;
exports
.
LinkedList
=
LinkedList
;
exports
.
ListNode
=
ListNode
;
exports
.
ListSlice
=
ListSlice
;
exports
.
A
=
A
1
;
exports
.
EMPTY_ARRAY
=
EMPTY_ARRAY
;
exports
.
HAS_NATIVE_WEAKMAP
=
HAS_NATIVE_WEAKMAP
;
exports
.
unwrap
=
unwrap
;
exports
.
expect
=
expect
;
exports
.
unreachable
=
unreachable
;
exports
.
typePos
=
typePos
;
}
)
;
enifed
(
"
glimmer
/
wire
-
format
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
Opcodes
;
(
function
(
Opcodes
)
{
Opcodes
[
Opcodes
[
"
Text
"
]
=
0
]
=
"
Text
"
;
Opcodes
[
Opcodes
[
"
Append
"
]
=
1
]
=
"
Append
"
;
Opcodes
[
Opcodes
[
"
Comment
"
]
=
2
]
=
"
Comment
"
;
Opcodes
[
Opcodes
[
"
Modifier
"
]
=
3
]
=
"
Modifier
"
;
Opcodes
[
Opcodes
[
"
Block
"
]
=
4
]
=
"
Block
"
;
Opcodes
[
Opcodes
[
"
Component
"
]
=
5
]
=
"
Component
"
;
Opcodes
[
Opcodes
[
"
OpenElement
"
]
=
6
]
=
"
OpenElement
"
;
Opcodes
[
Opcodes
[
"
FlushElement
"
]
=
7
]
=
"
FlushElement
"
;
Opcodes
[
Opcodes
[
"
CloseElement
"
]
=
8
]
=
"
CloseElement
"
;
Opcodes
[
Opcodes
[
"
StaticAttr
"
]
=
9
]
=
"
StaticAttr
"
;
Opcodes
[
Opcodes
[
"
DynamicAttr
"
]
=
10
]
=
"
DynamicAttr
"
;
Opcodes
[
Opcodes
[
"
Yield
"
]
=
11
]
=
"
Yield
"
;
Opcodes
[
Opcodes
[
"
Partial
"
]
=
12
]
=
"
Partial
"
;
Opcodes
[
Opcodes
[
"
DynamicArg
"
]
=
13
]
=
"
DynamicArg
"
;
Opcodes
[
Opcodes
[
"
StaticArg
"
]
=
14
]
=
"
StaticArg
"
;
Opcodes
[
Opcodes
[
"
TrustingAttr
"
]
=
15
]
=
"
TrustingAttr
"
;
Opcodes
[
Opcodes
[
"
Debugger
"
]
=
16
]
=
"
Debugger
"
;
Opcodes
[
Opcodes
[
"
ClientSideStatement
"
]
=
17
]
=
"
ClientSideStatement
"
;
Opcodes
[
Opcodes
[
"
Unknown
"
]
=
18
]
=
"
Unknown
"
;
Opcodes
[
Opcodes
[
"
Get
"
]
=
19
]
=
"
Get
"
;
Opcodes
[
Opcodes
[
"
MaybeLocal
"
]
=
20
]
=
"
MaybeLocal
"
;
Opcodes
[
Opcodes
[
"
FixThisBeforeWeMerge
"
]
=
21
]
=
"
FixThisBeforeWeMerge
"
;
Opcodes
[
Opcodes
[
"
HasBlock
"
]
=
22
]
=
"
HasBlock
"
;
Opcodes
[
Opcodes
[
"
HasBlockParams
"
]
=
23
]
=
"
HasBlockParams
"
;
Opcodes
[
Opcodes
[
"
Undefined
"
]
=
24
]
=
"
Undefined
"
;
Opcodes
[
Opcodes
[
"
Helper
"
]
=
25
]
=
"
Helper
"
;
Opcodes
[
Opcodes
[
"
Concat
"
]
=
26
]
=
"
Concat
"
;
Opcodes
[
Opcodes
[
"
ClientSideExpression
"
]
=
27
]
=
"
ClientSideExpression
"
;
}
)
(
Opcodes
|
|
(
exports
.
Ops
=
Opcodes
=
{
}
)
)
;
function
is
(
variant
)
{
return
function
(
value
)
{
return
Array
.
isArray
(
value
)
&
&
value
[
0
]
=
=
=
variant
;
}
;
}
var
Expressions
;
(
function
(
Expressions
)
{
Expressions
.
isUnknown
=
is
(
Opcodes
.
Unknown
)
;
Expressions
.
isGet
=
is
(
Opcodes
.
Get
)
;
Expressions
.
isConcat
=
is
(
Opcodes
.
Concat
)
;
Expressions
.
isHelper
=
is
(
Opcodes
.
Helper
)
;
Expressions
.
isHasBlock
=
is
(
Opcodes
.
HasBlock
)
;
Expressions
.
isHasBlockParams
=
is
(
Opcodes
.
HasBlockParams
)
;
Expressions
.
isUndefined
=
is
(
Opcodes
.
Undefined
)
;
Expressions
.
isClientSide
=
is
(
Opcodes
.
ClientSideExpression
)
;
Expressions
.
isMaybeLocal
=
is
(
Opcodes
.
MaybeLocal
)
;
function
isPrimitiveValue
(
value
)
{
if
(
value
=
=
=
null
)
{
return
true
;
}
return
typeof
value
!
=
=
'
object
'
;
}
Expressions
.
isPrimitiveValue
=
isPrimitiveValue
;
}
)
(
Expressions
|
|
(
exports
.
Expressions
=
Expressions
=
{
}
)
)
;
var
Statements
;
(
function
(
Statements
)
{
Statements
.
isText
=
is
(
Opcodes
.
Text
)
;
Statements
.
isAppend
=
is
(
Opcodes
.
Append
)
;
Statements
.
isComment
=
is
(
Opcodes
.
Comment
)
;
Statements
.
isModifier
=
is
(
Opcodes
.
Modifier
)
;
Statements
.
isBlock
=
is
(
Opcodes
.
Block
)
;
Statements
.
isComponent
=
is
(
Opcodes
.
Component
)
;
Statements
.
isOpenElement
=
is
(
Opcodes
.
OpenElement
)
;
Statements
.
isFlushElement
=
is
(
Opcodes
.
FlushElement
)
;
Statements
.
isCloseElement
=
is
(
Opcodes
.
CloseElement
)
;
Statements
.
isStaticAttr
=
is
(
Opcodes
.
StaticAttr
)
;
Statements
.
isDynamicAttr
=
is
(
Opcodes
.
DynamicAttr
)
;
Statements
.
isYield
=
is
(
Opcodes
.
Yield
)
;
Statements
.
isPartial
=
is
(
Opcodes
.
Partial
)
;
Statements
.
isDynamicArg
=
is
(
Opcodes
.
DynamicArg
)
;
Statements
.
isStaticArg
=
is
(
Opcodes
.
StaticArg
)
;
Statements
.
isTrustingAttr
=
is
(
Opcodes
.
TrustingAttr
)
;
Statements
.
isDebugger
=
is
(
Opcodes
.
Debugger
)
;
Statements
.
isClientSide
=
is
(
Opcodes
.
ClientSideStatement
)
;
function
isAttribute
(
val
)
{
return
val
[
0
]
=
=
=
Opcodes
.
StaticAttr
|
|
val
[
0
]
=
=
=
Opcodes
.
DynamicAttr
|
|
val
[
0
]
=
=
=
Opcodes
.
TrustingAttr
;
}
Statements
.
isAttribute
=
isAttribute
;
function
isArgument
(
val
)
{
return
val
[
0
]
=
=
=
Opcodes
.
StaticArg
|
|
val
[
0
]
=
=
=
Opcodes
.
DynamicArg
;
}
Statements
.
isArgument
=
isArgument
;
function
isParameter
(
val
)
{
return
isAttribute
(
val
)
|
|
isArgument
(
val
)
;
}
Statements
.
isParameter
=
isParameter
;
function
getParameterName
(
s
)
{
return
s
[
1
]
;
}
Statements
.
getParameterName
=
getParameterName
;
}
)
(
Statements
|
|
(
exports
.
Statements
=
Statements
=
{
}
)
)
;
exports
.
is
=
is
;
exports
.
Expressions
=
Expressions
;
exports
.
Statements
=
Statements
;
exports
.
Ops
=
Opcodes
;
}
)
;
enifed
(
'
backburner
'
[
'
exports
'
'
ember
-
babel
'
]
function
(
exports
_emberBabel
)
{
'
use
strict
'
;
var
NUMBER
=
/
\
d
+
/
;
function
isCoercableNumber
(
suspect
)
{
var
type
=
typeof
suspect
;
return
type
=
=
=
'
number
'
&
&
suspect
=
=
=
suspect
|
|
type
=
=
=
'
string
'
&
&
NUMBER
.
test
(
suspect
)
;
}
function
getOnError
(
options
)
{
return
options
.
onError
|
|
options
.
onErrorTarget
&
&
options
.
onErrorTarget
[
options
.
onErrorMethod
]
;
}
function
findItem
(
target
method
collection
)
{
var
index
=
-
1
;
for
(
var
i
=
0
l
=
collection
.
length
;
i
<
l
;
i
+
=
4
)
{
if
(
collection
[
i
]
=
=
=
target
&
&
collection
[
i
+
1
]
=
=
=
method
)
{
index
=
i
;
break
;
}
}
return
index
;
}
function
findTimer
(
timer
collection
)
{
var
index
=
-
1
;
for
(
var
i
=
3
;
i
<
collection
.
length
;
i
+
=
4
)
{
if
(
collection
[
i
]
=
=
=
timer
)
{
index
=
i
-
3
;
break
;
}
}
return
index
;
}
function
binarySearch
(
time
timers
)
{
var
start
=
0
;
var
end
=
timers
.
length
-
6
;
var
middle
=
void
0
;
var
l
=
void
0
;
while
(
start
<
end
)
{
l
=
(
end
-
start
)
/
6
;
middle
=
start
+
l
-
l
%
6
;
if
(
time
>
=
timers
[
middle
]
)
{
start
=
middle
+
6
;
}
else
{
end
=
middle
;
}
}
return
time
>
=
timers
[
start
]
?
start
+
6
:
start
;
}
var
Queue
=
function
(
)
{
function
Queue
(
name
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
globalOptions
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Queue
)
;
this
.
_queueBeingFlushed
=
[
]
;
this
.
targetQueues
=
new
Map
(
)
;
this
.
index
=
0
;
this
.
_queue
=
[
]
;
this
.
name
=
name
;
this
.
options
=
options
;
this
.
globalOptions
=
globalOptions
;
}
Queue
.
prototype
.
stackFor
=
function
stackFor
(
index
)
{
if
(
index
<
this
.
_queue
.
length
)
{
var
entry
=
this
.
_queue
[
index
*
3
+
4
]
;
if
(
entry
)
{
return
entry
.
stack
;
}
else
{
return
null
;
}
}
}
;
Queue
.
prototype
.
flush
=
function
flush
(
sync
)
{
var
_options
=
this
.
options
before
=
_options
.
before
after
=
_options
.
after
;
var
target
=
void
0
;
var
method
=
void
0
;
var
args
=
void
0
;
var
errorRecordedForStack
=
void
0
;
this
.
targetQueues
.
clear
(
)
;
if
(
this
.
_queueBeingFlushed
.
length
=
=
=
0
)
{
this
.
_queueBeingFlushed
=
this
.
_queue
;
this
.
_queue
=
[
]
;
}
if
(
before
!
=
=
undefined
)
{
before
(
)
;
}
var
invoke
=
void
0
;
var
queueItems
=
this
.
_queueBeingFlushed
;
if
(
queueItems
.
length
>
0
)
{
var
onError
=
getOnError
(
this
.
globalOptions
)
;
invoke
=
onError
?
this
.
invokeWithOnError
:
this
.
invoke
;
for
(
var
i
=
this
.
index
;
i
<
queueItems
.
length
;
i
+
=
4
)
{
this
.
index
+
=
4
;
method
=
queueItems
[
i
+
1
]
;
if
(
method
!
=
=
null
)
{
target
=
queueItems
[
i
]
;
args
=
queueItems
[
i
+
2
]
;
errorRecordedForStack
=
queueItems
[
i
+
3
]
;
invoke
(
target
method
args
onError
errorRecordedForStack
)
;
}
if
(
this
.
index
!
=
=
this
.
_queueBeingFlushed
.
length
&
&
this
.
globalOptions
.
mustYield
&
&
this
.
globalOptions
.
mustYield
(
)
)
{
return
1
;
}
}
}
if
(
after
!
=
=
undefined
)
{
after
(
)
;
}
this
.
_queueBeingFlushed
.
length
=
0
;
this
.
index
=
0
;
if
(
sync
!
=
=
false
&
&
this
.
_queue
.
length
>
0
)
{
this
.
flush
(
true
)
;
}
}
;
Queue
.
prototype
.
hasWork
=
function
hasWork
(
)
{
return
this
.
_queueBeingFlushed
.
length
>
0
|
|
this
.
_queue
.
length
>
0
;
}
;
Queue
.
prototype
.
cancel
=
function
cancel
(
_ref
)
{
var
target
=
_ref
.
target
method
=
_ref
.
method
;
var
queue
=
this
.
_queue
;
var
targetQueueMap
=
this
.
targetQueues
.
get
(
target
)
;
if
(
targetQueueMap
!
=
=
undefined
)
{
targetQueueMap
.
delete
(
method
)
;
}
var
index
=
findItem
(
target
method
queue
)
;
if
(
index
>
-
1
)
{
queue
.
splice
(
index
4
)
;
return
true
;
}
queue
=
this
.
_queueBeingFlushed
;
index
=
findItem
(
target
method
queue
)
;
if
(
index
>
-
1
)
{
queue
[
index
+
1
]
=
null
;
return
true
;
}
return
false
;
}
;
Queue
.
prototype
.
push
=
function
push
(
target
method
args
stack
)
{
this
.
_queue
.
push
(
target
method
args
stack
)
;
return
{
queue
:
this
target
:
target
method
:
method
}
;
}
;
Queue
.
prototype
.
pushUnique
=
function
pushUnique
(
target
method
args
stack
)
{
var
localQueueMap
=
this
.
targetQueues
.
get
(
target
)
;
if
(
localQueueMap
=
=
=
undefined
)
{
localQueueMap
=
new
Map
(
)
;
this
.
targetQueues
.
set
(
target
localQueueMap
)
;
}
var
index
=
localQueueMap
.
get
(
method
)
;
if
(
index
=
=
=
undefined
)
{
var
queueIndex
=
this
.
_queue
.
push
(
target
method
args
stack
)
-
4
;
localQueueMap
.
set
(
method
queueIndex
)
;
}
else
{
var
queue
=
this
.
_queue
;
queue
[
index
+
2
]
=
args
;
queue
[
index
+
3
]
=
stack
;
}
return
{
queue
:
this
target
:
target
method
:
method
}
;
}
;
Queue
.
prototype
.
invoke
=
function
invoke
(
target
method
args
)
{
if
(
args
=
=
=
undefined
)
{
method
.
call
(
target
)
;
}
else
{
method
.
apply
(
target
args
)
;
}
}
;
Queue
.
prototype
.
invokeWithOnError
=
function
invokeWithOnError
(
target
method
args
onError
errorRecordedForStack
)
{
try
{
if
(
args
=
=
=
undefined
)
{
method
.
call
(
target
)
;
}
else
{
method
.
apply
(
target
args
)
;
}
}
catch
(
error
)
{
onError
(
error
errorRecordedForStack
)
;
}
}
;
return
Queue
;
}
(
)
;
var
DeferredActionQueues
=
function
(
)
{
function
DeferredActionQueues
(
)
{
var
queueNames
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
[
]
;
var
options
=
arguments
[
1
]
;
(
0
_emberBabel
.
classCallCheck
)
(
this
DeferredActionQueues
)
;
this
.
queues
=
{
}
;
this
.
queueNameIndex
=
0
;
this
.
queueNames
=
queueNames
;
queueNames
.
reduce
(
function
(
queues
queueName
)
{
queues
[
queueName
]
=
new
Queue
(
queueName
options
[
queueName
]
options
)
;
return
queues
;
}
this
.
queues
)
;
}
DeferredActionQueues
.
prototype
.
schedule
=
function
schedule
(
queueName
target
method
args
onceFlag
stack
)
{
var
queues
=
this
.
queues
;
var
queue
=
queues
[
queueName
]
;
if
(
queue
=
=
=
undefined
)
{
throw
new
Error
(
'
You
attempted
to
schedule
an
action
in
a
queue
(
'
+
queueName
+
'
)
that
doesn
\
'
t
exist
'
)
;
}
if
(
method
=
=
=
undefined
|
|
method
=
=
=
null
)
{
throw
new
Error
(
'
You
attempted
to
schedule
an
action
in
a
queue
(
'
+
queueName
+
'
)
for
a
method
that
doesn
\
'
t
exist
'
)
;
}
if
(
onceFlag
)
{
return
queue
.
pushUnique
(
target
method
args
stack
)
;
}
else
{
return
queue
.
push
(
target
method
args
stack
)
;
}
}
;
DeferredActionQueues
.
prototype
.
flush
=
function
flush
(
)
{
var
queue
=
void
0
;
var
queueName
=
void
0
;
var
numberOfQueues
=
this
.
queueNames
.
length
;
while
(
this
.
queueNameIndex
<
numberOfQueues
)
{
queueName
=
this
.
queueNames
[
this
.
queueNameIndex
]
;
queue
=
this
.
queues
[
queueName
]
;
if
(
queue
.
hasWork
(
)
=
=
=
false
)
{
this
.
queueNameIndex
+
+
;
}
else
{
if
(
queue
.
flush
(
false
)
=
=
=
1
)
{
return
1
;
}
this
.
queueNameIndex
=
0
;
}
}
}
;
return
DeferredActionQueues
;
}
(
)
;
var
iteratorDrain
=
function
(
fn
)
{
var
iterator
=
fn
(
)
;
var
result
=
iterator
.
next
(
)
;
while
(
result
.
done
=
=
=
false
)
{
result
.
value
(
)
;
result
=
iterator
.
next
(
)
;
}
}
;
var
noop
=
function
(
)
{
}
;
var
SET_TIMEOUT
=
setTimeout
;
function
parseArgs
(
)
{
var
length
=
arguments
.
length
;
var
method
=
void
0
;
var
target
=
void
0
;
var
args
=
void
0
;
if
(
length
=
=
=
1
)
{
method
=
arguments
[
0
]
;
target
=
null
;
}
else
{
target
=
arguments
[
0
]
;
method
=
arguments
[
1
]
;
if
(
typeof
method
=
=
=
'
string
'
)
{
method
=
target
[
method
]
;
}
if
(
length
>
2
)
{
args
=
new
Array
(
length
-
2
)
;
for
(
var
i
=
0
l
=
length
-
2
;
i
<
l
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
+
2
]
;
}
}
}
return
[
target
method
args
]
;
}
var
UUID
=
0
;
var
Backburner
=
function
(
)
{
function
Backburner
(
queueNames
)
{
var
_this
=
this
;
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Backburner
)
;
this
.
DEBUG
=
false
;
this
.
currentInstance
=
null
;
this
.
instanceStack
=
[
]
;
this
.
_debouncees
=
[
]
;
this
.
_throttlers
=
[
]
;
this
.
_eventCallbacks
=
{
end
:
[
]
begin
:
[
]
}
;
this
.
_timerTimeoutId
=
null
;
this
.
_timers
=
[
]
;
this
.
_autorun
=
null
;
this
.
queueNames
=
queueNames
;
this
.
options
=
options
;
if
(
!
this
.
options
.
defaultQueue
)
{
this
.
options
.
defaultQueue
=
queueNames
[
0
]
;
}
this
.
_onBegin
=
this
.
options
.
onBegin
|
|
noop
;
this
.
_onEnd
=
this
.
options
.
onEnd
|
|
noop
;
var
_platform
=
this
.
options
.
_platform
|
|
{
}
;
var
platform
=
Object
.
create
(
null
)
;
platform
.
setTimeout
=
_platform
.
setTimeout
|
|
function
(
fn
ms
)
{
return
setTimeout
(
fn
ms
)
;
}
;
platform
.
clearTimeout
=
_platform
.
clearTimeout
|
|
function
(
id
)
{
return
clearTimeout
(
id
)
;
}
;
platform
.
next
=
_platform
.
next
|
|
function
(
fn
)
{
return
SET_TIMEOUT
(
fn
0
)
;
}
;
platform
.
clearNext
=
_platform
.
clearNext
|
|
platform
.
clearTimeout
;
platform
.
now
=
_platform
.
now
|
|
function
(
)
{
return
Date
.
now
(
)
;
}
;
this
.
_platform
=
platform
;
this
.
_boundRunExpiredTimers
=
function
(
)
{
_this
.
_runExpiredTimers
(
)
;
}
;
this
.
_boundAutorunEnd
=
function
(
)
{
_this
.
_autorun
=
null
;
_this
.
end
(
)
;
}
;
}
Backburner
.
prototype
.
begin
=
function
begin
(
)
{
var
options
=
this
.
options
;
var
previousInstance
=
this
.
currentInstance
;
var
current
=
void
0
;
if
(
this
.
_autorun
!
=
=
null
)
{
current
=
previousInstance
;
this
.
_cancelAutorun
(
)
;
}
else
{
if
(
previousInstance
!
=
=
null
)
{
this
.
instanceStack
.
push
(
previousInstance
)
;
}
current
=
this
.
currentInstance
=
new
DeferredActionQueues
(
this
.
queueNames
options
)
;
this
.
_trigger
(
'
begin
'
current
previousInstance
)
;
}
this
.
_onBegin
(
current
previousInstance
)
;
return
current
;
}
;
Backburner
.
prototype
.
end
=
function
end
(
)
{
var
currentInstance
=
this
.
currentInstance
;
var
nextInstance
=
null
;
if
(
currentInstance
=
=
=
null
)
{
throw
new
Error
(
'
end
called
without
begin
'
)
;
}
var
finallyAlreadyCalled
=
false
;
var
result
=
void
0
;
try
{
result
=
currentInstance
.
flush
(
)
;
}
finally
{
if
(
!
finallyAlreadyCalled
)
{
finallyAlreadyCalled
=
true
;
if
(
result
=
=
=
1
)
{
var
next
=
this
.
_platform
.
next
;
this
.
_autorun
=
next
(
this
.
_boundAutorunEnd
)
;
}
else
{
this
.
currentInstance
=
null
;
if
(
this
.
instanceStack
.
length
>
0
)
{
nextInstance
=
this
.
instanceStack
.
pop
(
)
;
this
.
currentInstance
=
nextInstance
;
}
this
.
_trigger
(
'
end
'
currentInstance
nextInstance
)
;
this
.
_onEnd
(
currentInstance
nextInstance
)
;
}
}
}
}
;
Backburner
.
prototype
.
on
=
function
on
(
eventName
callback
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
'
Callback
must
be
a
function
'
)
;
}
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
if
(
callbacks
!
=
=
undefined
)
{
callbacks
.
push
(
callback
)
;
}
else
{
throw
new
TypeError
(
'
Cannot
on
(
)
event
'
+
eventName
+
'
because
it
does
not
exist
'
)
;
}
}
;
Backburner
.
prototype
.
off
=
function
off
(
eventName
callback
)
{
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
if
(
!
eventName
|
|
callbacks
=
=
=
undefined
)
{
throw
new
TypeError
(
'
Cannot
off
(
)
event
'
+
eventName
+
'
because
it
does
not
exist
'
)
;
}
var
callbackFound
=
false
;
if
(
callback
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
if
(
callbacks
[
i
]
=
=
=
callback
)
{
callbackFound
=
true
;
callbacks
.
splice
(
i
1
)
;
i
-
-
;
}
}
}
if
(
!
callbackFound
)
{
throw
new
TypeError
(
'
Cannot
off
(
)
callback
that
does
not
exist
'
)
;
}
}
;
Backburner
.
prototype
.
run
=
function
run
(
)
{
var
_parseArgs
=
parseArgs
.
apply
(
undefined
arguments
)
target
=
_parseArgs
[
0
]
method
=
_parseArgs
[
1
]
args
=
_parseArgs
[
2
]
;
return
this
.
_run
(
target
method
args
)
;
}
;
Backburner
.
prototype
.
join
=
function
join
(
)
{
var
_parseArgs2
=
parseArgs
.
apply
(
undefined
arguments
)
target
=
_parseArgs2
[
0
]
method
=
_parseArgs2
[
1
]
args
=
_parseArgs2
[
2
]
;
return
this
.
_join
(
target
method
args
)
;
}
;
Backburner
.
prototype
.
defer
=
function
defer
(
queueName
targetOrMethod
)
{
for
(
var
_len
=
arguments
.
length
_args
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
_args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
return
this
.
schedule
.
apply
(
this
[
queueName
targetOrMethod
]
.
concat
(
_args
)
)
;
}
;
Backburner
.
prototype
.
schedule
=
function
schedule
(
queueName
)
{
for
(
var
_len2
=
arguments
.
length
_args
=
Array
(
_len2
>
1
?
_len2
-
1
:
0
)
_key2
=
1
;
_key2
<
_len2
;
_key2
+
+
)
{
_args
[
_key2
-
1
]
=
arguments
[
_key2
]
;
}
var
_parseArgs3
=
parseArgs
.
apply
(
undefined
_args
)
target
=
_parseArgs3
[
0
]
method
=
_parseArgs3
[
1
]
args
=
_parseArgs3
[
2
]
;
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
return
this
.
_ensureInstance
(
)
.
schedule
(
queueName
target
method
args
false
stack
)
;
}
;
Backburner
.
prototype
.
scheduleIterable
=
function
scheduleIterable
(
queueName
iterable
)
{
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
return
this
.
_ensureInstance
(
)
.
schedule
(
queueName
null
iteratorDrain
[
iterable
]
false
stack
)
;
}
;
Backburner
.
prototype
.
deferOnce
=
function
deferOnce
(
queueName
targetOrMethod
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
>
2
?
_len3
-
2
:
0
)
_key3
=
2
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
-
2
]
=
arguments
[
_key3
]
;
}
return
this
.
scheduleOnce
.
apply
(
this
[
queueName
targetOrMethod
]
.
concat
(
args
)
)
;
}
;
Backburner
.
prototype
.
scheduleOnce
=
function
scheduleOnce
(
queueName
)
{
for
(
var
_len4
=
arguments
.
length
_args
=
Array
(
_len4
>
1
?
_len4
-
1
:
0
)
_key4
=
1
;
_key4
<
_len4
;
_key4
+
+
)
{
_args
[
_key4
-
1
]
=
arguments
[
_key4
]
;
}
var
_parseArgs4
=
parseArgs
.
apply
(
undefined
_args
)
target
=
_parseArgs4
[
0
]
method
=
_parseArgs4
[
1
]
args
=
_parseArgs4
[
2
]
;
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
return
this
.
_ensureInstance
(
)
.
schedule
(
queueName
target
method
args
true
stack
)
;
}
;
Backburner
.
prototype
.
setTimeout
=
function
setTimeout
(
)
{
return
this
.
later
.
apply
(
this
arguments
)
;
}
;
Backburner
.
prototype
.
later
=
function
later
(
)
{
for
(
var
_len5
=
arguments
.
length
args
=
Array
(
_len5
)
_key5
=
0
;
_key5
<
_len5
;
_key5
+
+
)
{
args
[
_key5
]
=
arguments
[
_key5
]
;
}
var
length
=
args
.
length
;
var
wait
=
0
;
var
method
=
void
0
;
var
target
=
void
0
;
var
methodOrTarget
=
void
0
;
var
methodOrArgs
=
void
0
;
if
(
length
=
=
=
0
)
{
return
;
}
else
if
(
length
=
=
=
1
)
{
method
=
args
.
shift
(
)
;
}
else
{
var
last
=
args
[
args
.
length
-
1
]
;
if
(
isCoercableNumber
(
last
)
)
{
wait
=
parseInt
(
args
.
pop
(
)
10
)
;
}
methodOrTarget
=
args
[
0
]
;
methodOrArgs
=
args
[
1
]
;
var
type
=
typeof
methodOrArgs
;
if
(
type
=
=
=
'
function
'
)
{
target
=
args
.
shift
(
)
;
method
=
args
.
shift
(
)
;
}
else
if
(
methodOrTarget
!
=
=
null
&
&
type
=
=
=
'
string
'
&
&
methodOrArgs
in
methodOrTarget
)
{
target
=
args
.
shift
(
)
;
method
=
target
[
args
.
shift
(
)
]
;
}
else
{
method
=
args
.
shift
(
)
;
}
}
return
this
.
_setTimeout
(
target
method
args
wait
)
;
}
;
Backburner
.
prototype
.
throttle
=
function
throttle
(
targetOrThisArgOrMethod
)
{
var
_this2
=
this
;
var
target
=
void
0
;
var
method
=
void
0
;
var
immediate
=
void
0
;
var
isImmediate
=
void
0
;
var
wait
=
void
0
;
for
(
var
_len6
=
arguments
.
length
args
=
Array
(
_len6
>
1
?
_len6
-
1
:
0
)
_key6
=
1
;
_key6
<
_len6
;
_key6
+
+
)
{
args
[
_key6
-
1
]
=
arguments
[
_key6
]
;
}
if
(
args
.
length
=
=
=
1
)
{
method
=
targetOrThisArgOrMethod
;
wait
=
args
.
pop
(
)
;
target
=
null
;
isImmediate
=
true
;
}
else
{
target
=
targetOrThisArgOrMethod
;
method
=
args
.
shift
(
)
;
immediate
=
args
.
pop
(
)
;
var
type
=
typeof
method
;
if
(
type
=
=
=
'
string
'
)
{
method
=
target
[
method
]
;
}
else
if
(
type
!
=
=
'
function
'
)
{
args
.
unshift
(
method
)
;
method
=
target
;
target
=
null
;
}
if
(
isCoercableNumber
(
immediate
)
)
{
wait
=
immediate
;
isImmediate
=
true
;
}
else
{
wait
=
args
.
pop
(
)
;
isImmediate
=
immediate
=
=
=
true
;
}
}
var
index
=
findItem
(
target
method
this
.
_throttlers
)
;
if
(
index
>
-
1
)
{
this
.
_throttlers
[
index
+
2
]
=
args
;
return
this
.
_throttlers
[
index
+
3
]
;
}
wait
=
parseInt
(
wait
10
)
;
var
timer
=
this
.
_platform
.
setTimeout
(
function
(
)
{
var
i
=
findTimer
(
timer
_this2
.
_throttlers
)
;
var
_throttlers
splice
=
_this2
.
_throttlers
.
splice
(
i
4
)
context
=
_throttlers
splice
[
0
]
func
=
_throttlers
splice
[
1
]
params
=
_throttlers
splice
[
2
]
;
if
(
isImmediate
=
=
=
false
)
{
_this2
.
_run
(
context
func
params
)
;
}
}
wait
)
;
if
(
isImmediate
)
{
this
.
_join
(
target
method
args
)
;
}
this
.
_throttlers
.
push
(
target
method
args
timer
)
;
return
timer
;
}
;
Backburner
.
prototype
.
debounce
=
function
debounce
(
targetOrThisArgOrMethod
)
{
var
_this3
=
this
;
var
target
=
void
0
;
var
method
=
void
0
;
var
immediate
=
void
0
;
var
isImmediate
=
void
0
;
var
wait
=
void
0
;
for
(
var
_len7
=
arguments
.
length
args
=
Array
(
_len7
>
1
?
_len7
-
1
:
0
)
_key7
=
1
;
_key7
<
_len7
;
_key7
+
+
)
{
args
[
_key7
-
1
]
=
arguments
[
_key7
]
;
}
if
(
args
.
length
=
=
=
1
)
{
method
=
targetOrThisArgOrMethod
;
wait
=
args
.
pop
(
)
;
target
=
null
;
isImmediate
=
false
;
}
else
{
target
=
targetOrThisArgOrMethod
;
method
=
args
.
shift
(
)
;
immediate
=
args
.
pop
(
)
;
var
type
=
typeof
method
;
if
(
type
=
=
=
'
string
'
)
{
method
=
target
[
method
]
;
}
else
if
(
type
!
=
=
'
function
'
)
{
args
.
unshift
(
method
)
;
method
=
target
;
target
=
null
;
}
if
(
isCoercableNumber
(
immediate
)
)
{
wait
=
immediate
;
isImmediate
=
false
;
}
else
{
wait
=
args
.
pop
(
)
;
isImmediate
=
immediate
=
=
=
true
;
}
}
wait
=
parseInt
(
wait
10
)
;
var
index
=
findItem
(
target
method
this
.
_debouncees
)
;
if
(
index
>
-
1
)
{
var
timerId
=
this
.
_debouncees
[
index
+
3
]
;
this
.
_platform
.
clearTimeout
(
timerId
)
;
this
.
_debouncees
.
splice
(
index
4
)
;
}
var
timer
=
this
.
_platform
.
setTimeout
(
function
(
)
{
var
i
=
findTimer
(
timer
_this3
.
_debouncees
)
;
var
_debouncees
splice
=
_this3
.
_debouncees
.
splice
(
i
4
)
context
=
_debouncees
splice
[
0
]
func
=
_debouncees
splice
[
1
]
params
=
_debouncees
splice
[
2
]
;
if
(
isImmediate
=
=
=
false
)
{
_this3
.
_run
(
context
func
params
)
;
}
}
wait
)
;
if
(
isImmediate
&
&
index
=
=
=
-
1
)
{
this
.
_join
(
target
method
args
)
;
}
this
.
_debouncees
.
push
(
target
method
args
timer
)
;
return
timer
;
}
;
Backburner
.
prototype
.
cancelTimers
=
function
cancelTimers
(
)
{
for
(
var
i
=
3
;
i
<
this
.
_throttlers
.
length
;
i
+
=
4
)
{
this
.
_platform
.
clearTimeout
(
this
.
_throttlers
[
i
]
)
;
}
this
.
_throttlers
=
[
]
;
for
(
var
t
=
3
;
t
<
this
.
_debouncees
.
length
;
t
+
=
4
)
{
this
.
_platform
.
clearTimeout
(
this
.
_debouncees
[
t
]
)
;
}
this
.
_debouncees
=
[
]
;
this
.
_clearTimerTimeout
(
)
;
this
.
_timers
=
[
]
;
this
.
_cancelAutorun
(
)
;
}
;
Backburner
.
prototype
.
hasTimers
=
function
hasTimers
(
)
{
return
this
.
_timers
.
length
>
0
|
|
this
.
_debouncees
.
length
>
0
|
|
this
.
_throttlers
.
length
>
0
|
|
this
.
_autorun
!
=
=
null
;
}
;
Backburner
.
prototype
.
cancel
=
function
cancel
(
timer
)
{
if
(
!
timer
)
{
return
false
;
}
var
timerType
=
typeof
timer
;
if
(
timerType
=
=
=
'
number
'
)
{
return
this
.
_cancelItem
(
timer
this
.
_throttlers
)
|
|
this
.
_cancelItem
(
timer
this
.
_debouncees
)
;
}
else
if
(
timerType
=
=
=
'
string
'
)
{
return
this
.
_cancelLaterTimer
(
timer
)
;
}
else
if
(
timerType
=
=
=
'
object
'
&
&
timer
.
queue
&
&
timer
.
method
)
{
return
timer
.
queue
.
cancel
(
timer
)
;
}
return
false
;
}
;
Backburner
.
prototype
.
ensureInstance
=
function
ensureInstance
(
)
{
this
.
_ensureInstance
(
)
;
}
;
Backburner
.
prototype
.
_join
=
function
_join
(
target
method
args
)
{
if
(
this
.
currentInstance
=
=
=
null
)
{
return
this
.
_run
(
target
method
args
)
;
}
if
(
target
=
=
=
undefined
&
&
args
=
=
=
undefined
)
{
return
method
(
)
;
}
else
{
return
method
.
apply
(
target
args
)
;
}
}
;
Backburner
.
prototype
.
_run
=
function
_run
(
target
method
args
)
{
var
onError
=
getOnError
(
this
.
options
)
;
this
.
begin
(
)
;
if
(
onError
)
{
try
{
return
method
.
apply
(
target
args
)
;
}
catch
(
error
)
{
onError
(
error
)
;
}
finally
{
this
.
end
(
)
;
}
}
else
{
try
{
return
method
.
apply
(
target
args
)
;
}
finally
{
this
.
end
(
)
;
}
}
}
;
Backburner
.
prototype
.
_cancelAutorun
=
function
_cancelAutorun
(
)
{
if
(
this
.
_autorun
!
=
=
null
)
{
this
.
_platform
.
clearNext
(
this
.
_autorun
)
;
this
.
_autorun
=
null
;
}
}
;
Backburner
.
prototype
.
_setTimeout
=
function
_setTimeout
(
target
method
args
wait
)
{
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
var
executeAt
=
this
.
_platform
.
now
(
)
+
wait
;
var
id
=
UUID
+
+
+
'
'
;
if
(
this
.
_timers
.
length
=
=
=
0
)
{
this
.
_timers
.
push
(
executeAt
id
target
method
args
stack
)
;
this
.
_installTimerTimeout
(
)
;
return
id
;
}
var
i
=
binarySearch
(
executeAt
this
.
_timers
)
;
this
.
_timers
.
splice
(
i
0
executeAt
id
target
method
args
stack
)
;
if
(
i
=
=
=
0
)
{
this
.
_reinstallTimerTimeout
(
)
;
}
return
id
;
}
;
Backburner
.
prototype
.
_cancelLaterTimer
=
function
_cancelLaterTimer
(
timer
)
{
for
(
var
i
=
1
;
i
<
this
.
_timers
.
length
;
i
+
=
6
)
{
if
(
this
.
_timers
[
i
]
=
=
=
timer
)
{
i
=
i
-
1
;
this
.
_timers
.
splice
(
i
6
)
;
if
(
i
=
=
=
0
)
{
this
.
_reinstallTimerTimeout
(
)
;
}
return
true
;
}
}
return
false
;
}
;
Backburner
.
prototype
.
_cancelItem
=
function
_cancelItem
(
timer
array
)
{
var
index
=
findTimer
(
timer
array
)
;
if
(
index
>
-
1
)
{
this
.
_platform
.
clearTimeout
(
timer
)
;
array
.
splice
(
index
4
)
;
return
true
;
}
return
false
;
}
;
Backburner
.
prototype
.
_trigger
=
function
_trigger
(
eventName
arg1
arg2
)
{
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
if
(
callbacks
!
=
=
undefined
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
(
arg1
arg2
)
;
}
}
}
;
Backburner
.
prototype
.
_runExpiredTimers
=
function
_runExpiredTimers
(
)
{
this
.
_timerTimeoutId
=
null
;
if
(
this
.
_timers
.
length
=
=
=
0
)
{
return
;
}
this
.
begin
(
)
;
this
.
_scheduleExpiredTimers
(
)
;
this
.
end
(
)
;
}
;
Backburner
.
prototype
.
_scheduleExpiredTimers
=
function
_scheduleExpiredTimers
(
)
{
var
timers
=
this
.
_timers
;
var
i
=
0
;
var
l
=
timers
.
length
;
var
defaultQueue
=
this
.
options
.
defaultQueue
;
var
n
=
this
.
_platform
.
now
(
)
;
for
(
;
i
<
l
;
i
+
=
6
)
{
var
executeAt
=
timers
[
i
]
;
if
(
executeAt
<
=
n
)
{
var
target
=
timers
[
i
+
2
]
;
var
method
=
timers
[
i
+
3
]
;
var
_args2
=
timers
[
i
+
4
]
;
var
stack
=
timers
[
i
+
5
]
;
this
.
currentInstance
.
schedule
(
defaultQueue
target
method
_args2
false
stack
)
;
}
else
{
break
;
}
}
timers
.
splice
(
0
i
)
;
this
.
_installTimerTimeout
(
)
;
}
;
Backburner
.
prototype
.
_reinstallTimerTimeout
=
function
_reinstallTimerTimeout
(
)
{
this
.
_clearTimerTimeout
(
)
;
this
.
_installTimerTimeout
(
)
;
}
;
Backburner
.
prototype
.
_clearTimerTimeout
=
function
_clearTimerTimeout
(
)
{
if
(
this
.
_timerTimeoutId
=
=
=
null
)
{
return
;
}
this
.
_platform
.
clearTimeout
(
this
.
_timerTimeoutId
)
;
this
.
_timerTimeoutId
=
null
;
}
;
Backburner
.
prototype
.
_installTimerTimeout
=
function
_installTimerTimeout
(
)
{
if
(
this
.
_timers
.
length
=
=
=
0
)
{
return
;
}
var
minExpiresAt
=
this
.
_timers
[
0
]
;
var
n
=
this
.
_platform
.
now
(
)
;
var
wait
=
Math
.
max
(
0
minExpiresAt
-
n
)
;
this
.
_timerTimeoutId
=
this
.
_platform
.
setTimeout
(
this
.
_boundRunExpiredTimers
wait
)
;
}
;
Backburner
.
prototype
.
_ensureInstance
=
function
_ensureInstance
(
)
{
var
currentInstance
=
this
.
currentInstance
;
if
(
currentInstance
=
=
=
null
)
{
currentInstance
=
this
.
begin
(
)
;
var
next
=
this
.
_platform
.
next
;
this
.
_autorun
=
next
(
this
.
_boundAutorunEnd
)
;
}
return
currentInstance
;
}
;
return
Backburner
;
}
(
)
;
Backburner
.
Queue
=
Queue
;
exports
.
default
=
Backburner
;
}
)
;
enifed
(
'
container
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
debug
'
'
ember
/
features
'
'
ember
-
environment
'
]
function
(
exports
_emberBabel
_emberUtils
_emberDebug
_features
_emberEnvironment
)
{
'
use
strict
'
;
exports
.
Container
=
exports
.
privatize
=
exports
.
Registry
=
undefined
;
var
Container
=
function
(
)
{
function
Container
(
registry
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Container
)
;
this
.
registry
=
registry
;
this
.
owner
=
options
.
owner
|
|
null
;
this
.
cache
=
(
0
_emberUtils
.
dictionary
)
(
options
.
cache
|
|
null
)
;
this
.
factoryManagerCache
=
(
0
_emberUtils
.
dictionary
)
(
options
.
factoryManagerCache
|
|
null
)
;
this
.
isDestroyed
=
false
;
if
(
true
)
{
this
.
validationCache
=
(
0
_emberUtils
.
dictionary
)
(
options
.
validationCache
|
|
null
)
;
}
}
Container
.
prototype
.
lookup
=
function
lookup
(
fullName
options
)
{
(
true
&
&
!
(
this
.
registry
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
registry
.
isValidFullName
(
fullName
)
)
)
;
return
_lookup
(
this
this
.
registry
.
normalize
(
fullName
)
options
)
;
}
;
Container
.
prototype
.
destroy
=
function
destroy
(
)
{
destroyDestroyables
(
this
)
;
this
.
isDestroyed
=
true
;
}
;
Container
.
prototype
.
reset
=
function
reset
(
fullName
)
{
if
(
fullName
=
=
=
undefined
)
{
resetCache
(
this
)
;
}
else
{
resetMember
(
this
this
.
registry
.
normalize
(
fullName
)
)
;
}
}
;
Container
.
prototype
.
ownerInjection
=
function
ownerInjection
(
)
{
var
_ref
;
return
_ref
=
{
}
_ref
[
_emberUtils
.
OWNER
]
=
this
.
owner
_ref
;
}
;
Container
.
prototype
.
_resolverCacheKey
=
function
_resolverCacheKey
(
name
options
)
{
return
this
.
registry
.
resolverCacheKey
(
name
options
)
;
}
;
Container
.
prototype
.
factoryFor
=
function
factoryFor
(
fullName
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
normalizedName
=
this
.
registry
.
normalize
(
fullName
)
;
(
true
&
&
!
(
this
.
registry
.
isValidFullName
(
normalizedName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
registry
.
isValidFullName
(
normalizedName
)
)
)
;
if
(
options
.
source
)
{
var
expandedFullName
=
this
.
registry
.
expandLocalLookup
(
fullName
options
)
;
if
(
!
_features
.
EMBER_MODULE_UNIFICATION
)
{
if
(
!
expandedFullName
)
{
return
;
}
normalizedName
=
expandedFullName
;
}
else
if
(
expandedFullName
)
{
normalizedName
=
expandedFullName
;
options
=
{
}
;
}
}
var
cacheKey
=
this
.
_resolverCacheKey
(
normalizedName
options
)
;
var
cached
=
this
.
factoryManagerCache
[
cacheKey
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
var
factory
=
_features
.
EMBER_MODULE_UNIFICATION
?
this
.
registry
.
resolve
(
normalizedName
options
)
:
this
.
registry
.
resolve
(
normalizedName
)
;
if
(
factory
=
=
=
undefined
)
{
return
;
}
if
(
true
&
&
factory
&
&
typeof
factory
.
_onLookup
=
=
=
'
function
'
)
{
factory
.
_onLookup
(
fullName
)
;
}
var
manager
=
new
FactoryManager
(
this
factory
fullName
normalizedName
)
;
if
(
true
)
{
manager
=
wrapManagerInDeprecationProxy
(
manager
)
;
}
this
.
factoryManagerCache
[
cacheKey
]
=
manager
;
return
manager
;
}
;
return
Container
;
}
(
)
;
function
wrapManagerInDeprecationProxy
(
manager
)
{
if
(
_emberUtils
.
HAS_NATIVE_PROXY
)
{
var
validator
=
{
set
:
function
(
obj
prop
)
{
throw
new
Error
(
'
You
attempted
to
set
"
'
+
prop
+
'
"
on
a
factory
manager
created
by
container
#
factoryFor
.
A
factory
manager
is
a
read
-
only
construct
.
'
)
;
}
}
;
var
m
=
manager
;
var
proxiedManager
=
{
class
:
m
.
class
create
:
function
(
props
)
{
return
m
.
create
(
props
)
;
}
}
;
return
new
Proxy
(
proxiedManager
validator
)
;
}
return
manager
;
}
function
isSingleton
(
container
fullName
)
{
return
container
.
registry
.
getOption
(
fullName
'
singleton
'
)
!
=
=
false
;
}
function
isInstantiatable
(
container
fullName
)
{
return
container
.
registry
.
getOption
(
fullName
'
instantiate
'
)
!
=
=
false
;
}
function
_lookup
(
container
fullName
)
{
var
options
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
if
(
options
.
source
)
{
var
expandedFullName
=
container
.
registry
.
expandLocalLookup
(
fullName
options
)
;
if
(
!
_features
.
EMBER_MODULE_UNIFICATION
)
{
if
(
!
expandedFullName
)
{
return
;
}
fullName
=
expandedFullName
;
}
else
if
(
expandedFullName
)
{
fullName
=
expandedFullName
;
options
=
{
}
;
}
}
if
(
options
.
singleton
!
=
=
false
)
{
var
cacheKey
=
container
.
_resolverCacheKey
(
fullName
options
)
;
var
cached
=
container
.
cache
[
cacheKey
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
}
return
instantiateFactory
(
container
fullName
options
)
;
}
function
isSingletonClass
(
container
fullName
_ref2
)
{
var
instantiate
=
_ref2
.
instantiate
singleton
=
_ref2
.
singleton
;
return
singleton
!
=
=
false
&
&
!
instantiate
&
&
isSingleton
(
container
fullName
)
&
&
!
isInstantiatable
(
container
fullName
)
;
}
function
isSingletonInstance
(
container
fullName
_ref3
)
{
var
instantiate
=
_ref3
.
instantiate
singleton
=
_ref3
.
singleton
;
return
singleton
!
=
=
false
&
&
instantiate
!
=
=
false
&
&
isSingleton
(
container
fullName
)
&
&
isInstantiatable
(
container
fullName
)
;
}
function
isFactoryClass
(
container
fullname
_ref4
)
{
var
instantiate
=
_ref4
.
instantiate
singleton
=
_ref4
.
singleton
;
return
instantiate
=
=
=
false
&
&
(
singleton
=
=
=
false
|
|
!
isSingleton
(
container
fullname
)
)
&
&
!
isInstantiatable
(
container
fullname
)
;
}
function
isFactoryInstance
(
container
fullName
_ref5
)
{
var
instantiate
=
_ref5
.
instantiate
singleton
=
_ref5
.
singleton
;
return
instantiate
!
=
=
false
&
&
(
singleton
!
=
=
false
|
|
isSingleton
(
container
fullName
)
)
&
&
isInstantiatable
(
container
fullName
)
;
}
function
instantiateFactory
(
container
fullName
options
)
{
var
factoryManager
=
_features
.
EMBER_MODULE_UNIFICATION
&
&
options
&
&
options
.
source
?
container
.
factoryFor
(
fullName
options
)
:
container
.
factoryFor
(
fullName
)
;
if
(
factoryManager
=
=
=
undefined
)
{
return
;
}
if
(
isSingletonInstance
(
container
fullName
options
)
)
{
var
cacheKey
=
container
.
_resolverCacheKey
(
fullName
options
)
;
return
container
.
cache
[
cacheKey
]
=
factoryManager
.
create
(
)
;
}
if
(
isFactoryInstance
(
container
fullName
options
)
)
{
return
factoryManager
.
create
(
)
;
}
if
(
isSingletonClass
(
container
fullName
options
)
|
|
isFactoryClass
(
container
fullName
options
)
)
{
return
factoryManager
.
class
;
}
throw
new
Error
(
'
Could
not
create
factory
'
)
;
}
function
buildInjections
(
container
injections
)
{
var
hash
=
{
}
;
var
isDynamic
=
false
;
if
(
injections
.
length
>
0
)
{
if
(
true
)
{
container
.
registry
.
validateInjections
(
injections
)
;
}
var
injection
=
void
0
;
for
(
var
i
=
0
;
i
<
injections
.
length
;
i
+
+
)
{
injection
=
injections
[
i
]
;
hash
[
injection
.
property
]
=
_lookup
(
container
injection
.
fullName
)
;
if
(
!
isDynamic
)
{
isDynamic
=
!
isSingleton
(
container
injection
.
fullName
)
;
}
}
}
return
{
injections
:
hash
isDynamic
:
isDynamic
}
;
}
function
injectionsFor
(
container
fullName
)
{
var
registry
=
container
.
registry
;
var
_fullName
split
=
fullName
.
split
(
'
:
'
)
type
=
_fullName
split
[
0
]
;
var
injections
=
registry
.
getTypeInjections
(
type
)
.
concat
(
registry
.
getInjections
(
fullName
)
)
;
return
buildInjections
(
container
injections
)
;
}
function
destroyDestroyables
(
container
)
{
var
cache
=
container
.
cache
;
var
keys
=
Object
.
keys
(
cache
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
cache
[
key
]
;
if
(
value
.
destroy
)
{
value
.
destroy
(
)
;
}
}
}
function
resetCache
(
container
)
{
destroyDestroyables
(
container
)
;
container
.
cache
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
container
.
factoryManagerCache
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
}
function
resetMember
(
container
fullName
)
{
var
member
=
container
.
cache
[
fullName
]
;
delete
container
.
factoryManagerCache
[
fullName
]
;
if
(
member
)
{
delete
container
.
cache
[
fullName
]
;
if
(
member
.
destroy
)
{
member
.
destroy
(
)
;
}
}
}
var
FactoryManager
=
function
(
)
{
function
FactoryManager
(
container
factory
fullName
normalizedName
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
FactoryManager
)
;
this
.
container
=
container
;
this
.
owner
=
container
.
owner
;
this
.
class
=
factory
;
this
.
fullName
=
fullName
;
this
.
normalizedName
=
normalizedName
;
this
.
madeToString
=
undefined
;
this
.
injections
=
undefined
;
}
FactoryManager
.
prototype
.
toString
=
function
toString
(
)
{
if
(
this
.
madeToString
=
=
=
undefined
)
{
this
.
madeToString
=
this
.
container
.
registry
.
makeToString
(
this
.
class
this
.
fullName
)
;
}
return
this
.
madeToString
;
}
;
FactoryManager
.
prototype
.
create
=
function
create
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
var
injectionsCache
=
this
.
injections
;
if
(
injectionsCache
=
=
=
undefined
)
{
var
_injectionsFor
=
injectionsFor
(
this
.
container
this
.
normalizedName
)
injections
=
_injectionsFor
.
injections
isDynamic
=
_injectionsFor
.
isDynamic
;
injectionsCache
=
injections
;
if
(
!
isDynamic
)
{
this
.
injections
=
injections
;
}
}
var
props
=
(
0
_emberUtils
.
assign
)
(
{
}
injectionsCache
options
)
;
if
(
true
)
{
var
lazyInjections
=
void
0
;
var
validationCache
=
this
.
container
.
validationCache
;
if
(
!
validationCache
[
this
.
fullName
]
&
&
this
.
class
&
&
typeof
this
.
class
.
_lazyInjections
=
=
=
'
function
'
)
{
lazyInjections
=
this
.
class
.
_lazyInjections
(
)
;
lazyInjections
=
this
.
container
.
registry
.
normalizeInjectionsHash
(
lazyInjections
)
;
this
.
container
.
registry
.
validateInjections
(
lazyInjections
)
;
}
validationCache
[
this
.
fullName
]
=
true
;
}
if
(
!
this
.
class
.
create
)
{
throw
new
Error
(
'
Failed
to
create
an
instance
of
\
'
'
+
this
.
normalizedName
+
'
\
'
.
Most
likely
an
improperly
defined
class
or
'
+
'
an
invalid
module
export
.
'
)
;
}
if
(
typeof
this
.
class
.
_initFactory
=
=
=
'
function
'
)
{
this
.
class
.
_initFactory
(
this
)
;
}
else
{
(
0
_emberUtils
.
setOwner
)
(
props
this
.
owner
)
;
}
return
this
.
class
.
create
(
props
)
;
}
;
return
FactoryManager
;
}
(
)
;
var
VALID_FULL_NAME_REGEXP
=
/
^
[
^
:
]
+
:
[
^
:
]
+
/
;
var
missingResolverFunctionsDeprecation
=
'
Passing
a
resolver
function
into
a
Registry
is
deprecated
.
Please
pass
in
a
Resolver
object
with
a
resolve
method
.
'
;
var
Registry
=
function
(
)
{
function
Registry
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Registry
)
;
this
.
fallback
=
options
.
fallback
|
|
null
;
this
.
resolver
=
options
.
resolver
|
|
null
;
if
(
_emberEnvironment
.
ENV
.
_ENABLE_RESOLVER_FUNCTION_SUPPORT
!
=
=
true
)
{
(
true
&
&
!
(
typeof
this
.
resolver
!
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
missingResolverFunctionsDeprecation
typeof
this
.
resolver
!
=
=
'
function
'
)
)
;
}
if
(
typeof
this
.
resolver
=
=
=
'
function
'
&
&
_emberEnvironment
.
ENV
.
_ENABLE_RESOLVER_FUNCTION_SUPPORT
=
=
=
true
)
{
deprecateResolverFunction
(
this
)
;
}
this
.
registrations
=
(
0
_emberUtils
.
dictionary
)
(
options
.
registrations
|
|
null
)
;
this
.
_typeInjections
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
this
.
_injections
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
this
.
_localLookupCache
=
Object
.
create
(
null
)
;
this
.
_normalizeCache
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
this
.
_resolveCache
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
this
.
_failSet
=
new
Set
(
)
;
this
.
_options
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
this
.
_typeOptions
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
}
Registry
.
prototype
.
container
=
function
container
(
options
)
{
return
new
Container
(
this
options
)
;
}
;
Registry
.
prototype
.
register
=
function
register
(
fullName
factory
)
{
var
options
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
(
true
&
&
!
(
factory
!
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Attempting
to
register
an
unknown
factory
:
\
'
'
+
fullName
+
'
\
'
'
factory
!
=
=
undefined
)
)
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
(
true
&
&
!
(
!
this
.
_resolveCache
[
normalizedName
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
re
-
register
:
\
'
'
+
fullName
+
'
\
'
as
it
has
already
been
resolved
.
'
!
this
.
_resolveCache
[
normalizedName
]
)
)
;
this
.
_failSet
.
delete
(
normalizedName
)
;
this
.
registrations
[
normalizedName
]
=
factory
;
this
.
_options
[
normalizedName
]
=
options
;
}
;
Registry
.
prototype
.
unregister
=
function
unregister
(
fullName
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
this
.
_localLookupCache
=
Object
.
create
(
null
)
;
delete
this
.
registrations
[
normalizedName
]
;
delete
this
.
_resolveCache
[
normalizedName
]
;
delete
this
.
_options
[
normalizedName
]
;
this
.
_failSet
.
delete
(
normalizedName
)
;
}
;
Registry
.
prototype
.
resolve
=
function
resolve
(
fullName
options
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
var
factory
=
_resolve
(
this
this
.
normalize
(
fullName
)
options
)
;
if
(
factory
=
=
=
undefined
&
&
this
.
fallback
!
=
=
null
)
{
var
_fallback
;
factory
=
(
_fallback
=
this
.
fallback
)
.
resolve
.
apply
(
_fallback
arguments
)
;
}
return
factory
;
}
;
Registry
.
prototype
.
describe
=
function
describe
(
fullName
)
{
if
(
this
.
resolver
!
=
=
null
&
&
this
.
resolver
.
lookupDescription
)
{
return
this
.
resolver
.
lookupDescription
(
fullName
)
;
}
else
if
(
this
.
fallback
!
=
=
null
)
{
return
this
.
fallback
.
describe
(
fullName
)
;
}
else
{
return
fullName
;
}
}
;
Registry
.
prototype
.
normalizeFullName
=
function
normalizeFullName
(
fullName
)
{
if
(
this
.
resolver
!
=
=
null
&
&
this
.
resolver
.
normalize
)
{
return
this
.
resolver
.
normalize
(
fullName
)
;
}
else
if
(
this
.
fallback
!
=
=
null
)
{
return
this
.
fallback
.
normalizeFullName
(
fullName
)
;
}
else
{
return
fullName
;
}
}
;
Registry
.
prototype
.
normalize
=
function
normalize
(
fullName
)
{
return
this
.
_normalizeCache
[
fullName
]
|
|
(
this
.
_normalizeCache
[
fullName
]
=
this
.
normalizeFullName
(
fullName
)
)
;
}
;
Registry
.
prototype
.
makeToString
=
function
makeToString
(
factory
fullName
)
{
if
(
this
.
resolver
!
=
=
null
&
&
this
.
resolver
.
makeToString
)
{
return
this
.
resolver
.
makeToString
(
factory
fullName
)
;
}
else
if
(
this
.
fallback
!
=
=
null
)
{
return
this
.
fallback
.
makeToString
(
factory
fullName
)
;
}
else
{
return
factory
.
toString
(
)
;
}
}
;
Registry
.
prototype
.
has
=
function
has
(
fullName
options
)
{
if
(
!
this
.
isValidFullName
(
fullName
)
)
{
return
false
;
}
var
source
=
options
&
&
options
.
source
&
&
this
.
normalize
(
options
.
source
)
;
return
_has
(
this
this
.
normalize
(
fullName
)
source
)
;
}
;
Registry
.
prototype
.
optionsForType
=
function
optionsForType
(
type
options
)
{
this
.
_typeOptions
[
type
]
=
options
;
}
;
Registry
.
prototype
.
getOptionsForType
=
function
getOptionsForType
(
type
)
{
var
optionsForType
=
this
.
_typeOptions
[
type
]
;
if
(
optionsForType
=
=
=
undefined
&
&
this
.
fallback
!
=
=
null
)
{
optionsForType
=
this
.
fallback
.
getOptionsForType
(
type
)
;
}
return
optionsForType
;
}
;
Registry
.
prototype
.
options
=
function
options
(
fullName
)
{
var
_options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
this
.
_options
[
normalizedName
]
=
_options
;
}
;
Registry
.
prototype
.
getOptions
=
function
getOptions
(
fullName
)
{
var
normalizedName
=
this
.
normalize
(
fullName
)
;
var
options
=
this
.
_options
[
normalizedName
]
;
if
(
options
=
=
=
undefined
&
&
this
.
fallback
!
=
=
null
)
{
options
=
this
.
fallback
.
getOptions
(
fullName
)
;
}
return
options
;
}
;
Registry
.
prototype
.
getOption
=
function
getOption
(
fullName
optionName
)
{
var
options
=
this
.
_options
[
fullName
]
;
if
(
options
&
&
options
[
optionName
]
!
=
=
undefined
)
{
return
options
[
optionName
]
;
}
var
type
=
fullName
.
split
(
'
:
'
)
[
0
]
;
options
=
this
.
_typeOptions
[
type
]
;
if
(
options
&
&
options
[
optionName
]
!
=
=
undefined
)
{
return
options
[
optionName
]
;
}
else
if
(
this
.
fallback
!
=
=
null
)
{
return
this
.
fallback
.
getOption
(
fullName
optionName
)
;
}
}
;
Registry
.
prototype
.
typeInjection
=
function
typeInjection
(
type
property
fullName
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
var
fullNameType
=
fullName
.
split
(
'
:
'
)
[
0
]
;
(
true
&
&
!
(
fullNameType
!
=
=
type
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
inject
a
\
'
'
+
fullName
+
'
\
'
on
other
'
+
type
+
'
(
s
)
.
'
fullNameType
!
=
=
type
)
)
;
var
injections
=
this
.
_typeInjections
[
type
]
|
|
(
this
.
_typeInjections
[
type
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
fullName
}
)
;
}
;
Registry
.
prototype
.
injection
=
function
injection
(
fullName
property
injectionName
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
injectionName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Invalid
injectionName
expected
:
\
'
type
:
name
\
'
got
:
'
+
injectionName
this
.
isValidFullName
(
injectionName
)
)
)
;
var
normalizedInjectionName
=
this
.
normalize
(
injectionName
)
;
if
(
fullName
.
indexOf
(
'
:
'
)
=
=
=
-
1
)
{
return
this
.
typeInjection
(
fullName
property
normalizedInjectionName
)
;
}
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
var
injections
=
this
.
_injections
[
normalizedName
]
|
|
(
this
.
_injections
[
normalizedName
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
normalizedInjectionName
}
)
;
}
;
Registry
.
prototype
.
knownForType
=
function
knownForType
(
type
)
{
var
localKnown
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
var
registeredNames
=
Object
.
keys
(
this
.
registrations
)
;
for
(
var
index
=
0
;
index
<
registeredNames
.
length
;
index
+
+
)
{
var
fullName
=
registeredNames
[
index
]
;
var
itemType
=
fullName
.
split
(
'
:
'
)
[
0
]
;
if
(
itemType
=
=
=
type
)
{
localKnown
[
fullName
]
=
true
;
}
}
var
fallbackKnown
=
void
0
resolverKnown
=
void
0
;
if
(
this
.
fallback
!
=
=
null
)
{
fallbackKnown
=
this
.
fallback
.
knownForType
(
type
)
;
}
if
(
this
.
resolver
!
=
=
null
&
&
this
.
resolver
.
knownForType
)
{
resolverKnown
=
this
.
resolver
.
knownForType
(
type
)
;
}
return
(
0
_emberUtils
.
assign
)
(
{
}
fallbackKnown
localKnown
resolverKnown
)
;
}
;
Registry
.
prototype
.
isValidFullName
=
function
isValidFullName
(
fullName
)
{
return
VALID_FULL_NAME_REGEXP
.
test
(
fullName
)
;
}
;
Registry
.
prototype
.
getInjections
=
function
getInjections
(
fullName
)
{
var
injections
=
this
.
_injections
[
fullName
]
|
|
[
]
;
if
(
this
.
fallback
!
=
=
null
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getInjections
(
fullName
)
)
;
}
return
injections
;
}
;
Registry
.
prototype
.
getTypeInjections
=
function
getTypeInjections
(
type
)
{
var
injections
=
this
.
_typeInjections
[
type
]
|
|
[
]
;
if
(
this
.
fallback
!
=
=
null
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getTypeInjections
(
type
)
)
;
}
return
injections
;
}
;
Registry
.
prototype
.
resolverCacheKey
=
function
resolverCacheKey
(
name
options
)
{
if
(
!
_features
.
EMBER_MODULE_UNIFICATION
)
{
return
name
;
}
return
options
&
&
options
.
source
?
options
.
source
+
'
:
'
+
name
:
name
;
}
;
Registry
.
prototype
.
expandLocalLookup
=
function
expandLocalLookup
(
fullName
options
)
{
if
(
this
.
resolver
!
=
=
null
&
&
this
.
resolver
.
expandLocalLookup
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
fullName
must
be
a
proper
full
name
'
this
.
isValidFullName
(
fullName
)
)
)
;
(
true
&
&
!
(
options
&
&
options
.
source
)
&
&
(
0
_emberDebug
.
assert
)
(
'
options
.
source
must
be
provided
to
expandLocalLookup
'
options
&
&
options
.
source
)
)
;
(
true
&
&
!
(
this
.
isValidFullName
(
options
.
source
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
options
.
source
must
be
a
proper
full
name
'
this
.
isValidFullName
(
options
.
source
)
)
)
;
var
normalizedFullName
=
this
.
normalize
(
fullName
)
;
var
normalizedSource
=
this
.
normalize
(
options
.
source
)
;
return
_expandLocalLookup
(
this
normalizedFullName
normalizedSource
)
;
}
else
if
(
this
.
fallback
!
=
=
null
)
{
return
this
.
fallback
.
expandLocalLookup
(
fullName
options
)
;
}
else
{
return
null
;
}
}
;
return
Registry
;
}
(
)
;
function
deprecateResolverFunction
(
registry
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
missingResolverFunctionsDeprecation
false
{
id
:
'
ember
-
application
.
registry
-
resolver
-
as
-
function
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_registry
-
resolver
-
as
-
function
'
}
)
)
;
registry
.
resolver
=
{
resolve
:
registry
.
resolver
}
;
}
if
(
true
)
{
Registry
.
prototype
.
normalizeInjectionsHash
=
function
(
hash
)
{
var
injections
=
[
]
;
for
(
var
key
in
hash
)
{
if
(
hash
.
hasOwnProperty
(
key
)
)
{
(
true
&
&
!
(
this
.
isValidFullName
(
hash
[
key
]
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Expected
a
proper
full
name
given
\
'
'
+
hash
[
key
]
+
'
\
'
'
this
.
isValidFullName
(
hash
[
key
]
)
)
)
;
injections
.
push
(
{
property
:
key
fullName
:
hash
[
key
]
}
)
;
}
}
return
injections
;
}
;
Registry
.
prototype
.
validateInjections
=
function
(
injections
)
{
if
(
!
injections
)
{
return
;
}
var
fullName
=
void
0
;
for
(
var
i
=
0
;
i
<
injections
.
length
;
i
+
+
)
{
fullName
=
injections
[
i
]
.
fullName
;
(
true
&
&
!
(
this
.
has
(
fullName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Attempting
to
inject
an
unknown
injection
:
\
'
'
+
fullName
+
'
\
'
'
this
.
has
(
fullName
)
)
)
;
}
}
;
}
function
_expandLocalLookup
(
registry
normalizedName
normalizedSource
)
{
var
cache
=
registry
.
_localLookupCache
;
var
normalizedNameCache
=
cache
[
normalizedName
]
;
if
(
!
normalizedNameCache
)
{
normalizedNameCache
=
cache
[
normalizedName
]
=
Object
.
create
(
null
)
;
}
var
cached
=
normalizedNameCache
[
normalizedSource
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
var
expanded
=
registry
.
resolver
.
expandLocalLookup
(
normalizedName
normalizedSource
)
;
return
normalizedNameCache
[
normalizedSource
]
=
expanded
;
}
function
_resolve
(
registry
normalizedName
options
)
{
if
(
options
&
&
options
.
source
)
{
var
expandedNormalizedName
=
registry
.
expandLocalLookup
(
normalizedName
options
)
;
if
(
!
_features
.
EMBER_MODULE_UNIFICATION
)
{
if
(
!
expandedNormalizedName
)
{
return
;
}
normalizedName
=
expandedNormalizedName
;
}
else
if
(
expandedNormalizedName
)
{
normalizedName
=
expandedNormalizedName
;
options
=
{
}
;
}
}
var
cacheKey
=
registry
.
resolverCacheKey
(
normalizedName
options
)
;
var
cached
=
registry
.
_resolveCache
[
cacheKey
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
if
(
registry
.
_failSet
.
has
(
cacheKey
)
)
{
return
;
}
var
resolved
=
void
0
;
if
(
registry
.
resolver
)
{
resolved
=
registry
.
resolver
.
resolve
(
normalizedName
options
&
&
options
.
source
)
;
}
if
(
resolved
=
=
=
undefined
)
{
resolved
=
registry
.
registrations
[
normalizedName
]
;
}
if
(
resolved
=
=
=
undefined
)
{
registry
.
_failSet
.
add
(
cacheKey
)
;
}
else
{
registry
.
_resolveCache
[
cacheKey
]
=
resolved
;
}
return
resolved
;
}
function
_has
(
registry
fullName
source
)
{
return
registry
.
resolve
(
fullName
{
source
:
source
}
)
!
=
=
undefined
;
}
var
privateNames
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
var
privateSuffix
=
(
'
'
+
Math
.
random
(
)
+
Date
.
now
(
)
)
.
replace
(
'
.
'
'
'
)
;
function
privatize
(
_ref6
)
{
var
fullName
=
_ref6
[
0
]
;
var
name
=
privateNames
[
fullName
]
;
if
(
name
)
{
return
name
;
}
var
_fullName
split2
=
fullName
.
split
(
'
:
'
)
type
=
_fullName
split2
[
0
]
rawName
=
_fullName
split2
[
1
]
;
return
privateNames
[
fullName
]
=
(
0
_emberUtils
.
intern
)
(
type
+
'
:
'
+
rawName
+
'
-
'
+
privateSuffix
)
;
}
exports
.
Registry
=
Registry
;
exports
.
privatize
=
privatize
;
exports
.
Container
=
Container
;
}
)
;
enifed
(
"
dag
-
map
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
DAG
=
function
(
)
{
function
DAG
(
)
{
this
.
_vertices
=
new
Vertices
(
)
;
}
DAG
.
prototype
.
add
=
function
(
key
value
before
after
)
{
if
(
!
key
)
throw
new
Error
(
'
argument
key
is
required
'
)
;
var
vertices
=
this
.
_vertices
;
var
v
=
vertices
.
add
(
key
)
;
v
.
val
=
value
;
if
(
before
)
{
if
(
typeof
before
=
=
=
"
string
"
)
{
vertices
.
addEdge
(
v
vertices
.
add
(
before
)
)
;
}
else
{
for
(
var
i
=
0
;
i
<
before
.
length
;
i
+
+
)
{
vertices
.
addEdge
(
v
vertices
.
add
(
before
[
i
]
)
)
;
}
}
}
if
(
after
)
{
if
(
typeof
after
=
=
=
"
string
"
)
{
vertices
.
addEdge
(
vertices
.
add
(
after
)
v
)
;
}
else
{
for
(
var
i
=
0
;
i
<
after
.
length
;
i
+
+
)
{
vertices
.
addEdge
(
vertices
.
add
(
after
[
i
]
)
v
)
;
}
}
}
}
;
DAG
.
prototype
.
addEdges
=
function
(
key
value
before
after
)
{
this
.
add
(
key
value
before
after
)
;
}
;
DAG
.
prototype
.
each
=
function
(
callback
)
{
this
.
_vertices
.
walk
(
callback
)
;
}
;
DAG
.
prototype
.
topsort
=
function
(
callback
)
{
this
.
each
(
callback
)
;
}
;
return
DAG
;
}
(
)
;
exports
.
default
=
DAG
;
var
Vertices
=
function
(
)
{
function
Vertices
(
)
{
this
.
length
=
0
;
this
.
stack
=
new
IntStack
(
)
;
this
.
path
=
new
IntStack
(
)
;
this
.
result
=
new
IntStack
(
)
;
}
Vertices
.
prototype
.
add
=
function
(
key
)
{
if
(
!
key
)
throw
new
Error
(
"
missing
key
"
)
;
var
l
=
this
.
length
|
0
;
var
vertex
;
for
(
var
i
=
0
;
i
<
l
;
i
+
+
)
{
vertex
=
this
[
i
]
;
if
(
vertex
.
key
=
=
=
key
)
return
vertex
;
}
this
.
length
=
l
+
1
;
return
this
[
l
]
=
{
idx
:
l
key
:
key
val
:
undefined
out
:
false
flag
:
false
length
:
0
}
;
}
;
Vertices
.
prototype
.
addEdge
=
function
(
v
w
)
{
this
.
check
(
v
w
.
key
)
;
var
l
=
w
.
length
|
0
;
for
(
var
i
=
0
;
i
<
l
;
i
+
+
)
{
if
(
w
[
i
]
=
=
=
v
.
idx
)
return
;
}
w
.
length
=
l
+
1
;
w
[
l
]
=
v
.
idx
;
v
.
out
=
true
;
}
;
Vertices
.
prototype
.
walk
=
function
(
cb
)
{
this
.
reset
(
)
;
for
(
var
i
=
0
;
i
<
this
.
length
;
i
+
+
)
{
var
vertex
=
this
[
i
]
;
if
(
vertex
.
out
)
continue
;
this
.
visit
(
vertex
"
"
)
;
}
this
.
each
(
this
.
result
cb
)
;
}
;
Vertices
.
prototype
.
check
=
function
(
v
w
)
{
if
(
v
.
key
=
=
=
w
)
{
throw
new
Error
(
"
cycle
detected
:
"
+
w
+
"
<
-
"
+
w
)
;
}
if
(
v
.
length
=
=
=
0
)
return
;
for
(
var
i
=
0
;
i
<
v
.
length
;
i
+
+
)
{
var
key
=
this
[
v
[
i
]
]
.
key
;
if
(
key
=
=
=
w
)
{
throw
new
Error
(
"
cycle
detected
:
"
+
w
+
"
<
-
"
+
v
.
key
+
"
<
-
"
+
w
)
;
}
}
this
.
reset
(
)
;
this
.
visit
(
v
w
)
;
if
(
this
.
path
.
length
>
0
)
{
var
msg_1
=
"
cycle
detected
:
"
+
w
;
this
.
each
(
this
.
path
function
(
key
)
{
msg_1
+
=
"
<
-
"
+
key
;
}
)
;
throw
new
Error
(
msg_1
)
;
}
}
;
Vertices
.
prototype
.
reset
=
function
(
)
{
this
.
stack
.
length
=
0
;
this
.
path
.
length
=
0
;
this
.
result
.
length
=
0
;
for
(
var
i
=
0
l
=
this
.
length
;
i
<
l
;
i
+
+
)
{
this
[
i
]
.
flag
=
false
;
}
}
;
Vertices
.
prototype
.
visit
=
function
(
start
search
)
{
var
_a
=
this
stack
=
_a
.
stack
path
=
_a
.
path
result
=
_a
.
result
;
stack
.
push
(
start
.
idx
)
;
while
(
stack
.
length
)
{
var
index
=
stack
.
pop
(
)
|
0
;
if
(
index
>
=
0
)
{
var
vertex
=
this
[
index
]
;
if
(
vertex
.
flag
)
continue
;
vertex
.
flag
=
true
;
path
.
push
(
index
)
;
if
(
search
=
=
=
vertex
.
key
)
break
;
stack
.
push
(
~
index
)
;
this
.
pushIncoming
(
vertex
)
;
}
else
{
path
.
pop
(
)
;
result
.
push
(
~
index
)
;
}
}
}
;
Vertices
.
prototype
.
pushIncoming
=
function
(
incomming
)
{
var
stack
=
this
.
stack
;
for
(
var
i
=
incomming
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
index
=
incomming
[
i
]
;
if
(
!
this
[
index
]
.
flag
)
{
stack
.
push
(
index
)
;
}
}
}
;
Vertices
.
prototype
.
each
=
function
(
indices
cb
)
{
for
(
var
i
=
0
l
=
indices
.
length
;
i
<
l
;
i
+
+
)
{
var
vertex
=
this
[
indices
[
i
]
]
;
cb
(
vertex
.
key
vertex
.
val
)
;
}
}
;
return
Vertices
;
}
(
)
;
var
IntStack
=
function
(
)
{
function
IntStack
(
)
{
this
.
length
=
0
;
}
IntStack
.
prototype
.
push
=
function
(
n
)
{
this
[
this
.
length
+
+
]
=
n
|
0
;
}
;
IntStack
.
prototype
.
pop
=
function
(
)
{
return
this
[
-
-
this
.
length
]
|
0
;
}
;
return
IntStack
;
}
(
)
;
}
)
;
enifed
(
'
ember
-
application
/
index
'
[
'
exports
'
'
ember
-
application
/
system
/
application
'
'
ember
-
application
/
system
/
application
-
instance
'
'
ember
-
application
/
system
/
resolver
'
'
ember
-
application
/
system
/
engine
'
'
ember
-
application
/
system
/
engine
-
instance
'
'
ember
-
application
/
system
/
engine
-
parent
'
'
ember
-
application
/
initializers
/
dom
-
templates
'
]
function
(
exports
_application
_applicationInstance
_resolver
_engine
_engineInstance
_engineParent
)
{
'
use
strict
'
;
exports
.
setEngineParent
=
exports
.
getEngineParent
=
exports
.
EngineInstance
=
exports
.
Engine
=
exports
.
Resolver
=
exports
.
ApplicationInstance
=
exports
.
Application
=
undefined
;
Object
.
defineProperty
(
exports
'
Application
'
{
enumerable
:
true
get
:
function
(
)
{
return
_application
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ApplicationInstance
'
{
enumerable
:
true
get
:
function
(
)
{
return
_applicationInstance
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Resolver
'
{
enumerable
:
true
get
:
function
(
)
{
return
_resolver
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Engine
'
{
enumerable
:
true
get
:
function
(
)
{
return
_engine
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
EngineInstance
'
{
enumerable
:
true
get
:
function
(
)
{
return
_engineInstance
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getEngineParent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_engineParent
.
getEngineParent
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setEngineParent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_engineParent
.
setEngineParent
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
application
/
initializers
/
dom
-
templates
'
[
'
require
'
'
ember
-
glimmer
'
'
ember
-
environment
'
'
ember
-
application
/
system
/
application
'
]
function
(
_require2
_emberGlimmer
_emberEnvironment
_application
)
{
'
use
strict
'
;
var
bootstrap
=
function
(
)
{
}
;
_application
.
default
.
initializer
(
{
name
:
'
domTemplates
'
initialize
:
function
(
)
{
var
bootstrapModuleId
=
'
ember
-
template
-
compiler
/
system
/
bootstrap
'
;
var
context
=
void
0
;
if
(
_emberEnvironment
.
environment
.
hasDOM
&
&
(
0
_require2
.
has
)
(
bootstrapModuleId
)
)
{
bootstrap
=
(
0
_require2
.
default
)
(
bootstrapModuleId
)
.
default
;
context
=
document
;
}
bootstrap
(
{
context
:
context
hasTemplate
:
_emberGlimmer
.
hasTemplate
setTemplate
:
_emberGlimmer
.
setTemplate
}
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
application
-
instance
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
environment
'
'
ember
-
views
'
'
ember
-
application
/
system
/
engine
-
instance
'
'
ember
-
glimmer
'
]
function
(
exports
_emberUtils
_emberMetal
_emberEnvironment
_emberViews
_engineInstance
_emberGlimmer
)
{
'
use
strict
'
;
var
ApplicationInstance
=
_engineInstance
.
default
.
extend
(
{
application
:
null
customEvents
:
null
rootElement
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
register
(
'
-
application
-
instance
:
main
'
this
{
instantiate
:
false
}
)
;
}
_bootSync
:
function
(
options
)
{
if
(
this
.
_booted
)
{
return
this
;
}
options
=
new
BootOptions
(
options
)
;
this
.
setupRegistry
(
options
)
;
if
(
options
.
rootElement
)
{
this
.
rootElement
=
options
.
rootElement
;
}
else
{
this
.
rootElement
=
this
.
application
.
rootElement
;
}
if
(
options
.
location
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
(
0
_emberMetal
.
set
)
(
router
'
location
'
options
.
location
)
;
}
this
.
application
.
runInstanceInitializers
(
this
)
;
if
(
options
.
isInteractive
)
{
this
.
setupEventDispatcher
(
)
;
}
this
.
_booted
=
true
;
return
this
;
}
setupRegistry
:
function
(
options
)
{
this
.
constructor
.
setupRegistry
(
this
.
__registry__
options
)
;
}
router
:
(
0
_emberMetal
.
computed
)
(
function
(
)
{
return
this
.
lookup
(
'
router
:
main
'
)
;
}
)
.
readOnly
(
)
didCreateRootView
:
function
(
view
)
{
view
.
appendTo
(
this
.
rootElement
)
;
}
startRouting
:
function
(
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
router
.
startRouting
(
)
;
this
.
_didSetupRouter
=
true
;
}
setupRouter
:
function
(
)
{
if
(
this
.
_didSetupRouter
)
{
return
;
}
this
.
_didSetupRouter
=
true
;
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
router
.
setupRouter
(
)
;
}
handleURL
:
function
(
url
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
this
.
setupRouter
(
)
;
return
router
.
handleURL
(
url
)
;
}
setupEventDispatcher
:
function
(
)
{
var
dispatcher
=
this
.
lookup
(
'
event_dispatcher
:
main
'
)
;
var
applicationCustomEvents
=
(
0
_emberMetal
.
get
)
(
this
.
application
'
customEvents
'
)
;
var
instanceCustomEvents
=
(
0
_emberMetal
.
get
)
(
this
'
customEvents
'
)
;
var
customEvents
=
(
0
_emberUtils
.
assign
)
(
{
}
applicationCustomEvents
instanceCustomEvents
)
;
dispatcher
.
setup
(
customEvents
this
.
rootElement
)
;
return
dispatcher
;
}
getURL
:
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
router
.
url
'
)
;
}
visit
:
function
(
url
)
{
var
_this
=
this
;
this
.
setupRouter
(
)
;
var
bootOptions
=
this
.
__container__
.
lookup
(
'
-
environment
:
main
'
)
;
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
var
handleTransitionResolve
=
function
(
)
{
if
(
!
bootOptions
.
options
.
shouldRender
)
{
return
_this
;
}
else
{
return
(
0
_emberGlimmer
.
renderSettled
)
(
)
.
then
(
function
(
)
{
return
_this
;
}
)
;
}
}
;
var
handleTransitionReject
=
function
(
error
)
{
if
(
error
.
error
)
{
throw
error
.
error
;
}
else
if
(
error
.
name
=
=
=
'
TransitionAborted
'
&
&
router
.
_routerMicrolib
.
activeTransition
)
{
return
router
.
_routerMicrolib
.
activeTransition
.
then
(
handleTransitionResolve
handleTransitionReject
)
;
}
else
if
(
error
.
name
=
=
=
'
TransitionAborted
'
)
{
throw
new
Error
(
error
.
message
)
;
}
else
{
throw
error
;
}
}
;
var
location
=
(
0
_emberMetal
.
get
)
(
router
'
location
'
)
;
location
.
setURL
(
url
)
;
return
router
.
handleURL
(
location
.
getURL
(
)
)
.
then
(
handleTransitionResolve
handleTransitionReject
)
;
}
}
)
;
ApplicationInstance
.
reopenClass
(
{
setupRegistry
:
function
(
registry
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
if
(
!
options
.
toEnvironment
)
{
options
=
new
BootOptions
(
options
)
;
}
registry
.
register
(
'
-
environment
:
main
'
options
.
toEnvironment
(
)
{
instantiate
:
false
}
)
;
registry
.
register
(
'
service
:
-
document
'
options
.
document
{
instantiate
:
false
}
)
;
this
.
_super
(
registry
options
)
;
}
}
)
;
function
BootOptions
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
this
.
jQuery
=
_emberViews
.
jQuery
;
this
.
isInteractive
=
_emberEnvironment
.
environment
.
hasDOM
;
if
(
options
.
isBrowser
!
=
=
undefined
)
{
this
.
isBrowser
=
!
!
options
.
isBrowser
;
}
else
{
this
.
isBrowser
=
_emberEnvironment
.
environment
.
hasDOM
;
}
if
(
!
this
.
isBrowser
)
{
this
.
jQuery
=
null
;
this
.
isInteractive
=
false
;
this
.
location
=
'
none
'
;
}
if
(
options
.
shouldRender
!
=
=
undefined
)
{
this
.
shouldRender
=
!
!
options
.
shouldRender
;
}
else
{
this
.
shouldRender
=
true
;
}
if
(
!
this
.
shouldRender
)
{
this
.
jQuery
=
null
;
this
.
isInteractive
=
false
;
}
if
(
options
.
document
)
{
this
.
document
=
options
.
document
;
}
else
{
this
.
document
=
typeof
document
!
=
=
'
undefined
'
?
document
:
null
;
}
if
(
options
.
rootElement
)
{
this
.
rootElement
=
options
.
rootElement
;
}
if
(
options
.
location
!
=
=
undefined
)
{
this
.
location
=
options
.
location
;
}
if
(
options
.
jQuery
!
=
=
undefined
)
{
this
.
jQuery
=
options
.
jQuery
;
}
if
(
options
.
isInteractive
!
=
=
undefined
)
{
this
.
isInteractive
=
!
!
options
.
isInteractive
;
}
}
BootOptions
.
prototype
.
toEnvironment
=
function
(
)
{
var
env
=
(
0
_emberUtils
.
assign
)
(
{
}
_emberEnvironment
.
environment
)
;
env
.
hasDOM
=
this
.
isBrowser
;
env
.
isInteractive
=
this
.
isInteractive
;
env
.
options
=
this
;
return
env
;
}
;
exports
.
default
=
ApplicationInstance
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
application
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
environment
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
views
'
'
ember
-
routing
'
'
ember
-
application
/
system
/
application
-
instance
'
'
container
'
'
ember
-
application
/
system
/
engine
'
'
ember
-
glimmer
'
'
ember
/
features
'
]
function
(
exports
_emberBabel
_emberUtils
_emberEnvironment
_emberDebug
_emberMetal
_emberRuntime
_emberViews
_emberRouting
_applicationInstance
_container
_engine
_emberGlimmer
_features
)
{
'
use
strict
'
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
-
bucket
-
cache
:
main
'
]
[
'
-
bucket
-
cache
:
main
'
]
)
;
var
librariesRegistered
=
false
;
var
Application
=
_engine
.
default
.
extend
(
{
rootElement
:
'
body
'
eventDispatcher
:
null
customEvents
:
null
autoboot
:
true
_globalsMode
:
true
init
:
function
(
options
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
!
this
.
)
{
this
.
=
_emberViews
.
jQuery
;
}
registerLibraries
(
)
;
if
(
true
)
{
logLibraryVersions
(
)
;
}
this
.
_readinessDeferrals
=
1
;
this
.
_booted
=
false
;
this
.
autoboot
=
this
.
_globalsMode
=
!
!
this
.
autoboot
;
if
(
this
.
_globalsMode
)
{
this
.
_prepareForGlobalsMode
(
)
;
}
if
(
this
.
autoboot
)
{
this
.
waitForDOMReady
(
)
;
}
}
buildInstance
:
function
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
options
.
base
=
this
;
options
.
application
=
this
;
return
_applicationInstance
.
default
.
create
(
options
)
;
}
_prepareForGlobalsMode
:
function
(
)
{
this
.
Router
=
(
this
.
Router
|
|
_emberRouting
.
Router
)
.
extend
(
)
;
this
.
_buildDeprecatedInstance
(
)
;
}
_buildDeprecatedInstance
:
function
(
)
{
var
instance
=
this
.
buildInstance
(
)
;
this
.
__deprecatedInstance__
=
instance
;
this
.
__container__
=
instance
.
__container__
;
}
waitForDOMReady
:
function
(
)
{
if
(
!
this
.
|
|
this
.
.
isReady
)
{
_emberMetal
.
run
.
schedule
(
'
actions
'
this
'
domReady
'
)
;
}
else
{
this
.
(
)
.
ready
(
_emberMetal
.
run
.
bind
(
this
'
domReady
'
)
)
;
}
}
domReady
:
function
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
this
.
_bootSync
(
)
;
}
deferReadiness
:
function
(
)
{
(
true
&
&
!
(
this
instanceof
Application
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
must
call
deferReadiness
on
an
instance
of
Application
'
this
instanceof
Application
)
)
;
(
true
&
&
!
(
this
.
_readinessDeferrals
>
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
defer
readiness
since
the
ready
(
)
hook
has
already
been
called
.
'
this
.
_readinessDeferrals
>
0
)
)
;
this
.
_readinessDeferrals
+
+
;
}
advanceReadiness
:
function
(
)
{
(
true
&
&
!
(
this
instanceof
Application
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
must
call
advanceReadiness
on
an
instance
of
Application
'
this
instanceof
Application
)
)
;
this
.
_readinessDeferrals
-
-
;
if
(
this
.
_readinessDeferrals
=
=
=
0
)
{
_emberMetal
.
run
.
once
(
this
this
.
didBecomeReady
)
;
}
}
boot
:
function
(
)
{
if
(
this
.
_bootPromise
)
{
return
this
.
_bootPromise
;
}
try
{
this
.
_bootSync
(
)
;
}
catch
(
_
)
{
}
return
this
.
_bootPromise
;
}
_bootSync
:
function
(
)
{
if
(
this
.
_booted
)
{
return
;
}
var
defer
=
this
.
_bootResolver
=
_emberRuntime
.
RSVP
.
defer
(
)
;
this
.
_bootPromise
=
defer
.
promise
;
try
{
this
.
runInitializers
(
)
;
(
0
_emberRuntime
.
runLoadHooks
)
(
'
application
'
this
)
;
this
.
advanceReadiness
(
)
;
}
catch
(
error
)
{
defer
.
reject
(
error
)
;
throw
error
;
}
}
reset
:
function
(
)
{
(
true
&
&
!
(
this
.
_globalsMode
&
&
this
.
autoboot
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Calling
reset
(
)
on
instances
of
Application
is
not
\
n
supported
when
globals
mode
is
disabled
;
call
visit
(
)
to
\
n
create
new
ApplicationInstance
s
and
dispose
them
\
n
via
their
destroy
(
)
method
instead
.
'
this
.
_globalsMode
&
&
this
.
autoboot
)
)
;
var
instance
=
this
.
__deprecatedInstance__
;
this
.
_readinessDeferrals
=
1
;
this
.
_bootPromise
=
null
;
this
.
_bootResolver
=
null
;
this
.
_booted
=
false
;
function
handleReset
(
)
{
(
0
_emberMetal
.
run
)
(
instance
'
destroy
'
)
;
this
.
_buildDeprecatedInstance
(
)
;
_emberMetal
.
run
.
schedule
(
'
actions
'
this
'
_bootSync
'
)
;
}
_emberMetal
.
run
.
join
(
this
handleReset
)
;
}
didBecomeReady
:
function
(
)
{
try
{
if
(
!
(
0
_emberDebug
.
isTesting
)
(
)
)
{
_emberRuntime
.
Namespace
.
processAll
(
)
;
(
0
_emberRuntime
.
setNamespaceSearchDisabled
)
(
true
)
;
}
if
(
this
.
autoboot
)
{
var
instance
=
void
0
;
if
(
this
.
_globalsMode
)
{
instance
=
this
.
__deprecatedInstance__
;
}
else
{
instance
=
this
.
buildInstance
(
)
;
}
instance
.
_bootSync
(
)
;
this
.
ready
(
)
;
instance
.
startRouting
(
)
;
}
this
.
_bootResolver
.
resolve
(
this
)
;
this
.
_booted
=
true
;
}
catch
(
error
)
{
this
.
_bootResolver
.
reject
(
error
)
;
throw
error
;
}
}
ready
:
function
(
)
{
return
this
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
0
_emberRuntime
.
setNamespaceSearchDisabled
)
(
false
)
;
this
.
_booted
=
false
;
this
.
_bootPromise
=
null
;
this
.
_bootResolver
=
null
;
if
(
_emberRuntime
.
_loaded
.
application
=
=
=
this
)
{
_emberRuntime
.
_loaded
.
application
=
undefined
;
}
if
(
this
.
_globalsMode
&
&
this
.
__deprecatedInstance__
)
{
this
.
__deprecatedInstance__
.
destroy
(
)
;
}
}
visit
:
function
(
url
options
)
{
var
_this
=
this
;
return
this
.
boot
(
)
.
then
(
function
(
)
{
var
instance
=
_this
.
buildInstance
(
)
;
return
instance
.
boot
(
options
)
.
then
(
function
(
)
{
return
instance
.
visit
(
url
)
;
}
)
.
catch
(
function
(
error
)
{
(
0
_emberMetal
.
run
)
(
instance
'
destroy
'
)
;
throw
error
;
}
)
;
}
)
;
}
}
)
;
Application
.
reopenClass
(
{
buildRegistry
:
function
(
application
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
registry
=
this
.
_super
.
apply
(
this
arguments
)
;
commonSetupRegistry
(
registry
)
;
(
0
_emberGlimmer
.
setupApplicationRegistry
)
(
registry
)
;
return
registry
;
}
}
)
;
function
commonSetupRegistry
(
registry
)
{
registry
.
register
(
'
router
:
main
'
_emberRouting
.
Router
.
extend
(
)
)
;
registry
.
register
(
'
-
view
-
registry
:
main
'
{
create
:
function
(
)
{
return
(
0
_emberUtils
.
dictionary
)
(
null
)
;
}
}
)
;
registry
.
register
(
'
route
:
basic
'
_emberRouting
.
Route
)
;
registry
.
register
(
'
event_dispatcher
:
main
'
_emberViews
.
EventDispatcher
)
;
registry
.
injection
(
'
router
:
main
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
register
(
'
location
:
auto
'
_emberRouting
.
AutoLocation
)
;
registry
.
register
(
'
location
:
hash
'
_emberRouting
.
HashLocation
)
;
registry
.
register
(
'
location
:
history
'
_emberRouting
.
HistoryLocation
)
;
registry
.
register
(
'
location
:
none
'
_emberRouting
.
NoneLocation
)
;
registry
.
register
(
(
0
_container
.
privatize
)
(
_templateObject
)
_emberRouting
.
BucketCache
)
;
if
(
_features
.
EMBER_ROUTING_ROUTER_SERVICE
)
{
registry
.
register
(
'
service
:
router
'
_emberRouting
.
RouterService
)
;
registry
.
injection
(
'
service
:
router
'
'
_router
'
'
router
:
main
'
)
;
}
}
function
registerLibraries
(
)
{
if
(
!
librariesRegistered
)
{
librariesRegistered
=
true
;
if
(
_emberEnvironment
.
environment
.
hasDOM
&
&
typeof
_emberViews
.
jQuery
=
=
=
'
function
'
)
{
_emberMetal
.
libraries
.
registerCoreLibrary
(
'
jQuery
'
(
0
_emberViews
.
jQuery
)
(
)
.
jquery
)
;
}
}
}
function
logLibraryVersions
(
)
{
if
(
true
)
{
if
(
_emberEnvironment
.
ENV
.
LOG_VERSION
)
{
_emberEnvironment
.
ENV
.
LOG_VERSION
=
false
;
var
libs
=
_emberMetal
.
libraries
.
_registry
;
var
nameLengths
=
libs
.
map
(
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
'
name
.
length
'
)
;
}
)
;
var
maxNameLength
=
Math
.
max
.
apply
(
this
nameLengths
)
;
(
0
_emberDebug
.
debug
)
(
'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
'
)
;
for
(
var
i
=
0
;
i
<
libs
.
length
;
i
+
+
)
{
var
lib
=
libs
[
i
]
;
var
spaces
=
new
Array
(
maxNameLength
-
lib
.
name
.
length
+
1
)
.
join
(
'
'
)
;
(
0
_emberDebug
.
debug
)
(
[
lib
.
name
spaces
'
:
'
lib
.
version
]
.
join
(
'
'
)
)
;
}
(
0
_emberDebug
.
debug
)
(
'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
'
)
;
}
}
}
exports
.
default
=
Application
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
engine
-
instance
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
runtime
'
'
ember
-
debug
'
'
container
'
'
ember
-
application
/
system
/
engine
-
parent
'
]
function
(
exports
_emberBabel
_emberUtils
_emberRuntime
_emberDebug
_container
_engineParent
)
{
'
use
strict
'
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
-
bucket
-
cache
:
main
'
]
[
'
-
bucket
-
cache
:
main
'
]
)
;
var
EngineInstance
=
_emberRuntime
.
Object
.
extend
(
_emberRuntime
.
RegistryProxyMixin
_emberRuntime
.
ContainerProxyMixin
{
base
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
0
_emberUtils
.
guidFor
)
(
this
)
;
var
base
=
this
.
base
;
if
(
!
base
)
{
base
=
this
.
application
;
this
.
base
=
base
;
}
var
registry
=
this
.
__registry__
=
new
_container
.
Registry
(
{
fallback
:
base
.
__registry__
}
)
;
this
.
__container__
=
registry
.
container
(
{
owner
:
this
}
)
;
this
.
_booted
=
false
;
}
boot
:
function
(
options
)
{
var
_this
=
this
;
if
(
this
.
_bootPromise
)
{
return
this
.
_bootPromise
;
}
this
.
_bootPromise
=
new
_emberRuntime
.
RSVP
.
Promise
(
function
(
resolve
)
{
return
resolve
(
_this
.
_bootSync
(
options
)
)
;
}
)
;
return
this
.
_bootPromise
;
}
_bootSync
:
function
(
options
)
{
if
(
this
.
_booted
)
{
return
this
;
}
(
true
&
&
!
(
(
0
_engineParent
.
getEngineParent
)
(
this
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
An
engine
instance
\
'
s
parent
must
be
set
via
setEngineParent
(
engine
parent
)
prior
to
calling
engine
.
boot
(
)
.
'
(
0
_engineParent
.
getEngineParent
)
(
this
)
)
)
;
this
.
cloneParentDependencies
(
)
;
this
.
setupRegistry
(
options
)
;
this
.
base
.
runInstanceInitializers
(
this
)
;
this
.
_booted
=
true
;
return
this
;
}
setupRegistry
:
function
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
this
.
__container__
.
lookup
(
'
-
environment
:
main
'
)
;
this
.
constructor
.
setupRegistry
(
this
.
__registry__
options
)
;
}
unregister
:
function
(
fullName
)
{
this
.
__container__
.
reset
(
fullName
)
;
this
.
_super
.
apply
(
this
arguments
)
;
}
buildChildEngineInstance
:
function
(
name
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
Engine
=
this
.
lookup
(
'
engine
:
'
+
name
)
;
if
(
!
Engine
)
{
throw
new
_emberDebug
.
Error
(
'
You
attempted
to
mount
the
engine
\
'
'
+
name
+
'
\
'
but
it
is
not
registered
with
its
parent
.
'
)
;
}
var
engineInstance
=
Engine
.
buildInstance
(
options
)
;
(
0
_engineParent
.
setEngineParent
)
(
engineInstance
this
)
;
return
engineInstance
;
}
cloneParentDependencies
:
function
(
)
{
var
_this2
=
this
;
var
parent
=
(
0
_engineParent
.
getEngineParent
)
(
this
)
;
var
registrations
=
[
'
route
:
basic
'
'
service
:
-
routing
'
'
service
:
-
glimmer
-
environment
'
]
;
registrations
.
forEach
(
function
(
key
)
{
return
_this2
.
register
(
key
parent
.
resolveRegistration
(
key
)
)
;
}
)
;
var
env
=
parent
.
lookup
(
'
-
environment
:
main
'
)
;
this
.
register
(
'
-
environment
:
main
'
env
{
instantiate
:
false
}
)
;
var
singletons
=
[
'
router
:
main
'
(
0
_container
.
privatize
)
(
_templateObject
)
'
-
view
-
registry
:
main
'
'
renderer
:
-
'
+
(
env
.
isInteractive
?
'
dom
'
:
'
inert
'
)
'
service
:
-
document
'
]
;
if
(
env
.
isInteractive
)
{
singletons
.
push
(
'
event_dispatcher
:
main
'
)
;
}
singletons
.
forEach
(
function
(
key
)
{
return
_this2
.
register
(
key
parent
.
lookup
(
key
)
{
instantiate
:
false
}
)
;
}
)
;
this
.
inject
(
'
view
'
'
_environment
'
'
-
environment
:
main
'
)
;
this
.
inject
(
'
route
'
'
_environment
'
'
-
environment
:
main
'
)
;
}
}
)
;
EngineInstance
.
reopenClass
(
{
setupRegistry
:
function
(
registry
options
)
{
if
(
!
options
)
{
return
;
}
registry
.
injection
(
'
view
'
'
_environment
'
'
-
environment
:
main
'
)
;
registry
.
injection
(
'
route
'
'
_environment
'
'
-
environment
:
main
'
)
;
if
(
options
.
isInteractive
)
{
registry
.
injection
(
'
view
'
'
renderer
'
'
renderer
:
-
dom
'
)
;
registry
.
injection
(
'
component
'
'
renderer
'
'
renderer
:
-
dom
'
)
;
}
else
{
registry
.
injection
(
'
view
'
'
renderer
'
'
renderer
:
-
inert
'
)
;
registry
.
injection
(
'
component
'
'
renderer
'
'
renderer
:
-
inert
'
)
;
}
}
}
)
;
exports
.
default
=
EngineInstance
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
engine
-
parent
'
[
'
exports
'
'
ember
-
utils
'
]
function
(
exports
_emberUtils
)
{
'
use
strict
'
;
exports
.
ENGINE_PARENT
=
undefined
;
exports
.
getEngineParent
=
getEngineParent
;
exports
.
setEngineParent
=
setEngineParent
;
var
ENGINE_PARENT
=
exports
.
ENGINE_PARENT
=
(
0
_emberUtils
.
symbol
)
(
'
ENGINE_PARENT
'
)
;
function
getEngineParent
(
engine
)
{
return
engine
[
ENGINE_PARENT
]
;
}
function
setEngineParent
(
engine
parent
)
{
engine
[
ENGINE_PARENT
]
=
parent
;
}
}
)
;
enifed
(
'
ember
-
application
/
system
/
engine
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
runtime
'
'
container
'
'
dag
-
map
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
application
/
system
/
resolver
'
'
ember
-
application
/
system
/
engine
-
instance
'
'
ember
-
routing
'
'
ember
-
extension
-
support
'
'
ember
-
views
'
'
ember
-
glimmer
'
]
function
(
exports
_emberBabel
_emberUtils
_emberRuntime
_container
_dagMap
_emberDebug
_emberMetal
_resolver
_engineInstance
_emberRouting
_emberExtensionSupport
_emberViews
_emberGlimmer
)
{
'
use
strict
'
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
-
bucket
-
cache
:
main
'
]
[
'
-
bucket
-
cache
:
main
'
]
)
;
function
props
(
obj
)
{
var
properties
=
[
]
;
for
(
var
key
in
obj
)
{
properties
.
push
(
key
)
;
}
return
properties
;
}
var
Engine
=
_emberRuntime
.
Namespace
.
extend
(
_emberRuntime
.
RegistryProxyMixin
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
buildRegistry
(
)
;
}
_initializersRan
:
false
ensureInitializers
:
function
(
)
{
if
(
!
this
.
_initializersRan
)
{
this
.
runInitializers
(
)
;
this
.
_initializersRan
=
true
;
}
}
buildInstance
:
function
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
this
.
ensureInitializers
(
)
;
options
.
base
=
this
;
return
_engineInstance
.
default
.
create
(
options
)
;
}
buildRegistry
:
function
(
)
{
var
registry
=
this
.
__registry__
=
this
.
constructor
.
buildRegistry
(
this
)
;
return
registry
;
}
initializer
:
function
(
options
)
{
this
.
constructor
.
initializer
(
options
)
;
}
instanceInitializer
:
function
(
options
)
{
this
.
constructor
.
instanceInitializer
(
options
)
;
}
runInitializers
:
function
(
)
{
var
_this
=
this
;
this
.
_runInitializer
(
'
initializers
'
function
(
name
initializer
)
{
(
true
&
&
!
(
!
!
initializer
)
&
&
(
0
_emberDebug
.
assert
)
(
'
No
application
initializer
named
\
'
'
+
name
+
'
\
'
'
!
!
initializer
)
)
;
initializer
.
initialize
(
_this
)
;
}
)
;
}
runInstanceInitializers
:
function
(
instance
)
{
this
.
_runInitializer
(
'
instanceInitializers
'
function
(
name
initializer
)
{
(
true
&
&
!
(
!
!
initializer
)
&
&
(
0
_emberDebug
.
assert
)
(
'
No
instance
initializer
named
\
'
'
+
name
+
'
\
'
'
!
!
initializer
)
)
;
initializer
.
initialize
(
instance
)
;
}
)
;
}
_runInitializer
:
function
(
bucketName
cb
)
{
var
initializersByName
=
(
0
_emberMetal
.
get
)
(
this
.
constructor
bucketName
)
;
var
initializers
=
props
(
initializersByName
)
;
var
graph
=
new
_dagMap
.
default
(
)
;
var
initializer
=
void
0
;
for
(
var
i
=
0
;
i
<
initializers
.
length
;
i
+
+
)
{
initializer
=
initializersByName
[
initializers
[
i
]
]
;
graph
.
add
(
initializer
.
name
initializer
initializer
.
before
initializer
.
after
)
;
}
graph
.
topsort
(
cb
)
;
}
}
)
;
Engine
.
reopenClass
(
{
initializers
:
Object
.
create
(
null
)
instanceInitializers
:
Object
.
create
(
null
)
initializer
:
buildInitializerMethod
(
'
initializers
'
'
initializer
'
)
instanceInitializer
:
buildInitializerMethod
(
'
instanceInitializers
'
'
instance
initializer
'
)
buildRegistry
:
function
(
namespace
)
{
var
registry
=
new
_container
.
Registry
(
{
resolver
:
resolverFor
(
namespace
)
}
)
;
registry
.
set
=
_emberMetal
.
set
;
registry
.
register
(
'
application
:
main
'
namespace
{
instantiate
:
false
}
)
;
commonSetupRegistry
(
registry
)
;
(
0
_emberGlimmer
.
setupEngineRegistry
)
(
registry
)
;
return
registry
;
}
resolver
:
null
Resolver
:
null
}
)
;
function
resolverFor
(
namespace
)
{
var
ResolverClass
=
namespace
.
get
(
'
Resolver
'
)
|
|
_resolver
.
default
;
return
ResolverClass
.
create
(
{
namespace
:
namespace
}
)
;
}
function
buildInitializerMethod
(
bucketName
humanName
)
{
return
function
(
initializer
)
{
if
(
this
.
superclass
[
bucketName
]
!
=
=
undefined
&
&
this
.
superclass
[
bucketName
]
=
=
=
this
[
bucketName
]
)
{
var
attrs
=
{
}
;
attrs
[
bucketName
]
=
Object
.
create
(
this
[
bucketName
]
)
;
this
.
reopenClass
(
attrs
)
;
}
(
true
&
&
!
(
!
this
[
bucketName
]
[
initializer
.
name
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
'
+
humanName
+
'
\
'
'
+
initializer
.
name
+
'
\
'
has
already
been
registered
'
!
this
[
bucketName
]
[
initializer
.
name
]
)
)
;
(
true
&
&
!
(
(
0
_emberUtils
.
canInvoke
)
(
initializer
'
initialize
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
An
'
+
humanName
+
'
cannot
be
registered
without
an
initialize
function
'
(
0
_emberUtils
.
canInvoke
)
(
initializer
'
initialize
'
)
)
)
;
(
true
&
&
!
(
initializer
.
name
!
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
An
'
+
humanName
+
'
cannot
be
registered
without
a
name
property
'
initializer
.
name
!
=
=
undefined
)
)
;
this
[
bucketName
]
[
initializer
.
name
]
=
initializer
;
}
;
}
function
commonSetupRegistry
(
registry
)
{
registry
.
optionsForType
(
'
component
'
{
singleton
:
false
}
)
;
registry
.
optionsForType
(
'
view
'
{
singleton
:
false
}
)
;
registry
.
register
(
'
controller
:
basic
'
_emberRuntime
.
Controller
{
instantiate
:
false
}
)
;
registry
.
injection
(
'
view
'
'
_viewRegistry
'
'
-
view
-
registry
:
main
'
)
;
registry
.
injection
(
'
renderer
'
'
_viewRegistry
'
'
-
view
-
registry
:
main
'
)
;
registry
.
injection
(
'
event_dispatcher
:
main
'
'
_viewRegistry
'
'
-
view
-
registry
:
main
'
)
;
registry
.
injection
(
'
route
'
'
_topLevelViewTemplate
'
'
template
:
-
outlet
'
)
;
registry
.
injection
(
'
view
:
-
outlet
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
injection
(
'
controller
'
'
target
'
'
router
:
main
'
)
;
registry
.
injection
(
'
controller
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
injection
(
'
router
'
'
_bucketCache
'
(
0
_container
.
privatize
)
(
_templateObject
)
)
;
registry
.
injection
(
'
route
'
'
_bucketCache
'
(
0
_container
.
privatize
)
(
_templateObject
)
)
;
registry
.
injection
(
'
route
'
'
router
'
'
router
:
main
'
)
;
registry
.
register
(
'
service
:
-
routing
'
_emberRouting
.
RoutingService
)
;
registry
.
injection
(
'
service
:
-
routing
'
'
router
'
'
router
:
main
'
)
;
registry
.
register
(
'
resolver
-
for
-
debugging
:
main
'
registry
.
resolver
{
instantiate
:
false
}
)
;
registry
.
injection
(
'
container
-
debug
-
adapter
:
main
'
'
resolver
'
'
resolver
-
for
-
debugging
:
main
'
)
;
registry
.
injection
(
'
data
-
adapter
:
main
'
'
containerDebugAdapter
'
'
container
-
debug
-
adapter
:
main
'
)
;
registry
.
register
(
'
container
-
debug
-
adapter
:
main
'
_emberExtensionSupport
.
ContainerDebugAdapter
)
;
registry
.
register
(
'
component
-
lookup
:
main
'
_emberViews
.
ComponentLookup
)
;
}
exports
.
default
=
Engine
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
resolver
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
'
'
ember
-
application
/
utils
/
validate
-
type
'
'
ember
-
glimmer
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_emberRuntime
_validateType
_emberGlimmer
)
{
'
use
strict
'
;
exports
.
Resolver
=
undefined
;
var
Resolver
=
exports
.
Resolver
=
_emberRuntime
.
Object
.
extend
(
{
namespace
:
null
normalize
:
null
resolve
:
null
parseName
:
null
lookupDescription
:
null
makeToString
:
null
resolveOther
:
null
_logLookup
:
null
}
)
;
var
DefaultResolver
=
_emberRuntime
.
Object
.
extend
(
{
namespace
:
null
init
:
function
(
)
{
this
.
_parseNameCache
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
}
normalize
:
function
(
fullName
)
{
var
_fullName
split
=
fullName
.
split
(
'
:
'
)
type
=
_fullName
split
[
0
]
name
=
_fullName
split
[
1
]
;
(
true
&
&
!
(
fullName
.
split
(
'
:
'
)
.
length
=
=
=
2
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Tried
to
normalize
a
container
name
without
a
colon
(
:
)
in
it
.
'
+
'
You
probably
tried
to
lookup
a
name
that
did
not
contain
a
type
'
+
'
a
colon
and
a
name
.
A
proper
lookup
name
would
be
view
:
post
.
'
fullName
.
split
(
'
:
'
)
.
length
=
=
=
2
)
)
;
if
(
type
!
=
=
'
template
'
)
{
var
result
=
name
.
replace
(
/
(
\
.
|
_
|
-
)
.
/
g
function
(
m
)
{
return
m
.
charAt
(
1
)
.
toUpperCase
(
)
;
}
)
;
return
type
+
'
:
'
+
result
;
}
else
{
return
fullName
;
}
}
resolve
:
function
(
fullName
)
{
var
parsedName
=
this
.
parseName
(
fullName
)
;
var
resolveMethodName
=
parsedName
.
resolveMethodName
;
var
resolved
=
void
0
;
if
(
this
[
resolveMethodName
]
)
{
resolved
=
this
[
resolveMethodName
]
(
parsedName
)
;
}
resolved
=
resolved
|
|
this
.
resolveOther
(
parsedName
)
;
if
(
true
)
{
if
(
parsedName
.
root
&
&
parsedName
.
root
.
LOG_RESOLVER
)
{
this
.
_logLookup
(
resolved
parsedName
)
;
}
}
if
(
resolved
)
{
(
0
_validateType
.
default
)
(
resolved
parsedName
)
;
}
return
resolved
;
}
parseName
:
function
(
fullName
)
{
return
this
.
_parseNameCache
[
fullName
]
|
|
(
this
.
_parseNameCache
[
fullName
]
=
this
.
_parseName
(
fullName
)
)
;
}
_parseName
:
function
(
fullName
)
{
var
_fullName
split2
=
fullName
.
split
(
'
:
'
)
type
=
_fullName
split2
[
0
]
fullNameWithoutType
=
_fullName
split2
[
1
]
;
var
name
=
fullNameWithoutType
;
var
namespace
=
(
0
_emberMetal
.
get
)
(
this
'
namespace
'
)
;
var
root
=
namespace
;
var
lastSlashIndex
=
name
.
lastIndexOf
(
'
/
'
)
;
var
dirname
=
lastSlashIndex
!
=
=
-
1
?
name
.
slice
(
0
lastSlashIndex
)
:
null
;
if
(
type
!
=
=
'
template
'
&
&
lastSlashIndex
!
=
=
-
1
)
{
var
parts
=
name
.
split
(
'
/
'
)
;
name
=
parts
[
parts
.
length
-
1
]
;
var
namespaceName
=
_emberRuntime
.
String
.
capitalize
(
parts
.
slice
(
0
-
1
)
.
join
(
'
.
'
)
)
;
root
=
_emberRuntime
.
Namespace
.
byName
(
namespaceName
)
;
(
true
&
&
!
(
root
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
are
looking
for
a
'
+
name
+
'
'
+
type
+
'
in
the
'
+
namespaceName
+
'
namespace
but
the
namespace
could
not
be
found
'
root
)
)
;
}
var
resolveMethodName
=
fullNameWithoutType
=
=
=
'
main
'
?
'
Main
'
:
_emberRuntime
.
String
.
classify
(
type
)
;
if
(
!
(
name
&
&
type
)
)
{
throw
new
TypeError
(
'
Invalid
fullName
:
'
+
fullName
+
'
must
be
of
the
form
type
:
name
'
)
;
}
return
{
fullName
:
fullName
type
:
type
fullNameWithoutType
:
fullNameWithoutType
dirname
:
dirname
name
:
name
root
:
root
resolveMethodName
:
'
resolve
'
+
resolveMethodName
}
;
}
lookupDescription
:
function
(
fullName
)
{
var
parsedName
=
this
.
parseName
(
fullName
)
;
var
description
=
void
0
;
if
(
parsedName
.
type
=
=
=
'
template
'
)
{
return
'
template
at
'
+
parsedName
.
fullNameWithoutType
.
replace
(
/
\
.
/
g
'
/
'
)
;
}
description
=
parsedName
.
root
+
'
.
'
+
_emberRuntime
.
String
.
classify
(
parsedName
.
name
)
.
replace
(
/
\
.
/
g
'
'
)
;
if
(
parsedName
.
type
!
=
=
'
model
'
)
{
description
+
=
_emberRuntime
.
String
.
classify
(
parsedName
.
type
)
;
}
return
description
;
}
makeToString
:
function
(
factory
)
{
return
factory
.
toString
(
)
;
}
useRouterNaming
:
function
(
parsedName
)
{
if
(
parsedName
.
name
=
=
=
'
basic
'
)
{
parsedName
.
name
=
'
'
;
}
else
{
parsedName
.
name
=
parsedName
.
name
.
replace
(
/
\
.
/
g
'
_
'
)
;
}
}
resolveTemplate
:
function
(
parsedName
)
{
var
templateName
=
parsedName
.
fullNameWithoutType
.
replace
(
/
\
.
/
g
'
/
'
)
;
return
(
0
_emberGlimmer
.
getTemplate
)
(
templateName
)
|
|
(
0
_emberGlimmer
.
getTemplate
)
(
_emberRuntime
.
String
.
decamelize
(
templateName
)
)
;
}
resolveView
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveController
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveRoute
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveModel
:
function
(
parsedName
)
{
var
className
=
_emberRuntime
.
String
.
classify
(
parsedName
.
name
)
;
var
factory
=
(
0
_emberMetal
.
get
)
(
parsedName
.
root
className
)
;
return
factory
;
}
resolveHelper
:
function
(
parsedName
)
{
return
this
.
resolveOther
(
parsedName
)
;
}
resolveOther
:
function
(
parsedName
)
{
var
className
=
_emberRuntime
.
String
.
classify
(
parsedName
.
name
)
+
_emberRuntime
.
String
.
classify
(
parsedName
.
type
)
;
var
factory
=
(
0
_emberMetal
.
get
)
(
parsedName
.
root
className
)
;
return
factory
;
}
resolveMain
:
function
(
parsedName
)
{
var
className
=
_emberRuntime
.
String
.
classify
(
parsedName
.
type
)
;
return
(
0
_emberMetal
.
get
)
(
parsedName
.
root
className
)
;
}
knownForType
:
function
(
type
)
{
var
namespace
=
(
0
_emberMetal
.
get
)
(
this
'
namespace
'
)
;
var
suffix
=
_emberRuntime
.
String
.
classify
(
type
)
;
var
typeRegexp
=
new
RegExp
(
suffix
+
'
'
)
;
var
known
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
var
knownKeys
=
Object
.
keys
(
namespace
)
;
for
(
var
index
=
0
;
index
<
knownKeys
.
length
;
index
+
+
)
{
var
name
=
knownKeys
[
index
]
;
if
(
typeRegexp
.
test
(
name
)
)
{
var
containerName
=
this
.
translateToContainerFullname
(
type
name
)
;
known
[
containerName
]
=
true
;
}
}
return
known
;
}
translateToContainerFullname
:
function
(
type
name
)
{
var
suffix
=
_emberRuntime
.
String
.
classify
(
type
)
;
var
namePrefix
=
name
.
slice
(
0
suffix
.
length
*
-
1
)
;
var
dasherizedName
=
_emberRuntime
.
String
.
dasherize
(
namePrefix
)
;
return
type
+
'
:
'
+
dasherizedName
;
}
}
)
;
exports
.
default
=
DefaultResolver
;
if
(
true
)
{
DefaultResolver
.
reopen
(
{
_logLookup
:
function
(
found
parsedName
)
{
var
symbol
=
found
?
'
[
]
'
:
'
[
]
'
;
var
padding
=
void
0
;
if
(
parsedName
.
fullName
.
length
>
60
)
{
padding
=
'
.
'
;
}
else
{
padding
=
new
Array
(
60
-
parsedName
.
fullName
.
length
)
.
join
(
'
.
'
)
;
}
(
0
_emberDebug
.
info
)
(
symbol
parsedName
.
fullName
padding
this
.
lookupDescription
(
parsedName
.
fullName
)
)
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
application
/
utils
/
validate
-
type
'
[
'
exports
'
'
ember
-
debug
'
]
function
(
exports
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
validateType
;
var
VALIDATED_TYPES
=
{
route
:
[
'
assert
'
'
isRouteFactory
'
'
Ember
.
Route
'
]
component
:
[
'
deprecate
'
'
isComponentFactory
'
'
Ember
.
Component
'
]
view
:
[
'
deprecate
'
'
isViewFactory
'
'
Ember
.
View
'
]
service
:
[
'
deprecate
'
'
isServiceFactory
'
'
Ember
.
Service
'
]
}
;
function
validateType
(
resolvedType
parsedName
)
{
var
validationAttributes
=
VALIDATED_TYPES
[
parsedName
.
type
]
;
if
(
!
validationAttributes
)
{
return
;
}
var
factoryFlag
=
validationAttributes
[
1
]
expectedType
=
validationAttributes
[
2
]
;
(
true
&
&
!
(
!
!
resolvedType
[
factoryFlag
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Expected
'
+
parsedName
.
fullName
+
'
to
resolve
to
an
'
+
expectedType
+
'
but
'
+
(
'
instead
it
was
'
+
resolvedType
+
'
.
'
)
!
!
resolvedType
[
factoryFlag
]
)
)
;
}
}
)
;
enifed
(
'
ember
-
babel
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
classCallCheck
=
classCallCheck
;
exports
.
inherits
=
inherits
;
exports
.
taggedTemplateLiteralLoose
=
taggedTemplateLiteralLoose
;
exports
.
createClass
=
createClass
;
exports
.
defaults
=
defaults
;
function
classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
defaults
(
subClass
superClass
)
;
}
function
taggedTemplateLiteralLoose
(
strings
raw
)
{
strings
.
raw
=
raw
;
return
strings
;
}
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
function
createClass
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
function
defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
var
possibleConstructorReturn
=
exports
.
possibleConstructorReturn
=
function
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
'
this
hasn
\
'
t
been
initialized
-
super
(
)
hasn
\
'
t
been
called
'
)
;
}
return
call
&
&
(
typeof
call
=
=
=
'
object
'
|
|
typeof
call
=
=
=
'
function
'
)
?
call
:
self
;
}
;
var
slice
=
exports
.
slice
=
Array
.
prototype
.
slice
;
}
)
;
enifed
(
"
ember
-
console
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
index
=
{
log
:
function
(
)
{
var
_console
;
return
(
_console
=
console
)
.
log
.
apply
(
_console
arguments
)
;
}
warn
:
function
(
)
{
var
_console2
;
return
(
_console2
=
console
)
.
warn
.
apply
(
_console2
arguments
)
;
}
error
:
function
(
)
{
var
_console3
;
return
(
_console3
=
console
)
.
error
.
apply
(
_console3
arguments
)
;
}
info
:
function
(
)
{
var
_console4
;
return
(
_console4
=
console
)
.
info
.
apply
(
_console4
arguments
)
;
}
debug
:
function
(
)
{
var
_console6
;
if
(
console
.
debug
)
{
var
_console5
;
return
(
_console5
=
console
)
.
debug
.
apply
(
_console5
arguments
)
;
}
return
(
_console6
=
console
)
.
info
.
apply
(
_console6
arguments
)
;
}
assert
:
function
(
)
{
var
_console7
;
return
(
_console7
=
console
)
.
assert
.
apply
(
_console7
arguments
)
;
}
}
;
exports
.
default
=
index
;
}
)
;
enifed
(
'
ember
-
debug
/
deprecate
'
[
'
exports
'
'
ember
-
debug
/
error
'
'
ember
-
console
'
'
ember
-
environment
'
'
ember
-
debug
/
index
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_error
_emberConsole
_emberEnvironment
_index
_handlers
)
{
'
use
strict
'
;
exports
.
missingOptionsUntilDeprecation
=
exports
.
missingOptionsIdDeprecation
=
exports
.
missingOptionsDeprecation
=
exports
.
registerHandler
=
undefined
;
var
registerHandler
=
function
(
)
{
}
;
var
missingOptionsDeprecation
=
void
0
missingOptionsIdDeprecation
=
void
0
missingOptionsUntilDeprecation
=
void
0
deprecate
=
void
0
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
handler
)
{
(
0
_handlers
.
registerHandler
)
(
'
deprecate
'
handler
)
;
}
;
var
formatMessage
=
function
formatMessage
(
_message
options
)
{
var
message
=
_message
;
if
(
options
&
&
options
.
id
)
{
message
=
message
+
(
'
[
deprecation
id
:
'
+
options
.
id
+
'
]
'
)
;
}
if
(
options
&
&
options
.
url
)
{
message
+
=
'
See
'
+
options
.
url
+
'
for
more
details
.
'
;
}
return
message
;
}
;
registerHandler
(
function
logDeprecationToConsole
(
message
options
)
{
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberConsole
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
)
;
}
)
;
var
captureErrorForStack
=
void
0
;
if
(
new
Error
(
)
.
stack
)
{
captureErrorForStack
=
function
(
)
{
return
new
Error
(
)
;
}
;
}
else
{
captureErrorForStack
=
function
(
)
{
try
{
__fail__
.
fail
(
)
;
}
catch
(
e
)
{
return
e
;
}
}
;
}
registerHandler
(
function
logDeprecationStackTrace
(
message
options
next
)
{
if
(
_emberEnvironment
.
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
)
{
var
stackStr
=
'
'
;
var
error
=
captureErrorForStack
(
)
;
var
stack
=
void
0
;
if
(
error
.
stack
)
{
if
(
error
[
'
arguments
'
]
)
{
stack
=
error
.
stack
.
replace
(
/
^
\
s
+
at
\
s
+
/
gm
'
'
)
.
replace
(
/
^
(
[
^
\
(
]
+
?
)
(
[
\
n
]
)
/
gm
'
{
anonymous
}
(
1
)
2
'
)
.
replace
(
/
^
Object
.
<
anonymous
>
\
s
*
\
(
(
[
^
\
)
]
+
)
\
)
/
gm
'
{
anonymous
}
(
1
)
'
)
.
split
(
'
\
n
'
)
;
stack
.
shift
(
)
;
}
else
{
stack
=
error
.
stack
.
replace
(
/
(
?
:
\
n
:
0
)
?
\
s
+
/
m
'
'
)
.
replace
(
/
^
\
(
/
gm
'
{
anonymous
}
(
'
)
.
split
(
'
\
n
'
)
;
}
stackStr
=
'
\
n
'
+
stack
.
slice
(
2
)
.
join
(
'
\
n
'
)
;
}
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberConsole
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
+
stackStr
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
registerHandler
(
function
raiseOnDeprecation
(
message
options
next
)
{
if
(
_emberEnvironment
.
ENV
.
RAISE_ON_DEPRECATION
)
{
var
updatedMessage
=
formatMessage
(
message
)
;
throw
new
_error
.
default
(
updatedMessage
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
=
'
When
calling
deprecate
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
id
and
until
properties
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
=
'
When
calling
deprecate
you
must
provide
id
in
options
.
'
;
exports
.
missingOptionsUntilDeprecation
=
missingOptionsUntilDeprecation
=
'
When
calling
deprecate
you
must
provide
until
in
options
.
'
;
deprecate
=
function
deprecate
(
message
test
options
)
{
if
(
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
!
=
=
true
)
{
(
0
_index
.
assert
)
(
missingOptionsDeprecation
options
&
&
(
options
.
id
|
|
options
.
until
)
)
;
(
0
_index
.
assert
)
(
missingOptionsIdDeprecation
options
.
id
)
;
(
0
_index
.
assert
)
(
missingOptionsUntilDeprecation
options
.
until
)
;
}
if
(
(
!
options
|
|
!
options
.
id
&
&
!
options
.
until
)
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
until
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsUntilDeprecation
options
&
&
options
.
until
{
id
:
'
ember
-
debug
.
deprecate
-
until
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
_handlers
.
invoke
.
apply
(
undefined
[
'
deprecate
'
]
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
}
;
}
exports
.
default
=
deprecate
;
exports
.
registerHandler
=
registerHandler
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
exports
.
missingOptionsUntilDeprecation
=
missingOptionsUntilDeprecation
;
}
)
;
enifed
(
"
ember
-
debug
/
error
"
[
"
exports
"
"
ember
-
babel
"
]
function
(
exports
_emberBabel
)
{
"
use
strict
"
;
function
ExtendBuiltin
(
klass
)
{
function
ExtendableBuiltin
(
)
{
klass
.
apply
(
this
arguments
)
;
}
ExtendableBuiltin
.
prototype
=
Object
.
create
(
klass
.
prototype
)
;
ExtendableBuiltin
.
prototype
.
constructor
=
ExtendableBuiltin
;
return
ExtendableBuiltin
;
}
var
EmberError
=
function
(
_ExtendBuiltin
)
{
(
0
_emberBabel
.
inherits
)
(
EmberError
_ExtendBuiltin
)
;
function
EmberError
(
message
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EmberError
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ExtendBuiltin
.
call
(
this
)
)
;
if
(
!
(
_this
instanceof
EmberError
)
)
{
var
_ret
;
return
_ret
=
new
EmberError
(
message
)
(
0
_emberBabel
.
possibleConstructorReturn
)
(
_this
_ret
)
;
}
var
error
=
Error
.
call
(
_this
message
)
;
_this
.
stack
=
error
.
stack
;
_this
.
description
=
error
.
description
;
_this
.
fileName
=
error
.
fileName
;
_this
.
lineNumber
=
error
.
lineNumber
;
_this
.
message
=
error
.
message
;
_this
.
name
=
error
.
name
;
_this
.
number
=
error
.
number
;
_this
.
code
=
error
.
code
;
return
_this
;
}
return
EmberError
;
}
(
ExtendBuiltin
(
Error
)
)
;
exports
.
default
=
EmberError
;
}
)
;
enifed
(
'
ember
-
debug
/
features
'
[
'
exports
'
'
ember
-
environment
'
'
ember
/
features
'
]
function
(
exports
_emberEnvironment
_features
)
{
'
use
strict
'
;
exports
.
default
=
isEnabled
;
var
FEATURES
=
_features
.
FEATURES
;
function
isEnabled
(
feature
)
{
var
featureValue
=
FEATURES
[
feature
]
;
if
(
featureValue
=
=
=
true
|
|
featureValue
=
=
=
false
|
|
featureValue
=
=
=
undefined
)
{
return
featureValue
;
}
else
if
(
_emberEnvironment
.
ENV
.
ENABLE_OPTIONAL_FEATURES
)
{
return
true
;
}
else
{
return
false
;
}
}
}
)
;
enifed
(
'
ember
-
debug
/
handlers
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
HANDLERS
=
exports
.
HANDLERS
=
{
}
;
var
registerHandler
=
function
(
)
{
}
;
var
invoke
=
function
(
)
{
}
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
type
callback
)
{
var
nextHandler
=
HANDLERS
[
type
]
|
|
function
(
)
{
}
;
HANDLERS
[
type
]
=
function
(
message
options
)
{
callback
(
message
options
nextHandler
)
;
}
;
}
;
exports
.
invoke
=
invoke
=
function
invoke
(
type
message
test
options
)
{
if
(
test
)
{
return
;
}
var
handlerForType
=
HANDLERS
[
type
]
;
if
(
handlerForType
)
{
handlerForType
(
message
options
)
;
}
}
;
}
exports
.
registerHandler
=
registerHandler
;
exports
.
invoke
=
invoke
;
}
)
;
enifed
(
'
ember
-
debug
/
index
'
[
'
exports
'
'
ember
-
debug
/
warn
'
'
ember
-
debug
/
deprecate
'
'
ember
-
debug
/
features
'
'
ember
-
debug
/
error
'
'
ember
-
debug
/
testing
'
'
ember
-
environment
'
'
ember
-
console
'
'
ember
/
features
'
]
function
(
exports
_warn2
_deprecate2
_features
_error
_testing
_emberEnvironment
_emberConsole
_features2
)
{
'
use
strict
'
;
exports
.
_warnIfUsingStrippedFeatureFlags
=
exports
.
getDebugFunction
=
exports
.
setDebugFunction
=
exports
.
deprecateFunc
=
exports
.
runInDebug
=
exports
.
debugFreeze
=
exports
.
debugSeal
=
exports
.
deprecate
=
exports
.
debug
=
exports
.
warn
=
exports
.
info
=
exports
.
assert
=
exports
.
setTesting
=
exports
.
isTesting
=
exports
.
Error
=
exports
.
isFeatureEnabled
=
exports
.
registerDeprecationHandler
=
exports
.
registerWarnHandler
=
undefined
;
Object
.
defineProperty
(
exports
'
registerWarnHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_warn2
.
registerHandler
;
}
}
)
;
Object
.
defineProperty
(
exports
'
registerDeprecationHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_deprecate2
.
registerHandler
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isFeatureEnabled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_features
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Error
'
{
enumerable
:
true
get
:
function
(
)
{
return
_error
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testing
.
isTesting
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testing
.
setTesting
;
}
}
)
;
var
DEFAULT_FEATURES
=
_features2
.
DEFAULT_FEATURES
FEATURES
=
_features2
.
FEATURES
;
var
noop
=
function
(
)
{
}
;
var
assert
=
noop
;
var
info
=
noop
;
var
warn
=
noop
;
var
debug
=
noop
;
var
deprecate
=
noop
;
var
debugSeal
=
noop
;
var
debugFreeze
=
noop
;
var
runInDebug
=
noop
;
var
setDebugFunction
=
noop
;
var
getDebugFunction
=
noop
;
var
deprecateFunc
=
function
(
)
{
return
arguments
[
arguments
.
length
-
1
]
;
}
;
if
(
true
)
{
exports
.
setDebugFunction
=
setDebugFunction
=
function
(
type
callback
)
{
switch
(
type
)
{
case
'
assert
'
:
return
exports
.
assert
=
assert
=
callback
;
case
'
info
'
:
return
exports
.
info
=
info
=
callback
;
case
'
warn
'
:
return
exports
.
warn
=
warn
=
callback
;
case
'
debug
'
:
return
exports
.
debug
=
debug
=
callback
;
case
'
deprecate
'
:
return
exports
.
deprecate
=
deprecate
=
callback
;
case
'
debugSeal
'
:
return
exports
.
debugSeal
=
debugSeal
=
callback
;
case
'
debugFreeze
'
:
return
exports
.
debugFreeze
=
debugFreeze
=
callback
;
case
'
runInDebug
'
:
return
exports
.
runInDebug
=
runInDebug
=
callback
;
case
'
deprecateFunc
'
:
return
exports
.
deprecateFunc
=
deprecateFunc
=
callback
;
}
}
;
exports
.
getDebugFunction
=
getDebugFunction
=
function
(
type
)
{
switch
(
type
)
{
case
'
assert
'
:
return
assert
;
case
'
info
'
:
return
info
;
case
'
warn
'
:
return
warn
;
case
'
debug
'
:
return
debug
;
case
'
deprecate
'
:
return
deprecate
;
case
'
debugSeal
'
:
return
debugSeal
;
case
'
debugFreeze
'
:
return
debugFreeze
;
case
'
runInDebug
'
:
return
runInDebug
;
case
'
deprecateFunc
'
:
return
deprecateFunc
;
}
}
;
}
if
(
true
)
{
setDebugFunction
(
'
assert
'
function
assert
(
desc
test
)
{
if
(
!
test
)
{
throw
new
_error
.
default
(
'
Assertion
Failed
:
'
+
desc
)
;
}
}
)
;
setDebugFunction
(
'
debug
'
function
debug
(
message
)
{
_emberConsole
.
default
.
debug
(
'
DEBUG
:
'
+
message
)
;
}
)
;
setDebugFunction
(
'
info
'
function
info
(
)
{
_emberConsole
.
default
.
info
.
apply
(
undefined
arguments
)
;
}
)
;
setDebugFunction
(
'
deprecateFunc
'
function
deprecateFunc
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
args
.
length
=
=
=
3
)
{
var
message
=
args
[
0
]
options
=
args
[
1
]
func
=
args
[
2
]
;
return
function
(
)
{
deprecate
(
message
false
options
)
;
return
func
.
apply
(
this
arguments
)
;
}
;
}
else
{
var
_message
=
args
[
0
]
_func
=
args
[
1
]
;
return
function
(
)
{
deprecate
(
_message
)
;
return
_func
.
apply
(
this
arguments
)
;
}
;
}
}
)
;
setDebugFunction
(
'
runInDebug
'
function
runInDebug
(
func
)
{
func
(
)
;
}
)
;
setDebugFunction
(
'
debugSeal
'
function
debugSeal
(
obj
)
{
Object
.
seal
(
obj
)
;
}
)
;
setDebugFunction
(
'
debugFreeze
'
function
debugFreeze
(
obj
)
{
Object
.
freeze
(
obj
)
;
}
)
;
setDebugFunction
(
'
deprecate
'
_deprecate2
.
default
)
;
setDebugFunction
(
'
warn
'
_warn2
.
default
)
;
}
var
_warnIfUsingStrippedFeatureFlags
=
void
0
;
if
(
true
&
&
!
(
0
_testing
.
isTesting
)
(
)
)
{
exports
.
_warnIfUsingStrippedFeatureFlags
=
_warnIfUsingStrippedFeatureFlags
=
function
_warnIfUsingStrippedFeatureFlags
(
FEATURES
knownFeatures
featuresWereStripped
)
{
if
(
featuresWereStripped
)
{
warn
(
'
Ember
.
ENV
.
ENABLE_OPTIONAL_FEATURES
is
only
available
in
canary
builds
.
'
!
_emberEnvironment
.
ENV
.
ENABLE_OPTIONAL_FEATURES
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
var
keys
=
Object
.
keys
(
FEATURES
|
|
{
}
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
if
(
key
=
=
=
'
isEnabled
'
|
|
!
(
key
in
knownFeatures
)
)
{
continue
;
}
warn
(
'
FEATURE
[
"
'
+
key
+
'
"
]
is
set
as
enabled
but
FEATURE
flags
are
only
available
in
canary
builds
.
'
!
FEATURES
[
key
]
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
}
}
}
;
FEATURES
[
'
features
-
stripped
-
test
'
]
=
true
;
var
featuresWereStripped
=
true
;
if
(
(
0
_features
.
default
)
(
'
features
-
stripped
-
test
'
)
)
{
featuresWereStripped
=
false
;
}
delete
FEATURES
[
'
features
-
stripped
-
test
'
]
;
_warnIfUsingStrippedFeatureFlags
(
_emberEnvironment
.
ENV
.
FEATURES
DEFAULT_FEATURES
featuresWereStripped
)
;
var
isFirefox
=
_emberEnvironment
.
environment
.
isFirefox
;
var
isChrome
=
_emberEnvironment
.
environment
.
isChrome
;
if
(
typeof
window
!
=
=
'
undefined
'
&
&
(
isFirefox
|
|
isChrome
)
&
&
window
.
addEventListener
)
{
window
.
addEventListener
(
'
load
'
function
(
)
{
if
(
document
.
documentElement
&
&
document
.
documentElement
.
dataset
&
&
!
document
.
documentElement
.
dataset
.
emberExtension
)
{
var
downloadURL
=
void
0
;
if
(
isChrome
)
{
downloadURL
=
'
https
:
/
/
chrome
.
google
.
com
/
webstore
/
detail
/
ember
-
inspector
/
bmdblncegkenkacieihfhpjfppoconhi
'
;
}
else
if
(
isFirefox
)
{
downloadURL
=
'
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
firefox
/
addon
/
ember
-
inspector
/
'
;
}
debug
(
'
For
more
advanced
debugging
install
the
Ember
Inspector
from
'
+
downloadURL
)
;
}
}
false
)
;
}
}
exports
.
assert
=
assert
;
exports
.
info
=
info
;
exports
.
warn
=
warn
;
exports
.
debug
=
debug
;
exports
.
deprecate
=
deprecate
;
exports
.
debugSeal
=
debugSeal
;
exports
.
debugFreeze
=
debugFreeze
;
exports
.
runInDebug
=
runInDebug
;
exports
.
deprecateFunc
=
deprecateFunc
;
exports
.
setDebugFunction
=
setDebugFunction
;
exports
.
getDebugFunction
=
getDebugFunction
;
exports
.
_warnIfUsingStrippedFeatureFlags
=
_warnIfUsingStrippedFeatureFlags
;
}
)
;
enifed
(
"
ember
-
debug
/
testing
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
isTesting
=
isTesting
;
exports
.
setTesting
=
setTesting
;
var
testing
=
false
;
function
isTesting
(
)
{
return
testing
;
}
function
setTesting
(
value
)
{
testing
=
!
!
value
;
}
}
)
;
enifed
(
'
ember
-
debug
/
warn
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
console
'
'
ember
-
debug
/
deprecate
'
'
ember
-
debug
/
index
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_emberEnvironment
_emberConsole
_deprecate
_index
_handlers
)
{
'
use
strict
'
;
exports
.
missingOptionsDeprecation
=
exports
.
missingOptionsIdDeprecation
=
exports
.
registerHandler
=
undefined
;
var
registerHandler
=
function
(
)
{
}
;
var
warn
=
function
(
)
{
}
;
var
missingOptionsDeprecation
=
void
0
missingOptionsIdDeprecation
=
void
0
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
handler
)
{
(
0
_handlers
.
registerHandler
)
(
'
warn
'
handler
)
;
}
;
registerHandler
(
function
logWarning
(
message
)
{
_emberConsole
.
default
.
warn
(
'
WARNING
:
'
+
message
)
;
if
(
'
trace
'
in
_emberConsole
.
default
)
{
_emberConsole
.
default
.
trace
(
)
;
}
}
)
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
=
'
When
calling
warn
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
an
id
property
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
=
'
When
calling
warn
you
must
provide
id
in
options
.
'
;
warn
=
function
warn
(
message
test
options
)
{
if
(
arguments
.
length
=
=
=
2
&
&
typeof
test
=
=
=
'
object
'
)
{
options
=
test
;
test
=
false
;
}
if
(
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
!
=
=
true
)
{
(
0
_index
.
assert
)
(
missingOptionsDeprecation
options
)
;
(
0
_index
.
assert
)
(
missingOptionsIdDeprecation
options
&
&
options
.
id
)
;
}
if
(
!
options
&
&
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
=
=
=
true
)
{
(
0
_deprecate
.
default
)
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
&
&
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
=
=
=
true
)
{
(
0
_deprecate
.
default
)
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
(
0
_handlers
.
invoke
)
(
'
warn
'
message
test
options
)
;
}
;
}
exports
.
default
=
warn
;
exports
.
registerHandler
=
registerHandler
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
}
)
;
enifed
(
'
ember
-
environment
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
checkGlobal
(
value
)
{
return
value
&
&
value
.
Object
=
=
=
Object
?
value
:
undefined
;
}
function
checkElementIdShadowing
(
value
)
{
return
value
&
&
value
.
nodeType
=
=
=
undefined
?
value
:
undefined
;
}
var
global
1
=
checkGlobal
(
checkElementIdShadowing
(
typeof
global
=
=
=
'
object
'
&
&
global
)
)
|
|
checkGlobal
(
typeof
self
=
=
=
'
object
'
&
&
self
)
|
|
checkGlobal
(
typeof
window
=
=
=
'
object
'
&
&
window
)
|
|
mainContext
|
|
new
Function
(
'
return
this
'
)
(
)
;
function
defaultTrue
(
v
)
{
return
v
=
=
=
false
?
false
:
true
;
}
function
defaultFalse
(
v
)
{
return
v
=
=
=
true
?
true
:
false
;
}
function
normalizeExtendPrototypes
(
obj
)
{
if
(
obj
=
=
=
false
)
{
return
{
String
:
false
Array
:
false
Function
:
false
}
;
}
else
if
(
!
obj
|
|
obj
=
=
=
true
)
{
return
{
String
:
true
Array
:
true
Function
:
true
}
;
}
else
{
return
{
String
:
defaultTrue
(
obj
.
String
)
Array
:
defaultTrue
(
obj
.
Array
)
Function
:
defaultTrue
(
obj
.
Function
)
}
;
}
}
var
ENV
=
typeof
global
1
.
EmberENV
=
=
=
'
object
'
&
&
global
1
.
EmberENV
|
|
typeof
global
1
.
ENV
=
=
=
'
object
'
&
&
global
1
.
ENV
|
|
{
}
;
if
(
ENV
.
ENABLE_ALL_FEATURES
)
{
ENV
.
ENABLE_OPTIONAL_FEATURES
=
true
;
}
ENV
.
EXTEND_PROTOTYPES
=
normalizeExtendPrototypes
(
ENV
.
EXTEND_PROTOTYPES
)
;
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
=
defaultTrue
(
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
)
;
ENV
.
LOG_VERSION
=
defaultTrue
(
ENV
.
LOG_VERSION
)
;
ENV
.
LOG_BINDINGS
=
defaultFalse
(
ENV
.
LOG_BINDINGS
)
;
ENV
.
RAISE_ON_DEPRECATION
=
defaultFalse
(
ENV
.
RAISE_ON_DEPRECATION
)
;
var
hasDOM
=
typeof
window
!
=
=
'
undefined
'
&
&
window
=
=
=
global
1
&
&
window
.
document
&
&
window
.
document
.
createElement
&
&
!
ENV
.
disableBrowserEnvironment
;
var
originalContext
=
global
1
.
Ember
|
|
{
}
;
var
context
=
{
imports
:
originalContext
.
imports
|
|
global
1
exports
:
originalContext
.
exports
|
|
global
1
lookup
:
originalContext
.
lookup
|
|
global
1
}
;
var
environment
=
hasDOM
?
{
hasDOM
:
true
isChrome
:
!
!
window
.
chrome
&
&
!
window
.
opera
isFirefox
:
typeof
InstallTrigger
!
=
=
'
undefined
'
location
:
window
.
location
history
:
window
.
history
userAgent
:
window
.
navigator
.
userAgent
window
:
window
}
:
{
hasDOM
:
false
isChrome
:
false
isFirefox
:
false
location
:
null
history
:
null
userAgent
:
'
Lynx
(
textmode
)
'
window
:
null
}
;
exports
.
ENV
=
ENV
;
exports
.
context
=
context
;
exports
.
environment
=
environment
;
}
)
;
enifed
(
'
ember
-
extension
-
support
/
container_debug_adapter
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
]
function
(
exports
_emberMetal
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
resolver
:
null
canCatalogEntriesByType
:
function
(
type
)
{
if
(
type
=
=
=
'
model
'
|
|
type
=
=
=
'
template
'
)
{
return
false
;
}
return
true
;
}
catalogEntriesByType
:
function
(
type
)
{
var
namespaces
=
(
0
_emberRuntime
.
A
)
(
_emberRuntime
.
Namespace
.
NAMESPACES
)
;
var
types
=
(
0
_emberRuntime
.
A
)
(
)
;
var
typeSuffixRegex
=
new
RegExp
(
_emberRuntime
.
String
.
classify
(
type
)
+
'
'
)
;
namespaces
.
forEach
(
function
(
namespace
)
{
if
(
namespace
!
=
=
_emberMetal
.
default
)
{
for
(
var
key
in
namespace
)
{
if
(
!
namespace
.
hasOwnProperty
(
key
)
)
{
continue
;
}
if
(
typeSuffixRegex
.
test
(
key
)
)
{
var
klass
=
namespace
[
key
]
;
if
(
(
0
_emberRuntime
.
typeOf
)
(
klass
)
=
=
=
'
class
'
)
{
types
.
push
(
_emberRuntime
.
String
.
dasherize
(
key
.
replace
(
typeSuffixRegex
'
'
)
)
)
;
}
}
}
}
}
)
;
return
types
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
extension
-
support
/
data_adapter
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
runtime
'
]
function
(
exports
_emberUtils
_emberMetal
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
releaseMethods
=
(
0
_emberRuntime
.
A
)
(
)
;
}
containerDebugAdapter
:
undefined
attributeLimit
:
3
acceptsModelName
:
true
releaseMethods
:
(
0
_emberRuntime
.
A
)
(
)
getFilters
:
function
(
)
{
return
(
0
_emberRuntime
.
A
)
(
)
;
}
watchModelTypes
:
function
(
typesAdded
typesUpdated
)
{
var
_this
=
this
;
var
modelTypes
=
this
.
getModelTypes
(
)
;
var
releaseMethods
=
(
0
_emberRuntime
.
A
)
(
)
;
var
typesToSend
=
void
0
;
typesToSend
=
modelTypes
.
map
(
function
(
type
)
{
var
klass
=
type
.
klass
;
var
wrapped
=
_this
.
wrapModelType
(
klass
type
.
name
)
;
releaseMethods
.
push
(
_this
.
observeModelType
(
type
.
name
typesUpdated
)
)
;
return
wrapped
;
}
)
;
typesAdded
(
typesToSend
)
;
var
release
=
function
(
)
{
releaseMethods
.
forEach
(
function
(
fn
)
{
return
fn
(
)
;
}
)
;
_this
.
releaseMethods
.
removeObject
(
release
)
;
}
;
this
.
releaseMethods
.
pushObject
(
release
)
;
return
release
;
}
_nameToClass
:
function
(
type
)
{
if
(
typeof
type
=
=
=
'
string
'
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
Factory
=
owner
.
factoryFor
(
'
model
:
'
+
type
)
;
type
=
Factory
&
&
Factory
.
class
;
}
return
type
;
}
watchRecords
:
function
(
modelName
recordsAdded
recordsUpdated
recordsRemoved
)
{
var
_this2
=
this
;
var
releaseMethods
=
(
0
_emberRuntime
.
A
)
(
)
;
var
klass
=
this
.
_nameToClass
(
modelName
)
;
var
records
=
this
.
getRecords
(
klass
modelName
)
;
var
release
=
void
0
;
function
recordUpdated
(
updatedRecord
)
{
recordsUpdated
(
[
updatedRecord
]
)
;
}
var
recordsToSend
=
records
.
map
(
function
(
record
)
{
releaseMethods
.
push
(
_this2
.
observeRecord
(
record
recordUpdated
)
)
;
return
_this2
.
wrapRecord
(
record
)
;
}
)
;
var
contentDidChange
=
function
(
array
idx
removedCount
addedCount
)
{
for
(
var
i
=
idx
;
i
<
idx
+
addedCount
;
i
+
+
)
{
var
record
=
(
0
_emberRuntime
.
objectAt
)
(
array
i
)
;
var
wrapped
=
_this2
.
wrapRecord
(
record
)
;
releaseMethods
.
push
(
_this2
.
observeRecord
(
record
recordUpdated
)
)
;
recordsAdded
(
[
wrapped
]
)
;
}
if
(
removedCount
)
{
recordsRemoved
(
idx
removedCount
)
;
}
}
;
var
observer
=
{
didChange
:
contentDidChange
willChange
:
function
(
)
{
return
this
;
}
}
;
(
0
_emberRuntime
.
addArrayObserver
)
(
records
this
observer
)
;
release
=
function
(
)
{
releaseMethods
.
forEach
(
function
(
fn
)
{
return
fn
(
)
;
}
)
;
(
0
_emberRuntime
.
removeArrayObserver
)
(
records
_this2
observer
)
;
_this2
.
releaseMethods
.
removeObject
(
release
)
;
}
;
recordsAdded
(
recordsToSend
)
;
this
.
releaseMethods
.
pushObject
(
release
)
;
return
release
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
releaseMethods
.
forEach
(
function
(
fn
)
{
return
fn
(
)
;
}
)
;
}
detect
:
function
(
)
{
return
false
;
}
columnsForType
:
function
(
)
{
return
(
0
_emberRuntime
.
A
)
(
)
;
}
observeModelType
:
function
(
modelName
typesUpdated
)
{
var
_this3
=
this
;
var
klass
=
this
.
_nameToClass
(
modelName
)
;
var
records
=
this
.
getRecords
(
klass
modelName
)
;
function
onChange
(
)
{
typesUpdated
(
[
this
.
wrapModelType
(
klass
modelName
)
]
)
;
}
var
observer
=
{
didChange
:
function
(
array
idx
removedCount
addedCount
)
{
if
(
removedCount
>
0
|
|
addedCount
>
0
)
{
_emberMetal
.
run
.
scheduleOnce
(
'
actions
'
this
onChange
)
;
}
}
willChange
:
function
(
)
{
return
this
;
}
}
;
(
0
_emberRuntime
.
addArrayObserver
)
(
records
this
observer
)
;
var
release
=
function
(
)
{
return
(
0
_emberRuntime
.
removeArrayObserver
)
(
records
_this3
observer
)
;
}
;
return
release
;
}
wrapModelType
:
function
(
klass
name
)
{
var
records
=
this
.
getRecords
(
klass
name
)
;
var
typeToSend
=
void
0
;
typeToSend
=
{
name
:
name
count
:
(
0
_emberMetal
.
get
)
(
records
'
length
'
)
columns
:
this
.
columnsForType
(
klass
)
object
:
klass
}
;
return
typeToSend
;
}
getModelTypes
:
function
(
)
{
var
_this4
=
this
;
var
containerDebugAdapter
=
this
.
get
(
'
containerDebugAdapter
'
)
;
var
types
=
void
0
;
if
(
containerDebugAdapter
.
canCatalogEntriesByType
(
'
model
'
)
)
{
types
=
containerDebugAdapter
.
catalogEntriesByType
(
'
model
'
)
;
}
else
{
types
=
this
.
_getObjectsOnNamespaces
(
)
;
}
types
=
(
0
_emberRuntime
.
A
)
(
types
)
.
map
(
function
(
name
)
{
return
{
klass
:
_this4
.
_nameToClass
(
name
)
name
:
name
}
;
}
)
;
types
=
(
0
_emberRuntime
.
A
)
(
types
)
.
filter
(
function
(
type
)
{
return
_this4
.
detect
(
type
.
klass
)
;
}
)
;
return
(
0
_emberRuntime
.
A
)
(
types
)
;
}
_getObjectsOnNamespaces
:
function
(
)
{
var
_this5
=
this
;
var
namespaces
=
(
0
_emberRuntime
.
A
)
(
_emberRuntime
.
Namespace
.
NAMESPACES
)
;
var
types
=
(
0
_emberRuntime
.
A
)
(
)
;
namespaces
.
forEach
(
function
(
namespace
)
{
for
(
var
key
in
namespace
)
{
if
(
!
namespace
.
hasOwnProperty
(
key
)
)
{
continue
;
}
if
(
!
_this5
.
detect
(
namespace
[
key
]
)
)
{
continue
;
}
var
name
=
_emberRuntime
.
String
.
dasherize
(
key
)
;
types
.
push
(
name
)
;
}
}
)
;
return
types
;
}
getRecords
:
function
(
)
{
return
(
0
_emberRuntime
.
A
)
(
)
;
}
wrapRecord
:
function
(
record
)
{
var
recordToSend
=
{
object
:
record
}
;
recordToSend
.
columnValues
=
this
.
getRecordColumnValues
(
record
)
;
recordToSend
.
searchKeywords
=
this
.
getRecordKeywords
(
record
)
;
recordToSend
.
filterValues
=
this
.
getRecordFilterValues
(
record
)
;
recordToSend
.
color
=
this
.
getRecordColor
(
record
)
;
return
recordToSend
;
}
getRecordColumnValues
:
function
(
)
{
return
{
}
;
}
getRecordKeywords
:
function
(
)
{
return
(
0
_emberRuntime
.
A
)
(
)
;
}
getRecordFilterValues
:
function
(
)
{
return
{
}
;
}
getRecordColor
:
function
(
)
{
return
null
;
}
observeRecord
:
function
(
)
{
return
function
(
)
{
}
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
extension
-
support
/
index
'
[
'
exports
'
'
ember
-
extension
-
support
/
data_adapter
'
'
ember
-
extension
-
support
/
container_debug_adapter
'
]
function
(
exports
_data_adapter
_container_debug_adapter
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
DataAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_data_adapter
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ContainerDebugAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_container_debug_adapter
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
[
'
exports
'
'
ember
-
babel
'
]
function
(
exports
_emberBabel
)
{
'
use
strict
'
;
var
AbstractManager
=
function
(
)
{
function
AbstractManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
AbstractManager
)
;
this
.
debugStack
=
undefined
;
}
AbstractManager
.
prototype
.
prepareArgs
=
function
prepareArgs
(
_definition
_args
)
{
return
null
;
}
;
AbstractManager
.
prototype
.
didCreateElement
=
function
didCreateElement
(
_component
_element
_operations
)
{
}
;
AbstractManager
.
prototype
.
didRenderLayout
=
function
didRenderLayout
(
_component
_bounds
)
{
}
;
AbstractManager
.
prototype
.
didCreate
=
function
didCreate
(
_bucket
)
{
}
;
AbstractManager
.
prototype
.
getTag
=
function
getTag
(
_bucket
)
{
return
null
;
}
;
AbstractManager
.
prototype
.
update
=
function
update
(
_bucket
_dynamicScope
)
{
}
;
AbstractManager
.
prototype
.
didUpdateLayout
=
function
didUpdateLayout
(
_bucket
_bounds
)
{
}
;
AbstractManager
.
prototype
.
didUpdate
=
function
didUpdate
(
_bucket
)
{
}
;
return
AbstractManager
;
}
(
)
;
exports
.
default
=
AbstractManager
;
if
(
true
)
{
AbstractManager
.
prototype
.
_pushToDebugStack
=
function
(
name
environment
)
{
this
.
debugStack
=
environment
.
debugStack
;
this
.
debugStack
.
push
(
name
)
;
}
;
AbstractManager
.
prototype
.
_pushEngineToDebugStack
=
function
(
name
environment
)
{
this
.
debugStack
=
environment
.
debugStack
;
this
.
debugStack
.
pushEngine
(
name
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
curly
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
glimmer
/
runtime
'
'
container
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
utils
/
bindings
'
'
ember
-
glimmer
/
utils
/
curly
-
component
-
state
-
bucket
'
'
ember
-
glimmer
/
utils
/
process
-
args
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
]
function
(
exports
_emberBabel
_reference
_runtime
_container
_emberDebug
_emberMetal
_emberUtils
_emberViews
_component
_bindings
_curlyComponentStateBucket
_processArgs
_references
_abstract
)
{
'
use
strict
'
;
exports
.
CurlyComponentDefinition
=
exports
.
PositionalArgumentReference
=
undefined
;
exports
.
validatePositionalParameters
=
validatePositionalParameters
;
exports
.
processComponentInitializationAssertions
=
processComponentInitializationAssertions
;
exports
.
initialRenderInstrumentDetails
=
initialRenderInstrumentDetails
;
exports
.
rerenderInstrumentDetails
=
rerenderInstrumentDetails
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
template
:
components
/
-
default
'
]
[
'
template
:
components
/
-
default
'
]
)
;
var
DEFAULT_LAYOUT
=
(
0
_container
.
privatize
)
(
_templateObject
)
;
function
aliasIdToElementId
(
args
props
)
{
if
(
args
.
named
.
has
(
'
id
'
)
)
{
(
true
&
&
!
(
!
args
.
named
.
has
(
'
elementId
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
invoke
a
component
with
both
\
'
id
\
'
and
\
'
elementId
\
'
at
the
same
time
.
'
!
args
.
named
.
has
(
'
elementId
'
)
)
)
;
props
.
elementId
=
props
.
id
;
}
}
function
applyAttributeBindings
(
element
attributeBindings
component
operations
)
{
var
seen
=
[
]
;
var
i
=
attributeBindings
.
length
-
1
;
while
(
i
!
=
=
-
1
)
{
var
binding
=
attributeBindings
[
i
]
;
var
parsed
=
_bindings
.
AttributeBinding
.
parse
(
binding
)
;
var
attribute
=
parsed
[
1
]
;
if
(
seen
.
indexOf
(
attribute
)
=
=
=
-
1
)
{
seen
.
push
(
attribute
)
;
_bindings
.
AttributeBinding
.
install
(
element
component
parsed
operations
)
;
}
i
-
-
;
}
if
(
seen
.
indexOf
(
'
id
'
)
=
=
=
-
1
)
{
operations
.
addStaticAttribute
(
element
'
id
'
component
.
elementId
)
;
}
if
(
seen
.
indexOf
(
'
style
'
)
=
=
=
-
1
)
{
_bindings
.
IsVisibleBinding
.
install
(
element
component
operations
)
;
}
}
function
tagName
(
vm
)
{
var
dynamicScope
=
vm
.
dynamicScope
(
)
;
var
tagName
=
dynamicScope
.
view
.
tagName
;
return
_runtime
.
PrimitiveReference
.
create
(
tagName
=
=
=
'
'
?
null
:
tagName
|
|
'
div
'
)
;
}
function
ariaRole
(
vm
)
{
return
vm
.
getSelf
(
)
.
get
(
'
ariaRole
'
)
;
}
var
CurlyComponentLayoutCompiler
=
function
(
)
{
function
CurlyComponentLayoutCompiler
(
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
CurlyComponentLayoutCompiler
)
;
this
.
template
=
template
;
}
CurlyComponentLayoutCompiler
.
prototype
.
compile
=
function
compile
(
builder
)
{
builder
.
wrapLayout
(
this
.
template
)
;
builder
.
tag
.
dynamic
(
tagName
)
;
builder
.
attrs
.
dynamic
(
'
role
'
ariaRole
)
;
builder
.
attrs
.
static
(
'
class
'
'
ember
-
view
'
)
;
}
;
return
CurlyComponentLayoutCompiler
;
}
(
)
;
CurlyComponentLayoutCompiler
.
id
=
'
curly
'
;
var
PositionalArgumentReference
=
exports
.
PositionalArgumentReference
=
function
(
)
{
function
PositionalArgumentReference
(
references
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
PositionalArgumentReference
)
;
this
.
tag
=
(
0
_reference
.
combineTagged
)
(
references
)
;
this
.
_references
=
references
;
}
PositionalArgumentReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
_references
.
map
(
function
(
reference
)
{
return
reference
.
value
(
)
;
}
)
;
}
;
PositionalArgumentReference
.
prototype
.
get
=
function
get
(
key
)
{
return
_references
.
PropertyReference
.
create
(
this
key
)
;
}
;
return
PositionalArgumentReference
;
}
(
)
;
var
CurlyComponentManager
=
function
(
_AbstractManager
)
{
(
0
_emberBabel
.
inherits
)
(
CurlyComponentManager
_AbstractManager
)
;
function
CurlyComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
CurlyComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractManager
.
apply
(
this
arguments
)
)
;
}
CurlyComponentManager
.
prototype
.
prepareArgs
=
function
prepareArgs
(
definition
args
)
{
var
componentPositionalParamsDefinition
=
definition
.
ComponentClass
.
class
.
positionalParams
;
if
(
true
&
&
componentPositionalParamsDefinition
)
{
validatePositionalParameters
(
args
.
named
args
.
positional
componentPositionalParamsDefinition
)
;
}
var
componentHasRestStylePositionalParams
=
typeof
componentPositionalParamsDefinition
=
=
=
'
string
'
;
var
componentHasPositionalParams
=
componentHasRestStylePositionalParams
|
|
componentPositionalParamsDefinition
.
length
>
0
;
var
needsPositionalParamMunging
=
componentHasPositionalParams
&
&
args
.
positional
.
length
!
=
=
0
;
var
isClosureComponent
=
definition
.
args
;
if
(
!
needsPositionalParamMunging
&
&
!
isClosureComponent
)
{
return
null
;
}
var
capturedArgs
=
args
.
capture
(
)
;
var
positional
=
capturedArgs
.
positional
.
references
;
var
curriedNamed
=
void
0
;
if
(
definition
.
args
)
{
var
remainingDefinitionPositionals
=
definition
.
args
.
positional
.
slice
(
positional
.
length
)
;
positional
=
positional
.
concat
(
remainingDefinitionPositionals
)
;
curriedNamed
=
definition
.
args
.
named
;
}
var
positionalParamsToNamed
=
void
0
;
if
(
componentHasRestStylePositionalParams
)
{
var
_positionalParamsToNa
;
positionalParamsToNamed
=
(
_positionalParamsToNa
=
{
}
_positionalParamsToNa
[
componentPositionalParamsDefinition
]
=
new
PositionalArgumentReference
(
positional
)
_positionalParamsToNa
)
;
positional
=
[
]
;
}
else
if
(
componentHasPositionalParams
)
{
positionalParamsToNamed
=
{
}
;
var
length
=
Math
.
min
(
positional
.
length
componentPositionalParamsDefinition
.
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
var
name
=
componentPositionalParamsDefinition
[
i
]
;
positionalParamsToNamed
[
name
]
=
positional
[
i
]
;
}
}
var
named
=
(
0
_emberUtils
.
assign
)
(
{
}
curriedNamed
positionalParamsToNamed
capturedArgs
.
named
.
map
)
;
return
{
positional
:
positional
named
:
named
}
;
}
;
CurlyComponentManager
.
prototype
.
create
=
function
create
(
environment
definition
args
dynamicScope
callerSelfRef
hasBlock
)
{
if
(
true
)
{
this
.
_pushToDebugStack
(
'
component
:
'
+
definition
.
name
environment
)
;
}
var
parentView
=
dynamicScope
.
view
;
var
factory
=
definition
.
ComponentClass
;
var
capturedArgs
=
args
.
named
.
capture
(
)
;
var
props
=
(
0
_processArgs
.
processComponentArgs
)
(
capturedArgs
)
;
aliasIdToElementId
(
args
props
)
;
props
.
parentView
=
parentView
;
props
[
_component
.
HAS_BLOCK
]
=
hasBlock
;
props
.
_targetObject
=
callerSelfRef
.
value
(
)
;
var
component
=
factory
.
create
(
props
)
;
var
finalizer
=
(
0
_emberMetal
.
_instrumentStart
)
(
'
render
.
component
'
initialRenderInstrumentDetails
component
)
;
dynamicScope
.
view
=
component
;
if
(
parentView
!
=
=
null
&
&
parentView
!
=
=
undefined
)
{
parentView
.
appendChild
(
component
)
;
}
if
(
component
.
tagName
=
=
=
'
'
)
{
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willRender
'
)
;
}
component
.
_transitionTo
(
'
hasElement
'
)
;
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willInsertElement
'
)
;
}
}
var
bucket
=
new
_curlyComponentStateBucket
.
default
(
environment
component
capturedArgs
finalizer
)
;
if
(
args
.
named
.
has
(
'
class
'
)
)
{
bucket
.
classRef
=
args
.
named
.
get
(
'
class
'
)
;
}
if
(
true
)
{
processComponentInitializationAssertions
(
component
props
)
;
}
if
(
environment
.
isInteractive
&
&
component
.
tagName
!
=
=
'
'
)
{
component
.
trigger
(
'
willRender
'
)
;
}
return
bucket
;
}
;
CurlyComponentManager
.
prototype
.
layoutFor
=
function
layoutFor
(
definition
bucket
env
)
{
var
template
=
definition
.
template
;
if
(
!
template
)
{
template
=
this
.
templateFor
(
bucket
.
component
env
)
;
}
return
env
.
getCompiledBlock
(
CurlyComponentLayoutCompiler
template
)
;
}
;
CurlyComponentManager
.
prototype
.
templateFor
=
function
templateFor
(
component
env
)
{
var
Template
=
(
0
_emberMetal
.
get
)
(
component
'
layout
'
)
;
var
owner
=
component
[
_emberUtils
.
OWNER
]
;
if
(
Template
)
{
return
env
.
getTemplate
(
Template
owner
)
;
}
var
layoutName
=
(
0
_emberMetal
.
get
)
(
component
'
layoutName
'
)
;
if
(
layoutName
)
{
var
template
=
owner
.
lookup
(
'
template
:
'
+
layoutName
)
;
if
(
template
)
{
return
template
;
}
}
return
owner
.
lookup
(
DEFAULT_LAYOUT
)
;
}
;
CurlyComponentManager
.
prototype
.
getSelf
=
function
getSelf
(
_ref
)
{
var
component
=
_ref
.
component
;
return
component
[
_component
.
ROOT_REF
]
;
}
;
CurlyComponentManager
.
prototype
.
didCreateElement
=
function
didCreateElement
(
_ref2
element
operations
)
{
var
component
=
_ref2
.
component
classRef
=
_ref2
.
classRef
environment
=
_ref2
.
environment
;
(
0
_emberViews
.
setViewElement
)
(
component
element
)
;
var
attributeBindings
=
component
.
attributeBindings
classNames
=
component
.
classNames
classNameBindings
=
component
.
classNameBindings
;
if
(
attributeBindings
&
&
attributeBindings
.
length
)
{
applyAttributeBindings
(
element
attributeBindings
component
operations
)
;
}
else
{
operations
.
addStaticAttribute
(
element
'
id
'
component
.
elementId
)
;
_bindings
.
IsVisibleBinding
.
install
(
element
component
operations
)
;
}
if
(
classRef
)
{
operations
.
addDynamicAttribute
(
element
'
class
'
classRef
false
)
;
}
if
(
classNames
&
&
classNames
.
length
)
{
classNames
.
forEach
(
function
(
name
)
{
operations
.
addStaticAttribute
(
element
'
class
'
name
)
;
}
)
;
}
if
(
classNameBindings
&
&
classNameBindings
.
length
)
{
classNameBindings
.
forEach
(
function
(
binding
)
{
_bindings
.
ClassNameBinding
.
install
(
element
component
binding
operations
)
;
}
)
;
}
component
.
_transitionTo
(
'
hasElement
'
)
;
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willInsertElement
'
)
;
}
}
;
CurlyComponentManager
.
prototype
.
didRenderLayout
=
function
didRenderLayout
(
bucket
bounds
)
{
bucket
.
component
[
_component
.
BOUNDS
]
=
bounds
;
bucket
.
finalize
(
)
;
if
(
true
)
{
this
.
debugStack
.
pop
(
)
;
}
}
;
CurlyComponentManager
.
prototype
.
getTag
=
function
getTag
(
_ref3
)
{
var
component
=
_ref3
.
component
;
return
component
[
_component
.
DIRTY_TAG
]
;
}
;
CurlyComponentManager
.
prototype
.
didCreate
=
function
didCreate
(
_ref4
)
{
var
component
=
_ref4
.
component
environment
=
_ref4
.
environment
;
if
(
environment
.
isInteractive
)
{
component
.
_transitionTo
(
'
inDOM
'
)
;
component
.
trigger
(
'
didInsertElement
'
)
;
component
.
trigger
(
'
didRender
'
)
;
}
}
;
CurlyComponentManager
.
prototype
.
update
=
function
update
(
bucket
)
{
var
component
=
bucket
.
component
args
=
bucket
.
args
argsRevision
=
bucket
.
argsRevision
environment
=
bucket
.
environment
;
if
(
true
)
{
this
.
_pushToDebugStack
(
component
.
_debugContainerKey
environment
)
;
}
bucket
.
finalizer
=
(
0
_emberMetal
.
_instrumentStart
)
(
'
render
.
component
'
rerenderInstrumentDetails
component
)
;
if
(
!
args
.
tag
.
validate
(
argsRevision
)
)
{
var
props
=
(
0
_processArgs
.
processComponentArgs
)
(
args
)
;
bucket
.
argsRevision
=
args
.
tag
.
value
(
)
;
component
[
_component
.
IS_DISPATCHING_ATTRS
]
=
true
;
component
.
setProperties
(
props
)
;
component
[
_component
.
IS_DISPATCHING_ATTRS
]
=
false
;
component
.
trigger
(
'
didUpdateAttrs
'
)
;
component
.
trigger
(
'
didReceiveAttrs
'
)
;
}
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willUpdate
'
)
;
component
.
trigger
(
'
willRender
'
)
;
}
}
;
CurlyComponentManager
.
prototype
.
didUpdateLayout
=
function
didUpdateLayout
(
bucket
)
{
bucket
.
finalize
(
)
;
if
(
true
)
{
this
.
debugStack
.
pop
(
)
;
}
}
;
CurlyComponentManager
.
prototype
.
didUpdate
=
function
didUpdate
(
_ref5
)
{
var
component
=
_ref5
.
component
environment
=
_ref5
.
environment
;
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
didUpdate
'
)
;
component
.
trigger
(
'
didRender
'
)
;
}
}
;
CurlyComponentManager
.
prototype
.
getDestructor
=
function
getDestructor
(
stateBucket
)
{
return
stateBucket
;
}
;
return
CurlyComponentManager
;
}
(
_abstract
.
default
)
;
exports
.
default
=
CurlyComponentManager
;
function
validatePositionalParameters
(
named
positional
positionalParamsDefinition
)
{
if
(
true
)
{
if
(
!
named
|
|
!
positional
|
|
!
positional
.
length
)
{
return
;
}
var
paramType
=
typeof
positionalParamsDefinition
;
if
(
paramType
=
=
=
'
string
'
)
{
(
true
&
&
!
(
!
named
.
has
(
positionalParamsDefinition
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
specify
positional
parameters
and
the
hash
argument
'
+
positionalParamsDefinition
+
'
.
'
!
named
.
has
(
positionalParamsDefinition
)
)
)
;
}
else
{
if
(
positional
.
length
<
positionalParamsDefinition
.
length
)
{
positionalParamsDefinition
=
positionalParamsDefinition
.
slice
(
0
positional
.
length
)
;
}
for
(
var
i
=
0
;
i
<
positionalParamsDefinition
.
length
;
i
+
+
)
{
var
name
=
positionalParamsDefinition
[
i
]
;
(
true
&
&
!
(
!
named
.
has
(
name
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
specify
both
a
positional
param
(
at
position
'
+
i
+
'
)
and
the
hash
argument
'
+
name
+
'
.
'
!
named
.
has
(
name
)
)
)
;
}
}
}
}
function
processComponentInitializationAssertions
(
component
props
)
{
(
true
&
&
!
(
function
(
)
{
var
classNameBindings
=
component
.
classNameBindings
;
for
(
var
i
=
0
;
i
<
classNameBindings
.
length
;
i
+
+
)
{
var
binding
=
classNameBindings
[
i
]
;
if
(
typeof
binding
!
=
=
'
string
'
|
|
binding
.
length
=
=
=
0
)
{
return
false
;
}
}
return
true
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
classNameBindings
must
be
non
-
empty
strings
:
'
+
component
function
(
)
{
var
classNameBindings
=
component
.
classNameBindings
;
for
(
var
i
=
0
;
i
<
classNameBindings
.
length
;
i
+
+
)
{
var
binding
=
classNameBindings
[
i
]
;
if
(
typeof
binding
!
=
=
'
string
'
|
|
binding
.
length
=
=
=
0
)
{
return
false
;
}
}
return
true
;
}
(
)
)
)
;
(
true
&
&
!
(
function
(
)
{
var
classNameBindings
=
component
.
classNameBindings
;
for
(
var
i
=
0
;
i
<
classNameBindings
.
length
;
i
+
+
)
{
var
binding
=
classNameBindings
[
i
]
;
if
(
binding
.
split
(
'
'
)
.
length
>
1
)
{
return
false
;
}
}
return
true
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
classNameBindings
must
not
have
spaces
in
them
:
'
+
component
function
(
)
{
var
classNameBindings
=
component
.
classNameBindings
;
for
(
var
i
=
0
;
i
<
classNameBindings
.
length
;
i
+
+
)
{
var
binding
=
classNameBindings
[
i
]
;
if
(
binding
.
split
(
'
'
)
.
length
>
1
)
{
return
false
;
}
}
return
true
;
}
(
)
)
)
;
(
true
&
&
!
(
component
.
tagName
!
=
=
'
'
|
|
!
component
.
classNameBindings
|
|
component
.
classNameBindings
.
length
=
=
=
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
classNameBindings
on
a
tag
-
less
component
:
'
+
component
component
.
tagName
!
=
=
'
'
|
|
!
component
.
classNameBindings
|
|
component
.
classNameBindings
.
length
=
=
=
0
)
)
;
(
true
&
&
!
(
component
.
tagName
!
=
=
'
'
|
|
props
.
id
=
=
=
component
.
elementId
|
|
!
component
.
elementId
&
&
component
.
elementId
!
=
=
'
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
elementId
on
a
tag
-
less
component
:
'
+
component
component
.
tagName
!
=
=
'
'
|
|
props
.
id
=
=
=
component
.
elementId
|
|
!
component
.
elementId
&
&
component
.
elementId
!
=
=
'
'
)
)
;
(
true
&
&
!
(
component
.
tagName
!
=
=
'
'
|
|
!
component
.
attributeBindings
|
|
component
.
attributeBindings
.
length
=
=
=
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
attributeBindings
on
a
tag
-
less
component
:
'
+
component
component
.
tagName
!
=
=
'
'
|
|
!
component
.
attributeBindings
|
|
component
.
attributeBindings
.
length
=
=
=
0
)
)
;
}
function
initialRenderInstrumentDetails
(
component
)
{
return
component
.
instrumentDetails
(
{
initialRender
:
true
}
)
;
}
function
rerenderInstrumentDetails
(
component
)
{
return
component
.
instrumentDetails
(
{
initialRender
:
false
}
)
;
}
var
MANAGER
=
new
CurlyComponentManager
(
)
;
var
CurlyComponentDefinition
=
exports
.
CurlyComponentDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
CurlyComponentDefinition
_ComponentDefinition
)
;
function
CurlyComponentDefinition
(
name
ComponentClass
template
args
customManager
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
CurlyComponentDefinition
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
name
customManager
|
|
MANAGER
ComponentClass
)
)
;
_this2
.
template
=
template
;
_this2
.
args
=
args
;
return
_this2
;
}
return
CurlyComponentDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
mount
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
routing
'
'
ember
/
features
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
'
ember
-
glimmer
/
component
-
managers
/
outlet
'
]
function
(
exports
_emberBabel
_runtime
_emberRouting
_features
_references
_abstract
_outlet
)
{
'
use
strict
'
;
exports
.
MountDefinition
=
undefined
;
var
MountManager
=
function
(
_AbstractManager
)
{
(
0
_emberBabel
.
inherits
)
(
MountManager
_AbstractManager
)
;
function
MountManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
MountManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractManager
.
apply
(
this
arguments
)
)
;
}
MountManager
.
prototype
.
create
=
function
create
(
environment
_ref
args
)
{
var
name
=
_ref
.
name
;
if
(
true
)
{
this
.
_pushEngineToDebugStack
(
'
engine
:
'
+
name
environment
)
;
}
var
engine
=
environment
.
owner
.
buildChildEngineInstance
(
name
)
;
engine
.
boot
(
)
;
var
bucket
=
{
engine
:
engine
}
;
if
(
_features
.
EMBER_ENGINES_MOUNT_PARAMS
)
{
bucket
.
modelReference
=
args
.
named
.
get
(
'
model
'
)
;
}
return
bucket
;
}
;
MountManager
.
prototype
.
layoutFor
=
function
layoutFor
(
_definition
_ref2
env
)
{
var
engine
=
_ref2
.
engine
;
var
template
=
engine
.
lookup
(
'
template
:
application
'
)
;
return
env
.
getCompiledBlock
(
_outlet
.
OutletLayoutCompiler
template
)
;
}
;
MountManager
.
prototype
.
getSelf
=
function
getSelf
(
bucket
)
{
var
engine
=
bucket
.
engine
modelReference
=
bucket
.
modelReference
;
var
applicationFactory
=
engine
.
factoryFor
(
'
controller
:
application
'
)
;
var
controllerFactory
=
applicationFactory
|
|
(
0
_emberRouting
.
generateControllerFactory
)
(
engine
'
application
'
)
;
var
controller
=
bucket
.
controller
=
controllerFactory
.
create
(
)
;
if
(
_features
.
EMBER_ENGINES_MOUNT_PARAMS
)
{
var
model
=
modelReference
.
value
(
)
;
bucket
.
modelRevision
=
modelReference
.
tag
.
value
(
)
;
controller
.
set
(
'
model
'
model
)
;
}
return
new
_references
.
RootReference
(
controller
)
;
}
;
MountManager
.
prototype
.
getDestructor
=
function
getDestructor
(
_ref3
)
{
var
engine
=
_ref3
.
engine
;
return
engine
;
}
;
MountManager
.
prototype
.
didRenderLayout
=
function
didRenderLayout
(
)
{
if
(
true
)
{
this
.
debugStack
.
pop
(
)
;
}
}
;
MountManager
.
prototype
.
update
=
function
update
(
bucket
)
{
if
(
_features
.
EMBER_ENGINES_MOUNT_PARAMS
)
{
var
controller
=
bucket
.
controller
modelReference
=
bucket
.
modelReference
modelRevision
=
bucket
.
modelRevision
;
if
(
!
modelReference
.
tag
.
validate
(
modelRevision
)
)
{
var
model
=
modelReference
.
value
(
)
;
bucket
.
modelRevision
=
modelReference
.
tag
.
value
(
)
;
controller
.
set
(
'
model
'
model
)
;
}
}
}
;
return
MountManager
;
}
(
_abstract
.
default
)
;
var
MOUNT_MANAGER
=
new
MountManager
(
)
;
var
MountDefinition
=
exports
.
MountDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
MountDefinition
_ComponentDefinition
)
;
function
MountDefinition
(
name
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
MountDefinition
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
name
MOUNT_MANAGER
null
)
)
;
}
return
MountDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
outlet
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
/
features
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
]
function
(
exports
_emberBabel
_runtime
_emberMetal
_emberUtils
_features
_references
_abstract
)
{
'
use
strict
'
;
exports
.
OutletLayoutCompiler
=
exports
.
OutletComponentDefinition
=
exports
.
TopLevelOutletComponentDefinition
=
undefined
;
function
instrumentationPayload
(
_ref
)
{
var
_ref
render
=
_ref
.
render
name
=
_ref
render
.
name
outlet
=
_ref
render
.
outlet
;
return
{
object
:
name
+
'
:
'
+
outlet
}
;
}
function
NOOP
(
)
{
}
var
StateBucket
=
function
(
)
{
function
StateBucket
(
outletState
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
StateBucket
)
;
this
.
outletState
=
outletState
;
this
.
instrument
(
)
;
}
StateBucket
.
prototype
.
instrument
=
function
instrument
(
)
{
this
.
finalizer
=
(
0
_emberMetal
.
_instrumentStart
)
(
'
render
.
outlet
'
instrumentationPayload
this
.
outletState
)
;
}
;
StateBucket
.
prototype
.
finalize
=
function
finalize
(
)
{
var
finalizer
=
this
.
finalizer
;
finalizer
(
)
;
this
.
finalizer
=
NOOP
;
}
;
return
StateBucket
;
}
(
)
;
var
OutletComponentManager
=
function
(
_AbstractManager
)
{
(
0
_emberBabel
.
inherits
)
(
OutletComponentManager
_AbstractManager
)
;
function
OutletComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OutletComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractManager
.
apply
(
this
arguments
)
)
;
}
OutletComponentManager
.
prototype
.
create
=
function
create
(
environment
definition
_args
dynamicScope
)
{
if
(
true
)
{
this
.
_pushToDebugStack
(
'
template
:
'
+
definition
.
template
.
meta
.
moduleName
environment
)
;
}
var
outletStateReference
=
dynamicScope
.
outletState
=
dynamicScope
.
outletState
.
get
(
'
outlets
'
)
.
get
(
definition
.
outletName
)
;
var
outletState
=
outletStateReference
.
value
(
)
;
return
new
StateBucket
(
outletState
)
;
}
;
OutletComponentManager
.
prototype
.
layoutFor
=
function
layoutFor
(
definition
_bucket
env
)
{
return
env
.
getCompiledBlock
(
OutletLayoutCompiler
definition
.
template
)
;
}
;
OutletComponentManager
.
prototype
.
getSelf
=
function
getSelf
(
_ref2
)
{
var
outletState
=
_ref2
.
outletState
;
return
new
_references
.
RootReference
(
outletState
.
render
.
controller
)
;
}
;
OutletComponentManager
.
prototype
.
didRenderLayout
=
function
didRenderLayout
(
bucket
)
{
bucket
.
finalize
(
)
;
if
(
true
)
{
this
.
debugStack
.
pop
(
)
;
}
}
;
OutletComponentManager
.
prototype
.
getDestructor
=
function
getDestructor
(
)
{
return
null
;
}
;
return
OutletComponentManager
;
}
(
_abstract
.
default
)
;
var
MANAGER
=
new
OutletComponentManager
(
)
;
var
TopLevelOutletComponentManager
=
function
(
_OutletComponentManag
)
{
(
0
_emberBabel
.
inherits
)
(
TopLevelOutletComponentManager
_OutletComponentManag
)
;
function
TopLevelOutletComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TopLevelOutletComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_OutletComponentManag
.
apply
(
this
arguments
)
)
;
}
TopLevelOutletComponentManager
.
prototype
.
create
=
function
create
(
environment
definition
_args
dynamicScope
)
{
if
(
true
)
{
this
.
_pushToDebugStack
(
'
template
:
'
+
definition
.
template
.
meta
.
moduleName
environment
)
;
}
return
new
StateBucket
(
dynamicScope
.
outletState
.
value
(
)
)
;
}
;
return
TopLevelOutletComponentManager
;
}
(
OutletComponentManager
)
;
var
TOP_LEVEL_MANAGER
=
function
(
)
{
if
(
_features
.
EMBER_GLIMMER_REMOVE_APPLICATION_TEMPLATE_WRAPPER
)
{
return
new
TopLevelOutletComponentManager
(
)
;
}
else
{
var
WrappedTopLevelOutletLayoutCompiler
=
function
(
)
{
function
WrappedTopLevelOutletLayoutCompiler
(
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
WrappedTopLevelOutletLayoutCompiler
)
;
this
.
template
=
template
;
}
WrappedTopLevelOutletLayoutCompiler
.
prototype
.
compile
=
function
compile
(
builder
)
{
builder
.
wrapLayout
(
this
.
template
)
;
builder
.
tag
.
static
(
'
div
'
)
;
builder
.
attrs
.
static
(
'
id
'
(
0
_emberUtils
.
guidFor
)
(
this
)
)
;
builder
.
attrs
.
static
(
'
class
'
'
ember
-
view
'
)
;
}
;
return
WrappedTopLevelOutletLayoutCompiler
;
}
(
)
;
WrappedTopLevelOutletLayoutCompiler
.
id
=
'
wrapped
-
top
-
level
-
outlet
'
;
var
WrappedTopLevelOutletComponentManager
=
function
(
_TopLevelOutletCompon
)
{
(
0
_emberBabel
.
inherits
)
(
WrappedTopLevelOutletComponentManager
_TopLevelOutletCompon
)
;
function
WrappedTopLevelOutletComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
WrappedTopLevelOutletComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_TopLevelOutletCompon
.
apply
(
this
arguments
)
)
;
}
WrappedTopLevelOutletComponentManager
.
prototype
.
layoutFor
=
function
layoutFor
(
definition
_bucket
env
)
{
return
env
.
getCompiledBlock
(
WrappedTopLevelOutletLayoutCompiler
definition
.
template
)
;
}
;
return
WrappedTopLevelOutletComponentManager
;
}
(
TopLevelOutletComponentManager
)
;
return
new
WrappedTopLevelOutletComponentManager
(
)
;
}
}
(
)
;
var
TopLevelOutletComponentDefinition
=
exports
.
TopLevelOutletComponentDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
TopLevelOutletComponentDefinition
_ComponentDefinition
)
;
function
TopLevelOutletComponentDefinition
(
instance
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TopLevelOutletComponentDefinition
)
;
var
_this4
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
'
outlet
'
TOP_LEVEL_MANAGER
instance
)
)
;
_this4
.
template
=
instance
.
template
;
(
0
_emberUtils
.
generateGuid
)
(
_this4
)
;
return
_this4
;
}
return
TopLevelOutletComponentDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
var
OutletComponentDefinition
=
exports
.
OutletComponentDefinition
=
function
(
_ComponentDefinition2
)
{
(
0
_emberBabel
.
inherits
)
(
OutletComponentDefinition
_ComponentDefinition2
)
;
function
OutletComponentDefinition
(
outletName
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OutletComponentDefinition
)
;
var
_this5
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition2
.
call
(
this
'
outlet
'
MANAGER
null
)
)
;
_this5
.
outletName
=
outletName
;
_this5
.
template
=
template
;
(
0
_emberUtils
.
generateGuid
)
(
_this5
)
;
return
_this5
;
}
return
OutletComponentDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
var
OutletLayoutCompiler
=
exports
.
OutletLayoutCompiler
=
function
(
)
{
function
OutletLayoutCompiler
(
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OutletLayoutCompiler
)
;
this
.
template
=
template
;
}
OutletLayoutCompiler
.
prototype
.
compile
=
function
compile
(
builder
)
{
builder
.
wrapLayout
(
this
.
template
)
;
}
;
return
OutletLayoutCompiler
;
}
(
)
;
OutletLayoutCompiler
.
id
=
'
outlet
'
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
render
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
debug
'
'
ember
-
routing
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
'
ember
-
glimmer
/
component
-
managers
/
outlet
'
]
function
(
exports
_emberBabel
_runtime
_emberDebug
_emberRouting
_references
_abstract
_outlet
)
{
'
use
strict
'
;
exports
.
RenderDefinition
=
exports
.
NON_SINGLETON_RENDER_MANAGER
=
exports
.
SINGLETON_RENDER_MANAGER
=
exports
.
AbstractRenderManager
=
undefined
;
var
AbstractRenderManager
=
exports
.
AbstractRenderManager
=
function
(
_AbstractManager
)
{
(
0
_emberBabel
.
inherits
)
(
AbstractRenderManager
_AbstractManager
)
;
function
AbstractRenderManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
AbstractRenderManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractManager
.
apply
(
this
arguments
)
)
;
}
AbstractRenderManager
.
prototype
.
layoutFor
=
function
layoutFor
(
definition
_bucket
env
)
{
(
true
&
&
!
(
!
!
definition
.
template
)
&
&
(
0
_emberDebug
.
assert
)
(
'
definition
is
missing
a
template
'
!
!
definition
.
template
)
)
;
return
env
.
getCompiledBlock
(
_outlet
.
OutletLayoutCompiler
definition
.
template
)
;
}
;
AbstractRenderManager
.
prototype
.
getSelf
=
function
getSelf
(
_ref
)
{
var
controller
=
_ref
.
controller
;
return
new
_references
.
RootReference
(
controller
)
;
}
;
return
AbstractRenderManager
;
}
(
_abstract
.
default
)
;
if
(
true
)
{
AbstractRenderManager
.
prototype
.
didRenderLayout
=
function
(
)
{
this
.
debugStack
.
pop
(
)
;
}
;
}
var
SingletonRenderManager
=
function
(
_AbstractRenderManage
)
{
(
0
_emberBabel
.
inherits
)
(
SingletonRenderManager
_AbstractRenderManage
)
;
function
SingletonRenderManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
SingletonRenderManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractRenderManage
.
apply
(
this
arguments
)
)
;
}
SingletonRenderManager
.
prototype
.
create
=
function
create
(
env
definition
_args
dynamicScope
)
{
var
name
=
definition
.
name
;
var
controller
=
env
.
owner
.
lookup
(
'
controller
:
'
+
name
)
|
|
(
0
_emberRouting
.
generateController
)
(
env
.
owner
name
)
;
if
(
true
)
{
this
.
_pushToDebugStack
(
'
controller
:
'
+
name
+
'
(
with
the
render
helper
)
'
env
)
;
}
if
(
dynamicScope
.
rootOutletState
)
{
dynamicScope
.
outletState
=
dynamicScope
.
rootOutletState
.
getOrphan
(
name
)
;
}
return
{
controller
:
controller
}
;
}
;
SingletonRenderManager
.
prototype
.
getDestructor
=
function
getDestructor
(
)
{
return
null
;
}
;
return
SingletonRenderManager
;
}
(
AbstractRenderManager
)
;
var
SINGLETON_RENDER_MANAGER
=
exports
.
SINGLETON_RENDER_MANAGER
=
new
SingletonRenderManager
(
)
;
var
NonSingletonRenderManager
=
function
(
_AbstractRenderManage2
)
{
(
0
_emberBabel
.
inherits
)
(
NonSingletonRenderManager
_AbstractRenderManage2
)
;
function
NonSingletonRenderManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
NonSingletonRenderManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractRenderManage2
.
apply
(
this
arguments
)
)
;
}
NonSingletonRenderManager
.
prototype
.
create
=
function
create
(
environment
definition
args
dynamicScope
)
{
var
name
=
definition
.
name
env
=
definition
.
env
;
var
modelRef
=
args
.
positional
.
at
(
0
)
;
var
controllerFactory
=
env
.
owner
.
factoryFor
(
'
controller
:
'
+
name
)
;
var
factory
=
controllerFactory
|
|
(
0
_emberRouting
.
generateControllerFactory
)
(
env
.
owner
name
)
;
var
controller
=
factory
.
create
(
{
model
:
modelRef
.
value
(
)
}
)
;
if
(
true
)
{
this
.
_pushToDebugStack
(
'
controller
:
'
+
name
+
'
(
with
the
render
helper
)
'
environment
)
;
}
if
(
dynamicScope
.
rootOutletState
)
{
dynamicScope
.
outletState
=
dynamicScope
.
rootOutletState
.
getOrphan
(
name
)
;
}
return
{
controller
:
controller
model
:
modelRef
}
;
}
;
NonSingletonRenderManager
.
prototype
.
update
=
function
update
(
_ref2
)
{
var
controller
=
_ref2
.
controller
model
=
_ref2
.
model
;
controller
.
set
(
'
model
'
model
.
value
(
)
)
;
}
;
NonSingletonRenderManager
.
prototype
.
getDestructor
=
function
getDestructor
(
_ref3
)
{
var
controller
=
_ref3
.
controller
;
return
controller
;
}
;
return
NonSingletonRenderManager
;
}
(
AbstractRenderManager
)
;
var
NON_SINGLETON_RENDER_MANAGER
=
exports
.
NON_SINGLETON_RENDER_MANAGER
=
new
NonSingletonRenderManager
(
)
;
var
RenderDefinition
=
exports
.
RenderDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
RenderDefinition
_ComponentDefinition
)
;
function
RenderDefinition
(
name
template
env
manager
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RenderDefinition
)
;
var
_this4
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
'
render
'
manager
null
)
)
;
_this4
.
name
=
name
;
_this4
.
template
=
template
;
_this4
.
env
=
env
;
return
_this4
;
}
return
RenderDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
root
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
metal
'
'
ember
-
glimmer
/
utils
/
curly
-
component
-
state
-
bucket
'
'
ember
-
glimmer
/
component
-
managers
/
curly
'
]
function
(
exports
_emberBabel
_runtime
_emberMetal
_curlyComponentStateBucket
_curly
)
{
'
use
strict
'
;
exports
.
RootComponentDefinition
=
undefined
;
var
RootComponentManager
=
function
(
_CurlyComponentManage
)
{
(
0
_emberBabel
.
inherits
)
(
RootComponentManager
_CurlyComponentManage
)
;
function
RootComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RootComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CurlyComponentManage
.
apply
(
this
arguments
)
)
;
}
RootComponentManager
.
prototype
.
create
=
function
create
(
environment
definition
args
dynamicScope
)
{
var
component
=
definition
.
ComponentClass
.
create
(
)
;
if
(
true
)
{
this
.
_pushToDebugStack
(
component
.
_debugContainerKey
environment
)
;
}
var
finalizer
=
(
0
_emberMetal
.
_instrumentStart
)
(
'
render
.
component
'
_curly
.
initialRenderInstrumentDetails
component
)
;
dynamicScope
.
view
=
component
;
if
(
component
.
tagName
=
=
=
'
'
)
{
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willRender
'
)
;
}
component
.
_transitionTo
(
'
hasElement
'
)
;
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willInsertElement
'
)
;
}
}
if
(
true
)
{
(
0
_curly
.
processComponentInitializationAssertions
)
(
component
{
}
)
;
}
return
new
_curlyComponentStateBucket
.
default
(
environment
component
args
.
named
.
capture
(
)
finalizer
)
;
}
;
return
RootComponentManager
;
}
(
_curly
.
default
)
;
var
ROOT_MANAGER
=
new
RootComponentManager
(
)
;
var
RootComponentDefinition
=
exports
.
RootComponentDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
RootComponentDefinition
_ComponentDefinition
)
;
function
RootComponentDefinition
(
instance
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RootComponentDefinition
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
'
-
root
'
ROOT_MANAGER
{
class
:
instance
.
constructor
create
:
function
(
)
{
return
instance
;
}
}
)
)
;
_this2
.
template
=
undefined
;
_this2
.
args
=
undefined
;
return
_this2
;
}
return
RootComponentDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
-
managers
/
template
-
only
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
]
function
(
exports
_emberBabel
_runtime
_abstract
)
{
'
use
strict
'
;
exports
.
TemplateOnlyComponentDefinition
=
undefined
;
var
TemplateOnlyComponentLayoutCompiler
=
function
(
)
{
function
TemplateOnlyComponentLayoutCompiler
(
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TemplateOnlyComponentLayoutCompiler
)
;
this
.
template
=
template
;
}
TemplateOnlyComponentLayoutCompiler
.
prototype
.
compile
=
function
compile
(
builder
)
{
builder
.
wrapLayout
(
this
.
template
)
;
}
;
return
TemplateOnlyComponentLayoutCompiler
;
}
(
)
;
TemplateOnlyComponentLayoutCompiler
.
id
=
'
template
-
only
'
;
var
TemplateOnlyComponentManager
=
function
(
_AbstractManager
)
{
(
0
_emberBabel
.
inherits
)
(
TemplateOnlyComponentManager
_AbstractManager
)
;
function
TemplateOnlyComponentManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TemplateOnlyComponentManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AbstractManager
.
apply
(
this
arguments
)
)
;
}
TemplateOnlyComponentManager
.
prototype
.
create
=
function
create
(
)
{
return
null
;
}
;
TemplateOnlyComponentManager
.
prototype
.
layoutFor
=
function
layoutFor
(
_ref
_
env
)
{
var
template
=
_ref
.
template
;
return
env
.
getCompiledBlock
(
TemplateOnlyComponentLayoutCompiler
template
)
;
}
;
TemplateOnlyComponentManager
.
prototype
.
getSelf
=
function
getSelf
(
)
{
return
_runtime
.
NULL_REFERENCE
;
}
;
TemplateOnlyComponentManager
.
prototype
.
getDestructor
=
function
getDestructor
(
)
{
return
null
;
}
;
return
TemplateOnlyComponentManager
;
}
(
_abstract
.
default
)
;
exports
.
default
=
TemplateOnlyComponentManager
;
var
MANAGER
=
new
TemplateOnlyComponentManager
(
)
;
var
TemplateOnlyComponentDefinition
=
exports
.
TemplateOnlyComponentDefinition
=
function
(
_ComponentDefinition
)
{
(
0
_emberBabel
.
inherits
)
(
TemplateOnlyComponentDefinition
_ComponentDefinition
)
;
function
TemplateOnlyComponentDefinition
(
name
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TemplateOnlyComponentDefinition
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ComponentDefinition
.
call
(
this
name
MANAGER
null
)
)
;
_this2
.
template
=
template
;
return
_this2
;
}
return
TemplateOnlyComponentDefinition
;
}
(
_runtime
.
ComponentDefinition
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
component
'
[
'
exports
'
'
glimmer
/
reference
'
'
glimmer
/
runtime
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
utils
'
'
ember
-
views
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_reference
_runtime
_emberDebug
_emberMetal
_emberRuntime
_emberUtils
_emberViews
_references
)
{
'
use
strict
'
;
exports
.
BOUNDS
=
exports
.
HAS_BLOCK
=
exports
.
IS_DISPATCHING_ATTRS
=
exports
.
ROOT_REF
=
exports
.
ARGS
=
exports
.
DIRTY_TAG
=
undefined
;
var
_CoreView
extend
;
var
DIRTY_TAG
=
exports
.
DIRTY_TAG
=
(
0
_emberUtils
.
symbol
)
(
'
DIRTY_TAG
'
)
;
var
ARGS
=
exports
.
ARGS
=
(
0
_emberUtils
.
symbol
)
(
'
ARGS
'
)
;
var
ROOT_REF
=
exports
.
ROOT_REF
=
(
0
_emberUtils
.
symbol
)
(
'
ROOT_REF
'
)
;
var
IS_DISPATCHING_ATTRS
=
exports
.
IS_DISPATCHING_ATTRS
=
(
0
_emberUtils
.
symbol
)
(
'
IS_DISPATCHING_ATTRS
'
)
;
var
HAS_BLOCK
=
exports
.
HAS_BLOCK
=
(
0
_emberUtils
.
symbol
)
(
'
HAS_BLOCK
'
)
;
var
BOUNDS
=
exports
.
BOUNDS
=
(
0
_emberUtils
.
symbol
)
(
'
BOUNDS
'
)
;
var
Component
=
_emberViews
.
CoreView
.
extend
(
_emberViews
.
ChildViewsSupport
_emberViews
.
ViewStateSupport
_emberViews
.
ClassNamesSupport
_emberRuntime
.
TargetActionSupport
_emberViews
.
ActionSupport
_emberViews
.
ViewMixin
(
_CoreView
extend
=
{
isComponent
:
true
init
:
function
(
)
{
var
_this
=
this
;
this
.
_super
.
apply
(
this
arguments
)
;
this
[
IS_DISPATCHING_ATTRS
]
=
false
;
this
[
DIRTY_TAG
]
=
new
_reference
.
DirtyableTag
(
)
;
this
[
ROOT_REF
]
=
new
_references
.
RootReference
(
this
)
;
this
[
BOUNDS
]
=
null
;
(
true
&
&
!
(
this
.
tagName
!
=
=
'
'
|
|
!
this
.
renderer
.
_destinedForDOM
|
|
!
function
(
)
{
var
eventDispatcher
=
(
0
_emberUtils
.
getOwner
)
(
_this
)
.
lookup
(
'
event_dispatcher
:
main
'
)
;
var
events
=
eventDispatcher
&
&
eventDispatcher
.
_finalEvents
|
|
{
}
;
for
(
var
key
in
events
)
{
var
methodName
=
events
[
key
]
;
if
(
typeof
_this
[
methodName
]
=
=
=
'
function
'
)
{
return
true
;
}
}
return
false
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
can
not
define
a
function
that
handles
DOM
events
in
the
'
+
this
+
'
tagless
component
since
it
doesn
\
'
t
have
any
DOM
element
.
'
this
.
tagName
!
=
=
'
'
|
|
!
this
.
renderer
.
_destinedForDOM
|
|
!
function
(
)
{
var
eventDispatcher
=
(
0
_emberUtils
.
getOwner
)
(
_this
)
.
lookup
(
'
event_dispatcher
:
main
'
)
;
var
events
=
eventDispatcher
&
&
eventDispatcher
.
_finalEvents
|
|
{
}
;
for
(
var
key
in
events
)
{
var
methodName
=
events
[
key
]
;
if
(
typeof
_this
[
methodName
]
=
=
=
'
function
'
)
{
return
true
;
}
}
return
false
;
}
(
)
)
)
;
}
rerender
:
function
(
)
{
this
[
DIRTY_TAG
]
.
dirty
(
)
;
this
.
_super
(
)
;
}
__defineNonEnumerable
:
function
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
}
_CoreView
extend
[
_emberMetal
.
PROPERTY_DID_CHANGE
]
=
function
(
key
)
{
if
(
this
[
IS_DISPATCHING_ATTRS
]
)
{
return
;
}
var
args
=
this
[
ARGS
]
;
var
reference
=
args
&
&
args
[
key
]
;
if
(
reference
)
{
if
(
reference
[
_references
.
UPDATE
]
)
{
reference
[
_references
.
UPDATE
]
(
(
0
_emberMetal
.
get
)
(
this
key
)
)
;
}
}
}
_CoreView
extend
.
getAttr
=
function
(
key
)
{
return
this
.
get
(
key
)
;
}
_CoreView
extend
.
readDOMAttr
=
function
(
name
)
{
var
element
=
(
0
_emberViews
.
getViewElement
)
(
this
)
;
return
(
0
_runtime
.
readDOMAttr
)
(
element
name
)
;
}
_CoreView
extend
)
)
;
Component
[
_emberUtils
.
NAME_KEY
]
=
'
Ember
.
Component
'
;
Component
.
reopenClass
(
{
isComponentFactory
:
true
positionalParams
:
[
]
}
)
;
exports
.
default
=
Component
;
}
)
;
enifed
(
'
ember
-
glimmer
/
components
/
checkbox
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
templates
/
empty
'
]
function
(
exports
_emberMetal
_component
_empty
)
{
'
use
strict
'
;
exports
.
default
=
_component
.
default
.
extend
(
{
layout
:
_empty
.
default
classNames
:
[
'
ember
-
checkbox
'
]
tagName
:
'
input
'
attributeBindings
:
[
'
type
'
'
checked
'
'
indeterminate
'
'
disabled
'
'
tabindex
'
'
name
'
'
autofocus
'
'
required
'
'
form
'
]
type
:
'
checkbox
'
disabled
:
false
indeterminate
:
false
didInsertElement
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
0
_emberMetal
.
get
)
(
this
'
element
'
)
.
indeterminate
=
!
!
(
0
_emberMetal
.
get
)
(
this
'
indeterminate
'
)
;
}
change
:
function
(
)
{
(
0
_emberMetal
.
set
)
(
this
'
checked
'
this
.
(
)
.
prop
(
'
checked
'
)
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
components
/
link
-
to
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
templates
/
link
-
to
'
]
function
(
exports
_emberDebug
_emberMetal
_emberRuntime
_emberViews
_component
_linkTo
)
{
'
use
strict
'
;
var
LinkComponent
=
_component
.
default
.
extend
(
{
layout
:
_linkTo
.
default
tagName
:
'
a
'
'
current
-
when
'
:
null
title
:
null
rel
:
null
tabindex
:
null
target
:
null
activeClass
:
'
active
'
loadingClass
:
'
loading
'
disabledClass
:
'
disabled
'
replace
:
false
attributeBindings
:
[
'
href
'
'
title
'
'
rel
'
'
tabindex
'
'
target
'
]
classNameBindings
:
[
'
active
'
'
loading
'
'
disabled
'
'
transitioningIn
'
'
transitioningOut
'
]
eventName
:
'
click
'
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
eventName
=
(
0
_emberMetal
.
get
)
(
this
'
eventName
'
)
;
this
.
on
(
eventName
this
this
.
_invoke
)
;
}
_routing
:
_emberRuntime
.
inject
.
service
(
'
-
routing
'
)
disabled
:
(
0
_emberMetal
.
computed
)
(
{
get
:
function
(
_key
)
{
return
false
;
}
set
:
function
(
_key
value
)
{
this
.
_isDisabled
=
value
;
return
value
?
(
0
_emberMetal
.
get
)
(
this
'
disabledClass
'
)
:
false
;
}
}
)
_isActive
:
function
(
routerState
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
loading
'
)
)
{
return
false
;
}
var
currentWhen
=
(
0
_emberMetal
.
get
)
(
this
'
current
-
when
'
)
;
if
(
typeof
currentWhen
=
=
=
'
boolean
'
)
{
return
currentWhen
;
}
var
isCurrentWhenSpecified
=
!
!
currentWhen
;
currentWhen
=
currentWhen
|
|
(
0
_emberMetal
.
get
)
(
this
'
qualifiedRouteName
'
)
;
currentWhen
=
currentWhen
.
split
(
'
'
)
;
var
routing
=
(
0
_emberMetal
.
get
)
(
this
'
_routing
'
)
;
var
models
=
(
0
_emberMetal
.
get
)
(
this
'
models
'
)
;
var
resolvedQueryParams
=
(
0
_emberMetal
.
get
)
(
this
'
resolvedQueryParams
'
)
;
for
(
var
i
=
0
;
i
<
currentWhen
.
length
;
i
+
+
)
{
if
(
routing
.
isActiveForRoute
(
models
resolvedQueryParams
currentWhen
[
i
]
routerState
isCurrentWhenSpecified
)
)
{
return
true
;
}
}
return
false
;
}
active
:
(
0
_emberMetal
.
computed
)
(
'
activeClass
'
'
_active
'
function
computeLinkToComponentActiveClass
(
)
{
return
this
.
get
(
'
_active
'
)
?
(
0
_emberMetal
.
get
)
(
this
'
activeClass
'
)
:
false
;
}
)
_active
:
(
0
_emberMetal
.
computed
)
(
'
_routing
.
currentState
'
'
attrs
.
params
'
function
computeLinkToComponentActive
(
)
{
var
currentState
=
(
0
_emberMetal
.
get
)
(
this
'
_routing
.
currentState
'
)
;
if
(
!
currentState
)
{
return
false
;
}
return
this
.
_isActive
(
currentState
)
;
}
)
willBeActive
:
(
0
_emberMetal
.
computed
)
(
'
_routing
.
targetState
'
function
computeLinkToComponentWillBeActive
(
)
{
var
routing
=
(
0
_emberMetal
.
get
)
(
this
'
_routing
'
)
;
var
targetState
=
(
0
_emberMetal
.
get
)
(
routing
'
targetState
'
)
;
if
(
(
0
_emberMetal
.
get
)
(
routing
'
currentState
'
)
=
=
=
targetState
)
{
return
;
}
return
this
.
_isActive
(
targetState
)
;
}
)
transitioningIn
:
(
0
_emberMetal
.
computed
)
(
'
active
'
'
willBeActive
'
function
computeLinkToComponentTransitioningIn
(
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
willBeActive
'
)
=
=
=
true
&
&
!
(
0
_emberMetal
.
get
)
(
this
'
_active
'
)
)
{
return
'
ember
-
transitioning
-
in
'
;
}
else
{
return
false
;
}
}
)
transitioningOut
:
(
0
_emberMetal
.
computed
)
(
'
active
'
'
willBeActive
'
function
computeLinkToComponentTransitioningOut
(
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
willBeActive
'
)
=
=
=
false
&
&
(
0
_emberMetal
.
get
)
(
this
'
_active
'
)
)
{
return
'
ember
-
transitioning
-
out
'
;
}
else
{
return
false
;
}
}
)
_invoke
:
function
(
event
)
{
if
(
!
(
0
_emberViews
.
isSimpleClick
)
(
event
)
)
{
return
true
;
}
var
preventDefault
=
(
0
_emberMetal
.
get
)
(
this
'
preventDefault
'
)
;
var
targetAttribute
=
(
0
_emberMetal
.
get
)
(
this
'
target
'
)
;
if
(
preventDefault
!
=
=
false
)
{
if
(
!
targetAttribute
|
|
targetAttribute
=
=
=
'
_self
'
)
{
event
.
preventDefault
(
)
;
}
}
if
(
(
0
_emberMetal
.
get
)
(
this
'
bubbles
'
)
=
=
=
false
)
{
event
.
stopPropagation
(
)
;
}
if
(
this
.
_isDisabled
)
{
return
false
;
}
if
(
(
0
_emberMetal
.
get
)
(
this
'
loading
'
)
)
{
(
true
&
&
(
0
_emberDebug
.
warn
)
(
'
This
link
-
to
is
in
an
inactive
loading
state
because
at
least
one
of
its
parameters
presently
has
a
null
/
undefined
value
or
the
provided
route
name
is
invalid
.
'
false
)
)
;
return
false
;
}
if
(
targetAttribute
&
&
targetAttribute
!
=
=
'
_self
'
)
{
return
false
;
}
var
qualifiedRouteName
=
(
0
_emberMetal
.
get
)
(
this
'
qualifiedRouteName
'
)
;
var
models
=
(
0
_emberMetal
.
get
)
(
this
'
models
'
)
;
var
queryParams
=
(
0
_emberMetal
.
get
)
(
this
'
queryParams
.
values
'
)
;
var
shouldReplace
=
(
0
_emberMetal
.
get
)
(
this
'
replace
'
)
;
var
payload
=
{
queryParams
:
queryParams
routeName
:
qualifiedRouteName
}
;
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
link
-
to
'
payload
this
.
_generateTransition
(
payload
qualifiedRouteName
models
queryParams
shouldReplace
)
)
;
return
false
;
}
_generateTransition
:
function
(
payload
qualifiedRouteName
models
queryParams
shouldReplace
)
{
var
routing
=
(
0
_emberMetal
.
get
)
(
this
'
_routing
'
)
;
return
function
(
)
{
payload
.
transition
=
routing
.
transitionTo
(
qualifiedRouteName
models
queryParams
shouldReplace
)
;
}
;
}
queryParams
:
null
qualifiedRouteName
:
(
0
_emberMetal
.
computed
)
(
'
targetRouteName
'
'
_routing
.
currentState
'
function
computeLinkToComponentQualifiedRouteName
(
)
{
var
params
=
(
0
_emberMetal
.
get
)
(
this
'
params
'
)
;
var
paramsLength
=
params
.
length
;
var
lastParam
=
params
[
paramsLength
-
1
]
;
if
(
lastParam
&
&
lastParam
.
isQueryParams
)
{
paramsLength
-
-
;
}
var
onlyQueryParamsSupplied
=
this
[
_component
.
HAS_BLOCK
]
?
paramsLength
=
=
=
0
:
paramsLength
=
=
=
1
;
if
(
onlyQueryParamsSupplied
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
_routing
.
currentRouteName
'
)
;
}
return
(
0
_emberMetal
.
get
)
(
this
'
targetRouteName
'
)
;
}
)
resolvedQueryParams
:
(
0
_emberMetal
.
computed
)
(
'
queryParams
'
function
computeLinkToComponentResolvedQueryParams
(
)
{
var
resolvedQueryParams
=
{
}
;
var
queryParams
=
(
0
_emberMetal
.
get
)
(
this
'
queryParams
'
)
;
if
(
!
queryParams
)
{
return
resolvedQueryParams
;
}
var
values
=
queryParams
.
values
;
for
(
var
key
in
values
)
{
if
(
!
values
.
hasOwnProperty
(
key
)
)
{
continue
;
}
resolvedQueryParams
[
key
]
=
values
[
key
]
;
}
return
resolvedQueryParams
;
}
)
href
:
(
0
_emberMetal
.
computed
)
(
'
models
'
'
qualifiedRouteName
'
function
computeLinkToComponentHref
(
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
tagName
'
)
!
=
=
'
a
'
)
{
return
;
}
var
qualifiedRouteName
=
(
0
_emberMetal
.
get
)
(
this
'
qualifiedRouteName
'
)
;
var
models
=
(
0
_emberMetal
.
get
)
(
this
'
models
'
)
;
if
(
(
0
_emberMetal
.
get
)
(
this
'
loading
'
)
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
loadingHref
'
)
;
}
var
routing
=
(
0
_emberMetal
.
get
)
(
this
'
_routing
'
)
;
var
queryParams
=
(
0
_emberMetal
.
get
)
(
this
'
queryParams
.
values
'
)
;
if
(
true
)
{
try
{
routing
.
generateURL
(
qualifiedRouteName
models
queryParams
)
;
}
catch
(
e
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
attempted
to
define
a
{
{
link
-
to
"
'
+
qualifiedRouteName
+
'
"
}
}
but
did
not
pass
the
parameters
required
for
generating
its
dynamic
segments
.
'
+
e
.
message
)
)
;
}
}
return
routing
.
generateURL
(
qualifiedRouteName
models
queryParams
)
;
}
)
loading
:
(
0
_emberMetal
.
computed
)
(
'
_modelsAreLoaded
'
'
qualifiedRouteName
'
function
computeLinkToComponentLoading
(
)
{
var
qualifiedRouteName
=
(
0
_emberMetal
.
get
)
(
this
'
qualifiedRouteName
'
)
;
var
modelsAreLoaded
=
(
0
_emberMetal
.
get
)
(
this
'
_modelsAreLoaded
'
)
;
if
(
!
modelsAreLoaded
|
|
qualifiedRouteName
=
=
=
null
|
|
qualifiedRouteName
=
=
=
undefined
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
loadingClass
'
)
;
}
}
)
_modelsAreLoaded
:
(
0
_emberMetal
.
computed
)
(
'
models
'
function
computeLinkToComponentModelsAreLoaded
(
)
{
var
models
=
(
0
_emberMetal
.
get
)
(
this
'
models
'
)
;
for
(
var
i
=
0
;
i
<
models
.
length
;
i
+
+
)
{
var
model
=
models
[
i
]
;
if
(
model
=
=
=
null
|
|
model
=
=
=
undefined
)
{
return
false
;
}
}
return
true
;
}
)
_getModels
:
function
(
params
)
{
var
modelCount
=
params
.
length
-
1
;
var
models
=
new
Array
(
modelCount
)
;
for
(
var
i
=
0
;
i
<
modelCount
;
i
+
+
)
{
var
value
=
params
[
i
+
1
]
;
models
[
i
]
=
value
;
}
return
models
;
}
loadingHref
:
'
#
'
didReceiveAttrs
:
function
(
)
{
var
queryParams
=
void
0
;
var
params
=
(
0
_emberMetal
.
get
)
(
this
'
params
'
)
;
if
(
params
)
{
params
=
params
.
slice
(
)
;
}
(
true
&
&
!
(
params
&
&
params
.
length
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
must
provide
one
or
more
parameters
to
the
link
-
to
component
.
'
params
&
&
params
.
length
)
)
;
var
disabledWhen
=
(
0
_emberMetal
.
get
)
(
this
'
disabledWhen
'
)
;
if
(
disabledWhen
!
=
=
undefined
)
{
this
.
set
(
'
disabled
'
disabledWhen
)
;
}
if
(
!
this
[
_component
.
HAS_BLOCK
]
)
{
this
.
set
(
'
linkTitle
'
params
.
shift
(
)
)
;
}
this
.
set
(
'
targetRouteName
'
params
[
0
]
)
;
var
lastParam
=
params
[
params
.
length
-
1
]
;
if
(
lastParam
&
&
lastParam
.
isQueryParams
)
{
queryParams
=
params
.
pop
(
)
;
}
else
{
queryParams
=
{
values
:
{
}
}
;
}
this
.
set
(
'
queryParams
'
queryParams
)
;
if
(
params
.
length
>
1
)
{
this
.
set
(
'
models
'
this
.
_getModels
(
params
)
)
;
}
else
{
this
.
set
(
'
models
'
[
]
)
;
}
}
}
)
;
LinkComponent
.
toString
=
function
(
)
{
return
'
LinkComponent
'
;
}
;
LinkComponent
.
reopenClass
(
{
positionalParams
:
'
params
'
}
)
;
exports
.
default
=
LinkComponent
;
}
)
;
enifed
(
'
ember
-
glimmer
/
components
/
text_area
'
[
'
exports
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
templates
/
empty
'
]
function
(
exports
_emberViews
_component
_empty
)
{
'
use
strict
'
;
exports
.
default
=
_component
.
default
.
extend
(
_emberViews
.
TextSupport
{
classNames
:
[
'
ember
-
text
-
area
'
]
layout
:
_empty
.
default
tagName
:
'
textarea
'
attributeBindings
:
[
'
rows
'
'
cols
'
'
name
'
'
selectionEnd
'
'
selectionStart
'
'
wrap
'
'
lang
'
'
dir
'
'
value
'
]
rows
:
null
cols
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
components
/
text_field
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
metal
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
templates
/
empty
'
]
function
(
exports
_emberEnvironment
_emberMetal
_emberViews
_component
_empty
)
{
'
use
strict
'
;
var
inputTypes
=
Object
.
create
(
null
)
;
function
canSetTypeOfInput
(
type
)
{
if
(
type
in
inputTypes
)
{
return
inputTypes
[
type
]
;
}
if
(
!
_emberEnvironment
.
environment
.
hasDOM
)
{
inputTypes
[
type
]
=
type
;
return
type
;
}
var
inputTypeTestElement
=
document
.
createElement
(
'
input
'
)
;
try
{
inputTypeTestElement
.
type
=
type
;
}
catch
(
e
)
{
}
return
inputTypes
[
type
]
=
inputTypeTestElement
.
type
=
=
=
type
;
}
exports
.
default
=
_component
.
default
.
extend
(
_emberViews
.
TextSupport
{
layout
:
_empty
.
default
classNames
:
[
'
ember
-
text
-
field
'
]
tagName
:
'
input
'
attributeBindings
:
[
'
accept
'
'
autocomplete
'
'
autosave
'
'
dir
'
'
formaction
'
'
formenctype
'
'
formmethod
'
'
formnovalidate
'
'
formtarget
'
'
height
'
'
inputmode
'
'
lang
'
'
list
'
'
type
'
'
max
'
'
min
'
'
multiple
'
'
name
'
'
pattern
'
'
size
'
'
step
'
'
value
'
'
width
'
]
value
:
'
'
type
:
(
0
_emberMetal
.
computed
)
(
{
get
:
function
(
)
{
return
'
text
'
;
}
set
:
function
(
_key
value
)
{
var
type
=
'
text
'
;
if
(
canSetTypeOfInput
(
value
)
)
{
type
=
value
;
}
return
type
;
}
}
)
size
:
null
pattern
:
null
min
:
null
max
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
dom
'
[
'
exports
'
'
glimmer
/
runtime
'
'
glimmer
/
node
'
]
function
(
exports
_runtime
_node
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
DOMChanges
'
{
enumerable
:
true
get
:
function
(
)
{
return
_runtime
.
DOMChanges
;
}
}
)
;
Object
.
defineProperty
(
exports
'
DOMTreeConstruction
'
{
enumerable
:
true
get
:
function
(
)
{
return
_runtime
.
DOMTreeConstruction
;
}
}
)
;
Object
.
defineProperty
(
exports
'
NodeDOMTreeConstruction
'
{
enumerable
:
true
get
:
function
(
)
{
return
_node
.
NodeDOMTreeConstruction
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
environment
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
-
managers
/
curly
'
'
ember
-
glimmer
/
component
-
managers
/
template
-
only
'
'
ember
-
glimmer
/
syntax
'
'
ember
-
glimmer
/
utils
/
debug
-
stack
'
'
ember
-
glimmer
/
utils
/
iterable
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
helpers
/
-
class
'
'
ember
-
glimmer
/
helpers
/
-
html
-
safe
'
'
ember
-
glimmer
/
helpers
/
-
input
-
type
'
'
ember
-
glimmer
/
helpers
/
-
normalize
-
class
'
'
ember
-
glimmer
/
helpers
/
action
'
'
ember
-
glimmer
/
helpers
/
component
'
'
ember
-
glimmer
/
helpers
/
concat
'
'
ember
-
glimmer
/
helpers
/
each
-
in
'
'
ember
-
glimmer
/
helpers
/
get
'
'
ember
-
glimmer
/
helpers
/
hash
'
'
ember
-
glimmer
/
helpers
/
if
-
unless
'
'
ember
-
glimmer
/
helpers
/
log
'
'
ember
-
glimmer
/
helpers
/
mut
'
'
ember
-
glimmer
/
helpers
/
query
-
param
'
'
ember
-
glimmer
/
helpers
/
readonly
'
'
ember
-
glimmer
/
helpers
/
unbound
'
'
ember
-
glimmer
/
modifiers
/
action
'
'
ember
-
glimmer
/
protocol
-
for
-
url
'
'
ember
/
features
'
]
function
(
exports
_emberBabel
_runtime
_emberDebug
_emberMetal
_emberUtils
_emberViews
_curly
_templateOnly
_syntax
_debugStack
_iterable
_references
_class
_htmlSafe
_inputType
_normalizeClass
_action
_component
_concat
_eachIn
_get
_hash
_ifUnless
_log
_mut
_queryParam
_readonly
_unbound
_action2
_protocolForUrl
_features
)
{
'
use
strict
'
;
function
instrumentationPayload
(
name
)
{
return
{
object
:
'
component
:
'
+
name
}
;
}
function
isTemplateFactory
(
template
)
{
return
typeof
template
.
create
=
=
=
'
function
'
;
}
var
Environment
=
function
(
_GlimmerEnvironment
)
{
(
0
_emberBabel
.
inherits
)
(
Environment
_GlimmerEnvironment
)
;
Environment
.
create
=
function
create
(
options
)
{
return
new
this
(
options
)
;
}
;
function
Environment
(
injections
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
Environment
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_GlimmerEnvironment
.
call
(
this
injections
)
)
;
_this
.
owner
=
injections
[
_emberUtils
.
OWNER
]
;
_this
.
isInteractive
=
_this
.
owner
.
lookup
(
'
-
environment
:
main
'
)
.
isInteractive
;
_this
.
destroyedComponents
=
[
]
;
(
0
_protocolForUrl
.
default
)
(
_this
)
;
_this
.
_definitionCache
=
new
_emberMetal
.
Cache
(
2000
function
(
_ref
)
{
var
name
=
_ref
.
name
source
=
_ref
.
source
owner
=
_ref
.
owner
;
var
_lookupComponent
=
(
0
_emberViews
.
lookupComponent
)
(
owner
name
{
source
:
source
}
)
componentFactory
=
_lookupComponent
.
component
layout
=
_lookupComponent
.
layout
;
var
customManager
=
void
0
;
if
(
_features
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
&
&
layout
&
&
!
componentFactory
)
{
return
new
_templateOnly
.
TemplateOnlyComponentDefinition
(
name
layout
)
;
}
else
if
(
componentFactory
|
|
layout
)
{
if
(
_features
.
GLIMMER_CUSTOM_COMPONENT_MANAGER
)
{
var
managerId
=
layout
&
&
layout
.
meta
.
managerId
;
if
(
managerId
)
{
customManager
=
owner
.
factoryFor
(
'
component
-
manager
:
'
+
managerId
)
.
class
;
}
}
return
new
_curly
.
CurlyComponentDefinition
(
name
componentFactory
layout
undefined
customManager
)
;
}
return
undefined
;
}
function
(
_ref2
)
{
var
name
=
_ref2
.
name
source
=
_ref2
.
source
owner
=
_ref2
.
owner
;
var
expandedName
=
source
&
&
_this
.
_resolveLocalLookupName
(
name
source
owner
)
|
|
name
;
var
ownerGuid
=
(
0
_emberUtils
.
guidFor
)
(
owner
)
;
return
ownerGuid
+
'
|
'
+
expandedName
;
}
)
;
_this
.
_templateCache
=
new
_emberMetal
.
Cache
(
1000
function
(
_ref3
)
{
var
Template
=
_ref3
.
Template
owner
=
_ref3
.
owner
;
if
(
isTemplateFactory
(
Template
)
)
{
var
_Template
create
;
return
Template
.
create
(
(
_Template
create
=
{
env
:
_this
}
_Template
create
[
_emberUtils
.
OWNER
]
=
owner
_Template
create
)
)
;
}
else
{
return
Template
;
}
}
function
(
_ref4
)
{
var
Template
=
_ref4
.
Template
owner
=
_ref4
.
owner
;
return
(
0
_emberUtils
.
guidFor
)
(
owner
)
+
'
|
'
+
Template
.
id
;
}
)
;
_this
.
_compilerCache
=
new
_emberMetal
.
Cache
(
10
function
(
Compiler
)
{
return
new
_emberMetal
.
Cache
(
2000
function
(
template
)
{
var
compilable
=
new
Compiler
(
template
)
;
return
(
0
_runtime
.
compileLayout
)
(
compilable
_this
)
;
}
function
(
template
)
{
var
owner
=
template
.
meta
.
owner
;
return
(
0
_emberUtils
.
guidFor
)
(
owner
)
+
'
|
'
+
template
.
id
;
}
)
;
}
function
(
Compiler
)
{
return
Compiler
.
id
;
}
)
;
_this
.
builtInModifiers
=
{
action
:
new
_action2
.
default
(
)
}
;
_this
.
builtInHelpers
=
{
'
if
'
:
_ifUnless
.
inlineIf
action
:
_action
.
default
concat
:
_concat
.
default
get
:
_get
.
default
hash
:
_hash
.
default
log
:
_log
.
default
mut
:
_mut
.
default
'
query
-
params
'
:
_queryParam
.
default
readonly
:
_readonly
.
default
unbound
:
_unbound
.
default
'
unless
'
:
_ifUnless
.
inlineUnless
'
-
class
'
:
_class
.
default
'
-
each
-
in
'
:
_eachIn
.
default
'
-
input
-
type
'
:
_inputType
.
default
'
-
normalize
-
class
'
:
_normalizeClass
.
default
'
-
html
-
safe
'
:
_htmlSafe
.
default
'
-
get
-
dynamic
-
var
'
:
_runtime
.
getDynamicVar
}
;
if
(
true
)
{
_this
.
debugStack
=
new
_debugStack
.
default
(
)
;
}
return
_this
;
}
Environment
.
prototype
.
protocolForURL
=
function
protocolForURL
(
s
)
{
return
s
;
}
;
Environment
.
prototype
.
_resolveLocalLookupName
=
function
_resolveLocalLookupName
(
name
source
owner
)
{
return
_features
.
EMBER_MODULE_UNIFICATION
?
source
+
'
:
'
+
name
:
owner
.
_resolveLocalLookupName
(
name
source
)
;
}
;
Environment
.
prototype
.
macros
=
function
macros
(
)
{
var
macros
=
_GlimmerEnvironment
.
prototype
.
macros
.
call
(
this
)
;
(
0
_syntax
.
populateMacros
)
(
macros
.
blocks
macros
.
inlines
)
;
return
macros
;
}
;
Environment
.
prototype
.
hasComponentDefinition
=
function
hasComponentDefinition
(
)
{
return
false
;
}
;
Environment
.
prototype
.
getComponentDefinition
=
function
getComponentDefinition
(
name
_ref5
)
{
var
owner
=
_ref5
.
owner
moduleName
=
_ref5
.
moduleName
;
var
finalizer
=
(
0
_emberMetal
.
_instrumentStart
)
(
'
render
.
getComponentDefinition
'
instrumentationPayload
name
)
;
var
source
=
moduleName
&
&
'
template
:
'
+
moduleName
;
var
definition
=
this
.
_definitionCache
.
get
(
{
name
:
name
source
:
source
owner
:
owner
}
)
;
finalizer
(
)
;
return
definition
;
}
;
Environment
.
prototype
.
getTemplate
=
function
getTemplate
(
Template
owner
)
{
return
this
.
_templateCache
.
get
(
{
Template
:
Template
owner
:
owner
}
)
;
}
;
Environment
.
prototype
.
getCompiledBlock
=
function
getCompiledBlock
(
Compiler
template
)
{
var
compilerCache
=
this
.
_compilerCache
.
get
(
Compiler
)
;
return
compilerCache
.
get
(
template
)
;
}
;
Environment
.
prototype
.
hasPartial
=
function
hasPartial
(
name
meta
)
{
return
(
0
_emberViews
.
hasPartial
)
(
name
meta
.
owner
)
;
}
;
Environment
.
prototype
.
lookupPartial
=
function
lookupPartial
(
name
meta
)
{
var
partial
=
{
name
:
name
template
:
(
0
_emberViews
.
lookupPartial
)
(
name
meta
.
owner
)
}
;
if
(
partial
.
template
)
{
return
partial
;
}
else
{
throw
new
Error
(
name
+
'
is
not
a
partial
'
)
;
}
}
;
Environment
.
prototype
.
hasHelper
=
function
hasHelper
(
name
_ref6
)
{
var
owner
=
_ref6
.
owner
moduleName
=
_ref6
.
moduleName
;
if
(
name
=
=
=
'
component
'
|
|
this
.
builtInHelpers
[
name
]
)
{
return
true
;
}
var
options
=
{
source
:
'
template
:
'
+
moduleName
}
;
return
owner
.
hasRegistration
(
'
helper
:
'
+
name
options
)
|
|
owner
.
hasRegistration
(
'
helper
:
'
+
name
)
;
}
;
Environment
.
prototype
.
lookupHelper
=
function
lookupHelper
(
name
meta
)
{
if
(
name
=
=
=
'
component
'
)
{
return
function
(
vm
args
)
{
return
(
0
_component
.
default
)
(
vm
args
meta
)
;
}
;
}
var
owner
=
meta
.
owner
moduleName
=
meta
.
moduleName
;
var
helper
=
this
.
builtInHelpers
[
name
]
;
if
(
helper
)
{
return
helper
;
}
var
options
=
moduleName
&
&
{
source
:
'
template
:
'
+
moduleName
}
|
|
{
}
;
var
helperFactory
=
owner
.
factoryFor
(
'
helper
:
'
+
name
options
)
|
|
owner
.
factoryFor
(
'
helper
:
'
+
name
)
;
var
HelperReference
=
void
0
;
if
(
helperFactory
.
class
.
isSimpleHelperFactory
)
{
HelperReference
=
_references
.
SimpleHelperReference
;
}
else
if
(
helperFactory
.
class
.
isHelperFactory
)
{
HelperReference
=
_references
.
ClassBasedHelperReference
;
}
else
{
throw
new
Error
(
name
+
'
is
not
a
helper
'
)
;
}
return
function
(
vm
args
)
{
return
HelperReference
.
create
(
helperFactory
vm
args
.
capture
(
)
)
;
}
;
}
;
Environment
.
prototype
.
hasModifier
=
function
hasModifier
(
name
)
{
return
!
!
this
.
builtInModifiers
[
name
]
;
}
;
Environment
.
prototype
.
lookupModifier
=
function
lookupModifier
(
name
)
{
var
modifier
=
this
.
builtInModifiers
[
name
]
;
if
(
modifier
)
{
return
modifier
;
}
else
{
throw
new
Error
(
name
+
'
is
not
a
modifier
'
)
;
}
}
;
Environment
.
prototype
.
toConditionalReference
=
function
toConditionalReference
(
reference
)
{
return
_references
.
ConditionalReference
.
create
(
reference
)
;
}
;
Environment
.
prototype
.
iterableFor
=
function
iterableFor
(
ref
key
)
{
return
(
0
_iterable
.
default
)
(
ref
key
)
;
}
;
Environment
.
prototype
.
scheduleInstallModifier
=
function
scheduleInstallModifier
(
modifier
manager
)
{
if
(
this
.
isInteractive
)
{
_GlimmerEnvironment
.
prototype
.
scheduleInstallModifier
.
call
(
this
modifier
manager
)
;
}
}
;
Environment
.
prototype
.
scheduleUpdateModifier
=
function
scheduleUpdateModifier
(
modifier
manager
)
{
if
(
this
.
isInteractive
)
{
_GlimmerEnvironment
.
prototype
.
scheduleUpdateModifier
.
call
(
this
modifier
manager
)
;
}
}
;
Environment
.
prototype
.
didDestroy
=
function
didDestroy
(
destroyable
)
{
destroyable
.
destroy
(
)
;
}
;
Environment
.
prototype
.
begin
=
function
begin
(
)
{
this
.
inTransaction
=
true
;
_GlimmerEnvironment
.
prototype
.
begin
.
call
(
this
)
;
}
;
Environment
.
prototype
.
commit
=
function
commit
(
)
{
var
destroyedComponents
=
this
.
destroyedComponents
;
this
.
destroyedComponents
=
[
]
;
for
(
var
i
=
0
;
i
<
destroyedComponents
.
length
;
i
+
+
)
{
destroyedComponents
[
i
]
.
destroy
(
)
;
}
_GlimmerEnvironment
.
prototype
.
commit
.
call
(
this
)
;
this
.
inTransaction
=
false
;
}
;
return
Environment
;
}
(
_runtime
.
Environment
)
;
exports
.
default
=
Environment
;
if
(
true
)
{
var
StyleAttributeManager
=
function
(
_AttributeManager
)
{
(
0
_emberBabel
.
inherits
)
(
StyleAttributeManager
_AttributeManager
)
;
function
StyleAttributeManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
StyleAttributeManager
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_AttributeManager
.
apply
(
this
arguments
)
)
;
}
StyleAttributeManager
.
prototype
.
setAttribute
=
function
setAttribute
(
dom
element
value
)
{
(
true
&
&
(
0
_emberDebug
.
warn
)
(
(
0
_emberViews
.
constructStyleDeprecationMessage
)
(
value
)
function
(
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
|
|
(
0
_runtime
.
isSafeString
)
(
value
)
)
{
return
true
;
}
return
false
;
}
(
)
{
id
:
'
ember
-
htmlbars
.
style
-
xss
-
warning
'
}
)
)
;
_AttributeManager
.
prototype
.
setAttribute
.
call
(
this
dom
element
value
)
;
}
;
StyleAttributeManager
.
prototype
.
updateAttribute
=
function
updateAttribute
(
dom
element
value
)
{
(
true
&
&
(
0
_emberDebug
.
warn
)
(
(
0
_emberViews
.
constructStyleDeprecationMessage
)
(
value
)
function
(
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
|
|
(
0
_runtime
.
isSafeString
)
(
value
)
)
{
return
true
;
}
return
false
;
}
(
)
{
id
:
'
ember
-
htmlbars
.
style
-
xss
-
warning
'
}
)
)
;
_AttributeManager
.
prototype
.
updateAttribute
.
call
(
this
dom
element
value
)
;
}
;
return
StyleAttributeManager
;
}
(
_runtime
.
AttributeManager
)
;
var
STYLE_ATTRIBUTE_MANANGER
=
new
StyleAttributeManager
(
'
style
'
)
;
Environment
.
prototype
.
attributeFor
=
function
(
element
attribute
isTrusting
)
{
if
(
attribute
=
=
=
'
style
'
&
&
!
isTrusting
)
{
return
STYLE_ATTRIBUTE_MANANGER
;
}
return
_runtime
.
Environment
.
prototype
.
attributeFor
.
call
(
this
element
attribute
isTrusting
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helper
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
runtime
'
'
ember
-
utils
'
]
function
(
exports
_emberBabel
_reference
_emberRuntime
_emberUtils
)
{
'
use
strict
'
;
exports
.
SimpleHelper
=
exports
.
RECOMPUTE_TAG
=
undefined
;
exports
.
helper
=
helper
;
var
RECOMPUTE_TAG
=
exports
.
RECOMPUTE_TAG
=
(
0
_emberUtils
.
symbol
)
(
'
RECOMPUTE_TAG
'
)
;
var
Helper
=
_emberRuntime
.
FrameworkObject
.
extend
(
{
isHelperInstance
:
true
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
[
RECOMPUTE_TAG
]
=
new
_reference
.
DirtyableTag
(
)
;
}
recompute
:
function
(
)
{
this
[
RECOMPUTE_TAG
]
.
dirty
(
)
;
}
}
)
;
Helper
.
reopenClass
(
{
isHelperFactory
:
true
}
)
;
var
SimpleHelper
=
exports
.
SimpleHelper
=
function
(
)
{
function
SimpleHelper
(
compute
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
SimpleHelper
)
;
this
.
compute
=
compute
;
this
.
isHelperFactory
=
true
;
this
.
isHelperInstance
=
true
;
this
.
isSimpleHelperFactory
=
true
;
}
SimpleHelper
.
prototype
.
create
=
function
create
(
)
{
return
this
;
}
;
return
SimpleHelper
;
}
(
)
;
function
helper
(
helperFn
)
{
return
new
SimpleHelper
(
helperFn
)
;
}
exports
.
default
=
Helper
;
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
-
class
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberRuntime
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
classHelper
args
.
capture
(
)
)
;
}
;
function
classHelper
(
_ref
)
{
var
positional
=
_ref
.
positional
;
var
path
=
positional
.
at
(
0
)
;
var
args
=
positional
.
length
;
var
value
=
path
.
value
(
)
;
if
(
value
=
=
=
true
)
{
if
(
args
>
1
)
{
return
_emberRuntime
.
String
.
dasherize
(
positional
.
at
(
1
)
.
value
(
)
)
;
}
return
null
;
}
if
(
value
=
=
=
false
)
{
if
(
args
>
2
)
{
return
_emberRuntime
.
String
.
dasherize
(
positional
.
at
(
2
)
.
value
(
)
)
;
}
return
null
;
}
return
value
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
-
html
-
safe
'
[
'
exports
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
utils
/
string
'
]
function
(
exports
_references
_string
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
htmlSafe
args
.
capture
(
)
)
;
}
;
function
htmlSafe
(
_ref
)
{
var
positional
=
_ref
.
positional
;
var
path
=
positional
.
at
(
0
)
;
return
new
_string
.
SafeString
(
path
.
value
(
)
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
-
input
-
type
'
[
'
exports
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
inputTypeHelper
args
.
capture
(
)
)
;
}
;
function
inputTypeHelper
(
_ref
)
{
var
positional
=
_ref
.
positional
;
var
type
=
positional
.
at
(
0
)
.
value
(
)
;
if
(
type
=
=
=
'
checkbox
'
)
{
return
'
-
checkbox
'
;
}
return
'
-
text
-
field
'
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
-
normalize
-
class
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberRuntime
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
normalizeClass
args
.
capture
(
)
)
;
}
;
function
normalizeClass
(
_ref
)
{
var
positional
=
_ref
.
positional
;
var
classNameParts
=
positional
.
at
(
0
)
.
value
(
)
.
split
(
'
.
'
)
;
var
className
=
classNameParts
[
classNameParts
.
length
-
1
]
;
var
value
=
positional
.
at
(
1
)
.
value
(
)
;
if
(
value
=
=
=
true
)
{
return
_emberRuntime
.
String
.
dasherize
(
className
)
;
}
else
if
(
!
value
&
&
value
!
=
=
0
)
{
return
'
'
;
}
else
{
return
String
(
value
)
;
}
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
action
'
[
'
exports
'
'
glimmer
/
reference
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_reference
_emberDebug
_emberMetal
_emberUtils
_references
)
{
'
use
strict
'
;
exports
.
ACTION
=
exports
.
INVOKE
=
undefined
;
exports
.
default
=
function
(
_vm
args
)
{
var
named
=
args
.
named
positional
=
args
.
positional
;
var
capturedArgs
=
positional
.
capture
(
)
;
var
_capturedArgs
referen
=
capturedArgs
.
references
context
=
_capturedArgs
referen
[
0
]
action
=
_capturedArgs
referen
[
1
]
restArgs
=
_capturedArgs
referen
.
slice
(
2
)
;
var
debugKey
=
action
.
_propertyKey
;
var
target
=
named
.
has
(
'
target
'
)
?
named
.
get
(
'
target
'
)
:
context
;
var
processArgs
=
makeArgsProcessor
(
named
.
has
(
'
value
'
)
&
&
named
.
get
(
'
value
'
)
restArgs
)
;
var
fn
=
void
0
;
if
(
typeof
action
[
INVOKE
]
=
=
=
'
function
'
)
{
fn
=
makeClosureAction
(
action
action
action
[
INVOKE
]
processArgs
debugKey
)
;
}
else
if
(
(
0
_reference
.
isConst
)
(
target
)
&
&
(
0
_reference
.
isConst
)
(
action
)
)
{
fn
=
makeClosureAction
(
context
.
value
(
)
target
.
value
(
)
action
.
value
(
)
processArgs
debugKey
)
;
}
else
{
fn
=
makeDynamicClosureAction
(
context
.
value
(
)
target
action
processArgs
debugKey
)
;
}
fn
[
ACTION
]
=
true
;
return
new
_references
.
UnboundReference
(
fn
)
;
}
;
var
INVOKE
=
exports
.
INVOKE
=
(
0
_emberUtils
.
symbol
)
(
'
INVOKE
'
)
;
var
ACTION
=
exports
.
ACTION
=
(
0
_emberUtils
.
symbol
)
(
'
ACTION
'
)
;
function
NOOP
(
args
)
{
return
args
;
}
function
makeArgsProcessor
(
valuePathRef
actionArgsRef
)
{
var
mergeArgs
=
void
0
;
if
(
actionArgsRef
.
length
>
0
)
{
mergeArgs
=
function
(
args
)
{
return
actionArgsRef
.
map
(
function
(
ref
)
{
return
ref
.
value
(
)
;
}
)
.
concat
(
args
)
;
}
;
}
var
readValue
=
void
0
;
if
(
valuePathRef
)
{
readValue
=
function
(
args
)
{
var
valuePath
=
valuePathRef
.
value
(
)
;
if
(
valuePath
&
&
args
.
length
>
0
)
{
args
[
0
]
=
(
0
_emberMetal
.
get
)
(
args
[
0
]
valuePath
)
;
}
return
args
;
}
;
}
if
(
mergeArgs
&
&
readValue
)
{
return
function
(
args
)
{
return
readValue
(
mergeArgs
(
args
)
)
;
}
;
}
else
{
return
mergeArgs
|
|
readValue
|
|
NOOP
;
}
}
function
makeDynamicClosureAction
(
context
targetRef
actionRef
processArgs
debugKey
)
{
if
(
true
)
{
makeClosureAction
(
context
targetRef
.
value
(
)
actionRef
.
value
(
)
processArgs
debugKey
)
;
}
return
function
(
)
{
return
makeClosureAction
(
context
targetRef
.
value
(
)
actionRef
.
value
(
)
processArgs
debugKey
)
.
apply
(
undefined
arguments
)
;
}
;
}
function
makeClosureAction
(
context
target
action
processArgs
debugKey
)
{
var
self
=
void
0
;
var
fn
=
void
0
;
(
true
&
&
!
(
!
(
0
_emberMetal
.
isNone
)
(
action
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Action
passed
is
null
or
undefined
in
(
action
)
from
'
+
target
+
'
.
'
!
(
0
_emberMetal
.
isNone
)
(
action
)
)
)
;
if
(
typeof
action
[
INVOKE
]
=
=
=
'
function
'
)
{
self
=
action
;
fn
=
action
[
INVOKE
]
;
}
else
{
var
typeofAction
=
typeof
action
;
if
(
typeofAction
=
=
=
'
string
'
)
{
self
=
target
;
fn
=
target
.
actions
&
&
target
.
actions
[
action
]
;
(
true
&
&
!
(
fn
)
&
&
(
0
_emberDebug
.
assert
)
(
'
An
action
named
\
'
'
+
action
+
'
\
'
was
not
found
in
'
+
target
fn
)
)
;
}
else
if
(
typeofAction
=
=
=
'
function
'
)
{
self
=
context
;
fn
=
action
;
}
else
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
'
An
action
could
not
be
made
for
'
+
(
debugKey
|
|
action
)
+
'
in
'
+
target
+
'
.
Please
confirm
that
you
are
using
either
a
quoted
action
name
(
i
.
e
.
(
action
\
'
'
+
(
debugKey
|
|
'
myAction
'
)
+
'
\
'
)
)
or
a
function
available
in
'
+
target
+
'
.
'
false
)
)
;
}
}
return
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
payload
=
{
target
:
self
args
:
args
label
:
'
glimmer
/
closure
-
action
'
}
;
return
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
return
_emberMetal
.
run
.
join
.
apply
(
_emberMetal
.
run
[
self
fn
]
.
concat
(
processArgs
(
args
)
)
)
;
}
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
component
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
debug
'
'
ember
-
utils
'
'
ember
-
glimmer
/
component
-
managers
/
curly
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberBabel
_runtime
_emberDebug
_emberUtils
_curly
_references
)
{
'
use
strict
'
;
exports
.
ClosureComponentReference
=
undefined
;
exports
.
default
=
function
(
vm
args
meta
)
{
return
ClosureComponentReference
.
create
(
args
.
capture
(
)
meta
vm
.
env
)
;
}
;
var
ClosureComponentReference
=
exports
.
ClosureComponentReference
=
function
(
_CachedReference
)
{
(
0
_emberBabel
.
inherits
)
(
ClosureComponentReference
_CachedReference
)
;
ClosureComponentReference
.
create
=
function
create
(
args
meta
env
)
{
return
new
ClosureComponentReference
(
args
meta
env
)
;
}
;
function
ClosureComponentReference
(
args
meta
env
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ClosureComponentReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference
.
call
(
this
)
)
;
var
firstArg
=
args
.
positional
.
at
(
0
)
;
_this
.
defRef
=
firstArg
;
_this
.
tag
=
firstArg
.
tag
;
_this
.
args
=
args
;
_this
.
meta
=
meta
;
_this
.
env
=
env
;
_this
.
lastDefinition
=
undefined
;
_this
.
lastName
=
undefined
;
return
_this
;
}
ClosureComponentReference
.
prototype
.
compute
=
function
compute
(
)
{
var
args
=
this
.
args
defRef
=
this
.
defRef
env
=
this
.
env
meta
=
this
.
meta
lastDefinition
=
this
.
lastDefinition
lastName
=
this
.
lastName
;
var
nameOrDef
=
defRef
.
value
(
)
;
var
definition
=
void
0
;
if
(
nameOrDef
&
&
nameOrDef
=
=
=
lastName
)
{
return
lastDefinition
;
}
this
.
lastName
=
nameOrDef
;
if
(
typeof
nameOrDef
=
=
=
'
string
'
)
{
(
true
&
&
!
(
nameOrDef
!
=
=
'
input
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
the
input
helper
as
a
contextual
helper
.
Please
extend
TextField
or
Checkbox
to
use
it
as
a
contextual
component
.
'
nameOrDef
!
=
=
'
input
'
)
)
;
(
true
&
&
!
(
nameOrDef
!
=
=
'
textarea
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
the
textarea
helper
as
a
contextual
helper
.
Please
extend
TextArea
to
use
it
as
a
contextual
component
.
'
nameOrDef
!
=
=
'
textarea
'
)
)
;
definition
=
env
.
getComponentDefinition
(
nameOrDef
meta
)
;
(
true
&
&
!
(
!
!
definition
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
component
helper
cannot
be
used
without
a
valid
component
name
.
You
used
"
'
+
nameOrDef
+
'
"
via
(
component
"
'
+
nameOrDef
+
'
"
)
'
!
!
definition
)
)
;
}
else
if
(
(
0
_runtime
.
isComponentDefinition
)
(
nameOrDef
)
)
{
definition
=
nameOrDef
;
}
else
{
(
true
&
&
!
(
nameOrDef
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
create
a
component
from
'
+
nameOrDef
+
'
using
the
{
{
component
}
}
helper
'
nameOrDef
)
)
;
return
null
;
}
var
newDef
=
createCurriedDefinition
(
definition
args
)
;
this
.
lastDefinition
=
newDef
;
return
newDef
;
}
;
return
ClosureComponentReference
;
}
(
_references
.
CachedReference
)
;
function
createCurriedDefinition
(
definition
args
)
{
var
curriedArgs
=
curryArgs
(
definition
args
)
;
return
new
_curly
.
CurlyComponentDefinition
(
definition
.
name
definition
.
ComponentClass
definition
.
template
curriedArgs
)
;
}
function
curryArgs
(
definition
newArgs
)
{
var
args
=
definition
.
args
ComponentClass
=
definition
.
ComponentClass
;
var
positionalParams
=
ComponentClass
.
class
.
positionalParams
;
var
_newArgs
positional
r
=
newArgs
.
positional
.
references
slicedPositionalArgs
=
_newArgs
positional
r
.
slice
(
1
)
;
if
(
positionalParams
&
&
slicedPositionalArgs
.
length
)
{
(
0
_curly
.
validatePositionalParameters
)
(
newArgs
.
named
slicedPositionalArgs
positionalParams
)
;
}
var
isRest
=
typeof
positionalParams
=
=
=
'
string
'
;
var
positionalToNamedParams
=
{
}
;
if
(
!
isRest
&
&
positionalParams
.
length
>
0
)
{
var
limit
=
Math
.
min
(
positionalParams
.
length
slicedPositionalArgs
.
length
)
;
for
(
var
i
=
0
;
i
<
limit
;
i
+
+
)
{
var
name
=
positionalParams
[
i
]
;
positionalToNamedParams
[
name
]
=
slicedPositionalArgs
[
i
]
;
}
slicedPositionalArgs
.
length
=
0
;
}
var
oldNamed
=
args
&
&
args
.
named
|
|
{
}
;
var
oldPositional
=
args
&
&
args
.
positional
|
|
[
]
;
var
positional
=
new
Array
(
Math
.
max
(
oldPositional
.
length
slicedPositionalArgs
.
length
)
)
;
positional
.
splice
.
apply
(
positional
[
0
oldPositional
.
length
]
.
concat
(
oldPositional
)
)
;
positional
.
splice
.
apply
(
positional
[
0
slicedPositionalArgs
.
length
]
.
concat
(
slicedPositionalArgs
)
)
;
var
named
=
(
0
_emberUtils
.
assign
)
(
{
}
oldNamed
positionalToNamedParams
newArgs
.
named
.
map
)
;
return
{
positional
:
positional
named
:
named
}
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
concat
'
[
'
exports
'
'
glimmer
/
runtime
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_runtime
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
concat
args
.
capture
(
)
)
;
}
;
function
concat
(
_ref
)
{
var
positional
=
_ref
.
positional
;
return
positional
.
value
(
)
.
map
(
_runtime
.
normalizeTextValue
)
.
join
(
'
'
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
each
-
in
'
[
'
exports
'
'
ember
-
utils
'
]
function
(
exports
_emberUtils
)
{
'
use
strict
'
;
exports
.
isEachIn
=
isEachIn
;
exports
.
default
=
function
(
_vm
args
)
{
var
ref
=
Object
.
create
(
args
.
positional
.
at
(
0
)
)
;
ref
[
EACH_IN_REFERENCE
]
=
true
;
return
ref
;
}
;
var
EACH_IN_REFERENCE
=
(
0
_emberUtils
.
symbol
)
(
'
EACH_IN
'
)
;
function
isEachIn
(
ref
)
{
return
ref
&
&
ref
[
EACH_IN_REFERENCE
]
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
get
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
glimmer
/
runtime
'
'
ember
-
metal
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberBabel
_reference
_runtime
_emberMetal
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
GetHelperReference
.
create
(
args
.
positional
.
at
(
0
)
args
.
positional
.
at
(
1
)
)
;
}
;
var
GetHelperReference
=
function
(
_CachedReference
)
{
(
0
_emberBabel
.
inherits
)
(
GetHelperReference
_CachedReference
)
;
GetHelperReference
.
create
=
function
create
(
sourceReference
pathReference
)
{
if
(
(
0
_reference
.
isConst
)
(
pathReference
)
)
{
var
path
=
pathReference
.
value
(
)
;
if
(
path
=
=
=
undefined
|
|
path
=
=
=
null
|
|
path
=
=
=
'
'
)
{
return
_runtime
.
NULL_REFERENCE
;
}
else
if
(
typeof
path
=
=
=
'
string
'
&
&
path
.
indexOf
(
'
.
'
)
>
-
1
)
{
return
(
0
_reference
.
referenceFromParts
)
(
sourceReference
path
.
split
(
'
.
'
)
)
;
}
else
{
return
sourceReference
.
get
(
path
)
;
}
}
else
{
return
new
GetHelperReference
(
sourceReference
pathReference
)
;
}
}
;
function
GetHelperReference
(
sourceReference
pathReference
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
GetHelperReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference
.
call
(
this
)
)
;
_this
.
sourceReference
=
sourceReference
;
_this
.
pathReference
=
pathReference
;
_this
.
lastPath
=
null
;
_this
.
innerReference
=
_runtime
.
NULL_REFERENCE
;
var
innerTag
=
_this
.
innerTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
_this
.
tag
=
(
0
_reference
.
combine
)
(
[
sourceReference
.
tag
pathReference
.
tag
innerTag
]
)
;
return
_this
;
}
GetHelperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
lastPath
=
this
.
lastPath
innerReference
=
this
.
innerReference
innerTag
=
this
.
innerTag
;
var
path
=
this
.
lastPath
=
this
.
pathReference
.
value
(
)
;
if
(
path
!
=
=
lastPath
)
{
if
(
path
=
=
=
undefined
|
|
path
=
=
=
null
|
|
path
=
=
=
'
'
)
{
innerReference
=
_runtime
.
NULL_REFERENCE
;
}
else
if
(
typeof
path
=
=
=
'
string
'
&
&
path
.
indexOf
(
'
.
'
)
>
-
1
)
{
innerReference
=
(
0
_reference
.
referenceFromParts
)
(
this
.
sourceReference
path
.
split
(
'
.
'
)
)
;
}
else
{
innerReference
=
this
.
sourceReference
.
get
(
path
)
;
}
innerTag
.
inner
.
update
(
innerReference
.
tag
)
;
this
.
innerReference
=
innerReference
;
}
return
innerReference
.
value
(
)
;
}
;
GetHelperReference
.
prototype
[
_references
.
UPDATE
]
=
function
(
value
)
{
(
0
_emberMetal
.
set
)
(
this
.
sourceReference
.
value
(
)
this
.
pathReference
.
value
(
)
value
)
;
}
;
return
GetHelperReference
;
}
(
_references
.
CachedReference
)
;
}
)
;
enifed
(
"
ember
-
glimmer
/
helpers
/
hash
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
function
(
_vm
args
)
{
return
args
.
named
.
capture
(
)
;
}
;
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
if
-
unless
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
debug
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberBabel
_reference
_emberDebug
_references
)
{
'
use
strict
'
;
exports
.
inlineIf
=
inlineIf
;
exports
.
inlineUnless
=
inlineUnless
;
var
ConditionalHelperReference
=
function
(
_CachedReference
)
{
(
0
_emberBabel
.
inherits
)
(
ConditionalHelperReference
_CachedReference
)
;
ConditionalHelperReference
.
create
=
function
create
(
_condRef
truthyRef
falsyRef
)
{
var
condRef
=
_references
.
ConditionalReference
.
create
(
_condRef
)
;
if
(
(
0
_reference
.
isConst
)
(
condRef
)
)
{
return
condRef
.
value
(
)
?
truthyRef
:
falsyRef
;
}
else
{
return
new
ConditionalHelperReference
(
condRef
truthyRef
falsyRef
)
;
}
}
;
function
ConditionalHelperReference
(
cond
truthy
falsy
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ConditionalHelperReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference
.
call
(
this
)
)
;
_this
.
branchTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
_this
.
tag
=
(
0
_reference
.
combine
)
(
[
cond
.
tag
_this
.
branchTag
]
)
;
_this
.
cond
=
cond
;
_this
.
truthy
=
truthy
;
_this
.
falsy
=
falsy
;
return
_this
;
}
ConditionalHelperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
branch
=
this
.
cond
.
value
(
)
?
this
.
truthy
:
this
.
falsy
;
this
.
branchTag
.
inner
.
update
(
branch
.
tag
)
;
return
branch
.
value
(
)
;
}
;
return
ConditionalHelperReference
;
}
(
_references
.
CachedReference
)
;
function
inlineIf
(
_vm
_ref
)
{
var
positional
=
_ref
.
positional
;
(
true
&
&
!
(
positional
.
length
=
=
=
3
|
|
positional
.
length
=
=
=
2
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
inline
form
of
the
if
helper
expects
two
or
three
arguments
e
.
g
.
'
+
'
{
{
if
trialExpired
"
Expired
"
expiryDate
}
}
.
'
positional
.
length
=
=
=
3
|
|
positional
.
length
=
=
=
2
)
)
;
return
ConditionalHelperReference
.
create
(
positional
.
at
(
0
)
positional
.
at
(
1
)
positional
.
at
(
2
)
)
;
}
function
inlineUnless
(
_vm
_ref2
)
{
var
positional
=
_ref2
.
positional
;
(
true
&
&
!
(
positional
.
length
=
=
=
3
|
|
positional
.
length
=
=
=
2
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
inline
form
of
the
unless
helper
expects
two
or
three
arguments
e
.
g
.
'
+
'
{
{
unless
isFirstLogin
"
Welcome
back
!
"
}
}
.
'
positional
.
length
=
=
=
3
|
|
positional
.
length
=
=
=
2
)
)
;
return
ConditionalHelperReference
.
create
(
positional
.
at
(
0
)
positional
.
at
(
2
)
positional
.
at
(
1
)
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
loc
'
[
'
exports
'
'
ember
-
glimmer
/
helper
'
'
ember
-
runtime
'
]
function
(
exports
_helper
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
(
0
_helper
.
helper
)
(
function
(
params
)
{
return
_emberRuntime
.
String
.
loc
.
apply
(
null
params
)
;
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
log
'
[
'
exports
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
console
'
]
function
(
exports
_references
_emberConsole
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
log
args
.
capture
(
)
)
;
}
;
function
log
(
_ref
)
{
var
positional
=
_ref
.
positional
;
_emberConsole
.
default
.
log
.
apply
(
null
positional
.
value
(
)
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
mut
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
utils
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
helpers
/
action
'
]
function
(
exports
_emberDebug
_emberUtils
_references
_action
)
{
'
use
strict
'
;
exports
.
isMut
=
isMut
;
exports
.
unMut
=
unMut
;
exports
.
default
=
function
(
_vm
args
)
{
var
rawRef
=
args
.
positional
.
at
(
0
)
;
if
(
isMut
(
rawRef
)
)
{
return
rawRef
;
}
(
true
&
&
!
(
rawRef
[
_references
.
UPDATE
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
can
only
pass
a
path
to
mut
'
rawRef
[
_references
.
UPDATE
]
)
)
;
var
wrappedRef
=
Object
.
create
(
rawRef
)
;
wrappedRef
[
SOURCE
]
=
rawRef
;
wrappedRef
[
_action
.
INVOKE
]
=
rawRef
[
_references
.
UPDATE
]
;
wrappedRef
[
MUT_REFERENCE
]
=
true
;
return
wrappedRef
;
}
;
var
MUT_REFERENCE
=
(
0
_emberUtils
.
symbol
)
(
'
MUT
'
)
;
var
SOURCE
=
(
0
_emberUtils
.
symbol
)
(
'
SOURCE
'
)
;
function
isMut
(
ref
)
{
return
ref
&
&
ref
[
MUT_REFERENCE
]
;
}
function
unMut
(
ref
)
{
return
ref
[
SOURCE
]
|
|
ref
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
query
-
param
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
routing
'
'
ember
-
utils
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberDebug
_emberRouting
_emberUtils
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
return
new
_references
.
InternalHelperReference
(
queryParams
args
.
capture
(
)
)
;
}
;
function
queryParams
(
_ref
)
{
var
positional
=
_ref
.
positional
named
=
_ref
.
named
;
(
true
&
&
!
(
positional
.
value
(
)
.
length
=
=
=
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
query
-
params
helper
only
accepts
hash
parameters
e
.
g
.
(
query
-
params
queryParamPropertyName
=
\
'
foo
\
'
)
as
opposed
to
just
(
query
-
params
\
'
foo
\
'
)
'
positional
.
value
(
)
.
length
=
=
=
0
)
)
;
return
_emberRouting
.
QueryParams
.
create
(
{
values
:
(
0
_emberUtils
.
assign
)
(
{
}
named
.
value
(
)
)
}
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
readonly
'
[
'
exports
'
'
ember
-
glimmer
/
utils
/
references
'
'
ember
-
glimmer
/
helpers
/
mut
'
]
function
(
exports
_references
_mut
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
var
ref
=
(
0
_mut
.
unMut
)
(
args
.
positional
.
at
(
0
)
)
;
var
wrapped
=
Object
.
create
(
ref
)
;
wrapped
[
_references
.
UPDATE
]
=
undefined
;
return
wrapped
;
}
;
}
)
;
enifed
(
'
ember
-
glimmer
/
helpers
/
unbound
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberDebug
_references
)
{
'
use
strict
'
;
exports
.
default
=
function
(
_vm
args
)
{
(
true
&
&
!
(
args
.
positional
.
length
=
=
=
1
&
&
args
.
named
.
length
=
=
=
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
unbound
helper
cannot
be
called
with
multiple
params
or
hash
params
'
args
.
positional
.
length
=
=
=
1
&
&
args
.
named
.
length
=
=
=
0
)
)
;
return
_references
.
UnboundReference
.
create
(
args
.
positional
.
at
(
0
)
.
value
(
)
)
;
}
;
}
)
;
enifed
(
'
ember
-
glimmer
/
index
'
[
'
exports
'
'
ember
-
glimmer
/
helpers
/
action
'
'
ember
-
glimmer
/
templates
/
root
'
'
ember
-
glimmer
/
template
'
'
ember
-
glimmer
/
components
/
checkbox
'
'
ember
-
glimmer
/
components
/
text_field
'
'
ember
-
glimmer
/
components
/
text_area
'
'
ember
-
glimmer
/
components
/
link
-
to
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
helper
'
'
ember
-
glimmer
/
environment
'
'
ember
-
glimmer
/
utils
/
string
'
'
ember
-
glimmer
/
renderer
'
'
ember
-
glimmer
/
template_registry
'
'
ember
-
glimmer
/
setup
-
registry
'
'
ember
-
glimmer
/
dom
'
'
ember
-
glimmer
/
syntax
'
'
ember
-
glimmer
/
component
-
managers
/
abstract
'
]
function
(
exports
_action
_root
_template
_checkbox
_text_field
_text_area
_linkTo
_component
_helper
_environment
_string
_renderer
_template_registry
_setupRegistry
_dom
_syntax
_abstract
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
INVOKE
'
{
enumerable
:
true
get
:
function
(
)
{
return
_action
.
INVOKE
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RootTemplate
'
{
enumerable
:
true
get
:
function
(
)
{
return
_root
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
template
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Checkbox
'
{
enumerable
:
true
get
:
function
(
)
{
return
_checkbox
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TextField
'
{
enumerable
:
true
get
:
function
(
)
{
return
_text_field
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TextArea
'
{
enumerable
:
true
get
:
function
(
)
{
return
_text_area
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
LinkComponent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_linkTo
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Component
'
{
enumerable
:
true
get
:
function
(
)
{
return
_component
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Helper
'
{
enumerable
:
true
get
:
function
(
)
{
return
_helper
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
helper
'
{
enumerable
:
true
get
:
function
(
)
{
return
_helper
.
helper
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Environment
'
{
enumerable
:
true
get
:
function
(
)
{
return
_environment
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
SafeString
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string
.
SafeString
;
}
}
)
;
Object
.
defineProperty
(
exports
'
escapeExpression
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string
.
escapeExpression
;
}
}
)
;
Object
.
defineProperty
(
exports
'
htmlSafe
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string
.
htmlSafe
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isHTMLSafe
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string
.
isHTMLSafe
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Renderer
'
{
enumerable
:
true
get
:
function
(
)
{
return
_renderer
.
Renderer
;
}
}
)
;
Object
.
defineProperty
(
exports
'
InertRenderer
'
{
enumerable
:
true
get
:
function
(
)
{
return
_renderer
.
InertRenderer
;
}
}
)
;
Object
.
defineProperty
(
exports
'
InteractiveRenderer
'
{
enumerable
:
true
get
:
function
(
)
{
return
_renderer
.
InteractiveRenderer
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_resetRenderers
'
{
enumerable
:
true
get
:
function
(
)
{
return
_renderer
.
_resetRenderers
;
}
}
)
;
Object
.
defineProperty
(
exports
'
renderSettled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_renderer
.
renderSettled
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getTemplate
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template_registry
.
getTemplate
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setTemplate
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template_registry
.
setTemplate
;
}
}
)
;
Object
.
defineProperty
(
exports
'
hasTemplate
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template_registry
.
hasTemplate
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getTemplates
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template_registry
.
getTemplates
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setTemplates
'
{
enumerable
:
true
get
:
function
(
)
{
return
_template_registry
.
setTemplates
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupEngineRegistry
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupRegistry
.
setupEngineRegistry
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupApplicationRegistry
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupRegistry
.
setupApplicationRegistry
;
}
}
)
;
Object
.
defineProperty
(
exports
'
DOMChanges
'
{
enumerable
:
true
get
:
function
(
)
{
return
_dom
.
DOMChanges
;
}
}
)
;
Object
.
defineProperty
(
exports
'
NodeDOMTreeConstruction
'
{
enumerable
:
true
get
:
function
(
)
{
return
_dom
.
NodeDOMTreeConstruction
;
}
}
)
;
Object
.
defineProperty
(
exports
'
DOMTreeConstruction
'
{
enumerable
:
true
get
:
function
(
)
{
return
_dom
.
DOMTreeConstruction
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_registerMacros
'
{
enumerable
:
true
get
:
function
(
)
{
return
_syntax
.
registerMacros
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_experimentalMacros
'
{
enumerable
:
true
get
:
function
(
)
{
return
_syntax
.
experimentalMacros
;
}
}
)
;
Object
.
defineProperty
(
exports
'
AbstractComponentManager
'
{
enumerable
:
true
get
:
function
(
)
{
return
_abstract
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
modifiers
/
action
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
-
views
'
'
ember
-
glimmer
/
helpers
/
action
'
]
function
(
exports
_emberBabel
_emberDebug
_emberMetal
_emberUtils
_emberViews
_action
)
{
'
use
strict
'
;
exports
.
ActionState
=
exports
.
ActionHelper
=
undefined
;
var
MODIFIERS
=
[
'
alt
'
'
shift
'
'
meta
'
'
ctrl
'
]
;
var
POINTER_EVENT_TYPE_REGEX
=
/
^
click
|
mouse
|
touch
/
;
function
isAllowedEvent
(
event
allowedKeys
)
{
if
(
allowedKeys
=
=
=
null
|
|
allowedKeys
=
=
=
undefined
)
{
if
(
POINTER_EVENT_TYPE_REGEX
.
test
(
event
.
type
)
)
{
return
(
0
_emberViews
.
isSimpleClick
)
(
event
)
;
}
else
{
allowedKeys
=
'
'
;
}
}
if
(
allowedKeys
.
indexOf
(
'
any
'
)
>
=
0
)
{
return
true
;
}
for
(
var
i
=
0
;
i
<
MODIFIERS
.
length
;
i
+
+
)
{
if
(
event
[
MODIFIERS
[
i
]
+
'
Key
'
]
&
&
allowedKeys
.
indexOf
(
MODIFIERS
[
i
]
)
=
=
=
-
1
)
{
return
false
;
}
}
return
true
;
}
var
ActionHelper
=
exports
.
ActionHelper
=
{
registeredActions
:
_emberViews
.
ActionManager
.
registeredActions
registerAction
:
function
(
actionState
)
{
var
actionId
=
actionState
.
actionId
;
_emberViews
.
ActionManager
.
registeredActions
[
actionId
]
=
actionState
;
return
actionId
;
}
unregisterAction
:
function
(
actionState
)
{
var
actionId
=
actionState
.
actionId
;
delete
_emberViews
.
ActionManager
.
registeredActions
[
actionId
]
;
}
}
;
var
ActionState
=
exports
.
ActionState
=
function
(
)
{
function
ActionState
(
element
actionId
actionName
actionArgs
namedArgs
positionalArgs
implicitTarget
dom
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ActionState
)
;
this
.
element
=
element
;
this
.
actionId
=
actionId
;
this
.
actionName
=
actionName
;
this
.
actionArgs
=
actionArgs
;
this
.
namedArgs
=
namedArgs
;
this
.
positional
=
positionalArgs
;
this
.
implicitTarget
=
implicitTarget
;
this
.
dom
=
dom
;
this
.
eventName
=
this
.
getEventName
(
)
;
}
ActionState
.
prototype
.
getEventName
=
function
getEventName
(
)
{
return
this
.
namedArgs
.
get
(
'
on
'
)
.
value
(
)
|
|
'
click
'
;
}
;
ActionState
.
prototype
.
getActionArgs
=
function
getActionArgs
(
)
{
var
result
=
new
Array
(
this
.
actionArgs
.
length
)
;
for
(
var
i
=
0
;
i
<
this
.
actionArgs
.
length
;
i
+
+
)
{
result
[
i
]
=
this
.
actionArgs
[
i
]
.
value
(
)
;
}
return
result
;
}
;
ActionState
.
prototype
.
getTarget
=
function
getTarget
(
)
{
var
implicitTarget
=
this
.
implicitTarget
namedArgs
=
this
.
namedArgs
;
var
target
=
void
0
;
if
(
namedArgs
.
has
(
'
target
'
)
)
{
target
=
namedArgs
.
get
(
'
target
'
)
.
value
(
)
;
}
else
{
target
=
implicitTarget
.
value
(
)
;
}
return
target
;
}
;
ActionState
.
prototype
.
handler
=
function
handler
(
event
)
{
var
_this
=
this
;
var
actionName
=
this
.
actionName
namedArgs
=
this
.
namedArgs
;
var
bubbles
=
namedArgs
.
get
(
'
bubbles
'
)
;
var
preventDefault
=
namedArgs
.
get
(
'
preventDefault
'
)
;
var
allowedKeys
=
namedArgs
.
get
(
'
allowedKeys
'
)
;
var
target
=
this
.
getTarget
(
)
;
if
(
!
isAllowedEvent
(
event
allowedKeys
.
value
(
)
)
)
{
return
true
;
}
if
(
preventDefault
.
value
(
)
!
=
=
false
)
{
event
.
preventDefault
(
)
;
}
if
(
bubbles
.
value
(
)
=
=
=
false
)
{
event
.
stopPropagation
(
)
;
}
_emberMetal
.
run
.
join
(
function
(
)
{
var
args
=
_this
.
getActionArgs
(
)
;
var
payload
=
{
args
:
args
target
:
target
name
:
null
}
;
if
(
typeof
actionName
[
_action
.
INVOKE
]
=
=
=
'
function
'
)
{
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
actionName
[
_action
.
INVOKE
]
.
apply
(
actionName
args
)
;
}
)
;
return
;
}
if
(
typeof
actionName
=
=
=
'
function
'
)
{
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
actionName
.
apply
(
target
args
)
;
}
)
;
return
;
}
payload
.
name
=
actionName
;
if
(
target
.
send
)
{
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
target
.
send
.
apply
(
target
[
actionName
]
.
concat
(
args
)
)
;
}
)
;
}
else
{
(
true
&
&
!
(
typeof
target
[
actionName
]
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
action
\
'
'
+
actionName
+
'
\
'
did
not
exist
on
'
+
target
typeof
target
[
actionName
]
=
=
=
'
function
'
)
)
;
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
target
[
actionName
]
.
apply
(
target
args
)
;
}
)
;
}
}
)
;
return
false
;
}
;
ActionState
.
prototype
.
destroy
=
function
destroy
(
)
{
ActionHelper
.
unregisterAction
(
this
)
;
}
;
return
ActionState
;
}
(
)
;
var
ActionModifierManager
=
function
(
)
{
function
ActionModifierManager
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ActionModifierManager
)
;
}
ActionModifierManager
.
prototype
.
create
=
function
create
(
element
args
_dynamicScope
dom
)
{
var
_args
capture
=
args
.
capture
(
)
named
=
_args
capture
.
named
positional
=
_args
capture
.
positional
;
var
implicitTarget
=
void
0
;
var
actionName
=
void
0
;
var
actionNameRef
=
void
0
;
if
(
positional
.
length
>
1
)
{
implicitTarget
=
positional
.
at
(
0
)
;
actionNameRef
=
positional
.
at
(
1
)
;
if
(
actionNameRef
[
_action
.
INVOKE
]
)
{
actionName
=
actionNameRef
;
}
else
{
var
actionLabel
=
actionNameRef
.
_propertyKey
;
actionName
=
actionNameRef
.
value
(
)
;
(
true
&
&
!
(
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
specified
a
quoteless
path
'
+
actionLabel
+
'
to
the
'
+
'
{
{
action
}
}
helper
which
did
not
resolve
to
an
action
name
(
a
'
+
'
string
)
.
Perhaps
you
meant
to
use
a
quoted
actionName
?
(
e
.
g
.
'
+
'
{
{
action
"
'
+
actionLabel
+
'
"
}
}
)
.
'
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
)
;
}
}
var
actionArgs
=
[
]
;
for
(
var
i
=
2
;
i
<
positional
.
length
;
i
+
+
)
{
actionArgs
.
push
(
positional
.
at
(
i
)
)
;
}
var
actionId
=
(
0
_emberUtils
.
uuid
)
(
)
;
return
new
ActionState
(
element
actionId
actionName
actionArgs
named
positional
implicitTarget
dom
)
;
}
;
ActionModifierManager
.
prototype
.
install
=
function
install
(
actionState
)
{
var
dom
=
actionState
.
dom
element
=
actionState
.
element
actionId
=
actionState
.
actionId
;
ActionHelper
.
registerAction
(
actionState
)
;
dom
.
setAttribute
(
element
'
data
-
ember
-
action
'
'
'
)
;
dom
.
setAttribute
(
element
'
data
-
ember
-
action
-
'
+
actionId
actionId
)
;
}
;
ActionModifierManager
.
prototype
.
update
=
function
update
(
actionState
)
{
var
positional
=
actionState
.
positional
;
var
actionNameRef
=
positional
.
at
(
1
)
;
if
(
!
actionNameRef
[
_action
.
INVOKE
]
)
{
actionState
.
actionName
=
actionNameRef
.
value
(
)
;
}
actionState
.
eventName
=
actionState
.
getEventName
(
)
;
}
;
ActionModifierManager
.
prototype
.
getDestructor
=
function
getDestructor
(
modifier
)
{
return
modifier
;
}
;
return
ActionModifierManager
;
}
(
)
;
exports
.
default
=
ActionModifierManager
;
}
)
;
enifed
(
'
ember
-
glimmer
/
protocol
-
for
-
url
'
[
'
exports
'
'
ember
-
environment
'
'
node
-
module
'
]
function
(
exports
_emberEnvironment
_nodeModule
)
{
'
use
strict
'
;
exports
.
default
=
installProtocolForURL
;
var
nodeURL
=
void
0
;
var
parsingNode
=
void
0
;
function
installProtocolForURL
(
environment
)
{
var
protocol
=
void
0
;
if
(
_emberEnvironment
.
environment
.
hasDOM
)
{
protocol
=
browserProtocolForURL
.
call
(
environment
'
foobar
:
baz
'
)
;
}
if
(
protocol
=
=
=
'
foobar
:
'
)
{
environment
.
protocolForURL
=
browserProtocolForURL
;
}
else
if
(
typeof
URL
=
=
=
'
object
'
)
{
nodeURL
=
URL
;
environment
.
protocolForURL
=
nodeProtocolForURL
;
}
else
if
(
_nodeModule
.
IS_NODE
)
{
nodeURL
=
(
0
_nodeModule
.
require
)
(
'
url
'
)
;
environment
.
protocolForURL
=
nodeProtocolForURL
;
}
else
{
throw
new
Error
(
'
Could
not
find
valid
URL
parsing
mechanism
for
URL
Sanitization
'
)
;
}
}
function
browserProtocolForURL
(
url
)
{
if
(
!
parsingNode
)
{
parsingNode
=
document
.
createElement
(
'
a
'
)
;
}
parsingNode
.
href
=
url
;
return
parsingNode
.
protocol
;
}
function
nodeProtocolForURL
(
url
)
{
var
protocol
=
null
;
if
(
typeof
url
=
=
=
'
string
'
)
{
protocol
=
nodeURL
.
parse
(
url
)
.
protocol
;
}
return
protocol
=
=
=
null
?
'
:
'
:
protocol
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
renderer
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
component
-
managers
/
outlet
'
'
ember
-
glimmer
/
component
-
managers
/
root
'
'
ember
-
glimmer
/
utils
/
references
'
'
glimmer
/
runtime
'
'
rsvp
'
]
function
(
exports
_emberBabel
_reference
_emberDebug
_emberMetal
_emberViews
_component
_outlet
_root2
_references
_runtime
_rsvp
)
{
'
use
strict
'
;
exports
.
InteractiveRenderer
=
exports
.
InertRenderer
=
exports
.
Renderer
=
exports
.
DynamicScope
=
undefined
;
exports
.
_resetRenderers
=
_resetRenderers
;
exports
.
renderSettled
=
renderSettled
;
var
backburner
=
_emberMetal
.
run
.
backburner
;
var
DynamicScope
=
exports
.
DynamicScope
=
function
(
)
{
function
DynamicScope
(
view
outletState
rootOutletState
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
DynamicScope
)
;
this
.
view
=
view
;
this
.
outletState
=
outletState
;
this
.
rootOutletState
=
rootOutletState
;
}
DynamicScope
.
prototype
.
child
=
function
child
(
)
{
return
new
DynamicScope
(
this
.
view
this
.
outletState
this
.
rootOutletState
)
;
}
;
DynamicScope
.
prototype
.
get
=
function
get
(
key
)
{
(
true
&
&
!
(
key
=
=
=
'
outletState
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Using
-
get
-
dynamic
-
scope
is
only
supported
for
outletState
(
you
used
'
+
key
+
'
)
.
'
key
=
=
=
'
outletState
'
)
)
;
return
this
.
outletState
;
}
;
DynamicScope
.
prototype
.
set
=
function
set
(
key
value
)
{
(
true
&
&
!
(
key
=
=
=
'
outletState
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Using
-
with
-
dynamic
-
scope
is
only
supported
for
outletState
(
you
used
'
+
key
+
'
)
.
'
key
=
=
=
'
outletState
'
)
)
;
this
.
outletState
=
value
;
return
value
;
}
;
return
DynamicScope
;
}
(
)
;
var
RootState
=
function
(
)
{
function
RootState
(
root
env
template
self
parentElement
dynamicScope
)
{
var
_this
=
this
;
(
0
_emberBabel
.
classCallCheck
)
(
this
RootState
)
;
(
true
&
&
!
(
template
!
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
render
'
+
self
.
value
(
)
+
'
without
a
template
.
'
template
!
=
=
undefined
)
)
;
this
.
id
=
(
0
_emberViews
.
getViewId
)
(
root
)
;
this
.
env
=
env
;
this
.
root
=
root
;
this
.
result
=
undefined
;
this
.
shouldReflush
=
false
;
this
.
destroyed
=
false
;
var
options
=
this
.
options
=
{
alwaysRevalidate
:
false
}
;
this
.
render
=
function
(
)
{
var
iterator
=
template
.
render
(
self
parentElement
dynamicScope
)
;
var
iteratorResult
=
void
0
;
do
{
iteratorResult
=
iterator
.
next
(
)
;
}
while
(
!
iteratorResult
.
done
)
;
var
result
=
_this
.
result
=
iteratorResult
.
value
;
_this
.
render
=
function
(
)
{
return
result
.
rerender
(
options
)
;
}
;
}
;
}
RootState
.
prototype
.
isFor
=
function
isFor
(
possibleRoot
)
{
return
this
.
root
=
=
=
possibleRoot
;
}
;
RootState
.
prototype
.
destroy
=
function
destroy
(
)
{
var
result
=
this
.
result
env
=
this
.
env
;
this
.
destroyed
=
true
;
this
.
env
=
undefined
;
this
.
root
=
null
;
this
.
result
=
undefined
;
this
.
render
=
undefined
;
if
(
result
)
{
var
needsTransaction
=
!
env
.
inTransaction
;
if
(
needsTransaction
)
{
env
.
begin
(
)
;
}
result
.
destroy
(
)
;
if
(
needsTransaction
)
{
env
.
commit
(
)
;
}
}
}
;
return
RootState
;
}
(
)
;
var
renderers
=
[
]
;
function
_resetRenderers
(
)
{
renderers
.
length
=
0
;
}
(
0
_emberMetal
.
setHasViews
)
(
function
(
)
{
return
renderers
.
length
>
0
;
}
)
;
function
register
(
renderer
)
{
(
true
&
&
!
(
renderers
.
indexOf
(
renderer
)
=
=
=
-
1
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
register
the
same
renderer
twice
'
renderers
.
indexOf
(
renderer
)
=
=
=
-
1
)
)
;
renderers
.
push
(
renderer
)
;
}
function
deregister
(
renderer
)
{
var
index
=
renderers
.
indexOf
(
renderer
)
;
(
true
&
&
!
(
index
!
=
=
-
1
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
deregister
unknown
unregistered
renderer
'
index
!
=
=
-
1
)
)
;
renderers
.
splice
(
index
1
)
;
}
function
loopBegin
(
)
{
for
(
var
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
renderers
[
i
]
.
_scheduleRevalidate
(
)
;
}
}
function
K
(
)
{
}
var
renderSettledDeferred
=
null
;
function
renderSettled
(
)
{
if
(
renderSettledDeferred
=
=
=
null
)
{
renderSettledDeferred
=
_rsvp
.
default
.
defer
(
)
;
if
(
!
_emberMetal
.
run
.
currentRunLoop
)
{
backburner
.
schedule
(
'
actions
'
null
K
)
;
}
}
return
renderSettledDeferred
.
promise
;
}
function
resolveRenderPromise
(
)
{
if
(
renderSettledDeferred
!
=
=
null
)
{
var
resolve
=
renderSettledDeferred
.
resolve
;
renderSettledDeferred
=
null
;
backburner
.
join
(
null
resolve
)
;
}
}
var
loops
=
0
;
function
loopEnd
(
)
{
for
(
var
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
if
(
!
renderers
[
i
]
.
_isValid
(
)
)
{
if
(
loops
>
10
)
{
loops
=
0
;
renderers
[
i
]
.
destroy
(
)
;
throw
new
Error
(
'
infinite
rendering
invalidation
detected
'
)
;
}
loops
+
+
;
return
backburner
.
join
(
null
K
)
;
}
}
loops
=
0
;
resolveRenderPromise
(
)
;
}
backburner
.
on
(
'
begin
'
loopBegin
)
;
backburner
.
on
(
'
end
'
loopEnd
)
;
var
Renderer
=
exports
.
Renderer
=
function
(
)
{
function
Renderer
(
env
rootTemplate
)
{
var
_viewRegistry
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
_emberViews
.
fallbackViewRegistry
;
var
destinedForDOM
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
false
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Renderer
)
;
this
.
_env
=
env
;
this
.
_rootTemplate
=
rootTemplate
;
this
.
_viewRegistry
=
_viewRegistry
;
this
.
_destinedForDOM
=
destinedForDOM
;
this
.
_destroyed
=
false
;
this
.
_roots
=
[
]
;
this
.
_lastRevision
=
-
1
;
this
.
_isRenderingRoots
=
false
;
this
.
_removedRoots
=
[
]
;
}
Renderer
.
prototype
.
appendOutletView
=
function
appendOutletView
(
view
target
)
{
var
definition
=
new
_outlet
.
TopLevelOutletComponentDefinition
(
view
)
;
var
outletStateReference
=
view
.
toReference
(
)
;
this
.
_appendDefinition
(
view
definition
target
outletStateReference
)
;
}
;
Renderer
.
prototype
.
appendTo
=
function
appendTo
(
view
target
)
{
var
rootDef
=
new
_root2
.
RootComponentDefinition
(
view
)
;
this
.
_appendDefinition
(
view
rootDef
target
)
;
}
;
Renderer
.
prototype
.
_appendDefinition
=
function
_appendDefinition
(
root
definition
target
outletStateReference
)
{
var
self
=
new
_references
.
RootReference
(
definition
)
;
var
dynamicScope
=
new
DynamicScope
(
null
outletStateReference
|
|
_runtime
.
NULL_REFERENCE
outletStateReference
)
;
var
rootState
=
new
RootState
(
root
this
.
_env
this
.
_rootTemplate
self
target
dynamicScope
)
;
this
.
_renderRoot
(
rootState
)
;
}
;
Renderer
.
prototype
.
rerender
=
function
rerender
(
)
{
this
.
_scheduleRevalidate
(
)
;
}
;
Renderer
.
prototype
.
register
=
function
register
(
view
)
{
var
id
=
(
0
_emberViews
.
getViewId
)
(
view
)
;
(
true
&
&
!
(
!
this
.
_viewRegistry
[
id
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Attempted
to
register
a
view
with
an
id
already
in
use
:
'
+
id
!
this
.
_viewRegistry
[
id
]
)
)
;
this
.
_viewRegistry
[
id
]
=
view
;
}
;
Renderer
.
prototype
.
unregister
=
function
unregister
(
view
)
{
delete
this
.
_viewRegistry
[
(
0
_emberViews
.
getViewId
)
(
view
)
]
;
}
;
Renderer
.
prototype
.
remove
=
function
remove
(
view
)
{
view
.
_transitionTo
(
'
destroying
'
)
;
this
.
cleanupRootFor
(
view
)
;
(
0
_emberViews
.
setViewElement
)
(
view
null
)
;
if
(
this
.
_destinedForDOM
)
{
view
.
trigger
(
'
didDestroyElement
'
)
;
}
if
(
!
view
.
isDestroying
)
{
view
.
destroy
(
)
;
}
}
;
Renderer
.
prototype
.
cleanupRootFor
=
function
cleanupRootFor
(
view
)
{
if
(
this
.
_destroyed
)
{
return
;
}
var
roots
=
this
.
_roots
;
var
i
=
this
.
_roots
.
length
;
while
(
i
-
-
)
{
var
root
=
roots
[
i
]
;
if
(
root
.
isFor
(
view
)
)
{
root
.
destroy
(
)
;
roots
.
splice
(
i
1
)
;
}
}
}
;
Renderer
.
prototype
.
destroy
=
function
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
this
.
_clearAllRoots
(
)
;
}
;
Renderer
.
prototype
.
getBounds
=
function
getBounds
(
view
)
{
var
bounds
=
view
[
_component
.
BOUNDS
]
;
var
parentElement
=
bounds
.
parentElement
(
)
;
var
firstNode
=
bounds
.
firstNode
(
)
;
var
lastNode
=
bounds
.
lastNode
(
)
;
return
{
parentElement
:
parentElement
firstNode
:
firstNode
lastNode
:
lastNode
}
;
}
;
Renderer
.
prototype
.
createElement
=
function
createElement
(
tagName
)
{
return
this
.
_env
.
getAppendOperations
(
)
.
createElement
(
tagName
)
;
}
;
Renderer
.
prototype
.
_renderRoot
=
function
_renderRoot
(
root
)
{
var
roots
=
this
.
_roots
;
roots
.
push
(
root
)
;
if
(
roots
.
length
=
=
=
1
)
{
register
(
this
)
;
}
this
.
_renderRootsTransaction
(
)
;
}
;
Renderer
.
prototype
.
_renderRoots
=
function
_renderRoots
(
)
{
var
roots
=
this
.
_roots
env
=
this
.
_env
removedRoots
=
this
.
_removedRoots
;
var
globalShouldReflush
=
void
0
;
var
initialRootsLength
=
void
0
;
do
{
env
.
begin
(
)
;
initialRootsLength
=
roots
.
length
;
globalShouldReflush
=
false
;
for
(
var
i
=
0
;
i
<
roots
.
length
;
i
+
+
)
{
var
root
=
roots
[
i
]
;
if
(
root
.
destroyed
)
{
removedRoots
.
push
(
root
)
;
continue
;
}
var
shouldReflush
=
root
.
shouldReflush
;
if
(
i
>
=
initialRootsLength
&
&
!
shouldReflush
)
{
continue
;
}
root
.
options
.
alwaysRevalidate
=
shouldReflush
;
shouldReflush
=
root
.
shouldReflush
=
(
0
_emberMetal
.
runInTransaction
)
(
root
'
render
'
)
;
globalShouldReflush
=
globalShouldReflush
|
|
shouldReflush
;
}
this
.
_lastRevision
=
_reference
.
CURRENT_TAG
.
value
(
)
;
env
.
commit
(
)
;
}
while
(
globalShouldReflush
|
|
roots
.
length
>
initialRootsLength
)
;
while
(
removedRoots
.
length
)
{
var
_root
=
removedRoots
.
pop
(
)
;
var
rootIndex
=
roots
.
indexOf
(
_root
)
;
roots
.
splice
(
rootIndex
1
)
;
}
if
(
this
.
_roots
.
length
=
=
=
0
)
{
deregister
(
this
)
;
}
}
;
Renderer
.
prototype
.
_renderRootsTransaction
=
function
_renderRootsTransaction
(
)
{
if
(
this
.
_isRenderingRoots
)
{
return
;
}
this
.
_isRenderingRoots
=
true
;
var
completedWithoutError
=
false
;
try
{
this
.
_renderRoots
(
)
;
completedWithoutError
=
true
;
}
finally
{
if
(
!
completedWithoutError
)
{
this
.
_lastRevision
=
_reference
.
CURRENT_TAG
.
value
(
)
;
if
(
this
.
_env
.
inTransaction
=
=
=
true
)
{
this
.
_env
.
commit
(
)
;
}
}
this
.
_isRenderingRoots
=
false
;
}
}
;
Renderer
.
prototype
.
_clearAllRoots
=
function
_clearAllRoots
(
)
{
var
roots
=
this
.
_roots
;
for
(
var
i
=
0
;
i
<
roots
.
length
;
i
+
+
)
{
var
root
=
roots
[
i
]
;
root
.
destroy
(
)
;
}
this
.
_removedRoots
.
length
=
0
;
this
.
_roots
=
[
]
;
if
(
roots
.
length
)
{
deregister
(
this
)
;
}
}
;
Renderer
.
prototype
.
_scheduleRevalidate
=
function
_scheduleRevalidate
(
)
{
backburner
.
scheduleOnce
(
'
render
'
this
this
.
_revalidate
)
;
}
;
Renderer
.
prototype
.
_isValid
=
function
_isValid
(
)
{
return
this
.
_destroyed
|
|
this
.
_roots
.
length
=
=
=
0
|
|
_reference
.
CURRENT_TAG
.
validate
(
this
.
_lastRevision
)
;
}
;
Renderer
.
prototype
.
_revalidate
=
function
_revalidate
(
)
{
if
(
this
.
_isValid
(
)
)
{
return
;
}
this
.
_renderRootsTransaction
(
)
;
}
;
return
Renderer
;
}
(
)
;
var
InertRenderer
=
exports
.
InertRenderer
=
function
(
_Renderer
)
{
(
0
_emberBabel
.
inherits
)
(
InertRenderer
_Renderer
)
;
function
InertRenderer
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
InertRenderer
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Renderer
.
apply
(
this
arguments
)
)
;
}
InertRenderer
.
create
=
function
create
(
_ref
)
{
var
env
=
_ref
.
env
rootTemplate
=
_ref
.
rootTemplate
_viewRegistry
=
_ref
.
_viewRegistry
;
return
new
this
(
env
rootTemplate
_viewRegistry
false
)
;
}
;
InertRenderer
.
prototype
.
getElement
=
function
getElement
(
_view
)
{
throw
new
Error
(
'
Accessing
this
.
element
is
not
allowed
in
non
-
interactive
environments
(
such
as
FastBoot
)
.
'
)
;
}
;
return
InertRenderer
;
}
(
Renderer
)
;
var
InteractiveRenderer
=
exports
.
InteractiveRenderer
=
function
(
_Renderer2
)
{
(
0
_emberBabel
.
inherits
)
(
InteractiveRenderer
_Renderer2
)
;
function
InteractiveRenderer
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
InteractiveRenderer
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Renderer2
.
apply
(
this
arguments
)
)
;
}
InteractiveRenderer
.
create
=
function
create
(
_ref2
)
{
var
env
=
_ref2
.
env
rootTemplate
=
_ref2
.
rootTemplate
_viewRegistry
=
_ref2
.
_viewRegistry
;
return
new
this
(
env
rootTemplate
_viewRegistry
true
)
;
}
;
InteractiveRenderer
.
prototype
.
getElement
=
function
getElement
(
view
)
{
return
(
0
_emberViews
.
getViewElement
)
(
view
)
;
}
;
return
InteractiveRenderer
;
}
(
Renderer
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
setup
-
registry
'
[
'
exports
'
'
ember
-
babel
'
'
container
'
'
ember
-
environment
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
components
/
checkbox
'
'
ember
-
glimmer
/
components
/
link
-
to
'
'
ember
-
glimmer
/
components
/
text_area
'
'
ember
-
glimmer
/
components
/
text_field
'
'
ember
-
glimmer
/
dom
'
'
ember
-
glimmer
/
environment
'
'
ember
-
glimmer
/
renderer
'
'
ember
-
glimmer
/
templates
/
component
'
'
ember
-
glimmer
/
templates
/
outlet
'
'
ember
-
glimmer
/
templates
/
root
'
'
ember
-
glimmer
/
views
/
outlet
'
'
ember
-
glimmer
/
helpers
/
loc
'
'
ember
/
features
'
]
function
(
exports
_emberBabel
_container
_emberEnvironment
_component
_checkbox
_linkTo
_text_area
_text_field
_dom
_environment
_renderer
_component2
_outlet
_root
_outlet2
_loc
_features
)
{
'
use
strict
'
;
exports
.
setupApplicationRegistry
=
setupApplicationRegistry
;
exports
.
setupEngineRegistry
=
setupEngineRegistry
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
template
:
-
root
'
]
[
'
template
:
-
root
'
]
)
_templateObject2
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
template
:
components
/
-
default
'
]
[
'
template
:
components
/
-
default
'
]
)
_templateObject3
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
component
:
-
default
'
]
[
'
component
:
-
default
'
]
)
;
function
setupApplicationRegistry
(
registry
)
{
registry
.
injection
(
'
service
:
-
glimmer
-
environment
'
'
appendOperations
'
'
service
:
-
dom
-
tree
-
construction
'
)
;
registry
.
injection
(
'
renderer
'
'
env
'
'
service
:
-
glimmer
-
environment
'
)
;
registry
.
register
(
(
0
_container
.
privatize
)
(
_templateObject
)
_root
.
default
)
;
registry
.
injection
(
'
renderer
'
'
rootTemplate
'
(
0
_container
.
privatize
)
(
_templateObject
)
)
;
registry
.
register
(
'
renderer
:
-
dom
'
_renderer
.
InteractiveRenderer
)
;
registry
.
register
(
'
renderer
:
-
inert
'
_renderer
.
InertRenderer
)
;
if
(
_emberEnvironment
.
environment
.
hasDOM
)
{
registry
.
injection
(
'
service
:
-
glimmer
-
environment
'
'
updateOperations
'
'
service
:
-
dom
-
changes
'
)
;
}
registry
.
register
(
'
service
:
-
dom
-
changes
'
{
create
:
function
(
_ref
)
{
var
document
=
_ref
.
document
;
return
new
_dom
.
DOMChanges
(
document
)
;
}
}
)
;
registry
.
register
(
'
service
:
-
dom
-
tree
-
construction
'
{
create
:
function
(
_ref2
)
{
var
document
=
_ref2
.
document
;
var
Implementation
=
_emberEnvironment
.
environment
.
hasDOM
?
_dom
.
DOMTreeConstruction
:
_dom
.
NodeDOMTreeConstruction
;
return
new
Implementation
(
document
)
;
}
}
)
;
}
function
setupEngineRegistry
(
registry
)
{
registry
.
register
(
'
view
:
-
outlet
'
_outlet2
.
default
)
;
registry
.
register
(
'
template
:
-
outlet
'
_outlet
.
default
)
;
registry
.
injection
(
'
view
:
-
outlet
'
'
template
'
'
template
:
-
outlet
'
)
;
registry
.
injection
(
'
service
:
-
dom
-
changes
'
'
document
'
'
service
:
-
document
'
)
;
registry
.
injection
(
'
service
:
-
dom
-
tree
-
construction
'
'
document
'
'
service
:
-
document
'
)
;
registry
.
register
(
(
0
_container
.
privatize
)
(
_templateObject2
)
_component2
.
default
)
;
registry
.
register
(
'
service
:
-
glimmer
-
environment
'
_environment
.
default
)
;
registry
.
injection
(
'
template
'
'
env
'
'
service
:
-
glimmer
-
environment
'
)
;
registry
.
optionsForType
(
'
helper
'
{
instantiate
:
false
}
)
;
registry
.
register
(
'
helper
:
loc
'
_loc
.
default
)
;
registry
.
register
(
'
component
:
-
text
-
field
'
_text_field
.
default
)
;
registry
.
register
(
'
component
:
-
text
-
area
'
_text_area
.
default
)
;
registry
.
register
(
'
component
:
-
checkbox
'
_checkbox
.
default
)
;
registry
.
register
(
'
component
:
link
-
to
'
_linkTo
.
default
)
;
if
(
!
_features
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
)
{
registry
.
register
(
(
0
_container
.
privatize
)
(
_templateObject3
)
_component
.
default
)
;
}
}
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
environment
'
'
ember
-
glimmer
/
syntax
/
-
text
-
area
'
'
ember
-
glimmer
/
syntax
/
dynamic
-
component
'
'
ember
-
glimmer
/
syntax
/
input
'
'
ember
-
glimmer
/
syntax
/
mount
'
'
ember
-
glimmer
/
syntax
/
outlet
'
'
ember
-
glimmer
/
syntax
/
render
'
'
ember
-
glimmer
/
syntax
/
utils
'
'
ember
-
glimmer
/
utils
/
bindings
'
]
function
(
exports
_emberDebug
_emberEnvironment
_textArea
_dynamicComponent
_input
_mount
_outlet
_render
_utils
_bindings
)
{
'
use
strict
'
;
exports
.
experimentalMacros
=
undefined
;
exports
.
registerMacros
=
registerMacros
;
exports
.
populateMacros
=
populateMacros
;
function
refineInlineSyntax
(
name
params
hash
builder
)
{
(
true
&
&
!
(
!
(
builder
.
env
.
builtInHelpers
[
name
]
&
&
builder
.
env
.
owner
.
hasRegistration
(
'
helper
:
'
+
name
)
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
attempted
to
overwrite
the
built
-
in
helper
"
'
+
name
+
'
"
which
is
not
allowed
.
Please
rename
the
helper
.
'
!
(
builder
.
env
.
builtInHelpers
[
name
]
&
&
builder
.
env
.
owner
.
hasRegistration
(
'
helper
:
'
+
name
)
)
)
)
;
var
definition
=
void
0
;
if
(
name
.
indexOf
(
'
-
'
)
>
-
1
)
{
definition
=
builder
.
env
.
getComponentDefinition
(
name
builder
.
meta
.
templateMeta
)
;
}
if
(
definition
)
{
(
0
_bindings
.
wrapComponentClassAttribute
)
(
hash
)
;
builder
.
component
.
static
(
definition
[
params
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
)
;
return
true
;
}
return
false
;
}
function
refineBlockSyntax
(
name
params
hash
_default
inverse
builder
)
{
if
(
name
.
indexOf
(
'
-
'
)
=
=
=
-
1
)
{
return
false
;
}
var
meta
=
builder
.
meta
.
templateMeta
;
var
definition
=
void
0
;
if
(
name
.
indexOf
(
'
-
'
)
>
-
1
)
{
definition
=
builder
.
env
.
getComponentDefinition
(
name
meta
)
;
}
if
(
definition
)
{
(
0
_bindings
.
wrapComponentClassAttribute
)
(
hash
)
;
builder
.
component
.
static
(
definition
[
params
(
0
_utils
.
hashToArgs
)
(
hash
)
_default
inverse
]
)
;
return
true
;
}
(
true
&
&
!
(
builder
.
env
.
hasHelper
(
name
meta
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
A
component
or
helper
named
"
'
+
name
+
'
"
could
not
be
found
'
builder
.
env
.
hasHelper
(
name
meta
)
)
)
;
(
true
&
&
!
(
!
builder
.
env
.
hasHelper
(
name
meta
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Helpers
may
not
be
used
in
the
block
form
for
example
{
{
#
'
+
name
+
'
}
}
{
{
/
'
+
name
+
'
}
}
.
Please
use
a
component
or
alternatively
use
the
helper
in
combination
with
a
built
-
in
Ember
helper
for
example
{
{
#
if
(
'
+
name
+
'
)
}
}
{
{
/
if
}
}
.
'
!
builder
.
env
.
hasHelper
(
name
meta
)
)
)
;
return
false
;
}
var
experimentalMacros
=
exports
.
experimentalMacros
=
[
]
;
function
registerMacros
(
macro
)
{
experimentalMacros
.
push
(
macro
)
;
}
function
populateMacros
(
blocks
inlines
)
{
inlines
.
add
(
'
outlet
'
_outlet
.
outletMacro
)
;
inlines
.
add
(
'
component
'
_dynamicComponent
.
inlineComponentMacro
)
;
if
(
_emberEnvironment
.
ENV
.
_ENABLE_RENDER_SUPPORT
=
=
=
true
)
{
inlines
.
add
(
'
render
'
_render
.
renderMacro
)
;
}
inlines
.
add
(
'
mount
'
_mount
.
mountMacro
)
;
inlines
.
add
(
'
input
'
_input
.
inputMacro
)
;
inlines
.
add
(
'
textarea
'
_textArea
.
textAreaMacro
)
;
inlines
.
addMissing
(
refineInlineSyntax
)
;
blocks
.
add
(
'
component
'
_dynamicComponent
.
blockComponentMacro
)
;
blocks
.
addMissing
(
refineBlockSyntax
)
;
for
(
var
i
=
0
;
i
<
experimentalMacros
.
length
;
i
+
+
)
{
var
macro
=
experimentalMacros
[
i
]
;
macro
(
blocks
inlines
)
;
}
return
{
blocks
:
blocks
inlines
:
inlines
}
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
-
text
-
area
'
[
'
exports
'
'
ember
-
glimmer
/
utils
/
bindings
'
'
ember
-
glimmer
/
syntax
/
utils
'
]
function
(
exports
_bindings
_utils
)
{
'
use
strict
'
;
exports
.
textAreaMacro
=
textAreaMacro
;
function
textAreaMacro
(
_name
params
hash
builder
)
{
var
definition
=
builder
.
env
.
getComponentDefinition
(
'
-
text
-
area
'
builder
.
meta
.
templateMeta
)
;
(
0
_bindings
.
wrapComponentClassAttribute
)
(
hash
)
;
builder
.
component
.
static
(
definition
[
params
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
)
;
return
true
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
dynamic
-
component
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
debug
'
'
ember
-
glimmer
/
syntax
/
utils
'
]
function
(
exports
_emberBabel
_runtime
_emberDebug
_utils
)
{
'
use
strict
'
;
exports
.
dynamicComponentMacro
=
dynamicComponentMacro
;
exports
.
blockComponentMacro
=
blockComponentMacro
;
exports
.
inlineComponentMacro
=
inlineComponentMacro
;
function
dynamicComponentFor
(
vm
args
meta
)
{
var
env
=
vm
.
env
;
var
nameRef
=
args
.
positional
.
at
(
0
)
;
return
new
DynamicComponentReference
(
{
nameRef
:
nameRef
env
:
env
meta
:
meta
args
:
null
}
)
;
}
function
dynamicComponentMacro
(
params
hash
_default
_inverse
builder
)
{
var
definitionArgs
=
[
params
.
slice
(
0
1
)
null
null
null
]
;
var
args
=
[
params
.
slice
(
1
)
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
;
builder
.
component
.
dynamic
(
definitionArgs
dynamicComponentFor
args
)
;
return
true
;
}
function
blockComponentMacro
(
params
hash
_default
inverse
builder
)
{
var
definitionArgs
=
[
params
.
slice
(
0
1
)
null
null
null
]
;
var
args
=
[
params
.
slice
(
1
)
(
0
_utils
.
hashToArgs
)
(
hash
)
_default
inverse
]
;
builder
.
component
.
dynamic
(
definitionArgs
dynamicComponentFor
args
)
;
return
true
;
}
function
inlineComponentMacro
(
_name
params
hash
builder
)
{
var
definitionArgs
=
[
params
.
slice
(
0
1
)
null
null
null
]
;
var
args
=
[
params
.
slice
(
1
)
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
;
builder
.
component
.
dynamic
(
definitionArgs
dynamicComponentFor
args
)
;
return
true
;
}
var
DynamicComponentReference
=
function
(
)
{
function
DynamicComponentReference
(
_ref
)
{
var
nameRef
=
_ref
.
nameRef
env
=
_ref
.
env
meta
=
_ref
.
meta
args
=
_ref
.
args
;
(
0
_emberBabel
.
classCallCheck
)
(
this
DynamicComponentReference
)
;
this
.
tag
=
nameRef
.
tag
;
this
.
nameRef
=
nameRef
;
this
.
env
=
env
;
this
.
meta
=
meta
;
this
.
args
=
args
;
}
DynamicComponentReference
.
prototype
.
value
=
function
value
(
)
{
var
env
=
this
.
env
nameRef
=
this
.
nameRef
meta
=
this
.
meta
;
var
nameOrDef
=
nameRef
.
value
(
)
;
if
(
typeof
nameOrDef
=
=
=
'
string
'
)
{
var
definition
=
env
.
getComponentDefinition
(
nameOrDef
meta
)
;
(
true
&
&
!
(
!
!
definition
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Could
not
find
component
named
"
'
+
nameOrDef
+
'
"
(
no
component
or
template
with
that
name
was
found
)
'
!
!
definition
)
)
;
return
definition
;
}
else
if
(
(
0
_runtime
.
isComponentDefinition
)
(
nameOrDef
)
)
{
return
nameOrDef
;
}
else
{
return
null
;
}
}
;
DynamicComponentReference
.
prototype
.
get
=
function
get
(
)
{
}
;
return
DynamicComponentReference
;
}
(
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
input
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
glimmer
/
utils
/
bindings
'
'
ember
-
glimmer
/
syntax
/
dynamic
-
component
'
'
ember
-
glimmer
/
syntax
/
utils
'
]
function
(
exports
_emberDebug
_bindings
_dynamicComponent
_utils
)
{
'
use
strict
'
;
exports
.
inputMacro
=
inputMacro
;
function
buildSyntax
(
type
params
hash
builder
)
{
var
definition
=
builder
.
env
.
getComponentDefinition
(
type
builder
.
meta
.
templateMeta
)
;
builder
.
component
.
static
(
definition
[
params
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
)
;
return
true
;
}
function
inputMacro
(
_name
params
hash
builder
)
{
var
keys
=
void
0
;
var
values
=
void
0
;
var
typeIndex
=
-
1
;
var
valueIndex
=
-
1
;
if
(
hash
)
{
keys
=
hash
[
0
]
;
values
=
hash
[
1
]
;
typeIndex
=
keys
.
indexOf
(
'
type
'
)
;
valueIndex
=
keys
.
indexOf
(
'
value
'
)
;
}
if
(
!
params
)
{
params
=
[
]
;
}
if
(
typeIndex
>
-
1
)
{
var
typeArg
=
values
[
typeIndex
]
;
if
(
Array
.
isArray
(
typeArg
)
)
{
return
(
0
_dynamicComponent
.
dynamicComponentMacro
)
(
params
hash
null
null
builder
)
;
}
else
if
(
typeArg
=
=
=
'
checkbox
'
)
{
(
true
&
&
!
(
valueIndex
=
=
=
-
1
)
&
&
(
0
_emberDebug
.
assert
)
(
'
{
{
input
type
=
\
'
checkbox
\
'
}
}
does
not
support
setting
value
=
someBooleanValue
;
'
+
'
you
must
use
checked
=
someBooleanValue
instead
.
'
valueIndex
=
=
=
-
1
)
)
;
(
0
_bindings
.
wrapComponentClassAttribute
)
(
hash
)
;
return
buildSyntax
(
'
-
checkbox
'
params
hash
builder
)
;
}
}
return
buildSyntax
(
'
-
text
-
field
'
params
hash
builder
)
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
mount
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
debug
'
'
ember
/
features
'
'
ember
-
glimmer
/
component
-
managers
/
mount
'
'
ember
-
glimmer
/
syntax
/
utils
'
]
function
(
exports
_emberBabel
_emberDebug
_features
_mount
_utils
)
{
'
use
strict
'
;
exports
.
mountMacro
=
mountMacro
;
function
dynamicEngineFor
(
vm
args
meta
)
{
var
env
=
vm
.
env
;
var
nameRef
=
args
.
positional
.
at
(
0
)
;
return
new
DynamicEngineReference
(
{
nameRef
:
nameRef
env
:
env
meta
:
meta
}
)
;
}
function
mountMacro
(
_name
params
hash
builder
)
{
if
(
_features
.
EMBER_ENGINES_MOUNT_PARAMS
)
{
(
true
&
&
!
(
params
.
length
=
=
=
1
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
can
only
pass
a
single
positional
argument
to
the
{
{
mount
}
}
helper
e
.
g
.
{
{
mount
"
chat
-
engine
"
}
}
.
'
params
.
length
=
=
=
1
)
)
;
}
else
{
(
true
&
&
!
(
params
.
length
=
=
=
1
&
&
hash
=
=
=
null
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
can
only
pass
a
single
argument
to
the
{
{
mount
}
}
helper
e
.
g
.
{
{
mount
"
chat
-
engine
"
}
}
.
'
params
.
length
=
=
=
1
&
&
hash
=
=
=
null
)
)
;
}
var
definitionArgs
=
[
params
.
slice
(
0
1
)
null
null
null
]
;
var
args
=
[
null
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
;
builder
.
component
.
dynamic
(
definitionArgs
dynamicEngineFor
args
)
;
return
true
;
}
var
DynamicEngineReference
=
function
(
)
{
function
DynamicEngineReference
(
_ref
)
{
var
nameRef
=
_ref
.
nameRef
env
=
_ref
.
env
meta
=
_ref
.
meta
;
(
0
_emberBabel
.
classCallCheck
)
(
this
DynamicEngineReference
)
;
this
.
tag
=
nameRef
.
tag
;
this
.
nameRef
=
nameRef
;
this
.
env
=
env
;
this
.
meta
=
meta
;
this
.
_lastName
=
undefined
;
this
.
_lastDef
=
undefined
;
}
DynamicEngineReference
.
prototype
.
value
=
function
value
(
)
{
var
env
=
this
.
env
nameRef
=
this
.
nameRef
;
var
nameOrDef
=
nameRef
.
value
(
)
;
if
(
typeof
nameOrDef
=
=
=
'
string
'
)
{
if
(
this
.
_lastName
=
=
=
nameOrDef
)
{
return
this
.
_lastDef
;
}
(
true
&
&
!
(
env
.
owner
.
hasRegistration
(
'
engine
:
'
+
nameOrDef
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
used
{
{
mount
\
'
'
+
nameOrDef
+
'
\
'
}
}
but
the
engine
\
'
'
+
nameOrDef
+
'
\
'
can
not
be
found
.
'
env
.
owner
.
hasRegistration
(
'
engine
:
'
+
nameOrDef
)
)
)
;
if
(
!
env
.
owner
.
hasRegistration
(
'
engine
:
'
+
nameOrDef
)
)
{
return
null
;
}
this
.
_lastName
=
nameOrDef
;
this
.
_lastDef
=
new
_mount
.
MountDefinition
(
nameOrDef
)
;
return
this
.
_lastDef
;
}
else
{
(
true
&
&
!
(
nameOrDef
=
=
=
null
|
|
nameOrDef
=
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Invalid
engine
name
\
'
'
+
nameOrDef
+
'
\
'
specified
engine
name
must
be
either
a
string
null
or
undefined
.
'
nameOrDef
=
=
=
null
|
|
nameOrDef
=
=
=
undefined
)
)
;
return
null
;
}
}
;
return
DynamicEngineReference
;
}
(
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
outlet
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
glimmer
/
component
-
managers
/
outlet
'
]
function
(
exports
_emberBabel
_reference
_outlet
)
{
'
use
strict
'
;
exports
.
outletMacro
=
outletMacro
;
var
OutletComponentReference
=
function
(
)
{
function
OutletComponentReference
(
outletNameRef
parentOutletStateRef
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OutletComponentReference
)
;
this
.
outletNameRef
=
outletNameRef
;
this
.
parentOutletStateRef
=
parentOutletStateRef
;
this
.
definition
=
null
;
this
.
lastState
=
null
;
var
outletStateTag
=
this
.
outletStateTag
=
_reference
.
UpdatableTag
.
create
(
parentOutletStateRef
.
tag
)
;
this
.
tag
=
(
0
_reference
.
combine
)
(
[
outletStateTag
.
inner
outletNameRef
.
tag
]
)
;
}
OutletComponentReference
.
prototype
.
value
=
function
value
(
)
{
var
outletNameRef
=
this
.
outletNameRef
parentOutletStateRef
=
this
.
parentOutletStateRef
definition
=
this
.
definition
lastState
=
this
.
lastState
;
var
outletName
=
outletNameRef
.
value
(
)
;
var
outletStateRef
=
parentOutletStateRef
.
get
(
'
outlets
'
)
.
get
(
outletName
)
;
var
newState
=
this
.
lastState
=
outletStateRef
.
value
(
)
;
this
.
outletStateTag
.
inner
.
update
(
outletStateRef
.
tag
)
;
definition
=
revalidate
(
definition
lastState
newState
)
;
var
hasTemplate
=
newState
&
&
newState
.
render
.
template
;
if
(
definition
)
{
return
definition
;
}
else
if
(
hasTemplate
)
{
return
this
.
definition
=
new
_outlet
.
OutletComponentDefinition
(
outletName
newState
.
render
.
template
)
;
}
else
{
return
this
.
definition
=
null
;
}
}
;
return
OutletComponentReference
;
}
(
)
;
function
revalidate
(
definition
lastState
newState
)
{
if
(
!
lastState
&
&
!
newState
)
{
return
definition
;
}
if
(
!
lastState
&
&
newState
|
|
lastState
&
&
!
newState
)
{
return
null
;
}
if
(
newState
.
render
.
template
=
=
=
lastState
.
render
.
template
&
&
newState
.
render
.
controller
=
=
=
lastState
.
render
.
controller
)
{
return
definition
;
}
return
null
;
}
function
outletComponentFor
(
vm
args
)
{
var
_vm
dynamicScope
=
vm
.
dynamicScope
(
)
outletState
=
_vm
dynamicScope
.
outletState
;
var
outletNameRef
=
void
0
;
if
(
args
.
positional
.
length
=
=
=
0
)
{
outletNameRef
=
new
_reference
.
ConstReference
(
'
main
'
)
;
}
else
{
outletNameRef
=
args
.
positional
.
at
(
0
)
;
}
return
new
OutletComponentReference
(
outletNameRef
outletState
)
;
}
function
outletMacro
(
_name
params
_hash
builder
)
{
if
(
!
params
)
{
params
=
[
]
;
}
var
definitionArgs
=
[
params
.
slice
(
0
1
)
null
null
null
]
;
var
emptyArgs
=
[
[
]
null
null
null
]
;
builder
.
component
.
dynamic
(
definitionArgs
outletComponentFor
emptyArgs
)
;
return
true
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
syntax
/
render
'
[
'
exports
'
'
glimmer
/
reference
'
'
ember
-
debug
'
'
ember
-
glimmer
/
component
-
managers
/
render
'
'
ember
-
glimmer
/
syntax
/
utils
'
]
function
(
exports
_reference
_emberDebug
_render
_utils
)
{
'
use
strict
'
;
exports
.
renderMacro
=
renderMacro
;
function
makeComponentDefinition
(
vm
args
)
{
var
env
=
vm
.
env
;
var
nameRef
=
args
.
positional
.
at
(
0
)
;
(
true
&
&
!
(
(
0
_reference
.
isConst
)
(
nameRef
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
first
argument
of
{
{
render
}
}
must
be
quoted
e
.
g
.
{
{
render
"
sidebar
"
}
}
.
'
(
0
_reference
.
isConst
)
(
nameRef
)
)
)
;
(
true
&
&
!
(
args
.
positional
.
length
=
=
=
1
|
|
!
(
0
_reference
.
isConst
)
(
args
.
positional
.
at
(
1
)
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
second
argument
of
{
{
render
}
}
must
be
a
path
e
.
g
.
{
{
render
"
post
"
post
}
}
.
'
args
.
positional
.
length
=
=
=
1
|
|
!
(
0
_reference
.
isConst
)
(
args
.
positional
.
at
(
1
)
)
)
)
;
var
templateName
=
nameRef
.
value
(
)
;
(
true
&
&
!
(
env
.
owner
.
hasRegistration
(
'
template
:
'
+
templateName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
used
{
{
render
\
'
'
+
templateName
+
'
\
'
}
}
but
\
'
'
+
templateName
+
'
\
'
can
not
be
found
as
a
template
.
'
env
.
owner
.
hasRegistration
(
'
template
:
'
+
templateName
)
)
)
;
var
template
=
env
.
owner
.
lookup
(
'
template
:
'
+
templateName
)
;
var
controllerName
=
void
0
;
if
(
args
.
named
.
has
(
'
controller
'
)
)
{
var
controllerNameRef
=
args
.
named
.
get
(
'
controller
'
)
;
(
true
&
&
!
(
(
0
_reference
.
isConst
)
(
controllerNameRef
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
controller
argument
for
{
{
render
}
}
must
be
quoted
e
.
g
.
{
{
render
"
sidebar
"
controller
=
"
foo
"
}
}
.
'
(
0
_reference
.
isConst
)
(
controllerNameRef
)
)
)
;
controllerName
=
controllerNameRef
.
value
(
)
;
(
true
&
&
!
(
env
.
owner
.
hasRegistration
(
'
controller
:
'
+
controllerName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
controller
name
you
supplied
\
'
'
+
controllerName
+
'
\
'
did
not
resolve
to
a
controller
.
'
env
.
owner
.
hasRegistration
(
'
controller
:
'
+
controllerName
)
)
)
;
}
else
{
controllerName
=
templateName
;
}
if
(
args
.
positional
.
length
=
=
=
1
)
{
return
new
_reference
.
ConstReference
(
new
_render
.
RenderDefinition
(
controllerName
template
env
_render
.
SINGLETON_RENDER_MANAGER
)
)
;
}
else
{
return
new
_reference
.
ConstReference
(
new
_render
.
RenderDefinition
(
controllerName
template
env
_render
.
NON_SINGLETON_RENDER_MANAGER
)
)
;
}
}
function
renderMacro
(
_name
params
hash
builder
)
{
if
(
!
params
)
{
params
=
[
]
;
}
var
definitionArgs
=
[
params
.
slice
(
0
)
hash
null
null
]
;
var
args
=
[
params
.
slice
(
1
)
(
0
_utils
.
hashToArgs
)
(
hash
)
null
null
]
;
builder
.
component
.
dynamic
(
definitionArgs
makeComponentDefinition
args
)
;
return
true
;
}
}
)
;
enifed
(
"
ember
-
glimmer
/
syntax
/
utils
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
hashToArgs
=
hashToArgs
;
function
hashToArgs
(
hash
)
{
if
(
hash
=
=
=
null
)
{
return
null
;
}
var
names
=
hash
[
0
]
.
map
(
function
(
key
)
{
return
"
"
+
key
;
}
)
;
return
[
names
hash
[
1
]
]
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
template
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
runtime
'
'
ember
-
utils
'
]
function
(
exports
_emberBabel
_runtime
_emberUtils
)
{
'
use
strict
'
;
exports
.
WrappedTemplateFactory
=
undefined
;
exports
.
default
=
template
;
var
WrappedTemplateFactory
=
exports
.
WrappedTemplateFactory
=
function
(
)
{
function
WrappedTemplateFactory
(
factory
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
WrappedTemplateFactory
)
;
this
.
factory
=
factory
;
this
.
id
=
factory
.
id
;
this
.
meta
=
factory
.
meta
;
}
WrappedTemplateFactory
.
prototype
.
create
=
function
create
(
props
)
{
var
owner
=
props
[
_emberUtils
.
OWNER
]
;
return
this
.
factory
.
create
(
props
.
env
{
owner
:
owner
}
)
;
}
;
return
WrappedTemplateFactory
;
}
(
)
;
function
template
(
json
)
{
var
factory
=
(
0
_runtime
.
templateFactory
)
(
json
)
;
return
new
WrappedTemplateFactory
(
factory
)
;
}
}
)
;
enifed
(
"
ember
-
glimmer
/
template_registry
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
setTemplates
=
setTemplates
;
exports
.
getTemplates
=
getTemplates
;
exports
.
getTemplate
=
getTemplate
;
exports
.
hasTemplate
=
hasTemplate
;
exports
.
setTemplate
=
setTemplate
;
var
TEMPLATES
=
{
}
;
function
setTemplates
(
templates
)
{
TEMPLATES
=
templates
;
}
function
getTemplates
(
)
{
return
TEMPLATES
;
}
function
getTemplate
(
name
)
{
if
(
TEMPLATES
.
hasOwnProperty
(
name
)
)
{
return
TEMPLATES
[
name
]
;
}
}
function
hasTemplate
(
name
)
{
return
TEMPLATES
.
hasOwnProperty
(
name
)
;
}
function
setTemplate
(
name
template
)
{
return
TEMPLATES
[
name
]
=
template
;
}
}
)
;
enifed
(
"
ember
-
glimmer
/
templates
/
component
"
[
"
exports
"
"
ember
-
glimmer
/
template
"
]
function
(
exports
_template
)
{
"
use
strict
"
;
exports
.
default
=
(
0
_template
.
default
)
(
{
"
id
"
:
"
RxHsBKwy
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
\
"
&
default
\
"
]
\
"
statements
\
"
:
[
[
11
1
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
packages
/
ember
-
glimmer
/
lib
/
templates
/
component
.
hbs
"
}
}
)
;
}
)
;
enifed
(
"
ember
-
glimmer
/
templates
/
empty
"
[
"
exports
"
"
ember
-
glimmer
/
template
"
]
function
(
exports
_template
)
{
"
use
strict
"
;
exports
.
default
=
(
0
_template
.
default
)
(
{
"
id
"
:
"
5jp2oO
+
o
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
packages
/
ember
-
glimmer
/
lib
/
templates
/
empty
.
hbs
"
}
}
)
;
}
)
;
enifed
(
"
ember
-
glimmer
/
templates
/
link
-
to
"
[
"
exports
"
"
ember
-
glimmer
/
template
"
]
function
(
exports
_template
)
{
"
use
strict
"
;
exports
.
default
=
(
0
_template
.
default
)
(
{
"
id
"
:
"
VZn3uSPL
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
\
"
&
default
\
"
]
\
"
statements
\
"
:
[
[
4
\
"
if
\
"
[
[
20
[
\
"
linkTitle
\
"
]
]
]
null
{
\
"
statements
\
"
:
[
[
1
[
18
\
"
linkTitle
\
"
]
false
]
]
\
"
parameters
\
"
:
[
]
}
{
\
"
statements
\
"
:
[
[
11
1
]
]
\
"
parameters
\
"
:
[
]
}
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
packages
/
ember
-
glimmer
/
lib
/
templates
/
link
-
to
.
hbs
"
}
}
)
;
}
)
;
enifed
(
"
ember
-
glimmer
/
templates
/
outlet
"
[
"
exports
"
"
ember
-
glimmer
/
template
"
]
function
(
exports
_template
)
{
"
use
strict
"
;
exports
.
default
=
(
0
_template
.
default
)
(
{
"
id
"
:
"
/
7rqcQ85
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
[
1
[
18
\
"
outlet
\
"
]
false
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
packages
/
ember
-
glimmer
/
lib
/
templates
/
outlet
.
hbs
"
}
}
)
;
}
)
;
enifed
(
"
ember
-
glimmer
/
templates
/
root
"
[
"
exports
"
"
ember
-
glimmer
/
template
"
]
function
(
exports
_template
)
{
"
use
strict
"
;
exports
.
default
=
(
0
_template
.
default
)
(
{
"
id
"
:
"
AdIsk
/
cm
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
[
1
[
25
\
"
component
\
"
[
[
19
0
[
]
]
]
null
]
false
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
packages
/
ember
-
glimmer
/
lib
/
templates
/
root
.
hbs
"
}
}
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
bindings
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
glimmer
/
wire
-
format
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
utils
/
string
'
]
function
(
exports
_emberBabel
_reference
_wireFormat
_emberDebug
_emberMetal
_emberRuntime
_component
_string
)
{
'
use
strict
'
;
exports
.
ClassNameBinding
=
exports
.
IsVisibleBinding
=
exports
.
AttributeBinding
=
undefined
;
exports
.
wrapComponentClassAttribute
=
wrapComponentClassAttribute
;
function
referenceForKey
(
component
key
)
{
return
component
[
_component
.
ROOT_REF
]
.
get
(
key
)
;
}
function
referenceForParts
(
component
parts
)
{
var
isAttrs
=
parts
[
0
]
=
=
=
'
attrs
'
;
if
(
isAttrs
)
{
parts
.
shift
(
)
;
if
(
parts
.
length
=
=
=
1
)
{
return
referenceForKey
(
component
parts
[
0
]
)
;
}
}
return
(
0
_reference
.
referenceFromParts
)
(
component
[
_component
.
ROOT_REF
]
parts
)
;
}
function
wrapComponentClassAttribute
(
hash
)
{
if
(
!
hash
)
{
return
hash
;
}
var
keys
=
hash
[
0
]
values
=
hash
[
1
]
;
var
index
=
keys
.
indexOf
(
'
class
'
)
;
if
(
index
!
=
=
-
1
)
{
var
_values
index
=
values
[
index
]
type
=
_values
index
[
0
]
;
if
(
type
=
=
=
_wireFormat
.
Ops
.
Get
|
|
type
=
=
=
_wireFormat
.
Ops
.
MaybeLocal
)
{
var
getExp
=
values
[
index
]
;
var
path
=
getExp
[
getExp
.
length
-
1
]
;
var
propName
=
path
[
path
.
length
-
1
]
;
hash
[
1
]
[
index
]
=
[
_wireFormat
.
Ops
.
Helper
[
'
-
class
'
]
[
getExp
propName
]
]
;
}
}
return
hash
;
}
var
AttributeBinding
=
exports
.
AttributeBinding
=
{
parse
:
function
(
microsyntax
)
{
var
colonIndex
=
microsyntax
.
indexOf
(
'
:
'
)
;
if
(
colonIndex
=
=
=
-
1
)
{
(
true
&
&
!
(
microsyntax
!
=
=
'
class
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
class
as
an
attributeBinding
use
classNameBindings
instead
.
'
microsyntax
!
=
=
'
class
'
)
)
;
return
[
microsyntax
microsyntax
true
]
;
}
else
{
var
prop
=
microsyntax
.
substring
(
0
colonIndex
)
;
var
attribute
=
microsyntax
.
substring
(
colonIndex
+
1
)
;
(
true
&
&
!
(
attribute
!
=
=
'
class
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
class
as
an
attributeBinding
use
classNameBindings
instead
.
'
attribute
!
=
=
'
class
'
)
)
;
return
[
prop
attribute
false
]
;
}
}
install
:
function
(
element
component
parsed
operations
)
{
var
prop
=
parsed
[
0
]
attribute
=
parsed
[
1
]
isSimple
=
parsed
[
2
]
;
if
(
attribute
=
=
=
'
id
'
)
{
var
elementId
=
(
0
_emberMetal
.
get
)
(
component
prop
)
;
if
(
elementId
=
=
=
undefined
|
|
elementId
=
=
=
null
)
{
elementId
=
component
.
elementId
;
}
operations
.
addStaticAttribute
(
element
'
id
'
elementId
)
;
return
;
}
var
isPath
=
prop
.
indexOf
(
'
.
'
)
>
-
1
;
var
reference
=
isPath
?
referenceForParts
(
component
prop
.
split
(
'
.
'
)
)
:
referenceForKey
(
component
prop
)
;
(
true
&
&
!
(
!
(
isSimple
&
&
isPath
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Illegal
attributeBinding
:
\
'
'
+
prop
+
'
\
'
is
not
a
valid
attribute
name
.
'
!
(
isSimple
&
&
isPath
)
)
)
;
if
(
attribute
=
=
=
'
style
'
)
{
reference
=
new
StyleBindingReference
(
reference
referenceForKey
(
component
'
isVisible
'
)
)
;
}
operations
.
addDynamicAttribute
(
element
attribute
reference
false
)
;
}
}
;
var
DISPLAY_NONE
=
'
display
:
none
;
'
;
var
SAFE_DISPLAY_NONE
=
(
0
_string
.
htmlSafe
)
(
DISPLAY_NONE
)
;
var
StyleBindingReference
=
function
(
_CachedReference
)
{
(
0
_emberBabel
.
inherits
)
(
StyleBindingReference
_CachedReference
)
;
function
StyleBindingReference
(
inner
isVisible
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
StyleBindingReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference
.
call
(
this
)
)
;
_this
.
inner
=
inner
;
_this
.
isVisible
=
isVisible
;
_this
.
tag
=
(
0
_reference
.
combine
)
(
[
inner
.
tag
isVisible
.
tag
]
)
;
return
_this
;
}
StyleBindingReference
.
prototype
.
compute
=
function
compute
(
)
{
var
value
=
this
.
inner
.
value
(
)
;
var
isVisible
=
this
.
isVisible
.
value
(
)
;
if
(
isVisible
!
=
=
false
)
{
return
value
;
}
else
if
(
!
value
)
{
return
SAFE_DISPLAY_NONE
;
}
else
{
var
style
=
value
+
'
'
+
DISPLAY_NONE
;
return
(
0
_string
.
isHTMLSafe
)
(
value
)
?
(
0
_string
.
htmlSafe
)
(
style
)
:
style
;
}
}
;
return
StyleBindingReference
;
}
(
_reference
.
CachedReference
)
;
var
IsVisibleBinding
=
exports
.
IsVisibleBinding
=
{
install
:
function
(
element
component
operations
)
{
var
ref
=
(
0
_reference
.
map
)
(
referenceForKey
(
component
'
isVisible
'
)
this
.
mapStyleValue
)
;
operations
.
addDynamicAttribute
(
element
'
style
'
ref
false
)
;
}
mapStyleValue
:
function
(
isVisible
)
{
return
isVisible
=
=
=
false
?
SAFE_DISPLAY_NONE
:
null
;
}
}
;
var
ClassNameBinding
=
exports
.
ClassNameBinding
=
{
install
:
function
(
element
component
microsyntax
operations
)
{
var
_microsyntax
split
=
microsyntax
.
split
(
'
:
'
)
prop
=
_microsyntax
split
[
0
]
truthy
=
_microsyntax
split
[
1
]
falsy
=
_microsyntax
split
[
2
]
;
var
isStatic
=
prop
=
=
=
'
'
;
if
(
isStatic
)
{
operations
.
addStaticAttribute
(
element
'
class
'
truthy
)
;
}
else
{
var
isPath
=
prop
.
indexOf
(
'
.
'
)
>
-
1
;
var
parts
=
isPath
?
prop
.
split
(
'
.
'
)
:
[
]
;
var
value
=
isPath
?
referenceForParts
(
component
parts
)
:
referenceForKey
(
component
prop
)
;
var
ref
=
void
0
;
if
(
truthy
=
=
=
undefined
)
{
ref
=
new
SimpleClassNameBindingReference
(
value
isPath
?
parts
[
parts
.
length
-
1
]
:
prop
)
;
}
else
{
ref
=
new
ColonClassNameBindingReference
(
value
truthy
falsy
)
;
}
operations
.
addDynamicAttribute
(
element
'
class
'
ref
false
)
;
}
}
}
;
var
SimpleClassNameBindingReference
=
function
(
_CachedReference2
)
{
(
0
_emberBabel
.
inherits
)
(
SimpleClassNameBindingReference
_CachedReference2
)
;
function
SimpleClassNameBindingReference
(
inner
path
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
SimpleClassNameBindingReference
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference2
.
call
(
this
)
)
;
_this2
.
inner
=
inner
;
_this2
.
path
=
path
;
_this2
.
tag
=
inner
.
tag
;
_this2
.
inner
=
inner
;
_this2
.
path
=
path
;
_this2
.
dasherizedPath
=
null
;
return
_this2
;
}
SimpleClassNameBindingReference
.
prototype
.
compute
=
function
compute
(
)
{
var
value
=
this
.
inner
.
value
(
)
;
if
(
value
=
=
=
true
)
{
var
path
=
this
.
path
dasherizedPath
=
this
.
dasherizedPath
;
return
dasherizedPath
|
|
(
this
.
dasherizedPath
=
_emberRuntime
.
String
.
dasherize
(
path
)
)
;
}
else
if
(
value
|
|
value
=
=
=
0
)
{
return
String
(
value
)
;
}
else
{
return
null
;
}
}
;
return
SimpleClassNameBindingReference
;
}
(
_reference
.
CachedReference
)
;
var
ColonClassNameBindingReference
=
function
(
_CachedReference3
)
{
(
0
_emberBabel
.
inherits
)
(
ColonClassNameBindingReference
_CachedReference3
)
;
function
ColonClassNameBindingReference
(
inner
)
{
var
truthy
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
var
falsy
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
null
;
(
0
_emberBabel
.
classCallCheck
)
(
this
ColonClassNameBindingReference
)
;
var
_this3
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference3
.
call
(
this
)
)
;
_this3
.
inner
=
inner
;
_this3
.
truthy
=
truthy
;
_this3
.
falsy
=
falsy
;
_this3
.
tag
=
inner
.
tag
;
return
_this3
;
}
ColonClassNameBindingReference
.
prototype
.
compute
=
function
compute
(
)
{
var
inner
=
this
.
inner
truthy
=
this
.
truthy
falsy
=
this
.
falsy
;
return
inner
.
value
(
)
?
truthy
:
falsy
;
}
;
return
ColonClassNameBindingReference
;
}
(
_reference
.
CachedReference
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
curly
-
component
-
state
-
bucket
'
[
'
exports
'
'
ember
-
babel
'
]
function
(
exports
_emberBabel
)
{
'
use
strict
'
;
function
NOOP
(
)
{
}
var
ComponentStateBucket
=
function
(
)
{
function
ComponentStateBucket
(
environment
component
args
finalizer
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ComponentStateBucket
)
;
this
.
environment
=
environment
;
this
.
component
=
component
;
this
.
args
=
args
;
this
.
finalizer
=
finalizer
;
this
.
classRef
=
null
;
this
.
classRef
=
null
;
this
.
argsRevision
=
args
.
tag
.
value
(
)
;
}
ComponentStateBucket
.
prototype
.
destroy
=
function
destroy
(
)
{
var
component
=
this
.
component
environment
=
this
.
environment
;
if
(
environment
.
isInteractive
)
{
component
.
trigger
(
'
willDestroyElement
'
)
;
component
.
trigger
(
'
willClearRender
'
)
;
}
environment
.
destroyedComponents
.
push
(
component
)
;
}
;
ComponentStateBucket
.
prototype
.
finalize
=
function
finalize
(
)
{
var
finalizer
=
this
.
finalizer
;
finalizer
(
)
;
this
.
finalizer
=
NOOP
;
}
;
return
ComponentStateBucket
;
}
(
)
;
exports
.
default
=
ComponentStateBucket
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
debug
-
stack
'
[
'
exports
'
'
ember
-
babel
'
]
function
(
exports
_emberBabel
)
{
'
use
strict
'
;
var
DebugStack
=
void
0
;
if
(
true
)
{
var
Element
=
function
Element
(
name
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
Element
)
;
this
.
name
=
name
;
}
;
var
TemplateElement
=
function
(
_Element
)
{
(
0
_emberBabel
.
inherits
)
(
TemplateElement
_Element
)
;
function
TemplateElement
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TemplateElement
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Element
.
apply
(
this
arguments
)
)
;
}
return
TemplateElement
;
}
(
Element
)
;
var
EngineElement
=
function
(
_Element2
)
{
(
0
_emberBabel
.
inherits
)
(
EngineElement
_Element2
)
;
function
EngineElement
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EngineElement
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Element2
.
apply
(
this
arguments
)
)
;
}
return
EngineElement
;
}
(
Element
)
;
DebugStack
=
function
(
)
{
function
DebugStack
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
DebugStack
)
;
this
.
_stack
=
[
]
;
}
DebugStack
.
prototype
.
push
=
function
push
(
name
)
{
this
.
_stack
.
push
(
new
TemplateElement
(
name
)
)
;
}
;
DebugStack
.
prototype
.
pushEngine
=
function
pushEngine
(
name
)
{
this
.
_stack
.
push
(
new
EngineElement
(
name
)
)
;
}
;
DebugStack
.
prototype
.
pop
=
function
pop
(
)
{
var
element
=
this
.
_stack
.
pop
(
)
;
if
(
element
)
{
return
element
.
name
;
}
}
;
DebugStack
.
prototype
.
peek
=
function
peek
(
)
{
var
template
=
this
.
_currentTemplate
(
)
;
var
engine
=
this
.
_currentEngine
(
)
;
if
(
engine
)
{
return
'
"
'
+
template
+
'
"
(
in
"
'
+
engine
+
'
"
)
'
;
}
else
if
(
template
)
{
return
'
"
'
+
template
+
'
"
'
;
}
}
;
DebugStack
.
prototype
.
_currentTemplate
=
function
_currentTemplate
(
)
{
return
this
.
_getCurrentByType
(
TemplateElement
)
;
}
;
DebugStack
.
prototype
.
_currentEngine
=
function
_currentEngine
(
)
{
return
this
.
_getCurrentByType
(
EngineElement
)
;
}
;
DebugStack
.
prototype
.
_getCurrentByType
=
function
_getCurrentByType
(
type
)
{
for
(
var
i
=
this
.
_stack
.
length
;
i
>
=
0
;
i
-
-
)
{
var
element
=
this
.
_stack
[
i
]
;
if
(
element
instanceof
type
)
{
return
element
.
name
;
}
}
}
;
return
DebugStack
;
}
(
)
;
}
exports
.
default
=
DebugStack
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
iterable
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
utils
'
'
ember
-
glimmer
/
helpers
/
each
-
in
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberBabel
_reference
_emberMetal
_emberRuntime
_emberUtils
_eachIn
_references
)
{
'
use
strict
'
;
exports
.
default
=
iterableFor
;
var
ITERATOR_KEY_GUID
=
'
be277757
-
bbbe
-
4620
-
9fcb
-
213ef433cca2
'
;
function
iterableFor
(
ref
keyPath
)
{
if
(
(
0
_eachIn
.
isEachIn
)
(
ref
)
)
{
return
new
EachInIterable
(
ref
keyForEachIn
(
keyPath
)
)
;
}
else
{
return
new
ArrayIterable
(
ref
keyForArray
(
keyPath
)
)
;
}
}
function
keyForEachIn
(
keyPath
)
{
switch
(
keyPath
)
{
case
'
index
'
:
case
undefined
:
case
null
:
return
index
;
case
'
identity
'
:
return
identity
;
default
:
return
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
keyPath
)
;
}
;
}
}
function
keyForArray
(
keyPath
)
{
switch
(
keyPath
)
{
case
'
index
'
:
return
index
;
case
'
identity
'
:
case
undefined
:
case
null
:
return
identity
;
default
:
return
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
keyPath
)
;
}
;
}
}
function
index
(
_item
i
)
{
return
String
(
i
)
;
}
function
identity
(
item
)
{
switch
(
typeof
item
)
{
case
'
string
'
:
case
'
number
'
:
return
String
(
item
)
;
default
:
return
(
0
_emberUtils
.
guidFor
)
(
item
)
;
}
}
function
ensureUniqueKey
(
seen
key
)
{
var
seenCount
=
seen
[
key
]
;
if
(
seenCount
>
0
)
{
seen
[
key
]
+
+
;
return
'
'
+
key
+
ITERATOR_KEY_GUID
+
seenCount
;
}
else
{
seen
[
key
]
=
1
;
}
return
key
;
}
var
ArrayIterator
=
function
(
)
{
function
ArrayIterator
(
array
length
keyFor
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ArrayIterator
)
;
this
.
array
=
array
;
this
.
length
=
length
;
this
.
keyFor
=
keyFor
;
this
.
position
=
0
;
this
.
seen
=
Object
.
create
(
null
)
;
}
ArrayIterator
.
from
=
function
from
(
array
keyFor
)
{
var
length
=
array
.
length
;
if
(
length
>
0
)
{
return
new
this
(
array
array
.
length
keyFor
)
;
}
else
{
return
EMPTY_ITERATOR
;
}
}
;
ArrayIterator
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
false
;
}
;
ArrayIterator
.
prototype
.
getMemo
=
function
getMemo
(
position
)
{
return
position
;
}
;
ArrayIterator
.
prototype
.
getValue
=
function
getValue
(
position
)
{
return
this
.
array
[
position
]
;
}
;
ArrayIterator
.
prototype
.
next
=
function
next
(
)
{
var
length
=
this
.
length
keyFor
=
this
.
keyFor
position
=
this
.
position
seen
=
this
.
seen
;
if
(
position
>
=
length
)
{
return
null
;
}
var
value
=
this
.
getValue
(
position
)
;
var
memo
=
this
.
getMemo
(
position
)
;
var
key
=
ensureUniqueKey
(
seen
keyFor
(
value
memo
)
)
;
this
.
position
+
+
;
return
{
key
:
key
value
:
value
memo
:
memo
}
;
}
;
return
ArrayIterator
;
}
(
)
;
var
EmberArrayIterator
=
function
(
_ArrayIterator
)
{
(
0
_emberBabel
.
inherits
)
(
EmberArrayIterator
_ArrayIterator
)
;
EmberArrayIterator
.
from
=
function
from
(
array
keyFor
)
{
var
length
=
(
0
_emberMetal
.
get
)
(
array
'
length
'
)
;
if
(
length
>
0
)
{
return
new
this
(
array
length
keyFor
)
;
}
else
{
return
EMPTY_ITERATOR
;
}
}
;
function
EmberArrayIterator
(
array
length
keyFor
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EmberArrayIterator
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ArrayIterator
.
call
(
this
array
length
keyFor
)
)
;
}
EmberArrayIterator
.
prototype
.
getValue
=
function
getValue
(
position
)
{
return
(
0
_emberRuntime
.
objectAt
)
(
this
.
array
position
)
;
}
;
return
EmberArrayIterator
;
}
(
ArrayIterator
)
;
var
ObjectKeysIterator
=
function
(
_ArrayIterator2
)
{
(
0
_emberBabel
.
inherits
)
(
ObjectKeysIterator
_ArrayIterator2
)
;
function
ObjectKeysIterator
(
keys
values
length
keyFor
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ObjectKeysIterator
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ArrayIterator2
.
call
(
this
values
length
keyFor
)
)
;
_this2
.
keys
=
keys
;
return
_this2
;
}
ObjectKeysIterator
.
from
=
function
from
(
obj
keyFor
)
{
var
keys
=
Object
.
keys
(
obj
)
;
var
length
=
keys
.
length
;
if
(
length
>
0
)
{
return
new
this
(
keys
keys
.
map
(
function
(
key
)
{
return
obj
[
key
]
;
}
)
length
keyFor
)
;
}
else
{
return
EMPTY_ITERATOR
;
}
}
;
ObjectKeysIterator
.
prototype
.
getMemo
=
function
getMemo
(
position
)
{
return
this
.
keys
[
position
]
;
}
;
return
ObjectKeysIterator
;
}
(
ArrayIterator
)
;
var
EmptyIterator
=
function
(
)
{
function
EmptyIterator
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EmptyIterator
)
;
}
EmptyIterator
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
true
;
}
;
EmptyIterator
.
prototype
.
next
=
function
next
(
)
{
throw
new
Error
(
'
Cannot
call
next
(
)
on
an
empty
iterator
'
)
;
}
;
return
EmptyIterator
;
}
(
)
;
var
EMPTY_ITERATOR
=
new
EmptyIterator
(
)
;
var
EachInIterable
=
function
(
)
{
function
EachInIterable
(
ref
keyFor
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EachInIterable
)
;
this
.
ref
=
ref
;
this
.
keyFor
=
keyFor
;
var
valueTag
=
this
.
valueTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
this
.
tag
=
(
0
_reference
.
combine
)
(
[
ref
.
tag
valueTag
]
)
;
}
EachInIterable
.
prototype
.
iterate
=
function
iterate
(
)
{
var
ref
=
this
.
ref
keyFor
=
this
.
keyFor
valueTag
=
this
.
valueTag
;
var
iterable
=
ref
.
value
(
)
;
valueTag
.
inner
.
update
(
(
0
_emberMetal
.
tagFor
)
(
iterable
)
)
;
if
(
(
0
_emberMetal
.
isProxy
)
(
iterable
)
)
{
iterable
=
(
0
_emberMetal
.
get
)
(
iterable
'
content
'
)
;
}
var
typeofIterable
=
typeof
iterable
;
if
(
iterable
!
=
=
null
&
&
(
typeofIterable
=
=
=
'
object
'
|
|
typeofIterable
=
=
=
'
function
'
)
)
{
return
ObjectKeysIterator
.
from
(
iterable
keyFor
)
;
}
else
{
return
EMPTY_ITERATOR
;
}
}
;
EachInIterable
.
prototype
.
valueReferenceFor
=
function
valueReferenceFor
(
item
)
{
return
new
_references
.
UpdatablePrimitiveReference
(
item
.
memo
)
;
}
;
EachInIterable
.
prototype
.
updateValueReference
=
function
updateValueReference
(
reference
item
)
{
reference
.
update
(
item
.
memo
)
;
}
;
EachInIterable
.
prototype
.
memoReferenceFor
=
function
memoReferenceFor
(
item
)
{
return
new
_references
.
UpdatableReference
(
item
.
value
)
;
}
;
EachInIterable
.
prototype
.
updateMemoReference
=
function
updateMemoReference
(
reference
item
)
{
reference
.
update
(
item
.
value
)
;
}
;
return
EachInIterable
;
}
(
)
;
var
ArrayIterable
=
function
(
)
{
function
ArrayIterable
(
ref
keyFor
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ArrayIterable
)
;
this
.
ref
=
ref
;
this
.
keyFor
=
keyFor
;
var
valueTag
=
this
.
valueTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
this
.
tag
=
(
0
_reference
.
combine
)
(
[
ref
.
tag
valueTag
]
)
;
}
ArrayIterable
.
prototype
.
iterate
=
function
iterate
(
)
{
var
ref
=
this
.
ref
keyFor
=
this
.
keyFor
valueTag
=
this
.
valueTag
;
var
iterable
=
ref
.
value
(
)
;
valueTag
.
inner
.
update
(
(
0
_emberMetal
.
tagForProperty
)
(
iterable
'
[
]
'
)
)
;
if
(
iterable
=
=
=
null
|
|
typeof
iterable
!
=
=
'
object
'
)
{
return
EMPTY_ITERATOR
;
}
if
(
Array
.
isArray
(
iterable
)
)
{
return
ArrayIterator
.
from
(
iterable
keyFor
)
;
}
else
if
(
(
0
_emberRuntime
.
isEmberArray
)
(
iterable
)
)
{
return
EmberArrayIterator
.
from
(
iterable
keyFor
)
;
}
else
if
(
typeof
iterable
.
forEach
=
=
=
'
function
'
)
{
var
array
=
[
]
;
iterable
.
forEach
(
function
(
item
)
{
return
array
.
push
(
item
)
;
}
)
;
return
ArrayIterator
.
from
(
array
keyFor
)
;
}
else
{
return
EMPTY_ITERATOR
;
}
}
;
ArrayIterable
.
prototype
.
valueReferenceFor
=
function
valueReferenceFor
(
item
)
{
return
new
_references
.
UpdatableReference
(
item
.
value
)
;
}
;
ArrayIterable
.
prototype
.
updateValueReference
=
function
updateValueReference
(
reference
item
)
{
reference
.
update
(
item
.
value
)
;
}
;
ArrayIterable
.
prototype
.
memoReferenceFor
=
function
memoReferenceFor
(
item
)
{
return
new
_references
.
UpdatablePrimitiveReference
(
item
.
memo
)
;
}
;
ArrayIterable
.
prototype
.
updateMemoReference
=
function
updateMemoReference
(
reference
item
)
{
reference
.
update
(
item
.
memo
)
;
}
;
return
ArrayIterable
;
}
(
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
process
-
args
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
views
'
'
ember
-
glimmer
/
component
'
'
ember
-
glimmer
/
helpers
/
action
'
'
ember
-
glimmer
/
utils
/
references
'
]
function
(
exports
_emberBabel
_emberUtils
_emberViews
_component
_action
_references
)
{
'
use
strict
'
;
exports
.
processComponentArgs
=
processComponentArgs
;
function
processComponentArgs
(
namedArgs
)
{
var
keys
=
namedArgs
.
names
;
var
attrs
=
namedArgs
.
value
(
)
;
var
props
=
Object
.
create
(
null
)
;
var
args
=
Object
.
create
(
null
)
;
props
[
_component
.
ARGS
]
=
args
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
name
=
keys
[
i
]
;
var
ref
=
namedArgs
.
get
(
name
)
;
var
value
=
attrs
[
name
]
;
if
(
typeof
value
=
=
=
'
function
'
&
&
value
[
_action
.
ACTION
]
)
{
attrs
[
name
]
=
value
;
}
else
if
(
ref
[
_references
.
UPDATE
]
)
{
attrs
[
name
]
=
new
MutableCell
(
ref
value
)
;
}
args
[
name
]
=
ref
;
props
[
name
]
=
value
;
}
props
.
attrs
=
attrs
;
return
props
;
}
var
REF
=
(
0
_emberUtils
.
symbol
)
(
'
REF
'
)
;
var
MutableCell
=
function
(
)
{
function
MutableCell
(
ref
value
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
MutableCell
)
;
this
[
_emberViews
.
MUTABLE_CELL
]
=
true
;
this
[
REF
]
=
ref
;
this
.
value
=
value
;
}
MutableCell
.
prototype
.
update
=
function
update
(
val
)
{
this
[
REF
]
[
_references
.
UPDATE
]
(
val
)
;
}
;
return
MutableCell
;
}
(
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
references
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
glimmer
/
runtime
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
/
features
'
'
ember
-
glimmer
/
helper
'
'
ember
-
glimmer
/
utils
/
to
-
bool
'
]
function
(
exports
_emberBabel
_reference
_runtime
_emberMetal
_emberUtils
_features
_helper
_toBool
)
{
'
use
strict
'
;
exports
.
UnboundReference
=
exports
.
InternalHelperReference
=
exports
.
ClassBasedHelperReference
=
exports
.
SimpleHelperReference
=
exports
.
ConditionalReference
=
exports
.
UpdatablePrimitiveReference
=
exports
.
UpdatableReference
=
exports
.
NestedPropertyReference
=
exports
.
RootPropertyReference
=
exports
.
PropertyReference
=
exports
.
RootReference
=
exports
.
CachedReference
=
exports
.
UPDATE
=
undefined
;
var
UPDATE
=
exports
.
UPDATE
=
(
0
_emberUtils
.
symbol
)
(
'
UPDATE
'
)
;
var
maybeFreeze
=
void
0
;
if
(
true
)
{
maybeFreeze
=
function
(
obj
)
{
if
(
!
Object
.
isFrozen
(
obj
)
)
{
Object
.
freeze
(
obj
)
;
}
}
;
}
var
EmberPathReference
=
function
(
)
{
function
EmberPathReference
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EmberPathReference
)
;
}
EmberPathReference
.
prototype
.
get
=
function
get
(
key
)
{
return
PropertyReference
.
create
(
this
key
)
;
}
;
return
EmberPathReference
;
}
(
)
;
var
CachedReference
=
exports
.
CachedReference
=
function
(
_EmberPathReference
)
{
(
0
_emberBabel
.
inherits
)
(
CachedReference
_EmberPathReference
)
;
function
CachedReference
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
CachedReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_EmberPathReference
.
call
(
this
)
)
;
_this
.
_lastRevision
=
null
;
_this
.
_lastValue
=
null
;
return
_this
;
}
CachedReference
.
prototype
.
compute
=
function
compute
(
)
{
}
;
CachedReference
.
prototype
.
value
=
function
value
(
)
{
var
tag
=
this
.
tag
_lastRevision
=
this
.
_lastRevision
_lastValue
=
this
.
_lastValue
;
if
(
!
_lastRevision
|
|
!
tag
.
validate
(
_lastRevision
)
)
{
_lastValue
=
this
.
_lastValue
=
this
.
compute
(
)
;
this
.
_lastRevision
=
tag
.
value
(
)
;
}
return
_lastValue
;
}
;
return
CachedReference
;
}
(
EmberPathReference
)
;
var
RootReference
=
exports
.
RootReference
=
function
(
_ConstReference
)
{
(
0
_emberBabel
.
inherits
)
(
RootReference
_ConstReference
)
;
function
RootReference
(
value
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RootReference
)
;
var
_this2
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ConstReference
.
call
(
this
value
)
)
;
_this2
.
children
=
Object
.
create
(
null
)
;
return
_this2
;
}
RootReference
.
prototype
.
get
=
function
get
(
propertyKey
)
{
var
ref
=
this
.
children
[
propertyKey
]
;
if
(
ref
=
=
=
undefined
)
{
ref
=
this
.
children
[
propertyKey
]
=
new
RootPropertyReference
(
this
.
inner
propertyKey
)
;
}
return
ref
;
}
;
return
RootReference
;
}
(
_reference
.
ConstReference
)
;
var
TwoWayFlushDetectionTag
=
void
0
;
if
(
_features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
TwoWayFlushDetectionTag
=
function
(
)
{
function
TwoWayFlushDetectionTag
(
tag
key
ref
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TwoWayFlushDetectionTag
)
;
this
.
tag
=
tag
;
this
.
parent
=
null
;
this
.
key
=
key
;
this
.
ref
=
ref
;
}
TwoWayFlushDetectionTag
.
prototype
.
value
=
function
value
(
)
{
return
this
.
tag
.
value
(
)
;
}
;
TwoWayFlushDetectionTag
.
prototype
.
validate
=
function
validate
(
ticket
)
{
var
parent
=
this
.
parent
key
=
this
.
key
;
var
isValid
=
this
.
tag
.
validate
(
ticket
)
;
if
(
isValid
&
&
parent
)
{
(
0
_emberMetal
.
didRender
)
(
parent
key
this
.
ref
)
;
}
return
isValid
;
}
;
TwoWayFlushDetectionTag
.
prototype
.
didCompute
=
function
didCompute
(
parent
)
{
this
.
parent
=
parent
;
(
0
_emberMetal
.
didRender
)
(
parent
this
.
key
this
.
ref
)
;
}
;
return
TwoWayFlushDetectionTag
;
}
(
)
;
}
var
PropertyReference
=
exports
.
PropertyReference
=
function
(
_CachedReference
)
{
(
0
_emberBabel
.
inherits
)
(
PropertyReference
_CachedReference
)
;
function
PropertyReference
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
PropertyReference
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference
.
apply
(
this
arguments
)
)
;
}
PropertyReference
.
create
=
function
create
(
parentReference
propertyKey
)
{
if
(
(
0
_reference
.
isConst
)
(
parentReference
)
)
{
return
new
RootPropertyReference
(
parentReference
.
value
(
)
propertyKey
)
;
}
else
{
return
new
NestedPropertyReference
(
parentReference
propertyKey
)
;
}
}
;
PropertyReference
.
prototype
.
get
=
function
get
(
key
)
{
return
new
NestedPropertyReference
(
this
key
)
;
}
;
return
PropertyReference
;
}
(
CachedReference
)
;
var
RootPropertyReference
=
exports
.
RootPropertyReference
=
function
(
_PropertyReference
)
{
(
0
_emberBabel
.
inherits
)
(
RootPropertyReference
_PropertyReference
)
;
function
RootPropertyReference
(
parentValue
propertyKey
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RootPropertyReference
)
;
var
_this4
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_PropertyReference
.
call
(
this
)
)
;
_this4
.
_parentValue
=
parentValue
;
_this4
.
_propertyKey
=
propertyKey
;
if
(
_features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
_this4
.
tag
=
new
TwoWayFlushDetectionTag
(
(
0
_emberMetal
.
tagForProperty
)
(
parentValue
propertyKey
)
propertyKey
_this4
)
;
}
else
{
_this4
.
tag
=
(
0
_emberMetal
.
tagForProperty
)
(
parentValue
propertyKey
)
;
}
if
(
_features
.
MANDATORY_SETTER
)
{
(
0
_emberMetal
.
watchKey
)
(
parentValue
propertyKey
)
;
}
return
_this4
;
}
RootPropertyReference
.
prototype
.
compute
=
function
compute
(
)
{
var
_parentValue
=
this
.
_parentValue
_propertyKey
=
this
.
_propertyKey
;
if
(
_features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
this
.
tag
.
didCompute
(
_parentValue
)
;
}
return
(
0
_emberMetal
.
get
)
(
_parentValue
_propertyKey
)
;
}
;
RootPropertyReference
.
prototype
[
UPDATE
]
=
function
(
value
)
{
(
0
_emberMetal
.
set
)
(
this
.
_parentValue
this
.
_propertyKey
value
)
;
}
;
return
RootPropertyReference
;
}
(
PropertyReference
)
;
var
NestedPropertyReference
=
exports
.
NestedPropertyReference
=
function
(
_PropertyReference2
)
{
(
0
_emberBabel
.
inherits
)
(
NestedPropertyReference
_PropertyReference2
)
;
function
NestedPropertyReference
(
parentReference
propertyKey
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
NestedPropertyReference
)
;
var
_this5
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_PropertyReference2
.
call
(
this
)
)
;
var
parentReferenceTag
=
parentReference
.
tag
;
var
parentObjectTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
_this5
.
_parentReference
=
parentReference
;
_this5
.
_parentObjectTag
=
parentObjectTag
;
_this5
.
_propertyKey
=
propertyKey
;
if
(
_features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
var
tag
=
(
0
_reference
.
combine
)
(
[
parentReferenceTag
parentObjectTag
]
)
;
_this5
.
tag
=
new
TwoWayFlushDetectionTag
(
tag
propertyKey
_this5
)
;
}
else
{
_this5
.
tag
=
(
0
_reference
.
combine
)
(
[
parentReferenceTag
parentObjectTag
]
)
;
}
return
_this5
;
}
NestedPropertyReference
.
prototype
.
compute
=
function
compute
(
)
{
var
_parentReference
=
this
.
_parentReference
_parentObjectTag
=
this
.
_parentObjectTag
_propertyKey
=
this
.
_propertyKey
;
var
parentValue
=
_parentReference
.
value
(
)
;
_parentObjectTag
.
inner
.
update
(
(
0
_emberMetal
.
tagForProperty
)
(
parentValue
_propertyKey
)
)
;
var
parentValueType
=
typeof
parentValue
;
if
(
parentValueType
=
=
=
'
string
'
&
&
_propertyKey
=
=
=
'
length
'
)
{
return
parentValue
.
length
;
}
if
(
parentValueType
=
=
=
'
object
'
&
&
parentValue
!
=
=
null
|
|
parentValueType
=
=
=
'
function
'
)
{
if
(
_features
.
MANDATORY_SETTER
)
{
(
0
_emberMetal
.
watchKey
)
(
parentValue
_propertyKey
)
;
}
if
(
_features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
this
.
tag
.
didCompute
(
parentValue
)
;
}
return
(
0
_emberMetal
.
get
)
(
parentValue
_propertyKey
)
;
}
else
{
return
undefined
;
}
}
;
NestedPropertyReference
.
prototype
[
UPDATE
]
=
function
(
value
)
{
var
parent
=
this
.
_parentReference
.
value
(
)
;
(
0
_emberMetal
.
set
)
(
parent
this
.
_propertyKey
value
)
;
}
;
return
NestedPropertyReference
;
}
(
PropertyReference
)
;
var
UpdatableReference
=
exports
.
UpdatableReference
=
function
(
_EmberPathReference2
)
{
(
0
_emberBabel
.
inherits
)
(
UpdatableReference
_EmberPathReference2
)
;
function
UpdatableReference
(
value
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
UpdatableReference
)
;
var
_this6
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_EmberPathReference2
.
call
(
this
)
)
;
_this6
.
tag
=
_reference
.
DirtyableTag
.
create
(
)
;
_this6
.
_value
=
value
;
return
_this6
;
}
UpdatableReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
_value
;
}
;
UpdatableReference
.
prototype
.
update
=
function
update
(
value
)
{
var
_value
=
this
.
_value
;
if
(
value
!
=
=
_value
)
{
this
.
tag
.
inner
.
dirty
(
)
;
this
.
_value
=
value
;
}
}
;
return
UpdatableReference
;
}
(
EmberPathReference
)
;
var
UpdatablePrimitiveReference
=
exports
.
UpdatablePrimitiveReference
=
function
(
_UpdatableReference
)
{
(
0
_emberBabel
.
inherits
)
(
UpdatablePrimitiveReference
_UpdatableReference
)
;
function
UpdatablePrimitiveReference
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
UpdatablePrimitiveReference
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_UpdatableReference
.
apply
(
this
arguments
)
)
;
}
return
UpdatablePrimitiveReference
;
}
(
UpdatableReference
)
;
var
ConditionalReference
=
exports
.
ConditionalReference
=
function
(
_GlimmerConditionalRe
)
{
(
0
_emberBabel
.
inherits
)
(
ConditionalReference
_GlimmerConditionalRe
)
;
ConditionalReference
.
create
=
function
create
(
reference
)
{
if
(
(
0
_reference
.
isConst
)
(
reference
)
)
{
var
value
=
reference
.
value
(
)
;
if
(
(
0
_emberMetal
.
isProxy
)
(
value
)
)
{
return
new
RootPropertyReference
(
value
'
isTruthy
'
)
;
}
else
{
return
_runtime
.
PrimitiveReference
.
create
(
(
0
_toBool
.
default
)
(
value
)
)
;
}
}
return
new
ConditionalReference
(
reference
)
;
}
;
function
ConditionalReference
(
reference
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ConditionalReference
)
;
var
_this8
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_GlimmerConditionalRe
.
call
(
this
reference
)
)
;
_this8
.
objectTag
=
_reference
.
UpdatableTag
.
create
(
_reference
.
CONSTANT_TAG
)
;
_this8
.
tag
=
(
0
_reference
.
combine
)
(
[
reference
.
tag
_this8
.
objectTag
]
)
;
return
_this8
;
}
ConditionalReference
.
prototype
.
toBool
=
function
toBool
(
predicate
)
{
if
(
(
0
_emberMetal
.
isProxy
)
(
predicate
)
)
{
this
.
objectTag
.
inner
.
update
(
(
0
_emberMetal
.
tagForProperty
)
(
predicate
'
isTruthy
'
)
)
;
return
(
0
_emberMetal
.
get
)
(
predicate
'
isTruthy
'
)
;
}
else
{
this
.
objectTag
.
inner
.
update
(
(
0
_emberMetal
.
tagFor
)
(
predicate
)
)
;
return
(
0
_toBool
.
default
)
(
predicate
)
;
}
}
;
return
ConditionalReference
;
}
(
_runtime
.
ConditionalReference
)
;
var
SimpleHelperReference
=
exports
.
SimpleHelperReference
=
function
(
_CachedReference2
)
{
(
0
_emberBabel
.
inherits
)
(
SimpleHelperReference
_CachedReference2
)
;
SimpleHelperReference
.
create
=
function
create
(
Helper
_vm
args
)
{
var
helper
=
Helper
.
create
(
)
;
if
(
(
0
_reference
.
isConst
)
(
args
)
)
{
var
positional
=
args
.
positional
named
=
args
.
named
;
var
positionalValue
=
positional
.
value
(
)
;
var
namedValue
=
named
.
value
(
)
;
if
(
true
)
{
maybeFreeze
(
positionalValue
)
;
maybeFreeze
(
namedValue
)
;
}
var
result
=
helper
.
compute
(
positionalValue
namedValue
)
;
if
(
typeof
result
=
=
=
'
object
'
&
&
result
!
=
=
null
|
|
typeof
result
=
=
=
'
function
'
)
{
return
new
RootReference
(
result
)
;
}
else
{
return
_runtime
.
PrimitiveReference
.
create
(
result
)
;
}
}
else
{
return
new
SimpleHelperReference
(
helper
.
compute
args
)
;
}
}
;
function
SimpleHelperReference
(
helper
args
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
SimpleHelperReference
)
;
var
_this9
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference2
.
call
(
this
)
)
;
_this9
.
tag
=
args
.
tag
;
_this9
.
helper
=
helper
;
_this9
.
args
=
args
;
return
_this9
;
}
SimpleHelperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
helper
=
this
.
helper
_args
=
this
.
args
positional
=
_args
.
positional
named
=
_args
.
named
;
var
positionalValue
=
positional
.
value
(
)
;
var
namedValue
=
named
.
value
(
)
;
if
(
true
)
{
maybeFreeze
(
positionalValue
)
;
maybeFreeze
(
namedValue
)
;
}
return
helper
(
positionalValue
namedValue
)
;
}
;
return
SimpleHelperReference
;
}
(
CachedReference
)
;
var
ClassBasedHelperReference
=
exports
.
ClassBasedHelperReference
=
function
(
_CachedReference3
)
{
(
0
_emberBabel
.
inherits
)
(
ClassBasedHelperReference
_CachedReference3
)
;
ClassBasedHelperReference
.
create
=
function
create
(
helperClass
vm
args
)
{
var
instance
=
helperClass
.
create
(
)
;
vm
.
newDestroyable
(
instance
)
;
return
new
ClassBasedHelperReference
(
instance
args
)
;
}
;
function
ClassBasedHelperReference
(
instance
args
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ClassBasedHelperReference
)
;
var
_this10
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference3
.
call
(
this
)
)
;
_this10
.
tag
=
(
0
_reference
.
combine
)
(
[
instance
[
_helper
.
RECOMPUTE_TAG
]
args
.
tag
]
)
;
_this10
.
instance
=
instance
;
_this10
.
args
=
args
;
return
_this10
;
}
ClassBasedHelperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
instance
=
this
.
instance
_args2
=
this
.
args
positional
=
_args2
.
positional
named
=
_args2
.
named
;
var
positionalValue
=
positional
.
value
(
)
;
var
namedValue
=
named
.
value
(
)
;
if
(
true
)
{
maybeFreeze
(
positionalValue
)
;
maybeFreeze
(
namedValue
)
;
}
return
instance
.
compute
(
positionalValue
namedValue
)
;
}
;
return
ClassBasedHelperReference
;
}
(
CachedReference
)
;
var
InternalHelperReference
=
exports
.
InternalHelperReference
=
function
(
_CachedReference4
)
{
(
0
_emberBabel
.
inherits
)
(
InternalHelperReference
_CachedReference4
)
;
function
InternalHelperReference
(
helper
args
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
InternalHelperReference
)
;
var
_this11
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedReference4
.
call
(
this
)
)
;
_this11
.
tag
=
args
.
tag
;
_this11
.
helper
=
helper
;
_this11
.
args
=
args
;
return
_this11
;
}
InternalHelperReference
.
prototype
.
compute
=
function
compute
(
)
{
var
helper
=
this
.
helper
args
=
this
.
args
;
return
helper
(
args
)
;
}
;
return
InternalHelperReference
;
}
(
CachedReference
)
;
var
UnboundReference
=
exports
.
UnboundReference
=
function
(
_ConstReference2
)
{
(
0
_emberBabel
.
inherits
)
(
UnboundReference
_ConstReference2
)
;
function
UnboundReference
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
UnboundReference
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ConstReference2
.
apply
(
this
arguments
)
)
;
}
UnboundReference
.
create
=
function
create
(
value
)
{
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
)
{
return
new
UnboundReference
(
value
)
;
}
else
{
return
_runtime
.
PrimitiveReference
.
create
(
value
)
;
}
}
;
UnboundReference
.
prototype
.
get
=
function
get
(
key
)
{
return
new
UnboundReference
(
(
0
_emberMetal
.
get
)
(
this
.
inner
key
)
)
;
}
;
return
UnboundReference
;
}
(
_reference
.
ConstReference
)
;
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
string
'
[
'
exports
'
'
ember
-
babel
'
]
function
(
exports
_emberBabel
)
{
'
use
strict
'
;
exports
.
SafeString
=
undefined
;
exports
.
escapeExpression
=
escapeExpression
;
exports
.
htmlSafe
=
htmlSafe
;
exports
.
isHTMLSafe
=
isHTMLSafe
;
var
SafeString
=
exports
.
SafeString
=
function
(
)
{
function
SafeString
(
string
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
SafeString
)
;
this
.
string
=
string
;
}
SafeString
.
prototype
.
toString
=
function
toString
(
)
{
return
'
'
+
this
.
string
;
}
;
SafeString
.
prototype
.
toHTML
=
function
toHTML
(
)
{
return
this
.
toString
(
)
;
}
;
return
SafeString
;
}
(
)
;
var
escape
=
{
'
&
'
:
'
&
amp
;
'
'
<
'
:
'
&
lt
;
'
'
>
'
:
'
&
gt
;
'
'
"
'
:
'
&
quot
;
'
"
'
"
:
'
&
#
x27
;
'
'
'
:
'
&
#
x60
;
'
'
=
'
:
'
&
#
x3D
;
'
}
;
var
possible
=
/
[
&
<
>
"
'
=
]
/
;
var
badChars
=
/
[
&
<
>
"
'
=
]
/
g
;
function
escapeChar
(
chr
)
{
return
escape
[
chr
]
;
}
function
escapeExpression
(
string
)
{
if
(
typeof
string
!
=
=
'
string
'
)
{
if
(
string
&
&
string
.
toHTML
)
{
return
string
.
toHTML
(
)
;
}
else
if
(
string
=
=
=
null
|
|
string
=
=
=
undefined
)
{
return
'
'
;
}
else
if
(
!
string
)
{
return
string
+
'
'
;
}
string
=
'
'
+
string
;
}
if
(
!
possible
.
test
(
string
)
)
{
return
string
;
}
return
string
.
replace
(
badChars
escapeChar
)
;
}
function
htmlSafe
(
str
)
{
if
(
str
=
=
=
null
|
|
str
=
=
=
undefined
)
{
str
=
'
'
;
}
else
if
(
typeof
str
!
=
=
'
string
'
)
{
str
=
'
'
+
str
;
}
return
new
SafeString
(
str
)
;
}
function
isHTMLSafe
(
str
)
{
return
str
!
=
=
null
&
&
typeof
str
=
=
=
'
object
'
&
&
typeof
str
.
toHTML
=
=
=
'
function
'
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
utils
/
to
-
bool
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
]
function
(
exports
_emberMetal
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
toBool
;
function
toBool
(
predicate
)
{
if
(
!
predicate
)
{
return
false
;
}
if
(
predicate
=
=
=
true
)
{
return
true
;
}
if
(
(
0
_emberRuntime
.
isArray
)
(
predicate
)
)
{
return
(
0
_emberMetal
.
get
)
(
predicate
'
length
'
)
!
=
=
0
;
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
glimmer
/
views
/
outlet
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
environment
'
'
ember
-
metal
'
'
ember
-
utils
'
]
function
(
exports
_emberBabel
_reference
_emberEnvironment
_emberMetal
_emberUtils
)
{
'
use
strict
'
;
exports
.
RootOutletStateReference
=
undefined
;
var
RootOutletStateReference
=
exports
.
RootOutletStateReference
=
function
(
)
{
function
RootOutletStateReference
(
outletView
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
RootOutletStateReference
)
;
this
.
outletView
=
outletView
;
this
.
tag
=
outletView
.
_tag
;
}
RootOutletStateReference
.
prototype
.
get
=
function
get
(
key
)
{
return
new
ChildOutletStateReference
(
this
key
)
;
}
;
RootOutletStateReference
.
prototype
.
value
=
function
value
(
)
{
return
this
.
outletView
.
outletState
;
}
;
RootOutletStateReference
.
prototype
.
getOrphan
=
function
getOrphan
(
name
)
{
return
new
OrphanedOutletStateReference
(
this
name
)
;
}
;
RootOutletStateReference
.
prototype
.
update
=
function
update
(
state
)
{
this
.
outletView
.
setOutletState
(
state
)
;
}
;
return
RootOutletStateReference
;
}
(
)
;
var
OrphanedOutletStateReference
=
function
(
_RootOutletStateRefer
)
{
(
0
_emberBabel
.
inherits
)
(
OrphanedOutletStateReference
_RootOutletStateRefer
)
;
function
OrphanedOutletStateReference
(
root
name
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OrphanedOutletStateReference
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_RootOutletStateRefer
.
call
(
this
root
.
outletView
)
)
;
_this
.
root
=
root
;
_this
.
name
=
name
;
return
_this
;
}
OrphanedOutletStateReference
.
prototype
.
value
=
function
value
(
)
{
var
rootState
=
this
.
root
.
value
(
)
;
var
orphans
=
rootState
.
outlets
.
main
.
outlets
.
__ember_orphans__
;
if
(
!
orphans
)
{
return
null
;
}
var
matched
=
orphans
.
outlets
[
this
.
name
]
;
if
(
!
matched
)
{
return
null
;
}
var
state
=
Object
.
create
(
null
)
;
state
[
matched
.
render
.
outlet
]
=
matched
;
matched
.
wasUsed
=
true
;
return
{
outlets
:
state
render
:
undefined
}
;
}
;
return
OrphanedOutletStateReference
;
}
(
RootOutletStateReference
)
;
var
ChildOutletStateReference
=
function
(
)
{
function
ChildOutletStateReference
(
parent
key
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ChildOutletStateReference
)
;
this
.
parent
=
parent
;
this
.
key
=
key
;
this
.
tag
=
parent
.
tag
;
}
ChildOutletStateReference
.
prototype
.
get
=
function
get
(
key
)
{
return
new
ChildOutletStateReference
(
this
key
)
;
}
;
ChildOutletStateReference
.
prototype
.
value
=
function
value
(
)
{
var
parent
=
this
.
parent
.
value
(
)
;
return
parent
&
&
parent
[
this
.
key
]
;
}
;
return
ChildOutletStateReference
;
}
(
)
;
var
OutletView
=
function
(
)
{
OutletView
.
extend
=
function
extend
(
injections
)
{
return
function
(
_OutletView
)
{
(
0
_emberBabel
.
inherits
)
(
_class
_OutletView
)
;
function
_class
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
_class
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_OutletView
.
apply
(
this
arguments
)
)
;
}
_class
.
create
=
function
create
(
options
)
{
if
(
options
)
{
return
_OutletView
.
create
.
call
(
this
(
0
_emberUtils
.
assign
)
(
{
}
injections
options
)
)
;
}
else
{
return
_OutletView
.
create
.
call
(
this
injections
)
;
}
}
;
return
_class
;
}
(
OutletView
)
;
}
;
OutletView
.
reopenClass
=
function
reopenClass
(
injections
)
{
(
0
_emberUtils
.
assign
)
(
this
injections
)
;
}
;
OutletView
.
create
=
function
create
(
options
)
{
var
_environment
=
options
.
_environment
renderer
=
options
.
renderer
template
=
options
.
template
;
var
owner
=
options
[
_emberUtils
.
OWNER
]
;
return
new
OutletView
(
_environment
renderer
owner
template
)
;
}
;
function
OutletView
(
_environment
renderer
owner
template
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
OutletView
)
;
this
.
_environment
=
_environment
;
this
.
renderer
=
renderer
;
this
.
owner
=
owner
;
this
.
template
=
template
;
this
.
outletState
=
null
;
this
.
_tag
=
_reference
.
DirtyableTag
.
create
(
)
;
}
OutletView
.
prototype
.
appendTo
=
function
appendTo
(
selector
)
{
var
env
=
this
.
_environment
|
|
_emberEnvironment
.
environment
;
var
target
=
void
0
;
if
(
env
.
hasDOM
)
{
target
=
typeof
selector
=
=
=
'
string
'
?
document
.
querySelector
(
selector
)
:
selector
;
}
else
{
target
=
selector
;
}
_emberMetal
.
run
.
schedule
(
'
render
'
this
.
renderer
'
appendOutletView
'
this
target
)
;
}
;
OutletView
.
prototype
.
rerender
=
function
rerender
(
)
{
}
;
OutletView
.
prototype
.
setOutletState
=
function
setOutletState
(
state
)
{
this
.
outletState
=
{
outlets
:
{
main
:
state
}
render
:
{
owner
:
undefined
into
:
undefined
outlet
:
'
main
'
name
:
'
-
top
-
level
'
controller
:
undefined
template
:
undefined
}
}
;
this
.
_tag
.
inner
.
dirty
(
)
;
}
;
OutletView
.
prototype
.
toReference
=
function
toReference
(
)
{
return
new
RootOutletStateReference
(
this
)
;
}
;
OutletView
.
prototype
.
destroy
=
function
destroy
(
)
{
}
;
return
OutletView
;
}
(
)
;
exports
.
default
=
OutletView
;
}
)
;
enifed
(
'
ember
-
metal
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
utils
'
'
ember
-
debug
'
'
ember
/
features
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
require
'
'
backburner
'
]
function
(
exports
emberEnvironment
emberUtils
emberDebug
features
emberBabel
reference
require
Backburner
)
{
'
use
strict
'
;
require
=
require
&
&
require
.
hasOwnProperty
(
'
default
'
)
?
require
[
'
default
'
]
:
require
;
Backburner
=
Backburner
&
&
Backburner
.
hasOwnProperty
(
'
default
'
)
?
Backburner
[
'
default
'
]
:
Backburner
;
var
Ember
=
typeof
emberEnvironment
.
context
.
imports
.
Ember
=
=
=
'
object
'
&
&
emberEnvironment
.
context
.
imports
.
Ember
|
|
{
}
;
Ember
.
isNamespace
=
true
;
Ember
.
toString
=
function
(
)
{
return
'
Ember
'
;
}
;
var
ONCE
=
1
;
var
SUSPENDED
=
2
;
var
protoMethods
=
{
addToListeners
:
function
(
eventName
target
method
flags
)
{
if
(
this
.
_listeners
=
=
=
undefined
)
{
this
.
_listeners
=
[
]
;
}
this
.
_listeners
.
push
(
eventName
target
method
flags
)
;
}
_finalizeListeners
:
function
(
)
{
if
(
this
.
_listenersFinalized
)
{
return
;
}
if
(
this
.
_listeners
=
=
=
undefined
)
{
this
.
_listeners
=
[
]
;
}
var
pointer
=
this
.
parent
;
while
(
pointer
!
=
=
undefined
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
!
=
=
undefined
)
{
this
.
_listeners
=
this
.
_listeners
.
concat
(
listeners
)
;
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
this
.
_listenersFinalized
=
true
;
}
removeFromListeners
:
function
(
eventName
target
method
didRemove
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
!
=
=
undefined
)
{
for
(
var
index
=
listeners
.
length
-
4
;
index
>
=
0
;
index
-
=
4
)
{
if
(
listeners
[
index
]
=
=
=
eventName
&
&
(
!
method
|
|
listeners
[
index
+
1
]
=
=
=
target
&
&
listeners
[
index
+
2
]
=
=
=
method
)
)
{
if
(
pointer
=
=
=
this
)
{
if
(
typeof
didRemove
=
=
=
'
function
'
)
{
didRemove
(
eventName
target
listeners
[
index
+
2
]
)
;
}
listeners
.
splice
(
index
4
)
;
}
else
{
this
.
_finalizeListeners
(
)
;
return
this
.
removeFromListeners
(
eventName
target
method
)
;
}
}
}
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
}
matchingListeners
:
function
(
eventName
)
{
var
pointer
=
this
;
var
result
=
void
0
;
while
(
pointer
!
=
=
undefined
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
!
=
=
undefined
)
{
for
(
var
index
=
0
;
index
<
listeners
.
length
;
index
+
=
4
)
{
if
(
listeners
[
index
]
=
=
=
eventName
)
{
result
=
result
|
|
[
]
;
pushUniqueListener
(
result
listeners
index
)
;
}
}
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
return
result
;
}
}
;
function
pushUniqueListener
(
destination
source
index
)
{
var
target
=
source
[
index
+
1
]
;
var
method
=
source
[
index
+
2
]
;
for
(
var
destinationIndex
=
0
;
destinationIndex
<
destination
.
length
;
destinationIndex
+
=
3
)
{
if
(
destination
[
destinationIndex
]
=
=
=
target
&
&
destination
[
destinationIndex
+
1
]
=
=
=
method
)
{
return
;
}
}
destination
.
push
(
target
method
source
[
index
+
3
]
)
;
}
function
addListener
(
obj
eventName
target
method
once
)
{
true
&
&
!
(
!
!
obj
&
&
!
!
eventName
)
&
&
emberDebug
.
assert
(
'
You
must
pass
at
least
an
object
and
event
name
to
addListener
'
!
!
obj
&
&
!
!
eventName
)
;
if
(
emberEnvironment
.
ENV
.
_ENABLE_DID_INIT_ATTRS_SUPPORT
=
=
=
true
)
{
true
&
&
!
(
eventName
!
=
=
'
didInitAttrs
'
)
&
&
emberDebug
.
deprecate
(
'
didInitAttrs
called
in
'
+
(
obj
&
&
obj
.
toString
&
&
obj
.
toString
(
)
)
+
'
.
'
eventName
!
=
=
'
didInitAttrs
'
{
id
:
'
ember
-
views
.
did
-
init
-
attrs
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_ember
-
component
-
didinitattrs
'
}
)
;
}
else
{
true
&
&
!
(
eventName
!
=
=
'
didInitAttrs
'
)
&
&
emberDebug
.
assert
(
'
didInitAttrs
called
in
'
+
(
obj
&
&
obj
.
toString
&
&
obj
.
toString
(
)
)
+
'
is
no
longer
supported
.
'
eventName
!
=
=
'
didInitAttrs
'
)
;
}
if
(
!
method
&
&
'
function
'
=
=
=
typeof
target
)
{
method
=
target
;
target
=
null
;
}
var
flags
=
0
;
if
(
once
)
{
flags
|
=
ONCE
;
}
meta
(
obj
)
.
addToListeners
(
eventName
target
method
flags
)
;
if
(
'
function
'
=
=
=
typeof
obj
.
didAddListener
)
{
obj
.
didAddListener
(
eventName
target
method
)
;
}
}
function
removeListener
(
obj
eventName
target
method
)
{
true
&
&
!
(
!
!
obj
&
&
!
!
eventName
)
&
&
emberDebug
.
assert
(
'
You
must
pass
at
least
an
object
and
event
name
to
removeListener
'
!
!
obj
&
&
!
!
eventName
)
;
if
(
!
method
&
&
'
function
'
=
=
=
typeof
target
)
{
method
=
target
;
target
=
null
;
}
var
func
=
'
function
'
=
=
=
typeof
obj
.
didRemoveListener
?
obj
.
didRemoveListener
.
bind
(
obj
)
:
function
(
)
{
}
;
meta
(
obj
)
.
removeFromListeners
(
eventName
target
method
func
)
;
}
function
sendEvent
(
obj
eventName
params
actions
_meta
)
{
if
(
actions
=
=
=
undefined
)
{
var
meta
1
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
actions
=
typeof
meta
1
=
=
=
'
object
'
&
&
meta
1
!
=
=
null
&
&
meta
1
.
matchingListeners
(
eventName
)
;
}
if
(
actions
=
=
=
undefined
|
|
actions
.
length
=
=
=
0
)
{
return
false
;
}
for
(
var
i
=
actions
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
var
target
=
actions
[
i
]
;
var
method
=
actions
[
i
+
1
]
;
var
flags
=
actions
[
i
+
2
]
;
if
(
!
method
)
{
continue
;
}
if
(
flags
&
SUSPENDED
)
{
continue
;
}
if
(
flags
&
ONCE
)
{
removeListener
(
obj
eventName
target
method
)
;
}
if
(
!
target
)
{
target
=
obj
;
}
if
(
'
string
'
=
=
=
typeof
method
)
{
if
(
params
)
{
emberUtils
.
applyStr
(
target
method
params
)
;
}
else
{
target
[
method
]
(
)
;
}
}
else
{
if
(
params
)
{
method
.
apply
(
target
params
)
;
}
else
{
method
.
call
(
target
)
;
}
}
}
return
true
;
}
function
hasListeners
(
obj
eventName
)
{
var
meta
1
=
peekMeta
(
obj
)
;
if
(
meta
1
=
=
=
undefined
)
{
return
false
;
}
var
matched
=
meta
1
.
matchingListeners
(
eventName
)
;
return
matched
!
=
=
undefined
&
&
matched
.
length
>
0
;
}
function
on
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
func
=
args
.
pop
(
)
;
var
events
=
args
;
true
&
&
!
(
typeof
func
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
on
expects
function
as
last
argument
'
typeof
func
=
=
=
'
function
'
)
;
true
&
&
!
(
events
.
length
>
0
&
&
events
.
every
(
function
(
p
)
{
return
typeof
p
=
=
=
'
string
'
&
&
p
.
length
;
}
)
)
&
&
emberDebug
.
assert
(
'
on
called
without
valid
event
names
'
events
.
length
>
0
&
&
events
.
every
(
function
(
p
)
{
return
typeof
p
=
=
=
'
string
'
&
&
p
.
length
;
}
)
)
;
func
.
__ember_listens__
=
events
;
return
func
;
}
var
hasViews
=
function
(
)
{
return
false
;
}
;
function
setHasViews
(
fn
)
{
hasViews
=
fn
;
}
function
makeTag
(
)
{
return
new
reference
.
DirtyableTag
(
)
;
}
function
tagForProperty
(
object
propertyKey
_meta
)
{
if
(
typeof
object
!
=
=
'
object
'
|
|
object
=
=
=
null
)
{
return
reference
.
CONSTANT_TAG
;
}
var
meta
1
=
_meta
=
=
=
undefined
?
meta
(
object
)
:
_meta
;
if
(
meta
1
.
isProxy
(
)
)
{
return
tagFor
(
object
meta
1
)
;
}
var
tags
=
meta
1
.
writableTags
(
)
;
var
tag
=
tags
[
propertyKey
]
;
if
(
tag
)
{
return
tag
;
}
return
tags
[
propertyKey
]
=
makeTag
(
)
;
}
function
tagFor
(
object
_meta
)
{
if
(
typeof
object
=
=
=
'
object
'
&
&
object
!
=
=
null
)
{
var
meta
1
=
_meta
=
=
=
undefined
?
meta
(
object
)
:
_meta
;
return
meta
1
.
writableTag
(
makeTag
)
;
}
else
{
return
reference
.
CONSTANT_TAG
;
}
}
function
markObjectAsDirty
(
meta
1
propertyKey
)
{
var
objectTag
=
meta
1
.
readableTag
(
)
;
if
(
objectTag
!
=
=
undefined
)
{
objectTag
.
dirty
(
)
;
}
var
tags
=
meta
1
.
readableTags
(
)
;
var
propertyTag
=
tags
!
=
=
undefined
?
tags
[
propertyKey
]
:
undefined
;
if
(
propertyTag
!
=
=
undefined
)
{
propertyTag
.
dirty
(
)
;
}
if
(
propertyKey
=
=
=
'
content
'
&
&
meta
1
.
isProxy
(
)
)
{
objectTag
.
contentDidChange
(
)
;
}
if
(
objectTag
!
=
=
undefined
|
|
propertyTag
!
=
=
undefined
)
{
ensureRunloop
(
)
;
}
}
var
backburner
=
void
0
;
function
ensureRunloop
(
)
{
if
(
backburner
=
=
=
undefined
)
{
backburner
=
require
(
'
ember
-
metal
'
)
.
run
.
backburner
;
}
if
(
hasViews
(
)
)
{
backburner
.
ensureInstance
(
)
;
}
}
var
ObserverSet
=
function
(
)
{
function
ObserverSet
(
)
{
emberBabel
.
classCallCheck
(
this
ObserverSet
)
;
this
.
clear
(
)
;
}
ObserverSet
.
prototype
.
add
=
function
add
(
sender
keyName
eventName
)
{
var
observerSet
=
this
.
observerSet
;
var
observers
=
this
.
observers
;
var
senderGuid
=
emberUtils
.
guidFor
(
sender
)
;
var
keySet
=
observerSet
[
senderGuid
]
;
if
(
keySet
=
=
=
undefined
)
{
observerSet
[
senderGuid
]
=
keySet
=
{
}
;
}
var
index
=
keySet
[
keyName
]
;
if
(
index
=
=
=
undefined
)
{
index
=
observers
.
push
(
{
sender
:
sender
keyName
:
keyName
eventName
:
eventName
listeners
:
[
]
}
)
-
1
;
keySet
[
keyName
]
=
index
;
}
return
observers
[
index
]
.
listeners
;
}
;
ObserverSet
.
prototype
.
flush
=
function
flush
(
)
{
var
observers
=
this
.
observers
;
var
observer
=
void
0
sender
=
void
0
;
this
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
observers
.
length
;
+
+
i
)
{
observer
=
observers
[
i
]
;
sender
=
observer
.
sender
;
if
(
sender
.
isDestroying
|
|
sender
.
isDestroyed
)
{
continue
;
}
sendEvent
(
sender
observer
.
eventName
[
sender
observer
.
keyName
]
observer
.
listeners
)
;
}
}
;
ObserverSet
.
prototype
.
clear
=
function
clear
(
)
{
this
.
observerSet
=
{
}
;
this
.
observers
=
[
]
;
}
;
return
ObserverSet
;
}
(
)
;
exports
.
runInTransaction
=
void
0
;
exports
.
didRender
=
void
0
;
exports
.
assertNotRendered
=
void
0
;
if
(
features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
var
TransactionRunner
=
function
(
)
{
function
TransactionRunner
(
)
{
emberBabel
.
classCallCheck
(
this
TransactionRunner
)
;
this
.
transactionId
=
0
;
this
.
inTransaction
=
false
;
this
.
shouldReflush
=
false
;
this
.
weakMap
=
new
WeakMap
(
)
;
{
this
.
debugStack
=
undefined
;
}
}
TransactionRunner
.
prototype
.
runInTransaction
=
function
runInTransaction
(
context
1
methodName
)
{
this
.
before
(
context
1
)
;
try
{
context
1
[
methodName
]
(
)
;
}
finally
{
this
.
after
(
)
;
}
return
this
.
shouldReflush
;
}
;
TransactionRunner
.
prototype
.
didRender
=
function
didRender
(
object
key
reference
1
)
{
if
(
!
this
.
inTransaction
)
{
return
;
}
{
this
.
setKey
(
object
key
{
lastRef
:
reference
1
lastRenderedIn
:
this
.
debugStack
.
peek
(
)
}
)
;
}
}
;
TransactionRunner
.
prototype
.
assertNotRendered
=
function
assertNotRendered
(
object
key
)
{
if
(
!
this
.
inTransaction
)
{
return
;
}
if
(
this
.
hasRendered
(
object
key
)
)
{
{
var
_getKey
=
this
.
getKey
(
object
key
)
lastRef
=
_getKey
.
lastRef
lastRenderedIn
=
_getKey
.
lastRenderedIn
;
var
currentlyIn
=
this
.
debugStack
.
peek
(
)
;
var
parts
=
[
]
;
var
label
=
void
0
;
if
(
lastRef
!
=
=
undefined
)
{
while
(
lastRef
&
&
lastRef
.
_propertyKey
)
{
parts
.
unshift
(
lastRef
.
_propertyKey
)
;
lastRef
=
lastRef
.
_parentReference
;
}
label
=
parts
.
join
(
'
.
'
)
;
}
else
{
label
=
'
the
same
value
'
;
}
true
&
&
!
false
&
&
emberDebug
.
assert
(
'
You
modified
"
'
+
label
+
'
"
twice
on
'
+
object
+
'
in
a
single
render
.
It
was
rendered
in
'
+
lastRenderedIn
+
'
and
modified
in
'
+
currentlyIn
+
'
.
This
was
unreliable
and
slow
in
Ember
1
.
x
and
is
no
longer
supported
.
See
https
:
/
/
github
.
com
/
emberjs
/
ember
.
js
/
issues
/
13948
for
more
details
.
'
false
)
;
}
this
.
shouldReflush
=
true
;
}
}
;
TransactionRunner
.
prototype
.
hasRendered
=
function
hasRendered
(
object
key
)
{
if
(
!
this
.
inTransaction
)
{
return
false
;
}
{
return
this
.
getKey
(
object
key
)
!
=
=
undefined
;
}
return
this
.
getKey
(
object
key
)
=
=
=
this
.
transactionId
;
}
;
TransactionRunner
.
prototype
.
before
=
function
before
(
context
1
)
{
this
.
inTransaction
=
true
;
this
.
shouldReflush
=
false
;
{
this
.
debugStack
=
context
1
.
env
.
debugStack
;
}
}
;
TransactionRunner
.
prototype
.
after
=
function
after
(
)
{
this
.
transactionId
+
+
;
this
.
inTransaction
=
false
;
{
this
.
debugStack
=
undefined
;
}
this
.
clearObjectMap
(
)
;
}
;
TransactionRunner
.
prototype
.
createMap
=
function
createMap
(
object
)
{
var
map
=
Object
.
create
(
null
)
;
this
.
weakMap
.
set
(
object
map
)
;
return
map
;
}
;
TransactionRunner
.
prototype
.
getOrCreateMap
=
function
getOrCreateMap
(
object
)
{
var
map
=
this
.
weakMap
.
get
(
object
)
;
if
(
map
=
=
=
undefined
)
{
map
=
this
.
createMap
(
object
)
;
}
return
map
;
}
;
TransactionRunner
.
prototype
.
setKey
=
function
setKey
(
object
key
value
)
{
var
map
=
this
.
getOrCreateMap
(
object
)
;
map
[
key
]
=
value
;
}
;
TransactionRunner
.
prototype
.
getKey
=
function
getKey
(
object
key
)
{
var
map
=
this
.
weakMap
.
get
(
object
)
;
if
(
map
!
=
=
undefined
)
{
return
map
[
key
]
;
}
}
;
TransactionRunner
.
prototype
.
clearObjectMap
=
function
clearObjectMap
(
)
{
this
.
weakMap
=
new
WeakMap
(
)
;
}
;
return
TransactionRunner
;
}
(
)
;
var
runner
=
new
TransactionRunner
(
)
;
exports
.
runInTransaction
=
runner
.
runInTransaction
.
bind
(
runner
)
;
exports
.
didRender
=
runner
.
didRender
.
bind
(
runner
)
;
exports
.
assertNotRendered
=
runner
.
assertNotRendered
.
bind
(
runner
)
;
}
else
{
exports
.
runInTransaction
=
function
(
context
1
methodName
)
{
context
1
[
methodName
]
(
)
;
return
false
;
}
;
}
function
watchPath
(
obj
keyPath
meta
1
)
{
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
;
}
var
m
=
meta
1
=
=
=
undefined
?
meta
(
obj
)
:
meta
1
;
var
counter
=
m
.
peekWatching
(
keyPath
)
|
|
0
;
m
.
writeWatching
(
keyPath
counter
+
1
)
;
if
(
counter
=
=
=
0
)
{
m
.
writableChains
(
makeChainNode
)
.
add
(
keyPath
)
;
}
}
function
unwatchPath
(
obj
keyPath
meta
1
)
{
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
;
}
var
m
=
meta
1
=
=
=
undefined
?
peekMeta
(
obj
)
:
meta
1
;
if
(
m
=
=
=
undefined
)
{
return
;
}
var
counter
=
m
.
peekWatching
(
keyPath
)
|
|
0
;
if
(
counter
=
=
=
1
)
{
m
.
writeWatching
(
keyPath
0
)
;
m
.
writableChains
(
makeChainNode
)
.
remove
(
keyPath
)
;
}
else
if
(
counter
>
1
)
{
m
.
writeWatching
(
keyPath
counter
-
1
)
;
}
}
function
watch
(
obj
_keyPath
m
)
{
if
(
isPath
(
_keyPath
)
)
{
watchPath
(
obj
_keyPath
m
)
;
}
else
{
watchKey
(
obj
_keyPath
m
)
;
}
}
function
isWatching
(
obj
key
)
{
return
watcherCount
(
obj
key
)
>
0
;
}
function
watcherCount
(
obj
key
)
{
var
meta
1
=
peekMeta
(
obj
)
;
return
meta
1
!
=
=
undefined
&
&
meta
1
.
peekWatching
(
key
)
|
|
0
;
}
function
unwatch
(
obj
_keyPath
m
)
{
if
(
isPath
(
_keyPath
)
)
{
unwatchPath
(
obj
_keyPath
m
)
;
}
else
{
unwatchKey
(
obj
_keyPath
m
)
;
}
}
var
AFTER_OBSERVERS
=
'
:
change
'
;
var
BEFORE_OBSERVERS
=
'
:
before
'
;
function
changeEvent
(
keyName
)
{
return
keyName
+
AFTER_OBSERVERS
;
}
function
beforeEvent
(
keyName
)
{
return
keyName
+
BEFORE_OBSERVERS
;
}
function
addObserver
(
obj
_path
target
method
)
{
addListener
(
obj
changeEvent
(
_path
)
target
method
)
;
watch
(
obj
_path
)
;
return
this
;
}
function
removeObserver
(
obj
path
target
method
)
{
unwatch
(
obj
path
)
;
removeListener
(
obj
changeEvent
(
path
)
target
method
)
;
return
this
;
}
function
_addBeforeObserver
(
obj
path
target
method
)
{
addListener
(
obj
beforeEvent
(
path
)
target
method
)
;
watch
(
obj
path
)
;
return
this
;
}
function
_removeBeforeObserver
(
obj
path
target
method
)
{
unwatch
(
obj
path
)
;
removeListener
(
obj
beforeEvent
(
path
)
target
method
)
;
return
this
;
}
var
PROPERTY_DID_CHANGE
=
emberUtils
.
symbol
(
'
PROPERTY_DID_CHANGE
'
)
;
var
beforeObserverSet
=
new
ObserverSet
(
)
;
var
observerSet
=
new
ObserverSet
(
)
;
var
deferred
=
0
;
function
propertyWillChange
(
obj
keyName
_meta
)
{
var
meta
1
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
if
(
meta
1
!
=
=
undefined
&
&
!
meta
1
.
isInitialized
(
obj
)
)
{
return
;
}
var
watching
=
meta
1
!
=
=
undefined
&
&
meta
1
.
peekWatching
(
keyName
)
>
0
;
var
possibleDesc
=
descriptorFor
(
obj
keyName
meta
1
)
;
if
(
possibleDesc
!
=
=
undefined
&
&
possibleDesc
.
willChange
)
{
possibleDesc
.
willChange
(
obj
keyName
)
;
}
if
(
watching
)
{
dependentKeysWillChange
(
obj
keyName
meta
1
)
;
chainsWillChange
(
obj
keyName
meta
1
)
;
notifyBeforeObservers
(
obj
keyName
meta
1
)
;
}
}
function
propertyDidChange
(
obj
keyName
_meta
)
{
var
meta
1
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
var
hasMeta
=
meta
1
!
=
=
undefined
;
if
(
hasMeta
&
&
!
meta
1
.
isInitialized
(
obj
)
)
{
return
;
}
var
possibleDesc
=
descriptorFor
(
obj
keyName
meta
1
)
;
if
(
possibleDesc
!
=
=
undefined
&
&
possibleDesc
.
didChange
)
{
possibleDesc
.
didChange
(
obj
keyName
)
;
}
if
(
hasMeta
&
&
meta
1
.
peekWatching
(
keyName
)
>
0
)
{
dependentKeysDidChange
(
obj
keyName
meta
1
)
;
chainsDidChange
(
obj
keyName
meta
1
)
;
notifyObservers
(
obj
keyName
meta
1
)
;
}
if
(
obj
[
PROPERTY_DID_CHANGE
]
)
{
obj
[
PROPERTY_DID_CHANGE
]
(
keyName
)
;
}
if
(
hasMeta
)
{
if
(
meta
1
.
isSourceDestroying
(
)
)
{
return
;
}
markObjectAsDirty
(
meta
1
keyName
)
;
}
if
(
features
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
)
{
exports
.
assertNotRendered
(
obj
keyName
meta
1
)
;
}
}
var
WILL_SEEN
=
void
0
;
var
DID_SEEN
=
void
0
;
function
dependentKeysWillChange
(
obj
depKey
meta
1
)
{
if
(
meta
1
.
isSourceDestroying
(
)
|
|
!
meta
1
.
hasDeps
(
depKey
)
)
{
return
;
}
var
seen
=
WILL_SEEN
;
var
top
=
!
seen
;
if
(
top
)
{
seen
=
WILL_SEEN
=
{
}
;
}
iterDeps
(
propertyWillChange
obj
depKey
seen
meta
1
)
;
if
(
top
)
{
WILL_SEEN
=
null
;
}
}
function
dependentKeysDidChange
(
obj
depKey
meta
1
)
{
if
(
meta
1
.
isSourceDestroying
(
)
|
|
!
meta
1
.
hasDeps
(
depKey
)
)
{
return
;
}
var
seen
=
DID_SEEN
;
var
top
=
!
seen
;
if
(
top
)
{
seen
=
DID_SEEN
=
{
}
;
}
iterDeps
(
propertyDidChange
obj
depKey
seen
meta
1
)
;
if
(
top
)
{
DID_SEEN
=
null
;
}
}
function
iterDeps
(
method
obj
depKey
seen
meta
1
)
{
var
possibleDesc
=
void
0
;
var
guid
=
emberUtils
.
guidFor
(
obj
)
;
var
current
=
seen
[
guid
]
;
if
(
!
current
)
{
current
=
seen
[
guid
]
=
{
}
;
}
if
(
current
[
depKey
]
)
{
return
;
}
current
[
depKey
]
=
true
;
meta
1
.
forEachInDeps
(
depKey
function
(
key
value
)
{
if
(
!
value
)
{
return
;
}
possibleDesc
=
descriptorFor
(
obj
key
meta
1
)
;
if
(
possibleDesc
!
=
=
undefined
&
&
possibleDesc
.
_suspended
=
=
=
obj
)
{
return
;
}
method
(
obj
key
meta
1
)
;
}
)
;
}
function
chainsWillChange
(
obj
keyName
meta
1
)
{
var
chainWatchers
=
meta
1
.
readableChainWatchers
(
)
;
if
(
chainWatchers
!
=
=
undefined
)
{
chainWatchers
.
notify
(
keyName
false
propertyWillChange
)
;
}
}
function
chainsDidChange
(
obj
keyName
meta
1
)
{
var
chainWatchers
=
meta
1
.
readableChainWatchers
(
)
;
if
(
chainWatchers
!
=
=
undefined
)
{
chainWatchers
.
notify
(
keyName
true
propertyDidChange
)
;
}
}
function
overrideChains
(
obj
keyName
meta
1
)
{
var
chainWatchers
=
meta
1
.
readableChainWatchers
(
)
;
if
(
chainWatchers
!
=
=
undefined
)
{
chainWatchers
.
revalidate
(
keyName
)
;
}
}
function
beginPropertyChanges
(
)
{
deferred
+
+
;
}
function
endPropertyChanges
(
)
{
deferred
-
-
;
if
(
deferred
<
=
0
)
{
beforeObserverSet
.
clear
(
)
;
observerSet
.
flush
(
)
;
}
}
function
changeProperties
(
callback
)
{
beginPropertyChanges
(
)
;
try
{
callback
(
)
;
}
finally
{
endPropertyChanges
(
)
;
}
}
function
indexOf
(
array
target
method
)
{
var
index
=
-
1
;
for
(
var
i
=
array
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
if
(
target
=
=
=
array
[
i
]
&
&
method
=
=
=
array
[
i
+
1
]
)
{
index
=
i
;
break
;
}
}
return
index
;
}
function
accumulateListeners
(
obj
eventName
otherActions
meta
1
)
{
var
actions
=
meta
1
.
matchingListeners
(
eventName
)
;
if
(
actions
=
=
=
undefined
)
{
return
;
}
var
newActions
=
[
]
;
for
(
var
i
=
actions
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
var
target
=
actions
[
i
]
;
var
method
=
actions
[
i
+
1
]
;
var
flags
=
actions
[
i
+
2
]
;
var
actionIndex
=
indexOf
(
otherActions
target
method
)
;
if
(
actionIndex
=
=
=
-
1
)
{
otherActions
.
push
(
target
method
flags
)
;
newActions
.
push
(
target
method
flags
)
;
}
}
return
newActions
;
}
function
notifyBeforeObservers
(
obj
keyName
meta
1
)
{
if
(
meta
1
.
isSourceDestroying
(
)
)
{
return
;
}
var
eventName
=
beforeEvent
(
keyName
)
;
var
listeners
=
void
0
added
=
void
0
;
if
(
deferred
>
0
)
{
listeners
=
beforeObserverSet
.
add
(
obj
keyName
eventName
)
;
added
=
accumulateListeners
(
obj
eventName
listeners
meta
1
)
;
}
sendEvent
(
obj
eventName
[
obj
keyName
]
added
)
;
}
function
notifyObservers
(
obj
keyName
meta
1
)
{
if
(
meta
1
.
isSourceDestroying
(
)
)
{
return
;
}
var
eventName
=
changeEvent
(
keyName
)
;
var
listeners
=
void
0
;
if
(
deferred
>
0
)
{
listeners
=
observerSet
.
add
(
obj
keyName
eventName
)
;
accumulateListeners
(
obj
eventName
listeners
meta
1
)
;
}
else
{
sendEvent
(
obj
eventName
[
obj
keyName
]
)
;
}
}
function
Descriptor
(
)
{
this
.
isDescriptor
=
true
;
}
function
MANDATORY_SETTER_FUNCTION
(
name
)
{
function
SETTER_FUNCTION
(
value
)
{
var
m
=
peekMeta
(
this
)
;
if
(
!
m
.
isInitialized
(
this
)
)
{
m
.
writeValues
(
name
value
)
;
}
else
{
true
&
&
!
false
&
&
emberDebug
.
assert
(
'
You
must
use
set
(
)
to
set
the
'
+
name
+
'
property
(
of
'
+
this
+
'
)
to
'
+
value
+
'
.
'
false
)
;
}
}
SETTER_FUNCTION
.
isMandatorySetter
=
true
;
return
SETTER_FUNCTION
;
}
function
DEFAULT_GETTER_FUNCTION
(
name
)
{
return
function
GETTER_FUNCTION
(
)
{
var
meta
1
=
peekMeta
(
this
)
;
if
(
meta
1
!
=
=
undefined
)
{
return
meta
1
.
peekValues
(
name
)
;
}
}
;
}
function
INHERITING_GETTER_FUNCTION
(
name
)
{
function
IGETTER_FUNCTION
(
)
{
var
meta
1
=
peekMeta
(
this
)
;
var
val
=
void
0
;
if
(
meta
1
!
=
=
undefined
)
{
val
=
meta
1
.
readInheritedValue
(
'
values
'
name
)
;
}
if
(
val
=
=
=
UNDEFINED
)
{
var
proto
=
Object
.
getPrototypeOf
(
this
)
;
return
proto
&
&
proto
[
name
]
;
}
else
{
return
val
;
}
}
IGETTER_FUNCTION
.
isInheritingGetter
=
true
;
return
IGETTER_FUNCTION
;
}
var
DESCRIPTOR_GETTER_FUNCTION
=
void
0
;
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
DESCRIPTOR_GETTER_FUNCTION
=
function
(
name
descriptor
)
{
return
function
CPGETTER_FUNCTION
(
)
{
return
descriptor
.
get
(
this
name
)
;
}
;
}
;
}
else
if
(
features
.
DESCRIPTOR_TRAP
)
{
var
messageFor
=
function
(
obj
keyName
property
value
)
{
return
'
You
attempted
to
access
'
+
keyName
+
'
.
'
+
String
(
property
)
+
'
'
+
(
'
(
on
'
+
obj
+
'
)
but
'
+
keyName
+
'
is
a
computed
property
.
\
n
\
n
'
)
+
'
Due
to
certain
internal
implementation
details
of
Ember
the
'
+
(
'
'
+
keyName
+
'
property
previously
contained
a
private
"
descriptor
"
'
)
+
(
'
object
therefore
'
+
keyName
+
'
.
'
+
String
(
property
)
+
'
would
have
been
'
)
+
(
'
'
+
String
(
value
)
.
replace
(
/
\
n
/
g
'
'
)
+
'
.
\
n
\
n
'
)
+
'
This
implementation
detail
has
now
changed
and
the
"
descriptor
"
'
+
'
object
is
no
longer
present
at
this
location
.
Soon
accessing
'
+
(
'
'
+
keyName
+
'
on
this
object
will
return
the
computed
property
\
'
s
'
)
+
'
current
value
(
see
RFC
#
281
for
more
details
)
.
\
n
\
n
'
+
'
If
you
are
seeing
this
error
you
are
likely
using
an
addon
that
'
+
'
relies
on
this
now
-
defunct
private
implementation
detail
.
If
you
'
+
'
can
identify
the
addon
from
the
stack
trace
below
and
report
this
'
+
'
bug
to
the
addon
authors
.
If
you
feel
stuck
the
Ember
Community
'
+
'
Slack
(
https
:
/
/
ember
-
community
-
slackin
.
herokuapp
.
com
/
)
may
be
able
'
+
'
to
offer
some
help
.
\
n
\
n
'
+
'
If
you
are
an
addon
author
and
need
help
transitioning
your
code
'
+
'
please
get
in
touch
in
the
#
dev
-
ember
channel
in
the
Ember
Community
'
+
'
Slack
.
'
;
}
;
var
trapFor
=
void
0
;
if
(
emberUtils
.
HAS_NATIVE_PROXY
)
{
trapFor
=
function
(
obj
keyName
descriptor
)
{
return
new
Proxy
(
descriptor
{
get
:
function
(
descriptor
property
)
{
if
(
property
=
=
=
DESCRIPTOR
)
{
return
descriptor
;
}
else
if
(
property
=
=
=
'
prototype
'
|
|
property
=
=
=
'
constructor
'
|
|
property
=
=
=
'
nodeType
'
)
{
return
undefined
;
}
else
if
(
property
=
=
=
'
toString
'
|
|
property
=
=
=
'
valueOf
'
|
|
property
=
=
=
'
inspect
'
|
|
Symbol
&
&
property
=
=
=
Symbol
.
toPrimitive
|
|
Symbol
&
&
property
=
=
=
Symbol
.
toStringTag
)
{
return
function
(
)
{
return
'
[
COMPUTED
PROPERTY
]
'
;
}
;
}
true
&
&
!
false
&
&
emberDebug
.
assert
(
messageFor
(
obj
keyName
property
descriptor
[
property
]
)
)
;
}
}
)
;
}
;
}
else
{
trapFor
=
function
(
obj
keyName
descriptor
)
{
var
trap
=
Object
.
create
(
null
)
;
Object
.
defineProperty
(
trap
DESCRIPTOR
{
configurable
:
false
enumerable
:
false
writable
:
false
value
:
descriptor
}
)
;
trap
.
toString
=
trap
.
valueOf
=
function
(
)
{
return
'
[
COMPUTED
PROPERTY
]
'
;
}
;
[
'
isDescriptor
'
'
setup
'
'
teardown
'
'
get
'
'
_getter
'
'
set
'
'
_setter
'
'
meta
'
]
.
forEach
(
function
(
property
)
{
Object
.
defineProperty
(
trap
property
{
configurable
:
false
enumerable
:
false
get
:
function
(
)
{
true
&
&
!
false
&
&
emberDebug
.
assert
(
messageFor
(
obj
keyName
property
descriptor
[
property
]
)
)
;
}
}
)
;
}
)
;
return
trap
;
}
;
}
DESCRIPTOR_GETTER_FUNCTION
=
function
(
name
descriptor
)
{
var
trap
=
void
0
;
return
function
CPGETTER_FUNCTION
(
)
{
if
(
trap
)
{
return
trap
;
}
trap
=
trapFor
(
this
name
descriptor
)
;
return
trap
;
}
;
}
;
}
function
defineProperty
(
obj
keyName
desc
data
meta
1
)
{
if
(
meta
1
=
=
=
undefined
)
{
meta
1
=
meta
(
obj
)
;
}
var
watchEntry
=
meta
1
.
peekWatching
(
keyName
)
;
var
watching
=
watchEntry
!
=
=
undefined
&
&
watchEntry
>
0
;
var
previousDesc
=
descriptorFor
(
obj
keyName
meta
1
)
;
var
wasDescriptor
=
previousDesc
!
=
=
undefined
;
if
(
wasDescriptor
)
{
previousDesc
.
teardown
(
obj
keyName
meta
1
)
;
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
meta
1
.
removeDescriptors
(
keyName
)
;
}
}
var
enumerable
=
true
;
if
(
obj
=
=
=
Array
.
prototype
)
{
enumerable
=
false
;
}
var
value
=
void
0
;
if
(
desc
instanceof
Descriptor
)
{
value
=
desc
;
if
(
features
.
EMBER_METAL_ES5_GETTERS
|
|
features
.
DESCRIPTOR_TRAP
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
enumerable
get
:
DESCRIPTOR_GETTER_FUNCTION
(
keyName
value
)
}
)
;
}
else
if
(
features
.
MANDATORY_SETTER
&
&
watching
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
enumerable
writable
:
true
value
:
value
}
)
;
}
else
if
(
enumerable
=
=
=
false
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
writable
:
true
enumerable
:
enumerable
value
:
value
}
)
;
}
else
{
obj
[
keyName
]
=
value
;
}
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
meta
1
.
writeDescriptors
(
keyName
value
)
;
}
didDefineComputedProperty
(
obj
.
constructor
)
;
if
(
typeof
desc
.
setup
=
=
=
'
function
'
)
{
desc
.
setup
(
obj
keyName
)
;
}
}
else
if
(
desc
=
=
=
undefined
|
|
desc
=
=
=
null
)
{
value
=
data
;
if
(
features
.
MANDATORY_SETTER
&
&
watching
)
{
meta
1
.
writeValues
(
keyName
data
)
;
var
defaultDescriptor
=
{
configurable
:
true
enumerable
:
enumerable
set
:
MANDATORY_SETTER_FUNCTION
(
keyName
)
get
:
DEFAULT_GETTER_FUNCTION
(
keyName
)
}
;
Object
.
defineProperty
(
obj
keyName
defaultDescriptor
)
;
}
else
if
(
(
features
.
EMBER_METAL_ES5_GETTERS
|
|
features
.
DESCRIPTOR_TRAP
)
&
&
wasDescriptor
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
enumerable
writable
:
true
value
:
value
}
)
;
}
else
if
(
enumerable
=
=
=
false
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
enumerable
writable
:
true
value
:
value
}
)
;
}
else
{
obj
[
keyName
]
=
data
;
}
}
else
{
value
=
desc
;
Object
.
defineProperty
(
obj
keyName
desc
)
;
}
if
(
watching
)
{
overrideChains
(
obj
keyName
meta
1
)
;
}
if
(
typeof
obj
.
didDefineProperty
=
=
=
'
function
'
)
{
obj
.
didDefineProperty
(
obj
keyName
value
)
;
}
return
this
;
}
var
hasCachedComputedProperties
=
false
;
function
_hasCachedComputedProperties
(
)
{
hasCachedComputedProperties
=
true
;
}
function
didDefineComputedProperty
(
constructor
)
{
if
(
hasCachedComputedProperties
=
=
=
false
)
{
return
;
}
var
cache
=
meta
(
constructor
)
.
readableCache
(
)
;
if
(
cache
&
&
cache
.
_computedProperties
!
=
=
undefined
)
{
cache
.
_computedProperties
=
undefined
;
}
}
var
handleMandatorySetter
=
void
0
;
function
watchKey
(
obj
keyName
_meta
)
{
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
;
}
var
meta
1
=
_meta
=
=
=
undefined
?
meta
(
obj
)
:
_meta
;
var
count
=
meta
1
.
peekWatching
(
keyName
)
|
|
0
;
meta
1
.
writeWatching
(
keyName
count
+
1
)
;
if
(
count
=
=
=
0
)
{
var
possibleDesc
=
descriptorFor
(
obj
keyName
meta
1
)
;
if
(
possibleDesc
!
=
=
undefined
&
&
possibleDesc
.
willWatch
)
{
possibleDesc
.
willWatch
(
obj
keyName
meta
1
)
;
}
if
(
typeof
obj
.
willWatchProperty
=
=
=
'
function
'
)
{
obj
.
willWatchProperty
(
keyName
)
;
}
if
(
features
.
MANDATORY_SETTER
)
{
handleMandatorySetter
(
meta
1
obj
keyName
)
;
}
}
}
if
(
features
.
MANDATORY_SETTER
)
{
var
_hasOwnProperty
=
function
(
obj
key
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
;
}
;
var
_propertyIsEnumerable
=
function
(
obj
key
)
{
return
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
key
)
;
}
;
handleMandatorySetter
=
function
handleMandatorySetter
(
m
obj
keyName
)
{
var
descriptor
=
emberUtils
.
lookupDescriptor
(
obj
keyName
)
;
var
hasDescriptor
=
descriptor
!
=
=
null
;
var
possibleDesc
=
hasDescriptor
&
&
descriptor
.
value
;
if
(
isDescriptor
(
possibleDesc
)
)
{
return
;
}
var
configurable
=
hasDescriptor
?
descriptor
.
configurable
:
true
;
var
isWritable
=
hasDescriptor
?
descriptor
.
writable
:
true
;
var
hasValue
=
hasDescriptor
?
'
value
'
in
descriptor
:
true
;
if
(
configurable
&
&
isWritable
&
&
hasValue
&
&
keyName
in
obj
)
{
var
desc
=
{
configurable
:
true
set
:
MANDATORY_SETTER_FUNCTION
(
keyName
)
enumerable
:
_propertyIsEnumerable
(
obj
keyName
)
get
:
undefined
}
;
if
(
_hasOwnProperty
(
obj
keyName
)
)
{
m
.
writeValues
(
keyName
obj
[
keyName
]
)
;
desc
.
get
=
DEFAULT_GETTER_FUNCTION
(
keyName
)
;
}
else
{
desc
.
get
=
INHERITING_GETTER_FUNCTION
(
keyName
)
;
}
Object
.
defineProperty
(
obj
keyName
desc
)
;
}
}
;
}
function
unwatchKey
(
obj
keyName
_meta
)
{
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
;
}
var
meta
1
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
if
(
meta
1
=
=
=
undefined
|
|
meta
1
.
isSourceDestroyed
(
)
)
{
return
;
}
var
count
=
meta
1
.
peekWatching
(
keyName
)
;
if
(
count
=
=
=
1
)
{
meta
1
.
writeWatching
(
keyName
0
)
;
var
possibleDesc
=
descriptorFor
(
obj
keyName
meta
1
)
;
var
_isDescriptor
=
possibleDesc
!
=
=
undefined
;
if
(
_isDescriptor
&
&
possibleDesc
.
didUnwatch
)
{
possibleDesc
.
didUnwatch
(
obj
keyName
meta
1
)
;
}
if
(
typeof
obj
.
didUnwatchProperty
=
=
=
'
function
'
)
{
obj
.
didUnwatchProperty
(
keyName
)
;
}
if
(
features
.
MANDATORY_SETTER
)
{
if
(
!
_isDescriptor
&
&
keyName
in
obj
)
{
var
maybeMandatoryDescriptor
=
emberUtils
.
lookupDescriptor
(
obj
keyName
)
;
if
(
maybeMandatoryDescriptor
.
set
&
&
maybeMandatoryDescriptor
.
set
.
isMandatorySetter
)
{
if
(
maybeMandatoryDescriptor
.
get
&
&
maybeMandatoryDescriptor
.
get
.
isInheritingGetter
)
{
var
possibleValue
=
meta
1
.
readInheritedValue
(
'
values
'
keyName
)
;
if
(
possibleValue
=
=
=
UNDEFINED
)
{
delete
obj
[
keyName
]
;
return
;
}
}
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
keyName
)
writable
:
true
value
:
meta
1
.
peekValues
(
keyName
)
}
)
;
meta
1
.
deleteFromValues
(
keyName
)
;
}
}
}
}
else
if
(
count
>
1
)
{
meta
1
.
writeWatching
(
keyName
count
-
1
)
;
}
}
var
FIRST_KEY
=
/
^
(
[
^
\
.
]
+
)
/
;
function
firstKey
(
path
)
{
return
path
.
match
(
FIRST_KEY
)
[
0
]
;
}
function
isObject
(
obj
)
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
!
=
=
null
;
}
function
isVolatile
(
obj
keyName
meta
1
)
{
var
desc
=
descriptorFor
(
obj
keyName
meta
1
)
;
return
!
(
desc
!
=
=
undefined
&
&
desc
.
_volatile
=
=
=
false
)
;
}
var
ChainWatchers
=
function
(
)
{
function
ChainWatchers
(
)
{
emberBabel
.
classCallCheck
(
this
ChainWatchers
)
;
this
.
chains
=
Object
.
create
(
null
)
;
}
ChainWatchers
.
prototype
.
add
=
function
add
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
=
=
=
undefined
)
{
this
.
chains
[
key
]
=
[
node
]
;
}
else
{
nodes
.
push
(
node
)
;
}
}
;
ChainWatchers
.
prototype
.
remove
=
function
remove
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
!
=
=
undefined
)
{
for
(
var
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
if
(
nodes
[
i
]
=
=
=
node
)
{
nodes
.
splice
(
i
1
)
;
break
;
}
}
}
}
;
ChainWatchers
.
prototype
.
has
=
function
has
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
!
=
=
undefined
)
{
for
(
var
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
if
(
nodes
[
i
]
=
=
=
node
)
{
return
true
;
}
}
}
return
false
;
}
;
ChainWatchers
.
prototype
.
revalidateAll
=
function
revalidateAll
(
)
{
for
(
var
key
in
this
.
chains
)
{
this
.
notify
(
key
true
undefined
)
;
}
}
;
ChainWatchers
.
prototype
.
revalidate
=
function
revalidate
(
key
)
{
this
.
notify
(
key
true
undefined
)
;
}
;
ChainWatchers
.
prototype
.
notify
=
function
notify
(
key
revalidate
callback
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
=
=
=
undefined
|
|
nodes
.
length
=
=
=
0
)
{
return
;
}
var
affected
=
void
0
;
if
(
callback
)
{
affected
=
[
]
;
}
for
(
var
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
nodes
[
i
]
.
notify
(
revalidate
affected
)
;
}
if
(
callback
=
=
=
undefined
)
{
return
;
}
for
(
var
_i
=
0
;
_i
<
affected
.
length
;
_i
+
=
2
)
{
var
obj
=
affected
[
_i
]
;
var
path
=
affected
[
_i
+
1
]
;
callback
(
obj
path
)
;
}
}
;
return
ChainWatchers
;
}
(
)
;
function
makeChainWatcher
(
)
{
return
new
ChainWatchers
(
)
;
}
function
makeChainNode
(
obj
)
{
return
new
ChainNode
(
null
null
obj
)
;
}
function
addChainWatcher
(
obj
keyName
node
)
{
var
m
=
meta
(
obj
)
;
m
.
writableChainWatchers
(
makeChainWatcher
)
.
add
(
keyName
node
)
;
watchKey
(
obj
keyName
m
)
;
}
function
removeChainWatcher
(
obj
keyName
node
_meta
)
{
if
(
!
isObject
(
obj
)
)
{
return
;
}
var
meta
1
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
if
(
meta
1
=
=
=
undefined
|
|
meta
1
.
readableChainWatchers
(
)
=
=
=
undefined
)
{
return
;
}
meta
1
=
meta
(
obj
)
;
meta
1
.
readableChainWatchers
(
)
.
remove
(
keyName
node
)
;
unwatchKey
(
obj
keyName
meta
1
)
;
}
var
ChainNode
=
function
(
)
{
function
ChainNode
(
parent
key
value
)
{
emberBabel
.
classCallCheck
(
this
ChainNode
)
;
this
.
_parent
=
parent
;
this
.
_key
=
key
;
var
isWatching
=
this
.
_watching
=
value
=
=
=
undefined
;
this
.
_chains
=
undefined
;
this
.
_object
=
undefined
;
this
.
count
=
0
;
this
.
_value
=
value
;
this
.
_paths
=
undefined
;
if
(
isWatching
)
{
var
obj
=
parent
.
value
(
)
;
if
(
!
isObject
(
obj
)
)
{
return
;
}
this
.
_object
=
obj
;
addChainWatcher
(
this
.
_object
this
.
_key
this
)
;
}
}
ChainNode
.
prototype
.
value
=
function
value
(
)
{
if
(
this
.
_value
=
=
=
undefined
&
&
this
.
_watching
)
{
var
obj
=
this
.
_parent
.
value
(
)
;
this
.
_value
=
lazyGet
(
obj
this
.
_key
)
;
}
return
this
.
_value
;
}
;
ChainNode
.
prototype
.
destroy
=
function
destroy
(
)
{
if
(
this
.
_watching
)
{
removeChainWatcher
(
this
.
_object
this
.
_key
this
)
;
this
.
_watching
=
false
;
}
}
;
ChainNode
.
prototype
.
copy
=
function
copy
(
obj
)
{
var
ret
=
makeChainNode
(
obj
)
;
var
paths
=
this
.
_paths
;
if
(
paths
!
=
=
undefined
)
{
var
path
=
void
0
;
for
(
path
in
paths
)
{
if
(
paths
[
path
]
>
0
)
{
ret
.
add
(
path
)
;
}
}
}
return
ret
;
}
;
ChainNode
.
prototype
.
add
=
function
add
(
path
)
{
var
paths
=
this
.
_paths
|
|
(
this
.
_paths
=
{
}
)
;
paths
[
path
]
=
(
paths
[
path
]
|
|
0
)
+
1
;
var
key
=
firstKey
(
path
)
;
var
tail
=
path
.
slice
(
key
.
length
+
1
)
;
this
.
chain
(
key
tail
)
;
}
;
ChainNode
.
prototype
.
remove
=
function
remove
(
path
)
{
var
paths
=
this
.
_paths
;
if
(
paths
=
=
=
undefined
)
{
return
;
}
if
(
paths
[
path
]
>
0
)
{
paths
[
path
]
-
-
;
}
var
key
=
firstKey
(
path
)
;
var
tail
=
path
.
slice
(
key
.
length
+
1
)
;
this
.
unchain
(
key
tail
)
;
}
;
ChainNode
.
prototype
.
chain
=
function
chain
(
key
path
)
{
var
chains
=
this
.
_chains
;
var
node
=
void
0
;
if
(
chains
=
=
=
undefined
)
{
chains
=
this
.
_chains
=
Object
.
create
(
null
)
;
}
else
{
node
=
chains
[
key
]
;
}
if
(
node
=
=
=
undefined
)
{
node
=
chains
[
key
]
=
new
ChainNode
(
this
key
undefined
)
;
}
node
.
count
+
+
;
if
(
path
)
{
key
=
firstKey
(
path
)
;
path
=
path
.
slice
(
key
.
length
+
1
)
;
node
.
chain
(
key
path
)
;
}
}
;
ChainNode
.
prototype
.
unchain
=
function
unchain
(
key
path
)
{
var
chains
=
this
.
_chains
;
var
node
=
chains
[
key
]
;
if
(
path
&
&
path
.
length
>
1
)
{
var
nextKey
=
firstKey
(
path
)
;
var
nextPath
=
path
.
slice
(
nextKey
.
length
+
1
)
;
node
.
unchain
(
nextKey
nextPath
)
;
}
node
.
count
-
-
;
if
(
node
.
count
<
=
0
)
{
chains
[
node
.
_key
]
=
undefined
;
node
.
destroy
(
)
;
}
}
;
ChainNode
.
prototype
.
notify
=
function
notify
(
revalidate
affected
)
{
if
(
revalidate
&
&
this
.
_watching
)
{
var
parentValue
=
this
.
_parent
.
value
(
)
;
if
(
parentValue
!
=
=
this
.
_object
)
{
removeChainWatcher
(
this
.
_object
this
.
_key
this
)
;
if
(
isObject
(
parentValue
)
)
{
this
.
_object
=
parentValue
;
addChainWatcher
(
parentValue
this
.
_key
this
)
;
}
else
{
this
.
_object
=
undefined
;
}
}
this
.
_value
=
undefined
;
}
var
chains
=
this
.
_chains
;
if
(
chains
!
=
=
undefined
)
{
var
node
=
void
0
;
for
(
var
key
in
chains
)
{
node
=
chains
[
key
]
;
if
(
node
!
=
=
undefined
)
{
node
.
notify
(
revalidate
affected
)
;
}
}
}
if
(
affected
&
&
this
.
_parent
)
{
this
.
_parent
.
populateAffected
(
this
.
_key
1
affected
)
;
}
}
;
ChainNode
.
prototype
.
populateAffected
=
function
populateAffected
(
path
depth
affected
)
{
if
(
this
.
_key
)
{
path
=
this
.
_key
+
'
.
'
+
path
;
}
if
(
this
.
_parent
)
{
this
.
_parent
.
populateAffected
(
path
depth
+
1
affected
)
;
}
else
if
(
depth
>
1
)
{
affected
.
push
(
this
.
value
(
)
path
)
;
}
}
;
return
ChainNode
;
}
(
)
;
function
lazyGet
(
obj
key
)
{
if
(
!
isObject
(
obj
)
)
{
return
;
}
var
meta
1
=
peekMeta
(
obj
)
;
if
(
meta
1
!
=
=
undefined
&
&
meta
1
.
proto
=
=
=
obj
)
{
return
;
}
if
(
isVolatile
(
obj
key
meta
1
)
)
{
return
get
(
obj
key
)
;
}
else
{
var
cache
=
meta
1
.
readableCache
(
)
;
if
(
cache
!
=
=
undefined
)
{
return
cacheFor
.
get
(
cache
key
)
;
}
}
}
function
finishChains
(
meta
1
)
{
var
chainWatchers
=
meta
1
.
readableChainWatchers
(
)
;
if
(
chainWatchers
!
=
=
undefined
)
{
chainWatchers
.
revalidateAll
(
)
;
}
if
(
meta
1
.
readableChains
(
)
!
=
=
undefined
)
{
meta
1
.
writableChains
(
makeChainNode
)
;
}
}
var
counters
=
void
0
;
{
counters
=
{
peekCalls
:
0
peekParentCalls
:
0
peekPrototypeWalks
:
0
setCalls
:
0
deleteCalls
:
0
metaCalls
:
0
metaInstantiated
:
0
}
;
}
var
UNDEFINED
=
emberUtils
.
symbol
(
'
undefined
'
)
;
var
SOURCE_DESTROYING
=
1
<
<
1
;
var
SOURCE_DESTROYED
=
1
<
<
2
;
var
META_DESTROYED
=
1
<
<
3
;
var
IS_PROXY
=
1
<
<
4
;
var
NODE_STACK
=
[
]
;
var
Meta
=
function
(
)
{
function
Meta
(
obj
parentMeta
)
{
emberBabel
.
classCallCheck
(
this
Meta
)
;
{
counters
.
metaInstantiated
+
+
;
}
this
.
_cache
=
undefined
;
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
this
.
_descriptors
=
undefined
;
}
this
.
_watching
=
undefined
;
this
.
_mixins
=
undefined
;
if
(
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
{
this
.
_bindings
=
undefined
;
}
this
.
_values
=
undefined
;
this
.
_deps
=
undefined
;
this
.
_chainWatchers
=
undefined
;
this
.
_chains
=
undefined
;
this
.
_tag
=
undefined
;
this
.
_tags
=
undefined
;
this
.
_factory
=
undefined
;
this
.
_flags
=
0
;
this
.
source
=
obj
;
this
.
proto
=
undefined
;
this
.
parent
=
parentMeta
;
this
.
_listeners
=
undefined
;
this
.
_listenersFinalized
=
false
;
}
Meta
.
prototype
.
isInitialized
=
function
isInitialized
(
obj
)
{
return
this
.
proto
!
=
=
obj
;
}
;
Meta
.
prototype
.
destroy
=
function
destroy
(
)
{
if
(
this
.
isMetaDestroyed
(
)
)
{
return
;
}
var
nodes
=
void
0
key
=
void
0
nodeObject
=
void
0
;
var
node
=
this
.
readableChains
(
)
;
if
(
node
!
=
=
undefined
)
{
NODE_STACK
.
push
(
node
)
;
while
(
NODE_STACK
.
length
>
0
)
{
node
=
NODE_STACK
.
pop
(
)
;
nodes
=
node
.
_chains
;
if
(
nodes
!
=
=
undefined
)
{
for
(
key
in
nodes
)
{
if
(
nodes
[
key
]
!
=
=
undefined
)
{
NODE_STACK
.
push
(
nodes
[
key
]
)
;
}
}
}
if
(
node
.
_watching
)
{
nodeObject
=
node
.
_object
;
if
(
nodeObject
!
=
=
undefined
)
{
var
foreignMeta
=
peekMeta
(
nodeObject
)
;
if
(
foreignMeta
&
&
!
foreignMeta
.
isSourceDestroying
(
)
)
{
removeChainWatcher
(
nodeObject
node
.
_key
node
foreignMeta
)
;
}
}
}
}
}
this
.
setMetaDestroyed
(
)
;
}
;
Meta
.
prototype
.
isSourceDestroying
=
function
isSourceDestroying
(
)
{
return
(
this
.
_flags
&
SOURCE_DESTROYING
)
!
=
=
0
;
}
;
Meta
.
prototype
.
setSourceDestroying
=
function
setSourceDestroying
(
)
{
this
.
_flags
|
=
SOURCE_DESTROYING
;
}
;
Meta
.
prototype
.
isSourceDestroyed
=
function
isSourceDestroyed
(
)
{
return
(
this
.
_flags
&
SOURCE_DESTROYED
)
!
=
=
0
;
}
;
Meta
.
prototype
.
setSourceDestroyed
=
function
setSourceDestroyed
(
)
{
this
.
_flags
|
=
SOURCE_DESTROYED
;
}
;
Meta
.
prototype
.
isMetaDestroyed
=
function
isMetaDestroyed
(
)
{
return
(
this
.
_flags
&
META_DESTROYED
)
!
=
=
0
;
}
;
Meta
.
prototype
.
setMetaDestroyed
=
function
setMetaDestroyed
(
)
{
this
.
_flags
|
=
META_DESTROYED
;
}
;
Meta
.
prototype
.
isProxy
=
function
isProxy
(
)
{
return
(
this
.
_flags
&
IS_PROXY
)
!
=
=
0
;
}
;
Meta
.
prototype
.
setProxy
=
function
setProxy
(
)
{
this
.
_flags
|
=
IS_PROXY
;
}
;
Meta
.
prototype
.
_getOrCreateOwnMap
=
function
_getOrCreateOwnMap
(
key
)
{
return
this
[
key
]
|
|
(
this
[
key
]
=
Object
.
create
(
null
)
)
;
}
;
Meta
.
prototype
.
_getInherited
=
function
_getInherited
(
key
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
!
=
=
undefined
)
{
return
map
;
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
_findInherited
=
function
_findInherited
(
key
subkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
!
=
=
undefined
)
{
var
value
=
map
[
subkey
]
;
if
(
value
!
=
=
undefined
)
{
return
value
;
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
writeDeps
=
function
writeDeps
(
subkey
itemkey
value
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
modify
dependent
keys
for
'
+
itemkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
outerMap
=
this
.
_getOrCreateOwnMap
(
'
_deps
'
)
;
var
innerMap
=
outerMap
[
subkey
]
;
if
(
innerMap
=
=
=
undefined
)
{
innerMap
=
outerMap
[
subkey
]
=
Object
.
create
(
null
)
;
}
innerMap
[
itemkey
]
=
value
;
}
;
Meta
.
prototype
.
peekDeps
=
function
peekDeps
(
subkey
itemkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
.
_deps
;
if
(
map
!
=
=
undefined
)
{
var
value
=
map
[
subkey
]
;
if
(
value
!
=
=
undefined
)
{
var
itemvalue
=
value
[
itemkey
]
;
if
(
itemvalue
!
=
=
undefined
)
{
return
itemvalue
;
}
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
hasDeps
=
function
hasDeps
(
subkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
deps
=
pointer
.
_deps
;
if
(
deps
!
=
=
undefined
&
&
deps
[
subkey
]
!
=
=
undefined
)
{
return
true
;
}
pointer
=
pointer
.
parent
;
}
return
false
;
}
;
Meta
.
prototype
.
forEachInDeps
=
function
forEachInDeps
(
subkey
fn
)
{
return
this
.
_forEachIn
(
'
_deps
'
subkey
fn
)
;
}
;
Meta
.
prototype
.
_forEachIn
=
function
_forEachIn
(
key
subkey
fn
)
{
var
pointer
=
this
;
var
seen
=
void
0
;
var
calls
=
void
0
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
!
=
=
undefined
)
{
var
innerMap
=
map
[
subkey
]
;
if
(
innerMap
!
=
=
undefined
)
{
for
(
var
innerKey
in
innerMap
)
{
seen
=
seen
=
=
=
undefined
?
new
Set
(
)
:
seen
;
if
(
!
seen
.
has
(
innerKey
)
)
{
seen
.
add
(
innerKey
)
;
calls
=
calls
|
|
[
]
;
calls
.
push
(
innerKey
innerMap
[
innerKey
]
)
;
}
}
}
}
pointer
=
pointer
.
parent
;
}
if
(
calls
!
=
=
undefined
)
{
for
(
var
i
=
0
;
i
<
calls
.
length
;
i
+
=
2
)
{
fn
(
calls
[
i
]
calls
[
i
+
1
]
)
;
}
}
}
;
Meta
.
prototype
.
writableCache
=
function
writableCache
(
)
{
return
this
.
_getOrCreateOwnMap
(
'
_cache
'
)
;
}
;
Meta
.
prototype
.
readableCache
=
function
readableCache
(
)
{
return
this
.
_cache
;
}
;
Meta
.
prototype
.
writableTags
=
function
writableTags
(
)
{
return
this
.
_getOrCreateOwnMap
(
'
_tags
'
)
;
}
;
Meta
.
prototype
.
readableTags
=
function
readableTags
(
)
{
return
this
.
_tags
;
}
;
Meta
.
prototype
.
writableTag
=
function
writableTag
(
create
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
create
a
new
tag
for
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
ret
=
this
.
_tag
;
if
(
ret
=
=
=
undefined
)
{
ret
=
this
.
_tag
=
create
(
this
.
source
)
;
}
return
ret
;
}
;
Meta
.
prototype
.
readableTag
=
function
readableTag
(
)
{
return
this
.
_tag
;
}
;
Meta
.
prototype
.
writableChainWatchers
=
function
writableChainWatchers
(
create
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
create
a
new
chain
watcher
for
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
ret
=
this
.
_chainWatchers
;
if
(
ret
=
=
=
undefined
)
{
ret
=
this
.
_chainWatchers
=
create
(
this
.
source
)
;
}
return
ret
;
}
;
Meta
.
prototype
.
readableChainWatchers
=
function
readableChainWatchers
(
)
{
return
this
.
_chainWatchers
;
}
;
Meta
.
prototype
.
writableChains
=
function
writableChains
(
create
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
create
a
new
chains
for
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
ret
=
this
.
_chains
;
if
(
ret
=
=
=
undefined
)
{
if
(
this
.
parent
=
=
=
undefined
)
{
ret
=
create
(
this
.
source
)
;
}
else
{
ret
=
this
.
parent
.
writableChains
(
create
)
.
copy
(
this
.
source
)
;
}
this
.
_chains
=
ret
;
}
return
ret
;
}
;
Meta
.
prototype
.
readableChains
=
function
readableChains
(
)
{
return
this
.
_getInherited
(
'
_chains
'
)
;
}
;
Meta
.
prototype
.
writeWatching
=
function
writeWatching
(
subkey
value
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
update
watchers
for
'
+
subkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
map
=
this
.
_getOrCreateOwnMap
(
'
_watching
'
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
.
peekWatching
=
function
peekWatching
(
subkey
)
{
return
this
.
_findInherited
(
'
_watching
'
subkey
)
;
}
;
Meta
.
prototype
.
writeMixins
=
function
writeMixins
(
subkey
value
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
add
mixins
for
'
+
subkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
call
writeMixins
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
map
=
this
.
_getOrCreateOwnMap
(
'
_mixins
'
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
.
peekMixins
=
function
peekMixins
(
subkey
)
{
return
this
.
_findInherited
(
'
_mixins
'
subkey
)
;
}
;
Meta
.
prototype
.
forEachMixins
=
function
forEachMixins
(
fn
)
{
var
pointer
=
this
;
var
seen
=
void
0
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
.
_mixins
;
if
(
map
!
=
=
undefined
)
{
for
(
var
key
in
map
)
{
seen
=
seen
=
=
=
undefined
?
new
Set
(
)
:
seen
;
if
(
!
seen
.
has
(
key
)
)
{
seen
.
add
(
key
)
;
fn
(
key
map
[
key
]
)
;
}
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
writeBindings
=
function
writeBindings
(
subkey
value
)
{
true
&
&
!
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
emberDebug
.
assert
(
'
Cannot
invoke
meta
.
writeBindings
when
EmberENV
.
_ENABLE_BINDING_SUPPORT
is
not
set
'
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
;
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
add
a
binding
for
'
+
subkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
map
=
this
.
_getOrCreateOwnMap
(
'
_bindings
'
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
.
peekBindings
=
function
peekBindings
(
subkey
)
{
true
&
&
!
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
emberDebug
.
assert
(
'
Cannot
invoke
meta
.
peekBindings
when
EmberENV
.
_ENABLE_BINDING_SUPPORT
is
not
set
'
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
;
return
this
.
_findInherited
(
'
_bindings
'
subkey
)
;
}
;
Meta
.
prototype
.
forEachBindings
=
function
forEachBindings
(
fn
)
{
true
&
&
!
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
emberDebug
.
assert
(
'
Cannot
invoke
meta
.
forEachBindings
when
EmberENV
.
_ENABLE_BINDING_SUPPORT
is
not
set
'
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
;
var
pointer
=
this
;
var
seen
=
void
0
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
.
_bindings
;
if
(
map
!
=
=
undefined
)
{
for
(
var
key
in
map
)
{
seen
=
seen
|
|
Object
.
create
(
null
)
;
if
(
seen
[
key
]
=
=
=
undefined
)
{
seen
[
key
]
=
true
;
fn
(
key
map
[
key
]
)
;
}
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
clearBindings
=
function
clearBindings
(
)
{
true
&
&
!
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
emberDebug
.
assert
(
'
Cannot
invoke
meta
.
clearBindings
when
EmberENV
.
_ENABLE_BINDING_SUPPORT
is
not
set
'
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
;
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
clear
bindings
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
this
.
_bindings
=
undefined
;
}
;
Meta
.
prototype
.
writeValues
=
function
writeValues
(
subkey
value
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
set
the
value
of
'
+
subkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
map
=
this
.
_getOrCreateOwnMap
(
'
_values
'
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
.
peekValues
=
function
peekValues
(
subkey
)
{
return
this
.
_findInherited
(
'
_values
'
subkey
)
;
}
;
Meta
.
prototype
.
deleteFromValues
=
function
deleteFromValues
(
subkey
)
{
delete
this
.
_getOrCreateOwnMap
(
'
_values
'
)
[
subkey
]
;
}
;
emberBabel
.
createClass
(
Meta
[
{
key
:
'
factory
'
set
:
function
(
factory
)
{
this
.
_factory
=
factory
;
}
get
:
function
(
)
{
return
this
.
_factory
;
}
}
]
)
;
return
Meta
;
}
(
)
;
for
(
var
name
in
protoMethods
)
{
Meta
.
prototype
[
name
]
=
protoMethods
[
name
]
;
}
if
(
features
.
MANDATORY_SETTER
)
{
Meta
.
prototype
.
readInheritedValue
=
function
(
key
subkey
)
{
var
internalKey
=
'
_
'
+
key
;
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
internalKey
]
;
if
(
map
!
=
=
undefined
)
{
var
value
=
map
[
subkey
]
;
if
(
value
!
=
=
undefined
|
|
subkey
in
map
)
{
return
value
;
}
}
pointer
=
pointer
.
parent
;
}
return
UNDEFINED
;
}
;
Meta
.
prototype
.
writeValue
=
function
(
obj
key
value
)
{
var
descriptor
=
emberUtils
.
lookupDescriptor
(
obj
key
)
;
var
isMandatorySetter
=
descriptor
!
=
=
null
&
&
descriptor
.
set
&
&
descriptor
.
set
.
isMandatorySetter
;
if
(
isMandatorySetter
)
{
this
.
writeValues
(
key
value
)
;
}
else
{
obj
[
key
]
=
value
;
}
}
;
}
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
Meta
.
prototype
.
writeDescriptors
=
function
(
subkey
value
)
{
true
&
&
!
!
this
.
isMetaDestroyed
(
)
&
&
emberDebug
.
assert
(
'
Cannot
update
descriptors
for
'
+
subkey
+
'
on
'
+
emberUtils
.
toString
(
this
.
source
)
+
'
after
it
has
been
destroyed
.
'
!
this
.
isMetaDestroyed
(
)
)
;
var
map
=
this
.
_getOrCreateOwnMap
(
'
_descriptors
'
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
.
peekDescriptors
=
function
(
subkey
)
{
var
possibleDesc
=
this
.
_findInherited
(
'
_descriptors
'
subkey
)
;
return
possibleDesc
=
=
=
UNDEFINED
?
undefined
:
possibleDesc
;
}
;
Meta
.
prototype
.
removeDescriptors
=
function
(
subkey
)
{
this
.
writeDescriptors
(
subkey
UNDEFINED
)
;
}
;
}
var
getPrototypeOf
=
Object
.
getPrototypeOf
;
var
metaStore
=
new
WeakMap
(
)
;
function
setMeta
(
obj
meta
)
{
true
&
&
!
(
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
setMeta
on
null
'
obj
!
=
=
null
)
;
true
&
&
!
(
obj
!
=
=
undefined
)
&
&
emberDebug
.
assert
(
'
Cannot
call
setMeta
on
undefined
'
obj
!
=
=
undefined
)
;
true
&
&
!
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
setMeta
on
'
+
typeof
obj
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
{
counters
.
setCalls
+
+
;
}
metaStore
.
set
(
obj
meta
)
;
}
function
peekMeta
(
obj
)
{
true
&
&
!
(
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
peekMeta
on
null
'
obj
!
=
=
null
)
;
true
&
&
!
(
obj
!
=
=
undefined
)
&
&
emberDebug
.
assert
(
'
Cannot
call
peekMeta
on
undefined
'
obj
!
=
=
undefined
)
;
true
&
&
!
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
peekMeta
on
'
+
typeof
obj
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
var
pointer
=
obj
;
var
meta
=
void
0
;
while
(
pointer
!
=
=
undefined
&
&
pointer
!
=
=
null
)
{
meta
=
metaStore
.
get
(
pointer
)
;
{
counters
.
peekCalls
+
+
;
}
if
(
meta
!
=
=
undefined
)
{
return
meta
;
}
pointer
=
getPrototypeOf
(
pointer
)
;
{
counters
.
peekPrototypeWalks
+
+
;
}
}
}
function
deleteMeta
(
obj
)
{
true
&
&
!
(
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
deleteMeta
on
null
'
obj
!
=
=
null
)
;
true
&
&
!
(
obj
!
=
=
undefined
)
&
&
emberDebug
.
assert
(
'
Cannot
call
deleteMeta
on
undefined
'
obj
!
=
=
undefined
)
;
true
&
&
!
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
deleteMeta
on
'
+
typeof
obj
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
{
counters
.
deleteCalls
+
+
;
}
var
meta
=
peekMeta
(
obj
)
;
if
(
meta
!
=
=
undefined
)
{
meta
.
destroy
(
)
;
}
}
function
meta
(
obj
)
{
true
&
&
!
(
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
meta
on
null
'
obj
!
=
=
null
)
;
true
&
&
!
(
obj
!
=
=
undefined
)
&
&
emberDebug
.
assert
(
'
Cannot
call
meta
on
undefined
'
obj
!
=
=
undefined
)
;
true
&
&
!
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
meta
on
'
+
typeof
obj
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
{
counters
.
metaCalls
+
+
;
}
var
maybeMeta
=
peekMeta
(
obj
)
;
var
parent
=
void
0
;
if
(
maybeMeta
!
=
=
undefined
)
{
if
(
maybeMeta
.
source
=
=
=
obj
)
{
return
maybeMeta
;
}
parent
=
maybeMeta
;
}
var
newMeta
=
new
Meta
(
obj
parent
)
;
setMeta
(
obj
newMeta
)
;
return
newMeta
;
}
var
DESCRIPTOR
=
'
__DESCRIPTOR__
'
;
function
descriptorFor
(
obj
keyName
_meta
)
{
true
&
&
!
(
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
descriptorFor
on
null
'
obj
!
=
=
null
)
;
true
&
&
!
(
obj
!
=
=
undefined
)
&
&
emberDebug
.
assert
(
'
Cannot
call
descriptorFor
on
undefined
'
obj
!
=
=
undefined
)
;
true
&
&
!
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
descriptorFor
on
'
+
typeof
obj
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
var
_meta2
=
_meta
=
=
=
undefined
?
peekMeta
(
obj
)
:
_meta
;
if
(
_meta2
!
=
=
undefined
)
{
return
_meta2
.
peekDescriptors
(
keyName
)
;
}
}
else
{
var
possibleDesc
=
obj
[
keyName
]
;
if
(
features
.
DESCRIPTOR_TRAP
&
&
isDescriptorTrap
(
possibleDesc
)
)
{
return
possibleDesc
[
DESCRIPTOR
]
;
}
else
{
return
isDescriptor
(
possibleDesc
)
?
possibleDesc
:
undefined
;
}
}
}
function
isDescriptorTrap
(
possibleDesc
)
{
if
(
features
.
DESCRIPTOR_TRAP
)
{
return
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
[
DESCRIPTOR
]
!
=
=
undefined
;
}
else
{
throw
new
Error
(
'
Cannot
call
isDescriptorTrap
in
production
'
)
;
}
}
function
isDescriptor
(
possibleDesc
)
{
return
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
;
}
var
Cache
=
function
(
)
{
function
Cache
(
limit
func
key
store
)
{
emberBabel
.
classCallCheck
(
this
Cache
)
;
this
.
size
=
0
;
this
.
misses
=
0
;
this
.
hits
=
0
;
this
.
limit
=
limit
;
this
.
func
=
func
;
this
.
key
=
key
;
this
.
store
=
store
|
|
new
DefaultStore
(
)
;
}
Cache
.
prototype
.
get
=
function
get
(
obj
)
{
var
key
=
this
.
key
=
=
=
undefined
?
obj
:
this
.
key
(
obj
)
;
var
value
=
this
.
store
.
get
(
key
)
;
if
(
value
=
=
=
undefined
)
{
this
.
misses
+
+
;
value
=
this
.
_set
(
key
this
.
func
(
obj
)
)
;
}
else
if
(
value
=
=
=
UNDEFINED
)
{
this
.
hits
+
+
;
value
=
undefined
;
}
else
{
this
.
hits
+
+
;
}
return
value
;
}
;
Cache
.
prototype
.
set
=
function
set
(
obj
value
)
{
var
key
=
this
.
key
=
=
=
undefined
?
obj
:
this
.
key
(
obj
)
;
return
this
.
_set
(
key
value
)
;
}
;
Cache
.
prototype
.
_set
=
function
_set
(
key
value
)
{
if
(
this
.
limit
>
this
.
size
)
{
this
.
size
+
+
;
if
(
value
=
=
=
undefined
)
{
this
.
store
.
set
(
key
UNDEFINED
)
;
}
else
{
this
.
store
.
set
(
key
value
)
;
}
}
return
value
;
}
;
Cache
.
prototype
.
purge
=
function
purge
(
)
{
this
.
store
.
clear
(
)
;
this
.
size
=
0
;
this
.
hits
=
0
;
this
.
misses
=
0
;
}
;
return
Cache
;
}
(
)
;
var
DefaultStore
=
function
(
)
{
function
DefaultStore
(
)
{
emberBabel
.
classCallCheck
(
this
DefaultStore
)
;
this
.
data
=
Object
.
create
(
null
)
;
}
DefaultStore
.
prototype
.
get
=
function
get
(
key
)
{
return
this
.
data
[
key
]
;
}
;
DefaultStore
.
prototype
.
set
=
function
set
(
key
value
)
{
this
.
data
[
key
]
=
value
;
}
;
DefaultStore
.
prototype
.
clear
=
function
clear
(
)
{
this
.
data
=
Object
.
create
(
null
)
;
}
;
return
DefaultStore
;
}
(
)
;
var
firstDotIndexCache
=
new
Cache
(
1000
function
(
key
)
{
return
key
.
indexOf
(
'
.
'
)
;
}
)
;
function
isPath
(
path
)
{
return
typeof
path
=
=
=
'
string
'
&
&
firstDotIndexCache
.
get
(
path
)
!
=
=
-
1
;
}
var
ALLOWABLE_TYPES
=
{
object
:
true
function
:
true
string
:
true
}
;
function
get
(
obj
keyName
)
{
true
&
&
!
(
arguments
.
length
=
=
=
2
)
&
&
emberDebug
.
assert
(
'
Get
must
be
called
with
two
arguments
;
an
object
and
a
property
key
'
arguments
.
length
=
=
=
2
)
;
true
&
&
!
(
obj
!
=
=
undefined
&
&
obj
!
=
=
null
)
&
&
emberDebug
.
assert
(
'
Cannot
call
get
with
\
'
'
+
keyName
+
'
\
'
on
an
undefined
object
.
'
obj
!
=
=
undefined
&
&
obj
!
=
=
null
)
;
true
&
&
!
(
typeof
keyName
=
=
=
'
string
'
|
|
typeof
keyName
=
=
=
'
number
'
&
&
!
isNaN
(
keyName
)
)
&
&
emberDebug
.
assert
(
'
The
key
provided
to
get
must
be
a
string
or
number
you
passed
'
+
keyName
typeof
keyName
=
=
=
'
string
'
|
|
typeof
keyName
=
=
=
'
number
'
&
&
!
isNaN
(
keyName
)
)
;
true
&
&
!
(
typeof
keyName
!
=
=
'
string
'
|
|
keyName
.
lastIndexOf
(
'
this
.
'
0
)
!
=
=
0
)
&
&
emberDebug
.
assert
(
'
\
'
this
\
'
in
paths
is
not
supported
'
typeof
keyName
!
=
=
'
string
'
|
|
keyName
.
lastIndexOf
(
'
this
.
'
0
)
!
=
=
0
)
;
true
&
&
!
(
keyName
!
=
=
'
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
get
with
an
empty
string
'
keyName
!
=
=
'
'
)
;
var
type
=
typeof
obj
;
var
isObject
=
type
=
=
=
'
object
'
;
var
isFunction
=
type
=
=
=
'
function
'
;
var
isObjectLike
=
isObject
|
|
isFunction
;
var
descriptor
=
undefined
;
var
value
=
void
0
;
if
(
isObjectLike
)
{
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
descriptor
=
descriptorFor
(
obj
keyName
)
;
}
if
(
!
features
.
EMBER_METAL_ES5_GETTERS
|
|
descriptor
=
=
=
undefined
)
{
value
=
obj
[
keyName
]
;
if
(
features
.
DESCRIPTOR_TRAP
&
&
isDescriptorTrap
(
value
)
)
{
descriptor
=
value
[
DESCRIPTOR
]
;
}
else
if
(
isDescriptor
(
value
)
)
{
descriptor
=
value
;
}
}
if
(
descriptor
!
=
=
undefined
)
{
return
descriptor
.
get
(
obj
keyName
)
;
}
}
else
{
value
=
obj
[
keyName
]
;
}
if
(
isPath
(
keyName
)
)
{
return
_getPath
(
obj
keyName
)
;
}
else
if
(
value
=
=
=
undefined
&
&
isObject
&
&
!
(
keyName
in
obj
)
&
&
typeof
obj
.
unknownProperty
=
=
=
'
function
'
)
{
return
obj
.
unknownProperty
(
keyName
)
;
}
else
{
return
value
;
}
}
function
_getPath
(
root
path
)
{
var
obj
=
root
;
var
parts
=
path
.
split
(
'
.
'
)
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
if
(
!
isGettable
(
obj
)
)
{
return
undefined
;
}
obj
=
get
(
obj
parts
[
i
]
)
;
if
(
obj
&
&
obj
.
isDestroyed
)
{
return
undefined
;
}
}
return
obj
;
}
function
isGettable
(
obj
)
{
return
obj
!
=
=
undefined
&
&
obj
!
=
=
null
&
&
ALLOWABLE_TYPES
[
typeof
obj
]
;
}
function
getWithDefault
(
root
key
defaultValue
)
{
var
value
=
get
(
root
key
)
;
if
(
value
=
=
=
undefined
)
{
return
defaultValue
;
}
return
value
;
}
function
set
(
obj
keyName
value
tolerant
)
{
true
&
&
!
(
arguments
.
length
=
=
=
3
|
|
arguments
.
length
=
=
=
4
)
&
&
emberDebug
.
assert
(
'
Set
must
be
called
with
three
or
four
arguments
;
an
object
a
property
key
a
value
and
tolerant
true
/
false
'
arguments
.
length
=
=
=
3
|
|
arguments
.
length
=
=
=
4
)
;
true
&
&
!
(
obj
&
&
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
Cannot
call
set
with
\
'
'
+
keyName
+
'
\
'
on
an
undefined
object
.
'
obj
&
&
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
;
true
&
&
!
(
typeof
keyName
=
=
=
'
string
'
|
|
typeof
keyName
=
=
=
'
number
'
&
&
!
isNaN
(
keyName
)
)
&
&
emberDebug
.
assert
(
'
The
key
provided
to
set
must
be
a
string
or
number
you
passed
'
+
keyName
typeof
keyName
=
=
=
'
string
'
|
|
typeof
keyName
=
=
=
'
number
'
&
&
!
isNaN
(
keyName
)
)
;
true
&
&
!
(
typeof
keyName
!
=
=
'
string
'
|
|
keyName
.
lastIndexOf
(
'
this
.
'
0
)
!
=
=
0
)
&
&
emberDebug
.
assert
(
'
\
'
this
\
'
in
paths
is
not
supported
'
typeof
keyName
!
=
=
'
string
'
|
|
keyName
.
lastIndexOf
(
'
this
.
'
0
)
!
=
=
0
)
;
true
&
&
!
!
obj
.
isDestroyed
&
&
emberDebug
.
assert
(
'
calling
set
on
destroyed
object
:
'
+
emberUtils
.
toString
(
obj
)
+
'
.
'
+
keyName
+
'
=
'
+
emberUtils
.
toString
(
value
)
!
obj
.
isDestroyed
)
;
if
(
isPath
(
keyName
)
)
{
return
setPath
(
obj
keyName
value
tolerant
)
;
}
if
(
features
.
EMBER_METAL_ES5_GETTERS
)
{
var
possibleDesc
=
descriptorFor
(
obj
keyName
)
;
if
(
possibleDesc
!
=
=
undefined
)
{
possibleDesc
.
set
(
obj
keyName
value
)
;
return
value
;
}
}
var
currentValue
=
obj
[
keyName
]
;
if
(
features
.
DESCRIPTOR_TRAP
&
&
isDescriptorTrap
(
currentValue
)
)
{
currentValue
=
currentValue
[
DESCRIPTOR
]
;
}
if
(
isDescriptor
(
currentValue
)
)
{
currentValue
.
set
(
obj
keyName
value
)
;
}
else
if
(
currentValue
=
=
=
undefined
&
&
'
object
'
=
=
=
typeof
obj
&
&
!
(
keyName
in
obj
)
&
&
typeof
obj
.
setUnknownProperty
=
=
=
'
function
'
)
{
obj
.
setUnknownProperty
(
keyName
value
)
;
}
else
if
(
currentValue
=
=
=
value
)
{
}
else
{
var
meta
1
=
peekMeta
(
obj
)
;
propertyWillChange
(
obj
keyName
meta
1
)
;
if
(
features
.
MANDATORY_SETTER
)
{
setWithMandatorySetter
(
meta
1
obj
keyName
value
)
;
}
else
{
obj
[
keyName
]
=
value
;
}
propertyDidChange
(
obj
keyName
meta
1
)
;
}
return
value
;
}
if
(
features
.
MANDATORY_SETTER
)
{
var
setWithMandatorySetter
=
function
(
meta
1
obj
keyName
value
)
{
if
(
meta
1
!
=
=
undefined
&
&
meta
1
.
peekWatching
(
keyName
)
>
0
)
{
makeEnumerable
(
obj
keyName
)
;
meta
1
.
writeValue
(
obj
keyName
value
)
;
}
else
{
obj
[
keyName
]
=
value
;
}
}
;
var
makeEnumerable
=
function
(
obj
key
)
{
var
desc
=
Object
.
getOwnPropertyDescriptor
(
obj
key
)
;
if
(
desc
&
&
desc
.
set
&
&
desc
.
set
.
isMandatorySetter
)
{
desc
.
enumerable
=
true
;
Object
.
defineProperty
(
obj
key
desc
)
;
}
}
;
}
function
setPath
(
root
path
value
tolerant
)
{
var
parts
=
path
.
split
(
'
.
'
)
;
var
keyName
=
parts
.
pop
(
)
;
true
&
&
!
(
keyName
.
trim
(
)
.
length
>
0
)
&
&
emberDebug
.
assert
(
'
Property
set
failed
:
You
passed
an
empty
path
'
keyName
.
trim
(
)
.
length
>
0
)
;
var
newPath
=
parts
.
join
(
'
.
'
)
;
var
newRoot
=
_getPath
(
root
newPath
)
;
if
(
newRoot
)
{
return
set
(
newRoot
keyName
value
)
;
}
else
if
(
!
tolerant
)
{
throw
new
emberDebug
.
Error
(
'
Property
set
failed
:
object
in
path
"
'
+
newPath
+
'
"
could
not
be
found
or
was
destroyed
.
'
)
;
}
}
function
trySet
(
root
path
value
)
{
return
set
(
root
path
value
true
)
;
}
var
END_WITH_EACH_REGEX
=
/
\
.
each
/
;
function
expandProperties
(
pattern
callback
)
{
true
&
&
!
(
typeof
pattern
=
=
=
'
string
'
)
&
&
emberDebug
.
assert
(
'
A
computed
property
key
must
be
a
string
you
passed
'
+
typeof
pattern
+
'
'
+
pattern
typeof
pattern
=
=
=
'
string
'
)
;
true
&
&
!
(
pattern
.
indexOf
(
'
'
)
=
=
=
-
1
)
&
&
emberDebug
.
assert
(
'
Brace
expanded
properties
cannot
contain
spaces
e
.
g
.
"
user
.
{
firstName
lastName
}
"
should
be
"
user
.
{
firstName
lastName
}
"
'
pattern
.
indexOf
(
'
'
)
=
=
=
-
1
)
;
true
&
&
!
(
pattern
.
match
(
/
\
{
[
^
}
{
]
*
\
{
|
\
}
[
^
}
{
]
*
\
}
|
\
{
[
^
}
]
*
/
g
)
=
=
=
null
)
&
&
emberDebug
.
assert
(
'
Brace
expanded
properties
have
to
be
balanced
and
cannot
be
nested
pattern
:
'
+
pattern
pattern
.
match
(
/
\
{
[
^
}
{
]
*
\
{
|
\
}
[
^
}
{
]
*
\
}
|
\
{
[
^
}
]
*
/
g
)
=
=
=
null
)
;
var
start
=
pattern
.
indexOf
(
'
{
'
)
;
if
(
start
<
0
)
{
callback
(
pattern
.
replace
(
END_WITH_EACH_REGEX
'
.
[
]
'
)
)
;
}
else
{
dive
(
'
'
pattern
start
callback
)
;
}
}
function
dive
(
prefix
pattern
start
callback
)
{
var
end
=
pattern
.
indexOf
(
'
}
'
)
i
=
0
newStart
=
void
0
arrayLength
=
void
0
;
var
tempArr
=
pattern
.
substring
(
start
+
1
end
)
.
split
(
'
'
)
;
var
after
=
pattern
.
substring
(
end
+
1
)
;
prefix
=
prefix
+
pattern
.
substring
(
0
start
)
;
arrayLength
=
tempArr
.
length
;
while
(
i
<
arrayLength
)
{
newStart
=
after
.
indexOf
(
'
{
'
)
;
if
(
newStart
<
0
)
{
callback
(
(
prefix
+
tempArr
[
i
+
+
]
+
after
)
.
replace
(
END_WITH_EACH_REGEX
'
.
[
]
'
)
)
;
}
else
{
dive
(
prefix
+
tempArr
[
i
+
+
]
after
newStart
callback
)
;
}
}
}
function
addDependentKeys
(
desc
obj
keyName
meta
)
{
var
depKeys
=
desc
.
_dependentKeys
;
if
(
depKeys
=
=
=
null
|
|
depKeys
=
=
=
undefined
)
{
return
;
}
for
(
var
idx
=
0
;
idx
<
depKeys
.
length
;
idx
+
+
)
{
var
depKey
=
depKeys
[
idx
]
;
meta
.
writeDeps
(
depKey
keyName
(
meta
.
peekDeps
(
depKey
keyName
)
|
|
0
)
+
1
)
;
watch
(
obj
depKey
meta
)
;
}
}
function
removeDependentKeys
(
desc
obj
keyName
meta
)
{
var
depKeys
=
desc
.
_dependentKeys
;
if
(
depKeys
=
=
=
null
|
|
depKeys
=
=
=
undefined
)
{
return
;
}
for
(
var
idx
=
0
;
idx
<
depKeys
.
length
;
idx
+
+
)
{
var
depKey
=
depKeys
[
idx
]
;
meta
.
writeDeps
(
depKey
keyName
(
meta
.
peekDeps
(
depKey
keyName
)
|
|
0
)
-
1
)
;
unwatch
(
obj
depKey
meta
)
;
}
}
var
DEEP_EACH_REGEX
=
/
\
.
each
\
.
[
^
.
]
+
\
.
/
;
function
ComputedProperty
(
config
opts
)
{
this
.
isDescriptor
=
true
;
var
hasGetterOnly
=
typeof
config
=
=
=
'
function
'
;
if
(
hasGetterOnly
)
{
this
.
_getter
=
config
;
}
else
{
true
&
&
!
(
typeof
config
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
config
)
)
&
&
emberDebug
.
assert
(
'
computed
expects
a
function
or
an
object
as
last
argument
.
'
typeof
config
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
config
)
)
;
true
&
&
!
Object
.
keys
(
config
)
.
every
(
function
(
key
)
{
return
key
=
=
=
'
get
'
|
|
key
=
=
=
'
set
'
;
}
)
&
&
emberDebug
.
assert
(
'
Config
object
passed
to
computed
can
only
contain
get
or
set
keys
.
'
Object
.
keys
(
config
)
.
every
(
function
(
key
)
{
return
key
=
=
=
'
get
'
|
|
key
=
=
=
'
set
'
;
}
)
)
;
this
.
_getter
=
config
.
get
;
this
.
_setter
=
config
.
set
;
}
true
&
&
!
(
!
!
this
.
_getter
|
|
!
!
this
.
_setter
)
&
&
emberDebug
.
assert
(
'
Computed
properties
must
receive
a
getter
or
a
setter
you
passed
none
.
'
!
!
this
.
_getter
|
|
!
!
this
.
_setter
)
;
this
.
_suspended
=
undefined
;
this
.
_meta
=
undefined
;
this
.
_volatile
=
false
;
this
.
_dependentKeys
=
opts
&
&
opts
.
dependentKeys
;
this
.
_readOnly
=
opts
&
&
hasGetterOnly
&
&
opts
.
readOnly
=
=
=
true
;
}
ComputedProperty
.
prototype
=
new
Descriptor
(
)
;
ComputedProperty
.
prototype
.
constructor
=
ComputedProperty
;
var
ComputedPropertyPrototype
=
ComputedProperty
.
prototype
;
ComputedPropertyPrototype
.
volatile
=
function
(
)
{
this
.
_volatile
=
true
;
return
this
;
}
;
ComputedPropertyPrototype
.
readOnly
=
function
(
)
{
this
.
_readOnly
=
true
;
true
&
&
!
!
(
this
.
_readOnly
&
&
this
.
_setter
&
&
this
.
_setter
!
=
=
this
.
_getter
)
&
&
emberDebug
.
assert
(
'
Computed
properties
that
define
a
setter
using
the
new
syntax
cannot
be
read
-
only
'
!
(
this
.
_readOnly
&
&
this
.
_setter
&
&
this
.
_setter
!
=
=
this
.
_getter
)
)
;
return
this
;
}
;
ComputedPropertyPrototype
.
property
=
function
(
)
{
var
args
=
[
]
;
function
addArg
(
property
)
{
true
&
&
emberDebug
.
warn
(
'
Dependent
keys
containing
each
only
work
one
level
deep
.
'
+
(
'
You
used
the
key
"
'
+
property
+
'
"
which
is
invalid
.
'
)
+
'
Please
create
an
intermediary
computed
property
.
'
DEEP_EACH_REGEX
.
test
(
property
)
=
=
=
false
{
id
:
'
ember
-
metal
.
computed
-
deep
-
each
'
}
)
;
args
.
push
(
property
)
;
}
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
expandProperties
(
arguments
[
i
]
addArg
)
;
}
this
.
_dependentKeys
=
args
;
return
this
;
}
;
ComputedPropertyPrototype
.
meta
=
function
(
meta
1
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
.
_meta
|
|
{
}
;
}
else
{
this
.
_meta
=
meta
1
;
return
this
;
}
}
;
ComputedPropertyPrototype
.
didChange
=
function
(
obj
keyName
)
{
if
(
this
.
_volatile
|
|
this
.
_suspended
=
=
=
obj
)
{
return
;
}
var
meta
1
=
peekMeta
(
obj
)
;
if
(
meta
1
=
=
=
undefined
|
|
meta
1
.
source
!
=
=
obj
)
{
return
;
}
var
cache
=
meta
1
.
readableCache
(
)
;
if
(
cache
!
=
=
undefined
&
&
cache
[
keyName
]
!
=
=
undefined
)
{
cache
[
keyName
]
=
undefined
;
removeDependentKeys
(
this
obj
keyName
meta
1
)
;
}
}
;
ComputedPropertyPrototype
.
get
=
function
(
obj
keyName
)
{
if
(
this
.
_volatile
)
{
return
this
.
_getter
.
call
(
obj
keyName
)
;
}
var
meta
1
=
meta
(
obj
)
;
var
cache
=
meta
1
.
writableCache
(
)
;
var
result
=
cache
[
keyName
]
;
if
(
result
=
=
=
UNDEFINED
)
{
return
undefined
;
}
else
if
(
result
!
=
=
undefined
)
{
return
result
;
}
var
ret
=
this
.
_getter
.
call
(
obj
keyName
)
;
cache
[
keyName
]
=
ret
=
=
=
undefined
?
UNDEFINED
:
ret
;
var
chainWatchers
=
meta
1
.
readableChainWatchers
(
)
;
if
(
chainWatchers
!
=
=
undefined
)
{
chainWatchers
.
revalidate
(
keyName
)
;
}
addDependentKeys
(
this
obj
keyName
meta
1
)
;
return
ret
;
}
;
ComputedPropertyPrototype
.
set
=
function
computedPropertySetEntry
(
obj
keyName
value
)
{
if
(
this
.
_readOnly
)
{
this
.
_throwReadOnlyError
(
obj
keyName
)
;
}
if
(
!
this
.
_setter
)
{
return
this
.
clobberSet
(
obj
keyName
value
)
;
}
if
(
this
.
_volatile
)
{
return
this
.
volatileSet
(
obj
keyName
value
)
;
}
return
this
.
setWithSuspend
(
obj
keyName
value
)
;
}
;
ComputedPropertyPrototype
.
_throwReadOnlyError
=
function
computedPropertyThrowReadOnlyError
(
obj
keyName
)
{
throw
new
emberDebug
.
Error
(
'
Cannot
set
read
-
only
property
"
'
+
keyName
+
'
"
on
object
:
'
+
emberUtils
.
inspect
(
obj
)
)
;
}
;
ComputedPropertyPrototype
.
clobberSet
=
function
computedPropertyClobberSet
(
obj
keyName
value
)
{
var
cachedValue
=
cacheFor
(
obj
keyName
)
;
defineProperty
(
obj
keyName
null
cachedValue
)
;
set
(
obj
keyName
value
)
;
return
value
;
}
;
ComputedPropertyPrototype
.
volatileSet
=
function
computedPropertyVolatileSet
(
obj
keyName
value
)
{
return
this
.
_setter
.
call
(
obj
keyName
value
)
;
}
;
ComputedPropertyPrototype
.
setWithSuspend
=
function
computedPropertySetWithSuspend
(
obj
keyName
value
)
{
var
oldSuspended
=
this
.
_suspended
;
this
.
_suspended
=
obj
;
try
{
return
this
.
_set
(
obj
keyName
value
)
;
}
finally
{
this
.
_suspended
=
oldSuspended
;
}
}
;
ComputedPropertyPrototype
.
_set
=
function
computedPropertySet
(
obj
keyName
value
)
{
var
meta
1
=
meta
(
obj
)
;
var
cache
=
meta
1
.
writableCache
(
)
;
var
val
=
cache
[
keyName
]
;
var
hadCachedValue
=
val
!
=
=
undefined
;
var
cachedValue
=
void
0
;
if
(
hadCachedValue
&
&
val
!
=
=
UNDEFINED
)
{
cachedValue
=
val
;
}
var
ret
=
this
.
_setter
.
call
(
obj
keyName
value
cachedValue
)
;
if
(
hadCachedValue
&
&
cachedValue
=
=
=
ret
)
{
return
ret
;
}
propertyWillChange
(
obj
keyName
meta
1
)
;
if
(
!
hadCachedValue
)
{
addDependentKeys
(
this
obj
keyName
meta
1
)
;
}
cache
[
keyName
]
=
ret
=
=
=
undefined
?
UNDEFINED
:
ret
;
propertyDidChange
(
obj
keyName
meta
1
)
;
return
ret
;
}
;
ComputedPropertyPrototype
.
teardown
=
function
(
obj
keyName
meta
1
)
{
if
(
this
.
_volatile
)
{
return
;
}
var
cache
=
meta
1
.
readableCache
(
)
;
if
(
cache
!
=
=
undefined
&
&
cache
[
keyName
]
!
=
=
undefined
)
{
removeDependentKeys
(
this
obj
keyName
meta
1
)
;
cache
[
keyName
]
=
undefined
;
}
}
;
function
computed
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
func
=
args
.
pop
(
)
;
var
cp
=
new
ComputedProperty
(
func
)
;
if
(
args
.
length
>
0
)
{
cp
.
property
.
apply
(
cp
args
)
;
}
return
cp
;
}
function
cacheFor
(
obj
key
)
{
var
meta
1
=
peekMeta
(
obj
)
;
var
cache
=
meta
1
!
=
=
undefined
?
meta
1
.
source
=
=
=
obj
&
&
meta
1
.
readableCache
(
)
:
undefined
;
var
ret
=
cache
!
=
=
undefined
?
cache
[
key
]
:
undefined
;
if
(
ret
=
=
=
UNDEFINED
)
{
return
undefined
;
}
return
ret
;
}
cacheFor
.
set
=
function
(
cache
key
value
)
{
if
(
value
=
=
=
undefined
)
{
cache
[
key
]
=
UNDEFINED
;
}
else
{
cache
[
key
]
=
value
;
}
}
;
cacheFor
.
get
=
function
(
cache
key
)
{
var
ret
=
cache
[
key
]
;
if
(
ret
=
=
=
UNDEFINED
)
{
return
undefined
;
}
return
ret
;
}
;
cacheFor
.
remove
=
function
(
cache
key
)
{
cache
[
key
]
=
undefined
;
}
;
var
CONSUMED
=
{
}
;
function
alias
(
altKey
)
{
return
new
AliasedProperty
(
altKey
)
;
}
var
AliasedProperty
=
function
(
_Descriptor
)
{
emberBabel
.
inherits
(
AliasedProperty
_Descriptor
)
;
function
AliasedProperty
(
altKey
)
{
emberBabel
.
classCallCheck
(
this
AliasedProperty
)
;
var
_this
=
emberBabel
.
possibleConstructorReturn
(
this
_Descriptor
.
call
(
this
)
)
;
_this
.
isDescriptor
=
true
;
_this
.
altKey
=
altKey
;
_this
.
_dependentKeys
=
[
altKey
]
;
return
_this
;
}
AliasedProperty
.
prototype
.
setup
=
function
setup
(
obj
keyName
)
{
true
&
&
!
(
this
.
altKey
!
=
=
keyName
)
&
&
emberDebug
.
assert
(
'
Setting
alias
\
'
'
+
keyName
+
'
\
'
on
self
'
this
.
altKey
!
=
=
keyName
)
;
var
meta
1
=
meta
(
obj
)
;
if
(
meta
1
.
peekWatching
(
keyName
)
)
{
addDependentKeys
(
this
obj
keyName
meta
1
)
;
}
}
;
AliasedProperty
.
prototype
.
teardown
=
function
teardown
(
obj
keyName
meta
1
)
{
if
(
meta
1
.
peekWatching
(
keyName
)
)
{
removeDependentKeys
(
this
obj
keyName
meta
1
)
;
}
}
;
AliasedProperty
.
prototype
.
willWatch
=
function
willWatch
(
obj
keyName
meta
1
)
{
addDependentKeys
(
this
obj
keyName
meta
1
)
;
}
;
AliasedProperty
.
prototype
.
didUnwatch
=
function
didUnwatch
(
obj
keyName
meta
1
)
{
removeDependentKeys
(
this
obj
keyName
meta
1
)
;
}
;
AliasedProperty
.
prototype
.
get
=
function
get
1
(
obj
keyName
)
{
var
ret
=
get
(
obj
this
.
altKey
)
;
var
meta
1
=
meta
(
obj
)
;
var
cache
=
meta
1
.
writableCache
(
)
;
if
(
cache
[
keyName
]
!
=
=
CONSUMED
)
{
cache
[
keyName
]
=
CONSUMED
;
addDependentKeys
(
this
obj
keyName
meta
1
)
;
}
return
ret
;
}
;
AliasedProperty
.
prototype
.
set
=
function
set
1
(
obj
keyName
value
)
{
return
set
(
obj
this
.
altKey
value
)
;
}
;
AliasedProperty
.
prototype
.
readOnly
=
function
readOnly
(
)
{
this
.
set
=
AliasedProperty_readOnlySet
;
return
this
;
}
;
AliasedProperty
.
prototype
.
oneWay
=
function
oneWay
(
)
{
this
.
set
=
AliasedProperty_oneWaySet
;
return
this
;
}
;
return
AliasedProperty
;
}
(
Descriptor
)
;
function
AliasedProperty_readOnlySet
(
obj
keyName
value
)
{
throw
new
emberDebug
.
Error
(
'
Cannot
set
read
-
only
property
\
'
'
+
keyName
+
'
\
'
on
object
:
'
+
emberUtils
.
inspect
(
obj
)
)
;
}
function
AliasedProperty_oneWaySet
(
obj
keyName
value
)
{
defineProperty
(
obj
keyName
null
)
;
return
set
(
obj
keyName
value
)
;
}
AliasedProperty
.
prototype
.
_meta
=
undefined
;
AliasedProperty
.
prototype
.
meta
=
ComputedProperty
.
prototype
.
meta
;
function
merge
(
original
updates
)
{
if
(
updates
=
=
=
null
|
|
typeof
updates
!
=
=
'
object
'
)
{
return
original
;
}
var
props
=
Object
.
keys
(
updates
)
;
var
prop
=
void
0
;
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
prop
=
props
[
i
]
;
original
[
prop
]
=
updates
[
prop
]
;
}
return
original
;
}
function
deprecateProperty
(
object
deprecatedKey
newKey
options
)
{
function
_deprecate
(
)
{
true
&
&
!
false
&
&
emberDebug
.
deprecate
(
'
Usage
of
'
+
deprecatedKey
+
'
is
deprecated
use
'
+
newKey
+
'
instead
.
'
false
options
)
;
}
Object
.
defineProperty
(
object
deprecatedKey
{
configurable
:
true
enumerable
:
false
set
:
function
(
value
)
{
_deprecate
(
)
;
set
(
this
newKey
value
)
;
}
get
:
function
(
)
{
_deprecate
(
)
;
return
get
(
this
newKey
)
;
}
}
)
;
}
var
subscribers
=
[
]
;
var
cache
=
{
}
;
function
populateListeners
(
name
)
{
var
listeners
=
[
]
;
var
subscriber
=
void
0
;
for
(
var
i
=
0
;
i
<
subscribers
.
length
;
i
+
+
)
{
subscriber
=
subscribers
[
i
]
;
if
(
subscriber
.
regex
.
test
(
name
)
)
{
listeners
.
push
(
subscriber
.
object
)
;
}
}
cache
[
name
]
=
listeners
;
return
listeners
;
}
var
time
=
function
(
)
{
var
perf
=
'
undefined
'
!
=
=
typeof
window
?
window
.
performance
|
|
{
}
:
{
}
;
var
fn
=
perf
.
now
|
|
perf
.
mozNow
|
|
perf
.
webkitNow
|
|
perf
.
msNow
|
|
perf
.
oNow
;
return
fn
?
fn
.
bind
(
perf
)
:
function
(
)
{
return
+
new
Date
(
)
;
}
;
}
(
)
;
function
instrument
(
name
_payload
callback
binding
)
{
if
(
arguments
.
length
<
=
3
&
&
typeof
_payload
=
=
=
'
function
'
)
{
binding
=
callback
;
callback
=
_payload
;
_payload
=
undefined
;
}
if
(
subscribers
.
length
=
=
=
0
)
{
return
callback
.
call
(
binding
)
;
}
var
payload
=
_payload
|
|
{
}
;
var
finalizer
=
_instrumentStart
(
name
function
(
)
{
return
payload
;
}
)
;
if
(
finalizer
)
{
return
withFinalizer
(
callback
finalizer
payload
binding
)
;
}
else
{
return
callback
.
call
(
binding
)
;
}
}
exports
.
flaggedInstrument
=
void
0
;
if
(
features
.
EMBER_IMPROVED_INSTRUMENTATION
)
{
exports
.
flaggedInstrument
=
instrument
;
}
else
{
exports
.
flaggedInstrument
=
function
(
name
payload
callback
)
{
return
callback
(
)
;
}
;
}
function
withFinalizer
(
callback
finalizer
payload
binding
)
{
var
result
=
void
0
;
try
{
result
=
callback
.
call
(
binding
)
;
}
catch
(
e
)
{
payload
.
exception
=
e
;
result
=
payload
;
}
finally
{
finalizer
(
)
;
}
return
result
;
}
function
NOOP
(
)
{
}
function
_instrumentStart
(
name
_payload
_payloadParam
)
{
if
(
subscribers
.
length
=
=
=
0
)
{
return
NOOP
;
}
var
listeners
=
cache
[
name
]
;
if
(
!
listeners
)
{
listeners
=
populateListeners
(
name
)
;
}
if
(
listeners
.
length
=
=
=
0
)
{
return
NOOP
;
}
var
payload
=
_payload
(
_payloadParam
)
;
var
STRUCTURED_PROFILE
=
emberEnvironment
.
ENV
.
STRUCTURED_PROFILE
;
var
timeName
=
void
0
;
if
(
STRUCTURED_PROFILE
)
{
timeName
=
name
+
'
:
'
+
payload
.
object
;
console
.
time
(
timeName
)
;
}
var
beforeValues
=
new
Array
(
listeners
.
length
)
;
var
i
=
void
0
listener
=
void
0
;
var
timestamp
=
time
(
)
;
for
(
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listener
=
listeners
[
i
]
;
beforeValues
[
i
]
=
listener
.
before
(
name
timestamp
payload
)
;
}
return
function
_instrumentEnd
(
)
{
var
i
=
void
0
listener
=
void
0
;
var
timestamp
=
time
(
)
;
for
(
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listener
=
listeners
[
i
]
;
if
(
typeof
listener
.
after
=
=
=
'
function
'
)
{
listener
.
after
(
name
timestamp
payload
beforeValues
[
i
]
)
;
}
}
if
(
STRUCTURED_PROFILE
)
{
console
.
timeEnd
(
timeName
)
;
}
}
;
}
function
subscribe
(
pattern
object
)
{
var
paths
=
pattern
.
split
(
'
.
'
)
;
var
path
=
void
0
;
var
regex
=
[
]
;
for
(
var
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
path
=
paths
[
i
]
;
if
(
path
=
=
=
'
*
'
)
{
regex
.
push
(
'
[
^
\
\
.
]
*
'
)
;
}
else
{
regex
.
push
(
path
)
;
}
}
regex
=
regex
.
join
(
'
\
\
.
'
)
;
regex
=
regex
+
'
(
\
\
.
.
*
)
?
'
;
var
subscriber
=
{
pattern
:
pattern
regex
:
new
RegExp
(
'
^
'
+
regex
+
'
'
)
object
:
object
}
;
subscribers
.
push
(
subscriber
)
;
cache
=
{
}
;
return
subscriber
;
}
function
unsubscribe
(
subscriber
)
{
var
index
=
void
0
;
for
(
var
i
=
0
;
i
<
subscribers
.
length
;
i
+
+
)
{
if
(
subscribers
[
i
]
=
=
=
subscriber
)
{
index
=
i
;
}
}
subscribers
.
splice
(
index
1
)
;
cache
=
{
}
;
}
function
reset
(
)
{
subscribers
.
length
=
0
;
cache
=
{
}
;
}
var
onerror
=
void
0
;
var
onErrorTarget
=
{
get
onerror
(
)
{
return
onerror
;
}
}
;
function
getOnerror
(
)
{
return
onerror
;
}
function
setOnerror
(
handler
)
{
onerror
=
handler
;
}
var
dispatchOverride
=
void
0
;
function
getDispatchOverride
(
)
{
return
dispatchOverride
;
}
function
setDispatchOverride
(
handler
)
{
dispatchOverride
=
handler
;
}
function
isNone
(
obj
)
{
return
obj
=
=
=
null
|
|
obj
=
=
=
undefined
;
}
function
isEmpty
(
obj
)
{
var
none
=
isNone
(
obj
)
;
if
(
none
)
{
return
none
;
}
if
(
typeof
obj
.
size
=
=
=
'
number
'
)
{
return
!
obj
.
size
;
}
var
objectType
=
typeof
obj
;
if
(
objectType
=
=
=
'
object
'
)
{
var
size
=
get
(
obj
'
size
'
)
;
if
(
typeof
size
=
=
=
'
number
'
)
{
return
!
size
;
}
}
if
(
typeof
obj
.
length
=
=
=
'
number
'
&
&
objectType
!
=
=
'
function
'
)
{
return
!
obj
.
length
;
}
if
(
objectType
=
=
=
'
object
'
)
{
var
length
=
get
(
obj
'
length
'
)
;
if
(
typeof
length
=
=
=
'
number
'
)
{
return
!
length
;
}
}
return
false
;
}
function
isBlank
(
obj
)
{
return
isEmpty
(
obj
)
|
|
typeof
obj
=
=
=
'
string
'
&
&
/
\
S
/
.
test
(
obj
)
=
=
=
false
;
}
function
isPresent
(
obj
)
{
return
!
isBlank
(
obj
)
;
}
function
onBegin
(
current
)
{
run
.
currentRunLoop
=
current
;
}
function
onEnd
(
current
next
)
{
run
.
currentRunLoop
=
next
;
}
var
backburner
1
=
new
Backburner
(
[
'
sync
'
'
actions
'
'
destroy
'
]
{
sync
:
{
before
:
beginPropertyChanges
after
:
endPropertyChanges
}
defaultQueue
:
'
actions
'
onBegin
:
onBegin
onEnd
:
onEnd
onErrorTarget
:
onErrorTarget
onErrorMethod
:
'
onerror
'
}
)
;
function
run
(
)
{
return
backburner
1
.
run
.
apply
(
backburner
1
arguments
)
;
}
run
.
join
=
function
(
)
{
return
backburner
1
.
join
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
bind
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
curried
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
curried
[
_key
]
=
arguments
[
_key
]
;
}
return
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
run
.
join
.
apply
(
run
curried
.
concat
(
args
)
)
;
}
;
}
;
run
.
backburner
=
backburner
1
;
run
.
currentRunLoop
=
null
;
run
.
queues
=
backburner
1
.
queueNames
;
run
.
begin
=
function
(
)
{
backburner
1
.
begin
(
)
;
}
;
run
.
end
=
function
(
)
{
backburner
1
.
end
(
)
;
}
;
run
.
schedule
=
function
(
queue
)
{
true
&
&
!
(
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
&
&
emberDebug
.
assert
(
'
You
have
turned
on
testing
mode
which
disabled
the
run
-
loop
\
'
s
autorun
.
'
+
'
You
will
need
to
wrap
any
code
with
asynchronous
side
-
effects
in
a
run
'
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
;
true
&
&
!
(
queue
!
=
=
'
sync
'
)
&
&
emberDebug
.
deprecate
(
'
Scheduling
into
the
\
'
'
+
queue
+
'
\
'
run
loop
queue
is
deprecated
.
'
queue
!
=
=
'
sync
'
{
id
:
'
ember
-
metal
.
run
.
sync
'
until
:
'
3
.
5
.
0
'
}
)
;
return
backburner
1
.
schedule
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
hasScheduledTimers
=
function
(
)
{
return
backburner
1
.
hasTimers
(
)
;
}
;
run
.
cancelTimers
=
function
(
)
{
backburner
1
.
cancelTimers
(
)
;
}
;
run
.
later
=
function
(
)
{
return
backburner
1
.
later
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
once
=
function
(
)
{
true
&
&
!
(
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
&
&
emberDebug
.
assert
(
'
You
have
turned
on
testing
mode
which
disabled
the
run
-
loop
\
'
s
autorun
.
'
+
'
You
will
need
to
wrap
any
code
with
asynchronous
side
-
effects
in
a
run
'
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
;
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
args
.
unshift
(
'
actions
'
)
;
return
backburner
1
.
scheduleOnce
.
apply
(
backburner
1
args
)
;
}
;
run
.
scheduleOnce
=
function
(
queue
)
{
true
&
&
!
(
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
&
&
emberDebug
.
assert
(
'
You
have
turned
on
testing
mode
which
disabled
the
run
-
loop
\
'
s
autorun
.
'
+
'
You
will
need
to
wrap
any
code
with
asynchronous
side
-
effects
in
a
run
'
run
.
currentRunLoop
|
|
!
emberDebug
.
isTesting
(
)
)
;
true
&
&
!
(
queue
!
=
=
'
sync
'
)
&
&
emberDebug
.
deprecate
(
'
Scheduling
into
the
\
'
'
+
queue
+
'
\
'
run
loop
queue
is
deprecated
.
'
queue
!
=
=
'
sync
'
{
id
:
'
ember
-
metal
.
run
.
sync
'
until
:
'
3
.
5
.
0
'
}
)
;
return
backburner
1
.
scheduleOnce
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
next
=
function
(
)
{
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
)
_key4
=
0
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
]
=
arguments
[
_key4
]
;
}
args
.
push
(
1
)
;
return
backburner
1
.
later
.
apply
(
backburner
1
args
)
;
}
;
run
.
cancel
=
function
(
timer
)
{
return
backburner
1
.
cancel
(
timer
)
;
}
;
run
.
debounce
=
function
(
)
{
return
backburner
1
.
debounce
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
throttle
=
function
(
)
{
return
backburner
1
.
throttle
.
apply
(
backburner
1
arguments
)
;
}
;
run
.
_addQueue
=
function
(
name
after
)
{
if
(
run
.
queues
.
indexOf
(
name
)
=
=
=
-
1
)
{
run
.
queues
.
splice
(
run
.
queues
.
indexOf
(
after
)
+
1
0
name
)
;
}
}
;
var
Libraries
=
function
(
)
{
function
Libraries
(
)
{
emberBabel
.
classCallCheck
(
this
Libraries
)
;
this
.
_registry
=
[
]
;
this
.
_coreLibIndex
=
0
;
}
Libraries
.
prototype
.
_getLibraryByName
=
function
_getLibraryByName
(
name
)
{
var
libs
=
this
.
_registry
;
var
count
=
libs
.
length
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
libs
[
i
]
.
name
=
=
=
name
)
{
return
libs
[
i
]
;
}
}
}
;
Libraries
.
prototype
.
register
=
function
register
(
name
version
isCoreLibrary
)
{
var
index
=
this
.
_registry
.
length
;
if
(
!
this
.
_getLibraryByName
(
name
)
)
{
if
(
isCoreLibrary
)
{
index
=
this
.
_coreLibIndex
+
+
;
}
this
.
_registry
.
splice
(
index
0
{
name
:
name
version
:
version
}
)
;
}
else
{
true
&
&
emberDebug
.
warn
(
'
Library
"
'
+
name
+
'
"
is
already
registered
with
Ember
.
'
false
{
id
:
'
ember
-
metal
.
libraries
-
register
'
}
)
;
}
}
;
Libraries
.
prototype
.
registerCoreLibrary
=
function
registerCoreLibrary
(
name
version
)
{
this
.
register
(
name
version
true
)
;
}
;
Libraries
.
prototype
.
deRegister
=
function
deRegister
(
name
)
{
var
lib
=
this
.
_getLibraryByName
(
name
)
;
var
index
=
void
0
;
if
(
lib
)
{
index
=
this
.
_registry
.
indexOf
(
lib
)
;
this
.
_registry
.
splice
(
index
1
)
;
}
}
;
return
Libraries
;
}
(
)
;
if
(
features
.
EMBER_LIBRARIES_ISREGISTERED
)
{
Libraries
.
prototype
.
isRegistered
=
function
(
name
)
{
return
!
!
this
.
_getLibraryByName
(
name
)
;
}
;
}
var
libraries
=
new
Libraries
(
)
;
function
copyNull
(
obj
)
{
var
output
=
Object
.
create
(
null
)
;
for
(
var
prop
in
obj
)
{
output
[
prop
]
=
obj
[
prop
]
;
}
return
output
;
}
function
copyMap
(
original
newObject
)
{
var
keys
=
original
.
_keys
.
copy
(
)
;
var
values
=
copyNull
(
original
.
_values
)
;
newObject
.
_keys
=
keys
;
newObject
.
_values
=
values
;
newObject
.
size
=
original
.
size
;
return
newObject
;
}
var
OrderedSet
=
function
(
)
{
function
OrderedSet
(
)
{
emberBabel
.
classCallCheck
(
this
OrderedSet
)
;
this
.
clear
(
)
;
}
OrderedSet
.
create
=
function
create
(
)
{
var
Constructor
=
this
;
return
new
Constructor
(
)
;
}
;
OrderedSet
.
prototype
.
clear
=
function
clear
(
)
{
this
.
presenceSet
=
Object
.
create
(
null
)
;
this
.
list
=
[
]
;
this
.
size
=
0
;
}
;
OrderedSet
.
prototype
.
add
=
function
add
(
obj
_guid
)
{
var
guid
=
_guid
|
|
emberUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
var
list
=
this
.
list
;
if
(
presenceSet
[
guid
]
!
=
=
true
)
{
presenceSet
[
guid
]
=
true
;
this
.
size
=
list
.
push
(
obj
)
;
}
return
this
;
}
;
OrderedSet
.
prototype
.
delete
=
function
_delete
(
obj
_guid
)
{
var
guid
=
_guid
|
|
emberUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
var
list
=
this
.
list
;
if
(
presenceSet
[
guid
]
=
=
=
true
)
{
delete
presenceSet
[
guid
]
;
var
index
=
list
.
indexOf
(
obj
)
;
if
(
index
>
-
1
)
{
list
.
splice
(
index
1
)
;
}
this
.
size
=
list
.
length
;
return
true
;
}
else
{
return
false
;
}
}
;
OrderedSet
.
prototype
.
isEmpty
=
function
isEmpty
(
)
{
return
this
.
size
=
=
=
0
;
}
;
OrderedSet
.
prototype
.
has
=
function
has
(
obj
)
{
if
(
this
.
size
=
=
=
0
)
{
return
false
;
}
var
guid
=
emberUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
return
presenceSet
[
guid
]
=
=
=
true
;
}
;
OrderedSet
.
prototype
.
forEach
=
function
forEach
(
fn
)
{
true
&
&
!
(
typeof
fn
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
Object
.
prototype
.
toString
.
call
(
fn
)
+
'
is
not
a
function
'
typeof
fn
=
=
=
'
function
'
)
;
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
list
=
this
.
list
;
if
(
arguments
.
length
=
=
=
2
)
{
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
fn
.
call
(
arguments
[
1
]
list
[
i
]
)
;
}
}
else
{
for
(
var
_i
=
0
;
_i
<
list
.
length
;
_i
+
+
)
{
fn
(
list
[
_i
]
)
;
}
}
}
;
OrderedSet
.
prototype
.
toArray
=
function
toArray
(
)
{
return
this
.
list
.
slice
(
)
;
}
;
OrderedSet
.
prototype
.
copy
=
function
copy
(
)
{
var
Constructor
=
this
.
constructor
;
var
set
=
new
Constructor
(
)
;
set
.
presenceSet
=
copyNull
(
this
.
presenceSet
)
;
set
.
list
=
this
.
toArray
(
)
;
set
.
size
=
this
.
size
;
return
set
;
}
;
return
OrderedSet
;
}
(
)
;
var
Map
=
function
(
)
{
function
Map
(
)
{
emberBabel
.
classCallCheck
(
this
Map
)
;
this
.
_keys
=
new
OrderedSet
(
)
;
this
.
_values
=
Object
.
create
(
null
)
;
this
.
size
=
0
;
}
Map
.
create
=
function
create
(
)
{
var
Constructor
=
this
;
return
new
Constructor
(
)
;
}
;
Map
.
prototype
.
get
=
function
get
(
key
)
{
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
values
=
this
.
_values
;
var
guid
=
emberUtils
.
guidFor
(
key
)
;
return
values
[
guid
]
;
}
;
Map
.
prototype
.
set
=
function
set
(
key
value
)
{
var
keys
=
this
.
_keys
;
var
values
=
this
.
_values
;
var
guid
=
emberUtils
.
guidFor
(
key
)
;
var
k
=
key
=
=
=
-
0
?
0
:
key
;
keys
.
add
(
k
guid
)
;
values
[
guid
]
=
value
;
this
.
size
=
keys
.
size
;
return
this
;
}
;
Map
.
prototype
.
delete
=
function
_delete
(
key
)
{
if
(
this
.
size
=
=
=
0
)
{
return
false
;
}
var
keys
=
this
.
_keys
;
var
values
=
this
.
_values
;
var
guid
=
emberUtils
.
guidFor
(
key
)
;
if
(
keys
.
delete
(
key
guid
)
)
{
delete
values
[
guid
]
;
this
.
size
=
keys
.
size
;
return
true
;
}
else
{
return
false
;
}
}
;
Map
.
prototype
.
has
=
function
has
(
key
)
{
return
this
.
_keys
.
has
(
key
)
;
}
;
Map
.
prototype
.
forEach
=
function
forEach
(
callback
)
{
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
Object
.
prototype
.
toString
.
call
(
callback
)
+
'
is
not
a
function
'
typeof
callback
=
=
=
'
function
'
)
;
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
map
=
this
;
var
cb
=
void
0
thisArg
=
void
0
;
if
(
arguments
.
length
=
=
=
2
)
{
thisArg
=
arguments
[
1
]
;
cb
=
function
(
key
)
{
return
callback
.
call
(
thisArg
map
.
get
(
key
)
key
map
)
;
}
;
}
else
{
cb
=
function
(
key
)
{
return
callback
(
map
.
get
(
key
)
key
map
)
;
}
;
}
this
.
_keys
.
forEach
(
cb
)
;
}
;
Map
.
prototype
.
clear
=
function
clear
(
)
{
this
.
_keys
.
clear
(
)
;
this
.
_values
=
Object
.
create
(
null
)
;
this
.
size
=
0
;
}
;
Map
.
prototype
.
copy
=
function
copy
(
)
{
return
copyMap
(
this
new
Map
(
)
)
;
}
;
return
Map
;
}
(
)
;
var
MapWithDefault
=
function
(
_Map
)
{
emberBabel
.
inherits
(
MapWithDefault
_Map
)
;
function
MapWithDefault
(
options
)
{
emberBabel
.
classCallCheck
(
this
MapWithDefault
)
;
var
_this
=
emberBabel
.
possibleConstructorReturn
(
this
_Map
.
call
(
this
)
)
;
_this
.
defaultValue
=
options
.
defaultValue
;
return
_this
;
}
MapWithDefault
.
create
=
function
create
(
options
)
{
if
(
options
)
{
return
new
MapWithDefault
(
options
)
;
}
else
{
return
new
Map
(
)
;
}
}
;
MapWithDefault
.
prototype
.
get
=
function
get
(
key
)
{
var
hasValue
=
this
.
has
(
key
)
;
if
(
hasValue
)
{
return
_Map
.
prototype
.
get
.
call
(
this
key
)
;
}
else
{
var
defaultValue
=
this
.
defaultValue
(
key
)
;
this
.
set
(
key
defaultValue
)
;
return
defaultValue
;
}
}
;
MapWithDefault
.
prototype
.
copy
=
function
copy
(
)
{
var
Constructor
=
this
.
constructor
;
return
copyMap
(
this
new
Constructor
(
{
defaultValue
:
this
.
defaultValue
}
)
)
;
}
;
return
MapWithDefault
;
}
(
Map
)
;
function
getProperties
(
obj
)
{
var
ret
=
{
}
;
var
propertyNames
=
arguments
;
var
i
=
1
;
if
(
arguments
.
length
=
=
=
2
&
&
Array
.
isArray
(
arguments
[
1
]
)
)
{
i
=
0
;
propertyNames
=
arguments
[
1
]
;
}
for
(
;
i
<
propertyNames
.
length
;
i
+
+
)
{
ret
[
propertyNames
[
i
]
]
=
get
(
obj
propertyNames
[
i
]
)
;
}
return
ret
;
}
function
setProperties
(
obj
properties
)
{
if
(
properties
=
=
=
null
|
|
typeof
properties
!
=
=
'
object
'
)
{
return
properties
;
}
changeProperties
(
function
(
)
{
var
props
=
Object
.
keys
(
properties
)
;
var
propertyName
=
void
0
;
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
propertyName
=
props
[
i
]
;
set
(
obj
propertyName
properties
[
propertyName
]
)
;
}
}
)
;
return
properties
;
}
var
a_concat
=
Array
.
prototype
.
concat
;
var
isArray
=
Array
.
isArray
;
function
isMethod
(
obj
)
{
return
'
function
'
=
=
=
typeof
obj
&
&
obj
.
isMethod
!
=
=
false
&
&
obj
!
=
=
Boolean
&
&
obj
!
=
=
Object
&
&
obj
!
=
=
Number
&
&
obj
!
=
=
Array
&
&
obj
!
=
=
Date
&
&
obj
!
=
=
String
;
}
var
CONTINUE
=
{
}
;
function
mixinProperties
(
mixinsMeta
mixin
)
{
var
guid
=
void
0
;
if
(
mixin
instanceof
Mixin
)
{
guid
=
emberUtils
.
guidFor
(
mixin
)
;
if
(
mixinsMeta
.
peekMixins
(
guid
)
)
{
return
CONTINUE
;
}
mixinsMeta
.
writeMixins
(
guid
mixin
)
;
return
mixin
.
properties
;
}
else
{
return
mixin
;
}
}
function
concatenatedMixinProperties
(
concatProp
props
values
base
)
{
var
concats
=
values
[
concatProp
]
|
|
base
[
concatProp
]
;
if
(
props
[
concatProp
]
)
{
concats
=
concats
?
a_concat
.
call
(
concats
props
[
concatProp
]
)
:
props
[
concatProp
]
;
}
return
concats
;
}
function
giveDescriptorSuper
(
meta
1
key
property
values
descs
base
)
{
var
superProperty
=
void
0
;
if
(
values
[
key
]
=
=
=
undefined
)
{
superProperty
=
descs
[
key
]
;
}
if
(
!
superProperty
)
{
superProperty
=
descriptorFor
(
base
key
meta
1
)
;
}
if
(
superProperty
=
=
=
undefined
|
|
!
(
superProperty
instanceof
ComputedProperty
)
)
{
return
property
;
}
property
=
Object
.
create
(
property
)
;
property
.
_getter
=
emberUtils
.
wrap
(
property
.
_getter
superProperty
.
_getter
)
;
if
(
superProperty
.
_setter
)
{
if
(
property
.
_setter
)
{
property
.
_setter
=
emberUtils
.
wrap
(
property
.
_setter
superProperty
.
_setter
)
;
}
else
{
property
.
_setter
=
superProperty
.
_setter
;
}
}
return
property
;
}
function
giveMethodSuper
(
obj
key
method
values
descs
)
{
if
(
descs
[
key
]
!
=
=
undefined
)
{
return
method
;
}
var
superMethod
=
values
[
key
]
;
if
(
superMethod
=
=
=
undefined
&
&
(
!
features
.
EMBER_METAL_ES5_GETTERS
|
|
descriptorFor
(
obj
key
)
=
=
=
undefined
)
)
{
superMethod
=
obj
[
key
]
;
}
if
(
typeof
superMethod
=
=
=
'
function
'
)
{
return
emberUtils
.
wrap
(
method
superMethod
)
;
}
return
method
;
}
function
applyConcatenatedProperties
(
obj
key
value
values
)
{
var
baseValue
=
values
[
key
]
|
|
obj
[
key
]
;
var
ret
=
void
0
;
if
(
baseValue
=
=
=
null
|
|
baseValue
=
=
=
undefined
)
{
ret
=
emberUtils
.
makeArray
(
value
)
;
}
else
if
(
isArray
(
baseValue
)
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
ret
=
baseValue
;
}
else
{
ret
=
a_concat
.
call
(
baseValue
value
)
;
}
}
else
{
ret
=
a_concat
.
call
(
emberUtils
.
makeArray
(
baseValue
)
value
)
;
}
{
if
(
typeof
ret
=
=
=
'
object
'
&
&
ret
!
=
=
null
)
{
Object
.
freeze
(
ret
)
;
}
}
return
ret
;
}
function
applyMergedProperties
(
obj
key
value
values
)
{
var
baseValue
=
values
[
key
]
|
|
obj
[
key
]
;
true
&
&
!
!
isArray
(
value
)
&
&
emberDebug
.
assert
(
'
You
passed
in
'
+
JSON
.
stringify
(
value
)
+
'
as
the
value
for
'
+
key
+
'
but
'
+
key
+
'
cannot
be
an
Array
'
!
isArray
(
value
)
)
;
if
(
!
baseValue
)
{
return
value
;
}
var
newBase
=
emberUtils
.
assign
(
{
}
baseValue
)
;
var
hasFunction
=
false
;
for
(
var
prop
in
value
)
{
if
(
!
value
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
var
propValue
=
value
[
prop
]
;
if
(
isMethod
(
propValue
)
)
{
hasFunction
=
true
;
newBase
[
prop
]
=
giveMethodSuper
(
obj
prop
propValue
baseValue
{
}
)
;
}
else
{
newBase
[
prop
]
=
propValue
;
}
}
if
(
hasFunction
)
{
newBase
.
_super
=
emberUtils
.
ROOT
;
}
return
newBase
;
}
function
addNormalizedProperty
(
base
key
value
meta
1
descs
values
concats
mergings
)
{
if
(
value
instanceof
Descriptor
)
{
if
(
emberEnvironment
.
ENV
.
_ENABLE_PROPERTY_REQUIRED_SUPPORT
&
&
value
=
=
=
REQUIRED
&
&
descs
[
key
]
)
{
return
CONTINUE
;
}
if
(
value
.
_getter
)
{
value
=
giveDescriptorSuper
(
meta
1
key
value
values
descs
base
)
;
}
descs
[
key
]
=
value
;
values
[
key
]
=
undefined
;
}
else
{
if
(
concats
&
&
concats
.
indexOf
(
key
)
>
=
0
|
|
key
=
=
=
'
concatenatedProperties
'
|
|
key
=
=
=
'
mergedProperties
'
)
{
value
=
applyConcatenatedProperties
(
base
key
value
values
)
;
}
else
if
(
mergings
&
&
mergings
.
indexOf
(
key
)
>
-
1
)
{
value
=
applyMergedProperties
(
base
key
value
values
)
;
}
else
if
(
isMethod
(
value
)
)
{
value
=
giveMethodSuper
(
base
key
value
values
descs
)
;
}
descs
[
key
]
=
undefined
;
values
[
key
]
=
value
;
}
}
function
mergeMixins
(
mixins
meta
1
descs
values
base
keys
)
{
var
currentMixin
=
void
0
props
=
void
0
key
=
void
0
concats
=
void
0
mergings
=
void
0
;
function
removeKeys
(
keyName
)
{
delete
descs
[
keyName
]
;
delete
values
[
keyName
]
;
}
for
(
var
i
=
0
;
i
<
mixins
.
length
;
i
+
+
)
{
currentMixin
=
mixins
[
i
]
;
true
&
&
!
(
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
&
&
emberDebug
.
assert
(
'
Expected
hash
or
Mixin
instance
got
'
+
Object
.
prototype
.
toString
.
call
(
currentMixin
)
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
;
props
=
mixinProperties
(
meta
1
currentMixin
)
;
if
(
props
=
=
=
CONTINUE
)
{
continue
;
}
if
(
props
)
{
if
(
base
.
willMergeMixin
)
{
base
.
willMergeMixin
(
props
)
;
}
concats
=
concatenatedMixinProperties
(
'
concatenatedProperties
'
props
values
base
)
;
mergings
=
concatenatedMixinProperties
(
'
mergedProperties
'
props
values
base
)
;
for
(
key
in
props
)
{
if
(
!
props
.
hasOwnProperty
(
key
)
)
{
continue
;
}
keys
.
push
(
key
)
;
addNormalizedProperty
(
base
key
props
[
key
]
meta
1
descs
values
concats
mergings
)
;
}
if
(
props
.
hasOwnProperty
(
'
toString
'
)
)
{
base
.
toString
=
props
.
toString
;
}
}
else
if
(
currentMixin
.
mixins
)
{
mergeMixins
(
currentMixin
.
mixins
meta
1
descs
values
base
keys
)
;
if
(
currentMixin
.
_without
)
{
currentMixin
.
_without
.
forEach
(
removeKeys
)
;
}
}
}
}
function
followAlias
(
obj
desc
descs
values
)
{
var
altKey
=
desc
.
methodName
;
var
value
=
void
0
;
var
possibleDesc
=
void
0
;
if
(
descs
[
altKey
]
|
|
values
[
altKey
]
)
{
value
=
values
[
altKey
]
;
desc
=
descs
[
altKey
]
;
}
else
if
(
(
possibleDesc
=
descriptorFor
(
obj
altKey
)
)
!
=
=
undefined
)
{
desc
=
possibleDesc
;
value
=
undefined
;
}
else
{
desc
=
undefined
;
value
=
obj
[
altKey
]
;
}
return
{
desc
:
desc
value
:
value
}
;
}
function
updateObserversAndListeners
(
obj
key
paths
updateMethod
)
{
if
(
paths
)
{
for
(
var
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
updateMethod
(
obj
paths
[
i
]
null
key
)
;
}
}
}
function
replaceObserversAndListeners
(
obj
key
prev
next
)
{
if
(
typeof
prev
=
=
=
'
function
'
)
{
updateObserversAndListeners
(
obj
key
prev
.
__ember_observesBefore__
_removeBeforeObserver
)
;
updateObserversAndListeners
(
obj
key
prev
.
__ember_observes__
removeObserver
)
;
updateObserversAndListeners
(
obj
key
prev
.
__ember_listens__
removeListener
)
;
}
if
(
typeof
next
=
=
=
'
function
'
)
{
updateObserversAndListeners
(
obj
key
next
.
__ember_observesBefore__
_addBeforeObserver
)
;
updateObserversAndListeners
(
obj
key
next
.
__ember_observes__
addObserver
)
;
updateObserversAndListeners
(
obj
key
next
.
__ember_listens__
addListener
)
;
}
}
function
applyMixin
(
obj
mixins
partial
)
{
var
descs
=
{
}
;
var
values
=
{
}
;
var
meta
1
=
meta
(
obj
)
;
var
keys
=
[
]
;
var
key
=
void
0
value
=
void
0
desc
=
void
0
;
obj
.
_super
=
emberUtils
.
ROOT
;
mergeMixins
(
mixins
meta
1
descs
values
obj
keys
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
key
=
keys
[
i
]
;
if
(
key
=
=
=
'
constructor
'
|
|
!
values
.
hasOwnProperty
(
key
)
)
{
continue
;
}
desc
=
descs
[
key
]
;
value
=
values
[
key
]
;
if
(
emberEnvironment
.
ENV
.
_ENABLE_PROPERTY_REQUIRED_SUPPORT
&
&
desc
=
=
=
REQUIRED
)
{
continue
;
}
while
(
desc
&
&
desc
instanceof
Alias
)
{
var
followed
=
followAlias
(
obj
desc
descs
values
)
;
desc
=
followed
.
desc
;
value
=
followed
.
value
;
}
if
(
desc
=
=
=
undefined
&
&
value
=
=
=
undefined
)
{
continue
;
}
if
(
features
.
EMBER_METAL_ES5_GETTERS
&
&
descriptorFor
(
obj
key
)
!
=
=
undefined
)
{
replaceObserversAndListeners
(
obj
key
null
value
)
;
}
else
{
replaceObserversAndListeners
(
obj
key
obj
[
key
]
value
)
;
}
if
(
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
typeof
Mixin
.
detectBinding
=
=
=
'
function
'
&
&
Mixin
.
detectBinding
(
key
)
)
{
meta
1
.
writeBindings
(
key
value
)
;
}
defineProperty
(
obj
key
desc
value
meta
1
)
;
}
if
(
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
!
partial
&
&
typeof
Mixin
.
finishProtype
=
=
=
'
function
'
)
{
Mixin
.
finishPartial
(
obj
meta
1
)
;
}
return
obj
;
}
function
mixin
(
obj
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
applyMixin
(
obj
args
false
)
;
return
obj
;
}
var
Mixin
=
function
(
)
{
function
Mixin
(
mixins
properties
)
{
emberBabel
.
classCallCheck
(
this
Mixin
)
;
this
.
properties
=
properties
;
var
length
=
mixins
&
&
mixins
.
length
;
if
(
length
>
0
)
{
var
m
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
var
x
=
mixins
[
i
]
;
if
(
x
instanceof
Mixin
)
{
m
[
i
]
=
x
;
}
else
{
m
[
i
]
=
new
Mixin
(
undefined
x
)
;
}
}
this
.
mixins
=
m
;
}
else
{
this
.
mixins
=
undefined
;
}
this
.
ownerConstructor
=
undefined
;
this
.
_without
=
undefined
;
this
[
emberUtils
.
GUID_KEY
]
=
null
;
this
[
emberUtils
.
NAME_KEY
]
=
null
;
emberDebug
.
debugSeal
(
this
)
;
}
Mixin
.
applyPartial
=
function
applyPartial
(
obj
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
>
1
?
_len2
-
1
:
0
)
_key2
=
1
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
1
]
=
arguments
[
_key2
]
;
}
return
applyMixin
(
obj
args
true
)
;
}
;
Mixin
.
create
=
function
create
(
)
{
unprocessedFlag
=
true
;
var
M
=
this
;
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
return
new
M
(
args
undefined
)
;
}
;
Mixin
.
mixins
=
function
mixins
(
obj
)
{
var
meta
1
=
peekMeta
(
obj
)
;
var
ret
=
[
]
;
if
(
meta
1
=
=
=
undefined
)
{
return
ret
;
}
meta
1
.
forEachMixins
(
function
(
key
currentMixin
)
{
if
(
!
currentMixin
.
properties
)
{
ret
.
push
(
currentMixin
)
;
}
}
)
;
return
ret
;
}
;
Mixin
.
prototype
.
reopen
=
function
reopen
(
)
{
var
currentMixin
=
void
0
;
if
(
this
.
properties
)
{
currentMixin
=
new
Mixin
(
undefined
this
.
properties
)
;
this
.
properties
=
undefined
;
this
.
mixins
=
[
currentMixin
]
;
}
else
if
(
!
this
.
mixins
)
{
this
.
mixins
=
[
]
;
}
var
mixins
=
this
.
mixins
;
var
idx
=
void
0
;
for
(
idx
=
0
;
idx
<
arguments
.
length
;
idx
+
+
)
{
currentMixin
=
arguments
[
idx
]
;
true
&
&
!
(
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
&
&
emberDebug
.
assert
(
'
Expected
hash
or
Mixin
instance
got
'
+
Object
.
prototype
.
toString
.
call
(
currentMixin
)
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
;
if
(
currentMixin
instanceof
Mixin
)
{
mixins
.
push
(
currentMixin
)
;
}
else
{
mixins
.
push
(
new
Mixin
(
undefined
currentMixin
)
)
;
}
}
return
this
;
}
;
Mixin
.
prototype
.
apply
=
function
apply
(
obj
)
{
return
applyMixin
(
obj
[
this
]
false
)
;
}
;
Mixin
.
prototype
.
applyPartial
=
function
applyPartial
(
obj
)
{
return
applyMixin
(
obj
[
this
]
true
)
;
}
;
Mixin
.
prototype
.
detect
=
function
detect
(
obj
)
{
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
false
;
}
if
(
obj
instanceof
Mixin
)
{
return
_detect
(
obj
this
{
}
)
;
}
var
meta
1
=
peekMeta
(
obj
)
;
if
(
meta
1
=
=
=
undefined
)
{
return
false
;
}
return
!
!
meta
1
.
peekMixins
(
emberUtils
.
guidFor
(
this
)
)
;
}
;
Mixin
.
prototype
.
without
=
function
without
(
)
{
var
ret
=
new
Mixin
(
[
this
]
)
;
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
)
_key4
=
0
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
]
=
arguments
[
_key4
]
;
}
ret
.
_without
=
args
;
return
ret
;
}
;
Mixin
.
prototype
.
keys
=
function
keys
(
)
{
var
keys
=
{
}
;
var
seen
=
{
}
;
_keys
(
keys
this
seen
)
;
var
ret
=
Object
.
keys
(
keys
)
;
return
ret
;
}
;
return
Mixin
;
}
(
)
;
Mixin
.
_apply
=
applyMixin
;
if
(
emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
{
Mixin
.
finishPartial
=
null
;
Mixin
.
detectBinding
=
null
;
}
var
MixinPrototype
=
Mixin
.
prototype
;
MixinPrototype
.
toString
=
Object
.
toString
;
emberDebug
.
debugSeal
(
MixinPrototype
)
;
var
unprocessedFlag
=
false
;
function
hasUnprocessedMixins
(
)
{
return
unprocessedFlag
;
}
function
clearUnprocessedMixins
(
)
{
unprocessedFlag
=
false
;
}
function
_detect
(
curMixin
targetMixin
seen
)
{
var
guid
=
emberUtils
.
guidFor
(
curMixin
)
;
if
(
seen
[
guid
]
)
{
return
false
;
}
seen
[
guid
]
=
true
;
if
(
curMixin
=
=
=
targetMixin
)
{
return
true
;
}
var
mixins
=
curMixin
.
mixins
;
var
loc
=
mixins
?
mixins
.
length
:
0
;
while
(
-
-
loc
>
=
0
)
{
if
(
_detect
(
mixins
[
loc
]
targetMixin
seen
)
)
{
return
true
;
}
}
return
false
;
}
function
_keys
(
ret
mixin
seen
)
{
if
(
seen
[
emberUtils
.
guidFor
(
mixin
)
]
)
{
return
;
}
seen
[
emberUtils
.
guidFor
(
mixin
)
]
=
true
;
if
(
mixin
.
properties
)
{
var
props
=
Object
.
keys
(
mixin
.
properties
)
;
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
key
=
props
[
i
]
;
ret
[
key
]
=
true
;
}
}
else
if
(
mixin
.
mixins
)
{
mixin
.
mixins
.
forEach
(
function
(
x
)
{
return
_keys
(
ret
x
seen
)
;
}
)
;
}
}
var
REQUIRED
=
new
Descriptor
(
)
;
REQUIRED
.
toString
=
function
(
)
{
return
'
(
Required
Property
)
'
;
}
;
function
required
(
)
{
true
&
&
!
false
&
&
emberDebug
.
deprecate
(
'
Ember
.
required
is
deprecated
as
its
behavior
is
inconsistent
and
unreliable
.
'
false
{
id
:
'
ember
-
metal
.
required
'
until
:
'
3
.
0
.
0
'
}
)
;
return
REQUIRED
;
}
function
Alias
(
methodName
)
{
this
.
isDescriptor
=
true
;
this
.
methodName
=
methodName
;
}
Alias
.
prototype
=
new
Descriptor
(
)
;
function
aliasMethod
(
methodName
)
{
return
new
Alias
(
methodName
)
;
}
function
observer
(
)
{
for
(
var
_len5
=
arguments
.
length
args
=
Array
(
_len5
)
_key5
=
0
;
_key5
<
_len5
;
_key5
+
+
)
{
args
[
_key5
]
=
arguments
[
_key5
]
;
}
var
func
=
args
.
pop
(
)
;
var
_paths
=
args
;
true
&
&
!
(
typeof
func
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
observer
called
without
a
function
'
typeof
func
=
=
=
'
function
'
)
;
true
&
&
!
(
_paths
.
length
>
0
&
&
_paths
.
every
(
function
(
p
)
{
return
typeof
p
=
=
=
'
string
'
&
&
p
.
length
;
}
)
)
&
&
emberDebug
.
assert
(
'
observer
called
without
valid
path
'
_paths
.
length
>
0
&
&
_paths
.
every
(
function
(
p
)
{
return
typeof
p
=
=
=
'
string
'
&
&
p
.
length
;
}
)
)
;
var
paths
=
[
]
;
var
addWatchedProperty
=
function
(
path
)
{
return
paths
.
push
(
path
)
;
}
;
for
(
var
i
=
0
;
i
<
_paths
.
length
;
+
+
i
)
{
expandProperties
(
_paths
[
i
]
addWatchedProperty
)
;
}
func
.
__ember_observes__
=
paths
;
return
func
;
}
function
_beforeObserver
(
)
{
for
(
var
_len6
=
arguments
.
length
args
=
Array
(
_len6
)
_key6
=
0
;
_key6
<
_len6
;
_key6
+
+
)
{
args
[
_key6
]
=
arguments
[
_key6
]
;
}
var
func
=
args
.
pop
(
)
;
var
_paths
=
args
;
true
&
&
!
(
typeof
func
=
=
=
'
function
'
)
&
&
emberDebug
.
assert
(
'
_beforeObserver
called
without
a
function
'
typeof
func
=
=
=
'
function
'
)
;
var
paths
=
[
]
;
var
addWatchedProperty
=
function
(
path
)
{
paths
.
push
(
path
)
;
}
;
for
(
var
i
=
0
;
i
<
_paths
.
length
;
+
+
i
)
{
expandProperties
(
_paths
[
i
]
addWatchedProperty
)
;
}
func
.
__ember_observesBefore__
=
paths
;
return
func
;
}
function
InjectedProperty
(
type
name
)
{
this
.
type
=
type
;
this
.
name
=
name
;
this
.
_super
Constructor
(
injectedPropertyGet
)
;
AliasedPropertyPrototype
.
oneWay
.
call
(
this
)
;
}
function
injectedPropertyGet
(
keyName
)
{
var
desc
=
descriptorFor
(
this
keyName
)
;
var
owner
=
emberUtils
.
getOwner
(
this
)
|
|
this
.
container
;
true
&
&
!
(
desc
&
&
desc
.
type
)
&
&
emberDebug
.
assert
(
'
InjectedProperties
should
be
defined
with
the
inject
computed
property
macros
.
'
desc
&
&
desc
.
type
)
;
true
&
&
!
owner
&
&
emberDebug
.
assert
(
'
Attempting
to
lookup
an
injected
property
on
an
object
without
a
container
ensure
that
the
object
was
instantiated
via
a
container
.
'
owner
)
;
return
owner
.
lookup
(
desc
.
type
+
'
:
'
+
(
desc
.
name
|
|
keyName
)
)
;
}
InjectedProperty
.
prototype
=
Object
.
create
(
Descriptor
.
prototype
)
;
var
InjectedPropertyPrototype
=
InjectedProperty
.
prototype
;
var
ComputedPropertyPrototype
1
=
ComputedProperty
.
prototype
;
var
AliasedPropertyPrototype
=
AliasedProperty
.
prototype
;
InjectedPropertyPrototype
.
_super
Constructor
=
ComputedProperty
;
InjectedPropertyPrototype
.
get
=
ComputedPropertyPrototype
1
.
get
;
InjectedPropertyPrototype
.
readOnly
=
ComputedPropertyPrototype
1
.
readOnly
;
InjectedPropertyPrototype
.
teardown
=
ComputedPropertyPrototype
1
.
teardown
;
var
splice
=
Array
.
prototype
.
splice
;
function
replace
(
array
idx
amt
objects
)
{
var
args
=
[
]
.
concat
(
objects
)
;
var
ret
=
[
]
;
var
size
=
60000
;
var
start
=
idx
;
var
ends
=
amt
;
var
count
=
void
0
chunk
=
void
0
;
while
(
args
.
length
)
{
count
=
ends
>
size
?
size
:
ends
;
if
(
count
<
=
0
)
{
count
=
0
;
}
chunk
=
args
.
splice
(
0
size
)
;
chunk
=
[
start
count
]
.
concat
(
chunk
)
;
start
+
=
size
;
ends
-
=
count
;
ret
=
ret
.
concat
(
splice
.
apply
(
array
chunk
)
)
;
}
return
ret
;
}
function
isProxy
(
value
)
{
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
)
{
var
meta
1
=
peekMeta
(
value
)
;
return
meta
1
=
=
=
undefined
?
false
:
meta
1
.
isProxy
(
)
;
}
return
false
;
}
function
descriptor
(
desc
)
{
return
new
Descriptor
1
(
desc
)
;
}
var
Descriptor
1
=
function
(
_EmberDescriptor
)
{
emberBabel
.
inherits
(
Descriptor
1
_EmberDescriptor
)
;
function
Descriptor
1
(
desc
)
{
emberBabel
.
classCallCheck
(
this
Descriptor
1
)
;
var
_this
=
emberBabel
.
possibleConstructorReturn
(
this
_EmberDescriptor
.
call
(
this
)
)
;
_this
.
desc
=
desc
;
return
_this
;
}
Descriptor
1
.
prototype
.
setup
=
function
setup
(
obj
key
)
{
Object
.
defineProperty
(
obj
key
this
.
desc
)
;
}
;
Descriptor
1
.
prototype
.
get
=
function
get
(
obj
key
)
{
return
obj
[
key
]
;
}
;
Descriptor
1
.
prototype
.
set
=
function
set
(
obj
key
value
)
{
return
obj
[
key
]
=
value
;
}
;
Descriptor
1
.
prototype
.
teardown
=
function
teardown
(
)
{
}
;
return
Descriptor
1
;
}
(
Descriptor
)
;
exports
[
'
default
'
]
=
Ember
;
exports
.
computed
=
computed
;
exports
.
cacheFor
=
cacheFor
;
exports
.
ComputedProperty
=
ComputedProperty
;
exports
.
alias
=
alias
;
exports
.
merge
=
merge
;
exports
.
deprecateProperty
=
deprecateProperty
;
exports
.
instrument
=
instrument
;
exports
.
_instrumentStart
=
_instrumentStart
;
exports
.
instrumentationReset
=
reset
;
exports
.
instrumentationSubscribe
=
subscribe
;
exports
.
instrumentationUnsubscribe
=
unsubscribe
;
exports
.
getOnerror
=
getOnerror
;
exports
.
setOnerror
=
setOnerror
;
exports
.
setDispatchOverride
=
setDispatchOverride
;
exports
.
getDispatchOverride
=
getDispatchOverride
;
exports
.
descriptorFor
=
descriptorFor
;
exports
.
meta
=
meta
;
exports
.
peekMeta
=
peekMeta
;
exports
.
deleteMeta
=
deleteMeta
;
exports
.
Cache
=
Cache
;
exports
.
_getPath
=
_getPath
;
exports
.
get
=
get
;
exports
.
getWithDefault
=
getWithDefault
;
exports
.
set
=
set
;
exports
.
trySet
=
trySet
;
exports
.
addListener
=
addListener
;
exports
.
hasListeners
=
hasListeners
;
exports
.
on
=
on
;
exports
.
removeListener
=
removeListener
;
exports
.
sendEvent
=
sendEvent
;
exports
.
isNone
=
isNone
;
exports
.
isEmpty
=
isEmpty
;
exports
.
isBlank
=
isBlank
;
exports
.
isPresent
=
isPresent
;
exports
.
run
=
run
;
exports
.
ObserverSet
=
ObserverSet
;
exports
.
beginPropertyChanges
=
beginPropertyChanges
;
exports
.
changeProperties
=
changeProperties
;
exports
.
endPropertyChanges
=
endPropertyChanges
;
exports
.
overrideChains
=
overrideChains
;
exports
.
propertyDidChange
=
propertyDidChange
;
exports
.
propertyWillChange
=
propertyWillChange
;
exports
.
PROPERTY_DID_CHANGE
=
PROPERTY_DID_CHANGE
;
exports
.
defineProperty
=
defineProperty
;
exports
.
Descriptor
=
Descriptor
;
exports
.
_hasCachedComputedProperties
=
_hasCachedComputedProperties
;
exports
.
watchKey
=
watchKey
;
exports
.
unwatchKey
=
unwatchKey
;
exports
.
ChainNode
=
ChainNode
;
exports
.
finishChains
=
finishChains
;
exports
.
removeChainWatcher
=
removeChainWatcher
;
exports
.
watchPath
=
watchPath
;
exports
.
unwatchPath
=
unwatchPath
;
exports
.
isWatching
=
isWatching
;
exports
.
unwatch
=
unwatch
;
exports
.
watch
=
watch
;
exports
.
watcherCount
=
watcherCount
;
exports
.
libraries
=
libraries
;
exports
.
Libraries
=
Libraries
;
exports
.
Map
=
Map
;
exports
.
MapWithDefault
=
MapWithDefault
;
exports
.
OrderedSet
=
OrderedSet
;
exports
.
getProperties
=
getProperties
;
exports
.
setProperties
=
setProperties
;
exports
.
expandProperties
=
expandProperties
;
exports
.
addObserver
=
addObserver
;
exports
.
removeObserver
=
removeObserver
;
exports
.
_addBeforeObserver
=
_addBeforeObserver
;
exports
.
_removeBeforeObserver
=
_removeBeforeObserver
;
exports
.
Mixin
=
Mixin
;
exports
.
aliasMethod
=
aliasMethod
;
exports
.
_beforeObserver
=
_beforeObserver
;
exports
.
mixin
=
mixin
;
exports
.
observer
=
observer
;
exports
.
required
=
required
;
exports
.
REQUIRED
=
REQUIRED
;
exports
.
hasUnprocessedMixins
=
hasUnprocessedMixins
;
exports
.
clearUnprocessedMixins
=
clearUnprocessedMixins
;
exports
.
InjectedProperty
=
InjectedProperty
;
exports
.
setHasViews
=
setHasViews
;
exports
.
tagForProperty
=
tagForProperty
;
exports
.
tagFor
=
tagFor
;
exports
.
markObjectAsDirty
=
markObjectAsDirty
;
exports
.
replace
=
replace
;
exports
.
isProxy
=
isProxy
;
exports
.
descriptor
=
descriptor
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
ext
/
controller
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
routing
/
utils
'
]
function
(
exports
_emberMetal
_emberRuntime
_utils
)
{
'
use
strict
'
;
_emberRuntime
.
ControllerMixin
.
reopen
(
{
concatenatedProperties
:
[
'
queryParams
'
]
queryParams
:
null
_qpDelegate
:
null
_qpChanged
:
function
(
controller
_prop
)
{
var
prop
=
_prop
.
substr
(
0
_prop
.
length
-
3
)
;
var
delegate
=
controller
.
_qpDelegate
;
var
value
=
(
0
_emberMetal
.
get
)
(
controller
prop
)
;
delegate
(
prop
value
)
;
}
transitionToRoute
:
function
(
)
{
var
target
=
(
0
_emberMetal
.
get
)
(
this
'
target
'
)
;
var
method
=
target
.
transitionToRoute
|
|
target
.
transitionTo
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
method
.
apply
(
target
(
0
_utils
.
prefixRouteNameArg
)
(
this
args
)
)
;
}
replaceRoute
:
function
(
)
{
var
target
=
(
0
_emberMetal
.
get
)
(
this
'
target
'
)
;
var
method
=
target
.
replaceRoute
|
|
target
.
replaceWith
;
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
method
.
apply
(
target
(
0
_utils
.
prefixRouteNameArg
)
(
this
args
)
)
;
}
}
)
;
exports
.
default
=
_emberRuntime
.
ControllerMixin
;
}
)
;
enifed
(
'
ember
-
routing
/
ext
/
run_loop
'
[
'
ember
-
metal
'
]
function
(
_emberMetal
)
{
'
use
strict
'
;
_emberMetal
.
run
.
_addQueue
(
'
routerTransitions
'
'
actions
'
)
;
}
)
;
enifed
(
'
ember
-
routing
/
index
'
[
'
exports
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
routing
/
location
/
none_location
'
'
ember
-
routing
/
location
/
hash_location
'
'
ember
-
routing
/
location
/
history_location
'
'
ember
-
routing
/
location
/
auto_location
'
'
ember
-
routing
/
system
/
generate_controller
'
'
ember
-
routing
/
system
/
controller_for
'
'
ember
-
routing
/
system
/
dsl
'
'
ember
-
routing
/
system
/
router
'
'
ember
-
routing
/
system
/
route
'
'
ember
-
routing
/
system
/
query_params
'
'
ember
-
routing
/
services
/
routing
'
'
ember
-
routing
/
services
/
router
'
'
ember
-
routing
/
system
/
cache
'
'
ember
-
routing
/
ext
/
run_loop
'
'
ember
-
routing
/
ext
/
controller
'
]
function
(
exports
_api
_none_location
_hash_location
_history_location
_auto_location
_generate_controller
_controller_for
_dsl
_router
_route
_query_params
_routing
_router2
_cache
)
{
'
use
strict
'
;
exports
.
BucketCache
=
exports
.
RouterService
=
exports
.
RoutingService
=
exports
.
QueryParams
=
exports
.
Route
=
exports
.
Router
=
exports
.
RouterDSL
=
exports
.
controllerFor
=
exports
.
generateControllerFactory
=
exports
.
generateController
=
exports
.
AutoLocation
=
exports
.
HistoryLocation
=
exports
.
HashLocation
=
exports
.
NoneLocation
=
exports
.
Location
=
undefined
;
Object
.
defineProperty
(
exports
'
Location
'
{
enumerable
:
true
get
:
function
(
)
{
return
_api
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
NoneLocation
'
{
enumerable
:
true
get
:
function
(
)
{
return
_none_location
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
HashLocation
'
{
enumerable
:
true
get
:
function
(
)
{
return
_hash_location
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
HistoryLocation
'
{
enumerable
:
true
get
:
function
(
)
{
return
_history_location
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
AutoLocation
'
{
enumerable
:
true
get
:
function
(
)
{
return
_auto_location
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
generateController
'
{
enumerable
:
true
get
:
function
(
)
{
return
_generate_controller
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
generateControllerFactory
'
{
enumerable
:
true
get
:
function
(
)
{
return
_generate_controller
.
generateControllerFactory
;
}
}
)
;
Object
.
defineProperty
(
exports
'
controllerFor
'
{
enumerable
:
true
get
:
function
(
)
{
return
_controller_for
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RouterDSL
'
{
enumerable
:
true
get
:
function
(
)
{
return
_dsl
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Router
'
{
enumerable
:
true
get
:
function
(
)
{
return
_router
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Route
'
{
enumerable
:
true
get
:
function
(
)
{
return
_route
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
QueryParams
'
{
enumerable
:
true
get
:
function
(
)
{
return
_query_params
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RoutingService
'
{
enumerable
:
true
get
:
function
(
)
{
return
_routing
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RouterService
'
{
enumerable
:
true
get
:
function
(
)
{
return
_router2
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
BucketCache
'
{
enumerable
:
true
get
:
function
(
)
{
return
_cache
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
api
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
environment
'
'
ember
-
routing
/
location
/
util
'
]
function
(
exports
_emberDebug
_emberEnvironment
_util
)
{
'
use
strict
'
;
exports
.
default
=
{
create
:
function
(
options
)
{
var
implementation
=
options
&
&
options
.
implementation
;
(
true
&
&
!
(
!
!
implementation
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Location
.
create
:
you
must
specify
a
\
'
implementation
\
'
option
'
!
!
implementation
)
)
;
var
implementationClass
=
this
.
implementations
[
implementation
]
;
(
true
&
&
!
(
!
!
implementationClass
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Location
.
create
:
'
+
implementation
+
'
is
not
a
valid
implementation
'
!
!
implementationClass
)
)
;
return
implementationClass
.
create
.
apply
(
implementationClass
arguments
)
;
}
implementations
:
{
}
_location
:
_emberEnvironment
.
environment
.
location
_getHash
:
function
(
)
{
return
(
0
_util
.
getHash
)
(
this
.
location
)
;
}
}
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
auto_location
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
'
'
ember
-
environment
'
'
ember
-
routing
/
location
/
util
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_emberRuntime
_emberEnvironment
_util
)
{
'
use
strict
'
;
exports
.
getHistoryPath
=
getHistoryPath
;
exports
.
getHashPath
=
getHashPath
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
location
:
_emberEnvironment
.
environment
.
location
history
:
_emberEnvironment
.
environment
.
history
global
:
_emberEnvironment
.
environment
.
window
userAgent
:
_emberEnvironment
.
environment
.
userAgent
cancelRouterSetup
:
false
rootURL
:
'
/
'
detect
:
function
(
)
{
var
rootURL
=
this
.
rootURL
;
(
true
&
&
!
(
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
rootURL
must
end
with
a
trailing
forward
slash
e
.
g
.
"
/
app
/
"
'
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
)
;
var
implementation
=
detectImplementation
(
{
location
:
this
.
location
history
:
this
.
history
userAgent
:
this
.
userAgent
rootURL
:
rootURL
documentMode
:
this
.
documentMode
global
:
this
.
global
}
)
;
if
(
implementation
=
=
=
false
)
{
(
0
_emberMetal
.
set
)
(
this
'
cancelRouterSetup
'
true
)
;
implementation
=
'
none
'
;
}
var
concrete
=
(
0
_emberUtils
.
getOwner
)
(
this
)
.
lookup
(
'
location
:
'
+
implementation
)
;
(
0
_emberMetal
.
set
)
(
concrete
'
rootURL
'
rootURL
)
;
(
true
&
&
!
(
!
!
concrete
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Could
not
find
location
\
'
'
+
implementation
+
'
\
'
.
'
!
!
concrete
)
)
;
(
0
_emberMetal
.
set
)
(
this
'
concreteImplementation
'
concrete
)
;
}
initState
:
delegateToConcreteImplementation
(
'
initState
'
)
getURL
:
delegateToConcreteImplementation
(
'
getURL
'
)
setURL
:
delegateToConcreteImplementation
(
'
setURL
'
)
replaceURL
:
delegateToConcreteImplementation
(
'
replaceURL
'
)
onUpdateURL
:
delegateToConcreteImplementation
(
'
onUpdateURL
'
)
formatURL
:
delegateToConcreteImplementation
(
'
formatURL
'
)
willDestroy
:
function
(
)
{
var
concreteImplementation
=
(
0
_emberMetal
.
get
)
(
this
'
concreteImplementation
'
)
;
if
(
concreteImplementation
)
{
concreteImplementation
.
destroy
(
)
;
}
}
}
)
;
function
delegateToConcreteImplementation
(
methodName
)
{
return
function
(
)
{
var
concreteImplementation
=
(
0
_emberMetal
.
get
)
(
this
'
concreteImplementation
'
)
;
(
true
&
&
!
(
!
!
concreteImplementation
)
&
&
(
0
_emberDebug
.
assert
)
(
'
AutoLocation
\
'
s
detect
(
)
method
should
be
called
before
calling
any
other
hooks
.
'
!
!
concreteImplementation
)
)
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
(
0
_emberUtils
.
tryInvoke
)
(
concreteImplementation
methodName
args
)
;
}
;
}
function
detectImplementation
(
options
)
{
var
location
=
options
.
location
;
var
userAgent
=
options
.
userAgent
;
var
history
=
options
.
history
;
var
documentMode
=
options
.
documentMode
;
var
global
=
options
.
global
;
var
rootURL
=
options
.
rootURL
;
var
implementation
=
'
none
'
;
var
cancelRouterSetup
=
false
;
var
currentPath
=
(
0
_util
.
getFullPath
)
(
location
)
;
if
(
(
0
_util
.
supportsHistory
)
(
userAgent
history
)
)
{
var
historyPath
=
getHistoryPath
(
rootURL
location
)
;
if
(
currentPath
=
=
=
historyPath
)
{
return
'
history
'
;
}
else
{
if
(
currentPath
.
substr
(
0
2
)
=
=
=
'
/
#
'
)
{
history
.
replaceState
(
{
path
:
historyPath
}
null
historyPath
)
;
implementation
=
'
history
'
;
}
else
{
cancelRouterSetup
=
true
;
(
0
_util
.
replacePath
)
(
location
historyPath
)
;
}
}
}
else
if
(
(
0
_util
.
supportsHashChange
)
(
documentMode
global
)
)
{
var
hashPath
=
getHashPath
(
rootURL
location
)
;
if
(
currentPath
=
=
=
hashPath
|
|
currentPath
=
=
=
'
/
'
&
&
hashPath
=
=
=
'
/
#
/
'
)
{
implementation
=
'
hash
'
;
}
else
{
cancelRouterSetup
=
true
;
(
0
_util
.
replacePath
)
(
location
hashPath
)
;
}
}
if
(
cancelRouterSetup
)
{
return
false
;
}
return
implementation
;
}
function
getHistoryPath
(
rootURL
location
)
{
var
path
=
(
0
_util
.
getPath
)
(
location
)
;
var
hash
=
(
0
_util
.
getHash
)
(
location
)
;
var
query
=
(
0
_util
.
getQuery
)
(
location
)
;
var
rootURLIndex
=
path
.
indexOf
(
rootURL
)
;
var
routeHash
=
void
0
hashParts
=
void
0
;
(
true
&
&
!
(
rootURLIndex
=
=
=
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Path
'
+
path
+
'
does
not
start
with
the
provided
rootURL
'
+
rootURL
rootURLIndex
=
=
=
0
)
)
;
if
(
hash
.
substr
(
0
2
)
=
=
=
'
#
/
'
)
{
hashParts
=
hash
.
substr
(
1
)
.
split
(
'
#
'
)
;
routeHash
=
hashParts
.
shift
(
)
;
if
(
path
.
charAt
(
path
.
length
-
1
)
=
=
=
'
/
'
)
{
routeHash
=
routeHash
.
substr
(
1
)
;
}
path
+
=
routeHash
+
query
;
if
(
hashParts
.
length
)
{
path
+
=
'
#
'
+
hashParts
.
join
(
'
#
'
)
;
}
}
else
{
path
+
=
query
+
hash
;
}
return
path
;
}
function
getHashPath
(
rootURL
location
)
{
var
path
=
rootURL
;
var
historyPath
=
getHistoryPath
(
rootURL
location
)
;
var
routePath
=
historyPath
.
substr
(
rootURL
.
length
)
;
if
(
routePath
!
=
=
'
'
)
{
if
(
routePath
[
0
]
!
=
=
'
/
'
)
{
routePath
=
'
/
'
+
routePath
;
}
path
+
=
'
#
'
+
routePath
;
}
return
path
;
}
}
)
;
enifed
(
'
ember
-
routing
/
location
/
hash_location
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
routing
/
location
/
api
'
]
function
(
exports
_emberMetal
_emberRuntime
_api
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
implementation
:
'
hash
'
init
:
function
(
)
{
(
0
_emberMetal
.
set
)
(
this
'
location
'
(
0
_emberMetal
.
get
)
(
this
'
_location
'
)
|
|
window
.
location
)
;
this
.
_hashchangeHandler
=
undefined
;
}
getHash
:
_api
.
default
.
_getHash
getURL
:
function
(
)
{
var
originalPath
=
this
.
getHash
(
)
.
substr
(
1
)
;
var
outPath
=
originalPath
;
if
(
outPath
[
0
]
!
=
=
'
/
'
)
{
outPath
=
'
/
'
;
if
(
originalPath
)
{
outPath
+
=
'
#
'
+
originalPath
;
}
}
return
outPath
;
}
setURL
:
function
(
path
)
{
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
.
hash
=
path
;
(
0
_emberMetal
.
set
)
(
this
'
lastSetURL
'
path
)
;
}
replaceURL
:
function
(
path
)
{
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
.
replace
(
'
#
'
+
path
)
;
(
0
_emberMetal
.
set
)
(
this
'
lastSetURL
'
path
)
;
}
onUpdateURL
:
function
(
callback
)
{
this
.
_removeEventListener
(
)
;
this
.
_hashchangeHandler
=
_emberMetal
.
run
.
bind
(
this
function
(
)
{
var
path
=
this
.
getURL
(
)
;
if
(
(
0
_emberMetal
.
get
)
(
this
'
lastSetURL
'
)
=
=
=
path
)
{
return
;
}
(
0
_emberMetal
.
set
)
(
this
'
lastSetURL
'
null
)
;
callback
(
path
)
;
}
)
;
window
.
addEventListener
(
'
hashchange
'
this
.
_hashchangeHandler
)
;
}
formatURL
:
function
(
url
)
{
return
'
#
'
+
url
;
}
willDestroy
:
function
(
)
{
this
.
_removeEventListener
(
)
;
}
_removeEventListener
:
function
(
)
{
if
(
this
.
_hashchangeHandler
)
{
window
.
removeEventListener
(
'
hashchange
'
this
.
_hashchangeHandler
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
history_location
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
routing
/
location
/
api
'
]
function
(
exports
_emberMetal
_emberRuntime
_api
)
{
'
use
strict
'
;
var
popstateFired
=
false
;
function
_uuid
(
)
{
return
'
xxxxxxxx
-
xxxx
-
4xxx
-
yxxx
-
xxxxxxxxxxxx
'
.
replace
(
/
[
xy
]
/
g
function
(
c
)
{
var
r
v
;
r
=
Math
.
random
(
)
*
16
|
0
;
v
=
c
=
=
=
'
x
'
?
r
:
r
&
3
|
8
;
return
v
.
toString
(
16
)
;
}
)
;
}
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
implementation
:
'
history
'
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
base
=
document
.
querySelector
(
'
base
'
)
;
var
baseURL
=
'
'
;
if
(
base
)
{
baseURL
=
base
.
getAttribute
(
'
href
'
)
;
}
(
0
_emberMetal
.
set
)
(
this
'
baseURL
'
baseURL
)
;
(
0
_emberMetal
.
set
)
(
this
'
location
'
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
|
|
window
.
location
)
;
this
.
_popstateHandler
=
undefined
;
}
initState
:
function
(
)
{
var
history
=
(
0
_emberMetal
.
get
)
(
this
'
history
'
)
|
|
window
.
history
;
(
0
_emberMetal
.
set
)
(
this
'
history
'
history
)
;
if
(
history
&
&
'
state
'
in
history
)
{
this
.
supportsHistory
=
true
;
}
var
state
=
this
.
getState
(
)
;
var
path
=
this
.
formatURL
(
this
.
getURL
(
)
)
;
if
(
state
&
&
state
.
path
=
=
=
path
)
{
this
.
_previousURL
=
this
.
getURL
(
)
;
}
else
{
this
.
replaceState
(
path
)
;
}
}
rootURL
:
'
/
'
getURL
:
function
(
)
{
var
location
=
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
;
var
path
=
location
.
pathname
;
var
rootURL
=
(
0
_emberMetal
.
get
)
(
this
'
rootURL
'
)
;
var
baseURL
=
(
0
_emberMetal
.
get
)
(
this
'
baseURL
'
)
;
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
var
url
=
path
.
replace
(
new
RegExp
(
'
^
'
+
baseURL
+
'
(
?
=
/
|
)
'
)
'
'
)
.
replace
(
new
RegExp
(
'
^
'
+
rootURL
+
'
(
?
=
/
|
)
'
)
'
'
)
.
replace
(
/
\
/
\
/
/
g
'
/
'
)
;
var
search
=
location
.
search
|
|
'
'
;
url
+
=
search
+
this
.
getHash
(
)
;
return
url
;
}
setURL
:
function
(
path
)
{
var
state
=
this
.
getState
(
)
;
path
=
this
.
formatURL
(
path
)
;
if
(
!
state
|
|
state
.
path
!
=
=
path
)
{
this
.
pushState
(
path
)
;
}
}
replaceURL
:
function
(
path
)
{
var
state
=
this
.
getState
(
)
;
path
=
this
.
formatURL
(
path
)
;
if
(
!
state
|
|
state
.
path
!
=
=
path
)
{
this
.
replaceState
(
path
)
;
}
}
getState
:
function
(
)
{
if
(
this
.
supportsHistory
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
history
'
)
.
state
;
}
return
this
.
_historyState
;
}
pushState
:
function
(
path
)
{
var
state
=
{
path
:
path
uuid
:
_uuid
(
)
}
;
(
0
_emberMetal
.
get
)
(
this
'
history
'
)
.
pushState
(
state
null
path
)
;
this
.
_historyState
=
state
;
this
.
_previousURL
=
this
.
getURL
(
)
;
}
replaceState
:
function
(
path
)
{
var
state
=
{
path
:
path
uuid
:
_uuid
(
)
}
;
(
0
_emberMetal
.
get
)
(
this
'
history
'
)
.
replaceState
(
state
null
path
)
;
this
.
_historyState
=
state
;
this
.
_previousURL
=
this
.
getURL
(
)
;
}
onUpdateURL
:
function
(
callback
)
{
var
_this
=
this
;
this
.
_removeEventListener
(
)
;
this
.
_popstateHandler
=
function
(
)
{
if
(
!
popstateFired
)
{
popstateFired
=
true
;
if
(
_this
.
getURL
(
)
=
=
=
_this
.
_previousURL
)
{
return
;
}
}
callback
(
_this
.
getURL
(
)
)
;
}
;
window
.
addEventListener
(
'
popstate
'
this
.
_popstateHandler
)
;
}
formatURL
:
function
(
url
)
{
var
rootURL
=
(
0
_emberMetal
.
get
)
(
this
'
rootURL
'
)
;
var
baseURL
=
(
0
_emberMetal
.
get
)
(
this
'
baseURL
'
)
;
if
(
url
!
=
=
'
'
)
{
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
}
else
if
(
baseURL
[
0
]
=
=
=
'
/
'
&
&
rootURL
[
0
]
=
=
=
'
/
'
)
{
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
}
return
baseURL
+
rootURL
+
url
;
}
willDestroy
:
function
(
)
{
this
.
_removeEventListener
(
)
;
}
getHash
:
_api
.
default
.
_getHash
_removeEventListener
:
function
(
)
{
if
(
this
.
_popstateHandler
)
{
window
.
removeEventListener
(
'
popstate
'
this
.
_popstateHandler
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
none_location
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
'
]
function
(
exports
_emberMetal
_emberDebug
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
implementation
:
'
none
'
path
:
'
'
detect
:
function
(
)
{
var
rootURL
=
this
.
rootURL
;
(
true
&
&
!
(
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
rootURL
must
end
with
a
trailing
forward
slash
e
.
g
.
"
/
app
/
"
'
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
)
;
}
rootURL
:
'
/
'
getURL
:
function
(
)
{
var
path
=
(
0
_emberMetal
.
get
)
(
this
'
path
'
)
;
var
rootURL
=
(
0
_emberMetal
.
get
)
(
this
'
rootURL
'
)
;
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
return
path
.
replace
(
new
RegExp
(
'
^
'
+
rootURL
+
'
(
?
=
/
|
)
'
)
'
'
)
;
}
setURL
:
function
(
path
)
{
(
0
_emberMetal
.
set
)
(
this
'
path
'
path
)
;
}
onUpdateURL
:
function
(
callback
)
{
this
.
updateCallback
=
callback
;
}
handleURL
:
function
(
url
)
{
(
0
_emberMetal
.
set
)
(
this
'
path
'
url
)
;
this
.
updateCallback
(
url
)
;
}
formatURL
:
function
(
url
)
{
var
rootURL
=
(
0
_emberMetal
.
get
)
(
this
'
rootURL
'
)
;
if
(
url
!
=
=
'
'
)
{
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
}
return
rootURL
+
url
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
util
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
getPath
=
getPath
;
exports
.
getQuery
=
getQuery
;
exports
.
getHash
=
getHash
;
exports
.
getFullPath
=
getFullPath
;
exports
.
getOrigin
=
getOrigin
;
exports
.
supportsHashChange
=
supportsHashChange
;
exports
.
supportsHistory
=
supportsHistory
;
exports
.
replacePath
=
replacePath
;
function
getPath
(
location
)
{
var
pathname
=
location
.
pathname
;
if
(
pathname
[
0
]
!
=
=
'
/
'
)
{
pathname
=
'
/
'
+
pathname
;
}
return
pathname
;
}
function
getQuery
(
location
)
{
return
location
.
search
;
}
function
getHash
(
location
)
{
var
href
=
location
.
href
;
var
hashIndex
=
href
.
indexOf
(
'
#
'
)
;
if
(
hashIndex
=
=
=
-
1
)
{
return
'
'
;
}
else
{
return
href
.
substr
(
hashIndex
)
;
}
}
function
getFullPath
(
location
)
{
return
getPath
(
location
)
+
getQuery
(
location
)
+
getHash
(
location
)
;
}
function
getOrigin
(
location
)
{
var
origin
=
location
.
origin
;
if
(
!
origin
)
{
origin
=
location
.
protocol
+
'
/
/
'
+
location
.
hostname
;
if
(
location
.
port
)
{
origin
+
=
'
:
'
+
location
.
port
;
}
}
return
origin
;
}
function
supportsHashChange
(
documentMode
global
)
{
return
'
onhashchange
'
in
global
&
&
(
documentMode
=
=
=
undefined
|
|
documentMode
>
7
)
;
}
function
supportsHistory
(
userAgent
history
)
{
if
(
(
userAgent
.
indexOf
(
'
Android
2
.
'
)
!
=
=
-
1
|
|
userAgent
.
indexOf
(
'
Android
4
.
0
'
)
!
=
=
-
1
)
&
&
userAgent
.
indexOf
(
'
Mobile
Safari
'
)
!
=
=
-
1
&
&
userAgent
.
indexOf
(
'
Chrome
'
)
=
=
=
-
1
&
&
userAgent
.
indexOf
(
'
Windows
Phone
'
)
=
=
=
-
1
)
{
return
false
;
}
return
!
!
(
history
&
&
'
pushState
'
in
history
)
;
}
function
replacePath
(
location
path
)
{
location
.
replace
(
getOrigin
(
location
)
+
path
)
;
}
}
)
;
enifed
(
'
ember
-
routing
/
services
/
router
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
routing
/
utils
'
]
function
(
exports
_emberRuntime
_utils
)
{
'
use
strict
'
;
var
RouterService
=
_emberRuntime
.
Service
.
extend
(
{
currentRouteName
:
(
0
_emberRuntime
.
readOnly
)
(
'
_router
.
currentRouteName
'
)
currentURL
:
(
0
_emberRuntime
.
readOnly
)
(
'
_router
.
currentURL
'
)
location
:
(
0
_emberRuntime
.
readOnly
)
(
'
_router
.
location
'
)
rootURL
:
(
0
_emberRuntime
.
readOnly
)
(
'
_router
.
rootURL
'
)
_router
:
null
transitionTo
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
(
0
_utils
.
resemblesURL
)
(
args
[
0
]
)
)
{
return
this
.
_router
.
_doURLTransition
(
'
transitionTo
'
args
[
0
]
)
;
}
var
_extractRouteArgs
=
(
0
_utils
.
extractRouteArgs
)
(
args
)
routeName
=
_extractRouteArgs
.
routeName
models
=
_extractRouteArgs
.
models
queryParams
=
_extractRouteArgs
.
queryParams
;
var
transition
=
this
.
_router
.
_doTransition
(
routeName
models
queryParams
true
)
;
transition
.
_keepDefaultQueryParamValues
=
true
;
return
transition
;
}
replaceWith
:
function
(
)
{
return
this
.
transitionTo
.
apply
(
this
arguments
)
.
method
(
'
replace
'
)
;
}
urlFor
:
function
(
)
{
var
_router
;
return
(
_router
=
this
.
_router
)
.
generate
.
apply
(
_router
arguments
)
;
}
isActive
:
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
var
_extractRouteArgs2
=
(
0
_utils
.
extractRouteArgs
)
(
args
)
routeName
=
_extractRouteArgs2
.
routeName
models
=
_extractRouteArgs2
.
models
queryParams
=
_extractRouteArgs2
.
queryParams
;
var
routerMicrolib
=
this
.
_router
.
_routerMicrolib
;
if
(
!
routerMicrolib
.
isActiveIntent
(
routeName
models
null
)
)
{
return
false
;
}
var
hasQueryParams
=
Object
.
keys
(
queryParams
)
.
length
>
0
;
if
(
hasQueryParams
)
{
this
.
_router
.
_prepareQueryParams
(
routeName
models
queryParams
true
)
;
return
(
0
_utils
.
shallowEqual
)
(
queryParams
routerMicrolib
.
state
.
queryParams
)
;
}
return
true
;
}
}
)
;
exports
.
default
=
RouterService
;
}
)
;
enifed
(
'
ember
-
routing
/
services
/
routing
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
runtime
'
'
ember
-
metal
'
]
function
(
exports
_emberUtils
_emberRuntime
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Service
.
extend
(
{
router
:
null
targetState
:
(
0
_emberRuntime
.
readOnly
)
(
'
router
.
targetState
'
)
currentState
:
(
0
_emberRuntime
.
readOnly
)
(
'
router
.
currentState
'
)
currentRouteName
:
(
0
_emberRuntime
.
readOnly
)
(
'
router
.
currentRouteName
'
)
currentPath
:
(
0
_emberRuntime
.
readOnly
)
(
'
router
.
currentPath
'
)
hasRoute
:
function
(
routeName
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
.
hasRoute
(
routeName
)
;
}
transitionTo
:
function
(
routeName
models
queryParams
shouldReplace
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
var
transition
=
router
.
_doTransition
(
routeName
models
queryParams
)
;
if
(
shouldReplace
)
{
transition
.
method
(
'
replace
'
)
;
}
return
transition
;
}
normalizeQueryParams
:
function
(
routeName
models
queryParams
)
{
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
.
_prepareQueryParams
(
routeName
models
queryParams
)
;
}
generateURL
:
function
(
routeName
models
queryParams
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
if
(
!
router
.
_routerMicrolib
)
{
return
;
}
var
visibleQueryParams
=
{
}
;
if
(
queryParams
)
{
(
0
_emberUtils
.
assign
)
(
visibleQueryParams
queryParams
)
;
this
.
normalizeQueryParams
(
routeName
models
visibleQueryParams
)
;
}
return
router
.
generate
.
apply
(
router
[
routeName
]
.
concat
(
models
[
{
queryParams
:
visibleQueryParams
}
]
)
)
;
}
isActiveForRoute
:
function
(
contexts
queryParams
routeName
routerState
isCurrentWhenSpecified
)
{
var
router
=
(
0
_emberMetal
.
get
)
(
this
'
router
'
)
;
var
handlers
=
router
.
_routerMicrolib
.
recognizer
.
handlersFor
(
routeName
)
;
var
leafName
=
handlers
[
handlers
.
length
-
1
]
.
handler
;
var
maximumContexts
=
numberOfContextsAcceptedByHandler
(
routeName
handlers
)
;
if
(
contexts
.
length
>
maximumContexts
)
{
routeName
=
leafName
;
}
return
routerState
.
isActiveIntent
(
routeName
contexts
queryParams
!
isCurrentWhenSpecified
)
;
}
}
)
;
function
numberOfContextsAcceptedByHandler
(
handler
handlerInfos
)
{
var
req
=
0
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
req
+
=
handlerInfos
[
i
]
.
names
.
length
;
if
(
handlerInfos
[
i
]
.
handler
=
=
=
handler
)
{
break
;
}
}
return
req
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
cache
'
[
'
exports
'
'
ember
-
runtime
'
]
function
(
exports
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
init
:
function
(
)
{
this
.
cache
=
Object
.
create
(
null
)
;
}
has
:
function
(
bucketKey
)
{
return
!
!
this
.
cache
[
bucketKey
]
;
}
stash
:
function
(
bucketKey
key
value
)
{
var
bucket
=
this
.
cache
[
bucketKey
]
;
if
(
!
bucket
)
{
bucket
=
this
.
cache
[
bucketKey
]
=
Object
.
create
(
null
)
;
}
bucket
[
key
]
=
value
;
}
lookup
:
function
(
bucketKey
prop
defaultValue
)
{
var
cache
=
this
.
cache
;
if
(
!
this
.
has
(
bucketKey
)
)
{
return
defaultValue
;
}
var
bucket
=
cache
[
bucketKey
]
;
if
(
prop
in
bucket
&
&
bucket
[
prop
]
!
=
=
undefined
)
{
return
bucket
[
prop
]
;
}
else
{
return
defaultValue
;
}
}
}
)
;
}
)
;
enifed
(
"
ember
-
routing
/
system
/
controller_for
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
controllerFor
;
function
controllerFor
(
container
controllerName
lookupOptions
)
{
return
container
.
lookup
(
"
controller
:
"
+
controllerName
lookupOptions
)
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
dsl
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
debug
'
]
function
(
exports
_emberBabel
_emberUtils
_emberDebug
)
{
'
use
strict
'
;
var
uuid
=
0
;
var
DSL
=
function
(
)
{
function
DSL
(
name
options
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
DSL
)
;
this
.
parent
=
name
;
this
.
enableLoadingSubstates
=
options
&
&
options
.
enableLoadingSubstates
;
this
.
matches
=
[
]
;
this
.
explicitIndex
=
undefined
;
this
.
options
=
options
;
}
DSL
.
prototype
.
route
=
function
route
(
name
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
callback
=
arguments
[
2
]
;
var
dummyErrorRoute
=
'
/
_unused_dummy_error_path_route_
'
+
name
+
'
/
:
error
'
;
if
(
arguments
.
length
=
=
=
2
&
&
typeof
options
=
=
=
'
function
'
)
{
callback
=
options
;
options
=
{
}
;
}
(
true
&
&
!
(
function
(
)
{
if
(
options
.
overrideNameAssertion
=
=
=
true
)
{
return
true
;
}
return
[
'
array
'
'
basic
'
'
object
'
'
application
'
]
.
indexOf
(
name
)
=
=
=
-
1
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
\
'
'
+
name
+
'
\
'
cannot
be
used
as
a
route
name
.
'
function
(
)
{
if
(
options
.
overrideNameAssertion
=
=
=
true
)
{
return
true
;
}
return
[
'
array
'
'
basic
'
'
object
'
'
application
'
]
.
indexOf
(
name
)
=
=
=
-
1
;
}
(
)
)
)
;
if
(
this
.
enableLoadingSubstates
)
{
createRoute
(
this
name
+
'
_loading
'
{
resetNamespace
:
options
.
resetNamespace
}
)
;
createRoute
(
this
name
+
'
_error
'
{
resetNamespace
:
options
.
resetNamespace
path
:
dummyErrorRoute
}
)
;
}
if
(
callback
)
{
var
fullName
=
getFullName
(
this
name
options
.
resetNamespace
)
;
var
dsl
=
new
DSL
(
fullName
this
.
options
)
;
createRoute
(
dsl
'
loading
'
)
;
createRoute
(
dsl
'
error
'
{
path
:
dummyErrorRoute
}
)
;
callback
.
call
(
dsl
)
;
createRoute
(
this
name
options
dsl
.
generate
(
)
)
;
}
else
{
createRoute
(
this
name
options
)
;
}
}
;
DSL
.
prototype
.
push
=
function
push
(
url
name
callback
serialize
)
{
var
parts
=
name
.
split
(
'
.
'
)
;
if
(
this
.
options
.
engineInfo
)
{
var
localFullName
=
name
.
slice
(
this
.
options
.
engineInfo
.
fullName
.
length
+
1
)
;
var
routeInfo
=
(
0
_emberUtils
.
assign
)
(
{
localFullName
:
localFullName
}
this
.
options
.
engineInfo
)
;
if
(
serialize
)
{
routeInfo
.
serializeMethod
=
serialize
;
}
this
.
options
.
addRouteForEngine
(
name
routeInfo
)
;
}
else
if
(
serialize
)
{
throw
new
Error
(
'
Defining
a
route
serializer
on
route
\
'
'
+
name
+
'
\
'
outside
an
Engine
is
not
allowed
.
'
)
;
}
if
(
url
=
=
=
'
'
|
|
url
=
=
=
'
/
'
|
|
parts
[
parts
.
length
-
1
]
=
=
=
'
index
'
)
{
this
.
explicitIndex
=
true
;
}
this
.
matches
.
push
(
url
name
callback
)
;
}
;
DSL
.
prototype
.
generate
=
function
generate
(
)
{
var
dslMatches
=
this
.
matches
;
if
(
!
this
.
explicitIndex
)
{
this
.
route
(
'
index
'
{
path
:
'
/
'
}
)
;
}
return
function
(
match
)
{
for
(
var
i
=
0
;
i
<
dslMatches
.
length
;
i
+
=
3
)
{
match
(
dslMatches
[
i
]
)
.
to
(
dslMatches
[
i
+
1
]
dslMatches
[
i
+
2
]
)
;
}
}
;
}
;
DSL
.
prototype
.
mount
=
function
mount
(
_name
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
engineRouteMap
=
this
.
options
.
resolveRouteMap
(
_name
)
;
var
name
=
_name
;
if
(
options
.
as
)
{
name
=
options
.
as
;
}
var
fullName
=
getFullName
(
this
name
options
.
resetNamespace
)
;
var
engineInfo
=
{
name
:
_name
instanceId
:
uuid
+
+
mountPoint
:
fullName
fullName
:
fullName
}
;
var
path
=
options
.
path
;
if
(
typeof
path
!
=
=
'
string
'
)
{
path
=
'
/
'
+
name
;
}
var
callback
=
void
0
;
var
dummyErrorRoute
=
'
/
_unused_dummy_error_path_route_
'
+
name
+
'
/
:
error
'
;
if
(
engineRouteMap
)
{
var
shouldResetEngineInfo
=
false
;
var
oldEngineInfo
=
this
.
options
.
engineInfo
;
if
(
oldEngineInfo
)
{
shouldResetEngineInfo
=
true
;
this
.
options
.
engineInfo
=
engineInfo
;
}
var
optionsForChild
=
(
0
_emberUtils
.
assign
)
(
{
engineInfo
:
engineInfo
}
this
.
options
)
;
var
childDSL
=
new
DSL
(
fullName
optionsForChild
)
;
createRoute
(
childDSL
'
loading
'
)
;
createRoute
(
childDSL
'
error
'
{
path
:
dummyErrorRoute
}
)
;
engineRouteMap
.
class
.
call
(
childDSL
)
;
callback
=
childDSL
.
generate
(
)
;
if
(
shouldResetEngineInfo
)
{
this
.
options
.
engineInfo
=
oldEngineInfo
;
}
}
var
localFullName
=
'
application
'
;
var
routeInfo
=
(
0
_emberUtils
.
assign
)
(
{
localFullName
:
localFullName
}
engineInfo
)
;
if
(
this
.
enableLoadingSubstates
)
{
var
substateName
=
name
+
'
_loading
'
;
var
_localFullName
=
'
application_loading
'
;
var
_routeInfo
=
(
0
_emberUtils
.
assign
)
(
{
localFullName
:
_localFullName
}
engineInfo
)
;
createRoute
(
this
substateName
{
resetNamespace
:
options
.
resetNamespace
}
)
;
this
.
options
.
addRouteForEngine
(
substateName
_routeInfo
)
;
substateName
=
name
+
'
_error
'
;
_localFullName
=
'
application_error
'
;
_routeInfo
=
(
0
_emberUtils
.
assign
)
(
{
localFullName
:
_localFullName
}
engineInfo
)
;
createRoute
(
this
substateName
{
resetNamespace
:
options
.
resetNamespace
path
:
dummyErrorRoute
}
)
;
this
.
options
.
addRouteForEngine
(
substateName
_routeInfo
)
;
}
this
.
options
.
addRouteForEngine
(
fullName
routeInfo
)
;
this
.
push
(
path
fullName
callback
)
;
}
;
return
DSL
;
}
(
)
;
exports
.
default
=
DSL
;
function
canNest
(
dsl
)
{
return
dsl
.
parent
!
=
=
'
application
'
;
}
function
getFullName
(
dsl
name
resetNamespace
)
{
if
(
canNest
(
dsl
)
&
&
resetNamespace
!
=
=
true
)
{
return
dsl
.
parent
+
'
.
'
+
name
;
}
else
{
return
name
;
}
}
function
createRoute
(
dsl
name
)
{
var
options
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
var
callback
=
arguments
[
3
]
;
var
fullName
=
getFullName
(
dsl
name
options
.
resetNamespace
)
;
if
(
typeof
options
.
path
!
=
=
'
string
'
)
{
options
.
path
=
'
/
'
+
name
;
}
dsl
.
push
(
options
.
path
fullName
callback
options
.
serialize
)
;
}
DSL
.
map
=
function
(
callback
)
{
var
dsl
=
new
DSL
(
)
;
callback
.
call
(
dsl
)
;
return
dsl
;
}
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
generate_controller
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
generateControllerFactory
=
generateControllerFactory
;
exports
.
default
=
generateController
;
function
generateControllerFactory
(
owner
controllerName
)
{
var
Factory
=
owner
.
factoryFor
(
'
controller
:
basic
'
)
.
class
;
Factory
=
Factory
.
extend
(
{
toString
:
function
(
)
{
return
'
(
generated
'
+
controllerName
+
'
controller
)
'
;
}
}
)
;
var
fullName
=
'
controller
:
'
+
controllerName
;
owner
.
register
(
fullName
Factory
)
;
return
Factory
;
}
function
generateController
(
owner
controllerName
)
{
generateControllerFactory
(
owner
controllerName
)
;
var
fullName
=
'
controller
:
'
+
controllerName
;
var
instance
=
owner
.
lookup
(
fullName
)
;
if
(
true
)
{
if
(
(
0
_emberMetal
.
get
)
(
instance
'
namespace
.
LOG_ACTIVE_GENERATION
'
)
)
{
(
0
_emberDebug
.
info
)
(
'
generated
-
>
'
+
fullName
{
fullName
:
fullName
}
)
;
}
}
return
instance
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
query_params
'
[
'
exports
'
'
ember
-
runtime
'
]
function
(
exports
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
isQueryParams
:
true
values
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
route
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
'
'
ember
-
routing
/
system
/
generate_controller
'
'
ember
-
routing
/
utils
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_emberRuntime
_generate_controller
_utils
)
{
'
use
strict
'
;
exports
.
defaultSerialize
=
defaultSerialize
;
exports
.
hasDefaultSerialize
=
hasDefaultSerialize
;
function
K
(
)
{
return
this
;
}
function
defaultSerialize
(
model
params
)
{
if
(
params
.
length
<
1
|
|
!
model
)
{
return
;
}
var
object
=
{
}
;
if
(
params
.
length
=
=
=
1
)
{
var
name
=
params
[
0
]
;
if
(
name
in
model
)
{
object
[
name
]
=
(
0
_emberMetal
.
get
)
(
model
name
)
;
}
else
if
(
/
_id
/
.
test
(
name
)
)
{
object
[
name
]
=
(
0
_emberMetal
.
get
)
(
model
'
id
'
)
;
}
}
else
{
object
=
(
0
_emberMetal
.
getProperties
)
(
model
params
)
;
}
return
object
;
}
var
DEFAULT_SERIALIZE
=
(
0
_emberUtils
.
symbol
)
(
'
DEFAULT_SERIALIZE
'
)
;
defaultSerialize
[
DEFAULT_SERIALIZE
]
=
true
;
function
hasDefaultSerialize
(
route
)
{
return
!
!
route
.
serialize
[
DEFAULT_SERIALIZE
]
;
}
var
Route
=
_emberRuntime
.
Object
.
extend
(
_emberRuntime
.
ActionHandler
_emberRuntime
.
Evented
{
queryParams
:
{
}
_setRouteName
:
function
(
name
)
{
this
.
routeName
=
name
;
this
.
fullRouteName
=
getEngineRouteName
(
(
0
_emberUtils
.
getOwner
)
(
this
)
name
)
;
}
_qp
:
(
0
_emberMetal
.
computed
)
(
function
(
)
{
var
_this
=
this
;
var
combinedQueryParameterConfiguration
=
void
0
;
var
controllerName
=
this
.
controllerName
|
|
this
.
routeName
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
controller
=
owner
.
lookup
(
'
controller
:
'
+
controllerName
)
;
var
queryParameterConfiguraton
=
(
0
_emberMetal
.
get
)
(
this
'
queryParams
'
)
;
var
hasRouterDefinedQueryParams
=
Object
.
keys
(
queryParameterConfiguraton
)
.
length
>
0
;
if
(
controller
)
{
var
controllerDefinedQueryParameterConfiguration
=
(
0
_emberMetal
.
get
)
(
controller
'
queryParams
'
)
|
|
{
}
;
var
normalizedControllerQueryParameterConfiguration
=
(
0
_utils
.
normalizeControllerQueryParams
)
(
controllerDefinedQueryParameterConfiguration
)
;
combinedQueryParameterConfiguration
=
mergeEachQueryParams
(
normalizedControllerQueryParameterConfiguration
queryParameterConfiguraton
)
;
}
else
if
(
hasRouterDefinedQueryParams
)
{
controller
=
(
0
_generate_controller
.
default
)
(
owner
controllerName
)
;
combinedQueryParameterConfiguration
=
queryParameterConfiguraton
;
}
var
qps
=
[
]
;
var
map
=
{
}
;
var
propertyNames
=
[
]
;
for
(
var
propName
in
combinedQueryParameterConfiguration
)
{
if
(
!
combinedQueryParameterConfiguration
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
if
(
propName
=
=
=
'
unknownProperty
'
|
|
propName
=
=
=
'
_super
'
)
{
continue
;
}
var
desc
=
combinedQueryParameterConfiguration
[
propName
]
;
var
scope
=
desc
.
scope
|
|
'
model
'
;
var
parts
=
void
0
;
if
(
scope
=
=
=
'
controller
'
)
{
parts
=
[
]
;
}
var
urlKey
=
desc
.
as
|
|
this
.
serializeQueryParamKey
(
propName
)
;
var
defaultValue
=
(
0
_emberMetal
.
get
)
(
controller
propName
)
;
if
(
Array
.
isArray
(
defaultValue
)
)
{
defaultValue
=
(
0
_emberRuntime
.
A
)
(
defaultValue
.
slice
(
)
)
;
}
var
type
=
desc
.
type
|
|
(
0
_emberRuntime
.
typeOf
)
(
defaultValue
)
;
var
defaultValueSerialized
=
this
.
serializeQueryParam
(
defaultValue
urlKey
type
)
;
var
scopedPropertyName
=
controllerName
+
'
:
'
+
propName
;
var
qp
=
{
undecoratedDefaultValue
:
(
0
_emberMetal
.
get
)
(
controller
propName
)
defaultValue
:
defaultValue
serializedDefaultValue
:
defaultValueSerialized
serializedValue
:
defaultValueSerialized
type
:
type
urlKey
:
urlKey
prop
:
propName
scopedPropertyName
:
scopedPropertyName
controllerName
:
controllerName
route
:
this
parts
:
parts
values
:
null
scope
:
scope
}
;
map
[
propName
]
=
map
[
urlKey
]
=
map
[
scopedPropertyName
]
=
qp
;
qps
.
push
(
qp
)
;
propertyNames
.
push
(
propName
)
;
}
return
{
qps
:
qps
map
:
map
propertyNames
:
propertyNames
states
:
{
inactive
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
}
active
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
return
_this
.
_activeQPChanged
(
qp
value
)
;
}
allowOverrides
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
return
_this
.
_updatingQPChanged
(
qp
)
;
}
}
}
;
}
)
_names
:
null
_stashNames
:
function
(
handlerInfo
dynamicParent
)
{
if
(
this
.
_names
)
{
return
;
}
var
names
=
this
.
_names
=
handlerInfo
.
_names
;
if
(
!
names
.
length
)
{
handlerInfo
=
dynamicParent
;
names
=
handlerInfo
&
&
handlerInfo
.
_names
|
|
[
]
;
}
var
qps
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
.
qps
'
)
;
var
namePaths
=
new
Array
(
names
.
length
)
;
for
(
var
a
=
0
;
a
<
names
.
length
;
+
+
a
)
{
namePaths
[
a
]
=
handlerInfo
.
name
+
'
.
'
+
names
[
a
]
;
}
for
(
var
i
=
0
;
i
<
qps
.
length
;
+
+
i
)
{
var
qp
=
qps
[
i
]
;
if
(
qp
.
scope
=
=
=
'
model
'
)
{
qp
.
parts
=
namePaths
;
}
}
}
_activeQPChanged
:
function
(
qp
value
)
{
this
.
router
.
_activeQPChanged
(
qp
.
scopedPropertyName
value
)
;
}
_updatingQPChanged
:
function
(
qp
)
{
this
.
router
.
_updatingQPChanged
(
qp
.
urlKey
)
;
}
mergedProperties
:
[
'
queryParams
'
]
paramsFor
:
function
(
name
)
{
var
_this2
=
this
;
var
route
=
(
0
_emberUtils
.
getOwner
)
(
this
)
.
lookup
(
'
route
:
'
+
name
)
;
if
(
!
route
)
{
return
{
}
;
}
var
transition
=
this
.
router
.
_routerMicrolib
.
activeTransition
;
var
state
=
transition
?
transition
.
state
:
this
.
router
.
_routerMicrolib
.
state
;
var
fullName
=
route
.
fullRouteName
;
var
params
=
(
0
_emberUtils
.
assign
)
(
{
}
state
.
params
[
fullName
]
)
;
var
queryParams
=
getQueryParamsFor
(
route
state
)
;
return
Object
.
keys
(
queryParams
)
.
reduce
(
function
(
params
key
)
{
(
true
&
&
!
(
!
params
[
key
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
route
\
'
'
+
_this2
.
routeName
+
'
\
'
has
both
a
dynamic
segment
and
query
param
with
name
\
'
'
+
key
+
'
\
'
.
Please
rename
one
to
avoid
collisions
.
'
!
params
[
key
]
)
)
;
params
[
key
]
=
queryParams
[
key
]
;
return
params
;
}
params
)
;
}
serializeQueryParamKey
:
function
(
controllerPropertyName
)
{
return
controllerPropertyName
;
}
serializeQueryParam
:
function
(
value
urlKey
defaultValueType
)
{
return
this
.
router
.
_serializeQueryParam
(
value
defaultValueType
)
;
}
deserializeQueryParam
:
function
(
value
urlKey
defaultValueType
)
{
return
this
.
router
.
_deserializeQueryParam
(
value
defaultValueType
)
;
}
_optionsForQueryParam
:
function
(
qp
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
queryParams
.
'
+
qp
.
urlKey
)
|
|
(
0
_emberMetal
.
get
)
(
this
'
queryParams
.
'
+
qp
.
prop
)
|
|
{
}
;
}
resetController
:
K
exit
:
function
(
)
{
this
.
deactivate
(
)
;
this
.
trigger
(
'
deactivate
'
)
;
this
.
teardownViews
(
)
;
}
_reset
:
function
(
isExiting
transition
)
{
var
controller
=
this
.
controller
;
controller
.
_qpDelegate
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
.
states
.
inactive
'
)
;
this
.
resetController
(
controller
isExiting
transition
)
;
}
enter
:
function
(
)
{
this
.
connections
=
[
]
;
this
.
activate
(
)
;
this
.
trigger
(
'
activate
'
)
;
}
templateName
:
null
controllerName
:
null
actions
:
{
queryParamsDidChange
:
function
(
changed
totalPresent
removed
)
{
var
qpMap
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
'
)
.
map
;
var
totalChanged
=
Object
.
keys
(
changed
)
.
concat
(
Object
.
keys
(
removed
)
)
;
for
(
var
i
=
0
;
i
<
totalChanged
.
length
;
+
+
i
)
{
var
qp
=
qpMap
[
totalChanged
[
i
]
]
;
if
(
qp
&
&
(
0
_emberMetal
.
get
)
(
this
.
_optionsForQueryParam
(
qp
)
'
refreshModel
'
)
&
&
this
.
router
.
currentState
)
{
this
.
refresh
(
)
;
break
;
}
}
return
true
;
}
finalizeQueryParamChange
:
function
(
params
finalParams
transition
)
{
if
(
this
.
fullRouteName
!
=
=
'
application
'
)
{
return
true
;
}
if
(
!
transition
)
{
return
;
}
var
handlerInfos
=
transition
.
state
.
handlerInfos
;
var
router
=
this
.
router
;
var
qpMeta
=
router
.
_queryParamsFor
(
handlerInfos
)
;
var
changes
=
router
.
_qpUpdates
;
var
replaceUrl
=
void
0
;
(
0
_utils
.
stashParamNames
)
(
router
handlerInfos
)
;
for
(
var
i
=
0
;
i
<
qpMeta
.
qps
.
length
;
+
+
i
)
{
var
qp
=
qpMeta
.
qps
[
i
]
;
var
route
=
qp
.
route
;
var
controller
=
route
.
controller
;
var
presentKey
=
qp
.
urlKey
in
params
&
&
qp
.
urlKey
;
var
value
=
void
0
svalue
=
void
0
;
if
(
changes
&
&
qp
.
urlKey
in
changes
)
{
value
=
(
0
_emberMetal
.
get
)
(
controller
qp
.
prop
)
;
svalue
=
route
.
serializeQueryParam
(
value
qp
.
urlKey
qp
.
type
)
;
}
else
{
if
(
presentKey
)
{
svalue
=
params
[
presentKey
]
;
if
(
svalue
!
=
=
undefined
)
{
value
=
route
.
deserializeQueryParam
(
svalue
qp
.
urlKey
qp
.
type
)
;
}
}
else
{
svalue
=
qp
.
serializedDefaultValue
;
value
=
copyDefaultValue
(
qp
.
defaultValue
)
;
}
}
controller
.
_qpDelegate
=
(
0
_emberMetal
.
get
)
(
route
'
_qp
.
states
.
inactive
'
)
;
var
thisQueryParamChanged
=
svalue
!
=
=
qp
.
serializedValue
;
if
(
thisQueryParamChanged
)
{
if
(
transition
.
queryParamsOnly
&
&
replaceUrl
!
=
=
false
)
{
var
options
=
route
.
_optionsForQueryParam
(
qp
)
;
var
replaceConfigValue
=
(
0
_emberMetal
.
get
)
(
options
'
replace
'
)
;
if
(
replaceConfigValue
)
{
replaceUrl
=
true
;
}
else
if
(
replaceConfigValue
=
=
=
false
)
{
replaceUrl
=
false
;
}
}
(
0
_emberMetal
.
set
)
(
controller
qp
.
prop
value
)
;
}
qp
.
serializedValue
=
svalue
;
var
thisQueryParamHasDefaultValue
=
qp
.
serializedDefaultValue
=
=
=
svalue
;
if
(
!
thisQueryParamHasDefaultValue
|
|
transition
.
_keepDefaultQueryParamValues
)
{
finalParams
.
push
(
{
value
:
svalue
visible
:
true
key
:
presentKey
|
|
qp
.
urlKey
}
)
;
}
}
if
(
replaceUrl
)
{
transition
.
method
(
'
replace
'
)
;
}
qpMeta
.
qps
.
forEach
(
function
(
qp
)
{
var
routeQpMeta
=
(
0
_emberMetal
.
get
)
(
qp
.
route
'
_qp
'
)
;
var
finalizedController
=
qp
.
route
.
controller
;
finalizedController
.
_qpDelegate
=
(
0
_emberMetal
.
get
)
(
routeQpMeta
'
states
.
active
'
)
;
}
)
;
router
.
_qpUpdates
=
null
;
}
}
deactivate
:
K
activate
:
K
transitionTo
:
function
(
name
context
)
{
var
_router
;
return
(
_router
=
this
.
router
)
.
transitionTo
.
apply
(
_router
(
0
_utils
.
prefixRouteNameArg
)
(
this
arguments
)
)
;
}
intermediateTransitionTo
:
function
(
)
{
var
_router2
;
(
_router2
=
this
.
router
)
.
intermediateTransitionTo
.
apply
(
_router2
(
0
_utils
.
prefixRouteNameArg
)
(
this
arguments
)
)
;
}
refresh
:
function
(
)
{
return
this
.
router
.
_routerMicrolib
.
refresh
(
this
)
;
}
replaceWith
:
function
(
)
{
var
_router3
;
return
(
_router3
=
this
.
router
)
.
replaceWith
.
apply
(
_router3
(
0
_utils
.
prefixRouteNameArg
)
(
this
arguments
)
)
;
}
send
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
this
.
router
&
&
this
.
router
.
_routerMicrolib
|
|
!
(
0
_emberDebug
.
isTesting
)
(
)
)
{
var
_router4
;
(
_router4
=
this
.
router
)
.
send
.
apply
(
_router4
args
)
;
}
else
{
var
name
=
args
.
shift
(
)
;
var
action
=
this
.
actions
[
name
]
;
if
(
action
)
{
return
action
.
apply
(
this
args
)
;
}
}
}
setup
:
function
(
context
transition
)
{
var
controller
=
void
0
;
var
controllerName
=
this
.
controllerName
|
|
this
.
routeName
;
var
definedController
=
this
.
controllerFor
(
controllerName
true
)
;
if
(
definedController
)
{
controller
=
definedController
;
}
else
{
controller
=
this
.
generateController
(
controllerName
)
;
}
if
(
!
this
.
controller
)
{
var
propNames
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
.
propertyNames
'
)
;
addQueryParamsObservers
(
controller
propNames
)
;
this
.
controller
=
controller
;
}
var
queryParams
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
'
)
;
var
states
=
queryParams
.
states
;
controller
.
_qpDelegate
=
states
.
allowOverrides
;
if
(
transition
)
{
(
0
_utils
.
stashParamNames
)
(
this
.
router
transition
.
state
.
handlerInfos
)
;
var
cache
=
this
.
_bucketCache
;
var
params
=
transition
.
params
;
var
allParams
=
queryParams
.
propertyNames
;
allParams
.
forEach
(
function
(
prop
)
{
var
aQp
=
queryParams
.
map
[
prop
]
;
aQp
.
values
=
params
;
var
cacheKey
=
(
0
_utils
.
calculateCacheKey
)
(
aQp
.
route
.
fullRouteName
aQp
.
parts
aQp
.
values
)
;
var
value
=
cache
.
lookup
(
cacheKey
prop
aQp
.
undecoratedDefaultValue
)
;
(
0
_emberMetal
.
set
)
(
controller
prop
value
)
;
}
)
;
var
qpValues
=
getQueryParamsFor
(
this
transition
.
state
)
;
(
0
_emberMetal
.
setProperties
)
(
controller
qpValues
)
;
}
this
.
setupController
(
controller
context
transition
)
;
if
(
this
.
_environment
.
options
.
shouldRender
)
{
this
.
renderTemplate
(
controller
context
)
;
}
}
_qpChanged
:
function
(
prop
value
qp
)
{
if
(
!
qp
)
{
return
;
}
var
cache
=
this
.
_bucketCache
;
var
cacheKey
=
(
0
_utils
.
calculateCacheKey
)
(
qp
.
route
.
fullRouteName
qp
.
parts
qp
.
values
)
;
cache
.
stash
(
cacheKey
prop
value
)
;
}
beforeModel
:
K
afterModel
:
K
redirect
:
K
contextDidChange
:
function
(
)
{
this
.
currentModel
=
this
.
context
;
}
model
:
function
(
params
transition
)
{
var
name
=
void
0
sawParams
=
void
0
value
=
void
0
;
var
queryParams
=
(
0
_emberMetal
.
get
)
(
this
'
_qp
.
map
'
)
;
for
(
var
prop
in
params
)
{
if
(
prop
=
=
=
'
queryParams
'
|
|
queryParams
&
&
prop
in
queryParams
)
{
continue
;
}
var
match
=
prop
.
match
(
/
^
(
.
*
)
_id
/
)
;
if
(
match
!
=
=
null
)
{
name
=
match
[
1
]
;
value
=
params
[
prop
]
;
}
sawParams
=
true
;
}
if
(
!
name
)
{
if
(
sawParams
)
{
return
(
0
_emberRuntime
.
copy
)
(
params
)
;
}
else
{
if
(
transition
.
resolveIndex
<
1
)
{
return
;
}
return
transition
.
state
.
handlerInfos
[
transition
.
resolveIndex
-
1
]
.
context
;
}
}
return
this
.
findModel
(
name
value
)
;
}
deserialize
:
function
(
params
transition
)
{
return
this
.
model
(
this
.
paramsFor
(
this
.
routeName
)
transition
)
;
}
findModel
:
function
(
)
{
var
_get
;
return
(
_get
=
(
0
_emberMetal
.
get
)
(
this
'
store
'
)
)
.
find
.
apply
(
_get
arguments
)
;
}
store
:
(
0
_emberMetal
.
computed
)
(
function
(
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
routeName
=
this
.
routeName
;
var
namespace
=
(
0
_emberMetal
.
get
)
(
this
'
router
.
namespace
'
)
;
return
{
find
:
function
(
name
value
)
{
var
modelClass
=
owner
.
factoryFor
(
'
model
:
'
+
name
)
;
(
true
&
&
!
(
!
!
modelClass
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
used
the
dynamic
segment
'
+
name
+
'
_id
in
your
route
'
+
routeName
+
'
but
'
+
namespace
+
'
.
'
+
_emberRuntime
.
String
.
classify
(
name
)
+
'
did
not
exist
and
you
did
not
override
your
route
\
'
s
model
hook
.
'
!
!
modelClass
)
)
;
if
(
!
modelClass
)
{
return
;
}
modelClass
=
modelClass
.
class
;
(
true
&
&
!
(
typeof
modelClass
.
find
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
_emberRuntime
.
String
.
classify
(
name
)
+
'
has
no
method
find
.
'
typeof
modelClass
.
find
=
=
=
'
function
'
)
)
;
return
modelClass
.
find
(
value
)
;
}
}
;
}
)
serialize
:
defaultSerialize
setupController
:
function
(
controller
context
transition
)
{
if
(
controller
&
&
context
!
=
=
undefined
)
{
(
0
_emberMetal
.
set
)
(
controller
'
model
'
context
)
;
}
}
controllerFor
:
function
(
name
_skipAssert
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
route
=
owner
.
lookup
(
'
route
:
'
+
name
)
;
var
controller
=
void
0
;
if
(
route
&
&
route
.
controllerName
)
{
name
=
route
.
controllerName
;
}
controller
=
owner
.
lookup
(
'
controller
:
'
+
name
)
;
(
true
&
&
!
(
controller
|
|
_skipAssert
=
=
=
true
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
controller
named
\
'
'
+
name
+
'
\
'
could
not
be
found
.
Make
sure
that
this
route
exists
and
has
already
been
entered
at
least
once
.
If
you
are
accessing
a
controller
not
associated
with
a
route
make
sure
the
controller
class
is
explicitly
defined
.
'
controller
|
|
_skipAssert
=
=
=
true
)
)
;
return
controller
;
}
generateController
:
function
(
name
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
return
(
0
_generate_controller
.
default
)
(
owner
name
)
;
}
modelFor
:
function
(
_name
)
{
var
name
=
void
0
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
transition
=
this
.
router
?
this
.
router
.
_routerMicrolib
.
activeTransition
:
null
;
if
(
owner
.
routable
&
&
transition
!
=
=
null
)
{
name
=
getEngineRouteName
(
owner
_name
)
;
}
else
{
name
=
_name
;
}
var
route
=
owner
.
lookup
(
'
route
:
'
+
name
)
;
if
(
transition
!
=
=
null
)
{
var
modelLookupName
=
route
&
&
route
.
routeName
|
|
name
;
if
(
transition
.
resolvedModels
.
hasOwnProperty
(
modelLookupName
)
)
{
return
transition
.
resolvedModels
[
modelLookupName
]
;
}
}
return
route
&
&
route
.
currentModel
;
}
renderTemplate
:
function
(
controller
model
)
{
this
.
render
(
)
;
}
render
:
function
(
_name
options
)
{
var
name
=
void
0
;
var
isDefaultRender
=
arguments
.
length
=
=
=
0
;
if
(
!
isDefaultRender
)
{
if
(
typeof
_name
=
=
=
'
object
'
&
&
!
options
)
{
name
=
this
.
templateName
|
|
this
.
routeName
;
options
=
_name
;
}
else
{
(
true
&
&
!
(
!
(
0
_emberMetal
.
isEmpty
)
(
_name
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
name
in
the
given
arguments
is
undefined
or
empty
string
'
!
(
0
_emberMetal
.
isEmpty
)
(
_name
)
)
)
;
name
=
_name
;
}
}
var
renderOptions
=
buildRenderOptions
(
this
isDefaultRender
name
options
)
;
this
.
connections
.
push
(
renderOptions
)
;
_emberMetal
.
run
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
disconnectOutlet
:
function
(
options
)
{
var
outletName
=
void
0
;
var
parentView
=
void
0
;
if
(
options
)
{
if
(
typeof
options
=
=
=
'
string
'
)
{
outletName
=
options
;
}
else
{
outletName
=
options
.
outlet
;
parentView
=
options
.
parentView
?
options
.
parentView
.
replace
(
/
\
/
/
g
'
.
'
)
:
undefined
;
(
true
&
&
!
(
!
(
'
outlet
'
in
options
&
&
options
.
outlet
=
=
=
undefined
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
passed
undefined
as
the
outlet
name
.
'
!
(
'
outlet
'
in
options
&
&
options
.
outlet
=
=
=
undefined
)
)
)
;
}
}
outletName
=
outletName
|
|
'
main
'
;
this
.
_disconnectOutlet
(
outletName
parentView
)
;
var
handlerInfos
=
this
.
router
.
_routerMicrolib
.
currentHandlerInfos
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
handlerInfos
[
i
]
.
handler
.
_disconnectOutlet
(
outletName
parentView
)
;
}
}
_disconnectOutlet
:
function
(
outletName
parentView
)
{
var
parent
=
parentRoute
(
this
)
;
if
(
parent
&
&
parentView
=
=
=
parent
.
routeName
)
{
parentView
=
undefined
;
}
for
(
var
i
=
0
;
i
<
this
.
connections
.
length
;
i
+
+
)
{
var
connection
=
this
.
connections
[
i
]
;
if
(
connection
.
outlet
=
=
=
outletName
&
&
connection
.
into
=
=
=
parentView
)
{
this
.
connections
[
i
]
=
{
owner
:
connection
.
owner
into
:
connection
.
into
outlet
:
connection
.
outlet
name
:
connection
.
name
controller
:
undefined
template
:
undefined
}
;
_emberMetal
.
run
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
}
}
willDestroy
:
function
(
)
{
this
.
teardownViews
(
)
;
}
teardownViews
:
function
(
)
{
if
(
this
.
connections
&
&
this
.
connections
.
length
>
0
)
{
this
.
connections
=
[
]
;
_emberMetal
.
run
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
}
}
)
;
Route
.
reopenClass
(
{
isRouteFactory
:
true
}
)
;
function
parentRoute
(
route
)
{
var
handlerInfo
=
handlerInfoFor
(
route
route
.
router
.
_routerMicrolib
.
state
.
handlerInfos
-
1
)
;
return
handlerInfo
&
&
handlerInfo
.
handler
;
}
function
handlerInfoFor
(
route
handlerInfos
)
{
var
offset
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
0
;
if
(
!
handlerInfos
)
{
return
;
}
var
current
=
void
0
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
current
=
handlerInfos
[
i
]
.
handler
;
if
(
current
=
=
=
route
)
{
return
handlerInfos
[
i
+
offset
]
;
}
}
}
function
buildRenderOptions
(
route
isDefaultRender
_name
options
)
{
(
true
&
&
!
(
isDefaultRender
|
|
!
(
options
&
&
'
outlet
'
in
options
&
&
options
.
outlet
=
=
=
undefined
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
passed
undefined
as
the
outlet
name
.
'
isDefaultRender
|
|
!
(
options
&
&
'
outlet
'
in
options
&
&
options
.
outlet
=
=
=
undefined
)
)
)
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
route
)
;
var
name
=
void
0
templateName
=
void
0
into
=
void
0
outlet
=
void
0
controller
=
void
0
model
=
void
0
;
if
(
options
)
{
into
=
options
.
into
&
&
options
.
into
.
replace
(
/
\
/
/
g
'
.
'
)
;
outlet
=
options
.
outlet
;
controller
=
options
.
controller
;
model
=
options
.
model
;
}
outlet
=
outlet
|
|
'
main
'
;
if
(
isDefaultRender
)
{
name
=
route
.
routeName
;
templateName
=
route
.
templateName
|
|
name
;
}
else
{
name
=
_name
.
replace
(
/
\
/
/
g
'
.
'
)
;
templateName
=
name
;
}
if
(
!
controller
)
{
if
(
isDefaultRender
)
{
controller
=
route
.
controllerName
|
|
owner
.
lookup
(
'
controller
:
'
+
name
)
;
}
else
{
controller
=
owner
.
lookup
(
'
controller
:
'
+
name
)
|
|
route
.
controllerName
|
|
route
.
routeName
;
}
}
if
(
typeof
controller
=
=
=
'
string
'
)
{
var
controllerName
=
controller
;
controller
=
owner
.
lookup
(
'
controller
:
'
+
controllerName
)
;
(
true
&
&
!
(
isDefaultRender
|
|
controller
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
passed
controller
:
\
'
'
+
controllerName
+
'
\
'
into
the
render
method
but
no
such
controller
could
be
found
.
'
isDefaultRender
|
|
controller
)
)
;
}
if
(
model
)
{
controller
.
set
(
'
model
'
model
)
;
}
var
template
=
owner
.
lookup
(
'
template
:
'
+
templateName
)
;
(
true
&
&
!
(
isDefaultRender
|
|
template
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Could
not
find
"
'
+
templateName
+
'
"
template
view
or
component
.
'
isDefaultRender
|
|
template
)
)
;
var
parent
=
void
0
;
if
(
into
&
&
(
parent
=
parentRoute
(
route
)
)
&
&
into
=
=
=
parent
.
routeName
)
{
into
=
undefined
;
}
var
renderOptions
=
{
owner
:
owner
into
:
into
outlet
:
outlet
name
:
name
controller
:
controller
template
:
template
|
|
route
.
_topLevelViewTemplate
}
;
if
(
true
)
{
var
LOG_VIEW_LOOKUPS
=
(
0
_emberMetal
.
get
)
(
route
.
router
'
namespace
.
LOG_VIEW_LOOKUPS
'
)
;
if
(
LOG_VIEW_LOOKUPS
&
&
!
template
)
{
(
0
_emberDebug
.
info
)
(
'
Could
not
find
"
'
+
name
+
'
"
template
.
Nothing
will
be
rendered
'
{
fullName
:
'
template
:
'
+
name
}
)
;
}
}
return
renderOptions
;
}
function
getFullQueryParams
(
router
state
)
{
if
(
state
.
fullQueryParams
)
{
return
state
.
fullQueryParams
;
}
state
.
fullQueryParams
=
{
}
;
(
0
_emberUtils
.
assign
)
(
state
.
fullQueryParams
state
.
queryParams
)
;
router
.
_deserializeQueryParams
(
state
.
handlerInfos
state
.
fullQueryParams
)
;
return
state
.
fullQueryParams
;
}
function
getQueryParamsFor
(
route
state
)
{
state
.
queryParamsFor
=
state
.
queryParamsFor
|
|
{
}
;
var
name
=
route
.
fullRouteName
;
if
(
state
.
queryParamsFor
[
name
]
)
{
return
state
.
queryParamsFor
[
name
]
;
}
var
fullQueryParams
=
getFullQueryParams
(
route
.
router
state
)
;
var
params
=
state
.
queryParamsFor
[
name
]
=
{
}
;
var
qpMeta
=
(
0
_emberMetal
.
get
)
(
route
'
_qp
'
)
;
var
qps
=
qpMeta
.
qps
;
for
(
var
i
=
0
;
i
<
qps
.
length
;
+
+
i
)
{
var
qp
=
qps
[
i
]
;
var
qpValueWasPassedIn
=
qp
.
prop
in
fullQueryParams
;
params
[
qp
.
prop
]
=
qpValueWasPassedIn
?
fullQueryParams
[
qp
.
prop
]
:
copyDefaultValue
(
qp
.
defaultValue
)
;
}
return
params
;
}
function
copyDefaultValue
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
(
0
_emberRuntime
.
A
)
(
value
.
slice
(
)
)
;
}
return
value
;
}
function
mergeEachQueryParams
(
controllerQP
routeQP
)
{
var
qps
=
{
}
;
var
keysAlreadyMergedOrSkippable
=
{
defaultValue
:
true
type
:
true
scope
:
true
as
:
true
}
;
for
(
var
cqpName
in
controllerQP
)
{
if
(
!
controllerQP
.
hasOwnProperty
(
cqpName
)
)
{
continue
;
}
var
newControllerParameterConfiguration
=
{
}
;
(
0
_emberUtils
.
assign
)
(
newControllerParameterConfiguration
controllerQP
[
cqpName
]
routeQP
[
cqpName
]
)
;
qps
[
cqpName
]
=
newControllerParameterConfiguration
;
keysAlreadyMergedOrSkippable
[
cqpName
]
=
true
;
}
for
(
var
rqpName
in
routeQP
)
{
if
(
!
routeQP
.
hasOwnProperty
(
rqpName
)
|
|
keysAlreadyMergedOrSkippable
[
rqpName
]
)
{
continue
;
}
var
newRouteParameterConfiguration
=
{
}
;
(
0
_emberUtils
.
assign
)
(
newRouteParameterConfiguration
routeQP
[
rqpName
]
controllerQP
[
rqpName
]
)
;
qps
[
rqpName
]
=
newRouteParameterConfiguration
;
}
return
qps
;
}
function
addQueryParamsObservers
(
controller
propNames
)
{
propNames
.
forEach
(
function
(
prop
)
{
controller
.
addObserver
(
prop
+
'
.
[
]
'
controller
controller
.
_qpChanged
)
;
}
)
;
}
function
getEngineRouteName
(
engine
routeName
)
{
if
(
engine
.
routable
)
{
var
prefix
=
engine
.
mountPoint
;
if
(
routeName
=
=
=
'
application
'
)
{
return
prefix
;
}
else
{
return
prefix
+
'
.
'
+
routeName
;
}
}
return
routeName
;
}
exports
.
default
=
Route
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
router
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
console
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
'
'
ember
-
routing
/
system
/
route
'
'
ember
-
routing
/
system
/
dsl
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
routing
/
utils
'
'
ember
-
routing
/
system
/
router_state
'
'
router
'
]
function
(
exports
_emberUtils
_emberConsole
_emberMetal
_emberDebug
_emberRuntime
_route
_dsl
_api
_utils
_router_state
_router
)
{
'
use
strict
'
;
exports
.
triggerEvent
=
triggerEvent
;
function
K
(
)
{
return
this
;
}
var
slice
=
Array
.
prototype
.
slice
;
var
EmberRouter
=
_emberRuntime
.
Object
.
extend
(
_emberRuntime
.
Evented
{
location
:
'
hash
'
rootURL
:
'
/
'
_initRouterJs
:
function
(
)
{
var
routerMicrolib
=
this
.
_routerMicrolib
=
new
_router
.
default
(
)
;
routerMicrolib
.
triggerEvent
=
triggerEvent
.
bind
(
this
)
;
routerMicrolib
.
_triggerWillChangeContext
=
K
;
routerMicrolib
.
_triggerWillLeave
=
K
;
var
dslCallbacks
=
this
.
constructor
.
dslCallbacks
|
|
[
K
]
;
var
dsl
=
this
.
_buildDSL
(
)
;
dsl
.
route
(
'
application
'
{
path
:
'
/
'
resetNamespace
:
true
overrideNameAssertion
:
true
}
function
(
)
{
for
(
var
i
=
0
;
i
<
dslCallbacks
.
length
;
i
+
+
)
{
dslCallbacks
[
i
]
.
call
(
this
)
;
}
}
)
;
if
(
true
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
namespace
.
LOG_TRANSITIONS_INTERNAL
'
)
)
{
routerMicrolib
.
log
=
_emberConsole
.
default
.
debug
;
}
}
routerMicrolib
.
map
(
dsl
.
generate
(
)
)
;
}
_buildDSL
:
function
(
)
{
var
enableLoadingSubstates
=
this
.
_hasModuleBasedResolver
(
)
;
var
options
=
{
enableLoadingSubstates
:
enableLoadingSubstates
}
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
router
=
this
;
options
.
resolveRouteMap
=
function
(
name
)
{
return
owner
.
factoryFor
(
'
route
-
map
:
'
+
name
)
;
}
;
options
.
addRouteForEngine
=
function
(
name
engineInfo
)
{
if
(
!
router
.
_engineInfoByRoute
[
name
]
)
{
router
.
_engineInfoByRoute
[
name
]
=
engineInfo
;
}
}
;
return
new
_dsl
.
default
(
null
options
)
;
}
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
currentURL
=
null
;
this
.
currentRouteName
=
null
;
this
.
currentPath
=
null
;
this
.
_qpCache
=
Object
.
create
(
null
)
;
this
.
_resetQueuedQueryParameterChanges
(
)
;
this
.
_handledErrors
=
new
Set
(
)
;
this
.
_engineInstances
=
Object
.
create
(
null
)
;
this
.
_engineInfoByRoute
=
Object
.
create
(
null
)
;
}
_resetQueuedQueryParameterChanges
:
function
(
)
{
this
.
_queuedQPChanges
=
{
}
;
}
url
:
(
0
_emberMetal
.
computed
)
(
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
.
getURL
(
)
;
}
)
_hasModuleBasedResolver
:
function
(
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
if
(
!
owner
)
{
return
false
;
}
var
resolver
=
(
0
_emberMetal
.
get
)
(
owner
'
application
.
__registry__
.
resolver
.
moduleBasedResolver
'
)
;
return
!
!
resolver
;
}
startRouting
:
function
(
)
{
var
initialURL
=
(
0
_emberMetal
.
get
)
(
this
'
initialURL
'
)
;
if
(
this
.
setupRouter
(
)
)
{
if
(
initialURL
=
=
=
undefined
)
{
initialURL
=
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
.
getURL
(
)
;
}
var
initialTransition
=
this
.
handleURL
(
initialURL
)
;
if
(
initialTransition
&
&
initialTransition
.
error
)
{
throw
initialTransition
.
error
;
}
}
}
setupRouter
:
function
(
)
{
var
_this
=
this
;
this
.
_initRouterJs
(
)
;
this
.
_setupLocation
(
)
;
var
location
=
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
;
if
(
(
0
_emberMetal
.
get
)
(
location
'
cancelRouterSetup
'
)
)
{
return
false
;
}
this
.
_setupRouter
(
location
)
;
location
.
onUpdateURL
(
function
(
url
)
{
_this
.
handleURL
(
url
)
;
}
)
;
return
true
;
}
didTransition
:
function
(
infos
)
{
updatePaths
(
this
)
;
this
.
_cancelSlowTransitionTimer
(
)
;
this
.
notifyPropertyChange
(
'
url
'
)
;
this
.
set
(
'
currentState
'
this
.
targetState
)
;
_emberMetal
.
run
.
once
(
this
this
.
trigger
'
didTransition
'
)
;
if
(
true
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberConsole
.
default
.
log
(
'
Transitioned
into
\
'
'
+
EmberRouter
.
_routePath
(
infos
)
+
'
\
'
'
)
;
}
}
}
_setOutlets
:
function
(
)
{
if
(
this
.
isDestroying
|
|
this
.
isDestroyed
)
{
return
;
}
var
handlerInfos
=
this
.
_routerMicrolib
.
currentHandlerInfos
;
var
route
=
void
0
;
var
defaultParentState
=
void
0
;
var
liveRoutes
=
null
;
if
(
!
handlerInfos
)
{
return
;
}
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
route
=
handlerInfos
[
i
]
.
handler
;
var
connections
=
route
.
connections
;
var
ownState
=
void
0
;
for
(
var
j
=
0
;
j
<
connections
.
length
;
j
+
+
)
{
var
appended
=
appendLiveRoute
(
liveRoutes
defaultParentState
connections
[
j
]
)
;
liveRoutes
=
appended
.
liveRoutes
;
if
(
appended
.
ownState
.
render
.
name
=
=
=
route
.
routeName
|
|
appended
.
ownState
.
render
.
outlet
=
=
=
'
main
'
)
{
ownState
=
appended
.
ownState
;
}
}
if
(
connections
.
length
=
=
=
0
)
{
ownState
=
representEmptyRoute
(
liveRoutes
defaultParentState
route
)
;
}
defaultParentState
=
ownState
;
}
if
(
!
liveRoutes
)
{
return
;
}
if
(
!
this
.
_toplevelView
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
OutletView
=
owner
.
factoryFor
(
'
view
:
-
outlet
'
)
;
this
.
_toplevelView
=
OutletView
.
create
(
)
;
this
.
_toplevelView
.
setOutletState
(
liveRoutes
)
;
var
instance
=
owner
.
lookup
(
'
-
application
-
instance
:
main
'
)
;
instance
.
didCreateRootView
(
this
.
_toplevelView
)
;
}
else
{
this
.
_toplevelView
.
setOutletState
(
liveRoutes
)
;
}
}
willTransition
:
function
(
oldInfos
newInfos
transition
)
{
_emberMetal
.
run
.
once
(
this
this
.
trigger
'
willTransition
'
transition
)
;
if
(
true
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberConsole
.
default
.
log
(
'
Preparing
to
transition
from
\
'
'
+
EmberRouter
.
_routePath
(
oldInfos
)
+
'
\
'
to
\
'
'
+
EmberRouter
.
_routePath
(
newInfos
)
+
'
\
'
'
)
;
}
}
}
handleURL
:
function
(
url
)
{
var
_url
=
url
.
split
(
/
#
(
.
+
)
?
/
)
[
0
]
;
return
this
.
_doURLTransition
(
'
handleURL
'
_url
)
;
}
_doURLTransition
:
function
(
routerJsMethod
url
)
{
var
transition
=
this
.
_routerMicrolib
[
routerJsMethod
]
(
url
|
|
'
/
'
)
;
didBeginTransition
(
transition
this
)
;
return
transition
;
}
transitionTo
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
(
0
_utils
.
resemblesURL
)
(
args
[
0
]
)
)
{
return
this
.
_doURLTransition
(
'
transitionTo
'
args
[
0
]
)
;
}
var
_extractRouteArgs
=
(
0
_utils
.
extractRouteArgs
)
(
args
)
routeName
=
_extractRouteArgs
.
routeName
models
=
_extractRouteArgs
.
models
queryParams
=
_extractRouteArgs
.
queryParams
;
return
this
.
_doTransition
(
routeName
models
queryParams
)
;
}
intermediateTransitionTo
:
function
(
)
{
var
_routerMicrolib
;
(
_routerMicrolib
=
this
.
_routerMicrolib
)
.
intermediateTransitionTo
.
apply
(
_routerMicrolib
arguments
)
;
updatePaths
(
this
)
;
if
(
true
)
{
var
infos
=
this
.
_routerMicrolib
.
currentHandlerInfos
;
if
(
(
0
_emberMetal
.
get
)
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberConsole
.
default
.
log
(
'
Intermediate
-
transitioned
into
\
'
'
+
EmberRouter
.
_routePath
(
infos
)
+
'
\
'
'
)
;
}
}
}
replaceWith
:
function
(
)
{
return
this
.
transitionTo
.
apply
(
this
arguments
)
.
method
(
'
replace
'
)
;
}
generate
:
function
(
)
{
var
_routerMicrolib2
;
var
url
=
(
_routerMicrolib2
=
this
.
_routerMicrolib
)
.
generate
.
apply
(
_routerMicrolib2
arguments
)
;
return
this
.
location
.
formatURL
(
url
)
;
}
isActive
:
function
(
)
{
var
_routerMicrolib3
;
return
(
_routerMicrolib3
=
this
.
_routerMicrolib
)
.
isActive
.
apply
(
_routerMicrolib3
arguments
)
;
}
isActiveIntent
:
function
(
routeName
models
queryParams
)
{
return
this
.
currentState
.
isActiveIntent
(
routeName
models
queryParams
)
;
}
send
:
function
(
)
{
var
_routerMicrolib4
;
(
_routerMicrolib4
=
this
.
_routerMicrolib
)
.
trigger
.
apply
(
_routerMicrolib4
arguments
)
;
}
hasRoute
:
function
(
route
)
{
return
this
.
_routerMicrolib
.
hasRoute
(
route
)
;
}
reset
:
function
(
)
{
if
(
this
.
_routerMicrolib
)
{
this
.
_routerMicrolib
.
reset
(
)
;
}
}
willDestroy
:
function
(
)
{
if
(
this
.
_toplevelView
)
{
this
.
_toplevelView
.
destroy
(
)
;
this
.
_toplevelView
=
null
;
}
this
.
_super
.
apply
(
this
arguments
)
;
this
.
reset
(
)
;
var
instances
=
this
.
_engineInstances
;
for
(
var
name
in
instances
)
{
for
(
var
id
in
instances
[
name
]
)
{
(
0
_emberMetal
.
run
)
(
instances
[
name
]
[
id
]
'
destroy
'
)
;
}
}
}
_activeQPChanged
:
function
(
queryParameterName
newValue
)
{
this
.
_queuedQPChanges
[
queryParameterName
]
=
newValue
;
_emberMetal
.
run
.
once
(
this
this
.
_fireQueryParamTransition
)
;
}
_updatingQPChanged
:
function
(
queryParameterName
)
{
if
(
!
this
.
_qpUpdates
)
{
this
.
_qpUpdates
=
{
}
;
}
this
.
_qpUpdates
[
queryParameterName
]
=
true
;
}
_fireQueryParamTransition
:
function
(
)
{
this
.
transitionTo
(
{
queryParams
:
this
.
_queuedQPChanges
}
)
;
this
.
_resetQueuedQueryParameterChanges
(
)
;
}
_setupLocation
:
function
(
)
{
var
location
=
(
0
_emberMetal
.
get
)
(
this
'
location
'
)
;
var
rootURL
=
(
0
_emberMetal
.
get
)
(
this
'
rootURL
'
)
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
if
(
'
string
'
=
=
=
typeof
location
&
&
owner
)
{
var
resolvedLocation
=
owner
.
lookup
(
'
location
:
'
+
location
)
;
if
(
resolvedLocation
!
=
=
undefined
)
{
location
=
(
0
_emberMetal
.
set
)
(
this
'
location
'
resolvedLocation
)
;
}
else
{
var
options
=
{
implementation
:
location
}
;
location
=
(
0
_emberMetal
.
set
)
(
this
'
location
'
_api
.
default
.
create
(
options
)
)
;
}
}
if
(
location
!
=
=
null
&
&
typeof
location
=
=
=
'
object
'
)
{
if
(
rootURL
)
{
(
0
_emberMetal
.
set
)
(
location
'
rootURL
'
rootURL
)
;
}
if
(
typeof
location
.
detect
=
=
=
'
function
'
)
{
location
.
detect
(
)
;
}
if
(
typeof
location
.
initState
=
=
=
'
function
'
)
{
location
.
initState
(
)
;
}
}
}
_getHandlerFunction
:
function
(
)
{
var
_this2
=
this
;
var
seen
=
Object
.
create
(
null
)
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
return
function
(
name
)
{
var
routeName
=
name
;
var
routeOwner
=
owner
;
var
engineInfo
=
_this2
.
_engineInfoByRoute
[
routeName
]
;
if
(
engineInfo
)
{
var
engineInstance
=
_this2
.
_getEngineInstance
(
engineInfo
)
;
routeOwner
=
engineInstance
;
routeName
=
engineInfo
.
localFullName
;
}
var
fullRouteName
=
'
route
:
'
+
routeName
;
var
handler
=
routeOwner
.
lookup
(
fullRouteName
)
;
if
(
seen
[
name
]
)
{
return
handler
;
}
seen
[
name
]
=
true
;
if
(
!
handler
)
{
var
DefaultRoute
=
routeOwner
.
factoryFor
(
'
route
:
basic
'
)
.
class
;
routeOwner
.
register
(
fullRouteName
DefaultRoute
.
extend
(
)
)
;
handler
=
routeOwner
.
lookup
(
fullRouteName
)
;
if
(
true
)
{
if
(
(
0
_emberMetal
.
get
)
(
_this2
'
namespace
.
LOG_ACTIVE_GENERATION
'
)
)
{
(
0
_emberDebug
.
info
)
(
'
generated
-
>
'
+
fullRouteName
{
fullName
:
fullRouteName
}
)
;
}
}
}
handler
.
_setRouteName
(
routeName
)
;
if
(
engineInfo
&
&
!
(
0
_route
.
hasDefaultSerialize
)
(
handler
)
)
{
throw
new
Error
(
'
Defining
a
custom
serialize
method
on
an
Engine
route
is
not
supported
.
'
)
;
}
return
handler
;
}
;
}
_getSerializerFunction
:
function
(
)
{
var
_this3
=
this
;
return
function
(
name
)
{
var
engineInfo
=
_this3
.
_engineInfoByRoute
[
name
]
;
if
(
!
engineInfo
)
{
return
;
}
return
engineInfo
.
serializeMethod
|
|
_route
.
defaultSerialize
;
}
;
}
_setupRouter
:
function
(
location
)
{
var
_this4
=
this
;
var
lastURL
=
void
0
;
var
routerMicrolib
=
this
.
_routerMicrolib
;
routerMicrolib
.
getHandler
=
this
.
_getHandlerFunction
(
)
;
routerMicrolib
.
getSerializer
=
this
.
_getSerializerFunction
(
)
;
var
doUpdateURL
=
function
(
)
{
location
.
setURL
(
lastURL
)
;
(
0
_emberMetal
.
set
)
(
_this4
'
currentURL
'
lastURL
)
;
}
;
routerMicrolib
.
updateURL
=
function
(
path
)
{
lastURL
=
path
;
_emberMetal
.
run
.
once
(
doUpdateURL
)
;
}
;
if
(
location
.
replaceURL
)
{
var
doReplaceURL
=
function
(
)
{
location
.
replaceURL
(
lastURL
)
;
(
0
_emberMetal
.
set
)
(
_this4
'
currentURL
'
lastURL
)
;
}
;
routerMicrolib
.
replaceURL
=
function
(
path
)
{
lastURL
=
path
;
_emberMetal
.
run
.
once
(
doReplaceURL
)
;
}
;
}
routerMicrolib
.
didTransition
=
function
(
infos
)
{
_this4
.
didTransition
(
infos
)
;
}
;
routerMicrolib
.
willTransition
=
function
(
oldInfos
newInfos
transition
)
{
_this4
.
willTransition
(
oldInfos
newInfos
transition
)
;
}
;
}
_serializeQueryParams
:
function
(
handlerInfos
queryParams
)
{
var
_this5
=
this
;
forEachQueryParam
(
this
handlerInfos
queryParams
function
(
key
value
qp
)
{
if
(
qp
)
{
delete
queryParams
[
key
]
;
queryParams
[
qp
.
urlKey
]
=
qp
.
route
.
serializeQueryParam
(
value
qp
.
urlKey
qp
.
type
)
;
}
else
if
(
value
=
=
=
undefined
)
{
return
;
}
else
{
queryParams
[
key
]
=
_this5
.
_serializeQueryParam
(
value
(
0
_emberRuntime
.
typeOf
)
(
value
)
)
;
}
}
)
;
}
_serializeQueryParam
:
function
(
value
type
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
value
;
}
else
if
(
type
=
=
=
'
array
'
)
{
return
JSON
.
stringify
(
value
)
;
}
return
'
'
+
value
;
}
_deserializeQueryParams
:
function
(
handlerInfos
queryParams
)
{
forEachQueryParam
(
this
handlerInfos
queryParams
function
(
key
value
qp
)
{
if
(
qp
)
{
delete
queryParams
[
key
]
;
queryParams
[
qp
.
prop
]
=
qp
.
route
.
deserializeQueryParam
(
value
qp
.
urlKey
qp
.
type
)
;
}
}
)
;
}
_deserializeQueryParam
:
function
(
value
defaultType
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
value
;
}
else
if
(
defaultType
=
=
=
'
boolean
'
)
{
return
value
=
=
=
'
true
'
;
}
else
if
(
defaultType
=
=
=
'
number
'
)
{
return
Number
(
value
)
.
valueOf
(
)
;
}
else
if
(
defaultType
=
=
=
'
array
'
)
{
return
(
0
_emberRuntime
.
A
)
(
JSON
.
parse
(
value
)
)
;
}
return
value
;
}
_pruneDefaultQueryParamValues
:
function
(
handlerInfos
queryParams
)
{
var
qps
=
this
.
_queryParamsFor
(
handlerInfos
)
;
for
(
var
key
in
queryParams
)
{
var
qp
=
qps
.
map
[
key
]
;
if
(
qp
&
&
qp
.
serializedDefaultValue
=
=
=
queryParams
[
key
]
)
{
delete
queryParams
[
key
]
;
}
}
}
_doTransition
:
function
(
_targetRouteName
models
_queryParams
_keepDefaultQueryParamValues
)
{
var
_routerMicrolib5
;
var
targetRouteName
=
_targetRouteName
|
|
(
0
_utils
.
getActiveTargetName
)
(
this
.
_routerMicrolib
)
;
(
true
&
&
!
(
targetRouteName
&
&
this
.
_routerMicrolib
.
hasRoute
(
targetRouteName
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
route
'
+
targetRouteName
+
'
was
not
found
'
targetRouteName
&
&
this
.
_routerMicrolib
.
hasRoute
(
targetRouteName
)
)
)
;
var
queryParams
=
{
}
;
this
.
_processActiveTransitionQueryParams
(
targetRouteName
models
queryParams
_queryParams
)
;
(
0
_emberUtils
.
assign
)
(
queryParams
_queryParams
)
;
this
.
_prepareQueryParams
(
targetRouteName
models
queryParams
_keepDefaultQueryParamValues
)
;
var
transition
=
(
_routerMicrolib5
=
this
.
_routerMicrolib
)
.
transitionTo
.
apply
(
_routerMicrolib5
[
targetRouteName
]
.
concat
(
models
[
{
queryParams
:
queryParams
}
]
)
)
;
didBeginTransition
(
transition
this
)
;
return
transition
;
}
_processActiveTransitionQueryParams
:
function
(
targetRouteName
models
queryParams
_queryParams
)
{
if
(
!
this
.
_routerMicrolib
.
activeTransition
)
{
return
;
}
var
unchangedQPs
=
{
}
;
var
qpUpdates
=
this
.
_qpUpdates
|
|
{
}
;
var
params
=
this
.
_routerMicrolib
.
activeTransition
.
queryParams
;
for
(
var
key
in
params
)
{
if
(
!
qpUpdates
[
key
]
)
{
unchangedQPs
[
key
]
=
params
[
key
]
;
}
}
this
.
_fullyScopeQueryParams
(
targetRouteName
models
_queryParams
)
;
this
.
_fullyScopeQueryParams
(
targetRouteName
models
unchangedQPs
)
;
(
0
_emberUtils
.
assign
)
(
queryParams
unchangedQPs
)
;
}
_prepareQueryParams
:
function
(
targetRouteName
models
queryParams
_fromRouterService
)
{
var
state
=
calculatePostTransitionState
(
this
targetRouteName
models
)
;
this
.
_hydrateUnsuppliedQueryParams
(
state
queryParams
_fromRouterService
)
;
this
.
_serializeQueryParams
(
state
.
handlerInfos
queryParams
)
;
if
(
!
_fromRouterService
)
{
this
.
_pruneDefaultQueryParamValues
(
state
.
handlerInfos
queryParams
)
;
}
}
_getQPMeta
:
function
(
handlerInfo
)
{
var
route
=
handlerInfo
.
handler
;
return
route
&
&
(
0
_emberMetal
.
get
)
(
route
'
_qp
'
)
;
}
_queryParamsFor
:
function
(
handlerInfos
)
{
var
handlerInfoLength
=
handlerInfos
.
length
;
var
leafRouteName
=
handlerInfos
[
handlerInfoLength
-
1
]
.
name
;
var
cached
=
this
.
_qpCache
[
leafRouteName
]
;
if
(
cached
)
{
return
cached
;
}
var
shouldCache
=
true
;
var
qpsByUrlKey
=
{
}
;
var
map
=
{
}
;
var
qps
=
[
]
;
for
(
var
i
=
0
;
i
<
handlerInfoLength
;
+
+
i
)
{
var
qpMeta
=
this
.
_getQPMeta
(
handlerInfos
[
i
]
)
;
if
(
!
qpMeta
)
{
shouldCache
=
false
;
continue
;
}
for
(
var
_i
=
0
;
_i
<
qpMeta
.
qps
.
length
;
_i
+
+
)
{
var
qp
=
qpMeta
.
qps
[
_i
]
;
var
urlKey
=
qp
.
urlKey
;
var
qpOther
=
qpsByUrlKey
[
urlKey
]
;
if
(
qpOther
&
&
qpOther
.
controllerName
!
=
=
qp
.
controllerName
)
{
var
otherQP
=
qpsByUrlKey
[
urlKey
]
;
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
\
'
re
not
allowed
to
have
more
than
one
controller
property
map
to
the
same
query
param
key
but
both
'
+
otherQP
.
scopedPropertyName
+
'
and
'
+
qp
.
scopedPropertyName
+
'
map
to
'
+
urlKey
+
'
.
You
can
fix
this
by
mapping
one
of
the
controller
properties
to
a
different
query
param
key
via
the
as
config
option
e
.
g
.
'
+
otherQP
.
prop
+
'
:
{
as
:
\
'
other
-
'
+
otherQP
.
prop
+
'
\
'
}
'
false
)
)
;
}
qpsByUrlKey
[
urlKey
]
=
qp
;
qps
.
push
(
qp
)
;
}
(
0
_emberUtils
.
assign
)
(
map
qpMeta
.
map
)
;
}
var
finalQPMeta
=
{
qps
:
qps
map
:
map
}
;
if
(
shouldCache
)
{
this
.
_qpCache
[
leafRouteName
]
=
finalQPMeta
;
}
return
finalQPMeta
;
}
_fullyScopeQueryParams
:
function
(
leafRouteName
contexts
queryParams
)
{
var
state
=
calculatePostTransitionState
(
this
leafRouteName
contexts
)
;
var
handlerInfos
=
state
.
handlerInfos
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
qpMeta
=
this
.
_getQPMeta
(
handlerInfos
[
i
]
)
;
if
(
!
qpMeta
)
{
continue
;
}
for
(
var
j
=
0
qpLen
=
qpMeta
.
qps
.
length
;
j
<
qpLen
;
+
+
j
)
{
var
qp
=
qpMeta
.
qps
[
j
]
;
var
presentProp
=
qp
.
prop
in
queryParams
&
&
qp
.
prop
|
|
qp
.
scopedPropertyName
in
queryParams
&
&
qp
.
scopedPropertyName
|
|
qp
.
urlKey
in
queryParams
&
&
qp
.
urlKey
;
if
(
presentProp
)
{
if
(
presentProp
!
=
=
qp
.
scopedPropertyName
)
{
queryParams
[
qp
.
scopedPropertyName
]
=
queryParams
[
presentProp
]
;
delete
queryParams
[
presentProp
]
;
}
}
}
}
}
_hydrateUnsuppliedQueryParams
:
function
(
state
queryParams
_fromRouterService
)
{
var
handlerInfos
=
state
.
handlerInfos
;
var
appCache
=
this
.
_bucketCache
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
+
+
i
)
{
var
qpMeta
=
this
.
_getQPMeta
(
handlerInfos
[
i
]
)
;
if
(
!
qpMeta
)
{
continue
;
}
for
(
var
j
=
0
qpLen
=
qpMeta
.
qps
.
length
;
j
<
qpLen
;
+
+
j
)
{
var
qp
=
qpMeta
.
qps
[
j
]
;
var
presentProp
=
qp
.
prop
in
queryParams
&
&
qp
.
prop
|
|
qp
.
scopedPropertyName
in
queryParams
&
&
qp
.
scopedPropertyName
|
|
qp
.
urlKey
in
queryParams
&
&
qp
.
urlKey
;
(
true
&
&
!
(
function
(
)
{
if
(
qp
.
urlKey
=
=
=
presentProp
)
{
return
true
;
}
if
(
_fromRouterService
&
&
presentProp
!
=
=
false
)
{
return
false
;
}
return
true
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
passed
the
'
+
presentProp
+
'
query
parameter
during
a
transition
into
'
+
qp
.
route
.
routeName
+
'
please
update
to
'
+
qp
.
urlKey
function
(
)
{
if
(
qp
.
urlKey
=
=
=
presentProp
)
{
return
true
;
}
if
(
_fromRouterService
&
&
presentProp
!
=
=
false
)
{
return
false
;
}
return
true
;
}
(
)
)
)
;
if
(
presentProp
)
{
if
(
presentProp
!
=
=
qp
.
scopedPropertyName
)
{
queryParams
[
qp
.
scopedPropertyName
]
=
queryParams
[
presentProp
]
;
delete
queryParams
[
presentProp
]
;
}
}
else
{
var
cacheKey
=
(
0
_utils
.
calculateCacheKey
)
(
qp
.
route
.
fullRouteName
qp
.
parts
state
.
params
)
;
queryParams
[
qp
.
scopedPropertyName
]
=
appCache
.
lookup
(
cacheKey
qp
.
prop
qp
.
defaultValue
)
;
}
}
}
}
_scheduleLoadingEvent
:
function
(
transition
originRoute
)
{
this
.
_cancelSlowTransitionTimer
(
)
;
this
.
_slowTransitionTimer
=
_emberMetal
.
run
.
scheduleOnce
(
'
routerTransitions
'
this
'
_handleSlowTransition
'
transition
originRoute
)
;
}
currentState
:
null
targetState
:
null
_handleSlowTransition
:
function
(
transition
originRoute
)
{
if
(
!
this
.
_routerMicrolib
.
activeTransition
)
{
return
;
}
this
.
set
(
'
targetState
'
_router_state
.
default
.
create
(
{
emberRouter
:
this
routerJs
:
this
.
_routerMicrolib
routerJsState
:
this
.
_routerMicrolib
.
activeTransition
.
state
}
)
)
;
transition
.
trigger
(
true
'
loading
'
transition
originRoute
)
;
}
_cancelSlowTransitionTimer
:
function
(
)
{
if
(
this
.
_slowTransitionTimer
)
{
_emberMetal
.
run
.
cancel
(
this
.
_slowTransitionTimer
)
;
}
this
.
_slowTransitionTimer
=
null
;
}
_markErrorAsHandled
:
function
(
error
)
{
this
.
_handledErrors
.
add
(
error
)
;
}
_isErrorHandled
:
function
(
error
)
{
return
this
.
_handledErrors
.
has
(
error
)
;
}
_clearHandledError
:
function
(
error
)
{
this
.
_handledErrors
.
delete
(
error
)
;
}
_getEngineInstance
:
function
(
_ref
)
{
var
name
=
_ref
.
name
instanceId
=
_ref
.
instanceId
mountPoint
=
_ref
.
mountPoint
;
var
engineInstances
=
this
.
_engineInstances
;
if
(
!
engineInstances
[
name
]
)
{
engineInstances
[
name
]
=
Object
.
create
(
null
)
;
}
var
engineInstance
=
engineInstances
[
name
]
[
instanceId
]
;
if
(
!
engineInstance
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
(
true
&
&
!
(
owner
.
hasRegistration
(
'
engine
:
'
+
name
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
attempted
to
mount
the
engine
\
'
'
+
name
+
'
\
'
in
your
router
map
but
the
engine
can
not
be
found
.
'
owner
.
hasRegistration
(
'
engine
:
'
+
name
)
)
)
;
engineInstance
=
owner
.
buildChildEngineInstance
(
name
{
routable
:
true
mountPoint
:
mountPoint
}
)
;
engineInstance
.
boot
(
)
;
engineInstances
[
name
]
[
instanceId
]
=
engineInstance
;
}
return
engineInstance
;
}
}
)
;
function
forEachRouteAbove
(
handlerInfos
callback
)
{
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
var
route
=
handlerInfo
.
handler
;
if
(
route
=
=
=
undefined
)
{
continue
;
}
if
(
callback
(
route
handlerInfo
)
!
=
=
true
)
{
return
;
}
}
}
var
defaultActionHandlers
=
{
willResolveModel
:
function
(
handlerInfos
transition
originRoute
)
{
this
.
_scheduleLoadingEvent
(
transition
originRoute
)
;
}
error
:
function
(
handlerInfos
error
transition
)
{
var
router
=
this
;
var
handlerInfoWithError
=
handlerInfos
[
handlerInfos
.
length
-
1
]
;
forEachRouteAbove
(
handlerInfos
function
(
route
handlerInfo
)
{
if
(
handlerInfo
!
=
=
handlerInfoWithError
)
{
var
errorRouteName
=
findRouteStateName
(
route
'
error
'
)
;
if
(
errorRouteName
)
{
router
.
_markErrorAsHandled
(
error
)
;
router
.
intermediateTransitionTo
(
errorRouteName
error
)
;
return
false
;
}
}
var
errorSubstateName
=
findRouteSubstateName
(
route
'
error
'
)
;
if
(
errorSubstateName
)
{
router
.
_markErrorAsHandled
(
error
)
;
router
.
intermediateTransitionTo
(
errorSubstateName
error
)
;
return
false
;
}
return
true
;
}
)
;
logError
(
error
'
Error
while
processing
route
:
'
+
transition
.
targetName
)
;
}
loading
:
function
(
handlerInfos
transition
)
{
var
router
=
this
;
var
handlerInfoWithSlowLoading
=
handlerInfos
[
handlerInfos
.
length
-
1
]
;
forEachRouteAbove
(
handlerInfos
function
(
route
handlerInfo
)
{
if
(
handlerInfo
!
=
=
handlerInfoWithSlowLoading
)
{
var
loadingRouteName
=
findRouteStateName
(
route
'
loading
'
)
;
if
(
loadingRouteName
)
{
router
.
intermediateTransitionTo
(
loadingRouteName
)
;
return
false
;
}
}
var
loadingSubstateName
=
findRouteSubstateName
(
route
'
loading
'
)
;
if
(
loadingSubstateName
)
{
router
.
intermediateTransitionTo
(
loadingSubstateName
)
;
return
false
;
}
return
transition
.
pivotHandler
!
=
=
route
;
}
)
;
}
}
;
function
logError
(
_error
initialMessage
)
{
var
errorArgs
=
[
]
;
var
error
=
void
0
;
if
(
_error
&
&
typeof
_error
=
=
=
'
object
'
&
&
typeof
_error
.
errorThrown
=
=
=
'
object
'
)
{
error
=
_error
.
errorThrown
;
}
else
{
error
=
_error
;
}
if
(
initialMessage
)
{
errorArgs
.
push
(
initialMessage
)
;
}
if
(
error
)
{
if
(
error
.
message
)
{
errorArgs
.
push
(
error
.
message
)
;
}
if
(
error
.
stack
)
{
errorArgs
.
push
(
error
.
stack
)
;
}
if
(
typeof
error
=
=
=
'
string
'
)
{
errorArgs
.
push
(
error
)
;
}
}
_emberConsole
.
default
.
error
.
apply
(
this
errorArgs
)
;
}
function
findRouteSubstateName
(
route
state
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
route
)
;
var
routeName
=
route
.
routeName
fullRouteName
=
route
.
fullRouteName
router
=
route
.
router
;
var
substateName
=
routeName
+
'
_
'
+
state
;
var
substateNameFull
=
fullRouteName
+
'
_
'
+
state
;
return
routeHasBeenDefined
(
owner
router
substateName
substateNameFull
)
?
substateNameFull
:
'
'
;
}
function
findRouteStateName
(
route
state
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
route
)
;
var
routeName
=
route
.
routeName
fullRouteName
=
route
.
fullRouteName
router
=
route
.
router
;
var
stateName
=
routeName
=
=
=
'
application
'
?
state
:
routeName
+
'
.
'
+
state
;
var
stateNameFull
=
fullRouteName
=
=
=
'
application
'
?
state
:
fullRouteName
+
'
.
'
+
state
;
return
routeHasBeenDefined
(
owner
router
stateName
stateNameFull
)
?
stateNameFull
:
'
'
;
}
function
routeHasBeenDefined
(
owner
router
localName
fullName
)
{
var
routerHasRoute
=
router
.
hasRoute
(
fullName
)
;
var
ownerHasRoute
=
owner
.
hasRegistration
(
'
template
:
'
+
localName
)
|
|
owner
.
hasRegistration
(
'
route
:
'
+
localName
)
;
return
routerHasRoute
&
&
ownerHasRoute
;
}
function
triggerEvent
(
handlerInfos
ignoreFailure
args
)
{
var
name
=
args
.
shift
(
)
;
if
(
!
handlerInfos
)
{
if
(
ignoreFailure
)
{
return
;
}
throw
new
_emberDebug
.
Error
(
'
Can
\
'
t
trigger
action
\
'
'
+
name
+
'
\
'
because
your
app
hasn
\
'
t
finished
transitioning
into
its
first
route
.
To
trigger
an
action
on
destination
routes
during
a
transition
you
can
call
.
send
(
)
on
the
Transition
object
passed
to
the
model
/
beforeModel
/
afterModel
hooks
.
'
)
;
}
var
eventWasHandled
=
false
;
var
handlerInfo
=
void
0
handler
=
void
0
actionHandler
=
void
0
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
handlerInfo
=
handlerInfos
[
i
]
;
handler
=
handlerInfo
.
handler
;
actionHandler
=
handler
&
&
handler
.
actions
&
&
handler
.
actions
[
name
]
;
if
(
actionHandler
)
{
if
(
actionHandler
.
apply
(
handler
args
)
=
=
=
true
)
{
eventWasHandled
=
true
;
}
else
{
if
(
name
=
=
=
'
error
'
)
{
handler
.
router
.
_markErrorAsHandled
(
args
[
0
]
)
;
}
return
;
}
}
}
var
defaultHandler
=
defaultActionHandlers
[
name
]
;
if
(
defaultHandler
)
{
defaultHandler
.
apply
(
this
[
handlerInfos
]
.
concat
(
args
)
)
;
return
;
}
if
(
!
eventWasHandled
&
&
!
ignoreFailure
)
{
throw
new
_emberDebug
.
Error
(
'
Nothing
handled
the
action
\
'
'
+
name
+
'
\
'
.
If
you
did
handle
the
action
this
error
can
be
caused
by
returning
true
from
an
action
handler
in
a
controller
causing
the
action
to
bubble
.
'
)
;
}
}
function
calculatePostTransitionState
(
emberRouter
leafRouteName
contexts
)
{
var
state
=
emberRouter
.
_routerMicrolib
.
applyIntent
(
leafRouteName
contexts
)
;
var
handlerInfos
=
state
.
handlerInfos
params
=
state
.
params
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
if
(
!
handlerInfo
.
isResolved
)
{
params
[
handlerInfo
.
name
]
=
handlerInfo
.
serialize
(
handlerInfo
.
context
)
;
}
else
{
params
[
handlerInfo
.
name
]
=
handlerInfo
.
params
;
}
}
return
state
;
}
function
updatePaths
(
router
)
{
var
infos
=
router
.
_routerMicrolib
.
currentHandlerInfos
;
if
(
infos
.
length
=
=
=
0
)
{
return
;
}
var
path
=
EmberRouter
.
_routePath
(
infos
)
;
var
currentRouteName
=
infos
[
infos
.
length
-
1
]
.
name
;
var
currentURL
=
router
.
get
(
'
location
'
)
.
getURL
(
)
;
(
0
_emberMetal
.
set
)
(
router
'
currentPath
'
path
)
;
(
0
_emberMetal
.
set
)
(
router
'
currentRouteName
'
currentRouteName
)
;
(
0
_emberMetal
.
set
)
(
router
'
currentURL
'
currentURL
)
;
var
appController
=
(
0
_emberUtils
.
getOwner
)
(
router
)
.
lookup
(
'
controller
:
application
'
)
;
if
(
!
appController
)
{
return
;
}
if
(
!
(
'
currentPath
'
in
appController
)
)
{
(
0
_emberMetal
.
defineProperty
)
(
appController
'
currentPath
'
)
;
}
(
0
_emberMetal
.
set
)
(
appController
'
currentPath
'
path
)
;
if
(
!
(
'
currentRouteName
'
in
appController
)
)
{
(
0
_emberMetal
.
defineProperty
)
(
appController
'
currentRouteName
'
)
;
}
(
0
_emberMetal
.
set
)
(
appController
'
currentRouteName
'
currentRouteName
)
;
}
EmberRouter
.
reopenClass
(
{
map
:
function
(
callback
)
{
if
(
!
this
.
dslCallbacks
)
{
this
.
dslCallbacks
=
[
]
;
this
.
reopenClass
(
{
dslCallbacks
:
this
.
dslCallbacks
}
)
;
}
this
.
dslCallbacks
.
push
(
callback
)
;
return
this
;
}
_routePath
:
function
(
handlerInfos
)
{
var
path
=
[
]
;
function
intersectionMatches
(
a1
a2
)
{
for
(
var
i
=
0
;
i
<
a1
.
length
;
+
+
i
)
{
if
(
a1
[
i
]
!
=
=
a2
[
i
]
)
{
return
false
;
}
}
return
true
;
}
var
name
=
void
0
nameParts
=
void
0
oldNameParts
=
void
0
;
for
(
var
i
=
1
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
name
=
handlerInfos
[
i
]
.
name
;
nameParts
=
name
.
split
(
'
.
'
)
;
oldNameParts
=
slice
.
call
(
path
)
;
while
(
oldNameParts
.
length
)
{
if
(
intersectionMatches
(
oldNameParts
nameParts
)
)
{
break
;
}
oldNameParts
.
shift
(
)
;
}
path
.
push
.
apply
(
path
nameParts
.
slice
(
oldNameParts
.
length
)
)
;
}
return
path
.
join
(
'
.
'
)
;
}
}
)
;
function
didBeginTransition
(
transition
router
)
{
var
routerState
=
_router_state
.
default
.
create
(
{
emberRouter
:
router
routerJs
:
router
.
_routerMicrolib
routerJsState
:
transition
.
state
}
)
;
if
(
!
router
.
currentState
)
{
router
.
set
(
'
currentState
'
routerState
)
;
}
router
.
set
(
'
targetState
'
routerState
)
;
transition
.
promise
=
transition
.
catch
(
function
(
error
)
{
if
(
router
.
_isErrorHandled
(
error
)
)
{
router
.
_clearHandledError
(
error
)
;
}
else
{
throw
error
;
}
}
)
;
}
function
forEachQueryParam
(
router
handlerInfos
queryParams
callback
)
{
var
qpCache
=
router
.
_queryParamsFor
(
handlerInfos
)
;
for
(
var
key
in
queryParams
)
{
if
(
!
queryParams
.
hasOwnProperty
(
key
)
)
{
continue
;
}
var
value
=
queryParams
[
key
]
;
var
qp
=
qpCache
.
map
[
key
]
;
callback
(
key
value
qp
)
;
}
}
function
findLiveRoute
(
liveRoutes
name
)
{
if
(
!
liveRoutes
)
{
return
;
}
var
stack
=
[
liveRoutes
]
;
while
(
stack
.
length
>
0
)
{
var
test
=
stack
.
shift
(
)
;
if
(
test
.
render
.
name
=
=
=
name
)
{
return
test
;
}
var
outlets
=
test
.
outlets
;
for
(
var
outletName
in
outlets
)
{
stack
.
push
(
outlets
[
outletName
]
)
;
}
}
}
function
appendLiveRoute
(
liveRoutes
defaultParentState
renderOptions
)
{
var
target
=
void
0
;
var
myState
=
{
render
:
renderOptions
outlets
:
Object
.
create
(
null
)
wasUsed
:
false
}
;
if
(
renderOptions
.
into
)
{
target
=
findLiveRoute
(
liveRoutes
renderOptions
.
into
)
;
}
else
{
target
=
defaultParentState
;
}
if
(
target
)
{
(
0
_emberMetal
.
set
)
(
target
.
outlets
renderOptions
.
outlet
myState
)
;
}
else
{
if
(
renderOptions
.
into
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
Rendering
into
a
{
{
render
}
}
helper
that
resolves
to
an
{
{
outlet
}
}
is
deprecated
.
'
false
{
id
:
'
ember
-
routing
.
top
-
level
-
render
-
helper
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_rendering
-
into
-
a
-
render
-
helper
-
that
-
resolves
-
to
-
an
-
outlet
'
}
)
)
;
appendOrphan
(
liveRoutes
renderOptions
.
into
myState
)
;
}
else
{
liveRoutes
=
myState
;
}
}
return
{
liveRoutes
:
liveRoutes
ownState
:
myState
}
;
}
function
appendOrphan
(
liveRoutes
into
myState
)
{
if
(
!
liveRoutes
.
outlets
.
__ember_orphans__
)
{
liveRoutes
.
outlets
.
__ember_orphans__
=
{
render
:
{
name
:
'
__ember_orphans__
'
}
outlets
:
Object
.
create
(
null
)
}
;
}
liveRoutes
.
outlets
.
__ember_orphans__
.
outlets
[
into
]
=
myState
;
_emberMetal
.
run
.
schedule
(
'
afterRender
'
function
(
)
{
(
true
&
&
!
(
liveRoutes
.
outlets
.
__ember_orphans__
.
outlets
[
into
]
.
wasUsed
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
attempted
to
render
into
\
'
'
+
into
+
'
\
'
but
it
was
not
found
'
liveRoutes
.
outlets
.
__ember_orphans__
.
outlets
[
into
]
.
wasUsed
)
)
;
}
)
;
}
function
representEmptyRoute
(
liveRoutes
defaultParentState
route
)
{
var
alreadyAppended
=
findLiveRoute
(
liveRoutes
route
.
routeName
)
;
if
(
alreadyAppended
)
{
return
alreadyAppended
;
}
else
{
defaultParentState
.
outlets
.
main
=
{
render
:
{
name
:
route
.
routeName
outlet
:
'
main
'
}
outlets
:
{
}
}
;
return
defaultParentState
;
}
}
exports
.
default
=
EmberRouter
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
router_state
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
routing
/
utils
'
'
ember
-
runtime
'
]
function
(
exports
_emberUtils
_utils
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
emberRouter
:
null
routerJs
:
null
routerJsState
:
null
isActiveIntent
:
function
(
routeName
models
queryParams
queryParamsMustMatch
)
{
var
state
=
this
.
routerJsState
;
if
(
!
this
.
routerJs
.
isActiveIntent
(
routeName
models
null
state
)
)
{
return
false
;
}
if
(
queryParamsMustMatch
&
&
Object
.
keys
(
queryParams
)
.
length
>
0
)
{
var
visibleQueryParams
=
(
0
_emberUtils
.
assign
)
(
{
}
queryParams
)
;
this
.
emberRouter
.
_prepareQueryParams
(
routeName
models
visibleQueryParams
)
;
return
(
0
_utils
.
shallowEqual
)
(
visibleQueryParams
state
.
queryParams
)
;
}
return
true
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
utils
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
extractRouteArgs
=
extractRouteArgs
;
exports
.
getActiveTargetName
=
getActiveTargetName
;
exports
.
stashParamNames
=
stashParamNames
;
exports
.
calculateCacheKey
=
calculateCacheKey
;
exports
.
normalizeControllerQueryParams
=
normalizeControllerQueryParams
;
exports
.
resemblesURL
=
resemblesURL
;
exports
.
prefixRouteNameArg
=
prefixRouteNameArg
;
exports
.
shallowEqual
=
shallowEqual
;
var
ALL_PERIODS_REGEX
=
/
\
.
/
g
;
function
extractRouteArgs
(
args
)
{
args
=
args
.
slice
(
)
;
var
possibleQueryParams
=
args
[
args
.
length
-
1
]
;
var
queryParams
=
void
0
;
if
(
possibleQueryParams
&
&
possibleQueryParams
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
args
.
pop
(
)
.
queryParams
;
}
else
{
queryParams
=
{
}
;
}
var
routeName
=
args
.
shift
(
)
;
return
{
routeName
:
routeName
models
:
args
queryParams
:
queryParams
}
;
}
function
getActiveTargetName
(
router
)
{
var
handlerInfos
=
router
.
activeTransition
?
router
.
activeTransition
.
state
.
handlerInfos
:
router
.
state
.
handlerInfos
;
return
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
;
}
function
stashParamNames
(
router
handlerInfos
)
{
if
(
handlerInfos
.
_namesStashed
)
{
return
;
}
var
targetRouteName
=
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
;
var
recogHandlers
=
router
.
_routerMicrolib
.
recognizer
.
handlersFor
(
targetRouteName
)
;
var
dynamicParent
=
null
;
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
var
names
=
recogHandlers
[
i
]
.
names
;
if
(
names
.
length
)
{
dynamicParent
=
handlerInfo
;
}
handlerInfo
.
_names
=
names
;
var
route
=
handlerInfo
.
handler
;
route
.
_stashNames
(
handlerInfo
dynamicParent
)
;
}
handlerInfos
.
_namesStashed
=
true
;
}
function
_calculateCacheValuePrefix
(
prefix
part
)
{
var
prefixParts
=
prefix
.
split
(
'
.
'
)
;
var
currPrefix
=
'
'
;
for
(
var
i
=
0
;
i
<
prefixParts
.
length
;
i
+
+
)
{
var
currPart
=
prefixParts
.
slice
(
0
i
+
1
)
.
join
(
'
.
'
)
;
if
(
part
.
indexOf
(
currPart
)
!
=
=
0
)
{
break
;
}
currPrefix
=
currPart
;
}
return
currPrefix
;
}
function
calculateCacheKey
(
prefix
)
{
var
parts
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
[
]
;
var
values
=
arguments
[
2
]
;
var
suffixes
=
'
'
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
+
+
i
)
{
var
part
=
parts
[
i
]
;
var
cacheValuePrefix
=
_calculateCacheValuePrefix
(
prefix
part
)
;
var
value
=
void
0
;
if
(
values
)
{
if
(
cacheValuePrefix
&
&
cacheValuePrefix
in
values
)
{
var
partRemovedPrefix
=
part
.
indexOf
(
cacheValuePrefix
)
=
=
=
0
?
part
.
substr
(
cacheValuePrefix
.
length
+
1
)
:
part
;
value
=
(
0
_emberMetal
.
get
)
(
values
[
cacheValuePrefix
]
partRemovedPrefix
)
;
}
else
{
value
=
(
0
_emberMetal
.
get
)
(
values
part
)
;
}
}
suffixes
+
=
'
:
:
'
+
part
+
'
:
'
+
value
;
}
return
prefix
+
suffixes
.
replace
(
ALL_PERIODS_REGEX
'
-
'
)
;
}
function
normalizeControllerQueryParams
(
queryParams
)
{
var
qpMap
=
{
}
;
for
(
var
i
=
0
;
i
<
queryParams
.
length
;
+
+
i
)
{
accumulateQueryParamDescriptors
(
queryParams
[
i
]
qpMap
)
;
}
return
qpMap
;
}
function
accumulateQueryParamDescriptors
(
_desc
accum
)
{
var
desc
=
_desc
;
var
tmp
=
void
0
;
if
(
typeof
desc
=
=
=
'
string
'
)
{
tmp
=
{
}
;
tmp
[
desc
]
=
{
as
:
null
}
;
desc
=
tmp
;
}
for
(
var
key
in
desc
)
{
if
(
!
desc
.
hasOwnProperty
(
key
)
)
{
return
;
}
var
singleDesc
=
desc
[
key
]
;
if
(
typeof
singleDesc
=
=
=
'
string
'
)
{
singleDesc
=
{
as
:
singleDesc
}
;
}
tmp
=
accum
[
key
]
|
|
{
as
:
null
scope
:
'
model
'
}
;
(
0
_emberUtils
.
assign
)
(
tmp
singleDesc
)
;
accum
[
key
]
=
tmp
;
}
}
function
resemblesURL
(
str
)
{
return
typeof
str
=
=
=
'
string
'
&
&
(
str
=
=
=
'
'
|
|
str
[
0
]
=
=
=
'
/
'
)
;
}
function
prefixRouteNameArg
(
route
args
)
{
var
routeName
=
args
[
0
]
;
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
route
)
;
var
prefix
=
owner
.
mountPoint
;
if
(
owner
.
routable
&
&
typeof
routeName
=
=
=
'
string
'
)
{
if
(
resemblesURL
(
routeName
)
)
{
throw
new
_emberDebug
.
Error
(
'
Programmatic
transitions
by
URL
cannot
be
used
within
an
Engine
.
Please
use
the
route
name
instead
.
'
)
;
}
else
{
routeName
=
prefix
+
'
.
'
+
routeName
;
args
[
0
]
=
routeName
;
}
}
return
args
;
}
function
shallowEqual
(
a
b
)
{
var
k
=
void
0
;
var
aCount
=
0
;
var
bCount
=
0
;
for
(
k
in
a
)
{
if
(
a
.
hasOwnProperty
(
k
)
)
{
if
(
a
[
k
]
!
=
=
b
[
k
]
)
{
return
false
;
}
aCount
+
+
;
}
}
for
(
k
in
b
)
{
if
(
b
.
hasOwnProperty
(
k
)
)
{
bCount
+
+
;
}
}
return
aCount
=
=
=
bCount
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
compare
'
[
'
exports
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
mixins
/
comparable
'
]
function
(
exports
_utils
_comparable
)
{
'
use
strict
'
;
exports
.
default
=
compare
;
var
TYPE_ORDER
=
{
'
undefined
'
:
0
'
null
'
:
1
'
boolean
'
:
2
'
number
'
:
3
'
string
'
:
4
'
array
'
:
5
'
object
'
:
6
'
instance
'
:
7
'
function
'
:
8
'
class
'
:
9
'
date
'
:
10
}
;
function
spaceship
(
a
b
)
{
var
diff
=
a
-
b
;
return
(
diff
>
0
)
-
(
diff
<
0
)
;
}
function
compare
(
v
w
)
{
if
(
v
=
=
=
w
)
{
return
0
;
}
var
type1
=
(
0
_utils
.
typeOf
)
(
v
)
;
var
type2
=
(
0
_utils
.
typeOf
)
(
w
)
;
if
(
_comparable
.
default
)
{
if
(
type1
=
=
=
'
instance
'
&
&
_comparable
.
default
.
detect
(
v
)
&
&
v
.
constructor
.
compare
)
{
return
v
.
constructor
.
compare
(
v
w
)
;
}
if
(
type2
=
=
=
'
instance
'
&
&
_comparable
.
default
.
detect
(
w
)
&
&
w
.
constructor
.
compare
)
{
return
w
.
constructor
.
compare
(
w
v
)
*
-
1
;
}
}
var
res
=
spaceship
(
TYPE_ORDER
[
type1
]
TYPE_ORDER
[
type2
]
)
;
if
(
res
!
=
=
0
)
{
return
res
;
}
switch
(
type1
)
{
case
'
boolean
'
:
case
'
number
'
:
return
spaceship
(
v
w
)
;
case
'
string
'
:
return
spaceship
(
v
.
localeCompare
(
w
)
0
)
;
case
'
array
'
:
{
var
vLen
=
v
.
length
;
var
wLen
=
w
.
length
;
var
len
=
Math
.
min
(
vLen
wLen
)
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
r
=
compare
(
v
[
i
]
w
[
i
]
)
;
if
(
r
!
=
=
0
)
{
return
r
;
}
}
return
spaceship
(
vLen
wLen
)
;
}
case
'
instance
'
:
if
(
_comparable
.
default
&
&
_comparable
.
default
.
detect
(
v
)
)
{
return
v
.
compare
(
v
w
)
;
}
return
0
;
case
'
date
'
:
return
spaceship
(
v
.
getTime
(
)
w
.
getTime
(
)
)
;
default
:
return
0
;
}
}
}
)
;
enifed
(
'
ember
-
runtime
/
computed
/
computed_macros
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
or
=
exports
.
and
=
undefined
;
exports
.
empty
=
empty
;
exports
.
notEmpty
=
notEmpty
;
exports
.
none
=
none
;
exports
.
not
=
not
;
exports
.
bool
=
bool
;
exports
.
match
=
match
;
exports
.
equal
=
equal
;
exports
.
gt
=
gt
;
exports
.
gte
=
gte
;
exports
.
lt
=
lt
;
exports
.
lte
=
lte
;
exports
.
oneWay
=
oneWay
;
exports
.
readOnly
=
readOnly
;
exports
.
deprecatingAlias
=
deprecatingAlias
;
function
expandPropertiesToArray
(
predicateName
properties
)
{
var
expandedProperties
=
[
]
;
function
extractProperty
(
entry
)
{
expandedProperties
.
push
(
entry
)
;
}
for
(
var
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
var
property
=
properties
[
i
]
;
(
true
&
&
!
(
property
.
indexOf
(
'
'
)
<
0
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
keys
passed
to
computed
.
'
+
predicateName
+
'
(
)
can
\
'
t
have
spaces
.
'
property
.
indexOf
(
'
'
)
<
0
)
)
;
(
0
_emberMetal
.
expandProperties
)
(
property
extractProperty
)
;
}
return
expandedProperties
;
}
function
generateComputedWithPredicate
(
name
predicate
)
{
return
function
(
)
{
for
(
var
_len
=
arguments
.
length
properties
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
properties
[
_key
]
=
arguments
[
_key
]
;
}
var
dependentKeys
=
expandPropertiesToArray
(
name
properties
)
;
var
computedFunc
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
var
lastIdx
=
dependentKeys
.
length
-
1
;
for
(
var
i
=
0
;
i
<
lastIdx
;
i
+
+
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
this
dependentKeys
[
i
]
)
;
if
(
!
predicate
(
value
)
)
{
return
value
;
}
}
return
(
0
_emberMetal
.
get
)
(
this
dependentKeys
[
lastIdx
]
)
;
}
{
dependentKeys
:
dependentKeys
}
)
;
return
computedFunc
;
}
;
}
function
empty
(
dependentKey
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
+
'
.
length
'
function
(
)
{
return
(
0
_emberMetal
.
isEmpty
)
(
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
)
;
}
)
;
}
function
notEmpty
(
dependentKey
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
+
'
.
length
'
function
(
)
{
return
!
(
0
_emberMetal
.
isEmpty
)
(
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
)
;
}
)
;
}
function
none
(
dependentKey
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
isNone
)
(
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
)
;
}
)
;
}
function
not
(
dependentKey
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
!
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
}
)
;
}
function
bool
(
dependentKey
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
!
!
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
}
)
;
}
function
match
(
dependentKey
regexp
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
return
regexp
.
test
(
value
)
;
}
)
;
}
function
equal
(
dependentKey
value
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
=
=
=
value
;
}
)
;
}
function
gt
(
dependentKey
value
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
>
value
;
}
)
;
}
function
gte
(
dependentKey
value
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
>
=
value
;
}
)
;
}
function
lt
(
dependentKey
value
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
<
value
;
}
)
;
}
function
lte
(
dependentKey
value
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
function
(
)
{
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
<
=
value
;
}
)
;
}
var
and
=
exports
.
and
=
generateComputedWithPredicate
(
'
and
'
function
(
value
)
{
return
value
;
}
)
;
var
or
=
exports
.
or
=
generateComputedWithPredicate
(
'
or
'
function
(
value
)
{
return
!
value
;
}
)
;
function
oneWay
(
dependentKey
)
{
return
(
0
_emberMetal
.
alias
)
(
dependentKey
)
.
oneWay
(
)
;
}
function
readOnly
(
dependentKey
)
{
return
(
0
_emberMetal
.
alias
)
(
dependentKey
)
.
readOnly
(
)
;
}
function
deprecatingAlias
(
dependentKey
options
)
{
return
(
0
_emberMetal
.
computed
)
(
dependentKey
{
get
:
function
(
key
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
Usage
of
'
+
key
+
'
is
deprecated
use
'
+
dependentKey
+
'
instead
.
'
false
options
)
)
;
return
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
}
set
:
function
(
key
value
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
Usage
of
'
+
key
+
'
is
deprecated
use
'
+
dependentKey
+
'
instead
.
'
false
options
)
)
;
(
0
_emberMetal
.
set
)
(
this
dependentKey
value
)
;
return
value
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
computed
/
reduce_computed_macros
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
/
compare
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
system
/
native_array
'
]
function
(
exports
_emberDebug
_emberMetal
_compare
_utils
_native_array
)
{
'
use
strict
'
;
exports
.
union
=
undefined
;
exports
.
sum
=
sum
;
exports
.
max
=
max
;
exports
.
min
=
min
;
exports
.
map
=
map
;
exports
.
mapBy
=
mapBy
;
exports
.
filter
=
filter
;
exports
.
filterBy
=
filterBy
;
exports
.
uniq
=
uniq
;
exports
.
uniqBy
=
uniqBy
;
exports
.
intersect
=
intersect
;
exports
.
setDiff
=
setDiff
;
exports
.
collect
=
collect
;
exports
.
sort
=
sort
;
function
reduceMacro
(
dependentKey
callback
initialValue
name
)
{
(
true
&
&
!
(
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
key
passed
to
computed
.
'
+
name
+
'
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
)
;
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
var
arr
=
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
if
(
arr
=
=
=
null
|
|
typeof
arr
!
=
=
'
object
'
)
{
return
initialValue
;
}
return
arr
.
reduce
(
callback
initialValue
this
)
;
}
{
dependentKeys
:
[
dependentKey
+
'
.
[
]
'
]
readOnly
:
true
}
)
;
return
cp
;
}
function
arrayMacro
(
dependentKey
callback
)
{
var
propertyName
=
void
0
;
if
(
/
each
/
.
test
(
dependentKey
)
)
{
propertyName
=
dependentKey
.
replace
(
/
\
.
each
.
*
/
'
'
)
;
}
else
{
propertyName
=
dependentKey
;
dependentKey
+
=
'
.
[
]
'
;
}
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
this
propertyName
)
;
if
(
(
0
_utils
.
isArray
)
(
value
)
)
{
return
(
0
_native_array
.
A
)
(
callback
.
call
(
this
value
)
)
;
}
else
{
return
(
0
_native_array
.
A
)
(
)
;
}
}
{
readOnly
:
true
}
)
;
cp
.
property
(
dependentKey
)
;
return
cp
;
}
function
multiArrayMacro
(
_dependentKeys
callback
name
)
{
(
true
&
&
!
(
_dependentKeys
.
every
(
function
(
dependentKey
)
{
return
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
;
}
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
keys
passed
to
computed
.
'
+
name
+
'
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
_dependentKeys
.
every
(
function
(
dependentKey
)
{
return
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
;
}
)
)
)
;
var
dependentKeys
=
_dependentKeys
.
map
(
function
(
key
)
{
return
key
+
'
.
[
]
'
;
}
)
;
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
return
(
0
_native_array
.
A
)
(
callback
.
call
(
this
_dependentKeys
)
)
;
}
{
dependentKeys
:
dependentKeys
readOnly
:
true
}
)
;
return
cp
;
}
function
sum
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
sum
item
)
{
return
sum
+
item
;
}
0
'
sum
'
)
;
}
function
max
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
max
item
)
{
return
Math
.
max
(
max
item
)
;
}
-
Infinity
'
max
'
)
;
}
function
min
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
min
item
)
{
return
Math
.
min
(
min
item
)
;
}
Infinity
'
min
'
)
;
}
function
map
(
dependentKey
callback
)
{
return
arrayMacro
(
dependentKey
function
(
value
)
{
return
value
.
map
(
callback
this
)
;
}
)
;
}
function
mapBy
(
dependentKey
propertyKey
)
{
(
true
&
&
!
(
typeof
propertyKey
=
=
=
'
string
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
\
computed
.
mapBy
\
expects
a
property
string
for
its
second
argument
'
+
'
perhaps
you
meant
to
use
"
map
"
'
typeof
propertyKey
=
=
=
'
string
'
)
)
;
(
true
&
&
!
(
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
key
passed
to
computed
.
mapBy
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
)
;
return
map
(
dependentKey
+
'
.
each
.
'
+
propertyKey
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
propertyKey
)
;
}
)
;
}
function
filter
(
dependentKey
callback
)
{
return
arrayMacro
(
dependentKey
function
(
value
)
{
return
value
.
filter
(
callback
this
)
;
}
)
;
}
function
filterBy
(
dependentKey
propertyKey
value
)
{
(
true
&
&
!
(
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
key
passed
to
computed
.
filterBy
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
)
;
var
callback
=
void
0
;
if
(
arguments
.
length
=
=
=
2
)
{
callback
=
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
propertyKey
)
;
}
;
}
else
{
callback
=
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
propertyKey
)
=
=
=
value
;
}
;
}
return
filter
(
dependentKey
+
'
.
each
.
'
+
propertyKey
callback
)
;
}
function
uniq
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
multiArrayMacro
(
args
function
(
dependentKeys
)
{
var
_this
=
this
;
var
uniq
=
(
0
_native_array
.
A
)
(
)
;
var
seen
=
new
Set
(
)
;
dependentKeys
.
forEach
(
function
(
dependentKey
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
_this
dependentKey
)
;
if
(
(
0
_utils
.
isArray
)
(
value
)
)
{
value
.
forEach
(
function
(
item
)
{
if
(
!
seen
.
has
(
item
)
)
{
seen
.
add
(
item
)
;
uniq
.
push
(
item
)
;
}
}
)
;
}
}
)
;
return
uniq
;
}
'
uniq
'
)
;
}
function
uniqBy
(
dependentKey
propertyKey
)
{
(
true
&
&
!
(
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
key
passed
to
computed
.
uniqBy
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
dependentKey
)
)
)
;
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
var
uniq
=
(
0
_native_array
.
A
)
(
)
;
var
list
=
(
0
_emberMetal
.
get
)
(
this
dependentKey
)
;
if
(
(
0
_utils
.
isArray
)
(
list
)
)
{
var
seen
=
new
Set
(
)
;
list
.
forEach
(
function
(
item
)
{
var
val
=
(
0
_emberMetal
.
get
)
(
item
propertyKey
)
;
if
(
!
seen
.
has
(
val
)
)
{
seen
.
add
(
val
)
;
uniq
.
push
(
item
)
;
}
}
)
;
}
return
uniq
;
}
{
dependentKeys
:
[
dependentKey
+
'
.
[
]
'
]
readOnly
:
true
}
)
;
return
cp
;
}
var
union
=
exports
.
union
=
uniq
;
function
intersect
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
multiArrayMacro
(
args
function
(
dependentKeys
)
{
var
_this2
=
this
;
var
arrays
=
dependentKeys
.
map
(
function
(
dependentKey
)
{
var
array
=
(
0
_emberMetal
.
get
)
(
_this2
dependentKey
)
;
return
(
0
_utils
.
isArray
)
(
array
)
?
array
:
[
]
;
}
)
;
var
results
=
arrays
.
pop
(
)
.
filter
(
function
(
candidate
)
{
for
(
var
i
=
0
;
i
<
arrays
.
length
;
i
+
+
)
{
var
found
=
false
;
var
array
=
arrays
[
i
]
;
for
(
var
j
=
0
;
j
<
array
.
length
;
j
+
+
)
{
if
(
array
[
j
]
=
=
=
candidate
)
{
found
=
true
;
break
;
}
}
if
(
found
=
=
=
false
)
{
return
false
;
}
}
return
true
;
}
'
intersect
'
)
;
return
(
0
_native_array
.
A
)
(
results
)
;
}
)
;
}
function
setDiff
(
setAProperty
setBProperty
)
{
(
true
&
&
!
(
arguments
.
length
=
=
=
2
)
&
&
(
0
_emberDebug
.
assert
)
(
'
\
computed
.
setDiff
\
requires
exactly
two
dependent
arrays
.
'
arguments
.
length
=
=
=
2
)
)
;
(
true
&
&
!
(
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
setAProperty
)
&
&
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
setBProperty
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Dependent
keys
passed
to
computed
.
setDiff
shouldn
\
'
t
contain
brace
expanding
pattern
.
'
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
setAProperty
)
&
&
!
/
[
\
[
\
]
\
{
\
}
]
/
g
.
test
(
setBProperty
)
)
)
;
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
)
{
var
setA
=
this
.
get
(
setAProperty
)
;
var
setB
=
this
.
get
(
setBProperty
)
;
if
(
!
(
0
_utils
.
isArray
)
(
setA
)
)
{
return
(
0
_native_array
.
A
)
(
)
;
}
if
(
!
(
0
_utils
.
isArray
)
(
setB
)
)
{
return
(
0
_native_array
.
A
)
(
setA
)
;
}
return
setA
.
filter
(
function
(
x
)
{
return
setB
.
indexOf
(
x
)
=
=
=
-
1
;
}
)
;
}
{
dependentKeys
:
[
setAProperty
+
'
.
[
]
'
setBProperty
+
'
.
[
]
'
]
readOnly
:
true
}
)
;
return
cp
;
}
function
collect
(
)
{
for
(
var
_len3
=
arguments
.
length
dependentKeys
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
dependentKeys
[
_key3
]
=
arguments
[
_key3
]
;
}
return
multiArrayMacro
(
dependentKeys
function
(
)
{
var
properties
=
(
0
_emberMetal
.
getProperties
)
(
this
dependentKeys
)
;
var
res
=
(
0
_native_array
.
A
)
(
)
;
for
(
var
key
in
properties
)
{
if
(
properties
.
hasOwnProperty
(
key
)
)
{
if
(
properties
[
key
]
=
=
=
undefined
)
{
res
.
push
(
null
)
;
}
else
{
res
.
push
(
properties
[
key
]
)
;
}
}
}
return
res
;
}
'
collect
'
)
;
}
function
sort
(
itemsKey
sortDefinition
)
{
(
true
&
&
!
(
arguments
.
length
=
=
=
2
)
&
&
(
0
_emberDebug
.
assert
)
(
'
\
computed
.
sort
\
requires
two
arguments
:
an
array
key
to
sort
and
'
+
'
either
a
sort
properties
key
or
sort
function
'
arguments
.
length
=
=
=
2
)
)
;
if
(
typeof
sortDefinition
=
=
=
'
function
'
)
{
return
customSort
(
itemsKey
sortDefinition
)
;
}
else
{
return
propertySort
(
itemsKey
sortDefinition
)
;
}
}
function
customSort
(
itemsKey
comparator
)
{
return
arrayMacro
(
itemsKey
function
(
value
)
{
var
_this3
=
this
;
return
value
.
slice
(
)
.
sort
(
function
(
x
y
)
{
return
comparator
.
call
(
_this3
x
y
)
;
}
)
;
}
)
;
}
function
propertySort
(
itemsKey
sortPropertiesKey
)
{
var
cp
=
new
_emberMetal
.
ComputedProperty
(
function
(
key
)
{
var
_this4
=
this
;
var
sortProperties
=
(
0
_emberMetal
.
get
)
(
this
sortPropertiesKey
)
;
(
true
&
&
!
(
(
0
_utils
.
isArray
)
(
sortProperties
)
&
&
sortProperties
.
every
(
function
(
s
)
{
return
typeof
s
=
=
=
'
string
'
;
}
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
sort
definition
for
\
'
'
+
key
+
'
\
'
on
'
+
this
+
'
must
be
a
function
or
an
array
of
strings
'
(
0
_utils
.
isArray
)
(
sortProperties
)
&
&
sortProperties
.
every
(
function
(
s
)
{
return
typeof
s
=
=
=
'
string
'
;
}
)
)
)
;
var
activeObserversMap
=
cp
.
_activeObserverMap
|
|
(
cp
.
_activeObserverMap
=
new
WeakMap
(
)
)
;
var
activeObservers
=
activeObserversMap
.
get
(
this
)
;
if
(
activeObservers
!
=
=
undefined
)
{
activeObservers
.
forEach
(
function
(
args
)
{
return
_emberMetal
.
removeObserver
.
apply
(
undefined
args
)
;
}
)
;
}
function
sortPropertyDidChange
(
)
{
this
.
notifyPropertyChange
(
key
)
;
}
var
itemsKeyIsAtThis
=
itemsKey
=
=
=
'
this
'
;
var
normalizedSortProperties
=
normalizeSortProperties
(
sortProperties
)
;
activeObservers
=
normalizedSortProperties
.
map
(
function
(
_ref
)
{
var
prop
=
_ref
[
0
]
;
var
path
=
itemsKeyIsAtThis
?
'
each
.
'
+
prop
:
itemsKey
+
'
.
each
.
'
+
prop
;
(
0
_emberMetal
.
addObserver
)
(
_this4
path
sortPropertyDidChange
)
;
return
[
_this4
path
sortPropertyDidChange
]
;
}
)
;
activeObserversMap
.
set
(
this
activeObservers
)
;
var
items
=
itemsKeyIsAtThis
?
this
:
(
0
_emberMetal
.
get
)
(
this
itemsKey
)
;
if
(
!
(
0
_utils
.
isArray
)
(
items
)
)
{
return
(
0
_native_array
.
A
)
(
)
;
}
return
sortByNormalizedSortProperties
(
items
normalizedSortProperties
)
;
}
{
dependentKeys
:
[
sortPropertiesKey
+
'
.
[
]
'
]
readOnly
:
true
}
)
;
cp
.
_activeObserverMap
=
undefined
;
return
cp
;
}
function
normalizeSortProperties
(
sortProperties
)
{
return
sortProperties
.
map
(
function
(
p
)
{
var
_p
split
=
p
.
split
(
'
:
'
)
prop
=
_p
split
[
0
]
direction
=
_p
split
[
1
]
;
direction
=
direction
|
|
'
asc
'
;
return
[
prop
direction
]
;
}
)
;
}
function
sortByNormalizedSortProperties
(
items
normalizedSortProperties
)
{
return
(
0
_native_array
.
A
)
(
items
.
slice
(
)
.
sort
(
function
(
itemA
itemB
)
{
for
(
var
i
=
0
;
i
<
normalizedSortProperties
.
length
;
i
+
+
)
{
var
_normalizedSortProper
=
normalizedSortProperties
[
i
]
prop
=
_normalizedSortProper
[
0
]
direction
=
_normalizedSortProper
[
1
]
;
var
result
=
(
0
_compare
.
default
)
(
(
0
_emberMetal
.
get
)
(
itemA
prop
)
(
0
_emberMetal
.
get
)
(
itemB
prop
)
)
;
if
(
result
!
=
=
0
)
{
return
direction
=
=
=
'
desc
'
?
-
1
*
result
:
result
;
}
}
return
0
;
}
)
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
controllers
/
controller
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
controller
'
'
ember
-
runtime
/
inject
'
]
function
(
exports
_emberDebug
_object
_controller
_inject
)
{
'
use
strict
'
;
var
Controller
=
_object
.
default
.
extend
(
_controller
.
default
)
;
function
controllerInjectionHelper
(
factory
)
{
(
true
&
&
!
(
_controller
.
default
.
detect
(
factory
.
PrototypeMixin
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Defining
an
injected
controller
property
on
a
'
+
'
non
-
controller
is
not
allowed
.
'
_controller
.
default
.
detect
(
factory
.
PrototypeMixin
)
)
)
;
}
(
0
_inject
.
createInjectionHelper
)
(
'
controller
'
controllerInjectionHelper
)
;
exports
.
default
=
Controller
;
}
)
;
enifed
(
'
ember
-
runtime
/
copy
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
copyable
'
]
function
(
exports
_emberDebug
_object
_copyable
)
{
'
use
strict
'
;
exports
.
default
=
copy
;
function
_copy
(
obj
deep
seen
copies
)
{
var
ret
=
void
0
loc
=
void
0
key
=
void
0
;
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
obj
;
}
if
(
deep
&
&
(
loc
=
seen
.
indexOf
(
obj
)
)
>
=
0
)
{
return
copies
[
loc
]
;
}
(
true
&
&
!
(
!
(
obj
instanceof
_object
.
default
)
|
|
_copyable
.
default
&
&
_copyable
.
default
.
detect
(
obj
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
clone
an
EmberObject
that
does
not
implement
Copyable
'
!
(
obj
instanceof
_object
.
default
)
|
|
_copyable
.
default
&
&
_copyable
.
default
.
detect
(
obj
)
)
)
;
if
(
Array
.
isArray
(
obj
)
)
{
ret
=
obj
.
slice
(
)
;
if
(
deep
)
{
loc
=
ret
.
length
;
while
(
-
-
loc
>
=
0
)
{
ret
[
loc
]
=
_copy
(
ret
[
loc
]
deep
seen
copies
)
;
}
}
}
else
if
(
_copyable
.
default
&
&
_copyable
.
default
.
detect
(
obj
)
)
{
ret
=
obj
.
copy
(
deep
seen
copies
)
;
}
else
if
(
obj
instanceof
Date
)
{
ret
=
new
Date
(
obj
.
getTime
(
)
)
;
}
else
{
ret
=
{
}
;
for
(
key
in
obj
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
continue
;
}
if
(
key
.
substring
(
0
2
)
=
=
=
'
__
'
)
{
continue
;
}
ret
[
key
]
=
deep
?
_copy
(
obj
[
key
]
deep
seen
copies
)
:
obj
[
key
]
;
}
}
if
(
deep
)
{
seen
.
push
(
obj
)
;
copies
.
push
(
ret
)
;
}
return
ret
;
}
function
copy
(
obj
deep
)
{
if
(
'
object
'
!
=
=
typeof
obj
|
|
obj
=
=
=
null
)
{
return
obj
;
}
if
(
_copyable
.
default
&
&
_copyable
.
default
.
detect
(
obj
)
)
{
return
obj
.
copy
(
deep
)
;
}
return
_copy
(
obj
deep
deep
?
[
]
:
null
deep
?
[
]
:
null
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
function
'
[
'
ember
-
environment
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
_emberEnvironment
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
var
FunctionPrototype
=
Function
.
prototype
;
if
(
_emberEnvironment
.
ENV
.
EXTEND_PROTOTYPES
.
Function
)
{
Object
.
defineProperty
(
FunctionPrototype
'
property
'
{
configurable
:
true
enumerable
:
false
writable
:
true
value
:
function
(
)
{
return
_emberMetal
.
computed
.
apply
(
undefined
Array
.
prototype
.
slice
.
call
(
arguments
)
.
concat
(
[
this
]
)
)
;
}
}
)
;
Object
.
defineProperty
(
FunctionPrototype
'
observes
'
{
configurable
:
true
enumerable
:
false
writable
:
true
value
:
function
(
)
{
return
_emberMetal
.
observer
.
apply
(
undefined
Array
.
prototype
.
slice
.
call
(
arguments
)
.
concat
(
[
this
]
)
)
;
}
}
)
;
Object
.
defineProperty
(
FunctionPrototype
'
_observesImmediately
'
{
configurable
:
true
enumerable
:
false
writable
:
true
value
:
function
(
)
{
(
true
&
&
!
(
function
checkIsInternalProperty
(
)
{
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
if
(
arguments
[
i
]
.
indexOf
(
'
.
'
)
!
=
=
-
1
)
{
return
false
;
}
}
return
true
;
}
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Immediate
observers
must
observe
internal
properties
only
'
+
'
not
properties
on
other
objects
.
'
function
checkIsInternalProperty
(
)
{
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
if
(
arguments
[
i
]
.
indexOf
(
'
.
'
)
!
=
=
-
1
)
{
return
false
;
}
}
return
true
;
}
)
)
;
return
this
.
observes
.
apply
(
this
arguments
)
;
}
}
)
;
Object
.
defineProperty
(
FunctionPrototype
'
on
'
{
configurable
:
true
enumerable
:
false
writable
:
true
value
:
function
(
)
{
return
_emberMetal
.
on
.
apply
(
undefined
Array
.
prototype
.
slice
.
call
(
arguments
)
.
concat
(
[
this
]
)
)
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
rsvp
'
[
'
exports
'
'
rsvp
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_rsvp
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
onerrorDefault
=
onerrorDefault
;
var
backburner
=
_emberMetal
.
run
.
backburner
;
_emberMetal
.
run
.
_addQueue
(
'
rsvpAfter
'
'
destroy
'
)
;
_rsvp
.
configure
(
'
async
'
function
(
callback
promise
)
{
backburner
.
schedule
(
'
actions
'
null
callback
promise
)
;
}
)
;
_rsvp
.
configure
(
'
after
'
function
(
cb
)
{
backburner
.
schedule
(
'
rsvpAfter
'
null
cb
)
;
}
)
;
_rsvp
.
on
(
'
error
'
onerrorDefault
)
;
function
onerrorDefault
(
reason
)
{
var
error
=
errorFor
(
reason
)
;
if
(
error
)
{
var
overrideDispatch
=
(
0
_emberMetal
.
getDispatchOverride
)
(
)
;
if
(
overrideDispatch
)
{
overrideDispatch
(
error
)
;
}
else
{
throw
error
;
}
}
}
function
errorFor
(
reason
)
{
if
(
!
reason
)
return
;
if
(
reason
.
errorThrown
)
{
return
unwrapErrorThrown
(
reason
)
;
}
if
(
reason
.
name
=
=
=
'
UnrecognizedURLError
'
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
URL
\
'
'
+
reason
.
message
+
'
\
'
did
not
match
any
routes
in
your
application
'
false
)
)
;
return
;
}
if
(
reason
.
name
=
=
=
'
TransitionAborted
'
)
{
return
;
}
return
reason
;
}
function
unwrapErrorThrown
(
reason
)
{
var
error
=
reason
.
errorThrown
;
if
(
typeof
error
=
=
=
'
string
'
)
{
error
=
new
Error
(
error
)
;
}
Object
.
defineProperty
(
error
'
__reason_with_error_thrown__
'
{
value
:
reason
enumerable
:
false
}
)
;
return
error
;
}
exports
.
default
=
_rsvp
;
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
string
'
[
'
ember
-
environment
'
'
ember
-
runtime
/
system
/
string
'
]
function
(
_emberEnvironment
_string
)
{
'
use
strict
'
;
var
StringPrototype
=
String
.
prototype
;
if
(
_emberEnvironment
.
ENV
.
EXTEND_PROTOTYPES
.
String
)
{
Object
.
defineProperty
(
StringPrototype
'
w
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
w
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
loc
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
(
0
_string
.
loc
)
(
this
args
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
camelize
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
camelize
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
decamelize
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
decamelize
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
dasherize
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
dasherize
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
underscore
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
underscore
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
classify
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
classify
)
(
this
)
;
}
}
)
;
Object
.
defineProperty
(
StringPrototype
'
capitalize
'
{
configurable
:
true
enumerable
:
false
writeable
:
true
value
:
function
(
)
{
return
(
0
_string
.
capitalize
)
(
this
)
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
index
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
ember
-
runtime
/
mixins
/
container_proxy
'
'
ember
-
runtime
/
copy
'
'
ember
-
runtime
/
inject
'
'
ember
-
runtime
/
compare
'
'
ember
-
runtime
/
is
-
equal
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
mixins
/
comparable
'
'
ember
-
runtime
/
system
/
namespace
'
'
ember
-
runtime
/
system
/
array_proxy
'
'
ember
-
runtime
/
system
/
object_proxy
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
runtime
/
mixins
/
copyable
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
runtime
/
mixins
/
-
proxy
'
'
ember
-
runtime
/
system
/
lazy_load
'
'
ember
-
runtime
/
mixins
/
observable
'
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
target_action_support
'
'
ember
-
runtime
/
mixins
/
evented
'
'
ember
-
runtime
/
mixins
/
promise_proxy
'
'
ember
-
runtime
/
computed
/
computed_macros
'
'
ember
-
runtime
/
computed
/
reduce_computed_macros
'
'
ember
-
runtime
/
controllers
/
controller
'
'
ember
-
runtime
/
mixins
/
controller
'
'
ember
-
runtime
/
system
/
service
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
string_registry
'
'
ember
-
runtime
/
ext
/
string
'
'
ember
-
runtime
/
ext
/
function
'
]
function
(
exports
_object
_string
_registry_proxy
_container_proxy
_copy
_inject
_compare
_isEqual
_array
_comparable
_namespace
_array_proxy
_object_proxy
_core_object
_native_array
_action_handler
_copyable
_enumerable
_proxy
_lazy_load
_observable
_mutable_enumerable
_mutable_array
_target_action_support
_evented
_promise_proxy
_computed_macros
_reduce_computed_macros
_controller
_controller2
_service
_rsvp
_utils
_string_registry
)
{
'
use
strict
'
;
exports
.
setStrings
=
exports
.
getStrings
=
exports
.
typeOf
=
exports
.
isArray
=
exports
.
onerrorDefault
=
exports
.
RSVP
=
exports
.
Service
=
exports
.
ControllerMixin
=
exports
.
Controller
=
exports
.
collect
=
exports
.
intersect
=
exports
.
union
=
exports
.
uniqBy
=
exports
.
uniq
=
exports
.
filterBy
=
exports
.
filter
=
exports
.
mapBy
=
exports
.
setDiff
=
exports
.
sort
=
exports
.
map
=
exports
.
max
=
exports
.
min
=
exports
.
sum
=
exports
.
or
=
exports
.
and
=
exports
.
deprecatingAlias
=
exports
.
readOnly
=
exports
.
oneWay
=
exports
.
lte
=
exports
.
lt
=
exports
.
gte
=
exports
.
gt
=
exports
.
equal
=
exports
.
match
=
exports
.
bool
=
exports
.
not
=
exports
.
none
=
exports
.
notEmpty
=
exports
.
empty
=
exports
.
PromiseProxyMixin
=
exports
.
Evented
=
exports
.
TargetActionSupport
=
exports
.
removeAt
=
exports
.
MutableArray
=
exports
.
MutableEnumerable
=
exports
.
Observable
=
exports
.
_loaded
=
exports
.
runLoadHooks
=
exports
.
onLoad
=
exports
.
_ProxyMixin
=
exports
.
Enumerable
=
exports
.
Copyable
=
exports
.
ActionHandler
=
exports
.
A
=
exports
.
NativeArray
=
exports
.
CoreObject
=
exports
.
ObjectProxy
=
exports
.
ArrayProxy
=
exports
.
setNamespaceSearchDisabled
=
exports
.
isNamespaceSearchDisabled
=
exports
.
Namespace
=
exports
.
Comparable
=
exports
.
removeArrayObserver
=
exports
.
addArrayObserver
=
exports
.
isEmberArray
=
exports
.
objectAt
=
exports
.
Array
=
exports
.
isEqual
=
exports
.
compare
=
exports
.
inject
=
exports
.
copy
=
exports
.
ContainerProxyMixin
=
exports
.
RegistryProxyMixin
=
exports
.
String
=
exports
.
FrameworkObject
=
exports
.
Object
=
undefined
;
Object
.
defineProperty
(
exports
'
Object
'
{
enumerable
:
true
get
:
function
(
)
{
return
_object
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
FrameworkObject
'
{
enumerable
:
true
get
:
function
(
)
{
return
_object
.
FrameworkObject
;
}
}
)
;
Object
.
defineProperty
(
exports
'
String
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RegistryProxyMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_registry_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ContainerProxyMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_container_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
copy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_copy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
inject
'
{
enumerable
:
true
get
:
function
(
)
{
return
_inject
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
compare
'
{
enumerable
:
true
get
:
function
(
)
{
return
_compare
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isEqual
'
{
enumerable
:
true
get
:
function
(
)
{
return
_isEqual
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Array
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
objectAt
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array
.
objectAt
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isEmberArray
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array
.
isEmberArray
;
}
}
)
;
Object
.
defineProperty
(
exports
'
addArrayObserver
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array
.
addArrayObserver
;
}
}
)
;
Object
.
defineProperty
(
exports
'
removeArrayObserver
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array
.
removeArrayObserver
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Comparable
'
{
enumerable
:
true
get
:
function
(
)
{
return
_comparable
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Namespace
'
{
enumerable
:
true
get
:
function
(
)
{
return
_namespace
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isNamespaceSearchDisabled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_namespace
.
isSearchDisabled
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setNamespaceSearchDisabled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_namespace
.
setSearchDisabled
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ArrayProxy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_array_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ObjectProxy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_object_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
CoreObject
'
{
enumerable
:
true
get
:
function
(
)
{
return
_core_object
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
NativeArray
'
{
enumerable
:
true
get
:
function
(
)
{
return
_native_array
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
A
'
{
enumerable
:
true
get
:
function
(
)
{
return
_native_array
.
A
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ActionHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_action_handler
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Copyable
'
{
enumerable
:
true
get
:
function
(
)
{
return
_copyable
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Enumerable
'
{
enumerable
:
true
get
:
function
(
)
{
return
_enumerable
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_ProxyMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
onLoad
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lazy_load
.
onLoad
;
}
}
)
;
Object
.
defineProperty
(
exports
'
runLoadHooks
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lazy_load
.
runLoadHooks
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_loaded
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lazy_load
.
_loaded
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Observable
'
{
enumerable
:
true
get
:
function
(
)
{
return
_observable
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
MutableEnumerable
'
{
enumerable
:
true
get
:
function
(
)
{
return
_mutable_enumerable
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
MutableArray
'
{
enumerable
:
true
get
:
function
(
)
{
return
_mutable_array
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
removeAt
'
{
enumerable
:
true
get
:
function
(
)
{
return
_mutable_array
.
removeAt
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TargetActionSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_target_action_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Evented
'
{
enumerable
:
true
get
:
function
(
)
{
return
_evented
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
PromiseProxyMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_promise_proxy
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
empty
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
empty
;
}
}
)
;
Object
.
defineProperty
(
exports
'
notEmpty
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
notEmpty
;
}
}
)
;
Object
.
defineProperty
(
exports
'
none
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
none
;
}
}
)
;
Object
.
defineProperty
(
exports
'
not
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
not
;
}
}
)
;
Object
.
defineProperty
(
exports
'
bool
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
bool
;
}
}
)
;
Object
.
defineProperty
(
exports
'
match
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
match
;
}
}
)
;
Object
.
defineProperty
(
exports
'
equal
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
equal
;
}
}
)
;
Object
.
defineProperty
(
exports
'
gt
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
gt
;
}
}
)
;
Object
.
defineProperty
(
exports
'
gte
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
gte
;
}
}
)
;
Object
.
defineProperty
(
exports
'
lt
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
lt
;
}
}
)
;
Object
.
defineProperty
(
exports
'
lte
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
lte
;
}
}
)
;
Object
.
defineProperty
(
exports
'
oneWay
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
oneWay
;
}
}
)
;
Object
.
defineProperty
(
exports
'
readOnly
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
readOnly
;
}
}
)
;
Object
.
defineProperty
(
exports
'
deprecatingAlias
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
deprecatingAlias
;
}
}
)
;
Object
.
defineProperty
(
exports
'
and
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
and
;
}
}
)
;
Object
.
defineProperty
(
exports
'
or
'
{
enumerable
:
true
get
:
function
(
)
{
return
_computed_macros
.
or
;
}
}
)
;
Object
.
defineProperty
(
exports
'
sum
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
sum
;
}
}
)
;
Object
.
defineProperty
(
exports
'
min
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
min
;
}
}
)
;
Object
.
defineProperty
(
exports
'
max
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
max
;
}
}
)
;
Object
.
defineProperty
(
exports
'
map
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
map
;
}
}
)
;
Object
.
defineProperty
(
exports
'
sort
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
sort
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setDiff
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
setDiff
;
}
}
)
;
Object
.
defineProperty
(
exports
'
mapBy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
mapBy
;
}
}
)
;
Object
.
defineProperty
(
exports
'
filter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
filter
;
}
}
)
;
Object
.
defineProperty
(
exports
'
filterBy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
filterBy
;
}
}
)
;
Object
.
defineProperty
(
exports
'
uniq
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
uniq
;
}
}
)
;
Object
.
defineProperty
(
exports
'
uniqBy
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
uniqBy
;
}
}
)
;
Object
.
defineProperty
(
exports
'
union
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
union
;
}
}
)
;
Object
.
defineProperty
(
exports
'
intersect
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
intersect
;
}
}
)
;
Object
.
defineProperty
(
exports
'
collect
'
{
enumerable
:
true
get
:
function
(
)
{
return
_reduce_computed_macros
.
collect
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Controller
'
{
enumerable
:
true
get
:
function
(
)
{
return
_controller
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ControllerMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_controller2
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Service
'
{
enumerable
:
true
get
:
function
(
)
{
return
_service
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
RSVP
'
{
enumerable
:
true
get
:
function
(
)
{
return
_rsvp
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
onerrorDefault
'
{
enumerable
:
true
get
:
function
(
)
{
return
_rsvp
.
onerrorDefault
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isArray
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
isArray
;
}
}
)
;
Object
.
defineProperty
(
exports
'
typeOf
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
typeOf
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getStrings
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string_registry
.
getStrings
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setStrings
'
{
enumerable
:
true
get
:
function
(
)
{
return
_string_registry
.
setStrings
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
inject
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
inject
;
exports
.
createInjectionHelper
=
createInjectionHelper
;
exports
.
validatePropertyInjections
=
validatePropertyInjections
;
function
inject
(
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Injected
properties
must
be
created
through
helpers
see
\
'
'
+
Object
.
keys
(
inject
)
.
map
(
function
(
k
)
{
return
'
\
'
inject
.
'
+
k
+
'
\
'
'
;
}
)
.
join
(
'
or
'
)
+
'
\
'
'
)
)
;
}
var
typeValidators
=
{
}
;
function
createInjectionHelper
(
type
validator
)
{
typeValidators
[
type
]
=
validator
;
inject
[
type
]
=
function
(
name
)
{
return
new
_emberMetal
.
InjectedProperty
(
type
name
)
;
}
;
}
function
validatePropertyInjections
(
factory
)
{
var
proto
=
factory
.
proto
(
)
;
var
types
=
[
]
;
for
(
var
key
in
proto
)
{
var
desc
=
(
0
_emberMetal
.
descriptorFor
)
(
proto
key
)
;
if
(
desc
instanceof
_emberMetal
.
InjectedProperty
&
&
types
.
indexOf
(
desc
.
type
)
=
=
=
-
1
)
{
types
.
push
(
desc
.
type
)
;
}
}
if
(
types
.
length
)
{
for
(
var
i
=
0
;
i
<
types
.
length
;
i
+
+
)
{
var
validator
=
typeValidators
[
types
[
i
]
]
;
if
(
typeof
validator
=
=
=
'
function
'
)
{
validator
(
factory
)
;
}
}
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
is
-
equal
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
isEqual
;
function
isEqual
(
a
b
)
{
if
(
a
&
&
typeof
a
.
isEqual
=
=
=
'
function
'
)
{
return
a
.
isEqual
(
b
)
;
}
if
(
a
instanceof
Date
&
&
b
instanceof
Date
)
{
return
a
.
getTime
(
)
=
=
=
b
.
getTime
(
)
;
}
return
a
=
=
=
b
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
-
proxy
'
[
'
exports
'
'
ember
-
babel
'
'
glimmer
/
reference
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
/
computed
/
computed_macros
'
]
function
(
exports
_emberBabel
_reference
_emberMetal
_emberDebug
_computed_macros
)
{
'
use
strict
'
;
function
contentPropertyWillChange
(
content
contentKey
)
{
var
key
=
contentKey
.
slice
(
8
)
;
if
(
key
in
this
)
{
return
;
}
(
0
_emberMetal
.
propertyWillChange
)
(
this
key
)
;
}
function
contentPropertyDidChange
(
content
contentKey
)
{
var
key
=
contentKey
.
slice
(
8
)
;
if
(
key
in
this
)
{
return
;
}
(
0
_emberMetal
.
propertyDidChange
)
(
this
key
)
;
}
var
ProxyTag
=
function
(
_CachedTag
)
{
(
0
_emberBabel
.
inherits
)
(
ProxyTag
_CachedTag
)
;
function
ProxyTag
(
proxy
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ProxyTag
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_CachedTag
.
call
(
this
)
)
;
var
content
=
(
0
_emberMetal
.
get
)
(
proxy
'
content
'
)
;
_this
.
proxy
=
proxy
;
_this
.
proxyWrapperTag
=
new
_reference
.
DirtyableTag
(
)
;
_this
.
proxyContentTag
=
new
_reference
.
UpdatableTag
(
(
0
_emberMetal
.
tagFor
)
(
content
)
)
;
return
_this
;
}
ProxyTag
.
prototype
.
compute
=
function
compute
(
)
{
return
Math
.
max
(
this
.
proxyWrapperTag
.
value
(
)
this
.
proxyContentTag
.
value
(
)
)
;
}
;
ProxyTag
.
prototype
.
dirty
=
function
dirty
(
)
{
this
.
proxyWrapperTag
.
dirty
(
)
;
}
;
ProxyTag
.
prototype
.
contentDidChange
=
function
contentDidChange
(
)
{
var
content
=
(
0
_emberMetal
.
get
)
(
this
.
proxy
'
content
'
)
;
this
.
proxyContentTag
.
update
(
(
0
_emberMetal
.
tagFor
)
(
content
)
)
;
}
;
return
ProxyTag
;
}
(
_reference
.
CachedTag
)
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
content
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
m
=
(
0
_emberMetal
.
meta
)
(
this
)
;
m
.
setProxy
(
)
;
m
.
writableTag
(
function
(
source
)
{
return
new
ProxyTag
(
source
)
;
}
)
;
}
isTruthy
:
(
0
_computed_macros
.
bool
)
(
'
content
'
)
willWatchProperty
:
function
(
key
)
{
var
contentKey
=
'
content
.
'
+
key
;
(
0
_emberMetal
.
_addBeforeObserver
)
(
this
contentKey
null
contentPropertyWillChange
)
;
(
0
_emberMetal
.
addObserver
)
(
this
contentKey
null
contentPropertyDidChange
)
;
}
didUnwatchProperty
:
function
(
key
)
{
var
contentKey
=
'
content
.
'
+
key
;
(
0
_emberMetal
.
_removeBeforeObserver
)
(
this
contentKey
null
contentPropertyWillChange
)
;
(
0
_emberMetal
.
removeObserver
)
(
this
contentKey
null
contentPropertyDidChange
)
;
}
unknownProperty
:
function
(
key
)
{
var
content
=
(
0
_emberMetal
.
get
)
(
this
'
content
'
)
;
if
(
content
)
{
return
(
0
_emberMetal
.
get
)
(
content
key
)
;
}
}
setUnknownProperty
:
function
(
key
value
)
{
var
m
=
(
0
_emberMetal
.
meta
)
(
this
)
;
if
(
m
.
proto
=
=
=
this
)
{
(
0
_emberMetal
.
defineProperty
)
(
this
key
null
value
)
;
return
value
;
}
var
content
=
(
0
_emberMetal
.
get
)
(
this
'
content
'
)
;
(
true
&
&
!
(
content
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Cannot
delegate
set
(
\
'
'
+
key
+
'
\
'
'
+
value
+
'
)
to
the
\
'
content
\
'
property
of
object
proxy
'
+
this
+
'
:
its
\
'
content
\
'
is
undefined
.
'
content
)
)
;
return
(
0
_emberMetal
.
set
)
(
content
key
value
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
action_handler
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
var
ActionHandler
=
_emberMetal
.
Mixin
.
create
(
{
mergedProperties
:
[
'
actions
'
]
send
:
function
(
actionName
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
this
.
actions
&
&
this
.
actions
[
actionName
]
)
{
var
shouldBubble
=
this
.
actions
[
actionName
]
.
apply
(
this
args
)
=
=
=
true
;
if
(
!
shouldBubble
)
{
return
;
}
}
var
target
=
(
0
_emberMetal
.
get
)
(
this
'
target
'
)
;
if
(
target
)
{
(
true
&
&
!
(
typeof
target
.
send
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
target
for
'
+
this
+
'
(
'
+
target
+
'
)
does
not
have
a
send
method
'
typeof
target
.
send
=
=
=
'
function
'
)
)
;
target
.
send
.
apply
(
target
arguments
)
;
}
}
}
)
;
exports
.
default
=
ActionHandler
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
array
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
runtime
/
compare
'
'
require
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_enumerable
_compare
_require2
)
{
'
use
strict
'
;
exports
.
addArrayObserver
=
addArrayObserver
;
exports
.
removeArrayObserver
=
removeArrayObserver
;
exports
.
objectAt
=
objectAt
;
exports
.
arrayContentWillChange
=
arrayContentWillChange
;
exports
.
arrayContentDidChange
=
arrayContentDidChange
;
exports
.
isEmberArray
=
isEmberArray
;
var
_Mixin
create
;
var
_A
=
void
0
;
function
A
(
)
{
if
(
_A
=
=
=
undefined
)
{
_A
=
(
0
_require2
.
default
)
(
'
ember
-
runtime
/
system
/
native_array
'
)
.
A
;
}
return
_A
(
)
;
}
function
arrayObserversHelper
(
obj
target
opts
operation
notify
)
{
var
willChange
=
opts
&
&
opts
.
willChange
|
|
'
arrayWillChange
'
;
var
didChange
=
opts
&
&
opts
.
didChange
|
|
'
arrayDidChange
'
;
var
hasObservers
=
(
0
_emberMetal
.
get
)
(
obj
'
hasArrayObservers
'
)
;
if
(
hasObservers
=
=
=
notify
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
obj
'
hasArrayObservers
'
)
;
}
operation
(
obj
'
array
:
before
'
target
willChange
)
;
operation
(
obj
'
array
:
change
'
target
didChange
)
;
if
(
hasObservers
=
=
=
notify
)
{
(
0
_emberMetal
.
propertyDidChange
)
(
obj
'
hasArrayObservers
'
)
;
}
return
obj
;
}
function
addArrayObserver
(
array
target
opts
)
{
return
arrayObserversHelper
(
array
target
opts
_emberMetal
.
addListener
false
)
;
}
function
removeArrayObserver
(
array
target
opts
)
{
return
arrayObserversHelper
(
array
target
opts
_emberMetal
.
removeListener
true
)
;
}
function
objectAt
(
content
idx
)
{
return
typeof
content
.
objectAt
=
=
=
'
function
'
?
content
.
objectAt
(
idx
)
:
content
[
idx
]
;
}
function
arrayContentWillChange
(
array
startIdx
removeAmt
addAmt
)
{
if
(
startIdx
=
=
=
undefined
)
{
startIdx
=
0
;
removeAmt
=
addAmt
=
-
1
;
}
else
{
if
(
removeAmt
=
=
=
undefined
)
{
removeAmt
=
-
1
;
}
if
(
addAmt
=
=
=
undefined
)
{
addAmt
=
-
1
;
}
}
if
(
array
.
__each
)
{
array
.
__each
.
arrayWillChange
(
array
startIdx
removeAmt
addAmt
)
;
}
(
0
_emberMetal
.
sendEvent
)
(
array
'
array
:
before
'
[
array
startIdx
removeAmt
addAmt
]
)
;
(
0
_emberMetal
.
propertyWillChange
)
(
array
'
[
]
'
)
;
if
(
addAmt
<
0
|
|
removeAmt
<
0
|
|
addAmt
-
removeAmt
!
=
=
0
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
array
'
length
'
)
;
}
return
array
;
}
function
arrayContentDidChange
(
array
startIdx
removeAmt
addAmt
)
{
if
(
startIdx
=
=
=
undefined
)
{
startIdx
=
0
;
removeAmt
=
addAmt
=
-
1
;
}
else
{
if
(
removeAmt
=
=
=
undefined
)
{
removeAmt
=
-
1
;
}
if
(
addAmt
=
=
=
undefined
)
{
addAmt
=
-
1
;
}
}
if
(
addAmt
<
0
|
|
removeAmt
<
0
|
|
addAmt
-
removeAmt
!
=
=
0
)
{
(
0
_emberMetal
.
propertyDidChange
)
(
array
'
length
'
)
;
}
(
0
_emberMetal
.
propertyDidChange
)
(
array
'
[
]
'
)
;
if
(
array
.
__each
)
{
array
.
__each
.
arrayDidChange
(
array
startIdx
removeAmt
addAmt
)
;
}
(
0
_emberMetal
.
sendEvent
)
(
array
'
array
:
change
'
[
array
startIdx
removeAmt
addAmt
]
)
;
var
meta
=
(
0
_emberMetal
.
peekMeta
)
(
array
)
;
var
cache
=
meta
!
=
=
undefined
?
meta
.
readableCache
(
)
:
undefined
;
if
(
cache
!
=
=
undefined
)
{
var
length
=
(
0
_emberMetal
.
get
)
(
array
'
length
'
)
;
var
addedAmount
=
addAmt
=
=
=
-
1
?
0
:
addAmt
;
var
removedAmount
=
removeAmt
=
=
=
-
1
?
0
:
removeAmt
;
var
delta
=
addedAmount
-
removedAmount
;
var
previousLength
=
length
-
delta
;
var
normalStartIdx
=
startIdx
<
0
?
previousLength
+
startIdx
:
startIdx
;
if
(
cache
.
firstObject
!
=
=
undefined
&
&
normalStartIdx
=
=
=
0
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
array
'
firstObject
'
meta
)
;
(
0
_emberMetal
.
propertyDidChange
)
(
array
'
firstObject
'
meta
)
;
}
if
(
cache
.
lastObject
!
=
=
undefined
)
{
var
previousLastIndex
=
previousLength
-
1
;
var
lastAffectedIndex
=
normalStartIdx
+
removedAmount
;
if
(
previousLastIndex
<
lastAffectedIndex
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
array
'
lastObject
'
meta
)
;
(
0
_emberMetal
.
propertyDidChange
)
(
array
'
lastObject
'
meta
)
;
}
}
}
return
array
;
}
var
EMBER_ARRAY
=
(
0
_emberUtils
.
symbol
)
(
'
EMBER_ARRAY
'
)
;
function
isEmberArray
(
obj
)
{
return
obj
&
&
obj
[
EMBER_ARRAY
]
;
}
function
iter
(
key
value
)
{
var
valueProvided
=
arguments
.
length
=
=
=
2
;
return
valueProvided
?
function
(
item
)
{
return
value
=
=
=
(
0
_emberMetal
.
get
)
(
item
key
)
;
}
:
function
(
item
)
{
return
!
!
(
0
_emberMetal
.
get
)
(
item
key
)
;
}
;
}
var
ArrayMixin
=
_emberMetal
.
Mixin
.
create
(
_enumerable
.
default
(
_Mixin
create
=
{
}
_Mixin
create
[
EMBER_ARRAY
]
=
true
_Mixin
create
.
length
=
null
_Mixin
create
.
objectAt
=
function
(
idx
)
{
if
(
idx
<
0
|
|
idx
>
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
)
{
return
undefined
;
}
return
(
0
_emberMetal
.
get
)
(
this
idx
)
;
}
_Mixin
create
.
objectsAt
=
function
(
indexes
)
{
var
_this
=
this
;
return
indexes
.
map
(
function
(
idx
)
{
return
objectAt
(
_this
idx
)
;
}
)
;
}
_Mixin
create
[
'
[
]
'
]
=
(
0
_emberMetal
.
computed
)
(
{
get
:
function
(
key
)
{
return
this
;
}
set
:
function
(
key
value
)
{
this
.
replace
(
0
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
value
)
;
return
this
;
}
}
)
_Mixin
create
.
firstObject
=
(
0
_emberMetal
.
computed
)
(
function
(
)
{
return
objectAt
(
this
0
)
;
}
)
.
readOnly
(
)
_Mixin
create
.
lastObject
=
(
0
_emberMetal
.
computed
)
(
function
(
)
{
return
objectAt
(
this
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
-
1
)
;
}
)
.
readOnly
(
)
_Mixin
create
.
slice
=
function
(
beginIndex
endIndex
)
{
var
ret
=
A
(
)
;
var
length
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
(
0
_emberMetal
.
isNone
)
(
beginIndex
)
)
{
beginIndex
=
0
;
}
else
if
(
beginIndex
<
0
)
{
beginIndex
=
length
+
beginIndex
;
}
if
(
(
0
_emberMetal
.
isNone
)
(
endIndex
)
|
|
endIndex
>
length
)
{
endIndex
=
length
;
}
else
if
(
endIndex
<
0
)
{
endIndex
=
length
+
endIndex
;
}
while
(
beginIndex
<
endIndex
)
{
ret
[
ret
.
length
]
=
objectAt
(
this
beginIndex
+
+
)
;
}
return
ret
;
}
_Mixin
create
.
indexOf
=
function
(
object
startAt
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
startAt
=
=
=
undefined
)
{
startAt
=
0
;
}
if
(
startAt
<
0
)
{
startAt
+
=
len
;
}
for
(
var
idx
=
startAt
;
idx
<
len
;
idx
+
+
)
{
if
(
objectAt
(
this
idx
)
=
=
=
object
)
{
return
idx
;
}
}
return
-
1
;
}
_Mixin
create
.
lastIndexOf
=
function
(
object
startAt
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
startAt
=
=
=
undefined
|
|
startAt
>
=
len
)
{
startAt
=
len
-
1
;
}
if
(
startAt
<
0
)
{
startAt
+
=
len
;
}
for
(
var
idx
=
startAt
;
idx
>
=
0
;
idx
-
-
)
{
if
(
objectAt
(
this
idx
)
=
=
=
object
)
{
return
idx
;
}
}
return
-
1
;
}
_Mixin
create
.
addArrayObserver
=
function
(
target
opts
)
{
return
addArrayObserver
(
this
target
opts
)
;
}
_Mixin
create
.
removeArrayObserver
=
function
(
target
opts
)
{
return
removeArrayObserver
(
this
target
opts
)
;
}
_Mixin
create
.
hasArrayObservers
=
(
0
_emberMetal
.
computed
)
(
function
(
)
{
return
(
0
_emberMetal
.
hasListeners
)
(
this
'
array
:
change
'
)
|
|
(
0
_emberMetal
.
hasListeners
)
(
this
'
array
:
before
'
)
;
}
)
_Mixin
create
.
arrayContentWillChange
=
function
(
startIdx
removeAmt
addAmt
)
{
return
arrayContentWillChange
(
this
startIdx
removeAmt
addAmt
)
;
}
_Mixin
create
.
arrayContentDidChange
=
function
(
startIdx
removeAmt
addAmt
)
{
return
arrayContentDidChange
(
this
startIdx
removeAmt
addAmt
)
;
}
_Mixin
create
.
forEach
=
function
(
callback
)
{
var
target
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
forEach
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
length
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
for
(
var
index
=
0
;
index
<
length
;
index
+
+
)
{
var
item
=
this
.
objectAt
(
index
)
;
callback
.
call
(
target
item
index
this
)
;
}
return
this
;
}
_Mixin
create
.
getEach
=
(
0
_emberMetal
.
aliasMethod
)
(
'
mapBy
'
)
_Mixin
create
.
setEach
=
function
(
key
value
)
{
return
this
.
forEach
(
function
(
item
)
{
return
(
0
_emberMetal
.
set
)
(
item
key
value
)
;
}
)
;
}
_Mixin
create
.
map
=
function
(
callback
target
)
{
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
map
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
ret
=
A
(
)
;
this
.
forEach
(
function
(
x
idx
i
)
{
return
ret
[
idx
]
=
callback
.
call
(
target
x
idx
i
)
;
}
)
;
return
ret
;
}
_Mixin
create
.
mapBy
=
function
(
key
)
{
return
this
.
map
(
function
(
next
)
{
return
(
0
_emberMetal
.
get
)
(
next
key
)
;
}
)
;
}
_Mixin
create
.
filter
=
function
(
callback
target
)
{
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
filter
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
ret
=
A
(
)
;
this
.
forEach
(
function
(
x
idx
i
)
{
if
(
callback
.
call
(
target
x
idx
i
)
)
{
ret
.
push
(
x
)
;
}
}
)
;
return
ret
;
}
_Mixin
create
.
reject
=
function
(
callback
target
)
{
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
reject
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
return
this
.
filter
(
function
(
)
{
return
!
callback
.
apply
(
target
arguments
)
;
}
)
;
}
_Mixin
create
.
filterBy
=
function
(
key
value
)
{
return
this
.
filter
(
iter
.
apply
(
this
arguments
)
)
;
}
_Mixin
create
.
rejectBy
=
function
(
key
value
)
{
var
exactValue
=
function
(
item
)
{
return
(
0
_emberMetal
.
get
)
(
item
key
)
=
=
=
value
;
}
;
var
hasValue
=
function
(
item
)
{
return
!
!
(
0
_emberMetal
.
get
)
(
item
key
)
;
}
;
var
use
=
arguments
.
length
=
=
=
2
?
exactValue
:
hasValue
;
return
this
.
reject
(
use
)
;
}
_Mixin
create
.
find
=
function
(
callback
)
{
var
target
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
find
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
length
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
for
(
var
index
=
0
;
index
<
length
;
index
+
+
)
{
var
item
=
this
.
objectAt
(
index
)
;
if
(
callback
.
call
(
target
item
index
this
)
)
{
return
item
;
}
}
}
_Mixin
create
.
findBy
=
function
(
key
value
)
{
return
this
.
find
(
iter
.
apply
(
this
arguments
)
)
;
}
_Mixin
create
.
every
=
function
(
callback
target
)
{
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
every
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
return
!
this
.
find
(
function
(
x
idx
i
)
{
return
!
callback
.
call
(
target
x
idx
i
)
;
}
)
;
}
_Mixin
create
.
isEvery
=
function
(
key
value
)
{
return
this
.
every
(
iter
.
apply
(
this
arguments
)
)
;
}
_Mixin
create
.
any
=
function
(
callback
)
{
var
target
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
any
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
length
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
for
(
var
index
=
0
;
index
<
length
;
index
+
+
)
{
var
item
=
this
.
objectAt
(
index
)
;
if
(
callback
.
call
(
target
item
index
this
)
)
{
return
true
;
}
}
return
false
;
}
_Mixin
create
.
isAny
=
function
(
key
value
)
{
return
this
.
any
(
iter
.
apply
(
this
arguments
)
)
;
}
_Mixin
create
.
reduce
=
function
(
callback
initialValue
reducerProperty
)
{
(
true
&
&
!
(
typeof
callback
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
reduce
expects
a
function
as
first
argument
.
'
typeof
callback
=
=
=
'
function
'
)
)
;
var
ret
=
initialValue
;
this
.
forEach
(
function
(
item
i
)
{
ret
=
callback
(
ret
item
i
this
reducerProperty
)
;
}
this
)
;
return
ret
;
}
_Mixin
create
.
invoke
=
function
(
methodName
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
ret
=
A
(
)
;
this
.
forEach
(
function
(
x
idx
)
{
var
method
=
x
&
&
x
[
methodName
]
;
if
(
'
function
'
=
=
=
typeof
method
)
{
ret
[
idx
]
=
args
.
length
?
method
.
apply
(
x
args
)
:
x
[
methodName
]
(
)
;
}
}
this
)
;
return
ret
;
}
_Mixin
create
.
toArray
=
function
(
)
{
var
ret
=
A
(
)
;
this
.
forEach
(
function
(
o
idx
)
{
return
ret
[
idx
]
=
o
;
}
)
;
return
ret
;
}
_Mixin
create
.
compact
=
function
(
)
{
return
this
.
filter
(
function
(
value
)
{
return
value
!
=
null
;
}
)
;
}
_Mixin
create
.
includes
=
function
(
obj
startAt
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
startAt
=
=
=
undefined
)
{
startAt
=
0
;
}
if
(
startAt
<
0
)
{
startAt
+
=
len
;
}
for
(
var
idx
=
startAt
;
idx
<
len
;
idx
+
+
)
{
var
currentObj
=
objectAt
(
this
idx
)
;
if
(
obj
=
=
=
currentObj
|
|
obj
!
=
=
obj
&
&
currentObj
!
=
=
currentObj
)
{
return
true
;
}
}
return
false
;
}
_Mixin
create
.
sortBy
=
function
(
)
{
var
sortKeys
=
arguments
;
return
this
.
toArray
(
)
.
sort
(
function
(
a
b
)
{
for
(
var
i
=
0
;
i
<
sortKeys
.
length
;
i
+
+
)
{
var
key
=
sortKeys
[
i
]
;
var
propA
=
(
0
_emberMetal
.
get
)
(
a
key
)
;
var
propB
=
(
0
_emberMetal
.
get
)
(
b
key
)
;
var
compareValue
=
(
0
_compare
.
default
)
(
propA
propB
)
;
if
(
compareValue
)
{
return
compareValue
;
}
}
return
0
;
}
)
;
}
_Mixin
create
.
uniq
=
function
(
)
{
var
ret
=
A
(
)
;
var
seen
=
new
Set
(
)
;
this
.
forEach
(
function
(
item
)
{
if
(
!
seen
.
has
(
item
)
)
{
seen
.
add
(
item
)
;
ret
.
push
(
item
)
;
}
}
)
;
return
ret
;
}
_Mixin
create
.
uniqBy
=
function
(
key
)
{
var
ret
=
A
(
)
;
var
seen
=
new
Set
(
)
;
this
.
forEach
(
function
(
item
)
{
var
val
=
(
0
_emberMetal
.
get
)
(
item
key
)
;
if
(
!
seen
.
has
(
val
)
)
{
seen
.
add
(
val
)
;
ret
.
push
(
item
)
;
}
}
)
;
return
ret
;
}
_Mixin
create
.
without
=
function
(
value
)
{
if
(
!
this
.
includes
(
value
)
)
{
return
this
;
}
var
ret
=
A
(
)
;
this
.
forEach
(
function
(
k
)
{
if
(
!
(
k
=
=
=
value
|
|
k
!
=
=
k
&
&
value
!
=
=
value
)
)
{
ret
[
ret
.
length
]
=
k
;
}
}
)
;
return
ret
;
}
_Mixin
create
[
'
each
'
]
=
(
0
_emberMetal
.
computed
)
(
function
(
)
{
if
(
!
this
.
__each
)
{
this
.
__each
=
new
EachProxy
(
this
)
;
}
return
this
.
__each
;
}
)
.
volatile
(
)
.
readOnly
(
)
_Mixin
create
)
)
;
function
EachProxy
(
content
)
{
this
.
_content
=
content
;
this
.
_keys
=
undefined
;
(
0
_emberMetal
.
meta
)
(
this
)
;
}
EachProxy
.
prototype
=
{
__defineNonEnumerable
:
function
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
arrayWillChange
:
function
(
content
idx
removedCnt
addedCnt
)
{
var
keys
=
this
.
_keys
;
var
lim
=
removedCnt
>
0
?
idx
+
removedCnt
:
-
1
;
var
meta
=
(
0
_emberMetal
.
peekMeta
)
(
this
)
;
for
(
var
key
in
keys
)
{
if
(
lim
>
0
)
{
removeObserverForContentKey
(
content
key
this
idx
lim
)
;
}
(
0
_emberMetal
.
propertyWillChange
)
(
this
key
meta
)
;
}
}
arrayDidChange
:
function
(
content
idx
removedCnt
addedCnt
)
{
var
keys
=
this
.
_keys
;
var
lim
=
addedCnt
>
0
?
idx
+
addedCnt
:
-
1
;
var
meta
=
(
0
_emberMetal
.
peekMeta
)
(
this
)
;
for
(
var
key
in
keys
)
{
if
(
lim
>
0
)
{
addObserverForContentKey
(
content
key
this
idx
lim
)
;
}
(
0
_emberMetal
.
propertyDidChange
)
(
this
key
meta
)
;
}
}
willWatchProperty
:
function
(
property
)
{
this
.
beginObservingContentKey
(
property
)
;
}
didUnwatchProperty
:
function
(
property
)
{
this
.
stopObservingContentKey
(
property
)
;
}
beginObservingContentKey
:
function
(
keyName
)
{
var
keys
=
this
.
_keys
;
if
(
!
keys
)
{
keys
=
this
.
_keys
=
Object
.
create
(
null
)
;
}
if
(
!
keys
[
keyName
]
)
{
keys
[
keyName
]
=
1
;
var
content
=
this
.
_content
;
var
len
=
(
0
_emberMetal
.
get
)
(
content
'
length
'
)
;
addObserverForContentKey
(
content
keyName
this
0
len
)
;
}
else
{
keys
[
keyName
]
+
+
;
}
}
stopObservingContentKey
:
function
(
keyName
)
{
var
keys
=
this
.
_keys
;
if
(
keys
&
&
keys
[
keyName
]
>
0
&
&
-
-
keys
[
keyName
]
<
=
0
)
{
var
content
=
this
.
_content
;
var
len
=
(
0
_emberMetal
.
get
)
(
content
'
length
'
)
;
removeObserverForContentKey
(
content
keyName
this
0
len
)
;
}
}
contentKeyWillChange
:
function
(
obj
keyName
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
this
keyName
)
;
}
contentKeyDidChange
:
function
(
obj
keyName
)
{
(
0
_emberMetal
.
propertyDidChange
)
(
this
keyName
)
;
}
}
;
function
addObserverForContentKey
(
content
keyName
proxy
idx
loc
)
{
while
(
-
-
loc
>
=
idx
)
{
var
item
=
objectAt
(
content
loc
)
;
if
(
item
)
{
(
true
&
&
!
(
typeof
item
=
=
=
'
object
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
When
using
each
to
observe
the
array
'
+
(
0
_emberUtils
.
toString
)
(
content
)
+
'
the
array
must
return
an
object
'
typeof
item
=
=
=
'
object
'
)
)
;
(
0
_emberMetal
.
_addBeforeObserver
)
(
item
keyName
proxy
'
contentKeyWillChange
'
)
;
(
0
_emberMetal
.
addObserver
)
(
item
keyName
proxy
'
contentKeyDidChange
'
)
;
}
}
}
function
removeObserverForContentKey
(
content
keyName
proxy
idx
loc
)
{
while
(
-
-
loc
>
=
idx
)
{
var
item
=
objectAt
(
content
loc
)
;
if
(
item
)
{
(
0
_emberMetal
.
_removeBeforeObserver
)
(
item
keyName
proxy
'
contentKeyWillChange
'
)
;
(
0
_emberMetal
.
removeObserver
)
(
item
keyName
proxy
'
contentKeyDidChange
'
)
;
}
}
}
exports
.
default
=
ArrayMixin
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
comparable
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
compare
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
container_proxy
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
var
containerProxyMixin
=
{
__container__
:
null
ownerInjection
:
function
(
)
{
return
this
.
__container__
.
ownerInjection
(
)
;
}
lookup
:
function
(
fullName
options
)
{
return
this
.
__container__
.
lookup
(
fullName
options
)
;
}
_resolveLocalLookupName
:
function
(
name
source
)
{
return
this
.
__container__
.
registry
.
expandLocalLookup
(
'
component
:
'
+
name
{
source
:
source
}
)
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
this
.
__container__
)
{
(
0
_emberMetal
.
run
)
(
this
.
__container__
'
destroy
'
)
;
}
}
factoryFor
:
function
(
fullName
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
return
this
.
__container__
.
factoryFor
(
fullName
options
)
;
}
}
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
containerProxyMixin
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
controller
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
/
computed
/
computed_macros
'
'
ember
-
runtime
/
mixins
/
action_handler
'
]
function
(
exports
_emberMetal
_computed_macros
_action_handler
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
_action_handler
.
default
{
isController
:
true
target
:
null
store
:
null
model
:
null
content
:
(
0
_computed_macros
.
deprecatingAlias
)
(
'
model
'
{
id
:
'
ember
-
runtime
.
controller
.
content
-
alias
'
until
:
'
2
.
17
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_controller
-
content
-
alias
'
}
)
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
copyable
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
copy
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
enumerable
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
evented
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
on
:
function
(
name
target
method
)
{
(
0
_emberMetal
.
addListener
)
(
this
name
target
method
)
;
return
this
;
}
one
:
function
(
name
target
method
)
{
if
(
!
method
)
{
method
=
target
;
target
=
null
;
}
(
0
_emberMetal
.
addListener
)
(
this
name
target
method
true
)
;
return
this
;
}
trigger
:
function
(
name
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
(
0
_emberMetal
.
sendEvent
)
(
this
name
args
)
;
}
off
:
function
(
name
target
method
)
{
(
0
_emberMetal
.
removeListener
)
(
this
name
target
method
)
;
return
this
;
}
has
:
function
(
name
)
{
return
(
0
_emberMetal
.
hasListeners
)
(
this
name
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
mutable_array
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_mutable_enumerable
_array
_emberDebug
)
{
'
use
strict
'
;
exports
.
removeAt
=
removeAt
;
var
OUT_OF_RANGE_EXCEPTION
=
'
Index
out
of
range
'
;
var
EMPTY
=
[
]
;
function
removeAt
(
array
start
len
)
{
if
(
'
number
'
=
=
=
typeof
start
)
{
if
(
start
<
0
|
|
start
>
=
(
0
_emberMetal
.
get
)
(
array
'
length
'
)
)
{
throw
new
_emberDebug
.
Error
(
OUT_OF_RANGE_EXCEPTION
)
;
}
if
(
len
=
=
=
undefined
)
{
len
=
1
;
}
array
.
replace
(
start
len
EMPTY
)
;
}
return
array
;
}
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
_array
.
default
_mutable_enumerable
.
default
{
replace
:
null
clear
:
function
(
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
this
;
}
this
.
replace
(
0
len
EMPTY
)
;
return
this
;
}
insertAt
:
function
(
idx
object
)
{
if
(
idx
>
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
)
{
throw
new
_emberDebug
.
Error
(
OUT_OF_RANGE_EXCEPTION
)
;
}
this
.
replace
(
idx
0
[
object
]
)
;
return
this
;
}
removeAt
:
function
(
start
len
)
{
return
removeAt
(
this
start
len
)
;
}
pushObject
:
function
(
obj
)
{
this
.
insertAt
(
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
obj
)
;
return
obj
;
}
pushObjects
:
function
(
objects
)
{
if
(
!
Array
.
isArray
(
objects
)
)
{
throw
new
TypeError
(
'
Must
pass
Enumerable
to
MutableArray
#
pushObjects
'
)
;
}
this
.
replace
(
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
0
objects
)
;
return
this
;
}
popObject
:
function
(
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
null
;
}
var
ret
=
(
0
_array
.
objectAt
)
(
this
len
-
1
)
;
this
.
removeAt
(
len
-
1
1
)
;
return
ret
;
}
shiftObject
:
function
(
)
{
if
(
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
=
=
=
0
)
{
return
null
;
}
var
ret
=
(
0
_array
.
objectAt
)
(
this
0
)
;
this
.
removeAt
(
0
)
;
return
ret
;
}
unshiftObject
:
function
(
obj
)
{
this
.
insertAt
(
0
obj
)
;
return
obj
;
}
unshiftObjects
:
function
(
objects
)
{
this
.
replace
(
0
0
objects
)
;
return
this
;
}
reverseObjects
:
function
(
)
{
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
this
;
}
var
objects
=
this
.
toArray
(
)
.
reverse
(
)
;
this
.
replace
(
0
len
objects
)
;
return
this
;
}
setObjects
:
function
(
objects
)
{
if
(
objects
.
length
=
=
=
0
)
{
return
this
.
clear
(
)
;
}
var
len
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
;
this
.
replace
(
0
len
objects
)
;
return
this
;
}
removeObject
:
function
(
obj
)
{
var
loc
=
(
0
_emberMetal
.
get
)
(
this
'
length
'
)
|
|
0
;
while
(
-
-
loc
>
=
0
)
{
var
curObject
=
(
0
_array
.
objectAt
)
(
this
loc
)
;
if
(
curObject
=
=
=
obj
)
{
this
.
removeAt
(
loc
)
;
}
}
return
this
;
}
removeObjects
:
function
(
objects
)
{
(
0
_emberMetal
.
beginPropertyChanges
)
(
this
)
;
for
(
var
i
=
objects
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
removeObject
(
objects
[
i
]
)
;
}
(
0
_emberMetal
.
endPropertyChanges
)
(
this
)
;
return
this
;
}
addObject
:
function
(
obj
)
{
var
included
=
this
.
includes
(
obj
)
;
if
(
!
included
)
{
this
.
pushObject
(
obj
)
;
}
return
this
;
}
addObjects
:
function
(
objects
)
{
var
_this
=
this
;
(
0
_emberMetal
.
beginPropertyChanges
)
(
this
)
;
objects
.
forEach
(
function
(
obj
)
{
return
_this
.
addObject
(
obj
)
;
}
)
;
(
0
_emberMetal
.
endPropertyChanges
)
(
this
)
;
return
this
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
[
'
exports
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
metal
'
]
function
(
exports
_enumerable
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
_enumerable
.
default
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
observable
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
get
:
function
(
keyName
)
{
return
(
0
_emberMetal
.
get
)
(
this
keyName
)
;
}
getProperties
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
_emberMetal
.
getProperties
.
apply
(
undefined
[
this
]
.
concat
(
args
)
)
;
}
set
:
function
(
keyName
value
)
{
return
(
0
_emberMetal
.
set
)
(
this
keyName
value
)
;
}
setProperties
:
function
(
hash
)
{
return
(
0
_emberMetal
.
setProperties
)
(
this
hash
)
;
}
beginPropertyChanges
:
function
(
)
{
(
0
_emberMetal
.
beginPropertyChanges
)
(
)
;
return
this
;
}
endPropertyChanges
:
function
(
)
{
(
0
_emberMetal
.
endPropertyChanges
)
(
)
;
return
this
;
}
propertyWillChange
:
function
(
keyName
)
{
(
0
_emberMetal
.
propertyWillChange
)
(
this
keyName
)
;
return
this
;
}
propertyDidChange
:
function
(
keyName
)
{
(
0
_emberMetal
.
propertyDidChange
)
(
this
keyName
)
;
return
this
;
}
notifyPropertyChange
:
function
(
keyName
)
{
this
.
propertyWillChange
(
keyName
)
;
this
.
propertyDidChange
(
keyName
)
;
return
this
;
}
addObserver
:
function
(
key
target
method
)
{
(
0
_emberMetal
.
addObserver
)
(
this
key
target
method
)
;
return
this
;
}
removeObserver
:
function
(
key
target
method
)
{
(
0
_emberMetal
.
removeObserver
)
(
this
key
target
method
)
;
return
this
;
}
hasObserverFor
:
function
(
key
)
{
return
(
0
_emberMetal
.
hasListeners
)
(
this
key
+
'
:
change
'
)
;
}
getWithDefault
:
function
(
keyName
defaultValue
)
{
return
(
0
_emberMetal
.
getWithDefault
)
(
this
keyName
defaultValue
)
;
}
incrementProperty
:
function
(
keyName
increment
)
{
if
(
(
0
_emberMetal
.
isNone
)
(
increment
)
)
{
increment
=
1
;
}
(
true
&
&
!
(
!
isNaN
(
parseFloat
(
increment
)
)
&
&
isFinite
(
increment
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Must
pass
a
numeric
value
to
incrementProperty
'
!
isNaN
(
parseFloat
(
increment
)
)
&
&
isFinite
(
increment
)
)
)
;
return
(
0
_emberMetal
.
set
)
(
this
keyName
(
parseFloat
(
(
0
_emberMetal
.
get
)
(
this
keyName
)
)
|
|
0
)
+
increment
)
;
}
decrementProperty
:
function
(
keyName
decrement
)
{
if
(
(
0
_emberMetal
.
isNone
)
(
decrement
)
)
{
decrement
=
1
;
}
(
true
&
&
!
(
!
isNaN
(
parseFloat
(
decrement
)
)
&
&
isFinite
(
decrement
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Must
pass
a
numeric
value
to
decrementProperty
'
!
isNaN
(
parseFloat
(
decrement
)
)
&
&
isFinite
(
decrement
)
)
)
;
return
(
0
_emberMetal
.
set
)
(
this
keyName
(
(
0
_emberMetal
.
get
)
(
this
keyName
)
|
|
0
)
-
decrement
)
;
}
toggleProperty
:
function
(
keyName
)
{
return
(
0
_emberMetal
.
set
)
(
this
keyName
!
(
0
_emberMetal
.
get
)
(
this
keyName
)
)
;
}
cacheFor
:
function
(
keyName
)
{
return
(
0
_emberMetal
.
cacheFor
)
(
this
keyName
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
promise_proxy
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
runtime
/
computed
/
computed_macros
'
]
function
(
exports
_emberMetal
_emberDebug
_computed_macros
)
{
'
use
strict
'
;
function
tap
(
proxy
promise
)
{
(
0
_emberMetal
.
setProperties
)
(
proxy
{
isFulfilled
:
false
isRejected
:
false
}
)
;
return
promise
.
then
(
function
(
value
)
{
if
(
!
proxy
.
isDestroyed
&
&
!
proxy
.
isDestroying
)
{
(
0
_emberMetal
.
setProperties
)
(
proxy
{
content
:
value
isFulfilled
:
true
}
)
;
}
return
value
;
}
function
(
reason
)
{
if
(
!
proxy
.
isDestroyed
&
&
!
proxy
.
isDestroying
)
{
(
0
_emberMetal
.
setProperties
)
(
proxy
{
reason
:
reason
isRejected
:
true
}
)
;
}
throw
reason
;
}
'
Ember
:
PromiseProxy
'
)
;
}
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
reason
:
null
isPending
:
(
0
_computed_macros
.
not
)
(
'
isSettled
'
)
.
readOnly
(
)
isSettled
:
(
0
_computed_macros
.
or
)
(
'
isRejected
'
'
isFulfilled
'
)
.
readOnly
(
)
isRejected
:
false
isFulfilled
:
false
promise
:
(
0
_emberMetal
.
computed
)
(
{
get
:
function
(
)
{
throw
new
_emberDebug
.
Error
(
'
PromiseProxy
\
'
s
promise
must
be
set
'
)
;
}
set
:
function
(
key
promise
)
{
return
tap
(
this
promise
)
;
}
}
)
then
:
promiseAlias
(
'
then
'
)
'
catch
'
:
promiseAlias
(
'
catch
'
)
'
finally
'
:
promiseAlias
(
'
finally
'
)
}
)
;
function
promiseAlias
(
name
)
{
return
function
(
)
{
var
promise
=
(
0
_emberMetal
.
get
)
(
this
'
promise
'
)
;
return
promise
[
name
]
.
apply
(
promise
arguments
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
registry_proxy
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
__registry__
:
null
resolveRegistration
:
registryAlias
(
'
resolve
'
)
register
:
registryAlias
(
'
register
'
)
unregister
:
registryAlias
(
'
unregister
'
)
hasRegistration
:
registryAlias
(
'
has
'
)
registeredOption
:
registryAlias
(
'
getOption
'
)
registerOptions
:
registryAlias
(
'
options
'
)
registeredOptions
:
registryAlias
(
'
getOptions
'
)
registerOptionsForType
:
registryAlias
(
'
optionsForType
'
)
registeredOptionsForType
:
registryAlias
(
'
getOptionsForType
'
)
inject
:
registryAlias
(
'
injection
'
)
}
)
;
function
registryAlias
(
name
)
{
return
function
(
)
{
var
_registry__
;
return
(
_registry__
=
this
.
__registry__
)
[
name
]
.
apply
(
_registry__
arguments
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
target_action_support
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberEnvironment
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
target
:
null
targetObject
:
(
0
_emberMetal
.
descriptor
)
(
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
var
message
=
this
+
'
Usage
of
targetObject
is
deprecated
.
Please
use
target
instead
.
'
;
var
options
=
{
id
:
'
ember
-
runtime
.
using
-
targetObject
'
until
:
'
3
.
5
.
0
'
}
;
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
message
false
options
)
)
;
return
this
.
_targetObject
;
}
set
:
function
(
value
)
{
var
message
=
this
+
'
Usage
of
targetObject
is
deprecated
.
Please
use
target
instead
.
'
;
var
options
=
{
id
:
'
ember
-
runtime
.
using
-
targetObject
'
until
:
'
3
.
5
.
0
'
}
;
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
message
false
options
)
)
;
this
.
_targetObject
=
value
;
}
}
)
action
:
null
actionContext
:
null
actionContextObject
:
(
0
_emberMetal
.
computed
)
(
'
actionContext
'
function
(
)
{
var
actionContext
=
(
0
_emberMetal
.
get
)
(
this
'
actionContext
'
)
;
if
(
typeof
actionContext
=
=
=
'
string
'
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
this
actionContext
)
;
if
(
value
=
=
=
undefined
)
{
value
=
(
0
_emberMetal
.
get
)
(
_emberEnvironment
.
context
.
lookup
actionContext
)
;
}
return
value
;
}
else
{
return
actionContext
;
}
}
)
triggerAction
:
function
(
)
{
var
opts
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
var
action
=
opts
.
action
target
=
opts
.
target
actionContext
=
opts
.
actionContext
;
action
=
action
|
|
(
0
_emberMetal
.
get
)
(
this
'
action
'
)
;
target
=
target
|
|
getTarget
(
this
)
;
if
(
actionContext
=
=
=
undefined
)
{
actionContext
=
(
0
_emberMetal
.
get
)
(
this
'
actionContextObject
'
)
|
|
this
;
}
if
(
target
&
&
action
)
{
var
ret
=
void
0
;
if
(
target
.
send
)
{
var
_target
;
ret
=
(
_target
=
target
)
.
send
.
apply
(
_target
[
action
]
.
concat
(
actionContext
)
)
;
}
else
{
var
_target2
;
(
true
&
&
!
(
typeof
target
[
action
]
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
action
\
'
'
+
action
+
'
\
'
did
not
exist
on
'
+
target
typeof
target
[
action
]
=
=
=
'
function
'
)
)
;
ret
=
(
_target2
=
target
)
[
action
]
.
apply
(
_target2
[
]
.
concat
(
actionContext
)
)
;
}
if
(
ret
!
=
=
false
)
{
return
true
;
}
}
return
false
;
}
}
)
;
function
getTarget
(
instance
)
{
var
target
=
(
0
_emberMetal
.
get
)
(
instance
'
target
'
)
;
if
(
target
)
{
if
(
typeof
target
=
=
=
'
string
'
)
{
var
value
=
(
0
_emberMetal
.
get
)
(
instance
target
)
;
if
(
value
=
=
=
undefined
)
{
value
=
(
0
_emberMetal
.
get
)
(
_emberEnvironment
.
context
.
lookup
target
)
;
}
return
value
;
}
else
{
return
target
;
}
}
if
(
target
)
{
return
target
;
}
if
(
instance
.
_targetObject
)
{
return
instance
.
_targetObject
;
}
return
null
;
}
}
)
;
enifed
(
"
ember
-
runtime
/
string_registry
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
setStrings
=
setStrings
;
exports
.
getStrings
=
getStrings
;
exports
.
get
=
get
;
var
STRINGS
=
{
}
;
function
setStrings
(
strings
)
{
STRINGS
=
strings
;
}
function
getStrings
(
)
{
return
STRINGS
;
}
function
get
(
name
)
{
return
STRINGS
[
name
]
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
application
'
[
'
exports
'
'
ember
-
runtime
/
system
/
namespace
'
]
function
(
exports
_namespace
)
{
'
use
strict
'
;
exports
.
default
=
_namespace
.
default
.
extend
(
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
array_proxy
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_utils
_object
_mutable_array
_array
_emberDebug
)
{
'
use
strict
'
;
var
_EmberObject
extend
;
var
ARRAY_OBSERVER_MAPPING
=
{
willChange
:
'
_arrangedContentArrayWillChange
'
didChange
:
'
_arrangedContentArrayDidChange
'
}
;
exports
.
default
=
_object
.
default
.
extend
(
_mutable_array
.
default
(
_EmberObject
extend
=
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_objectsDirtyIndex
=
0
;
this
.
_objects
=
null
;
this
.
_lengthDirty
=
true
;
this
.
_length
=
0
;
this
.
_arrangedContent
=
null
;
this
.
_addArrangedContentArrayObsever
(
)
;
}
willDestroy
:
function
(
)
{
this
.
_removeArrangedContentArrayObsever
(
)
;
}
content
:
null
arrangedContent
:
(
0
_emberMetal
.
alias
)
(
'
content
'
)
objectAtContent
:
function
(
idx
)
{
return
(
0
_array
.
objectAt
)
(
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
idx
)
;
}
replace
:
function
(
idx
amt
objects
)
{
(
true
&
&
!
(
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
=
=
=
(
0
_emberMetal
.
get
)
(
this
'
content
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Mutating
an
arranged
ArrayProxy
is
not
allowed
'
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
=
=
=
(
0
_emberMetal
.
get
)
(
this
'
content
'
)
)
)
;
this
.
replaceContent
(
idx
amt
objects
)
;
}
replaceContent
:
function
(
idx
amt
objects
)
{
(
0
_emberMetal
.
get
)
(
this
'
content
'
)
.
replace
(
idx
amt
objects
)
;
}
objectAt
:
function
(
idx
)
{
if
(
this
.
_objects
=
=
=
null
)
{
this
.
_objects
=
[
]
;
}
if
(
this
.
_objectsDirtyIndex
!
=
=
-
1
&
&
idx
>
=
this
.
_objectsDirtyIndex
)
{
var
arrangedContent
=
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
;
if
(
arrangedContent
)
{
var
length
=
this
.
_objects
.
length
=
(
0
_emberMetal
.
get
)
(
arrangedContent
'
length
'
)
;
for
(
var
i
=
this
.
_objectsDirtyIndex
;
i
<
length
;
i
+
+
)
{
this
.
_objects
[
i
]
=
this
.
objectAtContent
(
i
)
;
}
}
else
{
this
.
_objects
.
length
=
0
;
}
this
.
_objectsDirtyIndex
=
-
1
;
}
return
this
.
_objects
[
idx
]
;
}
length
:
(
0
_emberMetal
.
computed
)
(
function
(
)
{
if
(
this
.
_lengthDirty
)
{
var
arrangedContent
=
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
;
this
.
_length
=
arrangedContent
?
(
0
_emberMetal
.
get
)
(
arrangedContent
'
length
'
)
:
0
;
this
.
_lengthDirty
=
false
;
}
return
this
.
_length
;
}
)
.
volatile
(
)
}
_EmberObject
extend
[
_emberMetal
.
PROPERTY_DID_CHANGE
]
=
function
(
key
)
{
if
(
key
=
=
=
'
arrangedContent
'
)
{
var
oldLength
=
this
.
_objects
=
=
=
null
?
0
:
this
.
_objects
.
length
;
var
arrangedContent
=
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
;
var
newLength
=
arrangedContent
?
(
0
_emberMetal
.
get
)
(
arrangedContent
'
length
'
)
:
0
;
this
.
_removeArrangedContentArrayObsever
(
)
;
this
.
arrayContentWillChange
(
0
oldLength
newLength
)
;
this
.
_objectsDirtyIndex
=
0
;
this
.
_lengthDirty
=
true
;
this
.
arrayContentDidChange
(
0
oldLength
newLength
)
;
this
.
_addArrangedContentArrayObsever
(
)
;
}
}
_EmberObject
extend
.
_addArrangedContentArrayObsever
=
function
(
)
{
var
arrangedContent
=
(
0
_emberMetal
.
get
)
(
this
'
arrangedContent
'
)
;
if
(
arrangedContent
)
{
(
true
&
&
!
(
arrangedContent
!
=
=
this
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Can
\
'
t
set
ArrayProxy
\
'
s
content
to
itself
'
arrangedContent
!
=
=
this
)
)
;
(
true
&
&
!
(
(
0
_utils
.
isArray
)
(
arrangedContent
)
|
|
arrangedContent
.
isDestroyed
)
&
&
(
0
_emberDebug
.
assert
)
(
'
ArrayProxy
expects
an
Array
or
ArrayProxy
but
you
passed
'
+
typeof
arrangedContent
(
0
_utils
.
isArray
)
(
arrangedContent
)
|
|
arrangedContent
.
isDestroyed
)
)
;
(
0
_array
.
addArrayObserver
)
(
arrangedContent
this
ARRAY_OBSERVER_MAPPING
)
;
this
.
_arrangedContent
=
arrangedContent
;
}
}
_EmberObject
extend
.
_removeArrangedContentArrayObsever
=
function
(
)
{
if
(
this
.
_arrangedContent
)
{
(
0
_array
.
removeArrayObserver
)
(
this
.
_arrangedContent
this
ARRAY_OBSERVER_MAPPING
)
;
}
}
_EmberObject
extend
.
_arrangedContentArrayWillChange
=
function
(
)
{
}
_EmberObject
extend
.
_arrangedContentArrayDidChange
=
function
(
proxy
idx
removedCnt
addedCnt
)
{
this
.
arrayContentWillChange
(
idx
removedCnt
addedCnt
)
;
var
dirtyIndex
=
idx
;
if
(
dirtyIndex
<
0
)
{
var
length
=
(
0
_emberMetal
.
get
)
(
this
.
_arrangedContent
'
length
'
)
;
dirtyIndex
+
=
length
+
removedCnt
-
addedCnt
;
}
if
(
this
.
_objectsDirtyIndex
=
=
=
-
1
)
{
this
.
_objectsDirtyIndex
=
dirtyIndex
;
}
else
{
if
(
this
.
_objectsDirtyIndex
>
dirtyIndex
)
{
this
.
_objectsDirtyIndex
=
dirtyIndex
;
}
}
this
.
_lengthDirty
=
true
;
this
.
arrayContentDidChange
(
idx
removedCnt
addedCnt
)
;
}
_EmberObject
extend
)
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
core_object
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
runtime
/
inject
'
'
ember
-
debug
'
'
ember
-
environment
'
'
ember
/
features
'
]
function
(
exports
_emberBabel
_emberUtils
_emberMetal
_action_handler
_inject
_emberDebug
_emberEnvironment
_features
)
{
'
use
strict
'
;
exports
.
POST_INIT
=
undefined
;
var
_Mixin
create
_ClassMixinProps
;
var
schedule
=
_emberMetal
.
run
.
schedule
;
var
applyMixin
=
_emberMetal
.
Mixin
.
_apply
;
var
reopen
=
_emberMetal
.
Mixin
.
prototype
.
reopen
;
var
POST_INIT
=
exports
.
POST_INIT
=
(
0
_emberUtils
.
symbol
)
(
'
POST_INIT
'
)
;
function
makeCtor
(
)
{
var
wasApplied
=
false
;
var
initProperties
=
void
0
initFactory
=
void
0
;
var
Class
=
function
(
)
{
function
Class
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
Class
)
;
if
(
!
wasApplied
)
{
Class
.
proto
(
)
;
}
if
(
arguments
.
length
>
0
)
{
initProperties
=
[
arguments
[
0
]
]
;
}
this
.
__defineNonEnumerable
(
_emberUtils
.
GUID_KEY_PROPERTY
)
;
var
m
=
(
0
_emberMetal
.
meta
)
(
this
)
;
var
proto
=
m
.
proto
;
m
.
proto
=
this
;
if
(
initFactory
)
{
m
.
factory
=
initFactory
;
initFactory
=
null
;
}
if
(
initProperties
)
{
var
props
=
initProperties
;
initProperties
=
null
;
var
concatenatedProperties
=
this
.
concatenatedProperties
;
var
mergedProperties
=
this
.
mergedProperties
;
var
hasConcatenatedProps
=
concatenatedProperties
&
&
concatenatedProperties
.
length
>
0
;
var
hasMergedProps
=
mergedProperties
&
&
mergedProperties
.
length
>
0
;
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
properties
=
props
[
i
]
;
(
true
&
&
!
(
typeof
properties
=
=
=
'
object
'
|
|
properties
=
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
EmberObject
.
create
only
accepts
objects
.
'
typeof
properties
=
=
=
'
object
'
|
|
properties
=
=
=
undefined
)
)
;
(
true
&
&
!
(
!
(
properties
instanceof
_emberMetal
.
Mixin
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
EmberObject
.
create
no
longer
supports
mixing
in
other
'
+
'
definitions
use
.
extend
&
.
create
separately
instead
.
'
!
(
properties
instanceof
_emberMetal
.
Mixin
)
)
)
;
if
(
!
properties
)
{
continue
;
}
var
keyNames
=
Object
.
keys
(
properties
)
;
for
(
var
j
=
0
;
j
<
keyNames
.
length
;
j
+
+
)
{
var
keyName
=
keyNames
[
j
]
;
var
value
=
properties
[
keyName
]
;
if
(
_emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
&
&
_emberMetal
.
Mixin
.
detectBinding
(
keyName
)
)
{
m
.
writeBindings
(
keyName
value
)
;
}
(
true
&
&
!
(
!
(
value
instanceof
_emberMetal
.
ComputedProperty
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
EmberObject
.
create
no
longer
supports
defining
computed
'
+
'
properties
.
Define
computed
properties
using
extend
(
)
or
reopen
(
)
'
+
'
before
calling
create
(
)
.
'
!
(
value
instanceof
_emberMetal
.
ComputedProperty
)
)
)
;
(
true
&
&
!
(
!
(
typeof
value
=
=
=
'
function
'
&
&
value
.
toString
(
)
.
indexOf
(
'
.
_super
'
)
!
=
=
-
1
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
EmberObject
.
create
no
longer
supports
defining
methods
that
call
_super
.
'
!
(
typeof
value
=
=
=
'
function
'
&
&
value
.
toString
(
)
.
indexOf
(
'
.
_super
'
)
!
=
=
-
1
)
)
)
;
(
true
&
&
!
(
!
(
keyName
=
=
=
'
actions
'
&
&
_action_handler
.
default
.
detect
(
this
)
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
actions
must
be
provided
at
extend
time
not
at
create
time
'
+
'
when
ActionHandler
is
used
(
i
.
e
.
views
controllers
&
routes
)
.
'
!
(
keyName
=
=
=
'
actions
'
&
&
_action_handler
.
default
.
detect
(
this
)
)
)
)
;
var
possibleDesc
=
(
0
_emberMetal
.
descriptorFor
)
(
this
keyName
m
)
;
var
isDescriptor
=
possibleDesc
!
=
=
undefined
;
if
(
!
isDescriptor
)
{
var
baseValue
=
this
[
keyName
]
;
if
(
hasConcatenatedProps
&
&
concatenatedProperties
.
indexOf
(
keyName
)
>
-
1
)
{
if
(
baseValue
)
{
value
=
(
0
_emberUtils
.
makeArray
)
(
baseValue
)
.
concat
(
value
)
;
}
else
{
value
=
(
0
_emberUtils
.
makeArray
)
(
value
)
;
}
}
if
(
hasMergedProps
&
&
mergedProperties
.
indexOf
(
keyName
)
>
-
1
)
{
value
=
(
0
_emberUtils
.
assign
)
(
{
}
baseValue
value
)
;
}
}
if
(
isDescriptor
)
{
possibleDesc
.
set
(
this
keyName
value
)
;
}
else
if
(
typeof
this
.
setUnknownProperty
=
=
=
'
function
'
&
&
!
(
keyName
in
this
)
)
{
this
.
setUnknownProperty
(
keyName
value
)
;
}
else
{
if
(
_features
.
MANDATORY_SETTER
)
{
(
0
_emberMetal
.
defineProperty
)
(
this
keyName
null
value
)
;
}
else
{
this
[
keyName
]
=
value
;
}
}
}
}
}
if
(
_emberEnvironment
.
ENV
.
_ENABLE_BINDING_SUPPORT
)
{
_emberMetal
.
Mixin
.
finishPartial
(
this
m
)
;
}
this
.
init
.
apply
(
this
arguments
)
;
this
[
POST_INIT
]
(
)
;
m
.
proto
=
proto
;
(
0
_emberMetal
.
finishChains
)
(
m
)
;
(
0
_emberMetal
.
sendEvent
)
(
this
'
init
'
undefined
undefined
undefined
m
)
;
}
Class
.
willReopen
=
function
willReopen
(
)
{
if
(
wasApplied
)
{
Class
.
PrototypeMixin
=
_emberMetal
.
Mixin
.
create
(
Class
.
PrototypeMixin
)
;
}
wasApplied
=
false
;
}
;
Class
.
_initProperties
=
function
_initProperties
(
args
)
{
initProperties
=
args
;
}
;
Class
.
_initFactory
=
function
_initFactory
(
factory
)
{
initFactory
=
factory
;
}
;
Class
.
proto
=
function
proto
(
)
{
var
superclass
=
Class
.
superclass
;
if
(
superclass
)
{
superclass
.
proto
(
)
;
}
if
(
!
wasApplied
)
{
wasApplied
=
true
;
Class
.
PrototypeMixin
.
applyPartial
(
Class
.
prototype
)
;
}
return
this
.
prototype
;
}
;
return
Class
;
}
(
)
;
Class
.
toString
=
_emberMetal
.
Mixin
.
prototype
.
toString
;
return
Class
;
}
var
IS_DESTROYED
=
(
0
_emberMetal
.
descriptor
)
(
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
return
(
0
_emberMetal
.
peekMeta
)
(
this
)
.
isSourceDestroyed
(
)
;
}
set
:
function
(
value
)
{
(
true
&
&
!
(
value
=
=
=
IS_DESTROYED
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
set
'
+
this
+
'
.
isDestroyed
directly
please
use
.
destroy
(
)
.
'
value
=
=
=
IS_DESTROYED
)
)
;
}
}
)
;
var
IS_DESTROYING
=
(
0
_emberMetal
.
descriptor
)
(
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
return
(
0
_emberMetal
.
peekMeta
)
(
this
)
.
isSourceDestroying
(
)
;
}
set
:
function
(
value
)
{
(
true
&
&
!
(
value
=
=
=
IS_DESTROYING
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
set
'
+
this
+
'
.
isDestroying
directly
please
use
.
destroy
(
)
.
'
value
=
=
=
IS_DESTROYING
)
)
;
}
}
)
;
var
CoreObject
=
makeCtor
(
)
;
CoreObject
.
toString
=
function
(
)
{
return
'
Ember
.
CoreObject
'
;
}
;
CoreObject
.
PrototypeMixin
=
_emberMetal
.
Mixin
.
create
(
(
_Mixin
create
=
{
reopen
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
applyMixin
(
this
args
true
)
;
return
this
;
}
init
:
function
(
)
{
}
}
_Mixin
create
[
POST_INIT
]
=
function
(
)
{
}
_Mixin
create
.
__defineNonEnumerable
=
function
(
property
)
{
Object
.
defineProperty
(
this
property
.
name
property
.
descriptor
)
;
}
_Mixin
create
.
concatenatedProperties
=
null
_Mixin
create
.
mergedProperties
=
null
_Mixin
create
.
isDestroyed
=
IS_DESTROYED
_Mixin
create
.
isDestroying
=
IS_DESTROYING
_Mixin
create
.
destroy
=
function
(
)
{
var
m
=
(
0
_emberMetal
.
peekMeta
)
(
this
)
;
if
(
m
.
isSourceDestroying
(
)
)
{
return
;
}
m
.
setSourceDestroying
(
)
;
schedule
(
'
actions
'
this
this
.
willDestroy
)
;
schedule
(
'
destroy
'
this
this
.
_scheduledDestroy
m
)
;
return
this
;
}
_Mixin
create
.
willDestroy
=
function
(
)
{
}
_Mixin
create
.
_scheduledDestroy
=
function
(
m
)
{
if
(
m
.
isSourceDestroyed
(
)
)
{
return
;
}
(
0
_emberMetal
.
deleteMeta
)
(
this
)
;
m
.
setSourceDestroyed
(
)
;
}
_Mixin
create
.
toString
=
function
(
)
{
var
hasToStringExtension
=
typeof
this
.
toStringExtension
=
=
=
'
function
'
;
var
extension
=
hasToStringExtension
?
'
:
'
+
this
.
toStringExtension
(
)
:
'
'
;
var
ret
=
'
<
'
+
(
this
[
_emberUtils
.
NAME_KEY
]
|
|
(
0
_emberMetal
.
peekMeta
)
(
this
)
.
factory
|
|
this
.
constructor
.
toString
(
)
)
+
'
:
'
+
(
0
_emberUtils
.
guidFor
)
(
this
)
+
extension
+
'
>
'
;
return
ret
;
}
_Mixin
create
)
)
;
CoreObject
.
PrototypeMixin
.
ownerConstructor
=
CoreObject
;
CoreObject
.
__super__
=
null
;
var
ClassMixinProps
=
(
_ClassMixinProps
=
{
isClass
:
true
isMethod
:
false
}
_ClassMixinProps
[
_emberUtils
.
NAME_KEY
]
=
null
_ClassMixinProps
[
_emberUtils
.
GUID_KEY
]
=
null
_ClassMixinProps
.
extend
=
function
(
)
{
var
Class
=
makeCtor
(
)
;
var
proto
=
void
0
;
Class
.
ClassMixin
=
_emberMetal
.
Mixin
.
create
(
this
.
ClassMixin
)
;
Class
.
PrototypeMixin
=
_emberMetal
.
Mixin
.
create
(
this
.
PrototypeMixin
)
;
Class
.
ClassMixin
.
ownerConstructor
=
Class
;
Class
.
PrototypeMixin
.
ownerConstructor
=
Class
;
reopen
.
apply
(
Class
.
PrototypeMixin
arguments
)
;
Class
.
superclass
=
this
;
Class
.
__super__
=
this
.
prototype
;
proto
=
Class
.
prototype
=
Object
.
create
(
this
.
prototype
)
;
proto
.
constructor
=
Class
;
(
0
_emberUtils
.
generateGuid
)
(
proto
)
;
(
0
_emberMetal
.
meta
)
(
proto
)
.
proto
=
proto
;
Class
.
ClassMixin
.
apply
(
Class
)
;
return
Class
;
}
_ClassMixinProps
.
create
=
function
(
)
{
var
C
=
this
;
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
if
(
args
.
length
>
0
)
{
this
.
_initProperties
(
args
)
;
}
return
new
C
(
)
;
}
_ClassMixinProps
.
reopen
=
function
(
)
{
this
.
willReopen
(
)
;
reopen
.
apply
(
this
.
PrototypeMixin
arguments
)
;
return
this
;
}
_ClassMixinProps
.
reopenClass
=
function
(
)
{
reopen
.
apply
(
this
.
ClassMixin
arguments
)
;
applyMixin
(
this
arguments
false
)
;
return
this
;
}
_ClassMixinProps
.
detect
=
function
(
obj
)
{
if
(
'
function
'
!
=
=
typeof
obj
)
{
return
false
;
}
while
(
obj
)
{
if
(
obj
=
=
=
this
)
{
return
true
;
}
obj
=
obj
.
superclass
;
}
return
false
;
}
_ClassMixinProps
.
detectInstance
=
function
(
obj
)
{
return
obj
instanceof
this
;
}
_ClassMixinProps
.
metaForProperty
=
function
(
key
)
{
var
proto
=
this
.
proto
(
)
;
var
possibleDesc
=
(
0
_emberMetal
.
descriptorFor
)
(
proto
key
)
;
(
true
&
&
!
(
possibleDesc
!
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
metaForProperty
(
)
could
not
find
a
computed
property
with
key
\
'
'
+
key
+
'
\
'
.
'
possibleDesc
!
=
=
undefined
)
)
;
return
possibleDesc
.
_meta
|
|
{
}
;
}
_ClassMixinProps
.
_computedProperties
=
(
0
_emberMetal
.
computed
)
(
function
(
)
{
(
0
_emberMetal
.
_hasCachedComputedProperties
)
(
)
;
var
proto
=
this
.
proto
(
)
;
var
possibleDesc
=
void
0
;
var
properties
=
[
]
;
for
(
var
name
in
proto
)
{
possibleDesc
=
(
0
_emberMetal
.
descriptorFor
)
(
proto
name
)
;
if
(
possibleDesc
!
=
=
undefined
)
{
properties
.
push
(
{
name
:
name
meta
:
possibleDesc
.
_meta
}
)
;
}
}
return
properties
;
}
)
.
readOnly
(
)
_ClassMixinProps
.
eachComputedProperty
=
function
(
callback
binding
)
{
var
property
=
void
0
;
var
empty
=
{
}
;
var
properties
=
(
0
_emberMetal
.
get
)
(
this
'
_computedProperties
'
)
;
for
(
var
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
property
=
properties
[
i
]
;
callback
.
call
(
binding
|
|
this
property
.
name
property
.
meta
|
|
empty
)
;
}
}
_ClassMixinProps
)
;
if
(
_emberEnvironment
.
ENV
.
_ENABLE_PROPERTY_REQUIRED_SUPPORT
)
{
ClassMixinProps
.
ClassMixin
=
_emberMetal
.
REQUIRED
;
ClassMixinProps
.
PrototypeMixin
=
_emberMetal
.
REQUIRED
;
}
function
injectedPropertyAssertion
(
)
{
(
true
&
&
!
(
(
0
_inject
.
validatePropertyInjections
)
(
this
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Injected
properties
are
invalid
'
(
0
_inject
.
validatePropertyInjections
)
(
this
)
)
)
;
}
if
(
true
)
{
ClassMixinProps
.
_onLookup
=
injectedPropertyAssertion
;
ClassMixinProps
.
_lazyInjections
=
function
(
)
{
var
injections
=
{
}
;
var
proto
=
this
.
proto
(
)
;
var
key
=
void
0
;
var
desc
=
void
0
;
for
(
key
in
proto
)
{
desc
=
(
0
_emberMetal
.
descriptorFor
)
(
proto
key
)
;
if
(
desc
instanceof
_emberMetal
.
InjectedProperty
)
{
injections
[
key
]
=
desc
.
type
+
'
:
'
+
(
desc
.
name
|
|
key
)
;
}
}
return
injections
;
}
;
}
var
ClassMixin
=
_emberMetal
.
Mixin
.
create
(
ClassMixinProps
)
;
ClassMixin
.
ownerConstructor
=
CoreObject
;
CoreObject
.
ClassMixin
=
ClassMixin
;
ClassMixin
.
apply
(
CoreObject
)
;
exports
.
default
=
CoreObject
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
lazy_load
'
[
'
exports
'
'
ember
-
environment
'
]
function
(
exports
_emberEnvironment
)
{
'
use
strict
'
;
exports
.
_loaded
=
undefined
;
exports
.
onLoad
=
onLoad
;
exports
.
runLoadHooks
=
runLoadHooks
;
var
loadHooks
=
_emberEnvironment
.
ENV
.
EMBER_LOAD_HOOKS
|
|
{
}
;
var
loaded
=
{
}
;
var
_loaded
=
exports
.
_loaded
=
loaded
;
function
onLoad
(
name
callback
)
{
var
object
=
loaded
[
name
]
;
loadHooks
[
name
]
=
loadHooks
[
name
]
|
|
[
]
;
loadHooks
[
name
]
.
push
(
callback
)
;
if
(
object
)
{
callback
(
object
)
;
}
}
function
runLoadHooks
(
name
object
)
{
loaded
[
name
]
=
object
;
var
window
=
_emberEnvironment
.
environment
.
window
;
if
(
window
&
&
typeof
CustomEvent
=
=
=
'
function
'
)
{
var
event
=
new
CustomEvent
(
name
{
detail
:
object
name
:
name
}
)
;
window
.
dispatchEvent
(
event
)
;
}
if
(
loadHooks
[
name
]
)
{
loadHooks
[
name
]
.
forEach
(
function
(
callback
)
{
return
callback
(
object
)
;
}
)
;
}
}
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
namespace
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
environment
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberUtils
_emberMetal
_emberEnvironment
_object
)
{
'
use
strict
'
;
exports
.
isSearchDisabled
=
isSearchDisabled
;
exports
.
setSearchDisabled
=
setSearchDisabled
;
var
searchDisabled
=
false
;
function
isSearchDisabled
(
)
{
return
searchDisabled
;
}
function
setSearchDisabled
(
flag
)
{
searchDisabled
=
!
!
flag
;
}
var
Namespace
=
_object
.
default
.
extend
(
{
isNamespace
:
true
init
:
function
(
)
{
Namespace
.
NAMESPACES
.
push
(
this
)
;
Namespace
.
PROCESSED
=
false
;
}
toString
:
function
(
)
{
var
name
=
(
0
_emberMetal
.
get
)
(
this
'
name
'
)
|
|
(
0
_emberMetal
.
get
)
(
this
'
modulePrefix
'
)
;
if
(
name
)
{
return
name
;
}
findNamespaces
(
)
;
return
this
[
_emberUtils
.
NAME_KEY
]
;
}
nameClasses
:
function
(
)
{
processNamespace
(
[
this
.
toString
(
)
]
this
{
}
)
;
}
destroy
:
function
(
)
{
var
namespaces
=
Namespace
.
NAMESPACES
;
var
toString
=
this
.
toString
(
)
;
if
(
toString
)
{
_emberEnvironment
.
context
.
lookup
[
toString
]
=
undefined
;
delete
Namespace
.
NAMESPACES_BY_ID
[
toString
]
;
}
namespaces
.
splice
(
namespaces
.
indexOf
(
this
)
1
)
;
this
.
_super
.
apply
(
this
arguments
)
;
}
}
)
;
Namespace
.
reopenClass
(
{
NAMESPACES
:
[
_emberMetal
.
default
]
NAMESPACES_BY_ID
:
{
Ember
:
_emberMetal
.
default
}
PROCESSED
:
false
processAll
:
processAllNamespaces
byName
:
function
(
name
)
{
if
(
!
searchDisabled
)
{
processAllNamespaces
(
)
;
}
return
NAMESPACES_BY_ID
[
name
]
;
}
}
)
;
var
NAMESPACES_BY_ID
=
Namespace
.
NAMESPACES_BY_ID
;
var
hasOwnProp
=
{
}
.
hasOwnProperty
;
function
processNamespace
(
paths
root
seen
)
{
var
idx
=
paths
.
length
;
NAMESPACES_BY_ID
[
paths
.
join
(
'
.
'
)
]
=
root
;
for
(
var
key
in
root
)
{
if
(
!
hasOwnProp
.
call
(
root
key
)
)
{
continue
;
}
var
obj
=
root
[
key
]
;
paths
[
idx
]
=
key
;
if
(
obj
&
&
obj
.
toString
=
=
=
classToString
&
&
!
obj
[
_emberUtils
.
NAME_KEY
]
)
{
obj
[
_emberUtils
.
NAME_KEY
]
=
paths
.
join
(
'
.
'
)
;
}
else
if
(
obj
&
&
obj
.
isNamespace
)
{
if
(
seen
[
(
0
_emberUtils
.
guidFor
)
(
obj
)
]
)
{
continue
;
}
seen
[
(
0
_emberUtils
.
guidFor
)
(
obj
)
]
=
true
;
processNamespace
(
paths
obj
seen
)
;
}
}
paths
.
length
=
idx
;
}
function
isUppercase
(
code
)
{
return
code
>
=
65
&
&
code
<
=
90
;
}
function
tryIsNamespace
(
lookup
prop
)
{
try
{
var
obj
=
lookup
[
prop
]
;
return
obj
&
&
obj
.
isNamespace
&
&
obj
;
}
catch
(
e
)
{
}
}
function
findNamespaces
(
)
{
if
(
Namespace
.
PROCESSED
)
{
return
;
}
var
lookup
=
_emberEnvironment
.
context
.
lookup
;
var
keys
=
Object
.
keys
(
lookup
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
if
(
!
isUppercase
(
key
.
charCodeAt
(
0
)
)
)
{
continue
;
}
var
obj
=
tryIsNamespace
(
lookup
key
)
;
if
(
obj
)
{
obj
[
_emberUtils
.
NAME_KEY
]
=
key
;
}
}
}
function
superClassString
(
mixin
)
{
var
superclass
=
mixin
.
superclass
;
if
(
superclass
)
{
if
(
superclass
[
_emberUtils
.
NAME_KEY
]
)
{
return
superclass
[
_emberUtils
.
NAME_KEY
]
;
}
return
superClassString
(
superclass
)
;
}
}
function
calculateToString
(
target
)
{
var
str
=
void
0
;
if
(
!
searchDisabled
)
{
processAllNamespaces
(
)
;
str
=
target
[
_emberUtils
.
NAME_KEY
]
;
if
(
str
)
{
return
str
;
}
else
{
str
=
superClassString
(
target
)
;
str
=
str
?
'
(
subclass
of
'
+
str
+
'
)
'
:
str
;
}
}
if
(
str
)
{
return
str
;
}
else
{
return
'
(
unknown
mixin
)
'
;
}
}
function
classToString
(
)
{
var
name
=
this
[
_emberUtils
.
NAME_KEY
]
;
if
(
name
)
{
return
name
;
}
return
this
[
_emberUtils
.
NAME_KEY
]
=
calculateToString
(
this
)
;
}
function
processAllNamespaces
(
)
{
var
unprocessedNamespaces
=
!
Namespace
.
PROCESSED
;
var
unprocessedMixins
=
(
0
_emberMetal
.
hasUnprocessedMixins
)
(
)
;
if
(
unprocessedNamespaces
)
{
findNamespaces
(
)
;
Namespace
.
PROCESSED
=
true
;
}
if
(
unprocessedNamespaces
|
|
unprocessedMixins
)
{
var
namespaces
=
Namespace
.
NAMESPACES
;
var
namespace
=
void
0
;
for
(
var
i
=
0
;
i
<
namespaces
.
length
;
i
+
+
)
{
namespace
=
namespaces
[
i
]
;
processNamespace
(
[
namespace
.
toString
(
)
]
namespace
{
}
)
;
}
(
0
_emberMetal
.
clearUnprocessedMixins
)
(
)
;
}
}
_emberMetal
.
Mixin
.
prototype
.
toString
=
classToString
;
exports
.
default
=
Namespace
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
native_array
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
environment
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
observable
'
'
ember
-
runtime
/
mixins
/
copyable
'
'
ember
-
debug
'
'
ember
-
runtime
/
copy
'
]
function
(
exports
_emberMetal
_emberEnvironment
_array
_mutable_array
_observable
_copyable
_emberDebug
_copy
)
{
'
use
strict
'
;
exports
.
NativeArray
=
exports
.
A
=
undefined
;
var
_NativeArray
;
var
NativeArray
=
_emberMetal
.
Mixin
.
create
(
_mutable_array
.
default
_observable
.
default
_copyable
.
default
{
get
:
function
(
key
)
{
if
(
'
number
'
=
=
=
typeof
key
)
{
return
this
[
key
]
;
}
else
{
return
this
.
_super
(
key
)
;
}
}
objectAt
:
function
(
idx
)
{
return
this
[
idx
]
;
}
replace
:
function
(
idx
amt
objects
)
{
(
true
&
&
!
(
objects
=
=
=
null
|
|
objects
=
=
=
undefined
|
|
Array
.
isArray
(
objects
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
third
argument
to
replace
needs
to
be
an
array
.
'
objects
=
=
=
null
|
|
objects
=
=
=
undefined
|
|
Array
.
isArray
(
objects
)
)
)
;
var
len
=
objects
?
(
0
_emberMetal
.
get
)
(
objects
'
length
'
)
:
0
;
(
0
_array
.
arrayContentWillChange
)
(
this
idx
amt
len
)
;
if
(
len
=
=
=
0
)
{
this
.
splice
(
idx
amt
)
;
}
else
{
(
0
_emberMetal
.
replace
)
(
this
idx
amt
objects
)
;
}
(
0
_array
.
arrayContentDidChange
)
(
this
idx
amt
len
)
;
return
this
;
}
unknownProperty
:
function
(
key
value
)
{
var
ret
=
void
0
;
if
(
value
!
=
=
undefined
&
&
ret
=
=
=
undefined
)
{
ret
=
this
[
key
]
=
value
;
}
return
ret
;
}
indexOf
:
Array
.
prototype
.
indexOf
lastIndexOf
:
Array
.
prototype
.
lastIndexOf
copy
:
function
(
deep
)
{
if
(
deep
)
{
return
this
.
map
(
function
(
item
)
{
return
(
0
_copy
.
default
)
(
item
true
)
;
}
)
;
}
return
this
.
slice
(
)
;
}
}
)
;
var
ignore
=
[
'
length
'
]
;
NativeArray
.
keys
(
)
.
forEach
(
function
(
methodName
)
{
if
(
Array
.
prototype
[
methodName
]
)
{
ignore
.
push
(
methodName
)
;
}
}
)
;
exports
.
NativeArray
=
NativeArray
=
(
_NativeArray
=
NativeArray
)
.
without
.
apply
(
_NativeArray
ignore
)
;
var
A
=
void
0
;
if
(
_emberEnvironment
.
ENV
.
EXTEND_PROTOTYPES
.
Array
)
{
NativeArray
.
apply
(
Array
.
prototype
)
;
exports
.
A
=
A
=
function
(
arr
)
{
return
arr
|
|
[
]
;
}
;
}
else
{
exports
.
A
=
A
=
function
(
arr
)
{
if
(
!
arr
)
{
arr
=
[
]
;
}
return
_array
.
default
.
detect
(
arr
)
?
arr
:
NativeArray
.
apply
(
arr
)
;
}
;
}
_emberMetal
.
default
.
A
=
A
;
exports
.
A
=
A
;
exports
.
NativeArray
=
NativeArray
;
exports
.
default
=
NativeArray
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
object
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
runtime
/
mixins
/
observable
'
'
ember
-
debug
'
]
function
(
exports
_emberUtils
_emberMetal
_core_object
_observable
_emberDebug
)
{
'
use
strict
'
;
exports
.
FrameworkObject
=
undefined
;
var
_CoreObject
extend
;
var
OVERRIDE_OWNER
=
(
0
_emberUtils
.
symbol
)
(
'
OVERRIDE_OWNER
'
)
;
var
EmberObject
=
_core_object
.
default
.
extend
(
_observable
.
default
(
_CoreObject
extend
=
{
_debugContainerKey
:
(
0
_emberMetal
.
descriptor
)
(
{
enumerable
:
false
get
:
function
(
)
{
var
meta
=
(
0
_emberMetal
.
peekMeta
)
(
this
)
;
var
factory
=
meta
.
factory
;
return
factory
&
&
factory
.
fullName
;
}
}
)
}
_CoreObject
extend
[
_emberUtils
.
OWNER
]
=
(
0
_emberMetal
.
descriptor
)
(
{
enumerable
:
false
get
:
function
(
)
{
if
(
this
[
OVERRIDE_OWNER
]
)
{
return
this
[
OVERRIDE_OWNER
]
;
}
var
meta
=
(
0
_emberMetal
.
peekMeta
)
(
this
)
;
var
factory
=
meta
.
factory
;
return
factory
&
&
factory
.
owner
;
}
set
:
function
(
value
)
{
this
[
OVERRIDE_OWNER
]
=
value
;
}
}
)
_CoreObject
extend
)
)
;
EmberObject
.
toString
=
function
(
)
{
return
'
Ember
.
Object
'
;
}
;
var
FrameworkObject
=
exports
.
FrameworkObject
=
EmberObject
;
if
(
true
)
{
var
_EmberObject
extend
;
var
INIT_WAS_CALLED
=
(
0
_emberUtils
.
symbol
)
(
'
INIT_WAS_CALLED
'
)
;
var
ASSERT_INIT_WAS_CALLED
=
(
0
_emberUtils
.
symbol
)
(
'
ASSERT_INIT_WAS_CALLED
'
)
;
exports
.
FrameworkObject
=
FrameworkObject
=
EmberObject
.
extend
(
(
_EmberObject
extend
=
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
[
INIT_WAS_CALLED
]
=
true
;
}
}
_EmberObject
extend
[
ASSERT_INIT_WAS_CALLED
]
=
(
0
_emberMetal
.
on
)
(
'
init
'
function
(
)
{
(
true
&
&
!
(
this
[
INIT_WAS_CALLED
]
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
must
call
this
.
_super
(
.
.
.
arguments
)
;
when
overriding
init
on
a
framework
object
.
Please
update
'
+
this
+
'
to
call
this
.
_super
(
.
.
.
arguments
)
;
from
init
.
'
this
[
INIT_WAS_CALLED
]
)
)
;
}
)
_EmberObject
extend
)
)
;
}
exports
.
default
=
EmberObject
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
object_proxy
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
-
proxy
'
]
function
(
exports
_object
_proxy
)
{
'
use
strict
'
;
exports
.
default
=
_object
.
default
.
extend
(
_proxy
.
default
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
service
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
inject
'
]
function
(
exports
_object
_inject
)
{
'
use
strict
'
;
(
0
_inject
.
createInjectionHelper
)
(
'
service
'
)
;
var
Service
=
_object
.
default
.
extend
(
)
;
Service
.
reopenClass
(
{
isServiceFactory
:
true
}
)
;
exports
.
default
=
Service
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
string
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
utils
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
string_registry
'
]
function
(
exports
_emberMetal
_emberUtils
_utils
_string_registry
)
{
'
use
strict
'
;
exports
.
capitalize
=
exports
.
underscore
=
exports
.
classify
=
exports
.
camelize
=
exports
.
dasherize
=
exports
.
decamelize
=
exports
.
w
=
exports
.
loc
=
undefined
;
var
STRING_DASHERIZE_REGEXP
=
/
[
_
]
/
g
;
var
STRING_DASHERIZE_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
key
)
{
return
decamelize
(
key
)
.
replace
(
STRING_DASHERIZE_REGEXP
'
-
'
)
;
}
)
;
var
STRING_CAMELIZE_REGEXP_1
=
/
(
\
-
|
\
_
|
\
.
|
\
s
)
+
(
.
)
?
/
g
;
var
STRING_CAMELIZE_REGEXP_2
=
/
(
^
|
\
/
)
(
[
A
-
Z
]
)
/
g
;
var
CAMELIZE_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
key
)
{
return
key
.
replace
(
STRING_CAMELIZE_REGEXP_1
function
(
match
separator
chr
)
{
return
chr
?
chr
.
toUpperCase
(
)
:
'
'
;
}
)
.
replace
(
STRING_CAMELIZE_REGEXP_2
function
(
match
)
{
return
match
.
toLowerCase
(
)
;
}
)
;
}
)
;
var
STRING_CLASSIFY_REGEXP_1
=
/
^
(
\
-
|
_
)
+
(
.
)
?
/
;
var
STRING_CLASSIFY_REGEXP_2
=
/
(
.
)
(
\
-
|
\
_
|
\
.
|
\
s
)
+
(
.
)
?
/
g
;
var
STRING_CLASSIFY_REGEXP_3
=
/
(
^
|
\
/
|
\
.
)
(
[
a
-
z
]
)
/
g
;
var
CLASSIFY_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
str
)
{
var
replace1
=
function
(
match
separator
chr
)
{
return
chr
?
'
_
'
+
chr
.
toUpperCase
(
)
:
'
'
;
}
;
var
replace2
=
function
(
match
initialChar
separator
chr
)
{
return
initialChar
+
(
chr
?
chr
.
toUpperCase
(
)
:
'
'
)
;
}
;
var
parts
=
str
.
split
(
'
/
'
)
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
parts
[
i
]
=
parts
[
i
]
.
replace
(
STRING_CLASSIFY_REGEXP_1
replace1
)
.
replace
(
STRING_CLASSIFY_REGEXP_2
replace2
)
;
}
return
parts
.
join
(
'
/
'
)
.
replace
(
STRING_CLASSIFY_REGEXP_3
function
(
match
)
{
return
match
.
toUpperCase
(
)
;
}
)
;
}
)
;
var
STRING_UNDERSCORE_REGEXP_1
=
/
(
[
a
-
z
\
d
]
)
(
[
A
-
Z
]
+
)
/
g
;
var
STRING_UNDERSCORE_REGEXP_2
=
/
\
-
|
\
s
+
/
g
;
var
UNDERSCORE_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_UNDERSCORE_REGEXP_1
'
1_
2
'
)
.
replace
(
STRING_UNDERSCORE_REGEXP_2
'
_
'
)
.
toLowerCase
(
)
;
}
)
;
var
STRING_CAPITALIZE_REGEXP
=
/
(
^
|
\
/
)
(
[
a
-
z
\
u00C0
-
\
u024F
]
)
/
g
;
var
CAPITALIZE_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_CAPITALIZE_REGEXP
function
(
match
)
{
return
match
.
toUpperCase
(
)
;
}
)
;
}
)
;
var
STRING_DECAMELIZE_REGEXP
=
/
(
[
a
-
z
\
d
]
)
(
[
A
-
Z
]
)
/
g
;
var
DECAMELIZE_CACHE
=
new
_emberMetal
.
Cache
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_DECAMELIZE_REGEXP
'
1_
2
'
)
.
toLowerCase
(
)
;
}
)
;
function
_fmt
(
str
formats
)
{
var
cachedFormats
=
formats
;
if
(
!
(
0
_utils
.
isArray
)
(
cachedFormats
)
|
|
arguments
.
length
>
2
)
{
cachedFormats
=
new
Array
(
arguments
.
length
-
1
)
;
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
cachedFormats
[
i
-
1
]
=
arguments
[
i
]
;
}
}
var
idx
=
0
;
return
str
.
replace
(
/
%
(
[
0
-
9
]
+
)
?
/
g
function
(
s
argIndex
)
{
argIndex
=
argIndex
?
parseInt
(
argIndex
10
)
-
1
:
idx
+
+
;
s
=
cachedFormats
[
argIndex
]
;
return
s
=
=
=
null
?
'
(
null
)
'
:
s
=
=
=
undefined
?
'
'
:
(
0
_emberUtils
.
inspect
)
(
s
)
;
}
)
;
}
function
loc
(
str
formats
)
{
if
(
!
(
0
_utils
.
isArray
)
(
formats
)
|
|
arguments
.
length
>
2
)
{
formats
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
}
str
=
(
0
_string_registry
.
get
)
(
str
)
|
|
str
;
return
_fmt
(
str
formats
)
;
}
function
w
(
str
)
{
return
str
.
split
(
/
\
s
+
/
)
;
}
function
decamelize
(
str
)
{
return
DECAMELIZE_CACHE
.
get
(
str
)
;
}
function
dasherize
(
str
)
{
return
STRING_DASHERIZE_CACHE
.
get
(
str
)
;
}
function
camelize
(
str
)
{
return
CAMELIZE_CACHE
.
get
(
str
)
;
}
function
classify
(
str
)
{
return
CLASSIFY_CACHE
.
get
(
str
)
;
}
function
underscore
(
str
)
{
return
UNDERSCORE_CACHE
.
get
(
str
)
;
}
function
capitalize
(
str
)
{
return
CAPITALIZE_CACHE
.
get
(
str
)
;
}
exports
.
default
=
{
loc
:
loc
w
:
w
decamelize
:
decamelize
dasherize
:
dasherize
camelize
:
camelize
classify
:
classify
underscore
:
underscore
capitalize
:
capitalize
}
;
exports
.
loc
=
loc
;
exports
.
w
=
w
;
exports
.
decamelize
=
decamelize
;
exports
.
dasherize
=
dasherize
;
exports
.
camelize
=
camelize
;
exports
.
classify
=
classify
;
exports
.
underscore
=
underscore
;
exports
.
capitalize
=
capitalize
;
}
)
;
enifed
(
'
ember
-
runtime
/
utils
'
[
'
exports
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_array
_object
)
{
'
use
strict
'
;
exports
.
isArray
=
isArray
;
exports
.
typeOf
=
typeOf
;
var
TYPE_MAP
=
{
'
[
object
Boolean
]
'
:
'
boolean
'
'
[
object
Number
]
'
:
'
number
'
'
[
object
String
]
'
:
'
string
'
'
[
object
Function
]
'
:
'
function
'
'
[
object
Array
]
'
:
'
array
'
'
[
object
Date
]
'
:
'
date
'
'
[
object
RegExp
]
'
:
'
regexp
'
'
[
object
Object
]
'
:
'
object
'
'
[
object
FileList
]
'
:
'
filelist
'
}
;
var
toString
=
Object
.
prototype
.
toString
;
function
isArray
(
obj
)
{
if
(
!
obj
|
|
obj
.
setInterval
)
{
return
false
;
}
if
(
Array
.
isArray
(
obj
)
)
{
return
true
;
}
if
(
_array
.
default
.
detect
(
obj
)
)
{
return
true
;
}
var
type
=
typeOf
(
obj
)
;
if
(
'
array
'
=
=
=
type
)
{
return
true
;
}
var
length
=
obj
.
length
;
if
(
typeof
length
=
=
=
'
number
'
&
&
length
=
=
=
length
&
&
'
object
'
=
=
=
type
)
{
return
true
;
}
return
false
;
}
function
typeOf
(
item
)
{
if
(
item
=
=
=
null
)
{
return
'
null
'
;
}
if
(
item
=
=
=
undefined
)
{
return
'
undefined
'
;
}
var
ret
=
TYPE_MAP
[
toString
.
call
(
item
)
]
|
|
'
object
'
;
if
(
ret
=
=
=
'
function
'
)
{
if
(
_object
.
default
.
detect
(
item
)
)
{
ret
=
'
class
'
;
}
}
else
if
(
ret
=
=
=
'
object
'
)
{
if
(
item
instanceof
Error
)
{
ret
=
'
error
'
;
}
else
if
(
item
instanceof
_object
.
default
)
{
ret
=
'
instance
'
;
}
else
if
(
item
instanceof
Date
)
{
ret
=
'
date
'
;
}
}
return
ret
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
compat
'
[
'
ember
-
metal
'
'
ember
-
template
-
compiler
/
system
/
precompile
'
'
ember
-
template
-
compiler
/
system
/
compile
'
'
ember
-
template
-
compiler
/
system
/
compile
-
options
'
]
function
(
_emberMetal
_precompile
_compile
_compileOptions
)
{
'
use
strict
'
;
var
EmberHandlebars
=
_emberMetal
.
default
.
Handlebars
=
_emberMetal
.
default
.
Handlebars
|
|
{
}
;
var
EmberHTMLBars
=
_emberMetal
.
default
.
HTMLBars
=
_emberMetal
.
default
.
HTMLBars
|
|
{
}
;
EmberHTMLBars
.
precompile
=
EmberHandlebars
.
precompile
=
_precompile
.
default
;
EmberHTMLBars
.
compile
=
EmberHandlebars
.
compile
=
_compile
.
default
;
EmberHTMLBars
.
registerPlugin
=
_compileOptions
.
registerPlugin
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
index
'
[
'
exports
'
'
ember
-
template
-
compiler
/
system
/
precompile
'
'
ember
-
template
-
compiler
/
system
/
compile
'
'
ember
-
template
-
compiler
/
system
/
compile
-
options
'
'
ember
-
template
-
compiler
/
plugins
'
'
ember
-
metal
'
'
ember
/
features
'
'
ember
-
environment
'
'
ember
/
version
'
'
ember
-
template
-
compiler
/
compat
'
'
ember
-
template
-
compiler
/
system
/
bootstrap
'
]
function
(
exports
_precompile
_compile
_compileOptions
_plugins
_emberMetal
_features
_emberEnvironment
_version
)
{
'
use
strict
'
;
exports
.
defaultPlugins
=
exports
.
unregisterPlugin
=
exports
.
registerPlugin
=
exports
.
compileOptions
=
exports
.
compile
=
exports
.
precompile
=
exports
.
_Ember
=
undefined
;
Object
.
defineProperty
(
exports
'
precompile
'
{
enumerable
:
true
get
:
function
(
)
{
return
_precompile
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
compile
'
{
enumerable
:
true
get
:
function
(
)
{
return
_compile
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
compileOptions
'
{
enumerable
:
true
get
:
function
(
)
{
return
_compileOptions
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
registerPlugin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_compileOptions
.
registerPlugin
;
}
}
)
;
Object
.
defineProperty
(
exports
'
unregisterPlugin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_compileOptions
.
unregisterPlugin
;
}
}
)
;
Object
.
defineProperty
(
exports
'
defaultPlugins
'
{
enumerable
:
true
get
:
function
(
)
{
return
_plugins
.
default
;
}
}
)
;
if
(
!
_emberMetal
.
default
.
ENV
)
{
_emberMetal
.
default
.
ENV
=
_emberEnvironment
.
ENV
;
}
if
(
!
_emberMetal
.
default
.
FEATURES
)
{
_emberMetal
.
default
.
FEATURES
=
_features
.
FEATURES
;
}
if
(
!
_emberMetal
.
default
.
VERSION
)
{
_emberMetal
.
default
.
VERSION
=
_version
.
default
;
}
exports
.
_Ember
=
_emberMetal
.
default
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
assert
-
input
-
helper
-
without
-
block
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberDebug
_calculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
errorOnInputWithContent
;
function
errorOnInputWithContent
(
env
)
{
var
moduleName
=
env
.
meta
.
moduleName
;
return
{
name
:
'
assert
-
input
-
helper
-
without
-
block
'
visitors
:
{
BlockStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
!
=
=
'
input
'
)
{
return
;
}
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
assertMessage
(
moduleName
node
)
)
)
;
}
}
}
;
}
function
assertMessage
(
moduleName
node
)
{
var
sourceInformation
=
(
0
_calculateLocationDisplay
.
default
)
(
moduleName
node
.
loc
)
;
return
'
The
{
{
input
}
}
helper
cannot
be
used
in
block
form
.
'
+
sourceInformation
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
assert
-
reserved
-
named
-
arguments
'
[
'
exports
'
'
ember
-
debug
'
'
ember
/
features
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberDebug
_features
_calculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
assertReservedNamedArguments
;
var
RESERVED
=
[
'
arguments
'
'
args
'
]
;
var
isReserved
=
void
0
assertMessage
=
void
0
;
function
assertReservedNamedArguments
(
env
)
{
var
moduleName
=
env
.
meta
.
moduleName
;
return
{
name
:
'
assert
-
reserved
-
named
-
arguments
'
visitors
:
{
PathExpression
:
function
(
_ref
)
{
var
original
=
_ref
.
original
loc
=
_ref
.
loc
;
if
(
isReserved
(
original
)
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
assert
)
(
assertMessage
(
original
)
+
'
'
+
(
0
_calculateLocationDisplay
.
default
)
(
moduleName
loc
)
)
)
;
}
}
}
}
;
}
if
(
_features
.
EMBER_GLIMMER_NAMED_ARGUMENTS
)
{
isReserved
=
function
(
name
)
{
return
RESERVED
.
indexOf
(
name
)
!
=
=
-
1
|
|
name
.
match
(
/
^
[
^
a
-
z
]
/
)
;
}
;
assertMessage
=
function
(
name
)
{
return
'
\
'
'
+
name
+
'
\
'
is
reserved
.
'
;
}
;
}
else
{
isReserved
=
function
(
name
)
{
return
name
[
0
]
=
=
=
'
'
;
}
;
assertMessage
=
function
(
name
)
{
return
'
\
'
'
+
name
+
'
\
'
is
not
a
valid
path
.
'
;
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
-
model
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberDebug
_calculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
deprecateRenderModel
;
function
deprecateRenderModel
(
env
)
{
var
moduleName
=
env
.
meta
.
moduleName
;
return
{
name
:
'
deprecate
-
render
-
model
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
=
=
=
'
render
'
&
&
node
.
params
.
length
>
1
)
{
node
.
params
.
forEach
(
function
(
param
)
{
if
(
param
.
type
!
=
=
'
PathExpression
'
)
{
return
;
}
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
deprecationMessage
(
moduleName
node
param
)
false
{
id
:
'
ember
-
template
-
compiler
.
deprecate
-
render
-
model
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_model
-
param
-
in
-
code
-
render
-
code
-
helper
'
}
)
)
;
}
)
;
}
}
}
}
;
}
function
deprecationMessage
(
moduleName
node
param
)
{
var
sourceInformation
=
(
0
_calculateLocationDisplay
.
default
)
(
moduleName
node
.
loc
)
;
var
componentName
=
node
.
params
[
0
]
.
original
;
var
modelName
=
param
.
original
;
var
original
=
'
{
{
render
"
'
+
componentName
+
'
"
'
+
modelName
+
'
}
}
'
;
var
preferred
=
'
{
{
'
+
componentName
+
'
model
=
'
+
modelName
+
'
}
}
'
;
return
'
Please
refactor
'
+
original
+
'
to
a
component
and
invoke
via
'
+
(
'
'
+
preferred
+
'
.
'
+
sourceInformation
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberDebug
_calculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
deprecateRender
;
function
deprecateRender
(
env
)
{
var
moduleName
=
env
.
meta
.
moduleName
;
return
{
name
:
'
deprecate
-
render
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
!
=
=
'
render
'
)
{
return
;
}
if
(
node
.
params
.
length
!
=
=
1
)
{
return
;
}
each
(
node
.
params
function
(
param
)
{
if
(
param
.
type
!
=
=
'
StringLiteral
'
)
{
return
;
}
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
deprecationMessage
(
moduleName
node
)
false
{
id
:
'
ember
-
template
-
compiler
.
deprecate
-
render
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_code
-
render
-
code
-
helper
'
}
)
)
;
}
)
;
}
}
}
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
function
deprecationMessage
(
moduleName
node
)
{
var
sourceInformation
=
(
0
_calculateLocationDisplay
.
default
)
(
moduleName
node
.
loc
)
;
var
componentName
=
node
.
params
[
0
]
.
original
;
var
original
=
'
{
{
render
"
'
+
componentName
+
'
"
}
}
'
;
var
preferred
=
'
{
{
'
+
componentName
+
'
}
}
'
;
return
'
Please
refactor
'
+
original
+
'
to
a
component
and
invoke
via
'
+
(
'
'
+
preferred
+
'
.
'
+
sourceInformation
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
extract
-
pragma
-
tag
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
extractPragmaTag
;
var
PRAGMA_TAG
=
'
use
-
component
-
manager
'
;
function
extractPragmaTag
(
env
)
{
var
meta
=
env
.
meta
;
return
{
name
:
'
exract
-
pragma
-
tag
'
visitors
:
{
MustacheStatement
:
{
enter
:
function
(
node
)
{
if
(
node
.
path
.
type
=
=
=
'
PathExpression
'
&
&
node
.
path
.
original
=
=
=
PRAGMA_TAG
)
{
meta
.
managerId
=
node
.
params
[
0
]
.
value
;
return
null
;
}
}
}
}
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
index
'
[
'
exports
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
binding
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
angle
-
bracket
-
components
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
top
-
level
-
components
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
inline
-
link
-
to
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
class
-
binding
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
quoted
-
bindings
-
into
-
just
-
bindings
'
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
-
model
'
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
'
'
ember
-
template
-
compiler
/
plugins
/
assert
-
reserved
-
named
-
arguments
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
action
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
input
-
type
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
attrs
-
into
-
args
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
each
-
in
-
into
-
each
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
has
-
block
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
dot
-
component
-
invocation
'
'
ember
-
template
-
compiler
/
plugins
/
extract
-
pragma
-
tag
'
'
ember
-
template
-
compiler
/
plugins
/
assert
-
input
-
helper
-
without
-
block
'
'
ember
/
features
'
]
function
(
exports
_transformOldBindingSyntax
_transformAngleBracketComponents
_transformTopLevelComponents
_transformInlineLinkTo
_transformOldClassBindingSyntax
_transformQuotedBindingsIntoJustBindings
_deprecateRenderModel
_deprecateRender
_assertReservedNamedArguments
_transformActionSyntax
_transformInputTypeSyntax
_transformAttrsIntoArgs
_transformEachInIntoEach
_transformHasBlockSyntax
_transformDotComponentInvocation
_extractPragmaTag
_assertInputHelperWithoutBlock
_features
)
{
'
use
strict
'
;
var
transforms
=
[
_transformDotComponentInvocation
.
default
_transformOldBindingSyntax
.
default
_transformAngleBracketComponents
.
default
_transformTopLevelComponents
.
default
_transformInlineLinkTo
.
default
_transformOldClassBindingSyntax
.
default
_transformQuotedBindingsIntoJustBindings
.
default
_deprecateRenderModel
.
default
_deprecateRender
.
default
_assertReservedNamedArguments
.
default
_transformActionSyntax
.
default
_transformInputTypeSyntax
.
default
_transformAttrsIntoArgs
.
default
_transformEachInIntoEach
.
default
_transformHasBlockSyntax
.
default
_assertInputHelperWithoutBlock
.
default
]
;
if
(
_features
.
GLIMMER_CUSTOM_COMPONENT_MANAGER
)
{
transforms
.
push
(
_extractPragmaTag
.
default
)
;
}
exports
.
default
=
Object
.
freeze
(
transforms
)
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
action
-
syntax
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformActionSyntax
;
function
transformActionSyntax
(
_ref
)
{
var
syntax
=
_ref
.
syntax
;
var
b
=
syntax
.
builders
;
return
{
name
:
'
transform
-
action
-
syntax
'
visitors
:
{
ElementModifierStatement
:
function
(
node
)
{
if
(
isAction
(
node
)
)
{
insertThisAsFirstParam
(
node
b
)
;
}
}
MustacheStatement
:
function
(
node
)
{
if
(
isAction
(
node
)
)
{
insertThisAsFirstParam
(
node
b
)
;
}
}
SubExpression
:
function
(
node
)
{
if
(
isAction
(
node
)
)
{
insertThisAsFirstParam
(
node
b
)
;
}
}
}
}
;
}
function
isAction
(
node
)
{
return
node
.
path
.
original
=
=
=
'
action
'
;
}
function
insertThisAsFirstParam
(
node
builders
)
{
node
.
params
.
unshift
(
builders
.
path
(
'
this
'
)
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
angle
-
bracket
-
components
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformAngleBracketComponents
;
function
transformAngleBracketComponents
(
)
{
return
{
name
:
'
transform
-
angle
-
bracket
-
components
'
visitors
:
{
ComponentNode
:
function
(
node
)
{
node
.
tag
=
'
<
'
+
node
.
tag
+
'
>
'
;
}
}
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
attrs
-
into
-
args
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformAttrsIntoArgs
;
function
transformAttrsIntoArgs
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
var
stack
=
[
[
]
]
;
return
{
name
:
'
transform
-
attrs
-
into
-
args
'
visitors
:
{
Program
:
{
enter
:
function
(
node
)
{
var
parent
=
stack
[
stack
.
length
-
1
]
;
stack
.
push
(
parent
.
concat
(
node
.
blockParams
)
)
;
}
exit
:
function
(
)
{
stack
.
pop
(
)
;
}
}
PathExpression
:
function
(
node
)
{
if
(
isAttrs
(
node
stack
[
stack
.
length
-
1
]
)
)
{
var
path
=
b
.
path
(
node
.
original
.
substr
(
6
)
)
;
path
.
original
=
'
'
+
path
.
original
;
path
.
data
=
true
;
return
path
;
}
}
}
}
;
}
function
isAttrs
(
node
symbols
)
{
var
name
=
node
.
parts
[
0
]
;
if
(
symbols
.
indexOf
(
name
)
!
=
=
-
1
)
{
return
false
;
}
if
(
name
=
=
=
'
attrs
'
)
{
if
(
node
.
this
=
=
=
true
)
{
node
.
parts
.
shift
(
)
;
node
.
original
=
node
.
original
.
slice
(
5
)
;
}
return
true
;
}
return
false
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
dot
-
component
-
invocation
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformDotComponentInvocation
;
function
transformDotComponentInvocation
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
dot
-
component
-
invocation
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
if
(
isInlineInvocation
(
node
.
path
node
.
params
node
.
hash
)
)
{
wrapInComponent
(
node
b
)
;
}
}
BlockStatement
:
function
(
node
)
{
if
(
isMultipartPath
(
node
.
path
)
)
{
wrapInComponent
(
node
b
)
;
}
}
}
}
;
}
function
isMultipartPath
(
path
)
{
return
path
.
parts
&
&
path
.
parts
.
length
>
1
;
}
function
isInlineInvocation
(
path
params
hash
)
{
if
(
isMultipartPath
(
path
)
)
{
if
(
params
.
length
>
0
|
|
hash
.
pairs
.
length
>
0
)
{
return
true
;
}
}
return
false
;
}
function
wrapInComponent
(
node
builder
)
{
var
component
=
node
.
path
;
var
componentHelper
=
builder
.
path
(
'
component
'
)
;
node
.
path
=
componentHelper
;
node
.
params
.
unshift
(
component
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
each
-
in
-
into
-
each
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformEachInIntoEach
;
function
transformEachInIntoEach
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
each
-
in
-
into
-
each
'
visitors
:
{
BlockStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
=
=
=
'
each
-
in
'
)
{
node
.
params
[
0
]
=
b
.
sexpr
(
b
.
path
(
'
-
each
-
in
'
)
[
node
.
params
[
0
]
]
)
;
return
b
.
block
(
b
.
path
(
'
each
'
)
node
.
params
node
.
hash
node
.
program
node
.
inverse
node
.
loc
)
;
}
}
}
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
has
-
block
-
syntax
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformHasBlockSyntax
;
var
TRANSFORMATIONS
=
{
hasBlock
:
'
has
-
block
'
hasBlockParams
:
'
has
-
block
-
params
'
}
;
function
transformHasBlockSyntax
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
has
-
block
-
syntax
'
visitors
:
{
PathExpression
:
function
(
node
)
{
if
(
TRANSFORMATIONS
[
node
.
original
]
)
{
return
b
.
sexpr
(
b
.
path
(
TRANSFORMATIONS
[
node
.
original
]
)
)
;
}
}
MustacheStatement
:
function
(
node
)
{
if
(
TRANSFORMATIONS
[
node
.
path
.
original
]
)
{
return
b
.
mustache
(
b
.
path
(
TRANSFORMATIONS
[
node
.
path
.
original
]
)
node
.
params
node
.
hash
null
node
.
loc
)
;
}
}
SubExpression
:
function
(
node
)
{
if
(
TRANSFORMATIONS
[
node
.
path
.
original
]
)
{
return
b
.
sexpr
(
b
.
path
(
TRANSFORMATIONS
[
node
.
path
.
original
]
)
node
.
params
node
.
hash
)
;
}
}
}
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
inline
-
link
-
to
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformInlineLinkTo
;
function
buildProgram
(
b
content
loc
)
{
return
b
.
program
(
[
buildStatement
(
b
content
loc
)
]
null
loc
)
;
}
function
buildStatement
(
b
content
loc
)
{
switch
(
content
.
type
)
{
case
'
PathExpression
'
:
return
b
.
mustache
(
content
null
null
null
loc
)
;
case
'
SubExpression
'
:
return
b
.
mustache
(
content
.
path
content
.
params
content
.
hash
null
loc
)
;
default
:
return
b
.
text
(
'
'
+
content
.
value
loc
)
;
}
}
function
unsafeHtml
(
b
expr
)
{
return
b
.
sexpr
(
'
-
html
-
safe
'
[
expr
]
)
;
}
function
transformInlineLinkTo
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
inline
-
link
-
to
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
=
=
=
'
link
-
to
'
)
{
var
content
=
node
.
escaped
?
node
.
params
[
0
]
:
unsafeHtml
(
b
node
.
params
[
0
]
)
;
return
b
.
block
(
'
link
-
to
'
node
.
params
.
slice
(
1
)
node
.
hash
buildProgram
(
b
content
node
.
loc
)
null
node
.
loc
)
;
}
}
}
}
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
input
-
type
-
syntax
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformInputTypeSyntax
;
function
transformInputTypeSyntax
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
input
-
type
-
syntax
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
if
(
isInput
(
node
)
)
{
insertTypeHelperParameter
(
node
b
)
;
}
}
}
}
;
}
function
isInput
(
node
)
{
return
node
.
path
.
original
=
=
=
'
input
'
;
}
function
insertTypeHelperParameter
(
node
builders
)
{
var
pairs
=
node
.
hash
.
pairs
;
var
pair
=
null
;
for
(
var
i
=
0
;
i
<
pairs
.
length
;
i
+
+
)
{
if
(
pairs
[
i
]
.
key
=
=
=
'
type
'
)
{
pair
=
pairs
[
i
]
;
break
;
}
}
if
(
pair
&
&
pair
.
value
.
type
!
=
=
'
StringLiteral
'
)
{
node
.
params
.
unshift
(
builders
.
sexpr
(
'
-
input
-
type
'
[
pair
.
value
]
null
pair
.
loc
)
)
;
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
binding
-
syntax
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberDebug
_calculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
transformOldBindingSyntax
;
function
transformOldBindingSyntax
(
env
)
{
var
moduleName
=
env
.
meta
.
moduleName
;
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
old
-
binding
-
syntax
'
visitors
:
{
BlockStatement
:
function
(
node
)
{
processHash
(
b
node
moduleName
)
;
}
MustacheStatement
:
function
(
node
)
{
processHash
(
b
node
moduleName
)
;
}
}
}
;
}
function
processHash
(
b
node
moduleName
)
{
for
(
var
i
=
0
;
i
<
node
.
hash
.
pairs
.
length
;
i
+
+
)
{
var
pair
=
node
.
hash
.
pairs
[
i
]
;
var
key
=
pair
.
key
value
=
pair
.
value
;
var
sourceInformation
=
(
0
_calculateLocationDisplay
.
default
)
(
moduleName
pair
.
loc
)
;
if
(
key
=
=
=
'
classBinding
'
)
{
return
;
}
(
true
&
&
!
(
key
!
=
=
'
attributeBindings
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Setting
\
'
attributeBindings
\
'
via
template
helpers
is
not
allowed
'
+
sourceInformation
key
!
=
=
'
attributeBindings
'
)
)
;
if
(
key
.
substr
(
-
7
)
=
=
=
'
Binding
'
)
{
var
newKey
=
key
.
slice
(
0
-
7
)
;
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
You
\
'
re
using
legacy
binding
syntax
:
'
+
key
+
'
=
'
+
exprToString
(
value
)
+
'
'
+
sourceInformation
+
'
.
Please
replace
with
'
+
newKey
+
'
=
'
+
value
.
original
false
{
id
:
'
ember
-
template
-
compiler
.
transform
-
old
-
binding
-
syntax
'
until
:
'
3
.
0
.
0
'
}
)
)
;
pair
.
key
=
newKey
;
if
(
value
.
type
=
=
=
'
StringLiteral
'
)
{
pair
.
value
=
b
.
path
(
value
.
original
)
;
}
}
}
}
function
exprToString
(
expr
)
{
switch
(
expr
.
type
)
{
case
'
StringLiteral
'
:
return
'
"
'
+
expr
.
original
+
'
"
'
;
case
'
PathExpression
'
:
return
expr
.
original
;
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
class
-
binding
-
syntax
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformOldClassBindingSyntax
;
function
transformOldClassBindingSyntax
(
env
)
{
var
b
=
env
.
syntax
.
builders
;
return
{
name
:
'
transform
-
old
-
class
-
binding
-
syntax
'
visitors
:
{
MustacheStatement
:
function
(
node
)
{
process
(
b
node
)
;
}
BlockStatement
:
function
(
node
)
{
process
(
b
node
)
;
}
}
}
;
}
function
process
(
b
node
)
{
var
allOfTheMicrosyntaxes
=
[
]
;
var
allOfTheMicrosyntaxIndexes
=
[
]
;
var
classPair
=
void
0
;
each
(
node
.
hash
.
pairs
function
(
pair
index
)
{
var
key
=
pair
.
key
;
if
(
key
=
=
=
'
classBinding
'
|
|
key
=
=
=
'
classNameBindings
'
)
{
allOfTheMicrosyntaxIndexes
.
push
(
index
)
;
allOfTheMicrosyntaxes
.
push
(
pair
)
;
}
else
if
(
key
=
=
=
'
class
'
)
{
classPair
=
pair
;
}
}
)
;
if
(
allOfTheMicrosyntaxes
.
length
=
=
=
0
)
{
return
;
}
var
classValue
=
[
]
;
if
(
classPair
)
{
classValue
.
push
(
classPair
.
value
)
;
classValue
.
push
(
b
.
string
(
'
'
)
)
;
}
else
{
classPair
=
b
.
pair
(
'
class
'
null
)
;
node
.
hash
.
pairs
.
push
(
classPair
)
;
}
each
(
allOfTheMicrosyntaxIndexes
function
(
index
)
{
node
.
hash
.
pairs
.
splice
(
index
1
)
;
}
)
;
each
(
allOfTheMicrosyntaxes
function
(
_ref
)
{
var
value
=
_ref
.
value
;
var
sexprs
=
[
]
;
if
(
value
.
type
=
=
=
'
StringLiteral
'
)
{
var
microsyntax
=
parseMicrosyntax
(
value
.
original
)
;
buildSexprs
(
microsyntax
sexprs
b
)
;
classValue
.
push
.
apply
(
classValue
sexprs
)
;
}
}
)
;
var
hash
=
b
.
hash
(
)
;
classPair
.
value
=
b
.
sexpr
(
b
.
path
(
'
concat
'
)
classValue
hash
)
;
}
function
buildSexprs
(
microsyntax
sexprs
b
)
{
for
(
var
i
=
0
;
i
<
microsyntax
.
length
;
i
+
+
)
{
var
_microsyntax
i
=
microsyntax
[
i
]
propName
=
_microsyntax
i
[
0
]
activeClass
=
_microsyntax
i
[
1
]
inactiveClass
=
_microsyntax
i
[
2
]
;
var
sexpr
=
void
0
;
if
(
propName
=
=
=
'
'
)
{
sexpr
=
b
.
string
(
activeClass
)
;
}
else
{
var
params
=
[
b
.
path
(
propName
)
]
;
if
(
activeClass
|
|
activeClass
=
=
=
'
'
)
{
params
.
push
(
b
.
string
(
activeClass
)
)
;
}
else
{
var
sexprParams
=
[
b
.
string
(
propName
)
b
.
path
(
propName
)
]
;
var
hash
=
b
.
hash
(
)
;
if
(
activeClass
!
=
=
undefined
)
{
hash
.
pairs
.
push
(
b
.
pair
(
'
activeClass
'
b
.
string
(
activeClass
)
)
)
;
}
if
(
inactiveClass
!
=
=
undefined
)
{
hash
.
pairs
.
push
(
b
.
pair
(
'
inactiveClass
'
b
.
string
(
inactiveClass
)
)
)
;
}
params
.
push
(
b
.
sexpr
(
b
.
path
(
'
-
normalize
-
class
'
)
sexprParams
hash
)
)
;
}
if
(
inactiveClass
|
|
inactiveClass
=
=
=
'
'
)
{
params
.
push
(
b
.
string
(
inactiveClass
)
)
;
}
sexpr
=
b
.
sexpr
(
b
.
path
(
'
if
'
)
params
)
;
}
sexprs
.
push
(
sexpr
)
;
sexprs
.
push
(
b
.
string
(
'
'
)
)
;
}
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
callback
(
list
[
i
]
i
)
;
}
}
function
parseMicrosyntax
(
string
)
{
var
segments
=
string
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
segments
.
length
;
i
+
+
)
{
segments
[
i
]
=
segments
[
i
]
.
split
(
'
:
'
)
;
}
return
segments
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
quoted
-
bindings
-
into
-
just
-
bindings
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformQuotedBindingsIntoJustBindings
;
function
transformQuotedBindingsIntoJustBindings
(
)
{
return
{
name
:
'
transform
-
quoted
-
bindings
-
into
-
just
-
bindings
'
visitors
:
{
ElementNode
:
function
(
node
)
{
var
styleAttr
=
getStyleAttr
(
node
)
;
if
(
!
validStyleAttr
(
styleAttr
)
)
{
return
;
}
styleAttr
.
value
=
styleAttr
.
value
.
parts
[
0
]
;
}
}
}
;
}
function
validStyleAttr
(
attr
)
{
if
(
!
attr
)
{
return
false
;
}
var
value
=
attr
.
value
;
if
(
!
value
|
|
value
.
type
!
=
=
'
ConcatStatement
'
|
|
value
.
parts
.
length
!
=
=
1
)
{
return
false
;
}
var
onlyPart
=
value
.
parts
[
0
]
;
return
onlyPart
.
type
=
=
=
'
MustacheStatement
'
;
}
function
getStyleAttr
(
node
)
{
var
attributes
=
node
.
attributes
;
for
(
var
i
=
0
;
i
<
attributes
.
length
;
i
+
+
)
{
if
(
attributes
[
i
]
.
name
=
=
=
'
style
'
)
{
return
attributes
[
i
]
;
}
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
top
-
level
-
components
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
transformTopLevelComponent
;
function
transformTopLevelComponent
(
)
{
return
{
name
:
'
transform
-
top
-
level
-
component
'
visitors
:
{
Program
:
function
(
node
)
{
hasSingleComponentNode
(
node
function
(
component
)
{
component
.
tag
=
'
'
+
component
.
tag
;
component
.
isStatic
=
true
;
}
)
;
}
}
}
;
}
function
hasSingleComponentNode
(
program
componentCallback
)
{
var
loc
=
program
.
loc
body
=
program
.
body
;
if
(
!
loc
|
|
loc
.
start
.
line
!
=
=
1
|
|
loc
.
start
.
column
!
=
=
0
)
{
return
;
}
var
lastComponentNode
=
void
0
;
var
nodeCount
=
0
;
for
(
var
i
=
0
;
i
<
body
.
length
;
i
+
+
)
{
var
curr
=
body
[
i
]
;
if
(
curr
.
type
=
=
=
'
TextNode
'
&
&
/
^
[
\
s
]
*
/
.
test
(
curr
.
chars
)
)
{
continue
;
}
if
(
nodeCount
+
+
>
0
)
{
return
false
;
}
if
(
curr
.
type
=
=
=
'
ComponentNode
'
|
|
curr
.
type
=
=
=
'
ElementNode
'
)
{
lastComponentNode
=
curr
;
}
}
if
(
!
lastComponentNode
)
{
return
;
}
if
(
lastComponentNode
.
type
=
=
=
'
ComponentNode
'
)
{
componentCallback
(
lastComponentNode
)
;
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
bootstrap
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
template
-
compiler
/
system
/
compile
'
]
function
(
exports
_emberDebug
_compile
)
{
'
use
strict
'
;
function
bootstrap
(
_ref
)
{
var
context
=
_ref
.
context
hasTemplate
=
_ref
.
hasTemplate
setTemplate
=
_ref
.
setTemplate
;
if
(
!
context
)
{
context
=
document
;
}
var
selector
=
'
script
[
type
=
"
text
/
x
-
handlebars
"
]
'
;
var
elements
=
context
.
querySelectorAll
(
selector
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
var
script
=
elements
[
i
]
;
var
templateName
=
script
.
getAttribute
(
'
data
-
template
-
name
'
)
|
|
script
.
getAttribute
(
'
id
'
)
|
|
'
application
'
;
var
template
=
void
0
;
template
=
(
0
_compile
.
default
)
(
script
.
innerHTML
{
moduleName
:
templateName
}
)
;
if
(
hasTemplate
(
templateName
)
)
{
throw
new
_emberDebug
.
Error
(
'
Template
named
"
'
+
templateName
+
'
"
already
exists
.
'
)
;
}
setTemplate
(
templateName
template
)
;
script
.
parentNode
.
removeChild
(
script
)
;
}
}
exports
.
default
=
bootstrap
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
calculateLocationDisplay
;
function
calculateLocationDisplay
(
moduleName
)
{
var
loc
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
_ref
=
loc
.
start
|
|
{
}
column
=
_ref
.
column
line
=
_ref
.
line
;
var
moduleInfo
=
'
'
;
if
(
moduleName
)
{
moduleInfo
+
=
'
\
'
'
+
moduleName
+
'
\
'
'
;
}
if
(
line
!
=
=
undefined
&
&
column
!
=
=
undefined
)
{
if
(
moduleName
)
{
moduleInfo
+
=
'
'
;
}
moduleInfo
+
=
'
L
'
+
line
+
'
:
C
'
+
column
;
}
if
(
moduleInfo
)
{
moduleInfo
=
'
(
'
+
moduleInfo
+
'
)
'
;
}
return
moduleInfo
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
compile
-
options
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
template
-
compiler
/
plugins
'
]
function
(
exports
_emberUtils
_plugins
)
{
'
use
strict
'
;
exports
.
default
=
compileOptions
;
exports
.
registerPlugin
=
registerPlugin
;
exports
.
unregisterPlugin
=
unregisterPlugin
;
var
USER_PLUGINS
=
[
]
;
function
compileOptions
(
_options
)
{
var
options
=
(
0
_emberUtils
.
assign
)
(
{
meta
:
{
}
}
_options
)
;
if
(
options
.
moduleName
)
{
var
meta
=
options
.
meta
;
meta
.
moduleName
=
options
.
moduleName
;
}
if
(
!
options
.
plugins
)
{
options
.
plugins
=
{
ast
:
[
]
.
concat
(
USER_PLUGINS
_plugins
.
default
)
}
;
}
else
{
var
potententialPugins
=
[
]
.
concat
(
USER_PLUGINS
_plugins
.
default
)
;
var
providedPlugins
=
options
.
plugins
.
ast
.
map
(
function
(
plugin
)
{
return
wrapLegacyPluginIfNeeded
(
plugin
)
;
}
)
;
var
pluginsToAdd
=
potententialPugins
.
filter
(
function
(
plugin
)
{
return
options
.
plugins
.
ast
.
indexOf
(
plugin
)
=
=
=
-
1
;
}
)
;
options
.
plugins
.
ast
=
providedPlugins
.
concat
(
pluginsToAdd
)
;
}
return
options
;
}
function
wrapLegacyPluginIfNeeded
(
_plugin
)
{
var
plugin
=
_plugin
;
if
(
_plugin
.
prototype
&
&
_plugin
.
prototype
.
transform
)
{
plugin
=
function
(
env
)
{
var
pluginInstantiated
=
false
;
return
{
name
:
_plugin
.
constructor
&
&
_plugin
.
constructor
.
name
visitors
:
{
Program
:
function
(
node
)
{
if
(
!
pluginInstantiated
)
{
pluginInstantiated
=
true
;
var
_plugin2
=
new
_plugin
(
env
)
;
_plugin2
.
syntax
=
env
.
syntax
;
return
_plugin2
.
transform
(
node
)
;
}
}
}
}
;
}
;
plugin
.
__raw
=
_plugin
;
}
return
plugin
;
}
function
registerPlugin
(
type
_plugin
)
{
if
(
type
!
=
=
'
ast
'
)
{
throw
new
Error
(
'
Attempting
to
register
'
+
_plugin
+
'
as
"
'
+
type
+
'
"
which
is
not
a
valid
Glimmer
plugin
type
.
'
)
;
}
for
(
var
i
=
0
;
i
<
USER_PLUGINS
.
length
;
i
+
+
)
{
var
PLUGIN
=
USER_PLUGINS
[
i
]
;
if
(
PLUGIN
=
=
=
_plugin
|
|
PLUGIN
.
__raw
=
=
=
_plugin
)
{
return
;
}
}
var
plugin
=
wrapLegacyPluginIfNeeded
(
_plugin
)
;
USER_PLUGINS
=
[
plugin
]
.
concat
(
USER_PLUGINS
)
;
}
function
unregisterPlugin
(
type
PluginClass
)
{
if
(
type
!
=
=
'
ast
'
)
{
throw
new
Error
(
'
Attempting
to
unregister
'
+
PluginClass
+
'
as
"
'
+
type
+
'
"
which
is
not
a
valid
Glimmer
plugin
type
.
'
)
;
}
USER_PLUGINS
=
USER_PLUGINS
.
filter
(
function
(
plugin
)
{
return
plugin
!
=
=
PluginClass
&
&
plugin
.
__raw
!
=
=
PluginClass
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
compile
'
[
'
exports
'
'
require
'
'
ember
-
template
-
compiler
/
system
/
precompile
'
]
function
(
exports
_require2
_precompile
)
{
'
use
strict
'
;
exports
.
default
=
compile
;
var
template
=
void
0
;
function
compile
(
templateString
options
)
{
if
(
!
template
&
&
(
0
_require2
.
has
)
(
'
ember
-
glimmer
'
)
)
{
template
=
(
0
_require2
.
default
)
(
'
ember
-
glimmer
'
)
.
template
;
}
if
(
!
template
)
{
throw
new
Error
(
'
Cannot
call
compile
with
only
the
template
compiler
loaded
.
Please
load
ember
.
debug
.
js
or
ember
.
prod
.
js
prior
to
calling
compile
.
'
)
;
}
var
precompiledTemplateString
=
(
0
_precompile
.
default
)
(
templateString
options
)
;
var
templateJS
=
new
Function
(
'
return
'
+
precompiledTemplateString
)
(
)
;
return
template
(
templateJS
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
precompile
'
[
'
exports
'
'
ember
-
template
-
compiler
/
system
/
compile
-
options
'
'
require
'
]
function
(
exports
_compileOptions
_require2
)
{
'
use
strict
'
;
exports
.
default
=
precompile
;
var
glimmerPrecompile
=
void
0
;
function
precompile
(
templateString
options
)
{
if
(
!
glimmerPrecompile
&
&
(
0
_require2
.
has
)
(
'
glimmer
/
compiler
'
)
)
{
glimmerPrecompile
=
(
0
_require2
.
default
)
(
'
glimmer
/
compiler
'
)
.
precompile
;
}
if
(
!
glimmerPrecompile
)
{
throw
new
Error
(
'
Cannot
call
compile
without
the
template
compiler
loaded
.
Please
load
ember
-
template
-
compiler
.
js
prior
to
calling
compile
.
'
)
;
}
return
glimmerPrecompile
(
templateString
(
0
_compileOptions
.
default
)
(
options
)
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
adapter
'
[
'
exports
'
'
ember
-
runtime
'
]
function
(
exports
_emberRuntime
)
{
'
use
strict
'
;
function
K
(
)
{
return
this
;
}
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
asyncStart
:
K
asyncEnd
:
K
exception
:
function
(
error
)
{
throw
error
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
qunit
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
testing
/
adapters
/
adapter
'
]
function
(
exports
_emberUtils
_adapter
)
{
'
use
strict
'
;
exports
.
default
=
_adapter
.
default
.
extend
(
{
asyncStart
:
function
(
)
{
QUnit
.
stop
(
)
;
}
asyncEnd
:
function
(
)
{
QUnit
.
start
(
)
;
}
exception
:
function
(
error
)
{
QUnit
.
config
.
current
.
assert
.
ok
(
false
(
0
_emberUtils
.
inspect
)
(
error
)
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
events
'
[
'
exports
'
'
ember
-
views
'
'
ember
-
metal
'
]
function
(
exports
_emberViews
_emberMetal
)
{
'
use
strict
'
;
exports
.
focus
=
focus
;
exports
.
fireEvent
=
fireEvent
;
var
DEFAULT_EVENT_OPTIONS
=
{
canBubble
:
true
cancelable
:
true
}
;
var
KEYBOARD_EVENT_TYPES
=
[
'
keydown
'
'
keypress
'
'
keyup
'
]
;
var
MOUSE_EVENT_TYPES
=
[
'
click
'
'
mousedown
'
'
mouseup
'
'
dblclick
'
'
mouseenter
'
'
mouseleave
'
'
mousemove
'
'
mouseout
'
'
mouseover
'
]
;
function
focus
(
el
)
{
if
(
!
el
)
{
return
;
}
var
el
=
(
0
_emberViews
.
jQuery
)
(
el
)
;
if
(
el
.
is
(
'
:
input
[
contenteditable
=
true
]
'
)
)
{
var
type
=
el
.
prop
(
'
type
'
)
;
if
(
type
!
=
=
'
checkbox
'
&
&
type
!
=
=
'
radio
'
&
&
type
!
=
=
'
hidden
'
)
{
(
0
_emberMetal
.
run
)
(
null
function
(
)
{
if
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
{
el
.
focus
(
)
;
}
else
{
el
.
trigger
(
'
focusin
'
)
;
}
}
)
;
}
}
}
function
fireEvent
(
element
type
)
{
var
options
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
if
(
!
element
)
{
return
;
}
var
event
=
void
0
;
if
(
KEYBOARD_EVENT_TYPES
.
indexOf
(
type
)
>
-
1
)
{
event
=
buildKeyboardEvent
(
type
options
)
;
}
else
if
(
MOUSE_EVENT_TYPES
.
indexOf
(
type
)
>
-
1
)
{
var
rect
=
element
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
left
+
1
;
var
y
=
rect
.
top
+
1
;
var
simulatedCoordinates
=
{
screenX
:
x
+
5
screenY
:
y
+
95
clientX
:
x
clientY
:
y
}
;
event
=
buildMouseEvent
(
type
_emberViews
.
jQuery
.
extend
(
simulatedCoordinates
options
)
)
;
}
else
{
event
=
buildBasicEvent
(
type
options
)
;
}
element
.
dispatchEvent
(
event
)
;
}
function
buildBasicEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
document
.
createEvent
(
'
Events
'
)
;
event
.
initEvent
(
type
true
true
)
;
_emberViews
.
jQuery
.
extend
(
event
options
)
;
return
event
;
}
function
buildMouseEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
void
0
;
try
{
event
=
document
.
createEvent
(
'
MouseEvents
'
)
;
var
eventOpts
=
_emberViews
.
jQuery
.
extend
(
{
}
DEFAULT_EVENT_OPTIONS
options
)
;
event
.
initMouseEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
detail
eventOpts
.
screenX
eventOpts
.
screenY
eventOpts
.
clientX
eventOpts
.
clientY
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
button
eventOpts
.
relatedTarget
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
function
buildKeyboardEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
void
0
;
try
{
event
=
document
.
createEvent
(
'
KeyEvents
'
)
;
var
eventOpts
=
_emberViews
.
jQuery
.
extend
(
{
}
DEFAULT_EVENT_OPTIONS
options
)
;
event
.
initKeyEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
keyCode
eventOpts
.
charCode
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
}
)
;
enifed
(
'
ember
-
testing
/
ext
/
application
'
[
'
ember
-
application
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
test
/
promise
'
'
ember
-
testing
/
test
/
run
'
'
ember
-
testing
/
test
/
on_inject_helpers
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
_emberApplication
_setup_for_testing
_helpers
_promise
_run
_on_inject_helpers
_adapter
)
{
'
use
strict
'
;
_emberApplication
.
Application
.
reopen
(
{
testHelpers
:
{
}
originalMethods
:
{
}
testing
:
false
setupForTesting
:
function
(
)
{
(
0
_setup_for_testing
.
default
)
(
)
;
this
.
testing
=
true
;
this
.
resolveRegistration
(
'
router
:
main
'
)
.
reopen
(
{
location
:
'
none
'
}
)
;
}
helperContainer
:
null
injectTestHelpers
:
function
(
helperContainer
)
{
if
(
helperContainer
)
{
this
.
helperContainer
=
helperContainer
;
}
else
{
this
.
helperContainer
=
window
;
}
this
.
reopen
(
{
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
removeTestHelpers
(
)
;
}
}
)
;
this
.
testHelpers
=
{
}
;
for
(
var
name
in
_helpers
.
helpers
)
{
this
.
originalMethods
[
name
]
=
this
.
helperContainer
[
name
]
;
this
.
testHelpers
[
name
]
=
this
.
helperContainer
[
name
]
=
helper
(
this
name
)
;
protoWrap
(
_promise
.
default
.
prototype
name
helper
(
this
name
)
_helpers
.
helpers
[
name
]
.
meta
.
wait
)
;
}
(
0
_on_inject_helpers
.
invokeInjectHelpersCallbacks
)
(
this
)
;
}
removeTestHelpers
:
function
(
)
{
if
(
!
this
.
helperContainer
)
{
return
;
}
for
(
var
name
in
_helpers
.
helpers
)
{
this
.
helperContainer
[
name
]
=
this
.
originalMethods
[
name
]
;
delete
_promise
.
default
.
prototype
[
name
]
;
delete
this
.
testHelpers
[
name
]
;
delete
this
.
originalMethods
[
name
]
;
}
}
}
)
;
function
protoWrap
(
proto
name
callback
isAsync
)
{
proto
[
name
]
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
isAsync
)
{
return
callback
.
apply
(
this
args
)
;
}
else
{
return
this
.
then
(
function
(
)
{
return
callback
.
apply
(
this
args
)
;
}
)
;
}
}
;
}
function
helper
(
app
name
)
{
var
fn
=
_helpers
.
helpers
[
name
]
.
method
;
var
meta
=
_helpers
.
helpers
[
name
]
.
meta
;
if
(
!
meta
.
wait
)
{
return
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
fn
.
apply
(
app
[
app
]
.
concat
(
args
)
)
;
}
;
}
return
function
(
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
var
lastPromise
=
(
0
_run
.
default
)
(
function
(
)
{
return
(
0
_promise
.
resolve
)
(
(
0
_promise
.
getLastPromise
)
(
)
)
;
}
)
;
(
0
_adapter
.
asyncStart
)
(
)
;
return
lastPromise
.
then
(
function
(
)
{
return
fn
.
apply
(
app
[
app
]
.
concat
(
args
)
)
;
}
)
.
finally
(
_adapter
.
asyncEnd
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
testing
/
ext
/
rsvp
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
exports
_emberRuntime
_emberMetal
_emberDebug
_adapter
)
{
'
use
strict
'
;
_emberRuntime
.
RSVP
.
configure
(
'
async
'
function
(
callback
promise
)
{
if
(
(
0
_emberDebug
.
isTesting
)
(
)
&
&
!
_emberMetal
.
run
.
backburner
.
currentInstance
)
{
(
0
_adapter
.
asyncStart
)
(
)
;
_emberMetal
.
run
.
backburner
.
schedule
(
'
actions
'
function
(
)
{
(
0
_adapter
.
asyncEnd
)
(
)
;
callback
(
promise
)
;
}
)
;
}
else
{
_emberMetal
.
run
.
backburner
.
schedule
(
'
actions
'
function
(
)
{
return
callback
(
promise
)
;
}
)
;
}
}
)
;
exports
.
default
=
_emberRuntime
.
RSVP
;
}
)
;
enifed
(
'
ember
-
testing
/
helpers
'
[
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
helpers
/
and_then
'
'
ember
-
testing
/
helpers
/
click
'
'
ember
-
testing
/
helpers
/
current_path
'
'
ember
-
testing
/
helpers
/
current_route_name
'
'
ember
-
testing
/
helpers
/
current_url
'
'
ember
-
testing
/
helpers
/
fill_in
'
'
ember
-
testing
/
helpers
/
find
'
'
ember
-
testing
/
helpers
/
find_with_assert
'
'
ember
-
testing
/
helpers
/
key_event
'
'
ember
-
testing
/
helpers
/
pause_test
'
'
ember
-
testing
/
helpers
/
trigger_event
'
'
ember
-
testing
/
helpers
/
visit
'
'
ember
-
testing
/
helpers
/
wait
'
]
function
(
_helpers
_and_then
_click
_current_path
_current_route_name
_current_url
_fill_in
_find
_find_with_assert
_key_event
_pause_test
_trigger_event
_visit
_wait
)
{
'
use
strict
'
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
visit
'
_visit
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
click
'
_click
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
keyEvent
'
_key_event
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
fillIn
'
_fill_in
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
wait
'
_wait
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
andThen
'
_and_then
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
pauseTest
'
_pause_test
.
pauseTest
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
triggerEvent
'
_trigger_event
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
find
'
_find
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
findWithAssert
'
_find_with_assert
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentRouteName
'
_current_route_name
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentPath
'
_current_path
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentURL
'
_current_url
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
resumeTest
'
_pause_test
.
resumeTest
)
;
}
)
;
enifed
(
"
ember
-
testing
/
helpers
/
and_then
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
andThen
;
function
andThen
(
app
callback
)
{
return
app
.
testHelpers
.
wait
(
callback
(
app
)
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
click
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
click
;
function
click
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
(
0
_events
.
fireEvent
)
(
el
'
mousedown
'
)
;
(
0
_events
.
focus
)
(
el
)
;
(
0
_events
.
fireEvent
)
(
el
'
mouseup
'
)
;
(
0
_events
.
fireEvent
)
(
el
'
click
'
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_path
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentPath
;
function
currentPath
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
(
0
_emberMetal
.
get
)
(
routingService
'
currentPath
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_route_name
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentRouteName
;
function
currentRouteName
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
(
0
_emberMetal
.
get
)
(
routingService
'
currentRouteName
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_url
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentURL
;
function
currentURL
(
app
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
return
(
0
_emberMetal
.
get
)
(
router
'
location
'
)
.
getURL
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
fill_in
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
fillIn
;
function
fillIn
(
app
selector
contextOrText
text
)
{
var
el
=
void
0
el
=
void
0
context
=
void
0
;
if
(
text
=
=
=
undefined
)
{
text
=
contextOrText
;
}
else
{
context
=
contextOrText
;
}
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
el
=
el
[
0
]
;
(
0
_events
.
focus
)
(
el
)
;
el
.
eq
(
0
)
.
val
(
text
)
;
(
0
_events
.
fireEvent
)
(
el
'
input
'
)
;
(
0
_events
.
fireEvent
)
(
el
'
change
'
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
find
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
find
;
function
find
(
app
selector
context
)
{
var
el
=
void
0
;
context
=
context
|
|
(
0
_emberMetal
.
get
)
(
app
'
rootElement
'
)
;
el
=
app
.
(
selector
context
)
;
return
el
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
find_with_assert
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
findWithAssert
;
function
findWithAssert
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
find
(
selector
context
)
;
if
(
el
.
length
=
=
=
0
)
{
throw
new
Error
(
'
Element
'
+
selector
+
'
not
found
.
'
)
;
}
return
el
;
}
}
)
;
enifed
(
"
ember
-
testing
/
helpers
/
key_event
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
keyEvent
;
function
keyEvent
(
app
selector
contextOrType
typeOrKeyCode
keyCode
)
{
var
context
=
void
0
type
=
void
0
;
if
(
keyCode
=
=
=
undefined
)
{
context
=
null
;
keyCode
=
typeOrKeyCode
;
type
=
contextOrType
;
}
else
{
context
=
contextOrType
;
type
=
typeOrKeyCode
;
}
return
app
.
testHelpers
.
triggerEvent
(
selector
context
type
{
keyCode
:
keyCode
which
:
keyCode
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
pause_test
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
console
'
'
ember
-
debug
'
]
function
(
exports
_emberRuntime
_emberConsole
_emberDebug
)
{
'
use
strict
'
;
exports
.
resumeTest
=
resumeTest
;
exports
.
pauseTest
=
pauseTest
;
var
resume
=
void
0
;
function
resumeTest
(
)
{
(
true
&
&
!
(
resume
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Testing
has
not
been
paused
.
There
is
nothing
to
resume
.
'
resume
)
)
;
resume
(
)
;
resume
=
undefined
;
}
function
pauseTest
(
)
{
_emberConsole
.
default
.
info
(
'
Testing
paused
.
Use
resumeTest
(
)
to
continue
.
'
)
;
return
new
_emberRuntime
.
RSVP
.
Promise
(
function
(
resolve
)
{
resume
=
resolve
;
}
'
TestAdapter
paused
promise
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
trigger_event
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
triggerEvent
;
function
triggerEvent
(
app
selector
contextOrType
typeOrOptions
possibleOptions
)
{
var
arity
=
arguments
.
length
;
var
context
=
void
0
type
=
void
0
options
=
void
0
;
if
(
arity
=
=
=
3
)
{
context
=
null
;
type
=
contextOrType
;
options
=
{
}
;
}
else
if
(
arity
=
=
=
4
)
{
if
(
typeof
typeOrOptions
=
=
=
'
object
'
)
{
context
=
null
;
type
=
contextOrType
;
options
=
typeOrOptions
;
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
{
}
;
}
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
possibleOptions
;
}
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
(
0
_events
.
fireEvent
)
(
el
type
options
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
visit
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
visit
;
function
visit
(
app
url
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
shouldHandleURL
=
false
;
app
.
boot
(
)
.
then
(
function
(
)
{
router
.
location
.
setURL
(
url
)
;
if
(
shouldHandleURL
)
{
(
0
_emberMetal
.
run
)
(
app
.
__deprecatedInstance__
'
handleURL
'
url
)
;
}
}
)
;
if
(
app
.
_readinessDeferrals
>
0
)
{
router
[
'
initialURL
'
]
=
url
;
(
0
_emberMetal
.
run
)
(
app
'
advanceReadiness
'
)
;
delete
router
[
'
initialURL
'
]
;
}
else
{
shouldHandleURL
=
true
;
}
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
wait
'
[
'
exports
'
'
ember
-
testing
/
test
/
waiters
'
'
ember
-
runtime
'
'
ember
-
metal
'
'
ember
-
testing
/
test
/
pending_requests
'
]
function
(
exports
_waiters
_emberRuntime
_emberMetal
_pending_requests
)
{
'
use
strict
'
;
exports
.
default
=
wait
;
function
wait
(
app
value
)
{
return
new
_emberRuntime
.
RSVP
.
Promise
(
function
(
resolve
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
watcher
=
setInterval
(
function
(
)
{
var
routerIsLoading
=
router
.
_routerMicrolib
&
&
!
!
router
.
_routerMicrolib
.
activeTransition
;
if
(
routerIsLoading
)
{
return
;
}
if
(
(
0
_pending_requests
.
pendingRequests
)
(
)
)
{
return
;
}
if
(
_emberMetal
.
run
.
hasScheduledTimers
(
)
|
|
_emberMetal
.
run
.
currentRunLoop
)
{
return
;
}
if
(
(
0
_waiters
.
checkWaiters
)
(
)
)
{
return
;
}
clearInterval
(
watcher
)
;
(
0
_emberMetal
.
run
)
(
null
resolve
value
)
;
}
10
)
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
index
'
[
'
exports
'
'
ember
-
testing
/
test
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
testing
/
adapters
/
qunit
'
'
ember
-
testing
/
support
'
'
ember
-
testing
/
ext
/
application
'
'
ember
-
testing
/
ext
/
rsvp
'
'
ember
-
testing
/
helpers
'
'
ember
-
testing
/
initializers
'
]
function
(
exports
_test
_adapter
_setup_for_testing
_qunit
)
{
'
use
strict
'
;
exports
.
QUnitAdapter
=
exports
.
setupForTesting
=
exports
.
Adapter
=
exports
.
Test
=
undefined
;
Object
.
defineProperty
(
exports
'
Test
'
{
enumerable
:
true
get
:
function
(
)
{
return
_test
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Adapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_adapter
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupForTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setup_for_testing
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
QUnitAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
initializers
'
[
'
ember
-
runtime
'
]
function
(
_emberRuntime
)
{
'
use
strict
'
;
var
name
=
'
deferReadiness
in
testing
mode
'
;
(
0
_emberRuntime
.
onLoad
)
(
'
Ember
.
Application
'
function
(
Application
)
{
if
(
!
Application
.
initializers
[
name
]
)
{
Application
.
initializer
(
{
name
:
name
initialize
:
function
(
application
)
{
if
(
application
.
testing
)
{
application
.
deferReadiness
(
)
;
}
}
}
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
setup_for_testing
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
views
'
'
ember
-
testing
/
test
/
adapter
'
'
ember
-
testing
/
test
/
pending_requests
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
testing
/
adapters
/
qunit
'
]
function
(
exports
_emberDebug
_emberViews
_adapter
_pending_requests
_adapter2
_qunit
)
{
'
use
strict
'
;
exports
.
default
=
setupForTesting
;
function
setupForTesting
(
)
{
(
0
_emberDebug
.
setTesting
)
(
true
)
;
var
adapter
=
(
0
_adapter
.
getAdapter
)
(
)
;
if
(
!
adapter
)
{
(
0
_adapter
.
setAdapter
)
(
typeof
self
.
QUnit
=
=
=
'
undefined
'
?
new
_adapter2
.
default
(
)
:
new
_qunit
.
default
(
)
)
;
}
if
(
_emberViews
.
jQuery
)
{
(
0
_emberViews
.
jQuery
)
(
document
)
.
off
(
'
ajaxSend
'
_pending_requests
.
incrementPendingRequests
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
off
(
'
ajaxComplete
'
_pending_requests
.
decrementPendingRequests
)
;
(
0
_pending_requests
.
clearPendingRequests
)
(
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
on
(
'
ajaxSend
'
_pending_requests
.
incrementPendingRequests
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
on
(
'
ajaxComplete
'
_pending_requests
.
decrementPendingRequests
)
;
}
}
}
)
;
enifed
(
'
ember
-
testing
/
support
'
[
'
ember
-
debug
'
'
ember
-
views
'
'
ember
-
environment
'
]
function
(
_emberDebug
_emberViews
_emberEnvironment
)
{
'
use
strict
'
;
var
=
_emberViews
.
jQuery
;
function
testCheckboxClick
(
handler
)
{
var
input
=
document
.
createElement
(
'
input
'
)
;
(
input
)
.
attr
(
'
type
'
'
checkbox
'
)
.
css
(
{
position
:
'
absolute
'
left
:
'
-
1000px
'
top
:
'
-
1000px
'
}
)
.
appendTo
(
'
body
'
)
.
on
(
'
click
'
handler
)
.
trigger
(
'
click
'
)
.
remove
(
)
;
}
if
(
_emberEnvironment
.
environment
.
hasDOM
&
&
typeof
=
=
=
'
function
'
)
{
(
function
(
)
{
testCheckboxClick
(
function
(
)
{
if
(
!
this
.
checked
&
&
!
.
event
.
special
.
click
)
{
.
event
.
special
.
click
=
{
trigger
:
function
(
)
{
if
(
.
nodeName
(
this
'
input
'
)
&
&
this
.
type
=
=
=
'
checkbox
'
&
&
this
.
click
)
{
this
.
click
(
)
;
return
false
;
}
}
}
;
}
}
)
;
testCheckboxClick
(
function
(
)
{
(
true
&
&
(
0
_emberDebug
.
warn
)
(
'
clicked
checkboxes
should
be
checked
!
the
jQuery
patch
didn
\
'
t
work
'
this
.
checked
{
id
:
'
ember
-
testing
.
test
-
checkbox
-
click
'
}
)
)
;
}
)
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
test
'
[
'
exports
'
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
test
/
on_inject_helpers
'
'
ember
-
testing
/
test
/
promise
'
'
ember
-
testing
/
test
/
waiters
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
exports
_helpers
_on_inject_helpers
_promise
_waiters
_adapter
)
{
'
use
strict
'
;
var
Test
=
{
_helpers
:
_helpers
.
helpers
registerHelper
:
_helpers
.
registerHelper
registerAsyncHelper
:
_helpers
.
registerAsyncHelper
unregisterHelper
:
_helpers
.
unregisterHelper
onInjectHelpers
:
_on_inject_helpers
.
onInjectHelpers
Promise
:
_promise
.
default
promise
:
_promise
.
promise
resolve
:
_promise
.
resolve
registerWaiter
:
_waiters
.
registerWaiter
unregisterWaiter
:
_waiters
.
unregisterWaiter
checkWaiters
:
_waiters
.
checkWaiters
}
;
Object
.
defineProperty
(
Test
'
adapter
'
{
get
:
_adapter
.
getAdapter
set
:
_adapter
.
setAdapter
}
)
;
exports
.
default
=
Test
;
}
)
;
enifed
(
'
ember
-
testing
/
test
/
adapter
'
[
'
exports
'
'
ember
-
console
'
'
ember
-
metal
'
]
function
(
exports
_emberConsole
_emberMetal
)
{
'
use
strict
'
;
exports
.
getAdapter
=
getAdapter
;
exports
.
setAdapter
=
setAdapter
;
exports
.
asyncStart
=
asyncStart
;
exports
.
asyncEnd
=
asyncEnd
;
var
adapter
=
void
0
;
function
getAdapter
(
)
{
return
adapter
;
}
function
setAdapter
(
value
)
{
adapter
=
value
;
if
(
value
&
&
typeof
value
.
exception
=
=
=
'
function
'
)
{
(
0
_emberMetal
.
setDispatchOverride
)
(
adapterDispatch
)
;
}
else
{
(
0
_emberMetal
.
setDispatchOverride
)
(
null
)
;
}
}
function
asyncStart
(
)
{
if
(
adapter
)
{
adapter
.
asyncStart
(
)
;
}
}
function
asyncEnd
(
)
{
if
(
adapter
)
{
adapter
.
asyncEnd
(
)
;
}
}
function
adapterDispatch
(
error
)
{
adapter
.
exception
(
error
)
;
_emberConsole
.
default
.
error
(
error
.
stack
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
helpers
'
[
'
exports
'
'
ember
-
testing
/
test
/
promise
'
]
function
(
exports
_promise
)
{
'
use
strict
'
;
exports
.
helpers
=
undefined
;
exports
.
registerHelper
=
registerHelper
;
exports
.
registerAsyncHelper
=
registerAsyncHelper
;
exports
.
unregisterHelper
=
unregisterHelper
;
var
helpers
=
exports
.
helpers
=
{
}
;
function
registerHelper
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
false
}
}
;
}
function
registerAsyncHelper
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
true
}
}
;
}
function
unregisterHelper
(
name
)
{
delete
helpers
[
name
]
;
delete
_promise
.
default
.
prototype
[
name
]
;
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
on_inject_helpers
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
onInjectHelpers
=
onInjectHelpers
;
exports
.
invokeInjectHelpersCallbacks
=
invokeInjectHelpersCallbacks
;
var
callbacks
=
exports
.
callbacks
=
[
]
;
function
onInjectHelpers
(
callback
)
{
callbacks
.
push
(
callback
)
;
}
function
invokeInjectHelpersCallbacks
(
app
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
(
app
)
;
}
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
pending_requests
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
pendingRequests
=
pendingRequests
;
exports
.
clearPendingRequests
=
clearPendingRequests
;
exports
.
incrementPendingRequests
=
incrementPendingRequests
;
exports
.
decrementPendingRequests
=
decrementPendingRequests
;
var
requests
=
[
]
;
function
pendingRequests
(
)
{
return
requests
.
length
;
}
function
clearPendingRequests
(
)
{
requests
.
length
=
0
;
}
function
incrementPendingRequests
(
_
xhr
)
{
requests
.
push
(
xhr
)
;
}
function
decrementPendingRequests
(
_
xhr
)
{
for
(
var
i
=
0
;
i
<
requests
.
length
;
i
+
+
)
{
if
(
xhr
=
=
=
requests
[
i
]
)
{
requests
.
splice
(
i
1
)
;
break
;
}
}
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
promise
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
runtime
'
'
ember
-
testing
/
test
/
run
'
]
function
(
exports
_emberBabel
_emberRuntime
_run
)
{
'
use
strict
'
;
exports
.
promise
=
promise
;
exports
.
resolve
=
resolve
;
exports
.
getLastPromise
=
getLastPromise
;
var
lastPromise
=
void
0
;
var
TestPromise
=
function
(
_RSVP
Promise
)
{
(
0
_emberBabel
.
inherits
)
(
TestPromise
_RSVP
Promise
)
;
function
TestPromise
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TestPromise
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_RSVP
Promise
.
apply
(
this
arguments
)
)
;
lastPromise
=
_this
;
return
_this
;
}
TestPromise
.
prototype
.
then
=
function
then
(
_onFulfillment
)
{
var
_RSVP
Promise
prototy
;
var
onFulfillment
=
typeof
_onFulfillment
=
=
=
'
function
'
?
function
(
result
)
{
return
isolate
(
_onFulfillment
result
)
;
}
:
undefined
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
(
_RSVP
Promise
prototy
=
_RSVP
Promise
.
prototype
.
then
)
.
call
.
apply
(
_RSVP
Promise
prototy
[
this
onFulfillment
]
.
concat
(
args
)
)
;
}
;
return
TestPromise
;
}
(
_emberRuntime
.
RSVP
.
Promise
)
;
exports
.
default
=
TestPromise
;
function
promise
(
resolver
label
)
{
var
fullLabel
=
'
Ember
.
Test
.
promise
:
'
+
(
label
|
|
'
<
Unknown
Promise
>
'
)
;
return
new
TestPromise
(
resolver
fullLabel
)
;
}
function
resolve
(
result
label
)
{
return
TestPromise
.
resolve
(
result
label
)
;
}
function
getLastPromise
(
)
{
return
lastPromise
;
}
function
isolate
(
onFulfillment
result
)
{
lastPromise
=
null
;
var
value
=
onFulfillment
(
result
)
;
var
promise
=
lastPromise
;
lastPromise
=
null
;
if
(
value
&
&
value
instanceof
TestPromise
|
|
!
promise
)
{
return
value
;
}
else
{
return
(
0
_run
.
default
)
(
function
(
)
{
return
resolve
(
promise
)
.
then
(
function
(
)
{
return
value
;
}
)
;
}
)
;
}
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
run
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
run
;
function
run
(
fn
)
{
if
(
!
_emberMetal
.
run
.
currentRunLoop
)
{
return
(
0
_emberMetal
.
run
)
(
fn
)
;
}
else
{
return
fn
(
)
;
}
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
waiters
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
registerWaiter
=
registerWaiter
;
exports
.
unregisterWaiter
=
unregisterWaiter
;
exports
.
checkWaiters
=
checkWaiters
;
var
contexts
=
[
]
;
var
callbacks
=
[
]
;
function
registerWaiter
(
context
callback
)
{
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
if
(
indexOf
(
context
callback
)
>
-
1
)
{
return
;
}
contexts
.
push
(
context
)
;
callbacks
.
push
(
callback
)
;
}
function
unregisterWaiter
(
context
callback
)
{
if
(
!
callbacks
.
length
)
{
return
;
}
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
var
i
=
indexOf
(
context
callback
)
;
if
(
i
=
=
=
-
1
)
{
return
;
}
contexts
.
splice
(
i
1
)
;
callbacks
.
splice
(
i
1
)
;
}
function
checkWaiters
(
)
{
if
(
!
callbacks
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
context
=
contexts
[
i
]
;
var
callback
=
callbacks
[
i
]
;
if
(
!
callback
.
call
(
context
)
)
{
return
true
;
}
}
return
false
;
}
function
indexOf
(
context
callback
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
if
(
callbacks
[
i
]
=
=
=
callback
&
&
contexts
[
i
]
=
=
=
context
)
{
return
i
;
}
}
return
-
1
;
}
}
)
;
enifed
(
'
ember
-
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
intern
(
str
)
{
var
obj
=
{
}
;
obj
[
str
]
=
1
;
for
(
var
key
in
obj
)
{
if
(
key
=
=
=
str
)
{
return
key
;
}
}
return
str
;
}
var
_uuid
=
0
;
function
uuid
(
)
{
return
+
+
_uuid
;
}
var
GUID_PREFIX
=
'
ember
'
;
var
numberCache
=
[
]
;
var
stringCache
=
{
}
;
var
GUID_KEY
=
intern
(
'
__ember
'
+
+
new
Date
(
)
)
;
var
GUID_DESC
=
{
writable
:
true
configurable
:
true
enumerable
:
false
value
:
null
}
;
var
nullDescriptor
=
{
configurable
:
true
writable
:
true
enumerable
:
false
value
:
null
}
;
var
GUID_KEY_PROPERTY
=
{
name
:
GUID_KEY
descriptor
:
nullDescriptor
}
;
function
generateGuid
(
obj
)
{
var
prefix
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
GUID_PREFIX
;
var
ret
=
prefix
+
uuid
(
)
;
if
(
obj
!
=
=
undefined
&
&
obj
!
=
=
null
)
{
if
(
obj
[
GUID_KEY
]
=
=
=
null
)
{
obj
[
GUID_KEY
]
=
ret
;
}
else
{
GUID_DESC
.
value
=
ret
;
if
(
obj
.
__defineNonEnumerable
)
{
obj
.
__defineNonEnumerable
(
GUID_KEY_PROPERTY
)
;
}
else
{
Object
.
defineProperty
(
obj
GUID_KEY
GUID_DESC
)
;
}
}
}
return
ret
;
}
function
guidFor
(
obj
)
{
if
(
obj
=
=
=
undefined
)
{
return
'
(
undefined
)
'
;
}
if
(
obj
=
=
=
null
)
{
return
'
(
null
)
'
;
}
var
type
=
typeof
obj
;
if
(
(
type
=
=
=
'
object
'
|
|
type
=
=
=
'
function
'
)
&
&
obj
[
GUID_KEY
]
)
{
return
obj
[
GUID_KEY
]
;
}
var
ret
=
void
0
;
switch
(
type
)
{
case
'
number
'
:
ret
=
numberCache
[
obj
]
;
if
(
!
ret
)
{
ret
=
numberCache
[
obj
]
=
'
nu
'
+
obj
;
}
return
ret
;
case
'
string
'
:
ret
=
stringCache
[
obj
]
;
if
(
!
ret
)
{
ret
=
stringCache
[
obj
]
=
'
st
'
+
uuid
(
)
;
}
return
ret
;
case
'
boolean
'
:
return
obj
?
'
(
true
)
'
:
'
(
false
)
'
;
default
:
if
(
obj
=
=
=
Object
)
{
return
'
(
Object
)
'
;
}
if
(
obj
=
=
=
Array
)
{
return
'
(
Array
)
'
;
}
return
generateGuid
(
obj
)
;
}
}
function
symbol
(
debugName
)
{
var
id
=
GUID_KEY
+
Math
.
floor
(
Math
.
random
(
)
*
new
Date
(
)
)
;
return
intern
(
'
__
'
+
debugName
+
id
+
'
__
'
)
;
}
var
OWNER
=
symbol
(
'
OWNER
'
)
;
function
getOwner
(
object
)
{
return
object
[
OWNER
]
;
}
function
setOwner
(
object
owner
)
{
object
[
OWNER
]
=
owner
;
}
function
assign
(
original
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
{
continue
;
}
var
updates
=
Object
.
keys
(
arg
)
;
for
(
var
_i
=
0
;
_i
<
updates
.
length
;
_i
+
+
)
{
var
prop
=
updates
[
_i
]
;
original
[
prop
]
=
arg
[
prop
]
;
}
}
return
original
;
}
var
assign
1
=
Object
.
assign
|
|
assign
;
function
makeDictionary
(
parent
)
{
var
dict
=
Object
.
create
(
parent
)
;
dict
[
'
_dict
'
]
=
null
;
delete
dict
[
'
_dict
'
]
;
return
dict
;
}
var
HAS_SUPER_PATTERN
=
/
\
.
(
_super
|
call
\
(
this
|
apply
\
(
this
)
/
;
var
fnToString
=
Function
.
prototype
.
toString
;
var
checkHasSuper
=
function
(
)
{
var
sourceAvailable
=
fnToString
.
call
(
function
(
)
{
return
this
;
}
)
.
indexOf
(
'
return
this
'
)
>
-
1
;
if
(
sourceAvailable
)
{
return
function
checkHasSuper
(
func
)
{
return
HAS_SUPER_PATTERN
.
test
(
fnToString
.
call
(
func
)
)
;
}
;
}
return
function
checkHasSuper
(
)
{
return
true
;
}
;
}
(
)
;
function
ROOT
(
)
{
}
ROOT
.
__hasSuper
=
false
;
function
hasSuper
(
func
)
{
if
(
func
.
__hasSuper
=
=
=
undefined
)
{
func
.
__hasSuper
=
checkHasSuper
(
func
)
;
}
return
func
.
__hasSuper
;
}
function
wrap
(
func
superFunc
)
{
if
(
!
hasSuper
(
func
)
)
{
return
func
;
}
if
(
!
superFunc
.
wrappedFunction
&
&
hasSuper
(
superFunc
)
)
{
return
_wrap
(
func
_wrap
(
superFunc
ROOT
)
)
;
}
return
_wrap
(
func
superFunc
)
;
}
function
_wrap
(
func
superFunc
)
{
function
superWrapper
(
)
{
var
orig
=
this
.
_super
;
this
.
_super
=
superFunc
;
var
ret
=
func
.
apply
(
this
arguments
)
;
this
.
_super
=
orig
;
return
ret
;
}
superWrapper
.
wrappedFunction
=
func
;
superWrapper
.
__ember_observes__
=
func
.
__ember_observes__
;
superWrapper
.
__ember_observesBefore__
=
func
.
__ember_observesBefore__
;
superWrapper
.
__ember_listens__
=
func
.
__ember_listens__
;
return
superWrapper
;
}
var
objectToString
=
Object
.
prototype
.
toString
;
function
inspect
(
obj
)
{
if
(
obj
=
=
=
null
)
{
return
'
null
'
;
}
if
(
obj
=
=
=
undefined
)
{
return
'
undefined
'
;
}
if
(
Array
.
isArray
(
obj
)
)
{
return
'
[
'
+
obj
+
'
]
'
;
}
var
type
=
typeof
obj
;
if
(
type
!
=
=
'
object
'
&
&
type
!
=
=
'
symbol
'
)
{
return
'
'
+
obj
;
}
if
(
typeof
obj
.
toString
=
=
=
'
function
'
&
&
obj
.
toString
!
=
=
objectToString
)
{
return
obj
.
toString
(
)
;
}
var
v
=
void
0
;
var
ret
=
[
]
;
for
(
var
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
v
=
obj
[
key
]
;
if
(
v
=
=
=
'
toString
'
)
{
continue
;
}
if
(
typeof
v
=
=
=
'
function
'
)
{
v
=
'
function
(
)
{
.
.
.
}
'
;
}
if
(
v
&
&
typeof
v
.
toString
!
=
=
'
function
'
)
{
ret
.
push
(
key
+
'
:
'
+
objectToString
.
call
(
v
)
)
;
}
else
{
ret
.
push
(
key
+
'
:
'
+
v
)
;
}
}
}
return
'
{
'
+
ret
.
join
(
'
'
)
+
'
}
'
;
}
function
lookupDescriptor
(
obj
keyName
)
{
var
current
=
obj
;
while
(
current
)
{
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
current
keyName
)
;
if
(
descriptor
)
{
return
descriptor
;
}
current
=
Object
.
getPrototypeOf
(
current
)
;
}
return
null
;
}
function
applyStr
(
t
m
a
)
{
var
l
=
a
&
&
a
.
length
;
if
(
!
a
|
|
!
l
)
{
return
t
[
m
]
(
)
;
}
switch
(
l
)
{
case
1
:
return
t
[
m
]
(
a
[
0
]
)
;
case
2
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
)
;
case
3
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
)
;
case
4
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
a
[
3
]
)
;
case
5
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
a
[
3
]
a
[
4
]
)
;
default
:
return
t
[
m
]
.
apply
(
t
a
)
;
}
}
function
canInvoke
(
obj
methodName
)
{
return
obj
!
=
=
null
&
&
obj
!
=
=
undefined
&
&
typeof
obj
[
methodName
]
=
=
=
'
function
'
;
}
function
tryInvoke
(
obj
methodName
args
)
{
if
(
canInvoke
(
obj
methodName
)
)
{
return
applyStr
(
obj
methodName
args
)
;
}
}
var
isArray
=
Array
.
isArray
;
function
makeArray
(
obj
)
{
if
(
obj
=
=
=
null
|
|
obj
=
=
=
undefined
)
{
return
[
]
;
}
return
isArray
(
obj
)
?
obj
:
[
obj
]
;
}
var
name
=
symbol
(
'
NAME_KEY
'
)
;
var
objectToString
1
=
Object
.
prototype
.
toString
;
function
isNone
(
obj
)
{
return
obj
=
=
=
null
|
|
obj
=
=
=
undefined
;
}
function
toString
(
obj
)
{
var
type
=
typeof
obj
;
if
(
type
=
=
=
"
string
"
)
{
return
obj
;
}
if
(
Array
.
isArray
(
obj
)
)
{
var
len
=
obj
.
length
;
var
r
=
'
'
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
if
(
k
>
0
)
{
r
+
=
'
'
;
}
if
(
!
isNone
(
obj
[
k
]
)
)
{
r
+
=
toString
(
obj
[
k
]
)
;
}
}
return
r
;
}
else
if
(
obj
!
=
null
&
&
typeof
obj
.
toString
=
=
=
'
function
'
)
{
return
obj
.
toString
(
)
;
}
else
{
return
objectToString
1
.
call
(
obj
)
;
}
}
var
HAS_NATIVE_PROXY
=
typeof
Proxy
=
=
=
'
function
'
;
exports
.
symbol
=
symbol
;
exports
.
getOwner
=
getOwner
;
exports
.
setOwner
=
setOwner
;
exports
.
OWNER
=
OWNER
;
exports
.
assign
=
assign
1
;
exports
.
assignPolyfill
=
assign
;
exports
.
dictionary
=
makeDictionary
;
exports
.
uuid
=
uuid
;
exports
.
GUID_KEY
=
GUID_KEY
;
exports
.
GUID_DESC
=
GUID_DESC
;
exports
.
GUID_KEY_PROPERTY
=
GUID_KEY_PROPERTY
;
exports
.
generateGuid
=
generateGuid
;
exports
.
guidFor
=
guidFor
;
exports
.
intern
=
intern
;
exports
.
checkHasSuper
=
checkHasSuper
;
exports
.
ROOT
=
ROOT
;
exports
.
wrap
=
wrap
;
exports
.
inspect
=
inspect
;
exports
.
lookupDescriptor
=
lookupDescriptor
;
exports
.
canInvoke
=
canInvoke
;
exports
.
tryInvoke
=
tryInvoke
;
exports
.
makeArray
=
makeArray
;
exports
.
applyStr
=
applyStr
;
exports
.
NAME_KEY
=
name
;
exports
.
toString
=
toString
;
exports
.
HAS_NATIVE_PROXY
=
HAS_NATIVE_PROXY
;
}
)
;
enifed
(
'
ember
-
views
/
compat
/
attrs
'
[
'
exports
'
'
ember
-
utils
'
]
function
(
exports
_emberUtils
)
{
'
use
strict
'
;
exports
.
MUTABLE_CELL
=
undefined
;
var
MUTABLE_CELL
=
exports
.
MUTABLE_CELL
=
(
0
_emberUtils
.
symbol
)
(
'
MUTABLE_CELL
'
)
;
}
)
;
enifed
(
'
ember
-
views
/
compat
/
fallback
-
view
-
registry
'
[
'
exports
'
'
ember
-
utils
'
]
function
(
exports
_emberUtils
)
{
'
use
strict
'
;
exports
.
default
=
(
0
_emberUtils
.
dictionary
)
(
null
)
;
}
)
;
enifed
(
'
ember
-
views
/
component_lookup
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
runtime
'
]
function
(
exports
_emberDebug
_emberRuntime
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
componentFor
:
function
(
name
owner
options
)
{
(
true
&
&
!
(
~
name
.
indexOf
(
'
-
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
\
'
'
+
name
+
'
\
'
as
a
component
name
.
Component
names
must
contain
a
hyphen
.
'
~
name
.
indexOf
(
'
-
'
)
)
)
;
var
fullName
=
'
component
:
'
+
name
;
return
owner
.
factoryFor
(
fullName
options
)
;
}
layoutFor
:
function
(
name
owner
options
)
{
(
true
&
&
!
(
~
name
.
indexOf
(
'
-
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
\
'
'
+
name
+
'
\
'
as
a
component
name
.
Component
names
must
contain
a
hyphen
.
'
~
name
.
indexOf
(
'
-
'
)
)
)
;
var
templateFullName
=
'
template
:
components
/
'
+
name
;
return
owner
.
lookup
(
templateFullName
options
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
index
'
[
'
exports
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
views
/
system
/
event_dispatcher
'
'
ember
-
views
/
component_lookup
'
'
ember
-
views
/
mixins
/
text_support
'
'
ember
-
views
/
views
/
core_view
'
'
ember
-
views
/
mixins
/
class_names_support
'
'
ember
-
views
/
mixins
/
child_views_support
'
'
ember
-
views
/
mixins
/
view_state_support
'
'
ember
-
views
/
mixins
/
view_support
'
'
ember
-
views
/
mixins
/
action_support
'
'
ember
-
views
/
compat
/
attrs
'
'
ember
-
views
/
system
/
lookup_partial
'
'
ember
-
views
/
utils
/
lookup
-
component
'
'
ember
-
views
/
system
/
action_manager
'
'
ember
-
views
/
compat
/
fallback
-
view
-
registry
'
'
ember
-
views
/
system
/
ext
'
]
function
(
exports
_jquery
_utils
_event_dispatcher
_component_lookup
_text_support
_core_view
_class_names_support
_child_views_support
_view_state_support
_view_support
_action_support
_attrs
_lookup_partial
_lookupComponent
_action_manager
_fallbackViewRegistry
)
{
'
use
strict
'
;
exports
.
fallbackViewRegistry
=
exports
.
ActionManager
=
exports
.
lookupComponent
=
exports
.
hasPartial
=
exports
.
lookupPartial
=
exports
.
MUTABLE_CELL
=
exports
.
ActionSupport
=
exports
.
ViewMixin
=
exports
.
ViewStateSupport
=
exports
.
ChildViewsSupport
=
exports
.
ClassNamesSupport
=
exports
.
CoreView
=
exports
.
TextSupport
=
exports
.
ComponentLookup
=
exports
.
EventDispatcher
=
exports
.
constructStyleDeprecationMessage
=
exports
.
setViewElement
=
exports
.
getViewElement
=
exports
.
getViewId
=
exports
.
getChildViews
=
exports
.
getRootViews
=
exports
.
getViewBoundingClientRect
=
exports
.
getViewClientRects
=
exports
.
getViewBounds
=
exports
.
isSimpleClick
=
exports
.
jQuery
=
undefined
;
Object
.
defineProperty
(
exports
'
jQuery
'
{
enumerable
:
true
get
:
function
(
)
{
return
_jquery
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isSimpleClick
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
isSimpleClick
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getViewBounds
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getViewBounds
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getViewClientRects
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getViewClientRects
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getViewBoundingClientRect
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getViewBoundingClientRect
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getRootViews
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getRootViews
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getChildViews
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getChildViews
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getViewId
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getViewId
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getViewElement
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
getViewElement
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setViewElement
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
setViewElement
;
}
}
)
;
Object
.
defineProperty
(
exports
'
constructStyleDeprecationMessage
'
{
enumerable
:
true
get
:
function
(
)
{
return
_utils
.
constructStyleDeprecationMessage
;
}
}
)
;
Object
.
defineProperty
(
exports
'
EventDispatcher
'
{
enumerable
:
true
get
:
function
(
)
{
return
_event_dispatcher
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ComponentLookup
'
{
enumerable
:
true
get
:
function
(
)
{
return
_component_lookup
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TextSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_text_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
CoreView
'
{
enumerable
:
true
get
:
function
(
)
{
return
_core_view
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ClassNamesSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_class_names_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ChildViewsSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_child_views_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ViewStateSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_view_state_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ViewMixin
'
{
enumerable
:
true
get
:
function
(
)
{
return
_view_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ActionSupport
'
{
enumerable
:
true
get
:
function
(
)
{
return
_action_support
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
MUTABLE_CELL
'
{
enumerable
:
true
get
:
function
(
)
{
return
_attrs
.
MUTABLE_CELL
;
}
}
)
;
Object
.
defineProperty
(
exports
'
lookupPartial
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lookup_partial
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
hasPartial
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lookup_partial
.
hasPartial
;
}
}
)
;
Object
.
defineProperty
(
exports
'
lookupComponent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_lookupComponent
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ActionManager
'
{
enumerable
:
true
get
:
function
(
)
{
return
_action_manager
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
fallbackViewRegistry
'
{
enumerable
:
true
get
:
function
(
)
{
return
_fallbackViewRegistry
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
action_support
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
views
/
compat
/
attrs
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_attrs
)
{
'
use
strict
'
;
function
validateAction
(
component
actionName
)
{
if
(
actionName
&
&
actionName
[
_attrs
.
MUTABLE_CELL
]
)
{
actionName
=
actionName
.
value
;
}
(
true
&
&
!
(
(
0
_emberMetal
.
isNone
)
(
actionName
)
|
|
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
default
action
was
triggered
on
the
component
'
+
component
.
toString
(
)
+
'
but
the
action
name
(
'
+
actionName
+
'
)
was
not
a
string
.
'
(
0
_emberMetal
.
isNone
)
(
actionName
)
|
|
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
)
;
return
actionName
;
}
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
sendAction
:
function
(
action
)
{
for
(
var
_len
=
arguments
.
length
contexts
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
contexts
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
actionName
=
void
0
;
if
(
action
=
=
=
undefined
)
{
action
=
'
action
'
;
}
actionName
=
(
0
_emberMetal
.
get
)
(
this
'
attrs
.
'
+
action
)
|
|
(
0
_emberMetal
.
get
)
(
this
action
)
;
actionName
=
validateAction
(
this
actionName
)
;
if
(
actionName
=
=
=
undefined
)
{
return
;
}
if
(
typeof
actionName
=
=
=
'
function
'
)
{
actionName
.
apply
(
undefined
contexts
)
;
}
else
{
this
.
triggerAction
(
{
action
:
actionName
actionContext
:
contexts
}
)
;
}
}
send
:
function
(
actionName
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
>
1
?
_len2
-
1
:
0
)
_key2
=
1
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
1
]
=
arguments
[
_key2
]
;
}
var
action
=
this
.
actions
&
&
this
.
actions
[
actionName
]
;
if
(
action
)
{
var
shouldBubble
=
action
.
apply
(
this
args
)
=
=
=
true
;
if
(
!
shouldBubble
)
{
return
;
}
}
var
target
=
(
0
_emberMetal
.
get
)
(
this
'
target
'
)
;
if
(
target
)
{
(
true
&
&
!
(
typeof
target
.
send
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
The
target
for
'
+
this
+
'
(
'
+
target
+
'
)
does
not
have
a
send
method
'
typeof
target
.
send
=
=
=
'
function
'
)
)
;
target
.
send
.
apply
(
target
arguments
)
;
}
else
{
(
true
&
&
!
(
action
)
&
&
(
0
_emberDebug
.
assert
)
(
(
0
_emberUtils
.
inspect
)
(
this
)
+
'
had
no
action
handler
for
:
'
+
actionName
action
)
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
child_views_support
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
views
/
system
/
utils
'
]
function
(
exports
_emberUtils
_emberMetal
_utils
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
0
_utils
.
initChildViews
)
(
this
)
;
}
childViews
:
(
0
_emberMetal
.
descriptor
)
(
{
configurable
:
false
enumerable
:
false
get
:
function
(
)
{
return
(
0
_utils
.
getChildViews
)
(
this
)
;
}
}
)
appendChild
:
function
(
view
)
{
this
.
linkChild
(
view
)
;
(
0
_utils
.
addChildView
)
(
this
view
)
;
}
linkChild
:
function
(
instance
)
{
if
(
!
(
0
_emberUtils
.
getOwner
)
(
instance
)
)
{
(
0
_emberUtils
.
setOwner
)
(
instance
(
0
_emberUtils
.
getOwner
)
(
this
)
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
class_names_support
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
debug
'
]
function
(
exports
_emberMetal
_emberDebug
)
{
'
use
strict
'
;
var
EMPTY_ARRAY
=
Object
.
freeze
(
[
]
)
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
concatenatedProperties
:
[
'
classNames
'
'
classNameBindings
'
]
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
true
&
&
!
(
(
0
_emberMetal
.
descriptorFor
)
(
this
'
classNameBindings
'
)
=
=
=
undefined
&
&
Array
.
isArray
(
this
.
classNameBindings
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Only
arrays
are
allowed
for
\
'
classNameBindings
\
'
'
(
0
_emberMetal
.
descriptorFor
)
(
this
'
classNameBindings
'
)
=
=
=
undefined
&
&
Array
.
isArray
(
this
.
classNameBindings
)
)
)
;
(
true
&
&
!
(
(
0
_emberMetal
.
descriptorFor
)
(
this
'
classNames
'
)
=
=
=
undefined
&
&
Array
.
isArray
(
this
.
classNames
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Only
arrays
of
static
class
strings
are
allowed
for
\
'
classNames
\
'
.
For
dynamic
classes
use
\
'
classNameBindings
\
'
.
'
(
0
_emberMetal
.
descriptorFor
)
(
this
'
classNames
'
)
=
=
=
undefined
&
&
Array
.
isArray
(
this
.
classNames
)
)
)
;
}
classNames
:
EMPTY_ARRAY
classNameBindings
:
EMPTY_ARRAY
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
text_support
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
]
function
(
exports
_emberMetal
_emberRuntime
)
{
'
use
strict
'
;
var
KEY_EVENTS
=
{
13
:
'
insertNewline
'
27
:
'
cancel
'
}
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
_emberRuntime
.
TargetActionSupport
{
value
:
'
'
attributeBindings
:
[
'
autocapitalize
'
'
autocorrect
'
'
autofocus
'
'
disabled
'
'
form
'
'
maxlength
'
'
minlength
'
'
placeholder
'
'
readonly
'
'
required
'
'
selectionDirection
'
'
spellcheck
'
'
tabindex
'
'
title
'
]
placeholder
:
null
disabled
:
false
maxlength
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
on
(
'
paste
'
this
this
.
_elementValueDidChange
)
;
this
.
on
(
'
cut
'
this
this
.
_elementValueDidChange
)
;
this
.
on
(
'
input
'
this
this
.
_elementValueDidChange
)
;
}
bubbles
:
false
interpretKeyEvents
:
function
(
event
)
{
var
map
=
KEY_EVENTS
;
var
method
=
map
[
event
.
keyCode
]
;
this
.
_elementValueDidChange
(
)
;
if
(
method
)
{
return
this
[
method
]
(
event
)
;
}
}
_elementValueDidChange
:
function
(
)
{
(
0
_emberMetal
.
set
)
(
this
'
value
'
this
.
element
.
value
)
;
}
change
:
function
(
event
)
{
this
.
_elementValueDidChange
(
event
)
;
}
insertNewline
:
function
(
event
)
{
sendAction
(
'
enter
'
this
event
)
;
sendAction
(
'
insert
-
newline
'
this
event
)
;
}
cancel
:
function
(
event
)
{
sendAction
(
'
escape
-
press
'
this
event
)
;
}
focusIn
:
function
(
event
)
{
sendAction
(
'
focus
-
in
'
this
event
)
;
}
focusOut
:
function
(
event
)
{
this
.
_elementValueDidChange
(
event
)
;
sendAction
(
'
focus
-
out
'
this
event
)
;
}
keyPress
:
function
(
event
)
{
sendAction
(
'
key
-
press
'
this
event
)
;
}
keyUp
:
function
(
event
)
{
this
.
interpretKeyEvents
(
event
)
;
this
.
sendAction
(
'
key
-
up
'
(
0
_emberMetal
.
get
)
(
this
'
value
'
)
event
)
;
}
keyDown
:
function
(
event
)
{
this
.
sendAction
(
'
key
-
down
'
(
0
_emberMetal
.
get
)
(
this
'
value
'
)
event
)
;
}
}
)
;
function
sendAction
(
eventName
view
event
)
{
var
action
=
(
0
_emberMetal
.
get
)
(
view
'
attrs
.
'
+
eventName
)
|
|
(
0
_emberMetal
.
get
)
(
view
eventName
)
;
var
value
=
(
0
_emberMetal
.
get
)
(
view
'
value
'
)
;
view
.
sendAction
(
eventName
value
)
;
if
(
action
&
&
!
(
0
_emberMetal
.
get
)
(
view
'
bubbles
'
)
)
{
event
.
stopPropagation
(
)
;
}
}
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_state_support
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
{
_transitionTo
:
function
(
state
)
{
var
priorState
=
this
.
_currentState
;
var
currentState
=
this
.
_currentState
=
this
.
_states
[
state
]
;
this
.
_state
=
state
;
if
(
priorState
&
&
priorState
.
exit
)
{
priorState
.
exit
(
this
)
;
}
if
(
currentState
.
enter
)
{
currentState
.
enter
(
this
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_support
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
environment
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
views
/
system
/
jquery
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_emberEnvironment
_utils
_core_object
_jquery
)
{
'
use
strict
'
;
var
_Mixin
create
;
function
K
(
)
{
return
this
;
}
exports
.
default
=
_emberMetal
.
Mixin
.
create
(
(
_Mixin
create
=
{
concatenatedProperties
:
[
'
attributeBindings
'
]
}
_Mixin
create
[
_core_object
.
POST_INIT
]
=
function
(
)
{
if
(
_emberEnvironment
.
ENV
.
_ENABLE_DID_INIT_ATTRS_SUPPORT
=
=
=
true
)
{
this
.
trigger
(
'
didInitAttrs
'
)
;
}
this
.
trigger
(
'
didReceiveAttrs
'
)
;
}
_Mixin
create
.
nearestOfType
=
function
(
klass
)
{
var
view
=
this
.
parentView
;
var
isOfType
=
klass
instanceof
_emberMetal
.
Mixin
?
function
(
view
)
{
return
klass
.
detect
(
view
)
;
}
:
function
(
view
)
{
return
klass
.
detect
(
view
.
constructor
)
;
}
;
while
(
view
)
{
if
(
isOfType
(
view
)
)
{
return
view
;
}
view
=
view
.
parentView
;
}
}
_Mixin
create
.
nearestWithProperty
=
function
(
property
)
{
var
view
=
this
.
parentView
;
while
(
view
)
{
if
(
property
in
view
)
{
return
view
;
}
view
=
view
.
parentView
;
}
}
_Mixin
create
.
rerender
=
function
(
)
{
return
this
.
_currentState
.
rerender
(
this
)
;
}
_Mixin
create
.
element
=
(
0
_emberMetal
.
descriptor
)
(
{
configurable
:
false
enumerable
:
false
get
:
function
(
)
{
return
this
.
renderer
.
getElement
(
this
)
;
}
}
)
_Mixin
create
.
=
function
(
sel
)
{
(
true
&
&
!
(
this
.
tagName
!
=
=
'
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
access
this
.
(
)
on
a
component
with
tagName
:
\
'
\
'
specified
.
'
this
.
tagName
!
=
=
'
'
)
)
;
if
(
this
.
element
)
{
return
sel
?
(
0
_jquery
.
default
)
(
sel
this
.
element
)
:
(
0
_jquery
.
default
)
(
this
.
element
)
;
}
}
_Mixin
create
.
appendTo
=
function
(
selector
)
{
var
env
=
this
.
_environment
|
|
_emberEnvironment
.
environment
;
var
target
=
void
0
;
if
(
env
.
hasDOM
)
{
target
=
typeof
selector
=
=
=
'
string
'
?
document
.
querySelector
(
selector
)
:
selector
;
(
true
&
&
!
(
target
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
tried
to
append
to
(
'
+
selector
+
'
)
but
that
isn
\
'
t
in
the
DOM
'
target
)
)
;
(
true
&
&
!
(
!
(
0
_utils
.
matches
)
(
target
'
.
ember
-
view
'
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
append
to
an
existing
Ember
.
View
.
'
!
(
0
_utils
.
matches
)
(
target
'
.
ember
-
view
'
)
)
)
;
(
true
&
&
!
(
function
(
)
{
var
node
=
target
.
parentNode
;
while
(
node
)
{
if
(
node
.
nodeType
!
=
=
9
&
&
(
0
_utils
.
matches
)
(
node
'
.
ember
-
view
'
)
)
{
return
false
;
}
node
=
node
.
parentNode
;
}
return
true
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
append
to
an
existing
Ember
.
View
.
'
function
(
)
{
var
node
=
target
.
parentNode
;
while
(
node
)
{
if
(
node
.
nodeType
!
=
=
9
&
&
(
0
_utils
.
matches
)
(
node
'
.
ember
-
view
'
)
)
{
return
false
;
}
node
=
node
.
parentNode
;
}
return
true
;
}
(
)
)
)
;
}
else
{
target
=
selector
;
(
true
&
&
!
(
typeof
target
!
=
=
'
string
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
tried
to
append
to
a
selector
string
(
'
+
selector
+
'
)
in
an
environment
without
jQuery
'
typeof
target
!
=
=
'
string
'
)
)
;
(
true
&
&
!
(
typeof
selector
.
appendChild
=
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
tried
to
append
to
a
non
-
Element
(
'
+
selector
+
'
)
in
an
environment
without
jQuery
'
typeof
selector
.
appendChild
=
=
=
'
function
'
)
)
;
}
this
.
renderer
.
appendTo
(
this
target
)
;
return
this
;
}
_Mixin
create
.
append
=
function
(
)
{
return
this
.
appendTo
(
document
.
body
)
;
}
_Mixin
create
.
elementId
=
null
_Mixin
create
.
findElementInParentElement
=
function
(
parentElem
)
{
var
id
=
'
#
'
+
this
.
elementId
;
return
(
0
_jquery
.
default
)
(
id
)
[
0
]
|
|
(
0
_jquery
.
default
)
(
id
parentElem
)
[
0
]
;
}
_Mixin
create
.
willInsertElement
=
K
_Mixin
create
.
didInsertElement
=
K
_Mixin
create
.
willClearRender
=
K
_Mixin
create
.
destroy
=
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_currentState
.
destroy
(
this
)
;
}
_Mixin
create
.
willDestroyElement
=
K
_Mixin
create
.
parentViewDidChange
=
K
_Mixin
create
.
tagName
=
null
_Mixin
create
.
init
=
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
(
true
&
&
!
(
(
0
_emberMetal
.
descriptorFor
)
(
this
'
elementId
'
)
=
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
a
computed
property
for
the
component
\
'
s
elementId
(
'
+
this
+
'
)
.
'
(
0
_emberMetal
.
descriptorFor
)
(
this
'
elementId
'
)
=
=
=
undefined
)
)
;
(
true
&
&
!
(
(
0
_emberMetal
.
descriptorFor
)
(
this
'
tagName
'
)
=
=
=
undefined
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
a
computed
property
for
the
component
\
'
s
tagName
(
'
+
this
+
'
)
.
'
(
0
_emberMetal
.
descriptorFor
)
(
this
'
tagName
'
)
=
=
=
undefined
)
)
;
if
(
!
this
.
elementId
&
&
this
.
tagName
!
=
=
'
'
)
{
this
.
elementId
=
(
0
_emberUtils
.
guidFor
)
(
this
)
;
}
if
(
_emberEnvironment
.
environment
.
_ENABLE_DID_INIT_ATTRS_SUPPORT
)
{
(
true
&
&
!
(
typeof
this
.
didInitAttrs
!
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
[
DEPRECATED
]
didInitAttrs
called
in
'
+
this
.
toString
(
)
+
'
.
'
typeof
this
.
didInitAttrs
!
=
=
'
function
'
{
id
:
'
ember
-
views
.
did
-
init
-
attrs
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_ember
-
component
-
didinitattrs
'
}
)
)
;
}
else
{
(
true
&
&
!
(
typeof
this
.
didInitAttrs
!
=
=
'
function
'
)
&
&
(
0
_emberDebug
.
assert
)
(
'
didInitAttrs
called
in
'
+
this
.
toString
(
)
+
'
is
no
longer
supported
.
'
typeof
this
.
didInitAttrs
!
=
=
'
function
'
)
)
;
}
(
true
&
&
!
(
!
this
.
render
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Using
a
custom
.
render
function
is
no
longer
supported
.
'
!
this
.
render
)
)
;
}
_Mixin
create
.
__defineNonEnumerable
=
function
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
_Mixin
create
.
handleEvent
=
function
(
eventName
evt
)
{
return
this
.
_currentState
.
handleEvent
(
this
eventName
evt
)
;
}
_Mixin
create
)
)
;
}
)
;
enifed
(
"
ember
-
views
/
system
/
action_manager
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
ActionManager
;
function
ActionManager
(
)
{
}
ActionManager
.
registeredActions
=
{
}
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
event_dispatcher
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
debug
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
views
/
system
/
action_manager
'
'
ember
-
views
/
compat
/
fallback
-
view
-
registry
'
]
function
(
exports
_emberUtils
_emberDebug
_emberMetal
_emberRuntime
_jquery
_action_manager
_fallbackViewRegistry
)
{
'
use
strict
'
;
var
HAS_JQUERY
=
_jquery
.
default
!
=
=
undefined
;
var
ROOT_ELEMENT_CLASS
=
'
ember
-
application
'
;
var
ROOT_ELEMENT_SELECTOR
=
'
.
'
+
ROOT_ELEMENT_CLASS
;
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
events
:
{
touchstart
:
'
touchStart
'
touchmove
:
'
touchMove
'
touchend
:
'
touchEnd
'
touchcancel
:
'
touchCancel
'
keydown
:
'
keyDown
'
keyup
:
'
keyUp
'
keypress
:
'
keyPress
'
mousedown
:
'
mouseDown
'
mouseup
:
'
mouseUp
'
contextmenu
:
'
contextMenu
'
click
:
'
click
'
dblclick
:
'
doubleClick
'
mousemove
:
'
mouseMove
'
focusin
:
'
focusIn
'
focusout
:
'
focusOut
'
mouseenter
:
'
mouseEnter
'
mouseleave
:
'
mouseLeave
'
submit
:
'
submit
'
input
:
'
input
'
change
:
'
change
'
dragstart
:
'
dragStart
'
drag
:
'
drag
'
dragenter
:
'
dragEnter
'
dragleave
:
'
dragLeave
'
dragover
:
'
dragOver
'
drop
:
'
drop
'
dragend
:
'
dragEnd
'
}
rootElement
:
'
body
'
init
:
function
(
)
{
var
_this
=
this
;
this
.
_super
(
)
;
(
true
&
&
!
(
function
(
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
_this
)
;
var
environment
=
owner
.
lookup
(
'
-
environment
:
main
'
)
;
return
environment
.
isInteractive
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
EventDispatcher
should
never
be
instantiated
in
fastboot
mode
.
Please
report
this
as
an
Ember
bug
.
'
function
(
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
_this
)
;
var
environment
=
owner
.
lookup
(
'
-
environment
:
main
'
)
;
return
environment
.
isInteractive
;
}
(
)
)
)
;
this
.
_eventHandlers
=
Object
.
create
(
null
)
;
}
setup
:
function
(
addedEvents
_rootElement
)
{
var
event
=
void
0
rootElement
=
void
0
;
var
events
=
this
.
_finalEvents
=
(
0
_emberUtils
.
assign
)
(
{
}
(
0
_emberMetal
.
get
)
(
this
'
events
'
)
addedEvents
)
;
if
(
!
(
0
_emberMetal
.
isNone
)
(
_rootElement
)
)
{
(
0
_emberMetal
.
set
)
(
this
'
rootElement
'
_rootElement
)
;
}
var
rootElementSelector
=
(
0
_emberMetal
.
get
)
(
this
'
rootElement
'
)
;
if
(
HAS_JQUERY
)
{
rootElement
=
(
0
_jquery
.
default
)
(
rootElementSelector
)
;
(
true
&
&
!
(
!
rootElement
.
is
(
ROOT_ELEMENT_SELECTOR
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
the
same
root
element
(
'
+
(
rootElement
.
selector
|
|
rootElement
[
0
]
.
tagName
)
+
'
)
multiple
times
in
an
Ember
.
Application
'
!
rootElement
.
is
(
ROOT_ELEMENT_SELECTOR
)
)
)
;
(
true
&
&
!
(
!
rootElement
.
closest
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
a
descendent
of
an
existing
Ember
.
Application
'
!
rootElement
.
closest
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
)
;
(
true
&
&
!
(
!
rootElement
.
find
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
an
ancestor
of
an
existing
Ember
.
Application
'
!
rootElement
.
find
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
)
;
rootElement
.
addClass
(
ROOT_ELEMENT_CLASS
)
;
if
(
!
rootElement
.
is
(
ROOT_ELEMENT_SELECTOR
)
)
{
throw
new
TypeError
(
'
Unable
to
add
\
'
'
+
ROOT_ELEMENT_CLASS
+
'
\
'
class
to
root
element
(
'
+
(
rootElement
.
selector
|
|
rootElement
[
0
]
.
tagName
)
+
'
)
.
Make
sure
you
set
rootElement
to
the
body
or
an
element
in
the
body
.
'
)
;
}
}
else
{
if
(
typeof
rootElementSelector
!
=
=
'
string
'
)
{
rootElement
=
rootElementSelector
;
}
else
{
rootElement
=
document
.
querySelector
(
rootElementSelector
)
;
}
(
true
&
&
!
(
!
rootElement
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
use
the
same
root
element
(
'
+
(
(
0
_emberMetal
.
get
)
(
this
'
rootElement
'
)
|
|
rootElement
.
tagName
)
+
'
)
multiple
times
in
an
Ember
.
Application
'
!
rootElement
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
)
;
(
true
&
&
!
(
function
(
)
{
var
target
=
rootElement
.
parentNode
;
do
{
if
(
target
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
{
return
false
;
}
target
=
target
.
parentNode
;
}
while
(
target
&
&
target
.
nodeType
=
=
=
1
)
;
return
true
;
}
(
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
a
descendent
of
an
existing
Ember
.
Application
'
function
(
)
{
var
target
=
rootElement
.
parentNode
;
do
{
if
(
target
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
{
return
false
;
}
target
=
target
.
parentNode
;
}
while
(
target
&
&
target
.
nodeType
=
=
=
1
)
;
return
true
;
}
(
)
)
)
;
(
true
&
&
!
(
!
rootElement
.
querySelector
(
ROOT_ELEMENT_SELECTOR
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
an
ancestor
of
an
existing
Ember
.
Application
'
!
rootElement
.
querySelector
(
ROOT_ELEMENT_SELECTOR
)
)
)
;
rootElement
.
classList
.
add
(
ROOT_ELEMENT_CLASS
)
;
(
true
&
&
!
(
rootElement
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Unable
to
add
\
'
'
+
ROOT_ELEMENT_CLASS
+
'
\
'
class
to
root
element
(
'
+
(
(
0
_emberMetal
.
get
)
(
this
'
rootElement
'
)
|
|
rootElement
.
tagName
)
+
'
)
.
Make
sure
you
set
rootElement
to
the
body
or
an
element
in
the
body
.
'
rootElement
.
classList
.
contains
(
ROOT_ELEMENT_CLASS
)
)
)
;
}
var
viewRegistry
=
this
.
_getViewRegistry
(
)
;
for
(
event
in
events
)
{
if
(
events
.
hasOwnProperty
(
event
)
)
{
this
.
setupHandler
(
rootElement
event
events
[
event
]
viewRegistry
)
;
}
}
}
setupHandler
:
function
(
rootElement
event
eventName
viewRegistry
)
{
if
(
eventName
=
=
=
null
)
{
return
;
}
if
(
HAS_JQUERY
)
{
rootElement
.
on
(
event
+
'
.
ember
'
'
.
ember
-
view
'
function
(
evt
)
{
var
view
=
viewRegistry
[
this
.
id
]
;
var
result
=
true
;
if
(
view
)
{
result
=
view
.
handleEvent
(
eventName
evt
)
;
}
return
result
;
}
)
;
rootElement
.
on
(
event
+
'
.
ember
'
'
[
data
-
ember
-
action
]
'
function
(
evt
)
{
var
attributes
=
evt
.
currentTarget
.
attributes
;
var
handledActions
=
[
]
;
for
(
var
i
=
0
;
i
<
attributes
.
length
;
i
+
+
)
{
var
attr
=
attributes
.
item
(
i
)
;
var
attrName
=
attr
.
name
;
if
(
attrName
.
lastIndexOf
(
'
data
-
ember
-
action
-
'
0
)
!
=
=
-
1
)
{
var
action
=
_action_manager
.
default
.
registeredActions
[
attr
.
value
]
;
if
(
action
&
&
action
.
eventName
=
=
=
eventName
&
&
handledActions
.
indexOf
(
action
)
=
=
=
-
1
)
{
action
.
handler
(
evt
)
;
handledActions
.
push
(
action
)
;
}
}
}
}
)
;
}
else
{
var
viewHandler
=
function
(
target
event
)
{
var
view
=
viewRegistry
[
target
.
id
]
;
var
result
=
true
;
if
(
view
)
{
result
=
view
.
handleEvent
(
eventName
event
)
;
}
return
result
;
}
;
var
actionHandler
=
function
(
target
event
)
{
var
actionId
=
target
.
getAttribute
(
'
data
-
ember
-
action
'
)
;
var
actions
=
_action_manager
.
default
.
registeredActions
[
actionId
]
;
if
(
actionId
=
=
=
'
'
)
{
var
attributes
=
target
.
attributes
;
var
attributeCount
=
attributes
.
length
;
actions
=
[
]
;
for
(
var
i
=
0
;
i
<
attributeCount
;
i
+
+
)
{
var
attr
=
attributes
.
item
(
i
)
;
var
attrName
=
attr
.
name
;
if
(
attrName
.
indexOf
(
'
data
-
ember
-
action
-
'
)
=
=
=
0
)
{
actions
=
actions
.
concat
(
_action_manager
.
default
.
registeredActions
[
attr
.
value
]
)
;
}
}
}
if
(
!
actions
)
{
return
;
}
for
(
var
index
=
0
;
index
<
actions
.
length
;
index
+
+
)
{
var
action
=
actions
[
index
]
;
if
(
action
&
&
action
.
eventName
=
=
=
eventName
)
{
return
action
.
handler
(
event
)
;
}
}
}
;
var
handleEvent
=
this
.
_eventHandlers
[
event
]
=
function
(
event
)
{
var
target
=
event
.
target
;
do
{
if
(
viewRegistry
[
target
.
id
]
)
{
if
(
viewHandler
(
target
event
)
=
=
=
false
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
break
;
}
}
else
if
(
target
.
hasAttribute
(
'
data
-
ember
-
action
'
)
)
{
actionHandler
(
target
event
)
;
break
;
}
target
=
target
.
parentNode
;
}
while
(
target
&
&
target
.
nodeType
=
=
=
1
)
;
}
;
rootElement
.
addEventListener
(
event
handleEvent
)
;
}
}
_getViewRegistry
:
function
(
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
this
)
;
var
viewRegistry
=
owner
&
&
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
|
|
_fallbackViewRegistry
.
default
;
return
viewRegistry
;
}
destroy
:
function
(
)
{
var
rootElementSelector
=
(
0
_emberMetal
.
get
)
(
this
'
rootElement
'
)
;
var
rootElement
=
void
0
;
if
(
rootElementSelector
.
nodeType
)
{
rootElement
=
rootElementSelector
;
}
else
{
rootElement
=
document
.
querySelector
(
rootElementSelector
)
;
}
if
(
!
rootElement
)
{
return
;
}
if
(
HAS_JQUERY
)
{
(
0
_jquery
.
default
)
(
rootElementSelector
)
.
off
(
'
.
ember
'
'
*
*
'
)
;
}
else
{
for
(
var
event
in
this
.
_eventHandlers
)
{
rootElement
.
removeEventListener
(
event
this
.
_eventHandlers
[
event
]
)
;
}
}
rootElement
.
classList
.
remove
(
ROOT_ELEMENT_CLASS
)
;
return
this
.
_super
.
apply
(
this
arguments
)
;
}
toString
:
function
(
)
{
return
'
(
EventDispatcher
)
'
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
ext
'
[
'
ember
-
metal
'
]
function
(
_emberMetal
)
{
'
use
strict
'
;
_emberMetal
.
run
.
_addQueue
(
'
render
'
'
actions
'
)
;
_emberMetal
.
run
.
_addQueue
(
'
afterRender
'
'
render
'
)
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
jquery
'
[
'
exports
'
'
ember
-
environment
'
]
function
(
exports
_emberEnvironment
)
{
'
use
strict
'
;
var
jQuery
=
void
0
;
if
(
_emberEnvironment
.
environment
.
hasDOM
)
{
jQuery
=
_emberEnvironment
.
context
.
imports
.
jQuery
;
if
(
jQuery
)
{
if
(
jQuery
.
event
.
addProp
)
{
jQuery
.
event
.
addProp
(
'
dataTransfer
'
)
;
}
else
{
[
'
dragstart
'
'
drag
'
'
dragenter
'
'
dragleave
'
'
dragover
'
'
drop
'
'
dragend
'
]
.
forEach
(
function
(
eventName
)
{
jQuery
.
event
.
fixHooks
[
eventName
]
=
{
props
:
[
'
dataTransfer
'
]
}
;
}
)
;
}
}
}
exports
.
default
=
jQuery
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
lookup_partial
'
[
'
exports
'
'
ember
-
debug
'
]
function
(
exports
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
lookupPartial
;
exports
.
hasPartial
=
hasPartial
;
function
parseUnderscoredName
(
templateName
)
{
var
nameParts
=
templateName
.
split
(
'
/
'
)
;
var
lastPart
=
nameParts
[
nameParts
.
length
-
1
]
;
nameParts
[
nameParts
.
length
-
1
]
=
'
_
'
+
lastPart
;
return
nameParts
.
join
(
'
/
'
)
;
}
function
lookupPartial
(
templateName
owner
)
{
if
(
templateName
=
=
null
)
{
return
;
}
var
template
=
templateFor
(
owner
parseUnderscoredName
(
templateName
)
templateName
)
;
(
true
&
&
!
(
!
!
template
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Unable
to
find
partial
with
name
"
'
+
templateName
+
'
"
'
!
!
template
)
)
;
return
template
;
}
function
hasPartial
(
name
owner
)
{
if
(
!
owner
)
{
throw
new
_emberDebug
.
Error
(
'
Container
was
not
found
when
looking
up
a
views
template
.
'
+
'
This
is
most
likely
due
to
manually
instantiating
an
Ember
.
View
.
'
+
'
See
:
http
:
/
/
git
.
io
/
EKPpnA
'
)
;
}
return
owner
.
hasRegistration
(
'
template
:
'
+
parseUnderscoredName
(
name
)
)
|
|
owner
.
hasRegistration
(
'
template
:
'
+
name
)
;
}
function
templateFor
(
owner
underscored
name
)
{
if
(
!
name
)
{
return
;
}
(
true
&
&
!
(
name
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
&
&
(
0
_emberDebug
.
assert
)
(
'
templateNames
are
not
allowed
to
contain
periods
:
'
+
name
name
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
)
;
if
(
!
owner
)
{
throw
new
_emberDebug
.
Error
(
'
Container
was
not
found
when
looking
up
a
views
template
.
'
+
'
This
is
most
likely
due
to
manually
instantiating
an
Ember
.
View
.
'
+
'
See
:
http
:
/
/
git
.
io
/
EKPpnA
'
)
;
}
return
owner
.
lookup
(
'
template
:
'
+
underscored
)
|
|
owner
.
lookup
(
'
template
:
'
+
name
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
system
/
utils
'
[
'
exports
'
'
ember
-
utils
'
]
function
(
exports
_emberUtils
)
{
'
use
strict
'
;
exports
.
elMatches
=
undefined
;
exports
.
isSimpleClick
=
isSimpleClick
;
exports
.
constructStyleDeprecationMessage
=
constructStyleDeprecationMessage
;
exports
.
getRootViews
=
getRootViews
;
exports
.
getViewId
=
getViewId
;
exports
.
getViewElement
=
getViewElement
;
exports
.
initViewElement
=
initViewElement
;
exports
.
setViewElement
=
setViewElement
;
exports
.
getChildViews
=
getChildViews
;
exports
.
initChildViews
=
initChildViews
;
exports
.
addChildView
=
addChildView
;
exports
.
collectChildViews
=
collectChildViews
;
exports
.
getViewBounds
=
getViewBounds
;
exports
.
getViewRange
=
getViewRange
;
exports
.
getViewClientRects
=
getViewClientRects
;
exports
.
getViewBoundingClientRect
=
getViewBoundingClientRect
;
exports
.
matches
=
matches
;
function
isSimpleClick
(
event
)
{
var
modifier
=
event
.
shiftKey
|
|
event
.
metaKey
|
|
event
.
altKey
|
|
event
.
ctrlKey
;
var
secondaryClick
=
event
.
which
>
1
;
return
!
modifier
&
&
!
secondaryClick
;
}
function
constructStyleDeprecationMessage
(
affectedStyle
)
{
return
'
'
+
'
Binding
style
attributes
may
introduce
cross
-
site
scripting
vulnerabilities
;
'
+
'
please
ensure
that
values
being
bound
are
properly
escaped
.
For
more
information
'
+
'
including
how
to
disable
this
warning
see
'
+
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v1
.
x
/
#
toc_binding
-
style
-
attributes
.
'
+
'
Style
affected
:
"
'
+
affectedStyle
+
'
"
'
;
}
function
getRootViews
(
owner
)
{
var
registry
=
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
var
rootViews
=
[
]
;
Object
.
keys
(
registry
)
.
forEach
(
function
(
id
)
{
var
view
=
registry
[
id
]
;
if
(
view
.
parentView
=
=
=
null
)
{
rootViews
.
push
(
view
)
;
}
}
)
;
return
rootViews
;
}
function
getViewId
(
view
)
{
if
(
view
.
tagName
=
=
=
'
'
)
{
return
(
0
_emberUtils
.
guidFor
)
(
view
)
;
}
else
{
return
view
.
elementId
|
|
(
0
_emberUtils
.
guidFor
)
(
view
)
;
}
}
var
VIEW_ELEMENT
=
(
0
_emberUtils
.
symbol
)
(
'
VIEW_ELEMENT
'
)
;
function
getViewElement
(
view
)
{
return
view
[
VIEW_ELEMENT
]
;
}
function
initViewElement
(
view
)
{
view
[
VIEW_ELEMENT
]
=
null
;
}
function
setViewElement
(
view
element
)
{
return
view
[
VIEW_ELEMENT
]
=
element
;
}
var
CHILD_VIEW_IDS
=
(
0
_emberUtils
.
symbol
)
(
'
CHILD_VIEW_IDS
'
)
;
function
getChildViews
(
view
)
{
var
owner
=
(
0
_emberUtils
.
getOwner
)
(
view
)
;
var
registry
=
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
return
collectChildViews
(
view
registry
)
;
}
function
initChildViews
(
view
)
{
view
[
CHILD_VIEW_IDS
]
=
[
]
;
}
function
addChildView
(
parent
child
)
{
parent
[
CHILD_VIEW_IDS
]
.
push
(
getViewId
(
child
)
)
;
}
function
collectChildViews
(
view
registry
)
{
var
ids
=
[
]
;
var
views
=
[
]
;
view
[
CHILD_VIEW_IDS
]
.
forEach
(
function
(
id
)
{
var
view
=
registry
[
id
]
;
if
(
view
&
&
!
view
.
isDestroying
&
&
!
view
.
isDestroyed
&
&
ids
.
indexOf
(
id
)
=
=
=
-
1
)
{
ids
.
push
(
id
)
;
views
.
push
(
view
)
;
}
}
)
;
view
[
CHILD_VIEW_IDS
]
=
ids
;
return
views
;
}
function
getViewBounds
(
view
)
{
return
view
.
renderer
.
getBounds
(
view
)
;
}
function
getViewRange
(
view
)
{
var
bounds
=
getViewBounds
(
view
)
;
var
range
=
document
.
createRange
(
)
;
range
.
setStartBefore
(
bounds
.
firstNode
)
;
range
.
setEndAfter
(
bounds
.
lastNode
)
;
return
range
;
}
function
getViewClientRects
(
view
)
{
var
range
=
getViewRange
(
view
)
;
return
range
.
getClientRects
(
)
;
}
function
getViewBoundingClientRect
(
view
)
{
var
range
=
getViewRange
(
view
)
;
return
range
.
getBoundingClientRect
(
)
;
}
var
elMatches
=
exports
.
elMatches
=
typeof
Element
!
=
=
'
undefined
'
&
&
(
Element
.
prototype
.
matches
|
|
Element
.
prototype
.
matchesSelector
|
|
Element
.
prototype
.
mozMatchesSelector
|
|
Element
.
prototype
.
msMatchesSelector
|
|
Element
.
prototype
.
oMatchesSelector
|
|
Element
.
prototype
.
webkitMatchesSelector
)
;
function
matches
(
el
selector
)
{
return
elMatches
.
call
(
el
selector
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
utils
/
lookup
-
component
'
[
'
exports
'
'
ember
-
babel
'
'
container
'
'
ember
/
features
'
]
function
(
exports
_emberBabel
_container
_features
)
{
'
use
strict
'
;
exports
.
default
=
lookupComponent
;
var
_templateObject
=
(
0
_emberBabel
.
taggedTemplateLiteralLoose
)
(
[
'
component
:
-
default
'
]
[
'
component
:
-
default
'
]
)
;
function
lookupModuleUnificationComponentPair
(
componentLookup
owner
name
options
)
{
var
localComponent
=
componentLookup
.
componentFor
(
name
owner
options
)
;
var
localLayout
=
componentLookup
.
layoutFor
(
name
owner
options
)
;
var
globalComponent
=
componentLookup
.
componentFor
(
name
owner
)
;
var
globalLayout
=
componentLookup
.
layoutFor
(
name
owner
)
;
var
localAndUniqueComponent
=
!
!
localComponent
&
&
(
!
globalComponent
|
|
localComponent
.
class
!
=
=
globalComponent
.
class
)
;
var
localAndUniqueLayout
=
!
!
localLayout
&
&
(
!
globalLayout
|
|
localLayout
.
meta
.
moduleName
!
=
=
globalLayout
.
meta
.
moduleName
)
;
if
(
localAndUniqueComponent
&
&
localAndUniqueLayout
)
{
return
{
layout
:
localLayout
component
:
localComponent
}
;
}
if
(
localAndUniqueComponent
&
&
!
localAndUniqueLayout
)
{
return
{
layout
:
null
component
:
localComponent
}
;
}
var
defaultComponentFactory
=
null
;
if
(
!
_features
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
)
{
defaultComponentFactory
=
owner
.
factoryFor
(
(
0
_container
.
privatize
)
(
_templateObject
)
)
;
}
if
(
!
localAndUniqueComponent
&
&
localAndUniqueLayout
)
{
return
{
layout
:
localLayout
component
:
defaultComponentFactory
}
;
}
var
component
=
globalComponent
|
|
globalLayout
&
&
defaultComponentFactory
;
return
{
layout
:
globalLayout
component
:
component
}
;
}
function
lookupComponentPair
(
componentLookup
owner
name
options
)
{
if
(
_features
.
EMBER_MODULE_UNIFICATION
)
{
return
lookupModuleUnificationComponentPair
(
componentLookup
owner
name
options
)
;
}
var
component
=
componentLookup
.
componentFor
(
name
owner
options
)
;
var
layout
=
componentLookup
.
layoutFor
(
name
owner
options
)
;
var
result
=
{
layout
:
layout
component
:
component
}
;
if
(
!
_features
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
&
&
layout
&
&
!
component
)
{
result
.
component
=
owner
.
factoryFor
(
(
0
_container
.
privatize
)
(
_templateObject
)
)
;
}
return
result
;
}
function
lookupComponent
(
owner
name
options
)
{
var
componentLookup
=
owner
.
lookup
(
'
component
-
lookup
:
main
'
)
;
var
source
=
options
&
&
options
.
source
;
if
(
source
)
{
var
localResult
=
lookupComponentPair
(
componentLookup
owner
name
options
)
;
if
(
localResult
.
component
|
|
localResult
.
layout
)
{
return
localResult
;
}
}
return
lookupComponentPair
(
componentLookup
owner
name
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
views
/
core_view
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
views
/
views
/
states
'
]
function
(
exports
_emberRuntime
_utils
_states
)
{
'
use
strict
'
;
var
CoreView
=
_emberRuntime
.
FrameworkObject
.
extend
(
_emberRuntime
.
Evented
_emberRuntime
.
ActionHandler
{
isView
:
true
_states
:
(
0
_states
.
cloneStates
)
(
_states
.
states
)
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_state
=
'
preRender
'
;
this
.
_currentState
=
this
.
_states
.
preRender
;
(
0
_utils
.
initViewElement
)
(
this
)
;
if
(
!
this
.
renderer
)
{
throw
new
Error
(
'
Cannot
instantiate
a
component
without
a
renderer
.
Please
ensure
that
you
are
creating
'
+
this
+
'
with
a
proper
container
/
registry
.
'
)
;
}
}
parentView
:
null
instrumentDetails
:
function
(
hash
)
{
hash
.
object
=
this
.
toString
(
)
;
hash
.
containerKey
=
this
.
_debugContainerKey
;
hash
.
view
=
this
;
return
hash
;
}
trigger
:
function
(
name
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
this
.
_super
.
apply
(
this
arguments
)
;
var
method
=
this
[
name
]
;
if
(
typeof
method
=
=
=
'
function
'
)
{
return
method
.
apply
(
this
args
)
;
}
}
has
:
function
(
name
)
{
return
typeof
this
[
name
]
=
=
=
'
function
'
|
|
this
.
_super
(
name
)
;
}
}
)
;
CoreView
.
reopenClass
(
{
isViewFactory
:
true
}
)
;
exports
.
default
=
CoreView
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
views
/
views
/
states
/
pre_render
'
'
ember
-
views
/
views
/
states
/
has_element
'
'
ember
-
views
/
views
/
states
/
in_dom
'
'
ember
-
views
/
views
/
states
/
destroying
'
]
function
(
exports
_emberUtils
_default2
_pre_render
_has_element
_in_dom
_destroying
)
{
'
use
strict
'
;
exports
.
states
=
undefined
;
exports
.
cloneStates
=
cloneStates
;
function
cloneStates
(
from
)
{
var
into
=
{
}
;
into
.
_default
=
{
}
;
into
.
preRender
=
Object
.
create
(
into
.
_default
)
;
into
.
destroying
=
Object
.
create
(
into
.
_default
)
;
into
.
hasElement
=
Object
.
create
(
into
.
_default
)
;
into
.
inDOM
=
Object
.
create
(
into
.
hasElement
)
;
for
(
var
stateName
in
from
)
{
if
(
!
from
.
hasOwnProperty
(
stateName
)
)
{
continue
;
}
(
0
_emberUtils
.
assign
)
(
into
[
stateName
]
from
[
stateName
]
)
;
}
return
into
;
}
var
states
=
exports
.
states
=
{
_default
:
_default2
.
default
preRender
:
_pre_render
.
default
inDOM
:
_in_dom
.
default
hasElement
:
_has_element
.
default
destroying
:
_destroying
.
default
}
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
default
'
[
'
exports
'
'
ember
-
debug
'
]
function
(
exports
_emberDebug
)
{
'
use
strict
'
;
exports
.
default
=
{
appendChild
:
function
(
)
{
throw
new
_emberDebug
.
EmberError
(
'
You
can
\
'
t
use
appendChild
outside
of
the
rendering
process
'
)
;
}
handleEvent
:
function
(
)
{
return
true
;
}
rerender
:
function
(
)
{
}
destroy
:
function
(
)
{
}
}
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
destroying
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
debug
'
'
ember
-
views
/
views
/
states
/
default
'
]
function
(
exports
_emberUtils
_emberDebug
_default2
)
{
'
use
strict
'
;
var
destroying
=
Object
.
create
(
_default2
.
default
)
;
(
0
_emberUtils
.
assign
)
(
destroying
{
appendChild
:
function
(
)
{
throw
new
_emberDebug
.
Error
(
'
You
can
\
'
t
call
appendChild
on
a
view
being
destroyed
'
)
;
}
rerender
:
function
(
)
{
throw
new
_emberDebug
.
Error
(
'
You
can
\
'
t
call
rerender
on
a
view
being
destroyed
'
)
;
}
}
)
;
exports
.
default
=
destroying
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
has_element
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
metal
'
]
function
(
exports
_emberUtils
_default2
_emberMetal
)
{
'
use
strict
'
;
var
hasElement
=
Object
.
create
(
_default2
.
default
)
;
(
0
_emberUtils
.
assign
)
(
hasElement
{
rerender
:
function
(
view
)
{
view
.
renderer
.
rerender
(
view
)
;
}
destroy
:
function
(
view
)
{
view
.
renderer
.
remove
(
view
)
;
}
handleEvent
:
function
(
view
eventName
event
)
{
if
(
view
.
has
(
eventName
)
)
{
return
(
0
_emberMetal
.
flaggedInstrument
)
(
'
interaction
.
'
+
eventName
{
event
:
event
view
:
view
}
function
(
)
{
return
_emberMetal
.
run
.
join
(
view
view
.
trigger
eventName
event
)
;
}
)
;
}
else
{
return
true
;
}
}
}
)
;
exports
.
default
=
hasElement
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
in_dom
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
views
/
views
/
states
/
has_element
'
]
function
(
exports
_emberUtils
_emberMetal
_emberDebug
_has_element
)
{
'
use
strict
'
;
var
inDOM
=
Object
.
create
(
_has_element
.
default
)
;
(
0
_emberUtils
.
assign
)
(
inDOM
{
enter
:
function
(
view
)
{
view
.
renderer
.
register
(
view
)
;
if
(
true
)
{
(
0
_emberMetal
.
_addBeforeObserver
)
(
view
'
elementId
'
function
(
)
{
throw
new
_emberDebug
.
Error
(
'
Changing
a
view
\
'
s
elementId
after
creation
is
not
allowed
'
)
;
}
)
;
}
}
exit
:
function
(
view
)
{
view
.
renderer
.
unregister
(
view
)
;
}
}
)
;
exports
.
default
=
inDOM
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
pre_render
'
[
'
exports
'
'
ember
-
views
/
views
/
states
/
default
'
]
function
(
exports
_default2
)
{
'
use
strict
'
;
exports
.
default
=
Object
.
create
(
_default2
.
default
)
;
}
)
;
enifed
(
'
ember
/
features
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
utils
'
]
function
(
exports
_emberEnvironment
_emberUtils
)
{
'
use
strict
'
;
exports
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
=
exports
.
MANDATORY_SETTER
=
exports
.
DESCRIPTOR_TRAP
=
exports
.
GLIMMER_CUSTOM_COMPONENT_MANAGER
=
exports
.
EMBER_MODULE_UNIFICATION
=
exports
.
EMBER_ENGINES_MOUNT_PARAMS
=
exports
.
EMBER_ROUTING_ROUTER_SERVICE
=
exports
.
EMBER_METAL_ES5_GETTERS
=
exports
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
=
exports
.
EMBER_GLIMMER_REMOVE_APPLICATION_TEMPLATE_WRAPPER
=
exports
.
EMBER_GLIMMER_NAMED_ARGUMENTS
=
exports
.
EMBER_IMPROVED_INSTRUMENTATION
=
exports
.
EMBER_LIBRARIES_ISREGISTERED
=
exports
.
FEATURES_STRIPPED_TEST
=
exports
.
FEATURES
=
exports
.
DEFAULT_FEATURES
=
undefined
;
var
DEFAULT_FEATURES
=
exports
.
DEFAULT_FEATURES
=
{
"
features
-
stripped
-
test
"
:
false
"
ember
-
libraries
-
isregistered
"
:
false
"
ember
-
improved
-
instrumentation
"
:
false
"
ember
-
glimmer
-
named
-
arguments
"
:
false
"
ember
-
glimmer
-
remove
-
application
-
template
-
wrapper
"
:
false
"
ember
-
glimmer
-
template
-
only
-
components
"
:
false
"
ember
-
metal
-
es5
-
getters
"
:
false
"
ember
-
routing
-
router
-
service
"
:
true
"
ember
-
engines
-
mount
-
params
"
:
true
"
ember
-
module
-
unification
"
:
false
"
glimmer
-
custom
-
component
-
manager
"
:
false
"
descriptor
-
trap
"
:
true
"
mandatory
-
setter
"
:
true
"
ember
-
glimmer
-
detect
-
backtracking
-
rerender
"
:
true
}
;
var
FEATURES
=
exports
.
FEATURES
=
(
0
_emberUtils
.
assign
)
(
DEFAULT_FEATURES
_emberEnvironment
.
ENV
.
FEATURES
)
;
var
FEATURES_STRIPPED_TEST
=
exports
.
FEATURES_STRIPPED_TEST
=
FEATURES
[
"
features
-
stripped
-
test
"
]
;
var
EMBER_LIBRARIES_ISREGISTERED
=
exports
.
EMBER_LIBRARIES_ISREGISTERED
=
FEATURES
[
"
ember
-
libraries
-
isregistered
"
]
;
var
EMBER_IMPROVED_INSTRUMENTATION
=
exports
.
EMBER_IMPROVED_INSTRUMENTATION
=
FEATURES
[
"
ember
-
improved
-
instrumentation
"
]
;
var
EMBER_GLIMMER_NAMED_ARGUMENTS
=
exports
.
EMBER_GLIMMER_NAMED_ARGUMENTS
=
FEATURES
[
"
ember
-
glimmer
-
named
-
arguments
"
]
;
var
EMBER_GLIMMER_REMOVE_APPLICATION_TEMPLATE_WRAPPER
=
exports
.
EMBER_GLIMMER_REMOVE_APPLICATION_TEMPLATE_WRAPPER
=
FEATURES
[
"
ember
-
glimmer
-
remove
-
application
-
template
-
wrapper
"
]
;
var
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
=
exports
.
EMBER_GLIMMER_TEMPLATE_ONLY_COMPONENTS
=
FEATURES
[
"
ember
-
glimmer
-
template
-
only
-
components
"
]
;
var
EMBER_METAL_ES5_GETTERS
=
exports
.
EMBER_METAL_ES5_GETTERS
=
FEATURES
[
"
ember
-
metal
-
es5
-
getters
"
]
;
var
EMBER_ROUTING_ROUTER_SERVICE
=
exports
.
EMBER_ROUTING_ROUTER_SERVICE
=
FEATURES
[
"
ember
-
routing
-
router
-
service
"
]
;
var
EMBER_ENGINES_MOUNT_PARAMS
=
exports
.
EMBER_ENGINES_MOUNT_PARAMS
=
FEATURES
[
"
ember
-
engines
-
mount
-
params
"
]
;
var
EMBER_MODULE_UNIFICATION
=
exports
.
EMBER_MODULE_UNIFICATION
=
FEATURES
[
"
ember
-
module
-
unification
"
]
;
var
GLIMMER_CUSTOM_COMPONENT_MANAGER
=
exports
.
GLIMMER_CUSTOM_COMPONENT_MANAGER
=
FEATURES
[
"
glimmer
-
custom
-
component
-
manager
"
]
;
var
DESCRIPTOR_TRAP
=
exports
.
DESCRIPTOR_TRAP
=
FEATURES
[
"
descriptor
-
trap
"
]
;
var
MANDATORY_SETTER
=
exports
.
MANDATORY_SETTER
=
FEATURES
[
"
mandatory
-
setter
"
]
;
var
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
=
exports
.
EMBER_GLIMMER_DETECT_BACKTRACKING_RERENDER
=
FEATURES
[
"
ember
-
glimmer
-
detect
-
backtracking
-
rerender
"
]
;
}
)
;
enifed
(
'
ember
/
index
'
[
'
exports
'
'
require
'
'
ember
-
environment
'
'
node
-
module
'
'
ember
-
utils
'
'
container
'
'
ember
-
metal
'
'
ember
/
features
'
'
ember
-
debug
'
'
backburner
'
'
ember
-
console
'
'
ember
-
runtime
'
'
ember
-
glimmer
'
'
ember
/
version
'
'
ember
-
views
'
'
ember
-
routing
'
'
ember
-
application
'
'
ember
-
extension
-
support
'
]
function
(
exports
_require2
_emberEnvironment
_nodeModule
_emberUtils
_container
_emberMetal
_features
_emberDebug
_backburner
_emberConsole
_emberRuntime
_emberGlimmer
_version
_emberViews
_emberRouting
_emberApplication
_emberExtensionSupport
)
{
'
use
strict
'
;
exports
.
VERSION
=
undefined
;
_emberMetal
.
default
.
getOwner
=
_emberUtils
.
getOwner
;
_emberMetal
.
default
.
setOwner
=
_emberUtils
.
setOwner
;
_emberMetal
.
default
.
generateGuid
=
_emberUtils
.
generateGuid
;
_emberMetal
.
default
.
GUID_KEY
=
_emberUtils
.
GUID_KEY
;
_emberMetal
.
default
.
guidFor
=
_emberUtils
.
guidFor
;
_emberMetal
.
default
.
inspect
=
_emberUtils
.
inspect
;
_emberMetal
.
default
.
makeArray
=
_emberUtils
.
makeArray
;
_emberMetal
.
default
.
canInvoke
=
_emberUtils
.
canInvoke
;
_emberMetal
.
default
.
tryInvoke
=
_emberUtils
.
tryInvoke
;
_emberMetal
.
default
.
wrap
=
_emberUtils
.
wrap
;
_emberMetal
.
default
.
applyStr
=
_emberUtils
.
applyStr
;
_emberMetal
.
default
.
uuid
=
_emberUtils
.
uuid
;
_emberMetal
.
default
.
assign
=
_emberUtils
.
assign
;
_emberMetal
.
default
.
Container
=
_container
.
Container
;
_emberMetal
.
default
.
Registry
=
_container
.
Registry
;
var
computed
=
_emberMetal
.
computed
;
computed
.
alias
=
_emberMetal
.
alias
;
_emberMetal
.
default
.
computed
=
computed
;
_emberMetal
.
default
.
ComputedProperty
=
_emberMetal
.
ComputedProperty
;
_emberMetal
.
default
.
cacheFor
=
_emberMetal
.
cacheFor
;
_emberMetal
.
default
.
assert
=
_emberDebug
.
assert
;
_emberMetal
.
default
.
warn
=
_emberDebug
.
warn
;
_emberMetal
.
default
.
debug
=
_emberDebug
.
debug
;
_emberMetal
.
default
.
deprecate
=
_emberDebug
.
deprecate
;
_emberMetal
.
default
.
deprecateFunc
=
_emberDebug
.
deprecateFunc
;
_emberMetal
.
default
.
runInDebug
=
_emberDebug
.
runInDebug
;
_emberMetal
.
default
.
Debug
=
{
registerDeprecationHandler
:
_emberDebug
.
registerDeprecationHandler
registerWarnHandler
:
_emberDebug
.
registerWarnHandler
}
;
_emberMetal
.
default
.
merge
=
_emberMetal
.
merge
;
_emberMetal
.
default
.
instrument
=
_emberMetal
.
instrument
;
_emberMetal
.
default
.
subscribe
=
_emberMetal
.
instrumentationSubscribe
;
_emberMetal
.
default
.
Instrumentation
=
{
instrument
:
_emberMetal
.
instrument
subscribe
:
_emberMetal
.
instrumentationSubscribe
unsubscribe
:
_emberMetal
.
instrumentationUnsubscribe
reset
:
_emberMetal
.
instrumentationReset
}
;
_emberMetal
.
default
.
Error
=
_emberDebug
.
Error
;
_emberMetal
.
default
.
meta
=
_emberMetal
.
meta
;
_emberMetal
.
default
.
get
=
_emberMetal
.
get
;
_emberMetal
.
default
.
getWithDefault
=
_emberMetal
.
getWithDefault
;
_emberMetal
.
default
.
_getPath
=
_emberMetal
.
_getPath
;
_emberMetal
.
default
.
set
=
_emberMetal
.
set
;
_emberMetal
.
default
.
trySet
=
_emberMetal
.
trySet
;
_emberMetal
.
default
.
FEATURES
=
_features
.
FEATURES
;
_emberMetal
.
default
.
FEATURES
.
isEnabled
=
_emberDebug
.
isFeatureEnabled
;
_emberMetal
.
default
.
_Cache
=
_emberMetal
.
Cache
;
_emberMetal
.
default
.
on
=
_emberMetal
.
on
;
_emberMetal
.
default
.
addListener
=
_emberMetal
.
addListener
;
_emberMetal
.
default
.
removeListener
=
_emberMetal
.
removeListener
;
_emberMetal
.
default
.
sendEvent
=
_emberMetal
.
sendEvent
;
_emberMetal
.
default
.
hasListeners
=
_emberMetal
.
hasListeners
;
_emberMetal
.
default
.
isNone
=
_emberMetal
.
isNone
;
_emberMetal
.
default
.
isEmpty
=
_emberMetal
.
isEmpty
;
_emberMetal
.
default
.
isBlank
=
_emberMetal
.
isBlank
;
_emberMetal
.
default
.
isPresent
=
_emberMetal
.
isPresent
;
_emberMetal
.
default
.
run
=
_emberMetal
.
run
;
_emberMetal
.
default
.
_ObserverSet
=
_emberMetal
.
ObserverSet
;
_emberMetal
.
default
.
propertyWillChange
=
_emberMetal
.
propertyWillChange
;
_emberMetal
.
default
.
propertyDidChange
=
_emberMetal
.
propertyDidChange
;
_emberMetal
.
default
.
overrideChains
=
_emberMetal
.
overrideChains
;
_emberMetal
.
default
.
beginPropertyChanges
=
_emberMetal
.
beginPropertyChanges
;
_emberMetal
.
default
.
endPropertyChanges
=
_emberMetal
.
endPropertyChanges
;
_emberMetal
.
default
.
changeProperties
=
_emberMetal
.
changeProperties
;
_emberMetal
.
default
.
platform
=
{
defineProperty
:
true
hasPropertyAccessors
:
true
}
;
_emberMetal
.
default
.
defineProperty
=
_emberMetal
.
defineProperty
;
_emberMetal
.
default
.
watchKey
=
_emberMetal
.
watchKey
;
_emberMetal
.
default
.
unwatchKey
=
_emberMetal
.
unwatchKey
;
_emberMetal
.
default
.
removeChainWatcher
=
_emberMetal
.
removeChainWatcher
;
_emberMetal
.
default
.
_ChainNode
=
_emberMetal
.
ChainNode
;
_emberMetal
.
default
.
finishChains
=
_emberMetal
.
finishChains
;
_emberMetal
.
default
.
watchPath
=
_emberMetal
.
watchPath
;
_emberMetal
.
default
.
unwatchPath
=
_emberMetal
.
unwatchPath
;
_emberMetal
.
default
.
watch
=
_emberMetal
.
watch
;
_emberMetal
.
default
.
isWatching
=
_emberMetal
.
isWatching
;
_emberMetal
.
default
.
unwatch
=
_emberMetal
.
unwatch
;
_emberMetal
.
default
.
destroy
=
_emberMetal
.
deleteMeta
;
_emberMetal
.
default
.
libraries
=
_emberMetal
.
libraries
;
_emberMetal
.
default
.
OrderedSet
=
_emberMetal
.
OrderedSet
;
_emberMetal
.
default
.
Map
=
_emberMetal
.
Map
;
_emberMetal
.
default
.
MapWithDefault
=
_emberMetal
.
MapWithDefault
;
_emberMetal
.
default
.
getProperties
=
_emberMetal
.
getProperties
;
_emberMetal
.
default
.
setProperties
=
_emberMetal
.
setProperties
;
_emberMetal
.
default
.
expandProperties
=
_emberMetal
.
expandProperties
;
_emberMetal
.
default
.
NAME_KEY
=
_emberUtils
.
NAME_KEY
;
_emberMetal
.
default
.
addObserver
=
_emberMetal
.
addObserver
;
_emberMetal
.
default
.
removeObserver
=
_emberMetal
.
removeObserver
;
if
(
_emberEnvironment
.
ENV
.
_ENABLE_PROPERTY_REQUIRED_SUPPORT
)
{
_emberMetal
.
default
.
required
=
_emberMetal
.
required
;
}
_emberMetal
.
default
.
aliasMethod
=
_emberMetal
.
aliasMethod
;
_emberMetal
.
default
.
observer
=
_emberMetal
.
observer
;
_emberMetal
.
default
.
mixin
=
_emberMetal
.
mixin
;
_emberMetal
.
default
.
Mixin
=
_emberMetal
.
Mixin
;
_emberMetal
.
default
.
bind
=
_emberMetal
.
bind
;
_emberMetal
.
default
.
Binding
=
_emberMetal
.
Binding
;
Object
.
defineProperty
(
_emberMetal
.
default
'
ENV
'
{
get
:
function
(
)
{
return
_emberEnvironment
.
ENV
;
}
enumerable
:
false
}
)
;
Object
.
defineProperty
(
_emberMetal
.
default
'
lookup
'
{
get
:
function
(
)
{
return
_emberEnvironment
.
context
.
lookup
;
}
set
:
function
(
value
)
{
_emberEnvironment
.
context
.
lookup
=
value
;
}
enumerable
:
false
}
)
;
_emberMetal
.
default
.
EXTEND_PROTOTYPES
=
_emberEnvironment
.
ENV
.
EXTEND_PROTOTYPES
;
Object
.
defineProperty
(
_emberMetal
.
default
'
LOG_STACKTRACE_ON_DEPRECATION
'
{
get
:
function
(
)
{
return
_emberEnvironment
.
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
;
}
set
:
function
(
value
)
{
_emberEnvironment
.
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
=
!
!
value
;
}
enumerable
:
false
}
)
;
Object
.
defineProperty
(
_emberMetal
.
default
'
LOG_VERSION
'
{
get
:
function
(
)
{
return
_emberEnvironment
.
ENV
.
LOG_VERSION
;
}
set
:
function
(
value
)
{
_emberEnvironment
.
ENV
.
LOG_VERSION
=
!
!
value
;
}
enumerable
:
false
}
)
;
if
(
true
)
{
Object
.
defineProperty
(
_emberMetal
.
default
'
MODEL_FACTORY_INJECTIONS
'
{
get
:
function
(
)
{
return
false
;
}
set
:
function
(
)
{
(
true
&
&
!
(
false
)
&
&
(
0
_emberDebug
.
deprecate
)
(
'
Ember
.
MODEL_FACTORY_INJECTIONS
is
no
longer
required
'
false
{
id
:
'
ember
-
metal
.
model_factory_injections
'
until
:
'
2
.
17
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_id
-
ember
-
metal
-
model_factory_injections
'
}
)
)
;
}
enumerable
:
false
}
)
;
}
Object
.
defineProperty
(
_emberMetal
.
default
'
LOG_BINDINGS
'
{
get
:
function
(
)
{
return
_emberEnvironment
.
ENV
.
LOG_BINDINGS
;
}
set
:
function
(
value
)
{
_emberEnvironment
.
ENV
.
LOG_BINDINGS
=
!
!
value
;
}
enumerable
:
false
}
)
;
Object
.
defineProperty
(
_emberMetal
.
default
'
onerror
'
{
get
:
_emberMetal
.
getOnerror
set
:
_emberMetal
.
setOnerror
enumerable
:
false
}
)
;
Object
.
defineProperty
(
_emberMetal
.
default
'
testing
'
{
get
:
_emberDebug
.
isTesting
set
:
_emberDebug
.
setTesting
enumerable
:
false
}
)
;
_emberMetal
.
default
.
_Backburner
=
_backburner
.
default
;
_emberMetal
.
default
.
Logger
=
_emberConsole
.
default
;
_emberMetal
.
default
.
String
=
_emberRuntime
.
String
;
_emberMetal
.
default
.
Object
=
_emberRuntime
.
Object
;
_emberMetal
.
default
.
_RegistryProxyMixin
=
_emberRuntime
.
RegistryProxyMixin
;
_emberMetal
.
default
.
_ContainerProxyMixin
=
_emberRuntime
.
ContainerProxyMixin
;
_emberMetal
.
default
.
compare
=
_emberRuntime
.
compare
;
_emberMetal
.
default
.
copy
=
_emberRuntime
.
copy
;
_emberMetal
.
default
.
isEqual
=
_emberRuntime
.
isEqual
;
_emberMetal
.
default
.
inject
=
_emberRuntime
.
inject
;
_emberMetal
.
default
.
Array
=
_emberRuntime
.
Array
;
_emberMetal
.
default
.
Comparable
=
_emberRuntime
.
Comparable
;
_emberMetal
.
default
.
Enumerable
=
_emberRuntime
.
Enumerable
;
_emberMetal
.
default
.
ArrayProxy
=
_emberRuntime
.
ArrayProxy
;
_emberMetal
.
default
.
ObjectProxy
=
_emberRuntime
.
ObjectProxy
;
_emberMetal
.
default
.
ActionHandler
=
_emberRuntime
.
ActionHandler
;
_emberMetal
.
default
.
CoreObject
=
_emberRuntime
.
CoreObject
;
_emberMetal
.
default
.
NativeArray
=
_emberRuntime
.
NativeArray
;
_emberMetal
.
default
.
Copyable
=
_emberRuntime
.
Copyable
;
_emberMetal
.
default
.
MutableEnumerable
=
_emberRuntime
.
MutableEnumerable
;
_emberMetal
.
default
.
MutableArray
=
_emberRuntime
.
MutableArray
;
_emberMetal
.
default
.
TargetActionSupport
=
_emberRuntime
.
TargetActionSupport
;
_emberMetal
.
default
.
Evented
=
_emberRuntime
.
Evented
;
_emberMetal
.
default
.
PromiseProxyMixin
=
_emberRuntime
.
PromiseProxyMixin
;
_emberMetal
.
default
.
Observable
=
_emberRuntime
.
Observable
;
_emberMetal
.
default
.
typeOf
=
_emberRuntime
.
typeOf
;
_emberMetal
.
default
.
isArray
=
_emberRuntime
.
isArray
;
_emberMetal
.
default
.
Object
=
_emberRuntime
.
Object
;
_emberMetal
.
default
.
onLoad
=
_emberRuntime
.
onLoad
;
_emberMetal
.
default
.
runLoadHooks
=
_emberRuntime
.
runLoadHooks
;
_emberMetal
.
default
.
Controller
=
_emberRuntime
.
Controller
;
_emberMetal
.
default
.
ControllerMixin
=
_emberRuntime
.
ControllerMixin
;
_emberMetal
.
default
.
Service
=
_emberRuntime
.
Service
;
_emberMetal
.
default
.
_ProxyMixin
=
_emberRuntime
.
_ProxyMixin
;
_emberMetal
.
default
.
RSVP
=
_emberRuntime
.
RSVP
;
_emberMetal
.
default
.
Namespace
=
_emberRuntime
.
Namespace
;
computed
.
empty
=
_emberRuntime
.
empty
;
computed
.
notEmpty
=
_emberRuntime
.
notEmpty
;
computed
.
none
=
_emberRuntime
.
none
;
computed
.
not
=
_emberRuntime
.
not
;
computed
.
bool
=
_emberRuntime
.
bool
;
computed
.
match
=
_emberRuntime
.
match
;
computed
.
equal
=
_emberRuntime
.
equal
;
computed
.
gt
=
_emberRuntime
.
gt
;
computed
.
gte
=
_emberRuntime
.
gte
;
computed
.
lt
=
_emberRuntime
.
lt
;
computed
.
lte
=
_emberRuntime
.
lte
;
computed
.
oneWay
=
_emberRuntime
.
oneWay
;
computed
.
reads
=
_emberRuntime
.
oneWay
;
computed
.
readOnly
=
_emberRuntime
.
readOnly
;
computed
.
deprecatingAlias
=
_emberRuntime
.
deprecatingAlias
;
computed
.
and
=
_emberRuntime
.
and
;
computed
.
or
=
_emberRuntime
.
or
;
computed
.
any
=
_emberRuntime
.
any
;
computed
.
sum
=
_emberRuntime
.
sum
;
computed
.
min
=
_emberRuntime
.
min
;
computed
.
max
=
_emberRuntime
.
max
;
computed
.
map
=
_emberRuntime
.
map
;
computed
.
sort
=
_emberRuntime
.
sort
;
computed
.
setDiff
=
_emberRuntime
.
setDiff
;
computed
.
mapBy
=
_emberRuntime
.
mapBy
;
computed
.
filter
=
_emberRuntime
.
filter
;
computed
.
filterBy
=
_emberRuntime
.
filterBy
;
computed
.
uniq
=
_emberRuntime
.
uniq
;
computed
.
uniqBy
=
_emberRuntime
.
uniqBy
;
computed
.
union
=
_emberRuntime
.
union
;
computed
.
intersect
=
_emberRuntime
.
intersect
;
computed
.
collect
=
_emberRuntime
.
collect
;
Object
.
defineProperty
(
_emberMetal
.
default
'
STRINGS
'
{
configurable
:
false
get
:
_emberRuntime
.
getStrings
set
:
_emberRuntime
.
setStrings
}
)
;
Object
.
defineProperty
(
_emberMetal
.
default
'
BOOTED
'
{
configurable
:
false
enumerable
:
false
get
:
_emberRuntime
.
isNamespaceSearchDisabled
set
:
_emberRuntime
.
setNamespaceSearchDisabled
}
)
;
_emberMetal
.
default
.
Component
=
_emberGlimmer
.
Component
;
_emberGlimmer
.
Helper
.
helper
=
_emberGlimmer
.
helper
;
_emberMetal
.
default
.
Helper
=
_emberGlimmer
.
Helper
;
_emberMetal
.
default
.
Checkbox
=
_emberGlimmer
.
Checkbox
;
_emberMetal
.
default
.
TextField
=
_emberGlimmer
.
TextField
;
_emberMetal
.
default
.
TextArea
=
_emberGlimmer
.
TextArea
;
_emberMetal
.
default
.
LinkComponent
=
_emberGlimmer
.
LinkComponent
;
if
(
_emberEnvironment
.
ENV
.
EXTEND_PROTOTYPES
.
String
)
{
String
.
prototype
.
htmlSafe
=
function
(
)
{
return
(
0
_emberGlimmer
.
htmlSafe
)
(
this
)
;
}
;
}
var
EmberHandlebars
=
_emberMetal
.
default
.
Handlebars
=
_emberMetal
.
default
.
Handlebars
|
|
{
}
;
var
EmberHTMLBars
=
_emberMetal
.
default
.
HTMLBars
=
_emberMetal
.
default
.
HTMLBars
|
|
{
}
;
var
EmberHandleBarsUtils
=
EmberHandlebars
.
Utils
=
EmberHandlebars
.
Utils
|
|
{
}
;
EmberHTMLBars
.
template
=
EmberHandlebars
.
template
=
_emberGlimmer
.
template
;
EmberHandleBarsUtils
.
escapeExpression
=
_emberGlimmer
.
escapeExpression
;
_emberRuntime
.
String
.
htmlSafe
=
_emberGlimmer
.
htmlSafe
;
_emberRuntime
.
String
.
isHTMLSafe
=
_emberGlimmer
.
isHTMLSafe
;
Object
.
defineProperty
(
_emberMetal
.
default
'
TEMPLATES
'
{
get
:
_emberGlimmer
.
getTemplates
set
:
_emberGlimmer
.
setTemplates
configurable
:
false
enumerable
:
false
}
)
;
exports
.
VERSION
=
_version
.
default
;
_emberMetal
.
default
.
VERSION
=
_version
.
default
;
_emberMetal
.
libraries
.
registerCoreLibrary
(
'
Ember
'
_version
.
default
)
;
_emberMetal
.
default
.
=
_emberViews
.
jQuery
;
_emberMetal
.
default
.
ViewTargetActionSupport
=
_emberViews
.
ViewTargetActionSupport
;
_emberMetal
.
default
.
ViewUtils
=
{
isSimpleClick
:
_emberViews
.
isSimpleClick
getViewElement
:
_emberViews
.
getViewElement
getViewBounds
:
_emberViews
.
getViewBounds
getViewClientRects
:
_emberViews
.
getViewClientRects
getViewBoundingClientRect
:
_emberViews
.
getViewBoundingClientRect
getRootViews
:
_emberViews
.
getRootViews
getChildViews
:
_emberViews
.
getChildViews
}
;
_emberMetal
.
default
.
TextSupport
=
_emberViews
.
TextSupport
;
_emberMetal
.
default
.
ComponentLookup
=
_emberViews
.
ComponentLookup
;
_emberMetal
.
default
.
EventDispatcher
=
_emberViews
.
EventDispatcher
;
_emberMetal
.
default
.
Location
=
_emberRouting
.
Location
;
_emberMetal
.
default
.
AutoLocation
=
_emberRouting
.
AutoLocation
;
_emberMetal
.
default
.
HashLocation
=
_emberRouting
.
HashLocation
;
_emberMetal
.
default
.
HistoryLocation
=
_emberRouting
.
HistoryLocation
;
_emberMetal
.
default
.
NoneLocation
=
_emberRouting
.
NoneLocation
;
_emberMetal
.
default
.
controllerFor
=
_emberRouting
.
controllerFor
;
_emberMetal
.
default
.
generateControllerFactory
=
_emberRouting
.
generateControllerFactory
;
_emberMetal
.
default
.
generateController
=
_emberRouting
.
generateController
;
_emberMetal
.
default
.
RouterDSL
=
_emberRouting
.
RouterDSL
;
_emberMetal
.
default
.
Router
=
_emberRouting
.
Router
;
_emberMetal
.
default
.
Route
=
_emberRouting
.
Route
;
_emberMetal
.
default
.
Application
=
_emberApplication
.
Application
;
_emberMetal
.
default
.
ApplicationInstance
=
_emberApplication
.
ApplicationInstance
;
_emberMetal
.
default
.
Engine
=
_emberApplication
.
Engine
;
_emberMetal
.
default
.
EngineInstance
=
_emberApplication
.
EngineInstance
;
_emberMetal
.
default
.
DefaultResolver
=
_emberMetal
.
default
.
Resolver
=
_emberApplication
.
Resolver
;
(
0
_emberRuntime
.
runLoadHooks
)
(
'
Ember
.
Application
'
_emberApplication
.
Application
)
;
_emberMetal
.
default
.
DataAdapter
=
_emberExtensionSupport
.
DataAdapter
;
_emberMetal
.
default
.
ContainerDebugAdapter
=
_emberExtensionSupport
.
ContainerDebugAdapter
;
if
(
(
0
_require2
.
has
)
(
'
ember
-
template
-
compiler
'
)
)
{
(
0
_require2
.
default
)
(
'
ember
-
template
-
compiler
'
)
;
}
if
(
(
0
_require2
.
has
)
(
'
ember
-
testing
'
)
)
{
var
testing
=
(
0
_require2
.
default
)
(
'
ember
-
testing
'
)
;
_emberMetal
.
default
.
Test
=
testing
.
Test
;
_emberMetal
.
default
.
Test
.
Adapter
=
testing
.
Adapter
;
_emberMetal
.
default
.
Test
.
QUnitAdapter
=
testing
.
QUnitAdapter
;
_emberMetal
.
default
.
setupForTesting
=
testing
.
setupForTesting
;
}
(
0
_emberRuntime
.
runLoadHooks
)
(
'
Ember
'
)
;
exports
.
default
=
_emberMetal
.
default
;
if
(
_nodeModule
.
IS_NODE
)
{
_nodeModule
.
module
.
exports
=
_emberMetal
.
default
;
}
else
{
_emberEnvironment
.
context
.
exports
.
Ember
=
_emberEnvironment
.
context
.
exports
.
Em
=
_emberMetal
.
default
;
}
}
)
;
enifed
(
"
ember
/
version
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
"
3
.
0
.
0
"
;
}
)
;
enifed
(
"
handlebars
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
handlebars
=
function
(
)
{
var
parser
=
{
trace
:
function
trace
(
)
{
}
yy
:
{
}
symbols_
:
{
"
error
"
:
2
"
root
"
:
3
"
program
"
:
4
"
EOF
"
:
5
"
program_repetition0
"
:
6
"
statement
"
:
7
"
mustache
"
:
8
"
block
"
:
9
"
rawBlock
"
:
10
"
partial
"
:
11
"
partialBlock
"
:
12
"
content
"
:
13
"
COMMENT
"
:
14
"
CONTENT
"
:
15
"
openRawBlock
"
:
16
"
rawBlock_repetition_plus0
"
:
17
"
END_RAW_BLOCK
"
:
18
"
OPEN_RAW_BLOCK
"
:
19
"
helperName
"
:
20
"
openRawBlock_repetition0
"
:
21
"
openRawBlock_option0
"
:
22
"
CLOSE_RAW_BLOCK
"
:
23
"
openBlock
"
:
24
"
block_option0
"
:
25
"
closeBlock
"
:
26
"
openInverse
"
:
27
"
block_option1
"
:
28
"
OPEN_BLOCK
"
:
29
"
openBlock_repetition0
"
:
30
"
openBlock_option0
"
:
31
"
openBlock_option1
"
:
32
"
CLOSE
"
:
33
"
OPEN_INVERSE
"
:
34
"
openInverse_repetition0
"
:
35
"
openInverse_option0
"
:
36
"
openInverse_option1
"
:
37
"
openInverseChain
"
:
38
"
OPEN_INVERSE_CHAIN
"
:
39
"
openInverseChain_repetition0
"
:
40
"
openInverseChain_option0
"
:
41
"
openInverseChain_option1
"
:
42
"
inverseAndProgram
"
:
43
"
INVERSE
"
:
44
"
inverseChain
"
:
45
"
inverseChain_option0
"
:
46
"
OPEN_ENDBLOCK
"
:
47
"
OPEN
"
:
48
"
mustache_repetition0
"
:
49
"
mustache_option0
"
:
50
"
OPEN_UNESCAPED
"
:
51
"
mustache_repetition1
"
:
52
"
mustache_option1
"
:
53
"
CLOSE_UNESCAPED
"
:
54
"
OPEN_PARTIAL
"
:
55
"
partialName
"
:
56
"
partial_repetition0
"
:
57
"
partial_option0
"
:
58
"
openPartialBlock
"
:
59
"
OPEN_PARTIAL_BLOCK
"
:
60
"
openPartialBlock_repetition0
"
:
61
"
openPartialBlock_option0
"
:
62
"
param
"
:
63
"
sexpr
"
:
64
"
OPEN_SEXPR
"
:
65
"
sexpr_repetition0
"
:
66
"
sexpr_option0
"
:
67
"
CLOSE_SEXPR
"
:
68
"
hash
"
:
69
"
hash_repetition_plus0
"
:
70
"
hashSegment
"
:
71
"
ID
"
:
72
"
EQUALS
"
:
73
"
blockParams
"
:
74
"
OPEN_BLOCK_PARAMS
"
:
75
"
blockParams_repetition_plus0
"
:
76
"
CLOSE_BLOCK_PARAMS
"
:
77
"
path
"
:
78
"
dataName
"
:
79
"
STRING
"
:
80
"
NUMBER
"
:
81
"
BOOLEAN
"
:
82
"
UNDEFINED
"
:
83
"
NULL
"
:
84
"
DATA
"
:
85
"
pathSegments
"
:
86
"
SEP
"
:
87
"
accept
"
:
0
"
end
"
:
1
}
terminals_
:
{
2
:
"
error
"
5
:
"
EOF
"
14
:
"
COMMENT
"
15
:
"
CONTENT
"
18
:
"
END_RAW_BLOCK
"
19
:
"
OPEN_RAW_BLOCK
"
23
:
"
CLOSE_RAW_BLOCK
"
29
:
"
OPEN_BLOCK
"
33
:
"
CLOSE
"
34
:
"
OPEN_INVERSE
"
39
:
"
OPEN_INVERSE_CHAIN
"
44
:
"
INVERSE
"
47
:
"
OPEN_ENDBLOCK
"
48
:
"
OPEN
"
51
:
"
OPEN_UNESCAPED
"
54
:
"
CLOSE_UNESCAPED
"
55
:
"
OPEN_PARTIAL
"
60
:
"
OPEN_PARTIAL_BLOCK
"
65
:
"
OPEN_SEXPR
"
68
:
"
CLOSE_SEXPR
"
72
:
"
ID
"
73
:
"
EQUALS
"
75
:
"
OPEN_BLOCK_PARAMS
"
77
:
"
CLOSE_BLOCK_PARAMS
"
80
:
"
STRING
"
81
:
"
NUMBER
"
82
:
"
BOOLEAN
"
83
:
"
UNDEFINED
"
84
:
"
NULL
"
85
:
"
DATA
"
87
:
"
SEP
"
}
productions_
:
[
0
[
3
2
]
[
4
1
]
[
7
1
]
[
7
1
]
[
7
1
]
[
7
1
]
[
7
1
]
[
7
1
]
[
7
1
]
[
13
1
]
[
10
3
]
[
16
5
]
[
9
4
]
[
9
4
]
[
24
6
]
[
27
6
]
[
38
6
]
[
43
2
]
[
45
3
]
[
45
1
]
[
26
3
]
[
8
5
]
[
8
5
]
[
11
5
]
[
12
3
]
[
59
5
]
[
63
1
]
[
63
1
]
[
64
5
]
[
69
1
]
[
71
3
]
[
74
3
]
[
20
1
]
[
20
1
]
[
20
1
]
[
20
1
]
[
20
1
]
[
20
1
]
[
20
1
]
[
56
1
]
[
56
1
]
[
79
2
]
[
78
1
]
[
86
3
]
[
86
1
]
[
6
0
]
[
6
2
]
[
17
1
]
[
17
2
]
[
21
0
]
[
21
2
]
[
22
0
]
[
22
1
]
[
25
0
]
[
25
1
]
[
28
0
]
[
28
1
]
[
30
0
]
[
30
2
]
[
31
0
]
[
31
1
]
[
32
0
]
[
32
1
]
[
35
0
]
[
35
2
]
[
36
0
]
[
36
1
]
[
37
0
]
[
37
1
]
[
40
0
]
[
40
2
]
[
41
0
]
[
41
1
]
[
42
0
]
[
42
1
]
[
46
0
]
[
46
1
]
[
49
0
]
[
49
2
]
[
50
0
]
[
50
1
]
[
52
0
]
[
52
2
]
[
53
0
]
[
53
1
]
[
57
0
]
[
57
2
]
[
58
0
]
[
58
1
]
[
61
0
]
[
61
2
]
[
62
0
]
[
62
1
]
[
66
0
]
[
66
2
]
[
67
0
]
[
67
1
]
[
70
1
]
[
70
2
]
[
76
1
]
[
76
2
]
]
performAction
:
function
anonymous
(
yytext
yyleng
yylineno
yy
yystate
_
)
{
var
0
=
.
length
-
1
;
switch
(
yystate
)
{
case
1
:
return
[
0
-
1
]
;
break
;
case
2
:
this
.
=
yy
.
prepareProgram
(
[
0
]
)
;
break
;
case
3
:
this
.
=
[
0
]
;
break
;
case
4
:
this
.
=
[
0
]
;
break
;
case
5
:
this
.
=
[
0
]
;
break
;
case
6
:
this
.
=
[
0
]
;
break
;
case
7
:
this
.
=
[
0
]
;
break
;
case
8
:
this
.
=
[
0
]
;
break
;
case
9
:
this
.
=
{
type
:
'
CommentStatement
'
value
:
yy
.
stripComment
(
[
0
]
)
strip
:
yy
.
stripFlags
(
[
0
]
[
0
]
)
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
10
:
this
.
=
{
type
:
'
ContentStatement
'
original
:
[
0
]
value
:
[
0
]
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
11
:
this
.
=
yy
.
prepareRawBlock
(
[
0
-
2
]
[
0
-
1
]
[
0
]
this
.
_
)
;
break
;
case
12
:
this
.
=
{
path
:
[
0
-
3
]
params
:
[
0
-
2
]
hash
:
[
0
-
1
]
}
;
break
;
case
13
:
this
.
=
yy
.
prepareBlock
(
[
0
-
3
]
[
0
-
2
]
[
0
-
1
]
[
0
]
false
this
.
_
)
;
break
;
case
14
:
this
.
=
yy
.
prepareBlock
(
[
0
-
3
]
[
0
-
2
]
[
0
-
1
]
[
0
]
true
this
.
_
)
;
break
;
case
15
:
this
.
=
{
open
:
[
0
-
5
]
path
:
[
0
-
4
]
params
:
[
0
-
3
]
hash
:
[
0
-
2
]
blockParams
:
[
0
-
1
]
strip
:
yy
.
stripFlags
(
[
0
-
5
]
[
0
]
)
}
;
break
;
case
16
:
this
.
=
{
path
:
[
0
-
4
]
params
:
[
0
-
3
]
hash
:
[
0
-
2
]
blockParams
:
[
0
-
1
]
strip
:
yy
.
stripFlags
(
[
0
-
5
]
[
0
]
)
}
;
break
;
case
17
:
this
.
=
{
path
:
[
0
-
4
]
params
:
[
0
-
3
]
hash
:
[
0
-
2
]
blockParams
:
[
0
-
1
]
strip
:
yy
.
stripFlags
(
[
0
-
5
]
[
0
]
)
}
;
break
;
case
18
:
this
.
=
{
strip
:
yy
.
stripFlags
(
[
0
-
1
]
[
0
-
1
]
)
program
:
[
0
]
}
;
break
;
case
19
:
var
inverse
=
yy
.
prepareBlock
(
[
0
-
2
]
[
0
-
1
]
[
0
]
[
0
]
false
this
.
_
)
program
=
yy
.
prepareProgram
(
[
inverse
]
[
0
-
1
]
.
loc
)
;
program
.
chained
=
true
;
this
.
=
{
strip
:
[
0
-
2
]
.
strip
program
:
program
chain
:
true
}
;
break
;
case
20
:
this
.
=
[
0
]
;
break
;
case
21
:
this
.
=
{
path
:
[
0
-
1
]
strip
:
yy
.
stripFlags
(
[
0
-
2
]
[
0
]
)
}
;
break
;
case
22
:
this
.
=
yy
.
prepareMustache
(
[
0
-
3
]
[
0
-
2
]
[
0
-
1
]
[
0
-
4
]
yy
.
stripFlags
(
[
0
-
4
]
[
0
]
)
this
.
_
)
;
break
;
case
23
:
this
.
=
yy
.
prepareMustache
(
[
0
-
3
]
[
0
-
2
]
[
0
-
1
]
[
0
-
4
]
yy
.
stripFlags
(
[
0
-
4
]
[
0
]
)
this
.
_
)
;
break
;
case
24
:
this
.
=
{
type
:
'
PartialStatement
'
name
:
[
0
-
3
]
params
:
[
0
-
2
]
hash
:
[
0
-
1
]
indent
:
'
'
strip
:
yy
.
stripFlags
(
[
0
-
4
]
[
0
]
)
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
25
:
this
.
=
yy
.
preparePartialBlock
(
[
0
-
2
]
[
0
-
1
]
[
0
]
this
.
_
)
;
break
;
case
26
:
this
.
=
{
path
:
[
0
-
3
]
params
:
[
0
-
2
]
hash
:
[
0
-
1
]
strip
:
yy
.
stripFlags
(
[
0
-
4
]
[
0
]
)
}
;
break
;
case
27
:
this
.
=
[
0
]
;
break
;
case
28
:
this
.
=
[
0
]
;
break
;
case
29
:
this
.
=
{
type
:
'
SubExpression
'
path
:
[
0
-
3
]
params
:
[
0
-
2
]
hash
:
[
0
-
1
]
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
30
:
this
.
=
{
type
:
'
Hash
'
pairs
:
[
0
]
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
31
:
this
.
=
{
type
:
'
HashPair
'
key
:
yy
.
id
(
[
0
-
2
]
)
value
:
[
0
]
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
32
:
this
.
=
yy
.
id
(
[
0
-
1
]
)
;
break
;
case
33
:
this
.
=
[
0
]
;
break
;
case
34
:
this
.
=
[
0
]
;
break
;
case
35
:
this
.
=
{
type
:
'
StringLiteral
'
value
:
[
0
]
original
:
[
0
]
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
36
:
this
.
=
{
type
:
'
NumberLiteral
'
value
:
Number
(
[
0
]
)
original
:
Number
(
[
0
]
)
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
37
:
this
.
=
{
type
:
'
BooleanLiteral
'
value
:
[
0
]
=
=
=
'
true
'
original
:
[
0
]
=
=
=
'
true
'
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
38
:
this
.
=
{
type
:
'
UndefinedLiteral
'
original
:
undefined
value
:
undefined
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
39
:
this
.
=
{
type
:
'
NullLiteral
'
original
:
null
value
:
null
loc
:
yy
.
locInfo
(
this
.
_
)
}
;
break
;
case
40
:
this
.
=
[
0
]
;
break
;
case
41
:
this
.
=
[
0
]
;
break
;
case
42
:
this
.
=
yy
.
preparePath
(
true
[
0
]
this
.
_
)
;
break
;
case
43
:
this
.
=
yy
.
preparePath
(
false
[
0
]
this
.
_
)
;
break
;
case
44
:
[
0
-
2
]
.
push
(
{
part
:
yy
.
id
(
[
0
]
)
original
:
[
0
]
separator
:
[
0
-
1
]
}
)
;
this
.
=
[
0
-
2
]
;
break
;
case
45
:
this
.
=
[
{
part
:
yy
.
id
(
[
0
]
)
original
:
[
0
]
}
]
;
break
;
case
46
:
this
.
=
[
]
;
break
;
case
47
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
48
:
this
.
=
[
[
0
]
]
;
break
;
case
49
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
50
:
this
.
=
[
]
;
break
;
case
51
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
58
:
this
.
=
[
]
;
break
;
case
59
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
64
:
this
.
=
[
]
;
break
;
case
65
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
70
:
this
.
=
[
]
;
break
;
case
71
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
78
:
this
.
=
[
]
;
break
;
case
79
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
82
:
this
.
=
[
]
;
break
;
case
83
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
86
:
this
.
=
[
]
;
break
;
case
87
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
90
:
this
.
=
[
]
;
break
;
case
91
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
94
:
this
.
=
[
]
;
break
;
case
95
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
98
:
this
.
=
[
[
0
]
]
;
break
;
case
99
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
case
100
:
this
.
=
[
[
0
]
]
;
break
;
case
101
:
[
0
-
1
]
.
push
(
[
0
]
)
;
break
;
}
}
table
:
[
{
3
:
1
4
:
2
5
:
[
2
46
]
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
1
:
[
3
]
}
{
5
:
[
1
4
]
}
{
5
:
[
2
2
]
7
:
5
8
:
6
9
:
7
10
:
8
11
:
9
12
:
10
13
:
11
14
:
[
1
12
]
15
:
[
1
20
]
16
:
17
19
:
[
1
23
]
24
:
15
27
:
16
29
:
[
1
21
]
34
:
[
1
22
]
39
:
[
2
2
]
44
:
[
2
2
]
47
:
[
2
2
]
48
:
[
1
13
]
51
:
[
1
14
]
55
:
[
1
18
]
59
:
19
60
:
[
1
24
]
}
{
1
:
[
2
1
]
}
{
5
:
[
2
47
]
14
:
[
2
47
]
15
:
[
2
47
]
19
:
[
2
47
]
29
:
[
2
47
]
34
:
[
2
47
]
39
:
[
2
47
]
44
:
[
2
47
]
47
:
[
2
47
]
48
:
[
2
47
]
51
:
[
2
47
]
55
:
[
2
47
]
60
:
[
2
47
]
}
{
5
:
[
2
3
]
14
:
[
2
3
]
15
:
[
2
3
]
19
:
[
2
3
]
29
:
[
2
3
]
34
:
[
2
3
]
39
:
[
2
3
]
44
:
[
2
3
]
47
:
[
2
3
]
48
:
[
2
3
]
51
:
[
2
3
]
55
:
[
2
3
]
60
:
[
2
3
]
}
{
5
:
[
2
4
]
14
:
[
2
4
]
15
:
[
2
4
]
19
:
[
2
4
]
29
:
[
2
4
]
34
:
[
2
4
]
39
:
[
2
4
]
44
:
[
2
4
]
47
:
[
2
4
]
48
:
[
2
4
]
51
:
[
2
4
]
55
:
[
2
4
]
60
:
[
2
4
]
}
{
5
:
[
2
5
]
14
:
[
2
5
]
15
:
[
2
5
]
19
:
[
2
5
]
29
:
[
2
5
]
34
:
[
2
5
]
39
:
[
2
5
]
44
:
[
2
5
]
47
:
[
2
5
]
48
:
[
2
5
]
51
:
[
2
5
]
55
:
[
2
5
]
60
:
[
2
5
]
}
{
5
:
[
2
6
]
14
:
[
2
6
]
15
:
[
2
6
]
19
:
[
2
6
]
29
:
[
2
6
]
34
:
[
2
6
]
39
:
[
2
6
]
44
:
[
2
6
]
47
:
[
2
6
]
48
:
[
2
6
]
51
:
[
2
6
]
55
:
[
2
6
]
60
:
[
2
6
]
}
{
5
:
[
2
7
]
14
:
[
2
7
]
15
:
[
2
7
]
19
:
[
2
7
]
29
:
[
2
7
]
34
:
[
2
7
]
39
:
[
2
7
]
44
:
[
2
7
]
47
:
[
2
7
]
48
:
[
2
7
]
51
:
[
2
7
]
55
:
[
2
7
]
60
:
[
2
7
]
}
{
5
:
[
2
8
]
14
:
[
2
8
]
15
:
[
2
8
]
19
:
[
2
8
]
29
:
[
2
8
]
34
:
[
2
8
]
39
:
[
2
8
]
44
:
[
2
8
]
47
:
[
2
8
]
48
:
[
2
8
]
51
:
[
2
8
]
55
:
[
2
8
]
60
:
[
2
8
]
}
{
5
:
[
2
9
]
14
:
[
2
9
]
15
:
[
2
9
]
19
:
[
2
9
]
29
:
[
2
9
]
34
:
[
2
9
]
39
:
[
2
9
]
44
:
[
2
9
]
47
:
[
2
9
]
48
:
[
2
9
]
51
:
[
2
9
]
55
:
[
2
9
]
60
:
[
2
9
]
}
{
20
:
25
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
36
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
4
:
37
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
39
:
[
2
46
]
44
:
[
2
46
]
47
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
4
:
38
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
44
:
[
2
46
]
47
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
13
:
40
15
:
[
1
20
]
17
:
39
}
{
20
:
42
56
:
41
64
:
43
65
:
[
1
44
]
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
4
:
45
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
47
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
5
:
[
2
10
]
14
:
[
2
10
]
15
:
[
2
10
]
18
:
[
2
10
]
19
:
[
2
10
]
29
:
[
2
10
]
34
:
[
2
10
]
39
:
[
2
10
]
44
:
[
2
10
]
47
:
[
2
10
]
48
:
[
2
10
]
51
:
[
2
10
]
55
:
[
2
10
]
60
:
[
2
10
]
}
{
20
:
46
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
47
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
48
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
42
56
:
49
64
:
43
65
:
[
1
44
]
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
33
:
[
2
78
]
49
:
50
65
:
[
2
78
]
72
:
[
2
78
]
80
:
[
2
78
]
81
:
[
2
78
]
82
:
[
2
78
]
83
:
[
2
78
]
84
:
[
2
78
]
85
:
[
2
78
]
}
{
23
:
[
2
33
]
33
:
[
2
33
]
54
:
[
2
33
]
65
:
[
2
33
]
68
:
[
2
33
]
72
:
[
2
33
]
75
:
[
2
33
]
80
:
[
2
33
]
81
:
[
2
33
]
82
:
[
2
33
]
83
:
[
2
33
]
84
:
[
2
33
]
85
:
[
2
33
]
}
{
23
:
[
2
34
]
33
:
[
2
34
]
54
:
[
2
34
]
65
:
[
2
34
]
68
:
[
2
34
]
72
:
[
2
34
]
75
:
[
2
34
]
80
:
[
2
34
]
81
:
[
2
34
]
82
:
[
2
34
]
83
:
[
2
34
]
84
:
[
2
34
]
85
:
[
2
34
]
}
{
23
:
[
2
35
]
33
:
[
2
35
]
54
:
[
2
35
]
65
:
[
2
35
]
68
:
[
2
35
]
72
:
[
2
35
]
75
:
[
2
35
]
80
:
[
2
35
]
81
:
[
2
35
]
82
:
[
2
35
]
83
:
[
2
35
]
84
:
[
2
35
]
85
:
[
2
35
]
}
{
23
:
[
2
36
]
33
:
[
2
36
]
54
:
[
2
36
]
65
:
[
2
36
]
68
:
[
2
36
]
72
:
[
2
36
]
75
:
[
2
36
]
80
:
[
2
36
]
81
:
[
2
36
]
82
:
[
2
36
]
83
:
[
2
36
]
84
:
[
2
36
]
85
:
[
2
36
]
}
{
23
:
[
2
37
]
33
:
[
2
37
]
54
:
[
2
37
]
65
:
[
2
37
]
68
:
[
2
37
]
72
:
[
2
37
]
75
:
[
2
37
]
80
:
[
2
37
]
81
:
[
2
37
]
82
:
[
2
37
]
83
:
[
2
37
]
84
:
[
2
37
]
85
:
[
2
37
]
}
{
23
:
[
2
38
]
33
:
[
2
38
]
54
:
[
2
38
]
65
:
[
2
38
]
68
:
[
2
38
]
72
:
[
2
38
]
75
:
[
2
38
]
80
:
[
2
38
]
81
:
[
2
38
]
82
:
[
2
38
]
83
:
[
2
38
]
84
:
[
2
38
]
85
:
[
2
38
]
}
{
23
:
[
2
39
]
33
:
[
2
39
]
54
:
[
2
39
]
65
:
[
2
39
]
68
:
[
2
39
]
72
:
[
2
39
]
75
:
[
2
39
]
80
:
[
2
39
]
81
:
[
2
39
]
82
:
[
2
39
]
83
:
[
2
39
]
84
:
[
2
39
]
85
:
[
2
39
]
}
{
23
:
[
2
43
]
33
:
[
2
43
]
54
:
[
2
43
]
65
:
[
2
43
]
68
:
[
2
43
]
72
:
[
2
43
]
75
:
[
2
43
]
80
:
[
2
43
]
81
:
[
2
43
]
82
:
[
2
43
]
83
:
[
2
43
]
84
:
[
2
43
]
85
:
[
2
43
]
87
:
[
1
51
]
}
{
72
:
[
1
35
]
86
:
52
}
{
23
:
[
2
45
]
33
:
[
2
45
]
54
:
[
2
45
]
65
:
[
2
45
]
68
:
[
2
45
]
72
:
[
2
45
]
75
:
[
2
45
]
80
:
[
2
45
]
81
:
[
2
45
]
82
:
[
2
45
]
83
:
[
2
45
]
84
:
[
2
45
]
85
:
[
2
45
]
87
:
[
2
45
]
}
{
52
:
53
54
:
[
2
82
]
65
:
[
2
82
]
72
:
[
2
82
]
80
:
[
2
82
]
81
:
[
2
82
]
82
:
[
2
82
]
83
:
[
2
82
]
84
:
[
2
82
]
85
:
[
2
82
]
}
{
25
:
54
38
:
56
39
:
[
1
58
]
43
:
57
44
:
[
1
59
]
45
:
55
47
:
[
2
54
]
}
{
28
:
60
43
:
61
44
:
[
1
59
]
47
:
[
2
56
]
}
{
13
:
63
15
:
[
1
20
]
18
:
[
1
62
]
}
{
15
:
[
2
48
]
18
:
[
2
48
]
}
{
33
:
[
2
86
]
57
:
64
65
:
[
2
86
]
72
:
[
2
86
]
80
:
[
2
86
]
81
:
[
2
86
]
82
:
[
2
86
]
83
:
[
2
86
]
84
:
[
2
86
]
85
:
[
2
86
]
}
{
33
:
[
2
40
]
65
:
[
2
40
]
72
:
[
2
40
]
80
:
[
2
40
]
81
:
[
2
40
]
82
:
[
2
40
]
83
:
[
2
40
]
84
:
[
2
40
]
85
:
[
2
40
]
}
{
33
:
[
2
41
]
65
:
[
2
41
]
72
:
[
2
41
]
80
:
[
2
41
]
81
:
[
2
41
]
82
:
[
2
41
]
83
:
[
2
41
]
84
:
[
2
41
]
85
:
[
2
41
]
}
{
20
:
65
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
26
:
66
47
:
[
1
67
]
}
{
30
:
68
33
:
[
2
58
]
65
:
[
2
58
]
72
:
[
2
58
]
75
:
[
2
58
]
80
:
[
2
58
]
81
:
[
2
58
]
82
:
[
2
58
]
83
:
[
2
58
]
84
:
[
2
58
]
85
:
[
2
58
]
}
{
33
:
[
2
64
]
35
:
69
65
:
[
2
64
]
72
:
[
2
64
]
75
:
[
2
64
]
80
:
[
2
64
]
81
:
[
2
64
]
82
:
[
2
64
]
83
:
[
2
64
]
84
:
[
2
64
]
85
:
[
2
64
]
}
{
21
:
70
23
:
[
2
50
]
65
:
[
2
50
]
72
:
[
2
50
]
80
:
[
2
50
]
81
:
[
2
50
]
82
:
[
2
50
]
83
:
[
2
50
]
84
:
[
2
50
]
85
:
[
2
50
]
}
{
33
:
[
2
90
]
61
:
71
65
:
[
2
90
]
72
:
[
2
90
]
80
:
[
2
90
]
81
:
[
2
90
]
82
:
[
2
90
]
83
:
[
2
90
]
84
:
[
2
90
]
85
:
[
2
90
]
}
{
20
:
75
33
:
[
2
80
]
50
:
72
63
:
73
64
:
76
65
:
[
1
44
]
69
:
74
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
72
:
[
1
80
]
}
{
23
:
[
2
42
]
33
:
[
2
42
]
54
:
[
2
42
]
65
:
[
2
42
]
68
:
[
2
42
]
72
:
[
2
42
]
75
:
[
2
42
]
80
:
[
2
42
]
81
:
[
2
42
]
82
:
[
2
42
]
83
:
[
2
42
]
84
:
[
2
42
]
85
:
[
2
42
]
87
:
[
1
51
]
}
{
20
:
75
53
:
81
54
:
[
2
84
]
63
:
82
64
:
76
65
:
[
1
44
]
69
:
83
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
26
:
84
47
:
[
1
67
]
}
{
47
:
[
2
55
]
}
{
4
:
85
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
39
:
[
2
46
]
44
:
[
2
46
]
47
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
47
:
[
2
20
]
}
{
20
:
86
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
4
:
87
6
:
3
14
:
[
2
46
]
15
:
[
2
46
]
19
:
[
2
46
]
29
:
[
2
46
]
34
:
[
2
46
]
47
:
[
2
46
]
48
:
[
2
46
]
51
:
[
2
46
]
55
:
[
2
46
]
60
:
[
2
46
]
}
{
26
:
88
47
:
[
1
67
]
}
{
47
:
[
2
57
]
}
{
5
:
[
2
11
]
14
:
[
2
11
]
15
:
[
2
11
]
19
:
[
2
11
]
29
:
[
2
11
]
34
:
[
2
11
]
39
:
[
2
11
]
44
:
[
2
11
]
47
:
[
2
11
]
48
:
[
2
11
]
51
:
[
2
11
]
55
:
[
2
11
]
60
:
[
2
11
]
}
{
15
:
[
2
49
]
18
:
[
2
49
]
}
{
20
:
75
33
:
[
2
88
]
58
:
89
63
:
90
64
:
76
65
:
[
1
44
]
69
:
91
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
65
:
[
2
94
]
66
:
92
68
:
[
2
94
]
72
:
[
2
94
]
80
:
[
2
94
]
81
:
[
2
94
]
82
:
[
2
94
]
83
:
[
2
94
]
84
:
[
2
94
]
85
:
[
2
94
]
}
{
5
:
[
2
25
]
14
:
[
2
25
]
15
:
[
2
25
]
19
:
[
2
25
]
29
:
[
2
25
]
34
:
[
2
25
]
39
:
[
2
25
]
44
:
[
2
25
]
47
:
[
2
25
]
48
:
[
2
25
]
51
:
[
2
25
]
55
:
[
2
25
]
60
:
[
2
25
]
}
{
20
:
93
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
75
31
:
94
33
:
[
2
60
]
63
:
95
64
:
76
65
:
[
1
44
]
69
:
96
70
:
77
71
:
78
72
:
[
1
79
]
75
:
[
2
60
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
75
33
:
[
2
66
]
36
:
97
63
:
98
64
:
76
65
:
[
1
44
]
69
:
99
70
:
77
71
:
78
72
:
[
1
79
]
75
:
[
2
66
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
75
22
:
100
23
:
[
2
52
]
63
:
101
64
:
76
65
:
[
1
44
]
69
:
102
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
20
:
75
33
:
[
2
92
]
62
:
103
63
:
104
64
:
76
65
:
[
1
44
]
69
:
105
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
33
:
[
1
106
]
}
{
33
:
[
2
79
]
65
:
[
2
79
]
72
:
[
2
79
]
80
:
[
2
79
]
81
:
[
2
79
]
82
:
[
2
79
]
83
:
[
2
79
]
84
:
[
2
79
]
85
:
[
2
79
]
}
{
33
:
[
2
81
]
}
{
23
:
[
2
27
]
33
:
[
2
27
]
54
:
[
2
27
]
65
:
[
2
27
]
68
:
[
2
27
]
72
:
[
2
27
]
75
:
[
2
27
]
80
:
[
2
27
]
81
:
[
2
27
]
82
:
[
2
27
]
83
:
[
2
27
]
84
:
[
2
27
]
85
:
[
2
27
]
}
{
23
:
[
2
28
]
33
:
[
2
28
]
54
:
[
2
28
]
65
:
[
2
28
]
68
:
[
2
28
]
72
:
[
2
28
]
75
:
[
2
28
]
80
:
[
2
28
]
81
:
[
2
28
]
82
:
[
2
28
]
83
:
[
2
28
]
84
:
[
2
28
]
85
:
[
2
28
]
}
{
23
:
[
2
30
]
33
:
[
2
30
]
54
:
[
2
30
]
68
:
[
2
30
]
71
:
107
72
:
[
1
108
]
75
:
[
2
30
]
}
{
23
:
[
2
98
]
33
:
[
2
98
]
54
:
[
2
98
]
68
:
[
2
98
]
72
:
[
2
98
]
75
:
[
2
98
]
}
{
23
:
[
2
45
]
33
:
[
2
45
]
54
:
[
2
45
]
65
:
[
2
45
]
68
:
[
2
45
]
72
:
[
2
45
]
73
:
[
1
109
]
75
:
[
2
45
]
80
:
[
2
45
]
81
:
[
2
45
]
82
:
[
2
45
]
83
:
[
2
45
]
84
:
[
2
45
]
85
:
[
2
45
]
87
:
[
2
45
]
}
{
23
:
[
2
44
]
33
:
[
2
44
]
54
:
[
2
44
]
65
:
[
2
44
]
68
:
[
2
44
]
72
:
[
2
44
]
75
:
[
2
44
]
80
:
[
2
44
]
81
:
[
2
44
]
82
:
[
2
44
]
83
:
[
2
44
]
84
:
[
2
44
]
85
:
[
2
44
]
87
:
[
2
44
]
}
{
54
:
[
1
110
]
}
{
54
:
[
2
83
]
65
:
[
2
83
]
72
:
[
2
83
]
80
:
[
2
83
]
81
:
[
2
83
]
82
:
[
2
83
]
83
:
[
2
83
]
84
:
[
2
83
]
85
:
[
2
83
]
}
{
54
:
[
2
85
]
}
{
5
:
[
2
13
]
14
:
[
2
13
]
15
:
[
2
13
]
19
:
[
2
13
]
29
:
[
2
13
]
34
:
[
2
13
]
39
:
[
2
13
]
44
:
[
2
13
]
47
:
[
2
13
]
48
:
[
2
13
]
51
:
[
2
13
]
55
:
[
2
13
]
60
:
[
2
13
]
}
{
38
:
56
39
:
[
1
58
]
43
:
57
44
:
[
1
59
]
45
:
112
46
:
111
47
:
[
2
76
]
}
{
33
:
[
2
70
]
40
:
113
65
:
[
2
70
]
72
:
[
2
70
]
75
:
[
2
70
]
80
:
[
2
70
]
81
:
[
2
70
]
82
:
[
2
70
]
83
:
[
2
70
]
84
:
[
2
70
]
85
:
[
2
70
]
}
{
47
:
[
2
18
]
}
{
5
:
[
2
14
]
14
:
[
2
14
]
15
:
[
2
14
]
19
:
[
2
14
]
29
:
[
2
14
]
34
:
[
2
14
]
39
:
[
2
14
]
44
:
[
2
14
]
47
:
[
2
14
]
48
:
[
2
14
]
51
:
[
2
14
]
55
:
[
2
14
]
60
:
[
2
14
]
}
{
33
:
[
1
114
]
}
{
33
:
[
2
87
]
65
:
[
2
87
]
72
:
[
2
87
]
80
:
[
2
87
]
81
:
[
2
87
]
82
:
[
2
87
]
83
:
[
2
87
]
84
:
[
2
87
]
85
:
[
2
87
]
}
{
33
:
[
2
89
]
}
{
20
:
75
63
:
116
64
:
76
65
:
[
1
44
]
67
:
115
68
:
[
2
96
]
69
:
117
70
:
77
71
:
78
72
:
[
1
79
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
33
:
[
1
118
]
}
{
32
:
119
33
:
[
2
62
]
74
:
120
75
:
[
1
121
]
}
{
33
:
[
2
59
]
65
:
[
2
59
]
72
:
[
2
59
]
75
:
[
2
59
]
80
:
[
2
59
]
81
:
[
2
59
]
82
:
[
2
59
]
83
:
[
2
59
]
84
:
[
2
59
]
85
:
[
2
59
]
}
{
33
:
[
2
61
]
75
:
[
2
61
]
}
{
33
:
[
2
68
]
37
:
122
74
:
123
75
:
[
1
121
]
}
{
33
:
[
2
65
]
65
:
[
2
65
]
72
:
[
2
65
]
75
:
[
2
65
]
80
:
[
2
65
]
81
:
[
2
65
]
82
:
[
2
65
]
83
:
[
2
65
]
84
:
[
2
65
]
85
:
[
2
65
]
}
{
33
:
[
2
67
]
75
:
[
2
67
]
}
{
23
:
[
1
124
]
}
{
23
:
[
2
51
]
65
:
[
2
51
]
72
:
[
2
51
]
80
:
[
2
51
]
81
:
[
2
51
]
82
:
[
2
51
]
83
:
[
2
51
]
84
:
[
2
51
]
85
:
[
2
51
]
}
{
23
:
[
2
53
]
}
{
33
:
[
1
125
]
}
{
33
:
[
2
91
]
65
:
[
2
91
]
72
:
[
2
91
]
80
:
[
2
91
]
81
:
[
2
91
]
82
:
[
2
91
]
83
:
[
2
91
]
84
:
[
2
91
]
85
:
[
2
91
]
}
{
33
:
[
2
93
]
}
{
5
:
[
2
22
]
14
:
[
2
22
]
15
:
[
2
22
]
19
:
[
2
22
]
29
:
[
2
22
]
34
:
[
2
22
]
39
:
[
2
22
]
44
:
[
2
22
]
47
:
[
2
22
]
48
:
[
2
22
]
51
:
[
2
22
]
55
:
[
2
22
]
60
:
[
2
22
]
}
{
23
:
[
2
99
]
33
:
[
2
99
]
54
:
[
2
99
]
68
:
[
2
99
]
72
:
[
2
99
]
75
:
[
2
99
]
}
{
73
:
[
1
109
]
}
{
20
:
75
63
:
126
64
:
76
65
:
[
1
44
]
72
:
[
1
35
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
5
:
[
2
23
]
14
:
[
2
23
]
15
:
[
2
23
]
19
:
[
2
23
]
29
:
[
2
23
]
34
:
[
2
23
]
39
:
[
2
23
]
44
:
[
2
23
]
47
:
[
2
23
]
48
:
[
2
23
]
51
:
[
2
23
]
55
:
[
2
23
]
60
:
[
2
23
]
}
{
47
:
[
2
19
]
}
{
47
:
[
2
77
]
}
{
20
:
75
33
:
[
2
72
]
41
:
127
63
:
128
64
:
76
65
:
[
1
44
]
69
:
129
70
:
77
71
:
78
72
:
[
1
79
]
75
:
[
2
72
]
78
:
26
79
:
27
80
:
[
1
28
]
81
:
[
1
29
]
82
:
[
1
30
]
83
:
[
1
31
]
84
:
[
1
32
]
85
:
[
1
34
]
86
:
33
}
{
5
:
[
2
24
]
14
:
[
2
24
]
15
:
[
2
24
]
19
:
[
2
24
]
29
:
[
2
24
]
34
:
[
2
24
]
39
:
[
2
24
]
44
:
[
2
24
]
47
:
[
2
24
]
48
:
[
2
24
]
51
:
[
2
24
]
55
:
[
2
24
]
60
:
[
2
24
]
}
{
68
:
[
1
130
]
}
{
65
:
[
2
95
]
68
:
[
2
95
]
72
:
[
2
95
]
80
:
[
2
95
]
81
:
[
2
95
]
82
:
[
2
95
]
83
:
[
2
95
]
84
:
[
2
95
]
85
:
[
2
95
]
}
{
68
:
[
2
97
]
}
{
5
:
[
2
21
]
14
:
[
2
21
]
15
:
[
2
21
]
19
:
[
2
21
]
29
:
[
2
21
]
34
:
[
2
21
]
39
:
[
2
21
]
44
:
[
2
21
]
47
:
[
2
21
]
48
:
[
2
21
]
51
:
[
2
21
]
55
:
[
2
21
]
60
:
[
2
21
]
}
{
33
:
[
1
131
]
}
{
33
:
[
2
63
]
}
{
72
:
[
1
133
]
76
:
132
}
{
33
:
[
1
134
]
}
{
33
:
[
2
69
]
}
{
15
:
[
2
12
]
}
{
14
:
[
2
26
]
15
:
[
2
26
]
19
:
[
2
26
]
29
:
[
2
26
]
34
:
[
2
26
]
47
:
[
2
26
]
48
:
[
2
26
]
51
:
[
2
26
]
55
:
[
2
26
]
60
:
[
2
26
]
}
{
23
:
[
2
31
]
33
:
[
2
31
]
54
:
[
2
31
]
68
:
[
2
31
]
72
:
[
2
31
]
75
:
[
2
31
]
}
{
33
:
[
2
74
]
42
:
135
74
:
136
75
:
[
1
121
]
}
{
33
:
[
2
71
]
65
:
[
2
71
]
72
:
[
2
71
]
75
:
[
2
71
]
80
:
[
2
71
]
81
:
[
2
71
]
82
:
[
2
71
]
83
:
[
2
71
]
84
:
[
2
71
]
85
:
[
2
71
]
}
{
33
:
[
2
73
]
75
:
[
2
73
]
}
{
23
:
[
2
29
]
33
:
[
2
29
]
54
:
[
2
29
]
65
:
[
2
29
]
68
:
[
2
29
]
72
:
[
2
29
]
75
:
[
2
29
]
80
:
[
2
29
]
81
:
[
2
29
]
82
:
[
2
29
]
83
:
[
2
29
]
84
:
[
2
29
]
85
:
[
2
29
]
}
{
14
:
[
2
15
]
15
:
[
2
15
]
19
:
[
2
15
]
29
:
[
2
15
]
34
:
[
2
15
]
39
:
[
2
15
]
44
:
[
2
15
]
47
:
[
2
15
]
48
:
[
2
15
]
51
:
[
2
15
]
55
:
[
2
15
]
60
:
[
2
15
]
}
{
72
:
[
1
138
]
77
:
[
1
137
]
}
{
72
:
[
2
100
]
77
:
[
2
100
]
}
{
14
:
[
2
16
]
15
:
[
2
16
]
19
:
[
2
16
]
29
:
[
2
16
]
34
:
[
2
16
]
44
:
[
2
16
]
47
:
[
2
16
]
48
:
[
2
16
]
51
:
[
2
16
]
55
:
[
2
16
]
60
:
[
2
16
]
}
{
33
:
[
1
139
]
}
{
33
:
[
2
75
]
}
{
33
:
[
2
32
]
}
{
72
:
[
2
101
]
77
:
[
2
101
]
}
{
14
:
[
2
17
]
15
:
[
2
17
]
19
:
[
2
17
]
29
:
[
2
17
]
34
:
[
2
17
]
39
:
[
2
17
]
44
:
[
2
17
]
47
:
[
2
17
]
48
:
[
2
17
]
51
:
[
2
17
]
55
:
[
2
17
]
60
:
[
2
17
]
}
]
defaultActions
:
{
4
:
[
2
1
]
55
:
[
2
55
]
57
:
[
2
20
]
61
:
[
2
57
]
74
:
[
2
81
]
83
:
[
2
85
]
87
:
[
2
18
]
91
:
[
2
89
]
102
:
[
2
53
]
105
:
[
2
93
]
111
:
[
2
19
]
112
:
[
2
77
]
117
:
[
2
97
]
120
:
[
2
63
]
123
:
[
2
69
]
124
:
[
2
12
]
136
:
[
2
75
]
137
:
[
2
32
]
}
parseError
:
function
parseError
(
str
hash
)
{
throw
new
Error
(
str
)
;
}
parse
:
function
parse
(
input
)
{
var
self
=
this
stack
=
[
0
]
vstack
=
[
null
]
lstack
=
[
]
table
=
this
.
table
yytext
=
"
"
yylineno
=
0
yyleng
=
0
recovering
=
0
;
this
.
lexer
.
setInput
(
input
)
;
this
.
lexer
.
yy
=
this
.
yy
;
this
.
yy
.
lexer
=
this
.
lexer
;
this
.
yy
.
parser
=
this
;
if
(
typeof
this
.
lexer
.
yylloc
=
=
"
undefined
"
)
this
.
lexer
.
yylloc
=
{
}
;
var
yyloc
=
this
.
lexer
.
yylloc
;
lstack
.
push
(
yyloc
)
;
var
ranges
=
this
.
lexer
.
options
&
&
this
.
lexer
.
options
.
ranges
;
if
(
typeof
this
.
yy
.
parseError
=
=
=
"
function
"
)
this
.
parseError
=
this
.
yy
.
parseError
;
function
lex
(
)
{
var
token
;
token
=
self
.
lexer
.
lex
(
)
|
|
1
;
if
(
typeof
token
!
=
=
"
number
"
)
{
token
=
self
.
symbols_
[
token
]
|
|
token
;
}
return
token
;
}
var
symbol
preErrorSymbol
state
action
a
r
yyval
=
{
}
p
len
newState
expected
;
while
(
true
)
{
state
=
stack
[
stack
.
length
-
1
]
;
if
(
this
.
defaultActions
[
state
]
)
{
action
=
this
.
defaultActions
[
state
]
;
}
else
{
if
(
symbol
=
=
=
null
|
|
typeof
symbol
=
=
"
undefined
"
)
{
symbol
=
lex
(
)
;
}
action
=
table
[
state
]
&
&
table
[
state
]
[
symbol
]
;
}
if
(
typeof
action
=
=
=
"
undefined
"
|
|
!
action
.
length
|
|
!
action
[
0
]
)
{
var
errStr
=
"
"
;
if
(
!
recovering
)
{
expected
=
[
]
;
for
(
p
in
table
[
state
]
)
{
if
(
this
.
terminals_
[
p
]
&
&
p
>
2
)
{
expected
.
push
(
"
'
"
+
this
.
terminals_
[
p
]
+
"
'
"
)
;
}
}
if
(
this
.
lexer
.
showPosition
)
{
errStr
=
"
Parse
error
on
line
"
+
(
yylineno
+
1
)
+
"
:
\
n
"
+
this
.
lexer
.
showPosition
(
)
+
"
\
nExpecting
"
+
expected
.
join
(
"
"
)
+
"
got
'
"
+
(
this
.
terminals_
[
symbol
]
|
|
symbol
)
+
"
'
"
;
}
else
{
errStr
=
"
Parse
error
on
line
"
+
(
yylineno
+
1
)
+
"
:
Unexpected
"
+
(
symbol
=
=
1
?
"
end
of
input
"
:
"
'
"
+
(
this
.
terminals_
[
symbol
]
|
|
symbol
)
+
"
'
"
)
;
}
this
.
parseError
(
errStr
{
text
:
this
.
lexer
.
match
token
:
this
.
terminals_
[
symbol
]
|
|
symbol
line
:
this
.
lexer
.
yylineno
loc
:
yyloc
expected
:
expected
}
)
;
}
}
if
(
action
[
0
]
instanceof
Array
&
&
action
.
length
>
1
)
{
throw
new
Error
(
"
Parse
Error
:
multiple
actions
possible
at
state
:
"
+
state
+
"
token
:
"
+
symbol
)
;
}
switch
(
action
[
0
]
)
{
case
1
:
stack
.
push
(
symbol
)
;
vstack
.
push
(
this
.
lexer
.
yytext
)
;
lstack
.
push
(
this
.
lexer
.
yylloc
)
;
stack
.
push
(
action
[
1
]
)
;
symbol
=
null
;
if
(
!
preErrorSymbol
)
{
yyleng
=
this
.
lexer
.
yyleng
;
yytext
=
this
.
lexer
.
yytext
;
yylineno
=
this
.
lexer
.
yylineno
;
yyloc
=
this
.
lexer
.
yylloc
;
if
(
recovering
>
0
)
recovering
-
-
;
}
else
{
symbol
=
preErrorSymbol
;
preErrorSymbol
=
null
;
}
break
;
case
2
:
len
=
this
.
productions_
[
action
[
1
]
]
[
1
]
;
yyval
.
=
vstack
[
vstack
.
length
-
len
]
;
yyval
.
_
=
{
first_line
:
lstack
[
lstack
.
length
-
(
len
|
|
1
)
]
.
first_line
last_line
:
lstack
[
lstack
.
length
-
1
]
.
last_line
first_column
:
lstack
[
lstack
.
length
-
(
len
|
|
1
)
]
.
first_column
last_column
:
lstack
[
lstack
.
length
-
1
]
.
last_column
}
;
if
(
ranges
)
{
yyval
.
_
.
range
=
[
lstack
[
lstack
.
length
-
(
len
|
|
1
)
]
.
range
[
0
]
lstack
[
lstack
.
length
-
1
]
.
range
[
1
]
]
;
}
r
=
this
.
performAction
.
call
(
yyval
yytext
yyleng
yylineno
this
.
yy
action
[
1
]
vstack
lstack
)
;
if
(
typeof
r
!
=
=
"
undefined
"
)
{
return
r
;
}
if
(
len
)
{
stack
=
stack
.
slice
(
0
-
1
*
len
*
2
)
;
vstack
=
vstack
.
slice
(
0
-
1
*
len
)
;
lstack
=
lstack
.
slice
(
0
-
1
*
len
)
;
}
stack
.
push
(
this
.
productions_
[
action
[
1
]
]
[
0
]
)
;
vstack
.
push
(
yyval
.
)
;
lstack
.
push
(
yyval
.
_
)
;
newState
=
table
[
stack
[
stack
.
length
-
2
]
]
[
stack
[
stack
.
length
-
1
]
]
;
stack
.
push
(
newState
)
;
break
;
case
3
:
return
true
;
}
}
return
true
;
}
}
;
var
lexer
=
function
(
)
{
var
lexer
=
{
EOF
:
1
parseError
:
function
parseError
(
str
hash
)
{
if
(
this
.
yy
.
parser
)
{
this
.
yy
.
parser
.
parseError
(
str
hash
)
;
}
else
{
throw
new
Error
(
str
)
;
}
}
setInput
:
function
(
input
)
{
this
.
_input
=
input
;
this
.
_more
=
this
.
_less
=
this
.
done
=
false
;
this
.
yylineno
=
this
.
yyleng
=
0
;
this
.
yytext
=
this
.
matched
=
this
.
match
=
'
'
;
this
.
conditionStack
=
[
'
INITIAL
'
]
;
this
.
yylloc
=
{
first_line
:
1
first_column
:
0
last_line
:
1
last_column
:
0
}
;
if
(
this
.
options
.
ranges
)
this
.
yylloc
.
range
=
[
0
0
]
;
this
.
offset
=
0
;
return
this
;
}
input
:
function
(
)
{
var
ch
=
this
.
_input
[
0
]
;
this
.
yytext
+
=
ch
;
this
.
yyleng
+
+
;
this
.
offset
+
+
;
this
.
match
+
=
ch
;
this
.
matched
+
=
ch
;
var
lines
=
ch
.
match
(
/
(
?
:
\
r
\
n
?
|
\
n
)
.
*
/
g
)
;
if
(
lines
)
{
this
.
yylineno
+
+
;
this
.
yylloc
.
last_line
+
+
;
}
else
{
this
.
yylloc
.
last_column
+
+
;
}
if
(
this
.
options
.
ranges
)
this
.
yylloc
.
range
[
1
]
+
+
;
this
.
_input
=
this
.
_input
.
slice
(
1
)
;
return
ch
;
}
unput
:
function
(
ch
)
{
var
len
=
ch
.
length
;
var
lines
=
ch
.
split
(
/
(
?
:
\
r
\
n
?
|
\
n
)
/
g
)
;
this
.
_input
=
ch
+
this
.
_input
;
this
.
yytext
=
this
.
yytext
.
substr
(
0
this
.
yytext
.
length
-
len
-
1
)
;
this
.
offset
-
=
len
;
var
oldLines
=
this
.
match
.
split
(
/
(
?
:
\
r
\
n
?
|
\
n
)
/
g
)
;
this
.
match
=
this
.
match
.
substr
(
0
this
.
match
.
length
-
1
)
;
this
.
matched
=
this
.
matched
.
substr
(
0
this
.
matched
.
length
-
1
)
;
if
(
lines
.
length
-
1
)
this
.
yylineno
-
=
lines
.
length
-
1
;
var
r
=
this
.
yylloc
.
range
;
this
.
yylloc
=
{
first_line
:
this
.
yylloc
.
first_line
last_line
:
this
.
yylineno
+
1
first_column
:
this
.
yylloc
.
first_column
last_column
:
lines
?
(
lines
.
length
=
=
=
oldLines
.
length
?
this
.
yylloc
.
first_column
:
0
)
+
oldLines
[
oldLines
.
length
-
lines
.
length
]
.
length
-
lines
[
0
]
.
length
:
this
.
yylloc
.
first_column
-
len
}
;
if
(
this
.
options
.
ranges
)
{
this
.
yylloc
.
range
=
[
r
[
0
]
r
[
0
]
+
this
.
yyleng
-
len
]
;
}
return
this
;
}
more
:
function
(
)
{
this
.
_more
=
true
;
return
this
;
}
less
:
function
(
n
)
{
this
.
unput
(
this
.
match
.
slice
(
n
)
)
;
}
pastInput
:
function
(
)
{
var
past
=
this
.
matched
.
substr
(
0
this
.
matched
.
length
-
this
.
match
.
length
)
;
return
(
past
.
length
>
20
?
'
.
.
.
'
:
'
'
)
+
past
.
substr
(
-
20
)
.
replace
(
/
\
n
/
g
"
"
)
;
}
upcomingInput
:
function
(
)
{
var
next
=
this
.
match
;
if
(
next
.
length
<
20
)
{
next
+
=
this
.
_input
.
substr
(
0
20
-
next
.
length
)
;
}
return
(
next
.
substr
(
0
20
)
+
(
next
.
length
>
20
?
'
.
.
.
'
:
'
'
)
)
.
replace
(
/
\
n
/
g
"
"
)
;
}
showPosition
:
function
(
)
{
var
pre
=
this
.
pastInput
(
)
;
var
c
=
new
Array
(
pre
.
length
+
1
)
.
join
(
"
-
"
)
;
return
pre
+
this
.
upcomingInput
(
)
+
"
\
n
"
+
c
+
"
^
"
;
}
next
:
function
(
)
{
if
(
this
.
done
)
{
return
this
.
EOF
;
}
if
(
!
this
.
_input
)
this
.
done
=
true
;
var
token
match
tempMatch
index
col
lines
;
if
(
!
this
.
_more
)
{
this
.
yytext
=
'
'
;
this
.
match
=
'
'
;
}
var
rules
=
this
.
_currentRules
(
)
;
for
(
var
i
=
0
;
i
<
rules
.
length
;
i
+
+
)
{
tempMatch
=
this
.
_input
.
match
(
this
.
rules
[
rules
[
i
]
]
)
;
if
(
tempMatch
&
&
(
!
match
|
|
tempMatch
[
0
]
.
length
>
match
[
0
]
.
length
)
)
{
match
=
tempMatch
;
index
=
i
;
if
(
!
this
.
options
.
flex
)
break
;
}
}
if
(
match
)
{
lines
=
match
[
0
]
.
match
(
/
(
?
:
\
r
\
n
?
|
\
n
)
.
*
/
g
)
;
if
(
lines
)
this
.
yylineno
+
=
lines
.
length
;
this
.
yylloc
=
{
first_line
:
this
.
yylloc
.
last_line
last_line
:
this
.
yylineno
+
1
first_column
:
this
.
yylloc
.
last_column
last_column
:
lines
?
lines
[
lines
.
length
-
1
]
.
length
-
lines
[
lines
.
length
-
1
]
.
match
(
/
\
r
?
\
n
?
/
)
[
0
]
.
length
:
this
.
yylloc
.
last_column
+
match
[
0
]
.
length
}
;
this
.
yytext
+
=
match
[
0
]
;
this
.
match
+
=
match
[
0
]
;
this
.
matches
=
match
;
this
.
yyleng
=
this
.
yytext
.
length
;
if
(
this
.
options
.
ranges
)
{
this
.
yylloc
.
range
=
[
this
.
offset
this
.
offset
+
=
this
.
yyleng
]
;
}
this
.
_more
=
false
;
this
.
_input
=
this
.
_input
.
slice
(
match
[
0
]
.
length
)
;
this
.
matched
+
=
match
[
0
]
;
token
=
this
.
performAction
.
call
(
this
this
.
yy
this
rules
[
index
]
this
.
conditionStack
[
this
.
conditionStack
.
length
-
1
]
)
;
if
(
this
.
done
&
&
this
.
_input
)
this
.
done
=
false
;
if
(
token
)
return
token
;
else
return
;
}
if
(
this
.
_input
=
=
=
"
"
)
{
return
this
.
EOF
;
}
else
{
return
this
.
parseError
(
'
Lexical
error
on
line
'
+
(
this
.
yylineno
+
1
)
+
'
.
Unrecognized
text
.
\
n
'
+
this
.
showPosition
(
)
{
text
:
"
"
token
:
null
line
:
this
.
yylineno
}
)
;
}
}
lex
:
function
lex
(
)
{
var
r
=
this
.
next
(
)
;
if
(
typeof
r
!
=
=
'
undefined
'
)
{
return
r
;
}
else
{
return
this
.
lex
(
)
;
}
}
begin
:
function
begin
(
condition
)
{
this
.
conditionStack
.
push
(
condition
)
;
}
popState
:
function
popState
(
)
{
return
this
.
conditionStack
.
pop
(
)
;
}
_currentRules
:
function
_currentRules
(
)
{
return
this
.
conditions
[
this
.
conditionStack
[
this
.
conditionStack
.
length
-
1
]
]
.
rules
;
}
topState
:
function
(
)
{
return
this
.
conditionStack
[
this
.
conditionStack
.
length
-
2
]
;
}
pushState
:
function
begin
(
condition
)
{
this
.
begin
(
condition
)
;
}
}
;
lexer
.
options
=
{
}
;
lexer
.
performAction
=
function
anonymous
(
yy
yy_
avoiding_name_collisions
YY_START
)
{
function
strip
(
start
end
)
{
return
yy_
.
yytext
=
yy_
.
yytext
.
substr
(
start
yy_
.
yyleng
-
end
)
;
}
switch
(
avoiding_name_collisions
)
{
case
0
:
if
(
yy_
.
yytext
.
slice
(
-
2
)
=
=
=
"
\
\
\
\
"
)
{
strip
(
0
1
)
;
this
.
begin
(
"
mu
"
)
;
}
else
if
(
yy_
.
yytext
.
slice
(
-
1
)
=
=
=
"
\
\
"
)
{
strip
(
0
1
)
;
this
.
begin
(
"
emu
"
)
;
}
else
{
this
.
begin
(
"
mu
"
)
;
}
if
(
yy_
.
yytext
)
return
15
;
break
;
case
1
:
return
15
;
break
;
case
2
:
this
.
popState
(
)
;
return
15
;
break
;
case
3
:
this
.
begin
(
'
raw
'
)
;
return
15
;
break
;
case
4
:
this
.
popState
(
)
;
if
(
this
.
conditionStack
[
this
.
conditionStack
.
length
-
1
]
=
=
=
'
raw
'
)
{
return
15
;
}
else
{
yy_
.
yytext
=
yy_
.
yytext
.
substr
(
5
yy_
.
yyleng
-
9
)
;
return
'
END_RAW_BLOCK
'
;
}
break
;
case
5
:
return
15
;
break
;
case
6
:
this
.
popState
(
)
;
return
14
;
break
;
case
7
:
return
65
;
break
;
case
8
:
return
68
;
break
;
case
9
:
return
19
;
break
;
case
10
:
this
.
popState
(
)
;
this
.
begin
(
'
raw
'
)
;
return
23
;
break
;
case
11
:
return
55
;
break
;
case
12
:
return
60
;
break
;
case
13
:
return
29
;
break
;
case
14
:
return
47
;
break
;
case
15
:
this
.
popState
(
)
;
return
44
;
break
;
case
16
:
this
.
popState
(
)
;
return
44
;
break
;
case
17
:
return
34
;
break
;
case
18
:
return
39
;
break
;
case
19
:
return
51
;
break
;
case
20
:
return
48
;
break
;
case
21
:
this
.
unput
(
yy_
.
yytext
)
;
this
.
popState
(
)
;
this
.
begin
(
'
com
'
)
;
break
;
case
22
:
this
.
popState
(
)
;
return
14
;
break
;
case
23
:
return
48
;
break
;
case
24
:
return
73
;
break
;
case
25
:
return
72
;
break
;
case
26
:
return
72
;
break
;
case
27
:
return
87
;
break
;
case
28
:
break
;
case
29
:
this
.
popState
(
)
;
return
54
;
break
;
case
30
:
this
.
popState
(
)
;
return
33
;
break
;
case
31
:
yy_
.
yytext
=
strip
(
1
2
)
.
replace
(
/
\
\
"
/
g
'
"
'
)
;
return
80
;
break
;
case
32
:
yy_
.
yytext
=
strip
(
1
2
)
.
replace
(
/
\
\
'
/
g
"
'
"
)
;
return
80
;
break
;
case
33
:
return
85
;
break
;
case
34
:
return
82
;
break
;
case
35
:
return
82
;
break
;
case
36
:
return
83
;
break
;
case
37
:
return
84
;
break
;
case
38
:
return
81
;
break
;
case
39
:
return
75
;
break
;
case
40
:
return
77
;
break
;
case
41
:
return
72
;
break
;
case
42
:
yy_
.
yytext
=
yy_
.
yytext
.
replace
(
/
\
\
(
[
\
\
\
]
]
)
/
g
'
1
'
)
;
return
72
;
break
;
case
43
:
return
'
INVALID
'
;
break
;
case
44
:
return
5
;
break
;
}
}
;
lexer
.
rules
=
[
/
^
(
?
:
[
^
\
x00
]
*
?
(
?
=
(
\
{
\
{
)
)
)
/
/
^
(
?
:
[
^
\
x00
]
+
)
/
/
^
(
?
:
[
^
\
x00
]
{
2
}
?
(
?
=
(
\
{
\
{
|
\
\
\
{
\
{
|
\
\
\
\
\
{
\
{
|
)
)
)
/
/
^
(
?
:
\
{
\
{
\
{
\
{
(
?
=
[
^
\
/
]
)
)
/
/
^
(
?
:
\
{
\
{
\
{
\
{
\
/
[
^
\
s
!
"
#
%
-
\
.
\
/
;
-
>
\
[
-
\
^
\
{
-
~
]
+
(
?
=
[
=
}
\
s
\
/
.
]
)
\
}
\
}
\
}
\
}
)
/
/
^
(
?
:
[
^
\
x00
]
*
?
(
?
=
(
\
{
\
{
\
{
\
{
)
)
)
/
/
^
(
?
:
[
\
s
\
S
]
*
?
-
-
(
~
)
?
\
}
\
}
)
/
/
^
(
?
:
\
(
)
/
/
^
(
?
:
\
)
)
/
/
^
(
?
:
\
{
\
{
\
{
\
{
)
/
/
^
(
?
:
\
}
\
}
\
}
\
}
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
>
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
#
>
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
#
\
*
?
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
/
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
^
\
s
*
(
~
)
?
\
}
\
}
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
s
*
else
\
s
*
(
~
)
?
\
}
\
}
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
^
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
s
*
else
\
b
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
{
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
&
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
!
-
-
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
!
[
\
s
\
S
]
*
?
\
}
\
}
)
/
/
^
(
?
:
\
{
\
{
(
~
)
?
\
*
?
)
/
/
^
(
?
:
=
)
/
/
^
(
?
:
\
.
\
.
)
/
/
^
(
?
:
\
.
(
?
=
(
[
=
~
}
\
s
\
/
.
)
|
]
)
)
)
/
/
^
(
?
:
[
\
/
.
]
)
/
/
^
(
?
:
\
s
+
)
/
/
^
(
?
:
\
}
(
~
)
?
\
}
\
}
)
/
/
^
(
?
:
(
~
)
?
\
}
\
}
)
/
/
^
(
?
:
"
(
\
\
[
"
]
|
[
^
"
]
)
*
"
)
/
/
^
(
?
:
'
(
\
\
[
'
]
|
[
^
'
]
)
*
'
)
/
/
^
(
?
:
)
/
/
^
(
?
:
true
(
?
=
(
[
~
}
\
s
)
]
)
)
)
/
/
^
(
?
:
false
(
?
=
(
[
~
}
\
s
)
]
)
)
)
/
/
^
(
?
:
undefined
(
?
=
(
[
~
}
\
s
)
]
)
)
)
/
/
^
(
?
:
null
(
?
=
(
[
~
}
\
s
)
]
)
)
)
/
/
^
(
?
:
-
?
[
0
-
9
]
+
(
?
:
\
.
[
0
-
9
]
+
)
?
(
?
=
(
[
~
}
\
s
)
]
)
)
)
/
/
^
(
?
:
as
\
s
+
\
|
)
/
/
^
(
?
:
\
|
)
/
/
^
(
?
:
(
[
^
\
s
!
"
#
%
-
\
.
\
/
;
-
>
\
[
-
\
^
\
{
-
~
]
+
(
?
=
(
[
=
~
}
\
s
\
/
.
)
|
]
)
)
)
)
/
/
^
(
?
:
\
[
(
\
\
\
]
|
[
^
\
]
]
)
*
\
]
)
/
/
^
(
?
:
.
)
/
/
^
(
?
:
)
/
]
;
lexer
.
conditions
=
{
"
mu
"
:
{
"
rules
"
:
[
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
]
"
inclusive
"
:
false
}
"
emu
"
:
{
"
rules
"
:
[
2
]
"
inclusive
"
:
false
}
"
com
"
:
{
"
rules
"
:
[
6
]
"
inclusive
"
:
false
}
"
raw
"
:
{
"
rules
"
:
[
3
4
5
]
"
inclusive
"
:
false
}
"
INITIAL
"
:
{
"
rules
"
:
[
0
1
44
]
"
inclusive
"
:
true
}
}
;
return
lexer
;
}
(
)
;
parser
.
lexer
=
lexer
;
function
Parser
(
)
{
this
.
yy
=
{
}
;
}
Parser
.
prototype
=
parser
;
parser
.
Parser
=
Parser
;
return
new
Parser
(
)
;
}
(
)
;
var
errorProps
=
[
'
description
'
'
fileName
'
'
lineNumber
'
'
message
'
'
name
'
'
number
'
'
stack
'
]
;
function
Exception
(
message
node
)
{
var
loc
=
node
&
&
node
.
loc
line
=
void
0
column
=
void
0
;
if
(
loc
)
{
line
=
loc
.
start
.
line
;
column
=
loc
.
start
.
column
;
message
+
=
'
-
'
+
line
+
'
:
'
+
column
;
}
var
tmp
=
Error
.
prototype
.
constructor
.
call
(
this
message
)
;
for
(
var
idx
=
0
;
idx
<
errorProps
.
length
;
idx
+
+
)
{
this
[
errorProps
[
idx
]
]
=
tmp
[
errorProps
[
idx
]
]
;
}
if
(
Error
.
captureStackTrace
)
{
Error
.
captureStackTrace
(
this
Exception
)
;
}
try
{
if
(
loc
)
{
this
.
lineNumber
=
line
;
if
(
Object
.
defineProperty
)
{
Object
.
defineProperty
(
this
'
column
'
{
value
:
column
enumerable
:
true
}
)
;
}
else
{
this
.
column
=
column
;
}
}
}
catch
(
nop
)
{
}
}
Exception
.
prototype
=
new
Error
(
)
;
function
Visitor
(
)
{
this
.
parents
=
[
]
;
}
Visitor
.
prototype
=
{
constructor
:
Visitor
mutating
:
false
acceptKey
:
function
(
node
name
)
{
var
value
=
this
.
accept
(
node
[
name
]
)
;
if
(
this
.
mutating
)
{
if
(
value
&
&
!
Visitor
.
prototype
[
value
.
type
]
)
{
throw
new
Exception
(
'
Unexpected
node
type
"
'
+
value
.
type
+
'
"
found
when
accepting
'
+
name
+
'
on
'
+
node
.
type
)
;
}
node
[
name
]
=
value
;
}
}
acceptRequired
:
function
(
node
name
)
{
this
.
acceptKey
(
node
name
)
;
if
(
!
node
[
name
]
)
{
throw
new
Exception
(
node
.
type
+
'
requires
'
+
name
)
;
}
}
acceptArray
:
function
(
array
)
{
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
this
.
acceptKey
(
array
i
)
;
if
(
!
array
[
i
]
)
{
array
.
splice
(
i
1
)
;
i
-
-
;
l
-
-
;
}
}
}
accept
:
function
(
object
)
{
if
(
!
object
)
{
return
;
}
if
(
!
this
[
object
.
type
]
)
{
throw
new
Exception
(
'
Unknown
type
:
'
+
object
.
type
object
)
;
}
if
(
this
.
current
)
{
this
.
parents
.
unshift
(
this
.
current
)
;
}
this
.
current
=
object
;
var
ret
=
this
[
object
.
type
]
(
object
)
;
this
.
current
=
this
.
parents
.
shift
(
)
;
if
(
!
this
.
mutating
|
|
ret
)
{
return
ret
;
}
else
if
(
ret
!
=
=
false
)
{
return
object
;
}
}
Program
:
function
(
program
)
{
this
.
acceptArray
(
program
.
body
)
;
}
MustacheStatement
:
visitSubExpression
Decorator
:
visitSubExpression
BlockStatement
:
visitBlock
DecoratorBlock
:
visitBlock
PartialStatement
:
visitPartial
PartialBlockStatement
:
function
(
partial
)
{
visitPartial
.
call
(
this
partial
)
;
this
.
acceptKey
(
partial
'
program
'
)
;
}
ContentStatement
:
function
(
)
{
}
CommentStatement
:
function
(
)
{
}
SubExpression
:
visitSubExpression
PathExpression
:
function
(
)
{
}
StringLiteral
:
function
(
)
{
}
NumberLiteral
:
function
(
)
{
}
BooleanLiteral
:
function
(
)
{
}
UndefinedLiteral
:
function
(
)
{
}
NullLiteral
:
function
(
)
{
}
Hash
:
function
(
hash
)
{
this
.
acceptArray
(
hash
.
pairs
)
;
}
HashPair
:
function
(
pair
)
{
this
.
acceptRequired
(
pair
'
value
'
)
;
}
}
;
function
visitSubExpression
(
mustache
)
{
this
.
acceptRequired
(
mustache
'
path
'
)
;
this
.
acceptArray
(
mustache
.
params
)
;
this
.
acceptKey
(
mustache
'
hash
'
)
;
}
function
visitBlock
(
block
)
{
visitSubExpression
.
call
(
this
block
)
;
this
.
acceptKey
(
block
'
program
'
)
;
this
.
acceptKey
(
block
'
inverse
'
)
;
}
function
visitPartial
(
partial
)
{
this
.
acceptRequired
(
partial
'
name
'
)
;
this
.
acceptArray
(
partial
.
params
)
;
this
.
acceptKey
(
partial
'
hash
'
)
;
}
function
WhitespaceControl
(
)
{
var
options
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
;
this
.
options
=
options
;
}
WhitespaceControl
.
prototype
=
new
Visitor
(
)
;
WhitespaceControl
.
prototype
.
Program
=
function
(
program
)
{
var
doStandalone
=
!
this
.
options
.
ignoreStandalone
;
var
isRoot
=
!
this
.
isRootSeen
;
this
.
isRootSeen
=
true
;
var
body
=
program
.
body
;
for
(
var
i
=
0
l
=
body
.
length
;
i
<
l
;
i
+
+
)
{
var
current
=
body
[
i
]
strip
=
this
.
accept
(
current
)
;
if
(
!
strip
)
{
continue
;
}
var
_isPrevWhitespace
=
isPrevWhitespace
(
body
i
isRoot
)
_isNextWhitespace
=
isNextWhitespace
(
body
i
isRoot
)
openStandalone
=
strip
.
openStandalone
&
&
_isPrevWhitespace
closeStandalone
=
strip
.
closeStandalone
&
&
_isNextWhitespace
inlineStandalone
=
strip
.
inlineStandalone
&
&
_isPrevWhitespace
&
&
_isNextWhitespace
;
if
(
strip
.
close
)
{
omitRight
(
body
i
true
)
;
}
if
(
strip
.
open
)
{
omitLeft
(
body
i
true
)
;
}
if
(
doStandalone
&
&
inlineStandalone
)
{
omitRight
(
body
i
)
;
if
(
omitLeft
(
body
i
)
)
{
if
(
current
.
type
=
=
=
'
PartialStatement
'
)
{
current
.
indent
=
/
(
[
\
t
]
+
)
/
.
exec
(
body
[
i
-
1
]
.
original
)
[
1
]
;
}
}
}
if
(
doStandalone
&
&
openStandalone
)
{
omitRight
(
(
current
.
program
|
|
current
.
inverse
)
.
body
)
;
omitLeft
(
body
i
)
;
}
if
(
doStandalone
&
&
closeStandalone
)
{
omitRight
(
body
i
)
;
omitLeft
(
(
current
.
inverse
|
|
current
.
program
)
.
body
)
;
}
}
return
program
;
}
;
WhitespaceControl
.
prototype
.
BlockStatement
=
WhitespaceControl
.
prototype
.
DecoratorBlock
=
WhitespaceControl
.
prototype
.
PartialBlockStatement
=
function
(
block
)
{
this
.
accept
(
block
.
program
)
;
this
.
accept
(
block
.
inverse
)
;
var
program
=
block
.
program
|
|
block
.
inverse
inverse
=
block
.
program
&
&
block
.
inverse
firstInverse
=
inverse
lastInverse
=
inverse
;
if
(
inverse
&
&
inverse
.
chained
)
{
firstInverse
=
inverse
.
body
[
0
]
.
program
;
while
(
lastInverse
.
chained
)
{
lastInverse
=
lastInverse
.
body
[
lastInverse
.
body
.
length
-
1
]
.
program
;
}
}
var
strip
=
{
open
:
block
.
openStrip
.
open
close
:
block
.
closeStrip
.
close
openStandalone
:
isNextWhitespace
(
program
.
body
)
closeStandalone
:
isPrevWhitespace
(
(
firstInverse
|
|
program
)
.
body
)
}
;
if
(
block
.
openStrip
.
close
)
{
omitRight
(
program
.
body
null
true
)
;
}
if
(
inverse
)
{
var
inverseStrip
=
block
.
inverseStrip
;
if
(
inverseStrip
.
open
)
{
omitLeft
(
program
.
body
null
true
)
;
}
if
(
inverseStrip
.
close
)
{
omitRight
(
firstInverse
.
body
null
true
)
;
}
if
(
block
.
closeStrip
.
open
)
{
omitLeft
(
lastInverse
.
body
null
true
)
;
}
if
(
!
this
.
options
.
ignoreStandalone
&
&
isPrevWhitespace
(
program
.
body
)
&
&
isNextWhitespace
(
firstInverse
.
body
)
)
{
omitLeft
(
program
.
body
)
;
omitRight
(
firstInverse
.
body
)
;
}
}
else
if
(
block
.
closeStrip
.
open
)
{
omitLeft
(
program
.
body
null
true
)
;
}
return
strip
;
}
;
WhitespaceControl
.
prototype
.
Decorator
=
WhitespaceControl
.
prototype
.
MustacheStatement
=
function
(
mustache
)
{
return
mustache
.
strip
;
}
;
WhitespaceControl
.
prototype
.
PartialStatement
=
WhitespaceControl
.
prototype
.
CommentStatement
=
function
(
node
)
{
var
strip
=
node
.
strip
|
|
{
}
;
return
{
inlineStandalone
:
true
open
:
strip
.
open
close
:
strip
.
close
}
;
}
;
function
isPrevWhitespace
(
body
i
isRoot
)
{
if
(
i
=
=
=
undefined
)
{
i
=
body
.
length
;
}
var
prev
=
body
[
i
-
1
]
sibling
=
body
[
i
-
2
]
;
if
(
!
prev
)
{
return
isRoot
;
}
if
(
prev
.
type
=
=
=
'
ContentStatement
'
)
{
return
(
sibling
|
|
!
isRoot
?
/
\
r
?
\
n
\
s
*
?
/
:
/
(
^
|
\
r
?
\
n
)
\
s
*
?
/
)
.
test
(
prev
.
original
)
;
}
}
function
isNextWhitespace
(
body
i
isRoot
)
{
if
(
i
=
=
=
undefined
)
{
i
=
-
1
;
}
var
next
=
body
[
i
+
1
]
sibling
=
body
[
i
+
2
]
;
if
(
!
next
)
{
return
isRoot
;
}
if
(
next
.
type
=
=
=
'
ContentStatement
'
)
{
return
(
sibling
|
|
!
isRoot
?
/
^
\
s
*
?
\
r
?
\
n
/
:
/
^
\
s
*
?
(
\
r
?
\
n
|
)
/
)
.
test
(
next
.
original
)
;
}
}
function
omitRight
(
body
i
multiple
)
{
var
current
=
body
[
i
=
=
null
?
0
:
i
+
1
]
;
if
(
!
current
|
|
current
.
type
!
=
=
'
ContentStatement
'
|
|
!
multiple
&
&
current
.
rightStripped
)
{
return
;
}
var
original
=
current
.
value
;
current
.
value
=
current
.
value
.
replace
(
multiple
?
/
^
\
s
+
/
:
/
^
[
\
t
]
*
\
r
?
\
n
?
/
'
'
)
;
current
.
rightStripped
=
current
.
value
!
=
=
original
;
}
function
omitLeft
(
body
i
multiple
)
{
var
current
=
body
[
i
=
=
null
?
body
.
length
-
1
:
i
-
1
]
;
if
(
!
current
|
|
current
.
type
!
=
=
'
ContentStatement
'
|
|
!
multiple
&
&
current
.
leftStripped
)
{
return
;
}
var
original
=
current
.
value
;
current
.
value
=
current
.
value
.
replace
(
multiple
?
/
\
s
+
/
:
/
[
\
t
]
+
/
'
'
)
;
current
.
leftStripped
=
current
.
value
!
=
=
original
;
return
current
.
leftStripped
;
}
function
validateClose
(
open
close
)
{
close
=
close
.
path
?
close
.
path
.
original
:
close
;
if
(
open
.
path
.
original
!
=
=
close
)
{
var
errorNode
=
{
loc
:
open
.
path
.
loc
}
;
throw
new
Exception
(
open
.
path
.
original
+
"
doesn
'
t
match
"
+
close
errorNode
)
;
}
}
function
SourceLocation
(
source
locInfo
)
{
this
.
source
=
source
;
this
.
start
=
{
line
:
locInfo
.
first_line
column
:
locInfo
.
first_column
}
;
this
.
end
=
{
line
:
locInfo
.
last_line
column
:
locInfo
.
last_column
}
;
}
function
id
(
token
)
{
if
(
/
^
\
[
.
*
\
]
/
.
test
(
token
)
)
{
return
token
.
substr
(
1
token
.
length
-
2
)
;
}
else
{
return
token
;
}
}
function
stripFlags
(
open
close
)
{
return
{
open
:
open
.
charAt
(
2
)
=
=
=
'
~
'
close
:
close
.
charAt
(
close
.
length
-
3
)
=
=
=
'
~
'
}
;
}
function
stripComment
(
comment
)
{
return
comment
.
replace
(
/
^
\
{
\
{
~
?
\
!
-
?
-
?
/
'
'
)
.
replace
(
/
-
?
-
?
~
?
\
}
\
}
/
'
'
)
;
}
function
preparePath
(
data
parts
loc
)
{
loc
=
this
.
locInfo
(
loc
)
;
var
original
=
data
?
'
'
:
'
'
dig
=
[
]
depth
=
0
;
for
(
var
i
=
0
l
=
parts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
parts
[
i
]
.
part
isLiteral
=
parts
[
i
]
.
original
!
=
=
part
;
original
+
=
(
parts
[
i
]
.
separator
|
|
'
'
)
+
part
;
if
(
!
isLiteral
&
&
(
part
=
=
=
'
.
.
'
|
|
part
=
=
=
'
.
'
|
|
part
=
=
=
'
this
'
)
)
{
if
(
dig
.
length
>
0
)
{
throw
new
Exception
(
'
Invalid
path
:
'
+
original
{
loc
:
loc
}
)
;
}
else
if
(
part
=
=
=
'
.
.
'
)
{
depth
+
+
;
}
}
else
{
dig
.
push
(
part
)
;
}
}
return
{
type
:
'
PathExpression
'
data
:
data
depth
:
depth
parts
:
dig
original
:
original
loc
:
loc
}
;
}
function
prepareMustache
(
path
params
hash
open
strip
locInfo
)
{
var
escapeFlag
=
open
.
charAt
(
3
)
|
|
open
.
charAt
(
2
)
escaped
=
escapeFlag
!
=
=
'
{
'
&
&
escapeFlag
!
=
=
'
&
'
;
var
decorator
=
/
\
*
/
.
test
(
open
)
;
return
{
type
:
decorator
?
'
Decorator
'
:
'
MustacheStatement
'
path
:
path
params
:
params
hash
:
hash
escaped
:
escaped
strip
:
strip
loc
:
this
.
locInfo
(
locInfo
)
}
;
}
function
prepareRawBlock
(
openRawBlock
contents
close
locInfo
)
{
validateClose
(
openRawBlock
close
)
;
locInfo
=
this
.
locInfo
(
locInfo
)
;
var
program
=
{
type
:
'
Program
'
body
:
contents
strip
:
{
}
loc
:
locInfo
}
;
return
{
type
:
'
BlockStatement
'
path
:
openRawBlock
.
path
params
:
openRawBlock
.
params
hash
:
openRawBlock
.
hash
program
:
program
openStrip
:
{
}
inverseStrip
:
{
}
closeStrip
:
{
}
loc
:
locInfo
}
;
}
function
prepareBlock
(
openBlock
program
inverseAndProgram
close
inverted
locInfo
)
{
if
(
close
&
&
close
.
path
)
{
validateClose
(
openBlock
close
)
;
}
var
decorator
=
/
\
*
/
.
test
(
openBlock
.
open
)
;
program
.
blockParams
=
openBlock
.
blockParams
;
var
inverse
=
void
0
inverseStrip
=
void
0
;
if
(
inverseAndProgram
)
{
if
(
decorator
)
{
throw
new
Exception
(
'
Unexpected
inverse
block
on
decorator
'
inverseAndProgram
)
;
}
if
(
inverseAndProgram
.
chain
)
{
inverseAndProgram
.
program
.
body
[
0
]
.
closeStrip
=
close
.
strip
;
}
inverseStrip
=
inverseAndProgram
.
strip
;
inverse
=
inverseAndProgram
.
program
;
}
if
(
inverted
)
{
inverted
=
inverse
;
inverse
=
program
;
program
=
inverted
;
}
return
{
type
:
decorator
?
'
DecoratorBlock
'
:
'
BlockStatement
'
path
:
openBlock
.
path
params
:
openBlock
.
params
hash
:
openBlock
.
hash
program
:
program
inverse
:
inverse
openStrip
:
openBlock
.
strip
inverseStrip
:
inverseStrip
closeStrip
:
close
&
&
close
.
strip
loc
:
this
.
locInfo
(
locInfo
)
}
;
}
function
prepareProgram
(
statements
loc
)
{
if
(
!
loc
&
&
statements
.
length
)
{
var
firstLoc
=
statements
[
0
]
.
loc
lastLoc
=
statements
[
statements
.
length
-
1
]
.
loc
;
if
(
firstLoc
&
&
lastLoc
)
{
loc
=
{
source
:
firstLoc
.
source
start
:
{
line
:
firstLoc
.
start
.
line
column
:
firstLoc
.
start
.
column
}
end
:
{
line
:
lastLoc
.
end
.
line
column
:
lastLoc
.
end
.
column
}
}
;
}
}
return
{
type
:
'
Program
'
body
:
statements
strip
:
{
}
loc
:
loc
}
;
}
function
preparePartialBlock
(
open
program
close
locInfo
)
{
validateClose
(
open
close
)
;
return
{
type
:
'
PartialBlockStatement
'
name
:
open
.
path
params
:
open
.
params
hash
:
open
.
hash
program
:
program
openStrip
:
open
.
strip
closeStrip
:
close
&
&
close
.
strip
loc
:
this
.
locInfo
(
locInfo
)
}
;
}
var
Helpers
=
Object
.
freeze
(
{
SourceLocation
:
SourceLocation
id
:
id
stripFlags
:
stripFlags
stripComment
:
stripComment
preparePath
:
preparePath
prepareMustache
:
prepareMustache
prepareRawBlock
:
prepareRawBlock
prepareBlock
:
prepareBlock
prepareProgram
:
prepareProgram
preparePartialBlock
:
preparePartialBlock
}
)
;
function
extend
(
obj
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
for
(
var
key
in
arguments
[
i
]
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
arguments
[
i
]
key
)
)
{
obj
[
key
]
=
arguments
[
i
]
[
key
]
;
}
}
}
return
obj
;
}
var
toString
=
Object
.
prototype
.
toString
;
var
isFunction
=
function
(
value
)
{
return
typeof
value
=
=
=
'
function
'
;
}
;
if
(
isFunction
(
/
x
/
)
)
{
isFunction
=
function
(
value
)
{
return
typeof
value
=
=
=
'
function
'
&
&
toString
.
call
(
value
)
=
=
=
'
[
object
Function
]
'
;
}
;
}
var
yy
=
{
}
;
extend
(
yy
Helpers
)
;
function
parse
(
input
options
)
{
if
(
input
.
type
=
=
=
'
Program
'
)
{
return
input
;
}
handlebars
.
yy
=
yy
;
yy
.
locInfo
=
function
(
locInfo
)
{
return
new
yy
.
SourceLocation
(
options
&
&
options
.
srcName
locInfo
)
;
}
;
var
strip
=
new
WhitespaceControl
(
options
)
;
return
strip
.
accept
(
handlebars
.
parse
(
input
)
)
;
}
exports
.
parser
=
handlebars
;
exports
.
parse
=
parse
;
}
)
;
enifed
(
'
node
-
module
'
[
'
exports
'
]
function
(
_exports
)
{
var
IS_NODE
=
typeof
module
=
=
=
'
object
'
&
&
typeof
module
.
require
=
=
=
'
function
'
;
if
(
IS_NODE
)
{
_exports
.
require
=
module
.
require
;
_exports
.
module
=
module
;
_exports
.
IS_NODE
=
IS_NODE
;
}
else
{
_exports
.
require
=
null
;
_exports
.
module
=
null
;
_exports
.
IS_NODE
=
IS_NODE
;
}
}
)
;
enifed
(
"
route
-
recognizer
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
createObject
=
Object
.
create
;
function
createMap
(
)
{
var
map
=
createObject
(
null
)
;
map
[
"
__
"
]
=
undefined
;
delete
map
[
"
__
"
]
;
return
map
;
}
var
Target
=
function
Target
(
path
matcher
delegate
)
{
this
.
path
=
path
;
this
.
matcher
=
matcher
;
this
.
delegate
=
delegate
;
}
;
Target
.
prototype
.
to
=
function
to
(
target
callback
)
{
var
delegate
=
this
.
delegate
;
if
(
delegate
&
&
delegate
.
willAddRoute
)
{
target
=
delegate
.
willAddRoute
(
this
.
matcher
.
target
target
)
;
}
this
.
matcher
.
add
(
this
.
path
target
)
;
if
(
callback
)
{
if
(
callback
.
length
=
=
=
0
)
{
throw
new
Error
(
"
You
must
have
an
argument
in
the
function
passed
to
to
"
)
;
}
this
.
matcher
.
addChild
(
this
.
path
target
callback
this
.
delegate
)
;
}
}
;
var
Matcher
=
function
Matcher
(
target
)
{
this
.
routes
=
createMap
(
)
;
this
.
children
=
createMap
(
)
;
this
.
target
=
target
;
}
;
Matcher
.
prototype
.
add
=
function
add
(
path
target
)
{
this
.
routes
[
path
]
=
target
;
}
;
Matcher
.
prototype
.
addChild
=
function
addChild
(
path
target
callback
delegate
)
{
var
matcher
=
new
Matcher
(
target
)
;
this
.
children
[
path
]
=
matcher
;
var
match
=
generateMatch
(
path
matcher
delegate
)
;
if
(
delegate
&
&
delegate
.
contextEntered
)
{
delegate
.
contextEntered
(
target
match
)
;
}
callback
(
match
)
;
}
;
function
generateMatch
(
startingPath
matcher
delegate
)
{
function
match
(
path
callback
)
{
var
fullPath
=
startingPath
+
path
;
if
(
callback
)
{
callback
(
generateMatch
(
fullPath
matcher
delegate
)
)
;
}
else
{
return
new
Target
(
fullPath
matcher
delegate
)
;
}
}
return
match
;
}
function
addRoute
(
routeArray
path
handler
)
{
var
len
=
0
;
for
(
var
i
=
0
;
i
<
routeArray
.
length
;
i
+
+
)
{
len
+
=
routeArray
[
i
]
.
path
.
length
;
}
path
=
path
.
substr
(
len
)
;
var
route
=
{
path
:
path
handler
:
handler
}
;
routeArray
.
push
(
route
)
;
}
function
eachRoute
(
baseRoute
matcher
callback
binding
)
{
var
routes
=
matcher
.
routes
;
var
paths
=
Object
.
keys
(
routes
)
;
for
(
var
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
var
path
=
paths
[
i
]
;
var
routeArray
=
baseRoute
.
slice
(
)
;
addRoute
(
routeArray
path
routes
[
path
]
)
;
var
nested
=
matcher
.
children
[
path
]
;
if
(
nested
)
{
eachRoute
(
routeArray
nested
callback
binding
)
;
}
else
{
callback
.
call
(
binding
routeArray
)
;
}
}
}
var
map
=
function
(
callback
addRouteCallback
)
{
var
matcher
=
new
Matcher
(
)
;
callback
(
generateMatch
(
"
"
matcher
this
.
delegate
)
)
;
eachRoute
(
[
]
matcher
function
(
routes
)
{
if
(
addRouteCallback
)
{
addRouteCallback
(
this
routes
)
;
}
else
{
this
.
add
(
routes
)
;
}
}
this
)
;
}
;
function
normalizePath
(
path
)
{
return
path
.
split
(
"
/
"
)
.
map
(
normalizeSegment
)
.
join
(
"
/
"
)
;
}
var
SEGMENT_RESERVED_CHARS
=
/
%
|
\
/
/
g
;
function
normalizeSegment
(
segment
)
{
if
(
segment
.
length
<
3
|
|
segment
.
indexOf
(
"
%
"
)
=
=
=
-
1
)
{
return
segment
;
}
return
decodeURIComponent
(
segment
)
.
replace
(
SEGMENT_RESERVED_CHARS
encodeURIComponent
)
;
}
var
PATH_SEGMENT_ENCODINGS
=
/
%
(
?
:
2
(
?
:
4
|
6
|
B
|
C
)
|
3
(
?
:
B
|
D
|
A
)
|
40
)
/
g
;
function
encodePathSegment
(
str
)
{
return
encodeURIComponent
(
str
)
.
replace
(
PATH_SEGMENT_ENCODINGS
decodeURIComponent
)
;
}
var
escapeRegex
=
/
(
\
/
|
\
.
|
\
*
|
\
+
|
\
?
|
\
|
|
\
(
|
\
)
|
\
[
|
\
]
|
\
{
|
\
}
|
\
\
)
/
g
;
var
isArray
=
Array
.
isArray
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
getParam
(
params
key
)
{
if
(
typeof
params
!
=
=
"
object
"
|
|
params
=
=
=
null
)
{
throw
new
Error
(
"
You
must
pass
an
object
as
the
second
argument
to
generate
.
"
)
;
}
if
(
!
hasOwnProperty
.
call
(
params
key
)
)
{
throw
new
Error
(
"
You
must
provide
param
"
+
key
+
"
to
generate
.
"
)
;
}
var
value
=
params
[
key
]
;
var
str
=
typeof
value
=
=
=
"
string
"
?
value
:
"
"
+
value
;
if
(
str
.
length
=
=
=
0
)
{
throw
new
Error
(
"
You
must
provide
a
param
"
+
key
+
"
.
"
)
;
}
return
str
;
}
var
eachChar
=
[
]
;
eachChar
[
0
]
=
function
(
segment
currentState
)
{
var
state
=
currentState
;
var
value
=
segment
.
value
;
for
(
var
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
var
ch
=
value
.
charCodeAt
(
i
)
;
state
=
state
.
put
(
ch
false
false
)
;
}
return
state
;
}
;
eachChar
[
1
]
=
function
(
_
currentState
)
{
return
currentState
.
put
(
47
true
true
)
;
}
;
eachChar
[
2
]
=
function
(
_
currentState
)
{
return
currentState
.
put
(
-
1
false
true
)
;
}
;
eachChar
[
4
]
=
function
(
_
currentState
)
{
return
currentState
;
}
;
var
regex
=
[
]
;
regex
[
0
]
=
function
(
segment
)
{
return
segment
.
value
.
replace
(
escapeRegex
"
\
\
1
"
)
;
}
;
regex
[
1
]
=
function
(
)
{
return
"
(
[
^
/
]
+
)
"
;
}
;
regex
[
2
]
=
function
(
)
{
return
"
(
.
+
)
"
;
}
;
regex
[
4
]
=
function
(
)
{
return
"
"
;
}
;
var
generate
=
[
]
;
generate
[
0
]
=
function
(
segment
)
{
return
segment
.
value
;
}
;
generate
[
1
]
=
function
(
segment
params
)
{
var
value
=
getParam
(
params
segment
.
value
)
;
if
(
RouteRecognizer
.
ENCODE_AND_DECODE_PATH_SEGMENTS
)
{
return
encodePathSegment
(
value
)
;
}
else
{
return
value
;
}
}
;
generate
[
2
]
=
function
(
segment
params
)
{
return
getParam
(
params
segment
.
value
)
;
}
;
generate
[
4
]
=
function
(
)
{
return
"
"
;
}
;
var
EmptyObject
=
Object
.
freeze
(
{
}
)
;
var
EmptyArray
=
Object
.
freeze
(
[
]
)
;
function
parse
(
segments
route
types
)
{
if
(
route
.
length
>
0
&
&
route
.
charCodeAt
(
0
)
=
=
=
47
)
{
route
=
route
.
substr
(
1
)
;
}
var
parts
=
route
.
split
(
"
/
"
)
;
var
names
=
undefined
;
var
shouldDecodes
=
undefined
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
var
part
=
parts
[
i
]
;
var
flags
=
0
;
var
type
=
0
;
if
(
part
=
=
=
"
"
)
{
type
=
4
;
}
else
if
(
part
.
charCodeAt
(
0
)
=
=
=
58
)
{
type
=
1
;
}
else
if
(
part
.
charCodeAt
(
0
)
=
=
=
42
)
{
type
=
2
;
}
else
{
type
=
0
;
}
flags
=
2
<
<
type
;
if
(
flags
&
12
)
{
part
=
part
.
slice
(
1
)
;
names
=
names
|
|
[
]
;
names
.
push
(
part
)
;
shouldDecodes
=
shouldDecodes
|
|
[
]
;
shouldDecodes
.
push
(
(
flags
&
4
)
!
=
=
0
)
;
}
if
(
flags
&
14
)
{
types
[
type
]
+
+
;
}
segments
.
push
(
{
type
:
type
value
:
normalizeSegment
(
part
)
}
)
;
}
return
{
names
:
names
|
|
EmptyArray
shouldDecodes
:
shouldDecodes
|
|
EmptyArray
}
;
}
function
isEqualCharSpec
(
spec
char
negate
)
{
return
spec
.
char
=
=
=
char
&
&
spec
.
negate
=
=
=
negate
;
}
var
State
=
function
State
(
states
id
char
negate
repeat
)
{
this
.
states
=
states
;
this
.
id
=
id
;
this
.
char
=
char
;
this
.
negate
=
negate
;
this
.
nextStates
=
repeat
?
id
:
null
;
this
.
pattern
=
"
"
;
this
.
_regex
=
undefined
;
this
.
handlers
=
undefined
;
this
.
types
=
undefined
;
}
;
State
.
prototype
.
regex
=
function
regex
1
(
)
{
if
(
!
this
.
_regex
)
{
this
.
_regex
=
new
RegExp
(
this
.
pattern
)
;
}
return
this
.
_regex
;
}
;
State
.
prototype
.
get
=
function
get
(
char
negate
)
{
var
this
1
=
this
;
var
nextStates
=
this
.
nextStates
;
if
(
nextStates
=
=
=
null
)
{
return
;
}
if
(
isArray
(
nextStates
)
)
{
for
(
var
i
=
0
;
i
<
nextStates
.
length
;
i
+
+
)
{
var
child
=
this
1
.
states
[
nextStates
[
i
]
]
;
if
(
isEqualCharSpec
(
child
char
negate
)
)
{
return
child
;
}
}
}
else
{
var
child
1
=
this
.
states
[
nextStates
]
;
if
(
isEqualCharSpec
(
child
1
char
negate
)
)
{
return
child
1
;
}
}
}
;
State
.
prototype
.
put
=
function
put
(
char
negate
repeat
)
{
var
state
;
if
(
state
=
this
.
get
(
char
negate
)
)
{
return
state
;
}
var
states
=
this
.
states
;
state
=
new
State
(
states
states
.
length
char
negate
repeat
)
;
states
[
states
.
length
]
=
state
;
if
(
this
.
nextStates
=
=
null
)
{
this
.
nextStates
=
state
.
id
;
}
else
if
(
isArray
(
this
.
nextStates
)
)
{
this
.
nextStates
.
push
(
state
.
id
)
;
}
else
{
this
.
nextStates
=
[
this
.
nextStates
state
.
id
]
;
}
return
state
;
}
;
State
.
prototype
.
match
=
function
match
(
ch
)
{
var
this
1
=
this
;
var
nextStates
=
this
.
nextStates
;
if
(
!
nextStates
)
{
return
[
]
;
}
var
returned
=
[
]
;
if
(
isArray
(
nextStates
)
)
{
for
(
var
i
=
0
;
i
<
nextStates
.
length
;
i
+
+
)
{
var
child
=
this
1
.
states
[
nextStates
[
i
]
]
;
if
(
isMatch
(
child
ch
)
)
{
returned
.
push
(
child
)
;
}
}
}
else
{
var
child
1
=
this
.
states
[
nextStates
]
;
if
(
isMatch
(
child
1
ch
)
)
{
returned
.
push
(
child
1
)
;
}
}
return
returned
;
}
;
function
isMatch
(
spec
char
)
{
return
spec
.
negate
?
spec
.
char
!
=
=
char
&
&
spec
.
char
!
=
=
-
1
:
spec
.
char
=
=
=
char
|
|
spec
.
char
=
=
=
-
1
;
}
function
sortSolutions
(
states
)
{
return
states
.
sort
(
function
(
a
b
)
{
var
ref
=
a
.
types
|
|
[
0
0
0
]
;
var
astatics
=
ref
[
0
]
;
var
adynamics
=
ref
[
1
]
;
var
astars
=
ref
[
2
]
;
var
ref
1
=
b
.
types
|
|
[
0
0
0
]
;
var
bstatics
=
ref
1
[
0
]
;
var
bdynamics
=
ref
1
[
1
]
;
var
bstars
=
ref
1
[
2
]
;
if
(
astars
!
=
=
bstars
)
{
return
astars
-
bstars
;
}
if
(
astars
)
{
if
(
astatics
!
=
=
bstatics
)
{
return
bstatics
-
astatics
;
}
if
(
adynamics
!
=
=
bdynamics
)
{
return
bdynamics
-
adynamics
;
}
}
if
(
adynamics
!
=
=
bdynamics
)
{
return
adynamics
-
bdynamics
;
}
if
(
astatics
!
=
=
bstatics
)
{
return
bstatics
-
astatics
;
}
return
0
;
}
)
;
}
function
recognizeChar
(
states
ch
)
{
var
nextStates
=
[
]
;
for
(
var
i
=
0
l
=
states
.
length
;
i
<
l
;
i
+
+
)
{
var
state
=
states
[
i
]
;
nextStates
=
nextStates
.
concat
(
state
.
match
(
ch
)
)
;
}
return
nextStates
;
}
var
RecognizeResults
=
function
RecognizeResults
(
queryParams
)
{
this
.
length
=
0
;
this
.
queryParams
=
queryParams
|
|
{
}
;
}
;
RecognizeResults
.
prototype
.
splice
=
Array
.
prototype
.
splice
;
RecognizeResults
.
prototype
.
slice
=
Array
.
prototype
.
slice
;
RecognizeResults
.
prototype
.
push
=
Array
.
prototype
.
push
;
function
findHandler
(
state
originalPath
queryParams
)
{
var
handlers
=
state
.
handlers
;
var
regex
=
state
.
regex
(
)
;
if
(
!
regex
|
|
!
handlers
)
{
throw
new
Error
(
"
state
not
initialized
"
)
;
}
var
captures
=
originalPath
.
match
(
regex
)
;
var
currentCapture
=
1
;
var
result
=
new
RecognizeResults
(
queryParams
)
;
result
.
length
=
handlers
.
length
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
var
handler
=
handlers
[
i
]
;
var
names
=
handler
.
names
;
var
shouldDecodes
=
handler
.
shouldDecodes
;
var
params
=
EmptyObject
;
var
isDynamic
=
false
;
if
(
names
!
=
=
EmptyArray
&
&
shouldDecodes
!
=
=
EmptyArray
)
{
for
(
var
j
=
0
;
j
<
names
.
length
;
j
+
+
)
{
isDynamic
=
true
;
var
name
=
names
[
j
]
;
var
capture
=
captures
&
&
captures
[
currentCapture
+
+
]
;
if
(
params
=
=
=
EmptyObject
)
{
params
=
{
}
;
}
if
(
RouteRecognizer
.
ENCODE_AND_DECODE_PATH_SEGMENTS
&
&
shouldDecodes
[
j
]
)
{
params
[
name
]
=
capture
&
&
decodeURIComponent
(
capture
)
;
}
else
{
params
[
name
]
=
capture
;
}
}
}
result
[
i
]
=
{
handler
:
handler
.
handler
params
:
params
isDynamic
:
isDynamic
}
;
}
return
result
;
}
function
decodeQueryParamPart
(
part
)
{
part
=
part
.
replace
(
/
\
+
/
gm
"
%
20
"
)
;
var
result
;
try
{
result
=
decodeURIComponent
(
part
)
;
}
catch
(
error
)
{
result
=
"
"
;
}
return
result
;
}
var
RouteRecognizer
=
function
RouteRecognizer
(
)
{
this
.
names
=
createMap
(
)
;
var
states
=
[
]
;
var
state
=
new
State
(
states
0
-
1
true
false
)
;
states
[
0
]
=
state
;
this
.
states
=
states
;
this
.
rootState
=
state
;
}
;
RouteRecognizer
.
prototype
.
add
=
function
add
(
routes
options
)
{
var
currentState
=
this
.
rootState
;
var
pattern
=
"
^
"
;
var
types
=
[
0
0
0
]
;
var
handlers
=
new
Array
(
routes
.
length
)
;
var
allSegments
=
[
]
;
var
isEmpty
=
true
;
var
j
=
0
;
for
(
var
i
=
0
;
i
<
routes
.
length
;
i
+
+
)
{
var
route
=
routes
[
i
]
;
var
ref
=
parse
(
allSegments
route
.
path
types
)
;
var
names
=
ref
.
names
;
var
shouldDecodes
=
ref
.
shouldDecodes
;
for
(
;
j
<
allSegments
.
length
;
j
+
+
)
{
var
segment
=
allSegments
[
j
]
;
if
(
segment
.
type
=
=
=
4
)
{
continue
;
}
isEmpty
=
false
;
currentState
=
currentState
.
put
(
47
false
false
)
;
pattern
+
=
"
/
"
;
currentState
=
eachChar
[
segment
.
type
]
(
segment
currentState
)
;
pattern
+
=
regex
[
segment
.
type
]
(
segment
)
;
}
handlers
[
i
]
=
{
handler
:
route
.
handler
names
:
names
shouldDecodes
:
shouldDecodes
}
;
}
if
(
isEmpty
)
{
currentState
=
currentState
.
put
(
47
false
false
)
;
pattern
+
=
"
/
"
;
}
currentState
.
handlers
=
handlers
;
currentState
.
pattern
=
pattern
+
"
"
;
currentState
.
types
=
types
;
var
name
;
if
(
typeof
options
=
=
=
"
object
"
&
&
options
!
=
=
null
&
&
options
.
as
)
{
name
=
options
.
as
;
}
if
(
name
)
{
this
.
names
[
name
]
=
{
segments
:
allSegments
handlers
:
handlers
}
;
}
}
;
RouteRecognizer
.
prototype
.
handlersFor
=
function
handlersFor
(
name
)
{
var
route
=
this
.
names
[
name
]
;
if
(
!
route
)
{
throw
new
Error
(
"
There
is
no
route
named
"
+
name
)
;
}
var
result
=
new
Array
(
route
.
handlers
.
length
)
;
for
(
var
i
=
0
;
i
<
route
.
handlers
.
length
;
i
+
+
)
{
var
handler
=
route
.
handlers
[
i
]
;
result
[
i
]
=
handler
;
}
return
result
;
}
;
RouteRecognizer
.
prototype
.
hasRoute
=
function
hasRoute
(
name
)
{
return
!
!
this
.
names
[
name
]
;
}
;
RouteRecognizer
.
prototype
.
generate
=
function
generate
1
(
name
params
)
{
var
route
=
this
.
names
[
name
]
;
var
output
=
"
"
;
if
(
!
route
)
{
throw
new
Error
(
"
There
is
no
route
named
"
+
name
)
;
}
var
segments
=
route
.
segments
;
for
(
var
i
=
0
;
i
<
segments
.
length
;
i
+
+
)
{
var
segment
=
segments
[
i
]
;
if
(
segment
.
type
=
=
=
4
)
{
continue
;
}
output
+
=
"
/
"
;
output
+
=
generate
[
segment
.
type
]
(
segment
params
)
;
}
if
(
output
.
charAt
(
0
)
!
=
=
"
/
"
)
{
output
=
"
/
"
+
output
;
}
if
(
params
&
&
params
.
queryParams
)
{
output
+
=
this
.
generateQueryString
(
params
.
queryParams
)
;
}
return
output
;
}
;
RouteRecognizer
.
prototype
.
generateQueryString
=
function
generateQueryString
(
params
)
{
var
pairs
=
[
]
;
var
keys
=
Object
.
keys
(
params
)
;
keys
.
sort
(
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
params
[
key
]
;
if
(
value
=
=
null
)
{
continue
;
}
var
pair
=
encodeURIComponent
(
key
)
;
if
(
isArray
(
value
)
)
{
for
(
var
j
=
0
;
j
<
value
.
length
;
j
+
+
)
{
var
arrayPair
=
key
+
"
[
]
"
+
"
=
"
+
encodeURIComponent
(
value
[
j
]
)
;
pairs
.
push
(
arrayPair
)
;
}
}
else
{
pair
+
=
"
=
"
+
encodeURIComponent
(
value
)
;
pairs
.
push
(
pair
)
;
}
}
if
(
pairs
.
length
=
=
=
0
)
{
return
"
"
;
}
return
"
?
"
+
pairs
.
join
(
"
&
"
)
;
}
;
RouteRecognizer
.
prototype
.
parseQueryString
=
function
parseQueryString
(
queryString
)
{
var
pairs
=
queryString
.
split
(
"
&
"
)
;
var
queryParams
=
{
}
;
for
(
var
i
=
0
;
i
<
pairs
.
length
;
i
+
+
)
{
var
pair
=
pairs
[
i
]
.
split
(
"
=
"
)
key
=
decodeQueryParamPart
(
pair
[
0
]
)
keyLength
=
key
.
length
isArray
=
false
value
=
void
0
;
if
(
pair
.
length
=
=
=
1
)
{
value
=
"
true
"
;
}
else
{
if
(
keyLength
>
2
&
&
key
.
slice
(
keyLength
-
2
)
=
=
=
"
[
]
"
)
{
isArray
=
true
;
key
=
key
.
slice
(
0
keyLength
-
2
)
;
if
(
!
queryParams
[
key
]
)
{
queryParams
[
key
]
=
[
]
;
}
}
value
=
pair
[
1
]
?
decodeQueryParamPart
(
pair
[
1
]
)
:
"
"
;
}
if
(
isArray
)
{
queryParams
[
key
]
.
push
(
value
)
;
}
else
{
queryParams
[
key
]
=
value
;
}
}
return
queryParams
;
}
;
RouteRecognizer
.
prototype
.
recognize
=
function
recognize
(
path
)
{
var
results
;
var
states
=
[
this
.
rootState
]
;
var
queryParams
=
{
}
;
var
isSlashDropped
=
false
;
var
hashStart
=
path
.
indexOf
(
"
#
"
)
;
if
(
hashStart
!
=
=
-
1
)
{
path
=
path
.
substr
(
0
hashStart
)
;
}
var
queryStart
=
path
.
indexOf
(
"
?
"
)
;
if
(
queryStart
!
=
=
-
1
)
{
var
queryString
=
path
.
substr
(
queryStart
+
1
path
.
length
)
;
path
=
path
.
substr
(
0
queryStart
)
;
queryParams
=
this
.
parseQueryString
(
queryString
)
;
}
if
(
path
.
charAt
(
0
)
!
=
=
"
/
"
)
{
path
=
"
/
"
+
path
;
}
var
originalPath
=
path
;
if
(
RouteRecognizer
.
ENCODE_AND_DECODE_PATH_SEGMENTS
)
{
path
=
normalizePath
(
path
)
;
}
else
{
path
=
decodeURI
(
path
)
;
originalPath
=
decodeURI
(
originalPath
)
;
}
var
pathLen
=
path
.
length
;
if
(
pathLen
>
1
&
&
path
.
charAt
(
pathLen
-
1
)
=
=
=
"
/
"
)
{
path
=
path
.
substr
(
0
pathLen
-
1
)
;
originalPath
=
originalPath
.
substr
(
0
originalPath
.
length
-
1
)
;
isSlashDropped
=
true
;
}
for
(
var
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
states
=
recognizeChar
(
states
path
.
charCodeAt
(
i
)
)
;
if
(
!
states
.
length
)
{
break
;
}
}
var
solutions
=
[
]
;
for
(
var
i
1
=
0
;
i
1
<
states
.
length
;
i
1
+
+
)
{
if
(
states
[
i
1
]
.
handlers
)
{
solutions
.
push
(
states
[
i
1
]
)
;
}
}
states
=
sortSolutions
(
solutions
)
;
var
state
=
solutions
[
0
]
;
if
(
state
&
&
state
.
handlers
)
{
if
(
isSlashDropped
&
&
state
.
pattern
&
&
state
.
pattern
.
slice
(
-
5
)
=
=
=
"
(
.
+
)
"
)
{
originalPath
=
originalPath
+
"
/
"
;
}
results
=
findHandler
(
state
originalPath
queryParams
)
;
}
return
results
;
}
;
RouteRecognizer
.
VERSION
=
"
0
.
3
.
3
"
;
RouteRecognizer
.
ENCODE_AND_DECODE_PATH_SEGMENTS
=
true
;
RouteRecognizer
.
Normalizer
=
{
normalizeSegment
:
normalizeSegment
normalizePath
:
normalizePath
encodePathSegment
:
encodePathSegment
}
;
RouteRecognizer
.
prototype
.
map
=
map
;
exports
.
default
=
RouteRecognizer
;
}
)
;
enifed
(
'
router
'
[
'
exports
'
'
ember
-
babel
'
'
route
-
recognizer
'
'
rsvp
'
]
function
(
exports
_emberBabel
_routeRecognizer
_rsvp
)
{
'
use
strict
'
;
exports
.
Transition
=
undefined
;
var
slice
=
Array
.
prototype
.
slice
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
isPromise
(
obj
)
{
return
(
typeof
obj
=
=
=
'
object
'
&
&
obj
!
=
=
null
|
|
typeof
obj
=
=
=
'
function
'
)
&
&
typeof
obj
.
then
=
=
=
'
function
'
;
}
function
merge
(
hash
other
)
{
for
(
var
prop
in
other
)
{
if
(
hasOwnProperty
.
call
(
other
prop
)
)
{
hash
[
prop
]
=
other
[
prop
]
;
}
}
}
function
extractQueryParams
(
array
)
{
var
len
=
array
&
&
array
.
length
head
=
void
0
queryParams
=
void
0
;
if
(
len
&
&
len
>
0
&
&
array
[
len
-
1
]
&
&
array
[
len
-
1
]
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
array
[
len
-
1
]
.
queryParams
;
head
=
slice
.
call
(
array
0
len
-
1
)
;
return
[
head
queryParams
]
;
}
else
{
return
[
array
null
]
;
}
}
function
coerceQueryParamsToString
(
queryParams
)
{
for
(
var
key
in
queryParams
)
{
if
(
typeof
queryParams
[
key
]
=
=
=
'
number
'
)
{
queryParams
[
key
]
=
'
'
+
queryParams
[
key
]
;
}
else
if
(
Array
.
isArray
(
queryParams
[
key
]
)
)
{
for
(
var
i
=
0
l
=
queryParams
[
key
]
.
length
;
i
<
l
;
i
+
+
)
{
queryParams
[
key
]
[
i
]
=
'
'
+
queryParams
[
key
]
[
i
]
;
}
}
}
}
function
_log
(
router
sequence
msg
)
{
if
(
!
router
.
log
)
{
return
;
}
if
(
arguments
.
length
=
=
=
3
)
{
router
.
log
(
'
Transition
#
'
+
sequence
+
'
:
'
+
msg
)
;
}
else
{
msg
=
sequence
;
router
.
log
(
msg
)
;
}
}
function
isParam
(
object
)
{
return
typeof
object
=
=
=
'
string
'
|
|
object
instanceof
String
|
|
typeof
object
=
=
=
'
number
'
|
|
object
instanceof
Number
;
}
function
forEach
(
array
callback
)
{
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
&
&
false
!
=
=
callback
(
array
[
i
]
)
;
i
+
+
)
{
}
}
function
_trigger
(
router
handlerInfos
ignoreFailure
args
)
{
if
(
router
.
triggerEvent
)
{
router
.
triggerEvent
(
handlerInfos
ignoreFailure
args
)
;
return
;
}
var
name
=
args
.
shift
(
)
;
if
(
!
handlerInfos
)
{
if
(
ignoreFailure
)
{
return
;
}
throw
new
Error
(
"
Could
not
trigger
event
'
"
+
name
+
"
'
.
There
are
no
active
handlers
"
)
;
}
var
eventWasHandled
=
false
;
function
delayedEvent
(
name
args
handler
)
{
handler
.
events
[
name
]
.
apply
(
handler
args
)
;
}
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
handlerInfo
=
handlerInfos
[
i
]
handler
=
handlerInfo
.
handler
;
if
(
!
handler
)
{
handlerInfo
.
handlerPromise
.
then
(
delayedEvent
.
bind
(
null
name
args
)
)
;
continue
;
}
if
(
handler
.
events
&
&
handler
.
events
[
name
]
)
{
if
(
handler
.
events
[
name
]
.
apply
(
handler
args
)
=
=
=
true
)
{
eventWasHandled
=
true
;
}
else
{
return
;
}
}
}
if
(
name
=
=
=
'
error
'
&
&
args
[
0
]
.
name
=
=
=
'
UnrecognizedURLError
'
)
{
throw
args
[
0
]
;
}
else
if
(
!
eventWasHandled
&
&
!
ignoreFailure
)
{
throw
new
Error
(
"
Nothing
handled
the
event
'
"
+
name
+
"
'
.
"
)
;
}
}
function
getChangelist
(
oldObject
newObject
)
{
var
key
=
void
0
;
var
results
=
{
all
:
{
}
changed
:
{
}
removed
:
{
}
}
;
merge
(
results
.
all
newObject
)
;
var
didChange
=
false
;
coerceQueryParamsToString
(
oldObject
)
;
coerceQueryParamsToString
(
newObject
)
;
for
(
key
in
oldObject
)
{
if
(
hasOwnProperty
.
call
(
oldObject
key
)
)
{
if
(
!
hasOwnProperty
.
call
(
newObject
key
)
)
{
didChange
=
true
;
results
.
removed
[
key
]
=
oldObject
[
key
]
;
}
}
}
for
(
key
in
newObject
)
{
if
(
hasOwnProperty
.
call
(
newObject
key
)
)
{
if
(
Array
.
isArray
(
oldObject
[
key
]
)
&
&
Array
.
isArray
(
newObject
[
key
]
)
)
{
if
(
oldObject
[
key
]
.
length
!
=
=
newObject
[
key
]
.
length
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
else
{
for
(
var
i
=
0
l
=
oldObject
[
key
]
.
length
;
i
<
l
;
i
+
+
)
{
if
(
oldObject
[
key
]
[
i
]
!
=
=
newObject
[
key
]
[
i
]
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
}
}
}
else
{
if
(
oldObject
[
key
]
!
=
=
newObject
[
key
]
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
}
}
}
return
didChange
&
&
results
;
}
function
_promiseLabel
(
label
)
{
return
'
Router
:
'
+
label
;
}
function
resolveHook
(
obj
hookName
)
{
if
(
!
obj
)
{
return
;
}
var
underscored
=
'
_
'
+
hookName
;
return
obj
[
underscored
]
&
&
underscored
|
|
obj
[
hookName
]
&
&
hookName
;
}
function
callHook
(
obj
_hookName
arg1
arg2
)
{
var
hookName
=
resolveHook
(
obj
_hookName
)
;
return
hookName
&
&
obj
[
hookName
]
.
call
(
obj
arg1
arg2
)
;
}
function
applyHook
(
obj
_hookName
args
)
{
var
hookName
=
resolveHook
(
obj
_hookName
)
;
if
(
hookName
)
{
if
(
args
.
length
=
=
=
0
)
{
return
obj
[
hookName
]
.
call
(
obj
)
;
}
else
if
(
args
.
length
=
=
=
1
)
{
return
obj
[
hookName
]
.
call
(
obj
args
[
0
]
)
;
}
else
if
(
args
.
length
=
=
=
2
)
{
return
obj
[
hookName
]
.
call
(
obj
args
[
0
]
args
[
1
]
)
;
}
else
{
return
obj
[
hookName
]
.
apply
(
obj
args
)
;
}
}
}
function
TransitionState
(
)
{
this
.
handlerInfos
=
[
]
;
this
.
queryParams
=
{
}
;
this
.
params
=
{
}
;
}
TransitionState
.
prototype
=
{
promiseLabel
:
function
(
label
)
{
var
targetName
=
'
'
;
forEach
(
this
.
handlerInfos
function
(
handlerInfo
)
{
if
(
targetName
!
=
=
'
'
)
{
targetName
+
=
'
.
'
;
}
targetName
+
=
handlerInfo
.
name
;
}
)
;
return
_promiseLabel
(
"
'
"
+
targetName
+
"
'
:
"
+
label
)
;
}
resolve
:
function
(
shouldContinue
payload
)
{
var
params
=
this
.
params
;
forEach
(
this
.
handlerInfos
function
(
handlerInfo
)
{
params
[
handlerInfo
.
name
]
=
handlerInfo
.
params
|
|
{
}
;
}
)
;
payload
=
payload
|
|
{
}
;
payload
.
resolveIndex
=
0
;
var
currentState
=
this
;
var
wasAborted
=
false
;
return
_rsvp
.
Promise
.
resolve
(
null
this
.
promiseLabel
(
'
Start
transition
'
)
)
.
then
(
resolveOneHandlerInfo
null
this
.
promiseLabel
(
'
Resolve
handler
'
)
)
.
catch
(
handleError
this
.
promiseLabel
(
'
Handle
error
'
)
)
;
function
innerShouldContinue
(
)
{
return
_rsvp
.
Promise
.
resolve
(
shouldContinue
(
)
currentState
.
promiseLabel
(
'
Check
if
should
continue
'
)
)
.
catch
(
function
(
reason
)
{
wasAborted
=
true
;
return
_rsvp
.
Promise
.
reject
(
reason
)
;
}
currentState
.
promiseLabel
(
'
Handle
abort
'
)
)
;
}
function
handleError
(
error
)
{
var
handlerInfos
=
currentState
.
handlerInfos
;
var
errorHandlerIndex
=
payload
.
resolveIndex
>
=
handlerInfos
.
length
?
handlerInfos
.
length
-
1
:
payload
.
resolveIndex
;
return
_rsvp
.
Promise
.
reject
(
{
error
:
error
handlerWithError
:
currentState
.
handlerInfos
[
errorHandlerIndex
]
.
handler
wasAborted
:
wasAborted
state
:
currentState
}
)
;
}
function
proceed
(
resolvedHandlerInfo
)
{
var
wasAlreadyResolved
=
currentState
.
handlerInfos
[
payload
.
resolveIndex
]
.
isResolved
;
currentState
.
handlerInfos
[
payload
.
resolveIndex
+
+
]
=
resolvedHandlerInfo
;
if
(
!
wasAlreadyResolved
)
{
var
handler
=
resolvedHandlerInfo
.
handler
;
callHook
(
handler
'
redirect
'
resolvedHandlerInfo
.
context
payload
)
;
}
return
innerShouldContinue
(
)
.
then
(
resolveOneHandlerInfo
null
currentState
.
promiseLabel
(
'
Resolve
handler
'
)
)
;
}
function
resolveOneHandlerInfo
(
)
{
if
(
payload
.
resolveIndex
=
=
=
currentState
.
handlerInfos
.
length
)
{
return
{
error
:
null
state
:
currentState
}
;
}
var
handlerInfo
=
currentState
.
handlerInfos
[
payload
.
resolveIndex
]
;
return
handlerInfo
.
resolve
(
innerShouldContinue
payload
)
.
then
(
proceed
null
currentState
.
promiseLabel
(
'
Proceed
'
)
)
;
}
}
}
;
function
TransitionAbortedError
(
message
)
{
if
(
!
(
this
instanceof
TransitionAbortedError
)
)
{
return
new
TransitionAbortedError
(
message
)
;
}
var
error
=
Error
.
call
(
this
message
)
;
if
(
Error
.
captureStackTrace
)
{
Error
.
captureStackTrace
(
this
TransitionAbortedError
)
;
}
else
{
this
.
stack
=
error
.
stack
;
}
this
.
description
=
error
.
description
;
this
.
fileName
=
error
.
fileName
;
this
.
lineNumber
=
error
.
lineNumber
;
this
.
message
=
error
.
message
|
|
'
TransitionAborted
'
;
this
.
name
=
'
TransitionAborted
'
;
this
.
number
=
error
.
number
;
this
.
code
=
error
.
code
;
}
TransitionAbortedError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
var
Transition
=
function
(
)
{
function
Transition
(
router
intent
state
error
previousTransition
)
{
var
_this
=
this
;
(
0
_emberBabel
.
classCallCheck
)
(
this
Transition
)
;
this
.
state
=
state
|
|
router
.
state
;
this
.
intent
=
intent
;
this
.
router
=
router
;
this
.
data
=
this
.
intent
&
&
this
.
intent
.
data
|
|
{
}
;
this
.
resolvedModels
=
{
}
;
this
.
queryParams
=
{
}
;
this
.
promise
=
undefined
;
this
.
error
=
undefined
;
this
.
params
=
undefined
;
this
.
handlerInfos
=
undefined
;
this
.
targetName
=
undefined
;
this
.
pivotHandler
=
undefined
;
this
.
sequence
=
undefined
;
this
.
isAborted
=
false
;
this
.
isActive
=
true
;
this
.
urlMethod
=
'
update
'
;
this
.
resolveIndex
=
0
;
this
.
queryParamsOnly
=
false
;
this
.
isTransition
=
true
;
if
(
error
)
{
this
.
promise
=
_rsvp
.
Promise
.
reject
(
error
)
;
this
.
error
=
error
;
return
;
}
this
.
isCausedByAbortingTransition
=
!
!
previousTransition
;
this
.
isCausedByInitialTransition
=
previousTransition
&
&
(
previousTransition
.
isCausedByInitialTransition
|
|
previousTransition
.
sequence
=
=
=
0
)
;
if
(
state
)
{
this
.
params
=
state
.
params
;
this
.
queryParams
=
state
.
queryParams
;
this
.
handlerInfos
=
state
.
handlerInfos
;
var
len
=
state
.
handlerInfos
.
length
;
if
(
len
)
{
this
.
targetName
=
state
.
handlerInfos
[
len
-
1
]
.
name
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
state
.
handlerInfos
[
i
]
;
if
(
!
handlerInfo
.
isResolved
)
{
break
;
}
this
.
pivotHandler
=
handlerInfo
.
handler
;
}
this
.
sequence
=
router
.
currentSequence
+
+
;
this
.
promise
=
state
.
resolve
(
function
(
)
{
if
(
_this
.
isAborted
)
{
return
_rsvp
.
Promise
.
reject
(
undefined
_promiseLabel
(
'
Transition
aborted
-
reject
'
)
)
;
}
}
this
)
.
catch
(
function
(
result
)
{
if
(
result
.
wasAborted
|
|
_this
.
isAborted
)
{
return
_rsvp
.
Promise
.
reject
(
logAbort
(
_this
)
)
;
}
else
{
_this
.
trigger
(
'
error
'
result
.
error
_this
result
.
handlerWithError
)
;
_this
.
abort
(
)
;
return
_rsvp
.
Promise
.
reject
(
result
.
error
)
;
}
}
_promiseLabel
(
'
Handle
Abort
'
)
)
;
}
else
{
this
.
promise
=
_rsvp
.
Promise
.
resolve
(
this
.
state
)
;
this
.
params
=
{
}
;
}
}
Transition
.
prototype
.
isExiting
=
function
isExiting
(
handler
)
{
var
handlerInfos
=
this
.
handlerInfos
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
if
(
handlerInfo
.
name
=
=
=
handler
|
|
handlerInfo
.
handler
=
=
=
handler
)
{
return
false
;
}
}
return
true
;
}
;
Transition
.
prototype
.
then
=
function
then
(
onFulfilled
onRejected
label
)
{
return
this
.
promise
.
then
(
onFulfilled
onRejected
label
)
;
}
;
Transition
.
prototype
.
catch
=
function
_catch
(
onRejection
label
)
{
return
this
.
promise
.
catch
(
onRejection
label
)
;
}
;
Transition
.
prototype
.
finally
=
function
_finally
(
callback
label
)
{
return
this
.
promise
.
finally
(
callback
label
)
;
}
;
Transition
.
prototype
.
abort
=
function
abort
(
)
{
if
(
this
.
isAborted
)
{
return
this
;
}
_log
(
this
.
router
this
.
sequence
this
.
targetName
+
'
:
transition
was
aborted
'
)
;
this
.
intent
.
preTransitionState
=
this
.
router
.
state
;
this
.
isAborted
=
true
;
this
.
isActive
=
false
;
this
.
router
.
activeTransition
=
null
;
return
this
;
}
;
Transition
.
prototype
.
retry
=
function
retry
(
)
{
this
.
abort
(
)
;
var
newTransition
=
this
.
router
.
transitionByIntent
(
this
.
intent
false
)
;
if
(
this
.
urlMethod
!
=
=
null
)
{
newTransition
.
method
(
this
.
urlMethod
)
;
}
return
newTransition
;
}
;
Transition
.
prototype
.
method
=
function
method
(
_method
)
{
this
.
urlMethod
=
_method
;
return
this
;
}
;
Transition
.
prototype
.
trigger
=
function
trigger
(
ignoreFailure
)
{
var
args
=
slice
.
call
(
arguments
)
;
if
(
typeof
ignoreFailure
=
=
=
'
boolean
'
)
{
args
.
shift
(
)
;
}
else
{
ignoreFailure
=
false
;
}
_trigger
(
this
.
router
this
.
state
.
handlerInfos
.
slice
(
0
this
.
resolveIndex
+
1
)
ignoreFailure
args
)
;
}
;
Transition
.
prototype
.
followRedirects
=
function
followRedirects
(
)
{
var
router
=
this
.
router
;
return
this
.
promise
.
catch
(
function
(
reason
)
{
if
(
router
.
activeTransition
)
{
return
router
.
activeTransition
.
followRedirects
(
)
;
}
return
_rsvp
.
Promise
.
reject
(
reason
)
;
}
)
;
}
;
Transition
.
prototype
.
toString
=
function
toString
(
)
{
return
'
Transition
(
sequence
'
+
this
.
sequence
+
'
)
'
;
}
;
Transition
.
prototype
.
log
=
function
log
(
message
)
{
_log
(
this
.
router
this
.
sequence
message
)
;
}
;
return
Transition
;
}
(
)
;
Transition
.
prototype
.
send
=
Transition
.
prototype
.
trigger
;
function
logAbort
(
transition
)
{
_log
(
transition
.
router
transition
.
sequence
'
detected
abort
.
'
)
;
return
new
TransitionAbortedError
(
)
;
}
var
TransitionIntent
=
function
TransitionIntent
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TransitionIntent
)
;
this
.
data
=
this
.
data
|
|
{
}
;
}
;
var
DEFAULT_HANDLER
=
Object
.
freeze
(
{
}
)
;
var
HandlerInfo
=
function
(
)
{
function
HandlerInfo
(
_props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
HandlerInfo
)
;
var
props
=
_props
|
|
{
}
;
this
.
_handler
=
DEFAULT_HANDLER
;
this
.
_handlerPromise
=
null
;
this
.
factory
=
null
;
this
.
name
=
props
.
name
;
for
(
var
prop
in
props
)
{
if
(
prop
=
=
=
'
handler
'
)
{
this
.
_processHandler
(
props
.
handler
)
;
}
else
{
this
[
prop
]
=
props
[
prop
]
;
}
}
}
HandlerInfo
.
prototype
.
getHandler
=
function
getHandler
(
)
{
}
;
HandlerInfo
.
prototype
.
fetchHandler
=
function
fetchHandler
(
)
{
var
handler
=
this
.
getHandler
(
this
.
name
)
;
return
this
.
_processHandler
(
handler
)
;
}
;
HandlerInfo
.
prototype
.
_processHandler
=
function
_processHandler
(
handler
)
{
var
_this2
=
this
;
this
.
handlerPromise
=
_rsvp
.
Promise
.
resolve
(
handler
)
;
if
(
isPromise
(
handler
)
)
{
this
.
handlerPromise
=
this
.
handlerPromise
.
then
(
function
(
h
)
{
return
_this2
.
updateHandler
(
h
)
;
}
)
;
return
this
.
handler
=
undefined
;
}
else
if
(
handler
)
{
return
this
.
updateHandler
(
handler
)
;
}
}
;
HandlerInfo
.
prototype
.
log
=
function
log
(
payload
message
)
{
if
(
payload
.
log
)
{
payload
.
log
(
this
.
name
+
'
:
'
+
message
)
;
}
}
;
HandlerInfo
.
prototype
.
promiseLabel
=
function
promiseLabel
(
label
)
{
return
_promiseLabel
(
"
'
"
+
this
.
name
+
"
'
"
+
label
)
;
}
;
HandlerInfo
.
prototype
.
getUnresolved
=
function
getUnresolved
(
)
{
return
this
;
}
;
HandlerInfo
.
prototype
.
serialize
=
function
serialize
(
)
{
return
this
.
params
|
|
{
}
;
}
;
HandlerInfo
.
prototype
.
updateHandler
=
function
updateHandler
(
handler
)
{
handler
.
_handlerName
=
this
.
name
;
return
this
.
handler
=
handler
;
}
;
HandlerInfo
.
prototype
.
resolve
=
function
resolve
(
shouldContinue
payload
)
{
var
checkForAbort
=
this
.
checkForAbort
.
bind
(
this
shouldContinue
)
beforeModel
=
this
.
runBeforeModelHook
.
bind
(
this
payload
)
model
=
this
.
getModel
.
bind
(
this
payload
)
afterModel
=
this
.
runAfterModelHook
.
bind
(
this
payload
)
becomeResolved
=
this
.
becomeResolved
.
bind
(
this
payload
)
self
=
this
;
return
_rsvp
.
Promise
.
resolve
(
this
.
handlerPromise
this
.
promiseLabel
(
'
Start
handler
'
)
)
.
then
(
function
(
handler
)
{
return
_rsvp
.
Promise
.
resolve
(
handler
)
.
then
(
checkForAbort
null
self
.
promiseLabel
(
'
Check
for
abort
'
)
)
.
then
(
beforeModel
null
self
.
promiseLabel
(
'
Before
model
'
)
)
.
then
(
checkForAbort
null
self
.
promiseLabel
(
"
Check
if
aborted
during
'
beforeModel
'
hook
"
)
)
.
then
(
model
null
self
.
promiseLabel
(
'
Model
'
)
)
.
then
(
checkForAbort
null
self
.
promiseLabel
(
"
Check
if
aborted
in
'
model
'
hook
"
)
)
.
then
(
afterModel
null
self
.
promiseLabel
(
'
After
model
'
)
)
.
then
(
checkForAbort
null
self
.
promiseLabel
(
"
Check
if
aborted
in
'
afterModel
'
hook
"
)
)
.
then
(
becomeResolved
null
self
.
promiseLabel
(
'
Become
resolved
'
)
)
;
}
function
(
error
)
{
throw
error
;
}
)
;
}
;
HandlerInfo
.
prototype
.
runBeforeModelHook
=
function
runBeforeModelHook
(
payload
)
{
if
(
payload
.
trigger
)
{
payload
.
trigger
(
true
'
willResolveModel
'
payload
this
.
handler
)
;
}
return
this
.
runSharedModelHook
(
payload
'
beforeModel
'
[
]
)
;
}
;
HandlerInfo
.
prototype
.
runAfterModelHook
=
function
runAfterModelHook
(
payload
resolvedModel
)
{
var
name
=
this
.
name
;
this
.
stashResolvedModel
(
payload
resolvedModel
)
;
return
this
.
runSharedModelHook
(
payload
'
afterModel
'
[
resolvedModel
]
)
.
then
(
function
(
)
{
return
payload
.
resolvedModels
[
name
]
;
}
null
this
.
promiseLabel
(
'
Ignore
fulfillment
value
and
return
model
value
'
)
)
;
}
;
HandlerInfo
.
prototype
.
runSharedModelHook
=
function
runSharedModelHook
(
payload
hookName
args
)
{
this
.
log
(
payload
'
calling
'
+
hookName
+
'
hook
'
)
;
if
(
this
.
queryParams
)
{
args
.
push
(
this
.
queryParams
)
;
}
args
.
push
(
payload
)
;
var
result
=
applyHook
(
this
.
handler
hookName
args
)
;
if
(
result
&
&
result
.
isTransition
)
{
result
=
null
;
}
return
_rsvp
.
Promise
.
resolve
(
result
this
.
promiseLabel
(
'
Resolve
value
returned
from
one
of
the
model
hooks
'
)
)
;
}
;
HandlerInfo
.
prototype
.
getModel
=
function
getModel
(
)
{
}
;
HandlerInfo
.
prototype
.
checkForAbort
=
function
checkForAbort
(
shouldContinue
promiseValue
)
{
return
_rsvp
.
Promise
.
resolve
(
shouldContinue
(
)
this
.
promiseLabel
(
'
Check
for
abort
'
)
)
.
then
(
function
(
)
{
return
promiseValue
;
}
null
this
.
promiseLabel
(
'
Ignore
fulfillment
value
and
continue
'
)
)
;
}
;
HandlerInfo
.
prototype
.
stashResolvedModel
=
function
stashResolvedModel
(
payload
resolvedModel
)
{
payload
.
resolvedModels
=
payload
.
resolvedModels
|
|
{
}
;
payload
.
resolvedModels
[
this
.
name
]
=
resolvedModel
;
}
;
HandlerInfo
.
prototype
.
becomeResolved
=
function
becomeResolved
(
payload
resolvedContext
)
{
var
params
=
this
.
serialize
(
resolvedContext
)
;
if
(
payload
)
{
this
.
stashResolvedModel
(
payload
resolvedContext
)
;
payload
.
params
=
payload
.
params
|
|
{
}
;
payload
.
params
[
this
.
name
]
=
params
;
}
return
this
.
factory
(
'
resolved
'
{
context
:
resolvedContext
name
:
this
.
name
handler
:
this
.
handler
params
:
params
}
)
;
}
;
HandlerInfo
.
prototype
.
shouldSupercede
=
function
shouldSupercede
(
other
)
{
if
(
!
other
)
{
return
true
;
}
var
contextsMatch
=
other
.
context
=
=
=
this
.
context
;
return
other
.
name
!
=
=
this
.
name
|
|
this
.
hasOwnProperty
(
'
context
'
)
&
&
!
contextsMatch
|
|
this
.
hasOwnProperty
(
'
params
'
)
&
&
!
paramsMatch
(
this
.
params
other
.
params
)
;
}
;
(
0
_emberBabel
.
createClass
)
(
HandlerInfo
[
{
key
:
'
handler
'
get
:
function
(
)
{
if
(
this
.
_handler
!
=
=
DEFAULT_HANDLER
)
{
return
this
.
_handler
;
}
return
this
.
fetchHandler
(
)
;
}
set
:
function
(
handler
)
{
return
this
.
_handler
=
handler
;
}
}
{
key
:
'
handlerPromise
'
get
:
function
(
)
{
if
(
this
.
_handlerPromise
!
=
=
null
)
{
return
this
.
_handlerPromise
;
}
this
.
fetchHandler
(
)
;
return
this
.
_handlerPromise
;
}
set
:
function
(
handlerPromise
)
{
this
.
_handlerPromise
=
handlerPromise
;
return
handlerPromise
;
}
}
]
)
;
return
HandlerInfo
;
}
(
)
;
HandlerInfo
.
prototype
.
context
=
null
;
function
paramsMatch
(
a
b
)
{
if
(
!
a
^
!
b
)
{
return
false
;
}
if
(
!
a
)
{
return
true
;
}
for
(
var
k
in
a
)
{
if
(
a
.
hasOwnProperty
(
k
)
&
&
a
[
k
]
!
=
=
b
[
k
]
)
{
return
false
;
}
}
return
true
;
}
var
ResolvedHandlerInfo
=
function
(
_HandlerInfo
)
{
(
0
_emberBabel
.
inherits
)
(
ResolvedHandlerInfo
_HandlerInfo
)
;
function
ResolvedHandlerInfo
(
props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
ResolvedHandlerInfo
)
;
var
_this3
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_HandlerInfo
.
call
(
this
props
)
)
;
_this3
.
isResolved
=
true
;
return
_this3
;
}
ResolvedHandlerInfo
.
prototype
.
resolve
=
function
resolve
(
shouldContinue
payload
)
{
if
(
payload
&
&
payload
.
resolvedModels
)
{
payload
.
resolvedModels
[
this
.
name
]
=
this
.
context
;
}
return
_rsvp
.
Promise
.
resolve
(
this
this
.
promiseLabel
(
'
Resolve
'
)
)
;
}
;
ResolvedHandlerInfo
.
prototype
.
getUnresolved
=
function
getUnresolved
(
)
{
return
this
.
factory
(
'
param
'
{
name
:
this
.
name
handler
:
this
.
handler
params
:
this
.
params
}
)
;
}
;
return
ResolvedHandlerInfo
;
}
(
HandlerInfo
)
;
var
UnresolvedHandlerInfoByObject
=
function
(
_HandlerInfo2
)
{
(
0
_emberBabel
.
inherits
)
(
UnresolvedHandlerInfoByObject
_HandlerInfo2
)
;
function
UnresolvedHandlerInfoByObject
(
props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
UnresolvedHandlerInfoByObject
)
;
var
_this4
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_HandlerInfo2
.
call
(
this
props
)
)
;
_this4
.
names
=
_this4
.
names
|
|
[
]
;
return
_this4
;
}
UnresolvedHandlerInfoByObject
.
prototype
.
getModel
=
function
getModel
(
payload
)
{
this
.
log
(
payload
this
.
name
+
'
:
resolving
provided
model
'
)
;
return
_rsvp
.
Promise
.
resolve
(
this
.
context
)
;
}
;
UnresolvedHandlerInfoByObject
.
prototype
.
serialize
=
function
serialize
(
_model
)
{
var
model
=
_model
|
|
this
.
context
names
=
this
.
names
;
var
object
=
{
}
;
if
(
isParam
(
model
)
)
{
object
[
names
[
0
]
]
=
model
;
return
object
;
}
if
(
this
.
serializer
)
{
return
this
.
serializer
.
call
(
null
model
names
)
;
}
else
if
(
this
.
handler
&
&
this
.
handler
.
serialize
)
{
return
this
.
handler
.
serialize
(
model
names
)
;
}
if
(
names
.
length
!
=
=
1
)
{
return
;
}
var
name
=
names
[
0
]
;
if
(
/
_id
/
.
test
(
name
)
)
{
object
[
name
]
=
model
.
id
;
}
else
{
object
[
name
]
=
model
;
}
return
object
;
}
;
return
UnresolvedHandlerInfoByObject
;
}
(
HandlerInfo
)
;
var
UnresolvedHandlerInfoByParam
=
function
(
_HandlerInfo3
)
{
(
0
_emberBabel
.
inherits
)
(
UnresolvedHandlerInfoByParam
_HandlerInfo3
)
;
function
UnresolvedHandlerInfoByParam
(
props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
UnresolvedHandlerInfoByParam
)
;
var
_this5
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_HandlerInfo3
.
call
(
this
props
)
)
;
_this5
.
params
=
_this5
.
params
|
|
{
}
;
return
_this5
;
}
UnresolvedHandlerInfoByParam
.
prototype
.
getModel
=
function
getModel
(
payload
)
{
var
fullParams
=
this
.
params
;
if
(
payload
&
&
payload
.
queryParams
)
{
fullParams
=
{
}
;
merge
(
fullParams
this
.
params
)
;
fullParams
.
queryParams
=
payload
.
queryParams
;
}
var
handler
=
this
.
handler
;
var
hookName
=
resolveHook
(
handler
'
deserialize
'
)
|
|
resolveHook
(
handler
'
model
'
)
;
return
this
.
runSharedModelHook
(
payload
hookName
[
fullParams
]
)
;
}
;
return
UnresolvedHandlerInfoByParam
;
}
(
HandlerInfo
)
;
handlerInfoFactory
.
klasses
=
{
resolved
:
ResolvedHandlerInfo
param
:
UnresolvedHandlerInfoByParam
object
:
UnresolvedHandlerInfoByObject
}
;
function
handlerInfoFactory
(
name
props
)
{
var
klass
=
handlerInfoFactory
.
klasses
[
name
]
;
var
handlerInfo
=
new
klass
(
props
|
|
{
}
)
;
handlerInfo
.
factory
=
handlerInfoFactory
;
return
handlerInfo
;
}
var
NamedTransitionIntent
=
function
(
_TransitionIntent
)
{
(
0
_emberBabel
.
inherits
)
(
NamedTransitionIntent
_TransitionIntent
)
;
function
NamedTransitionIntent
(
props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
NamedTransitionIntent
)
;
var
_this6
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_TransitionIntent
.
call
(
this
props
)
)
;
_this6
.
name
=
props
.
name
;
_this6
.
pivotHandler
=
props
.
pivotHandler
;
_this6
.
contexts
=
props
.
contexts
|
|
[
]
;
_this6
.
queryParams
=
props
.
queryParams
;
return
_this6
;
}
NamedTransitionIntent
.
prototype
.
applyToState
=
function
applyToState
(
oldState
recognizer
getHandler
isIntermediate
getSerializer
)
{
var
partitionedArgs
=
extractQueryParams
(
[
this
.
name
]
.
concat
(
this
.
contexts
)
)
pureArgs
=
partitionedArgs
[
0
]
handlers
=
recognizer
.
handlersFor
(
pureArgs
[
0
]
)
;
var
targetRouteName
=
handlers
[
handlers
.
length
-
1
]
.
handler
;
return
this
.
applyToHandlers
(
oldState
handlers
getHandler
targetRouteName
isIntermediate
null
getSerializer
)
;
}
;
NamedTransitionIntent
.
prototype
.
applyToHandlers
=
function
applyToHandlers
(
oldState
handlers
getHandler
targetRouteName
isIntermediate
checkingIfActive
getSerializer
)
{
var
i
len
;
var
newState
=
new
TransitionState
(
)
;
var
objects
=
this
.
contexts
.
slice
(
0
)
;
var
invalidateIndex
=
handlers
.
length
;
if
(
this
.
pivotHandler
)
{
for
(
i
=
0
len
=
handlers
.
length
;
i
<
len
;
+
+
i
)
{
if
(
handlers
[
i
]
.
handler
=
=
=
this
.
pivotHandler
.
_handlerName
)
{
invalidateIndex
=
i
;
break
;
}
}
}
for
(
i
=
handlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
result
=
handlers
[
i
]
;
var
name
=
result
.
handler
;
var
oldHandlerInfo
=
oldState
.
handlerInfos
[
i
]
;
var
newHandlerInfo
=
null
;
if
(
result
.
names
.
length
>
0
)
{
if
(
i
>
=
invalidateIndex
)
{
newHandlerInfo
=
this
.
createParamHandlerInfo
(
name
getHandler
result
.
names
objects
oldHandlerInfo
)
;
}
else
{
var
serializer
=
getSerializer
(
name
)
;
newHandlerInfo
=
this
.
getHandlerInfoForDynamicSegment
(
name
getHandler
result
.
names
objects
oldHandlerInfo
targetRouteName
i
serializer
)
;
}
}
else
{
newHandlerInfo
=
this
.
createParamHandlerInfo
(
name
getHandler
result
.
names
objects
oldHandlerInfo
)
;
}
if
(
checkingIfActive
)
{
newHandlerInfo
=
newHandlerInfo
.
becomeResolved
(
null
newHandlerInfo
.
context
)
;
var
oldContext
=
oldHandlerInfo
&
&
oldHandlerInfo
.
context
;
if
(
result
.
names
.
length
>
0
&
&
newHandlerInfo
.
context
=
=
=
oldContext
)
{
newHandlerInfo
.
params
=
oldHandlerInfo
&
&
oldHandlerInfo
.
params
;
}
newHandlerInfo
.
context
=
oldContext
;
}
var
handlerToUse
=
oldHandlerInfo
;
if
(
i
>
=
invalidateIndex
|
|
newHandlerInfo
.
shouldSupercede
(
oldHandlerInfo
)
)
{
invalidateIndex
=
Math
.
min
(
i
invalidateIndex
)
;
handlerToUse
=
newHandlerInfo
;
}
if
(
isIntermediate
&
&
!
checkingIfActive
)
{
handlerToUse
=
handlerToUse
.
becomeResolved
(
null
handlerToUse
.
context
)
;
}
newState
.
handlerInfos
.
unshift
(
handlerToUse
)
;
}
if
(
objects
.
length
>
0
)
{
throw
new
Error
(
'
More
context
objects
were
passed
than
there
are
dynamic
segments
for
the
route
:
'
+
targetRouteName
)
;
}
if
(
!
isIntermediate
)
{
this
.
invalidateChildren
(
newState
.
handlerInfos
invalidateIndex
)
;
}
merge
(
newState
.
queryParams
this
.
queryParams
|
|
{
}
)
;
return
newState
;
}
;
NamedTransitionIntent
.
prototype
.
invalidateChildren
=
function
invalidateChildren
(
handlerInfos
invalidateIndex
)
{
for
(
var
i
=
invalidateIndex
l
=
handlerInfos
.
length
;
i
<
l
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
handlerInfos
[
i
]
=
handlerInfo
.
getUnresolved
(
)
;
}
}
;
NamedTransitionIntent
.
prototype
.
getHandlerInfoForDynamicSegment
=
function
getHandlerInfoForDynamicSegment
(
name
getHandler
names
objects
oldHandlerInfo
targetRouteName
i
serializer
)
{
var
objectToUse
;
if
(
objects
.
length
>
0
)
{
objectToUse
=
objects
[
objects
.
length
-
1
]
;
if
(
isParam
(
objectToUse
)
)
{
return
this
.
createParamHandlerInfo
(
name
getHandler
names
objects
oldHandlerInfo
)
;
}
else
{
objects
.
pop
(
)
;
}
}
else
if
(
oldHandlerInfo
&
&
oldHandlerInfo
.
name
=
=
=
name
)
{
return
oldHandlerInfo
;
}
else
{
if
(
this
.
preTransitionState
)
{
var
preTransitionHandlerInfo
=
this
.
preTransitionState
.
handlerInfos
[
i
]
;
objectToUse
=
preTransitionHandlerInfo
&
&
preTransitionHandlerInfo
.
context
;
}
else
{
return
oldHandlerInfo
;
}
}
return
handlerInfoFactory
(
'
object
'
{
name
:
name
getHandler
:
getHandler
serializer
:
serializer
context
:
objectToUse
names
:
names
}
)
;
}
;
NamedTransitionIntent
.
prototype
.
createParamHandlerInfo
=
function
createParamHandlerInfo
(
name
getHandler
names
objects
oldHandlerInfo
)
{
var
params
=
{
}
;
var
numNames
=
names
.
length
;
while
(
numNames
-
-
)
{
var
oldParams
=
oldHandlerInfo
&
&
name
=
=
=
oldHandlerInfo
.
name
&
&
oldHandlerInfo
.
params
|
|
{
}
;
var
peek
=
objects
[
objects
.
length
-
1
]
;
var
paramName
=
names
[
numNames
]
;
if
(
isParam
(
peek
)
)
{
params
[
paramName
]
=
'
'
+
objects
.
pop
(
)
;
}
else
{
if
(
oldParams
.
hasOwnProperty
(
paramName
)
)
{
params
[
paramName
]
=
oldParams
[
paramName
]
;
}
else
{
throw
new
Error
(
"
You
didn
'
t
provide
enough
string
/
numeric
parameters
to
satisfy
all
of
the
dynamic
segments
for
route
"
+
name
)
;
}
}
}
return
handlerInfoFactory
(
'
param
'
{
name
:
name
getHandler
:
getHandler
params
:
params
}
)
;
}
;
return
NamedTransitionIntent
;
}
(
TransitionIntent
)
;
function
UnrecognizedURLError
(
message
)
{
if
(
!
(
this
instanceof
UnrecognizedURLError
)
)
{
return
new
UnrecognizedURLError
(
message
)
;
}
var
error
=
Error
.
call
(
this
message
)
;
if
(
Error
.
captureStackTrace
)
{
Error
.
captureStackTrace
(
this
UnrecognizedURLError
)
;
}
else
{
this
.
stack
=
error
.
stack
;
}
this
.
description
=
error
.
description
;
this
.
fileName
=
error
.
fileName
;
this
.
lineNumber
=
error
.
lineNumber
;
this
.
message
=
error
.
message
|
|
'
UnrecognizedURL
'
;
this
.
name
=
'
UnrecognizedURLError
'
;
this
.
number
=
error
.
number
;
this
.
code
=
error
.
code
;
}
UnrecognizedURLError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
var
URLTransitionIntent
=
function
(
_TransitionIntent2
)
{
(
0
_emberBabel
.
inherits
)
(
URLTransitionIntent
_TransitionIntent2
)
;
function
URLTransitionIntent
(
props
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
URLTransitionIntent
)
;
var
_this7
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_TransitionIntent2
.
call
(
this
props
)
)
;
_this7
.
url
=
props
.
url
;
return
_this7
;
}
URLTransitionIntent
.
prototype
.
applyToState
=
function
applyToState
(
oldState
recognizer
getHandler
)
{
var
newState
=
new
TransitionState
(
)
;
var
results
=
recognizer
.
recognize
(
this
.
url
)
i
len
;
if
(
!
results
)
{
throw
new
UnrecognizedURLError
(
this
.
url
)
;
}
var
statesDiffer
=
false
;
var
url
=
this
.
url
;
function
checkHandlerAccessibility
(
handler
)
{
if
(
handler
&
&
handler
.
inaccessibleByURL
)
{
throw
new
UnrecognizedURLError
(
url
)
;
}
return
handler
;
}
for
(
i
=
0
len
=
results
.
length
;
i
<
len
;
+
+
i
)
{
var
result
=
results
[
i
]
;
var
name
=
result
.
handler
;
var
newHandlerInfo
=
handlerInfoFactory
(
'
param
'
{
name
:
name
getHandler
:
getHandler
params
:
result
.
params
}
)
;
var
handler
=
newHandlerInfo
.
handler
;
if
(
handler
)
{
checkHandlerAccessibility
(
handler
)
;
}
else
{
newHandlerInfo
.
handlerPromise
=
newHandlerInfo
.
handlerPromise
.
then
(
checkHandlerAccessibility
)
;
}
var
oldHandlerInfo
=
oldState
.
handlerInfos
[
i
]
;
if
(
statesDiffer
|
|
newHandlerInfo
.
shouldSupercede
(
oldHandlerInfo
)
)
{
statesDiffer
=
true
;
newState
.
handlerInfos
[
i
]
=
newHandlerInfo
;
}
else
{
newState
.
handlerInfos
[
i
]
=
oldHandlerInfo
;
}
}
merge
(
newState
.
queryParams
results
.
queryParams
)
;
return
newState
;
}
;
return
URLTransitionIntent
;
}
(
TransitionIntent
)
;
var
pop
=
Array
.
prototype
.
pop
;
function
Router
(
_options
)
{
var
options
=
_options
|
|
{
}
;
this
.
getHandler
=
options
.
getHandler
|
|
this
.
getHandler
;
this
.
getSerializer
=
options
.
getSerializer
|
|
this
.
getSerializer
;
this
.
updateURL
=
options
.
updateURL
|
|
this
.
updateURL
;
this
.
replaceURL
=
options
.
replaceURL
|
|
this
.
replaceURL
;
this
.
didTransition
=
options
.
didTransition
|
|
this
.
didTransition
;
this
.
willTransition
=
options
.
willTransition
|
|
this
.
willTransition
;
this
.
delegate
=
options
.
delegate
|
|
this
.
delegate
;
this
.
triggerEvent
=
options
.
triggerEvent
|
|
this
.
triggerEvent
;
this
.
log
=
options
.
log
|
|
this
.
log
;
this
.
dslCallBacks
=
[
]
;
this
.
state
=
undefined
;
this
.
activeTransition
=
undefined
;
this
.
_changedQueryParams
=
undefined
;
this
.
oldState
=
undefined
;
this
.
currentHandlerInfos
=
undefined
;
this
.
currentSequence
=
0
;
this
.
recognizer
=
new
_routeRecognizer
.
default
(
)
;
this
.
reset
(
)
;
}
function
getTransitionByIntent
(
intent
isIntermediate
)
{
var
wasTransitioning
=
!
!
this
.
activeTransition
;
var
oldState
=
wasTransitioning
?
this
.
activeTransition
.
state
:
this
.
state
;
var
newTransition
;
var
newState
=
intent
.
applyToState
(
oldState
this
.
recognizer
this
.
getHandler
isIntermediate
this
.
getSerializer
)
;
var
queryParamChangelist
=
getChangelist
(
oldState
.
queryParams
newState
.
queryParams
)
;
if
(
handlerInfosEqual
(
newState
.
handlerInfos
oldState
.
handlerInfos
)
)
{
if
(
queryParamChangelist
)
{
newTransition
=
this
.
queryParamsTransition
(
queryParamChangelist
wasTransitioning
oldState
newState
)
;
if
(
newTransition
)
{
newTransition
.
queryParamsOnly
=
true
;
return
newTransition
;
}
}
return
this
.
activeTransition
|
|
new
Transition
(
this
)
;
}
if
(
isIntermediate
)
{
setupContexts
(
this
newState
)
;
return
;
}
newTransition
=
new
Transition
(
this
intent
newState
undefined
this
.
activeTransition
)
;
if
(
handlerInfosSameExceptQueryParams
(
newState
.
handlerInfos
oldState
.
handlerInfos
)
)
{
newTransition
.
queryParamsOnly
=
true
;
}
if
(
this
.
activeTransition
)
{
this
.
activeTransition
.
abort
(
)
;
}
this
.
activeTransition
=
newTransition
;
newTransition
.
promise
=
newTransition
.
promise
.
then
(
function
(
result
)
{
return
finalizeTransition
(
newTransition
result
.
state
)
;
}
null
_promiseLabel
(
'
Settle
transition
promise
when
transition
is
finalized
'
)
)
;
if
(
!
wasTransitioning
)
{
notifyExistingHandlers
(
this
newState
newTransition
)
;
}
fireQueryParamDidChange
(
this
newState
queryParamChangelist
)
;
return
newTransition
;
}
Router
.
prototype
=
{
map
:
function
(
callback
)
{
this
.
recognizer
.
delegate
=
this
.
delegate
;
this
.
recognizer
.
map
(
callback
function
(
recognizer
routes
)
{
for
(
var
i
=
routes
.
length
-
1
proceed
=
true
;
i
>
=
0
&
&
proceed
;
-
-
i
)
{
var
route
=
routes
[
i
]
;
recognizer
.
add
(
routes
{
as
:
route
.
handler
}
)
;
proceed
=
route
.
path
=
=
=
'
/
'
|
|
route
.
path
=
=
=
'
'
|
|
route
.
handler
.
slice
(
-
6
)
=
=
=
'
.
index
'
;
}
}
)
;
}
hasRoute
:
function
(
route
)
{
return
this
.
recognizer
.
hasRoute
(
route
)
;
}
getHandler
:
function
(
)
{
}
getSerializer
:
function
(
)
{
}
queryParamsTransition
:
function
(
changelist
wasTransitioning
oldState
newState
)
{
var
router
=
this
;
fireQueryParamDidChange
(
this
newState
changelist
)
;
if
(
!
wasTransitioning
&
&
this
.
activeTransition
)
{
return
this
.
activeTransition
;
}
else
{
var
newTransition
=
new
Transition
(
this
)
;
newTransition
.
queryParamsOnly
=
true
;
oldState
.
queryParams
=
finalizeQueryParamChange
(
this
newState
.
handlerInfos
newState
.
queryParams
newTransition
)
;
newTransition
.
promise
=
newTransition
.
promise
.
then
(
function
(
result
)
{
updateURL
(
newTransition
oldState
true
)
;
if
(
router
.
didTransition
)
{
router
.
didTransition
(
router
.
currentHandlerInfos
)
;
}
return
result
;
}
null
_promiseLabel
(
'
Transition
complete
'
)
)
;
return
newTransition
;
}
}
transitionByIntent
:
function
(
intent
)
{
try
{
return
getTransitionByIntent
.
apply
(
this
arguments
)
;
}
catch
(
e
)
{
return
new
Transition
(
this
intent
null
e
)
;
}
}
reset
:
function
(
)
{
if
(
this
.
state
)
{
forEach
(
this
.
state
.
handlerInfos
.
slice
(
)
.
reverse
(
)
function
(
handlerInfo
)
{
var
handler
=
handlerInfo
.
handler
;
callHook
(
handler
'
exit
'
)
;
}
)
;
}
this
.
oldState
=
undefined
;
this
.
state
=
new
TransitionState
(
)
;
this
.
currentHandlerInfos
=
null
;
}
activeTransition
:
null
handleURL
:
function
(
url
)
{
var
args
=
slice
.
call
(
arguments
)
;
if
(
url
.
charAt
(
0
)
!
=
=
'
/
'
)
{
args
[
0
]
=
'
/
'
+
url
;
}
return
doTransition
(
this
args
)
.
method
(
null
)
;
}
updateURL
:
function
(
)
{
throw
new
Error
(
'
updateURL
is
not
implemented
'
)
;
}
replaceURL
:
function
(
url
)
{
this
.
updateURL
(
url
)
;
}
transitionTo
:
function
(
)
{
return
doTransition
(
this
arguments
)
;
}
intermediateTransitionTo
:
function
(
)
{
return
doTransition
(
this
arguments
true
)
;
}
refresh
:
function
(
pivotHandler
)
{
var
previousTransition
=
this
.
activeTransition
;
var
state
=
previousTransition
?
previousTransition
.
state
:
this
.
state
;
var
handlerInfos
=
state
.
handlerInfos
;
_log
(
this
'
Starting
a
refresh
transition
'
)
;
var
intent
=
new
NamedTransitionIntent
(
{
name
:
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
pivotHandler
:
pivotHandler
|
|
handlerInfos
[
0
]
.
handler
contexts
:
[
]
queryParams
:
this
.
_changedQueryParams
|
|
state
.
queryParams
|
|
{
}
}
)
;
var
newTransition
=
this
.
transitionByIntent
(
intent
false
)
;
if
(
previousTransition
&
&
previousTransition
.
urlMethod
=
=
=
'
replace
'
)
{
newTransition
.
method
(
previousTransition
.
urlMethod
)
;
}
return
newTransition
;
}
replaceWith
:
function
(
)
{
return
doTransition
(
this
arguments
)
.
method
(
'
replace
'
)
;
}
generate
:
function
(
handlerName
)
{
var
partitionedArgs
=
extractQueryParams
(
slice
.
call
(
arguments
1
)
)
suppliedParams
=
partitionedArgs
[
0
]
queryParams
=
partitionedArgs
[
1
]
;
var
intent
=
new
NamedTransitionIntent
(
{
name
:
handlerName
contexts
:
suppliedParams
}
)
;
var
state
=
intent
.
applyToState
(
this
.
state
this
.
recognizer
this
.
getHandler
null
this
.
getSerializer
)
;
var
params
=
{
}
;
for
(
var
i
=
0
len
=
state
.
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
state
.
handlerInfos
[
i
]
;
var
handlerParams
=
handlerInfo
.
serialize
(
)
;
merge
(
params
handlerParams
)
;
}
params
.
queryParams
=
queryParams
;
return
this
.
recognizer
.
generate
(
handlerName
params
)
;
}
applyIntent
:
function
(
handlerName
contexts
)
{
var
intent
=
new
NamedTransitionIntent
(
{
name
:
handlerName
contexts
:
contexts
}
)
;
var
state
=
this
.
activeTransition
&
&
this
.
activeTransition
.
state
|
|
this
.
state
;
return
intent
.
applyToState
(
state
this
.
recognizer
this
.
getHandler
null
this
.
getSerializer
)
;
}
isActiveIntent
:
function
(
handlerName
contexts
queryParams
_state
)
{
var
state
=
_state
|
|
this
.
state
targetHandlerInfos
=
state
.
handlerInfos
handlerInfo
len
;
if
(
!
targetHandlerInfos
.
length
)
{
return
false
;
}
var
targetHandler
=
targetHandlerInfos
[
targetHandlerInfos
.
length
-
1
]
.
name
;
var
recogHandlers
=
this
.
recognizer
.
handlersFor
(
targetHandler
)
;
var
index
=
0
;
for
(
len
=
recogHandlers
.
length
;
index
<
len
;
+
+
index
)
{
handlerInfo
=
targetHandlerInfos
[
index
]
;
if
(
handlerInfo
.
name
=
=
=
handlerName
)
{
break
;
}
}
if
(
index
=
=
=
recogHandlers
.
length
)
{
return
false
;
}
var
testState
=
new
TransitionState
(
)
;
testState
.
handlerInfos
=
targetHandlerInfos
.
slice
(
0
index
+
1
)
;
recogHandlers
=
recogHandlers
.
slice
(
0
index
+
1
)
;
var
intent
=
new
NamedTransitionIntent
(
{
name
:
targetHandler
contexts
:
contexts
}
)
;
var
newState
=
intent
.
applyToHandlers
(
testState
recogHandlers
this
.
getHandler
targetHandler
true
true
this
.
getSerializer
)
;
var
handlersEqual
=
handlerInfosEqual
(
newState
.
handlerInfos
testState
.
handlerInfos
)
;
if
(
!
queryParams
|
|
!
handlersEqual
)
{
return
handlersEqual
;
}
var
activeQPsOnNewHandler
=
{
}
;
merge
(
activeQPsOnNewHandler
queryParams
)
;
var
activeQueryParams
=
state
.
queryParams
;
for
(
var
key
in
activeQueryParams
)
{
if
(
activeQueryParams
.
hasOwnProperty
(
key
)
&
&
activeQPsOnNewHandler
.
hasOwnProperty
(
key
)
)
{
activeQPsOnNewHandler
[
key
]
=
activeQueryParams
[
key
]
;
}
}
return
handlersEqual
&
&
!
getChangelist
(
activeQPsOnNewHandler
queryParams
)
;
}
isActive
:
function
(
handlerName
)
{
var
partitionedArgs
=
extractQueryParams
(
slice
.
call
(
arguments
1
)
)
;
return
this
.
isActiveIntent
(
handlerName
partitionedArgs
[
0
]
partitionedArgs
[
1
]
)
;
}
trigger
:
function
(
)
{
var
args
=
slice
.
call
(
arguments
)
;
_trigger
(
this
this
.
currentHandlerInfos
false
args
)
;
}
log
:
null
}
;
function
fireQueryParamDidChange
(
router
newState
queryParamChangelist
)
{
if
(
queryParamChangelist
)
{
router
.
_changedQueryParams
=
queryParamChangelist
.
all
;
_trigger
(
router
newState
.
handlerInfos
true
[
'
queryParamsDidChange
'
queryParamChangelist
.
changed
queryParamChangelist
.
all
queryParamChangelist
.
removed
]
)
;
router
.
_changedQueryParams
=
null
;
}
}
function
setupContexts
(
router
newState
transition
)
{
var
partition
=
partitionHandlers
(
router
.
state
newState
)
;
var
i
l
handler
;
for
(
i
=
0
l
=
partition
.
exited
.
length
;
i
<
l
;
i
+
+
)
{
handler
=
partition
.
exited
[
i
]
.
handler
;
delete
handler
.
context
;
callHook
(
handler
'
reset
'
true
transition
)
;
callHook
(
handler
'
exit
'
transition
)
;
}
var
oldState
=
router
.
oldState
=
router
.
state
;
router
.
state
=
newState
;
var
currentHandlerInfos
=
router
.
currentHandlerInfos
=
partition
.
unchanged
.
slice
(
)
;
try
{
for
(
i
=
0
l
=
partition
.
reset
.
length
;
i
<
l
;
i
+
+
)
{
handler
=
partition
.
reset
[
i
]
.
handler
;
callHook
(
handler
'
reset
'
false
transition
)
;
}
for
(
i
=
0
l
=
partition
.
updatedContext
.
length
;
i
<
l
;
i
+
+
)
{
handlerEnteredOrUpdated
(
currentHandlerInfos
partition
.
updatedContext
[
i
]
false
transition
)
;
}
for
(
i
=
0
l
=
partition
.
entered
.
length
;
i
<
l
;
i
+
+
)
{
handlerEnteredOrUpdated
(
currentHandlerInfos
partition
.
entered
[
i
]
true
transition
)
;
}
}
catch
(
e
)
{
router
.
state
=
oldState
;
router
.
currentHandlerInfos
=
oldState
.
handlerInfos
;
throw
e
;
}
router
.
state
.
queryParams
=
finalizeQueryParamChange
(
router
currentHandlerInfos
newState
.
queryParams
transition
)
;
}
function
handlerEnteredOrUpdated
(
currentHandlerInfos
handlerInfo
enter
transition
)
{
var
handler
=
handlerInfo
.
handler
context
=
handlerInfo
.
context
;
function
_handlerEnteredOrUpdated
(
handler
)
{
if
(
enter
)
{
callHook
(
handler
'
enter
'
transition
)
;
}
if
(
transition
&
&
transition
.
isAborted
)
{
throw
new
TransitionAbortedError
(
)
;
}
handler
.
context
=
context
;
callHook
(
handler
'
contextDidChange
'
)
;
callHook
(
handler
'
setup
'
context
transition
)
;
if
(
transition
&
&
transition
.
isAborted
)
{
throw
new
TransitionAbortedError
(
)
;
}
currentHandlerInfos
.
push
(
handlerInfo
)
;
}
if
(
!
handler
)
{
handlerInfo
.
handlerPromise
=
handlerInfo
.
handlerPromise
.
then
(
_handlerEnteredOrUpdated
)
;
}
else
{
_handlerEnteredOrUpdated
(
handler
)
;
}
return
true
;
}
function
partitionHandlers
(
oldState
newState
)
{
var
oldHandlers
=
oldState
.
handlerInfos
;
var
newHandlers
=
newState
.
handlerInfos
;
var
handlers
=
{
updatedContext
:
[
]
exited
:
[
]
entered
:
[
]
unchanged
:
[
]
reset
:
undefined
}
;
var
handlerChanged
contextChanged
=
false
i
l
;
for
(
i
=
0
l
=
newHandlers
.
length
;
i
<
l
;
i
+
+
)
{
var
oldHandler
=
oldHandlers
[
i
]
newHandler
=
newHandlers
[
i
]
;
if
(
!
oldHandler
|
|
oldHandler
.
handler
!
=
=
newHandler
.
handler
)
{
handlerChanged
=
true
;
}
if
(
handlerChanged
)
{
handlers
.
entered
.
push
(
newHandler
)
;
if
(
oldHandler
)
{
handlers
.
exited
.
unshift
(
oldHandler
)
;
}
}
else
if
(
contextChanged
|
|
oldHandler
.
context
!
=
=
newHandler
.
context
)
{
contextChanged
=
true
;
handlers
.
updatedContext
.
push
(
newHandler
)
;
}
else
{
handlers
.
unchanged
.
push
(
oldHandler
)
;
}
}
for
(
i
=
newHandlers
.
length
l
=
oldHandlers
.
length
;
i
<
l
;
i
+
+
)
{
handlers
.
exited
.
unshift
(
oldHandlers
[
i
]
)
;
}
handlers
.
reset
=
handlers
.
updatedContext
.
slice
(
)
;
handlers
.
reset
.
reverse
(
)
;
return
handlers
;
}
function
updateURL
(
transition
state
)
{
var
urlMethod
=
transition
.
urlMethod
;
if
(
!
urlMethod
)
{
return
;
}
var
router
=
transition
.
router
handlerInfos
=
state
.
handlerInfos
handlerName
=
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
params
=
{
}
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
merge
(
params
handlerInfo
.
params
)
;
if
(
handlerInfo
.
handler
.
inaccessibleByURL
)
{
urlMethod
=
null
;
}
}
if
(
urlMethod
)
{
params
.
queryParams
=
transition
.
_visibleQueryParams
|
|
state
.
queryParams
;
var
url
=
router
.
recognizer
.
generate
(
handlerName
params
)
;
var
initial
=
transition
.
isCausedByInitialTransition
;
var
replaceAndNotAborting
=
urlMethod
=
=
=
'
replace
'
&
&
!
transition
.
isCausedByAbortingTransition
;
var
isQueryParamsRefreshTransition
=
transition
.
queryParamsOnly
&
&
urlMethod
=
=
=
'
replace
'
;
if
(
initial
|
|
replaceAndNotAborting
|
|
isQueryParamsRefreshTransition
)
{
router
.
replaceURL
(
url
)
;
}
else
{
router
.
updateURL
(
url
)
;
}
}
}
function
finalizeTransition
(
transition
newState
)
{
try
{
_log
(
transition
.
router
transition
.
sequence
'
Resolved
all
models
on
destination
route
;
finalizing
transition
.
'
)
;
var
router
=
transition
.
router
handlerInfos
=
newState
.
handlerInfos
;
setupContexts
(
router
newState
transition
)
;
if
(
transition
.
isAborted
)
{
router
.
state
.
handlerInfos
=
router
.
currentHandlerInfos
;
return
_rsvp
.
Promise
.
reject
(
logAbort
(
transition
)
)
;
}
updateURL
(
transition
newState
transition
.
intent
.
url
)
;
transition
.
isActive
=
false
;
router
.
activeTransition
=
null
;
_trigger
(
router
router
.
currentHandlerInfos
true
[
'
didTransition
'
]
)
;
if
(
router
.
didTransition
)
{
router
.
didTransition
(
router
.
currentHandlerInfos
)
;
}
_log
(
router
transition
.
sequence
'
TRANSITION
COMPLETE
.
'
)
;
return
handlerInfos
[
handlerInfos
.
length
-
1
]
.
handler
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
TransitionAbortedError
)
)
{
var
infos
=
transition
.
state
.
handlerInfos
;
transition
.
trigger
(
true
'
error
'
e
transition
infos
[
infos
.
length
-
1
]
.
handler
)
;
transition
.
abort
(
)
;
}
throw
e
;
}
}
function
doTransition
(
router
args
isIntermediate
)
{
var
name
=
args
[
0
]
|
|
'
/
'
;
var
lastArg
=
args
[
args
.
length
-
1
]
;
var
queryParams
=
{
}
;
if
(
lastArg
&
&
lastArg
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
pop
.
call
(
args
)
.
queryParams
;
}
var
intent
;
if
(
args
.
length
=
=
=
0
)
{
_log
(
router
'
Updating
query
params
'
)
;
var
handlerInfos
=
router
.
state
.
handlerInfos
;
intent
=
new
NamedTransitionIntent
(
{
name
:
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
contexts
:
[
]
queryParams
:
queryParams
}
)
;
}
else
if
(
name
.
charAt
(
0
)
=
=
=
'
/
'
)
{
_log
(
router
'
Attempting
URL
transition
to
'
+
name
)
;
intent
=
new
URLTransitionIntent
(
{
url
:
name
}
)
;
}
else
{
_log
(
router
'
Attempting
transition
to
'
+
name
)
;
intent
=
new
NamedTransitionIntent
(
{
name
:
args
[
0
]
contexts
:
slice
.
call
(
args
1
)
queryParams
:
queryParams
}
)
;
}
return
router
.
transitionByIntent
(
intent
isIntermediate
)
;
}
function
handlerInfosEqual
(
handlerInfos
otherHandlerInfos
)
{
if
(
handlerInfos
.
length
!
=
=
otherHandlerInfos
.
length
)
{
return
false
;
}
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
if
(
handlerInfos
[
i
]
!
=
=
otherHandlerInfos
[
i
]
)
{
return
false
;
}
}
return
true
;
}
function
handlerInfosSameExceptQueryParams
(
handlerInfos
otherHandlerInfos
)
{
if
(
handlerInfos
.
length
!
=
=
otherHandlerInfos
.
length
)
{
return
false
;
}
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
if
(
handlerInfos
[
i
]
.
name
!
=
=
otherHandlerInfos
[
i
]
.
name
)
{
return
false
;
}
if
(
!
paramsEqual
(
handlerInfos
[
i
]
.
params
otherHandlerInfos
[
i
]
.
params
)
)
{
return
false
;
}
}
return
true
;
}
function
paramsEqual
(
params
otherParams
)
{
if
(
!
params
&
&
!
otherParams
)
{
return
true
;
}
else
if
(
!
params
&
&
!
!
otherParams
|
|
!
!
params
&
&
!
otherParams
)
{
return
false
;
}
var
keys
=
Object
.
keys
(
params
)
;
var
otherKeys
=
Object
.
keys
(
otherParams
)
;
if
(
keys
.
length
!
=
=
otherKeys
.
length
)
{
return
false
;
}
for
(
var
i
=
0
len
=
keys
.
length
;
i
<
len
;
+
+
i
)
{
var
key
=
keys
[
i
]
;
if
(
params
[
key
]
!
=
=
otherParams
[
key
]
)
{
return
false
;
}
}
return
true
;
}
function
finalizeQueryParamChange
(
router
resolvedHandlers
newQueryParams
transition
)
{
for
(
var
k
in
newQueryParams
)
{
if
(
newQueryParams
.
hasOwnProperty
(
k
)
&
&
newQueryParams
[
k
]
=
=
=
null
)
{
delete
newQueryParams
[
k
]
;
}
}
var
finalQueryParamsArray
=
[
]
;
_trigger
(
router
resolvedHandlers
true
[
'
finalizeQueryParamChange
'
newQueryParams
finalQueryParamsArray
transition
]
)
;
if
(
transition
)
{
transition
.
_visibleQueryParams
=
{
}
;
}
var
finalQueryParams
=
{
}
;
for
(
var
i
=
0
len
=
finalQueryParamsArray
.
length
;
i
<
len
;
+
+
i
)
{
var
qp
=
finalQueryParamsArray
[
i
]
;
finalQueryParams
[
qp
.
key
]
=
qp
.
value
;
if
(
transition
&
&
qp
.
visible
!
=
=
false
)
{
transition
.
_visibleQueryParams
[
qp
.
key
]
=
qp
.
value
;
}
}
return
finalQueryParams
;
}
function
notifyExistingHandlers
(
router
newState
newTransition
)
{
var
oldHandlers
=
router
.
state
.
handlerInfos
changing
=
[
]
i
oldHandlerLen
oldHandler
newHandler
;
oldHandlerLen
=
oldHandlers
.
length
;
for
(
i
=
0
;
i
<
oldHandlerLen
;
i
+
+
)
{
oldHandler
=
oldHandlers
[
i
]
;
newHandler
=
newState
.
handlerInfos
[
i
]
;
if
(
!
newHandler
|
|
oldHandler
.
name
!
=
=
newHandler
.
name
)
{
break
;
}
if
(
!
newHandler
.
isResolved
)
{
changing
.
push
(
oldHandler
)
;
}
}
_trigger
(
router
oldHandlers
true
[
'
willTransition
'
newTransition
]
)
;
if
(
router
.
willTransition
)
{
router
.
willTransition
(
oldHandlers
newState
.
handlerInfos
newTransition
)
;
}
}
exports
.
Transition
=
Transition
;
exports
.
default
=
Router
;
}
)
;
enifed
(
'
rsvp
'
[
'
exports
'
'
ember
-
babel
'
'
node
-
module
'
]
function
(
exports
_emberBabel
_nodeModule
)
{
'
use
strict
'
;
exports
.
filter
=
exports
.
async
=
exports
.
map
=
exports
.
reject
=
exports
.
resolve
=
exports
.
off
=
exports
.
on
=
exports
.
configure
=
exports
.
denodeify
=
exports
.
defer
=
exports
.
rethrow
=
exports
.
hashSettled
=
exports
.
hash
=
exports
.
race
=
exports
.
allSettled
=
exports
.
all
=
exports
.
EventTarget
=
exports
.
Promise
=
exports
.
cast
=
exports
.
asap
=
undefined
;
var
_rsvp
;
function
callbacksFor
(
object
)
{
var
callbacks
=
object
.
_promiseCallbacks
;
if
(
!
callbacks
)
{
callbacks
=
object
.
_promiseCallbacks
=
{
}
;
}
return
callbacks
;
}
var
EventTarget
=
{
mixin
:
function
(
object
)
{
object
[
'
on
'
]
=
this
[
'
on
'
]
;
object
[
'
off
'
]
=
this
[
'
off
'
]
;
object
[
'
trigger
'
]
=
this
[
'
trigger
'
]
;
object
.
_promiseCallbacks
=
undefined
;
return
object
;
}
on
:
function
(
eventName
callback
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
'
Callback
must
be
a
function
'
)
;
}
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
=
void
0
;
callbacks
=
allCallbacks
[
eventName
]
;
if
(
!
callbacks
)
{
callbacks
=
allCallbacks
[
eventName
]
=
[
]
;
}
if
(
callbacks
.
indexOf
(
callback
)
)
{
callbacks
.
push
(
callback
)
;
}
}
off
:
function
(
eventName
callback
)
{
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
=
void
0
index
=
void
0
;
if
(
!
callback
)
{
allCallbacks
[
eventName
]
=
[
]
;
return
;
}
callbacks
=
allCallbacks
[
eventName
]
;
index
=
callbacks
.
indexOf
(
callback
)
;
if
(
index
!
=
=
-
1
)
{
callbacks
.
splice
(
index
1
)
;
}
}
trigger
:
function
(
eventName
options
label
)
{
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
=
void
0
callback
=
void
0
;
if
(
callbacks
=
allCallbacks
[
eventName
]
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callback
=
callbacks
[
i
]
;
callback
(
options
label
)
;
}
}
}
}
;
var
config
=
{
instrument
:
false
}
;
EventTarget
[
'
mixin
'
]
(
config
)
;
function
configure
(
name
value
)
{
if
(
arguments
.
length
=
=
=
2
)
{
config
[
name
]
=
value
;
}
else
{
return
config
[
name
]
;
}
}
var
queue
=
[
]
;
function
scheduleFlush
(
)
{
setTimeout
(
function
(
)
{
for
(
var
i
=
0
;
i
<
queue
.
length
;
i
+
+
)
{
var
entry
=
queue
[
i
]
;
var
payload
=
entry
.
payload
;
payload
.
guid
=
payload
.
key
+
payload
.
id
;
payload
.
childGuid
=
payload
.
key
+
payload
.
childId
;
if
(
payload
.
error
)
{
payload
.
stack
=
payload
.
error
.
stack
;
}
config
[
'
trigger
'
]
(
entry
.
name
entry
.
payload
)
;
}
queue
.
length
=
0
;
}
50
)
;
}
function
instrument
(
eventName
promise
child
)
{
if
(
1
=
=
=
queue
.
push
(
{
name
:
eventName
payload
:
{
key
:
promise
.
_guidKey
id
:
promise
.
_id
eventName
:
eventName
detail
:
promise
.
_result
childId
:
child
&
&
child
.
_id
label
:
promise
.
_label
timeStamp
:
Date
.
now
(
)
error
:
config
[
"
instrument
-
with
-
stack
"
]
?
new
Error
(
promise
.
_label
)
:
null
}
}
)
)
{
scheduleFlush
(
)
;
}
}
function
resolve
1
(
object
label
)
{
var
Constructor
=
this
;
if
(
object
&
&
typeof
object
=
=
=
'
object
'
&
&
object
.
constructor
=
=
=
Constructor
)
{
return
object
;
}
var
promise
=
new
Constructor
(
noop
label
)
;
resolve
(
promise
object
)
;
return
promise
;
}
function
withOwnPromise
(
)
{
return
new
TypeError
(
'
A
promises
callback
cannot
return
that
same
promise
.
'
)
;
}
function
objectOrFunction
(
x
)
{
var
type
=
typeof
x
;
return
x
!
=
=
null
&
&
(
type
=
=
=
'
object
'
|
|
type
=
=
=
'
function
'
)
;
}
function
noop
(
)
{
}
var
PENDING
=
void
0
;
var
FULFILLED
=
1
;
var
REJECTED
=
2
;
function
ErrorObject
(
)
{
this
.
error
=
null
;
}
var
GET_THEN_ERROR
=
new
ErrorObject
(
)
;
function
getThen
(
promise
)
{
try
{
return
promise
.
then
;
}
catch
(
error
)
{
GET_THEN_ERROR
.
error
=
error
;
return
GET_THEN_ERROR
;
}
}
var
TRY_CATCH_ERROR
=
new
ErrorObject
(
)
;
var
tryCatchCallback
=
void
0
;
function
tryCatcher
(
)
{
try
{
var
target
=
tryCatchCallback
;
tryCatchCallback
=
null
;
return
target
.
apply
(
this
arguments
)
;
}
catch
(
e
)
{
TRY_CATCH_ERROR
.
error
=
e
;
return
TRY_CATCH_ERROR
;
}
}
function
tryCatch
(
fn
)
{
tryCatchCallback
=
fn
;
return
tryCatcher
;
}
function
tryThen
(
then
1
value
fulfillmentHandler
rejectionHandler
)
{
try
{
then
1
.
call
(
value
fulfillmentHandler
rejectionHandler
)
;
}
catch
(
e
)
{
return
e
;
}
}
function
handleForeignThenable
(
promise
thenable
then
1
)
{
config
.
async
(
function
(
promise
)
{
var
sealed
=
false
;
var
error
=
tryThen
(
then
1
thenable
function
(
value
)
{
if
(
sealed
)
{
return
;
}
sealed
=
true
;
if
(
thenable
!
=
=
value
)
{
resolve
(
promise
value
undefined
)
;
}
else
{
fulfill
(
promise
value
)
;
}
}
function
(
reason
)
{
if
(
sealed
)
{
return
;
}
sealed
=
true
;
reject
(
promise
reason
)
;
}
'
Settle
:
'
+
(
promise
.
_label
|
|
'
unknown
promise
'
)
)
;
if
(
!
sealed
&
&
error
)
{
sealed
=
true
;
reject
(
promise
error
)
;
}
}
promise
)
;
}
function
handleOwnThenable
(
promise
thenable
)
{
if
(
thenable
.
_state
=
=
=
FULFILLED
)
{
fulfill
(
promise
thenable
.
_result
)
;
}
else
if
(
thenable
.
_state
=
=
=
REJECTED
)
{
thenable
.
_onError
=
null
;
reject
(
promise
thenable
.
_result
)
;
}
else
{
subscribe
(
thenable
undefined
function
(
value
)
{
if
(
thenable
=
=
=
value
)
{
fulfill
(
promise
value
)
;
}
else
{
resolve
(
promise
value
)
;
}
}
function
(
reason
)
{
return
reject
(
promise
reason
)
;
}
)
;
}
}
function
handleMaybeThenable
(
promise
maybeThenable
then
1
)
{
var
isOwnThenable
=
maybeThenable
.
constructor
=
=
=
promise
.
constructor
&
&
then
1
=
=
=
then
&
&
promise
.
constructor
.
resolve
=
=
=
resolve
1
;
if
(
isOwnThenable
)
{
handleOwnThenable
(
promise
maybeThenable
)
;
}
else
if
(
then
1
=
=
=
GET_THEN_ERROR
)
{
var
error
=
GET_THEN_ERROR
.
error
;
GET_THEN_ERROR
.
error
=
null
;
reject
(
promise
error
)
;
}
else
if
(
typeof
then
1
=
=
=
'
function
'
)
{
handleForeignThenable
(
promise
maybeThenable
then
1
)
;
}
else
{
fulfill
(
promise
maybeThenable
)
;
}
}
function
resolve
(
promise
value
)
{
if
(
promise
=
=
=
value
)
{
fulfill
(
promise
value
)
;
}
else
if
(
objectOrFunction
(
value
)
)
{
handleMaybeThenable
(
promise
value
getThen
(
value
)
)
;
}
else
{
fulfill
(
promise
value
)
;
}
}
function
publishRejection
(
promise
)
{
if
(
promise
.
_onError
)
{
promise
.
_onError
(
promise
.
_result
)
;
}
publish
(
promise
)
;
}
function
fulfill
(
promise
value
)
{
if
(
promise
.
_state
!
=
=
PENDING
)
{
return
;
}
promise
.
_result
=
value
;
promise
.
_state
=
FULFILLED
;
if
(
promise
.
_subscribers
.
length
=
=
=
0
)
{
if
(
config
.
instrument
)
{
instrument
(
'
fulfilled
'
promise
)
;
}
}
else
{
config
.
async
(
publish
promise
)
;
}
}
function
reject
(
promise
reason
)
{
if
(
promise
.
_state
!
=
=
PENDING
)
{
return
;
}
promise
.
_state
=
REJECTED
;
promise
.
_result
=
reason
;
config
.
async
(
publishRejection
promise
)
;
}
function
subscribe
(
parent
child
onFulfillment
onRejection
)
{
var
subscribers
=
parent
.
_subscribers
;
var
length
=
subscribers
.
length
;
parent
.
_onError
=
null
;
subscribers
[
length
]
=
child
;
subscribers
[
length
+
FULFILLED
]
=
onFulfillment
;
subscribers
[
length
+
REJECTED
]
=
onRejection
;
if
(
length
=
=
=
0
&
&
parent
.
_state
)
{
config
.
async
(
publish
parent
)
;
}
}
function
publish
(
promise
)
{
var
subscribers
=
promise
.
_subscribers
;
var
settled
=
promise
.
_state
;
if
(
config
.
instrument
)
{
instrument
(
settled
=
=
=
FULFILLED
?
'
fulfilled
'
:
'
rejected
'
promise
)
;
}
if
(
subscribers
.
length
=
=
=
0
)
{
return
;
}
var
child
=
void
0
callback
=
void
0
result
=
promise
.
_result
;
for
(
var
i
=
0
;
i
<
subscribers
.
length
;
i
+
=
3
)
{
child
=
subscribers
[
i
]
;
callback
=
subscribers
[
i
+
settled
]
;
if
(
child
)
{
invokeCallback
(
settled
child
callback
result
)
;
}
else
{
callback
(
result
)
;
}
}
promise
.
_subscribers
.
length
=
0
;
}
function
invokeCallback
(
state
promise
callback
result
)
{
var
hasCallback
=
typeof
callback
=
=
=
'
function
'
;
var
value
=
void
0
;
if
(
hasCallback
)
{
value
=
tryCatch
(
callback
)
(
result
)
;
}
else
{
value
=
result
;
}
if
(
promise
.
_state
!
=
=
PENDING
)
{
}
else
if
(
value
=
=
=
promise
)
{
reject
(
promise
withOwnPromise
(
)
)
;
}
else
if
(
value
=
=
=
TRY_CATCH_ERROR
)
{
var
error
=
value
.
error
;
value
.
error
=
null
;
reject
(
promise
error
)
;
}
else
if
(
hasCallback
)
{
resolve
(
promise
value
)
;
}
else
if
(
state
=
=
=
FULFILLED
)
{
fulfill
(
promise
value
)
;
}
else
if
(
state
=
=
=
REJECTED
)
{
reject
(
promise
value
)
;
}
}
function
initializePromise
(
promise
resolver
)
{
var
resolved
=
false
;
try
{
resolver
(
function
(
value
)
{
if
(
resolved
)
{
return
;
}
resolved
=
true
;
resolve
(
promise
value
)
;
}
function
(
reason
)
{
if
(
resolved
)
{
return
;
}
resolved
=
true
;
reject
(
promise
reason
)
;
}
)
;
}
catch
(
e
)
{
reject
(
promise
e
)
;
}
}
function
then
(
onFulfillment
onRejection
label
)
{
var
parent
=
this
;
var
state
=
parent
.
_state
;
if
(
state
=
=
=
FULFILLED
&
&
!
onFulfillment
|
|
state
=
=
=
REJECTED
&
&
!
onRejection
)
{
config
.
instrument
&
&
instrument
(
'
chained
'
parent
parent
)
;
return
parent
;
}
parent
.
_onError
=
null
;
var
child
=
new
parent
.
constructor
(
noop
label
)
;
var
result
=
parent
.
_result
;
config
.
instrument
&
&
instrument
(
'
chained
'
parent
child
)
;
if
(
state
=
=
=
PENDING
)
{
subscribe
(
parent
child
onFulfillment
onRejection
)
;
}
else
{
var
callback
=
state
=
=
=
FULFILLED
?
onFulfillment
:
onRejection
;
config
.
async
(
function
(
)
{
return
invokeCallback
(
state
child
callback
result
)
;
}
)
;
}
return
child
;
}
var
Enumerator
=
function
(
)
{
function
Enumerator
(
Constructor
input
abortOnReject
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
Enumerator
)
;
this
.
_instanceConstructor
=
Constructor
;
this
.
promise
=
new
Constructor
(
noop
label
)
;
this
.
_abortOnReject
=
abortOnReject
;
this
.
isUsingOwnPromise
=
Constructor
=
=
=
Promise
;
this
.
_init
.
apply
(
this
arguments
)
;
}
Enumerator
.
prototype
.
_init
=
function
_init
(
Constructor
input
)
{
var
len
=
input
.
length
|
|
0
;
this
.
length
=
len
;
this
.
_remaining
=
len
;
this
.
_result
=
new
Array
(
len
)
;
this
.
_enumerate
(
input
)
;
}
;
Enumerator
.
prototype
.
_enumerate
=
function
_enumerate
(
input
)
{
var
length
=
this
.
length
;
var
promise
=
this
.
promise
;
for
(
var
i
=
0
;
promise
.
_state
=
=
=
PENDING
&
&
i
<
length
;
i
+
+
)
{
this
.
_eachEntry
(
input
[
i
]
i
true
)
;
}
this
.
_checkFullfillment
(
)
;
}
;
Enumerator
.
prototype
.
_checkFullfillment
=
function
_checkFullfillment
(
)
{
if
(
this
.
_remaining
=
=
=
0
)
{
fulfill
(
this
.
promise
this
.
_result
)
;
}
}
;
Enumerator
.
prototype
.
_settleMaybeThenable
=
function
_settleMaybeThenable
(
entry
i
firstPass
)
{
var
c
=
this
.
_instanceConstructor
;
var
resolve
1
=
c
.
resolve
;
if
(
resolve
1
=
=
=
resolve
1
)
{
var
then
1
=
getThen
(
entry
)
;
if
(
then
1
=
=
=
then
&
&
entry
.
_state
!
=
=
PENDING
)
{
entry
.
_onError
=
null
;
this
.
_settledAt
(
entry
.
_state
i
entry
.
_result
firstPass
)
;
}
else
if
(
typeof
then
1
!
=
=
'
function
'
)
{
this
.
_settledAt
(
FULFILLED
i
entry
firstPass
)
;
}
else
if
(
this
.
isUsingOwnPromise
)
{
var
promise
=
new
c
(
noop
)
;
handleMaybeThenable
(
promise
entry
then
1
)
;
this
.
_willSettleAt
(
promise
i
firstPass
)
;
}
else
{
this
.
_willSettleAt
(
new
c
(
function
(
resolve
1
)
{
return
resolve
1
(
entry
)
;
}
)
i
firstPass
)
;
}
}
else
{
this
.
_willSettleAt
(
resolve
1
(
entry
)
i
firstPass
)
;
}
}
;
Enumerator
.
prototype
.
_eachEntry
=
function
_eachEntry
(
entry
i
firstPass
)
{
if
(
entry
!
=
=
null
&
&
typeof
entry
=
=
=
'
object
'
)
{
this
.
_settleMaybeThenable
(
entry
i
firstPass
)
;
}
else
{
this
.
_setResultAt
(
FULFILLED
i
entry
firstPass
)
;
}
}
;
Enumerator
.
prototype
.
_settledAt
=
function
_settledAt
(
state
i
value
firstPass
)
{
var
promise
=
this
.
promise
;
if
(
promise
.
_state
=
=
=
PENDING
)
{
if
(
this
.
_abortOnReject
&
&
state
=
=
=
REJECTED
)
{
reject
(
promise
value
)
;
}
else
{
this
.
_setResultAt
(
state
i
value
firstPass
)
;
this
.
_checkFullfillment
(
)
;
}
}
}
;
Enumerator
.
prototype
.
_setResultAt
=
function
_setResultAt
(
state
i
value
firstPass
)
{
this
.
_remaining
-
-
;
this
.
_result
[
i
]
=
value
;
}
;
Enumerator
.
prototype
.
_willSettleAt
=
function
_willSettleAt
(
promise
i
firstPass
)
{
var
_this
=
this
;
subscribe
(
promise
undefined
function
(
value
)
{
return
_this
.
_settledAt
(
FULFILLED
i
value
firstPass
)
;
}
function
(
reason
)
{
return
_this
.
_settledAt
(
REJECTED
i
reason
firstPass
)
;
}
)
;
}
;
return
Enumerator
;
}
(
)
;
function
setSettledResult
(
state
i
value
)
{
this
.
_remaining
-
-
;
if
(
state
=
=
=
FULFILLED
)
{
this
.
_result
[
i
]
=
{
state
:
'
fulfilled
'
value
:
value
}
;
}
else
{
this
.
_result
[
i
]
=
{
state
:
'
rejected
'
reason
:
value
}
;
}
}
function
all
(
entries
label
)
{
if
(
!
Array
.
isArray
(
entries
)
)
{
return
this
.
reject
(
new
TypeError
(
"
Promise
.
all
must
be
called
with
an
array
"
)
label
)
;
}
return
new
Enumerator
(
this
entries
true
label
)
.
promise
;
}
function
race
(
entries
label
)
{
var
Constructor
=
this
;
var
promise
=
new
Constructor
(
noop
label
)
;
if
(
!
Array
.
isArray
(
entries
)
)
{
reject
(
promise
new
TypeError
(
'
Promise
.
race
must
be
called
with
an
array
'
)
)
;
return
promise
;
}
for
(
var
i
=
0
;
promise
.
_state
=
=
=
PENDING
&
&
i
<
entries
.
length
;
i
+
+
)
{
subscribe
(
Constructor
.
resolve
(
entries
[
i
]
)
undefined
function
(
value
)
{
return
resolve
(
promise
value
)
;
}
function
(
reason
)
{
return
reject
(
promise
reason
)
;
}
)
;
}
return
promise
;
}
function
reject
1
(
reason
label
)
{
var
Constructor
=
this
;
var
promise
=
new
Constructor
(
noop
label
)
;
reject
(
promise
reason
)
;
return
promise
;
}
var
guidKey
=
'
rsvp_
'
+
Date
.
now
(
)
+
'
-
'
;
var
counter
=
0
;
function
needsResolver
(
)
{
throw
new
TypeError
(
'
You
must
pass
a
resolver
function
as
the
first
argument
to
the
promise
constructor
'
)
;
}
function
needsNew
(
)
{
throw
new
TypeError
(
"
Failed
to
construct
'
Promise
'
:
Please
use
the
'
new
'
operator
this
object
constructor
cannot
be
called
as
a
function
.
"
)
;
}
var
Promise
=
function
(
)
{
function
Promise
(
resolver
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
Promise
)
;
this
.
_id
=
counter
+
+
;
this
.
_label
=
label
;
this
.
_state
=
undefined
;
this
.
_result
=
undefined
;
this
.
_subscribers
=
[
]
;
config
.
instrument
&
&
instrument
(
'
created
'
this
)
;
if
(
noop
!
=
=
resolver
)
{
typeof
resolver
!
=
=
'
function
'
&
&
needsResolver
(
)
;
this
instanceof
Promise
?
initializePromise
(
this
resolver
)
:
needsNew
(
)
;
}
}
Promise
.
prototype
.
_onError
=
function
_onError
(
reason
)
{
var
_this2
=
this
;
config
.
after
(
function
(
)
{
if
(
_this2
.
_onError
)
{
config
.
trigger
(
'
error
'
reason
_this2
.
_label
)
;
}
}
)
;
}
;
Promise
.
prototype
.
catch
=
function
_catch
(
onRejection
label
)
{
return
this
.
then
(
undefined
onRejection
label
)
;
}
;
Promise
.
prototype
.
finally
=
function
_finally
(
callback
label
)
{
var
promise
=
this
;
var
constructor
=
promise
.
constructor
;
return
promise
.
then
(
function
(
value
)
{
return
constructor
.
resolve
(
callback
(
)
)
.
then
(
function
(
)
{
return
value
;
}
)
;
}
function
(
reason
)
{
return
constructor
.
resolve
(
callback
(
)
)
.
then
(
function
(
)
{
throw
reason
;
}
)
;
}
label
)
;
}
;
return
Promise
;
}
(
)
;
Promise
.
cast
=
resolve
1
;
Promise
.
all
=
all
;
Promise
.
race
=
race
;
Promise
.
resolve
=
resolve
1
;
Promise
.
reject
=
reject
1
;
Promise
.
prototype
.
_guidKey
=
guidKey
;
Promise
.
prototype
.
then
=
then
;
function
Result
(
)
{
this
.
value
=
undefined
;
}
var
ERROR
=
new
Result
(
)
;
var
GET_THEN_ERROR
1
=
new
Result
(
)
;
function
getThen
1
(
obj
)
{
try
{
return
obj
.
then
;
}
catch
(
error
)
{
ERROR
.
value
=
error
;
return
ERROR
;
}
}
function
tryApply
(
f
s
a
)
{
try
{
f
.
apply
(
s
a
)
;
}
catch
(
error
)
{
ERROR
.
value
=
error
;
return
ERROR
;
}
}
function
makeObject
(
_
argumentNames
)
{
var
obj
=
{
}
;
var
length
=
_
.
length
;
var
args
=
new
Array
(
length
)
;
for
(
var
x
=
0
;
x
<
length
;
x
+
+
)
{
args
[
x
]
=
_
[
x
]
;
}
for
(
var
i
=
0
;
i
<
argumentNames
.
length
;
i
+
+
)
{
var
name
=
argumentNames
[
i
]
;
obj
[
name
]
=
args
[
i
+
1
]
;
}
return
obj
;
}
function
arrayResult
(
_
)
{
var
length
=
_
.
length
;
var
args
=
new
Array
(
length
-
1
)
;
for
(
var
i
=
1
;
i
<
length
;
i
+
+
)
{
args
[
i
-
1
]
=
_
[
i
]
;
}
return
args
;
}
function
wrapThenable
(
then
promise
)
{
return
{
then
:
function
(
onFulFillment
onRejection
)
{
return
then
.
call
(
promise
onFulFillment
onRejection
)
;
}
}
;
}
function
denodeify
(
nodeFunc
options
)
{
var
fn
=
function
(
)
{
var
self
=
this
;
var
l
=
arguments
.
length
;
var
args
=
new
Array
(
l
+
1
)
;
var
promiseInput
=
false
;
for
(
var
i
=
0
;
i
<
l
;
+
+
i
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
promiseInput
)
{
promiseInput
=
needsPromiseInput
(
arg
)
;
if
(
promiseInput
=
=
=
GET_THEN_ERROR
1
)
{
var
p
=
new
Promise
(
noop
)
;
reject
(
p
GET_THEN_ERROR
1
.
value
)
;
return
p
;
}
else
if
(
promiseInput
&
&
promiseInput
!
=
=
true
)
{
arg
=
wrapThenable
(
promiseInput
arg
)
;
}
}
args
[
i
]
=
arg
;
}
var
promise
=
new
Promise
(
noop
)
;
args
[
l
]
=
function
(
err
val
)
{
if
(
err
)
reject
(
promise
err
)
;
else
if
(
options
=
=
=
undefined
)
resolve
(
promise
val
)
;
else
if
(
options
=
=
=
true
)
resolve
(
promise
arrayResult
(
arguments
)
)
;
else
if
(
Array
.
isArray
(
options
)
)
resolve
(
promise
makeObject
(
arguments
options
)
)
;
else
resolve
(
promise
val
)
;
}
;
if
(
promiseInput
)
{
return
handlePromiseInput
(
promise
args
nodeFunc
self
)
;
}
else
{
return
handleValueInput
(
promise
args
nodeFunc
self
)
;
}
}
;
(
0
_emberBabel
.
defaults
)
(
fn
nodeFunc
)
;
return
fn
;
}
function
handleValueInput
(
promise
args
nodeFunc
self
)
{
var
result
=
tryApply
(
nodeFunc
self
args
)
;
if
(
result
=
=
=
ERROR
)
{
reject
(
promise
result
.
value
)
;
}
return
promise
;
}
function
handlePromiseInput
(
promise
args
nodeFunc
self
)
{
return
Promise
.
all
(
args
)
.
then
(
function
(
args
)
{
var
result
=
tryApply
(
nodeFunc
self
args
)
;
if
(
result
=
=
=
ERROR
)
{
reject
(
promise
result
.
value
)
;
}
return
promise
;
}
)
;
}
function
needsPromiseInput
(
arg
)
{
if
(
arg
&
&
typeof
arg
=
=
=
'
object
'
)
{
if
(
arg
.
constructor
=
=
=
Promise
)
{
return
true
;
}
else
{
return
getThen
1
(
arg
)
;
}
}
else
{
return
false
;
}
}
function
all
1
(
array
label
)
{
return
Promise
.
all
(
array
label
)
;
}
var
AllSettled
=
function
(
_Enumerator
)
{
(
0
_emberBabel
.
inherits
)
(
AllSettled
_Enumerator
)
;
function
AllSettled
(
Constructor
entries
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
AllSettled
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Enumerator
.
call
(
this
Constructor
entries
false
label
)
)
;
}
return
AllSettled
;
}
(
Enumerator
)
;
AllSettled
.
prototype
.
_setResultAt
=
setSettledResult
;
function
allSettled
(
entries
label
)
{
if
(
!
Array
.
isArray
(
entries
)
)
{
return
Promise
.
reject
(
new
TypeError
(
"
Promise
.
allSettled
must
be
called
with
an
array
"
)
label
)
;
}
return
new
AllSettled
(
Promise
entries
label
)
.
promise
;
}
function
race
1
(
array
label
)
{
return
Promise
.
race
(
array
label
)
;
}
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
PromiseHash
=
function
(
_Enumerator2
)
{
(
0
_emberBabel
.
inherits
)
(
PromiseHash
_Enumerator2
)
;
function
PromiseHash
(
Constructor
object
)
{
var
abortOnReject
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
true
;
var
label
=
arguments
[
3
]
;
(
0
_emberBabel
.
classCallCheck
)
(
this
PromiseHash
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Enumerator2
.
call
(
this
Constructor
object
abortOnReject
label
)
)
;
}
PromiseHash
.
prototype
.
_init
=
function
_init
(
Constructor
object
)
{
this
.
_result
=
{
}
;
this
.
_enumerate
(
object
)
;
if
(
this
.
_remaining
=
=
=
0
)
{
fulfill
(
this
.
promise
this
.
_result
)
;
}
}
;
PromiseHash
.
prototype
.
_enumerate
=
function
_enumerate
(
input
)
{
var
promise
=
this
.
promise
;
var
results
=
[
]
;
for
(
var
key
in
input
)
{
if
(
hasOwnProperty
.
call
(
input
key
)
)
{
results
.
push
(
{
position
:
key
entry
:
input
[
key
]
}
)
;
}
}
var
length
=
results
.
length
;
this
.
_remaining
=
length
;
var
result
=
void
0
;
for
(
var
i
=
0
;
promise
.
_state
=
=
=
PENDING
&
&
i
<
length
;
i
+
+
)
{
result
=
results
[
i
]
;
this
.
_eachEntry
(
result
.
entry
result
.
position
)
;
}
}
;
return
PromiseHash
;
}
(
Enumerator
)
;
function
hash
(
object
label
)
{
if
(
object
=
=
=
null
|
|
typeof
object
!
=
=
'
object
'
)
{
return
Promise
.
reject
(
new
TypeError
(
"
Promise
.
hash
must
be
called
with
an
object
"
)
label
)
;
}
return
new
PromiseHash
(
Promise
object
label
)
.
promise
;
}
var
HashSettled
=
function
(
_PromiseHash
)
{
(
0
_emberBabel
.
inherits
)
(
HashSettled
_PromiseHash
)
;
function
HashSettled
(
Constructor
object
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
HashSettled
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_PromiseHash
.
call
(
this
Constructor
object
false
label
)
)
;
}
return
HashSettled
;
}
(
PromiseHash
)
;
HashSettled
.
prototype
.
_setResultAt
=
setSettledResult
;
function
hashSettled
(
object
label
)
{
if
(
object
=
=
=
null
|
|
typeof
object
!
=
=
'
object
'
)
{
return
Promise
.
reject
(
new
TypeError
(
"
RSVP
.
hashSettled
must
be
called
with
an
object
"
)
label
)
;
}
return
new
HashSettled
(
Promise
object
false
label
)
.
promise
;
}
function
rethrow
(
reason
)
{
setTimeout
(
function
(
)
{
throw
reason
;
}
)
;
throw
reason
;
}
function
defer
(
label
)
{
var
deferred
=
{
resolve
:
undefined
reject
:
undefined
}
;
deferred
.
promise
=
new
Promise
(
function
(
resolve
reject
)
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
label
)
;
return
deferred
;
}
var
MapEnumerator
=
function
(
_Enumerator3
)
{
(
0
_emberBabel
.
inherits
)
(
MapEnumerator
_Enumerator3
)
;
function
MapEnumerator
(
Constructor
entries
mapFn
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
MapEnumerator
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Enumerator3
.
call
(
this
Constructor
entries
true
label
mapFn
)
)
;
}
MapEnumerator
.
prototype
.
_init
=
function
_init
(
Constructor
input
bool
label
mapFn
)
{
var
len
=
input
.
length
|
|
0
;
this
.
length
=
len
;
this
.
_remaining
=
len
;
this
.
_result
=
new
Array
(
len
)
;
this
.
_mapFn
=
mapFn
;
this
.
_enumerate
(
input
)
;
}
;
MapEnumerator
.
prototype
.
_setResultAt
=
function
_setResultAt
(
state
i
value
firstPass
)
{
if
(
firstPass
)
{
var
val
=
tryCatch
(
this
.
_mapFn
)
(
value
i
)
;
if
(
val
=
=
=
TRY_CATCH_ERROR
)
{
this
.
_settledAt
(
REJECTED
i
val
.
error
false
)
;
}
else
{
this
.
_eachEntry
(
val
i
false
)
;
}
}
else
{
this
.
_remaining
-
-
;
this
.
_result
[
i
]
=
value
;
}
}
;
return
MapEnumerator
;
}
(
Enumerator
)
;
function
map
(
promises
mapFn
label
)
{
if
(
!
Array
.
isArray
(
promises
)
)
{
return
Promise
.
reject
(
new
TypeError
(
"
RSVP
.
map
must
be
called
with
an
array
"
)
label
)
;
}
if
(
typeof
mapFn
!
=
=
'
function
'
)
{
return
Promise
.
reject
(
new
TypeError
(
"
RSVP
.
map
expects
a
function
as
a
second
argument
"
)
label
)
;
}
return
new
MapEnumerator
(
Promise
promises
mapFn
label
)
.
promise
;
}
function
resolve
2
(
value
label
)
{
return
Promise
.
resolve
(
value
label
)
;
}
function
reject
2
(
reason
label
)
{
return
Promise
.
reject
(
reason
label
)
;
}
var
EMPTY_OBJECT
=
{
}
;
var
FilterEnumerator
=
function
(
_Enumerator4
)
{
(
0
_emberBabel
.
inherits
)
(
FilterEnumerator
_Enumerator4
)
;
function
FilterEnumerator
(
Constructor
entries
filterFn
label
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
FilterEnumerator
)
;
return
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_Enumerator4
.
call
(
this
Constructor
entries
true
label
filterFn
)
)
;
}
FilterEnumerator
.
prototype
.
_init
=
function
_init
(
Constructor
input
bool
label
filterFn
)
{
var
len
=
input
.
length
|
|
0
;
this
.
length
=
len
;
this
.
_remaining
=
len
;
this
.
_result
=
new
Array
(
len
)
;
this
.
_filterFn
=
filterFn
;
this
.
_enumerate
(
input
)
;
}
;
FilterEnumerator
.
prototype
.
_checkFullfillment
=
function
_checkFullfillment
(
)
{
if
(
this
.
_remaining
=
=
=
0
)
{
this
.
_result
=
this
.
_result
.
filter
(
function
(
val
)
{
return
val
!
=
=
EMPTY_OBJECT
;
}
)
;
fulfill
(
this
.
promise
this
.
_result
)
;
}
}
;
FilterEnumerator
.
prototype
.
_setResultAt
=
function
_setResultAt
(
state
i
value
firstPass
)
{
if
(
firstPass
)
{
this
.
_result
[
i
]
=
value
;
var
val
=
tryCatch
(
this
.
_filterFn
)
(
value
i
)
;
if
(
val
=
=
=
TRY_CATCH_ERROR
)
{
this
.
_settledAt
(
REJECTED
i
val
.
error
false
)
;
}
else
{
this
.
_eachEntry
(
val
i
false
)
;
}
}
else
{
this
.
_remaining
-
-
;
if
(
!
value
)
{
this
.
_result
[
i
]
=
EMPTY_OBJECT
;
}
}
}
;
return
FilterEnumerator
;
}
(
Enumerator
)
;
function
filter
(
promises
filterFn
label
)
{
if
(
!
Array
.
isArray
(
promises
)
&
&
!
(
promises
!
=
=
null
&
&
typeof
promises
=
=
=
'
object
'
&
&
promises
.
then
!
=
=
undefined
)
)
{
return
Promise
.
reject
(
new
TypeError
(
"
RSVP
.
filter
must
be
called
with
an
array
or
promise
"
)
label
)
;
}
if
(
typeof
filterFn
!
=
=
'
function
'
)
{
return
Promise
.
reject
(
new
TypeError
(
"
RSVP
.
filter
expects
function
as
a
second
argument
"
)
label
)
;
}
return
Promise
.
resolve
(
promises
label
)
.
then
(
function
(
promises
)
{
return
new
FilterEnumerator
(
Promise
promises
filterFn
label
)
.
promise
;
}
)
;
}
var
len
=
0
;
var
vertxNext
=
void
0
;
function
asap
(
callback
arg
)
{
queue
1
[
len
]
=
callback
;
queue
1
[
len
+
1
]
=
arg
;
len
+
=
2
;
if
(
len
=
=
=
2
)
{
scheduleFlush
1
(
)
;
}
}
var
browserWindow
=
typeof
window
!
=
=
'
undefined
'
?
window
:
undefined
;
var
browserGlobal
=
browserWindow
|
|
{
}
;
var
BrowserMutationObserver
=
browserGlobal
.
MutationObserver
|
|
browserGlobal
.
WebKitMutationObserver
;
var
isNode
=
typeof
self
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
{
}
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
var
isWorker
=
typeof
Uint8ClampedArray
!
=
=
'
undefined
'
&
&
typeof
importScripts
!
=
=
'
undefined
'
&
&
typeof
MessageChannel
!
=
=
'
undefined
'
;
function
useNextTick
(
)
{
var
nextTick
=
process
.
nextTick
;
var
version
=
process
.
versions
.
node
.
match
(
/
^
(
?
:
(
\
d
+
)
\
.
)
?
(
?
:
(
\
d
+
)
\
.
)
?
(
\
*
|
\
d
+
)
/
)
;
if
(
Array
.
isArray
(
version
)
&
&
version
[
1
]
=
=
=
'
0
'
&
&
version
[
2
]
=
=
=
'
10
'
)
{
nextTick
=
setImmediate
;
}
return
function
(
)
{
return
nextTick
(
flush
)
;
}
;
}
function
useVertxTimer
(
)
{
if
(
typeof
vertxNext
!
=
=
'
undefined
'
)
{
return
function
(
)
{
vertxNext
(
flush
)
;
}
;
}
return
useSetTimeout
(
)
;
}
function
useMutationObserver
(
)
{
var
iterations
=
0
;
var
observer
=
new
BrowserMutationObserver
(
flush
)
;
var
node
=
document
.
createTextNode
(
'
'
)
;
observer
.
observe
(
node
{
characterData
:
true
}
)
;
return
function
(
)
{
return
node
.
data
=
iterations
=
+
+
iterations
%
2
;
}
;
}
function
useMessageChannel
(
)
{
var
channel
=
new
MessageChannel
(
)
;
channel
.
port1
.
onmessage
=
flush
;
return
function
(
)
{
return
channel
.
port2
.
postMessage
(
0
)
;
}
;
}
function
useSetTimeout
(
)
{
return
function
(
)
{
return
setTimeout
(
flush
1
)
;
}
;
}
var
queue
1
=
new
Array
(
1000
)
;
function
flush
(
)
{
for
(
var
i
=
0
;
i
<
len
;
i
+
=
2
)
{
var
callback
=
queue
1
[
i
]
;
var
arg
=
queue
1
[
i
+
1
]
;
callback
(
arg
)
;
queue
1
[
i
]
=
undefined
;
queue
1
[
i
+
1
]
=
undefined
;
}
len
=
0
;
}
function
attemptVertex
(
)
{
try
{
var
r
=
_nodeModule
.
require
;
var
vertx
=
r
(
'
vertx
'
)
;
vertxNext
=
vertx
.
runOnLoop
|
|
vertx
.
runOnContext
;
return
useVertxTimer
(
)
;
}
catch
(
e
)
{
return
useSetTimeout
(
)
;
}
}
var
scheduleFlush
1
=
void
0
;
if
(
isNode
)
{
scheduleFlush
1
=
useNextTick
(
)
;
}
else
if
(
BrowserMutationObserver
)
{
scheduleFlush
1
=
useMutationObserver
(
)
;
}
else
if
(
isWorker
)
{
scheduleFlush
1
=
useMessageChannel
(
)
;
}
else
if
(
browserWindow
=
=
=
undefined
&
&
typeof
_nodeModule
.
require
=
=
=
'
function
'
)
{
scheduleFlush
1
=
attemptVertex
(
)
;
}
else
{
scheduleFlush
1
=
useSetTimeout
(
)
;
}
if
(
typeof
self
=
=
=
'
object
'
)
{
}
else
if
(
typeof
global
=
=
=
'
object
'
)
{
}
else
{
throw
new
Error
(
'
no
global
:
self
or
global
found
'
)
;
}
config
.
async
=
asap
;
config
.
after
=
function
(
cb
)
{
return
setTimeout
(
cb
0
)
;
}
;
var
cast
=
resolve
2
;
var
async
=
function
(
callback
arg
)
{
return
config
.
async
(
callback
arg
)
;
}
;
function
on
(
)
{
config
[
'
on
'
]
.
apply
(
config
arguments
)
;
}
function
off
(
)
{
config
[
'
off
'
]
.
apply
(
config
arguments
)
;
}
if
(
typeof
window
!
=
=
'
undefined
'
&
&
typeof
window
[
'
__PROMISE_INSTRUMENTATION__
'
]
=
=
=
'
object
'
)
{
var
callbacks
=
window
[
'
__PROMISE_INSTRUMENTATION__
'
]
;
configure
(
'
instrument
'
true
)
;
for
(
var
eventName
in
callbacks
)
{
if
(
callbacks
.
hasOwnProperty
(
eventName
)
)
{
on
(
eventName
callbacks
[
eventName
]
)
;
}
}
}
var
rsvp
=
(
_rsvp
=
{
asap
:
asap
cast
:
cast
Promise
:
Promise
EventTarget
:
EventTarget
all
:
all
1
allSettled
:
allSettled
race
:
race
1
hash
:
hash
hashSettled
:
hashSettled
rethrow
:
rethrow
defer
:
defer
denodeify
:
denodeify
configure
:
configure
on
:
on
off
:
off
resolve
:
resolve
2
reject
:
reject
2
map
:
map
}
_rsvp
[
'
async
'
]
=
async
_rsvp
.
filter
=
filter
_rsvp
)
;
exports
.
asap
=
asap
;
exports
.
cast
=
cast
;
exports
.
Promise
=
Promise
;
exports
.
EventTarget
=
EventTarget
;
exports
.
all
=
all
1
;
exports
.
allSettled
=
allSettled
;
exports
.
race
=
race
1
;
exports
.
hash
=
hash
;
exports
.
hashSettled
=
hashSettled
;
exports
.
rethrow
=
rethrow
;
exports
.
defer
=
defer
;
exports
.
denodeify
=
denodeify
;
exports
.
configure
=
configure
;
exports
.
on
=
on
;
exports
.
off
=
off
;
exports
.
resolve
=
resolve
2
;
exports
.
reject
=
reject
2
;
exports
.
map
=
map
;
exports
.
async
=
async
;
exports
.
filter
=
filter
;
exports
.
default
=
rsvp
;
}
)
;
requireModule
(
'
ember
'
)
}
(
)
)
;
;
(
function
(
)
{
define
(
'
ember
-
cli
-
shims
/
deprecations
'
[
]
function
(
)
{
var
values
=
{
"
ember
-
application
"
:
{
"
default
"
:
[
"
ember
/
application
"
]
}
"
ember
-
array
"
:
{
"
default
"
:
[
"
ember
/
array
"
]
}
"
ember
-
array
/
mutable
"
:
{
"
default
"
:
[
"
ember
/
array
/
mutable
"
]
}
"
ember
-
array
/
utils
"
:
{
"
A
"
:
[
"
ember
/
array
"
"
A
"
]
"
isEmberArray
"
:
[
"
ember
/
array
"
"
isArray
"
]
"
wrap
"
:
[
"
ember
/
array
"
"
makeArray
"
]
}
"
ember
-
component
"
:
{
"
default
"
:
[
"
ember
/
component
"
]
}
"
ember
-
components
/
checkbox
"
:
{
"
default
"
:
[
"
ember
/
component
/
checkbox
"
]
}
"
ember
-
components
/
text
-
area
"
:
{
"
default
"
:
[
"
ember
/
component
/
text
-
area
"
]
}
"
ember
-
components
/
text
-
field
"
:
{
"
default
"
:
[
"
ember
/
component
/
text
-
field
"
]
}
"
ember
-
controller
"
:
{
"
default
"
:
[
"
ember
/
controller
"
]
}
"
ember
-
controller
/
inject
"
:
{
"
default
"
:
[
"
ember
/
controller
"
"
inject
"
]
}
"
ember
-
controller
/
proxy
"
:
{
"
default
"
:
[
"
ember
/
array
/
proxy
"
]
}
"
ember
-
debug
"
:
{
"
log
"
:
[
"
ember
/
debug
"
"
debug
"
]
"
inspect
"
:
[
"
ember
/
debug
"
"
inspect
"
]
"
run
"
:
[
"
ember
/
debug
"
"
runInDebug
"
]
"
warn
"
:
[
"
ember
/
debug
"
"
warn
"
]
}
"
ember
-
debug
/
container
-
debug
-
adapter
"
:
{
"
default
"
:
[
"
ember
/
debug
/
container
-
debug
-
adapter
"
]
}
"
ember
-
debug
/
data
-
adapter
"
:
{
"
default
"
:
[
"
ember
/
debug
/
data
-
adapter
"
]
}
"
ember
-
deprecations
"
:
{
"
deprecate
"
:
[
"
ember
/
application
/
deprecations
"
"
deprecate
"
]
"
deprecateFunc
"
:
[
"
ember
/
application
/
deprecations
"
"
deprecateFunc
"
]
}
"
ember
-
enumerable
"
:
{
"
default
"
:
[
"
ember
/
enumerable
"
]
}
"
ember
-
evented
"
:
{
"
default
"
:
[
"
ember
/
object
/
evented
"
]
}
"
ember
-
evented
/
on
"
:
{
"
default
"
:
[
"
ember
/
object
/
evented
"
"
on
"
]
}
"
ember
-
globals
-
resolver
"
:
{
"
default
"
:
[
"
ember
/
application
/
globals
-
resolver
"
]
}
"
ember
-
helper
"
:
{
"
default
"
:
[
"
ember
/
component
/
helper
"
]
"
helper
"
:
[
"
ember
/
component
/
helper
"
"
helper
"
]
}
"
ember
-
instrumentation
"
:
{
"
instrument
"
:
[
"
ember
/
instrumentation
"
"
instrument
"
]
"
reset
"
:
[
"
ember
/
instrumentation
"
"
reset
"
]
"
subscribe
"
:
[
"
ember
/
instrumentation
"
"
subscribe
"
]
"
unsubscribe
"
:
[
"
ember
/
instrumentation
"
"
unsubscribe
"
]
}
"
ember
-
locations
/
hash
"
:
{
"
default
"
:
[
"
ember
/
routing
/
hash
-
location
"
]
}
"
ember
-
locations
/
history
"
:
{
"
default
"
:
[
"
ember
/
routing
/
history
-
location
"
]
}
"
ember
-
locations
/
none
"
:
{
"
default
"
:
[
"
ember
/
routing
/
none
-
location
"
]
}
"
ember
-
map
"
:
{
"
default
"
:
[
"
ember
/
map
"
]
"
withDefault
"
:
[
"
ember
/
map
/
with
-
default
"
]
}
"
ember
-
metal
/
events
"
:
{
"
addListener
"
:
[
"
ember
/
object
/
events
"
"
addListener
"
]
"
removeListener
"
:
[
"
ember
/
object
/
events
"
"
removeListener
"
]
"
send
"
:
[
"
ember
/
object
/
events
"
"
sendEvent
"
]
}
"
ember
-
metal
/
get
"
:
{
"
default
"
:
[
"
ember
/
object
"
"
get
"
]
"
getProperties
"
:
[
"
ember
/
object
"
"
getProperties
"
]
}
"
ember
-
metal
/
mixin
"
:
{
"
default
"
:
[
"
ember
/
object
/
mixin
"
]
}
"
ember
-
metal
/
observer
"
:
{
"
default
"
:
[
"
ember
/
object
"
"
observer
"
]
"
addObserver
"
:
[
"
ember
/
object
/
observers
"
"
addObserver
"
]
"
removeObserver
"
:
[
"
ember
/
object
/
observers
"
"
removeObserver
"
]
}
"
ember
-
metal
/
on
-
load
"
:
{
"
default
"
:
[
"
ember
/
application
"
"
onLoad
"
]
"
run
"
:
[
"
ember
/
application
"
"
runLoadHooks
"
]
}
"
ember
-
metal
/
set
"
:
{
"
default
"
:
[
"
ember
/
object
"
"
set
"
]
"
setProperties
"
:
[
"
ember
/
object
"
"
setProperties
"
]
"
trySet
"
:
[
"
ember
/
object
"
"
trySet
"
]
}
"
ember
-
metal
/
utils
"
:
{
"
aliasMethod
"
:
[
"
ember
/
object
"
"
aliasMethod
"
]
"
assert
"
:
[
"
ember
/
debug
"
"
assert
"
]
"
cacheFor
"
:
[
"
ember
/
object
/
internals
"
"
cacheFor
"
]
"
copy
"
:
[
"
ember
/
object
/
internals
"
"
copy
"
]
"
guidFor
"
:
[
"
ember
/
object
/
internals
"
"
guidFor
"
]
}
"
ember
-
object
"
:
{
"
default
"
:
[
"
ember
/
object
"
]
}
"
ember
-
owner
/
get
"
:
{
"
default
"
:
[
"
ember
/
application
"
"
getOwner
"
]
}
"
ember
-
owner
/
set
"
:
{
"
default
"
:
[
"
ember
/
application
"
"
setOwner
"
]
}
"
ember
-
platform
"
:
{
"
assign
"
:
[
"
ember
/
polyfills
"
"
assign
"
]
"
create
"
:
[
"
ember
/
polyfills
"
"
create
"
]
"
hasAccessors
"
:
[
"
ember
/
polyfills
"
"
hasPropertyAccessors
"
]
"
keys
"
:
[
"
ember
/
polyfills
"
"
keys
"
]
}
"
ember
-
route
"
:
{
"
default
"
:
[
"
ember
/
routing
/
route
"
]
}
"
ember
-
router
"
:
{
"
default
"
:
[
"
ember
/
routing
/
router
"
]
}
"
ember
-
runloop
"
:
{
"
default
"
:
[
"
ember
/
runloop
"
"
run
"
]
"
begin
"
:
[
"
ember
/
runloop
"
"
begin
"
]
"
bind
"
:
[
"
ember
/
runloop
"
"
bind
"
]
"
cancel
"
:
[
"
ember
/
runloop
"
"
cancel
"
]
"
debounce
"
:
[
"
ember
/
runloop
"
"
debounce
"
]
"
end
"
:
[
"
ember
/
runloop
"
"
end
"
]
"
join
"
:
[
"
ember
/
runloop
"
"
join
"
]
"
later
"
:
[
"
ember
/
runloop
"
"
later
"
]
"
next
"
:
[
"
ember
/
runloop
"
"
next
"
]
"
once
"
:
[
"
ember
/
runloop
"
"
once
"
]
"
schedule
"
:
[
"
ember
/
runloop
"
"
schedule
"
]
"
scheduleOnce
"
:
[
"
ember
/
runloop
"
"
scheduleOnce
"
]
"
throttle
"
:
[
"
ember
/
runloop
"
"
throttle
"
]
}
"
ember
-
service
"
:
{
"
default
"
:
[
"
ember
/
service
"
]
}
"
ember
-
service
/
inject
"
:
{
"
default
"
:
[
"
ember
/
service
"
"
inject
"
]
}
"
ember
-
string
"
:
{
"
camelize
"
:
[
"
ember
/
string
"
"
camelize
"
]
"
capitalize
"
:
[
"
ember
/
string
"
"
capitalize
"
]
"
classify
"
:
[
"
ember
/
string
"
"
classify
"
]
"
dasherize
"
:
[
"
ember
/
string
"
"
dasherize
"
]
"
decamelize
"
:
[
"
ember
/
string
"
"
decamelize
"
]
"
fmt
"
:
[
"
ember
/
string
"
"
fmt
"
]
"
htmlSafe
"
:
[
"
ember
/
string
"
"
htmlSafe
"
]
"
loc
"
:
[
"
ember
/
string
"
"
loc
"
]
"
underscore
"
:
[
"
ember
/
string
"
"
underscore
"
]
"
w
"
:
[
"
ember
/
string
"
"
w
"
]
}
"
ember
-
utils
"
:
{
"
isBlank
"
:
[
"
ember
/
utils
"
"
isBlank
"
]
"
isEmpty
"
:
[
"
ember
/
utils
"
"
isEmpty
"
]
"
isNone
"
:
[
"
ember
/
utils
"
"
isNone
"
]
"
isPresent
"
:
[
"
ember
/
utils
"
"
isPresent
"
]
"
tryInvoke
"
:
[
"
ember
/
utils
"
"
tryInvoke
"
]
"
typeOf
"
:
[
"
ember
/
utils
"
"
typeOf
"
]
}
"
ember
-
computed
"
:
{
"
default
"
:
[
"
ember
/
object
"
"
computed
"
]
"
empty
"
:
[
"
ember
/
object
/
computed
"
"
empty
"
]
"
notEmpty
"
:
[
"
ember
/
object
/
computed
"
"
notEmpty
"
]
"
none
"
:
[
"
ember
/
object
/
computed
"
"
none
"
]
"
not
"
:
[
"
ember
/
object
/
computed
"
"
not
"
]
"
bool
"
:
[
"
ember
/
object
/
computed
"
"
bool
"
]
"
match
"
:
[
"
ember
/
object
/
computed
"
"
match
"
]
"
equal
"
:
[
"
ember
/
object
/
computed
"
"
equal
"
]
"
gt
"
:
[
"
ember
/
object
/
computed
"
"
gt
"
]
"
gte
"
:
[
"
ember
/
object
/
computed
"
"
gte
"
]
"
lt
"
:
[
"
ember
/
object
/
computed
"
"
lt
"
]
"
lte
"
:
[
"
ember
/
object
/
computed
"
"
lte
"
]
"
alias
"
:
[
"
ember
/
object
/
computed
"
"
alias
"
]
"
oneWay
"
:
[
"
ember
/
object
/
computed
"
"
oneWay
"
]
"
reads
"
:
[
"
ember
/
object
/
computed
"
"
reads
"
]
"
readOnly
"
:
[
"
ember
/
object
/
computed
"
"
readOnly
"
]
"
deprecatingAlias
"
:
[
"
ember
/
object
/
computed
"
"
deprecatingAlias
"
]
"
and
"
:
[
"
ember
/
object
/
computed
"
"
and
"
]
"
or
"
:
[
"
ember
/
object
/
computed
"
"
or
"
]
"
collect
"
:
[
"
ember
/
object
/
computed
"
"
collect
"
]
"
sum
"
:
[
"
ember
/
object
/
computed
"
"
sum
"
]
"
min
"
:
[
"
ember
/
object
/
computed
"
"
min
"
]
"
max
"
:
[
"
ember
/
object
/
computed
"
"
max
"
]
"
map
"
:
[
"
ember
/
object
/
computed
"
"
map
"
]
"
sort
"
:
[
"
ember
/
object
/
computed
"
"
sort
"
]
"
setDiff
"
:
[
"
ember
/
object
/
computed
"
"
setDiff
"
]
"
mapBy
"
:
[
"
ember
/
object
/
computed
"
"
mapBy
"
]
"
mapProperty
"
:
[
"
ember
/
object
/
computed
"
"
mapProperty
"
]
"
filter
"
:
[
"
ember
/
object
/
computed
"
"
filter
"
]
"
filterBy
"
:
[
"
ember
/
object
/
computed
"
"
filterBy
"
]
"
filterProperty
"
:
[
"
ember
/
object
/
computed
"
"
filterProperty
"
]
"
uniq
"
:
[
"
ember
/
object
/
computed
"
"
uniq
"
]
"
union
"
:
[
"
ember
/
object
/
computed
"
"
union
"
]
"
intersect
"
:
[
"
ember
/
object
/
computed
"
"
intersect
"
]
}
"
ember
-
test
/
adapter
"
:
{
"
default
"
:
[
"
ember
/
test
/
adapter
"
]
}
}
;
Object
.
defineProperty
(
values
'
__esModule
'
{
value
:
true
}
)
;
return
values
;
}
)
;
}
)
(
)
;
;
(
function
(
)
{
function
processEmberShims
(
)
{
var
shims
=
{
'
ember
-
application
'
:
{
'
default
'
:
Ember
.
Application
}
'
ember
-
array
'
:
{
'
default
'
:
Ember
.
Array
}
'
ember
-
array
/
mutable
'
:
{
'
default
'
:
Ember
.
MutableArray
}
'
ember
-
array
/
utils
'
:
{
'
A
'
:
Ember
.
A
'
isEmberArray
'
:
Ember
.
isArray
'
wrap
'
:
Ember
.
makeArray
}
'
ember
-
component
'
:
{
'
default
'
:
Ember
.
Component
}
'
ember
-
components
/
checkbox
'
:
{
'
default
'
:
Ember
.
Checkbox
}
'
ember
-
components
/
text
-
area
'
:
{
'
default
'
:
Ember
.
TextArea
}
'
ember
-
components
/
text
-
field
'
:
{
'
default
'
:
Ember
.
TextField
}
'
ember
-
controller
'
:
{
'
default
'
:
Ember
.
Controller
}
'
ember
-
controller
/
inject
'
:
{
'
default
'
:
Ember
.
inject
.
controller
}
'
ember
-
controller
/
proxy
'
:
{
'
default
'
:
Ember
.
ArrayProxy
}
'
ember
-
controllers
/
sortable
'
:
{
'
default
'
:
Ember
.
SortableMixin
}
'
ember
-
debug
'
:
{
'
log
'
:
Ember
.
debug
'
inspect
'
:
Ember
.
inspect
'
run
'
:
Ember
.
runInDebug
'
warn
'
:
Ember
.
warn
}
'
ember
-
debug
/
container
-
debug
-
adapter
'
:
{
'
default
'
:
Ember
.
ContainerDebugAdapter
}
'
ember
-
debug
/
data
-
adapter
'
:
{
'
default
'
:
Ember
.
DataAdapter
}
'
ember
-
deprecations
'
:
{
'
deprecate
'
:
Ember
.
deprecate
'
deprecateFunc
'
:
Ember
.
deprecateFunc
}
'
ember
-
enumerable
'
:
{
'
default
'
:
Ember
.
Enumerable
}
'
ember
-
evented
'
:
{
'
default
'
:
Ember
.
Evented
}
'
ember
-
evented
/
on
'
:
{
'
default
'
:
Ember
.
on
}
'
ember
-
globals
-
resolver
'
:
{
'
default
'
:
Ember
.
DefaultResolver
}
'
ember
-
helper
'
:
{
'
default
'
:
Ember
.
Helper
'
helper
'
:
Ember
.
Helper
&
&
Ember
.
Helper
.
helper
}
'
ember
-
instrumentation
'
:
{
'
instrument
'
:
Ember
.
Instrumentation
.
instrument
'
reset
'
:
Ember
.
Instrumentation
.
reset
'
subscribe
'
:
Ember
.
Instrumentation
.
subscribe
'
unsubscribe
'
:
Ember
.
Instrumentation
.
unsubscribe
}
'
ember
-
locations
/
hash
'
:
{
'
default
'
:
Ember
.
HashLocation
}
'
ember
-
locations
/
history
'
:
{
'
default
'
:
Ember
.
HistoryLocation
}
'
ember
-
locations
/
none
'
:
{
'
default
'
:
Ember
.
NoneLocation
}
'
ember
-
map
'
:
{
'
default
'
:
Ember
.
Map
'
withDefault
'
:
Ember
.
MapWithDefault
}
'
ember
-
metal
/
destroy
'
:
{
'
default
'
:
Ember
.
destroy
}
'
ember
-
metal
/
events
'
:
{
'
addListener
'
:
Ember
.
addListener
'
removeListener
'
:
Ember
.
removeListener
'
send
'
:
Ember
.
sendEvent
}
'
ember
-
metal
/
get
'
:
{
'
default
'
:
Ember
.
get
'
getProperties
'
:
Ember
.
getProperties
}
'
ember
-
metal
/
mixin
'
:
{
'
default
'
:
Ember
.
Mixin
}
'
ember
-
metal
/
observer
'
:
{
'
default
'
:
Ember
.
observer
'
addObserver
'
:
Ember
.
addObserver
'
removeObserver
'
:
Ember
.
removeObserver
}
'
ember
-
metal
/
on
-
load
'
:
{
'
default
'
:
Ember
.
onLoad
'
run
'
:
Ember
.
runLoadHooks
}
'
ember
-
metal
/
set
'
:
{
'
default
'
:
Ember
.
set
'
setProperties
'
:
Ember
.
setProperties
'
trySet
'
:
Ember
.
trySet
}
'
ember
-
metal
/
utils
'
:
{
'
aliasMethod
'
:
Ember
.
aliasMethod
'
assert
'
:
Ember
.
assert
'
cacheFor
'
:
Ember
.
cacheFor
'
copy
'
:
Ember
.
copy
'
guidFor
'
:
Ember
.
guidFor
}
'
ember
-
object
'
:
{
'
default
'
:
Ember
.
Object
}
'
ember
-
owner
/
get
'
:
{
'
default
'
:
Ember
.
getOwner
}
'
ember
-
owner
/
set
'
:
{
'
default
'
:
Ember
.
setOwner
}
'
ember
-
platform
'
:
{
'
assign
'
:
Ember
.
assign
|
|
Ember
.
merge
'
create
'
:
Ember
.
create
'
defineProperty
'
:
Ember
.
platform
.
defineProperty
'
hasAccessors
'
:
Ember
.
platform
.
hasPropertyAccessors
'
keys
'
:
Ember
.
keys
}
'
ember
-
route
'
:
{
'
default
'
:
Ember
.
Route
}
'
ember
-
router
'
:
{
'
default
'
:
Ember
.
Router
}
'
ember
-
runloop
'
:
{
'
default
'
:
Ember
.
run
'
begin
'
:
Ember
.
run
.
begin
'
bind
'
:
Ember
.
run
.
bind
'
cancel
'
:
Ember
.
run
.
cancel
'
debounce
'
:
Ember
.
run
.
debounce
'
end
'
:
Ember
.
run
.
end
'
join
'
:
Ember
.
run
.
join
'
later
'
:
Ember
.
run
.
later
'
next
'
:
Ember
.
run
.
next
'
once
'
:
Ember
.
run
.
once
'
schedule
'
:
Ember
.
run
.
schedule
'
scheduleOnce
'
:
Ember
.
run
.
scheduleOnce
'
throttle
'
:
Ember
.
run
.
throttle
}
'
ember
-
service
'
:
{
'
default
'
:
Ember
.
Service
}
'
ember
-
service
/
inject
'
:
{
'
default
'
:
Ember
.
inject
.
service
}
'
ember
-
set
/
ordered
'
:
{
'
default
'
:
Ember
.
OrderedSet
}
'
ember
-
string
'
:
{
'
camelize
'
:
Ember
.
String
.
camelize
'
capitalize
'
:
Ember
.
String
.
capitalize
'
classify
'
:
Ember
.
String
.
classify
'
dasherize
'
:
Ember
.
String
.
dasherize
'
decamelize
'
:
Ember
.
String
.
decamelize
'
fmt
'
:
Ember
.
String
.
fmt
'
htmlSafe
'
:
Ember
.
String
.
htmlSafe
'
loc
'
:
Ember
.
String
.
loc
'
underscore
'
:
Ember
.
String
.
underscore
'
w
'
:
Ember
.
String
.
w
}
'
ember
-
utils
'
:
{
'
isBlank
'
:
Ember
.
isBlank
'
isEmpty
'
:
Ember
.
isEmpty
'
isNone
'
:
Ember
.
isNone
'
isPresent
'
:
Ember
.
isPresent
'
tryInvoke
'
:
Ember
.
tryInvoke
'
typeOf
'
:
Ember
.
typeOf
}
}
;
shims
[
'
ember
-
computed
'
]
=
{
'
default
'
:
Ember
.
computed
}
;
var
computedMacros
=
[
"
empty
"
"
notEmpty
"
"
none
"
"
not
"
"
bool
"
"
match
"
"
equal
"
"
gt
"
"
gte
"
"
lt
"
"
lte
"
"
alias
"
"
oneWay
"
"
reads
"
"
readOnly
"
"
deprecatingAlias
"
"
and
"
"
or
"
"
collect
"
"
sum
"
"
min
"
"
max
"
"
map
"
"
sort
"
"
setDiff
"
"
mapBy
"
"
mapProperty
"
"
filter
"
"
filterBy
"
"
filterProperty
"
"
uniq
"
"
union
"
"
intersect
"
]
;
for
(
var
i
=
0
l
=
computedMacros
.
length
;
i
<
l
;
i
+
+
)
{
var
key
=
computedMacros
[
i
]
;
shims
[
'
ember
-
computed
'
]
[
key
]
=
Ember
.
computed
[
key
]
;
}
for
(
var
moduleName
in
shims
)
{
generateModule
(
moduleName
shims
[
moduleName
]
true
)
;
}
}
function
processTestShims
(
)
{
if
(
Ember
.
Test
)
{
var
testShims
=
{
'
ember
-
test
'
:
{
'
default
'
:
Ember
.
Test
}
'
ember
-
test
/
adapter
'
:
{
'
default
'
:
Ember
.
Test
.
Adapter
}
'
ember
-
test
/
qunit
-
adapter
'
:
{
'
default
'
:
Ember
.
Test
.
QUnitAdapter
}
}
;
for
(
var
moduleName
in
testShims
)
{
generateModule
(
moduleName
testShims
[
moduleName
]
)
;
}
}
}
function
generateModule
(
name
values
deprecated
)
{
define
(
name
[
'
ember
-
cli
-
shims
/
deprecations
'
]
function
(
deprecations
)
{
'
use
strict
'
;
if
(
deprecated
)
{
var
moduleDeprecations
=
deprecations
[
name
]
;
var
message
=
'
Importing
from
the
'
+
name
+
'
module
has
been
deprecated
.
'
;
if
(
moduleDeprecations
)
{
message
+
=
'
Please
use
the
new
module
imports
:
\
n
\
n
'
;
Object
.
keys
(
moduleDeprecations
)
.
forEach
(
function
(
key
)
{
var
newImport
=
moduleDeprecations
[
key
]
;
if
(
newImport
[
1
]
)
{
message
+
=
'
import
{
'
+
newImport
[
1
]
+
'
}
from
\
'
'
+
newImport
[
0
]
+
'
\
'
\
n
'
;
}
else
{
var
importName
=
Ember
.
String
.
classify
(
newImport
[
0
]
.
split
(
'
/
'
)
.
pop
(
)
)
;
message
+
=
'
import
'
+
importName
+
'
from
\
'
'
+
newImport
[
0
]
+
'
\
'
\
n
'
;
}
}
)
;
message
+
=
'
\
n
'
;
}
else
{
message
+
=
'
Please
use
globals
instead
.
'
;
}
Ember
.
deprecate
(
message
false
{
id
:
'
ember
-
cli
-
shims
.
deprecated
-
shims
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
github
.
com
/
emberjs
/
rfcs
/
blob
/
master
/
text
/
0176
-
javascript
-
module
-
api
.
md
'
}
)
;
}
Object
.
defineProperty
(
values
'
__esModule
'
{
value
:
true
}
)
;
return
values
;
}
)
;
}
generateModule
(
'
ember
'
{
default
:
Ember
}
)
;
processEmberShims
(
)
;
processTestShims
(
)
;
generateModule
(
'
jquery
'
{
'
default
'
:
self
.
jQuery
}
)
;
generateModule
(
'
rsvp
'
{
'
default
'
:
Ember
.
RSVP
}
)
;
}
)
(
)
;
;
function
createDeprecatedModule
(
moduleId
)
{
define
(
moduleId
[
'
exports
'
'
ember
-
resolver
/
resolver
'
'
ember
'
]
function
(
exports
Resolver
Ember
)
{
Ember
[
'
default
'
]
.
deprecate
(
'
Usage
of
'
+
moduleId
+
'
module
is
deprecated
please
update
to
ember
-
resolver
.
'
false
{
id
:
'
ember
-
resolver
.
legacy
-
shims
'
until
:
'
3
.
0
.
0
'
}
)
;
exports
[
'
default
'
]
=
Resolver
[
'
default
'
]
;
}
)
;
}
createDeprecatedModule
(
'
ember
/
resolver
'
)
;
createDeprecatedModule
(
'
resolver
'
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
promise
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
class
AJAXPromise
extends
Ember
.
RSVP
.
Promise
{
then
(
)
{
const
child
=
super
.
then
(
.
.
.
arguments
)
;
child
.
xhr
=
this
.
xhr
;
return
child
;
}
}
exports
.
default
=
AJAXPromise
;
}
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
utils
/
get
-
header
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
getHeader
;
function
getHeader
(
headers
name
)
{
if
(
Ember
.
isNone
(
headers
)
|
|
Ember
.
isNone
(
name
)
)
{
return
;
}
const
matchedKey
=
Ember
.
A
(
Object
.
keys
(
headers
)
)
.
find
(
key
=
>
{
return
key
.
toLowerCase
(
)
=
=
=
name
.
toLowerCase
(
)
;
}
)
;
return
headers
[
matchedKey
]
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
utils
/
is
-
fastboot
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
isFastBoot
=
typeof
FastBoot
!
=
=
'
undefined
'
;
exports
.
default
=
isFastBoot
;
}
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
utils
/
is
-
string
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
isString
;
function
isString
(
object
)
{
return
typeof
object
=
=
=
'
string
'
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
utils
/
parse
-
response
-
headers
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
parseResponseHeaders
;
const
CRLF
=
exports
.
CRLF
=
'
\
u000d
\
u000a
'
;
function
parseResponseHeaders
(
headersString
)
{
const
headers
=
{
}
;
if
(
!
headersString
)
{
return
headers
;
}
return
headersString
.
split
(
CRLF
)
.
reduce
(
(
hash
header
)
=
>
{
let
[
field
.
.
.
value
]
=
header
.
split
(
'
:
'
)
;
field
=
field
.
trim
(
)
;
value
=
value
.
join
(
'
:
'
)
.
trim
(
)
;
if
(
value
)
{
hash
[
field
]
=
value
;
}
return
hash
;
}
headers
)
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
-
private
/
utils
/
url
-
helpers
'
[
'
exports
'
'
require
'
'
ember
-
ajax
/
-
private
/
utils
/
is
-
fastboot
'
]
function
(
exports
_require2
_isFastboot
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
parseURL
=
parseURL
;
exports
.
isFullURL
=
isFullURL
;
exports
.
haveSameHost
=
haveSameHost
;
const
completeUrlRegex
=
/
^
(
http
|
https
)
/
;
const
isNode
=
typeof
self
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
{
}
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
const
url
=
function
(
)
{
if
(
_isFastboot
.
default
)
{
return
URL
;
}
if
(
isNode
)
{
return
(
0
_require2
.
default
)
(
'
url
'
)
;
}
return
document
.
createElement
(
'
a
'
)
;
}
(
)
;
function
parseURL
(
str
)
{
let
fullObject
;
if
(
isNode
|
|
_isFastboot
.
default
)
{
fullObject
=
url
.
parse
(
str
)
;
}
else
{
url
.
href
=
str
;
fullObject
=
url
;
}
const
desiredProps
=
{
}
;
desiredProps
.
href
=
fullObject
.
href
;
desiredProps
.
protocol
=
fullObject
.
protocol
;
desiredProps
.
hostname
=
fullObject
.
hostname
;
desiredProps
.
port
=
fullObject
.
port
;
desiredProps
.
pathname
=
fullObject
.
pathname
;
desiredProps
.
search
=
fullObject
.
search
;
desiredProps
.
hash
=
fullObject
.
hash
;
return
desiredProps
;
}
function
isFullURL
(
url
)
{
return
url
.
match
(
completeUrlRegex
)
;
}
function
haveSameHost
(
a
b
)
{
a
=
parseURL
(
a
)
;
b
=
parseURL
(
b
)
;
return
a
.
protocol
=
=
=
b
.
protocol
&
&
a
.
hostname
=
=
=
b
.
hostname
&
&
a
.
port
=
=
=
b
.
port
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
ajax
-
request
'
[
'
exports
'
'
ember
-
ajax
/
mixins
/
ajax
-
request
'
]
function
(
exports
_ajaxRequest
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Object
.
extend
(
_ajaxRequest
.
default
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
errors
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
AjaxError
=
AjaxError
;
exports
.
InvalidError
=
InvalidError
;
exports
.
UnauthorizedError
=
UnauthorizedError
;
exports
.
ForbiddenError
=
ForbiddenError
;
exports
.
BadRequestError
=
BadRequestError
;
exports
.
NotFoundError
=
NotFoundError
;
exports
.
TimeoutError
=
TimeoutError
;
exports
.
AbortError
=
AbortError
;
exports
.
ConflictError
=
ConflictError
;
exports
.
ServerError
=
ServerError
;
exports
.
isAjaxError
=
isAjaxError
;
exports
.
isUnauthorizedError
=
isUnauthorizedError
;
exports
.
isForbiddenError
=
isForbiddenError
;
exports
.
isInvalidError
=
isInvalidError
;
exports
.
isBadRequestError
=
isBadRequestError
;
exports
.
isNotFoundError
=
isNotFoundError
;
exports
.
isTimeoutError
=
isTimeoutError
;
exports
.
isAbortError
=
isAbortError
;
exports
.
isConflictError
=
isConflictError
;
exports
.
isServerError
=
isServerError
;
exports
.
isSuccess
=
isSuccess
;
function
AjaxError
(
payload
message
=
'
Ajax
operation
failed
'
status
)
{
Ember
.
Error
.
call
(
this
message
)
;
this
.
payload
=
payload
;
this
.
status
=
status
;
}
AjaxError
.
prototype
=
Object
.
create
(
Ember
.
Error
.
prototype
)
;
function
InvalidError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
Request
was
rejected
because
it
was
invalid
'
422
)
;
}
InvalidError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
UnauthorizedError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
Ajax
authorization
failed
'
401
)
;
}
UnauthorizedError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
ForbiddenError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
Request
was
rejected
because
user
is
not
permitted
to
perform
this
operation
.
'
403
)
;
}
ForbiddenError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
BadRequestError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
Request
was
formatted
incorrectly
.
'
400
)
;
}
BadRequestError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
NotFoundError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
Resource
was
not
found
.
'
404
)
;
}
NotFoundError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
TimeoutError
(
)
{
AjaxError
.
call
(
this
null
'
The
ajax
operation
timed
out
'
-
1
)
;
}
TimeoutError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
AbortError
(
)
{
AjaxError
.
call
(
this
null
'
The
ajax
operation
was
aborted
'
0
)
;
}
AbortError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
ConflictError
(
payload
)
{
AjaxError
.
call
(
this
payload
'
The
ajax
operation
failed
due
to
a
conflict
'
409
)
;
}
ConflictError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
ServerError
(
payload
status
)
{
AjaxError
.
call
(
this
payload
'
Request
was
rejected
due
to
server
error
'
status
)
;
}
ServerError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
isAjaxError
(
error
)
{
return
error
instanceof
AjaxError
;
}
function
isUnauthorizedError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
UnauthorizedError
;
}
else
{
return
error
=
=
=
401
;
}
}
function
isForbiddenError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
ForbiddenError
;
}
else
{
return
error
=
=
=
403
;
}
}
function
isInvalidError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
InvalidError
;
}
else
{
return
error
=
=
=
422
;
}
}
function
isBadRequestError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
BadRequestError
;
}
else
{
return
error
=
=
=
400
;
}
}
function
isNotFoundError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
NotFoundError
;
}
else
{
return
error
=
=
=
404
;
}
}
function
isTimeoutError
(
error
)
{
return
error
instanceof
TimeoutError
;
}
function
isAbortError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
AbortError
;
}
else
{
return
error
=
=
=
0
;
}
}
function
isConflictError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
ConflictError
;
}
else
{
return
error
=
=
=
409
;
}
}
function
isServerError
(
error
)
{
if
(
isAjaxError
(
error
)
)
{
return
error
instanceof
ServerError
;
}
else
{
return
error
>
=
500
&
&
error
<
600
;
}
}
function
isSuccess
(
status
)
{
const
s
=
parseInt
(
status
10
)
;
return
s
>
=
200
&
&
s
<
300
|
|
s
=
=
=
304
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
index
'
[
'
exports
'
'
ember
-
ajax
/
request
'
]
function
(
exports
_request
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_request
.
default
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
mixins
/
ajax
-
request
'
[
'
exports
'
'
ember
-
ajax
/
errors
'
'
ember
-
ajax
/
utils
/
ajax
'
'
ember
-
ajax
/
-
private
/
utils
/
parse
-
response
-
headers
'
'
ember
-
ajax
/
-
private
/
utils
/
get
-
header
'
'
ember
-
ajax
/
-
private
/
utils
/
url
-
helpers
'
'
ember
-
ajax
/
-
private
/
utils
/
is
-
string
'
'
ember
-
ajax
/
-
private
/
promise
'
]
function
(
exports
_errors
_ajax
_parseResponseHeaders
_getHeader
_urlHelpers
_isString
_promise
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
{
Logger
Test
testing
}
=
Ember
;
const
JSONContentType
=
/
^
application
\
/
(
?
:
vnd
\
.
api
\
+
)
?
json
/
i
;
function
isJSONContentType
(
header
)
{
if
(
!
(
0
_isString
.
default
)
(
header
)
)
{
return
false
;
}
return
!
!
header
.
match
(
JSONContentType
)
;
}
function
isJSONStringifyable
(
method
{
contentType
data
headers
}
)
{
if
(
method
=
=
=
'
GET
'
)
{
return
false
;
}
if
(
!
isJSONContentType
(
contentType
)
&
&
!
isJSONContentType
(
(
0
_getHeader
.
default
)
(
headers
'
Content
-
Type
'
)
)
)
{
return
false
;
}
if
(
typeof
data
!
=
=
'
object
'
)
{
return
false
;
}
return
true
;
}
function
startsWithSlash
(
string
)
{
return
string
.
charAt
(
0
)
=
=
=
'
/
'
;
}
function
endsWithSlash
(
string
)
{
return
string
.
charAt
(
string
.
length
-
1
)
=
=
=
'
/
'
;
}
function
removeLeadingSlash
(
string
)
{
return
string
.
substring
(
1
)
;
}
function
stripSlashes
(
path
)
{
if
(
startsWithSlash
(
path
)
)
{
path
=
removeLeadingSlash
(
path
)
;
}
if
(
endsWithSlash
(
path
)
)
{
path
=
path
.
slice
(
0
-
1
)
;
}
return
path
;
}
let
pendingRequestCount
=
0
;
if
(
testing
)
{
Test
.
registerWaiter
(
function
(
)
{
return
pendingRequestCount
=
=
=
0
;
}
)
;
}
exports
.
default
=
Ember
.
Mixin
.
create
(
{
contentType
:
'
application
/
x
-
www
-
form
-
urlencoded
;
charset
=
UTF
-
8
'
headers
:
{
}
request
(
url
options
)
{
const
hash
=
this
.
options
(
url
options
)
;
const
internalPromise
=
this
.
_makeRequest
(
hash
)
;
const
ajaxPromise
=
new
_promise
.
default
(
(
resolve
reject
)
=
>
{
internalPromise
.
then
(
(
{
response
}
)
=
>
{
resolve
(
response
)
;
}
)
.
catch
(
(
{
response
}
)
=
>
{
reject
(
response
)
;
}
)
;
}
ember
-
ajax
:
{
hash
.
type
}
{
hash
.
url
}
response
)
;
ajaxPromise
.
xhr
=
internalPromise
.
xhr
;
return
ajaxPromise
;
}
raw
(
url
options
)
{
const
hash
=
this
.
options
(
url
options
)
;
return
this
.
_makeRequest
(
hash
)
;
}
_makeRequest
(
hash
)
{
const
method
=
hash
.
method
|
|
hash
.
type
|
|
'
GET
'
;
const
requestData
=
{
method
type
:
method
url
:
hash
.
url
}
;
if
(
isJSONStringifyable
(
method
hash
)
)
{
hash
.
data
=
JSON
.
stringify
(
hash
.
data
)
;
}
pendingRequestCount
=
pendingRequestCount
+
1
;
const
jqXHR
=
(
0
_ajax
.
default
)
(
hash
)
;
const
promise
=
new
_promise
.
default
(
(
resolve
reject
)
=
>
{
jqXHR
.
done
(
(
payload
textStatus
jqXHR
)
=
>
{
const
response
=
this
.
handleResponse
(
jqXHR
.
status
(
0
_parseResponseHeaders
.
default
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
payload
requestData
)
;
if
(
(
0
_errors
.
isAjaxError
)
(
response
)
)
{
Ember
.
run
.
join
(
null
reject
{
payload
textStatus
jqXHR
response
}
)
;
}
else
{
Ember
.
run
.
join
(
null
resolve
{
payload
textStatus
jqXHR
response
}
)
;
}
}
)
.
fail
(
(
jqXHR
textStatus
errorThrown
)
=
>
{
Ember
.
runInDebug
(
function
(
)
{
const
message
=
The
server
returned
an
empty
string
for
{
requestData
.
type
}
{
requestData
.
url
}
which
cannot
be
parsed
into
a
valid
JSON
.
Return
either
null
or
{
}
.
;
const
validJSONString
=
!
(
textStatus
=
=
=
'
parsererror
'
&
&
jqXHR
.
responseText
=
=
=
'
'
)
;
(
true
&
&
Ember
.
warn
(
message
validJSONString
{
id
:
'
ds
.
adapter
.
returned
-
empty
-
string
-
as
-
JSON
'
}
)
)
;
}
)
;
const
payload
=
this
.
parseErrorResponse
(
jqXHR
.
responseText
)
|
|
errorThrown
;
let
response
;
if
(
errorThrown
instanceof
Error
)
{
response
=
errorThrown
;
}
else
if
(
textStatus
=
=
=
'
timeout
'
)
{
response
=
new
_errors
.
TimeoutError
(
)
;
}
else
if
(
textStatus
=
=
=
'
abort
'
)
{
response
=
new
_errors
.
AbortError
(
)
;
}
else
{
response
=
this
.
handleResponse
(
jqXHR
.
status
(
0
_parseResponseHeaders
.
default
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
payload
requestData
)
;
}
Ember
.
run
.
join
(
null
reject
{
payload
textStatus
jqXHR
errorThrown
response
}
)
;
}
)
.
always
(
(
)
=
>
{
pendingRequestCount
=
pendingRequestCount
-
1
;
}
)
;
}
ember
-
ajax
:
{
hash
.
type
}
{
hash
.
url
}
)
;
promise
.
xhr
=
jqXHR
;
return
promise
;
}
post
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
POST
'
)
)
;
}
put
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
PUT
'
)
)
;
}
patch
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
PATCH
'
)
)
;
}
del
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
DELETE
'
)
)
;
}
delete
(
)
{
return
this
.
del
(
.
.
.
arguments
)
;
}
get
(
url
)
{
if
(
arguments
.
length
>
1
|
|
url
.
indexOf
(
'
/
'
)
!
=
=
-
1
)
{
throw
new
Ember
.
Error
(
'
It
seems
you
tried
to
use
.
get
to
make
a
request
!
Use
the
.
request
method
instead
.
'
)
;
}
return
this
.
_super
(
.
.
.
arguments
)
;
}
_addTypeToOptionsFor
(
options
method
)
{
options
=
options
|
|
{
}
;
options
.
type
=
method
;
return
options
;
}
_getFullHeadersHash
(
headers
)
{
const
classHeaders
=
Ember
.
get
(
this
'
headers
'
)
;
const
_headers
=
Ember
.
merge
(
{
}
classHeaders
)
;
return
Ember
.
merge
(
_headers
headers
)
;
}
options
(
url
options
=
{
}
)
{
options
=
Ember
.
merge
(
{
}
options
)
;
options
.
url
=
this
.
_buildURL
(
url
options
)
;
options
.
type
=
options
.
type
|
|
'
GET
'
;
options
.
dataType
=
options
.
dataType
|
|
'
json
'
;
options
.
contentType
=
Ember
.
isEmpty
(
options
.
contentType
)
?
Ember
.
get
(
this
'
contentType
'
)
:
options
.
contentType
;
if
(
this
.
_shouldSendHeaders
(
options
)
)
{
options
.
headers
=
this
.
_getFullHeadersHash
(
options
.
headers
)
;
}
else
{
options
.
headers
=
options
.
headers
|
|
{
}
;
}
return
options
;
}
_buildURL
(
url
options
=
{
}
)
{
if
(
(
0
_urlHelpers
.
isFullURL
)
(
url
)
)
{
return
url
;
}
const
urlParts
=
[
]
;
let
host
=
options
.
host
|
|
Ember
.
get
(
this
'
host
'
)
;
if
(
host
)
{
host
=
stripSlashes
(
host
)
;
}
urlParts
.
push
(
host
)
;
let
namespace
=
options
.
namespace
|
|
Ember
.
get
(
this
'
namespace
'
)
;
if
(
namespace
)
{
namespace
=
stripSlashes
(
namespace
)
;
urlParts
.
push
(
namespace
)
;
}
const
hasNamespaceRegex
=
new
RegExp
(
^
(
/
)
?
{
namespace
}
)
;
if
(
hasNamespaceRegex
.
test
(
url
)
)
{
return
url
;
}
if
(
startsWithSlash
(
url
)
)
{
url
=
removeLeadingSlash
(
url
)
;
}
urlParts
.
push
(
url
)
;
return
urlParts
.
join
(
'
/
'
)
;
}
handleResponse
(
status
headers
payload
requestData
)
{
if
(
this
.
isSuccess
(
status
headers
payload
)
)
{
return
payload
;
}
payload
=
this
.
normalizeErrorResponse
(
status
headers
payload
)
;
return
this
.
_createCorrectError
(
status
headers
payload
requestData
)
;
}
_createCorrectError
(
status
headers
payload
requestData
)
{
let
error
;
if
(
this
.
isUnauthorizedError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
UnauthorizedError
(
payload
)
;
}
else
if
(
this
.
isForbiddenError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
ForbiddenError
(
payload
)
;
}
else
if
(
this
.
isInvalidError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
InvalidError
(
payload
)
;
}
else
if
(
this
.
isBadRequestError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
BadRequestError
(
payload
)
;
}
else
if
(
this
.
isNotFoundError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
NotFoundError
(
payload
)
;
}
else
if
(
this
.
isAbortError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
AbortError
(
payload
)
;
}
else
if
(
this
.
isConflictError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
ConflictError
(
payload
)
;
}
else
if
(
this
.
isServerError
(
status
headers
payload
)
)
{
error
=
new
_errors
.
ServerError
(
payload
status
)
;
}
else
{
const
detailedMessage
=
this
.
generateDetailedMessage
(
status
headers
payload
requestData
)
;
error
=
new
_errors
.
AjaxError
(
payload
detailedMessage
status
)
;
}
return
error
;
}
_matchHosts
(
host
matcher
)
{
if
(
matcher
.
constructor
=
=
=
RegExp
)
{
return
matcher
.
test
(
host
)
;
}
else
if
(
typeof
matcher
=
=
=
'
string
'
)
{
return
matcher
=
=
=
host
;
}
else
{
Logger
.
warn
(
'
trustedHosts
only
handles
strings
or
regexes
.
'
matcher
'
is
neither
.
'
)
;
return
false
;
}
}
_shouldSendHeaders
(
{
url
host
}
)
{
url
=
url
|
|
'
'
;
host
=
host
|
|
Ember
.
get
(
this
'
host
'
)
|
|
'
'
;
const
trustedHosts
=
Ember
.
get
(
this
'
trustedHosts
'
)
|
|
Ember
.
A
(
)
;
const
{
hostname
}
=
(
0
_urlHelpers
.
parseURL
)
(
url
)
;
if
(
!
(
0
_urlHelpers
.
isFullURL
)
(
url
)
)
{
return
true
;
}
else
if
(
trustedHosts
.
find
(
matcher
=
>
this
.
_matchHosts
(
hostname
matcher
)
)
)
{
return
true
;
}
return
(
0
_urlHelpers
.
haveSameHost
)
(
url
host
)
;
}
generateDetailedMessage
(
status
headers
payload
requestData
)
{
let
shortenedPayload
;
const
payloadContentType
=
(
0
_getHeader
.
default
)
(
headers
'
Content
-
Type
'
)
|
|
'
Empty
Content
-
Type
'
;
if
(
payloadContentType
.
toLowerCase
(
)
=
=
=
'
text
/
html
'
&
&
payload
.
length
>
250
)
{
shortenedPayload
=
'
[
Omitted
Lengthy
HTML
]
'
;
}
else
{
shortenedPayload
=
JSON
.
stringify
(
payload
)
;
}
const
requestDescription
=
{
requestData
.
type
}
{
requestData
.
url
}
;
const
payloadDescription
=
Payload
(
{
payloadContentType
}
)
;
return
[
Ember
AJAX
Request
{
requestDescription
}
returned
a
{
status
}
payloadDescription
shortenedPayload
]
.
join
(
'
\
n
'
)
;
}
isUnauthorizedError
(
status
)
{
return
(
0
_errors
.
isUnauthorizedError
)
(
status
)
;
}
isForbiddenError
(
status
)
{
return
(
0
_errors
.
isForbiddenError
)
(
status
)
;
}
isInvalidError
(
status
)
{
return
(
0
_errors
.
isInvalidError
)
(
status
)
;
}
isBadRequestError
(
status
)
{
return
(
0
_errors
.
isBadRequestError
)
(
status
)
;
}
isNotFoundError
(
status
)
{
return
(
0
_errors
.
isNotFoundError
)
(
status
)
;
}
isAbortError
(
status
)
{
return
(
0
_errors
.
isAbortError
)
(
status
)
;
}
isConflictError
(
status
)
{
return
(
0
_errors
.
isConflictError
)
(
status
)
;
}
isServerError
(
status
)
{
return
(
0
_errors
.
isServerError
)
(
status
)
;
}
isSuccess
(
status
)
{
return
(
0
_errors
.
isSuccess
)
(
status
)
;
}
parseErrorResponse
(
responseText
)
{
try
{
return
JSON
.
parse
(
responseText
)
;
}
catch
(
e
)
{
return
responseText
;
}
}
normalizeErrorResponse
(
status
headers
payload
)
{
return
payload
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
mixins
/
ajax
-
support
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Mixin
.
create
(
{
ajaxService
:
Ember
.
inject
.
service
(
'
ajax
'
)
host
:
Ember
.
computed
.
alias
(
'
ajaxService
.
host
'
)
namespace
:
Ember
.
computed
.
alias
(
'
ajaxService
.
namespace
'
)
headers
:
Ember
.
computed
.
alias
(
'
ajaxService
.
headers
'
)
ajax
(
url
)
{
const
augmentedOptions
=
this
.
ajaxOptions
(
.
.
.
arguments
)
;
return
this
.
get
(
'
ajaxService
'
)
.
request
(
url
augmentedOptions
)
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
mixins
/
legacy
/
normalize
-
error
-
response
'
[
'
exports
'
'
ember
-
ajax
/
-
private
/
utils
/
is
-
string
'
]
function
(
exports
_isString
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
function
isObject
(
object
)
{
return
typeof
object
=
=
=
'
object
'
;
}
exports
.
default
=
Ember
.
Mixin
.
create
(
{
normalizeErrorResponse
(
status
headers
payload
)
{
payload
=
Ember
.
isNone
(
payload
)
?
{
}
:
payload
;
if
(
Ember
.
isArray
(
payload
.
errors
)
)
{
return
payload
.
errors
.
map
(
function
(
error
)
{
if
(
isObject
(
error
)
)
{
const
ret
=
Ember
.
merge
(
{
}
error
)
;
ret
.
status
=
{
error
.
status
}
;
return
ret
;
}
else
{
return
{
status
:
{
status
}
title
:
error
}
;
}
}
)
;
}
else
if
(
Ember
.
isArray
(
payload
)
)
{
return
payload
.
map
(
function
(
error
)
{
if
(
isObject
(
error
)
)
{
return
{
status
:
{
status
}
title
:
error
.
title
|
|
'
The
backend
responded
with
an
error
'
detail
:
error
}
;
}
else
{
return
{
status
:
{
status
}
title
:
{
error
}
}
;
}
}
)
;
}
else
if
(
(
0
_isString
.
default
)
(
payload
)
)
{
return
[
{
status
:
{
status
}
title
:
payload
}
]
;
}
else
{
return
[
{
status
:
{
status
}
title
:
payload
.
title
|
|
'
The
backend
responded
with
an
error
'
detail
:
payload
}
]
;
}
}
}
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
raw
'
[
'
exports
'
'
ember
-
ajax
/
ajax
-
request
'
]
function
(
exports
_ajaxRequest
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
raw
;
function
raw
(
)
{
const
ajax
=
new
_ajaxRequest
.
default
(
)
;
return
ajax
.
raw
(
.
.
.
arguments
)
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
request
'
[
'
exports
'
'
ember
-
ajax
/
ajax
-
request
'
]
function
(
exports
_ajaxRequest
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
request
;
function
request
(
)
{
const
ajax
=
new
_ajaxRequest
.
default
(
)
;
return
ajax
.
request
(
.
.
.
arguments
)
;
}
}
)
;
;
define
(
'
ember
-
ajax
/
services
/
ajax
'
[
'
exports
'
'
ember
-
ajax
/
mixins
/
ajax
-
request
'
]
function
(
exports
_ajaxRequest
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Service
.
extend
(
_ajaxRequest
.
default
)
;
}
)
;
;
define
(
'
ember
-
ajax
/
utils
/
ajax
'
[
'
exports
'
'
ember
-
ajax
/
-
private
/
utils
/
is
-
fastboot
'
]
function
(
exports
_isFastboot
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
_isFastboot
.
default
?
najax
:
Ember
.
.
ajax
;
}
)
;
;
define
(
'
ember
-
cli
-
app
-
version
/
initializer
-
factory
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
initializerFactory
;
const
{
String
:
{
classify
}
libraries
}
=
Ember
;
function
initializerFactory
(
name
version
)
{
let
registered
=
false
;
return
function
(
)
{
if
(
!
registered
&
&
name
&
&
version
)
{
var
appName
=
classify
(
name
)
;
libraries
.
register
(
appName
version
)
;
registered
=
true
;
}
}
;
}
}
)
;
;
define
(
"
ember
-
cli
-
app
-
version
/
utils
/
regexp
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
versionRegExp
=
exports
.
versionRegExp
=
/
\
d
[
.
]
\
d
[
.
]
\
d
/
;
const
shaRegExp
=
exports
.
shaRegExp
=
/
[
a
-
z
\
d
]
{
8
}
/
;
}
)
;
;
define
(
'
ember
-
inflector
/
index
'
[
'
exports
'
'
ember
-
inflector
/
lib
/
system
'
'
ember
-
inflector
/
lib
/
ext
/
string
'
]
function
(
exports
_system
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
defaultRules
=
exports
.
singularize
=
exports
.
pluralize
=
undefined
;
_system
.
Inflector
.
defaultRules
=
_system
.
defaultRules
;
Object
.
defineProperty
(
Ember
'
Inflector
'
{
get
(
)
{
Ember
.
deprecate
(
Ember
.
Inflector
is
deprecated
.
Please
explicitly
:
import
Inflector
from
'
ember
-
inflector
'
;
false
{
id
:
'
ember
-
inflector
.
globals
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_system
.
Inflector
;
}
}
)
;
Object
.
defineProperty
(
Ember
.
String
'
singularize
'
{
get
(
)
{
Ember
.
deprecate
(
Ember
.
String
.
singularize
(
)
is
deprecated
.
Please
explicitly
:
import
{
singularize
}
from
'
ember
-
inflector
'
;
false
{
id
:
'
ember
-
inflector
.
globals
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_system
.
singularize
;
}
}
)
;
Object
.
defineProperty
(
Ember
.
String
'
pluralize
'
{
get
(
)
{
Ember
.
deprecate
(
Ember
.
String
.
pluralize
(
)
is
deprecated
.
Please
explicitly
:
import
{
pluralize
}
from
'
ember
-
inflector
'
;
false
{
id
:
'
ember
-
inflector
.
globals
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_system
.
pluralize
;
}
}
)
;
exports
.
default
=
_system
.
Inflector
;
exports
.
pluralize
=
_system
.
pluralize
;
exports
.
singularize
=
_system
.
singularize
;
exports
.
defaultRules
=
_system
.
defaultRules
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
ext
/
string
'
[
'
ember
-
inflector
/
lib
/
system
/
string
'
]
function
(
_string
)
{
'
use
strict
'
;
if
(
Ember
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
Ember
.
EXTEND_PROTOTYPES
.
String
)
{
Object
.
defineProperty
(
String
.
prototype
'
pluralize
'
{
get
(
)
{
Ember
.
deprecate
(
String
.
prototype
.
pluralize
(
)
is
deprecated
.
Please
explicitly
:
import
{
pluralize
}
from
'
ember
-
inflector
'
;
false
{
id
:
'
ember
-
inflector
.
globals
'
until
:
'
3
.
0
.
0
'
}
)
;
return
function
(
)
{
return
(
0
_string
.
pluralize
)
(
this
)
;
}
;
}
}
)
;
Object
.
defineProperty
(
String
.
prototype
'
singularize
'
{
get
(
)
{
Ember
.
deprecate
(
String
.
prototype
.
singularize
(
)
is
deprecated
.
Please
explicitly
:
import
{
singularize
}
from
'
ember
-
inflector
'
;
false
{
id
:
'
ember
-
inflector
.
globals
'
until
:
'
3
.
0
.
0
'
}
)
;
return
function
(
)
{
return
(
0
_string
.
singularize
)
(
this
)
;
}
;
}
}
)
;
}
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
helpers
/
pluralize
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
]
function
(
exports
_emberInflector
_makeHelper
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
(
0
_makeHelper
.
default
)
(
function
(
params
hash
)
{
let
count
word
withoutCount
=
false
;
if
(
params
.
length
=
=
=
1
)
{
word
=
params
[
0
]
;
return
(
0
_emberInflector
.
pluralize
)
(
word
)
;
}
else
{
count
=
params
[
0
]
;
word
=
params
[
1
]
;
if
(
hash
[
"
without
-
count
"
]
)
{
withoutCount
=
hash
[
"
without
-
count
"
]
;
}
if
(
parseFloat
(
count
)
!
=
=
1
)
{
word
=
(
0
_emberInflector
.
pluralize
)
(
word
)
;
}
return
withoutCount
?
word
:
count
+
"
"
+
word
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
helpers
/
singularize
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
]
function
(
exports
_emberInflector
_makeHelper
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
(
0
_makeHelper
.
default
)
(
function
(
params
)
{
return
(
0
_emberInflector
.
singularize
)
(
params
[
0
]
)
;
}
)
;
}
)
;
;
define
(
"
ember
-
inflector
/
lib
/
system
"
[
"
exports
"
"
ember
-
inflector
/
lib
/
system
/
inflector
"
"
ember
-
inflector
/
lib
/
system
/
string
"
"
ember
-
inflector
/
lib
/
system
/
inflections
"
]
function
(
exports
_inflector
_string
_inflections
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
defaultRules
=
exports
.
pluralize
=
exports
.
singularize
=
exports
.
Inflector
=
undefined
;
_inflector
.
default
.
inflector
=
new
_inflector
.
default
(
_inflections
.
default
)
;
exports
.
Inflector
=
_inflector
.
default
;
exports
.
singularize
=
_string
.
singularize
;
exports
.
pluralize
=
_string
.
pluralize
;
exports
.
defaultRules
=
_inflections
.
default
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
system
/
inflections
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
{
plurals
:
[
[
/
/
'
s
'
]
[
/
s
/
i
'
s
'
]
[
/
^
(
ax
|
test
)
is
/
i
'
1es
'
]
[
/
(
octop
|
vir
)
us
/
i
'
1i
'
]
[
/
(
octop
|
vir
)
i
/
i
'
1i
'
]
[
/
(
alias
|
status
|
bonus
)
/
i
'
1es
'
]
[
/
(
bu
)
s
/
i
'
1ses
'
]
[
/
(
buffal
|
tomat
)
o
/
i
'
1oes
'
]
[
/
(
[
ti
]
)
um
/
i
'
1a
'
]
[
/
(
[
ti
]
)
a
/
i
'
1a
'
]
[
/
sis
/
i
'
ses
'
]
[
/
(
?
:
(
[
^
f
]
)
fe
|
(
[
lr
]
)
f
)
/
i
'
1
2ves
'
]
[
/
(
hive
)
/
i
'
1s
'
]
[
/
(
[
^
aeiouy
]
|
qu
)
y
/
i
'
1ies
'
]
[
/
(
x
|
ch
|
ss
|
sh
)
/
i
'
1es
'
]
[
/
(
matr
|
vert
|
ind
)
(
?
:
ix
|
ex
)
/
i
'
1ices
'
]
[
/
^
(
m
|
l
)
ouse
/
i
'
1ice
'
]
[
/
^
(
m
|
l
)
ice
/
i
'
1ice
'
]
[
/
^
(
ox
)
/
i
'
1en
'
]
[
/
^
(
oxen
)
/
i
'
1
'
]
[
/
(
quiz
)
/
i
'
1zes
'
]
]
singular
:
[
[
/
s
/
i
'
'
]
[
/
(
ss
)
/
i
'
1
'
]
[
/
(
n
)
ews
/
i
'
1ews
'
]
[
/
(
[
ti
]
)
a
/
i
'
1um
'
]
[
/
(
(
a
)
naly
|
(
b
)
a
|
(
d
)
iagno
|
(
p
)
arenthe
|
(
p
)
rogno
|
(
s
)
ynop
|
(
t
)
he
)
(
sis
|
ses
)
/
i
'
1sis
'
]
[
/
(
^
analy
)
(
sis
|
ses
)
/
i
'
1sis
'
]
[
/
(
[
^
f
]
)
ves
/
i
'
1fe
'
]
[
/
(
hive
)
s
/
i
'
1
'
]
[
/
(
tive
)
s
/
i
'
1
'
]
[
/
(
[
lr
]
)
ves
/
i
'
1f
'
]
[
/
(
[
^
aeiouy
]
|
qu
)
ies
/
i
'
1y
'
]
[
/
(
s
)
eries
/
i
'
1eries
'
]
[
/
(
m
)
ovies
/
i
'
1ovie
'
]
[
/
(
x
|
ch
|
ss
|
sh
)
es
/
i
'
1
'
]
[
/
^
(
m
|
l
)
ice
/
i
'
1ouse
'
]
[
/
(
bus
)
(
es
)
?
/
i
'
1
'
]
[
/
(
o
)
es
/
i
'
1
'
]
[
/
(
shoe
)
s
/
i
'
1
'
]
[
/
(
cris
|
test
)
(
is
|
es
)
/
i
'
1is
'
]
[
/
^
(
a
)
x
[
ie
]
s
/
i
'
1xis
'
]
[
/
(
octop
|
vir
)
(
us
|
i
)
/
i
'
1us
'
]
[
/
(
alias
|
status
|
bonus
)
(
es
)
?
/
i
'
1
'
]
[
/
^
(
ox
)
en
/
i
'
1
'
]
[
/
(
vert
|
ind
)
ices
/
i
'
1ex
'
]
[
/
(
matr
)
ices
/
i
'
1ix
'
]
[
/
(
quiz
)
zes
/
i
'
1
'
]
[
/
(
database
)
s
/
i
'
1
'
]
]
irregularPairs
:
[
[
'
person
'
'
people
'
]
[
'
man
'
'
men
'
]
[
'
child
'
'
children
'
]
[
'
sex
'
'
sexes
'
]
[
'
move
'
'
moves
'
]
[
'
cow
'
'
kine
'
]
[
'
zombie
'
'
zombies
'
]
]
uncountable
:
[
'
equipment
'
'
information
'
'
rice
'
'
money
'
'
species
'
'
series
'
'
fish
'
'
sheep
'
'
jeans
'
'
police
'
]
}
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
system
/
inflector
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
capitalize
=
Ember
.
String
.
capitalize
;
var
BLANK_REGEX
=
/
^
\
s
*
/
;
var
LAST_WORD_DASHED_REGEX
=
/
(
[
\
w
/
-
]
+
[
_
/
\
s
-
]
)
(
[
a
-
z
\
d
]
+
)
/
;
var
LAST_WORD_CAMELIZED_REGEX
=
/
(
[
\
w
/
\
s
-
]
+
)
(
[
A
-
Z
]
[
a
-
z
\
d
]
*
)
/
;
var
CAMELIZED_REGEX
=
/
[
A
-
Z
]
[
a
-
z
\
d
]
*
/
;
function
loadUncountable
(
rules
uncountable
)
{
for
(
var
i
=
0
length
=
uncountable
.
length
;
i
<
length
;
i
+
+
)
{
rules
.
uncountable
[
uncountable
[
i
]
.
toLowerCase
(
)
]
=
true
;
}
}
function
loadIrregular
(
rules
irregularPairs
)
{
var
pair
;
for
(
var
i
=
0
length
=
irregularPairs
.
length
;
i
<
length
;
i
+
+
)
{
pair
=
irregularPairs
[
i
]
;
rules
.
irregular
[
pair
[
0
]
.
toLowerCase
(
)
]
=
pair
[
1
]
;
rules
.
irregular
[
pair
[
1
]
.
toLowerCase
(
)
]
=
pair
[
1
]
;
rules
.
irregularInverse
[
pair
[
1
]
.
toLowerCase
(
)
]
=
pair
[
0
]
;
rules
.
irregularInverse
[
pair
[
0
]
.
toLowerCase
(
)
]
=
pair
[
0
]
;
}
}
function
Inflector
(
ruleSet
)
{
ruleSet
=
ruleSet
|
|
{
}
;
ruleSet
.
uncountable
=
ruleSet
.
uncountable
|
|
makeDictionary
(
)
;
ruleSet
.
irregularPairs
=
ruleSet
.
irregularPairs
|
|
makeDictionary
(
)
;
var
rules
=
this
.
rules
=
{
plurals
:
ruleSet
.
plurals
|
|
[
]
singular
:
ruleSet
.
singular
|
|
[
]
irregular
:
makeDictionary
(
)
irregularInverse
:
makeDictionary
(
)
uncountable
:
makeDictionary
(
)
}
;
loadUncountable
(
rules
ruleSet
.
uncountable
)
;
loadIrregular
(
rules
ruleSet
.
irregularPairs
)
;
this
.
enableCache
(
)
;
}
if
(
!
Object
.
create
&
&
!
Object
.
create
(
null
)
.
hasOwnProperty
)
{
throw
new
Error
(
"
This
browser
does
not
support
Object
.
create
(
null
)
please
polyfil
with
es5
-
sham
:
http
:
/
/
git
.
io
/
yBU2rg
"
)
;
}
function
makeDictionary
(
)
{
var
cache
=
Object
.
create
(
null
)
;
cache
[
'
_dict
'
]
=
null
;
delete
cache
[
'
_dict
'
]
;
return
cache
;
}
Inflector
.
prototype
=
{
enableCache
:
function
(
)
{
this
.
purgeCache
(
)
;
this
.
singularize
=
function
(
word
)
{
this
.
_cacheUsed
=
true
;
return
this
.
_sCache
[
word
]
|
|
(
this
.
_sCache
[
word
]
=
this
.
_singularize
(
word
)
)
;
}
;
this
.
pluralize
=
function
(
word
)
{
this
.
_cacheUsed
=
true
;
return
this
.
_pCache
[
word
]
|
|
(
this
.
_pCache
[
word
]
=
this
.
_pluralize
(
word
)
)
;
}
;
}
purgeCache
:
function
(
)
{
this
.
_cacheUsed
=
false
;
this
.
_sCache
=
makeDictionary
(
)
;
this
.
_pCache
=
makeDictionary
(
)
;
}
disableCache
:
function
(
)
{
this
.
_sCache
=
null
;
this
.
_pCache
=
null
;
this
.
singularize
=
function
(
word
)
{
return
this
.
_singularize
(
word
)
;
}
;
this
.
pluralize
=
function
(
word
)
{
return
this
.
_pluralize
(
word
)
;
}
;
}
plural
:
function
(
regex
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
this
.
rules
.
plurals
.
push
(
[
regex
string
.
toLowerCase
(
)
]
)
;
}
singular
:
function
(
regex
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
this
.
rules
.
singular
.
push
(
[
regex
string
.
toLowerCase
(
)
]
)
;
}
uncountable
:
function
(
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
loadUncountable
(
this
.
rules
[
string
.
toLowerCase
(
)
]
)
;
}
irregular
:
function
(
singular
plural
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
loadIrregular
(
this
.
rules
[
[
singular
plural
]
]
)
;
}
pluralize
:
function
(
word
)
{
return
this
.
_pluralize
(
word
)
;
}
_pluralize
:
function
(
word
)
{
return
this
.
inflect
(
word
this
.
rules
.
plurals
this
.
rules
.
irregular
)
;
}
singularize
:
function
(
word
)
{
return
this
.
_singularize
(
word
)
;
}
_singularize
:
function
(
word
)
{
return
this
.
inflect
(
word
this
.
rules
.
singular
this
.
rules
.
irregularInverse
)
;
}
inflect
:
function
(
word
typeRules
irregular
)
{
var
inflection
substitution
result
lowercase
wordSplit
firstPhrase
lastWord
isBlank
isCamelized
rule
isUncountable
;
isBlank
=
!
word
|
|
BLANK_REGEX
.
test
(
word
)
;
isCamelized
=
CAMELIZED_REGEX
.
test
(
word
)
;
firstPhrase
=
"
"
;
if
(
isBlank
)
{
return
word
;
}
lowercase
=
word
.
toLowerCase
(
)
;
wordSplit
=
LAST_WORD_DASHED_REGEX
.
exec
(
word
)
|
|
LAST_WORD_CAMELIZED_REGEX
.
exec
(
word
)
;
if
(
wordSplit
)
{
firstPhrase
=
wordSplit
[
1
]
;
lastWord
=
wordSplit
[
2
]
.
toLowerCase
(
)
;
}
isUncountable
=
this
.
rules
.
uncountable
[
lowercase
]
|
|
this
.
rules
.
uncountable
[
lastWord
]
;
if
(
isUncountable
)
{
return
word
;
}
for
(
rule
in
irregular
)
{
if
(
lowercase
.
match
(
rule
+
"
"
)
)
{
substitution
=
irregular
[
rule
]
;
if
(
isCamelized
&
&
irregular
[
lastWord
]
)
{
substitution
=
capitalize
(
substitution
)
;
rule
=
capitalize
(
rule
)
;
}
return
word
.
replace
(
new
RegExp
(
rule
'
i
'
)
substitution
)
;
}
}
for
(
var
i
=
typeRules
.
length
min
=
0
;
i
>
min
;
i
-
-
)
{
inflection
=
typeRules
[
i
-
1
]
;
rule
=
inflection
[
0
]
;
if
(
rule
.
test
(
word
)
)
{
break
;
}
}
inflection
=
inflection
|
|
[
]
;
rule
=
inflection
[
0
]
;
substitution
=
inflection
[
1
]
;
result
=
word
.
replace
(
rule
substitution
)
;
return
result
;
}
}
;
exports
.
default
=
Inflector
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
system
/
string
'
[
'
exports
'
'
ember
-
inflector
/
lib
/
system
/
inflector
'
]
function
(
exports
_inflector
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
singularize
=
exports
.
pluralize
=
undefined
;
function
pluralize
(
word
)
{
return
_inflector
.
default
.
inflector
.
pluralize
(
word
)
;
}
function
singularize
(
word
)
{
return
_inflector
.
default
.
inflector
.
singularize
(
word
)
;
}
exports
.
pluralize
=
pluralize
;
exports
.
singularize
=
singularize
;
}
)
;
;
define
(
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
makeHelper
;
function
makeHelper
(
helperFunction
)
{
if
(
Ember
.
Helper
)
{
return
Ember
.
Helper
.
helper
(
helperFunction
)
;
}
if
(
Ember
.
HTMLBars
)
{
return
Ember
.
HTMLBars
.
makeBoundHelper
(
helperFunction
)
;
}
return
Ember
.
Handlebars
.
makeBoundHelper
(
helperFunction
)
;
}
}
)
;
;
define
(
'
ember
-
load
-
initializers
/
index
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
function
(
app
prefix
)
{
var
initializerPrefix
=
prefix
+
'
/
initializers
/
'
;
var
instanceInitializerPrefix
=
prefix
+
'
/
instance
-
initializers
/
'
;
var
initializers
=
[
]
;
var
instanceInitializers
=
[
]
;
var
moduleNames
=
Object
.
keys
(
requirejs
.
_eak_seen
)
;
for
(
var
i
=
0
;
i
<
moduleNames
.
length
;
i
+
+
)
{
var
moduleName
=
moduleNames
[
i
]
;
if
(
moduleName
.
lastIndexOf
(
initializerPrefix
0
)
=
=
=
0
)
{
initializers
.
push
(
moduleName
)
;
}
else
if
(
moduleName
.
lastIndexOf
(
instanceInitializerPrefix
0
)
=
=
=
0
)
{
instanceInitializers
.
push
(
moduleName
)
;
}
}
registerInitializers
(
app
initializers
)
;
registerInstanceInitializers
(
app
instanceInitializers
)
;
}
;
function
resolveInitializer
(
moduleName
)
{
var
module
=
require
(
moduleName
null
null
true
)
;
if
(
!
module
)
{
throw
new
Error
(
moduleName
+
'
must
export
an
initializer
.
'
)
;
}
var
initializer
=
module
[
'
default
'
]
;
if
(
!
initializer
.
name
)
{
initializer
.
name
=
moduleName
.
slice
(
moduleName
.
lastIndexOf
(
'
/
'
)
+
1
)
;
}
return
initializer
;
}
function
registerInitializers
(
app
moduleNames
)
{
for
(
var
i
=
0
;
i
<
moduleNames
.
length
;
i
+
+
)
{
app
.
initializer
(
resolveInitializer
(
moduleNames
[
i
]
)
)
;
}
}
function
registerInstanceInitializers
(
app
moduleNames
)
{
for
(
var
i
=
0
;
i
<
moduleNames
.
length
;
i
+
+
)
{
app
.
instanceInitializer
(
resolveInitializer
(
moduleNames
[
i
]
)
)
;
}
}
}
)
;
;
define
(
"
ember
-
resolver
/
features
"
[
]
function
(
)
{
"
use
strict
"
;
}
)
;
;
define
(
'
ember
-
resolver
/
index
'
[
'
exports
'
'
ember
-
resolver
/
resolvers
/
classic
'
]
function
(
exports
_classic
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_classic
.
default
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
resolver
/
resolver
'
[
'
exports
'
'
ember
-
resolver
/
resolvers
/
classic
'
]
function
(
exports
_classic
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_classic
.
default
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
resolver
/
resolvers
/
classic
/
container
-
debug
-
adapter
'
[
'
exports
'
'
ember
-
resolver
/
resolvers
/
classic
/
index
'
]
function
(
exports
_index
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
{
ContainerDebugAdapter
}
=
Ember
;
function
getPod
(
type
key
prefix
)
{
let
match
=
key
.
match
(
new
RegExp
(
'
^
/
?
'
+
prefix
+
'
/
(
.
+
)
/
'
+
type
+
'
'
)
)
;
if
(
match
!
=
=
null
)
{
return
match
[
1
]
;
}
}
exports
.
default
=
ContainerDebugAdapter
.
extend
(
{
_moduleRegistry
:
null
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
if
(
!
this
.
_moduleRegistry
)
{
this
.
_moduleRegistry
=
new
_index
.
ModuleRegistry
(
)
;
}
}
canCatalogEntriesByType
(
type
)
{
if
(
type
=
=
=
'
model
'
)
{
return
true
;
}
return
this
.
_super
(
.
.
.
arguments
)
;
}
catalogEntriesByType
(
type
)
{
let
moduleNames
=
this
.
_moduleRegistry
.
moduleNames
(
)
;
let
types
=
Ember
.
A
(
)
;
let
prefix
=
this
.
namespace
.
modulePrefix
;
for
(
let
i
=
0
l
=
moduleNames
.
length
;
i
<
l
;
i
+
+
)
{
let
key
=
moduleNames
[
i
]
;
if
(
key
.
indexOf
(
type
)
!
=
=
-
1
)
{
let
name
=
getPod
(
type
key
this
.
namespace
.
podModulePrefix
|
|
prefix
)
;
if
(
!
name
)
{
name
=
key
.
split
(
type
+
'
s
/
'
)
.
pop
(
)
;
}
types
.
addObject
(
name
)
;
}
}
return
types
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
resolver
/
resolvers
/
classic
/
index
'
[
'
exports
'
'
ember
-
resolver
/
utils
/
class
-
factory
'
'
ember
-
resolver
/
utils
/
make
-
dictionary
'
]
function
(
exports
_classFactory
_makeDictionary
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
ModuleRegistry
=
undefined
;
if
(
typeof
requirejs
.
entries
=
=
=
'
undefined
'
)
{
requirejs
.
entries
=
requirejs
.
_eak_seen
;
}
class
ModuleRegistry
{
constructor
(
entries
)
{
this
.
_entries
=
entries
|
|
requirejs
.
entries
;
}
moduleNames
(
)
{
return
Object
.
keys
(
this
.
_entries
)
;
}
has
(
moduleName
)
{
return
moduleName
in
this
.
_entries
;
}
get
(
moduleName
)
{
return
require
(
moduleName
)
;
}
}
exports
.
ModuleRegistry
=
ModuleRegistry
;
const
{
underscore
classify
dasherize
}
=
Ember
.
String
;
const
{
get
DefaultResolver
}
=
Ember
;
function
parseName
(
fullName
)
{
if
(
fullName
.
parsedName
=
=
=
true
)
{
return
fullName
;
}
let
prefix
type
name
;
let
fullNameParts
=
fullName
.
split
(
'
'
)
;
if
(
fullName
!
=
=
'
helper
:
content
-
helper
'
&
&
fullNameParts
.
length
=
=
=
2
)
{
let
prefixParts
=
fullNameParts
[
0
]
.
split
(
'
:
'
)
;
if
(
prefixParts
.
length
=
=
=
2
)
{
prefix
=
prefixParts
[
1
]
;
type
=
prefixParts
[
0
]
;
name
=
fullNameParts
[
1
]
;
}
else
{
let
nameParts
=
fullNameParts
[
1
]
.
split
(
'
:
'
)
;
prefix
=
fullNameParts
[
0
]
;
type
=
nameParts
[
0
]
;
name
=
nameParts
[
1
]
;
}
if
(
type
=
=
=
'
template
'
&
&
prefix
.
lastIndexOf
(
'
components
/
'
0
)
=
=
=
0
)
{
name
=
components
/
{
name
}
;
prefix
=
prefix
.
slice
(
11
)
;
}
}
else
{
fullNameParts
=
fullName
.
split
(
'
:
'
)
;
type
=
fullNameParts
[
0
]
;
name
=
fullNameParts
[
1
]
;
}
let
fullNameWithoutType
=
name
;
let
namespace
=
get
(
this
'
namespace
'
)
;
let
root
=
namespace
;
return
{
parsedName
:
true
fullName
:
fullName
prefix
:
prefix
|
|
this
.
prefix
(
{
type
:
type
}
)
type
:
type
fullNameWithoutType
:
fullNameWithoutType
name
:
name
root
:
root
resolveMethodName
:
"
resolve
"
+
classify
(
type
)
}
;
}
function
resolveOther
(
parsedName
)
{
Ember
.
assert
(
'
modulePrefix
must
be
defined
'
this
.
namespace
.
modulePrefix
)
;
let
normalizedModuleName
=
this
.
findModuleName
(
parsedName
)
;
if
(
normalizedModuleName
)
{
let
defaultExport
=
this
.
_extractDefaultExport
(
normalizedModuleName
parsedName
)
;
if
(
defaultExport
=
=
=
undefined
)
{
throw
new
Error
(
Expected
to
find
:
'
{
parsedName
.
fullName
}
'
within
'
{
normalizedModuleName
}
'
but
got
'
undefined
'
.
Did
you
forget
to
'
export
default
'
within
'
{
normalizedModuleName
}
'
?
)
;
}
if
(
this
.
shouldWrapInClassFactory
(
defaultExport
parsedName
)
)
{
defaultExport
=
(
0
_classFactory
.
default
)
(
defaultExport
)
;
}
return
defaultExport
;
}
else
{
return
this
.
_super
(
parsedName
)
;
}
}
const
Resolver
=
DefaultResolver
.
extend
(
{
resolveOther
parseName
resolveTemplate
:
resolveOther
pluralizedTypes
:
null
moduleRegistry
:
null
makeToString
(
factory
fullName
)
{
return
'
'
+
this
.
namespace
.
modulePrefix
+
'
'
+
fullName
+
'
:
'
;
}
shouldWrapInClassFactory
(
)
{
return
false
;
}
init
(
)
{
this
.
_super
(
)
;
this
.
moduleBasedResolver
=
true
;
if
(
!
this
.
_moduleRegistry
)
{
this
.
_moduleRegistry
=
new
ModuleRegistry
(
)
;
}
this
.
_normalizeCache
=
(
0
_makeDictionary
.
default
)
(
)
;
this
.
pluralizedTypes
=
this
.
pluralizedTypes
|
|
(
0
_makeDictionary
.
default
)
(
)
;
if
(
!
this
.
pluralizedTypes
.
config
)
{
this
.
pluralizedTypes
.
config
=
'
config
'
;
}
this
.
_deprecatedPodModulePrefix
=
false
;
}
normalize
(
fullName
)
{
return
this
.
_normalizeCache
[
fullName
]
|
|
(
this
.
_normalizeCache
[
fullName
]
=
this
.
_normalize
(
fullName
)
)
;
}
_normalize
(
fullName
)
{
let
split
=
fullName
.
split
(
'
:
'
)
;
if
(
split
.
length
>
1
)
{
if
(
split
[
0
]
=
=
=
'
helper
'
)
{
return
split
[
0
]
+
'
:
'
+
split
[
1
]
.
replace
(
/
_
/
g
'
-
'
)
;
}
else
{
return
split
[
0
]
+
'
:
'
+
dasherize
(
split
[
1
]
.
replace
(
/
\
.
/
g
'
/
'
)
)
;
}
}
else
{
return
fullName
;
}
}
pluralize
(
type
)
{
return
this
.
pluralizedTypes
[
type
]
|
|
(
this
.
pluralizedTypes
[
type
]
=
type
+
'
s
'
)
;
}
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
{
let
fullNameWithoutType
=
parsedName
.
fullNameWithoutType
;
if
(
parsedName
.
type
=
=
=
'
template
'
)
{
fullNameWithoutType
=
fullNameWithoutType
.
replace
(
/
^
components
\
/
/
'
'
)
;
}
return
podPrefix
+
'
/
'
+
fullNameWithoutType
+
'
/
'
+
parsedName
.
type
;
}
podBasedModuleName
(
parsedName
)
{
let
podPrefix
=
this
.
namespace
.
podModulePrefix
|
|
this
.
namespace
.
modulePrefix
;
return
this
.
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
;
}
podBasedComponentsInSubdir
(
parsedName
)
{
let
podPrefix
=
this
.
namespace
.
podModulePrefix
|
|
this
.
namespace
.
modulePrefix
;
podPrefix
=
podPrefix
+
'
/
components
'
;
if
(
parsedName
.
type
=
=
=
'
component
'
|
|
/
^
components
/
.
test
(
parsedName
.
fullNameWithoutType
)
)
{
return
this
.
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
;
}
}
resolveEngine
(
parsedName
)
{
let
engineName
=
parsedName
.
fullNameWithoutType
;
let
engineModule
=
engineName
+
'
/
engine
'
;
if
(
this
.
_moduleRegistry
.
has
(
engineModule
)
)
{
return
this
.
_extractDefaultExport
(
engineModule
)
;
}
}
resolveRouteMap
(
parsedName
)
{
let
engineName
=
parsedName
.
fullNameWithoutType
;
let
engineRoutesModule
=
engineName
+
'
/
routes
'
;
if
(
this
.
_moduleRegistry
.
has
(
engineRoutesModule
)
)
{
let
routeMap
=
this
.
_extractDefaultExport
(
engineRoutesModule
)
;
Ember
.
assert
(
The
route
map
for
{
engineName
}
should
be
wrapped
by
'
buildRoutes
'
before
exporting
.
routeMap
.
isRouteMap
)
;
return
routeMap
;
}
}
mainModuleName
(
parsedName
)
{
let
tmpModuleName
=
parsedName
.
prefix
+
'
/
'
+
parsedName
.
type
;
if
(
parsedName
.
fullNameWithoutType
=
=
=
'
main
'
)
{
return
tmpModuleName
;
}
}
defaultModuleName
(
parsedName
)
{
return
parsedName
.
prefix
+
'
/
'
+
this
.
pluralize
(
parsedName
.
type
)
+
'
/
'
+
parsedName
.
fullNameWithoutType
;
}
prefix
(
parsedName
)
{
let
tmpPrefix
=
this
.
namespace
.
modulePrefix
;
if
(
this
.
namespace
[
parsedName
.
type
+
'
Prefix
'
]
)
{
tmpPrefix
=
this
.
namespace
[
parsedName
.
type
+
'
Prefix
'
]
;
}
return
tmpPrefix
;
}
moduleNameLookupPatterns
:
Ember
.
computed
(
function
(
)
{
return
[
this
.
podBasedModuleName
this
.
podBasedComponentsInSubdir
this
.
mainModuleName
this
.
defaultModuleName
]
;
}
)
.
readOnly
(
)
findModuleName
(
parsedName
loggingDisabled
)
{
let
moduleNameLookupPatterns
=
this
.
get
(
'
moduleNameLookupPatterns
'
)
;
let
moduleName
;
for
(
let
index
=
0
length
=
moduleNameLookupPatterns
.
length
;
index
<
length
;
index
+
+
)
{
let
item
=
moduleNameLookupPatterns
[
index
]
;
let
tmpModuleName
=
item
.
call
(
this
parsedName
)
;
if
(
tmpModuleName
)
{
tmpModuleName
=
this
.
chooseModuleName
(
tmpModuleName
parsedName
)
;
}
if
(
tmpModuleName
&
&
this
.
_moduleRegistry
.
has
(
tmpModuleName
)
)
{
moduleName
=
tmpModuleName
;
}
if
(
!
loggingDisabled
)
{
this
.
_logLookup
(
moduleName
parsedName
tmpModuleName
)
;
}
if
(
moduleName
)
{
return
moduleName
;
}
}
}
chooseModuleName
(
moduleName
parsedName
)
{
let
underscoredModuleName
=
underscore
(
moduleName
)
;
if
(
moduleName
!
=
=
underscoredModuleName
&
&
this
.
_moduleRegistry
.
has
(
moduleName
)
&
&
this
.
_moduleRegistry
.
has
(
underscoredModuleName
)
)
{
throw
new
TypeError
(
Ambiguous
module
names
:
'
{
moduleName
}
'
and
'
{
underscoredModuleName
}
'
)
;
}
if
(
this
.
_moduleRegistry
.
has
(
moduleName
)
)
{
return
moduleName
;
}
else
if
(
this
.
_moduleRegistry
.
has
(
underscoredModuleName
)
)
{
return
underscoredModuleName
;
}
let
partializedModuleName
=
moduleName
.
replace
(
/
\
/
-
(
[
^
/
]
*
)
/
'
/
_
1
'
)
;
if
(
this
.
_moduleRegistry
.
has
(
partializedModuleName
)
)
{
Ember
.
deprecate
(
'
Modules
should
not
contain
underscores
.
'
+
'
Attempted
to
lookup
"
'
+
moduleName
+
'
"
which
'
+
'
was
not
found
.
Please
rename
"
'
+
partializedModuleName
+
'
"
'
+
'
to
"
'
+
moduleName
+
'
"
instead
.
'
false
{
id
:
'
ember
-
resolver
.
underscored
-
modules
'
until
:
'
3
.
0
.
0
'
}
)
;
return
partializedModuleName
;
}
Ember
.
runInDebug
(
(
)
=
>
{
let
isCamelCaseHelper
=
parsedName
.
type
=
=
=
'
helper
'
&
&
/
[
a
-
z
]
+
[
A
-
Z
]
+
/
.
test
(
moduleName
)
;
if
(
isCamelCaseHelper
)
{
this
.
_camelCaseHelperWarnedNames
=
this
.
_camelCaseHelperWarnedNames
|
|
[
]
;
let
alreadyWarned
=
this
.
_camelCaseHelperWarnedNames
.
indexOf
(
parsedName
.
fullName
)
>
-
1
;
if
(
!
alreadyWarned
&
&
this
.
_moduleRegistry
.
has
(
dasherize
(
moduleName
)
)
)
{
this
.
_camelCaseHelperWarnedNames
.
push
(
parsedName
.
fullName
)
;
Ember
.
warn
(
'
Attempted
to
lookup
"
'
+
parsedName
.
fullName
+
'
"
which
'
+
'
was
not
found
.
In
previous
versions
of
ember
-
resolver
a
bug
would
have
'
+
'
caused
the
module
at
"
'
+
dasherize
(
moduleName
)
+
'
"
to
be
'
+
'
returned
for
this
camel
case
helper
name
.
This
has
been
fixed
.
'
+
'
Use
the
dasherized
name
to
resolve
the
module
that
would
have
been
'
+
'
returned
in
previous
versions
.
'
false
{
id
:
'
ember
-
resolver
.
camelcase
-
helper
-
names
'
until
:
'
3
.
0
.
0
'
}
)
;
}
}
}
)
;
}
lookupDescription
(
fullName
)
{
let
parsedName
=
this
.
parseName
(
fullName
)
;
let
moduleName
=
this
.
findModuleName
(
parsedName
true
)
;
return
moduleName
;
}
_logLookup
(
found
parsedName
description
)
{
if
(
!
Ember
.
ENV
.
LOG_MODULE_RESOLVER
&
&
!
parsedName
.
root
.
LOG_RESOLVER
)
{
return
;
}
let
padding
;
let
symbol
=
found
?
'
[
]
'
:
'
[
]
'
;
if
(
parsedName
.
fullName
.
length
>
60
)
{
padding
=
'
.
'
;
}
else
{
padding
=
new
Array
(
60
-
parsedName
.
fullName
.
length
)
.
join
(
'
.
'
)
;
}
if
(
!
description
)
{
description
=
this
.
lookupDescription
(
parsedName
)
;
}
if
(
console
&
&
console
.
info
)
{
console
.
info
(
symbol
parsedName
.
fullName
padding
description
)
;
}
}
knownForType
(
type
)
{
let
moduleKeys
=
this
.
_moduleRegistry
.
moduleNames
(
)
;
let
items
=
(
0
_makeDictionary
.
default
)
(
)
;
for
(
let
index
=
0
length
=
moduleKeys
.
length
;
index
<
length
;
index
+
+
)
{
let
moduleName
=
moduleKeys
[
index
]
;
let
fullname
=
this
.
translateToContainerFullname
(
type
moduleName
)
;
if
(
fullname
)
{
items
[
fullname
]
=
true
;
}
}
return
items
;
}
translateToContainerFullname
(
type
moduleName
)
{
let
prefix
=
this
.
prefix
(
{
type
}
)
;
let
podPrefix
=
prefix
+
'
/
'
;
let
podSuffix
=
'
/
'
+
type
;
let
start
=
moduleName
.
indexOf
(
podPrefix
)
;
let
end
=
moduleName
.
indexOf
(
podSuffix
)
;
if
(
start
=
=
=
0
&
&
end
=
=
=
moduleName
.
length
-
podSuffix
.
length
&
&
moduleName
.
length
>
podPrefix
.
length
+
podSuffix
.
length
)
{
return
type
+
'
:
'
+
moduleName
.
slice
(
start
+
podPrefix
.
length
end
)
;
}
let
pluralizedType
=
this
.
pluralize
(
type
)
;
let
nonPodPrefix
=
prefix
+
'
/
'
+
pluralizedType
+
'
/
'
;
if
(
moduleName
.
indexOf
(
nonPodPrefix
)
=
=
=
0
&
&
moduleName
.
length
>
nonPodPrefix
.
length
)
{
return
type
+
'
:
'
+
moduleName
.
slice
(
nonPodPrefix
.
length
)
;
}
}
_extractDefaultExport
(
normalizedModuleName
)
{
let
module
=
require
(
normalizedModuleName
null
null
true
)
;
if
(
module
&
&
module
[
'
default
'
]
)
{
module
=
module
[
'
default
'
]
;
}
return
module
;
}
}
)
;
Resolver
.
reopenClass
(
{
moduleBasedResolver
:
true
}
)
;
exports
.
default
=
Resolver
;
}
)
;
;
define
(
'
ember
-
resolver
/
utils
/
class
-
factory
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
classFactory
;
function
classFactory
(
klass
)
{
return
{
create
(
injections
)
{
if
(
typeof
klass
.
extend
=
=
=
'
function
'
)
{
return
klass
.
extend
(
injections
)
;
}
else
{
return
klass
;
}
}
}
;
}
}
)
;
;
define
(
'
ember
-
resolver
/
utils
/
make
-
dictionary
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
makeDictionary
;
function
makeDictionary
(
)
{
let
cache
=
Object
.
create
(
null
)
;
cache
[
'
_dict
'
]
=
null
;
delete
cache
[
'
_dict
'
]
;
return
cache
;
}
}
)
;
;
define
(
'
ember
-
welcome
-
page
/
components
/
welcome
-
page
'
[
'
exports
'
'
ember
-
welcome
-
page
/
templates
/
components
/
welcome
-
page
'
]
function
(
exports
_welcomePage
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Component
.
extend
(
{
layout
:
_welcomePage
.
default
emberVersion
:
Ember
.
computed
(
function
(
)
{
let
[
major
minor
]
=
Ember
.
VERSION
.
split
(
"
.
"
)
;
return
{
major
}
.
{
minor
}
.
0
;
}
)
}
)
;
}
)
;
;
define
(
"
ember
-
welcome
-
page
/
templates
/
components
/
welcome
-
page
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
default
=
Ember
.
HTMLBars
.
template
(
{
"
id
"
:
"
D2iezqDS
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
[
6
\
"
div
\
"
]
[
9
\
"
id
\
"
\
"
ember
-
welcome
-
page
-
id
-
selector
\
"
]
[
10
\
"
data
-
ember
-
version
\
"
[
26
[
[
18
\
"
emberVersion
\
"
]
]
]
]
[
7
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
div
\
"
]
[
9
\
"
class
\
"
\
"
columns
\
"
]
[
7
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
div
\
"
]
[
9
\
"
class
\
"
\
"
tomster
\
"
]
[
7
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
img
\
"
]
[
9
\
"
src
\
"
\
"
ember
-
welcome
-
page
/
images
/
construction
.
png
\
"
]
[
9
\
"
alt
\
"
\
"
Under
construction
\
"
]
[
7
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
div
\
"
]
[
9
\
"
class
\
"
\
"
welcome
\
"
]
[
7
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
h2
\
"
]
[
9
\
"
id
\
"
\
"
title
\
"
]
[
7
]
[
0
\
"
Congratulations
you
made
it
!
\
"
]
[
8
]
[
0
\
"
\
\
n
\
\
n
\
"
]
[
6
\
"
p
\
"
]
[
7
]
[
0
\
"
You
ve
officially
spun
up
your
very
first
Ember
app
:
-
)
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
p
\
"
]
[
7
]
[
0
\
"
You
ve
got
one
more
decision
to
make
:
what
do
you
want
to
do
next
?
We
d
suggest
one
of
the
following
to
help
you
get
going
:
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
ol
\
"
]
[
7
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
li
\
"
]
[
7
]
[
6
\
"
a
\
"
]
[
10
\
"
href
\
"
[
26
[
\
"
https
:
/
/
guides
.
emberjs
.
com
/
v
\
"
[
18
\
"
emberVersion
\
"
]
\
"
/
getting
-
started
/
quick
-
start
/
\
"
]
]
]
[
7
]
[
0
\
"
Quick
Start
\
"
]
[
8
]
[
0
\
"
-
a
quick
introduction
to
how
Ember
works
.
Learn
about
defining
your
first
route
writing
a
UI
component
and
deploying
your
application
.
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
li
\
"
]
[
7
]
[
6
\
"
a
\
"
]
[
10
\
"
href
\
"
[
26
[
\
"
https
:
/
/
guides
.
emberjs
.
com
/
v
\
"
[
18
\
"
emberVersion
\
"
]
\
"
/
tutorial
/
ember
-
cli
/
\
"
]
]
]
[
7
]
[
0
\
"
Ember
Guides
\
"
]
[
8
]
[
0
\
"
-
this
is
our
more
thorough
hands
-
on
intro
to
Ember
.
Your
crash
course
in
Ember
philosophy
background
and
some
in
-
depth
discussion
of
how
things
work
(
and
why
they
work
the
way
they
do
)
.
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
p
\
"
]
[
7
]
[
0
\
"
If
you
run
into
problems
you
can
check
\
"
]
[
6
\
"
a
\
"
]
[
9
\
"
href
\
"
\
"
http
:
/
/
stackoverflow
.
com
/
questions
/
tagged
/
ember
.
js
\
"
]
[
7
]
[
0
\
"
Stack
Overflow
\
"
]
[
8
]
[
0
\
"
or
\
"
]
[
6
\
"
a
\
"
]
[
9
\
"
href
\
"
\
"
http
:
/
/
discuss
.
emberjs
.
com
/
\
"
]
[
7
]
[
0
\
"
our
forums
\
"
]
[
8
]
[
0
\
"
for
ideas
and
answers
someone
s
probably
been
through
the
same
thing
and
already
posted
an
answer
.
If
not
you
can
post
your
\
"
]
[
6
\
"
strong
\
"
]
[
7
]
[
0
\
"
own
\
"
]
[
8
]
[
0
\
"
question
.
People
love
to
help
new
Ember
developers
get
started
and
our
community
is
incredibly
supportive
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
6
\
"
p
\
"
]
[
9
\
"
class
\
"
\
"
postscript
\
"
]
[
7
]
[
0
\
"
To
remove
this
welcome
message
remove
the
\
"
]
[
6
\
"
code
\
"
]
[
7
]
[
0
\
"
{
{
welcome
-
page
}
}
\
"
]
[
8
]
[
0
\
"
component
from
your
\
"
]
[
6
\
"
code
\
"
]
[
7
]
[
0
\
"
application
.
hbs
\
"
]
[
8
]
[
0
\
"
file
.
\
"
]
[
6
\
"
br
\
"
]
[
7
]
[
8
]
[
0
\
"
You
'
ll
see
this
page
update
soon
after
!
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
[
8
]
[
0
\
"
\
\
n
\
"
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
"
moduleName
"
:
"
ember
-
welcome
-
page
/
templates
/
components
/
welcome
-
page
.
hbs
"
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
-
debug
/
index
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
instrument
=
instrument
;
function
instrument
(
method
)
{
return
method
(
)
;
}
var
assertPolymorphicType
=
void
0
;
if
(
true
)
{
var
checkPolymorphic
=
function
checkPolymorphic
(
modelClass
addedModelClass
)
{
if
(
modelClass
.
__isMixin
)
{
return
modelClass
.
__mixin
.
detect
(
addedModelClass
.
PrototypeMixin
)
;
}
if
(
Ember
.
MODEL_FACTORY_INJECTIONS
)
{
modelClass
=
modelClass
.
superclass
;
}
return
modelClass
.
detect
(
addedModelClass
)
;
}
;
exports
.
assertPolymorphicType
=
assertPolymorphicType
=
function
assertPolymorphicType
(
parentInternalModel
relationshipMeta
addedInternalModel
)
{
var
addedModelName
=
addedInternalModel
.
modelName
;
var
parentModelName
=
parentInternalModel
.
modelName
;
var
key
=
relationshipMeta
.
key
;
var
relationshipModelName
=
relationshipMeta
.
type
;
var
relationshipClass
=
parentInternalModel
.
store
.
modelFor
(
relationshipModelName
)
;
var
assertionMessage
=
You
cannot
add
a
record
of
modelClass
'
{
addedModelName
}
'
to
the
'
{
parentModelName
}
.
{
key
}
'
relationship
(
only
'
{
relationshipModelName
}
'
allowed
)
;
(
true
&
&
!
(
checkPolymorphic
(
relationshipClass
addedInternalModel
.
modelClass
)
)
&
&
Ember
.
assert
(
assertionMessage
checkPolymorphic
(
relationshipClass
addedInternalModel
.
modelClass
)
)
)
;
}
;
}
exports
.
assertPolymorphicType
=
assertPolymorphicType
;
}
)
;
;
define
(
'
ember
-
data
/
-
private
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
data
/
-
debug
'
'
ember
-
data
/
version
'
]
function
(
exports
emberInflector
emberData_Debug
VERSION
)
{
'
use
strict
'
;
VERSION
=
'
default
'
in
VERSION
?
VERSION
[
'
default
'
]
:
VERSION
;
var
PromiseArray
=
Ember
.
ArrayProxy
.
extend
(
Ember
.
PromiseProxyMixin
{
meta
:
Ember
.
computed
.
reads
(
'
content
.
meta
'
)
}
)
;
var
PromiseObject
=
Ember
.
ObjectProxy
.
extend
(
Ember
.
PromiseProxyMixin
)
;
function
promiseObject
(
promise
label
)
{
return
PromiseObject
.
create
(
{
promise
:
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
}
)
;
}
function
promiseArray
(
promise
label
)
{
return
PromiseArray
.
create
(
{
promise
:
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
}
)
;
}
function
proxyToContent
(
method
)
{
return
function
(
)
{
return
Ember
.
get
(
this
'
content
'
)
[
method
]
(
.
.
.
arguments
)
;
}
;
}
var
PromiseManyArray
=
PromiseArray
.
extend
(
{
reload
(
)
{
(
true
&
&
!
(
Ember
.
get
(
this
'
content
'
)
)
&
&
Ember
.
assert
(
'
You
are
trying
to
reload
an
async
manyArray
before
it
has
been
created
'
Ember
.
get
(
this
'
content
'
)
)
)
;
this
.
set
(
'
promise
'
this
.
get
(
'
content
'
)
.
reload
(
)
)
;
return
this
;
}
createRecord
:
proxyToContent
(
'
createRecord
'
)
on
:
proxyToContent
(
'
on
'
)
one
:
proxyToContent
(
'
one
'
)
trigger
:
proxyToContent
(
'
trigger
'
)
off
:
proxyToContent
(
'
off
'
)
has
:
proxyToContent
(
'
has
'
)
}
)
;
var
Errors
=
Ember
.
ArrayProxy
.
extend
(
Ember
.
Evented
{
registerHandlers
(
target
becameInvalid
becameValid
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
Record
errors
will
no
longer
be
evented
.
false
{
id
:
'
ds
.
errors
.
registerHandlers
'
until
:
'
3
.
0
.
0
'
}
)
)
;
this
.
_registerHandlers
(
target
becameInvalid
becameValid
)
;
}
_registerHandlers
(
target
becameInvalid
becameValid
)
{
this
.
on
(
'
becameInvalid
'
target
becameInvalid
)
;
this
.
on
(
'
becameValid
'
target
becameValid
)
;
}
errorsByAttributeName
:
Ember
.
computed
(
function
(
)
{
return
Ember
.
MapWithDefault
.
create
(
{
defaultValue
(
)
{
return
Ember
.
A
(
)
;
}
}
)
;
}
)
errorsFor
(
attribute
)
{
return
Ember
.
get
(
this
'
errorsByAttributeName
'
)
.
get
(
attribute
)
;
}
messages
:
Ember
.
computed
.
mapBy
(
'
content
'
'
message
'
)
content
:
Ember
.
computed
(
function
(
)
{
return
Ember
.
A
(
)
;
}
)
unknownProperty
(
attribute
)
{
var
errors
=
this
.
errorsFor
(
attribute
)
;
if
(
Ember
.
isEmpty
(
errors
)
)
{
return
undefined
;
}
return
errors
;
}
isEmpty
:
Ember
.
computed
.
not
(
'
length
'
)
.
readOnly
(
)
add
(
attribute
messages
)
{
(
true
&
&
Ember
.
warn
(
Interacting
with
a
record
errors
object
will
no
longer
change
the
record
state
.
false
{
id
:
'
ds
.
errors
.
add
'
}
)
)
;
var
wasEmpty
=
Ember
.
get
(
this
'
isEmpty
'
)
;
this
.
_add
(
attribute
messages
)
;
if
(
wasEmpty
&
&
!
Ember
.
get
(
this
'
isEmpty
'
)
)
{
this
.
trigger
(
'
becameInvalid
'
)
;
}
}
_add
(
attribute
messages
)
{
messages
=
this
.
_findOrCreateMessages
(
attribute
messages
)
;
this
.
addObjects
(
messages
)
;
Ember
.
get
(
this
'
errorsByAttributeName
'
)
.
get
(
attribute
)
.
addObjects
(
messages
)
;
this
.
notifyPropertyChange
(
attribute
)
;
}
_findOrCreateMessages
(
attribute
messages
)
{
var
errors
=
this
.
errorsFor
(
attribute
)
;
var
messagesArray
=
Ember
.
makeArray
(
messages
)
;
var
_messages
=
new
Array
(
messagesArray
.
length
)
;
for
(
var
i
=
0
;
i
<
messagesArray
.
length
;
i
+
+
)
{
var
message
=
messagesArray
[
i
]
;
var
err
=
errors
.
findBy
(
'
message
'
message
)
;
if
(
err
)
{
_messages
[
i
]
=
err
;
}
else
{
_messages
[
i
]
=
{
attribute
:
attribute
message
:
message
}
;
}
}
return
_messages
;
}
remove
(
attribute
)
{
(
true
&
&
Ember
.
warn
(
Interacting
with
a
record
errors
object
will
no
longer
change
the
record
state
.
false
{
id
:
'
ds
.
errors
.
remove
'
}
)
)
;
if
(
Ember
.
get
(
this
'
isEmpty
'
)
)
{
return
;
}
this
.
_remove
(
attribute
)
;
if
(
Ember
.
get
(
this
'
isEmpty
'
)
)
{
this
.
trigger
(
'
becameValid
'
)
;
}
}
_remove
(
attribute
)
{
if
(
Ember
.
get
(
this
'
isEmpty
'
)
)
{
return
;
}
var
content
=
this
.
rejectBy
(
'
attribute
'
attribute
)
;
Ember
.
set
(
this
'
content
'
content
)
;
Ember
.
get
(
this
'
errorsByAttributeName
'
)
.
delete
(
attribute
)
;
this
.
notifyPropertyChange
(
attribute
)
;
this
.
notifyPropertyChange
(
'
length
'
)
;
}
clear
(
)
{
(
true
&
&
Ember
.
warn
(
Interacting
with
a
record
errors
object
will
no
longer
change
the
record
state
.
false
{
id
:
'
ds
.
errors
.
clear
'
}
)
)
;
if
(
Ember
.
get
(
this
'
isEmpty
'
)
)
{
return
;
}
this
.
_clear
(
)
;
this
.
trigger
(
'
becameValid
'
)
;
}
_clear
(
)
{
if
(
Ember
.
get
(
this
'
isEmpty
'
)
)
{
return
;
}
var
errorsByAttributeName
=
Ember
.
get
(
this
'
errorsByAttributeName
'
)
;
var
attributes
=
Ember
.
A
(
)
;
errorsByAttributeName
.
forEach
(
function
(
_
attribute
)
{
attributes
.
push
(
attribute
)
;
}
)
;
errorsByAttributeName
.
clear
(
)
;
attributes
.
forEach
(
function
(
attribute
)
{
this
.
notifyPropertyChange
(
attribute
)
;
}
this
)
;
Ember
.
ArrayProxy
.
prototype
.
clear
.
call
(
this
)
;
}
has
(
attribute
)
{
return
!
Ember
.
isEmpty
(
this
.
errorsFor
(
attribute
)
)
;
}
}
)
;
function
isEnabled
(
)
{
return
Ember
.
FEATURES
.
isEnabled
(
.
.
.
arguments
)
;
}
function
didSetProperty
(
internalModel
context
)
{
if
(
context
.
value
=
=
=
context
.
originalValue
)
{
delete
internalModel
.
_attributes
[
context
.
name
]
;
internalModel
.
send
(
'
propertyWasReset
'
context
.
name
)
;
}
else
if
(
context
.
value
!
=
=
context
.
oldValue
)
{
internalModel
.
send
(
'
becomeDirty
'
)
;
}
internalModel
.
updateRecordArrays
(
)
;
}
var
DirtyState
=
{
initialState
:
'
uncommitted
'
isDirty
:
true
uncommitted
:
{
didSetProperty
loadingData
(
)
{
}
propertyWasReset
(
internalModel
name
)
{
if
(
!
internalModel
.
hasChangedAttributes
(
)
)
{
internalModel
.
send
(
'
rolledBack
'
)
;
}
}
pushedData
(
internalModel
)
{
internalModel
.
updateChangedAttributes
(
)
;
if
(
!
internalModel
.
hasChangedAttributes
(
)
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
}
}
becomeDirty
(
)
{
}
willCommit
(
internalModel
)
{
internalModel
.
transitionTo
(
'
inFlight
'
)
;
}
reloadRecord
(
internalModel
resolve
)
{
resolve
(
internalModel
.
store
.
_reloadRecord
(
internalModel
)
)
;
}
rolledBack
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
}
becameInvalid
(
internalModel
)
{
internalModel
.
transitionTo
(
'
invalid
'
)
;
}
rollback
(
internalModel
)
{
internalModel
.
rollbackAttributes
(
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
}
inFlight
:
{
isSaving
:
true
didSetProperty
becomeDirty
(
)
{
}
pushedData
(
)
{
}
unloadRecord
:
assertAgainstUnloadRecord
willCommit
(
)
{
}
didCommit
(
internalModel
)
{
internalModel
.
transitionTo
(
'
saved
'
)
;
internalModel
.
send
(
'
invokeLifecycleCallbacks
'
this
.
dirtyType
)
;
}
becameInvalid
(
internalModel
)
{
internalModel
.
transitionTo
(
'
invalid
'
)
;
internalModel
.
send
(
'
invokeLifecycleCallbacks
'
)
;
}
becameError
(
internalModel
)
{
internalModel
.
transitionTo
(
'
uncommitted
'
)
;
internalModel
.
triggerLater
(
'
becameError
'
internalModel
)
;
}
}
invalid
:
{
isValid
:
false
deleteRecord
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
uncommitted
'
)
;
}
didSetProperty
(
internalModel
context
)
{
internalModel
.
removeErrorMessageFromAttribute
(
context
.
name
)
;
didSetProperty
(
internalModel
context
)
;
if
(
!
internalModel
.
hasErrors
(
)
)
{
this
.
becameValid
(
internalModel
)
;
}
}
becameInvalid
(
)
{
}
becomeDirty
(
)
{
}
pushedData
(
)
{
}
willCommit
(
internalModel
)
{
internalModel
.
clearErrorMessages
(
)
;
internalModel
.
transitionTo
(
'
inFlight
'
)
;
}
rolledBack
(
internalModel
)
{
internalModel
.
clearErrorMessages
(
)
;
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
becameValid
(
internalModel
)
{
internalModel
.
transitionTo
(
'
uncommitted
'
)
;
}
invokeLifecycleCallbacks
(
internalModel
)
{
internalModel
.
triggerLater
(
'
becameInvalid
'
internalModel
)
;
}
}
}
;
function
deepClone
(
object
)
{
var
clone
=
{
}
;
var
value
=
void
0
;
for
(
var
prop
in
object
)
{
value
=
object
[
prop
]
;
if
(
value
&
&
typeof
value
=
=
=
'
object
'
)
{
clone
[
prop
]
=
deepClone
(
value
)
;
}
else
{
clone
[
prop
]
=
value
;
}
}
return
clone
;
}
function
mixin
(
original
hash
)
{
for
(
var
prop
in
hash
)
{
original
[
prop
]
=
hash
[
prop
]
;
}
return
original
;
}
function
dirtyState
(
options
)
{
var
newState
=
deepClone
(
DirtyState
)
;
return
mixin
(
newState
options
)
;
}
var
createdState
=
dirtyState
(
{
dirtyType
:
'
created
'
isNew
:
true
}
)
;
createdState
.
invalid
.
rolledBack
=
function
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
saved
'
)
;
}
;
createdState
.
uncommitted
.
rolledBack
=
function
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
saved
'
)
;
}
;
var
updatedState
=
dirtyState
(
{
dirtyType
:
'
updated
'
}
)
;
function
createdStateDeleteRecord
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
saved
'
)
;
internalModel
.
send
(
'
invokeLifecycleCallbacks
'
)
;
}
createdState
.
uncommitted
.
deleteRecord
=
createdStateDeleteRecord
;
createdState
.
invalid
.
deleteRecord
=
createdStateDeleteRecord
;
createdState
.
uncommitted
.
rollback
=
function
(
internalModel
)
{
DirtyState
.
uncommitted
.
rollback
.
apply
(
this
arguments
)
;
internalModel
.
transitionTo
(
'
deleted
.
saved
'
)
;
}
;
createdState
.
uncommitted
.
pushedData
=
function
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
updated
.
uncommitted
'
)
;
internalModel
.
triggerLater
(
'
didLoad
'
)
;
}
;
createdState
.
uncommitted
.
propertyWasReset
=
function
(
)
{
}
;
function
assertAgainstUnloadRecord
(
internalModel
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
"
You
can
only
unload
a
record
which
is
not
inFlight
.
"
+
internalModel
+
"
"
false
)
)
;
}
updatedState
.
invalid
.
becameValid
=
function
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
}
;
updatedState
.
inFlight
.
unloadRecord
=
assertAgainstUnloadRecord
;
updatedState
.
uncommitted
.
deleteRecord
=
function
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
uncommitted
'
)
;
}
;
var
RootState
=
{
isEmpty
:
false
isLoading
:
false
isLoaded
:
false
isDirty
:
false
isSaving
:
false
isDeleted
:
false
isNew
:
false
isValid
:
true
rolledBack
(
)
{
}
unloadRecord
(
internalModel
)
{
}
propertyWasReset
(
)
{
}
empty
:
{
isEmpty
:
true
loadingData
(
internalModel
promise
)
{
internalModel
.
_loadingPromise
=
promise
;
internalModel
.
transitionTo
(
'
loading
'
)
;
}
loadedData
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
created
.
uncommitted
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
pushedData
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
internalModel
.
triggerLater
(
'
didLoad
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
}
loading
:
{
isLoading
:
true
exit
(
internalModel
)
{
internalModel
.
_loadingPromise
=
null
;
}
pushedData
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
internalModel
.
triggerLater
(
'
didLoad
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
internalModel
.
didCleanError
(
)
;
}
becameError
(
internalModel
)
{
internalModel
.
triggerLater
(
'
becameError
'
internalModel
)
;
}
notFound
(
internalModel
)
{
internalModel
.
transitionTo
(
'
empty
'
)
;
}
}
loaded
:
{
initialState
:
'
saved
'
isLoaded
:
true
loadingData
(
)
{
}
saved
:
{
setup
(
internalModel
)
{
if
(
internalModel
.
hasChangedAttributes
(
)
)
{
internalModel
.
adapterDidDirty
(
)
;
}
}
didSetProperty
pushedData
(
)
{
}
becomeDirty
(
internalModel
)
{
internalModel
.
transitionTo
(
'
updated
.
uncommitted
'
)
;
}
willCommit
(
internalModel
)
{
internalModel
.
transitionTo
(
'
updated
.
inFlight
'
)
;
}
reloadRecord
(
internalModel
resolve
)
{
resolve
(
internalModel
.
store
.
_reloadRecord
(
internalModel
)
)
;
}
deleteRecord
(
internalModel
)
{
internalModel
.
transitionTo
(
'
deleted
.
uncommitted
'
)
;
}
unloadRecord
(
internalModel
)
{
}
didCommit
(
)
{
}
notFound
(
)
{
}
}
created
:
createdState
updated
:
updatedState
}
deleted
:
{
initialState
:
'
uncommitted
'
dirtyType
:
'
deleted
'
isDeleted
:
true
isLoaded
:
true
isDirty
:
true
setup
(
internalModel
)
{
internalModel
.
updateRecordArrays
(
)
;
}
uncommitted
:
{
willCommit
(
internalModel
)
{
internalModel
.
transitionTo
(
'
inFlight
'
)
;
}
rollback
(
internalModel
)
{
internalModel
.
rollbackAttributes
(
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
pushedData
(
)
{
}
becomeDirty
(
)
{
}
deleteRecord
(
)
{
}
rolledBack
(
internalModel
)
{
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
}
inFlight
:
{
isSaving
:
true
unloadRecord
:
assertAgainstUnloadRecord
willCommit
(
)
{
}
didCommit
(
internalModel
)
{
internalModel
.
transitionTo
(
'
saved
'
)
;
internalModel
.
send
(
'
invokeLifecycleCallbacks
'
)
;
}
becameError
(
internalModel
)
{
internalModel
.
transitionTo
(
'
uncommitted
'
)
;
internalModel
.
triggerLater
(
'
becameError
'
internalModel
)
;
}
becameInvalid
(
internalModel
)
{
internalModel
.
transitionTo
(
'
invalid
'
)
;
internalModel
.
triggerLater
(
'
becameInvalid
'
internalModel
)
;
}
}
saved
:
{
isDirty
:
false
setup
(
internalModel
)
{
internalModel
.
removeFromInverseRelationships
(
)
;
}
invokeLifecycleCallbacks
(
internalModel
)
{
internalModel
.
triggerLater
(
'
didDelete
'
internalModel
)
;
internalModel
.
triggerLater
(
'
didCommit
'
internalModel
)
;
}
willCommit
(
)
{
}
didCommit
(
)
{
}
}
invalid
:
{
isValid
:
false
didSetProperty
(
internalModel
context
)
{
internalModel
.
removeErrorMessageFromAttribute
(
context
.
name
)
;
didSetProperty
(
internalModel
context
)
;
if
(
!
internalModel
.
hasErrors
(
)
)
{
this
.
becameValid
(
internalModel
)
;
}
}
becameInvalid
(
)
{
}
becomeDirty
(
)
{
}
deleteRecord
(
)
{
}
willCommit
(
)
{
}
rolledBack
(
internalModel
)
{
internalModel
.
clearErrorMessages
(
)
;
internalModel
.
transitionTo
(
'
loaded
.
saved
'
)
;
internalModel
.
triggerLater
(
'
ready
'
)
;
}
becameValid
(
internalModel
)
{
internalModel
.
transitionTo
(
'
uncommitted
'
)
;
}
}
}
invokeLifecycleCallbacks
(
internalModel
dirtyType
)
{
if
(
dirtyType
=
=
=
'
created
'
)
{
internalModel
.
triggerLater
(
'
didCreate
'
internalModel
)
;
}
else
{
internalModel
.
triggerLater
(
'
didUpdate
'
internalModel
)
;
}
internalModel
.
triggerLater
(
'
didCommit
'
internalModel
)
;
}
}
;
function
wireState
(
object
parent
name
)
{
object
=
mixin
(
parent
?
Object
.
create
(
parent
)
:
{
}
object
)
;
object
.
parentState
=
parent
;
object
.
stateName
=
name
;
for
(
var
prop
in
object
)
{
if
(
!
object
.
hasOwnProperty
(
prop
)
|
|
prop
=
=
=
'
parentState
'
|
|
prop
=
=
=
'
stateName
'
)
{
continue
;
}
if
(
typeof
object
[
prop
]
=
=
=
'
object
'
)
{
object
[
prop
]
=
wireState
(
object
[
prop
]
object
name
+
'
.
'
+
prop
)
;
}
}
return
object
;
}
var
RootState
1
=
wireState
(
RootState
null
'
root
'
)
;
function
normalizeModelName
(
modelName
)
{
return
Ember
.
String
.
dasherize
(
modelName
)
;
}
function
typeForRelationshipMeta
(
meta
)
{
var
modelName
=
void
0
;
modelName
=
meta
.
type
|
|
meta
.
key
;
if
(
meta
.
kind
=
=
=
'
hasMany
'
)
{
modelName
=
emberInflector
.
singularize
(
normalizeModelName
(
modelName
)
)
;
}
return
modelName
;
}
function
relationshipFromMeta
(
meta
)
{
return
{
key
:
meta
.
key
kind
:
meta
.
kind
type
:
typeForRelationshipMeta
(
meta
)
options
:
meta
.
options
name
:
meta
.
name
parentType
:
meta
.
parentType
isRelationship
:
true
}
;
}
var
relationshipsDescriptor
=
Ember
.
computed
(
function
(
)
{
var
map
=
new
Ember
.
MapWithDefault
(
{
defaultValue
(
)
{
return
[
]
;
}
}
)
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isRelationship
)
{
meta
.
key
=
name
;
var
relationshipsForType
=
map
.
get
(
typeForRelationshipMeta
(
meta
)
)
;
relationshipsForType
.
push
(
{
name
:
name
kind
:
meta
.
kind
}
)
;
}
}
)
;
return
map
;
}
)
.
readOnly
(
)
;
var
relatedTypesDescriptor
=
Ember
.
computed
(
function
(
)
{
var
modelName
=
void
0
;
var
types
=
Ember
.
A
(
)
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isRelationship
)
{
meta
.
key
=
name
;
modelName
=
typeForRelationshipMeta
(
meta
)
;
(
true
&
&
!
(
modelName
)
&
&
Ember
.
assert
(
You
specified
a
hasMany
(
{
meta
.
type
}
)
on
{
meta
.
parentType
}
but
{
meta
.
type
}
was
not
found
.
modelName
)
)
;
if
(
!
types
.
includes
(
modelName
)
)
{
(
true
&
&
!
(
!
!
modelName
)
&
&
Ember
.
assert
(
Trying
to
sideload
{
name
}
on
{
this
.
toString
(
)
}
but
the
type
doesn
'
t
exist
.
!
!
modelName
)
)
;
types
.
push
(
modelName
)
;
}
}
}
)
;
return
types
;
}
)
.
readOnly
(
)
;
var
relationshipsByNameDescriptor
=
Ember
.
computed
(
function
(
)
{
var
map
=
Ember
.
Map
.
create
(
)
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isRelationship
)
{
meta
.
key
=
name
;
var
relationship
=
relationshipFromMeta
(
meta
)
;
relationship
.
type
=
typeForRelationshipMeta
(
meta
)
;
map
.
set
(
name
relationship
)
;
}
}
)
;
return
map
;
}
)
.
readOnly
(
)
;
function
findPossibleInverses
(
type
inverseType
name
relationshipsSoFar
)
{
var
possibleRelationships
=
relationshipsSoFar
|
|
[
]
;
var
relationshipMap
=
Ember
.
get
(
inverseType
'
relationships
'
)
;
if
(
!
relationshipMap
)
{
return
possibleRelationships
;
}
var
relationships
=
relationshipMap
.
get
(
type
.
modelName
)
.
filter
(
relationship
=
>
{
var
optionsForRelationship
=
inverseType
.
metaForProperty
(
relationship
.
name
)
.
options
;
if
(
!
optionsForRelationship
.
inverse
&
&
optionsForRelationship
.
inverse
!
=
=
null
)
{
return
true
;
}
return
name
=
=
=
optionsForRelationship
.
inverse
;
}
)
;
if
(
relationships
)
{
possibleRelationships
.
push
.
apply
(
possibleRelationships
relationships
)
;
}
if
(
type
.
superclass
)
{
findPossibleInverses
(
type
.
superclass
inverseType
name
possibleRelationships
)
;
}
return
possibleRelationships
;
}
function
intersection
(
array1
array2
)
{
var
result
=
[
]
;
array1
.
forEach
(
element
=
>
{
if
(
array2
.
indexOf
(
element
)
>
=
0
)
{
result
.
push
(
element
)
;
}
}
)
;
return
result
;
}
var
RESERVED_MODEL_PROPS
=
[
'
currentState
'
'
data
'
'
store
'
]
;
var
retrieveFromCurrentState
=
Ember
.
computed
(
'
currentState
'
function
(
key
)
{
return
Ember
.
get
(
this
.
_internalModel
.
currentState
key
)
;
}
)
.
readOnly
(
)
;
var
Model
=
Ember
.
Object
.
extend
(
Ember
.
Evented
{
_internalModel
:
null
store
:
null
__defineNonEnumerable
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
isEmpty
:
retrieveFromCurrentState
isLoading
:
retrieveFromCurrentState
isLoaded
:
retrieveFromCurrentState
hasDirtyAttributes
:
Ember
.
computed
(
'
currentState
.
isDirty
'
function
(
)
{
return
this
.
get
(
'
currentState
.
isDirty
'
)
;
}
)
isSaving
:
retrieveFromCurrentState
isDeleted
:
retrieveFromCurrentState
isNew
:
retrieveFromCurrentState
isValid
:
retrieveFromCurrentState
dirtyType
:
retrieveFromCurrentState
isError
:
false
isReloading
:
false
id
:
null
currentState
:
RootState
1
.
empty
errors
:
Ember
.
computed
(
function
(
)
{
var
errors
=
Errors
.
create
(
)
;
errors
.
_registerHandlers
(
this
.
_internalModel
function
(
)
{
this
.
send
(
'
becameInvalid
'
)
;
}
function
(
)
{
this
.
send
(
'
becameValid
'
)
;
}
)
;
return
errors
;
}
)
.
readOnly
(
)
adapterError
:
null
serialize
(
options
)
{
return
this
.
_internalModel
.
createSnapshot
(
)
.
serialize
(
options
)
;
}
toJSON
(
options
)
{
var
serializer
=
this
.
store
.
serializerFor
(
'
-
default
'
)
;
var
snapshot
=
this
.
_internalModel
.
createSnapshot
(
)
;
return
serializer
.
serialize
(
snapshot
options
)
;
}
ready
:
null
didLoad
:
null
didUpdate
:
null
didCreate
:
null
didDelete
:
null
becameInvalid
:
null
becameError
:
null
rolledBack
:
null
send
(
name
context
)
{
return
this
.
_internalModel
.
send
(
name
context
)
;
}
transitionTo
(
name
)
{
return
this
.
_internalModel
.
transitionTo
(
name
)
;
}
deleteRecord
(
)
{
this
.
_internalModel
.
deleteRecord
(
)
;
}
destroyRecord
(
options
)
{
this
.
deleteRecord
(
)
;
return
this
.
save
(
options
)
;
}
unloadRecord
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
this
.
_internalModel
.
unloadRecord
(
)
;
}
_notifyProperties
(
keys
)
{
Ember
.
beginPropertyChanges
(
)
;
var
key
=
void
0
;
for
(
var
i
=
0
length
=
keys
.
length
;
i
<
length
;
i
+
+
)
{
key
=
keys
[
i
]
;
this
.
notifyPropertyChange
(
key
)
;
}
Ember
.
endPropertyChanges
(
)
;
}
changedAttributes
(
)
{
return
this
.
_internalModel
.
changedAttributes
(
)
;
}
rollbackAttributes
(
)
{
this
.
_internalModel
.
rollbackAttributes
(
)
;
}
_createSnapshot
(
)
{
return
this
.
_internalModel
.
createSnapshot
(
)
;
}
toStringExtension
(
)
{
return
Ember
.
get
(
this
'
id
'
)
;
}
save
(
options
)
{
return
PromiseObject
.
create
(
{
promise
:
this
.
_internalModel
.
save
(
options
)
.
then
(
(
)
=
>
this
)
}
)
;
}
reload
(
)
{
return
PromiseObject
.
create
(
{
promise
:
this
.
_internalModel
.
reload
(
)
.
then
(
(
)
=
>
this
)
}
)
;
}
trigger
(
name
)
{
var
fn
=
this
[
name
]
;
if
(
typeof
fn
=
=
=
'
function
'
)
{
var
length
=
arguments
.
length
;
var
args
=
new
Array
(
length
-
1
)
;
for
(
var
i
=
1
;
i
<
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
fn
.
apply
(
this
args
)
;
}
this
.
_super
(
.
.
.
arguments
)
;
}
attr
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
"
The
attr
method
is
not
available
on
DS
.
Model
a
DS
.
Snapshot
was
probably
expected
.
Are
you
passing
a
DS
.
Model
instead
of
a
DS
.
Snapshot
to
your
serializer
?
"
false
)
)
;
}
belongsTo
(
name
)
{
return
this
.
_internalModel
.
referenceFor
(
'
belongsTo
'
name
)
;
}
hasMany
(
name
)
{
return
this
.
_internalModel
.
referenceFor
(
'
hasMany
'
name
)
;
}
setId
:
Ember
.
observer
(
'
id
'
function
(
)
{
this
.
_internalModel
.
setId
(
this
.
get
(
'
id
'
)
)
;
}
)
_debugInfo
(
)
{
var
attributes
=
[
'
id
'
]
;
var
relationships
=
{
}
;
var
expensiveProperties
=
[
]
;
this
.
eachAttribute
(
(
name
meta
)
=
>
attributes
.
push
(
name
)
)
;
var
groups
=
[
{
name
:
'
Attributes
'
properties
:
attributes
expand
:
true
}
]
;
this
.
eachRelationship
(
(
name
relationship
)
=
>
{
var
properties
=
relationships
[
relationship
.
kind
]
;
if
(
properties
=
=
=
undefined
)
{
properties
=
relationships
[
relationship
.
kind
]
=
[
]
;
groups
.
push
(
{
name
:
relationship
.
name
properties
expand
:
true
}
)
;
}
properties
.
push
(
name
)
;
expensiveProperties
.
push
(
name
)
;
}
)
;
groups
.
push
(
{
name
:
'
Flags
'
properties
:
[
'
isLoaded
'
'
hasDirtyAttributes
'
'
isSaving
'
'
isDeleted
'
'
isError
'
'
isNew
'
'
isValid
'
]
}
)
;
return
{
propertyInfo
:
{
includeOtherProperties
:
true
groups
:
groups
expensiveProperties
:
expensiveProperties
}
}
;
}
notifyBelongsToChanged
(
key
)
{
this
.
notifyPropertyChange
(
key
)
;
}
eachRelationship
(
callback
binding
)
{
this
.
constructor
.
eachRelationship
(
callback
binding
)
;
}
relationshipFor
(
name
)
{
return
Ember
.
get
(
this
.
constructor
'
relationshipsByName
'
)
.
get
(
name
)
;
}
inverseFor
(
key
)
{
return
this
.
constructor
.
inverseFor
(
key
this
.
store
)
;
}
notifyHasManyAdded
(
key
)
{
this
.
notifyPropertyChange
(
key
)
;
}
eachAttribute
(
callback
binding
)
{
this
.
constructor
.
eachAttribute
(
callback
binding
)
;
}
}
)
;
Object
.
defineProperty
(
Model
.
prototype
'
data
'
{
get
(
)
{
return
this
.
_internalModel
.
_data
;
}
}
)
;
{
Model
.
reopen
(
{
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
if
(
!
this
.
_internalModel
)
{
throw
new
Ember
.
Error
(
'
You
should
not
call
create
on
a
model
.
Instead
call
store
.
createRecord
with
the
attributes
you
would
like
to
set
.
'
)
;
}
}
}
)
;
}
Model
.
reopenClass
(
{
isModel
:
true
modelName
:
null
typeForRelationship
(
name
store
)
{
var
relationship
=
Ember
.
get
(
this
'
relationshipsByName
'
)
.
get
(
name
)
;
return
relationship
&
&
store
.
modelFor
(
relationship
.
type
)
;
}
inverseMap
:
Ember
.
computed
(
function
(
)
{
return
Object
.
create
(
null
)
;
}
)
inverseFor
(
name
store
)
{
var
inverseMap
=
Ember
.
get
(
this
'
inverseMap
'
)
;
if
(
inverseMap
[
name
]
!
=
=
undefined
)
{
return
inverseMap
[
name
]
;
}
else
{
var
relationship
=
Ember
.
get
(
this
'
relationshipsByName
'
)
.
get
(
name
)
;
if
(
!
relationship
)
{
inverseMap
[
name
]
=
null
;
return
null
;
}
var
options
=
relationship
.
options
;
if
(
options
&
&
options
.
inverse
=
=
=
null
)
{
inverseMap
[
name
]
=
null
;
return
null
;
}
return
inverseMap
[
name
]
=
this
.
_findInverseFor
(
name
store
)
;
}
}
_findInverseFor
(
name
store
)
{
var
inverseType
=
this
.
typeForRelationship
(
name
store
)
;
if
(
!
inverseType
)
{
return
null
;
}
var
propertyMeta
=
this
.
metaForProperty
(
name
)
;
var
options
=
propertyMeta
.
options
;
if
(
options
.
inverse
=
=
=
null
)
{
return
null
;
}
var
inverseName
=
void
0
inverseKind
=
void
0
inverse
=
void
0
;
if
(
options
.
inverse
)
{
inverseName
=
options
.
inverse
;
inverse
=
Ember
.
get
(
inverseType
'
relationshipsByName
'
)
.
get
(
inverseName
)
;
(
true
&
&
!
(
!
Ember
.
isNone
(
inverse
)
)
&
&
Ember
.
assert
(
"
We
found
no
inverse
relationships
by
the
name
of
'
"
+
inverseName
+
"
'
on
the
'
"
+
inverseType
.
modelName
+
"
'
model
.
This
is
most
likely
due
to
a
missing
attribute
on
your
model
definition
.
"
!
Ember
.
isNone
(
inverse
)
)
)
;
inverseKind
=
inverse
.
kind
;
}
else
{
if
(
propertyMeta
.
parentType
&
&
propertyMeta
.
type
=
=
=
propertyMeta
.
parentType
.
modelName
)
{
(
true
&
&
Ember
.
warn
(
Detected
a
reflexive
relationship
by
the
name
of
'
{
name
}
'
without
an
inverse
option
.
Look
at
https
:
/
/
guides
.
emberjs
.
com
/
current
/
models
/
relationships
/
#
toc_reflexive
-
relations
for
how
to
explicitly
specify
inverses
.
false
{
id
:
'
ds
.
model
.
reflexive
-
relationship
-
without
-
inverse
'
}
)
)
;
}
var
possibleRelationships
=
findPossibleInverses
(
this
inverseType
name
)
;
if
(
possibleRelationships
.
length
=
=
=
0
)
{
return
null
;
}
var
filteredRelationships
=
possibleRelationships
.
filter
(
possibleRelationship
=
>
{
var
optionsForRelationship
=
inverseType
.
metaForProperty
(
possibleRelationship
.
name
)
.
options
;
return
name
=
=
=
optionsForRelationship
.
inverse
;
}
)
;
(
true
&
&
!
(
filteredRelationships
.
length
<
2
)
&
&
Ember
.
assert
(
"
You
defined
the
'
"
+
name
+
"
'
relationship
on
"
+
this
+
"
but
you
defined
the
inverse
relationships
of
type
"
+
inverseType
.
toString
(
)
+
"
multiple
times
.
Look
at
https
:
/
/
guides
.
emberjs
.
com
/
current
/
models
/
relationships
/
#
toc_explicit
-
inverses
for
how
to
explicitly
specify
inverses
"
filteredRelationships
.
length
<
2
)
)
;
if
(
filteredRelationships
.
length
=
=
=
1
)
{
possibleRelationships
=
filteredRelationships
;
}
(
true
&
&
!
(
possibleRelationships
.
length
=
=
=
1
)
&
&
Ember
.
assert
(
"
You
defined
the
'
"
+
name
+
"
'
relationship
on
"
+
this
+
"
but
multiple
possible
inverse
relationships
of
type
"
+
this
+
"
were
found
on
"
+
inverseType
+
"
.
Look
at
https
:
/
/
guides
.
emberjs
.
com
/
current
/
models
/
relationships
/
#
toc_explicit
-
inverses
for
how
to
explicitly
specify
inverses
"
possibleRelationships
.
length
=
=
=
1
)
)
;
inverseName
=
possibleRelationships
[
0
]
.
name
;
inverseKind
=
possibleRelationships
[
0
]
.
kind
;
}
return
{
type
:
inverseType
name
:
inverseName
kind
:
inverseKind
}
;
}
relationships
:
relationshipsDescriptor
relationshipNames
:
Ember
.
computed
(
function
(
)
{
var
names
=
{
hasMany
:
[
]
belongsTo
:
[
]
}
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isRelationship
)
{
names
[
meta
.
kind
]
.
push
(
name
)
;
}
}
)
;
return
names
;
}
)
relatedTypes
:
relatedTypesDescriptor
relationshipsByName
:
relationshipsByNameDescriptor
fields
:
Ember
.
computed
(
function
(
)
{
var
map
=
Ember
.
Map
.
create
(
)
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isRelationship
)
{
map
.
set
(
name
meta
.
kind
)
;
}
else
if
(
meta
.
isAttribute
)
{
map
.
set
(
name
'
attribute
'
)
;
}
}
)
;
return
map
;
}
)
.
readOnly
(
)
eachRelationship
(
callback
binding
)
{
Ember
.
get
(
this
'
relationshipsByName
'
)
.
forEach
(
(
relationship
name
)
=
>
{
callback
.
call
(
binding
name
relationship
)
;
}
)
;
}
eachRelatedType
(
callback
binding
)
{
var
relationshipTypes
=
Ember
.
get
(
this
'
relatedTypes
'
)
;
for
(
var
i
=
0
;
i
<
relationshipTypes
.
length
;
i
+
+
)
{
var
type
=
relationshipTypes
[
i
]
;
callback
.
call
(
binding
type
)
;
}
}
determineRelationshipType
(
knownSide
store
)
{
var
knownKey
=
knownSide
.
key
;
var
knownKind
=
knownSide
.
kind
;
var
inverse
=
this
.
inverseFor
(
knownKey
store
)
;
var
otherKind
=
void
0
;
if
(
!
inverse
)
{
return
knownKind
=
=
=
'
belongsTo
'
?
'
oneToNone
'
:
'
manyToNone
'
;
}
otherKind
=
inverse
.
kind
;
if
(
otherKind
=
=
=
'
belongsTo
'
)
{
return
knownKind
=
=
=
'
belongsTo
'
?
'
oneToOne
'
:
'
manyToOne
'
;
}
else
{
return
knownKind
=
=
=
'
belongsTo
'
?
'
oneToMany
'
:
'
manyToMany
'
;
}
}
attributes
:
Ember
.
computed
(
function
(
)
{
var
map
=
Ember
.
Map
.
create
(
)
;
this
.
eachComputedProperty
(
(
name
meta
)
=
>
{
if
(
meta
.
isAttribute
)
{
(
true
&
&
!
(
name
!
=
=
'
id
'
)
&
&
Ember
.
assert
(
"
You
may
not
set
id
as
an
attribute
on
your
model
.
Please
remove
any
lines
that
look
like
:
id
:
DS
.
attr
(
'
<
type
>
'
)
from
"
+
this
.
toString
(
)
name
!
=
=
'
id
'
)
)
;
meta
.
name
=
name
;
map
.
set
(
name
meta
)
;
}
}
)
;
return
map
;
}
)
.
readOnly
(
)
transformedAttributes
:
Ember
.
computed
(
function
(
)
{
var
map
=
Ember
.
Map
.
create
(
)
;
this
.
eachAttribute
(
(
key
meta
)
=
>
{
if
(
meta
.
type
)
{
map
.
set
(
key
meta
.
type
)
;
}
}
)
;
return
map
;
}
)
.
readOnly
(
)
eachAttribute
(
callback
binding
)
{
Ember
.
get
(
this
'
attributes
'
)
.
forEach
(
(
meta
name
)
=
>
{
callback
.
call
(
binding
name
meta
)
;
}
)
;
}
eachTransformedAttribute
(
callback
binding
)
{
Ember
.
get
(
this
'
transformedAttributes
'
)
.
forEach
(
(
type
name
)
=
>
{
callback
.
call
(
binding
name
type
)
;
}
)
;
}
}
)
;
if
(
isEnabled
(
'
ds
-
rollback
-
attribute
'
)
)
{
Model
.
reopen
(
{
rollbackAttribute
(
attributeName
)
{
if
(
attributeName
in
this
.
_internalModel
.
_attributes
)
{
this
.
set
(
attributeName
this
.
_internalModel
.
lastAcknowledgedValue
(
attributeName
)
)
;
}
}
}
)
;
}
{
Model
.
reopen
(
{
willMergeMixin
(
props
)
{
var
constructor
=
this
.
constructor
;
(
true
&
&
!
(
!
intersection
(
Object
.
keys
(
props
)
RESERVED_MODEL_PROPS
)
[
0
]
)
&
&
Ember
.
assert
(
'
'
+
intersection
(
Object
.
keys
(
props
)
RESERVED_MODEL_PROPS
)
[
0
]
+
'
is
a
reserved
property
name
on
DS
.
Model
objects
.
Please
choose
a
different
property
name
for
'
+
constructor
.
toString
(
)
!
intersection
(
Object
.
keys
(
props
)
RESERVED_MODEL_PROPS
)
[
0
]
)
)
;
(
true
&
&
!
(
Object
.
keys
(
props
)
.
indexOf
(
'
id
'
)
=
=
=
-
1
)
&
&
Ember
.
assert
(
"
You
may
not
set
id
as
an
attribute
on
your
model
.
Please
remove
any
lines
that
look
like
:
id
:
DS
.
attr
(
'
<
type
>
'
)
from
"
+
constructor
.
toString
(
)
Object
.
keys
(
props
)
.
indexOf
(
'
id
'
)
=
=
=
-
1
)
)
;
}
didDefineProperty
(
proto
key
value
)
{
if
(
value
instanceof
Ember
.
ComputedProperty
)
{
var
meta
=
value
.
meta
(
)
;
meta
.
parentType
=
proto
.
constructor
;
}
}
}
)
;
}
var
SOURCE_POINTER_REGEXP
=
/
^
\
/
?
data
\
/
(
attributes
|
relationships
)
\
/
(
.
*
)
/
;
var
SOURCE_POINTER_PRIMARY_REGEXP
=
/
^
\
/
?
data
/
;
var
PRIMARY_ATTRIBUTE_KEY
=
'
base
'
;
function
AdapterError
(
errors
message
=
'
Adapter
operation
failed
'
)
{
this
.
isAdapterError
=
true
;
Ember
.
Error
.
call
(
this
message
)
;
this
.
errors
=
errors
|
|
[
{
title
:
'
Adapter
Error
'
detail
:
message
}
]
;
}
function
extendFn
(
ErrorClass
)
{
return
function
(
{
message
:
defaultMessage
}
=
{
}
)
{
return
extend
(
ErrorClass
defaultMessage
)
;
}
;
}
function
extend
(
ParentErrorClass
defaultMessage
)
{
var
ErrorClass
=
function
(
errors
message
)
{
(
true
&
&
!
(
Array
.
isArray
(
errors
|
|
[
]
)
)
&
&
Ember
.
assert
(
'
AdapterError
expects
json
-
api
formatted
errors
array
.
'
Array
.
isArray
(
errors
|
|
[
]
)
)
)
;
ParentErrorClass
.
call
(
this
errors
message
|
|
defaultMessage
)
;
}
;
ErrorClass
.
prototype
=
Object
.
create
(
ParentErrorClass
.
prototype
)
;
ErrorClass
.
extend
=
extendFn
(
ErrorClass
)
;
return
ErrorClass
;
}
AdapterError
.
prototype
=
Object
.
create
(
Ember
.
Error
.
prototype
)
;
AdapterError
.
extend
=
extendFn
(
AdapterError
)
;
var
InvalidError
=
extend
(
AdapterError
'
The
adapter
rejected
the
commit
because
it
was
invalid
'
)
;
var
TimeoutError
=
extend
(
AdapterError
'
The
adapter
operation
timed
out
'
)
;
var
AbortError
=
extend
(
AdapterError
'
The
adapter
operation
was
aborted
'
)
;
var
UnauthorizedError
=
extend
(
AdapterError
'
The
adapter
operation
is
unauthorized
'
)
;
var
ForbiddenError
=
extend
(
AdapterError
'
The
adapter
operation
is
forbidden
'
)
;
var
NotFoundError
=
extend
(
AdapterError
'
The
adapter
could
not
find
the
resource
'
)
;
var
ConflictError
=
extend
(
AdapterError
'
The
adapter
operation
failed
due
to
a
conflict
'
)
;
var
ServerError
=
extend
(
AdapterError
'
The
adapter
operation
failed
due
to
a
server
error
'
)
;
function
errorsHashToArray
(
errors
)
{
var
out
=
[
]
;
if
(
Ember
.
isPresent
(
errors
)
)
{
Object
.
keys
(
errors
)
.
forEach
(
key
=
>
{
var
messages
=
Ember
.
makeArray
(
errors
[
key
]
)
;
for
(
var
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
var
title
=
'
Invalid
Attribute
'
;
var
pointer
=
/
data
/
attributes
/
{
key
}
;
if
(
key
=
=
=
PRIMARY_ATTRIBUTE_KEY
)
{
title
=
'
Invalid
Document
'
;
pointer
=
/
data
;
}
out
.
push
(
{
title
:
title
detail
:
messages
[
i
]
source
:
{
pointer
:
pointer
}
}
)
;
}
}
)
;
}
return
out
;
}
function
errorsArrayToHash
(
errors
)
{
var
out
=
{
}
;
if
(
Ember
.
isPresent
(
errors
)
)
{
errors
.
forEach
(
error
=
>
{
if
(
error
.
source
&
&
error
.
source
.
pointer
)
{
var
key
=
error
.
source
.
pointer
.
match
(
SOURCE_POINTER_REGEXP
)
;
if
(
key
)
{
key
=
key
[
2
]
;
}
else
if
(
error
.
source
.
pointer
.
search
(
SOURCE_POINTER_PRIMARY_REGEXP
)
!
=
=
-
1
)
{
key
=
PRIMARY_ATTRIBUTE_KEY
;
}
if
(
key
)
{
out
[
key
]
=
out
[
key
]
|
|
[
]
;
out
[
key
]
.
push
(
error
.
detail
|
|
error
.
title
)
;
}
}
}
)
;
}
return
out
;
}
var
EmberOrderedSet
=
Ember
.
OrderedSet
;
function
OrderedSet
(
)
{
this
.
_super
constructor
(
)
;
}
OrderedSet
.
create
=
function
(
)
{
var
Constructor
=
this
;
return
new
Constructor
(
)
;
}
;
OrderedSet
.
prototype
=
Object
.
create
(
EmberOrderedSet
.
prototype
)
;
OrderedSet
.
prototype
.
constructor
=
OrderedSet
;
OrderedSet
.
prototype
.
_super
constructor
=
EmberOrderedSet
;
OrderedSet
.
prototype
.
addWithIndex
=
function
(
obj
idx
)
{
var
guid
=
Ember
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
var
list
=
this
.
list
;
if
(
presenceSet
[
guid
]
=
=
=
true
)
{
return
;
}
presenceSet
[
guid
]
=
true
;
if
(
idx
=
=
=
undefined
|
|
idx
=
=
=
null
)
{
list
.
push
(
obj
)
;
}
else
{
list
.
splice
(
idx
0
obj
)
;
}
this
.
size
+
=
1
;
return
this
;
}
;
function
_normalizeLink
(
link
)
{
switch
(
typeof
link
)
{
case
'
object
'
:
return
link
;
case
'
string
'
:
return
{
href
:
link
}
;
}
return
null
;
}
class
Relationship
{
constructor
(
store
internalModel
inverseKey
relationshipMeta
)
{
var
async
=
relationshipMeta
.
options
.
async
;
var
polymorphic
=
relationshipMeta
.
options
.
polymorphic
;
this
.
members
=
new
OrderedSet
(
)
;
this
.
canonicalMembers
=
new
OrderedSet
(
)
;
this
.
store
=
store
;
this
.
key
=
relationshipMeta
.
key
;
this
.
inverseKey
=
inverseKey
;
this
.
internalModel
=
internalModel
;
this
.
isAsync
=
typeof
async
=
=
=
'
undefined
'
?
true
:
async
;
this
.
isPolymorphic
=
typeof
polymorphic
=
=
=
'
undefined
'
?
true
:
polymorphic
;
this
.
relationshipMeta
=
relationshipMeta
;
this
.
inverseKeyForImplicit
=
this
.
internalModel
.
modelName
+
this
.
key
;
this
.
linkPromise
=
null
;
this
.
meta
=
null
;
this
.
hasData
=
false
;
this
.
hasLoaded
=
false
;
this
.
__inverseMeta
=
undefined
;
}
_inverseIsAsync
(
)
{
var
inverseMeta
=
this
.
_inverseMeta
;
if
(
!
inverseMeta
)
{
return
false
;
}
var
inverseAsync
=
inverseMeta
.
options
.
async
;
return
typeof
inverseAsync
=
=
=
'
undefined
'
?
true
:
inverseAsync
;
}
_inverseIsSync
(
)
{
var
inverseMeta
=
this
.
_inverseMeta
;
if
(
!
inverseMeta
)
{
return
false
;
}
var
inverseAsync
=
inverseMeta
.
options
.
async
;
return
typeof
inverseAsync
=
=
=
'
undefined
'
?
false
:
!
inverseAsync
;
}
get
_inverseMeta
(
)
{
if
(
this
.
__inverseMeta
=
=
=
undefined
)
{
var
inverseMeta
=
null
;
if
(
this
.
inverseKey
)
{
var
inverseModelClass
=
this
.
store
.
modelFor
(
this
.
relationshipMeta
.
type
)
;
var
inverseRelationships
=
Ember
.
get
(
inverseModelClass
'
relationshipsByName
'
)
;
inverseMeta
=
inverseRelationships
.
get
(
this
.
inverseKey
)
;
}
this
.
__inverseMeta
=
inverseMeta
;
}
return
this
.
__inverseMeta
;
}
get
parentType
(
)
{
return
this
.
internalModel
.
modelName
;
}
internalModelDidDematerialize
(
)
{
if
(
!
this
.
inverseKey
)
{
return
;
}
this
.
forAllMembers
(
inverseInternalModel
=
>
{
var
relationship
=
inverseInternalModel
.
_relationships
.
get
(
this
.
inverseKey
)
;
relationship
.
inverseDidDematerialize
(
this
.
internalModel
)
;
}
)
;
}
inverseDidDematerialize
(
inverseInternalModel
)
{
if
(
!
this
.
isAsync
)
{
this
.
removeInternalModelFromOwn
(
inverseInternalModel
)
;
this
.
removeCanonicalInternalModelFromOwn
(
inverseInternalModel
)
;
}
}
updateMeta
(
meta
)
{
this
.
meta
=
meta
;
}
clear
(
)
{
var
members
=
this
.
members
.
list
;
while
(
members
.
length
>
0
)
{
var
member
=
members
[
0
]
;
this
.
removeInternalModel
(
member
)
;
}
var
canonicalMembers
=
this
.
canonicalMembers
.
list
;
while
(
canonicalMembers
.
length
>
0
)
{
var
_member
=
canonicalMembers
[
0
]
;
this
.
removeCanonicalInternalModel
(
_member
)
;
}
}
removeAllInternalModelsFromOwn
(
)
{
this
.
members
.
clear
(
)
;
this
.
internalModel
.
updateRecordArrays
(
)
;
}
removeAllCanonicalInternalModelsFromOwn
(
)
{
this
.
canonicalMembers
.
clear
(
)
;
this
.
flushCanonicalLater
(
)
;
}
removeInternalModels
(
internalModels
)
{
internalModels
.
forEach
(
internalModel
=
>
this
.
removeInternalModel
(
internalModel
)
)
;
}
addInternalModels
(
internalModels
idx
)
{
internalModels
.
forEach
(
internalModel
=
>
{
this
.
addInternalModel
(
internalModel
idx
)
;
if
(
idx
!
=
=
undefined
)
{
idx
+
+
;
}
}
)
;
}
addCanonicalInternalModels
(
internalModels
idx
)
{
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
if
(
idx
!
=
=
undefined
)
{
this
.
addCanonicalInternalModel
(
internalModels
[
i
]
i
+
idx
)
;
}
else
{
this
.
addCanonicalInternalModel
(
internalModels
[
i
]
)
;
}
}
}
addCanonicalInternalModel
(
internalModel
idx
)
{
if
(
!
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
this
.
canonicalMembers
.
add
(
internalModel
)
;
this
.
setupInverseRelationship
(
internalModel
)
;
}
this
.
flushCanonicalLater
(
)
;
this
.
setHasData
(
true
)
;
}
setupInverseRelationship
(
internalModel
)
{
if
(
this
.
inverseKey
)
{
var
relationships
=
internalModel
.
_relationships
;
var
relationshipExisted
=
relationships
.
has
(
this
.
inverseKey
)
;
var
relationship
=
relationships
.
get
(
this
.
inverseKey
)
;
if
(
relationshipExisted
|
|
this
.
isPolymorphic
)
{
relationship
.
addCanonicalInternalModel
(
this
.
internalModel
)
;
}
}
else
{
var
_relationships
=
internalModel
.
_implicitRelationships
;
var
_relationship
=
_relationships
[
this
.
inverseKeyForImplicit
]
;
if
(
!
_relationship
)
{
_relationship
=
_relationships
[
this
.
inverseKeyForImplicit
]
=
new
Relationship
(
this
.
store
internalModel
this
.
key
{
options
:
{
async
:
this
.
isAsync
}
type
:
this
.
parentType
}
)
;
}
_relationship
.
addCanonicalInternalModel
(
this
.
internalModel
)
;
}
}
removeCanonicalInternalModels
(
internalModels
idx
)
{
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
if
(
idx
!
=
=
undefined
)
{
this
.
removeCanonicalInternalModel
(
internalModels
[
i
]
i
+
idx
)
;
}
else
{
this
.
removeCanonicalInternalModel
(
internalModels
[
i
]
)
;
}
}
}
removeCanonicalInternalModel
(
internalModel
idx
)
{
if
(
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
this
.
removeCanonicalInternalModelFromOwn
(
internalModel
)
;
if
(
this
.
inverseKey
)
{
this
.
removeCanonicalInternalModelFromInverse
(
internalModel
)
;
}
else
{
if
(
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
)
{
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
.
removeCanonicalInternalModel
(
this
.
internalModel
)
;
}
}
}
this
.
flushCanonicalLater
(
)
;
}
addInternalModel
(
internalModel
idx
)
{
if
(
!
this
.
members
.
has
(
internalModel
)
)
{
this
.
members
.
addWithIndex
(
internalModel
idx
)
;
this
.
notifyRecordRelationshipAdded
(
internalModel
idx
)
;
if
(
this
.
inverseKey
)
{
internalModel
.
_relationships
.
get
(
this
.
inverseKey
)
.
addInternalModel
(
this
.
internalModel
)
;
}
else
{
if
(
!
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
)
{
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
=
new
Relationship
(
this
.
store
internalModel
this
.
key
{
options
:
{
async
:
this
.
isAsync
}
type
:
this
.
parentType
}
)
;
}
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
.
addInternalModel
(
this
.
internalModel
)
;
}
this
.
internalModel
.
updateRecordArrays
(
)
;
}
this
.
setHasData
(
true
)
;
}
removeInternalModel
(
internalModel
)
{
if
(
this
.
members
.
has
(
internalModel
)
)
{
this
.
removeInternalModelFromOwn
(
internalModel
)
;
if
(
this
.
inverseKey
)
{
this
.
removeInternalModelFromInverse
(
internalModel
)
;
}
else
{
if
(
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
)
{
internalModel
.
_implicitRelationships
[
this
.
inverseKeyForImplicit
]
.
removeInternalModel
(
this
.
internalModel
)
;
}
}
}
}
removeInternalModelFromInverse
(
internalModel
)
{
var
inverseRelationship
=
internalModel
.
_relationships
.
get
(
this
.
inverseKey
)
;
if
(
inverseRelationship
)
{
inverseRelationship
.
removeInternalModelFromOwn
(
this
.
internalModel
)
;
}
}
removeInternalModelFromOwn
(
internalModel
)
{
this
.
members
.
delete
(
internalModel
)
;
this
.
internalModel
.
updateRecordArrays
(
)
;
}
removeCanonicalInternalModelFromInverse
(
internalModel
)
{
var
inverseRelationship
=
internalModel
.
_relationships
.
get
(
this
.
inverseKey
)
;
if
(
inverseRelationship
)
{
inverseRelationship
.
removeCanonicalInternalModelFromOwn
(
this
.
internalModel
)
;
}
}
removeCanonicalInternalModelFromOwn
(
internalModel
)
{
this
.
canonicalMembers
.
delete
(
internalModel
)
;
this
.
flushCanonicalLater
(
)
;
}
removeCompletelyFromInverse
(
)
{
if
(
!
this
.
inverseKey
)
{
return
;
}
var
seen
=
Object
.
create
(
null
)
;
var
internalModel
=
this
.
internalModel
;
var
unload
=
inverseInternalModel
=
>
{
var
id
=
Ember
.
guidFor
(
inverseInternalModel
)
;
if
(
seen
[
id
]
=
=
=
undefined
)
{
var
relationship
=
inverseInternalModel
.
_relationships
.
get
(
this
.
inverseKey
)
;
relationship
.
removeCompletelyFromOwn
(
internalModel
)
;
seen
[
id
]
=
true
;
}
}
;
this
.
members
.
forEach
(
unload
)
;
this
.
canonicalMembers
.
forEach
(
unload
)
;
if
(
!
this
.
isAsync
)
{
this
.
clear
(
)
;
}
}
forAllMembers
(
callback
)
{
var
seen
=
Object
.
create
(
null
)
;
for
(
var
i
=
0
;
i
<
this
.
members
.
list
.
length
;
i
+
+
)
{
var
inverseInternalModel
=
this
.
members
.
list
[
i
]
;
var
id
=
Ember
.
guidFor
(
inverseInternalModel
)
;
if
(
!
seen
[
id
]
)
{
seen
[
id
]
=
true
;
callback
(
inverseInternalModel
)
;
}
}
for
(
var
_i
=
0
;
_i
<
this
.
canonicalMembers
.
list
.
length
;
_i
+
+
)
{
var
_inverseInternalModel
=
this
.
canonicalMembers
.
list
[
_i
]
;
var
_id
=
Ember
.
guidFor
(
_inverseInternalModel
)
;
if
(
!
seen
[
_id
]
)
{
seen
[
_id
]
=
true
;
callback
(
_inverseInternalModel
)
;
}
}
}
removeCompletelyFromOwn
(
internalModel
)
{
this
.
canonicalMembers
.
delete
(
internalModel
)
;
this
.
members
.
delete
(
internalModel
)
;
this
.
internalModel
.
updateRecordArrays
(
)
;
}
flushCanonical
(
)
{
var
list
=
this
.
members
.
list
;
this
.
willSync
=
false
;
var
newInternalModels
=
[
]
;
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
if
(
list
[
i
]
.
isNew
(
)
)
{
newInternalModels
.
push
(
list
[
i
]
)
;
}
}
this
.
members
=
this
.
canonicalMembers
.
copy
(
)
;
for
(
var
_i2
=
0
;
_i2
<
newInternalModels
.
length
;
_i2
+
+
)
{
this
.
members
.
add
(
newInternalModels
[
_i2
]
)
;
}
}
flushCanonicalLater
(
)
{
if
(
this
.
willSync
)
{
return
;
}
this
.
willSync
=
true
;
this
.
store
.
_updateRelationshipState
(
this
)
;
}
updateLink
(
link
initial
)
{
(
true
&
&
Ember
.
warn
(
You
pushed
a
record
of
type
'
{
this
.
internalModel
.
modelName
}
'
with
a
relationship
'
{
this
.
key
}
'
configured
as
'
async
:
false
'
.
You
'
ve
included
a
link
but
no
primary
data
this
may
be
an
error
in
your
payload
.
this
.
isAsync
|
|
this
.
hasData
{
id
:
'
ds
.
store
.
push
-
link
-
for
-
sync
-
relationship
'
}
)
)
;
(
true
&
&
!
(
typeof
link
=
=
=
'
string
'
|
|
link
=
=
=
null
)
&
&
Ember
.
assert
(
You
have
pushed
a
record
of
type
'
{
this
.
internalModel
.
modelName
}
'
with
'
{
this
.
key
}
'
as
a
link
but
the
value
of
that
link
is
not
a
string
.
typeof
link
=
=
=
'
string
'
|
|
link
=
=
=
null
)
)
;
this
.
link
=
link
;
this
.
linkPromise
=
null
;
if
(
!
initial
)
{
this
.
internalModel
.
notifyPropertyChange
(
this
.
key
)
;
}
}
findLink
(
)
{
if
(
this
.
linkPromise
)
{
return
this
.
linkPromise
;
}
else
{
var
promise
=
this
.
fetchLink
(
)
;
this
.
linkPromise
=
promise
;
return
promise
.
then
(
result
=
>
result
)
;
}
}
updateInternalModelsFromAdapter
(
internalModels
)
{
this
.
setHasData
(
true
)
;
this
.
computeChanges
(
internalModels
)
;
}
notifyRecordRelationshipAdded
(
)
{
}
setHasData
(
value
)
{
this
.
hasData
=
value
;
}
setHasLoaded
(
value
)
{
this
.
hasLoaded
=
value
;
}
push
(
payload
initial
)
{
var
hasData
=
false
;
var
hasLink
=
false
;
if
(
payload
.
meta
)
{
this
.
updateMeta
(
payload
.
meta
)
;
}
if
(
payload
.
data
!
=
=
undefined
)
{
hasData
=
true
;
this
.
updateData
(
payload
.
data
initial
)
;
}
if
(
payload
.
links
&
&
payload
.
links
.
related
)
{
var
relatedLink
=
_normalizeLink
(
payload
.
links
.
related
)
;
if
(
relatedLink
&
&
relatedLink
.
href
&
&
relatedLink
.
href
!
=
=
this
.
link
)
{
hasLink
=
true
;
this
.
updateLink
(
relatedLink
.
href
initial
)
;
}
}
if
(
hasData
)
{
this
.
setHasData
(
true
)
;
this
.
setHasLoaded
(
true
)
;
}
else
if
(
hasLink
)
{
this
.
setHasLoaded
(
false
)
;
}
}
updateData
(
)
{
}
destroy
(
)
{
}
}
function
_bind
(
fn
.
.
.
args
)
{
return
function
(
)
{
return
fn
.
apply
(
undefined
args
)
;
}
;
}
function
_guard
(
promise
test
)
{
var
guarded
=
promise
[
'
finally
'
]
(
function
(
)
{
if
(
!
test
(
)
)
{
guarded
.
_subscribers
.
length
=
0
;
}
}
)
;
return
guarded
;
}
function
_objectIsAlive
(
object
)
{
return
!
(
Ember
.
get
(
object
"
isDestroyed
"
)
|
|
Ember
.
get
(
object
"
isDestroying
"
)
)
;
}
function
diffArray
(
oldArray
newArray
)
{
var
oldLength
=
oldArray
.
length
;
var
newLength
=
newArray
.
length
;
var
shortestLength
=
Math
.
min
(
oldLength
newLength
)
;
var
firstChangeIndex
=
null
;
for
(
var
i
=
0
;
i
<
shortestLength
;
i
+
+
)
{
if
(
oldArray
[
i
]
!
=
=
newArray
[
i
]
)
{
firstChangeIndex
=
i
;
break
;
}
}
if
(
firstChangeIndex
=
=
=
null
&
&
newLength
!
=
=
oldLength
)
{
firstChangeIndex
=
shortestLength
;
}
var
addedCount
=
0
;
var
removedCount
=
0
;
if
(
firstChangeIndex
!
=
=
null
)
{
var
unchangedEndBlockLength
=
shortestLength
-
firstChangeIndex
;
for
(
var
_i
=
1
;
_i
<
=
shortestLength
;
_i
+
+
)
{
if
(
oldArray
[
oldLength
-
_i
]
!
=
=
newArray
[
newLength
-
_i
]
)
{
unchangedEndBlockLength
=
_i
-
1
;
break
;
}
}
addedCount
=
newLength
-
unchangedEndBlockLength
-
firstChangeIndex
;
removedCount
=
oldLength
-
unchangedEndBlockLength
-
firstChangeIndex
;
}
return
{
firstChangeIndex
addedCount
removedCount
}
;
}
var
ManyArray
=
Ember
.
Object
.
extend
(
Ember
.
MutableArray
Ember
.
Evented
{
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
this
.
isLoaded
=
false
;
this
.
length
=
0
;
this
.
promise
=
null
;
this
.
meta
=
this
.
meta
|
|
null
;
this
.
isPolymorphic
=
this
.
isPolymorphic
|
|
false
;
this
.
relationship
=
this
.
relationship
|
|
null
;
this
.
currentState
=
[
]
;
this
.
flushCanonical
(
false
)
;
}
objectAt
(
index
)
{
var
internalModel
=
this
.
currentState
[
index
]
;
if
(
internalModel
=
=
=
undefined
)
{
return
;
}
return
internalModel
.
getRecord
(
)
;
}
flushCanonical
(
isInitialized
=
true
)
{
if
(
!
_objectIsAlive
(
this
)
)
{
return
;
}
var
toSet
=
this
.
canonicalState
;
var
newInternalModels
=
this
.
currentState
.
filter
(
internalModel
=
>
internalModel
.
isNew
(
)
&
&
toSet
.
indexOf
(
internalModel
)
=
=
=
-
1
)
;
toSet
=
toSet
.
concat
(
newInternalModels
)
;
var
diff
=
diffArray
(
this
.
currentState
toSet
)
;
if
(
diff
.
firstChangeIndex
!
=
=
null
)
{
this
.
arrayContentWillChange
(
diff
.
firstChangeIndex
diff
.
removedCount
diff
.
addedCount
)
;
this
.
set
(
'
length
'
toSet
.
length
)
;
this
.
currentState
=
toSet
;
this
.
arrayContentDidChange
(
diff
.
firstChangeIndex
diff
.
removedCount
diff
.
addedCount
)
;
if
(
isInitialized
&
&
diff
.
addedCount
>
0
)
{
this
.
relationship
.
notifyHasManyChanged
(
)
;
}
}
}
internalReplace
(
idx
amt
objects
)
{
if
(
!
objects
)
{
objects
=
[
]
;
}
this
.
arrayContentWillChange
(
idx
amt
objects
.
length
)
;
this
.
currentState
.
splice
.
apply
(
this
.
currentState
[
idx
amt
]
.
concat
(
objects
)
)
;
this
.
set
(
'
length
'
this
.
currentState
.
length
)
;
this
.
arrayContentDidChange
(
idx
amt
objects
.
length
)
;
}
_removeInternalModels
(
internalModels
)
{
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
index
=
this
.
currentState
.
indexOf
(
internalModels
[
i
]
)
;
this
.
internalReplace
(
index
1
)
;
}
}
_addInternalModels
(
internalModels
idx
)
{
if
(
idx
=
=
=
undefined
)
{
idx
=
this
.
currentState
.
length
;
}
this
.
internalReplace
(
idx
0
internalModels
)
;
}
replace
(
idx
amt
objects
)
{
var
internalModels
=
void
0
;
if
(
amt
>
0
)
{
internalModels
=
this
.
currentState
.
slice
(
idx
idx
+
amt
)
;
this
.
get
(
'
relationship
'
)
.
removeInternalModels
(
internalModels
)
;
}
if
(
objects
)
{
this
.
get
(
'
relationship
'
)
.
addInternalModels
(
objects
.
map
(
obj
=
>
obj
.
_internalModel
)
idx
)
;
}
}
reload
(
)
{
return
this
.
relationship
.
reload
(
)
;
}
save
(
)
{
var
manyArray
=
this
;
var
promiseLabel
=
'
DS
:
ManyArray
#
save
'
+
Ember
.
get
(
this
'
type
'
)
;
var
promise
=
Ember
.
RSVP
.
all
(
this
.
invoke
(
"
save
"
)
promiseLabel
)
.
then
(
(
)
=
>
manyArray
null
'
DS
:
ManyArray
#
save
return
ManyArray
'
)
;
return
PromiseArray
.
create
(
{
promise
}
)
;
}
createRecord
(
hash
)
{
var
store
=
Ember
.
get
(
this
'
store
'
)
;
var
type
=
Ember
.
get
(
this
'
type
'
)
;
(
true
&
&
!
(
!
Ember
.
get
(
this
'
isPolymorphic
'
)
)
&
&
Ember
.
assert
(
You
cannot
add
'
{
type
.
modelName
}
'
records
to
this
polymorphic
relationship
.
!
Ember
.
get
(
this
'
isPolymorphic
'
)
)
)
;
var
record
=
store
.
createRecord
(
type
.
modelName
hash
)
;
this
.
pushObject
(
record
)
;
return
record
;
}
}
)
;
class
ManyRelationship
extends
Relationship
{
constructor
(
store
internalModel
inverseKey
relationshipMeta
)
{
super
(
store
internalModel
inverseKey
relationshipMeta
)
;
this
.
belongsToType
=
relationshipMeta
.
type
;
this
.
canonicalState
=
[
]
;
this
.
isPolymorphic
=
relationshipMeta
.
options
.
polymorphic
;
this
.
_manyArray
=
null
;
this
.
_retainedManyArray
=
null
;
this
.
__loadingPromise
=
null
;
}
get
_loadingPromise
(
)
{
return
this
.
__loadingPromise
;
}
_updateLoadingPromise
(
promise
content
)
{
if
(
this
.
__loadingPromise
)
{
if
(
content
)
{
this
.
__loadingPromise
.
set
(
'
content
'
content
)
;
}
this
.
__loadingPromise
.
set
(
'
promise
'
promise
)
;
}
else
{
this
.
__loadingPromise
=
PromiseManyArray
.
create
(
{
promise
content
}
)
;
}
return
this
.
__loadingPromise
;
}
get
manyArray
(
)
{
(
true
&
&
!
(
this
.
_manyArray
=
=
=
null
|
|
this
.
_retainedManyArray
=
=
=
null
)
&
&
Ember
.
assert
(
Error
:
relationship
{
this
.
parentType
}
:
{
this
.
key
}
has
both
many
array
and
retained
many
array
this
.
_manyArray
=
=
=
null
|
|
this
.
_retainedManyArray
=
=
=
null
)
)
;
if
(
!
this
.
_manyArray
)
{
this
.
_manyArray
=
ManyArray
.
create
(
{
canonicalState
:
this
.
canonicalState
store
:
this
.
store
relationship
:
this
type
:
this
.
store
.
modelFor
(
this
.
belongsToType
)
record
:
this
.
internalModel
meta
:
this
.
meta
isPolymorphic
:
this
.
isPolymorphic
}
)
;
if
(
this
.
_retainedManyArray
!
=
=
null
)
{
this
.
_retainedManyArray
.
destroy
(
)
;
this
.
_retainedManyArray
=
null
;
}
}
return
this
.
_manyArray
;
}
removeInverseRelationships
(
)
{
super
.
removeInverseRelationships
(
)
;
if
(
this
.
_manyArray
)
{
this
.
_manyArray
.
destroy
(
)
;
this
.
_manyArray
=
null
;
}
if
(
this
.
_loadingPromise
)
{
this
.
_loadingPromise
.
destroy
(
)
;
}
}
updateMeta
(
meta
)
{
super
.
updateMeta
(
meta
)
;
if
(
this
.
_manyArray
)
{
this
.
_manyArray
.
set
(
'
meta
'
meta
)
;
}
}
addCanonicalInternalModel
(
internalModel
idx
)
{
if
(
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
return
;
}
if
(
idx
!
=
=
undefined
)
{
this
.
canonicalState
.
splice
(
idx
0
internalModel
)
;
}
else
{
this
.
canonicalState
.
push
(
internalModel
)
;
}
super
.
addCanonicalInternalModel
(
internalModel
idx
)
;
}
inverseDidDematerialize
(
inverseInternalModel
)
{
super
.
inverseDidDematerialize
(
inverseInternalModel
)
;
if
(
this
.
isAsync
)
{
if
(
this
.
_manyArray
)
{
this
.
_retainedManyArray
=
this
.
_manyArray
;
this
.
_manyArray
=
null
;
}
this
.
_removeInternalModelFromManyArray
(
this
.
_retainedManyArray
inverseInternalModel
)
;
}
this
.
notifyHasManyChanged
(
)
;
}
addInternalModel
(
internalModel
idx
)
{
if
(
this
.
members
.
has
(
internalModel
)
)
{
return
;
}
emberData_Debug
.
assertPolymorphicType
(
this
.
internalModel
this
.
relationshipMeta
internalModel
)
;
super
.
addInternalModel
(
internalModel
idx
)
;
this
.
manyArray
.
_addInternalModels
(
[
internalModel
]
idx
)
;
}
removeCanonicalInternalModelFromOwn
(
internalModel
idx
)
{
var
i
=
idx
;
if
(
!
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
return
;
}
if
(
i
=
=
=
undefined
)
{
i
=
this
.
canonicalState
.
indexOf
(
internalModel
)
;
}
if
(
i
>
-
1
)
{
this
.
canonicalState
.
splice
(
i
1
)
;
}
super
.
removeCanonicalInternalModelFromOwn
(
internalModel
idx
)
;
}
removeAllCanonicalInternalModelsFromOwn
(
)
{
super
.
removeAllCanonicalInternalModelsFromOwn
(
)
;
this
.
canonicalMembers
.
clear
(
)
;
this
.
canonicalState
.
splice
(
0
this
.
canonicalState
.
length
)
;
}
removeCompletelyFromOwn
(
internalModel
)
{
super
.
removeCompletelyFromOwn
(
internalModel
)
;
var
canonicalIndex
=
this
.
canonicalState
.
indexOf
(
internalModel
)
;
if
(
canonicalIndex
!
=
=
-
1
)
{
this
.
canonicalState
.
splice
(
canonicalIndex
1
)
;
}
var
manyArray
=
this
.
_manyArray
;
if
(
manyArray
)
{
var
idx
=
manyArray
.
currentState
.
indexOf
(
internalModel
)
;
if
(
idx
!
=
=
-
1
)
{
manyArray
.
internalReplace
(
idx
1
)
;
}
}
}
flushCanonical
(
)
{
if
(
this
.
_manyArray
)
{
this
.
_manyArray
.
flushCanonical
(
)
;
}
super
.
flushCanonical
(
)
;
}
removeInternalModelFromOwn
(
internalModel
idx
)
{
if
(
!
this
.
members
.
has
(
internalModel
)
)
{
return
;
}
super
.
removeInternalModelFromOwn
(
internalModel
idx
)
;
this
.
_removeInternalModelFromManyArray
(
this
.
manyArray
internalModel
idx
)
;
this
.
_removeInternalModelFromManyArray
(
this
.
_retainedManyArray
internalModel
idx
)
;
}
removeAllInternalModelsFromOwn
(
)
{
super
.
removeAllInternalModelsFromOwn
(
)
;
this
.
manyArray
.
clear
(
)
;
if
(
this
.
_retainedManyArray
)
{
this
.
_retainedManyArray
.
clear
(
)
;
}
}
_removeInternalModelFromManyArray
(
manyArray
internalModel
idx
)
{
if
(
manyArray
=
=
=
null
)
{
return
;
}
if
(
idx
!
=
=
undefined
)
{
manyArray
.
currentState
.
removeAt
(
idx
)
;
}
else
{
manyArray
.
_removeInternalModels
(
[
internalModel
]
)
;
}
}
notifyRecordRelationshipAdded
(
internalModel
idx
)
{
this
.
internalModel
.
notifyHasManyAdded
(
this
.
key
internalModel
idx
)
;
}
reload
(
)
{
var
manyArray
=
this
.
manyArray
;
var
manyArrayLoadedState
=
manyArray
.
get
(
'
isLoaded
'
)
;
if
(
this
.
_loadingPromise
)
{
if
(
this
.
_loadingPromise
.
get
(
'
isPending
'
)
)
{
return
this
.
_loadingPromise
;
}
if
(
this
.
_loadingPromise
.
get
(
'
isRejected
'
)
)
{
manyArray
.
set
(
'
isLoaded
'
manyArrayLoadedState
)
;
}
}
var
promise
=
void
0
;
if
(
this
.
link
)
{
promise
=
this
.
fetchLink
(
)
;
}
else
{
promise
=
this
.
store
.
_scheduleFetchMany
(
manyArray
.
currentState
)
.
then
(
(
)
=
>
manyArray
)
;
}
this
.
_updateLoadingPromise
(
promise
)
;
return
this
.
_loadingPromise
;
}
computeChanges
(
internalModels
=
[
]
)
{
var
members
=
this
.
canonicalMembers
;
var
internalModelsToRemove
=
[
]
;
var
internalModelSet
=
setForArray
(
internalModels
)
;
members
.
forEach
(
member
=
>
{
if
(
internalModelSet
.
has
(
member
)
)
{
return
;
}
internalModelsToRemove
.
push
(
member
)
;
}
)
;
this
.
removeCanonicalInternalModels
(
internalModelsToRemove
)
;
for
(
var
i
=
0
l
=
internalModels
.
length
;
i
<
l
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
this
.
removeCanonicalInternalModel
(
internalModel
)
;
this
.
addCanonicalInternalModel
(
internalModel
i
)
;
}
}
setInitialInternalModels
(
internalModels
)
{
if
(
Array
.
isArray
(
internalModels
)
=
=
=
false
|
|
internalModels
.
length
=
=
=
0
)
{
return
;
}
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
if
(
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
continue
;
}
this
.
canonicalMembers
.
add
(
internalModel
)
;
this
.
members
.
add
(
internalModel
)
;
this
.
setupInverseRelationship
(
internalModel
)
;
}
this
.
canonicalState
=
this
.
canonicalMembers
.
toArray
(
)
;
}
fetchLink
(
)
{
return
this
.
store
.
findHasMany
(
this
.
internalModel
this
.
link
this
.
relationshipMeta
)
.
then
(
records
=
>
{
if
(
records
.
hasOwnProperty
(
'
meta
'
)
)
{
this
.
updateMeta
(
records
.
meta
)
;
}
this
.
store
.
_backburner
.
join
(
(
)
=
>
{
this
.
updateInternalModelsFromAdapter
(
records
)
;
this
.
manyArray
.
set
(
'
isLoaded
'
true
)
;
this
.
setHasData
(
true
)
;
}
)
;
return
this
.
manyArray
;
}
)
;
}
findRecords
(
)
{
var
manyArray
=
this
.
manyArray
;
var
internalModels
=
manyArray
.
currentState
;
return
this
.
store
.
findMany
(
internalModels
)
.
then
(
(
)
=
>
{
if
(
!
manyArray
.
get
(
'
isDestroyed
'
)
)
{
manyArray
.
set
(
'
isLoaded
'
true
)
;
}
return
manyArray
;
}
)
;
}
notifyHasManyChanged
(
)
{
this
.
internalModel
.
notifyHasManyAdded
(
this
.
key
)
;
}
getRecords
(
)
{
var
manyArray
=
this
.
manyArray
;
if
(
this
.
isAsync
)
{
var
promise
=
void
0
;
if
(
this
.
link
)
{
if
(
this
.
hasLoaded
)
{
promise
=
this
.
findRecords
(
)
;
}
else
{
promise
=
this
.
findLink
(
)
.
then
(
(
)
=
>
this
.
findRecords
(
)
)
;
}
}
else
{
promise
=
this
.
findRecords
(
)
;
}
return
this
.
_updateLoadingPromise
(
promise
manyArray
)
;
}
else
{
(
true
&
&
!
(
manyArray
.
isEvery
(
'
isEmpty
'
false
)
)
&
&
Ember
.
assert
(
You
looked
up
the
'
{
this
.
key
}
'
relationship
on
a
'
{
this
.
internalModel
.
type
.
modelName
}
'
with
id
{
this
.
internalModel
.
id
}
but
some
of
the
associated
records
were
not
loaded
.
Either
make
sure
they
are
all
loaded
together
with
the
parent
record
or
specify
that
the
relationship
is
async
(
'
DS
.
hasMany
(
{
async
:
true
}
)
'
)
manyArray
.
isEvery
(
'
isEmpty
'
false
)
)
)
;
if
(
!
manyArray
.
get
(
'
isDestroyed
'
)
)
{
manyArray
.
set
(
'
isLoaded
'
true
)
;
}
return
manyArray
;
}
}
updateData
(
data
initial
)
{
var
internalModels
=
this
.
store
.
_pushResourceIdentifiers
(
this
data
)
;
if
(
initial
)
{
this
.
setInitialInternalModels
(
internalModels
)
;
}
else
{
this
.
updateInternalModelsFromAdapter
(
internalModels
)
;
}
}
destroy
(
)
{
super
.
destroy
(
)
;
var
manyArray
=
this
.
_manyArray
;
if
(
manyArray
)
{
manyArray
.
destroy
(
)
;
this
.
_manyArray
=
null
;
}
var
proxy
=
this
.
__loadingPromise
;
if
(
proxy
)
{
proxy
.
destroy
(
)
;
this
.
__loadingPromise
=
null
;
}
}
}
function
setForArray
(
array
)
{
var
set
=
new
OrderedSet
(
)
;
if
(
array
)
{
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
set
.
add
(
array
[
i
]
)
;
}
}
return
set
;
}
class
BelongsToRelationship
extends
Relationship
{
constructor
(
store
internalModel
inverseKey
relationshipMeta
)
{
super
(
store
internalModel
inverseKey
relationshipMeta
)
;
this
.
internalModel
=
internalModel
;
this
.
key
=
relationshipMeta
.
key
;
this
.
inverseInternalModel
=
null
;
this
.
canonicalState
=
null
;
}
setInternalModel
(
internalModel
)
{
if
(
internalModel
)
{
this
.
addInternalModel
(
internalModel
)
;
}
else
if
(
this
.
inverseInternalModel
)
{
this
.
removeInternalModel
(
this
.
inverseInternalModel
)
;
}
this
.
setHasData
(
true
)
;
this
.
setHasLoaded
(
true
)
;
}
setCanonicalInternalModel
(
internalModel
)
{
if
(
internalModel
)
{
this
.
addCanonicalInternalModel
(
internalModel
)
;
}
else
if
(
this
.
canonicalState
)
{
this
.
removeCanonicalInternalModel
(
this
.
canonicalState
)
;
}
this
.
flushCanonicalLater
(
)
;
}
setInitialCanonicalInternalModel
(
internalModel
)
{
if
(
!
internalModel
)
{
return
;
}
this
.
canonicalMembers
.
add
(
internalModel
)
;
this
.
members
.
add
(
internalModel
)
;
this
.
inverseInternalModel
=
this
.
canonicalState
=
internalModel
;
this
.
setupInverseRelationship
(
internalModel
)
;
}
addCanonicalInternalModel
(
internalModel
)
{
if
(
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
return
;
}
if
(
this
.
canonicalState
)
{
this
.
removeCanonicalInternalModel
(
this
.
canonicalState
)
;
}
this
.
canonicalState
=
internalModel
;
super
.
addCanonicalInternalModel
(
internalModel
)
;
}
inverseDidDematerialize
(
)
{
super
.
inverseDidDematerialize
(
this
.
inverseInternalModel
)
;
this
.
notifyBelongsToChanged
(
)
;
}
removeCompletelyFromOwn
(
internalModel
)
{
super
.
removeCompletelyFromOwn
(
internalModel
)
;
if
(
this
.
canonicalState
=
=
=
internalModel
)
{
this
.
canonicalState
=
null
;
}
if
(
this
.
inverseInternalModel
=
=
=
internalModel
)
{
this
.
inverseInternalModel
=
null
;
this
.
notifyBelongsToChanged
(
)
;
}
}
removeCompletelyFromInverse
(
)
{
super
.
removeCompletelyFromInverse
(
)
;
this
.
inverseInternalModel
=
null
;
}
flushCanonical
(
)
{
if
(
this
.
inverseInternalModel
&
&
this
.
inverseInternalModel
.
isNew
(
)
&
&
!
this
.
canonicalState
)
{
return
;
}
if
(
this
.
inverseInternalModel
!
=
=
this
.
canonicalState
)
{
this
.
inverseInternalModel
=
this
.
canonicalState
;
this
.
notifyBelongsToChanged
(
)
;
}
super
.
flushCanonical
(
)
;
}
addInternalModel
(
internalModel
)
{
if
(
this
.
members
.
has
(
internalModel
)
)
{
return
;
}
emberData_Debug
.
assertPolymorphicType
(
this
.
internalModel
this
.
relationshipMeta
internalModel
)
;
if
(
this
.
inverseInternalModel
)
{
this
.
removeInternalModel
(
this
.
inverseInternalModel
)
;
}
this
.
inverseInternalModel
=
internalModel
;
super
.
addInternalModel
(
internalModel
)
;
this
.
notifyBelongsToChanged
(
)
;
}
setRecordPromise
(
newPromise
)
{
var
content
=
newPromise
.
get
&
&
newPromise
.
get
(
'
content
'
)
;
(
true
&
&
!
(
content
!
=
=
undefined
)
&
&
Ember
.
assert
(
"
You
passed
in
a
promise
that
did
not
originate
from
an
EmberData
relationship
.
You
can
only
pass
promises
that
come
from
a
belongsTo
or
hasMany
relationship
to
the
get
call
.
"
content
!
=
=
undefined
)
)
;
this
.
setInternalModel
(
content
?
content
.
_internalModel
:
content
)
;
}
removeInternalModelFromOwn
(
internalModel
)
{
if
(
!
this
.
members
.
has
(
internalModel
)
)
{
return
;
}
this
.
inverseInternalModel
=
null
;
super
.
removeInternalModelFromOwn
(
internalModel
)
;
this
.
notifyBelongsToChanged
(
)
;
}
removeAllInternalModelsFromOwn
(
)
{
super
.
removeAllInternalModelsFromOwn
(
)
;
this
.
inverseInternalModel
=
null
;
this
.
notifyBelongsToChanged
(
)
;
}
notifyBelongsToChanged
(
)
{
this
.
internalModel
.
notifyBelongsToChanged
(
this
.
key
)
;
}
removeCanonicalInternalModelFromOwn
(
internalModel
)
{
if
(
!
this
.
canonicalMembers
.
has
(
internalModel
)
)
{
return
;
}
this
.
canonicalState
=
null
;
super
.
removeCanonicalInternalModelFromOwn
(
internalModel
)
;
}
removeAllCanonicalInternalModelsFromOwn
(
)
{
super
.
removeAllCanonicalInternalModelsFromOwn
(
)
;
this
.
canonicalState
=
null
;
}
findRecord
(
)
{
if
(
this
.
inverseInternalModel
)
{
return
this
.
store
.
_findByInternalModel
(
this
.
inverseInternalModel
)
;
}
else
{
return
Ember
.
RSVP
.
Promise
.
resolve
(
null
)
;
}
}
fetchLink
(
)
{
return
this
.
store
.
findBelongsTo
(
this
.
internalModel
this
.
link
this
.
relationshipMeta
)
.
then
(
internalModel
=
>
{
if
(
internalModel
)
{
this
.
addInternalModel
(
internalModel
)
;
}
return
internalModel
;
}
)
;
}
getRecord
(
)
{
if
(
this
.
isAsync
)
{
var
promise
=
void
0
;
if
(
this
.
link
)
{
if
(
this
.
hasLoaded
)
{
promise
=
this
.
findRecord
(
)
;
}
else
{
promise
=
this
.
findLink
(
)
.
then
(
(
)
=
>
this
.
findRecord
(
)
)
;
}
}
else
{
promise
=
this
.
findRecord
(
)
;
}
return
PromiseObject
.
create
(
{
promise
:
promise
content
:
this
.
inverseInternalModel
?
this
.
inverseInternalModel
.
getRecord
(
)
:
null
}
)
;
}
else
{
if
(
this
.
inverseInternalModel
=
=
=
null
)
{
return
null
;
}
var
toReturn
=
this
.
inverseInternalModel
.
getRecord
(
)
;
(
true
&
&
!
(
toReturn
=
=
=
null
|
|
!
toReturn
.
get
(
'
isEmpty
'
)
)
&
&
Ember
.
assert
(
"
You
looked
up
the
'
"
+
this
.
key
+
"
'
relationship
on
a
'
"
+
this
.
internalModel
.
modelName
+
"
'
with
id
"
+
this
.
internalModel
.
id
+
"
but
some
of
the
associated
records
were
not
loaded
.
Either
make
sure
they
are
all
loaded
together
with
the
parent
record
or
specify
that
the
relationship
is
async
(
DS
.
belongsTo
(
{
async
:
true
}
)
)
"
toReturn
=
=
=
null
|
|
!
toReturn
.
get
(
'
isEmpty
'
)
)
)
;
return
toReturn
;
}
}
reload
(
)
{
if
(
this
.
link
)
{
return
this
.
fetchLink
(
)
;
}
if
(
this
.
inverseInternalModel
&
&
this
.
inverseInternalModel
.
hasRecord
)
{
return
this
.
inverseInternalModel
.
getRecord
(
)
.
reload
(
)
;
}
return
this
.
findRecord
(
)
;
}
updateData
(
data
initial
)
{
(
true
&
&
!
(
data
=
=
=
null
|
|
data
.
id
!
=
=
undefined
&
&
data
.
type
!
=
=
undefined
)
&
&
Ember
.
assert
(
Ember
Data
expected
the
data
for
the
{
this
.
key
}
relationship
on
a
{
this
.
internalModel
.
toString
(
)
}
to
be
in
a
JSON
API
format
and
include
an
\
id
\
and
\
type
\
property
but
it
found
{
Ember
.
inspect
(
data
)
}
.
Please
check
your
serializer
and
make
sure
it
is
serializing
the
relationship
payload
into
a
JSON
API
format
.
data
=
=
=
null
|
|
data
.
id
!
=
=
undefined
&
&
data
.
type
!
=
=
undefined
)
)
;
var
internalModel
=
this
.
store
.
_pushResourceIdentifier
(
this
data
)
;
if
(
initial
)
{
this
.
setInitialCanonicalInternalModel
(
internalModel
)
;
}
else
{
this
.
setCanonicalInternalModel
(
internalModel
)
;
}
}
}
function
shouldFindInverse
(
relationshipMeta
)
{
var
options
=
relationshipMeta
.
options
;
return
!
(
options
&
&
options
.
inverse
=
=
=
null
)
;
}
function
createRelationshipFor
(
internalModel
relationshipMeta
store
)
{
var
inverseKey
=
void
0
;
var
inverse
=
null
;
if
(
shouldFindInverse
(
relationshipMeta
)
)
{
inverse
=
internalModel
.
type
.
inverseFor
(
relationshipMeta
.
key
store
)
;
}
else
{
internalModel
.
type
.
typeForRelationship
(
relationshipMeta
.
key
store
)
;
}
if
(
inverse
)
{
inverseKey
=
inverse
.
name
;
}
if
(
relationshipMeta
.
kind
=
=
=
'
hasMany
'
)
{
return
new
ManyRelationship
(
store
internalModel
inverseKey
relationshipMeta
)
;
}
else
{
return
new
BelongsToRelationship
(
store
internalModel
inverseKey
relationshipMeta
)
;
}
}
class
Relationships
{
constructor
(
internalModel
)
{
this
.
internalModel
=
internalModel
;
this
.
initializedRelationships
=
Object
.
create
(
null
)
;
}
get
record
(
)
{
return
this
.
internalModel
;
}
has
(
key
)
{
return
!
!
this
.
initializedRelationships
[
key
]
;
}
forEach
(
cb
)
{
var
rels
=
this
.
initializedRelationships
;
Object
.
keys
(
rels
)
.
forEach
(
name
=
>
{
cb
(
name
rels
[
name
]
)
;
}
)
;
}
get
(
key
)
{
var
relationships
=
this
.
initializedRelationships
;
var
relationship
=
relationships
[
key
]
;
var
internalModel
=
this
.
internalModel
;
if
(
!
relationship
)
{
var
relationshipsByName
=
Ember
.
get
(
internalModel
.
type
'
relationshipsByName
'
)
;
var
rel
=
relationshipsByName
.
get
(
key
)
;
if
(
!
rel
)
{
return
undefined
;
}
var
relationshipPayload
=
internalModel
.
store
.
_relationshipsPayloads
.
get
(
internalModel
.
modelName
internalModel
.
id
key
)
;
relationship
=
relationships
[
key
]
=
createRelationshipFor
(
internalModel
rel
internalModel
.
store
)
;
if
(
relationshipPayload
)
{
relationship
.
push
(
relationshipPayload
true
)
;
}
}
return
relationship
;
}
}
class
Snapshot
{
constructor
(
internalModel
options
=
{
}
)
{
this
.
_attributes
=
Object
.
create
(
null
)
;
this
.
_belongsToRelationships
=
Object
.
create
(
null
)
;
this
.
_belongsToIds
=
Object
.
create
(
null
)
;
this
.
_hasManyRelationships
=
Object
.
create
(
null
)
;
this
.
_hasManyIds
=
Object
.
create
(
null
)
;
this
.
_internalModel
=
internalModel
;
var
record
=
internalModel
.
getRecord
(
)
;
this
.
record
=
record
;
record
.
eachAttribute
(
keyName
=
>
this
.
_attributes
[
keyName
]
=
Ember
.
get
(
record
keyName
)
)
;
this
.
id
=
internalModel
.
id
;
this
.
adapterOptions
=
options
.
adapterOptions
;
this
.
include
=
options
.
include
;
this
.
modelName
=
internalModel
.
modelName
;
this
.
_changedAttributes
=
record
.
changedAttributes
(
)
;
}
get
type
(
)
{
return
this
.
_internalModel
.
modelClass
;
}
attr
(
keyName
)
{
if
(
keyName
in
this
.
_attributes
)
{
return
this
.
_attributes
[
keyName
]
;
}
throw
new
Ember
.
Error
(
"
Model
'
"
+
Ember
.
inspect
(
this
.
record
)
+
"
'
has
no
attribute
named
'
"
+
keyName
+
"
'
defined
.
"
)
;
}
attributes
(
)
{
return
Ember
.
copy
(
this
.
_attributes
)
;
}
changedAttributes
(
)
{
var
changedAttributes
=
Object
.
create
(
null
)
;
var
changedAttributeKeys
=
Object
.
keys
(
this
.
_changedAttributes
)
;
for
(
var
i
=
0
length
=
changedAttributeKeys
.
length
;
i
<
length
;
i
+
+
)
{
var
key
=
changedAttributeKeys
[
i
]
;
changedAttributes
[
key
]
=
Ember
.
copy
(
this
.
_changedAttributes
[
key
]
)
;
}
return
changedAttributes
;
}
belongsTo
(
keyName
options
)
{
var
id
=
options
&
&
options
.
id
;
var
relationship
=
void
0
inverseInternalModel
=
void
0
hasData
=
void
0
;
var
result
=
void
0
;
if
(
id
&
&
keyName
in
this
.
_belongsToIds
)
{
return
this
.
_belongsToIds
[
keyName
]
;
}
if
(
!
id
&
&
keyName
in
this
.
_belongsToRelationships
)
{
return
this
.
_belongsToRelationships
[
keyName
]
;
}
relationship
=
this
.
_internalModel
.
_relationships
.
get
(
keyName
)
;
if
(
!
(
relationship
&
&
relationship
.
relationshipMeta
.
kind
=
=
=
'
belongsTo
'
)
)
{
throw
new
Ember
.
Error
(
"
Model
'
"
+
Ember
.
inspect
(
this
.
record
)
+
"
'
has
no
belongsTo
relationship
named
'
"
+
keyName
+
"
'
defined
.
"
)
;
}
hasData
=
Ember
.
get
(
relationship
'
hasData
'
)
;
inverseInternalModel
=
Ember
.
get
(
relationship
'
inverseInternalModel
'
)
;
if
(
hasData
)
{
if
(
inverseInternalModel
&
&
!
inverseInternalModel
.
isDeleted
(
)
)
{
if
(
id
)
{
result
=
Ember
.
get
(
inverseInternalModel
'
id
'
)
;
}
else
{
result
=
inverseInternalModel
.
createSnapshot
(
)
;
}
}
else
{
result
=
null
;
}
}
if
(
id
)
{
this
.
_belongsToIds
[
keyName
]
=
result
;
}
else
{
this
.
_belongsToRelationships
[
keyName
]
=
result
;
}
return
result
;
}
hasMany
(
keyName
options
)
{
var
ids
=
options
&
&
options
.
ids
;
var
relationship
=
void
0
members
=
void
0
hasData
=
void
0
;
var
results
=
void
0
;
if
(
ids
&
&
keyName
in
this
.
_hasManyIds
)
{
return
this
.
_hasManyIds
[
keyName
]
;
}
if
(
!
ids
&
&
keyName
in
this
.
_hasManyRelationships
)
{
return
this
.
_hasManyRelationships
[
keyName
]
;
}
relationship
=
this
.
_internalModel
.
_relationships
.
get
(
keyName
)
;
if
(
!
(
relationship
&
&
relationship
.
relationshipMeta
.
kind
=
=
=
'
hasMany
'
)
)
{
throw
new
Ember
.
Error
(
"
Model
'
"
+
Ember
.
inspect
(
this
.
record
)
+
"
'
has
no
hasMany
relationship
named
'
"
+
keyName
+
"
'
defined
.
"
)
;
}
hasData
=
Ember
.
get
(
relationship
'
hasData
'
)
;
members
=
Ember
.
get
(
relationship
'
members
'
)
;
if
(
hasData
)
{
results
=
[
]
;
members
.
forEach
(
member
=
>
{
if
(
!
member
.
isDeleted
(
)
)
{
if
(
ids
)
{
results
.
push
(
member
.
id
)
;
}
else
{
results
.
push
(
member
.
createSnapshot
(
)
)
;
}
}
}
)
;
}
if
(
ids
)
{
this
.
_hasManyIds
[
keyName
]
=
results
;
}
else
{
this
.
_hasManyRelationships
[
keyName
]
=
results
;
}
return
results
;
}
eachAttribute
(
callback
binding
)
{
this
.
record
.
eachAttribute
(
callback
binding
)
;
}
eachRelationship
(
callback
binding
)
{
this
.
record
.
eachRelationship
(
callback
binding
)
;
}
serialize
(
options
)
{
return
this
.
record
.
store
.
serializerFor
(
this
.
modelName
)
.
serialize
(
this
options
)
;
}
}
function
modelHasAttributeOrRelationshipNamedType
(
modelClass
)
{
return
Ember
.
get
(
modelClass
'
attributes
'
)
.
has
(
'
type
'
)
|
|
Ember
.
get
(
modelClass
'
relationshipsByName
'
)
.
has
(
'
type
'
)
;
}
function
getOwner
(
context
)
{
var
owner
=
void
0
;
if
(
Ember
.
getOwner
)
{
owner
=
Ember
.
getOwner
(
context
)
;
}
else
if
(
context
.
container
)
{
owner
=
context
.
container
;
}
if
(
owner
&
&
owner
.
lookupFactory
&
&
!
owner
.
_lookupFactory
)
{
owner
.
_lookupFactory
=
function
(
)
{
return
owner
.
lookupFactory
(
.
.
.
arguments
)
;
}
;
owner
.
register
=
function
(
)
{
var
registry
=
owner
.
registry
|
|
owner
.
_registry
|
|
owner
;
return
registry
.
register
(
.
.
.
arguments
)
;
}
;
}
return
owner
;
}
var
Reference
=
function
(
store
internalModel
)
{
this
.
store
=
store
;
this
.
internalModel
=
internalModel
;
}
;
Reference
.
prototype
=
{
constructor
:
Reference
}
;
var
RecordReference
=
function
(
store
internalModel
)
{
this
.
_super
constructor
(
store
internalModel
)
;
this
.
type
=
internalModel
.
modelName
;
this
.
_id
=
internalModel
.
id
;
}
;
RecordReference
.
prototype
=
Object
.
create
(
Reference
.
prototype
)
;
RecordReference
.
prototype
.
constructor
=
RecordReference
;
RecordReference
.
prototype
.
_super
constructor
=
Reference
;
RecordReference
.
prototype
.
id
=
function
(
)
{
return
this
.
_id
;
}
;
RecordReference
.
prototype
.
remoteType
=
function
(
)
{
return
'
identity
'
;
}
;
RecordReference
.
prototype
.
push
=
function
(
objectOrPromise
)
{
return
Ember
.
RSVP
.
resolve
(
objectOrPromise
)
.
then
(
data
=
>
{
return
this
.
store
.
push
(
data
)
;
}
)
;
}
;
RecordReference
.
prototype
.
value
=
function
(
)
{
if
(
this
.
internalModel
.
hasRecord
)
{
return
this
.
internalModel
.
getRecord
(
)
;
}
return
null
;
}
;
RecordReference
.
prototype
.
load
=
function
(
)
{
return
this
.
store
.
findRecord
(
this
.
type
this
.
_id
)
;
}
;
RecordReference
.
prototype
.
reload
=
function
(
)
{
var
record
=
this
.
value
(
)
;
if
(
record
)
{
return
record
.
reload
(
)
;
}
return
this
.
load
(
)
;
}
;
var
BelongsToReference
=
function
(
store
parentInternalModel
belongsToRelationship
)
{
this
.
_super
constructor
(
store
parentInternalModel
)
;
this
.
belongsToRelationship
=
belongsToRelationship
;
this
.
type
=
belongsToRelationship
.
relationshipMeta
.
type
;
this
.
parent
=
parentInternalModel
.
recordReference
;
}
;
BelongsToReference
.
prototype
=
Object
.
create
(
Reference
.
prototype
)
;
BelongsToReference
.
prototype
.
constructor
=
BelongsToReference
;
BelongsToReference
.
prototype
.
_super
constructor
=
Reference
;
BelongsToReference
.
prototype
.
remoteType
=
function
(
)
{
if
(
this
.
belongsToRelationship
.
link
)
{
return
"
link
"
;
}
return
"
id
"
;
}
;
BelongsToReference
.
prototype
.
id
=
function
(
)
{
var
inverseInternalModel
=
this
.
belongsToRelationship
.
inverseInternalModel
;
return
inverseInternalModel
&
&
inverseInternalModel
.
id
;
}
;
BelongsToReference
.
prototype
.
link
=
function
(
)
{
return
this
.
belongsToRelationship
.
link
;
}
;
BelongsToReference
.
prototype
.
meta
=
function
(
)
{
return
this
.
belongsToRelationship
.
meta
;
}
;
BelongsToReference
.
prototype
.
push
=
function
(
objectOrPromise
)
{
return
Ember
.
RSVP
.
resolve
(
objectOrPromise
)
.
then
(
data
=
>
{
var
record
=
void
0
;
if
(
data
instanceof
Model
)
{
if
(
isEnabled
(
'
ds
-
overhaul
-
references
'
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
BelongsToReference
#
push
(
DS
.
Model
)
is
deprecated
.
Update
relationship
via
model
.
set
(
'
relationshipName
'
value
)
instead
.
"
false
{
id
:
'
ds
.
references
.
belongs
-
to
.
push
-
record
'
until
:
'
4
.
0
.
0
'
}
)
)
;
}
record
=
data
;
}
else
{
record
=
this
.
store
.
push
(
data
)
;
}
emberData_Debug
.
assertPolymorphicType
(
this
.
internalModel
this
.
belongsToRelationship
.
relationshipMeta
record
.
_internalModel
)
;
this
.
belongsToRelationship
.
setCanonicalInternalModel
(
record
.
_internalModel
)
;
return
record
;
}
)
;
}
;
BelongsToReference
.
prototype
.
value
=
function
(
)
{
var
inverseInternalModel
=
this
.
belongsToRelationship
.
inverseInternalModel
;
if
(
inverseInternalModel
&
&
inverseInternalModel
.
isLoaded
(
)
)
{
return
inverseInternalModel
.
getRecord
(
)
;
}
return
null
;
}
;
BelongsToReference
.
prototype
.
load
=
function
(
)
{
if
(
this
.
remoteType
(
)
=
=
=
"
id
"
)
{
return
this
.
belongsToRelationship
.
getRecord
(
)
;
}
if
(
this
.
remoteType
(
)
=
=
=
"
link
"
)
{
return
this
.
belongsToRelationship
.
findLink
(
)
.
then
(
internalModel
=
>
{
return
this
.
value
(
)
;
}
)
;
}
}
;
BelongsToReference
.
prototype
.
reload
=
function
(
)
{
return
this
.
belongsToRelationship
.
reload
(
)
.
then
(
internalModel
=
>
{
return
this
.
value
(
)
;
}
)
;
}
;
var
HasManyReference
=
function
(
store
parentInternalModel
hasManyRelationship
)
{
this
.
_super
constructor
(
store
parentInternalModel
)
;
this
.
hasManyRelationship
=
hasManyRelationship
;
this
.
type
=
hasManyRelationship
.
relationshipMeta
.
type
;
this
.
parent
=
parentInternalModel
.
recordReference
;
}
;
HasManyReference
.
prototype
=
Object
.
create
(
Reference
.
prototype
)
;
HasManyReference
.
prototype
.
constructor
=
HasManyReference
;
HasManyReference
.
prototype
.
_super
constructor
=
Reference
;
HasManyReference
.
prototype
.
remoteType
=
function
(
)
{
if
(
this
.
hasManyRelationship
.
link
)
{
return
"
link
"
;
}
return
"
ids
"
;
}
;
HasManyReference
.
prototype
.
link
=
function
(
)
{
return
this
.
hasManyRelationship
.
link
;
}
;
HasManyReference
.
prototype
.
ids
=
function
(
)
{
var
members
=
this
.
hasManyRelationship
.
members
.
toArray
(
)
;
return
members
.
map
(
function
(
internalModel
)
{
return
internalModel
.
id
;
}
)
;
}
;
HasManyReference
.
prototype
.
meta
=
function
(
)
{
return
this
.
hasManyRelationship
.
meta
;
}
;
HasManyReference
.
prototype
.
push
=
function
(
objectOrPromise
)
{
return
Ember
.
RSVP
.
resolve
(
objectOrPromise
)
.
then
(
payload
=
>
{
var
array
=
payload
;
if
(
isEnabled
(
"
ds
-
overhaul
-
references
"
)
)
{
(
true
&
&
!
(
!
Array
.
isArray
(
payload
)
)
&
&
Ember
.
deprecate
(
"
HasManyReference
#
push
(
array
)
is
deprecated
.
Push
a
JSON
-
API
document
instead
.
"
!
Array
.
isArray
(
payload
)
{
id
:
'
ds
.
references
.
has
-
many
.
push
-
array
'
until
:
'
4
.
0
.
0
'
}
)
)
;
}
var
useLegacyArrayPush
=
true
;
if
(
typeof
payload
=
=
=
"
object
"
&
&
payload
.
data
)
{
array
=
payload
.
data
;
useLegacyArrayPush
=
array
.
length
&
&
array
[
0
]
.
data
;
if
(
isEnabled
(
'
ds
-
overhaul
-
references
'
)
)
{
(
true
&
&
!
(
!
useLegacyArrayPush
)
&
&
Ember
.
deprecate
(
"
HasManyReference
#
push
(
)
expects
a
valid
JSON
-
API
document
.
"
!
useLegacyArrayPush
{
id
:
'
ds
.
references
.
has
-
many
.
push
-
invalid
-
json
-
api
'
until
:
'
4
.
0
.
0
'
}
)
)
;
}
}
if
(
!
isEnabled
(
'
ds
-
overhaul
-
references
'
)
)
{
useLegacyArrayPush
=
true
;
}
var
internalModels
=
void
0
;
if
(
useLegacyArrayPush
)
{
internalModels
=
array
.
map
(
obj
=
>
{
var
record
=
this
.
store
.
push
(
obj
)
;
{
var
relationshipMeta
=
this
.
hasManyRelationship
.
relationshipMeta
;
emberData_Debug
.
assertPolymorphicType
(
this
.
internalModel
relationshipMeta
record
.
_internalModel
)
;
}
return
record
.
_internalModel
;
}
)
;
}
else
{
var
records
=
this
.
store
.
push
(
payload
)
;
internalModels
=
Ember
.
A
(
records
)
.
mapBy
(
'
_internalModel
'
)
;
{
internalModels
.
forEach
(
internalModel
=
>
{
var
relationshipMeta
=
this
.
hasManyRelationship
.
relationshipMeta
;
emberData_Debug
.
assertPolymorphicType
(
this
.
internalModel
relationshipMeta
internalModel
)
;
}
)
;
}
}
this
.
hasManyRelationship
.
computeChanges
(
internalModels
)
;
return
this
.
hasManyRelationship
.
manyArray
;
}
)
;
}
;
HasManyReference
.
prototype
.
_isLoaded
=
function
(
)
{
var
hasData
=
Ember
.
get
(
this
.
hasManyRelationship
'
hasData
'
)
;
if
(
!
hasData
)
{
return
false
;
}
var
members
=
this
.
hasManyRelationship
.
members
.
toArray
(
)
;
return
members
.
every
(
function
(
internalModel
)
{
return
internalModel
.
isLoaded
(
)
=
=
=
true
;
}
)
;
}
;
HasManyReference
.
prototype
.
value
=
function
(
)
{
if
(
this
.
_isLoaded
(
)
)
{
return
this
.
hasManyRelationship
.
manyArray
;
}
return
null
;
}
;
HasManyReference
.
prototype
.
load
=
function
(
)
{
if
(
!
this
.
_isLoaded
(
)
)
{
return
this
.
hasManyRelationship
.
getRecords
(
)
;
}
return
Ember
.
RSVP
.
resolve
(
this
.
hasManyRelationship
.
manyArray
)
;
}
;
HasManyReference
.
prototype
.
reload
=
function
(
)
{
return
this
.
hasManyRelationship
.
reload
(
)
;
}
;
var
emberAssign
=
Ember
.
assign
|
|
Ember
.
merge
;
var
TransitionChainMap
=
Object
.
create
(
null
)
;
var
_extractPivotNameCache
=
Object
.
create
(
null
)
;
var
_splitOnDotCache
=
Object
.
create
(
null
)
;
function
splitOnDot
(
name
)
{
return
_splitOnDotCache
[
name
]
|
|
(
_splitOnDotCache
[
name
]
=
name
.
split
(
'
.
'
)
)
;
}
function
extractPivotName
(
name
)
{
return
_extractPivotNameCache
[
name
]
|
|
(
_extractPivotNameCache
[
name
]
=
splitOnDot
(
name
)
[
0
]
)
;
}
function
areAllModelsUnloaded
(
internalModels
)
{
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
+
+
i
)
{
var
record
=
internalModels
[
i
]
.
_record
;
if
(
record
&
&
!
(
record
.
get
(
'
isDestroyed
'
)
|
|
record
.
get
(
'
isDestroying
'
)
)
)
{
return
false
;
}
}
return
true
;
}
function
destroyRelationship
(
rel
)
{
rel
.
internalModelDidDematerialize
(
)
;
if
(
rel
.
_inverseIsSync
(
)
)
{
rel
.
removeAllInternalModelsFromOwn
(
)
;
rel
.
removeAllCanonicalInternalModelsFromOwn
(
)
;
}
}
var
InternalModelReferenceId
=
1
;
var
nextBfsId
=
1
;
class
InternalModel
{
constructor
(
modelName
id
store
data
)
{
this
.
id
=
id
;
this
[
Ember
.
GUID_KEY
]
=
InternalModelReferenceId
+
+
+
'
internal
-
model
'
;
this
.
store
=
store
;
this
.
modelName
=
modelName
;
this
.
_loadingPromise
=
null
;
this
.
_record
=
null
;
this
.
_isDestroyed
=
false
;
this
.
isError
=
false
;
this
.
_isUpdatingRecordArrays
=
false
;
this
.
_isDematerializing
=
false
;
this
.
_scheduledDestroy
=
null
;
this
.
resetRecord
(
)
;
if
(
data
)
{
this
.
__data
=
data
;
}
this
.
_modelClass
=
null
;
this
.
__deferredTriggers
=
null
;
this
.
__recordArrays
=
null
;
this
.
_references
=
null
;
this
.
_recordReference
=
null
;
this
.
__relationships
=
null
;
this
.
__implicitRelationships
=
null
;
this
.
_bfsId
=
0
;
}
get
modelClass
(
)
{
return
this
.
_modelClass
|
|
(
this
.
_modelClass
=
this
.
store
.
_modelFor
(
this
.
modelName
)
)
;
}
get
type
(
)
{
return
this
.
modelClass
;
}
get
recordReference
(
)
{
if
(
this
.
_recordReference
=
=
=
null
)
{
this
.
_recordReference
=
new
RecordReference
(
this
.
store
this
)
;
}
return
this
.
_recordReference
;
}
get
_recordArrays
(
)
{
if
(
this
.
__recordArrays
=
=
=
null
)
{
this
.
__recordArrays
=
OrderedSet
.
create
(
)
;
}
return
this
.
__recordArrays
;
}
get
references
(
)
{
if
(
this
.
_references
=
=
=
null
)
{
this
.
_references
=
Object
.
create
(
null
)
;
}
return
this
.
_references
;
}
get
_deferredTriggers
(
)
{
if
(
this
.
__deferredTriggers
=
=
=
null
)
{
this
.
__deferredTriggers
=
[
]
;
}
return
this
.
__deferredTriggers
;
}
get
_attributes
(
)
{
if
(
this
.
__attributes
=
=
=
null
)
{
this
.
__attributes
=
Object
.
create
(
null
)
;
}
return
this
.
__attributes
;
}
set
_attributes
(
v
)
{
this
.
__attributes
=
v
;
}
get
_relationships
(
)
{
if
(
this
.
__relationships
=
=
=
null
)
{
this
.
__relationships
=
new
Relationships
(
this
)
;
}
return
this
.
__relationships
;
}
get
_inFlightAttributes
(
)
{
if
(
this
.
__inFlightAttributes
=
=
=
null
)
{
this
.
__inFlightAttributes
=
Object
.
create
(
null
)
;
}
return
this
.
__inFlightAttributes
;
}
set
_inFlightAttributes
(
v
)
{
this
.
__inFlightAttributes
=
v
;
}
get
_data
(
)
{
if
(
this
.
__data
=
=
=
null
)
{
this
.
__data
=
Object
.
create
(
null
)
;
}
return
this
.
__data
;
}
set
_data
(
v
)
{
this
.
__data
=
v
;
}
get
_implicitRelationships
(
)
{
if
(
this
.
__implicitRelationships
=
=
=
null
)
{
this
.
__implicitRelationships
=
Object
.
create
(
null
)
;
}
return
this
.
__implicitRelationships
;
}
isHiddenFromRecordArrays
(
)
{
return
this
.
_isDematerializing
|
|
this
.
isDestroyed
|
|
this
.
currentState
.
stateName
=
=
=
'
root
.
deleted
.
saved
'
|
|
this
.
isEmpty
(
)
;
}
isEmpty
(
)
{
return
this
.
currentState
.
isEmpty
;
}
isLoading
(
)
{
return
this
.
currentState
.
isLoading
;
}
isLoaded
(
)
{
return
this
.
currentState
.
isLoaded
;
}
hasDirtyAttributes
(
)
{
return
this
.
currentState
.
hasDirtyAttributes
;
}
isSaving
(
)
{
return
this
.
currentState
.
isSaving
;
}
isDeleted
(
)
{
return
this
.
currentState
.
isDeleted
;
}
isNew
(
)
{
return
this
.
currentState
.
isNew
;
}
isValid
(
)
{
return
this
.
currentState
.
isValid
;
}
dirtyType
(
)
{
return
this
.
currentState
.
dirtyType
;
}
getRecord
(
properties
)
{
if
(
!
this
.
_record
&
&
!
this
.
_isDematerializing
)
{
var
createOptions
=
{
store
:
this
.
store
_internalModel
:
this
id
:
this
.
id
currentState
:
this
.
currentState
isError
:
this
.
isError
adapterError
:
this
.
error
}
;
if
(
typeof
properties
=
=
=
'
object
'
&
&
properties
!
=
=
null
)
{
emberAssign
(
createOptions
properties
)
;
}
if
(
Ember
.
setOwner
)
{
Ember
.
setOwner
(
createOptions
getOwner
(
this
.
store
)
)
;
}
else
{
createOptions
.
container
=
this
.
store
.
container
;
}
this
.
_record
=
this
.
store
.
modelFactoryFor
(
this
.
modelName
)
.
create
(
createOptions
)
;
this
.
_triggerDeferredTriggers
(
)
;
}
return
this
.
_record
;
}
resetRecord
(
)
{
this
.
_record
=
null
;
this
.
isReloading
=
false
;
this
.
error
=
null
;
this
.
currentState
=
RootState
1
.
empty
;
this
.
__attributes
=
null
;
this
.
__inFlightAttributes
=
null
;
this
.
_data
=
null
;
}
dematerializeRecord
(
)
{
if
(
this
.
_record
)
{
this
.
_isDematerializing
=
true
;
this
.
_record
.
destroy
(
)
;
this
.
destroyRelationships
(
)
;
this
.
updateRecordArrays
(
)
;
this
.
resetRecord
(
)
;
}
}
deleteRecord
(
)
{
this
.
send
(
'
deleteRecord
'
)
;
}
save
(
options
)
{
var
promiseLabel
=
"
DS
:
Model
#
save
"
+
this
;
var
resolver
=
Ember
.
RSVP
.
defer
(
promiseLabel
)
;
this
.
store
.
scheduleSave
(
this
resolver
options
)
;
return
resolver
.
promise
;
}
startedReloading
(
)
{
this
.
isReloading
=
true
;
if
(
this
.
hasRecord
)
{
Ember
.
set
(
this
.
_record
'
isReloading
'
true
)
;
}
}
finishedReloading
(
)
{
this
.
isReloading
=
false
;
if
(
this
.
hasRecord
)
{
Ember
.
set
(
this
.
_record
'
isReloading
'
false
)
;
}
}
reload
(
)
{
this
.
startedReloading
(
)
;
var
internalModel
=
this
;
var
promiseLabel
=
"
DS
:
Model
#
reload
of
"
+
this
;
return
new
Ember
.
RSVP
.
Promise
(
function
(
resolve
)
{
internalModel
.
send
(
'
reloadRecord
'
resolve
)
;
}
promiseLabel
)
.
then
(
function
(
)
{
internalModel
.
didCleanError
(
)
;
return
internalModel
;
}
function
(
error
)
{
internalModel
.
didError
(
error
)
;
throw
error
;
}
"
DS
:
Model
#
reload
complete
update
flags
"
)
.
finally
(
function
(
)
{
internalModel
.
finishedReloading
(
)
;
internalModel
.
updateRecordArrays
(
)
;
}
)
;
}
_directlyRelatedInternalModels
(
)
{
var
array
=
[
]
;
this
.
_relationships
.
forEach
(
(
name
rel
)
=
>
{
array
=
array
.
concat
(
rel
.
members
.
list
rel
.
canonicalMembers
.
list
)
;
}
)
;
return
array
;
}
_allRelatedInternalModels
(
)
{
var
array
=
[
]
;
var
queue
=
[
]
;
var
bfsId
=
nextBfsId
+
+
;
queue
.
push
(
this
)
;
this
.
_bfsId
=
bfsId
;
while
(
queue
.
length
>
0
)
{
var
node
=
queue
.
shift
(
)
;
array
.
push
(
node
)
;
var
related
=
node
.
_directlyRelatedInternalModels
(
)
;
for
(
var
i
=
0
;
i
<
related
.
length
;
+
+
i
)
{
var
internalModel
=
related
[
i
]
;
(
true
&
&
!
(
internalModel
.
_bfsId
<
=
bfsId
)
&
&
Ember
.
assert
(
'
Internal
Error
:
seen
a
future
bfs
iteration
'
internalModel
.
_bfsId
<
=
bfsId
)
)
;
if
(
internalModel
.
_bfsId
<
bfsId
)
{
queue
.
push
(
internalModel
)
;
internalModel
.
_bfsId
=
bfsId
;
}
}
}
return
array
;
}
unloadRecord
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
this
.
send
(
'
unloadRecord
'
)
;
this
.
dematerializeRecord
(
)
;
if
(
this
.
_scheduledDestroy
=
=
=
null
)
{
if
(
!
Ember
.
run
.
currentRunLoop
)
{
(
true
&
&
!
(
Ember
.
testing
)
&
&
Ember
.
assert
(
'
You
have
turned
on
testing
mode
which
disabled
the
run
-
loop
\
'
s
autorun
.
\
n
You
will
need
to
wrap
any
code
with
asynchronous
side
-
effects
in
a
run
'
Ember
.
testing
)
)
;
}
this
.
_scheduledDestroy
=
Ember
.
run
.
backburner
.
schedule
(
'
destroy
'
this
'
_checkForOrphanedInternalModels
'
)
;
}
}
hasScheduledDestroy
(
)
{
return
!
!
this
.
_scheduledDestroy
;
}
cancelDestroy
(
)
{
(
true
&
&
!
(
!
this
.
isDestroyed
)
&
&
Ember
.
assert
(
You
cannot
cancel
the
destruction
of
an
InternalModel
once
it
has
already
been
destroyed
!
this
.
isDestroyed
)
)
;
this
.
_isDematerializing
=
false
;
Ember
.
run
.
cancel
(
this
.
_scheduledDestroy
)
;
this
.
_scheduledDestroy
=
null
;
}
destroySync
(
)
{
if
(
this
.
_isDematerializing
)
{
this
.
cancelDestroy
(
)
;
}
this
.
_checkForOrphanedInternalModels
(
)
;
if
(
this
.
isDestroyed
|
|
this
.
isDestroying
)
{
return
;
}
this
.
destroy
(
)
;
}
_checkForOrphanedInternalModels
(
)
{
this
.
_isDematerializing
=
false
;
this
.
_scheduledDestroy
=
null
;
if
(
this
.
isDestroyed
)
{
return
;
}
this
.
_cleanupOrphanedInternalModels
(
)
;
}
_cleanupOrphanedInternalModels
(
)
{
var
relatedInternalModels
=
this
.
_allRelatedInternalModels
(
)
;
if
(
areAllModelsUnloaded
(
relatedInternalModels
)
)
{
for
(
var
i
=
0
;
i
<
relatedInternalModels
.
length
;
+
+
i
)
{
var
internalModel
=
relatedInternalModels
[
i
]
;
if
(
!
internalModel
.
isDestroyed
)
{
internalModel
.
destroy
(
)
;
}
}
}
}
eachRelationship
(
callback
binding
)
{
return
this
.
modelClass
.
eachRelationship
(
callback
binding
)
;
}
destroy
(
)
{
(
true
&
&
!
(
!
this
.
_record
|
|
this
.
_record
.
get
(
'
isDestroyed
'
)
|
|
this
.
_record
.
get
(
'
isDestroying
'
)
)
&
&
Ember
.
assert
(
"
Cannot
destroy
an
internalModel
while
its
record
is
materialized
"
!
this
.
_record
|
|
this
.
_record
.
get
(
'
isDestroyed
'
)
|
|
this
.
_record
.
get
(
'
isDestroying
'
)
)
)
;
this
.
store
.
_internalModelDestroyed
(
this
)
;
this
.
_relationships
.
forEach
(
(
name
rel
)
=
>
rel
.
destroy
(
)
)
;
this
.
_isDestroyed
=
true
;
}
eachAttribute
(
callback
binding
)
{
return
this
.
modelClass
.
eachAttribute
(
callback
binding
)
;
}
inverseFor
(
key
)
{
return
this
.
modelClass
.
inverseFor
(
key
)
;
}
setupData
(
data
)
{
this
.
store
.
_internalModelDidReceiveRelationshipData
(
this
.
modelName
this
.
id
data
.
relationships
)
;
var
changedKeys
=
void
0
;
if
(
this
.
hasRecord
)
{
changedKeys
=
this
.
_changedKeys
(
data
.
attributes
)
;
}
emberAssign
(
this
.
_data
data
.
attributes
)
;
this
.
pushedData
(
)
;
if
(
this
.
hasRecord
)
{
this
.
_record
.
_notifyProperties
(
changedKeys
)
;
}
}
get
isDestroyed
(
)
{
return
this
.
_isDestroyed
;
}
get
hasRecord
(
)
{
return
!
!
this
.
_record
;
}
createSnapshot
(
options
)
{
return
new
Snapshot
(
this
options
)
;
}
loadingData
(
promise
)
{
this
.
send
(
'
loadingData
'
promise
)
;
}
loadedData
(
)
{
this
.
send
(
'
loadedData
'
)
;
}
notFound
(
)
{
this
.
send
(
'
notFound
'
)
;
}
pushedData
(
)
{
this
.
send
(
'
pushedData
'
)
;
}
flushChangedAttributes
(
)
{
this
.
_inFlightAttributes
=
this
.
_attributes
;
this
.
_attributes
=
null
;
}
hasChangedAttributes
(
)
{
return
this
.
__attributes
!
=
=
null
&
&
Object
.
keys
(
this
.
__attributes
)
.
length
>
0
;
}
updateChangedAttributes
(
)
{
var
changedAttributes
=
this
.
changedAttributes
(
)
;
var
changedAttributeNames
=
Object
.
keys
(
changedAttributes
)
;
var
attrs
=
this
.
_attributes
;
for
(
var
i
=
0
length
=
changedAttributeNames
.
length
;
i
<
length
;
i
+
+
)
{
var
attribute
=
changedAttributeNames
[
i
]
;
var
data
=
changedAttributes
[
attribute
]
;
var
oldData
=
data
[
0
]
;
var
newData
=
data
[
1
]
;
if
(
oldData
=
=
=
newData
)
{
delete
attrs
[
attribute
]
;
}
}
}
changedAttributes
(
)
{
var
oldData
=
this
.
_data
;
var
currentData
=
this
.
_attributes
;
var
inFlightData
=
this
.
_inFlightAttributes
;
var
newData
=
emberAssign
(
Ember
.
copy
(
inFlightData
)
currentData
)
;
var
diffData
=
Object
.
create
(
null
)
;
var
newDataKeys
=
Object
.
keys
(
newData
)
;
for
(
var
i
=
0
length
=
newDataKeys
.
length
;
i
<
length
;
i
+
+
)
{
var
key
=
newDataKeys
[
i
]
;
diffData
[
key
]
=
[
oldData
[
key
]
newData
[
key
]
]
;
}
return
diffData
;
}
adapterWillCommit
(
)
{
this
.
send
(
'
willCommit
'
)
;
}
adapterDidDirty
(
)
{
this
.
send
(
'
becomeDirty
'
)
;
this
.
updateRecordArrays
(
)
;
}
send
(
name
context
)
{
var
currentState
=
this
.
currentState
;
if
(
!
currentState
[
name
]
)
{
this
.
_unhandledEvent
(
currentState
name
context
)
;
}
return
currentState
[
name
]
(
this
context
)
;
}
notifyHasManyAdded
(
key
record
idx
)
{
if
(
this
.
hasRecord
)
{
this
.
_record
.
notifyHasManyAdded
(
key
record
idx
)
;
}
}
notifyBelongsToChanged
(
key
record
)
{
if
(
this
.
hasRecord
)
{
this
.
_record
.
notifyBelongsToChanged
(
key
record
)
;
}
}
notifyPropertyChange
(
key
)
{
if
(
this
.
hasRecord
)
{
this
.
_record
.
notifyPropertyChange
(
key
)
;
}
}
rollbackAttributes
(
)
{
var
dirtyKeys
=
void
0
;
if
(
this
.
hasChangedAttributes
(
)
)
{
dirtyKeys
=
Object
.
keys
(
this
.
_attributes
)
;
this
.
_attributes
=
null
;
}
if
(
Ember
.
get
(
this
'
isError
'
)
)
{
this
.
_inFlightAttributes
=
null
;
this
.
didCleanError
(
)
;
}
if
(
this
.
isNew
(
)
)
{
this
.
removeFromInverseRelationships
(
)
;
}
if
(
this
.
isValid
(
)
)
{
this
.
_inFlightAttributes
=
null
;
}
this
.
send
(
'
rolledBack
'
)
;
if
(
dirtyKeys
&
&
dirtyKeys
.
length
>
0
)
{
this
.
_record
.
_notifyProperties
(
dirtyKeys
)
;
}
}
transitionTo
(
name
)
{
var
pivotName
=
extractPivotName
(
name
)
;
var
state
=
this
.
currentState
;
var
transitionMapId
=
{
state
.
stateName
}
-
>
{
name
}
;
do
{
if
(
state
.
exit
)
{
state
.
exit
(
this
)
;
}
state
=
state
.
parentState
;
}
while
(
!
state
[
pivotName
]
)
;
var
setups
=
void
0
;
var
enters
=
void
0
;
var
i
=
void
0
;
var
l
=
void
0
;
var
map
=
TransitionChainMap
[
transitionMapId
]
;
if
(
map
)
{
setups
=
map
.
setups
;
enters
=
map
.
enters
;
state
=
map
.
state
;
}
else
{
setups
=
[
]
;
enters
=
[
]
;
var
path
=
splitOnDot
(
name
)
;
for
(
i
=
0
l
=
path
.
length
;
i
<
l
;
i
+
+
)
{
state
=
state
[
path
[
i
]
]
;
if
(
state
.
enter
)
{
enters
.
push
(
state
)
;
}
if
(
state
.
setup
)
{
setups
.
push
(
state
)
;
}
}
TransitionChainMap
[
transitionMapId
]
=
{
setups
enters
state
}
;
}
for
(
i
=
0
l
=
enters
.
length
;
i
<
l
;
i
+
+
)
{
enters
[
i
]
.
enter
(
this
)
;
}
this
.
currentState
=
state
;
if
(
this
.
hasRecord
)
{
Ember
.
set
(
this
.
_record
'
currentState
'
state
)
;
}
for
(
i
=
0
l
=
setups
.
length
;
i
<
l
;
i
+
+
)
{
setups
[
i
]
.
setup
(
this
)
;
}
this
.
updateRecordArrays
(
)
;
}
_unhandledEvent
(
state
name
context
)
{
var
errorMessage
=
"
Attempted
to
handle
event
"
+
name
+
"
"
;
errorMessage
+
=
"
on
"
+
String
(
this
)
+
"
while
in
state
"
;
errorMessage
+
=
state
.
stateName
+
"
.
"
;
if
(
context
!
=
=
undefined
)
{
errorMessage
+
=
"
Called
with
"
+
Ember
.
inspect
(
context
)
+
"
.
"
;
}
throw
new
Ember
.
Error
(
errorMessage
)
;
}
triggerLater
(
.
.
.
args
)
{
if
(
this
.
_deferredTriggers
.
push
(
args
)
!
=
=
1
)
{
return
;
}
this
.
store
.
_updateInternalModel
(
this
)
;
}
_triggerDeferredTriggers
(
)
{
if
(
!
this
.
hasRecord
)
{
return
;
}
var
triggers
=
this
.
_deferredTriggers
;
var
record
=
this
.
_record
;
var
trigger
=
record
.
trigger
;
for
(
var
i
=
0
l
=
triggers
.
length
;
i
<
l
;
i
+
+
)
{
trigger
.
apply
(
record
triggers
[
i
]
)
;
}
triggers
.
length
=
0
;
}
removeFromInverseRelationships
(
)
{
this
.
_relationships
.
forEach
(
(
name
rel
)
=
>
{
rel
.
removeCompletelyFromInverse
(
)
;
rel
.
clear
(
)
;
}
)
;
var
implicitRelationships
=
this
.
_implicitRelationships
;
this
.
__implicitRelationships
=
null
;
Object
.
keys
(
implicitRelationships
)
.
forEach
(
key
=
>
{
var
rel
=
implicitRelationships
[
key
]
;
rel
.
removeCompletelyFromInverse
(
)
;
rel
.
clear
(
)
;
}
)
;
}
destroyRelationships
(
)
{
var
relationships
=
this
.
_relationships
;
relationships
.
forEach
(
(
name
rel
)
=
>
destroyRelationship
(
rel
)
)
;
var
implicitRelationships
=
this
.
_implicitRelationships
;
this
.
__implicitRelationships
=
null
;
Object
.
keys
(
implicitRelationships
)
.
forEach
(
key
=
>
{
var
rel
=
implicitRelationships
[
key
]
;
destroyRelationship
(
rel
)
;
}
)
;
}
preloadData
(
preload
)
{
Object
.
keys
(
preload
)
.
forEach
(
key
=
>
{
var
preloadValue
=
Ember
.
get
(
preload
key
)
;
var
relationshipMeta
=
this
.
modelClass
.
metaForProperty
(
key
)
;
if
(
relationshipMeta
.
isRelationship
)
{
this
.
_preloadRelationship
(
key
preloadValue
)
;
}
else
{
this
.
_data
[
key
]
=
preloadValue
;
}
}
)
;
}
_preloadRelationship
(
key
preloadValue
)
{
var
relationshipMeta
=
this
.
modelClass
.
metaForProperty
(
key
)
;
var
modelClass
=
relationshipMeta
.
type
;
if
(
relationshipMeta
.
kind
=
=
=
'
hasMany
'
)
{
this
.
_preloadHasMany
(
key
preloadValue
modelClass
)
;
}
else
{
this
.
_preloadBelongsTo
(
key
preloadValue
modelClass
)
;
}
}
_preloadHasMany
(
key
preloadValue
modelClass
)
{
(
true
&
&
!
(
Array
.
isArray
(
preloadValue
)
)
&
&
Ember
.
assert
(
"
You
need
to
pass
in
an
array
to
set
a
hasMany
property
on
a
record
"
Array
.
isArray
(
preloadValue
)
)
)
;
var
recordsToSet
=
new
Array
(
preloadValue
.
length
)
;
for
(
var
i
=
0
;
i
<
preloadValue
.
length
;
i
+
+
)
{
var
recordToPush
=
preloadValue
[
i
]
;
recordsToSet
[
i
]
=
this
.
_convertStringOrNumberIntoInternalModel
(
recordToPush
modelClass
)
;
}
this
.
_relationships
.
get
(
key
)
.
updateInternalModelsFromAdapter
(
recordsToSet
)
;
}
_preloadBelongsTo
(
key
preloadValue
modelClass
)
{
var
internalModelToSet
=
this
.
_convertStringOrNumberIntoInternalModel
(
preloadValue
modelClass
)
;
this
.
_relationships
.
get
(
key
)
.
setInternalModel
(
internalModelToSet
)
;
}
_convertStringOrNumberIntoInternalModel
(
value
modelClass
)
{
if
(
typeof
value
=
=
=
'
string
'
|
|
typeof
value
=
=
=
'
number
'
)
{
return
this
.
store
.
_internalModelForId
(
modelClass
value
)
;
}
if
(
value
.
_internalModel
)
{
return
value
.
_internalModel
;
}
return
value
;
}
updateRecordArrays
(
)
{
this
.
store
.
recordArrayManager
.
recordDidChange
(
this
)
;
}
setId
(
id
)
{
(
true
&
&
!
(
this
.
id
=
=
=
null
|
|
this
.
id
=
=
=
id
|
|
this
.
isNew
(
)
)
&
&
Ember
.
assert
(
'
A
record
\
'
s
id
cannot
be
changed
once
it
is
in
the
loaded
state
'
this
.
id
=
=
=
null
|
|
this
.
id
=
=
=
id
|
|
this
.
isNew
(
)
)
)
;
this
.
id
=
id
;
if
(
this
.
_record
.
get
(
'
id
'
)
!
=
=
id
)
{
this
.
_record
.
set
(
'
id
'
id
)
;
}
}
didError
(
error
)
{
this
.
error
=
error
;
this
.
isError
=
true
;
if
(
this
.
hasRecord
)
{
this
.
_record
.
setProperties
(
{
isError
:
true
adapterError
:
error
}
)
;
}
}
didCleanError
(
)
{
this
.
error
=
null
;
this
.
isError
=
false
;
if
(
this
.
hasRecord
)
{
this
.
_record
.
setProperties
(
{
isError
:
false
adapterError
:
null
}
)
;
}
}
adapterDidCommit
(
data
)
{
if
(
data
)
{
this
.
store
.
_internalModelDidReceiveRelationshipData
(
this
.
modelName
this
.
id
data
.
relationships
)
;
data
=
data
.
attributes
;
}
this
.
didCleanError
(
)
;
var
changedKeys
=
this
.
_changedKeys
(
data
)
;
emberAssign
(
this
.
_data
this
.
_inFlightAttributes
)
;
if
(
data
)
{
emberAssign
(
this
.
_data
data
)
;
}
this
.
_inFlightAttributes
=
null
;
this
.
send
(
'
didCommit
'
)
;
this
.
updateRecordArrays
(
)
;
if
(
!
data
)
{
return
;
}
this
.
_record
.
_notifyProperties
(
changedKeys
)
;
}
addErrorMessageToAttribute
(
attribute
message
)
{
Ember
.
get
(
this
.
getRecord
(
)
'
errors
'
)
.
_add
(
attribute
message
)
;
}
removeErrorMessageFromAttribute
(
attribute
)
{
Ember
.
get
(
this
.
getRecord
(
)
'
errors
'
)
.
_remove
(
attribute
)
;
}
clearErrorMessages
(
)
{
Ember
.
get
(
this
.
getRecord
(
)
'
errors
'
)
.
_clear
(
)
;
}
hasErrors
(
)
{
var
errors
=
Ember
.
get
(
this
.
getRecord
(
)
'
errors
'
)
;
return
!
Ember
.
isEmpty
(
errors
)
;
}
adapterDidInvalidate
(
errors
)
{
var
attribute
=
void
0
;
for
(
attribute
in
errors
)
{
if
(
errors
.
hasOwnProperty
(
attribute
)
)
{
this
.
addErrorMessageToAttribute
(
attribute
errors
[
attribute
]
)
;
}
}
this
.
send
(
'
becameInvalid
'
)
;
this
.
_saveWasRejected
(
)
;
}
adapterDidError
(
error
)
{
this
.
send
(
'
becameError
'
)
;
this
.
didError
(
error
)
;
this
.
_saveWasRejected
(
)
;
}
_saveWasRejected
(
)
{
var
keys
=
Object
.
keys
(
this
.
_inFlightAttributes
)
;
if
(
keys
.
length
>
0
)
{
var
attrs
=
this
.
_attributes
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
if
(
attrs
[
keys
[
i
]
]
=
=
=
undefined
)
{
attrs
[
keys
[
i
]
]
=
this
.
_inFlightAttributes
[
keys
[
i
]
]
;
}
}
}
this
.
_inFlightAttributes
=
null
;
}
_changedKeys
(
updates
)
{
var
changedKeys
=
[
]
;
if
(
updates
)
{
var
original
=
void
0
i
=
void
0
value
=
void
0
key
=
void
0
;
var
keys
=
Object
.
keys
(
updates
)
;
var
length
=
keys
.
length
;
var
hasAttrs
=
this
.
hasChangedAttributes
(
)
;
var
attrs
=
void
0
;
if
(
hasAttrs
)
{
attrs
=
this
.
_attributes
;
}
original
=
emberAssign
(
Object
.
create
(
null
)
this
.
_data
)
;
original
=
emberAssign
(
original
this
.
_inFlightAttributes
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
key
=
keys
[
i
]
;
value
=
updates
[
key
]
;
if
(
hasAttrs
=
=
=
true
&
&
attrs
[
key
]
!
=
=
undefined
)
{
continue
;
}
if
(
!
Ember
.
isEqual
(
original
[
key
]
value
)
)
{
changedKeys
.
push
(
key
)
;
}
}
}
return
changedKeys
;
}
toString
(
)
{
return
<
{
this
.
modelName
}
:
{
this
.
id
}
>
;
}
referenceFor
(
kind
name
)
{
var
reference
=
this
.
references
[
name
]
;
if
(
!
reference
)
{
var
relationship
=
this
.
_relationships
.
get
(
name
)
;
{
var
modelName
=
this
.
modelName
;
(
true
&
&
!
(
relationship
)
&
&
Ember
.
assert
(
There
is
no
{
kind
}
relationship
named
'
{
name
}
'
on
a
model
of
modelClass
'
{
modelName
}
'
relationship
)
)
;
var
actualRelationshipKind
=
relationship
.
relationshipMeta
.
kind
;
(
true
&
&
!
(
actualRelationshipKind
=
=
=
kind
)
&
&
Ember
.
assert
(
You
tried
to
get
the
'
{
name
}
'
relationship
on
a
'
{
modelName
}
'
via
record
.
{
kind
}
(
'
{
name
}
'
)
but
the
relationship
is
of
kind
'
{
actualRelationshipKind
}
'
.
Use
record
.
{
actualRelationshipKind
}
(
'
{
name
}
'
)
instead
.
actualRelationshipKind
=
=
=
kind
)
)
;
}
if
(
kind
=
=
=
"
belongsTo
"
)
{
reference
=
new
BelongsToReference
(
this
.
store
this
relationship
)
;
}
else
if
(
kind
=
=
=
"
hasMany
"
)
{
reference
=
new
HasManyReference
(
this
.
store
this
relationship
)
;
}
this
.
references
[
name
]
=
reference
;
}
return
reference
;
}
}
if
(
isEnabled
(
'
ds
-
rollback
-
attribute
'
)
)
{
InternalModel
.
prototype
.
lastAcknowledgedValue
=
function
lastAcknowledgedValue
(
key
)
{
if
(
key
in
this
.
_inFlightAttributes
)
{
return
this
.
_inFlightAttributes
[
key
]
;
}
else
{
return
this
.
_data
[
key
]
;
}
}
;
}
class
InternalModelMap
{
constructor
(
modelName
)
{
this
.
modelName
=
modelName
;
this
.
_idToModel
=
Object
.
create
(
null
)
;
this
.
_models
=
[
]
;
this
.
_metadata
=
null
;
}
get
(
id
)
{
return
this
.
_idToModel
[
id
]
;
}
has
(
id
)
{
return
!
!
this
.
_idToModel
[
id
]
;
}
get
length
(
)
{
return
this
.
_models
.
length
;
}
set
(
id
internalModel
)
{
(
true
&
&
!
(
id
)
&
&
Ember
.
assert
(
You
cannot
index
an
internalModel
by
an
empty
id
'
id
)
)
;
(
true
&
&
!
(
internalModel
instanceof
InternalModel
)
&
&
Ember
.
assert
(
You
cannot
set
an
index
for
an
internalModel
to
something
other
than
an
internalModel
internalModel
instanceof
InternalModel
)
)
;
(
true
&
&
!
(
this
.
contains
(
internalModel
)
)
&
&
Ember
.
assert
(
You
cannot
set
an
index
for
an
internalModel
that
is
not
in
the
InternalModelMap
this
.
contains
(
internalModel
)
)
)
;
(
true
&
&
!
(
!
this
.
has
(
id
)
|
|
this
.
get
(
id
)
=
=
=
internalModel
)
&
&
Ember
.
assert
(
You
cannot
update
the
id
index
of
an
InternalModel
once
set
.
Attempted
to
update
{
id
}
.
!
this
.
has
(
id
)
|
|
this
.
get
(
id
)
=
=
=
internalModel
)
)
;
this
.
_idToModel
[
id
]
=
internalModel
;
}
add
(
internalModel
id
)
{
(
true
&
&
!
(
!
this
.
contains
(
internalModel
)
)
&
&
Ember
.
assert
(
You
cannot
re
-
add
an
already
present
InternalModel
to
the
InternalModelMap
.
!
this
.
contains
(
internalModel
)
)
)
;
if
(
id
)
{
this
.
_idToModel
[
id
]
=
internalModel
;
}
this
.
_models
.
push
(
internalModel
)
;
}
remove
(
internalModel
id
)
{
delete
this
.
_idToModel
[
id
]
;
var
loc
=
this
.
_models
.
indexOf
(
internalModel
)
;
if
(
loc
!
=
=
-
1
)
{
this
.
_models
.
splice
(
loc
1
)
;
}
}
contains
(
internalModel
)
{
return
this
.
_models
.
indexOf
(
internalModel
)
!
=
=
-
1
;
}
get
models
(
)
{
return
this
.
_models
;
}
get
metadata
(
)
{
return
this
.
_metadata
|
|
(
this
.
_metadata
=
Object
.
create
(
null
)
)
;
}
get
type
(
)
{
throw
new
Error
(
'
InternalModelMap
.
type
is
no
longer
available
'
)
;
}
clear
(
)
{
var
models
=
this
.
_models
;
this
.
_models
=
[
]
;
for
(
var
i
=
0
;
i
<
models
.
length
;
i
+
+
)
{
var
model
=
models
[
i
]
;
model
.
unloadRecord
(
)
;
}
this
.
_metadata
=
null
;
}
}
class
IdentityMap
{
constructor
(
)
{
this
.
_map
=
Object
.
create
(
null
)
;
}
retrieve
(
modelName
)
{
var
map
=
this
.
_map
[
modelName
]
;
if
(
map
=
=
=
undefined
)
{
map
=
this
.
_map
[
modelName
]
=
new
InternalModelMap
(
modelName
)
;
}
return
map
;
}
clear
(
)
{
var
map
=
this
.
_map
;
var
keys
=
Object
.
keys
(
map
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
map
[
key
]
.
clear
(
)
;
}
}
}
function
validateDocumentStructure
(
doc
)
{
var
errors
=
[
]
;
if
(
!
doc
|
|
typeof
doc
!
=
=
'
object
'
)
{
errors
.
push
(
'
Top
level
of
a
JSON
API
document
must
be
an
object
'
)
;
}
else
{
if
(
!
(
'
data
'
in
doc
)
&
&
!
(
'
errors
'
in
doc
)
&
&
!
(
'
meta
'
in
doc
)
)
{
errors
.
push
(
'
One
or
more
of
the
following
keys
must
be
present
:
"
data
"
"
errors
"
"
meta
"
.
'
)
;
}
else
{
if
(
'
data
'
in
doc
&
&
'
errors
'
in
doc
)
{
errors
.
push
(
'
Top
level
keys
"
errors
"
and
"
data
"
cannot
both
be
present
in
a
JSON
API
document
'
)
;
}
}
if
(
'
data
'
in
doc
)
{
if
(
!
(
doc
.
data
=
=
=
null
|
|
Array
.
isArray
(
doc
.
data
)
|
|
typeof
doc
.
data
=
=
=
'
object
'
)
)
{
errors
.
push
(
'
data
must
be
null
an
object
or
an
array
'
)
;
}
}
if
(
'
meta
'
in
doc
)
{
if
(
typeof
doc
.
meta
!
=
=
'
object
'
)
{
errors
.
push
(
'
meta
must
be
an
object
'
)
;
}
}
if
(
'
errors
'
in
doc
)
{
if
(
!
Array
.
isArray
(
doc
.
errors
)
)
{
errors
.
push
(
'
errors
must
be
an
array
'
)
;
}
}
if
(
'
links
'
in
doc
)
{
if
(
typeof
doc
.
links
!
=
=
'
object
'
)
{
errors
.
push
(
'
links
must
be
an
object
'
)
;
}
}
if
(
'
jsonapi
'
in
doc
)
{
if
(
typeof
doc
.
jsonapi
!
=
=
'
object
'
)
{
errors
.
push
(
'
jsonapi
must
be
an
object
'
)
;
}
}
if
(
'
included
'
in
doc
)
{
if
(
typeof
doc
.
included
!
=
=
'
object
'
)
{
errors
.
push
(
'
included
must
be
an
array
'
)
;
}
}
}
return
errors
;
}
function
normalizeResponseHelper
(
serializer
store
modelClass
payload
id
requestType
)
{
var
normalizedResponse
=
serializer
.
normalizeResponse
(
store
modelClass
payload
id
requestType
)
;
var
validationErrors
=
[
]
;
{
validationErrors
=
validateDocumentStructure
(
normalizedResponse
)
;
}
(
true
&
&
!
(
Ember
.
isEmpty
(
validationErrors
)
)
&
&
Ember
.
assert
(
normalizeResponse
must
return
a
valid
JSON
API
document
:
\
n
\
t
*
{
validationErrors
.
join
(
'
\
n
\
t
*
'
)
}
Ember
.
isEmpty
(
validationErrors
)
)
)
;
return
normalizedResponse
;
}
function
serializerForAdapter
(
store
adapter
modelName
)
{
var
serializer
=
adapter
.
serializer
;
if
(
serializer
=
=
=
undefined
)
{
serializer
=
store
.
serializerFor
(
modelName
)
;
}
if
(
serializer
=
=
=
null
|
|
serializer
=
=
=
undefined
)
{
serializer
=
{
extract
(
store
type
payload
)
{
return
payload
;
}
}
;
}
return
serializer
;
}
class
TypeCache
{
constructor
(
)
{
this
.
types
=
Object
.
create
(
null
)
;
}
get
(
modelName
id
)
{
var
{
types
}
=
this
;
if
(
types
[
modelName
]
!
=
=
undefined
)
{
return
types
[
modelName
]
[
id
]
;
}
}
set
(
modelName
id
payload
)
{
var
{
types
}
=
this
;
var
typeMap
=
types
[
modelName
]
;
if
(
typeMap
=
=
=
undefined
)
{
typeMap
=
types
[
modelName
]
=
Object
.
create
(
null
)
;
}
typeMap
[
id
]
=
payload
;
}
delete
(
modelName
id
)
{
var
{
types
}
=
this
;
if
(
types
[
modelName
]
!
=
=
undefined
)
{
delete
types
[
modelName
]
[
id
]
;
}
}
}
class
RelationshipPayloads
{
constructor
(
relInfo
)
{
this
.
_relInfo
=
relInfo
;
this
.
lhs_payloads
=
new
TypeCache
(
)
;
this
.
rhs_payloads
=
relInfo
.
isReflexive
?
this
.
lhs_payloads
:
new
TypeCache
(
)
;
this
.
_pendingPayloads
=
[
]
;
}
get
(
modelName
id
relationshipName
)
{
this
.
_flushPending
(
)
;
if
(
this
.
_isLHS
(
modelName
relationshipName
)
)
{
return
this
.
lhs_payloads
.
get
(
modelName
id
)
;
}
else
{
(
true
&
&
!
(
this
.
_isRHS
(
modelName
relationshipName
)
)
&
&
Ember
.
assert
(
{
modelName
}
:
{
relationshipName
}
is
not
either
side
of
this
relationship
{
this
.
_relInfo
.
lhs_key
}
<
-
>
{
this
.
_relInfo
.
rhs_key
}
this
.
_isRHS
(
modelName
relationshipName
)
)
)
;
return
this
.
rhs_payloads
.
get
(
modelName
id
)
;
}
}
push
(
modelName
id
relationshipName
relationshipData
)
{
this
.
_pendingPayloads
.
push
(
[
modelName
id
relationshipName
relationshipData
]
)
;
}
unload
(
modelName
id
relationshipName
)
{
this
.
_flushPending
(
)
;
if
(
this
.
_isLHS
(
modelName
relationshipName
)
)
{
delete
this
.
lhs_payloads
.
delete
(
modelName
id
)
;
}
else
{
(
true
&
&
!
(
this
.
_isRHS
(
modelName
relationshipName
)
)
&
&
Ember
.
assert
(
{
modelName
}
:
{
relationshipName
}
is
not
either
side
of
this
relationship
{
this
.
_relInfo
.
lhs_baseModelName
}
:
{
this
.
_relInfo
.
lhs_relationshipName
}
<
-
>
{
this
.
_relInfo
.
rhs_baseModelName
}
:
{
this
.
_relInfo
.
rhs_relationshipName
}
this
.
_isRHS
(
modelName
relationshipName
)
)
)
;
delete
this
.
rhs_payloads
.
delete
(
modelName
id
)
;
}
}
_isLHS
(
modelName
relationshipName
)
{
var
relInfo
=
this
.
_relInfo
;
var
isSelfReferential
=
relInfo
.
isSelfReferential
;
var
isRelationship
=
relationshipName
=
=
=
relInfo
.
lhs_relationshipName
;
if
(
isRelationship
=
=
=
true
)
{
return
isSelfReferential
=
=
=
true
|
|
modelName
=
=
=
relInfo
.
lhs_baseModelName
|
|
relInfo
.
lhs_modelNames
.
indexOf
(
modelName
)
!
=
=
-
1
;
}
return
false
;
}
_isRHS
(
modelName
relationshipName
)
{
var
relInfo
=
this
.
_relInfo
;
var
isSelfReferential
=
relInfo
.
isSelfReferential
;
var
isRelationship
=
relationshipName
=
=
=
relInfo
.
rhs_relationshipName
;
if
(
isRelationship
=
=
=
true
)
{
return
isSelfReferential
=
=
=
true
|
|
modelName
=
=
=
relInfo
.
rhs_baseModelName
|
|
relInfo
.
rhs_modelNames
.
indexOf
(
modelName
)
!
=
=
-
1
;
}
return
false
;
}
_flushPending
(
)
{
if
(
this
.
_pendingPayloads
.
length
=
=
=
0
)
{
return
;
}
var
payloadsToBeProcessed
=
this
.
_pendingPayloads
.
splice
(
0
this
.
_pendingPayloads
.
length
)
;
for
(
var
i
=
0
;
i
<
payloadsToBeProcessed
.
length
;
+
+
i
)
{
var
modelName
=
payloadsToBeProcessed
[
i
]
[
0
]
;
var
id
=
payloadsToBeProcessed
[
i
]
[
1
]
;
var
relationshipName
=
payloadsToBeProcessed
[
i
]
[
2
]
;
var
relationshipData
=
payloadsToBeProcessed
[
i
]
[
3
]
;
var
inverseRelationshipData
=
{
data
:
{
id
:
id
type
:
modelName
}
}
;
var
previousPayload
=
void
0
;
var
payloadMap
=
void
0
;
var
inversePayloadMap
=
void
0
;
var
inverseIsMany
=
void
0
;
if
(
this
.
_isLHS
(
modelName
relationshipName
)
)
{
previousPayload
=
this
.
lhs_payloads
.
get
(
modelName
id
)
;
payloadMap
=
this
.
lhs_payloads
;
inversePayloadMap
=
this
.
rhs_payloads
;
inverseIsMany
=
this
.
_rhsRelationshipIsMany
;
}
else
{
(
true
&
&
!
(
this
.
_isRHS
(
modelName
relationshipName
)
)
&
&
Ember
.
assert
(
{
modelName
}
:
{
relationshipName
}
is
not
either
side
of
this
relationship
{
this
.
_relInfo
.
lhs_key
}
<
-
>
{
this
.
_relInfo
.
rhs_key
}
this
.
_isRHS
(
modelName
relationshipName
)
)
)
;
previousPayload
=
this
.
rhs_payloads
.
get
(
modelName
id
)
;
payloadMap
=
this
.
rhs_payloads
;
inversePayloadMap
=
this
.
lhs_payloads
;
inverseIsMany
=
this
.
_lhsRelationshipIsMany
;
}
if
(
relationshipData
.
data
!
=
=
undefined
)
{
this
.
_removeInverse
(
id
previousPayload
inversePayloadMap
)
;
}
payloadMap
.
set
(
modelName
id
relationshipData
)
;
this
.
_populateInverse
(
relationshipData
inverseRelationshipData
inversePayloadMap
inverseIsMany
)
;
}
}
_populateInverse
(
relationshipData
inversePayload
inversePayloadMap
inverseIsMany
)
{
if
(
!
relationshipData
.
data
)
{
return
;
}
if
(
Array
.
isArray
(
relationshipData
.
data
)
)
{
for
(
var
i
=
0
;
i
<
relationshipData
.
data
.
length
;
+
+
i
)
{
var
resourceIdentifier
=
relationshipData
.
data
[
i
]
;
this
.
_addToInverse
(
inversePayload
resourceIdentifier
inversePayloadMap
inverseIsMany
)
;
}
}
else
{
var
_resourceIdentifier
=
relationshipData
.
data
;
this
.
_addToInverse
(
inversePayload
_resourceIdentifier
inversePayloadMap
inverseIsMany
)
;
}
}
_addToInverse
(
inversePayload
resourceIdentifier
inversePayloadMap
inverseIsMany
)
{
var
relInfo
=
this
.
_relInfo
;
if
(
relInfo
.
isReflexive
&
&
inversePayload
.
data
.
id
=
=
=
resourceIdentifier
.
id
)
{
return
;
}
var
existingPayload
=
inversePayloadMap
.
get
(
resourceIdentifier
.
type
resourceIdentifier
.
id
)
;
var
existingData
=
existingPayload
&
&
existingPayload
.
data
;
if
(
existingData
)
{
if
(
Array
.
isArray
(
existingData
)
)
{
existingData
.
push
(
inversePayload
.
data
)
;
}
else
{
inversePayloadMap
.
set
(
resourceIdentifier
.
type
resourceIdentifier
.
id
inversePayload
)
;
}
}
else
{
if
(
inverseIsMany
)
{
inversePayloadMap
.
set
(
resourceIdentifier
.
type
resourceIdentifier
.
id
{
data
:
[
inversePayload
.
data
]
}
)
;
}
else
{
inversePayloadMap
.
set
(
resourceIdentifier
.
type
resourceIdentifier
.
id
inversePayload
)
;
}
}
}
get
_lhsRelationshipIsMany
(
)
{
var
meta
=
this
.
_relInfo
.
lhs_relationshipMeta
;
return
meta
!
=
=
null
&
&
meta
.
kind
=
=
=
'
hasMany
'
;
}
get
_rhsRelationshipIsMany
(
)
{
var
meta
=
this
.
_relInfo
.
rhs_relationshipMeta
;
return
meta
!
=
=
null
&
&
meta
.
kind
=
=
=
'
hasMany
'
;
}
_removeInverse
(
id
previousPayload
inversePayloadMap
)
{
var
data
=
previousPayload
&
&
previousPayload
.
data
;
if
(
!
data
)
{
return
;
}
if
(
Array
.
isArray
(
data
)
)
{
for
(
var
i
=
0
;
i
<
data
.
length
;
+
+
i
)
{
var
resourceIdentifier
=
data
[
i
]
;
this
.
_removeFromInverse
(
id
resourceIdentifier
inversePayloadMap
)
;
}
}
else
{
this
.
_removeFromInverse
(
id
data
inversePayloadMap
)
;
}
}
_removeFromInverse
(
id
resourceIdentifier
inversePayloads
)
{
var
inversePayload
=
inversePayloads
.
get
(
resourceIdentifier
.
type
resourceIdentifier
.
id
)
;
var
data
=
inversePayload
&
&
inversePayload
.
data
;
if
(
!
data
)
{
return
;
}
if
(
Array
.
isArray
(
data
)
)
{
inversePayload
.
data
=
data
.
filter
(
x
=
>
x
.
id
!
=
=
id
)
;
}
else
{
inversePayloads
.
set
(
resourceIdentifier
.
type
resourceIdentifier
.
id
{
data
:
null
}
)
;
}
}
}
class
RelationshipPayloadsManager
{
constructor
(
store
)
{
this
.
_store
=
store
;
this
.
_cache
=
Object
.
create
(
null
)
;
this
.
_inverseLookupCache
=
new
TypeCache
(
)
;
}
get
(
modelName
id
relationshipName
)
{
var
relationshipPayloads
=
this
.
_getRelationshipPayloads
(
modelName
relationshipName
false
)
;
return
relationshipPayloads
&
&
relationshipPayloads
.
get
(
modelName
id
relationshipName
)
;
}
push
(
modelName
id
relationshipsData
)
{
if
(
!
relationshipsData
)
{
return
;
}
Object
.
keys
(
relationshipsData
)
.
forEach
(
key
=
>
{
var
relationshipPayloads
=
this
.
_getRelationshipPayloads
(
modelName
key
true
)
;
if
(
relationshipPayloads
)
{
relationshipPayloads
.
push
(
modelName
id
key
relationshipsData
[
key
]
)
;
}
}
)
;
}
unload
(
modelName
id
)
{
var
modelClass
=
this
.
_store
.
_modelFor
(
modelName
)
;
var
relationshipsByName
=
Ember
.
get
(
modelClass
'
relationshipsByName
'
)
;
relationshipsByName
.
forEach
(
(
_
relationshipName
)
=
>
{
var
relationshipPayloads
=
this
.
_getRelationshipPayloads
(
modelName
relationshipName
false
)
;
if
(
relationshipPayloads
)
{
relationshipPayloads
.
unload
(
modelName
id
relationshipName
)
;
}
}
)
;
}
_getRelationshipPayloads
(
modelName
relationshipName
init
)
{
var
relInfo
=
this
.
getRelationshipInfo
(
modelName
relationshipName
)
;
if
(
relInfo
=
=
=
null
)
{
return
;
}
var
cache
=
this
.
_cache
[
relInfo
.
lhs_key
]
;
if
(
!
cache
&
&
init
)
{
return
this
.
_initializeRelationshipPayloads
(
relInfo
)
;
}
return
cache
;
}
getRelationshipInfo
(
modelName
relationshipName
)
{
var
inverseCache
=
this
.
_inverseLookupCache
;
var
store
=
this
.
_store
;
var
cached
=
inverseCache
.
get
(
modelName
relationshipName
)
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
var
modelClass
=
store
.
_modelFor
(
modelName
)
;
var
relationshipsByName
=
Ember
.
get
(
modelClass
'
relationshipsByName
'
)
;
if
(
!
relationshipsByName
.
has
(
relationshipName
)
)
{
inverseCache
.
set
(
modelName
relationshipName
null
)
;
return
null
;
}
var
inverseMeta
=
modelClass
.
inverseFor
(
relationshipName
store
)
;
var
relationshipMeta
=
relationshipsByName
.
get
(
relationshipName
)
;
var
selfIsPolymorphic
=
relationshipMeta
.
options
!
=
=
undefined
&
&
relationshipMeta
.
options
.
polymorphic
=
=
=
true
;
var
inverseBaseModelName
=
relationshipMeta
.
type
;
if
(
!
inverseMeta
)
{
var
_info
=
{
lhs_key
:
{
modelName
}
:
{
relationshipName
}
lhs_modelNames
:
[
modelName
]
lhs_baseModelName
:
modelName
lhs_relationshipName
:
relationshipName
lhs_relationshipMeta
:
relationshipMeta
lhs_isPolymorphic
:
selfIsPolymorphic
rhs_key
:
'
'
rhs_modelNames
:
[
]
rhs_baseModelName
:
inverseBaseModelName
rhs_relationshipName
:
'
'
rhs_relationshipMeta
:
null
rhs_isPolymorphic
:
false
hasInverse
:
false
isSelfReferential
:
false
isReflexive
:
false
}
;
inverseCache
.
set
(
modelName
relationshipName
_info
)
;
return
_info
;
}
var
inverseRelationshipName
=
inverseMeta
.
name
;
var
inverseRelationshipMeta
=
Ember
.
get
(
inverseMeta
.
type
'
relationshipsByName
'
)
.
get
(
inverseRelationshipName
)
;
var
baseModelName
=
inverseRelationshipMeta
.
type
;
var
isSelfReferential
=
baseModelName
=
=
=
inverseBaseModelName
;
cached
=
inverseCache
.
get
(
baseModelName
relationshipName
)
|
|
inverseCache
.
get
(
inverseBaseModelName
inverseRelationshipName
)
;
if
(
cached
)
{
(
true
&
&
!
(
cached
.
hasInverse
!
=
=
false
)
&
&
Ember
.
assert
(
The
{
inverseBaseModelName
}
:
{
inverseRelationshipName
}
relationship
declares
'
inverse
:
null
'
but
it
was
resolved
as
the
inverse
for
{
baseModelName
}
:
{
relationshipName
}
.
cached
.
hasInverse
!
=
=
false
)
)
;
var
isLHS
=
cached
.
lhs_baseModelName
=
=
=
baseModelName
;
var
modelNames
=
isLHS
?
cached
.
lhs_modelNames
:
cached
.
rhs_modelNames
;
modelNames
.
push
(
modelName
)
;
inverseCache
.
set
(
modelName
relationshipName
cached
)
;
return
cached
;
}
var
info
=
{
lhs_key
:
{
baseModelName
}
:
{
relationshipName
}
lhs_modelNames
:
[
modelName
]
lhs_baseModelName
:
baseModelName
lhs_relationshipName
:
relationshipName
lhs_relationshipMeta
:
relationshipMeta
lhs_isPolymorphic
:
selfIsPolymorphic
rhs_key
:
{
inverseBaseModelName
}
:
{
inverseRelationshipName
}
rhs_modelNames
:
[
]
rhs_baseModelName
:
inverseBaseModelName
rhs_relationshipName
:
inverseRelationshipName
rhs_relationshipMeta
:
inverseRelationshipMeta
rhs_isPolymorphic
:
inverseRelationshipMeta
.
options
!
=
=
undefined
&
&
inverseRelationshipMeta
.
options
.
polymorphic
=
=
=
true
hasInverse
:
true
isSelfReferential
isReflexive
:
isSelfReferential
&
&
relationshipName
=
=
=
inverseRelationshipName
}
;
inverseCache
.
set
(
baseModelName
relationshipName
info
)
;
inverseCache
.
set
(
modelName
relationshipName
info
)
;
inverseCache
.
set
(
inverseBaseModelName
inverseRelationshipName
info
)
;
return
info
;
}
_initializeRelationshipPayloads
(
relInfo
)
{
var
lhsKey
=
relInfo
.
lhs_key
;
var
rhsKey
=
relInfo
.
rhs_key
;
var
existingPayloads
=
this
.
_cache
[
lhsKey
]
;
if
(
relInfo
.
hasInverse
=
=
=
true
&
&
relInfo
.
rhs_isPolymorphic
=
=
=
true
)
{
existingPayloads
=
this
.
_cache
[
rhsKey
]
;
if
(
existingPayloads
!
=
=
undefined
)
{
this
.
_cache
[
lhsKey
]
=
existingPayloads
;
return
existingPayloads
;
}
}
var
cache
=
this
.
_cache
[
lhsKey
]
=
new
RelationshipPayloads
(
relInfo
)
;
if
(
relInfo
.
hasInverse
=
=
=
true
)
{
this
.
_cache
[
rhsKey
]
=
cache
;
}
return
cache
;
}
}
function
payloadIsNotBlank
(
adapterPayload
)
{
if
(
Array
.
isArray
(
adapterPayload
)
)
{
return
true
;
}
else
{
return
Object
.
keys
(
adapterPayload
|
|
{
}
)
.
length
;
}
}
function
_find
(
adapter
store
modelClass
id
internalModel
options
)
{
var
snapshot
=
internalModel
.
createSnapshot
(
options
)
;
var
{
modelName
}
=
internalModel
;
var
promise
=
adapter
.
findRecord
(
store
modelClass
id
snapshot
)
;
var
label
=
DS
:
Handle
Adapter
#
findRecord
of
'
{
modelName
}
'
with
id
:
'
{
id
}
'
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
(
true
&
&
!
(
payloadIsNotBlank
(
adapterPayload
)
)
&
&
Ember
.
assert
(
You
made
a
'
findRecord
'
request
for
a
'
{
modelName
}
'
with
id
'
{
id
}
'
but
the
adapter
'
s
response
did
not
have
any
data
payloadIsNotBlank
(
adapterPayload
)
)
)
;
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
id
'
findRecord
'
)
;
(
true
&
&
!
(
!
Array
.
isArray
(
payload
.
data
)
)
&
&
Ember
.
assert
(
Ember
Data
expected
the
primary
data
returned
from
a
'
findRecord
'
response
to
be
an
object
but
instead
it
found
an
array
.
!
Array
.
isArray
(
payload
.
data
)
)
)
;
(
true
&
&
Ember
.
warn
(
You
requested
a
record
of
type
'
{
modelName
}
'
with
id
'
{
id
}
'
but
the
adapter
returned
a
payload
with
primary
data
having
an
id
of
'
{
payload
.
data
.
id
}
'
.
Use
'
store
.
findRecord
(
)
'
when
the
requested
id
is
the
same
as
the
one
returned
by
the
adapter
.
In
other
cases
use
'
store
.
queryRecord
(
)
'
instead
https
:
/
/
emberjs
.
com
/
api
/
data
/
classes
/
DS
.
Store
.
html
#
method_queryRecord
payload
.
data
.
id
=
=
=
id
{
id
:
'
ds
.
store
.
findRecord
.
id
-
mismatch
'
}
)
)
;
return
store
.
_push
(
payload
)
;
}
error
=
>
{
internalModel
.
notFound
(
)
;
if
(
internalModel
.
isEmpty
(
)
)
{
internalModel
.
unloadRecord
(
)
;
}
throw
error
;
}
DS
:
Extract
payload
of
'
{
modelName
}
'
)
;
}
function
_findMany
(
adapter
store
modelName
ids
internalModels
)
{
var
snapshots
=
Ember
.
A
(
internalModels
)
.
invoke
(
'
createSnapshot
'
)
;
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
promise
=
adapter
.
findMany
(
store
modelClass
ids
snapshots
)
;
var
label
=
DS
:
Handle
Adapter
#
findMany
of
'
{
modelName
}
'
;
if
(
promise
=
=
=
undefined
)
{
throw
new
Error
(
'
adapter
.
findMany
returned
undefined
this
was
very
likely
a
mistake
'
)
;
}
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
(
true
&
&
!
(
payloadIsNotBlank
(
adapterPayload
)
)
&
&
Ember
.
assert
(
You
made
a
'
findMany
'
request
for
'
{
modelName
}
'
records
with
ids
'
[
{
ids
}
]
'
but
the
adapter
'
s
response
did
not
have
any
data
payloadIsNotBlank
(
adapterPayload
)
)
)
;
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
findMany
'
)
;
return
store
.
_push
(
payload
)
;
}
null
DS
:
Extract
payload
of
{
modelName
}
)
;
}
function
_findHasMany
(
adapter
store
internalModel
link
relationship
)
{
var
snapshot
=
internalModel
.
createSnapshot
(
)
;
var
modelClass
=
store
.
modelFor
(
relationship
.
type
)
;
var
promise
=
adapter
.
findHasMany
(
store
snapshot
link
relationship
)
;
var
label
=
DS
:
Handle
Adapter
#
findHasMany
of
'
{
internalModel
.
modelName
}
'
:
'
{
relationship
.
type
}
'
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
internalModel
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
(
true
&
&
!
(
payloadIsNotBlank
(
adapterPayload
)
)
&
&
Ember
.
assert
(
You
made
a
'
findHasMany
'
request
for
a
{
internalModel
.
modelName
}
'
s
'
{
relationship
.
key
}
'
relationship
using
link
'
{
link
}
'
but
the
adapter
'
s
response
did
not
have
any
data
payloadIsNotBlank
(
adapterPayload
)
)
)
;
var
serializer
=
serializerForAdapter
(
store
adapter
relationship
.
type
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
findHasMany
'
)
;
var
internalModelArray
=
store
.
_push
(
payload
)
;
internalModelArray
.
meta
=
payload
.
meta
;
return
internalModelArray
;
}
null
DS
:
Extract
payload
of
'
{
internalModel
.
modelName
}
'
:
hasMany
'
{
relationship
.
type
}
'
)
;
}
function
_findBelongsTo
(
adapter
store
internalModel
link
relationship
)
{
var
snapshot
=
internalModel
.
createSnapshot
(
)
;
var
modelClass
=
store
.
modelFor
(
relationship
.
type
)
;
var
promise
=
adapter
.
findBelongsTo
(
store
snapshot
link
relationship
)
;
var
label
=
DS
:
Handle
Adapter
#
findBelongsTo
of
{
internalModel
.
modelName
}
:
{
relationship
.
type
}
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
internalModel
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
var
serializer
=
serializerForAdapter
(
store
adapter
relationship
.
type
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
findBelongsTo
'
)
;
if
(
!
payload
.
data
)
{
return
null
;
}
return
store
.
_push
(
payload
)
;
}
null
DS
:
Extract
payload
of
{
internalModel
.
modelName
}
:
{
relationship
.
type
}
)
;
}
function
_findAll
(
adapter
store
modelName
sinceToken
options
)
{
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
recordArray
=
store
.
peekAll
(
modelName
)
;
var
snapshotArray
=
recordArray
.
_createSnapshot
(
options
)
;
var
promise
=
adapter
.
findAll
(
store
modelClass
sinceToken
snapshotArray
)
;
var
label
=
"
DS
:
Handle
Adapter
#
findAll
of
"
+
modelClass
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
(
true
&
&
!
(
payloadIsNotBlank
(
adapterPayload
)
)
&
&
Ember
.
assert
(
You
made
a
'
findAll
'
request
for
'
{
modelName
}
'
records
but
the
adapter
'
s
response
did
not
have
any
data
payloadIsNotBlank
(
adapterPayload
)
)
)
;
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
findAll
'
)
;
store
.
_push
(
payload
)
;
store
.
_didUpdateAll
(
modelName
)
;
return
recordArray
;
}
null
'
DS
:
Extract
payload
of
findAll
{
modelName
}
'
)
;
}
function
_query
(
adapter
store
modelName
query
recordArray
)
{
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
promise
=
void
0
;
if
(
adapter
.
query
.
length
>
3
)
{
recordArray
=
recordArray
|
|
store
.
recordArrayManager
.
createAdapterPopulatedRecordArray
(
modelName
query
)
;
promise
=
adapter
.
query
(
store
modelClass
query
recordArray
)
;
}
else
{
promise
=
adapter
.
query
(
store
modelClass
query
)
;
}
var
label
=
DS
:
Handle
Adapter
#
query
of
{
modelClass
}
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
query
'
)
;
var
internalModels
=
store
.
_push
(
payload
)
;
(
true
&
&
!
(
Array
.
isArray
(
internalModels
)
)
&
&
Ember
.
assert
(
'
The
response
to
store
.
query
is
expected
to
be
an
array
but
it
was
a
single
record
.
Please
wrap
your
response
in
an
array
or
use
store
.
queryRecord
to
query
for
a
single
record
.
'
Array
.
isArray
(
internalModels
)
)
)
;
if
(
recordArray
)
{
recordArray
.
_setInternalModels
(
internalModels
payload
)
;
}
else
{
recordArray
=
store
.
recordArrayManager
.
createAdapterPopulatedRecordArray
(
modelName
query
internalModels
payload
)
;
}
return
recordArray
;
}
null
DS
:
Extract
payload
of
query
{
modelName
}
)
;
}
function
_queryRecord
(
adapter
store
modelName
query
)
{
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
promise
=
adapter
.
queryRecord
(
store
modelClass
query
)
;
var
label
=
DS
:
Handle
Adapter
#
queryRecord
of
{
modelName
}
;
promise
=
Ember
.
RSVP
.
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
null
'
queryRecord
'
)
;
(
true
&
&
!
(
!
Array
.
isArray
(
payload
.
data
)
)
&
&
Ember
.
assert
(
Expected
the
primary
data
returned
by
the
serializer
for
a
'
queryRecord
'
response
to
be
a
single
object
or
null
but
instead
it
was
an
array
.
!
Array
.
isArray
(
payload
.
data
)
{
id
:
'
ds
.
store
.
queryRecord
-
array
-
response
'
}
)
)
;
return
store
.
_push
(
payload
)
;
}
null
DS
:
Extract
payload
of
queryRecord
{
modelName
}
)
;
}
function
coerceId
(
id
)
{
if
(
id
=
=
=
null
|
|
id
=
=
=
undefined
|
|
id
=
=
=
'
'
)
{
return
null
;
}
if
(
typeof
id
=
=
=
'
string
'
)
{
return
id
;
}
return
'
'
+
id
;
}
class
SnapshotRecordArray
{
constructor
(
recordArray
meta
options
=
{
}
)
{
this
.
_snapshots
=
null
;
this
.
_recordArray
=
recordArray
;
this
.
length
=
recordArray
.
get
(
'
length
'
)
;
this
.
_type
=
null
;
this
.
meta
=
meta
;
this
.
adapterOptions
=
options
.
adapterOptions
;
this
.
include
=
options
.
include
;
}
get
type
(
)
{
return
this
.
_type
|
|
(
this
.
_type
=
this
.
_recordArray
.
get
(
'
type
'
)
)
;
}
snapshots
(
)
{
if
(
this
.
_snapshots
!
=
=
null
)
{
return
this
.
_snapshots
;
}
this
.
_snapshots
=
this
.
_recordArray
.
_takeSnapshot
(
)
;
return
this
.
_snapshots
;
}
}
var
RecordArray
=
Ember
.
ArrayProxy
.
extend
(
Ember
.
Evented
{
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
this
.
set
(
'
content
'
this
.
content
|
|
null
)
;
this
.
isLoaded
=
this
.
isLoaded
|
|
false
;
this
.
isUpdating
=
false
;
this
.
store
=
this
.
store
|
|
null
;
this
.
_updatingPromise
=
null
;
}
replace
(
)
{
throw
new
Error
(
The
result
of
a
server
query
(
for
all
{
this
.
modelName
}
types
)
is
immutable
.
To
modify
contents
use
toArray
(
)
)
;
}
type
:
Ember
.
computed
(
'
modelName
'
function
(
)
{
if
(
!
this
.
modelName
)
{
return
null
;
}
return
this
.
store
.
_modelFor
(
this
.
modelName
)
;
}
)
.
readOnly
(
)
objectAtContent
(
index
)
{
var
internalModel
=
Ember
.
get
(
this
'
content
'
)
.
objectAt
(
index
)
;
return
internalModel
&
&
internalModel
.
getRecord
(
)
;
}
update
(
)
{
if
(
Ember
.
get
(
this
'
isUpdating
'
)
)
{
return
this
.
_updatingPromise
;
}
this
.
set
(
'
isUpdating
'
true
)
;
var
updatingPromise
=
this
.
_update
(
)
.
finally
(
(
)
=
>
{
this
.
_updatingPromise
=
null
;
if
(
this
.
get
(
'
isDestroying
'
)
|
|
this
.
get
(
'
isDestroyed
'
)
)
{
return
;
}
this
.
set
(
'
isUpdating
'
false
)
;
}
)
;
this
.
_updatingPromise
=
updatingPromise
;
return
updatingPromise
;
}
_update
(
)
{
return
this
.
store
.
findAll
(
this
.
modelName
{
reload
:
true
}
)
;
}
_pushInternalModels
(
internalModels
)
{
Ember
.
get
(
this
'
content
'
)
.
pushObjects
(
internalModels
)
;
}
_removeInternalModels
(
internalModels
)
{
Ember
.
get
(
this
'
content
'
)
.
removeObjects
(
internalModels
)
;
}
save
(
)
{
var
promiseLabel
=
DS
:
RecordArray
#
save
{
this
.
modelName
}
;
var
promise
=
Ember
.
RSVP
.
Promise
.
all
(
this
.
invoke
(
'
save
'
)
promiseLabel
)
.
then
(
(
)
=
>
this
null
'
DS
:
RecordArray
#
save
return
RecordArray
'
)
;
return
PromiseArray
.
create
(
{
promise
}
)
;
}
_dissociateFromOwnRecords
(
)
{
this
.
get
(
'
content
'
)
.
forEach
(
internalModel
=
>
{
var
recordArrays
=
internalModel
.
__recordArrays
;
if
(
recordArrays
)
{
recordArrays
.
delete
(
this
)
;
}
}
)
;
}
_unregisterFromManager
(
)
{
this
.
manager
.
unregisterRecordArray
(
this
)
;
}
willDestroy
(
)
{
this
.
_unregisterFromManager
(
)
;
this
.
_dissociateFromOwnRecords
(
)
;
Ember
.
set
(
this
'
content
'
null
)
;
Ember
.
set
(
this
'
length
'
0
)
;
this
.
_super
(
.
.
.
arguments
)
;
}
_createSnapshot
(
options
)
{
return
new
SnapshotRecordArray
(
this
this
.
get
(
'
meta
'
)
options
)
;
}
_takeSnapshot
(
)
{
return
Ember
.
get
(
this
'
content
'
)
.
map
(
internalModel
=
>
internalModel
.
createSnapshot
(
)
)
;
}
}
)
;
var
FilteredRecordArray
=
RecordArray
.
extend
(
{
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
this
.
set
(
'
filterFunction
'
this
.
get
(
'
filterFunction
'
)
|
|
null
)
;
this
.
isLoaded
=
true
;
}
replace
(
)
{
throw
new
Error
(
The
result
of
a
client
-
side
filter
(
on
{
this
.
modelName
}
)
is
immutable
.
)
;
}
_updateFilter
(
)
{
if
(
Ember
.
get
(
this
'
isDestroying
'
)
|
|
Ember
.
get
(
this
'
isDestroyed
'
)
)
{
return
;
}
Ember
.
get
(
this
'
manager
'
)
.
updateFilter
(
this
this
.
modelName
Ember
.
get
(
this
'
filterFunction
'
)
)
;
}
updateFilter
:
Ember
.
observer
(
'
filterFunction
'
function
(
)
{
Ember
.
run
.
once
(
this
this
.
_updateFilter
)
;
}
)
}
)
;
function
cloneNull
(
source
)
{
var
clone
=
Object
.
create
(
null
)
;
for
(
var
key
in
source
)
{
clone
[
key
]
=
source
[
key
]
;
}
return
clone
;
}
var
AdapterPopulatedRecordArray
=
RecordArray
.
extend
(
{
init
(
)
{
this
.
set
(
'
content
'
this
.
get
(
'
content
'
)
|
|
Ember
.
A
(
)
)
;
this
.
_super
(
.
.
.
arguments
)
;
this
.
query
=
this
.
query
|
|
null
;
this
.
links
=
this
.
links
|
|
null
;
}
replace
(
)
{
throw
new
Error
(
The
result
of
a
server
query
(
on
{
this
.
modelName
}
)
is
immutable
.
)
;
}
_update
(
)
{
var
store
=
Ember
.
get
(
this
'
store
'
)
;
var
query
=
Ember
.
get
(
this
'
query
'
)
;
return
store
.
_query
(
this
.
modelName
query
this
)
;
}
_setInternalModels
(
internalModels
payload
)
{
this
.
get
(
'
content
'
)
.
setObjects
(
internalModels
)
;
this
.
setProperties
(
{
isLoaded
:
true
isUpdating
:
false
meta
:
cloneNull
(
payload
.
meta
)
links
:
cloneNull
(
payload
.
links
)
}
)
;
associateWithRecordArray
(
internalModels
this
)
;
Ember
.
run
.
once
(
this
'
trigger
'
'
didLoad
'
)
;
}
}
)
;
class
RecordArrayManager
{
constructor
(
options
)
{
this
.
store
=
options
.
store
;
this
.
isDestroying
=
false
;
this
.
isDestroyed
=
false
;
this
.
_filteredRecordArrays
=
Object
.
create
(
null
)
;
this
.
_liveRecordArrays
=
Object
.
create
(
null
)
;
this
.
_pending
=
Object
.
create
(
null
)
;
this
.
_adapterPopulatedRecordArrays
=
[
]
;
}
recordDidChange
(
internalModel
)
{
this
.
internalModelDidChange
(
internalModel
)
;
}
recordWasLoaded
(
internalModel
)
{
this
.
internalModelDidChange
(
internalModel
)
;
}
internalModelDidChange
(
internalModel
)
{
var
modelName
=
internalModel
.
modelName
;
if
(
internalModel
.
_pendingRecordArrayManagerFlush
)
{
return
;
}
internalModel
.
_pendingRecordArrayManagerFlush
=
true
;
var
pending
=
this
.
_pending
;
var
models
=
pending
[
modelName
]
=
pending
[
modelName
]
|
|
[
]
;
if
(
models
.
push
(
internalModel
)
!
=
=
1
)
{
return
;
}
Ember
.
run
.
schedule
(
'
actions
'
this
this
.
_flush
)
;
}
_flush
(
)
{
var
pending
=
this
.
_pending
;
this
.
_pending
=
Object
.
create
(
null
)
;
var
modelsToRemove
=
[
]
;
for
(
var
modelName
in
pending
)
{
var
internalModels
=
pending
[
modelName
]
;
for
(
var
j
=
0
;
j
<
internalModels
.
length
;
j
+
+
)
{
var
internalModel
=
internalModels
[
j
]
;
internalModel
.
_pendingRecordArrayManagerFlush
=
false
;
if
(
internalModel
.
isHiddenFromRecordArrays
(
)
)
{
modelsToRemove
.
push
(
internalModel
)
;
}
}
if
(
this
.
_filteredRecordArrays
[
modelName
]
)
{
var
recordArrays
=
this
.
filteredRecordArraysFor
(
modelName
)
;
for
(
var
i
=
0
;
i
<
recordArrays
.
length
;
i
+
+
)
{
this
.
updateFilterRecordArray
(
recordArrays
[
i
]
modelName
internalModels
)
;
}
}
var
array
=
this
.
_liveRecordArrays
[
modelName
]
;
if
(
array
)
{
this
.
updateLiveRecordArray
(
array
internalModels
)
;
}
if
(
modelsToRemove
.
length
>
0
)
{
removeFromAdapterPopulatedRecordArrays
(
modelsToRemove
)
;
}
}
}
updateLiveRecordArray
(
array
internalModels
)
{
return
updateLiveRecordArray
(
array
internalModels
)
;
}
updateFilterRecordArray
(
array
modelName
internalModels
)
{
var
filter
=
Ember
.
get
(
array
'
filterFunction
'
)
;
var
shouldBeInAdded
=
[
]
;
var
shouldBeRemoved
=
[
]
;
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
if
(
internalModel
.
isHiddenFromRecordArrays
(
)
=
=
=
false
&
&
filter
(
internalModel
.
getRecord
(
)
)
)
{
if
(
internalModel
.
_recordArrays
.
has
(
array
)
)
{
continue
;
}
shouldBeInAdded
.
push
(
internalModel
)
;
internalModel
.
_recordArrays
.
add
(
array
)
;
}
else
{
if
(
internalModel
.
_recordArrays
.
delete
(
array
)
)
{
shouldBeRemoved
.
push
(
internalModel
)
;
}
}
}
if
(
shouldBeInAdded
.
length
>
0
)
{
array
.
_pushInternalModels
(
shouldBeInAdded
)
;
}
if
(
shouldBeRemoved
.
length
>
0
)
{
array
.
_removeInternalModels
(
shouldBeRemoved
)
;
}
}
_syncLiveRecordArray
(
array
modelName
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
syncLiveRecordArray
expects
modelName
not
modelClass
as
the
second
param
typeof
modelName
=
=
=
'
string
'
)
)
;
var
hasNoPotentialDeletions
=
Object
.
keys
(
this
.
_pending
)
.
length
=
=
=
0
;
var
map
=
this
.
store
.
_internalModelsFor
(
modelName
)
;
var
hasNoInsertionsOrRemovals
=
Ember
.
get
(
map
'
length
'
)
=
=
=
Ember
.
get
(
array
'
length
'
)
;
if
(
hasNoPotentialDeletions
&
&
hasNoInsertionsOrRemovals
)
{
return
;
}
var
internalModels
=
this
.
_visibleInternalModelsByType
(
modelName
)
;
var
modelsToAdd
=
[
]
;
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
var
recordArrays
=
internalModel
.
_recordArrays
;
if
(
recordArrays
.
has
(
array
)
=
=
=
false
)
{
recordArrays
.
add
(
array
)
;
modelsToAdd
.
push
(
internalModel
)
;
}
}
array
.
_pushInternalModels
(
modelsToAdd
)
;
}
updateFilter
(
array
modelName
filter
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
updateFilter
expects
modelName
not
modelClass
as
the
second
param
received
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
modelMap
=
this
.
store
.
_internalModelsFor
(
modelName
)
;
var
internalModels
=
modelMap
.
models
;
this
.
updateFilterRecordArray
(
array
filter
internalModels
)
;
}
_didUpdateAll
(
modelName
)
{
var
recordArray
=
this
.
_liveRecordArrays
[
modelName
]
;
if
(
recordArray
)
{
Ember
.
set
(
recordArray
'
isUpdating
'
false
)
;
}
}
liveRecordArrayFor
(
modelName
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
liveRecordArrayFor
expects
modelName
not
modelClass
as
the
param
typeof
modelName
=
=
=
'
string
'
)
)
;
var
array
=
this
.
_liveRecordArrays
[
modelName
]
;
if
(
array
)
{
this
.
_syncLiveRecordArray
(
array
modelName
)
;
}
else
{
var
internalModels
=
this
.
_visibleInternalModelsByType
(
modelName
)
;
array
=
this
.
createRecordArray
(
modelName
internalModels
)
;
this
.
_liveRecordArrays
[
modelName
]
=
array
;
}
return
array
;
}
_visibleInternalModelsByType
(
modelName
)
{
var
all
=
this
.
store
.
_internalModelsFor
(
modelName
)
.
_models
;
var
visible
=
[
]
;
for
(
var
i
=
0
;
i
<
all
.
length
;
i
+
+
)
{
var
model
=
all
[
i
]
;
if
(
model
.
isHiddenFromRecordArrays
(
)
=
=
=
false
)
{
visible
.
push
(
model
)
;
}
}
return
visible
;
}
filteredRecordArraysFor
(
modelName
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
filteredRecordArraysFor
expects
modelName
not
modelClass
as
the
param
typeof
modelName
=
=
=
'
string
'
)
)
;
return
this
.
_filteredRecordArrays
[
modelName
]
|
|
(
this
.
_filteredRecordArrays
[
modelName
]
=
[
]
)
;
}
createRecordArray
(
modelName
content
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
createRecordArray
expects
modelName
not
modelClass
as
the
param
typeof
modelName
=
=
=
'
string
'
)
)
;
var
array
=
RecordArray
.
create
(
{
modelName
content
:
Ember
.
A
(
content
|
|
[
]
)
store
:
this
.
store
isLoaded
:
true
manager
:
this
}
)
;
if
(
Array
.
isArray
(
content
)
)
{
associateWithRecordArray
(
content
array
)
;
}
return
array
;
}
createFilteredRecordArray
(
modelName
filter
query
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
createFilteredRecordArray
expects
modelName
not
modelClass
as
the
first
param
received
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
array
=
FilteredRecordArray
.
create
(
{
query
modelName
content
:
Ember
.
A
(
)
store
:
this
.
store
manager
:
this
filterFunction
:
filter
}
)
;
this
.
registerFilteredRecordArray
(
array
modelName
filter
)
;
return
array
;
}
createAdapterPopulatedRecordArray
(
modelName
query
internalModels
payload
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
createAdapterPopulatedRecordArray
expects
modelName
not
modelClass
as
the
first
param
received
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
array
=
void
0
;
if
(
Array
.
isArray
(
internalModels
)
)
{
array
=
AdapterPopulatedRecordArray
.
create
(
{
modelName
query
:
query
content
:
Ember
.
A
(
internalModels
)
store
:
this
.
store
manager
:
this
isLoaded
:
true
isUpdating
:
false
meta
:
cloneNull
(
payload
.
meta
)
links
:
cloneNull
(
payload
.
links
)
}
)
;
associateWithRecordArray
(
internalModels
array
)
;
}
else
{
array
=
AdapterPopulatedRecordArray
.
create
(
{
modelName
query
:
query
content
:
Ember
.
A
(
)
store
:
this
.
store
manager
:
this
}
)
;
}
this
.
_adapterPopulatedRecordArrays
.
push
(
array
)
;
return
array
;
}
registerFilteredRecordArray
(
array
modelName
filter
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
recordArrayManger
.
registerFilteredRecordArray
expects
modelName
not
modelClass
as
the
second
param
received
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
this
.
filteredRecordArraysFor
(
modelName
)
.
push
(
array
)
;
this
.
updateFilter
(
array
modelName
filter
)
;
}
unregisterRecordArray
(
array
)
{
var
modelName
=
array
.
modelName
;
var
recordArrays
=
this
.
filteredRecordArraysFor
(
modelName
)
;
var
removedFromFiltered
=
remove
(
recordArrays
array
)
;
var
removedFromAdapterPopulated
=
remove
(
this
.
_adapterPopulatedRecordArrays
array
)
;
if
(
!
removedFromFiltered
&
&
!
removedFromAdapterPopulated
)
{
var
liveRecordArrayForType
=
this
.
_liveRecordArrays
[
modelName
]
;
if
(
liveRecordArrayForType
)
{
if
(
array
=
=
=
liveRecordArrayForType
)
{
delete
this
.
_liveRecordArrays
[
modelName
]
;
}
}
}
}
willDestroy
(
)
{
Object
.
keys
(
this
.
_filteredRecordArrays
)
.
forEach
(
modelName
=
>
flatten
(
this
.
_filteredRecordArrays
[
modelName
]
)
.
forEach
(
destroy
)
)
;
Object
.
keys
(
this
.
_liveRecordArrays
)
.
forEach
(
modelName
=
>
this
.
_liveRecordArrays
[
modelName
]
.
destroy
(
)
)
;
this
.
_adapterPopulatedRecordArrays
.
forEach
(
destroy
)
;
this
.
isDestroyed
=
true
;
}
destroy
(
)
{
this
.
isDestroying
=
true
;
Ember
.
run
.
schedule
(
'
actions
'
this
this
.
willDestroy
)
;
}
}
function
destroy
(
entry
)
{
entry
.
destroy
(
)
;
}
function
flatten
(
list
)
{
var
length
=
list
.
length
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
result
=
result
.
concat
(
list
[
i
]
)
;
}
return
result
;
}
function
remove
(
array
item
)
{
var
index
=
array
.
indexOf
(
item
)
;
if
(
index
!
=
=
-
1
)
{
array
.
splice
(
index
1
)
;
return
true
;
}
return
false
;
}
function
updateLiveRecordArray
(
array
internalModels
)
{
var
modelsToAdd
=
[
]
;
var
modelsToRemove
=
[
]
;
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
var
isDeleted
=
internalModel
.
isHiddenFromRecordArrays
(
)
;
var
recordArrays
=
internalModel
.
_recordArrays
;
if
(
!
isDeleted
&
&
!
internalModel
.
isEmpty
(
)
)
{
if
(
!
recordArrays
.
has
(
array
)
)
{
modelsToAdd
.
push
(
internalModel
)
;
recordArrays
.
add
(
array
)
;
}
}
if
(
isDeleted
)
{
modelsToRemove
.
push
(
internalModel
)
;
recordArrays
.
delete
(
array
)
;
}
}
if
(
modelsToAdd
.
length
>
0
)
{
array
.
_pushInternalModels
(
modelsToAdd
)
;
}
if
(
modelsToRemove
.
length
>
0
)
{
array
.
_removeInternalModels
(
modelsToRemove
)
;
}
}
function
removeFromAdapterPopulatedRecordArrays
(
internalModels
)
{
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
var
list
=
internalModel
.
_recordArrays
.
list
;
for
(
var
j
=
0
;
j
<
list
.
length
;
j
+
+
)
{
list
[
j
]
.
_removeInternalModels
(
[
internalModel
]
)
;
}
internalModel
.
_recordArrays
.
clear
(
)
;
}
}
function
associateWithRecordArray
(
internalModels
array
)
{
for
(
var
i
=
0
l
=
internalModels
.
length
;
i
<
l
;
i
+
+
)
{
var
internalModel
=
internalModels
[
i
]
;
internalModel
.
_recordArrays
.
add
(
array
)
;
}
}
var
badIdFormatAssertion
=
'
id
passed
to
findRecord
(
)
has
to
be
non
-
empty
string
or
number
'
;
var
{
_Backburner
:
Backburner
ENV
}
=
Ember
;
var
{
Promise
}
=
Ember
.
RSVP
;
function
promiseRecord
(
internalModelPromise
label
)
{
var
toReturn
=
internalModelPromise
.
then
(
internalModel
=
>
internalModel
.
getRecord
(
)
)
;
return
promiseObject
(
toReturn
label
)
;
}
var
Store
=
void
0
;
Store
=
Ember
.
Service
.
extend
(
{
init
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
this
.
_backburner
=
new
Backburner
(
[
'
normalizeRelationships
'
'
syncRelationships
'
'
finished
'
]
)
;
this
.
recordArrayManager
=
new
RecordArrayManager
(
{
store
:
this
}
)
;
this
.
_identityMap
=
new
IdentityMap
(
)
;
this
.
_pendingSave
=
[
]
;
this
.
_modelFactoryCache
=
Object
.
create
(
null
)
;
this
.
_relationshipsPayloads
=
new
RelationshipPayloadsManager
(
this
)
;
this
.
_pendingSave
=
[
]
;
this
.
_updatedRelationships
=
[
]
;
this
.
_pushedInternalModels
=
[
]
;
this
.
_updatedInternalModels
=
[
]
;
this
.
_pendingFetch
=
Ember
.
MapWithDefault
.
create
(
{
defaultValue
(
)
{
return
[
]
;
}
}
)
;
this
.
_adapterCache
=
Object
.
create
(
null
)
;
this
.
_serializerCache
=
Object
.
create
(
null
)
;
}
adapter
:
'
-
json
-
api
'
serialize
(
record
options
)
{
if
(
isEnabled
(
'
ds
-
deprecate
-
store
-
serialize
'
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
Use
of
store
.
serialize
is
deprecated
use
record
.
serialize
instead
.
'
false
{
id
:
'
ds
.
store
.
serialize
'
until
:
'
3
.
0
'
}
)
)
;
}
var
snapshot
=
record
.
_internalModel
.
createSnapshot
(
)
;
return
snapshot
.
serialize
(
options
)
;
}
defaultAdapter
:
Ember
.
computed
(
'
adapter
'
function
(
)
{
var
adapter
=
Ember
.
get
(
this
'
adapter
'
)
;
(
true
&
&
!
(
typeof
adapter
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
'
You
tried
to
set
adapter
property
to
an
instance
of
DS
.
Adapter
where
it
should
be
a
name
'
typeof
adapter
=
=
=
'
string
'
)
)
;
return
this
.
adapterFor
(
adapter
)
;
}
)
createRecord
(
modelName
inputProperties
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
createRecord
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
properties
=
Ember
.
copy
(
inputProperties
)
|
|
Object
.
create
(
null
)
;
if
(
Ember
.
isNone
(
properties
.
id
)
)
{
properties
.
id
=
this
.
_generateId
(
normalizedModelName
properties
)
;
}
properties
.
id
=
coerceId
(
properties
.
id
)
;
var
internalModel
=
this
.
_buildInternalModel
(
normalizedModelName
properties
.
id
)
;
internalModel
.
loadedData
(
)
;
var
record
=
internalModel
.
getRecord
(
properties
)
;
internalModel
.
eachRelationship
(
(
key
descriptor
)
=
>
{
if
(
properties
[
key
]
!
=
=
undefined
)
{
internalModel
.
_relationships
.
get
(
key
)
.
setHasData
(
true
)
;
}
}
)
;
return
record
;
}
_generateId
(
modelName
properties
)
{
var
adapter
=
this
.
adapterFor
(
modelName
)
;
if
(
adapter
&
&
adapter
.
generateIdForRecord
)
{
return
adapter
.
generateIdForRecord
(
this
modelName
properties
)
;
}
return
null
;
}
deleteRecord
(
record
)
{
record
.
deleteRecord
(
)
;
}
unloadRecord
(
record
)
{
record
.
unloadRecord
(
)
;
}
find
(
modelName
id
options
)
{
(
true
&
&
!
(
arguments
.
length
!
=
=
1
)
&
&
Ember
.
assert
(
Using
store
.
find
(
type
)
has
been
removed
.
Use
store
.
findAll
(
modelName
)
to
retrieve
all
records
for
a
given
type
.
arguments
.
length
!
=
=
1
)
)
;
(
true
&
&
!
(
!
options
)
&
&
Ember
.
assert
(
Calling
store
.
find
(
modelName
id
{
preload
:
preload
}
)
is
no
longer
supported
.
Use
store
.
findRecord
(
modelName
id
{
preload
:
preload
}
)
instead
.
!
options
)
)
;
(
true
&
&
!
(
arguments
.
length
=
=
=
2
)
&
&
Ember
.
assert
(
You
need
to
pass
the
model
name
and
id
to
the
store
'
s
find
method
arguments
.
length
=
=
=
2
)
)
;
(
true
&
&
!
(
typeof
id
=
=
=
'
string
'
|
|
typeof
id
=
=
=
'
number
'
)
&
&
Ember
.
assert
(
You
cannot
pass
'
{
id
}
'
as
id
to
the
store
'
s
find
method
typeof
id
=
=
=
'
string
'
|
|
typeof
id
=
=
=
'
number
'
)
)
;
(
true
&
&
!
(
typeof
id
!
=
=
'
object
'
)
&
&
Ember
.
assert
(
Calling
store
.
find
(
)
with
a
query
object
is
no
longer
supported
.
Use
store
.
query
(
)
instead
.
typeof
id
!
=
=
'
object
'
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
return
this
.
findRecord
(
normalizedModelName
id
)
;
}
findRecord
(
modelName
id
options
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
findRecord
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
(
true
&
&
!
(
typeof
id
=
=
=
'
string
'
&
&
id
.
length
>
0
|
|
typeof
id
=
=
=
'
number
'
&
&
!
isNaN
(
id
)
)
&
&
Ember
.
assert
(
badIdFormatAssertion
typeof
id
=
=
=
'
string
'
&
&
id
.
length
>
0
|
|
typeof
id
=
=
=
'
number
'
&
&
!
isNaN
(
id
)
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
internalModel
=
this
.
_internalModelForId
(
normalizedModelName
id
)
;
options
=
options
|
|
{
}
;
if
(
!
this
.
hasRecordForId
(
normalizedModelName
id
)
)
{
return
this
.
_findByInternalModel
(
internalModel
options
)
;
}
var
fetchedInternalModel
=
this
.
_findRecord
(
internalModel
options
)
;
return
promiseRecord
(
fetchedInternalModel
DS
:
Store
#
findRecord
{
normalizedModelName
}
with
id
:
{
id
}
)
;
}
_findRecord
(
internalModel
options
)
{
if
(
options
.
reload
)
{
return
this
.
_scheduleFetch
(
internalModel
options
)
;
}
var
snapshot
=
internalModel
.
createSnapshot
(
options
)
;
var
adapter
=
this
.
adapterFor
(
internalModel
.
modelName
)
;
if
(
adapter
.
shouldReloadRecord
(
this
snapshot
)
)
{
return
this
.
_scheduleFetch
(
internalModel
options
)
;
}
if
(
options
.
backgroundReload
=
=
=
false
)
{
return
Promise
.
resolve
(
internalModel
)
;
}
if
(
options
.
backgroundReload
|
|
adapter
.
shouldBackgroundReloadRecord
(
this
snapshot
)
)
{
this
.
_scheduleFetch
(
internalModel
options
)
;
}
return
Promise
.
resolve
(
internalModel
)
;
}
_findByInternalModel
(
internalModel
options
=
{
}
)
{
if
(
options
.
preload
)
{
internalModel
.
preloadData
(
options
.
preload
)
;
}
var
fetchedInternalModel
=
this
.
_findEmptyInternalModel
(
internalModel
options
)
;
return
promiseRecord
(
fetchedInternalModel
DS
:
Store
#
findRecord
{
internalModel
.
modelName
}
with
id
:
{
internalModel
.
id
}
)
;
}
_findEmptyInternalModel
(
internalModel
options
)
{
if
(
internalModel
.
isEmpty
(
)
)
{
return
this
.
_scheduleFetch
(
internalModel
options
)
;
}
if
(
internalModel
.
isLoading
(
)
)
{
return
internalModel
.
_loadingPromise
;
}
return
Promise
.
resolve
(
internalModel
)
;
}
findByIds
(
modelName
ids
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
findByIds
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
promises
=
new
Array
(
ids
.
length
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
for
(
var
i
=
0
;
i
<
ids
.
length
;
i
+
+
)
{
promises
[
i
]
=
this
.
findRecord
(
normalizedModelName
ids
[
i
]
)
;
}
return
promiseArray
(
Ember
.
RSVP
.
all
(
promises
)
.
then
(
Ember
.
A
null
DS
:
Store
#
findByIds
of
{
normalizedModelName
}
complete
)
)
;
}
_fetchRecord
(
internalModel
options
)
{
var
modelName
=
internalModel
.
modelName
;
var
adapter
=
this
.
adapterFor
(
modelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
find
a
record
but
you
have
no
adapter
(
for
{
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
findRecord
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
find
a
record
but
your
adapter
(
for
{
modelName
}
)
does
not
implement
'
findRecord
'
typeof
adapter
.
findRecord
=
=
=
'
function
'
)
)
;
return
_find
(
adapter
this
internalModel
.
type
internalModel
.
id
internalModel
options
)
;
}
_scheduleFetchMany
(
internalModels
)
{
var
fetches
=
new
Array
(
internalModels
.
length
)
;
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
fetches
[
i
]
=
this
.
_scheduleFetch
(
internalModels
[
i
]
)
;
}
return
Promise
.
all
(
fetches
)
;
}
_scheduleFetch
(
internalModel
options
)
{
if
(
internalModel
.
_loadingPromise
)
{
return
internalModel
.
_loadingPromise
;
}
var
{
id
modelName
}
=
internalModel
;
var
resolver
=
Ember
.
RSVP
.
defer
(
Fetching
{
modelName
}
'
with
id
:
{
id
}
)
;
var
pendingFetchItem
=
{
internalModel
resolver
options
}
;
var
promise
=
resolver
.
promise
;
internalModel
.
loadingData
(
promise
)
;
if
(
this
.
_pendingFetch
.
size
=
=
=
0
)
{
Ember
.
run
.
schedule
(
'
afterRender
'
this
this
.
flushAllPendingFetches
)
;
}
this
.
_pendingFetch
.
get
(
modelName
)
.
push
(
pendingFetchItem
)
;
return
promise
;
}
flushAllPendingFetches
(
)
{
if
(
this
.
isDestroyed
|
|
this
.
isDestroying
)
{
return
;
}
this
.
_pendingFetch
.
forEach
(
this
.
_flushPendingFetchForType
this
)
;
this
.
_pendingFetch
.
clear
(
)
;
}
_flushPendingFetchForType
(
pendingFetchItems
modelName
)
{
var
store
=
this
;
var
adapter
=
store
.
adapterFor
(
modelName
)
;
var
shouldCoalesce
=
!
!
adapter
.
findMany
&
&
adapter
.
coalesceFindRequests
;
var
totalItems
=
pendingFetchItems
.
length
;
var
internalModels
=
new
Array
(
totalItems
)
;
var
seeking
=
Object
.
create
(
null
)
;
for
(
var
_i
=
0
;
_i
<
totalItems
;
_i
+
+
)
{
var
pendingItem
=
pendingFetchItems
[
_i
]
;
var
_internalModel
=
pendingItem
.
internalModel
;
internalModels
[
_i
]
=
_internalModel
;
seeking
[
_internalModel
.
id
]
=
pendingItem
;
}
function
_fetchRecord
(
recordResolverPair
)
{
var
recordFetch
=
store
.
_fetchRecord
(
recordResolverPair
.
internalModel
recordResolverPair
.
options
)
;
recordResolverPair
.
resolver
.
resolve
(
recordFetch
)
;
}
function
handleFoundRecords
(
foundInternalModels
expectedInternalModels
)
{
var
found
=
Object
.
create
(
null
)
;
for
(
var
_i2
=
0
_l
=
foundInternalModels
.
length
;
_i2
<
_l
;
_i2
+
+
)
{
var
_internalModel2
=
foundInternalModels
[
_i2
]
;
var
_pair
=
seeking
[
_internalModel2
.
id
]
;
found
[
_internalModel2
.
id
]
=
_internalModel2
;
if
(
_pair
)
{
var
resolver
=
_pair
.
resolver
;
resolver
.
resolve
(
_internalModel2
)
;
}
}
var
missingInternalModels
=
[
]
;
for
(
var
_i3
=
0
_l2
=
expectedInternalModels
.
length
;
_i3
<
_l2
;
_i3
+
+
)
{
var
_internalModel3
=
expectedInternalModels
[
_i3
]
;
if
(
!
found
[
_internalModel3
.
id
]
)
{
missingInternalModels
.
push
(
_internalModel3
)
;
}
}
if
(
missingInternalModels
.
length
)
{
(
true
&
&
Ember
.
warn
(
'
Ember
Data
expected
to
find
records
with
the
following
ids
in
the
adapter
response
but
they
were
missing
:
'
+
Ember
.
inspect
(
missingInternalModels
.
map
(
r
=
>
r
.
id
)
)
false
{
id
:
'
ds
.
store
.
missing
-
records
-
from
-
adapter
'
}
)
)
;
rejectInternalModels
(
missingInternalModels
)
;
}
}
function
rejectInternalModels
(
internalModels
error
)
{
for
(
var
_i4
=
0
_l3
=
internalModels
.
length
;
_i4
<
_l3
;
_i4
+
+
)
{
var
_internalModel4
=
internalModels
[
_i4
]
;
var
_pair2
=
seeking
[
_internalModel4
.
id
]
;
if
(
_pair2
)
{
_pair2
.
resolver
.
reject
(
error
|
|
new
Error
(
Expected
:
'
{
_internalModel4
}
'
to
be
present
in
the
adapter
provided
payload
but
it
was
not
found
.
)
)
;
}
}
}
if
(
shouldCoalesce
)
{
var
snapshots
=
new
Array
(
totalItems
)
;
for
(
var
_i5
=
0
;
_i5
<
totalItems
;
_i5
+
+
)
{
snapshots
[
_i5
]
=
internalModels
[
_i5
]
.
createSnapshot
(
)
;
}
var
groups
=
adapter
.
groupRecordsForFindMany
(
this
snapshots
)
;
for
(
var
i
=
0
l
=
groups
.
length
;
i
<
l
;
i
+
+
)
{
var
group
=
groups
[
i
]
;
var
totalInGroup
=
groups
[
i
]
.
length
;
var
ids
=
new
Array
(
totalInGroup
)
;
var
groupedInternalModels
=
new
Array
(
totalInGroup
)
;
for
(
var
j
=
0
;
j
<
totalInGroup
;
j
+
+
)
{
var
internalModel
=
group
[
j
]
.
_internalModel
;
groupedInternalModels
[
j
]
=
internalModel
;
ids
[
j
]
=
internalModel
.
id
;
}
if
(
totalInGroup
>
1
)
{
(
function
(
groupedInternalModels
)
{
_findMany
(
adapter
store
modelName
ids
groupedInternalModels
)
.
then
(
function
(
foundInternalModels
)
{
handleFoundRecords
(
foundInternalModels
groupedInternalModels
)
;
}
)
.
catch
(
function
(
error
)
{
rejectInternalModels
(
groupedInternalModels
error
)
;
}
)
;
}
)
(
groupedInternalModels
)
;
}
else
if
(
ids
.
length
=
=
=
1
)
{
var
pair
=
seeking
[
groupedInternalModels
[
0
]
.
id
]
;
_fetchRecord
(
pair
)
;
}
else
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
"
You
cannot
return
an
empty
array
from
adapter
'
s
method
groupRecordsForFindMany
"
false
)
)
;
}
}
}
else
{
for
(
var
_i6
=
0
;
_i6
<
totalItems
;
_i6
+
+
)
{
_fetchRecord
(
pendingFetchItems
[
_i6
]
)
;
}
}
}
getReference
(
modelName
id
)
{
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
return
this
.
_internalModelForId
(
normalizedModelName
id
)
.
recordReference
;
}
peekRecord
(
modelName
id
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
peekRecord
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
&
&
Ember
.
isPresent
(
id
)
)
&
&
Ember
.
assert
(
You
need
to
pass
both
a
model
name
and
id
to
the
store
'
s
peekRecord
method
Ember
.
isPresent
(
modelName
)
&
&
Ember
.
isPresent
(
id
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
if
(
this
.
hasRecordForId
(
normalizedModelName
id
)
)
{
return
this
.
_internalModelForId
(
normalizedModelName
id
)
.
getRecord
(
)
;
}
else
{
return
null
;
}
}
_reloadRecord
(
internalModel
)
{
var
{
id
modelName
}
=
internalModel
;
var
adapter
=
this
.
adapterFor
(
modelName
)
;
(
true
&
&
!
(
id
)
&
&
Ember
.
assert
(
You
cannot
reload
a
record
without
an
ID
id
)
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
reload
a
record
but
you
have
no
adapter
(
for
{
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
findRecord
=
=
=
'
function
'
|
|
typeof
adapter
.
find
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
reload
a
record
but
your
adapter
does
not
implement
'
findRecord
'
typeof
adapter
.
findRecord
=
=
=
'
function
'
|
|
typeof
adapter
.
find
=
=
=
'
function
'
)
)
;
return
this
.
_scheduleFetch
(
internalModel
)
;
}
hasRecordForId
(
modelName
id
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
hasRecordForId
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
trueId
=
coerceId
(
id
)
;
var
internalModel
=
this
.
_internalModelsFor
(
normalizedModelName
)
.
get
(
trueId
)
;
return
!
!
internalModel
&
&
internalModel
.
isLoaded
(
)
;
}
recordForId
(
modelName
id
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
recordForId
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
return
this
.
_internalModelForId
(
modelName
id
)
.
getRecord
(
)
;
}
_internalModelForId
(
modelName
id
)
{
var
trueId
=
coerceId
(
id
)
;
var
internalModel
=
this
.
_internalModelsFor
(
modelName
)
.
get
(
trueId
)
;
if
(
internalModel
)
{
if
(
internalModel
.
hasScheduledDestroy
(
)
)
{
internalModel
.
destroySync
(
)
;
return
this
.
_buildInternalModel
(
modelName
trueId
)
;
}
else
{
return
internalModel
;
}
}
else
{
return
this
.
_buildInternalModel
(
modelName
trueId
)
;
}
}
_internalModelDidReceiveRelationshipData
(
modelName
id
relationshipData
)
{
this
.
_relationshipsPayloads
.
push
(
modelName
id
relationshipData
)
;
}
_internalModelDestroyed
(
internalModel
)
{
this
.
_removeFromIdMap
(
internalModel
)
;
this
.
_relationshipsPayloads
.
unload
(
internalModel
.
modelName
internalModel
.
id
)
;
}
findMany
(
internalModels
)
{
var
finds
=
new
Array
(
internalModels
.
length
)
;
for
(
var
i
=
0
;
i
<
internalModels
.
length
;
i
+
+
)
{
finds
[
i
]
=
this
.
_findEmptyInternalModel
(
internalModels
[
i
]
)
;
}
return
Promise
.
all
(
finds
)
;
}
findHasMany
(
internalModel
link
relationship
)
{
var
adapter
=
this
.
adapterFor
(
internalModel
.
modelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
load
a
hasMany
relationship
but
you
have
no
adapter
(
for
{
internalModel
.
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
findHasMany
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
load
a
hasMany
relationship
from
a
specified
'
link
'
in
the
original
payload
but
your
adapter
does
not
implement
'
findHasMany
'
typeof
adapter
.
findHasMany
=
=
=
'
function
'
)
)
;
return
_findHasMany
(
adapter
this
internalModel
link
relationship
)
;
}
findBelongsTo
(
internalModel
link
relationship
)
{
var
adapter
=
this
.
adapterFor
(
internalModel
.
modelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
load
a
belongsTo
relationship
but
you
have
no
adapter
(
for
{
internalModel
.
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
findBelongsTo
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
load
a
belongsTo
relationship
from
a
specified
'
link
'
in
the
original
payload
but
your
adapter
does
not
implement
'
findBelongsTo
'
typeof
adapter
.
findBelongsTo
=
=
=
'
function
'
)
)
;
return
_findBelongsTo
(
adapter
this
internalModel
link
relationship
)
;
}
query
(
modelName
query
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
query
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
query
)
&
&
Ember
.
assert
(
You
need
to
pass
a
query
hash
to
the
store
'
s
query
method
query
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
return
this
.
_query
(
normalizedModelName
query
)
;
}
_query
(
modelName
query
array
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
query
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
query
)
&
&
Ember
.
assert
(
You
need
to
pass
a
query
hash
to
the
store
'
s
query
method
query
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
adapter
=
this
.
adapterFor
(
modelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
load
a
query
but
you
have
no
adapter
(
for
{
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
query
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
load
a
query
but
your
adapter
does
not
implement
'
query
'
typeof
adapter
.
query
=
=
=
'
function
'
)
)
;
var
pA
=
promiseArray
(
_query
(
adapter
this
modelName
query
array
)
)
;
return
pA
;
}
queryRecord
(
modelName
query
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
queryRecord
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
query
)
&
&
Ember
.
assert
(
You
need
to
pass
a
query
hash
to
the
store
'
s
queryRecord
method
query
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
adapter
=
this
.
adapterFor
(
normalizedModelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
make
a
query
but
you
have
no
adapter
(
for
{
normalizedModelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
queryRecord
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
make
a
query
but
your
adapter
does
not
implement
'
queryRecord
'
typeof
adapter
.
queryRecord
=
=
=
'
function
'
)
)
;
return
promiseObject
(
_queryRecord
(
adapter
this
modelName
query
)
.
then
(
internalModel
=
>
{
if
(
internalModel
)
{
return
internalModel
.
getRecord
(
)
;
}
return
null
;
}
)
)
;
}
findAll
(
modelName
options
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
findAll
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
fetch
=
this
.
_fetchAll
(
normalizedModelName
this
.
peekAll
(
normalizedModelName
)
options
)
;
return
fetch
;
}
_fetchAll
(
modelName
array
options
=
{
}
)
{
var
adapter
=
this
.
adapterFor
(
modelName
)
;
var
sinceToken
=
this
.
_internalModelsFor
(
modelName
)
.
metadata
.
since
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
load
all
records
but
you
have
no
adapter
(
for
{
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
.
findAll
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
load
all
records
but
your
adapter
does
not
implement
'
findAll
'
typeof
adapter
.
findAll
=
=
=
'
function
'
)
)
;
if
(
options
.
reload
)
{
Ember
.
set
(
array
'
isUpdating
'
true
)
;
return
promiseArray
(
_findAll
(
adapter
this
modelName
sinceToken
options
)
)
;
}
var
snapshotArray
=
array
.
_createSnapshot
(
options
)
;
if
(
adapter
.
shouldReloadAll
(
this
snapshotArray
)
)
{
Ember
.
set
(
array
'
isUpdating
'
true
)
;
return
promiseArray
(
_findAll
(
adapter
this
modelName
sinceToken
options
)
)
;
}
if
(
options
.
backgroundReload
=
=
=
false
)
{
return
promiseArray
(
Promise
.
resolve
(
array
)
)
;
}
if
(
options
.
backgroundReload
|
|
adapter
.
shouldBackgroundReloadAll
(
this
snapshotArray
)
)
{
Ember
.
set
(
array
'
isUpdating
'
true
)
;
_findAll
(
adapter
this
modelName
sinceToken
options
)
;
}
return
promiseArray
(
Promise
.
resolve
(
array
)
)
;
}
_didUpdateAll
(
modelName
)
{
this
.
recordArrayManager
.
_didUpdateAll
(
modelName
)
;
}
didUpdateAll
(
modelName
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
didUpdateAll
was
documented
as
private
and
will
be
removed
in
the
next
version
of
Ember
Data
.
'
false
{
id
:
'
ember
-
data
.
didUpdateAll
'
until
:
'
2
.
17
.
0
'
}
)
)
;
return
this
.
_didUpdateAll
(
modelName
)
;
}
peekAll
(
modelName
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
peekAll
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
return
this
.
recordArrayManager
.
liveRecordArrayFor
(
normalizedModelName
)
;
}
unloadAll
(
modelName
)
{
(
true
&
&
!
(
!
modelName
|
|
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
!
modelName
|
|
typeof
modelName
=
=
=
'
string
'
)
)
;
if
(
arguments
.
length
=
=
=
0
)
{
this
.
_identityMap
.
clear
(
)
;
}
else
{
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
this
.
_internalModelsFor
(
normalizedModelName
)
.
clear
(
)
;
}
}
filter
(
modelName
query
filter
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
filter
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
if
(
!
ENV
.
ENABLE_DS_FILTER
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
'
The
filter
API
has
been
moved
to
a
plugin
.
To
enable
store
.
filter
using
an
environment
flag
or
to
use
an
alternative
you
can
visit
the
ember
-
data
-
filter
addon
page
.
https
:
/
/
github
.
com
/
ember
-
data
/
ember
-
data
-
filter
'
false
)
)
;
}
var
promise
=
void
0
;
var
length
=
arguments
.
length
;
var
array
=
void
0
;
var
hasQuery
=
length
=
=
=
3
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
if
(
hasQuery
)
{
promise
=
this
.
query
(
normalizedModelName
query
)
;
}
else
if
(
arguments
.
length
=
=
=
2
)
{
filter
=
query
;
}
if
(
hasQuery
)
{
array
=
this
.
recordArrayManager
.
createFilteredRecordArray
(
normalizedModelName
filter
query
)
;
}
else
{
array
=
this
.
recordArrayManager
.
createFilteredRecordArray
(
normalizedModelName
filter
)
;
}
promise
=
promise
|
|
Promise
.
resolve
(
array
)
;
return
promiseArray
(
promise
.
then
(
(
)
=
>
array
null
DS
:
Store
#
filter
of
{
normalizedModelName
}
)
)
;
}
recordIsLoaded
(
modelName
id
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
Use
of
recordIsLoaded
is
deprecated
use
hasRecordForId
instead
.
false
{
id
:
'
ds
.
store
.
recordIsLoaded
'
until
:
'
3
.
0
'
}
)
)
;
return
this
.
hasRecordForId
(
modelName
id
)
;
}
scheduleSave
(
internalModel
resolver
options
)
{
var
snapshot
=
internalModel
.
createSnapshot
(
options
)
;
internalModel
.
flushChangedAttributes
(
)
;
internalModel
.
adapterWillCommit
(
)
;
this
.
_pendingSave
.
push
(
{
snapshot
:
snapshot
resolver
:
resolver
}
)
;
Ember
.
run
.
once
(
this
this
.
flushPendingSave
)
;
}
flushPendingSave
(
)
{
var
pending
=
this
.
_pendingSave
.
slice
(
)
;
this
.
_pendingSave
=
[
]
;
for
(
var
i
=
0
j
=
pending
.
length
;
i
<
j
;
i
+
+
)
{
var
pendingItem
=
pending
[
i
]
;
var
snapshot
=
pendingItem
.
snapshot
;
var
resolver
=
pendingItem
.
resolver
;
var
internalModel
=
snapshot
.
_internalModel
;
var
adapter
=
this
.
adapterFor
(
internalModel
.
modelName
)
;
var
operation
=
void
0
;
if
(
internalModel
.
currentState
.
stateName
=
=
=
'
root
.
deleted
.
saved
'
)
{
resolver
.
resolve
(
)
;
continue
;
}
else
if
(
internalModel
.
isNew
(
)
)
{
operation
=
'
createRecord
'
;
}
else
if
(
internalModel
.
isDeleted
(
)
)
{
operation
=
'
deleteRecord
'
;
}
else
{
operation
=
'
updateRecord
'
;
}
resolver
.
resolve
(
_commit
(
adapter
this
operation
snapshot
)
)
;
}
}
didSaveRecord
(
internalModel
dataArg
)
{
var
data
=
void
0
;
if
(
dataArg
)
{
data
=
dataArg
.
data
;
}
if
(
data
)
{
this
.
updateId
(
internalModel
data
)
;
this
.
_setupRelationshipsForModel
(
internalModel
data
)
;
}
else
{
(
true
&
&
!
(
internalModel
.
id
)
&
&
Ember
.
assert
(
Your
{
internalModel
.
modelName
}
record
was
saved
to
the
server
but
the
response
does
not
have
an
id
and
no
id
has
been
set
client
side
.
Records
must
have
ids
.
Please
update
the
server
response
to
provide
an
id
in
the
response
or
generate
the
id
on
the
client
side
either
before
saving
the
record
or
while
normalizing
the
response
.
internalModel
.
id
)
)
;
}
internalModel
.
adapterDidCommit
(
data
)
;
}
recordWasInvalid
(
internalModel
errors
)
{
internalModel
.
adapterDidInvalidate
(
errors
)
;
}
recordWasError
(
internalModel
error
)
{
internalModel
.
adapterDidError
(
error
)
;
}
updateId
(
internalModel
data
)
{
var
oldId
=
internalModel
.
id
;
var
modelName
=
internalModel
.
modelName
;
var
id
=
coerceId
(
data
.
id
)
;
(
true
&
&
!
(
!
(
id
=
=
=
null
&
&
oldId
=
=
=
null
)
)
&
&
Ember
.
assert
(
'
{
modelName
}
'
was
saved
to
the
server
but
the
response
does
not
have
an
id
and
your
record
does
not
either
.
!
(
id
=
=
=
null
&
&
oldId
=
=
=
null
)
)
)
;
(
true
&
&
!
(
!
(
oldId
!
=
=
null
&
&
id
!
=
=
oldId
)
)
&
&
Ember
.
assert
(
'
{
modelName
}
:
{
oldId
}
'
was
saved
to
the
server
but
the
response
returned
the
new
id
'
{
id
}
'
.
The
store
cannot
assign
a
new
id
to
a
record
that
already
has
an
id
.
!
(
oldId
!
=
=
null
&
&
id
!
=
=
oldId
)
)
)
;
if
(
oldId
!
=
=
null
&
&
id
=
=
=
null
)
{
(
true
&
&
Ember
.
warn
(
Your
{
modelName
}
record
was
saved
to
the
server
but
the
response
does
not
have
an
id
.
!
(
oldId
!
=
=
null
&
&
id
=
=
=
null
)
)
)
;
return
;
}
var
existingInternalModel
=
this
.
_existingInternalModelForId
(
modelName
id
)
;
(
true
&
&
!
(
Ember
.
isNone
(
existingInternalModel
)
|
|
existingInternalModel
=
=
=
internalModel
)
&
&
Ember
.
assert
(
'
{
modelName
}
'
was
saved
to
the
server
but
the
response
returned
the
new
id
'
{
id
}
'
which
has
already
been
used
with
another
record
.
'
Ember
.
isNone
(
existingInternalModel
)
|
|
existingInternalModel
=
=
=
internalModel
)
)
;
this
.
_internalModelsFor
(
internalModel
.
modelName
)
.
set
(
id
internalModel
)
;
internalModel
.
setId
(
id
)
;
}
_internalModelsFor
(
modelName
)
{
return
this
.
_identityMap
.
retrieve
(
modelName
)
;
}
_load
(
data
)
{
var
modelName
=
normalizeModelName
(
data
.
type
)
;
var
internalModel
=
this
.
_internalModelForId
(
modelName
data
.
id
)
;
var
isUpdate
=
internalModel
.
currentState
.
isEmpty
=
=
=
false
;
internalModel
.
setupData
(
data
)
;
if
(
isUpdate
)
{
this
.
recordArrayManager
.
recordDidChange
(
internalModel
)
;
}
else
{
this
.
recordArrayManager
.
recordWasLoaded
(
internalModel
)
;
}
return
internalModel
;
}
_modelForMixin
(
normalizedModelName
)
{
var
owner
=
getOwner
(
this
)
;
var
mixin
=
void
0
;
if
(
owner
.
factoryFor
)
{
var
MaybeMixin
=
owner
.
factoryFor
(
mixin
:
{
normalizedModelName
}
)
;
mixin
=
MaybeMixin
&
&
MaybeMixin
.
class
;
}
else
{
mixin
=
owner
.
_lookupFactory
(
mixin
:
{
normalizedModelName
}
)
;
}
if
(
mixin
)
{
var
ModelForMixin
=
Model
.
extend
(
mixin
)
;
ModelForMixin
.
reopenClass
(
{
__isMixin
:
true
__mixin
:
mixin
}
)
;
owner
.
register
(
'
model
:
'
+
normalizedModelName
ModelForMixin
)
;
}
return
this
.
modelFactoryFor
(
normalizedModelName
)
;
}
modelFor
(
modelName
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
modelFor
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
return
this
.
_modelFor
(
normalizedModelName
)
;
}
_modelFor
(
modelName
)
{
var
maybeFactory
=
this
.
_modelFactoryFor
(
modelName
)
;
return
maybeFactory
.
class
?
maybeFactory
.
class
:
maybeFactory
;
}
_modelFactoryFor
(
modelName
)
{
var
factory
=
this
.
_modelFactoryCache
[
modelName
]
;
if
(
!
factory
)
{
factory
=
this
.
modelFactoryFor
(
modelName
)
;
if
(
!
factory
)
{
factory
=
this
.
_modelForMixin
(
modelName
)
;
}
if
(
!
factory
)
{
throw
new
Ember
.
Error
(
No
model
was
found
for
'
{
modelName
}
'
)
;
}
var
klass
=
getOwner
(
this
)
.
factoryFor
?
factory
.
class
:
factory
;
(
true
&
&
!
(
klass
.
isModel
)
&
&
Ember
.
assert
(
'
{
Ember
.
inspect
(
klass
)
}
'
does
not
appear
to
be
an
ember
-
data
model
klass
.
isModel
)
)
;
klass
.
modelName
=
klass
.
modelName
|
|
modelName
;
this
.
_modelFactoryCache
[
modelName
]
=
factory
;
}
return
factory
;
}
modelFactoryFor
(
modelName
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
modelFactoryFor
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
owner
=
getOwner
(
this
)
;
if
(
owner
.
factoryFor
)
{
return
owner
.
factoryFor
(
model
:
{
normalizedModelName
}
)
;
}
else
{
return
owner
.
_lookupFactory
(
model
:
{
normalizedModelName
}
)
;
}
}
push
(
data
)
{
var
pushed
=
this
.
_push
(
data
)
;
if
(
Array
.
isArray
(
pushed
)
)
{
var
records
=
pushed
.
map
(
internalModel
=
>
internalModel
.
getRecord
(
)
)
;
return
records
;
}
if
(
pushed
=
=
=
null
)
{
return
null
;
}
var
record
=
pushed
.
getRecord
(
)
;
return
record
;
}
_push
(
jsonApiDoc
)
{
var
internalModelOrModels
=
this
.
_backburner
.
join
(
(
)
=
>
{
var
included
=
jsonApiDoc
.
included
;
var
i
=
void
0
length
=
void
0
;
if
(
included
)
{
for
(
i
=
0
length
=
included
.
length
;
i
<
length
;
i
+
+
)
{
this
.
_pushInternalModel
(
included
[
i
]
)
;
}
}
if
(
Array
.
isArray
(
jsonApiDoc
.
data
)
)
{
length
=
jsonApiDoc
.
data
.
length
;
var
internalModels
=
new
Array
(
length
)
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
internalModels
[
i
]
=
this
.
_pushInternalModel
(
jsonApiDoc
.
data
[
i
]
)
;
}
return
internalModels
;
}
if
(
jsonApiDoc
.
data
=
=
=
null
)
{
return
null
;
}
(
true
&
&
!
(
Ember
.
typeOf
(
jsonApiDoc
.
data
)
=
=
=
'
object
'
)
&
&
Ember
.
assert
(
Expected
an
object
in
the
'
data
'
property
in
a
call
to
'
push
'
for
{
jsonApiDoc
.
type
}
but
was
{
Ember
.
typeOf
(
jsonApiDoc
.
data
)
}
Ember
.
typeOf
(
jsonApiDoc
.
data
)
=
=
=
'
object
'
)
)
;
return
this
.
_pushInternalModel
(
jsonApiDoc
.
data
)
;
}
)
;
return
internalModelOrModels
;
}
_hasModelFor
(
modelName
)
{
var
owner
=
getOwner
(
this
)
;
modelName
=
normalizeModelName
(
modelName
)
;
if
(
owner
.
factoryFor
)
{
return
!
!
owner
.
factoryFor
(
model
:
{
modelName
}
)
;
}
else
{
return
!
!
owner
.
_lookupFactory
(
model
:
{
modelName
}
)
;
}
}
_pushInternalModel
(
data
)
{
var
modelName
=
data
.
type
;
(
true
&
&
!
(
data
.
id
!
=
=
null
&
&
data
.
id
!
=
=
undefined
&
&
data
.
id
!
=
=
'
'
)
&
&
Ember
.
assert
(
You
must
include
an
'
id
'
for
{
modelName
}
in
an
object
passed
to
'
push
'
data
.
id
!
=
=
null
&
&
data
.
id
!
=
=
undefined
&
&
data
.
id
!
=
=
'
'
)
)
;
(
true
&
&
!
(
this
.
_hasModelFor
(
modelName
)
)
&
&
Ember
.
assert
(
You
tried
to
push
data
with
a
type
'
{
modelName
}
'
but
no
model
could
be
found
with
that
name
.
this
.
_hasModelFor
(
modelName
)
)
)
;
{
if
(
ENV
.
DS_WARN_ON_UNKNOWN_KEYS
)
{
var
modelClass
=
this
.
_modelFor
(
modelName
)
;
var
unknownAttributes
=
Object
.
keys
(
data
.
attributes
|
|
{
}
)
.
filter
(
key
=
>
{
return
!
Ember
.
get
(
modelClass
'
fields
'
)
.
has
(
key
)
;
}
)
;
var
unknownAttributesMessage
=
The
payload
for
'
{
modelName
}
'
contains
these
unknown
attributes
:
{
unknownAttributes
}
.
Make
sure
they
'
ve
been
defined
in
your
model
.
;
(
true
&
&
Ember
.
warn
(
unknownAttributesMessage
unknownAttributes
.
length
=
=
=
0
{
id
:
'
ds
.
store
.
unknown
-
keys
-
in
-
payload
'
}
)
)
;
var
unknownRelationships
=
Object
.
keys
(
data
.
relationships
|
|
{
}
)
.
filter
(
key
=
>
{
return
!
Ember
.
get
(
modelClass
'
fields
'
)
.
has
(
key
)
;
}
)
;
var
unknownRelationshipsMessage
=
The
payload
for
'
{
modelName
}
'
contains
these
unknown
relationships
:
{
unknownRelationships
}
.
Make
sure
they
'
ve
been
defined
in
your
model
.
;
(
true
&
&
Ember
.
warn
(
unknownRelationshipsMessage
unknownRelationships
.
length
=
=
=
0
{
id
:
'
ds
.
store
.
unknown
-
keys
-
in
-
payload
'
}
)
)
;
}
}
var
internalModel
=
this
.
_load
(
data
)
;
this
.
_setupRelationshipsForModel
(
internalModel
data
)
;
return
internalModel
;
}
_setupRelationshipsForModel
(
internalModel
data
)
{
if
(
data
.
relationships
=
=
=
undefined
)
{
return
;
}
if
(
this
.
_pushedInternalModels
.
push
(
internalModel
data
)
!
=
=
2
)
{
return
;
}
this
.
_backburner
.
schedule
(
'
normalizeRelationships
'
this
this
.
_setupRelationships
)
;
}
_setupRelationships
(
)
{
var
pushed
=
this
.
_pushedInternalModels
;
var
modelNameToInverseMap
=
void
0
;
for
(
var
i
=
0
l
=
pushed
.
length
;
i
<
l
;
i
+
=
2
)
{
modelNameToInverseMap
=
modelNameToInverseMap
|
|
Object
.
create
(
null
)
;
var
internalModel
=
pushed
[
i
]
;
var
data
=
pushed
[
i
+
1
]
;
setupRelationships
(
this
internalModel
data
modelNameToInverseMap
)
;
}
pushed
.
length
=
0
;
}
pushPayload
(
modelName
inputPayload
)
{
var
serializer
=
void
0
;
var
payload
=
void
0
;
if
(
!
inputPayload
)
{
payload
=
modelName
;
serializer
=
defaultSerializer
(
this
)
;
(
true
&
&
!
(
typeof
serializer
.
pushPayload
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
cannot
use
'
store
#
pushPayload
'
without
a
modelName
unless
your
default
serializer
defines
'
pushPayload
'
typeof
serializer
.
pushPayload
=
=
=
'
function
'
)
)
;
}
else
{
payload
=
inputPayload
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
serializer
=
this
.
serializerFor
(
normalizedModelName
)
;
}
if
(
isEnabled
(
'
ds
-
pushpayload
-
return
'
)
)
{
return
serializer
.
pushPayload
(
this
payload
)
;
}
else
{
serializer
.
pushPayload
(
this
payload
)
;
}
}
normalize
(
modelName
payload
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
normalize
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
methods
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
Ember
.
inspect
(
modelName
)
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
serializer
=
this
.
serializerFor
(
normalizedModelName
)
;
var
model
=
this
.
_modelFor
(
normalizedModelName
)
;
return
serializer
.
normalize
(
model
payload
)
;
}
_buildInternalModel
(
modelName
id
data
)
{
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
You
can
no
longer
pass
a
modelClass
as
the
first
argument
to
store
.
_buildInternalModel
.
Pass
modelName
instead
.
typeof
modelName
=
=
=
'
string
'
)
)
;
var
existingInternalModel
=
this
.
_existingInternalModelForId
(
modelName
id
)
;
(
true
&
&
!
(
!
existingInternalModel
)
&
&
Ember
.
assert
(
The
id
{
id
}
has
already
been
used
with
another
record
for
modelClass
'
{
modelName
}
'
.
!
existingInternalModel
)
)
;
var
internalModel
=
new
InternalModel
(
modelName
id
this
data
)
;
this
.
_internalModelsFor
(
modelName
)
.
add
(
internalModel
id
)
;
return
internalModel
;
}
_existingInternalModelForId
(
modelName
id
)
{
var
internalModel
=
this
.
_internalModelsFor
(
modelName
)
.
get
(
id
)
;
if
(
internalModel
&
&
internalModel
.
hasScheduledDestroy
(
)
)
{
internalModel
.
destroySync
(
)
;
internalModel
=
null
;
}
return
internalModel
;
}
buildInternalModel
(
modelName
id
data
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
buildInternalModel
was
documented
as
private
and
will
be
removed
in
the
next
version
of
Ember
Data
.
'
false
{
id
:
'
ember
-
data
.
buildInternalModel
'
until
:
'
2
.
17
.
0
'
}
)
)
;
return
this
.
_buildInternalModel
(
modelName
id
data
)
;
}
recordWasLoaded
(
record
)
{
this
.
recordArrayManager
.
recordWasLoaded
(
record
)
;
}
_removeFromIdMap
(
internalModel
)
{
var
recordMap
=
this
.
_internalModelsFor
(
internalModel
.
modelName
)
;
var
id
=
internalModel
.
id
;
recordMap
.
remove
(
internalModel
id
)
;
}
adapterFor
(
modelName
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
adapterFor
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
.
adapterFor
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
{
_adapterCache
}
=
this
;
var
adapter
=
_adapterCache
[
normalizedModelName
]
;
if
(
adapter
)
{
return
adapter
;
}
var
owner
=
getOwner
(
this
)
;
adapter
=
owner
.
lookup
(
adapter
:
{
normalizedModelName
}
)
;
if
(
adapter
!
=
=
undefined
)
{
Ember
.
set
(
adapter
'
store
'
this
)
;
_adapterCache
[
normalizedModelName
]
=
adapter
;
return
adapter
;
}
adapter
=
_adapterCache
.
application
|
|
owner
.
lookup
(
'
adapter
:
application
'
)
;
if
(
adapter
!
=
=
undefined
)
{
Ember
.
set
(
adapter
'
store
'
this
)
;
_adapterCache
[
normalizedModelName
]
=
adapter
;
_adapterCache
.
application
=
adapter
;
return
adapter
;
}
var
adapterName
=
this
.
get
(
'
adapter
'
)
;
adapter
=
_adapterCache
[
adapterName
]
|
|
owner
.
lookup
(
adapter
:
{
adapterName
}
)
;
if
(
adapter
!
=
=
undefined
)
{
Ember
.
set
(
adapter
'
store
'
this
)
;
_adapterCache
[
normalizedModelName
]
=
adapter
;
_adapterCache
[
adapterName
]
=
adapter
;
return
adapter
;
}
adapter
=
_adapterCache
[
'
-
json
-
api
'
]
|
|
owner
.
lookup
(
'
adapter
:
-
json
-
api
'
)
;
Ember
.
set
(
adapter
'
store
'
this
)
;
_adapterCache
[
normalizedModelName
]
=
adapter
;
_adapterCache
[
'
-
json
-
api
'
]
=
adapter
;
return
adapter
;
}
serializerFor
(
modelName
)
{
(
true
&
&
!
(
Ember
.
isPresent
(
modelName
)
)
&
&
Ember
.
assert
(
You
need
to
pass
a
model
name
to
the
store
'
s
serializerFor
method
Ember
.
isPresent
(
modelName
)
)
)
;
(
true
&
&
!
(
typeof
modelName
=
=
=
'
string
'
)
&
&
Ember
.
assert
(
Passing
classes
to
store
.
serializerFor
has
been
removed
.
Please
pass
a
dasherized
string
instead
of
{
modelName
}
typeof
modelName
=
=
=
'
string
'
)
)
;
var
normalizedModelName
=
normalizeModelName
(
modelName
)
;
var
{
_serializerCache
}
=
this
;
var
serializer
=
_serializerCache
[
normalizedModelName
]
;
if
(
serializer
)
{
return
serializer
;
}
var
owner
=
getOwner
(
this
)
;
serializer
=
owner
.
lookup
(
serializer
:
{
normalizedModelName
}
)
;
if
(
serializer
!
=
=
undefined
)
{
Ember
.
set
(
serializer
'
store
'
this
)
;
_serializerCache
[
normalizedModelName
]
=
serializer
;
return
serializer
;
}
serializer
=
_serializerCache
.
application
|
|
owner
.
lookup
(
'
serializer
:
application
'
)
;
if
(
serializer
!
=
=
undefined
)
{
Ember
.
set
(
serializer
'
store
'
this
)
;
_serializerCache
[
normalizedModelName
]
=
serializer
;
_serializerCache
.
application
=
serializer
;
return
serializer
;
}
var
adapter
=
this
.
adapterFor
(
modelName
)
;
var
serializerName
=
Ember
.
get
(
adapter
'
defaultSerializer
'
)
;
serializer
=
_serializerCache
[
serializerName
]
|
|
owner
.
lookup
(
serializer
:
{
serializerName
}
)
;
if
(
serializer
!
=
=
undefined
)
{
Ember
.
set
(
serializer
'
store
'
this
)
;
_serializerCache
[
normalizedModelName
]
=
serializer
;
_serializerCache
[
serializerName
]
=
serializer
;
return
serializer
;
}
serializer
=
_serializerCache
[
'
-
default
'
]
|
|
owner
.
lookup
(
'
serializer
:
-
default
'
)
;
Ember
.
set
(
serializer
'
store
'
this
)
;
_serializerCache
[
normalizedModelName
]
=
serializer
;
_serializerCache
[
'
-
default
'
]
=
serializer
;
return
serializer
;
}
lookupAdapter
(
name
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
Use
of
lookupAdapter
is
deprecated
use
adapterFor
instead
.
false
{
id
:
'
ds
.
store
.
lookupAdapter
'
until
:
'
3
.
0
'
}
)
)
;
return
this
.
adapterFor
(
name
)
;
}
lookupSerializer
(
name
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
Use
of
lookupSerializer
is
deprecated
use
serializerFor
instead
.
false
{
id
:
'
ds
.
store
.
lookupSerializer
'
until
:
'
3
.
0
'
}
)
)
;
return
this
.
serializerFor
(
name
)
;
}
willDestroy
(
)
{
this
.
_super
(
.
.
.
arguments
)
;
this
.
_pushedInternalModels
=
null
;
this
.
recordArrayManager
.
destroy
(
)
;
this
.
_adapterCache
=
null
;
this
.
_serializerCache
=
null
;
this
.
unloadAll
(
)
;
}
_updateRelationshipState
(
relationship
)
{
if
(
this
.
_updatedRelationships
.
push
(
relationship
)
!
=
=
1
)
{
return
;
}
this
.
_backburner
.
join
(
(
)
=
>
{
this
.
_backburner
.
schedule
(
'
syncRelationships
'
this
this
.
_flushUpdatedRelationships
)
;
}
)
;
}
_flushUpdatedRelationships
(
)
{
var
updated
=
this
.
_updatedRelationships
;
for
(
var
i
=
0
l
=
updated
.
length
;
i
<
l
;
i
+
+
)
{
updated
[
i
]
.
flushCanonical
(
)
;
}
updated
.
length
=
0
;
}
_updateInternalModel
(
internalModel
)
{
if
(
this
.
_updatedInternalModels
.
push
(
internalModel
)
!
=
=
1
)
{
return
;
}
Ember
.
run
.
schedule
(
'
actions
'
this
this
.
_flushUpdatedInternalModels
)
;
}
_flushUpdatedInternalModels
(
)
{
var
updated
=
this
.
_updatedInternalModels
;
for
(
var
i
=
0
l
=
updated
.
length
;
i
<
l
;
i
+
+
)
{
updated
[
i
]
.
_triggerDeferredTriggers
(
)
;
}
updated
.
length
=
0
;
}
_pushResourceIdentifier
(
relationship
resourceIdentifier
)
{
if
(
Ember
.
isNone
(
resourceIdentifier
)
)
{
return
;
}
(
true
&
&
!
(
!
Array
.
isArray
(
resourceIdentifier
)
)
&
&
Ember
.
assert
(
A
{
relationship
.
internalModel
.
modelName
}
record
was
pushed
into
the
store
with
the
value
of
{
relationship
.
key
}
being
{
Ember
.
inspect
(
resourceIdentifier
)
}
but
{
relationship
.
key
}
is
a
belongsTo
relationship
so
the
value
must
not
be
an
array
.
You
should
probably
check
your
data
payload
or
serializer
.
!
Array
.
isArray
(
resourceIdentifier
)
)
)
;
return
this
.
_internalModelForId
(
resourceIdentifier
.
type
resourceIdentifier
.
id
)
;
}
_pushResourceIdentifiers
(
relationship
resourceIdentifiers
)
{
if
(
Ember
.
isNone
(
resourceIdentifiers
)
)
{
return
;
}
(
true
&
&
!
(
Array
.
isArray
(
resourceIdentifiers
)
)
&
&
Ember
.
assert
(
A
{
relationship
.
internalModel
.
modelName
}
record
was
pushed
into
the
store
with
the
value
of
{
relationship
.
key
}
being
'
{
Ember
.
inspect
(
resourceIdentifiers
)
}
'
but
{
relationship
.
key
}
is
a
hasMany
relationship
so
the
value
must
be
an
array
.
You
should
probably
check
your
data
payload
or
serializer
.
Array
.
isArray
(
resourceIdentifiers
)
)
)
;
var
_internalModels
=
new
Array
(
resourceIdentifiers
.
length
)
;
for
(
var
i
=
0
;
i
<
resourceIdentifiers
.
length
;
i
+
+
)
{
_internalModels
[
i
]
=
this
.
_pushResourceIdentifier
(
relationship
resourceIdentifiers
[
i
]
)
;
}
return
_internalModels
;
}
}
)
;
function
defaultSerializer
(
store
)
{
return
store
.
serializerFor
(
'
application
'
)
;
}
function
_commit
(
adapter
store
operation
snapshot
)
{
var
internalModel
=
snapshot
.
_internalModel
;
var
modelName
=
snapshot
.
modelName
;
var
modelClass
=
store
.
_modelFor
(
modelName
)
;
(
true
&
&
!
(
adapter
)
&
&
Ember
.
assert
(
You
tried
to
update
a
record
but
you
have
no
adapter
(
for
{
modelName
}
)
adapter
)
)
;
(
true
&
&
!
(
typeof
adapter
[
operation
]
=
=
=
'
function
'
)
&
&
Ember
.
assert
(
You
tried
to
update
a
record
but
your
adapter
(
for
{
modelName
}
)
does
not
implement
'
{
operation
}
'
typeof
adapter
[
operation
]
=
=
=
'
function
'
)
)
;
var
promise
=
adapter
[
operation
]
(
store
modelClass
snapshot
)
;
var
serializer
=
serializerForAdapter
(
store
adapter
modelName
)
;
var
label
=
DS
:
Extract
and
notify
about
{
operation
}
completion
of
{
internalModel
}
;
(
true
&
&
!
(
promise
!
=
=
undefined
)
&
&
Ember
.
assert
(
Your
adapter
'
s
'
{
operation
}
'
method
must
return
a
value
but
it
returned
'
undefined
'
promise
!
=
=
undefined
)
)
;
promise
=
Promise
.
resolve
(
promise
label
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
store
)
)
;
promise
=
_guard
(
promise
_bind
(
_objectIsAlive
internalModel
)
)
;
return
promise
.
then
(
adapterPayload
=
>
{
store
.
_backburner
.
join
(
(
)
=
>
{
var
payload
=
void
0
data
=
void
0
;
if
(
adapterPayload
)
{
payload
=
normalizeResponseHelper
(
serializer
store
modelClass
adapterPayload
snapshot
.
id
operation
)
;
if
(
payload
.
included
)
{
store
.
_push
(
{
data
:
null
included
:
payload
.
included
}
)
;
}
data
=
payload
.
data
;
}
store
.
didSaveRecord
(
internalModel
{
data
}
)
;
}
)
;
return
internalModel
;
}
function
(
error
)
{
if
(
error
instanceof
InvalidError
)
{
var
errors
=
serializer
.
extractErrors
(
store
modelClass
error
snapshot
.
id
)
;
store
.
recordWasInvalid
(
internalModel
errors
)
;
}
else
{
store
.
recordWasError
(
internalModel
error
)
;
}
throw
error
;
}
label
)
;
}
function
isInverseRelationshipInitialized
(
store
internalModel
data
key
modelNameToInverseMap
)
{
var
relationshipData
=
data
.
relationships
[
key
]
.
data
;
if
(
!
relationshipData
)
{
return
false
;
}
var
inverseMap
=
modelNameToInverseMap
[
internalModel
.
modelName
]
;
if
(
!
inverseMap
)
{
inverseMap
=
modelNameToInverseMap
[
internalModel
.
modelName
]
=
Ember
.
get
(
internalModel
.
type
'
inverseMap
'
)
;
}
var
inverseRelationshipMetadata
=
inverseMap
[
key
]
;
if
(
inverseRelationshipMetadata
=
=
=
undefined
)
{
inverseRelationshipMetadata
=
internalModel
.
type
.
inverseFor
(
key
store
)
;
}
if
(
!
inverseRelationshipMetadata
)
{
return
false
;
}
var
{
name
:
inverseRelationshipName
}
=
inverseRelationshipMetadata
;
if
(
Array
.
isArray
(
relationshipData
)
)
{
for
(
var
i
=
0
;
i
<
relationshipData
.
length
;
+
+
i
)
{
var
inverseInternalModel
=
store
.
_internalModelsFor
(
relationshipData
[
i
]
.
type
)
.
get
(
relationshipData
[
i
]
.
id
)
;
if
(
inverseInternalModel
&
&
inverseInternalModel
.
_relationships
.
has
(
inverseRelationshipName
)
)
{
return
true
;
}
}
return
false
;
}
else
{
var
_inverseInternalModel
=
store
.
_internalModelsFor
(
relationshipData
.
type
)
.
get
(
relationshipData
.
id
)
;
return
_inverseInternalModel
&
&
_inverseInternalModel
.
_relationships
.
has
(
inverseRelationshipName
)
;
}
}
function
setupRelationships
(
store
internalModel
data
modelNameToInverseMap
)
{
Object
.
keys
(
data
.
relationships
)
.
forEach
(
relationshipName
=
>
{
var
relationships
=
internalModel
.
_relationships
;
var
relationshipRequiresNotification
=
relationships
.
has
(
relationshipName
)
|
|
isInverseRelationshipInitialized
(
store
internalModel
data
relationshipName
modelNameToInverseMap
)
;
if
(
relationshipRequiresNotification
)
{
var
relationshipData
=
data
.
relationships
[
relationshipName
]
;
relationships
.
get
(
relationshipName
)
.
push
(
relationshipData
false
)
;
}
{
var
relationshipMeta
=
Ember
.
get
(
internalModel
.
type
'
relationshipsByName
'
)
.
get
(
relationshipName
)
;
var
_relationshipData
=
data
.
relationships
[
relationshipName
]
;
if
(
!
_relationshipData
|
|
!
relationshipMeta
)
{
return
;
}
if
(
_relationshipData
.
links
)
{
var
isAsync
=
relationshipMeta
.
options
&
&
relationshipMeta
.
options
.
async
!
=
=
false
;
(
true
&
&
Ember
.
warn
(
You
pushed
a
record
of
type
'
{
internalModel
.
type
.
modelName
}
'
with
a
relationship
'
{
relationshipName
}
'
configured
as
'
async
:
false
'
.
You
'
ve
included
a
link
but
no
primary
data
this
may
be
an
error
in
your
payload
.
isAsync
|
|
_relationshipData
.
data
{
id
:
'
ds
.
store
.
push
-
link
-
for
-
sync
-
relationship
'
}
)
)
;
}
else
if
(
_relationshipData
.
data
)
{
if
(
relationshipMeta
.
kind
=
=
=
'
belongsTo
'
)
{
(
true
&
&
!
(
!
Array
.
isArray
(
_relationshipData
.
data
)
)
&
&
Ember
.
assert
(
A
{
internalModel
.
type
.
modelName
}
record
was
pushed
into
the
store
with
the
value
of
{
relationshipName
}
being
{
Ember
.
inspect
(
_relationshipData
.
data
)
}
but
{
relationshipName
}
is
a
belongsTo
relationship
so
the
value
must
not
be
an
array
.
You
should
probably
check
your
data
payload
or
serializer
.
!
Array
.
isArray
(
_relationshipData
.
data
)
)
)
;
}
else
if
(
relationshipMeta
.
kind
=
=
=
'
hasMany
'
)
{
(
true
&
&
!
(
Array
.
isArray
(
_relationshipData
.
data
)
)
&
&
Ember
.
assert
(
A
{
internalModel
.
type
.
modelName
}
record
was
pushed
into
the
store
with
the
value
of
{
relationshipName
}
being
'
{
Ember
.
inspect
(
_relationshipData
.
data
)
}
'
but
{
relationshipName
}
is
a
hasMany
relationship
so
the
value
must
be
an
array
.
You
should
probably
check
your
data
payload
or
serializer
.
Array
.
isArray
(
_relationshipData
.
data
)
)
)
;
}
}
}
}
)
;
}
var
Store
1
=
Store
;
var
DS
=
Ember
.
Namespace
.
create
(
{
VERSION
:
VERSION
name
:
"
DS
"
}
)
;
if
(
Ember
.
libraries
)
{
Ember
.
libraries
.
registerCoreLibrary
(
'
Ember
Data
'
DS
.
VERSION
)
;
}
function
belongsTo
(
modelName
options
)
{
var
opts
=
void
0
userEnteredModelName
=
void
0
;
if
(
typeof
modelName
=
=
=
'
object
'
)
{
opts
=
modelName
;
userEnteredModelName
=
undefined
;
}
else
{
opts
=
options
;
userEnteredModelName
=
modelName
;
}
if
(
typeof
userEnteredModelName
=
=
=
'
string
'
)
{
userEnteredModelName
=
normalizeModelName
(
userEnteredModelName
)
;
}
(
true
&
&
!
(
typeof
userEnteredModelName
=
=
=
'
string
'
|
|
typeof
userEnteredModelName
=
=
=
'
undefined
'
)
&
&
Ember
.
assert
(
"
The
first
argument
to
DS
.
belongsTo
must
be
a
string
representing
a
model
type
key
not
an
instance
of
"
+
Ember
.
inspect
(
userEnteredModelName
)
+
"
.
E
.
g
.
to
define
a
relation
to
the
Person
model
use
DS
.
belongsTo
(
'
person
'
)
"
typeof
userEnteredModelName
=
=
=
'
string
'
|
|
typeof
userEnteredModelName
=
=
=
'
undefined
'
)
)
;
opts
=
opts
|
|
{
}
;
var
meta
=
{
type
:
userEnteredModelName
isRelationship
:
true
options
:
opts
kind
:
'
belongsTo
'
name
:
'
Belongs
To
'
key
:
null
}
;
return
Ember
.
computed
(
{
get
(
key
)
{
if
(
opts
.
hasOwnProperty
(
'
serialize
'
)
)
{
(
true
&
&
Ember
.
warn
(
You
provided
a
serialize
option
on
the
"
{
key
}
"
property
in
the
"
{
this
.
_internalModel
.
modelName
}
"
class
this
belongs
in
the
serializer
.
See
DS
.
Serializer
and
it
'
s
implementations
https
:
/
/
emberjs
.
com
/
api
/
data
/
classes
/
DS
.
Serializer
.
html
false
{
id
:
'
ds
.
model
.
serialize
-
option
-
in
-
belongs
-
to
'
}
)
)
;
}
if
(
opts
.
hasOwnProperty
(
'
embedded
'
)
)
{
(
true
&
&
Ember
.
warn
(
You
provided
an
embedded
option
on
the
"
{
key
}
"
property
in
the
"
{
this
.
_internalModel
.
modelName
}
"
class
this
belongs
in
the
serializer
.
See
DS
.
EmbeddedRecordsMixin
https
:
/
/
emberjs
.
com
/
api
/
data
/
classes
/
DS
.
EmbeddedRecordsMixin
.
html
false
{
id
:
'
ds
.
model
.
embedded
-
option
-
in
-
belongs
-
to
'
}
)
)
;
}
return
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
getRecord
(
)
;
}
set
(
key
value
)
{
if
(
value
=
=
=
undefined
)
{
value
=
null
;
}
if
(
value
&
&
value
.
then
)
{
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
setRecordPromise
(
value
)
;
}
else
if
(
value
)
{
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
setInternalModel
(
value
.
_internalModel
)
;
}
else
{
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
setInternalModel
(
value
)
;
}
return
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
getRecord
(
)
;
}
}
)
.
meta
(
meta
)
;
}
function
isArrayLike
(
obj
)
{
if
(
!
obj
|
|
obj
.
setInterval
)
{
return
false
;
}
if
(
Array
.
isArray
(
obj
)
)
{
return
true
;
}
if
(
Ember
.
Array
.
detect
(
obj
)
)
{
return
true
;
}
var
type
=
Ember
.
typeOf
(
obj
)
;
if
(
'
array
'
=
=
=
type
)
{
return
true
;
}
if
(
obj
.
length
!
=
=
undefined
&
&
'
object
'
=
=
=
type
)
{
return
true
;
}
return
false
;
}
function
hasMany
(
type
options
)
{
if
(
typeof
type
=
=
=
'
object
'
)
{
options
=
type
;
type
=
undefined
;
}
(
true
&
&
!
(
typeof
type
=
=
=
'
string
'
|
|
typeof
type
=
=
=
'
undefined
'
)
&
&
Ember
.
assert
(
The
first
argument
to
DS
.
hasMany
must
be
a
string
representing
a
model
type
key
not
an
instance
of
{
Ember
.
inspect
(
type
)
}
.
E
.
g
.
to
define
a
relation
to
the
Comment
model
use
DS
.
hasMany
(
'
comment
'
)
typeof
type
=
=
=
'
string
'
|
|
typeof
type
=
=
=
'
undefined
'
)
)
;
options
=
options
|
|
{
}
;
if
(
typeof
type
=
=
=
'
string
'
)
{
type
=
normalizeModelName
(
type
)
;
}
var
meta
=
{
type
options
isRelationship
:
true
kind
:
'
hasMany
'
name
:
'
Has
Many
'
key
:
null
}
;
return
Ember
.
computed
(
{
get
(
key
)
{
return
this
.
_internalModel
.
_relationships
.
get
(
key
)
.
getRecords
(
)
;
}
set
(
key
records
)
{
(
true
&
&
!
(
isArrayLike
(
records
)
)
&
&
Ember
.
assert
(
You
must
pass
an
array
of
records
to
set
a
hasMany
relationship
isArrayLike
(
records
)
)
)
;
(
true
&
&
!
(
function
(
)
{
return
Ember
.
A
(
records
)
.
every
(
record
=
>
record
.
hasOwnProperty
(
'
_internalModel
'
)
=
=
=
true
)
;
}
(
)
)
&
&
Ember
.
assert
(
All
elements
of
a
hasMany
relationship
must
be
instances
of
DS
.
Model
you
passed
{
Ember
.
inspect
(
records
)
}
function
(
)
{
return
Ember
.
A
(
records
)
.
every
(
record
=
>
record
.
hasOwnProperty
(
'
_internalModel
'
)
=
=
=
true
)
;
}
(
)
)
)
;
var
relationship
=
this
.
_internalModel
.
_relationships
.
get
(
key
)
;
relationship
.
clear
(
)
;
relationship
.
addInternalModels
(
records
.
map
(
record
=
>
Ember
.
get
(
record
'
_internalModel
'
)
)
)
;
return
relationship
.
getRecords
(
)
;
}
}
)
.
meta
(
meta
)
;
}
var
buildUrlMixin
=
Ember
.
Mixin
.
create
(
{
buildURL
(
modelName
id
snapshot
requestType
query
)
{
switch
(
requestType
)
{
case
'
findRecord
'
:
return
this
.
urlForFindRecord
(
id
modelName
snapshot
)
;
case
'
findAll
'
:
return
this
.
urlForFindAll
(
modelName
snapshot
)
;
case
'
query
'
:
return
this
.
urlForQuery
(
query
modelName
)
;
case
'
queryRecord
'
:
return
this
.
urlForQueryRecord
(
query
modelName
)
;
case
'
findMany
'
:
return
this
.
urlForFindMany
(
id
modelName
snapshot
)
;
case
'
findHasMany
'
:
return
this
.
urlForFindHasMany
(
id
modelName
snapshot
)
;
case
'
findBelongsTo
'
:
return
this
.
urlForFindBelongsTo
(
id
modelName
snapshot
)
;
case
'
createRecord
'
:
return
this
.
urlForCreateRecord
(
modelName
snapshot
)
;
case
'
updateRecord
'
:
return
this
.
urlForUpdateRecord
(
id
modelName
snapshot
)
;
case
'
deleteRecord
'
:
return
this
.
urlForDeleteRecord
(
id
modelName
snapshot
)
;
default
:
return
this
.
_buildURL
(
modelName
id
)
;
}
}
_buildURL
(
modelName
id
)
{
var
path
=
void
0
;
var
url
=
[
]
;
var
host
=
Ember
.
get
(
this
'
host
'
)
;
var
prefix
=
this
.
urlPrefix
(
)
;
if
(
modelName
)
{
path
=
this
.
pathForType
(
modelName
)
;
if
(
path
)
{
url
.
push
(
path
)
;
}
}
if
(
id
)
{
url
.
push
(
encodeURIComponent
(
id
)
)
;
}
if
(
prefix
)
{
url
.
unshift
(
prefix
)
;
}
url
=
url
.
join
(
'
/
'
)
;
if
(
!
host
&
&
url
&
&
url
.
charAt
(
0
)
!
=
=
'
/
'
)
{
url
=
'
/
'
+
url
;
}
return
url
;
}
urlForFindRecord
(
id
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
id
)
;
}
urlForFindAll
(
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
)
;
}
urlForQuery
(
query
modelName
)
{
return
this
.
_buildURL
(
modelName
)
;
}
urlForQueryRecord
(
query
modelName
)
{
return
this
.
_buildURL
(
modelName
)
;
}
urlForFindMany
(
ids
modelName
snapshots
)
{
return
this
.
_buildURL
(
modelName
)
;
}
urlForFindHasMany
(
id
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
id
)
;
}
urlForFindBelongsTo
(
id
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
id
)
;
}
urlForCreateRecord
(
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
)
;
}
urlForUpdateRecord
(
id
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
id
)
;
}
urlForDeleteRecord
(
id
modelName
snapshot
)
{
return
this
.
_buildURL
(
modelName
id
)
;
}
urlPrefix
(
path
parentURL
)
{
var
host
=
Ember
.
get
(
this
'
host
'
)
;
var
namespace
=
Ember
.
get
(
this
'
namespace
'
)
;
if
(
!
host
|
|
host
=
=
=
'
/
'
)
{
host
=
'
'
;
}
if
(
path
)
{
if
(
/
^
\
/
\
/
/
.
test
(
path
)
|
|
/
http
(
s
)
?
:
\
/
\
/
/
.
test
(
path
)
)
{
return
path
;
}
else
if
(
path
.
charAt
(
0
)
=
=
=
'
/
'
)
{
return
{
host
}
{
path
}
;
}
else
{
return
{
parentURL
}
/
{
path
}
;
}
}
var
url
=
[
]
;
if
(
host
)
{
url
.
push
(
host
)
;
}
if
(
namespace
)
{
url
.
push
(
namespace
)
;
}
return
url
.
join
(
'
/
'
)
;
}
pathForType
(
modelName
)
{
var
camelized
=
Ember
.
String
.
camelize
(
modelName
)
;
return
emberInflector
.
pluralize
(
camelized
)
;
}
}
)
;
var
CLRF
=
'
\
u000d
\
u000a
'
;
function
parseResponseHeaders
(
headersString
)
{
var
headers
=
Object
.
create
(
null
)
;
if
(
!
headersString
)
{
return
headers
;
}
var
headerPairs
=
headersString
.
split
(
CLRF
)
;
for
(
var
i
=
0
;
i
<
headerPairs
.
length
;
i
+
+
)
{
var
header
=
headerPairs
[
i
]
;
var
j
=
0
;
var
foundSep
=
false
;
for
(
;
j
<
header
.
length
;
j
+
+
)
{
if
(
header
.
charCodeAt
(
j
)
=
=
=
58
)
{
foundSep
=
true
;
break
;
}
}
if
(
foundSep
=
=
=
false
)
{
continue
;
}
var
field
=
header
.
substring
(
0
j
)
.
trim
(
)
;
var
value
=
header
.
substring
(
j
+
1
header
.
length
)
.
trim
(
)
;
if
(
value
)
{
headers
[
field
]
=
value
;
}
}
return
headers
;
}
var
debugAdapter
=
Ember
.
DataAdapter
.
extend
(
{
getFilters
(
)
{
return
[
{
name
:
'
isNew
'
desc
:
'
New
'
}
{
name
:
'
isModified
'
desc
:
'
Modified
'
}
{
name
:
'
isClean
'
desc
:
'
Clean
'
}
]
;
}
detect
(
typeClass
)
{
return
typeClass
!
=
=
Model
&
&
Model
.
detect
(
typeClass
)
;
}
columnsForType
(
typeClass
)
{
var
columns
=
[
{
name
:
'
id
'
desc
:
'
Id
'
}
]
;
var
count
=
0
;
var
self
=
this
;
Ember
.
get
(
typeClass
'
attributes
'
)
.
forEach
(
(
meta
name
)
=
>
{
if
(
count
+
+
>
self
.
attributeLimit
)
{
return
false
;
}
var
desc
=
Ember
.
String
.
capitalize
(
Ember
.
String
.
underscore
(
name
)
.
replace
(
'
_
'
'
'
)
)
;
columns
.
push
(
{
name
:
name
desc
:
desc
}
)
;
}
)
;
return
columns
;
}
getRecords
(
modelClass
modelName
)
{
if
(
arguments
.
length
<
2
)
{
var
containerKey
=
modelClass
.
_debugContainerKey
;
if
(
containerKey
)
{
var
match
=
containerKey
.
match
(
/
model
:
(
.
*
)
/
)
;
if
(
match
!
=
=
null
)
{
modelName
=
match
[
1
]
;
}
}
}
(
true
&
&
!
(
!
!
modelName
)
&
&
Ember
.
assert
(
"
Cannot
find
model
name
.
Please
upgrade
to
Ember
.
js
>
=
1
.
13
for
Ember
Inspector
support
"
!
!
modelName
)
)
;
return
this
.
get
(
'
store
'
)
.
peekAll
(
modelName
)
;
}
getRecordColumnValues
(
record
)
{
var
count
=
0
;
var
columnValues
=
{
id
:
Ember
.
get
(
record
'
id
'
)
}
;
record
.
eachAttribute
(
key
=
>
{
if
(
count
+
+
>
this
.
attributeLimit
)
{
return
false
;
}
columnValues
[
key
]
=
Ember
.
get
(
record
key
)
;
}
)
;
return
columnValues
;
}
getRecordKeywords
(
record
)
{
var
keywords
=
[
]
;
var
keys
=
Ember
.
A
(
[
'
id
'
]
)
;
record
.
eachAttribute
(
key
=
>
keys
.
push
(
key
)
)
;
keys
.
forEach
(
key
=
>
keywords
.
push
(
Ember
.
get
(
record
key
)
)
)
;
return
keywords
;
}
getRecordFilterValues
(
record
)
{
return
{
isNew
:
record
.
get
(
'
isNew
'
)
isModified
:
record
.
get
(
'
hasDirtyAttributes
'
)
&
&
!
record
.
get
(
'
isNew
'
)
isClean
:
!
record
.
get
(
'
hasDirtyAttributes
'
)
}
;
}
getRecordColor
(
record
)
{
var
color
=
'
black
'
;
if
(
record
.
get
(
'
isNew
'
)
)
{
color
=
'
green
'
;
}
else
if
(
record
.
get
(
'
hasDirtyAttributes
'
)
)
{
color
=
'
blue
'
;
}
return
color
;
}
observeRecord
(
record
recordUpdated
)
{
var
releaseMethods
=
Ember
.
A
(
)
;
var
keysToObserve
=
Ember
.
A
(
[
'
id
'
'
isNew
'
'
hasDirtyAttributes
'
]
)
;
record
.
eachAttribute
(
key
=
>
keysToObserve
.
push
(
key
)
)
;
var
adapter
=
this
;
keysToObserve
.
forEach
(
function
(
key
)
{
var
handler
=
function
(
)
{
recordUpdated
(
adapter
.
wrapRecord
(
record
)
)
;
}
;
Ember
.
addObserver
(
record
key
handler
)
;
releaseMethods
.
push
(
function
(
)
{
Ember
.
removeObserver
(
record
key
handler
)
;
}
)
;
}
)
;
var
release
=
function
(
)
{
releaseMethods
.
forEach
(
fn
=
>
fn
(
)
)
;
}
;
return
release
;
}
}
)
;
exports
.
Model
=
Model
;
exports
.
Errors
=
Errors
;
exports
.
Store
=
Store
1
;
exports
.
DS
=
DS
;
exports
.
belongsTo
=
belongsTo
;
exports
.
hasMany
=
hasMany
;
exports
.
BuildURLMixin
=
buildUrlMixin
;
exports
.
Snapshot
=
Snapshot
;
exports
.
AdapterError
=
AdapterError
;
exports
.
InvalidError
=
InvalidError
;
exports
.
UnauthorizedError
=
UnauthorizedError
;
exports
.
ForbiddenError
=
ForbiddenError
;
exports
.
NotFoundError
=
NotFoundError
;
exports
.
ConflictError
=
ConflictError
;
exports
.
ServerError
=
ServerError
;
exports
.
TimeoutError
=
TimeoutError
;
exports
.
AbortError
=
AbortError
;
exports
.
errorsHashToArray
=
errorsHashToArray
;
exports
.
errorsArrayToHash
=
errorsArrayToHash
;
exports
.
normalizeModelName
=
normalizeModelName
;
exports
.
getOwner
=
getOwner
;
exports
.
modelHasAttributeOrRelationshipNamedType
=
modelHasAttributeOrRelationshipNamedType
;
exports
.
coerceId
=
coerceId
;
exports
.
parseResponseHeaders
=
parseResponseHeaders
;
exports
.
isEnabled
=
isEnabled
;
exports
.
RootState
=
RootState
1
;
exports
.
InternalModel
=
InternalModel
;
exports
.
PromiseArray
=
PromiseArray
;
exports
.
PromiseObject
=
PromiseObject
;
exports
.
PromiseManyArray
=
PromiseManyArray
;
exports
.
RecordArray
=
RecordArray
;
exports
.
FilteredRecordArray
=
FilteredRecordArray
;
exports
.
AdapterPopulatedRecordArray
=
AdapterPopulatedRecordArray
;
exports
.
ManyArray
=
ManyArray
;
exports
.
RecordArrayManager
=
RecordArrayManager
;
exports
.
Relationship
=
Relationship
;
exports
.
DebugAdapter
=
debugAdapter
;
exports
.
diffArray
=
diffArray
;
exports
.
RelationshipPayloadsManager
=
RelationshipPayloadsManager
;
exports
.
RelationshipPayloads
=
RelationshipPayloads
;
exports
.
SnapshotRecordArray
=
SnapshotRecordArray
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
adapter
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Object
.
extend
(
{
defaultSerializer
:
'
-
default
'
findRecord
:
null
findAll
:
null
query
:
null
queryRecord
:
null
generateIdForRecord
:
null
serialize
(
snapshot
options
)
{
return
snapshot
.
serialize
(
options
)
;
}
createRecord
:
null
updateRecord
:
null
deleteRecord
:
null
coalesceFindRequests
:
true
findMany
:
null
groupRecordsForFindMany
(
store
snapshots
)
{
return
[
snapshots
]
;
}
shouldReloadRecord
(
store
snapshot
)
{
return
false
;
}
shouldReloadAll
(
store
snapshotRecordArray
)
{
return
!
snapshotRecordArray
.
length
;
}
shouldBackgroundReloadRecord
(
store
snapshot
)
{
return
true
;
}
shouldBackgroundReloadAll
(
store
snapshotRecordArray
)
{
return
true
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
adapters
/
errors
'
[
'
exports
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
AdapterError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
AdapterError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
InvalidError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
InvalidError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
UnauthorizedError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
UnauthorizedError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ForbiddenError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
ForbiddenError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
NotFoundError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
NotFoundError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ConflictError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
ConflictError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
ServerError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
ServerError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TimeoutError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
TimeoutError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
AbortError
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
AbortError
;
}
}
)
;
Object
.
defineProperty
(
exports
'
errorsHashToArray
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
errorsHashToArray
;
}
}
)
;
Object
.
defineProperty
(
exports
'
errorsArrayToHash
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
errorsArrayToHash
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
adapters
/
json
-
api
'
[
'
exports
'
'
ember
-
data
/
adapters
/
rest
'
'
ember
-
data
/
-
private
'
'
ember
-
inflector
'
]
function
(
exports
_rest
_private
_emberInflector
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
JSONAPIAdapter
=
_rest
.
default
.
extend
(
{
defaultSerializer
:
'
-
json
-
api
'
ajaxOptions
(
url
type
options
)
{
var
hash
=
this
.
_super
(
.
.
.
arguments
)
;
if
(
hash
.
contentType
)
{
hash
.
contentType
=
'
application
/
vnd
.
api
+
json
'
;
}
var
beforeSend
=
hash
.
beforeSend
;
hash
.
beforeSend
=
function
(
xhr
)
{
xhr
.
setRequestHeader
(
'
Accept
'
'
application
/
vnd
.
api
+
json
'
)
;
if
(
beforeSend
)
{
beforeSend
(
xhr
)
;
}
}
;
return
hash
;
}
coalesceFindRequests
:
false
findMany
(
store
type
ids
snapshots
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
return
this
.
_super
(
.
.
.
arguments
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
ids
snapshots
'
findMany
'
)
;
return
this
.
ajax
(
url
'
GET
'
{
data
:
{
filter
:
{
id
:
ids
.
join
(
'
'
)
}
}
}
)
;
}
}
pathForType
(
modelName
)
{
var
dasherized
=
Ember
.
String
.
dasherize
(
modelName
)
;
return
(
0
_emberInflector
.
pluralize
)
(
dasherized
)
;
}
updateRecord
(
store
type
snapshot
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
return
this
.
_super
(
.
.
.
arguments
)
;
}
else
{
var
data
=
{
}
;
var
serializer
=
store
.
serializerFor
(
type
.
modelName
)
;
serializer
.
serializeIntoHash
(
data
type
snapshot
{
includeId
:
true
}
)
;
var
url
=
this
.
buildURL
(
type
.
modelName
snapshot
.
id
snapshot
'
updateRecord
'
)
;
return
this
.
ajax
(
url
'
PATCH
'
{
data
:
data
}
)
;
}
}
_hasCustomizedAjax
(
)
{
if
(
this
.
ajax
!
=
=
JSONAPIAdapter
.
prototype
.
ajax
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
JSONAPIAdapter
#
ajax
has
been
deprecated
please
use
.
methodForRequest
urlForRequest
headersForRequest
or
dataForRequest
instead
.
'
false
{
id
:
'
ds
.
json
-
api
-
adapter
.
ajax
'
until
:
'
3
.
0
.
0
'
}
)
)
;
return
true
;
}
if
(
this
.
ajaxOptions
!
=
=
JSONAPIAdapter
.
prototype
.
ajaxOptions
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
JSONAPIAdapterr
#
ajaxOptions
has
been
deprecated
please
use
.
methodForRequest
urlForRequest
headersForRequest
or
dataForRequest
instead
.
'
false
{
id
:
'
ds
.
json
-
api
-
adapter
.
ajax
-
options
'
until
:
'
3
.
0
.
0
'
}
)
)
;
return
true
;
}
return
false
;
}
}
)
;
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
)
{
JSONAPIAdapter
.
reopen
(
{
methodForRequest
(
params
)
{
if
(
params
.
requestType
=
=
=
'
updateRecord
'
)
{
return
'
PATCH
'
;
}
return
this
.
_super
(
.
.
.
arguments
)
;
}
dataForRequest
(
params
)
{
var
{
requestType
ids
}
=
params
;
if
(
requestType
=
=
=
'
findMany
'
)
{
return
{
filter
:
{
id
:
ids
.
join
(
'
'
)
}
}
;
}
if
(
requestType
=
=
=
'
updateRecord
'
)
{
var
{
store
type
snapshot
}
=
params
;
var
data
=
{
}
;
var
serializer
=
store
.
serializerFor
(
type
.
modelName
)
;
serializer
.
serializeIntoHash
(
data
type
snapshot
{
includeId
:
true
}
)
;
return
data
;
}
return
this
.
_super
(
.
.
.
arguments
)
;
}
headersForRequest
(
)
{
var
headers
=
this
.
_super
(
.
.
.
arguments
)
|
|
{
}
;
headers
[
'
Accept
'
]
=
'
application
/
vnd
.
api
+
json
'
;
return
headers
;
}
_requestToJQueryAjaxHash
(
)
{
var
hash
=
this
.
_super
(
.
.
.
arguments
)
;
if
(
hash
.
contentType
)
{
hash
.
contentType
=
'
application
/
vnd
.
api
+
json
'
;
}
return
hash
;
}
}
)
;
}
exports
.
default
=
JSONAPIAdapter
;
}
)
;
;
define
(
'
ember
-
data
/
adapters
/
rest
'
[
'
exports
'
'
ember
-
data
/
adapter
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_adapter
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
Promise
=
Ember
.
RSVP
.
Promise
;
var
RESTAdapter
=
_adapter
.
default
.
extend
(
_private
.
BuildURLMixin
{
defaultSerializer
:
'
-
rest
'
sortQueryParams
(
obj
)
{
var
keys
=
Object
.
keys
(
obj
)
;
var
len
=
keys
.
length
;
if
(
len
<
2
)
{
return
obj
;
}
var
newQueryParams
=
{
}
;
var
sortedKeys
=
keys
.
sort
(
)
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
newQueryParams
[
sortedKeys
[
i
]
]
=
obj
[
sortedKeys
[
i
]
]
;
}
return
newQueryParams
;
}
coalesceFindRequests
:
false
findRecord
(
store
type
id
snapshot
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
id
snapshot
requestType
:
'
findRecord
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
id
snapshot
'
findRecord
'
)
;
var
query
=
this
.
buildQuery
(
snapshot
)
;
return
this
.
ajax
(
url
'
GET
'
{
data
:
query
}
)
;
}
}
findAll
(
store
type
sinceToken
snapshotRecordArray
)
{
var
query
=
this
.
buildQuery
(
snapshotRecordArray
)
;
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
sinceToken
query
snapshots
:
snapshotRecordArray
requestType
:
'
findAll
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
null
snapshotRecordArray
'
findAll
'
)
;
if
(
sinceToken
)
{
query
.
since
=
sinceToken
;
}
return
this
.
ajax
(
url
'
GET
'
{
data
:
query
}
)
;
}
}
query
(
store
type
query
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
query
requestType
:
'
query
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
null
null
'
query
'
query
)
;
if
(
this
.
sortQueryParams
)
{
query
=
this
.
sortQueryParams
(
query
)
;
}
return
this
.
ajax
(
url
'
GET
'
{
data
:
query
}
)
;
}
}
queryRecord
(
store
type
query
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
query
requestType
:
'
queryRecord
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
null
null
'
queryRecord
'
query
)
;
if
(
this
.
sortQueryParams
)
{
query
=
this
.
sortQueryParams
(
query
)
;
}
return
this
.
ajax
(
url
'
GET
'
{
data
:
query
}
)
;
}
}
findMany
(
store
type
ids
snapshots
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
ids
snapshots
requestType
:
'
findMany
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
url
=
this
.
buildURL
(
type
.
modelName
ids
snapshots
'
findMany
'
)
;
return
this
.
ajax
(
url
'
GET
'
{
data
:
{
ids
:
ids
}
}
)
;
}
}
findHasMany
(
store
snapshot
url
relationship
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
snapshot
url
relationship
requestType
:
'
findHasMany
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
id
=
snapshot
.
id
;
var
type
=
snapshot
.
modelName
;
url
=
this
.
urlPrefix
(
url
this
.
buildURL
(
type
id
snapshot
'
findHasMany
'
)
)
;
return
this
.
ajax
(
url
'
GET
'
)
;
}
}
findBelongsTo
(
store
snapshot
url
relationship
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
snapshot
url
relationship
requestType
:
'
findBelongsTo
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
id
=
snapshot
.
id
;
var
type
=
snapshot
.
modelName
;
url
=
this
.
urlPrefix
(
url
this
.
buildURL
(
type
id
snapshot
'
findBelongsTo
'
)
)
;
return
this
.
ajax
(
url
'
GET
'
)
;
}
}
createRecord
(
store
type
snapshot
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
snapshot
requestType
:
'
createRecord
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
data
=
{
}
;
var
serializer
=
store
.
serializerFor
(
type
.
modelName
)
;
var
url
=
this
.
buildURL
(
type
.
modelName
null
snapshot
'
createRecord
'
)
;
serializer
.
serializeIntoHash
(
data
type
snapshot
{
includeId
:
true
}
)
;
return
this
.
ajax
(
url
"
POST
"
{
data
:
data
}
)
;
}
}
updateRecord
(
store
type
snapshot
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
snapshot
requestType
:
'
updateRecord
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
data
=
{
}
;
var
serializer
=
store
.
serializerFor
(
type
.
modelName
)
;
serializer
.
serializeIntoHash
(
data
type
snapshot
)
;
var
id
=
snapshot
.
id
;
var
url
=
this
.
buildURL
(
type
.
modelName
id
snapshot
'
updateRecord
'
)
;
return
this
.
ajax
(
url
"
PUT
"
{
data
:
data
}
)
;
}
}
deleteRecord
(
store
type
snapshot
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
&
&
!
this
.
_hasCustomizedAjax
(
)
)
{
var
request
=
this
.
_requestFor
(
{
store
type
snapshot
requestType
:
'
deleteRecord
'
}
)
;
return
this
.
_makeRequest
(
request
)
;
}
else
{
var
id
=
snapshot
.
id
;
return
this
.
ajax
(
this
.
buildURL
(
type
.
modelName
id
snapshot
'
deleteRecord
'
)
"
DELETE
"
)
;
}
}
_stripIDFromURL
(
store
snapshot
)
{
var
url
=
this
.
buildURL
(
snapshot
.
modelName
snapshot
.
id
snapshot
)
;
var
expandedURL
=
url
.
split
(
'
/
'
)
;
var
lastSegment
=
expandedURL
[
expandedURL
.
length
-
1
]
;
var
id
=
snapshot
.
id
;
if
(
decodeURIComponent
(
lastSegment
)
=
=
=
id
)
{
expandedURL
[
expandedURL
.
length
-
1
]
=
"
"
;
}
else
if
(
endsWith
(
lastSegment
'
?
id
=
'
+
id
)
)
{
expandedURL
[
expandedURL
.
length
-
1
]
=
lastSegment
.
substring
(
0
lastSegment
.
length
-
id
.
length
-
1
)
;
}
return
expandedURL
.
join
(
'
/
'
)
;
}
maxURLLength
:
2048
groupRecordsForFindMany
(
store
snapshots
)
{
var
groups
=
Ember
.
MapWithDefault
.
create
(
{
defaultValue
(
)
{
return
[
]
;
}
}
)
;
var
adapter
=
this
;
var
maxURLLength
=
this
.
maxURLLength
;
snapshots
.
forEach
(
snapshot
=
>
{
var
baseUrl
=
adapter
.
_stripIDFromURL
(
store
snapshot
)
;
groups
.
get
(
baseUrl
)
.
push
(
snapshot
)
;
}
)
;
function
splitGroupToFitInUrl
(
group
maxURLLength
paramNameLength
)
{
var
idsSize
=
0
;
var
baseUrl
=
adapter
.
_stripIDFromURL
(
store
group
[
0
]
)
;
var
splitGroups
=
[
[
]
]
;
group
.
forEach
(
snapshot
=
>
{
var
additionalLength
=
encodeURIComponent
(
snapshot
.
id
)
.
length
+
paramNameLength
;
if
(
baseUrl
.
length
+
idsSize
+
additionalLength
>
=
maxURLLength
)
{
idsSize
=
0
;
splitGroups
.
push
(
[
]
)
;
}
idsSize
+
=
additionalLength
;
var
lastGroupIndex
=
splitGroups
.
length
-
1
;
splitGroups
[
lastGroupIndex
]
.
push
(
snapshot
)
;
}
)
;
return
splitGroups
;
}
var
groupsArray
=
[
]
;
groups
.
forEach
(
(
group
key
)
=
>
{
var
paramNameLength
=
'
&
ids
%
5B
%
5D
=
'
.
length
;
var
splitGroups
=
splitGroupToFitInUrl
(
group
maxURLLength
paramNameLength
)
;
splitGroups
.
forEach
(
splitGroup
=
>
groupsArray
.
push
(
splitGroup
)
)
;
}
)
;
return
groupsArray
;
}
handleResponse
(
status
headers
payload
requestData
)
{
if
(
this
.
isSuccess
(
status
headers
payload
)
)
{
return
payload
;
}
else
if
(
this
.
isInvalid
(
status
headers
payload
)
)
{
return
new
_private
.
InvalidError
(
payload
.
errors
)
;
}
var
errors
=
this
.
normalizeErrorResponse
(
status
headers
payload
)
;
var
detailedMessage
=
this
.
generatedDetailedMessage
(
status
headers
payload
requestData
)
;
switch
(
status
)
{
case
401
:
return
new
_private
.
UnauthorizedError
(
errors
detailedMessage
)
;
case
403
:
return
new
_private
.
ForbiddenError
(
errors
detailedMessage
)
;
case
404
:
return
new
_private
.
NotFoundError
(
errors
detailedMessage
)
;
case
409
:
return
new
_private
.
ConflictError
(
errors
detailedMessage
)
;
default
:
if
(
status
>
=
500
)
{
return
new
_private
.
ServerError
(
errors
detailedMessage
)
;
}
}
return
new
_private
.
AdapterError
(
errors
detailedMessage
)
;
}
isSuccess
(
status
headers
payload
)
{
return
status
>
=
200
&
&
status
<
300
|
|
status
=
=
=
304
;
}
isInvalid
(
status
headers
payload
)
{
return
status
=
=
=
422
;
}
ajax
(
url
type
options
)
{
var
adapter
=
this
;
var
requestData
=
{
url
:
url
method
:
type
}
;
return
new
Promise
(
function
(
resolve
reject
)
{
var
hash
=
adapter
.
ajaxOptions
(
url
type
options
)
;
hash
.
success
=
function
(
payload
textStatus
jqXHR
)
{
var
response
=
ajaxSuccess
(
adapter
jqXHR
payload
requestData
)
;
Ember
.
run
.
join
(
null
resolve
response
)
;
}
;
hash
.
error
=
function
(
jqXHR
textStatus
errorThrown
)
{
var
responseData
=
{
textStatus
errorThrown
}
;
var
error
=
ajaxError
(
adapter
jqXHR
requestData
responseData
)
;
Ember
.
run
.
join
(
null
reject
error
)
;
}
;
adapter
.
_ajaxRequest
(
hash
)
;
}
'
DS
:
RESTAdapter
#
ajax
'
+
type
+
'
to
'
+
url
)
;
}
_ajaxRequest
(
options
)
{
Ember
.
.
ajax
(
options
)
;
}
ajaxOptions
(
url
type
options
)
{
var
hash
=
options
|
|
{
}
;
hash
.
url
=
url
;
hash
.
type
=
type
;
hash
.
dataType
=
'
json
'
;
hash
.
context
=
this
;
if
(
hash
.
data
&
&
type
!
=
=
'
GET
'
)
{
hash
.
contentType
=
'
application
/
json
;
charset
=
utf
-
8
'
;
hash
.
data
=
JSON
.
stringify
(
hash
.
data
)
;
}
var
headers
=
Ember
.
get
(
this
'
headers
'
)
;
if
(
headers
!
=
=
undefined
)
{
hash
.
beforeSend
=
function
(
xhr
)
{
Object
.
keys
(
headers
)
.
forEach
(
key
=
>
xhr
.
setRequestHeader
(
key
headers
[
key
]
)
)
;
}
;
}
return
hash
;
}
parseErrorResponse
(
responseText
)
{
var
json
=
responseText
;
try
{
json
=
Ember
.
.
parseJSON
(
responseText
)
;
}
catch
(
e
)
{
}
return
json
;
}
normalizeErrorResponse
(
status
headers
payload
)
{
if
(
payload
&
&
typeof
payload
=
=
=
'
object
'
&
&
payload
.
errors
)
{
return
payload
.
errors
;
}
else
{
return
[
{
status
:
{
status
}
title
:
"
The
backend
responded
with
an
error
"
detail
:
{
payload
}
}
]
;
}
}
generatedDetailedMessage
:
function
(
status
headers
payload
requestData
)
{
var
shortenedPayload
=
void
0
;
var
payloadContentType
=
headers
[
"
Content
-
Type
"
]
|
|
"
Empty
Content
-
Type
"
;
if
(
payloadContentType
=
=
=
"
text
/
html
"
&
&
payload
.
length
>
250
)
{
shortenedPayload
=
"
[
Omitted
Lengthy
HTML
]
"
;
}
else
{
shortenedPayload
=
payload
;
}
var
requestDescription
=
requestData
.
method
+
'
'
+
requestData
.
url
;
var
payloadDescription
=
'
Payload
(
'
+
payloadContentType
+
'
)
'
;
return
[
'
Ember
Data
Request
'
+
requestDescription
+
'
returned
a
'
+
status
payloadDescription
shortenedPayload
]
.
join
(
'
\
n
'
)
;
}
buildQuery
(
snapshot
)
{
var
query
=
{
}
;
if
(
snapshot
)
{
var
{
include
}
=
snapshot
;
if
(
include
)
{
query
.
include
=
include
;
}
}
return
query
;
}
_hasCustomizedAjax
(
)
{
if
(
this
.
ajax
!
=
=
RESTAdapter
.
prototype
.
ajax
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
RESTAdapter
#
ajax
has
been
deprecated
please
use
.
methodForRequest
urlForRequest
headersForRequest
or
dataForRequest
instead
.
'
false
{
id
:
'
ds
.
rest
-
adapter
.
ajax
'
until
:
'
3
.
0
.
0
'
}
)
)
;
return
true
;
}
if
(
this
.
ajaxOptions
!
=
=
RESTAdapter
.
prototype
.
ajaxOptions
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
RESTAdapter
#
ajaxOptions
has
been
deprecated
please
use
.
methodForRequest
urlForRequest
headersForRequest
or
dataForRequest
instead
.
'
false
{
id
:
'
ds
.
rest
-
adapter
.
ajax
-
options
'
until
:
'
3
.
0
.
0
'
}
)
)
;
return
true
;
}
return
false
;
}
}
)
;
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
improved
-
ajax
'
)
)
{
RESTAdapter
.
reopen
(
{
dataForRequest
(
params
)
{
var
{
store
type
snapshot
requestType
query
}
=
params
;
type
=
type
|
|
snapshot
&
&
snapshot
.
type
;
var
serializer
=
store
.
serializerFor
(
type
.
modelName
)
;
var
data
=
{
}
;
switch
(
requestType
)
{
case
'
createRecord
'
:
serializer
.
serializeIntoHash
(
data
type
snapshot
{
includeId
:
true
}
)
;
break
;
case
'
updateRecord
'
:
serializer
.
serializeIntoHash
(
data
type
snapshot
)
;
break
;
case
'
findRecord
'
:
data
=
this
.
buildQuery
(
snapshot
)
;
break
;
case
'
findAll
'
:
if
(
params
.
sinceToken
)
{
query
=
query
|
|
{
}
;
query
.
since
=
params
.
sinceToken
;
}
data
=
query
;
break
;
case
'
query
'
:
case
'
queryRecord
'
:
if
(
this
.
sortQueryParams
)
{
query
=
this
.
sortQueryParams
(
query
)
;
}
data
=
query
;
break
;
case
'
findMany
'
:
data
=
{
ids
:
params
.
ids
}
;
break
;
default
:
data
=
undefined
;
break
;
}
return
data
;
}
methodForRequest
(
params
)
{
var
{
requestType
}
=
params
;
switch
(
requestType
)
{
case
'
createRecord
'
:
return
'
POST
'
;
case
'
updateRecord
'
:
return
'
PUT
'
;
case
'
deleteRecord
'
:
return
'
DELETE
'
;
}
return
'
GET
'
;
}
urlForRequest
(
params
)
{
var
{
type
id
ids
snapshot
snapshots
requestType
query
}
=
params
;
type
=
type
|
|
snapshot
&
&
snapshot
.
type
;
id
=
id
|
|
snapshot
&
&
snapshot
.
id
;
switch
(
requestType
)
{
case
'
findAll
'
:
return
this
.
buildURL
(
type
.
modelName
null
snapshots
requestType
)
;
case
'
query
'
:
case
'
queryRecord
'
:
return
this
.
buildURL
(
type
.
modelName
null
null
requestType
query
)
;
case
'
findMany
'
:
return
this
.
buildURL
(
type
.
modelName
ids
snapshots
requestType
)
;
case
'
findHasMany
'
:
case
'
findBelongsTo
'
:
{
var
url
=
this
.
buildURL
(
type
.
modelName
id
snapshot
requestType
)
;
return
this
.
urlPrefix
(
params
.
url
url
)
;
}
}
return
this
.
buildURL
(
type
.
modelName
id
snapshot
requestType
query
)
;
}
headersForRequest
(
params
)
{
return
this
.
get
(
'
headers
'
)
;
}
_requestFor
(
params
)
{
var
method
=
this
.
methodForRequest
(
params
)
;
var
url
=
this
.
urlForRequest
(
params
)
;
var
headers
=
this
.
headersForRequest
(
params
)
;
var
data
=
this
.
dataForRequest
(
params
)
;
return
{
method
url
headers
data
}
;
}
_requestToJQueryAjaxHash
(
request
)
{
var
hash
=
{
}
;
hash
.
type
=
request
.
method
;
hash
.
url
=
request
.
url
;
hash
.
dataType
=
'
json
'
;
hash
.
context
=
this
;
if
(
request
.
data
)
{
if
(
request
.
method
!
=
=
'
GET
'
)
{
hash
.
contentType
=
'
application
/
json
;
charset
=
utf
-
8
'
;
hash
.
data
=
JSON
.
stringify
(
request
.
data
)
;
}
else
{
hash
.
data
=
request
.
data
;
}
}
var
headers
=
request
.
headers
;
if
(
headers
!
=
=
undefined
)
{
hash
.
beforeSend
=
function
(
xhr
)
{
Object
.
keys
(
headers
)
.
forEach
(
key
=
>
xhr
.
setRequestHeader
(
key
headers
[
key
]
)
)
;
}
;
}
return
hash
;
}
_makeRequest
(
request
)
{
var
adapter
=
this
;
var
hash
=
this
.
_requestToJQueryAjaxHash
(
request
)
;
var
{
method
url
}
=
request
;
var
requestData
=
{
method
url
}
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
hash
.
success
=
function
(
payload
textStatus
jqXHR
)
{
var
response
=
ajaxSuccess
(
adapter
jqXHR
payload
requestData
)
;
Ember
.
run
.
join
(
null
resolve
response
)
;
}
;
hash
.
error
=
function
(
jqXHR
textStatus
errorThrown
)
{
var
responseData
=
{
textStatus
errorThrown
}
;
var
error
=
ajaxError
(
adapter
jqXHR
requestData
responseData
)
;
Ember
.
run
.
join
(
null
reject
error
)
;
}
;
adapter
.
_ajaxRequest
(
hash
)
;
}
DS
:
RESTAdapter
#
makeRequest
:
{
method
}
{
url
}
)
;
}
}
)
;
}
function
ajaxSuccess
(
adapter
jqXHR
payload
requestData
)
{
var
response
=
void
0
;
try
{
response
=
adapter
.
handleResponse
(
jqXHR
.
status
(
0
_private
.
parseResponseHeaders
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
payload
requestData
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
;
}
if
(
response
&
&
response
.
isAdapterError
)
{
return
Promise
.
reject
(
response
)
;
}
else
{
return
response
;
}
}
function
ajaxError
(
adapter
jqXHR
requestData
responseData
)
{
if
(
true
)
{
var
message
=
The
server
returned
an
empty
string
for
{
requestData
.
method
}
{
requestData
.
url
}
which
cannot
be
parsed
into
a
valid
JSON
.
Return
either
null
or
{
}
.
;
var
validJSONString
=
!
(
responseData
.
textStatus
=
=
=
"
parsererror
"
&
&
jqXHR
.
responseText
=
=
=
"
"
)
;
(
true
&
&
Ember
.
warn
(
message
validJSONString
{
id
:
'
ds
.
adapter
.
returned
-
empty
-
string
-
as
-
JSON
'
}
)
)
;
}
var
error
=
void
0
;
if
(
responseData
.
errorThrown
instanceof
Error
)
{
error
=
responseData
.
errorThrown
;
}
else
if
(
responseData
.
textStatus
=
=
=
'
timeout
'
)
{
error
=
new
_private
.
TimeoutError
(
)
;
}
else
if
(
responseData
.
textStatus
=
=
=
'
abort
'
|
|
jqXHR
.
status
=
=
=
0
)
{
error
=
new
_private
.
AbortError
(
)
;
}
else
{
try
{
error
=
adapter
.
handleResponse
(
jqXHR
.
status
(
0
_private
.
parseResponseHeaders
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
adapter
.
parseErrorResponse
(
jqXHR
.
responseText
)
|
|
responseData
.
errorThrown
requestData
)
;
}
catch
(
e
)
{
error
=
e
;
}
}
return
error
;
}
function
endsWith
(
string
suffix
)
{
if
(
typeof
String
.
prototype
.
endsWith
!
=
=
'
function
'
)
{
return
string
.
indexOf
(
suffix
string
.
length
-
suffix
.
length
)
!
=
=
-
1
;
}
else
{
return
string
.
endsWith
(
suffix
)
;
}
}
exports
.
default
=
RESTAdapter
;
}
)
;
;
define
(
'
ember
-
data
/
attr
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
attr
;
function
getDefaultValue
(
record
options
key
)
{
if
(
typeof
options
.
defaultValue
=
=
=
'
function
'
)
{
return
options
.
defaultValue
.
apply
(
null
arguments
)
;
}
else
{
var
defaultValue
=
options
.
defaultValue
;
(
true
&
&
!
(
typeof
defaultValue
!
=
=
'
object
'
|
|
defaultValue
=
=
=
null
)
&
&
Ember
.
assert
(
Non
primitive
defaultValues
are
not
supported
because
they
are
shared
between
all
instances
.
If
you
would
like
to
use
a
complex
object
as
a
default
value
please
provide
a
function
that
returns
the
complex
object
.
typeof
defaultValue
!
=
=
'
object
'
|
|
defaultValue
=
=
=
null
)
)
;
return
defaultValue
;
}
}
function
hasValue
(
record
key
)
{
return
key
in
record
.
_attributes
|
|
key
in
record
.
_inFlightAttributes
|
|
key
in
record
.
_data
;
}
function
getValue
(
record
key
)
{
if
(
key
in
record
.
_attributes
)
{
return
record
.
_attributes
[
key
]
;
}
else
if
(
key
in
record
.
_inFlightAttributes
)
{
return
record
.
_inFlightAttributes
[
key
]
;
}
else
{
return
record
.
_data
[
key
]
;
}
}
function
attr
(
type
options
)
{
if
(
typeof
type
=
=
=
'
object
'
)
{
options
=
type
;
type
=
undefined
;
}
else
{
options
=
options
|
|
{
}
;
}
var
meta
=
{
type
:
type
isAttribute
:
true
options
:
options
}
;
return
Ember
.
computed
(
{
get
(
key
)
{
var
internalModel
=
this
.
_internalModel
;
if
(
hasValue
(
internalModel
key
)
)
{
return
getValue
(
internalModel
key
)
;
}
else
{
return
getDefaultValue
(
this
options
key
)
;
}
}
set
(
key
value
)
{
var
internalModel
=
this
.
_internalModel
;
var
oldValue
=
getValue
(
internalModel
key
)
;
var
originalValue
=
void
0
;
if
(
value
!
=
=
oldValue
)
{
internalModel
.
_attributes
[
key
]
=
value
;
if
(
key
in
internalModel
.
_inFlightAttributes
)
{
originalValue
=
internalModel
.
_inFlightAttributes
[
key
]
;
}
else
{
originalValue
=
internalModel
.
_data
[
key
]
;
}
this
.
_internalModel
.
send
(
'
didSetProperty
'
{
name
:
key
oldValue
:
oldValue
originalValue
:
originalValue
value
:
value
}
)
;
}
return
value
;
}
}
)
.
meta
(
meta
)
;
}
}
)
;
;
define
(
"
ember
-
data
/
index
"
[
"
exports
"
"
ember
-
data
/
-
private
"
"
ember
-
data
/
setup
-
container
"
"
ember
-
data
/
initialize
-
store
-
service
"
"
ember
-
data
/
transforms
/
transform
"
"
ember
-
data
/
transforms
/
number
"
"
ember
-
data
/
transforms
/
date
"
"
ember
-
data
/
transforms
/
string
"
"
ember
-
data
/
transforms
/
boolean
"
"
ember
-
data
/
adapter
"
"
ember
-
data
/
adapters
/
json
-
api
"
"
ember
-
data
/
adapters
/
rest
"
"
ember
-
data
/
serializer
"
"
ember
-
data
/
serializers
/
json
-
api
"
"
ember
-
data
/
serializers
/
json
"
"
ember
-
data
/
serializers
/
rest
"
"
ember
-
data
/
serializers
/
embedded
-
records
-
mixin
"
"
ember
-
data
/
attr
"
"
ember
-
inflector
"
]
function
(
exports
_private
_setupContainer
_initializeStoreService
_transform
_number
_date
_string
_boolean
_adapter
_jsonApi
_rest
_serializer
_jsonApi2
_json
_rest2
_embeddedRecordsMixin
_attr
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
if
(
Ember
.
VERSION
.
match
(
/
^
1
\
.
(
[
0
-
9
]
|
1
[
0
-
2
]
)
\
.
/
)
)
{
throw
new
Ember
.
Error
(
"
Ember
Data
requires
at
least
Ember
1
.
13
.
0
but
you
have
"
+
Ember
.
VERSION
+
"
.
Please
upgrade
your
version
of
Ember
then
upgrade
Ember
Data
.
"
)
;
}
_private
.
DS
.
Store
=
_private
.
Store
;
_private
.
DS
.
PromiseArray
=
_private
.
PromiseArray
;
_private
.
DS
.
PromiseObject
=
_private
.
PromiseObject
;
_private
.
DS
.
PromiseManyArray
=
_private
.
PromiseManyArray
;
_private
.
DS
.
Model
=
_private
.
Model
;
_private
.
DS
.
RootState
=
_private
.
RootState
;
_private
.
DS
.
attr
=
_attr
.
default
;
_private
.
DS
.
Errors
=
_private
.
Errors
;
_private
.
DS
.
InternalModel
=
_private
.
InternalModel
;
_private
.
DS
.
Snapshot
=
_private
.
Snapshot
;
_private
.
DS
.
Adapter
=
_adapter
.
default
;
_private
.
DS
.
AdapterError
=
_private
.
AdapterError
;
_private
.
DS
.
InvalidError
=
_private
.
InvalidError
;
_private
.
DS
.
TimeoutError
=
_private
.
TimeoutError
;
_private
.
DS
.
AbortError
=
_private
.
AbortError
;
_private
.
DS
.
UnauthorizedError
=
_private
.
UnauthorizedError
;
_private
.
DS
.
ForbiddenError
=
_private
.
ForbiddenError
;
_private
.
DS
.
NotFoundError
=
_private
.
NotFoundError
;
_private
.
DS
.
ConflictError
=
_private
.
ConflictError
;
_private
.
DS
.
ServerError
=
_private
.
ServerError
;
_private
.
DS
.
errorsHashToArray
=
_private
.
errorsHashToArray
;
_private
.
DS
.
errorsArrayToHash
=
_private
.
errorsArrayToHash
;
_private
.
DS
.
Serializer
=
_serializer
.
default
;
_private
.
DS
.
DebugAdapter
=
_private
.
DebugAdapter
;
_private
.
DS
.
RecordArray
=
_private
.
RecordArray
;
_private
.
DS
.
FilteredRecordArray
=
_private
.
FilteredRecordArray
;
_private
.
DS
.
AdapterPopulatedRecordArray
=
_private
.
AdapterPopulatedRecordArray
;
_private
.
DS
.
ManyArray
=
_private
.
ManyArray
;
_private
.
DS
.
RecordArrayManager
=
_private
.
RecordArrayManager
;
_private
.
DS
.
RESTAdapter
=
_rest
.
default
;
_private
.
DS
.
BuildURLMixin
=
_private
.
BuildURLMixin
;
_private
.
DS
.
RESTSerializer
=
_rest2
.
default
;
_private
.
DS
.
JSONSerializer
=
_json
.
default
;
_private
.
DS
.
JSONAPIAdapter
=
_jsonApi
.
default
;
_private
.
DS
.
JSONAPISerializer
=
_jsonApi2
.
default
;
_private
.
DS
.
Transform
=
_transform
.
default
;
_private
.
DS
.
DateTransform
=
_date
.
default
;
_private
.
DS
.
StringTransform
=
_string
.
default
;
_private
.
DS
.
NumberTransform
=
_number
.
default
;
_private
.
DS
.
BooleanTransform
=
_boolean
.
default
;
_private
.
DS
.
EmbeddedRecordsMixin
=
_embeddedRecordsMixin
.
default
;
_private
.
DS
.
belongsTo
=
_private
.
belongsTo
;
_private
.
DS
.
hasMany
=
_private
.
hasMany
;
_private
.
DS
.
Relationship
=
_private
.
Relationship
;
_private
.
DS
.
_setupContainer
=
_setupContainer
.
default
;
_private
.
DS
.
_initializeStoreService
=
_initializeStoreService
.
default
;
Object
.
defineProperty
(
_private
.
DS
'
normalizeModelName
'
{
enumerable
:
true
writable
:
false
configurable
:
false
value
:
_private
.
normalizeModelName
}
)
;
exports
.
default
=
_private
.
DS
;
}
)
;
;
define
(
'
ember
-
data
/
initialize
-
store
-
service
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
initializeStoreService
;
function
initializeStoreService
(
instance
)
{
var
container
=
instance
.
lookup
?
instance
:
instance
.
container
;
container
.
lookup
(
'
service
:
store
'
)
;
}
}
)
;
;
define
(
'
ember
-
data
/
model
'
[
'
exports
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
Model
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
relationships
'
[
'
exports
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
belongsTo
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
belongsTo
;
}
}
)
;
Object
.
defineProperty
(
exports
'
hasMany
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
hasMany
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
serializer
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Object
.
extend
(
{
normalizeResponse
:
null
serialize
:
null
normalize
(
typeClass
hash
)
{
return
hash
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
serializers
/
embedded
-
records
-
mixin
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Mixin
.
create
(
{
normalize
(
typeClass
hash
prop
)
{
var
normalizedHash
=
this
.
_super
(
typeClass
hash
prop
)
;
return
this
.
_extractEmbeddedRecords
(
this
this
.
store
typeClass
normalizedHash
)
;
}
keyForRelationship
(
key
typeClass
method
)
{
if
(
method
=
=
=
'
serialize
'
&
&
this
.
hasSerializeRecordsOption
(
key
)
|
|
method
=
=
=
'
deserialize
'
&
&
this
.
hasDeserializeRecordsOption
(
key
)
)
{
return
this
.
keyForAttribute
(
key
method
)
;
}
else
{
return
this
.
_super
(
key
typeClass
method
)
|
|
key
;
}
}
serializeBelongsTo
(
snapshot
json
relationship
)
{
var
attr
=
relationship
.
key
;
if
(
this
.
noSerializeOptionSpecified
(
attr
)
)
{
this
.
_super
(
snapshot
json
relationship
)
;
return
;
}
var
includeIds
=
this
.
hasSerializeIdsOption
(
attr
)
;
var
includeRecords
=
this
.
hasSerializeRecordsOption
(
attr
)
;
var
embeddedSnapshot
=
snapshot
.
belongsTo
(
attr
)
;
if
(
includeIds
)
{
var
serializedKey
=
this
.
_getMappedKey
(
relationship
.
key
snapshot
.
type
)
;
if
(
serializedKey
=
=
=
relationship
.
key
&
&
this
.
keyForRelationship
)
{
serializedKey
=
this
.
keyForRelationship
(
relationship
.
key
relationship
.
kind
"
serialize
"
)
;
}
if
(
!
embeddedSnapshot
)
{
json
[
serializedKey
]
=
null
;
}
else
{
json
[
serializedKey
]
=
embeddedSnapshot
.
id
;
if
(
relationship
.
options
.
polymorphic
)
{
this
.
serializePolymorphicType
(
snapshot
json
relationship
)
;
}
}
}
else
if
(
includeRecords
)
{
this
.
_serializeEmbeddedBelongsTo
(
snapshot
json
relationship
)
;
}
}
_serializeEmbeddedBelongsTo
(
snapshot
json
relationship
)
{
var
embeddedSnapshot
=
snapshot
.
belongsTo
(
relationship
.
key
)
;
var
serializedKey
=
this
.
_getMappedKey
(
relationship
.
key
snapshot
.
type
)
;
if
(
serializedKey
=
=
=
relationship
.
key
&
&
this
.
keyForRelationship
)
{
serializedKey
=
this
.
keyForRelationship
(
relationship
.
key
relationship
.
kind
"
serialize
"
)
;
}
if
(
!
embeddedSnapshot
)
{
json
[
serializedKey
]
=
null
;
}
else
{
json
[
serializedKey
]
=
embeddedSnapshot
.
serialize
(
{
includeId
:
true
}
)
;
this
.
removeEmbeddedForeignKey
(
snapshot
embeddedSnapshot
relationship
json
[
serializedKey
]
)
;
if
(
relationship
.
options
.
polymorphic
)
{
this
.
serializePolymorphicType
(
snapshot
json
relationship
)
;
}
}
}
serializeHasMany
(
snapshot
json
relationship
)
{
var
attr
=
relationship
.
key
;
if
(
this
.
noSerializeOptionSpecified
(
attr
)
)
{
this
.
_super
(
snapshot
json
relationship
)
;
return
;
}
if
(
this
.
hasSerializeIdsOption
(
attr
)
)
{
var
serializedKey
=
this
.
_getMappedKey
(
relationship
.
key
snapshot
.
type
)
;
if
(
serializedKey
=
=
=
relationship
.
key
&
&
this
.
keyForRelationship
)
{
serializedKey
=
this
.
keyForRelationship
(
relationship
.
key
relationship
.
kind
"
serialize
"
)
;
}
json
[
serializedKey
]
=
snapshot
.
hasMany
(
attr
{
ids
:
true
}
)
;
}
else
if
(
this
.
hasSerializeRecordsOption
(
attr
)
)
{
this
.
_serializeEmbeddedHasMany
(
snapshot
json
relationship
)
;
}
else
{
if
(
this
.
hasSerializeIdsAndTypesOption
(
attr
)
)
{
this
.
_serializeHasManyAsIdsAndTypes
(
snapshot
json
relationship
)
;
}
}
}
_serializeHasManyAsIdsAndTypes
(
snapshot
json
relationship
)
{
var
serializedKey
=
this
.
keyForAttribute
(
relationship
.
key
'
serialize
'
)
;
var
hasMany
=
snapshot
.
hasMany
(
relationship
.
key
)
;
json
[
serializedKey
]
=
Ember
.
A
(
hasMany
)
.
map
(
function
(
recordSnapshot
)
{
return
{
id
:
recordSnapshot
.
id
type
:
recordSnapshot
.
modelName
}
;
}
)
;
}
_serializeEmbeddedHasMany
(
snapshot
json
relationship
)
{
var
serializedKey
=
this
.
_getMappedKey
(
relationship
.
key
snapshot
.
type
)
;
if
(
serializedKey
=
=
=
relationship
.
key
&
&
this
.
keyForRelationship
)
{
serializedKey
=
this
.
keyForRelationship
(
relationship
.
key
relationship
.
kind
"
serialize
"
)
;
}
(
true
&
&
Ember
.
warn
(
The
embedded
relationship
'
{
serializedKey
}
'
is
undefined
for
'
{
snapshot
.
modelName
}
'
with
id
'
{
snapshot
.
id
}
'
.
Please
include
it
in
your
original
payload
.
Ember
.
typeOf
(
snapshot
.
hasMany
(
relationship
.
key
)
)
!
=
=
'
undefined
'
{
id
:
'
ds
.
serializer
.
embedded
-
relationship
-
undefined
'
}
)
)
;
json
[
serializedKey
]
=
this
.
_generateSerializedHasMany
(
snapshot
relationship
)
;
}
_generateSerializedHasMany
(
snapshot
relationship
)
{
var
hasMany
=
snapshot
.
hasMany
(
relationship
.
key
)
;
var
manyArray
=
Ember
.
A
(
hasMany
)
;
var
ret
=
new
Array
(
manyArray
.
length
)
;
for
(
var
i
=
0
;
i
<
manyArray
.
length
;
i
+
+
)
{
var
embeddedSnapshot
=
manyArray
[
i
]
;
var
embeddedJson
=
embeddedSnapshot
.
serialize
(
{
includeId
:
true
}
)
;
this
.
removeEmbeddedForeignKey
(
snapshot
embeddedSnapshot
relationship
embeddedJson
)
;
ret
[
i
]
=
embeddedJson
;
}
return
ret
;
}
removeEmbeddedForeignKey
(
snapshot
embeddedSnapshot
relationship
json
)
{
if
(
relationship
.
kind
=
=
=
'
belongsTo
'
)
{
var
parentRecord
=
snapshot
.
type
.
inverseFor
(
relationship
.
key
this
.
store
)
;
if
(
parentRecord
)
{
var
name
=
parentRecord
.
name
;
var
embeddedSerializer
=
this
.
store
.
serializerFor
(
embeddedSnapshot
.
modelName
)
;
var
parentKey
=
embeddedSerializer
.
keyForRelationship
(
name
parentRecord
.
kind
'
deserialize
'
)
;
if
(
parentKey
)
{
delete
json
[
parentKey
]
;
}
}
}
}
hasEmbeddedAlwaysOption
(
attr
)
{
var
option
=
this
.
attrsOption
(
attr
)
;
return
option
&
&
option
.
embedded
=
=
=
'
always
'
;
}
hasSerializeRecordsOption
(
attr
)
{
var
alwaysEmbed
=
this
.
hasEmbeddedAlwaysOption
(
attr
)
;
var
option
=
this
.
attrsOption
(
attr
)
;
return
alwaysEmbed
|
|
option
&
&
option
.
serialize
=
=
=
'
records
'
;
}
hasSerializeIdsOption
(
attr
)
{
var
option
=
this
.
attrsOption
(
attr
)
;
return
option
&
&
(
option
.
serialize
=
=
=
'
ids
'
|
|
option
.
serialize
=
=
=
'
id
'
)
;
}
hasSerializeIdsAndTypesOption
(
attr
)
{
var
option
=
this
.
attrsOption
(
attr
)
;
return
option
&
&
(
option
.
serialize
=
=
=
'
ids
-
and
-
types
'
|
|
option
.
serialize
=
=
=
'
id
-
and
-
type
'
)
;
}
noSerializeOptionSpecified
(
attr
)
{
var
option
=
this
.
attrsOption
(
attr
)
;
return
!
(
option
&
&
(
option
.
serialize
|
|
option
.
embedded
)
)
;
}
hasDeserializeRecordsOption
(
attr
)
{
var
alwaysEmbed
=
this
.
hasEmbeddedAlwaysOption
(
attr
)
;
var
option
=
this
.
attrsOption
(
attr
)
;
return
alwaysEmbed
|
|
option
&
&
option
.
deserialize
=
=
=
'
records
'
;
}
attrsOption
(
attr
)
{
var
attrs
=
this
.
get
(
'
attrs
'
)
;
return
attrs
&
&
(
attrs
[
Ember
.
String
.
camelize
(
attr
)
]
|
|
attrs
[
attr
]
)
;
}
_extractEmbeddedRecords
(
serializer
store
typeClass
partial
)
{
typeClass
.
eachRelationship
(
(
key
relationship
)
=
>
{
if
(
serializer
.
hasDeserializeRecordsOption
(
key
)
)
{
if
(
relationship
.
kind
=
=
=
"
hasMany
"
)
{
this
.
_extractEmbeddedHasMany
(
store
key
partial
relationship
)
;
}
if
(
relationship
.
kind
=
=
=
"
belongsTo
"
)
{
this
.
_extractEmbeddedBelongsTo
(
store
key
partial
relationship
)
;
}
}
}
)
;
return
partial
;
}
_extractEmbeddedHasMany
(
store
key
hash
relationshipMeta
)
{
var
relationshipHash
=
Ember
.
get
(
hash
data
.
relationships
.
{
key
}
.
data
)
;
if
(
!
relationshipHash
)
{
return
;
}
var
hasMany
=
new
Array
(
relationshipHash
.
length
)
;
for
(
var
i
=
0
;
i
<
relationshipHash
.
length
;
i
+
+
)
{
var
item
=
relationshipHash
[
i
]
;
var
{
data
included
}
=
this
.
_normalizeEmbeddedRelationship
(
store
relationshipMeta
item
)
;
hash
.
included
=
hash
.
included
|
|
[
]
;
hash
.
included
.
push
(
data
)
;
if
(
included
)
{
hash
.
included
.
push
(
.
.
.
included
)
;
}
hasMany
[
i
]
=
{
id
:
data
.
id
type
:
data
.
type
}
;
}
var
relationship
=
{
data
:
hasMany
}
;
Ember
.
set
(
hash
data
.
relationships
.
{
key
}
relationship
)
;
}
_extractEmbeddedBelongsTo
(
store
key
hash
relationshipMeta
)
{
var
relationshipHash
=
Ember
.
get
(
hash
data
.
relationships
.
{
key
}
.
data
)
;
if
(
!
relationshipHash
)
{
return
;
}
var
{
data
included
}
=
this
.
_normalizeEmbeddedRelationship
(
store
relationshipMeta
relationshipHash
)
;
hash
.
included
=
hash
.
included
|
|
[
]
;
hash
.
included
.
push
(
data
)
;
if
(
included
)
{
hash
.
included
.
push
(
.
.
.
included
)
;
}
var
belongsTo
=
{
id
:
data
.
id
type
:
data
.
type
}
;
var
relationship
=
{
data
:
belongsTo
}
;
Ember
.
set
(
hash
data
.
relationships
.
{
key
}
relationship
)
;
}
_normalizeEmbeddedRelationship
(
store
relationshipMeta
relationshipHash
)
{
var
modelName
=
relationshipMeta
.
type
;
if
(
relationshipMeta
.
options
.
polymorphic
)
{
modelName
=
relationshipHash
.
type
;
}
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
serializer
=
store
.
serializerFor
(
modelName
)
;
return
serializer
.
normalize
(
modelClass
relationshipHash
null
)
;
}
isEmbeddedRecordsMixin
:
true
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
serializers
/
json
-
api
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
data
/
serializers
/
json
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_emberInflector
_json
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
JSONAPISerializer
=
_json
.
default
.
extend
(
{
_normalizeDocumentHelper
(
documentHash
)
{
if
(
Ember
.
typeOf
(
documentHash
.
data
)
=
=
=
'
object
'
)
{
documentHash
.
data
=
this
.
_normalizeResourceHelper
(
documentHash
.
data
)
;
}
else
if
(
Array
.
isArray
(
documentHash
.
data
)
)
{
var
ret
=
new
Array
(
documentHash
.
data
.
length
)
;
for
(
var
i
=
0
;
i
<
documentHash
.
data
.
length
;
i
+
+
)
{
var
data
=
documentHash
.
data
[
i
]
;
ret
[
i
]
=
this
.
_normalizeResourceHelper
(
data
)
;
}
documentHash
.
data
=
ret
;
}
if
(
Array
.
isArray
(
documentHash
.
included
)
)
{
var
_ret
=
new
Array
(
)
;
for
(
var
_i
=
0
;
_i
<
documentHash
.
included
.
length
;
_i
+
+
)
{
var
included
=
documentHash
.
included
[
_i
]
;
var
normalized
=
this
.
_normalizeResourceHelper
(
included
)
;
if
(
normalized
!
=
=
null
)
{
_ret
.
push
(
normalized
)
;
}
}
documentHash
.
included
=
_ret
;
}
return
documentHash
;
}
_normalizeRelationshipDataHelper
(
relationshipDataHash
)
{
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
var
modelName
=
this
.
modelNameFromPayloadType
(
relationshipDataHash
.
type
)
;
var
deprecatedModelNameLookup
=
this
.
modelNameFromPayloadKey
(
relationshipDataHash
.
type
)
;
if
(
modelName
!
=
=
deprecatedModelNameLookup
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
are
using
modelNameFromPayloadKey
to
normalize
the
type
for
a
relationship
.
This
has
been
deprecated
in
favor
of
modelNameFromPayloadType
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
model
-
name
-
for
-
relationship
'
until
:
'
4
.
0
.
0
'
}
)
)
;
modelName
=
deprecatedModelNameLookup
;
}
relationshipDataHash
.
type
=
modelName
;
}
else
{
relationshipDataHash
.
type
=
this
.
modelNameFromPayloadKey
(
relationshipDataHash
.
type
)
;
}
return
relationshipDataHash
;
}
_normalizeResourceHelper
(
resourceHash
)
{
(
true
&
&
!
(
!
Ember
.
isNone
(
resourceHash
.
type
)
)
&
&
Ember
.
assert
(
this
.
warnMessageForUndefinedType
(
)
!
Ember
.
isNone
(
resourceHash
.
type
)
{
id
:
'
ds
.
serializer
.
type
-
is
-
undefined
'
}
)
)
;
var
modelName
=
void
0
usedLookup
=
void
0
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
modelName
=
this
.
modelNameFromPayloadType
(
resourceHash
.
type
)
;
var
deprecatedModelNameLookup
=
this
.
modelNameFromPayloadKey
(
resourceHash
.
type
)
;
usedLookup
=
'
modelNameFromPayloadType
'
;
if
(
modelName
!
=
=
deprecatedModelNameLookup
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
are
using
modelNameFromPayloadKey
to
normalize
the
type
for
a
resource
.
This
has
been
deprecated
in
favor
of
modelNameFromPayloadType
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
model
-
name
-
for
-
resource
'
until
:
'
4
.
0
.
0
'
}
)
)
;
modelName
=
deprecatedModelNameLookup
;
usedLookup
=
'
modelNameFromPayloadKey
'
;
}
}
else
{
modelName
=
this
.
modelNameFromPayloadKey
(
resourceHash
.
type
)
;
usedLookup
=
'
modelNameFromPayloadKey
'
;
}
if
(
!
this
.
store
.
_hasModelFor
(
modelName
)
)
{
(
true
&
&
Ember
.
warn
(
this
.
warnMessageNoModelForType
(
modelName
resourceHash
.
type
usedLookup
)
false
{
id
:
'
ds
.
serializer
.
model
-
for
-
type
-
missing
'
}
)
)
;
return
null
;
}
var
modelClass
=
this
.
store
.
_modelFor
(
modelName
)
;
var
serializer
=
this
.
store
.
serializerFor
(
modelName
)
;
var
{
data
}
=
serializer
.
normalize
(
modelClass
resourceHash
)
;
return
data
;
}
pushPayload
(
store
payload
)
{
var
normalizedPayload
=
this
.
_normalizeDocumentHelper
(
payload
)
;
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
pushpayload
-
return
'
)
)
{
return
store
.
push
(
normalizedPayload
)
;
}
else
{
store
.
push
(
normalizedPayload
)
;
}
}
_normalizeResponse
(
store
primaryModelClass
payload
id
requestType
isSingle
)
{
var
normalizedPayload
=
this
.
_normalizeDocumentHelper
(
payload
)
;
return
normalizedPayload
;
}
normalizeQueryRecordResponse
(
)
{
var
normalized
=
this
.
_super
(
.
.
.
arguments
)
;
(
true
&
&
!
(
!
Array
.
isArray
(
normalized
.
data
)
)
&
&
Ember
.
assert
(
'
Expected
the
primary
data
returned
by
the
serializer
for
a
queryRecord
response
to
be
a
single
object
but
instead
it
was
an
array
.
'
!
Array
.
isArray
(
normalized
.
data
)
{
id
:
'
ds
.
serializer
.
json
-
api
.
queryRecord
-
array
-
response
'
}
)
)
;
return
normalized
;
}
extractAttributes
(
modelClass
resourceHash
)
{
var
attributes
=
{
}
;
if
(
resourceHash
.
attributes
)
{
modelClass
.
eachAttribute
(
key
=
>
{
var
attributeKey
=
this
.
keyForAttribute
(
key
'
deserialize
'
)
;
if
(
resourceHash
.
attributes
[
attributeKey
]
!
=
=
undefined
)
{
attributes
[
key
]
=
resourceHash
.
attributes
[
attributeKey
]
;
}
if
(
true
)
{
if
(
resourceHash
.
attributes
[
attributeKey
]
=
=
=
undefined
&
&
resourceHash
.
attributes
[
key
]
!
=
=
undefined
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
Your
payload
for
'
{
modelClass
.
modelName
}
'
contains
'
{
key
}
'
but
your
serializer
is
setup
to
look
for
'
{
attributeKey
}
'
.
This
is
most
likely
because
Ember
Data
'
s
JSON
API
serializer
dasherizes
attribute
keys
by
default
.
You
should
subclass
JSONAPISerializer
and
implement
'
keyForAttribute
(
key
)
{
return
key
;
}
'
to
prevent
Ember
Data
from
customizing
your
attribute
keys
.
false
)
)
;
}
}
}
)
;
}
return
attributes
;
}
extractRelationship
(
relationshipHash
)
{
if
(
Ember
.
typeOf
(
relationshipHash
.
data
)
=
=
=
'
object
'
)
{
relationshipHash
.
data
=
this
.
_normalizeRelationshipDataHelper
(
relationshipHash
.
data
)
;
}
if
(
Array
.
isArray
(
relationshipHash
.
data
)
)
{
var
ret
=
new
Array
(
relationshipHash
.
data
.
length
)
;
for
(
var
i
=
0
;
i
<
relationshipHash
.
data
.
length
;
i
+
+
)
{
var
data
=
relationshipHash
.
data
[
i
]
;
ret
[
i
]
=
this
.
_normalizeRelationshipDataHelper
(
data
)
;
}
relationshipHash
.
data
=
ret
;
}
return
relationshipHash
;
}
extractRelationships
(
modelClass
resourceHash
)
{
var
relationships
=
{
}
;
if
(
resourceHash
.
relationships
)
{
modelClass
.
eachRelationship
(
(
key
relationshipMeta
)
=
>
{
var
relationshipKey
=
this
.
keyForRelationship
(
key
relationshipMeta
.
kind
'
deserialize
'
)
;
if
(
resourceHash
.
relationships
[
relationshipKey
]
!
=
=
undefined
)
{
var
relationshipHash
=
resourceHash
.
relationships
[
relationshipKey
]
;
relationships
[
key
]
=
this
.
extractRelationship
(
relationshipHash
)
;
}
if
(
true
)
{
if
(
resourceHash
.
relationships
[
relationshipKey
]
=
=
=
undefined
&
&
resourceHash
.
relationships
[
key
]
!
=
=
undefined
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
assert
(
Your
payload
for
'
{
modelClass
.
modelName
}
'
contains
'
{
key
}
'
but
your
serializer
is
setup
to
look
for
'
{
relationshipKey
}
'
.
This
is
most
likely
because
Ember
Data
'
s
JSON
API
serializer
dasherizes
relationship
keys
by
default
.
You
should
subclass
JSONAPISerializer
and
implement
'
keyForRelationship
(
key
)
{
return
key
;
}
'
to
prevent
Ember
Data
from
customizing
your
relationship
keys
.
false
)
)
;
}
}
}
)
;
}
return
relationships
;
}
_extractType
(
modelClass
resourceHash
)
{
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
var
modelName
=
this
.
modelNameFromPayloadType
(
resourceHash
.
type
)
;
var
deprecatedModelNameLookup
=
this
.
modelNameFromPayloadKey
(
resourceHash
.
type
)
;
if
(
modelName
!
=
=
deprecatedModelNameLookup
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
are
using
modelNameFromPayloadKey
to
normalize
the
type
for
a
polymorphic
relationship
.
This
has
been
deprecated
in
favor
of
modelNameFromPayloadType
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
model
-
name
-
for
-
polymorphic
-
type
'
until
:
'
3
.
0
.
0
'
}
)
)
;
modelName
=
deprecatedModelNameLookup
;
}
return
modelName
;
}
else
{
return
this
.
modelNameFromPayloadKey
(
resourceHash
.
type
)
;
}
}
modelNameFromPayloadKey
(
key
)
{
return
(
0
_emberInflector
.
singularize
)
(
(
0
_private
.
normalizeModelName
)
(
key
)
)
;
}
payloadKeyFromModelName
(
modelName
)
{
return
(
0
_emberInflector
.
pluralize
)
(
modelName
)
;
}
normalize
(
modelClass
resourceHash
)
{
if
(
resourceHash
.
attributes
)
{
this
.
normalizeUsingDeclaredMapping
(
modelClass
resourceHash
.
attributes
)
;
}
if
(
resourceHash
.
relationships
)
{
this
.
normalizeUsingDeclaredMapping
(
modelClass
resourceHash
.
relationships
)
;
}
var
data
=
{
id
:
this
.
extractId
(
modelClass
resourceHash
)
type
:
this
.
_extractType
(
modelClass
resourceHash
)
attributes
:
this
.
extractAttributes
(
modelClass
resourceHash
)
relationships
:
this
.
extractRelationships
(
modelClass
resourceHash
)
}
;
this
.
applyTransforms
(
modelClass
data
.
attributes
)
;
return
{
data
}
;
}
keyForAttribute
(
key
method
)
{
return
Ember
.
String
.
dasherize
(
key
)
;
}
keyForRelationship
(
key
typeClass
method
)
{
return
Ember
.
String
.
dasherize
(
key
)
;
}
serialize
(
snapshot
options
)
{
var
data
=
this
.
_super
(
.
.
.
arguments
)
;
var
payloadType
=
void
0
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
payloadType
=
this
.
payloadTypeFromModelName
(
snapshot
.
modelName
)
;
var
deprecatedPayloadTypeLookup
=
this
.
payloadKeyFromModelName
(
snapshot
.
modelName
)
;
if
(
payloadType
!
=
=
deprecatedPayloadTypeLookup
&
&
this
.
_hasCustomPayloadKeyFromModelName
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
used
payloadKeyFromModelName
to
customize
how
a
type
is
serialized
.
Use
payloadTypeFromModelName
instead
.
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
payload
-
type
-
for
-
model
'
until
:
'
4
.
0
.
0
'
}
)
)
;
payloadType
=
deprecatedPayloadTypeLookup
;
}
}
else
{
payloadType
=
this
.
payloadKeyFromModelName
(
snapshot
.
modelName
)
;
}
data
.
type
=
payloadType
;
return
{
data
}
;
}
serializeAttribute
(
snapshot
json
key
attribute
)
{
var
type
=
attribute
.
type
;
if
(
this
.
_canSerialize
(
key
)
)
{
json
.
attributes
=
json
.
attributes
|
|
{
}
;
var
value
=
snapshot
.
attr
(
key
)
;
if
(
type
)
{
var
transform
=
this
.
transformFor
(
type
)
;
value
=
transform
.
serialize
(
value
attribute
.
options
)
;
}
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
)
{
payloadKey
=
this
.
keyForAttribute
(
key
'
serialize
'
)
;
}
json
.
attributes
[
payloadKey
]
=
value
;
}
}
serializeBelongsTo
(
snapshot
json
relationship
)
{
var
key
=
relationship
.
key
;
if
(
this
.
_canSerialize
(
key
)
)
{
var
belongsTo
=
snapshot
.
belongsTo
(
key
)
;
if
(
belongsTo
!
=
=
undefined
)
{
json
.
relationships
=
json
.
relationships
|
|
{
}
;
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
)
{
payloadKey
=
this
.
keyForRelationship
(
key
'
belongsTo
'
'
serialize
'
)
;
}
var
data
=
null
;
if
(
belongsTo
)
{
var
payloadType
=
void
0
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
payloadType
=
this
.
payloadTypeFromModelName
(
belongsTo
.
modelName
)
;
var
deprecatedPayloadTypeLookup
=
this
.
payloadKeyFromModelName
(
belongsTo
.
modelName
)
;
if
(
payloadType
!
=
=
deprecatedPayloadTypeLookup
&
&
this
.
_hasCustomPayloadKeyFromModelName
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
used
payloadKeyFromModelName
to
serialize
type
for
belongs
-
to
relationship
.
Use
payloadTypeFromModelName
instead
.
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
payload
-
type
-
for
-
belongs
-
to
'
until
:
'
4
.
0
.
0
'
}
)
)
;
payloadType
=
deprecatedPayloadTypeLookup
;
}
}
else
{
payloadType
=
this
.
payloadKeyFromModelName
(
belongsTo
.
modelName
)
;
}
data
=
{
type
:
payloadType
id
:
belongsTo
.
id
}
;
}
json
.
relationships
[
payloadKey
]
=
{
data
}
;
}
}
}
serializeHasMany
(
snapshot
json
relationship
)
{
var
key
=
relationship
.
key
;
if
(
this
.
shouldSerializeHasMany
(
snapshot
key
relationship
)
)
{
var
hasMany
=
snapshot
.
hasMany
(
key
)
;
if
(
hasMany
!
=
=
undefined
)
{
json
.
relationships
=
json
.
relationships
|
|
{
}
;
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
&
&
this
.
keyForRelationship
)
{
payloadKey
=
this
.
keyForRelationship
(
key
'
hasMany
'
'
serialize
'
)
;
}
var
data
=
new
Array
(
hasMany
.
length
)
;
for
(
var
i
=
0
;
i
<
hasMany
.
length
;
i
+
+
)
{
var
item
=
hasMany
[
i
]
;
var
payloadType
=
void
0
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
payloadType
=
this
.
payloadTypeFromModelName
(
item
.
modelName
)
;
var
deprecatedPayloadTypeLookup
=
this
.
payloadKeyFromModelName
(
item
.
modelName
)
;
if
(
payloadType
!
=
=
deprecatedPayloadTypeLookup
&
&
this
.
_hasCustomPayloadKeyFromModelName
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
used
payloadKeyFromModelName
to
serialize
type
for
belongs
-
to
relationship
.
Use
payloadTypeFromModelName
instead
.
"
false
{
id
:
'
ds
.
json
-
api
-
serializer
.
deprecated
-
payload
-
type
-
for
-
has
-
many
'
until
:
'
4
.
0
.
0
'
}
)
)
;
payloadType
=
deprecatedPayloadTypeLookup
;
}
}
else
{
payloadType
=
this
.
payloadKeyFromModelName
(
item
.
modelName
)
;
}
data
[
i
]
=
{
type
:
payloadType
id
:
item
.
id
}
;
}
json
.
relationships
[
payloadKey
]
=
{
data
}
;
}
}
}
}
)
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
JSONAPISerializer
.
reopen
(
{
modelNameFromPayloadType
(
type
)
{
return
(
0
_emberInflector
.
singularize
)
(
(
0
_private
.
normalizeModelName
)
(
type
)
)
;
}
payloadTypeFromModelName
(
modelName
)
{
return
(
0
_emberInflector
.
pluralize
)
(
modelName
)
;
}
_hasCustomModelNameFromPayloadKey
(
)
{
return
this
.
modelNameFromPayloadKey
!
=
=
JSONAPISerializer
.
prototype
.
modelNameFromPayloadKey
;
}
_hasCustomPayloadKeyFromModelName
(
)
{
return
this
.
payloadKeyFromModelName
!
=
=
JSONAPISerializer
.
prototype
.
payloadKeyFromModelName
;
}
}
)
;
}
if
(
true
)
{
JSONAPISerializer
.
reopen
(
{
willMergeMixin
(
props
)
{
var
constructor
=
this
.
constructor
;
(
true
&
&
Ember
.
warn
(
You
'
ve
defined
'
extractMeta
'
in
{
constructor
.
toString
(
)
}
which
is
not
used
for
serializers
extending
JSONAPISerializer
.
Read
more
at
https
:
/
/
emberjs
.
com
/
api
/
data
/
classes
/
DS
.
JSONAPISerializer
.
html
#
toc_customizing
-
meta
on
how
to
customize
meta
when
using
JSON
API
.
Ember
.
isNone
(
props
.
extractMeta
)
|
|
props
.
extractMeta
=
=
=
_json
.
default
.
prototype
.
extractMeta
{
id
:
'
ds
.
serializer
.
json
-
api
.
extractMeta
'
}
)
)
;
(
true
&
&
Ember
.
warn
(
'
The
JSONAPISerializer
does
not
work
with
the
EmbeddedRecordsMixin
because
the
JSON
API
spec
does
not
describe
how
to
format
embedded
resources
.
'
!
props
.
isEmbeddedRecordsMixin
{
id
:
'
ds
.
serializer
.
embedded
-
records
-
mixin
-
not
-
supported
'
}
)
)
;
}
warnMessageForUndefinedType
(
)
{
return
'
Encountered
a
resource
object
with
an
undefined
type
(
resolved
resource
using
'
+
this
.
constructor
.
toString
(
)
+
'
)
'
;
}
warnMessageNoModelForType
(
modelName
originalType
usedLookup
)
{
return
Encountered
a
resource
object
with
type
"
{
originalType
}
"
but
no
model
was
found
for
model
name
"
{
modelName
}
"
(
resolved
model
name
using
'
{
this
.
constructor
.
toString
(
)
}
.
{
usedLookup
}
(
"
{
originalType
}
"
)
'
)
.
;
}
}
)
;
}
exports
.
default
=
JSONAPISerializer
;
}
)
;
;
define
(
'
ember
-
data
/
serializers
/
json
'
[
'
exports
'
'
ember
-
data
/
serializer
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_serializer
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
emberAssign
=
Ember
.
assign
|
|
Ember
.
merge
;
var
JSONSerializer
=
_serializer
.
default
.
extend
(
{
primaryKey
:
'
id
'
mergedProperties
:
[
'
attrs
'
]
applyTransforms
(
typeClass
data
)
{
var
attributes
=
Ember
.
get
(
typeClass
'
attributes
'
)
;
typeClass
.
eachTransformedAttribute
(
(
key
typeClass
)
=
>
{
if
(
data
[
key
]
=
=
=
undefined
)
{
return
;
}
var
transform
=
this
.
transformFor
(
typeClass
)
;
var
transformMeta
=
attributes
.
get
(
key
)
;
data
[
key
]
=
transform
.
deserialize
(
data
[
key
]
transformMeta
.
options
)
;
}
)
;
return
data
;
}
normalizeResponse
(
store
primaryModelClass
payload
id
requestType
)
{
switch
(
requestType
)
{
case
'
findRecord
'
:
return
this
.
normalizeFindRecordResponse
(
.
.
.
arguments
)
;
case
'
queryRecord
'
:
return
this
.
normalizeQueryRecordResponse
(
.
.
.
arguments
)
;
case
'
findAll
'
:
return
this
.
normalizeFindAllResponse
(
.
.
.
arguments
)
;
case
'
findBelongsTo
'
:
return
this
.
normalizeFindBelongsToResponse
(
.
.
.
arguments
)
;
case
'
findHasMany
'
:
return
this
.
normalizeFindHasManyResponse
(
.
.
.
arguments
)
;
case
'
findMany
'
:
return
this
.
normalizeFindManyResponse
(
.
.
.
arguments
)
;
case
'
query
'
:
return
this
.
normalizeQueryResponse
(
.
.
.
arguments
)
;
case
'
createRecord
'
:
return
this
.
normalizeCreateRecordResponse
(
.
.
.
arguments
)
;
case
'
deleteRecord
'
:
return
this
.
normalizeDeleteRecordResponse
(
.
.
.
arguments
)
;
case
'
updateRecord
'
:
return
this
.
normalizeUpdateRecordResponse
(
.
.
.
arguments
)
;
}
}
normalizeFindRecordResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSingleResponse
(
.
.
.
arguments
)
;
}
normalizeQueryRecordResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSingleResponse
(
.
.
.
arguments
)
;
}
normalizeFindAllResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeArrayResponse
(
.
.
.
arguments
)
;
}
normalizeFindBelongsToResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSingleResponse
(
.
.
.
arguments
)
;
}
normalizeFindHasManyResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeArrayResponse
(
.
.
.
arguments
)
;
}
normalizeFindManyResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeArrayResponse
(
.
.
.
arguments
)
;
}
normalizeQueryResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeArrayResponse
(
.
.
.
arguments
)
;
}
normalizeCreateRecordResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSaveResponse
(
.
.
.
arguments
)
;
}
normalizeDeleteRecordResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSaveResponse
(
.
.
.
arguments
)
;
}
normalizeUpdateRecordResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSaveResponse
(
.
.
.
arguments
)
;
}
normalizeSaveResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
normalizeSingleResponse
(
.
.
.
arguments
)
;
}
normalizeSingleResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
_normalizeResponse
(
store
primaryModelClass
payload
id
requestType
true
)
;
}
normalizeArrayResponse
(
store
primaryModelClass
payload
id
requestType
)
{
return
this
.
_normalizeResponse
(
store
primaryModelClass
payload
id
requestType
false
)
;
}
_normalizeResponse
(
store
primaryModelClass
payload
id
requestType
isSingle
)
{
var
documentHash
=
{
data
:
null
included
:
[
]
}
;
var
meta
=
this
.
extractMeta
(
store
primaryModelClass
payload
)
;
if
(
meta
)
{
(
true
&
&
!
(
Ember
.
typeOf
(
meta
)
=
=
=
'
object
'
)
&
&
Ember
.
assert
(
'
The
meta
returned
from
extractMeta
has
to
be
an
object
not
"
'
+
Ember
.
typeOf
(
meta
)
+
'
"
.
'
Ember
.
typeOf
(
meta
)
=
=
=
'
object
'
)
)
;
documentHash
.
meta
=
meta
;
}
if
(
isSingle
)
{
var
{
data
included
}
=
this
.
normalize
(
primaryModelClass
payload
)
;
documentHash
.
data
=
data
;
if
(
included
)
{
documentHash
.
included
=
included
;
}
}
else
{
var
ret
=
new
Array
(
payload
.
length
)
;
for
(
var
i
=
0
l
=
payload
.
length
;
i
<
l
;
i
+
+
)
{
var
item
=
payload
[
i
]
;
var
{
data
:
_data
included
:
_included
}
=
this
.
normalize
(
primaryModelClass
item
)
;
if
(
_included
)
{
documentHash
.
included
.
push
(
.
.
.
_included
)
;
}
ret
[
i
]
=
_data
;
}
documentHash
.
data
=
ret
;
}
return
documentHash
;
}
normalize
(
modelClass
resourceHash
)
{
var
data
=
null
;
if
(
resourceHash
)
{
this
.
normalizeUsingDeclaredMapping
(
modelClass
resourceHash
)
;
if
(
Ember
.
typeOf
(
resourceHash
.
links
)
=
=
=
'
object
'
)
{
this
.
normalizeUsingDeclaredMapping
(
modelClass
resourceHash
.
links
)
;
}
data
=
{
id
:
this
.
extractId
(
modelClass
resourceHash
)
type
:
modelClass
.
modelName
attributes
:
this
.
extractAttributes
(
modelClass
resourceHash
)
relationships
:
this
.
extractRelationships
(
modelClass
resourceHash
)
}
;
this
.
applyTransforms
(
modelClass
data
.
attributes
)
;
}
return
{
data
}
;
}
extractId
(
modelClass
resourceHash
)
{
var
primaryKey
=
Ember
.
get
(
this
'
primaryKey
'
)
;
var
id
=
resourceHash
[
primaryKey
]
;
return
(
0
_private
.
coerceId
)
(
id
)
;
}
extractAttributes
(
modelClass
resourceHash
)
{
var
attributeKey
=
void
0
;
var
attributes
=
{
}
;
modelClass
.
eachAttribute
(
key
=
>
{
attributeKey
=
this
.
keyForAttribute
(
key
'
deserialize
'
)
;
if
(
resourceHash
[
attributeKey
]
!
=
=
undefined
)
{
attributes
[
key
]
=
resourceHash
[
attributeKey
]
;
}
}
)
;
return
attributes
;
}
extractRelationship
(
relationshipModelName
relationshipHash
)
{
if
(
Ember
.
isNone
(
relationshipHash
)
)
{
return
null
;
}
if
(
Ember
.
typeOf
(
relationshipHash
)
=
=
=
'
object
'
)
{
if
(
relationshipHash
.
id
)
{
relationshipHash
.
id
=
(
0
_private
.
coerceId
)
(
relationshipHash
.
id
)
;
}
var
modelClass
=
this
.
store
.
modelFor
(
relationshipModelName
)
;
if
(
relationshipHash
.
type
&
&
!
(
0
_private
.
modelHasAttributeOrRelationshipNamedType
)
(
modelClass
)
)
{
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
var
modelName
=
this
.
modelNameFromPayloadType
(
relationshipHash
.
type
)
;
var
deprecatedModelNameLookup
=
this
.
modelNameFromPayloadKey
(
relationshipHash
.
type
)
;
if
(
modelName
!
=
=
deprecatedModelNameLookup
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
used
modelNameFromPayloadKey
to
customize
how
a
type
is
normalized
.
Use
modelNameFromPayloadType
instead
"
false
{
id
:
'
ds
.
json
-
serializer
.
deprecated
-
type
-
for
-
polymorphic
-
relationship
'
until
:
'
3
.
0
.
0
'
}
)
)
;
modelName
=
deprecatedModelNameLookup
;
}
relationshipHash
.
type
=
modelName
;
}
else
{
relationshipHash
.
type
=
this
.
modelNameFromPayloadKey
(
relationshipHash
.
type
)
;
}
}
return
relationshipHash
;
}
return
{
id
:
(
0
_private
.
coerceId
)
(
relationshipHash
)
type
:
relationshipModelName
}
;
}
extractPolymorphicRelationship
(
relationshipModelName
relationshipHash
relationshipOptions
)
{
return
this
.
extractRelationship
(
relationshipModelName
relationshipHash
)
;
}
extractRelationships
(
modelClass
resourceHash
)
{
var
relationships
=
{
}
;
modelClass
.
eachRelationship
(
(
key
relationshipMeta
)
=
>
{
var
relationship
=
null
;
var
relationshipKey
=
this
.
keyForRelationship
(
key
relationshipMeta
.
kind
'
deserialize
'
)
;
if
(
resourceHash
[
relationshipKey
]
!
=
=
undefined
)
{
var
data
=
null
;
var
relationshipHash
=
resourceHash
[
relationshipKey
]
;
if
(
relationshipMeta
.
kind
=
=
=
'
belongsTo
'
)
{
if
(
relationshipMeta
.
options
.
polymorphic
)
{
data
=
this
.
extractPolymorphicRelationship
(
relationshipMeta
.
type
relationshipHash
{
key
resourceHash
relationshipMeta
}
)
;
}
else
{
data
=
this
.
extractRelationship
(
relationshipMeta
.
type
relationshipHash
)
;
}
}
else
if
(
relationshipMeta
.
kind
=
=
=
'
hasMany
'
)
{
if
(
!
Ember
.
isNone
(
relationshipHash
)
)
{
data
=
new
Array
(
relationshipHash
.
length
)
;
for
(
var
i
=
0
l
=
relationshipHash
.
length
;
i
<
l
;
i
+
+
)
{
var
item
=
relationshipHash
[
i
]
;
data
[
i
]
=
this
.
extractRelationship
(
relationshipMeta
.
type
item
)
;
}
}
}
relationship
=
{
data
}
;
}
var
linkKey
=
this
.
keyForLink
(
key
relationshipMeta
.
kind
)
;
if
(
resourceHash
.
links
&
&
resourceHash
.
links
[
linkKey
]
!
=
=
undefined
)
{
var
related
=
resourceHash
.
links
[
linkKey
]
;
relationship
=
relationship
|
|
{
}
;
relationship
.
links
=
{
related
}
;
}
if
(
relationship
)
{
relationships
[
key
]
=
relationship
;
}
}
)
;
return
relationships
;
}
modelNameFromPayloadKey
(
key
)
{
return
(
0
_private
.
normalizeModelName
)
(
key
)
;
}
normalizeRelationships
(
typeClass
hash
)
{
var
payloadKey
=
void
0
;
if
(
this
.
keyForRelationship
)
{
typeClass
.
eachRelationship
(
(
key
relationship
)
=
>
{
payloadKey
=
this
.
keyForRelationship
(
key
relationship
.
kind
'
deserialize
'
)
;
if
(
key
=
=
=
payloadKey
)
{
return
;
}
if
(
hash
[
payloadKey
]
=
=
=
undefined
)
{
return
;
}
hash
[
key
]
=
hash
[
payloadKey
]
;
delete
hash
[
payloadKey
]
;
}
)
;
}
}
normalizeUsingDeclaredMapping
(
modelClass
hash
)
{
var
attrs
=
Ember
.
get
(
this
'
attrs
'
)
;
var
normalizedKey
=
void
0
;
var
payloadKey
=
void
0
;
if
(
attrs
)
{
for
(
var
key
in
attrs
)
{
normalizedKey
=
payloadKey
=
this
.
_getMappedKey
(
key
modelClass
)
;
if
(
hash
[
payloadKey
]
=
=
=
undefined
)
{
continue
;
}
if
(
Ember
.
get
(
modelClass
'
attributes
'
)
.
has
(
key
)
)
{
normalizedKey
=
this
.
keyForAttribute
(
key
)
;
}
if
(
Ember
.
get
(
modelClass
'
relationshipsByName
'
)
.
has
(
key
)
)
{
normalizedKey
=
this
.
keyForRelationship
(
key
)
;
}
if
(
payloadKey
!
=
=
normalizedKey
)
{
hash
[
normalizedKey
]
=
hash
[
payloadKey
]
;
delete
hash
[
payloadKey
]
;
}
}
}
}
_getMappedKey
(
key
modelClass
)
{
(
true
&
&
Ember
.
warn
(
'
There
is
no
attribute
or
relationship
with
the
name
'
+
key
+
'
on
'
+
modelClass
.
modelName
+
'
.
Check
your
serializers
attrs
hash
.
'
Ember
.
get
(
modelClass
'
attributes
'
)
.
has
(
key
)
|
|
Ember
.
get
(
modelClass
'
relationshipsByName
'
)
.
has
(
key
)
{
id
:
'
ds
.
serializer
.
no
-
mapped
-
attrs
-
key
'
}
)
)
;
var
attrs
=
Ember
.
get
(
this
'
attrs
'
)
;
var
mappedKey
=
void
0
;
if
(
attrs
&
&
attrs
[
key
]
)
{
mappedKey
=
attrs
[
key
]
;
if
(
mappedKey
.
key
)
{
mappedKey
=
mappedKey
.
key
;
}
if
(
typeof
mappedKey
=
=
=
'
string
'
)
{
key
=
mappedKey
;
}
}
return
key
;
}
_canSerialize
(
key
)
{
var
attrs
=
Ember
.
get
(
this
'
attrs
'
)
;
return
!
attrs
|
|
!
attrs
[
key
]
|
|
attrs
[
key
]
.
serialize
!
=
=
false
;
}
_mustSerialize
(
key
)
{
var
attrs
=
Ember
.
get
(
this
'
attrs
'
)
;
return
attrs
&
&
attrs
[
key
]
&
&
attrs
[
key
]
.
serialize
=
=
=
true
;
}
shouldSerializeHasMany
(
snapshot
key
relationship
)
{
var
relationshipType
=
snapshot
.
type
.
determineRelationshipType
(
relationship
this
.
store
)
;
if
(
this
.
_mustSerialize
(
key
)
)
{
return
true
;
}
return
this
.
_canSerialize
(
key
)
&
&
(
relationshipType
=
=
=
'
manyToNone
'
|
|
relationshipType
=
=
=
'
manyToMany
'
)
;
}
serialize
(
snapshot
options
)
{
var
json
=
{
}
;
if
(
options
&
&
options
.
includeId
)
{
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
serialize
-
id
'
)
)
{
this
.
serializeId
(
snapshot
json
Ember
.
get
(
this
'
primaryKey
'
)
)
;
}
else
{
var
id
=
snapshot
.
id
;
if
(
id
)
{
json
[
Ember
.
get
(
this
'
primaryKey
'
)
]
=
id
;
}
}
}
snapshot
.
eachAttribute
(
(
key
attribute
)
=
>
{
this
.
serializeAttribute
(
snapshot
json
key
attribute
)
;
}
)
;
snapshot
.
eachRelationship
(
(
key
relationship
)
=
>
{
if
(
relationship
.
kind
=
=
=
'
belongsTo
'
)
{
this
.
serializeBelongsTo
(
snapshot
json
relationship
)
;
}
else
if
(
relationship
.
kind
=
=
=
'
hasMany
'
)
{
this
.
serializeHasMany
(
snapshot
json
relationship
)
;
}
}
)
;
return
json
;
}
serializeIntoHash
(
hash
typeClass
snapshot
options
)
{
emberAssign
(
hash
this
.
serialize
(
snapshot
options
)
)
;
}
serializeAttribute
(
snapshot
json
key
attribute
)
{
if
(
this
.
_canSerialize
(
key
)
)
{
var
type
=
attribute
.
type
;
var
value
=
snapshot
.
attr
(
key
)
;
if
(
type
)
{
var
transform
=
this
.
transformFor
(
type
)
;
value
=
transform
.
serialize
(
value
attribute
.
options
)
;
}
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
&
&
this
.
keyForAttribute
)
{
payloadKey
=
this
.
keyForAttribute
(
key
'
serialize
'
)
;
}
json
[
payloadKey
]
=
value
;
}
}
serializeBelongsTo
(
snapshot
json
relationship
)
{
var
key
=
relationship
.
key
;
if
(
this
.
_canSerialize
(
key
)
)
{
var
belongsToId
=
snapshot
.
belongsTo
(
key
{
id
:
true
}
)
;
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
&
&
this
.
keyForRelationship
)
{
payloadKey
=
this
.
keyForRelationship
(
key
"
belongsTo
"
"
serialize
"
)
;
}
if
(
Ember
.
isNone
(
belongsToId
)
)
{
json
[
payloadKey
]
=
null
;
}
else
{
json
[
payloadKey
]
=
belongsToId
;
}
if
(
relationship
.
options
.
polymorphic
)
{
this
.
serializePolymorphicType
(
snapshot
json
relationship
)
;
}
}
}
serializeHasMany
(
snapshot
json
relationship
)
{
var
key
=
relationship
.
key
;
if
(
this
.
shouldSerializeHasMany
(
snapshot
key
relationship
)
)
{
var
hasMany
=
snapshot
.
hasMany
(
key
{
ids
:
true
}
)
;
if
(
hasMany
!
=
=
undefined
)
{
var
payloadKey
=
this
.
_getMappedKey
(
key
snapshot
.
type
)
;
if
(
payloadKey
=
=
=
key
&
&
this
.
keyForRelationship
)
{
payloadKey
=
this
.
keyForRelationship
(
key
"
hasMany
"
"
serialize
"
)
;
}
json
[
payloadKey
]
=
hasMany
;
}
}
}
serializePolymorphicType
(
)
{
}
extractMeta
(
store
modelClass
payload
)
{
if
(
payload
&
&
payload
[
'
meta
'
]
!
=
=
undefined
)
{
var
meta
=
payload
.
meta
;
delete
payload
.
meta
;
return
meta
;
}
}
extractErrors
(
store
typeClass
payload
id
)
{
if
(
payload
&
&
typeof
payload
=
=
=
'
object
'
&
&
payload
.
errors
)
{
payload
=
(
0
_private
.
errorsArrayToHash
)
(
payload
.
errors
)
;
this
.
normalizeUsingDeclaredMapping
(
typeClass
payload
)
;
typeClass
.
eachAttribute
(
name
=
>
{
var
key
=
this
.
keyForAttribute
(
name
'
deserialize
'
)
;
if
(
key
!
=
=
name
&
&
payload
[
key
]
!
=
=
undefined
)
{
payload
[
name
]
=
payload
[
key
]
;
delete
payload
[
key
]
;
}
}
)
;
typeClass
.
eachRelationship
(
name
=
>
{
var
key
=
this
.
keyForRelationship
(
name
'
deserialize
'
)
;
if
(
key
!
=
=
name
&
&
payload
[
key
]
!
=
=
undefined
)
{
payload
[
name
]
=
payload
[
key
]
;
delete
payload
[
key
]
;
}
}
)
;
}
return
payload
;
}
keyForAttribute
(
key
method
)
{
return
key
;
}
keyForRelationship
(
key
typeClass
method
)
{
return
key
;
}
keyForLink
(
key
kind
)
{
return
key
;
}
transformFor
(
attributeType
skipAssertion
)
{
var
transform
=
(
0
_private
.
getOwner
)
(
this
)
.
lookup
(
'
transform
:
'
+
attributeType
)
;
(
true
&
&
!
(
skipAssertion
|
|
!
!
transform
)
&
&
Ember
.
assert
(
"
Unable
to
find
transform
for
'
"
+
attributeType
+
"
'
"
skipAssertion
|
|
!
!
transform
)
)
;
return
transform
;
}
}
)
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
JSONSerializer
.
reopen
(
{
modelNameFromPayloadType
(
type
)
{
return
(
0
_private
.
normalizeModelName
)
(
type
)
;
}
_hasCustomModelNameFromPayloadKey
(
)
{
return
this
.
modelNameFromPayloadKey
!
=
=
JSONSerializer
.
prototype
.
modelNameFromPayloadKey
;
}
}
)
;
}
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
serialize
-
id
"
)
)
{
JSONSerializer
.
reopen
(
{
serializeId
(
snapshot
json
primaryKey
)
{
var
id
=
snapshot
.
id
;
if
(
id
)
{
json
[
primaryKey
]
=
id
;
}
}
}
)
;
}
exports
.
default
=
JSONSerializer
;
}
)
;
;
define
(
'
ember
-
data
/
serializers
/
rest
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
data
/
serializers
/
json
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_emberInflector
_json
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
RESTSerializer
=
_json
.
default
.
extend
(
{
keyForPolymorphicType
(
key
typeClass
method
)
{
var
relationshipKey
=
this
.
keyForRelationship
(
key
)
;
return
{
relationshipKey
}
Type
;
}
_normalizeArray
(
store
modelName
arrayHash
prop
)
{
var
documentHash
=
{
data
:
[
]
included
:
[
]
}
;
var
modelClass
=
store
.
modelFor
(
modelName
)
;
var
serializer
=
store
.
serializerFor
(
modelName
)
;
Ember
.
makeArray
(
arrayHash
)
.
forEach
(
hash
=
>
{
var
{
data
included
}
=
this
.
_normalizePolymorphicRecord
(
store
hash
prop
modelClass
serializer
)
;
documentHash
.
data
.
push
(
data
)
;
if
(
included
)
{
documentHash
.
included
.
push
(
.
.
.
included
)
;
}
}
)
;
return
documentHash
;
}
_normalizePolymorphicRecord
(
store
hash
prop
primaryModelClass
primarySerializer
)
{
var
serializer
=
primarySerializer
;
var
modelClass
=
primaryModelClass
;
var
primaryHasTypeAttribute
=
(
0
_private
.
modelHasAttributeOrRelationshipNamedType
)
(
primaryModelClass
)
;
if
(
!
primaryHasTypeAttribute
&
&
hash
.
type
)
{
var
modelName
=
void
0
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
modelName
=
this
.
modelNameFromPayloadType
(
hash
.
type
)
;
var
deprecatedModelNameLookup
=
this
.
modelNameFromPayloadKey
(
hash
.
type
)
;
if
(
modelName
!
=
=
deprecatedModelNameLookup
&
&
!
this
.
_hasCustomModelNameFromPayloadType
(
)
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
are
using
modelNameFromPayloadKey
to
normalize
the
type
for
a
polymorphic
relationship
.
This
is
has
been
deprecated
in
favor
of
modelNameFromPayloadType
"
false
{
id
:
'
ds
.
rest
-
serializer
.
deprecated
-
model
-
name
-
for
-
polymorphic
-
type
'
until
:
'
3
.
0
.
0
'
}
)
)
;
modelName
=
deprecatedModelNameLookup
;
}
}
else
{
modelName
=
this
.
modelNameFromPayloadKey
(
hash
.
type
)
;
}
if
(
store
.
_hasModelFor
(
modelName
)
)
{
serializer
=
store
.
serializerFor
(
modelName
)
;
modelClass
=
store
.
modelFor
(
modelName
)
;
}
}
return
serializer
.
normalize
(
modelClass
hash
prop
)
;
}
_normalizeResponse
(
store
primaryModelClass
payload
id
requestType
isSingle
)
{
var
documentHash
=
{
data
:
null
included
:
[
]
}
;
var
meta
=
this
.
extractMeta
(
store
primaryModelClass
payload
)
;
if
(
meta
)
{
(
true
&
&
!
(
Ember
.
typeOf
(
meta
)
=
=
=
'
object
'
)
&
&
Ember
.
assert
(
'
The
meta
returned
from
extractMeta
has
to
be
an
object
not
"
'
+
Ember
.
typeOf
(
meta
)
+
'
"
.
'
Ember
.
typeOf
(
meta
)
=
=
=
'
object
'
)
)
;
documentHash
.
meta
=
meta
;
}
var
keys
=
Object
.
keys
(
payload
)
;
for
(
var
i
=
0
length
=
keys
.
length
;
i
<
length
;
i
+
+
)
{
var
prop
=
keys
[
i
]
;
var
modelName
=
prop
;
var
forcedSecondary
=
false
;
if
(
prop
.
charAt
(
0
)
=
=
=
'
_
'
)
{
forcedSecondary
=
true
;
modelName
=
prop
.
substr
(
1
)
;
}
var
typeName
=
this
.
modelNameFromPayloadKey
(
modelName
)
;
if
(
!
store
.
modelFactoryFor
(
typeName
)
)
{
(
true
&
&
Ember
.
warn
(
this
.
warnMessageNoModelForKey
(
modelName
typeName
)
false
{
id
:
'
ds
.
serializer
.
model
-
for
-
key
-
missing
'
}
)
)
;
continue
;
}
var
isPrimary
=
!
forcedSecondary
&
&
this
.
isPrimaryType
(
store
typeName
primaryModelClass
)
;
var
value
=
payload
[
prop
]
;
if
(
value
=
=
=
null
)
{
continue
;
}
if
(
true
)
{
var
isQueryRecordAnArray
=
requestType
=
=
=
'
queryRecord
'
&
&
isPrimary
&
&
Array
.
isArray
(
value
)
;
var
message
=
"
The
adapter
returned
an
array
for
the
primary
data
of
a
queryRecord
response
.
This
is
deprecated
as
queryRecord
should
return
a
single
record
.
"
;
(
true
&
&
!
(
!
isQueryRecordAnArray
)
&
&
Ember
.
deprecate
(
message
!
isQueryRecordAnArray
{
id
:
'
ds
.
serializer
.
rest
.
queryRecord
-
array
-
response
'
until
:
'
3
.
0
'
}
)
)
;
}
if
(
isPrimary
&
&
!
Array
.
isArray
(
value
)
)
{
var
{
data
:
_data
included
:
_included
}
=
this
.
_normalizePolymorphicRecord
(
store
value
prop
primaryModelClass
this
)
;
documentHash
.
data
=
_data
;
if
(
_included
)
{
documentHash
.
included
.
push
(
.
.
.
_included
)
;
}
continue
;
}
var
{
data
included
}
=
this
.
_normalizeArray
(
store
typeName
value
prop
)
;
if
(
included
)
{
documentHash
.
included
.
push
(
.
.
.
included
)
;
}
if
(
isSingle
)
{
data
.
forEach
(
resource
=
>
{
var
isUpdatedRecord
=
isPrimary
&
&
(
0
_private
.
coerceId
)
(
resource
.
id
)
=
=
=
id
;
var
isFirstCreatedRecord
=
isPrimary
&
&
!
id
&
&
!
documentHash
.
data
;
if
(
isFirstCreatedRecord
|
|
isUpdatedRecord
)
{
documentHash
.
data
=
resource
;
}
else
{
documentHash
.
included
.
push
(
resource
)
;
}
}
)
;
}
else
{
if
(
isPrimary
)
{
documentHash
.
data
=
data
;
}
else
{
if
(
data
)
{
documentHash
.
included
.
push
(
.
.
.
data
)
;
}
}
}
}
return
documentHash
;
}
isPrimaryType
(
store
typeName
primaryTypeClass
)
{
return
store
.
modelFor
(
typeName
)
=
=
=
primaryTypeClass
;
}
pushPayload
(
store
payload
)
{
var
documentHash
=
{
data
:
[
]
included
:
[
]
}
;
for
(
var
prop
in
payload
)
{
var
modelName
=
this
.
modelNameFromPayloadKey
(
prop
)
;
if
(
!
store
.
modelFactoryFor
(
modelName
)
)
{
(
true
&
&
Ember
.
warn
(
this
.
warnMessageNoModelForKey
(
prop
modelName
)
false
{
id
:
'
ds
.
serializer
.
model
-
for
-
key
-
missing
'
}
)
)
;
continue
;
}
var
type
=
store
.
modelFor
(
modelName
)
;
var
typeSerializer
=
store
.
serializerFor
(
type
.
modelName
)
;
Ember
.
makeArray
(
payload
[
prop
]
)
.
forEach
(
hash
=
>
{
var
{
data
included
}
=
typeSerializer
.
normalize
(
type
hash
prop
)
;
documentHash
.
data
.
push
(
data
)
;
if
(
included
)
{
documentHash
.
included
.
push
(
.
.
.
included
)
;
}
}
)
;
}
if
(
(
0
_private
.
isEnabled
)
(
'
ds
-
pushpayload
-
return
'
)
)
{
return
store
.
push
(
documentHash
)
;
}
else
{
store
.
push
(
documentHash
)
;
}
}
modelNameFromPayloadKey
(
key
)
{
return
(
0
_emberInflector
.
singularize
)
(
(
0
_private
.
normalizeModelName
)
(
key
)
)
;
}
serialize
(
snapshot
options
)
{
return
this
.
_super
(
.
.
.
arguments
)
;
}
serializeIntoHash
(
hash
typeClass
snapshot
options
)
{
var
normalizedRootKey
=
this
.
payloadKeyFromModelName
(
typeClass
.
modelName
)
;
hash
[
normalizedRootKey
]
=
this
.
serialize
(
snapshot
options
)
;
}
payloadKeyFromModelName
(
modelName
)
{
return
Ember
.
String
.
camelize
(
modelName
)
;
}
serializePolymorphicType
(
snapshot
json
relationship
)
{
var
key
=
relationship
.
key
;
var
typeKey
=
this
.
keyForPolymorphicType
(
key
relationship
.
type
'
serialize
'
)
;
var
belongsTo
=
snapshot
.
belongsTo
(
key
)
;
if
(
Ember
.
isNone
(
belongsTo
)
)
{
json
[
typeKey
]
=
null
;
}
else
{
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
json
[
typeKey
]
=
this
.
payloadTypeFromModelName
(
belongsTo
.
modelName
)
;
}
else
{
json
[
typeKey
]
=
Ember
.
String
.
camelize
(
belongsTo
.
modelName
)
;
}
}
}
extractPolymorphicRelationship
(
relationshipType
relationshipHash
relationshipOptions
)
{
var
{
key
resourceHash
relationshipMeta
}
=
relationshipOptions
;
var
isPolymorphic
=
relationshipMeta
.
options
.
polymorphic
;
var
typeProperty
=
this
.
keyForPolymorphicType
(
key
relationshipType
'
deserialize
'
)
;
if
(
isPolymorphic
&
&
resourceHash
[
typeProperty
]
!
=
=
undefined
&
&
typeof
relationshipHash
!
=
=
'
object
'
)
{
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
var
payloadType
=
resourceHash
[
typeProperty
]
;
var
type
=
this
.
modelNameFromPayloadType
(
payloadType
)
;
var
deprecatedTypeLookup
=
this
.
modelNameFromPayloadKey
(
payloadType
)
;
if
(
payloadType
!
=
=
deprecatedTypeLookup
&
&
!
this
.
_hasCustomModelNameFromPayloadType
(
)
&
&
this
.
_hasCustomModelNameFromPayloadKey
(
)
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
"
You
are
using
modelNameFromPayloadKey
to
normalize
the
type
for
a
polymorphic
relationship
.
This
has
been
deprecated
in
favor
of
modelNameFromPayloadType
"
false
{
id
:
'
ds
.
rest
-
serializer
.
deprecated
-
model
-
name
-
for
-
polymorphic
-
type
'
until
:
'
3
.
0
.
0
'
}
)
)
;
type
=
deprecatedTypeLookup
;
}
return
{
id
:
relationshipHash
type
:
type
}
;
}
else
{
var
_type
=
this
.
modelNameFromPayloadKey
(
resourceHash
[
typeProperty
]
)
;
return
{
id
:
relationshipHash
type
:
_type
}
;
}
}
return
this
.
_super
(
.
.
.
arguments
)
;
}
}
)
;
if
(
(
0
_private
.
isEnabled
)
(
"
ds
-
payload
-
type
-
hooks
"
)
)
{
RESTSerializer
.
reopen
(
{
modelNameFromPayloadType
(
payloadType
)
{
return
(
0
_emberInflector
.
singularize
)
(
(
0
_private
.
normalizeModelName
)
(
payloadType
)
)
;
}
payloadTypeFromModelName
(
modelName
)
{
return
Ember
.
String
.
camelize
(
modelName
)
;
}
_hasCustomModelNameFromPayloadKey
(
)
{
return
this
.
modelNameFromPayloadKey
!
=
=
RESTSerializer
.
prototype
.
modelNameFromPayloadKey
;
}
_hasCustomModelNameFromPayloadType
(
)
{
return
this
.
modelNameFromPayloadType
!
=
=
RESTSerializer
.
prototype
.
modelNameFromPayloadType
;
}
_hasCustomPayloadTypeFromModelName
(
)
{
return
this
.
payloadTypeFromModelName
!
=
=
RESTSerializer
.
prototype
.
payloadTypeFromModelName
;
}
_hasCustomPayloadKeyFromModelName
(
)
{
return
this
.
payloadKeyFromModelName
!
=
=
RESTSerializer
.
prototype
.
payloadKeyFromModelName
;
}
}
)
;
}
if
(
true
)
{
RESTSerializer
.
reopen
(
{
warnMessageNoModelForKey
(
prop
typeKey
)
{
return
'
Encountered
"
'
+
prop
+
'
"
in
payload
but
no
model
was
found
for
model
name
"
'
+
typeKey
+
'
"
(
resolved
model
name
using
'
+
this
.
constructor
.
toString
(
)
+
'
.
modelNameFromPayloadKey
(
"
'
+
prop
+
'
"
)
)
'
;
}
}
)
;
}
exports
.
default
=
RESTSerializer
;
}
)
;
;
define
(
'
ember
-
data
/
setup
-
container
'
[
'
exports
'
'
ember
-
data
/
-
private
'
'
ember
-
data
/
serializers
/
json
-
api
'
'
ember
-
data
/
serializers
/
json
'
'
ember
-
data
/
serializers
/
rest
'
'
ember
-
data
/
adapters
/
json
-
api
'
'
ember
-
data
/
adapters
/
rest
'
'
ember
-
data
/
transforms
/
number
'
'
ember
-
data
/
transforms
/
date
'
'
ember
-
data
/
transforms
/
string
'
'
ember
-
data
/
transforms
/
boolean
'
]
function
(
exports
_private
_jsonApi
_json
_rest
_jsonApi2
_rest2
_number
_date
_string
_boolean
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
setupContainer
;
function
has
(
applicationOrRegistry
fullName
)
{
if
(
applicationOrRegistry
.
has
)
{
return
applicationOrRegistry
.
has
(
fullName
)
;
}
else
{
return
applicationOrRegistry
.
hasRegistration
(
fullName
)
;
}
}
function
initializeStore
(
registry
)
{
var
registerOptionsForType
=
registry
.
registerOptionsForType
|
|
registry
.
optionsForType
;
registerOptionsForType
.
call
(
registry
'
serializer
'
{
singleton
:
false
}
)
;
registerOptionsForType
.
call
(
registry
'
adapter
'
{
singleton
:
false
}
)
;
registry
.
register
(
'
serializer
:
-
default
'
_json
.
default
)
;
registry
.
register
(
'
serializer
:
-
rest
'
_rest
.
default
)
;
registry
.
register
(
'
adapter
:
-
rest
'
_rest2
.
default
)
;
registry
.
register
(
'
adapter
:
-
json
-
api
'
_jsonApi2
.
default
)
;
registry
.
register
(
'
serializer
:
-
json
-
api
'
_jsonApi
.
default
)
;
if
(
!
has
(
registry
'
service
:
store
'
)
)
{
registry
.
register
(
'
service
:
store
'
_private
.
Store
)
;
}
}
function
initializeDataAdapter
(
registry
)
{
registry
.
register
(
'
data
-
adapter
:
main
'
_private
.
DebugAdapter
)
;
}
function
initializeStoreInjections
(
registry
)
{
var
inject
=
registry
.
inject
|
|
registry
.
injection
;
inject
.
call
(
registry
'
controller
'
'
store
'
'
service
:
store
'
)
;
inject
.
call
(
registry
'
route
'
'
store
'
'
service
:
store
'
)
;
inject
.
call
(
registry
'
data
-
adapter
'
'
store
'
'
service
:
store
'
)
;
}
function
initializeTransforms
(
registry
)
{
registry
.
register
(
'
transform
:
boolean
'
_boolean
.
default
)
;
registry
.
register
(
'
transform
:
date
'
_date
.
default
)
;
registry
.
register
(
'
transform
:
number
'
_number
.
default
)
;
registry
.
register
(
'
transform
:
string
'
_string
.
default
)
;
}
function
setupContainer
(
application
)
{
initializeDataAdapter
(
application
)
;
initializeTransforms
(
application
)
;
initializeStoreInjections
(
application
)
;
initializeStore
(
application
)
;
}
}
)
;
;
define
(
'
ember
-
data
/
store
'
[
'
exports
'
'
ember
-
data
/
-
private
'
]
function
(
exports
_private
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_private
.
Store
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transform
'
[
'
exports
'
'
ember
-
data
/
transforms
/
transform
'
]
function
(
exports
_transform
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_transform
.
default
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transforms
/
boolean
'
[
'
exports
'
'
ember
-
data
/
transforms
/
transform
'
]
function
(
exports
_transform
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
_transform
.
default
.
extend
(
{
deserialize
(
serialized
options
)
{
if
(
Ember
.
isNone
(
serialized
)
&
&
options
.
allowNull
=
=
=
true
)
{
return
null
;
}
var
type
=
typeof
serialized
;
if
(
type
=
=
=
"
boolean
"
)
{
return
serialized
;
}
else
if
(
type
=
=
=
"
string
"
)
{
return
(
/
^
(
true
|
t
|
1
)
/
i
.
test
(
serialized
)
)
;
}
else
if
(
type
=
=
=
"
number
"
)
{
return
serialized
=
=
=
1
;
}
else
{
return
false
;
}
}
serialize
(
deserialized
options
)
{
if
(
Ember
.
isNone
(
deserialized
)
&
&
options
.
allowNull
=
=
=
true
)
{
return
null
;
}
return
Boolean
(
deserialized
)
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transforms
/
date
'
[
'
exports
'
'
ember
-
data
/
transforms
/
transform
'
]
function
(
exports
_transform
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
_transform
.
default
.
extend
(
{
deserialize
(
serialized
)
{
var
type
=
typeof
serialized
;
if
(
type
=
=
=
"
string
"
)
{
var
offset
=
serialized
.
indexOf
(
'
+
'
)
;
if
(
offset
!
=
=
-
1
&
&
serialized
.
length
-
5
=
=
=
offset
)
{
offset
+
=
3
;
return
new
Date
(
serialized
.
slice
(
0
offset
)
+
'
:
'
+
serialized
.
slice
(
offset
)
)
;
}
return
new
Date
(
serialized
)
;
}
else
if
(
type
=
=
=
"
number
"
)
{
return
new
Date
(
serialized
)
;
}
else
if
(
serialized
=
=
=
null
|
|
serialized
=
=
=
undefined
)
{
return
serialized
;
}
else
{
return
null
;
}
}
serialize
(
date
)
{
if
(
date
instanceof
Date
&
&
!
isNaN
(
date
)
)
{
return
date
.
toISOString
(
)
;
}
else
{
return
null
;
}
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transforms
/
number
'
[
'
exports
'
'
ember
-
data
/
transforms
/
transform
'
]
function
(
exports
_transform
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
function
isNumber
(
value
)
{
return
value
=
=
=
value
&
&
value
!
=
=
Infinity
&
&
value
!
=
=
-
Infinity
;
}
exports
.
default
=
_transform
.
default
.
extend
(
{
deserialize
(
serialized
)
{
var
transformed
=
void
0
;
if
(
Ember
.
isEmpty
(
serialized
)
)
{
return
null
;
}
else
{
transformed
=
Number
(
serialized
)
;
return
isNumber
(
transformed
)
?
transformed
:
null
;
}
}
serialize
(
deserialized
)
{
var
transformed
=
void
0
;
if
(
Ember
.
isEmpty
(
deserialized
)
)
{
return
null
;
}
else
{
transformed
=
Number
(
deserialized
)
;
return
isNumber
(
transformed
)
?
transformed
:
null
;
}
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transforms
/
string
'
[
'
exports
'
'
ember
-
data
/
transforms
/
transform
'
]
function
(
exports
_transform
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
_transform
.
default
.
extend
(
{
deserialize
(
serialized
)
{
return
Ember
.
isNone
(
serialized
)
?
null
:
String
(
serialized
)
;
}
serialize
(
deserialized
)
{
return
Ember
.
isNone
(
deserialized
)
?
null
:
String
(
deserialized
)
;
}
}
)
;
}
)
;
;
define
(
'
ember
-
data
/
transforms
/
transform
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Ember
.
Object
.
extend
(
{
serialize
:
null
deserialize
:
null
}
)
;
}
)
;
;
define
(
"
ember
-
data
/
version
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
"
3
.
0
.
2
"
;
}
)
;
;
