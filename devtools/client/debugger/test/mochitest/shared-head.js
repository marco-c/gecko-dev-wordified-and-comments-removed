"
use
strict
"
;
function
createDebuggerContext
(
toolbox
)
{
const
panel
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
const
win
=
panel
.
panelWin
;
return
{
.
.
.
win
.
dbg
commands
:
toolbox
.
commands
toolbox
win
panel
}
;
}
var
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
const
asyncStorage
=
require
(
"
devtools
/
shared
/
async
-
storage
"
)
;
const
{
getSelectedLocation
}
=
require
(
"
devtools
/
client
/
debugger
/
src
/
utils
/
selected
-
location
"
)
;
const
{
createLocation
}
=
require
(
"
devtools
/
client
/
debugger
/
src
/
utils
/
location
"
)
;
const
{
resetSchemaVersion
}
=
require
(
"
devtools
/
client
/
debugger
/
src
/
utils
/
prefs
"
)
;
const
{
getUnicodeUrlPath
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
unicode
-
url
.
js
"
)
;
const
{
isGeneratedId
}
=
require
(
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
)
;
const
DEBUGGER_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
debugger
.
properties
"
)
;
function
waitForState
(
dbg
predicate
msg
)
{
return
new
Promise
(
resolve
=
>
{
info
(
Waiting
for
state
change
:
{
msg
|
|
"
"
}
)
;
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
info
(
Finished
waiting
for
state
change
:
{
msg
|
|
"
"
}
)
;
resolve
(
)
;
return
;
}
const
unsubscribe
=
dbg
.
store
.
subscribe
(
(
)
=
>
{
const
result
=
predicate
(
dbg
.
store
.
getState
(
)
)
;
if
(
result
)
{
info
(
Finished
waiting
for
state
change
:
{
msg
|
|
"
"
}
)
;
unsubscribe
(
)
;
resolve
(
result
)
;
}
}
)
;
}
)
;
}
async
function
waitForSources
(
dbg
.
.
.
sources
)
{
if
(
sources
.
length
=
=
=
0
)
{
return
;
}
info
(
Waiting
on
sources
:
{
sources
.
join
(
"
"
)
}
)
;
await
Promise
.
all
(
sources
.
map
(
url
=
>
{
if
(
!
sourceExists
(
dbg
url
)
)
{
return
waitForState
(
dbg
(
)
=
>
sourceExists
(
dbg
url
)
source
{
url
}
exists
)
;
}
return
Promise
.
resolve
(
)
;
}
)
)
;
info
(
Finished
waiting
on
sources
:
{
sources
.
join
(
"
"
)
}
)
;
}
function
waitForSource
(
dbg
url
)
{
return
waitForState
(
dbg
state
=
>
findSource
(
dbg
url
{
silent
:
true
}
)
"
source
exists
"
)
;
}
async
function
waitForElement
(
dbg
name
.
.
.
args
)
{
await
waitUntil
(
(
)
=
>
findElement
(
dbg
name
.
.
.
args
)
)
;
return
findElement
(
dbg
name
.
.
.
args
)
;
}
async
function
waitForAllElements
(
dbg
name
count
=
1
countStrictlyEqual
=
false
)
{
await
waitUntil
(
(
)
=
>
{
const
elsCount
=
findAllElements
(
dbg
name
)
.
length
;
return
countStrictlyEqual
?
elsCount
=
=
=
count
:
elsCount
>
=
count
;
}
)
;
return
findAllElements
(
dbg
name
)
;
}
async
function
waitForElementWithSelector
(
dbg
selector
)
{
await
waitUntil
(
(
)
=
>
findElementWithSelector
(
dbg
selector
)
)
;
return
findElementWithSelector
(
dbg
selector
)
;
}
function
waitForRequestsToSettle
(
dbg
)
{
return
dbg
.
commands
.
client
.
waitForRequestsToSettle
(
)
;
}
function
assertClass
(
el
className
exists
=
true
)
{
if
(
exists
)
{
ok
(
el
.
classList
.
contains
(
className
)
{
className
}
class
exists
)
;
}
else
{
ok
(
!
el
.
classList
.
contains
(
className
)
{
className
}
class
does
not
exist
)
;
}
}
function
waitForSelectedLocation
(
dbg
line
column
)
{
return
waitForState
(
dbg
state
=
>
{
const
location
=
dbg
.
selectors
.
getSelectedLocation
(
)
;
return
(
location
&
&
(
line
?
location
.
line
=
=
line
:
true
)
&
&
(
column
?
location
.
column
=
=
column
:
true
)
)
;
}
)
;
}
function
waitForSelectedSource
(
dbg
sourceOrUrl
)
{
const
{
getSelectedSourceTextContent
getSymbols
getBreakableLines
getSourceActorsForSource
getSourceActorBreakableLines
getFirstSourceActorForGeneratedSource
}
=
dbg
.
selectors
;
return
waitForState
(
dbg
state
=
>
{
const
location
=
dbg
.
selectors
.
getSelectedLocation
(
)
|
|
{
}
;
const
sourceTextContent
=
getSelectedSourceTextContent
(
)
;
if
(
!
sourceTextContent
)
{
return
false
;
}
if
(
sourceOrUrl
)
{
if
(
typeof
sourceOrUrl
=
=
"
string
"
)
{
const
url
=
location
.
source
.
url
;
if
(
typeof
url
!
=
"
string
"
|
|
!
url
.
includes
(
encodeURI
(
sourceOrUrl
)
)
)
{
return
false
;
}
}
else
if
(
location
.
source
.
id
!
=
sourceOrUrl
.
id
)
{
return
false
;
}
}
if
(
!
getSymbols
(
location
)
&
&
!
isWasmBinarySource
(
location
.
source
)
)
{
return
false
;
}
if
(
location
.
source
.
isHTML
)
{
const
sourceActors
=
getSourceActorsForSource
(
location
.
source
.
id
)
;
const
allSourceActorsProcessed
=
sourceActors
.
every
(
sourceActor
=
>
!
!
getSourceActorBreakableLines
(
sourceActor
.
id
)
)
;
return
allSourceActorsProcessed
;
}
if
(
!
getBreakableLines
(
location
.
source
.
id
)
)
{
return
false
;
}
return
getCM
(
dbg
)
.
getValue
(
)
!
=
=
DEBUGGER_L10N
.
getStr
(
"
loadingText
"
)
;
}
"
selected
source
"
)
;
}
function
isWasmBinarySource
(
source
)
{
return
source
.
isWasm
&
&
!
source
.
isOriginal
;
}
function
getVisibleSelectedFrameLine
(
dbg
)
{
const
frame
=
dbg
.
selectors
.
getVisibleSelectedFrame
(
)
;
return
frame
?
.
location
.
line
;
}
function
getVisibleSelectedFrameColumn
(
dbg
)
{
const
frame
=
dbg
.
selectors
.
getVisibleSelectedFrame
(
)
;
return
frame
?
.
location
.
column
;
}
function
assertLineIsBreakable
(
dbg
file
line
shouldBeBreakable
)
{
const
lineInfo
=
getCM
(
dbg
)
.
lineInfo
(
line
-
1
)
;
const
lineText
=
{
line
}
|
{
lineInfo
.
text
.
substring
(
0
50
)
}
{
lineInfo
.
text
.
length
>
50
?
"
"
:
"
"
}
in
{
file
}
;
if
(
shouldBeBreakable
)
{
ok
(
!
lineInfo
.
wrapClass
?
.
includes
(
"
empty
-
line
"
)
{
lineText
}
should
be
breakable
)
;
}
else
{
ok
(
lineInfo
?
.
wrapClass
?
.
includes
(
"
empty
-
line
"
)
{
lineText
}
should
NOT
be
breakable
)
;
}
}
function
assertHighlightLocation
(
dbg
source
line
)
{
source
=
findSource
(
dbg
source
)
;
is
(
dbg
.
selectors
.
getSelectedSource
(
)
.
url
source
.
url
"
source
url
is
correct
"
)
;
const
lineEl
=
findElement
(
dbg
"
highlightLine
"
)
;
ok
(
lineEl
"
Line
is
highlighted
"
)
;
is
(
findAllElements
(
dbg
"
highlightLine
"
)
.
length
1
"
Only
1
line
is
highlighted
"
)
;
ok
(
isVisibleInEditor
(
dbg
lineEl
)
"
Highlighted
line
is
visible
"
)
;
const
cm
=
getCM
(
dbg
)
;
const
lineInfo
=
cm
.
lineInfo
(
line
-
1
)
;
ok
(
lineInfo
.
wrapClass
.
includes
(
"
highlight
-
line
"
)
"
Line
is
highlighted
"
)
;
}
function
_assertDebugLine
(
dbg
line
column
)
{
const
source
=
dbg
.
selectors
.
getSelectedSource
(
)
;
if
(
isWasmBinarySource
(
source
)
)
{
line
=
dbg
.
wasmOffsetToLine
(
source
.
id
line
)
+
1
;
}
const
lineInfo
=
getCM
(
dbg
)
.
lineInfo
(
line
-
1
)
;
const
sourceTextContent
=
dbg
.
selectors
.
getSelectedSourceTextContent
(
)
;
if
(
source
&
&
!
sourceTextContent
)
{
const
url
=
source
.
url
;
ok
(
false
Looks
like
the
source
{
url
}
is
still
loading
.
Try
adding
waitForLoadedSource
in
the
test
.
)
;
return
;
}
getCM
(
dbg
)
.
scrollIntoView
(
{
line
ch
:
0
}
)
;
if
(
!
lineInfo
.
wrapClass
)
{
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
ok
(
false
Expected
pause
line
on
line
{
line
}
it
is
on
{
pauseLine
}
)
;
return
;
}
ok
(
lineInfo
?
.
wrapClass
.
includes
(
"
new
-
debug
-
line
"
)
Line
{
line
}
is
not
highlighted
as
paused
)
;
const
debugLine
=
findElement
(
dbg
"
debugLine
"
)
|
|
findElement
(
dbg
"
debugErrorLine
"
)
;
is
(
findAllElements
(
dbg
"
debugLine
"
)
.
length
+
findAllElements
(
dbg
"
debugErrorLine
"
)
.
length
1
"
There
is
only
one
line
"
)
;
ok
(
isVisibleInEditor
(
dbg
debugLine
)
"
debug
line
is
visible
"
)
;
const
markedSpans
=
lineInfo
.
handle
.
markedSpans
;
if
(
markedSpans
&
&
markedSpans
.
length
&
&
!
isWasmBinarySource
(
source
)
)
{
const
hasExpectedDebugLine
=
markedSpans
.
some
(
span
=
>
span
.
marker
.
className
?
.
includes
(
"
debug
-
expression
"
)
&
&
(
!
column
|
|
span
.
from
=
=
column
)
)
;
ok
(
hasExpectedDebugLine
"
Got
the
expected
DebugLine
.
i
.
e
.
got
the
right
marker
in
codemirror
visualizing
the
breakpoint
"
)
;
}
info
(
Paused
on
line
{
line
}
)
;
}
function
assertPausedAtSourceAndLine
(
dbg
expectedSourceId
expectedLine
expectedColumn
)
{
assertPaused
(
dbg
)
;
ok
(
isSelectedFrameSelected
(
dbg
)
"
top
frame
'
s
source
is
selected
"
)
;
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
is
(
pauseLine
expectedLine
"
Redux
state
for
currently
selected
frame
'
s
line
is
correct
"
)
;
const
pauseColumn
=
getVisibleSelectedFrameColumn
(
dbg
)
;
if
(
expectedColumn
)
{
is
(
pauseColumn
+
1
expectedColumn
"
Redux
state
for
currently
selected
frame
'
s
column
is
correct
"
)
;
}
_assertDebugLine
(
dbg
pauseLine
pauseColumn
)
;
ok
(
isVisibleInEditor
(
dbg
getCM
(
dbg
)
.
display
.
gutters
)
"
gutter
is
visible
"
)
;
const
frames
=
dbg
.
selectors
.
getCurrentThreadFrames
(
)
;
const
selectedSource
=
dbg
.
selectors
.
getSelectedSource
(
)
;
if
(
isWasmBinarySource
(
selectedSource
)
)
{
return
;
}
ok
(
frames
.
length
>
=
1
"
Got
at
least
one
frame
"
)
;
const
{
source
line
column
}
=
isGeneratedId
(
expectedSourceId
)
?
frames
[
0
]
.
generatedLocation
:
frames
[
0
]
.
location
;
is
(
source
.
id
expectedSourceId
"
Frame
has
correct
source
"
)
;
is
(
line
expectedLine
Frame
paused
at
line
{
line
}
but
expected
line
{
expectedLine
}
)
;
if
(
expectedColumn
)
{
is
(
column
+
1
expectedColumn
Frame
paused
at
column
{
column
+
1
}
but
expected
column
{
expectedColumn
}
)
;
}
}
async
function
waitForThreadCount
(
dbg
count
)
{
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getThreads
(
state
)
.
length
=
=
count
)
;
}
async
function
waitForLoadedScopes
(
dbg
)
{
const
scopes
=
await
waitForElement
(
dbg
"
scopes
"
)
;
await
waitUntil
(
(
)
=
>
scopes
.
querySelector
(
'
.
tree
-
node
[
aria
-
level
=
"
2
"
]
'
)
)
;
}
function
waitForBreakpointCount
(
dbg
count
)
{
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getBreakpointCount
(
)
=
=
count
)
;
}
function
waitForBreakpoint
(
dbg
url
line
)
{
return
waitForState
(
dbg
(
)
=
>
findBreakpoint
(
dbg
url
line
)
)
;
}
function
waitForBreakpointRemoved
(
dbg
url
line
)
{
return
waitForState
(
dbg
(
)
=
>
!
findBreakpoint
(
dbg
url
line
)
)
;
}
function
isPaused
(
dbg
)
{
return
dbg
.
selectors
.
getIsCurrentThreadPaused
(
)
;
}
function
assertNotPaused
(
dbg
msg
=
"
client
is
not
paused
"
)
{
ok
(
!
isPaused
(
dbg
)
msg
)
;
}
function
assertPaused
(
dbg
msg
=
"
client
is
paused
"
)
{
ok
(
isPaused
(
dbg
)
msg
)
;
}
async
function
waitForPaused
(
dbg
url
options
=
{
shouldWaitForLoadedScopes
:
true
}
)
{
info
(
"
Waiting
for
the
debugger
to
pause
"
)
;
const
{
getSelectedScope
getCurrentThread
getCurrentThreadFrames
}
=
dbg
.
selectors
;
await
waitForState
(
dbg
state
=
>
isPaused
(
dbg
)
&
&
!
!
getSelectedScope
(
getCurrentThread
(
)
)
"
paused
"
)
;
await
waitForState
(
dbg
getCurrentThreadFrames
"
fetched
frames
"
)
;
if
(
options
.
shouldWaitForLoadedScopes
)
{
await
waitForLoadedScopes
(
dbg
)
;
}
await
waitForSelectedSource
(
dbg
url
)
;
}
function
waitForResumed
(
dbg
)
{
info
(
"
Waiting
for
the
debugger
to
resume
"
)
;
return
waitForState
(
dbg
state
=
>
!
dbg
.
selectors
.
getIsCurrentThreadPaused
(
)
)
;
}
function
waitForInlinePreviews
(
dbg
)
{
return
waitForState
(
dbg
(
)
=
>
dbg
.
selectors
.
getSelectedInlinePreviews
(
)
)
;
}
function
waitForCondition
(
dbg
condition
)
{
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getBreakpointsList
(
)
.
find
(
bp
=
>
bp
.
options
.
condition
=
=
condition
)
)
;
}
function
waitForLog
(
dbg
logValue
)
{
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getBreakpointsList
(
)
.
find
(
bp
=
>
bp
.
options
.
logValue
=
=
logValue
)
)
;
}
async
function
waitForPausedThread
(
dbg
thread
)
{
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getIsPaused
(
thread
)
)
;
}
function
isSelectedFrameSelected
(
dbg
state
)
{
const
frame
=
dbg
.
selectors
.
getVisibleSelectedFrame
(
)
;
const
source
=
dbg
.
selectors
.
getSelectedSource
(
)
;
const
sourceTextContent
=
dbg
.
selectors
.
getSelectedSourceTextContent
(
)
;
if
(
!
source
|
|
!
sourceTextContent
)
{
return
false
;
}
return
source
.
id
=
=
frame
.
location
.
source
.
id
;
}
function
isFrameSelected
(
dbg
index
title
)
{
const
frame
=
findElement
(
dbg
"
frame
"
index
)
;
const
{
selectors
:
{
getSelectedFrame
getCurrentThread
}
}
=
dbg
;
const
frame
=
getSelectedFrame
(
getCurrentThread
(
)
)
;
const
elSelected
=
frame
.
classList
.
contains
(
"
selected
"
)
;
const
titleSelected
=
frame
.
displayName
=
=
title
;
return
elSelected
&
&
titleSelected
;
}
async
function
clearDebuggerPreferences
(
prefs
=
[
]
)
{
resetSchemaVersion
(
)
;
asyncStorage
.
clear
(
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
alphabetize
-
outline
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pause
-
on
-
exceptions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pause
-
on
-
caught
-
exceptions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
ignore
-
caught
-
exceptions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pending
-
selected
-
location
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
expressions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
breakpoints
-
visible
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
call
-
stack
-
visible
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
scopes
-
visible
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
skip
-
pausing
"
)
;
for
(
const
pref
of
prefs
)
{
await
pushPref
(
.
.
.
pref
)
;
}
}
async
function
initDebugger
(
url
.
.
.
sources
)
{
return
initDebuggerWithAbsoluteURL
(
EXAMPLE_URL
+
url
.
.
.
sources
)
;
}
async
function
initDebuggerWithAbsoluteURL
(
url
.
.
.
sources
)
{
await
clearDebuggerPreferences
(
)
;
const
toolbox
=
await
openNewTabAndToolbox
(
url
"
jsdebugger
"
)
;
const
dbg
=
createDebuggerContext
(
toolbox
)
;
await
waitForSources
(
dbg
.
.
.
sources
)
;
return
dbg
;
}
async
function
initPane
(
url
pane
prefs
)
{
await
clearDebuggerPreferences
(
prefs
)
;
return
openNewTabAndToolbox
(
EXAMPLE_URL
+
url
pane
)
;
}
function
findSource
(
dbg
filenameOrUrlOrSource
{
silent
}
=
{
silent
:
false
}
)
{
if
(
typeof
filenameOrUrlOrSource
!
=
=
"
string
"
)
{
return
filenameOrUrlOrSource
;
}
const
sources
=
dbg
.
selectors
.
getSourceList
(
)
;
const
source
=
sources
.
find
(
s
=
>
{
const
sourceFileName
=
s
.
url
?
getUnicodeUrlPath
(
s
.
url
.
substring
(
s
.
url
.
lastIndexOf
(
"
/
"
)
+
1
)
)
:
"
"
;
return
(
sourceFileName
=
=
filenameOrUrlOrSource
|
|
s
.
url
=
=
filenameOrUrlOrSource
)
;
}
)
;
if
(
!
source
)
{
if
(
silent
)
{
return
false
;
}
throw
new
Error
(
Unable
to
find
source
:
{
filenameOrUrlOrSource
}
)
;
}
return
source
;
}
function
findSourceContent
(
dbg
url
opts
)
{
const
source
=
findSource
(
dbg
url
opts
)
;
if
(
!
source
)
{
return
null
;
}
const
content
=
dbg
.
selectors
.
getSettledSourceTextContent
(
createLocation
(
{
source
}
)
)
;
if
(
!
content
)
{
return
null
;
}
if
(
content
.
state
!
=
=
"
fulfilled
"
)
{
throw
new
Error
(
Expected
loaded
source
got
{
content
.
value
}
)
;
}
return
content
.
value
;
}
function
sourceExists
(
dbg
url
)
{
return
!
!
findSource
(
dbg
url
{
silent
:
true
}
)
;
}
function
waitForLoadedSource
(
dbg
url
)
{
return
waitForState
(
dbg
state
=
>
{
const
source
=
findSource
(
dbg
url
{
silent
:
true
}
)
;
return
(
source
&
&
dbg
.
selectors
.
getSettledSourceTextContent
(
createLocation
(
{
source
}
)
)
)
;
}
"
loaded
source
"
)
;
}
async
function
selectSourceFromSourceTree
(
dbg
fileName
sourcePosition
message
)
{
info
(
message
)
;
await
clickElement
(
dbg
"
sourceNode
"
sourcePosition
)
;
await
waitForSelectedSource
(
dbg
fileName
)
;
await
waitFor
(
(
)
=
>
getCM
(
dbg
)
.
getValue
(
)
!
=
=
Loading
"
Wait
for
source
to
completely
load
"
)
;
}
async
function
triggerSourceTreeContextMenu
(
dbg
sourceTreeNode
contextMenuItem
)
{
const
onContextMenu
=
waitForContextMenu
(
dbg
)
;
rightClickEl
(
dbg
sourceTreeNode
)
;
const
menupopup
=
await
onContextMenu
;
const
onHidden
=
new
Promise
(
resolve
=
>
{
menupopup
.
addEventListener
(
"
popuphidden
"
resolve
{
once
:
true
}
)
;
}
)
;
selectContextMenuItem
(
dbg
contextMenuItem
)
;
await
onHidden
;
}
async
function
selectSource
(
dbg
url
line
column
)
{
const
source
=
findSource
(
dbg
url
)
;
await
dbg
.
actions
.
selectLocation
(
createLocation
(
{
source
line
column
}
)
{
keepContext
:
false
}
)
;
return
waitForSelectedSource
(
dbg
source
)
;
}
async
function
closeTab
(
dbg
url
)
{
await
dbg
.
actions
.
closeTab
(
findSource
(
dbg
url
)
)
;
}
function
countTabs
(
dbg
)
{
return
findElement
(
dbg
"
sourceTabs
"
)
.
children
.
length
;
}
async
function
stepOver
(
dbg
pauseOptions
)
{
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
info
(
Stepping
over
from
{
pauseLine
}
)
;
await
dbg
.
actions
.
stepOver
(
)
;
return
waitForPaused
(
dbg
null
pauseOptions
)
;
}
async
function
stepIn
(
dbg
)
{
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
info
(
Stepping
in
from
{
pauseLine
}
)
;
await
dbg
.
actions
.
stepIn
(
)
;
return
waitForPaused
(
dbg
)
;
}
async
function
stepOut
(
dbg
)
{
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
info
(
Stepping
out
from
{
pauseLine
}
)
;
await
dbg
.
actions
.
stepOut
(
)
;
return
waitForPaused
(
dbg
)
;
}
async
function
resume
(
dbg
)
{
const
pauseLine
=
getVisibleSelectedFrameLine
(
dbg
)
;
info
(
Resuming
from
{
pauseLine
}
)
;
const
onResumed
=
waitForResumed
(
dbg
)
;
await
dbg
.
actions
.
resume
(
)
;
return
onResumed
;
}
function
deleteExpression
(
dbg
input
)
{
info
(
Delete
expression
"
{
input
}
"
)
;
return
dbg
.
actions
.
deleteExpression
(
{
input
}
)
;
}
async
function
reload
(
dbg
.
.
.
sources
)
{
await
reloadBrowser
(
)
;
return
waitForSources
(
dbg
.
.
.
sources
)
;
}
async
function
reloadWhenPausedBeforePageLoaded
(
dbg
.
.
.
sources
)
{
const
{
resourceCommand
}
=
dbg
.
commands
;
const
{
onResource
:
onTopLevelDomLoading
}
=
await
resourceCommand
.
waitForNextResource
(
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
targetFront
.
isTopLevel
&
&
resource
.
name
=
=
=
"
dom
-
loading
"
}
)
;
gBrowser
.
reloadTab
(
gBrowser
.
selectedTab
)
;
info
(
"
Wait
for
DOCUMENT_EVENT
dom
-
loading
after
reload
"
)
;
await
onTopLevelDomLoading
;
return
waitForSources
(
dbg
.
.
.
sources
)
;
}
async
function
navigate
(
dbg
url
.
.
.
sources
)
{
return
navigateToAbsoluteURL
(
dbg
EXAMPLE_URL
+
url
.
.
.
sources
)
;
}
async
function
navigateToAbsoluteURL
(
dbg
url
.
.
.
sources
)
{
await
navigateTo
(
url
)
;
return
waitForSources
(
dbg
.
.
.
sources
)
;
}
function
getFirstBreakpointColumn
(
dbg
source
line
)
{
const
position
=
dbg
.
selectors
.
getFirstBreakpointPosition
(
createLocation
(
{
line
source
}
)
)
;
return
getSelectedLocation
(
position
source
)
.
column
;
}
function
isMatchingLocation
(
location1
location2
)
{
return
(
location1
?
.
source
.
id
=
=
location2
?
.
source
.
id
&
&
location1
?
.
line
=
=
location2
?
.
line
&
&
location1
?
.
column
=
=
location2
?
.
column
)
;
}
function
getBreakpointForLocation
(
dbg
location
)
{
if
(
!
location
)
{
return
undefined
;
}
const
isGeneratedSource
=
isGeneratedId
(
location
.
source
.
id
)
;
return
dbg
.
selectors
.
getBreakpointsList
(
)
.
find
(
bp
=
>
{
const
loc
=
isGeneratedSource
?
bp
.
generatedLocation
:
bp
.
location
;
return
isMatchingLocation
(
loc
location
)
;
}
)
;
}
async
function
addBreakpoint
(
dbg
source
line
column
options
)
{
source
=
findSource
(
dbg
source
)
;
const
bpCount
=
dbg
.
selectors
.
getBreakpointCount
(
)
;
const
onBreakpoint
=
waitForDispatch
(
dbg
.
store
"
SET_BREAKPOINT
"
)
;
await
dbg
.
actions
.
addBreakpoint
(
createLocation
(
{
source
line
column
:
column
-
1
}
)
options
)
;
await
onBreakpoint
;
is
(
dbg
.
selectors
.
getBreakpointCount
(
)
bpCount
+
1
"
a
new
breakpoint
was
created
"
)
;
}
async
function
addBreakpointViaGutter
(
dbg
line
)
{
info
(
Add
breakpoint
via
the
editor
on
line
{
line
}
)
;
await
clickGutter
(
dbg
line
)
;
return
waitForDispatch
(
dbg
.
store
"
SET_BREAKPOINT
"
)
;
}
function
disableBreakpoint
(
dbg
source
line
column
)
{
if
(
column
=
=
=
0
)
{
throw
new
Error
(
"
disableBreakpoint
expect
a
1
-
based
column
argument
"
)
;
}
const
internalColumn
=
column
?
column
-
1
:
getFirstBreakpointColumn
(
dbg
source
line
)
;
const
location
=
createLocation
(
{
source
line
column
:
internalColumn
}
)
;
const
bp
=
getBreakpointForLocation
(
dbg
location
)
;
return
dbg
.
actions
.
disableBreakpoint
(
bp
)
;
}
function
findBreakpoint
(
dbg
url
line
)
{
const
source
=
findSource
(
dbg
url
)
;
return
dbg
.
selectors
.
getBreakpointsForSource
(
source
line
)
[
0
]
;
}
function
findColumnBreakpoint
(
dbg
url
line
column
)
{
const
source
=
findSource
(
dbg
url
)
;
const
lineBreakpoints
=
dbg
.
selectors
.
getBreakpointsForSource
(
source
line
)
;
return
lineBreakpoints
.
find
(
bp
=
>
{
return
source
.
isOriginal
?
bp
.
location
.
column
=
=
=
column
:
bp
.
generatedLocation
.
column
=
=
=
column
;
}
)
;
}
async
function
loadAndAddBreakpoint
(
dbg
filename
line
column
)
{
const
{
selectors
:
{
getBreakpoint
getBreakpointCount
getBreakpointsMap
}
}
=
dbg
;
await
waitForSources
(
dbg
filename
)
;
ok
(
true
"
Original
sources
exist
"
)
;
const
source
=
findSource
(
dbg
filename
)
;
await
selectSource
(
dbg
source
)
;
await
addBreakpoint
(
dbg
source
line
column
)
;
is
(
getBreakpointCount
(
)
1
"
One
breakpoint
exists
"
)
;
if
(
!
getBreakpoint
(
createLocation
(
{
source
line
column
:
column
-
1
}
)
)
)
{
const
breakpoints
=
getBreakpointsMap
(
)
;
const
id
=
Object
.
keys
(
breakpoints
)
.
pop
(
)
;
const
loc
=
breakpoints
[
id
]
.
location
;
ok
(
false
Breakpoint
has
correct
line
{
line
}
column
{
column
}
but
was
line
{
loc
.
line
}
column
{
loc
.
column
+
1
}
)
;
}
return
source
;
}
async
function
invokeWithBreakpoint
(
dbg
fnName
filename
{
line
column
}
handler
pauseOptions
)
{
const
source
=
await
loadAndAddBreakpoint
(
dbg
filename
line
column
)
;
const
invokeResult
=
invokeInTab
(
fnName
)
;
const
invokeFailed
=
await
Promise
.
race
(
[
waitForPaused
(
dbg
null
pauseOptions
)
invokeResult
.
then
(
(
)
=
>
new
Promise
(
(
)
=
>
{
}
)
(
)
=
>
true
)
]
)
;
if
(
invokeFailed
)
{
await
invokeResult
;
return
;
}
assertPausedAtSourceAndLine
(
dbg
findSource
(
dbg
filename
)
.
id
line
column
)
;
await
removeBreakpoint
(
dbg
source
.
id
line
column
)
;
is
(
dbg
.
selectors
.
getBreakpointCount
(
)
0
"
Breakpoint
reverted
"
)
;
await
handler
(
source
)
;
await
resume
(
dbg
)
;
await
invokeResult
;
}
function
prettyPrint
(
dbg
)
{
const
source
=
dbg
.
selectors
.
getSelectedSource
(
)
;
return
dbg
.
actions
.
prettyPrintAndSelectSource
(
source
)
;
}
async
function
expandAllScopes
(
dbg
)
{
const
scopes
=
await
waitForElement
(
dbg
"
scopes
"
)
;
const
scopeElements
=
scopes
.
querySelectorAll
(
'
.
tree
-
node
[
aria
-
level
=
"
1
"
]
[
data
-
expandable
=
"
true
"
]
:
not
(
[
aria
-
expanded
=
"
true
"
]
)
'
)
;
const
indices
=
Array
.
from
(
scopeElements
el
=
>
{
return
Array
.
prototype
.
indexOf
.
call
(
el
.
parentNode
.
childNodes
el
)
;
}
)
.
reverse
(
)
;
for
(
const
index
of
indices
)
{
await
toggleScopeNode
(
dbg
index
+
1
)
;
}
}
async
function
assertScopes
(
dbg
items
)
{
await
expandAllScopes
(
dbg
)
;
for
(
const
[
i
val
]
of
items
.
entries
(
)
)
{
if
(
Array
.
isArray
(
val
)
)
{
is
(
getScopeNodeLabel
(
dbg
i
+
1
)
val
[
0
]
)
;
is
(
getScopeNodeValue
(
dbg
i
+
1
)
val
[
1
]
"
{
val
[
0
]
}
"
has
the
expected
"
{
val
[
1
]
}
"
value
)
;
}
else
{
is
(
getScopeNodeLabel
(
dbg
i
+
1
)
val
)
;
}
}
is
(
getScopeNodeLabel
(
dbg
items
.
length
+
1
)
"
Window
"
)
;
}
function
findSourceTreeThreadByName
(
dbg
name
)
{
return
[
.
.
.
findAllElements
(
dbg
"
sourceTreeThreads
"
)
]
.
find
(
el
=
>
{
return
el
.
textContent
.
includes
(
name
)
;
}
)
;
}
function
findSourceNodeWithText
(
dbg
text
)
{
return
[
.
.
.
findAllElements
(
dbg
"
sourceNodes
"
)
]
.
find
(
el
=
>
{
return
el
.
textContent
.
includes
(
text
)
;
}
)
;
}
function
assertSourceIcon
(
dbg
sourceName
icon
)
{
const
sourceItem
=
findSourceNodeWithText
(
dbg
sourceName
)
;
ok
(
sourceItem
Found
the
source
item
for
{
sourceName
}
)
;
is
(
sourceItem
.
querySelector
(
"
.
source
-
icon
"
)
.
className
img
source
-
icon
{
icon
}
The
icon
for
{
sourceName
}
is
correct
)
;
}
async
function
expandSourceTree
(
dbg
)
{
for
(
const
rootNode
of
dbg
.
win
.
document
.
querySelectorAll
(
"
.
sources
-
list
>
.
tree
>
.
tree
-
node
[
data
-
expandable
=
true
]
"
)
)
{
await
expandAllSourceNodes
(
dbg
rootNode
)
;
}
}
async
function
expandAllSourceNodes
(
dbg
treeNode
)
{
return
triggerSourceTreeContextMenu
(
dbg
treeNode
"
#
node
-
menu
-
expand
-
all
"
)
;
}
function
removeBreakpoint
(
dbg
sourceId
line
column
)
{
const
source
=
dbg
.
selectors
.
getSource
(
sourceId
)
;
column
=
column
?
column
-
1
:
getFirstBreakpointColumn
(
dbg
source
line
)
;
const
location
=
createLocation
(
{
source
line
column
}
)
;
const
bp
=
getBreakpointForLocation
(
dbg
location
)
;
return
dbg
.
actions
.
removeBreakpoint
(
bp
)
;
}
async
function
togglePauseOnExceptions
(
dbg
pauseOnExceptions
pauseOnCaughtExceptions
)
{
return
dbg
.
actions
.
pauseOnExceptions
(
pauseOnExceptions
pauseOnCaughtExceptions
)
;
}
function
invokeInTab
(
fnc
.
.
.
args
)
{
info
(
Invoking
in
tab
:
{
fnc
}
(
{
args
.
map
(
uneval
)
.
join
(
"
"
)
}
)
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
fnc
args
}
options
=
>
content
.
wrappedJSObject
[
options
.
fnc
]
(
.
.
.
options
.
args
)
)
;
}
function
clickElementInTab
(
selector
)
{
info
(
click
element
{
selector
}
in
tab
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
function
(
_selector
)
{
const
element
=
content
.
document
.
querySelector
(
_selector
)
;
content
.
setTimeout
(
(
)
=
>
{
element
.
click
(
)
;
}
)
;
}
)
;
}
const
isLinux
=
Services
.
appinfo
.
OS
=
=
=
"
Linux
"
;
const
isMac
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
cmdOrCtrl
=
isMac
?
{
metaKey
:
true
}
:
{
ctrlKey
:
true
}
;
const
shiftOrAlt
=
isMac
?
{
accelKey
:
true
shiftKey
:
true
}
:
{
accelKey
:
true
altKey
:
true
}
;
const
cmdShift
=
isMac
?
{
accelKey
:
true
shiftKey
:
true
metaKey
:
true
}
:
{
accelKey
:
true
shiftKey
:
true
ctrlKey
:
true
}
;
const
endKey
=
isMac
?
{
code
:
"
VK_RIGHT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_END
"
}
;
const
startKey
=
isMac
?
{
code
:
"
VK_LEFT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_HOME
"
}
;
const
keyMappings
=
{
close
:
{
code
:
"
w
"
modifiers
:
cmdOrCtrl
}
commandKeyDown
:
{
code
:
"
VK_META
"
modifiers
:
{
type
:
"
keydown
"
}
}
commandKeyUp
:
{
code
:
"
VK_META
"
modifiers
:
{
type
:
"
keyup
"
}
}
debugger
:
{
code
:
"
s
"
modifiers
:
shiftOrAlt
}
toggleCondPanel
:
{
code
:
"
b
"
modifiers
:
cmdShift
}
inspector
:
{
code
:
"
c
"
modifiers
:
shiftOrAlt
}
quickOpen
:
{
code
:
"
p
"
modifiers
:
cmdOrCtrl
}
quickOpenFunc
:
{
code
:
"
o
"
modifiers
:
cmdShift
}
quickOpenLine
:
{
code
:
"
:
"
modifiers
:
cmdOrCtrl
}
fileSearch
:
{
code
:
"
f
"
modifiers
:
cmdOrCtrl
}
projectSearch
:
{
code
:
"
f
"
modifiers
:
cmdShift
}
fileSearchNext
:
{
code
:
"
g
"
modifiers
:
{
metaKey
:
true
}
}
fileSearchPrev
:
{
code
:
"
g
"
modifiers
:
cmdShift
}
goToLine
:
{
code
:
"
g
"
modifiers
:
{
ctrlKey
:
true
}
}
Enter
:
{
code
:
"
VK_RETURN
"
}
ShiftEnter
:
{
code
:
"
VK_RETURN
"
modifiers
:
{
shiftKey
:
true
}
}
AltEnter
:
{
code
:
"
VK_RETURN
"
modifiers
:
{
altKey
:
true
}
}
Up
:
{
code
:
"
VK_UP
"
}
Down
:
{
code
:
"
VK_DOWN
"
}
Right
:
{
code
:
"
VK_RIGHT
"
}
Left
:
{
code
:
"
VK_LEFT
"
}
End
:
endKey
Start
:
startKey
Tab
:
{
code
:
"
VK_TAB
"
}
Escape
:
{
code
:
"
VK_ESCAPE
"
}
Delete
:
{
code
:
"
VK_DELETE
"
}
pauseKey
:
{
code
:
"
VK_F8
"
}
resumeKey
:
{
code
:
"
VK_F8
"
}
stepOverKey
:
{
code
:
"
VK_F10
"
}
stepInKey
:
{
code
:
"
VK_F11
"
}
stepOutKey
:
{
code
:
"
VK_F11
"
modifiers
:
{
shiftKey
:
true
}
}
Backspace
:
{
code
:
"
VK_BACK_SPACE
"
}
}
;
function
pressKey
(
dbg
keyName
)
{
const
keyEvent
=
keyMappings
[
keyName
]
;
const
{
code
modifiers
}
=
keyEvent
;
info
(
The
{
keyName
}
key
is
pressed
)
;
return
EventUtils
.
synthesizeKey
(
code
modifiers
|
|
{
}
dbg
.
win
)
;
}
function
type
(
dbg
string
)
{
string
.
split
(
"
"
)
.
forEach
(
char
=
>
EventUtils
.
synthesizeKey
(
char
{
}
dbg
.
win
)
)
;
}
function
isVisibleInEditor
(
dbg
element
)
{
return
isVisible
(
findElement
(
dbg
"
codeMirror
"
)
element
)
;
}
function
isVisible
(
outerEl
innerEl
)
{
if
(
!
innerEl
|
|
!
outerEl
)
{
return
false
;
}
const
innerRect
=
innerEl
.
getBoundingClientRect
(
)
;
const
outerRect
=
outerEl
.
getBoundingClientRect
(
)
;
const
verticallyVisible
=
innerRect
.
top
>
=
outerRect
.
top
|
|
innerRect
.
bottom
<
=
outerRect
.
bottom
|
|
(
innerRect
.
top
<
outerRect
.
top
&
&
innerRect
.
bottom
>
outerRect
.
bottom
)
;
const
horizontallyVisible
=
innerRect
.
left
>
=
outerRect
.
left
|
|
innerRect
.
right
<
=
outerRect
.
right
|
|
(
innerRect
.
left
<
outerRect
.
left
&
&
innerRect
.
right
>
outerRect
.
right
)
;
const
visible
=
verticallyVisible
&
&
horizontallyVisible
;
return
visible
;
}
async
function
getEditorLineGutter
(
dbg
line
)
{
const
lineEl
=
await
getEditorLineEl
(
dbg
line
)
;
return
lineEl
.
firstChild
;
}
async
function
getEditorLineEl
(
dbg
line
)
{
let
el
=
await
codeMirrorGutterElement
(
dbg
line
)
;
while
(
el
&
&
!
el
.
matches
(
"
.
CodeMirror
-
code
>
div
"
)
)
{
el
=
el
.
parentElement
;
}
return
el
;
}
async
function
openContextMenuInDebugger
(
dbg
elementName
line
)
{
const
waitForOpen
=
waitForContextMenu
(
dbg
)
;
info
(
Open
{
elementName
}
context
menu
on
line
{
line
|
|
"
"
}
)
;
rightClickElement
(
dbg
elementName
line
)
;
return
waitForOpen
;
}
async
function
selectEditorLinesAndOpenContextMenu
(
dbg
lines
)
{
const
{
startLine
endLine
}
=
lines
;
const
elementName
=
"
line
"
;
if
(
!
endLine
)
{
await
clickElement
(
dbg
elementName
startLine
)
;
}
else
{
getCM
(
dbg
)
.
setSelection
(
{
line
:
startLine
-
1
ch
:
0
}
{
line
:
endLine
ch
:
0
}
)
;
}
return
openContextMenuInDebugger
(
dbg
elementName
startLine
)
;
}
function
assertIgnoredStyleInSourceLines
(
dbg
{
lines
hasBlackboxedLinesClass
}
)
{
if
(
lines
)
{
let
currentLine
=
lines
[
0
]
;
do
{
const
element
=
findElement
(
dbg
"
line
"
currentLine
)
;
const
hasStyle
=
hasBlackboxedLinesClass
?
element
.
parentNode
.
classList
.
contains
(
"
blackboxed
-
line
"
)
:
!
element
.
parentNode
.
classList
.
contains
(
"
blackboxed
-
line
"
)
;
ok
(
hasStyle
Line
{
currentLine
}
{
hasBlackboxedLinesClass
?
"
does
not
have
"
:
"
has
"
}
ignored
styling
)
;
currentLine
=
currentLine
+
1
;
}
while
(
currentLine
<
=
lines
[
1
]
)
;
}
else
{
const
codeLines
=
findAllElementsWithSelector
(
dbg
"
.
CodeMirror
-
code
.
CodeMirror
-
line
"
)
;
const
blackboxedLines
=
findAllElementsWithSelector
(
dbg
"
.
CodeMirror
-
code
.
blackboxed
-
line
"
)
;
is
(
hasBlackboxedLinesClass
?
codeLines
.
length
:
0
blackboxedLines
.
length
{
blackboxedLines
.
length
}
of
{
codeLines
.
length
}
lines
are
blackboxed
)
;
}
}
function
assertTextContentOnLine
(
dbg
line
expectedTextContent
)
{
const
lineInfo
=
getCM
(
dbg
)
.
lineInfo
(
line
-
1
)
;
const
textContent
=
lineInfo
.
text
.
trim
(
)
;
is
(
textContent
expectedTextContent
Expected
text
content
on
line
{
line
}
)
;
}
async
function
assertNoBreakpoint
(
dbg
line
)
{
const
el
=
await
getEditorLineEl
(
dbg
line
)
;
const
exists
=
!
!
el
.
querySelector
(
"
.
new
-
breakpoint
"
)
;
ok
(
!
exists
Breakpoint
doesn
'
t
exists
on
line
{
line
}
)
;
}
async
function
assertBreakpoint
(
dbg
line
)
{
const
el
=
await
getEditorLineEl
(
dbg
line
)
;
const
exists
=
!
!
el
.
querySelector
(
"
.
new
-
breakpoint
"
)
;
ok
(
exists
Breakpoint
exists
on
line
{
line
}
)
;
const
hasConditionClass
=
el
.
classList
.
contains
(
"
has
-
condition
"
)
;
ok
(
!
hasConditionClass
Regular
breakpoint
doesn
'
t
have
condition
on
line
{
line
}
)
;
const
hasLogClass
=
el
.
classList
.
contains
(
"
has
-
log
"
)
;
ok
(
!
hasLogClass
Regular
breakpoint
doesn
'
t
have
log
on
line
{
line
}
)
;
}
async
function
assertConditionBreakpoint
(
dbg
line
)
{
const
el
=
await
getEditorLineEl
(
dbg
line
)
;
const
exists
=
!
!
el
.
querySelector
(
"
.
new
-
breakpoint
"
)
;
ok
(
exists
Breakpoint
exists
on
line
{
line
}
)
;
const
hasConditionClass
=
el
.
classList
.
contains
(
"
has
-
condition
"
)
;
ok
(
hasConditionClass
Conditional
breakpoint
on
line
{
line
}
)
;
const
hasLogClass
=
el
.
classList
.
contains
(
"
has
-
log
"
)
;
ok
(
!
hasLogClass
Conditional
breakpoint
doesn
'
t
have
log
breakpoint
on
line
{
line
}
)
;
}
async
function
assertLogBreakpoint
(
dbg
line
)
{
const
el
=
await
getEditorLineEl
(
dbg
line
)
;
const
exists
=
!
!
el
.
querySelector
(
"
.
new
-
breakpoint
"
)
;
ok
(
exists
Breakpoint
exists
on
line
{
line
}
)
;
const
hasConditionClass
=
el
.
classList
.
contains
(
"
has
-
condition
"
)
;
ok
(
!
hasConditionClass
Log
breakpoint
doesn
'
t
have
condition
on
line
{
line
}
)
;
const
hasLogClass
=
el
.
classList
.
contains
(
"
has
-
log
"
)
;
ok
(
hasLogClass
Log
breakpoint
on
line
{
line
}
)
;
}
function
assertBreakpointSnippet
(
dbg
index
expectedSnippet
)
{
const
actualSnippet
=
findElement
(
dbg
"
breakpointLabel
"
2
)
.
innerText
;
is
(
actualSnippet
expectedSnippet
Breakpoint
{
index
}
snippet
)
;
}
const
selectors
=
{
callStackHeader
:
"
.
call
-
stack
-
pane
.
_header
.
header
-
label
"
callStackBody
:
"
.
call
-
stack
-
pane
.
pane
"
domMutationItem
:
"
.
dom
-
mutation
-
list
li
"
expressionNode
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
object
-
label
expressionValue
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
object
-
delimiter
+
*
expressionClose
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
close
expressionInput
:
"
.
watch
-
expressions
-
pane
input
.
input
-
expression
"
expressionNodes
:
"
.
expressions
-
list
.
tree
-
node
"
expressionPlus
:
"
.
watch
-
expressions
-
pane
button
.
plus
"
expressionRefresh
:
"
.
watch
-
expressions
-
pane
button
.
refresh
"
expressionsHeader
:
"
.
watch
-
expressions
-
pane
.
_header
.
header
-
label
"
scopesHeader
:
"
.
scopes
-
pane
.
_header
.
header
-
label
"
breakpointItem
:
i
=
>
.
breakpoints
-
list
div
:
nth
-
of
-
type
(
{
i
}
)
breakpointLabel
:
i
=
>
{
selectors
.
breakpointItem
(
i
)
}
.
breakpoint
-
label
breakpointHeadings
:
"
.
breakpoints
-
list
.
breakpoint
-
heading
"
breakpointItems
:
"
.
breakpoints
-
list
.
breakpoint
"
breakpointContextMenu
:
{
disableSelf
:
"
#
node
-
menu
-
disable
-
self
"
disableAll
:
"
#
node
-
menu
-
disable
-
all
"
disableOthers
:
"
#
node
-
menu
-
disable
-
others
"
enableSelf
:
"
#
node
-
menu
-
enable
-
self
"
enableOthers
:
"
#
node
-
menu
-
enable
-
others
"
disableDbgStatement
:
"
#
node
-
menu
-
disable
-
dbgStatement
"
enableDbgStatement
:
"
#
node
-
menu
-
enable
-
dbgStatement
"
remove
:
"
#
node
-
menu
-
delete
-
self
"
removeOthers
:
"
#
node
-
menu
-
delete
-
other
"
removeCondition
:
"
#
node
-
menu
-
remove
-
condition
"
}
editorContextMenu
:
{
continueToHere
:
"
#
node
-
menu
-
continue
-
to
-
here
"
}
columnBreakpoints
:
"
.
column
-
breakpoint
"
scopes
:
"
.
scopes
-
list
"
scopeNodes
:
"
.
scopes
-
list
.
object
-
label
"
scopeNode
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
label
scopeValue
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
delimiter
+
*
mapScopesCheckbox
:
"
.
map
-
scopes
-
header
input
"
frame
:
i
=
>
.
frames
[
role
=
"
list
"
]
[
role
=
"
listitem
"
]
:
nth
-
child
(
{
i
}
)
frames
:
'
.
frames
[
role
=
"
list
"
]
[
role
=
"
listitem
"
]
'
gutter
:
i
=
>
.
CodeMirror
-
code
*
:
nth
-
child
(
{
i
}
)
.
CodeMirror
-
linenumber
line
:
i
=
>
.
CodeMirror
-
code
div
:
nth
-
child
(
{
i
}
)
.
CodeMirror
-
line
addConditionItem
:
"
#
node
-
menu
-
add
-
condition
#
node
-
menu
-
add
-
conditional
-
breakpoint
"
editConditionItem
:
"
#
node
-
menu
-
edit
-
condition
#
node
-
menu
-
edit
-
conditional
-
breakpoint
"
addLogItem
:
"
#
node
-
menu
-
add
-
log
-
point
"
editLogItem
:
"
#
node
-
menu
-
edit
-
log
-
point
"
disableItem
:
"
#
node
-
menu
-
disable
-
breakpoint
"
menuitem
:
i
=
>
menupopup
menuitem
:
nth
-
child
(
{
i
}
)
pauseOnExceptions
:
"
.
pause
-
exceptions
"
breakpoint
:
"
.
CodeMirror
-
code
>
.
new
-
breakpoint
"
highlightLine
:
"
.
CodeMirror
-
code
>
.
highlight
-
line
"
debugLine
:
"
.
new
-
debug
-
line
"
debugErrorLine
:
"
.
new
-
debug
-
line
-
error
"
codeMirror
:
"
.
CodeMirror
"
resume
:
"
.
resume
.
active
"
pause
:
"
.
pause
.
active
"
sourceTabs
:
"
.
source
-
tabs
"
activeTab
:
"
.
source
-
tab
.
active
"
stepOver
:
"
.
stepOver
.
active
"
stepOut
:
"
.
stepOut
.
active
"
stepIn
:
"
.
stepIn
.
active
"
trace
:
"
.
debugger
-
trace
-
menu
-
button
"
prettyPrintButton
:
"
.
source
-
footer
.
prettyPrint
"
mappedSourceLink
:
"
.
source
-
footer
.
mapped
-
source
"
sourcesFooter
:
"
.
sources
-
panel
.
source
-
footer
"
sourceMapFooterButton
:
"
.
debugger
-
source
-
map
-
button
"
editorFooter
:
"
.
editor
-
pane
.
source
-
footer
"
sourceNode
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
node
sourceNodes
:
"
.
sources
-
list
.
tree
-
node
"
sourceTreeThreads
:
'
.
sources
-
list
.
tree
-
node
[
aria
-
level
=
"
1
"
]
'
sourceTreeThreadsNodes
:
'
.
sources
-
list
.
tree
-
node
[
aria
-
level
=
"
1
"
]
>
.
node
>
span
:
nth
-
child
(
1
)
'
sourceTreeFiles
:
"
.
sources
-
list
.
tree
-
node
[
data
-
expandable
=
false
]
"
threadSourceTree
:
i
=
>
.
threads
-
list
.
sources
-
pane
:
nth
-
child
(
{
i
}
)
threadSourceTreeSourceNode
:
(
i
j
)
=
>
{
selectors
.
threadSourceTree
(
i
)
}
.
tree
-
node
:
nth
-
child
(
{
j
}
)
.
node
sourceDirectoryLabel
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
label
resultItems
:
"
.
result
-
list
.
result
-
item
"
resultItemName
:
(
name
i
)
=
>
{
selectors
.
resultItems
}
:
nth
-
child
(
{
i
}
)
[
title
=
"
{
name
}
"
]
fileMatch
:
"
.
project
-
text
-
search
.
line
-
value
"
popup
:
"
.
popover
"
previewPopup
:
"
.
preview
-
popup
"
openInspector
:
"
button
.
open
-
inspector
"
outlineItem
:
i
=
>
.
outline
-
list__element
:
nth
-
child
(
{
i
}
)
.
function
-
signature
outlineItems
:
"
.
outline
-
list__element
"
conditionalPanel
:
"
.
conditional
-
breakpoint
-
panel
"
conditionalPanelInput
:
"
.
conditional
-
breakpoint
-
panel
textarea
"
conditionalBreakpointInSecPane
:
"
.
breakpoint
.
is
-
conditional
"
logPointPanel
:
"
.
conditional
-
breakpoint
-
panel
.
log
-
point
"
logPointInSecPane
:
"
.
breakpoint
.
is
-
log
"
searchField
:
"
.
search
-
field
"
blackbox
:
"
.
action
.
black
-
box
"
projectSearchSearchInput
:
"
.
project
-
text
-
search
.
search
-
field
input
"
projectSearchCollapsed
:
"
.
project
-
text
-
search
.
arrow
:
not
(
.
expanded
)
"
projectSearchExpandedResults
:
"
.
project
-
text
-
search
.
result
"
projectSearchFileResults
:
"
.
project
-
text
-
search
.
file
-
result
"
projectSearchModifiersCaseSensitive
:
"
.
project
-
text
-
search
button
.
case
-
sensitive
-
btn
"
projectSearchModifiersRegexMatch
:
"
.
project
-
text
-
search
button
.
regex
-
match
-
btn
"
projectSearchModifiersWholeWordMatch
:
"
.
project
-
text
-
search
button
.
whole
-
word
-
btn
"
projectSearchRefreshButton
:
"
.
project
-
text
-
search
button
.
refresh
-
btn
"
threadsPaneItems
:
"
.
threads
-
pane
.
thread
"
threadsPaneItem
:
i
=
>
.
threads
-
pane
.
thread
:
nth
-
child
(
{
i
}
)
threadsPaneItemPause
:
i
=
>
{
selectors
.
threadsPaneItem
(
i
)
}
.
paused
CodeMirrorLines
:
"
.
CodeMirror
-
lines
"
inlinePreviewLabels
:
"
.
inline
-
preview
.
inline
-
preview
-
label
"
inlinePreviewValues
:
"
.
inline
-
preview
.
inline
-
preview
-
value
"
inlinePreviewOpenInspector
:
"
.
inline
-
preview
-
value
button
.
open
-
inspector
"
watchpointsSubmenu
:
"
#
node
-
menu
-
watchpoints
"
addGetWatchpoint
:
"
#
node
-
menu
-
add
-
get
-
watchpoint
"
addSetWatchpoint
:
"
#
node
-
menu
-
add
-
set
-
watchpoint
"
removeWatchpoint
:
"
#
node
-
menu
-
remove
-
watchpoint
"
logEventsCheckbox
:
"
.
events
-
header
input
"
previewPopupInvokeGetterButton
:
"
.
preview
-
popup
.
invoke
-
getter
"
previewPopupObjectNumber
:
"
.
preview
-
popup
.
objectBox
-
number
"
previewPopupObjectObject
:
"
.
preview
-
popup
.
objectBox
-
object
"
sourceTreeRootNode
:
"
.
sources
-
panel
.
node
.
window
"
sourceTreeFolderNode
:
"
.
sources
-
panel
.
node
.
folder
"
excludePatternsInput
:
"
.
project
-
text
-
search
.
exclude
-
patterns
-
field
input
"
fileSearchInput
:
"
.
search
-
bar
input
"
watchExpressionsHeader
:
"
.
watch
-
expressions
-
pane
.
_header
.
header
-
label
"
watchExpressionsAddButton
:
"
.
watch
-
expressions
-
pane
.
_header
.
plus
"
editorNotificationFooter
:
"
.
editor
-
notification
-
footer
"
}
;
function
getSelector
(
elementName
.
.
.
args
)
{
let
selector
=
selectors
[
elementName
]
;
if
(
!
selector
)
{
throw
new
Error
(
The
selector
{
elementName
}
is
not
defined
)
;
}
if
(
typeof
selector
=
=
"
function
"
)
{
selector
=
selector
(
.
.
.
args
)
;
}
return
selector
;
}
function
findElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
findElementWithSelector
(
dbg
selector
)
;
}
function
findElementWithSelector
(
dbg
selector
)
{
return
dbg
.
win
.
document
.
querySelector
(
selector
)
;
}
function
findAllElements
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
findAllElementsWithSelector
(
dbg
selector
)
;
}
function
findAllElementsWithSelector
(
dbg
selector
)
{
return
dbg
.
win
.
document
.
querySelectorAll
(
selector
)
;
}
function
getSourceNodeLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
sourceNode
"
index
)
.
textContent
.
trim
(
)
.
replace
(
/
^
[
\
s
\
u200b
]
*
/
g
"
"
)
;
}
async
function
clickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
const
el
=
await
waitForElementWithSelector
(
dbg
selector
)
;
el
.
scrollIntoView
(
)
;
return
clickElementWithSelector
(
dbg
selector
)
;
}
function
clickElementWithSelector
(
dbg
selector
)
{
clickDOMElement
(
dbg
findElementWithSelector
(
dbg
selector
)
)
;
}
function
clickDOMElement
(
dbg
element
options
=
{
}
)
{
EventUtils
.
synthesizeMouseAtCenter
(
element
options
dbg
.
win
)
;
}
function
dblClickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
EventUtils
.
synthesizeMouseAtCenter
(
findElementWithSelector
(
dbg
selector
)
{
clickCount
:
2
}
dbg
.
win
)
;
}
function
clickElementWithOptions
(
dbg
elementName
options
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
const
el
=
findElementWithSelector
(
dbg
selector
)
;
el
.
scrollIntoView
(
)
;
return
EventUtils
.
synthesizeMouseAtCenter
(
el
options
dbg
.
win
)
;
}
function
altClickElement
(
dbg
elementName
.
.
.
args
)
{
return
clickElementWithOptions
(
dbg
elementName
{
altKey
:
true
}
.
.
.
args
)
;
}
function
shiftClickElement
(
dbg
elementName
.
.
.
args
)
{
return
clickElementWithOptions
(
dbg
elementName
{
shiftKey
:
true
}
.
.
.
args
)
;
}
function
rightClickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
const
doc
=
dbg
.
win
.
document
;
return
rightClickEl
(
dbg
doc
.
querySelector
(
selector
)
)
;
}
function
rightClickEl
(
dbg
el
)
{
const
doc
=
dbg
.
win
.
document
;
el
.
scrollIntoView
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
el
{
type
:
"
contextmenu
"
}
dbg
.
win
)
;
}
async
function
clearElement
(
dbg
elementName
)
{
await
clickElement
(
dbg
elementName
)
;
await
pressKey
(
dbg
"
End
"
)
;
const
selector
=
getSelector
(
elementName
)
;
const
el
=
findElementWithSelector
(
dbg
getSelector
(
elementName
)
)
;
let
len
=
el
.
value
.
length
;
while
(
len
)
{
pressKey
(
dbg
"
Backspace
"
)
;
len
-
-
;
}
}
async
function
clickGutter
(
dbg
line
)
{
const
el
=
await
codeMirrorGutterElement
(
dbg
line
)
;
clickDOMElement
(
dbg
el
)
;
}
async
function
cmdClickGutter
(
dbg
line
)
{
const
el
=
await
codeMirrorGutterElement
(
dbg
line
)
;
clickDOMElement
(
dbg
el
cmdOrCtrl
)
;
}
function
findContextMenu
(
dbg
selector
)
{
const
doc
=
dbg
.
toolbox
.
topDoc
;
const
popup
=
doc
.
querySelector
(
'
menupopup
[
menu
-
api
=
"
true
"
]
'
)
;
return
popup
.
querySelector
(
selector
)
;
}
async
function
waitForContextMenu
(
dbg
)
{
const
doc
=
dbg
.
toolbox
.
topDoc
;
const
popup
=
await
waitFor
(
(
)
=
>
doc
.
querySelector
(
'
menupopup
[
menu
-
api
=
"
true
"
]
'
)
)
;
if
(
popup
.
state
=
=
"
open
"
)
{
return
popup
;
}
await
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popupshown
"
(
)
=
>
resolve
(
)
{
once
:
true
}
)
;
}
)
;
return
popup
;
}
async
function
closeContextMenu
(
dbg
popup
)
{
const
onHidden
=
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popuphidden
"
resolve
{
once
:
true
}
)
;
}
)
;
popup
.
hidePopup
(
)
;
return
onHidden
;
}
function
selectContextMenuItem
(
dbg
selector
)
{
const
item
=
findContextMenu
(
dbg
selector
)
;
item
.
closest
(
"
menupopup
"
)
.
activateItem
(
item
)
;
}
async
function
openContextMenuSubmenu
(
dbg
selector
)
{
const
item
=
findContextMenu
(
dbg
selector
)
;
const
popup
=
item
.
menupopup
;
const
popupshown
=
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popupshown
"
(
)
=
>
resolve
(
)
{
once
:
true
}
)
;
}
)
;
item
.
openMenu
(
true
)
;
await
popupshown
;
return
popup
;
}
async
function
assertContextMenuLabel
(
dbg
selector
expectedLabel
)
{
const
item
=
await
waitFor
(
(
)
=
>
findContextMenu
(
dbg
selector
)
)
;
is
(
item
.
label
expectedLabel
"
The
label
of
the
context
menu
item
shown
to
the
user
"
)
;
}
async
function
typeInPanel
(
dbg
text
)
{
await
waitForElement
(
dbg
"
conditionalPanelInput
"
)
;
pressKey
(
dbg
"
End
"
)
;
type
(
dbg
text
)
;
pressKey
(
dbg
"
Enter
"
)
;
}
async
function
toggleMapScopes
(
dbg
)
{
info
(
"
Turn
on
original
variable
mapping
"
)
;
const
scopesLoaded
=
waitForLoadedScopes
(
dbg
)
;
const
onDispatch
=
waitForDispatch
(
dbg
.
store
"
TOGGLE_MAP_SCOPES
"
)
;
clickElement
(
dbg
"
mapScopesCheckbox
"
)
;
return
Promise
.
all
(
[
onDispatch
scopesLoaded
]
)
;
}
async
function
waitForPausedInOriginalFileAndToggleMapScopes
(
dbg
expectedSelectedSource
=
null
)
{
await
waitForPaused
(
dbg
expectedSelectedSource
{
shouldWaitForLoadedScopes
:
false
}
)
;
await
toggleMapScopes
(
dbg
)
;
}
function
toggleExpressions
(
dbg
)
{
return
findElement
(
dbg
"
expressionsHeader
"
)
.
click
(
)
;
}
function
toggleScopes
(
dbg
)
{
return
findElement
(
dbg
"
scopesHeader
"
)
.
click
(
)
;
}
function
toggleExpressionNode
(
dbg
index
)
{
return
toggleObjectInspectorNode
(
findElement
(
dbg
"
expressionNode
"
index
)
)
;
}
function
toggleScopeNode
(
dbg
index
)
{
return
toggleObjectInspectorNode
(
findElement
(
dbg
"
scopeNode
"
index
)
)
;
}
function
rightClickScopeNode
(
dbg
index
)
{
rightClickObjectInspectorNode
(
dbg
findElement
(
dbg
"
scopeNode
"
index
)
)
;
}
function
getScopeNodeLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeNode
"
index
)
.
innerText
;
}
function
getScopeNodeValue
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeValue
"
index
)
.
innerText
;
}
function
toggleObjectInspectorNode
(
node
)
{
const
objectInspector
=
node
.
closest
(
"
.
object
-
inspector
"
)
;
const
properties
=
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
;
info
(
Toggling
node
{
node
.
innerText
}
)
;
node
.
click
(
)
;
return
waitUntil
(
(
)
=
>
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
!
=
=
properties
)
;
}
function
rightClickObjectInspectorNode
(
dbg
node
)
{
const
objectInspector
=
node
.
closest
(
"
.
object
-
inspector
"
)
;
const
properties
=
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
;
info
(
Right
clicking
node
{
node
.
innerText
}
)
;
rightClickEl
(
dbg
node
)
;
return
waitUntil
(
(
)
=
>
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
!
=
=
properties
)
;
}
function
getCM
(
dbg
)
{
const
el
=
dbg
.
win
.
document
.
querySelector
(
"
.
CodeMirror
"
)
;
return
el
.
CodeMirror
;
}
function
getCoordsFromPosition
(
cm
{
line
ch
}
)
{
return
cm
.
charCoords
(
{
line
:
~
~
line
ch
:
~
~
ch
}
)
;
}
async
function
getTokenFromPosition
(
dbg
{
line
column
=
0
}
)
{
info
(
Get
token
at
{
line
}
:
{
column
}
)
;
const
cm
=
getCM
(
dbg
)
;
const
cmPosition
=
{
line
:
line
-
1
ch
:
column
-
1
}
;
const
onScrolled
=
waitForScrolling
(
cm
)
;
cm
.
scrollIntoView
(
cmPosition
0
)
;
await
onScrolled
;
const
{
left
top
}
=
getCoordsFromPosition
(
cm
cmPosition
)
;
const
lineHeightOffset
=
3
;
return
dbg
.
win
.
document
.
elementFromPoint
(
left
top
+
lineHeightOffset
)
;
}
async
function
waitForScrolling
(
codeMirror
)
{
return
new
Promise
(
resolve
=
>
{
codeMirror
.
on
(
"
scroll
"
resolve
)
;
setTimeout
(
resolve
500
)
;
}
)
;
}
async
function
codeMirrorGutterElement
(
dbg
line
)
{
info
(
CodeMirror
line
{
line
}
)
;
const
cm
=
getCM
(
dbg
)
;
const
position
=
{
line
:
line
-
1
ch
:
0
}
;
cm
.
scrollIntoView
(
position
0
)
;
await
waitForScrolling
(
cm
)
;
const
coords
=
getCoordsFromPosition
(
cm
position
)
;
const
{
left
top
}
=
coords
;
const
lineHeightOffset
=
3
;
const
leftOffset
=
10
;
const
tokenEl
=
dbg
.
win
.
document
.
elementFromPoint
(
left
-
leftOffset
top
+
lineHeightOffset
)
;
if
(
!
tokenEl
)
{
throw
new
Error
(
Failed
to
find
element
for
line
{
line
}
)
;
}
return
tokenEl
;
}
async
function
clickAtPos
(
dbg
pos
)
{
const
tokenEl
=
await
getTokenFromPosition
(
dbg
pos
)
;
if
(
!
tokenEl
)
{
return
;
}
const
{
top
left
}
=
tokenEl
.
getBoundingClientRect
(
)
;
info
(
Clicking
on
token
{
tokenEl
.
innerText
}
in
line
{
tokenEl
.
parentNode
.
innerText
}
)
;
tokenEl
.
dispatchEvent
(
new
MouseEvent
(
"
click
"
{
bubbles
:
true
cancelable
:
true
view
:
dbg
.
win
clientX
:
left
+
1
clientY
:
top
+
1
}
)
)
;
}
async
function
rightClickAtPos
(
dbg
pos
)
{
const
el
=
await
getTokenFromPosition
(
dbg
pos
)
;
if
(
!
el
)
{
return
;
}
EventUtils
.
synthesizeMouseAtCenter
(
el
{
type
:
"
contextmenu
"
}
dbg
.
win
)
;
}
async
function
hoverAtPos
(
dbg
pos
)
{
const
tokenEl
=
await
getTokenFromPosition
(
dbg
pos
)
;
if
(
!
tokenEl
)
{
return
;
}
hoverToken
(
tokenEl
)
;
}
function
hoverToken
(
tokenEl
)
{
info
(
Hovering
on
token
<
{
tokenEl
.
innerText
}
>
)
;
const
{
p1
p2
p3
}
=
tokenEl
.
getBoxQuads
(
)
[
0
]
;
const
x
=
p1
.
x
+
(
p2
.
x
-
p1
.
x
)
/
2
;
const
y
=
p1
.
y
+
(
p3
.
y
-
p1
.
y
)
/
2
;
EventUtils
.
synthesizeMouseAtPoint
(
x
y
{
type
:
"
mouseover
"
}
tokenEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouseAtPoint
(
x
y
{
type
:
"
mousemove
"
}
tokenEl
.
ownerGlobal
)
;
}
async
function
closePreviewForToken
(
dbg
tokenEl
previewType
=
"
previewPopup
"
)
{
ok
(
findElement
(
dbg
previewType
)
"
A
preview
was
opened
before
trying
to
close
it
"
)
;
const
{
p1
p2
p3
}
=
tokenEl
.
getBoxQuads
(
)
[
0
]
;
const
x
=
p1
.
x
+
(
p2
.
x
-
p1
.
x
)
/
2
;
const
y
=
p1
.
y
+
(
p3
.
y
-
p1
.
y
)
/
2
;
EventUtils
.
synthesizeMouseAtPoint
(
tokenEl
x
y
{
type
:
"
mouseout
"
}
tokenEl
.
ownerGlobal
)
;
const
element
=
tokenEl
.
ownerDocument
.
querySelector
(
"
.
debugger
-
settings
-
menu
-
button
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mousemove
"
}
element
.
ownerGlobal
)
;
await
waitUntil
(
(
)
=
>
findElement
(
dbg
previewType
)
=
=
null
)
;
info
(
"
Preview
closed
"
)
;
}
async
function
tryHovering
(
dbg
line
column
elementName
)
{
ok
(
!
findElement
(
dbg
elementName
)
"
The
expected
preview
element
on
hover
should
not
exist
beforehand
"
)
;
const
tokenEl
=
await
getTokenFromPosition
(
dbg
{
line
column
}
)
;
return
tryHoverToken
(
dbg
tokenEl
elementName
)
;
}
async
function
tryHoverTokenAtLine
(
dbg
expression
line
column
elementName
)
{
info
(
"
Scroll
codeMirror
to
make
the
token
visible
"
)
;
const
cm
=
getCM
(
dbg
)
;
const
onScrolled
=
waitForScrolling
(
cm
)
;
cm
.
scrollIntoView
(
{
line
:
line
-
1
ch
:
0
}
0
)
;
await
onScrolled
;
const
tokenEl
=
getTokenElAtLine
(
dbg
expression
line
column
)
;
if
(
!
tokenEl
)
{
throw
new
Error
(
Couldn
'
t
find
token
<
{
expression
}
>
on
{
line
}
:
{
column
}
\
n
)
;
}
ok
(
true
Found
token
<
{
expression
}
>
on
{
line
}
:
{
column
}
)
;
return
tryHoverToken
(
dbg
tokenEl
elementName
)
;
}
async
function
tryHoverToken
(
dbg
tokenEl
elementName
)
{
hoverToken
(
tokenEl
)
;
const
element
=
await
waitForElement
(
dbg
elementName
)
;
return
{
element
tokenEl
}
;
}
function
getTokenElAtLine
(
dbg
expression
line
column
=
0
)
{
info
(
Search
for
<
{
expression
}
>
token
on
{
line
}
:
{
column
}
)
;
const
lineGutterEl
=
[
.
.
.
dbg
.
win
.
document
.
querySelectorAll
(
"
.
CodeMirror
-
linenumber
"
)
]
.
find
(
el
=
>
el
.
textContent
=
=
=
{
line
}
)
;
const
editorLineEl
=
lineGutterEl
.
closest
(
"
.
CodeMirror
-
gutter
-
wrapper
"
)
.
parentElement
.
querySelector
(
"
.
CodeMirror
-
line
"
)
;
let
currentColumn
=
1
;
return
Array
.
from
(
editorLineEl
.
childNodes
[
0
]
.
childNodes
)
.
find
(
child
=
>
{
const
childText
=
child
.
textContent
;
currentColumn
+
=
childText
.
length
;
if
(
currentColumn
<
column
)
{
return
false
;
}
return
childText
=
=
=
expression
;
}
)
;
}
async
function
assertNoTooltip
(
dbg
)
{
await
wait
(
200
)
;
const
el
=
findElement
(
dbg
"
previewPopup
"
)
;
is
(
el
null
"
Tooltip
should
not
exist
"
)
;
}
async
function
assertPreviewTextValue
(
dbg
line
column
{
result
expression
doNotClose
=
false
}
)
{
await
waitForInlinePreviews
(
dbg
)
;
const
{
element
:
previewEl
tokenEl
}
=
await
tryHoverTokenAtLine
(
dbg
expression
line
column
"
previewPopup
"
)
;
ok
(
previewEl
.
innerText
.
includes
(
result
)
"
Popup
preview
text
shown
to
user
.
Got
:
"
+
previewEl
.
innerText
+
"
Expected
:
"
+
result
)
;
if
(
!
doNotClose
)
{
await
closePreviewForToken
(
dbg
tokenEl
)
;
}
}
async
function
assertPreviews
(
dbg
previews
)
{
EventUtils
.
synthesizeMouse
(
findElement
(
dbg
"
codeMirror
"
)
0
0
{
type
:
"
mousemove
"
}
dbg
.
win
)
;
await
waitForInlinePreviews
(
dbg
)
;
for
(
const
{
line
column
expression
result
header
fields
}
of
previews
)
{
info
(
"
#
Assert
preview
on
"
+
line
+
"
:
"
+
column
)
;
if
(
result
)
{
await
assertPreviewTextValue
(
dbg
line
column
{
expression
result
}
)
;
}
if
(
fields
)
{
const
{
element
:
popupEl
tokenEl
}
=
expression
?
await
tryHoverTokenAtLine
(
dbg
expression
line
column
"
popup
"
)
:
await
tryHovering
(
dbg
line
column
"
popup
"
)
;
info
(
"
Wait
for
child
nodes
to
load
"
)
;
await
waitUntil
(
(
)
=
>
popupEl
.
querySelectorAll
(
"
.
preview
-
popup
.
node
"
)
.
length
>
1
)
;
ok
(
true
"
child
nodes
loaded
"
)
;
const
oiNodes
=
Array
.
from
(
popupEl
.
querySelectorAll
(
"
.
preview
-
popup
.
node
"
)
)
;
if
(
header
)
{
is
(
oiNodes
[
0
]
.
querySelector
(
"
.
objectBox
"
)
.
textContent
header
"
popup
has
expected
value
"
)
;
}
for
(
const
[
field
value
]
of
fields
)
{
const
node
=
oiNodes
.
find
(
oiNode
=
>
oiNode
.
querySelector
(
"
.
object
-
label
"
)
?
.
textContent
=
=
=
field
)
;
if
(
!
node
)
{
ok
(
false
The
"
{
field
}
"
property
is
not
displayed
in
the
popup
)
;
}
else
{
is
(
node
.
querySelector
(
"
.
object
-
label
"
)
.
textContent
field
The
"
{
field
}
"
property
is
displayed
in
the
popup
)
;
if
(
value
!
=
=
undefined
)
{
is
(
node
.
querySelector
(
"
.
objectBox
"
)
.
textContent
value
The
"
{
field
}
"
property
has
the
expected
value
)
;
}
}
}
await
closePreviewForToken
(
dbg
tokenEl
"
popup
"
)
;
}
}
}
async
function
assertInlineExceptionPreview
(
dbg
line
column
{
expression
result
fields
}
)
{
info
(
"
#
Assert
preview
on
"
+
line
+
"
:
"
+
column
)
;
const
{
element
:
popupEl
tokenEl
}
=
await
tryHovering
(
dbg
line
column
"
previewPopup
"
)
;
info
(
"
Wait
for
top
level
node
to
expand
and
child
nodes
to
load
"
)
;
await
waitForElementWithSelector
(
dbg
"
.
exception
-
popup
.
exception
-
message
.
arrow
.
expanded
"
)
;
is
(
popupEl
.
querySelector
(
"
.
preview
-
popup
.
exception
-
message
.
objectBox
"
)
.
textContent
result
"
The
correct
result
is
not
displayed
in
the
popup
"
)
;
await
waitFor
(
(
)
=
>
popupEl
.
querySelectorAll
(
"
.
preview
-
popup
.
exception
-
stacktrace
.
frame
"
)
)
;
const
stackFrameNodes
=
Array
.
from
(
popupEl
.
querySelectorAll
(
"
.
preview
-
popup
.
exception
-
stacktrace
.
frame
"
)
)
;
for
(
const
[
field
value
]
of
fields
)
{
const
node
=
stackFrameNodes
.
find
(
frameNode
=
>
frameNode
.
querySelector
(
"
.
title
"
)
?
.
textContent
=
=
=
field
)
;
if
(
!
node
)
{
ok
(
false
The
"
{
field
}
"
property
is
not
displayed
in
the
popup
)
;
}
else
{
is
(
node
.
querySelector
(
"
.
location
"
)
.
textContent
value
The
"
{
field
}
"
property
has
the
expected
value
)
;
}
}
await
closePreviewForToken
(
dbg
tokenEl
"
previewPopup
"
)
;
}
async
function
waitForBreakableLine
(
dbg
source
lineNumber
)
{
await
waitForState
(
dbg
state
=
>
{
const
currentSource
=
findSource
(
dbg
source
)
;
const
breakableLines
=
currentSource
&
&
dbg
.
selectors
.
getBreakableLines
(
currentSource
.
id
)
;
return
breakableLines
&
&
breakableLines
.
includes
(
lineNumber
)
;
}
waiting
for
breakable
line
{
lineNumber
}
)
;
}
async
function
waitForSourceTreeThreadsCount
(
dbg
i
)
{
info
(
waiting
for
{
i
}
threads
in
the
source
tree
)
;
await
waitUntil
(
(
)
=
>
{
return
findAllElements
(
dbg
"
sourceTreeThreads
"
)
.
length
=
=
=
i
;
}
)
;
}
async
function
waitForSourcesInSourceTree
(
dbg
sources
{
noExpand
=
false
}
=
{
}
)
{
info
(
waiting
for
{
sources
.
length
}
files
in
the
source
tree
)
;
function
getDisplayedSources
(
)
{
return
[
.
.
.
findAllElements
(
dbg
"
sourceTreeFiles
"
)
]
.
map
(
e
=
>
{
return
e
.
textContent
.
trim
(
)
.
replace
(
/
^
[
\
s
\
u200b
]
*
/
g
"
"
)
;
}
)
;
}
try
{
await
waitFor
(
async
(
)
=
>
{
if
(
!
noExpand
)
{
await
expandSourceTree
(
dbg
)
;
}
const
displayedSources
=
getDisplayedSources
(
)
;
return
(
displayedSources
.
length
=
=
sources
.
length
&
&
sources
.
every
(
source
=
>
displayedSources
.
includes
(
source
)
)
)
;
}
null
100
50
)
;
}
catch
(
e
)
{
const
displayedSources
=
getDisplayedSources
(
)
;
let
msg
=
"
Invalid
Source
Tree
Content
.
\
n
"
;
const
missingElements
=
[
]
;
for
(
const
source
of
sources
)
{
const
idx
=
displayedSources
.
indexOf
(
source
)
;
if
(
idx
!
=
-
1
)
{
displayedSources
.
splice
(
idx
1
)
;
}
else
{
missingElements
.
push
(
source
)
;
}
}
if
(
missingElements
.
length
)
{
msg
+
=
"
Missing
elements
:
"
+
missingElements
.
join
(
"
"
)
+
"
\
n
"
;
}
if
(
displayedSources
.
length
)
{
msg
+
=
"
Unexpected
elements
:
"
+
displayedSources
.
join
(
"
"
)
;
}
throw
new
Error
(
msg
)
;
}
}
async
function
waitForNodeToGainFocus
(
dbg
index
)
{
await
waitUntil
(
(
)
=
>
{
const
element
=
findElement
(
dbg
"
sourceNode
"
index
)
;
if
(
element
)
{
return
element
.
classList
.
contains
(
"
focused
"
)
;
}
return
false
;
}
waiting
for
source
node
{
index
}
to
be
focused
)
;
}
async
function
assertNodeIsFocused
(
dbg
index
)
{
await
waitForNodeToGainFocus
(
dbg
index
)
;
const
node
=
findElement
(
dbg
"
sourceNode
"
index
)
;
ok
(
node
.
classList
.
contains
(
"
focused
"
)
node
{
index
}
is
focused
)
;
}
async
function
assertDebuggerIsHighlightedAndPaused
(
toolbox
)
{
info
(
"
Wait
for
the
debugger
to
be
automatically
selected
on
pause
"
)
;
await
waitUntil
(
(
)
=
>
toolbox
.
currentToolId
=
=
"
jsdebugger
"
)
;
ok
(
true
"
Debugger
selected
"
)
;
await
toolbox
.
getPanelWhenReady
(
"
jsdebugger
"
)
;
const
dbg
=
createDebuggerContext
(
toolbox
)
;
await
waitForPaused
(
dbg
)
;
ok
(
toolbox
.
isHighlighted
(
"
jsdebugger
"
)
"
Debugger
is
highlighted
"
)
;
return
dbg
;
}
async
function
addExpression
(
dbg
input
)
{
info
(
"
Adding
an
expression
"
)
;
const
plusIcon
=
findElementWithSelector
(
dbg
selectors
.
expressionPlus
)
;
if
(
plusIcon
)
{
plusIcon
.
click
(
)
;
}
findElementWithSelector
(
dbg
selectors
.
expressionInput
)
.
focus
(
)
;
type
(
dbg
input
)
;
const
evaluated
=
waitForDispatch
(
dbg
.
store
"
EVALUATE_EXPRESSION
"
)
;
const
clearAutocomplete
=
waitForDispatch
(
dbg
.
store
"
CLEAR_AUTOCOMPLETE
"
)
;
pressKey
(
dbg
"
Enter
"
)
;
await
evaluated
;
await
clearAutocomplete
;
}
async
function
editExpression
(
dbg
input
)
{
info
(
"
Updating
the
expression
"
)
;
dblClickElement
(
dbg
"
expressionNode
"
1
)
;
pressKey
(
dbg
"
End
"
)
;
type
(
dbg
input
)
;
const
evaluated
=
waitForDispatch
(
dbg
.
store
"
EVALUATE_EXPRESSIONS
"
)
;
pressKey
(
dbg
"
Enter
"
)
;
await
evaluated
;
}
function
getWatchExpressionLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
expressionNode
"
index
)
.
innerText
;
}
function
getWatchExpressionValue
(
dbg
index
)
{
return
findElement
(
dbg
"
expressionValue
"
index
)
.
innerText
;
}
async
function
getDebuggerSplitConsole
(
dbg
)
{
let
{
toolbox
win
}
=
dbg
;
if
(
!
win
)
{
win
=
toolbox
.
win
;
}
if
(
!
toolbox
.
splitConsole
)
{
pressKey
(
dbg
"
Escape
"
)
;
}
await
toolbox
.
openSplitConsole
(
)
;
return
toolbox
.
getPanel
(
"
webconsole
"
)
;
}
async
function
evaluateInTopFrame
(
dbg
text
)
{
const
threadFront
=
dbg
.
toolbox
.
target
.
threadFront
;
const
{
frames
}
=
await
threadFront
.
getFrames
(
0
1
)
;
ok
(
frames
.
length
=
=
1
"
Got
one
frame
"
)
;
const
response
=
await
dbg
.
commands
.
scriptCommand
.
execute
(
text
{
frameActor
:
frames
[
0
]
.
actorID
}
)
;
return
response
.
result
.
type
=
=
"
undefined
"
?
undefined
:
response
.
result
;
}
async
function
checkEvaluateInTopFrame
(
dbg
text
expected
)
{
const
rval
=
await
evaluateInTopFrame
(
dbg
text
)
;
ok
(
rval
=
=
expected
Eval
returned
{
expected
}
)
;
}
async
function
findConsoleMessage
(
{
toolbox
}
query
)
{
const
[
message
]
=
await
findConsoleMessages
(
toolbox
query
)
;
const
value
=
message
.
querySelector
(
"
.
message
-
body
"
)
.
innerText
;
const
link
=
message
.
querySelector
(
"
.
frame
-
link
-
source
"
)
?
.
innerText
;
return
{
value
link
}
;
}
async
function
findConsoleMessages
(
toolbox
query
)
{
const
webConsole
=
await
toolbox
.
getPanel
(
"
webconsole
"
)
;
const
win
=
webConsole
.
_frameWindow
;
return
Array
.
prototype
.
filter
.
call
(
win
.
document
.
querySelectorAll
(
"
.
message
"
)
e
=
>
e
.
innerText
.
includes
(
query
)
)
;
}
async
function
hasConsoleMessage
(
{
toolbox
}
msg
)
{
return
waitFor
(
async
(
)
=
>
{
const
messages
=
await
findConsoleMessages
(
toolbox
msg
)
;
return
!
!
messages
.
length
;
}
)
;
}
function
evaluateExpressionInConsole
(
hud
expression
expectedClassName
=
"
result
"
)
{
const
seenMessages
=
new
Set
(
JSON
.
parse
(
hud
.
ui
.
outputNode
.
querySelector
(
"
[
data
-
visible
-
messages
]
"
)
.
getAttribute
(
"
data
-
visible
-
messages
"
)
)
)
;
const
onResult
=
new
Promise
(
res
=
>
{
const
onNewMessage
=
messages
=
>
{
for
(
const
message
of
messages
)
{
if
(
message
.
node
.
classList
.
contains
(
expectedClassName
)
&
&
!
seenMessages
.
has
(
message
.
node
.
getAttribute
(
"
data
-
message
-
id
"
)
)
)
{
hud
.
ui
.
off
(
"
new
-
messages
"
onNewMessage
)
;
res
(
message
.
node
)
;
}
}
}
;
hud
.
ui
.
on
(
"
new
-
messages
"
onNewMessage
)
;
}
)
;
hud
.
ui
.
wrapper
.
dispatchEvaluateExpression
(
expression
)
;
return
onResult
;
}
function
waitForInspectorPanelChange
(
dbg
)
{
return
dbg
.
toolbox
.
getPanelWhenReady
(
"
inspector
"
)
;
}
function
getEagerEvaluationElement
(
hud
)
{
return
hud
.
ui
.
outputNode
.
querySelector
(
"
.
eager
-
evaluation
-
result
"
)
;
}
async
function
waitForEagerEvaluationResult
(
hud
text
)
{
await
waitUntil
(
(
)
=
>
{
const
elem
=
getEagerEvaluationElement
(
hud
)
;
if
(
elem
)
{
if
(
text
instanceof
RegExp
)
{
return
text
.
test
(
elem
.
innerText
)
;
}
return
elem
.
innerText
=
=
text
;
}
return
false
;
}
)
;
ok
(
true
Got
eager
evaluation
result
{
text
}
)
;
}
function
setInputValue
(
hud
value
)
{
const
onValueSet
=
hud
.
jsterm
.
once
(
"
set
-
input
-
value
"
)
;
hud
.
jsterm
.
_setValue
(
value
)
;
return
onValueSet
;
}
function
assertMenuItemChecked
(
menuItem
isChecked
)
{
is
(
!
!
menuItem
.
getAttribute
(
"
aria
-
checked
"
)
isChecked
Item
has
expected
state
:
{
isChecked
?
"
checked
"
:
"
unchecked
"
}
)
;
}
async
function
toggleDebbuggerSettingsMenuItem
(
dbg
{
className
isChecked
}
)
{
const
menuButton
=
findElementWithSelector
(
dbg
"
.
debugger
-
settings
-
menu
-
button
"
)
;
const
{
parent
}
=
dbg
.
panel
.
panelWin
;
const
{
document
}
=
parent
;
menuButton
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
const
menuListEl
=
document
.
querySelector
(
"
#
debugger
-
settings
-
menu
-
list
"
)
;
return
menuListEl
&
&
menuListEl
.
offsetParent
!
=
=
null
;
}
)
;
const
menuItem
=
document
.
querySelector
(
className
)
;
assertMenuItemChecked
(
menuItem
isChecked
)
;
menuItem
.
click
(
)
;
await
waitFor
(
(
)
=
>
menuButton
.
getAttribute
(
"
aria
-
expanded
"
)
=
=
=
"
false
"
)
;
}
async
function
clickOnSourceMapMenuItem
(
dbg
className
)
{
const
menuButton
=
findElement
(
dbg
"
sourceMapFooterButton
"
)
;
const
{
parent
}
=
dbg
.
panel
.
panelWin
;
const
{
document
}
=
parent
;
menuButton
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
const
menuListEl
=
document
.
querySelector
(
"
#
debugger
-
source
-
map
-
list
"
)
;
return
menuListEl
&
&
menuListEl
.
offsetParent
!
=
=
null
;
}
)
;
const
menuItem
=
document
.
querySelector
(
className
)
;
menuItem
.
click
(
)
;
}
async
function
setLogPoint
(
dbg
index
value
)
{
rightClickElement
(
dbg
"
gutter
"
index
)
;
await
waitForContextMenu
(
dbg
)
;
selectContextMenuItem
(
dbg
{
selectors
.
addLogItem
}
{
selectors
.
editLogItem
}
)
;
const
onBreakpointSet
=
waitForDispatch
(
dbg
.
store
"
SET_BREAKPOINT
"
)
;
await
typeInPanel
(
dbg
value
)
;
await
onBreakpointSet
;
}
function
openProjectSearch
(
dbg
)
{
info
(
"
Opening
the
project
search
panel
"
)
;
synthesizeKeyShortcut
(
"
CmdOrCtrl
+
Shift
+
F
"
)
;
return
waitForState
(
dbg
state
=
>
dbg
.
selectors
.
getActiveSearch
(
)
=
=
=
"
project
"
)
;
}
async
function
doProjectSearch
(
dbg
searchTerm
expectedResults
)
{
await
clearElement
(
dbg
"
projectSearchSearchInput
"
)
;
type
(
dbg
searchTerm
)
;
pressKey
(
dbg
"
Enter
"
)
;
return
waitForSearchResults
(
dbg
expectedResults
)
;
}
async
function
waitForSearchResults
(
dbg
expectedResults
)
{
if
(
expectedResults
)
{
info
(
Wait
for
{
expectedResults
}
project
search
results
)
;
await
waitUntil
(
(
)
=
>
findAllElements
(
dbg
"
projectSearchFileResults
"
)
.
length
=
=
expectedResults
)
;
}
else
{
info
(
"
Wait
for
project
search
to
complete
with
no
results
"
)
;
await
waitUntil
(
(
)
=
>
{
const
projectSearchResult
=
findElementWithSelector
(
dbg
"
.
no
-
result
-
msg
"
)
;
return
projectSearchResult
?
projectSearchResult
.
textContent
=
=
DEBUGGER_L10N
.
getStr
(
"
projectTextSearch
.
noResults
"
)
:
false
;
}
)
;
}
return
findAllElements
(
dbg
"
projectSearchFileResults
"
)
;
}
function
getExpandedResultsCount
(
dbg
)
{
return
findAllElements
(
dbg
"
projectSearchExpandedResults
"
)
.
length
;
}
const
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
if
(
protocolHandler
.
hasSubstitution
(
"
testing
-
common
"
)
)
{
const
{
PromiseTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
sys
.
mjs
"
)
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
Connection
closed
/
)
;
this
.
PromiseTestUtils
=
PromiseTestUtils
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
DebuggerContextError
/
)
;
}
async
function
selectBlackBoxContextMenuItem
(
dbg
itemName
)
{
let
wait
=
null
;
if
(
itemName
=
=
"
blackbox
-
line
"
|
|
itemName
=
=
"
blackbox
-
lines
"
)
{
wait
=
Promise
.
any
(
[
waitForDispatch
(
dbg
.
store
"
BLACKBOX_SOURCE_RANGES
"
)
waitForDispatch
(
dbg
.
store
"
UNBLACKBOX_SOURCE_RANGES
"
)
]
)
;
}
else
if
(
itemName
=
=
"
blackbox
"
)
{
wait
=
Promise
.
any
(
[
waitForDispatch
(
dbg
.
store
"
BLACKBOX_WHOLE_SOURCES
"
)
waitForDispatch
(
dbg
.
store
"
UNBLACKBOX_WHOLE_SOURCES
"
)
]
)
;
}
info
(
Select
the
{
itemName
}
context
menu
item
)
;
selectContextMenuItem
(
dbg
#
node
-
menu
-
{
itemName
}
)
;
return
wait
;
}
function
openOutlinePanel
(
dbg
waitForOutlineList
=
true
)
{
info
(
"
Select
the
outline
panel
"
)
;
const
outlineTab
=
findElementWithSelector
(
dbg
"
.
outline
-
tab
a
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
outlineTab
{
}
outlineTab
.
ownerGlobal
)
;
if
(
!
waitForOutlineList
)
{
return
Promise
.
resolve
(
)
;
}
return
waitForElementWithSelector
(
dbg
"
.
outline
-
list
"
)
;
}
function
assertOutlineItems
(
dbg
expectedItems
)
{
const
outlineItems
=
Array
.
from
(
findAllElementsWithSelector
(
dbg
"
.
outline
-
list
h2
.
outline
-
list
.
outline
-
list__element
"
)
)
;
SimpleTest
.
isDeeply
(
outlineItems
.
map
(
i
=
>
i
.
innerText
.
trim
(
)
)
expectedItems
"
The
expected
items
are
displayed
in
the
outline
panel
"
)
;
}
async
function
checkAdditionalThreadCount
(
dbg
count
)
{
await
waitForState
(
dbg
state
=
>
{
return
dbg
.
selectors
.
getThreads
(
)
.
length
=
=
count
;
}
"
Have
the
expected
number
of
additional
threads
"
)
;
ok
(
true
Have
{
count
}
threads
)
;
}
function
findFooterNotificationMessage
(
dbg
)
{
return
findElement
(
dbg
"
editorNotificationFooter
"
)
?
.
innerText
;
}
