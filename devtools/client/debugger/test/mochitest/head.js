"
use
strict
"
;
const
EXAMPLE_URL
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
examples
/
"
;
const
EXAMPLE_REMOTE_URL
=
"
https
:
/
/
example
.
org
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
examples
/
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
webconsole
/
test
/
browser
/
shared
-
head
.
js
"
this
)
;
const
integrationTasks
=
[
]
;
function
addIntegrationTask
(
fun
)
{
integrationTasks
.
push
(
fun
)
;
}
function
_loadAllIntegrationTests
(
)
{
const
testsDir
=
getChromeDir
(
getResolvedURI
(
gTestPath
)
)
;
testsDir
.
append
(
"
integration
-
tests
"
)
;
const
entries
=
testsDir
.
directoryEntries
;
const
urls
=
[
]
;
while
(
entries
.
hasMoreElements
(
)
)
{
const
file
=
entries
.
nextFile
;
const
url
=
Services
.
io
.
newFileURI
(
file
)
.
spec
;
if
(
url
.
endsWith
(
"
.
js
"
)
)
{
urls
.
push
(
url
)
;
}
}
urls
.
sort
(
)
;
for
(
const
url
of
urls
)
{
Services
.
scriptloader
.
loadSubScript
(
url
this
)
;
}
return
integrationTasks
;
}
async
function
runAllIntegrationTests
(
testFolder
env
)
{
const
tasks
=
_loadAllIntegrationTests
(
)
;
const
testServer
=
createVersionizedHttpTestServer
(
"
examples
/
"
+
testFolder
)
;
const
testUrl
=
testServer
.
urlFor
(
"
index
.
html
"
)
;
for
(
const
task
of
tasks
)
{
info
(
=
=
>
Running
integration
task
'
{
task
.
name
}
'
)
;
await
task
(
testServer
testUrl
env
)
;
}
}
const
INTEGRATION_TEST_PAGE_SOURCES
=
[
"
index
.
html
"
"
iframe
.
html
"
"
script
.
js
"
"
onload
.
js
"
"
test
-
functions
.
js
"
"
query
.
js
?
x
=
1
"
"
query
.
js
?
x
=
2
"
"
query2
.
js
?
y
=
3
"
"
bundle
.
js
"
"
original
.
js
"
"
bundle
-
with
-
another
-
original
.
js
"
"
original
-
with
-
no
-
update
.
js
"
"
replaced
-
bundle
.
js
"
"
removed
-
original
.
js
"
"
named
-
eval
.
js
"
"
.
js
"
"
bootstrap
3b1a221408fdde86aa49
"
"
bootstrap
a1ecee2f86e1d0ea3fb5
"
"
bootstrap
6fda1f7ea9ecbc1a2d5b
"
"
same
-
url
.
sjs
"
"
same
-
url
.
sjs
"
]
;
if
(
isFissionEnabled
(
)
|
|
isEveryFrameTargetEnabled
(
)
)
{
INTEGRATION_TEST_PAGE_SOURCES
.
push
(
"
same
-
url
.
sjs
"
)
;
}
async
function
installAndStartContentScriptExtension
(
)
{
function
contentScript
(
)
{
console
.
log
(
"
content
script
loads
"
)
;
window
.
onload
=
(
)
=
>
{
}
;
}
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Test
content
script
extension
"
content_scripts
:
[
{
js
:
[
"
content_script
.
js
"
]
matches
:
[
"
https
:
/
/
example
.
com
/
*
"
]
run_at
:
"
document_start
"
}
]
}
files
:
{
"
content_script
.
js
"
:
contentScript
}
}
)
;
await
extension
.
startup
(
)
;
return
extension
;
}
function
getSourceTreeLabel
(
dbg
index
)
{
return
(
findElement
(
dbg
"
sourceNode
"
index
)
.
textContent
.
trim
(
)
.
replace
(
/
^
[
\
s
\
u200b
]
*
/
g
"
"
)
)
;
}
async
function
assertSourceTreeNode
(
dbg
text
)
{
let
node
=
null
;
await
waitUntil
(
(
)
=
>
{
node
=
findSourceNodeWithText
(
dbg
text
)
;
return
!
!
node
;
}
)
;
ok
(
!
!
node
Source
tree
node
with
text
"
{
text
}
"
exists
)
;
}
