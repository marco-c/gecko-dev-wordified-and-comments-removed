"
use
strict
"
;
requestLongerTimeout
(
2
)
;
add_task
(
async
function
testScrollingOnPauseAndSourceSwitching
(
)
{
const
dbg
=
await
initDebugger
(
"
doc
-
editor
-
scroll
.
html
"
"
scroll
.
js
"
"
long
.
js
"
)
;
await
selectSource
(
dbg
"
scroll
.
js
"
)
;
await
addBreakpoint
(
dbg
"
scroll
.
js
"
26
)
;
info
(
"
Open
long
file
scroll
down
to
line
below
the
fold
"
)
;
await
selectSource
(
dbg
"
long
.
js
"
)
;
const
ensureScroll
=
waitForScrolling
(
dbg
{
useTimeoutFallback
:
false
}
)
;
await
scrollEditorIntoView
(
dbg
25
0
)
;
ok
(
isScrolledPositionVisible
(
dbg
25
)
"
Scroll
position
is
visible
"
)
;
info
(
"
Wait
for
the
codemirror
scroll
event
"
)
;
await
ensureScroll
;
info
(
"
Ensure
vertical
scroll
is
the
same
after
switching
documents
"
)
;
let
onScrolled
=
waitForScrolling
(
dbg
)
;
await
selectSource
(
dbg
"
scroll
.
js
"
)
;
await
onScrolled
;
ok
(
isScrolledPositionVisible
(
dbg
1
)
"
Scrolled
to
the
top
of
the
editor
"
)
;
onScrolled
=
waitForScrolling
(
dbg
)
;
await
selectSource
(
dbg
"
long
.
js
"
)
;
await
onScrolled
;
ok
(
isScrolledPositionVisible
(
dbg
25
)
"
Scroll
position
is
visible
"
)
;
info
(
"
Trigger
a
pause
click
on
a
frame
ensure
the
right
line
is
selected
"
)
;
onScrolled
=
waitForScrolling
(
dbg
)
;
invokeInTab
(
"
line26
"
)
;
await
waitForPaused
(
dbg
)
;
await
onScrolled
;
ok
(
isScrolledPositionVisible
(
dbg
26
)
"
Frame
scrolled
down
to
correct
location
"
)
;
info
(
"
Navigating
while
paused
goes
to
the
correct
location
"
)
;
onScrolled
=
waitForScrolling
(
dbg
)
;
await
selectSource
(
dbg
"
long
.
js
"
)
;
await
onScrolled
;
ok
(
isScrolledPositionVisible
(
dbg
25
)
"
Scroll
position
is
visible
"
)
;
info
(
"
Open
new
source
ensure
it
'
s
at
0
scroll
"
)
;
onScrolled
=
waitForScrolling
(
dbg
)
;
await
selectSource
(
dbg
"
frames
.
js
"
)
;
await
onScrolled
;
ok
(
isScrolledPositionVisible
(
dbg
1
)
"
Scrolled
to
the
top
of
the
editor
"
)
;
}
)
;
add_task
(
async
function
testIsPositionVisible
(
)
{
await
pushPref
(
"
devtools
.
toolbox
.
footer
.
height
"
250
)
;
await
pushPref
(
"
devtools
.
debugger
.
start
-
panel
-
size
"
300
)
;
await
pushPref
(
"
devtools
.
debugger
.
end
-
panel
-
size
"
300
)
;
const
expectedWidth
=
1280
;
const
expectedHeight
=
1040
;
if
(
window
.
innerWidth
!
=
expectedWidth
|
|
window
.
innerHeight
!
=
expectedHeight
)
{
info
(
"
Resize
the
top
level
window
to
match
the
expected
size
"
)
;
const
onResize
=
once
(
window
"
resize
"
)
;
const
deltaW
=
window
.
outerWidth
-
window
.
innerWidth
;
const
deltaH
=
window
.
outerHeight
-
window
.
innerHeight
;
const
originalWidth
=
window
.
outerWidth
;
const
originalHeight
=
window
.
outerHeight
;
window
.
resizeTo
(
expectedWidth
+
deltaW
expectedHeight
+
deltaH
)
;
await
onResize
;
registerCleanupFunction
(
(
)
=
>
{
window
.
resizeTo
(
originalWidth
originalHeight
)
;
}
)
;
}
is
(
window
.
innerWidth
expectedWidth
)
;
const
dbg
=
await
initDebugger
(
"
doc
-
editor
-
scroll
.
html
"
"
scroll
.
js
"
"
long
.
js
"
)
;
await
selectSource
(
dbg
"
scroll
.
js
"
)
;
const
editor
=
getCMEditor
(
dbg
)
;
function
getFirstVisibleLine
(
)
{
const
{
x
y
}
=
editor
.
codeMirror
.
dom
.
getBoundingClientRect
(
)
;
const
pos
=
editor
.
codeMirror
.
posAtCoords
(
{
x
y
:
y
+
1
}
)
;
return
editor
.
codeMirror
.
state
.
doc
.
lineAt
(
pos
)
.
number
;
}
function
getLastVisibleLine
(
)
{
const
{
x
y
height
}
=
editor
.
codeMirror
.
dom
.
getBoundingClientRect
(
)
;
const
pos
=
editor
.
codeMirror
.
posAtCoords
(
{
x
y
:
y
+
height
}
)
;
return
editor
.
codeMirror
.
state
.
doc
.
lineAt
(
pos
)
.
number
;
}
const
lastLine
=
getLastVisibleLine
(
)
;
is
(
lastLine
11
"
The
last
line
is
the
11th
.
(
it
may
change
if
you
resize
the
default
browser
window
height
)
"
)
;
ok
(
isScrolledPositionVisible
(
dbg
1
)
"
First
line
is
visible
"
)
;
ok
(
isScrolledPositionVisible
(
dbg
lastLine
-
1
)
"
The
line
before
the
last
one
is
visible
"
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
lastLine
)
"
Last
line
is
partially
visible
and
considered
hidden
"
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
lastLine
+
1
)
"
The
line
after
the
last
is
hidden
"
)
;
info
(
"
Set
a
breakpoint
and
pause
on
the
last
fully
visible
line
it
should
not
scroll
"
)
;
await
addBreakpoint
(
dbg
"
scroll
.
js
"
lastLine
-
1
)
;
invokeInTab
(
"
line
"
+
(
lastLine
-
1
)
)
;
await
waitForPaused
(
dbg
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
lastLine
)
"
Last
line
which
is
partially
visible
is
still
hidden
"
)
;
await
resume
(
dbg
)
;
info
(
"
Set
a
breakpoint
on
the
last
partially
visible
line
it
should
scroll
that
line
in
the
middle
of
the
viewport
"
)
;
await
addBreakpoint
(
dbg
"
scroll
.
js
"
lastLine
)
;
invokeInTab
(
"
line
"
+
lastLine
)
;
await
waitForPaused
(
dbg
)
;
const
newLastLine
=
getLastVisibleLine
(
)
;
is
(
newLastLine
16
"
The
new
last
line
is
the
16th
"
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
newLastLine
)
"
The
new
Last
line
is
still
partially
visible
and
considered
hidden
"
)
;
ok
(
isScrolledPositionVisible
(
dbg
newLastLine
-
1
)
"
The
line
before
is
reported
as
visible
"
)
;
const
firstLine
=
getFirstVisibleLine
(
)
;
is
(
firstLine
6
)
;
ok
(
isScrolledPositionVisible
(
dbg
firstLine
+
1
)
"
The
next
line
of
the
new
first
line
is
visible
"
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
firstLine
-
1
)
"
The
line
before
the
new
first
line
is
hidden
"
)
;
await
resume
(
dbg
)
;
info
(
"
Set
a
breakpoint
far
from
the
current
position
it
should
also
scroll
and
display
the
paused
line
in
the
middle
of
the
viewport
"
)
;
await
addBreakpoint
(
dbg
"
scroll
.
js
"
50
)
;
invokeInTab
(
"
line50
"
)
;
await
waitForPaused
(
dbg
)
;
info
(
"
Wait
for
the
paused
line
marker
to
be
visible
"
)
;
await
waitForElementWithSelector
(
dbg
"
.
cm
-
content
.
paused
-
line
"
)
;
const
newLastLine2
=
getLastVisibleLine
(
)
;
is
(
newLastLine2
55
)
;
ok
(
isScrolledPositionVisible
(
dbg
newLastLine2
-
1
)
"
The
line
before
is
visible
"
)
;
const
firstLine2
=
getFirstVisibleLine
(
)
;
is
(
firstLine2
45
)
;
ok
(
isScrolledPositionVisible
(
dbg
firstLine2
+
1
)
"
The
next
line
of
the
new
first
line
is
visible
"
)
;
ok
(
!
isScrolledPositionVisible
(
dbg
firstLine2
-
1
)
"
The
line
before
the
new
first
line
is
hidden
"
)
;
await
resume
(
dbg
)
;
}
)
;
add_task
(
async
function
testColumnBreakpointsLimitAfterVerticalScroll
(
)
{
await
pushPref
(
"
devtools
.
debugger
.
end
-
panel
-
size
"
300
)
;
await
pushPref
(
"
devtools
.
debugger
.
ui
.
editor
-
wrapping
"
true
)
;
const
dbg
=
await
initDebugger
(
"
doc
-
large
-
sources
.
html
"
"
codemirror
-
bundle
.
js
"
)
;
info
(
"
Select
the
minified
bundle
and
add
a
breakpoint
"
)
;
await
selectSource
(
dbg
"
codemirror
-
bundle
.
js
"
)
;
await
addBreakpoint
(
dbg
"
codemirror
-
bundle
.
js
"
1
)
;
let
columnBreakpointMarkers
=
await
waitForAllElements
(
dbg
"
columnBreakpoints
"
)
;
is
(
columnBreakpointMarkers
.
length
100
"
We
have
the
expected
limit
of
column
breakpoint
markers
on
the
minified
source
"
)
;
info
(
"
Scroll
to
the
bottom
of
the
file
"
)
;
await
scrollEditorIntoView
(
dbg
1
)
;
columnBreakpointMarkers
=
findAllElements
(
dbg
"
columnBreakpoints
"
)
;
is
(
columnBreakpointMarkers
.
length
0
"
There
are
no
column
breakpoint
markers
as
the
source
has
vertically
scrolled
the
viewport
over
the
limit
"
)
;
info
(
"
Scroll
back
to
the
top
of
the
file
"
)
;
await
scrollEditorIntoView
(
dbg
0
)
;
columnBreakpointMarkers
=
await
waitForAllElements
(
dbg
"
columnBreakpoints
"
)
;
is
(
columnBreakpointMarkers
.
length
100
"
We
still
have
the
expected
limit
of
column
breakpoint
markers
on
the
minified
source
"
)
;
}
)
;
