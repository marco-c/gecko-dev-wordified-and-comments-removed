"
use
strict
"
;
add_task
(
async
function
testTracingOnNextLoad
(
)
{
await
pushPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
true
)
;
await
pushPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
-
log
-
method
"
"
console
"
)
;
const
jsCode
=
function
foo
(
)
{
}
;
function
bar
(
)
{
}
;
foo
(
)
;
dump
(
"
plop
\
\
n
"
)
;
const
dbg
=
await
initDebuggerWithAbsoluteURL
(
"
data
:
text
/
html
"
+
encodeURIComponent
(
<
script
>
{
jsCode
}
<
/
script
>
<
body
>
<
/
body
>
)
)
;
let
traceButton
=
dbg
.
toolbox
.
doc
.
getElementById
(
"
command
-
button
-
jstracer
"
)
;
await
toggleJsTracerMenuItem
(
dbg
"
#
jstracer
-
menu
-
item
-
next
-
load
"
)
;
await
toggleJsTracer
(
dbg
.
toolbox
)
;
ok
(
!
traceButton
.
classList
.
contains
(
"
pending
"
)
"
Before
toggling
the
trace
button
it
has
no
particular
state
"
)
;
info
(
"
Wait
for
the
split
console
to
be
automatically
displayed
when
toggling
this
setting
"
)
;
await
dbg
.
toolbox
.
getPanelWhenReady
(
"
webconsole
"
)
;
invokeInTab
(
"
bar
"
)
;
await
wait
(
500
)
;
is
(
(
await
findConsoleMessages
(
dbg
.
toolbox
"
bar
"
)
)
.
length
0
"
The
code
isn
'
t
logged
as
the
tracer
shouldn
'
t
be
started
yet
"
)
;
await
waitFor
(
(
)
=
>
{
return
traceButton
.
classList
.
contains
(
"
pending
"
)
;
}
"
The
tracer
button
is
pending
before
reloading
the
page
"
)
;
info
(
"
Add
an
iframe
to
trigger
a
target
creation
"
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
async
function
(
)
{
const
iframe
=
content
.
document
.
createElement
(
"
iframe
"
)
;
iframe
.
src
=
"
data
:
text
/
html
iframe
"
;
content
.
document
.
body
.
appendChild
(
iframe
)
;
}
)
;
await
wait
(
500
)
;
ok
(
traceButton
.
classList
.
contains
(
"
pending
"
)
"
verify
that
the
tracer
is
still
pending
after
the
iframe
creation
"
)
;
await
reload
(
dbg
)
;
let
topLevelThreadActorID
=
dbg
.
toolbox
.
commands
.
targetCommand
.
targetFront
.
threadFront
.
actorID
;
info
(
"
Wait
for
tracing
to
be
enabled
after
page
reload
"
)
;
await
waitForState
(
dbg
(
)
=
>
{
return
dbg
.
selectors
.
getIsThreadCurrentlyTracing
(
topLevelThreadActorID
)
;
}
)
;
is
(
traceButton
.
getAttribute
(
"
aria
-
pressed
"
)
"
true
"
"
The
tracer
button
is
now
active
after
reload
"
)
;
info
(
"
Wait
for
the
split
console
to
be
displayed
"
)
;
await
dbg
.
toolbox
.
getPanelWhenReady
(
"
webconsole
"
)
;
await
hasConsoleMessage
(
dbg
"
foo
"
)
;
is
(
(
await
findConsoleMessages
(
dbg
.
toolbox
"
bar
"
)
)
.
length
0
"
The
code
ran
before
the
reload
isn
'
t
logged
"
)
;
await
toggleJsTracer
(
dbg
.
toolbox
)
;
topLevelThreadActorID
=
dbg
.
toolbox
.
commands
.
targetCommand
.
targetFront
.
threadFront
.
actorID
;
info
(
"
Wait
for
tracing
to
be
disabled
"
)
;
await
waitForState
(
dbg
(
)
=
>
{
return
dbg
.
selectors
.
getIsThreadCurrentlyTracing
(
topLevelThreadActorID
)
;
}
)
;
await
waitFor
(
(
)
=
>
{
return
!
traceButton
.
classList
.
contains
(
"
active
"
)
;
}
"
The
tracer
button
is
no
longer
active
after
stop
request
"
)
;
info
(
"
Toggle
the
setting
back
off
"
)
;
await
toggleJsTracerMenuItem
(
dbg
"
#
jstracer
-
menu
-
item
-
next
-
load
"
)
;
await
waitFor
(
(
)
=
>
{
traceButton
=
dbg
.
toolbox
.
doc
.
getElementById
(
"
command
-
button
-
jstracer
"
)
;
return
!
traceButton
.
classList
.
contains
(
"
pending
"
)
;
}
"
The
tracer
button
is
no
longer
pending
after
toggling
the
setting
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
javascript
-
tracing
-
on
-
next
-
interaction
"
)
;
}
)
;
