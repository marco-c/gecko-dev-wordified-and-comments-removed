"
use
strict
"
;
const
SOURCE_URL_DEFAULT_MAX_LENGTH
=
64
;
const
STACK_FRAMES_SOURCE_URL_MAX_LENGTH
=
15
;
const
STACK_FRAMES_SOURCE_URL_TRIM_SECTION
=
"
center
"
;
const
STACK_FRAMES_SCROLL_DELAY
=
100
;
const
BREAKPOINT_SMALL_WINDOW_WIDTH
=
850
;
const
RESULTS_PANEL_POPUP_POSITION
=
"
before_end
"
;
const
RESULTS_PANEL_MAX_RESULTS
=
10
;
const
FILE_SEARCH_ACTION_MAX_DELAY
=
300
;
const
GLOBAL_SEARCH_EXPAND_MAX_RESULTS
=
50
;
const
GLOBAL_SEARCH_LINE_MAX_LENGTH
=
300
;
const
GLOBAL_SEARCH_ACTION_MAX_DELAY
=
1500
;
const
FUNCTION_SEARCH_ACTION_MAX_DELAY
=
400
;
const
SEARCH_GLOBAL_FLAG
=
"
!
"
;
const
SEARCH_FUNCTION_FLAG
=
"
"
;
const
SEARCH_TOKEN_FLAG
=
"
#
"
;
const
SEARCH_LINE_FLAG
=
"
:
"
;
const
SEARCH_VARIABLE_FLAG
=
"
*
"
;
const
SEARCH_AUTOFILL
=
[
SEARCH_GLOBAL_FLAG
SEARCH_FUNCTION_FLAG
SEARCH_TOKEN_FLAG
]
;
const
EDITOR_VARIABLE_HOVER_DELAY
=
750
;
const
EDITOR_VARIABLE_POPUP_POSITION
=
"
topcenter
bottomleft
"
;
const
TOOLBAR_ORDER_POPUP_POSITION
=
"
topcenter
bottomleft
"
;
const
RESIZE_REFRESH_RATE
=
50
;
const
PROMISE_DEBUGGER_URL
=
"
chrome
:
/
/
devtools
/
content
/
promisedebugger
/
promise
-
debugger
.
xhtml
"
;
const
EventListenersView
=
require
(
'
.
/
content
/
views
/
event
-
listeners
-
view
'
)
;
const
SourcesView
=
require
(
'
.
/
content
/
views
/
sources
-
view
'
)
;
var
actions
=
Object
.
assign
(
{
}
require
(
'
.
/
content
/
globalActions
'
)
require
(
'
.
/
content
/
actions
/
breakpoints
'
)
require
(
'
.
/
content
/
actions
/
sources
'
)
require
(
'
.
/
content
/
actions
/
event
-
listeners
'
)
)
;
var
queries
=
require
(
'
.
/
content
/
queries
'
)
;
var
constants
=
require
(
'
.
/
content
/
constants
'
)
;
var
DebuggerView
=
{
LARGE_FILE_SIZE
:
1048576
initialize
:
function
(
)
{
if
(
this
.
_startup
)
{
return
this
.
_startup
;
}
const
deferred
=
promise
.
defer
(
)
;
this
.
_startup
=
deferred
.
promise
;
this
.
_initializePanes
(
)
;
this
.
Toolbar
.
initialize
(
)
;
this
.
Options
.
initialize
(
)
;
this
.
Filtering
.
initialize
(
)
;
this
.
StackFrames
.
initialize
(
)
;
this
.
StackFramesClassicList
.
initialize
(
)
;
this
.
Workers
.
initialize
(
)
;
this
.
Sources
.
initialize
(
)
;
this
.
VariableBubble
.
initialize
(
)
;
this
.
WatchExpressions
.
initialize
(
)
;
this
.
EventListeners
.
initialize
(
)
;
this
.
GlobalSearch
.
initialize
(
)
;
this
.
_initializeVariablesView
(
)
;
this
.
_initializeEditor
(
deferred
.
resolve
)
;
this
.
_editorSource
=
{
}
;
document
.
title
=
L10N
.
getStr
(
"
DebuggerWindowTitle
"
)
;
this
.
editor
.
on
(
"
cursorActivity
"
this
.
Sources
.
_onEditorCursorActivity
)
;
this
.
controller
=
DebuggerController
;
const
getState
=
this
.
controller
.
getState
;
onReducerEvents
(
this
.
controller
{
"
source
-
text
-
loaded
"
:
this
.
renderSourceText
"
source
-
selected
"
:
this
.
renderSourceText
"
blackboxed
"
:
this
.
renderBlackBoxed
"
prettyprinted
"
:
this
.
renderPrettyPrinted
"
breakpoint
-
added
"
:
this
.
addEditorBreakpoint
"
breakpoint
-
enabled
"
:
this
.
addEditorBreakpoint
"
breakpoint
-
disabled
"
:
this
.
removeEditorBreakpoint
"
breakpoint
-
removed
"
:
this
.
removeEditorBreakpoint
"
breakpoint
-
condition
-
updated
"
:
this
.
renderEditorBreakpointCondition
"
breakpoint
-
moved
"
:
(
{
breakpoint
prevLocation
}
)
=
>
{
const
selectedSource
=
queries
.
getSelectedSource
(
getState
(
)
)
;
const
{
location
}
=
breakpoint
;
if
(
selectedSource
&
&
selectedSource
.
actor
=
=
=
location
.
actor
)
{
this
.
editor
.
moveBreakpoint
(
prevLocation
.
line
-
1
location
.
line
-
1
)
;
}
}
}
this
)
;
return
deferred
.
promise
;
}
destroy
:
function
(
)
{
if
(
this
.
_hasShutdown
)
{
return
;
}
this
.
_hasShutdown
=
true
;
window
.
removeEventListener
(
"
resize
"
this
.
_onResize
false
)
;
this
.
editor
.
off
(
"
cursorActivity
"
this
.
Sources
.
_onEditorCursorActivity
)
;
this
.
Toolbar
.
destroy
(
)
;
this
.
Options
.
destroy
(
)
;
this
.
Filtering
.
destroy
(
)
;
this
.
StackFrames
.
destroy
(
)
;
this
.
StackFramesClassicList
.
destroy
(
)
;
this
.
Sources
.
destroy
(
)
;
this
.
VariableBubble
.
destroy
(
)
;
this
.
WatchExpressions
.
destroy
(
)
;
this
.
EventListeners
.
destroy
(
)
;
this
.
GlobalSearch
.
destroy
(
)
;
this
.
_destroyPromiseDebugger
(
)
;
this
.
_destroyPanes
(
)
;
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
this
.
controller
.
dispatch
(
actions
.
removeAllBreakpoints
(
)
)
;
}
_initializePanes
:
function
(
)
{
dumpn
(
"
Initializing
the
DebuggerView
panes
"
)
;
this
.
_body
=
document
.
getElementById
(
"
body
"
)
;
this
.
_editorDeck
=
document
.
getElementById
(
"
editor
-
deck
"
)
;
this
.
_workersAndSourcesPane
=
document
.
getElementById
(
"
workers
-
and
-
sources
-
pane
"
)
;
this
.
_instrumentsPane
=
document
.
getElementById
(
"
instruments
-
pane
"
)
;
this
.
_instrumentsPaneToggleButton
=
document
.
getElementById
(
"
instruments
-
pane
-
toggle
"
)
;
this
.
_promisePane
=
document
.
getElementById
(
"
promise
-
debugger
-
pane
"
)
;
this
.
showEditor
=
this
.
showEditor
.
bind
(
this
)
;
this
.
showBlackBoxMessage
=
this
.
showBlackBoxMessage
.
bind
(
this
)
;
this
.
showProgressBar
=
this
.
showProgressBar
.
bind
(
this
)
;
this
.
_onTabSelect
=
this
.
_onInstrumentsPaneTabSelect
.
bind
(
this
)
;
this
.
_instrumentsPane
.
tabpanels
.
addEventListener
(
"
select
"
this
.
_onTabSelect
)
;
this
.
_collapsePaneString
=
L10N
.
getStr
(
"
collapsePanes
"
)
;
this
.
_expandPaneString
=
L10N
.
getStr
(
"
expandPanes
"
)
;
this
.
_workersAndSourcesPane
.
setAttribute
(
"
width
"
Prefs
.
workersAndSourcesWidth
)
;
this
.
_instrumentsPane
.
setAttribute
(
"
width
"
Prefs
.
instrumentsWidth
)
;
this
.
toggleInstrumentsPane
(
{
visible
:
Prefs
.
panesVisibleOnStartup
}
)
;
this
.
updateLayoutMode
(
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
window
.
addEventListener
(
"
resize
"
this
.
_onResize
false
)
;
}
_destroyPanes
:
function
(
)
{
dumpn
(
"
Destroying
the
DebuggerView
panes
"
)
;
if
(
gHostType
!
=
"
side
"
)
{
Prefs
.
workersAndSourcesWidth
=
this
.
_workersAndSourcesPane
.
getAttribute
(
"
width
"
)
;
Prefs
.
instrumentsWidth
=
this
.
_instrumentsPane
.
getAttribute
(
"
width
"
)
;
}
this
.
_workersAndSourcesPane
=
null
;
this
.
_instrumentsPane
=
null
;
this
.
_instrumentsPaneToggleButton
=
null
;
this
.
_promisePane
=
null
;
}
_initializeVariablesView
:
function
(
)
{
this
.
Variables
=
new
VariablesView
(
document
.
getElementById
(
"
variables
"
)
{
searchPlaceholder
:
L10N
.
getStr
(
"
emptyVariablesFilterText
"
)
emptyText
:
L10N
.
getStr
(
"
emptyVariablesText
"
)
onlyEnumVisible
:
Prefs
.
variablesOnlyEnumVisible
searchEnabled
:
Prefs
.
variablesSearchboxVisible
eval
:
(
variable
value
)
=
>
{
let
string
=
variable
.
evaluationMacro
(
variable
value
)
;
DebuggerController
.
StackFrames
.
evaluate
(
string
)
;
}
lazyEmpty
:
true
}
)
;
this
.
Variables
.
toolbox
=
DebuggerController
.
_toolbox
;
VariablesViewController
.
attach
(
this
.
Variables
{
getEnvironmentClient
:
aObject
=
>
gThreadClient
.
environment
(
aObject
)
getObjectClient
:
aObject
=
>
{
return
gThreadClient
.
pauseGrip
(
aObject
)
}
}
)
;
this
.
Variables
.
on
(
"
fetched
"
(
aEvent
aType
)
=
>
{
switch
(
aType
)
{
case
"
scopes
"
:
window
.
emit
(
EVENTS
.
FETCHED_SCOPES
)
;
break
;
case
"
variables
"
:
window
.
emit
(
EVENTS
.
FETCHED_VARIABLES
)
;
break
;
case
"
properties
"
:
window
.
emit
(
EVENTS
.
FETCHED_PROPERTIES
)
;
break
;
}
}
)
;
}
_initializePromiseDebugger
:
function
(
)
{
let
iframe
=
this
.
_promiseDebuggerIframe
=
document
.
createElement
(
"
iframe
"
)
;
iframe
.
setAttribute
(
"
flex
"
1
)
;
let
onLoad
=
(
event
)
=
>
{
iframe
.
removeEventListener
(
"
load
"
onLoad
true
)
;
let
doc
=
event
.
target
;
let
win
=
doc
.
defaultView
;
win
.
setPanel
(
DebuggerController
.
_toolbox
)
;
}
;
iframe
.
addEventListener
(
"
load
"
onLoad
true
)
;
iframe
.
setAttribute
(
"
src
"
PROMISE_DEBUGGER_URL
)
;
this
.
_promisePane
.
appendChild
(
iframe
)
;
}
_destroyPromiseDebugger
:
function
(
)
{
if
(
this
.
_promiseDebuggerIframe
)
{
this
.
_promiseDebuggerIframe
.
contentWindow
.
destroy
(
)
;
this
.
_promiseDebuggerIframe
.
parentNode
.
removeChild
(
this
.
_promiseDebuggerIframe
)
;
this
.
_promiseDebuggerIframe
=
null
;
}
}
_initializeEditor
:
function
(
callback
)
{
dumpn
(
"
Initializing
the
DebuggerView
editor
"
)
;
let
extraKeys
=
{
}
;
bindKey
(
"
_doTokenSearch
"
"
tokenSearchKey
"
)
;
bindKey
(
"
_doGlobalSearch
"
"
globalSearchKey
"
{
alt
:
true
}
)
;
bindKey
(
"
_doFunctionSearch
"
"
functionSearchKey
"
)
;
extraKeys
[
Editor
.
keyFor
(
"
jumpToLine
"
)
]
=
false
;
extraKeys
[
"
Esc
"
]
=
false
;
function
bindKey
(
func
key
modifiers
=
{
}
)
{
key
=
document
.
getElementById
(
key
)
.
getAttribute
(
"
key
"
)
;
let
shortcut
=
Editor
.
accel
(
key
modifiers
)
;
extraKeys
[
shortcut
]
=
(
)
=
>
DebuggerView
.
Filtering
[
func
]
(
)
;
}
let
gutters
=
[
"
breakpoints
"
]
;
this
.
editor
=
new
Editor
(
{
mode
:
Editor
.
modes
.
text
readOnly
:
true
lineNumbers
:
true
showAnnotationRuler
:
true
gutters
:
gutters
extraKeys
:
extraKeys
contextMenu
:
"
sourceEditorContextMenu
"
enableCodeFolding
:
false
}
)
;
this
.
editor
.
appendTo
(
document
.
getElementById
(
"
editor
"
)
)
.
then
(
(
)
=
>
{
this
.
editor
.
extend
(
DebuggerEditor
)
;
this
.
_loadingText
=
L10N
.
getStr
(
"
loadingText
"
)
;
callback
(
)
;
}
)
;
this
.
editor
.
on
(
"
gutterClick
"
(
ev
line
button
)
=
>
{
if
(
button
=
=
2
)
{
this
.
clickedLine
=
line
;
}
else
{
const
source
=
queries
.
getSelectedSource
(
this
.
controller
.
getState
(
)
)
;
if
(
source
)
{
const
location
=
{
actor
:
source
.
actor
line
:
line
+
1
}
;
if
(
this
.
editor
.
hasBreakpoint
(
line
)
)
{
this
.
controller
.
dispatch
(
actions
.
removeBreakpoint
(
location
)
)
;
}
else
{
this
.
controller
.
dispatch
(
actions
.
addBreakpoint
(
location
)
)
;
}
}
}
}
)
;
}
updateEditorBreakpoints
:
function
(
source
)
{
const
breakpoints
=
queries
.
getBreakpoints
(
this
.
controller
.
getState
(
)
)
;
const
sources
=
queries
.
getSources
(
this
.
controller
.
getState
(
)
)
;
for
(
let
bp
of
breakpoints
)
{
if
(
sources
[
bp
.
location
.
actor
]
&
&
!
bp
.
disabled
)
{
this
.
addEditorBreakpoint
(
bp
)
;
}
else
{
this
.
removeEditorBreakpoint
(
bp
)
;
}
}
}
addEditorBreakpoint
:
function
(
breakpoint
)
{
const
{
location
condition
}
=
breakpoint
;
const
source
=
queries
.
getSelectedSource
(
this
.
controller
.
getState
(
)
)
;
if
(
source
&
&
source
.
actor
=
=
=
location
.
actor
&
&
!
breakpoint
.
disabled
)
{
this
.
editor
.
addBreakpoint
(
location
.
line
-
1
condition
)
;
}
}
removeEditorBreakpoint
:
function
(
breakpoint
)
{
const
{
location
}
=
breakpoint
;
const
source
=
queries
.
getSelectedSource
(
this
.
controller
.
getState
(
)
)
;
if
(
source
&
&
source
.
actor
=
=
=
location
.
actor
)
{
this
.
editor
.
removeBreakpoint
(
location
.
line
-
1
)
;
}
}
renderEditorBreakpointCondition
:
function
(
breakpoint
)
{
const
{
location
condition
}
=
breakpoint
;
const
source
=
queries
.
getSelectedSource
(
this
.
controller
.
getState
(
)
)
;
if
(
source
&
&
source
.
actor
=
=
=
location
.
actor
)
{
if
(
condition
)
{
this
.
editor
.
setBreakpointCondition
(
location
.
line
-
1
)
;
}
else
{
this
.
editor
.
removeBreakpointCondition
(
location
.
line
-
1
)
;
}
}
}
showEditor
:
function
(
)
{
this
.
_editorDeck
.
selectedIndex
=
0
;
}
showBlackBoxMessage
:
function
(
)
{
this
.
_editorDeck
.
selectedIndex
=
1
;
}
showProgressBar
:
function
(
)
{
this
.
_editorDeck
.
selectedIndex
=
2
;
}
_setEditorText
:
function
(
aTextContent
=
"
"
)
{
this
.
editor
.
setMode
(
Editor
.
modes
.
text
)
;
this
.
editor
.
setText
(
aTextContent
)
;
this
.
editor
.
clearDebugLocation
(
)
;
this
.
editor
.
clearHistory
(
)
;
}
_setEditorMode
:
function
(
aUrl
aContentType
=
"
"
aTextContent
=
"
"
)
{
if
(
SourceUtils
.
isJavaScript
(
aUrl
aContentType
)
)
{
return
void
this
.
editor
.
setMode
(
Editor
.
modes
.
js
)
;
}
if
(
aTextContent
.
match
(
/
^
\
s
*
<
/
)
)
{
return
void
this
.
editor
.
setMode
(
Editor
.
modes
.
html
)
;
}
this
.
editor
.
setMode
(
Editor
.
modes
.
text
)
;
}
renderBlackBoxed
:
function
(
source
)
{
this
.
_renderSourceText
(
source
queries
.
getSourceText
(
this
.
controller
.
getState
(
)
source
.
actor
)
)
;
}
renderPrettyPrinted
:
function
(
source
)
{
this
.
_renderSourceText
(
source
queries
.
getSourceText
(
this
.
controller
.
getState
(
)
source
.
actor
)
)
;
}
renderSourceText
:
function
(
source
)
{
this
.
_renderSourceText
(
source
queries
.
getSourceText
(
this
.
controller
.
getState
(
)
source
.
actor
)
queries
.
getSelectedSourceOpts
(
this
.
controller
.
getState
(
)
)
)
;
}
_renderSourceText
:
function
(
source
textInfo
opts
=
{
}
)
{
const
selectedSource
=
queries
.
getSelectedSource
(
this
.
controller
.
getState
(
)
)
;
if
(
!
selectedSource
|
|
selectedSource
.
actor
!
=
=
source
.
actor
)
{
return
;
}
if
(
source
.
isBlackBoxed
)
{
this
.
showBlackBoxMessage
(
)
;
setTimeout
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
SOURCE_SHOWN
source
)
;
}
0
)
;
return
;
}
else
{
this
.
showEditor
(
)
;
}
if
(
textInfo
.
loading
)
{
this
.
_setEditorText
(
L10N
.
getStr
(
"
loadingText
"
)
)
;
return
;
}
else
if
(
textInfo
.
error
)
{
let
msg
=
L10N
.
getFormatStr
(
"
errorLoadingText2
"
textInfo
.
error
)
;
this
.
_setEditorText
(
msg
)
;
Cu
.
reportError
(
msg
)
;
dumpn
(
msg
)
;
this
.
showEditor
(
)
;
window
.
emit
(
EVENTS
.
SOURCE_ERROR_SHOWN
source
)
;
return
;
}
if
(
!
(
'
line
'
in
opts
)
)
{
let
cachedFrames
=
DebuggerController
.
activeThread
.
cachedFrames
;
let
currentDepth
=
DebuggerController
.
StackFrames
.
currentFrameDepth
;
let
frame
=
cachedFrames
[
currentDepth
]
;
if
(
frame
&
&
frame
.
source
.
actor
=
=
source
.
actor
)
{
opts
.
line
=
frame
.
where
.
line
;
}
}
if
(
this
.
_editorSource
.
actor
=
=
=
source
.
actor
&
&
this
.
_editorSource
.
prettyPrinted
=
=
=
source
.
isPrettyPrinted
&
&
this
.
_editorSource
.
blackboxed
=
=
=
source
.
isBlackBoxed
)
{
this
.
updateEditorPosition
(
opts
)
;
return
;
}
this
.
_editorSource
.
actor
=
source
.
actor
;
this
.
_editorSource
.
prettyPrinted
=
source
.
isPrettyPrinted
;
this
.
_editorSource
.
blackboxed
=
source
.
isBlackBoxed
;
let
{
text
contentType
}
=
textInfo
;
this
.
_setEditorText
(
text
)
;
this
.
_setEditorMode
(
source
.
url
contentType
text
)
;
this
.
updateEditorBreakpoints
(
source
)
;
setTimeout
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
SOURCE_SHOWN
source
)
;
}
0
)
;
this
.
updateEditorPosition
(
opts
)
;
}
updateEditorPosition
:
function
(
opts
)
{
let
line
=
opts
.
line
|
|
0
;
if
(
line
<
1
)
{
window
.
emit
(
EVENTS
.
EDITOR_LOCATION_SET
)
;
return
;
}
if
(
opts
.
charOffset
)
{
line
+
=
this
.
editor
.
getPosition
(
opts
.
charOffset
)
.
line
;
}
if
(
opts
.
lineOffset
)
{
line
+
=
opts
.
lineOffset
;
}
if
(
opts
.
moveCursor
)
{
let
location
=
{
line
:
line
-
1
ch
:
opts
.
columnOffset
|
|
0
}
;
this
.
editor
.
setCursor
(
location
)
;
}
if
(
!
opts
.
noDebug
)
{
this
.
editor
.
setDebugLocation
(
line
-
1
)
;
}
window
.
emit
(
EVENTS
.
EDITOR_LOCATION_SET
)
;
}
setEditorLocation
:
function
(
aActor
aLine
aFlags
=
{
}
)
{
if
(
!
this
.
Sources
.
containsValue
(
aActor
)
)
{
throw
new
Error
(
"
Unknown
source
for
the
specified
URL
.
"
)
;
}
let
sourceItem
=
this
.
Sources
.
getItemByValue
(
aActor
)
;
let
source
=
sourceItem
.
attachment
.
source
;
this
.
controller
.
dispatch
(
actions
.
selectSource
(
source
{
line
:
aLine
charOffset
:
aFlags
.
charOffset
lineOffset
:
aFlags
.
lineOffset
columnOffset
:
aFlags
.
columnOffset
moveCursor
:
!
aFlags
.
noCaret
noDebug
:
aFlags
.
noDebug
forceUpdate
:
aFlags
.
force
}
)
)
;
}
get
instrumentsPaneHidden
(
)
{
return
this
.
_instrumentsPane
.
hasAttribute
(
"
pane
-
collapsed
"
)
;
}
get
instrumentsPaneTab
(
)
{
return
this
.
_instrumentsPane
.
selectedTab
.
id
;
}
toggleInstrumentsPane
:
function
(
aFlags
aTabIndex
)
{
let
pane
=
this
.
_instrumentsPane
;
let
button
=
this
.
_instrumentsPaneToggleButton
;
ViewHelpers
.
togglePane
(
aFlags
pane
)
;
if
(
aFlags
.
visible
)
{
button
.
removeAttribute
(
"
pane
-
collapsed
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
this
.
_collapsePaneString
)
;
}
else
{
button
.
setAttribute
(
"
pane
-
collapsed
"
"
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
this
.
_expandPaneString
)
;
}
if
(
aTabIndex
!
=
=
undefined
)
{
pane
.
selectedIndex
=
aTabIndex
;
}
}
showInstrumentsPane
:
function
(
aCallback
)
{
DebuggerView
.
toggleInstrumentsPane
(
{
visible
:
true
animated
:
true
delayed
:
true
callback
:
aCallback
}
0
)
;
}
_onInstrumentsPaneTabSelect
:
function
(
)
{
if
(
this
.
_instrumentsPane
.
selectedTab
.
id
=
=
"
events
-
tab
"
)
{
this
.
controller
.
dispatch
(
actions
.
fetchEventListeners
(
)
)
;
}
}
handleHostChanged
:
function
(
hostType
)
{
this
.
_hostType
=
hostType
;
this
.
updateLayoutMode
(
)
;
}
_onResize
:
function
(
evt
)
{
setNamedTimeout
(
"
resize
-
events
"
RESIZE_REFRESH_RATE
(
)
=
>
this
.
updateLayoutMode
(
)
)
;
}
updateLayoutMode
:
function
(
)
{
if
(
this
.
_isSmallWindowHost
(
)
|
|
this
.
_hostType
=
=
"
side
"
)
{
this
.
_setLayoutMode
(
"
vertical
"
)
;
}
else
{
this
.
_setLayoutMode
(
"
horizontal
"
)
;
}
}
_isSmallWindowHost
:
function
(
)
{
if
(
this
.
_hostType
!
=
"
window
"
)
{
return
false
;
}
return
window
.
outerWidth
<
=
BREAKPOINT_SMALL_WINDOW_WIDTH
;
}
_setLayoutMode
:
function
(
layoutMode
)
{
if
(
this
.
_body
.
getAttribute
(
"
layout
"
)
=
=
layoutMode
)
{
return
;
}
if
(
layoutMode
=
=
"
vertical
"
)
{
this
.
_enterVerticalLayout
(
)
;
}
else
{
this
.
_enterHorizontalLayout
(
)
;
}
this
.
_body
.
setAttribute
(
"
layout
"
layoutMode
)
;
window
.
emit
(
EVENTS
.
LAYOUT_CHANGED
layoutMode
)
;
}
_enterVerticalLayout
:
function
(
)
{
let
vertContainer
=
document
.
getElementById
(
"
vertical
-
layout
-
panes
-
container
"
)
;
let
splitter
=
document
.
getElementById
(
"
sources
-
and
-
instruments
-
splitter
"
)
;
vertContainer
.
insertBefore
(
this
.
_workersAndSourcesPane
splitter
)
;
vertContainer
.
appendChild
(
this
.
_instrumentsPane
)
;
vertContainer
.
setAttribute
(
"
height
"
vertContainer
.
getBoundingClientRect
(
)
.
height
)
;
}
_enterHorizontalLayout
:
function
(
)
{
let
normContainer
=
document
.
getElementById
(
"
debugger
-
widgets
"
)
;
let
editorPane
=
document
.
getElementById
(
"
editor
-
and
-
instruments
-
pane
"
)
;
let
splitter
=
document
.
getElementById
(
"
sources
-
and
-
editor
-
splitter
"
)
;
normContainer
.
insertBefore
(
this
.
_workersAndSourcesPane
splitter
)
;
editorPane
.
appendChild
(
this
.
_instrumentsPane
)
;
this
.
_workersAndSourcesPane
.
setAttribute
(
"
width
"
Prefs
.
workersAndSourcesWidth
)
;
this
.
_instrumentsPane
.
setAttribute
(
"
width
"
Prefs
.
instrumentsWidth
)
;
}
handleTabNavigation
:
function
(
)
{
dumpn
(
"
Handling
tab
navigation
in
the
DebuggerView
"
)
;
this
.
Filtering
.
clearSearch
(
)
;
this
.
GlobalSearch
.
clearView
(
)
;
this
.
StackFrames
.
empty
(
)
;
this
.
Sources
.
empty
(
)
;
this
.
Variables
.
empty
(
)
;
this
.
EventListeners
.
empty
(
)
;
if
(
this
.
editor
)
{
this
.
editor
.
setMode
(
Editor
.
modes
.
text
)
;
this
.
editor
.
setText
(
"
"
)
;
this
.
editor
.
clearHistory
(
)
;
this
.
_editorSource
=
{
}
;
}
}
Toolbar
:
null
Options
:
null
Filtering
:
null
GlobalSearch
:
null
StackFrames
:
null
Sources
:
null
Variables
:
null
VariableBubble
:
null
WatchExpressions
:
null
EventListeners
:
null
editor
:
null
_loadingText
:
"
"
_body
:
null
_editorDeck
:
null
_workersAndSourcesPane
:
null
_instrumentsPane
:
null
_instrumentsPaneToggleButton
:
null
_collapsePaneString
:
"
"
_expandPaneString
:
"
"
}
;
function
ResultsPanelContainer
(
)
{
}
ResultsPanelContainer
.
prototype
=
Heritage
.
extend
(
WidgetMethods
{
set
anchor
(
aNode
)
{
this
.
_anchor
=
aNode
;
if
(
aNode
)
{
if
(
!
this
.
_panel
)
{
this
.
_panel
=
document
.
createElement
(
"
panel
"
)
;
this
.
_panel
.
id
=
"
results
-
panel
"
;
this
.
_panel
.
setAttribute
(
"
level
"
"
top
"
)
;
this
.
_panel
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
this
.
_panel
.
setAttribute
(
"
consumeoutsideclicks
"
"
false
"
)
;
document
.
documentElement
.
appendChild
(
this
.
_panel
)
;
}
if
(
!
this
.
widget
)
{
this
.
widget
=
new
SimpleListWidget
(
this
.
_panel
)
;
this
.
autoFocusOnFirstItem
=
false
;
this
.
autoFocusOnSelection
=
false
;
this
.
maintainSelectionVisible
=
false
;
}
}
else
{
this
.
_panel
.
remove
(
)
;
this
.
_panel
=
null
;
this
.
widget
=
null
;
}
}
get
anchor
(
)
{
return
this
.
_anchor
;
}
set
hidden
(
aFlag
)
{
if
(
aFlag
)
{
this
.
_panel
.
hidden
=
true
;
this
.
_panel
.
hidePopup
(
)
;
}
else
{
this
.
_panel
.
hidden
=
false
;
this
.
_panel
.
openPopup
(
this
.
_anchor
this
.
position
this
.
left
this
.
top
)
;
}
}
get
hidden
(
)
{
return
this
.
_panel
.
state
=
=
"
closed
"
|
|
this
.
_panel
.
state
=
=
"
hiding
"
;
}
clearView
:
function
(
)
{
this
.
hidden
=
true
;
this
.
empty
(
)
;
}
selectNext
:
function
(
)
{
let
nextIndex
=
this
.
selectedIndex
+
1
;
if
(
nextIndex
>
=
this
.
itemCount
)
{
nextIndex
=
0
;
}
this
.
selectedItem
=
this
.
getItemAtIndex
(
nextIndex
)
;
}
selectPrev
:
function
(
)
{
let
prevIndex
=
this
.
selectedIndex
-
1
;
if
(
prevIndex
<
0
)
{
prevIndex
=
this
.
itemCount
-
1
;
}
this
.
selectedItem
=
this
.
getItemAtIndex
(
prevIndex
)
;
}
_createItemView
:
function
(
aLabel
aBelowLabel
aBeforeLabel
)
{
let
container
=
document
.
createElement
(
"
vbox
"
)
;
container
.
className
=
"
results
-
panel
-
item
"
;
let
firstRowLabels
=
document
.
createElement
(
"
hbox
"
)
;
let
secondRowLabels
=
document
.
createElement
(
"
hbox
"
)
;
if
(
aBeforeLabel
)
{
let
beforeLabelNode
=
document
.
createElement
(
"
label
"
)
;
beforeLabelNode
.
className
=
"
plain
results
-
panel
-
item
-
label
-
before
"
;
beforeLabelNode
.
setAttribute
(
"
value
"
aBeforeLabel
)
;
firstRowLabels
.
appendChild
(
beforeLabelNode
)
;
}
let
labelNode
=
document
.
createElement
(
"
label
"
)
;
labelNode
.
className
=
"
plain
results
-
panel
-
item
-
label
"
;
labelNode
.
setAttribute
(
"
value
"
aLabel
)
;
firstRowLabels
.
appendChild
(
labelNode
)
;
if
(
aBelowLabel
)
{
let
belowLabelNode
=
document
.
createElement
(
"
label
"
)
;
belowLabelNode
.
className
=
"
plain
results
-
panel
-
item
-
label
-
below
"
;
belowLabelNode
.
setAttribute
(
"
value
"
aBelowLabel
)
;
secondRowLabels
.
appendChild
(
belowLabelNode
)
;
}
container
.
appendChild
(
firstRowLabels
)
;
container
.
appendChild
(
secondRowLabels
)
;
return
container
;
}
_anchor
:
null
_panel
:
null
position
:
RESULTS_PANEL_POPUP_POSITION
left
:
0
top
:
0
}
)
;
DebuggerView
.
EventListeners
=
new
EventListenersView
(
DebuggerController
)
;
DebuggerView
.
Sources
=
new
SourcesView
(
DebuggerController
DebuggerView
)
;
