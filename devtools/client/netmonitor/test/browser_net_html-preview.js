"
use
strict
"
;
const
httpServer
=
createTestHTTPServer
(
)
;
httpServer
.
registerContentType
(
"
html
"
"
text
/
html
"
)
;
const
BASE_URL
=
http
:
/
/
localhost
:
{
httpServer
.
identity
.
primaryPort
}
/
;
const
REDIRECT_URL
=
BASE_URL
+
"
redirect
.
html
"
;
function
addBaseHtmlElements
(
body
)
{
return
<
html
>
<
head
>
<
/
head
>
<
body
>
{
body
}
<
/
body
>
<
/
html
>
;
}
const
TEST_PAGES
=
{
redirect
:
addBaseHtmlElements
(
Fetch
1
<
script
>
window
.
parent
.
location
.
href
=
"
{
REDIRECT_URL
}
"
;
<
/
script
>
)
js
:
addBaseHtmlElements
(
Fetch
2
<
script
>
document
.
write
(
"
JS
activated
"
)
<
/
script
>
)
forms
:
addBaseHtmlElements
(
Fetch
3
<
a
href
=
"
{
REDIRECT_URL
}
"
>
link
<
/
a
>
-
-
<
form
action
=
"
{
REDIRECT_URL
}
"
>
<
input
type
=
"
submit
"
>
<
/
form
>
)
lineBreak
:
addBaseHtmlElements
(
<
a
href
=
"
#
"
id
=
"
link1
"
>
link1
<
/
a
>
<
a
href
=
"
#
"
id
=
"
link2
"
>
link2
<
/
a
>
)
styles
:
addBaseHtmlElements
(
<
p
style
=
"
color
:
red
;
"
>
Hello
World
<
/
p
>
)
csp
:
addBaseHtmlElements
(
<
base
href
=
"
https
:
/
/
example
.
com
/
"
>
<
img
src
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2P4v5ThPwAG7wKklwQ
/
bwAAAABJRU5ErkJggg
=
=
"
>
<
iframe
src
=
"
/
foo
.
html
"
>
<
/
iframe
>
)
}
;
const
TEST_HTML
=
addBaseHtmlElements
(
<
div
id
=
"
to
-
copy
"
>
HTML
<
/
div
>
<
script
>
+
Object
.
keys
(
TEST_PAGES
)
.
map
(
name
=
>
fetch
(
"
{
BASE_URL
}
fetch
-
{
name
}
.
html
"
)
;
)
.
join
(
"
\
n
"
)
+
<
/
script
>
)
;
const
TEST_URL
=
BASE_URL
+
"
doc
-
html
-
preview
.
html
"
;
httpServer
.
registerPathHandler
(
"
/
doc
-
html
-
preview
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
TEST_HTML
)
;
}
)
;
for
(
const
[
name
content
]
of
Object
.
entries
(
TEST_PAGES
)
)
{
httpServer
.
registerPathHandler
(
/
fetch
-
{
name
}
.
html
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
if
(
name
=
=
=
"
csp
"
)
{
response
.
setHeaderNoCheck
(
"
Content
-
Security
-
Policy
"
"
img
-
src
'
none
'
"
)
;
response
.
setHeaderNoCheck
(
"
Content
-
Security
-
Policy
"
"
base
-
uri
'
self
'
"
)
;
}
response
.
write
(
content
)
;
}
)
;
}
httpServer
.
registerPathHandler
(
"
/
redirect
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
"
Redirected
!
"
)
;
}
)
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
test
.
events
.
async
.
enabled
"
true
)
;
const
{
monitor
}
=
await
initNetMonitor
(
TEST_URL
{
requestCount
:
3
}
)
;
info
(
"
Starting
test
.
.
.
"
)
;
const
{
document
store
windowRequire
}
=
monitor
.
panelWin
;
const
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
const
onNetworkEvent
=
waitForNetworkEvents
(
monitor
1
+
Object
.
keys
(
TEST_PAGES
)
.
length
)
;
await
reloadBrowser
(
)
;
await
onNetworkEvent
;
await
selectIndexAndWaitForHtmlView
(
0
"
initial
-
page
"
TEST_HTML
)
;
let
index
=
1
;
for
(
const
[
name
content
]
of
Object
.
entries
(
TEST_PAGES
)
)
{
await
selectIndexAndWaitForHtmlView
(
index
name
content
)
;
index
+
+
;
}
await
teardown
(
monitor
)
;
async
function
selectIndexAndWaitForHtmlView
(
index_
name
expectedHtmlPreview
)
{
info
(
Select
the
request
"
{
name
}
"
#
{
index_
}
)
;
const
onResponseContent
=
monitor
.
panelWin
.
api
.
once
(
TEST_EVENTS
.
RECEIVED_RESPONSE_CONTENT
)
;
store
.
dispatch
(
Actions
.
selectRequestByIndex
(
index_
)
)
;
document
.
querySelector
(
"
#
response
-
tab
"
)
.
click
(
)
;
const
[
browser
]
=
await
waitForDOM
(
document
"
#
response
-
panel
.
html
-
preview
browser
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Wait
for
response
content
to
be
loaded
"
)
;
await
onResponseContent
;
is
(
browser
.
browsingContext
.
currentWindowGlobal
.
isInProcess
false
"
The
preview
is
loaded
in
a
content
process
"
)
;
await
SpecialPowers
.
spawn
(
browser
.
browsingContext
[
expectedHtmlPreview
]
async
function
(
expectedHtml
)
{
is
(
content
.
document
.
documentElement
.
outerHTML
expectedHtml
"
The
text
shown
in
the
browser
is
incorrect
for
the
html
request
.
"
)
;
}
)
;
if
(
name
=
=
=
"
style
"
)
{
await
SpecialPowers
.
spawn
(
browser
.
browsingContext
[
]
async
function
(
)
{
const
p
=
content
.
document
.
querySelector
(
"
p
"
)
;
const
computed
=
content
.
window
.
getComputedStyle
(
p
)
;
is
(
computed
.
getPropertyValue
(
"
color
"
)
"
rgb
(
255
0
0
)
"
"
The
inline
style
was
not
applied
"
)
;
}
)
;
}
if
(
name
=
=
"
csp
"
)
{
await
SpecialPowers
.
spawn
(
browser
.
browsingContext
[
]
async
function
(
)
{
is
(
content
.
document
.
querySelector
(
"
img
"
)
.
complete
false
"
img
was
blocked
"
)
;
is
(
content
.
document
.
querySelector
(
"
iframe
"
)
.
src
"
/
foo
.
html
"
"
URL
of
iframe
was
not
changed
by
<
base
>
"
)
;
}
)
;
}
if
(
name
=
=
"
initial
-
page
"
)
{
await
waitForClipboardPromise
(
async
function
(
)
{
await
SpecialPowers
.
spawn
(
browser
.
browsingContext
[
]
async
function
(
)
{
const
elt
=
content
.
document
.
getElementById
(
"
to
-
copy
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
elt
{
clickCount
:
2
}
content
)
;
await
new
Promise
(
r
=
>
elt
.
addEventListener
(
"
dblclick
"
r
{
once
:
true
}
)
)
;
EventUtils
.
synthesizeKey
(
"
c
"
{
accelKey
:
true
}
content
)
;
}
)
;
}
"
HTML
"
)
;
}
}
}
)
;
