"
use
strict
"
;
add_task
(
async
function
(
)
{
requestLongerTimeout
(
4
)
;
let
{
tab
monitor
}
=
await
initNetMonitor
(
INFINITE_GET_URL
true
)
;
let
{
document
windowRequire
store
}
=
monitor
.
panelWin
;
let
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
await
waitForRequestListToAppear
(
)
;
let
requestsContainer
=
document
.
querySelector
(
"
.
requests
-
list
-
contents
"
)
;
ok
(
requestsContainer
"
Container
element
exists
as
expected
.
"
)
;
await
waitForRequestsToOverflowContainer
(
)
;
await
waitForScroll
(
)
;
ok
(
true
"
Scrolled
to
bottom
on
overflow
.
"
)
;
requestsContainer
.
scrollTop
=
0
;
await
waitSomeTime
(
)
;
ok
(
!
scrolledToBottom
(
requestsContainer
)
"
Not
scrolled
to
bottom
.
"
)
;
let
scrollTop
=
requestsContainer
.
scrollTop
;
await
waitForNetworkEvents
(
monitor
8
)
;
await
waitSomeTime
(
)
;
is
(
requestsContainer
.
scrollTop
scrollTop
"
Did
not
scroll
.
"
)
;
requestsContainer
.
scrollTop
=
requestsContainer
.
scrollHeight
;
ok
(
scrolledToBottom
(
requestsContainer
)
"
Set
scroll
position
to
bottom
.
"
)
;
await
waitForNetworkEvents
(
monitor
8
)
;
await
waitForScroll
(
)
;
ok
(
true
"
Still
scrolled
to
bottom
.
"
)
;
store
.
dispatch
(
Actions
.
selectRequestByIndex
(
0
)
)
;
await
waitForNetworkEvents
(
monitor
8
)
;
await
waitSomeTime
(
)
;
let
requestsContainerHeaders
=
requestsContainer
.
firstChild
;
let
headersHeight
=
requestsContainerHeaders
.
offsetHeight
;
is
(
requestsContainer
.
scrollTop
headersHeight
"
Did
not
scroll
.
"
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
function
(
)
{
content
.
wrappedJSObject
.
stopRequests
(
)
;
}
)
;
return
teardown
(
monitor
)
;
function
waitForRequestListToAppear
(
)
{
info
(
"
Waiting
until
the
empty
notice
disappears
and
is
replaced
with
the
list
"
)
;
return
waitUntil
(
(
)
=
>
!
!
document
.
querySelector
(
"
.
requests
-
list
-
contents
"
)
)
;
}
async
function
waitForRequestsToOverflowContainer
(
)
{
info
(
"
Waiting
for
enough
requests
to
overflow
the
container
"
)
;
while
(
true
)
{
info
(
"
Waiting
for
one
network
request
"
)
;
await
waitForNetworkEvents
(
monitor
1
)
;
if
(
requestsContainer
.
scrollHeight
>
requestsContainer
.
clientHeight
)
{
info
(
"
The
list
is
long
enough
returning
"
)
;
return
;
}
}
}
function
scrolledToBottom
(
element
)
{
return
element
.
scrollTop
+
element
.
clientHeight
>
=
element
.
scrollHeight
;
}
function
waitSomeTime
(
)
{
return
wait
(
50
)
;
}
function
waitForScroll
(
)
{
info
(
"
Waiting
for
the
list
to
scroll
to
bottom
"
)
;
return
waitUntil
(
(
)
=
>
scrolledToBottom
(
requestsContainer
)
)
;
}
}
)
;
