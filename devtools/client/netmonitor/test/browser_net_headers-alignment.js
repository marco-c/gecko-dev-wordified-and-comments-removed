"
use
strict
"
;
add_task
(
function
*
(
)
{
requestLongerTimeout
(
4
)
;
let
{
tab
monitor
}
=
yield
initNetMonitor
(
INFINITE_GET_URL
true
)
;
let
{
document
windowRequire
store
}
=
monitor
.
panelWin
;
let
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
yield
waitForRequestListToAppear
(
)
;
let
requestsContainer
=
document
.
querySelector
(
"
.
requests
-
list
-
contents
"
)
;
ok
(
requestsContainer
"
Container
element
exists
as
expected
.
"
)
;
let
headers
=
document
.
querySelector
(
"
.
requests
-
list
-
headers
"
)
;
ok
(
headers
"
Headers
element
exists
as
expected
.
"
)
;
yield
waitForRequestsToOverflowContainer
(
)
;
let
firstRequestLine
=
requestsContainer
.
childNodes
[
1
]
;
let
numberOfColumns
=
headers
.
childElementCount
;
for
(
let
columnNumber
=
0
;
columnNumber
<
numberOfColumns
;
columnNumber
+
+
)
{
let
aHeaderColumn
=
headers
.
childNodes
[
columnNumber
]
;
let
aRequestColumn
=
firstRequestLine
.
childNodes
[
columnNumber
]
;
is
(
aHeaderColumn
.
getBoundingClientRect
(
)
.
left
aRequestColumn
.
getBoundingClientRect
(
)
.
left
"
Headers
for
columns
number
"
+
columnNumber
+
"
are
aligned
.
"
)
;
}
yield
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
function
*
(
)
{
content
.
wrappedJSObject
.
stopRequests
(
)
;
}
)
;
return
teardown
(
monitor
)
;
function
waitForRequestListToAppear
(
)
{
info
(
"
Waiting
until
the
empty
notice
disappears
and
is
replaced
with
the
list
"
)
;
return
waitUntil
(
(
)
=
>
!
!
document
.
querySelector
(
"
.
requests
-
list
-
contents
"
)
)
;
}
function
*
waitForRequestsToOverflowContainer
(
)
{
info
(
"
Waiting
for
enough
requests
to
overflow
the
container
"
)
;
while
(
true
)
{
info
(
"
Waiting
for
one
network
request
"
)
;
yield
waitForNetworkEvents
(
monitor
1
)
;
if
(
requestsContainer
.
scrollHeight
>
requestsContainer
.
clientHeight
)
{
info
(
"
The
list
is
long
enough
returning
"
)
;
return
;
}
}
}
}
)
;
