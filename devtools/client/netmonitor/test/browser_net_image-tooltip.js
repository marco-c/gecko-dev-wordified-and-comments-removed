"
use
strict
"
;
const
IMAGE_TOOLTIP_URL
=
EXAMPLE_URL
+
"
html_image
-
tooltip
-
test
-
page
.
html
"
;
const
IMAGE_TOOLTIP_REQUESTS
=
1
;
add_task
(
function
*
test
(
)
{
let
{
tab
monitor
}
=
yield
initNetMonitor
(
IMAGE_TOOLTIP_URL
)
;
info
(
"
Starting
test
.
.
.
"
)
;
let
{
document
gStore
windowRequire
NetMonitorController
}
=
monitor
.
panelWin
;
let
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
actions
/
index
"
)
;
let
{
ACTIVITY_TYPE
EVENTS
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
constants
"
)
;
let
toolboxDoc
=
monitor
.
toolbox
.
doc
;
gStore
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
let
onEvents
=
waitForNetworkEvents
(
monitor
IMAGE_TOOLTIP_REQUESTS
)
;
let
onThumbnail
=
monitor
.
panelWin
.
once
(
EVENTS
.
RESPONSE_IMAGE_THUMBNAIL_DISPLAYED
)
;
yield
performRequests
(
)
;
yield
onEvents
;
yield
onThumbnail
;
info
(
"
Checking
the
image
thumbnail
after
a
few
requests
were
made
.
.
.
"
)
;
yield
showTooltipAndVerify
(
document
.
querySelectorAll
(
"
.
request
-
list
-
item
"
)
[
0
]
)
;
info
(
"
Checking
the
image
thumbnail
gets
hidden
.
.
.
"
)
;
yield
hideTooltipAndVerify
(
document
.
querySelectorAll
(
"
.
request
-
list
-
item
"
)
[
0
]
)
;
onEvents
=
waitForNetworkEvents
(
monitor
IMAGE_TOOLTIP_REQUESTS
+
1
)
;
onThumbnail
=
monitor
.
panelWin
.
once
(
EVENTS
.
RESPONSE_IMAGE_THUMBNAIL_DISPLAYED
)
;
info
(
"
Reloading
the
debuggee
and
performing
all
requests
again
.
.
.
"
)
;
yield
NetMonitorController
.
triggerActivity
(
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_ENABLED
)
;
yield
performRequests
(
)
;
yield
onEvents
;
yield
onThumbnail
;
info
(
"
Checking
the
image
thumbnail
after
a
reload
.
"
)
;
yield
showTooltipAndVerify
(
document
.
querySelectorAll
(
"
.
request
-
list
-
item
"
)
[
1
]
)
;
info
(
"
Checking
if
the
image
thumbnail
is
hidden
when
mouse
leaves
the
menu
widget
"
)
;
let
requestsListContents
=
document
.
querySelector
(
"
.
requests
-
list
-
contents
"
)
;
EventUtils
.
synthesizeMouse
(
requestsListContents
0
0
{
type
:
"
mouseout
"
}
monitor
.
panelWin
)
;
yield
waitUntil
(
(
)
=
>
!
toolboxDoc
.
querySelector
(
"
.
tooltip
-
container
.
tooltip
-
visible
"
)
)
;
yield
teardown
(
monitor
)
;
function
performRequests
(
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
function
*
(
)
{
content
.
wrappedJSObject
.
performRequests
(
)
;
}
)
;
}
function
*
showTooltipAndVerify
(
target
)
{
let
anchor
=
target
.
querySelector
(
"
.
requests
-
list
-
file
"
)
;
yield
showTooltipOn
(
anchor
)
;
info
(
"
Tooltip
was
successfully
opened
for
the
image
request
.
"
)
;
is
(
toolboxDoc
.
querySelector
(
"
.
tooltip
-
panel
img
"
)
.
src
TEST_IMAGE_DATA_URI
"
The
tooltip
'
s
image
content
is
displayed
correctly
.
"
)
;
}
function
*
showTooltipOn
(
element
)
{
let
win
=
element
.
ownerDocument
.
defaultView
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mousemove
"
}
win
)
;
yield
waitUntil
(
(
)
=
>
toolboxDoc
.
querySelector
(
"
.
tooltip
-
panel
img
"
)
)
;
}
function
*
hideTooltipAndVerify
(
target
)
{
let
anchor
=
target
.
querySelector
(
"
.
requests
-
list
-
method
"
)
;
let
win
=
anchor
.
ownerDocument
.
defaultView
;
EventUtils
.
synthesizeMouseAtCenter
(
anchor
{
type
:
"
mousemove
"
}
win
)
;
yield
waitUntil
(
(
)
=
>
!
toolboxDoc
.
querySelector
(
"
.
tooltip
-
container
.
tooltip
-
visible
"
)
)
;
info
(
"
Tooltip
was
successfully
closed
.
"
)
;
}
}
)
;
