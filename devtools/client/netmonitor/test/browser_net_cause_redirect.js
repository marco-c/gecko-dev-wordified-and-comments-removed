"
use
strict
"
;
add_task
(
function
*
(
)
{
const
EXPECTED_REQUESTS
=
[
{
status
:
302
hasStack
:
true
}
{
status
:
200
hasStack
:
false
}
{
status
:
200
hasStack
:
true
}
]
;
let
{
tab
monitor
}
=
yield
initNetMonitor
(
CUSTOM_GET_URL
)
;
let
{
store
windowRequire
connector
}
=
monitor
.
panelWin
;
let
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
let
{
getSortedRequests
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
selectors
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
let
wait
=
waitForNetworkEvents
(
monitor
EXPECTED_REQUESTS
.
length
)
;
yield
performRequests
(
2
HSTS_SJS
)
;
yield
wait
;
let
requests
=
getSortedRequests
(
store
.
getState
(
)
)
;
yield
Promise
.
all
(
requests
.
map
(
requestItem
=
>
connector
.
requestData
(
requestItem
.
id
"
stackTrace
"
)
)
)
;
EXPECTED_REQUESTS
.
forEach
(
async
(
{
status
hasStack
}
i
)
=
>
{
let
item
=
getSortedRequests
(
store
.
getState
(
)
)
.
get
(
i
)
;
is
(
item
.
status
status
Request
#
{
i
}
has
the
expected
status
)
;
await
waitUntil
(
(
)
=
>
!
!
item
.
stacktrace
)
;
let
{
stacktrace
}
=
item
;
let
stackLen
=
stacktrace
?
stacktrace
.
length
:
0
;
if
(
hasStack
)
{
ok
(
stacktrace
Request
#
{
i
}
has
a
stacktrace
)
;
ok
(
stackLen
>
0
Request
#
{
i
}
has
a
stacktrace
with
{
stackLen
}
items
)
;
}
else
{
is
(
stackLen
0
Request
#
{
i
}
has
an
empty
stacktrace
)
;
}
}
)
;
wait
=
waitForNetworkEvents
(
monitor
1
)
;
yield
performRequests
(
1
HSTS_SJS
+
"
?
reset
"
)
;
yield
wait
;
yield
teardown
(
monitor
)
;
function
performRequests
(
count
url
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
count
url
}
function
*
(
args
)
{
content
.
wrappedJSObject
.
performRequests
(
args
.
count
args
.
url
)
;
}
)
;
}
}
)
;
