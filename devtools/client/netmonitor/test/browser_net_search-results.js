"
use
strict
"
;
const
{
PluralForm
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
plural
-
form
.
js
"
)
;
add_task
(
async
function
(
)
{
const
{
tab
monitor
}
=
await
initNetMonitor
(
HTTPS_CUSTOM_GET_URL
{
requestCount
:
1
}
)
;
info
(
"
Starting
test
.
.
.
"
)
;
const
{
document
store
windowRequire
}
=
monitor
.
panelWin
;
const
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
const
SEARCH_STRING
=
"
test
"
;
const
URLS
=
[
HTTPS_SEARCH_SJS
+
"
?
value
=
test1
"
HTTPS_SEARCH_SJS
+
"
?
value
=
test2
"
]
;
const
wait
=
waitForNetworkEvents
(
monitor
2
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
URLS
]
makeRequests
)
;
await
wait
;
await
store
.
dispatch
(
Actions
.
openSearch
(
)
)
;
typeInNetmonitor
(
SEARCH_STRING
monitor
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
-
content
.
treeRow
.
resourceRow
"
2
)
;
const
searchMatchContents
=
document
.
querySelectorAll
(
"
.
search
-
panel
-
content
.
treeRow
.
treeIcon
"
)
;
for
(
let
i
=
searchMatchContents
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
clickElement
(
searchMatchContents
[
i
]
monitor
)
;
}
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
-
content
.
treeRow
.
resultRow
"
12
)
;
const
matches
=
document
.
querySelectorAll
(
"
.
search
-
panel
-
content
.
treeRow
.
resultRow
"
)
;
await
checkSearchResult
(
monitor
matches
[
0
]
"
#
headers
-
panel
"
"
.
url
-
preview
.
properties
-
view
"
"
.
treeRow
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
1
]
"
#
headers
-
panel
"
"
#
responseHeaders
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
2
]
"
#
headers
-
panel
"
"
#
requestHeaders
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
3
]
"
#
cookies
-
panel
"
"
#
responseCookies
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
4
]
"
#
response
-
panel
"
"
.
CodeMirror
-
code
"
"
.
CodeMirror
-
activeline
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
5
]
"
#
headers
-
panel
"
"
.
url
-
preview
.
properties
-
view
"
"
.
treeRow
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
6
]
"
#
headers
-
panel
"
"
#
responseHeaders
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
7
]
"
#
headers
-
panel
"
"
#
requestHeaders
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
8
]
"
#
headers
-
panel
"
"
#
requestHeaders
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
9
]
"
#
cookies
-
panel
"
"
#
responseCookies
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
10
]
"
#
cookies
-
panel
"
"
#
requestCookies
.
properties
-
view
"
"
.
treeRow
.
selected
"
[
SEARCH_STRING
]
)
;
await
checkSearchResult
(
monitor
matches
[
11
]
"
#
response
-
panel
"
"
.
CodeMirror
-
code
"
"
.
CodeMirror
-
activeline
"
[
SEARCH_STRING
]
)
;
await
teardown
(
monitor
)
;
}
)
;
add_task
(
async
function
(
)
{
const
{
tab
monitor
}
=
await
initNetMonitor
(
HTTPS_CUSTOM_GET_URL
{
requestCount
:
1
}
)
;
info
(
"
Starting
test
.
.
.
"
)
;
const
{
document
store
windowRequire
}
=
monitor
.
panelWin
;
const
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
const
SEARCH_STRING
=
"
matchingResult
"
;
const
matchingUrls
=
[
HTTPS_SEARCH_SJS
+
"
?
value
=
matchingResult1
"
HTTPS_SEARCH_SJS
+
"
?
value
=
matchingResult2
"
]
;
const
nonMatchingUrls
=
[
HTTPS_SEARCH_SJS
+
"
?
value
=
somethingDifferent
"
]
;
const
wait
=
waitForNetworkEvents
(
monitor
matchingUrls
.
length
+
nonMatchingUrls
.
length
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
matchingUrls
]
makeRequests
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
nonMatchingUrls
]
makeRequests
)
;
await
wait
;
await
store
.
dispatch
(
Actions
.
openSearch
(
)
)
;
typeInNetmonitor
(
SEARCH_STRING
monitor
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
waitForAllNetworkUpdateEvents
(
)
;
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
-
content
.
treeRow
.
resourceRow
"
2
)
;
const
resourceMatches
=
document
.
querySelectorAll
(
"
.
search
-
panel
-
content
.
treeRow
.
treeIcon
"
)
;
const
firstResourceMatch
=
resourceMatches
[
0
]
;
clickElement
(
firstResourceMatch
monitor
)
;
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
-
content
.
treeRow
.
resultRow
"
1
)
;
const
contentMatches
=
document
.
querySelectorAll
(
"
.
search
-
panel
-
content
.
treeRow
.
resultRow
"
)
;
const
firstContentMatch
=
contentMatches
[
0
]
;
ok
(
document
.
querySelector
(
"
.
treeRow
.
selected
.
opened
"
)
"
The
previous
line
which
is
the
selected
line
is
expanded
to
show
the
result
row
"
)
;
await
checkContentMenuCopy
(
firstContentMatch
matchingUrls
[
0
]
monitor
)
;
const
secondResourceMatch
=
resourceMatches
[
1
]
;
await
checkResourceMenuCopyUrl
(
secondResourceMatch
matchingUrls
[
1
]
monitor
)
;
await
checkResourceMenuResend
(
secondResourceMatch
monitor
)
;
ok
(
document
.
querySelector
(
"
.
treeRow
.
selected
.
opened
"
)
"
The
previous
line
is
still
expanded
after
having
added
a
new
request
is
the
result
list
"
)
;
await
checkResourceMenuBlockUnblock
(
secondResourceMatch
matchingUrls
[
1
]
monitor
)
;
await
checkSaveAllAsHARWithContextMenu
(
secondResourceMatch
matchingUrls
monitor
)
;
const
waitForEvents
=
waitForNetworkEvents
(
monitor
1
)
;
tab
.
linkedBrowser
.
reload
(
)
;
await
waitForEvents
;
await
checkResourceMenuNotAvailbale
(
secondResourceMatch
monitor
)
;
await
teardown
(
monitor
)
;
}
)
;
add_task
(
async
function
searchWithRequestOnUnload
(
)
{
const
{
tab
monitor
}
=
await
initNetMonitor
(
HTTPS_CUSTOM_GET_URL
{
requestCount
:
1
}
)
;
info
(
"
Starting
test
.
.
.
"
)
;
const
{
document
store
windowRequire
}
=
monitor
.
panelWin
;
const
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
store
.
dispatch
(
Actions
.
batchEnable
(
false
)
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
HTTPS_SEARCH_SJS
+
"
?
value
=
test1
"
]
function
(
url
)
{
content
.
addEventListener
(
"
unload
"
(
)
=
>
{
content
.
wrappedJSObject
.
get
(
url
)
;
}
)
;
}
)
;
const
SEARCH_STRING
=
"
html_custom
-
get
-
page
.
html
"
;
const
waitForEvents
=
waitForNetworkEvents
(
monitor
2
)
;
tab
.
linkedBrowser
.
reload
(
)
;
await
waitForEvents
;
await
store
.
dispatch
(
Actions
.
openSearch
(
)
)
;
typeInNetmonitor
(
SEARCH_STRING
monitor
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
-
content
.
treeRow
.
resourceRow
"
1
)
;
await
waitForDOMIfNeeded
(
document
"
.
search
-
panel
.
status
-
bar
-
label
"
)
;
const
statusBar
=
document
.
querySelector
(
"
.
search
-
panel
.
status
-
bar
-
label
"
)
;
const
matchingLines
=
PluralForm
.
get
(
1
L10N
.
getStr
(
"
netmonitor
.
search
.
status
.
labels
.
matchingLines
"
)
)
.
replace
(
"
#
1
"
1
)
;
const
matchingFiles
=
PluralForm
.
get
(
1
L10N
.
getStr
(
"
netmonitor
.
search
.
status
.
labels
.
fileCount
"
)
)
.
replace
(
"
#
1
"
1
)
;
is
(
statusBar
.
textContent
L10N
.
getFormatStr
(
"
netmonitor
.
search
.
status
.
labels
.
done
"
matchingLines
matchingFiles
)
"
Search
completed
"
)
;
await
teardown
(
monitor
)
;
}
)
;
async
function
makeRequests
(
urls
)
{
await
content
.
wrappedJSObject
.
get
(
urls
[
0
]
)
;
await
content
.
wrappedJSObject
.
get
(
urls
[
1
]
)
;
info
(
"
XHR
Requests
executed
"
)
;
}
async
function
checkContentMenuCopy
(
contentMatch
expectedClipboardValue
monitor
)
{
EventUtils
.
sendMouseEvent
(
{
type
:
"
contextmenu
"
}
contentMatch
)
;
await
waitForClipboardPromise
(
async
function
setup
(
)
{
await
selectContextMenuItem
(
monitor
"
properties
-
view
-
context
-
menu
-
copyvalue
"
)
;
}
expectedClipboardValue
)
;
}
async
function
checkResourceMenuCopyUrl
(
resourceMatch
expectedClipboardValue
monitor
)
{
EventUtils
.
sendMouseEvent
(
{
type
:
"
contextmenu
"
}
resourceMatch
)
;
await
waitForClipboardPromise
(
async
function
setup
(
)
{
await
selectContextMenuItem
(
monitor
"
request
-
list
-
context
-
copy
-
url
"
)
;
}
expectedClipboardValue
)
;
}
async
function
checkResourceMenuResend
(
resourceMatch
monitor
)
{
const
{
store
windowRequire
}
=
monitor
.
panelWin
;
const
{
getSelectedRequest
getDisplayedRequests
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
selectors
/
index
"
)
;
const
displayedRequests
=
getDisplayedRequests
(
store
.
getState
(
)
)
;
const
originalResourceIds
=
displayedRequests
.
map
(
r
=
>
r
.
id
)
;
const
expectedNrOfRequestsAfterResend
=
displayedRequests
.
length
+
1
;
const
waitForNewRequest
=
waitUntil
(
(
)
=
>
{
const
newResourceId
=
getSelectedRequest
(
store
.
getState
(
)
)
?
.
id
;
return
(
getDisplayedRequests
(
store
.
getState
(
)
)
.
length
=
=
expectedNrOfRequestsAfterResend
&
&
!
originalResourceIds
.
includes
(
newResourceId
)
)
;
}
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
contextmenu
"
}
resourceMatch
)
;
await
selectContextMenuItem
(
monitor
"
request
-
list
-
context
-
resend
-
only
"
)
;
await
waitForNewRequest
;
}
async
function
checkResourceMenuBlockUnblock
(
resourceMatch
blockUrl
monitor
)
{
const
{
store
windowRequire
}
=
monitor
.
panelWin
;
await
toggleBlockedUrl
(
resourceMatch
monitor
store
)
;
is
(
store
.
getState
(
)
.
requestBlocking
.
blockedUrls
.
length
1
"
There
should
be
1
blocked
URL
"
)
;
is
(
store
.
getState
(
)
.
requestBlocking
.
blockedUrls
[
0
]
.
url
blockUrl
The
blocked
URL
should
be
'
{
blockUrl
}
'
)
;
const
Actions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
await
store
.
dispatch
(
Actions
.
openSearch
(
)
)
;
await
toggleBlockedUrl
(
resourceMatch
monitor
store
"
unblock
"
)
;
is
(
store
.
getState
(
)
.
requestBlocking
.
blockedUrls
.
length
0
"
There
should
be
no
blocked
URL
"
)
;
}
async
function
checkSaveAllAsHARWithContextMenu
(
resourceMatch
expectedUrls
monitor
)
{
const
{
HarMenuUtils
}
=
monitor
.
panelWin
.
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
menu
-
utils
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
mousedown
"
}
resourceMatch
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
contextmenu
"
}
resourceMatch
)
;
info
(
"
Trigger
Copy
All
As
HAR
from
the
context
menu
"
)
;
const
onHarCopyDone
=
HarMenuUtils
.
once
(
"
copy
-
all
-
as
-
har
-
done
"
)
;
await
selectContextMenuItem
(
monitor
"
request
-
list
-
context
-
copy
-
all
-
as
-
har
"
)
;
const
jsonString
=
await
onHarCopyDone
;
info
(
"
exported
JSON
:
\
n
"
+
jsonString
)
;
const
parsedJson
=
JSON
.
parse
(
jsonString
)
;
is
(
parsedJson
?
.
log
?
.
entries
?
.
length
expectedUrls
.
length
"
Expected
length
of
"
+
expectedUrls
.
length
)
;
for
(
let
i
=
0
;
i
<
expectedUrls
.
length
;
i
+
+
)
{
is
(
parsedJson
.
log
.
entries
[
i
]
.
request
?
.
url
expectedUrls
[
i
]
"
Expected
url
was
'
"
+
expectedUrls
[
i
]
+
"
'
"
)
;
}
}
async
function
checkResourceMenuNotAvailbale
(
resourceMatch
monitor
)
{
EventUtils
.
sendMouseEvent
(
{
type
:
"
contextmenu
"
}
resourceMatch
)
;
is
(
!
!
getContextMenuItem
(
monitor
"
simple
-
view
-
context
-
menu
-
request
-
not
-
available
-
anymore
"
)
true
"
context
menu
item
'
not
-
available
'
should
be
present
"
)
;
is
(
!
!
getContextMenuItem
(
monitor
"
request
-
list
-
context
-
resend
-
only
"
)
false
"
context
menu
item
'
resend
'
should
not
be
present
"
)
;
is
(
!
!
getContextMenuItem
(
monitor
"
request
-
list
-
context
-
copy
-
all
-
as
-
har
"
)
false
"
context
menu
item
'
copy
all
as
HAR
'
should
not
be
present
"
)
;
is
(
!
!
getContextMenuItem
(
monitor
"
netmonitor
.
context
.
blockURL
"
)
false
"
context
menu
item
'
block
URL
'
should
not
be
present
"
)
;
}
async
function
checkSearchResult
(
monitor
match
panelSelector
panelContentSelector
panelDetailSelector
expected
)
{
const
{
document
}
=
monitor
.
panelWin
;
match
.
scrollIntoView
(
)
;
clickElement
(
match
monitor
)
;
console
.
log
(
{
panelSelector
}
{
panelContentSelector
}
)
;
await
waitFor
(
(
)
=
>
document
.
querySelector
(
{
panelSelector
}
{
panelContentSelector
}
)
)
;
const
tabpanel
=
document
.
querySelector
(
panelSelector
)
;
const
content
=
tabpanel
.
querySelectorAll
(
{
panelContentSelector
}
{
panelDetailSelector
}
)
;
is
(
content
.
length
expected
.
length
There
should
be
{
expected
.
length
}
item
{
expected
.
length
=
=
=
1
?
"
"
:
"
s
"
}
displayed
in
this
tabpanel
)
;
if
(
panelDetailSelector
=
=
=
"
.
treeRow
.
selected
"
)
{
const
selectedElements
=
tabpanel
.
querySelectorAll
(
panelDetailSelector
)
;
is
(
selectedElements
.
length
1
There
should
be
only
1
item
selected
found
{
selectedElements
.
length
}
items
selected
)
;
}
if
(
content
.
length
=
=
=
expected
.
length
)
{
for
(
let
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
is
(
content
[
i
]
.
textContent
.
includes
(
expected
[
i
]
)
true
Content
must
include
{
expected
[
i
]
}
)
;
}
}
}
