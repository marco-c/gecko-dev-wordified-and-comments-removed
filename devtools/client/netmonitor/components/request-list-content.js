"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
createClass
createFactory
DOM
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
div
}
=
DOM
;
const
Actions
=
require
(
"
.
.
/
actions
/
index
"
)
;
const
RequestListItem
=
createFactory
(
require
(
"
.
/
request
-
list
-
item
"
)
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
{
setTooltipImageContent
setTooltipStackTraceContent
}
=
require
(
"
.
/
request
-
list
-
tooltip
"
)
;
const
{
getDisplayedRequests
getWaterfallScale
}
=
require
(
"
.
.
/
selectors
/
index
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
REQUESTS_TOOLTIP_TOGGLE_DELAY
=
500
;
const
RequestListContent
=
createClass
(
{
displayName
:
"
RequestListContent
"
propTypes
:
{
displayedRequests
:
PropTypes
.
object
.
isRequired
firstRequestStartedMillis
:
PropTypes
.
number
.
isRequired
onItemContextMenu
:
PropTypes
.
func
.
isRequired
onItemMouseDown
:
PropTypes
.
func
.
isRequired
onSecurityIconClick
:
PropTypes
.
func
.
isRequired
onSelectDelta
:
PropTypes
.
func
.
isRequired
scale
:
PropTypes
.
number
selectedRequestId
:
PropTypes
.
string
tooltip
:
PropTypes
.
shape
(
{
hide
:
PropTypes
.
func
.
isRequired
startTogglingOnHover
:
PropTypes
.
func
.
isRequired
stopTogglingOnHover
:
PropTypes
.
func
.
isRequired
}
)
.
isRequired
}
componentDidMount
(
)
{
this
.
setScalingStyles
(
)
;
this
.
props
.
tooltip
.
startTogglingOnHover
(
this
.
refs
.
contentEl
this
.
onHover
{
toggleDelay
:
REQUESTS_TOOLTIP_TOGGLE_DELAY
interactive
:
true
}
)
;
this
.
refs
.
contentEl
.
addEventListener
(
"
scroll
"
this
.
onScroll
true
)
;
}
componentWillUpdate
(
nextProps
)
{
const
delta
=
nextProps
.
displayedRequests
.
size
-
this
.
props
.
displayedRequests
.
size
;
this
.
shouldScrollBottom
=
delta
>
0
&
&
this
.
isScrolledToBottom
(
)
;
}
componentDidUpdate
(
prevProps
)
{
this
.
setScalingStyles
(
prevProps
)
;
if
(
this
.
shouldScrollBottom
)
{
let
node
=
this
.
refs
.
contentEl
;
node
.
scrollTop
=
node
.
scrollHeight
;
}
}
componentWillUnmount
(
)
{
this
.
refs
.
contentEl
.
removeEventListener
(
"
scroll
"
this
.
onScroll
true
)
;
this
.
props
.
tooltip
.
stopTogglingOnHover
(
)
;
}
setScalingStyles
(
prevProps
)
{
const
{
scale
}
=
this
.
props
;
if
(
prevProps
&
&
prevProps
.
scale
=
=
=
scale
)
{
return
;
}
const
{
style
}
=
this
.
refs
.
contentEl
;
style
.
removeProperty
(
"
-
-
timings
-
scale
"
)
;
style
.
removeProperty
(
"
-
-
timings
-
rev
-
scale
"
)
;
style
.
setProperty
(
"
-
-
timings
-
scale
"
scale
)
;
style
.
setProperty
(
"
-
-
timings
-
rev
-
scale
"
1
/
scale
)
;
}
isScrolledToBottom
(
)
{
const
{
contentEl
}
=
this
.
refs
;
const
lastChildEl
=
contentEl
.
lastElementChild
;
if
(
!
lastChildEl
)
{
return
false
;
}
let
lastChildRect
=
lastChildEl
.
getBoundingClientRect
(
)
;
let
contentRect
=
contentEl
.
getBoundingClientRect
(
)
;
return
(
lastChildRect
.
height
+
lastChildRect
.
top
)
<
=
contentRect
.
bottom
;
}
onHover
:
Task
.
async
(
function
*
(
target
tooltip
)
{
let
itemEl
=
target
.
closest
(
"
.
request
-
list
-
item
"
)
;
if
(
!
itemEl
)
{
return
false
;
}
let
itemId
=
itemEl
.
dataset
.
id
;
if
(
!
itemId
)
{
return
false
;
}
let
requestItem
=
this
.
props
.
displayedRequests
.
find
(
r
=
>
r
.
id
=
=
itemId
)
;
if
(
!
requestItem
)
{
return
false
;
}
if
(
requestItem
.
responseContent
&
&
target
.
closest
(
"
.
requests
-
menu
-
icon
-
and
-
file
"
)
)
{
return
setTooltipImageContent
(
tooltip
itemEl
requestItem
)
;
}
else
if
(
requestItem
.
cause
&
&
target
.
closest
(
"
.
requests
-
menu
-
cause
-
stack
"
)
)
{
return
setTooltipStackTraceContent
(
tooltip
requestItem
)
;
}
return
false
;
}
)
onScroll
(
)
{
this
.
props
.
tooltip
.
hide
(
)
;
}
onKeyDown
(
e
)
{
let
delta
;
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
case
KeyCodes
.
DOM_VK_LEFT
:
delta
=
-
1
;
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
case
KeyCodes
.
DOM_VK_RIGHT
:
delta
=
+
1
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
delta
=
"
PAGE_UP
"
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
delta
=
"
PAGE_DOWN
"
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
delta
=
-
Infinity
;
break
;
case
KeyCodes
.
DOM_VK_END
:
delta
=
+
Infinity
;
break
;
}
if
(
delta
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
this
.
props
.
onSelectDelta
(
delta
)
;
}
}
onFocusedNodeChange
(
)
{
this
.
shouldScrollBottom
=
false
;
}
onFocusedNodeUnmount
(
)
{
if
(
this
.
refs
.
contentEl
)
{
this
.
refs
.
contentEl
.
focus
(
)
;
}
}
render
(
)
{
const
{
selectedRequestId
displayedRequests
firstRequestStartedMillis
onItemMouseDown
onItemContextMenu
onSecurityIconClick
}
=
this
.
props
;
return
div
(
{
ref
:
"
contentEl
"
className
:
"
requests
-
menu
-
contents
"
tabIndex
:
0
onKeyDown
:
this
.
onKeyDown
}
displayedRequests
.
map
(
(
item
index
)
=
>
RequestListItem
(
{
key
:
item
.
id
item
index
isSelected
:
item
.
id
=
=
=
selectedRequestId
firstRequestStartedMillis
onMouseDown
:
e
=
>
onItemMouseDown
(
e
item
.
id
)
onContextMenu
:
e
=
>
onItemContextMenu
(
e
item
.
id
)
onSecurityIconClick
:
e
=
>
onSecurityIconClick
(
e
item
)
onFocusedNodeChange
:
this
.
onFocusedNodeChange
onFocusedNodeUnmount
:
this
.
onFocusedNodeUnmount
}
)
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
displayedRequests
:
getDisplayedRequests
(
state
)
selectedRequestId
:
state
.
requests
.
selectedId
scale
:
getWaterfallScale
(
state
)
firstRequestStartedMillis
:
state
.
requests
.
firstStartedMillis
tooltip
:
NetMonitorView
.
RequestsMenu
.
tooltip
}
)
dispatch
=
>
(
{
onItemMouseDown
:
(
e
item
)
=
>
dispatch
(
Actions
.
selectRequest
(
item
)
)
onItemContextMenu
:
(
e
item
)
=
>
{
e
.
preventDefault
(
)
;
NetMonitorView
.
RequestsMenu
.
contextMenu
.
open
(
e
)
;
}
onSelectDelta
:
(
delta
)
=
>
dispatch
(
Actions
.
selectDelta
(
delta
)
)
onSecurityIconClick
:
(
e
item
)
=
>
{
const
{
securityState
}
=
item
;
if
(
securityState
&
&
securityState
!
=
=
"
insecure
"
)
{
NetMonitorView
.
NetworkDetails
.
widget
.
selectedIndex
=
5
;
}
}
}
)
)
(
RequestListContent
)
;
