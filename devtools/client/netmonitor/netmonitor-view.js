"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
XPCOMUtils
.
defineLazyGetter
(
this
"
HarExporter
"
function
(
)
{
return
require
(
"
devtools
/
client
/
netmonitor
/
har
/
har
-
exporter
"
)
.
HarExporter
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
NetworkHelper
"
function
(
)
{
return
require
(
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
}
)
;
const
{
SideMenuWidget
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
const
{
VariablesView
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
const
{
VariablesViewController
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
const
{
ToolSidebar
}
=
require
(
"
devtools
/
client
/
framework
/
sidebar
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
{
setImageTooltip
getImageDimensions
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
ImageTooltipHelper
"
)
;
const
{
testing
:
isTesting
}
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
PrefsHelper
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
ViewHelpers
Heritage
WidgetMethods
setNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
Curl
CurlUtils
}
=
require
(
"
devtools
/
client
/
shared
/
curl
"
)
;
const
{
Filters
isFreetextMatch
}
=
require
(
"
devtools
/
client
/
netmonitor
/
filter
-
predicates
"
)
;
const
NET_STRINGS_URI
=
"
devtools
/
locale
/
netmonitor
.
properties
"
;
const
WEBCONSOLE_STRINGS_URI
=
"
devtools
/
locale
/
webconsole
.
properties
"
;
var
L10N
=
new
LocalizationHelper
(
NET_STRINGS_URI
)
;
const
WEBCONSOLE_L10N
=
new
LocalizationHelper
(
WEBCONSOLE_STRINGS_URI
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
WDA_DEFAULT_VERIFY_INTERVAL
=
50
;
const
WDA_DEFAULT_GIVE_UP_TIMEOUT
=
isTesting
?
45000
:
2000
;
var
Prefs
=
new
PrefsHelper
(
"
devtools
.
netmonitor
"
{
networkDetailsWidth
:
[
"
Int
"
"
panes
-
network
-
details
-
width
"
]
networkDetailsHeight
:
[
"
Int
"
"
panes
-
network
-
details
-
height
"
]
statistics
:
[
"
Bool
"
"
statistics
"
]
filters
:
[
"
Json
"
"
filters
"
]
}
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
EPSILON
=
0
.
001
;
const
SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE
=
102400
;
const
RESIZE_REFRESH_RATE
=
50
;
const
REQUESTS_REFRESH_RATE
=
50
;
const
REQUESTS_TOOLTIP_TOGGLE_DELAY
=
500
;
const
REQUESTS_TOOLTIP_IMAGE_MAX_DIM
=
400
;
const
REQUESTS_TOOLTIP_STACK_TRACE_WIDTH
=
600
;
const
REQUESTS_WATERFALL_SAFE_BOUNDS
=
90
;
const
REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE
=
5
;
const
REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN
=
60
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE
=
5
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES
=
3
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN
=
10
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB
=
[
128
136
144
]
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN
=
32
;
const
REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD
=
32
;
const
REQUESTS_WATERFALL_DOMCONTENTLOADED_TICKS_COLOR_RGBA
=
[
255
0
0
128
]
;
const
REQUESTS_WATERFALL_LOAD_TICKS_COLOR_RGBA
=
[
0
0
255
128
]
;
const
REQUEST_TIME_DECIMALS
=
2
;
const
HEADERS_SIZE_DECIMALS
=
3
;
const
CONTENT_SIZE_DECIMALS
=
2
;
const
CONTENT_MIME_TYPE_ABBREVIATIONS
=
{
"
ecmascript
"
:
"
js
"
"
javascript
"
:
"
js
"
"
x
-
javascript
"
:
"
js
"
}
;
const
CONTENT_MIME_TYPE_MAPPINGS
=
{
"
/
ecmascript
"
:
Editor
.
modes
.
js
"
/
javascript
"
:
Editor
.
modes
.
js
"
/
x
-
javascript
"
:
Editor
.
modes
.
js
"
/
html
"
:
Editor
.
modes
.
html
"
/
xhtml
"
:
Editor
.
modes
.
html
"
/
xml
"
:
Editor
.
modes
.
html
"
/
atom
"
:
Editor
.
modes
.
html
"
/
soap
"
:
Editor
.
modes
.
html
"
/
vnd
.
mpeg
.
dash
.
mpd
"
:
Editor
.
modes
.
html
"
/
rdf
"
:
Editor
.
modes
.
css
"
/
rss
"
:
Editor
.
modes
.
css
"
/
css
"
:
Editor
.
modes
.
css
}
;
const
LOAD_CAUSE_STRINGS
=
{
[
Ci
.
nsIContentPolicy
.
TYPE_INVALID
]
:
"
invalid
"
[
Ci
.
nsIContentPolicy
.
TYPE_OTHER
]
:
"
other
"
[
Ci
.
nsIContentPolicy
.
TYPE_SCRIPT
]
:
"
script
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
]
:
"
img
"
[
Ci
.
nsIContentPolicy
.
TYPE_STYLESHEET
]
:
"
stylesheet
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT
]
:
"
object
"
[
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
]
:
"
document
"
[
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
]
:
"
subdocument
"
[
Ci
.
nsIContentPolicy
.
TYPE_REFRESH
]
:
"
refresh
"
[
Ci
.
nsIContentPolicy
.
TYPE_XBL
]
:
"
xbl
"
[
Ci
.
nsIContentPolicy
.
TYPE_PING
]
:
"
ping
"
[
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
]
:
"
xhr
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT_SUBREQUEST
]
:
"
objectSubdoc
"
[
Ci
.
nsIContentPolicy
.
TYPE_DTD
]
:
"
dtd
"
[
Ci
.
nsIContentPolicy
.
TYPE_FONT
]
:
"
font
"
[
Ci
.
nsIContentPolicy
.
TYPE_MEDIA
]
:
"
media
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
]
:
"
websocket
"
[
Ci
.
nsIContentPolicy
.
TYPE_CSP_REPORT
]
:
"
csp
"
[
Ci
.
nsIContentPolicy
.
TYPE_XSLT
]
:
"
xslt
"
[
Ci
.
nsIContentPolicy
.
TYPE_BEACON
]
:
"
beacon
"
[
Ci
.
nsIContentPolicy
.
TYPE_FETCH
]
:
"
fetch
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
]
:
"
imageset
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEB_MANIFEST
]
:
"
webManifest
"
}
;
function
loadCauseString
(
causeType
)
{
return
LOAD_CAUSE_STRINGS
[
causeType
]
|
|
"
unknown
"
;
}
const
DEFAULT_EDITOR_CONFIG
=
{
mode
:
Editor
.
modes
.
text
readOnly
:
true
lineNumbers
:
true
}
;
const
GENERIC_VARIABLES_VIEW_SETTINGS
=
{
lazyEmpty
:
true
lazyEmptyDelay
:
10
searchEnabled
:
true
editableValueTooltip
:
"
"
editableNameTooltip
:
"
"
preventDisableOnChange
:
true
preventDescriptorModifiers
:
true
eval
:
(
)
=
>
{
}
}
;
const
NETWORK_ANALYSIS_PIE_CHART_DIAMETER
=
200
;
const
FREETEXT_FILTER_SEARCH_DELAY
=
200
;
const
BYTES_IN_KB
=
1024
;
const
BYTES_IN_MB
=
Math
.
pow
(
BYTES_IN_KB
2
)
;
const
BYTES_IN_GB
=
Math
.
pow
(
BYTES_IN_KB
3
)
;
const
MAX_BYTES_SIZE
=
1000
;
const
MAX_KB_SIZE
=
1000
*
BYTES_IN_KB
;
const
MAX_MB_SIZE
=
1000
*
BYTES_IN_MB
;
const
{
DeferredTask
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
{
}
)
;
var
NetMonitorView
=
{
initialize
:
function
(
)
{
this
.
_initializePanes
(
)
;
this
.
Toolbar
.
initialize
(
)
;
this
.
RequestsMenu
.
initialize
(
)
;
this
.
NetworkDetails
.
initialize
(
)
;
this
.
CustomRequest
.
initialize
(
)
;
}
destroy
:
function
(
)
{
this
.
_isDestroyed
=
true
;
this
.
Toolbar
.
destroy
(
)
;
this
.
RequestsMenu
.
destroy
(
)
;
this
.
NetworkDetails
.
destroy
(
)
;
this
.
CustomRequest
.
destroy
(
)
;
this
.
_destroyPanes
(
)
;
}
_initializePanes
:
function
(
)
{
dumpn
(
"
Initializing
the
NetMonitorView
panes
"
)
;
this
.
_body
=
(
"
#
body
"
)
;
this
.
_detailsPane
=
(
"
#
details
-
pane
"
)
;
this
.
_detailsPaneToggleButton
=
(
"
#
details
-
pane
-
toggle
"
)
;
this
.
_collapsePaneString
=
L10N
.
getStr
(
"
collapseDetailsPane
"
)
;
this
.
_expandPaneString
=
L10N
.
getStr
(
"
expandDetailsPane
"
)
;
this
.
_detailsPane
.
setAttribute
(
"
width
"
Prefs
.
networkDetailsWidth
)
;
this
.
_detailsPane
.
setAttribute
(
"
height
"
Prefs
.
networkDetailsHeight
)
;
this
.
toggleDetailsPane
(
{
visible
:
false
}
)
;
if
(
!
Prefs
.
statistics
)
{
(
"
#
request
-
menu
-
context
-
perf
"
)
.
hidden
=
true
;
(
"
#
notice
-
perf
-
message
"
)
.
hidden
=
true
;
(
"
#
requests
-
menu
-
network
-
summary
-
button
"
)
.
hidden
=
true
;
}
}
_destroyPanes
:
Task
.
async
(
function
*
(
)
{
dumpn
(
"
Destroying
the
NetMonitorView
panes
"
)
;
Prefs
.
networkDetailsWidth
=
this
.
_detailsPane
.
getAttribute
(
"
width
"
)
;
Prefs
.
networkDetailsHeight
=
this
.
_detailsPane
.
getAttribute
(
"
height
"
)
;
this
.
_detailsPane
=
null
;
this
.
_detailsPaneToggleButton
=
null
;
for
(
let
p
of
this
.
_editorPromises
.
values
(
)
)
{
let
editor
=
yield
p
;
editor
.
destroy
(
)
;
}
}
)
get
detailsPaneHidden
(
)
{
return
this
.
_detailsPane
.
classList
.
contains
(
"
pane
-
collapsed
"
)
;
}
toggleDetailsPane
:
function
(
flags
tabIndex
)
{
let
pane
=
this
.
_detailsPane
;
let
button
=
this
.
_detailsPaneToggleButton
;
ViewHelpers
.
togglePane
(
flags
pane
)
;
if
(
flags
.
visible
)
{
this
.
_body
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
button
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
this
.
_collapsePaneString
)
;
}
else
{
this
.
_body
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
button
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
this
.
_expandPaneString
)
;
}
if
(
tabIndex
!
=
=
undefined
)
{
(
"
#
event
-
details
-
pane
"
)
.
selectedIndex
=
tabIndex
;
}
}
get
currentFrontendMode
(
)
{
if
(
!
this
.
_body
.
selectedPanel
)
{
return
null
;
}
return
this
.
_body
.
selectedPanel
.
id
;
}
toggleFrontendMode
:
function
(
)
{
if
(
this
.
currentFrontendMode
!
=
"
network
-
inspector
-
view
"
)
{
this
.
showNetworkInspectorView
(
)
;
}
else
{
this
.
showNetworkStatisticsView
(
)
;
}
}
showNetworkInspectorView
:
function
(
)
{
this
.
_body
.
selectedPanel
=
(
"
#
network
-
inspector
-
view
"
)
;
this
.
RequestsMenu
.
_flushWaterfallViews
(
true
)
;
}
showNetworkStatisticsView
:
function
(
)
{
this
.
_body
.
selectedPanel
=
(
"
#
network
-
statistics
-
view
"
)
;
let
controller
=
NetMonitorController
;
let
requestsView
=
this
.
RequestsMenu
;
let
statisticsView
=
this
.
PerformanceStatistics
;
Task
.
spawn
(
function
*
(
)
{
statisticsView
.
displayPlaceholderCharts
(
)
;
yield
controller
.
triggerActivity
(
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_ENABLED
)
;
try
{
yield
whenDataAvailable
(
requestsView
.
attachments
[
"
responseHeaders
"
"
status
"
"
contentSize
"
"
mimeType
"
"
totalTime
"
]
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
statisticsView
.
createPrimedCacheChart
(
requestsView
.
items
)
;
statisticsView
.
createEmptyCacheChart
(
requestsView
.
items
)
;
}
)
;
}
reloadPage
:
function
(
)
{
NetMonitorController
.
triggerActivity
(
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_DEFAULT
)
;
}
editor
:
function
(
id
)
{
dumpn
(
"
Getting
a
NetMonitorView
editor
:
"
+
id
)
;
if
(
this
.
_editorPromises
.
has
(
id
)
)
{
return
this
.
_editorPromises
.
get
(
id
)
;
}
let
deferred
=
promise
.
defer
(
)
;
this
.
_editorPromises
.
set
(
id
deferred
.
promise
)
;
let
editor
=
new
Editor
(
DEFAULT_EDITOR_CONFIG
)
;
editor
.
appendTo
(
(
id
)
)
.
then
(
(
)
=
>
deferred
.
resolve
(
editor
)
)
;
return
deferred
.
promise
;
}
_body
:
null
_detailsPane
:
null
_detailsPaneToggleButton
:
null
_collapsePaneString
:
"
"
_expandPaneString
:
"
"
_editorPromises
:
new
Map
(
)
}
;
function
ToolbarView
(
)
{
dumpn
(
"
ToolbarView
was
instantiated
"
)
;
this
.
_onTogglePanesPressed
=
this
.
_onTogglePanesPressed
.
bind
(
this
)
;
}
ToolbarView
.
prototype
=
{
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
ToolbarView
"
)
;
this
.
_detailsPaneToggleButton
=
(
"
#
details
-
pane
-
toggle
"
)
;
this
.
_detailsPaneToggleButton
.
addEventListener
(
"
mousedown
"
this
.
_onTogglePanesPressed
false
)
;
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
ToolbarView
"
)
;
this
.
_detailsPaneToggleButton
.
removeEventListener
(
"
mousedown
"
this
.
_onTogglePanesPressed
false
)
;
}
_onTogglePanesPressed
:
function
(
)
{
let
requestsMenu
=
NetMonitorView
.
RequestsMenu
;
let
selectedIndex
=
requestsMenu
.
selectedIndex
;
if
(
selectedIndex
=
=
-
1
&
&
requestsMenu
.
itemCount
)
{
requestsMenu
.
selectedIndex
=
0
;
}
else
{
requestsMenu
.
selectedIndex
=
-
1
;
}
}
_detailsPaneToggleButton
:
null
}
;
function
RequestsMenuView
(
)
{
dumpn
(
"
RequestsMenuView
was
instantiated
"
)
;
this
.
_flushRequests
=
this
.
_flushRequests
.
bind
(
this
)
;
this
.
_onHover
=
this
.
_onHover
.
bind
(
this
)
;
this
.
_onSelect
=
this
.
_onSelect
.
bind
(
this
)
;
this
.
_onSwap
=
this
.
_onSwap
.
bind
(
this
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
_onScroll
=
this
.
_onScroll
.
bind
(
this
)
;
this
.
_byFile
=
this
.
_byFile
.
bind
(
this
)
;
this
.
_byDomain
=
this
.
_byDomain
.
bind
(
this
)
;
this
.
_byType
=
this
.
_byType
.
bind
(
this
)
;
this
.
_onSecurityIconClick
=
this
.
_onSecurityIconClick
.
bind
(
this
)
;
}
RequestsMenuView
.
prototype
=
Heritage
.
extend
(
WidgetMethods
{
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
RequestsMenuView
"
)
;
let
widgetParentEl
=
(
"
#
requests
-
menu
-
contents
"
)
;
this
.
widget
=
new
SideMenuWidget
(
widgetParentEl
)
;
this
.
_splitter
=
(
"
#
network
-
inspector
-
view
-
splitter
"
)
;
this
.
_summary
=
(
"
#
requests
-
menu
-
network
-
summary
-
button
"
)
;
this
.
_summary
.
setAttribute
(
"
label
"
L10N
.
getStr
(
"
networkMenu
.
empty
"
)
)
;
this
.
userInputTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
tooltip
=
new
HTMLTooltip
(
NetMonitorController
.
_toolbox
.
doc
{
type
:
"
arrow
"
}
)
;
this
.
tooltip
.
startTogglingOnHover
(
widgetParentEl
this
.
_onHover
{
toggleDelay
:
REQUESTS_TOOLTIP_TOGGLE_DELAY
interactive
:
true
}
)
;
(
"
#
requests
-
menu
-
contents
"
)
.
addEventListener
(
"
scroll
"
this
.
_onScroll
true
)
;
Prefs
.
filters
.
forEach
(
type
=
>
this
.
filterOn
(
type
)
)
;
this
.
sortContents
(
this
.
_byTiming
)
;
this
.
allowFocusOnRightClick
=
true
;
this
.
maintainSelectionVisible
=
true
;
this
.
widget
.
addEventListener
(
"
select
"
this
.
_onSelect
false
)
;
this
.
widget
.
addEventListener
(
"
swap
"
this
.
_onSwap
false
)
;
this
.
_splitter
.
addEventListener
(
"
mousemove
"
this
.
_onResize
false
)
;
window
.
addEventListener
(
"
resize
"
this
.
_onResize
false
)
;
this
.
requestsMenuSortEvent
=
getKeyWithEvent
(
this
.
sortBy
.
bind
(
this
)
)
;
this
.
requestsMenuSortKeyboardEvent
=
getKeyWithEvent
(
this
.
sortBy
.
bind
(
this
)
true
)
;
this
.
requestsMenuFilterEvent
=
getKeyWithEvent
(
this
.
filterOn
.
bind
(
this
)
)
;
this
.
requestsMenuFilterKeyboardEvent
=
getKeyWithEvent
(
this
.
filterOn
.
bind
(
this
)
true
)
;
this
.
reqeustsMenuClearEvent
=
this
.
clear
.
bind
(
this
)
;
this
.
_onContextShowing
=
this
.
_onContextShowing
.
bind
(
this
)
;
this
.
_onContextNewTabCommand
=
this
.
openRequestInTab
.
bind
(
this
)
;
this
.
_onContextCopyUrlCommand
=
this
.
copyUrl
.
bind
(
this
)
;
this
.
_onContextCopyImageAsDataUriCommand
=
this
.
copyImageAsDataUri
.
bind
(
this
)
;
this
.
_onContextCopyResponseCommand
=
this
.
copyResponse
.
bind
(
this
)
;
this
.
_onContextResendCommand
=
this
.
cloneSelectedRequest
.
bind
(
this
)
;
this
.
_onContextToggleRawHeadersCommand
=
this
.
toggleRawHeaders
.
bind
(
this
)
;
this
.
_onContextPerfCommand
=
(
)
=
>
NetMonitorView
.
toggleFrontendMode
(
)
;
this
.
_onReloadCommand
=
(
)
=
>
NetMonitorView
.
reloadPage
(
)
;
this
.
_flushRequestsTask
=
new
DeferredTask
(
this
.
_flushRequests
REQUESTS_REFRESH_RATE
)
;
this
.
sendCustomRequestEvent
=
this
.
sendCustomRequest
.
bind
(
this
)
;
this
.
closeCustomRequestEvent
=
this
.
closeCustomRequest
.
bind
(
this
)
;
this
.
cloneSelectedRequestEvent
=
this
.
cloneSelectedRequest
.
bind
(
this
)
;
this
.
toggleRawHeadersEvent
=
this
.
toggleRawHeaders
.
bind
(
this
)
;
this
.
requestsFreetextFilterEvent
=
this
.
requestsFreetextFilterEvent
.
bind
(
this
)
;
this
.
reFilterRequests
=
this
.
reFilterRequests
.
bind
(
this
)
;
this
.
freetextFilterBox
=
(
"
#
requests
-
menu
-
filter
-
freetext
-
text
"
)
;
this
.
freetextFilterBox
.
addEventListener
(
"
input
"
this
.
requestsFreetextFilterEvent
false
)
;
this
.
freetextFilterBox
.
addEventListener
(
"
command
"
this
.
requestsFreetextFilterEvent
false
)
;
(
"
#
toolbar
-
labels
"
)
.
addEventListener
(
"
click
"
this
.
requestsMenuSortEvent
false
)
;
(
"
#
toolbar
-
labels
"
)
.
addEventListener
(
"
keydown
"
this
.
requestsMenuSortKeyboardEvent
false
)
;
(
"
#
requests
-
menu
-
filter
-
buttons
"
)
.
addEventListener
(
"
click
"
this
.
requestsMenuFilterEvent
false
)
;
(
"
#
requests
-
menu
-
filter
-
buttons
"
)
.
addEventListener
(
"
keydown
"
this
.
requestsMenuFilterKeyboardEvent
false
)
;
(
"
#
requests
-
menu
-
clear
-
button
"
)
.
addEventListener
(
"
click
"
this
.
reqeustsMenuClearEvent
false
)
;
(
"
#
network
-
request
-
popup
"
)
.
addEventListener
(
"
popupshowing
"
this
.
_onContextShowing
false
)
;
(
"
#
request
-
menu
-
context
-
newtab
"
)
.
addEventListener
(
"
command
"
this
.
_onContextNewTabCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
url
"
)
.
addEventListener
(
"
command
"
this
.
_onContextCopyUrlCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
response
"
)
.
addEventListener
(
"
command
"
this
.
_onContextCopyResponseCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
image
-
as
-
data
-
uri
"
)
.
addEventListener
(
"
command
"
this
.
_onContextCopyImageAsDataUriCommand
false
)
;
(
"
#
toggle
-
raw
-
headers
"
)
.
addEventListener
(
"
click
"
this
.
toggleRawHeadersEvent
false
)
;
window
.
once
(
"
connected
"
this
.
_onConnect
.
bind
(
this
)
)
;
}
_onConnect
:
function
(
)
{
(
"
#
requests
-
menu
-
reload
-
notice
-
button
"
)
.
addEventListener
(
"
command
"
this
.
_onReloadCommand
false
)
;
if
(
NetMonitorController
.
supportsCustomRequest
)
{
(
"
#
request
-
menu
-
context
-
resend
"
)
.
addEventListener
(
"
command
"
this
.
_onContextResendCommand
false
)
;
(
"
#
custom
-
request
-
send
-
button
"
)
.
addEventListener
(
"
click
"
this
.
sendCustomRequestEvent
false
)
;
(
"
#
custom
-
request
-
close
-
button
"
)
.
addEventListener
(
"
click
"
this
.
closeCustomRequestEvent
false
)
;
(
"
#
headers
-
summary
-
resend
"
)
.
addEventListener
(
"
click
"
this
.
cloneSelectedRequestEvent
false
)
;
}
else
{
(
"
#
request
-
menu
-
context
-
resend
"
)
.
hidden
=
true
;
(
"
#
headers
-
summary
-
resend
"
)
.
hidden
=
true
;
}
if
(
NetMonitorController
.
supportsPerfStats
)
{
(
"
#
request
-
menu
-
context
-
perf
"
)
.
addEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
requests
-
menu
-
perf
-
notice
-
button
"
)
.
addEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
requests
-
menu
-
network
-
summary
-
button
"
)
.
addEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
network
-
statistics
-
back
-
button
"
)
.
addEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
}
else
{
(
"
#
notice
-
perf
-
message
"
)
.
hidden
=
true
;
(
"
#
request
-
menu
-
context
-
perf
"
)
.
hidden
=
true
;
(
"
#
requests
-
menu
-
network
-
summary
-
button
"
)
.
hidden
=
true
;
}
if
(
!
NetMonitorController
.
supportsTransferredResponseSize
)
{
(
"
#
requests
-
menu
-
transferred
-
header
-
box
"
)
.
hidden
=
true
;
(
"
#
requests
-
menu
-
item
-
template
.
requests
-
menu
-
transferred
"
)
.
hidden
=
true
;
}
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
RequestsMenuView
"
)
;
Prefs
.
filters
=
this
.
_activeFilters
;
this
.
tooltip
.
stopTogglingOnHover
(
)
;
this
.
tooltip
.
destroy
(
)
;
(
"
#
requests
-
menu
-
contents
"
)
.
removeEventListener
(
"
scroll
"
this
.
_onScroll
true
)
;
this
.
widget
.
removeEventListener
(
"
select
"
this
.
_onSelect
false
)
;
this
.
widget
.
removeEventListener
(
"
swap
"
this
.
_onSwap
false
)
;
this
.
_splitter
.
removeEventListener
(
"
mousemove
"
this
.
_onResize
false
)
;
window
.
removeEventListener
(
"
resize
"
this
.
_onResize
false
)
;
(
"
#
toolbar
-
labels
"
)
.
removeEventListener
(
"
click
"
this
.
requestsMenuSortEvent
false
)
;
(
"
#
toolbar
-
labels
"
)
.
removeEventListener
(
"
keydown
"
this
.
requestsMenuSortKeyboardEvent
false
)
;
(
"
#
requests
-
menu
-
filter
-
buttons
"
)
.
removeEventListener
(
"
click
"
this
.
requestsMenuFilterEvent
false
)
;
(
"
#
requests
-
menu
-
filter
-
buttons
"
)
.
removeEventListener
(
"
keydown
"
this
.
requestsMenuFilterKeyboardEvent
false
)
;
(
"
#
requests
-
menu
-
clear
-
button
"
)
.
removeEventListener
(
"
click
"
this
.
reqeustsMenuClearEvent
false
)
;
this
.
freetextFilterBox
.
removeEventListener
(
"
input
"
this
.
requestsFreetextFilterEvent
false
)
;
this
.
freetextFilterBox
.
removeEventListener
(
"
command
"
this
.
requestsFreetextFilterEvent
false
)
;
this
.
userInputTimer
.
cancel
(
)
;
this
.
_flushRequestsTask
.
disarm
(
)
;
(
"
#
network
-
request
-
popup
"
)
.
removeEventListener
(
"
popupshowing
"
this
.
_onContextShowing
false
)
;
(
"
#
request
-
menu
-
context
-
newtab
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextNewTabCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
url
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextCopyUrlCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
response
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextCopyResponseCommand
false
)
;
(
"
#
request
-
menu
-
context
-
copy
-
image
-
as
-
data
-
uri
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextCopyImageAsDataUriCommand
false
)
;
(
"
#
request
-
menu
-
context
-
resend
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextResendCommand
false
)
;
(
"
#
request
-
menu
-
context
-
perf
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
requests
-
menu
-
reload
-
notice
-
button
"
)
.
removeEventListener
(
"
command
"
this
.
_onReloadCommand
false
)
;
(
"
#
requests
-
menu
-
perf
-
notice
-
button
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
requests
-
menu
-
network
-
summary
-
button
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
network
-
statistics
-
back
-
button
"
)
.
removeEventListener
(
"
command
"
this
.
_onContextPerfCommand
false
)
;
(
"
#
custom
-
request
-
send
-
button
"
)
.
removeEventListener
(
"
click
"
this
.
sendCustomRequestEvent
false
)
;
(
"
#
custom
-
request
-
close
-
button
"
)
.
removeEventListener
(
"
click
"
this
.
closeCustomRequestEvent
false
)
;
(
"
#
headers
-
summary
-
resend
"
)
.
removeEventListener
(
"
click
"
this
.
cloneSelectedRequestEvent
false
)
;
(
"
#
toggle
-
raw
-
headers
"
)
.
removeEventListener
(
"
click
"
this
.
toggleRawHeadersEvent
false
)
;
}
reset
:
function
(
)
{
this
.
empty
(
)
;
this
.
_addQueue
=
[
]
;
this
.
_updateQueue
=
[
]
;
this
.
_firstRequestStartedMillis
=
-
1
;
this
.
_lastRequestEndedMillis
=
-
1
;
}
_lazyUpdate
:
true
get
lazyUpdate
(
)
{
return
this
.
_lazyUpdate
;
}
set
lazyUpdate
(
value
)
{
this
.
_lazyUpdate
=
value
;
if
(
!
value
)
{
this
.
_flushRequests
(
)
;
}
}
addRequest
:
function
(
id
startedDateTime
method
url
isXHR
cause
fromCache
fromServiceWorker
)
{
this
.
_addQueue
.
push
(
[
id
startedDateTime
method
url
isXHR
cause
fromCache
fromServiceWorker
]
)
;
if
(
!
this
.
lazyUpdate
)
{
return
void
this
.
_flushRequests
(
)
;
}
this
.
_flushRequestsTask
.
arm
(
)
;
return
undefined
;
}
openRequestInTab
:
function
(
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
let
selected
=
this
.
selectedItem
.
attachment
;
win
.
openUILinkIn
(
selected
.
url
"
tab
"
{
relatedToCurrent
:
true
}
)
;
}
copyUrl
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
clipboardHelper
.
copyString
(
selected
.
url
)
;
}
copyUrlParams
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
params
=
NetworkHelper
.
nsIURL
(
selected
.
url
)
.
query
.
split
(
"
&
"
)
;
let
string
=
params
.
join
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
)
;
clipboardHelper
.
copyString
(
string
)
;
}
_getFormDataSections
:
Task
.
async
(
function
*
(
headers
uploadHeaders
postData
)
{
let
formDataSections
=
[
]
;
let
{
headers
:
requestHeaders
}
=
headers
;
let
{
headers
:
payloadHeaders
}
=
uploadHeaders
;
let
allHeaders
=
[
.
.
.
payloadHeaders
.
.
.
requestHeaders
]
;
let
contentTypeHeader
=
allHeaders
.
find
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
content
-
type
"
;
}
)
;
let
contentTypeLongString
=
contentTypeHeader
?
contentTypeHeader
.
value
:
"
"
;
let
contentType
=
yield
gNetwork
.
getString
(
contentTypeLongString
)
;
if
(
contentType
.
includes
(
"
x
-
www
-
form
-
urlencoded
"
)
)
{
let
postDataLongString
=
postData
.
postData
.
text
;
let
text
=
yield
gNetwork
.
getString
(
postDataLongString
)
;
for
(
let
section
of
text
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
)
{
if
(
payloadHeaders
.
every
(
header
=
>
!
section
.
startsWith
(
header
.
name
)
)
)
{
formDataSections
.
push
(
section
)
;
}
}
}
return
formDataSections
;
}
)
copyPostData
:
Task
.
async
(
function
*
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
view
=
this
;
let
formDataSections
=
yield
view
.
_getFormDataSections
(
selected
.
requestHeaders
selected
.
requestHeadersFromUploadStream
selected
.
requestPostData
)
;
let
params
=
[
]
;
formDataSections
.
forEach
(
section
=
>
{
let
paramsArray
=
NetworkHelper
.
parseQueryString
(
section
)
;
if
(
paramsArray
)
{
params
=
[
.
.
.
params
.
.
.
paramsArray
]
;
}
}
)
;
let
string
=
params
.
map
(
param
=
>
param
.
name
+
(
param
.
value
?
"
=
"
+
param
.
value
:
"
"
)
)
.
join
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
)
;
if
(
!
string
)
{
let
postData
=
selected
.
requestPostData
.
postData
.
text
;
string
=
yield
gNetwork
.
getString
(
postData
)
;
if
(
Services
.
appinfo
.
OS
!
=
=
"
WINNT
"
)
{
string
=
string
.
replace
(
/
\
r
/
g
"
"
)
;
}
}
clipboardHelper
.
copyString
(
string
)
;
}
)
copyAsCurl
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
Task
.
spawn
(
function
*
(
)
{
let
data
=
{
url
:
selected
.
url
method
:
selected
.
method
headers
:
[
]
httpVersion
:
selected
.
httpVersion
postDataText
:
null
}
;
for
(
let
{
name
value
}
of
selected
.
requestHeaders
.
headers
)
{
let
text
=
yield
gNetwork
.
getString
(
value
)
;
data
.
headers
.
push
(
{
name
:
name
value
:
text
}
)
;
}
if
(
selected
.
requestPostData
)
{
let
postData
=
selected
.
requestPostData
.
postData
.
text
;
data
.
postDataText
=
yield
gNetwork
.
getString
(
postData
)
;
}
clipboardHelper
.
copyString
(
Curl
.
generateCommand
(
data
)
)
;
}
)
;
}
copyAllAsHar
:
function
(
)
{
let
options
=
this
.
getDefaultHarOptions
(
)
;
return
HarExporter
.
copy
(
options
)
;
}
saveAllAsHar
:
function
(
)
{
let
options
=
this
.
getDefaultHarOptions
(
)
;
return
HarExporter
.
save
(
options
)
;
}
getDefaultHarOptions
:
function
(
)
{
let
form
=
NetMonitorController
.
_target
.
form
;
let
title
=
form
.
title
|
|
form
.
url
;
return
{
getString
:
gNetwork
.
getString
.
bind
(
gNetwork
)
view
:
this
items
:
NetMonitorView
.
RequestsMenu
.
items
title
:
title
}
;
}
copyRequestHeaders
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
rawHeaders
=
selected
.
requestHeaders
.
rawHeaders
.
trim
(
)
;
if
(
Services
.
appinfo
.
OS
!
=
=
"
WINNT
"
)
{
rawHeaders
=
rawHeaders
.
replace
(
/
\
r
/
g
"
"
)
;
}
clipboardHelper
.
copyString
(
rawHeaders
)
;
}
copyResponseHeaders
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
rawHeaders
=
selected
.
responseHeaders
.
rawHeaders
.
trim
(
)
;
if
(
Services
.
appinfo
.
OS
!
=
=
"
WINNT
"
)
{
rawHeaders
=
rawHeaders
.
replace
(
/
\
r
/
g
"
"
)
;
}
clipboardHelper
.
copyString
(
rawHeaders
)
;
}
copyImageAsDataUri
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
{
mimeType
text
encoding
}
=
selected
.
responseContent
.
content
;
gNetwork
.
getString
(
text
)
.
then
(
string
=
>
{
let
data
=
formDataURI
(
mimeType
encoding
string
)
;
clipboardHelper
.
copyString
(
data
)
;
}
)
;
}
copyResponse
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
text
=
selected
.
responseContent
.
content
.
text
;
gNetwork
.
getString
(
text
)
.
then
(
string
=
>
{
clipboardHelper
.
copyString
(
string
)
;
}
)
;
}
cloneSelectedRequest
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
menuView
=
this
.
_createMenuView
(
selected
.
method
selected
.
url
selected
.
cause
)
;
let
newItem
=
this
.
push
(
[
menuView
]
{
attachment
:
Object
.
create
(
selected
{
isCustom
:
{
value
:
true
}
}
)
}
)
;
this
.
selectedItem
=
newItem
;
}
sendCustomRequest
:
function
(
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
data
=
{
url
:
selected
.
url
method
:
selected
.
method
httpVersion
:
selected
.
httpVersion
}
;
if
(
selected
.
requestHeaders
)
{
data
.
headers
=
selected
.
requestHeaders
.
headers
;
}
if
(
selected
.
requestPostData
)
{
data
.
body
=
selected
.
requestPostData
.
postData
.
text
;
}
NetMonitorController
.
webConsoleClient
.
sendHTTPRequest
(
data
response
=
>
{
let
id
=
response
.
eventActor
.
actor
;
this
.
_preferredItemId
=
id
;
}
)
;
this
.
closeCustomRequest
(
)
;
}
closeCustomRequest
:
function
(
)
{
this
.
remove
(
this
.
selectedItem
)
;
NetMonitorView
.
Sidebar
.
toggle
(
false
)
;
}
toggleRawHeaders
:
function
(
)
{
let
requestTextarea
=
(
"
#
raw
-
request
-
headers
-
textarea
"
)
;
let
responseTextare
=
(
"
#
raw
-
response
-
headers
-
textarea
"
)
;
let
rawHeadersHidden
=
(
"
#
raw
-
headers
"
)
.
getAttribute
(
"
hidden
"
)
;
if
(
rawHeadersHidden
)
{
let
selected
=
this
.
selectedItem
.
attachment
;
let
selectedRequestHeaders
=
selected
.
requestHeaders
.
headers
;
let
selectedResponseHeaders
=
selected
.
responseHeaders
.
headers
;
requestTextarea
.
value
=
writeHeaderText
(
selectedRequestHeaders
)
;
responseTextare
.
value
=
writeHeaderText
(
selectedResponseHeaders
)
;
(
"
#
raw
-
headers
"
)
.
hidden
=
false
;
}
else
{
requestTextarea
.
value
=
null
;
responseTextare
.
value
=
null
;
(
"
#
raw
-
headers
"
)
.
hidden
=
true
;
}
}
requestsFreetextFilterEvent
:
function
(
)
{
this
.
userInputTimer
.
cancel
(
)
;
this
.
_currentFreetextFilter
=
this
.
freetextFilterBox
.
value
|
|
"
"
;
if
(
this
.
_currentFreetextFilter
.
length
=
=
=
0
)
{
this
.
freetextFilterBox
.
removeAttribute
(
"
filled
"
)
;
}
else
{
this
.
freetextFilterBox
.
setAttribute
(
"
filled
"
true
)
;
}
this
.
userInputTimer
.
initWithCallback
(
this
.
reFilterRequests
FREETEXT_FILTER_SEARCH_DELAY
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
reFilterRequests
:
function
(
)
{
this
.
filterContents
(
this
.
_filterPredicate
)
;
this
.
refreshSummary
(
)
;
this
.
refreshZebra
(
)
;
}
filterOn
:
function
(
type
=
"
all
"
)
{
if
(
type
=
=
=
"
all
"
)
{
if
(
this
.
_activeFilters
.
indexOf
(
"
all
"
)
!
=
=
-
1
)
{
return
;
}
this
.
_activeFilters
.
slice
(
)
.
forEach
(
this
.
_disableFilter
this
)
;
}
else
if
(
this
.
_activeFilters
.
indexOf
(
type
)
=
=
=
-
1
)
{
this
.
_enableFilter
(
type
)
;
}
else
{
this
.
_disableFilter
(
type
)
;
}
this
.
reFilterRequests
(
)
;
}
filterOnlyOn
:
function
(
type
=
"
all
"
)
{
this
.
_activeFilters
.
slice
(
)
.
forEach
(
this
.
_disableFilter
this
)
;
this
.
filterOn
(
type
)
;
}
_disableFilter
:
function
(
type
)
{
this
.
_activeFilters
.
splice
(
this
.
_activeFilters
.
indexOf
(
type
)
1
)
;
let
target
=
(
"
#
requests
-
menu
-
filter
-
"
+
type
+
"
-
button
"
)
;
target
.
removeAttribute
(
"
checked
"
)
;
if
(
this
.
_activeFilters
.
length
=
=
=
0
)
{
this
.
_enableFilter
(
"
all
"
)
;
}
}
_enableFilter
:
function
(
type
)
{
if
(
!
Object
.
keys
(
Filters
)
.
includes
(
type
)
)
{
return
;
}
this
.
_activeFilters
.
push
(
type
)
;
let
target
=
(
"
#
requests
-
menu
-
filter
-
"
+
type
+
"
-
button
"
)
;
target
.
setAttribute
(
"
checked
"
true
)
;
if
(
type
!
=
=
"
all
"
&
&
this
.
_activeFilters
.
indexOf
(
"
all
"
)
!
=
=
-
1
)
{
this
.
_disableFilter
(
"
all
"
)
;
}
}
get
_filterPredicate
(
)
{
let
currentFreetextFilter
=
this
.
_currentFreetextFilter
;
return
requestItem
=
>
{
const
{
attachment
}
=
requestItem
;
return
this
.
_activeFilters
.
some
(
filterName
=
>
Filters
[
filterName
]
(
attachment
)
)
&
&
isFreetextMatch
(
attachment
currentFreetextFilter
)
;
}
;
}
sortBy
:
function
(
type
=
"
waterfall
"
)
{
let
target
=
(
"
#
requests
-
menu
-
"
+
type
+
"
-
button
"
)
;
let
headers
=
document
.
querySelectorAll
(
"
.
requests
-
menu
-
header
-
button
"
)
;
for
(
let
header
of
headers
)
{
if
(
header
!
=
target
)
{
header
.
removeAttribute
(
"
sorted
"
)
;
header
.
removeAttribute
(
"
tooltiptext
"
)
;
header
.
parentNode
.
removeAttribute
(
"
active
"
)
;
}
}
let
direction
=
"
"
;
if
(
target
)
{
if
(
target
.
getAttribute
(
"
sorted
"
)
=
=
"
ascending
"
)
{
target
.
setAttribute
(
"
sorted
"
direction
=
"
descending
"
)
;
target
.
setAttribute
(
"
tooltiptext
"
L10N
.
getStr
(
"
networkMenu
.
sortedDesc
"
)
)
;
}
else
{
target
.
setAttribute
(
"
sorted
"
direction
=
"
ascending
"
)
;
target
.
setAttribute
(
"
tooltiptext
"
L10N
.
getStr
(
"
networkMenu
.
sortedAsc
"
)
)
;
}
target
.
parentNode
.
setAttribute
(
"
active
"
"
true
"
)
;
}
switch
(
type
)
{
case
"
status
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byStatus
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byStatus
(
a
b
)
)
;
}
break
;
case
"
method
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byMethod
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byMethod
(
a
b
)
)
;
}
break
;
case
"
file
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byFile
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byFile
(
a
b
)
)
;
}
break
;
case
"
domain
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byDomain
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byDomain
(
a
b
)
)
;
}
break
;
case
"
cause
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byCause
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byCause
(
a
b
)
)
;
}
break
;
case
"
type
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byType
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byType
(
a
b
)
)
;
}
break
;
case
"
transferred
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byTransferred
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byTransferred
(
a
b
)
)
;
}
break
;
case
"
size
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_bySize
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_bySize
(
a
b
)
)
;
}
break
;
case
"
waterfall
"
:
if
(
direction
=
=
"
ascending
"
)
{
this
.
sortContents
(
this
.
_byTiming
)
;
}
else
{
this
.
sortContents
(
(
a
b
)
=
>
!
this
.
_byTiming
(
a
b
)
)
;
}
break
;
}
this
.
refreshSummary
(
)
;
this
.
refreshZebra
(
)
;
}
clear
:
function
(
)
{
NetMonitorController
.
NetworkEventsHandler
.
clearMarkers
(
)
;
NetMonitorView
.
Sidebar
.
toggle
(
false
)
;
(
"
#
details
-
pane
-
toggle
"
)
.
disabled
=
true
;
(
"
#
requests
-
menu
-
empty
-
notice
"
)
.
hidden
=
false
;
this
.
empty
(
)
;
this
.
refreshSummary
(
)
;
}
_byTiming
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
return
first
.
startedMillis
>
second
.
startedMillis
;
}
_byStatus
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
return
first
.
status
=
=
second
.
status
?
first
.
startedMillis
>
second
.
startedMillis
:
first
.
status
>
second
.
status
;
}
_byMethod
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
return
first
.
method
=
=
second
.
method
?
first
.
startedMillis
>
second
.
startedMillis
:
first
.
method
>
second
.
method
;
}
_byFile
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
let
firstUrl
=
this
.
_getUriNameWithQuery
(
first
.
url
)
.
toLowerCase
(
)
;
let
secondUrl
=
this
.
_getUriNameWithQuery
(
second
.
url
)
.
toLowerCase
(
)
;
return
firstUrl
=
=
secondUrl
?
first
.
startedMillis
>
second
.
startedMillis
:
firstUrl
>
secondUrl
;
}
_byDomain
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
let
firstDomain
=
this
.
_getUriHostPort
(
first
.
url
)
.
toLowerCase
(
)
;
let
secondDomain
=
this
.
_getUriHostPort
(
second
.
url
)
.
toLowerCase
(
)
;
return
firstDomain
=
=
secondDomain
?
first
.
startedMillis
>
second
.
startedMillis
:
firstDomain
>
secondDomain
;
}
_byCause
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
let
firstCause
=
loadCauseString
(
first
.
cause
.
type
)
;
let
secondCause
=
loadCauseString
(
second
.
cause
.
type
)
;
return
firstCause
=
=
secondCause
?
first
.
startedMillis
>
second
.
startedMillis
:
firstCause
>
secondCause
;
}
_byType
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
let
firstType
=
this
.
_getAbbreviatedMimeType
(
first
.
mimeType
)
.
toLowerCase
(
)
;
let
secondType
=
this
.
_getAbbreviatedMimeType
(
second
.
mimeType
)
.
toLowerCase
(
)
;
return
firstType
=
=
secondType
?
first
.
startedMillis
>
second
.
startedMillis
:
firstType
>
secondType
;
}
_byTransferred
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
return
first
.
transferredSize
>
second
.
transferredSize
;
}
_bySize
:
function
(
{
attachment
:
first
}
{
attachment
:
second
}
)
{
return
first
.
contentSize
>
second
.
contentSize
;
}
refreshSummary
:
function
(
)
{
let
visibleItems
=
this
.
visibleItems
;
let
visibleRequestsCount
=
visibleItems
.
length
;
if
(
!
visibleRequestsCount
)
{
this
.
_summary
.
setAttribute
(
"
label
"
L10N
.
getStr
(
"
networkMenu
.
empty
"
)
)
;
return
;
}
let
totalBytes
=
this
.
_getTotalBytesOfRequests
(
visibleItems
)
;
let
totalMillis
=
this
.
_getNewestRequest
(
visibleItems
)
.
attachment
.
endedMillis
-
this
.
_getOldestRequest
(
visibleItems
)
.
attachment
.
startedMillis
;
let
str
=
PluralForm
.
get
(
visibleRequestsCount
L10N
.
getStr
(
"
networkMenu
.
summary
"
)
)
;
this
.
_summary
.
setAttribute
(
"
label
"
str
.
replace
(
"
#
1
"
visibleRequestsCount
)
.
replace
(
"
#
2
"
L10N
.
numberWithDecimals
(
(
totalBytes
|
|
0
)
/
1024
CONTENT_SIZE_DECIMALS
)
)
.
replace
(
"
#
3
"
L10N
.
numberWithDecimals
(
(
totalMillis
|
|
0
)
/
1000
REQUEST_TIME_DECIMALS
)
)
)
;
}
refreshZebra
:
function
(
)
{
let
visibleItems
=
this
.
visibleItems
;
for
(
let
i
=
0
len
=
visibleItems
.
length
;
i
<
len
;
i
+
+
)
{
let
requestItem
=
visibleItems
[
i
]
;
let
requestTarget
=
requestItem
.
target
;
if
(
i
%
2
=
=
0
)
{
requestTarget
.
setAttribute
(
"
even
"
"
"
)
;
requestTarget
.
removeAttribute
(
"
odd
"
)
;
}
else
{
requestTarget
.
setAttribute
(
"
odd
"
"
"
)
;
requestTarget
.
removeAttribute
(
"
even
"
)
;
}
}
}
attachSecurityIconClickListener
:
function
(
{
target
}
)
{
let
icon
=
(
"
.
requests
-
security
-
state
-
icon
"
target
)
;
icon
.
addEventListener
(
"
click
"
this
.
_onSecurityIconClick
)
;
}
updateRequest
:
function
(
id
data
callback
)
{
this
.
_updateQueue
.
push
(
[
id
data
callback
]
)
;
if
(
!
this
.
lazyUpdate
)
{
return
void
this
.
_flushRequests
(
)
;
}
this
.
_flushRequestsTask
.
arm
(
)
;
return
undefined
;
}
_flushRequests
:
function
(
)
{
if
(
NetMonitorView
.
_isDestroyed
)
{
return
;
}
let
widget
=
NetMonitorView
.
RequestsMenu
.
widget
;
let
isScrolledToBottom
=
widget
.
isScrolledToBottom
(
)
;
for
(
let
[
id
startedDateTime
method
url
isXHR
cause
fromCache
fromServiceWorker
]
of
this
.
_addQueue
)
{
let
unixTime
=
Date
.
parse
(
startedDateTime
)
;
let
menuView
=
this
.
_createMenuView
(
method
url
cause
)
;
this
.
_registerFirstRequestStart
(
unixTime
)
;
this
.
_registerLastRequestEnd
(
unixTime
)
;
let
requestItem
=
this
.
push
(
[
menuView
id
]
{
attachment
:
{
startedDeltaMillis
:
unixTime
-
this
.
_firstRequestStartedMillis
startedMillis
:
unixTime
method
:
method
url
:
url
isXHR
:
isXHR
cause
:
cause
fromCache
:
fromCache
fromServiceWorker
:
fromServiceWorker
}
}
)
;
if
(
id
=
=
this
.
_preferredItemId
)
{
this
.
selectedItem
=
requestItem
;
}
window
.
emit
(
EVENTS
.
REQUEST_ADDED
id
)
;
}
if
(
isScrolledToBottom
&
&
this
.
_addQueue
.
length
)
{
widget
.
scrollToBottom
(
)
;
}
for
(
let
[
id
data
callback
]
of
this
.
_updateQueue
)
{
let
requestItem
=
this
.
getItemByValue
(
id
)
;
if
(
!
requestItem
)
{
continue
;
}
for
(
let
key
in
data
)
{
let
val
=
data
[
key
]
;
if
(
val
=
=
=
undefined
)
{
continue
;
}
switch
(
key
)
{
case
"
requestHeaders
"
:
requestItem
.
attachment
.
requestHeaders
=
val
;
break
;
case
"
requestCookies
"
:
requestItem
.
attachment
.
requestCookies
=
val
;
break
;
case
"
requestPostData
"
:
let
currentItem
=
requestItem
;
let
currentStore
=
{
headers
:
[
]
headersSize
:
0
}
;
Task
.
spawn
(
function
*
(
)
{
let
postData
=
yield
gNetwork
.
getString
(
val
.
postData
.
text
)
;
let
payloadHeaders
=
CurlUtils
.
getHeadersFromMultipartText
(
postData
)
;
currentStore
.
headers
=
payloadHeaders
;
currentStore
.
headersSize
=
payloadHeaders
.
reduce
(
(
acc
{
name
value
}
)
=
>
acc
+
name
.
length
+
value
.
length
+
2
0
)
;
refreshNetworkDetailsPaneIfNecessary
(
currentItem
)
;
}
)
;
requestItem
.
attachment
.
requestPostData
=
val
;
requestItem
.
attachment
.
requestHeadersFromUploadStream
=
currentStore
;
break
;
case
"
securityState
"
:
requestItem
.
attachment
.
securityState
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
break
;
case
"
securityInfo
"
:
requestItem
.
attachment
.
securityInfo
=
val
;
break
;
case
"
responseHeaders
"
:
requestItem
.
attachment
.
responseHeaders
=
val
;
break
;
case
"
responseCookies
"
:
requestItem
.
attachment
.
responseCookies
=
val
;
break
;
case
"
httpVersion
"
:
requestItem
.
attachment
.
httpVersion
=
val
;
break
;
case
"
remoteAddress
"
:
requestItem
.
attachment
.
remoteAddress
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
break
;
case
"
remotePort
"
:
requestItem
.
attachment
.
remotePort
=
val
;
break
;
case
"
status
"
:
requestItem
.
attachment
.
status
=
val
;
this
.
updateMenuView
(
requestItem
key
{
status
:
val
cached
:
requestItem
.
attachment
.
fromCache
serviceWorker
:
requestItem
.
attachment
.
fromServiceWorker
}
)
;
break
;
case
"
statusText
"
:
requestItem
.
attachment
.
statusText
=
val
;
let
text
=
(
requestItem
.
attachment
.
status
+
"
"
+
requestItem
.
attachment
.
statusText
)
;
if
(
requestItem
.
attachment
.
fromCache
)
{
text
+
=
"
(
cached
)
"
;
}
else
if
(
requestItem
.
attachment
.
fromServiceWorker
)
{
text
+
=
"
(
service
worker
)
"
;
}
this
.
updateMenuView
(
requestItem
key
text
)
;
break
;
case
"
headersSize
"
:
requestItem
.
attachment
.
headersSize
=
val
;
break
;
case
"
contentSize
"
:
requestItem
.
attachment
.
contentSize
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
break
;
case
"
transferredSize
"
:
if
(
requestItem
.
attachment
.
fromCache
)
{
requestItem
.
attachment
.
transferredSize
=
0
;
this
.
updateMenuView
(
requestItem
key
"
cached
"
)
;
}
else
if
(
requestItem
.
attachment
.
fromServiceWorker
)
{
requestItem
.
attachment
.
transferredSize
=
0
;
this
.
updateMenuView
(
requestItem
key
"
service
worker
"
)
;
}
else
{
requestItem
.
attachment
.
transferredSize
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
}
break
;
case
"
mimeType
"
:
requestItem
.
attachment
.
mimeType
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
break
;
case
"
responseContent
"
:
if
(
!
requestItem
.
attachment
.
mimeType
)
{
requestItem
.
attachment
.
mimeType
=
"
text
/
plain
"
;
this
.
updateMenuView
(
requestItem
"
mimeType
"
"
text
/
plain
"
)
;
}
requestItem
.
attachment
.
responseContent
=
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
break
;
case
"
totalTime
"
:
requestItem
.
attachment
.
totalTime
=
val
;
requestItem
.
attachment
.
endedMillis
=
requestItem
.
attachment
.
startedMillis
+
val
;
this
.
updateMenuView
(
requestItem
key
val
)
;
this
.
_registerLastRequestEnd
(
requestItem
.
attachment
.
endedMillis
)
;
break
;
case
"
eventTimings
"
:
requestItem
.
attachment
.
eventTimings
=
val
;
this
.
_createWaterfallView
(
requestItem
val
.
timings
requestItem
.
attachment
.
fromCache
|
|
requestItem
.
attachment
.
fromServiceWorker
)
;
break
;
}
}
refreshNetworkDetailsPaneIfNecessary
(
requestItem
)
;
if
(
callback
)
{
callback
(
)
;
}
}
function
refreshNetworkDetailsPaneIfNecessary
(
requestItem
)
{
let
selectedItem
=
NetMonitorView
.
RequestsMenu
.
selectedItem
;
if
(
selectedItem
=
=
requestItem
)
{
NetMonitorView
.
NetworkDetails
.
populate
(
selectedItem
.
attachment
)
;
}
}
this
.
_updateQueue
=
[
]
;
this
.
_addQueue
=
[
]
;
(
"
#
details
-
pane
-
toggle
"
)
.
disabled
=
!
this
.
itemCount
;
(
"
#
requests
-
menu
-
empty
-
notice
"
)
.
hidden
=
!
!
this
.
itemCount
;
this
.
sortContents
(
)
;
this
.
filterContents
(
)
;
this
.
refreshSummary
(
)
;
this
.
refreshZebra
(
)
;
this
.
_flushWaterfallViews
(
)
;
}
_createMenuView
:
function
(
method
url
cause
)
{
let
template
=
(
"
#
requests
-
menu
-
item
-
template
"
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
node
of
template
.
childNodes
)
{
fragment
.
appendChild
(
node
.
cloneNode
(
true
)
)
;
}
this
.
updateMenuView
(
fragment
"
method
"
method
)
;
this
.
updateMenuView
(
fragment
"
url
"
url
)
;
this
.
updateMenuView
(
fragment
"
cause
"
cause
)
;
return
fragment
;
}
getFormattedSize
(
bytes
)
{
if
(
bytes
<
MAX_BYTES_SIZE
)
{
return
L10N
.
getFormatStr
(
"
networkMenu
.
sizeB
"
bytes
)
;
}
else
if
(
bytes
<
MAX_KB_SIZE
)
{
let
kb
=
bytes
/
BYTES_IN_KB
;
let
size
=
L10N
.
numberWithDecimals
(
kb
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
networkMenu
.
sizeKB
"
size
)
;
}
else
if
(
bytes
<
MAX_MB_SIZE
)
{
let
mb
=
bytes
/
BYTES_IN_MB
;
let
size
=
L10N
.
numberWithDecimals
(
mb
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
networkMenu
.
sizeMB
"
size
)
;
}
let
gb
=
bytes
/
BYTES_IN_GB
;
let
size
=
L10N
.
numberWithDecimals
(
gb
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
networkMenu
.
sizeGB
"
size
)
;
}
updateMenuView
:
Task
.
async
(
function
*
(
item
key
value
)
{
let
target
=
item
.
target
|
|
item
;
switch
(
key
)
{
case
"
method
"
:
{
let
node
=
(
"
.
requests
-
menu
-
method
"
target
)
;
node
.
setAttribute
(
"
value
"
value
)
;
break
;
}
case
"
url
"
:
{
let
uri
;
try
{
uri
=
NetworkHelper
.
nsIURL
(
value
)
;
}
catch
(
e
)
{
break
;
}
let
nameWithQuery
=
this
.
_getUriNameWithQuery
(
uri
)
;
let
hostPort
=
this
.
_getUriHostPort
(
uri
)
;
let
host
=
this
.
_getUriHost
(
uri
)
;
let
unicodeUrl
=
NetworkHelper
.
convertToUnicode
(
unescape
(
uri
.
spec
)
)
;
let
file
=
(
"
.
requests
-
menu
-
file
"
target
)
;
file
.
setAttribute
(
"
value
"
nameWithQuery
)
;
file
.
setAttribute
(
"
tooltiptext
"
unicodeUrl
)
;
let
domain
=
(
"
.
requests
-
menu
-
domain
"
target
)
;
domain
.
setAttribute
(
"
value
"
hostPort
)
;
domain
.
setAttribute
(
"
tooltiptext
"
hostPort
)
;
let
icon
=
(
"
.
requests
-
security
-
state
-
icon
"
target
)
;
icon
.
classList
.
remove
(
"
security
-
state
-
local
"
)
;
if
(
host
.
match
(
/
(
.
+
\
.
)
?
localhost
/
)
|
|
host
.
match
(
/
^
127
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
/
)
|
|
host
.
match
(
/
\
[
[
0
:
]
+
1
\
]
/
)
)
{
let
tooltip
=
L10N
.
getStr
(
"
netmonitor
.
security
.
state
.
secure
"
)
;
icon
.
classList
.
add
(
"
security
-
state
-
local
"
)
;
icon
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
}
break
;
}
case
"
remoteAddress
"
:
let
domain
=
(
"
.
requests
-
menu
-
domain
"
target
)
;
let
tooltip
=
(
domain
.
getAttribute
(
"
value
"
)
+
(
value
?
"
(
"
+
value
+
"
)
"
:
"
"
)
)
;
domain
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
break
;
case
"
securityState
"
:
{
let
icon
=
(
"
.
requests
-
security
-
state
-
icon
"
target
)
;
this
.
attachSecurityIconClickListener
(
item
)
;
if
(
icon
.
classList
.
contains
(
"
security
-
state
-
local
"
)
)
{
break
;
}
let
tooltip2
=
L10N
.
getStr
(
"
netmonitor
.
security
.
state
.
"
+
value
)
;
icon
.
classList
.
add
(
"
security
-
state
-
"
+
value
)
;
icon
.
setAttribute
(
"
tooltiptext
"
tooltip2
)
;
break
;
}
case
"
status
"
:
{
let
node
=
(
"
.
requests
-
menu
-
status
-
icon
"
target
)
;
let
code
;
if
(
value
.
cached
)
{
code
=
"
cached
"
;
}
else
if
(
value
.
serviceWorker
)
{
code
=
"
service
worker
"
;
}
else
{
code
=
value
.
status
;
}
node
.
setAttribute
(
"
code
"
code
)
;
let
codeNode
=
(
"
.
requests
-
menu
-
status
-
code
"
target
)
;
codeNode
.
setAttribute
(
"
value
"
value
.
status
)
;
break
;
}
case
"
statusText
"
:
{
let
node
=
(
"
.
requests
-
menu
-
status
"
target
)
;
node
.
setAttribute
(
"
tooltiptext
"
value
)
;
break
;
}
case
"
cause
"
:
{
let
labelNode
=
(
"
.
requests
-
menu
-
cause
-
label
"
target
)
;
labelNode
.
setAttribute
(
"
value
"
loadCauseString
(
value
.
type
)
)
;
if
(
value
.
loadingDocumentUri
)
{
labelNode
.
setAttribute
(
"
tooltiptext
"
value
.
loadingDocumentUri
)
;
}
let
stackNode
=
(
"
.
requests
-
menu
-
cause
-
stack
"
target
)
;
if
(
value
.
stacktrace
&
&
value
.
stacktrace
.
length
>
0
)
{
stackNode
.
removeAttribute
(
"
hidden
"
)
;
}
break
;
}
case
"
contentSize
"
:
{
let
node
=
(
"
.
requests
-
menu
-
size
"
target
)
;
let
text
=
this
.
getFormattedSize
(
value
)
;
node
.
setAttribute
(
"
value
"
text
)
;
node
.
setAttribute
(
"
tooltiptext
"
text
)
;
break
;
}
case
"
transferredSize
"
:
{
let
node
=
(
"
.
requests
-
menu
-
transferred
"
target
)
;
let
text
;
if
(
value
=
=
=
null
)
{
text
=
L10N
.
getStr
(
"
networkMenu
.
sizeUnavailable
"
)
;
}
else
if
(
value
=
=
=
"
cached
"
)
{
text
=
L10N
.
getStr
(
"
networkMenu
.
sizeCached
"
)
;
node
.
classList
.
add
(
"
theme
-
comment
"
)
;
}
else
if
(
value
=
=
=
"
service
worker
"
)
{
text
=
L10N
.
getStr
(
"
networkMenu
.
sizeServiceWorker
"
)
;
node
.
classList
.
add
(
"
theme
-
comment
"
)
;
}
else
{
text
=
this
.
getFormattedSize
(
value
)
;
}
node
.
setAttribute
(
"
value
"
text
)
;
node
.
setAttribute
(
"
tooltiptext
"
text
)
;
break
;
}
case
"
mimeType
"
:
{
let
type
=
this
.
_getAbbreviatedMimeType
(
value
)
;
let
node
=
(
"
.
requests
-
menu
-
type
"
target
)
;
let
text
=
CONTENT_MIME_TYPE_ABBREVIATIONS
[
type
]
|
|
type
;
node
.
setAttribute
(
"
value
"
text
)
;
node
.
setAttribute
(
"
tooltiptext
"
value
)
;
break
;
}
case
"
responseContent
"
:
{
let
{
mimeType
}
=
item
.
attachment
;
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
let
{
text
encoding
}
=
value
.
content
;
let
responseBody
=
yield
gNetwork
.
getString
(
text
)
;
let
node
=
(
"
.
requests
-
menu
-
icon
"
item
.
target
)
;
node
.
src
=
formDataURI
(
mimeType
encoding
responseBody
)
;
node
.
setAttribute
(
"
type
"
"
thumbnail
"
)
;
node
.
removeAttribute
(
"
hidden
"
)
;
window
.
emit
(
EVENTS
.
RESPONSE_IMAGE_THUMBNAIL_DISPLAYED
)
;
}
break
;
}
case
"
totalTime
"
:
{
let
node
=
(
"
.
requests
-
menu
-
timings
-
total
"
target
)
;
let
text
=
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
value
)
;
node
.
setAttribute
(
"
value
"
text
)
;
node
.
setAttribute
(
"
tooltiptext
"
text
)
;
break
;
}
}
}
)
_createWaterfallView
:
function
(
item
timings
fromCache
)
{
let
{
target
}
=
item
;
let
sections
=
[
"
blocked
"
"
dns
"
"
connect
"
"
send
"
"
wait
"
"
receive
"
]
;
let
timingsNode
=
(
"
.
requests
-
menu
-
timings
"
target
)
;
let
timingsTotal
=
(
"
.
requests
-
menu
-
timings
-
total
"
timingsNode
)
;
if
(
fromCache
)
{
timingsTotal
.
style
.
display
=
"
none
"
;
return
;
}
for
(
let
key
of
sections
)
{
let
width
=
timings
[
key
]
;
if
(
width
>
0
)
{
let
timingBox
=
document
.
createElement
(
"
hbox
"
)
;
timingBox
.
className
=
"
requests
-
menu
-
timings
-
box
"
+
key
;
timingBox
.
setAttribute
(
"
width
"
width
)
;
timingsNode
.
insertBefore
(
timingBox
timingsTotal
)
;
}
}
}
_flushWaterfallViews
:
function
(
reset
)
{
if
(
NetMonitorView
.
currentFrontendMode
!
=
"
network
-
inspector
-
view
"
|
|
!
this
.
itemCount
)
{
return
;
}
if
(
reset
)
{
this
.
_cachedWaterfallWidth
=
0
;
}
let
availableWidth
=
this
.
_waterfallWidth
-
REQUESTS_WATERFALL_SAFE_BOUNDS
;
let
longestWidth
=
this
.
_lastRequestEndedMillis
-
this
.
_firstRequestStartedMillis
;
let
scale
=
Math
.
min
(
Math
.
max
(
availableWidth
/
longestWidth
EPSILON
)
1
)
;
this
.
_showWaterfallDivisionLabels
(
scale
)
;
this
.
_drawWaterfallBackground
(
scale
)
;
for
(
let
{
target
attachment
}
of
this
)
{
let
timingsNode
=
(
"
.
requests
-
menu
-
timings
"
target
)
;
let
totalNode
=
(
"
.
requests
-
menu
-
timings
-
total
"
target
)
;
let
direction
=
window
.
isRTL
?
-
1
:
1
;
let
translateX
=
"
translateX
(
"
+
(
direction
*
attachment
.
startedDeltaMillis
)
+
"
px
)
"
;
let
scaleX
=
"
scaleX
(
"
+
scale
+
"
)
"
;
let
revScaleX
=
"
scaleX
(
"
+
(
1
/
scale
)
+
"
)
"
;
timingsNode
.
style
.
transform
=
scaleX
+
"
"
+
translateX
;
totalNode
.
style
.
transform
=
revScaleX
;
}
}
_showWaterfallDivisionLabels
:
function
(
scale
)
{
let
container
=
(
"
#
requests
-
menu
-
waterfall
-
label
-
wrapper
"
)
;
let
availableWidth
=
this
.
_waterfallWidth
-
REQUESTS_WATERFALL_SAFE_BOUNDS
;
while
(
container
.
hasChildNodes
(
)
)
{
container
.
firstChild
.
remove
(
)
;
}
let
timingStep
=
REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE
;
let
optimalTickIntervalFound
=
false
;
while
(
!
optimalTickIntervalFound
)
{
let
scaledStep
=
scale
*
timingStep
;
if
(
scaledStep
<
REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN
)
{
timingStep
<
<
=
1
;
continue
;
}
optimalTickIntervalFound
=
true
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
let
direction
=
window
.
isRTL
?
-
1
:
1
;
for
(
let
x
=
0
;
x
<
availableWidth
;
x
+
=
scaledStep
)
{
let
translateX
=
"
translateX
(
"
+
(
(
direction
*
x
)
|
0
)
+
"
px
)
"
;
let
millisecondTime
=
x
/
scale
;
let
normalizedTime
=
millisecondTime
;
let
divisionScale
=
"
millisecond
"
;
if
(
normalizedTime
>
60000
)
{
normalizedTime
/
=
60000
;
divisionScale
=
"
minute
"
;
}
else
if
(
normalizedTime
>
1000
)
{
normalizedTime
/
=
1000
;
divisionScale
=
"
second
"
;
}
if
(
divisionScale
=
=
"
millisecond
"
)
{
normalizedTime
|
=
0
;
}
else
{
normalizedTime
=
L10N
.
numberWithDecimals
(
normalizedTime
REQUEST_TIME_DECIMALS
)
;
}
let
node
=
document
.
createElement
(
"
label
"
)
;
let
text
=
L10N
.
getFormatStr
(
"
networkMenu
.
"
+
divisionScale
normalizedTime
)
;
node
.
className
=
"
plain
requests
-
menu
-
timings
-
division
"
;
node
.
setAttribute
(
"
division
-
scale
"
divisionScale
)
;
node
.
style
.
transform
=
translateX
;
node
.
setAttribute
(
"
value
"
text
)
;
fragment
.
appendChild
(
node
)
;
}
container
.
appendChild
(
fragment
)
;
container
.
className
=
"
requests
-
menu
-
waterfall
-
visible
"
;
}
}
_drawWaterfallBackground
:
function
(
scale
)
{
if
(
!
this
.
_canvas
|
|
!
this
.
_ctx
)
{
this
.
_canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
this
.
_ctx
=
this
.
_canvas
.
getContext
(
"
2d
"
)
;
}
let
canvas
=
this
.
_canvas
;
let
ctx
=
this
.
_ctx
;
let
canvasWidth
=
canvas
.
width
=
this
.
_waterfallWidth
;
let
canvasHeight
=
canvas
.
height
=
1
;
let
imageData
=
ctx
.
createImageData
(
canvasWidth
canvasHeight
)
;
let
pixelArray
=
imageData
.
data
;
let
buf
=
new
ArrayBuffer
(
pixelArray
.
length
)
;
let
view8bit
=
new
Uint8ClampedArray
(
buf
)
;
let
view32bit
=
new
Uint32Array
(
buf
)
;
let
timingStep
=
REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE
;
let
[
r
g
b
]
=
REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB
;
let
alphaComponent
=
REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN
;
let
optimalTickIntervalFound
=
false
;
while
(
!
optimalTickIntervalFound
)
{
let
scaledStep
=
scale
*
timingStep
;
if
(
scaledStep
<
REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN
)
{
timingStep
<
<
=
1
;
continue
;
}
optimalTickIntervalFound
=
true
;
for
(
let
i
=
1
;
i
<
=
REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES
;
i
+
+
)
{
let
increment
=
scaledStep
*
Math
.
pow
(
2
i
)
;
for
(
let
x
=
0
;
x
<
canvasWidth
;
x
+
=
increment
)
{
let
position
=
(
window
.
isRTL
?
canvasWidth
-
x
:
x
)
|
0
;
view32bit
[
position
]
=
(
alphaComponent
<
<
24
)
|
(
b
<
<
16
)
|
(
g
<
<
8
)
|
r
;
}
alphaComponent
+
=
REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD
;
}
}
{
let
t
=
NetMonitorController
.
NetworkEventsHandler
.
firstDocumentDOMContentLoadedTimestamp
;
let
delta
=
Math
.
floor
(
(
t
-
this
.
_firstRequestStartedMillis
)
*
scale
)
;
let
[
r1
g1
b1
a1
]
=
REQUESTS_WATERFALL_DOMCONTENTLOADED_TICKS_COLOR_RGBA
;
view32bit
[
delta
]
=
(
a1
<
<
24
)
|
(
r1
<
<
16
)
|
(
g1
<
<
8
)
|
b1
;
}
{
let
t
=
NetMonitorController
.
NetworkEventsHandler
.
firstDocumentLoadTimestamp
;
let
delta
=
Math
.
floor
(
(
t
-
this
.
_firstRequestStartedMillis
)
*
scale
)
;
let
[
r2
g2
b2
a2
]
=
REQUESTS_WATERFALL_LOAD_TICKS_COLOR_RGBA
;
view32bit
[
delta
]
=
(
a2
<
<
24
)
|
(
r2
<
<
16
)
|
(
g2
<
<
8
)
|
b2
;
}
pixelArray
.
set
(
view8bit
)
;
ctx
.
putImageData
(
imageData
0
0
)
;
document
.
mozSetImageElement
(
"
waterfall
-
background
"
canvas
)
;
}
_onSelect
:
function
(
{
detail
:
item
}
)
{
if
(
item
)
{
NetMonitorView
.
Sidebar
.
populate
(
item
.
attachment
)
;
NetMonitorView
.
Sidebar
.
toggle
(
true
)
;
}
else
{
NetMonitorView
.
Sidebar
.
toggle
(
false
)
;
}
}
_onSwap
:
function
(
{
detail
:
[
firstItem
secondItem
]
}
)
{
this
.
attachSecurityIconClickListener
(
firstItem
)
;
this
.
attachSecurityIconClickListener
(
secondItem
)
;
}
_onHover
:
Task
.
async
(
function
*
(
target
tooltip
)
{
let
requestItem
=
this
.
getItemForElement
(
target
)
;
if
(
!
requestItem
)
{
return
false
;
}
let
hovered
=
requestItem
.
attachment
;
if
(
hovered
.
responseContent
&
&
target
.
closest
(
"
.
requests
-
menu
-
icon
-
and
-
file
"
)
)
{
return
this
.
_setTooltipImageContent
(
tooltip
requestItem
)
;
}
else
if
(
hovered
.
cause
&
&
target
.
closest
(
"
.
requests
-
menu
-
cause
-
stack
"
)
)
{
return
this
.
_setTooltipStackTraceContent
(
tooltip
requestItem
)
;
}
return
false
;
}
)
_setTooltipImageContent
:
Task
.
async
(
function
*
(
tooltip
requestItem
)
{
let
{
mimeType
text
encoding
}
=
requestItem
.
attachment
.
responseContent
.
content
;
if
(
!
mimeType
|
|
!
mimeType
.
includes
(
"
image
/
"
)
)
{
return
false
;
}
let
string
=
yield
gNetwork
.
getString
(
text
)
;
let
src
=
formDataURI
(
mimeType
encoding
string
)
;
let
maxDim
=
REQUESTS_TOOLTIP_IMAGE_MAX_DIM
;
let
{
naturalWidth
naturalHeight
}
=
yield
getImageDimensions
(
tooltip
.
doc
src
)
;
let
options
=
{
maxDim
naturalWidth
naturalHeight
}
;
setImageTooltip
(
tooltip
tooltip
.
doc
src
options
)
;
return
(
"
.
requests
-
menu
-
icon
"
requestItem
.
target
)
;
}
)
_setTooltipStackTraceContent
:
Task
.
async
(
function
*
(
tooltip
requestItem
)
{
let
{
stacktrace
}
=
requestItem
.
attachment
.
cause
;
if
(
!
stacktrace
|
|
stacktrace
.
length
=
=
0
)
{
return
false
;
}
let
doc
=
tooltip
.
doc
;
let
el
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
el
.
className
=
"
stack
-
trace
-
tooltip
devtools
-
monospace
"
;
for
(
let
f
of
stacktrace
)
{
let
{
functionName
filename
lineNumber
columnNumber
asyncCause
}
=
f
;
if
(
asyncCause
)
{
let
asyncFrameEl
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
asyncFrameEl
.
className
=
"
stack
-
frame
stack
-
frame
-
async
"
;
asyncFrameEl
.
textContent
=
WEBCONSOLE_L10N
.
getFormatStr
(
"
stacktrace
.
asyncStack
"
asyncCause
)
;
el
.
appendChild
(
asyncFrameEl
)
;
}
let
sourceUrl
=
filename
.
split
(
"
-
>
"
)
.
pop
(
)
;
let
frameEl
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
frameEl
.
className
=
"
stack
-
frame
stack
-
frame
-
call
"
;
let
funcEl
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
funcEl
.
className
=
"
stack
-
frame
-
function
-
name
"
;
funcEl
.
textContent
=
functionName
|
|
WEBCONSOLE_L10N
.
getStr
(
"
stacktrace
.
anonymousFunction
"
)
;
frameEl
.
appendChild
(
funcEl
)
;
let
sourceEl
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
sourceEl
.
className
=
"
stack
-
frame
-
source
-
name
"
;
frameEl
.
appendChild
(
sourceEl
)
;
let
sourceInnerEl
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
sourceInnerEl
.
className
=
"
stack
-
frame
-
source
-
name
-
inner
"
;
sourceEl
.
appendChild
(
sourceInnerEl
)
;
sourceInnerEl
.
textContent
=
sourceUrl
;
sourceInnerEl
.
title
=
sourceUrl
;
let
lineEl
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
lineEl
.
className
=
"
stack
-
frame
-
line
"
;
lineEl
.
textContent
=
:
{
lineNumber
}
:
{
columnNumber
}
;
sourceInnerEl
.
appendChild
(
lineEl
)
;
frameEl
.
addEventListener
(
"
click
"
(
)
=
>
{
tooltip
.
hide
(
)
;
NetMonitorController
.
viewSourceInDebugger
(
filename
lineNumber
)
;
}
false
)
;
el
.
appendChild
(
frameEl
)
;
}
tooltip
.
setContent
(
el
{
width
:
REQUESTS_TOOLTIP_STACK_TRACE_WIDTH
}
)
;
return
true
;
}
)
_onSecurityIconClick
:
function
(
e
)
{
let
state
=
this
.
selectedItem
.
attachment
.
securityState
;
if
(
state
!
=
=
"
insecure
"
)
{
NetMonitorView
.
NetworkDetails
.
widget
.
selectedIndex
=
5
;
}
}
_onResize
:
function
(
e
)
{
setNamedTimeout
(
"
resize
-
events
"
RESIZE_REFRESH_RATE
(
)
=
>
this
.
_flushWaterfallViews
(
true
)
)
;
}
_onScroll
:
function
(
)
{
this
.
tooltip
.
hide
(
)
;
}
_onContextShowing
:
function
(
)
{
let
selectedItem
=
this
.
selectedItem
;
let
resendElement
=
(
"
#
request
-
menu
-
context
-
resend
"
)
;
resendElement
.
hidden
=
!
NetMonitorController
.
supportsCustomRequest
|
|
!
selectedItem
|
|
selectedItem
.
attachment
.
isCustom
;
let
copyUrlElement
=
(
"
#
request
-
menu
-
context
-
copy
-
url
"
)
;
copyUrlElement
.
hidden
=
!
selectedItem
;
let
copyUrlParamsElement
=
(
"
#
request
-
menu
-
context
-
copy
-
url
-
params
"
)
;
copyUrlParamsElement
.
hidden
=
!
selectedItem
|
|
!
NetworkHelper
.
nsIURL
(
selectedItem
.
attachment
.
url
)
.
query
;
let
copyPostDataElement
=
(
"
#
request
-
menu
-
context
-
copy
-
post
-
data
"
)
;
copyPostDataElement
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
.
requestPostData
;
let
copyAsCurlElement
=
(
"
#
request
-
menu
-
context
-
copy
-
as
-
curl
"
)
;
copyAsCurlElement
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
;
let
copyRequestHeadersElement
=
(
"
#
request
-
menu
-
context
-
copy
-
request
-
headers
"
)
;
copyRequestHeadersElement
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
.
requestHeaders
;
let
copyResponseHeadersElement
=
(
"
#
response
-
menu
-
context
-
copy
-
response
-
headers
"
)
;
copyResponseHeadersElement
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
.
responseHeaders
;
let
copyResponse
=
(
"
#
request
-
menu
-
context
-
copy
-
response
"
)
;
copyResponse
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
.
responseContent
|
|
!
selectedItem
.
attachment
.
responseContent
.
content
.
text
|
|
selectedItem
.
attachment
.
responseContent
.
content
.
text
.
length
=
=
=
0
;
let
copyImageAsDataUriElement
=
(
"
#
request
-
menu
-
context
-
copy
-
image
-
as
-
data
-
uri
"
)
;
copyImageAsDataUriElement
.
hidden
=
!
selectedItem
|
|
!
selectedItem
.
attachment
.
responseContent
|
|
!
selectedItem
.
attachment
.
responseContent
.
content
.
mimeType
.
includes
(
"
image
/
"
)
;
let
separators
=
all
(
"
.
request
-
menu
-
context
-
separator
"
)
;
Array
.
forEach
(
separators
separator
=
>
{
separator
.
hidden
=
!
selectedItem
;
}
)
;
let
copyAsHar
=
(
"
#
request
-
menu
-
context
-
copy
-
all
-
as
-
har
"
)
;
copyAsHar
.
hidden
=
!
NetMonitorView
.
RequestsMenu
.
items
.
length
;
let
saveAsHar
=
(
"
#
request
-
menu
-
context
-
save
-
all
-
as
-
har
"
)
;
saveAsHar
.
hidden
=
!
NetMonitorView
.
RequestsMenu
.
items
.
length
;
let
newTabElement
=
(
"
#
request
-
menu
-
context
-
newtab
"
)
;
newTabElement
.
hidden
=
!
selectedItem
;
}
_registerFirstRequestStart
:
function
(
unixTime
)
{
if
(
this
.
_firstRequestStartedMillis
=
=
-
1
)
{
this
.
_firstRequestStartedMillis
=
unixTime
;
}
}
_registerLastRequestEnd
:
function
(
unixTime
)
{
if
(
this
.
_lastRequestEndedMillis
<
unixTime
)
{
this
.
_lastRequestEndedMillis
=
unixTime
;
}
}
_getUriNameWithQuery
:
function
(
url
)
{
if
(
!
(
url
instanceof
Ci
.
nsIURL
)
)
{
url
=
NetworkHelper
.
nsIURL
(
url
)
;
}
let
name
=
NetworkHelper
.
convertToUnicode
(
unescape
(
url
.
fileName
|
|
url
.
filePath
|
|
"
/
"
)
)
;
let
query
=
NetworkHelper
.
convertToUnicode
(
unescape
(
url
.
query
)
)
;
return
name
+
(
query
?
"
?
"
+
query
:
"
"
)
;
}
_getUriHostPort
:
function
(
url
)
{
if
(
!
(
url
instanceof
Ci
.
nsIURL
)
)
{
url
=
NetworkHelper
.
nsIURL
(
url
)
;
}
return
NetworkHelper
.
convertToUnicode
(
unescape
(
url
.
hostPort
)
)
;
}
_getUriHost
:
function
(
url
)
{
return
this
.
_getUriHostPort
(
url
)
.
replace
(
/
:
\
d
+
/
"
"
)
;
}
_getAbbreviatedMimeType
:
function
(
mimeType
)
{
if
(
!
mimeType
)
{
return
"
"
;
}
return
(
mimeType
.
split
(
"
;
"
)
[
0
]
.
split
(
"
/
"
)
[
1
]
|
|
"
"
)
.
split
(
"
+
"
)
[
0
]
;
}
_getTotalBytesOfRequests
:
function
(
itemsArray
)
{
if
(
!
itemsArray
.
length
)
{
return
0
;
}
let
result
=
0
;
itemsArray
.
forEach
(
item
=
>
{
let
size
=
item
.
attachment
.
contentSize
;
result
+
=
(
typeof
size
=
=
"
number
"
)
?
size
:
0
;
}
)
;
return
result
;
}
_getOldestRequest
:
function
(
itemsArray
)
{
if
(
!
itemsArray
.
length
)
{
return
null
;
}
return
itemsArray
.
reduce
(
(
prev
curr
)
=
>
prev
.
attachment
.
startedMillis
<
curr
.
attachment
.
startedMillis
?
prev
:
curr
)
;
}
_getNewestRequest
:
function
(
itemsArray
)
{
if
(
!
itemsArray
.
length
)
{
return
null
;
}
return
itemsArray
.
reduce
(
(
prev
curr
)
=
>
prev
.
attachment
.
startedMillis
>
curr
.
attachment
.
startedMillis
?
prev
:
curr
)
;
}
get
_waterfallWidth
(
)
{
if
(
this
.
_cachedWaterfallWidth
=
=
0
)
{
let
container
=
(
"
#
requests
-
menu
-
toolbar
"
)
;
let
waterfall
=
(
"
#
requests
-
menu
-
waterfall
-
header
-
box
"
)
;
let
containerBounds
=
container
.
getBoundingClientRect
(
)
;
let
waterfallBounds
=
waterfall
.
getBoundingClientRect
(
)
;
if
(
!
window
.
isRTL
)
{
this
.
_cachedWaterfallWidth
=
containerBounds
.
width
-
waterfallBounds
.
left
;
}
else
{
this
.
_cachedWaterfallWidth
=
waterfallBounds
.
right
;
}
}
return
this
.
_cachedWaterfallWidth
;
}
_splitter
:
null
_summary
:
null
_canvas
:
null
_ctx
:
null
_cachedWaterfallWidth
:
0
_firstRequestStartedMillis
:
-
1
_lastRequestEndedMillis
:
-
1
_updateQueue
:
[
]
_addQueue
:
[
]
_updateTimeout
:
null
_resizeTimeout
:
null
_activeFilters
:
[
"
all
"
]
_currentFreetextFilter
:
"
"
}
)
;
function
SidebarView
(
)
{
dumpn
(
"
SidebarView
was
instantiated
"
)
;
}
SidebarView
.
prototype
=
{
toggle
:
function
(
visibleFlag
)
{
NetMonitorView
.
toggleDetailsPane
(
{
visible
:
visibleFlag
}
)
;
NetMonitorView
.
RequestsMenu
.
_flushWaterfallViews
(
true
)
;
}
populate
:
Task
.
async
(
function
*
(
data
)
{
let
isCustom
=
data
.
isCustom
;
let
view
=
isCustom
?
NetMonitorView
.
CustomRequest
:
NetMonitorView
.
NetworkDetails
;
yield
view
.
populate
(
data
)
;
(
"
#
details
-
pane
"
)
.
selectedIndex
=
isCustom
?
0
:
1
;
window
.
emit
(
EVENTS
.
SIDEBAR_POPULATED
)
;
}
)
}
;
function
CustomRequestView
(
)
{
dumpn
(
"
CustomRequestView
was
instantiated
"
)
;
}
CustomRequestView
.
prototype
=
{
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
CustomRequestView
"
)
;
this
.
updateCustomRequestEvent
=
getKeyWithEvent
(
this
.
onUpdate
.
bind
(
this
)
)
;
(
"
#
custom
-
pane
"
)
.
addEventListener
(
"
input
"
this
.
updateCustomRequestEvent
false
)
;
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
CustomRequestView
"
)
;
(
"
#
custom
-
pane
"
)
.
removeEventListener
(
"
input
"
this
.
updateCustomRequestEvent
false
)
;
}
populate
:
Task
.
async
(
function
*
(
data
)
{
(
"
#
custom
-
url
-
value
"
)
.
value
=
data
.
url
;
(
"
#
custom
-
method
-
value
"
)
.
value
=
data
.
method
;
this
.
updateCustomQuery
(
data
.
url
)
;
if
(
data
.
requestHeaders
)
{
let
headers
=
data
.
requestHeaders
.
headers
;
(
"
#
custom
-
headers
-
value
"
)
.
value
=
writeHeaderText
(
headers
)
;
}
if
(
data
.
requestPostData
)
{
let
postData
=
data
.
requestPostData
.
postData
.
text
;
(
"
#
custom
-
postdata
-
value
"
)
.
value
=
yield
gNetwork
.
getString
(
postData
)
;
}
window
.
emit
(
EVENTS
.
CUSTOMREQUESTVIEW_POPULATED
)
;
}
)
onUpdate
:
function
(
field
)
{
let
selectedItem
=
NetMonitorView
.
RequestsMenu
.
selectedItem
;
let
value
;
switch
(
field
)
{
case
"
method
"
:
value
=
(
"
#
custom
-
method
-
value
"
)
.
value
.
trim
(
)
;
selectedItem
.
attachment
.
method
=
value
;
break
;
case
"
url
"
:
value
=
(
"
#
custom
-
url
-
value
"
)
.
value
;
this
.
updateCustomQuery
(
value
)
;
selectedItem
.
attachment
.
url
=
value
;
break
;
case
"
query
"
:
let
query
=
(
"
#
custom
-
query
-
value
"
)
.
value
;
this
.
updateCustomUrl
(
query
)
;
field
=
"
url
"
;
value
=
(
"
#
custom
-
url
-
value
"
)
.
value
;
selectedItem
.
attachment
.
url
=
value
;
break
;
case
"
body
"
:
value
=
(
"
#
custom
-
postdata
-
value
"
)
.
value
;
selectedItem
.
attachment
.
requestPostData
=
{
postData
:
{
text
:
value
}
}
;
break
;
case
"
headers
"
:
let
headersText
=
(
"
#
custom
-
headers
-
value
"
)
.
value
;
value
=
parseHeadersText
(
headersText
)
;
selectedItem
.
attachment
.
requestHeaders
=
{
headers
:
value
}
;
break
;
}
NetMonitorView
.
RequestsMenu
.
updateMenuView
(
selectedItem
field
value
)
;
}
updateCustomQuery
:
function
(
url
)
{
let
paramsArray
=
NetworkHelper
.
parseQueryString
(
NetworkHelper
.
nsIURL
(
url
)
.
query
)
;
if
(
!
paramsArray
)
{
(
"
#
custom
-
query
"
)
.
hidden
=
true
;
return
;
}
(
"
#
custom
-
query
"
)
.
hidden
=
false
;
(
"
#
custom
-
query
-
value
"
)
.
value
=
writeQueryText
(
paramsArray
)
;
}
updateCustomUrl
:
function
(
queryText
)
{
let
params
=
parseQueryText
(
queryText
)
;
let
queryString
=
writeQueryString
(
params
)
;
let
url
=
(
"
#
custom
-
url
-
value
"
)
.
value
;
let
oldQuery
=
NetworkHelper
.
nsIURL
(
url
)
.
query
;
let
path
=
url
.
replace
(
oldQuery
queryString
)
;
(
"
#
custom
-
url
-
value
"
)
.
value
=
path
;
}
}
;
function
NetworkDetailsView
(
)
{
dumpn
(
"
NetworkDetailsView
was
instantiated
"
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_onTabSelect
=
this
.
_onTabSelect
.
bind
(
this
)
;
}
NetworkDetailsView
.
prototype
=
{
_viewState
:
{
updating
:
[
]
dirty
:
[
]
latestData
:
null
}
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
NetworkDetailsView
"
)
;
this
.
widget
=
(
"
#
event
-
details
-
pane
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
this
.
widget
this
"
netmonitor
"
{
disableTelemetry
:
true
showAllTabsMenu
:
true
}
)
;
this
.
_headers
=
new
VariablesView
(
(
"
#
all
-
headers
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
headersEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
headersFilterText
"
)
}
)
)
;
this
.
_cookies
=
new
VariablesView
(
(
"
#
all
-
cookies
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
cookiesEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
cookiesFilterText
"
)
}
)
)
;
this
.
_params
=
new
VariablesView
(
(
"
#
request
-
params
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
paramsEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
paramsFilterText
"
)
}
)
)
;
this
.
_json
=
new
VariablesView
(
(
"
#
response
-
content
-
json
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
onlyEnumVisible
:
true
searchPlaceholder
:
L10N
.
getStr
(
"
jsonFilterText
"
)
}
)
)
;
VariablesViewController
.
attach
(
this
.
_json
)
;
this
.
_paramsQueryString
=
L10N
.
getStr
(
"
paramsQueryString
"
)
;
this
.
_paramsFormData
=
L10N
.
getStr
(
"
paramsFormData
"
)
;
this
.
_paramsPostPayload
=
L10N
.
getStr
(
"
paramsPostPayload
"
)
;
this
.
_requestHeaders
=
L10N
.
getStr
(
"
requestHeaders
"
)
;
this
.
_requestHeadersFromUpload
=
L10N
.
getStr
(
"
requestHeadersFromUpload
"
)
;
this
.
_responseHeaders
=
L10N
.
getStr
(
"
responseHeaders
"
)
;
this
.
_requestCookies
=
L10N
.
getStr
(
"
requestCookies
"
)
;
this
.
_responseCookies
=
L10N
.
getStr
(
"
responseCookies
"
)
;
(
"
tabpanels
"
this
.
widget
)
.
addEventListener
(
"
select
"
this
.
_onTabSelect
)
;
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
NetworkDetailsView
"
)
;
this
.
sidebar
.
destroy
(
)
;
(
"
tabpanels
"
this
.
widget
)
.
removeEventListener
(
"
select
"
this
.
_onTabSelect
)
;
}
populate
:
function
(
data
)
{
(
"
#
request
-
params
-
box
"
)
.
setAttribute
(
"
flex
"
"
1
"
)
;
(
"
#
request
-
params
-
box
"
)
.
hidden
=
false
;
(
"
#
request
-
post
-
data
-
textarea
-
box
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
info
-
header
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
json
-
box
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
true
;
(
"
#
raw
-
headers
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
image
-
box
"
)
.
hidden
=
true
;
let
isHtml
=
Filters
.
html
(
data
)
;
this
.
sidebar
.
toggleTab
(
isHtml
"
preview
-
tab
"
)
;
let
hasSecurityInfo
=
data
.
securityState
&
&
data
.
securityState
!
=
=
"
insecure
"
;
this
.
sidebar
.
toggleTab
(
hasSecurityInfo
"
security
-
tab
"
)
;
if
(
!
isHtml
&
&
this
.
widget
.
selectedPanel
=
=
=
(
"
#
preview
-
tabpanel
"
)
|
|
!
hasSecurityInfo
&
&
this
.
widget
.
selectedPanel
=
=
=
(
"
#
security
-
tabpanel
"
)
)
{
this
.
widget
.
selectedIndex
=
0
;
}
this
.
_headers
.
empty
(
)
;
this
.
_cookies
.
empty
(
)
;
this
.
_params
.
empty
(
)
;
this
.
_json
.
empty
(
)
;
this
.
_dataSrc
=
{
src
:
data
populated
:
[
]
}
;
this
.
_onTabSelect
(
)
;
window
.
emit
(
EVENTS
.
NETWORKDETAILSVIEW_POPULATED
)
;
return
promise
.
resolve
(
)
;
}
_onTabSelect
:
function
(
)
{
let
{
src
populated
}
=
this
.
_dataSrc
|
|
{
}
;
let
tab
=
this
.
widget
.
selectedIndex
;
let
view
=
this
;
if
(
!
src
|
|
populated
[
tab
]
)
{
return
;
}
let
viewState
=
this
.
_viewState
;
if
(
viewState
.
updating
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
true
;
viewState
.
latestData
=
src
;
return
;
}
Task
.
spawn
(
function
*
(
)
{
viewState
.
updating
[
tab
]
=
true
;
switch
(
tab
)
{
case
0
:
yield
view
.
_setSummary
(
src
)
;
yield
view
.
_setResponseHeaders
(
src
.
responseHeaders
)
;
yield
view
.
_setRequestHeaders
(
src
.
requestHeaders
src
.
requestHeadersFromUploadStream
)
;
break
;
case
1
:
yield
view
.
_setResponseCookies
(
src
.
responseCookies
)
;
yield
view
.
_setRequestCookies
(
src
.
requestCookies
)
;
break
;
case
2
:
yield
view
.
_setRequestGetParams
(
src
.
url
)
;
yield
view
.
_setRequestPostParams
(
src
.
requestHeaders
src
.
requestHeadersFromUploadStream
src
.
requestPostData
)
;
break
;
case
3
:
yield
view
.
_setResponseBody
(
src
.
url
src
.
responseContent
)
;
break
;
case
4
:
yield
view
.
_setTimingsInformation
(
src
.
eventTimings
)
;
break
;
case
5
:
yield
view
.
_setSecurityInfo
(
src
.
securityInfo
src
.
url
)
;
break
;
case
6
:
yield
view
.
_setHtmlPreview
(
src
.
responseContent
)
;
break
;
}
viewState
.
updating
[
tab
]
=
false
;
}
)
.
then
(
(
)
=
>
{
if
(
tab
=
=
this
.
widget
.
selectedIndex
)
{
if
(
viewState
.
dirty
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
false
;
view
.
populate
(
viewState
.
latestData
)
;
}
else
{
populated
[
tab
]
=
true
;
window
.
emit
(
EVENTS
.
TAB_UPDATED
)
;
if
(
NetMonitorController
.
isConnected
(
)
)
{
NetMonitorView
.
RequestsMenu
.
ensureSelectedItemIsVisible
(
)
;
}
}
}
else
if
(
viewState
.
dirty
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
false
;
}
}
e
=
>
console
.
error
(
e
)
)
;
}
_setSummary
:
function
(
data
)
{
if
(
data
.
url
)
{
let
unicodeUrl
=
NetworkHelper
.
convertToUnicode
(
unescape
(
data
.
url
)
)
;
(
"
#
headers
-
summary
-
url
-
value
"
)
.
setAttribute
(
"
value
"
unicodeUrl
)
;
(
"
#
headers
-
summary
-
url
-
value
"
)
.
setAttribute
(
"
tooltiptext
"
unicodeUrl
)
;
(
"
#
headers
-
summary
-
url
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
url
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
method
)
{
(
"
#
headers
-
summary
-
method
-
value
"
)
.
setAttribute
(
"
value
"
data
.
method
)
;
(
"
#
headers
-
summary
-
method
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
method
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
remoteAddress
)
{
let
address
=
data
.
remoteAddress
;
if
(
address
.
indexOf
(
"
:
"
)
!
=
-
1
)
{
address
=
[
{
address
}
]
;
}
if
(
data
.
remotePort
)
{
address
+
=
:
{
data
.
remotePort
}
;
}
(
"
#
headers
-
summary
-
address
-
value
"
)
.
setAttribute
(
"
value
"
address
)
;
(
"
#
headers
-
summary
-
address
-
value
"
)
.
setAttribute
(
"
tooltiptext
"
address
)
;
(
"
#
headers
-
summary
-
address
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
address
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
status
)
{
let
code
;
if
(
data
.
fromCache
)
{
code
=
"
cached
"
;
}
else
if
(
data
.
fromServiceWorker
)
{
code
=
"
service
worker
"
;
}
else
{
code
=
data
.
status
;
}
(
"
#
headers
-
summary
-
status
-
circle
"
)
.
setAttribute
(
"
code
"
code
)
;
(
"
#
headers
-
summary
-
status
-
value
"
)
.
setAttribute
(
"
value
"
data
.
status
+
"
"
+
data
.
statusText
)
;
(
"
#
headers
-
summary
-
status
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
status
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
httpVersion
)
{
(
"
#
headers
-
summary
-
version
-
value
"
)
.
setAttribute
(
"
value
"
data
.
httpVersion
)
;
(
"
#
headers
-
summary
-
version
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
version
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_setRequestHeaders
:
Task
.
async
(
function
*
(
headers
uploadHeaders
)
{
if
(
headers
&
&
headers
.
headers
.
length
)
{
yield
this
.
_addHeaders
(
this
.
_requestHeaders
headers
)
;
}
if
(
uploadHeaders
&
&
uploadHeaders
.
headers
.
length
)
{
yield
this
.
_addHeaders
(
this
.
_requestHeadersFromUpload
uploadHeaders
)
;
}
}
)
_setResponseHeaders
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
headers
.
length
)
{
response
.
headers
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
yield
this
.
_addHeaders
(
this
.
_responseHeaders
response
)
;
}
}
)
_addHeaders
:
Task
.
async
(
function
*
(
name
response
)
{
let
kb
=
response
.
headersSize
/
1024
;
let
size
=
L10N
.
numberWithDecimals
(
kb
HEADERS_SIZE_DECIMALS
)
;
let
text
=
L10N
.
getFormatStr
(
"
networkMenu
.
sizeKB
"
size
)
;
let
headersScope
=
this
.
_headers
.
addScope
(
name
+
"
(
"
+
text
+
"
)
"
)
;
headersScope
.
expanded
=
true
;
for
(
let
header
of
response
.
headers
)
{
let
headerVar
=
headersScope
.
addItem
(
header
.
name
{
}
{
relaxed
:
true
}
)
;
let
headerValue
=
yield
gNetwork
.
getString
(
header
.
value
)
;
headerVar
.
setGrip
(
headerValue
)
;
}
}
)
_setRequestCookies
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
cookies
.
length
)
{
response
.
cookies
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
yield
this
.
_addCookies
(
this
.
_requestCookies
response
)
;
}
}
)
_setResponseCookies
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
cookies
.
length
)
{
yield
this
.
_addCookies
(
this
.
_responseCookies
response
)
;
}
}
)
_addCookies
:
Task
.
async
(
function
*
(
name
response
)
{
let
cookiesScope
=
this
.
_cookies
.
addScope
(
name
)
;
cookiesScope
.
expanded
=
true
;
for
(
let
cookie
of
response
.
cookies
)
{
let
cookieVar
=
cookiesScope
.
addItem
(
cookie
.
name
{
}
{
relaxed
:
true
}
)
;
let
cookieValue
=
yield
gNetwork
.
getString
(
cookie
.
value
)
;
cookieVar
.
setGrip
(
cookieValue
)
;
let
cookieProps
=
Object
.
keys
(
cookie
)
;
if
(
cookieProps
.
length
=
=
2
)
{
continue
;
}
let
rawObject
=
Object
.
create
(
null
)
;
let
otherProps
=
cookieProps
.
filter
(
e
=
>
e
!
=
"
name
"
&
&
e
!
=
"
value
"
)
;
for
(
let
prop
of
otherProps
)
{
rawObject
[
prop
]
=
cookie
[
prop
]
;
}
cookieVar
.
populate
(
rawObject
)
;
cookieVar
.
twisty
=
true
;
cookieVar
.
expanded
=
true
;
}
}
)
_setRequestGetParams
:
function
(
url
)
{
let
query
=
NetworkHelper
.
nsIURL
(
url
)
.
query
;
if
(
query
)
{
this
.
_addParams
(
this
.
_paramsQueryString
query
)
;
}
}
_setRequestPostParams
:
Task
.
async
(
function
*
(
headers
uploadHeaders
postData
)
{
if
(
!
headers
|
|
!
uploadHeaders
|
|
!
postData
)
{
return
;
}
let
formDataSections
=
yield
RequestsMenuView
.
prototype
.
_getFormDataSections
(
headers
uploadHeaders
postData
)
;
this
.
_params
.
onlyEnumVisible
=
false
;
if
(
formDataSections
.
length
>
0
)
{
formDataSections
.
forEach
(
section
=
>
{
this
.
_addParams
(
this
.
_paramsFormData
section
)
;
}
)
;
}
else
{
let
postDataLongString
=
postData
.
postData
.
text
;
let
text
=
yield
gNetwork
.
getString
(
postDataLongString
)
;
let
jsonVal
=
null
;
try
{
jsonVal
=
JSON
.
parse
(
text
)
;
}
catch
(
ex
)
{
}
if
(
jsonVal
)
{
this
.
_params
.
onlyEnumVisible
=
true
;
let
jsonScopeName
=
L10N
.
getStr
(
"
jsonScopeName
"
)
;
let
jsonScope
=
this
.
_params
.
addScope
(
jsonScopeName
)
;
jsonScope
.
expanded
=
true
;
let
jsonItem
=
jsonScope
.
addItem
(
"
"
{
enumerable
:
true
}
)
;
jsonItem
.
populate
(
jsonVal
{
sorted
:
true
}
)
;
}
else
{
(
"
#
request
-
params
-
box
"
)
.
removeAttribute
(
"
flex
"
)
;
let
paramsScope
=
this
.
_params
.
addScope
(
this
.
_paramsPostPayload
)
;
paramsScope
.
expanded
=
true
;
paramsScope
.
locked
=
true
;
(
"
#
request
-
post
-
data
-
textarea
-
box
"
)
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
request
-
post
-
data
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
text
)
;
editor
.
setText
(
text
)
;
}
}
window
.
emit
(
EVENTS
.
REQUEST_POST_PARAMS_DISPLAYED
)
;
}
)
_addParams
:
function
(
name
queryString
)
{
let
paramsArray
=
NetworkHelper
.
parseQueryString
(
queryString
)
;
if
(
!
paramsArray
)
{
return
;
}
let
paramsScope
=
this
.
_params
.
addScope
(
name
)
;
paramsScope
.
expanded
=
true
;
for
(
let
param
of
paramsArray
)
{
let
paramVar
=
paramsScope
.
addItem
(
param
.
name
{
}
{
relaxed
:
true
}
)
;
paramVar
.
setGrip
(
param
.
value
)
;
}
}
_setResponseBody
:
Task
.
async
(
function
*
(
url
response
)
{
if
(
!
response
)
{
return
;
}
let
{
mimeType
text
encoding
}
=
response
.
content
;
let
responseBody
=
yield
gNetwork
.
getString
(
text
)
;
let
jsonMimeType
jsonObject
jsonObjectParseError
;
try
{
jsonMimeType
=
/
\
bjson
/
.
test
(
mimeType
)
;
jsonObject
=
JSON
.
parse
(
responseBody
)
;
}
catch
(
e
)
{
jsonObjectParseError
=
e
;
}
if
(
jsonMimeType
|
|
jsonObject
)
{
let
jsonpRegex
=
/
^
\
s
*
(
[
\
w
]
+
)
\
s
*
\
(
\
s
*
(
[
^
]
*
)
\
s
*
\
)
\
s
*
;
?
\
s
*
/
;
let
[
_
callbackPadding
jsonpString
]
=
responseBody
.
match
(
jsonpRegex
)
|
|
[
]
;
if
(
callbackPadding
&
&
jsonpString
)
{
try
{
jsonObject
=
JSON
.
parse
(
jsonpString
)
;
}
catch
(
e
)
{
jsonObjectParseError
=
e
;
}
}
if
(
jsonObject
)
{
(
"
#
response
-
content
-
json
-
box
"
)
.
hidden
=
false
;
let
jsonScopeName
=
callbackPadding
?
L10N
.
getFormatStr
(
"
jsonpScopeName
"
callbackPadding
)
:
L10N
.
getStr
(
"
jsonScopeName
"
)
;
let
jsonVar
=
{
label
:
jsonScopeName
rawObject
:
jsonObject
}
;
yield
this
.
_json
.
controller
.
setSingleVariable
(
jsonVar
)
.
expanded
;
}
else
{
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
false
;
let
infoHeader
=
(
"
#
response
-
content
-
info
-
header
"
)
;
infoHeader
.
setAttribute
(
"
value
"
jsonObjectParseError
)
;
infoHeader
.
setAttribute
(
"
tooltiptext
"
jsonObjectParseError
)
;
infoHeader
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
response
-
content
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
js
)
;
editor
.
setText
(
responseBody
)
;
}
}
else
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
(
"
#
response
-
content
-
image
-
box
"
)
.
setAttribute
(
"
align
"
"
center
"
)
;
(
"
#
response
-
content
-
image
-
box
"
)
.
setAttribute
(
"
pack
"
"
center
"
)
;
(
"
#
response
-
content
-
image
-
box
"
)
.
hidden
=
false
;
(
"
#
response
-
content
-
image
"
)
.
src
=
formDataURI
(
mimeType
encoding
responseBody
)
;
(
"
#
response
-
content
-
image
-
name
-
value
"
)
.
setAttribute
(
"
value
"
NetworkHelper
.
nsIURL
(
url
)
.
fileName
)
;
(
"
#
response
-
content
-
image
-
mime
-
value
"
)
.
setAttribute
(
"
value
"
mimeType
)
;
(
"
#
response
-
content
-
image
"
)
.
onload
=
e
=
>
{
let
{
width
height
}
=
e
.
target
.
getBoundingClientRect
(
)
;
let
dimensions
=
(
width
-
2
)
+
"
\
u00D7
"
+
(
height
-
2
)
;
(
"
#
response
-
content
-
image
-
dimensions
-
value
"
)
.
setAttribute
(
"
value
"
dimensions
)
;
}
;
}
else
{
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
response
-
content
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
text
)
;
editor
.
setText
(
responseBody
)
;
if
(
responseBody
.
length
<
SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE
)
{
let
mapping
=
Object
.
keys
(
CONTENT_MIME_TYPE_MAPPINGS
)
.
find
(
key
=
>
{
return
mimeType
.
includes
(
key
)
;
}
)
;
if
(
mapping
)
{
editor
.
setMode
(
CONTENT_MIME_TYPE_MAPPINGS
[
mapping
]
)
;
}
}
}
window
.
emit
(
EVENTS
.
RESPONSE_BODY_DISPLAYED
)
;
}
)
_setTimingsInformation
:
function
(
response
)
{
if
(
!
response
)
{
return
;
}
let
{
blocked
dns
connect
send
wait
receive
}
=
response
.
timings
;
let
tabboxWidth
=
(
"
#
details
-
pane
"
)
.
getAttribute
(
"
width
"
)
;
let
availableWidth
=
tabboxWidth
/
2
;
let
scale
=
(
response
.
totalTime
>
0
?
Math
.
max
(
availableWidth
/
response
.
totalTime
0
)
:
0
)
;
(
"
#
timings
-
summary
-
blocked
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
blocked
*
scale
)
;
(
"
#
timings
-
summary
-
blocked
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
blocked
)
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
dns
*
scale
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
dns
)
)
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
connect
*
scale
)
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
connect
)
)
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
send
*
scale
)
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
send
)
)
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
wait
*
scale
)
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
wait
)
)
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
receive
*
scale
)
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
receive
)
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
blocked
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
+
wait
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
blocked
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
+
wait
)
)
+
"
px
)
"
;
}
_setHtmlPreview
:
Task
.
async
(
function
*
(
response
)
{
if
(
!
response
)
{
return
promise
.
resolve
(
)
;
}
let
{
text
}
=
response
.
content
;
let
responseBody
=
yield
gNetwork
.
getString
(
text
)
;
let
iframe
=
(
"
#
response
-
preview
"
)
;
iframe
.
contentDocument
.
docShell
.
allowJavascript
=
false
;
iframe
.
contentDocument
.
documentElement
.
innerHTML
=
responseBody
;
window
.
emit
(
EVENTS
.
RESPONSE_HTML_PREVIEW_DISPLAYED
)
;
return
undefined
;
}
)
_setSecurityInfo
:
Task
.
async
(
function
*
(
securityInfo
url
)
{
if
(
!
securityInfo
)
{
return
;
}
function
setValue
(
selector
value
)
{
let
label
=
(
selector
)
;
if
(
!
value
)
{
label
.
setAttribute
(
"
value
"
L10N
.
getStr
(
"
netmonitor
.
security
.
notAvailable
"
)
)
;
label
.
setAttribute
(
"
tooltiptext
"
label
.
getAttribute
(
"
value
"
)
)
;
}
else
{
label
.
setAttribute
(
"
value
"
value
)
;
label
.
setAttribute
(
"
tooltiptext
"
value
)
;
}
}
let
errorbox
=
(
"
#
security
-
error
"
)
;
let
infobox
=
(
"
#
security
-
information
"
)
;
if
(
securityInfo
.
state
=
=
=
"
secure
"
|
|
securityInfo
.
state
=
=
=
"
weak
"
)
{
infobox
.
hidden
=
false
;
errorbox
.
hidden
=
true
;
let
cipher
=
(
"
#
security
-
warning
-
cipher
"
)
;
if
(
securityInfo
.
state
=
=
=
"
weak
"
)
{
cipher
.
hidden
=
securityInfo
.
weaknessReasons
.
indexOf
(
"
cipher
"
)
=
=
=
-
1
;
}
else
{
cipher
.
hidden
=
true
;
}
let
enabledLabel
=
L10N
.
getStr
(
"
netmonitor
.
security
.
enabled
"
)
;
let
disabledLabel
=
L10N
.
getStr
(
"
netmonitor
.
security
.
disabled
"
)
;
setValue
(
"
#
security
-
protocol
-
version
-
value
"
securityInfo
.
protocolVersion
)
;
setValue
(
"
#
security
-
ciphersuite
-
value
"
securityInfo
.
cipherSuite
)
;
let
domain
=
NetMonitorView
.
RequestsMenu
.
_getUriHostPort
(
url
)
;
let
hostHeader
=
L10N
.
getFormatStr
(
"
netmonitor
.
security
.
hostHeader
"
domain
)
;
setValue
(
"
#
security
-
info
-
host
-
header
"
hostHeader
)
;
setValue
(
"
#
security
-
http
-
strict
-
transport
-
security
-
value
"
securityInfo
.
hsts
?
enabledLabel
:
disabledLabel
)
;
setValue
(
"
#
security
-
public
-
key
-
pinning
-
value
"
securityInfo
.
hpkp
?
enabledLabel
:
disabledLabel
)
;
let
cert
=
securityInfo
.
cert
;
setValue
(
"
#
security
-
cert
-
subject
-
cn
"
cert
.
subject
.
commonName
)
;
setValue
(
"
#
security
-
cert
-
subject
-
o
"
cert
.
subject
.
organization
)
;
setValue
(
"
#
security
-
cert
-
subject
-
ou
"
cert
.
subject
.
organizationalUnit
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
cn
"
cert
.
issuer
.
commonName
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
o
"
cert
.
issuer
.
organization
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
ou
"
cert
.
issuer
.
organizationalUnit
)
;
setValue
(
"
#
security
-
cert
-
validity
-
begins
"
cert
.
validity
.
start
)
;
setValue
(
"
#
security
-
cert
-
validity
-
expires
"
cert
.
validity
.
end
)
;
setValue
(
"
#
security
-
cert
-
sha1
-
fingerprint
"
cert
.
fingerprint
.
sha1
)
;
setValue
(
"
#
security
-
cert
-
sha256
-
fingerprint
"
cert
.
fingerprint
.
sha256
)
;
}
else
{
infobox
.
hidden
=
true
;
errorbox
.
hidden
=
false
;
let
plain
=
new
DOMParser
(
)
.
parseFromString
(
securityInfo
.
errorMessage
"
text
/
html
"
)
;
setValue
(
"
#
security
-
error
-
message
"
plain
.
body
.
textContent
)
;
}
}
)
_dataSrc
:
null
_headers
:
null
_cookies
:
null
_params
:
null
_json
:
null
_paramsQueryString
:
"
"
_paramsFormData
:
"
"
_paramsPostPayload
:
"
"
_requestHeaders
:
"
"
_responseHeaders
:
"
"
_requestCookies
:
"
"
_responseCookies
:
"
"
}
;
function
PerformanceStatisticsView
(
)
{
}
PerformanceStatisticsView
.
prototype
=
{
displayPlaceholderCharts
:
function
(
)
{
this
.
_createChart
(
{
id
:
"
#
primed
-
cache
-
chart
"
title
:
"
charts
.
cacheEnabled
"
}
)
;
this
.
_createChart
(
{
id
:
"
#
empty
-
cache
-
chart
"
title
:
"
charts
.
cacheDisabled
"
}
)
;
window
.
emit
(
EVENTS
.
PLACEHOLDER_CHARTS_DISPLAYED
)
;
}
createPrimedCacheChart
:
function
(
items
)
{
this
.
_createChart
(
{
id
:
"
#
primed
-
cache
-
chart
"
title
:
"
charts
.
cacheEnabled
"
data
:
this
.
_sanitizeChartDataSource
(
items
)
strings
:
this
.
_commonChartStrings
totals
:
this
.
_commonChartTotals
sorted
:
true
}
)
;
window
.
emit
(
EVENTS
.
PRIMED_CACHE_CHART_DISPLAYED
)
;
}
createEmptyCacheChart
:
function
(
items
)
{
this
.
_createChart
(
{
id
:
"
#
empty
-
cache
-
chart
"
title
:
"
charts
.
cacheDisabled
"
data
:
this
.
_sanitizeChartDataSource
(
items
true
)
strings
:
this
.
_commonChartStrings
totals
:
this
.
_commonChartTotals
sorted
:
true
}
)
;
window
.
emit
(
EVENTS
.
EMPTY_CACHE_CHART_DISPLAYED
)
;
}
_commonChartStrings
:
{
size
:
value
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
value
/
1024
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
sizeKB
"
string
)
;
}
time
:
value
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
value
/
1000
REQUEST_TIME_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
totalS
"
string
)
;
}
}
_commonChartTotals
:
{
size
:
total
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
total
/
1024
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
totalSize
"
string
)
;
}
time
:
total
=
>
{
let
seconds
=
total
/
1000
;
let
string
=
L10N
.
numberWithDecimals
(
seconds
REQUEST_TIME_DECIMALS
)
;
return
PluralForm
.
get
(
seconds
L10N
.
getStr
(
"
charts
.
totalSeconds
"
)
)
.
replace
(
"
#
1
"
string
)
;
}
cached
:
total
=
>
{
return
L10N
.
getFormatStr
(
"
charts
.
totalCached
"
total
)
;
}
count
:
total
=
>
{
return
L10N
.
getFormatStr
(
"
charts
.
totalCount
"
total
)
;
}
}
_createChart
:
function
(
{
id
title
data
strings
totals
sorted
}
)
{
let
container
=
(
id
)
;
while
(
container
.
hasChildNodes
(
)
)
{
container
.
firstChild
.
remove
(
)
;
}
let
chart
=
Chart
.
PieTable
(
document
{
diameter
:
NETWORK_ANALYSIS_PIE_CHART_DIAMETER
title
:
L10N
.
getStr
(
title
)
data
:
data
strings
:
strings
totals
:
totals
sorted
:
sorted
}
)
;
chart
.
on
(
"
click
"
(
_
item
)
=
>
{
NetMonitorView
.
RequestsMenu
.
filterOnlyOn
(
item
.
label
)
;
NetMonitorView
.
showNetworkInspectorView
(
)
;
}
)
;
container
.
appendChild
(
chart
.
node
)
;
}
_sanitizeChartDataSource
:
function
(
items
emptyCache
)
{
let
data
=
[
"
html
"
"
css
"
"
js
"
"
xhr
"
"
fonts
"
"
images
"
"
media
"
"
flash
"
"
ws
"
"
other
"
]
.
map
(
e
=
>
(
{
cached
:
0
count
:
0
label
:
e
size
:
0
time
:
0
}
)
)
;
for
(
let
requestItem
of
items
)
{
let
details
=
requestItem
.
attachment
;
let
type
;
if
(
Filters
.
html
(
details
)
)
{
type
=
0
;
}
else
if
(
Filters
.
css
(
details
)
)
{
type
=
1
;
}
else
if
(
Filters
.
js
(
details
)
)
{
type
=
2
;
}
else
if
(
Filters
.
fonts
(
details
)
)
{
type
=
4
;
}
else
if
(
Filters
.
images
(
details
)
)
{
type
=
5
;
}
else
if
(
Filters
.
media
(
details
)
)
{
type
=
6
;
}
else
if
(
Filters
.
flash
(
details
)
)
{
type
=
7
;
}
else
if
(
Filters
.
ws
(
details
)
)
{
type
=
8
;
}
else
if
(
Filters
.
xhr
(
details
)
)
{
type
=
3
;
}
else
{
type
=
9
;
}
if
(
emptyCache
|
|
!
responseIsFresh
(
details
)
)
{
data
[
type
]
.
time
+
=
details
.
totalTime
|
|
0
;
data
[
type
]
.
size
+
=
details
.
contentSize
|
|
0
;
}
else
{
data
[
type
]
.
cached
+
+
;
}
data
[
type
]
.
count
+
+
;
}
return
data
.
filter
(
e
=
>
e
.
count
>
0
)
;
}
}
;
var
=
(
selector
target
=
document
)
=
>
target
.
querySelector
(
selector
)
;
var
all
=
(
selector
target
=
document
)
=
>
target
.
querySelectorAll
(
selector
)
;
function
parseHeadersText
(
text
)
{
return
parseRequestText
(
text
"
\
\
S
+
?
"
"
:
"
)
;
}
function
parseQueryText
(
text
)
{
return
parseRequestText
(
text
"
.
+
?
"
"
=
"
)
;
}
function
parseRequestText
(
text
namereg
divider
)
{
let
regex
=
new
RegExp
(
"
(
"
+
namereg
+
"
)
\
\
"
+
divider
+
"
\
\
s
*
(
.
+
)
"
)
;
let
pairs
=
[
]
;
for
(
let
line
of
text
.
split
(
"
\
n
"
)
)
{
let
matches
;
if
(
matches
=
regex
.
exec
(
line
)
)
{
let
[
name
value
]
=
matches
;
pairs
.
push
(
{
name
:
name
value
:
value
}
)
;
}
}
return
pairs
;
}
function
writeHeaderText
(
headers
)
{
return
headers
.
map
(
(
{
name
value
}
)
=
>
name
+
"
:
"
+
value
)
.
join
(
"
\
n
"
)
;
}
function
writeQueryText
(
params
)
{
return
params
.
map
(
(
{
name
value
}
)
=
>
name
+
"
=
"
+
value
)
.
join
(
"
\
n
"
)
;
}
function
writeQueryString
(
params
)
{
return
params
.
map
(
(
{
name
value
}
)
=
>
name
+
"
=
"
+
value
)
.
join
(
"
&
"
)
;
}
function
responseIsFresh
(
{
responseHeaders
status
}
)
{
if
(
status
!
=
304
|
|
!
responseHeaders
)
{
return
false
;
}
let
list
=
responseHeaders
.
headers
;
let
cacheControl
=
list
.
filter
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
cache
-
control
"
;
}
)
[
0
]
;
let
expires
=
list
.
filter
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
"
expires
"
)
[
0
]
;
if
(
cacheControl
)
{
let
maxAgeMatch
=
cacheControl
.
value
.
match
(
/
s
-
maxage
\
s
*
=
\
s
*
(
\
d
+
)
/
)
|
|
cacheControl
.
value
.
match
(
/
max
-
age
\
s
*
=
\
s
*
(
\
d
+
)
/
)
;
if
(
maxAgeMatch
&
&
maxAgeMatch
.
pop
(
)
>
0
)
{
return
true
;
}
}
if
(
expires
&
&
Date
.
parse
(
expires
.
value
)
)
{
return
true
;
}
return
false
;
}
function
getKeyWithEvent
(
callback
onlySpaceOrReturn
)
{
return
function
(
event
)
{
let
key
=
event
.
target
.
getAttribute
(
"
data
-
key
"
)
;
let
filterKeyboardEvent
=
onlySpaceOrReturn
?
ViewHelpers
.
isSpaceOrReturn
(
event
)
:
true
;
if
(
key
&
&
filterKeyboardEvent
)
{
callback
.
call
(
null
key
)
;
}
}
;
}
function
formDataURI
(
mimeType
encoding
text
)
{
if
(
!
encoding
)
{
encoding
=
"
base64
"
;
text
=
btoa
(
text
)
;
}
return
"
data
:
"
+
mimeType
+
"
;
"
+
encoding
+
"
"
+
text
;
}
function
whenDataAvailable
(
dataStore
mandatoryFields
)
{
let
deferred
=
promise
.
defer
(
)
;
let
interval
=
setInterval
(
(
)
=
>
{
if
(
dataStore
.
every
(
item
=
>
{
return
mandatoryFields
.
every
(
field
=
>
field
in
item
)
;
}
)
)
{
clearInterval
(
interval
)
;
clearTimeout
(
timer
)
;
deferred
.
resolve
(
)
;
}
}
WDA_DEFAULT_VERIFY_INTERVAL
)
;
let
timer
=
setTimeout
(
(
)
=
>
{
clearInterval
(
interval
)
;
deferred
.
reject
(
new
Error
(
"
Timed
out
while
waiting
for
data
"
)
)
;
}
WDA_DEFAULT_GIVE_UP_TIMEOUT
)
;
return
deferred
.
promise
;
}
NetMonitorView
.
Toolbar
=
new
ToolbarView
(
)
;
NetMonitorView
.
RequestsMenu
=
new
RequestsMenuView
(
)
;
NetMonitorView
.
Sidebar
=
new
SidebarView
(
)
;
NetMonitorView
.
CustomRequest
=
new
CustomRequestView
(
)
;
NetMonitorView
.
NetworkDetails
=
new
NetworkDetailsView
(
)
;
NetMonitorView
.
PerformanceStatistics
=
new
PerformanceStatisticsView
(
)
;
