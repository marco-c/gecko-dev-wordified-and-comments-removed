"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
Class
}
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
resolve
}
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
loader
.
lazyRequireGetter
(
this
"
HarCollector
"
"
devtools
/
client
/
netmonitor
/
har
/
har
-
collector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HarExporter
"
"
devtools
/
client
/
netmonitor
/
har
/
har
-
exporter
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HarUtils
"
"
devtools
/
client
/
netmonitor
/
har
/
har
-
utils
"
true
)
;
const
prefDomain
=
"
devtools
.
netmonitor
.
har
.
"
;
const
trace
=
{
log
:
function
(
.
.
.
args
)
{
}
}
;
var
HarAutomation
=
Class
(
{
initialize
:
function
(
toolbox
)
{
this
.
toolbox
=
toolbox
;
let
target
=
toolbox
.
target
;
target
.
makeRemote
(
)
.
then
(
(
)
=
>
{
this
.
startMonitoring
(
target
.
client
target
.
form
)
;
}
)
;
}
destroy
:
function
(
)
{
if
(
this
.
collector
)
{
this
.
collector
.
stop
(
)
;
}
if
(
this
.
tabWatcher
)
{
this
.
tabWatcher
.
disconnect
(
)
;
}
}
startMonitoring
:
function
(
client
tabGrip
callback
)
{
if
(
!
client
)
{
return
;
}
if
(
!
tabGrip
)
{
return
;
}
this
.
debuggerClient
=
client
;
this
.
tabClient
=
this
.
toolbox
.
target
.
activeTab
;
this
.
webConsoleClient
=
this
.
toolbox
.
target
.
activeConsole
;
this
.
tabWatcher
=
new
TabWatcher
(
this
.
toolbox
this
)
;
this
.
tabWatcher
.
connect
(
)
;
}
pageLoadBegin
:
function
(
response
)
{
this
.
resetCollector
(
)
;
}
resetCollector
:
function
(
)
{
if
(
this
.
collector
)
{
this
.
collector
.
stop
(
)
;
}
this
.
collector
=
new
HarCollector
(
{
webConsoleClient
:
this
.
webConsoleClient
debuggerClient
:
this
.
debuggerClient
}
)
;
this
.
collector
.
start
(
)
;
}
pageLoadDone
:
function
(
response
)
{
trace
.
log
(
"
HarAutomation
.
pageLoadDone
;
"
response
)
;
if
(
this
.
collector
)
{
this
.
collector
.
waitForHarLoad
(
)
.
then
(
collector
=
>
{
return
this
.
autoExport
(
)
;
}
)
;
}
}
autoExport
:
function
(
)
{
let
autoExport
=
Services
.
prefs
.
getBoolPref
(
prefDomain
+
"
enableAutoExportToFile
"
)
;
if
(
!
autoExport
)
{
return
resolve
(
)
;
}
let
data
=
{
fileName
:
Services
.
prefs
.
getCharPref
(
prefDomain
+
"
defaultFileName
"
)
}
;
return
this
.
executeExport
(
data
)
;
}
triggerExport
:
function
(
data
)
{
if
(
!
data
.
fileName
)
{
data
.
fileName
=
Services
.
prefs
.
getCharPref
(
prefDomain
+
"
defaultFileName
"
)
;
}
return
this
.
executeExport
(
data
)
;
}
clear
:
function
(
)
{
this
.
resetCollector
(
)
;
}
executeExport
:
function
(
data
)
{
let
items
=
this
.
collector
.
getItems
(
)
;
let
form
=
this
.
toolbox
.
target
.
form
;
let
title
=
form
.
title
|
|
form
.
url
;
let
options
=
{
getString
:
this
.
getString
.
bind
(
this
)
view
:
this
items
:
items
}
;
options
.
defaultFileName
=
data
.
fileName
;
options
.
compress
=
data
.
compress
;
options
.
title
=
data
.
title
|
|
title
;
options
.
id
=
data
.
id
;
options
.
jsonp
=
data
.
jsonp
;
options
.
includeResponseBodies
=
data
.
includeResponseBodies
;
options
.
jsonpCallback
=
data
.
jsonpCallback
;
options
.
forceExport
=
data
.
forceExport
;
trace
.
log
(
"
HarAutomation
.
executeExport
;
"
+
data
.
fileName
options
)
;
return
HarExporter
.
fetchHarData
(
options
)
.
then
(
jsonString
=
>
{
if
(
jsonString
&
&
options
.
defaultFileName
)
{
let
file
=
getDefaultTargetFile
(
options
)
;
if
(
file
)
{
HarUtils
.
saveToFile
(
file
jsonString
options
.
compress
)
;
}
}
return
jsonString
;
}
)
;
}
getString
:
function
(
stringGrip
)
{
return
this
.
webConsoleClient
.
getString
(
stringGrip
)
;
}
_getFormDataSections
:
Task
.
async
(
function
*
(
headers
uploadHeaders
postData
)
{
let
formDataSections
=
[
]
;
let
{
headers
:
requestHeaders
}
=
headers
;
let
{
headers
:
payloadHeaders
}
=
uploadHeaders
;
let
allHeaders
=
[
.
.
.
payloadHeaders
.
.
.
requestHeaders
]
;
let
contentTypeHeader
=
allHeaders
.
find
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
content
-
type
"
;
}
)
;
let
contentTypeLongString
=
contentTypeHeader
?
contentTypeHeader
.
value
:
"
"
;
let
contentType
=
yield
this
.
getString
(
contentTypeLongString
)
;
if
(
contentType
.
includes
(
"
x
-
www
-
form
-
urlencoded
"
)
)
{
let
postDataLongString
=
postData
.
postData
.
text
;
let
data
=
yield
this
.
getString
(
postDataLongString
)
;
for
(
let
section
of
data
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
)
{
if
(
payloadHeaders
.
every
(
header
=
>
!
section
.
startsWith
(
header
.
name
)
)
)
{
formDataSections
.
push
(
section
)
;
}
}
}
return
formDataSections
;
}
)
}
)
;
function
TabWatcher
(
toolbox
listener
)
{
this
.
target
=
toolbox
.
target
;
this
.
listener
=
listener
;
this
.
onTabNavigated
=
this
.
onTabNavigated
.
bind
(
this
)
;
}
TabWatcher
.
prototype
=
{
connect
:
function
(
)
{
this
.
target
.
on
(
"
navigate
"
this
.
onTabNavigated
)
;
this
.
target
.
on
(
"
will
-
navigate
"
this
.
onTabNavigated
)
;
}
disconnect
:
function
(
)
{
if
(
!
this
.
target
)
{
return
;
}
this
.
target
.
off
(
"
navigate
"
this
.
onTabNavigated
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
onTabNavigated
)
;
}
onTabNavigated
:
function
(
type
packet
)
{
switch
(
type
)
{
case
"
will
-
navigate
"
:
{
this
.
listener
.
pageLoadBegin
(
packet
)
;
break
;
}
case
"
navigate
"
:
{
this
.
listener
.
pageLoadDone
(
packet
)
;
break
;
}
}
}
}
;
function
getDefaultTargetFile
(
options
)
{
let
path
=
options
.
defaultLogDir
|
|
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
defaultLogDir
"
)
;
let
folder
=
HarUtils
.
getLocalDirectory
(
path
)
;
let
fileName
=
HarUtils
.
getHarFileName
(
options
.
defaultFileName
options
.
jsonp
options
.
compress
)
;
folder
.
append
(
fileName
)
;
folder
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
0666
"
8
)
)
;
return
folder
;
}
exports
.
HarAutomation
=
HarAutomation
;
