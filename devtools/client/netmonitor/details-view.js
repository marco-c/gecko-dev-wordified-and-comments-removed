"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Editor
=
require
(
"
devtools
/
client
/
sourceeditor
/
editor
"
)
;
const
{
Heritage
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
ToolSidebar
}
=
require
(
"
devtools
/
client
/
framework
/
sidebar
"
)
;
const
{
VariablesView
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
const
{
VariablesViewController
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
const
{
EVENTS
}
=
require
(
"
.
/
events
"
)
;
const
{
L10N
}
=
require
(
"
.
/
l10n
"
)
;
const
{
Filters
}
=
require
(
"
.
/
filter
-
predicates
"
)
;
const
{
decodeUnicodeUrl
formDataURI
getFormDataSections
getUrlBaseName
getUrlQuery
getUrlHost
parseQueryString
}
=
require
(
"
.
/
request
-
utils
"
)
;
const
SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE
=
102400
;
const
HEADERS_SIZE_DECIMALS
=
3
;
const
CONTENT_MIME_TYPE_MAPPINGS
=
{
"
/
ecmascript
"
:
Editor
.
modes
.
js
"
/
javascript
"
:
Editor
.
modes
.
js
"
/
x
-
javascript
"
:
Editor
.
modes
.
js
"
/
html
"
:
Editor
.
modes
.
html
"
/
xhtml
"
:
Editor
.
modes
.
html
"
/
xml
"
:
Editor
.
modes
.
html
"
/
atom
"
:
Editor
.
modes
.
html
"
/
soap
"
:
Editor
.
modes
.
html
"
/
vnd
.
mpeg
.
dash
.
mpd
"
:
Editor
.
modes
.
html
"
/
rdf
"
:
Editor
.
modes
.
css
"
/
rss
"
:
Editor
.
modes
.
css
"
/
css
"
:
Editor
.
modes
.
css
}
;
const
GENERIC_VARIABLES_VIEW_SETTINGS
=
{
lazyEmpty
:
true
lazyEmptyDelay
:
10
searchEnabled
:
true
editableValueTooltip
:
"
"
editableNameTooltip
:
"
"
preventDisableOnChange
:
true
preventDescriptorModifiers
:
true
eval
:
(
)
=
>
{
}
}
;
function
DetailsView
(
)
{
dumpn
(
"
DetailsView
was
instantiated
"
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_onTabSelect
=
this
.
_onTabSelect
.
bind
(
this
)
;
}
DetailsView
.
prototype
=
{
_viewState
:
{
updating
:
[
]
dirty
:
[
]
latestData
:
null
}
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
DetailsView
"
)
;
this
.
widget
=
(
"
#
event
-
details
-
pane
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
this
.
widget
this
"
netmonitor
"
{
disableTelemetry
:
true
showAllTabsMenu
:
true
}
)
;
this
.
_headers
=
new
VariablesView
(
(
"
#
all
-
headers
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
headersEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
headersFilterText
"
)
}
)
)
;
this
.
_cookies
=
new
VariablesView
(
(
"
#
all
-
cookies
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
cookiesEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
cookiesFilterText
"
)
}
)
)
;
this
.
_params
=
new
VariablesView
(
(
"
#
request
-
params
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
emptyText
:
L10N
.
getStr
(
"
paramsEmptyText
"
)
searchPlaceholder
:
L10N
.
getStr
(
"
paramsFilterText
"
)
}
)
)
;
this
.
_json
=
new
VariablesView
(
(
"
#
response
-
content
-
json
"
)
Heritage
.
extend
(
GENERIC_VARIABLES_VIEW_SETTINGS
{
onlyEnumVisible
:
true
searchPlaceholder
:
L10N
.
getStr
(
"
jsonFilterText
"
)
}
)
)
;
VariablesViewController
.
attach
(
this
.
_json
)
;
this
.
_paramsQueryString
=
L10N
.
getStr
(
"
paramsQueryString
"
)
;
this
.
_paramsFormData
=
L10N
.
getStr
(
"
paramsFormData
"
)
;
this
.
_paramsPostPayload
=
L10N
.
getStr
(
"
paramsPostPayload
"
)
;
this
.
_requestHeaders
=
L10N
.
getStr
(
"
requestHeaders
"
)
;
this
.
_requestHeadersFromUpload
=
L10N
.
getStr
(
"
requestHeadersFromUpload
"
)
;
this
.
_responseHeaders
=
L10N
.
getStr
(
"
responseHeaders
"
)
;
this
.
_requestCookies
=
L10N
.
getStr
(
"
requestCookies
"
)
;
this
.
_responseCookies
=
L10N
.
getStr
(
"
responseCookies
"
)
;
(
"
tabpanels
"
this
.
widget
)
.
addEventListener
(
"
select
"
this
.
_onTabSelect
)
;
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
DetailsView
"
)
;
this
.
sidebar
.
destroy
(
)
;
(
"
tabpanels
"
this
.
widget
)
.
removeEventListener
(
"
select
"
this
.
_onTabSelect
)
;
}
populate
:
function
(
data
)
{
(
"
#
request
-
params
-
box
"
)
.
setAttribute
(
"
flex
"
"
1
"
)
;
(
"
#
request
-
params
-
box
"
)
.
hidden
=
false
;
(
"
#
request
-
post
-
data
-
textarea
-
box
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
info
-
header
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
json
-
box
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
true
;
(
"
#
raw
-
headers
"
)
.
hidden
=
true
;
(
"
#
response
-
content
-
image
-
box
"
)
.
hidden
=
true
;
let
isHtml
=
Filters
.
html
(
data
)
;
this
.
sidebar
.
toggleTab
(
isHtml
"
preview
-
tab
"
)
;
let
hasSecurityInfo
=
data
.
securityState
&
&
data
.
securityState
!
=
=
"
insecure
"
;
this
.
sidebar
.
toggleTab
(
hasSecurityInfo
"
security
-
tab
"
)
;
if
(
!
isHtml
&
&
this
.
widget
.
selectedPanel
=
=
=
(
"
#
preview
-
tabpanel
"
)
|
|
!
hasSecurityInfo
&
&
this
.
widget
.
selectedPanel
=
=
=
(
"
#
security
-
tabpanel
"
)
)
{
this
.
widget
.
selectedIndex
=
0
;
}
this
.
_headers
.
empty
(
)
;
this
.
_cookies
.
empty
(
)
;
this
.
_params
.
empty
(
)
;
this
.
_json
.
empty
(
)
;
this
.
_dataSrc
=
{
src
:
data
populated
:
[
]
}
;
this
.
_onTabSelect
(
)
;
window
.
emit
(
EVENTS
.
NETWORKDETAILSVIEW_POPULATED
)
;
return
promise
.
resolve
(
)
;
}
_onTabSelect
:
function
(
)
{
let
{
src
populated
}
=
this
.
_dataSrc
|
|
{
}
;
let
tab
=
this
.
widget
.
selectedIndex
;
let
view
=
this
;
if
(
!
src
|
|
populated
[
tab
]
)
{
return
;
}
let
viewState
=
this
.
_viewState
;
if
(
viewState
.
updating
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
true
;
viewState
.
latestData
=
src
;
return
;
}
Task
.
spawn
(
function
*
(
)
{
viewState
.
updating
[
tab
]
=
true
;
switch
(
tab
)
{
case
0
:
yield
view
.
_setSummary
(
src
)
;
yield
view
.
_setResponseHeaders
(
src
.
responseHeaders
)
;
yield
view
.
_setRequestHeaders
(
src
.
requestHeaders
src
.
requestHeadersFromUploadStream
)
;
break
;
case
1
:
yield
view
.
_setResponseCookies
(
src
.
responseCookies
)
;
yield
view
.
_setRequestCookies
(
src
.
requestCookies
)
;
break
;
case
2
:
yield
view
.
_setRequestGetParams
(
src
.
url
)
;
yield
view
.
_setRequestPostParams
(
src
.
requestHeaders
src
.
requestHeadersFromUploadStream
src
.
requestPostData
)
;
break
;
case
3
:
yield
view
.
_setResponseBody
(
src
.
url
src
.
responseContent
)
;
break
;
case
4
:
yield
view
.
_setTimingsInformation
(
src
.
eventTimings
)
;
break
;
case
5
:
yield
view
.
_setSecurityInfo
(
src
.
securityInfo
src
.
url
)
;
break
;
case
6
:
yield
view
.
_setHtmlPreview
(
src
.
responseContent
)
;
break
;
}
viewState
.
updating
[
tab
]
=
false
;
}
)
.
then
(
(
)
=
>
{
if
(
tab
=
=
this
.
widget
.
selectedIndex
)
{
if
(
viewState
.
dirty
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
false
;
view
.
populate
(
viewState
.
latestData
)
;
}
else
{
populated
[
tab
]
=
true
;
window
.
emit
(
EVENTS
.
TAB_UPDATED
)
;
}
}
else
if
(
viewState
.
dirty
[
tab
]
)
{
viewState
.
dirty
[
tab
]
=
false
;
}
}
e
=
>
console
.
error
(
e
)
)
;
}
_setSummary
:
function
(
data
)
{
if
(
data
.
url
)
{
let
unicodeUrl
=
decodeUnicodeUrl
(
data
.
url
)
;
(
"
#
headers
-
summary
-
url
-
value
"
)
.
setAttribute
(
"
value
"
unicodeUrl
)
;
(
"
#
headers
-
summary
-
url
-
value
"
)
.
setAttribute
(
"
tooltiptext
"
unicodeUrl
)
;
(
"
#
headers
-
summary
-
url
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
url
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
method
)
{
(
"
#
headers
-
summary
-
method
-
value
"
)
.
setAttribute
(
"
value
"
data
.
method
)
;
(
"
#
headers
-
summary
-
method
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
method
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
remoteAddress
)
{
let
address
=
data
.
remoteAddress
;
if
(
address
.
indexOf
(
"
:
"
)
!
=
-
1
)
{
address
=
[
{
address
}
]
;
}
if
(
data
.
remotePort
)
{
address
+
=
:
{
data
.
remotePort
}
;
}
(
"
#
headers
-
summary
-
address
-
value
"
)
.
setAttribute
(
"
value
"
address
)
;
(
"
#
headers
-
summary
-
address
-
value
"
)
.
setAttribute
(
"
tooltiptext
"
address
)
;
(
"
#
headers
-
summary
-
address
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
address
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
status
)
{
let
code
;
if
(
data
.
fromCache
)
{
code
=
"
cached
"
;
}
else
if
(
data
.
fromServiceWorker
)
{
code
=
"
service
worker
"
;
}
else
{
code
=
data
.
status
;
}
(
"
#
headers
-
summary
-
status
-
circle
"
)
.
setAttribute
(
"
data
-
code
"
code
)
;
(
"
#
headers
-
summary
-
status
-
value
"
)
.
setAttribute
(
"
value
"
data
.
status
+
"
"
+
data
.
statusText
)
;
(
"
#
headers
-
summary
-
status
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
status
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
data
.
httpVersion
)
{
(
"
#
headers
-
summary
-
version
-
value
"
)
.
setAttribute
(
"
value
"
data
.
httpVersion
)
;
(
"
#
headers
-
summary
-
version
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
(
"
#
headers
-
summary
-
version
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_setRequestHeaders
:
Task
.
async
(
function
*
(
headers
uploadHeaders
)
{
if
(
headers
&
&
headers
.
headers
.
length
)
{
yield
this
.
_addHeaders
(
this
.
_requestHeaders
headers
)
;
}
if
(
uploadHeaders
&
&
uploadHeaders
.
headers
.
length
)
{
yield
this
.
_addHeaders
(
this
.
_requestHeadersFromUpload
uploadHeaders
)
;
}
}
)
_setResponseHeaders
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
headers
.
length
)
{
response
.
headers
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
yield
this
.
_addHeaders
(
this
.
_responseHeaders
response
)
;
}
}
)
_addHeaders
:
Task
.
async
(
function
*
(
name
response
)
{
let
kb
=
response
.
headersSize
/
1024
;
let
size
=
L10N
.
numberWithDecimals
(
kb
HEADERS_SIZE_DECIMALS
)
;
let
text
=
L10N
.
getFormatStr
(
"
networkMenu
.
sizeKB
"
size
)
;
let
headersScope
=
this
.
_headers
.
addScope
(
name
+
"
(
"
+
text
+
"
)
"
)
;
headersScope
.
expanded
=
true
;
for
(
let
header
of
response
.
headers
)
{
let
headerVar
=
headersScope
.
addItem
(
header
.
name
{
}
{
relaxed
:
true
}
)
;
let
headerValue
=
yield
gNetwork
.
getString
(
header
.
value
)
;
headerVar
.
setGrip
(
headerValue
)
;
}
}
)
_setRequestCookies
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
cookies
.
length
)
{
response
.
cookies
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
yield
this
.
_addCookies
(
this
.
_requestCookies
response
)
;
}
}
)
_setResponseCookies
:
Task
.
async
(
function
*
(
response
)
{
if
(
response
&
&
response
.
cookies
.
length
)
{
yield
this
.
_addCookies
(
this
.
_responseCookies
response
)
;
}
}
)
_addCookies
:
Task
.
async
(
function
*
(
name
response
)
{
let
cookiesScope
=
this
.
_cookies
.
addScope
(
name
)
;
cookiesScope
.
expanded
=
true
;
for
(
let
cookie
of
response
.
cookies
)
{
let
cookieVar
=
cookiesScope
.
addItem
(
cookie
.
name
{
}
{
relaxed
:
true
}
)
;
let
cookieValue
=
yield
gNetwork
.
getString
(
cookie
.
value
)
;
cookieVar
.
setGrip
(
cookieValue
)
;
let
cookieProps
=
Object
.
keys
(
cookie
)
;
if
(
cookieProps
.
length
=
=
2
)
{
continue
;
}
let
rawObject
=
Object
.
create
(
null
)
;
let
otherProps
=
cookieProps
.
filter
(
e
=
>
e
!
=
"
name
"
&
&
e
!
=
"
value
"
)
;
for
(
let
prop
of
otherProps
)
{
rawObject
[
prop
]
=
cookie
[
prop
]
;
}
cookieVar
.
populate
(
rawObject
)
;
cookieVar
.
twisty
=
true
;
cookieVar
.
expanded
=
true
;
}
}
)
_setRequestGetParams
:
function
(
url
)
{
let
query
=
getUrlQuery
(
url
)
;
if
(
query
)
{
this
.
_addParams
(
this
.
_paramsQueryString
query
)
;
}
}
_setRequestPostParams
:
Task
.
async
(
function
*
(
headers
uploadHeaders
postData
)
{
if
(
!
headers
|
|
!
uploadHeaders
|
|
!
postData
)
{
return
;
}
let
formDataSections
=
yield
getFormDataSections
(
headers
uploadHeaders
postData
gNetwork
.
getString
.
bind
(
gNetwork
)
)
;
this
.
_params
.
onlyEnumVisible
=
false
;
if
(
formDataSections
.
length
>
0
)
{
formDataSections
.
forEach
(
section
=
>
{
this
.
_addParams
(
this
.
_paramsFormData
section
)
;
}
)
;
}
else
{
let
postDataLongString
=
postData
.
postData
.
text
;
let
text
=
yield
gNetwork
.
getString
(
postDataLongString
)
;
let
jsonVal
=
null
;
try
{
jsonVal
=
JSON
.
parse
(
text
)
;
}
catch
(
ex
)
{
}
if
(
jsonVal
)
{
this
.
_params
.
onlyEnumVisible
=
true
;
let
jsonScopeName
=
L10N
.
getStr
(
"
jsonScopeName
"
)
;
let
jsonScope
=
this
.
_params
.
addScope
(
jsonScopeName
)
;
jsonScope
.
expanded
=
true
;
let
jsonItem
=
jsonScope
.
addItem
(
undefined
{
enumerable
:
true
}
)
;
jsonItem
.
populate
(
jsonVal
{
sorted
:
true
}
)
;
}
else
{
(
"
#
request
-
params
-
box
"
)
.
removeAttribute
(
"
flex
"
)
;
let
paramsScope
=
this
.
_params
.
addScope
(
this
.
_paramsPostPayload
)
;
paramsScope
.
expanded
=
true
;
paramsScope
.
locked
=
true
;
(
"
#
request
-
post
-
data
-
textarea
-
box
"
)
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
request
-
post
-
data
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
text
)
;
editor
.
setText
(
text
)
;
}
}
window
.
emit
(
EVENTS
.
REQUEST_POST_PARAMS_DISPLAYED
)
;
}
)
_addParams
:
function
(
name
queryString
)
{
let
paramsArray
=
parseQueryString
(
queryString
)
;
if
(
!
paramsArray
)
{
return
;
}
let
paramsScope
=
this
.
_params
.
addScope
(
name
)
;
paramsScope
.
expanded
=
true
;
for
(
let
param
of
paramsArray
)
{
let
paramVar
=
paramsScope
.
addItem
(
param
.
name
{
}
{
relaxed
:
true
}
)
;
paramVar
.
setGrip
(
param
.
value
)
;
}
}
_setResponseBody
:
Task
.
async
(
function
*
(
url
response
)
{
if
(
!
response
)
{
return
;
}
let
{
mimeType
text
encoding
}
=
response
.
content
;
let
responseBody
=
yield
gNetwork
.
getString
(
text
)
;
let
jsonMimeType
jsonObject
jsonObjectParseError
;
try
{
jsonMimeType
=
/
\
bjson
/
.
test
(
mimeType
)
;
jsonObject
=
JSON
.
parse
(
responseBody
)
;
}
catch
(
e
)
{
jsonObjectParseError
=
e
;
}
if
(
jsonMimeType
|
|
jsonObject
)
{
let
jsonpRegex
=
/
^
\
s
*
(
[
\
w
]
+
)
\
s
*
\
(
\
s
*
(
[
^
]
*
)
\
s
*
\
)
\
s
*
;
?
\
s
*
/
;
let
[
_
callbackPadding
jsonpString
]
=
responseBody
.
match
(
jsonpRegex
)
|
|
[
]
;
if
(
callbackPadding
&
&
jsonpString
)
{
try
{
jsonObject
=
JSON
.
parse
(
jsonpString
)
;
}
catch
(
e
)
{
jsonObjectParseError
=
e
;
}
}
if
(
jsonObject
)
{
(
"
#
response
-
content
-
json
-
box
"
)
.
hidden
=
false
;
let
jsonScopeName
=
callbackPadding
?
L10N
.
getFormatStr
(
"
jsonpScopeName
"
callbackPadding
)
:
L10N
.
getStr
(
"
jsonScopeName
"
)
;
let
jsonVar
=
{
label
:
jsonScopeName
rawObject
:
jsonObject
}
;
yield
this
.
_json
.
controller
.
setSingleVariable
(
jsonVar
)
.
expanded
;
}
else
{
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
false
;
let
infoHeader
=
(
"
#
response
-
content
-
info
-
header
"
)
;
infoHeader
.
setAttribute
(
"
value
"
jsonObjectParseError
)
;
infoHeader
.
setAttribute
(
"
tooltiptext
"
jsonObjectParseError
)
;
infoHeader
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
response
-
content
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
js
)
;
editor
.
setText
(
responseBody
)
;
}
}
else
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
(
"
#
response
-
content
-
image
-
box
"
)
.
setAttribute
(
"
align
"
"
center
"
)
;
(
"
#
response
-
content
-
image
-
box
"
)
.
setAttribute
(
"
pack
"
"
center
"
)
;
(
"
#
response
-
content
-
image
-
box
"
)
.
hidden
=
false
;
(
"
#
response
-
content
-
image
"
)
.
src
=
formDataURI
(
mimeType
encoding
responseBody
)
;
(
"
#
response
-
content
-
image
-
name
-
value
"
)
.
setAttribute
(
"
value
"
getUrlBaseName
(
url
)
)
;
(
"
#
response
-
content
-
image
-
mime
-
value
"
)
.
setAttribute
(
"
value
"
mimeType
)
;
(
"
#
response
-
content
-
image
"
)
.
onload
=
e
=
>
{
let
{
width
height
}
=
e
.
target
.
getBoundingClientRect
(
)
;
let
dimensions
=
(
width
-
2
)
+
"
\
u00D7
"
+
(
height
-
2
)
;
(
"
#
response
-
content
-
image
-
dimensions
-
value
"
)
.
setAttribute
(
"
value
"
dimensions
)
;
}
;
}
else
{
(
"
#
response
-
content
-
textarea
-
box
"
)
.
hidden
=
false
;
let
editor
=
yield
NetMonitorView
.
editor
(
"
#
response
-
content
-
textarea
"
)
;
editor
.
setMode
(
Editor
.
modes
.
text
)
;
editor
.
setText
(
responseBody
)
;
if
(
responseBody
.
length
<
SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE
)
{
let
mapping
=
Object
.
keys
(
CONTENT_MIME_TYPE_MAPPINGS
)
.
find
(
key
=
>
{
return
mimeType
.
includes
(
key
)
;
}
)
;
if
(
mapping
)
{
editor
.
setMode
(
CONTENT_MIME_TYPE_MAPPINGS
[
mapping
]
)
;
}
}
}
window
.
emit
(
EVENTS
.
RESPONSE_BODY_DISPLAYED
)
;
}
)
_setTimingsInformation
:
function
(
response
)
{
if
(
!
response
)
{
return
;
}
let
{
blocked
dns
connect
send
wait
receive
}
=
response
.
timings
;
let
tabboxWidth
=
(
"
#
details
-
pane
"
)
.
getAttribute
(
"
width
"
)
;
let
availableWidth
=
tabboxWidth
/
2
;
let
scale
=
(
response
.
totalTime
>
0
?
Math
.
max
(
availableWidth
/
response
.
totalTime
0
)
:
0
)
;
(
"
#
timings
-
summary
-
blocked
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
blocked
*
scale
)
;
(
"
#
timings
-
summary
-
blocked
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
blocked
)
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
dns
*
scale
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
dns
)
)
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
connect
*
scale
)
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
connect
)
)
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
send
*
scale
)
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
send
)
)
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
wait
*
scale
)
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
wait
)
)
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
box
"
)
.
setAttribute
(
"
width
"
receive
*
scale
)
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
total
"
)
.
setAttribute
(
"
value
"
L10N
.
getFormatStr
(
"
networkMenu
.
totalMS
"
receive
)
)
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
blocked
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
box
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
+
wait
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
dns
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
blocked
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
connect
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
send
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
wait
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
)
)
+
"
px
)
"
;
(
"
#
timings
-
summary
-
receive
.
requests
-
menu
-
timings
-
total
"
)
.
style
.
transform
=
"
translateX
(
"
+
(
scale
*
(
blocked
+
dns
+
connect
+
send
+
wait
)
)
+
"
px
)
"
;
}
_setHtmlPreview
:
Task
.
async
(
function
*
(
response
)
{
if
(
!
response
)
{
return
promise
.
resolve
(
)
;
}
let
{
text
}
=
response
.
content
;
let
responseBody
=
yield
gNetwork
.
getString
(
text
)
;
let
iframe
=
(
"
#
response
-
preview
"
)
;
iframe
.
contentDocument
.
docShell
.
allowJavascript
=
false
;
iframe
.
contentDocument
.
documentElement
.
innerHTML
=
responseBody
;
window
.
emit
(
EVENTS
.
RESPONSE_HTML_PREVIEW_DISPLAYED
)
;
return
undefined
;
}
)
_setSecurityInfo
:
Task
.
async
(
function
*
(
securityInfo
url
)
{
if
(
!
securityInfo
)
{
return
;
}
function
setValue
(
selector
value
)
{
let
label
=
(
selector
)
;
if
(
!
value
)
{
label
.
setAttribute
(
"
value
"
L10N
.
getStr
(
"
netmonitor
.
security
.
notAvailable
"
)
)
;
label
.
setAttribute
(
"
tooltiptext
"
label
.
getAttribute
(
"
value
"
)
)
;
}
else
{
label
.
setAttribute
(
"
value
"
value
)
;
label
.
setAttribute
(
"
tooltiptext
"
value
)
;
}
}
let
errorbox
=
(
"
#
security
-
error
"
)
;
let
infobox
=
(
"
#
security
-
information
"
)
;
if
(
securityInfo
.
state
=
=
=
"
secure
"
|
|
securityInfo
.
state
=
=
=
"
weak
"
)
{
infobox
.
hidden
=
false
;
errorbox
.
hidden
=
true
;
let
cipher
=
(
"
#
security
-
warning
-
cipher
"
)
;
if
(
securityInfo
.
state
=
=
=
"
weak
"
)
{
cipher
.
hidden
=
securityInfo
.
weaknessReasons
.
indexOf
(
"
cipher
"
)
=
=
=
-
1
;
}
else
{
cipher
.
hidden
=
true
;
}
let
enabledLabel
=
L10N
.
getStr
(
"
netmonitor
.
security
.
enabled
"
)
;
let
disabledLabel
=
L10N
.
getStr
(
"
netmonitor
.
security
.
disabled
"
)
;
setValue
(
"
#
security
-
protocol
-
version
-
value
"
securityInfo
.
protocolVersion
)
;
setValue
(
"
#
security
-
ciphersuite
-
value
"
securityInfo
.
cipherSuite
)
;
let
domain
=
getUrlHost
(
url
)
;
let
hostHeader
=
L10N
.
getFormatStr
(
"
netmonitor
.
security
.
hostHeader
"
domain
)
;
setValue
(
"
#
security
-
info
-
host
-
header
"
hostHeader
)
;
setValue
(
"
#
security
-
http
-
strict
-
transport
-
security
-
value
"
securityInfo
.
hsts
?
enabledLabel
:
disabledLabel
)
;
setValue
(
"
#
security
-
public
-
key
-
pinning
-
value
"
securityInfo
.
hpkp
?
enabledLabel
:
disabledLabel
)
;
let
cert
=
securityInfo
.
cert
;
setValue
(
"
#
security
-
cert
-
subject
-
cn
"
cert
.
subject
.
commonName
)
;
setValue
(
"
#
security
-
cert
-
subject
-
o
"
cert
.
subject
.
organization
)
;
setValue
(
"
#
security
-
cert
-
subject
-
ou
"
cert
.
subject
.
organizationalUnit
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
cn
"
cert
.
issuer
.
commonName
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
o
"
cert
.
issuer
.
organization
)
;
setValue
(
"
#
security
-
cert
-
issuer
-
ou
"
cert
.
issuer
.
organizationalUnit
)
;
setValue
(
"
#
security
-
cert
-
validity
-
begins
"
cert
.
validity
.
start
)
;
setValue
(
"
#
security
-
cert
-
validity
-
expires
"
cert
.
validity
.
end
)
;
setValue
(
"
#
security
-
cert
-
sha1
-
fingerprint
"
cert
.
fingerprint
.
sha1
)
;
setValue
(
"
#
security
-
cert
-
sha256
-
fingerprint
"
cert
.
fingerprint
.
sha256
)
;
}
else
{
infobox
.
hidden
=
true
;
errorbox
.
hidden
=
false
;
let
plain
=
new
DOMParser
(
)
.
parseFromString
(
securityInfo
.
errorMessage
"
text
/
html
"
)
;
setValue
(
"
#
security
-
error
-
message
"
plain
.
body
.
textContent
)
;
}
}
)
_dataSrc
:
null
_headers
:
null
_cookies
:
null
_params
:
null
_json
:
null
_paramsQueryString
:
"
"
_paramsFormData
:
"
"
_paramsPostPayload
:
"
"
_requestHeaders
:
"
"
_responseHeaders
:
"
"
_requestCookies
:
"
"
_responseCookies
:
"
"
}
;
exports
.
DetailsView
=
DetailsView
;
