"
use
strict
"
;
const
{
BATCH_ACTIONS
BATCH_ENABLE
BATCH_RESET
BATCH_FLUSH
}
=
require
(
"
.
.
/
constants
"
)
;
const
REQUESTS_REFRESH_RATE
=
50
;
function
batchingMiddleware
(
store
)
{
return
next
=
>
{
let
queuedActions
=
[
]
;
let
enabled
=
true
;
let
flushTask
=
null
;
return
action
=
>
{
if
(
action
.
type
=
=
=
BATCH_ENABLE
)
{
return
setEnabled
(
action
.
enabled
)
;
}
if
(
action
.
type
=
=
=
BATCH_RESET
)
{
return
resetQueue
(
)
;
}
if
(
action
.
type
=
=
=
BATCH_FLUSH
)
{
return
flushQueue
(
)
;
}
if
(
action
.
meta
&
&
action
.
meta
.
batch
)
{
if
(
!
enabled
)
{
next
(
action
)
;
return
Promise
.
resolve
(
)
;
}
queuedActions
.
push
(
action
)
;
if
(
!
flushTask
)
{
flushTask
=
new
DelayedTask
(
flushActions
REQUESTS_REFRESH_RATE
)
;
}
return
flushTask
.
promise
;
}
return
next
(
action
)
;
}
;
function
setEnabled
(
value
)
{
enabled
=
value
;
if
(
!
enabled
&
&
flushTask
)
{
flushTask
.
runNow
(
)
;
}
}
function
resetQueue
(
)
{
queuedActions
=
[
]
;
if
(
flushTask
)
{
flushTask
.
cancel
(
)
;
flushTask
=
null
;
}
}
function
flushQueue
(
)
{
if
(
flushTask
)
{
flushTask
.
runNow
(
)
;
}
}
function
flushActions
(
)
{
const
actions
=
queuedActions
;
queuedActions
=
[
]
;
next
(
{
type
:
BATCH_ACTIONS
actions
}
)
;
flushTask
=
null
;
}
}
;
}
function
DelayedTask
(
taskFn
delay
)
{
this
.
_promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
runTask
=
cancel
=
>
{
if
(
cancel
)
{
reject
(
"
Task
cancelled
"
)
;
}
else
{
taskFn
(
)
;
resolve
(
)
;
}
this
.
runTask
=
null
;
}
;
this
.
timeout
=
setTimeout
(
this
.
runTask
delay
)
;
}
)
.
catch
(
console
.
error
)
;
}
DelayedTask
.
prototype
=
{
get
promise
(
)
{
return
this
.
_promise
;
}
cancel
(
)
{
clearTimeout
(
this
.
timeout
)
;
if
(
this
.
runTask
)
{
this
.
runTask
(
true
)
;
}
}
runNow
(
)
{
clearTimeout
(
this
.
timeout
)
;
if
(
this
.
runTask
)
{
this
.
runTask
(
)
;
}
}
}
;
module
.
exports
=
batchingMiddleware
;
