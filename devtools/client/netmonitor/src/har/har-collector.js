"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
getLongStringFullText
}
=
require
(
"
devtools
/
client
/
shared
/
string
-
utils
"
)
;
const
trace
=
{
log
(
.
.
.
args
)
{
}
}
;
function
HarCollector
(
options
)
{
this
.
commands
=
options
.
commands
;
this
.
onResourceAvailable
=
this
.
onResourceAvailable
.
bind
(
this
)
;
this
.
onResourceUpdated
=
this
.
onResourceUpdated
.
bind
(
this
)
;
this
.
onRequestHeaders
=
this
.
onRequestHeaders
.
bind
(
this
)
;
this
.
onRequestCookies
=
this
.
onRequestCookies
.
bind
(
this
)
;
this
.
onRequestPostData
=
this
.
onRequestPostData
.
bind
(
this
)
;
this
.
onResponseHeaders
=
this
.
onResponseHeaders
.
bind
(
this
)
;
this
.
onResponseCookies
=
this
.
onResponseCookies
.
bind
(
this
)
;
this
.
onResponseContent
=
this
.
onResponseContent
.
bind
(
this
)
;
this
.
onEventTimings
=
this
.
onEventTimings
.
bind
(
this
)
;
this
.
clear
(
)
;
}
HarCollector
.
prototype
=
{
async
start
(
)
{
await
this
.
commands
.
resourceCommand
.
watchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
]
{
onAvailable
:
this
.
onResourceAvailable
onUpdated
:
this
.
onResourceUpdated
}
)
;
}
async
stop
(
)
{
await
this
.
commands
.
resourceCommand
.
unwatchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
]
{
onAvailable
:
this
.
onResourceAvailable
onUpdated
:
this
.
onResourceUpdated
}
)
;
}
clear
(
)
{
this
.
files
=
new
Map
(
)
;
this
.
items
=
[
]
;
this
.
firstRequestStart
=
-
1
;
this
.
lastRequestStart
=
-
1
;
this
.
requests
=
[
]
;
}
waitForHarLoad
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
waitForResponses
(
)
.
then
(
(
)
=
>
{
trace
.
log
(
"
HarCollector
.
waitForHarLoad
;
DONE
HAR
loaded
!
"
)
;
resolve
(
this
)
;
}
)
;
}
)
;
}
waitForResponses
(
)
{
trace
.
log
(
"
HarCollector
.
waitForResponses
;
"
+
this
.
requests
.
length
)
;
return
waitForAll
(
this
.
requests
)
.
then
(
(
)
=
>
{
this
.
pageLoadDeferred
=
this
.
waitForTimeout
(
)
.
then
(
(
)
=
>
{
}
(
)
=
>
{
trace
.
log
(
"
HarCollector
.
waitForResponses
;
NEW
requests
"
+
"
appeared
during
page
timeout
!
"
)
;
return
this
.
waitForResponses
(
)
;
}
)
;
return
this
.
pageLoadDeferred
;
}
)
;
}
waitForTimeout
(
)
{
const
timeout
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
netmonitor
.
har
.
pageLoadedTimeout
"
)
;
trace
.
log
(
"
HarCollector
.
waitForTimeout
;
"
+
timeout
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
timeout
<
=
0
)
{
resolve
(
)
;
}
this
.
pageLoadReject
=
reject
;
this
.
pageLoadTimeout
=
setTimeout
(
(
)
=
>
{
trace
.
log
(
"
HarCollector
.
onPageLoadTimeout
;
"
)
;
resolve
(
)
;
}
timeout
)
;
}
)
;
}
resetPageLoadTimeout
(
)
{
if
(
this
.
pageLoadTimeout
)
{
trace
.
log
(
"
HarCollector
.
resetPageLoadTimeout
;
"
)
;
clearTimeout
(
this
.
pageLoadTimeout
)
;
this
.
pageLoadTimeout
=
null
;
}
if
(
this
.
pageLoadReject
)
{
this
.
pageLoadReject
(
)
;
this
.
pageLoadReject
=
null
;
}
}
getFile
(
actorId
)
{
return
this
.
files
.
get
(
actorId
)
;
}
getItems
(
)
{
return
this
.
items
;
}
onResourceAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
trace
.
log
(
"
HarCollector
.
onNetworkEvent
;
"
resource
)
;
const
{
actor
startedDateTime
method
url
isXHR
}
=
resource
;
const
startTime
=
Date
.
parse
(
startedDateTime
)
;
if
(
this
.
firstRequestStart
=
=
-
1
)
{
this
.
firstRequestStart
=
startTime
;
}
if
(
this
.
lastRequestEnd
<
startTime
)
{
this
.
lastRequestEnd
=
startTime
;
}
let
file
=
this
.
getFile
(
actor
)
;
if
(
file
)
{
console
.
error
(
"
HarCollector
.
onNetworkEvent
;
ERROR
"
+
"
existing
file
conflict
!
"
)
;
continue
;
}
file
=
{
id
:
actor
startedDeltaMs
:
startTime
-
this
.
firstRequestStart
startedMs
:
startTime
method
url
isXHR
}
;
this
.
files
.
set
(
actor
file
)
;
this
.
items
.
push
(
file
)
;
}
}
onResourceUpdated
(
updates
)
{
for
(
const
{
resource
}
of
updates
)
{
const
file
=
this
.
getFile
(
resource
.
actor
)
;
if
(
!
file
)
{
return
;
}
const
includeResponseBodies
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
includeResponseBodies
"
)
;
[
{
type
:
"
eventTimings
"
method
:
"
getEventTimings
"
callbackName
:
"
onEventTimings
"
}
{
type
:
"
requestHeaders
"
method
:
"
getRequestHeaders
"
callbackName
:
"
onRequestHeaders
"
}
{
type
:
"
requestPostData
"
method
:
"
getRequestPostData
"
callbackName
:
"
onRequestPostData
"
}
{
type
:
"
responseHeaders
"
method
:
"
getResponseHeaders
"
callbackName
:
"
onResponseHeaders
"
}
{
type
:
"
responseStart
"
}
{
type
:
"
responseContent
"
method
:
"
getResponseContent
"
callbackName
:
"
onResponseContent
"
}
{
type
:
"
requestCookies
"
method
:
"
getRequestCookies
"
callbackName
:
"
onRequestCookies
"
}
{
type
:
"
responseCookies
"
method
:
"
getResponseCookies
"
callbackName
:
"
onResponseCookies
"
}
]
.
forEach
(
updateType
=
>
{
trace
.
log
(
"
HarCollector
.
onNetworkEventUpdate
;
"
+
updateType
.
type
resource
)
;
let
request
;
if
(
resource
[
{
updateType
.
type
}
Available
]
)
{
if
(
updateType
.
type
=
=
"
responseStart
"
)
{
file
.
httpVersion
=
resource
.
httpVersion
;
file
.
status
=
resource
.
status
;
file
.
statusText
=
resource
.
statusText
;
}
else
if
(
updateType
.
type
=
=
"
responseContent
"
)
{
file
.
contentSize
=
resource
.
contentSize
;
file
.
mimeType
=
resource
.
mimeType
;
file
.
transferredSize
=
resource
.
transferredSize
;
if
(
includeResponseBodies
)
{
request
=
this
.
getData
(
resource
.
actor
updateType
.
method
this
[
updateType
.
callbackName
]
)
;
}
}
else
{
request
=
this
.
getData
(
resource
.
actor
updateType
.
method
this
[
updateType
.
callbackName
]
)
;
}
}
if
(
request
)
{
this
.
requests
.
push
(
request
)
;
}
this
.
resetPageLoadTimeout
(
)
;
}
)
;
}
}
async
getData
(
actor
method
callback
)
{
const
file
=
this
.
getFile
(
actor
)
;
trace
.
log
(
"
HarCollector
.
getData
;
REQUEST
"
+
method
+
"
"
+
file
.
url
file
)
;
const
packet
=
{
to
:
actor
type
:
method
}
;
const
response
=
await
this
.
commands
.
client
.
request
(
packet
)
;
trace
.
log
(
"
HarCollector
.
getData
;
RESPONSE
"
+
method
+
"
"
+
file
.
url
response
)
;
callback
(
response
)
;
return
response
;
}
onRequestHeaders
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
requestHeaders
=
response
;
this
.
getLongHeaders
(
response
.
headers
)
;
}
onRequestCookies
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
requestCookies
=
response
;
this
.
getLongHeaders
(
response
.
cookies
)
;
}
onRequestPostData
(
response
)
{
trace
.
log
(
"
HarCollector
.
onRequestPostData
;
"
response
)
;
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
requestPostData
=
response
;
const
{
text
}
=
response
.
postData
;
if
(
typeof
text
=
=
"
object
"
)
{
this
.
getString
(
text
)
.
then
(
value
=
>
{
response
.
postData
.
text
=
value
;
}
)
;
}
}
onResponseHeaders
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
responseHeaders
=
response
;
this
.
getLongHeaders
(
response
.
headers
)
;
}
onResponseCookies
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
responseCookies
=
response
;
this
.
getLongHeaders
(
response
.
cookies
)
;
}
onResponseContent
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
responseContent
=
response
;
const
{
text
}
=
response
.
content
;
if
(
typeof
text
=
=
"
object
"
)
{
this
.
getString
(
text
)
.
then
(
value
=
>
{
response
.
content
.
text
=
value
;
}
)
;
}
}
onEventTimings
(
response
)
{
const
file
=
this
.
getFile
(
response
.
from
)
;
file
.
eventTimings
=
response
;
file
.
totalTime
=
response
.
totalTime
;
}
getLongHeaders
(
headers
)
{
for
(
const
header
of
headers
)
{
if
(
typeof
header
.
value
=
=
"
object
"
)
{
try
{
this
.
getString
(
header
.
value
)
.
then
(
value
=
>
{
header
.
value
=
value
;
}
)
;
}
catch
(
error
)
{
trace
.
log
(
"
HarCollector
.
getLongHeaders
;
ERROR
when
getString
"
error
)
;
}
}
}
}
async
getString
(
stringGrip
)
{
const
promise
=
getLongStringFullText
(
this
.
commands
.
client
stringGrip
)
;
this
.
requests
.
push
(
promise
)
;
return
promise
;
}
}
;
function
waitForAll
(
promises
)
{
const
clone
=
promises
.
splice
(
0
promises
.
length
)
;
return
Promise
.
all
(
clone
)
.
then
(
(
)
=
>
{
if
(
promises
.
length
)
{
return
waitForAll
(
promises
)
;
}
return
undefined
;
}
)
;
}
exports
.
HarCollector
=
HarCollector
;
