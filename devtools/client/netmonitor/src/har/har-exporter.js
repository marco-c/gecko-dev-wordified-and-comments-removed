"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
JSZip
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
jszip
.
js
"
)
;
const
clipboardHelper
=
require
(
"
resource
:
/
/
devtools
/
shared
/
platform
/
clipboard
.
js
"
)
;
const
{
HarUtils
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
utils
.
js
"
)
;
const
{
HarBuilder
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
.
js
"
)
;
var
uid
=
1
;
const
trace
=
{
log
(
.
.
.
args
)
{
}
}
;
const
HarExporter
=
{
async
save
(
options
)
{
const
defaultFileName
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
defaultFileName
"
)
;
const
compress
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
compress
"
)
;
trace
.
log
(
"
HarExporter
.
save
;
"
+
defaultFileName
options
)
;
let
data
=
await
this
.
fetchHarData
(
options
)
;
const
host
=
new
URL
(
options
.
connector
.
currentTarget
.
url
)
;
const
fileName
=
HarUtils
.
getHarFileName
(
defaultFileName
options
.
jsonp
compress
host
.
hostname
)
;
if
(
compress
)
{
data
=
await
JSZip
(
)
.
file
(
fileName
data
)
.
generateAsync
(
{
compression
:
"
DEFLATE
"
platform
:
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
?
"
DOS
"
:
"
UNIX
"
type
:
"
uint8array
"
}
)
;
}
else
{
data
=
new
TextEncoder
(
)
.
encode
(
data
)
;
}
DevToolsUtils
.
saveAs
(
window
data
fileName
)
;
}
copy
(
options
)
{
return
this
.
fetchHarData
(
options
)
.
then
(
jsonString
=
>
{
clipboardHelper
.
copyString
(
jsonString
)
;
return
jsonString
;
}
)
;
}
getHar
(
options
)
{
return
this
.
fetchHarData
(
options
)
.
then
(
data
=
>
{
return
data
?
JSON
.
parse
(
data
)
:
null
;
}
)
;
}
fetchHarData
(
options
)
{
options
.
id
=
options
.
id
|
|
uid
+
+
;
if
(
typeof
options
.
jsonp
!
=
"
boolean
"
)
{
options
.
jsonp
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
jsonp
"
)
;
}
if
(
typeof
options
.
includeResponseBodies
!
=
"
boolean
"
)
{
options
.
includeResponseBodies
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
includeResponseBodies
"
)
;
}
if
(
typeof
options
.
jsonpCallback
!
=
"
boolean
"
)
{
options
.
jsonpCallback
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
jsonpCallback
"
)
;
}
if
(
typeof
options
.
forceExport
!
=
"
boolean
"
)
{
options
.
forceExport
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
forceExport
"
)
;
}
if
(
typeof
options
.
supportsMultiplePages
!
=
"
boolean
"
)
{
options
.
supportsMultiplePages
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
multiple
-
pages
"
)
;
}
return
this
.
buildHarData
(
options
)
.
then
(
har
=
>
{
if
(
!
har
.
log
.
entries
.
length
&
&
!
options
.
forceExport
)
{
return
Promise
.
resolve
(
)
;
}
let
jsonString
=
this
.
stringify
(
har
)
;
if
(
!
jsonString
)
{
return
Promise
.
resolve
(
)
;
}
if
(
options
.
jsonp
)
{
const
callbackName
=
options
.
jsonpCallback
|
|
"
onInputData
"
;
jsonString
=
callbackName
+
"
(
"
+
jsonString
+
"
)
;
"
;
}
return
jsonString
;
}
)
.
catch
(
function
onError
(
err
)
{
console
.
error
(
err
)
;
}
)
;
}
async
buildHarData
(
options
)
{
const
{
connector
}
=
options
;
connector
.
enableActions
(
false
)
;
options
=
{
.
.
.
options
getString
:
connector
.
getLongString
getTimingMarker
:
connector
.
getTimingMarker
initialTargetTitle
:
connector
.
getInitialTargetTitle
(
)
requestData
:
connector
.
requestData
targetTitlesPerURL
:
connector
.
getTargetTitlesPerURL
(
)
title
:
connector
.
currentTarget
.
title
}
;
const
builder
=
new
HarBuilder
(
options
)
;
const
result
=
await
builder
.
build
(
)
;
connector
.
enableActions
(
true
)
;
return
result
;
}
stringify
(
har
)
{
if
(
!
har
)
{
return
null
;
}
try
{
return
JSON
.
stringify
(
har
null
"
"
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
return
undefined
;
}
}
}
;
exports
.
HarExporter
=
HarExporter
;
