"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
clipboardHelper
=
require
(
"
resource
:
/
/
devtools
/
shared
/
platform
/
clipboard
.
js
"
)
;
const
{
HarUtils
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
utils
.
js
"
)
;
const
{
HarBuilder
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
}
)
;
var
uid
=
1
;
const
trace
=
{
log
(
)
{
}
}
;
const
HarExporter
=
{
async
save
(
options
)
{
const
defaultFileName
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
defaultFileName
"
)
;
const
compress
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
compress
"
)
;
trace
.
log
(
"
HarExporter
.
save
;
"
+
defaultFileName
options
)
;
let
data
=
await
this
.
fetchHarData
(
options
)
;
const
host
=
new
URL
(
options
.
connector
.
currentTarget
.
url
)
;
if
(
typeof
options
.
isSingleRequest
!
=
"
boolean
"
)
{
options
.
isSingleRequest
=
false
;
}
const
fileName
=
HarUtils
.
getHarFileName
(
defaultFileName
options
.
jsonp
compress
host
.
hostname
options
.
isSingleRequest
&
&
options
.
items
.
length
?
new
URL
(
options
.
items
[
0
]
.
url
)
.
pathname
:
"
"
)
;
data
=
new
TextEncoder
(
)
.
encode
(
data
)
;
if
(
compress
)
{
const
file
=
await
DevToolsUtils
.
showSaveFileDialog
(
window
fileName
[
"
*
.
zip
"
]
)
;
this
.
_zip
(
file
fileName
.
replace
(
/
\
.
zip
/
"
"
)
data
.
buffer
)
;
}
else
{
DevToolsUtils
.
saveAs
(
window
data
fileName
)
;
}
}
_zip
(
file
fileName
buffer
)
{
const
ZipWriter
=
Components
.
Constructor
(
"
mozilla
.
org
/
zipwriter
;
1
"
"
nsIZipWriter
"
)
;
const
zipW
=
new
ZipWriter
(
)
;
file
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
lazy
.
FileUtils
.
PERMS_FILE
)
;
const
MODE_WRONLY
=
0x02
;
const
MODE_TRUNCATE
=
0x20
;
zipW
.
open
(
file
MODE_WRONLY
|
MODE_TRUNCATE
)
;
const
stream
=
Cc
[
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIArrayBufferInputStream
)
;
stream
.
setData
(
buffer
0
buffer
.
byteLength
)
;
const
time
=
Date
.
now
(
)
*
1000
;
zipW
.
addEntryStream
(
fileName
time
0
stream
false
)
;
zipW
.
close
(
)
;
}
copy
(
options
)
{
return
this
.
fetchHarData
(
options
)
.
then
(
jsonString
=
>
{
clipboardHelper
.
copyString
(
jsonString
)
;
return
jsonString
;
}
)
;
}
getHar
(
options
)
{
return
this
.
fetchHarData
(
options
)
.
then
(
data
=
>
{
return
data
?
JSON
.
parse
(
data
)
:
null
;
}
)
;
}
fetchHarData
(
options
)
{
options
.
id
=
options
.
id
|
|
uid
+
+
;
if
(
typeof
options
.
jsonp
!
=
"
boolean
"
)
{
options
.
jsonp
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
jsonp
"
)
;
}
if
(
typeof
options
.
includeResponseBodies
!
=
"
boolean
"
)
{
options
.
includeResponseBodies
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
includeResponseBodies
"
)
;
}
if
(
typeof
options
.
jsonpCallback
!
=
"
boolean
"
)
{
options
.
jsonpCallback
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
jsonpCallback
"
)
;
}
if
(
typeof
options
.
forceExport
!
=
"
boolean
"
)
{
options
.
forceExport
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
forceExport
"
)
;
}
if
(
typeof
options
.
supportsMultiplePages
!
=
"
boolean
"
)
{
options
.
supportsMultiplePages
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
multiple
-
pages
"
)
;
}
return
this
.
buildHarData
(
options
)
.
then
(
har
=
>
{
if
(
!
har
.
log
.
entries
.
length
&
&
!
options
.
forceExport
)
{
return
Promise
.
resolve
(
)
;
}
let
jsonString
=
this
.
stringify
(
har
)
;
if
(
!
jsonString
)
{
return
Promise
.
resolve
(
)
;
}
if
(
options
.
jsonp
)
{
const
callbackName
=
options
.
jsonpCallback
|
|
"
onInputData
"
;
jsonString
=
callbackName
+
"
(
"
+
jsonString
+
"
)
;
"
;
}
return
jsonString
;
}
)
.
catch
(
function
onError
(
err
)
{
console
.
error
(
err
)
;
}
)
;
}
async
buildHarData
(
options
)
{
options
.
connector
.
enableActions
(
false
)
;
const
builder
=
new
HarBuilder
(
options
)
;
const
result
=
await
builder
.
build
(
)
;
options
.
connector
.
enableActions
(
true
)
;
return
result
;
}
stringify
(
har
)
{
if
(
!
har
)
{
return
null
;
}
try
{
return
JSON
.
stringify
(
har
null
"
"
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
return
undefined
;
}
}
}
;
exports
.
HarExporter
=
HarExporter
;
