"
use
strict
"
;
const
{
TIMING_KEYS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
const
{
getUrlDetails
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
utils
/
request
-
utils
"
)
;
var
guid
=
0
;
var
HarImporter
=
function
(
actions
)
{
this
.
actions
=
actions
;
}
;
HarImporter
.
prototype
=
{
import
:
function
(
har
)
{
const
json
=
JSON
.
parse
(
har
)
;
this
.
doImport
(
json
)
;
}
doImport
:
function
(
har
)
{
this
.
actions
.
clearRequests
(
)
;
const
pages
=
new
Map
(
)
;
har
.
log
.
pages
.
forEach
(
page
=
>
{
pages
.
set
(
page
.
id
page
)
;
}
)
;
har
.
log
.
entries
.
forEach
(
entry
=
>
{
const
requestId
=
String
(
+
+
guid
)
;
const
startedMs
=
Date
.
parse
(
entry
.
startedDateTime
)
;
this
.
actions
.
addRequest
(
requestId
{
startedMs
:
startedMs
method
:
entry
.
request
.
method
url
:
entry
.
request
.
url
urlDetails
:
getUrlDetails
(
entry
.
request
.
url
)
isXHR
:
false
cause
:
{
loadingDocumentUri
:
"
"
stackTraceAvailable
:
false
type
:
"
"
}
fromCache
:
false
fromServiceWorker
:
false
}
false
)
;
const
data
=
{
requestHeaders
:
{
headers
:
entry
.
request
.
headers
headersSize
:
entry
.
request
.
headersSize
rawHeaders
:
"
"
}
responseHeaders
:
{
headers
:
entry
.
response
.
headers
headersSize
:
entry
.
response
.
headersSize
rawHeaders
:
"
"
}
requestCookies
:
entry
.
request
.
cookies
responseCookies
:
entry
.
response
.
cookies
requestPostData
:
{
postData
:
entry
.
request
.
postData
|
|
{
}
postDataDiscarded
:
false
}
responseContent
:
{
content
:
entry
.
response
.
content
contentDiscarded
:
false
}
eventTimings
:
{
timings
:
entry
.
timings
}
totalTime
:
TIMING_KEYS
.
reduce
(
(
sum
type
)
=
>
{
const
time
=
entry
.
timings
[
type
]
;
return
typeof
time
!
=
"
undefined
"
&
&
time
!
=
-
1
?
sum
+
time
:
sum
;
}
0
)
httpVersion
:
entry
.
request
.
httpVersion
contentSize
:
entry
.
response
.
content
.
size
mimeType
:
entry
.
response
.
content
.
mimeType
remoteAddress
:
entry
.
serverIPAddress
remotePort
:
entry
.
connection
status
:
entry
.
response
.
status
statusText
:
entry
.
response
.
statusText
transferredSize
:
entry
.
response
.
bodySize
securityState
:
entry
.
_securityState
eventTimingsAvailable
:
false
requestCookiesAvailable
:
false
requestHeadersAvailable
:
false
responseContentAvailable
:
false
responseStartAvailable
:
false
responseCookiesAvailable
:
false
responseHeadersAvailable
:
false
securityInfoAvailable
:
false
requestPostDataAvailable
:
false
}
;
if
(
entry
.
cache
.
afterRequest
)
{
const
{
afterRequest
}
=
entry
.
cache
;
data
.
responseCache
=
{
cache
:
{
expires
:
afterRequest
.
expires
fetchCount
:
afterRequest
.
fetchCount
lastFetched
:
afterRequest
.
lastFetched
eTag
:
afterRequest
.
eTag
_dataSize
:
afterRequest
.
_dataSize
_lastModified
:
afterRequest
.
_lastModified
_device
:
afterRequest
.
_device
}
}
;
}
this
.
actions
.
updateRequest
(
requestId
data
false
)
;
const
pageTimings
=
pages
.
get
(
entry
.
pageref
)
.
pageTimings
;
let
onContentLoad
=
pageTimings
.
onContentLoad
|
|
0
;
let
onLoad
=
pageTimings
.
onLoad
|
|
0
;
onContentLoad
=
onContentLoad
!
=
-
1
?
onContentLoad
:
0
;
onLoad
=
onLoad
!
=
-
1
?
onLoad
:
0
;
if
(
onContentLoad
>
0
)
{
this
.
actions
.
addTimingMarker
(
{
name
:
"
dom
-
interactive
"
time
:
startedMs
+
onContentLoad
}
)
;
}
if
(
onLoad
>
0
)
{
this
.
actions
.
addTimingMarker
(
{
name
:
"
dom
-
complete
"
time
:
startedMs
+
onLoad
}
)
;
}
}
)
;
}
}
;
exports
.
HarImporter
=
HarImporter
;
