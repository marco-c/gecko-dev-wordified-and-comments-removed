"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
HarCollector
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
collector
"
)
;
const
{
HarExporter
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
exporter
"
)
;
const
{
HarUtils
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
utils
"
)
;
const
{
getLongStringFullText
}
=
require
(
"
devtools
/
client
/
shared
/
string
-
utils
"
)
;
const
prefDomain
=
"
devtools
.
netmonitor
.
har
.
"
;
const
trace
=
{
log
(
.
.
.
args
)
{
}
}
;
function
HarAutomation
(
)
{
}
HarAutomation
.
prototype
=
{
async
initialize
(
toolbox
)
{
this
.
toolbox
=
toolbox
;
this
.
commands
=
toolbox
.
commands
;
await
this
.
startMonitoring
(
)
;
}
destroy
(
)
{
if
(
this
.
collector
)
{
this
.
collector
.
stop
(
)
;
}
if
(
this
.
tabWatcher
)
{
this
.
tabWatcher
.
disconnect
(
)
;
}
}
async
startMonitoring
(
)
{
await
this
.
toolbox
.
resourceCommand
.
watchResources
(
[
this
.
toolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
resources
=
>
{
if
(
resources
.
find
(
r
=
>
r
.
name
=
=
"
will
-
navigate
"
&
&
r
.
targetFront
.
isTopLevel
)
)
{
this
.
pageLoadBegin
(
)
;
}
if
(
resources
.
find
(
r
=
>
r
.
name
=
=
"
dom
-
complete
"
&
&
r
.
targetFront
.
isTopLevel
)
)
{
this
.
pageLoadDone
(
)
;
}
}
ignoreExistingResources
:
true
}
)
;
}
pageLoadBegin
(
response
)
{
this
.
resetCollector
(
)
;
}
resetCollector
(
)
{
if
(
this
.
collector
)
{
this
.
collector
.
stop
(
)
;
}
this
.
collector
=
new
HarCollector
(
{
commands
:
this
.
commands
}
)
;
this
.
collector
.
start
(
)
;
}
pageLoadDone
(
response
)
{
trace
.
log
(
"
HarAutomation
.
pageLoadDone
;
"
response
)
;
if
(
this
.
collector
)
{
this
.
collector
.
waitForHarLoad
(
)
.
then
(
collector
=
>
{
return
this
.
autoExport
(
)
;
}
)
;
}
}
autoExport
(
)
{
const
autoExport
=
Services
.
prefs
.
getBoolPref
(
prefDomain
+
"
enableAutoExportToFile
"
)
;
if
(
!
autoExport
)
{
return
Promise
.
resolve
(
)
;
}
const
data
=
{
fileName
:
Services
.
prefs
.
getCharPref
(
prefDomain
+
"
defaultFileName
"
)
}
;
return
this
.
executeExport
(
data
)
;
}
triggerExport
(
data
)
{
if
(
!
data
.
fileName
)
{
data
.
fileName
=
Services
.
prefs
.
getCharPref
(
prefDomain
+
"
defaultFileName
"
)
;
}
return
this
.
executeExport
(
data
)
;
}
clear
(
)
{
this
.
resetCollector
(
)
;
}
async
executeExport
(
data
)
{
const
items
=
this
.
collector
.
getItems
(
)
;
const
{
title
}
=
this
.
commands
.
targetCommand
.
targetFront
;
const
netMonitor
=
await
this
.
toolbox
.
getNetMonitorAPI
(
)
;
const
connector
=
await
netMonitor
.
getHarExportConnector
(
)
;
const
options
=
{
connector
requestData
:
null
getTimingMarker
:
null
getString
:
this
.
getString
.
bind
(
this
)
view
:
this
items
}
;
options
.
defaultFileName
=
data
.
fileName
;
options
.
compress
=
data
.
compress
;
options
.
title
=
data
.
title
|
|
title
;
options
.
id
=
data
.
id
;
options
.
jsonp
=
data
.
jsonp
;
options
.
includeResponseBodies
=
data
.
includeResponseBodies
;
options
.
jsonpCallback
=
data
.
jsonpCallback
;
options
.
forceExport
=
data
.
forceExport
;
trace
.
log
(
"
HarAutomation
.
executeExport
;
"
+
data
.
fileName
options
)
;
const
jsonString
=
await
HarExporter
.
fetchHarData
(
options
)
;
if
(
jsonString
&
&
options
.
defaultFileName
)
{
const
file
=
getDefaultTargetFile
(
options
)
;
if
(
file
)
{
HarUtils
.
saveToFile
(
file
jsonString
options
.
compress
)
;
}
}
return
jsonString
;
}
async
getString
(
stringGrip
)
{
const
fullText
=
await
getLongStringFullText
(
this
.
commands
.
client
stringGrip
)
;
return
fullText
;
}
}
;
function
getDefaultTargetFile
(
options
)
{
const
path
=
options
.
defaultLogDir
|
|
Services
.
prefs
.
getCharPref
(
"
devtools
.
netmonitor
.
har
.
defaultLogDir
"
)
;
const
folder
=
HarUtils
.
getLocalDirectory
(
path
)
;
const
tabTarget
=
options
.
connector
.
getTabTarget
(
)
;
const
host
=
new
URL
(
tabTarget
.
url
)
;
const
fileName
=
HarUtils
.
getHarFileName
(
options
.
defaultFileName
options
.
jsonp
options
.
compress
host
.
hostname
)
;
folder
.
append
(
fileName
)
;
folder
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
0666
"
8
)
)
;
return
folder
;
}
exports
.
HarAutomation
=
HarAutomation
;
