"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
appInfo
=
Services
.
appinfo
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
CurlUtils
}
=
require
(
"
devtools
/
client
/
shared
/
curl
"
)
;
const
{
getFormDataSections
getUrlQuery
parseQueryString
}
=
require
(
"
.
.
/
utils
/
request
-
utils
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
har
.
properties
"
)
;
const
HAR_VERSION
=
"
1
.
1
"
;
var
HarBuilder
=
function
(
options
)
{
this
.
_options
=
options
;
this
.
_pageMap
=
[
]
;
}
;
HarBuilder
.
prototype
=
{
build
:
async
function
(
)
{
this
.
promises
=
[
]
;
let
log
=
this
.
buildLog
(
)
;
for
(
let
file
of
this
.
_options
.
items
)
{
log
.
entries
.
push
(
await
this
.
buildEntry
(
log
file
)
)
;
}
await
Promise
.
all
(
this
.
promises
)
;
return
{
log
}
;
}
buildLog
:
function
(
)
{
return
{
version
:
HAR_VERSION
creator
:
{
name
:
appInfo
.
name
version
:
appInfo
.
version
}
browser
:
{
name
:
appInfo
.
name
version
:
appInfo
.
version
}
pages
:
[
]
entries
:
[
]
}
;
}
buildPage
:
function
(
file
)
{
let
page
=
{
}
;
page
.
startedDateTime
=
0
;
page
.
id
=
"
page_
"
+
this
.
_options
.
id
;
page
.
title
=
this
.
_options
.
title
;
return
page
;
}
getPage
:
function
(
log
file
)
{
let
id
=
this
.
_options
.
id
;
let
page
=
this
.
_pageMap
[
id
]
;
if
(
page
)
{
return
page
;
}
this
.
_pageMap
[
id
]
=
page
=
this
.
buildPage
(
file
)
;
log
.
pages
.
push
(
page
)
;
return
page
;
}
buildEntry
:
async
function
(
log
file
)
{
let
page
=
this
.
getPage
(
log
file
)
;
let
entry
=
{
}
;
entry
.
pageref
=
page
.
id
;
entry
.
startedDateTime
=
dateToJSON
(
new
Date
(
file
.
startedMillis
)
)
;
entry
.
time
=
file
.
endedMillis
-
file
.
startedMillis
;
entry
.
request
=
await
this
.
buildRequest
(
file
)
;
entry
.
response
=
await
this
.
buildResponse
(
file
)
;
entry
.
cache
=
this
.
buildCache
(
file
)
;
entry
.
timings
=
file
.
eventTimings
?
file
.
eventTimings
.
timings
:
{
}
;
if
(
file
.
remoteAddress
)
{
entry
.
serverIPAddress
=
file
.
remoteAddress
;
}
if
(
file
.
remotePort
)
{
entry
.
connection
=
file
.
remotePort
+
"
"
;
}
if
(
!
page
.
startedDateTime
)
{
page
.
startedDateTime
=
entry
.
startedDateTime
;
page
.
pageTimings
=
this
.
buildPageTimings
(
page
file
)
;
}
return
entry
;
}
buildPageTimings
:
function
(
page
file
)
{
let
timings
=
{
onContentLoad
:
-
1
onLoad
:
-
1
}
;
return
timings
;
}
buildRequest
:
async
function
(
file
)
{
let
requestHeaders
=
file
.
requestHeaders
;
if
(
!
requestHeaders
&
&
this
.
_options
.
requestData
)
{
requestHeaders
=
await
this
.
_options
.
requestData
(
file
.
id
"
requestHeaders
"
)
;
}
let
requestCookies
=
file
.
requestCookies
;
if
(
!
requestCookies
&
&
this
.
_options
.
requestData
)
{
requestCookies
=
await
this
.
_options
.
requestData
(
file
.
id
"
requestCookies
"
)
;
}
let
request
=
{
bodySize
:
0
}
;
request
.
method
=
file
.
method
;
request
.
url
=
file
.
url
;
request
.
httpVersion
=
file
.
httpVersion
|
|
"
"
;
request
.
headers
=
this
.
buildHeaders
(
requestHeaders
)
;
request
.
headers
=
this
.
appendHeadersPostData
(
request
.
headers
file
)
;
request
.
cookies
=
this
.
buildCookies
(
requestCookies
)
;
request
.
queryString
=
parseQueryString
(
getUrlQuery
(
file
.
url
)
)
|
|
[
]
;
request
.
headersSize
=
requestHeaders
.
headersSize
;
request
.
postData
=
await
this
.
buildPostData
(
file
)
;
if
(
request
.
postData
&
&
request
.
postData
.
text
)
{
request
.
bodySize
=
request
.
postData
.
text
.
length
;
}
return
request
;
}
buildHeaders
:
function
(
input
)
{
if
(
!
input
)
{
return
[
]
;
}
return
this
.
buildNameValuePairs
(
input
.
headers
)
;
}
appendHeadersPostData
:
function
(
input
=
[
]
file
)
{
if
(
!
file
.
requestPostData
)
{
return
input
;
}
this
.
fetchData
(
file
.
requestPostData
.
postData
.
text
)
.
then
(
value
=
>
{
let
multipartHeaders
=
CurlUtils
.
getHeadersFromMultipartText
(
value
)
;
for
(
let
header
of
multipartHeaders
)
{
input
.
push
(
header
)
;
}
}
)
;
return
input
;
}
buildCookies
:
function
(
input
)
{
if
(
!
input
)
{
return
[
]
;
}
return
this
.
buildNameValuePairs
(
input
.
cookies
)
;
}
buildNameValuePairs
:
function
(
entries
)
{
let
result
=
[
]
;
if
(
!
entries
)
{
return
result
;
}
entries
.
forEach
(
entry
=
>
{
this
.
fetchData
(
entry
.
value
)
.
then
(
value
=
>
{
result
.
push
(
{
name
:
entry
.
name
value
:
value
}
)
;
}
)
;
}
)
;
return
result
;
}
buildPostData
:
async
function
(
file
)
{
let
requestPostData
=
file
.
requestPostData
;
let
requestHeaders
=
file
.
requestHeaders
;
let
requestHeadersFromUploadStream
;
if
(
!
requestPostData
&
&
this
.
_options
.
requestData
)
{
let
payload
=
await
this
.
_options
.
requestData
(
file
.
id
"
requestPostData
"
)
;
requestPostData
=
payload
.
requestPostData
;
requestHeadersFromUploadStream
=
payload
.
requestHeadersFromUploadStream
;
}
if
(
!
requestPostData
.
postData
.
text
)
{
return
undefined
;
}
if
(
!
requestHeaders
&
&
this
.
_options
.
requestData
)
{
requestHeaders
=
await
this
.
_options
.
requestData
(
file
.
id
"
requestHeaders
"
)
;
}
let
postData
=
{
mimeType
:
findValue
(
requestHeaders
.
headers
"
content
-
type
"
)
params
:
[
]
text
:
requestPostData
.
postData
.
text
}
;
if
(
requestPostData
.
postDataDiscarded
)
{
postData
.
comment
=
L10N
.
getStr
(
"
har
.
requestBodyNotIncluded
"
)
;
return
postData
;
}
if
(
CurlUtils
.
isUrlEncodedRequest
(
{
headers
:
requestHeaders
.
headers
postDataText
:
postData
.
text
}
)
)
{
postData
.
mimeType
=
"
application
/
x
-
www
-
form
-
urlencoded
"
;
let
formDataSections
=
await
getFormDataSections
(
requestHeaders
requestHeadersFromUploadStream
requestPostData
this
.
_options
.
getString
)
;
formDataSections
.
forEach
(
(
section
)
=
>
{
let
paramsArray
=
parseQueryString
(
section
)
;
if
(
paramsArray
)
{
postData
.
params
=
[
.
.
.
postData
.
params
.
.
.
paramsArray
]
;
}
}
)
;
}
return
postData
;
}
buildResponse
:
async
function
(
file
)
{
let
responseHeaders
=
file
.
responseHeaders
;
if
(
!
responseHeaders
&
&
this
.
_options
.
requestData
)
{
responseHeaders
=
await
this
.
_options
.
requestData
(
file
.
id
"
responseHeaders
"
)
;
}
let
responseCookies
=
file
.
responseCookies
;
if
(
!
responseCookies
&
&
this
.
_options
.
requestData
)
{
responseCookies
=
await
this
.
_options
.
requestData
(
file
.
id
"
responseCookies
"
)
;
}
let
response
=
{
status
:
0
}
;
if
(
file
.
status
)
{
response
.
status
=
parseInt
(
file
.
status
10
)
;
}
response
.
statusText
=
file
.
statusText
|
|
"
"
;
response
.
httpVersion
=
file
.
httpVersion
|
|
"
"
;
response
.
headers
=
this
.
buildHeaders
(
responseHeaders
)
;
response
.
cookies
=
this
.
buildCookies
(
responseCookies
)
;
response
.
content
=
await
this
.
buildContent
(
file
)
;
let
headers
=
responseHeaders
?
responseHeaders
.
headers
:
null
;
let
headersSize
=
responseHeaders
?
responseHeaders
.
headersSize
:
-
1
;
response
.
redirectURL
=
findValue
(
headers
"
Location
"
)
;
response
.
headersSize
=
headersSize
;
if
(
typeof
file
.
transferredSize
!
=
"
number
"
)
{
response
.
bodySize
=
(
response
.
status
=
=
304
)
?
0
:
-
1
;
}
else
{
response
.
bodySize
=
file
.
transferredSize
;
}
return
response
;
}
buildContent
:
async
function
(
file
)
{
let
content
=
{
mimeType
:
file
.
mimeType
size
:
-
1
}
;
let
responseContent
=
file
.
responseContent
;
if
(
!
responseContent
&
&
this
.
_options
.
requestData
)
{
responseContent
=
await
this
.
_options
.
requestData
(
file
.
id
"
responseContent
"
)
;
}
if
(
responseContent
&
&
responseContent
.
content
)
{
content
.
size
=
responseContent
.
content
.
size
;
content
.
encoding
=
responseContent
.
content
.
encoding
;
}
let
includeBodies
=
this
.
_options
.
includeResponseBodies
;
let
contentDiscarded
=
responseContent
?
responseContent
.
contentDiscarded
:
false
;
if
(
!
includeBodies
|
|
contentDiscarded
)
{
content
.
comment
=
L10N
.
getStr
(
"
har
.
responseBodyNotIncluded
"
)
;
return
content
;
}
if
(
responseContent
)
{
let
text
=
responseContent
.
content
.
text
;
this
.
fetchData
(
text
)
.
then
(
value
=
>
{
content
.
text
=
value
;
}
)
;
}
return
content
;
}
buildCache
:
function
(
file
)
{
let
cache
=
{
}
;
if
(
!
file
.
fromCache
)
{
return
cache
;
}
if
(
file
.
cacheEntry
)
{
cache
.
afterRequest
=
this
.
buildCacheEntry
(
file
.
cacheEntry
)
;
}
else
{
cache
.
afterRequest
=
null
;
}
return
cache
;
}
buildCacheEntry
:
function
(
cacheEntry
)
{
let
cache
=
{
}
;
cache
.
expires
=
findValue
(
cacheEntry
"
Expires
"
)
;
cache
.
lastAccess
=
findValue
(
cacheEntry
"
Last
Fetched
"
)
;
cache
.
eTag
=
"
"
;
cache
.
hitCount
=
findValue
(
cacheEntry
"
Fetch
Count
"
)
;
return
cache
;
}
getBlockingEndTime
:
function
(
file
)
{
if
(
file
.
resolveStarted
&
&
file
.
connectStarted
)
{
return
file
.
resolvingTime
;
}
if
(
file
.
connectStarted
)
{
return
file
.
connectingTime
;
}
if
(
file
.
sendStarted
)
{
return
file
.
sendingTime
;
}
return
(
file
.
sendingTime
>
file
.
startTime
)
?
file
.
sendingTime
:
file
.
waitingForTime
;
}
fetchData
:
function
(
string
)
{
let
promise
=
this
.
_options
.
getString
(
string
)
.
then
(
value
=
>
{
return
value
;
}
)
;
this
.
promises
.
push
(
promise
)
;
return
promise
;
}
}
;
function
findValue
(
arr
name
)
{
if
(
!
arr
)
{
return
"
"
;
}
name
=
name
.
toLowerCase
(
)
;
let
result
=
arr
.
find
(
entry
=
>
entry
.
name
.
toLowerCase
(
)
=
=
name
)
;
return
result
?
result
.
value
:
"
"
;
}
function
dateToJSON
(
date
)
{
function
f
(
n
c
)
{
if
(
!
c
)
{
c
=
2
;
}
let
s
=
new
String
(
n
)
;
while
(
s
.
length
<
c
)
{
s
=
"
0
"
+
s
;
}
return
s
;
}
let
result
=
date
.
getFullYear
(
)
+
"
-
"
+
f
(
date
.
getMonth
(
)
+
1
)
+
"
-
"
+
f
(
date
.
getDate
(
)
)
+
"
T
"
+
f
(
date
.
getHours
(
)
)
+
"
:
"
+
f
(
date
.
getMinutes
(
)
)
+
"
:
"
+
f
(
date
.
getSeconds
(
)
)
+
"
.
"
+
f
(
date
.
getMilliseconds
(
)
3
)
;
let
offset
=
date
.
getTimezoneOffset
(
)
;
let
positive
=
offset
>
0
;
offset
=
Math
.
abs
(
offset
)
;
let
offsetHours
=
Math
.
floor
(
offset
/
60
)
;
let
offsetMinutes
=
Math
.
floor
(
offset
%
60
)
;
let
prettyOffset
=
(
positive
>
0
?
"
-
"
:
"
+
"
)
+
f
(
offsetHours
)
+
"
:
"
+
f
(
offsetMinutes
)
;
return
result
+
prettyOffset
;
}
exports
.
HarBuilder
=
HarBuilder
;
