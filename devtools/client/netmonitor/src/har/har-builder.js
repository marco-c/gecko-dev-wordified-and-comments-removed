"
use
strict
"
;
const
appInfo
=
Services
.
appinfo
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
{
CurlUtils
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
curl
.
js
"
)
;
const
{
getFormDataSections
getUrlQuery
parseQueryString
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
utils
/
request
-
utils
.
js
"
)
;
const
{
buildHarLog
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
-
utils
.
js
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
har
.
properties
"
)
;
const
{
TIMING_KEYS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
constants
.
js
"
)
;
class
HarBuilder
{
constructor
(
options
)
{
this
.
_connector
=
options
.
connector
;
this
.
_id
=
options
.
id
;
this
.
_includeResponseBodies
=
options
.
includeResponseBodies
;
this
.
_items
=
options
.
items
;
this
.
_pageId
=
options
.
supportsMultiplePages
?
0
:
options
.
id
;
this
.
_pageMap
=
[
]
;
this
.
_supportsMultiplePages
=
options
.
supportsMultiplePages
;
this
.
_url
=
this
.
_connector
.
currentTarget
.
url
;
}
async
build
(
)
{
this
.
promises
=
[
]
;
const
harLog
=
buildHarLog
(
appInfo
)
;
this
.
buildPages
(
harLog
.
log
)
;
for
(
const
request
of
this
.
_items
)
{
const
entry
=
await
this
.
buildEntry
(
harLog
.
log
request
)
;
if
(
entry
)
{
harLog
.
log
.
entries
.
push
(
entry
)
;
}
}
await
Promise
.
all
(
this
.
promises
)
;
return
harLog
;
}
buildPages
(
log
)
{
if
(
this
.
_supportsMultiplePages
)
{
this
.
buildPagesFromTargetTitles
(
log
)
;
}
else
if
(
this
.
_items
.
length
)
{
const
firstRequest
=
this
.
_items
[
0
]
;
const
page
=
this
.
buildPage
(
this
.
_url
firstRequest
)
;
log
.
pages
.
push
(
page
)
;
this
.
_pageMap
[
this
.
_id
]
=
page
;
}
}
buildPagesFromTargetTitles
(
log
)
{
const
{
initialURL
navigationRequests
}
=
this
.
_connector
.
getHarData
(
)
;
const
firstNavigationRequest
=
navigationRequests
[
0
]
;
const
firstRequest
=
this
.
_items
[
0
]
;
if
(
!
firstNavigationRequest
|
|
firstRequest
.
resourceId
!
=
=
firstNavigationRequest
.
resourceId
)
{
const
initialPage
=
this
.
buildPage
(
initialURL
firstRequest
)
;
log
.
pages
.
push
(
initialPage
)
;
}
for
(
const
request
of
navigationRequests
)
{
const
page
=
this
.
buildPage
(
request
.
url
request
)
;
log
.
pages
.
push
(
page
)
;
}
}
buildPage
(
url
networkEvent
)
{
const
page
=
{
}
;
page
.
id
=
"
page_
"
+
this
.
_pageId
;
page
.
pageTimings
=
this
.
buildPageTimings
(
page
networkEvent
)
;
page
.
startedDateTime
=
dateToHarString
(
new
Date
(
networkEvent
.
startedMs
)
)
;
page
.
title
=
url
;
this
.
_pageId
+
+
;
return
page
;
}
getPage
(
log
entry
)
{
const
existingPage
=
log
.
pages
.
findLast
(
(
{
startedDateTime
}
)
=
>
startedDateTime
<
=
entry
.
startedDateTime
)
;
if
(
!
existingPage
)
{
throw
new
Error
(
"
Could
not
find
a
page
for
request
:
"
+
entry
.
request
.
url
)
;
}
return
existingPage
;
}
async
buildEntry
(
log
networkEvent
)
{
const
entry
=
{
}
;
entry
.
startedDateTime
=
dateToHarString
(
new
Date
(
networkEvent
.
startedMs
)
)
;
let
{
eventTimings
id
}
=
networkEvent
;
try
{
if
(
!
eventTimings
&
&
this
.
_connector
.
requestData
)
{
eventTimings
=
await
this
.
_connector
.
requestData
(
id
"
eventTimings
"
)
;
}
entry
.
request
=
await
this
.
buildRequest
(
networkEvent
)
;
entry
.
response
=
await
this
.
buildResponse
(
networkEvent
)
;
entry
.
cache
=
await
this
.
buildCache
(
networkEvent
)
;
}
catch
(
e
)
{
console
.
warn
(
"
HAR
builder
failed
on
"
networkEvent
.
url
e
e
.
stack
)
;
return
null
;
}
entry
.
timings
=
eventTimings
?
eventTimings
.
timings
:
{
}
;
entry
.
time
=
TIMING_KEYS
.
reduce
(
(
sum
type
)
=
>
{
const
time
=
entry
.
timings
[
type
]
;
return
typeof
time
!
=
"
undefined
"
&
&
time
!
=
-
1
?
sum
+
time
:
sum
;
}
0
)
;
entry
.
_securityState
=
networkEvent
.
securityState
;
if
(
networkEvent
.
remoteAddress
)
{
entry
.
serverIPAddress
=
networkEvent
.
remoteAddress
;
}
if
(
networkEvent
.
remotePort
)
{
entry
.
connection
=
networkEvent
.
remotePort
+
"
"
;
}
const
page
=
this
.
getPage
(
log
entry
)
;
entry
.
pageref
=
page
.
id
;
return
entry
;
}
buildPageTimings
(
)
{
const
timings
=
{
onContentLoad
:
-
1
onLoad
:
-
1
}
;
if
(
this
.
_connector
.
getTimingMarker
)
{
timings
.
onContentLoad
=
this
.
_connector
.
getTimingMarker
(
"
firstDocumentDOMContentLoadedTimestamp
"
)
;
timings
.
onLoad
=
this
.
_connector
.
getTimingMarker
(
"
firstDocumentLoadTimestamp
"
)
;
}
return
timings
;
}
async
buildRequest
(
networkEvent
)
{
let
{
id
requestHeaders
}
=
networkEvent
;
if
(
!
requestHeaders
&
&
this
.
_connector
.
requestData
)
{
requestHeaders
=
await
this
.
_connector
.
requestData
(
id
"
requestHeaders
"
)
;
}
let
{
requestCookies
}
=
networkEvent
;
if
(
!
requestCookies
&
&
this
.
_connector
.
requestData
)
{
requestCookies
=
await
this
.
_connector
.
requestData
(
id
"
requestCookies
"
)
;
}
const
request
=
{
bodySize
:
0
}
;
request
.
method
=
networkEvent
.
method
;
request
.
url
=
networkEvent
.
url
;
request
.
httpVersion
=
networkEvent
.
httpVersion
|
|
"
"
;
request
.
headers
=
this
.
buildHeaders
(
requestHeaders
)
;
request
.
headers
=
this
.
appendHeadersPostData
(
request
.
headers
networkEvent
)
;
request
.
cookies
=
this
.
buildCookies
(
requestCookies
)
;
request
.
queryString
=
parseQueryString
(
getUrlQuery
(
networkEvent
.
url
)
)
|
|
[
]
;
request
.
headersSize
=
requestHeaders
.
headersSize
;
request
.
postData
=
await
this
.
buildPostData
(
networkEvent
)
;
if
(
request
.
postData
?
.
text
)
{
request
.
bodySize
=
request
.
postData
.
text
.
length
;
}
return
request
;
}
buildHeaders
(
input
)
{
if
(
!
input
)
{
return
[
]
;
}
return
this
.
buildNameValuePairs
(
input
.
headers
)
;
}
appendHeadersPostData
(
input
=
[
]
networkEvent
)
{
if
(
!
networkEvent
.
requestPostData
)
{
return
input
;
}
this
.
fetchData
(
networkEvent
.
requestPostData
.
postData
.
text
)
.
then
(
value
=
>
{
const
multipartHeaders
=
CurlUtils
.
getHeadersFromMultipartText
(
value
)
;
for
(
const
header
of
multipartHeaders
)
{
input
.
push
(
header
)
;
}
}
)
;
return
input
;
}
buildCookies
(
input
)
{
if
(
!
input
)
{
return
[
]
;
}
return
this
.
buildNameValuePairs
(
input
.
cookies
|
|
input
)
;
}
buildNameValuePairs
(
entries
)
{
const
result
=
[
]
;
if
(
!
entries
)
{
return
result
;
}
entries
.
forEach
(
entry
=
>
{
this
.
fetchData
(
entry
.
value
)
.
then
(
value
=
>
{
result
.
push
(
{
name
:
entry
.
name
value
}
)
;
}
)
;
}
)
;
return
result
;
}
async
buildPostData
(
networkEvent
)
{
let
{
id
requestHeaders
requestPostData
}
=
networkEvent
;
let
requestHeadersFromUploadStream
;
if
(
!
requestPostData
&
&
this
.
_connector
.
requestData
)
{
requestPostData
=
await
this
.
_connector
.
requestData
(
id
"
requestPostData
"
)
;
requestHeadersFromUploadStream
=
requestPostData
.
uploadHeaders
;
}
if
(
!
requestPostData
.
postData
.
text
)
{
return
undefined
;
}
if
(
!
requestHeaders
&
&
this
.
_connector
.
requestData
)
{
requestHeaders
=
await
this
.
_connector
.
requestData
(
id
"
requestHeaders
"
)
;
}
const
postData
=
{
mimeType
:
findValue
(
requestHeaders
.
headers
"
content
-
type
"
)
params
:
[
]
text
:
requestPostData
.
postData
.
text
}
;
if
(
requestPostData
.
postDataDiscarded
)
{
postData
.
comment
=
L10N
.
getStr
(
"
har
.
requestBodyNotIncluded
"
)
;
return
postData
;
}
if
(
CurlUtils
.
isUrlEncodedRequest
(
{
headers
:
requestHeaders
.
headers
postDataText
:
postData
.
text
}
)
)
{
postData
.
mimeType
=
"
application
/
x
-
www
-
form
-
urlencoded
"
;
const
formDataSections
=
await
getFormDataSections
(
requestHeaders
requestHeadersFromUploadStream
requestPostData
this
.
_connector
.
getLongString
)
;
formDataSections
.
forEach
(
section
=
>
{
const
paramsArray
=
parseQueryString
(
section
)
;
if
(
paramsArray
)
{
postData
.
params
=
[
.
.
.
postData
.
params
.
.
.
paramsArray
]
;
}
}
)
;
}
return
postData
;
}
async
buildResponse
(
networkEvent
)
{
let
{
id
responseCookies
responseHeaders
}
=
networkEvent
;
if
(
!
responseHeaders
&
&
this
.
_connector
.
requestData
)
{
responseHeaders
=
await
this
.
_connector
.
requestData
(
id
"
responseHeaders
"
)
;
}
if
(
!
responseCookies
&
&
this
.
_connector
.
requestData
)
{
responseCookies
=
await
this
.
_connector
.
requestData
(
id
"
responseCookies
"
)
;
}
const
response
=
{
status
:
0
}
;
if
(
networkEvent
.
status
)
{
response
.
status
=
parseInt
(
networkEvent
.
status
10
)
;
}
response
.
statusText
=
networkEvent
.
statusText
|
|
"
"
;
response
.
httpVersion
=
networkEvent
.
httpVersion
|
|
"
"
;
response
.
headers
=
this
.
buildHeaders
(
responseHeaders
)
;
response
.
cookies
=
this
.
buildCookies
(
responseCookies
)
;
response
.
content
=
await
this
.
buildContent
(
networkEvent
)
;
const
headers
=
responseHeaders
?
responseHeaders
.
headers
:
null
;
const
headersSize
=
responseHeaders
?
responseHeaders
.
headersSize
:
-
1
;
response
.
redirectURL
=
findValue
(
headers
"
Location
"
)
;
response
.
headersSize
=
headersSize
;
if
(
typeof
networkEvent
.
transferredSize
!
=
"
number
"
)
{
response
.
bodySize
=
response
.
status
=
=
304
?
0
:
-
1
;
}
else
{
response
.
bodySize
=
networkEvent
.
transferredSize
;
}
return
response
;
}
async
buildContent
(
networkEvent
)
{
const
content
=
{
mimeType
:
networkEvent
.
mimeType
size
:
-
1
}
;
let
{
responseContent
}
=
networkEvent
;
if
(
!
responseContent
&
&
this
.
_connector
.
requestData
)
{
responseContent
=
await
this
.
_connector
.
requestData
(
networkEvent
.
id
"
responseContent
"
)
;
}
if
(
responseContent
?
.
content
)
{
content
.
size
=
responseContent
.
content
.
size
;
content
.
encoding
=
responseContent
.
content
.
encoding
;
}
const
includeBodies
=
this
.
_includeResponseBodies
;
const
contentDiscarded
=
responseContent
?
responseContent
.
contentDiscarded
:
false
;
if
(
!
includeBodies
|
|
contentDiscarded
)
{
content
.
comment
=
L10N
.
getStr
(
"
har
.
responseBodyNotIncluded
"
)
;
return
content
;
}
if
(
responseContent
)
{
const
{
text
}
=
responseContent
.
content
;
this
.
fetchData
(
text
)
.
then
(
value
=
>
{
content
.
text
=
value
;
}
)
;
}
return
content
;
}
async
buildCache
(
networkEvent
)
{
const
cache
=
{
}
;
if
(
networkEvent
.
status
!
=
"
304
"
)
{
return
cache
;
}
if
(
networkEvent
.
responseCacheAvailable
&
&
this
.
_connector
.
requestData
)
{
const
responseCache
=
await
this
.
_connector
.
requestData
(
networkEvent
.
id
"
responseCache
"
)
;
if
(
responseCache
.
cache
)
{
cache
.
afterRequest
=
this
.
buildCacheEntry
(
responseCache
.
cache
)
;
}
}
else
if
(
networkEvent
.
responseCache
?
.
cache
)
{
cache
.
afterRequest
=
this
.
buildCacheEntry
(
networkEvent
.
responseCache
.
cache
)
;
}
else
{
cache
.
afterRequest
=
null
;
}
return
cache
;
}
buildCacheEntry
(
cacheEntry
)
{
const
cache
=
{
}
;
if
(
typeof
cacheEntry
!
=
=
"
undefined
"
)
{
cache
.
expires
=
findKeys
(
cacheEntry
[
"
expirationTime
"
"
expires
"
]
)
;
cache
.
lastFetched
=
findKeys
(
cacheEntry
[
"
lastFetched
"
]
)
;
cache
.
fetchCount
=
findKeys
(
cacheEntry
[
"
fetchCount
"
]
)
;
cache
.
_dataSize
=
findKeys
(
cacheEntry
[
"
storageDataSize
"
"
_dataSize
"
]
)
;
cache
.
_lastModified
=
findKeys
(
cacheEntry
[
"
lastModified
"
"
_lastModified
"
]
)
;
cache
.
_device
=
findKeys
(
cacheEntry
[
"
deviceID
"
"
_device
"
]
)
;
}
return
cache
;
}
fetchData
(
string
)
{
const
promise
=
this
.
_connector
.
getLongString
(
string
)
.
then
(
value
=
>
{
return
value
;
}
)
;
this
.
promises
.
push
(
promise
)
;
return
promise
;
}
}
function
findKeys
(
obj
keys
)
{
if
(
!
keys
)
{
return
"
"
;
}
const
keyFound
=
keys
.
filter
(
key
=
>
obj
[
key
]
)
;
if
(
!
keys
.
length
)
{
return
"
"
;
}
const
value
=
obj
[
keyFound
[
0
]
]
;
if
(
typeof
value
=
=
=
"
undefined
"
|
|
typeof
value
=
=
=
"
object
"
)
{
return
"
"
;
}
return
String
(
value
)
;
}
function
findValue
(
arr
name
)
{
if
(
!
arr
)
{
return
"
"
;
}
name
=
name
.
toLowerCase
(
)
;
const
result
=
arr
.
find
(
entry
=
>
entry
.
name
.
toLowerCase
(
)
=
=
name
)
;
return
result
?
result
.
value
:
"
"
;
}
function
dateToHarString
(
date
)
{
function
f
(
n
c
)
{
if
(
!
c
)
{
c
=
2
;
}
let
s
=
String
(
n
)
;
while
(
s
.
length
<
c
)
{
s
=
"
0
"
+
s
;
}
return
s
;
}
const
result
=
date
.
getFullYear
(
)
+
"
-
"
+
f
(
date
.
getMonth
(
)
+
1
)
+
"
-
"
+
f
(
date
.
getDate
(
)
)
+
"
T
"
+
f
(
date
.
getHours
(
)
)
+
"
:
"
+
f
(
date
.
getMinutes
(
)
)
+
"
:
"
+
f
(
date
.
getSeconds
(
)
)
+
"
.
"
+
f
(
date
.
getMilliseconds
(
)
3
)
;
let
offset
=
date
.
getTimezoneOffset
(
)
;
const
positive
=
offset
>
0
;
offset
=
Math
.
abs
(
offset
)
;
const
offsetHours
=
Math
.
floor
(
offset
/
60
)
;
const
offsetMinutes
=
Math
.
floor
(
offset
%
60
)
;
const
prettyOffset
=
(
positive
>
0
?
"
-
"
:
"
+
"
)
+
f
(
offsetHours
)
+
"
:
"
+
f
(
offsetMinutes
)
;
return
result
+
prettyOffset
;
}
exports
.
HarBuilder
=
HarBuilder
;
