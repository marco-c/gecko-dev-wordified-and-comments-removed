"
use
strict
"
;
const
Emitter
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
components
/
messages
/
parsers
/
socket
-
io
/
component
-
emitter
.
js
"
)
;
const
binary
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
components
/
messages
/
parsers
/
socket
-
io
/
binary
.
js
"
)
;
const
isBuf
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
components
/
messages
/
parsers
/
socket
-
io
/
is
-
buffer
.
js
"
)
;
const
TYPES
=
[
"
CONNECT
"
"
DISCONNECT
"
"
EVENT
"
"
ACK
"
"
ERROR
"
"
BINARY_EVENT
"
"
BINARY_ACK
"
]
;
const
CONNECT
=
0
;
const
DISCONNECT
=
1
;
const
EVENT
=
2
;
const
ACK
=
3
;
const
ERROR
=
4
;
const
BINARY_EVENT
=
5
;
const
BINARY_ACK
=
6
;
function
Decoder
(
)
{
this
.
reconstructor
=
null
;
}
Emitter
(
Decoder
.
prototype
)
;
function
BinaryReconstructor
(
packet
)
{
this
.
reconPack
=
packet
;
this
.
buffers
=
[
]
;
}
BinaryReconstructor
.
prototype
.
takeBinaryData
=
function
(
binData
)
{
this
.
buffers
.
push
(
binData
)
;
if
(
this
.
buffers
.
length
=
=
=
this
.
reconPack
.
attachments
)
{
const
packet
=
binary
.
reconstructPacket
(
this
.
reconPack
this
.
buffers
)
;
this
.
finishedReconstruction
(
)
;
return
packet
;
}
return
null
;
}
;
BinaryReconstructor
.
prototype
.
finishedReconstruction
=
function
(
)
{
this
.
reconPack
=
null
;
this
.
buffers
=
[
]
;
}
;
Decoder
.
prototype
.
add
=
function
(
obj
)
{
let
packet
;
if
(
typeof
obj
=
=
=
"
string
"
)
{
packet
=
decodeString
(
obj
)
;
if
(
BINARY_EVENT
=
=
=
packet
.
type
|
|
BINARY_ACK
=
=
=
packet
.
type
)
{
this
.
reconstructor
=
new
BinaryReconstructor
(
packet
)
;
if
(
this
.
reconstructor
.
reconPack
.
attachments
=
=
=
0
)
{
this
.
emit
(
"
decoded
"
packet
)
;
}
}
else
{
this
.
emit
(
"
decoded
"
packet
)
;
}
}
else
if
(
isBuf
(
obj
)
|
|
obj
.
base64
)
{
if
(
!
this
.
reconstructor
)
{
throw
new
Error
(
"
got
binary
data
when
not
reconstructing
a
packet
"
)
;
}
else
{
packet
=
this
.
reconstructor
.
takeBinaryData
(
obj
)
;
if
(
packet
)
{
this
.
reconstructor
=
null
;
this
.
emit
(
"
decoded
"
packet
)
;
}
}
}
else
{
throw
new
Error
(
"
Unknown
type
:
"
+
obj
)
;
}
}
;
function
decodeString
(
str
)
{
let
i
=
0
;
const
p
=
{
type
:
Number
(
str
.
charAt
(
0
)
)
}
;
if
(
TYPES
[
p
.
type
]
=
=
null
)
{
return
error
(
"
unknown
packet
type
"
+
p
.
type
)
;
}
if
(
BINARY_EVENT
=
=
=
p
.
type
|
|
BINARY_ACK
=
=
=
p
.
type
)
{
let
buf
=
"
"
;
while
(
str
.
charAt
(
+
+
i
)
!
=
=
"
-
"
)
{
buf
+
=
str
.
charAt
(
i
)
;
if
(
i
=
=
=
str
.
length
)
{
break
;
}
}
if
(
buf
!
=
Number
(
buf
)
|
|
str
.
charAt
(
i
)
!
=
=
"
-
"
)
{
throw
new
Error
(
"
Illegal
attachments
"
)
;
}
p
.
attachments
=
Number
(
buf
)
;
}
if
(
str
.
charAt
(
i
+
1
)
=
=
=
"
/
"
)
{
p
.
nsp
=
"
"
;
while
(
+
+
i
)
{
const
c
=
str
.
charAt
(
i
)
;
if
(
c
=
=
=
"
"
)
{
break
;
}
p
.
nsp
+
=
c
;
if
(
i
=
=
=
str
.
length
)
{
break
;
}
}
}
else
{
p
.
nsp
=
"
/
"
;
}
const
next
=
str
.
charAt
(
i
+
1
)
;
if
(
next
!
=
=
"
"
&
&
Number
(
next
)
=
=
next
)
{
p
.
id
=
"
"
;
while
(
+
+
i
)
{
const
c
=
str
.
charAt
(
i
)
;
if
(
c
=
=
null
|
|
Number
(
c
)
!
=
c
)
{
-
-
i
;
break
;
}
p
.
id
+
=
str
.
charAt
(
i
)
;
if
(
i
=
=
=
str
.
length
)
{
break
;
}
}
p
.
id
=
Number
(
p
.
id
)
;
}
if
(
str
.
charAt
(
+
+
i
)
)
{
const
payload
=
tryParse
(
str
.
substr
(
i
)
)
;
const
isPayloadValid
=
payload
!
=
=
false
&
&
(
p
.
type
=
=
=
ERROR
|
|
Array
.
isArray
(
payload
)
)
;
if
(
isPayloadValid
)
{
p
.
data
=
payload
;
}
else
{
return
error
(
"
invalid
payload
"
)
;
}
}
return
p
;
}
function
tryParse
(
str
)
{
try
{
return
JSON
.
parse
(
str
)
;
}
catch
(
e
)
{
return
false
;
}
}
Decoder
.
prototype
.
destroy
=
function
(
)
{
if
(
this
.
reconstructor
)
{
this
.
reconstructor
.
finishedReconstruction
(
)
;
}
}
;
function
error
(
msg
)
{
return
{
type
:
ERROR
data
:
"
parser
error
:
"
+
msg
}
;
}
module
.
exports
=
Decoder
;
