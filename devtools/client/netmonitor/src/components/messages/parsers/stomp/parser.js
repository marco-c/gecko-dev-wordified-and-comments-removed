"
use
strict
"
;
const
NULL
=
0
;
const
LF
=
10
;
const
CR
=
13
;
const
COLON
=
58
;
class
Parser
{
constructor
(
onFrame
onIncomingPing
)
{
this
.
onFrame
=
onFrame
;
this
.
onIncomingPing
=
onIncomingPing
;
this
.
_encoder
=
new
TextEncoder
(
)
;
this
.
_decoder
=
new
TextDecoder
(
)
;
this
.
_token
=
[
]
;
this
.
_initState
(
)
;
}
parseChunk
(
segment
appendMissingNULLonIncoming
=
false
)
{
let
chunk
;
if
(
segment
instanceof
ArrayBuffer
)
{
chunk
=
new
Uint8Array
(
segment
)
;
}
else
{
chunk
=
this
.
_encoder
.
encode
(
segment
)
;
}
if
(
appendMissingNULLonIncoming
&
&
chunk
[
chunk
.
length
-
1
]
!
=
=
0
)
{
const
chunkWithNull
=
new
Uint8Array
(
chunk
.
length
+
1
)
;
chunkWithNull
.
set
(
chunk
0
)
;
chunkWithNull
[
chunk
.
length
]
=
0
;
chunk
=
chunkWithNull
;
}
for
(
let
i
=
0
;
i
<
chunk
.
length
;
i
+
+
)
{
const
byte
=
chunk
[
i
]
;
this
.
_onByte
(
byte
)
;
}
}
_collectFrame
(
byte
)
{
if
(
byte
=
=
=
NULL
)
{
return
;
}
if
(
byte
=
=
=
CR
)
{
return
;
}
if
(
byte
=
=
=
LF
)
{
this
.
onIncomingPing
(
)
;
return
;
}
this
.
_onByte
=
this
.
_collectCommand
;
this
.
_reinjectByte
(
byte
)
;
}
_collectCommand
(
byte
)
{
if
(
byte
=
=
=
CR
)
{
return
;
}
if
(
byte
=
=
=
LF
)
{
this
.
_results
.
command
=
this
.
_consumeTokenAsUTF8
(
)
;
this
.
_onByte
=
this
.
_collectHeaders
;
return
;
}
this
.
_consumeByte
(
byte
)
;
}
_collectHeaders
(
byte
)
{
if
(
byte
=
=
=
CR
)
{
return
;
}
if
(
byte
=
=
=
LF
)
{
this
.
_setupCollectBody
(
)
;
return
;
}
this
.
_onByte
=
this
.
_collectHeaderKey
;
this
.
_reinjectByte
(
byte
)
;
}
_reinjectByte
(
byte
)
{
this
.
_onByte
(
byte
)
;
}
_collectHeaderKey
(
byte
)
{
if
(
byte
=
=
=
COLON
)
{
this
.
_headerKey
=
this
.
_consumeTokenAsUTF8
(
)
;
this
.
_onByte
=
this
.
_collectHeaderValue
;
return
;
}
this
.
_consumeByte
(
byte
)
;
}
_collectHeaderValue
(
byte
)
{
if
(
byte
=
=
=
CR
)
{
return
;
}
if
(
byte
=
=
=
LF
)
{
this
.
_results
.
headers
.
push
(
[
this
.
_headerKey
this
.
_consumeTokenAsUTF8
(
)
]
)
;
this
.
_headerKey
=
undefined
;
this
.
_onByte
=
this
.
_collectHeaders
;
return
;
}
this
.
_consumeByte
(
byte
)
;
}
_setupCollectBody
(
)
{
const
contentLengthHeader
=
this
.
_results
.
headers
.
filter
(
header
=
>
{
return
header
[
0
]
=
=
=
"
content
-
length
"
;
}
)
[
0
]
;
if
(
contentLengthHeader
)
{
this
.
_bodyBytesRemaining
=
parseInt
(
contentLengthHeader
[
1
]
10
)
;
this
.
_onByte
=
this
.
_collectBodyFixedSize
;
}
else
{
this
.
_onByte
=
this
.
_collectBodyNullTerminated
;
}
}
_collectBodyNullTerminated
(
byte
)
{
if
(
byte
=
=
=
NULL
)
{
this
.
_retrievedBody
(
)
;
return
;
}
this
.
_consumeByte
(
byte
)
;
}
_collectBodyFixedSize
(
byte
)
{
if
(
this
.
_bodyBytesRemaining
-
-
=
=
=
0
)
{
this
.
_retrievedBody
(
)
;
return
;
}
this
.
_consumeByte
(
byte
)
;
}
_retrievedBody
(
)
{
this
.
_results
.
binaryBody
=
this
.
_consumeTokenAsRaw
(
)
;
this
.
onFrame
(
this
.
_results
)
;
this
.
_initState
(
)
;
}
_consumeByte
(
byte
)
{
this
.
_token
.
push
(
byte
)
;
}
_consumeTokenAsUTF8
(
)
{
return
this
.
_decoder
.
decode
(
this
.
_consumeTokenAsRaw
(
)
)
;
}
_consumeTokenAsRaw
(
)
{
const
rawResult
=
new
Uint8Array
(
this
.
_token
)
;
this
.
_token
=
[
]
;
return
rawResult
;
}
_initState
(
)
{
this
.
_results
=
{
command
:
undefined
headers
:
[
]
binaryBody
:
undefined
}
;
this
.
_token
=
[
]
;
this
.
_headerKey
=
undefined
;
this
.
_onByte
=
this
.
_collectFrame
;
}
}
module
.
exports
=
{
Parser
}
;
