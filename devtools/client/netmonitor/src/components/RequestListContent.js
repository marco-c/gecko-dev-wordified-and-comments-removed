"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
visibility
-
handler
-
connect
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
Actions
=
require
(
"
.
.
/
actions
/
index
"
)
;
const
{
formDataURI
}
=
require
(
"
.
.
/
utils
/
request
-
utils
"
)
;
const
{
getDisplayedRequests
getColumns
getSelectedRequest
getWaterfallScale
}
=
require
(
"
.
.
/
selectors
/
index
"
)
;
loader
.
lazyRequireGetter
(
this
"
openRequestInTab
"
"
devtools
/
client
/
netmonitor
/
src
/
utils
/
firefox
/
open
-
request
-
in
-
tab
"
true
)
;
loader
.
lazyGetter
(
this
"
setImageTooltip
"
function
(
)
{
return
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
ImageTooltipHelper
"
)
.
setImageTooltip
;
}
)
;
loader
.
lazyGetter
(
this
"
getImageDimensions
"
function
(
)
{
return
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
ImageTooltipHelper
"
)
.
getImageDimensions
;
}
)
;
const
RequestListHeader
=
createFactory
(
require
(
"
.
/
RequestListHeader
"
)
)
;
const
RequestListItem
=
createFactory
(
require
(
"
.
/
RequestListItem
"
)
)
;
const
RequestListContextMenu
=
require
(
"
.
.
/
widgets
/
RequestListContextMenu
"
)
;
const
{
div
}
=
dom
;
const
REQUESTS_TOOLTIP_TOGGLE_DELAY
=
500
;
const
REQUESTS_TOOLTIP_IMAGE_MAX_DIM
=
400
;
const
MAX_SCROLL_HEIGHT
=
2147483647
;
const
LEFT_MOUSE_BUTTON
=
0
;
const
RIGHT_MOUSE_BUTTON
=
2
;
class
RequestListContent
extends
Component
{
static
get
propTypes
(
)
{
return
{
blockedUrls
:
PropTypes
.
array
.
isRequired
connector
:
PropTypes
.
object
.
isRequired
columns
:
PropTypes
.
object
.
isRequired
networkDetailsOpen
:
PropTypes
.
bool
.
isRequired
networkDetailsWidth
:
PropTypes
.
number
networkDetailsHeight
:
PropTypes
.
number
cloneRequest
:
PropTypes
.
func
.
isRequired
clickedRequest
:
PropTypes
.
object
openDetailsPanelTab
:
PropTypes
.
func
.
isRequired
sendCustomRequest
:
PropTypes
.
func
.
isRequired
displayedRequests
:
PropTypes
.
array
.
isRequired
firstRequestStartedMs
:
PropTypes
.
number
.
isRequired
fromCache
:
PropTypes
.
bool
onCauseBadgeMouseDown
:
PropTypes
.
func
.
isRequired
onItemRightMouseButtonDown
:
PropTypes
.
func
.
isRequired
onItemMouseDown
:
PropTypes
.
func
.
isRequired
onSecurityIconMouseDown
:
PropTypes
.
func
.
isRequired
onSelectDelta
:
PropTypes
.
func
.
isRequired
onWaterfallMouseDown
:
PropTypes
.
func
.
isRequired
openStatistics
:
PropTypes
.
func
.
isRequired
openRequestBlockingAndAddUrl
:
PropTypes
.
func
.
isRequired
openRequestBlockingAndDisableUrls
:
PropTypes
.
func
.
isRequired
removeBlockedUrl
:
PropTypes
.
func
.
isRequired
scale
:
PropTypes
.
number
selectRequest
:
PropTypes
.
func
.
isRequired
selectedRequest
:
PropTypes
.
object
requestFilterTypes
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
isScrolledToBottom
=
this
.
isScrolledToBottom
.
bind
(
this
)
;
this
.
onHover
=
this
.
onHover
.
bind
(
this
)
;
this
.
onScroll
=
this
.
onScroll
.
bind
(
this
)
;
this
.
onResize
=
this
.
onResize
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
openRequestInTab
=
this
.
openRequestInTab
.
bind
(
this
)
;
this
.
onDoubleClick
=
this
.
onDoubleClick
.
bind
(
this
)
;
this
.
onContextMenu
=
this
.
onContextMenu
.
bind
(
this
)
;
this
.
onFocusedNodeChange
=
this
.
onFocusedNodeChange
.
bind
(
this
)
;
this
.
onMouseDown
=
this
.
onMouseDown
.
bind
(
this
)
;
}
componentWillMount
(
)
{
this
.
tooltip
=
new
HTMLTooltip
(
window
.
parent
.
document
{
type
:
"
arrow
"
}
)
;
window
.
addEventListener
(
"
resize
"
this
.
onResize
)
;
}
componentDidMount
(
)
{
this
.
tooltip
.
startTogglingOnHover
(
this
.
refs
.
scrollEl
this
.
onHover
{
toggleDelay
:
REQUESTS_TOOLTIP_TOGGLE_DELAY
interactive
:
true
}
)
;
this
.
refs
.
scrollEl
.
addEventListener
(
"
scroll
"
this
.
onScroll
true
)
;
this
.
onResize
(
)
;
}
componentWillUpdate
(
nextProps
)
{
this
.
shouldScrollBottom
=
this
.
isScrolledToBottom
(
)
;
}
componentDidUpdate
(
prevProps
)
{
const
node
=
this
.
refs
.
scrollEl
;
if
(
this
.
shouldScrollBottom
&
&
node
.
scrollTop
!
=
=
MAX_SCROLL_HEIGHT
)
{
node
.
scrollTop
=
MAX_SCROLL_HEIGHT
;
}
if
(
prevProps
.
networkDetailsOpen
!
=
=
this
.
props
.
networkDetailsOpen
|
|
prevProps
.
networkDetailsWidth
!
=
=
this
.
props
.
networkDetailsWidth
|
|
prevProps
.
networkDetailsHeight
!
=
=
this
.
props
.
networkDetailsHeight
)
{
this
.
onResize
(
)
;
}
}
componentWillUnmount
(
)
{
this
.
refs
.
scrollEl
.
removeEventListener
(
"
scroll
"
this
.
onScroll
true
)
;
this
.
tooltip
.
stopTogglingOnHover
(
)
;
window
.
removeEventListener
(
"
resize
"
this
.
onResize
)
;
}
onResize
(
)
{
const
parent
=
this
.
refs
.
scrollEl
.
parentNode
;
this
.
refs
.
scrollEl
.
style
.
width
=
parent
.
offsetWidth
+
"
px
"
;
this
.
refs
.
scrollEl
.
style
.
height
=
parent
.
offsetHeight
+
"
px
"
;
}
isScrolledToBottom
(
)
{
const
{
scrollEl
rowGroupEl
}
=
this
.
refs
;
const
lastChildEl
=
rowGroupEl
.
lastElementChild
;
if
(
!
lastChildEl
)
{
return
false
;
}
const
lastNodeHeight
=
lastChildEl
.
clientHeight
;
return
(
scrollEl
.
scrollTop
+
scrollEl
.
clientHeight
>
=
scrollEl
.
scrollHeight
-
lastNodeHeight
/
2
)
;
}
async
onHover
(
target
tooltip
)
{
const
itemEl
=
target
.
closest
(
"
.
request
-
list
-
item
"
)
;
if
(
!
itemEl
)
{
return
false
;
}
const
itemId
=
itemEl
.
dataset
.
id
;
if
(
!
itemId
)
{
return
false
;
}
const
requestItem
=
this
.
props
.
displayedRequests
.
find
(
r
=
>
r
.
id
=
=
itemId
)
;
if
(
!
requestItem
)
{
return
false
;
}
if
(
!
target
.
closest
(
"
.
requests
-
list
-
file
"
)
)
{
return
false
;
}
const
{
mimeType
}
=
requestItem
;
if
(
!
mimeType
|
|
!
mimeType
.
includes
(
"
image
/
"
)
)
{
return
false
;
}
const
responseContent
=
await
this
.
props
.
connector
.
requestData
(
requestItem
.
id
"
responseContent
"
)
;
const
{
encoding
text
}
=
responseContent
.
content
;
const
src
=
formDataURI
(
mimeType
encoding
text
)
;
const
maxDim
=
REQUESTS_TOOLTIP_IMAGE_MAX_DIM
;
const
{
naturalWidth
naturalHeight
}
=
await
getImageDimensions
(
tooltip
.
doc
src
)
;
const
options
=
{
maxDim
naturalWidth
naturalHeight
}
;
setImageTooltip
(
tooltip
tooltip
.
doc
src
options
)
;
return
itemEl
.
querySelector
(
"
.
requests
-
list
-
file
"
)
;
}
onScroll
(
)
{
this
.
tooltip
.
hide
(
)
;
}
onMouseDown
(
evt
id
channelId
)
{
if
(
evt
.
button
=
=
=
LEFT_MOUSE_BUTTON
)
{
this
.
props
.
selectRequest
(
id
channelId
)
;
}
else
if
(
evt
.
button
=
=
=
RIGHT_MOUSE_BUTTON
)
{
this
.
props
.
onItemRightMouseButtonDown
(
id
)
;
}
}
onKeyDown
(
evt
)
{
let
delta
;
switch
(
evt
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowLeft
"
:
delta
=
-
1
;
break
;
case
"
ArrowDown
"
:
case
"
ArrowRight
"
:
delta
=
+
1
;
break
;
case
"
PageUp
"
:
delta
=
"
PAGE_UP
"
;
break
;
case
"
PageDown
"
:
delta
=
"
PAGE_DOWN
"
;
break
;
case
"
Home
"
:
delta
=
-
Infinity
;
break
;
case
"
End
"
:
delta
=
+
Infinity
;
break
;
}
if
(
delta
)
{
evt
.
preventDefault
(
)
;
evt
.
stopPropagation
(
)
;
this
.
props
.
onSelectDelta
(
delta
)
;
}
}
async
openRequestInTab
(
id
url
requestHeaders
requestPostData
)
{
requestHeaders
=
requestHeaders
|
|
(
await
this
.
props
.
connector
.
requestData
(
id
"
requestHeaders
"
)
)
;
requestPostData
=
requestPostData
|
|
(
await
this
.
props
.
connector
.
requestData
(
id
"
requestPostData
"
)
)
;
openRequestInTab
(
url
requestHeaders
requestPostData
)
;
}
onDoubleClick
(
{
id
url
requestHeaders
requestPostData
}
)
{
this
.
openRequestInTab
(
id
url
requestHeaders
requestPostData
)
;
}
onContextMenu
(
evt
)
{
evt
.
preventDefault
(
)
;
const
{
clickedRequest
displayedRequests
blockedUrls
}
=
this
.
props
;
if
(
!
this
.
contextMenu
)
{
const
{
connector
cloneRequest
openDetailsPanelTab
sendCustomRequest
openStatistics
openRequestBlockingAndAddUrl
openRequestBlockingAndDisableUrls
removeBlockedUrl
}
=
this
.
props
;
this
.
contextMenu
=
new
RequestListContextMenu
(
{
connector
cloneRequest
openDetailsPanelTab
sendCustomRequest
openStatistics
openRequestBlockingAndAddUrl
openRequestBlockingAndDisableUrls
removeBlockedUrl
openRequestInTab
:
this
.
openRequestInTab
}
)
;
}
this
.
contextMenu
.
open
(
evt
clickedRequest
displayedRequests
blockedUrls
)
;
}
onFocusedNodeChange
(
)
{
this
.
shouldScrollBottom
=
false
;
}
render
(
)
{
const
{
connector
columns
displayedRequests
firstRequestStartedMs
onCauseBadgeMouseDown
onSecurityIconMouseDown
onWaterfallMouseDown
requestFilterTypes
scale
selectedRequest
openRequestBlockingAndAddUrl
openRequestBlockingAndDisableUrls
}
=
this
.
props
;
return
div
(
{
ref
:
"
scrollEl
"
className
:
"
requests
-
list
-
scroll
"
}
dom
.
table
(
{
className
:
"
requests
-
list
-
table
"
}
RequestListHeader
(
)
dom
.
tbody
(
{
ref
:
"
rowGroupEl
"
className
:
"
requests
-
list
-
row
-
group
"
tabIndex
:
0
onKeyDown
:
this
.
onKeyDown
style
:
{
"
-
-
timings
-
scale
"
:
scale
"
-
-
timings
-
rev
-
scale
"
:
1
/
scale
}
}
displayedRequests
.
map
(
(
item
index
)
=
>
RequestListItem
(
{
blocked
:
!
!
item
.
blockedReason
firstRequestStartedMs
fromCache
:
item
.
status
=
=
=
"
304
"
|
|
item
.
fromCache
networkDetailsOpen
:
this
.
props
.
networkDetailsOpen
connector
columns
item
index
isSelected
:
item
.
id
=
=
=
(
selectedRequest
&
&
selectedRequest
.
id
)
key
:
item
.
id
onContextMenu
:
this
.
onContextMenu
onFocusedNodeChange
:
this
.
onFocusedNodeChange
onDoubleClick
:
(
)
=
>
this
.
onDoubleClick
(
item
)
onMouseDown
:
evt
=
>
this
.
onMouseDown
(
evt
item
.
id
item
.
channelId
)
onCauseBadgeMouseDown
:
(
)
=
>
onCauseBadgeMouseDown
(
item
.
cause
)
onSecurityIconMouseDown
:
(
)
=
>
onSecurityIconMouseDown
(
item
.
securityState
)
onWaterfallMouseDown
:
(
)
=
>
onWaterfallMouseDown
(
)
requestFilterTypes
openRequestBlockingAndAddUrl
:
url
=
>
openRequestBlockingAndAddUrl
(
url
)
openRequestBlockingAndDisableUrls
:
url
=
>
openRequestBlockingAndDisableUrls
(
url
)
}
)
)
)
)
)
;
}
}
module
.
exports
=
connect
(
state
=
>
(
{
blockedUrls
:
state
.
requestBlocking
.
blockedUrls
.
map
(
(
{
url
}
)
=
>
url
)
columns
:
getColumns
(
state
)
networkDetailsOpen
:
state
.
ui
.
networkDetailsOpen
networkDetailsWidth
:
state
.
ui
.
networkDetailsWidth
networkDetailsHeight
:
state
.
ui
.
networkDetailsHeight
clickedRequest
:
state
.
requests
.
clickedRequest
displayedRequests
:
getDisplayedRequests
(
state
)
firstRequestStartedMs
:
state
.
requests
.
firstStartedMs
selectedRequest
:
getSelectedRequest
(
state
)
scale
:
getWaterfallScale
(
state
)
requestFilterTypes
:
state
.
filters
.
requestFilterTypes
}
)
(
dispatch
props
)
=
>
(
{
cloneRequest
:
id
=
>
dispatch
(
Actions
.
cloneRequest
(
id
)
)
openDetailsPanelTab
:
(
)
=
>
dispatch
(
Actions
.
openNetworkDetails
(
true
)
)
sendCustomRequest
:
(
)
=
>
dispatch
(
Actions
.
sendCustomRequest
(
props
.
connector
)
)
openStatistics
:
open
=
>
dispatch
(
Actions
.
openStatistics
(
props
.
connector
open
)
)
openRequestBlockingAndAddUrl
:
url
=
>
dispatch
(
Actions
.
openRequestBlockingAndAddUrl
(
url
)
)
removeBlockedUrl
:
url
=
>
dispatch
(
Actions
.
removeBlockedUrl
(
url
)
)
openRequestBlockingAndDisableUrls
:
url
=
>
dispatch
(
Actions
.
openRequestBlockingAndDisableUrls
(
url
)
)
onCauseBadgeMouseDown
:
cause
=
>
{
if
(
cause
.
stacktrace
&
&
cause
.
stacktrace
.
length
>
0
)
{
dispatch
(
Actions
.
selectDetailsPanelTab
(
"
stack
-
trace
"
)
)
;
}
}
selectRequest
:
(
id
channelId
)
=
>
dispatch
(
Actions
.
selectRequest
(
id
channelId
)
)
onItemRightMouseButtonDown
:
id
=
>
dispatch
(
Actions
.
rightClickRequest
(
id
)
)
onItemMouseDown
:
id
=
>
dispatch
(
Actions
.
selectRequest
(
id
)
)
onSecurityIconMouseDown
:
securityState
=
>
{
if
(
securityState
&
&
securityState
!
=
=
"
insecure
"
)
{
dispatch
(
Actions
.
selectDetailsPanelTab
(
"
security
"
)
)
;
}
}
onSelectDelta
:
delta
=
>
dispatch
(
Actions
.
selectDelta
(
delta
)
)
onWaterfallMouseDown
:
(
)
=
>
{
dispatch
(
Actions
.
selectDetailsPanelTab
(
"
timings
"
)
)
;
}
}
)
)
(
RequestListContent
)
;
