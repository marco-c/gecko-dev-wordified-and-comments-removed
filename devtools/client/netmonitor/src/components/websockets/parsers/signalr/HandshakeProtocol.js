"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
TextMessageFormat
=
require
(
"
.
/
TextMessageFormat
"
)
;
const
Utils
=
require
(
"
.
/
Utils
"
)
;
class
HandshakeProtocol
{
writeHandshakeRequest
(
handshakeRequest
)
{
return
TextMessageFormat
.
TextMessageFormat
.
write
(
JSON
.
stringify
(
handshakeRequest
)
)
;
}
parseHandshakeResponse
(
data
)
{
let
messageData
;
let
remainingData
;
if
(
Utils
.
isArrayBuffer
(
data
)
|
|
(
typeof
Buffer
!
=
=
"
undefined
"
&
&
data
instanceof
Buffer
)
)
{
const
binaryData
=
new
Uint8Array
(
data
)
;
const
separatorIndex
=
binaryData
.
indexOf
(
TextMessageFormat
.
TextMessageFormat
.
RecordSeparatorCode
)
;
if
(
separatorIndex
=
=
=
-
1
)
{
throw
new
Error
(
"
Message
is
incomplete
.
"
)
;
}
const
responseLength
=
separatorIndex
+
1
;
messageData
=
String
.
fromCharCode
.
apply
(
null
binaryData
.
slice
(
0
responseLength
)
)
;
remainingData
=
binaryData
.
byteLength
>
responseLength
?
binaryData
.
slice
(
responseLength
)
.
buffer
:
null
;
}
else
{
const
textData
=
data
;
const
separatorIndex
=
textData
.
indexOf
(
TextMessageFormat
.
TextMessageFormat
.
RecordSeparator
)
;
if
(
separatorIndex
=
=
=
-
1
)
{
throw
new
Error
(
"
Message
is
incomplete
.
"
)
;
}
const
responseLength
=
separatorIndex
+
1
;
messageData
=
textData
.
substring
(
0
responseLength
)
;
remainingData
=
textData
.
length
>
responseLength
?
textData
.
substring
(
responseLength
)
:
null
;
}
const
messages
=
TextMessageFormat
.
TextMessageFormat
.
parse
(
messageData
)
;
const
response
=
JSON
.
parse
(
messages
[
0
]
)
;
if
(
response
.
type
)
{
throw
new
Error
(
"
Expected
a
handshake
response
from
the
server
.
"
)
;
}
const
responseMessage
=
response
;
return
[
remainingData
responseMessage
]
;
}
}
exports
.
HandshakeProtocol
=
HandshakeProtocol
;
