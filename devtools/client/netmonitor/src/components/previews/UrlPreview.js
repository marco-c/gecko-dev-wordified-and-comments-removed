"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
PropertiesView
=
createFactory
(
require
(
"
devtools
/
client
/
netmonitor
/
src
/
components
/
request
-
details
/
PropertiesView
"
)
)
;
const
{
parseQueryString
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
utils
/
request
-
utils
"
)
;
const
TreeRow
=
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
tree
/
TreeRow
"
)
)
;
loader
.
lazyGetter
(
this
"
MODE
"
function
(
)
{
return
require
(
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
"
)
.
MODE
;
}
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
div
span
tr
td
}
=
dom
;
class
UrlPreview
extends
Component
{
static
get
propTypes
(
)
{
return
{
url
:
PropTypes
.
string
method
:
PropTypes
.
string
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
parseUrl
=
this
.
parseUrl
.
bind
(
this
)
;
this
.
renderValue
=
this
.
renderValue
.
bind
(
this
)
;
}
renderRow
(
props
)
{
const
{
member
:
{
name
}
}
=
props
;
if
(
name
=
=
"
query
"
)
{
return
tr
(
{
key
:
name
className
:
"
treeRow
stringRow
"
}
td
(
{
colSpan
:
2
className
:
"
splitter
"
}
div
(
{
className
:
"
horizontal
-
splitter
"
}
)
)
)
;
}
const
customProps
=
{
.
.
.
props
}
;
customProps
.
member
.
selected
=
false
;
return
TreeRow
(
customProps
)
;
}
renderValue
(
props
)
{
const
{
member
:
{
level
open
}
value
}
=
props
;
if
(
level
=
=
0
)
{
if
(
open
)
{
return
"
"
;
}
const
{
scheme
host
filename
query
}
=
value
;
const
queryParamNames
=
query
?
Object
.
keys
(
query
)
:
[
]
;
return
div
(
{
key
:
"
url
"
className
:
"
url
"
}
span
(
{
key
:
"
url
-
scheme
"
className
:
"
url
-
scheme
"
}
{
scheme
}
:
/
/
)
span
(
{
key
:
"
url
-
host
"
className
:
"
url
-
host
"
}
{
host
}
)
span
(
{
key
:
"
url
-
filename
"
className
:
"
url
-
filename
"
}
{
filename
}
)
!
!
queryParamNames
.
length
&
&
span
(
{
key
:
"
url
-
ques
"
className
:
"
url
-
chars
"
}
"
?
"
)
queryParamNames
.
map
(
(
name
index
)
=
>
{
return
span
(
{
key
:
url
-
params
-
{
name
}
className
:
"
url
-
params
"
}
span
(
{
key
:
"
url
-
params
-
name
"
className
:
"
url
-
params
-
name
"
}
{
name
}
)
span
(
{
key
:
"
url
-
chars
-
equals
"
className
:
"
url
-
chars
"
}
"
=
"
)
span
(
{
key
:
"
url
-
params
-
value
"
className
:
"
url
-
params
-
value
"
}
{
query
[
name
]
}
)
queryParamNames
.
length
-
1
!
=
=
index
&
&
span
(
{
key
:
"
url
-
amp
"
className
:
"
url
-
chars
"
}
"
&
"
)
)
;
}
)
)
;
}
if
(
typeof
value
!
=
=
"
string
"
)
{
if
(
level
=
=
0
)
{
return
"
"
;
}
return
"
[
.
.
.
]
"
;
}
return
level
=
=
1
?
value
:
"
{
value
}
"
;
}
parseUrl
(
url
)
{
const
{
method
}
=
this
.
props
;
const
{
host
protocol
pathname
search
}
=
new
URL
(
url
)
;
const
urlObject
=
{
[
method
]
:
{
scheme
:
protocol
.
replace
(
"
:
"
"
"
)
host
:
host
filename
:
pathname
}
}
;
const
expandedNodes
=
new
Set
(
)
;
expandedNodes
.
add
(
/
{
method
}
/
query
)
;
if
(
search
.
length
)
{
const
params
=
parseQueryString
(
search
)
;
urlObject
[
method
]
.
query
=
params
.
reduce
(
(
map
obj
)
=
>
{
const
value
=
map
[
obj
.
name
]
;
if
(
value
|
|
value
=
=
=
"
"
)
{
if
(
typeof
value
!
=
=
"
object
"
)
{
expandedNodes
.
add
(
/
{
method
}
/
query
/
{
obj
.
name
}
)
;
map
[
obj
.
name
]
=
[
value
]
;
}
map
[
obj
.
name
]
.
push
(
obj
.
value
)
;
}
else
{
map
[
obj
.
name
]
=
obj
.
value
;
}
return
map
;
}
{
}
)
;
}
return
{
urlObject
expandedNodes
}
;
}
render
(
)
{
const
{
url
}
=
this
.
props
;
const
{
urlObject
expandedNodes
}
=
this
.
parseUrl
(
url
)
;
return
div
(
{
className
:
"
url
-
preview
"
}
PropertiesView
(
{
object
:
urlObject
useQuotes
:
true
defaultSelectFirstNode
:
false
mode
:
MODE
.
TINY
expandedNodes
renderRow
:
this
.
renderRow
renderValue
:
this
.
renderValue
enableInput
:
false
}
)
)
;
}
}
module
.
exports
=
UrlPreview
;
