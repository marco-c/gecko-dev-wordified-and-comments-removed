"
use
strict
"
;
const
{
EVENTS
}
=
require
(
"
.
.
/
constants
"
)
;
const
{
CurlUtils
}
=
require
(
"
devtools
/
client
/
shared
/
curl
"
)
;
const
{
fetchHeaders
formDataURI
}
=
require
(
"
.
.
/
utils
/
request
-
utils
"
)
;
class
FirefoxDataProvider
{
constructor
(
{
webConsoleClient
actions
}
)
{
this
.
webConsoleClient
=
webConsoleClient
;
this
.
actions
=
actions
;
this
.
payloadQueue
=
[
]
;
this
.
rdpRequestMap
=
new
Map
(
)
;
this
.
getLongString
=
this
.
getLongString
.
bind
(
this
)
;
this
.
onNetworkEvent
=
this
.
onNetworkEvent
.
bind
(
this
)
;
this
.
onNetworkEventUpdate
=
this
.
onNetworkEventUpdate
.
bind
(
this
)
;
}
async
addRequest
(
id
data
)
{
let
{
method
url
isXHR
cause
startedDateTime
fromCache
fromServiceWorker
}
=
data
;
if
(
this
.
actions
.
addRequest
)
{
await
this
.
actions
.
addRequest
(
id
{
startedMillis
:
Date
.
parse
(
startedDateTime
)
method
url
isXHR
cause
fromCache
fromServiceWorker
}
true
)
;
}
emit
(
EVENTS
.
REQUEST_ADDED
id
)
;
}
async
updateRequest
(
id
data
)
{
let
{
mimeType
responseContent
responseCookies
responseHeaders
requestCookies
requestHeaders
requestPostData
}
=
data
;
let
[
responseContentObj
requestHeadersObj
responseHeadersObj
postDataObj
requestCookiesObj
responseCookiesObj
]
=
await
Promise
.
all
(
[
this
.
fetchResponseContent
(
mimeType
responseContent
)
this
.
fetchRequestHeaders
(
requestHeaders
)
this
.
fetchResponseHeaders
(
responseHeaders
)
this
.
fetchPostData
(
requestPostData
)
this
.
fetchRequestCookies
(
requestCookies
)
this
.
fetchResponseCookies
(
responseCookies
)
]
)
;
let
payload
=
Object
.
assign
(
{
}
data
responseContentObj
requestHeadersObj
responseHeadersObj
postDataObj
requestCookiesObj
responseCookiesObj
)
;
this
.
pushRequestToQueue
(
id
payload
)
;
if
(
this
.
actions
.
updateRequest
&
&
this
.
isRequestPayloadReady
(
id
)
)
{
let
payloadFromQueue
=
this
.
getRequestFromQueue
(
id
)
.
payload
;
this
.
cleanUpQueue
(
id
)
;
await
this
.
actions
.
updateRequest
(
id
payloadFromQueue
true
)
;
}
}
async
fetchResponseContent
(
mimeType
responseContent
)
{
let
payload
=
{
}
;
if
(
mimeType
&
&
responseContent
&
&
responseContent
.
content
)
{
let
{
encoding
text
}
=
responseContent
.
content
;
let
response
=
await
this
.
getLongString
(
text
)
;
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
payload
.
responseContentDataUri
=
formDataURI
(
mimeType
encoding
response
)
;
}
responseContent
.
content
.
text
=
response
;
payload
.
responseContent
=
responseContent
;
}
return
payload
;
}
async
fetchRequestHeaders
(
requestHeaders
)
{
let
payload
=
{
}
;
if
(
requestHeaders
&
&
requestHeaders
.
headers
&
&
requestHeaders
.
headers
.
length
)
{
let
headers
=
await
fetchHeaders
(
requestHeaders
this
.
getLongString
)
;
if
(
headers
)
{
payload
.
requestHeaders
=
headers
;
}
}
return
payload
;
}
async
fetchResponseHeaders
(
responseHeaders
)
{
let
payload
=
{
}
;
if
(
responseHeaders
&
&
responseHeaders
.
headers
&
&
responseHeaders
.
headers
.
length
)
{
let
headers
=
await
fetchHeaders
(
responseHeaders
this
.
getLongString
)
;
if
(
headers
)
{
payload
.
responseHeaders
=
headers
;
}
}
return
payload
;
}
async
fetchPostData
(
requestPostData
)
{
let
payload
=
{
}
;
if
(
requestPostData
&
&
requestPostData
.
postData
)
{
let
{
text
}
=
requestPostData
.
postData
;
let
postData
=
await
this
.
getLongString
(
text
)
;
const
headers
=
CurlUtils
.
getHeadersFromMultipartText
(
postData
)
;
const
headersSize
=
headers
.
reduce
(
(
acc
{
name
value
}
)
=
>
{
return
acc
+
name
.
length
+
value
.
length
+
2
;
}
0
)
;
requestPostData
.
postData
.
text
=
postData
;
payload
.
requestPostData
=
Object
.
assign
(
{
}
requestPostData
)
;
payload
.
requestHeadersFromUploadStream
=
{
headers
headersSize
}
;
}
return
payload
;
}
async
fetchResponseCookies
(
responseCookies
)
{
let
payload
=
{
}
;
if
(
responseCookies
)
{
let
resCookies
=
[
]
;
let
cookies
=
responseCookies
.
cookies
?
responseCookies
.
cookies
:
responseCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
let
cookie
of
cookies
)
{
resCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
this
.
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
resCookies
.
length
)
{
payload
.
responseCookies
=
resCookies
;
}
}
}
return
payload
;
}
async
fetchRequestCookies
(
requestCookies
)
{
let
payload
=
{
}
;
if
(
requestCookies
)
{
let
reqCookies
=
[
]
;
let
cookies
=
requestCookies
.
cookies
?
requestCookies
.
cookies
:
requestCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
let
cookie
of
cookies
)
{
reqCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
this
.
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
reqCookies
.
length
)
{
payload
.
requestCookies
=
reqCookies
;
}
}
}
return
payload
;
}
getRequestFromQueue
(
id
)
{
return
this
.
payloadQueue
.
find
(
(
item
)
=
>
item
.
id
=
=
=
id
)
;
}
isRequestPayloadReady
(
id
)
{
return
!
this
.
rdpRequestMap
.
get
(
id
)
;
}
pushRequestToQueue
(
id
payload
)
{
let
request
=
this
.
getRequestFromQueue
(
id
)
;
if
(
!
request
)
{
this
.
payloadQueue
.
push
(
{
id
payload
}
)
;
}
else
{
request
.
payload
=
Object
.
assign
(
{
}
request
.
payload
payload
)
;
}
}
cleanUpQueue
(
id
)
{
this
.
payloadQueue
=
this
.
payloadQueue
.
filter
(
request
=
>
request
.
id
!
=
id
)
;
}
getNetworkRequest
(
id
)
{
return
this
.
webConsoleClient
.
getNetworkRequest
(
id
)
;
}
getLongString
(
stringGrip
)
{
return
this
.
webConsoleClient
.
getString
(
stringGrip
)
;
}
onNetworkEvent
(
type
networkInfo
)
{
let
{
actor
cause
fromCache
fromServiceWorker
isXHR
request
:
{
method
url
}
startedDateTime
}
=
networkInfo
;
this
.
addRequest
(
actor
{
cause
fromCache
fromServiceWorker
isXHR
method
startedDateTime
url
}
)
;
emit
(
EVENTS
.
NETWORK_EVENT
actor
)
;
}
onNetworkEventUpdate
(
type
data
)
{
let
{
packet
networkInfo
}
=
data
;
let
{
actor
}
=
networkInfo
;
switch
(
packet
.
updateType
)
{
case
"
requestHeaders
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onRequestHeaders
(
response
)
;
emit
(
EVENTS
.
UPDATING_REQUEST_HEADERS
actor
)
;
}
)
;
break
;
case
"
requestCookies
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onRequestCookies
(
response
)
;
emit
(
EVENTS
.
UPDATING_REQUEST_COOKIES
actor
)
;
}
)
;
break
;
case
"
requestPostData
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onRequestPostData
(
response
)
;
emit
(
EVENTS
.
UPDATING_REQUEST_POST_DATA
actor
)
;
}
)
;
break
;
case
"
securityInfo
"
:
this
.
updateRequest
(
actor
{
securityState
:
networkInfo
.
securityInfo
}
)
.
then
(
(
)
=
>
{
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onSecurityInfo
(
response
)
;
emit
(
EVENTS
.
UPDATING_SECURITY_INFO
actor
)
;
}
)
;
}
)
;
break
;
case
"
responseHeaders
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onResponseHeaders
(
response
)
;
emit
(
EVENTS
.
UPDATING_RESPONSE_HEADERS
actor
)
;
}
)
;
break
;
case
"
responseCookies
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onResponseCookies
(
response
)
;
emit
(
EVENTS
.
UPDATING_RESPONSE_COOKIES
actor
)
;
}
)
;
break
;
case
"
responseStart
"
:
this
.
updateRequest
(
actor
{
httpVersion
:
networkInfo
.
response
.
httpVersion
remoteAddress
:
networkInfo
.
response
.
remoteAddress
remotePort
:
networkInfo
.
response
.
remotePort
status
:
networkInfo
.
response
.
status
statusText
:
networkInfo
.
response
.
statusText
headersSize
:
networkInfo
.
response
.
headersSize
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
STARTED_RECEIVING_RESPONSE
actor
)
;
}
)
;
break
;
case
"
responseContent
"
:
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onResponseContent
(
{
contentSize
:
networkInfo
.
response
.
bodySize
transferredSize
:
networkInfo
.
response
.
transferredSize
mimeType
:
networkInfo
.
response
.
content
.
mimeType
}
response
)
;
emit
(
EVENTS
.
UPDATING_RESPONSE_CONTENT
actor
)
;
}
)
;
break
;
case
"
eventTimings
"
:
this
.
updateRequest
(
actor
{
totalTime
:
networkInfo
.
totalTime
}
)
.
then
(
(
)
=
>
{
this
.
requestData
(
actor
packet
.
updateType
)
.
then
(
response
=
>
{
this
.
onEventTimings
(
response
)
;
emit
(
EVENTS
.
UPDATING_EVENT_TIMINGS
actor
)
;
}
)
;
}
)
;
break
;
}
}
requestData
(
actor
method
)
{
let
record
=
this
.
rdpRequestMap
.
get
(
actor
)
;
if
(
!
record
)
{
record
=
{
}
;
this
.
rdpRequestMap
.
set
(
actor
record
)
;
}
if
(
record
.
method
)
{
return
record
.
method
;
}
let
realMethodName
=
"
get
"
+
method
.
charAt
(
0
)
.
toUpperCase
(
)
+
method
.
slice
(
1
)
;
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
typeof
this
.
webConsoleClient
[
realMethodName
]
=
=
"
function
"
)
{
this
.
webConsoleClient
[
realMethodName
]
(
actor
response
=
>
{
delete
record
[
method
]
;
let
props
=
Object
.
getOwnPropertyNames
(
record
)
;
if
(
!
props
.
length
)
{
this
.
rdpRequestMap
.
delete
(
actor
)
;
}
resolve
(
response
)
;
}
)
;
}
else
{
reject
(
new
Error
(
"
Error
:
No
such
client
method
!
"
)
)
;
}
}
)
;
record
[
method
]
=
promise
;
return
promise
;
}
onRequestHeaders
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestHeaders
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_REQUEST_HEADERS
response
.
from
)
;
}
)
;
}
onRequestCookies
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestCookies
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_REQUEST_COOKIES
response
.
from
)
;
}
)
;
}
onRequestPostData
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestPostData
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_REQUEST_POST_DATA
response
.
from
)
;
}
)
;
}
onSecurityInfo
(
response
)
{
this
.
updateRequest
(
response
.
from
{
securityInfo
:
response
.
securityInfo
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_SECURITY_INFO
response
.
from
)
;
}
)
;
}
onResponseHeaders
(
response
)
{
this
.
updateRequest
(
response
.
from
{
responseHeaders
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_RESPONSE_HEADERS
response
.
from
)
;
}
)
;
}
onResponseCookies
(
response
)
{
this
.
updateRequest
(
response
.
from
{
responseCookies
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_RESPONSE_COOKIES
response
.
from
)
;
}
)
;
}
onResponseContent
(
data
response
)
{
let
payload
=
Object
.
assign
(
{
responseContent
:
response
}
data
)
;
this
.
updateRequest
(
response
.
from
payload
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_RESPONSE_CONTENT
response
.
from
)
;
}
)
;
}
onEventTimings
(
response
)
{
this
.
updateRequest
(
response
.
from
{
eventTimings
:
response
}
)
.
then
(
(
)
=
>
{
emit
(
EVENTS
.
RECEIVED_EVENT_TIMINGS
response
.
from
)
;
}
)
;
}
}
function
emit
(
type
data
)
{
if
(
typeof
window
!
=
"
undefined
"
)
{
window
.
emit
(
type
data
)
;
}
}
module
.
exports
=
FirefoxDataProvider
;
