"
use
strict
"
;
const
{
EVENTS
TEST_EVENTS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
const
{
CurlUtils
}
=
require
(
"
devtools
/
client
/
shared
/
curl
"
)
;
const
{
fetchHeaders
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
utils
/
request
-
utils
"
)
;
const
{
getLongStringFullText
}
=
require
(
"
devtools
/
client
/
shared
/
string
-
utils
"
)
;
class
FirefoxDataProvider
{
constructor
(
{
commands
actions
owner
}
)
{
this
.
commands
=
commands
;
this
.
actions
=
actions
|
|
{
}
;
this
.
actionsEnabled
=
true
;
this
.
_requestDataEnabled
=
true
;
this
.
_lastRequestDataClearId
=
0
;
this
.
owner
=
owner
;
this
.
stackTraces
=
new
Map
(
)
;
this
.
stackTraceRequestInfoByActorID
=
new
Map
(
)
;
this
.
pendingRequests
=
new
Set
(
)
;
this
.
lazyRequestData
=
new
Map
(
)
;
this
.
getLongString
=
this
.
getLongString
.
bind
(
this
)
;
this
.
onNetworkResourceAvailable
=
this
.
onNetworkResourceAvailable
.
bind
(
this
)
;
this
.
onNetworkResourceUpdated
=
this
.
onNetworkResourceUpdated
.
bind
(
this
)
;
this
.
onWebSocketOpened
=
this
.
onWebSocketOpened
.
bind
(
this
)
;
this
.
onWebSocketClosed
=
this
.
onWebSocketClosed
.
bind
(
this
)
;
this
.
onFrameSent
=
this
.
onFrameSent
.
bind
(
this
)
;
this
.
onFrameReceived
=
this
.
onFrameReceived
.
bind
(
this
)
;
this
.
onEventSourceConnectionClosed
=
this
.
onEventSourceConnectionClosed
.
bind
(
this
)
;
this
.
onEventReceived
=
this
.
onEventReceived
.
bind
(
this
)
;
this
.
setEventStreamFlag
=
this
.
setEventStreamFlag
.
bind
(
this
)
;
}
clear
(
)
{
this
.
stackTraces
.
clear
(
)
;
this
.
pendingRequests
.
clear
(
)
;
this
.
lazyRequestData
.
clear
(
)
;
this
.
stackTraceRequestInfoByActorID
.
clear
(
)
;
this
.
_requestDataEnabled
=
false
;
this
.
_lastRequestDataClearId
+
+
;
}
destroy
(
)
{
this
.
clear
(
)
;
}
enableActions
(
enable
)
{
this
.
actionsEnabled
=
enable
;
}
async
addRequest
(
id
resource
)
{
this
.
pendingRequests
.
add
(
id
)
;
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
addRequest
)
{
await
this
.
actions
.
addRequest
(
id
resource
true
)
;
}
this
.
emit
(
EVENTS
.
REQUEST_ADDED
id
)
;
}
async
updateRequest
(
id
data
)
{
const
{
responseContent
responseCookies
responseHeaders
requestCookies
requestHeaders
requestPostData
responseCache
}
=
data
;
const
[
responseContentObj
requestHeadersObj
responseHeadersObj
postDataObj
requestCookiesObj
responseCookiesObj
responseCacheObj
]
=
await
Promise
.
all
(
[
this
.
fetchResponseContent
(
responseContent
)
this
.
fetchRequestHeaders
(
requestHeaders
)
this
.
fetchResponseHeaders
(
responseHeaders
)
this
.
fetchPostData
(
requestPostData
)
this
.
fetchRequestCookies
(
requestCookies
)
this
.
fetchResponseCookies
(
responseCookies
)
this
.
fetchResponseCache
(
responseCache
)
]
)
;
const
payload
=
Object
.
assign
(
{
}
data
responseContentObj
requestHeadersObj
responseHeadersObj
postDataObj
requestCookiesObj
responseCookiesObj
responseCacheObj
)
;
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
updateRequest
)
{
await
this
.
actions
.
updateRequest
(
id
payload
true
)
;
}
return
payload
;
}
async
fetchResponseContent
(
responseContent
)
{
const
payload
=
{
}
;
if
(
responseContent
?
.
content
)
{
const
{
text
}
=
responseContent
.
content
;
const
response
=
await
this
.
getLongString
(
text
)
;
responseContent
.
content
.
text
=
response
;
payload
.
responseContent
=
responseContent
;
}
return
payload
;
}
async
fetchRequestHeaders
(
requestHeaders
)
{
const
payload
=
{
}
;
if
(
requestHeaders
?
.
headers
?
.
length
)
{
const
headers
=
await
fetchHeaders
(
requestHeaders
this
.
getLongString
)
;
if
(
headers
)
{
payload
.
requestHeaders
=
headers
;
}
}
return
payload
;
}
async
fetchResponseHeaders
(
responseHeaders
)
{
const
payload
=
{
}
;
if
(
responseHeaders
?
.
headers
?
.
length
)
{
const
headers
=
await
fetchHeaders
(
responseHeaders
this
.
getLongString
)
;
if
(
headers
)
{
payload
.
responseHeaders
=
headers
;
}
}
return
payload
;
}
async
fetchPostData
(
requestPostData
)
{
const
payload
=
{
}
;
if
(
requestPostData
?
.
postData
)
{
const
{
text
}
=
requestPostData
.
postData
;
const
postData
=
await
this
.
getLongString
(
text
)
;
const
headers
=
CurlUtils
.
getHeadersFromMultipartText
(
postData
)
;
const
headersSize
=
headers
.
reduce
(
(
acc
{
name
value
}
)
=
>
{
return
acc
+
name
.
length
+
value
.
length
+
2
;
}
0
)
;
requestPostData
.
postData
.
text
=
postData
;
payload
.
requestPostData
=
{
.
.
.
requestPostData
uploadHeaders
:
{
headers
headersSize
}
}
;
}
return
payload
;
}
async
fetchRequestCookies
(
requestCookies
)
{
const
payload
=
{
}
;
if
(
requestCookies
)
{
const
reqCookies
=
[
]
;
const
cookies
=
requestCookies
.
cookies
?
requestCookies
.
cookies
:
requestCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
const
cookie
of
cookies
)
{
reqCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
this
.
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
reqCookies
.
length
)
{
payload
.
requestCookies
=
reqCookies
;
}
}
}
return
payload
;
}
async
fetchResponseCookies
(
responseCookies
)
{
const
payload
=
{
}
;
if
(
responseCookies
)
{
const
resCookies
=
[
]
;
const
cookies
=
responseCookies
.
cookies
?
responseCookies
.
cookies
:
responseCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
const
cookie
of
cookies
)
{
resCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
this
.
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
resCookies
.
length
)
{
payload
.
responseCookies
=
resCookies
;
}
}
}
return
payload
;
}
async
fetchResponseCache
(
responseCache
)
{
const
payload
=
{
}
;
if
(
responseCache
)
{
payload
.
responseCache
=
await
responseCache
;
payload
.
responseCacheAvailable
=
false
;
}
return
payload
;
}
hasPendingRequests
(
)
{
return
this
.
pendingRequests
.
size
>
0
;
}
async
getLongString
(
stringGrip
)
{
const
payload
=
await
getLongStringFullText
(
this
.
commands
.
client
stringGrip
)
;
this
.
emitForTests
(
TEST_EVENTS
.
LONGSTRING_RESOLVED
{
payload
}
)
;
return
payload
;
}
async
_getStackTraceFromWatcher
(
actor
)
{
let
stacktrace
=
[
]
;
if
(
!
actor
.
targetFront
.
isDestroyed
(
)
)
{
const
networkContentFront
=
await
actor
.
targetFront
.
getFront
(
"
networkContent
"
)
;
stacktrace
=
await
networkContentFront
.
getStackTrace
(
actor
.
stacktraceResourceId
)
;
}
return
{
stacktrace
}
;
}
async
onStackTraceAvailable
(
resource
)
{
if
(
!
this
.
stackTraces
.
has
(
resource
.
resourceId
)
)
{
this
.
stackTraces
.
set
(
resource
.
resourceId
resource
)
;
}
else
{
const
request
=
this
.
stackTraces
.
get
(
resource
.
resourceId
)
;
request
.
cause
.
stacktraceAvailable
=
resource
.
stacktraceAvailable
;
request
.
cause
.
lastFrame
=
resource
.
lastFrame
;
this
.
stackTraces
.
delete
(
resource
.
resourceId
)
;
this
.
stackTraceRequestInfoByActorID
.
set
(
request
.
actor
{
targetFront
:
resource
.
targetFront
stacktraceResourceId
:
resource
.
resourceId
}
)
;
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
updateRequest
)
{
await
this
.
actions
.
updateRequest
(
request
.
actor
request
true
)
;
}
}
}
async
onNetworkResourceAvailable
(
resource
)
{
const
{
actor
stacktraceResourceId
cause
}
=
resource
;
if
(
!
this
.
_requestDataEnabled
)
{
this
.
_requestDataEnabled
=
true
;
}
if
(
this
.
stackTraces
.
has
(
stacktraceResourceId
)
)
{
const
{
stacktraceAvailable
lastFrame
targetFront
}
=
this
.
stackTraces
.
get
(
stacktraceResourceId
)
;
resource
.
cause
.
stacktraceAvailable
=
stacktraceAvailable
;
resource
.
cause
.
lastFrame
=
lastFrame
;
this
.
stackTraces
.
delete
(
stacktraceResourceId
)
;
this
.
stackTraceRequestInfoByActorID
.
set
(
actor
{
targetFront
stacktraceResourceId
}
)
;
}
else
if
(
cause
)
{
this
.
stackTraces
.
set
(
stacktraceResourceId
{
actor
cause
}
)
;
}
await
this
.
addRequest
(
actor
resource
)
;
this
.
emitForTests
(
TEST_EVENTS
.
NETWORK_EVENT
resource
)
;
}
async
onNetworkResourceUpdated
(
resource
)
{
if
(
resource
?
.
mimeType
?
.
includes
(
"
text
/
event
-
stream
"
)
)
{
await
this
.
setEventStreamFlag
(
resource
.
actor
)
;
}
this
.
pendingRequests
.
delete
(
resource
.
actor
)
;
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
updateRequest
)
{
await
this
.
actions
.
updateRequest
(
resource
.
actor
resource
true
)
;
}
this
.
emitForTests
(
TEST_EVENTS
.
NETWORK_EVENT_UPDATED
resource
.
actor
)
;
this
.
emit
(
EVENTS
.
PAYLOAD_READY
resource
)
;
}
async
onWebSocketOpened
(
httpChannelId
effectiveURI
protocols
extensions
)
{
}
async
onWebSocketClosed
(
httpChannelId
wasClean
code
reason
)
{
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
closeConnection
)
{
await
this
.
actions
.
closeConnection
(
httpChannelId
wasClean
code
reason
)
;
}
}
async
onFrameSent
(
httpChannelId
data
)
{
this
.
addMessage
(
httpChannelId
data
)
;
}
async
onFrameReceived
(
httpChannelId
data
)
{
this
.
addMessage
(
httpChannelId
data
)
;
}
async
addMessage
(
httpChannelId
data
)
{
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
addMessage
)
{
await
this
.
actions
.
addMessage
(
httpChannelId
data
true
)
;
}
}
requestData
(
actor
method
)
{
if
(
!
this
.
_requestDataEnabled
)
{
return
Promise
.
resolve
(
)
;
}
const
key
=
{
actor
}
-
{
method
}
;
let
promise
=
this
.
lazyRequestData
.
get
(
key
)
;
if
(
promise
)
{
return
promise
;
}
promise
=
this
.
_requestData
(
actor
method
)
.
then
(
async
payload
=
>
{
this
.
lazyRequestData
.
delete
(
key
)
;
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
updateRequest
)
{
await
this
.
actions
.
updateRequest
(
actor
{
.
.
.
payload
[
{
method
}
Available
]
:
false
}
true
)
;
}
return
payload
;
}
)
;
this
.
lazyRequestData
.
set
(
key
promise
)
;
return
promise
;
}
async
_requestData
(
actor
method
)
{
const
lastRequestDataClearId
=
this
.
_lastRequestDataClearId
;
const
clientMethodName
=
get
{
method
.
charAt
(
0
)
.
toUpperCase
(
)
}
{
method
.
slice
(
1
)
}
;
const
callbackMethodName
=
on
{
method
.
charAt
(
0
)
.
toUpperCase
(
)
}
{
method
.
slice
(
1
)
}
;
const
updatingEventName
=
UPDATING_
{
method
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
_
1
"
)
.
toUpperCase
(
)
}
;
this
.
emitForTests
(
EVENTS
[
updatingEventName
]
actor
)
;
const
actorID
=
actor
.
replace
(
"
-
clone
"
"
"
)
;
let
response
;
if
(
clientMethodName
=
=
"
getStackTrace
"
&
&
this
.
commands
.
resourceCommand
.
hasResourceCommandSupport
(
this
.
commands
.
resourceCommand
.
TYPES
.
NETWORK_EVENT_STACKTRACE
)
)
{
const
requestInfo
=
this
.
stackTraceRequestInfoByActorID
.
get
(
actorID
)
;
const
{
stacktrace
}
=
await
this
.
_getStackTraceFromWatcher
(
requestInfo
)
;
this
.
stackTraceRequestInfoByActorID
.
delete
(
actorID
)
;
response
=
{
from
:
actor
stacktrace
}
;
}
else
{
try
{
const
packet
=
{
to
:
actorID
type
:
clientMethodName
}
;
response
=
await
this
.
commands
.
client
.
request
(
packet
)
;
}
catch
(
e
)
{
if
(
this
.
_lastRequestDataClearId
!
=
=
lastRequestDataClearId
)
{
console
.
warn
(
Firefox
Data
Provider
destroyed
while
requesting
data
:
{
e
.
message
}
)
;
response
=
{
from
:
actor
}
;
}
else
{
throw
new
Error
(
Error
while
calling
method
{
clientMethodName
}
:
{
e
.
message
}
)
;
}
}
}
if
(
actor
.
includes
(
"
-
clone
"
)
)
{
response
=
{
.
.
.
response
from
:
{
response
.
from
}
-
clone
}
;
}
return
this
[
callbackMethodName
]
(
response
)
;
}
async
onRequestHeaders
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
requestHeaders
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_REQUEST_HEADERS
response
)
;
return
payload
.
requestHeaders
;
}
async
onResponseHeaders
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
responseHeaders
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_RESPONSE_HEADERS
response
)
;
return
payload
.
responseHeaders
;
}
async
onRequestCookies
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
requestCookies
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_REQUEST_COOKIES
response
)
;
return
payload
.
requestCookies
;
}
async
onRequestPostData
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
requestPostData
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_REQUEST_POST_DATA
response
)
;
return
payload
.
requestPostData
;
}
async
onSecurityInfo
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
securityInfo
:
response
.
securityInfo
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_SECURITY_INFO
response
)
;
return
payload
.
securityInfo
;
}
async
onResponseCookies
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
responseCookies
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_RESPONSE_COOKIES
response
)
;
return
payload
.
responseCookies
;
}
async
onResponseCache
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
responseCache
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_RESPONSE_CACHE
response
)
;
return
payload
.
responseCache
;
}
async
onResponseContent
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
mimeType
:
response
.
content
.
mimeType
responseContent
:
response
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_RESPONSE_CONTENT
response
)
;
return
payload
.
responseContent
;
}
async
onEventTimings
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
eventTimings
:
response
}
)
;
this
.
emit
(
EVENTS
.
RECEIVED_EVENT_TIMINGS
response
)
;
return
payload
.
eventTimings
;
}
async
onStackTrace
(
response
)
{
const
payload
=
await
this
.
updateRequest
(
response
.
from
{
stacktrace
:
response
.
stacktrace
}
)
;
this
.
emitForTests
(
TEST_EVENTS
.
RECEIVED_EVENT_STACKTRACE
response
)
;
return
payload
.
stacktrace
;
}
async
onEventSourceConnectionClosed
(
httpChannelId
)
{
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
closeConnection
)
{
await
this
.
actions
.
closeConnection
(
httpChannelId
)
;
}
}
async
onEventReceived
(
httpChannelId
data
)
{
this
.
addMessage
(
httpChannelId
data
)
;
}
async
setEventStreamFlag
(
actorId
)
{
if
(
this
.
actionsEnabled
&
&
this
.
actions
.
setEventStreamFlag
)
{
await
this
.
actions
.
setEventStreamFlag
(
actorId
true
)
;
}
}
emit
(
type
data
)
{
if
(
this
.
owner
)
{
this
.
owner
.
emit
(
type
data
)
;
}
}
emitForTests
(
type
data
)
{
if
(
this
.
owner
)
{
this
.
owner
.
emitForTests
(
type
data
)
;
}
}
}
module
.
exports
=
FirefoxDataProvider
;
