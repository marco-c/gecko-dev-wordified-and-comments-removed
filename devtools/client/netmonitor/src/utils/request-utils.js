"
use
strict
"
;
const
{
getUnicodeUrl
getUnicodeUrlPath
getUnicodeHostname
}
=
require
(
"
devtools
/
client
/
shared
/
unicode
-
url
"
)
;
const
{
UPDATE_PROPS
}
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
constants
"
)
;
const
CONTENT_MIME_TYPE_ABBREVIATIONS
=
{
ecmascript
:
"
js
"
javascript
:
"
js
"
"
x
-
javascript
"
:
"
js
"
}
;
async
function
getFormDataSections
(
headers
uploadHeaders
postData
getLongString
)
{
const
formDataSections
=
[
]
;
const
requestHeaders
=
headers
.
headers
;
const
payloadHeaders
=
uploadHeaders
?
uploadHeaders
.
headers
:
[
]
;
const
allHeaders
=
[
.
.
.
payloadHeaders
.
.
.
requestHeaders
]
;
const
contentTypeHeader
=
allHeaders
.
find
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
content
-
type
"
;
}
)
;
const
contentTypeLongString
=
contentTypeHeader
?
contentTypeHeader
.
value
:
"
"
;
const
contentType
=
await
getLongString
(
contentTypeLongString
)
;
if
(
contentType
&
&
contentType
.
includes
(
"
x
-
www
-
form
-
urlencoded
"
)
)
{
const
postDataLongString
=
postData
.
postData
.
text
;
const
text
=
await
getLongString
(
postDataLongString
)
;
for
(
const
section
of
text
.
trim
(
)
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
)
{
if
(
payloadHeaders
.
every
(
header
=
>
!
section
.
startsWith
(
header
.
name
)
)
)
{
formDataSections
.
push
(
section
)
;
}
}
}
return
formDataSections
;
}
async
function
fetchHeaders
(
headers
getLongString
)
{
for
(
const
{
value
}
of
headers
.
headers
)
{
headers
.
headers
.
value
=
await
getLongString
(
value
)
;
}
return
headers
;
}
function
fetchNetworkUpdatePacket
(
requestData
request
updateTypes
)
{
const
promises
=
[
]
;
if
(
request
)
{
updateTypes
.
forEach
(
updateType
=
>
{
if
(
updateType
=
=
=
"
stackTrace
"
)
{
if
(
request
.
cause
.
stacktraceAvailable
&
&
!
request
.
stacktrace
)
{
promises
.
push
(
requestData
(
request
.
id
updateType
)
)
;
}
return
;
}
if
(
request
[
{
updateType
}
Available
]
&
&
!
request
[
updateType
]
)
{
promises
.
push
(
requestData
(
request
.
id
updateType
)
)
;
}
}
)
;
}
return
Promise
.
all
(
promises
)
;
}
function
formDataURI
(
mimeType
encoding
text
)
{
if
(
!
encoding
)
{
encoding
=
"
base64
"
;
text
=
btoa
(
unescape
(
encodeURIComponent
(
text
)
)
)
;
}
return
"
data
:
"
+
mimeType
+
"
;
"
+
encoding
+
"
"
+
text
;
}
function
writeHeaderText
(
headers
preHeaderText
)
{
let
result
=
"
"
;
if
(
preHeaderText
)
{
result
+
=
preHeaderText
+
"
\
r
\
n
"
;
}
result
+
=
headers
.
map
(
(
{
name
value
}
)
=
>
name
+
"
:
"
+
value
)
.
join
(
"
\
r
\
n
"
)
;
result
+
=
"
\
r
\
n
\
r
\
n
"
;
return
result
;
}
function
decodeUnicodeBase64
(
string
)
{
try
{
return
decodeURIComponent
(
atob
(
string
)
)
;
}
catch
(
err
)
{
}
return
string
;
}
function
getAbbreviatedMimeType
(
mimeType
)
{
if
(
!
mimeType
)
{
return
"
"
;
}
const
abbrevType
=
(
mimeType
.
split
(
"
;
"
)
[
0
]
.
split
(
"
/
"
)
[
1
]
|
|
"
"
)
.
split
(
"
+
"
)
[
0
]
;
return
CONTENT_MIME_TYPE_ABBREVIATIONS
[
abbrevType
]
|
|
abbrevType
;
}
function
getFileName
(
baseNameWithQuery
)
{
const
basename
=
baseNameWithQuery
&
&
baseNameWithQuery
.
split
(
"
?
"
)
[
0
]
;
return
basename
&
&
basename
.
includes
(
"
.
"
)
?
basename
:
null
;
}
function
getUrl
(
url
)
{
try
{
return
new
URL
(
url
)
;
}
catch
(
err
)
{
return
null
;
}
}
function
getUrlProperty
(
input
property
)
{
const
url
=
getUrl
(
input
)
;
return
url
?
.
[
property
]
?
url
[
property
]
:
"
"
;
}
function
getUrlBaseName
(
url
)
{
const
pathname
=
getUrlProperty
(
url
"
pathname
"
)
;
return
getUnicodeUrlPath
(
pathname
.
replace
(
/
\
S
*
\
/
/
"
"
)
|
|
pathname
|
|
"
/
"
)
;
}
function
getUrlQuery
(
url
)
{
return
getUrlProperty
(
url
"
search
"
)
.
replace
(
/
^
\
?
/
"
"
)
;
}
function
getUrlBaseNameWithQuery
(
url
)
{
const
basename
=
getUrlBaseName
(
url
)
;
const
search
=
getUrlProperty
(
url
"
search
"
)
;
return
basename
+
getUnicodeUrlPath
(
search
)
;
}
function
getUrlHostName
(
url
)
{
return
getUrlProperty
(
url
"
hostname
"
)
;
}
function
getUrlHost
(
url
)
{
return
getUrlProperty
(
url
"
host
"
)
;
}
function
getUrlScheme
(
url
)
{
const
protocol
=
getUrlProperty
(
url
"
protocol
"
)
;
return
protocol
.
replace
(
"
:
"
"
"
)
.
toLowerCase
(
)
;
}
function
getUrlDetails
(
url
)
{
const
baseNameWithQuery
=
getUrlBaseNameWithQuery
(
url
)
;
let
host
=
getUrlHost
(
url
)
;
const
hostname
=
getUrlHostName
(
url
)
;
const
unicodeUrl
=
getUnicodeUrl
(
url
)
;
const
scheme
=
getUrlScheme
(
url
)
;
const
unicodeHostname
=
getUnicodeHostname
(
hostname
)
;
if
(
unicodeHostname
!
=
=
hostname
)
{
host
=
host
.
replace
(
hostname
unicodeHostname
)
;
}
const
isLocal
=
hostname
.
match
(
/
(
.
+
\
.
)
?
localhost
/
)
|
|
hostname
.
match
(
/
^
127
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
/
)
|
|
hostname
.
match
(
/
\
[
[
0
:
]
+
1
\
]
/
)
;
return
{
baseNameWithQuery
host
scheme
unicodeUrl
isLocal
url
}
;
}
function
parseQueryString
(
query
)
{
if
(
!
query
)
{
return
null
;
}
return
query
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
const
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
getUnicodeUrlPath
(
param
[
0
]
.
replace
(
/
\
+
/
g
"
"
)
)
:
"
"
value
:
param
[
1
]
?
getUnicodeUrlPath
(
param
.
slice
(
1
)
.
join
(
"
=
"
)
.
replace
(
/
\
+
/
g
"
"
)
)
:
"
"
}
;
}
)
;
}
function
parseFormData
(
sections
)
{
if
(
!
sections
)
{
return
[
]
;
}
return
sections
.
replace
(
/
^
&
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
const
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
getUnicodeUrlPath
(
param
[
0
]
)
:
"
"
value
:
param
[
1
]
?
getUnicodeUrlPath
(
param
[
1
]
)
:
"
"
}
;
}
)
;
}
function
ipToLong
(
ip
)
{
if
(
!
ip
)
{
return
-
1
;
}
let
base
;
let
octets
=
ip
.
split
(
"
.
"
)
;
if
(
octets
.
length
=
=
=
4
)
{
base
=
10
;
}
else
if
(
ip
.
includes
(
"
:
"
)
)
{
const
numberOfZeroSections
=
8
-
ip
.
replace
(
/
^
:
+
|
:
+
/
g
"
"
)
.
split
(
/
:
+
/
g
)
.
length
;
octets
=
ip
.
replace
(
"
:
:
"
:
{
"
0
:
"
.
repeat
(
numberOfZeroSections
)
}
)
.
replace
(
/
^
:
|
:
/
g
"
"
)
.
split
(
"
:
"
)
;
base
=
16
;
}
else
{
return
-
1
;
}
return
octets
.
map
(
(
val
ix
arr
)
=
>
{
return
parseInt
(
val
base
)
*
Math
.
pow
(
256
arr
.
length
-
1
-
ix
)
;
}
)
.
reduce
(
(
sum
val
)
=
>
{
return
sum
+
val
;
}
0
)
;
}
function
propertiesEqual
(
props
item1
item2
)
{
return
item1
=
=
=
item2
|
|
props
.
every
(
p
=
>
item1
[
p
]
=
=
=
item2
[
p
]
)
;
}
function
getStartTime
(
item
firstRequestStartedMs
=
0
)
{
return
item
.
startedMs
-
firstRequestStartedMs
;
}
function
getEndTime
(
item
firstRequestStartedMs
=
0
)
{
const
{
startedMs
totalTime
}
=
item
;
return
startedMs
+
totalTime
-
firstRequestStartedMs
;
}
function
getResponseTime
(
item
firstRequestStartedMs
=
0
)
{
const
{
startedMs
totalTime
eventTimings
=
{
timings
:
{
}
}
}
=
item
;
return
(
startedMs
+
totalTime
-
firstRequestStartedMs
-
eventTimings
.
timings
.
receive
)
;
}
function
getFormattedProtocol
(
item
)
{
const
{
httpVersion
=
"
"
responseHeaders
=
{
headers
:
[
]
}
}
=
item
;
const
protocol
=
[
httpVersion
]
;
responseHeaders
.
headers
.
some
(
h
=
>
{
if
(
h
.
hasOwnProperty
(
"
name
"
)
&
&
h
.
name
.
toLowerCase
(
)
=
=
=
"
x
-
firefox
-
spdy
"
)
{
if
(
h
.
value
!
=
=
undefined
&
&
h
.
value
.
length
)
{
if
(
h
.
value
.
toLowerCase
(
)
!
=
=
"
http
/
1
.
1
"
|
|
protocol
[
0
]
.
toLowerCase
(
)
!
=
=
"
http
/
1
.
1
"
)
{
if
(
parseFloat
(
h
.
value
.
toLowerCase
(
)
.
split
(
"
"
)
[
1
]
)
!
=
=
parseFloat
(
protocol
[
0
]
.
toLowerCase
(
)
.
split
(
"
/
"
)
[
1
]
)
)
{
protocol
.
push
(
h
.
value
)
;
return
true
;
}
}
}
}
return
false
;
}
)
;
return
protocol
.
join
(
"
+
"
)
;
}
function
getResponseHeader
(
item
header
)
{
const
{
responseHeaders
}
=
item
;
if
(
!
responseHeaders
|
|
!
responseHeaders
.
headers
.
length
)
{
return
null
;
}
header
=
header
.
toLowerCase
(
)
;
for
(
const
responseHeader
of
responseHeaders
.
headers
)
{
if
(
responseHeader
.
name
.
toLowerCase
(
)
=
=
header
)
{
return
responseHeader
.
value
;
}
}
return
null
;
}
function
getRequestHeader
(
item
header
)
{
const
{
requestHeaders
}
=
item
;
if
(
!
requestHeaders
|
|
!
requestHeaders
.
headers
.
length
)
{
return
null
;
}
header
=
header
.
toLowerCase
(
)
;
for
(
const
requestHeader
of
requestHeaders
.
headers
)
{
if
(
requestHeader
.
name
.
toLowerCase
(
)
=
=
header
)
{
return
requestHeader
.
value
;
}
}
return
null
;
}
async
function
updateFormDataSections
(
props
)
{
const
{
connector
request
=
{
}
updateRequest
}
=
props
;
let
{
id
formDataSections
requestHeaders
requestHeadersAvailable
requestHeadersFromUploadStream
requestPostData
requestPostDataAvailable
}
=
request
;
if
(
requestHeadersAvailable
&
&
!
requestHeaders
)
{
requestHeaders
=
await
connector
.
requestData
(
id
"
requestHeaders
"
)
;
}
if
(
requestPostDataAvailable
&
&
!
requestPostData
)
{
requestPostData
=
await
connector
.
requestData
(
id
"
requestPostData
"
)
;
}
if
(
!
formDataSections
&
&
requestHeaders
&
&
requestPostData
&
&
requestHeadersFromUploadStream
)
{
formDataSections
=
await
getFormDataSections
(
requestHeaders
requestHeadersFromUploadStream
requestPostData
connector
.
getLongString
)
;
updateRequest
(
request
.
id
{
formDataSections
}
true
)
;
}
}
async
function
getMessagePayload
(
payload
getLongString
)
{
const
result
=
await
getLongString
(
payload
)
;
return
result
;
}
function
processNetworkUpdates
(
update
)
{
const
newRequest
=
{
}
;
for
(
const
[
key
value
]
of
Object
.
entries
(
update
)
)
{
if
(
UPDATE_PROPS
.
includes
(
key
)
)
{
newRequest
[
key
]
=
value
;
if
(
key
=
=
"
requestPostData
"
)
{
newRequest
.
requestHeadersFromUploadStream
=
value
.
uploadHeaders
;
}
}
}
return
newRequest
;
}
function
isBase64
(
payload
)
{
try
{
return
btoa
(
atob
(
payload
)
)
=
=
payload
;
}
catch
(
err
)
{
return
false
;
}
}
function
parseJSON
(
payloadUnclean
)
{
let
json
;
const
jsonpRegex
=
/
^
\
s
*
(
[
\
w
]
+
)
\
s
*
\
(
\
s
*
(
[
^
]
*
)
\
s
*
\
)
\
s
*
;
?
\
s
*
/
;
const
[
jsonpCallback
jsonp
]
=
payloadUnclean
.
match
(
jsonpRegex
)
|
|
[
]
;
if
(
jsonpCallback
&
&
jsonp
)
{
let
error
;
try
{
json
=
parseJSON
(
jsonp
)
.
json
;
}
catch
(
err
)
{
error
=
err
;
}
return
{
json
error
jsonpCallback
}
;
}
let
{
payload
strippedChars
error
}
=
removeXSSIString
(
payloadUnclean
)
;
try
{
json
=
JSON
.
parse
(
payload
)
;
}
catch
(
err
)
{
if
(
isBase64
(
payload
)
)
{
try
{
json
=
JSON
.
parse
(
atob
(
payload
)
)
;
}
catch
(
err64
)
{
error
=
err64
;
}
}
else
{
error
=
err
;
}
}
if
(
!
error
)
{
if
(
typeof
json
!
=
=
"
object
"
)
{
return
{
}
;
}
}
return
{
json
error
strippedChars
}
;
}
function
removeXSSIString
(
payloadUnclean
)
{
const
xssiRegex
=
/
(
^
\
)
\
]
\
}
'
?
\
n
)
|
(
^
for
?
\
(
;
;
\
)
;
?
)
|
(
^
while
?
\
(
1
\
)
;
?
)
/
;
let
payload
strippedChars
error
;
const
xssiRegexMatch
=
payloadUnclean
.
match
(
xssiRegex
)
;
if
(
xssiRegexMatch
?
.
length
>
0
)
{
const
xssiLen
=
xssiRegexMatch
[
0
]
.
length
;
try
{
payload
=
payloadUnclean
.
substring
(
xssiLen
)
;
strippedChars
=
xssiRegexMatch
[
0
]
;
}
catch
(
err
)
{
error
=
err
;
payload
=
payloadUnclean
;
}
}
else
{
payload
=
payloadUnclean
;
}
return
{
payload
strippedChars
error
}
;
}
function
getRequestHeadersRawText
(
method
httpVersion
requestHeaders
urlDetails
)
{
const
url
=
new
URL
(
urlDetails
.
url
)
;
const
path
=
url
?
{
url
.
pathname
}
{
url
.
search
}
:
"
<
unknown
>
"
;
const
preHeaderText
=
{
method
}
{
path
}
{
httpVersion
}
;
return
writeHeaderText
(
requestHeaders
.
headers
preHeaderText
)
.
trim
(
)
;
}
module
.
exports
=
{
decodeUnicodeBase64
getFormDataSections
fetchHeaders
fetchNetworkUpdatePacket
formDataURI
writeHeaderText
getAbbreviatedMimeType
getFileName
getEndTime
getFormattedProtocol
getMessagePayload
getRequestHeader
getResponseHeader
getResponseTime
getStartTime
getUrlBaseName
getUrlBaseNameWithQuery
getUrlDetails
getUrlHost
getUrlHostName
getUrlQuery
getUrlScheme
parseQueryString
parseFormData
updateFormDataSections
processNetworkUpdates
propertiesEqual
ipToLong
parseJSON
getRequestHeadersRawText
}
;
