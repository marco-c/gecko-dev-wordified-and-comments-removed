"
use
strict
"
;
const
{
getUnicodeUrl
getUnicodeUrlPath
getUnicodeHostname
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
unicode
-
url
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
parseJsonLossless
:
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
rep
-
utils
.
mjs
"
JSON_NUMBER
:
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
constants
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
loader
.
lazyRequireGetter
(
this
"
L10N
"
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
utils
/
l10n
.
js
"
true
)
;
const
{
UPDATE_PROPS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
constants
.
js
"
)
;
const
CONTENT_MIME_TYPE_ABBREVIATIONS
=
new
Map
(
[
[
"
ecmascript
"
"
js
"
]
[
"
javascript
"
"
js
"
]
[
"
x
-
javascript
"
"
js
"
]
[
"
event
-
stream
"
"
eventsource
"
]
]
)
;
async
function
getFormDataSections
(
headers
uploadHeaders
postData
getLongString
)
{
const
formDataSections
=
[
]
;
const
requestHeaders
=
headers
.
headers
;
const
payloadHeaders
=
uploadHeaders
?
uploadHeaders
.
headers
:
[
]
;
const
allHeaders
=
[
.
.
.
payloadHeaders
.
.
.
requestHeaders
]
;
const
contentTypeHeader
=
allHeaders
.
find
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
content
-
type
"
;
}
)
;
const
contentTypeLongString
=
contentTypeHeader
?
contentTypeHeader
.
value
:
"
"
;
const
contentType
=
await
getLongString
(
contentTypeLongString
)
;
if
(
contentType
&
&
contentType
.
includes
(
"
x
-
www
-
form
-
urlencoded
"
)
)
{
const
postDataLongString
=
postData
.
postData
.
text
;
const
text
=
await
getLongString
(
postDataLongString
)
;
for
(
const
section
of
text
.
trim
(
)
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
)
{
if
(
payloadHeaders
.
every
(
header
=
>
!
section
.
startsWith
(
header
.
name
)
)
)
{
formDataSections
.
push
(
section
)
;
}
}
}
return
formDataSections
;
}
async
function
fetchHeaders
(
headers
getLongString
)
{
for
(
const
{
value
}
of
headers
.
headers
)
{
headers
.
headers
.
value
=
await
getLongString
(
value
)
;
}
return
headers
;
}
function
fetchNetworkUpdatePacket
(
requestData
request
updateTypes
)
{
const
promises
=
[
]
;
if
(
request
)
{
updateTypes
.
forEach
(
updateType
=
>
{
if
(
updateType
=
=
=
"
stackTrace
"
)
{
if
(
request
.
cause
.
stacktraceAvailable
&
&
!
request
.
stacktrace
)
{
promises
.
push
(
requestData
(
request
.
id
updateType
)
)
;
}
return
;
}
if
(
request
[
{
updateType
}
Available
]
&
&
!
request
[
updateType
]
)
{
promises
.
push
(
requestData
(
request
.
id
updateType
)
)
;
}
}
)
;
}
return
Promise
.
all
(
promises
)
;
}
function
formDataURI
(
mimeType
encoding
text
)
{
if
(
!
encoding
)
{
encoding
=
"
base64
"
;
text
=
btoa
(
unescape
(
encodeURIComponent
(
text
)
)
)
;
}
return
"
data
:
"
+
mimeType
+
"
;
"
+
encoding
+
"
"
+
text
;
}
function
writeHeaderText
(
headers
preHeaderText
)
{
let
result
=
"
"
;
if
(
preHeaderText
)
{
result
+
=
preHeaderText
+
"
\
r
\
n
"
;
}
result
+
=
headers
.
map
(
(
{
name
value
}
)
=
>
name
+
"
:
"
+
value
)
.
join
(
"
\
r
\
n
"
)
;
result
+
=
"
\
r
\
n
\
r
\
n
"
;
return
result
;
}
function
decodeUnicodeBase64
(
string
)
{
try
{
return
decodeURIComponent
(
atob
(
string
)
)
;
}
catch
(
err
)
{
}
return
string
;
}
function
getAbbreviatedMimeType
(
mimeType
)
{
if
(
!
mimeType
)
{
return
"
"
;
}
const
abbrevType
=
(
mimeType
.
toLowerCase
(
)
.
split
(
"
;
"
)
[
0
]
.
split
(
"
/
"
)
[
1
]
|
|
"
"
)
.
split
(
"
+
"
)
[
0
]
;
return
CONTENT_MIME_TYPE_ABBREVIATIONS
.
get
(
abbrevType
)
|
|
abbrevType
;
}
function
getFileName
(
baseNameWithQuery
)
{
const
basename
=
baseNameWithQuery
&
&
baseNameWithQuery
.
split
(
"
?
"
)
[
0
]
;
return
basename
&
&
basename
.
includes
(
"
.
"
)
?
basename
:
null
;
}
function
getUrl
(
url
)
{
if
(
URL
.
isInstance
(
url
)
)
{
return
url
;
}
return
URL
.
parse
(
url
)
;
}
function
getUrlProperty
(
input
property
)
{
const
url
=
getUrl
(
input
)
;
return
url
?
.
[
property
]
?
?
"
"
;
}
function
getUrlBaseName
(
url
)
{
const
pathname
=
getUrlProperty
(
url
"
pathname
"
)
;
return
getUnicodeUrlPath
(
pathname
.
replace
(
/
\
S
*
\
/
/
"
"
)
|
|
pathname
|
|
"
/
"
)
;
}
function
getUrlQuery
(
url
)
{
return
getUrlProperty
(
url
"
search
"
)
.
replace
(
/
^
\
?
/
"
"
)
;
}
function
getUrlBaseNameWithQuery
(
urlObject
)
{
if
(
urlObject
.
href
.
startsWith
(
"
data
:
"
)
)
{
return
urlObject
.
href
;
}
const
basename
=
getUrlBaseName
(
urlObject
)
;
const
search
=
getUrlProperty
(
urlObject
"
search
"
)
;
return
basename
+
getUnicodeUrlPath
(
search
)
;
}
function
getUrlHostName
(
url
)
{
return
getUrlProperty
(
url
"
hostname
"
)
;
}
function
getUrlHost
(
url
)
{
return
getUrlProperty
(
url
"
host
"
)
;
}
function
getUrlScheme
(
url
)
{
const
protocol
=
getUrlProperty
(
url
"
protocol
"
)
;
return
protocol
.
replace
(
"
:
"
"
"
)
.
toLowerCase
(
)
;
}
function
getUrlPath
(
url
)
{
const
href
=
getUrlProperty
(
url
"
href
"
)
;
const
origin
=
getUrlProperty
(
url
"
origin
"
)
;
return
href
.
replace
(
origin
"
"
)
;
}
function
getUrlDetails
(
url
)
{
const
urlObject
=
getUrl
(
url
)
;
const
baseNameWithQuery
=
getUrlBaseNameWithQuery
(
urlObject
)
;
let
host
=
getUrlHost
(
urlObject
)
;
const
hostname
=
getUrlHostName
(
urlObject
)
;
const
unicodeUrl
=
getUnicodeUrl
(
urlObject
)
;
const
scheme
=
getUrlScheme
(
urlObject
)
;
const
path
=
getUrlPath
(
urlObject
)
;
const
unicodeHostname
=
getUnicodeHostname
(
hostname
)
;
if
(
unicodeHostname
!
=
=
hostname
)
{
host
=
host
.
replace
(
hostname
unicodeHostname
)
;
}
const
isLocal
=
/
^
(
.
+
\
.
)
?
localhost
/
.
test
(
hostname
)
|
|
/
^
127
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
\
.
\
d
{
1
3
}
/
.
test
(
hostname
)
|
|
/
^
\
[
[
0
:
]
+
1
\
]
/
.
test
(
hostname
)
;
return
{
baseNameWithQuery
host
scheme
unicodeUrl
isLocal
url
path
}
;
}
function
getUrlToolTip
(
urlDetails
)
{
const
url
=
urlDetails
.
url
;
const
decodedURL
=
urlDetails
.
unicodeUrl
;
const
ORIGINAL_URL
=
L10N
.
getFormatStr
(
"
netRequest
.
originalFileURL
.
tooltip
"
url
)
;
const
DECODED_URL
=
L10N
.
getFormatStr
(
"
netRequest
.
decodedFileURL
.
tooltip
"
decodedURL
)
;
const
toolTip
=
url
=
=
=
decodedURL
?
url
:
ORIGINAL_URL
+
"
\
n
\
n
"
+
DECODED_URL
;
return
toolTip
;
}
function
parseQueryString
(
query
)
{
if
(
!
query
)
{
return
null
;
}
return
query
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
const
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
getUnicodeUrlPath
(
param
[
0
]
.
replace
(
/
\
+
/
g
"
"
)
)
:
"
"
value
:
param
[
1
]
?
getUnicodeUrlPath
(
param
.
slice
(
1
)
.
join
(
"
=
"
)
.
replace
(
/
\
+
/
g
"
"
)
)
:
"
"
}
;
}
)
;
}
function
parseFormData
(
sections
)
{
if
(
!
sections
)
{
return
[
]
;
}
return
sections
.
replace
(
/
^
&
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
const
firstEqualSignIndex
=
e
.
indexOf
(
"
=
"
)
;
const
paramName
=
firstEqualSignIndex
!
=
=
-
1
?
e
.
slice
(
0
firstEqualSignIndex
)
:
e
;
const
paramValue
=
firstEqualSignIndex
!
=
=
-
1
?
e
.
slice
(
firstEqualSignIndex
+
1
)
:
"
"
;
return
{
name
:
paramName
?
getUnicodeUrlPath
(
paramName
)
:
"
"
value
:
paramValue
?
getUnicodeUrlPath
(
paramValue
)
:
"
"
}
;
}
)
;
}
function
ipToLong
(
ip
)
{
if
(
!
ip
)
{
return
-
1
;
}
let
base
;
let
octets
=
ip
.
split
(
"
.
"
)
;
if
(
octets
.
length
=
=
=
4
)
{
base
=
10
;
}
else
if
(
ip
.
includes
(
"
:
"
)
)
{
const
numberOfZeroSections
=
8
-
ip
.
replace
(
/
^
:
+
|
:
+
/
g
"
"
)
.
split
(
/
:
+
/
g
)
.
length
;
octets
=
ip
.
replace
(
"
:
:
"
:
{
"
0
:
"
.
repeat
(
numberOfZeroSections
)
}
)
.
replace
(
/
^
:
|
:
/
g
"
"
)
.
split
(
"
:
"
)
;
base
=
16
;
}
else
{
return
-
1
;
}
return
octets
.
map
(
(
val
ix
arr
)
=
>
{
return
parseInt
(
val
base
)
*
Math
.
pow
(
256
arr
.
length
-
1
-
ix
)
;
}
)
.
reduce
(
(
sum
val
)
=
>
{
return
sum
+
val
;
}
0
)
;
}
function
propertiesEqual
(
props
item1
item2
)
{
return
item1
=
=
=
item2
|
|
props
.
every
(
p
=
>
item1
[
p
]
=
=
=
item2
[
p
]
)
;
}
function
getStartTime
(
item
firstRequestStartedMs
=
0
)
{
return
item
.
startedMs
-
firstRequestStartedMs
;
}
function
getEndTime
(
item
firstRequestStartedMs
=
0
)
{
const
{
startedMs
totalTime
}
=
item
;
return
startedMs
+
totalTime
-
firstRequestStartedMs
;
}
function
getResponseTime
(
item
firstRequestStartedMs
=
0
)
{
const
{
startedMs
totalTime
eventTimings
=
{
timings
:
{
}
}
}
=
item
;
return
(
startedMs
+
totalTime
-
firstRequestStartedMs
-
eventTimings
.
timings
.
receive
)
;
}
function
getFormattedProtocol
(
item
)
{
const
{
httpVersion
=
"
"
responseHeaders
=
{
headers
:
[
]
}
}
=
item
;
const
protocol
=
[
httpVersion
]
;
responseHeaders
.
headers
.
some
(
h
=
>
{
if
(
h
.
hasOwnProperty
(
"
name
"
)
&
&
h
.
name
.
toLowerCase
(
)
=
=
=
"
x
-
firefox
-
spdy
"
)
{
if
(
h
.
value
!
=
=
undefined
&
&
h
.
value
.
length
)
{
if
(
h
.
value
.
toLowerCase
(
)
!
=
=
"
http
/
1
.
1
"
|
|
protocol
[
0
]
.
toLowerCase
(
)
!
=
=
"
http
/
1
.
1
"
)
{
if
(
parseFloat
(
h
.
value
.
toLowerCase
(
)
.
split
(
"
"
)
[
1
]
)
!
=
=
parseFloat
(
protocol
[
0
]
.
toLowerCase
(
)
.
split
(
"
/
"
)
[
1
]
)
)
{
protocol
.
push
(
h
.
value
)
;
return
true
;
}
}
}
}
return
false
;
}
)
;
return
protocol
.
join
(
"
+
"
)
;
}
function
getResponseHeader
(
item
header
)
{
const
{
responseHeaders
}
=
item
;
if
(
!
responseHeaders
?
.
headers
?
.
length
)
{
return
null
;
}
header
=
header
.
toLowerCase
(
)
;
for
(
const
responseHeader
of
responseHeaders
.
headers
)
{
if
(
responseHeader
.
name
.
toLowerCase
(
)
=
=
header
)
{
return
responseHeader
.
value
;
}
}
return
null
;
}
function
getRequestHeader
(
item
header
)
{
const
{
requestHeaders
}
=
item
;
if
(
!
requestHeaders
?
.
headers
?
.
length
)
{
return
null
;
}
header
=
header
.
toLowerCase
(
)
;
for
(
const
requestHeader
of
requestHeaders
.
headers
)
{
if
(
requestHeader
.
name
.
toLowerCase
(
)
=
=
header
)
{
return
requestHeader
.
value
;
}
}
return
null
;
}
async
function
updateFormDataSections
(
props
)
{
const
{
connector
request
=
{
}
updateRequest
}
=
props
;
let
{
id
formDataSections
requestHeaders
requestHeadersAvailable
requestHeadersFromUploadStream
requestPostData
requestPostDataAvailable
}
=
request
;
if
(
requestHeadersAvailable
&
&
!
requestHeaders
)
{
requestHeaders
=
await
connector
.
requestData
(
id
"
requestHeaders
"
)
;
}
if
(
requestPostDataAvailable
&
&
!
requestPostData
)
{
requestPostData
=
await
connector
.
requestData
(
id
"
requestPostData
"
)
;
}
if
(
!
formDataSections
&
&
requestHeaders
&
&
requestPostData
&
&
requestHeadersFromUploadStream
)
{
formDataSections
=
await
getFormDataSections
(
requestHeaders
requestHeadersFromUploadStream
requestPostData
connector
.
getLongString
)
;
updateRequest
(
request
.
id
{
formDataSections
}
true
)
;
}
}
async
function
getMessagePayload
(
payload
getLongString
)
{
const
result
=
await
getLongString
(
payload
)
;
return
result
;
}
function
processNetworkUpdates
(
update
)
{
const
newRequest
=
{
}
;
for
(
const
[
key
value
]
of
Object
.
entries
(
update
)
)
{
if
(
UPDATE_PROPS
.
includes
(
key
)
)
{
newRequest
[
key
]
=
value
;
if
(
key
=
=
"
requestPostData
"
)
{
newRequest
.
requestHeadersFromUploadStream
=
value
.
uploadHeaders
;
}
}
}
return
newRequest
;
}
function
isBase64
(
payload
)
{
try
{
return
btoa
(
atob
(
payload
)
)
=
=
payload
;
}
catch
(
err
)
{
return
false
;
}
}
function
parseJSON
(
payloadUnclean
)
{
let
json
;
const
jsonpRegex
=
/
^
\
s
*
(
[
\
w
]
+
)
\
s
*
\
(
\
s
*
(
[
^
]
*
)
\
s
*
\
)
\
s
*
;
?
\
s
*
/
;
const
[
jsonpCallback
jsonp
]
=
payloadUnclean
.
match
(
jsonpRegex
)
|
|
[
]
;
if
(
jsonpCallback
&
&
jsonp
)
{
let
error
;
try
{
json
=
parseJSON
(
jsonp
)
.
json
;
}
catch
(
err
)
{
error
=
err
;
}
return
{
json
error
jsonpCallback
}
;
}
let
{
payload
strippedChars
error
}
=
removeXSSIString
(
payloadUnclean
)
;
try
{
json
=
lazy
.
parseJsonLossless
(
payload
)
;
}
catch
(
err
)
{
if
(
isBase64
(
payload
)
)
{
try
{
json
=
JSON
.
parse
(
atob
(
payload
)
)
;
}
catch
(
err64
)
{
error
=
err64
;
}
}
else
{
error
=
err
;
}
}
if
(
!
error
&
&
(
typeof
json
!
=
=
"
object
"
|
|
json
=
=
=
null
|
|
json
?
.
type
=
=
=
lazy
.
JSON_NUMBER
)
)
{
return
{
}
;
}
return
{
json
error
strippedChars
}
;
}
function
removeXSSIString
(
payloadUnclean
)
{
const
xssiRegex
=
/
(
^
\
)
\
]
\
}
'
?
\
n
)
|
(
^
for
?
\
(
;
;
\
)
;
?
)
|
(
^
while
?
\
(
1
\
)
;
?
)
/
;
let
payload
strippedChars
error
;
const
xssiRegexMatch
=
payloadUnclean
.
match
(
xssiRegex
)
;
if
(
xssiRegexMatch
?
.
length
)
{
const
xssiLen
=
xssiRegexMatch
[
0
]
.
length
;
try
{
payload
=
payloadUnclean
.
substring
(
xssiLen
)
;
strippedChars
=
xssiRegexMatch
[
0
]
;
}
catch
(
err
)
{
error
=
err
;
payload
=
payloadUnclean
;
}
}
else
{
payload
=
payloadUnclean
;
}
return
{
payload
strippedChars
error
}
;
}
function
getRequestHeadersRawText
(
method
httpVersion
requestHeaders
urlDetails
)
{
const
url
=
getUrl
(
urlDetails
.
url
)
;
const
path
=
url
?
{
url
.
pathname
}
{
url
.
search
}
:
"
<
unknown
>
"
;
const
preHeaderText
=
{
method
}
{
path
}
{
httpVersion
}
;
return
writeHeaderText
(
requestHeaders
.
headers
preHeaderText
)
.
trim
(
)
;
}
function
responseIsFresh
(
{
responseHeaders
status
}
)
{
if
(
status
!
=
304
|
|
!
responseHeaders
)
{
return
false
;
}
const
list
=
responseHeaders
.
headers
;
const
cacheControl
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
=
"
cache
-
control
"
)
;
const
expires
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
=
"
expires
"
)
;
if
(
cacheControl
)
{
const
maxAgeMatch
=
cacheControl
.
value
.
match
(
/
s
-
maxage
\
s
*
=
\
s
*
(
\
d
+
)
/
)
|
|
cacheControl
.
value
.
match
(
/
max
-
age
\
s
*
=
\
s
*
(
\
d
+
)
/
)
;
if
(
maxAgeMatch
&
&
maxAgeMatch
.
pop
(
)
>
0
)
{
return
true
;
}
}
if
(
expires
&
&
Date
.
parse
(
expires
.
value
)
)
{
return
true
;
}
return
false
;
}
module
.
exports
=
{
decodeUnicodeBase64
getFormDataSections
fetchHeaders
fetchNetworkUpdatePacket
formDataURI
writeHeaderText
getAbbreviatedMimeType
getFileName
getEndTime
getFormattedProtocol
getMessagePayload
getRequestHeader
getResponseHeader
getResponseTime
getStartTime
getUrl
getUrlBaseName
getUrlDetails
getUrlHost
getUrlHostName
getUrlQuery
getUrlScheme
getUrlToolTip
parseQueryString
parseFormData
updateFormDataSections
processNetworkUpdates
propertiesEqual
ipToLong
parseJSON
getRequestHeadersRawText
responseIsFresh
}
;
