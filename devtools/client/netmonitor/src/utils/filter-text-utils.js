"
use
strict
"
;
const
{
FILTER_FLAGS
}
=
require
(
"
.
.
/
constants
"
)
;
const
{
getFormattedIPAndPort
}
=
require
(
"
.
/
format
-
utils
"
)
;
function
parseFilters
(
query
)
{
let
flags
=
[
]
;
let
text
=
[
]
;
let
parts
=
query
.
split
(
/
\
s
+
/
)
;
for
(
let
part
of
parts
)
{
if
(
!
part
)
{
continue
;
}
let
colonIndex
=
part
.
indexOf
(
"
:
"
)
;
if
(
colonIndex
=
=
=
-
1
)
{
text
.
push
(
part
)
;
continue
;
}
let
key
=
part
.
substring
(
0
colonIndex
)
;
let
negative
=
key
.
startsWith
(
"
-
"
)
;
if
(
negative
)
{
key
=
key
.
substring
(
1
)
;
}
if
(
!
FILTER_FLAGS
.
includes
(
key
)
)
{
text
.
push
(
part
)
;
continue
;
}
let
value
=
part
.
substring
(
colonIndex
+
1
)
;
value
=
processFlagFilter
(
key
value
)
;
flags
.
push
(
{
type
:
key
value
negative
}
)
;
}
return
{
text
flags
}
;
}
function
processFlagFilter
(
type
value
)
{
switch
(
type
)
{
case
"
regexp
"
:
return
value
;
case
"
size
"
:
case
"
transferred
"
:
case
"
larger
-
than
"
:
let
multiplier
=
1
;
if
(
value
.
endsWith
(
"
k
"
)
)
{
multiplier
=
1024
;
value
=
value
.
substring
(
0
value
.
length
-
1
)
;
}
else
if
(
value
.
endsWith
(
"
m
"
)
)
{
multiplier
=
1024
*
1024
;
value
=
value
.
substring
(
0
value
.
length
-
1
)
;
}
let
quantity
=
Number
(
value
)
;
if
(
isNaN
(
quantity
)
)
{
return
null
;
}
return
quantity
*
multiplier
;
default
:
return
value
.
toLowerCase
(
)
;
}
}
function
isFlagFilterMatch
(
item
{
type
value
negative
}
)
{
let
match
=
true
;
let
{
responseCookies
=
{
cookies
:
[
]
}
}
=
item
;
responseCookies
=
responseCookies
.
cookies
|
|
responseCookies
;
switch
(
type
)
{
case
"
status
-
code
"
:
match
=
item
.
status
=
=
=
value
;
break
;
case
"
method
"
:
match
=
item
.
method
.
toLowerCase
(
)
=
=
=
value
;
break
;
case
"
protocol
"
:
let
protocol
=
item
.
httpVersion
;
match
=
typeof
protocol
=
=
=
"
string
"
?
protocol
.
toLowerCase
(
)
.
includes
(
value
)
:
false
;
break
;
case
"
domain
"
:
match
=
item
.
urlDetails
.
host
.
toLowerCase
(
)
.
includes
(
value
)
;
break
;
case
"
remote
-
ip
"
:
match
=
getFormattedIPAndPort
(
item
.
remoteAddress
item
.
remotePort
)
.
toLowerCase
(
)
.
includes
(
value
)
;
break
;
case
"
has
-
response
-
header
"
:
if
(
typeof
item
.
responseHeaders
=
=
=
"
object
"
)
{
let
{
headers
}
=
item
.
responseHeaders
;
match
=
headers
.
findIndex
(
h
=
>
h
.
name
.
toLowerCase
(
)
=
=
=
value
)
>
-
1
;
}
else
{
match
=
false
;
}
break
;
case
"
cause
"
:
let
causeType
=
item
.
cause
.
type
;
match
=
typeof
causeType
=
=
=
"
string
"
?
causeType
.
toLowerCase
(
)
.
includes
(
value
)
:
false
;
break
;
case
"
transferred
"
:
if
(
item
.
fromCache
)
{
match
=
false
;
}
else
{
match
=
isSizeMatch
(
value
item
.
transferredSize
)
;
}
break
;
case
"
size
"
:
match
=
isSizeMatch
(
value
item
.
contentSize
)
;
break
;
case
"
larger
-
than
"
:
match
=
item
.
contentSize
>
value
;
break
;
case
"
mime
-
type
"
:
match
=
item
.
mimeType
.
includes
(
value
)
;
break
;
case
"
is
"
:
if
(
value
=
=
=
"
from
-
cache
"
|
|
value
=
=
=
"
cached
"
)
{
match
=
item
.
fromCache
|
|
item
.
status
=
=
=
"
304
"
;
}
else
if
(
value
=
=
=
"
running
"
)
{
match
=
!
item
.
status
;
}
break
;
case
"
scheme
"
:
match
=
item
.
urlDetails
.
scheme
=
=
=
value
;
break
;
case
"
regexp
"
:
try
{
let
pattern
=
new
RegExp
(
value
)
;
match
=
pattern
.
test
(
item
.
url
)
;
}
catch
(
e
)
{
match
=
false
;
}
break
;
case
"
set
-
cookie
-
domain
"
:
if
(
responseCookies
.
length
>
0
)
{
let
host
=
item
.
urlDetails
.
host
;
let
i
=
responseCookies
.
findIndex
(
c
=
>
{
let
domain
=
c
.
hasOwnProperty
(
"
domain
"
)
?
c
.
domain
:
host
;
return
domain
=
=
=
value
;
}
)
;
match
=
i
>
-
1
;
}
else
{
match
=
false
;
}
break
;
case
"
set
-
cookie
-
name
"
:
match
=
responseCookies
.
findIndex
(
c
=
>
c
.
name
.
toLowerCase
(
)
=
=
=
value
)
>
-
1
;
break
;
case
"
set
-
cookie
-
value
"
:
match
=
responseCookies
.
findIndex
(
c
=
>
c
.
value
.
toLowerCase
(
)
=
=
=
value
)
>
-
1
;
break
;
}
if
(
negative
)
{
return
!
match
;
}
return
match
;
}
function
isSizeMatch
(
value
size
)
{
return
value
>
=
(
size
-
size
/
10
)
&
&
value
<
(
size
+
size
/
10
)
;
}
function
isTextFilterMatch
(
{
url
}
text
)
{
let
lowerCaseUrl
=
url
.
toLowerCase
(
)
;
let
lowerCaseText
=
text
.
toLowerCase
(
)
;
let
textLength
=
text
.
length
;
if
(
text
.
startsWith
(
"
-
"
)
&
&
textLength
>
1
)
{
lowerCaseText
=
lowerCaseText
.
substring
(
1
textLength
)
;
return
!
lowerCaseUrl
.
includes
(
lowerCaseText
)
;
}
return
!
text
|
|
lowerCaseUrl
.
includes
(
lowerCaseText
)
;
}
function
isFreetextMatch
(
item
text
)
{
if
(
!
text
)
{
return
true
;
}
let
filters
=
parseFilters
(
text
)
;
let
match
=
true
;
for
(
let
textFilter
of
filters
.
text
)
{
match
=
match
&
&
isTextFilterMatch
(
item
textFilter
)
;
}
for
(
let
flagFilter
of
filters
.
flags
)
{
match
=
match
&
&
isFlagFilterMatch
(
item
flagFilter
)
;
}
return
match
;
}
module
.
exports
=
{
isFreetextMatch
}
;
