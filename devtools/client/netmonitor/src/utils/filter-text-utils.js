"
use
strict
"
;
const
{
HEADERS
}
=
require
(
"
.
.
/
constants
"
)
;
const
HEADER_FILTERS
=
HEADERS
.
filter
(
h
=
>
h
.
canFilter
)
.
map
(
h
=
>
h
.
filterKey
|
|
h
.
name
)
;
const
FILTER_FLAGS
=
[
.
.
.
HEADER_FILTERS
"
scheme
"
"
mime
-
type
"
"
larger
-
than
"
"
is
"
]
;
function
parseFilters
(
query
)
{
let
flags
=
[
]
;
let
text
=
[
]
;
let
parts
=
query
.
split
(
/
\
s
+
/
)
;
for
(
let
part
of
parts
)
{
if
(
!
part
)
{
continue
;
}
let
colonIndex
=
part
.
indexOf
(
"
:
"
)
;
if
(
colonIndex
=
=
=
-
1
)
{
text
.
push
(
part
)
;
continue
;
}
let
key
=
part
.
substring
(
0
colonIndex
)
;
let
negative
=
key
.
startsWith
(
"
-
"
)
;
if
(
negative
)
{
key
=
key
.
substring
(
1
)
;
}
if
(
!
FILTER_FLAGS
.
includes
(
key
)
)
{
text
.
push
(
part
)
;
continue
;
}
let
value
=
part
.
substring
(
colonIndex
+
1
)
;
value
=
processFlagFilter
(
key
value
)
;
flags
.
push
(
{
type
:
key
value
negative
}
)
;
}
return
{
text
flags
}
;
}
function
processFlagFilter
(
type
value
)
{
switch
(
type
)
{
case
"
size
"
:
case
"
transferred
"
:
case
"
larger
-
than
"
:
let
multiplier
=
1
;
if
(
value
.
endsWith
(
"
k
"
)
)
{
multiplier
=
1024
;
value
=
value
.
substring
(
0
value
.
length
-
1
)
;
}
else
if
(
value
.
endsWith
(
"
m
"
)
)
{
multiplier
=
1024
*
1024
;
value
=
value
.
substring
(
0
value
.
length
-
1
)
;
}
let
quantity
=
Number
(
value
)
;
if
(
isNaN
(
quantity
)
)
{
return
null
;
}
return
quantity
*
multiplier
;
default
:
return
value
.
toLowerCase
(
)
;
}
}
function
getSizeOrder
(
size
)
{
return
Math
.
round
(
Math
.
log10
(
size
)
)
;
}
function
isFlagFilterMatch
(
item
{
type
value
negative
}
)
{
let
match
=
true
;
switch
(
type
)
{
case
"
status
-
code
"
:
match
=
item
.
status
=
=
=
value
;
break
;
case
"
method
"
:
match
=
item
.
method
.
toLowerCase
(
)
=
=
=
value
;
break
;
case
"
domain
"
:
match
=
item
.
urlDetails
.
host
.
toLowerCase
(
)
.
includes
(
value
)
;
break
;
case
"
remote
-
ip
"
:
match
=
{
item
.
remoteAddress
}
:
{
item
.
remotePort
}
.
toLowerCase
(
)
.
includes
(
value
)
;
break
;
case
"
cause
"
:
let
causeType
=
item
.
cause
.
type
;
match
=
typeof
causeType
=
=
=
"
string
"
?
causeType
.
toLowerCase
(
)
.
includes
(
value
)
:
false
;
break
;
case
"
transferred
"
:
if
(
item
.
fromCache
)
{
match
=
false
;
}
else
{
match
=
getSizeOrder
(
value
)
=
=
=
getSizeOrder
(
item
.
transferredSize
)
;
}
break
;
case
"
size
"
:
match
=
getSizeOrder
(
value
)
=
=
=
getSizeOrder
(
item
.
contentSize
)
;
break
;
case
"
larger
-
than
"
:
match
=
item
.
contentSize
>
value
;
break
;
case
"
mime
-
type
"
:
match
=
item
.
mimeType
.
includes
(
value
)
;
break
;
case
"
is
"
:
if
(
value
=
=
=
"
from
-
cache
"
|
|
value
=
=
=
"
cached
"
)
{
match
=
item
.
fromCache
|
|
item
.
status
=
=
=
"
304
"
;
}
else
if
(
value
=
=
=
"
running
"
)
{
match
=
!
item
.
status
;
}
break
;
case
"
scheme
"
:
let
scheme
=
new
URL
(
item
.
url
)
.
protocol
.
replace
(
"
:
"
"
"
)
.
toLowerCase
(
)
;
match
=
scheme
=
=
=
value
;
break
;
}
if
(
negative
)
{
return
!
match
;
}
return
match
;
}
function
isTextFilterMatch
(
{
url
}
text
)
{
let
lowerCaseUrl
=
url
.
toLowerCase
(
)
;
let
lowerCaseText
=
text
.
toLowerCase
(
)
;
let
textLength
=
text
.
length
;
if
(
text
.
startsWith
(
"
-
"
)
&
&
textLength
>
1
)
{
lowerCaseText
=
lowerCaseText
.
substring
(
1
textLength
)
;
return
!
lowerCaseUrl
.
includes
(
lowerCaseText
)
;
}
return
!
text
|
|
lowerCaseUrl
.
includes
(
lowerCaseText
)
;
}
function
isFreetextMatch
(
item
text
)
{
if
(
!
text
)
{
return
true
;
}
let
filters
=
parseFilters
(
text
)
;
let
match
=
true
;
for
(
let
textFilter
of
filters
.
text
)
{
match
=
match
&
&
isTextFilterMatch
(
item
textFilter
)
;
}
for
(
let
flagFilter
of
filters
.
flags
)
{
match
=
match
&
&
isFlagFilterMatch
(
item
flagFilter
)
;
}
return
match
;
}
module
.
exports
=
{
isFreetextMatch
}
;
