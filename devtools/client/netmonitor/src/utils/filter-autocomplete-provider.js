"
use
strict
"
;
const
{
FILTER_FLAGS
}
=
require
(
"
.
.
/
constants
"
)
;
function
getAutocompleteValuesForFlag
(
flag
request
)
{
let
values
=
[
]
;
let
{
responseCookies
=
{
cookies
:
[
]
}
}
=
request
;
responseCookies
=
responseCookies
.
cookies
|
|
responseCookies
;
switch
(
flag
)
{
case
"
status
-
code
"
:
values
.
push
(
String
(
request
.
status
)
)
;
break
;
case
"
scheme
"
:
values
.
push
(
request
.
urlDetails
.
scheme
)
;
break
;
case
"
domain
"
:
values
.
push
(
request
.
urlDetails
.
host
)
;
break
;
case
"
remote
-
ip
"
:
values
.
push
(
request
.
remoteAddress
)
;
break
;
case
"
cause
"
:
values
.
push
(
request
.
cause
.
type
)
;
break
;
case
"
mime
-
type
"
:
values
.
push
(
request
.
mimeType
.
replace
(
/
;
.
+
/
"
"
)
)
;
break
;
case
"
set
-
cookie
-
name
"
:
values
=
responseCookies
.
map
(
c
=
>
c
.
name
)
;
break
;
case
"
set
-
cookie
-
value
"
:
values
=
responseCookies
.
map
(
c
=
>
c
.
value
)
;
break
;
case
"
set
-
cookie
-
domain
"
:
values
=
responseCookies
.
map
(
c
=
>
c
.
hasOwnProperty
(
"
domain
"
)
?
c
.
domain
:
request
.
urlDetails
.
host
)
;
break
;
case
"
is
"
:
values
=
[
"
cached
"
"
from
-
cache
"
"
running
"
]
;
break
;
case
"
has
-
response
-
header
"
:
values
=
request
.
responseHeaders
&
&
request
.
responseHeaders
.
headers
.
map
(
h
=
>
h
.
name
)
;
break
;
case
"
protocol
"
:
values
.
push
(
request
.
httpVersion
)
;
break
;
case
"
method
"
:
default
:
values
.
push
(
request
[
flag
]
)
;
}
return
values
;
}
function
getLastTokenFlagValues
(
lastToken
requests
)
{
if
(
!
lastToken
.
includes
(
"
:
"
)
)
{
return
[
]
;
}
let
[
flag
typedFlagValue
]
=
lastToken
.
split
(
"
:
"
)
;
let
isNegativeFlag
=
false
;
if
(
flag
.
startsWith
(
"
-
"
)
)
{
flag
=
flag
.
slice
(
1
)
;
isNegativeFlag
=
true
;
}
if
(
!
FILTER_FLAGS
.
includes
(
flag
)
)
{
return
[
]
;
}
let
values
=
[
]
;
for
(
let
request
of
requests
)
{
values
.
push
(
.
.
.
getAutocompleteValuesForFlag
(
flag
request
)
)
;
}
values
=
[
.
.
.
new
Set
(
values
)
]
;
return
values
.
filter
(
value
=
>
{
if
(
typedFlagValue
)
{
let
lowerTyped
=
typedFlagValue
.
toLowerCase
(
)
lowerValue
=
value
.
toLowerCase
(
)
;
return
lowerValue
.
includes
(
lowerTyped
)
&
&
lowerValue
!
=
=
lowerTyped
;
}
return
typeof
value
!
=
=
"
undefined
"
&
&
value
!
=
=
"
"
&
&
value
!
=
=
"
undefined
"
;
}
)
.
sort
(
)
.
map
(
value
=
>
isNegativeFlag
?
-
{
flag
}
:
{
value
}
:
{
flag
}
:
{
value
}
)
;
}
function
autocompleteProvider
(
filter
requests
)
{
if
(
!
filter
)
{
return
[
]
;
}
let
negativeAutocompleteList
=
FILTER_FLAGS
.
map
(
(
item
)
=
>
-
{
item
}
)
;
let
baseList
=
[
.
.
.
FILTER_FLAGS
.
.
.
negativeAutocompleteList
]
.
map
(
(
item
)
=
>
{
item
}
:
)
;
let
tokens
=
filter
.
split
(
/
\
s
+
/
g
)
;
let
lastToken
=
tokens
[
tokens
.
length
-
1
]
;
let
previousTokens
=
tokens
.
slice
(
0
tokens
.
length
-
1
)
;
if
(
!
lastToken
)
{
return
[
]
;
}
let
autocompleteList
;
let
availableValues
=
getLastTokenFlagValues
(
lastToken
requests
)
;
if
(
availableValues
.
length
>
0
)
{
autocompleteList
=
availableValues
;
}
else
{
autocompleteList
=
baseList
.
filter
(
(
item
)
=
>
{
return
item
.
toLowerCase
(
)
.
startsWith
(
lastToken
.
toLowerCase
(
)
)
&
&
item
.
toLowerCase
(
)
!
=
=
lastToken
.
toLowerCase
(
)
;
}
)
;
}
return
autocompleteList
.
sort
(
)
.
map
(
item
=
>
(
{
value
:
[
.
.
.
previousTokens
item
]
.
join
(
"
"
)
displayValue
:
item
}
)
)
;
}
module
.
exports
=
{
autocompleteProvider
}
;
