"
use
strict
"
;
const
{
getCssVariableColor
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
theme
.
js
"
)
;
const
{
REQUESTS_WATERFALL
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
constants
.
js
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
STATE_KEYS
=
[
"
firstRequestStartedMs
"
"
scale
"
"
timingMarkers
"
"
waterfallWidth
"
]
;
class
WaterfallBackground
{
constructor
(
)
{
this
.
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
this
.
ctx
=
this
.
canvas
.
getContext
(
"
2d
"
)
;
this
.
prevState
=
{
}
;
}
setImageElement
(
imageElementId
imageElement
)
{
if
(
document
.
mozSetImageElement
)
{
document
.
mozSetImageElement
(
imageElementId
imageElement
)
;
}
}
draw
(
state
)
{
const
shouldUpdate
=
STATE_KEYS
.
some
(
key
=
>
this
.
prevState
[
key
]
!
=
=
state
[
key
]
)
;
if
(
!
shouldUpdate
)
{
return
;
}
this
.
prevState
=
state
;
if
(
state
.
waterfallWidth
=
=
=
null
|
|
state
.
scale
=
=
=
null
)
{
this
.
setImageElement
(
"
waterfall
-
background
"
null
)
;
return
;
}
const
canvasWidth
=
(
this
.
canvas
.
width
=
Math
.
max
(
state
.
waterfallWidth
-
REQUESTS_WATERFALL
.
LABEL_WIDTH
1
)
)
;
const
canvasHeight
=
(
this
.
canvas
.
height
=
1
)
;
const
imageData
=
this
.
ctx
.
createImageData
(
canvasWidth
canvasHeight
)
;
const
pixelArray
=
imageData
.
data
;
const
buf
=
new
ArrayBuffer
(
pixelArray
.
length
)
;
const
view8bit
=
new
Uint8ClampedArray
(
buf
)
;
const
view32bit
=
new
Uint32Array
(
buf
)
;
let
timingStep
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_MULTIPLE
;
let
optimalTickIntervalFound
=
false
;
let
scaledStep
;
while
(
!
optimalTickIntervalFound
)
{
scaledStep
=
state
.
scale
*
timingStep
;
if
(
scaledStep
<
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_SPACING_MIN
)
{
timingStep
<
<
=
1
;
continue
;
}
optimalTickIntervalFound
=
true
;
}
const
isRTL
=
document
.
dir
=
=
=
"
rtl
"
;
const
[
r
g
b
]
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_COLOR_RGB
;
let
alphaComponent
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_OPACITY_MIN
;
function
drawPixelAt
(
offset
color
)
{
const
position
=
(
isRTL
?
canvasWidth
-
offset
:
offset
-
1
)
|
0
;
const
[
rc
gc
bc
ac
]
=
color
;
view32bit
[
position
]
=
(
ac
<
<
24
)
|
(
bc
<
<
16
)
|
(
gc
<
<
8
)
|
rc
;
}
for
(
let
i
=
1
;
i
<
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_SCALES
;
i
+
+
)
{
const
increment
=
scaledStep
*
Math
.
pow
(
2
i
)
;
for
(
let
x
=
0
;
x
<
canvasWidth
;
x
+
=
increment
)
{
drawPixelAt
(
x
[
r
g
b
alphaComponent
]
)
;
}
alphaComponent
+
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_OPACITY_ADD
;
}
function
drawTimestamp
(
timestamp
color
)
{
if
(
timestamp
=
=
=
-
1
)
{
return
;
}
const
delta
=
Math
.
floor
(
(
timestamp
-
state
.
firstRequestStartedMs
)
*
state
.
scale
)
;
drawPixelAt
(
delta
color
)
;
}
const
{
DOMCONTENTLOADED_TICKS_COLOR
LOAD_TICKS_COLOR
}
=
REQUESTS_WATERFALL
;
drawTimestamp
(
state
.
timingMarkers
.
firstDocumentDOMContentLoadedTimestamp
this
.
getThemeColorAsRgba
(
DOMCONTENTLOADED_TICKS_COLOR
)
)
;
drawTimestamp
(
state
.
timingMarkers
.
firstDocumentLoadTimestamp
this
.
getThemeColorAsRgba
(
LOAD_TICKS_COLOR
)
)
;
pixelArray
.
set
(
view8bit
)
;
try
{
this
.
ctx
.
putImageData
(
imageData
0
0
)
;
}
catch
(
e
)
{
console
.
error
(
"
WaterfallBackground
crash
error
"
e
)
;
}
this
.
setImageElement
(
"
waterfall
-
background
"
this
.
canvas
)
;
}
getThemeColorAsRgba
(
colorVariableName
)
{
const
colorStr
=
getCssVariableColor
(
colorVariableName
document
.
ownerGlobal
)
;
const
{
r
g
b
a
}
=
InspectorUtils
.
colorToRGBA
(
colorStr
)
;
return
[
r
g
b
a
*
255
]
;
}
destroy
(
)
{
this
.
setImageElement
(
"
waterfall
-
background
"
null
)
;
}
}
module
.
exports
=
WaterfallBackground
;
