"
use
strict
"
;
const
{
getColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
REQUESTS_WATERFALL
}
=
require
(
"
.
.
/
constants
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
STATE_KEYS
=
[
"
firstRequestStartedMillis
"
"
scale
"
"
timingMarkers
"
"
waterfallWidth
"
]
;
class
WaterfallBackground
{
constructor
(
)
{
this
.
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
this
.
ctx
=
this
.
canvas
.
getContext
(
"
2d
"
)
;
this
.
prevState
=
{
}
;
}
setImageElement
(
imageElementId
imageElement
)
{
if
(
document
.
mozSetImageElement
)
{
document
.
mozSetImageElement
(
imageElementId
imageElement
)
;
}
}
draw
(
state
)
{
const
shouldUpdate
=
STATE_KEYS
.
some
(
key
=
>
this
.
prevState
[
key
]
!
=
=
state
[
key
]
)
;
if
(
!
shouldUpdate
)
{
return
;
}
this
.
prevState
=
state
;
if
(
state
.
waterfallWidth
=
=
=
null
|
|
state
.
scale
=
=
=
null
)
{
this
.
setImageElement
(
"
waterfall
-
background
"
null
)
;
return
;
}
let
canvasWidth
=
this
.
canvas
.
width
=
state
.
waterfallWidth
-
REQUESTS_WATERFALL
.
LABEL_WIDTH
;
let
canvasHeight
=
this
.
canvas
.
height
=
1
;
let
imageData
=
this
.
ctx
.
createImageData
(
canvasWidth
canvasHeight
)
;
let
pixelArray
=
imageData
.
data
;
let
buf
=
new
ArrayBuffer
(
pixelArray
.
length
)
;
let
view8bit
=
new
Uint8ClampedArray
(
buf
)
;
let
view32bit
=
new
Uint32Array
(
buf
)
;
let
timingStep
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_MULTIPLE
;
let
optimalTickIntervalFound
=
false
;
let
scaledStep
;
while
(
!
optimalTickIntervalFound
)
{
scaledStep
=
state
.
scale
*
timingStep
;
if
(
scaledStep
<
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_SPACING_MIN
)
{
timingStep
<
<
=
1
;
continue
;
}
optimalTickIntervalFound
=
true
;
}
const
isRTL
=
document
.
dir
=
=
=
"
rtl
"
;
const
[
r
g
b
]
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_COLOR_RGB
;
let
alphaComponent
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_OPACITY_MIN
;
function
drawPixelAt
(
offset
color
)
{
let
position
=
(
isRTL
?
canvasWidth
-
offset
:
offset
-
1
)
|
0
;
let
[
rc
gc
bc
ac
]
=
color
;
view32bit
[
position
]
=
(
ac
<
<
24
)
|
(
bc
<
<
16
)
|
(
gc
<
<
8
)
|
rc
;
}
for
(
let
i
=
1
;
i
<
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_SCALES
;
i
+
+
)
{
let
increment
=
scaledStep
*
Math
.
pow
(
2
i
)
;
for
(
let
x
=
0
;
x
<
canvasWidth
;
x
+
=
increment
)
{
drawPixelAt
(
x
[
r
g
b
alphaComponent
]
)
;
}
alphaComponent
+
=
REQUESTS_WATERFALL
.
BACKGROUND_TICKS_OPACITY_ADD
;
}
function
drawTimestamp
(
timestamp
color
)
{
if
(
timestamp
=
=
=
-
1
)
{
return
;
}
let
delta
=
Math
.
floor
(
(
timestamp
-
state
.
firstRequestStartedMillis
)
*
state
.
scale
)
;
drawPixelAt
(
delta
color
)
;
}
let
{
DOMCONTENTLOADED_TICKS_COLOR
LOAD_TICKS_COLOR
}
=
REQUESTS_WATERFALL
;
drawTimestamp
(
state
.
timingMarkers
.
firstDocumentDOMContentLoadedTimestamp
this
.
getThemeColorAsRgba
(
DOMCONTENTLOADED_TICKS_COLOR
state
.
theme
)
)
;
drawTimestamp
(
state
.
timingMarkers
.
firstDocumentLoadTimestamp
this
.
getThemeColorAsRgba
(
LOAD_TICKS_COLOR
state
.
theme
)
)
;
pixelArray
.
set
(
view8bit
)
;
this
.
ctx
.
putImageData
(
imageData
0
0
)
;
this
.
setImageElement
(
"
waterfall
-
background
"
this
.
canvas
)
;
}
getThemeColorAsRgba
(
colorName
theme
)
{
let
colorStr
=
getColor
(
colorName
theme
)
;
let
color
=
new
colorUtils
.
CssColor
(
colorStr
)
;
let
{
r
g
b
}
=
color
.
getRGBATuple
(
)
;
return
[
r
g
b
REQUESTS_WATERFALL
.
TICKS_COLOR_OPACITY
]
;
}
destroy
(
)
{
this
.
setImageElement
(
"
waterfall
-
background
"
null
)
;
}
}
module
.
exports
=
WaterfallBackground
;
