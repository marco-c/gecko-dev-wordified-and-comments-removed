"
use
strict
"
;
const
{
getUrlDetails
processNetworkUpdates
}
=
require
(
"
.
.
/
utils
/
request
-
utils
"
)
;
const
{
ADD_REQUEST
CLEAR_REQUESTS
CLONE_SELECTED_REQUEST
OPEN_NETWORK_DETAILS
REMOVE_SELECTED_CUSTOM_REQUEST
SELECT_REQUEST
SEND_CUSTOM_REQUEST
TOGGLE_RECORDING
UPDATE_REQUEST
}
=
require
(
"
.
.
/
constants
"
)
;
function
Requests
(
)
{
return
{
requests
:
mapNew
(
)
selectedId
:
null
preselectedId
:
null
recording
:
true
firstStartedMillis
:
+
Infinity
lastEndedMillis
:
-
Infinity
}
;
}
function
requestsReducer
(
state
=
Requests
(
)
action
)
{
switch
(
action
.
type
)
{
case
ADD_REQUEST
:
{
let
nextState
=
{
.
.
.
state
}
;
let
newRequest
=
{
id
:
action
.
id
.
.
.
action
.
data
urlDetails
:
getUrlDetails
(
action
.
data
.
url
)
}
;
nextState
.
requests
=
mapSet
(
state
.
requests
newRequest
.
id
newRequest
)
;
let
{
startedMillis
}
=
action
.
data
;
if
(
startedMillis
<
state
.
firstStartedMillis
)
{
nextState
.
firstStartedMillis
=
startedMillis
;
}
if
(
startedMillis
>
state
.
lastEndedMillis
)
{
nextState
.
lastEndedMillis
=
startedMillis
;
}
if
(
state
.
preselectedId
&
&
state
.
preselectedId
=
=
=
action
.
id
)
{
nextState
.
selectedId
=
state
.
selectedId
|
|
state
.
preselectedId
;
nextState
.
preselectedId
=
null
;
}
return
nextState
;
}
case
UPDATE_REQUEST
:
{
let
{
requests
lastEndedMillis
}
=
state
;
let
request
=
requests
.
get
(
action
.
id
)
;
if
(
!
request
)
{
return
state
;
}
request
=
{
.
.
.
request
.
.
.
processNetworkUpdates
(
action
.
data
)
}
;
return
{
.
.
.
state
requests
:
mapSet
(
state
.
requests
action
.
id
request
)
lastEndedMillis
:
lastEndedMillis
}
;
}
case
CLEAR_REQUESTS
:
{
return
{
.
.
.
Requests
(
)
recording
:
state
.
recording
}
;
}
case
SELECT_REQUEST
:
{
return
{
.
.
.
state
selectedId
:
action
.
id
}
;
}
case
CLONE_SELECTED_REQUEST
:
{
let
{
requests
selectedId
}
=
state
;
if
(
!
selectedId
)
{
return
state
;
}
let
clonedRequest
=
requests
.
get
(
selectedId
)
;
if
(
!
clonedRequest
)
{
return
state
;
}
let
newRequest
=
{
id
:
clonedRequest
.
id
+
"
-
clone
"
method
:
clonedRequest
.
method
url
:
clonedRequest
.
url
urlDetails
:
clonedRequest
.
urlDetails
requestHeaders
:
clonedRequest
.
requestHeaders
requestPostData
:
clonedRequest
.
requestPostData
requestPostDataAvailable
:
clonedRequest
.
requestPostDataAvailable
isCustom
:
true
}
;
return
{
.
.
.
state
requests
:
mapSet
(
requests
newRequest
.
id
newRequest
)
selectedId
:
newRequest
.
id
}
;
}
case
REMOVE_SELECTED_CUSTOM_REQUEST
:
{
return
closeCustomRequest
(
state
)
;
}
case
SEND_CUSTOM_REQUEST
:
{
return
closeCustomRequest
(
{
.
.
.
state
preselectedId
:
action
.
id
}
)
;
}
case
TOGGLE_RECORDING
:
{
return
{
.
.
.
state
recording
:
!
state
.
recording
}
;
}
case
OPEN_NETWORK_DETAILS
:
{
let
nextState
=
{
.
.
.
state
}
;
if
(
!
action
.
open
)
{
nextState
.
selectedId
=
null
;
return
nextState
;
}
if
(
!
state
.
selectedId
&
&
!
state
.
requests
.
isEmpty
(
)
)
{
nextState
.
selectedId
=
[
.
.
.
state
.
requests
.
values
(
)
]
[
0
]
.
id
;
return
nextState
;
}
return
state
;
}
default
:
return
state
;
}
}
function
closeCustomRequest
(
state
)
{
let
{
requests
selectedId
}
=
state
;
if
(
!
selectedId
)
{
return
state
;
}
let
removedRequest
=
requests
.
get
(
selectedId
)
;
if
(
!
removedRequest
|
|
!
removedRequest
.
isCustom
)
{
return
state
;
}
return
{
.
.
.
state
requests
:
mapDelete
(
state
.
requests
selectedId
)
selectedId
:
null
}
;
}
function
mapNew
(
map
)
{
let
newMap
=
new
Map
(
map
)
;
newMap
.
isEmpty
=
(
)
=
>
newMap
.
size
=
=
0
;
newMap
.
valueSeq
=
(
)
=
>
[
.
.
.
newMap
.
values
(
)
]
;
return
newMap
;
}
function
mapSet
(
map
key
value
)
{
let
newMap
=
mapNew
(
map
)
;
return
newMap
.
set
(
key
value
)
;
}
function
mapDelete
(
map
key
)
{
let
newMap
=
mapNew
(
map
)
;
newMap
.
delete
(
key
)
;
return
newMap
;
}
module
.
exports
=
{
Requests
requestsReducer
}
;
