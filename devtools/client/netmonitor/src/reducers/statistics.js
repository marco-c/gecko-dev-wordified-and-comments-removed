"
use
strict
"
;
const
{
FILTER_TAGS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
constants
.
js
"
)
;
const
{
Filters
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
utils
/
filter
-
predicates
.
js
"
)
;
const
{
processNetworkUpdates
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
utils
/
request
-
utils
.
js
"
)
;
const
{
ADD_REQUEST
UPDATE_REQUEST
CLEAR_REQUESTS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
constants
.
js
"
)
;
function
initStatisticsData
(
)
{
return
FILTER_TAGS
.
map
(
type
=
>
(
{
cached
:
0
count
:
0
label
:
type
size
:
0
transferredSize
:
0
time
:
0
nonBlockingTime
:
0
}
)
)
;
}
function
Statistics
(
)
{
return
{
mutableRequests
:
[
]
mutableUsedRequests
:
new
Set
(
)
statisticsData
:
{
emptyCacheData
:
initStatisticsData
(
)
primedCacheData
:
initStatisticsData
(
)
}
}
;
}
function
statisticsReducer
(
state
=
Statistics
(
)
action
)
{
switch
(
action
.
type
)
{
case
ADD_REQUEST
:
{
return
addRequest
(
state
action
)
;
}
case
UPDATE_REQUEST
:
{
const
index
=
state
.
mutableRequests
.
findIndex
(
request
=
>
request
.
id
=
=
=
action
.
id
)
;
if
(
index
=
=
=
-
1
)
{
return
state
;
}
const
request
=
state
.
mutableRequests
[
index
]
;
const
updatedRequest
=
{
.
.
.
request
.
.
.
processNetworkUpdates
(
action
.
data
)
}
;
state
.
mutableRequests
[
index
]
=
updatedRequest
;
return
updateStatisticsData
(
state
state
.
mutableRequests
[
index
]
)
;
}
case
CLEAR_REQUESTS
:
{
return
{
.
.
.
Statistics
(
)
}
;
}
default
:
return
state
;
}
}
function
addRequest
(
state
action
)
{
const
{
targetFront
.
.
.
requestData
}
=
action
.
data
;
const
newRequest
=
{
id
:
action
.
id
.
.
.
requestData
}
;
state
.
mutableRequests
.
push
(
newRequest
)
;
return
state
;
}
function
updateStatisticsData
(
state
request
)
{
if
(
request
.
contentSize
=
=
undefined
|
|
!
request
.
mimeType
|
|
!
request
.
eventTimings
|
|
!
request
.
responseHeaders
|
|
request
.
status
=
=
undefined
|
|
request
.
totalTime
=
=
undefined
|
|
state
.
mutableUsedRequests
.
has
(
request
.
id
)
)
{
return
state
;
}
const
{
statisticsData
:
{
emptyCacheData
primedCacheData
}
}
=
state
;
let
dataType
=
8
;
for
(
const
[
index
type
]
of
FILTER_TAGS
.
entries
(
)
)
{
if
(
Filters
[
type
]
(
request
)
)
{
dataType
=
index
;
}
if
(
Filters
.
xhr
(
request
)
)
{
dataType
=
3
;
}
}
let
newEmptyCacheData
=
[
.
.
.
emptyCacheData
]
;
let
newPrimedCacheData
=
[
.
.
.
primedCacheData
]
;
newEmptyCacheData
=
setData
(
newEmptyCacheData
request
dataType
true
)
;
newPrimedCacheData
=
setData
(
newPrimedCacheData
request
dataType
false
)
;
state
.
mutableUsedRequests
.
add
(
request
.
id
)
;
return
{
mutableRequests
:
state
.
mutableRequests
mutableUsedRequests
:
state
.
mutableUsedRequests
statisticsData
:
{
emptyCacheData
:
newEmptyCacheData
primedCacheData
:
newPrimedCacheData
}
}
;
}
function
setData
(
cacheData
request
dataType
emptyCache
)
{
if
(
emptyCache
|
|
!
responseIsFresh
(
request
)
)
{
cacheData
[
dataType
]
.
time
+
=
request
.
totalTime
|
|
0
;
cacheData
[
dataType
]
.
size
+
=
request
.
contentSize
|
|
0
;
cacheData
[
dataType
]
.
transferredSize
+
=
request
.
transferredSize
|
|
0
;
const
nonBlockingTime
=
request
.
eventTimings
.
totalTime
-
(
request
.
eventTimings
.
timings
?
.
blocked
|
|
0
)
;
cacheData
[
dataType
]
.
nonBlockingTime
+
=
nonBlockingTime
|
|
0
;
}
else
{
cacheData
[
dataType
]
.
cached
+
+
;
}
cacheData
[
dataType
]
.
count
+
+
;
return
cacheData
;
}
function
responseIsFresh
(
{
responseHeaders
status
}
)
{
if
(
status
!
=
304
|
|
!
responseHeaders
)
{
return
false
;
}
const
list
=
responseHeaders
.
headers
;
const
cacheControl
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
=
"
cache
-
control
"
)
;
const
expires
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
=
"
expires
"
)
;
if
(
cacheControl
)
{
const
maxAgeMatch
=
cacheControl
.
value
.
match
(
/
s
-
maxage
\
s
*
=
\
s
*
(
\
d
+
)
/
)
|
|
cacheControl
.
value
.
match
(
/
max
-
age
\
s
*
=
\
s
*
(
\
d
+
)
/
)
;
if
(
maxAgeMatch
&
&
maxAgeMatch
.
pop
(
)
>
0
)
{
return
true
;
}
}
if
(
expires
&
&
Date
.
parse
(
expires
.
value
)
)
{
return
true
;
}
return
false
;
}
module
.
exports
=
{
statisticsReducer
}
;
