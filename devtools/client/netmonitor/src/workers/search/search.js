"
use
strict
"
;
function
searchInResource
(
resource
query
)
{
const
results
=
[
]
;
if
(
resource
.
url
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
url
"
label
:
"
Url
"
type
:
"
url
"
panel
:
"
headers
"
}
)
)
;
}
if
(
resource
.
responseHeaders
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
responseHeaders
.
headers
"
type
:
"
responseHeaders
"
panel
:
"
headers
"
}
)
)
;
}
if
(
resource
.
requestHeaders
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
requestHeaders
.
headers
"
type
:
"
requestHeaders
"
panel
:
"
headers
"
}
)
)
;
}
if
(
resource
.
requestHeadersFromUploadStream
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
requestHeadersFromUploadStream
.
headers
"
type
:
"
requestHeadersFromUploadStream
"
panel
:
"
headers
"
}
)
)
;
}
if
(
resource
.
responseCookies
)
{
let
key
=
"
responseCookies
"
;
if
(
resource
.
responseCookies
.
cookies
)
{
key
=
"
responseCookies
.
cookies
"
;
}
results
.
push
(
findMatches
(
resource
query
{
key
type
:
"
responseCookies
"
panel
:
"
cookies
"
}
)
)
;
}
if
(
resource
.
requestCookies
)
{
let
key
=
"
requestCookies
"
;
if
(
resource
.
requestCookies
.
cookies
)
{
key
=
"
requestCookies
.
cookies
"
;
}
results
.
push
(
findMatches
(
resource
query
{
key
type
:
"
requestCookies
"
panel
:
"
cookies
"
}
)
)
;
}
if
(
resource
.
responseContent
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
responseContent
.
content
.
text
"
type
:
"
responseContent
"
panel
:
"
response
"
}
)
)
;
}
if
(
resource
.
requestPostData
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
requestPostData
.
postData
.
text
"
type
:
"
requestPostData
"
panel
:
"
params
"
}
)
)
;
}
return
getResults
(
results
resource
)
;
}
function
getResults
(
results
resource
)
{
const
tempResults
=
[
]
.
concat
.
apply
(
[
]
results
)
;
tempResults
.
forEach
(
(
result
index
)
=
>
{
result
.
key
=
index
;
result
.
parentResource
=
resource
;
}
)
;
return
tempResults
;
}
function
findMatches
(
resource
query
data
)
{
if
(
!
resource
|
|
!
query
|
|
!
data
)
{
return
[
]
;
}
const
resourceValue
=
getValue
(
data
.
key
resource
)
;
const
resourceType
=
getType
(
resourceValue
)
;
if
(
resource
.
hasOwnProperty
(
"
name
"
)
&
&
resource
.
hasOwnProperty
(
"
value
"
)
)
{
return
searchInProperties
(
query
resource
data
)
;
}
switch
(
resourceType
)
{
case
"
string
"
:
return
searchInText
(
query
resourceValue
data
)
;
case
"
array
"
:
return
searchInArray
(
query
resourceValue
data
)
;
case
"
object
"
:
return
searchInObject
(
query
resourceValue
data
)
;
default
:
return
[
]
;
}
}
function
searchInProperties
(
query
obj
data
)
{
const
match
=
{
.
.
.
data
}
;
if
(
obj
.
name
.
includes
(
query
)
)
{
match
.
label
=
obj
.
name
;
}
if
(
obj
.
name
.
includes
(
query
)
|
|
obj
.
value
.
includes
(
query
)
)
{
match
.
value
=
obj
.
value
;
match
.
startIndex
=
obj
.
value
.
indexOf
(
query
)
;
return
match
;
}
return
[
]
;
}
function
getType
(
resource
)
{
return
Array
.
isArray
(
resource
)
?
"
array
"
:
typeof
resource
;
}
function
getValue
(
path
obj
)
{
const
properties
=
Array
.
isArray
(
path
)
?
path
:
path
.
split
(
"
.
"
)
;
return
properties
.
reduce
(
(
prev
curr
)
=
>
prev
&
&
prev
[
curr
]
obj
)
;
}
function
searchInText
(
query
text
data
)
{
const
{
type
}
=
data
;
const
lines
=
text
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
;
const
matches
=
[
]
;
lines
.
forEach
(
(
curr
i
)
=
>
{
const
regexQuery
=
RegExp
(
query
"
gmi
"
)
;
const
lineMatches
=
[
]
;
let
singleMatch
;
while
(
(
singleMatch
=
regexQuery
.
exec
(
lines
[
i
]
)
)
!
=
=
null
)
{
const
startIndex
=
regexQuery
.
lastIndex
;
lineMatches
.
push
(
startIndex
)
;
}
if
(
lineMatches
.
length
!
=
=
0
)
{
const
line
=
i
+
1
;
const
match
=
{
.
.
.
data
label
:
type
!
=
=
"
url
"
?
line
+
"
"
:
"
Url
"
line
startIndex
:
lineMatches
}
;
match
.
value
=
lineMatches
.
length
=
=
=
1
?
getTruncatedValue
(
lines
[
i
]
query
lineMatches
[
0
]
)
:
lines
[
i
]
;
matches
.
push
(
match
)
;
}
}
)
;
return
matches
.
length
=
=
=
0
?
[
]
:
matches
;
}
function
searchInArray
(
query
arr
data
)
{
const
{
key
label
}
=
data
;
const
matches
=
arr
.
filter
(
match
=
>
JSON
.
stringify
(
match
)
.
includes
(
query
)
)
.
map
(
(
match
i
)
=
>
findMatches
(
match
query
{
.
.
.
data
label
:
match
.
hasOwnProperty
(
"
name
"
)
?
match
.
name
:
label
key
:
key
+
"
.
[
"
+
i
+
"
]
"
}
)
)
;
return
getResults
(
matches
)
;
}
function
getTruncatedValue
(
value
query
startIndex
)
{
const
valueSize
=
value
.
length
;
const
indexEnd
=
startIndex
+
query
.
length
;
if
(
valueSize
<
100
+
query
.
length
)
{
return
value
;
}
const
start
=
value
.
substring
(
startIndex
startIndex
-
50
)
;
const
end
=
value
.
substring
(
indexEnd
indexEnd
+
50
)
;
return
start
+
end
;
}
function
searchInObject
(
query
obj
data
)
{
const
matches
=
data
.
hasOwnProperty
(
"
collector
"
)
?
data
.
collector
:
[
]
;
for
(
const
objectKey
in
obj
)
{
const
objectKeyType
=
getType
(
obj
[
objectKey
]
)
;
if
(
objectKeyType
=
=
=
"
object
"
&
&
Object
.
keys
(
obj
[
objectKey
]
.
length
>
1
)
)
{
searchInObject
(
query
obj
[
objectKey
]
{
.
.
.
data
collector
:
matches
}
)
;
}
else
if
(
(
objectKeyType
=
=
=
"
string
"
&
&
obj
[
objectKey
]
.
includes
(
query
)
)
|
|
objectKey
.
includes
(
query
)
)
{
const
match
=
{
.
.
.
data
}
;
const
value
=
obj
[
objectKey
]
;
const
startIndex
=
value
.
indexOf
(
query
)
;
match
.
label
=
objectKey
;
match
.
startIndex
=
startIndex
;
match
.
value
=
getTruncatedValue
(
value
query
startIndex
)
;
matches
.
push
(
match
)
;
}
}
return
matches
;
}
