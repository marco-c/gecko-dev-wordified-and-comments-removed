"
use
strict
"
;
function
searchInResource
(
resource
query
)
{
const
results
=
[
]
;
if
(
resource
.
url
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
url
"
label
:
"
Url
"
type
:
"
url
"
}
)
)
;
}
if
(
resource
.
responseHeaders
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
responseHeaders
.
headers
"
label
:
"
Response
Headers
"
type
:
"
responseHeaders
"
}
)
)
;
}
if
(
resource
.
requestHeaders
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
requestHeaders
.
headers
"
label
:
"
Request
Headers
"
type
:
"
requestHeaders
"
}
)
)
;
}
if
(
resource
.
responseCookies
)
{
let
key
=
"
responseCookies
"
;
if
(
resource
.
responseCookies
.
cookies
)
{
key
=
"
responseCookies
.
cookies
"
;
}
results
.
push
(
findMatches
(
resource
query
{
key
label
:
"
Response
Cookies
"
type
:
"
responseCookies
"
}
)
)
;
}
if
(
resource
.
requestCookies
)
{
let
key
=
"
requestCookies
"
;
if
(
resource
.
requestCookies
.
cookies
)
{
key
=
"
requestCookies
.
cookies
"
;
}
results
.
push
(
findMatches
(
resource
query
{
key
label
:
"
Request
Cookies
"
type
:
"
requestCookies
"
}
)
)
;
}
if
(
resource
.
securityInfo
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
securityInfo
"
label
:
"
Security
Information
"
type
:
"
securityInfo
"
}
)
)
;
}
if
(
resource
.
responseContent
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
responseContent
.
content
.
text
"
label
:
"
Response
Content
"
type
:
"
responseContent
"
}
)
)
;
}
if
(
resource
.
requestPostData
)
{
results
.
push
(
findMatches
(
resource
query
{
key
:
"
requestPostData
.
postData
.
text
"
label
:
"
Request
Post
Data
"
type
:
"
requestPostData
"
}
)
)
;
}
return
getResults
(
results
)
;
}
function
getResults
(
results
)
{
const
tempResults
=
[
]
.
concat
.
apply
(
[
]
results
)
;
tempResults
.
forEach
(
(
result
index
)
=
>
{
result
.
key
=
index
;
}
)
;
return
tempResults
;
}
function
findMatches
(
resource
query
data
)
{
if
(
!
resource
|
|
!
query
|
|
!
data
)
{
return
[
]
;
}
const
resourceValue
=
getValue
(
data
.
key
resource
)
;
const
resourceType
=
getType
(
resourceValue
)
;
switch
(
resourceType
)
{
case
"
string
"
:
return
searchInText
(
query
resourceValue
data
)
;
case
"
array
"
:
return
searchInArray
(
query
resourceValue
data
)
;
case
"
object
"
:
return
searchInObject
(
query
resourceValue
data
)
;
default
:
return
[
]
;
}
}
function
getType
(
resource
)
{
return
Array
.
isArray
(
resource
)
?
"
array
"
:
typeof
resource
;
}
function
getValue
(
path
obj
)
{
const
properties
=
Array
.
isArray
(
path
)
?
path
:
path
.
split
(
"
.
"
)
;
return
properties
.
reduce
(
(
prev
curr
)
=
>
prev
&
&
prev
[
curr
]
obj
)
;
}
function
searchInText
(
query
text
data
)
{
const
{
type
label
}
=
data
;
const
lines
=
text
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
;
const
matches
=
[
]
;
lines
.
forEach
(
(
curr
i
arr
)
=
>
{
const
regexQuery
=
RegExp
(
query
"
gmi
"
)
;
let
singleMatch
;
while
(
(
singleMatch
=
regexQuery
.
exec
(
lines
[
i
]
)
)
!
=
=
null
)
{
const
startIndex
=
regexQuery
.
lastIndex
;
matches
.
push
(
{
type
label
line
:
i
value
:
getTruncatedValue
(
lines
[
i
]
query
startIndex
)
startIndex
}
)
;
}
}
)
;
return
matches
.
length
=
=
=
0
?
[
]
:
matches
;
}
function
searchInArray
(
query
arr
data
)
{
const
{
type
key
label
}
=
data
;
const
matches
=
arr
.
filter
(
match
=
>
JSON
.
stringify
(
match
)
.
includes
(
query
)
)
.
map
(
(
match
i
)
=
>
findMatches
(
match
query
{
label
key
:
key
+
"
.
[
"
+
i
+
"
]
"
type
}
)
)
;
return
getResults
(
matches
)
;
}
function
getTruncatedValue
(
value
query
startIndex
)
{
const
valueSize
=
value
.
length
;
const
indexEnd
=
startIndex
+
query
.
length
;
if
(
valueSize
<
200
+
query
.
length
)
{
return
value
;
}
const
start
=
value
.
substring
(
startIndex
startIndex
-
100
)
;
const
end
=
value
.
substring
(
indexEnd
indexEnd
+
100
)
;
return
start
+
query
+
end
;
}
function
searchInObject
(
query
obj
data
)
{
const
{
type
label
}
=
data
;
const
matches
=
data
.
hasOwnProperty
(
"
collector
"
)
?
data
.
collector
:
[
]
;
for
(
const
objectKey
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
objectKey
)
)
{
if
(
typeof
obj
[
objectKey
]
=
=
=
"
object
"
)
{
searchInObject
(
obj
[
objectKey
]
query
{
collector
:
matches
type
label
:
objectKey
}
)
;
}
let
location
;
if
(
objectKey
)
{
if
(
objectKey
.
includes
(
query
)
)
{
location
=
"
name
"
;
}
else
if
(
typeof
obj
[
objectKey
]
=
=
=
"
string
"
&
&
obj
[
objectKey
]
.
includes
(
query
)
)
{
location
=
"
value
"
;
}
}
if
(
!
location
)
{
continue
;
}
const
match
=
{
type
label
:
objectKey
}
;
const
value
=
location
=
=
=
"
name
"
?
objectKey
:
obj
[
objectKey
]
;
const
startIndex
=
value
.
indexOf
(
query
)
;
match
.
startIndex
=
startIndex
;
match
.
value
=
getTruncatedValue
(
value
query
startIndex
)
;
matches
.
push
(
match
)
;
}
}
return
matches
;
}
