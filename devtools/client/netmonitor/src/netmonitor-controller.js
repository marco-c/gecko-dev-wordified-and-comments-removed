"
use
strict
"
;
const
{
TimelineFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
timeline
"
)
;
const
{
CurlUtils
}
=
require
(
"
devtools
/
client
/
shared
/
curl
"
)
;
const
{
ACTIVITY_TYPE
EVENTS
}
=
require
(
"
.
/
constants
"
)
;
const
Actions
=
require
(
"
.
/
actions
/
index
"
)
;
const
{
fetchHeaders
formDataURI
}
=
require
(
"
.
/
utils
/
request
-
utils
"
)
;
const
{
getLongString
getWebConsoleClient
onFirefoxConnect
onFirefoxDisconnect
}
=
require
(
"
.
/
utils
/
client
"
)
;
const
{
getRequestById
getDisplayedRequestById
}
=
require
(
"
.
/
selectors
/
index
"
)
;
var
NetMonitorController
=
{
startupNetMonitor
(
connection
)
{
if
(
this
.
_startup
)
{
return
this
.
_startup
;
}
this
.
_startup
=
new
Promise
(
async
(
resolve
)
=
>
{
await
this
.
connect
(
connection
)
;
resolve
(
)
;
}
)
;
return
this
.
_startup
;
}
shutdownNetMonitor
(
)
{
if
(
this
.
_shutdown
)
{
return
this
.
_shutdown
;
}
this
.
_shutdown
=
new
Promise
(
async
(
resolve
)
=
>
{
window
.
gStore
.
dispatch
(
Actions
.
batchReset
(
)
)
;
onFirefoxDisconnect
(
this
.
_target
)
;
this
.
_target
.
off
(
"
close
"
this
.
_onTabDetached
)
;
this
.
NetworkEventsHandler
.
disconnect
(
)
;
await
this
.
disconnect
(
)
;
resolve
(
)
;
}
)
;
return
this
.
_shutdown
;
}
connect
(
connection
)
{
if
(
this
.
_connection
)
{
return
this
.
_connection
;
}
this
.
_onTabDetached
=
this
.
shutdownNetMonitor
.
bind
(
this
)
;
this
.
_connection
=
new
Promise
(
async
(
resolve
)
=
>
{
this
.
toolbox
=
connection
.
toolbox
;
this
.
_target
=
connection
.
tabConnection
.
tabTarget
;
this
.
tabClient
=
this
.
_target
.
isTabActor
?
this
.
_target
.
activeTab
:
null
;
let
connectTimeline
=
(
)
=
>
{
if
(
this
.
_target
.
getTrait
(
"
documentLoadingMarkers
"
)
)
{
this
.
timelineFront
=
new
TimelineFront
(
this
.
_target
.
client
this
.
_target
.
form
)
;
return
this
.
timelineFront
.
start
(
{
withDocLoadingEvents
:
true
}
)
;
}
return
undefined
;
}
;
await
connectTimeline
(
)
;
onFirefoxConnect
(
this
.
_target
)
;
this
.
_target
.
on
(
"
close
"
this
.
_onTabDetached
)
;
this
.
webConsoleClient
=
getWebConsoleClient
(
)
;
this
.
NetworkEventsHandler
=
new
NetworkEventsHandler
(
)
;
this
.
NetworkEventsHandler
.
connect
(
)
;
window
.
emit
(
EVENTS
.
CONNECTED
)
;
resolve
(
)
;
this
.
_connected
=
true
;
}
)
;
return
this
.
_connection
;
}
disconnect
(
)
{
if
(
this
.
_disconnection
)
{
return
this
.
_disconnection
;
}
this
.
_disconnection
=
new
Promise
(
async
(
resolve
)
=
>
{
if
(
!
this
.
_connected
)
{
await
this
.
_connection
;
}
this
.
tabClient
=
null
;
this
.
webConsoleClient
=
null
;
if
(
this
.
_target
.
getTrait
(
"
documentLoadingMarkers
"
)
)
{
await
this
.
timelineFront
.
destroy
(
)
;
this
.
timelineFront
=
null
;
}
resolve
(
)
;
this
.
_connected
=
false
;
}
)
;
return
this
.
_disconnection
;
}
triggerActivity
:
function
(
type
)
{
let
standBy
=
(
)
=
>
{
this
.
_currentActivity
=
ACTIVITY_TYPE
.
NONE
;
}
;
let
waitForNavigation
=
(
)
=
>
{
return
new
Promise
(
(
resolve
)
=
>
{
this
.
_target
.
once
(
"
will
-
navigate
"
(
)
=
>
{
this
.
_target
.
once
(
"
navigate
"
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
;
let
reconfigureTab
=
options
=
>
{
return
new
Promise
(
(
resolve
)
=
>
{
this
.
_target
.
activeTab
.
reconfigure
(
options
resolve
)
;
}
)
;
}
;
let
reconfigureTabAndWaitForNavigation
=
options
=
>
{
options
.
performReload
=
true
;
let
navigationFinished
=
waitForNavigation
(
)
;
return
reconfigureTab
(
options
)
.
then
(
(
)
=
>
navigationFinished
)
;
}
;
if
(
type
=
=
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_DEFAULT
)
{
return
reconfigureTabAndWaitForNavigation
(
{
}
)
.
then
(
standBy
)
;
}
if
(
type
=
=
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_ENABLED
)
{
this
.
_currentActivity
=
ACTIVITY_TYPE
.
ENABLE_CACHE
;
this
.
_target
.
once
(
"
will
-
navigate
"
(
)
=
>
{
this
.
_currentActivity
=
type
;
}
)
;
return
reconfigureTabAndWaitForNavigation
(
{
cacheDisabled
:
false
performReload
:
true
}
)
.
then
(
standBy
)
;
}
if
(
type
=
=
ACTIVITY_TYPE
.
RELOAD
.
WITH_CACHE_DISABLED
)
{
this
.
_currentActivity
=
ACTIVITY_TYPE
.
DISABLE_CACHE
;
this
.
_target
.
once
(
"
will
-
navigate
"
(
)
=
>
{
this
.
_currentActivity
=
type
;
}
)
;
return
reconfigureTabAndWaitForNavigation
(
{
cacheDisabled
:
true
performReload
:
true
}
)
.
then
(
standBy
)
;
}
if
(
type
=
=
ACTIVITY_TYPE
.
ENABLE_CACHE
)
{
this
.
_currentActivity
=
type
;
return
reconfigureTab
(
{
cacheDisabled
:
false
performReload
:
false
}
)
.
then
(
standBy
)
;
}
if
(
type
=
=
ACTIVITY_TYPE
.
DISABLE_CACHE
)
{
this
.
_currentActivity
=
type
;
return
reconfigureTab
(
{
cacheDisabled
:
true
performReload
:
false
}
)
.
then
(
standBy
)
;
}
this
.
_currentActivity
=
ACTIVITY_TYPE
.
NONE
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
activity
type
"
)
)
;
}
inspectRequest
(
requestId
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
request
=
null
;
let
inspector
=
(
)
=
>
{
request
=
getDisplayedRequestById
(
window
.
gStore
.
getState
(
)
requestId
)
;
if
(
!
request
)
{
window
.
gStore
.
dispatch
(
Actions
.
toggleRequestFilterType
(
"
all
"
)
)
;
request
=
getDisplayedRequestById
(
window
.
gStore
.
getState
(
)
requestId
)
;
}
if
(
request
)
{
window
.
off
(
EVENTS
.
REQUEST_ADDED
inspector
)
;
window
.
gStore
.
dispatch
(
Actions
.
selectRequest
(
request
.
id
)
)
;
resolve
(
)
;
}
}
;
inspector
(
)
;
if
(
!
request
)
{
window
.
on
(
EVENTS
.
REQUEST_ADDED
inspector
)
;
}
}
)
;
}
get
supportsCustomRequest
(
)
{
return
this
.
webConsoleClient
&
&
(
this
.
webConsoleClient
.
traits
.
customNetworkRequest
|
|
!
this
.
_target
.
isApp
)
;
}
get
supportsPerfStats
(
)
{
return
this
.
tabClient
&
&
(
this
.
tabClient
.
traits
.
reconfigure
|
|
!
this
.
_target
.
isApp
)
;
}
viewSourceInDebugger
(
sourceURL
sourceLine
)
{
if
(
this
.
toolbox
)
{
this
.
toolbox
.
viewSourceInDebugger
(
sourceURL
sourceLine
)
;
}
}
}
;
function
NetworkEventsHandler
(
)
{
this
.
addRequest
=
this
.
addRequest
.
bind
(
this
)
;
this
.
updateRequest
=
this
.
updateRequest
.
bind
(
this
)
;
this
.
_onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
_onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_onDocLoadingMarker
=
this
.
_onDocLoadingMarker
.
bind
(
this
)
;
this
.
_onRequestHeaders
=
this
.
_onRequestHeaders
.
bind
(
this
)
;
this
.
_onRequestCookies
=
this
.
_onRequestCookies
.
bind
(
this
)
;
this
.
_onRequestPostData
=
this
.
_onRequestPostData
.
bind
(
this
)
;
this
.
_onResponseHeaders
=
this
.
_onResponseHeaders
.
bind
(
this
)
;
this
.
_onResponseCookies
=
this
.
_onResponseCookies
.
bind
(
this
)
;
this
.
_onResponseContent
=
this
.
_onResponseContent
.
bind
(
this
)
;
this
.
_onSecurityInfo
=
this
.
_onSecurityInfo
.
bind
(
this
)
;
this
.
_onEventTimings
=
this
.
_onEventTimings
.
bind
(
this
)
;
}
NetworkEventsHandler
.
prototype
=
{
get
client
(
)
{
return
NetMonitorController
.
_target
.
client
;
}
get
webConsoleClient
(
)
{
return
NetMonitorController
.
webConsoleClient
;
}
get
timelineFront
(
)
{
return
NetMonitorController
.
timelineFront
;
}
connect
:
function
(
)
{
this
.
webConsoleClient
.
on
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
on
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
if
(
this
.
timelineFront
)
{
this
.
timelineFront
.
on
(
"
doc
-
loading
"
this
.
_onDocLoadingMarker
)
;
}
this
.
_displayCachedEvents
(
)
;
}
disconnect
:
function
(
)
{
if
(
!
this
.
client
)
{
return
;
}
this
.
webConsoleClient
.
off
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
off
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
if
(
this
.
timelineFront
)
{
this
.
timelineFront
.
off
(
"
doc
-
loading
"
this
.
_onDocLoadingMarker
)
;
}
}
_displayCachedEvents
:
function
(
)
{
for
(
let
cachedEvent
of
this
.
webConsoleClient
.
getNetworkEvents
(
)
)
{
this
.
_onNetworkEvent
(
"
networkEvent
"
cachedEvent
)
;
for
(
let
update
of
cachedEvent
.
updates
)
{
this
.
_onNetworkEventUpdate
(
"
networkEventUpdate
"
{
packet
:
{
updateType
:
update
}
networkInfo
:
cachedEvent
}
)
;
}
}
}
_onDocLoadingMarker
:
function
(
marker
)
{
window
.
emit
(
EVENTS
.
TIMELINE_EVENT
marker
)
;
window
.
gStore
.
dispatch
(
Actions
.
addTimingMarker
(
marker
)
)
;
}
_onNetworkEvent
:
function
(
type
networkInfo
)
{
let
{
actor
startedDateTime
request
:
{
method
url
}
isXHR
cause
fromCache
fromServiceWorker
}
=
networkInfo
;
this
.
addRequest
(
actor
{
startedDateTime
method
url
isXHR
cause
fromCache
fromServiceWorker
}
)
;
window
.
emit
(
EVENTS
.
NETWORK_EVENT
actor
)
;
}
addRequest
(
id
data
)
{
let
{
method
url
isXHR
cause
startedDateTime
fromCache
fromServiceWorker
}
=
data
;
window
.
gStore
.
dispatch
(
Actions
.
addRequest
(
id
{
startedMillis
:
Date
.
parse
(
startedDateTime
)
method
url
isXHR
cause
fromCache
fromServiceWorker
}
true
)
)
.
then
(
(
)
=
>
window
.
emit
(
EVENTS
.
REQUEST_ADDED
id
)
)
;
}
async
updateRequest
(
id
data
)
{
const
action
=
Actions
.
updateRequest
(
id
data
true
)
;
await
window
.
gStore
.
dispatch
(
action
)
;
let
{
responseContent
responseCookies
responseHeaders
requestCookies
requestHeaders
requestPostData
}
=
action
.
data
;
let
request
=
getRequestById
(
window
.
gStore
.
getState
(
)
action
.
id
)
;
if
(
requestHeaders
&
&
requestHeaders
.
headers
&
&
requestHeaders
.
headers
.
length
)
{
let
headers
=
await
fetchHeaders
(
requestHeaders
getLongString
)
;
if
(
headers
)
{
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
{
requestHeaders
:
headers
}
true
)
)
;
}
}
if
(
responseHeaders
&
&
responseHeaders
.
headers
&
&
responseHeaders
.
headers
.
length
)
{
let
headers
=
await
fetchHeaders
(
responseHeaders
getLongString
)
;
if
(
headers
)
{
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
{
responseHeaders
:
headers
}
true
)
)
;
}
}
if
(
request
&
&
responseContent
&
&
responseContent
.
content
)
{
let
{
mimeType
}
=
request
;
let
{
text
encoding
}
=
responseContent
.
content
;
let
response
=
await
getLongString
(
text
)
;
let
payload
=
{
}
;
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
payload
.
responseContentDataUri
=
formDataURI
(
mimeType
encoding
response
)
;
}
responseContent
.
content
.
text
=
response
;
payload
.
responseContent
=
responseContent
;
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
payload
true
)
)
;
if
(
mimeType
.
includes
(
"
image
/
"
)
)
{
window
.
emit
(
EVENTS
.
RESPONSE_IMAGE_THUMBNAIL_DISPLAYED
)
;
}
}
if
(
requestPostData
&
&
requestPostData
.
postData
)
{
let
{
text
}
=
requestPostData
.
postData
;
let
postData
=
await
getLongString
(
text
)
;
const
headers
=
CurlUtils
.
getHeadersFromMultipartText
(
postData
)
;
const
headersSize
=
headers
.
reduce
(
(
acc
{
name
value
}
)
=
>
{
return
acc
+
name
.
length
+
value
.
length
+
2
;
}
0
)
;
let
payload
=
{
}
;
requestPostData
.
postData
.
text
=
postData
;
payload
.
requestPostData
=
Object
.
assign
(
{
}
requestPostData
)
;
payload
.
requestHeadersFromUploadStream
=
{
headers
headersSize
}
;
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
payload
true
)
)
;
}
if
(
requestCookies
)
{
let
reqCookies
=
[
]
;
let
cookies
=
requestCookies
.
cookies
?
requestCookies
.
cookies
:
requestCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
let
cookie
of
cookies
)
{
reqCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
reqCookies
.
length
)
{
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
{
requestCookies
:
reqCookies
}
true
)
)
;
}
}
}
if
(
responseCookies
)
{
let
resCookies
=
[
]
;
let
cookies
=
responseCookies
.
cookies
?
responseCookies
.
cookies
:
responseCookies
;
if
(
typeof
cookies
[
Symbol
.
iterator
]
=
=
=
"
function
"
)
{
for
(
let
cookie
of
cookies
)
{
resCookies
.
push
(
Object
.
assign
(
{
}
cookie
{
value
:
await
getLongString
(
cookie
.
value
)
}
)
)
;
}
if
(
resCookies
.
length
)
{
await
window
.
gStore
.
dispatch
(
Actions
.
updateRequest
(
action
.
id
{
responseCookies
:
resCookies
}
true
)
)
;
}
}
}
}
_onNetworkEventUpdate
:
function
(
type
{
packet
networkInfo
}
)
{
let
{
actor
}
=
networkInfo
;
switch
(
packet
.
updateType
)
{
case
"
requestHeaders
"
:
this
.
webConsoleClient
.
getRequestHeaders
(
actor
this
.
_onRequestHeaders
)
;
window
.
emit
(
EVENTS
.
UPDATING_REQUEST_HEADERS
actor
)
;
break
;
case
"
requestCookies
"
:
this
.
webConsoleClient
.
getRequestCookies
(
actor
this
.
_onRequestCookies
)
;
window
.
emit
(
EVENTS
.
UPDATING_REQUEST_COOKIES
actor
)
;
break
;
case
"
requestPostData
"
:
this
.
webConsoleClient
.
getRequestPostData
(
actor
this
.
_onRequestPostData
)
;
window
.
emit
(
EVENTS
.
UPDATING_REQUEST_POST_DATA
actor
)
;
break
;
case
"
securityInfo
"
:
this
.
updateRequest
(
actor
{
securityState
:
networkInfo
.
securityInfo
}
)
;
this
.
webConsoleClient
.
getSecurityInfo
(
actor
this
.
_onSecurityInfo
)
;
window
.
emit
(
EVENTS
.
UPDATING_SECURITY_INFO
actor
)
;
break
;
case
"
responseHeaders
"
:
this
.
webConsoleClient
.
getResponseHeaders
(
actor
this
.
_onResponseHeaders
)
;
window
.
emit
(
EVENTS
.
UPDATING_RESPONSE_HEADERS
actor
)
;
break
;
case
"
responseCookies
"
:
this
.
webConsoleClient
.
getResponseCookies
(
actor
this
.
_onResponseCookies
)
;
window
.
emit
(
EVENTS
.
UPDATING_RESPONSE_COOKIES
actor
)
;
break
;
case
"
responseStart
"
:
this
.
updateRequest
(
actor
{
httpVersion
:
networkInfo
.
response
.
httpVersion
remoteAddress
:
networkInfo
.
response
.
remoteAddress
remotePort
:
networkInfo
.
response
.
remotePort
status
:
networkInfo
.
response
.
status
statusText
:
networkInfo
.
response
.
statusText
headersSize
:
networkInfo
.
response
.
headersSize
}
)
;
window
.
emit
(
EVENTS
.
STARTED_RECEIVING_RESPONSE
actor
)
;
break
;
case
"
responseContent
"
:
this
.
updateRequest
(
actor
{
contentSize
:
networkInfo
.
response
.
bodySize
transferredSize
:
networkInfo
.
response
.
transferredSize
mimeType
:
networkInfo
.
response
.
content
.
mimeType
}
)
;
this
.
webConsoleClient
.
getResponseContent
(
actor
this
.
_onResponseContent
)
;
window
.
emit
(
EVENTS
.
UPDATING_RESPONSE_CONTENT
actor
)
;
break
;
case
"
eventTimings
"
:
this
.
updateRequest
(
actor
{
totalTime
:
networkInfo
.
totalTime
}
)
;
this
.
webConsoleClient
.
getEventTimings
(
actor
this
.
_onEventTimings
)
;
window
.
emit
(
EVENTS
.
UPDATING_EVENT_TIMINGS
actor
)
;
break
;
}
}
_onRequestHeaders
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestHeaders
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_REQUEST_HEADERS
response
.
from
)
;
}
)
;
}
_onRequestCookies
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestCookies
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_REQUEST_COOKIES
response
.
from
)
;
}
)
;
}
_onRequestPostData
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
requestPostData
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_REQUEST_POST_DATA
response
.
from
)
;
}
)
;
}
_onSecurityInfo
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
securityInfo
:
response
.
securityInfo
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_SECURITY_INFO
response
.
from
)
;
}
)
;
}
_onResponseHeaders
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
responseHeaders
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_RESPONSE_HEADERS
response
.
from
)
;
}
)
;
}
_onResponseCookies
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
responseCookies
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_RESPONSE_COOKIES
response
.
from
)
;
}
)
;
}
_onResponseContent
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
responseContent
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_RESPONSE_CONTENT
response
.
from
)
;
}
)
;
}
_onEventTimings
:
function
(
response
)
{
this
.
updateRequest
(
response
.
from
{
eventTimings
:
response
}
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
RECEIVED_EVENT_TIMINGS
response
.
from
)
;
}
)
;
}
}
;
exports
.
NetMonitorController
=
NetMonitorController
;
