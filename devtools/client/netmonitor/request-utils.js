"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
function
getKeyWithEvent
(
callback
onlySpaceOrReturn
)
{
return
function
(
event
)
{
let
key
=
event
.
target
.
getAttribute
(
"
data
-
key
"
)
;
let
filterKeyboardEvent
=
!
onlySpaceOrReturn
|
|
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_SPACE
|
|
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
;
if
(
key
&
&
filterKeyboardEvent
)
{
callback
.
call
(
null
key
)
;
}
}
;
}
const
getFormDataSections
=
Task
.
async
(
function
*
(
headers
uploadHeaders
postData
getString
)
{
let
formDataSections
=
[
]
;
let
{
headers
:
requestHeaders
}
=
headers
;
let
{
headers
:
payloadHeaders
}
=
uploadHeaders
;
let
allHeaders
=
[
.
.
.
payloadHeaders
.
.
.
requestHeaders
]
;
let
contentTypeHeader
=
allHeaders
.
find
(
e
=
>
{
return
e
.
name
.
toLowerCase
(
)
=
=
"
content
-
type
"
;
}
)
;
let
contentTypeLongString
=
contentTypeHeader
?
contentTypeHeader
.
value
:
"
"
;
let
contentType
=
yield
getString
(
contentTypeLongString
)
;
if
(
contentType
.
includes
(
"
x
-
www
-
form
-
urlencoded
"
)
)
{
let
postDataLongString
=
postData
.
postData
.
text
;
let
text
=
yield
getString
(
postDataLongString
)
;
for
(
let
section
of
text
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
)
{
if
(
payloadHeaders
.
every
(
header
=
>
!
section
.
startsWith
(
header
.
name
)
)
)
{
formDataSections
.
push
(
section
)
;
}
}
}
return
formDataSections
;
}
)
;
function
formDataURI
(
mimeType
encoding
text
)
{
if
(
!
encoding
)
{
encoding
=
"
base64
"
;
text
=
btoa
(
text
)
;
}
return
"
data
:
"
+
mimeType
+
"
;
"
+
encoding
+
"
"
+
text
;
}
function
writeHeaderText
(
headers
)
{
return
headers
.
map
(
(
{
name
value
}
)
=
>
name
+
"
:
"
+
value
)
.
join
(
"
\
n
"
)
;
}
function
decodeUnicodeUrl
(
string
)
{
try
{
return
decodeURIComponent
(
string
)
;
}
catch
(
err
)
{
}
return
string
;
}
function
getAbbreviatedMimeType
(
mimeType
)
{
if
(
!
mimeType
)
{
return
"
"
;
}
return
(
mimeType
.
split
(
"
;
"
)
[
0
]
.
split
(
"
/
"
)
[
1
]
|
|
"
"
)
.
split
(
"
+
"
)
[
0
]
;
}
function
getUrlBaseName
(
url
)
{
const
pathname
=
(
new
URL
(
url
)
)
.
pathname
;
return
decodeUnicodeUrl
(
pathname
.
replace
(
/
\
S
*
\
/
/
"
"
)
|
|
pathname
|
|
"
/
"
)
;
}
function
getUrlQuery
(
url
)
{
return
decodeUnicodeUrl
(
(
new
URL
(
url
)
)
.
search
.
replace
(
/
^
\
?
/
"
"
)
)
;
}
function
getUrlBaseNameWithQuery
(
url
)
{
return
getUrlBaseName
(
url
)
+
decodeUnicodeUrl
(
(
new
URL
(
url
)
)
.
search
)
;
}
function
getUrlHostName
(
url
)
{
return
decodeUnicodeUrl
(
(
new
URL
(
url
)
)
.
hostname
)
;
}
function
getUrlHost
(
url
)
{
return
decodeUnicodeUrl
(
(
new
URL
(
url
)
)
.
host
)
;
}
function
parseQueryString
(
query
)
{
if
(
!
query
)
{
return
null
;
}
return
query
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
let
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
decodeUnicodeUrl
(
param
[
0
]
)
:
"
"
value
:
param
[
1
]
?
decodeUnicodeUrl
(
param
[
1
]
)
:
"
"
}
;
}
)
;
}
const
LOAD_CAUSE_STRINGS
=
{
[
Ci
.
nsIContentPolicy
.
TYPE_INVALID
]
:
"
invalid
"
[
Ci
.
nsIContentPolicy
.
TYPE_OTHER
]
:
"
other
"
[
Ci
.
nsIContentPolicy
.
TYPE_SCRIPT
]
:
"
script
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
]
:
"
img
"
[
Ci
.
nsIContentPolicy
.
TYPE_STYLESHEET
]
:
"
stylesheet
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT
]
:
"
object
"
[
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
]
:
"
document
"
[
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
]
:
"
subdocument
"
[
Ci
.
nsIContentPolicy
.
TYPE_REFRESH
]
:
"
refresh
"
[
Ci
.
nsIContentPolicy
.
TYPE_XBL
]
:
"
xbl
"
[
Ci
.
nsIContentPolicy
.
TYPE_PING
]
:
"
ping
"
[
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
]
:
"
xhr
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT_SUBREQUEST
]
:
"
objectSubdoc
"
[
Ci
.
nsIContentPolicy
.
TYPE_DTD
]
:
"
dtd
"
[
Ci
.
nsIContentPolicy
.
TYPE_FONT
]
:
"
font
"
[
Ci
.
nsIContentPolicy
.
TYPE_MEDIA
]
:
"
media
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
]
:
"
websocket
"
[
Ci
.
nsIContentPolicy
.
TYPE_CSP_REPORT
]
:
"
csp
"
[
Ci
.
nsIContentPolicy
.
TYPE_XSLT
]
:
"
xslt
"
[
Ci
.
nsIContentPolicy
.
TYPE_BEACON
]
:
"
beacon
"
[
Ci
.
nsIContentPolicy
.
TYPE_FETCH
]
:
"
fetch
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
]
:
"
imageset
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEB_MANIFEST
]
:
"
webManifest
"
}
;
function
loadCauseString
(
causeType
)
{
return
LOAD_CAUSE_STRINGS
[
causeType
]
|
|
"
unknown
"
;
}
module
.
exports
=
{
getKeyWithEvent
getFormDataSections
formDataURI
writeHeaderText
decodeUnicodeUrl
getAbbreviatedMimeType
getUrlBaseName
getUrlQuery
getUrlBaseNameWithQuery
getUrlHostName
getUrlHost
parseQueryString
loadCauseString
}
;
