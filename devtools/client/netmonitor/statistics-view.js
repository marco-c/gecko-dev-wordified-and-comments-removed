"
use
strict
"
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
{
Filters
}
=
require
(
"
.
/
filter
-
predicates
"
)
;
const
{
L10N
}
=
require
(
"
.
/
l10n
"
)
;
const
{
EVENTS
}
=
require
(
"
.
/
events
"
)
;
const
{
DOM
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
button
}
=
DOM
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
Actions
=
require
(
"
.
/
actions
/
index
"
)
;
const
{
Chart
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Chart
"
)
;
const
REQUEST_TIME_DECIMALS
=
2
;
const
CONTENT_SIZE_DECIMALS
=
2
;
const
NETWORK_ANALYSIS_PIE_CHART_DIAMETER
=
200
;
function
StatisticsView
(
)
{
}
StatisticsView
.
prototype
=
{
initialize
(
store
)
{
this
.
store
=
store
;
this
.
Chart
=
Chart
;
this
.
_backButton
=
(
"
#
react
-
statistics
-
back
-
hook
"
)
;
let
backStr
=
L10N
.
getStr
(
"
netmonitor
.
backButton
"
)
;
ReactDOM
.
render
(
button
(
{
id
:
"
network
-
statistics
-
back
-
button
"
className
:
"
devtools
-
toolbarbutton
"
"
data
-
text
-
only
"
:
"
true
"
title
:
backStr
onClick
:
(
)
=
>
{
this
.
store
.
dispatch
(
Actions
.
openStatistics
(
false
)
)
;
}
}
backStr
)
this
.
_backButton
)
;
}
destroy
(
)
{
ReactDOM
.
unmountComponentAtNode
(
this
.
_backButton
)
;
}
displayPlaceholderCharts
(
)
{
this
.
_createChart
(
{
id
:
"
#
primed
-
cache
-
chart
"
title
:
"
charts
.
cacheEnabled
"
}
)
;
this
.
_createChart
(
{
id
:
"
#
empty
-
cache
-
chart
"
title
:
"
charts
.
cacheDisabled
"
}
)
;
window
.
emit
(
EVENTS
.
PLACEHOLDER_CHARTS_DISPLAYED
)
;
}
createPrimedCacheChart
(
items
)
{
this
.
_createChart
(
{
id
:
"
#
primed
-
cache
-
chart
"
title
:
"
charts
.
cacheEnabled
"
data
:
this
.
_sanitizeChartDataSource
(
items
)
strings
:
this
.
_commonChartStrings
totals
:
this
.
_commonChartTotals
sorted
:
true
}
)
;
window
.
emit
(
EVENTS
.
PRIMED_CACHE_CHART_DISPLAYED
)
;
}
createEmptyCacheChart
(
items
)
{
this
.
_createChart
(
{
id
:
"
#
empty
-
cache
-
chart
"
title
:
"
charts
.
cacheDisabled
"
data
:
this
.
_sanitizeChartDataSource
(
items
true
)
strings
:
this
.
_commonChartStrings
totals
:
this
.
_commonChartTotals
sorted
:
true
}
)
;
window
.
emit
(
EVENTS
.
EMPTY_CACHE_CHART_DISPLAYED
)
;
}
_commonChartStrings
:
{
size
:
value
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
value
/
1024
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
sizeKB
"
string
)
;
}
time
:
value
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
value
/
1000
REQUEST_TIME_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
totalS
"
string
)
;
}
}
_commonChartTotals
:
{
size
:
total
=
>
{
let
string
=
L10N
.
numberWithDecimals
(
total
/
1024
CONTENT_SIZE_DECIMALS
)
;
return
L10N
.
getFormatStr
(
"
charts
.
totalSize
"
string
)
;
}
time
:
total
=
>
{
let
seconds
=
total
/
1000
;
let
string
=
L10N
.
numberWithDecimals
(
seconds
REQUEST_TIME_DECIMALS
)
;
return
PluralForm
.
get
(
seconds
L10N
.
getStr
(
"
charts
.
totalSeconds
"
)
)
.
replace
(
"
#
1
"
string
)
;
}
cached
:
total
=
>
{
return
L10N
.
getFormatStr
(
"
charts
.
totalCached
"
total
)
;
}
count
:
total
=
>
{
return
L10N
.
getFormatStr
(
"
charts
.
totalCount
"
total
)
;
}
}
_createChart
(
{
id
title
data
strings
totals
sorted
}
)
{
let
container
=
(
id
)
;
while
(
container
.
hasChildNodes
(
)
)
{
container
.
firstChild
.
remove
(
)
;
}
let
chart
=
this
.
Chart
.
PieTable
(
document
{
diameter
:
NETWORK_ANALYSIS_PIE_CHART_DIAMETER
title
:
L10N
.
getStr
(
title
)
data
strings
totals
sorted
}
)
;
chart
.
on
(
"
click
"
(
_
item
)
=
>
{
this
.
store
.
dispatch
(
Actions
.
enableRequestFilterTypeOnly
(
item
.
label
)
)
;
this
.
store
.
dispatch
(
Actions
.
openStatistics
(
false
)
)
;
}
)
;
container
.
appendChild
(
chart
.
node
)
;
}
_sanitizeChartDataSource
(
items
emptyCache
)
{
let
data
=
[
"
html
"
"
css
"
"
js
"
"
xhr
"
"
fonts
"
"
images
"
"
media
"
"
flash
"
"
ws
"
"
other
"
]
.
map
(
e
=
>
(
{
cached
:
0
count
:
0
label
:
e
size
:
0
time
:
0
}
)
)
;
for
(
let
requestItem
of
items
)
{
let
details
=
requestItem
;
let
type
;
if
(
Filters
.
html
(
details
)
)
{
type
=
0
;
}
else
if
(
Filters
.
css
(
details
)
)
{
type
=
1
;
}
else
if
(
Filters
.
js
(
details
)
)
{
type
=
2
;
}
else
if
(
Filters
.
fonts
(
details
)
)
{
type
=
4
;
}
else
if
(
Filters
.
images
(
details
)
)
{
type
=
5
;
}
else
if
(
Filters
.
media
(
details
)
)
{
type
=
6
;
}
else
if
(
Filters
.
flash
(
details
)
)
{
type
=
7
;
}
else
if
(
Filters
.
ws
(
details
)
)
{
type
=
8
;
}
else
if
(
Filters
.
xhr
(
details
)
)
{
type
=
3
;
}
else
{
type
=
9
;
}
if
(
emptyCache
|
|
!
responseIsFresh
(
details
)
)
{
data
[
type
]
.
time
+
=
details
.
totalTime
|
|
0
;
data
[
type
]
.
size
+
=
details
.
contentSize
|
|
0
;
}
else
{
data
[
type
]
.
cached
+
+
;
}
data
[
type
]
.
count
+
+
;
}
return
data
.
filter
(
e
=
>
e
.
count
>
0
)
;
}
}
;
function
responseIsFresh
(
{
responseHeaders
status
}
)
{
if
(
status
!
=
304
|
|
!
responseHeaders
)
{
return
false
;
}
let
list
=
responseHeaders
.
headers
;
let
cacheControl
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
"
cache
-
control
"
)
;
let
expires
=
list
.
find
(
e
=
>
e
.
name
.
toLowerCase
(
)
=
=
"
expires
"
)
;
if
(
cacheControl
)
{
let
maxAgeMatch
=
cacheControl
.
value
.
match
(
/
s
-
maxage
\
s
*
=
\
s
*
(
\
d
+
)
/
)
|
|
cacheControl
.
value
.
match
(
/
max
-
age
\
s
*
=
\
s
*
(
\
d
+
)
/
)
;
if
(
maxAgeMatch
&
&
maxAgeMatch
.
pop
(
)
>
0
)
{
return
true
;
}
}
if
(
expires
&
&
Date
.
parse
(
expires
.
value
)
)
{
return
true
;
}
return
false
;
}
exports
.
StatisticsView
=
StatisticsView
;
