"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
E10SUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
const
{
tunnelToInnerBrowser
}
=
require
(
"
.
/
tunnel
"
)
;
function
debug
(
msg
)
{
}
function
swapToInnerBrowser
(
{
tab
containerURL
getInnerBrowser
}
)
{
let
browserWindow
=
tab
.
ownerGlobal
;
let
gBrowser
=
browserWindow
.
gBrowser
;
let
innerBrowser
;
let
tunnel
;
const
dispatchDevToolsBrowserSwap
=
(
from
to
)
=
>
{
const
CustomEvent
=
browserWindow
.
CustomEvent
;
const
event
=
new
CustomEvent
(
"
DevTools
:
BrowserSwap
"
{
detail
:
to
bubbles
:
true
}
)
;
from
.
dispatchEvent
(
event
)
;
}
;
const
addTabSilently
=
(
uri
options
)
=
>
{
browserWindow
.
addEventListener
(
"
TabOpen
"
event
=
>
{
event
.
stopImmediatePropagation
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
options
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
options
.
userContextId
}
)
;
return
gBrowser
.
addWebTab
(
uri
options
)
;
}
;
const
swapBrowsersAndCloseOtherSilently
=
(
ourTab
otherTab
)
=
>
{
browserWindow
.
addEventListener
(
"
TabClose
"
event
=
>
{
event
.
stopImmediatePropagation
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
ourTab
otherTab
)
;
}
;
const
swapBrowserDocShells
=
(
ourTab
otherBrowser
)
=
>
{
if
(
!
ourTab
.
linkedBrowser
.
isRemoteBrowser
|
|
!
otherBrowser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
Both
browsers
should
be
remote
before
swapping
.
"
)
;
}
const
contentTabId
=
ourTab
.
linkedBrowser
.
frameLoader
.
tabParent
.
tabId
;
gBrowser
.
_swapBrowserDocShells
(
ourTab
otherBrowser
)
;
if
(
otherBrowser
.
frameLoader
.
tabParent
.
tabId
!
=
contentTabId
)
{
throw
new
Error
(
"
Swapping
tab
content
between
browsers
failed
.
"
)
;
}
}
;
function
loadURIWithNewFrameLoader
(
browser
uri
options
)
{
return
new
Promise
(
resolve
=
>
{
gBrowser
.
addEventListener
(
"
XULFrameLoaderCreated
"
resolve
{
once
:
true
}
)
;
browser
.
loadURI
(
uri
options
)
;
}
)
;
}
return
{
async
start
(
)
{
const
{
requiredRemoteType
mustChangeProcess
newFrameloader
}
=
E10SUtils
.
shouldLoadURIInBrowser
(
tab
.
linkedBrowser
"
http
:
/
/
example
.
com
"
)
;
if
(
newFrameloader
)
{
debug
(
Tab
will
force
a
new
frameloader
on
navigation
load
about
:
blank
first
)
;
await
loadURIWithNewFrameLoader
(
tab
.
linkedBrowser
"
about
:
blank
"
{
flags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
}
)
;
}
if
(
mustChangeProcess
&
&
tab
.
linkedBrowser
.
remoteType
=
=
"
privileged
"
)
{
debug
(
Tab
must
flip
away
from
the
privileged
content
process
+
on
navigation
)
;
gBrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
true
{
remoteType
:
requiredRemoteType
}
)
;
}
tab
.
isResponsiveDesignMode
=
true
;
tab
.
linkedBrowser
.
style
.
visibility
=
"
hidden
"
;
freezeNavigationState
(
tab
)
;
debug
(
"
Add
blank
tool
tab
"
)
;
const
containerTab
=
addTabSilently
(
"
about
:
blank
"
{
skipAnimation
:
true
forceNotRemote
:
true
userContextId
:
tab
.
userContextId
}
)
;
gBrowser
.
hideTab
(
containerTab
)
;
const
containerBrowser
=
containerTab
.
linkedBrowser
;
containerBrowser
.
messageManager
.
sendAsyncMessage
(
"
SessionStore
:
flush
"
{
epoch
:
-
1
}
)
;
debug
(
"
Load
container
URL
"
)
;
containerBrowser
.
loadURI
(
containerURL
{
flags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
const
stateFlags
=
gBrowser
.
_tabListeners
.
get
(
tab
)
.
mStateFlags
;
gBrowser
.
_tabListeners
.
get
(
containerTab
)
.
mStateFlags
=
stateFlags
;
debug
(
"
Set
container
docShell
active
"
)
;
containerBrowser
.
docShellIsActive
=
true
;
debug
(
"
Wait
until
container
tab
loaded
"
)
;
await
tabLoaded
(
containerTab
)
;
debug
(
"
Wait
until
inner
browser
available
"
)
;
innerBrowser
=
await
getInnerBrowser
(
containerBrowser
)
;
addXULBrowserDecorations
(
innerBrowser
)
;
if
(
innerBrowser
.
isRemoteBrowser
!
=
tab
.
linkedBrowser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
inner
browser
'
s
remoteness
must
match
the
"
+
"
original
tab
.
"
)
;
}
dispatchDevToolsBrowserSwap
(
tab
.
linkedBrowser
innerBrowser
)
;
debug
(
"
Swap
content
to
inner
browser
"
)
;
swapBrowserDocShells
(
tab
innerBrowser
)
;
debug
(
"
Flip
original
tab
to
remote
false
"
)
;
gBrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
false
)
;
debug
(
"
Swap
tool
UI
to
original
tab
"
)
;
swapBrowsersAndCloseOtherSilently
(
tab
containerTab
)
;
tunnel
=
tunnelToInnerBrowser
(
tab
.
linkedBrowser
innerBrowser
)
;
debug
(
"
Wait
until
tunnel
start
"
)
;
await
tunnel
.
start
(
)
;
if
(
gBrowser
.
isFindBarInitialized
(
tab
)
)
{
const
findBar
=
gBrowser
.
getCachedFindBar
(
tab
)
;
findBar
.
browser
=
tab
.
linkedBrowser
;
if
(
!
findBar
.
hidden
)
{
findBar
.
onFindCommand
(
)
;
}
}
thawNavigationState
(
tab
)
;
gBrowser
.
setTabTitle
(
tab
)
;
gBrowser
.
updateCurrentBrowser
(
true
)
;
tab
.
linkedBrowser
.
style
.
visibility
=
"
"
;
debug
(
"
Exit
swap
start
"
)
;
}
stop
(
)
{
tab
.
linkedBrowser
.
style
.
visibility
=
"
hidden
"
;
tunnel
.
stop
(
)
;
tunnel
=
null
;
const
contentTab
=
addTabSilently
(
"
about
:
blank
"
{
skipAnimation
:
true
userContextId
:
tab
.
userContextId
}
)
;
gBrowser
.
hideTab
(
contentTab
)
;
const
contentBrowser
=
contentTab
.
linkedBrowser
;
contentBrowser
.
docShellIsActive
=
true
;
dispatchDevToolsBrowserSwap
(
innerBrowser
contentBrowser
)
;
swapBrowserDocShells
(
contentTab
innerBrowser
)
;
innerBrowser
=
null
;
const
stateFlags
=
gBrowser
.
_tabListeners
.
get
(
tab
)
.
mStateFlags
;
gBrowser
.
_tabListeners
.
get
(
contentTab
)
.
mStateFlags
=
stateFlags
;
gBrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
true
{
remoteType
:
contentBrowser
.
remoteType
}
)
;
dispatchDevToolsBrowserSwap
(
contentBrowser
tab
.
linkedBrowser
)
;
swapBrowsersAndCloseOtherSilently
(
tab
contentTab
)
;
if
(
gBrowser
.
isFindBarInitialized
(
tab
)
)
{
const
findBar
=
gBrowser
.
getCachedFindBar
(
tab
)
;
findBar
.
browser
=
tab
.
linkedBrowser
;
if
(
!
findBar
.
hidden
)
{
findBar
.
onFindCommand
(
)
;
}
}
gBrowser
=
null
;
browserWindow
=
null
;
tab
.
linkedBrowser
.
frameLoader
.
activateRemoteFrame
(
)
;
delete
tab
.
isResponsiveDesignMode
;
tab
.
linkedBrowser
.
style
.
visibility
=
"
"
;
}
}
;
}
const
NAVIGATION_PROPERTIES
=
[
"
currentURI
"
"
contentTitle
"
"
securityUI
"
]
;
function
freezeNavigationState
(
tab
)
{
for
(
const
property
of
NAVIGATION_PROPERTIES
)
{
const
value
=
tab
.
linkedBrowser
[
property
]
;
Object
.
defineProperty
(
tab
.
linkedBrowser
property
{
get
(
)
{
return
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
}
function
thawNavigationState
(
tab
)
{
for
(
const
property
of
NAVIGATION_PROPERTIES
)
{
delete
tab
.
linkedBrowser
[
property
]
;
}
}
function
addXULBrowserDecorations
(
browser
)
{
if
(
browser
.
isRemoteBrowser
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
isRemoteBrowser
"
{
get
(
)
{
return
this
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
remoteType
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
remoteType
"
{
get
(
)
{
return
this
.
messageManager
.
remoteType
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
messageManager
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
messageManager
"
{
get
(
)
{
return
this
.
frameLoader
.
messageManager
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
outerWindowID
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
outerWindowID
"
{
get
(
)
{
return
browser
.
_outerWindowID
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
_remoteWebNavigationImpl
=
=
undefined
)
{
browser
.
_remoteWebNavigationImpl
=
{
swapBrowser
(
)
{
}
}
;
}
if
(
browser
.
_remoteWebProgressManager
=
=
undefined
)
{
browser
.
_remoteWebProgressManager
=
{
swapBrowser
(
)
{
}
get
progressListeners
(
)
{
return
[
]
;
}
}
;
}
if
(
browser
.
_remoteWebProgress
=
=
undefined
)
{
browser
.
_remoteWebProgress
=
{
addProgressListener
(
)
{
}
removeProgressListener
(
)
{
}
}
;
}
}
function
tabLoaded
(
tab
)
{
return
new
Promise
(
resolve
=
>
{
function
handle
(
event
)
{
if
(
event
.
originalTarget
!
=
tab
.
linkedBrowser
.
contentDocument
|
|
event
.
target
.
location
.
href
=
=
"
about
:
blank
"
)
{
return
;
}
tab
.
linkedBrowser
.
removeEventListener
(
"
load
"
handle
true
)
;
resolve
(
event
)
;
}
tab
.
linkedBrowser
.
addEventListener
(
"
load
"
handle
true
)
;
}
)
;
}
exports
.
swapToInnerBrowser
=
swapToInnerBrowser
;
