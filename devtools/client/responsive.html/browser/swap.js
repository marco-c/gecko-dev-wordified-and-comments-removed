"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
tunnelToInnerBrowser
}
=
require
(
"
.
/
tunnel
"
)
;
function
swapToInnerBrowser
(
{
tab
containerURL
getInnerBrowser
}
)
{
let
gBrowser
=
tab
.
ownerDocument
.
defaultView
.
gBrowser
;
let
innerBrowser
;
let
tunnel
;
return
{
start
:
Task
.
async
(
function
*
(
)
{
freezeNavigationState
(
tab
)
;
let
containerTab
=
gBrowser
.
addTab
(
containerURL
{
skipAnimation
:
true
}
)
;
gBrowser
.
hideTab
(
containerTab
)
;
let
containerBrowser
=
containerTab
.
linkedBrowser
;
containerBrowser
.
docShellIsActive
=
true
;
yield
tabLoaded
(
containerTab
)
;
innerBrowser
=
yield
getInnerBrowser
(
containerBrowser
)
;
addXULBrowserDecorations
(
innerBrowser
)
;
if
(
innerBrowser
.
isRemoteBrowser
!
=
tab
.
linkedBrowser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
inner
browser
'
s
remoteness
must
match
the
"
+
"
original
tab
.
"
)
;
}
gBrowser
.
_swapBrowserDocShells
(
tab
innerBrowser
)
;
gBrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
false
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
tab
containerTab
)
;
tunnel
=
tunnelToInnerBrowser
(
tab
.
linkedBrowser
innerBrowser
)
;
yield
tunnel
.
start
(
)
;
thawNavigationState
(
tab
)
;
gBrowser
.
setTabTitle
(
tab
)
;
gBrowser
.
updateCurrentBrowser
(
true
)
;
}
)
stop
(
)
{
tunnel
.
stop
(
)
;
tunnel
=
null
;
let
contentTab
=
gBrowser
.
addTab
(
"
about
:
blank
"
{
skipAnimation
:
true
}
)
;
gBrowser
.
hideTab
(
contentTab
)
;
let
contentBrowser
=
contentTab
.
linkedBrowser
;
contentBrowser
.
docShellIsActive
=
true
;
gBrowser
.
_swapBrowserDocShells
(
contentTab
innerBrowser
)
;
innerBrowser
=
null
;
gBrowser
.
updateBrowserRemoteness
(
tab
.
linkedBrowser
true
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
tab
contentTab
)
;
gBrowser
=
null
;
tab
.
linkedBrowser
.
frameLoader
.
activateRemoteFrame
(
)
;
}
}
;
}
const
NAVIGATION_PROPERTIES
=
[
"
currentURI
"
"
contentTitle
"
"
securityUI
"
]
;
function
freezeNavigationState
(
tab
)
{
for
(
let
property
of
NAVIGATION_PROPERTIES
)
{
let
value
=
tab
.
linkedBrowser
[
property
]
;
Object
.
defineProperty
(
tab
.
linkedBrowser
property
{
get
(
)
{
return
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
}
function
thawNavigationState
(
tab
)
{
for
(
let
property
of
NAVIGATION_PROPERTIES
)
{
delete
tab
.
linkedBrowser
[
property
]
;
}
}
function
addXULBrowserDecorations
(
browser
)
{
if
(
browser
.
isRemoteBrowser
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
isRemoteBrowser
"
{
get
(
)
{
return
this
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
messageManager
=
=
undefined
)
{
Object
.
defineProperty
(
browser
"
messageManager
"
{
get
(
)
{
return
this
.
frameLoader
.
messageManager
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
if
(
browser
.
_remoteWebNavigationImpl
=
=
undefined
)
{
browser
.
_remoteWebNavigationImpl
=
{
swapBrowser
(
)
{
}
}
;
}
if
(
browser
.
_remoteWebProgressManager
=
=
undefined
)
{
browser
.
_remoteWebProgressManager
=
{
swapBrowser
(
)
{
}
}
;
}
}
function
tabLoaded
(
tab
)
{
let
deferred
=
promise
.
defer
(
)
;
function
handle
(
event
)
{
if
(
event
.
originalTarget
!
=
tab
.
linkedBrowser
.
contentDocument
|
|
event
.
target
.
location
.
href
=
=
"
about
:
blank
"
)
{
return
;
}
tab
.
linkedBrowser
.
removeEventListener
(
"
load
"
handle
true
)
;
deferred
.
resolve
(
event
)
;
}
tab
.
linkedBrowser
.
addEventListener
(
"
load
"
handle
true
)
;
return
deferred
.
promise
;
}
exports
.
swapToInnerBrowser
=
swapToInnerBrowser
;
