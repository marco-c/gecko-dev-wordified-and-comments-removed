"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
BrowserElementWebNavigation
}
=
require
(
"
.
/
web
-
navigation
"
)
;
function
debug
(
msg
)
{
}
const
SWAPPED_BROWSER_STATE
=
[
"
_securityUI
"
"
_documentURI
"
"
_documentContentType
"
"
_contentTitle
"
"
_characterSet
"
"
_contentPrincipal
"
"
_imageDocument
"
"
_fullZoom
"
"
_textZoom
"
"
_isSyntheticDocument
"
"
_innerWindowID
"
"
_manifestURI
"
]
;
function
tunnelToInnerBrowser
(
outer
inner
)
{
let
browserWindow
=
outer
.
ownerDocument
.
defaultView
;
let
gBrowser
=
browserWindow
.
gBrowser
;
let
mmTunnel
;
return
{
start
:
Task
.
async
(
function
*
(
)
{
if
(
outer
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
outer
browser
must
be
non
-
remote
.
"
)
;
}
if
(
!
inner
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
inner
browser
must
be
remote
.
"
)
;
}
copyPermanentKey
(
outer
inner
)
;
mmTunnel
=
new
MessageManagerTunnel
(
outer
inner
)
;
Object
.
defineProperty
(
outer
"
messageManager
"
{
value
:
mmTunnel
writable
:
false
configurable
:
true
enumerable
:
true
}
)
;
Object
.
defineProperty
(
outer
"
isRemoteBrowser
"
{
get
(
)
{
return
true
;
}
configurable
:
true
enumerable
:
true
}
)
;
outer
.
destroy
(
)
;
outer
.
style
.
MozBinding
=
"
url
(
chrome
:
/
/
browser
/
content
/
tabbrowser
.
xml
"
+
"
#
tabbrowser
-
remote
-
browser
)
"
;
while
(
!
outer
.
_remoteWebNavigation
)
{
Services
.
tm
.
currentThread
.
processNextEvent
(
true
)
;
}
let
webNavigation
=
new
BrowserElementWebNavigation
(
inner
)
;
webNavigation
.
copyStateFrom
(
inner
.
_remoteWebNavigationImpl
)
;
outer
.
_remoteWebNavigation
=
webNavigation
;
outer
.
_remoteWebNavigationImpl
=
webNavigation
;
let
tab
=
gBrowser
.
getTabForBrowser
(
outer
)
;
let
filteredProgressListener
=
gBrowser
.
_tabFilters
.
get
(
tab
)
;
outer
.
webProgress
.
addProgressListener
(
filteredProgressListener
)
;
for
(
let
property
of
SWAPPED_BROWSER_STATE
)
{
outer
[
property
]
=
inner
[
property
]
;
}
Object
.
defineProperty
(
outer
"
hasContentOpener
"
{
get
(
)
{
return
inner
.
frameLoader
.
tabParent
.
hasContentOpener
;
}
configurable
:
true
enumerable
:
true
}
)
;
Object
.
defineProperty
(
outer
"
docShellIsActive
"
{
get
(
)
{
return
inner
.
frameLoader
.
tabParent
.
docShellIsActive
;
}
set
(
value
)
{
inner
.
frameLoader
.
tabParent
.
docShellIsActive
=
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
outer
.
setDocShellIsActiveAndForeground
=
value
=
>
{
inner
.
frameLoader
.
tabParent
.
setDocShellIsActiveAndForeground
(
value
)
;
}
;
}
)
stop
(
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
outer
)
;
let
filteredProgressListener
=
gBrowser
.
_tabFilters
.
get
(
tab
)
;
browserWindow
=
null
;
gBrowser
=
null
;
for
(
let
property
of
SWAPPED_BROWSER_STATE
)
{
inner
[
property
]
=
outer
[
property
]
;
}
outer
.
webProgress
.
removeProgressListener
(
filteredProgressListener
)
;
outer
.
destroy
(
)
;
outer
.
style
.
MozBinding
=
"
"
;
delete
outer
.
messageManager
;
delete
outer
.
isRemoteBrowser
;
delete
outer
.
hasContentOpener
;
delete
outer
.
docShellIsActive
;
delete
outer
.
setDocShellIsActiveAndForeground
;
mmTunnel
.
destroy
(
)
;
mmTunnel
=
null
;
outer
.
permanentKey
=
{
id
:
"
zombie
"
}
;
}
}
;
}
exports
.
tunnelToInnerBrowser
=
tunnelToInnerBrowser
;
function
copyPermanentKey
(
outer
inner
)
{
let
outerMM
=
outer
.
frameLoader
.
messageManager
;
let
onHistoryEntry
=
message
=
>
{
let
history
=
message
.
data
.
data
.
history
;
if
(
!
history
|
|
!
history
.
entries
)
{
return
;
}
outerMM
.
removeMessageListener
(
"
SessionStore
:
update
"
onHistoryEntry
)
;
debug
(
"
Got
session
update
for
outer
browser
"
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
debug
(
"
Copy
inner
permanentKey
to
outer
browser
"
)
;
outer
.
permanentKey
=
inner
.
permanentKey
;
}
)
;
}
;
outerMM
.
addMessageListener
(
"
SessionStore
:
update
"
onHistoryEntry
)
;
}
function
MessageManagerTunnel
(
outer
inner
)
{
if
(
outer
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
outer
browser
must
be
non
-
remote
.
"
)
;
}
this
.
outer
=
outer
;
this
.
inner
=
inner
;
this
.
init
(
)
;
}
MessageManagerTunnel
.
prototype
=
{
PASS_THROUGH_METHODS
:
[
"
addMessageListener
"
"
loadFrameScript
"
"
killChild
"
"
assertPermission
"
"
assertContainApp
"
"
assertAppHasPermission
"
"
assertAppHasStatus
"
"
removeDelayedFrameScript
"
"
getDelayedFrameScripts
"
"
loadProcessScript
"
"
removeDelayedProcessScript
"
"
getDelayedProcessScripts
"
"
removeMessageListener
"
"
addWeakMessageListener
"
"
removeWeakMessageListener
"
]
OUTER_TO_INNER_MESSAGES
:
[
"
Browser
:
PurgeSessionHistory
"
"
InPermitUnload
"
"
PermitUnload
"
"
Browser
:
Reload
"
"
Forms
:
DismissedDropDown
"
"
Forms
:
MouseOut
"
"
Forms
:
MouseOver
"
"
Forms
:
SelectDropDownItem
"
"
SessionStore
:
flush
"
]
INNER_TO_OUTER_MESSAGES
:
[
"
Content
:
LoadURIResult
"
"
Content
:
LocationChange
"
"
Content
:
ProgressChange
"
"
Content
:
SecurityChange
"
"
Content
:
StateChange
"
"
Content
:
StatusChange
"
"
DOMTitleChanged
"
"
ImageDocumentLoaded
"
"
Forms
:
ShowDropDown
"
"
Forms
:
HideDropDown
"
"
InPermitUnload
"
"
PermitUnload
"
"
Forms
:
UpdateDropDown
"
"
PageVisibility
:
Hide
"
"
PageVisibility
:
Show
"
"
SessionStore
:
update
"
"
browser
-
test
-
utils
:
loadEvent
"
]
get
outerParentMM
(
)
{
return
this
.
outer
.
frameLoader
.
messageManager
;
}
get
outerChildMM
(
)
{
let
docShell
=
this
.
outer
.
frameLoader
.
docShell
;
return
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
get
innerParentMM
(
)
{
return
this
.
inner
.
frameLoader
.
messageManager
;
}
sendAsyncMessage
(
name
.
.
.
args
)
{
debug
(
Calling
sendAsyncMessage
for
{
name
}
)
;
if
(
!
this
.
OUTER_TO_INNER_MESSAGES
.
includes
(
name
)
)
{
debug
(
Should
{
name
}
go
to
inner
?
)
;
this
.
outerParentMM
.
sendAsyncMessage
(
name
.
.
.
args
)
;
return
;
}
debug
(
{
name
}
outer
-
>
inner
)
;
this
.
innerParentMM
.
sendAsyncMessage
(
name
.
.
.
args
)
;
}
init
(
)
{
for
(
let
method
of
this
.
PASS_THROUGH_METHODS
)
{
let
_method
=
method
;
this
[
_method
]
=
(
.
.
.
args
)
=
>
{
return
this
.
outerParentMM
[
_method
]
(
.
.
.
args
)
;
}
;
}
for
(
let
message
of
this
.
INNER_TO_OUTER_MESSAGES
)
{
this
.
innerParentMM
.
addMessageListener
(
message
this
)
;
}
}
destroy
(
)
{
for
(
let
message
of
this
.
INNER_TO_OUTER_MESSAGES
)
{
this
.
innerParentMM
.
removeMessageListener
(
message
this
)
;
}
}
receiveMessage
(
{
name
data
objects
principal
}
)
{
if
(
!
this
.
INNER_TO_OUTER_MESSAGES
.
includes
(
name
)
)
{
debug
(
Received
unexpected
message
{
name
}
)
;
return
;
}
debug
(
{
name
}
inner
-
>
outer
)
;
this
.
outerChildMM
.
sendAsyncMessage
(
name
data
objects
principal
)
;
}
}
;
