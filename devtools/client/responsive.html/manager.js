"
use
strict
"
;
const
{
Ci
Cr
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
TouchEventSimulator
}
=
require
(
"
devtools
/
shared
/
touch
/
simulator
"
)
;
const
{
getOwnerWindow
}
=
require
(
"
sdk
/
tabs
/
utils
"
)
;
const
{
on
off
}
=
require
(
"
sdk
/
event
/
core
"
)
;
const
{
startup
}
=
require
(
"
sdk
/
window
/
helpers
"
)
;
const
events
=
require
(
"
.
/
events
"
)
;
const
TOOL_URL
=
"
chrome
:
/
/
devtools
/
content
/
responsive
.
html
/
index
.
xhtml
"
;
const
ResponsiveUIManager
=
exports
.
ResponsiveUIManager
=
{
activeTabs
:
new
Map
(
)
toggle
(
window
tab
)
{
let
action
=
this
.
isActiveForTab
(
tab
)
?
"
close
"
:
"
open
"
;
return
this
[
action
+
"
IfNeeded
"
]
(
window
tab
)
;
}
openIfNeeded
:
Task
.
async
(
function
*
(
window
tab
)
{
if
(
!
this
.
isActiveForTab
(
tab
)
)
{
if
(
!
this
.
activeTabs
.
size
)
{
on
(
events
.
activate
"
data
"
onActivate
)
;
on
(
events
.
close
"
data
"
onClose
)
;
}
let
ui
=
new
ResponsiveUI
(
window
tab
)
;
this
.
activeTabs
.
set
(
tab
ui
)
;
yield
setMenuCheckFor
(
tab
window
)
;
yield
ui
.
inited
;
this
.
emit
(
"
on
"
{
tab
}
)
;
}
return
this
.
getResponsiveUIForTab
(
tab
)
;
}
)
closeIfNeeded
:
Task
.
async
(
function
*
(
window
tab
)
{
if
(
this
.
isActiveForTab
(
tab
)
)
{
let
ui
=
this
.
activeTabs
.
get
(
tab
)
;
this
.
activeTabs
.
delete
(
tab
)
;
if
(
!
this
.
activeTabs
.
size
)
{
off
(
events
.
activate
"
data
"
onActivate
)
;
off
(
events
.
close
"
data
"
onClose
)
;
}
yield
ui
.
destroy
(
)
;
this
.
emit
(
"
off
"
{
tab
}
)
;
yield
setMenuCheckFor
(
tab
window
)
;
}
return
promise
.
resolve
(
)
;
}
)
isActiveForTab
(
tab
)
{
return
this
.
activeTabs
.
has
(
tab
)
;
}
getResponsiveUIForTab
(
tab
)
{
return
this
.
activeTabs
.
get
(
tab
)
;
}
handleGcliCommand
:
function
(
window
tab
command
args
)
{
let
completed
;
switch
(
command
)
{
case
"
resize
to
"
:
completed
=
this
.
openIfNeeded
(
window
tab
)
;
this
.
activeTabs
.
get
(
tab
)
.
setViewportSize
(
args
.
width
args
.
height
)
;
break
;
case
"
resize
on
"
:
completed
=
this
.
openIfNeeded
(
window
tab
)
;
break
;
case
"
resize
off
"
:
completed
=
this
.
closeIfNeeded
(
window
tab
)
;
break
;
case
"
resize
toggle
"
:
completed
=
this
.
toggle
(
window
tab
)
;
break
;
default
:
}
completed
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
}
;
EventEmitter
.
decorate
(
ResponsiveUIManager
)
;
function
ResponsiveUI
(
window
tab
)
{
this
.
browserWindow
=
window
;
this
.
tab
=
tab
;
this
.
inited
=
this
.
init
(
)
;
}
ResponsiveUI
.
prototype
=
{
browserWindow
:
null
tab
:
null
inited
:
null
toolWindow
:
null
touchEventSimulator
:
null
init
:
Task
.
async
(
function
*
(
)
{
let
tabBrowser
=
this
.
tab
.
linkedBrowser
;
let
contentURI
=
tabBrowser
.
documentURI
.
spec
;
tabBrowser
.
loadURI
(
TOOL_URL
)
;
yield
tabLoaded
(
this
.
tab
)
;
let
toolWindow
=
this
.
toolWindow
=
tabBrowser
.
contentWindow
;
toolWindow
.
addEventListener
(
"
message
"
this
)
;
yield
waitForMessage
(
toolWindow
"
init
"
)
;
toolWindow
.
addInitialViewport
(
contentURI
)
;
yield
waitForMessage
(
toolWindow
"
browser
-
mounted
"
)
;
let
browser
=
toolWindow
.
document
.
querySelector
(
"
iframe
.
browser
"
)
;
this
.
touchEventSimulator
=
new
TouchEventSimulator
(
browser
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
let
tabBrowser
=
this
.
tab
.
linkedBrowser
;
let
browserWindow
=
this
.
browserWindow
;
this
.
browserWindow
=
null
;
this
.
tab
=
null
;
this
.
inited
=
null
;
this
.
toolWindow
=
null
;
yield
this
.
touchEventSimulator
.
stop
(
)
;
this
.
touchEventSimulator
=
null
;
let
loaded
=
waitForDocLoadComplete
(
browserWindow
.
gBrowser
)
;
tabBrowser
.
goBack
(
)
;
yield
loaded
;
}
)
handleEvent
(
event
)
{
let
{
tab
window
}
=
this
;
let
toolWindow
=
tab
.
linkedBrowser
.
contentWindow
;
if
(
event
.
origin
!
=
=
"
chrome
:
/
/
devtools
"
)
{
return
;
}
switch
(
event
.
data
.
type
)
{
case
"
content
-
resize
"
:
let
{
width
height
}
=
event
.
data
;
this
.
emit
(
"
content
-
resize
"
{
width
height
}
)
;
break
;
case
"
exit
"
:
toolWindow
.
removeEventListener
(
event
.
type
this
)
;
ResponsiveUIManager
.
closeIfNeeded
(
window
tab
)
;
break
;
case
"
update
-
touch
-
simulation
"
:
let
{
enabled
}
=
event
.
data
;
this
.
updateTouchSimulation
(
enabled
)
;
break
;
}
}
updateTouchSimulation
:
Task
.
async
(
function
*
(
enabled
)
{
if
(
enabled
)
{
this
.
touchEventSimulator
.
start
(
)
;
}
else
{
this
.
touchEventSimulator
.
stop
(
)
;
}
}
)
getViewportSize
(
)
{
return
this
.
toolWindow
.
getViewportSize
(
)
;
}
setViewportSize
:
Task
.
async
(
function
*
(
width
height
)
{
yield
this
.
inited
;
this
.
toolWindow
.
setViewportSize
(
width
height
)
;
}
)
getViewportMessageManager
(
)
{
return
this
.
toolWindow
.
getViewportMessageManager
(
)
;
}
}
;
EventEmitter
.
decorate
(
ResponsiveUI
.
prototype
)
;
function
waitForMessage
(
win
type
)
{
let
deferred
=
promise
.
defer
(
)
;
let
onMessage
=
event
=
>
{
if
(
event
.
data
.
type
!
=
=
type
)
{
return
;
}
win
.
removeEventListener
(
"
message
"
onMessage
)
;
deferred
.
resolve
(
)
;
}
;
win
.
addEventListener
(
"
message
"
onMessage
)
;
return
deferred
.
promise
;
}
function
tabLoaded
(
tab
)
{
let
deferred
=
promise
.
defer
(
)
;
function
handle
(
event
)
{
if
(
event
.
originalTarget
!
=
tab
.
linkedBrowser
.
contentDocument
|
|
event
.
target
.
location
.
href
=
=
"
about
:
blank
"
)
{
return
;
}
tab
.
linkedBrowser
.
removeEventListener
(
"
load
"
handle
true
)
;
deferred
.
resolve
(
event
)
;
}
tab
.
linkedBrowser
.
addEventListener
(
"
load
"
handle
true
)
;
return
deferred
.
promise
;
}
function
waitForDocLoadComplete
(
gBrowser
)
{
let
deferred
=
promise
.
defer
(
)
;
let
progressListener
=
{
onStateChange
:
function
(
webProgress
req
flags
status
)
{
let
docStop
=
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
|
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
if
(
(
flags
&
docStop
)
=
=
docStop
&
&
status
!
=
Cr
.
NS_BINDING_ABORTED
)
{
gBrowser
.
removeProgressListener
(
progressListener
)
;
deferred
.
resolve
(
)
;
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
gBrowser
.
addProgressListener
(
progressListener
)
;
return
deferred
.
promise
;
}
const
onActivate
=
(
tab
)
=
>
setMenuCheckFor
(
tab
)
;
const
onClose
=
(
{
window
tabs
}
)
=
>
{
for
(
let
tab
of
tabs
)
{
ResponsiveUIManager
.
closeIfNeeded
(
window
tab
)
;
}
}
;
const
setMenuCheckFor
=
Task
.
async
(
function
*
(
tab
window
=
getOwnerWindow
(
tab
)
)
{
yield
startup
(
window
)
;
let
menu
=
window
.
document
.
getElementById
(
"
menu_responsiveUI
"
)
;
menu
.
setAttribute
(
"
checked
"
ResponsiveUIManager
.
isActiveForTab
(
tab
)
)
;
}
)
;
