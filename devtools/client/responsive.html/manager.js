"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
debugger
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
throttlingProfiles
"
"
devtools
/
client
/
shared
/
components
/
throttling
/
profiles
"
)
;
loader
.
lazyRequireGetter
(
this
"
SettingOnboardingTooltip
"
"
devtools
/
client
/
responsive
.
html
/
setting
-
onboarding
-
tooltip
"
)
;
loader
.
lazyRequireGetter
(
this
"
swapToInnerBrowser
"
"
devtools
/
client
/
responsive
.
html
/
browser
/
swap
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
startup
"
"
devtools
/
client
/
responsive
.
html
/
utils
/
window
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
message
"
"
devtools
/
client
/
responsive
.
html
/
utils
/
message
"
)
;
loader
.
lazyRequireGetter
(
this
"
showNotification
"
"
devtools
/
client
/
responsive
.
html
/
utils
/
notification
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
l10n
"
"
devtools
/
client
/
responsive
.
html
/
utils
/
l10n
"
)
;
loader
.
lazyRequireGetter
(
this
"
EmulationFront
"
"
devtools
/
shared
/
fronts
/
emulation
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PriorityLevels
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Telemetry
"
"
devtools
/
client
/
shared
/
telemetry
"
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
const
TOOL_URL
=
"
chrome
:
/
/
devtools
/
content
/
responsive
.
html
/
index
.
xhtml
"
;
const
RELOAD_CONDITION_PREF_PREFIX
=
"
devtools
.
responsive
.
reloadConditions
.
"
;
const
RELOAD_NOTIFICATION_PREF
=
"
devtools
.
responsive
.
reloadNotification
.
enabled
"
;
const
SHOW_SETTING_TOOLTIP_PREF
=
"
devtools
.
responsive
.
show
-
setting
-
tooltip
"
;
function
debug
(
msg
)
{
}
const
ResponsiveUIManager
=
exports
.
ResponsiveUIManager
=
{
_telemetry
:
new
Telemetry
(
)
activeTabs
:
new
Map
(
)
toggle
(
window
tab
options
=
{
}
)
{
const
action
=
this
.
isActiveForTab
(
tab
)
?
"
close
"
:
"
open
"
;
const
completed
=
this
[
action
+
"
IfNeeded
"
]
(
window
tab
options
)
;
completed
.
catch
(
console
.
error
)
;
return
completed
;
}
async
openIfNeeded
(
window
tab
options
=
{
}
)
{
if
(
!
tab
.
linkedBrowser
.
isRemoteBrowser
)
{
await
this
.
showRemoteOnlyNotification
(
window
tab
options
)
;
return
promise
.
reject
(
new
Error
(
"
RDM
only
available
for
remote
tabs
.
"
)
)
;
}
if
(
!
this
.
isActiveForTab
(
tab
)
)
{
this
.
initMenuCheckListenerFor
(
window
)
;
const
ui
=
new
ResponsiveUI
(
window
tab
)
;
this
.
activeTabs
.
set
(
tab
ui
)
;
this
.
recordTelemetryOpen
(
window
tab
options
)
;
await
this
.
setMenuCheckFor
(
tab
window
)
;
await
ui
.
inited
;
this
.
emit
(
"
on
"
{
tab
}
)
;
}
return
this
.
getResponsiveUIForTab
(
tab
)
;
}
async
recordTelemetryOpen
(
window
tab
options
)
{
const
isKnownTab
=
TargetFactory
.
isKnownTab
(
tab
)
;
let
toolbox
;
if
(
isKnownTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
}
const
hostType
=
toolbox
?
toolbox
.
hostType
:
"
none
"
;
const
hasToolbox
=
!
!
toolbox
;
const
tel
=
this
.
_telemetry
;
if
(
hasToolbox
)
{
tel
.
scalarAdd
(
"
devtools
.
responsive
.
toolbox_opened_first
"
1
)
;
}
tel
.
recordEvent
(
"
activate
"
"
responsive_design
"
null
{
"
host
"
:
hostType
"
width
"
:
Math
.
ceil
(
window
.
outerWidth
/
50
)
*
50
"
session_id
"
:
toolbox
?
toolbox
.
sessionId
:
-
1
}
)
;
let
{
trigger
}
=
options
;
if
(
!
trigger
)
{
trigger
=
"
unknown
"
;
}
tel
.
keyedScalarAdd
(
"
devtools
.
responsive
.
open_trigger
"
trigger
1
)
;
}
async
closeIfNeeded
(
window
tab
options
=
{
}
)
{
if
(
this
.
isActiveForTab
(
tab
)
)
{
const
ui
=
this
.
activeTabs
.
get
(
tab
)
;
const
destroyed
=
await
ui
.
destroy
(
options
)
;
if
(
!
destroyed
)
{
return
;
}
this
.
activeTabs
.
delete
(
tab
)
;
if
(
!
this
.
isActiveForWindow
(
window
)
)
{
this
.
removeMenuCheckListenerFor
(
window
)
;
}
this
.
emit
(
"
off
"
{
tab
}
)
;
await
this
.
setMenuCheckFor
(
tab
window
)
;
this
.
recordTelemetryClose
(
window
tab
)
;
}
}
async
recordTelemetryClose
(
window
tab
)
{
const
isKnownTab
=
TargetFactory
.
isKnownTab
(
tab
)
;
let
toolbox
;
if
(
isKnownTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
}
const
hostType
=
toolbox
?
toolbox
.
hostType
:
"
none
"
;
const
t
=
this
.
_telemetry
;
t
.
recordEvent
(
"
deactivate
"
"
responsive_design
"
null
{
"
host
"
:
hostType
"
width
"
:
Math
.
ceil
(
window
.
outerWidth
/
50
)
*
50
"
session_id
"
:
toolbox
?
toolbox
.
sessionId
:
-
1
}
)
;
}
isActiveForTab
(
tab
)
{
return
this
.
activeTabs
.
has
(
tab
)
;
}
isActiveForWindow
(
window
)
{
return
[
.
.
.
this
.
activeTabs
.
keys
(
)
]
.
some
(
t
=
>
t
.
ownerGlobal
=
=
=
window
)
;
}
getResponsiveUIForTab
(
tab
)
{
return
this
.
activeTabs
.
get
(
tab
)
;
}
handleMenuCheck
(
{
target
}
)
{
ResponsiveUIManager
.
setMenuCheckFor
(
target
)
;
}
initMenuCheckListenerFor
(
window
)
{
const
{
tabContainer
}
=
window
.
gBrowser
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
.
handleMenuCheck
)
;
}
removeMenuCheckListenerFor
(
window
)
{
if
(
window
&
&
window
.
gBrowser
&
&
window
.
gBrowser
.
tabContainer
)
{
const
{
tabContainer
}
=
window
.
gBrowser
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
.
handleMenuCheck
)
;
}
}
async
setMenuCheckFor
(
tab
window
=
tab
.
ownerGlobal
)
{
await
startup
(
window
)
;
const
menu
=
window
.
document
.
getElementById
(
"
menu_responsiveUI
"
)
;
if
(
menu
)
{
menu
.
setAttribute
(
"
checked
"
this
.
isActiveForTab
(
tab
)
)
;
}
}
showRemoteOnlyNotification
(
window
tab
{
trigger
}
=
{
}
)
{
return
showNotification
(
window
tab
{
toolboxButton
:
trigger
=
=
"
toolbox
"
msg
:
l10n
.
getStr
(
"
responsive
.
remoteOnly
"
)
priority
:
PriorityLevels
.
PRIORITY_CRITICAL_MEDIUM
}
)
;
}
}
;
EventEmitter
.
decorate
(
ResponsiveUIManager
)
;
function
ResponsiveUI
(
window
tab
)
{
this
.
browserWindow
=
window
;
this
.
tab
=
tab
;
this
.
inited
=
this
.
init
(
)
;
}
ResponsiveUI
.
prototype
=
{
browserWindow
:
null
tab
:
null
inited
:
null
destroying
:
false
destroyed
:
false
toolWindow
:
null
async
init
(
)
{
debug
(
"
Init
start
"
)
;
const
ui
=
this
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
browserWindow
.
addEventListener
(
"
unload
"
this
)
;
debug
(
"
Create
browser
swapper
"
)
;
this
.
swap
=
swapToInnerBrowser
(
{
tab
:
this
.
tab
containerURL
:
TOOL_URL
async
getInnerBrowser
(
containerBrowser
)
{
const
toolWindow
=
ui
.
toolWindow
=
containerBrowser
.
contentWindow
;
toolWindow
.
addEventListener
(
"
message
"
ui
)
;
debug
(
"
Wait
until
init
from
inner
"
)
;
await
message
.
request
(
toolWindow
"
init
"
)
;
toolWindow
.
addInitialViewport
(
{
uri
:
"
about
:
blank
"
userContextId
:
ui
.
tab
.
userContextId
}
)
;
debug
(
"
Wait
until
browser
mounted
"
)
;
await
message
.
wait
(
toolWindow
"
browser
-
mounted
"
)
;
return
ui
.
getViewportBrowser
(
)
;
}
}
)
;
debug
(
"
Wait
until
swap
start
"
)
;
await
this
.
swap
.
start
(
)
;
this
.
tab
.
addEventListener
(
"
BeforeTabRemotenessChange
"
this
)
;
debug
(
"
Wait
until
start
frame
script
"
)
;
await
message
.
request
(
this
.
toolWindow
"
start
-
frame
-
script
"
)
;
debug
(
"
Wait
until
RDP
server
connect
"
)
;
await
this
.
connectToServer
(
)
;
await
this
.
restoreState
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
SHOW_SETTING_TOOLTIP_PREF
)
)
{
this
.
settingOnboardingTooltip
=
new
SettingOnboardingTooltip
(
ui
.
toolWindow
.
document
)
;
}
message
.
post
(
this
.
toolWindow
"
post
-
init
"
)
;
debug
(
"
Init
done
"
)
;
}
async
destroy
(
options
)
{
if
(
this
.
destroying
)
{
return
false
;
}
this
.
destroying
=
true
;
const
isTabDestroyed
=
!
this
.
tab
.
linkedBrowser
;
const
isWindowClosing
=
(
options
&
&
options
.
reason
=
=
=
"
unload
"
)
|
|
isTabDestroyed
;
const
isTabContentDestroying
=
isWindowClosing
|
|
(
options
&
&
(
options
.
reason
=
=
=
"
TabClose
"
|
|
options
.
reason
=
=
=
"
BeforeTabRemotenessChange
"
)
)
;
if
(
!
isTabContentDestroying
)
{
await
this
.
inited
;
}
this
.
tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
removeEventListener
(
"
BeforeTabRemotenessChange
"
this
)
;
this
.
browserWindow
.
removeEventListener
(
"
unload
"
this
)
;
this
.
toolWindow
.
removeEventListener
(
"
message
"
this
)
;
if
(
!
isTabContentDestroying
)
{
await
message
.
request
(
this
.
toolWindow
"
stop
-
frame
-
script
"
)
;
}
if
(
!
isTabContentDestroying
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
)
;
await
this
.
updateNetworkThrottling
(
)
;
reloadNeeded
|
=
await
this
.
updateUserAgent
(
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
await
this
.
updateTouchSimulation
(
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
}
if
(
this
.
settingOnboardingTooltip
)
{
this
.
settingOnboardingTooltip
.
destroy
(
)
;
this
.
settingOnboardingTooltip
=
null
;
}
const
swap
=
this
.
swap
;
this
.
browserWindow
=
null
;
this
.
tab
=
null
;
this
.
inited
=
null
;
this
.
toolWindow
=
null
;
this
.
swap
=
null
;
const
clientClosed
=
this
.
client
.
close
(
)
;
if
(
!
isTabContentDestroying
)
{
await
clientClosed
;
}
this
.
client
=
this
.
emulationFront
=
null
;
if
(
!
isWindowClosing
)
{
swap
.
stop
(
)
;
}
this
.
destroyed
=
true
;
return
true
;
}
async
connectToServer
(
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
this
.
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
await
this
.
client
.
connect
(
)
;
const
targetFront
=
await
this
.
client
.
mainRoot
.
getTab
(
)
;
this
.
emulationFront
=
new
EmulationFront
(
this
.
client
)
;
this
.
emulationFront
.
actorID
=
targetFront
.
targetForm
[
this
.
emulationFront
.
formAttributeName
]
;
this
.
emulationFront
.
manage
(
this
.
emulationFront
)
;
}
showReloadNotification
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
)
{
showNotification
(
this
.
browserWindow
this
.
tab
{
msg
:
l10n
.
getFormatStr
(
"
responsive
.
reloadNotification
.
description2
"
)
}
)
;
Services
.
prefs
.
setBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
;
}
}
reloadOnChange
(
id
)
{
this
.
showReloadNotification
(
)
;
const
pref
=
RELOAD_CONDITION_PREF_PREFIX
+
id
;
return
Services
.
prefs
.
getBoolPref
(
pref
false
)
;
}
handleEvent
(
event
)
{
const
{
browserWindow
tab
}
=
this
;
switch
(
event
.
type
)
{
case
"
message
"
:
this
.
handleMessage
(
event
)
;
break
;
case
"
BeforeTabRemotenessChange
"
:
case
"
TabClose
"
:
case
"
unload
"
:
ResponsiveUIManager
.
closeIfNeeded
(
browserWindow
tab
{
reason
:
event
.
type
}
)
;
break
;
}
}
handleMessage
(
event
)
{
if
(
event
.
origin
!
=
=
"
chrome
:
/
/
devtools
"
)
{
return
;
}
switch
(
event
.
data
.
type
)
{
case
"
change
-
device
"
:
this
.
onChangeDevice
(
event
)
;
break
;
case
"
change
-
network
-
throttling
"
:
this
.
onChangeNetworkThrottling
(
event
)
;
break
;
case
"
change
-
pixel
-
ratio
"
:
this
.
onChangePixelRatio
(
event
)
;
break
;
case
"
change
-
touch
-
simulation
"
:
this
.
onChangeTouchSimulation
(
event
)
;
break
;
case
"
change
-
user
-
agent
"
:
this
.
onChangeUserAgent
(
event
)
;
break
;
case
"
content
-
resize
"
:
this
.
onContentResize
(
event
)
;
break
;
case
"
exit
"
:
this
.
onExit
(
)
;
break
;
case
"
remove
-
device
-
association
"
:
this
.
onRemoveDeviceAssociation
(
)
;
break
;
case
"
viewport
-
resize
"
:
this
.
onViewportResize
(
event
)
;
break
;
}
}
async
onChangeDevice
(
event
)
{
const
{
userAgent
pixelRatio
touch
}
=
event
.
data
.
device
;
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
pixelRatio
)
;
reloadNeeded
|
=
await
this
.
updateUserAgent
(
userAgent
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
await
this
.
updateTouchSimulation
(
touch
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
device
-
changed
"
)
;
}
async
onChangeNetworkThrottling
(
event
)
{
const
{
enabled
profile
}
=
event
.
data
;
await
this
.
updateNetworkThrottling
(
enabled
profile
)
;
this
.
emit
(
"
network
-
throttling
-
changed
"
)
;
}
onChangePixelRatio
(
event
)
{
const
{
pixelRatio
}
=
event
.
data
;
this
.
updateDPPX
(
pixelRatio
)
;
}
async
onChangeTouchSimulation
(
event
)
{
const
{
enabled
}
=
event
.
data
;
const
reloadNeeded
=
await
this
.
updateTouchSimulation
(
enabled
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
touch
-
simulation
-
changed
"
)
;
}
async
onChangeUserAgent
(
event
)
{
const
{
userAgent
}
=
event
.
data
;
const
reloadNeeded
=
await
this
.
updateUserAgent
(
userAgent
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
user
-
agent
-
changed
"
)
;
}
onContentResize
(
event
)
{
const
{
width
height
}
=
event
.
data
;
this
.
emit
(
"
content
-
resize
"
{
width
height
}
)
;
}
onExit
(
)
{
const
{
browserWindow
tab
}
=
this
;
ResponsiveUIManager
.
closeIfNeeded
(
browserWindow
tab
)
;
}
async
onRemoveDeviceAssociation
(
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
)
;
reloadNeeded
|
=
await
this
.
updateUserAgent
(
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
await
this
.
updateTouchSimulation
(
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
device
-
association
-
removed
"
)
;
}
onViewportResize
(
event
)
{
const
{
width
height
}
=
event
.
data
;
this
.
emit
(
"
viewport
-
resize
"
{
width
height
}
)
;
}
async
restoreState
(
)
{
const
deviceState
=
await
asyncStorage
.
getItem
(
"
devtools
.
responsive
.
deviceState
"
)
;
if
(
deviceState
)
{
return
;
}
const
pixelRatio
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
pixelRatio
"
0
)
;
const
touchSimulationEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
touchSimulation
.
enabled
"
false
)
;
const
userAgent
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
responsive
.
userAgent
"
"
"
)
;
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
pixelRatio
)
;
if
(
touchSimulationEnabled
)
{
reloadNeeded
|
=
await
this
.
updateTouchSimulation
(
touchSimulationEnabled
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
}
if
(
userAgent
)
{
reloadNeeded
|
=
await
this
.
updateUserAgent
(
userAgent
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
}
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
}
async
updateDPPX
(
dppx
)
{
if
(
!
dppx
)
{
await
this
.
emulationFront
.
clearDPPXOverride
(
)
;
return
false
;
}
await
this
.
emulationFront
.
setDPPXOverride
(
dppx
)
;
return
false
;
}
async
updateNetworkThrottling
(
enabled
profile
)
{
if
(
!
enabled
)
{
await
this
.
emulationFront
.
clearNetworkThrottling
(
)
;
return
false
;
}
const
data
=
throttlingProfiles
.
find
(
(
{
id
}
)
=
>
id
=
=
profile
)
;
const
{
download
upload
latency
}
=
data
;
await
this
.
emulationFront
.
setNetworkThrottling
(
{
downloadThroughput
:
download
uploadThroughput
:
upload
latency
}
)
;
return
false
;
}
updateUserAgent
(
userAgent
)
{
if
(
!
userAgent
)
{
return
this
.
emulationFront
.
clearUserAgentOverride
(
)
;
}
return
this
.
emulationFront
.
setUserAgentOverride
(
userAgent
)
;
}
async
updateTouchSimulation
(
enabled
)
{
let
reloadNeeded
;
if
(
enabled
)
{
const
metaViewportEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
metaViewport
.
enabled
"
false
)
;
reloadNeeded
=
await
this
.
emulationFront
.
setTouchEventsOverride
(
Ci
.
nsIDocShell
.
TOUCHEVENTS_OVERRIDE_ENABLED
)
;
if
(
metaViewportEnabled
)
{
reloadNeeded
|
=
await
this
.
emulationFront
.
setMetaViewportOverride
(
Ci
.
nsIDocShell
.
META_VIEWPORT_OVERRIDE_ENABLED
)
;
}
}
else
{
reloadNeeded
=
await
this
.
emulationFront
.
clearTouchEventsOverride
(
)
;
reloadNeeded
|
=
await
this
.
emulationFront
.
clearMetaViewportOverride
(
)
;
}
return
reloadNeeded
;
}
getViewportSize
(
)
{
return
this
.
toolWindow
.
getViewportSize
(
)
;
}
async
setViewportSize
(
size
)
{
await
this
.
inited
;
this
.
toolWindow
.
setViewportSize
(
size
)
;
}
getViewportBrowser
(
)
{
return
this
.
toolWindow
.
getViewportBrowser
(
)
;
}
getViewportMessageManager
(
)
{
return
this
.
getViewportBrowser
(
)
.
messageManager
;
}
}
;
EventEmitter
.
decorate
(
ResponsiveUI
.
prototype
)
;
