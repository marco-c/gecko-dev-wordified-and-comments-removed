"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
head
.
js
"
this
)
;
const
BLOCKED_STATE
=
"
Blocked
"
;
const
NOT_BLOCKED_STATE
=
"
Not
Blocked
"
;
async
function
loadTracker
(
browser
trackerUrl
=
"
https
:
/
/
tracking
.
example
.
org
"
)
{
const
blockedPromise
=
waitForContentBlockingEvent
(
window
)
.
then
(
(
)
=
>
"
blocked
"
)
;
const
loadPromise
=
SpecialPowers
.
spawn
(
browser
[
trackerUrl
]
async
function
(
url
)
{
const
iframe
=
content
.
document
.
createElement
(
"
iframe
"
)
;
const
iframeLoadPromise
=
ContentTaskUtils
.
waitForEvent
(
iframe
"
load
"
)
.
then
(
(
)
=
>
"
loaded
"
)
;
iframe
.
src
=
url
;
content
.
document
.
body
.
appendChild
(
iframe
)
;
return
iframeLoadPromise
;
}
)
;
return
Promise
.
race
(
[
loadPromise
blockedPromise
]
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
contentblocking
.
category
"
"
strict
"
]
[
"
privacy
.
trackingprotection
.
enabled
"
true
]
[
"
privacy
.
trackingprotection
.
allow_list
.
baseline
.
enabled
"
false
]
[
"
privacy
.
trackingprotection
.
allow_list
.
convenience
.
enabled
"
false
]
[
"
urlclassifier
.
trackingTable
.
testEntries
"
"
tracking
.
example
.
org
social
-
tracking
.
example
.
org
"
]
[
"
urlclassifier
.
trackingAnnotationTable
.
testEntries
"
"
tracking
.
example
.
org
social
-
tracking
.
example
.
org
"
]
]
}
)
;
await
UrlClassifierTestUtils
.
addTestTrackers
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
UrlClassifierTestUtils
.
cleanupTestTrackers
(
)
;
}
)
;
}
)
;
async
function
cleanup
(
toolbox
)
{
await
closeToolboxAndTab
(
toolbox
)
;
}
add_task
(
async
function
test_single_blocked_request_shown
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
const
webcompatDebugger
=
panelWindow
.
AntiTracking
.
debugger
;
const
result
=
await
loadTracker
(
tab
.
linkedBrowser
)
;
is
(
result
"
blocked
"
"
Tracker
should
be
blocked
"
)
;
const
hasTrackers
=
!
!
Object
.
keys
(
webcompatDebugger
.
allTrackers
)
.
length
;
ok
(
hasTrackers
"
There
should
be
at
least
one
tracker
in
the
debugger
"
)
;
const
trackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
Assert
.
equal
(
trackerRows
.
length
1
"
There
should
be
one
tracker
shown
in
the
panel
"
)
;
const
blockedColumn
=
trackerRows
[
0
]
.
querySelector
(
"
td
:
nth
-
child
(
2
)
"
)
;
is
(
blockedColumn
.
textContent
BLOCKED_STATE
"
The
tracker
should
be
marked
as
blocked
"
)
;
const
hostnameColumn
=
trackerRows
[
0
]
.
querySelector
(
"
td
:
nth
-
child
(
3
)
"
)
;
ok
(
hostnameColumn
.
textContent
.
includes
(
"
tracking
.
example
.
org
"
)
"
Tracker
hostname
should
be
displayed
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
add_task
(
async
function
test_no_blocked_requests_shown
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
const
table
=
panelWindow
.
document
.
getElementById
(
"
tracker
-
table
"
)
;
const
trackerRows
=
table
.
querySelectorAll
(
"
tbody
tr
"
)
;
is
(
trackerRows
.
length
0
"
No
trackers
should
be
shown
when
none
are
blocked
"
)
;
const
noContentMessage
=
panelWindow
.
document
.
querySelector
(
"
.
no
-
content
-
message
"
)
;
ok
(
noContentMessage
&
&
noContentMessage
.
textContent
.
includes
(
"
No
blocked
resources
"
)
"
Should
show
no
blocked
resources
message
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
add_task
(
async
function
test_unblock_single_request
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
const
webcompatDebugger
=
panelWindow
.
AntiTracking
.
debugger
;
let
result
=
await
loadTracker
(
tab
.
linkedBrowser
)
;
is
(
result
"
blocked
"
"
Tracker
should
be
blocked
initially
"
)
;
const
trackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
Assert
.
equal
(
trackerRows
.
length
1
"
There
should
be
one
tracker
shown
in
the
panel
"
)
;
const
firstRow
=
trackerRows
[
0
]
;
const
blockedColumn
=
firstRow
.
querySelector
(
"
td
:
nth
-
child
(
2
)
"
)
;
is
(
blockedColumn
.
textContent
BLOCKED_STATE
"
Tracker
should
initially
be
blocked
"
)
;
const
unblockButton
=
firstRow
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
is
(
unblockButton
.
textContent
"
Unblock
"
"
Button
should
say
'
Unblock
'
"
)
;
const
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
unblockButton
.
click
(
)
;
await
browserLoadedPromise
;
const
updatedTrackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
const
updatedFirstRow
=
updatedTrackerRows
[
0
]
;
const
updatedBlockedColumn
=
updatedFirstRow
.
querySelector
(
"
td
:
nth
-
child
(
2
)
"
)
;
is
(
updatedBlockedColumn
.
textContent
NOT_BLOCKED_STATE
"
Tracker
should
now
be
unblocked
in
UI
"
)
;
const
updatedButton
=
updatedFirstRow
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
is
(
updatedButton
.
textContent
"
Block
"
"
Button
should
now
say
'
Block
'
"
)
;
ok
(
webcompatDebugger
.
unblockedChannels
.
has
(
"
tracking
.
example
.
org
"
)
"
Tracker
should
now
be
unblocked
in
debugger
state
"
)
;
await
reloadBrowser
(
tab
.
linkedBrowser
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
)
;
is
(
result
"
loaded
"
"
Tracker
should
load
successfully
after
unblocking
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
add_task
(
async
function
test_block_unblocked_channel
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
const
webcompatDebugger
=
panelWindow
.
AntiTracking
.
debugger
;
webcompatDebugger
.
unblockedChannels
=
new
Set
(
[
"
tracking
.
example
.
org
"
]
)
;
webcompatDebugger
.
allTrackers
=
{
"
tracking
.
example
.
org
"
:
"
Tracking
Protection
"
}
;
webcompatDebugger
.
populateTrackerTable
(
)
;
const
firstRow
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
[
0
]
;
const
blockButton
=
firstRow
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
ok
(
blockButton
"
Block
button
should
be
present
"
)
;
is
(
blockButton
.
textContent
"
Block
"
"
Button
should
say
'
Block
'
"
)
;
const
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
blockButton
.
click
(
)
;
await
browserLoadedPromise
;
const
updatedTrackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
const
updatedFirstRow
=
updatedTrackerRows
[
0
]
;
const
updatedBlockedColumn
=
updatedFirstRow
.
querySelector
(
"
td
:
nth
-
child
(
2
)
"
)
;
is
(
updatedBlockedColumn
.
textContent
BLOCKED_STATE
"
Tracker
should
now
be
blocked
in
UI
"
)
;
const
updatedButton
=
updatedFirstRow
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
is
(
updatedButton
.
textContent
"
Unblock
"
"
Button
should
now
say
'
Unblock
'
"
)
;
ok
(
!
webcompatDebugger
.
unblockedChannels
.
has
(
"
tracking
.
example
.
org
"
)
"
Tracker
should
now
be
blocked
(
removed
from
unblockedChannels
)
"
)
;
const
result
=
await
loadTracker
(
tab
.
linkedBrowser
)
;
is
(
result
"
blocked
"
"
Tracker
should
be
blocked
after
clicking
block
button
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
add_task
(
async
function
test_multiple_trackers_one_unblocked
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
let
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
tracking
.
example
.
org
"
)
;
is
(
result
"
blocked
"
"
First
tracker
should
be
blocked
"
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
social
-
tracking
.
example
.
org
"
)
;
is
(
result
"
blocked
"
"
Second
tracker
should
also
be
blocked
"
)
;
const
trackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
Assert
.
equal
(
trackerRows
.
length
2
"
Two
trackers
should
be
shown
in
the
panel
"
)
;
const
firstRow
=
trackerRows
[
0
]
;
const
unblockButton
=
firstRow
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
const
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
unblockButton
.
click
(
)
;
await
browserLoadedPromise
;
const
updatedTrackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
const
updatedFirstRow
=
updatedTrackerRows
[
0
]
;
const
updatedBlockedColumn
=
updatedFirstRow
.
querySelector
(
"
td
:
nth
-
child
(
2
)
"
)
;
is
(
updatedBlockedColumn
.
textContent
NOT_BLOCKED_STATE
"
First
tracker
should
now
be
unblocked
in
UI
"
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
tracking
.
example
.
org
"
)
;
is
(
result
"
loaded
"
"
First
tracker
should
be
loaded
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
add_task
(
async
function
test_unblock_selected_button
(
)
{
const
tab
=
await
addTab
(
"
https
:
/
/
example
.
com
/
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
antitracking
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
panelWindow
=
panel
.
panelWin
;
const
webcompatDebugger
=
panelWindow
.
AntiTracking
.
debugger
;
let
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
tracking
.
example
.
org
"
)
;
is
(
result
"
blocked
"
"
First
tracker
should
be
blocked
"
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
social
-
tracking
.
example
.
org
"
)
;
is
(
result
"
blocked
"
"
Second
tracker
should
also
be
blocked
"
)
;
const
rowCheckboxes
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
.
row
-
checkbox
"
)
;
is
(
rowCheckboxes
.
length
2
"
Two
row
checkboxes
should
be
present
"
)
;
rowCheckboxes
[
0
]
.
click
(
)
;
rowCheckboxes
[
1
]
.
click
(
)
;
const
unblockSelectedButton
=
panelWindow
.
document
.
getElementById
(
"
unblock
-
selected
"
)
;
ok
(
unblockSelectedButton
"
Unblock
selected
button
should
be
present
"
)
;
const
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
unblockSelectedButton
.
click
(
)
;
await
browserLoadedPromise
;
ok
(
webcompatDebugger
.
unblockedChannels
.
has
(
"
tracking
.
example
.
org
"
)
"
First
tracker
should
be
unblocked
in
debugger
state
"
)
;
ok
(
webcompatDebugger
.
unblockedChannels
.
has
(
"
social
-
tracking
.
example
.
org
"
)
"
Second
tracker
should
be
unblocked
in
debugger
state
"
)
;
const
updatedTrackerRows
=
panelWindow
.
document
.
querySelectorAll
(
"
#
tracker
-
table
tbody
tr
"
)
;
const
firstRowButton
=
updatedTrackerRows
[
0
]
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
const
secondRowButton
=
updatedTrackerRows
[
1
]
.
querySelector
(
"
td
:
last
-
child
button
"
)
;
is
(
firstRowButton
.
textContent
"
Block
"
"
First
tracker
button
should
say
'
Block
'
"
)
;
is
(
secondRowButton
.
textContent
"
Block
"
"
Second
tracker
button
should
say
'
Block
'
"
)
;
await
reloadBrowser
(
tab
.
linkedBrowser
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
tracking
.
example
.
org
"
)
;
is
(
result
"
loaded
"
"
First
tracker
should
load
after
bulk
unblock
"
)
;
result
=
await
loadTracker
(
tab
.
linkedBrowser
"
https
:
/
/
social
-
tracking
.
example
.
org
"
)
;
is
(
result
"
loaded
"
"
Second
tracker
should
load
after
bulk
unblock
"
)
;
await
cleanup
(
toolbox
)
;
}
)
;
