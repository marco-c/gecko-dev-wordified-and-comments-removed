"
use
strict
"
;
class
DebuggerFSMContext
{
constructor
(
allTrackers
{
onPromptTextUpdate
onButtonStateUpdate
onTrackersBlockedStateUpdate
}
)
{
this
.
allTrackers
=
allTrackers
;
this
.
subdomainStageTrackers
=
new
Set
(
)
;
this
.
necessaryTrackers
=
new
Set
(
)
;
this
.
onTrackersBlockedStateUpdate
=
onTrackersBlockedStateUpdate
|
|
(
(
)
=
>
{
}
)
;
this
.
onPromptTextUpdate
=
onPromptTextUpdate
|
|
(
(
)
=
>
{
}
)
;
this
.
onButtonStateUpdate
=
onButtonStateUpdate
|
|
(
(
)
=
>
{
}
)
;
this
.
onTrackersBlockedStateUpdate
(
false
this
.
allTrackers
)
;
this
.
onButtonStateUpdate
(
"
stop
-
debugging
"
false
)
;
this
.
changeState
(
new
DomainStageState
(
this
)
)
;
}
changeState
(
state
)
{
this
.
state
=
state
;
}
async
onTestNextTracker
(
)
{
await
this
.
state
.
onTestNextTracker
(
)
;
}
async
onWebsiteBroke
(
)
{
await
this
.
state
.
onWebsiteBroke
(
)
;
}
async
stop
(
)
{
this
.
onPromptTextUpdate
(
undefined
Interactive
debugger
stopped
.
)
;
await
this
.
onTrackersBlockedStateUpdate
(
false
this
.
allTrackers
)
;
this
.
onButtonStateUpdate
(
"
test
-
next
-
tracker
"
true
)
;
this
.
onButtonStateUpdate
(
"
website
-
broke
"
true
)
;
this
.
onButtonStateUpdate
(
"
stop
-
debugging
"
true
)
;
}
}
class
FSMState
{
constructor
(
debuggerFSMContext
)
{
this
.
debuggerFSMContext
=
debuggerFSMContext
;
}
onTestNextTracker
(
)
{
throw
new
Error
(
"
onTestNextTracker
must
be
implemented
in
derived
class
"
)
;
}
onWebsiteBroke
(
)
{
throw
new
Error
(
"
onWebsiteBroke
must
be
implemented
in
derived
class
"
)
;
}
}
class
DomainStageState
extends
FSMState
{
constructor
(
debuggerFSMContext
)
{
super
(
debuggerFSMContext
)
;
this
.
domainGroups
=
this
.
groupByDomain
(
debuggerFSMContext
.
allTrackers
)
;
this
.
lastGroup
=
null
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
this
.
domainGroups
.
length
"
Click
'
Continue
'
to
start
domain
debugging
.
"
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
test
-
next
-
tracker
"
false
)
;
}
async
onTestNextTracker
(
)
{
this
.
lastGroup
=
this
.
domainGroups
.
shift
(
)
;
const
count
=
this
.
domainGroups
.
length
;
if
(
!
this
.
lastGroup
)
{
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
count
"
Domain
debugging
finished
.
Starting
subdomain
tracker
stage
.
Click
'
Continue
'
to
proceed
.
"
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
true
)
;
this
.
debuggerFSMContext
.
changeState
(
new
SubdomainStageState
(
this
.
debuggerFSMContext
)
)
;
return
;
}
await
this
.
debuggerFSMContext
.
onTrackersBlockedStateUpdate
(
true
this
.
lastGroup
.
hosts
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
false
)
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
count
Blocked
domain
group
'
{
this
.
lastGroup
.
domain
}
'
.
If
the
website
is
broken
click
'
Website
Broke
'
otherwise
'
Continue
'
.
)
;
}
async
onWebsiteBroke
(
)
{
if
(
this
.
lastGroup
&
&
this
.
lastGroup
.
hosts
)
{
this
.
lastGroup
.
hosts
.
forEach
(
tracker
=
>
this
.
debuggerFSMContext
.
subdomainStageTrackers
.
add
(
tracker
)
)
;
await
this
.
debuggerFSMContext
.
onTrackersBlockedStateUpdate
(
false
this
.
lastGroup
.
hosts
)
;
const
count
=
this
.
domainGroups
.
length
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
count
Domain
group
'
{
this
.
lastGroup
.
domain
}
'
will
be
tested
individually
later
.
Click
'
Continue
'
to
test
the
next
domain
group
.
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
true
)
;
}
}
groupByDomain
(
trackers
)
{
const
domainGroupsMap
=
{
}
;
trackers
.
forEach
(
tracker
=
>
{
const
domain
=
Services
.
eTLD
.
getBaseDomainFromHost
(
tracker
)
;
if
(
!
domainGroupsMap
[
domain
]
)
{
domainGroupsMap
[
domain
]
=
new
Set
(
)
;
}
domainGroupsMap
[
domain
]
.
add
(
tracker
)
;
}
)
;
return
Object
.
entries
(
domainGroupsMap
)
.
map
(
(
[
domain
hosts
]
)
=
>
(
{
domain
hosts
:
Array
.
from
(
hosts
)
}
)
)
;
}
}
class
SubdomainStageState
extends
FSMState
{
constructor
(
debuggerFSMContext
)
{
super
(
debuggerFSMContext
)
;
this
.
subdomains
=
Array
.
from
(
debuggerFSMContext
.
subdomainStageTrackers
)
;
this
.
lastSubdomain
=
null
;
}
async
onTestNextTracker
(
)
{
this
.
lastSubdomain
=
this
.
subdomains
.
shift
(
)
;
const
count
=
this
.
subdomains
.
length
;
if
(
!
this
.
lastSubdomain
)
{
this
.
debuggerFSMContext
.
changeState
(
new
CompletedState
(
this
.
debuggerFSMContext
)
)
;
return
;
}
await
this
.
debuggerFSMContext
.
onTrackersBlockedStateUpdate
(
true
[
this
.
lastSubdomain
]
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
false
)
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
count
Blocked
subdomain
'
{
this
.
lastSubdomain
}
'
.
If
the
website
is
broken
click
'
Website
Broke
'
otherwise
'
Continue
'
.
)
;
}
async
onWebsiteBroke
(
)
{
if
(
this
.
lastSubdomain
)
{
this
.
debuggerFSMContext
.
necessaryTrackers
.
add
(
this
.
lastSubdomain
)
;
await
this
.
debuggerFSMContext
.
onTrackersBlockedStateUpdate
(
false
[
this
.
lastSubdomain
]
)
;
const
count
=
this
.
subdomains
.
length
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
true
)
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
count
Added
'
{
this
.
lastSubdomain
}
'
to
necessary
trackers
.
Click
'
Continue
'
to
test
the
next
subdomain
.
)
;
}
}
}
class
CompletedState
extends
FSMState
{
constructor
(
debuggerFSMContext
)
{
super
(
debuggerFSMContext
)
;
this
.
debuggerFSMContext
.
onPromptTextUpdate
(
undefined
Subdomain
debugging
finished
.
Please
add
the
following
to
the
exceptions
list
:
{
Array
.
from
(
this
.
debuggerFSMContext
.
necessaryTrackers
)
.
join
(
"
"
)
}
true
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
test
-
next
-
tracker
"
true
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
website
-
broke
"
true
)
;
this
.
debuggerFSMContext
.
onButtonStateUpdate
(
"
stop
-
debugging
"
true
)
;
}
}
if
(
typeof
module
!
=
=
"
undefined
"
&
&
module
.
exports
)
{
module
.
exports
=
{
DebuggerFSMContext
DomainStageState
SubdomainStageState
CompletedState
}
;
}
exports
.
DebuggerFSMContext
=
DebuggerFSMContext
;
