"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
function
isNodeVisible
(
node
)
{
return
!
!
node
.
getClientRects
(
)
.
length
;
}
async
function
waitForUpdate
(
inspector
waitForSelectionUpdate
)
{
await
inspector
.
highlighters
.
hideHighlighterType
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
return
new
Promise
(
resolve
=
>
{
inspector
.
on
(
"
boxmodel
-
view
-
updated
"
function
onUpdate
(
reasons
)
{
if
(
waitForSelectionUpdate
&
&
!
reasons
.
includes
(
"
new
-
selection
"
)
)
{
return
;
}
inspector
.
off
(
"
boxmodel
-
view
-
updated
"
onUpdate
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
waitForMarkupLoaded
(
inspector
)
{
return
Promise
.
all
(
[
waitForUpdate
(
inspector
)
inspector
.
once
(
"
markuploaded
"
)
]
)
;
}
function
getStyle
(
browser
selector
propertyName
)
{
return
SpecialPowers
.
spawn
(
browser
[
selector
propertyName
]
async
function
(
_selector
_propertyName
)
{
return
content
.
document
.
querySelector
(
_selector
)
.
style
.
getPropertyValue
(
_propertyName
)
;
}
)
;
}
function
setStyle
(
browser
selector
propertyName
value
)
{
return
SpecialPowers
.
spawn
(
browser
[
selector
propertyName
value
]
async
function
(
_selector
_propertyName
_value
)
{
content
.
document
.
querySelector
(
_selector
)
.
style
[
_propertyName
]
=
_value
;
}
)
;
}
var
_selectNode
=
selectNode
;
selectNode
=
async
function
(
node
inspector
reason
)
{
const
onUpdate
=
waitForUpdate
(
inspector
true
)
;
await
_selectNode
(
node
inspector
reason
)
;
await
onUpdate
;
}
;
async
function
waitForElementTextContent
(
element
expectedText
)
{
await
waitFor
(
(
)
=
>
element
.
textContent
=
=
=
expectedText
Couldn
'
t
get
"
{
expectedText
}
"
as
the
text
content
of
the
given
element
)
;
ok
(
true
Found
the
expected
text
(
{
expectedText
}
)
for
the
given
element
)
;
}
