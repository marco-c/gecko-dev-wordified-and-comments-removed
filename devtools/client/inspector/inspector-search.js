"
use
strict
"
;
const
{
Cu
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
loader
.
lazyGetter
(
this
"
EventEmitter
"
(
)
=
>
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
)
;
loader
.
lazyGetter
(
this
"
AutocompletePopup
"
(
)
=
>
require
(
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
.
AutocompletePopup
)
;
const
MAX_SUGGESTIONS
=
15
;
function
InspectorSearch
(
inspector
input
)
{
this
.
inspector
=
inspector
;
this
.
searchBox
=
input
;
this
.
_lastSearched
=
null
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_onCommand
=
this
.
_onCommand
.
bind
(
this
)
;
this
.
searchBox
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
searchBox
.
addEventListener
(
"
command
"
this
.
_onCommand
true
)
;
this
.
_lastQuery
=
promise
.
resolve
(
null
)
;
this
.
autocompleter
=
new
SelectorAutocompleter
(
inspector
input
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
InspectorSearch
=
InspectorSearch
;
InspectorSearch
.
prototype
=
{
get
walker
(
)
{
return
this
.
inspector
.
walker
;
}
destroy
:
function
(
)
{
this
.
searchBox
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
searchBox
.
removeEventListener
(
"
command
"
this
.
_onCommand
true
)
;
this
.
searchBox
=
null
;
this
.
autocompleter
.
destroy
(
)
;
}
_onSearch
:
function
(
reverse
=
false
)
{
this
.
doFullTextSearch
(
this
.
searchBox
.
value
reverse
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
doFullTextSearch
:
Task
.
async
(
function
*
(
query
reverse
)
{
let
lastSearched
=
this
.
_lastSearched
;
this
.
_lastSearched
=
query
;
if
(
query
.
length
=
=
=
0
)
{
this
.
searchBox
.
classList
.
remove
(
"
devtools
-
no
-
search
-
result
"
)
;
if
(
!
lastSearched
|
|
lastSearched
.
length
>
0
)
{
this
.
emit
(
"
search
-
cleared
"
)
;
}
return
;
}
let
res
=
yield
this
.
walker
.
search
(
query
{
reverse
}
)
;
if
(
query
!
=
this
.
searchBox
.
value
)
{
return
;
}
if
(
res
)
{
this
.
inspector
.
selection
.
setNodeFront
(
res
.
node
"
inspectorsearch
"
)
;
this
.
searchBox
.
classList
.
remove
(
"
devtools
-
no
-
search
-
result
"
)
;
res
.
query
=
query
;
this
.
emit
(
"
search
-
result
"
res
)
;
}
else
{
this
.
searchBox
.
classList
.
add
(
"
devtools
-
no
-
search
-
result
"
)
;
this
.
emit
(
"
search
-
result
"
)
;
}
}
)
_onCommand
:
function
(
)
{
if
(
this
.
searchBox
.
value
.
length
=
=
=
0
)
{
this
.
_onSearch
(
)
;
}
}
_onKeyDown
:
function
(
event
)
{
if
(
this
.
searchBox
.
value
.
length
=
=
=
0
)
{
this
.
searchBox
.
removeAttribute
(
"
filled
"
)
;
}
else
{
this
.
searchBox
.
setAttribute
(
"
filled
"
true
)
;
}
if
(
event
.
keyCode
=
=
=
event
.
DOM_VK_RETURN
)
{
this
.
_onSearch
(
)
;
}
if
(
event
.
keyCode
=
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_G
&
&
event
.
metaKey
)
{
this
.
_onSearch
(
event
.
shiftKey
)
;
event
.
preventDefault
(
)
;
}
}
}
;
function
SelectorAutocompleter
(
inspector
inputNode
)
{
this
.
inspector
=
inspector
;
this
.
searchBox
=
inputNode
;
this
.
panelDoc
=
this
.
searchBox
.
ownerDocument
;
this
.
showSuggestions
=
this
.
showSuggestions
.
bind
(
this
)
;
this
.
_onSearchKeypress
=
this
.
_onSearchKeypress
.
bind
(
this
)
;
this
.
_onListBoxKeypress
=
this
.
_onListBoxKeypress
.
bind
(
this
)
;
this
.
_onMarkupMutation
=
this
.
_onMarkupMutation
.
bind
(
this
)
;
let
options
=
{
panelId
:
"
inspector
-
searchbox
-
panel
"
listBoxId
:
"
searchbox
-
panel
-
listbox
"
autoSelect
:
true
position
:
"
before_start
"
direction
:
"
ltr
"
theme
:
"
auto
"
onClick
:
this
.
_onListBoxKeypress
onKeypress
:
this
.
_onListBoxKeypress
}
;
this
.
searchPopup
=
new
AutocompletePopup
(
this
.
panelDoc
options
)
;
this
.
searchBox
.
addEventListener
(
"
input
"
this
.
showSuggestions
true
)
;
this
.
searchBox
.
addEventListener
(
"
keypress
"
this
.
_onSearchKeypress
true
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
_onMarkupMutation
)
;
this
.
_lastQuery
=
promise
.
resolve
(
null
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
SelectorAutocompleter
=
SelectorAutocompleter
;
SelectorAutocompleter
.
prototype
=
{
get
walker
(
)
{
return
this
.
inspector
.
walker
;
}
States
:
{
CLASS
:
"
class
"
ID
:
"
id
"
TAG
:
"
tag
"
}
_state
:
null
_lastStateCheckAt
:
null
get
state
(
)
{
if
(
!
this
.
searchBox
|
|
!
this
.
searchBox
.
value
)
{
return
null
;
}
let
query
=
this
.
searchBox
.
value
;
if
(
this
.
_lastStateCheckAt
=
=
query
)
{
return
this
.
_state
;
}
this
.
_lastStateCheckAt
=
query
;
this
.
_state
=
null
;
let
subQuery
=
"
"
;
for
(
let
i
=
1
;
i
<
=
query
.
length
;
i
+
+
)
{
subQuery
=
query
.
slice
(
0
i
)
;
let
[
secondLastChar
lastChar
]
=
subQuery
.
slice
(
-
2
)
;
switch
(
this
.
_state
)
{
case
null
:
lastChar
=
secondLastChar
;
case
this
.
States
.
TAG
:
this
.
_state
=
lastChar
=
=
"
.
"
?
this
.
States
.
CLASS
:
lastChar
=
=
"
#
"
?
this
.
States
.
ID
:
this
.
States
.
TAG
;
break
;
case
this
.
States
.
CLASS
:
if
(
subQuery
.
match
(
/
[
\
.
]
+
[
^
\
.
]
*
/
)
[
0
]
.
length
>
2
)
{
this
.
_state
=
(
lastChar
=
=
"
"
|
|
lastChar
=
=
"
>
"
)
?
this
.
States
.
TAG
:
lastChar
=
=
"
#
"
?
this
.
States
.
ID
:
this
.
States
.
CLASS
;
}
break
;
case
this
.
States
.
ID
:
if
(
subQuery
.
match
(
/
[
#
]
+
[
^
#
]
*
/
)
[
0
]
.
length
>
2
)
{
this
.
_state
=
(
lastChar
=
=
"
"
|
|
lastChar
=
=
"
>
"
)
?
this
.
States
.
TAG
:
lastChar
=
=
"
.
"
?
this
.
States
.
CLASS
:
this
.
States
.
ID
;
}
break
;
}
}
return
this
.
_state
;
}
destroy
:
function
(
)
{
this
.
searchBox
.
removeEventListener
(
"
input
"
this
.
showSuggestions
true
)
;
this
.
searchBox
.
removeEventListener
(
"
keypress
"
this
.
_onSearchKeypress
true
)
;
this
.
inspector
.
off
(
"
markupmutation
"
this
.
_onMarkupMutation
)
;
this
.
searchPopup
.
destroy
(
)
;
this
.
searchPopup
=
null
;
this
.
searchBox
=
null
;
this
.
panelDoc
=
null
;
}
_onSearchKeypress
:
function
(
event
)
{
let
query
=
this
.
searchBox
.
value
;
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_RETURN
:
case
event
.
DOM_VK_TAB
:
if
(
this
.
searchPopup
.
isOpen
&
&
this
.
searchPopup
.
getItemAtIndex
(
this
.
searchPopup
.
itemCount
-
1
)
.
preLabel
=
=
query
)
{
this
.
searchPopup
.
selectedIndex
=
this
.
searchPopup
.
itemCount
-
1
;
this
.
searchBox
.
value
=
this
.
searchPopup
.
selectedItem
.
label
;
this
.
hidePopup
(
)
;
}
break
;
case
event
.
DOM_VK_UP
:
if
(
this
.
searchPopup
.
isOpen
&
&
this
.
searchPopup
.
itemCount
>
0
)
{
this
.
searchPopup
.
focus
(
)
;
if
(
this
.
searchPopup
.
selectedIndex
=
=
this
.
searchPopup
.
itemCount
-
1
)
{
this
.
searchPopup
.
selectedIndex
=
Math
.
max
(
0
this
.
searchPopup
.
itemCount
-
2
)
;
}
else
{
this
.
searchPopup
.
selectedIndex
=
this
.
searchPopup
.
itemCount
-
1
;
}
this
.
searchBox
.
value
=
this
.
searchPopup
.
selectedItem
.
label
;
}
break
;
case
event
.
DOM_VK_DOWN
:
if
(
this
.
searchPopup
.
isOpen
&
&
this
.
searchPopup
.
itemCount
>
0
)
{
this
.
searchPopup
.
focus
(
)
;
this
.
searchPopup
.
selectedIndex
=
0
;
this
.
searchBox
.
value
=
this
.
searchPopup
.
selectedItem
.
label
;
}
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
emit
(
"
processing
-
done
"
)
;
}
_onListBoxKeypress
:
function
(
event
)
{
switch
(
event
.
keyCode
|
|
event
.
button
)
{
case
event
.
DOM_VK_RETURN
:
case
event
.
DOM_VK_TAB
:
case
0
:
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
searchBox
.
value
=
this
.
searchPopup
.
selectedItem
.
label
;
this
.
searchBox
.
focus
(
)
;
this
.
hidePopup
(
)
;
break
;
case
event
.
DOM_VK_UP
:
if
(
this
.
searchPopup
.
selectedIndex
=
=
0
)
{
this
.
searchPopup
.
selectedIndex
=
-
1
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
else
{
let
index
=
this
.
searchPopup
.
selectedIndex
;
this
.
searchBox
.
value
=
this
.
searchPopup
.
getItemAtIndex
(
index
-
1
)
.
label
;
}
break
;
case
event
.
DOM_VK_DOWN
:
if
(
this
.
searchPopup
.
selectedIndex
=
=
this
.
searchPopup
.
itemCount
-
1
)
{
this
.
searchPopup
.
selectedIndex
=
-
1
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
else
{
let
index
=
this
.
searchPopup
.
selectedIndex
;
this
.
searchBox
.
value
=
this
.
searchPopup
.
getItemAtIndex
(
index
+
1
)
.
label
;
}
break
;
case
event
.
DOM_VK_BACK_SPACE
:
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
if
(
this
.
searchBox
.
selectionStart
>
0
)
{
this
.
searchBox
.
value
=
this
.
searchBox
.
value
.
substring
(
0
this
.
searchBox
.
selectionStart
-
1
)
;
}
this
.
hidePopup
(
)
;
break
;
}
this
.
emit
(
"
processing
-
done
"
)
;
}
_onMarkupMutation
:
function
(
)
{
this
.
_searchResults
=
null
;
this
.
_lastSearched
=
null
;
}
_showPopup
:
function
(
list
firstPart
aState
)
{
let
total
=
0
;
let
query
=
this
.
searchBox
.
value
;
let
items
=
[
]
;
for
(
let
[
value
state
]
of
list
)
{
if
(
query
.
match
(
/
[
\
s
>
+
]
/
)
)
{
value
=
query
+
value
;
}
else
if
(
query
.
match
(
/
[
\
s
>
+
]
[
\
.
#
a
-
zA
-
Z
]
[
^
\
s
>
+
\
.
#
]
*
/
)
)
{
let
lastPart
=
query
.
match
(
/
[
\
s
>
+
]
[
\
.
#
a
-
zA
-
Z
]
[
^
>
\
s
+
\
.
#
]
*
/
)
[
0
]
;
value
=
query
.
slice
(
0
-
1
*
lastPart
.
length
+
1
)
+
value
;
}
else
if
(
query
.
match
(
/
[
a
-
zA
-
Z
]
[
#
\
.
]
[
^
#
\
.
\
s
+
>
]
*
/
)
)
{
let
lastPart
=
query
.
match
(
/
[
a
-
zA
-
Z
]
[
#
\
.
]
[
^
#
\
.
\
s
>
+
]
*
/
)
[
0
]
;
value
=
query
.
slice
(
0
-
1
*
lastPart
.
length
+
1
)
+
value
;
}
let
item
=
{
preLabel
:
query
label
:
value
}
;
if
(
value
.
match
(
/
.
*
[
\
.
#
]
[
^
\
.
#
]
{
0
}
/
)
=
=
null
)
{
item
.
label
=
value
.
toLowerCase
(
)
;
}
if
(
aState
=
=
=
this
.
States
.
TAG
&
&
state
=
=
=
this
.
States
.
CLASS
)
{
item
.
preLabel
=
"
.
"
+
item
.
preLabel
;
}
if
(
aState
=
=
=
this
.
States
.
TAG
&
&
state
=
=
=
this
.
States
.
ID
)
{
item
.
preLabel
=
"
#
"
+
item
.
preLabel
;
}
items
.
unshift
(
item
)
;
if
(
+
+
total
>
MAX_SUGGESTIONS
-
1
)
{
break
;
}
}
if
(
total
>
0
)
{
this
.
searchPopup
.
setItems
(
items
)
;
this
.
searchPopup
.
openPopup
(
this
.
searchBox
)
;
}
else
{
this
.
hidePopup
(
)
;
}
}
hidePopup
:
function
(
)
{
if
(
this
.
searchPopup
.
isOpen
)
{
this
.
searchPopup
.
hidePopup
(
)
;
}
}
showSuggestions
:
function
(
)
{
let
query
=
this
.
searchBox
.
value
;
let
state
=
this
.
state
;
let
firstPart
=
"
"
;
if
(
state
=
=
=
this
.
States
.
TAG
)
{
firstPart
=
(
query
.
match
(
/
[
\
s
>
+
]
?
(
[
a
-
zA
-
Z
]
*
)
/
)
|
|
[
"
"
query
]
)
[
1
]
;
query
=
query
.
slice
(
0
query
.
length
-
firstPart
.
length
)
;
}
else
if
(
state
=
=
=
this
.
States
.
CLASS
)
{
firstPart
=
query
.
match
(
/
\
.
(
[
^
\
.
]
*
)
/
)
[
1
]
;
query
=
query
.
slice
(
0
query
.
length
-
firstPart
.
length
-
1
)
;
}
else
if
(
state
=
=
=
this
.
States
.
ID
)
{
firstPart
=
query
.
match
(
/
#
(
[
^
#
]
*
)
/
)
[
1
]
;
query
=
query
.
slice
(
0
query
.
length
-
firstPart
.
length
-
1
)
;
}
if
(
/
[
\
s
+
>
~
]
/
.
test
(
query
)
)
{
query
+
=
"
*
"
;
}
this
.
_lastQuery
=
this
.
walker
.
getSuggestionsForQuery
(
query
firstPart
state
)
.
then
(
result
=
>
{
this
.
emit
(
"
processing
-
done
"
)
;
if
(
result
.
query
!
=
=
query
)
{
return
;
}
if
(
state
=
=
=
this
.
States
.
CLASS
)
{
firstPart
=
"
.
"
+
firstPart
;
}
else
if
(
state
=
=
=
this
.
States
.
ID
)
{
firstPart
=
"
#
"
+
firstPart
;
}
if
(
result
.
suggestions
.
length
=
=
=
1
&
&
result
.
suggestions
[
0
]
[
0
]
=
=
=
firstPart
)
{
result
.
suggestions
=
[
]
;
}
this
.
_showPopup
(
result
.
suggestions
firstPart
state
)
;
}
)
;
return
this
.
_lastQuery
;
}
}
;
