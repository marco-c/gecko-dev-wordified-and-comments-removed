"
use
strict
"
;
const
{
KeyCodes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
keycodes
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
AutocompletePopup
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
autocomplete
-
popup
.
js
"
)
;
const
MAX_SUGGESTIONS
=
15
;
function
InspectorSearch
(
inspector
input
clearBtn
prevBtn
nextBtn
)
{
this
.
inspector
=
inspector
;
this
.
searchBox
=
input
;
this
.
searchClearButton
=
clearBtn
;
this
.
searchPrevButton
=
prevBtn
;
this
.
searchNextButton
=
nextBtn
;
this
.
_lastSearched
=
null
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_onInput
=
this
.
_onInput
.
bind
(
this
)
;
this
.
findPrev
=
this
.
findPrev
.
bind
(
this
)
;
this
.
findNext
=
this
.
findNext
.
bind
(
this
)
;
this
.
_onClearSearch
=
this
.
_onClearSearch
.
bind
(
this
)
;
this
.
searchBox
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
searchBox
.
addEventListener
(
"
input
"
this
.
_onInput
true
)
;
this
.
searchPrevButton
.
addEventListener
(
"
click
"
this
.
findPrev
true
)
;
this
.
searchNextButton
.
addEventListener
(
"
click
"
this
.
findNext
true
)
;
this
.
searchClearButton
.
addEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
autocompleter
=
new
SelectorAutocompleter
(
inspector
input
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
InspectorSearch
=
InspectorSearch
;
InspectorSearch
.
prototype
=
{
destroy
(
)
{
this
.
searchBox
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
searchBox
.
removeEventListener
(
"
input
"
this
.
_onInput
true
)
;
this
.
searchPrevButton
.
removeEventListener
(
"
click
"
this
.
findPrev
true
)
;
this
.
searchNextButton
.
removeEventListener
(
"
click
"
this
.
findNext
true
)
;
this
.
searchClearButton
.
removeEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
searchBox
=
null
;
this
.
searchPrevButton
=
null
;
this
.
searchNextButton
=
null
;
this
.
searchClearButton
=
null
;
this
.
autocompleter
.
destroy
(
)
;
}
_onSearch
(
reverse
=
false
)
{
this
.
doFullTextSearch
(
this
.
searchBox
.
value
reverse
)
.
catch
(
console
.
error
)
;
}
async
doFullTextSearch
(
query
reverse
)
{
const
lastSearched
=
this
.
_lastSearched
;
this
.
_lastSearched
=
query
;
const
searchContainer
=
this
.
searchBox
.
parentNode
;
if
(
query
.
length
=
=
=
0
)
{
searchContainer
.
classList
.
remove
(
"
devtools
-
searchbox
-
no
-
match
"
)
;
if
(
!
lastSearched
|
|
lastSearched
.
length
)
{
this
.
emit
(
"
search
-
cleared
"
)
;
}
return
;
}
const
res
=
await
this
.
inspector
.
commands
.
inspectorCommand
.
findNextNode
(
query
{
reverse
}
)
;
if
(
query
!
=
=
this
.
searchBox
.
value
)
{
return
;
}
if
(
res
)
{
this
.
inspector
.
selection
.
setNodeFront
(
res
.
node
{
reason
:
"
inspectorsearch
"
searchQuery
:
query
}
)
;
searchContainer
.
classList
.
remove
(
"
devtools
-
searchbox
-
no
-
match
"
)
;
res
.
query
=
query
;
this
.
emit
(
"
search
-
result
"
res
)
;
}
else
{
searchContainer
.
classList
.
add
(
"
devtools
-
searchbox
-
no
-
match
"
)
;
this
.
emit
(
"
search
-
result
"
)
;
}
}
_onInput
(
)
{
if
(
this
.
searchBox
.
value
.
length
=
=
=
0
)
{
this
.
searchClearButton
.
hidden
=
true
;
this
.
_onSearch
(
)
;
}
else
{
this
.
searchClearButton
.
hidden
=
false
;
}
}
_onKeyDown
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
this
.
_onSearch
(
event
.
shiftKey
)
;
}
const
modifierKey
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
event
.
metaKey
:
event
.
ctrlKey
;
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_G
&
&
modifierKey
)
{
this
.
_onSearch
(
event
.
shiftKey
)
;
event
.
preventDefault
(
)
;
}
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
&
&
this
.
autocompleter
.
searchPopup
?
.
isOpen
)
{
event
.
preventDefault
(
)
;
this
.
autocompleter
.
hidePopup
(
)
;
}
}
findNext
(
)
{
this
.
_onSearch
(
)
;
}
findPrev
(
)
{
this
.
_onSearch
(
true
)
;
}
_onClearSearch
(
)
{
this
.
searchBox
.
parentNode
.
classList
.
remove
(
"
devtools
-
searchbox
-
no
-
match
"
)
;
this
.
searchBox
.
value
=
"
"
;
this
.
searchBox
.
focus
(
)
;
this
.
searchClearButton
.
hidden
=
true
;
this
.
emit
(
"
search
-
cleared
"
)
;
}
}
;
class
SelectorAutocompleter
extends
EventEmitter
{
constructor
(
inspector
inputNode
)
{
super
(
)
;
this
.
inspector
=
inspector
;
this
.
searchBox
=
inputNode
;
this
.
panelDoc
=
this
.
searchBox
.
ownerDocument
;
this
.
showSuggestions
=
this
.
showSuggestions
.
bind
(
this
)
;
const
options
=
{
listId
:
"
searchbox
-
panel
-
listbox
"
autoSelect
:
true
position
:
"
top
"
onClick
:
this
.
#
onSearchPopupClick
}
;
this
.
searchPopup
=
new
AutocompletePopup
(
inspector
.
toolbox
.
doc
options
)
;
this
.
searchBox
.
addEventListener
(
"
input
"
this
.
showSuggestions
true
)
;
this
.
searchBox
.
addEventListener
(
"
keypress
"
this
.
#
onSearchKeypress
true
)
;
}
States
=
{
CLASS
:
"
class
"
ID
:
"
id
"
TAG
:
"
tag
"
ATTRIBUTE
:
"
attribute
"
PSEUDO_CLASS
:
"
pseudo
"
PSEUDO_ELEMENT
:
"
pseudo
-
element
"
}
;
#
state
=
null
;
#
lastStateCheckAt
=
null
;
get
walker
(
)
{
return
this
.
inspector
.
walker
;
}
get
state
(
)
{
if
(
!
this
.
searchBox
|
|
!
this
.
searchBox
.
value
)
{
return
null
;
}
const
query
=
this
.
searchBox
.
value
;
if
(
this
.
#
lastStateCheckAt
=
=
query
)
{
return
this
.
#
state
;
}
this
.
#
lastStateCheckAt
=
query
;
this
.
#
state
=
null
;
let
subQuery
=
"
"
;
for
(
let
i
=
1
;
i
<
=
query
.
length
;
i
+
+
)
{
subQuery
=
query
.
slice
(
0
i
)
;
let
[
secondLastChar
lastChar
]
=
subQuery
.
slice
(
-
2
)
;
switch
(
this
.
#
state
)
{
case
null
:
lastChar
=
secondLastChar
;
case
this
.
States
.
TAG
:
if
(
lastChar
=
=
=
"
.
"
)
{
this
.
#
state
=
this
.
States
.
CLASS
;
}
else
if
(
lastChar
=
=
=
"
#
"
)
{
this
.
#
state
=
this
.
States
.
ID
;
}
else
if
(
lastChar
=
=
=
"
[
"
)
{
this
.
#
state
=
this
.
States
.
ATTRIBUTE
;
}
else
if
(
lastChar
=
=
=
"
:
"
)
{
this
.
#
state
=
this
.
States
.
PSEUDO_CLASS
;
}
else
if
(
lastChar
=
=
=
"
)
"
)
{
this
.
#
state
=
null
;
}
else
{
this
.
#
state
=
this
.
States
.
TAG
;
}
break
;
case
this
.
States
.
CLASS
:
if
(
subQuery
.
match
(
/
[
\
.
]
+
[
^
\
.
]
*
/
)
[
0
]
.
length
>
2
)
{
if
(
lastChar
=
=
=
"
"
|
|
lastChar
=
=
=
"
>
"
)
{
this
.
#
state
=
this
.
States
.
TAG
;
}
else
if
(
lastChar
=
=
=
"
#
"
)
{
this
.
#
state
=
this
.
States
.
ID
;
}
else
if
(
lastChar
=
=
=
"
[
"
)
{
this
.
#
state
=
this
.
States
.
ATTRIBUTE
;
}
else
if
(
lastChar
=
=
=
"
:
"
)
{
this
.
#
state
=
this
.
States
.
PSEUDO_CLASS
;
}
else
if
(
lastChar
=
=
=
"
)
"
)
{
this
.
#
state
=
null
;
}
else
{
this
.
#
state
=
this
.
States
.
CLASS
;
}
}
break
;
case
this
.
States
.
ID
:
if
(
subQuery
.
match
(
/
[
#
]
+
[
^
#
]
*
/
)
[
0
]
.
length
>
2
)
{
if
(
lastChar
=
=
=
"
"
|
|
lastChar
=
=
=
"
>
"
)
{
this
.
#
state
=
this
.
States
.
TAG
;
}
else
if
(
lastChar
=
=
=
"
.
"
)
{
this
.
#
state
=
this
.
States
.
CLASS
;
}
else
if
(
lastChar
=
=
=
"
[
"
)
{
this
.
#
state
=
this
.
States
.
ATTRIBUTE
;
}
else
if
(
lastChar
=
=
=
"
:
"
)
{
this
.
#
state
=
this
.
States
.
PSEUDO_CLASS
;
}
else
if
(
lastChar
=
=
=
"
)
"
)
{
this
.
#
state
=
null
;
}
else
{
this
.
#
state
=
this
.
States
.
ID
;
}
}
break
;
case
this
.
States
.
ATTRIBUTE
:
if
(
subQuery
.
match
(
/
[
\
[
]
[
^
\
]
]
+
[
\
]
]
/
)
!
=
=
null
)
{
if
(
lastChar
=
=
=
"
"
|
|
lastChar
=
=
=
"
>
"
)
{
this
.
#
state
=
this
.
States
.
TAG
;
}
else
if
(
lastChar
=
=
=
"
.
"
)
{
this
.
#
state
=
this
.
States
.
CLASS
;
}
else
if
(
lastChar
=
=
=
"
#
"
)
{
this
.
#
state
=
this
.
States
.
ID
;
}
else
if
(
lastChar
=
=
=
"
:
"
)
{
this
.
#
state
=
this
.
States
.
PSEUDO_CLASS
;
}
else
if
(
lastChar
=
=
=
"
)
"
)
{
this
.
#
state
=
null
;
}
else
{
this
.
#
state
=
this
.
States
.
ATTRIBUTE
;
}
}
break
;
case
this
.
States
.
PSEUDO_CLASS
:
if
(
lastChar
=
=
=
"
:
"
&
&
secondLastChar
=
=
=
"
:
"
)
{
this
.
#
state
=
this
.
States
.
PSEUDO_ELEMENT
;
return
this
.
#
state
;
}
if
(
lastChar
=
=
=
"
(
"
)
{
this
.
#
state
=
null
;
}
else
if
(
lastChar
=
=
=
"
.
"
)
{
this
.
#
state
=
this
.
States
.
CLASS
;
}
else
if
(
lastChar
=
=
=
"
#
"
)
{
this
.
#
state
=
this
.
States
.
ID
;
}
else
{
this
.
#
state
=
this
.
States
.
PSEUDO_CLASS
;
}
break
;
}
}
return
this
.
#
state
;
}
destroy
(
)
{
this
.
searchBox
.
removeEventListener
(
"
input
"
this
.
showSuggestions
true
)
;
this
.
searchBox
.
removeEventListener
(
"
keypress
"
this
.
#
onSearchKeypress
true
)
;
this
.
searchPopup
.
destroy
(
)
;
this
.
searchPopup
=
null
;
this
.
searchBox
=
null
;
this
.
panelDoc
=
null
;
}
#
onSearchKeypress
=
event
=
>
{
const
popup
=
this
.
searchPopup
;
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_RETURN
:
case
KeyCodes
.
DOM_VK_TAB
:
if
(
popup
.
isOpen
)
{
if
(
popup
.
selectedItem
)
{
this
.
searchBox
.
value
=
popup
.
selectedItem
.
label
;
}
this
.
hidePopup
(
)
;
}
else
if
(
!
popup
.
isOpen
)
{
this
.
emitForTests
(
"
processing
-
done
"
)
;
return
;
}
break
;
case
KeyCodes
.
DOM_VK_UP
:
if
(
popup
.
isOpen
&
&
popup
.
itemCount
>
0
)
{
popup
.
selectPreviousItem
(
)
;
this
.
searchBox
.
value
=
popup
.
selectedItem
.
label
;
}
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
if
(
popup
.
isOpen
&
&
popup
.
itemCount
>
0
)
{
popup
.
selectNextItem
(
)
;
this
.
searchBox
.
value
=
popup
.
selectedItem
.
label
;
}
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
popup
.
isOpen
)
{
this
.
hidePopup
(
)
;
}
else
{
this
.
emitForTests
(
"
processing
-
done
"
)
;
return
;
}
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
emitForTests
(
"
processing
-
done
"
)
;
}
;
#
onSearchPopupClick
=
event
=
>
{
const
selectedItem
=
this
.
searchPopup
.
selectedItem
;
if
(
selectedItem
)
{
this
.
searchBox
.
value
=
selectedItem
.
label
;
}
this
.
hidePopup
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
;
#
showPopup
(
suggestions
popupState
)
{
let
total
=
0
;
const
query
=
this
.
searchBox
.
value
;
const
items
=
[
]
;
for
(
let
[
value
state
]
of
suggestions
)
{
if
(
popupState
=
=
=
this
.
States
.
PSEUDO_CLASS
)
{
value
=
query
.
substring
(
0
query
.
lastIndexOf
(
"
:
"
)
)
+
value
;
}
else
if
(
query
.
match
(
/
[
\
s
>
+
~
]
/
)
)
{
value
=
query
+
value
;
}
else
if
(
query
.
match
(
/
[
\
s
>
+
~
]
[
\
.
#
a
-
zA
-
Z
]
[
^
\
s
>
+
~
\
.
#
\
[
]
*
/
)
)
{
const
lastPart
=
query
.
match
(
/
[
\
s
>
+
~
]
[
\
.
#
a
-
zA
-
Z
]
[
^
\
s
>
+
~
\
.
#
\
[
]
*
/
)
[
0
]
;
value
=
query
.
slice
(
0
-
1
*
lastPart
.
length
+
1
)
+
value
;
}
else
if
(
query
.
match
(
/
[
a
-
zA
-
Z
]
[
#
\
.
]
[
^
#
\
.
\
s
+
>
~
]
*
/
)
)
{
const
lastPart
=
query
.
match
(
/
[
a
-
zA
-
Z
]
[
#
\
.
]
[
^
#
\
.
\
s
+
>
~
]
*
/
)
[
0
]
;
value
=
query
.
slice
(
0
-
1
*
lastPart
.
length
+
1
)
+
value
;
}
else
if
(
query
.
match
(
/
[
a
-
zA
-
Z
]
*
\
[
[
^
\
]
]
*
\
]
[
^
\
]
]
*
/
)
)
{
const
attrPart
=
query
.
substring
(
0
query
.
lastIndexOf
(
"
]
"
)
+
1
)
;
value
=
attrPart
+
value
;
}
const
item
=
{
preLabel
:
query
label
:
value
}
;
if
(
popupState
=
=
=
this
.
States
.
TAG
&
&
state
=
=
=
this
.
States
.
CLASS
)
{
item
.
preLabel
=
"
.
"
+
item
.
preLabel
;
}
if
(
popupState
=
=
=
this
.
States
.
TAG
&
&
state
=
=
=
this
.
States
.
ID
)
{
item
.
preLabel
=
"
#
"
+
item
.
preLabel
;
}
items
.
push
(
item
)
;
if
(
+
+
total
>
MAX_SUGGESTIONS
-
1
)
{
break
;
}
}
if
(
total
>
0
)
{
const
onPopupOpened
=
this
.
searchPopup
.
once
(
"
popup
-
opened
"
)
;
this
.
searchPopup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
this
.
searchPopup
.
setItems
(
items
)
;
const
xOffset
=
23
;
this
.
searchPopup
.
openPopup
(
this
.
searchBox
xOffset
)
;
}
)
;
this
.
searchPopup
.
hidePopup
(
)
;
return
onPopupOpened
;
}
return
this
.
hidePopup
(
)
;
}
hidePopup
(
)
{
const
onPopupClosed
=
this
.
searchPopup
.
once
(
"
popup
-
closed
"
)
;
this
.
searchPopup
.
hidePopup
(
)
;
return
onPopupClosed
;
}
async
showSuggestions
(
)
{
let
query
=
this
.
searchBox
.
value
;
const
originalQuery
=
this
.
searchBox
.
value
;
const
state
=
this
.
state
;
let
completing
=
"
"
;
if
(
!
query
|
|
query
.
endsWith
(
"
*
"
)
|
|
state
=
=
=
this
.
States
.
ATTRIBUTE
|
|
state
=
=
=
this
.
States
.
PSEUDO_ELEMENT
)
{
this
.
hidePopup
(
)
;
this
.
emitForTests
(
"
processing
-
done
"
{
query
:
originalQuery
}
)
;
return
;
}
if
(
state
=
=
=
this
.
States
.
TAG
)
{
const
matches
=
query
.
match
(
/
[
\
s
>
+
~
]
?
(
?
<
tag
>
[
a
-
zA
-
Z0
-
9_
-
]
*
)
/
)
;
completing
=
matches
.
groups
.
tag
;
query
=
query
.
slice
(
0
query
.
length
-
completing
.
length
)
;
}
else
if
(
state
=
=
=
this
.
States
.
CLASS
)
{
completing
=
query
.
match
(
/
\
.
(
[
^
\
.
]
*
)
/
)
[
1
]
;
query
=
query
.
slice
(
0
query
.
length
-
completing
.
length
-
1
)
;
}
else
if
(
state
=
=
=
this
.
States
.
ID
)
{
completing
=
query
.
match
(
/
#
(
[
^
#
]
*
)
/
)
[
1
]
;
query
=
query
.
slice
(
0
query
.
length
-
completing
.
length
-
1
)
;
}
else
if
(
state
=
=
=
this
.
States
.
PSEUDO_CLASS
)
{
completing
=
query
.
substring
(
query
.
lastIndexOf
(
"
:
"
)
+
1
)
;
query
=
"
"
;
}
if
(
/
[
\
s
+
>
~
]
/
.
test
(
query
)
)
{
query
+
=
"
*
"
;
}
let
suggestions
=
await
this
.
inspector
.
commands
.
inspectorCommand
.
getSuggestionsForQuery
(
query
completing
state
)
;
if
(
state
=
=
=
this
.
States
.
CLASS
)
{
completing
=
"
.
"
+
completing
;
}
else
if
(
state
=
=
=
this
.
States
.
ID
)
{
completing
=
"
#
"
+
completing
;
}
else
if
(
state
=
=
=
this
.
States
.
PSEUDO_CLASS
)
{
completing
=
"
:
"
+
completing
;
suggestions
=
suggestions
.
filter
(
suggestion
=
>
!
suggestion
[
0
]
.
startsWith
(
"
:
:
"
)
)
;
}
if
(
suggestions
.
length
=
=
=
1
&
&
suggestions
[
0
]
[
0
]
=
=
=
completing
)
{
suggestions
=
[
]
;
}
await
this
.
#
showPopup
(
suggestions
state
)
;
this
.
emitForTests
(
"
processing
-
done
"
{
query
:
originalQuery
}
)
;
}
}
exports
.
SelectorAutocompleter
=
SelectorAutocompleter
;
