"
use
strict
"
;
const
{
getSourceHash
getRuleHash
}
=
require
(
"
.
.
/
utils
/
changes
-
utils
"
)
;
const
{
RESET_CHANGES
TRACK_CHANGE
}
=
require
(
"
.
.
/
actions
/
index
"
)
;
function
cloneState
(
state
=
{
}
)
{
return
Object
.
entries
(
state
)
.
reduce
(
(
sources
[
sourceId
source
]
)
=
>
{
sources
[
sourceId
]
=
{
.
.
.
source
rules
:
Object
.
entries
(
source
.
rules
)
.
reduce
(
(
rules
[
ruleId
rule
]
)
=
>
{
rules
[
ruleId
]
=
{
.
.
.
rule
children
:
rule
.
children
.
slice
(
0
)
add
:
{
.
.
.
rule
.
add
}
remove
:
{
.
.
.
rule
.
remove
}
}
;
return
rules
;
}
{
}
)
}
;
return
sources
;
}
{
}
)
;
}
function
createRule
(
ruleData
rules
)
{
const
ruleAncestry
=
[
.
.
.
ruleData
.
ancestors
{
.
.
.
ruleData
}
]
;
return
ruleAncestry
.
map
(
(
rule
index
)
=
>
{
rule
.
ancestors
=
ruleAncestry
.
slice
(
0
index
)
;
if
(
!
rule
.
selector
)
{
rule
.
selector
=
{
rule
.
typeName
}
{
(
rule
.
conditionText
|
|
rule
.
name
|
|
rule
.
keyText
)
}
;
}
return
getRuleHash
(
rule
)
;
}
)
.
map
(
(
ruleId
index
array
)
=
>
{
const
{
selector
}
=
ruleAncestry
[
index
]
;
const
prevRuleId
=
array
[
index
-
1
]
;
const
nextRuleId
=
array
[
index
+
1
]
;
rules
[
ruleId
]
=
Object
.
assign
(
{
}
{
selector
children
:
[
]
}
rules
[
ruleId
]
)
;
if
(
nextRuleId
&
&
!
rules
[
ruleId
]
.
children
.
includes
(
nextRuleId
)
)
{
rules
[
ruleId
]
.
children
.
push
(
nextRuleId
)
;
}
if
(
prevRuleId
)
{
rules
[
ruleId
]
.
parent
=
prevRuleId
;
}
return
rules
[
ruleId
]
;
}
)
.
pop
(
)
;
}
function
removeRule
(
ruleId
rules
)
{
const
rule
=
rules
[
ruleId
]
;
if
(
rule
.
parent
&
&
rules
[
rule
.
parent
]
)
{
rules
[
rule
.
parent
]
.
children
=
rules
[
rule
.
parent
]
.
children
.
filter
(
childRuleId
=
>
{
return
childRuleId
!
=
=
ruleId
;
}
)
;
if
(
!
rules
[
rule
.
parent
]
.
children
.
length
)
{
removeRule
(
rule
.
parent
rules
)
;
}
}
delete
rules
[
ruleId
]
;
}
const
INITIAL_STATE
=
{
}
;
const
reducers
=
{
[
TRACK_CHANGE
]
(
state
{
change
}
)
{
const
defaults
=
{
selector
:
null
source
:
{
}
ancestors
:
[
]
add
:
{
}
remove
:
{
}
}
;
change
=
{
.
.
.
defaults
.
.
.
change
}
;
state
=
cloneState
(
state
)
;
const
{
type
href
index
}
=
change
.
source
;
const
{
selector
ancestors
ruleIndex
type
:
changeType
}
=
change
;
const
sourceId
=
getSourceHash
(
change
.
source
)
;
const
ruleId
=
getRuleHash
(
{
selector
ancestors
ruleIndex
}
)
;
const
hasAdd
=
!
!
change
.
add
;
const
hasRemove
=
!
!
change
.
remove
;
const
source
=
Object
.
assign
(
{
}
state
[
sourceId
]
{
type
href
index
}
)
;
const
rules
=
Object
.
assign
(
{
}
source
.
rules
)
;
let
rule
=
rules
[
ruleId
]
;
if
(
!
rule
)
{
rule
=
createRule
(
{
selector
ancestors
ruleIndex
}
rules
)
;
if
(
changeType
.
startsWith
(
"
rule
-
"
)
)
{
rule
.
changeType
=
changeType
;
}
}
const
add
=
Object
.
assign
(
{
}
rule
.
add
)
;
const
remove
=
Object
.
assign
(
{
}
rule
.
remove
)
;
if
(
hasRemove
)
{
Object
.
entries
(
change
.
remove
)
.
forEach
(
(
[
property
value
]
)
=
>
{
if
(
!
add
[
property
]
)
{
remove
[
property
]
=
value
;
}
if
(
add
[
property
]
=
=
=
value
)
{
delete
add
[
property
]
;
}
}
)
;
}
if
(
hasAdd
)
{
Object
.
entries
(
change
.
add
)
.
forEach
(
(
[
property
value
]
)
=
>
{
add
[
property
]
=
value
;
if
(
add
[
property
]
=
=
=
remove
[
property
]
)
{
delete
add
[
property
]
;
delete
remove
[
property
]
;
}
}
)
;
}
if
(
!
Object
.
keys
(
add
)
.
length
&
&
!
Object
.
keys
(
remove
)
.
length
)
{
removeRule
(
ruleId
rules
)
;
source
.
rules
=
{
.
.
.
rules
}
;
}
else
{
source
.
rules
=
{
.
.
.
rules
[
ruleId
]
:
{
.
.
.
rule
add
remove
}
}
;
}
if
(
!
Object
.
keys
(
source
.
rules
)
.
length
)
{
delete
state
[
sourceId
]
;
}
else
{
state
[
sourceId
]
=
source
;
}
return
state
;
}
[
RESET_CHANGES
]
(
state
)
{
return
INITIAL_STATE
;
}
}
;
module
.
exports
=
function
(
state
=
INITIAL_STATE
action
)
{
const
reducer
=
reducers
[
action
.
type
]
;
if
(
!
reducer
)
{
return
state
;
}
return
reducer
(
state
action
)
;
}
;
