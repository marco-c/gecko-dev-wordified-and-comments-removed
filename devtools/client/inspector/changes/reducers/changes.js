"
use
strict
"
;
const
{
getSourceHash
getRuleHash
}
=
require
(
"
.
.
/
utils
/
changes
-
utils
"
)
;
const
{
RESET_CHANGES
TRACK_CHANGE
}
=
require
(
"
.
.
/
actions
/
index
"
)
;
function
cloneState
(
state
=
{
}
)
{
return
Object
.
entries
(
state
)
.
reduce
(
(
sources
[
sourceId
source
]
)
=
>
{
sources
[
sourceId
]
=
{
.
.
.
source
rules
:
Object
.
entries
(
source
.
rules
)
.
reduce
(
(
rules
[
ruleId
rule
]
)
=
>
{
rules
[
ruleId
]
=
{
.
.
.
rule
children
:
rule
.
children
.
slice
(
0
)
add
:
rule
.
add
.
slice
(
0
)
remove
:
rule
.
remove
.
slice
(
0
)
}
;
return
rules
;
}
{
}
)
}
;
return
sources
;
}
{
}
)
;
}
function
createRule
(
ruleData
rules
)
{
const
ruleAncestry
=
[
.
.
.
ruleData
.
ancestors
{
.
.
.
ruleData
}
]
;
return
ruleAncestry
.
map
(
(
rule
index
)
=
>
{
rule
.
ancestors
=
ruleAncestry
.
slice
(
0
index
)
;
if
(
!
rule
.
selector
)
{
rule
.
selector
=
{
rule
.
typeName
}
{
(
rule
.
conditionText
|
|
rule
.
name
|
|
rule
.
keyText
)
}
;
}
return
getRuleHash
(
rule
)
;
}
)
.
map
(
(
ruleId
index
array
)
=
>
{
const
{
selector
}
=
ruleAncestry
[
index
]
;
const
prevRuleId
=
array
[
index
-
1
]
;
const
nextRuleId
=
array
[
index
+
1
]
;
const
defaults
=
{
selector
ruleId
add
:
[
]
remove
:
[
]
children
:
[
]
}
;
rules
[
ruleId
]
=
Object
.
assign
(
defaults
rules
[
ruleId
]
)
;
if
(
nextRuleId
&
&
!
rules
[
ruleId
]
.
children
.
includes
(
nextRuleId
)
)
{
rules
[
ruleId
]
.
children
.
push
(
nextRuleId
)
;
}
if
(
prevRuleId
)
{
rules
[
ruleId
]
.
parent
=
prevRuleId
;
}
return
rules
[
ruleId
]
;
}
)
.
pop
(
)
;
}
function
removeRule
(
ruleId
rules
)
{
const
rule
=
rules
[
ruleId
]
;
if
(
rule
.
parent
&
&
rules
[
rule
.
parent
]
)
{
rules
[
rule
.
parent
]
.
children
=
rules
[
rule
.
parent
]
.
children
.
filter
(
childRuleId
=
>
{
return
childRuleId
!
=
=
ruleId
;
}
)
;
if
(
!
rules
[
rule
.
parent
]
.
children
.
length
)
{
removeRule
(
rule
.
parent
rules
)
;
}
}
delete
rules
[
ruleId
]
;
}
const
INITIAL_STATE
=
{
}
;
const
reducers
=
{
[
TRACK_CHANGE
]
(
state
{
change
}
)
{
const
defaults
=
{
selector
:
null
source
:
{
}
ancestors
:
[
]
add
:
[
]
remove
:
[
]
}
;
change
=
{
.
.
.
defaults
.
.
.
change
}
;
state
=
cloneState
(
state
)
;
const
{
type
href
index
isFramed
}
=
change
.
source
;
const
{
selector
ancestors
ruleIndex
type
:
changeType
}
=
change
;
const
sourceId
=
getSourceHash
(
change
.
source
)
;
const
ruleId
=
getRuleHash
(
{
selector
ancestors
ruleIndex
}
)
;
const
source
=
Object
.
assign
(
{
}
state
[
sourceId
]
{
type
href
index
isFramed
}
)
;
const
rules
=
Object
.
assign
(
{
}
source
.
rules
)
;
let
rule
=
rules
[
ruleId
]
;
if
(
!
rule
)
{
rule
=
createRule
(
{
selector
ancestors
ruleIndex
}
rules
)
;
if
(
changeType
.
startsWith
(
"
rule
-
"
)
)
{
rule
.
changeType
=
changeType
;
}
}
if
(
change
.
remove
&
&
change
.
remove
.
length
)
{
for
(
const
decl
of
change
.
remove
)
{
const
addIndex
=
rule
.
add
.
findIndex
(
addDecl
=
>
{
return
addDecl
.
index
=
=
=
decl
.
index
&
&
addDecl
.
property
=
=
=
decl
.
property
&
&
addDecl
.
value
=
=
=
decl
.
value
;
}
)
;
const
removeIndex
=
rule
.
remove
.
findIndex
(
removeDecl
=
>
{
return
removeDecl
.
index
=
=
=
decl
.
index
&
&
removeDecl
.
property
=
=
=
decl
.
property
&
&
removeDecl
.
value
=
=
=
decl
.
value
;
}
)
;
if
(
addIndex
<
0
&
&
removeIndex
<
0
)
{
rule
.
remove
.
push
(
decl
)
;
}
if
(
rule
.
add
[
addIndex
]
)
{
rule
.
add
.
splice
(
addIndex
1
)
;
}
if
(
changeType
=
=
=
"
declaration
-
remove
"
)
{
rule
.
add
=
rule
.
add
.
map
(
(
addDecl
=
>
{
if
(
addDecl
.
index
>
decl
.
index
)
{
addDecl
.
index
-
-
;
}
return
addDecl
;
}
)
)
;
rule
.
remove
=
rule
.
remove
.
map
(
(
removeDecl
=
>
{
if
(
removeDecl
.
index
>
decl
.
index
)
{
removeDecl
.
index
-
-
;
}
return
removeDecl
;
}
)
)
;
}
}
}
if
(
change
.
add
&
&
change
.
add
.
length
)
{
for
(
const
decl
of
change
.
add
)
{
const
removeIndex
=
rule
.
remove
.
findIndex
(
removeDecl
=
>
{
return
removeDecl
.
index
=
=
=
decl
.
index
&
&
removeDecl
.
value
=
=
=
decl
.
value
&
&
removeDecl
.
property
=
=
=
decl
.
property
;
}
)
;
const
addIndex
=
rule
.
add
.
findIndex
(
addDecl
=
>
{
return
addDecl
.
index
=
=
=
decl
.
index
&
&
addDecl
.
property
=
=
=
decl
.
property
;
}
)
;
if
(
rule
.
remove
[
removeIndex
]
)
{
rule
.
remove
.
splice
(
removeIndex
1
)
;
}
else
if
(
rule
.
add
[
addIndex
]
)
{
rule
.
add
.
splice
(
addIndex
1
decl
)
;
}
else
{
rule
.
add
.
push
(
decl
)
;
}
}
}
if
(
!
rule
.
add
.
length
&
&
!
rule
.
remove
.
length
)
{
removeRule
(
ruleId
rules
)
;
source
.
rules
=
{
.
.
.
rules
}
;
}
else
{
source
.
rules
=
{
.
.
.
rules
[
ruleId
]
:
rule
}
;
}
if
(
!
Object
.
keys
(
source
.
rules
)
.
length
)
{
delete
state
[
sourceId
]
;
}
else
{
state
[
sourceId
]
=
source
;
}
return
state
;
}
[
RESET_CHANGES
]
(
state
)
{
return
INITIAL_STATE
;
}
}
;
module
.
exports
=
function
(
state
=
INITIAL_STATE
action
)
{
const
reducer
=
reducers
[
action
.
type
]
;
if
(
!
reducer
)
{
return
state
;
}
return
reducer
(
state
action
)
;
}
;
