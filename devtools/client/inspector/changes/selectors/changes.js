"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
getTabPrefs
"
"
devtools
/
shared
/
indentation
"
true
)
;
const
{
getSourceForDisplay
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
changes
/
utils
/
changes
-
utils
.
js
"
)
;
function
getChangesTree
(
state
filter
=
{
}
)
{
const
{
sourceIds
:
sourceIdsFilter
=
[
]
ruleIds
:
rulesIdsFilter
=
[
]
}
=
filter
;
function
expandRuleChildren
(
ruleId
rule
rules
visitedRules
)
{
if
(
visitedRules
.
has
(
ruleId
)
)
{
return
null
;
}
visitedRules
.
add
(
ruleId
)
;
return
{
.
.
.
rule
children
:
rule
.
children
.
map
(
childRuleId
=
>
expandRuleChildren
(
childRuleId
rules
[
childRuleId
]
rules
visitedRules
)
)
}
;
}
return
Object
.
entries
(
state
)
.
filter
(
(
[
sourceId
source
]
)
=
>
{
if
(
sourceIdsFilter
.
length
)
{
return
sourceIdsFilter
.
includes
(
sourceId
)
;
}
return
true
;
}
)
.
reduce
(
(
sourcesObj
[
sourceId
source
]
)
=
>
{
const
{
rules
}
=
source
;
const
visitedRules
=
new
Set
(
)
;
sourcesObj
[
sourceId
]
=
{
.
.
.
source
rules
:
Object
.
entries
(
rules
)
.
filter
(
(
[
ruleId
rule
]
)
=
>
{
if
(
rulesIdsFilter
.
length
)
{
return
rulesIdsFilter
.
includes
(
ruleId
)
;
}
return
true
;
}
)
.
reduce
(
(
rulesObj
[
ruleId
rule
]
)
=
>
{
const
expandedRule
=
expandRuleChildren
(
ruleId
rule
rules
visitedRules
)
;
if
(
expandedRule
!
=
=
null
)
{
rulesObj
[
ruleId
]
=
expandedRule
;
}
return
rulesObj
;
}
{
}
)
}
;
return
sourcesObj
;
}
{
}
)
;
}
function
getChangesStylesheet
(
state
filter
)
{
const
changeTree
=
getChangesTree
(
state
filter
)
;
const
{
indentUnit
indentWithTabs
}
=
getTabPrefs
(
)
;
const
indentChar
=
indentWithTabs
?
"
\
t
"
.
repeat
(
indentUnit
)
:
"
"
.
repeat
(
indentUnit
)
;
function
writeSelector
(
selectors
=
[
]
level
)
{
const
indent
=
indentChar
.
repeat
(
level
)
;
let
selectorText
;
switch
(
selectors
.
length
)
{
case
0
:
selectorText
=
"
"
;
break
;
case
1
:
selectorText
=
{
indent
}
{
selectors
[
0
]
}
;
break
;
default
:
selectorText
=
{
indent
}
/
*
{
selectors
[
0
]
}
{
*
/
\
n
+
{
indent
}
{
selectors
[
selectors
.
length
-
1
]
}
;
}
return
selectorText
;
}
function
writeRule
(
ruleId
rule
level
)
{
let
ruleBody
=
rule
.
children
.
reduce
(
(
str
childRule
)
=
>
{
str
+
=
writeRule
(
childRule
.
ruleId
childRule
level
+
1
)
;
return
str
;
}
"
"
)
;
ruleBody
+
=
writeDeclarations
(
rule
.
remove
rule
.
add
level
+
1
)
;
const
indent
=
indentChar
.
repeat
(
level
)
;
const
selectorText
=
writeSelector
(
rule
.
selectors
level
)
;
return
\
n
{
selectorText
}
{
{
ruleBody
}
\
n
{
indent
}
}
;
}
function
writeDeclarations
(
remove
=
[
]
add
=
[
]
level
)
{
const
indent
=
indentChar
.
repeat
(
level
)
;
const
removals
=
remove
.
sort
(
(
a
b
)
=
>
a
.
index
>
b
.
index
)
.
reduce
(
(
str
{
property
value
}
)
=
>
{
str
+
=
\
n
{
indent
}
/
*
{
property
}
:
{
value
}
;
*
/
;
return
str
;
}
"
"
)
;
const
additions
=
add
.
sort
(
(
a
b
)
=
>
a
.
index
>
b
.
index
)
.
reduce
(
(
str
{
property
value
}
)
=
>
{
str
+
=
\
n
{
indent
}
{
property
}
:
{
value
}
;
;
return
str
;
}
"
"
)
;
return
removals
+
additions
;
}
return
Object
.
entries
(
changeTree
)
.
reduce
(
(
stylesheetText
[
sourceId
source
]
)
=
>
{
const
{
href
rules
}
=
source
;
stylesheetText
+
=
\
n
/
*
{
getSourceForDisplay
(
source
)
}
|
{
href
}
*
/
\
n
;
stylesheetText
+
=
Object
.
entries
(
rules
)
.
reduce
(
(
str
[
ruleId
rule
]
)
=
>
{
str
+
=
writeRule
(
ruleId
rule
0
)
+
"
\
n
"
;
return
str
;
}
"
"
)
;
return
stylesheetText
;
}
"
"
)
;
}
module
.
exports
=
{
getChangesTree
getChangesStylesheet
}
;
