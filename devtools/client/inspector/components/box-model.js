"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
InplaceEditor
editableItem
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
ReflowFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
layout
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
getCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
STRINGS_URI
=
"
devtools
/
client
/
locales
/
shared
.
properties
"
;
const
STRINGS_INSPECTOR
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
SHARED_L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
STRINGS_INSPECTOR
)
;
const
NUMERIC
=
/
^
-
?
[
\
d
\
.
]
+
/
;
const
LONG_TEXT_ROTATE_LIMIT
=
3
;
function
EditingSession
(
{
inspector
doc
elementRules
}
)
{
this
.
_doc
=
doc
;
this
.
_rules
=
elementRules
;
this
.
_modifications
=
new
Map
(
)
;
this
.
_cssProperties
=
getCssProperties
(
inspector
.
toolbox
)
;
}
EditingSession
.
prototype
=
{
getPropertyFromRule
:
function
(
rule
property
)
{
let
index
=
this
.
getPropertyIndex
(
property
rule
)
;
if
(
index
!
=
=
-
1
)
{
return
rule
.
declarations
[
index
]
.
value
;
}
let
dummyStyle
=
this
.
_element
.
style
;
dummyStyle
.
cssText
=
rule
.
cssText
;
return
dummyStyle
.
getPropertyValue
(
property
)
;
}
getProperty
:
function
(
property
)
{
let
div
=
this
.
_doc
.
createElement
(
"
div
"
)
;
div
.
setAttribute
(
"
style
"
"
display
:
none
"
)
;
this
.
_doc
.
getElementById
(
"
sidebar
-
panel
-
computedview
"
)
.
appendChild
(
div
)
;
this
.
_element
=
this
.
_doc
.
createElement
(
"
p
"
)
;
div
.
appendChild
(
this
.
_element
)
;
for
(
let
rule
of
this
.
_rules
)
{
let
value
=
this
.
getPropertyFromRule
(
rule
property
)
;
if
(
value
!
=
=
"
"
)
{
div
.
remove
(
)
;
return
value
;
}
}
div
.
remove
(
)
;
return
"
"
;
}
getPropertyIndex
:
function
(
name
rule
=
this
.
_rules
[
0
]
)
{
let
elementStyleRule
=
this
.
_rules
[
0
]
;
if
(
!
elementStyleRule
.
declarations
.
length
)
{
return
-
1
;
}
return
elementStyleRule
.
declarations
.
findIndex
(
p
=
>
p
.
name
=
=
=
name
)
;
}
setProperties
:
Task
.
async
(
function
*
(
properties
)
{
for
(
let
property
of
properties
)
{
let
modifications
=
this
.
_rules
[
0
]
.
startModifyingProperties
(
this
.
_cssProperties
)
;
if
(
!
this
.
_modifications
.
has
(
property
.
name
)
)
{
this
.
_modifications
.
set
(
property
.
name
this
.
getPropertyFromRule
(
this
.
_rules
[
0
]
property
.
name
)
)
;
}
let
index
=
this
.
getPropertyIndex
(
property
.
name
)
;
if
(
index
=
=
=
-
1
)
{
index
=
this
.
_rules
[
0
]
.
declarations
.
length
;
}
if
(
property
.
value
=
=
"
"
)
{
modifications
.
removeProperty
(
index
property
.
name
)
;
}
else
{
modifications
.
setProperty
(
index
property
.
name
property
.
value
"
"
)
;
}
yield
modifications
.
apply
(
)
;
}
}
)
revert
:
Task
.
async
(
function
*
(
)
{
for
(
let
[
property
value
]
of
this
.
_modifications
)
{
let
modifications
=
this
.
_rules
[
0
]
.
startModifyingProperties
(
this
.
_cssProperties
)
;
let
index
=
this
.
getPropertyIndex
(
property
)
;
if
(
value
!
=
"
"
)
{
if
(
index
=
=
=
-
1
)
{
index
=
0
;
}
modifications
.
setProperty
(
index
property
value
"
"
)
;
}
else
{
if
(
index
=
=
=
-
1
)
{
continue
;
}
modifications
.
removeProperty
(
index
property
)
;
}
yield
modifications
.
apply
(
)
;
}
}
)
destroy
:
function
(
)
{
this
.
_doc
=
null
;
this
.
_rules
=
null
;
this
.
_modifications
.
clear
(
)
;
}
}
;
function
BoxModelView
(
inspector
document
)
{
this
.
inspector
=
inspector
;
this
.
doc
=
document
;
this
.
wrapper
=
this
.
doc
.
getElementById
(
"
boxmodel
-
wrapper
"
)
;
this
.
container
=
this
.
doc
.
getElementById
(
"
boxmodel
-
container
"
)
;
this
.
expander
=
this
.
doc
.
getElementById
(
"
boxmodel
-
expander
"
)
;
this
.
sizeLabel
=
this
.
doc
.
querySelector
(
"
.
boxmodel
-
size
>
span
"
)
;
this
.
sizeHeadingLabel
=
this
.
doc
.
getElementById
(
"
boxmodel
-
element
-
size
"
)
;
this
.
_geometryEditorHighlighter
=
null
;
this
.
_cssProperties
=
getCssProperties
(
inspector
.
toolbox
)
;
this
.
init
(
)
;
}
BoxModelView
.
prototype
=
{
init
:
function
(
)
{
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
onNewNode
=
this
.
onNewNode
.
bind
(
this
)
;
this
.
inspector
.
sidebar
.
on
(
"
computedview
-
selected
"
this
.
onNewNode
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
inspector
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
onToggleExpander
=
this
.
onToggleExpander
.
bind
(
this
)
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
onToggleExpander
)
;
let
header
=
this
.
doc
.
getElementById
(
"
boxmodel
-
header
"
)
;
header
.
addEventListener
(
"
dblclick
"
this
.
onToggleExpander
)
;
this
.
onFilterComputedView
=
this
.
onFilterComputedView
.
bind
(
this
)
;
this
.
inspector
.
on
(
"
computed
-
view
-
filtered
"
this
.
onFilterComputedView
)
;
this
.
onPickerStarted
=
this
.
onPickerStarted
.
bind
(
this
)
;
this
.
onMarkupViewLeave
=
this
.
onMarkupViewLeave
.
bind
(
this
)
;
this
.
onMarkupViewNodeHover
=
this
.
onMarkupViewNodeHover
.
bind
(
this
)
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
initBoxModelHighlighter
(
)
;
this
.
map
=
{
position
:
{
selector
:
"
#
boxmodel
-
element
-
position
"
property
:
"
position
"
value
:
undefined
}
marginTop
:
{
selector
:
"
.
boxmodel
-
margin
.
boxmodel
-
top
>
span
"
property
:
"
margin
-
top
"
value
:
undefined
}
marginBottom
:
{
selector
:
"
.
boxmodel
-
margin
.
boxmodel
-
bottom
>
span
"
property
:
"
margin
-
bottom
"
value
:
undefined
}
marginLeft
:
{
selector
:
"
.
boxmodel
-
margin
.
boxmodel
-
left
>
span
"
property
:
"
margin
-
left
"
value
:
undefined
}
marginRight
:
{
selector
:
"
.
boxmodel
-
margin
.
boxmodel
-
right
>
span
"
property
:
"
margin
-
right
"
value
:
undefined
}
paddingTop
:
{
selector
:
"
.
boxmodel
-
padding
.
boxmodel
-
top
>
span
"
property
:
"
padding
-
top
"
value
:
undefined
}
paddingBottom
:
{
selector
:
"
.
boxmodel
-
padding
.
boxmodel
-
bottom
>
span
"
property
:
"
padding
-
bottom
"
value
:
undefined
}
paddingLeft
:
{
selector
:
"
.
boxmodel
-
padding
.
boxmodel
-
left
>
span
"
property
:
"
padding
-
left
"
value
:
undefined
}
paddingRight
:
{
selector
:
"
.
boxmodel
-
padding
.
boxmodel
-
right
>
span
"
property
:
"
padding
-
right
"
value
:
undefined
}
borderTop
:
{
selector
:
"
.
boxmodel
-
border
.
boxmodel
-
top
>
span
"
property
:
"
border
-
top
-
width
"
value
:
undefined
}
borderBottom
:
{
selector
:
"
.
boxmodel
-
border
.
boxmodel
-
bottom
>
span
"
property
:
"
border
-
bottom
-
width
"
value
:
undefined
}
borderLeft
:
{
selector
:
"
.
boxmodel
-
border
.
boxmodel
-
left
>
span
"
property
:
"
border
-
left
-
width
"
value
:
undefined
}
borderRight
:
{
selector
:
"
.
boxmodel
-
border
.
boxmodel
-
right
>
span
"
property
:
"
border
-
right
-
width
"
value
:
undefined
}
}
;
for
(
let
i
in
this
.
map
)
{
if
(
i
=
=
"
position
"
)
{
continue
;
}
let
dimension
=
this
.
map
[
i
]
;
editableItem
(
{
element
:
this
.
doc
.
querySelector
(
dimension
.
selector
)
}
(
element
event
)
=
>
{
this
.
initEditor
(
element
event
dimension
)
;
}
)
;
}
this
.
onNewNode
(
)
;
let
nodeGeometry
=
this
.
doc
.
getElementById
(
"
layout
-
geometry
-
editor
"
)
;
this
.
onGeometryButtonClick
=
this
.
onGeometryButtonClick
.
bind
(
this
)
;
nodeGeometry
.
addEventListener
(
"
click
"
this
.
onGeometryButtonClick
)
;
}
initBoxModelHighlighter
:
function
(
)
{
let
highlightElts
=
this
.
doc
.
querySelectorAll
(
"
#
boxmodel
-
container
*
[
title
]
"
)
;
this
.
onHighlightMouseOver
=
this
.
onHighlightMouseOver
.
bind
(
this
)
;
this
.
onHighlightMouseOut
=
this
.
onHighlightMouseOut
.
bind
(
this
)
;
for
(
let
element
of
highlightElts
)
{
element
.
addEventListener
(
"
mouseover
"
this
.
onHighlightMouseOver
true
)
;
element
.
addEventListener
(
"
mouseout
"
this
.
onHighlightMouseOut
true
)
;
}
}
trackReflows
:
function
(
)
{
if
(
!
this
.
reflowFront
)
{
let
{
target
}
=
this
.
inspector
;
if
(
target
.
form
.
reflowActor
)
{
this
.
reflowFront
=
ReflowFront
(
target
.
client
target
.
form
)
;
}
else
{
return
;
}
}
this
.
reflowFront
.
on
(
"
reflows
"
this
.
update
)
;
this
.
reflowFront
.
start
(
)
;
}
untrackReflows
:
function
(
)
{
if
(
!
this
.
reflowFront
)
{
return
;
}
this
.
reflowFront
.
off
(
"
reflows
"
this
.
update
)
;
this
.
reflowFront
.
stop
(
)
;
}
initEditor
:
function
(
element
event
dimension
)
{
let
{
property
}
=
dimension
;
let
session
=
new
EditingSession
(
this
)
;
let
initialValue
=
session
.
getProperty
(
property
)
;
let
editor
=
new
InplaceEditor
(
{
element
:
element
initial
:
initialValue
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
{
name
:
dimension
.
property
}
start
:
self
=
>
{
self
.
elt
.
parentNode
.
classList
.
add
(
"
boxmodel
-
editing
"
)
;
}
change
:
value
=
>
{
if
(
NUMERIC
.
test
(
value
)
)
{
value
+
=
"
px
"
;
}
let
properties
=
[
{
name
:
property
value
:
value
}
]
;
if
(
property
.
substring
(
0
7
)
=
=
"
border
-
"
)
{
let
bprop
=
property
.
substring
(
0
property
.
length
-
5
)
+
"
style
"
;
let
style
=
session
.
getProperty
(
bprop
)
;
if
(
!
style
|
|
style
=
=
"
none
"
|
|
style
=
=
"
hidden
"
)
{
properties
.
push
(
{
name
:
bprop
value
:
"
solid
"
}
)
;
}
}
session
.
setProperties
(
properties
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
done
:
(
value
commit
)
=
>
{
editor
.
elt
.
parentNode
.
classList
.
remove
(
"
boxmodel
-
editing
"
)
;
if
(
!
commit
)
{
session
.
revert
(
)
.
then
(
(
)
=
>
{
session
.
destroy
(
)
;
}
e
=
>
console
.
error
(
e
)
)
;
}
}
contextMenu
:
this
.
inspector
.
onTextBoxContextMenu
cssProperties
:
this
.
_cssProperties
}
event
)
;
}
isViewVisible
:
function
(
)
{
return
this
.
inspector
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
"
computedview
"
;
}
isViewVisibleAndNodeValid
:
function
(
)
{
return
this
.
isViewVisible
(
)
&
&
this
.
inspector
.
selection
.
isConnected
(
)
&
&
this
.
inspector
.
selection
.
isElementNode
(
)
;
}
destroy
:
function
(
)
{
let
highlightElts
=
this
.
doc
.
querySelectorAll
(
"
#
boxmodel
-
container
*
[
title
]
"
)
;
for
(
let
element
of
highlightElts
)
{
element
.
removeEventListener
(
"
mouseover
"
this
.
onHighlightMouseOver
true
)
;
element
.
removeEventListener
(
"
mouseout
"
this
.
onHighlightMouseOut
true
)
;
}
this
.
expander
.
removeEventListener
(
"
click
"
this
.
onToggleExpander
)
;
let
header
=
this
.
doc
.
getElementById
(
"
boxmodel
-
header
"
)
;
header
.
removeEventListener
(
"
dblclick
"
this
.
onToggleExpander
)
;
let
nodeGeometry
=
this
.
doc
.
getElementById
(
"
layout
-
geometry
-
editor
"
)
;
nodeGeometry
.
removeEventListener
(
"
click
"
this
.
onGeometryButtonClick
)
;
this
.
inspector
.
off
(
"
picker
-
started
"
this
.
onPickerStarted
)
;
if
(
this
.
inspector
.
markup
)
{
this
.
inspector
.
markup
.
off
(
"
leave
"
this
.
onMarkupViewLeave
)
;
this
.
inspector
.
markup
.
off
(
"
node
-
hover
"
this
.
onMarkupViewNodeHover
)
;
}
this
.
inspector
.
sidebar
.
off
(
"
computedview
-
selected
"
this
.
onNewNode
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
inspector
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
inspector
.
target
.
off
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
this
.
inspector
.
off
(
"
computed
-
view
-
filtered
"
this
.
onFilterComputedView
)
;
this
.
inspector
=
null
;
this
.
doc
=
null
;
this
.
wrapper
=
null
;
this
.
container
=
null
;
this
.
expander
=
null
;
this
.
sizeLabel
=
null
;
this
.
sizeHeadingLabel
=
null
;
if
(
this
.
reflowFront
)
{
this
.
untrackReflows
(
)
;
this
.
reflowFront
.
destroy
(
)
;
this
.
reflowFront
=
null
;
}
}
onSidebarSelect
:
function
(
e
sidebar
)
{
this
.
setActive
(
sidebar
=
=
=
"
computedview
"
)
;
}
onNewSelection
:
function
(
)
{
let
done
=
this
.
inspector
.
updating
(
"
computed
-
view
"
)
;
this
.
onNewNode
(
)
.
then
(
(
)
=
>
this
.
hideGeometryEditor
(
)
)
.
then
(
done
(
err
)
=
>
{
console
.
error
(
err
)
;
done
(
)
;
}
)
.
catch
(
console
.
error
)
;
}
onNewNode
:
function
(
)
{
this
.
setActive
(
this
.
isViewVisibleAndNodeValid
(
)
)
;
return
this
.
update
(
)
;
}
onHighlightMouseOver
:
function
(
e
)
{
let
region
=
e
.
target
.
getAttribute
(
"
data
-
box
"
)
;
if
(
!
region
)
{
return
;
}
this
.
showBoxModel
(
{
region
showOnly
:
region
onlyRegionArea
:
true
}
)
;
}
onHighlightMouseOut
:
function
(
)
{
this
.
hideBoxModel
(
)
;
}
onGeometryButtonClick
:
function
(
{
target
}
)
{
if
(
target
.
hasAttribute
(
"
checked
"
)
)
{
target
.
removeAttribute
(
"
checked
"
)
;
this
.
hideGeometryEditor
(
)
;
}
else
{
target
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
showGeometryEditor
(
)
;
}
}
onPickerStarted
:
function
(
)
{
this
.
hideGeometryEditor
(
)
;
}
onToggleExpander
:
function
(
)
{
let
isOpen
=
this
.
expander
.
hasAttribute
(
"
open
"
)
;
if
(
isOpen
)
{
this
.
container
.
hidden
=
true
;
this
.
expander
.
removeAttribute
(
"
open
"
)
;
}
else
{
this
.
container
.
hidden
=
false
;
this
.
expander
.
setAttribute
(
"
open
"
"
"
)
;
}
}
onMarkupViewLeave
:
function
(
)
{
this
.
showGeometryEditor
(
true
)
;
}
onMarkupViewNodeHover
:
function
(
)
{
this
.
hideGeometryEditor
(
false
)
;
}
onWillNavigate
:
function
(
)
{
this
.
_geometryEditorHighlighter
.
release
(
)
.
catch
(
console
.
error
)
;
this
.
_geometryEditorHighlighter
=
null
;
}
onFilterComputedView
:
function
(
reason
hidden
)
{
this
.
wrapper
.
hidden
=
hidden
;
}
setActive
:
function
(
isActive
)
{
if
(
isActive
=
=
=
this
.
isActive
)
{
return
;
}
this
.
isActive
=
isActive
;
if
(
isActive
)
{
this
.
trackReflows
(
)
;
}
else
{
this
.
untrackReflows
(
)
;
}
}
update
:
function
(
)
{
let
lastRequest
=
Task
.
spawn
(
(
function
*
(
)
{
if
(
!
this
.
isViewVisibleAndNodeValid
(
)
)
{
this
.
wrapper
.
hidden
=
true
;
this
.
inspector
.
emit
(
"
boxmodel
-
view
-
updated
"
)
;
return
null
;
}
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
layout
=
yield
this
.
inspector
.
pageStyle
.
getLayout
(
node
{
autoMargins
:
this
.
isActive
}
)
;
let
styleEntries
=
yield
this
.
inspector
.
pageStyle
.
getApplied
(
node
{
}
)
;
yield
this
.
updateGeometryButton
(
)
;
if
(
this
.
_lastRequest
!
=
lastRequest
)
{
return
this
.
_lastRequest
;
}
this
.
_lastRequest
=
null
;
let
width
=
layout
.
width
;
let
height
=
layout
.
height
;
let
newLabel
=
SHARED_L10N
.
getFormatStr
(
"
dimensions
"
width
height
)
;
if
(
this
.
sizeHeadingLabel
.
textContent
!
=
newLabel
)
{
this
.
sizeHeadingLabel
.
textContent
=
newLabel
;
}
for
(
let
i
in
this
.
map
)
{
let
property
=
this
.
map
[
i
]
.
property
;
if
(
!
(
property
in
layout
)
)
{
continue
;
}
let
parsedValue
=
parseFloat
(
layout
[
property
]
)
;
if
(
Number
.
isNaN
(
parsedValue
)
)
{
this
.
map
[
i
]
.
value
=
layout
[
property
]
;
}
else
{
this
.
map
[
i
]
.
value
=
parsedValue
;
}
}
let
margins
=
layout
.
autoMargins
;
if
(
"
top
"
in
margins
)
{
this
.
map
.
marginTop
.
value
=
"
auto
"
;
}
if
(
"
right
"
in
margins
)
{
this
.
map
.
marginRight
.
value
=
"
auto
"
;
}
if
(
"
bottom
"
in
margins
)
{
this
.
map
.
marginBottom
.
value
=
"
auto
"
;
}
if
(
"
left
"
in
margins
)
{
this
.
map
.
marginLeft
.
value
=
"
auto
"
;
}
for
(
let
i
in
this
.
map
)
{
let
selector
=
this
.
map
[
i
]
.
selector
;
let
span
=
this
.
doc
.
querySelector
(
selector
)
;
this
.
updateSourceRuleTooltip
(
span
this
.
map
[
i
]
.
property
styleEntries
)
;
if
(
span
.
textContent
.
length
>
0
&
&
span
.
textContent
=
=
this
.
map
[
i
]
.
value
)
{
continue
;
}
span
.
textContent
=
this
.
map
[
i
]
.
value
;
this
.
manageOverflowingText
(
span
)
;
}
width
-
=
this
.
map
.
borderLeft
.
value
+
this
.
map
.
borderRight
.
value
+
this
.
map
.
paddingLeft
.
value
+
this
.
map
.
paddingRight
.
value
;
width
=
parseFloat
(
width
.
toPrecision
(
6
)
)
;
height
-
=
this
.
map
.
borderTop
.
value
+
this
.
map
.
borderBottom
.
value
+
this
.
map
.
paddingTop
.
value
+
this
.
map
.
paddingBottom
.
value
;
height
=
parseFloat
(
height
.
toPrecision
(
6
)
)
;
let
newValue
=
width
+
"
\
u00D7
"
+
height
;
if
(
this
.
sizeLabel
.
textContent
!
=
newValue
)
{
this
.
sizeLabel
.
textContent
=
newValue
;
}
this
.
elementRules
=
styleEntries
.
map
(
e
=
>
e
.
rule
)
;
this
.
wrapper
.
hidden
=
false
;
this
.
inspector
.
emit
(
"
boxmodel
-
view
-
updated
"
)
;
return
null
;
}
)
.
bind
(
this
)
)
.
catch
(
console
.
error
)
;
this
.
_lastRequest
=
lastRequest
;
return
this
.
_lastRequest
;
}
updateSourceRuleTooltip
:
function
(
el
property
rules
)
{
let
dummyEl
=
this
.
doc
.
createElement
(
"
div
"
)
;
let
sourceRule
value
;
for
(
let
{
rule
}
of
rules
)
{
dummyEl
.
style
.
cssText
=
rule
.
cssText
;
value
=
dummyEl
.
style
.
getPropertyValue
(
property
)
;
if
(
value
!
=
=
"
"
)
{
sourceRule
=
rule
;
break
;
}
}
let
title
=
property
;
if
(
sourceRule
&
&
sourceRule
.
selectors
)
{
title
+
=
"
\
n
"
+
sourceRule
.
selectors
.
join
(
"
"
)
;
}
if
(
sourceRule
&
&
sourceRule
.
parentStyleSheet
)
{
if
(
sourceRule
.
parentStyleSheet
.
href
)
{
title
+
=
"
\
n
"
+
sourceRule
.
parentStyleSheet
.
href
+
"
:
"
+
sourceRule
.
line
;
}
else
{
title
+
=
"
\
n
"
+
INSPECTOR_L10N
.
getStr
(
"
rule
.
sourceInline
"
)
+
"
:
"
+
sourceRule
.
line
;
}
}
el
.
setAttribute
(
"
title
"
title
)
;
}
showBoxModel
:
function
(
options
=
{
}
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
let
nodeFront
=
this
.
inspector
.
selection
.
nodeFront
;
toolbox
.
highlighterUtils
.
highlightNodeFront
(
nodeFront
options
)
;
}
hideBoxModel
:
function
(
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
toolbox
.
highlighterUtils
.
unhighlight
(
)
;
}
showGeometryEditor
:
function
(
showOnlyIfActive
=
false
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
let
nodeFront
=
this
.
inspector
.
selection
.
nodeFront
;
let
nodeGeometry
=
this
.
doc
.
getElementById
(
"
layout
-
geometry
-
editor
"
)
;
let
isActive
=
nodeGeometry
.
hasAttribute
(
"
checked
"
)
;
if
(
showOnlyIfActive
&
&
!
isActive
)
{
return
;
}
if
(
this
.
_geometryEditorHighlighter
)
{
this
.
_geometryEditorHighlighter
.
show
(
nodeFront
)
.
catch
(
console
.
error
)
;
return
;
}
toolbox
.
highlighterUtils
.
getHighlighterByType
(
"
GeometryEditorHighlighter
"
)
.
then
(
highlighter
=
>
{
highlighter
.
show
(
nodeFront
)
.
catch
(
console
.
error
)
;
this
.
_geometryEditorHighlighter
=
highlighter
;
toolbox
.
on
(
"
picker
-
started
"
this
.
onPickerStarted
)
;
this
.
inspector
.
markup
.
on
(
"
leave
"
this
.
onMarkupViewLeave
)
;
this
.
inspector
.
markup
.
on
(
"
node
-
hover
"
this
.
onMarkupViewNodeHover
)
;
this
.
inspector
.
target
.
once
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
}
)
;
}
hideGeometryEditor
:
function
(
updateButton
=
true
)
{
if
(
this
.
_geometryEditorHighlighter
)
{
this
.
_geometryEditorHighlighter
.
hide
(
)
.
catch
(
console
.
error
)
;
}
if
(
updateButton
)
{
let
nodeGeometry
=
this
.
doc
.
getElementById
(
"
layout
-
geometry
-
editor
"
)
;
nodeGeometry
.
removeAttribute
(
"
checked
"
)
;
}
}
updateGeometryButton
:
Task
.
async
(
function
*
(
)
{
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
isEditable
=
false
;
if
(
node
)
{
isEditable
=
yield
this
.
inspector
.
pageStyle
.
isPositionEditable
(
node
)
;
}
let
nodeGeometry
=
this
.
doc
.
getElementById
(
"
layout
-
geometry
-
editor
"
)
;
nodeGeometry
.
style
.
visibility
=
isEditable
?
"
visible
"
:
"
hidden
"
;
}
)
manageOverflowingText
:
function
(
span
)
{
let
classList
=
span
.
parentNode
.
classList
;
if
(
classList
.
contains
(
"
boxmodel
-
left
"
)
|
|
classList
.
contains
(
"
boxmodel
-
right
"
)
)
{
let
force
=
span
.
textContent
.
length
>
LONG_TEXT_ROTATE_LIMIT
;
classList
.
toggle
(
"
boxmodel
-
rotate
"
force
)
;
}
}
}
;
exports
.
BoxModelView
=
BoxModelView
;
