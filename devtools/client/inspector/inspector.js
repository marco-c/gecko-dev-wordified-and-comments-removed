"
use
strict
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
flags
=
require
(
"
resource
:
/
/
devtools
/
shared
/
flags
.
js
"
)
;
const
{
executeSoon
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
Toolbox
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
.
js
"
)
;
const
createStore
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
store
.
js
"
)
;
const
InspectorStyleChangeTracker
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
style
-
change
-
tracker
.
js
"
)
;
const
{
PrefObserver
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
prefs
.
js
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
const
osString
=
Services
.
appinfo
.
OS
;
loader
.
lazyRequireGetter
(
this
"
HTMLBreadcrumbs
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
breadcrumbs
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorSearch
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
inspector
-
search
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
toolsidebar
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
MarkupView
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
markup
/
markup
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
HighlightersOverlay
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
highlighters
-
overlay
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
PICKER_TYPES
"
"
resource
:
/
/
devtools
/
shared
/
picker
-
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
captureAndSaveScreenshot
"
"
resource
:
/
/
devtools
/
client
/
shared
/
screenshot
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
debounce
"
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
true
)
;
const
{
LocalizationHelper
localizeMarkup
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
{
FluentL10n
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
fluent
-
l10n
/
fluent
-
l10n
.
js
"
)
;
const
INITIAL_SIDEBAR_SIZE
=
350
;
const
LAZY_RESIZE_INTERVAL_MS
=
200
;
const
PORTRAIT_MODE_WIDTH_THRESHOLD
=
700
;
const
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
=
1000
;
const
THREE_PANE_ENABLED_PREF
=
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
;
const
THREE_PANE_CHROME_ENABLED_PREF
=
"
devtools
.
inspector
.
chrome
.
three
-
pane
-
enabled
"
;
const
DEFAULT_COLOR_UNIT_PREF
=
"
devtools
.
defaultColorUnit
"
;
class
Inspector
extends
EventEmitter
{
constructor
(
toolbox
commands
win
)
{
super
(
)
;
this
.
#
toolbox
=
toolbox
;
this
.
#
commands
=
commands
;
this
.
panelDoc
=
win
.
document
;
this
.
panelWin
=
win
;
this
.
panelWin
.
inspector
=
this
;
this
.
telemetry
=
toolbox
.
telemetry
;
this
.
store
=
createStore
(
this
)
;
this
.
onResourceAvailable
=
this
.
onResourceAvailable
.
bind
(
this
)
;
this
.
onRootNodeAvailable
=
this
.
onRootNodeAvailable
.
bind
(
this
)
;
this
.
onPickerCanceled
=
this
.
onPickerCanceled
.
bind
(
this
)
;
this
.
onPickerHovered
=
this
.
onPickerHovered
.
bind
(
this
)
;
this
.
onPickerPicked
=
this
.
onPickerPicked
.
bind
(
this
)
;
this
.
onSidebarHidden
=
this
.
onSidebarHidden
.
bind
(
this
)
;
this
.
onSidebarResized
=
this
.
onSidebarResized
.
bind
(
this
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
onSidebarShown
=
this
.
onSidebarShown
.
bind
(
this
)
;
this
.
onSidebarToggle
=
this
.
onSidebarToggle
.
bind
(
this
)
;
this
.
prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
prefObserver
.
on
(
DEFAULT_COLOR_UNIT_PREF
this
.
#
handleDefaultColorUnitPrefChange
)
;
this
.
defaultColorUnit
=
Services
.
prefs
.
getStringPref
(
DEFAULT_COLOR_UNIT_PREF
)
;
}
#
toolbox
;
#
commands
;
#
panels
=
new
Map
(
)
;
#
fluentL10n
;
#
defaultStartupNode
;
#
defaultStartupNodeDomReference
;
#
defaultStartupNodeSelectionReason
;
#
defaultNode
;
#
watchedResources
;
#
highlighters
;
#
newRootStart
;
#
markupFrame
;
#
markupBox
;
#
isThreePaneModeEnabled
;
#
search
;
#
cssProperties
;
#
destroyed
;
#
pendingSelectionUnique
;
#
InspectorTabPanel
;
#
InspectorSplitBox
;
#
TabBar
;
#
updateProgress
;
async
init
(
options
=
{
}
)
{
localizeMarkup
(
this
.
panelDoc
)
;
this
.
#
fluentL10n
=
new
FluentL10n
(
)
;
await
this
.
#
fluentL10n
.
init
(
[
"
devtools
/
client
/
compatibility
.
ftl
"
]
)
;
this
.
panelDoc
.
getElementById
(
"
inspector
-
main
-
content
"
)
.
style
.
visibility
=
"
visible
"
;
this
.
#
setupSplitter
(
)
;
this
.
#
defaultStartupNode
=
options
.
defaultStartupNode
;
this
.
#
defaultStartupNodeDomReference
=
options
.
defaultStartupNodeDomReference
;
this
.
#
defaultStartupNodeSelectionReason
=
options
.
defaultStartupNodeSelectionReason
;
this
.
#
defaultNode
=
null
;
await
this
.
commands
.
targetCommand
.
watchTargets
(
{
types
:
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
#
onTargetAvailable
onSelected
:
this
.
#
onTargetSelected
onDestroyed
:
this
.
#
onTargetDestroyed
}
)
;
const
{
TYPES
}
=
this
.
toolbox
.
resourceCommand
;
this
.
#
watchedResources
=
[
TYPES
.
CSS_CHANGE
TYPES
.
DOCUMENT_EVENT
TYPES
.
REFLOW
]
;
const
isBrowserToolbox
=
this
.
commands
.
descriptorFront
.
isBrowserProcessDescriptor
;
if
(
isBrowserToolbox
)
{
this
.
#
watchedResources
.
push
(
TYPES
.
ROOT_NODE
)
;
}
await
this
.
toolbox
.
resourceCommand
.
watchResources
(
this
.
#
watchedResources
{
onAvailable
:
this
.
onResourceAvailable
}
)
;
this
.
previousURL
=
this
.
currentTarget
.
url
;
this
.
styleChangeTracker
=
new
InspectorStyleChangeTracker
(
this
)
;
this
.
#
setupSidebar
(
)
;
this
.
breadcrumbs
=
new
HTMLBreadcrumbs
(
this
)
;
this
.
#
setupExtensionSidebars
(
)
;
this
.
#
setupSearchBox
(
)
;
this
.
#
createInspectorShortcuts
(
)
;
this
.
#
onNewSelection
(
)
;
this
.
toolbox
.
on
(
"
host
-
changed
"
this
.
#
onHostChanged
)
;
this
.
toolbox
.
nodePicker
.
on
(
"
picker
-
node
-
hovered
"
this
.
onPickerHovered
)
;
this
.
toolbox
.
nodePicker
.
on
(
"
picker
-
node
-
canceled
"
this
.
onPickerCanceled
)
;
this
.
toolbox
.
nodePicker
.
on
(
"
picker
-
node
-
picked
"
this
.
onPickerPicked
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
#
onNewSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
#
onDetached
)
;
Glean
.
devtoolsInspector
.
threePaneEnabled
[
this
.
isThreePaneModeEnabled
]
.
add
(
1
)
;
return
this
;
}
#
onTargetAvailable
=
async
(
{
targetFront
}
)
=
>
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
await
Promise
.
all
(
[
this
.
#
getCssProperties
(
targetFront
)
this
.
#
getAccessibilityFront
(
targetFront
)
]
)
;
}
;
#
onTargetSelected
=
async
(
{
targetFront
}
)
=
>
{
if
(
this
.
#
highlighters
)
{
this
.
#
highlighters
.
hideAllHighlighters
(
)
;
}
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
await
this
.
#
initInspectorFront
(
targetFront
)
;
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
const
{
walker
}
=
await
targetFront
.
getFront
(
"
inspector
"
)
;
const
rootNodeFront
=
await
walker
.
getRootNode
(
)
;
await
this
.
onRootNodeAvailable
(
rootNodeFront
)
;
}
;
#
onTargetDestroyed
=
(
{
targetFront
}
)
=
>
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
this
.
#
defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
}
;
onResourceAvailable
(
resources
)
{
const
rootNodeAvailablePromises
=
[
]
;
for
(
const
resource
of
resources
)
{
const
isTopLevelTarget
=
!
!
resource
.
targetFront
?
.
isTopLevel
;
const
isTopLevelDocument
=
!
!
resource
.
isTopLevelDocument
;
if
(
resource
.
resourceType
=
=
=
this
.
toolbox
.
resourceCommand
.
TYPES
.
ROOT_NODE
&
&
!
resource
.
isDestroyed
(
)
&
&
isTopLevelTarget
&
&
isTopLevelDocument
)
{
rootNodeAvailablePromises
.
push
(
this
.
onRootNodeAvailable
(
resource
)
)
;
}
if
(
resource
.
resourceType
=
=
=
this
.
toolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
=
"
will
-
navigate
"
&
&
isTopLevelTarget
)
{
this
.
#
onWillNavigate
(
)
;
}
if
(
resource
.
resourceType
=
=
=
this
.
toolbox
.
resourceCommand
.
TYPES
.
REFLOW
)
{
this
.
emit
(
"
reflow
"
)
;
if
(
resource
.
targetFront
=
=
=
this
.
selection
?
.
nodeFront
?
.
targetFront
)
{
this
.
emit
(
"
reflow
-
in
-
selected
-
target
"
)
;
}
}
}
return
Promise
.
all
(
rootNodeAvailablePromises
)
;
}
async
onRootNodeAvailable
(
rootNodeFront
)
{
this
.
#
newRootStart
=
this
.
panelWin
.
performance
.
now
(
)
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
#
destroyMarkup
(
)
;
try
{
const
defaultNode
=
await
this
.
#
getDefaultNodeForSelection
(
rootNodeFront
)
;
if
(
!
defaultNode
)
{
return
;
}
this
.
selection
.
setNodeFront
(
defaultNode
{
reason
:
this
.
#
defaultStartupNodeSelectionReason
?
?
"
inspector
-
default
-
selection
"
}
)
;
this
.
#
defaultStartupNodeSelectionReason
=
null
;
await
this
.
#
initMarkupView
(
)
;
/
/
Setup
the
toolbar
again
since
its
content
may
depend
on
the
current
document
.
this
.
#
setupToolbar
(
)
;
}
catch
(
e
)
{
this
.
#
handleRejectionIfNotDestroyed
(
e
)
;
}
}
async
#
initMarkupView
(
)
{
if
(
!
this
.
#
markupFrame
)
{
this
.
#
markupFrame
=
this
.
panelDoc
.
createElement
(
"
iframe
"
)
;
this
.
#
markupFrame
.
setAttribute
(
"
aria
-
label
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
panelLabel
.
markupView
"
)
)
;
this
.
#
markupFrame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
#
markupFrame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
this
.
#
markupBox
=
this
.
panelDoc
.
getElementById
(
"
markup
-
box
"
)
;
this
.
#
markupBox
.
style
.
visibility
=
"
hidden
"
;
this
.
#
markupBox
.
appendChild
(
this
.
#
markupFrame
)
;
const
onMarkupFrameLoaded
=
new
Promise
(
r
=
>
this
.
#
markupFrame
.
addEventListener
(
"
load
"
r
{
capture
:
true
once
:
true
}
)
)
;
this
.
#
markupFrame
.
setAttribute
(
"
src
"
"
markup
/
markup
.
xhtml
"
)
;
await
onMarkupFrameLoaded
;
}
this
.
#
markupFrame
.
contentWindow
.
focus
(
)
;
this
.
#
markupBox
.
style
.
visibility
=
"
visible
"
;
this
.
markup
=
new
MarkupView
(
this
this
.
#
markupFrame
this
.
#
toolbox
.
win
)
;
this
.
emitForTests
(
"
markuploaded
"
)
;
const
onExpand
=
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
if
(
this
.
#
highlighters
)
{
await
Promise
.
all
(
[
this
.
highlighters
.
restoreFlexboxState
(
)
this
.
highlighters
.
restoreGridState
(
)
]
)
;
}
this
.
emit
(
"
new
-
root
"
)
;
await
onExpand
;
this
.
emit
(
"
reloaded
"
)
;
if
(
this
.
#
newRootStart
)
{
if
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
=
=
"
inspector
"
)
{
const
delay
=
this
.
panelWin
.
performance
.
now
(
)
-
this
.
#
newRootStart
;
Glean
.
devtoolsInspector
.
newRootToReloadDelay
.
accumulateSingleSample
(
delay
)
;
}
this
.
#
newRootStart
=
null
;
}
}
async
#
initInspectorFront
(
targetFront
)
{
this
.
inspectorFront
=
await
targetFront
.
getFront
(
"
inspector
"
)
;
this
.
walker
=
this
.
inspectorFront
.
walker
;
}
get
toolbox
(
)
{
return
this
.
#
toolbox
;
}
get
commands
(
)
{
return
this
.
#
commands
;
}
async
getAllInspectorFronts
(
)
{
return
this
.
commands
.
targetCommand
.
getAllFronts
(
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
"
inspector
"
)
;
}
get
highlighters
(
)
{
if
(
!
this
.
#
highlighters
)
{
this
.
#
highlighters
=
new
HighlightersOverlay
(
this
)
;
}
return
this
.
#
highlighters
;
}
get
#
threePanePrefName
(
)
{
return
this
.
commands
.
descriptorFront
.
isTabDescriptor
?
THREE_PANE_ENABLED_PREF
:
THREE_PANE_CHROME_ENABLED_PREF
;
}
get
isThreePaneModeEnabled
(
)
{
if
(
!
this
.
#
isThreePaneModeEnabled
)
{
this
.
#
isThreePaneModeEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
#
threePanePrefName
)
;
}
return
this
.
#
isThreePaneModeEnabled
;
}
set
isThreePaneModeEnabled
(
value
)
{
this
.
#
isThreePaneModeEnabled
=
value
;
Services
.
prefs
.
setBoolPref
(
this
.
#
threePanePrefName
this
.
#
isThreePaneModeEnabled
)
;
}
get
search
(
)
{
if
(
!
this
.
#
search
)
{
this
.
#
search
=
new
InspectorSearch
(
this
this
.
searchBox
this
.
searchClearButton
this
.
searchPrevButton
this
.
searchNextButton
)
;
}
return
this
.
#
search
;
}
get
selection
(
)
{
return
this
.
toolbox
.
selection
;
}
get
cssProperties
(
)
{
return
this
.
#
cssProperties
.
cssProperties
;
}
get
fluentL10n
(
)
{
return
this
.
#
fluentL10n
;
}
HIGHLIGHTER_AUTOHIDE_TIMER
=
flags
.
testing
?
0
:
1000
;
#
handleDefaultColorUnitPrefChange
=
(
)
=
>
{
this
.
defaultColorUnit
=
Services
.
prefs
.
getStringPref
(
DEFAULT_COLOR_UNIT_PREF
)
;
}
;
#
handleRejectionIfNotDestroyed
=
e
=
>
{
if
(
!
this
.
#
destroyed
)
{
console
.
error
(
e
)
;
}
}
;
#
onWillNavigate
=
(
)
=
>
{
this
.
#
defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
if
(
this
.
#
highlighters
)
{
this
.
#
highlighters
.
hideAllHighlighters
(
)
;
}
this
.
#
destroyMarkup
(
)
;
this
.
#
pendingSelectionUnique
=
null
;
}
;
async
#
getCssProperties
(
targetFront
)
{
this
.
#
cssProperties
=
await
targetFront
.
getFront
(
"
cssProperties
"
)
;
}
async
#
getAccessibilityFront
(
targetFront
)
{
this
.
accessibilityFront
=
await
targetFront
.
getFront
(
"
accessibility
"
)
;
return
this
.
accessibilityFront
;
}
async
#
getDefaultNodeForSelection
(
rootNodeFront
)
{
let
node
;
if
(
this
.
#
defaultStartupNode
)
{
node
=
this
.
#
defaultStartupNode
;
this
.
#
defaultStartupNode
=
null
;
this
.
#
defaultStartupNodeDomReference
=
null
;
return
node
;
}
const
pendingSelectionUnique
=
Symbol
(
"
pending
-
selection
"
)
;
this
.
#
pendingSelectionUnique
=
pendingSelectionUnique
;
if
(
this
.
#
defaultStartupNodeDomReference
)
{
const
domReference
=
this
.
#
defaultStartupNodeDomReference
;
this
.
#
defaultStartupNode
=
null
;
this
.
#
defaultStartupNodeDomReference
=
null
;
try
{
node
=
await
this
.
inspectorFront
.
getNodeActorFromContentDomReference
(
domReference
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Couldn
'
t
retrieve
node
front
from
dom
reference
"
domReference
)
;
}
}
if
(
this
.
#
pendingSelectionUnique
!
=
=
pendingSelectionUnique
)
{
return
null
;
}
if
(
node
)
{
return
node
;
}
const
walker
=
rootNodeFront
.
walkerFront
;
const
cssSelectors
=
this
.
selectionCssSelectors
;
const
defaultNodeSelectors
=
[
(
)
=
>
cssSelectors
.
length
?
this
.
commands
.
inspectorCommand
.
findNodeFrontFromSelectors
(
cssSelectors
)
:
null
(
)
=
>
walker
.
querySelector
(
rootNodeFront
"
body
"
)
(
)
=
>
walker
.
documentElement
(
)
]
;
for
(
const
selector
of
defaultNodeSelectors
)
{
node
=
await
selector
(
)
;
if
(
this
.
#
pendingSelectionUnique
!
=
=
pendingSelectionUnique
)
{
return
null
;
}
if
(
node
)
{
this
.
#
defaultNode
=
node
;
return
node
;
}
}
return
null
;
}
get
currentTarget
(
)
{
return
this
.
commands
.
targetCommand
.
selectedTargetFront
;
}
#
setupSearchBox
(
)
{
this
.
searchBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchbox
"
)
;
this
.
searchClearButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchinput
-
clear
"
)
;
this
.
searchResultsContainer
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
-
container
"
)
;
this
.
searchNavigationContainer
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchnavigation
-
container
"
)
;
this
.
searchPrevButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchnavigation
-
button
-
prev
"
)
;
this
.
searchNextButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchnavigation
-
button
-
next
"
)
;
this
.
searchResultsLabel
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
"
)
;
this
.
searchResultsLabel
.
addEventListener
(
"
click
"
this
.
#
onSearchLabelClick
)
;
this
.
searchBox
.
addEventListener
(
"
focus
"
this
.
#
listenForSearchEvents
{
once
:
true
}
)
;
}
#
onSearchLabelClick
=
(
)
=
>
{
this
.
searchBox
.
focus
(
)
;
}
;
#
listenForSearchEvents
=
(
)
=
>
{
this
.
search
.
on
(
"
search
-
cleared
"
this
.
#
clearSearchResultsLabel
)
;
this
.
search
.
on
(
"
search
-
result
"
this
.
#
updateSearchResultsLabel
)
;
}
;
#
isFromInspectorWindow
=
event
=
>
{
const
win
=
event
.
originalTarget
.
ownerGlobal
;
return
win
=
=
=
this
.
panelWin
|
|
win
.
parent
=
=
=
this
.
panelWin
;
}
;
#
createInspectorShortcuts
=
(
)
=
>
{
this
.
inspectorShortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
panelDoc
.
defaultView
target
:
this
.
toolbox
.
getChromeEventHandler
(
)
}
)
;
const
searchboxKey
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
;
this
.
inspectorShortcuts
.
on
(
searchboxKey
event
=
>
{
if
(
event
.
originalTarget
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
|
|
event
.
originalTarget
.
closest
(
"
#
sidebar
-
panel
-
computedview
"
)
|
|
!
this
.
#
isFromInspectorWindow
(
event
)
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
const
eyedropperKey
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
eyedropper
.
key
"
)
;
this
.
inspectorShortcuts
.
on
(
eyedropperKey
event
=
>
{
if
(
!
this
.
#
isFromInspectorWindow
(
event
)
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
onEyeDropperButtonClicked
(
)
;
}
)
;
}
;
get
searchSuggestions
(
)
{
return
this
.
search
.
autocompleter
;
}
#
clearSearchResultsLabel
=
result
=
>
{
this
.
emit
(
"
search
-
cleared
"
)
;
return
this
.
#
updateSearchResultsLabel
(
result
true
)
;
}
;
#
updateSearchResultsLabel
=
(
result
clear
=
false
)
=
>
{
let
str
=
"
"
;
if
(
!
clear
)
{
if
(
result
)
{
str
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
searchResultsCount2
"
result
.
resultsIndex
+
1
result
.
resultsLength
)
;
this
.
searchNavigationContainer
.
hidden
=
false
;
}
else
{
str
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchResultsNone
"
)
;
this
.
searchNavigationContainer
.
hidden
=
true
;
}
this
.
searchResultsContainer
.
hidden
=
false
;
}
else
{
this
.
searchResultsContainer
.
hidden
=
true
;
}
this
.
searchResultsLabel
.
textContent
=
str
;
}
;
get
React
(
)
{
return
this
.
#
toolbox
.
React
;
}
get
ReactDOM
(
)
{
return
this
.
#
toolbox
.
ReactDOM
;
}
get
ReactRedux
(
)
{
return
this
.
#
toolbox
.
ReactRedux
;
}
get
browserRequire
(
)
{
return
this
.
#
toolbox
.
browserRequire
;
}
get
InspectorTabPanel
(
)
{
if
(
!
this
.
#
InspectorTabPanel
)
{
this
.
#
InspectorTabPanel
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
components
/
InspectorTabPanel
"
)
)
;
}
return
this
.
#
InspectorTabPanel
;
}
get
InspectorSplitBox
(
)
{
if
(
!
this
.
#
InspectorSplitBox
)
{
this
.
#
InspectorSplitBox
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
splitter
/
SplitBox
"
)
)
;
}
return
this
.
#
InspectorSplitBox
;
}
get
TabBar
(
)
{
if
(
!
this
.
#
TabBar
)
{
this
.
#
TabBar
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
tabs
/
TabBar
"
)
)
;
}
return
this
.
#
TabBar
;
}
#
useLandscapeMode
(
)
{
if
(
!
this
.
panelDoc
)
{
return
true
;
}
const
splitterBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
const
width
=
splitterBox
.
clientWidth
;
return
this
.
isThreePaneModeEnabled
&
&
(
this
.
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
LEFT
|
|
this
.
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
RIGHT
)
?
width
>
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
:
width
>
PORTRAIT_MODE_WIDTH_THRESHOLD
;
}
#
setupSplitter
(
)
{
const
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
sidebarSplitBoxRef
=
this
.
React
.
createRef
(
)
;
const
splitter
=
this
.
InspectorSplitBox
(
{
className
:
"
inspector
-
sidebar
-
splitter
"
initialWidth
:
width
initialHeight
:
height
minSize
:
"
10
%
"
maxSize
:
"
80
%
"
splitterSize
:
1
endPanelControl
:
true
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
main
-
content
"
}
)
endPanel
:
this
.
InspectorSplitBox
(
{
initialWidth
:
splitSidebarWidth
minSize
:
"
225px
"
maxSize
:
"
80
%
"
splitterSize
:
this
.
isThreePaneModeEnabled
?
1
:
0
endPanelControl
:
this
.
isThreePaneModeEnabled
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
rules
-
container
"
}
)
endPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
sidebar
-
container
"
}
)
ref
:
this
.
sidebarSplitBoxRef
}
)
vert
:
this
.
#
useLandscapeMode
(
)
onControlledPanelResized
:
this
.
onSidebarResized
}
)
;
this
.
splitBox
=
this
.
ReactDOM
.
render
(
splitter
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
)
;
this
.
panelWin
.
addEventListener
(
"
resize
"
this
.
#
onLazyPanelResize
true
)
;
}
#
onLazyPanelResize
=
debounce
(
(
)
=
>
{
if
(
this
.
panelWin
?
.
closed
|
|
this
.
#
destroyed
|
|
this
.
#
toolbox
.
currentToolId
!
=
=
"
inspector
"
)
{
return
;
}
this
.
splitBox
.
setState
(
{
vert
:
this
.
#
useLandscapeMode
(
)
}
)
;
this
.
emit
(
"
inspector
-
resize
"
)
;
}
LAZY_RESIZE_INTERVAL_MS
this
)
;
getSidebarSize
(
)
{
let
width
;
let
height
;
let
splitSidebarWidth
;
try
{
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
)
;
splitSidebarWidth
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
)
;
}
catch
(
e
)
{
width
=
this
.
isThreePaneModeEnabled
?
INITIAL_SIDEBAR_SIZE
*
2
:
INITIAL_SIDEBAR_SIZE
;
height
=
INITIAL_SIDEBAR_SIZE
;
splitSidebarWidth
=
INITIAL_SIDEBAR_SIZE
;
}
return
{
width
height
splitSidebarWidth
}
;
}
onSidebarHidden
(
)
{
const
state
=
this
.
splitBox
.
state
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
state
.
width
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
state
.
height
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
this
.
sidebarSplitBoxRef
.
current
.
state
.
width
)
;
}
onSidebarResized
(
width
height
)
{
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
resized
"
{
width
height
}
)
;
}
getActiveSidebar
(
)
{
return
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
}
setActiveSidebar
(
toolId
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
toolId
)
;
}
getSelectedSidebar
(
)
{
return
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
selectedSidebar
"
)
;
}
setSelectedSidebar
(
toolId
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
selectedSidebar
"
toolId
)
;
}
onSidebarSelect
(
toolId
)
{
this
.
setSelectedSidebar
(
toolId
)
;
this
.
setActiveSidebar
(
toolId
)
;
this
.
getPanel
(
toolId
)
;
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
select
"
toolId
)
;
}
onSidebarShown
(
)
{
const
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
splitBox
.
setState
(
{
width
height
}
)
;
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
width
:
splitSidebarWidth
}
)
;
}
async
onSidebarToggle
(
)
{
this
.
isThreePaneModeEnabled
=
!
this
.
isThreePaneModeEnabled
;
await
this
.
#
setupToolbar
(
)
;
this
.
#
addRuleView
(
{
skipQueue
:
true
}
)
;
}
#
setSidebarSplitBoxState
(
)
{
const
toolboxWidth
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
.
clientWidth
;
const
sidebarWidth
=
this
.
splitBox
.
state
.
width
;
let
sidebarSplitboxWidth
;
if
(
this
.
#
useLandscapeMode
(
)
)
{
const
canDoubleSidebarWidth
=
sidebarWidth
*
2
<
toolboxWidth
/
2
;
this
.
splitBox
.
setState
(
{
width
:
canDoubleSidebarWidth
?
sidebarWidth
*
2
:
(
toolboxWidth
*
2
)
/
3
}
)
;
sidebarSplitboxWidth
=
canDoubleSidebarWidth
?
sidebarWidth
:
toolboxWidth
/
3
;
}
else
{
sidebarSplitboxWidth
=
toolboxWidth
/
2
;
}
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
endPanelControl
:
true
splitterSize
:
1
width
:
sidebarSplitboxWidth
}
)
;
}
#
addRuleView
(
{
skipQueue
=
false
}
=
{
}
)
{
const
selectedSidebar
=
this
.
getSelectedSidebar
(
)
;
const
ruleViewSidebar
=
this
.
sidebarSplitBoxRef
.
current
.
startPanelContainer
;
if
(
this
.
isThreePaneModeEnabled
)
{
ruleViewSidebar
.
style
.
display
=
"
block
"
;
this
.
#
setSidebarSplitBoxState
(
)
;
this
.
getPanel
(
"
ruleview
"
)
;
this
.
sidebar
.
removeTab
(
"
ruleview
"
)
;
this
.
sidebar
.
select
(
selectedSidebar
)
;
this
.
ruleViewSideBar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
)
;
this
.
ruleViewSideBar
.
show
(
)
;
}
else
{
this
.
setActiveSidebar
(
"
ruleview
"
)
;
ruleViewSidebar
.
style
.
display
=
"
none
"
;
const
splitterBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
this
.
splitBox
.
setState
(
{
width
:
this
.
#
useLandscapeMode
(
)
?
this
.
sidebarSplitBoxRef
.
current
.
state
.
width
:
splitterBox
.
clientWidth
}
)
;
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
endPanelControl
:
false
splitterSize
:
0
}
)
;
this
.
ruleViewSideBar
.
hide
(
)
;
this
.
ruleViewSideBar
.
removeTab
(
"
ruleview
"
)
;
if
(
skipQueue
)
{
this
.
sidebar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
0
)
;
}
else
{
this
.
sidebar
.
queueExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
0
)
;
}
}
this
.
setSelectedSidebar
(
selectedSidebar
)
;
this
.
emit
(
"
ruleview
-
added
"
)
;
}
hasPanel
(
id
)
{
return
this
.
#
panels
.
has
(
id
)
;
}
getPanel
(
id
)
{
if
(
this
.
#
panels
.
has
(
id
)
)
{
return
this
.
#
panels
.
get
(
id
)
;
}
let
panel
;
switch
(
id
)
{
case
"
animationinspector
"
:
{
const
AnimationInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
animation
/
animation
"
)
;
panel
=
new
AnimationInspector
(
this
this
.
panelWin
)
;
break
;
}
case
"
boxmodel
"
:
{
const
BoxModel
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
boxmodel
/
box
-
model
.
js
"
)
;
panel
=
new
BoxModel
(
this
this
.
panelWin
)
;
break
;
}
case
"
changesview
"
:
{
const
ChangesView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
changes
/
ChangesView
"
)
;
panel
=
new
ChangesView
(
this
this
.
panelWin
)
;
break
;
}
case
"
compatibilityview
"
:
{
const
CompatibilityView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
compatibility
/
CompatibilityView
"
)
;
panel
=
new
CompatibilityView
(
this
this
.
panelWin
)
;
break
;
}
case
"
computedview
"
:
{
const
{
ComputedViewTool
}
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
computed
/
computed
"
)
;
panel
=
new
ComputedViewTool
(
this
this
.
panelWin
)
;
break
;
}
case
"
fontinspector
"
:
{
const
FontInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
fonts
/
fonts
"
)
;
panel
=
new
FontInspector
(
this
this
.
panelWin
)
;
break
;
}
case
"
layoutview
"
:
{
const
LayoutView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
layout
/
layout
"
)
;
panel
=
new
LayoutView
(
this
this
.
panelWin
)
;
break
;
}
case
"
ruleview
"
:
{
const
{
RuleViewTool
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
rules
.
js
"
)
;
panel
=
new
RuleViewTool
(
this
this
.
panelWin
)
;
break
;
}
default
:
return
null
;
}
if
(
panel
)
{
this
.
#
panels
.
set
(
id
panel
)
;
}
return
panel
;
}
#
setupSidebar
(
)
{
const
sidebar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
sidebar
"
)
;
const
options
=
{
showAllTabsMenu
:
true
allTabsMenuButtonTooltip
:
INSPECTOR_L10N
.
getStr
(
"
allTabsMenuButton
.
tooltip
"
)
sidebarToggleButton
:
{
collapsed
:
!
this
.
isThreePaneModeEnabled
collapsePaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
hideThreePaneMode
"
)
expandPaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
showThreePaneMode
"
)
onClick
:
this
.
onSidebarToggle
}
}
;
this
.
sidebar
=
new
ToolSidebar
(
sidebar
this
"
inspector
"
options
)
;
this
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
const
ruleSideBar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
rules
-
sidebar
"
)
;
this
.
ruleViewSideBar
=
new
ToolSidebar
(
ruleSideBar
this
"
inspector
"
{
hideTabstripe
:
true
}
)
;
this
.
#
addRuleView
(
)
;
const
sidebarPanels
=
[
]
;
sidebarPanels
.
push
(
{
id
:
"
layoutview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
layoutViewTitle2
"
)
}
)
;
sidebarPanels
.
push
(
{
id
:
"
computedview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
computedViewTitle
"
)
}
)
;
sidebarPanels
.
push
(
{
id
:
"
changesview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
changesViewTitle
"
)
}
)
;
sidebarPanels
.
push
(
{
id
:
"
compatibilityview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
compatibilityViewTitle
"
)
}
)
;
sidebarPanels
.
push
(
{
id
:
"
fontinspector
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
}
)
;
sidebarPanels
.
push
(
{
id
:
"
animationinspector
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
animationInspectorTitle
"
)
}
)
;
const
defaultTab
=
this
.
getActiveSidebar
(
)
;
for
(
const
{
id
title
}
of
sidebarPanels
)
{
if
(
id
=
=
=
"
computedview
"
)
{
this
.
sidebar
.
queueExistingTab
(
id
title
defaultTab
=
=
=
id
)
;
}
else
{
this
.
sidebar
.
queueTab
(
id
title
{
props
:
{
id
title
}
panel
:
(
)
=
>
{
return
this
.
getPanel
(
id
)
.
provider
;
}
}
defaultTab
=
=
=
id
)
;
}
}
this
.
sidebar
.
addAllQueuedTabs
(
)
;
this
.
sidebar
.
on
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
on
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
on
(
"
destroy
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
show
(
)
;
}
#
setupExtensionSidebars
(
)
{
for
(
const
[
sidebarId
{
title
}
]
of
this
.
toolbox
.
inspectorExtensionSidebars
)
{
this
.
addExtensionSidebar
(
sidebarId
{
title
}
)
;
}
}
addExtensionSidebar
(
id
{
title
}
)
{
if
(
this
.
#
panels
.
has
(
id
)
)
{
throw
new
Error
(
Cannot
create
an
extension
sidebar
for
the
existent
id
:
{
id
}
)
;
}
const
ExtensionSidebar
=
this
.
browserRequire
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
extensions
/
extension
-
sidebar
.
js
"
)
;
const
extensionSidebar
=
new
ExtensionSidebar
(
this
{
id
title
}
)
;
this
.
addSidebarTab
(
id
title
extensionSidebar
.
provider
false
)
;
this
.
#
panels
.
set
(
id
extensionSidebar
)
;
this
.
toolbox
.
emit
(
extension
-
sidebar
-
created
-
{
id
}
extensionSidebar
)
;
}
removeExtensionSidebar
(
id
)
{
if
(
!
this
.
#
panels
.
has
(
id
)
)
{
throw
new
Error
(
Unable
to
find
a
sidebar
panel
with
id
"
{
id
}
"
)
;
}
const
panel
=
this
.
#
panels
.
get
(
id
)
;
const
ExtensionSidebar
=
this
.
browserRequire
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
extensions
/
extension
-
sidebar
.
js
"
)
;
if
(
!
(
panel
instanceof
ExtensionSidebar
)
)
{
throw
new
Error
(
The
sidebar
panel
with
id
"
{
id
}
"
is
not
an
ExtensionSidebar
)
;
}
this
.
#
panels
.
delete
(
id
)
;
this
.
sidebar
.
removeTab
(
id
)
;
panel
.
destroy
(
)
;
}
addSidebarTab
(
id
title
panel
selected
)
{
this
.
sidebar
.
addTab
(
id
title
panel
selected
)
;
}
async
supportsEyeDropper
(
)
{
try
{
return
await
this
.
inspectorFront
.
supportsHighlighters
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
false
;
}
}
async
#
setupToolbar
(
)
{
this
.
#
teardownToolbar
(
)
;
this
.
addNode
=
this
.
addNode
.
bind
(
this
)
;
this
.
addNodeButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
this
.
addNodeButton
.
addEventListener
(
"
click
"
this
.
addNode
)
;
const
canShowEyeDropper
=
await
this
.
supportsEyeDropper
(
)
;
if
(
!
this
.
panelDoc
)
{
return
;
}
if
(
canShowEyeDropper
)
{
this
.
onEyeDropperDone
=
this
.
onEyeDropperDone
.
bind
(
this
)
;
this
.
onEyeDropperButtonClicked
=
this
.
onEyeDropperButtonClicked
.
bind
(
this
)
;
this
.
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
this
.
eyeDropperButton
.
disabled
=
false
;
const
shortcutKey
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
eyedropper
.
key
"
)
.
replace
(
"
CmdOrCtrl
"
osString
=
=
"
Darwin
"
?
"
Cmd
"
:
"
Ctrl
"
)
;
this
.
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
eyedropper
.
label2
"
shortcutKey
)
;
this
.
eyeDropperButton
.
addEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
}
else
{
const
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
eyeDropperButton
.
disabled
=
true
;
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
eyedropper
.
disabled
.
title
"
)
;
}
this
.
emit
(
"
inspector
-
toolbar
-
updated
"
)
;
}
#
teardownToolbar
(
)
{
if
(
this
.
addNodeButton
)
{
this
.
addNodeButton
.
removeEventListener
(
"
click
"
this
.
addNode
)
;
this
.
addNodeButton
=
null
;
}
if
(
this
.
eyeDropperButton
)
{
this
.
eyeDropperButton
.
removeEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
this
.
eyeDropperButton
=
null
;
}
}
#
selectionCssSelectors
=
null
;
set
selectionCssSelectors
(
cssSelectors
=
[
]
)
{
if
(
this
.
#
destroyed
)
{
return
;
}
this
.
#
selectionCssSelectors
=
{
selectors
:
cssSelectors
url
:
this
.
currentTarget
.
url
}
;
}
get
selectionCssSelectors
(
)
{
if
(
this
.
#
selectionCssSelectors
&
&
this
.
#
selectionCssSelectors
.
url
=
=
=
this
.
currentTarget
.
url
)
{
return
this
.
#
selectionCssSelectors
.
selectors
;
}
return
[
]
;
}
#
updateSelectionCssSelectors
(
)
{
if
(
!
this
.
selection
.
isElementNode
(
)
)
{
return
;
}
this
.
commands
.
inspectorCommand
.
getNodeFrontSelectorsFromTopDocument
(
this
.
selection
.
nodeFront
)
.
then
(
selectors
=
>
{
this
.
selectionCssSelectors
=
selectors
;
this
.
emitForTests
(
"
selection
-
css
-
selectors
-
updated
"
selectors
)
;
}
this
.
#
handleRejectionIfNotDestroyed
)
;
}
canAddHTMLChild
(
)
{
const
selection
=
this
.
selection
;
const
invalidTagNames
=
[
"
html
"
"
iframe
"
]
;
return
(
selection
.
isHTMLNode
(
)
&
&
selection
.
isElementNode
(
)
&
&
!
selection
.
isPseudoElementNode
(
)
&
&
!
selection
.
isAnonymousNode
(
)
&
&
!
invalidTagNames
.
includes
(
selection
.
nodeFront
.
nodeName
.
toLowerCase
(
)
)
)
;
}
#
updateAddElementButton
(
)
{
const
btn
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
btn
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
btn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
#
onHostChanged
=
async
(
)
=
>
{
await
this
.
#
onLazyPanelResize
(
)
;
if
(
!
this
.
currentTarget
|
|
!
this
.
isThreePaneModeEnabled
)
{
return
;
}
this
.
inspectorShortcuts
.
destroy
(
)
;
this
.
#
createInspectorShortcuts
(
)
;
this
.
#
setSidebarSplitBoxState
(
)
;
}
;
#
onNewSelection
=
(
value
reason
)
=
>
{
if
(
reason
=
=
=
"
selection
-
destroy
"
)
{
return
;
}
this
.
#
updateAddElementButton
(
)
;
this
.
#
updateSelectionCssSelectors
(
)
;
const
selfUpdate
=
this
.
updating
(
"
inspector
-
panel
"
)
;
executeSoon
(
(
)
=
>
{
try
{
selfUpdate
(
this
.
selection
.
nodeFront
)
;
Glean
.
devtoolsInspector
.
nodeSelectionCount
.
add
(
1
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
)
;
}
;
updating
(
name
)
{
if
(
this
.
#
updateProgress
&
&
this
.
#
updateProgress
.
node
!
=
this
.
selection
.
nodeFront
)
{
this
.
#
cancelUpdate
(
)
;
}
if
(
!
this
.
#
updateProgress
)
{
const
self
=
this
;
this
.
#
updateProgress
=
{
node
:
this
.
selection
.
nodeFront
outstanding
:
new
Set
(
)
checkDone
(
)
{
if
(
this
!
=
=
self
.
#
updateProgress
)
{
return
;
}
if
(
!
self
.
selection
|
|
this
.
node
!
=
=
self
.
selection
.
nodeFront
)
{
self
.
#
cancelUpdate
(
)
;
return
;
}
if
(
this
.
outstanding
.
size
!
=
=
0
)
{
return
;
}
self
.
#
updateProgress
=
null
;
self
.
emit
(
"
inspector
-
updated
"
name
)
;
}
}
;
}
const
progress
=
this
.
#
updateProgress
;
const
done
=
function
(
)
{
progress
.
outstanding
.
delete
(
done
)
;
progress
.
checkDone
(
)
;
}
;
progress
.
outstanding
.
add
(
done
)
;
return
done
;
}
#
cancelUpdate
(
)
{
this
.
#
updateProgress
=
null
;
}
#
onDetached
=
parentNode
=
>
{
this
.
breadcrumbs
.
cutAfter
(
this
.
breadcrumbs
.
indexOf
(
parentNode
)
)
;
const
nodeFront
=
parentNode
?
parentNode
:
this
.
#
defaultNode
;
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
detached
"
}
)
;
}
;
destroy
(
)
{
if
(
this
.
#
destroyed
)
{
return
;
}
this
.
#
destroyed
=
true
;
this
.
#
cancelUpdate
(
)
;
this
.
panelWin
.
removeEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
#
onNewSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
#
onDetached
)
;
this
.
toolbox
.
nodePicker
.
off
(
"
picker
-
node
-
canceled
"
this
.
onPickerCanceled
)
;
this
.
toolbox
.
nodePicker
.
off
(
"
picker
-
node
-
hovered
"
this
.
onPickerHovered
)
;
this
.
toolbox
.
nodePicker
.
off
(
"
picker
-
node
-
picked
"
this
.
onPickerPicked
)
;
this
.
sidebar
.
destroy
(
)
;
this
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
sidebar
.
off
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
off
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
off
(
"
destroy
"
this
.
onSidebarHidden
)
;
for
(
const
[
panel
]
of
this
.
#
panels
)
{
panel
.
destroy
(
)
;
}
this
.
#
panels
.
clear
(
)
;
if
(
this
.
#
highlighters
)
{
this
.
#
highlighters
.
destroy
(
)
;
}
if
(
this
.
#
search
)
{
this
.
#
search
.
destroy
(
)
;
this
.
#
search
=
null
;
}
this
.
ruleViewSideBar
.
destroy
(
)
;
this
.
ruleViewSideBar
=
null
;
this
.
#
destroyMarkup
(
)
;
this
.
#
teardownToolbar
(
)
;
this
.
prefObserver
.
on
(
DEFAULT_COLOR_UNIT_PREF
this
.
#
handleDefaultColorUnitPrefChange
)
;
this
.
prefObserver
.
destroy
(
)
;
this
.
breadcrumbs
.
destroy
(
)
;
this
.
styleChangeTracker
.
destroy
(
)
;
this
.
inspectorShortcuts
.
destroy
(
)
;
this
.
inspectorShortcuts
=
null
;
this
.
commands
.
targetCommand
.
unwatchTargets
(
{
types
:
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
#
onTargetAvailable
onSelected
:
this
.
#
onTargetSelected
onDestroyed
:
this
.
#
onTargetDestroyed
}
)
;
const
{
resourceCommand
}
=
this
.
toolbox
;
resourceCommand
.
unwatchResources
(
this
.
#
watchedResources
{
onAvailable
:
this
.
onResourceAvailable
}
)
;
this
.
#
InspectorTabPanel
=
null
;
this
.
#
TabBar
=
null
;
this
.
#
InspectorSplitBox
=
null
;
this
.
sidebarSplitBoxRef
=
null
;
this
.
splitBox
=
null
;
this
.
#
isThreePaneModeEnabled
=
null
;
this
.
#
markupBox
=
null
;
this
.
#
markupFrame
=
null
;
this
.
#
toolbox
=
null
;
this
.
#
commands
=
null
;
this
.
breadcrumbs
=
null
;
this
.
inspectorFront
=
null
;
this
.
#
cssProperties
=
null
;
this
.
accessibilityFront
=
null
;
this
.
#
highlighters
=
null
;
this
.
walker
=
null
;
this
.
#
defaultNode
=
null
;
this
.
panelDoc
=
null
;
this
.
panelWin
.
inspector
=
null
;
this
.
panelWin
=
null
;
this
.
resultsLength
=
null
;
this
.
searchBox
.
removeEventListener
(
"
focus
"
this
.
#
listenForSearchEvents
)
;
this
.
searchBox
=
null
;
this
.
show3PaneTooltip
=
null
;
this
.
sidebar
=
null
;
this
.
store
=
null
;
this
.
telemetry
=
null
;
this
.
searchResultsLabel
.
removeEventListener
(
"
click
"
this
.
#
onSearchLabelClick
)
;
this
.
searchResultsLabel
=
null
;
}
#
destroyMarkup
(
)
{
if
(
this
.
markup
)
{
this
.
markup
.
destroy
(
)
;
this
.
markup
=
null
;
}
if
(
this
.
#
markupBox
)
{
this
.
#
markupBox
.
style
.
visibility
=
"
hidden
"
;
}
}
onEyeDropperButtonClicked
(
)
{
this
.
eyeDropperButton
.
classList
.
contains
(
"
checked
"
)
?
this
.
hideEyeDropper
(
)
:
this
.
showEyeDropper
(
)
;
}
startEyeDropperListeners
(
)
{
this
.
toolbox
.
tellRDMAboutPickerState
(
true
PICKER_TYPES
.
EYEDROPPER
)
;
this
.
inspectorFront
.
once
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspectorFront
.
once
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
once
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
stopEyeDropperListeners
(
)
{
this
.
toolbox
.
tellRDMAboutPickerState
(
false
PICKER_TYPES
.
EYEDROPPER
)
.
catch
(
console
.
error
)
;
this
.
inspectorFront
.
off
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspectorFront
.
off
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
off
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
onEyeDropperDone
(
)
{
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
this
.
panelWin
.
focus
(
)
;
}
showEyeDropper
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
toolbox
.
nodePicker
.
stop
(
{
canceled
:
true
}
)
.
catch
(
console
.
error
)
;
this
.
eyeDropperButton
.
classList
.
add
(
"
checked
"
)
;
this
.
startEyeDropperListeners
(
)
;
return
this
.
inspectorFront
.
pickColorFromPage
(
{
copyOnSelect
:
true
}
)
.
catch
(
console
.
error
)
;
}
hideEyeDropper
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
return
this
.
inspectorFront
.
cancelPickColorFromPage
(
)
.
catch
(
console
.
error
)
;
}
async
addNode
(
)
{
if
(
!
this
.
canAddHTMLChild
(
)
)
{
return
;
}
this
.
toolbox
.
nodePicker
.
stop
(
{
canceled
:
true
}
)
;
this
.
hideEyeDropper
(
)
;
const
nodeFront
=
this
.
selection
.
nodeFront
;
const
html
=
"
<
div
>
<
/
div
>
"
;
const
onMutations
=
this
.
once
(
"
markupmutation
"
)
;
await
nodeFront
.
walkerFront
.
insertAdjacentHTML
(
this
.
selection
.
nodeFront
"
beforeEnd
"
html
)
;
await
onMutations
;
this
.
markup
.
expandNode
(
nodeFront
)
;
}
togglePseudoClass
(
pseudo
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
const
node
=
this
.
selection
.
nodeFront
;
if
(
node
.
hasPseudoClassLock
(
pseudo
)
)
{
return
node
.
walkerFront
.
removePseudoClassLock
(
node
pseudo
{
parents
:
true
}
)
;
}
const
hierarchical
=
pseudo
=
=
"
:
hover
"
|
|
pseudo
=
=
"
:
active
"
;
return
node
.
walkerFront
.
addPseudoClassLock
(
node
pseudo
{
parents
:
hierarchical
}
)
;
}
return
Promise
.
resolve
(
)
;
}
async
screenshotNode
(
)
{
await
this
.
highlighters
.
hideHighlighterType
(
this
.
highlighters
.
TYPES
.
BOXMODEL
)
;
const
clipboardEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
clipboard
.
enabled
"
)
;
const
args
=
{
file
:
!
clipboardEnabled
nodeActorID
:
this
.
selection
.
nodeFront
.
actorID
clipboard
:
clipboardEnabled
}
;
const
messages
=
await
captureAndSaveScreenshot
(
this
.
selection
.
nodeFront
.
targetFront
this
.
panelWin
args
)
;
const
notificationBox
=
this
.
toolbox
.
getNotificationBox
(
)
;
const
priorityMap
=
{
error
:
notificationBox
.
PRIORITY_CRITICAL_HIGH
warn
:
notificationBox
.
PRIORITY_WARNING_HIGH
}
;
for
(
const
{
text
level
}
of
messages
)
{
if
(
level
!
=
=
"
warn
"
&
&
level
!
=
=
"
error
"
)
{
continue
;
}
notificationBox
.
appendNotification
(
text
null
null
priorityMap
[
level
]
)
;
}
}
/
*
*
*
Returns
an
object
containing
the
shared
handler
functions
used
in
React
components
.
*
/
getCommonComponentProps
(
)
{
return
{
setSelectedNode
:
this
.
selection
.
setNodeFront
}
;
}
onPickerCanceled
(
)
{
this
.
highlighters
.
hideHighlighterType
(
this
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
onPickerHovered
(
nodeFront
)
{
this
.
highlighters
.
showHighlighterTypeForNode
(
this
.
highlighters
.
TYPES
.
BOXMODEL
nodeFront
)
;
}
onPickerPicked
(
nodeFront
)
{
if
(
this
.
toolbox
.
isDebugTargetFenix
(
)
)
{
/
/
When
debugging
a
phone
as
we
don
'
t
have
the
"
hover
overlay
"
we
want
to
provide
/
/
feedback
to
the
user
so
they
know
where
they
tapped
this
.
highlighters
.
showHighlighterTypeForNode
(
this
.
highlighters
.
TYPES
.
BOXMODEL
nodeFront
{
duration
:
this
.
HIGHLIGHTER_AUTOHIDE_TIMER
}
)
;
return
;
}
this
.
highlighters
.
hideHighlighterType
(
this
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
async
inspectNodeActor
(
nodeGrip
reason
)
{
const
nodeFront
=
await
this
.
inspectorFront
.
getNodeFrontFromNodeGrip
(
nodeGrip
)
;
if
(
!
nodeFront
)
{
console
.
error
(
"
The
object
cannot
be
linked
to
the
inspector
the
"
+
"
corresponding
nodeFront
could
not
be
found
.
"
)
;
return
false
;
}
const
isAttached
=
await
this
.
walker
.
isInDOMTree
(
nodeFront
)
;
if
(
!
isAttached
)
{
console
.
error
(
"
Selected
DOMNode
is
not
attached
to
the
document
tree
.
"
)
;
return
false
;
}
await
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
}
)
;
return
true
;
}
/
*
*
*
Called
by
toolbox
.
js
on
Esc
keydown
.
*
*
param
{
AbortController
}
abortController
*
/
onToolboxChromeEventHandlerEscapeKeyDown
(
abortController
)
{
/
/
If
the
event
tooltip
is
displayed
hide
it
and
prevent
the
Esc
event
listener
/
/
of
the
toolbox
to
occur
(
e
.
g
.
don
'
t
toggle
split
console
)
if
(
this
.
markup
.
hasEventDetailsTooltip
(
)
&
&
this
.
markup
.
eventDetailsTooltip
.
isVisible
(
)
)
{
this
.
markup
.
eventDetailsTooltip
.
hide
(
)
;
abortController
.
abort
(
)
;
}
}
}
exports
.
Inspector
=
Inspector
;
