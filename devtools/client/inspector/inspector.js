"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
executeSoon
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
const
ReflowTracker
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
reflow
-
tracker
"
)
;
const
Store
=
require
(
"
devtools
/
client
/
inspector
/
store
"
)
;
const
InspectorStyleChangeTracker
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
style
-
change
-
tracker
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
initCssProperties
"
"
devtools
/
shared
/
fronts
/
css
-
properties
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HTMLBreadcrumbs
"
"
devtools
/
client
/
inspector
/
breadcrumbs
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorSearch
"
"
devtools
/
client
/
inspector
/
inspector
-
search
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
inspector
/
toolsidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
MarkupView
"
"
devtools
/
client
/
inspector
/
markup
/
markup
"
)
;
loader
.
lazyRequireGetter
(
this
"
HighlightersOverlay
"
"
devtools
/
client
/
inspector
/
shared
/
highlighters
-
overlay
"
)
;
loader
.
lazyRequireGetter
(
this
"
ExtensionSidebar
"
"
devtools
/
client
/
inspector
/
extensions
/
extension
-
sidebar
"
)
;
loader
.
lazyRequireGetter
(
this
"
saveScreenshot
"
"
devtools
/
shared
/
screenshot
/
save
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
loader
.
lazyImporter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
const
{
LocalizationHelper
localizeMarkup
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
INITIAL_SIDEBAR_SIZE
=
350
;
const
LAZY_RESIZE_INTERVAL_MS
=
200
;
const
PORTRAIT_MODE_WIDTH_THRESHOLD
=
700
;
const
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
=
1000
;
const
THREE_PANE_ENABLED_PREF
=
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
;
const
THREE_PANE_ENABLED_SCALAR
=
"
devtools
.
inspector
.
three_pane_enabled
"
;
const
THREE_PANE_CHROME_ENABLED_PREF
=
"
devtools
.
inspector
.
chrome
.
three
-
pane
-
enabled
"
;
const
TELEMETRY_EYEDROPPER_OPENED
=
"
devtools
.
toolbar
.
eyedropper
.
opened
"
;
const
TELEMETRY_SCALAR_NODE_SELECTION_COUNT
=
"
devtools
.
inspector
.
node_selection_count
"
;
function
Inspector
(
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_target
=
toolbox
.
target
;
this
.
panelDoc
=
window
.
document
;
this
.
panelWin
=
window
;
this
.
panelWin
.
inspector
=
this
;
this
.
telemetry
=
toolbox
.
telemetry
;
this
.
store
=
Store
(
{
createObjectClient
:
object
=
>
{
return
new
ObjectClient
(
toolbox
.
target
.
client
object
)
;
}
releaseActor
:
actor
=
>
{
if
(
!
actor
)
{
return
;
}
toolbox
.
target
.
client
.
release
(
actor
)
;
}
}
)
;
this
.
_panels
=
new
Map
(
)
;
this
.
_clearSearchResultsLabel
=
this
.
_clearSearchResultsLabel
.
bind
(
this
)
;
this
.
_handleRejectionIfNotDestroyed
=
this
.
_handleRejectionIfNotDestroyed
.
bind
(
this
)
;
this
.
_onBeforeNavigate
=
this
.
_onBeforeNavigate
.
bind
(
this
)
;
this
.
_onMarkupFrameLoad
=
this
.
_onMarkupFrameLoad
.
bind
(
this
)
;
this
.
_updateSearchResultsLabel
=
this
.
_updateSearchResultsLabel
.
bind
(
this
)
;
this
.
onDetached
=
this
.
onDetached
.
bind
(
this
)
;
this
.
onHostChanged
=
this
.
onHostChanged
.
bind
(
this
)
;
this
.
onMarkupLoaded
=
this
.
onMarkupLoaded
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
onNewRoot
=
this
.
onNewRoot
.
bind
(
this
)
;
this
.
onPanelWindowResize
=
this
.
onPanelWindowResize
.
bind
(
this
)
;
this
.
onShowBoxModelHighlighterForNode
=
this
.
onShowBoxModelHighlighterForNode
.
bind
(
this
)
;
this
.
onSidebarHidden
=
this
.
onSidebarHidden
.
bind
(
this
)
;
this
.
onSidebarResized
=
this
.
onSidebarResized
.
bind
(
this
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
onSidebarShown
=
this
.
onSidebarShown
.
bind
(
this
)
;
this
.
onSidebarToggle
=
this
.
onSidebarToggle
.
bind
(
this
)
;
this
.
handleThreadPaused
=
this
.
handleThreadPaused
.
bind
(
this
)
;
this
.
handleThreadResumed
=
this
.
handleThreadResumed
.
bind
(
this
)
;
}
Inspector
.
prototype
=
{
async
init
(
)
{
localizeMarkup
(
this
.
panelDoc
)
;
if
(
this
.
currentTarget
.
isReplayEnabled
(
)
)
{
let
dbg
=
this
.
_toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
!
dbg
)
{
dbg
=
await
this
.
_toolbox
.
loadTool
(
"
jsdebugger
"
)
;
}
this
.
_replayResumed
=
!
dbg
.
isPaused
(
)
;
this
.
currentTarget
.
threadFront
.
on
(
"
paused
"
this
.
handleThreadPaused
)
;
this
.
currentTarget
.
threadFront
.
on
(
"
resumed
"
this
.
handleThreadResumed
)
;
}
await
this
.
initInspectorFront
(
)
;
this
.
currentTarget
.
on
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
await
Promise
.
all
(
[
this
.
_getCssProperties
(
)
this
.
_getPageStyle
(
)
this
.
_getDefaultSelection
(
)
this
.
_getAccessibilityFront
(
)
this
.
_getChangesFront
(
)
]
)
;
this
.
previousURL
=
this
.
currentTarget
.
url
;
this
.
reflowTracker
=
new
ReflowTracker
(
this
.
currentTarget
)
;
this
.
styleChangeTracker
=
new
InspectorStyleChangeTracker
(
this
)
;
this
.
_markupBox
=
this
.
panelDoc
.
getElementById
(
"
markup
-
box
"
)
;
return
this
.
_deferredOpen
(
)
;
}
async
initInspectorFront
(
)
{
this
.
inspectorFront
=
await
this
.
currentTarget
.
getFront
(
"
inspector
"
)
;
this
.
highlighter
=
this
.
inspectorFront
.
highlighter
;
this
.
walker
=
this
.
inspectorFront
.
walker
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
highlighters
(
)
{
if
(
!
this
.
_highlighters
)
{
this
.
_highlighters
=
new
HighlightersOverlay
(
this
)
;
}
return
this
.
_highlighters
;
}
get
isHighlighterReady
(
)
{
return
!
!
this
.
_highlighters
;
}
get
is3PaneModeEnabled
(
)
{
if
(
this
.
currentTarget
.
chrome
)
{
if
(
!
this
.
_is3PaneModeChromeEnabled
)
{
this
.
_is3PaneModeChromeEnabled
=
Services
.
prefs
.
getBoolPref
(
THREE_PANE_CHROME_ENABLED_PREF
)
;
}
return
this
.
_is3PaneModeChromeEnabled
;
}
if
(
!
this
.
_is3PaneModeEnabled
)
{
this
.
_is3PaneModeEnabled
=
Services
.
prefs
.
getBoolPref
(
THREE_PANE_ENABLED_PREF
)
;
}
return
this
.
_is3PaneModeEnabled
;
}
set
is3PaneModeEnabled
(
value
)
{
if
(
this
.
currentTarget
.
chrome
)
{
this
.
_is3PaneModeChromeEnabled
=
value
;
Services
.
prefs
.
setBoolPref
(
THREE_PANE_CHROME_ENABLED_PREF
this
.
_is3PaneModeChromeEnabled
)
;
}
else
{
this
.
_is3PaneModeEnabled
=
value
;
Services
.
prefs
.
setBoolPref
(
THREE_PANE_ENABLED_PREF
this
.
_is3PaneModeEnabled
)
;
}
}
get
search
(
)
{
if
(
!
this
.
_search
)
{
this
.
_search
=
new
InspectorSearch
(
this
this
.
searchBox
this
.
searchClearButton
)
;
}
return
this
.
_search
;
}
get
selection
(
)
{
return
this
.
toolbox
.
selection
;
}
get
cssProperties
(
)
{
return
this
.
_cssProperties
.
cssProperties
;
}
_handleRejectionIfNotDestroyed
:
function
(
e
)
{
if
(
!
this
.
_destroyed
)
{
console
.
error
(
e
)
;
}
}
_deferredOpen
:
async
function
(
)
{
const
onMarkupLoaded
=
this
.
once
(
"
markuploaded
"
)
;
this
.
_initMarkup
(
)
;
this
.
isReady
=
false
;
if
(
this
.
_defaultNode
)
{
this
.
selection
.
setNodeFront
(
this
.
_defaultNode
{
reason
:
"
inspector
-
open
"
}
)
;
}
this
.
setupSplitter
(
)
;
this
.
panelDoc
.
getElementById
(
"
inspector
-
main
-
content
"
)
.
style
.
visibility
=
"
visible
"
;
await
this
.
setupSidebar
(
)
;
await
onMarkupLoaded
;
this
.
isReady
=
true
;
this
.
breadcrumbs
=
new
HTMLBreadcrumbs
(
this
)
;
this
.
setupExtensionSidebars
(
)
;
this
.
setupSearchBox
(
)
;
await
this
.
setupToolbar
(
)
;
this
.
onNewSelection
(
)
;
this
.
walker
.
on
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
toolbox
.
on
(
"
host
-
changed
"
this
.
onHostChanged
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetached
)
;
this
.
telemetry
.
keyedScalarAdd
(
THREE_PANE_ENABLED_SCALAR
this
.
is3PaneModeEnabled
1
)
;
this
.
emit
(
"
ready
"
)
;
return
this
;
}
_onBeforeNavigate
:
function
(
)
{
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
this
.
_pendingSelection
=
null
;
}
_getCssProperties
:
function
(
)
{
return
initCssProperties
(
this
.
toolbox
)
.
then
(
cssProperties
=
>
{
this
.
_cssProperties
=
cssProperties
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
_getAccessibilityFront
:
async
function
(
)
{
this
.
accessibilityFront
=
await
this
.
currentTarget
.
getFront
(
"
accessibility
"
)
;
return
this
.
accessibilityFront
;
}
_getChangesFront
:
async
function
(
)
{
this
.
changesFront
=
await
this
.
currentTarget
.
getFront
(
"
changes
"
)
;
await
this
.
changesFront
.
start
(
)
;
return
this
.
changesFront
;
}
_getDefaultSelection
:
function
(
)
{
return
this
.
_getDefaultNodeForSelection
(
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
}
_getPageStyle
:
function
(
)
{
return
this
.
inspectorFront
.
getPageStyle
(
)
.
then
(
pageStyle
=
>
{
this
.
pageStyle
=
pageStyle
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
_getDefaultNodeForSelection
:
function
(
)
{
if
(
this
.
_defaultNode
)
{
return
this
.
_defaultNode
;
}
const
walker
=
this
.
walker
;
let
rootNode
=
null
;
const
pendingSelection
=
this
.
_pendingSelection
;
const
hasNavigated
=
(
)
=
>
{
return
pendingSelection
!
=
=
this
.
_pendingSelection
|
|
this
.
_replayResumed
;
}
;
return
walker
.
getRootNode
(
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
rootNode
=
node
;
if
(
this
.
selectionCssSelector
)
{
return
walker
.
querySelector
(
rootNode
this
.
selectionCssSelector
)
;
}
return
null
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
walker
.
querySelector
(
rootNode
"
body
"
)
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
this
.
walker
.
documentElement
(
)
;
}
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
this
.
_defaultNode
=
node
;
return
node
;
}
)
;
}
get
currentTarget
(
)
{
return
this
.
_target
;
}
setupSearchBox
:
function
(
)
{
this
.
searchBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchbox
"
)
;
this
.
searchClearButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchinput
-
clear
"
)
;
this
.
searchResultsContainer
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
-
container
"
)
;
this
.
searchResultsLabel
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
"
)
;
this
.
searchBox
.
addEventListener
(
"
focus
"
(
)
=
>
{
this
.
search
.
on
(
"
search
-
cleared
"
this
.
_clearSearchResultsLabel
)
;
this
.
search
.
on
(
"
search
-
result
"
this
.
_updateSearchResultsLabel
)
;
}
{
once
:
true
}
)
;
this
.
createSearchBoxShortcuts
(
)
;
}
createSearchBoxShortcuts
(
)
{
this
.
searchboxShortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
panelDoc
.
defaultView
target
:
this
.
toolbox
.
getChromeEventHandler
(
)
}
)
;
const
key
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
;
this
.
searchboxShortcuts
.
on
(
key
event
=
>
{
if
(
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
|
|
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
computedview
"
)
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
}
get
searchSuggestions
(
)
{
return
this
.
search
.
autocompleter
;
}
_clearSearchResultsLabel
:
function
(
result
)
{
return
this
.
_updateSearchResultsLabel
(
result
true
)
;
}
_updateSearchResultsLabel
:
function
(
result
clear
=
false
)
{
let
str
=
"
"
;
if
(
!
clear
)
{
if
(
result
)
{
str
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
searchResultsCount2
"
result
.
resultsIndex
+
1
result
.
resultsLength
)
;
}
else
{
str
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchResultsNone
"
)
;
}
this
.
searchResultsContainer
.
hidden
=
false
;
}
else
{
this
.
searchResultsContainer
.
hidden
=
true
;
}
this
.
searchResultsLabel
.
textContent
=
str
;
}
get
React
(
)
{
return
this
.
_toolbox
.
React
;
}
get
ReactDOM
(
)
{
return
this
.
_toolbox
.
ReactDOM
;
}
get
ReactRedux
(
)
{
return
this
.
_toolbox
.
ReactRedux
;
}
get
browserRequire
(
)
{
return
this
.
_toolbox
.
browserRequire
;
}
get
InspectorTabPanel
(
)
{
if
(
!
this
.
_InspectorTabPanel
)
{
this
.
_InspectorTabPanel
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
components
/
InspectorTabPanel
"
)
)
;
}
return
this
.
_InspectorTabPanel
;
}
get
InspectorSplitBox
(
)
{
if
(
!
this
.
_InspectorSplitBox
)
{
this
.
_InspectorSplitBox
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
splitter
/
SplitBox
"
)
)
;
}
return
this
.
_InspectorSplitBox
;
}
get
TabBar
(
)
{
if
(
!
this
.
_TabBar
)
{
this
.
_TabBar
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
tabs
/
TabBar
"
)
)
;
}
return
this
.
_TabBar
;
}
useLandscapeMode
:
function
(
)
{
if
(
!
this
.
panelDoc
)
{
return
true
;
}
const
splitterBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
const
{
width
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
splitterBox
)
;
return
this
.
is3PaneModeEnabled
&
&
(
this
.
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
LEFT
|
|
this
.
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
RIGHT
)
?
width
>
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
:
width
>
PORTRAIT_MODE_WIDTH_THRESHOLD
;
}
setupSplitter
:
function
(
)
{
const
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
sidebarSplitBoxRef
=
this
.
React
.
createRef
(
)
;
const
splitter
=
this
.
InspectorSplitBox
(
{
className
:
"
inspector
-
sidebar
-
splitter
"
initialWidth
:
width
initialHeight
:
height
minSize
:
"
10
%
"
maxSize
:
"
80
%
"
splitterSize
:
1
endPanelControl
:
true
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
main
-
content
"
}
)
endPanel
:
this
.
InspectorSplitBox
(
{
initialWidth
:
splitSidebarWidth
minSize
:
10
maxSize
:
"
80
%
"
splitterSize
:
this
.
is3PaneModeEnabled
?
1
:
0
endPanelControl
:
this
.
is3PaneModeEnabled
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
rules
-
container
"
}
)
endPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
sidebar
-
container
"
}
)
ref
:
this
.
sidebarSplitBoxRef
}
)
vert
:
this
.
useLandscapeMode
(
)
onControlledPanelResized
:
this
.
onSidebarResized
}
)
;
this
.
splitBox
=
this
.
ReactDOM
.
render
(
splitter
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
)
;
this
.
panelWin
.
addEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
}
_onLazyPanelResize
:
async
function
(
)
{
if
(
window
.
closed
)
{
return
;
}
this
.
splitBox
.
setState
(
{
vert
:
this
.
useLandscapeMode
(
)
}
)
;
this
.
emit
(
"
inspector
-
resize
"
)
;
}
onPanelWindowResize
:
function
(
)
{
if
(
this
.
toolbox
.
currentToolId
!
=
=
"
inspector
"
)
{
return
;
}
if
(
!
this
.
_lazyResizeHandler
)
{
this
.
_lazyResizeHandler
=
new
DeferredTask
(
this
.
_onLazyPanelResize
.
bind
(
this
)
LAZY_RESIZE_INTERVAL_MS
0
)
;
}
this
.
_lazyResizeHandler
.
arm
(
)
;
}
getSidebarSize
:
function
(
)
{
let
width
;
let
height
;
let
splitSidebarWidth
;
try
{
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
)
;
splitSidebarWidth
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
)
;
}
catch
(
e
)
{
width
=
this
.
is3PaneModeEnabled
?
INITIAL_SIDEBAR_SIZE
*
2
:
INITIAL_SIDEBAR_SIZE
;
height
=
INITIAL_SIDEBAR_SIZE
;
splitSidebarWidth
=
INITIAL_SIDEBAR_SIZE
;
}
return
{
width
height
splitSidebarWidth
}
;
}
onSidebarHidden
:
function
(
)
{
const
state
=
this
.
splitBox
.
state
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
state
.
width
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
state
.
height
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
this
.
sidebarSplitBoxRef
.
current
.
state
.
width
)
;
}
onSidebarResized
:
function
(
width
height
)
{
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
resized
"
{
width
height
}
)
;
}
onSidebarSelect
:
function
(
toolId
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
toolId
)
;
this
.
getPanel
(
toolId
)
;
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
select
"
toolId
)
;
}
onSidebarShown
:
function
(
)
{
const
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
splitBox
.
setState
(
{
width
height
}
)
;
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
width
:
splitSidebarWidth
}
)
;
}
async
onSidebarToggle
(
)
{
this
.
is3PaneModeEnabled
=
!
this
.
is3PaneModeEnabled
;
await
this
.
setupToolbar
(
)
;
await
this
.
addRuleView
(
{
skipQueue
:
true
}
)
;
}
setSidebarSplitBoxState
(
)
{
const
toolboxWidth
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
.
clientWidth
;
const
sidebarWidth
=
this
.
splitBox
.
state
.
width
;
let
sidebarSplitboxWidth
;
if
(
this
.
useLandscapeMode
(
)
)
{
const
canDoubleSidebarWidth
=
sidebarWidth
*
2
<
toolboxWidth
/
2
;
this
.
splitBox
.
setState
(
{
width
:
canDoubleSidebarWidth
?
sidebarWidth
*
2
:
(
toolboxWidth
*
2
)
/
3
}
)
;
sidebarSplitboxWidth
=
canDoubleSidebarWidth
?
sidebarWidth
:
toolboxWidth
/
3
;
}
else
{
sidebarSplitboxWidth
=
toolboxWidth
/
2
;
}
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
endPanelControl
:
true
splitterSize
:
1
width
:
sidebarSplitboxWidth
}
)
;
}
async
addRuleView
(
{
defaultTab
=
"
ruleview
"
skipQueue
=
false
}
=
{
}
)
{
const
ruleViewSidebar
=
this
.
sidebarSplitBoxRef
.
current
.
startPanelContainer
;
if
(
this
.
is3PaneModeEnabled
)
{
ruleViewSidebar
.
style
.
display
=
"
block
"
;
this
.
setSidebarSplitBoxState
(
)
;
this
.
getPanel
(
"
ruleview
"
)
;
await
this
.
sidebar
.
removeTab
(
"
ruleview
"
)
;
this
.
ruleViewSideBar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
)
;
this
.
ruleViewSideBar
.
show
(
)
;
}
else
{
ruleViewSidebar
.
style
.
display
=
"
none
"
;
const
splitterBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
this
.
splitBox
.
setState
(
{
width
:
this
.
useLandscapeMode
(
)
?
this
.
sidebarSplitBoxRef
.
current
.
state
.
width
:
splitterBox
.
clientWidth
}
)
;
this
.
sidebarSplitBoxRef
.
current
.
setState
(
{
endPanelControl
:
false
splitterSize
:
0
}
)
;
this
.
ruleViewSideBar
.
hide
(
)
;
await
this
.
ruleViewSideBar
.
removeTab
(
"
ruleview
"
)
;
if
(
skipQueue
)
{
this
.
sidebar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
defaultTab
=
=
"
ruleview
"
0
)
;
}
else
{
this
.
sidebar
.
queueExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
defaultTab
=
=
"
ruleview
"
0
)
;
}
}
this
.
emit
(
"
ruleview
-
added
"
)
;
}
hasPanel
:
function
(
id
)
{
return
this
.
_panels
.
has
(
id
)
;
}
getPanel
:
function
(
id
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
return
this
.
_panels
.
get
(
id
)
;
}
let
panel
;
switch
(
id
)
{
case
"
animationinspector
"
:
const
AnimationInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
animation
/
animation
"
)
;
panel
=
new
AnimationInspector
(
this
this
.
panelWin
)
;
break
;
case
"
boxmodel
"
:
const
BoxModel
=
require
(
"
devtools
/
client
/
inspector
/
boxmodel
/
box
-
model
"
)
;
panel
=
new
BoxModel
(
this
this
.
panelWin
)
;
break
;
case
"
changesview
"
:
const
ChangesView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
changes
/
ChangesView
"
)
;
panel
=
new
ChangesView
(
this
this
.
panelWin
)
;
break
;
case
"
compatibilityview
"
:
const
CompatibilityView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
compatibility
/
CompatibilityView
"
)
;
panel
=
new
CompatibilityView
(
this
this
.
panelWin
)
;
break
;
case
"
computedview
"
:
const
{
ComputedViewTool
}
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
computed
/
computed
"
)
;
panel
=
new
ComputedViewTool
(
this
this
.
panelWin
)
;
break
;
case
"
fontinspector
"
:
const
FontInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
fonts
/
fonts
"
)
;
panel
=
new
FontInspector
(
this
this
.
panelWin
)
;
break
;
case
"
layoutview
"
:
const
LayoutView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
layout
/
layout
"
)
;
panel
=
new
LayoutView
(
this
this
.
panelWin
)
;
break
;
case
"
newruleview
"
:
const
RulesView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
rules
/
new
-
rules
"
)
;
panel
=
new
RulesView
(
this
this
.
panelWin
)
;
break
;
case
"
ruleview
"
:
const
{
RuleViewTool
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
;
panel
=
new
RuleViewTool
(
this
this
.
panelWin
)
;
break
;
default
:
return
null
;
}
if
(
panel
)
{
this
.
_panels
.
set
(
id
panel
)
;
}
return
panel
;
}
async
setupSidebar
(
)
{
const
sidebar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
sidebar
"
)
;
const
options
=
{
showAllTabsMenu
:
true
sidebarToggleButton
:
{
collapsed
:
!
this
.
is3PaneModeEnabled
collapsePaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
hideThreePaneMode
"
)
expandPaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
showThreePaneMode
"
)
onClick
:
this
.
onSidebarToggle
}
}
;
this
.
sidebar
=
new
ToolSidebar
(
sidebar
this
"
inspector
"
options
)
;
this
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
const
ruleSideBar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
rules
-
sidebar
"
)
;
this
.
ruleViewSideBar
=
new
ToolSidebar
(
ruleSideBar
this
"
inspector
"
{
hideTabstripe
:
true
}
)
;
let
defaultTab
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
if
(
this
.
is3PaneModeEnabled
&
&
defaultTab
=
=
=
"
ruleview
"
)
{
defaultTab
=
"
layoutview
"
;
}
await
this
.
addRuleView
(
{
defaultTab
}
)
;
const
sidebarPanels
=
[
{
id
:
"
layoutview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
layoutViewTitle2
"
)
}
{
id
:
"
computedview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
computedViewTitle
"
)
}
{
id
:
"
changesview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
changesViewTitle
"
)
}
{
id
:
"
fontinspector
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
}
{
id
:
"
animationinspector
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
animationInspectorTitle
"
)
}
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
new
-
rulesview
.
enabled
"
)
)
{
sidebarPanels
.
push
(
{
id
:
"
newruleview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
}
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
compatibility
.
enabled
"
)
)
{
sidebarPanels
.
push
(
{
id
:
"
compatibilityview
"
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
compatibilityViewTitle
"
)
}
)
;
}
for
(
const
{
id
title
}
of
sidebarPanels
)
{
if
(
id
=
=
=
"
computedview
"
)
{
this
.
sidebar
.
queueExistingTab
(
id
title
defaultTab
=
=
=
id
)
;
}
else
{
this
.
sidebar
.
queueTab
(
id
title
{
props
:
{
id
title
}
panel
:
(
)
=
>
{
return
this
.
getPanel
(
id
)
.
provider
;
}
}
defaultTab
=
=
=
id
)
;
}
}
this
.
sidebar
.
addAllQueuedTabs
(
)
;
this
.
sidebar
.
on
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
on
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
on
(
"
destroy
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
show
(
)
;
}
setupExtensionSidebars
(
)
{
for
(
const
[
sidebarId
{
title
}
]
of
this
.
toolbox
.
inspectorExtensionSidebars
)
{
this
.
addExtensionSidebar
(
sidebarId
{
title
}
)
;
}
}
addExtensionSidebar
:
function
(
id
{
title
}
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Cannot
create
an
extension
sidebar
for
the
existent
id
:
{
id
}
)
;
}
const
extensionSidebar
=
new
ExtensionSidebar
(
this
{
id
title
}
)
;
this
.
addSidebarTab
(
id
title
extensionSidebar
.
provider
false
)
;
this
.
_panels
.
set
(
id
extensionSidebar
)
;
this
.
toolbox
.
emit
(
extension
-
sidebar
-
created
-
{
id
}
extensionSidebar
)
;
}
removeExtensionSidebar
:
function
(
id
)
{
if
(
!
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Unable
to
find
a
sidebar
panel
with
id
"
{
id
}
"
)
;
}
const
panel
=
this
.
_panels
.
get
(
id
)
;
if
(
!
(
panel
instanceof
ExtensionSidebar
)
)
{
throw
new
Error
(
The
sidebar
panel
with
id
"
{
id
}
"
is
not
an
ExtensionSidebar
)
;
}
this
.
_panels
.
delete
(
id
)
;
this
.
sidebar
.
removeTab
(
id
)
;
panel
.
destroy
(
)
;
}
addSidebarTab
:
function
(
id
title
panel
selected
)
{
this
.
sidebar
.
addTab
(
id
title
panel
selected
)
;
}
async
supportsEyeDropper
(
)
{
try
{
return
await
this
.
inspectorFront
.
supportsHighlighters
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
false
;
}
}
async
setupToolbar
(
)
{
this
.
teardownToolbar
(
)
;
this
.
addNode
=
this
.
addNode
.
bind
(
this
)
;
this
.
addNodeButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
this
.
addNodeButton
.
addEventListener
(
"
click
"
this
.
addNode
)
;
const
canShowEyeDropper
=
await
this
.
supportsEyeDropper
(
)
;
if
(
!
this
.
panelDoc
)
{
return
;
}
if
(
canShowEyeDropper
)
{
this
.
onEyeDropperDone
=
this
.
onEyeDropperDone
.
bind
(
this
)
;
this
.
onEyeDropperButtonClicked
=
this
.
onEyeDropperButtonClicked
.
bind
(
this
)
;
this
.
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
this
.
eyeDropperButton
.
disabled
=
false
;
this
.
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
eyedropper
.
label
"
)
;
this
.
eyeDropperButton
.
addEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
}
else
{
const
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
eyeDropperButton
.
disabled
=
true
;
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
eyedropper
.
disabled
.
title
"
)
;
}
this
.
emit
(
"
inspector
-
toolbar
-
updated
"
)
;
}
teardownToolbar
:
function
(
)
{
if
(
this
.
addNodeButton
)
{
this
.
addNodeButton
.
removeEventListener
(
"
click
"
this
.
addNode
)
;
this
.
addNodeButton
=
null
;
}
if
(
this
.
eyeDropperButton
)
{
this
.
eyeDropperButton
.
removeEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
this
.
eyeDropperButton
=
null
;
}
}
onNewRoot
:
function
(
)
{
this
.
_newRootStart
=
this
.
panelWin
.
performance
.
now
(
)
;
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
const
onNodeSelected
=
defaultNode
=
>
{
if
(
this
.
_pendingSelection
!
=
onNodeSelected
)
{
return
;
}
this
.
_pendingSelection
=
null
;
this
.
selection
.
setNodeFront
(
defaultNode
{
reason
:
"
navigateaway
"
}
)
;
this
.
once
(
"
markuploaded
"
this
.
onMarkupLoaded
)
;
this
.
_initMarkup
(
)
;
this
.
setupToolbar
(
)
;
}
;
this
.
_pendingSelection
=
onNodeSelected
;
this
.
_getDefaultNodeForSelection
(
)
.
then
(
onNodeSelected
this
.
_handleRejectionIfNotDestroyed
)
;
}
handleThreadPaused
(
)
{
this
.
_replayResumed
=
false
;
this
.
onNewRoot
(
)
;
}
handleThreadResumed
(
)
{
this
.
_replayResumed
=
true
;
this
.
onNewRoot
(
)
;
}
async
onMarkupLoaded
(
)
{
if
(
!
this
.
markup
)
{
return
;
}
const
onExpand
=
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
if
(
this
.
_highlighters
)
{
await
Promise
.
all
(
[
this
.
highlighters
.
restoreFlexboxState
(
)
this
.
highlighters
.
restoreGridState
(
)
]
)
;
}
this
.
emit
(
"
new
-
root
"
)
;
await
onExpand
;
this
.
emit
(
"
reloaded
"
)
;
if
(
this
.
_newRootStart
)
{
if
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
=
=
"
inspector
"
)
{
const
delay
=
this
.
panelWin
.
performance
.
now
(
)
-
this
.
_newRootStart
;
const
telemetryKey
=
"
DEVTOOLS_INSPECTOR_NEW_ROOT_TO_RELOAD_DELAY_MS
"
;
const
histogram
=
this
.
telemetry
.
getHistogramById
(
telemetryKey
)
;
histogram
.
add
(
delay
)
;
}
delete
this
.
_newRootStart
;
}
}
_selectionCssSelector
:
null
set
selectionCssSelector
(
cssSelector
=
null
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_selectionCssSelector
=
{
selector
:
cssSelector
url
:
this
.
_target
.
url
}
;
}
get
selectionCssSelector
(
)
{
if
(
this
.
_selectionCssSelector
&
&
this
.
_selectionCssSelector
.
url
=
=
=
this
.
_target
.
url
)
{
return
this
.
_selectionCssSelector
.
selector
;
}
return
null
;
}
updateSelectionCssSelector
(
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
this
.
selection
.
nodeFront
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
this
.
selectionCssSelector
=
selector
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
}
canAddHTMLChild
:
function
(
)
{
const
selection
=
this
.
selection
;
const
invalidTagNames
=
[
"
html
"
"
iframe
"
]
;
return
(
selection
.
isHTMLNode
(
)
&
&
selection
.
isElementNode
(
)
&
&
!
selection
.
isPseudoElementNode
(
)
&
&
!
selection
.
isAnonymousNode
(
)
&
&
!
invalidTagNames
.
includes
(
selection
.
nodeFront
.
nodeName
.
toLowerCase
(
)
)
)
;
}
updateAddElementButton
(
)
{
const
btn
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
btn
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
btn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
async
onHostChanged
(
)
{
await
this
.
_onLazyPanelResize
(
)
;
if
(
!
this
.
currentTarget
|
|
!
this
.
is3PaneModeEnabled
)
{
return
;
}
this
.
searchboxShortcuts
.
destroy
(
)
;
this
.
createSearchBoxShortcuts
(
)
;
this
.
setSidebarSplitBoxState
(
)
;
}
onNewSelection
:
function
(
value
reason
)
{
if
(
reason
=
=
=
"
selection
-
destroy
"
)
{
return
;
}
this
.
updateAddElementButton
(
)
;
this
.
updateSelectionCssSelector
(
)
;
const
selfUpdate
=
this
.
updating
(
"
inspector
-
panel
"
)
;
executeSoon
(
(
)
=
>
{
try
{
selfUpdate
(
this
.
selection
.
nodeFront
)
;
this
.
telemetry
.
scalarAdd
(
TELEMETRY_SCALAR_NODE_SELECTION_COUNT
1
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
)
;
}
updating
:
function
(
name
)
{
if
(
this
.
_updateProgress
&
&
this
.
_updateProgress
.
node
!
=
this
.
selection
.
nodeFront
)
{
this
.
cancelUpdate
(
)
;
}
if
(
!
this
.
_updateProgress
)
{
const
self
=
this
;
this
.
_updateProgress
=
{
node
:
this
.
selection
.
nodeFront
outstanding
:
new
Set
(
)
checkDone
:
function
(
)
{
if
(
this
!
=
=
self
.
_updateProgress
)
{
return
;
}
if
(
!
self
.
selection
|
|
this
.
node
!
=
=
self
.
selection
.
nodeFront
)
{
self
.
cancelUpdate
(
)
;
return
;
}
if
(
this
.
outstanding
.
size
!
=
=
0
)
{
return
;
}
self
.
_updateProgress
=
null
;
self
.
emit
(
"
inspector
-
updated
"
name
)
;
}
}
;
}
const
progress
=
this
.
_updateProgress
;
const
done
=
function
(
)
{
progress
.
outstanding
.
delete
(
done
)
;
progress
.
checkDone
(
)
;
}
;
progress
.
outstanding
.
add
(
done
)
;
return
done
;
}
cancelUpdate
:
function
(
)
{
this
.
_updateProgress
=
null
;
}
onDetached
:
function
(
parentNode
)
{
this
.
breadcrumbs
.
cutAfter
(
this
.
breadcrumbs
.
indexOf
(
parentNode
)
)
;
const
nodeFront
=
parentNode
?
parentNode
:
this
.
_defaultNode
;
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
detached
"
}
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
this
.
_target
.
threadFront
.
off
(
"
paused
"
this
.
handleThreadPaused
)
;
this
.
_target
.
threadFront
.
off
(
"
resumed
"
this
.
handleThreadResumed
)
;
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
pageStyle
=
null
;
}
this
.
cancelUpdate
(
)
;
this
.
sidebar
.
destroy
(
)
;
this
.
panelWin
.
removeEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
onDetached
)
;
this
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
sidebar
.
off
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
off
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
off
(
"
destroy
"
this
.
onSidebarHidden
)
;
this
.
currentTarget
.
off
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
for
(
const
[
panel
]
of
this
.
_panels
)
{
panel
.
destroy
(
)
;
}
this
.
_panels
.
clear
(
)
;
if
(
this
.
_highlighters
)
{
this
.
_highlighters
.
destroy
(
)
;
this
.
_highlighters
=
null
;
}
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
}
if
(
this
.
_search
)
{
this
.
_search
.
destroy
(
)
;
this
.
_search
=
null
;
}
this
.
sidebar
.
destroy
(
)
;
if
(
this
.
ruleViewSideBar
)
{
this
.
ruleViewSideBar
.
destroy
(
)
;
}
this
.
_destroyMarkup
(
)
;
this
.
teardownToolbar
(
)
;
this
.
breadcrumbs
.
destroy
(
)
;
this
.
reflowTracker
.
destroy
(
)
;
this
.
styleChangeTracker
.
destroy
(
)
;
this
.
searchboxShortcuts
.
destroy
(
)
;
this
.
_is3PaneModeChromeEnabled
=
null
;
this
.
_is3PaneModeEnabled
=
null
;
this
.
_markupBox
=
null
;
this
.
_markupFrame
=
null
;
this
.
_target
=
null
;
this
.
_toolbox
=
null
;
this
.
breadcrumbs
=
null
;
this
.
panelDoc
=
null
;
this
.
panelWin
.
inspector
=
null
;
this
.
panelWin
=
null
;
this
.
resultsLength
=
null
;
this
.
searchBox
=
null
;
this
.
show3PaneTooltip
=
null
;
this
.
sidebar
=
null
;
this
.
store
=
null
;
this
.
telemetry
=
null
;
}
_initMarkup
:
function
(
)
{
if
(
!
this
.
_markupFrame
)
{
this
.
_markupFrame
=
this
.
panelDoc
.
createElement
(
"
iframe
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
aria
-
label
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
panelLabel
.
markupView
"
)
)
;
this
.
_markupFrame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
this
.
_markupBox
.
style
.
visibility
=
"
hidden
"
;
this
.
_markupBox
.
appendChild
(
this
.
_markupFrame
)
;
this
.
_markupFrame
.
addEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
setAttribute
(
"
src
"
"
markup
/
markup
.
xhtml
"
)
;
}
else
{
this
.
_onMarkupFrameLoad
(
)
;
}
}
_onMarkupFrameLoad
:
function
(
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
contentWindow
.
focus
(
)
;
this
.
_markupBox
.
style
.
visibility
=
"
visible
"
;
this
.
markup
=
new
MarkupView
(
this
this
.
_markupFrame
this
.
_toolbox
.
win
)
;
this
.
markup
.
init
(
)
;
this
.
emit
(
"
markuploaded
"
)
;
}
_destroyMarkup
:
function
(
)
{
let
destroyPromise
;
if
(
this
.
markup
)
{
destroyPromise
=
this
.
markup
.
destroy
(
)
;
this
.
markup
=
null
;
}
else
{
destroyPromise
=
promise
.
resolve
(
)
;
}
this
.
_markupBox
.
style
.
visibility
=
"
hidden
"
;
return
destroyPromise
;
}
onEyeDropperButtonClicked
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
contains
(
"
checked
"
)
?
this
.
hideEyeDropper
(
)
:
this
.
showEyeDropper
(
)
;
}
startEyeDropperListeners
:
function
(
)
{
this
.
toolbox
.
tellRDMAboutPickerState
(
true
)
;
this
.
inspectorFront
.
once
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspectorFront
.
once
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
once
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
stopEyeDropperListeners
:
function
(
)
{
this
.
toolbox
.
tellRDMAboutPickerState
(
false
)
;
this
.
inspectorFront
.
off
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspectorFront
.
off
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
off
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
onEyeDropperDone
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
}
showEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
toolbox
.
nodePicker
.
stop
(
)
.
catch
(
console
.
error
)
;
this
.
telemetry
.
scalarSet
(
TELEMETRY_EYEDROPPER_OPENED
1
)
;
this
.
eyeDropperButton
.
classList
.
add
(
"
checked
"
)
;
this
.
startEyeDropperListeners
(
)
;
return
this
.
inspectorFront
.
pickColorFromPage
(
{
copyOnSelect
:
true
}
)
.
catch
(
console
.
error
)
;
}
hideEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
return
this
.
inspectorFront
.
cancelPickColorFromPage
(
)
.
catch
(
console
.
error
)
;
}
async
addNode
(
)
{
if
(
!
this
.
canAddHTMLChild
(
)
)
{
return
;
}
this
.
toolbox
.
nodePicker
.
stop
(
)
;
this
.
hideEyeDropper
(
)
;
const
nodeFront
=
this
.
selection
.
nodeFront
;
const
html
=
"
<
div
>
<
/
div
>
"
;
const
onMutations
=
this
.
once
(
"
markupmutation
"
)
;
await
nodeFront
.
walkerFront
.
insertAdjacentHTML
(
this
.
selection
.
nodeFront
"
beforeEnd
"
html
)
;
await
onMutations
;
this
.
markup
.
expandNode
(
nodeFront
)
;
}
togglePseudoClass
:
function
(
pseudo
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
const
node
=
this
.
selection
.
nodeFront
;
if
(
node
.
hasPseudoClassLock
(
pseudo
)
)
{
return
node
.
walkerFront
.
removePseudoClassLock
(
node
pseudo
{
parents
:
true
}
)
;
}
const
hierarchical
=
pseudo
=
=
"
:
hover
"
|
|
pseudo
=
=
"
:
active
"
;
return
node
.
walkerFront
.
addPseudoClassLock
(
node
pseudo
{
parents
:
hierarchical
}
)
;
}
return
promise
.
resolve
(
)
;
}
async
screenshotNode
(
)
{
await
this
.
highlighter
.
hideBoxModel
(
)
;
const
clipboardEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
clipboard
.
enabled
"
)
;
const
args
=
{
file
:
true
nodeActorID
:
this
.
selection
.
nodeFront
.
actorID
clipboard
:
clipboardEnabled
}
;
const
screenshotFront
=
await
this
.
currentTarget
.
getFront
(
"
screenshot
"
)
;
const
screenshot
=
await
screenshotFront
.
capture
(
args
)
;
await
saveScreenshot
(
this
.
panelWin
args
screenshot
)
;
}
getCommonComponentProps
(
)
{
return
{
setSelectedNode
:
this
.
selection
.
setNodeFront
onShowBoxModelHighlighterForNode
:
this
.
onShowBoxModelHighlighterForNode
}
;
}
onShowBoxModelHighlighterForNode
(
nodeFront
options
)
{
nodeFront
.
highlighterFront
.
highlight
(
nodeFront
options
)
;
}
async
inspectNodeActor
(
nodeActor
inspectFromAnnotation
)
{
const
nodeFront
=
await
this
.
walker
.
gripToNodeFront
(
{
actor
:
nodeActor
}
)
;
if
(
!
nodeFront
)
{
console
.
error
(
"
The
object
cannot
be
linked
to
the
inspector
the
"
+
"
corresponding
nodeFront
could
not
be
found
.
"
)
;
return
false
;
}
const
isAttached
=
await
this
.
walker
.
isInDOMTree
(
nodeFront
)
;
if
(
!
isAttached
)
{
console
.
error
(
"
Selected
DOMNode
is
not
attached
to
the
document
tree
.
"
)
;
return
false
;
}
await
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
inspectFromAnnotation
}
)
;
return
true
;
}
}
;
exports
.
Inspector
=
Inspector
;
