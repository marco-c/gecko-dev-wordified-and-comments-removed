"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
{
executeSoon
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
HighlightersOverlay
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
highlighters
-
overlay
"
)
;
const
ReflowTracker
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
reflow
-
tracker
"
)
;
const
Store
=
require
(
"
devtools
/
client
/
inspector
/
store
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
initCssProperties
"
"
devtools
/
shared
/
fronts
/
css
-
properties
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HTMLBreadcrumbs
"
"
devtools
/
client
/
inspector
/
breadcrumbs
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorSearch
"
"
devtools
/
client
/
inspector
/
inspector
-
search
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
inspector
/
toolsidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
MarkupView
"
"
devtools
/
client
/
inspector
/
markup
/
markup
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
Menu
"
"
devtools
/
client
/
framework
/
menu
"
)
;
loader
.
lazyRequireGetter
(
this
"
MenuItem
"
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
loader
.
lazyRequireGetter
(
this
"
ExtensionSidebar
"
"
devtools
/
client
/
inspector
/
extensions
/
extension
-
sidebar
"
)
;
loader
.
lazyRequireGetter
(
this
"
CommandUtils
"
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
clipboardHelper
"
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
{
LocalizationHelper
localizeMarkup
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
loader
.
lazyGetter
(
this
"
TOOLBOX_L10N
"
function
(
)
{
return
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
}
)
;
const
INITIAL_SIDEBAR_SIZE
=
350
;
const
PORTRAIT_MODE_WIDTH
=
700
;
const
SHOW_SPLIT_SIDEBAR_TOGGLE_PREF
=
"
devtools
.
inspector
.
split
-
sidebar
-
toggle
"
;
const
SPLIT_RULE_VIEW_PREF
=
"
devtools
.
inspector
.
split
-
rule
-
enabled
"
;
function
Inspector
(
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_target
=
toolbox
.
target
;
this
.
panelDoc
=
window
.
document
;
this
.
panelWin
=
window
;
this
.
panelWin
.
inspector
=
this
;
this
.
_panels
=
new
Map
(
)
;
this
.
highlighters
=
new
HighlightersOverlay
(
this
)
;
this
.
prefsObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
reflowTracker
=
new
ReflowTracker
(
this
.
_target
)
;
this
.
store
=
Store
(
)
;
this
.
telemetry
=
new
Telemetry
(
)
;
this
.
previousURL
=
this
.
target
.
url
;
this
.
showSplitSidebarToggle
=
Services
.
prefs
.
getBoolPref
(
SHOW_SPLIT_SIDEBAR_TOGGLE_PREF
)
;
this
.
isSplitRuleViewEnabled
=
Services
.
prefs
.
getBoolPref
(
SPLIT_RULE_VIEW_PREF
)
;
this
.
nodeMenuTriggerInfo
=
null
;
this
.
_handleRejectionIfNotDestroyed
=
this
.
_handleRejectionIfNotDestroyed
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onBeforeNavigate
=
this
.
_onBeforeNavigate
.
bind
(
this
)
;
this
.
_onMarkupFrameLoad
=
this
.
_onMarkupFrameLoad
.
bind
(
this
)
;
this
.
_updateSearchResultsLabel
=
this
.
_updateSearchResultsLabel
.
bind
(
this
)
;
this
.
onDetached
=
this
.
onDetached
.
bind
(
this
)
;
this
.
onMarkupLoaded
=
this
.
onMarkupLoaded
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
onNewRoot
=
this
.
onNewRoot
.
bind
(
this
)
;
this
.
onPanelWindowResize
=
this
.
onPanelWindowResize
.
bind
(
this
)
;
this
.
onShowBoxModelHighlighterForNode
=
this
.
onShowBoxModelHighlighterForNode
.
bind
(
this
)
;
this
.
onSidebarHidden
=
this
.
onSidebarHidden
.
bind
(
this
)
;
this
.
onSidebarResized
=
this
.
onSidebarResized
.
bind
(
this
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
onSidebarShown
=
this
.
onSidebarShown
.
bind
(
this
)
;
this
.
onSidebarToggle
=
this
.
onSidebarToggle
.
bind
(
this
)
;
this
.
onSplitRuleViewPrefChanged
=
this
.
onSplitRuleViewPrefChanged
.
bind
(
this
)
;
this
.
_target
.
on
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
this
.
prefsObserver
.
on
(
SPLIT_RULE_VIEW_PREF
this
.
onSplitRuleViewPrefChanged
)
;
}
Inspector
.
prototype
=
{
init
:
Task
.
async
(
function
*
(
)
{
localizeMarkup
(
this
.
panelDoc
)
;
this
.
_cssPropertiesLoaded
=
initCssProperties
(
this
.
toolbox
)
;
yield
this
.
_cssPropertiesLoaded
;
yield
this
.
target
.
makeRemote
(
)
;
yield
this
.
_getPageStyle
(
)
;
let
defaultSelection
=
yield
this
.
_getDefaultNodeForSelection
(
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
return
yield
this
.
_deferredOpen
(
defaultSelection
)
;
}
)
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
inspector
(
)
{
return
this
.
_toolbox
.
inspector
;
}
get
walker
(
)
{
return
this
.
_toolbox
.
walker
;
}
get
selection
(
)
{
return
this
.
_toolbox
.
selection
;
}
get
highlighter
(
)
{
return
this
.
_toolbox
.
highlighter
;
}
get
isOuterHTMLEditable
(
)
{
return
this
.
_target
.
client
.
traits
.
editOuterHTML
;
}
get
hasUrlToImageDataResolver
(
)
{
return
this
.
_target
.
client
.
traits
.
urlToImageDataResolver
;
}
get
canGetUniqueSelector
(
)
{
return
this
.
_target
.
client
.
traits
.
getUniqueSelector
;
}
get
canGetCssPath
(
)
{
return
this
.
_target
.
client
.
traits
.
getCssPath
;
}
get
canGetXPath
(
)
{
return
this
.
_target
.
client
.
traits
.
getXPath
;
}
get
canGetUsedFontFaces
(
)
{
return
this
.
_target
.
client
.
traits
.
getUsedFontFaces
;
}
get
canPasteInnerOrAdjacentHTML
(
)
{
return
this
.
_target
.
client
.
traits
.
pasteHTML
;
}
_handleRejectionIfNotDestroyed
:
function
(
e
)
{
if
(
!
this
.
_panelDestroyer
)
{
console
.
error
(
e
)
;
}
}
_deferredOpen
:
async
function
(
defaultSelection
)
{
this
.
breadcrumbs
=
new
HTMLBreadcrumbs
(
this
)
;
this
.
walker
.
on
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetached
)
;
if
(
this
.
target
.
isLocalTab
)
{
this
.
updateDebuggerPausedWarning
=
(
)
=
>
{
let
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
inspector
-
script
-
paused
"
)
;
if
(
!
notification
&
&
this
.
_toolbox
.
currentToolId
=
=
"
inspector
"
&
&
this
.
_toolbox
.
threadClient
.
paused
)
{
let
message
=
INSPECTOR_L10N
.
getStr
(
"
debuggerPausedWarning
.
message
"
)
;
notificationBox
.
appendNotification
(
message
"
inspector
-
script
-
paused
"
"
"
notificationBox
.
PRIORITY_WARNING_HIGH
)
;
}
if
(
notification
&
&
this
.
_toolbox
.
currentToolId
!
=
"
inspector
"
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
if
(
notification
&
&
!
this
.
_toolbox
.
threadClient
.
paused
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
}
;
this
.
target
.
on
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
on
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
on
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
this
.
updateDebuggerPausedWarning
(
)
;
}
this
.
_initMarkup
(
)
;
this
.
isReady
=
false
;
this
.
setupSearchBox
(
)
;
this
.
setupSplitter
(
)
;
this
.
panelDoc
.
getElementById
(
"
inspector
-
main
-
content
"
)
.
style
.
visibility
=
"
visible
"
;
this
.
setupSidebar
(
)
;
this
.
setupExtensionSidebars
(
)
;
await
this
.
once
(
"
markuploaded
"
)
;
this
.
isReady
=
true
;
if
(
defaultSelection
)
{
let
onAllPanelsUpdated
=
this
.
once
(
"
inspector
-
updated
"
)
;
this
.
selection
.
setNodeFront
(
defaultSelection
"
inspector
-
open
"
)
;
await
onAllPanelsUpdated
;
await
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
}
await
this
.
setupToolbar
(
)
;
this
.
emit
(
"
ready
"
)
;
return
this
;
}
_onBeforeNavigate
:
function
(
)
{
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
this
.
_pendingSelection
=
null
;
}
_getPageStyle
:
function
(
)
{
return
this
.
inspector
.
getPageStyle
(
)
.
then
(
pageStyle
=
>
{
this
.
pageStyle
=
pageStyle
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
_getDefaultNodeForSelection
:
function
(
)
{
if
(
this
.
_defaultNode
)
{
return
this
.
_defaultNode
;
}
let
walker
=
this
.
walker
;
let
rootNode
=
null
;
let
pendingSelection
=
this
.
_pendingSelection
;
let
hasNavigated
=
(
)
=
>
pendingSelection
!
=
=
this
.
_pendingSelection
;
return
walker
.
getRootNode
(
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
rootNode
=
node
;
if
(
this
.
selectionCssSelector
)
{
return
walker
.
querySelector
(
rootNode
this
.
selectionCssSelector
)
;
}
return
null
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
walker
.
querySelector
(
rootNode
"
body
"
)
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
this
.
walker
.
documentElement
(
)
;
}
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
this
.
_defaultNode
=
node
;
return
node
;
}
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
set
target
(
value
)
{
this
.
_target
=
value
;
}
setupSearchBox
:
function
(
)
{
this
.
searchBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchbox
"
)
;
this
.
searchClearButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchinput
-
clear
"
)
;
this
.
searchResultsLabel
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
"
)
;
this
.
search
=
new
InspectorSearch
(
this
this
.
searchBox
this
.
searchClearButton
)
;
this
.
search
.
on
(
"
search
-
cleared
"
this
.
_updateSearchResultsLabel
)
;
this
.
search
.
on
(
"
search
-
result
"
this
.
_updateSearchResultsLabel
)
;
let
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
panelDoc
.
defaultView
}
)
;
let
key
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
;
shortcuts
.
on
(
key
(
name
event
)
=
>
{
if
(
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
|
|
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
computedview
"
)
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
}
get
searchSuggestions
(
)
{
return
this
.
search
.
autocompleter
;
}
_updateSearchResultsLabel
:
function
(
event
result
)
{
let
str
=
"
"
;
if
(
event
!
=
=
"
search
-
cleared
"
)
{
if
(
result
)
{
str
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
searchResultsCount2
"
result
.
resultsIndex
+
1
result
.
resultsLength
)
;
}
else
{
str
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchResultsNone
"
)
;
}
}
this
.
searchResultsLabel
.
textContent
=
str
;
}
get
React
(
)
{
return
this
.
_toolbox
.
React
;
}
get
ReactDOM
(
)
{
return
this
.
_toolbox
.
ReactDOM
;
}
get
ReactRedux
(
)
{
return
this
.
_toolbox
.
ReactRedux
;
}
get
browserRequire
(
)
{
return
this
.
_toolbox
.
browserRequire
;
}
get
InspectorTabPanel
(
)
{
if
(
!
this
.
_InspectorTabPanel
)
{
this
.
_InspectorTabPanel
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
components
/
InspectorTabPanel
"
)
)
;
}
return
this
.
_InspectorTabPanel
;
}
useLandscapeMode
:
function
(
)
{
let
{
clientWidth
}
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
return
clientWidth
>
PORTRAIT_MODE_WIDTH
;
}
setupSplitter
:
function
(
)
{
let
SplitBox
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
splitter
/
SplitBox
"
)
)
;
let
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
let
splitter
=
SplitBox
(
{
className
:
"
inspector
-
sidebar
-
splitter
"
initialWidth
:
width
initialHeight
:
height
minSize
:
"
10
%
"
maxSize
:
"
80
%
"
splitterSize
:
1
endPanelControl
:
true
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
main
-
content
"
}
)
endPanel
:
SplitBox
(
{
initialWidth
:
splitSidebarWidth
minSize
:
10
maxSize
:
"
80
%
"
splitterSize
:
this
.
isSplitRuleViewEnabled
?
1
:
0
endPanelControl
:
false
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
rules
-
container
"
}
)
endPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
sidebar
-
container
"
}
)
ref
:
splitbox
=
>
{
this
.
sidebarSplitBox
=
splitbox
;
}
}
)
vert
:
this
.
useLandscapeMode
(
)
onControlledPanelResized
:
this
.
onSidebarResized
}
)
;
this
.
splitBox
=
this
.
ReactDOM
.
render
(
splitter
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
)
;
this
.
panelWin
.
addEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
}
teardownSplitter
:
function
(
)
{
this
.
panelWin
.
removeEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
this
.
sidebar
.
off
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
off
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
off
(
"
destroy
"
this
.
onSidebarHidden
)
;
}
onPanelWindowResize
:
function
(
)
{
this
.
splitBox
.
setState
(
{
vert
:
this
.
useLandscapeMode
(
)
}
)
;
}
getSidebarSize
:
function
(
)
{
let
width
;
let
height
;
let
splitSidebarWidth
;
try
{
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
)
;
splitSidebarWidth
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
)
;
}
catch
(
e
)
{
width
=
this
.
isSplitRuleViewEnabled
?
INITIAL_SIDEBAR_SIZE
*
2
:
INITIAL_SIDEBAR_SIZE
;
height
=
INITIAL_SIDEBAR_SIZE
;
splitSidebarWidth
=
INITIAL_SIDEBAR_SIZE
;
}
return
{
width
height
splitSidebarWidth
}
;
}
onSidebarHidden
:
function
(
)
{
let
state
=
this
.
splitBox
.
state
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
state
.
width
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
state
.
height
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
this
.
sidebarSplitBox
.
state
.
width
)
;
}
onSidebarResized
:
function
(
width
height
)
{
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
resized
"
{
width
height
}
)
;
}
onSidebarSelect
:
function
(
event
toolId
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
toolId
)
;
this
.
getPanel
(
toolId
)
;
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
select
"
toolId
)
;
}
onSidebarShown
:
function
(
)
{
let
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
splitBox
.
setState
(
{
width
height
}
)
;
this
.
sidebarSplitBox
.
setState
(
{
width
:
splitSidebarWidth
}
)
;
}
onSidebarToggle
:
function
(
)
{
Services
.
prefs
.
setBoolPref
(
SPLIT_RULE_VIEW_PREF
!
this
.
isSplitRuleViewEnabled
)
;
}
async
onSplitRuleViewPrefChanged
(
)
{
this
.
isSplitRuleViewEnabled
=
Services
.
prefs
.
getBoolPref
(
SPLIT_RULE_VIEW_PREF
)
;
await
this
.
setupToolbar
(
)
;
await
this
.
addRuleView
(
)
;
}
async
addRuleView
(
defaultTab
=
"
ruleview
"
)
{
let
ruleViewSidebar
=
this
.
sidebarSplitBox
.
startPanelContainer
;
if
(
this
.
isSplitRuleViewEnabled
)
{
ruleViewSidebar
.
style
.
display
=
"
block
"
;
if
(
this
.
sidebarToggle
)
{
this
.
sidebarToggle
.
setState
(
{
collapsed
:
false
}
)
;
}
this
.
sidebarSplitBox
.
setState
(
{
splitterSize
:
1
}
)
;
this
.
getPanel
(
"
ruleview
"
)
;
await
this
.
sidebar
.
removeTab
(
"
ruleview
"
)
;
this
.
ruleViewSideBar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
)
;
this
.
ruleViewSideBar
.
show
(
"
ruleview
"
)
;
}
else
{
ruleViewSidebar
.
style
.
display
=
"
none
"
;
if
(
this
.
sidebarToggle
)
{
this
.
sidebarToggle
.
setState
(
{
collapsed
:
true
}
)
;
}
this
.
sidebarSplitBox
.
setState
(
{
splitterSize
:
0
}
)
;
this
.
ruleViewSideBar
.
hide
(
)
;
await
this
.
ruleViewSideBar
.
removeTab
(
"
ruleview
"
)
;
this
.
sidebar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
defaultTab
=
=
"
ruleview
"
0
)
;
}
}
getPanel
:
function
(
id
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
return
this
.
_panels
.
get
(
id
)
;
}
let
panel
;
switch
(
id
)
{
case
"
computedview
"
:
const
{
ComputedViewTool
}
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
computed
/
computed
"
)
;
panel
=
new
ComputedViewTool
(
this
this
.
panelWin
)
;
break
;
case
"
ruleview
"
:
const
{
RuleViewTool
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
;
panel
=
new
RuleViewTool
(
this
this
.
panelWin
)
;
break
;
case
"
boxmodel
"
:
const
BoxModel
=
require
(
"
devtools
/
client
/
inspector
/
boxmodel
/
box
-
model
"
)
;
panel
=
new
BoxModel
(
this
this
.
panelWin
)
;
break
;
default
:
return
null
;
}
this
.
_panels
.
set
(
id
panel
)
;
return
panel
;
}
async
setupSidebar
(
)
{
let
sidebar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
sidebar
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
sidebar
this
"
inspector
"
{
showAllTabsMenu
:
true
}
)
;
let
ruleSideBar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
rules
-
sidebar
"
)
;
this
.
ruleViewSideBar
=
new
ToolSidebar
(
ruleSideBar
this
"
inspector
"
{
hideTabstripe
:
true
}
)
;
this
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
let
defaultTab
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
if
(
this
.
isSplitRuleViewEnabled
&
&
defaultTab
=
=
=
"
ruleview
"
)
{
defaultTab
=
"
computedview
"
;
}
await
this
.
addRuleView
(
defaultTab
)
;
this
.
sidebar
.
addExistingTab
(
"
computedview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
computedViewTitle
"
)
defaultTab
=
=
"
computedview
"
)
;
let
layoutId
=
"
layoutview
"
;
let
layoutTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
layoutViewTitle2
"
)
;
this
.
sidebar
.
addTab
(
layoutId
layoutTitle
{
props
:
{
id
:
layoutId
title
:
layoutTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
layoutview
)
{
const
LayoutView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
layout
/
layout
"
)
;
this
.
layoutview
=
new
LayoutView
(
this
this
.
panelWin
)
;
}
return
this
.
layoutview
.
provider
;
}
}
defaultTab
=
=
layoutId
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
changesview
.
enabled
"
)
)
{
let
changesId
=
"
changesview
"
;
let
changesTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
changesViewTitle
"
)
;
this
.
sidebar
.
addTab
(
changesId
changesTitle
{
props
:
{
id
:
changesId
title
:
changesTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
changesview
)
{
const
ChangesView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
changes
/
changes
"
)
;
this
.
changesview
=
new
ChangesView
(
this
this
.
panelWin
)
;
}
return
this
.
changesview
.
provider
;
}
}
defaultTab
=
=
changesId
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
eventsview
.
enabled
"
)
)
{
let
eventsId
=
"
eventsview
"
;
let
eventsTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
eventsViewTitle
"
)
;
this
.
sidebar
.
addTab
(
eventsId
eventsTitle
{
props
:
{
id
:
eventsId
title
:
eventsTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
eventview
)
{
const
EventsView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
events
/
events
"
)
;
this
.
eventsview
=
new
EventsView
(
this
this
.
panelWin
)
;
}
return
this
.
eventsview
.
provider
;
}
}
defaultTab
=
=
eventsId
)
;
}
if
(
this
.
target
.
form
.
animationsActor
)
{
const
animationTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
animationInspectorTitle
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
)
)
{
const
animationId
=
"
newanimationinspector
"
;
this
.
sidebar
.
addTab
(
animationId
animationTitle
{
props
:
{
id
:
animationId
title
:
animationTitle
}
panel
:
(
)
=
>
{
const
AnimationInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
animation
/
animation
"
)
;
this
.
animationinspector
=
new
AnimationInspector
(
this
this
.
panelWin
)
;
return
this
.
animationinspector
.
provider
;
}
}
defaultTab
=
=
animationId
)
;
}
else
{
this
.
sidebar
.
addFrameTab
(
"
animationinspector
"
animationTitle
"
chrome
:
/
/
devtools
/
content
/
animationinspector
/
animation
-
inspector
.
xhtml
"
defaultTab
=
=
"
animationinspector
"
)
;
}
}
if
(
this
.
canGetUsedFontFaces
)
{
let
fontId
=
"
fontinspector
"
;
let
fontTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
;
this
.
sidebar
.
addTab
(
fontId
fontTitle
{
props
:
{
id
:
fontId
title
:
fontTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
fontinspector
)
{
const
FontInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
fonts
/
fonts
"
)
;
this
.
fontinspector
=
new
FontInspector
(
this
this
.
panelWin
)
;
}
return
this
.
fontinspector
.
provider
;
}
}
defaultTab
=
=
fontId
)
;
}
this
.
sidebar
.
on
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
on
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
on
(
"
destroy
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
show
(
defaultTab
)
;
}
setupExtensionSidebars
(
)
{
for
(
const
[
sidebarId
{
title
}
]
of
this
.
toolbox
.
inspectorExtensionSidebars
)
{
this
.
addExtensionSidebar
(
sidebarId
{
title
}
)
;
}
}
addExtensionSidebar
:
function
(
id
{
title
}
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Cannot
create
an
extension
sidebar
for
the
existent
id
:
{
id
}
)
;
}
const
extensionSidebar
=
new
ExtensionSidebar
(
this
{
id
title
}
)
;
this
.
addSidebarTab
(
id
title
extensionSidebar
.
provider
false
)
;
this
.
_panels
.
set
(
id
extensionSidebar
)
;
this
.
toolbox
.
emit
(
extension
-
sidebar
-
created
-
{
id
}
extensionSidebar
)
;
}
removeExtensionSidebar
:
function
(
id
)
{
if
(
!
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Unable
to
find
a
sidebar
panel
with
id
"
{
id
}
"
)
;
}
const
panel
=
this
.
_panels
.
get
(
id
)
;
if
(
!
(
panel
instanceof
ExtensionSidebar
)
)
{
throw
new
Error
(
The
sidebar
panel
with
id
"
{
id
}
"
is
not
an
ExtensionSidebar
)
;
}
this
.
_panels
.
delete
(
id
)
;
this
.
sidebar
.
removeTab
(
id
)
;
panel
.
destroy
(
)
;
}
addSidebarTab
:
function
(
id
title
panel
selected
)
{
this
.
sidebar
.
addTab
(
id
title
panel
selected
)
;
}
supportsEyeDropper
:
Task
.
async
(
function
*
(
)
{
try
{
let
hasSupportsHighlighters
=
yield
this
.
target
.
actorHasMethod
(
"
inspector
"
"
supportsHighlighters
"
)
;
let
supportsHighlighters
;
if
(
hasSupportsHighlighters
)
{
supportsHighlighters
=
yield
this
.
inspector
.
supportsHighlighters
(
)
;
}
else
{
let
{
nodeFront
}
=
this
.
selection
;
supportsHighlighters
=
nodeFront
&
&
nodeFront
.
isInHTMLDocument
;
}
return
supportsHighlighters
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
false
;
}
}
)
setupToolbar
:
Task
.
async
(
function
*
(
)
{
this
.
teardownToolbar
(
)
;
this
.
addNode
=
this
.
addNode
.
bind
(
this
)
;
this
.
addNodeButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
this
.
addNodeButton
.
addEventListener
(
"
click
"
this
.
addNode
)
;
let
canShowEyeDropper
=
yield
this
.
supportsEyeDropper
(
)
;
if
(
!
this
.
panelDoc
)
{
return
;
}
if
(
canShowEyeDropper
)
{
this
.
onEyeDropperDone
=
this
.
onEyeDropperDone
.
bind
(
this
)
;
this
.
onEyeDropperButtonClicked
=
this
.
onEyeDropperButtonClicked
.
bind
(
this
)
;
this
.
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
this
.
eyeDropperButton
.
disabled
=
false
;
this
.
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
eyedropper
.
label
"
)
;
this
.
eyeDropperButton
.
addEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
}
else
{
let
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
eyeDropperButton
.
disabled
=
true
;
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
eyedropper
.
disabled
.
title
"
)
;
}
if
(
this
.
showSplitSidebarToggle
&
&
!
this
.
sidebarToggle
)
{
let
SidebarToggle
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
SidebarToggle
"
)
)
;
let
sidebarToggle
=
SidebarToggle
(
{
collapsed
:
!
this
.
isSplitRuleViewEnabled
collapsePaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
hideSplitRulesView
"
)
expandPaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
showSplitRulesView
"
)
onClick
:
this
.
onSidebarToggle
}
)
;
let
parentBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
sidebar
-
toggle
-
box
"
)
;
this
.
sidebarToggle
=
this
.
ReactDOM
.
render
(
sidebarToggle
parentBox
)
;
}
}
)
teardownToolbar
:
function
(
)
{
if
(
this
.
addNodeButton
)
{
this
.
addNodeButton
.
removeEventListener
(
"
click
"
this
.
addNode
)
;
this
.
addNodeButton
=
null
;
}
if
(
this
.
eyeDropperButton
)
{
this
.
eyeDropperButton
.
removeEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
this
.
eyeDropperButton
=
null
;
}
}
onNewRoot
:
function
(
)
{
this
.
_newRootStart
=
this
.
panelWin
.
performance
.
now
(
)
;
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
let
onNodeSelected
=
defaultNode
=
>
{
if
(
this
.
_pendingSelection
!
=
onNodeSelected
)
{
return
;
}
this
.
_pendingSelection
=
null
;
this
.
selection
.
setNodeFront
(
defaultNode
"
navigateaway
"
)
;
this
.
_initMarkup
(
)
;
this
.
once
(
"
markuploaded
"
this
.
onMarkupLoaded
)
;
this
.
setupToolbar
(
)
;
}
;
this
.
_pendingSelection
=
onNodeSelected
;
this
.
_getDefaultNodeForSelection
(
)
.
then
(
onNodeSelected
this
.
_handleRejectionIfNotDestroyed
)
;
}
onMarkupLoaded
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
markup
)
{
return
;
}
let
onExpand
=
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
yield
Promise
.
all
(
[
this
.
highlighters
.
restoreFlexboxState
(
)
this
.
highlighters
.
restoreGridState
(
)
this
.
highlighters
.
restoreShapeState
(
)
]
)
;
this
.
emit
(
"
new
-
root
"
)
;
yield
onExpand
;
this
.
emit
(
"
reloaded
"
)
;
if
(
this
.
_newRootStart
)
{
if
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
=
=
"
inspector
"
)
{
let
delay
=
this
.
panelWin
.
performance
.
now
(
)
-
this
.
_newRootStart
;
let
telemetryKey
=
"
DEVTOOLS_INSPECTOR_NEW_ROOT_TO_RELOAD_DELAY_MS
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
telemetryKey
)
;
histogram
.
add
(
delay
)
;
}
delete
this
.
_newRootStart
;
}
}
)
_selectionCssSelector
:
null
set
selectionCssSelector
(
cssSelector
=
null
)
{
if
(
this
.
_panelDestroyer
)
{
return
;
}
this
.
_selectionCssSelector
=
{
selector
:
cssSelector
url
:
this
.
_target
.
url
}
;
}
get
selectionCssSelector
(
)
{
if
(
this
.
_selectionCssSelector
&
&
this
.
_selectionCssSelector
.
url
=
=
=
this
.
_target
.
url
)
{
return
this
.
_selectionCssSelector
.
selector
;
}
return
null
;
}
canAddHTMLChild
:
function
(
)
{
let
selection
=
this
.
selection
;
let
invalidTagNames
=
[
"
html
"
"
iframe
"
]
;
return
selection
.
isHTMLNode
(
)
&
&
selection
.
isElementNode
(
)
&
&
!
selection
.
isPseudoElementNode
(
)
&
&
!
selection
.
isAnonymousNode
(
)
&
&
!
invalidTagNames
.
includes
(
selection
.
nodeFront
.
nodeName
.
toLowerCase
(
)
)
;
}
onNewSelection
:
function
(
event
value
reason
)
{
if
(
reason
=
=
=
"
selection
-
destroy
"
)
{
return
;
}
let
selection
=
this
.
selection
.
nodeFront
;
let
btn
=
this
.
panelDoc
.
querySelector
(
"
#
inspector
-
element
-
add
-
button
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
btn
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
btn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
this
.
canGetUniqueSelector
&
&
this
.
selection
.
isElementNode
(
)
)
{
selection
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
this
.
selectionCssSelector
=
selector
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
let
selfUpdate
=
this
.
updating
(
"
inspector
-
panel
"
)
;
executeSoon
(
(
)
=
>
{
try
{
selfUpdate
(
selection
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
)
;
}
updating
:
function
(
name
)
{
if
(
this
.
_updateProgress
&
&
this
.
_updateProgress
.
node
!
=
this
.
selection
.
nodeFront
)
{
this
.
cancelUpdate
(
)
;
}
if
(
!
this
.
_updateProgress
)
{
let
self
=
this
;
this
.
_updateProgress
=
{
node
:
this
.
selection
.
nodeFront
outstanding
:
new
Set
(
)
checkDone
:
function
(
)
{
if
(
this
!
=
=
self
.
_updateProgress
)
{
return
;
}
if
(
!
self
.
selection
|
|
(
this
.
node
!
=
=
self
.
selection
.
nodeFront
)
)
{
self
.
cancelUpdate
(
)
;
return
;
}
if
(
this
.
outstanding
.
size
!
=
=
0
)
{
return
;
}
self
.
_updateProgress
=
null
;
self
.
emit
(
"
inspector
-
updated
"
name
)
;
}
}
;
}
let
progress
=
this
.
_updateProgress
;
let
done
=
function
(
)
{
progress
.
outstanding
.
delete
(
done
)
;
progress
.
checkDone
(
)
;
}
;
progress
.
outstanding
.
add
(
done
)
;
return
done
;
}
cancelUpdate
:
function
(
)
{
this
.
_updateProgress
=
null
;
}
onDetached
:
function
(
event
parentNode
)
{
this
.
breadcrumbs
.
cutAfter
(
this
.
breadcrumbs
.
indexOf
(
parentNode
)
)
;
this
.
selection
.
setNodeFront
(
parentNode
?
parentNode
:
this
.
_defaultNode
"
detached
"
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_panelDestroyer
)
{
return
this
.
_panelDestroyer
;
}
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
pageStyle
=
null
;
}
this
.
cancelUpdate
(
)
;
this
.
prefsObserver
.
off
(
SPLIT_RULE_VIEW_PREF
this
.
onSplitRuleViewPrefChanged
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
this
.
target
.
off
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
off
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
off
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
for
(
let
[
panel
]
of
this
.
_panels
)
{
panel
.
destroy
(
)
;
}
this
.
_panels
.
clear
(
)
;
if
(
this
.
layoutview
)
{
this
.
layoutview
.
destroy
(
)
;
}
if
(
this
.
fontinspector
)
{
this
.
fontinspector
.
destroy
(
)
;
}
if
(
this
.
animationinspector
)
{
this
.
animationinspector
.
destroy
(
)
;
}
let
cssPropertiesDestroyer
=
this
.
_cssPropertiesLoaded
.
then
(
(
{
front
}
)
=
>
{
if
(
front
)
{
front
.
destroy
(
)
;
}
}
)
;
this
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
let
sidebarDestroyer
=
this
.
sidebar
.
destroy
(
)
;
let
ruleViewSideBarDestroyer
=
this
.
ruleViewSideBar
?
this
.
ruleViewSideBar
.
destroy
(
)
:
null
;
this
.
teardownSplitter
(
)
;
this
.
teardownToolbar
(
)
;
this
.
breadcrumbs
.
destroy
(
)
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
onDetached
)
;
let
markupDestroyer
=
this
.
_destroyMarkup
(
)
;
this
.
highlighters
.
destroy
(
)
;
this
.
prefsObserver
.
destroy
(
)
;
this
.
reflowTracker
.
destroy
(
)
;
this
.
search
.
destroy
(
)
;
this
.
_toolbox
=
null
;
this
.
breadcrumbs
=
null
;
this
.
highlighters
=
null
;
this
.
panelDoc
=
null
;
this
.
panelWin
.
inspector
=
null
;
this
.
panelWin
=
null
;
this
.
prefsObserver
=
null
;
this
.
resultsLength
=
null
;
this
.
search
=
null
;
this
.
searchBox
=
null
;
this
.
sidebar
=
null
;
this
.
store
=
null
;
this
.
target
=
null
;
this
.
_panelDestroyer
=
promise
.
all
(
[
cssPropertiesDestroyer
markupDestroyer
sidebarDestroyer
ruleViewSideBarDestroyer
]
)
;
return
this
.
_panelDestroyer
;
}
_getClipboardContentForPaste
:
function
(
)
{
let
content
=
clipboardHelper
.
getText
(
)
;
if
(
content
&
&
content
.
trim
(
)
.
length
>
0
)
{
return
content
;
}
return
null
;
}
_onContextMenu
:
function
(
e
)
{
if
(
e
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
e
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
return
;
}
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
this
.
_openMenu
(
{
screenX
:
e
.
screenX
screenY
:
e
.
screenY
target
:
e
.
target
}
)
;
}
_openMenu
:
function
(
{
target
screenX
=
0
screenY
=
0
}
=
{
}
)
{
let
markupContainer
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
this
.
contextMenuTarget
=
target
;
this
.
nodeMenuTriggerInfo
=
markupContainer
&
&
markupContainer
.
editor
.
getInfoAtNode
(
target
)
;
let
isSelectionElement
=
this
.
selection
.
isElementNode
(
)
&
&
!
this
.
selection
.
isPseudoElementNode
(
)
;
let
isEditableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
;
let
isDuplicatableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
&
&
!
this
.
selection
.
isRoot
(
)
;
let
isScreenshotable
=
isSelectionElement
&
&
this
.
canGetUniqueSelector
&
&
this
.
selection
.
nodeFront
.
isTreeDisplayed
;
let
menu
=
new
Menu
(
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
edithtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLEdit
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLEdit
.
accesskey
"
)
disabled
:
!
isEditableElement
|
|
!
this
.
isOuterHTMLEditable
click
:
(
)
=
>
this
.
editHTML
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
add
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddNode
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddNode
.
accesskey
"
)
disabled
:
!
this
.
canAddHTMLChild
(
)
click
:
(
)
=
>
this
.
addNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
duplicatenode
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorDuplicateNode
.
label
"
)
disabled
:
!
isDuplicatableElement
click
:
(
)
=
>
this
.
duplicateNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
delete
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLDelete
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLDelete
.
accesskey
"
)
disabled
:
!
this
.
isDeletable
(
this
.
selection
.
nodeFront
)
click
:
(
)
=
>
this
.
deleteNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAttributesSubmenu
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAttributesSubmenu
.
accesskey
"
)
submenu
:
this
.
_getAttributesSubmenu
(
isEditableElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
for
(
let
name
of
[
"
hover
"
"
active
"
"
focus
"
]
)
{
let
menuitem
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
pseudo
-
"
+
name
label
:
name
type
:
"
checkbox
"
click
:
this
.
togglePseudoClass
.
bind
(
this
"
:
"
+
name
)
}
)
;
if
(
isSelectionElement
)
{
let
checked
=
this
.
selection
.
nodeFront
.
hasPseudoClassLock
(
"
:
"
+
name
)
;
menuitem
.
checked
=
checked
;
}
else
{
menuitem
.
disabled
=
true
;
}
menu
.
append
(
menuitem
)
;
}
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyHTMLSubmenu
.
label
"
)
submenu
:
this
.
_getCopySubmenu
(
markupContainer
isSelectionElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteHTMLSubmenu
.
label
"
)
submenu
:
this
.
_getPasteSubmenu
(
isEditableElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
let
isNodeWithChildren
=
this
.
selection
.
isNode
(
)
&
&
markupContainer
.
hasChildren
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
expand
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorExpandNode
.
label
"
)
disabled
:
!
isNodeWithChildren
click
:
(
)
=
>
this
.
expandNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
collapse
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCollapseAll
.
label
"
)
disabled
:
!
isNodeWithChildren
|
|
!
markupContainer
.
expanded
click
:
(
)
=
>
this
.
collapseAll
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
scrollnodeintoview
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScrollNodeIntoView
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScrollNodeIntoView
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
scrollNodeIntoView
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
screenshotnode
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScreenshotNode
.
label
"
)
disabled
:
!
isScreenshotable
click
:
(
)
=
>
this
.
screenshotNode
(
)
.
catch
(
console
.
error
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
useinconsole
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorUseInConsole
.
label
"
)
click
:
(
)
=
>
this
.
useInConsole
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
showdomproperties
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorShowDOMProperties
.
label
"
)
click
:
(
)
=
>
this
.
showDOMProperties
(
)
}
)
)
;
let
nodeLinkMenuItems
=
this
.
_getNodeLinkMenuItems
(
)
;
if
(
nodeLinkMenuItems
.
filter
(
item
=
>
item
.
visible
)
.
length
>
0
)
{
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
separator
"
type
:
"
separator
"
}
)
)
;
}
for
(
let
menuitem
of
nodeLinkMenuItems
)
{
menu
.
append
(
menuitem
)
;
}
menu
.
popup
(
screenX
screenY
this
.
_toolbox
)
;
return
menu
;
}
_getCopySubmenu
:
function
(
markupContainer
isSelectionElement
)
{
let
copySubmenu
=
new
Menu
(
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyinner
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyInnerHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyInnerHTML
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
copyInnerHTML
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyouter
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyOuterHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyOuterHTML
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
copyOuterHTML
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyuniqueselector
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSSelector
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSSelector
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetUniqueSelector
click
:
(
)
=
>
this
.
copyUniqueSelector
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copycsspath
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSPath
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSPath
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetCssPath
click
:
(
)
=
>
this
.
copyCssPath
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyxpath
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyXPath
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyXPath
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetXPath
click
:
(
)
=
>
this
.
copyXPath
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyimagedatauri
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorImageDataUri
.
label
"
)
disabled
:
!
isSelectionElement
|
|
!
markupContainer
|
|
!
markupContainer
.
isPreviewable
(
)
click
:
(
)
=
>
this
.
copyImageDataUri
(
)
}
)
)
;
return
copySubmenu
;
}
_getPasteSubmenu
:
function
(
isEditableElement
)
{
let
isPasteable
=
isEditableElement
&
&
this
.
_getClipboardContentForPaste
(
)
;
let
disableAdjacentPaste
=
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
|
|
this
.
selection
.
isRoot
(
)
|
|
this
.
selection
.
isBodyNode
(
)
|
|
this
.
selection
.
isHeadNode
(
)
;
let
disableFirstLastPaste
=
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
|
|
(
this
.
selection
.
isHTMLNode
(
)
&
&
this
.
selection
.
isRoot
(
)
)
;
let
pasteSubmenu
=
new
Menu
(
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteinnerhtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteInnerHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteInnerHTML
.
accesskey
"
)
disabled
:
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
click
:
(
)
=
>
this
.
pasteInnerHTML
(
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteouterhtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteOuterHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteOuterHTML
.
accesskey
"
)
disabled
:
!
isPasteable
|
|
!
this
.
isOuterHTMLEditable
click
:
(
)
=
>
this
.
pasteOuterHTML
(
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastebefore
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteBefore
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteBefore
.
accesskey
"
)
disabled
:
disableAdjacentPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
beforeBegin
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteafter
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteAfter
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteAfter
.
accesskey
"
)
disabled
:
disableAdjacentPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
afterEnd
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastefirstchild
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteFirstChild
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteFirstChild
.
accesskey
"
)
disabled
:
disableFirstLastPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
afterBegin
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastelastchild
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteLastChild
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteLastChild
.
accesskey
"
)
disabled
:
disableFirstLastPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
beforeEnd
"
)
}
)
)
;
return
pasteSubmenu
;
}
_getAttributesSubmenu
:
function
(
isEditableElement
)
{
let
attributesSubmenu
=
new
Menu
(
)
;
let
nodeInfo
=
this
.
nodeMenuTriggerInfo
;
let
isAttributeClicked
=
isEditableElement
&
&
nodeInfo
&
&
nodeInfo
.
type
=
=
=
"
attribute
"
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
add
-
attribute
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddAttribute
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddAttribute
.
accesskey
"
)
disabled
:
!
isEditableElement
click
:
(
)
=
>
this
.
onAddAttribute
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copy
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorCopyAttributeValue
.
label
"
isAttributeClicked
?
{
nodeInfo
.
value
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyAttributeValue
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onCopyAttributeValue
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
edit
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorEditAttribute
.
label
"
isAttributeClicked
?
{
nodeInfo
.
name
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorEditAttribute
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onEditAttribute
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
remove
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorRemoveAttribute
.
label
"
isAttributeClicked
?
{
nodeInfo
.
name
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorRemoveAttribute
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onRemoveAttribute
(
)
}
)
)
;
return
attributesSubmenu
;
}
_getNodeLinkMenuItems
:
function
(
)
{
let
linkFollow
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
follow
"
visible
:
false
click
:
(
)
=
>
this
.
onFollowLink
(
)
}
)
;
let
linkCopy
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
copy
"
visible
:
false
click
:
(
)
=
>
this
.
onCopyLink
(
)
}
)
;
let
popupNode
=
this
.
contextMenuTarget
;
if
(
!
popupNode
|
|
!
popupNode
.
classList
.
contains
(
"
link
"
)
)
{
return
[
linkFollow
linkCopy
]
;
}
let
type
=
popupNode
.
dataset
.
type
;
if
(
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
)
{
if
(
type
=
=
=
"
uri
"
&
&
!
this
.
target
.
chrome
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
menu
.
openUrlInNewTab
.
label
"
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
TOOLBOX_L10N
.
getStr
(
"
toolbox
.
viewCssSourceInStyleEditor
.
label
"
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
TOOLBOX_L10N
.
getStr
(
"
toolbox
.
viewJsSourceInDebugger
.
label
"
)
;
}
linkCopy
.
visible
=
true
;
linkCopy
.
label
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
menu
.
copyUrlToClipboard
.
label
"
)
;
}
else
if
(
type
=
=
=
"
idref
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
menu
.
selectElement
.
label
"
popupNode
.
dataset
.
link
)
;
}
return
[
linkFollow
linkCopy
]
;
}
_initMarkup
:
function
(
)
{
let
doc
=
this
.
panelDoc
;
this
.
_markupBox
=
doc
.
getElementById
(
"
markup
-
box
"
)
;
this
.
_markupFrame
=
doc
.
createElement
(
"
iframe
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
this
.
_markupFrame
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
_markupBox
.
style
.
visibility
=
"
hidden
"
;
this
.
_markupBox
.
appendChild
(
this
.
_markupFrame
)
;
this
.
_markupFrame
.
addEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
setAttribute
(
"
src
"
"
markup
/
markup
.
xhtml
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
aria
-
label
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
panelLabel
.
markupView
"
)
)
;
}
_onMarkupFrameLoad
:
function
(
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
contentWindow
.
focus
(
)
;
this
.
markup
=
new
MarkupView
(
this
this
.
_markupFrame
this
.
_toolbox
.
win
)
;
this
.
_markupBox
.
style
.
visibility
=
"
visible
"
;
this
.
emit
(
"
markuploaded
"
)
;
}
_destroyMarkup
:
function
(
)
{
let
destroyPromise
;
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
}
if
(
this
.
markup
)
{
destroyPromise
=
this
.
markup
.
destroy
(
)
;
this
.
markup
=
null
;
}
else
{
destroyPromise
=
promise
.
resolve
(
)
;
}
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
remove
(
)
;
this
.
_markupFrame
=
null
;
}
this
.
_markupBox
=
null
;
return
destroyPromise
;
}
onEyeDropperButtonClicked
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
contains
(
"
checked
"
)
?
this
.
hideEyeDropper
(
)
:
this
.
showEyeDropper
(
)
;
}
startEyeDropperListeners
:
function
(
)
{
this
.
inspector
.
once
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspector
.
once
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
once
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
stopEyeDropperListeners
:
function
(
)
{
this
.
inspector
.
off
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspector
.
off
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
off
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
onEyeDropperDone
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
}
showEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
telemetry
.
toolOpened
(
"
toolbareyedropper
"
)
;
this
.
eyeDropperButton
.
classList
.
add
(
"
checked
"
)
;
this
.
startEyeDropperListeners
(
)
;
return
this
.
inspector
.
pickColorFromPage
(
this
.
toolbox
{
copyOnSelect
:
true
}
)
.
catch
(
console
.
error
)
;
}
hideEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
return
this
.
inspector
.
cancelPickColorFromPage
(
)
.
catch
(
console
.
error
)
;
}
addNode
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
canAddHTMLChild
(
)
)
{
return
;
}
let
html
=
"
<
div
>
<
/
div
>
"
;
let
onMutations
=
this
.
once
(
"
markupmutation
"
)
;
yield
this
.
walker
.
insertAdjacentHTML
(
this
.
selection
.
nodeFront
"
beforeEnd
"
html
)
;
yield
onMutations
;
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
}
)
togglePseudoClass
:
function
(
pseudo
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
let
node
=
this
.
selection
.
nodeFront
;
if
(
node
.
hasPseudoClassLock
(
pseudo
)
)
{
return
this
.
walker
.
removePseudoClassLock
(
node
pseudo
{
parents
:
true
}
)
;
}
let
hierarchical
=
pseudo
=
=
"
:
hover
"
|
|
pseudo
=
=
"
:
active
"
;
return
this
.
walker
.
addPseudoClassLock
(
node
pseudo
{
parents
:
hierarchical
}
)
;
}
return
promise
.
resolve
(
)
;
}
showDOMProperties
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
jsterm
.
execute
(
"
inspect
(
0
)
"
)
;
jsterm
.
focus
(
)
;
}
)
;
}
useInConsole
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
let
evalString
=
{
let
i
=
0
;
while
(
window
.
hasOwnProperty
(
"
temp
"
+
i
)
&
&
i
<
1000
)
{
i
+
+
;
}
window
[
"
temp
"
+
i
]
=
0
;
"
temp
"
+
i
;
}
;
let
options
=
{
selectedNodeActor
:
this
.
selection
.
nodeFront
.
actorID
}
;
jsterm
.
requestEvaluation
(
evalString
options
)
.
then
(
(
res
)
=
>
{
jsterm
.
setInputValue
(
res
.
result
)
;
this
.
emit
(
"
console
-
var
-
ready
"
)
;
}
)
;
}
)
;
}
editHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
beginEditingOuterHTML
(
this
.
selection
.
nodeFront
)
;
}
}
pasteOuterHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeOuterHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeOuterHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteInnerHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeInnerHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeInnerHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteAdjacentHTML
:
function
(
position
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
insertAdjacentHTMLToNode
(
node
position
content
)
;
}
copyInnerHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
_copyLongString
(
this
.
walker
.
innerHTML
(
this
.
selection
.
nodeFront
)
)
;
}
copyOuterHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
let
node
=
this
.
selection
.
nodeFront
;
switch
(
node
.
nodeType
)
{
case
nodeConstants
.
ELEMENT_NODE
:
this
.
_copyLongString
(
this
.
walker
.
outerHTML
(
node
)
)
;
break
;
case
nodeConstants
.
COMMENT_NODE
:
this
.
_getLongString
(
node
.
getNodeValue
(
)
)
.
then
(
comment
=
>
{
clipboardHelper
.
copyString
(
"
<
!
-
-
"
+
comment
+
"
-
-
>
"
)
;
}
)
;
break
;
case
nodeConstants
.
DOCUMENT_TYPE_NODE
:
clipboardHelper
.
copyString
(
node
.
doctypeString
)
;
break
;
}
}
copyImageDataUri
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
if
(
container
&
&
container
.
isPreviewable
(
)
)
{
container
.
copyImageDataUri
(
)
;
}
}
_copyLongString
:
function
(
longStringActorPromise
)
{
return
this
.
_getLongString
(
longStringActorPromise
)
.
then
(
string
=
>
{
clipboardHelper
.
copyString
(
string
)
;
}
)
.
catch
(
console
.
error
)
;
}
_getLongString
:
function
(
longStringActorPromise
)
{
return
longStringActorPromise
.
then
(
longStringActor
=
>
{
return
longStringActor
.
string
(
)
.
then
(
string
=
>
{
longStringActor
.
release
(
)
.
catch
(
console
.
error
)
;
return
string
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyUniqueSelector
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
toolOpened
(
"
copyuniquecssselector
"
)
;
this
.
selection
.
nodeFront
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
clipboardHelper
.
copyString
(
selector
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyCssPath
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
toolOpened
(
"
copyfullcssselector
"
)
;
this
.
selection
.
nodeFront
.
getCssPath
(
)
.
then
(
path
=
>
{
clipboardHelper
.
copyString
(
path
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyXPath
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
toolOpened
(
"
copyxpath
"
)
;
this
.
selection
.
nodeFront
.
getXPath
(
)
.
then
(
path
=
>
{
clipboardHelper
.
copyString
(
path
)
;
}
)
.
catch
(
console
.
error
)
;
}
screenshotNode
:
Task
.
async
(
function
*
(
)
{
const
command
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
clipboard
.
enabled
"
)
?
"
screenshot
-
-
file
-
-
clipboard
-
-
selector
"
:
"
screenshot
-
-
file
-
-
selector
"
;
yield
this
.
highlighter
.
hideBoxModel
(
)
;
CommandUtils
.
executeOnTarget
(
this
.
_target
{
command
}
'
{
this
.
selectionCssSelector
}
'
)
;
}
)
scrollNodeIntoView
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
selection
.
nodeFront
.
scrollIntoView
(
)
;
}
duplicateNode
:
function
(
)
{
let
selection
=
this
.
selection
;
if
(
!
selection
.
isElementNode
(
)
|
|
selection
.
isRoot
(
)
|
|
selection
.
isAnonymousNode
(
)
|
|
selection
.
isPseudoElementNode
(
)
)
{
return
;
}
this
.
walker
.
duplicateNode
(
selection
.
nodeFront
)
.
catch
(
console
.
error
)
;
}
deleteNode
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
|
|
this
.
selection
.
isRoot
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
deleteNode
(
this
.
selection
.
nodeFront
)
;
}
else
{
this
.
walker
.
removeNode
(
this
.
selection
.
nodeFront
)
;
}
}
onAddAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
addAttribute
(
)
;
}
onCopyAttributeValue
:
function
(
)
{
clipboardHelper
.
copyString
(
this
.
nodeMenuTriggerInfo
.
value
)
;
}
onEditAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
editAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
onRemoveAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
removeAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
expandNode
:
function
(
)
{
this
.
markup
.
expandAll
(
this
.
selection
.
nodeFront
)
;
}
collapseAll
:
function
(
)
{
this
.
markup
.
collapseAll
(
this
.
selection
.
nodeFront
)
;
}
onFollowLink
:
function
(
)
{
let
type
=
this
.
contextMenuTarget
.
dataset
.
type
;
let
link
=
this
.
contextMenuTarget
.
dataset
.
link
;
this
.
followAttributeLink
(
type
link
)
;
}
followAttributeLink
:
function
(
type
link
)
{
if
(
!
type
|
|
!
link
)
{
return
;
}
if
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
if
(
type
=
=
=
"
uri
"
)
{
let
browserWin
=
this
.
target
.
tab
.
ownerDocument
.
defaultView
;
browserWin
.
openUILinkIn
(
url
"
tab
"
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
return
this
.
toolbox
.
viewSourceInStyleEditor
(
url
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
return
this
.
toolbox
.
viewSourceInDebugger
(
url
)
;
}
return
null
;
}
)
.
catch
(
console
.
error
)
;
}
else
if
(
type
=
=
"
idref
"
)
{
this
.
walker
.
document
(
this
.
selection
.
nodeFront
)
.
then
(
doc
=
>
{
return
this
.
walker
.
querySelector
(
doc
"
#
"
+
CSS
.
escape
(
link
)
)
.
then
(
node
=
>
{
if
(
!
node
)
{
this
.
emit
(
"
idref
-
attribute
-
link
-
failed
"
)
;
return
;
}
this
.
selection
.
setNodeFront
(
node
)
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
}
onCopyLink
:
function
(
)
{
let
link
=
this
.
contextMenuTarget
.
dataset
.
link
;
this
.
copyAttributeLink
(
link
)
;
}
copyAttributeLink
:
function
(
link
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
clipboardHelper
.
copyString
(
url
)
;
}
console
.
error
)
;
}
getCommonComponentProps
(
)
{
return
{
setSelectedNode
:
this
.
selection
.
setNodeFront
onShowBoxModelHighlighterForNode
:
this
.
onShowBoxModelHighlighterForNode
}
;
}
onShowBoxModelHighlighterForNode
(
nodeFront
options
)
{
let
toolbox
=
this
.
toolbox
;
toolbox
.
highlighterUtils
.
highlightNodeFront
(
nodeFront
options
)
;
}
isDeletable
(
nodeFront
)
{
return
!
(
nodeFront
.
isDocumentElement
|
|
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_TYPE_NODE
|
|
nodeFront
.
isAnonymous
)
;
}
async
inspectNodeActor
(
nodeActor
inspectFromAnnotation
)
{
const
nodeFront
=
await
this
.
walker
.
getNodeActorFromObjectActor
(
nodeActor
)
;
if
(
!
nodeFront
)
{
console
.
error
(
"
The
object
cannot
be
linked
to
the
inspector
the
"
+
"
corresponding
nodeFront
could
not
be
found
.
"
)
;
return
false
;
}
let
isAttached
=
await
this
.
walker
.
isInDOMTree
(
nodeFront
)
;
if
(
!
isAttached
)
{
console
.
error
(
"
Selected
DOMNode
is
not
attached
to
the
document
tree
.
"
)
;
return
false
;
}
await
this
.
selection
.
setNodeFront
(
nodeFront
inspectFromAnnotation
)
;
return
true
;
}
}
;
const
buildFakeToolbox
=
Task
.
async
(
function
*
(
target
createThreadClient
{
React
ReactDOM
browserRequire
}
)
{
const
{
InspectorFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
inspector
"
)
;
const
{
Selection
}
=
require
(
"
devtools
/
client
/
framework
/
selection
"
)
;
const
{
getHighlighterUtils
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
-
highlighter
-
utils
"
)
;
let
notImplemented
=
function
(
)
{
throw
new
Error
(
"
Not
implemented
in
a
tab
"
)
;
}
;
let
fakeToolbox
=
{
target
hostType
:
"
bottom
"
doc
:
window
.
document
win
:
window
on
(
)
{
}
emit
(
)
{
}
off
(
)
{
}
initInspector
(
)
{
}
browserRequire
React
ReactDOM
isToolRegistered
(
)
{
return
false
;
}
currentToolId
:
"
inspector
"
getCurrentPanel
(
)
{
return
"
inspector
"
;
}
get
textboxContextMenuPopup
(
)
{
notImplemented
(
)
;
}
getPanel
:
notImplemented
openSplitConsole
:
notImplemented
viewCssSourceInStyleEditor
:
notImplemented
viewJsSourceInDebugger
:
notImplemented
viewSource
:
notImplemented
viewSourceInDebugger
:
notImplemented
viewSourceInStyleEditor
:
notImplemented
get
inspectorExtensionSidebars
(
)
{
notImplemented
(
)
;
}
highlightTool
(
)
{
}
unhighlightTool
(
)
{
}
selectTool
(
)
{
}
raise
(
)
{
}
getNotificationBox
(
)
{
}
}
;
fakeToolbox
.
threadClient
=
yield
createThreadClient
(
fakeToolbox
)
;
let
inspector
=
InspectorFront
(
target
.
client
target
.
form
)
;
let
showAllAnonymousContent
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
)
;
let
walker
=
yield
inspector
.
getWalker
(
{
showAllAnonymousContent
}
)
;
let
selection
=
new
Selection
(
walker
)
;
let
highlighter
=
yield
inspector
.
getHighlighter
(
false
)
;
fakeToolbox
.
highlighterUtils
=
getHighlighterUtils
(
fakeToolbox
)
;
fakeToolbox
.
inspector
=
inspector
;
fakeToolbox
.
walker
=
walker
;
fakeToolbox
.
selection
=
selection
;
fakeToolbox
.
highlighter
=
highlighter
;
return
fakeToolbox
;
}
)
;
let
href
=
window
.
location
.
href
.
replace
(
/
chrome
:
/
"
http
:
/
/
"
)
;
let
url
=
new
window
.
URL
(
href
)
;
if
(
window
.
location
.
protocol
=
=
=
"
chrome
:
"
&
&
url
.
search
.
length
>
1
)
{
const
{
targetFromURL
}
=
require
(
"
devtools
/
client
/
framework
/
target
-
from
-
url
"
)
;
const
{
attachThread
}
=
require
(
"
devtools
/
client
/
framework
/
attach
-
thread
"
)
;
const
browserRequire
=
BrowserLoader
(
{
window
useOnlyShared
:
true
}
)
.
require
;
const
React
=
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
Task
.
spawn
(
function
*
(
)
{
let
target
=
yield
targetFromURL
(
url
)
;
let
fakeToolbox
=
yield
buildFakeToolbox
(
target
(
toolbox
)
=
>
attachThread
(
toolbox
)
{
React
ReactDOM
browserRequire
}
)
;
let
inspectorUI
=
new
Inspector
(
fakeToolbox
)
;
inspectorUI
.
init
(
)
;
}
)
.
catch
(
e
=
>
{
window
.
alert
(
"
Unable
to
start
the
inspector
:
"
+
e
.
message
+
"
\
n
"
+
e
.
stack
)
;
}
)
;
}
exports
.
Inspector
=
Inspector
;
exports
.
buildFakeToolbox
=
buildFakeToolbox
;
