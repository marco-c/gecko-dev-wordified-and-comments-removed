"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
executeSoon
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
HighlightersOverlay
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
highlighters
-
overlay
"
)
;
const
ReflowTracker
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
reflow
-
tracker
"
)
;
const
Store
=
require
(
"
devtools
/
client
/
inspector
/
store
"
)
;
const
InspectorStyleChangeTracker
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
style
-
change
-
tracker
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
initCssProperties
"
"
devtools
/
shared
/
fronts
/
css
-
properties
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HTMLBreadcrumbs
"
"
devtools
/
client
/
inspector
/
breadcrumbs
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ThreePaneOnboardingTooltip
"
"
devtools
/
client
/
inspector
/
shared
/
three
-
pane
-
onboarding
-
tooltip
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorSearch
"
"
devtools
/
client
/
inspector
/
inspector
-
search
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
inspector
/
toolsidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
MarkupView
"
"
devtools
/
client
/
inspector
/
markup
/
markup
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
Menu
"
"
devtools
/
client
/
framework
/
menu
"
)
;
loader
.
lazyRequireGetter
(
this
"
MenuItem
"
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
loader
.
lazyRequireGetter
(
this
"
ExtensionSidebar
"
"
devtools
/
client
/
inspector
/
extensions
/
extension
-
sidebar
"
)
;
loader
.
lazyRequireGetter
(
this
"
CommandUtils
"
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
clipboardHelper
"
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
{
LocalizationHelper
localizeMarkup
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
loader
.
lazyGetter
(
this
"
TOOLBOX_L10N
"
function
(
)
{
return
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
}
)
;
const
INITIAL_SIDEBAR_SIZE
=
350
;
const
PORTRAIT_MODE_WIDTH_THRESHOLD
=
700
;
const
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
=
1000
;
const
SHOW_THREE_PANE_ONBOARDING_PREF
=
"
devtools
.
inspector
.
show
-
three
-
pane
-
tooltip
"
;
const
SHOW_THREE_PANE_TOGGLE_PREF
=
"
devtools
.
inspector
.
three
-
pane
-
toggle
"
;
const
THREE_PANE_ENABLED_PREF
=
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
;
const
THREE_PANE_ENABLED_SCALAR
=
"
devtools
.
inspector
.
three_pane_enabled
"
;
function
Inspector
(
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_target
=
toolbox
.
target
;
this
.
panelDoc
=
window
.
document
;
this
.
panelWin
=
window
;
this
.
panelWin
.
inspector
=
this
;
this
.
store
=
Store
(
)
;
this
.
_panels
=
new
Map
(
)
;
this
.
highlighters
=
new
HighlightersOverlay
(
this
)
;
this
.
reflowTracker
=
new
ReflowTracker
(
this
.
_target
)
;
this
.
styleChangeTracker
=
new
InspectorStyleChangeTracker
(
this
)
;
this
.
telemetry
=
new
Telemetry
(
)
;
this
.
previousURL
=
this
.
target
.
url
;
this
.
is3PaneModeEnabled
=
Services
.
prefs
.
getBoolPref
(
THREE_PANE_ENABLED_PREF
)
;
this
.
show3PaneToggle
=
Services
.
prefs
.
getBoolPref
(
SHOW_THREE_PANE_TOGGLE_PREF
)
;
this
.
show3PaneTooltip
=
Services
.
prefs
.
getBoolPref
(
SHOW_THREE_PANE_ONBOARDING_PREF
)
;
this
.
nodeMenuTriggerInfo
=
null
;
this
.
_handleRejectionIfNotDestroyed
=
this
.
_handleRejectionIfNotDestroyed
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onBeforeNavigate
=
this
.
_onBeforeNavigate
.
bind
(
this
)
;
this
.
_onMarkupFrameLoad
=
this
.
_onMarkupFrameLoad
.
bind
(
this
)
;
this
.
_updateSearchResultsLabel
=
this
.
_updateSearchResultsLabel
.
bind
(
this
)
;
this
.
_clearSearchResultsLabel
=
this
.
_clearSearchResultsLabel
.
bind
(
this
)
;
this
.
onDetached
=
this
.
onDetached
.
bind
(
this
)
;
this
.
onMarkupLoaded
=
this
.
onMarkupLoaded
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
onNewRoot
=
this
.
onNewRoot
.
bind
(
this
)
;
this
.
onPanelWindowResize
=
this
.
onPanelWindowResize
.
bind
(
this
)
;
this
.
onShowBoxModelHighlighterForNode
=
this
.
onShowBoxModelHighlighterForNode
.
bind
(
this
)
;
this
.
onSidebarHidden
=
this
.
onSidebarHidden
.
bind
(
this
)
;
this
.
onSidebarResized
=
this
.
onSidebarResized
.
bind
(
this
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
onSidebarShown
=
this
.
onSidebarShown
.
bind
(
this
)
;
this
.
onSidebarToggle
=
this
.
onSidebarToggle
.
bind
(
this
)
;
this
.
_target
.
on
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
}
Inspector
.
prototype
=
{
async
init
(
)
{
localizeMarkup
(
this
.
panelDoc
)
;
this
.
_cssProperties
=
await
initCssProperties
(
this
.
toolbox
)
;
await
this
.
target
.
makeRemote
(
)
;
await
this
.
_getPageStyle
(
)
;
let
defaultSelection
=
await
this
.
_getDefaultNodeForSelection
(
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
return
this
.
_deferredOpen
(
defaultSelection
)
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
inspector
(
)
{
return
this
.
_toolbox
.
inspector
;
}
get
walker
(
)
{
return
this
.
_toolbox
.
walker
;
}
get
selection
(
)
{
return
this
.
_toolbox
.
selection
;
}
get
highlighter
(
)
{
return
this
.
_toolbox
.
highlighter
;
}
get
isOuterHTMLEditable
(
)
{
return
this
.
_target
.
client
.
traits
.
editOuterHTML
;
}
get
hasUrlToImageDataResolver
(
)
{
return
this
.
_target
.
client
.
traits
.
urlToImageDataResolver
;
}
get
canGetUniqueSelector
(
)
{
return
this
.
_target
.
client
.
traits
.
getUniqueSelector
;
}
get
canGetCssPath
(
)
{
return
this
.
_target
.
client
.
traits
.
getCssPath
;
}
get
canGetXPath
(
)
{
return
this
.
_target
.
client
.
traits
.
getXPath
;
}
get
canGetUsedFontFaces
(
)
{
return
this
.
_target
.
client
.
traits
.
getUsedFontFaces
;
}
get
canPasteInnerOrAdjacentHTML
(
)
{
return
this
.
_target
.
client
.
traits
.
pasteHTML
;
}
_handleRejectionIfNotDestroyed
:
function
(
e
)
{
if
(
!
this
.
_panelDestroyer
)
{
console
.
error
(
e
)
;
}
}
_deferredOpen
:
async
function
(
defaultSelection
)
{
this
.
breadcrumbs
=
new
HTMLBreadcrumbs
(
this
)
;
this
.
walker
.
on
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetached
)
;
if
(
this
.
target
.
isLocalTab
)
{
this
.
updateDebuggerPausedWarning
=
(
)
=
>
{
let
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
inspector
-
script
-
paused
"
)
;
if
(
!
notification
&
&
this
.
_toolbox
.
currentToolId
=
=
"
inspector
"
&
&
this
.
_toolbox
.
threadClient
.
paused
)
{
let
message
=
INSPECTOR_L10N
.
getStr
(
"
debuggerPausedWarning
.
message
"
)
;
notificationBox
.
appendNotification
(
message
"
inspector
-
script
-
paused
"
"
"
notificationBox
.
PRIORITY_WARNING_HIGH
)
;
}
if
(
notification
&
&
this
.
_toolbox
.
currentToolId
!
=
"
inspector
"
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
if
(
notification
&
&
!
this
.
_toolbox
.
threadClient
.
paused
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
}
;
this
.
target
.
on
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
on
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
on
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
this
.
updateDebuggerPausedWarning
(
)
;
}
this
.
_initMarkup
(
)
;
this
.
isReady
=
false
;
this
.
setupSearchBox
(
)
;
this
.
setupSplitter
(
)
;
this
.
panelDoc
.
getElementById
(
"
inspector
-
main
-
content
"
)
.
style
.
visibility
=
"
visible
"
;
this
.
setupSidebar
(
)
;
this
.
setupExtensionSidebars
(
)
;
await
this
.
once
(
"
markuploaded
"
)
;
this
.
isReady
=
true
;
if
(
defaultSelection
)
{
let
onAllPanelsUpdated
=
this
.
once
(
"
inspector
-
updated
"
)
;
this
.
selection
.
setNodeFront
(
defaultSelection
{
reason
:
"
inspector
-
open
"
}
)
;
await
onAllPanelsUpdated
;
await
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
}
await
this
.
setupToolbar
(
)
;
if
(
this
.
show3PaneTooltip
)
{
this
.
threePaneTooltip
=
new
ThreePaneOnboardingTooltip
(
this
.
toolbox
this
.
panelDoc
)
;
}
this
.
telemetry
.
logKeyedScalar
(
THREE_PANE_ENABLED_SCALAR
this
.
is3PaneModeEnabled
1
)
;
this
.
emit
(
"
ready
"
)
;
return
this
;
}
_onBeforeNavigate
:
function
(
)
{
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
this
.
_pendingSelection
=
null
;
}
_getPageStyle
:
function
(
)
{
return
this
.
inspector
.
getPageStyle
(
)
.
then
(
pageStyle
=
>
{
this
.
pageStyle
=
pageStyle
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
_getDefaultNodeForSelection
:
function
(
)
{
if
(
this
.
_defaultNode
)
{
return
this
.
_defaultNode
;
}
let
walker
=
this
.
walker
;
let
rootNode
=
null
;
let
pendingSelection
=
this
.
_pendingSelection
;
let
hasNavigated
=
(
)
=
>
pendingSelection
!
=
=
this
.
_pendingSelection
;
return
walker
.
getRootNode
(
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
rootNode
=
node
;
if
(
this
.
selectionCssSelector
)
{
return
walker
.
querySelector
(
rootNode
this
.
selectionCssSelector
)
;
}
return
null
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
walker
.
querySelector
(
rootNode
"
body
"
)
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
this
.
walker
.
documentElement
(
)
;
}
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
this
.
_defaultNode
=
node
;
return
node
;
}
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
set
target
(
value
)
{
this
.
_target
=
value
;
}
setupSearchBox
:
function
(
)
{
this
.
searchBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchbox
"
)
;
this
.
searchClearButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchinput
-
clear
"
)
;
this
.
searchResultsLabel
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
"
)
;
this
.
search
=
new
InspectorSearch
(
this
this
.
searchBox
this
.
searchClearButton
)
;
this
.
search
.
on
(
"
search
-
cleared
"
this
.
_clearSearchResultsLabel
)
;
this
.
search
.
on
(
"
search
-
result
"
this
.
_updateSearchResultsLabel
)
;
let
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
panelDoc
.
defaultView
}
)
;
let
key
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
;
shortcuts
.
on
(
key
event
=
>
{
if
(
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
|
|
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
computedview
"
)
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
}
get
searchSuggestions
(
)
{
return
this
.
search
.
autocompleter
;
}
_clearSearchResultsLabel
:
function
(
result
)
{
return
this
.
_updateSearchResultsLabel
(
result
true
)
;
}
_updateSearchResultsLabel
:
function
(
result
clear
=
false
)
{
let
str
=
"
"
;
if
(
!
clear
)
{
if
(
result
)
{
str
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
searchResultsCount2
"
result
.
resultsIndex
+
1
result
.
resultsLength
)
;
}
else
{
str
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchResultsNone
"
)
;
}
}
this
.
searchResultsLabel
.
textContent
=
str
;
}
get
React
(
)
{
return
this
.
_toolbox
.
React
;
}
get
ReactDOM
(
)
{
return
this
.
_toolbox
.
ReactDOM
;
}
get
ReactRedux
(
)
{
return
this
.
_toolbox
.
ReactRedux
;
}
get
browserRequire
(
)
{
return
this
.
_toolbox
.
browserRequire
;
}
get
InspectorTabPanel
(
)
{
if
(
!
this
.
_InspectorTabPanel
)
{
this
.
_InspectorTabPanel
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
components
/
InspectorTabPanel
"
)
)
;
}
return
this
.
_InspectorTabPanel
;
}
get
InspectorSplitBox
(
)
{
if
(
!
this
.
_InspectorSplitBox
)
{
this
.
_InspectorSplitBox
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
splitter
/
SplitBox
"
)
)
;
}
return
this
.
_InspectorSplitBox
;
}
get
TabBar
(
)
{
if
(
!
this
.
_TabBar
)
{
this
.
_TabBar
=
this
.
React
.
createFactory
(
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
tabs
/
TabBar
"
)
)
;
}
return
this
.
_TabBar
;
}
useLandscapeMode
:
function
(
)
{
let
{
clientWidth
}
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
;
return
this
.
is3PaneModeEnabled
&
&
this
.
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
SIDE
?
clientWidth
>
SIDE_PORTAIT_MODE_WIDTH_THRESHOLD
:
clientWidth
>
PORTRAIT_MODE_WIDTH_THRESHOLD
;
}
setupSplitter
:
function
(
)
{
let
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
let
splitter
=
this
.
InspectorSplitBox
(
{
className
:
"
inspector
-
sidebar
-
splitter
"
initialWidth
:
width
initialHeight
:
height
minSize
:
"
10
%
"
maxSize
:
"
80
%
"
splitterSize
:
1
endPanelControl
:
true
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
main
-
content
"
}
)
endPanel
:
this
.
InspectorSplitBox
(
{
initialWidth
:
splitSidebarWidth
minSize
:
10
maxSize
:
"
80
%
"
splitterSize
:
this
.
is3PaneModeEnabled
?
1
:
0
endPanelControl
:
this
.
is3PaneModeEnabled
startPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
rules
-
container
"
}
)
endPanel
:
this
.
InspectorTabPanel
(
{
id
:
"
inspector
-
sidebar
-
container
"
}
)
ref
:
splitbox
=
>
{
this
.
sidebarSplitBox
=
splitbox
;
}
}
)
vert
:
this
.
useLandscapeMode
(
)
onControlledPanelResized
:
this
.
onSidebarResized
}
)
;
this
.
splitBox
=
this
.
ReactDOM
.
render
(
splitter
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
)
;
this
.
panelWin
.
addEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
}
teardownSplitter
:
function
(
)
{
this
.
panelWin
.
removeEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
this
.
sidebar
.
off
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
off
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
off
(
"
destroy
"
this
.
onSidebarHidden
)
;
}
onPanelWindowResize
:
function
(
)
{
this
.
splitBox
.
setState
(
{
vert
:
this
.
useLandscapeMode
(
)
}
)
;
}
getSidebarSize
:
function
(
)
{
let
width
;
let
height
;
let
splitSidebarWidth
;
try
{
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
)
;
splitSidebarWidth
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
)
;
}
catch
(
e
)
{
width
=
this
.
is3PaneModeEnabled
?
INITIAL_SIDEBAR_SIZE
*
2
:
INITIAL_SIDEBAR_SIZE
;
height
=
INITIAL_SIDEBAR_SIZE
;
splitSidebarWidth
=
INITIAL_SIDEBAR_SIZE
;
}
return
{
width
height
splitSidebarWidth
}
;
}
onSidebarHidden
:
function
(
)
{
let
state
=
this
.
splitBox
.
state
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
state
.
width
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
height
.
inspector
"
state
.
height
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
.
splitsidebar
"
this
.
sidebarSplitBox
.
state
.
width
)
;
}
onSidebarResized
:
function
(
width
height
)
{
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
resized
"
{
width
height
}
)
;
}
onSidebarSelect
:
function
(
toolId
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
toolId
)
;
this
.
getPanel
(
toolId
)
;
this
.
toolbox
.
emit
(
"
inspector
-
sidebar
-
select
"
toolId
)
;
}
onSidebarShown
:
function
(
)
{
let
{
width
height
splitSidebarWidth
}
=
this
.
getSidebarSize
(
)
;
this
.
splitBox
.
setState
(
{
width
height
}
)
;
this
.
sidebarSplitBox
.
setState
(
{
width
:
splitSidebarWidth
}
)
;
}
async
onSidebarToggle
(
)
{
this
.
is3PaneModeEnabled
=
!
this
.
is3PaneModeEnabled
;
Services
.
prefs
.
setBoolPref
(
THREE_PANE_ENABLED_PREF
this
.
is3PaneModeEnabled
)
;
await
this
.
setupToolbar
(
)
;
await
this
.
addRuleView
(
)
;
}
async
addRuleView
(
defaultTab
=
"
ruleview
"
)
{
const
ruleViewSidebar
=
this
.
sidebarSplitBox
.
startPanelContainer
;
const
toolboxWidth
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
splitter
-
box
"
)
.
clientWidth
;
if
(
this
.
is3PaneModeEnabled
)
{
ruleViewSidebar
.
style
.
display
=
"
block
"
;
const
sidebarWidth
=
this
.
splitBox
.
state
.
width
;
let
sidebarSplitboxWidth
;
if
(
this
.
useLandscapeMode
(
)
)
{
const
canDoubleSidebarWidth
=
(
sidebarWidth
*
2
)
<
(
toolboxWidth
/
2
)
;
this
.
splitBox
.
setState
(
{
width
:
canDoubleSidebarWidth
?
sidebarWidth
*
2
:
toolboxWidth
*
2
/
3
}
)
;
sidebarSplitboxWidth
=
canDoubleSidebarWidth
?
sidebarWidth
:
toolboxWidth
/
3
;
}
else
{
sidebarSplitboxWidth
=
toolboxWidth
/
2
;
}
this
.
sidebarSplitBox
.
setState
(
{
endPanelControl
:
true
splitterSize
:
1
width
:
sidebarSplitboxWidth
}
)
;
this
.
getPanel
(
"
ruleview
"
)
;
await
this
.
sidebar
.
removeTab
(
"
ruleview
"
)
;
this
.
ruleViewSideBar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
true
)
;
this
.
ruleViewSideBar
.
show
(
"
ruleview
"
)
;
}
else
{
ruleViewSidebar
.
style
.
display
=
"
none
"
;
this
.
splitBox
.
setState
(
{
width
:
this
.
useLandscapeMode
(
)
?
this
.
sidebarSplitBox
.
state
.
width
:
toolboxWidth
}
)
;
this
.
sidebarSplitBox
.
setState
(
{
endPanelControl
:
false
splitterSize
:
0
}
)
;
this
.
ruleViewSideBar
.
hide
(
)
;
await
this
.
ruleViewSideBar
.
removeTab
(
"
ruleview
"
)
;
this
.
sidebar
.
addExistingTab
(
"
ruleview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
defaultTab
=
=
"
ruleview
"
0
)
;
}
this
.
emit
(
"
ruleview
-
added
"
)
;
}
getPanel
:
function
(
id
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
return
this
.
_panels
.
get
(
id
)
;
}
let
panel
;
switch
(
id
)
{
case
"
computedview
"
:
const
{
ComputedViewTool
}
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
computed
/
computed
"
)
;
panel
=
new
ComputedViewTool
(
this
this
.
panelWin
)
;
break
;
case
"
ruleview
"
:
const
{
RuleViewTool
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
;
panel
=
new
RuleViewTool
(
this
this
.
panelWin
)
;
break
;
case
"
boxmodel
"
:
const
BoxModel
=
require
(
"
devtools
/
client
/
inspector
/
boxmodel
/
box
-
model
"
)
;
panel
=
new
BoxModel
(
this
this
.
panelWin
)
;
break
;
default
:
return
null
;
}
this
.
_panels
.
set
(
id
panel
)
;
return
panel
;
}
async
setupSidebar
(
)
{
let
sidebar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
sidebar
"
)
;
let
options
=
{
showAllTabsMenu
:
true
}
;
if
(
this
.
show3PaneToggle
)
{
options
.
sidebarToggleButton
=
{
collapsed
:
!
this
.
is3PaneModeEnabled
collapsePaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
hideThreePaneMode
"
)
expandPaneTitle
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
showThreePaneMode
"
)
onClick
:
this
.
onSidebarToggle
}
;
}
this
.
sidebar
=
new
ToolSidebar
(
sidebar
this
"
inspector
"
options
)
;
let
ruleSideBar
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
rules
-
sidebar
"
)
;
this
.
ruleViewSideBar
=
new
ToolSidebar
(
ruleSideBar
this
"
inspector
"
{
hideTabstripe
:
true
}
)
;
this
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
let
defaultTab
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
if
(
this
.
is3PaneModeEnabled
&
&
defaultTab
=
=
=
"
ruleview
"
)
{
defaultTab
=
"
computedview
"
;
}
await
this
.
addRuleView
(
defaultTab
)
;
if
(
!
this
.
show3PaneToggle
)
{
this
.
sidebar
.
addExistingTab
(
"
computedview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
computedViewTitle
"
)
defaultTab
=
=
"
computedview
"
)
;
}
let
layoutId
=
"
layoutview
"
;
let
layoutTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
layoutViewTitle2
"
)
;
this
.
sidebar
.
addTab
(
layoutId
layoutTitle
{
props
:
{
id
:
layoutId
title
:
layoutTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
layoutview
)
{
const
LayoutView
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
layout
/
layout
"
)
;
this
.
layoutview
=
new
LayoutView
(
this
this
.
panelWin
)
;
}
return
this
.
layoutview
.
provider
;
}
}
defaultTab
=
=
layoutId
)
;
if
(
this
.
show3PaneToggle
)
{
this
.
sidebar
.
addExistingTab
(
"
computedview
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
computedViewTitle
"
)
defaultTab
=
=
"
computedview
"
)
;
}
if
(
this
.
target
.
form
.
animationsActor
)
{
const
animationTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
animationInspectorTitle
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
)
)
{
const
animationId
=
"
newanimationinspector
"
;
this
.
sidebar
.
addTab
(
animationId
animationTitle
{
props
:
{
id
:
animationId
title
:
animationTitle
}
panel
:
(
)
=
>
{
const
AnimationInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
animation
/
animation
"
)
;
this
.
animationinspector
=
new
AnimationInspector
(
this
this
.
panelWin
)
;
return
this
.
animationinspector
.
provider
;
}
}
defaultTab
=
=
animationId
)
;
}
else
{
this
.
sidebar
.
addFrameTab
(
"
animationinspector
"
animationTitle
"
chrome
:
/
/
devtools
/
content
/
inspector
/
animation
-
old
/
animation
-
inspector
.
xhtml
"
defaultTab
=
=
"
animationinspector
"
)
;
}
}
if
(
this
.
canGetUsedFontFaces
)
{
let
fontId
=
"
fontinspector
"
;
let
fontTitle
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
;
this
.
sidebar
.
addTab
(
fontId
fontTitle
{
props
:
{
id
:
fontId
title
:
fontTitle
}
panel
:
(
)
=
>
{
if
(
!
this
.
fontinspector
)
{
const
FontInspector
=
this
.
browserRequire
(
"
devtools
/
client
/
inspector
/
fonts
/
fonts
"
)
;
this
.
fontinspector
=
new
FontInspector
(
this
this
.
panelWin
)
;
}
return
this
.
fontinspector
.
provider
;
}
}
defaultTab
=
=
fontId
)
;
}
this
.
sidebar
.
on
(
"
show
"
this
.
onSidebarShown
)
;
this
.
sidebar
.
on
(
"
hide
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
on
(
"
destroy
"
this
.
onSidebarHidden
)
;
this
.
sidebar
.
show
(
defaultTab
)
;
}
setupExtensionSidebars
(
)
{
for
(
const
[
sidebarId
{
title
}
]
of
this
.
toolbox
.
inspectorExtensionSidebars
)
{
this
.
addExtensionSidebar
(
sidebarId
{
title
}
)
;
}
}
addExtensionSidebar
:
function
(
id
{
title
}
)
{
if
(
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Cannot
create
an
extension
sidebar
for
the
existent
id
:
{
id
}
)
;
}
const
extensionSidebar
=
new
ExtensionSidebar
(
this
{
id
title
}
)
;
this
.
addSidebarTab
(
id
title
extensionSidebar
.
provider
false
)
;
this
.
_panels
.
set
(
id
extensionSidebar
)
;
this
.
toolbox
.
emit
(
extension
-
sidebar
-
created
-
{
id
}
extensionSidebar
)
;
}
removeExtensionSidebar
:
function
(
id
)
{
if
(
!
this
.
_panels
.
has
(
id
)
)
{
throw
new
Error
(
Unable
to
find
a
sidebar
panel
with
id
"
{
id
}
"
)
;
}
const
panel
=
this
.
_panels
.
get
(
id
)
;
if
(
!
(
panel
instanceof
ExtensionSidebar
)
)
{
throw
new
Error
(
The
sidebar
panel
with
id
"
{
id
}
"
is
not
an
ExtensionSidebar
)
;
}
this
.
_panels
.
delete
(
id
)
;
this
.
sidebar
.
removeTab
(
id
)
;
panel
.
destroy
(
)
;
}
addSidebarTab
:
function
(
id
title
panel
selected
)
{
this
.
sidebar
.
addTab
(
id
title
panel
selected
)
;
}
async
supportsEyeDropper
(
)
{
try
{
let
hasSupportsHighlighters
=
await
this
.
target
.
actorHasMethod
(
"
inspector
"
"
supportsHighlighters
"
)
;
let
supportsHighlighters
;
if
(
hasSupportsHighlighters
)
{
supportsHighlighters
=
await
this
.
inspector
.
supportsHighlighters
(
)
;
}
else
{
let
{
nodeFront
}
=
this
.
selection
;
supportsHighlighters
=
nodeFront
&
&
nodeFront
.
isInHTMLDocument
;
}
return
supportsHighlighters
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
false
;
}
}
async
setupToolbar
(
)
{
this
.
teardownToolbar
(
)
;
this
.
addNode
=
this
.
addNode
.
bind
(
this
)
;
this
.
addNodeButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
element
-
add
-
button
"
)
;
this
.
addNodeButton
.
addEventListener
(
"
click
"
this
.
addNode
)
;
let
canShowEyeDropper
=
await
this
.
supportsEyeDropper
(
)
;
if
(
!
this
.
panelDoc
)
{
return
;
}
if
(
canShowEyeDropper
)
{
this
.
onEyeDropperDone
=
this
.
onEyeDropperDone
.
bind
(
this
)
;
this
.
onEyeDropperButtonClicked
=
this
.
onEyeDropperButtonClicked
.
bind
(
this
)
;
this
.
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
this
.
eyeDropperButton
.
disabled
=
false
;
this
.
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
eyedropper
.
label
"
)
;
this
.
eyeDropperButton
.
addEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
}
else
{
let
eyeDropperButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
eyedropper
-
toggle
"
)
;
eyeDropperButton
.
disabled
=
true
;
eyeDropperButton
.
title
=
INSPECTOR_L10N
.
getStr
(
"
eyedropper
.
disabled
.
title
"
)
;
}
}
teardownToolbar
:
function
(
)
{
if
(
this
.
addNodeButton
)
{
this
.
addNodeButton
.
removeEventListener
(
"
click
"
this
.
addNode
)
;
this
.
addNodeButton
=
null
;
}
if
(
this
.
eyeDropperButton
)
{
this
.
eyeDropperButton
.
removeEventListener
(
"
click
"
this
.
onEyeDropperButtonClicked
)
;
this
.
eyeDropperButton
=
null
;
}
}
onNewRoot
:
function
(
)
{
this
.
_newRootStart
=
this
.
panelWin
.
performance
.
now
(
)
;
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
let
onNodeSelected
=
defaultNode
=
>
{
if
(
this
.
_pendingSelection
!
=
onNodeSelected
)
{
return
;
}
this
.
_pendingSelection
=
null
;
this
.
selection
.
setNodeFront
(
defaultNode
{
reason
:
"
navigateaway
"
}
)
;
this
.
_initMarkup
(
)
;
this
.
once
(
"
markuploaded
"
this
.
onMarkupLoaded
)
;
this
.
setupToolbar
(
)
;
}
;
this
.
_pendingSelection
=
onNodeSelected
;
this
.
_getDefaultNodeForSelection
(
)
.
then
(
onNodeSelected
this
.
_handleRejectionIfNotDestroyed
)
;
}
async
onMarkupLoaded
(
)
{
if
(
!
this
.
markup
)
{
return
;
}
let
onExpand
=
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
await
Promise
.
all
(
[
this
.
highlighters
.
restoreFlexboxState
(
)
this
.
highlighters
.
restoreGridState
(
)
]
)
;
this
.
emit
(
"
new
-
root
"
)
;
await
onExpand
;
this
.
emit
(
"
reloaded
"
)
;
if
(
this
.
_newRootStart
)
{
if
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
=
=
"
inspector
"
)
{
let
delay
=
this
.
panelWin
.
performance
.
now
(
)
-
this
.
_newRootStart
;
let
telemetryKey
=
"
DEVTOOLS_INSPECTOR_NEW_ROOT_TO_RELOAD_DELAY_MS
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
telemetryKey
)
;
histogram
.
add
(
delay
)
;
}
delete
this
.
_newRootStart
;
}
}
_selectionCssSelector
:
null
set
selectionCssSelector
(
cssSelector
=
null
)
{
if
(
this
.
_panelDestroyer
)
{
return
;
}
this
.
_selectionCssSelector
=
{
selector
:
cssSelector
url
:
this
.
_target
.
url
}
;
}
get
selectionCssSelector
(
)
{
if
(
this
.
_selectionCssSelector
&
&
this
.
_selectionCssSelector
.
url
=
=
=
this
.
_target
.
url
)
{
return
this
.
_selectionCssSelector
.
selector
;
}
return
null
;
}
canAddHTMLChild
:
function
(
)
{
let
selection
=
this
.
selection
;
let
invalidTagNames
=
[
"
html
"
"
iframe
"
]
;
return
selection
.
isHTMLNode
(
)
&
&
selection
.
isElementNode
(
)
&
&
!
selection
.
isPseudoElementNode
(
)
&
&
!
selection
.
isAnonymousNode
(
)
&
&
!
invalidTagNames
.
includes
(
selection
.
nodeFront
.
nodeName
.
toLowerCase
(
)
)
;
}
onNewSelection
:
function
(
value
reason
)
{
if
(
reason
=
=
=
"
selection
-
destroy
"
)
{
return
;
}
let
selection
=
this
.
selection
.
nodeFront
;
let
btn
=
this
.
panelDoc
.
querySelector
(
"
#
inspector
-
element
-
add
-
button
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
btn
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
btn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
this
.
canGetUniqueSelector
&
&
this
.
selection
.
isElementNode
(
)
)
{
selection
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
this
.
selectionCssSelector
=
selector
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
let
selfUpdate
=
this
.
updating
(
"
inspector
-
panel
"
)
;
executeSoon
(
(
)
=
>
{
try
{
selfUpdate
(
selection
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
)
;
}
updating
:
function
(
name
)
{
if
(
this
.
_updateProgress
&
&
this
.
_updateProgress
.
node
!
=
this
.
selection
.
nodeFront
)
{
this
.
cancelUpdate
(
)
;
}
if
(
!
this
.
_updateProgress
)
{
let
self
=
this
;
this
.
_updateProgress
=
{
node
:
this
.
selection
.
nodeFront
outstanding
:
new
Set
(
)
checkDone
:
function
(
)
{
if
(
this
!
=
=
self
.
_updateProgress
)
{
return
;
}
if
(
!
self
.
selection
|
|
(
this
.
node
!
=
=
self
.
selection
.
nodeFront
)
)
{
self
.
cancelUpdate
(
)
;
return
;
}
if
(
this
.
outstanding
.
size
!
=
=
0
)
{
return
;
}
self
.
_updateProgress
=
null
;
self
.
emit
(
"
inspector
-
updated
"
name
)
;
}
}
;
}
let
progress
=
this
.
_updateProgress
;
let
done
=
function
(
)
{
progress
.
outstanding
.
delete
(
done
)
;
progress
.
checkDone
(
)
;
}
;
progress
.
outstanding
.
add
(
done
)
;
return
done
;
}
cancelUpdate
:
function
(
)
{
this
.
_updateProgress
=
null
;
}
onDetached
:
function
(
parentNode
)
{
this
.
breadcrumbs
.
cutAfter
(
this
.
breadcrumbs
.
indexOf
(
parentNode
)
)
;
let
nodeFront
=
parentNode
?
parentNode
:
this
.
_defaultNode
;
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
detached
"
}
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_panelDestroyer
)
{
return
this
.
_panelDestroyer
;
}
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
pageStyle
=
null
;
}
this
.
cancelUpdate
(
)
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
onDetached
)
;
this
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
this
.
target
.
off
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
off
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
off
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
for
(
let
[
panel
]
of
this
.
_panels
)
{
panel
.
destroy
(
)
;
}
this
.
_panels
.
clear
(
)
;
if
(
this
.
layoutview
)
{
this
.
layoutview
.
destroy
(
)
;
}
if
(
this
.
fontinspector
)
{
this
.
fontinspector
.
destroy
(
)
;
}
if
(
this
.
animationinspector
)
{
this
.
animationinspector
.
destroy
(
)
;
}
if
(
this
.
threePaneTooltip
)
{
this
.
threePaneTooltip
.
destroy
(
)
;
}
let
cssPropertiesDestroyer
=
this
.
_cssProperties
.
front
.
destroy
(
)
;
let
sidebarDestroyer
=
this
.
sidebar
.
destroy
(
)
;
let
ruleViewSideBarDestroyer
=
this
.
ruleViewSideBar
?
this
.
ruleViewSideBar
.
destroy
(
)
:
null
;
let
markupDestroyer
=
this
.
_destroyMarkup
(
)
;
let
highlighterDestroyer
=
this
.
highlighters
.
destroy
(
)
;
this
.
teardownSplitter
(
)
;
this
.
teardownToolbar
(
)
;
this
.
breadcrumbs
.
destroy
(
)
;
this
.
reflowTracker
.
destroy
(
)
;
this
.
styleChangeTracker
.
destroy
(
)
;
this
.
search
.
destroy
(
)
;
this
.
_toolbox
=
null
;
this
.
breadcrumbs
=
null
;
this
.
highlighters
=
null
;
this
.
is3PaneModeEnabled
=
null
;
this
.
panelDoc
=
null
;
this
.
panelWin
.
inspector
=
null
;
this
.
panelWin
=
null
;
this
.
resultsLength
=
null
;
this
.
search
=
null
;
this
.
searchBox
=
null
;
this
.
show3PaneToggle
=
null
;
this
.
show3PaneTooltip
=
null
;
this
.
sidebar
=
null
;
this
.
store
=
null
;
this
.
target
=
null
;
this
.
threePaneTooltip
=
null
;
this
.
_panelDestroyer
=
promise
.
all
(
[
highlighterDestroyer
cssPropertiesDestroyer
markupDestroyer
sidebarDestroyer
ruleViewSideBarDestroyer
]
)
;
return
this
.
_panelDestroyer
;
}
_getClipboardContentForPaste
:
function
(
)
{
let
content
=
clipboardHelper
.
getText
(
)
;
if
(
content
&
&
content
.
trim
(
)
.
length
>
0
)
{
return
content
;
}
return
null
;
}
_onContextMenu
:
function
(
e
)
{
if
(
!
(
e
.
originalTarget
instanceof
Element
)
|
|
e
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
e
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
return
;
}
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
this
.
_openMenu
(
{
screenX
:
e
.
screenX
screenY
:
e
.
screenY
target
:
e
.
target
}
)
;
}
_openMenu
:
function
(
{
target
screenX
=
0
screenY
=
0
}
=
{
}
)
{
if
(
this
.
selection
.
isSlotted
(
)
)
{
return
null
;
}
let
markupContainer
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
this
.
contextMenuTarget
=
target
;
this
.
nodeMenuTriggerInfo
=
markupContainer
&
&
markupContainer
.
editor
.
getInfoAtNode
(
target
)
;
let
isSelectionElement
=
this
.
selection
.
isElementNode
(
)
&
&
!
this
.
selection
.
isPseudoElementNode
(
)
;
let
isEditableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
;
let
isDuplicatableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
&
&
!
this
.
selection
.
isRoot
(
)
;
let
isScreenshotable
=
isSelectionElement
&
&
this
.
canGetUniqueSelector
&
&
this
.
selection
.
nodeFront
.
isTreeDisplayed
;
let
menu
=
new
Menu
(
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
edithtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLEdit
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLEdit
.
accesskey
"
)
disabled
:
!
isEditableElement
|
|
!
this
.
isOuterHTMLEditable
click
:
(
)
=
>
this
.
editHTML
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
add
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddNode
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddNode
.
accesskey
"
)
disabled
:
!
this
.
canAddHTMLChild
(
)
click
:
(
)
=
>
this
.
addNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
duplicatenode
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorDuplicateNode
.
label
"
)
disabled
:
!
isDuplicatableElement
click
:
(
)
=
>
this
.
duplicateNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
delete
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLDelete
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLDelete
.
accesskey
"
)
disabled
:
!
this
.
isDeletable
(
this
.
selection
.
nodeFront
)
click
:
(
)
=
>
this
.
deleteNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAttributesSubmenu
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAttributesSubmenu
.
accesskey
"
)
submenu
:
this
.
_getAttributesSubmenu
(
isEditableElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
for
(
let
name
of
[
"
hover
"
"
active
"
"
focus
"
]
)
{
let
menuitem
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
pseudo
-
"
+
name
label
:
name
type
:
"
checkbox
"
click
:
this
.
togglePseudoClass
.
bind
(
this
"
:
"
+
name
)
}
)
;
if
(
isSelectionElement
)
{
let
checked
=
this
.
selection
.
nodeFront
.
hasPseudoClassLock
(
"
:
"
+
name
)
;
menuitem
.
checked
=
checked
;
}
else
{
menuitem
.
disabled
=
true
;
}
menu
.
append
(
menuitem
)
;
}
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyHTMLSubmenu
.
label
"
)
submenu
:
this
.
_getCopySubmenu
(
markupContainer
isSelectionElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteHTMLSubmenu
.
label
"
)
submenu
:
this
.
_getPasteSubmenu
(
isEditableElement
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
let
isNodeWithChildren
=
this
.
selection
.
isNode
(
)
&
&
markupContainer
.
hasChildren
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
expand
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorExpandNode
.
label
"
)
disabled
:
!
isNodeWithChildren
click
:
(
)
=
>
this
.
expandNode
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
collapse
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCollapseAll
.
label
"
)
disabled
:
!
isNodeWithChildren
|
|
!
markupContainer
.
expanded
click
:
(
)
=
>
this
.
collapseAll
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
scrollnodeintoview
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScrollNodeIntoView
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScrollNodeIntoView
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
scrollNodeIntoView
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
screenshotnode
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorScreenshotNode
.
label
"
)
disabled
:
!
isScreenshotable
click
:
(
)
=
>
this
.
screenshotNode
(
)
.
catch
(
console
.
error
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
useinconsole
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorUseInConsole
.
label
"
)
click
:
(
)
=
>
this
.
useInConsole
(
)
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
showdomproperties
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorShowDOMProperties
.
label
"
)
click
:
(
)
=
>
this
.
showDOMProperties
(
)
}
)
)
;
this
.
buildA11YMenuItem
(
menu
)
;
let
nodeLinkMenuItems
=
this
.
_getNodeLinkMenuItems
(
)
;
if
(
nodeLinkMenuItems
.
filter
(
item
=
>
item
.
visible
)
.
length
>
0
)
{
menu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
separator
"
type
:
"
separator
"
}
)
)
;
}
for
(
let
menuitem
of
nodeLinkMenuItems
)
{
menu
.
append
(
menuitem
)
;
}
menu
.
popup
(
screenX
screenY
this
.
_toolbox
)
;
return
menu
;
}
buildA11YMenuItem
:
function
(
menu
)
{
if
(
!
(
this
.
selection
.
isElementNode
(
)
|
|
this
.
selection
.
isTextNode
(
)
)
|
|
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
accessibility
.
enabled
"
)
)
{
return
;
}
const
showA11YPropsItem
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
showaccessibilityproperties
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorShowAccessibilityProperties
.
label
"
)
click
:
(
)
=
>
this
.
showAccessibilityProperties
(
)
disabled
:
true
}
)
;
this
.
_updateA11YMenuItem
(
showA11YPropsItem
)
;
menu
.
append
(
showA11YPropsItem
)
;
}
_updateA11YMenuItem
:
async
function
(
menuItem
)
{
const
hasMethod
=
await
this
.
target
.
actorHasMethod
(
"
domwalker
"
"
hasAccessibilityProperties
"
)
;
if
(
!
hasMethod
)
{
return
;
}
const
hasA11YProps
=
await
this
.
walker
.
hasAccessibilityProperties
(
this
.
selection
.
nodeFront
)
;
if
(
hasA11YProps
)
{
this
.
_toolbox
.
doc
.
getElementById
(
menuItem
.
id
)
.
disabled
=
menuItem
.
disabled
=
false
;
}
this
.
emit
(
"
node
-
menu
-
updated
"
)
;
}
_getCopySubmenu
:
function
(
markupContainer
isSelectionElement
)
{
let
copySubmenu
=
new
Menu
(
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyinner
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyInnerHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyInnerHTML
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
copyInnerHTML
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyouter
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyOuterHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyOuterHTML
.
accesskey
"
)
disabled
:
!
isSelectionElement
click
:
(
)
=
>
this
.
copyOuterHTML
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyuniqueselector
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSSelector
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSSelector
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetUniqueSelector
click
:
(
)
=
>
this
.
copyUniqueSelector
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copycsspath
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSPath
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyCSSPath
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetCssPath
click
:
(
)
=
>
this
.
copyCssPath
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyxpath
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyXPath
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyXPath
.
accesskey
"
)
disabled
:
!
isSelectionElement
hidden
:
!
this
.
canGetXPath
click
:
(
)
=
>
this
.
copyXPath
(
)
}
)
)
;
copySubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copyimagedatauri
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorImageDataUri
.
label
"
)
disabled
:
!
isSelectionElement
|
|
!
markupContainer
|
|
!
markupContainer
.
isPreviewable
(
)
click
:
(
)
=
>
this
.
copyImageDataUri
(
)
}
)
)
;
return
copySubmenu
;
}
_getPasteSubmenu
:
function
(
isEditableElement
)
{
let
isPasteable
=
isEditableElement
&
&
this
.
_getClipboardContentForPaste
(
)
;
let
disableAdjacentPaste
=
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
|
|
this
.
selection
.
isRoot
(
)
|
|
this
.
selection
.
isBodyNode
(
)
|
|
this
.
selection
.
isHeadNode
(
)
;
let
disableFirstLastPaste
=
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
|
|
(
this
.
selection
.
isHTMLNode
(
)
&
&
this
.
selection
.
isRoot
(
)
)
;
let
pasteSubmenu
=
new
Menu
(
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteinnerhtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteInnerHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteInnerHTML
.
accesskey
"
)
disabled
:
!
isPasteable
|
|
!
this
.
canPasteInnerOrAdjacentHTML
click
:
(
)
=
>
this
.
pasteInnerHTML
(
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteouterhtml
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteOuterHTML
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorPasteOuterHTML
.
accesskey
"
)
disabled
:
!
isPasteable
|
|
!
this
.
isOuterHTMLEditable
click
:
(
)
=
>
this
.
pasteOuterHTML
(
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastebefore
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteBefore
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteBefore
.
accesskey
"
)
disabled
:
disableAdjacentPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
beforeBegin
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pasteafter
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteAfter
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteAfter
.
accesskey
"
)
disabled
:
disableAdjacentPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
afterEnd
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastefirstchild
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteFirstChild
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteFirstChild
.
accesskey
"
)
disabled
:
disableFirstLastPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
afterBegin
"
)
}
)
)
;
pasteSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
pastelastchild
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteLastChild
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorHTMLPasteLastChild
.
accesskey
"
)
disabled
:
disableFirstLastPaste
click
:
(
)
=
>
this
.
pasteAdjacentHTML
(
"
beforeEnd
"
)
}
)
)
;
return
pasteSubmenu
;
}
_getAttributesSubmenu
:
function
(
isEditableElement
)
{
let
attributesSubmenu
=
new
Menu
(
)
;
let
nodeInfo
=
this
.
nodeMenuTriggerInfo
;
let
isAttributeClicked
=
isEditableElement
&
&
nodeInfo
&
&
nodeInfo
.
type
=
=
=
"
attribute
"
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
add
-
attribute
"
label
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddAttribute
.
label
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorAddAttribute
.
accesskey
"
)
disabled
:
!
isEditableElement
click
:
(
)
=
>
this
.
onAddAttribute
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
copy
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorCopyAttributeValue
.
label
"
isAttributeClicked
?
{
nodeInfo
.
value
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorCopyAttributeValue
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onCopyAttributeValue
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
edit
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorEditAttribute
.
label
"
isAttributeClicked
?
{
nodeInfo
.
name
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorEditAttribute
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onEditAttribute
(
)
}
)
)
;
attributesSubmenu
.
append
(
new
MenuItem
(
{
id
:
"
node
-
menu
-
remove
-
attribute
"
label
:
INSPECTOR_L10N
.
getFormatStr
(
"
inspectorRemoveAttribute
.
label
"
isAttributeClicked
?
{
nodeInfo
.
name
}
:
"
"
)
accesskey
:
INSPECTOR_L10N
.
getStr
(
"
inspectorRemoveAttribute
.
accesskey
"
)
disabled
:
!
isAttributeClicked
click
:
(
)
=
>
this
.
onRemoveAttribute
(
)
}
)
)
;
return
attributesSubmenu
;
}
_getNodeLinkMenuItems
:
function
(
)
{
let
linkFollow
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
follow
"
visible
:
false
click
:
(
)
=
>
this
.
onFollowLink
(
)
}
)
;
let
linkCopy
=
new
MenuItem
(
{
id
:
"
node
-
menu
-
link
-
copy
"
visible
:
false
click
:
(
)
=
>
this
.
onCopyLink
(
)
}
)
;
let
popupNode
=
this
.
contextMenuTarget
;
if
(
!
popupNode
|
|
!
popupNode
.
classList
.
contains
(
"
link
"
)
)
{
return
[
linkFollow
linkCopy
]
;
}
let
type
=
popupNode
.
dataset
.
type
;
if
(
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
)
{
if
(
type
=
=
=
"
uri
"
&
&
!
this
.
target
.
chrome
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
menu
.
openUrlInNewTab
.
label
"
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
TOOLBOX_L10N
.
getStr
(
"
toolbox
.
viewCssSourceInStyleEditor
.
label
"
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
TOOLBOX_L10N
.
getStr
(
"
toolbox
.
viewJsSourceInDebugger
.
label
"
)
;
}
linkCopy
.
visible
=
true
;
linkCopy
.
label
=
INSPECTOR_L10N
.
getStr
(
"
inspector
.
menu
.
copyUrlToClipboard
.
label
"
)
;
}
else
if
(
type
=
=
=
"
idref
"
)
{
linkFollow
.
visible
=
true
;
linkFollow
.
label
=
INSPECTOR_L10N
.
getFormatStr
(
"
inspector
.
menu
.
selectElement
.
label
"
popupNode
.
dataset
.
link
)
;
}
return
[
linkFollow
linkCopy
]
;
}
_initMarkup
:
function
(
)
{
let
doc
=
this
.
panelDoc
;
this
.
_markupBox
=
doc
.
getElementById
(
"
markup
-
box
"
)
;
this
.
_markupFrame
=
doc
.
createElement
(
"
iframe
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
this
.
_markupFrame
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
_markupBox
.
style
.
visibility
=
"
hidden
"
;
this
.
_markupBox
.
appendChild
(
this
.
_markupFrame
)
;
this
.
_markupFrame
.
addEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
setAttribute
(
"
src
"
"
markup
/
markup
.
xhtml
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
aria
-
label
"
INSPECTOR_L10N
.
getStr
(
"
inspector
.
panelLabel
.
markupView
"
)
)
;
}
_onMarkupFrameLoad
:
function
(
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
contentWindow
.
focus
(
)
;
this
.
markup
=
new
MarkupView
(
this
this
.
_markupFrame
this
.
_toolbox
.
win
)
;
this
.
_markupBox
.
style
.
visibility
=
"
visible
"
;
this
.
emit
(
"
markuploaded
"
)
;
}
_destroyMarkup
:
function
(
)
{
let
destroyPromise
;
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
}
if
(
this
.
markup
)
{
destroyPromise
=
this
.
markup
.
destroy
(
)
;
this
.
markup
=
null
;
}
else
{
destroyPromise
=
promise
.
resolve
(
)
;
}
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
remove
(
)
;
this
.
_markupFrame
=
null
;
}
this
.
_markupBox
=
null
;
return
destroyPromise
;
}
onEyeDropperButtonClicked
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
contains
(
"
checked
"
)
?
this
.
hideEyeDropper
(
)
:
this
.
showEyeDropper
(
)
;
}
startEyeDropperListeners
:
function
(
)
{
this
.
inspector
.
once
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspector
.
once
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
once
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
stopEyeDropperListeners
:
function
(
)
{
this
.
inspector
.
off
(
"
color
-
pick
-
canceled
"
this
.
onEyeDropperDone
)
;
this
.
inspector
.
off
(
"
color
-
picked
"
this
.
onEyeDropperDone
)
;
this
.
walker
.
off
(
"
new
-
root
"
this
.
onEyeDropperDone
)
;
}
onEyeDropperDone
:
function
(
)
{
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
}
showEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
telemetry
.
toolOpened
(
"
toolbareyedropper
"
)
;
this
.
eyeDropperButton
.
classList
.
add
(
"
checked
"
)
;
this
.
startEyeDropperListeners
(
)
;
return
this
.
inspector
.
pickColorFromPage
(
this
.
toolbox
{
copyOnSelect
:
true
}
)
.
catch
(
console
.
error
)
;
}
hideEyeDropper
:
function
(
)
{
if
(
!
this
.
eyeDropperButton
)
{
return
null
;
}
this
.
eyeDropperButton
.
classList
.
remove
(
"
checked
"
)
;
this
.
stopEyeDropperListeners
(
)
;
return
this
.
inspector
.
cancelPickColorFromPage
(
)
.
catch
(
console
.
error
)
;
}
async
addNode
(
)
{
if
(
!
this
.
canAddHTMLChild
(
)
)
{
return
;
}
let
html
=
"
<
div
>
<
/
div
>
"
;
let
onMutations
=
this
.
once
(
"
markupmutation
"
)
;
await
this
.
walker
.
insertAdjacentHTML
(
this
.
selection
.
nodeFront
"
beforeEnd
"
html
)
;
await
onMutations
;
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
}
togglePseudoClass
:
function
(
pseudo
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
let
node
=
this
.
selection
.
nodeFront
;
if
(
node
.
hasPseudoClassLock
(
pseudo
)
)
{
return
this
.
walker
.
removePseudoClassLock
(
node
pseudo
{
parents
:
true
}
)
;
}
let
hierarchical
=
pseudo
=
=
"
:
hover
"
|
|
pseudo
=
=
"
:
active
"
;
return
this
.
walker
.
addPseudoClassLock
(
node
pseudo
{
parents
:
hierarchical
}
)
;
}
return
promise
.
resolve
(
)
;
}
showDOMProperties
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
jsterm
.
execute
(
"
inspect
(
0
)
"
)
;
jsterm
.
focus
(
)
;
}
)
;
}
async
showAccessibilityProperties
(
)
{
let
a11yPanel
=
await
this
.
_toolbox
.
selectTool
(
"
accessibility
"
)
;
let
onSelected
=
a11yPanel
.
once
(
"
new
-
accessible
-
front
-
selected
"
)
;
a11yPanel
.
selectAccessibleForNode
(
this
.
selection
.
nodeFront
"
inspector
-
context
-
menu
"
)
;
await
onSelected
;
}
useInConsole
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
let
evalString
=
{
let
i
=
0
;
while
(
window
.
hasOwnProperty
(
"
temp
"
+
i
)
&
&
i
<
1000
)
{
i
+
+
;
}
window
[
"
temp
"
+
i
]
=
0
;
"
temp
"
+
i
;
}
;
let
options
=
{
selectedNodeActor
:
this
.
selection
.
nodeFront
.
actorID
}
;
jsterm
.
requestEvaluation
(
evalString
options
)
.
then
(
(
res
)
=
>
{
jsterm
.
setInputValue
(
res
.
result
)
;
this
.
emit
(
"
console
-
var
-
ready
"
)
;
}
)
;
}
)
;
}
editHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
beginEditingOuterHTML
(
this
.
selection
.
nodeFront
)
;
}
}
pasteOuterHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeOuterHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeOuterHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteInnerHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeInnerHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeInnerHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteAdjacentHTML
:
function
(
position
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
{
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
}
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
insertAdjacentHTMLToNode
(
node
position
content
)
;
}
copyInnerHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
_copyLongString
(
this
.
walker
.
innerHTML
(
this
.
selection
.
nodeFront
)
)
;
}
copyOuterHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
let
node
=
this
.
selection
.
nodeFront
;
switch
(
node
.
nodeType
)
{
case
nodeConstants
.
ELEMENT_NODE
:
this
.
_copyLongString
(
this
.
walker
.
outerHTML
(
node
)
)
;
break
;
case
nodeConstants
.
COMMENT_NODE
:
this
.
_getLongString
(
node
.
getNodeValue
(
)
)
.
then
(
comment
=
>
{
clipboardHelper
.
copyString
(
"
<
!
-
-
"
+
comment
+
"
-
-
>
"
)
;
}
)
;
break
;
case
nodeConstants
.
DOCUMENT_TYPE_NODE
:
clipboardHelper
.
copyString
(
node
.
doctypeString
)
;
break
;
}
}
copyImageDataUri
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
if
(
container
&
&
container
.
isPreviewable
(
)
)
{
container
.
copyImageDataUri
(
)
;
}
}
_copyLongString
:
function
(
longStringActorPromise
)
{
return
this
.
_getLongString
(
longStringActorPromise
)
.
then
(
string
=
>
{
clipboardHelper
.
copyString
(
string
)
;
}
)
.
catch
(
console
.
error
)
;
}
_getLongString
:
function
(
longStringActorPromise
)
{
return
longStringActorPromise
.
then
(
longStringActor
=
>
{
return
longStringActor
.
string
(
)
.
then
(
string
=
>
{
longStringActor
.
release
(
)
.
catch
(
console
.
error
)
;
return
string
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyUniqueSelector
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
logScalar
(
"
devtools
.
copy
.
unique
.
css
.
selector
.
opened
"
1
)
;
this
.
selection
.
nodeFront
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
clipboardHelper
.
copyString
(
selector
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyCssPath
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
logScalar
(
"
devtools
.
copy
.
full
.
css
.
selector
.
opened
"
1
)
;
this
.
selection
.
nodeFront
.
getCssPath
(
)
.
then
(
path
=
>
{
clipboardHelper
.
copyString
(
path
)
;
}
)
.
catch
(
console
.
error
)
;
}
copyXPath
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
telemetry
.
logScalar
(
"
devtools
.
copy
.
xpath
.
opened
"
1
)
;
this
.
selection
.
nodeFront
.
getXPath
(
)
.
then
(
path
=
>
{
clipboardHelper
.
copyString
(
path
)
;
}
)
.
catch
(
console
.
error
)
;
}
async
screenshotNode
(
)
{
const
command
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
clipboard
.
enabled
"
)
?
"
screenshot
-
-
file
-
-
clipboard
-
-
selector
"
:
"
screenshot
-
-
file
-
-
selector
"
;
await
this
.
highlighter
.
hideBoxModel
(
)
;
CommandUtils
.
executeOnTarget
(
this
.
_target
{
command
}
'
{
this
.
selectionCssSelector
}
'
)
;
}
scrollNodeIntoView
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
selection
.
nodeFront
.
scrollIntoView
(
)
;
}
duplicateNode
:
function
(
)
{
let
selection
=
this
.
selection
;
if
(
!
selection
.
isElementNode
(
)
|
|
selection
.
isRoot
(
)
|
|
selection
.
isAnonymousNode
(
)
|
|
selection
.
isPseudoElementNode
(
)
)
{
return
;
}
this
.
walker
.
duplicateNode
(
selection
.
nodeFront
)
.
catch
(
console
.
error
)
;
}
deleteNode
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
|
|
this
.
selection
.
isRoot
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
deleteNode
(
this
.
selection
.
nodeFront
)
;
}
else
{
this
.
walker
.
removeNode
(
this
.
selection
.
nodeFront
)
;
}
}
onAddAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
addAttribute
(
)
;
}
onCopyAttributeValue
:
function
(
)
{
clipboardHelper
.
copyString
(
this
.
nodeMenuTriggerInfo
.
value
)
;
}
onEditAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
editAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
onRemoveAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
removeAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
expandNode
:
function
(
)
{
this
.
markup
.
expandAll
(
this
.
selection
.
nodeFront
)
;
}
collapseAll
:
function
(
)
{
this
.
markup
.
collapseAll
(
this
.
selection
.
nodeFront
)
;
}
onFollowLink
:
function
(
)
{
let
type
=
this
.
contextMenuTarget
.
dataset
.
type
;
let
link
=
this
.
contextMenuTarget
.
dataset
.
link
;
this
.
followAttributeLink
(
type
link
)
;
}
followAttributeLink
:
function
(
type
link
)
{
if
(
!
type
|
|
!
link
)
{
return
;
}
if
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
if
(
type
=
=
=
"
uri
"
)
{
let
browserWin
=
this
.
target
.
tab
.
ownerDocument
.
defaultView
;
browserWin
.
openWebLinkIn
(
url
"
tab
"
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
return
this
.
toolbox
.
viewSourceInStyleEditor
(
url
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
return
this
.
toolbox
.
viewSourceInDebugger
(
url
)
;
}
return
null
;
}
)
.
catch
(
console
.
error
)
;
}
else
if
(
type
=
=
"
idref
"
)
{
this
.
walker
.
document
(
this
.
selection
.
nodeFront
)
.
then
(
doc
=
>
{
return
this
.
walker
.
querySelector
(
doc
"
#
"
+
CSS
.
escape
(
link
)
)
.
then
(
node
=
>
{
if
(
!
node
)
{
this
.
emit
(
"
idref
-
attribute
-
link
-
failed
"
)
;
return
;
}
this
.
selection
.
setNodeFront
(
node
)
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
}
onCopyLink
:
function
(
)
{
let
link
=
this
.
contextMenuTarget
.
dataset
.
link
;
this
.
copyAttributeLink
(
link
)
;
}
copyAttributeLink
:
function
(
link
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
clipboardHelper
.
copyString
(
url
)
;
}
console
.
error
)
;
}
getCommonComponentProps
(
)
{
return
{
setSelectedNode
:
this
.
selection
.
setNodeFront
onShowBoxModelHighlighterForNode
:
this
.
onShowBoxModelHighlighterForNode
}
;
}
onShowBoxModelHighlighterForNode
(
nodeFront
options
)
{
let
toolbox
=
this
.
toolbox
;
toolbox
.
highlighterUtils
.
highlightNodeFront
(
nodeFront
options
)
;
}
isDeletable
(
nodeFront
)
{
return
!
(
nodeFront
.
isDocumentElement
|
|
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_TYPE_NODE
|
|
nodeFront
.
isAnonymous
)
;
}
async
inspectNodeActor
(
nodeActor
inspectFromAnnotation
)
{
const
nodeFront
=
await
this
.
walker
.
getNodeActorFromObjectActor
(
nodeActor
)
;
if
(
!
nodeFront
)
{
console
.
error
(
"
The
object
cannot
be
linked
to
the
inspector
the
"
+
"
corresponding
nodeFront
could
not
be
found
.
"
)
;
return
false
;
}
let
isAttached
=
await
this
.
walker
.
isInDOMTree
(
nodeFront
)
;
if
(
!
isAttached
)
{
console
.
error
(
"
Selected
DOMNode
is
not
attached
to
the
document
tree
.
"
)
;
return
false
;
}
await
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
inspectFromAnnotation
}
)
;
return
true
;
}
}
;
exports
.
Inspector
=
Inspector
;
