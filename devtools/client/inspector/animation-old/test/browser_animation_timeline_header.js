"
use
strict
"
;
requestLongerTimeout
(
2
)
;
const
{
findOptimalTimeInterval
TimeScale
}
=
require
(
"
devtools
/
client
/
inspector
/
animation
-
old
/
utils
"
)
;
const
TIME_GRADUATION_MIN_SPACING
=
40
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
false
)
;
await
addTab
(
URL_ROOT
+
"
doc_simple_animation
.
html
"
)
;
await
pushPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
350
)
;
const
{
panel
}
=
await
openAnimationInspector
(
)
;
const
timeline
=
panel
.
animationsTimelineComponent
;
const
headerEl
=
timeline
.
timeHeaderEl
;
info
(
"
Find
out
how
many
time
graduations
should
there
be
"
)
;
const
width
=
headerEl
.
offsetWidth
;
const
animationDuration
=
TimeScale
.
maxEndTime
-
TimeScale
.
minStartTime
;
const
minTimeInterval
=
TIME_GRADUATION_MIN_SPACING
*
animationDuration
/
width
;
const
interval
=
findOptimalTimeInterval
(
minTimeInterval
)
;
const
nb
=
Math
.
ceil
(
animationDuration
/
interval
)
;
is
(
headerEl
.
querySelectorAll
(
"
.
header
-
item
"
)
.
length
nb
"
The
expected
number
of
time
ticks
were
found
"
)
;
info
(
"
Make
sure
graduations
are
evenly
distributed
and
show
the
right
times
"
)
;
[
.
.
.
headerEl
.
querySelectorAll
(
"
.
time
-
tick
"
)
]
.
forEach
(
(
tick
i
)
=
>
{
const
left
=
parseFloat
(
tick
.
style
.
left
)
;
const
expectedPos
=
i
*
interval
*
100
/
animationDuration
;
is
(
Math
.
round
(
left
)
Math
.
round
(
expectedPos
)
Graduation
{
i
}
is
positioned
correctly
)
;
const
formattedTime
=
TimeScale
.
formatTime
(
TimeScale
.
distanceToRelativeTime
(
expectedPos
width
)
)
;
is
(
tick
.
textContent
formattedTime
Graduation
{
i
}
has
the
right
text
content
)
;
}
)
;
}
)
;
