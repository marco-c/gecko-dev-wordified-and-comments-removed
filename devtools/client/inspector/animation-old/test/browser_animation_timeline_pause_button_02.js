"
use
strict
"
;
requestLongerTimeout
(
2
)
;
add_task
(
async
function
(
)
{
await
addTab
(
URL_ROOT
+
"
doc_simple_animation
.
html
"
)
;
const
{
panel
inspector
}
=
await
openAnimationInspector
(
)
;
const
timeline
=
panel
.
animationsTimelineComponent
;
const
btn
=
panel
.
playTimelineButtonEl
;
info
(
"
Select
an
infinite
animation
and
wait
for
the
scrubber
to
reach
the
end
"
)
;
await
selectNodeAndWaitForAnimations
(
"
.
multi
"
inspector
)
;
await
waitForOutOfBoundScrubber
(
timeline
)
;
ok
(
!
btn
.
classList
.
contains
(
"
paused
"
)
"
The
button
is
in
its
playing
state
still
animations
are
infinite
.
"
)
;
await
assertScrubberMoving
(
panel
true
)
;
info
(
"
Click
on
the
button
after
the
scrubber
has
moved
out
of
bounds
"
)
;
await
clickTimelinePlayPauseButton
(
panel
)
;
ok
(
btn
.
classList
.
contains
(
"
paused
"
)
"
The
button
can
be
paused
after
the
scrubber
has
moved
out
of
bounds
"
)
;
await
assertScrubberMoving
(
panel
false
)
;
}
)
;
function
waitForOutOfBoundScrubber
(
{
win
scrubberEl
}
)
{
return
new
Promise
(
resolve
=
>
{
function
check
(
)
{
const
pos
=
scrubberEl
.
getBoxQuads
(
)
[
0
]
.
bounds
.
right
;
const
width
=
win
.
document
.
documentElement
.
offsetWidth
;
if
(
pos
>
=
width
)
{
setTimeout
(
resolve
50
)
;
}
else
{
setTimeout
(
check
50
)
;
}
}
check
(
)
;
}
)
;
}
