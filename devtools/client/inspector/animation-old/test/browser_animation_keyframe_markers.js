"
use
strict
"
;
const
EXPECTED_PROPERTIES
=
[
"
backgroundColor
"
"
backgroundPosition
"
"
backgroundSize
"
"
borderBottomLeftRadius
"
"
borderBottomRightRadius
"
"
borderTopLeftRadius
"
"
borderTopRightRadius
"
"
filter
"
"
height
"
"
transform
"
"
width
"
]
;
add_task
(
async
function
(
)
{
await
addTab
(
URL_ROOT
+
"
doc_keyframes
.
html
"
)
;
const
{
panel
}
=
await
openAnimationInspector
(
)
;
const
timeline
=
panel
.
animationsTimelineComponent
;
ok
(
timeline
.
rootWrapperEl
.
querySelectorAll
(
"
.
frames
.
keyframes
"
)
.
length
"
There
are
container
elements
for
displaying
keyframes
"
)
;
const
data
=
await
getExpectedKeyframesData
(
timeline
.
animations
[
0
]
)
;
for
(
const
propertyName
in
data
)
{
info
(
"
Check
the
keyframe
markers
for
"
+
propertyName
)
;
const
widthMarkerSelector
=
"
.
frame
[
data
-
property
=
"
+
propertyName
+
"
]
"
;
const
markers
=
timeline
.
rootWrapperEl
.
querySelectorAll
(
widthMarkerSelector
)
;
is
(
markers
.
length
data
[
propertyName
]
.
length
"
The
right
number
of
keyframes
was
found
for
"
+
propertyName
)
;
const
offsets
=
[
.
.
.
markers
]
.
map
(
m
=
>
parseFloat
(
m
.
dataset
.
offset
)
)
;
const
values
=
[
.
.
.
markers
]
.
map
(
m
=
>
m
.
dataset
.
value
)
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
is
(
markers
[
i
]
.
dataset
.
offset
offsets
[
i
]
"
Marker
"
+
i
+
"
for
"
+
propertyName
+
"
has
the
right
offset
"
)
;
is
(
markers
[
i
]
.
dataset
.
value
values
[
i
]
"
Marker
"
+
i
+
"
for
"
+
propertyName
+
"
has
the
right
value
"
)
;
}
}
}
)
;
async
function
getExpectedKeyframesData
(
animation
)
{
const
properties
=
await
animation
.
getProperties
(
)
;
const
data
=
{
}
;
for
(
const
expectedProperty
of
EXPECTED_PROPERTIES
)
{
data
[
expectedProperty
]
=
[
]
;
for
(
const
{
name
values
}
of
properties
)
{
if
(
name
!
=
=
expectedProperty
)
{
continue
;
}
for
(
const
{
offset
value
}
of
values
)
{
data
[
expectedProperty
]
.
push
(
{
offset
value
}
)
;
}
}
}
return
data
;
}
