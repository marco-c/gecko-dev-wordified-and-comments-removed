"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
FRAME_SCRIPT_URL
=
CHROME_URL_ROOT
+
"
doc_frame_script
.
js
"
;
const
TAB_NAME
=
"
animationinspector
"
;
const
ANIMATION_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
registerCleanupFunction
(
async
function
(
)
{
await
closeAnimationInspector
(
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
log
"
)
;
}
)
;
function
enableAnimationFeatures
(
)
{
return
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
dom
.
animations
-
api
.
core
.
enabled
"
true
]
[
"
layout
.
css
.
frames
-
timing
.
enabled
"
true
]
]
}
resolve
)
;
}
)
;
}
var
_addTab
=
addTab
;
addTab
=
function
(
url
)
{
return
enableAnimationFeatures
(
)
.
then
(
(
)
=
>
_addTab
(
url
)
)
.
then
(
tab
=
>
{
let
browser
=
tab
.
linkedBrowser
;
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
loadFrameScriptUtils
(
browser
)
;
return
tab
;
}
)
;
}
;
async
function
reloadTab
(
inspector
)
{
let
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
await
executeInContent
(
"
devtools
:
test
:
reload
"
{
}
{
}
false
)
;
await
onNewRoot
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
var
selectNodeAndWaitForAnimations
=
async
function
(
data
inspector
reason
=
"
test
"
)
{
let
{
AnimationsController
AnimationsPanel
}
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
let
onUiUpdated
=
AnimationsPanel
.
once
(
AnimationsPanel
.
UI_UPDATED_EVENT
)
;
await
selectNode
(
data
inspector
reason
)
;
await
onUiUpdated
;
if
(
AnimationsController
.
animationPlayers
.
length
!
=
=
0
)
{
await
waitForAnimationTimelineRendering
(
AnimationsPanel
)
;
await
waitForAllAnimationTargets
(
AnimationsPanel
)
;
}
}
;
function
assertAnimationsDisplayed
(
panel
nbAnimations
msg
=
"
"
)
{
msg
=
msg
|
|
There
are
{
nbAnimations
}
animations
in
the
panel
;
is
(
panel
.
animationsTimelineComponent
.
animationsEl
.
querySelectorAll
(
"
.
animation
"
)
.
length
nbAnimations
msg
)
;
}
var
waitForAnimationInspectorReady
=
async
function
(
inspector
)
{
let
win
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
let
tabReady
=
win
.
document
.
readyState
=
=
=
"
complete
"
?
promise
.
resolve
(
)
:
inspector
.
sidebar
.
once
(
"
animationinspector
-
ready
"
)
;
return
promise
.
all
(
[
updated
tabReady
]
)
;
}
;
var
openAnimationInspector
=
async
function
(
)
{
let
{
inspector
toolbox
}
=
await
openInspectorSidebarTab
(
TAB_NAME
)
;
info
(
"
Waiting
for
the
inspector
and
sidebar
to
be
ready
"
)
;
await
waitForAnimationInspectorReady
(
inspector
)
;
let
win
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
let
{
AnimationsController
AnimationsPanel
}
=
win
;
info
(
"
Waiting
for
the
animation
controller
and
panel
to
be
ready
"
)
;
if
(
AnimationsPanel
.
initialized
)
{
await
AnimationsPanel
.
initialized
;
}
else
{
await
AnimationsPanel
.
once
(
AnimationsPanel
.
PANEL_INITIALIZED
)
;
}
if
(
AnimationsController
.
animationPlayers
.
length
!
=
=
0
)
{
await
waitForAnimationTimelineRendering
(
AnimationsPanel
)
;
await
waitForAllAnimationTargets
(
AnimationsPanel
)
;
}
return
{
toolbox
:
toolbox
inspector
:
inspector
controller
:
AnimationsController
panel
:
AnimationsPanel
window
:
win
}
;
}
;
var
closeAnimationInspector
=
async
function
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
}
;
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
return
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
resolve
(
msg
.
data
)
;
}
)
;
}
)
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
var
getAnimationPlayerState
=
async
function
(
selector
animationIndex
=
0
)
{
let
playState
=
await
executeInContent
(
"
Test
:
GetAnimationPlayerState
"
{
selector
animationIndex
}
)
;
return
playState
;
}
;
function
isNodeVisible
(
node
)
{
return
!
!
node
.
getClientRects
(
)
.
length
;
}
var
waitForAllAnimationTargets
=
async
function
(
panel
)
{
let
targets
=
getAnimationTargetNodes
(
panel
)
;
await
promise
.
all
(
targets
.
map
(
t
=
>
{
if
(
!
t
.
previewer
.
nodeFront
)
{
return
t
.
once
(
"
target
-
retrieved
"
)
;
}
return
false
;
}
)
)
;
return
targets
;
}
;
async
function
assertScrubberMoving
(
panel
isMoving
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
if
(
isMoving
)
{
let
{
time
:
time1
}
=
await
timeline
.
once
(
"
timeline
-
data
-
changed
"
)
;
let
{
time
:
time2
}
=
await
timeline
.
once
(
"
timeline
-
data
-
changed
"
)
;
ok
(
time2
>
time1
"
The
scrubber
is
moving
"
)
;
}
else
{
let
hasMoved
=
false
;
timeline
.
once
(
"
timeline
-
data
-
changed
"
(
)
=
>
{
hasMoved
=
true
;
}
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
500
)
)
;
ok
(
!
hasMoved
"
The
scrubber
is
not
moving
"
)
;
}
}
async
function
clickTimelinePlayPauseButton
(
panel
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
onRendered
=
waitForAnimationTimelineRendering
(
panel
)
;
let
btn
=
panel
.
playTimelineButtonEl
;
let
win
=
btn
.
ownerDocument
.
defaultView
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
btn
win
)
;
await
onUiUpdated
;
await
onRendered
;
await
waitForAllAnimationTargets
(
panel
)
;
}
async
function
clickTimelineRewindButton
(
panel
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
onRendered
=
waitForAnimationTimelineRendering
(
panel
)
;
let
btn
=
panel
.
rewindTimelineButtonEl
;
let
win
=
btn
.
ownerDocument
.
defaultView
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
btn
win
)
;
await
onUiUpdated
;
await
onRendered
;
await
waitForAllAnimationTargets
(
panel
)
;
}
async
function
changeTimelinePlaybackRate
(
panel
rate
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
select
=
panel
.
rateSelectorEl
.
firstChild
;
let
win
=
select
.
ownerDocument
.
defaultView
;
let
option
=
[
.
.
.
select
.
options
]
.
filter
(
o
=
>
o
.
value
=
=
=
rate
+
"
"
)
[
0
]
;
if
(
!
option
)
{
ok
(
false
"
Could
not
find
an
option
for
rate
"
+
rate
+
"
in
the
rate
selector
.
"
+
"
Values
are
:
"
+
[
.
.
.
select
.
options
]
.
map
(
o
=
>
o
.
value
)
)
;
return
;
}
EventUtils
.
synthesizeMouseAtCenter
(
select
{
type
:
"
mousedown
"
}
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
option
{
type
:
"
mouseup
"
}
win
)
;
await
onUiUpdated
;
await
waitForAnimationTimelineRendering
(
panel
)
;
await
waitForAllAnimationTargets
(
panel
)
;
EventUtils
.
synthesizeMouseAtCenter
(
win
.
document
.
querySelector
(
"
#
timeline
-
toolbar
"
)
{
type
:
"
mousemove
"
}
win
)
;
}
async
function
waitForAnimationSelecting
(
panel
)
{
await
panel
.
animationsTimelineComponent
.
once
(
"
animation
-
selected
"
)
;
}
function
waitForAnimationTimelineRendering
(
panel
)
{
return
panel
.
animationsTimelineComponent
.
once
(
"
animation
-
timeline
-
rendering
-
completed
"
)
;
}
async
function
clickOnTimelineHeader
(
panel
position
)
{
const
timeline
=
panel
.
animationsTimelineComponent
;
const
onTimelineDataChanged
=
timeline
.
once
(
"
timeline
-
data
-
changed
"
)
;
const
header
=
timeline
.
timeHeaderEl
;
const
clientX
=
header
.
offsetLeft
+
header
.
offsetWidth
*
position
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
mousedown
"
clientX
:
clientX
}
header
header
.
ownerDocument
.
defaultView
)
;
info
(
Click
at
(
{
clientX
}
0
)
on
timeline
header
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
mouseup
"
clientX
:
clientX
}
header
header
.
ownerDocument
.
defaultView
)
;
return
onTimelineDataChanged
;
}
function
disableHighlighter
(
toolbox
)
{
toolbox
.
_highlighter
=
{
showBoxModel
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
hideBoxModel
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
pick
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
cancelPick
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
destroy
:
(
)
=
>
{
}
traits
:
{
}
}
;
}
async
function
clickOnAnimation
(
panel
index
shouldAlreadySelected
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
let
onSelectionChanged
=
timeline
.
once
(
shouldAlreadySelected
?
"
animation
-
already
-
selected
"
:
"
animation
-
selected
"
)
;
info
(
"
Click
on
animation
"
+
index
+
"
in
the
timeline
"
)
;
let
timeBlock
=
timeline
.
rootWrapperEl
.
querySelectorAll
(
"
.
time
-
block
"
)
[
index
]
;
timeBlock
.
scrollIntoView
(
false
)
;
let
timeBlockBounds
=
timeBlock
.
getBoundingClientRect
(
)
;
let
x
=
timeBlockBounds
.
width
/
2
;
let
y
=
timeBlockBounds
.
height
/
2
;
if
(
timeBlock
!
=
timeBlock
.
ownerDocument
.
elementFromPoint
(
x
y
)
)
{
x
+
=
timeBlockBounds
.
width
/
4
;
}
EventUtils
.
synthesizeMouse
(
timeBlock
x
y
{
}
timeBlock
.
ownerDocument
.
defaultView
)
;
return
onSelectionChanged
;
}
function
getKeyframeComponent
(
panel
propertyName
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
let
detailsComponent
=
timeline
.
details
;
return
detailsComponent
.
keyframeComponents
.
find
(
c
=
>
c
.
propertyName
=
=
=
propertyName
)
;
}
function
getKeyframeEl
(
panel
propertyName
keyframeIndex
)
{
let
keyframeComponent
=
getKeyframeComponent
(
panel
propertyName
)
;
return
keyframeComponent
.
keyframesEl
.
querySelectorAll
(
"
.
frame
"
)
[
keyframeIndex
]
;
}
async
function
setStyle
(
animation
panel
name
value
selector
)
{
info
(
"
Change
the
animation
style
via
the
content
DOM
.
Setting
"
+
name
+
"
to
"
+
value
+
"
of
"
+
selector
)
;
const
onAnimationChanged
=
animation
?
once
(
animation
"
changed
"
)
:
Promise
.
resolve
(
)
;
const
onRendered
=
waitForAnimationTimelineRendering
(
panel
)
;
await
executeInContent
(
"
devtools
:
test
:
setStyle
"
{
selector
:
selector
propertyName
:
name
propertyValue
:
value
}
)
;
await
onAnimationChanged
;
await
onRendered
;
await
waitForAllAnimationTargets
(
panel
)
;
}
function
assertPathSegments
(
pathEl
duration
hasClosePath
expectedValues
)
{
const
pathSegList
=
pathEl
.
pathSegList
;
ok
(
pathSegList
"
The
tested
element
should
have
pathSegList
"
)
;
expectedValues
.
forEach
(
expectedValue
=
>
{
ok
(
isPassingThrough
(
pathSegList
expectedValue
.
x
expectedValue
.
y
)
The
path
segment
of
x
{
expectedValue
.
x
}
y
{
expectedValue
.
y
}
+
should
be
passing
through
)
;
if
(
expectedValue
.
color
)
{
assertColor
(
pathEl
.
closest
(
"
svg
"
)
expectedValue
.
x
/
duration
expectedValue
.
color
)
;
}
}
)
;
if
(
hasClosePath
)
{
const
closePathSeg
=
pathSegList
.
getItem
(
pathSegList
.
numberOfItems
-
1
)
;
is
(
closePathSeg
.
pathSegType
closePathSeg
.
PATHSEG_CLOSEPATH
"
The
last
segment
should
be
close
path
"
)
;
}
}
function
assertColor
(
svgEl
offset
expectedColor
)
{
const
stopEl
=
findStopElement
(
svgEl
offset
)
;
ok
(
stopEl
stop
element
at
offset
{
offset
}
should
exist
)
;
is
(
stopEl
.
getAttribute
(
"
stop
-
color
"
)
expectedColor
stop
-
color
of
stop
element
at
offset
{
offset
}
should
be
{
expectedColor
}
)
;
}
function
isPassingThrough
(
pathSegList
x
y
)
{
let
previousPathSeg
=
pathSegList
.
getItem
(
0
)
;
for
(
let
i
=
0
;
i
<
pathSegList
.
numberOfItems
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
pathSeg
.
x
=
=
=
undefined
)
{
continue
;
}
const
currentX
=
parseFloat
(
pathSeg
.
x
.
toFixed
(
3
)
)
;
const
currentY
=
parseFloat
(
pathSeg
.
y
.
toFixed
(
6
)
)
;
if
(
currentX
=
=
=
x
&
&
currentY
=
=
=
y
)
{
return
true
;
}
const
previousX
=
parseFloat
(
previousPathSeg
.
x
.
toFixed
(
3
)
)
;
const
previousY
=
parseFloat
(
previousPathSeg
.
y
.
toFixed
(
6
)
)
;
if
(
previousX
<
=
x
&
&
x
<
=
currentX
&
&
Math
.
min
(
previousY
currentY
)
<
=
y
&
&
y
<
=
Math
.
max
(
previousY
currentY
)
)
{
return
true
;
}
previousPathSeg
=
pathSeg
;
}
return
false
;
}
function
findStopElement
(
svgEl
offset
)
{
for
(
const
stopEl
of
svgEl
.
querySelectorAll
(
"
stop
"
)
)
{
if
(
offset
<
=
parseFloat
(
stopEl
.
getAttribute
(
"
offset
"
)
)
)
{
return
stopEl
;
}
}
return
null
;
}
function
getAnimationTargetNodes
(
panel
)
{
return
panel
.
animationsTimelineComponent
.
animations
.
map
(
animation
=
>
{
return
panel
.
animationsTimelineComponent
.
componentsMap
[
animation
.
actorID
]
.
targetNode
;
}
)
;
}
function
getAnimationTimeBlocks
(
panel
)
{
return
panel
.
animationsTimelineComponent
.
animations
.
map
(
animation
=
>
{
return
panel
.
animationsTimelineComponent
.
componentsMap
[
animation
.
actorID
]
.
timeBlock
;
}
)
;
}
