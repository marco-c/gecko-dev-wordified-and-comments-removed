"
use
strict
"
;
requestLongerTimeout
(
2
)
;
add_task
(
async
function
(
)
{
await
addTab
(
URL_ROOT
+
"
doc_simple_animation
.
html
"
)
;
const
{
panel
inspector
}
=
await
openAnimationInspector
(
)
;
const
btn
=
panel
.
playTimelineButtonEl
;
info
(
"
Select
a
finite
animation
and
wait
for
the
animation
to
complete
"
)
;
await
selectNodeAndWaitForAnimations
(
"
.
negative
-
delay
"
inspector
)
;
await
reloadTab
(
inspector
)
;
if
(
!
btn
.
classList
.
contains
(
"
paused
"
)
)
{
await
waitForButtonPaused
(
btn
)
;
}
ok
(
btn
.
classList
.
contains
(
"
paused
"
)
"
The
button
is
in
paused
state
once
finite
animations
are
done
"
)
;
await
assertScrubberMoving
(
panel
false
)
;
info
(
"
Click
again
on
the
button
to
play
the
animation
from
the
start
again
"
)
;
await
clickTimelinePlayPauseButton
(
panel
)
;
ok
(
!
btn
.
classList
.
contains
(
"
paused
"
)
"
Clicking
the
button
once
finite
animations
are
done
should
restart
them
"
)
;
await
assertScrubberMoving
(
panel
true
)
;
}
)
;
function
waitForButtonPaused
(
btn
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
btn
.
ownerDocument
.
defaultView
.
MutationObserver
(
mutations
=
>
{
for
(
const
mutation
of
mutations
)
{
if
(
mutation
.
type
=
=
=
"
attributes
"
&
&
mutation
.
attributeName
=
=
=
"
class
"
&
&
!
mutation
.
oldValue
.
includes
(
"
paused
"
)
&
&
btn
.
classList
.
contains
(
"
paused
"
)
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
}
)
;
observer
.
observe
(
btn
{
attributes
:
true
attributeOldValue
:
true
}
)
;
}
)
;
}
