"
use
strict
"
;
const
{
createSVGNode
getJsPropertyName
}
=
require
(
"
devtools
/
client
/
inspector
/
animation
-
old
/
utils
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
.
js
"
)
;
const
{
parseTimingFunction
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
CubicBezierWidget
"
)
;
const
DURATION_RESOLUTION
=
4
;
const
DEFAULT_MIN_PROGRESS_THRESHOLD
=
0
.
1
;
exports
.
DEFAULT_MIN_PROGRESS_THRESHOLD
=
DEFAULT_MIN_PROGRESS_THRESHOLD
;
const
BOUND_EXCLUDING_TIME
=
0
.
001
;
function
ProgressGraphHelper
(
win
propertyCSSName
animationType
keyframes
duration
)
{
this
.
win
=
win
;
const
doc
=
this
.
win
.
document
;
this
.
targetEl
=
doc
.
createElement
(
"
div
"
)
;
doc
.
documentElement
.
appendChild
(
this
.
targetEl
)
;
this
.
propertyCSSName
=
propertyCSSName
;
this
.
propertyJSName
=
getJsPropertyName
(
this
.
propertyCSSName
)
;
this
.
animationType
=
animationType
;
const
keyframesObject
=
keyframes
.
map
(
keyframe
=
>
{
const
keyframeObject
=
Object
.
assign
(
{
}
keyframe
)
;
keyframeObject
[
this
.
propertyJSName
]
=
keyframe
.
value
;
return
keyframeObject
;
}
)
;
const
effectTiming
=
{
duration
:
duration
fill
:
"
forwards
"
}
;
this
.
keyframes
=
keyframesObject
;
this
.
devtoolsKeyframes
=
keyframes
;
this
.
valueHelperFunction
=
this
.
getValueHelperFunction
(
)
;
this
.
animation
=
this
.
targetEl
.
animate
(
this
.
keyframes
effectTiming
)
;
this
.
animation
.
pause
(
)
;
}
ProgressGraphHelper
.
prototype
=
{
destroy
:
function
(
)
{
this
.
targetEl
.
remove
(
)
;
this
.
animation
.
cancel
(
)
;
this
.
targetEl
=
null
;
this
.
animation
=
null
;
this
.
valueHelperFunction
=
null
;
this
.
propertyCSSName
=
null
;
this
.
propertyJSName
=
null
;
this
.
animationType
=
null
;
this
.
keyframes
=
null
;
this
.
win
=
null
;
}
getDuration
:
function
(
)
{
return
this
.
animation
.
effect
.
getComputedTiming
(
)
.
duration
;
}
getKeyframes
:
function
(
)
{
return
this
.
keyframes
;
}
getGraphType
:
function
(
)
{
return
(
this
.
propertyJSName
=
=
=
"
opacity
"
|
|
this
.
propertyJSName
=
=
=
"
transform
"
)
?
this
.
propertyJSName
:
this
.
animationType
;
}
getSegment
:
function
(
time
)
{
this
.
animation
.
currentTime
=
time
;
const
style
=
this
.
win
.
getComputedStyle
(
this
.
targetEl
)
[
this
.
propertyJSName
]
;
const
value
=
this
.
valueHelperFunction
(
style
)
;
return
{
x
:
time
y
:
value
style
:
style
}
;
}
getValueHelperFunction
:
function
(
)
{
switch
(
this
.
animationType
)
{
case
"
none
"
:
{
return
(
)
=
>
1
;
}
case
"
float
"
:
{
return
this
.
getFloatValueHelperFunction
(
)
;
}
case
"
coord
"
:
{
return
this
.
getCoordinateValueHelperFunction
(
)
;
}
case
"
color
"
:
{
return
this
.
getColorValueHelperFunction
(
)
;
}
case
"
discrete
"
:
{
return
this
.
getDiscreteValueHelperFunction
(
)
;
}
}
return
null
;
}
getFloatValueHelperFunction
:
function
(
)
{
let
maxValue
=
0
;
let
minValue
=
Infinity
;
this
.
keyframes
.
forEach
(
keyframe
=
>
{
maxValue
=
Math
.
max
(
maxValue
keyframe
.
value
)
;
minValue
=
Math
.
min
(
minValue
keyframe
.
value
)
;
}
)
;
const
distance
=
maxValue
-
minValue
;
return
value
=
>
{
return
(
value
-
minValue
)
/
distance
;
}
;
}
getCoordinateValueHelperFunction
:
function
(
)
{
let
maxValue
=
0
;
let
minValue
=
Infinity
;
for
(
let
i
=
0
n
=
this
.
keyframes
.
length
;
i
<
n
;
i
+
+
)
{
if
(
this
.
keyframes
[
i
]
.
value
.
match
(
/
calc
/
)
)
{
return
null
;
}
const
value
=
parseFloat
(
this
.
keyframes
[
i
]
.
value
)
;
minValue
=
Math
.
min
(
minValue
value
)
;
maxValue
=
Math
.
max
(
maxValue
value
)
;
}
const
distance
=
maxValue
-
minValue
;
return
value
=
>
{
return
(
parseFloat
(
value
)
-
minValue
)
/
distance
;
}
;
}
getColorValueHelperFunction
:
function
(
)
{
const
maxObject
=
{
distance
:
0
}
;
for
(
let
i
=
0
;
i
<
this
.
keyframes
.
length
-
1
;
i
+
+
)
{
const
value1
=
getRGBA
(
this
.
keyframes
[
i
]
.
value
)
;
for
(
let
j
=
i
+
1
;
j
<
this
.
keyframes
.
length
;
j
+
+
)
{
const
value2
=
getRGBA
(
this
.
keyframes
[
j
]
.
value
)
;
const
distance
=
getRGBADistance
(
value1
value2
)
;
if
(
maxObject
.
distance
>
=
distance
)
{
continue
;
}
maxObject
.
distance
=
distance
;
maxObject
.
value1
=
value1
;
maxObject
.
value2
=
value2
;
}
}
const
baseValue
=
maxObject
.
value1
<
maxObject
.
value2
?
maxObject
.
value1
:
maxObject
.
value2
;
return
value
=
>
{
const
colorValue
=
getRGBA
(
value
)
;
return
getRGBADistance
(
baseValue
colorValue
)
/
maxObject
.
distance
;
}
;
}
getDiscreteValueHelperFunction
:
function
(
)
{
const
discreteValues
=
[
]
;
this
.
keyframes
.
forEach
(
keyframe
=
>
{
this
.
targetEl
.
style
[
this
.
propertyJSName
]
=
keyframe
.
value
;
const
style
=
this
.
win
.
getComputedStyle
(
this
.
targetEl
)
[
this
.
propertyJSName
]
;
if
(
!
discreteValues
.
includes
(
style
)
)
{
discreteValues
.
push
(
style
)
;
}
}
)
;
this
.
targetEl
.
style
[
this
.
propertyJSName
]
=
"
unset
"
;
return
value
=
>
{
return
discreteValues
.
indexOf
(
value
)
/
(
discreteValues
.
length
-
1
)
;
}
;
}
createPathSegments
:
function
(
duration
minSegmentDuration
minProgressThreshold
)
{
if
(
!
this
.
valueHelperFunction
)
{
return
createKeyframesPathSegments
(
duration
this
.
devtoolsKeyframes
)
;
}
const
segments
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
devtoolsKeyframes
.
length
-
1
;
i
+
+
)
{
const
startKeyframe
=
this
.
devtoolsKeyframes
[
i
]
;
const
endKeyframe
=
this
.
devtoolsKeyframes
[
i
+
1
]
;
const
startTime
=
startKeyframe
.
offset
*
duration
;
const
endTime
=
endKeyframe
.
offset
*
duration
;
if
(
startKeyframe
.
offset
=
=
=
endKeyframe
.
offset
)
{
const
startSegment
=
this
.
getSegment
(
startTime
-
BOUND_EXCLUDING_TIME
)
;
startSegment
.
x
=
startTime
;
const
endSegment
=
this
.
getSegment
(
endTime
)
;
segments
.
push
(
startSegment
endSegment
)
;
}
else
{
let
threshold
=
getPreferredProgressThreshold
(
startKeyframe
.
easing
)
;
if
(
threshold
!
=
=
DEFAULT_MIN_PROGRESS_THRESHOLD
)
{
threshold
*
=
(
endKeyframe
.
offset
-
startKeyframe
.
offset
)
;
}
segments
.
push
(
.
.
.
createPathSegments
(
startTime
endTime
-
BOUND_EXCLUDING_TIME
minSegmentDuration
threshold
this
)
)
;
}
}
const
lastKeyframe
=
this
.
devtoolsKeyframes
[
this
.
devtoolsKeyframes
.
length
-
1
]
;
const
lastTime
=
lastKeyframe
.
offset
*
duration
;
segments
.
push
(
this
.
getSegment
(
lastTime
)
)
;
return
segments
;
}
appendShapePath
:
function
(
parentEl
pathSegments
cls
)
{
return
appendShapePath
(
parentEl
pathSegments
cls
)
;
}
appendLinePath
:
function
(
parentEl
pathSegments
cls
)
{
const
isClosePathNeeded
=
false
;
return
appendPathElement
(
parentEl
pathSegments
cls
isClosePathNeeded
)
;
}
}
;
exports
.
ProgressGraphHelper
=
ProgressGraphHelper
;
function
SummaryGraphHelper
(
win
state
minSegmentDuration
)
{
this
.
win
=
win
;
const
doc
=
this
.
win
.
document
;
this
.
targetEl
=
doc
.
createElement
(
"
div
"
)
;
doc
.
documentElement
.
appendChild
(
this
.
targetEl
)
;
const
effectTiming
=
Object
.
assign
(
{
}
state
{
iterations
:
state
.
iterationCount
?
state
.
iterationCount
:
Infinity
}
)
;
this
.
animation
=
this
.
targetEl
.
animate
(
null
effectTiming
)
;
this
.
animation
.
pause
(
)
;
this
.
endTime
=
this
.
animation
.
effect
.
getComputedTiming
(
)
.
endTime
;
this
.
minSegmentDuration
=
minSegmentDuration
;
this
.
minProgressThreshold
=
DEFAULT_MIN_PROGRESS_THRESHOLD
;
}
SummaryGraphHelper
.
prototype
=
{
destroy
:
function
(
)
{
this
.
animation
.
cancel
(
)
;
this
.
targetEl
.
remove
(
)
;
this
.
targetEl
=
null
;
this
.
animation
=
null
;
this
.
win
=
null
;
}
setKeyframes
:
function
(
keyframes
)
{
let
frames
=
null
;
let
durationResolution
=
DURATION_RESOLUTION
;
if
(
keyframes
)
{
let
previousOffset
=
0
;
frames
=
keyframes
.
map
(
keyframe
=
>
{
if
(
previousOffset
&
&
previousOffset
!
=
keyframe
.
offset
)
{
const
interval
=
keyframe
.
offset
-
previousOffset
;
durationResolution
=
Math
.
max
(
durationResolution
Math
.
ceil
(
1
/
interval
)
)
;
}
previousOffset
=
keyframe
.
offset
;
return
{
opacity
:
keyframe
.
offset
offset
:
keyframe
.
offset
easing
:
keyframe
.
easing
}
;
}
)
;
this
.
targetEl
.
style
.
opacity
=
0
;
}
this
.
durationResolution
=
durationResolution
;
this
.
animation
.
effect
.
setKeyframes
(
frames
)
;
this
.
hasFrames
=
!
!
frames
;
}
setOriginalBehavior
:
function
(
isOriginalBehavior
)
{
this
.
isOriginalBehavior
=
isOriginalBehavior
;
}
setFillMode
:
function
(
fill
)
{
this
.
animation
.
effect
.
updateTiming
(
{
fill
}
)
;
}
setClosePathNeeded
:
function
(
isClosePathNeeded
)
{
this
.
isClosePathNeeded
=
isClosePathNeeded
;
}
setMinProgressThreshold
:
function
(
minProgressThreshold
)
{
this
.
minProgressThreshold
=
minProgressThreshold
;
}
getSegment
:
function
(
time
)
{
if
(
this
.
isOriginalBehavior
)
{
if
(
time
<
0
)
{
return
{
x
:
time
y
:
0
}
;
}
this
.
animation
.
currentTime
=
time
<
this
.
endTime
?
time
:
this
.
endTime
;
}
else
{
this
.
animation
.
currentTime
=
time
;
}
const
value
=
this
.
hasFrames
?
this
.
getOpacityValue
(
)
:
this
.
getProgressValue
(
)
;
return
{
x
:
time
y
:
value
}
;
}
createPathSegments
:
function
(
startTime
endTime
)
{
return
createPathSegments
(
startTime
endTime
this
.
minSegmentDuration
this
.
minProgressThreshold
this
this
.
durationResolution
)
;
}
appendShapePath
:
function
(
parentEl
pathSegments
cls
)
{
return
appendShapePath
(
parentEl
pathSegments
cls
this
.
isClosePathNeeded
)
;
}
getProgressValue
:
function
(
)
{
return
Math
.
max
(
this
.
animation
.
effect
.
getComputedTiming
(
)
.
progress
0
)
;
}
getOpacityValue
:
function
(
)
{
return
this
.
win
.
getComputedStyle
(
this
.
targetEl
)
.
opacity
;
}
}
;
exports
.
SummaryGraphHelper
=
SummaryGraphHelper
;
function
createPathSegments
(
startTime
endTime
minSegmentDuration
minProgressThreshold
segmentHelper
resolution
=
DURATION_RESOLUTION
)
{
if
(
endTime
-
startTime
<
minSegmentDuration
)
{
return
[
segmentHelper
.
getSegment
(
startTime
)
segmentHelper
.
getSegment
(
endTime
)
]
;
}
let
pathSegments
=
[
]
;
const
startTimeSegment
=
segmentHelper
.
getSegment
(
startTime
)
;
pathSegments
.
push
(
startTimeSegment
)
;
let
previousSegment
=
startTimeSegment
;
const
interval
=
(
endTime
-
startTime
)
/
resolution
;
for
(
let
index
=
1
;
index
<
=
resolution
;
index
+
+
)
{
const
currentSegment
=
segmentHelper
.
getSegment
(
startTime
+
index
*
interval
)
;
if
(
Math
.
abs
(
currentSegment
.
y
-
previousSegment
.
y
)
>
minProgressThreshold
)
{
pathSegments
=
pathSegments
.
concat
(
createPathSegments
(
previousSegment
.
x
+
BOUND_EXCLUDING_TIME
currentSegment
.
x
-
BOUND_EXCLUDING_TIME
minSegmentDuration
minProgressThreshold
segmentHelper
)
)
;
}
pathSegments
.
push
(
currentSegment
)
;
previousSegment
=
currentSegment
;
}
return
pathSegments
;
}
function
appendShapePath
(
parentEl
pathSegments
cls
isClosePathNeeded
=
true
)
{
const
segments
=
[
{
x
:
pathSegments
[
0
]
.
x
y
:
0
}
.
.
.
pathSegments
{
x
:
pathSegments
[
pathSegments
.
length
-
1
]
.
x
y
:
0
}
]
;
return
appendPathElement
(
parentEl
segments
cls
isClosePathNeeded
)
;
}
function
appendPathElement
(
parentEl
pathSegments
cls
isClosePathNeeded
)
{
let
currentSegment
=
pathSegments
[
0
]
;
let
path
=
M
{
currentSegment
.
x
}
{
currentSegment
.
y
}
;
for
(
let
i
=
1
;
i
<
pathSegments
.
length
;
i
+
+
)
{
const
currentEasing
=
currentSegment
.
easing
?
currentSegment
.
easing
:
"
linear
"
;
const
nextSegment
=
pathSegments
[
i
]
;
if
(
currentEasing
=
=
=
"
linear
"
)
{
path
+
=
createLinePathString
(
nextSegment
)
;
}
else
if
(
currentEasing
.
startsWith
(
"
steps
"
)
)
{
path
+
=
createStepsPathString
(
currentSegment
nextSegment
)
;
}
else
if
(
currentEasing
.
startsWith
(
"
frames
"
)
)
{
path
+
=
createFramesPathString
(
currentSegment
nextSegment
)
;
}
else
{
path
+
=
createCubicBezierPathString
(
currentSegment
nextSegment
)
;
}
currentSegment
=
nextSegment
;
}
if
(
isClosePathNeeded
)
{
path
+
=
"
Z
"
;
}
return
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
path
"
attributes
:
{
"
d
"
:
path
"
class
"
:
cls
"
vector
-
effect
"
:
"
non
-
scaling
-
stroke
"
"
transform
"
:
"
scale
(
1
-
1
)
"
}
}
)
;
}
function
createKeyframesPathSegments
(
duration
keyframes
)
{
return
keyframes
.
map
(
keyframe
=
>
{
return
{
x
:
keyframe
.
offset
*
duration
y
:
keyframe
.
distance
easing
:
keyframe
.
easing
style
:
keyframe
.
value
}
;
}
)
;
}
function
createLinePathString
(
segment
)
{
return
L
{
segment
.
x
}
{
segment
.
y
}
;
}
function
createStepsPathString
(
currentSegment
nextSegment
)
{
const
matches
=
currentSegment
.
easing
.
match
(
/
^
steps
\
(
(
\
d
+
)
(
\
sstart
)
?
\
)
/
)
;
const
stepNumber
=
parseInt
(
matches
[
1
]
10
)
;
const
oneStepX
=
(
nextSegment
.
x
-
currentSegment
.
x
)
/
stepNumber
;
const
oneStepY
=
(
nextSegment
.
y
-
currentSegment
.
y
)
/
stepNumber
;
const
isStepStart
=
matches
[
2
]
;
const
stepOffsetY
=
isStepStart
?
1
:
0
;
let
path
=
"
"
;
for
(
let
step
=
0
;
step
<
stepNumber
;
step
+
+
)
{
const
sx
=
currentSegment
.
x
+
step
*
oneStepX
;
const
ex
=
sx
+
oneStepX
;
const
y
=
currentSegment
.
y
+
(
step
+
stepOffsetY
)
*
oneStepY
;
path
+
=
L
{
sx
}
{
y
}
L
{
ex
}
{
y
}
;
}
if
(
!
isStepStart
)
{
path
+
=
L
{
nextSegment
.
x
}
{
nextSegment
.
y
}
;
}
return
path
;
}
function
createFramesPathString
(
currentSegment
nextSegment
)
{
const
matches
=
currentSegment
.
easing
.
match
(
/
^
frames
\
(
(
\
d
+
)
\
)
/
)
;
const
framesNumber
=
parseInt
(
matches
[
1
]
10
)
;
const
oneFrameX
=
(
nextSegment
.
x
-
currentSegment
.
x
)
/
framesNumber
;
const
oneFrameY
=
(
nextSegment
.
y
-
currentSegment
.
y
)
/
(
framesNumber
-
1
)
;
let
path
=
"
"
;
for
(
let
frame
=
0
;
frame
<
framesNumber
;
frame
+
+
)
{
const
sx
=
currentSegment
.
x
+
frame
*
oneFrameX
;
const
ex
=
sx
+
oneFrameX
;
const
y
=
currentSegment
.
y
+
frame
*
oneFrameY
;
path
+
=
L
{
sx
}
{
y
}
L
{
ex
}
{
y
}
;
}
return
path
;
}
function
createCubicBezierPathString
(
currentSegment
nextSegment
)
{
const
controlPoints
=
parseTimingFunction
(
currentSegment
.
easing
)
;
if
(
!
controlPoints
)
{
return
createLinePathString
(
currentSegment
)
;
}
const
cp1x
=
controlPoints
[
0
]
;
const
cp1y
=
controlPoints
[
1
]
;
const
cp2x
=
controlPoints
[
2
]
;
const
cp2y
=
controlPoints
[
3
]
;
const
diffX
=
nextSegment
.
x
-
currentSegment
.
x
;
const
diffY
=
nextSegment
.
y
-
currentSegment
.
y
;
let
path
=
C
{
currentSegment
.
x
+
diffX
*
cp1x
}
{
currentSegment
.
y
+
diffY
*
cp1y
}
;
path
+
=
{
currentSegment
.
x
+
diffX
*
cp2x
}
{
currentSegment
.
y
+
diffY
*
cp2y
}
;
path
+
=
{
nextSegment
.
x
}
{
nextSegment
.
y
}
;
return
path
;
}
function
getRGBA
(
colorString
)
{
const
color
=
new
colorUtils
.
CssColor
(
colorString
)
;
return
color
.
getRGBATuple
(
)
;
}
function
getRGBADistance
(
rgba1
rgba2
)
{
const
startA
=
rgba1
.
a
;
const
startR
=
rgba1
.
r
*
startA
;
const
startG
=
rgba1
.
g
*
startA
;
const
startB
=
rgba1
.
b
*
startA
;
const
endA
=
rgba2
.
a
;
const
endR
=
rgba2
.
r
*
endA
;
const
endG
=
rgba2
.
g
*
endA
;
const
endB
=
rgba2
.
b
*
endA
;
const
diffA
=
startA
-
endA
;
const
diffR
=
startR
-
endR
;
const
diffG
=
startG
-
endG
;
const
diffB
=
startB
-
endB
;
return
Math
.
sqrt
(
diffA
*
diffA
+
diffR
*
diffR
+
diffG
*
diffG
+
diffB
*
diffB
)
;
}
function
getPreferredKeyframesProgressThreshold
(
keyframes
)
{
let
minProgressTreshold
=
DEFAULT_MIN_PROGRESS_THRESHOLD
;
for
(
let
i
=
0
;
i
<
keyframes
.
length
-
1
;
i
+
+
)
{
const
keyframe
=
keyframes
[
i
]
;
if
(
!
keyframe
.
easing
)
{
continue
;
}
let
keyframeProgressThreshold
=
getPreferredProgressThreshold
(
keyframe
.
easing
)
;
if
(
keyframeProgressThreshold
!
=
=
DEFAULT_MIN_PROGRESS_THRESHOLD
)
{
keyframeProgressThreshold
*
=
(
keyframes
[
i
+
1
]
.
offset
-
keyframe
.
offset
)
;
}
minProgressTreshold
=
Math
.
min
(
keyframeProgressThreshold
minProgressTreshold
)
;
}
return
minProgressTreshold
;
}
exports
.
getPreferredKeyframesProgressThreshold
=
getPreferredKeyframesProgressThreshold
;
function
getPreferredProgressThreshold
(
easing
)
{
const
stepOrFramesFunction
=
easing
.
match
(
/
(
steps
|
frames
)
\
(
(
\
d
+
)
/
)
;
return
stepOrFramesFunction
?
1
/
(
parseInt
(
stepOrFramesFunction
[
2
]
10
)
+
1
)
:
DEFAULT_MIN_PROGRESS_THRESHOLD
;
}
exports
.
getPreferredProgressThreshold
=
getPreferredProgressThreshold
;
