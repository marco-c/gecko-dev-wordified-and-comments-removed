"
use
strict
"
;
const
ToolDefinitions
=
require
(
"
devtools
/
client
/
definitions
"
)
.
Tools
;
const
CssLogic
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
OutputParser
=
require
(
"
devtools
/
client
/
shared
/
output
-
parser
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
createChild
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
getCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
{
VIEW_NODE_SELECTOR_TYPE
VIEW_NODE_PROPERTY_TYPE
VIEW_NODE_VALUE_TYPE
VIEW_NODE_IMAGE_URL_TYPE
VIEW_NODE_FONT_TYPE
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
node
-
types
"
)
;
const
StyleInspectorMenu
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
style
-
inspector
-
menu
"
)
;
const
TooltipsOverlay
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
tooltips
-
overlay
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
clipboardHelper
=
require
(
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
{
createElement
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
BoxModelApp
=
createFactory
(
require
(
"
devtools
/
client
/
inspector
/
boxmodel
/
components
/
BoxModelApp
"
)
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
const
FILTER_CHANGED_TIMEOUT
=
150
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
UpdateProcess
(
win
array
options
)
{
this
.
win
=
win
;
this
.
index
=
0
;
this
.
array
=
array
;
this
.
onItem
=
options
.
onItem
|
|
function
(
)
{
}
;
this
.
onBatch
=
options
.
onBatch
|
|
function
(
)
{
}
;
this
.
onDone
=
options
.
onDone
|
|
function
(
)
{
}
;
this
.
onCancel
=
options
.
onCancel
|
|
function
(
)
{
}
;
this
.
threshold
=
options
.
threshold
|
|
45
;
this
.
canceled
=
false
;
}
UpdateProcess
.
prototype
=
{
ERROR_ITERATION_DONE
:
new
Error
(
"
UpdateProcess
iteration
done
"
)
schedule
:
function
(
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
_timeout
=
setTimeout
(
this
.
_timeoutHandler
.
bind
(
this
)
0
)
;
}
cancel
:
function
(
)
{
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
0
;
}
this
.
canceled
=
true
;
this
.
onCancel
(
)
;
}
_timeoutHandler
:
function
(
)
{
this
.
_timeout
=
null
;
try
{
this
.
_runBatch
(
)
;
this
.
schedule
(
)
;
}
catch
(
e
)
{
if
(
e
=
=
=
this
.
ERROR_ITERATION_DONE
)
{
this
.
onBatch
(
)
;
this
.
onDone
(
)
;
return
;
}
console
.
error
(
e
)
;
throw
e
;
}
}
_runBatch
:
function
(
)
{
let
time
=
Date
.
now
(
)
;
while
(
!
this
.
canceled
)
{
let
next
=
this
.
_next
(
)
;
this
.
onItem
(
next
)
;
if
(
(
Date
.
now
(
)
-
time
)
>
this
.
threshold
)
{
this
.
onBatch
(
)
;
return
;
}
}
}
_next
:
function
(
)
{
if
(
this
.
index
<
this
.
array
.
length
)
{
return
this
.
array
[
this
.
index
+
+
]
;
}
throw
this
.
ERROR_ITERATION_DONE
;
}
}
;
function
CssComputedView
(
inspector
document
pageStyle
)
{
this
.
inspector
=
inspector
;
this
.
highlighters
=
inspector
.
highlighters
;
this
.
store
=
inspector
.
store
;
this
.
styleDocument
=
document
;
this
.
styleWindow
=
this
.
styleDocument
.
defaultView
;
this
.
pageStyle
=
pageStyle
;
this
.
propertyViews
=
[
]
;
let
cssProperties
=
getCssProperties
(
inspector
.
toolbox
)
;
this
.
_outputParser
=
new
OutputParser
(
document
cssProperties
)
;
this
.
focusWindow
=
this
.
focusWindow
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onClick
=
this
.
_onClick
.
bind
(
this
)
;
this
.
_onCopy
=
this
.
_onCopy
.
bind
(
this
)
;
this
.
_onFilterStyles
=
this
.
_onFilterStyles
.
bind
(
this
)
;
this
.
_onClearSearch
=
this
.
_onClearSearch
.
bind
(
this
)
;
this
.
_onIncludeBrowserStyles
=
this
.
_onIncludeBrowserStyles
.
bind
(
this
)
;
let
doc
=
this
.
styleDocument
;
this
.
element
=
doc
.
getElementById
(
"
computed
-
property
-
container
"
)
;
this
.
boxModelWrapper
=
doc
.
getElementById
(
"
boxmodel
-
wrapper
"
)
;
this
.
searchField
=
doc
.
getElementById
(
"
computed
-
searchbox
"
)
;
this
.
searchClearButton
=
doc
.
getElementById
(
"
computed
-
searchinput
-
clear
"
)
;
this
.
includeBrowserStylesCheckbox
=
doc
.
getElementById
(
"
browser
-
style
-
checkbox
"
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
styleWindow
}
)
;
this
.
_onShortcut
=
this
.
_onShortcut
.
bind
(
this
)
;
this
.
shortcuts
.
on
(
"
CmdOrCtrl
+
F
"
this
.
_onShortcut
)
;
this
.
shortcuts
.
on
(
"
Escape
"
this
.
_onShortcut
)
;
this
.
styleDocument
.
addEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
styleDocument
.
addEventListener
(
"
mousedown
"
this
.
focusWindow
)
;
this
.
element
.
addEventListener
(
"
click
"
this
.
_onClick
)
;
this
.
element
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
searchField
.
addEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
addEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
includeBrowserStylesCheckbox
.
addEventListener
(
"
input
"
this
.
_onIncludeBrowserStyles
)
;
this
.
searchClearButton
.
hidden
=
true
;
this
.
noResults
=
this
.
styleDocument
.
getElementById
(
"
computed
-
no
-
results
"
)
;
this
.
_handlePrefChange
=
this
.
_handlePrefChange
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
"
devtools
.
defaultColorUnit
"
this
.
_handlePrefChange
)
;
this
.
_viewedElement
=
null
;
this
.
createBoxModelView
(
)
;
this
.
createStyleViews
(
)
;
this
.
_contextmenu
=
new
StyleInspectorMenu
(
this
{
isRuleView
:
false
}
)
;
this
.
tooltips
=
new
TooltipsOverlay
(
this
)
;
this
.
highlighters
.
addToView
(
this
)
;
}
CssComputedView
.
l10n
=
function
(
name
)
{
try
{
return
STYLE_INSPECTOR_L10N
.
getStr
(
name
)
;
}
catch
(
ex
)
{
console
.
log
(
"
Error
reading
'
"
+
name
+
"
'
"
)
;
throw
new
Error
(
"
l10n
error
with
"
+
name
)
;
}
}
;
CssComputedView
.
prototype
=
{
_matchedProperties
:
null
_filterChangedTimeout
:
null
_panelRefreshTimeout
:
null
_darkStripe
:
true
numVisibleProperties
:
0
setPageStyle
:
function
(
pageStyle
)
{
this
.
pageStyle
=
pageStyle
;
}
get
includeBrowserStyles
(
)
{
return
this
.
includeBrowserStylesCheckbox
.
checked
;
}
_handlePrefChange
:
function
(
event
data
)
{
if
(
this
.
_computed
)
{
this
.
refreshPanel
(
)
;
}
}
selectElement
:
function
(
element
)
{
if
(
!
element
)
{
this
.
_viewedElement
=
null
;
this
.
noResults
.
hidden
=
false
;
if
(
this
.
_refreshProcess
)
{
this
.
_refreshProcess
.
cancel
(
)
;
}
for
(
let
propView
of
this
.
propertyViews
)
{
propView
.
refresh
(
)
;
}
return
promise
.
resolve
(
undefined
)
;
}
if
(
element
=
=
=
this
.
_viewedElement
)
{
return
promise
.
resolve
(
undefined
)
;
}
this
.
_viewedElement
=
element
;
this
.
refreshSourceFilter
(
)
;
return
this
.
refreshPanel
(
)
;
}
getNodeInfo
:
function
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
classes
=
node
.
classList
;
if
(
classes
.
contains
(
"
matched
"
)
|
|
classes
.
contains
(
"
bestmatch
"
)
|
|
classes
.
contains
(
"
parentmatch
"
)
)
{
let
selectorText
=
"
"
;
for
(
let
child
of
node
.
childNodes
[
0
]
.
childNodes
)
{
if
(
child
.
nodeType
=
=
=
node
.
TEXT_NODE
)
{
selectorText
+
=
child
.
textContent
;
}
}
return
{
type
:
VIEW_NODE_SELECTOR_TYPE
value
:
selectorText
.
trim
(
)
}
;
}
let
propertyView
;
let
propertyContent
;
let
parent
=
node
;
while
(
parent
.
parentNode
)
{
if
(
parent
.
classList
.
contains
(
"
computed
-
property
-
view
"
)
)
{
propertyView
=
parent
;
break
;
}
if
(
parent
.
classList
.
contains
(
"
computed
-
property
-
content
"
)
)
{
propertyContent
=
parent
;
break
;
}
parent
=
parent
.
parentNode
;
}
if
(
!
propertyView
&
&
!
propertyContent
)
{
return
null
;
}
let
value
type
;
let
isHref
=
classes
.
contains
(
"
theme
-
link
"
)
&
&
!
classes
.
contains
(
"
computed
-
link
"
)
;
if
(
propertyView
&
&
(
classes
.
contains
(
"
computed
-
property
-
name
"
)
|
|
classes
.
contains
(
"
computed
-
property
-
value
"
)
|
|
isHref
)
)
{
value
=
{
property
:
parent
.
querySelector
(
"
.
computed
-
property
-
name
"
)
.
firstChild
.
textContent
value
:
parent
.
querySelector
(
"
.
computed
-
property
-
value
"
)
.
textContent
}
;
}
if
(
propertyContent
&
&
(
classes
.
contains
(
"
computed
-
other
-
property
-
value
"
)
|
|
isHref
)
)
{
let
view
=
propertyContent
.
previousSibling
;
value
=
{
property
:
view
.
querySelector
(
"
.
computed
-
property
-
name
"
)
.
firstChild
.
textContent
value
:
node
.
textContent
}
;
}
if
(
classes
.
contains
(
"
computed
-
font
-
family
"
)
)
{
if
(
propertyView
)
{
value
=
{
property
:
parent
.
querySelector
(
"
.
computed
-
property
-
name
"
)
.
firstChild
.
textContent
value
:
node
.
parentNode
.
textContent
}
;
}
else
if
(
propertyContent
)
{
let
view
=
propertyContent
.
previousSibling
;
value
=
{
property
:
view
.
querySelector
(
"
.
computed
-
property
-
name
"
)
.
firstChild
.
textContent
value
:
node
.
parentNode
.
textContent
}
;
}
else
{
return
null
;
}
}
if
(
classes
.
contains
(
"
computed
-
property
-
name
"
)
)
{
type
=
VIEW_NODE_PROPERTY_TYPE
;
}
else
if
(
classes
.
contains
(
"
computed
-
property
-
value
"
)
|
|
classes
.
contains
(
"
computed
-
other
-
property
-
value
"
)
)
{
type
=
VIEW_NODE_VALUE_TYPE
;
}
else
if
(
classes
.
contains
(
"
computed
-
font
-
family
"
)
)
{
type
=
VIEW_NODE_FONT_TYPE
;
}
else
if
(
isHref
)
{
type
=
VIEW_NODE_IMAGE_URL_TYPE
;
value
.
url
=
node
.
href
;
}
else
{
return
null
;
}
return
{
view
:
"
computed
"
type
value
}
;
}
_createPropertyViews
:
function
(
)
{
if
(
this
.
_createViewsPromise
)
{
return
this
.
_createViewsPromise
;
}
this
.
refreshSourceFilter
(
)
;
this
.
numVisibleProperties
=
0
;
let
fragment
=
this
.
styleDocument
.
createDocumentFragment
(
)
;
this
.
_createViewsPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_createViewsProcess
=
new
UpdateProcess
(
this
.
styleWindow
CssComputedView
.
propertyNames
{
onItem
:
(
propertyName
)
=
>
{
let
propView
=
new
PropertyView
(
this
propertyName
)
;
fragment
.
appendChild
(
propView
.
buildMain
(
)
)
;
fragment
.
appendChild
(
propView
.
buildSelectorContainer
(
)
)
;
if
(
propView
.
visible
)
{
this
.
numVisibleProperties
+
+
;
}
this
.
propertyViews
.
push
(
propView
)
;
}
onCancel
:
(
)
=
>
{
reject
(
"
_createPropertyViews
cancelled
"
)
;
}
onDone
:
(
)
=
>
{
this
.
element
.
appendChild
(
fragment
)
;
this
.
noResults
.
hidden
=
this
.
numVisibleProperties
>
0
;
resolve
(
undefined
)
;
}
}
)
;
}
)
;
this
.
_createViewsProcess
.
schedule
(
)
;
return
this
.
_createViewsPromise
;
}
refreshPanel
:
function
(
)
{
if
(
!
this
.
_viewedElement
)
{
return
promise
.
resolve
(
)
;
}
let
viewedElement
=
this
.
_viewedElement
;
return
promise
.
all
(
[
this
.
_createPropertyViews
(
)
this
.
pageStyle
.
getComputed
(
this
.
_viewedElement
{
filter
:
this
.
_sourceFilter
onlyMatched
:
!
this
.
includeBrowserStyles
markMatched
:
true
}
)
]
)
.
then
(
(
[
computed
]
)
=
>
{
if
(
viewedElement
!
=
=
this
.
_viewedElement
)
{
return
promise
.
resolve
(
)
;
}
this
.
_matchedProperties
=
new
Set
(
)
;
for
(
let
name
in
computed
)
{
if
(
computed
[
name
]
.
matched
)
{
this
.
_matchedProperties
.
add
(
name
)
;
}
}
this
.
_computed
=
computed
;
if
(
this
.
_refreshProcess
)
{
this
.
_refreshProcess
.
cancel
(
)
;
}
this
.
noResults
.
hidden
=
true
;
this
.
numVisibleProperties
=
0
;
this
.
_darkStripe
=
true
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_refreshProcess
=
new
UpdateProcess
(
this
.
styleWindow
this
.
propertyViews
{
onItem
:
(
propView
)
=
>
{
propView
.
refresh
(
)
;
}
onCancel
:
(
)
=
>
{
reject
(
"
_refreshProcess
of
computed
view
cancelled
"
)
;
}
onDone
:
(
)
=
>
{
this
.
_refreshProcess
=
null
;
this
.
noResults
.
hidden
=
this
.
numVisibleProperties
>
0
;
if
(
this
.
searchField
.
value
.
length
>
0
&
&
!
this
.
numVisibleProperties
)
{
this
.
searchField
.
classList
.
add
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
else
{
this
.
searchField
.
classList
.
remove
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
this
.
inspector
.
emit
(
"
computed
-
view
-
refreshed
"
)
;
resolve
(
undefined
)
;
}
}
)
;
this
.
_refreshProcess
.
schedule
(
)
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
_onShortcut
:
function
(
name
event
)
{
if
(
!
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
computedview
"
)
)
{
return
;
}
if
(
name
=
=
=
"
Escape
"
&
&
event
.
target
=
=
=
this
.
searchField
&
&
this
.
_onClearSearch
(
)
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
else
if
(
name
=
=
=
"
CmdOrCtrl
+
F
"
)
{
this
.
searchField
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
}
setFilterStyles
:
function
(
value
=
"
"
)
{
this
.
searchField
.
value
=
value
;
this
.
searchField
.
focus
(
)
;
this
.
_onFilterStyles
(
)
;
}
_onFilterStyles
:
function
(
)
{
if
(
this
.
_filterChangedTimeout
)
{
clearTimeout
(
this
.
_filterChangedTimeout
)
;
}
let
filterTimeout
=
(
this
.
searchField
.
value
.
length
>
0
)
?
FILTER_CHANGED_TIMEOUT
:
0
;
this
.
searchClearButton
.
hidden
=
this
.
searchField
.
value
.
length
=
=
=
0
;
this
.
_filterChangedTimeout
=
setTimeout
(
(
)
=
>
{
if
(
this
.
searchField
.
value
.
length
>
0
)
{
this
.
searchField
.
setAttribute
(
"
filled
"
true
)
;
this
.
boxModelWrapper
.
hidden
=
true
;
}
else
{
this
.
searchField
.
removeAttribute
(
"
filled
"
)
;
this
.
boxModelWrapper
.
hidden
=
false
;
}
this
.
refreshPanel
(
)
;
this
.
_filterChangeTimeout
=
null
;
}
filterTimeout
)
;
}
_onClearSearch
:
function
(
)
{
if
(
this
.
searchField
.
value
)
{
this
.
setFilterStyles
(
"
"
)
;
return
true
;
}
return
false
;
}
_onIncludeBrowserStyles
:
function
(
)
{
this
.
refreshSourceFilter
(
)
;
this
.
refreshPanel
(
)
;
}
refreshSourceFilter
:
function
(
)
{
this
.
_matchedProperties
=
null
;
this
.
_sourceFilter
=
this
.
includeBrowserStyles
?
CssLogic
.
FILTER
.
UA
:
CssLogic
.
FILTER
.
USER
;
}
createBoxModelView
:
function
(
)
{
let
{
setSelectedNode
onShowBoxModelHighlighterForNode
}
=
this
.
inspector
.
getCommonComponentProps
(
)
;
let
{
onHideBoxModelHighlighter
onShowBoxModelEditor
onShowBoxModelHighlighter
onToggleGeometryEditor
}
=
this
.
inspector
.
getPanel
(
"
boxmodel
"
)
.
getComponentProps
(
)
;
let
provider
=
createElement
(
Provider
{
store
:
this
.
store
}
BoxModelApp
(
{
setSelectedNode
showBoxModelProperties
:
false
onHideBoxModelHighlighter
onShowBoxModelEditor
onShowBoxModelHighlighter
onShowBoxModelHighlighterForNode
onToggleGeometryEditor
}
)
)
;
ReactDOM
.
render
(
provider
this
.
boxModelWrapper
)
;
}
createStyleViews
:
function
(
)
{
if
(
CssComputedView
.
propertyNames
)
{
return
;
}
CssComputedView
.
propertyNames
=
[
]
;
let
styles
=
this
.
styleWindow
.
getComputedStyle
(
this
.
styleDocument
.
documentElement
)
;
let
mozProps
=
[
]
;
for
(
let
i
=
0
numStyles
=
styles
.
length
;
i
<
numStyles
;
i
+
+
)
{
let
prop
=
styles
.
item
(
i
)
;
if
(
prop
.
startsWith
(
"
-
-
"
)
)
{
continue
;
}
else
if
(
prop
.
startsWith
(
"
-
"
)
)
{
mozProps
.
push
(
prop
)
;
}
else
{
CssComputedView
.
propertyNames
.
push
(
prop
)
;
}
}
CssComputedView
.
propertyNames
.
sort
(
)
;
CssComputedView
.
propertyNames
.
push
.
apply
(
CssComputedView
.
propertyNames
mozProps
.
sort
(
)
)
;
this
.
_createPropertyViews
(
)
.
catch
(
e
=
>
{
if
(
!
this
.
_isDestroyed
)
{
console
.
warn
(
"
The
creation
of
property
views
was
cancelled
because
"
+
"
the
computed
-
view
was
destroyed
before
it
was
done
creating
views
"
)
;
}
else
{
console
.
error
(
e
)
;
}
}
)
;
}
get
matchedProperties
(
)
{
return
this
.
_matchedProperties
|
|
new
Set
(
)
;
}
focusWindow
:
function
(
)
{
this
.
styleWindow
.
focus
(
)
;
}
_onContextMenu
:
function
(
event
)
{
this
.
_contextmenu
.
show
(
event
)
;
}
_onClick
:
function
(
event
)
{
let
target
=
event
.
target
;
if
(
target
.
nodeName
=
=
=
"
a
"
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
let
browserWin
=
this
.
inspector
.
target
.
tab
.
ownerDocument
.
defaultView
;
browserWin
.
openUILinkIn
(
target
.
href
"
tab
"
)
;
}
}
_onCopy
:
function
(
event
)
{
let
win
=
this
.
styleWindow
;
let
text
=
win
.
getSelection
(
)
.
toString
(
)
.
trim
(
)
;
if
(
text
!
=
=
"
"
)
{
this
.
copySelection
(
)
;
event
.
preventDefault
(
)
;
}
}
copySelection
:
function
(
)
{
try
{
let
win
=
this
.
styleWindow
;
let
text
=
win
.
getSelection
(
)
.
toString
(
)
.
trim
(
)
;
clipboardHelper
.
copyString
(
text
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
destroy
:
function
(
)
{
this
.
_viewedElement
=
null
;
this
.
_outputParser
=
null
;
this
.
_prefObserver
.
off
(
"
devtools
.
defaultColorUnit
"
this
.
_handlePrefChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
if
(
this
.
_createViewsProcess
)
{
this
.
_createViewsProcess
.
cancel
(
)
;
}
if
(
this
.
_refreshProcess
)
{
this
.
_refreshProcess
.
cancel
(
)
;
}
if
(
this
.
_contextmenu
)
{
this
.
_contextmenu
.
destroy
(
)
;
this
.
_contextmenu
=
null
;
}
this
.
tooltips
.
destroy
(
)
;
this
.
highlighters
.
removeFromView
(
this
)
;
this
.
styleDocument
.
removeEventListener
(
"
mousedown
"
this
.
focusWindow
)
;
this
.
element
.
removeEventListener
(
"
click
"
this
.
_onClick
)
;
this
.
styleDocument
.
removeEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
searchField
.
removeEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
removeEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
includeBrowserStylesCheckbox
.
removeEventListener
(
"
input
"
this
.
_onIncludeBrowserStyles
)
;
this
.
element
=
null
;
this
.
boxModelWrapper
=
null
;
this
.
searchField
=
null
;
this
.
searchClearButton
=
null
;
this
.
includeBrowserStylesCheckbox
=
null
;
for
(
let
propView
of
this
.
propertyViews
)
{
propView
.
destroy
(
)
;
}
this
.
propertyViews
=
null
;
this
.
inspector
=
null
;
this
.
highlighters
=
null
;
this
.
store
=
null
;
this
.
styleDocument
=
null
;
this
.
styleWindow
=
null
;
this
.
_isDestroyed
=
true
;
}
}
;
function
PropertyInfo
(
tree
name
)
{
this
.
tree
=
tree
;
this
.
name
=
name
;
}
PropertyInfo
.
prototype
=
{
get
value
(
)
{
if
(
this
.
tree
.
_computed
)
{
let
value
=
this
.
tree
.
_computed
[
this
.
name
]
.
value
;
return
value
;
}
return
null
;
}
}
;
function
PropertyView
(
tree
name
)
{
this
.
tree
=
tree
;
this
.
name
=
name
;
this
.
link
=
"
https
:
/
/
developer
.
mozilla
.
org
/
CSS
/
"
+
name
;
this
.
_propertyInfo
=
new
PropertyInfo
(
tree
name
)
;
}
PropertyView
.
prototype
=
{
element
:
null
propertyHeader
:
null
nameNode
:
null
valueNode
:
null
matchedExpanded
:
false
matchedSelectorsContainer
:
null
matchedExpander
:
null
_matchedSelectorViews
:
null
_prevViewedElement
:
null
get
value
(
)
{
return
this
.
propertyInfo
.
value
;
}
get
propertyInfo
(
)
{
return
this
.
_propertyInfo
;
}
get
hasMatchedSelectors
(
)
{
return
this
.
tree
.
matchedProperties
.
has
(
this
.
name
)
;
}
get
visible
(
)
{
if
(
!
this
.
tree
.
_viewedElement
)
{
return
false
;
}
if
(
!
this
.
tree
.
includeBrowserStyles
&
&
!
this
.
hasMatchedSelectors
)
{
return
false
;
}
let
searchTerm
=
this
.
tree
.
searchField
.
value
.
toLowerCase
(
)
;
let
isValidSearchTerm
=
searchTerm
.
trim
(
)
.
length
>
0
;
if
(
isValidSearchTerm
&
&
this
.
name
.
toLowerCase
(
)
.
indexOf
(
searchTerm
)
=
=
=
-
1
&
&
this
.
value
.
toLowerCase
(
)
.
indexOf
(
searchTerm
)
=
=
=
-
1
)
{
return
false
;
}
return
true
;
}
get
propertyHeaderClassName
(
)
{
if
(
this
.
visible
)
{
let
isDark
=
this
.
tree
.
_darkStripe
=
!
this
.
tree
.
_darkStripe
;
return
isDark
?
"
computed
-
property
-
view
row
-
striped
"
:
"
computed
-
property
-
view
"
;
}
return
"
computed
-
property
-
hidden
"
;
}
get
propertyContentClassName
(
)
{
if
(
this
.
visible
)
{
let
isDark
=
this
.
tree
.
_darkStripe
;
return
isDark
?
"
computed
-
property
-
content
row
-
striped
"
:
"
computed
-
property
-
content
"
;
}
return
"
computed
-
property
-
hidden
"
;
}
buildMain
:
function
(
)
{
let
doc
=
this
.
tree
.
styleDocument
;
this
.
onMatchedToggle
=
this
.
onMatchedToggle
.
bind
(
this
)
;
this
.
element
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
element
.
setAttribute
(
"
class
"
this
.
propertyHeaderClassName
)
;
this
.
element
.
addEventListener
(
"
dblclick
"
this
.
onMatchedToggle
)
;
this
.
element
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
tree
.
styleWindow
target
:
this
.
element
}
)
;
this
.
shortcuts
.
on
(
"
F1
"
(
name
event
)
=
>
{
this
.
mdnLinkClick
(
event
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
)
;
this
.
shortcuts
.
on
(
"
Return
"
(
name
event
)
=
>
this
.
onMatchedToggle
(
event
)
)
;
this
.
shortcuts
.
on
(
"
Space
"
(
name
event
)
=
>
this
.
onMatchedToggle
(
event
)
)
;
let
nameContainer
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
nameContainer
.
className
=
"
computed
-
property
-
name
-
container
"
;
this
.
element
.
appendChild
(
nameContainer
)
;
this
.
matchedExpander
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
matchedExpander
.
className
=
"
computed
-
expander
theme
-
twisty
"
;
this
.
matchedExpander
.
addEventListener
(
"
click
"
this
.
onMatchedToggle
)
;
nameContainer
.
appendChild
(
this
.
matchedExpander
)
;
this
.
nameNode
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
this
.
nameNode
.
classList
.
add
(
"
computed
-
property
-
name
"
"
theme
-
fg
-
color5
"
)
;
this
.
nameNode
.
setAttribute
(
"
tabindex
"
"
"
)
;
this
.
nameNode
.
setAttribute
(
"
dir
"
"
ltr
"
)
;
this
.
nameNode
.
textContent
=
this
.
nameNode
.
title
=
this
.
name
;
this
.
onFocus
=
(
)
=
>
this
.
element
.
focus
(
)
;
this
.
nameNode
.
addEventListener
(
"
click
"
this
.
onFocus
)
;
let
nameSeparator
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
nameSeparator
.
classList
.
add
(
"
visually
-
hidden
"
)
;
nameSeparator
.
textContent
=
"
:
"
;
this
.
nameNode
.
appendChild
(
nameSeparator
)
;
nameContainer
.
appendChild
(
this
.
nameNode
)
;
let
valueContainer
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
valueContainer
.
className
=
"
computed
-
property
-
value
-
container
"
;
this
.
element
.
appendChild
(
valueContainer
)
;
this
.
valueNode
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
this
.
valueNode
.
classList
.
add
(
"
computed
-
property
-
value
"
"
theme
-
fg
-
color1
"
)
;
this
.
valueNode
.
setAttribute
(
"
tabindex
"
"
"
)
;
this
.
valueNode
.
setAttribute
(
"
dir
"
"
ltr
"
)
;
this
.
valueNode
.
addEventListener
(
"
click
"
this
.
onFocus
)
;
let
valueSeparator
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
valueSeparator
.
classList
.
add
(
"
visually
-
hidden
"
)
;
valueSeparator
.
textContent
=
"
;
"
;
valueContainer
.
appendChild
(
this
.
valueNode
)
;
valueContainer
.
appendChild
(
valueSeparator
)
;
return
this
.
element
;
}
buildSelectorContainer
:
function
(
)
{
let
doc
=
this
.
tree
.
styleDocument
;
let
element
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
element
.
setAttribute
(
"
class
"
this
.
propertyContentClassName
)
;
this
.
matchedSelectorsContainer
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
matchedSelectorsContainer
.
classList
.
add
(
"
matchedselectors
"
)
;
element
.
appendChild
(
this
.
matchedSelectorsContainer
)
;
return
element
;
}
refresh
:
function
(
)
{
this
.
element
.
className
=
this
.
propertyHeaderClassName
;
this
.
element
.
nextElementSibling
.
className
=
this
.
propertyContentClassName
;
if
(
this
.
_prevViewedElement
!
=
=
this
.
tree
.
_viewedElement
)
{
this
.
_matchedSelectorViews
=
null
;
this
.
_prevViewedElement
=
this
.
tree
.
_viewedElement
;
}
if
(
!
this
.
tree
.
_viewedElement
|
|
!
this
.
visible
)
{
this
.
valueNode
.
textContent
=
this
.
valueNode
.
title
=
"
"
;
this
.
matchedSelectorsContainer
.
parentNode
.
hidden
=
true
;
this
.
matchedSelectorsContainer
.
textContent
=
"
"
;
this
.
matchedExpander
.
removeAttribute
(
"
open
"
)
;
return
;
}
this
.
tree
.
numVisibleProperties
+
+
;
let
outputParser
=
this
.
tree
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
this
.
propertyInfo
.
name
this
.
propertyInfo
.
value
{
colorSwatchClass
:
"
computed
-
colorswatch
"
colorClass
:
"
computed
-
color
"
urlClass
:
"
theme
-
link
"
fontFamilyClass
:
"
computed
-
font
-
family
"
}
)
;
this
.
valueNode
.
innerHTML
=
"
"
;
this
.
valueNode
.
appendChild
(
frag
)
;
this
.
refreshMatchedSelectors
(
)
;
}
refreshMatchedSelectors
:
function
(
)
{
let
hasMatchedSelectors
=
this
.
hasMatchedSelectors
;
this
.
matchedSelectorsContainer
.
parentNode
.
hidden
=
!
hasMatchedSelectors
;
if
(
hasMatchedSelectors
)
{
this
.
matchedExpander
.
classList
.
add
(
"
computed
-
expandable
"
)
;
}
else
{
this
.
matchedExpander
.
classList
.
remove
(
"
computed
-
expandable
"
)
;
}
if
(
this
.
matchedExpanded
&
&
hasMatchedSelectors
)
{
return
this
.
tree
.
pageStyle
.
getMatchedSelectors
(
this
.
tree
.
_viewedElement
this
.
name
)
.
then
(
matched
=
>
{
if
(
!
this
.
matchedExpanded
)
{
return
;
}
this
.
_matchedSelectorResponse
=
matched
;
this
.
_buildMatchedSelectors
(
)
;
this
.
matchedExpander
.
setAttribute
(
"
open
"
"
"
)
;
this
.
tree
.
inspector
.
emit
(
"
computed
-
view
-
property
-
expanded
"
)
;
}
)
.
catch
(
console
.
error
)
;
}
this
.
matchedSelectorsContainer
.
innerHTML
=
"
"
;
this
.
matchedExpander
.
removeAttribute
(
"
open
"
)
;
this
.
tree
.
inspector
.
emit
(
"
computed
-
view
-
property
-
collapsed
"
)
;
return
promise
.
resolve
(
undefined
)
;
}
get
matchedSelectors
(
)
{
return
this
.
_matchedSelectorResponse
;
}
_buildMatchedSelectors
:
function
(
)
{
let
frag
=
this
.
element
.
ownerDocument
.
createDocumentFragment
(
)
;
for
(
let
selector
of
this
.
matchedSelectorViews
)
{
let
p
=
createChild
(
frag
"
p
"
)
;
let
span
=
createChild
(
p
"
span
"
{
class
:
"
rule
-
link
"
}
)
;
let
link
=
createChild
(
span
"
a
"
{
target
:
"
_blank
"
class
:
"
computed
-
link
theme
-
link
"
title
:
selector
.
href
sourcelocation
:
selector
.
source
tabindex
:
"
0
"
textContent
:
selector
.
source
}
)
;
link
.
addEventListener
(
"
click
"
selector
.
openStyleEditor
)
;
let
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
tree
.
styleWindow
target
:
link
}
)
;
shortcuts
.
on
(
"
Return
"
(
)
=
>
selector
.
openStyleEditor
(
)
)
;
let
status
=
createChild
(
p
"
span
"
{
dir
:
"
ltr
"
class
:
"
rule
-
text
theme
-
fg
-
color3
"
+
selector
.
statusClass
title
:
selector
.
statusText
}
)
;
createChild
(
status
"
div
"
{
class
:
"
fix
-
get
-
selection
"
textContent
:
selector
.
sourceText
}
)
;
let
valueDiv
=
createChild
(
status
"
div
"
{
class
:
"
fix
-
get
-
selection
computed
-
other
-
property
-
value
theme
-
fg
-
color1
"
}
)
;
valueDiv
.
appendChild
(
selector
.
outputFragment
)
;
}
this
.
matchedSelectorsContainer
.
innerHTML
=
"
"
;
this
.
matchedSelectorsContainer
.
appendChild
(
frag
)
;
}
get
matchedSelectorViews
(
)
{
if
(
!
this
.
_matchedSelectorViews
)
{
this
.
_matchedSelectorViews
=
[
]
;
this
.
_matchedSelectorResponse
.
forEach
(
selectorInfo
=
>
{
let
selectorView
=
new
SelectorView
(
this
.
tree
selectorInfo
)
;
this
.
_matchedSelectorViews
.
push
(
selectorView
)
;
}
this
)
;
}
return
this
.
_matchedSelectorViews
;
}
onMatchedToggle
:
function
(
event
)
{
if
(
event
.
shiftKey
)
{
return
;
}
this
.
matchedExpanded
=
!
this
.
matchedExpanded
;
this
.
refreshMatchedSelectors
(
)
;
event
.
preventDefault
(
)
;
}
mdnLinkClick
:
function
(
event
)
{
let
inspector
=
this
.
tree
.
inspector
;
if
(
inspector
.
target
.
tab
)
{
let
browserWin
=
inspector
.
target
.
tab
.
ownerDocument
.
defaultView
;
browserWin
.
openUILinkIn
(
this
.
link
"
tab
"
)
;
}
}
destroy
:
function
(
)
{
if
(
this
.
_matchedSelectorViews
)
{
for
(
let
view
of
this
.
_matchedSelectorViews
)
{
view
.
destroy
(
)
;
}
}
this
.
element
.
removeEventListener
(
"
dblclick
"
this
.
onMatchedToggle
)
;
this
.
shortcuts
.
destroy
(
)
;
this
.
element
=
null
;
this
.
matchedExpander
.
removeEventListener
(
"
click
"
this
.
onMatchedToggle
)
;
this
.
matchedExpander
=
null
;
this
.
nameNode
.
removeEventListener
(
"
click
"
this
.
onFocus
)
;
this
.
nameNode
=
null
;
this
.
valueNode
.
removeEventListener
(
"
click
"
this
.
onFocus
)
;
this
.
valueNode
=
null
;
}
}
;
function
SelectorView
(
tree
selectorInfo
)
{
this
.
tree
=
tree
;
this
.
selectorInfo
=
selectorInfo
;
this
.
_cacheStatusNames
(
)
;
this
.
openStyleEditor
=
this
.
openStyleEditor
.
bind
(
this
)
;
this
.
_updateLocation
=
this
.
_updateLocation
.
bind
(
this
)
;
const
rule
=
this
.
selectorInfo
.
rule
;
if
(
!
rule
|
|
!
rule
.
parentStyleSheet
|
|
rule
.
type
=
=
ELEMENT_STYLE
)
{
this
.
source
=
CssLogic
.
l10n
(
"
rule
.
sourceElement
"
)
;
}
else
{
const
sheet
=
rule
.
parentStyleSheet
;
this
.
source
=
CssLogic
.
shortSource
(
sheet
)
+
"
:
"
+
rule
.
line
;
const
url
=
sheet
.
href
|
|
sheet
.
nodeHref
;
this
.
currentLocation
=
{
href
:
url
line
:
rule
.
line
column
:
rule
.
column
}
;
this
.
generatedLocation
=
this
.
currentLocation
;
this
.
sourceMapURLService
=
this
.
tree
.
inspector
.
toolbox
.
sourceMapURLService
;
this
.
sourceMapURLService
.
subscribe
(
url
rule
.
line
rule
.
column
this
.
_updateLocation
)
;
}
}
SelectorView
.
STATUS_NAMES
=
[
]
;
SelectorView
.
CLASS_NAMES
=
[
"
parentmatch
"
"
matched
"
"
bestmatch
"
]
;
SelectorView
.
prototype
=
{
_cacheStatusNames
:
function
(
)
{
if
(
SelectorView
.
STATUS_NAMES
.
length
)
{
return
;
}
for
(
let
status
in
CssLogic
.
STATUS
)
{
let
i
=
CssLogic
.
STATUS
[
status
]
;
if
(
i
>
CssLogic
.
STATUS
.
UNMATCHED
)
{
let
value
=
CssComputedView
.
l10n
(
"
rule
.
status
.
"
+
status
)
;
SelectorView
.
STATUS_NAMES
[
i
]
=
value
.
replace
(
/
/
g
"
\
u00A0
"
)
;
}
}
}
get
statusText
(
)
{
return
SelectorView
.
STATUS_NAMES
[
this
.
selectorInfo
.
status
]
;
}
get
statusClass
(
)
{
return
SelectorView
.
CLASS_NAMES
[
this
.
selectorInfo
.
status
-
1
]
;
}
get
href
(
)
{
if
(
this
.
_href
)
{
return
this
.
_href
;
}
let
sheet
=
this
.
selectorInfo
.
rule
.
parentStyleSheet
;
this
.
_href
=
sheet
?
sheet
.
href
:
"
#
"
;
return
this
.
_href
;
}
get
sourceText
(
)
{
return
this
.
selectorInfo
.
sourceText
;
}
get
value
(
)
{
return
this
.
selectorInfo
.
value
;
}
get
outputFragment
(
)
{
let
outputParser
=
this
.
tree
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
this
.
selectorInfo
.
name
this
.
selectorInfo
.
value
{
colorSwatchClass
:
"
computed
-
colorswatch
"
colorClass
:
"
computed
-
color
"
urlClass
:
"
theme
-
link
"
fontFamilyClass
:
"
computed
-
font
-
family
"
baseURI
:
this
.
selectorInfo
.
rule
.
href
}
)
;
return
frag
;
}
_updateLocation
:
function
(
enabled
url
line
column
)
{
if
(
!
this
.
tree
.
element
)
{
return
;
}
if
(
enabled
)
{
this
.
currentLocation
=
{
href
:
url
line
column
}
;
}
else
{
this
.
currentLocation
=
this
.
generatedLocation
;
}
let
selector
=
'
[
sourcelocation
=
"
'
+
this
.
source
+
'
"
]
'
;
let
link
=
this
.
tree
.
element
.
querySelector
(
selector
)
;
if
(
link
)
{
let
text
=
CssLogic
.
shortSource
(
this
.
currentLocation
)
+
"
:
"
+
this
.
currentLocation
.
line
;
link
.
textContent
=
text
;
}
this
.
tree
.
inspector
.
emit
(
"
computed
-
view
-
sourcelinks
-
updated
"
)
;
}
openStyleEditor
:
function
(
)
{
let
inspector
=
this
.
tree
.
inspector
;
let
rule
=
this
.
selectorInfo
.
rule
;
let
parentStyleSheet
=
rule
.
parentStyleSheet
;
if
(
!
parentStyleSheet
|
|
parentStyleSheet
.
isSystem
)
{
let
toolbox
=
gDevTools
.
getToolbox
(
inspector
.
target
)
;
toolbox
.
viewSource
(
rule
.
href
rule
.
line
)
;
return
;
}
let
{
href
line
column
}
=
this
.
currentLocation
;
let
target
=
inspector
.
target
;
if
(
ToolDefinitions
.
styleEditor
.
isTargetSupported
(
target
)
)
{
gDevTools
.
showToolbox
(
target
"
styleeditor
"
)
.
then
(
function
(
toolbox
)
{
toolbox
.
getCurrentPanel
(
)
.
selectStyleSheet
(
href
line
column
)
;
}
)
;
}
}
destroy
:
function
(
)
{
let
rule
=
this
.
selectorInfo
.
rule
;
if
(
rule
&
&
rule
.
parentStyleSheet
&
&
rule
.
type
!
=
ELEMENT_STYLE
)
{
const
url
=
rule
.
parentStyleSheet
.
href
|
|
rule
.
parentStyleSheet
.
nodeHref
;
this
.
sourceMapURLService
.
unsubscribe
(
url
rule
.
line
rule
.
column
this
.
_updateLocation
)
;
}
}
}
;
function
ComputedViewTool
(
inspector
window
)
{
this
.
inspector
=
inspector
;
this
.
document
=
window
.
document
;
this
.
computedView
=
new
CssComputedView
(
this
.
inspector
this
.
document
this
.
inspector
.
pageStyle
)
;
this
.
onSelected
=
this
.
onSelected
.
bind
(
this
)
;
this
.
refresh
=
this
.
refresh
.
bind
(
this
)
;
this
.
onPanelSelected
=
this
.
onPanelSelected
.
bind
(
this
)
;
this
.
onMutations
=
this
.
onMutations
.
bind
(
this
)
;
this
.
onResized
=
this
.
onResized
.
bind
(
this
)
;
this
.
inspector
.
selection
.
on
(
"
detached
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
selection
.
on
(
"
pseudoclass
"
this
.
refresh
)
;
this
.
inspector
.
sidebar
.
on
(
"
computedview
-
selected
"
this
.
onPanelSelected
)
;
this
.
inspector
.
pageStyle
.
on
(
"
stylesheet
-
updated
"
this
.
refresh
)
;
this
.
inspector
.
walker
.
on
(
"
mutations
"
this
.
onMutations
)
;
this
.
inspector
.
walker
.
on
(
"
resize
"
this
.
onResized
)
;
this
.
computedView
.
selectElement
(
null
)
;
this
.
onSelected
(
)
;
}
ComputedViewTool
.
prototype
=
{
isSidebarActive
:
function
(
)
{
if
(
!
this
.
computedView
)
{
return
false
;
}
return
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
"
computedview
"
;
}
onSelected
:
function
(
event
)
{
if
(
!
this
.
computedView
)
{
return
;
}
let
isInactive
=
!
this
.
isSidebarActive
(
)
&
&
this
.
inspector
.
selection
.
nodeFront
;
if
(
isInactive
)
{
return
;
}
this
.
computedView
.
setPageStyle
(
this
.
inspector
.
pageStyle
)
;
if
(
!
this
.
inspector
.
selection
.
isConnected
(
)
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
this
.
computedView
.
selectElement
(
null
)
;
return
;
}
if
(
!
event
|
|
event
=
=
"
new
-
node
-
front
"
)
{
let
done
=
this
.
inspector
.
updating
(
"
computed
-
view
"
)
;
this
.
computedView
.
selectElement
(
this
.
inspector
.
selection
.
nodeFront
)
.
then
(
(
)
=
>
{
done
(
)
;
}
)
;
}
}
refresh
:
function
(
)
{
if
(
this
.
isSidebarActive
(
)
)
{
this
.
computedView
.
refreshPanel
(
)
;
}
}
onPanelSelected
:
function
(
)
{
if
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
this
.
computedView
.
_viewedElement
)
{
this
.
refresh
(
)
;
}
else
{
this
.
onSelected
(
)
;
}
}
onMutations
:
function
(
mutations
)
{
for
(
let
{
type
target
}
of
mutations
)
{
if
(
target
=
=
=
this
.
inspector
.
selection
.
nodeFront
&
&
type
=
=
=
"
attributes
"
)
{
this
.
refresh
(
)
;
break
;
}
}
}
onResized
:
function
(
)
{
this
.
refresh
(
)
;
}
destroy
:
function
(
)
{
this
.
inspector
.
walker
.
off
(
"
mutations
"
this
.
onMutations
)
;
this
.
inspector
.
walker
.
off
(
"
resize
"
this
.
onResized
)
;
this
.
inspector
.
sidebar
.
off
(
"
computedview
-
selected
"
this
.
refresh
)
;
this
.
inspector
.
selection
.
off
(
"
pseudoclass
"
this
.
refresh
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
selection
.
off
(
"
detached
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
sidebar
.
off
(
"
computedview
-
selected
"
this
.
onPanelSelected
)
;
if
(
this
.
inspector
.
pageStyle
)
{
this
.
inspector
.
pageStyle
.
off
(
"
stylesheet
-
updated
"
this
.
refresh
)
;
}
this
.
computedView
.
destroy
(
)
;
this
.
computedView
=
this
.
document
=
this
.
inspector
=
null
;
}
}
;
exports
.
CssComputedView
=
CssComputedView
;
exports
.
ComputedViewTool
=
ComputedViewTool
;
exports
.
PropertyView
=
PropertyView
;
