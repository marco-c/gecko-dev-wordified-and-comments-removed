"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
function
fireCopyEvent
(
element
)
{
const
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
getComputedViewProperties
(
view
)
{
return
Array
.
from
(
view
.
styleDocument
.
querySelectorAll
(
"
#
computed
-
container
.
computed
-
property
-
view
"
)
)
;
}
function
getComputedViewProperty
(
view
name
)
{
let
prop
;
for
(
const
property
of
getComputedViewProperties
(
view
)
)
{
const
nameSpan
=
property
.
querySelector
(
"
.
computed
-
property
-
name
"
)
;
const
valueSpan
=
property
.
querySelector
(
"
.
computed
-
property
-
value
"
)
;
if
(
nameSpan
.
firstChild
.
textContent
=
=
=
name
)
{
prop
=
{
nameSpan
valueSpan
}
;
break
;
}
}
return
prop
;
}
function
getComputedViewPropertyView
(
view
name
)
{
let
propView
;
for
(
const
propertyView
of
view
.
propertyViews
)
{
if
(
propertyView
.
propertyInfo
.
name
=
=
=
name
)
{
propView
=
propertyView
;
break
;
}
}
return
propView
;
}
var
getComputedViewMatchedRules
=
async
function
(
view
name
)
{
let
expander
;
let
matchedRulesEl
;
for
(
const
property
of
view
.
styleDocument
.
querySelectorAll
(
"
#
computed
-
container
.
computed
-
property
-
view
"
)
)
{
const
nameSpan
=
property
.
querySelector
(
"
.
computed
-
property
-
name
"
)
;
if
(
nameSpan
.
firstChild
.
textContent
=
=
=
name
)
{
expander
=
property
.
querySelector
(
"
.
computed
-
expandable
"
)
;
matchedRulesEl
=
property
.
querySelector
(
"
.
matchedselectors
"
)
;
break
;
}
}
if
(
!
expander
.
hasAttribute
(
"
open
"
)
)
{
const
onExpand
=
view
.
inspector
.
once
(
"
computed
-
view
-
property
-
expanded
"
)
;
expander
.
click
(
)
;
await
onExpand
;
await
waitFor
(
(
)
=
>
expander
.
hasAttribute
(
"
open
"
)
)
;
}
return
matchedRulesEl
;
}
;
function
getComputedViewPropertyValue
(
view
name
)
{
return
getComputedViewProperty
(
view
name
)
.
valueSpan
.
textContent
;
}
function
expandComputedViewPropertyByIndex
(
view
index
)
{
info
(
"
Expanding
property
"
+
index
+
"
in
the
computed
view
"
)
;
const
expandos
=
view
.
styleDocument
.
querySelectorAll
(
"
.
computed
-
expandable
"
)
;
if
(
!
expandos
.
length
|
|
!
expandos
[
index
]
)
{
return
Promise
.
reject
(
)
;
}
const
onExpand
=
view
.
inspector
.
once
(
"
computed
-
view
-
property
-
expanded
"
)
;
expandos
[
index
]
.
click
(
)
;
return
onExpand
;
}
function
getComputedViewLinkByIndex
(
view
index
)
{
const
matchedSelectors
=
view
.
styleDocument
.
querySelectorAll
(
"
.
matchedselectors
>
p
"
)
;
const
matchedSelector
=
matchedSelectors
[
index
]
;
if
(
!
matchedSelector
)
{
return
null
;
}
return
matchedSelector
.
querySelector
(
.
rule
-
link
.
computed
-
link
)
;
}
function
selectAllText
(
view
)
{
info
(
"
Selecting
all
the
text
"
)
;
view
.
contextMenu
.
_onSelectAll
(
)
;
}
async
function
copyAllAndCheckClipboard
(
view
expectedPattern
)
{
selectAllText
(
view
)
;
const
contentDoc
=
view
.
styleDocument
;
const
prop
=
contentDoc
.
querySelector
(
"
#
computed
-
container
.
computed
-
property
-
view
"
)
;
try
{
info
(
"
Trigger
a
copy
event
and
wait
for
the
clipboard
content
"
)
;
await
waitForClipboardPromise
(
(
)
=
>
fireCopyEvent
(
prop
)
(
)
=
>
checkClipboard
(
expectedPattern
)
)
;
}
catch
(
e
)
{
failClipboardCheck
(
expectedPattern
)
;
}
}
async
function
copySomeTextAndCheckClipboard
(
view
positions
expectedPattern
)
{
info
(
"
Testing
selection
copy
"
)
;
const
contentDocument
=
view
.
styleDocument
;
const
props
=
contentDocument
.
querySelectorAll
(
"
#
computed
-
container
.
computed
-
property
-
view
"
)
;
info
(
"
Create
the
text
selection
range
"
)
;
const
range
=
contentDocument
.
createRange
(
)
;
range
.
setStart
(
props
[
positions
.
start
.
prop
]
positions
.
start
.
offset
)
;
range
.
setEnd
(
props
[
positions
.
end
.
prop
]
positions
.
end
.
offset
)
;
contentDocument
.
defaultView
.
getSelection
(
)
.
addRange
(
range
)
;
try
{
info
(
"
Trigger
a
copy
event
and
wait
for
the
clipboard
content
"
)
;
await
waitForClipboardPromise
(
(
)
=
>
fireCopyEvent
(
props
[
0
]
)
(
)
=
>
checkClipboard
(
expectedPattern
)
)
;
}
catch
(
e
)
{
failClipboardCheck
(
expectedPattern
)
;
}
}
function
checkClipboard
(
expectedPattern
)
{
const
actual
=
SpecialPowers
.
getClipboardData
(
"
text
/
plain
"
)
;
const
expectedRegExp
=
new
RegExp
(
expectedPattern
"
g
"
)
;
return
expectedRegExp
.
test
(
actual
)
;
}
function
failClipboardCheck
(
expectedPattern
)
{
const
terminator
=
Services
.
appinfo
.
OS
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
;
expectedPattern
=
expectedPattern
.
replace
(
/
\
[
\
\
r
\
\
n
\
]
[
+
*
]
/
g
terminator
)
;
expectedPattern
=
expectedPattern
.
replace
(
/
\
\
\
(
/
g
"
(
"
)
;
expectedPattern
=
expectedPattern
.
replace
(
/
\
\
\
)
/
g
"
)
"
)
;
let
actual
=
SpecialPowers
.
getClipboardData
(
"
text
/
plain
"
)
;
expectedPattern
=
expectedPattern
.
trimRight
(
)
;
actual
=
actual
.
trimRight
(
)
;
dump
(
"
TEST
-
UNEXPECTED
-
FAIL
|
Clipboard
text
does
not
match
expected
.
.
.
"
+
"
results
(
escaped
for
accurate
comparison
)
:
\
n
"
)
;
info
(
"
Actual
:
"
+
escape
(
actual
)
)
;
info
(
"
Expected
:
"
+
escape
(
expectedPattern
)
)
;
}
