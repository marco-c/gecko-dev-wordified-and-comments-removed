"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
function
openComputedView
(
)
{
return
openInspectorSidebarTab
(
"
computedview
"
)
.
then
(
(
{
toolbox
inspector
}
)
=
>
{
return
{
toolbox
inspector
view
:
inspector
.
computedview
.
view
}
;
}
)
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
waitForTab
=
Task
.
async
(
function
*
(
)
{
info
(
"
Waiting
for
a
tab
to
open
"
)
;
yield
once
(
gBrowser
.
tabContainer
"
TabOpen
"
)
;
let
tab
=
gBrowser
.
selectedTab
;
let
browser
=
tab
.
linkedBrowser
;
yield
once
(
browser
"
load
"
true
)
;
info
(
"
The
tab
load
completed
"
)
;
return
tab
;
}
)
;
function
fireCopyEvent
(
element
)
{
let
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
synthesizeKeys
(
input
win
)
{
for
(
let
key
of
input
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
win
)
;
}
}
function
getComputedViewProperty
(
view
name
)
{
let
prop
;
for
(
let
property
of
view
.
styleDocument
.
querySelectorAll
(
"
.
property
-
view
"
)
)
{
let
nameSpan
=
property
.
querySelector
(
"
.
property
-
name
"
)
;
let
valueSpan
=
property
.
querySelector
(
"
.
property
-
value
"
)
;
if
(
nameSpan
.
textContent
=
=
=
name
)
{
prop
=
{
nameSpan
:
nameSpan
valueSpan
:
valueSpan
}
;
break
;
}
}
return
prop
;
}
function
getComputedViewPropertyView
(
view
name
)
{
let
propView
;
for
(
let
propertyView
of
view
.
propertyViews
)
{
if
(
propertyView
.
_propertyInfo
.
name
=
=
=
name
)
{
propView
=
propertyView
;
break
;
}
}
return
propView
;
}
var
getComputedViewMatchedRules
=
Task
.
async
(
function
*
(
view
name
)
{
let
expander
;
let
propertyContent
;
for
(
let
property
of
view
.
styleDocument
.
querySelectorAll
(
"
.
property
-
view
"
)
)
{
let
nameSpan
=
property
.
querySelector
(
"
.
property
-
name
"
)
;
if
(
nameSpan
.
textContent
=
=
=
name
)
{
expander
=
property
.
querySelector
(
"
.
expandable
"
)
;
propertyContent
=
property
.
nextSibling
;
break
;
}
}
if
(
!
expander
.
hasAttribute
(
"
open
"
)
)
{
let
onExpand
=
view
.
inspector
.
once
(
"
computed
-
view
-
property
-
expanded
"
)
;
expander
.
click
(
)
;
yield
onExpand
;
}
return
propertyContent
;
}
)
;
function
getComputedViewPropertyValue
(
view
name
propertyName
)
{
return
getComputedViewProperty
(
view
name
propertyName
)
.
valueSpan
.
textContent
;
}
function
expandComputedViewPropertyByIndex
(
view
index
)
{
info
(
"
Expanding
property
"
+
index
+
"
in
the
computed
view
"
)
;
let
expandos
=
view
.
styleDocument
.
querySelectorAll
(
"
.
expandable
"
)
;
if
(
!
expandos
.
length
|
|
!
expandos
[
index
]
)
{
return
promise
.
reject
(
)
;
}
let
onExpand
=
view
.
inspector
.
once
(
"
computed
-
view
-
property
-
expanded
"
)
;
expandos
[
index
]
.
click
(
)
;
return
onExpand
;
}
function
getComputedViewLinkByIndex
(
view
index
)
{
let
links
=
view
.
styleDocument
.
querySelectorAll
(
"
.
rule
-
link
.
link
"
)
;
return
links
[
index
]
;
}
