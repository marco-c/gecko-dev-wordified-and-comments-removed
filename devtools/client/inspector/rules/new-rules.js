"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
ElementStyle
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
element
-
style
"
)
;
const
{
createFactory
createElement
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
updateClasses
updateClassPanelExpanded
}
=
require
(
"
.
/
actions
/
class
-
list
"
)
;
const
{
disableAllPseudoClasses
setPseudoClassLocks
togglePseudoClass
}
=
require
(
"
.
/
actions
/
pseudo
-
classes
"
)
;
const
{
updateAddRuleEnabled
updateColorSchemeSimulationHidden
updateHighlightedSelector
updatePrintSimulationHidden
updateRules
updateSourceLinkEnabled
}
=
require
(
"
.
/
actions
/
rules
"
)
;
const
RulesApp
=
createFactory
(
require
(
"
.
/
components
/
RulesApp
"
)
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
Tools
"
"
devtools
/
client
/
definitions
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ClassList
"
"
devtools
/
client
/
inspector
/
rules
/
models
/
class
-
list
"
)
;
loader
.
lazyRequireGetter
(
this
"
advanceValidate
"
"
devtools
/
client
/
inspector
/
shared
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
InplaceEditor
"
"
devtools
/
client
/
shared
/
inplace
-
editor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
COLOR_SCHEMES
"
"
devtools
/
client
/
inspector
/
rules
/
constants
"
true
)
;
const
PREF_UA_STYLES
=
"
devtools
.
inspector
.
showUserAgentStyles
"
;
class
RulesView
{
constructor
(
inspector
window
)
{
this
.
cssProperties
=
inspector
.
cssProperties
;
this
.
doc
=
window
.
document
;
this
.
inspector
=
inspector
;
this
.
selection
=
inspector
.
selection
;
this
.
store
=
inspector
.
store
;
this
.
telemetry
=
inspector
.
telemetry
;
this
.
toolbox
=
inspector
.
toolbox
;
this
.
isNewRulesView
=
true
;
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
onAddClass
=
this
.
onAddClass
.
bind
(
this
)
;
this
.
onAddRule
=
this
.
onAddRule
.
bind
(
this
)
;
this
.
onOpenSourceLink
=
this
.
onOpenSourceLink
.
bind
(
this
)
;
this
.
onSelection
=
this
.
onSelection
.
bind
(
this
)
;
this
.
onSetClassState
=
this
.
onSetClassState
.
bind
(
this
)
;
this
.
onToggleClassPanelExpanded
=
this
.
onToggleClassPanelExpanded
.
bind
(
this
)
;
this
.
onToggleDeclaration
=
this
.
onToggleDeclaration
.
bind
(
this
)
;
this
.
onTogglePrintSimulation
=
this
.
onTogglePrintSimulation
.
bind
(
this
)
;
this
.
onToggleColorSchemeSimulation
=
this
.
onToggleColorSchemeSimulation
.
bind
(
this
)
;
this
.
onTogglePseudoClass
=
this
.
onTogglePseudoClass
.
bind
(
this
)
;
this
.
onToolChanged
=
this
.
onToolChanged
.
bind
(
this
)
;
this
.
onToggleSelectorHighlighter
=
this
.
onToggleSelectorHighlighter
.
bind
(
this
)
;
this
.
showDeclarationNameEditor
=
this
.
showDeclarationNameEditor
.
bind
(
this
)
;
this
.
showDeclarationValueEditor
=
this
.
showDeclarationValueEditor
.
bind
(
this
)
;
this
.
showNewDeclarationEditor
=
this
.
showNewDeclarationEditor
.
bind
(
this
)
;
this
.
showSelectorEditor
=
this
.
showSelectorEditor
.
bind
(
this
)
;
this
.
updateClassList
=
this
.
updateClassList
.
bind
(
this
)
;
this
.
updateRules
=
this
.
updateRules
.
bind
(
this
)
;
this
.
inspector
.
sidebar
.
on
(
"
select
"
this
.
onSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
onSelection
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onSelection
)
;
this
.
toolbox
.
on
(
"
tool
-
registered
"
this
.
onToolChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
unregistered
"
this
.
onToolChanged
)
;
this
.
init
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
init
(
)
{
if
(
!
this
.
inspector
)
{
return
;
}
const
rulesApp
=
RulesApp
(
{
onAddClass
:
this
.
onAddClass
onAddRule
:
this
.
onAddRule
onOpenSourceLink
:
this
.
onOpenSourceLink
onSetClassState
:
this
.
onSetClassState
onToggleClassPanelExpanded
:
this
.
onToggleClassPanelExpanded
onToggleColorSchemeSimulation
:
this
.
onToggleColorSchemeSimulation
onToggleDeclaration
:
this
.
onToggleDeclaration
onTogglePrintSimulation
:
this
.
onTogglePrintSimulation
onTogglePseudoClass
:
this
.
onTogglePseudoClass
onToggleSelectorHighlighter
:
this
.
onToggleSelectorHighlighter
showDeclarationNameEditor
:
this
.
showDeclarationNameEditor
showDeclarationValueEditor
:
this
.
showDeclarationValueEditor
showNewDeclarationEditor
:
this
.
showNewDeclarationEditor
showSelectorEditor
:
this
.
showSelectorEditor
}
)
;
this
.
initSimulationFeatures
(
)
;
const
provider
=
createElement
(
Provider
{
id
:
"
ruleview
"
key
:
"
ruleview
"
store
:
this
.
store
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
ruleViewTitle
"
)
}
rulesApp
)
;
this
.
provider
=
provider
;
}
async
initSimulationFeatures
(
)
{
this
.
emulationFront
=
await
this
.
currentTarget
.
getFront
(
"
emulation
"
)
;
if
(
!
this
.
currentTarget
.
chrome
)
{
this
.
store
.
dispatch
(
updatePrintSimulationHidden
(
false
)
)
;
}
else
{
this
.
store
.
dispatch
(
updatePrintSimulationHidden
(
true
)
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
color
-
scheme
-
simulation
.
enabled
"
)
&
&
(
await
this
.
currentTarget
.
actorHasMethod
(
"
emulation
"
"
getEmulatedColorScheme
"
)
)
)
{
this
.
store
.
dispatch
(
updateColorSchemeSimulationHidden
(
false
)
)
;
}
else
{
this
.
store
.
dispatch
(
updateColorSchemeSimulationHidden
(
true
)
)
;
}
}
destroy
(
)
{
this
.
inspector
.
sidebar
.
off
(
"
select
"
this
.
onSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
onSelection
)
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onSelection
)
;
this
.
toolbox
.
off
(
"
tool
-
registered
"
this
.
onToolChanged
)
;
this
.
toolbox
.
off
(
"
tool
-
unregistered
"
this
.
onToolChanged
)
;
if
(
this
.
_autocompletePopup
)
{
this
.
_autocompletePopup
.
destroy
(
)
;
this
.
_autocompletePopup
=
null
;
}
if
(
this
.
_classList
)
{
this
.
_classList
.
off
(
"
current
-
node
-
class
-
changed
"
this
.
refreshClassList
)
;
this
.
_classList
.
destroy
(
)
;
this
.
_classList
=
null
;
}
if
(
this
.
_selectHighlighter
)
{
this
.
_selectorHighlighter
.
finalize
(
)
;
this
.
_selectorHighlighter
=
null
;
}
if
(
this
.
elementStyle
)
{
this
.
elementStyle
.
destroy
(
)
;
this
.
elementStyle
=
null
;
}
if
(
this
.
emulationFront
)
{
this
.
emulationFront
.
destroy
(
)
;
this
.
emulationFront
=
null
;
}
this
.
_dummyElement
=
null
;
this
.
cssProperties
=
null
;
this
.
doc
=
null
;
this
.
inspector
=
null
;
this
.
pageStyle
=
null
;
this
.
selection
=
null
;
this
.
showUserAgentStyles
=
null
;
this
.
store
=
null
;
this
.
telemetry
=
null
;
this
.
toolbox
=
null
;
}
get
autocompletePopup
(
)
{
if
(
!
this
.
_autocompletePopup
)
{
this
.
_autocompletePopup
=
new
AutocompletePopup
(
this
.
doc
{
autoSelect
:
true
theme
:
"
auto
"
}
)
;
}
return
this
.
_autocompletePopup
;
}
get
classList
(
)
{
if
(
!
this
.
_classList
)
{
this
.
_classList
=
new
ClassList
(
this
.
inspector
)
;
}
return
this
.
_classList
;
}
get
currentTarget
(
)
{
return
this
.
inspector
.
currentTarget
;
}
get
dummyElement
(
)
{
if
(
!
this
.
_dummyElement
)
{
this
.
_dummyElement
=
this
.
doc
.
createElement
(
"
div
"
)
;
}
return
this
.
_dummyElement
;
}
get
highlighters
(
)
{
return
this
.
inspector
.
highlighters
;
}
async
getGridlineNames
(
)
{
const
gridLineNames
=
{
cols
:
[
]
rows
:
[
]
}
;
const
layoutInspector
=
await
this
.
inspector
.
walker
.
getLayoutInspector
(
)
;
const
gridFront
=
await
layoutInspector
.
getCurrentGrid
(
this
.
selection
.
nodeFront
)
;
if
(
gridFront
)
{
const
gridFragments
=
gridFront
.
gridFragments
;
for
(
const
gridFragment
of
gridFragments
)
{
for
(
const
rowLine
of
gridFragment
.
rows
.
lines
)
{
gridLineNames
.
rows
=
gridLineNames
.
rows
.
concat
(
rowLine
.
names
)
;
}
for
(
const
colLine
of
gridFragment
.
cols
.
lines
)
{
gridLineNames
.
cols
=
gridLineNames
.
cols
.
concat
(
colLine
.
names
)
;
}
}
}
this
.
inspector
.
emit
(
"
grid
-
line
-
names
-
updated
"
)
;
return
gridLineNames
;
}
async
getSelectorHighlighter
(
)
{
if
(
!
this
.
inspector
)
{
return
null
;
}
if
(
this
.
_selectorHighlighter
)
{
return
this
.
_selectorHighlighter
;
}
try
{
const
front
=
this
.
inspector
.
inspectorFront
;
this
.
_selectorHighlighter
=
await
front
.
getHighlighterByType
(
"
SelectorHighlighter
"
)
;
return
this
.
_selectorHighlighter
;
}
catch
(
e
)
{
return
null
;
}
}
isPanelVisible
(
)
{
return
(
this
.
inspector
&
&
this
.
inspector
.
toolbox
&
&
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
toolbox
.
currentToolId
=
=
=
"
inspector
"
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
=
"
newruleview
"
)
;
}
async
onAddClass
(
value
)
{
await
this
.
classList
.
addClassName
(
value
)
;
this
.
updateClassList
(
)
;
}
async
onAddRule
(
)
{
await
this
.
elementStyle
.
addNewRule
(
)
;
}
async
onOpenSourceLink
(
ruleId
)
{
const
rule
=
this
.
elementStyle
.
getRule
(
ruleId
)
;
if
(
!
rule
|
|
!
Tools
.
styleEditor
.
isTargetSupported
(
this
.
currentTarget
)
)
{
return
;
}
const
toolbox
=
await
gDevTools
.
showToolbox
(
this
.
currentTarget
"
styleeditor
"
)
;
const
styleEditor
=
toolbox
.
getCurrentPanel
(
)
;
if
(
!
styleEditor
)
{
return
;
}
const
{
url
line
column
}
=
rule
.
sourceLocation
;
styleEditor
.
selectStyleSheet
(
url
line
column
)
;
}
onSelection
(
)
{
if
(
!
this
.
isPanelVisible
(
)
)
{
return
;
}
if
(
!
this
.
selection
.
isConnected
(
)
|
|
!
this
.
selection
.
isElementNode
(
)
)
{
this
.
update
(
)
;
return
;
}
this
.
update
(
this
.
selection
.
nodeFront
)
;
}
async
onSetClassState
(
name
checked
)
{
await
this
.
classList
.
setClassState
(
name
checked
)
;
this
.
updateClassList
(
)
;
}
onToggleClassPanelExpanded
(
isClassPanelExpanded
)
{
if
(
isClassPanelExpanded
)
{
this
.
classList
.
on
(
"
current
-
node
-
class
-
changed
"
this
.
updateClassList
)
;
}
else
{
this
.
classList
.
off
(
"
current
-
node
-
class
-
changed
"
this
.
updateClassList
)
;
}
this
.
store
.
dispatch
(
updateClassPanelExpanded
(
isClassPanelExpanded
)
)
;
}
onToggleDeclaration
(
ruleId
declarationId
)
{
this
.
elementStyle
.
toggleDeclaration
(
ruleId
declarationId
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
async
onToggleColorSchemeSimulation
(
)
{
const
currentState
=
await
this
.
emulationFront
.
getEmulatedColorScheme
(
)
;
const
index
=
COLOR_SCHEMES
.
indexOf
(
currentState
)
;
const
nextState
=
COLOR_SCHEMES
[
(
index
+
1
)
%
COLOR_SCHEMES
.
length
]
;
await
this
.
emulationFront
.
setEmulatedColorScheme
(
nextState
)
;
await
this
.
updateElementStyle
(
)
;
}
async
onTogglePrintSimulation
(
)
{
const
enabled
=
await
this
.
emulationFront
.
getIsPrintSimulationEnabled
(
)
;
if
(
!
enabled
)
{
await
this
.
emulationFront
.
startPrintMediaSimulation
(
)
;
}
else
{
await
this
.
emulationFront
.
stopPrintMediaSimulation
(
false
)
;
}
await
this
.
updateElementStyle
(
)
;
}
onTogglePseudoClass
(
value
)
{
this
.
store
.
dispatch
(
togglePseudoClass
(
value
)
)
;
this
.
inspector
.
togglePseudoClass
(
value
)
;
}
async
onToggleSelectorHighlighter
(
selector
)
{
const
highlighter
=
await
this
.
getSelectorHighlighter
(
)
;
if
(
!
highlighter
)
{
return
;
}
await
highlighter
.
hide
(
)
;
if
(
selector
!
=
=
this
.
highlighters
.
selectorHighlighterShown
)
{
this
.
store
.
dispatch
(
updateHighlightedSelector
(
selector
)
)
;
await
highlighter
.
show
(
this
.
selection
.
nodeFront
{
hideInfoBar
:
true
hideGuides
:
true
selector
}
)
;
this
.
highlighters
.
selectorHighlighterShown
=
selector
;
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
true
)
;
}
else
{
this
.
highlighters
.
selectorHighlighterShown
=
null
;
this
.
store
.
dispatch
(
updateHighlightedSelector
(
"
"
)
)
;
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
false
)
;
}
}
onToolChanged
(
)
{
const
prevIsSourceLinkEnabled
=
this
.
store
.
getState
(
)
.
rules
.
isSourceLinkEnabled
;
const
isSourceLinkEnabled
=
this
.
toolbox
.
isToolRegistered
(
"
styleeditor
"
)
;
if
(
prevIsSourceLinkEnabled
!
=
=
isSourceLinkEnabled
)
{
this
.
store
.
dispatch
(
updateSourceLinkEnabled
(
isSourceLinkEnabled
)
)
;
}
}
showDeclarationNameEditor
(
element
ruleId
declarationId
)
{
new
InplaceEditor
(
{
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
cssProperties
:
this
.
cssProperties
done
:
async
(
name
commit
)
=
>
{
if
(
!
commit
)
{
return
;
}
await
this
.
elementStyle
.
modifyDeclarationName
(
ruleId
declarationId
name
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
element
popup
:
this
.
autocompletePopup
}
)
;
}
showDeclarationValueEditor
(
element
ruleId
declarationId
)
{
const
rule
=
this
.
elementStyle
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
declaration
=
rule
.
getDeclaration
(
declarationId
)
;
if
(
!
declaration
)
{
return
;
}
new
InplaceEditor
(
{
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
cssProperties
:
this
.
cssProperties
cssVariables
:
this
.
elementStyle
.
variablesMap
.
get
(
rule
.
pseudoElement
)
|
|
[
]
defaultIncrement
:
declaration
.
name
=
=
=
"
opacity
"
?
0
.
1
:
1
done
:
async
(
value
commit
)
=
>
{
if
(
!
commit
|
|
!
value
|
|
!
value
.
trim
(
)
)
{
return
;
}
await
this
.
elementStyle
.
modifyDeclarationValue
(
ruleId
declarationId
value
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
element
getGridLineNames
:
this
.
getGridlineNames
maxWidth
:
(
)
=
>
{
const
containerElement
=
element
.
closest
(
"
.
ruleview
-
propertycontainer
"
)
;
return
containerElement
.
getBoundingClientRect
(
)
.
width
;
}
multiline
:
true
popup
:
this
.
autocompletePopup
property
:
declaration
showSuggestCompletionOnEmpty
:
true
}
)
;
}
showNewDeclarationEditor
(
element
ruleId
callback
)
{
new
InplaceEditor
(
{
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
cssProperties
:
this
.
cssProperties
destroy
:
(
)
=
>
{
callback
(
)
;
}
done
:
(
value
commit
)
=
>
{
if
(
!
commit
|
|
!
value
|
|
!
value
.
trim
(
)
)
{
return
;
}
this
.
elementStyle
.
addNewDeclaration
(
ruleId
value
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
element
popup
:
this
.
autocompletePopup
}
)
;
}
showSelectorEditor
(
element
ruleId
)
{
new
InplaceEditor
(
{
element
done
:
async
(
value
commit
)
=
>
{
if
(
!
value
|
|
!
commit
)
{
return
;
}
if
(
this
.
highlighters
.
selectorHighlighterShown
)
{
const
selector
=
await
this
.
elementStyle
.
getRule
(
ruleId
)
.
getUniqueSelector
(
)
;
if
(
this
.
highlighters
.
selectorHighlighterShown
=
=
=
selector
)
{
this
.
onToggleSelectorHighlighter
(
this
.
highlighters
.
selectorHighlighterShown
)
;
}
}
await
this
.
elementStyle
.
modifySelector
(
ruleId
value
)
;
}
}
)
;
}
async
update
(
element
)
{
if
(
this
.
elementStyle
)
{
this
.
elementStyle
.
destroy
(
)
;
}
if
(
!
element
)
{
this
.
store
.
dispatch
(
disableAllPseudoClasses
(
)
)
;
this
.
store
.
dispatch
(
updateAddRuleEnabled
(
false
)
)
;
this
.
store
.
dispatch
(
updateClasses
(
[
]
)
)
;
this
.
store
.
dispatch
(
updateRules
(
[
]
)
)
;
return
;
}
this
.
pageStyle
=
element
.
inspectorFront
.
pageStyle
;
this
.
elementStyle
=
new
ElementStyle
(
element
this
{
}
this
.
pageStyle
this
.
showUserAgentStyles
)
;
this
.
elementStyle
.
onChanged
=
this
.
updateRules
;
await
this
.
updateElementStyle
(
)
;
}
updateClassList
(
)
{
this
.
store
.
dispatch
(
updateClasses
(
this
.
classList
.
currentClasses
)
)
;
}
async
updateElementStyle
(
)
{
await
this
.
elementStyle
.
populate
(
)
;
const
isAddRuleEnabled
=
this
.
selection
.
isElementNode
(
)
&
&
!
this
.
selection
.
isAnonymousNode
(
)
;
this
.
store
.
dispatch
(
updateAddRuleEnabled
(
isAddRuleEnabled
)
)
;
this
.
store
.
dispatch
(
setPseudoClassLocks
(
this
.
elementStyle
.
element
.
pseudoClassLocks
)
)
;
this
.
updateClassList
(
)
;
this
.
updateRules
(
)
;
}
updateRules
(
)
{
this
.
store
.
dispatch
(
updateRules
(
this
.
elementStyle
.
rules
)
)
;
}
}
module
.
exports
=
RulesView
;
