"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
ROOT_TEST_DIR
=
getRootDirectory
(
gTestPath
)
;
const
FRAME_SCRIPT_URL
=
ROOT_TEST_DIR
+
"
doc_frame_script
.
js
"
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
var
_addTab
=
addTab
;
addTab
=
function
(
url
)
{
return
_addTab
(
url
)
.
then
(
tab
=
>
{
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
const
browser
=
tab
.
linkedBrowser
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
return
tab
;
}
)
;
}
;
function
getStyle
(
testActor
selector
propName
)
{
return
testActor
.
eval
(
document
.
querySelector
(
"
{
selector
}
"
)
.
style
.
getPropertyValue
(
"
{
propName
}
"
)
;
)
;
}
async
function
hideTooltipAndWaitForRuleViewChanged
(
editorTooltip
view
)
{
const
onModified
=
view
.
once
(
"
ruleview
-
changed
"
)
;
const
onHidden
=
editorTooltip
.
tooltip
.
once
(
"
hidden
"
)
;
editorTooltip
.
hide
(
)
;
await
onModified
;
await
onHidden
;
}
var
waitForSuccess
=
async
function
(
validatorFn
desc
=
"
untitled
"
)
{
let
i
=
0
;
while
(
true
)
{
info
(
"
Checking
:
"
+
desc
)
;
if
(
await
validatorFn
(
)
)
{
ok
(
true
"
Success
:
"
+
desc
)
;
break
;
}
i
+
+
;
if
(
i
>
10
)
{
ok
(
false
"
Failure
:
"
+
desc
)
;
break
;
}
await
new
Promise
(
r
=
>
setTimeout
(
r
200
)
)
;
}
}
;
var
simulateColorPickerChange
=
async
function
(
ruleView
colorPicker
newRgba
expectedChange
)
{
let
onComputedStyleChanged
;
if
(
expectedChange
)
{
const
{
selector
name
value
}
=
expectedChange
;
onComputedStyleChanged
=
waitForComputedStyleProperty
(
selector
null
name
value
)
;
}
const
onRuleViewChanged
=
ruleView
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
const
spectrum
=
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
info
(
"
Waiting
for
rule
-
view
to
update
"
)
;
await
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
await
onComputedStyleChanged
;
}
}
;
var
openColorPickerAndSelectColor
=
async
function
(
view
ruleIndex
propIndex
newRgba
expectedChange
)
{
const
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
const
propEditor
=
ruleEditor
.
rule
.
textProps
[
propIndex
]
.
editor
;
const
swatch
=
propEditor
.
valueSpan
.
querySelector
(
"
.
ruleview
-
colorswatch
"
)
;
const
cPicker
=
view
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
;
info
(
"
Opening
the
colorpicker
by
clicking
the
color
swatch
"
)
;
const
onColorPickerReady
=
cPicker
.
once
(
"
ready
"
)
;
swatch
.
click
(
)
;
await
onColorPickerReady
;
await
simulateColorPickerChange
(
view
cPicker
newRgba
expectedChange
)
;
return
{
propEditor
swatch
cPicker
}
;
}
;
var
openCubicBezierAndChangeCoords
=
async
function
(
view
ruleIndex
propIndex
coords
expectedChange
)
{
const
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
const
propEditor
=
ruleEditor
.
rule
.
textProps
[
propIndex
]
.
editor
;
const
swatch
=
propEditor
.
valueSpan
.
querySelector
(
"
.
ruleview
-
bezierswatch
"
)
;
const
bezierTooltip
=
view
.
tooltips
.
getTooltip
(
"
cubicBezier
"
)
;
info
(
"
Opening
the
cubicBezier
by
clicking
the
swatch
"
)
;
const
onBezierWidgetReady
=
bezierTooltip
.
once
(
"
ready
"
)
;
swatch
.
click
(
)
;
await
onBezierWidgetReady
;
const
widget
=
await
bezierTooltip
.
widget
;
info
(
"
Simulating
a
change
of
curve
in
the
widget
"
)
;
const
onRuleViewChanged
=
view
.
once
(
"
ruleview
-
changed
"
)
;
widget
.
coordinates
=
coords
;
await
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
const
{
selector
name
value
}
=
expectedChange
;
await
waitForComputedStyleProperty
(
selector
null
name
value
)
;
}
return
{
propEditor
swatch
bezierTooltip
}
;
}
;
var
addProperty
=
async
function
(
view
ruleIndex
name
value
commitValueWith
=
"
VK_RETURN
"
blurNewProperty
=
true
)
{
info
(
"
Adding
new
property
"
+
name
+
"
:
"
+
value
+
"
to
rule
"
+
ruleIndex
)
;
const
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
let
editor
=
await
focusNewRuleViewProperty
(
ruleEditor
)
;
const
numOfProps
=
ruleEditor
.
rule
.
textProps
.
length
;
const
onMutations
=
new
Promise
(
r
=
>
{
if
(
ruleIndex
!
=
=
0
)
{
r
(
)
;
}
let
receivedMutations
=
0
;
view
.
inspector
.
walker
.
on
(
"
mutations
"
function
onWalkerMutations
(
mutations
)
{
receivedMutations
+
=
mutations
.
length
;
if
(
receivedMutations
>
=
2
)
{
view
.
inspector
.
walker
.
off
(
"
mutations
"
onWalkerMutations
)
;
r
(
)
;
}
}
)
;
}
)
;
info
(
"
Adding
name
"
+
name
)
;
editor
.
input
.
value
=
name
;
const
onNameAdded
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
await
onNameAdded
;
editor
=
inplaceEditor
(
view
.
styleDocument
.
activeElement
)
;
const
textProps
=
ruleEditor
.
rule
.
textProps
;
const
textProp
=
textProps
[
textProps
.
length
-
1
]
;
is
(
ruleEditor
.
rule
.
textProps
.
length
numOfProps
+
1
"
A
new
test
property
was
added
"
)
;
is
(
editor
inplaceEditor
(
textProp
.
editor
.
valueSpan
)
"
The
inplace
editor
appeared
for
the
value
"
)
;
info
(
"
Adding
value
"
+
value
)
;
const
onPreview
=
view
.
once
(
"
ruleview
-
changed
"
)
;
editor
.
input
.
value
=
value
;
view
.
debounce
.
flush
(
)
;
await
onPreview
;
const
onValueAdded
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
commitValueWith
{
}
view
.
styleWindow
)
;
await
onValueAdded
;
info
(
"
Waiting
for
DOM
mutations
in
case
the
property
was
added
to
the
element
style
"
)
;
await
onMutations
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
return
textProp
;
}
;
var
setProperty
=
async
function
(
view
textProp
value
blurNewProperty
=
true
)
{
await
focusEditableField
(
view
textProp
.
editor
.
valueSpan
)
;
const
onPreview
=
view
.
once
(
"
ruleview
-
changed
"
)
;
if
(
value
=
=
=
null
)
{
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
view
.
styleWindow
)
;
}
else
{
EventUtils
.
sendString
(
value
view
.
styleWindow
)
;
}
view
.
debounce
.
flush
(
)
;
await
onPreview
;
const
onValueDone
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
await
onValueDone
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
}
;
var
renameProperty
=
async
function
(
view
textProp
name
)
{
await
focusEditableField
(
view
textProp
.
editor
.
nameSpan
)
;
const
onNameDone
=
view
.
once
(
"
ruleview
-
changed
"
)
;
info
(
Rename
the
property
to
{
name
}
)
;
EventUtils
.
sendString
(
name
view
.
styleWindow
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
info
(
"
Wait
for
property
name
.
"
)
;
await
onNameDone
;
const
onValueDone
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_ESCAPE
"
{
}
view
.
styleWindow
)
;
info
(
"
Wait
for
property
value
.
"
)
;
await
onValueDone
;
}
;
var
removeProperty
=
async
function
(
view
textProp
blurNewProperty
=
true
)
{
await
focusEditableField
(
view
textProp
.
editor
.
nameSpan
)
;
const
onModifications
=
view
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Deleting
the
property
name
now
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
view
.
styleWindow
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
await
onModifications
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
}
;
var
togglePropStatus
=
async
function
(
view
textProp
)
{
const
onRuleViewRefreshed
=
view
.
once
(
"
ruleview
-
changed
"
)
;
textProp
.
editor
.
enable
.
click
(
)
;
await
onRuleViewRefreshed
;
}
;
async
function
reloadPage
(
inspector
testActor
)
{
const
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
await
testActor
.
reload
(
)
;
await
onNewRoot
;
await
inspector
.
markup
.
_waitForChildren
(
)
;
}
async
function
addNewRule
(
inspector
view
)
{
info
(
"
Adding
the
new
rule
using
the
button
"
)
;
view
.
addRuleButton
.
click
(
)
;
info
(
"
Waiting
for
rule
view
to
change
"
)
;
await
view
.
once
(
"
ruleview
-
changed
"
)
;
}
async
function
addNewRuleAndDismissEditor
(
inspector
view
expectedSelector
expectedIndex
)
{
await
addNewRule
(
inspector
view
)
;
info
(
"
Getting
the
new
rule
at
index
"
+
expectedIndex
)
;
const
ruleEditor
=
getRuleViewRuleEditor
(
view
expectedIndex
)
;
const
editor
=
ruleEditor
.
selectorText
.
ownerDocument
.
activeElement
;
is
(
editor
.
value
expectedSelector
"
The
editor
for
the
new
selector
has
the
correct
value
:
"
+
expectedSelector
)
;
info
(
"
Pressing
escape
to
leave
the
editor
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
is
(
ruleEditor
.
selectorText
.
textContent
expectedSelector
"
The
new
selector
has
the
correct
text
:
"
+
expectedSelector
)
;
}
async
function
sendKeysAndWaitForFocus
(
view
element
keys
)
{
const
onFocus
=
once
(
element
"
focus
"
true
)
;
for
(
const
key
of
keys
)
{
EventUtils
.
sendKey
(
key
view
.
styleWindow
)
;
}
await
onFocus
;
}
function
waitForStyleModification
(
inspector
)
{
return
new
Promise
(
function
(
resolve
)
{
function
checkForStyleModification
(
mutations
)
{
for
(
const
mutation
of
mutations
)
{
if
(
mutation
.
type
=
=
=
"
attributes
"
&
&
mutation
.
attributeName
=
=
=
"
style
"
)
{
inspector
.
off
(
"
markupmutation
"
checkForStyleModification
)
;
resolve
(
)
;
return
;
}
}
}
inspector
.
on
(
"
markupmutation
"
checkForStyleModification
)
;
}
)
;
}
async
function
clickSelectorIcon
(
icon
view
)
{
const
onToggled
=
view
.
once
(
"
ruleview
-
selectorhighlighter
-
toggled
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
icon
{
}
view
.
styleWindow
)
;
await
onToggled
;
}
async
function
toggleClassPanelCheckBox
(
view
name
)
{
info
(
Clicking
on
checkbox
for
class
{
name
}
)
;
const
checkBox
=
[
.
.
.
view
.
classPanel
.
querySelectorAll
(
"
[
type
=
checkbox
]
"
)
]
.
find
(
box
=
>
{
return
box
.
dataset
.
name
=
=
=
name
;
}
)
;
const
onMutation
=
view
.
inspector
.
once
(
"
markupmutation
"
)
;
checkBox
.
click
(
)
;
info
(
"
Waiting
for
a
markupmutation
as
a
result
of
toggling
this
class
"
)
;
await
onMutation
;
}
function
checkClassPanelContent
(
view
classes
)
{
const
checkBoxNodeList
=
view
.
classPanel
.
querySelectorAll
(
"
[
type
=
checkbox
]
"
)
;
is
(
checkBoxNodeList
.
length
classes
.
length
"
The
panel
contains
the
expected
number
of
checkboxes
"
)
;
for
(
let
i
=
0
;
i
<
classes
.
length
;
i
+
+
)
{
is
(
checkBoxNodeList
[
i
]
.
dataset
.
name
classes
[
i
]
.
name
Checkbox
{
i
}
has
the
right
class
name
)
;
is
(
checkBoxNodeList
[
i
]
.
checked
classes
[
i
]
.
state
Checkbox
{
i
}
has
the
right
state
)
;
}
}
async
function
openEyedropper
(
view
swatch
)
{
const
tooltip
=
view
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
tooltip
;
info
(
"
Click
on
the
swatch
"
)
;
const
onColorPickerReady
=
view
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
once
(
"
ready
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
swatch
{
}
swatch
.
ownerGlobal
)
;
await
onColorPickerReady
;
const
dropperButton
=
tooltip
.
container
.
querySelector
(
"
#
eyedropper
-
button
"
)
;
info
(
"
Click
on
the
eyedropper
icon
"
)
;
const
onOpened
=
tooltip
.
once
(
"
eyedropper
-
opened
"
)
;
dropperButton
.
click
(
)
;
await
onOpened
;
}
function
getPropertiesForRuleIndex
(
view
ruleIndex
)
{
const
declaration
=
new
Map
(
)
;
const
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
for
(
const
currProp
of
ruleEditor
.
rule
.
textProps
)
{
const
icon
=
currProp
.
editor
.
unusedState
;
const
unused
=
currProp
.
editor
.
element
.
classList
.
contains
(
"
unused
"
)
;
declaration
.
set
(
{
currProp
.
name
}
:
{
currProp
.
value
}
{
propertyName
:
currProp
.
name
propertyValue
:
currProp
.
value
icon
:
icon
data
:
currProp
.
isUsed
(
)
warning
:
unused
used
:
!
unused
}
)
;
}
return
declaration
;
}
async
function
toggleDeclaration
(
inspector
view
ruleIndex
declaration
)
{
const
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
const
[
[
name
value
]
]
=
Object
.
entries
(
declaration
)
;
let
textProp
=
null
;
for
(
const
currProp
of
ruleEditor
.
rule
.
textProps
)
{
if
(
currProp
.
name
=
=
=
name
&
&
currProp
.
value
=
=
=
value
)
{
textProp
=
currProp
;
break
;
}
}
const
dec
=
{
name
}
:
{
value
}
;
ok
(
textProp
Declaration
"
{
dec
}
"
found
)
;
const
newStatus
=
textProp
.
enabled
?
"
disabled
"
:
"
enabled
"
;
info
(
Toggling
declaration
"
{
dec
}
"
of
rule
{
ruleIndex
}
to
{
newStatus
}
)
;
await
togglePropStatus
(
view
textProp
)
;
info
(
"
Toggled
successfully
.
"
)
;
}
async
function
checkDeclarationIsInactive
(
view
ruleIndex
declaration
)
{
const
declarations
=
getPropertiesForRuleIndex
(
view
ruleIndex
)
;
const
[
[
name
value
]
]
=
Object
.
entries
(
declaration
)
;
const
dec
=
{
name
}
:
{
value
}
;
const
{
used
warning
}
=
declarations
.
get
(
dec
)
;
ok
(
!
used
"
{
dec
}
"
is
inactive
)
;
ok
(
warning
"
{
dec
}
"
has
a
warning
)
;
await
checkInteractiveTooltip
(
view
ruleIndex
declaration
)
;
}
function
checkDeclarationIsActive
(
view
ruleIndex
declaration
)
{
const
declarations
=
getPropertiesForRuleIndex
(
view
ruleIndex
)
;
const
[
[
name
value
]
]
=
Object
.
entries
(
declaration
)
;
const
dec
=
{
name
}
:
{
value
}
;
const
{
used
warning
}
=
declarations
.
get
(
dec
)
;
ok
(
used
{
dec
}
is
active
)
;
ok
(
!
warning
{
dec
}
has
no
warning
)
;
}
async
function
checkInteractiveTooltip
(
view
ruleIndex
declaration
)
{
const
declarations
=
getPropertiesForRuleIndex
(
view
ruleIndex
)
;
const
[
[
name
value
]
]
=
Object
.
entries
(
declaration
)
;
const
dec
=
{
name
}
:
{
value
}
;
const
{
icon
data
}
=
declarations
.
get
(
dec
)
;
const
tooltip
=
view
.
tooltips
.
getTooltip
(
"
interactiveTooltip
"
)
;
const
inactiveCssTooltipHelper
=
view
.
tooltips
.
inactiveCssTooltipHelper
;
const
template
=
inactiveCssTooltipHelper
.
getTemplate
(
data
tooltip
)
;
const
{
doc
}
=
tooltip
;
await
doc
.
l10n
.
translateFragment
(
template
)
;
const
expected
=
template
.
firstElementChild
.
outerHTML
;
const
onTooltipReady
=
tooltip
.
once
(
"
shown
"
)
;
await
view
.
tooltips
.
onInteractiveTooltipTargetHover
(
icon
)
;
tooltip
.
show
(
icon
)
;
await
onTooltipReady
;
const
actual
=
tooltip
.
panel
.
firstElementChild
.
outerHTML
;
const
onTooltipHidden
=
tooltip
.
once
(
"
hidden
"
)
;
tooltip
.
hide
(
)
;
await
onTooltipHidden
;
is
(
actual
expected
"
Tooltip
contains
the
correct
value
.
"
)
;
}
async
function
runInactiveCSSTests
(
view
inspector
tests
)
{
for
(
const
test
of
tests
)
{
if
(
test
.
selector
)
{
await
selectNode
(
test
.
selector
inspector
)
;
}
if
(
test
.
activeDeclarations
)
{
info
(
"
Checking
whether
declarations
are
marked
as
used
.
"
)
;
for
(
const
activeDeclarations
of
test
.
activeDeclarations
)
{
for
(
const
[
name
value
]
of
Object
.
entries
(
activeDeclarations
.
declarations
)
)
{
checkDeclarationIsActive
(
view
activeDeclarations
.
ruleIndex
{
[
name
]
:
value
}
)
;
}
}
}
if
(
test
.
inactiveDeclarations
)
{
info
(
"
Checking
that
declarations
are
unused
and
have
a
warning
.
"
)
;
for
(
const
inactiveDeclaration
of
test
.
inactiveDeclarations
)
{
await
checkDeclarationIsInactive
(
view
inactiveDeclaration
.
ruleIndex
inactiveDeclaration
.
declaration
)
;
}
}
}
}
function
getPseudoClassCheckbox
(
view
pseudo
)
{
return
view
.
pseudoClassCheckboxes
.
filter
(
checkbox
=
>
checkbox
.
value
=
=
=
pseudo
)
[
0
]
;
}
function
checkCSSVariableOutput
(
view
selector
propertyName
expectedClassName
expectedDatasetValue
)
{
const
target
=
getRuleViewProperty
(
view
selector
propertyName
)
.
valueSpan
.
querySelector
(
.
{
expectedClassName
}
)
;
ok
(
target
"
The
target
element
should
exist
"
)
;
is
(
target
.
dataset
.
variable
expectedDatasetValue
)
;
}
