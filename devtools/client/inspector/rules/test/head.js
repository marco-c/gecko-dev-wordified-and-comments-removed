"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
ROOT_TEST_DIR
=
getRootDirectory
(
gTestPath
)
;
const
FRAME_SCRIPT_URL
=
ROOT_TEST_DIR
+
"
doc_frame_script
.
js
"
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
"
chrome
:
/
/
devtools
-
shared
/
locale
/
styleinspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
var
_addTab
=
addTab
;
addTab
=
function
(
url
)
{
return
_addTab
(
url
)
.
then
(
tab
=
>
{
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
let
browser
=
tab
.
linkedBrowser
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
return
tab
;
}
)
;
}
;
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
def
=
defer
(
)
;
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
def
.
resolve
(
msg
.
data
)
;
}
)
;
return
def
.
promise
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
function
*
getComputedStyleProperty
(
selector
pseudo
propName
)
{
return
yield
executeInContent
(
"
Test
:
GetComputedStylePropertyValue
"
{
selector
pseudo
name
:
propName
}
)
;
}
function
getStyle
(
testActor
selector
propName
)
{
return
testActor
.
eval
(
content
.
document
.
querySelector
(
"
{
selector
}
"
)
.
style
.
getPropertyValue
(
"
{
propName
}
"
)
;
)
;
}
function
*
waitForComputedStyleProperty
(
selector
pseudo
name
expected
)
{
return
yield
executeInContent
(
"
Test
:
WaitForComputedStylePropertyValue
"
{
selector
pseudo
expected
name
}
)
;
}
var
focusEditableField
=
Task
.
async
(
function
*
(
ruleView
editable
xOffset
=
1
yOffset
=
1
options
=
{
}
)
{
let
onFocus
=
once
(
editable
.
parentNode
"
focus
"
true
)
;
info
(
"
Clicking
on
editable
field
to
turn
to
edit
mode
"
)
;
EventUtils
.
synthesizeMouse
(
editable
xOffset
yOffset
options
editable
.
ownerDocument
.
defaultView
)
;
yield
onFocus
;
info
(
"
Editable
field
gained
focus
returning
the
input
field
now
"
)
;
let
onEdit
=
inplaceEditor
(
editable
.
ownerDocument
.
activeElement
)
;
return
onEdit
;
}
)
;
function
*
hideTooltipAndWaitForRuleViewChanged
(
editorTooltip
view
)
{
let
onModified
=
view
.
once
(
"
ruleview
-
changed
"
)
;
let
onHidden
=
editorTooltip
.
tooltip
.
once
(
"
hidden
"
)
;
editorTooltip
.
hide
(
)
;
yield
onModified
;
yield
onHidden
;
}
var
waitForSuccess
=
Task
.
async
(
function
*
(
validatorFn
desc
=
"
untitled
"
)
{
let
i
=
0
;
while
(
true
)
{
info
(
"
Checking
:
"
+
desc
)
;
if
(
yield
validatorFn
(
)
)
{
ok
(
true
"
Success
:
"
+
desc
)
;
break
;
}
i
+
+
;
if
(
i
>
10
)
{
ok
(
false
"
Failure
:
"
+
desc
)
;
break
;
}
yield
new
Promise
(
r
=
>
setTimeout
(
r
200
)
)
;
}
}
)
;
function
getRuleViewRule
(
view
selectorText
)
{
let
rule
;
for
(
let
r
of
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
"
)
)
{
let
selector
=
r
.
querySelector
(
"
.
ruleview
-
selectorcontainer
"
+
"
.
ruleview
-
selector
-
matched
"
)
;
if
(
selector
&
&
selector
.
textContent
=
=
=
selectorText
)
{
rule
=
r
;
break
;
}
}
return
rule
;
}
function
getRuleViewProperty
(
view
selectorText
propertyName
)
{
let
prop
;
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
if
(
rule
)
{
for
(
let
p
of
rule
.
querySelectorAll
(
"
.
ruleview
-
property
"
)
)
{
let
nameSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
;
let
valueSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
;
if
(
nameSpan
.
textContent
=
=
=
propertyName
)
{
prop
=
{
nameSpan
:
nameSpan
valueSpan
:
valueSpan
}
;
break
;
}
}
}
return
prop
;
}
function
getRuleViewPropertyValue
(
view
selectorText
propertyName
)
{
return
getRuleViewProperty
(
view
selectorText
propertyName
)
.
valueSpan
.
textContent
;
}
function
getRuleViewSelector
(
view
selectorText
)
{
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
return
rule
.
querySelector
(
"
.
ruleview
-
selector
.
ruleview
-
selector
-
matched
"
)
;
}
function
getRuleViewSelectorHighlighterIcon
(
view
selectorText
)
{
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
return
rule
.
querySelector
(
"
.
ruleview
-
selectorhighlighter
"
)
;
}
var
simulateColorPickerChange
=
Task
.
async
(
function
*
(
ruleView
colorPicker
newRgba
expectedChange
)
{
let
onComputedStyleChanged
;
if
(
expectedChange
)
{
let
{
selector
name
value
}
=
expectedChange
;
onComputedStyleChanged
=
waitForComputedStyleProperty
(
selector
null
name
value
)
;
}
let
onRuleViewChanged
=
ruleView
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
let
spectrum
=
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
info
(
"
Waiting
for
rule
-
view
to
update
"
)
;
yield
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
yield
onComputedStyleChanged
;
}
}
)
;
var
openColorPickerAndSelectColor
=
Task
.
async
(
function
*
(
view
ruleIndex
propIndex
newRgba
expectedChange
)
{
let
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
let
propEditor
=
ruleEditor
.
rule
.
textProps
[
propIndex
]
.
editor
;
let
swatch
=
propEditor
.
valueSpan
.
querySelector
(
"
.
ruleview
-
colorswatch
"
)
;
let
cPicker
=
view
.
tooltips
.
colorPicker
;
info
(
"
Opening
the
colorpicker
by
clicking
the
color
swatch
"
)
;
let
onColorPickerReady
=
cPicker
.
once
(
"
ready
"
)
;
swatch
.
click
(
)
;
yield
onColorPickerReady
;
yield
simulateColorPickerChange
(
view
cPicker
newRgba
expectedChange
)
;
return
{
propEditor
swatch
cPicker
}
;
}
)
;
var
openCubicBezierAndChangeCoords
=
Task
.
async
(
function
*
(
view
ruleIndex
propIndex
coords
expectedChange
)
{
let
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
let
propEditor
=
ruleEditor
.
rule
.
textProps
[
propIndex
]
.
editor
;
let
swatch
=
propEditor
.
valueSpan
.
querySelector
(
"
.
ruleview
-
bezierswatch
"
)
;
let
bezierTooltip
=
view
.
tooltips
.
cubicBezier
;
info
(
"
Opening
the
cubicBezier
by
clicking
the
swatch
"
)
;
let
onBezierWidgetReady
=
bezierTooltip
.
once
(
"
ready
"
)
;
swatch
.
click
(
)
;
yield
onBezierWidgetReady
;
let
widget
=
yield
bezierTooltip
.
widget
;
info
(
"
Simulating
a
change
of
curve
in
the
widget
"
)
;
let
onRuleViewChanged
=
view
.
once
(
"
ruleview
-
changed
"
)
;
widget
.
coordinates
=
coords
;
yield
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
let
{
selector
name
value
}
=
expectedChange
;
yield
waitForComputedStyleProperty
(
selector
null
name
value
)
;
}
return
{
propEditor
swatch
bezierTooltip
}
;
}
)
;
function
getRuleViewLinkByIndex
(
view
index
)
{
let
links
=
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
-
source
"
)
;
return
links
[
index
]
;
}
function
getRuleViewLinkTextByIndex
(
view
index
)
{
let
link
=
getRuleViewLinkByIndex
(
view
index
)
;
return
link
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
.
value
;
}
var
addProperty
=
Task
.
async
(
function
*
(
view
ruleIndex
name
value
commitValueWith
=
"
VK_RETURN
"
blurNewProperty
=
true
)
{
info
(
"
Adding
new
property
"
+
name
+
"
:
"
+
value
+
"
to
rule
"
+
ruleIndex
)
;
let
ruleEditor
=
getRuleViewRuleEditor
(
view
ruleIndex
)
;
let
editor
=
yield
focusNewRuleViewProperty
(
ruleEditor
)
;
let
numOfProps
=
ruleEditor
.
rule
.
textProps
.
length
;
info
(
"
Adding
name
"
+
name
)
;
editor
.
input
.
value
=
name
;
let
onNameAdded
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
yield
onNameAdded
;
editor
=
inplaceEditor
(
view
.
styleDocument
.
activeElement
)
;
let
textProps
=
ruleEditor
.
rule
.
textProps
;
let
textProp
=
textProps
[
textProps
.
length
-
1
]
;
is
(
ruleEditor
.
rule
.
textProps
.
length
numOfProps
+
1
"
A
new
test
property
was
added
"
)
;
is
(
editor
inplaceEditor
(
textProp
.
editor
.
valueSpan
)
"
The
inplace
editor
appeared
for
the
value
"
)
;
info
(
"
Adding
value
"
+
value
)
;
let
onPreview
=
view
.
once
(
"
ruleview
-
changed
"
)
;
editor
.
input
.
value
=
value
;
view
.
throttle
.
flush
(
)
;
yield
onPreview
;
let
onValueAdded
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
commitValueWith
{
}
view
.
styleWindow
)
;
yield
onValueAdded
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
return
textProp
;
}
)
;
var
setProperty
=
Task
.
async
(
function
*
(
view
textProp
value
blurNewProperty
=
true
)
{
yield
focusEditableField
(
view
textProp
.
editor
.
valueSpan
)
;
let
onPreview
=
view
.
once
(
"
ruleview
-
changed
"
)
;
if
(
value
=
=
=
null
)
{
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
view
.
styleWindow
)
;
}
else
{
EventUtils
.
sendString
(
value
view
.
styleWindow
)
;
}
view
.
throttle
.
flush
(
)
;
yield
onPreview
;
let
onValueDone
=
view
.
once
(
"
ruleview
-
changed
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
yield
onValueDone
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
}
)
;
var
removeProperty
=
Task
.
async
(
function
*
(
view
textProp
blurNewProperty
=
true
)
{
yield
focusEditableField
(
view
textProp
.
editor
.
nameSpan
)
;
let
onModifications
=
view
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Deleting
the
property
name
now
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
view
.
styleWindow
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
view
.
styleWindow
)
;
yield
onModifications
;
if
(
blurNewProperty
)
{
view
.
styleDocument
.
activeElement
.
blur
(
)
;
}
}
)
;
var
togglePropStatus
=
Task
.
async
(
function
*
(
view
textProp
)
{
let
onRuleViewRefreshed
=
view
.
once
(
"
ruleview
-
changed
"
)
;
textProp
.
editor
.
enable
.
click
(
)
;
yield
onRuleViewRefreshed
;
}
)
;
var
focusNewRuleViewProperty
=
Task
.
async
(
function
*
(
ruleEditor
)
{
info
(
"
Clicking
on
a
close
ruleEditor
brace
to
start
editing
a
new
property
"
)
;
ruleEditor
.
closeBrace
.
scrollIntoView
(
)
;
let
editor
=
yield
focusEditableField
(
ruleEditor
.
ruleView
ruleEditor
.
closeBrace
)
;
is
(
inplaceEditor
(
ruleEditor
.
newPropSpan
)
editor
"
Focused
editor
is
the
new
property
editor
.
"
)
;
return
editor
;
}
)
;
var
createNewRuleViewProperty
=
Task
.
async
(
function
*
(
ruleEditor
inputValue
)
{
info
(
"
Creating
a
new
property
editor
"
)
;
let
editor
=
yield
focusNewRuleViewProperty
(
ruleEditor
)
;
info
(
"
Entering
the
value
"
+
inputValue
)
;
editor
.
input
.
value
=
inputValue
;
info
(
"
Submitting
the
new
value
and
waiting
for
value
field
focus
"
)
;
let
onFocus
=
once
(
ruleEditor
.
element
"
focus
"
true
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
ruleEditor
.
element
.
ownerDocument
.
defaultView
)
;
yield
onFocus
;
}
)
;
var
setSearchFilter
=
Task
.
async
(
function
*
(
view
searchValue
)
{
info
(
"
Setting
filter
text
to
\
"
"
+
searchValue
+
"
\
"
"
)
;
let
win
=
view
.
styleWindow
;
let
searchField
=
view
.
searchField
;
searchField
.
focus
(
)
;
synthesizeKeys
(
searchValue
win
)
;
yield
view
.
inspector
.
once
(
"
ruleview
-
filtered
"
)
;
}
)
;
function
*
reloadPage
(
inspector
testActor
)
{
let
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
yield
testActor
.
reload
(
)
;
yield
onNewRoot
;
yield
inspector
.
markup
.
_waitForChildren
(
)
;
}
function
*
addNewRule
(
inspector
view
)
{
info
(
"
Adding
the
new
rule
using
the
button
"
)
;
view
.
addRuleButton
.
click
(
)
;
info
(
"
Waiting
for
rule
view
to
change
"
)
;
yield
view
.
once
(
"
ruleview
-
changed
"
)
;
}
function
*
addNewRuleAndDismissEditor
(
inspector
view
expectedSelector
expectedIndex
)
{
yield
addNewRule
(
inspector
view
)
;
info
(
"
Getting
the
new
rule
at
index
"
+
expectedIndex
)
;
let
ruleEditor
=
getRuleViewRuleEditor
(
view
expectedIndex
)
;
let
editor
=
ruleEditor
.
selectorText
.
ownerDocument
.
activeElement
;
is
(
editor
.
value
expectedSelector
"
The
editor
for
the
new
selector
has
the
correct
value
:
"
+
expectedSelector
)
;
info
(
"
Pressing
escape
to
leave
the
editor
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_ESCAPE
"
{
}
)
;
is
(
ruleEditor
.
selectorText
.
textContent
expectedSelector
"
The
new
selector
has
the
correct
text
:
"
+
expectedSelector
)
;
}
function
*
sendKeysAndWaitForFocus
(
view
element
keys
)
{
let
onFocus
=
once
(
element
"
focus
"
true
)
;
for
(
let
key
of
keys
)
{
EventUtils
.
sendKey
(
key
view
.
styleWindow
)
;
}
yield
onFocus
;
}
function
openStyleContextMenuAndGetAllItems
(
view
target
)
{
let
menu
=
view
.
_contextmenu
.
_openMenu
(
{
target
:
target
}
)
;
let
allItems
=
[
]
.
concat
.
apply
(
[
]
menu
.
items
.
map
(
function
addItem
(
item
)
{
if
(
item
.
submenu
)
{
return
addItem
(
item
.
submenu
.
items
)
;
}
return
item
;
}
)
)
;
return
allItems
;
}
function
waitForStyleModification
(
inspector
)
{
return
new
Promise
(
function
(
resolve
)
{
function
checkForStyleModification
(
name
mutations
)
{
for
(
let
mutation
of
mutations
)
{
if
(
mutation
.
type
=
=
=
"
attributes
"
&
&
mutation
.
attributeName
=
=
=
"
style
"
)
{
inspector
.
off
(
"
markupmutation
"
checkForStyleModification
)
;
resolve
(
)
;
return
;
}
}
}
inspector
.
on
(
"
markupmutation
"
checkForStyleModification
)
;
}
)
;
}
