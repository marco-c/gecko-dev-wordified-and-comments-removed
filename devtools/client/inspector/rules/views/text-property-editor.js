"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
l10n
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
InplaceEditor
editableField
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
createChild
appendText
advanceValidate
blurOnMultipleProperties
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
throttle
}
=
require
(
"
devtools
/
shared
/
throttle
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
openContentLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
parseDeclarations
"
"
parseSingleValue
"
]
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
true
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
INLINE_COMPATIBILITY_WARNING_PREF
=
"
devtools
.
inspector
.
ruleview
.
inline
-
compatibility
-
warning
.
enabled
"
;
const
SHARED_SWATCH_CLASS
=
"
ruleview
-
swatch
"
;
const
COLOR_SWATCH_CLASS
=
"
ruleview
-
colorswatch
"
;
const
BEZIER_SWATCH_CLASS
=
"
ruleview
-
bezierswatch
"
;
const
FILTER_SWATCH_CLASS
=
"
ruleview
-
filterswatch
"
;
const
ANGLE_SWATCH_CLASS
=
"
ruleview
-
angleswatch
"
;
const
FONT_FAMILY_CLASS
=
"
ruleview
-
font
-
family
"
;
const
SHAPE_SWATCH_CLASS
=
"
ruleview
-
shapeswatch
"
;
const
ACTIONABLE_ELEMENTS_SELECTORS
=
[
.
{
COLOR_SWATCH_CLASS
}
.
{
BEZIER_SWATCH_CLASS
}
.
{
FILTER_SWATCH_CLASS
}
.
{
ANGLE_SWATCH_CLASS
}
"
a
"
]
;
const
SLOW_DRAGGING_SPEED
=
0
.
1
;
const
DEFAULT_DRAGGING_SPEED
=
1
;
const
FAST_DRAGGING_SPEED
=
10
;
const
DRAGGING_DEADZONE_DISTANCE
=
5
;
const
DRAGGABLE_VALUE_CLASSNAME
=
"
ruleview
-
propertyvalue
-
draggable
"
;
const
IS_DRAGGING_CLASSNAME
=
"
ruleview
-
propertyvalue
-
dragging
"
;
const
GENERIC_FONT_FAMILIES
=
[
"
serif
"
"
sans
-
serif
"
"
cursive
"
"
fantasy
"
"
monospace
"
"
system
-
ui
"
]
;
function
TextPropertyEditor
(
ruleEditor
property
)
{
this
.
ruleEditor
=
ruleEditor
;
this
.
ruleView
=
this
.
ruleEditor
.
ruleView
;
this
.
cssProperties
=
this
.
ruleView
.
cssProperties
;
this
.
doc
=
this
.
ruleEditor
.
doc
;
this
.
popup
=
this
.
ruleView
.
popup
;
this
.
prop
=
property
;
this
.
prop
.
editor
=
this
;
this
.
browserWindow
=
this
.
doc
.
defaultView
.
top
;
this
.
_populatedComputed
=
false
;
this
.
_hasPendingClick
=
false
;
this
.
_clickedElementOptions
=
null
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
_isDragging
=
false
;
this
.
_hasDragged
=
false
;
this
.
_draggingController
=
null
;
this
.
_draggingValueCache
=
null
;
this
.
getGridlineNames
=
this
.
getGridlineNames
.
bind
(
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
updatePropertyState
=
this
.
updatePropertyState
.
bind
(
this
)
;
this
.
_onDraggablePreferenceChanged
=
this
.
_onDraggablePreferenceChanged
.
bind
(
this
)
;
this
.
_onEnableChanged
=
this
.
_onEnableChanged
.
bind
(
this
)
;
this
.
_onEnableClicked
=
this
.
_onEnableClicked
.
bind
(
this
)
;
this
.
_onExpandClicked
=
this
.
_onExpandClicked
.
bind
(
this
)
;
this
.
_onNameDone
=
this
.
_onNameDone
.
bind
(
this
)
;
this
.
_onStartEditing
=
this
.
_onStartEditing
.
bind
(
this
)
;
this
.
_onSwatchCommit
=
this
.
_onSwatchCommit
.
bind
(
this
)
;
this
.
_onSwatchPreview
=
this
.
_onSwatchPreview
.
bind
(
this
)
;
this
.
_onSwatchRevert
=
this
.
_onSwatchRevert
.
bind
(
this
)
;
this
.
_onValidate
=
this
.
ruleView
.
debounce
(
this
.
_previewValue
10
this
)
;
this
.
_onValueDone
=
this
.
_onValueDone
.
bind
(
this
)
;
this
.
_draggingOnMouseDown
=
this
.
_draggingOnMouseDown
.
bind
(
this
)
;
this
.
_draggingOnMouseMove
=
throttle
(
this
.
_draggingOnMouseMove
30
this
)
;
this
.
_draggingOnMouseUp
=
this
.
_draggingOnMouseUp
.
bind
(
this
)
;
this
.
_draggingOnKeydown
=
this
.
_draggingOnKeydown
.
bind
(
this
)
;
this
.
_create
(
)
;
this
.
update
(
)
;
}
TextPropertyEditor
.
prototype
=
{
get
editing
(
)
{
return
(
!
!
(
this
.
nameSpan
.
inplaceEditor
|
|
this
.
valueSpan
.
inplaceEditor
|
|
this
.
ruleView
.
tooltips
.
isEditing
)
|
|
this
.
popup
.
isOpen
)
;
}
get
rule
(
)
{
return
this
.
prop
.
rule
;
}
get
_DRAGGING_DEADZONE_DISTANCE
(
)
{
return
DRAGGING_DEADZONE_DISTANCE
;
}
_create
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
this
.
element
.
classList
.
add
(
"
ruleview
-
property
"
)
;
this
.
element
.
dataset
.
declarationId
=
this
.
prop
.
id
;
this
.
element
.
_textPropertyEditor
=
this
;
this
.
container
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
propertycontainer
"
}
)
;
this
.
enable
=
createChild
(
this
.
container
"
input
"
{
type
:
"
checkbox
"
class
:
"
ruleview
-
enableproperty
"
"
aria
-
labelledby
"
:
this
.
prop
.
id
tabindex
:
"
-
1
"
}
)
;
this
.
nameContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
this
.
nameSpan
=
createChild
(
this
.
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
id
:
this
.
prop
.
id
}
)
;
appendText
(
this
.
nameContainer
"
:
"
)
;
this
.
expander
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
expander
theme
-
twisty
"
}
)
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onExpandClicked
true
)
;
this
.
valueContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
this
.
valueSpan
=
createChild
(
this
.
valueContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
this
.
valueSpan
.
textProperty
=
this
.
prop
;
this
.
nameSpan
.
textProperty
=
this
.
prop
;
appendText
(
this
.
valueContainer
"
;
"
)
;
this
.
warning
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
warning
"
hidden
:
"
"
title
:
l10n
(
"
rule
.
warning
.
title
"
)
}
)
;
this
.
unusedState
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
unused
-
warning
"
hidden
:
"
"
}
)
;
const
inlineCompatibilityWarningEnabled
=
Services
.
prefs
.
getBoolPref
(
INLINE_COMPATIBILITY_WARNING_PREF
)
;
if
(
inlineCompatibilityWarningEnabled
)
{
this
.
compatibilityState
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
compatibility
-
warning
"
hidden
:
"
"
}
)
;
}
this
.
filterProperty
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
overridden
-
rule
-
filter
"
hidden
:
"
"
title
:
l10n
(
"
rule
.
filterProperty
.
title
"
)
}
)
;
this
.
filterProperty
.
addEventListener
(
"
click
"
event
=
>
{
this
.
ruleEditor
.
ruleView
.
setFilterStyles
(
"
"
+
this
.
prop
.
name
+
"
"
)
;
event
.
stopPropagation
(
)
;
}
)
;
this
.
computed
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
computedlist
"
}
)
;
this
.
shorthandOverridden
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
overridden
-
items
"
}
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
this
.
enable
.
addEventListener
(
"
click
"
this
.
_onEnableClicked
true
)
;
this
.
enable
.
addEventListener
(
"
change
"
this
.
_onEnableChanged
true
)
;
this
.
nameContainer
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
nameContainer
)
{
this
.
nameSpan
.
click
(
)
;
}
}
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
nameSpan
done
:
this
.
_onNameDone
destroy
:
this
.
updatePropertyState
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
popup
cssProperties
:
this
.
cssProperties
}
)
;
this
.
nameContainer
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
cssProperties
)
)
;
this
.
valueContainer
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
valueContainer
)
{
this
.
valueSpan
.
click
(
)
;
}
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mousedown
"
event
=
>
{
const
clickedEl
=
event
.
target
;
if
(
clickedEl
=
=
=
this
.
valueSpan
)
{
return
;
}
this
.
_hasPendingClick
=
true
;
const
matchedSelector
=
ACTIONABLE_ELEMENTS_SELECTORS
.
find
(
selector
=
>
clickedEl
.
matches
(
selector
)
)
;
if
(
matchedSelector
)
{
const
similarElements
=
[
.
.
.
this
.
valueSpan
.
querySelectorAll
(
matchedSelector
)
]
;
this
.
_clickedElementOptions
=
{
selector
:
matchedSelector
index
:
similarElements
.
indexOf
(
clickedEl
)
}
;
}
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mouseup
"
event
=
>
{
if
(
this
.
_hasDragged
)
{
return
;
}
this
.
_clickedElementOptions
=
null
;
this
.
_hasPendingClick
=
false
;
}
)
;
this
.
valueSpan
.
addEventListener
(
"
click
"
event
=
>
{
const
target
=
event
.
target
;
if
(
target
.
nodeName
=
=
=
"
a
"
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
openContentLink
(
target
.
href
)
;
}
}
)
;
this
.
ruleView
.
on
(
"
draggable
-
preference
-
updated
"
this
.
_onDraggablePreferenceChanged
)
;
if
(
this
.
_isDraggableProperty
(
this
.
prop
)
)
{
this
.
_addDraggingCapability
(
)
;
}
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
valueSpan
done
:
this
.
_onValueDone
destroy
:
this
.
update
validate
:
this
.
_onValidate
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
this
.
prop
defaultIncrement
:
this
.
prop
.
name
=
=
=
"
opacity
"
?
0
.
1
:
1
popup
:
this
.
popup
multiline
:
true
maxWidth
:
(
)
=
>
this
.
container
.
getBoundingClientRect
(
)
.
width
cssProperties
:
this
.
cssProperties
cssVariables
:
this
.
rule
.
elementStyle
.
variablesMap
.
get
(
this
.
rule
.
pseudoElement
)
|
|
[
]
getGridLineNames
:
this
.
getGridlineNames
showSuggestCompletionOnEmpty
:
true
}
)
;
}
}
async
getGridlineNames
(
)
{
const
gridLineNames
=
{
cols
:
[
]
rows
:
[
]
}
;
const
layoutInspector
=
await
this
.
ruleView
.
inspector
.
walker
.
getLayoutInspector
(
)
;
const
gridFront
=
await
layoutInspector
.
getCurrentGrid
(
this
.
ruleView
.
inspector
.
selection
.
nodeFront
)
;
if
(
gridFront
)
{
const
gridFragments
=
gridFront
.
gridFragments
;
for
(
const
gridFragment
of
gridFragments
)
{
for
(
const
rowLine
of
gridFragment
.
rows
.
lines
)
{
let
gridArea
;
for
(
const
name
of
rowLine
.
names
)
{
const
rowLineName
=
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
start
"
)
)
|
|
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
end
"
)
)
;
gridArea
=
gridFragment
.
areas
.
find
(
area
=
>
area
.
name
=
=
=
rowLineName
)
;
if
(
rowLine
.
type
=
=
=
"
implicit
"
&
&
gridArea
&
&
gridArea
.
type
=
=
=
"
implicit
"
)
{
continue
;
}
gridLineNames
.
rows
.
push
(
name
)
;
}
}
for
(
const
colLine
of
gridFragment
.
cols
.
lines
)
{
let
gridArea
;
for
(
const
name
of
colLine
.
names
)
{
const
colLineName
=
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
start
"
)
)
|
|
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
end
"
)
)
;
gridArea
=
gridFragment
.
areas
.
find
(
area
=
>
area
.
name
=
=
=
colLineName
)
;
if
(
colLine
.
type
=
=
=
"
implicit
"
&
&
gridArea
&
&
gridArea
.
type
=
=
=
"
implicit
"
)
{
continue
;
}
gridLineNames
.
cols
.
push
(
name
)
;
}
}
}
}
this
.
ruleView
.
inspector
.
emit
(
"
grid
-
line
-
names
-
updated
"
)
;
return
gridLineNames
;
}
get
sheetHref
(
)
{
const
domRule
=
this
.
rule
.
domRule
;
if
(
domRule
)
{
return
domRule
.
href
|
|
domRule
.
nodeHref
;
}
return
undefined
;
}
update
(
)
{
if
(
this
.
ruleView
.
isDestroyed
)
{
return
;
}
this
.
updatePropertyState
(
)
;
const
name
=
this
.
prop
.
name
;
this
.
nameSpan
.
textContent
=
name
;
const
store
=
this
.
rule
.
elementStyle
.
store
;
let
val
=
store
.
userProperties
.
getProperty
(
this
.
rule
.
domRule
name
this
.
prop
.
value
)
;
if
(
this
.
prop
.
priority
)
{
val
+
=
"
!
"
+
this
.
prop
.
priority
;
}
const
propDirty
=
store
.
userProperties
.
contains
(
this
.
rule
.
domRule
name
)
;
if
(
propDirty
)
{
this
.
element
.
setAttribute
(
"
dirty
"
"
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
dirty
"
)
;
}
const
outputParser
=
this
.
ruleView
.
_outputParser
;
const
parserOptions
=
{
angleClass
:
"
ruleview
-
angle
"
angleSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
ANGLE_SWATCH_CLASS
bezierClass
:
"
ruleview
-
bezier
"
bezierSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
BEZIER_SWATCH_CLASS
colorClass
:
"
ruleview
-
color
"
colorSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
COLOR_SWATCH_CLASS
filterClass
:
"
ruleview
-
filter
"
filterSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
FILTER_SWATCH_CLASS
flexClass
:
"
ruleview
-
flex
js
-
toggle
-
flexbox
-
highlighter
"
gridClass
:
"
ruleview
-
grid
js
-
toggle
-
grid
-
highlighter
"
shapeClass
:
"
ruleview
-
shape
"
shapeSwatchClass
:
SHAPE_SWATCH_CLASS
defaultColorType
:
!
propDirty
urlClass
:
"
theme
-
link
"
fontFamilyClass
:
FONT_FAMILY_CLASS
baseURI
:
this
.
sheetHref
unmatchedVariableClass
:
"
ruleview
-
unmatched
-
variable
"
matchedVariableClass
:
"
ruleview
-
variable
"
getVariableValue
:
varName
=
>
this
.
rule
.
elementStyle
.
getVariable
(
varName
this
.
rule
.
pseudoElement
)
}
;
const
frag
=
outputParser
.
parseCssProperty
(
name
val
parserOptions
)
;
if
(
!
this
.
committed
)
{
this
.
committed
=
{
name
value
:
frag
.
textContent
priority
:
this
.
prop
.
priority
}
;
}
let
focusedElSelector
=
null
;
if
(
this
.
valueSpan
.
contains
(
this
.
doc
.
activeElement
)
)
{
focusedElSelector
=
findCssSelector
(
this
.
doc
.
activeElement
)
;
}
this
.
valueSpan
.
innerHTML
=
"
"
;
this
.
valueSpan
.
appendChild
(
frag
)
;
this
.
ruleView
.
emit
(
"
property
-
value
-
updated
"
{
rule
:
this
.
prop
.
rule
property
:
name
value
:
val
}
)
;
const
fontFamilySpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
FONT_FAMILY_CLASS
)
;
if
(
fontFamilySpans
.
length
&
&
this
.
prop
.
enabled
&
&
!
this
.
prop
.
overridden
)
{
this
.
rule
.
elementStyle
.
getUsedFontFamilies
(
)
.
then
(
families
=
>
{
const
usedFontFamilies
=
families
.
map
(
font
=
>
font
.
toLowerCase
(
)
)
;
let
foundMatchingFamily
=
false
;
let
firstGenericSpan
=
null
;
for
(
const
span
of
fontFamilySpans
)
{
const
authoredFont
=
span
.
textContent
.
toLowerCase
(
)
;
if
(
!
firstGenericSpan
&
&
GENERIC_FONT_FAMILIES
.
includes
(
authoredFont
)
)
{
firstGenericSpan
=
span
;
}
if
(
usedFontFamilies
.
includes
(
authoredFont
)
)
{
span
.
classList
.
add
(
"
used
-
font
"
)
;
foundMatchingFamily
=
true
;
}
}
if
(
!
foundMatchingFamily
&
&
firstGenericSpan
)
{
firstGenericSpan
.
classList
.
add
(
"
used
-
font
"
)
;
}
this
.
ruleView
.
emit
(
"
font
-
highlighted
"
this
.
valueSpan
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
"
Could
not
get
the
list
of
font
families
"
e
)
)
;
}
this
.
_colorSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
COLOR_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
colorSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
span
.
dataset
.
propertyName
=
this
.
nameSpan
.
textContent
;
}
}
this
.
_bezierSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
BEZIER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
_bezierSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
cubicBezier
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
bezierSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
const
span
=
this
.
valueSpan
.
querySelector
(
"
.
"
+
FILTER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
if
(
span
)
{
parserOptions
.
filterSwatch
=
true
;
this
.
ruleView
.
tooltips
.
getTooltip
(
"
filterEditor
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
outputParser
parserOptions
)
;
const
title
=
l10n
(
"
rule
.
filterSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
this
.
angleSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
ANGLE_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
angleSpan
of
this
.
angleSwatchSpans
)
{
angleSpan
.
on
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
const
title
=
l10n
(
"
rule
.
angleSwatch
.
tooltip
"
)
;
angleSpan
.
setAttribute
(
"
title
"
title
)
;
}
}
const
nodeFront
=
this
.
ruleView
.
inspector
.
selection
.
nodeFront
;
const
flexToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
flex
"
)
;
if
(
flexToggle
)
{
flexToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
flexToggle
.
tooltip
"
)
)
;
flexToggle
.
classList
.
toggle
(
"
active
"
this
.
ruleView
.
inspector
.
highlighters
.
getNodeForActiveHighlighter
(
this
.
ruleView
.
inspector
.
highlighters
.
TYPES
.
FLEXBOX
)
=
=
=
nodeFront
)
;
}
const
gridToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
grid
"
)
;
if
(
gridToggle
)
{
gridToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
gridToggle
.
tooltip
"
)
)
;
gridToggle
.
classList
.
toggle
(
"
active
"
this
.
ruleView
.
highlighters
.
gridHighlighters
.
has
(
nodeFront
)
)
;
gridToggle
.
toggleAttribute
(
"
disabled
"
!
this
.
ruleView
.
highlighters
.
canGridHighlighterToggle
(
nodeFront
)
)
;
}
const
shapeToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
shapeswatch
"
)
;
if
(
shapeToggle
)
{
const
mode
=
"
css
"
+
name
.
split
(
"
-
"
)
.
map
(
s
=
>
{
return
s
[
0
]
.
toUpperCase
(
)
+
s
.
slice
(
1
)
;
}
)
.
join
(
"
"
)
;
shapeToggle
.
setAttribute
(
"
data
-
mode
"
mode
)
;
}
if
(
this
.
_hasPendingClick
&
&
!
this
.
_isDragging
)
{
this
.
_hasPendingClick
=
false
;
let
elToClick
;
if
(
this
.
_clickedElementOptions
!
=
=
null
)
{
const
{
selector
index
}
=
this
.
_clickedElementOptions
;
elToClick
=
this
.
valueSpan
.
querySelectorAll
(
selector
)
[
index
]
;
this
.
_clickedElementOptions
=
null
;
}
if
(
!
elToClick
)
{
elToClick
=
this
.
valueSpan
;
}
elToClick
.
click
(
)
;
}
this
.
_updateComputed
(
)
;
this
.
_updateShorthandOverridden
(
)
;
this
.
ruleView
.
_updatePropertyHighlight
(
this
)
;
if
(
focusedElSelector
)
{
const
elementToFocus
=
this
.
doc
.
querySelector
(
focusedElSelector
)
;
if
(
elementToFocus
)
{
elementToFocus
.
focus
(
)
;
}
}
}
_onStartEditing
(
)
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
this
.
filterProperty
.
hidden
=
true
;
this
.
enable
.
style
.
visibility
=
"
hidden
"
;
this
.
expander
.
style
.
display
=
"
none
"
;
}
get
shouldShowComputedExpander
(
)
{
return
(
this
.
prop
.
computed
.
some
(
c
=
>
c
.
name
!
=
=
this
.
prop
.
name
)
&
&
!
this
.
prop
.
computed
.
every
(
c
=
>
!
c
.
value
)
)
;
}
updatePropertyState
(
)
{
if
(
this
.
prop
.
enabled
)
{
this
.
enable
.
style
.
removeProperty
(
"
visibility
"
)
;
}
else
{
this
.
enable
.
style
.
visibility
=
"
visible
"
;
}
this
.
enable
.
checked
=
this
.
prop
.
enabled
;
this
.
warning
.
title
=
!
this
.
isNameValid
(
)
?
l10n
(
"
rule
.
warningName
.
title
"
)
:
l10n
(
"
rule
.
warning
.
title
"
)
;
this
.
warning
.
hidden
=
this
.
editing
|
|
this
.
isValid
(
)
;
this
.
filterProperty
.
hidden
=
this
.
editing
|
|
!
this
.
isValid
(
)
|
|
!
this
.
prop
.
overridden
|
|
this
.
ruleEditor
.
rule
.
isUnmatched
;
this
.
expander
.
style
.
display
=
this
.
shouldShowComputedExpander
?
"
inline
-
block
"
:
"
none
"
;
if
(
!
this
.
editing
&
&
(
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
!
this
.
prop
.
isKnownProperty
)
)
{
this
.
element
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
else
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
}
this
.
updatePropertyUsedIndicator
(
)
;
const
inlineCompatibilityWarningEnabled
=
Services
.
prefs
.
getBoolPref
(
INLINE_COMPATIBILITY_WARNING_PREF
)
;
if
(
inlineCompatibilityWarningEnabled
)
{
this
.
updatePropertyCompatibilityIndicator
(
)
;
}
}
updatePropertyUsedIndicator
(
)
{
const
{
used
}
=
this
.
prop
.
isUsed
(
)
;
if
(
this
.
editing
|
|
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
used
)
{
this
.
element
.
classList
.
remove
(
"
unused
"
)
;
this
.
unusedState
.
hidden
=
true
;
}
else
{
this
.
element
.
classList
.
add
(
"
unused
"
)
;
this
.
unusedState
.
hidden
=
false
;
}
}
async
updatePropertyCompatibilityIndicator
(
)
{
const
{
isCompatible
}
=
await
this
.
prop
.
isCompatible
(
)
;
if
(
this
.
editing
|
|
isCompatible
)
{
this
.
compatibilityState
.
hidden
=
true
;
}
else
{
this
.
compatibilityState
.
hidden
=
false
;
}
}
_updateComputed
(
)
{
this
.
computed
.
innerHTML
=
"
"
;
this
.
expander
.
style
.
display
=
!
this
.
editing
&
&
this
.
shouldShowComputedExpander
?
"
inline
-
block
"
:
"
none
"
;
this
.
_populatedComputed
=
false
;
if
(
this
.
expander
.
hasAttribute
(
"
open
"
)
)
{
this
.
_populateComputed
(
)
;
}
}
_populateComputed
(
)
{
if
(
this
.
_populatedComputed
)
{
return
;
}
this
.
_populatedComputed
=
true
;
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
)
{
continue
;
}
computed
.
element
=
this
.
_createComputedListItem
(
this
.
computed
computed
"
ruleview
-
computed
"
)
;
}
}
_updateShorthandOverridden
(
)
{
this
.
shorthandOverridden
.
innerHTML
=
"
"
;
this
.
_populatedShorthandOverridden
=
false
;
this
.
_populateShorthandOverridden
(
)
;
}
_populateShorthandOverridden
(
)
{
if
(
this
.
_populatedShorthandOverridden
|
|
this
.
prop
.
overridden
|
|
!
this
.
shouldShowComputedExpander
)
{
return
;
}
this
.
_populatedShorthandOverridden
=
true
;
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
|
|
!
computed
.
overridden
)
{
continue
;
}
this
.
_createComputedListItem
(
this
.
shorthandOverridden
computed
"
ruleview
-
overridden
-
item
"
)
;
}
}
_createComputedListItem
(
parentEl
computed
className
)
{
const
li
=
createChild
(
parentEl
"
li
"
{
class
:
className
}
)
;
if
(
computed
.
overridden
)
{
li
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
const
nameContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
createChild
(
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
textContent
:
computed
.
name
}
)
;
appendText
(
nameContainer
"
:
"
)
;
const
outputParser
=
this
.
ruleView
.
_outputParser
;
const
frag
=
outputParser
.
parseCssProperty
(
computed
.
name
computed
.
value
{
colorSwatchClass
:
"
ruleview
-
swatch
ruleview
-
colorswatch
"
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetHref
fontFamilyClass
:
"
ruleview
-
font
-
family
"
}
)
;
computed
.
parsedValue
=
frag
.
textContent
;
const
propertyContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
createChild
(
propertyContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
child
:
frag
}
)
;
appendText
(
propertyContainer
"
;
"
)
;
return
li
;
}
_onDraggablePreferenceChanged
(
)
{
if
(
this
.
_isDraggableProperty
(
this
.
prop
)
)
{
this
.
_addDraggingCapability
(
)
;
}
else
{
this
.
_removeDraggingCapacity
(
)
;
}
}
_onEnableClicked
(
event
)
{
event
.
stopPropagation
(
)
;
}
_onEnableChanged
(
event
)
{
this
.
prop
.
setEnabled
(
this
.
enable
.
checked
)
;
event
.
stopPropagation
(
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
_onExpandClicked
(
event
)
{
if
(
this
.
computed
.
hasAttribute
(
"
filter
-
open
"
)
|
|
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
this
.
computed
.
removeAttribute
(
"
user
-
open
"
)
;
this
.
shorthandOverridden
.
hidden
=
false
;
this
.
_populateShorthandOverridden
(
)
;
}
else
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
user
-
open
"
"
"
)
;
this
.
shorthandOverridden
.
hidden
=
true
;
this
.
_populateComputed
(
)
;
}
event
.
stopPropagation
(
)
;
}
expandForFilter
(
)
{
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
filter
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
}
collapseForFilter
(
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
}
}
_onNameDone
(
value
commit
direction
)
{
const
isNameUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
this
.
committed
.
name
=
=
=
value
;
if
(
this
.
prop
.
value
&
&
isNameUnchanged
)
{
return
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
if
(
!
value
.
trim
(
)
)
{
this
.
remove
(
direction
)
;
return
;
}
if
(
!
this
.
prop
.
value
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
this
.
remove
(
direction
)
;
return
;
}
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
this
.
prop
.
setName
(
properties
[
0
]
.
name
)
;
this
.
committed
.
name
=
this
.
prop
.
name
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
if
(
properties
.
length
>
1
)
{
this
.
prop
.
setValue
(
properties
[
0
]
.
value
properties
[
0
]
.
priority
)
;
this
.
ruleEditor
.
addProperties
(
properties
.
slice
(
1
)
this
.
prop
)
;
}
}
}
remove
(
direction
)
{
if
(
this
.
_colorSwatchSpans
&
&
this
.
_colorSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
removeSwatch
(
span
)
;
span
.
off
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
}
}
if
(
this
.
angleSwatchSpans
&
&
this
.
angleSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
angleSwatchSpans
)
{
span
.
off
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
}
}
this
.
ruleView
.
off
(
"
draggable
-
preference
-
updated
"
this
.
_onDraggablePreferenceChanged
)
;
this
.
element
.
remove
(
)
;
this
.
ruleEditor
.
rule
.
editClosestTextProperty
(
this
.
prop
direction
)
;
this
.
nameSpan
.
textProperty
=
null
;
this
.
valueSpan
.
textProperty
=
null
;
this
.
prop
.
remove
(
)
;
}
_onValueDone
(
value
=
"
"
commit
direction
)
{
const
parsedProperties
=
this
.
_getValueAndExtraProperties
(
value
)
;
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
parsedProperties
.
firstValue
)
;
const
isValueUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
(
!
parsedProperties
.
propertiesToAdd
.
length
&
&
this
.
committed
.
value
=
=
=
val
.
value
&
&
this
.
committed
.
priority
=
=
=
val
.
priority
)
;
if
(
value
.
trim
(
)
&
&
isValueUnchanged
)
{
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
return
;
}
if
(
this
.
_isDraggableProperty
(
val
)
)
{
this
.
_addDraggingCapability
(
)
;
}
else
{
this
.
_removeDraggingCapacity
(
)
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
this
.
prop
.
setValue
(
val
.
value
val
.
priority
)
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
committed
.
priority
=
this
.
prop
.
priority
;
this
.
ruleEditor
.
addProperties
(
parsedProperties
.
propertiesToAdd
this
.
prop
)
;
if
(
!
value
.
trim
(
)
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
setTimeout
(
(
)
=
>
{
if
(
!
this
.
editing
)
{
this
.
remove
(
direction
)
;
}
}
0
)
;
}
}
_onSwatchCommit
(
)
{
this
.
_onValueDone
(
this
.
valueSpan
.
textContent
true
)
;
this
.
update
(
)
;
}
_onSwatchPreview
(
)
{
this
.
_previewValue
(
this
.
valueSpan
.
textContent
)
;
}
_onSwatchRevert
(
)
{
this
.
_previewValue
(
this
.
prop
.
value
true
)
;
this
.
update
(
)
;
}
_getValueAndExtraProperties
(
value
)
{
let
firstValue
=
value
;
let
propertiesToAdd
=
[
]
;
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
if
(
!
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
else
if
(
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
name
+
"
:
"
+
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
}
return
{
propertiesToAdd
firstValue
}
;
}
_previewValue
(
value
reverting
=
false
)
{
if
(
!
reverting
&
&
(
!
this
.
editing
|
|
this
.
ruleEditor
.
isEditing
)
)
{
return
;
}
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
value
)
;
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
}
_hasSmallIncrementModifier
(
event
)
{
const
modifier
=
AppConstants
.
platform
=
=
=
"
macosx
"
?
"
altKey
"
:
"
ctrlKey
"
;
return
event
[
modifier
]
=
=
=
true
;
}
_parseDimension
(
value
)
{
const
cssDimensionRegex
=
/
^
(
?
<
value
>
[
+
-
]
?
(
\
d
*
\
.
)
?
\
d
+
(
e
[
+
-
]
?
\
d
+
)
?
)
(
?
<
unit
>
(
%
|
[
a
-
zA
-
Z
]
+
)
)
/
;
return
value
.
match
(
cssDimensionRegex
)
;
}
_isDraggableProperty
(
textProperty
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
draggable_properties
"
false
)
)
{
return
false
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
ELEMENT_STYLE
)
{
return
false
;
}
const
nbValues
=
textProperty
.
value
.
split
(
"
"
)
.
length
;
if
(
nbValues
>
1
)
{
return
false
;
}
const
dimensionMatchObj
=
this
.
_parseDimension
(
textProperty
.
value
)
;
return
!
!
dimensionMatchObj
;
}
_draggingOnMouseDown
(
event
)
{
this
.
_isDragging
=
true
;
this
.
valueSpan
.
setPointerCapture
(
event
.
pointerId
)
;
this
.
_draggingController
=
new
AbortController
(
)
;
const
{
signal
}
=
this
.
_draggingController
;
this
.
valueSpan
.
classList
.
add
(
IS_DRAGGING_CLASSNAME
)
;
const
dimensionObj
=
this
.
_parseDimension
(
this
.
prop
.
value
)
;
const
{
value
unit
}
=
dimensionObj
.
groups
;
this
.
_draggingValueCache
=
{
isInDeadzone
:
true
previousScreenX
:
event
.
screenX
value
:
parseFloat
(
value
)
unit
}
;
this
.
valueSpan
.
addEventListener
(
"
mousemove
"
this
.
_draggingOnMouseMove
{
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mouseup
"
this
.
_draggingOnMouseUp
{
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
keydown
"
this
.
_draggingOnKeydown
{
signal
}
)
;
}
_draggingOnMouseMove
(
event
)
{
if
(
!
this
.
_isDragging
)
{
return
;
}
const
{
isInDeadzone
previousScreenX
}
=
this
.
_draggingValueCache
;
let
deltaX
=
event
.
screenX
-
previousScreenX
;
if
(
isInDeadzone
)
{
if
(
Math
.
abs
(
deltaX
)
<
DRAGGING_DEADZONE_DISTANCE
)
{
return
;
}
deltaX
=
Math
.
sign
(
deltaX
)
*
(
Math
.
abs
(
deltaX
)
-
DRAGGING_DEADZONE_DISTANCE
)
;
this
.
_draggingValueCache
.
isInDeadzone
=
false
;
}
let
draggingSpeed
=
DEFAULT_DRAGGING_SPEED
;
if
(
event
.
shiftKey
)
{
draggingSpeed
=
FAST_DRAGGING_SPEED
;
}
else
if
(
this
.
_hasSmallIncrementModifier
(
event
)
)
{
draggingSpeed
=
SLOW_DRAGGING_SPEED
;
}
const
delta
=
deltaX
*
draggingSpeed
;
this
.
_draggingValueCache
.
previousScreenX
=
event
.
screenX
;
this
.
_draggingValueCache
.
value
+
=
delta
;
if
(
delta
=
=
0
)
{
return
;
}
const
{
value
unit
}
=
this
.
_draggingValueCache
;
const
roundedValue
=
Number
.
isInteger
(
value
)
?
value
:
value
.
toFixed
(
1
)
;
this
.
prop
.
setValue
(
roundedValue
+
unit
this
.
prop
.
priority
)
;
this
.
ruleView
.
emitForTests
(
"
property
-
updated
-
by
-
dragging
"
)
;
this
.
_hasDragged
=
true
;
}
_draggingOnMouseUp
(
event
)
{
if
(
!
this
.
_isDragging
)
{
return
;
}
if
(
this
.
_hasDragged
)
{
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
_onStopDragging
(
event
)
;
}
_draggingOnKeydown
(
event
)
{
if
(
event
.
key
=
=
"
Escape
"
)
{
this
.
prop
.
setValue
(
this
.
committed
.
value
this
.
committed
.
priority
)
;
this
.
_onStopDragging
(
event
)
;
event
.
preventDefault
(
)
;
}
}
_onStopDragging
(
event
)
{
if
(
this
.
_hasDragged
&
&
!
this
.
_hasPendingClick
)
{
this
.
ruleView
.
childHasDragged
=
true
;
}
this
.
_isDragging
=
false
;
this
.
_hasDragged
=
false
;
this
.
_draggingValueCache
=
null
;
this
.
valueSpan
.
releasePointerCapture
(
event
.
pointerId
)
;
this
.
valueSpan
.
classList
.
remove
(
IS_DRAGGING_CLASSNAME
)
;
this
.
_draggingController
.
abort
(
)
;
}
_addDraggingCapability
(
)
{
if
(
this
.
valueSpan
.
classList
.
contains
(
DRAGGABLE_VALUE_CLASSNAME
)
)
{
return
;
}
this
.
valueSpan
.
classList
.
add
(
DRAGGABLE_VALUE_CLASSNAME
)
;
this
.
valueSpan
.
addEventListener
(
"
mousedown
"
this
.
_draggingOnMouseDown
)
;
}
_removeDraggingCapacity
(
)
{
if
(
!
this
.
valueSpan
.
classList
.
contains
(
DRAGGABLE_VALUE_CLASSNAME
)
)
{
return
;
}
this
.
_draggingController
=
null
;
this
.
valueSpan
.
classList
.
remove
(
DRAGGABLE_VALUE_CLASSNAME
)
;
this
.
valueSpan
.
removeEventListener
(
"
mousedown
"
this
.
_draggingOnMouseDown
)
;
}
isValid
(
)
{
return
this
.
prop
.
isValid
(
)
;
}
isNameValid
(
)
{
return
this
.
prop
.
isNameValid
(
)
;
}
}
;
module
.
exports
=
TextPropertyEditor
;
