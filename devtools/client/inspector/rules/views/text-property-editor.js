"
use
strict
"
;
const
{
l10n
l10nFormatStr
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
const
{
InplaceEditor
editableField
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
inplace
-
editor
.
js
"
)
;
const
{
createChild
appendText
advanceValidate
blurOnMultipleProperties
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
utils
.
js
"
)
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
parseDeclarations
"
"
parseSingleValue
"
]
"
resource
:
/
/
devtools
/
shared
/
css
/
parsing
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
true
)
;
loader
.
lazyGetter
(
this
"
PROPERTY_NAME_INPUT_LABEL
"
function
(
)
{
return
l10n
(
"
rule
.
propertyName
.
label
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
SHORTHAND_EXPANDER_TOOLTIP
"
function
(
)
{
return
l10n
(
"
rule
.
shorthandExpander
.
tooltip
"
)
;
}
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
}
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SHARED_SWATCH_CLASS
=
"
inspector
-
swatch
"
;
const
COLOR_SWATCH_CLASS
=
"
inspector
-
colorswatch
"
;
const
BEZIER_SWATCH_CLASS
=
"
inspector
-
bezierswatch
"
;
const
LINEAR_EASING_SWATCH_CLASS
=
"
inspector
-
lineareasingswatch
"
;
const
FILTER_SWATCH_CLASS
=
"
inspector
-
filterswatch
"
;
const
ANGLE_SWATCH_CLASS
=
"
inspector
-
angleswatch
"
;
const
FONT_FAMILY_CLASS
=
"
ruleview
-
font
-
family
"
;
const
SHAPE_SWATCH_CLASS
=
"
inspector
-
shapeswatch
"
;
const
ACTIONABLE_ELEMENTS_SELECTORS
=
[
.
{
COLOR_SWATCH_CLASS
}
.
{
BEZIER_SWATCH_CLASS
}
.
{
LINEAR_EASING_SWATCH_CLASS
}
.
{
FILTER_SWATCH_CLASS
}
.
{
ANGLE_SWATCH_CLASS
}
"
a
"
]
;
const
SLOW_DRAGGING_SPEED
=
0
.
1
;
const
DEFAULT_DRAGGING_SPEED
=
1
;
const
FAST_DRAGGING_SPEED
=
10
;
const
DRAGGING_DEADZONE_DISTANCE
=
5
;
const
DRAGGABLE_VALUE_CLASSNAME
=
"
ruleview
-
propertyvalue
-
draggable
"
;
const
IS_DRAGGING_CLASSNAME
=
"
ruleview
-
propertyvalue
-
dragging
"
;
class
TextPropertyEditor
{
constructor
(
ruleEditor
property
options
)
{
this
.
ruleEditor
=
ruleEditor
;
this
.
ruleView
=
this
.
ruleEditor
.
ruleView
;
this
.
cssProperties
=
this
.
ruleView
.
cssProperties
;
this
.
doc
=
this
.
ruleEditor
.
doc
;
this
.
popup
=
this
.
ruleView
.
popup
;
this
.
prop
=
property
;
this
.
prop
.
editor
=
this
;
this
.
browserWindow
=
this
.
doc
.
defaultView
.
top
;
this
.
#
elementsWithPendingClicks
=
options
.
elementsWithPendingClicks
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
#
onValidate
=
this
.
ruleView
.
debounce
(
this
.
#
previewValue
10
this
)
;
this
.
#
createUI
(
)
;
this
.
update
(
)
;
}
#
populatedComputed
=
false
;
#
hasPendingClick
=
false
;
#
clickedElementOptions
=
null
;
#
populatedShorthandOverridden
;
#
elementsWithPendingClicks
;
#
colorSwatchSpans
;
#
bezierSwatchSpans
;
#
linearEasingSwatchSpans
;
#
onValidate
;
#
isDragging
=
false
;
#
capturingPointerId
=
null
;
#
hasDragged
=
false
;
#
draggingController
=
null
;
#
draggingValueCache
=
null
;
get
editing
(
)
{
return
(
!
!
(
this
.
nameSpan
.
inplaceEditor
|
|
this
.
valueSpan
.
inplaceEditor
|
|
this
.
ruleView
.
tooltips
.
isEditing
)
|
|
this
.
popup
.
isOpen
)
;
}
get
rule
(
)
{
return
this
.
prop
.
rule
;
}
get
_DRAGGING_DEADZONE_DISTANCE
(
)
{
return
DRAGGING_DEADZONE_DISTANCE
;
}
#
createUI
(
)
{
const
win
=
this
.
doc
.
defaultView
;
this
.
abortController
=
new
win
.
AbortController
(
)
;
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
element
.
setAttribute
(
"
role
"
"
listitem
"
)
;
this
.
element
.
classList
.
add
(
"
ruleview
-
property
"
)
;
this
.
element
.
dataset
.
declarationId
=
this
.
prop
.
id
;
this
.
element
.
_textPropertyEditor
=
this
;
this
.
container
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
propertycontainer
"
}
)
;
const
indent
=
(
(
this
.
ruleEditor
.
rule
.
domRule
.
ancestorData
.
length
|
|
0
)
+
1
)
*
2
;
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
rule
-
indent
clipboard
-
only
"
textContent
:
"
"
.
repeat
(
indent
)
}
)
;
this
.
enable
=
createChild
(
this
.
container
"
input
"
{
type
:
"
checkbox
"
class
:
"
ruleview
-
enableproperty
"
title
:
l10nFormatStr
(
"
rule
.
propertyToggle
.
label
"
this
.
prop
.
name
)
}
)
;
this
.
nameContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
this
.
nameSpan
=
createChild
(
this
.
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
id
:
this
.
prop
.
id
}
)
;
appendText
(
this
.
nameContainer
"
:
"
)
;
if
(
this
.
#
shouldShowComputedExpander
)
{
this
.
#
createComputedExpander
(
)
;
}
this
.
valueContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
this
.
valueSpan
=
createChild
(
this
.
valueContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
this
.
valueSpan
.
textProperty
=
this
.
prop
;
this
.
nameSpan
.
textProperty
=
this
.
prop
;
appendText
(
this
.
valueContainer
"
;
"
)
;
if
(
this
.
#
shouldShowWarning
)
{
this
.
#
createWarningIcon
(
)
;
}
if
(
this
.
#
isInvalidAtComputedValueTime
(
)
)
{
this
.
#
createInvalidAtComputedValueTimeIcon
(
)
;
}
if
(
this
.
#
shouldShowUnusedState
)
{
this
.
#
createUnusedWarningIcon
(
)
;
}
if
(
this
.
#
shouldShowFilterProperty
)
{
this
.
#
createFilterPropertyButton
(
)
;
}
if
(
this
.
ruleEditor
.
isEditable
)
{
this
.
enable
.
addEventListener
(
"
click
"
this
.
#
onEnableClicked
{
signal
:
this
.
abortController
.
signal
capture
:
true
}
)
;
this
.
enable
.
addEventListener
(
"
change
"
this
.
#
onEnableChanged
{
signal
:
this
.
abortController
.
signal
capture
:
true
}
)
;
this
.
nameContainer
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
nameContainer
)
{
this
.
nameSpan
.
click
(
)
;
}
}
{
signal
:
this
.
abortController
.
signal
}
)
;
const
getCssVariables
=
(
)
=
>
this
.
rule
.
elementStyle
.
getAllCustomProperties
(
this
.
rule
.
pseudoElement
)
;
editableField
(
{
start
:
this
.
#
onStartEditing
element
:
this
.
nameSpan
done
:
this
.
#
onNameDone
destroy
:
this
.
updateUI
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
popup
cssProperties
:
this
.
cssProperties
getCssVariables
focusEditableFieldAfterApply
:
true
focusEditableFieldContainerSelector
:
"
.
ruleview
-
rule
"
stopOnReturn
:
this
.
ruleView
.
inplaceEditorFocusNextOnEnter
!
=
=
true
inputAriaLabel
:
PROPERTY_NAME_INPUT_LABEL
}
)
;
this
.
nameContainer
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
cssProperties
)
{
signal
:
this
.
abortController
.
signal
}
)
;
this
.
valueContainer
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
valueContainer
)
{
this
.
valueSpan
.
click
(
)
;
}
}
{
signal
:
this
.
abortController
.
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mousedown
"
event
=
>
{
const
clickedEl
=
event
.
target
;
if
(
clickedEl
=
=
=
this
.
valueSpan
)
{
return
;
}
this
.
#
hasPendingClick
=
true
;
this
.
#
elementsWithPendingClicks
.
add
(
this
.
valueSpan
)
;
const
matchedSelector
=
ACTIONABLE_ELEMENTS_SELECTORS
.
find
(
selector
=
>
clickedEl
.
matches
(
selector
)
)
;
if
(
matchedSelector
)
{
const
similarElements
=
[
.
.
.
this
.
valueSpan
.
querySelectorAll
(
matchedSelector
)
]
;
this
.
#
clickedElementOptions
=
{
selector
:
matchedSelector
index
:
similarElements
.
indexOf
(
clickedEl
)
}
;
}
}
{
signal
:
this
.
abortController
.
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
pointerup
"
(
)
=
>
{
if
(
this
.
#
hasDragged
)
{
return
;
}
this
.
#
clickedElementOptions
=
null
;
this
.
#
hasPendingClick
=
false
;
this
.
#
elementsWithPendingClicks
.
delete
(
this
.
valueSpan
)
;
}
{
signal
:
this
.
abortController
.
signal
}
)
;
this
.
ruleView
.
on
(
"
draggable
-
preference
-
updated
"
this
.
#
onDraggablePreferenceChanged
{
signal
:
this
.
abortController
.
signal
}
)
;
if
(
this
.
#
isDraggableProperty
(
this
.
prop
)
)
{
this
.
#
addDraggingCapability
(
)
;
}
editableField
(
{
start
:
this
.
#
onStartEditing
element
:
this
.
valueSpan
done
:
this
.
#
onValueDone
destroy
:
onValueDonePromise
=
>
{
const
cb
=
this
.
update
;
if
(
onValueDonePromise
&
&
typeof
onValueDonePromise
.
then
=
=
=
"
function
"
)
{
return
onValueDonePromise
.
then
(
cb
)
;
}
return
cb
(
)
;
}
validate
:
this
.
#
onValidate
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
this
.
prop
defaultIncrement
:
this
.
prop
.
name
=
=
=
"
opacity
"
?
0
.
1
:
1
popup
:
this
.
popup
multiline
:
true
maxWidth
:
(
)
=
>
this
.
container
.
getBoundingClientRect
(
)
.
width
cssProperties
:
this
.
cssProperties
getCssVariables
getGridLineNames
:
this
.
#
getGridlineNames
showSuggestCompletionOnEmpty
:
true
focusEditableFieldAfterApply
:
true
focusEditableFieldContainerSelector
:
"
.
ruleview
-
rule
"
stopOnReturn
:
this
.
ruleView
.
inplaceEditorFocusNextOnEnter
!
=
=
true
inputAriaLabelledBy
:
this
.
nameSpan
.
id
}
)
;
}
}
#
getGridlineNames
=
async
(
)
=
>
{
const
gridLineNames
=
{
cols
:
[
]
rows
:
[
]
}
;
const
layoutInspector
=
await
this
.
ruleView
.
inspector
.
walker
.
getLayoutInspector
(
)
;
const
gridFront
=
await
layoutInspector
.
getCurrentGrid
(
this
.
ruleView
.
inspector
.
selection
.
nodeFront
)
;
if
(
gridFront
)
{
const
gridFragments
=
gridFront
.
gridFragments
;
for
(
const
gridFragment
of
gridFragments
)
{
for
(
const
rowLine
of
gridFragment
.
rows
.
lines
)
{
let
gridArea
;
for
(
const
name
of
rowLine
.
names
)
{
const
rowLineName
=
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
start
"
)
)
|
|
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
end
"
)
)
;
gridArea
=
gridFragment
.
areas
.
find
(
area
=
>
area
.
name
=
=
=
rowLineName
)
;
if
(
rowLine
.
type
=
=
=
"
implicit
"
&
&
gridArea
&
&
gridArea
.
type
=
=
=
"
implicit
"
)
{
continue
;
}
gridLineNames
.
rows
.
push
(
name
)
;
}
}
for
(
const
colLine
of
gridFragment
.
cols
.
lines
)
{
let
gridArea
;
for
(
const
name
of
colLine
.
names
)
{
const
colLineName
=
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
start
"
)
)
|
|
name
.
substring
(
0
name
.
lastIndexOf
(
"
-
end
"
)
)
;
gridArea
=
gridFragment
.
areas
.
find
(
area
=
>
area
.
name
=
=
=
colLineName
)
;
if
(
colLine
.
type
=
=
=
"
implicit
"
&
&
gridArea
&
&
gridArea
.
type
=
=
=
"
implicit
"
)
{
continue
;
}
gridLineNames
.
cols
.
push
(
name
)
;
}
}
}
}
this
.
ruleView
.
inspector
.
emit
(
"
grid
-
line
-
names
-
updated
"
)
;
return
gridLineNames
;
}
;
get
#
sheetHref
(
)
{
const
domRule
=
this
.
rule
.
domRule
;
if
(
domRule
)
{
return
domRule
.
href
|
|
domRule
.
nodeHref
;
}
return
undefined
;
}
update
=
(
)
=
>
{
if
(
this
.
ruleView
.
isDestroyed
)
{
return
;
}
this
.
updateUI
(
)
;
const
name
=
this
.
prop
.
name
;
this
.
nameSpan
.
textContent
=
name
;
this
.
enable
.
setAttribute
(
"
title
"
l10nFormatStr
(
"
rule
.
propertyToggle
.
label
"
name
)
)
;
const
store
=
this
.
rule
.
elementStyle
.
store
;
let
val
=
store
.
userProperties
.
getProperty
(
this
.
rule
.
domRule
name
this
.
prop
.
value
)
;
if
(
this
.
prop
.
priority
)
{
val
+
=
"
!
"
+
this
.
prop
.
priority
;
}
const
propDirty
=
store
.
userProperties
.
contains
(
this
.
rule
.
domRule
name
)
;
if
(
propDirty
)
{
this
.
element
.
setAttribute
(
"
dirty
"
"
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
dirty
"
)
;
}
const
outputParser
=
this
.
ruleView
.
_outputParser
;
this
.
outputParserOptions
=
{
angleClass
:
"
ruleview
-
angle
"
angleSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
ANGLE_SWATCH_CLASS
bezierClass
:
"
ruleview
-
bezier
"
bezierSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
BEZIER_SWATCH_CLASS
colorClass
:
"
ruleview
-
color
"
colorSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
COLOR_SWATCH_CLASS
filterClass
:
"
ruleview
-
filter
"
filterSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
FILTER_SWATCH_CLASS
flexClass
:
"
inspector
-
flex
js
-
toggle
-
flexbox
-
highlighter
"
gridClass
:
"
inspector
-
grid
js
-
toggle
-
grid
-
highlighter
"
linearEasingClass
:
"
ruleview
-
lineareasing
"
linearEasingSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
LINEAR_EASING_SWATCH_CLASS
shapeClass
:
"
inspector
-
shape
"
shapeSwatchClass
:
SHAPE_SWATCH_CLASS
useDefaultColorUnit
:
!
propDirty
defaultColorUnit
:
this
.
ruleView
.
inspector
.
defaultColorUnit
urlClass
:
"
theme
-
link
"
fontFamilyClass
:
FONT_FAMILY_CLASS
baseURI
:
this
.
#
sheetHref
unmatchedClass
:
"
inspector
-
unmatched
"
matchedVariableClass
:
"
inspector
-
variable
"
getVariableData
:
varName
=
>
this
.
rule
.
elementStyle
.
getVariableData
(
varName
this
.
rule
.
pseudoElement
)
inStartingStyleRule
:
this
.
rule
.
isInStartingStyle
(
)
isValid
:
this
.
isValid
(
)
}
;
if
(
this
.
rule
.
darkColorScheme
!
=
=
undefined
)
{
this
.
outputParserOptions
.
isDarkColorScheme
=
this
.
rule
.
darkColorScheme
;
}
const
frag
=
outputParser
.
parseCssProperty
(
name
val
this
.
outputParserOptions
)
;
if
(
!
this
.
committed
)
{
this
.
committed
=
{
name
value
:
frag
.
textContent
priority
:
this
.
prop
.
priority
}
;
}
let
focusedElSelector
=
null
;
if
(
this
.
valueSpan
.
contains
(
this
.
doc
.
activeElement
)
)
{
focusedElSelector
=
findCssSelector
(
this
.
doc
.
activeElement
)
;
}
this
.
valueSpan
.
innerHTML
=
"
"
;
this
.
valueSpan
.
appendChild
(
frag
)
;
if
(
this
.
valueSpan
.
textProperty
?
.
name
=
=
=
"
grid
-
template
-
areas
"
&
&
this
.
isValid
(
)
&
&
(
this
.
valueSpan
.
innerText
.
includes
(
"
)
|
|
this
.
valueSpan
.
innerText
.
includes
(
'
)
)
)
{
this
.
#
formatGridTemplateAreasValue
(
)
;
}
this
.
ruleView
.
emit
(
"
property
-
value
-
updated
"
{
rule
:
this
.
prop
.
rule
property
:
name
value
:
val
}
)
;
const
fontFamilySpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
FONT_FAMILY_CLASS
)
;
if
(
fontFamilySpans
.
length
&
&
this
.
prop
.
enabled
&
&
!
this
.
prop
.
overridden
)
{
this
.
rule
.
elementStyle
.
getUsedFontFamilies
(
)
.
then
(
families
=
>
{
for
(
const
span
of
fontFamilySpans
)
{
const
authoredFont
=
span
.
textContent
.
toLowerCase
(
)
;
if
(
families
.
has
(
authoredFont
)
)
{
span
.
classList
.
add
(
"
used
-
font
"
)
;
families
.
delete
(
authoredFont
)
;
}
}
this
.
ruleView
.
emit
(
"
font
-
highlighted
"
this
.
valueSpan
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
"
Could
not
get
the
list
of
font
families
"
e
)
)
;
}
this
.
#
colorSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
COLOR_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
#
colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
addSwatch
(
span
{
onShow
:
this
.
#
onStartEditing
onPreview
:
this
.
#
onSwatchPreview
onCommit
:
this
.
#
onSwatchCommit
onRevert
:
this
.
#
onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
colorSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
span
.
dataset
.
propertyName
=
this
.
nameSpan
.
textContent
;
}
}
this
.
#
bezierSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
BEZIER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
#
bezierSwatchSpans
)
{
/
/
Adding
this
swatch
to
the
list
of
swatches
our
colorpicker
/
/
knows
about
this
.
ruleView
.
tooltips
.
getTooltip
(
"
cubicBezier
"
)
.
addSwatch
(
span
{
onShow
:
this
.
#
onStartEditing
onPreview
:
this
.
#
onSwatchPreview
onCommit
:
this
.
#
onSwatchCommit
onRevert
:
this
.
#
onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
bezierSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
/
/
Attach
the
linear
easing
tooltip
to
the
linear
easing
swatches
this
.
#
linearEasingSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
LINEAR_EASING_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
#
linearEasingSwatchSpans
)
{
/
/
Adding
this
swatch
to
the
list
of
swatches
our
colorpicker
/
/
knows
about
this
.
ruleView
.
tooltips
.
getTooltip
(
"
linearEaseFunction
"
)
.
addSwatch
(
span
{
onShow
:
this
.
#
onStartEditing
onPreview
:
this
.
#
onSwatchPreview
onCommit
:
this
.
#
onSwatchCommit
onRevert
:
this
.
#
onSwatchRevert
}
)
;
span
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
bezierSwatch
.
tooltip
"
)
)
;
}
}
/
/
Attach
the
filter
editor
tooltip
to
the
filter
swatch
const
span
=
this
.
valueSpan
.
querySelector
(
"
.
"
+
FILTER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
if
(
span
)
{
this
.
outputParserOptions
.
filterSwatch
=
true
;
this
.
ruleView
.
tooltips
.
getTooltip
(
"
filterEditor
"
)
.
addSwatch
(
span
{
onShow
:
this
.
#
onStartEditing
onPreview
:
this
.
#
onSwatchPreview
onCommit
:
this
.
#
onSwatchCommit
onRevert
:
this
.
#
onSwatchRevert
}
outputParser
this
.
outputParserOptions
)
;
const
title
=
l10n
(
"
rule
.
filterSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
this
.
angleSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
ANGLE_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
angleSpan
of
this
.
angleSwatchSpans
)
{
angleSpan
.
addEventListener
(
"
unit
-
change
"
this
.
#
onSwatchCommit
)
;
const
title
=
l10n
(
"
rule
.
angleSwatch
.
tooltip
"
)
;
angleSpan
.
setAttribute
(
"
title
"
title
)
;
}
}
const
nodeFront
=
this
.
ruleView
.
inspector
.
selection
.
nodeFront
;
const
flexToggle
=
this
.
valueSpan
.
querySelector
(
"
.
inspector
-
flex
"
)
;
if
(
flexToggle
)
{
flexToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
flexToggle
.
tooltip
"
)
)
;
flexToggle
.
setAttribute
(
"
aria
-
pressed
"
this
.
ruleView
.
inspector
.
highlighters
.
getNodeForActiveHighlighter
(
this
.
ruleView
.
inspector
.
highlighters
.
TYPES
.
FLEXBOX
)
=
=
=
nodeFront
)
;
}
const
gridToggle
=
this
.
valueSpan
.
querySelector
(
"
.
inspector
-
grid
"
)
;
if
(
gridToggle
)
{
gridToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
gridToggle
.
tooltip
"
)
)
;
gridToggle
.
setAttribute
(
"
aria
-
pressed
"
this
.
ruleView
.
highlighters
.
gridHighlighters
.
has
(
nodeFront
)
)
;
gridToggle
.
toggleAttribute
(
"
disabled
"
!
this
.
ruleView
.
highlighters
.
canGridHighlighterToggle
(
nodeFront
)
)
;
}
const
shapeToggle
=
this
.
valueSpan
.
querySelector
(
"
.
inspector
-
shapeswatch
"
)
;
if
(
shapeToggle
)
{
const
mode
=
"
css
"
+
name
.
split
(
"
-
"
)
.
map
(
s
=
>
{
return
s
[
0
]
.
toUpperCase
(
)
+
s
.
slice
(
1
)
;
}
)
.
join
(
"
"
)
;
shapeToggle
.
setAttribute
(
"
data
-
mode
"
mode
)
;
shapeToggle
.
setAttribute
(
"
aria
-
pressed
"
false
)
;
shapeToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
shapeToggle
.
tooltip
"
)
)
;
}
if
(
this
.
#
hasPendingClick
&
&
!
this
.
#
isDragging
)
{
this
.
#
hasPendingClick
=
false
;
this
.
#
elementsWithPendingClicks
.
delete
(
this
.
valueSpan
)
;
let
elToClick
;
if
(
this
.
#
clickedElementOptions
!
=
=
null
)
{
const
{
selector
index
}
=
this
.
#
clickedElementOptions
;
elToClick
=
this
.
valueSpan
.
querySelectorAll
(
selector
)
[
index
]
;
this
.
#
clickedElementOptions
=
null
;
}
if
(
!
elToClick
)
{
elToClick
=
this
.
valueSpan
;
}
elToClick
.
click
(
)
;
}
this
.
#
updateComputed
(
)
;
this
.
#
updateShorthandOverridden
(
)
;
this
.
ruleView
.
_updatePropertyHighlight
(
this
)
;
if
(
this
.
doc
.
hasFocus
(
)
&
&
focusedElSelector
)
{
const
elementToFocus
=
this
.
doc
.
querySelector
(
focusedElSelector
)
;
if
(
elementToFocus
)
{
elementToFocus
.
focus
(
)
;
}
}
}
;
#
onStartEditing
=
(
)
=
>
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
this
.
enable
.
style
.
visibility
=
"
hidden
"
;
if
(
this
.
filterProperty
)
{
this
.
filterProperty
.
hidden
=
true
;
}
if
(
this
.
expander
)
{
this
.
expander
.
style
.
display
=
"
none
"
;
}
}
;
get
#
shouldShowComputedExpander
(
)
{
if
(
this
.
prop
.
name
.
startsWith
(
"
-
-
"
)
)
{
return
false
;
}
return
(
this
.
prop
.
computed
.
some
(
c
=
>
c
.
name
!
=
=
this
.
prop
.
name
)
&
&
!
this
.
prop
.
computed
.
every
(
c
=
>
!
c
.
value
)
)
;
}
get
#
shouldShowWarning
(
)
{
if
(
this
.
prop
.
name
.
startsWith
(
"
-
-
"
)
)
{
return
false
;
}
return
!
this
.
editing
&
&
!
this
.
isValid
(
)
;
}
get
#
shouldShowUnusedState
(
)
{
const
{
used
}
=
this
.
prop
.
isUsed
(
)
;
return
!
this
.
editing
&
&
!
this
.
prop
.
overridden
&
&
this
.
prop
.
enabled
&
&
!
used
;
}
get
#
shouldShowFilterProperty
(
)
{
return
(
!
this
.
editing
&
&
this
.
isValid
(
)
&
&
this
.
prop
.
overridden
&
&
!
this
.
ruleEditor
.
rule
.
isUnmatched
)
;
}
#
createComputedExpander
(
)
{
if
(
this
.
expander
)
{
return
;
}
this
.
expander
=
this
.
doc
.
createElementNS
(
HTML_NS
"
button
"
)
;
this
.
expander
.
ariaExpanded
=
false
;
this
.
expander
.
classList
.
add
(
"
ruleview
-
expander
"
"
theme
-
twisty
"
)
;
this
.
expander
.
title
=
SHORTHAND_EXPANDER_TOOLTIP
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
#
onExpandClicked
{
capture
:
true
signal
:
this
.
abortController
.
signal
}
)
;
this
.
container
.
insertBefore
(
this
.
expander
this
.
valueContainer
)
;
}
#
createComputedList
(
)
{
if
(
this
.
computed
)
{
return
;
}
this
.
computed
=
this
.
doc
.
createElementNS
(
HTML_NS
"
ul
"
)
;
this
.
computed
.
classList
.
add
(
"
ruleview
-
computedlist
"
)
;
this
.
element
.
insertBefore
(
this
.
computed
this
.
shorthandOverridden
)
;
}
#
createWarningIcon
(
)
{
if
(
this
.
warning
)
{
return
;
}
this
.
warning
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
warning
.
classList
.
add
(
"
ruleview
-
warning
"
)
;
this
.
warning
.
title
=
l10n
(
"
rule
.
warning
.
title
"
)
;
this
.
container
.
insertBefore
(
this
.
warning
this
.
invalidAtComputedValueTimeWarning
|
|
this
.
unusedState
|
|
this
.
compatibilityState
|
|
this
.
filterProperty
)
;
}
#
createInvalidAtComputedValueTimeIcon
(
)
{
if
(
this
.
invalidAtComputedValueTimeWarning
)
{
return
;
}
this
.
invalidAtComputedValueTimeWarning
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
invalidAtComputedValueTimeWarning
.
classList
.
add
(
"
ruleview
-
invalid
-
at
-
computed
-
value
-
time
-
warning
"
)
;
this
.
container
.
insertBefore
(
this
.
invalidAtComputedValueTimeWarning
this
.
unusedState
|
|
this
.
compatibilityState
|
|
this
.
filterProperty
)
;
}
#
createUnusedWarningIcon
(
)
{
if
(
this
.
unusedState
)
{
return
;
}
this
.
unusedState
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
unusedState
.
classList
.
add
(
"
ruleview
-
unused
-
warning
"
)
;
this
.
container
.
insertBefore
(
this
.
unusedState
this
.
compatibilityState
|
|
this
.
filterProperty
)
;
}
#
createCompatibilityWarningIcon
(
)
{
if
(
this
.
compatibilityState
)
{
return
;
}
this
.
compatibilityState
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
compatibilityState
.
classList
.
add
(
"
ruleview
-
compatibility
-
warning
"
)
;
this
.
container
.
insertBefore
(
this
.
compatibilityState
this
.
filterProperty
)
;
}
#
createFilterPropertyButton
(
)
{
if
(
this
.
filterProperty
)
{
return
;
}
this
.
filterProperty
=
this
.
doc
.
createElementNS
(
HTML_NS
"
button
"
)
;
this
.
filterProperty
.
classList
.
add
(
"
ruleview
-
overridden
-
rule
-
filter
"
)
;
this
.
filterProperty
.
title
=
l10n
(
"
rule
.
filterProperty
.
title
"
)
;
this
.
container
.
append
(
this
.
filterProperty
)
;
this
.
filterProperty
.
addEventListener
(
"
click
"
event
=
>
{
this
.
ruleEditor
.
ruleView
.
setFilterStyles
(
"
"
+
this
.
prop
.
name
+
"
"
)
;
event
.
stopPropagation
(
)
;
}
{
signal
:
this
.
abortController
.
signal
}
)
;
}
updateUI
=
(
)
=
>
{
if
(
this
.
prop
.
enabled
)
{
this
.
enable
.
style
.
removeProperty
(
"
visibility
"
)
;
}
else
{
this
.
enable
.
style
.
visibility
=
"
visible
"
;
}
this
.
enable
.
checked
=
this
.
prop
.
enabled
;
if
(
this
.
#
shouldShowWarning
)
{
if
(
!
this
.
warning
)
{
this
.
#
createWarningIcon
(
)
;
}
else
{
this
.
warning
.
hidden
=
false
;
}
this
.
warning
.
title
=
!
this
.
#
isNameValid
(
)
?
l10n
(
"
rule
.
warningName
.
title
"
)
:
l10n
(
"
rule
.
warning
.
title
"
)
;
}
else
if
(
this
.
warning
)
{
this
.
warning
.
hidden
=
true
;
}
if
(
!
this
.
editing
&
&
this
.
#
isInvalidAtComputedValueTime
(
)
)
{
if
(
!
this
.
invalidAtComputedValueTimeWarning
)
{
this
.
#
createInvalidAtComputedValueTimeIcon
(
)
;
}
this
.
invalidAtComputedValueTimeWarning
.
title
=
l10nFormatStr
(
"
rule
.
warningInvalidAtComputedValueTime
.
title
"
"
{
this
.
prop
.
getExpectedSyntax
(
)
}
"
)
;
this
.
invalidAtComputedValueTimeWarning
.
hidden
=
false
;
}
else
if
(
this
.
invalidAtComputedValueTimeWarning
)
{
this
.
invalidAtComputedValueTimeWarning
.
hidden
=
true
;
}
if
(
this
.
#
shouldShowFilterProperty
)
{
this
.
#
createFilterPropertyButton
(
)
;
}
else
if
(
this
.
filterProperty
)
{
this
.
filterProperty
.
hidden
=
true
;
}
if
(
this
.
#
shouldShowComputedExpander
&
&
!
this
.
expander
)
{
this
.
#
createComputedExpander
(
)
;
}
else
if
(
!
this
.
#
shouldShowComputedExpander
&
&
this
.
expander
)
{
this
.
expander
.
remove
(
)
;
this
.
expander
=
null
;
}
if
(
!
this
.
editing
&
&
(
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
!
this
.
prop
.
isKnownProperty
)
)
{
this
.
element
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
else
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
}
this
.
#
updatePropertyUsedIndicator
(
)
;
this
.
#
updatePropertyCompatibilityIndicator
(
)
;
}
;
#
updatePropertyUsedIndicator
(
)
{
const
{
used
}
=
this
.
prop
.
isUsed
(
)
;
if
(
this
.
editing
|
|
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
used
)
{
this
.
element
.
classList
.
remove
(
"
unused
"
)
;
if
(
this
.
unusedState
)
{
this
.
unusedState
.
hidden
=
true
;
}
}
else
{
this
.
element
.
classList
.
add
(
"
unused
"
)
;
if
(
!
this
.
unusedState
)
{
this
.
#
createUnusedWarningIcon
(
)
;
}
else
{
this
.
unusedState
.
hidden
=
false
;
}
}
}
async
#
updatePropertyCompatibilityIndicator
(
)
{
const
{
isCompatible
}
=
await
this
.
prop
.
isCompatible
(
)
;
if
(
this
.
editing
|
|
isCompatible
)
{
if
(
this
.
compatibilityState
)
{
this
.
compatibilityState
.
hidden
=
true
;
}
}
else
{
if
(
!
this
.
compatibilityState
)
{
this
.
#
createCompatibilityWarningIcon
(
)
;
}
this
.
compatibilityState
.
hidden
=
false
;
}
}
#
updateComputed
(
)
{
if
(
this
.
computed
)
{
this
.
computed
.
replaceChildren
(
)
;
}
if
(
!
this
.
editing
&
&
this
.
#
shouldShowComputedExpander
&
&
!
this
.
expander
)
{
this
.
#
createComputedExpander
(
)
;
}
else
if
(
this
.
expander
&
&
!
this
.
editing
&
&
!
this
.
#
shouldShowComputedExpander
)
{
this
.
expander
.
hidden
=
true
;
}
this
.
#
populatedComputed
=
false
;
if
(
this
.
expander
&
&
this
.
expander
.
getAttribute
(
"
aria
-
expanded
"
=
=
=
"
true
"
)
)
{
this
.
populateComputed
(
)
;
}
}
populateComputed
(
)
{
if
(
this
.
#
populatedComputed
)
{
return
;
}
this
.
#
populatedComputed
=
true
;
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
)
{
continue
;
}
if
(
!
this
.
computed
)
{
this
.
#
createComputedList
(
)
;
}
computed
.
element
=
this
.
#
createComputedListItem
(
this
.
computed
computed
"
ruleview
-
computed
"
)
;
}
}
#
updateShorthandOverridden
(
)
{
if
(
this
.
shorthandOverridden
)
{
this
.
shorthandOverridden
.
replaceChildren
(
)
;
}
this
.
#
populatedShorthandOverridden
=
false
;
this
.
#
populateShorthandOverridden
(
)
;
}
#
populateShorthandOverridden
(
)
{
if
(
this
.
#
populatedShorthandOverridden
|
|
this
.
prop
.
overridden
|
|
!
this
.
#
shouldShowComputedExpander
)
{
return
;
}
this
.
#
populatedShorthandOverridden
=
true
;
if
(
!
this
.
shorthandOverridden
)
{
this
.
shorthandOverridden
=
this
.
doc
.
createElementNS
(
HTML_NS
"
ul
"
)
;
this
.
shorthandOverridden
.
classList
.
add
(
"
ruleview
-
overridden
-
items
"
)
;
this
.
element
.
append
(
this
.
shorthandOverridden
)
;
}
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
|
|
!
computed
.
overridden
)
{
continue
;
}
this
.
#
createComputedListItem
(
this
.
shorthandOverridden
computed
"
ruleview
-
overridden
-
item
"
)
;
}
}
#
createComputedListItem
(
parentEl
computed
className
)
{
const
li
=
createChild
(
parentEl
"
li
"
{
class
:
className
}
)
;
if
(
computed
.
overridden
)
{
li
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
const
nameContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
createChild
(
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
textContent
:
computed
.
name
}
)
;
appendText
(
nameContainer
"
:
"
)
;
const
outputParser
=
this
.
ruleView
.
_outputParser
;
const
frag
=
outputParser
.
parseCssProperty
(
computed
.
name
computed
.
value
{
colorSwatchClass
:
"
inspector
-
swatch
inspector
-
colorswatch
"
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
#
sheetHref
fontFamilyClass
:
"
ruleview
-
font
-
family
"
}
)
;
computed
.
parsedValue
=
frag
.
textContent
;
const
propertyContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
createChild
(
propertyContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
child
:
frag
}
)
;
appendText
(
propertyContainer
"
;
"
)
;
return
li
;
}
#
onDraggablePreferenceChanged
=
(
)
=
>
{
if
(
this
.
#
isDraggableProperty
(
this
.
prop
)
)
{
this
.
#
addDraggingCapability
(
)
;
}
else
{
this
.
#
removeDraggingCapacity
(
)
;
}
}
;
#
onEnableClicked
=
event
=
>
{
event
.
stopPropagation
(
)
;
}
;
#
onEnableChanged
=
event
=
>
{
this
.
prop
.
setEnabled
(
this
.
enable
.
checked
)
;
event
.
stopPropagation
(
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
)
;
}
;
#
onExpandClicked
=
event
=
>
{
if
(
!
this
.
computed
)
{
this
.
#
createComputedList
(
)
;
}
const
isOpened
=
this
.
computed
.
hasAttribute
(
"
filter
-
open
"
)
|
|
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
;
this
.
expander
.
setAttribute
(
"
aria
-
expanded
"
!
isOpened
)
;
if
(
isOpened
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
this
.
computed
.
removeAttribute
(
"
user
-
open
"
)
;
if
(
this
.
shorthandOverridden
)
{
this
.
shorthandOverridden
.
hidden
=
false
;
}
this
.
#
populateShorthandOverridden
(
)
;
}
else
{
this
.
computed
.
setAttribute
(
"
user
-
open
"
"
"
)
;
if
(
this
.
shorthandOverridden
)
{
this
.
shorthandOverridden
.
hidden
=
true
;
}
this
.
populateComputed
(
)
;
}
event
.
stopPropagation
(
)
;
}
;
expandForFilter
(
)
{
if
(
!
this
.
computed
|
|
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
if
(
!
this
.
expander
)
{
this
.
#
createComputedExpander
(
)
;
}
this
.
expander
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
if
(
!
this
.
computed
)
{
this
.
#
createComputedList
(
)
;
}
this
.
computed
.
setAttribute
(
"
filter
-
open
"
"
"
)
;
this
.
populateComputed
(
)
;
}
}
collapseForFilter
(
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
&
&
this
.
expander
)
{
this
.
expander
.
setAttribute
(
"
aria
-
expanded
"
"
false
"
)
;
}
}
#
onNameDone
=
(
value
commit
direction
)
=
>
{
const
isNameUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
this
.
committed
.
name
=
=
=
value
;
if
(
this
.
prop
.
value
&
&
isNameUnchanged
)
{
return
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
)
;
if
(
!
value
.
trim
(
)
)
{
this
.
remove
(
direction
)
;
return
;
}
const
isVariable
=
value
.
startsWith
(
"
-
-
"
)
;
if
(
!
this
.
prop
.
value
&
&
!
isVariable
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
this
.
remove
(
direction
)
;
return
;
}
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
this
.
prop
.
setName
(
properties
[
0
]
.
name
)
;
this
.
committed
.
name
=
this
.
prop
.
name
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
if
(
properties
.
length
>
1
)
{
this
.
prop
.
setValue
(
properties
[
0
]
.
value
properties
[
0
]
.
priority
)
;
this
.
ruleEditor
.
addProperties
(
properties
.
slice
(
1
)
this
.
prop
)
;
}
}
}
;
remove
(
direction
)
{
if
(
this
.
#
colorSwatchSpans
&
&
this
.
#
colorSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
#
colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
removeSwatch
(
span
)
;
}
}
if
(
this
.
angleSwatchSpans
&
&
this
.
angleSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
angleSwatchSpans
)
{
span
.
removeEventListener
(
"
unit
-
change
"
this
.
#
onSwatchCommit
)
;
}
}
if
(
this
.
abortController
)
{
this
.
abortController
.
abort
(
)
;
this
.
abortController
=
null
;
}
this
.
element
.
remove
(
)
;
this
.
ruleEditor
.
rule
.
editClosestTextProperty
(
this
.
prop
direction
)
;
this
.
nameSpan
.
textProperty
=
null
;
this
.
valueSpan
.
textProperty
=
null
;
this
.
#
elementsWithPendingClicks
.
delete
(
this
.
valueSpan
)
;
this
.
prop
.
remove
(
)
;
}
#
onValueDone
=
(
value
=
"
"
commit
direction
)
=
>
{
const
parsedProperties
=
this
.
#
getValueAndExtraProperties
(
value
)
;
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
parsedProperties
.
firstValue
)
;
const
isValueUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
(
!
parsedProperties
.
propertiesToAdd
.
length
&
&
this
.
committed
.
value
=
=
=
val
.
value
&
&
this
.
committed
.
priority
=
=
=
val
.
priority
)
;
const
isVariable
=
this
.
prop
.
name
.
startsWith
(
"
-
-
"
)
;
if
(
(
value
.
trim
(
)
|
|
isVariable
)
&
&
isValueUnchanged
)
{
const
onPropertySet
=
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
return
onPropertySet
;
}
if
(
this
.
#
isDraggableProperty
(
val
)
)
{
this
.
#
addDraggingCapability
(
)
;
}
else
{
this
.
#
removeDraggingCapacity
(
)
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
)
;
const
onPropertySet
=
this
.
prop
.
setValue
(
val
.
value
val
.
priority
)
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
committed
.
priority
=
this
.
prop
.
priority
;
this
.
ruleEditor
.
addProperties
(
parsedProperties
.
propertiesToAdd
this
.
prop
)
;
if
(
!
value
.
trim
(
)
&
&
!
isVariable
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
setTimeout
(
(
)
=
>
{
if
(
!
this
.
editing
)
{
this
.
remove
(
direction
)
;
}
}
0
)
;
}
return
onPropertySet
;
}
;
#
onSwatchCommit
=
(
)
=
>
{
this
.
#
onValueDone
(
this
.
valueSpan
.
textContent
true
)
;
this
.
update
(
)
;
}
;
#
onSwatchPreview
=
(
)
=
>
{
this
.
#
previewValue
(
this
.
valueSpan
.
textContent
)
;
}
;
#
onSwatchRevert
=
(
)
=
>
{
this
.
#
previewValue
(
this
.
prop
.
value
true
)
;
this
.
update
(
)
;
}
;
#
getValueAndExtraProperties
(
value
)
{
let
firstValue
=
value
;
let
propertiesToAdd
=
[
]
;
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
if
(
!
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
else
if
(
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
name
+
"
:
"
+
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
}
return
{
propertiesToAdd
firstValue
}
;
}
#
previewValue
=
(
value
reverting
=
false
)
=
>
{
if
(
!
reverting
&
&
(
!
this
.
editing
|
|
this
.
ruleEditor
.
isEditing
)
)
{
return
;
}
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
value
)
;
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
}
;
#
hasSmallIncrementModifier
(
event
)
{
const
modifier
=
lazy
.
AppConstants
.
platform
=
=
=
"
macosx
"
?
"
altKey
"
:
"
ctrlKey
"
;
return
event
[
modifier
]
=
=
=
true
;
}
#
parseDimension
(
value
)
{
const
cssDimensionRegex
=
/
^
(
?
<
value
>
[
+
-
]
?
(
\
d
*
\
.
)
?
\
d
+
(
e
[
+
-
]
?
\
d
+
)
?
)
(
?
<
unit
>
(
%
|
[
a
-
zA
-
Z
]
+
)
)
/
;
return
value
.
match
(
cssDimensionRegex
)
;
}
#
isDraggableProperty
(
textProperty
)
{
if
(
!
this
.
ruleView
.
draggablePropertiesEnabled
)
{
return
false
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
ELEMENT_STYLE
)
{
return
false
;
}
const
nbValues
=
textProperty
.
value
.
split
(
"
"
)
.
length
;
if
(
nbValues
>
1
)
{
return
false
;
}
const
dimensionMatchObj
=
this
.
#
parseDimension
(
textProperty
.
value
)
;
return
!
!
dimensionMatchObj
;
}
#
draggingOnPointerDown
=
event
=
>
{
if
(
event
.
pointerType
!
=
"
mouse
"
)
{
return
;
}
this
.
#
isDragging
=
true
;
this
.
valueSpan
.
setPointerCapture
(
event
.
pointerId
)
;
this
.
#
capturingPointerId
=
event
.
pointerId
;
this
.
#
draggingController
=
new
AbortController
(
)
;
const
{
signal
}
=
this
.
#
draggingController
;
this
.
valueSpan
.
classList
.
add
(
IS_DRAGGING_CLASSNAME
)
;
const
dimensionObj
=
this
.
#
parseDimension
(
this
.
prop
.
value
)
;
const
{
value
unit
}
=
dimensionObj
.
groups
;
const
intScreenX
=
Math
.
floor
(
event
.
screenX
+
0
.
5
)
;
this
.
#
draggingValueCache
=
{
isInDeadzone
:
true
previousScreenX
:
intScreenX
value
:
parseFloat
(
value
)
unit
}
;
this
.
valueSpan
.
addEventListener
(
"
mousemove
"
this
.
#
draggingOnMouseMove
{
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
pointerup
"
this
.
#
draggingOnPointerUp
{
signal
}
)
;
this
.
valueSpan
.
addEventListener
(
"
keydown
"
this
.
#
draggingOnKeydown
{
signal
}
)
;
}
;
#
draggingOnMouseMove
=
throttle
(
event
=
>
{
if
(
!
this
.
#
isDragging
)
{
return
;
}
const
{
isInDeadzone
previousScreenX
}
=
this
.
#
draggingValueCache
;
let
deltaX
=
event
.
screenX
-
previousScreenX
;
if
(
isInDeadzone
)
{
if
(
Math
.
abs
(
deltaX
)
<
DRAGGING_DEADZONE_DISTANCE
)
{
return
;
}
deltaX
=
Math
.
sign
(
deltaX
)
*
(
Math
.
abs
(
deltaX
)
-
DRAGGING_DEADZONE_DISTANCE
)
;
this
.
#
draggingValueCache
.
isInDeadzone
=
false
;
}
let
draggingSpeed
=
DEFAULT_DRAGGING_SPEED
;
if
(
event
.
shiftKey
)
{
draggingSpeed
=
FAST_DRAGGING_SPEED
;
}
else
if
(
this
.
#
hasSmallIncrementModifier
(
event
)
)
{
draggingSpeed
=
SLOW_DRAGGING_SPEED
;
}
const
delta
=
deltaX
*
draggingSpeed
;
this
.
#
draggingValueCache
.
previousScreenX
=
event
.
screenX
;
this
.
#
draggingValueCache
.
value
+
=
delta
;
if
(
delta
=
=
0
)
{
return
;
}
const
{
value
unit
}
=
this
.
#
draggingValueCache
;
const
roundedValue
=
Number
.
isInteger
(
value
)
?
value
:
value
.
toFixed
(
1
)
;
this
.
prop
.
setValue
(
roundedValue
+
unit
this
.
prop
.
priority
)
.
then
(
(
)
=
>
this
.
ruleView
.
emitForTests
(
"
property
-
updated
-
by
-
dragging
"
)
)
;
this
.
#
hasDragged
=
true
;
}
30
)
;
#
draggingOnPointerUp
=
(
)
=
>
{
if
(
!
this
.
#
isDragging
)
{
return
;
}
if
(
this
.
#
hasDragged
)
{
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
#
onStopDragging
(
)
;
}
;
#
draggingOnKeydown
=
event
=
>
{
if
(
event
.
key
=
=
"
Escape
"
)
{
this
.
prop
.
setValue
(
this
.
committed
.
value
this
.
committed
.
priority
)
;
this
.
#
onStopDragging
(
)
;
event
.
preventDefault
(
)
;
}
}
;
#
onStopDragging
(
)
{
if
(
this
.
#
hasDragged
&
&
!
this
.
#
hasPendingClick
)
{
this
.
ruleView
.
childHasDragged
=
true
;
}
this
.
#
isDragging
=
false
;
this
.
#
hasDragged
=
false
;
this
.
#
draggingValueCache
=
null
;
if
(
this
.
#
capturingPointerId
!
=
=
null
)
{
this
.
#
capturingPointerId
=
null
;
try
{
this
.
valueSpan
.
releasePointerCapture
(
this
.
#
capturingPointerId
)
;
}
catch
(
e
)
{
}
}
this
.
valueSpan
.
classList
.
remove
(
IS_DRAGGING_CLASSNAME
)
;
this
.
#
draggingController
.
abort
(
)
;
}
#
addDraggingCapability
(
)
{
if
(
this
.
valueSpan
.
classList
.
contains
(
DRAGGABLE_VALUE_CLASSNAME
)
)
{
return
;
}
this
.
valueSpan
.
classList
.
add
(
DRAGGABLE_VALUE_CLASSNAME
)
;
this
.
valueSpan
.
addEventListener
(
"
pointerdown
"
this
.
#
draggingOnPointerDown
{
passive
:
true
}
)
;
}
#
removeDraggingCapacity
(
)
{
if
(
!
this
.
valueSpan
.
classList
.
contains
(
DRAGGABLE_VALUE_CLASSNAME
)
)
{
return
;
}
this
.
#
draggingController
=
null
;
this
.
valueSpan
.
classList
.
remove
(
DRAGGABLE_VALUE_CLASSNAME
)
;
this
.
valueSpan
.
removeEventListener
(
"
pointerdown
"
this
.
#
draggingOnPointerDown
{
passive
:
true
}
)
;
}
isValid
(
)
{
return
this
.
prop
.
isValid
(
)
;
}
#
isNameValid
(
)
{
return
this
.
prop
.
isNameValid
(
)
;
}
#
isInvalidAtComputedValueTime
(
)
{
return
this
.
prop
.
isInvalidAtComputedValueTime
(
)
;
}
#
formatGridTemplateAreasValue
(
)
{
this
.
valueSpan
.
classList
.
add
(
"
ruleview
-
propertyvalue
-
break
-
spaces
"
)
;
let
quoteSymbolsUsed
=
[
]
;
const
getQuoteSymbolsUsed
=
cssValue
=
>
{
const
regex
=
/
\
"
|
\
'
/
g
;
const
found
=
cssValue
.
match
(
regex
)
;
quoteSymbolsUsed
=
found
.
filter
(
(
_
i
)
=
>
i
%
2
=
=
=
0
)
;
}
;
getQuoteSymbolsUsed
(
this
.
valueSpan
.
innerText
)
;
this
.
valueSpan
.
innerText
=
this
.
valueSpan
.
innerText
.
split
(
'
"
'
)
.
filter
(
s
=
>
s
!
=
=
"
"
)
.
map
(
s
=
>
s
.
split
(
"
'
"
)
)
.
flat
(
)
.
map
(
s
=
>
s
.
trim
(
)
.
replace
(
/
\
s
+
/
g
"
"
)
)
.
filter
(
s
=
>
s
.
length
)
.
map
(
line
=
>
line
.
split
(
"
"
)
)
.
map
(
(
line
i
lines
)
=
>
line
.
map
(
(
col
j
)
=
>
col
.
padEnd
(
Math
.
max
(
.
.
.
lines
.
map
(
l
=
>
l
[
j
]
.
length
)
)
"
"
)
)
)
.
map
(
(
line
i
)
=
>
\
n
{
quoteSymbolsUsed
[
i
]
}
+
line
.
join
(
"
"
)
+
quoteSymbolsUsed
[
i
]
)
.
join
(
"
"
)
;
}
}
module
.
exports
=
TextPropertyEditor
;
