"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
l10n
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
InplaceEditor
editableField
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
createChild
appendText
advanceValidate
blurOnMultipleProperties
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
openContentLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseDeclarations
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseSingleValue
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SHARED_SWATCH_CLASS
=
"
ruleview
-
swatch
"
;
const
COLOR_SWATCH_CLASS
=
"
ruleview
-
colorswatch
"
;
const
BEZIER_SWATCH_CLASS
=
"
ruleview
-
bezierswatch
"
;
const
FILTER_SWATCH_CLASS
=
"
ruleview
-
filterswatch
"
;
const
ANGLE_SWATCH_CLASS
=
"
ruleview
-
angleswatch
"
;
const
FONT_FAMILY_CLASS
=
"
ruleview
-
font
-
family
"
;
const
SHAPE_SWATCH_CLASS
=
"
ruleview
-
shapeswatch
"
;
const
ACTIONABLE_ELEMENTS_SELECTORS
=
[
.
{
COLOR_SWATCH_CLASS
}
.
{
BEZIER_SWATCH_CLASS
}
.
{
FILTER_SWATCH_CLASS
}
.
{
ANGLE_SWATCH_CLASS
}
"
a
"
]
;
const
GENERIC_FONT_FAMILIES
=
[
"
serif
"
"
sans
-
serif
"
"
cursive
"
"
fantasy
"
"
monospace
"
"
system
-
ui
"
]
;
function
TextPropertyEditor
(
ruleEditor
property
)
{
this
.
ruleEditor
=
ruleEditor
;
this
.
ruleView
=
this
.
ruleEditor
.
ruleView
;
this
.
cssProperties
=
this
.
ruleView
.
cssProperties
;
this
.
doc
=
this
.
ruleEditor
.
doc
;
this
.
popup
=
this
.
ruleView
.
popup
;
this
.
prop
=
property
;
this
.
prop
.
editor
=
this
;
this
.
browserWindow
=
this
.
doc
.
defaultView
.
top
;
this
.
_populatedComputed
=
false
;
this
.
_hasPendingClick
=
false
;
this
.
_clickedElementOptions
=
null
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
getGridlineNames
=
this
.
getGridlineNames
.
bind
(
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
updatePropertyState
=
this
.
updatePropertyState
.
bind
(
this
)
;
this
.
_onEnableClicked
=
this
.
_onEnableClicked
.
bind
(
this
)
;
this
.
_onExpandClicked
=
this
.
_onExpandClicked
.
bind
(
this
)
;
this
.
_onNameDone
=
this
.
_onNameDone
.
bind
(
this
)
;
this
.
_onStartEditing
=
this
.
_onStartEditing
.
bind
(
this
)
;
this
.
_onSwatchCommit
=
this
.
_onSwatchCommit
.
bind
(
this
)
;
this
.
_onSwatchPreview
=
this
.
_onSwatchPreview
.
bind
(
this
)
;
this
.
_onSwatchRevert
=
this
.
_onSwatchRevert
.
bind
(
this
)
;
this
.
_onValidate
=
this
.
ruleView
.
debounce
(
this
.
_previewValue
10
this
)
;
this
.
_onValueDone
=
this
.
_onValueDone
.
bind
(
this
)
;
this
.
_create
(
)
;
this
.
update
(
)
;
}
TextPropertyEditor
.
prototype
=
{
get
editing
(
)
{
return
!
!
(
this
.
nameSpan
.
inplaceEditor
|
|
this
.
valueSpan
.
inplaceEditor
|
|
this
.
ruleView
.
tooltips
.
isEditing
)
|
|
this
.
popup
.
isOpen
;
}
get
rule
(
)
{
return
this
.
prop
.
rule
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
this
.
element
.
classList
.
add
(
"
ruleview
-
property
"
)
;
this
.
element
.
_textPropertyEditor
=
this
;
this
.
container
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
propertycontainer
inline
-
tooltip
-
container
"
}
)
;
this
.
enable
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
enableproperty
theme
-
checkbox
"
tabindex
:
"
-
1
"
}
)
;
this
.
nameContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
this
.
nameSpan
=
createChild
(
this
.
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
appendText
(
this
.
nameContainer
"
:
"
)
;
this
.
expander
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
expander
theme
-
twisty
"
}
)
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onExpandClicked
true
)
;
this
.
valueContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
this
.
valueSpan
=
createChild
(
this
.
valueContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
this
.
valueSpan
.
textProperty
=
this
.
prop
;
this
.
nameSpan
.
textProperty
=
this
.
prop
;
appendText
(
this
.
valueContainer
"
;
"
)
;
this
.
warning
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
warning
"
hidden
:
"
"
title
:
l10n
(
"
rule
.
warning
.
title
"
)
}
)
;
this
.
filterProperty
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
overridden
-
rule
-
filter
"
hidden
:
"
"
title
:
l10n
(
"
rule
.
filterProperty
.
title
"
)
}
)
;
this
.
filterProperty
.
addEventListener
(
"
click
"
event
=
>
{
this
.
ruleEditor
.
ruleView
.
setFilterStyles
(
"
"
+
this
.
prop
.
name
+
"
"
)
;
event
.
stopPropagation
(
)
;
}
)
;
this
.
computed
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
computedlist
"
}
)
;
this
.
shorthandOverridden
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
overridden
-
items
"
}
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
this
.
enable
.
addEventListener
(
"
click
"
this
.
_onEnableClicked
true
)
;
this
.
nameContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
nameContainer
)
{
this
.
nameSpan
.
click
(
)
;
}
}
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
nameSpan
done
:
this
.
_onNameDone
destroy
:
this
.
updatePropertyState
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
popup
cssProperties
:
this
.
cssProperties
}
)
;
this
.
nameContainer
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
cssProperties
)
)
;
this
.
valueContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
valueContainer
)
{
this
.
valueSpan
.
click
(
)
;
}
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
const
clickedEl
=
event
.
target
;
if
(
clickedEl
=
=
=
this
.
valueSpan
)
{
return
;
}
this
.
_hasPendingClick
=
true
;
const
matchedSelector
=
ACTIONABLE_ELEMENTS_SELECTORS
.
find
(
(
selector
)
=
>
clickedEl
.
matches
(
selector
)
)
;
if
(
matchedSelector
)
{
const
similarElements
=
[
.
.
.
this
.
valueSpan
.
querySelectorAll
(
matchedSelector
)
]
;
this
.
_clickedElementOptions
=
{
selector
:
matchedSelector
index
:
similarElements
.
indexOf
(
clickedEl
)
}
;
}
}
)
;
this
.
valueSpan
.
addEventListener
(
"
mouseup
"
(
event
)
=
>
{
this
.
_clickedElementOptions
=
null
;
this
.
_hasPendingClick
=
false
;
}
)
;
this
.
valueSpan
.
addEventListener
(
"
click
"
(
event
)
=
>
{
const
target
=
event
.
target
;
if
(
target
.
nodeName
=
=
=
"
a
"
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
openContentLink
(
target
.
href
)
;
}
}
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
valueSpan
done
:
this
.
_onValueDone
destroy
:
this
.
update
validate
:
this
.
_onValidate
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
this
.
prop
defaultIncrement
:
this
.
prop
.
name
=
=
=
"
opacity
"
?
0
.
1
:
1
popup
:
this
.
popup
multiline
:
true
maxWidth
:
(
)
=
>
this
.
container
.
getBoundingClientRect
(
)
.
width
cssProperties
:
this
.
cssProperties
cssVariables
:
this
.
rule
.
elementStyle
.
variables
getGridLineNames
:
this
.
getGridlineNames
}
)
;
}
}
getGridlineNames
:
async
function
(
)
{
const
gridLineNames
=
{
cols
:
[
]
rows
:
[
]
}
;
const
layoutInspector
=
await
this
.
ruleView
.
inspector
.
walker
.
getLayoutInspector
(
)
;
const
gridFront
=
await
layoutInspector
.
getCurrentGrid
(
this
.
ruleView
.
inspector
.
selection
.
nodeFront
)
;
if
(
gridFront
)
{
const
gridFragments
=
gridFront
.
gridFragments
;
for
(
const
gridFragment
of
gridFragments
)
{
for
(
const
rowLine
of
gridFragment
.
rows
.
lines
)
{
gridLineNames
.
rows
=
gridLineNames
.
rows
.
concat
(
rowLine
.
names
)
;
}
for
(
const
colLine
of
gridFragment
.
cols
.
lines
)
{
gridLineNames
.
cols
=
gridLineNames
.
cols
.
concat
(
colLine
.
names
)
;
}
}
}
this
.
ruleView
.
inspector
.
emit
(
"
grid
-
line
-
names
-
updated
"
)
;
return
gridLineNames
;
}
get
sheetHref
(
)
{
const
domRule
=
this
.
rule
.
domRule
;
if
(
domRule
)
{
return
domRule
.
href
|
|
domRule
.
nodeHref
;
}
return
undefined
;
}
update
:
function
(
)
{
if
(
this
.
ruleView
.
isDestroyed
)
{
return
;
}
this
.
updatePropertyState
(
)
;
const
name
=
this
.
prop
.
name
;
this
.
nameSpan
.
textContent
=
name
;
const
store
=
this
.
rule
.
elementStyle
.
store
;
let
val
=
store
.
userProperties
.
getProperty
(
this
.
rule
.
domRule
name
this
.
prop
.
value
)
;
if
(
this
.
prop
.
priority
)
{
val
+
=
"
!
"
+
this
.
prop
.
priority
;
}
const
propDirty
=
store
.
userProperties
.
contains
(
this
.
rule
.
domRule
name
)
;
if
(
propDirty
)
{
this
.
element
.
setAttribute
(
"
dirty
"
"
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
dirty
"
)
;
}
const
outputParser
=
this
.
ruleView
.
_outputParser
;
const
parserOptions
=
{
angleClass
:
"
ruleview
-
angle
"
angleSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
ANGLE_SWATCH_CLASS
bezierClass
:
"
ruleview
-
bezier
"
bezierSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
BEZIER_SWATCH_CLASS
colorClass
:
"
ruleview
-
color
"
colorSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
COLOR_SWATCH_CLASS
filterClass
:
"
ruleview
-
filter
"
filterSwatchClass
:
SHARED_SWATCH_CLASS
+
"
"
+
FILTER_SWATCH_CLASS
flexClass
:
"
ruleview
-
flex
"
gridClass
:
"
ruleview
-
grid
"
shapeClass
:
"
ruleview
-
shape
"
shapeSwatchClass
:
SHAPE_SWATCH_CLASS
defaultColorType
:
!
propDirty
urlClass
:
"
theme
-
link
"
fontFamilyClass
:
FONT_FAMILY_CLASS
baseURI
:
this
.
sheetHref
unmatchedVariableClass
:
"
ruleview
-
unmatched
-
variable
"
matchedVariableClass
:
"
ruleview
-
variable
"
isVariableInUse
:
varName
=
>
this
.
rule
.
elementStyle
.
getVariable
(
varName
)
}
;
const
frag
=
outputParser
.
parseCssProperty
(
name
val
parserOptions
)
;
if
(
!
this
.
committed
)
{
this
.
committed
=
{
name
value
:
frag
.
textContent
priority
:
this
.
prop
.
priority
}
;
}
this
.
valueSpan
.
innerHTML
=
"
"
;
this
.
valueSpan
.
appendChild
(
frag
)
;
this
.
ruleView
.
emit
(
"
property
-
value
-
updated
"
{
rule
:
this
.
prop
.
rule
property
:
name
value
:
val
}
)
;
const
fontFamilySpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
FONT_FAMILY_CLASS
)
;
if
(
fontFamilySpans
.
length
&
&
this
.
prop
.
enabled
&
&
!
this
.
prop
.
overridden
)
{
this
.
rule
.
elementStyle
.
getUsedFontFamilies
(
)
.
then
(
families
=
>
{
const
usedFontFamilies
=
families
.
map
(
font
=
>
font
.
toLowerCase
(
)
)
;
let
foundMatchingFamily
=
false
;
let
firstGenericSpan
=
null
;
for
(
const
span
of
fontFamilySpans
)
{
const
authoredFont
=
span
.
textContent
.
toLowerCase
(
)
;
if
(
!
firstGenericSpan
&
&
GENERIC_FONT_FAMILIES
.
includes
(
authoredFont
)
)
{
firstGenericSpan
=
span
;
}
if
(
usedFontFamilies
.
includes
(
authoredFont
)
)
{
span
.
classList
.
add
(
"
used
-
font
"
)
;
foundMatchingFamily
=
true
;
}
}
if
(
!
foundMatchingFamily
&
&
firstGenericSpan
)
{
firstGenericSpan
.
classList
.
add
(
"
used
-
font
"
)
;
}
this
.
ruleView
.
emit
(
"
font
-
highlighted
"
this
.
valueSpan
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
"
Could
not
get
the
list
of
font
families
"
e
)
)
;
}
this
.
_colorSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
COLOR_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
colorSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
span
.
dataset
.
propertyName
=
this
.
nameSpan
.
textContent
;
}
}
this
.
_bezierSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
BEZIER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
span
of
this
.
_bezierSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
cubicBezier
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
const
title
=
l10n
(
"
rule
.
bezierSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
const
span
=
this
.
valueSpan
.
querySelector
(
"
.
"
+
FILTER_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
if
(
span
)
{
parserOptions
.
filterSwatch
=
true
;
this
.
ruleView
.
tooltips
.
getTooltip
(
"
filterEditor
"
)
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
outputParser
parserOptions
)
;
const
title
=
l10n
(
"
rule
.
filterSwatch
.
tooltip
"
)
;
span
.
setAttribute
(
"
title
"
title
)
;
}
}
this
.
angleSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
ANGLE_SWATCH_CLASS
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
const
angleSpan
of
this
.
angleSwatchSpans
)
{
angleSpan
.
on
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
const
title
=
l10n
(
"
rule
.
angleSwatch
.
tooltip
"
)
;
angleSpan
.
setAttribute
(
"
title
"
title
)
;
}
}
const
nodeFront
=
this
.
ruleView
.
inspector
.
selection
.
nodeFront
;
const
flexToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
flex
"
)
;
if
(
flexToggle
)
{
flexToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
flexToggle
.
tooltip
"
)
)
;
flexToggle
.
classList
.
toggle
(
"
active
"
this
.
ruleView
.
highlighters
.
flexboxHighlighterShown
=
=
=
nodeFront
)
;
}
const
gridToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
grid
"
)
;
if
(
gridToggle
)
{
gridToggle
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
gridToggle
.
tooltip
"
)
)
;
gridToggle
.
classList
.
toggle
(
"
active
"
this
.
ruleView
.
highlighters
.
gridHighlighters
.
has
(
nodeFront
)
)
;
gridToggle
.
toggleAttribute
(
"
disabled
"
!
this
.
ruleView
.
highlighters
.
canGridHighlighterToggle
(
nodeFront
)
)
;
}
const
shapeToggle
=
this
.
valueSpan
.
querySelector
(
"
.
ruleview
-
shapeswatch
"
)
;
if
(
shapeToggle
)
{
const
mode
=
"
css
"
+
name
.
split
(
"
-
"
)
.
map
(
s
=
>
{
return
s
[
0
]
.
toUpperCase
(
)
+
s
.
slice
(
1
)
;
}
)
.
join
(
"
"
)
;
shapeToggle
.
setAttribute
(
"
data
-
mode
"
mode
)
;
}
if
(
this
.
_hasPendingClick
)
{
this
.
_hasPendingClick
=
false
;
let
elToClick
;
if
(
this
.
_clickedElementOptions
!
=
=
null
)
{
const
{
selector
index
}
=
this
.
_clickedElementOptions
;
elToClick
=
this
.
valueSpan
.
querySelectorAll
(
selector
)
[
index
]
;
this
.
_clickedElementOptions
=
null
;
}
if
(
!
elToClick
)
{
elToClick
=
this
.
valueSpan
;
}
elToClick
.
click
(
)
;
}
this
.
_updateComputed
(
)
;
this
.
_updateShorthandOverridden
(
)
;
this
.
ruleView
.
_updatePropertyHighlight
(
this
)
;
}
_onStartEditing
:
function
(
)
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
this
.
filterProperty
.
hidden
=
true
;
this
.
enable
.
style
.
visibility
=
"
hidden
"
;
this
.
expander
.
style
.
display
=
"
none
"
;
}
get
shouldShowComputedExpander
(
)
{
return
this
.
prop
.
computed
.
some
(
c
=
>
c
.
name
!
=
=
this
.
prop
.
name
)
&
&
!
this
.
prop
.
computed
.
every
(
c
=
>
!
c
.
value
)
;
}
updatePropertyState
:
function
(
)
{
if
(
this
.
prop
.
enabled
)
{
this
.
enable
.
style
.
removeProperty
(
"
visibility
"
)
;
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
else
{
this
.
enable
.
style
.
visibility
=
"
visible
"
;
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
this
.
warning
.
title
=
!
this
.
isNameValid
(
)
?
l10n
(
"
rule
.
warningName
.
title
"
)
:
l10n
(
"
rule
.
warning
.
title
"
)
;
this
.
warning
.
hidden
=
this
.
editing
|
|
this
.
isValid
(
)
;
this
.
filterProperty
.
hidden
=
this
.
editing
|
|
!
this
.
isValid
(
)
|
|
!
this
.
prop
.
overridden
|
|
this
.
ruleEditor
.
rule
.
isUnmatched
;
this
.
expander
.
style
.
display
=
this
.
shouldShowComputedExpander
?
"
inline
-
block
"
:
"
none
"
;
if
(
!
this
.
editing
&
&
(
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
!
this
.
prop
.
isKnownProperty
)
)
{
this
.
element
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
else
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
}
}
_updateComputed
:
function
(
)
{
this
.
computed
.
innerHTML
=
"
"
;
this
.
expander
.
style
.
display
=
!
this
.
editing
&
&
this
.
shouldShowComputedExpander
?
"
inline
-
block
"
:
"
none
"
;
this
.
_populatedComputed
=
false
;
if
(
this
.
expander
.
hasAttribute
(
"
open
"
)
)
{
this
.
_populateComputed
(
)
;
}
}
_populateComputed
:
function
(
)
{
if
(
this
.
_populatedComputed
)
{
return
;
}
this
.
_populatedComputed
=
true
;
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
)
{
continue
;
}
computed
.
element
=
this
.
_createComputedListItem
(
this
.
computed
computed
"
ruleview
-
computed
"
)
;
}
}
_updateShorthandOverridden
:
function
(
)
{
this
.
shorthandOverridden
.
innerHTML
=
"
"
;
this
.
_populatedShorthandOverridden
=
false
;
this
.
_populateShorthandOverridden
(
)
;
}
_populateShorthandOverridden
:
function
(
)
{
if
(
this
.
_populatedShorthandOverridden
|
|
this
.
prop
.
overridden
|
|
!
this
.
shouldShowComputedExpander
)
{
return
;
}
this
.
_populatedShorthandOverridden
=
true
;
for
(
const
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
|
|
!
computed
.
overridden
)
{
continue
;
}
this
.
_createComputedListItem
(
this
.
shorthandOverridden
computed
"
ruleview
-
overridden
-
item
"
)
;
}
}
_createComputedListItem
:
function
(
parentEl
computed
className
)
{
const
li
=
createChild
(
parentEl
"
li
"
{
class
:
className
}
)
;
if
(
computed
.
overridden
)
{
li
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
const
nameContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
createChild
(
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color3
"
textContent
:
computed
.
name
}
)
;
appendText
(
nameContainer
"
:
"
)
;
const
outputParser
=
this
.
ruleView
.
_outputParser
;
const
frag
=
outputParser
.
parseCssProperty
(
computed
.
name
computed
.
value
{
colorSwatchClass
:
"
ruleview
-
swatch
ruleview
-
colorswatch
"
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetHref
fontFamilyClass
:
"
ruleview
-
font
-
family
"
}
)
;
computed
.
parsedValue
=
frag
.
textContent
;
const
propertyContainer
=
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
createChild
(
propertyContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
child
:
frag
}
)
;
appendText
(
propertyContainer
"
;
"
)
;
return
li
;
}
_onEnableClicked
:
function
(
event
)
{
const
checked
=
this
.
enable
.
hasAttribute
(
"
checked
"
)
;
if
(
checked
)
{
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
else
{
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
this
.
prop
.
setEnabled
(
!
checked
)
;
event
.
stopPropagation
(
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
"
session_id
"
:
this
.
toolbox
.
sessionId
}
)
;
}
_onExpandClicked
:
function
(
event
)
{
if
(
this
.
computed
.
hasAttribute
(
"
filter
-
open
"
)
|
|
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
this
.
computed
.
removeAttribute
(
"
user
-
open
"
)
;
this
.
shorthandOverridden
.
removeAttribute
(
"
hidden
"
)
;
this
.
_populateShorthandOverridden
(
)
;
}
else
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
user
-
open
"
"
"
)
;
this
.
shorthandOverridden
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
_populateComputed
(
)
;
}
event
.
stopPropagation
(
)
;
}
expandForFilter
:
function
(
)
{
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
filter
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
}
collapseForFilter
:
function
(
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
}
}
_onNameDone
:
function
(
value
commit
direction
)
{
const
isNameUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
this
.
committed
.
name
=
=
=
value
;
if
(
this
.
prop
.
value
&
&
isNameUnchanged
)
{
return
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
"
session_id
"
:
this
.
toolbox
.
sessionId
}
)
;
if
(
!
value
.
trim
(
)
)
{
this
.
remove
(
direction
)
;
return
;
}
if
(
!
this
.
prop
.
value
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
this
.
remove
(
direction
)
;
return
;
}
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
this
.
prop
.
setName
(
properties
[
0
]
.
name
)
;
this
.
committed
.
name
=
this
.
prop
.
name
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
if
(
properties
.
length
>
1
)
{
this
.
prop
.
setValue
(
properties
[
0
]
.
value
properties
[
0
]
.
priority
)
;
this
.
ruleEditor
.
addProperties
(
properties
.
slice
(
1
)
this
.
prop
)
;
}
}
}
remove
:
function
(
direction
)
{
if
(
this
.
_colorSwatchSpans
&
&
this
.
_colorSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
getTooltip
(
"
colorPicker
"
)
.
removeSwatch
(
span
)
;
span
.
off
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
}
}
if
(
this
.
angleSwatchSpans
&
&
this
.
angleSwatchSpans
.
length
)
{
for
(
const
span
of
this
.
angleSwatchSpans
)
{
span
.
off
(
"
unit
-
change
"
this
.
_onSwatchCommit
)
;
}
}
this
.
element
.
remove
(
)
;
this
.
ruleEditor
.
rule
.
editClosestTextProperty
(
this
.
prop
direction
)
;
this
.
nameSpan
.
textProperty
=
null
;
this
.
valueSpan
.
textProperty
=
null
;
this
.
prop
.
remove
(
)
;
}
_onValueDone
:
function
(
value
=
"
"
commit
direction
)
{
const
parsedProperties
=
this
.
_getValueAndExtraProperties
(
value
)
;
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
parsedProperties
.
firstValue
)
;
const
isValueUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
!
parsedProperties
.
propertiesToAdd
.
length
&
&
this
.
committed
.
value
=
=
=
val
.
value
&
&
this
.
committed
.
priority
=
=
=
val
.
priority
;
if
(
value
.
trim
(
)
&
&
isValueUnchanged
)
{
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
return
;
}
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
"
session_id
"
:
this
.
toolbox
.
sessionId
}
)
;
if
(
this
.
isDisplayFlex
(
)
)
{
this
.
ruleView
.
highlighters
.
hideFlexboxHighlighter
(
)
;
}
if
(
this
.
isDisplayGrid
(
)
)
{
this
.
ruleView
.
highlighters
.
hideGridHighlighter
(
this
.
ruleView
.
inspector
.
selection
.
nodeFront
)
;
}
this
.
prop
.
setValue
(
val
.
value
val
.
priority
)
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
committed
.
priority
=
this
.
prop
.
priority
;
this
.
ruleEditor
.
addProperties
(
parsedProperties
.
propertiesToAdd
this
.
prop
)
;
if
(
!
value
.
trim
(
)
&
&
direction
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
setTimeout
(
(
)
=
>
{
if
(
!
this
.
editing
)
{
this
.
remove
(
direction
)
;
}
}
0
)
;
}
}
_onSwatchCommit
:
function
(
)
{
this
.
_onValueDone
(
this
.
valueSpan
.
textContent
true
)
;
this
.
update
(
)
;
}
_onSwatchPreview
:
function
(
)
{
this
.
_previewValue
(
this
.
valueSpan
.
textContent
)
;
}
_onSwatchRevert
:
function
(
)
{
this
.
_previewValue
(
this
.
prop
.
value
true
)
;
this
.
update
(
)
;
}
_getValueAndExtraProperties
:
function
(
value
)
{
let
firstValue
=
value
;
let
propertiesToAdd
=
[
]
;
const
properties
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
properties
.
length
)
{
if
(
!
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
else
if
(
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
name
+
"
:
"
+
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
}
return
{
propertiesToAdd
:
propertiesToAdd
firstValue
:
firstValue
}
;
}
_previewValue
:
function
(
value
reverting
=
false
)
{
if
(
!
reverting
&
&
(
!
this
.
editing
|
|
this
.
ruleEditor
.
isEditing
)
)
{
return
;
}
const
val
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
value
)
;
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
}
isValid
:
function
(
)
{
return
this
.
prop
.
isValid
(
)
;
}
isNameValid
:
function
(
)
{
return
this
.
prop
.
isNameValid
(
)
;
}
isDisplayFlex
:
function
(
)
{
return
this
.
prop
.
name
=
=
=
"
display
"
&
&
(
this
.
prop
.
value
=
=
=
"
flex
"
|
|
this
.
prop
.
value
=
=
=
"
inline
-
flex
"
)
;
}
isDisplayGrid
:
function
(
)
{
return
this
.
prop
.
name
=
=
=
"
display
"
&
&
(
this
.
prop
.
value
=
=
=
"
grid
"
|
|
this
.
prop
.
value
=
=
=
"
inline
-
grid
"
)
;
}
}
;
module
.
exports
=
TextPropertyEditor
;
