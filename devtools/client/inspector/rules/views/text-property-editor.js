"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
CssLogic
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
InplaceEditor
editableField
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
createChild
appendText
advanceValidate
blurOnMultipleProperties
throttle
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
parseDeclarations
parseSingleValue
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
parsing
-
utils
"
)
;
const
{
setTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
IOService
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
function
TextPropertyEditor
(
ruleEditor
property
)
{
this
.
ruleEditor
=
ruleEditor
;
this
.
ruleView
=
this
.
ruleEditor
.
ruleView
;
this
.
doc
=
this
.
ruleEditor
.
doc
;
this
.
popup
=
this
.
ruleView
.
popup
;
this
.
prop
=
property
;
this
.
prop
.
editor
=
this
;
this
.
browserWindow
=
this
.
doc
.
defaultView
.
top
;
this
.
_populatedComputed
=
false
;
this
.
_onEnableClicked
=
this
.
_onEnableClicked
.
bind
(
this
)
;
this
.
_onExpandClicked
=
this
.
_onExpandClicked
.
bind
(
this
)
;
this
.
_onStartEditing
=
this
.
_onStartEditing
.
bind
(
this
)
;
this
.
_onNameDone
=
this
.
_onNameDone
.
bind
(
this
)
;
this
.
_onValueDone
=
this
.
_onValueDone
.
bind
(
this
)
;
this
.
_onSwatchCommit
=
this
.
_onSwatchCommit
.
bind
(
this
)
;
this
.
_onSwatchPreview
=
this
.
_onSwatchPreview
.
bind
(
this
)
;
this
.
_onSwatchRevert
=
this
.
_onSwatchRevert
.
bind
(
this
)
;
this
.
_onValidate
=
throttle
(
this
.
_previewValue
10
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
_create
(
)
;
this
.
update
(
)
;
}
TextPropertyEditor
.
prototype
=
{
get
editing
(
)
{
return
!
!
(
this
.
nameSpan
.
inplaceEditor
|
|
this
.
valueSpan
.
inplaceEditor
|
|
this
.
ruleView
.
tooltips
.
isEditing
)
|
|
this
.
popup
.
isOpen
;
}
get
rule
(
)
{
return
this
.
prop
.
rule
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
li
"
)
;
this
.
element
.
classList
.
add
(
"
ruleview
-
property
"
)
;
this
.
element
.
_textPropertyEditor
=
this
;
this
.
container
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
propertycontainer
"
}
)
;
this
.
enable
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
enableproperty
theme
-
checkbox
"
tabindex
:
"
-
1
"
}
)
;
this
.
expander
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
expander
theme
-
twisty
"
}
)
;
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onExpandClicked
true
)
;
this
.
nameContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
namecontainer
"
}
)
;
this
.
nameSpan
=
createChild
(
this
.
nameContainer
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color5
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
appendText
(
this
.
nameContainer
"
:
"
)
;
this
.
valueContainer
=
createChild
(
this
.
container
"
span
"
{
class
:
"
ruleview
-
propertyvaluecontainer
"
}
)
;
this
.
valueSpan
=
createChild
(
this
.
valueContainer
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
tabindex
:
this
.
ruleEditor
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
this
.
valueSpan
.
textProperty
=
this
.
prop
;
this
.
nameSpan
.
textProperty
=
this
.
prop
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
this
.
prop
.
name
this
.
prop
.
value
)
;
let
parsedValue
=
frag
.
textContent
;
this
.
committed
=
{
name
:
this
.
prop
.
name
value
:
parsedValue
priority
:
this
.
prop
.
priority
}
;
appendText
(
this
.
valueContainer
"
;
"
)
;
this
.
warning
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
warning
"
hidden
:
"
"
title
:
CssLogic
.
l10n
(
"
rule
.
warning
.
title
"
)
}
)
;
this
.
filterProperty
=
createChild
(
this
.
container
"
div
"
{
class
:
"
ruleview
-
overridden
-
rule
-
filter
"
hidden
:
"
"
title
:
CssLogic
.
l10n
(
"
rule
.
filterProperty
.
title
"
)
}
)
;
this
.
filterProperty
.
addEventListener
(
"
click
"
event
=
>
{
this
.
ruleEditor
.
ruleView
.
setFilterStyles
(
"
"
+
this
.
prop
.
name
+
"
"
)
;
event
.
stopPropagation
(
)
;
}
false
)
;
this
.
computed
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
computedlist
"
}
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
this
.
enable
.
addEventListener
(
"
click
"
this
.
_onEnableClicked
true
)
;
this
.
nameContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
nameContainer
)
{
this
.
nameSpan
.
click
(
)
;
}
}
false
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
nameSpan
done
:
this
.
_onNameDone
destroy
:
this
.
update
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
popup
}
)
;
this
.
nameContainer
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
false
)
;
this
.
valueContainer
.
addEventListener
(
"
click
"
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
=
=
=
this
.
valueContainer
)
{
this
.
valueSpan
.
click
(
)
;
}
}
false
)
;
this
.
valueSpan
.
addEventListener
(
"
click
"
(
event
)
=
>
{
let
target
=
event
.
target
;
if
(
target
.
nodeName
=
=
=
"
a
"
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
browserWindow
.
openUILinkIn
(
target
.
href
"
tab
"
)
;
}
}
false
)
;
editableField
(
{
start
:
this
.
_onStartEditing
element
:
this
.
valueSpan
done
:
this
.
_onValueDone
destroy
:
this
.
update
validate
:
this
.
_onValidate
advanceChars
:
advanceValidate
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_VALUE
property
:
this
.
prop
popup
:
this
.
popup
}
)
;
}
}
get
sheetHref
(
)
{
let
domRule
=
this
.
rule
.
domRule
;
if
(
domRule
)
{
return
domRule
.
href
|
|
domRule
.
nodeHref
;
}
}
get
sheetURI
(
)
{
if
(
this
.
_sheetURI
=
=
=
undefined
)
{
if
(
this
.
sheetHref
)
{
this
.
_sheetURI
=
IOService
.
newURI
(
this
.
sheetHref
null
null
)
;
}
else
{
this
.
_sheetURI
=
null
;
}
}
return
this
.
_sheetURI
;
}
resolveURI
:
function
(
relativePath
)
{
if
(
this
.
sheetURI
)
{
relativePath
=
this
.
sheetURI
.
resolve
(
relativePath
)
;
}
return
relativePath
;
}
update
:
function
(
)
{
if
(
this
.
ruleView
.
isDestroyed
)
{
return
;
}
if
(
this
.
prop
.
enabled
)
{
this
.
enable
.
style
.
removeProperty
(
"
visibility
"
)
;
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
else
{
this
.
enable
.
style
.
visibility
=
"
visible
"
;
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
this
.
warning
.
hidden
=
this
.
editing
|
|
this
.
isValid
(
)
;
this
.
filterProperty
.
hidden
=
this
.
editing
|
|
!
this
.
isValid
(
)
|
|
!
this
.
prop
.
overridden
|
|
this
.
ruleEditor
.
rule
.
isUnmatched
;
if
(
!
this
.
editing
&
&
(
this
.
prop
.
overridden
|
|
!
this
.
prop
.
enabled
|
|
!
this
.
prop
.
isKnownProperty
(
)
)
)
{
this
.
element
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
else
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
}
let
name
=
this
.
prop
.
name
;
this
.
nameSpan
.
textContent
=
name
;
let
store
=
this
.
rule
.
elementStyle
.
store
;
let
val
=
store
.
userProperties
.
getProperty
(
this
.
rule
.
style
name
this
.
prop
.
value
)
;
if
(
this
.
prop
.
priority
)
{
val
+
=
"
!
"
+
this
.
prop
.
priority
;
}
let
propDirty
=
store
.
userProperties
.
contains
(
this
.
rule
.
style
name
)
;
if
(
propDirty
)
{
this
.
element
.
setAttribute
(
"
dirty
"
"
"
)
;
}
else
{
this
.
element
.
removeAttribute
(
"
dirty
"
)
;
}
const
sharedSwatchClass
=
"
ruleview
-
swatch
"
;
const
colorSwatchClass
=
"
ruleview
-
colorswatch
"
;
const
bezierSwatchClass
=
"
ruleview
-
bezierswatch
"
;
const
filterSwatchClass
=
"
ruleview
-
filterswatch
"
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
parserOptions
=
{
colorSwatchClass
:
sharedSwatchClass
+
colorSwatchClass
colorClass
:
"
ruleview
-
color
"
bezierSwatchClass
:
sharedSwatchClass
+
bezierSwatchClass
bezierClass
:
"
ruleview
-
bezier
"
filterSwatchClass
:
sharedSwatchClass
+
filterSwatchClass
filterClass
:
"
ruleview
-
filter
"
defaultColorType
:
!
propDirty
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetURI
}
;
let
frag
=
outputParser
.
parseCssProperty
(
name
val
parserOptions
)
;
this
.
valueSpan
.
innerHTML
=
"
"
;
this
.
valueSpan
.
appendChild
(
frag
)
;
this
.
_colorSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
colorSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
let
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
colorPicker
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
}
}
this
.
_bezierSwatchSpans
=
this
.
valueSpan
.
querySelectorAll
(
"
.
"
+
bezierSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
for
(
let
span
of
this
.
_bezierSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
cubicBezier
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
)
;
}
}
let
span
=
this
.
valueSpan
.
querySelector
(
"
.
"
+
filterSwatchClass
)
;
if
(
this
.
ruleEditor
.
isEditable
)
{
if
(
span
)
{
parserOptions
.
filterSwatch
=
true
;
this
.
ruleView
.
tooltips
.
filterEditor
.
addSwatch
(
span
{
onShow
:
this
.
_onStartEditing
onPreview
:
this
.
_onSwatchPreview
onCommit
:
this
.
_onSwatchCommit
onRevert
:
this
.
_onSwatchRevert
}
outputParser
parserOptions
)
;
}
}
this
.
_updateComputed
(
)
;
this
.
ruleView
.
_updatePropertyHighlight
(
this
)
;
}
_onStartEditing
:
function
(
)
{
this
.
element
.
classList
.
remove
(
"
ruleview
-
overridden
"
)
;
this
.
enable
.
style
.
visibility
=
"
hidden
"
;
}
_updateComputed
:
function
(
)
{
this
.
computed
.
innerHTML
=
"
"
;
let
showExpander
=
this
.
prop
.
computed
.
some
(
c
=
>
c
.
name
!
=
=
this
.
prop
.
name
)
;
this
.
expander
.
style
.
visibility
=
showExpander
?
"
visible
"
:
"
hidden
"
;
this
.
_populatedComputed
=
false
;
if
(
this
.
expander
.
hasAttribute
(
"
open
"
)
)
{
this
.
_populateComputed
(
)
;
}
}
_populateComputed
:
function
(
)
{
if
(
this
.
_populatedComputed
)
{
return
;
}
this
.
_populatedComputed
=
true
;
for
(
let
computed
of
this
.
prop
.
computed
)
{
if
(
computed
.
name
=
=
=
this
.
prop
.
name
)
{
continue
;
}
let
li
=
createChild
(
this
.
computed
"
li
"
{
class
:
"
ruleview
-
computed
"
}
)
;
if
(
computed
.
overridden
)
{
li
.
classList
.
add
(
"
ruleview
-
overridden
"
)
;
}
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyname
theme
-
fg
-
color5
"
textContent
:
computed
.
name
}
)
;
appendText
(
li
"
:
"
)
;
let
outputParser
=
this
.
ruleView
.
_outputParser
;
let
frag
=
outputParser
.
parseCssProperty
(
computed
.
name
computed
.
value
{
colorSwatchClass
:
"
ruleview
-
swatch
ruleview
-
colorswatch
"
urlClass
:
"
theme
-
link
"
baseURI
:
this
.
sheetURI
}
)
;
computed
.
parsedValue
=
frag
.
textContent
;
createChild
(
li
"
span
"
{
class
:
"
ruleview
-
propertyvalue
theme
-
fg
-
color1
"
child
:
frag
}
)
;
appendText
(
li
"
;
"
)
;
computed
.
element
=
li
;
}
}
_onEnableClicked
:
function
(
event
)
{
let
checked
=
this
.
enable
.
hasAttribute
(
"
checked
"
)
;
if
(
checked
)
{
this
.
enable
.
removeAttribute
(
"
checked
"
)
;
}
else
{
this
.
enable
.
setAttribute
(
"
checked
"
"
"
)
;
}
this
.
prop
.
setEnabled
(
!
checked
)
;
event
.
stopPropagation
(
)
;
}
_onExpandClicked
:
function
(
event
)
{
if
(
this
.
computed
.
hasAttribute
(
"
filter
-
open
"
)
|
|
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
this
.
computed
.
removeAttribute
(
"
user
-
open
"
)
;
}
else
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
user
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
event
.
stopPropagation
(
)
;
}
expandForFilter
:
function
(
)
{
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
computed
.
setAttribute
(
"
filter
-
open
"
"
"
)
;
this
.
_populateComputed
(
)
;
}
}
collapseForFilter
:
function
(
)
{
this
.
computed
.
removeAttribute
(
"
filter
-
open
"
)
;
if
(
!
this
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
this
.
expander
.
removeAttribute
(
"
open
"
)
;
}
}
_onNameDone
:
function
(
value
commit
direction
)
{
let
isNameUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
this
.
committed
.
name
=
=
=
value
;
if
(
this
.
prop
.
value
&
&
isNameUnchanged
)
{
return
;
}
if
(
!
value
.
trim
(
)
)
{
this
.
remove
(
direction
)
;
return
;
}
if
(
!
this
.
prop
.
value
&
&
direction
!
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_FORWARD
)
{
this
.
remove
(
direction
)
;
return
;
}
let
properties
=
parseDeclarations
(
value
)
;
if
(
properties
.
length
)
{
this
.
prop
.
setName
(
properties
[
0
]
.
name
)
;
this
.
committed
.
name
=
this
.
prop
.
name
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
if
(
properties
.
length
>
1
)
{
this
.
prop
.
setValue
(
properties
[
0
]
.
value
properties
[
0
]
.
priority
)
;
this
.
ruleEditor
.
addProperties
(
properties
.
slice
(
1
)
this
.
prop
)
;
}
}
}
remove
:
function
(
direction
)
{
if
(
this
.
_colorSwatchSpans
&
&
this
.
_colorSwatchSpans
.
length
)
{
for
(
let
span
of
this
.
_colorSwatchSpans
)
{
this
.
ruleView
.
tooltips
.
colorPicker
.
removeSwatch
(
span
)
;
}
}
this
.
element
.
parentNode
.
removeChild
(
this
.
element
)
;
this
.
ruleEditor
.
rule
.
editClosestTextProperty
(
this
.
prop
direction
)
;
this
.
nameSpan
.
textProperty
=
null
;
this
.
valueSpan
.
textProperty
=
null
;
this
.
prop
.
remove
(
)
;
}
_onValueDone
:
function
(
value
=
"
"
commit
direction
)
{
let
parsedProperties
=
this
.
_getValueAndExtraProperties
(
value
)
;
let
val
=
parseSingleValue
(
parsedProperties
.
firstValue
)
;
let
isValueUnchanged
=
(
!
commit
&
&
!
this
.
ruleEditor
.
isEditing
)
|
|
!
parsedProperties
.
propertiesToAdd
.
length
&
&
this
.
committed
.
value
=
=
=
val
.
value
&
&
this
.
committed
.
priority
=
=
=
val
.
priority
;
if
(
value
.
trim
(
)
&
&
isValueUnchanged
)
{
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
this
.
rule
.
setPropertyEnabled
(
this
.
prop
this
.
prop
.
enabled
)
;
return
;
}
this
.
prop
.
setValue
(
val
.
value
val
.
priority
)
;
if
(
!
this
.
prop
.
enabled
)
{
this
.
prop
.
setEnabled
(
true
)
;
}
this
.
committed
.
value
=
this
.
prop
.
value
;
this
.
committed
.
priority
=
this
.
prop
.
priority
;
this
.
ruleEditor
.
addProperties
(
parsedProperties
.
propertiesToAdd
this
.
prop
)
;
if
(
!
value
.
trim
(
)
&
&
direction
!
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_BACKWARD
)
{
setTimeout
(
(
)
=
>
{
if
(
!
this
.
editing
)
{
this
.
remove
(
direction
)
;
}
}
0
)
;
}
}
_onSwatchCommit
:
function
(
)
{
this
.
_onValueDone
(
this
.
valueSpan
.
textContent
true
)
;
this
.
update
(
)
;
}
_onSwatchPreview
:
function
(
)
{
this
.
_previewValue
(
this
.
valueSpan
.
textContent
)
;
}
_onSwatchRevert
:
function
(
)
{
this
.
_previewValue
(
this
.
prop
.
value
true
)
;
this
.
update
(
)
;
}
_getValueAndExtraProperties
:
function
(
value
)
{
let
firstValue
=
value
;
let
propertiesToAdd
=
[
]
;
let
properties
=
parseDeclarations
(
value
)
;
if
(
properties
.
length
)
{
if
(
!
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
else
if
(
properties
[
0
]
.
name
&
&
properties
[
0
]
.
value
)
{
firstValue
=
properties
[
0
]
.
name
+
"
:
"
+
properties
[
0
]
.
value
;
propertiesToAdd
=
properties
.
slice
(
1
)
;
}
}
return
{
propertiesToAdd
:
propertiesToAdd
firstValue
:
firstValue
}
;
}
_previewValue
:
function
(
value
reverting
=
false
)
{
if
(
!
reverting
&
&
(
!
this
.
editing
|
|
this
.
ruleEditor
.
isEditing
)
)
{
return
;
}
let
val
=
parseSingleValue
(
value
)
;
this
.
ruleEditor
.
rule
.
previewPropertyValue
(
this
.
prop
val
.
value
val
.
priority
)
;
}
isValid
:
function
(
)
{
return
this
.
prop
.
isValid
(
)
;
}
}
;
exports
.
TextPropertyEditor
=
TextPropertyEditor
;
