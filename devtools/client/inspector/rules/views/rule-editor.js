"
use
strict
"
;
const
{
l10n
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
constants
.
js
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
)
;
const
Rule
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
models
/
rule
.
js
"
)
;
const
{
InplaceEditor
editableField
editableItem
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
inplace
-
editor
.
js
"
)
;
const
TextPropertyEditor
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
views
/
text
-
property
-
editor
.
js
"
)
;
const
{
createChild
blurOnMultipleProperties
promiseWarn
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
utils
.
js
"
)
;
const
{
parseNamedDeclarations
parsePseudoClassesAndAttributes
SELECTOR_ATTRIBUTE
SELECTOR_ELEMENT
SELECTOR_PSEUDO_CLASS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
parsing
-
utils
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
CssLogic
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
Tools
"
"
resource
:
/
/
devtools
/
client
/
definitions
.
js
"
true
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
const
COMPONENT_PROPERTIES
=
"
devtools
/
client
/
locales
/
components
.
properties
"
;
const
COMPONENT_L10N
=
new
LocalizationHelper
(
COMPONENT_PROPERTIES
)
;
loader
.
lazyGetter
(
this
"
NEW_PROPERTY_NAME_INPUT_LABEL
"
function
(
)
{
return
STYLE_INSPECTOR_L10N
.
getStr
(
"
rule
.
newPropertyName
.
label
"
)
;
}
)
;
const
INDENT_SIZE
=
2
;
const
INDENT_STR
=
"
"
.
repeat
(
INDENT_SIZE
)
;
function
RuleEditor
(
ruleView
rule
options
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
ruleView
=
ruleView
;
this
.
doc
=
this
.
ruleView
.
styleDocument
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
rule
=
rule
;
this
.
options
=
options
;
this
.
isEditable
=
!
rule
.
isSystem
;
this
.
isEditing
=
false
;
this
.
_onNewProperty
=
this
.
_onNewProperty
.
bind
(
this
)
;
this
.
_newPropertyDestroy
=
this
.
_newPropertyDestroy
.
bind
(
this
)
;
this
.
_onSelectorDone
=
this
.
_onSelectorDone
.
bind
(
this
)
;
this
.
_locationChanged
=
this
.
_locationChanged
.
bind
(
this
)
;
this
.
updateSourceLink
=
this
.
updateSourceLink
.
bind
(
this
)
;
this
.
_onToolChanged
=
this
.
_onToolChanged
.
bind
(
this
)
;
this
.
_updateLocation
=
this
.
_updateLocation
.
bind
(
this
)
;
this
.
_onSourceClick
=
this
.
_onSourceClick
.
bind
(
this
)
;
this
.
rule
.
domRule
.
on
(
"
location
-
changed
"
this
.
_locationChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
this
.
_create
(
)
;
}
RuleEditor
.
prototype
=
{
destroy
(
)
{
this
.
rule
.
domRule
.
off
(
"
location
-
changed
"
)
;
this
.
toolbox
.
off
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
off
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
if
(
this
.
_unsubscribeSourceMap
)
{
this
.
_unsubscribeSourceMap
(
)
;
}
}
get
sourceMapURLService
(
)
{
if
(
!
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
=
this
.
toolbox
.
sourceMapURLService
;
}
return
this
.
_sourceMapURLService
;
}
get
isSelectorEditable
(
)
{
const
trait
=
this
.
isEditable
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
;
return
trait
&
&
!
this
.
rule
.
elementStyle
.
element
.
isAnonymous
;
}
_create
(
)
{
this
.
element
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
element
.
className
=
"
ruleview
-
rule
devtools
-
monospace
"
;
this
.
element
.
dataset
.
ruleId
=
this
.
rule
.
domRule
.
actorID
;
this
.
element
.
setAttribute
(
"
uneditable
"
!
this
.
isEditable
)
;
this
.
element
.
setAttribute
(
"
unmatched
"
this
.
rule
.
isUnmatched
)
;
this
.
element
.
_ruleEditor
=
this
;
this
.
element
.
style
.
position
=
"
relative
"
;
if
(
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
this
.
source
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
source
theme
-
link
"
}
)
;
this
.
source
.
addEventListener
(
"
click
"
this
.
_onSourceClick
)
;
const
sourceLabel
=
this
.
doc
.
createElement
(
"
a
"
)
;
sourceLabel
.
classList
.
add
(
"
ruleview
-
rule
-
source
-
label
"
)
;
this
.
source
.
appendChild
(
sourceLabel
)
;
}
this
.
updateSourceLink
(
)
;
if
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
{
const
ancestorsFrag
=
this
.
doc
.
createDocumentFragment
(
)
;
this
.
rule
.
domRule
.
ancestorData
.
forEach
(
(
ancestorData
index
)
=
>
{
const
ancestorItem
=
this
.
doc
.
createElement
(
"
div
"
)
;
ancestorItem
.
setAttribute
(
"
role
"
"
listitem
"
)
;
ancestorsFrag
.
append
(
ancestorItem
)
;
ancestorItem
.
setAttribute
(
"
data
-
ancestor
-
index
"
index
)
;
ancestorItem
.
classList
.
add
(
"
ruleview
-
rule
-
ancestor
"
)
;
if
(
ancestorData
.
type
)
{
ancestorItem
.
classList
.
add
(
ancestorData
.
type
)
;
}
if
(
index
)
{
createChild
(
ancestorItem
"
span
"
{
class
:
"
ruleview
-
rule
-
indent
"
textContent
:
INDENT_STR
.
repeat
(
index
)
}
)
;
}
const
selectorContainer
=
createChild
(
ancestorItem
"
span
"
{
class
:
"
ruleview
-
rule
-
ancestor
-
selectorcontainer
"
}
)
;
if
(
ancestorData
.
type
=
=
"
container
"
)
{
ancestorItem
.
classList
.
add
(
"
container
-
query
"
"
has
-
tooltip
"
)
;
createChild
(
selectorContainer
"
span
"
{
class
:
"
container
-
query
-
declaration
"
textContent
:
container
{
ancestorData
.
containerName
?
"
"
+
ancestorData
.
containerName
:
"
"
}
}
)
;
const
jumpToNodeButton
=
createChild
(
selectorContainer
"
button
"
{
class
:
"
open
-
inspector
"
title
:
l10n
(
"
rule
.
containerQuery
.
selectContainerButton
.
tooltip
"
)
}
)
;
let
containerNodeFront
;
const
getNodeFront
=
async
(
)
=
>
{
if
(
!
containerNodeFront
)
{
const
res
=
await
this
.
rule
.
domRule
.
getQueryContainerForNode
(
index
this
.
rule
.
inherited
|
|
this
.
ruleView
.
inspector
.
selection
.
nodeFront
)
;
containerNodeFront
=
res
.
node
;
}
return
containerNodeFront
;
}
;
jumpToNodeButton
.
addEventListener
(
"
click
"
async
(
)
=
>
{
const
front
=
await
getNodeFront
(
)
;
if
(
!
front
)
{
return
;
}
this
.
ruleView
.
inspector
.
selection
.
setNodeFront
(
front
)
;
await
this
.
ruleView
.
inspector
.
highlighters
.
hideHighlighterType
(
this
.
ruleView
.
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
)
;
ancestorItem
.
addEventListener
(
"
mouseenter
"
async
(
)
=
>
{
const
front
=
await
getNodeFront
(
)
;
if
(
!
front
)
{
return
;
}
await
this
.
ruleView
.
inspector
.
highlighters
.
showHighlighterTypeForNode
(
this
.
ruleView
.
inspector
.
highlighters
.
TYPES
.
BOXMODEL
front
)
;
}
)
;
ancestorItem
.
addEventListener
(
"
mouseleave
"
async
(
)
=
>
{
await
this
.
ruleView
.
inspector
.
highlighters
.
hideHighlighterType
(
this
.
ruleView
.
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
)
;
createChild
(
selectorContainer
"
span
"
{
textContent
:
"
"
+
ancestorData
.
containerQuery
}
)
;
}
else
if
(
ancestorData
.
type
=
=
"
layer
"
)
{
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
layer
{
ancestorData
.
value
?
"
"
+
ancestorData
.
value
:
"
"
}
)
)
;
}
else
if
(
ancestorData
.
type
=
=
"
media
"
)
{
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
media
{
ancestorData
.
value
}
)
)
;
}
else
if
(
ancestorData
.
type
=
=
"
supports
"
)
{
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
supports
{
ancestorData
.
conditionText
}
)
)
;
}
else
if
(
ancestorData
.
type
=
=
"
import
"
)
{
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
import
{
ancestorData
.
value
}
)
)
;
}
else
if
(
ancestorData
.
type
=
=
"
scope
"
)
{
let
text
=
scope
;
if
(
ancestorData
.
start
)
{
text
+
=
(
{
ancestorData
.
start
}
)
;
if
(
ancestorData
.
end
)
{
text
+
=
to
(
{
ancestorData
.
end
}
)
;
}
}
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
text
)
)
;
}
else
if
(
ancestorData
.
type
=
=
"
starting
-
style
"
)
{
selectorContainer
.
append
(
this
.
doc
.
createTextNode
(
starting
-
style
)
)
;
}
else
if
(
ancestorData
.
selectors
)
{
ancestorData
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
if
(
i
!
=
=
0
)
{
createChild
(
selectorContainer
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
const
selectorEl
=
createChild
(
selectorContainer
"
span
"
{
class
:
"
ruleview
-
selector
"
textContent
:
selector
}
)
;
const
warningsContainer
=
this
.
_createWarningsElementForSelector
(
i
ancestorData
.
selectorWarnings
)
;
if
(
warningsContainer
)
{
selectorEl
.
append
(
warningsContainer
)
;
}
}
)
;
}
else
{
console
.
warn
(
"
Unknown
ancestor
data
type
:
"
ancestorData
.
type
)
;
return
;
}
createChild
(
ancestorItem
"
span
"
{
class
:
"
ruleview
-
ancestor
-
ruleopen
"
textContent
:
"
{
"
}
)
;
}
)
;
this
.
ancestorDataEl
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
ancestor
-
data
theme
-
link
"
role
:
"
list
"
}
)
;
this
.
ancestorDataEl
.
append
(
ancestorsFrag
)
;
}
const
code
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
code
"
}
)
;
const
header
=
createChild
(
code
"
div
"
{
}
)
;
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
rule
-
indent
"
textContent
:
INDENT_STR
.
repeat
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
}
)
;
this
.
selectorText
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectors
-
container
"
tabindex
:
this
.
isSelectorEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
classList
.
add
(
"
alternative
-
selector
"
)
;
}
if
(
this
.
isSelectorEditable
)
{
this
.
selectorText
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
editableField
(
{
element
:
this
.
selectorText
done
:
this
.
_onSelectorDone
cssProperties
:
this
.
rule
.
cssProperties
focusEditableFieldAfterApply
:
true
focusEditableFieldContainerSelector
:
"
.
ruleview
-
rule
"
stopOnReturn
:
this
.
ruleView
.
inplaceEditorFocusNextOnEnter
!
=
=
true
}
)
;
}
if
(
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
)
{
let
computedSelector
=
"
"
;
if
(
this
.
rule
.
domRule
.
selectors
)
{
computedSelector
=
this
.
rule
.
domRule
.
computedSelector
;
}
const
isHighlighted
=
this
.
ruleView
.
isSelectorHighlighted
(
computedSelector
)
;
createChild
(
header
"
button
"
{
class
:
"
ruleview
-
selectorhighlighter
js
-
toggle
-
selector
-
highlighter
"
+
(
isHighlighted
?
"
highlighted
"
:
"
"
)
"
aria
-
pressed
"
:
isHighlighted
"
data
-
computed
-
selector
"
:
computedSelector
title
:
l10n
(
"
rule
.
selectorHighlighter
.
tooltip
"
)
}
)
;
}
this
.
openBrace
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
ruleopen
"
textContent
:
"
{
"
}
)
;
this
.
propertyList
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
propertylist
"
role
:
"
list
"
}
)
;
this
.
populate
(
)
;
this
.
closeBrace
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ruleclose
"
tabindex
:
this
.
isEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
{
createChild
(
this
.
closeBrace
"
span
"
{
class
:
"
ruleview
-
rule
-
indent
"
textContent
:
INDENT_STR
.
repeat
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
}
)
;
}
this
.
closeBrace
.
append
(
this
.
doc
.
createTextNode
(
"
}
"
)
)
;
if
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
{
let
closingBracketsText
=
"
"
;
for
(
let
i
=
this
.
rule
.
domRule
.
ancestorData
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
i
)
{
closingBracketsText
+
=
INDENT_STR
.
repeat
(
i
)
;
}
closingBracketsText
+
=
"
}
\
n
"
;
}
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ancestor
-
ruleclose
"
textContent
:
closingBracketsText
}
)
;
}
if
(
this
.
isEditable
)
{
this
.
_ruleViewIsEditing
=
false
;
code
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
_ruleViewIsEditing
=
this
.
ruleView
.
isEditing
;
}
)
;
code
.
addEventListener
(
"
click
"
(
)
=
>
{
const
selection
=
this
.
doc
.
defaultView
.
getSelection
(
)
;
if
(
selection
.
isCollapsed
&
&
!
this
.
_ruleViewIsEditing
)
{
this
.
newProperty
(
)
;
}
this
.
_ruleViewIsEditing
=
false
;
}
)
;
this
.
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
)
;
editableItem
(
{
element
:
this
.
closeBrace
}
(
)
=
>
{
this
.
newProperty
(
)
;
}
)
;
}
}
_createWarningsElementForSelector
(
selectorIndex
selectorWarnings
)
{
if
(
!
selectorWarnings
)
{
return
null
;
}
const
warningKinds
=
[
]
;
for
(
const
{
index
kind
}
of
selectorWarnings
)
{
if
(
index
!
=
=
selectorIndex
)
{
continue
;
}
warningKinds
.
push
(
kind
)
;
}
if
(
!
warningKinds
.
length
)
{
return
null
;
}
const
warningsContainer
=
this
.
doc
.
createElement
(
"
div
"
)
;
warningsContainer
.
classList
.
add
(
"
ruleview
-
selector
-
warnings
"
"
has
-
tooltip
"
)
;
warningsContainer
.
setAttribute
(
"
data
-
selector
-
warning
-
kind
"
warningKinds
.
join
(
"
"
)
)
;
if
(
warningKinds
.
includes
(
"
UnconstrainedHas
"
)
)
{
warningsContainer
.
classList
.
add
(
"
slow
"
)
;
}
return
warningsContainer
;
}
_onToolChanged
(
)
{
if
(
!
this
.
source
)
{
return
;
}
if
(
this
.
toolbox
.
isToolRegistered
(
"
styleeditor
"
)
)
{
this
.
source
.
removeAttribute
(
"
unselectable
"
)
;
}
else
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
}
}
_locationChanged
(
)
{
this
.
updateSourceLink
(
)
;
}
_onSourceClick
(
e
)
{
e
.
preventDefault
(
)
;
if
(
this
.
source
.
hasAttribute
(
"
unselectable
"
)
)
{
return
;
}
const
{
inspector
}
=
this
.
ruleView
;
if
(
Tools
.
styleEditor
.
isToolSupported
(
inspector
.
toolbox
)
)
{
inspector
.
toolbox
.
viewSourceInStyleEditorByResource
(
this
.
rule
.
sheet
this
.
rule
.
ruleLine
this
.
rule
.
ruleColumn
)
;
}
}
_updateLocation
(
originalLocation
)
{
let
displayURL
=
this
.
rule
.
sheet
?
.
href
;
const
constructed
=
this
.
rule
.
sheet
?
.
constructed
;
let
line
=
this
.
rule
.
ruleLine
;
if
(
originalLocation
)
{
displayURL
=
originalLocation
.
url
;
line
=
originalLocation
.
line
;
}
let
sourceTextContent
=
CssLogic
.
shortSource
(
{
constructed
href
:
displayURL
}
)
;
let
displayLocation
=
displayURL
?
displayURL
:
sourceTextContent
;
if
(
line
>
0
)
{
sourceTextContent
+
=
"
:
"
+
line
;
displayLocation
+
=
"
:
"
+
line
;
}
const
title
=
COMPONENT_L10N
.
getFormatStr
(
"
frame
.
viewsourceinstyleeditor
"
displayLocation
)
;
const
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
sourceLabel
.
setAttribute
(
"
title
"
title
)
;
sourceLabel
.
setAttribute
(
"
href
"
displayURL
)
;
sourceLabel
.
textContent
=
sourceTextContent
;
}
updateSourceLink
(
)
{
if
(
this
.
source
)
{
if
(
this
.
rule
.
isSystem
)
{
const
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
const
uaLabel
=
STYLE_INSPECTOR_L10N
.
getStr
(
"
rule
.
userAgentStyles
"
)
;
sourceLabel
.
textContent
=
uaLabel
+
"
"
+
this
.
rule
.
title
;
sourceLabel
.
setAttribute
(
"
href
"
this
.
rule
.
sheet
?
.
href
)
;
}
else
{
this
.
_updateLocation
(
null
)
;
}
if
(
this
.
rule
.
sheet
&
&
!
this
.
rule
.
isSystem
)
{
if
(
this
.
_unsubscribeSourceMap
)
{
this
.
_unsubscribeSourceMap
(
)
;
}
this
.
_unsubscribeSourceMap
=
this
.
sourceMapURLService
.
subscribeByID
(
this
.
rule
.
sheet
.
resourceId
this
.
rule
.
ruleLine
this
.
rule
.
ruleColumn
this
.
_updateLocation
)
;
}
this
.
_onToolChanged
(
)
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
source
-
link
-
updated
"
)
;
}
)
;
}
populate
(
reset
)
{
while
(
this
.
selectorText
.
hasChildNodes
(
)
)
{
this
.
selectorText
.
removeChild
(
this
.
selectorText
.
lastChild
)
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
selectorText
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
domRule
.
keyText
;
}
else
{
this
.
rule
.
domRule
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
this
.
_populateSelector
(
selector
i
)
;
}
)
;
}
let
focusedElSelector
;
if
(
reset
)
{
if
(
this
.
element
.
contains
(
this
.
doc
.
activeElement
)
)
{
focusedElSelector
=
CssLogic
.
findCssSelector
(
this
.
doc
.
activeElement
)
;
}
while
(
this
.
propertyList
.
hasChildNodes
(
)
)
{
this
.
propertyList
.
removeChild
(
this
.
propertyList
.
lastChild
)
;
}
}
for
(
const
prop
of
this
.
rule
.
textProps
)
{
if
(
!
prop
.
editor
&
&
!
prop
.
invisible
)
{
const
editor
=
new
TextPropertyEditor
(
this
prop
{
elementsWithPendingClicks
:
this
.
options
.
elementsWithPendingClicks
}
)
;
this
.
propertyList
.
appendChild
(
editor
.
element
)
;
}
else
if
(
prop
.
editor
)
{
this
.
propertyList
.
appendChild
(
prop
.
editor
.
element
)
;
}
}
if
(
focusedElSelector
)
{
const
elementToFocus
=
this
.
doc
.
querySelector
(
focusedElSelector
)
;
if
(
elementToFocus
&
&
this
.
element
.
contains
(
elementToFocus
)
)
{
setTimeout
(
(
)
=
>
{
elementToFocus
.
focus
(
)
;
this
.
ruleView
.
emitForTests
(
"
rule
-
editor
-
focus
-
reset
"
)
;
}
0
)
;
}
}
}
_populateSelector
(
selector
selectorIndex
)
{
if
(
selectorIndex
!
=
=
0
)
{
createChild
(
this
.
selectorText
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
let
containerClass
=
"
ruleview
-
selector
"
;
if
(
this
.
rule
.
matchedSelectorIndexes
.
length
)
{
containerClass
+
=
this
.
rule
.
matchedSelectorIndexes
.
includes
(
selectorIndex
)
?
"
matched
"
:
"
unmatched
"
;
}
let
selectorContainerTitle
;
if
(
typeof
this
.
rule
.
selector
.
selectorsSpecificity
?
.
[
selectorIndex
]
!
=
=
"
undefined
"
)
{
const
specificity
=
this
.
rule
.
selector
.
selectorsSpecificity
?
.
[
selectorIndex
]
;
const
a
=
Math
.
floor
(
specificity
/
(
1024
*
1024
)
)
;
const
b
=
Math
.
floor
(
(
specificity
%
(
1024
*
1024
)
)
/
1024
)
;
const
c
=
specificity
%
1024
;
selectorContainerTitle
=
STYLE_INSPECTOR_L10N
.
getFormatStr
(
"
rule
.
selectorSpecificity
.
title
"
(
{
a
}
{
b
}
{
c
}
)
)
;
}
const
selectorContainer
=
createChild
(
this
.
selectorText
"
span
"
{
class
:
containerClass
title
:
selectorContainerTitle
}
)
;
const
parsedSelector
=
parsePseudoClassesAndAttributes
(
selector
)
;
for
(
const
selectorText
of
parsedSelector
)
{
let
selectorClass
=
"
"
;
switch
(
selectorText
.
type
)
{
case
SELECTOR_ATTRIBUTE
:
selectorClass
=
"
ruleview
-
selector
-
attribute
"
;
break
;
case
SELECTOR_ELEMENT
:
selectorClass
=
"
ruleview
-
selector
-
element
"
;
break
;
case
SELECTOR_PSEUDO_CLASS
:
selectorClass
=
PSEUDO_CLASSES
.
some
(
pseudo
=
>
selectorText
.
value
=
=
=
pseudo
)
?
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
:
"
ruleview
-
selector
-
pseudo
-
class
"
;
break
;
default
:
break
;
}
createChild
(
selectorContainer
"
span
"
{
textContent
:
selectorText
.
value
class
:
selectorClass
}
)
;
}
const
warningsContainer
=
this
.
_createWarningsElementForSelector
(
selectorIndex
this
.
rule
.
domRule
.
selectorWarnings
)
;
if
(
warningsContainer
)
{
selectorContainer
.
append
(
warningsContainer
)
;
}
}
addProperty
(
name
value
priority
enabled
siblingProp
)
{
const
prop
=
this
.
rule
.
createProperty
(
name
value
priority
enabled
siblingProp
)
;
const
index
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
const
editor
=
new
TextPropertyEditor
(
this
prop
{
elementsWithPendingClicks
:
this
.
options
.
elementsWithPendingClicks
}
)
;
this
.
propertyList
.
insertBefore
(
editor
.
element
this
.
propertyList
.
children
[
index
]
)
;
return
prop
;
}
addProperties
(
properties
siblingProp
)
{
if
(
!
properties
|
|
!
properties
.
length
)
{
return
;
}
let
lastProp
=
siblingProp
;
for
(
const
p
of
properties
)
{
const
isCommented
=
Boolean
(
p
.
commentOffsets
)
;
const
enabled
=
!
isCommented
;
lastProp
=
this
.
addProperty
(
p
.
name
p
.
value
p
.
priority
enabled
lastProp
)
;
}
if
(
lastProp
&
&
lastProp
.
value
.
trim
(
)
=
=
=
"
"
)
{
lastProp
.
editor
.
valueSpan
.
click
(
)
;
}
else
{
this
.
newProperty
(
)
;
}
}
newProperty
(
)
{
if
(
!
this
.
closeBrace
.
hasAttribute
(
"
tabindex
"
)
)
{
return
;
}
this
.
closeBrace
.
removeAttribute
(
"
tabindex
"
)
;
this
.
newPropItem
=
createChild
(
this
.
propertyList
"
div
"
{
class
:
"
ruleview
-
property
ruleview
-
newproperty
"
role
:
"
listitem
"
}
)
;
this
.
newPropSpan
=
createChild
(
this
.
newPropItem
"
span
"
{
class
:
"
ruleview
-
propertyname
"
tabindex
:
"
0
"
}
)
;
this
.
multipleAddedProperties
=
null
;
this
.
editor
=
new
InplaceEditor
(
{
element
:
this
.
newPropSpan
done
:
this
.
_onNewProperty
focusEditableFieldAfterApply
:
true
focusEditableFieldContainerSelector
:
"
.
ruleview
-
rule
"
destroy
:
this
.
_newPropertyDestroy
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
ruleView
.
popup
cssProperties
:
this
.
rule
.
cssProperties
inputAriaLabel
:
NEW_PROPERTY_NAME_INPUT_LABEL
getCssVariables
:
(
)
=
>
this
.
rule
.
elementStyle
.
getAllCustomProperties
(
this
.
rule
.
pseudoElement
)
}
)
;
this
.
editor
.
input
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
rule
.
cssProperties
)
)
;
}
_onNewProperty
(
value
commit
)
{
if
(
!
value
|
|
!
commit
)
{
return
;
}
this
.
multipleAddedProperties
=
parseNamedDeclarations
(
this
.
rule
.
cssProperties
.
isKnown
value
true
)
;
this
.
editor
.
input
.
blur
(
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
)
;
}
_newPropertyDestroy
(
)
{
this
.
closeBrace
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
propertyList
.
removeChild
(
this
.
newPropItem
)
;
delete
this
.
newPropItem
;
delete
this
.
newPropSpan
;
if
(
this
.
multipleAddedProperties
&
&
this
.
multipleAddedProperties
.
length
)
{
this
.
addProperties
(
this
.
multipleAddedProperties
)
;
}
}
async
_onSelectorDone
(
value
commit
direction
)
{
if
(
!
commit
|
|
this
.
isEditing
|
|
value
=
=
=
"
"
|
|
value
=
=
=
this
.
rule
.
selectorText
)
{
return
;
}
const
ruleView
=
this
.
ruleView
;
const
elementStyle
=
ruleView
.
_elementStyle
;
const
element
=
elementStyle
.
element
;
this
.
isEditing
=
true
;
const
computedSelector
=
this
.
rule
.
domRule
.
computedSelector
;
if
(
this
.
ruleView
.
isSelectorHighlighted
(
computedSelector
)
)
{
await
this
.
ruleView
.
toggleSelectorHighlighter
(
this
.
rule
computedSelector
)
;
}
try
{
const
response
=
await
this
.
rule
.
domRule
.
modifySelector
(
element
value
)
;
const
applied
=
await
elementStyle
.
pageStyle
.
getApplied
(
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
elementStyle
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
;
this
.
isEditing
=
false
;
const
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
ruleProps
.
isUnmatched
=
!
isMatching
;
const
newRule
=
new
Rule
(
elementStyle
ruleProps
)
;
const
editor
=
new
RuleEditor
(
ruleView
newRule
)
;
const
rules
=
elementStyle
.
rules
;
let
newRuleIndex
=
applied
.
findIndex
(
r
=
>
r
.
rule
=
=
ruleProps
.
rule
)
;
const
oldIndex
=
rules
.
indexOf
(
this
.
rule
)
;
if
(
newRuleIndex
=
=
=
-
1
)
{
newRuleIndex
=
oldIndex
;
}
rules
.
splice
(
oldIndex
1
)
;
rules
.
splice
(
newRuleIndex
0
newRule
)
;
elementStyle
.
_changed
(
)
;
elementStyle
.
onRuleUpdated
(
)
;
this
.
element
.
parentNode
.
replaceChild
(
editor
.
element
this
.
element
)
;
editor
.
_moveSelectorFocus
(
direction
)
;
}
catch
(
err
)
{
this
.
isEditing
=
false
;
promiseWarn
(
err
)
;
}
}
_moveSelectorFocus
(
direction
)
{
if
(
!
direction
|
|
direction
=
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
return
;
}
if
(
this
.
rule
.
textProps
.
length
)
{
this
.
rule
.
textProps
[
0
]
.
editor
.
nameSpan
.
click
(
)
;
}
else
{
this
.
propertyList
.
click
(
)
;
}
}
}
;
module
.
exports
=
RuleEditor
;
