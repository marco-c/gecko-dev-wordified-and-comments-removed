"
use
strict
"
;
const
{
l10n
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
const
Rule
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
{
InplaceEditor
editableField
editableItem
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
TextPropertyEditor
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
views
/
text
-
property
-
editor
"
)
;
const
{
createChild
blurOnMultipleProperties
promiseWarn
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
parseNamedDeclarations
parsePseudoClassesAndAttributes
SELECTOR_ATTRIBUTE
SELECTOR_ELEMENT
SELECTOR_PSEUDO_CLASS
}
=
require
(
"
devtools
/
shared
/
css
/
parsing
-
utils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
Tools
}
=
require
(
"
devtools
/
client
/
definitions
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
CssLogic
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
function
RuleEditor
(
ruleView
rule
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
ruleView
=
ruleView
;
this
.
doc
=
this
.
ruleView
.
styleDocument
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
rule
=
rule
;
this
.
isEditable
=
!
rule
.
isSystem
;
this
.
isEditing
=
false
;
this
.
_onNewProperty
=
this
.
_onNewProperty
.
bind
(
this
)
;
this
.
_newPropertyDestroy
=
this
.
_newPropertyDestroy
.
bind
(
this
)
;
this
.
_onSelectorDone
=
this
.
_onSelectorDone
.
bind
(
this
)
;
this
.
_locationChanged
=
this
.
_locationChanged
.
bind
(
this
)
;
this
.
updateSourceLink
=
this
.
updateSourceLink
.
bind
(
this
)
;
this
.
_onToolChanged
=
this
.
_onToolChanged
.
bind
(
this
)
;
this
.
_updateLocation
=
this
.
_updateLocation
.
bind
(
this
)
;
this
.
_onSourceClick
=
this
.
_onSourceClick
.
bind
(
this
)
;
this
.
rule
.
domRule
.
on
(
"
location
-
changed
"
this
.
_locationChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
this
.
_create
(
)
;
}
RuleEditor
.
prototype
=
{
destroy
:
function
(
)
{
this
.
rule
.
domRule
.
off
(
"
location
-
changed
"
)
;
this
.
toolbox
.
off
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
off
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
let
url
=
null
;
if
(
this
.
rule
.
sheet
)
{
url
=
this
.
rule
.
sheet
.
href
|
|
this
.
rule
.
sheet
.
nodeHref
;
}
if
(
url
&
&
!
this
.
rule
.
isSystem
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
let
sourceLine
=
this
.
rule
.
ruleLine
;
let
sourceColumn
=
this
.
rule
.
ruleColumn
;
if
(
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
.
unsubscribe
(
url
sourceLine
sourceColumn
this
.
_updateLocation
)
;
}
}
}
get
sourceMapURLService
(
)
{
if
(
!
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
=
this
.
toolbox
.
sourceMapURLService
;
}
return
this
.
_sourceMapURLService
;
}
get
isSelectorEditable
(
)
{
let
trait
=
this
.
isEditable
&
&
this
.
ruleView
.
inspector
.
target
.
client
.
traits
.
selectorEditable
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
;
return
trait
&
&
!
this
.
rule
.
elementStyle
.
element
.
isAnonymous
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
element
.
className
=
"
ruleview
-
rule
devtools
-
monospace
"
;
this
.
element
.
setAttribute
(
"
uneditable
"
!
this
.
isEditable
)
;
this
.
element
.
setAttribute
(
"
unmatched
"
this
.
rule
.
isUnmatched
)
;
this
.
element
.
_ruleEditor
=
this
;
this
.
element
.
style
.
position
=
"
relative
"
;
this
.
source
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
source
theme
-
link
"
}
)
;
this
.
source
.
addEventListener
(
"
click
"
this
.
_onSourceClick
)
;
let
sourceLabel
=
this
.
doc
.
createElement
(
"
span
"
)
;
sourceLabel
.
classList
.
add
(
"
ruleview
-
rule
-
source
-
label
"
)
;
this
.
source
.
appendChild
(
sourceLabel
)
;
this
.
updateSourceLink
(
)
;
let
code
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
code
"
}
)
;
let
header
=
createChild
(
code
"
div
"
{
}
)
;
this
.
selectorText
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorcontainer
"
tabindex
:
this
.
isSelectorEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
isSelectorEditable
)
{
this
.
selectorText
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
editableField
(
{
element
:
this
.
selectorText
done
:
this
.
_onSelectorDone
cssProperties
:
this
.
rule
.
cssProperties
}
)
;
}
if
(
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
)
{
(
async
function
(
)
{
let
selector
;
if
(
this
.
rule
.
domRule
.
selectors
)
{
selector
=
this
.
rule
.
domRule
.
selectors
.
join
(
"
"
)
;
}
else
if
(
this
.
rule
.
inherited
)
{
selector
=
await
this
.
rule
.
inherited
.
getUniqueSelector
(
)
;
}
else
{
selector
=
this
.
ruleView
.
inspector
.
selectionCssSelector
;
}
let
isHighlighted
=
this
.
ruleView
.
_highlighters
&
&
this
.
ruleView
.
highlighters
.
selectorHighlighterShown
=
=
=
selector
;
let
selectorHighlighter
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorhighlighter
"
+
(
isHighlighted
?
"
highlighted
"
:
"
"
)
title
:
l10n
(
"
rule
.
selectorHighlighter
.
tooltip
"
)
}
)
;
selectorHighlighter
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
ruleView
.
toggleSelectorHighlighter
(
selectorHighlighter
selector
)
;
}
)
;
this
.
uniqueSelector
=
selector
;
this
.
emit
(
"
selector
-
icon
-
created
"
)
;
}
.
bind
(
this
)
)
(
)
.
catch
(
error
=
>
{
console
.
error
(
"
Exception
while
getting
unique
selector
"
error
)
;
}
)
;
}
this
.
openBrace
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
ruleopen
"
textContent
:
"
{
"
}
)
;
this
.
propertyList
=
createChild
(
code
"
ul
"
{
class
:
"
ruleview
-
propertylist
"
}
)
;
this
.
populate
(
)
;
this
.
closeBrace
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ruleclose
"
tabindex
:
this
.
isEditable
?
"
0
"
:
"
-
1
"
textContent
:
"
}
"
}
)
;
if
(
this
.
isEditable
)
{
this
.
_ruleViewIsEditing
=
false
;
code
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
_ruleViewIsEditing
=
this
.
ruleView
.
isEditing
;
}
)
;
code
.
addEventListener
(
"
click
"
(
)
=
>
{
let
selection
=
this
.
doc
.
defaultView
.
getSelection
(
)
;
if
(
selection
.
isCollapsed
&
&
!
this
.
_ruleViewIsEditing
)
{
this
.
newProperty
(
)
;
}
this
.
_ruleViewIsEditing
=
false
;
}
)
;
this
.
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
)
;
editableItem
(
{
element
:
this
.
closeBrace
}
(
)
=
>
{
this
.
newProperty
(
)
;
}
)
;
}
}
_onToolChanged
:
function
(
)
{
if
(
this
.
source
.
getAttribute
(
"
unselectable
"
)
=
=
=
"
permanent
"
)
{
}
else
if
(
this
.
toolbox
.
isToolRegistered
(
"
styleeditor
"
)
)
{
this
.
source
.
removeAttribute
(
"
unselectable
"
)
;
}
else
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
}
}
_locationChanged
:
function
(
)
{
this
.
updateSourceLink
(
)
;
}
_onSourceClick
:
function
(
)
{
if
(
this
.
source
.
hasAttribute
(
"
unselectable
"
)
|
|
!
this
.
_currentLocation
)
{
return
;
}
let
target
=
this
.
ruleView
.
inspector
.
target
;
if
(
Tools
.
styleEditor
.
isTargetSupported
(
target
)
)
{
gDevTools
.
showToolbox
(
target
"
styleeditor
"
)
.
then
(
toolbox
=
>
{
let
{
url
line
column
}
=
this
.
_currentLocation
;
toolbox
.
getCurrentPanel
(
)
.
selectStyleSheet
(
url
line
column
)
;
}
)
;
}
}
_updateLocation
:
function
(
enabled
url
line
column
)
{
let
displayURL
=
url
;
if
(
!
enabled
)
{
url
=
null
;
displayURL
=
null
;
if
(
this
.
rule
.
sheet
)
{
url
=
this
.
rule
.
sheet
.
href
|
|
this
.
rule
.
sheet
.
nodeHref
;
displayURL
=
this
.
rule
.
sheet
.
href
;
}
line
=
this
.
rule
.
ruleLine
;
column
=
this
.
rule
.
ruleColumn
;
}
this
.
_currentLocation
=
{
url
line
column
}
;
let
sourceTextContent
=
CssLogic
.
shortSource
(
{
href
:
displayURL
}
)
;
let
title
=
displayURL
?
displayURL
:
sourceTextContent
;
if
(
line
>
0
)
{
sourceTextContent
+
=
"
:
"
+
line
;
title
+
=
"
:
"
+
line
;
}
if
(
this
.
rule
.
mediaText
)
{
sourceTextContent
+
=
"
"
+
this
.
rule
.
mediaText
;
title
+
=
"
"
+
this
.
rule
.
mediaText
;
}
let
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
sourceLabel
.
setAttribute
(
"
title
"
title
)
;
sourceLabel
.
textContent
=
sourceTextContent
;
}
updateSourceLink
:
function
(
)
{
if
(
this
.
rule
.
isSystem
)
{
let
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
let
title
=
this
.
rule
.
title
;
let
sourceHref
=
(
this
.
rule
.
sheet
&
&
this
.
rule
.
sheet
.
href
)
?
this
.
rule
.
sheet
.
href
:
title
;
let
uaLabel
=
STYLE_INSPECTOR_L10N
.
getStr
(
"
rule
.
userAgentStyles
"
)
;
sourceLabel
.
textContent
=
uaLabel
+
"
"
+
title
;
if
(
sourceHref
=
=
=
"
about
:
PreferenceStyleSheet
"
)
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
permanent
"
)
;
sourceLabel
.
textContent
=
uaLabel
;
sourceLabel
.
removeAttribute
(
"
title
"
)
;
}
}
else
{
this
.
_updateLocation
(
false
)
;
}
let
url
=
null
;
if
(
this
.
rule
.
sheet
)
{
url
=
this
.
rule
.
sheet
.
href
|
|
this
.
rule
.
sheet
.
nodeHref
;
}
if
(
url
&
&
!
this
.
rule
.
isSystem
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
let
sourceLine
=
this
.
rule
.
ruleLine
;
let
sourceColumn
=
this
.
rule
.
ruleColumn
;
this
.
sourceMapURLService
.
subscribe
(
url
sourceLine
sourceColumn
this
.
_updateLocation
)
;
this
.
_onToolChanged
(
)
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
permanent
"
)
;
}
else
{
this
.
_onToolChanged
(
)
;
}
promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
source
-
link
-
updated
"
)
;
}
)
;
}
populate
:
function
(
)
{
while
(
this
.
selectorText
.
hasChildNodes
(
)
)
{
this
.
selectorText
.
removeChild
(
this
.
selectorText
.
lastChild
)
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
selectorText
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
domRule
.
keyText
;
}
else
{
this
.
rule
.
domRule
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
if
(
i
!
=
=
0
)
{
createChild
(
this
.
selectorText
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
let
containerClass
=
(
this
.
rule
.
matchedSelectors
.
indexOf
(
selector
)
>
-
1
)
?
"
ruleview
-
selector
-
matched
"
:
"
ruleview
-
selector
-
unmatched
"
;
let
selectorContainer
=
createChild
(
this
.
selectorText
"
span
"
{
class
:
containerClass
}
)
;
let
parsedSelector
=
parsePseudoClassesAndAttributes
(
selector
)
;
for
(
let
selectorText
of
parsedSelector
)
{
let
selectorClass
=
"
"
;
switch
(
selectorText
.
type
)
{
case
SELECTOR_ATTRIBUTE
:
selectorClass
=
"
ruleview
-
selector
-
attribute
"
;
break
;
case
SELECTOR_ELEMENT
:
selectorClass
=
"
ruleview
-
selector
"
;
break
;
case
SELECTOR_PSEUDO_CLASS
:
selectorClass
=
[
"
:
active
"
"
:
focus
"
"
:
hover
"
]
.
some
(
pseudo
=
>
selectorText
.
value
=
=
=
pseudo
)
?
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
:
"
ruleview
-
selector
-
pseudo
-
class
"
;
break
;
default
:
break
;
}
createChild
(
selectorContainer
"
span
"
{
textContent
:
selectorText
.
value
class
:
selectorClass
}
)
;
}
}
)
;
}
for
(
let
prop
of
this
.
rule
.
textProps
)
{
if
(
!
prop
.
editor
&
&
!
prop
.
invisible
)
{
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
appendChild
(
editor
.
element
)
;
}
}
}
addProperty
:
function
(
name
value
priority
enabled
siblingProp
)
{
let
prop
=
this
.
rule
.
createProperty
(
name
value
priority
enabled
siblingProp
)
;
let
index
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
insertBefore
(
editor
.
element
this
.
propertyList
.
children
[
index
]
)
;
return
prop
;
}
addProperties
:
function
(
properties
siblingProp
)
{
if
(
!
properties
|
|
!
properties
.
length
)
{
return
;
}
let
lastProp
=
siblingProp
;
for
(
let
p
of
properties
)
{
let
isCommented
=
Boolean
(
p
.
commentOffsets
)
;
let
enabled
=
!
isCommented
;
lastProp
=
this
.
addProperty
(
p
.
name
p
.
value
p
.
priority
enabled
lastProp
)
;
}
if
(
lastProp
&
&
lastProp
.
value
.
trim
(
)
=
=
=
"
"
)
{
lastProp
.
editor
.
valueSpan
.
click
(
)
;
}
else
{
this
.
newProperty
(
)
;
}
}
newProperty
:
function
(
)
{
if
(
!
this
.
closeBrace
.
hasAttribute
(
"
tabindex
"
)
)
{
return
;
}
this
.
closeBrace
.
removeAttribute
(
"
tabindex
"
)
;
this
.
newPropItem
=
createChild
(
this
.
propertyList
"
li
"
{
class
:
"
ruleview
-
property
ruleview
-
newproperty
"
}
)
;
this
.
newPropSpan
=
createChild
(
this
.
newPropItem
"
span
"
{
class
:
"
ruleview
-
propertyname
"
tabindex
:
"
0
"
}
)
;
this
.
multipleAddedProperties
=
null
;
this
.
editor
=
new
InplaceEditor
(
{
element
:
this
.
newPropSpan
done
:
this
.
_onNewProperty
destroy
:
this
.
_newPropertyDestroy
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
ruleView
.
popup
cssProperties
:
this
.
rule
.
cssProperties
}
)
;
this
.
editor
.
input
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
rule
.
cssProperties
)
)
;
}
_onNewProperty
:
function
(
value
commit
)
{
if
(
!
value
|
|
!
commit
)
{
return
;
}
this
.
multipleAddedProperties
=
parseNamedDeclarations
(
this
.
rule
.
cssProperties
.
isKnown
value
true
)
;
this
.
editor
.
input
.
blur
(
)
;
this
.
telemetry
.
recordEvent
(
"
devtools
.
main
"
"
edit_rule
"
"
ruleview
"
)
;
}
_newPropertyDestroy
:
function
(
)
{
this
.
closeBrace
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
propertyList
.
removeChild
(
this
.
newPropItem
)
;
delete
this
.
newPropItem
;
delete
this
.
newPropSpan
;
if
(
this
.
multipleAddedProperties
&
&
this
.
multipleAddedProperties
.
length
)
{
this
.
addProperties
(
this
.
multipleAddedProperties
)
;
}
}
async
_onSelectorDone
(
value
commit
direction
)
{
if
(
!
commit
|
|
this
.
isEditing
|
|
value
=
=
=
"
"
|
|
value
=
=
=
this
.
rule
.
selectorText
)
{
return
;
}
let
ruleView
=
this
.
ruleView
;
let
elementStyle
=
ruleView
.
_elementStyle
;
let
element
=
elementStyle
.
element
;
let
supportsUnmatchedRules
=
this
.
rule
.
domRule
.
supportsModifySelectorUnmatched
;
this
.
isEditing
=
true
;
try
{
let
response
=
await
this
.
rule
.
domRule
.
modifySelector
(
element
value
)
;
if
(
!
supportsUnmatchedRules
)
{
this
.
isEditing
=
false
;
if
(
response
)
{
this
.
ruleView
.
refreshPanel
(
)
;
}
return
;
}
let
applied
=
await
elementStyle
.
pageStyle
.
getApplied
(
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
elementStyle
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
;
this
.
isEditing
=
false
;
let
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
ruleProps
.
isUnmatched
=
!
isMatching
;
let
newRule
=
new
Rule
(
elementStyle
ruleProps
)
;
let
editor
=
new
RuleEditor
(
ruleView
newRule
)
;
let
rules
=
elementStyle
.
rules
;
let
newRuleIndex
=
applied
.
findIndex
(
(
r
)
=
>
r
.
rule
=
=
ruleProps
.
rule
)
;
let
oldIndex
=
rules
.
indexOf
(
this
.
rule
)
;
if
(
newRuleIndex
=
=
=
-
1
)
{
newRuleIndex
=
oldIndex
;
}
rules
.
splice
(
oldIndex
1
)
;
rules
.
splice
(
newRuleIndex
0
newRule
)
;
elementStyle
.
_changed
(
)
;
elementStyle
.
markOverriddenAll
(
)
;
this
.
element
.
parentNode
.
replaceChild
(
editor
.
element
this
.
element
)
;
if
(
ruleView
.
highlighters
.
selectorHighlighterShown
)
{
ruleView
.
toggleSelectorHighlighter
(
ruleView
.
lastSelectorIcon
ruleView
.
highlighters
.
selectorHighlighterShown
)
;
}
editor
.
_moveSelectorFocus
(
direction
)
;
}
catch
(
err
)
{
this
.
isEditing
=
false
;
promiseWarn
(
err
)
;
}
}
_moveSelectorFocus
:
function
(
direction
)
{
if
(
!
direction
|
|
direction
=
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
return
;
}
if
(
this
.
rule
.
textProps
.
length
>
0
)
{
this
.
rule
.
textProps
[
0
]
.
editor
.
nameSpan
.
click
(
)
;
}
else
{
this
.
propertyList
.
click
(
)
;
}
}
}
;
module
.
exports
=
RuleEditor
;
