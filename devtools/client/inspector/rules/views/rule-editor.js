"
use
strict
"
;
const
{
l10n
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
devtools
/
shared
/
css
/
constants
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
const
Rule
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
{
InplaceEditor
editableField
editableItem
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
TextPropertyEditor
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
views
/
text
-
property
-
editor
"
)
;
const
{
createChild
blurOnMultipleProperties
promiseWarn
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
parseNamedDeclarations
parsePseudoClassesAndAttributes
SELECTOR_ATTRIBUTE
SELECTOR_ELEMENT
SELECTOR_PSEUDO_CLASS
}
=
require
(
"
devtools
/
shared
/
css
/
parsing
-
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
CssLogic
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
loader
.
lazyRequireGetter
(
this
"
Tools
"
"
devtools
/
client
/
definitions
"
true
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
function
RuleEditor
(
ruleView
rule
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
ruleView
=
ruleView
;
this
.
doc
=
this
.
ruleView
.
styleDocument
;
this
.
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
this
.
telemetry
=
this
.
toolbox
.
telemetry
;
this
.
rule
=
rule
;
this
.
isEditable
=
!
rule
.
isSystem
;
this
.
isEditing
=
false
;
this
.
_onNewProperty
=
this
.
_onNewProperty
.
bind
(
this
)
;
this
.
_newPropertyDestroy
=
this
.
_newPropertyDestroy
.
bind
(
this
)
;
this
.
_onSelectorDone
=
this
.
_onSelectorDone
.
bind
(
this
)
;
this
.
_locationChanged
=
this
.
_locationChanged
.
bind
(
this
)
;
this
.
updateSourceLink
=
this
.
updateSourceLink
.
bind
(
this
)
;
this
.
_onToolChanged
=
this
.
_onToolChanged
.
bind
(
this
)
;
this
.
_updateLocation
=
this
.
_updateLocation
.
bind
(
this
)
;
this
.
_onSourceClick
=
this
.
_onSourceClick
.
bind
(
this
)
;
this
.
rule
.
domRule
.
on
(
"
location
-
changed
"
this
.
_locationChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
on
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
this
.
_create
(
)
;
}
RuleEditor
.
prototype
=
{
destroy
(
)
{
this
.
rule
.
domRule
.
off
(
"
location
-
changed
"
)
;
this
.
toolbox
.
off
(
"
tool
-
registered
"
this
.
_onToolChanged
)
;
this
.
toolbox
.
off
(
"
tool
-
unregistered
"
this
.
_onToolChanged
)
;
if
(
this
.
_unsubscribeSourceMap
)
{
this
.
_unsubscribeSourceMap
(
)
;
}
}
get
sourceMapURLService
(
)
{
if
(
!
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
=
this
.
toolbox
.
sourceMapURLService
;
}
return
this
.
_sourceMapURLService
;
}
get
isSelectorEditable
(
)
{
const
trait
=
this
.
isEditable
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
;
return
trait
&
&
!
this
.
rule
.
elementStyle
.
element
.
isAnonymous
;
}
_create
(
)
{
this
.
element
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
element
.
className
=
"
ruleview
-
rule
devtools
-
monospace
"
;
this
.
element
.
dataset
.
ruleId
=
this
.
rule
.
domRule
.
actorID
;
this
.
element
.
setAttribute
(
"
uneditable
"
!
this
.
isEditable
)
;
this
.
element
.
setAttribute
(
"
unmatched
"
this
.
rule
.
isUnmatched
)
;
this
.
element
.
_ruleEditor
=
this
;
this
.
element
.
style
.
position
=
"
relative
"
;
this
.
source
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
source
theme
-
link
"
}
)
;
this
.
source
.
addEventListener
(
"
click
"
this
.
_onSourceClick
)
;
const
sourceLabel
=
this
.
doc
.
createElement
(
"
span
"
)
;
sourceLabel
.
classList
.
add
(
"
ruleview
-
rule
-
source
-
label
"
)
;
this
.
source
.
appendChild
(
sourceLabel
)
;
this
.
updateSourceLink
(
)
;
if
(
this
.
rule
.
domRule
.
ancestorData
.
length
)
{
const
parts
=
this
.
rule
.
domRule
.
ancestorData
.
map
(
ancestorData
=
>
{
if
(
ancestorData
.
type
=
=
"
container
"
)
{
const
containerQueryParts
=
[
"
container
"
ancestorData
.
containerName
ancestorData
.
containerQuery
]
.
filter
(
p
=
>
!
!
p
)
;
return
containerQueryParts
.
join
(
"
"
)
;
}
if
(
ancestorData
.
type
=
=
"
layer
"
)
{
return
layer
{
ancestorData
.
value
?
"
"
+
ancestorData
.
value
:
"
"
}
;
}
if
(
ancestorData
.
type
=
=
"
media
"
)
{
return
media
{
ancestorData
.
value
}
;
}
console
.
warn
(
"
Unknown
ancestor
data
type
:
"
ancestorData
.
type
)
;
return
;
}
)
;
const
title
=
{
parts
.
join
(
"
\
n
"
)
.
replaceAll
(
"
"
"
\
u202A
"
)
}
;
this
.
ancestorDataEl
=
createChild
(
this
.
element
"
ul
"
{
class
:
"
ruleview
-
rule
-
ancestor
-
data
theme
-
link
"
title
}
)
;
for
(
const
part
of
parts
)
{
createChild
(
this
.
ancestorDataEl
"
li
"
{
textContent
:
part
}
)
;
}
}
const
code
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
code
"
}
)
;
const
header
=
createChild
(
code
"
div
"
{
}
)
;
this
.
selectorText
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorcontainer
"
tabindex
:
this
.
isSelectorEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
isSelectorEditable
)
{
this
.
selectorText
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
editableField
(
{
element
:
this
.
selectorText
done
:
this
.
_onSelectorDone
cssProperties
:
this
.
rule
.
cssProperties
}
)
;
}
if
(
this
.
rule
.
domRule
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
)
{
(
async
function
(
)
{
let
selector
;
if
(
this
.
rule
.
domRule
.
selectors
)
{
selector
=
this
.
rule
.
domRule
.
selectors
.
join
(
"
"
)
;
}
else
if
(
this
.
rule
.
inherited
)
{
selector
=
await
this
.
rule
.
inherited
.
getUniqueSelector
(
)
;
}
else
{
selector
=
await
this
.
ruleView
.
inspector
.
selection
.
nodeFront
.
getUniqueSelector
(
)
;
}
const
isHighlighted
=
this
.
ruleView
.
isSelectorHighlighted
(
selector
)
;
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorhighlighter
js
-
toggle
-
selector
-
highlighter
"
+
(
isHighlighted
?
"
highlighted
"
:
"
"
)
"
data
-
selector
"
:
selector
title
:
l10n
(
"
rule
.
selectorHighlighter
.
tooltip
"
)
}
)
;
}
.
bind
(
this
)
(
)
.
catch
(
error
=
>
{
console
.
error
(
"
Exception
while
getting
unique
selector
"
error
)
;
}
)
)
;
}
this
.
openBrace
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
ruleopen
"
textContent
:
"
{
"
}
)
;
this
.
propertyList
=
createChild
(
code
"
ul
"
{
class
:
"
ruleview
-
propertylist
"
}
)
;
this
.
populate
(
)
;
this
.
closeBrace
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ruleclose
"
tabindex
:
this
.
isEditable
?
"
0
"
:
"
-
1
"
textContent
:
"
}
"
}
)
;
if
(
this
.
isEditable
)
{
this
.
_ruleViewIsEditing
=
false
;
code
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
_ruleViewIsEditing
=
this
.
ruleView
.
isEditing
;
}
)
;
code
.
addEventListener
(
"
click
"
event
=
>
{
const
selection
=
this
.
doc
.
defaultView
.
getSelection
(
)
;
if
(
selection
.
isCollapsed
&
&
!
this
.
_ruleViewIsEditing
)
{
this
.
newProperty
(
)
;
}
this
.
_ruleViewIsEditing
=
false
;
}
)
;
this
.
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
)
;
editableItem
(
{
element
:
this
.
closeBrace
}
(
)
=
>
{
this
.
newProperty
(
)
;
}
)
;
}
}
_onToolChanged
(
)
{
if
(
this
.
source
.
getAttribute
(
"
unselectable
"
)
=
=
=
"
permanent
"
)
{
}
else
if
(
this
.
toolbox
.
isToolRegistered
(
"
styleeditor
"
)
)
{
this
.
source
.
removeAttribute
(
"
unselectable
"
)
;
}
else
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
}
}
_locationChanged
(
)
{
this
.
updateSourceLink
(
)
;
}
_onSourceClick
(
)
{
if
(
this
.
source
.
hasAttribute
(
"
unselectable
"
)
)
{
return
;
}
const
{
inspector
}
=
this
.
ruleView
;
if
(
Tools
.
styleEditor
.
isToolSupported
(
inspector
.
toolbox
)
)
{
inspector
.
toolbox
.
viewSourceInStyleEditorByFront
(
this
.
rule
.
sheet
this
.
rule
.
ruleLine
this
.
rule
.
ruleColumn
)
;
}
}
_updateLocation
(
originalLocation
)
{
let
displayURL
=
this
.
rule
.
sheet
?
.
href
;
const
constructed
=
this
.
rule
.
sheet
?
.
constructed
;
let
line
=
this
.
rule
.
ruleLine
;
if
(
originalLocation
)
{
displayURL
=
originalLocation
.
url
;
line
=
originalLocation
.
line
;
}
let
sourceTextContent
=
CssLogic
.
shortSource
(
{
constructed
href
:
displayURL
}
)
;
let
title
=
displayURL
?
displayURL
:
sourceTextContent
;
if
(
line
>
0
)
{
sourceTextContent
+
=
"
:
"
+
line
;
title
+
=
"
:
"
+
line
;
}
const
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
sourceLabel
.
setAttribute
(
"
title
"
title
)
;
sourceLabel
.
textContent
=
sourceTextContent
;
}
updateSourceLink
(
)
{
if
(
this
.
rule
.
isSystem
)
{
const
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
const
title
=
this
.
rule
.
title
;
const
sourceHref
=
this
.
rule
.
sheet
?
.
href
|
|
title
;
const
uaLabel
=
STYLE_INSPECTOR_L10N
.
getStr
(
"
rule
.
userAgentStyles
"
)
;
sourceLabel
.
textContent
=
uaLabel
+
"
"
+
title
;
if
(
sourceHref
=
=
=
"
about
:
PreferenceStyleSheet
"
)
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
permanent
"
)
;
sourceLabel
.
textContent
=
uaLabel
;
sourceLabel
.
removeAttribute
(
"
title
"
)
;
}
}
else
{
this
.
_updateLocation
(
null
)
;
}
if
(
this
.
rule
.
sheet
&
&
!
this
.
rule
.
isSystem
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
if
(
this
.
_unsubscribeSourceMap
)
{
this
.
_unsubscribeSourceMap
(
)
;
}
this
.
_unsubscribeSourceMap
=
this
.
sourceMapURLService
.
subscribeByID
(
this
.
rule
.
sheet
.
resourceId
|
|
this
.
rule
.
sheet
.
actorID
this
.
rule
.
ruleLine
this
.
rule
.
ruleColumn
this
.
_updateLocation
)
;
this
.
_onToolChanged
(
)
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
source
.
setAttribute
(
"
unselectable
"
"
permanent
"
)
;
}
else
{
this
.
_onToolChanged
(
)
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
source
-
link
-
updated
"
)
;
}
)
;
}
populate
(
reset
)
{
while
(
this
.
selectorText
.
hasChildNodes
(
)
)
{
this
.
selectorText
.
removeChild
(
this
.
selectorText
.
lastChild
)
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
selectorText
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
domRule
.
keyText
;
}
else
{
this
.
rule
.
domRule
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
if
(
i
!
=
=
0
)
{
createChild
(
this
.
selectorText
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
const
containerClass
=
this
.
rule
.
matchedSelectors
.
indexOf
(
selector
)
>
-
1
?
"
ruleview
-
selector
-
matched
"
:
"
ruleview
-
selector
-
unmatched
"
;
const
selectorContainer
=
createChild
(
this
.
selectorText
"
span
"
{
class
:
containerClass
}
)
;
const
parsedSelector
=
parsePseudoClassesAndAttributes
(
selector
)
;
for
(
const
selectorText
of
parsedSelector
)
{
let
selectorClass
=
"
"
;
switch
(
selectorText
.
type
)
{
case
SELECTOR_ATTRIBUTE
:
selectorClass
=
"
ruleview
-
selector
-
attribute
"
;
break
;
case
SELECTOR_ELEMENT
:
selectorClass
=
"
ruleview
-
selector
"
;
break
;
case
SELECTOR_PSEUDO_CLASS
:
selectorClass
=
PSEUDO_CLASSES
.
some
(
pseudo
=
>
selectorText
.
value
=
=
=
pseudo
)
?
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
:
"
ruleview
-
selector
-
pseudo
-
class
"
;
break
;
default
:
break
;
}
createChild
(
selectorContainer
"
span
"
{
textContent
:
selectorText
.
value
class
:
selectorClass
}
)
;
}
}
)
;
}
if
(
reset
)
{
while
(
this
.
propertyList
.
hasChildNodes
(
)
)
{
this
.
propertyList
.
removeChild
(
this
.
propertyList
.
lastChild
)
;
}
}
for
(
const
prop
of
this
.
rule
.
textProps
)
{
if
(
!
prop
.
editor
&
&
!
prop
.
invisible
)
{
const
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
appendChild
(
editor
.
element
)
;
}
else
if
(
prop
.
editor
)
{
this
.
propertyList
.
appendChild
(
prop
.
editor
.
element
)
;
}
}
}
addProperty
(
name
value
priority
enabled
siblingProp
)
{
const
prop
=
this
.
rule
.
createProperty
(
name
value
priority
enabled
siblingProp
)
;
const
index
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
const
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
insertBefore
(
editor
.
element
this
.
propertyList
.
children
[
index
]
)
;
return
prop
;
}
addProperties
(
properties
siblingProp
)
{
if
(
!
properties
|
|
!
properties
.
length
)
{
return
;
}
let
lastProp
=
siblingProp
;
for
(
const
p
of
properties
)
{
const
isCommented
=
Boolean
(
p
.
commentOffsets
)
;
const
enabled
=
!
isCommented
;
lastProp
=
this
.
addProperty
(
p
.
name
p
.
value
p
.
priority
enabled
lastProp
)
;
}
if
(
lastProp
&
&
lastProp
.
value
.
trim
(
)
=
=
=
"
"
)
{
lastProp
.
editor
.
valueSpan
.
click
(
)
;
}
else
{
this
.
newProperty
(
)
;
}
}
newProperty
(
)
{
if
(
!
this
.
closeBrace
.
hasAttribute
(
"
tabindex
"
)
)
{
return
;
}
this
.
closeBrace
.
removeAttribute
(
"
tabindex
"
)
;
this
.
newPropItem
=
createChild
(
this
.
propertyList
"
li
"
{
class
:
"
ruleview
-
property
ruleview
-
newproperty
"
}
)
;
this
.
newPropSpan
=
createChild
(
this
.
newPropItem
"
span
"
{
class
:
"
ruleview
-
propertyname
"
tabindex
:
"
0
"
}
)
;
this
.
multipleAddedProperties
=
null
;
this
.
editor
=
new
InplaceEditor
(
{
element
:
this
.
newPropSpan
done
:
this
.
_onNewProperty
destroy
:
this
.
_newPropertyDestroy
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
ruleView
.
popup
cssProperties
:
this
.
rule
.
cssProperties
}
)
;
this
.
editor
.
input
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
(
this
.
rule
.
cssProperties
)
)
;
}
_onNewProperty
(
value
commit
)
{
if
(
!
value
|
|
!
commit
)
{
return
;
}
this
.
multipleAddedProperties
=
parseNamedDeclarations
(
this
.
rule
.
cssProperties
.
isKnown
value
true
)
;
this
.
editor
.
input
.
blur
(
)
;
this
.
telemetry
.
recordEvent
(
"
edit_rule
"
"
ruleview
"
null
{
session_id
:
this
.
toolbox
.
sessionId
}
)
;
}
_newPropertyDestroy
(
)
{
this
.
closeBrace
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
propertyList
.
removeChild
(
this
.
newPropItem
)
;
delete
this
.
newPropItem
;
delete
this
.
newPropSpan
;
if
(
this
.
multipleAddedProperties
&
&
this
.
multipleAddedProperties
.
length
)
{
this
.
addProperties
(
this
.
multipleAddedProperties
)
;
}
}
async
_onSelectorDone
(
value
commit
direction
)
{
if
(
!
commit
|
|
this
.
isEditing
|
|
value
=
=
=
"
"
|
|
value
=
=
=
this
.
rule
.
selectorText
)
{
return
;
}
const
ruleView
=
this
.
ruleView
;
const
elementStyle
=
ruleView
.
_elementStyle
;
const
element
=
elementStyle
.
element
;
this
.
isEditing
=
true
;
if
(
this
.
ruleView
.
isSelectorHighlighted
(
this
.
rule
.
selectorText
)
)
{
await
this
.
ruleView
.
toggleSelectorHighlighter
(
this
.
rule
.
selectorText
)
;
}
try
{
const
response
=
await
this
.
rule
.
domRule
.
modifySelector
(
element
value
)
;
const
applied
=
await
elementStyle
.
pageStyle
.
getApplied
(
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
elementStyle
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
;
this
.
isEditing
=
false
;
const
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
ruleProps
.
isUnmatched
=
!
isMatching
;
const
newRule
=
new
Rule
(
elementStyle
ruleProps
)
;
const
editor
=
new
RuleEditor
(
ruleView
newRule
)
;
const
rules
=
elementStyle
.
rules
;
let
newRuleIndex
=
applied
.
findIndex
(
r
=
>
r
.
rule
=
=
ruleProps
.
rule
)
;
const
oldIndex
=
rules
.
indexOf
(
this
.
rule
)
;
if
(
newRuleIndex
=
=
=
-
1
)
{
newRuleIndex
=
oldIndex
;
}
rules
.
splice
(
oldIndex
1
)
;
rules
.
splice
(
newRuleIndex
0
newRule
)
;
elementStyle
.
_changed
(
)
;
elementStyle
.
onRuleUpdated
(
)
;
this
.
element
.
parentNode
.
replaceChild
(
editor
.
element
this
.
element
)
;
editor
.
_moveSelectorFocus
(
direction
)
;
}
catch
(
err
)
{
this
.
isEditing
=
false
;
promiseWarn
(
err
)
;
}
}
_moveSelectorFocus
(
direction
)
{
if
(
!
direction
|
|
direction
=
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
return
;
}
if
(
this
.
rule
.
textProps
.
length
)
{
this
.
rule
.
textProps
[
0
]
.
editor
.
nameSpan
.
click
(
)
;
}
else
{
this
.
propertyList
.
click
(
)
;
}
}
}
;
module
.
exports
=
RuleEditor
;
