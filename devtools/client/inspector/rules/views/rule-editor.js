"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
CssLogic
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
server
/
actors
/
styles
"
)
;
const
{
PREF_ORIG_SOURCES
}
=
require
(
"
devtools
/
client
/
styleeditor
/
utils
"
)
;
const
{
Rule
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
{
InplaceEditor
editableField
editableItem
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
TextPropertyEditor
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
views
/
text
-
property
-
editor
"
)
;
const
{
createChild
blurOnMultipleProperties
promiseWarn
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
parseDeclarations
parsePseudoClassesAndAttributes
SELECTOR_ATTRIBUTE
SELECTOR_ELEMENT
SELECTOR_PSEUDO_CLASS
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
parsing
-
utils
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_strings
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
-
shared
/
locale
/
styleinspector
.
properties
"
)
;
}
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
function
RuleEditor
(
ruleView
rule
)
{
this
.
ruleView
=
ruleView
;
this
.
doc
=
this
.
ruleView
.
styleDocument
;
this
.
rule
=
rule
;
this
.
isEditable
=
!
rule
.
isSystem
;
this
.
isEditing
=
false
;
this
.
_onNewProperty
=
this
.
_onNewProperty
.
bind
(
this
)
;
this
.
_newPropertyDestroy
=
this
.
_newPropertyDestroy
.
bind
(
this
)
;
this
.
_onSelectorDone
=
this
.
_onSelectorDone
.
bind
(
this
)
;
this
.
_locationChanged
=
this
.
_locationChanged
.
bind
(
this
)
;
this
.
rule
.
domRule
.
on
(
"
location
-
changed
"
this
.
_locationChanged
)
;
this
.
_create
(
)
;
}
RuleEditor
.
prototype
=
{
destroy
:
function
(
)
{
this
.
rule
.
domRule
.
off
(
"
location
-
changed
"
)
;
}
get
isSelectorEditable
(
)
{
let
toolbox
=
this
.
ruleView
.
inspector
.
toolbox
;
let
trait
=
this
.
isEditable
&
&
toolbox
.
target
.
client
.
traits
.
selectorEditable
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
rule
.
domRule
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
;
return
trait
&
&
!
this
.
rule
.
elementStyle
.
element
.
isAnonymous
;
}
_create
:
function
(
)
{
this
.
element
=
this
.
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
element
.
className
=
"
ruleview
-
rule
theme
-
separator
"
;
this
.
element
.
setAttribute
(
"
uneditable
"
!
this
.
isEditable
)
;
this
.
element
.
_ruleEditor
=
this
;
this
.
element
.
style
.
position
=
"
relative
"
;
this
.
source
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
rule
-
source
theme
-
link
"
}
)
;
this
.
source
.
addEventListener
(
"
click
"
function
(
)
{
if
(
this
.
source
.
hasAttribute
(
"
unselectable
"
)
)
{
return
;
}
let
rule
=
this
.
rule
.
domRule
;
this
.
ruleView
.
emit
(
"
ruleview
-
linked
-
clicked
"
rule
)
;
}
.
bind
(
this
)
)
;
let
sourceLabel
=
this
.
doc
.
createElementNS
(
XUL_NS
"
label
"
)
;
sourceLabel
.
setAttribute
(
"
crop
"
"
center
"
)
;
sourceLabel
.
classList
.
add
(
"
ruleview
-
rule
-
source
-
label
"
)
;
this
.
source
.
appendChild
(
sourceLabel
)
;
this
.
updateSourceLink
(
)
;
let
code
=
createChild
(
this
.
element
"
div
"
{
class
:
"
ruleview
-
code
"
}
)
;
let
header
=
createChild
(
code
"
div
"
{
}
)
;
this
.
selectorText
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorcontainer
theme
-
fg
-
color3
"
tabindex
:
this
.
isSelectorEditable
?
"
0
"
:
"
-
1
"
}
)
;
if
(
this
.
isSelectorEditable
)
{
this
.
selectorText
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
}
false
)
;
editableField
(
{
element
:
this
.
selectorText
done
:
this
.
_onSelectorDone
}
)
;
}
if
(
this
.
rule
.
domRule
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
&
&
this
.
rule
.
domRule
.
selectors
)
{
let
selector
=
this
.
rule
.
domRule
.
selectors
.
join
(
"
"
)
;
let
selectorHighlighter
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
selectorhighlighter
"
+
(
this
.
ruleView
.
highlightedSelector
=
=
=
selector
?
"
highlighted
"
:
"
"
)
title
:
CssLogic
.
l10n
(
"
rule
.
selectorHighlighter
.
tooltip
"
)
}
)
;
selectorHighlighter
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
ruleView
.
toggleSelectorHighlighter
(
selectorHighlighter
selector
)
;
}
)
;
}
this
.
openBrace
=
createChild
(
header
"
span
"
{
class
:
"
ruleview
-
ruleopen
"
textContent
:
"
{
"
}
)
;
this
.
propertyList
=
createChild
(
code
"
ul
"
{
class
:
"
ruleview
-
propertylist
"
}
)
;
this
.
populate
(
)
;
this
.
closeBrace
=
createChild
(
code
"
div
"
{
class
:
"
ruleview
-
ruleclose
"
tabindex
:
this
.
isEditable
?
"
0
"
:
"
-
1
"
textContent
:
"
}
"
}
)
;
if
(
this
.
isEditable
)
{
code
.
addEventListener
(
"
click
"
(
)
=
>
{
let
selection
=
this
.
doc
.
defaultView
.
getSelection
(
)
;
if
(
selection
.
isCollapsed
)
{
this
.
newProperty
(
)
;
}
}
false
)
;
this
.
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
false
)
;
editableItem
(
{
element
:
this
.
closeBrace
}
(
)
=
>
{
this
.
newProperty
(
)
;
}
)
;
}
}
_locationChanged
:
function
(
)
{
this
.
updateSourceLink
(
)
;
}
updateSourceLink
:
function
(
)
{
let
sourceLabel
=
this
.
element
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
let
title
=
this
.
rule
.
title
;
let
sourceHref
=
(
this
.
rule
.
sheet
&
&
this
.
rule
.
sheet
.
href
)
?
this
.
rule
.
sheet
.
href
:
title
;
let
sourceLine
=
this
.
rule
.
ruleLine
>
0
?
"
:
"
+
this
.
rule
.
ruleLine
:
"
"
;
sourceLabel
.
setAttribute
(
"
tooltiptext
"
sourceHref
+
sourceLine
)
;
if
(
this
.
rule
.
isSystem
)
{
let
uaLabel
=
_strings
.
GetStringFromName
(
"
rule
.
userAgentStyles
"
)
;
sourceLabel
.
setAttribute
(
"
value
"
uaLabel
+
"
"
+
title
)
;
if
(
sourceHref
=
=
=
"
about
:
PreferenceStyleSheet
"
)
{
sourceLabel
.
parentNode
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
sourceLabel
.
setAttribute
(
"
value
"
uaLabel
)
;
sourceLabel
.
removeAttribute
(
"
tooltiptext
"
)
;
}
}
else
{
sourceLabel
.
setAttribute
(
"
value
"
title
)
;
if
(
this
.
rule
.
ruleLine
=
=
=
-
1
&
&
this
.
rule
.
domRule
.
parentStyleSheet
)
{
sourceLabel
.
parentNode
.
setAttribute
(
"
unselectable
"
"
true
"
)
;
}
}
let
showOrig
=
Services
.
prefs
.
getBoolPref
(
PREF_ORIG_SOURCES
)
;
if
(
showOrig
&
&
!
this
.
rule
.
isSystem
&
&
this
.
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
this
.
rule
.
getOriginalSourceStrings
(
)
.
then
(
(
strings
)
=
>
{
sourceLabel
.
setAttribute
(
"
value
"
strings
.
short
)
;
sourceLabel
.
setAttribute
(
"
tooltiptext
"
strings
.
full
)
;
}
console
.
error
)
;
}
}
populate
:
function
(
)
{
while
(
this
.
selectorText
.
hasChildNodes
(
)
)
{
this
.
selectorText
.
removeChild
(
this
.
selectorText
.
lastChild
)
;
}
if
(
this
.
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
selectorText
;
}
else
if
(
this
.
rule
.
domRule
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
{
this
.
selectorText
.
textContent
=
this
.
rule
.
domRule
.
keyText
;
}
else
{
this
.
rule
.
domRule
.
selectors
.
forEach
(
(
selector
i
)
=
>
{
if
(
i
!
=
=
0
)
{
createChild
(
this
.
selectorText
"
span
"
{
class
:
"
ruleview
-
selector
-
separator
"
textContent
:
"
"
}
)
;
}
let
containerClass
=
(
this
.
rule
.
matchedSelectors
.
indexOf
(
selector
)
>
-
1
)
?
"
ruleview
-
selector
-
matched
"
:
"
ruleview
-
selector
-
unmatched
"
;
let
selectorContainer
=
createChild
(
this
.
selectorText
"
span
"
{
class
:
containerClass
}
)
;
let
parsedSelector
=
parsePseudoClassesAndAttributes
(
selector
)
;
for
(
let
selectorText
of
parsedSelector
)
{
let
selectorClass
=
"
"
;
switch
(
selectorText
.
type
)
{
case
SELECTOR_ATTRIBUTE
:
selectorClass
=
"
ruleview
-
selector
-
attribute
"
;
break
;
case
SELECTOR_ELEMENT
:
selectorClass
=
"
ruleview
-
selector
"
;
break
;
case
SELECTOR_PSEUDO_CLASS
:
selectorClass
=
[
"
:
active
"
"
:
focus
"
"
:
hover
"
]
.
some
(
pseudo
=
>
selectorText
.
value
=
=
=
pseudo
)
?
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
:
"
ruleview
-
selector
-
pseudo
-
class
"
;
break
;
default
:
break
;
}
createChild
(
selectorContainer
"
span
"
{
textContent
:
selectorText
.
value
class
:
selectorClass
}
)
;
}
}
)
;
}
for
(
let
prop
of
this
.
rule
.
textProps
)
{
if
(
!
prop
.
editor
&
&
!
prop
.
invisible
)
{
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
appendChild
(
editor
.
element
)
;
}
}
}
addProperty
:
function
(
name
value
priority
siblingProp
)
{
let
prop
=
this
.
rule
.
createProperty
(
name
value
priority
siblingProp
)
;
let
index
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
let
editor
=
new
TextPropertyEditor
(
this
prop
)
;
this
.
propertyList
.
insertBefore
(
editor
.
element
this
.
propertyList
.
children
[
index
]
)
;
return
prop
;
}
addProperties
:
function
(
properties
siblingProp
)
{
if
(
!
properties
|
|
!
properties
.
length
)
{
return
;
}
let
lastProp
=
siblingProp
;
for
(
let
p
of
properties
)
{
lastProp
=
this
.
addProperty
(
p
.
name
p
.
value
p
.
priority
lastProp
)
;
}
if
(
lastProp
&
&
lastProp
.
value
.
trim
(
)
=
=
=
"
"
)
{
lastProp
.
editor
.
valueSpan
.
click
(
)
;
}
else
{
this
.
newProperty
(
)
;
}
}
newProperty
:
function
(
)
{
if
(
!
this
.
closeBrace
.
hasAttribute
(
"
tabindex
"
)
)
{
return
;
}
this
.
closeBrace
.
removeAttribute
(
"
tabindex
"
)
;
this
.
newPropItem
=
createChild
(
this
.
propertyList
"
li
"
{
class
:
"
ruleview
-
property
ruleview
-
newproperty
"
}
)
;
this
.
newPropSpan
=
createChild
(
this
.
newPropItem
"
span
"
{
class
:
"
ruleview
-
propertyname
"
tabindex
:
"
0
"
}
)
;
this
.
multipleAddedProperties
=
null
;
this
.
editor
=
new
InplaceEditor
(
{
element
:
this
.
newPropSpan
done
:
this
.
_onNewProperty
destroy
:
this
.
_newPropertyDestroy
advanceChars
:
"
:
"
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_PROPERTY
popup
:
this
.
ruleView
.
popup
}
)
;
this
.
editor
.
input
.
addEventListener
(
"
paste
"
blurOnMultipleProperties
false
)
;
}
_onNewProperty
:
function
(
value
commit
)
{
if
(
!
value
|
|
!
commit
)
{
return
;
}
this
.
multipleAddedProperties
=
parseDeclarations
(
value
)
.
filter
(
d
=
>
d
.
name
)
;
this
.
editor
.
input
.
blur
(
)
;
}
_newPropertyDestroy
:
function
(
)
{
this
.
closeBrace
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
propertyList
.
removeChild
(
this
.
newPropItem
)
;
delete
this
.
newPropItem
;
delete
this
.
newPropSpan
;
if
(
this
.
multipleAddedProperties
&
&
this
.
multipleAddedProperties
.
length
)
{
this
.
addProperties
(
this
.
multipleAddedProperties
)
;
}
}
_onSelectorDone
:
function
(
value
commit
direction
)
{
if
(
!
commit
|
|
this
.
isEditing
|
|
value
=
=
=
"
"
|
|
value
=
=
=
this
.
rule
.
selectorText
)
{
return
;
}
let
ruleView
=
this
.
ruleView
;
let
elementStyle
=
ruleView
.
_elementStyle
;
let
element
=
elementStyle
.
element
;
let
supportsUnmatchedRules
=
this
.
rule
.
domRule
.
supportsModifySelectorUnmatched
;
this
.
isEditing
=
true
;
this
.
rule
.
domRule
.
modifySelector
(
element
value
)
.
then
(
response
=
>
{
this
.
isEditing
=
false
;
if
(
!
supportsUnmatchedRules
)
{
if
(
response
)
{
this
.
ruleView
.
refreshPanel
(
)
;
}
return
;
}
let
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
let
newRule
=
new
Rule
(
elementStyle
ruleProps
)
;
let
editor
=
new
RuleEditor
(
ruleView
newRule
)
;
let
rules
=
elementStyle
.
rules
;
rules
.
splice
(
rules
.
indexOf
(
this
.
rule
)
1
)
;
rules
.
push
(
newRule
)
;
elementStyle
.
_changed
(
)
;
elementStyle
.
markOverriddenAll
(
)
;
editor
.
element
.
setAttribute
(
"
unmatched
"
!
isMatching
)
;
this
.
element
.
parentNode
.
replaceChild
(
editor
.
element
this
.
element
)
;
if
(
ruleView
.
highlightedSelector
)
{
ruleView
.
toggleSelectorHighlighter
(
ruleView
.
lastSelectorIcon
ruleView
.
highlightedSelector
)
;
}
editor
.
_moveSelectorFocus
(
direction
)
;
}
)
.
then
(
null
err
=
>
{
this
.
isEditing
=
false
;
promiseWarn
(
err
)
;
}
)
;
}
_moveSelectorFocus
:
function
(
direction
)
{
if
(
!
direction
|
|
direction
=
=
=
Ci
.
nsIFocusManager
.
MOVEFOCUS_BACKWARD
)
{
return
;
}
if
(
this
.
rule
.
textProps
.
length
>
0
)
{
this
.
rule
.
textProps
[
0
]
.
editor
.
nameSpan
.
click
(
)
;
}
else
{
this
.
propertyList
.
click
(
)
;
}
}
}
;
exports
.
RuleEditor
=
RuleEditor
;
