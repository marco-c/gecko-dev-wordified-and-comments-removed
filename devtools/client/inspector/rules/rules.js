"
use
strict
"
;
const
flags
=
require
(
"
resource
:
/
/
devtools
/
shared
/
flags
.
js
"
)
;
const
{
l10n
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
constants
.
js
"
)
;
const
OutputParser
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
output
-
parser
.
js
"
)
;
const
{
PrefObserver
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
prefs
.
js
"
)
;
const
ElementStyle
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
models
/
element
-
style
.
js
"
)
;
const
RuleEditor
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
views
/
rule
-
editor
.
js
"
)
;
const
TooltipsOverlay
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
tooltips
-
overlay
.
js
"
)
;
const
{
createChild
promiseWarn
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
utils
.
js
"
)
;
const
{
debounce
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
flashElementOn
"
"
flashElementOff
"
]
"
resource
:
/
/
devtools
/
client
/
inspector
/
markup
/
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ClassListPreviewer
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
views
/
class
-
list
-
previewer
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getNodeInfo
"
"
getNodeCompatibilityInfo
"
"
getRuleFromNode
"
]
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
utils
/
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StyleInspectorMenu
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
style
-
inspector
-
menu
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
resource
:
/
/
devtools
/
client
/
shared
/
autocomplete
-
popup
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
clipboardHelper
"
"
resource
:
/
/
devtools
/
shared
/
platform
/
clipboard
.
js
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
PREF_UA_STYLES
=
"
devtools
.
inspector
.
showUserAgentStyles
"
;
const
PREF_DEFAULT_COLOR_UNIT
=
"
devtools
.
defaultColorUnit
"
;
const
PREF_DRAGGABLE
=
"
devtools
.
inspector
.
draggable_properties
"
;
const
FILTER_CHANGED_TIMEOUT
=
150
;
const
PROPERTY_FLASHING_DURATION
=
1000
;
const
FILTER_PROP_RE
=
/
\
s
*
(
[
^
:
\
s
]
*
)
\
s
*
:
\
s
*
(
.
*
?
)
\
s
*
;
?
/
;
const
FILTER_STRICT_RE
=
/
\
s
*
(
.
*
?
)
\
s
*
/
;
const
RULE_VIEW_HEADER_CLASSNAME
=
"
ruleview
-
header
"
;
const
PSEUDO_ELEMENTS_CONTAINER_ID
=
"
pseudo
-
elements
-
container
"
;
function
CssRuleView
(
inspector
document
store
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
inspector
=
inspector
;
this
.
cssProperties
=
inspector
.
cssProperties
;
this
.
styleDocument
=
document
;
this
.
styleWindow
=
this
.
styleDocument
.
defaultView
;
this
.
store
=
store
|
|
{
}
;
this
.
debounce
=
debounce
;
this
.
childHasDragged
=
false
;
this
.
_outputParser
=
new
OutputParser
(
document
this
.
cssProperties
)
;
this
.
_onAddRule
=
this
.
_onAddRule
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onCopy
=
this
.
_onCopy
.
bind
(
this
)
;
this
.
_onFilterStyles
=
this
.
_onFilterStyles
.
bind
(
this
)
;
this
.
_onClearSearch
=
this
.
_onClearSearch
.
bind
(
this
)
;
this
.
_onTogglePseudoClassPanel
=
this
.
_onTogglePseudoClassPanel
.
bind
(
this
)
;
this
.
_onTogglePseudoClass
=
this
.
_onTogglePseudoClass
.
bind
(
this
)
;
this
.
_onToggleClassPanel
=
this
.
_onToggleClassPanel
.
bind
(
this
)
;
this
.
_onToggleLightColorSchemeSimulation
=
this
.
_onToggleLightColorSchemeSimulation
.
bind
(
this
)
;
this
.
_onToggleDarkColorSchemeSimulation
=
this
.
_onToggleDarkColorSchemeSimulation
.
bind
(
this
)
;
this
.
_onTogglePrintSimulation
=
this
.
_onTogglePrintSimulation
.
bind
(
this
)
;
this
.
highlightElementRule
=
this
.
highlightElementRule
.
bind
(
this
)
;
this
.
highlightProperty
=
this
.
highlightProperty
.
bind
(
this
)
;
this
.
refreshPanel
=
this
.
refreshPanel
.
bind
(
this
)
;
const
doc
=
this
.
styleDocument
;
this
.
styleDocument
.
addEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
this
.
element
=
doc
.
getElementById
(
"
ruleview
-
container
-
focusable
"
)
;
this
.
addRuleButton
=
doc
.
getElementById
(
"
ruleview
-
add
-
rule
-
button
"
)
;
this
.
searchField
=
doc
.
getElementById
(
"
ruleview
-
searchbox
"
)
;
this
.
searchClearButton
=
doc
.
getElementById
(
"
ruleview
-
searchinput
-
clear
"
)
;
this
.
pseudoClassPanel
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
"
)
;
this
.
pseudoClassToggle
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
-
toggle
"
)
;
this
.
classPanel
=
doc
.
getElementById
(
"
ruleview
-
class
-
panel
"
)
;
this
.
classToggle
=
doc
.
getElementById
(
"
class
-
panel
-
toggle
"
)
;
this
.
colorSchemeLightSimulationButton
=
doc
.
getElementById
(
"
color
-
scheme
-
simulation
-
light
-
toggle
"
)
;
this
.
colorSchemeDarkSimulationButton
=
doc
.
getElementById
(
"
color
-
scheme
-
simulation
-
dark
-
toggle
"
)
;
this
.
printSimulationButton
=
doc
.
getElementById
(
"
print
-
simulation
-
toggle
"
)
;
this
.
_initSimulationFeatures
(
)
;
this
.
searchClearButton
.
hidden
=
true
;
this
.
onHighlighterShown
=
data
=
>
this
.
handleHighlighterEvent
(
"
highlighter
-
shown
"
data
)
;
this
.
onHighlighterHidden
=
data
=
>
this
.
handleHighlighterEvent
(
"
highlighter
-
hidden
"
data
)
;
this
.
inspector
.
highlighters
.
on
(
"
highlighter
-
shown
"
this
.
onHighlighterShown
)
;
this
.
inspector
.
highlighters
.
on
(
"
highlighter
-
hidden
"
this
.
onHighlighterHidden
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
styleWindow
}
)
;
this
.
_onShortcut
=
this
.
_onShortcut
.
bind
(
this
)
;
this
.
shortcuts
.
on
(
"
Escape
"
event
=
>
this
.
_onShortcut
(
"
Escape
"
event
)
)
;
this
.
shortcuts
.
on
(
"
Return
"
event
=
>
this
.
_onShortcut
(
"
Return
"
event
)
)
;
this
.
shortcuts
.
on
(
"
Space
"
event
=
>
this
.
_onShortcut
(
"
Space
"
event
)
)
;
this
.
shortcuts
.
on
(
"
CmdOrCtrl
+
F
"
event
=
>
this
.
_onShortcut
(
"
CmdOrCtrl
+
F
"
event
)
)
;
this
.
element
.
addEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
addEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
addEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
addEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassToggle
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
classToggle
.
addEventListener
(
"
click
"
this
.
_onToggleClassPanel
)
;
this
.
pseudoClassPanel
.
addEventListener
(
"
change
"
this
.
_onTogglePseudoClass
)
;
if
(
flags
.
testing
)
{
this
.
highlighters
.
addToView
(
this
)
;
}
else
{
this
.
element
.
addEventListener
(
"
mousemove
"
(
)
=
>
{
this
.
highlighters
.
addToView
(
this
)
;
}
{
once
:
true
}
)
;
}
this
.
_handlePrefChange
=
this
.
_handlePrefChange
.
bind
(
this
)
;
this
.
_handleUAStylePrefChange
=
this
.
_handleUAStylePrefChange
.
bind
(
this
)
;
this
.
_handleDefaultColorUnitPrefChange
=
this
.
_handleDefaultColorUnitPrefChange
.
bind
(
this
)
;
this
.
_handleDraggablePrefChange
=
this
.
_handleDraggablePrefChange
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
PREF_UA_STYLES
this
.
_handleUAStylePrefChange
)
;
this
.
_prefObserver
.
on
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handleDefaultColorUnitPrefChange
)
;
this
.
_prefObserver
.
on
(
PREF_DRAGGABLE
this
.
_handleDraggablePrefChange
)
;
this
.
_handleDraggablePrefChange
(
)
;
this
.
pseudoClassCheckboxes
=
this
.
_createPseudoClassCheckboxes
(
)
;
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
tooltips
=
new
TooltipsOverlay
(
this
)
;
}
CssRuleView
.
prototype
=
{
_viewedElement
:
null
_filterChangedTimeout
:
null
_dummyElement
:
null
get
popup
(
)
{
if
(
!
this
.
_popup
)
{
this
.
_popup
=
new
AutocompletePopup
(
this
.
inspector
.
toolbox
.
doc
{
autoSelect
:
true
}
)
;
}
return
this
.
_popup
;
}
get
classListPreviewer
(
)
{
if
(
!
this
.
_classListPreviewer
)
{
this
.
_classListPreviewer
=
new
ClassListPreviewer
(
this
.
inspector
this
.
classPanel
)
;
}
return
this
.
_classListPreviewer
;
}
get
contextMenu
(
)
{
if
(
!
this
.
_contextMenu
)
{
this
.
_contextMenu
=
new
StyleInspectorMenu
(
this
{
isRuleView
:
true
}
)
;
}
return
this
.
_contextMenu
;
}
get
dummyElement
(
)
{
return
this
.
_dummyElement
;
}
get
highlighters
(
)
{
if
(
!
this
.
_highlighters
)
{
this
.
_highlighters
=
this
.
inspector
.
highlighters
;
}
return
this
.
_highlighters
;
}
get
searchValue
(
)
{
return
this
.
searchField
.
value
.
toLowerCase
(
)
;
}
get
rules
(
)
{
return
this
.
_elementStyle
?
this
.
_elementStyle
.
rules
:
[
]
;
}
get
currentTarget
(
)
{
return
this
.
inspector
.
toolbox
.
target
;
}
async
toggleSelectorHighlighter
(
selector
)
{
if
(
this
.
isSelectorHighlighted
(
selector
)
)
{
await
this
.
inspector
.
highlighters
.
hideHighlighterType
(
this
.
inspector
.
highlighters
.
TYPES
.
SELECTOR
)
;
}
else
{
await
this
.
inspector
.
highlighters
.
showHighlighterTypeForNode
(
this
.
inspector
.
highlighters
.
TYPES
.
SELECTOR
this
.
inspector
.
selection
.
nodeFront
{
hideInfoBar
:
true
hideGuides
:
true
selector
}
)
;
}
}
isPanelVisible
(
)
{
return
(
this
.
inspector
.
toolbox
&
&
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
toolbox
.
currentToolId
=
=
=
"
inspector
"
&
&
(
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
"
ruleview
"
|
|
this
.
inspector
.
is3PaneModeEnabled
)
)
;
}
isSelectorHighlighted
(
selector
)
{
const
options
=
this
.
inspector
.
highlighters
.
getOptionsForActiveHighlighter
(
this
.
inspector
.
highlighters
.
TYPES
.
SELECTOR
)
;
return
options
?
.
selector
=
=
=
selector
;
}
handleEvent
(
event
)
{
if
(
this
.
childHasDragged
)
{
this
.
childHasDragged
=
false
;
event
.
stopPropagation
(
)
;
return
;
}
switch
(
event
.
type
)
{
case
"
click
"
:
this
.
handleClickEvent
(
event
)
;
break
;
default
:
}
}
async
handleClickEvent
(
event
)
{
const
target
=
event
.
target
;
if
(
target
.
classList
.
contains
(
"
js
-
toggle
-
selector
-
highlighter
"
)
)
{
event
.
stopPropagation
(
)
;
let
selector
=
target
.
dataset
.
computedSelector
;
if
(
selector
=
=
=
"
"
)
{
try
{
const
rule
=
getRuleFromNode
(
target
this
.
_elementStyle
)
;
if
(
rule
.
inherited
)
{
selector
=
await
rule
.
inherited
.
getUniqueSelector
(
)
;
}
else
{
selector
=
await
this
.
inspector
.
selection
.
nodeFront
.
getUniqueSelector
(
)
;
}
target
.
dataset
.
computedSelector
=
selector
;
}
finally
{
}
}
this
.
toggleSelectorHighlighter
(
selector
)
;
}
if
(
target
.
classList
.
contains
(
"
js
-
toggle
-
flexbox
-
highlighter
"
)
)
{
event
.
stopPropagation
(
)
;
this
.
inspector
.
highlighters
.
toggleFlexboxHighlighter
(
this
.
inspector
.
selection
.
nodeFront
"
rule
"
)
;
}
if
(
target
.
classList
.
contains
(
"
js
-
toggle
-
grid
-
highlighter
"
)
)
{
event
.
stopPropagation
(
)
;
this
.
inspector
.
highlighters
.
toggleGridHighlighter
(
this
.
inspector
.
selection
.
nodeFront
"
rule
"
)
;
}
}
handleHighlighterEvent
(
eventName
data
)
{
switch
(
data
.
type
)
{
case
this
.
inspector
.
highlighters
.
TYPES
.
SELECTOR
:
{
const
selector
=
data
?
.
options
?
.
selector
;
if
(
!
selector
)
{
return
;
}
const
query
=
.
js
-
toggle
-
selector
-
highlighter
[
data
-
computed
-
selector
=
'
{
selector
}
'
]
;
for
(
const
node
of
this
.
styleDocument
.
querySelectorAll
(
query
)
)
{
const
isHighlighterDisplayed
=
eventName
=
=
"
highlighter
-
shown
"
;
node
.
classList
.
toggle
(
"
highlighted
"
isHighlighterDisplayed
)
;
node
.
setAttribute
(
"
aria
-
pressed
"
isHighlighterDisplayed
)
;
}
}
break
;
case
this
.
inspector
.
highlighters
.
TYPES
.
FLEXBOX
:
{
const
query
=
"
.
js
-
toggle
-
flexbox
-
highlighter
"
;
for
(
const
node
of
this
.
styleDocument
.
querySelectorAll
(
query
)
)
{
node
.
classList
.
toggle
(
"
active
"
eventName
=
=
"
highlighter
-
shown
"
)
;
}
}
break
;
case
this
.
inspector
.
highlighters
.
TYPES
.
GRID
:
{
const
query
=
"
.
js
-
toggle
-
grid
-
highlighter
"
;
for
(
const
node
of
this
.
styleDocument
.
querySelectorAll
(
query
)
)
{
if
(
data
.
nodeFront
=
=
=
this
.
inspector
.
selection
.
nodeFront
)
{
node
.
classList
.
toggle
(
"
active
"
eventName
=
=
"
highlighter
-
shown
"
)
;
}
node
.
toggleAttribute
(
"
disabled
"
!
this
.
inspector
.
highlighters
.
canGridHighlighterToggle
(
this
.
inspector
.
selection
.
nodeFront
)
)
;
}
}
break
;
}
}
async
_initSimulationFeatures
(
)
{
if
(
!
this
.
inspector
.
commands
.
descriptorFront
.
isTabDescriptor
)
{
return
;
}
this
.
colorSchemeLightSimulationButton
.
removeAttribute
(
"
hidden
"
)
;
this
.
colorSchemeDarkSimulationButton
.
removeAttribute
(
"
hidden
"
)
;
this
.
printSimulationButton
.
removeAttribute
(
"
hidden
"
)
;
this
.
printSimulationButton
.
addEventListener
(
"
click
"
this
.
_onTogglePrintSimulation
)
;
this
.
colorSchemeLightSimulationButton
.
addEventListener
(
"
click
"
this
.
_onToggleLightColorSchemeSimulation
)
;
this
.
colorSchemeDarkSimulationButton
.
addEventListener
(
"
click
"
this
.
_onToggleDarkColorSchemeSimulation
)
;
}
getNodeInfo
(
node
)
{
return
getNodeInfo
(
node
this
.
_elementStyle
)
;
}
async
getNodeCompatibilityInfo
(
node
)
{
const
compatibilityInfo
=
await
getNodeCompatibilityInfo
(
node
this
.
_elementStyle
)
;
return
compatibilityInfo
;
}
_onContextMenu
(
event
)
{
if
(
event
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
event
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
event
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
contextMenu
.
show
(
event
)
;
}
_onCopy
(
event
)
{
if
(
event
)
{
this
.
copySelection
(
event
.
target
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
copySelection
(
target
)
{
try
{
let
text
=
"
"
;
const
nodeName
=
target
?
.
nodeName
;
const
targetType
=
target
?
.
type
;
if
(
(
nodeName
=
=
=
"
input
"
&
&
targetType
!
=
=
"
checkbox
"
)
|
|
nodeName
=
=
"
textarea
"
)
{
const
start
=
Math
.
min
(
target
.
selectionStart
target
.
selectionEnd
)
;
const
end
=
Math
.
max
(
target
.
selectionStart
target
.
selectionEnd
)
;
const
count
=
end
-
start
;
text
=
target
.
value
.
substr
(
start
count
)
;
}
else
{
text
=
this
.
styleWindow
.
getSelection
(
)
.
toString
(
)
;
text
=
text
.
replace
(
/
(
\
r
?
\
n
)
\
r
?
\
n
/
g
"
1
"
)
;
}
clipboardHelper
.
copyString
(
text
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
async
_onAddRule
(
)
{
const
elementStyle
=
this
.
_elementStyle
;
const
element
=
elementStyle
.
element
;
const
pseudoClasses
=
element
.
pseudoClassLocks
;
this
.
_focusNextUserAddedRule
=
true
;
this
.
pageStyle
.
addNewRule
(
element
pseudoClasses
)
;
}
refreshAddRuleButtonState
(
)
{
const
shouldBeDisabled
=
!
this
.
_viewedElement
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
|
|
this
.
inspector
.
selection
.
isAnonymousNode
(
)
;
this
.
addRuleButton
.
disabled
=
shouldBeDisabled
;
}
get
isEditing
(
)
{
return
(
this
.
tooltips
.
isEditing
|
|
!
!
this
.
element
.
querySelectorAll
(
"
.
styleinspector
-
propertyeditor
"
)
.
length
)
;
}
_handleUAStylePrefChange
(
)
{
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
_handlePrefChange
(
PREF_UA_STYLES
)
;
}
_handleDefaultColorUnitPrefChange
(
)
{
this
.
_handlePrefChange
(
PREF_DEFAULT_COLOR_UNIT
)
;
}
_handleDraggablePrefChange
(
)
{
this
.
draggablePropertiesEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_DRAGGABLE
false
)
;
this
.
emit
(
"
draggable
-
preference
-
updated
"
)
;
}
_handlePrefChange
(
pref
)
{
const
refreshOnPrefs
=
[
PREF_UA_STYLES
PREF_DEFAULT_COLOR_UNIT
]
;
if
(
refreshOnPrefs
.
indexOf
(
pref
)
>
-
1
)
{
this
.
selectElement
(
this
.
_viewedElement
true
)
;
}
}
setFilterStyles
(
value
=
"
"
)
{
this
.
searchField
.
value
=
value
;
this
.
searchField
.
focus
(
)
;
this
.
_onFilterStyles
(
)
;
}
_onFilterStyles
(
)
{
if
(
this
.
_filterChangedTimeout
)
{
clearTimeout
(
this
.
_filterChangedTimeout
)
;
}
const
filterTimeout
=
this
.
searchValue
.
length
?
FILTER_CHANGED_TIMEOUT
:
0
;
this
.
searchClearButton
.
hidden
=
this
.
searchValue
.
length
=
=
=
0
;
this
.
_filterChangedTimeout
=
setTimeout
(
(
)
=
>
{
this
.
searchData
=
{
searchPropertyMatch
:
FILTER_PROP_RE
.
exec
(
this
.
searchValue
)
searchPropertyName
:
this
.
searchValue
searchPropertyValue
:
this
.
searchValue
strictSearchValue
:
"
"
strictSearchPropertyName
:
false
strictSearchPropertyValue
:
false
strictSearchAllValues
:
false
}
;
if
(
this
.
searchData
.
searchPropertyMatch
)
{
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
)
{
this
.
searchData
.
strictSearchPropertyName
=
true
;
this
.
searchData
.
searchPropertyName
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyName
=
this
.
searchData
.
searchPropertyMatch
[
1
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
)
{
this
.
searchData
.
strictSearchPropertyValue
=
true
;
this
.
searchData
.
searchPropertyValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyValue
=
this
.
searchData
.
searchPropertyMatch
[
2
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
this
.
searchData
.
strictSearchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
}
}
else
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
const
searchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
this
.
searchData
.
strictSearchAllValues
=
true
;
this
.
searchData
.
searchPropertyName
=
searchValue
;
this
.
searchData
.
searchPropertyValue
=
searchValue
;
this
.
searchData
.
strictSearchValue
=
searchValue
;
}
this
.
_clearHighlight
(
this
.
element
)
;
this
.
_clearRules
(
)
;
this
.
_createEditors
(
)
;
this
.
inspector
.
emit
(
"
ruleview
-
filtered
"
)
;
this
.
_filterChangeTimeout
=
null
;
}
filterTimeout
)
;
}
_onClearSearch
(
)
{
if
(
this
.
searchField
.
value
)
{
this
.
setFilterStyles
(
"
"
)
;
return
true
;
}
return
false
;
}
destroy
(
)
{
this
.
isDestroyed
=
true
;
this
.
clear
(
)
;
this
.
_dummyElement
=
null
;
this
.
_prefObserver
.
off
(
PREF_UA_STYLES
this
.
_handleUAStylePrefChange
)
;
this
.
_prefObserver
.
off
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handleDefaultColorUnitPrefChange
)
;
this
.
_prefObserver
.
off
(
PREF_DRAGGABLE
this
.
_handleDraggablePrefChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
this
.
_outputParser
=
null
;
if
(
this
.
_classListPreviewer
)
{
this
.
_classListPreviewer
.
destroy
(
)
;
this
.
_classListPreviewer
=
null
;
}
if
(
this
.
_contextMenu
)
{
this
.
_contextMenu
.
destroy
(
)
;
this
.
_contextMenu
=
null
;
}
if
(
this
.
_highlighters
)
{
this
.
_highlighters
.
removeFromView
(
this
)
;
this
.
_highlighters
=
null
;
}
this
.
colorSchemeLightSimulationButton
.
removeEventListener
(
"
click
"
this
.
_onToggleLightColorSchemeSimulation
)
;
this
.
colorSchemeDarkSimulationButton
.
removeEventListener
(
"
click
"
this
.
_onToggleDarkColorSchemeSimulation
)
;
this
.
printSimulationButton
.
removeEventListener
(
"
click
"
this
.
_onTogglePrintSimulation
)
;
this
.
colorSchemeLightSimulationButton
=
null
;
this
.
colorSchemeDarkSimulationButton
=
null
;
this
.
printSimulationButton
=
null
;
this
.
tooltips
.
destroy
(
)
;
this
.
shortcuts
.
destroy
(
)
;
this
.
styleDocument
.
removeEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
this
.
element
.
removeEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
removeEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
removeEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
removeEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassPanel
.
removeEventListener
(
"
change
"
this
.
_onTogglePseudoClass
)
;
this
.
pseudoClassToggle
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
classToggle
.
removeEventListener
(
"
click
"
this
.
_onToggleClassPanel
)
;
this
.
inspector
.
highlighters
.
off
(
"
highlighter
-
shown
"
this
.
onHighlighterShown
)
;
this
.
inspector
.
highlighters
.
off
(
"
highlighter
-
hidden
"
this
.
onHighlighterHidden
)
;
this
.
searchField
=
null
;
this
.
searchClearButton
=
null
;
this
.
pseudoClassPanel
=
null
;
this
.
pseudoClassToggle
=
null
;
this
.
pseudoClassCheckboxes
=
null
;
this
.
classPanel
=
null
;
this
.
classToggle
=
null
;
this
.
inspector
=
null
;
this
.
styleDocument
=
null
;
this
.
styleWindow
=
null
;
if
(
this
.
element
.
parentNode
)
{
this
.
element
.
remove
(
)
;
}
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
}
if
(
this
.
_popup
)
{
this
.
_popup
.
destroy
(
)
;
this
.
_popup
=
null
;
}
}
_startSelectingElement
(
)
{
this
.
element
.
classList
.
add
(
"
non
-
interactive
"
)
;
}
_stopSelectingElement
(
)
{
this
.
element
.
classList
.
remove
(
"
non
-
interactive
"
)
;
}
selectElement
(
element
allowRefresh
=
false
)
{
const
refresh
=
this
.
_viewedElement
=
=
=
element
;
if
(
refresh
&
&
!
allowRefresh
)
{
return
Promise
.
resolve
(
undefined
)
;
}
if
(
this
.
_popup
&
&
this
.
popup
.
isOpen
)
{
this
.
popup
.
hidePopup
(
)
;
}
this
.
clear
(
false
)
;
this
.
_viewedElement
=
element
;
this
.
clearPseudoClassPanel
(
)
;
this
.
refreshAddRuleButtonState
(
)
;
if
(
!
this
.
_viewedElement
)
{
this
.
_stopSelectingElement
(
)
;
this
.
_clearRules
(
)
;
this
.
_showEmpty
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
if
(
this
.
pageStyle
)
{
this
.
pageStyle
.
off
(
"
stylesheet
-
updated
"
this
.
refreshPanel
)
;
this
.
pageStyle
=
null
;
}
return
Promise
.
resolve
(
undefined
)
;
}
this
.
pageStyle
=
element
.
inspectorFront
.
pageStyle
;
this
.
pageStyle
.
on
(
"
stylesheet
-
updated
"
this
.
refreshPanel
)
;
const
dummyElementPromise
=
Promise
.
resolve
(
this
.
styleDocument
)
.
then
(
document
=
>
{
const
namespaceURI
=
this
.
element
.
namespaceURI
|
|
document
.
documentElement
.
namespaceURI
;
this
.
_dummyElement
=
document
.
createElementNS
(
namespaceURI
this
.
element
.
tagName
)
;
}
)
.
catch
(
promiseWarn
)
;
const
elementStyle
=
new
ElementStyle
(
element
this
this
.
store
this
.
pageStyle
this
.
showUserAgentStyles
)
;
this
.
_elementStyle
=
elementStyle
;
this
.
_startSelectingElement
(
)
;
return
dummyElementPromise
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
return
this
.
_populate
(
)
;
}
return
undefined
;
}
)
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
if
(
!
refresh
)
{
this
.
element
.
scrollTop
=
0
;
}
this
.
_stopSelectingElement
(
)
;
this
.
_elementStyle
.
onChanged
=
(
)
=
>
{
this
.
_changed
(
)
;
}
;
}
}
)
.
catch
(
e
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
this
.
_stopSelectingElement
(
)
;
this
.
_clearRules
(
)
;
}
console
.
error
(
e
)
;
}
)
;
}
refreshPanel
(
)
{
if
(
!
this
.
isPanelVisible
(
)
|
|
this
.
isEditing
|
|
!
this
.
_elementStyle
)
{
return
Promise
.
resolve
(
undefined
)
;
}
const
promises
=
[
]
;
for
(
const
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
_applyingModifications
)
{
promises
.
push
(
rule
.
_applyingModifications
)
;
}
}
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
{
return
this
.
_populate
(
)
;
}
)
;
}
clearPseudoClassPanel
(
)
{
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
checked
=
false
;
checkbox
.
disabled
=
false
;
}
)
;
}
_createPseudoClassCheckboxes
(
)
{
const
doc
=
this
.
styleDocument
;
const
fragment
=
doc
.
createDocumentFragment
(
)
;
for
(
const
pseudo
of
PSEUDO_CLASSES
)
{
const
label
=
doc
.
createElement
(
"
label
"
)
;
const
checkbox
=
doc
.
createElement
(
"
input
"
)
;
checkbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
checkbox
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
checkbox
.
setAttribute
(
"
value
"
pseudo
)
;
label
.
append
(
checkbox
pseudo
)
;
fragment
.
append
(
label
)
;
}
this
.
pseudoClassPanel
.
append
(
fragment
)
;
return
Array
.
from
(
this
.
pseudoClassPanel
.
querySelectorAll
(
"
input
[
type
=
checkbox
]
"
)
)
;
}
refreshPseudoClassPanel
(
)
{
if
(
!
this
.
_elementStyle
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
disabled
=
true
;
}
)
;
return
;
}
const
pseudoClassLocks
=
this
.
_elementStyle
.
element
.
pseudoClassLocks
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
disabled
=
false
;
checkbox
.
checked
=
pseudoClassLocks
.
includes
(
checkbox
.
value
)
;
}
)
;
}
_populate
(
)
{
const
elementStyle
=
this
.
_elementStyle
;
return
this
.
_elementStyle
.
populate
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
!
=
=
elementStyle
|
|
this
.
isDestroyed
)
{
return
null
;
}
this
.
_clearRules
(
)
;
const
onEditorsReady
=
this
.
_createEditors
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
return
onEditorsReady
.
then
(
(
)
=
>
{
this
.
emit
(
"
ruleview
-
refreshed
"
)
;
}
console
.
error
)
;
}
)
.
catch
(
promiseWarn
)
;
}
_showEmpty
(
)
{
if
(
this
.
styleDocument
.
getElementById
(
"
ruleview
-
no
-
results
"
)
)
{
return
;
}
createChild
(
this
.
element
"
div
"
{
id
:
"
ruleview
-
no
-
results
"
class
:
"
devtools
-
sidepanel
-
no
-
result
"
textContent
:
l10n
(
"
rule
.
empty
"
)
}
)
;
}
_clearRules
(
)
{
this
.
element
.
innerHTML
=
"
"
;
}
clear
(
clearDom
=
true
)
{
if
(
clearDom
)
{
this
.
_clearRules
(
)
;
}
this
.
_viewedElement
=
null
;
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
this
.
_elementStyle
=
null
;
}
if
(
this
.
pageStyle
)
{
this
.
pageStyle
.
off
(
"
stylesheet
-
updated
"
this
.
refreshPanel
)
;
this
.
pageStyle
=
null
;
}
}
_changed
(
)
{
this
.
emit
(
"
ruleview
-
changed
"
)
;
}
get
selectedElementLabel
(
)
{
if
(
this
.
_selectedElementLabel
)
{
return
this
.
_selectedElementLabel
;
}
this
.
_selectedElementLabel
=
l10n
(
"
rule
.
selectedElement
"
)
;
return
this
.
_selectedElementLabel
;
}
get
pseudoElementLabel
(
)
{
if
(
this
.
_pseudoElementLabel
)
{
return
this
.
_pseudoElementLabel
;
}
this
.
_pseudoElementLabel
=
l10n
(
"
rule
.
pseudoElement
"
)
;
return
this
.
_pseudoElementLabel
;
}
get
showPseudoElements
(
)
{
if
(
this
.
_showPseudoElements
=
=
=
undefined
)
{
this
.
_showPseudoElements
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
)
;
}
return
this
.
_showPseudoElements
;
}
createExpandableContainer
(
label
containerId
isPseudo
=
false
)
{
const
header
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
header
.
classList
.
add
(
RULE_VIEW_HEADER_CLASSNAME
"
ruleview
-
expandable
-
header
"
)
;
header
.
setAttribute
(
"
role
"
"
heading
"
)
;
const
toggleButton
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
button
"
)
;
toggleButton
.
setAttribute
(
"
title
"
l10n
(
"
rule
.
expandableContainerToggleButton
.
title
"
)
)
;
toggleButton
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
toggleButton
.
setAttribute
(
"
aria
-
controls
"
containerId
)
;
const
twisty
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
span
"
)
;
twisty
.
className
=
"
ruleview
-
expander
theme
-
twisty
"
;
toggleButton
.
append
(
twisty
this
.
styleDocument
.
createTextNode
(
label
)
)
;
header
.
append
(
toggleButton
)
;
const
container
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
container
.
id
=
containerId
;
container
.
classList
.
add
(
"
ruleview
-
expandable
-
container
"
)
;
container
.
hidden
=
false
;
this
.
element
.
append
(
header
container
)
;
toggleButton
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
_toggleContainerVisibility
(
toggleButton
container
isPseudo
!
this
.
showPseudoElements
)
;
}
)
;
if
(
isPseudo
)
{
this
.
_toggleContainerVisibility
(
toggleButton
container
isPseudo
this
.
showPseudoElements
)
;
}
return
container
;
}
_toggleContainerVisibility
(
toggleButton
container
isPseudo
showPseudo
)
{
let
isOpen
=
toggleButton
.
getAttribute
(
"
aria
-
expanded
"
)
=
=
=
"
true
"
;
if
(
isPseudo
)
{
this
.
_showPseudoElements
=
!
!
showPseudo
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
this
.
showPseudoElements
)
;
container
.
hidden
=
!
this
.
showPseudoElements
;
isOpen
=
!
this
.
showPseudoElements
;
}
else
{
container
.
hidden
=
!
container
.
hidden
;
}
toggleButton
.
setAttribute
(
"
aria
-
expanded
"
!
isOpen
)
;
}
_createEditors
(
)
{
let
lastInheritedSource
=
"
"
;
let
lastKeyframes
=
null
;
let
seenPseudoElement
=
false
;
let
seenNormalElement
=
false
;
let
seenSearchTerm
=
false
;
let
container
=
null
;
if
(
!
this
.
_elementStyle
.
rules
)
{
return
Promise
.
resolve
(
)
;
}
const
editorReadyPromises
=
[
]
;
for
(
const
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
domRule
.
system
)
{
continue
;
}
if
(
!
rule
.
editor
)
{
rule
.
editor
=
new
RuleEditor
(
this
rule
)
;
editorReadyPromises
.
push
(
rule
.
editor
.
once
(
"
source
-
link
-
updated
"
)
)
;
}
if
(
this
.
searchValue
&
&
this
.
searchData
)
{
if
(
this
.
highlightRule
(
rule
)
)
{
seenSearchTerm
=
true
;
}
else
if
(
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
continue
;
}
}
if
(
seenPseudoElement
&
&
!
seenNormalElement
&
&
!
rule
.
pseudoElement
)
{
seenNormalElement
=
true
;
const
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
RULE_VIEW_HEADER_CLASSNAME
;
div
.
setAttribute
(
"
role
"
"
heading
"
)
;
div
.
textContent
=
this
.
selectedElementLabel
;
this
.
element
.
appendChild
(
div
)
;
}
const
inheritedSource
=
rule
.
inherited
;
if
(
inheritedSource
&
&
inheritedSource
!
=
=
lastInheritedSource
)
{
const
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
RULE_VIEW_HEADER_CLASSNAME
;
div
.
setAttribute
(
"
role
"
"
heading
"
)
;
div
.
setAttribute
(
"
aria
-
level
"
"
3
"
)
;
div
.
textContent
=
rule
.
inheritedSource
;
lastInheritedSource
=
inheritedSource
;
this
.
element
.
appendChild
(
div
)
;
}
if
(
!
seenPseudoElement
&
&
rule
.
pseudoElement
)
{
seenPseudoElement
=
true
;
container
=
this
.
createExpandableContainer
(
this
.
pseudoElementLabel
PSEUDO_ELEMENTS_CONTAINER_ID
true
)
;
}
const
keyframes
=
rule
.
keyframes
;
if
(
keyframes
&
&
keyframes
!
=
=
lastKeyframes
)
{
lastKeyframes
=
keyframes
;
container
=
this
.
createExpandableContainer
(
rule
.
keyframesName
keyframes
-
container
-
{
keyframes
.
name
}
)
;
}
rule
.
editor
.
element
.
setAttribute
(
"
role
"
"
article
"
)
;
if
(
container
&
&
(
rule
.
pseudoElement
|
|
keyframes
)
)
{
container
.
appendChild
(
rule
.
editor
.
element
)
;
}
else
{
this
.
element
.
appendChild
(
rule
.
editor
.
element
)
;
}
if
(
this
.
_focusNextUserAddedRule
&
&
rule
.
domRule
.
userAdded
)
{
this
.
_focusNextUserAddedRule
=
null
;
rule
.
editor
.
selectorText
.
click
(
)
;
this
.
emitForTests
(
"
new
-
rule
-
added
"
)
;
}
}
const
searchBox
=
this
.
searchField
.
parentNode
;
searchBox
.
classList
.
toggle
(
"
devtools
-
searchbox
-
no
-
match
"
this
.
searchValue
&
&
!
seenSearchTerm
)
;
return
Promise
.
all
(
editorReadyPromises
)
;
}
highlightRule
(
rule
)
{
const
isRuleSelectorHighlighted
=
this
.
_highlightRuleSelector
(
rule
)
;
const
isStyleSheetHighlighted
=
this
.
_highlightStyleSheet
(
rule
)
;
const
isAncestorRulesHighlighted
=
this
.
_highlightAncestorRules
(
rule
)
;
let
isHighlighted
=
isRuleSelectorHighlighted
|
|
isStyleSheetHighlighted
|
|
isAncestorRulesHighlighted
;
for
(
const
textProp
of
rule
.
textProps
)
{
if
(
!
textProp
.
invisible
&
&
this
.
_highlightProperty
(
textProp
.
editor
)
)
{
isHighlighted
=
true
;
}
}
return
isHighlighted
;
}
_highlightRuleSelector
(
rule
)
{
let
isSelectorHighlighted
=
false
;
let
selectorNodes
=
[
.
.
.
rule
.
editor
.
selectorText
.
childNodes
]
;
if
(
rule
.
domRule
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
{
selectorNodes
=
[
rule
.
editor
.
selectorText
]
;
}
else
if
(
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
selectorNodes
=
[
]
;
}
for
(
const
selectorNode
of
selectorNodes
)
{
const
selector
=
selectorNode
.
textContent
.
toLowerCase
(
)
;
if
(
(
this
.
searchData
.
strictSearchAllValues
&
&
selector
=
=
=
this
.
searchData
.
strictSearchValue
)
|
|
(
!
this
.
searchData
.
strictSearchAllValues
&
&
selector
.
includes
(
this
.
searchValue
)
)
)
{
selectorNode
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
isSelectorHighlighted
=
true
;
}
}
return
isSelectorHighlighted
;
}
_highlightAncestorRules
(
rule
)
{
const
element
=
rule
.
editor
.
ancestorDataEl
;
if
(
!
element
)
{
return
false
;
}
const
ancestorSelectors
=
element
.
querySelectorAll
(
"
.
ruleview
-
rule
-
ancestor
-
selectorcontainer
"
)
;
let
isHighlighted
=
false
;
for
(
const
child
of
ancestorSelectors
)
{
const
dataText
=
child
.
innerText
.
toLowerCase
(
)
;
const
matches
=
this
.
searchData
.
strictSearchValue
?
dataText
=
=
=
this
.
searchData
.
strictSearchValue
:
dataText
.
includes
(
this
.
searchValue
)
;
if
(
matches
)
{
isHighlighted
=
true
;
child
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
}
return
isHighlighted
;
}
_highlightStyleSheet
(
rule
)
{
const
styleSheetSource
=
rule
.
title
.
toLowerCase
(
)
;
const
isStyleSheetHighlighted
=
this
.
searchData
.
strictSearchValue
?
styleSheetSource
=
=
=
this
.
searchData
.
strictSearchValue
:
styleSheetSource
.
includes
(
this
.
searchValue
)
;
if
(
isStyleSheetHighlighted
)
{
rule
.
editor
.
source
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
isStyleSheetHighlighted
;
}
_highlightProperty
(
editor
)
{
const
isPropertyHighlighted
=
this
.
_highlightRuleProperty
(
editor
)
;
const
isComputedHighlighted
=
this
.
_highlightComputedProperty
(
editor
)
;
if
(
!
isPropertyHighlighted
&
&
isComputedHighlighted
&
&
!
editor
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
editor
.
expandForFilter
(
)
;
}
return
isPropertyHighlighted
|
|
isComputedHighlighted
;
}
_updatePropertyHighlight
(
editor
)
{
if
(
!
this
.
searchValue
|
|
!
this
.
searchData
)
{
return
;
}
this
.
_clearHighlight
(
editor
.
element
)
;
if
(
this
.
_highlightProperty
(
editor
)
)
{
this
.
searchField
.
classList
.
remove
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
}
_highlightRuleProperty
(
editor
)
{
const
propertyName
=
editor
.
prop
.
name
.
toLowerCase
(
)
;
const
propertyValue
=
editor
.
valueSpan
.
textContent
.
toLowerCase
(
)
;
return
this
.
_highlightMatches
(
editor
.
container
propertyName
propertyValue
)
;
}
_highlightComputedProperty
(
editor
)
{
let
isComputedHighlighted
=
false
;
editor
.
_populateComputed
(
)
;
for
(
const
computed
of
editor
.
prop
.
computed
)
{
if
(
computed
.
element
)
{
const
computedName
=
computed
.
name
.
toLowerCase
(
)
;
const
computedValue
=
computed
.
parsedValue
.
toLowerCase
(
)
;
isComputedHighlighted
=
this
.
_highlightMatches
(
computed
.
element
computedName
computedValue
)
?
true
:
isComputedHighlighted
;
}
}
return
isComputedHighlighted
;
}
_highlightMatches
(
element
propertyName
propertyValue
)
{
const
{
searchPropertyName
searchPropertyValue
searchPropertyMatch
strictSearchPropertyName
strictSearchPropertyValue
strictSearchAllValues
}
=
this
.
searchData
;
let
matches
=
false
;
const
hasNameAndValue
=
searchPropertyMatch
&
&
searchPropertyName
&
&
searchPropertyValue
;
const
isMatch
=
(
value
query
isStrict
)
=
>
{
return
isStrict
?
value
=
=
=
query
:
query
&
&
value
.
includes
(
query
)
;
}
;
if
(
hasNameAndValue
)
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
)
&
&
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
)
;
}
else
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
|
|
strictSearchAllValues
)
|
|
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
|
|
strictSearchAllValues
)
;
}
if
(
matches
)
{
element
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
matches
;
}
_clearHighlight
(
element
)
{
for
(
const
el
of
element
.
querySelectorAll
(
"
.
ruleview
-
highlight
"
)
)
{
el
.
classList
.
remove
(
"
ruleview
-
highlight
"
)
;
}
for
(
const
computed
of
element
.
querySelectorAll
(
"
.
ruleview
-
computedlist
[
filter
-
open
]
"
)
)
{
computed
.
parentNode
.
_textPropertyEditor
.
collapseForFilter
(
)
;
}
}
_onTogglePseudoClassPanel
(
)
{
if
(
this
.
pseudoClassPanel
.
hidden
)
{
this
.
showPseudoClassPanel
(
)
;
}
else
{
this
.
hidePseudoClassPanel
(
)
;
}
}
showPseudoClassPanel
(
)
{
this
.
hideClassPanel
(
)
;
this
.
pseudoClassToggle
.
setAttribute
(
"
aria
-
pressed
"
"
true
"
)
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
)
;
this
.
pseudoClassPanel
.
hidden
=
false
;
}
hidePseudoClassPanel
(
)
{
this
.
pseudoClassToggle
.
setAttribute
(
"
aria
-
pressed
"
"
false
"
)
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
}
)
;
this
.
pseudoClassPanel
.
hidden
=
true
;
}
_onTogglePseudoClass
(
event
)
{
const
target
=
event
.
target
;
this
.
inspector
.
togglePseudoClass
(
target
.
value
)
;
}
_onToggleClassPanel
(
)
{
if
(
this
.
classPanel
.
hidden
)
{
this
.
showClassPanel
(
)
;
}
else
{
this
.
hideClassPanel
(
)
;
}
}
showClassPanel
(
)
{
this
.
hidePseudoClassPanel
(
)
;
this
.
classToggle
.
setAttribute
(
"
aria
-
pressed
"
"
true
"
)
;
this
.
classPanel
.
hidden
=
false
;
this
.
classListPreviewer
.
focusAddClassField
(
)
;
}
hideClassPanel
(
)
{
this
.
classToggle
.
setAttribute
(
"
aria
-
pressed
"
"
false
"
)
;
this
.
classPanel
.
hidden
=
true
;
}
_onShortcut
(
name
event
)
{
if
(
!
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
)
{
return
;
}
if
(
name
=
=
=
"
CmdOrCtrl
+
F
"
)
{
this
.
searchField
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
else
if
(
(
name
=
=
=
"
Return
"
|
|
name
=
=
=
"
Space
"
)
&
&
this
.
element
.
classList
.
contains
(
"
non
-
interactive
"
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
name
=
=
=
"
Escape
"
&
&
event
.
target
=
=
=
this
.
searchField
&
&
this
.
_onClearSearch
(
)
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
async
_onToggleLightColorSchemeSimulation
(
)
{
const
shouldSimulateLightScheme
=
this
.
colorSchemeLightSimulationButton
.
getAttribute
(
"
aria
-
pressed
"
)
!
=
=
"
true
"
;
this
.
colorSchemeLightSimulationButton
.
setAttribute
(
"
aria
-
pressed
"
shouldSimulateLightScheme
)
;
this
.
colorSchemeDarkSimulationButton
.
setAttribute
(
"
aria
-
pressed
"
"
false
"
)
;
await
this
.
inspector
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
colorSchemeSimulation
:
shouldSimulateLightScheme
?
"
light
"
:
null
}
)
;
this
.
refreshPanel
(
)
;
}
async
_onToggleDarkColorSchemeSimulation
(
)
{
const
shouldSimulateDarkScheme
=
this
.
colorSchemeDarkSimulationButton
.
getAttribute
(
"
aria
-
pressed
"
)
!
=
=
"
true
"
;
this
.
colorSchemeDarkSimulationButton
.
setAttribute
(
"
aria
-
pressed
"
shouldSimulateDarkScheme
)
;
this
.
colorSchemeLightSimulationButton
.
setAttribute
(
"
aria
-
pressed
"
"
false
"
)
;
await
this
.
inspector
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
colorSchemeSimulation
:
shouldSimulateDarkScheme
?
"
dark
"
:
null
}
)
;
this
.
refreshPanel
(
)
;
}
async
_onTogglePrintSimulation
(
)
{
const
enabled
=
this
.
printSimulationButton
.
getAttribute
(
"
aria
-
pressed
"
)
!
=
=
"
true
"
;
this
.
printSimulationButton
.
setAttribute
(
"
aria
-
pressed
"
enabled
)
;
await
this
.
inspector
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
printSimulationEnabled
:
enabled
}
)
;
this
.
refreshPanel
(
)
;
}
_flashElement
(
element
)
{
flashElementOn
(
element
{
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
if
(
this
.
_flashMutationTimer
)
{
clearTimeout
(
this
.
_removeFlashOutTimer
)
;
this
.
_flashMutationTimer
=
null
;
}
this
.
_flashMutationTimer
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
element
{
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
this
.
emit
(
"
scrolled
-
to
-
element
"
)
;
}
PROPERTY_FLASHING_DURATION
)
;
}
_scrollToElement
(
rule
declaration
scrollBehavior
=
"
smooth
"
)
{
let
elementToScrollTo
=
rule
;
if
(
declaration
)
{
const
{
offsetTop
offsetHeight
}
=
declaration
;
const
distance
=
offsetTop
+
offsetHeight
-
rule
.
offsetTop
;
if
(
this
.
element
.
parentNode
.
offsetHeight
<
=
distance
)
{
elementToScrollTo
=
declaration
;
}
}
const
win
=
elementToScrollTo
.
ownerGlobal
;
const
reducedMotion
=
win
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
)
"
)
.
matches
;
scrollBehavior
=
reducedMotion
?
"
auto
"
:
scrollBehavior
;
elementToScrollTo
.
scrollIntoView
(
{
behavior
:
scrollBehavior
}
)
;
}
_togglePseudoElementRuleContainer
(
)
{
const
container
=
this
.
styleDocument
.
getElementById
(
PSEUDO_ELEMENTS_CONTAINER_ID
)
;
const
toggle
=
this
.
styleDocument
.
querySelector
(
[
aria
-
controls
=
"
{
PSEUDO_ELEMENTS_CONTAINER_ID
}
"
]
)
;
this
.
_toggleContainerVisibility
(
toggle
container
true
true
)
;
}
highlightElementRule
(
ruleId
)
{
let
scrollBehavior
=
"
smooth
"
;
const
rule
=
this
.
rules
.
find
(
r
=
>
r
.
domRule
.
actorID
=
=
=
ruleId
)
;
if
(
!
rule
)
{
return
;
}
if
(
rule
.
domRule
.
actorID
=
=
=
ruleId
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
const
{
editor
:
{
element
}
}
=
rule
;
this
.
_scrollToElement
(
element
null
scrollBehavior
)
;
this
.
_flashElement
(
element
)
;
}
}
highlightProperty
(
name
)
{
for
(
const
rule
of
this
.
rules
)
{
for
(
const
textProp
of
rule
.
textProps
)
{
if
(
textProp
.
overridden
|
|
textProp
.
invisible
|
|
!
textProp
.
enabled
)
{
continue
;
}
const
{
editor
:
{
selectorText
}
}
=
rule
;
let
scrollBehavior
=
"
smooth
"
;
if
(
textProp
.
name
=
=
=
name
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
this
.
_scrollToElement
(
selectorText
textProp
.
editor
.
element
scrollBehavior
)
;
this
.
_flashElement
(
textProp
.
editor
.
element
)
;
return
true
;
}
for
(
const
computed
of
textProp
.
computed
)
{
if
(
computed
.
overridden
)
{
continue
;
}
if
(
computed
.
name
=
=
=
name
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
textProp
.
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
textProp
.
editor
.
expandForFilter
(
)
;
this
.
_scrollToElement
(
selectorText
computed
.
element
scrollBehavior
)
;
this
.
_flashElement
(
computed
.
element
)
;
return
true
;
}
}
}
}
return
false
;
}
}
;
class
RuleViewTool
{
constructor
(
inspector
window
)
{
this
.
inspector
=
inspector
;
this
.
document
=
window
.
document
;
this
.
view
=
new
CssRuleView
(
this
.
inspector
this
.
document
)
;
this
.
refresh
=
this
.
refresh
.
bind
(
this
)
;
this
.
onDetachedFront
=
this
.
onDetachedFront
.
bind
(
this
)
;
this
.
onPanelSelected
=
this
.
onPanelSelected
.
bind
(
this
)
;
this
.
onDetachedFront
=
this
.
onDetachedFront
.
bind
(
this
)
;
this
.
onSelected
=
this
.
onSelected
.
bind
(
this
)
;
this
.
onViewRefreshed
=
this
.
onViewRefreshed
.
bind
(
this
)
;
this
.
#
abortController
=
new
window
.
AbortController
(
)
;
const
{
signal
}
=
this
.
#
abortController
;
const
baseEventConfig
=
{
signal
}
;
this
.
view
.
on
(
"
ruleview
-
refreshed
"
this
.
onViewRefreshed
baseEventConfig
)
;
this
.
inspector
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetachedFront
baseEventConfig
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onSelected
baseEventConfig
)
;
this
.
inspector
.
selection
.
on
(
"
pseudoclass
"
this
.
refresh
baseEventConfig
)
;
this
.
inspector
.
ruleViewSideBar
.
on
(
"
ruleview
-
selected
"
this
.
onPanelSelected
baseEventConfig
)
;
this
.
inspector
.
sidebar
.
on
(
"
ruleview
-
selected
"
this
.
onPanelSelected
baseEventConfig
)
;
this
.
inspector
.
toolbox
.
on
(
"
inspector
-
selected
"
this
.
onPanelSelected
baseEventConfig
)
;
this
.
inspector
.
styleChangeTracker
.
on
(
"
style
-
changed
"
this
.
refresh
baseEventConfig
)
;
this
.
inspector
.
commands
.
resourceCommand
.
watchResources
(
[
this
.
inspector
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
this
.
inspector
.
commands
.
resourceCommand
.
TYPES
.
STYLESHEET
]
{
onAvailable
:
this
.
#
onResourceAvailable
ignoreExistingResources
:
true
}
)
;
this
.
readyPromise
=
this
.
onSelected
(
)
;
}
#
abortController
;
isPanelVisible
(
)
{
if
(
!
this
.
view
)
{
return
false
;
}
return
this
.
view
.
isPanelVisible
(
)
;
}
onDetachedFront
(
)
{
this
.
onSelected
(
false
)
;
}
onSelected
(
selectElement
=
true
)
{
if
(
!
this
.
view
)
{
return
null
;
}
const
isInactive
=
!
this
.
isPanelVisible
(
)
&
&
this
.
inspector
.
selection
.
nodeFront
;
if
(
isInactive
)
{
return
null
;
}
if
(
!
this
.
inspector
.
selection
.
isConnected
(
)
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
return
this
.
view
.
selectElement
(
null
)
;
}
if
(
!
selectElement
)
{
return
null
;
}
const
done
=
this
.
inspector
.
updating
(
"
rule
-
view
"
)
;
return
this
.
view
.
selectElement
(
this
.
inspector
.
selection
.
nodeFront
)
.
then
(
done
done
)
;
}
refresh
(
)
{
if
(
this
.
isPanelVisible
(
)
)
{
this
.
view
.
refreshPanel
(
)
;
}
}
#
onResourceAvailable
=
resources
=
>
{
if
(
!
this
.
inspector
)
{
return
;
}
let
hasNewStylesheet
=
false
;
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
=
=
=
this
.
inspector
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
=
"
will
-
navigate
"
&
&
resource
.
targetFront
.
isTopLevel
)
{
this
.
clearUserProperties
(
)
;
continue
;
}
if
(
resource
.
resourceType
=
=
=
this
.
inspector
.
commands
.
resourceCommand
.
TYPES
.
STYLESHEET
&
&
!
resource
.
isNew
)
{
hasNewStylesheet
=
true
;
}
}
if
(
hasNewStylesheet
)
{
this
.
refresh
(
)
;
}
}
;
clearUserProperties
(
)
{
if
(
this
.
view
&
&
this
.
view
.
store
&
&
this
.
view
.
store
.
userProperties
)
{
this
.
view
.
store
.
userProperties
.
clear
(
)
;
}
}
onPanelSelected
(
)
{
if
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
this
.
view
.
_viewedElement
)
{
this
.
refresh
(
)
;
}
else
{
this
.
onSelected
(
)
;
}
}
onViewRefreshed
(
)
{
this
.
inspector
.
emit
(
"
rule
-
view
-
refreshed
"
)
;
}
destroy
(
)
{
if
(
this
.
#
abortController
)
{
this
.
#
abortController
.
abort
(
)
;
}
this
.
inspector
.
commands
.
resourceCommand
.
unwatchResources
(
[
this
.
inspector
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
#
onResourceAvailable
}
)
;
this
.
view
.
destroy
(
)
;
this
.
view
=
this
.
document
=
this
.
inspector
=
this
.
readyPromise
=
this
.
#
abortController
=
null
;
}
}
exports
.
CssRuleView
=
CssRuleView
;
exports
.
RuleViewTool
=
RuleViewTool
;
