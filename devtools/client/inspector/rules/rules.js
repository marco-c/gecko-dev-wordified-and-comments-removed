"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
{
l10n
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
devtools
/
shared
/
css
/
constants
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
const
OutputParser
=
require
(
"
devtools
/
client
/
shared
/
output
-
parser
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
ElementStyle
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
element
-
style
"
)
;
const
RuleEditor
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
views
/
rule
-
editor
"
)
;
const
{
VIEW_NODE_FONT_TYPE
VIEW_NODE_IMAGE_URL_TYPE
VIEW_NODE_INACTIVE_CSS
VIEW_NODE_LOCATION_TYPE
VIEW_NODE_PROPERTY_TYPE
VIEW_NODE_SELECTOR_TYPE
VIEW_NODE_SHAPE_POINT_TYPE
VIEW_NODE_SHAPE_SWATCH
VIEW_NODE_VALUE_TYPE
VIEW_NODE_VARIABLE_TYPE
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
node
-
types
"
)
;
const
TooltipsOverlay
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
tooltips
-
overlay
"
)
;
const
{
createChild
promiseWarn
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
debounce
}
=
require
(
"
devtools
/
shared
/
debounce
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
flashElementOn
"
"
devtools
/
client
/
inspector
/
markup
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
flashElementOff
"
"
devtools
/
client
/
inspector
/
markup
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ClassListPreviewer
"
"
devtools
/
client
/
inspector
/
rules
/
views
/
class
-
list
-
previewer
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleInspectorMenu
"
"
devtools
/
client
/
inspector
/
shared
/
style
-
inspector
-
menu
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
clipboardHelper
"
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
PREF_UA_STYLES
=
"
devtools
.
inspector
.
showUserAgentStyles
"
;
const
PREF_DEFAULT_COLOR_UNIT
=
"
devtools
.
defaultColorUnit
"
;
const
FILTER_CHANGED_TIMEOUT
=
150
;
const
PROPERTY_FLASHING_DURATION
=
1000
;
const
FILTER_PROP_RE
=
/
\
s
*
(
[
^
:
\
s
]
*
)
\
s
*
:
\
s
*
(
.
*
?
)
\
s
*
;
?
/
;
const
FILTER_STRICT_RE
=
/
\
s
*
(
.
*
?
)
\
s
*
/
;
const
INSET_POINT_TYPES
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
function
CssRuleView
(
inspector
document
store
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
inspector
=
inspector
;
this
.
cssProperties
=
inspector
.
cssProperties
;
this
.
styleDocument
=
document
;
this
.
styleWindow
=
this
.
styleDocument
.
defaultView
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
inspector
.
pageStyle
;
this
.
debounce
=
debounce
;
this
.
_outputParser
=
new
OutputParser
(
document
this
.
cssProperties
)
;
this
.
_onAddRule
=
this
.
_onAddRule
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onCopy
=
this
.
_onCopy
.
bind
(
this
)
;
this
.
_onFilterStyles
=
this
.
_onFilterStyles
.
bind
(
this
)
;
this
.
_onClearSearch
=
this
.
_onClearSearch
.
bind
(
this
)
;
this
.
_onTogglePseudoClassPanel
=
this
.
_onTogglePseudoClassPanel
.
bind
(
this
)
;
this
.
_onTogglePseudoClass
=
this
.
_onTogglePseudoClass
.
bind
(
this
)
;
this
.
_onToggleClassPanel
=
this
.
_onToggleClassPanel
.
bind
(
this
)
;
this
.
_onTogglePrintSimulation
=
this
.
_onTogglePrintSimulation
.
bind
(
this
)
;
this
.
highlightElementRule
=
this
.
highlightElementRule
.
bind
(
this
)
;
this
.
highlightProperty
=
this
.
highlightProperty
.
bind
(
this
)
;
const
doc
=
this
.
styleDocument
;
this
.
element
=
doc
.
getElementById
(
"
ruleview
-
container
-
focusable
"
)
;
this
.
addRuleButton
=
doc
.
getElementById
(
"
ruleview
-
add
-
rule
-
button
"
)
;
this
.
searchField
=
doc
.
getElementById
(
"
ruleview
-
searchbox
"
)
;
this
.
searchClearButton
=
doc
.
getElementById
(
"
ruleview
-
searchinput
-
clear
"
)
;
this
.
pseudoClassPanel
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
"
)
;
this
.
pseudoClassToggle
=
doc
.
getElementById
(
"
pseudo
-
class
-
panel
-
toggle
"
)
;
this
.
classPanel
=
doc
.
getElementById
(
"
ruleview
-
class
-
panel
"
)
;
this
.
classToggle
=
doc
.
getElementById
(
"
class
-
panel
-
toggle
"
)
;
this
.
printSimulationButton
=
doc
.
getElementById
(
"
print
-
simulation
-
toggle
"
)
;
this
.
_initPrintSimulation
(
)
;
this
.
searchClearButton
.
hidden
=
true
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
styleWindow
}
)
;
this
.
_onShortcut
=
this
.
_onShortcut
.
bind
(
this
)
;
this
.
shortcuts
.
on
(
"
Escape
"
event
=
>
this
.
_onShortcut
(
"
Escape
"
event
)
)
;
this
.
shortcuts
.
on
(
"
Return
"
event
=
>
this
.
_onShortcut
(
"
Return
"
event
)
)
;
this
.
shortcuts
.
on
(
"
Space
"
event
=
>
this
.
_onShortcut
(
"
Space
"
event
)
)
;
this
.
shortcuts
.
on
(
"
CmdOrCtrl
+
F
"
event
=
>
this
.
_onShortcut
(
"
CmdOrCtrl
+
F
"
event
)
)
;
this
.
element
.
addEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
addEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
addEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
addEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassToggle
.
addEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
classToggle
.
addEventListener
(
"
click
"
this
.
_onToggleClassPanel
)
;
this
.
pseudoClassPanel
.
addEventListener
(
"
change
"
this
.
_onTogglePseudoClass
)
;
if
(
flags
.
testing
)
{
this
.
highlighters
.
addToView
(
this
)
;
}
else
{
this
.
element
.
addEventListener
(
"
mousemove
"
(
)
=
>
{
this
.
highlighters
.
addToView
(
this
)
;
}
{
once
:
true
}
)
;
}
this
.
_handlePrefChange
=
this
.
_handlePrefChange
.
bind
(
this
)
;
this
.
_handleUAStylePrefChange
=
this
.
_handleUAStylePrefChange
.
bind
(
this
)
;
this
.
_handleDefaultColorUnitPrefChange
=
this
.
_handleDefaultColorUnitPrefChange
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
PREF_UA_STYLES
this
.
_handleUAStylePrefChange
)
;
this
.
_prefObserver
.
on
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handleDefaultColorUnitPrefChange
)
;
this
.
pseudoClassCheckboxes
=
this
.
_createPseudoClassCheckboxes
(
)
;
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
tooltips
=
new
TooltipsOverlay
(
this
)
;
}
CssRuleView
.
prototype
=
{
_viewedElement
:
null
_filterChangedTimeout
:
null
_dummyElement
:
null
get
popup
(
)
{
if
(
!
this
.
_popup
)
{
this
.
_popup
=
new
AutocompletePopup
(
this
.
inspector
.
toolbox
.
doc
{
autoSelect
:
true
}
)
;
}
return
this
.
_popup
;
}
get
classListPreviewer
(
)
{
if
(
!
this
.
_classListPreviewer
)
{
this
.
_classListPreviewer
=
new
ClassListPreviewer
(
this
.
inspector
this
.
classPanel
)
;
}
return
this
.
_classListPreviewer
;
}
get
contextMenu
(
)
{
if
(
!
this
.
_contextMenu
)
{
this
.
_contextMenu
=
new
StyleInspectorMenu
(
this
{
isRuleView
:
true
}
)
;
}
return
this
.
_contextMenu
;
}
get
dummyElement
(
)
{
return
this
.
_dummyElement
;
}
get
emulationFront
(
)
{
return
this
.
_emulationFront
;
}
get
highlighters
(
)
{
if
(
!
this
.
_highlighters
)
{
this
.
_highlighters
=
this
.
inspector
.
highlighters
;
}
return
this
.
_highlighters
;
}
get
searchValue
(
)
{
return
this
.
searchField
.
value
.
toLowerCase
(
)
;
}
get
rules
(
)
{
return
this
.
_elementStyle
?
this
.
_elementStyle
.
rules
:
[
]
;
}
get
currentTarget
(
)
{
return
this
.
inspector
.
toolbox
.
target
;
}
async
getSelectorHighlighter
(
)
{
if
(
!
this
.
inspector
)
{
return
null
;
}
if
(
this
.
selectorHighlighter
)
{
return
this
.
selectorHighlighter
;
}
try
{
const
front
=
this
.
inspector
.
inspectorFront
;
const
h
=
await
front
.
getHighlighterByType
(
"
SelectorHighlighter
"
)
;
this
.
selectorHighlighter
=
h
;
return
h
;
}
catch
(
e
)
{
return
null
;
}
}
async
toggleSelectorHighlighter
(
selectorIcon
selector
)
{
if
(
this
.
lastSelectorIcon
)
{
this
.
lastSelectorIcon
.
classList
.
remove
(
"
highlighted
"
)
;
}
selectorIcon
.
classList
.
remove
(
"
highlighted
"
)
;
const
highlighter
=
await
this
.
getSelectorHighlighter
(
)
;
if
(
!
highlighter
)
{
return
;
}
await
highlighter
.
hide
(
)
;
if
(
selector
!
=
=
this
.
highlighters
.
selectorHighlighterShown
)
{
this
.
highlighters
.
selectorHighlighterShown
=
selector
;
selectorIcon
.
classList
.
add
(
"
highlighted
"
)
;
this
.
lastSelectorIcon
=
selectorIcon
;
const
node
=
this
.
inspector
.
selection
.
nodeFront
;
await
highlighter
.
show
(
node
{
hideInfoBar
:
true
hideGuides
:
true
selector
}
)
;
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
true
)
;
}
else
{
this
.
highlighters
.
selectorHighlighterShown
=
null
;
this
.
emit
(
"
ruleview
-
selectorhighlighter
-
toggled
"
false
)
;
}
}
async
_initPrintSimulation
(
)
{
this
.
_emulationFront
=
await
this
.
currentTarget
.
getFront
(
"
emulation
"
)
;
if
(
(
await
this
.
currentTarget
.
actorHasMethod
(
"
emulation
"
"
getIsPrintSimulationEnabled
"
)
)
&
&
!
this
.
currentTarget
.
chrome
)
{
this
.
printSimulationButton
.
removeAttribute
(
"
hidden
"
)
;
this
.
printSimulationButton
.
addEventListener
(
"
click
"
this
.
_onTogglePrintSimulation
)
;
}
}
getNodeInfo
:
function
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
type
value
;
const
classes
=
node
.
classList
;
const
prop
=
getParentTextProperty
(
node
)
;
if
(
classes
.
contains
(
"
ruleview
-
propertyname
"
)
&
&
prop
)
{
type
=
VIEW_NODE_PROPERTY_TYPE
;
value
=
{
property
:
node
.
textContent
value
:
getPropertyNameAndValue
(
node
)
.
value
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
propertyvalue
"
)
&
&
prop
)
{
type
=
VIEW_NODE_VALUE_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
font
-
family
"
)
&
&
prop
)
{
type
=
VIEW_NODE_FONT_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
getPropertyNameAndValue
(
node
)
.
value
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
shape
-
point
"
)
&
&
prop
)
{
type
=
VIEW_NODE_SHAPE_POINT_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
toggleActive
:
getShapeToggleActive
(
node
)
point
:
getShapePoint
(
node
)
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
unused
-
warning
"
)
&
&
prop
)
{
type
=
VIEW_NODE_INACTIVE_CSS
;
value
=
prop
.
isUsed
(
)
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
shapeswatch
"
)
&
&
prop
)
{
type
=
VIEW_NODE_SHAPE_SWATCH
;
value
=
{
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
textProperty
:
prop
}
;
}
else
if
(
(
classes
.
contains
(
"
ruleview
-
variable
"
)
|
|
classes
.
contains
(
"
ruleview
-
unmatched
-
variable
"
)
)
&
&
prop
)
{
type
=
VIEW_NODE_VARIABLE_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
variable
:
node
.
dataset
.
variable
}
;
}
else
if
(
classes
.
contains
(
"
theme
-
link
"
)
&
&
!
classes
.
contains
(
"
ruleview
-
rule
-
source
"
)
&
&
prop
)
{
type
=
VIEW_NODE_IMAGE_URL_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
parentNode
.
textContent
url
:
node
.
href
enabled
:
prop
.
enabled
overridden
:
prop
.
overridden
pseudoElement
:
prop
.
rule
.
pseudoElement
sheetHref
:
prop
.
rule
.
domRule
.
href
textProperty
:
prop
}
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
selector
-
unmatched
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
matched
"
)
|
|
classes
.
contains
(
"
ruleview
-
selectorcontainer
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
attribute
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
"
)
|
|
classes
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
)
)
{
type
=
VIEW_NODE_SELECTOR_TYPE
;
value
=
this
.
_getRuleEditorForNode
(
node
)
.
selectorText
.
textContent
;
}
else
if
(
classes
.
contains
(
"
ruleview
-
rule
-
source
"
)
|
|
classes
.
contains
(
"
ruleview
-
rule
-
source
-
label
"
)
)
{
type
=
VIEW_NODE_LOCATION_TYPE
;
const
rule
=
this
.
_getRuleEditorForNode
(
node
)
.
rule
;
value
=
rule
.
sheet
&
&
rule
.
sheet
.
href
?
rule
.
sheet
.
href
:
rule
.
title
;
}
else
{
return
null
;
}
return
{
view
:
"
rule
"
type
value
}
;
}
_getRuleEditorForNode
:
function
(
node
)
{
return
node
.
closest
(
"
.
ruleview
-
rule
"
)
.
_ruleEditor
;
}
_onContextMenu
:
function
(
event
)
{
if
(
event
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
event
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
event
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
contextMenu
.
show
(
event
)
;
}
_onCopy
:
function
(
event
)
{
if
(
event
)
{
this
.
copySelection
(
event
.
target
)
;
event
.
preventDefault
(
)
;
}
}
copySelection
:
function
(
target
)
{
try
{
let
text
=
"
"
;
const
nodeName
=
target
&
&
target
.
nodeName
;
if
(
nodeName
=
=
=
"
input
"
|
|
nodeName
=
=
"
textarea
"
)
{
const
start
=
Math
.
min
(
target
.
selectionStart
target
.
selectionEnd
)
;
const
end
=
Math
.
max
(
target
.
selectionStart
target
.
selectionEnd
)
;
const
count
=
end
-
start
;
text
=
target
.
value
.
substr
(
start
count
)
;
}
else
{
text
=
this
.
styleWindow
.
getSelection
(
)
.
toString
(
)
;
text
=
text
.
replace
(
/
(
\
r
?
\
n
)
\
r
?
\
n
/
g
"
1
"
)
;
}
clipboardHelper
.
copyString
(
text
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
_onAddRule
:
function
(
)
{
const
elementStyle
=
this
.
_elementStyle
;
const
element
=
elementStyle
.
element
;
const
pseudoClasses
=
element
.
pseudoClassLocks
;
const
eventPromise
=
this
.
once
(
"
ruleview
-
refreshed
"
)
;
const
newRulePromise
=
this
.
pageStyle
.
addNewRule
(
element
pseudoClasses
)
;
promise
.
all
(
[
eventPromise
newRulePromise
]
)
.
then
(
values
=
>
{
const
options
=
values
[
1
]
;
for
(
const
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
options
.
rule
=
=
=
rule
.
domRule
)
{
rule
.
editor
.
selectorText
.
click
(
)
;
elementStyle
.
_changed
(
)
;
break
;
}
}
}
)
;
}
refreshAddRuleButtonState
:
function
(
)
{
const
shouldBeDisabled
=
!
this
.
_viewedElement
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
|
|
this
.
inspector
.
selection
.
isAnonymousNode
(
)
;
this
.
addRuleButton
.
disabled
=
shouldBeDisabled
;
}
setPageStyle
:
function
(
pageStyle
)
{
this
.
pageStyle
=
pageStyle
;
}
get
isEditing
(
)
{
return
(
this
.
tooltips
.
isEditing
|
|
this
.
element
.
querySelectorAll
(
"
.
styleinspector
-
propertyeditor
"
)
.
length
>
0
)
;
}
_handleUAStylePrefChange
:
function
(
)
{
this
.
showUserAgentStyles
=
Services
.
prefs
.
getBoolPref
(
PREF_UA_STYLES
)
;
this
.
_handlePrefChange
(
PREF_UA_STYLES
)
;
}
_handleDefaultColorUnitPrefChange
:
function
(
)
{
this
.
_handlePrefChange
(
PREF_DEFAULT_COLOR_UNIT
)
;
}
_handlePrefChange
:
function
(
pref
)
{
const
refreshOnPrefs
=
[
PREF_UA_STYLES
PREF_DEFAULT_COLOR_UNIT
]
;
if
(
refreshOnPrefs
.
indexOf
(
pref
)
>
-
1
)
{
this
.
selectElement
(
this
.
_viewedElement
true
)
;
}
}
setFilterStyles
:
function
(
value
=
"
"
)
{
this
.
searchField
.
value
=
value
;
this
.
searchField
.
focus
(
)
;
this
.
_onFilterStyles
(
)
;
}
_onFilterStyles
:
function
(
)
{
if
(
this
.
_filterChangedTimeout
)
{
clearTimeout
(
this
.
_filterChangedTimeout
)
;
}
const
filterTimeout
=
this
.
searchValue
.
length
>
0
?
FILTER_CHANGED_TIMEOUT
:
0
;
this
.
searchClearButton
.
hidden
=
this
.
searchValue
.
length
=
=
=
0
;
this
.
_filterChangedTimeout
=
setTimeout
(
(
)
=
>
{
this
.
searchData
=
{
searchPropertyMatch
:
FILTER_PROP_RE
.
exec
(
this
.
searchValue
)
searchPropertyName
:
this
.
searchValue
searchPropertyValue
:
this
.
searchValue
strictSearchValue
:
"
"
strictSearchPropertyName
:
false
strictSearchPropertyValue
:
false
strictSearchAllValues
:
false
}
;
if
(
this
.
searchData
.
searchPropertyMatch
)
{
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
)
{
this
.
searchData
.
strictSearchPropertyName
=
true
;
this
.
searchData
.
searchPropertyName
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
1
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyName
=
this
.
searchData
.
searchPropertyMatch
[
1
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
)
{
this
.
searchData
.
strictSearchPropertyValue
=
true
;
this
.
searchData
.
searchPropertyValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchData
.
searchPropertyMatch
[
2
]
)
[
1
]
;
}
else
{
this
.
searchData
.
searchPropertyValue
=
this
.
searchData
.
searchPropertyMatch
[
2
]
;
}
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
this
.
searchData
.
strictSearchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
}
}
else
if
(
FILTER_STRICT_RE
.
test
(
this
.
searchValue
)
)
{
const
searchValue
=
FILTER_STRICT_RE
.
exec
(
this
.
searchValue
)
[
1
]
;
this
.
searchData
.
strictSearchAllValues
=
true
;
this
.
searchData
.
searchPropertyName
=
searchValue
;
this
.
searchData
.
searchPropertyValue
=
searchValue
;
this
.
searchData
.
strictSearchValue
=
searchValue
;
}
this
.
_clearHighlight
(
this
.
element
)
;
this
.
_clearRules
(
)
;
this
.
_createEditors
(
)
;
this
.
inspector
.
emit
(
"
ruleview
-
filtered
"
)
;
this
.
_filterChangeTimeout
=
null
;
}
filterTimeout
)
;
}
_onClearSearch
:
function
(
)
{
if
(
this
.
searchField
.
value
)
{
this
.
setFilterStyles
(
"
"
)
;
return
true
;
}
return
false
;
}
destroy
:
function
(
)
{
this
.
isDestroyed
=
true
;
this
.
clear
(
)
;
this
.
_dummyElement
=
null
;
this
.
_prefObserver
.
off
(
PREF_UA_STYLES
this
.
_handleUAStylePrefChange
)
;
this
.
_prefObserver
.
off
(
PREF_DEFAULT_COLOR_UNIT
this
.
_handleDefaultColorUnitPrefChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
this
.
_outputParser
=
null
;
if
(
this
.
_classListPreviewer
)
{
this
.
_classListPreviewer
.
destroy
(
)
;
this
.
_classListPreviewer
=
null
;
}
if
(
this
.
_contextMenu
)
{
this
.
_contextMenu
.
destroy
(
)
;
this
.
_contextMenu
=
null
;
}
if
(
this
.
_highlighters
)
{
this
.
_highlighters
.
removeFromView
(
this
)
;
this
.
_highlighters
=
null
;
}
if
(
this
.
_emulationFront
)
{
this
.
printSimulationButton
.
removeEventListener
(
"
click
"
this
.
_onTogglePrintSimulation
)
;
this
.
_emulationFront
.
destroy
(
)
;
this
.
printSimulationButton
=
null
;
this
.
_emulationFront
=
null
;
}
this
.
tooltips
.
destroy
(
)
;
this
.
shortcuts
.
destroy
(
)
;
this
.
element
.
removeEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
element
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
addRuleButton
.
removeEventListener
(
"
click
"
this
.
_onAddRule
)
;
this
.
searchField
.
removeEventListener
(
"
input
"
this
.
_onFilterStyles
)
;
this
.
searchClearButton
.
removeEventListener
(
"
click
"
this
.
_onClearSearch
)
;
this
.
pseudoClassPanel
.
removeEventListener
(
"
change
"
this
.
_onTogglePseudoClass
)
;
this
.
pseudoClassToggle
.
removeEventListener
(
"
click
"
this
.
_onTogglePseudoClassPanel
)
;
this
.
classToggle
.
removeEventListener
(
"
click
"
this
.
_onToggleClassPanel
)
;
this
.
searchField
=
null
;
this
.
searchClearButton
=
null
;
this
.
pseudoClassPanel
=
null
;
this
.
pseudoClassToggle
=
null
;
this
.
pseudoClassCheckboxes
=
null
;
this
.
classPanel
=
null
;
this
.
classToggle
=
null
;
this
.
inspector
=
null
;
this
.
styleDocument
=
null
;
this
.
styleWindow
=
null
;
if
(
this
.
element
.
parentNode
)
{
this
.
element
.
remove
(
)
;
}
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
}
if
(
this
.
_popup
)
{
this
.
_popup
.
destroy
(
)
;
this
.
_popup
=
null
;
}
}
_startSelectingElement
:
function
(
)
{
this
.
element
.
classList
.
add
(
"
non
-
interactive
"
)
;
}
_stopSelectingElement
:
function
(
)
{
this
.
element
.
classList
.
remove
(
"
non
-
interactive
"
)
;
}
selectElement
:
function
(
element
allowRefresh
=
false
)
{
const
refresh
=
this
.
_viewedElement
=
=
=
element
;
if
(
refresh
&
&
!
allowRefresh
)
{
return
promise
.
resolve
(
undefined
)
;
}
if
(
this
.
_popup
&
&
this
.
popup
.
isOpen
)
{
this
.
popup
.
hidePopup
(
)
;
}
this
.
clear
(
false
)
;
this
.
_viewedElement
=
element
;
this
.
clearPseudoClassPanel
(
)
;
this
.
refreshAddRuleButtonState
(
)
;
if
(
!
this
.
_viewedElement
)
{
this
.
_stopSelectingElement
(
)
;
this
.
_clearRules
(
)
;
this
.
_showEmpty
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
return
promise
.
resolve
(
undefined
)
;
}
const
dummyElementPromise
=
promise
.
resolve
(
this
.
styleDocument
)
.
then
(
document
=
>
{
const
namespaceURI
=
this
.
element
.
namespaceURI
|
|
document
.
documentElement
.
namespaceURI
;
this
.
_dummyElement
=
document
.
createElementNS
(
namespaceURI
this
.
element
.
tagName
)
;
}
)
.
catch
(
promiseWarn
)
;
const
elementStyle
=
new
ElementStyle
(
element
this
this
.
store
this
.
pageStyle
this
.
showUserAgentStyles
)
;
this
.
_elementStyle
=
elementStyle
;
this
.
_startSelectingElement
(
)
;
return
dummyElementPromise
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
return
this
.
_populate
(
)
;
}
return
undefined
;
}
)
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
if
(
!
refresh
)
{
this
.
element
.
scrollTop
=
0
;
}
this
.
_stopSelectingElement
(
)
;
this
.
_elementStyle
.
onChanged
=
(
)
=
>
{
this
.
_changed
(
)
;
}
;
}
}
)
.
catch
(
e
=
>
{
if
(
this
.
_elementStyle
=
=
=
elementStyle
)
{
this
.
_stopSelectingElement
(
)
;
this
.
_clearRules
(
)
;
}
console
.
error
(
e
)
;
}
)
;
}
refreshPanel
:
function
(
)
{
if
(
this
.
isEditing
|
|
!
this
.
_elementStyle
)
{
return
promise
.
resolve
(
undefined
)
;
}
const
promises
=
[
]
;
for
(
const
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
_applyingModifications
)
{
promises
.
push
(
rule
.
_applyingModifications
)
;
}
}
return
promise
.
all
(
promises
)
.
then
(
(
)
=
>
{
return
this
.
_populate
(
)
;
}
)
;
}
clearPseudoClassPanel
:
function
(
)
{
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
checked
=
false
;
checkbox
.
disabled
=
false
;
}
)
;
}
_createPseudoClassCheckboxes
:
function
(
)
{
const
doc
=
this
.
styleDocument
;
const
fragment
=
doc
.
createDocumentFragment
(
)
;
for
(
const
pseudo
of
PSEUDO_CLASSES
)
{
const
label
=
doc
.
createElement
(
"
label
"
)
;
const
checkbox
=
doc
.
createElement
(
"
input
"
)
;
checkbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
checkbox
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
checkbox
.
setAttribute
(
"
value
"
pseudo
)
;
label
.
append
(
checkbox
pseudo
)
;
fragment
.
append
(
label
)
;
}
this
.
pseudoClassPanel
.
append
(
fragment
)
;
return
Array
.
from
(
this
.
pseudoClassPanel
.
querySelectorAll
(
"
input
[
type
=
checkbox
]
"
)
)
;
}
refreshPseudoClassPanel
:
function
(
)
{
if
(
!
this
.
_elementStyle
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
disabled
=
true
;
}
)
;
return
;
}
const
pseudoClassLocks
=
this
.
_elementStyle
.
element
.
pseudoClassLocks
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
disabled
=
false
;
checkbox
.
checked
=
pseudoClassLocks
.
includes
(
checkbox
.
value
)
;
}
)
;
}
_populate
:
function
(
)
{
const
elementStyle
=
this
.
_elementStyle
;
return
this
.
_elementStyle
.
populate
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_elementStyle
!
=
=
elementStyle
|
|
this
.
isDestroyed
)
{
return
null
;
}
this
.
_clearRules
(
)
;
const
onEditorsReady
=
this
.
_createEditors
(
)
;
this
.
refreshPseudoClassPanel
(
)
;
return
onEditorsReady
.
then
(
(
)
=
>
{
this
.
emit
(
"
ruleview
-
refreshed
"
)
;
}
console
.
error
)
;
}
)
.
catch
(
promiseWarn
)
;
}
_showEmpty
:
function
(
)
{
if
(
this
.
styleDocument
.
getElementById
(
"
ruleview
-
no
-
results
"
)
)
{
return
;
}
createChild
(
this
.
element
"
div
"
{
id
:
"
ruleview
-
no
-
results
"
class
:
"
devtools
-
sidepanel
-
no
-
result
"
textContent
:
l10n
(
"
rule
.
empty
"
)
}
)
;
}
_clearRules
:
function
(
)
{
this
.
element
.
innerHTML
=
"
"
;
}
clear
:
function
(
clearDom
=
true
)
{
this
.
lastSelectorIcon
=
null
;
if
(
clearDom
)
{
this
.
_clearRules
(
)
;
}
this
.
_viewedElement
=
null
;
if
(
this
.
_elementStyle
)
{
this
.
_elementStyle
.
destroy
(
)
;
this
.
_elementStyle
=
null
;
}
}
_changed
:
function
(
)
{
this
.
emit
(
"
ruleview
-
changed
"
)
;
}
get
selectedElementLabel
(
)
{
if
(
this
.
_selectedElementLabel
)
{
return
this
.
_selectedElementLabel
;
}
this
.
_selectedElementLabel
=
l10n
(
"
rule
.
selectedElement
"
)
;
return
this
.
_selectedElementLabel
;
}
get
pseudoElementLabel
(
)
{
if
(
this
.
_pseudoElementLabel
)
{
return
this
.
_pseudoElementLabel
;
}
this
.
_pseudoElementLabel
=
l10n
(
"
rule
.
pseudoElement
"
)
;
return
this
.
_pseudoElementLabel
;
}
get
showPseudoElements
(
)
{
if
(
this
.
_showPseudoElements
=
=
=
undefined
)
{
this
.
_showPseudoElements
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
)
;
}
return
this
.
_showPseudoElements
;
}
createExpandableContainer
:
function
(
label
isPseudo
=
false
)
{
const
header
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
header
.
className
=
this
.
_getRuleViewHeaderClassName
(
true
)
;
header
.
textContent
=
label
;
const
twisty
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
span
"
)
;
twisty
.
className
=
"
ruleview
-
expander
theme
-
twisty
"
;
twisty
.
setAttribute
(
"
open
"
"
true
"
)
;
header
.
insertBefore
(
twisty
header
.
firstChild
)
;
this
.
element
.
appendChild
(
header
)
;
const
container
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
container
.
classList
.
add
(
"
ruleview
-
expandable
-
container
"
)
;
container
.
hidden
=
false
;
this
.
element
.
appendChild
(
container
)
;
header
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
_toggleContainerVisibility
(
twisty
container
isPseudo
!
this
.
showPseudoElements
)
;
}
)
;
if
(
isPseudo
)
{
container
.
id
=
"
pseudo
-
elements
-
container
"
;
twisty
.
id
=
"
pseudo
-
elements
-
header
-
twisty
"
;
this
.
_toggleContainerVisibility
(
twisty
container
isPseudo
this
.
showPseudoElements
)
;
}
return
container
;
}
_toggleContainerVisibility
:
function
(
twisty
container
isPseudo
showPseudo
)
{
let
isOpen
=
twisty
.
getAttribute
(
"
open
"
)
;
if
(
isPseudo
)
{
this
.
_showPseudoElements
=
!
!
showPseudo
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
show_pseudo_elements
"
this
.
showPseudoElements
)
;
container
.
hidden
=
!
this
.
showPseudoElements
;
isOpen
=
!
this
.
showPseudoElements
;
}
else
{
container
.
hidden
=
!
container
.
hidden
;
}
if
(
isOpen
)
{
twisty
.
removeAttribute
(
"
open
"
)
;
}
else
{
twisty
.
setAttribute
(
"
open
"
"
true
"
)
;
}
}
_getRuleViewHeaderClassName
:
function
(
isPseudo
)
{
const
baseClassName
=
"
ruleview
-
header
"
;
return
isPseudo
?
baseClassName
+
"
ruleview
-
expandable
-
header
"
:
baseClassName
;
}
_createEditors
:
function
(
)
{
let
lastInheritedSource
=
"
"
;
let
lastKeyframes
=
null
;
let
seenPseudoElement
=
false
;
let
seenNormalElement
=
false
;
let
seenSearchTerm
=
false
;
let
container
=
null
;
if
(
!
this
.
_elementStyle
.
rules
)
{
return
promise
.
resolve
(
)
;
}
const
editorReadyPromises
=
[
]
;
for
(
const
rule
of
this
.
_elementStyle
.
rules
)
{
if
(
rule
.
domRule
.
system
)
{
continue
;
}
if
(
!
rule
.
editor
)
{
rule
.
editor
=
new
RuleEditor
(
this
rule
)
;
editorReadyPromises
.
push
(
rule
.
editor
.
once
(
"
source
-
link
-
updated
"
)
)
;
}
if
(
this
.
searchValue
&
&
this
.
searchData
)
{
if
(
this
.
highlightRule
(
rule
)
)
{
seenSearchTerm
=
true
;
}
else
if
(
rule
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
continue
;
}
}
if
(
seenPseudoElement
&
&
!
seenNormalElement
&
&
!
rule
.
pseudoElement
)
{
seenNormalElement
=
true
;
const
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
this
.
_getRuleViewHeaderClassName
(
)
;
div
.
textContent
=
this
.
selectedElementLabel
;
this
.
element
.
appendChild
(
div
)
;
}
const
inheritedSource
=
rule
.
inherited
;
if
(
inheritedSource
&
&
inheritedSource
!
=
=
lastInheritedSource
)
{
const
div
=
this
.
styleDocument
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
this
.
_getRuleViewHeaderClassName
(
)
;
div
.
textContent
=
rule
.
inheritedSource
;
lastInheritedSource
=
inheritedSource
;
this
.
element
.
appendChild
(
div
)
;
}
if
(
!
seenPseudoElement
&
&
rule
.
pseudoElement
)
{
seenPseudoElement
=
true
;
container
=
this
.
createExpandableContainer
(
this
.
pseudoElementLabel
true
)
;
}
const
keyframes
=
rule
.
keyframes
;
if
(
keyframes
&
&
keyframes
!
=
=
lastKeyframes
)
{
lastKeyframes
=
keyframes
;
container
=
this
.
createExpandableContainer
(
rule
.
keyframesName
)
;
}
if
(
container
&
&
(
rule
.
pseudoElement
|
|
keyframes
)
)
{
container
.
appendChild
(
rule
.
editor
.
element
)
;
}
else
{
this
.
element
.
appendChild
(
rule
.
editor
.
element
)
;
}
}
const
searchBox
=
this
.
searchField
.
parentNode
;
searchBox
.
classList
.
toggle
(
"
devtools
-
searchbox
-
no
-
match
"
this
.
searchValue
&
&
!
seenSearchTerm
)
;
return
promise
.
all
(
editorReadyPromises
)
;
}
highlightRule
:
function
(
rule
)
{
const
isRuleSelectorHighlighted
=
this
.
_highlightRuleSelector
(
rule
)
;
const
isStyleSheetHighlighted
=
this
.
_highlightStyleSheet
(
rule
)
;
let
isHighlighted
=
isRuleSelectorHighlighted
|
|
isStyleSheetHighlighted
;
for
(
const
textProp
of
rule
.
textProps
)
{
if
(
!
textProp
.
invisible
&
&
this
.
_highlightProperty
(
textProp
.
editor
)
)
{
isHighlighted
=
true
;
}
}
return
isHighlighted
;
}
_highlightRuleSelector
:
function
(
rule
)
{
let
isSelectorHighlighted
=
false
;
let
selectorNodes
=
[
.
.
.
rule
.
editor
.
selectorText
.
childNodes
]
;
if
(
rule
.
domRule
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
{
selectorNodes
=
[
rule
.
editor
.
selectorText
]
;
}
else
if
(
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
selectorNodes
=
[
]
;
}
for
(
const
selectorNode
of
selectorNodes
)
{
const
selector
=
selectorNode
.
textContent
.
toLowerCase
(
)
;
if
(
(
this
.
searchData
.
strictSearchAllValues
&
&
selector
=
=
=
this
.
searchData
.
strictSearchValue
)
|
|
(
!
this
.
searchData
.
strictSearchAllValues
&
&
selector
.
includes
(
this
.
searchValue
)
)
)
{
selectorNode
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
isSelectorHighlighted
=
true
;
}
}
return
isSelectorHighlighted
;
}
_highlightStyleSheet
:
function
(
rule
)
{
const
styleSheetSource
=
rule
.
title
.
toLowerCase
(
)
;
const
isStyleSheetHighlighted
=
this
.
searchData
.
strictSearchValue
?
styleSheetSource
=
=
=
this
.
searchData
.
strictSearchValue
:
styleSheetSource
.
includes
(
this
.
searchValue
)
;
if
(
isStyleSheetHighlighted
)
{
rule
.
editor
.
source
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
isStyleSheetHighlighted
;
}
_highlightProperty
:
function
(
editor
)
{
const
isPropertyHighlighted
=
this
.
_highlightRuleProperty
(
editor
)
;
const
isComputedHighlighted
=
this
.
_highlightComputedProperty
(
editor
)
;
if
(
!
isPropertyHighlighted
&
&
isComputedHighlighted
&
&
!
editor
.
computed
.
hasAttribute
(
"
user
-
open
"
)
)
{
editor
.
expandForFilter
(
)
;
}
return
isPropertyHighlighted
|
|
isComputedHighlighted
;
}
_updatePropertyHighlight
:
function
(
editor
)
{
if
(
!
this
.
searchValue
|
|
!
this
.
searchData
)
{
return
;
}
this
.
_clearHighlight
(
editor
.
element
)
;
if
(
this
.
_highlightProperty
(
editor
)
)
{
this
.
searchField
.
classList
.
remove
(
"
devtools
-
style
-
searchbox
-
no
-
match
"
)
;
}
}
_highlightRuleProperty
:
function
(
editor
)
{
const
propertyName
=
editor
.
prop
.
name
.
toLowerCase
(
)
;
const
propertyValue
=
editor
.
valueSpan
.
textContent
.
toLowerCase
(
)
;
return
this
.
_highlightMatches
(
editor
.
container
propertyName
propertyValue
)
;
}
_highlightComputedProperty
:
function
(
editor
)
{
let
isComputedHighlighted
=
false
;
editor
.
_populateComputed
(
)
;
for
(
const
computed
of
editor
.
prop
.
computed
)
{
if
(
computed
.
element
)
{
const
computedName
=
computed
.
name
.
toLowerCase
(
)
;
const
computedValue
=
computed
.
parsedValue
.
toLowerCase
(
)
;
isComputedHighlighted
=
this
.
_highlightMatches
(
computed
.
element
computedName
computedValue
)
?
true
:
isComputedHighlighted
;
}
}
return
isComputedHighlighted
;
}
_highlightMatches
:
function
(
element
propertyName
propertyValue
)
{
const
{
searchPropertyName
searchPropertyValue
searchPropertyMatch
strictSearchPropertyName
strictSearchPropertyValue
strictSearchAllValues
}
=
this
.
searchData
;
let
matches
=
false
;
const
hasNameAndValue
=
searchPropertyMatch
&
&
searchPropertyName
&
&
searchPropertyValue
;
const
isMatch
=
(
value
query
isStrict
)
=
>
{
return
isStrict
?
value
=
=
=
query
:
query
&
&
value
.
includes
(
query
)
;
}
;
if
(
hasNameAndValue
)
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
)
&
&
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
)
;
}
else
{
matches
=
isMatch
(
propertyName
searchPropertyName
strictSearchPropertyName
|
|
strictSearchAllValues
)
|
|
isMatch
(
propertyValue
searchPropertyValue
strictSearchPropertyValue
|
|
strictSearchAllValues
)
;
}
if
(
matches
)
{
element
.
classList
.
add
(
"
ruleview
-
highlight
"
)
;
}
return
matches
;
}
_clearHighlight
:
function
(
element
)
{
for
(
const
el
of
element
.
querySelectorAll
(
"
.
ruleview
-
highlight
"
)
)
{
el
.
classList
.
remove
(
"
ruleview
-
highlight
"
)
;
}
for
(
const
computed
of
element
.
querySelectorAll
(
"
.
ruleview
-
computedlist
[
filter
-
open
]
"
)
)
{
computed
.
parentNode
.
_textPropertyEditor
.
collapseForFilter
(
)
;
}
}
_onTogglePseudoClassPanel
:
function
(
)
{
if
(
this
.
pseudoClassPanel
.
hidden
)
{
this
.
showPseudoClassPanel
(
)
;
}
else
{
this
.
hidePseudoClassPanel
(
)
;
}
}
showPseudoClassPanel
:
function
(
)
{
this
.
hideClassPanel
(
)
;
this
.
pseudoClassToggle
.
classList
.
add
(
"
checked
"
)
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
)
;
this
.
pseudoClassPanel
.
hidden
=
false
;
}
hidePseudoClassPanel
:
function
(
)
{
this
.
pseudoClassToggle
.
classList
.
remove
(
"
checked
"
)
;
this
.
pseudoClassCheckboxes
.
forEach
(
checkbox
=
>
{
checkbox
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
}
)
;
this
.
pseudoClassPanel
.
hidden
=
true
;
}
_onTogglePseudoClass
:
function
(
event
)
{
const
target
=
event
.
target
;
this
.
inspector
.
togglePseudoClass
(
target
.
value
)
;
}
_onToggleClassPanel
:
function
(
)
{
if
(
this
.
classPanel
.
hidden
)
{
this
.
showClassPanel
(
)
;
}
else
{
this
.
hideClassPanel
(
)
;
}
}
showClassPanel
:
function
(
)
{
this
.
hidePseudoClassPanel
(
)
;
this
.
classToggle
.
classList
.
add
(
"
checked
"
)
;
this
.
classPanel
.
hidden
=
false
;
this
.
classListPreviewer
.
focusAddClassField
(
)
;
}
hideClassPanel
:
function
(
)
{
this
.
classToggle
.
classList
.
remove
(
"
checked
"
)
;
this
.
classPanel
.
hidden
=
true
;
}
_onShortcut
:
function
(
name
event
)
{
if
(
!
event
.
target
.
closest
(
"
#
sidebar
-
panel
-
ruleview
"
)
)
{
return
;
}
if
(
name
=
=
=
"
CmdOrCtrl
+
F
"
)
{
this
.
searchField
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
else
if
(
(
name
=
=
=
"
Return
"
|
|
name
=
=
=
"
Space
"
)
&
&
this
.
element
.
classList
.
contains
(
"
non
-
interactive
"
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
name
=
=
=
"
Escape
"
&
&
event
.
target
=
=
=
this
.
searchField
&
&
this
.
_onClearSearch
(
)
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
async
_onTogglePrintSimulation
(
)
{
const
enabled
=
await
this
.
emulationFront
.
getIsPrintSimulationEnabled
(
)
;
if
(
!
enabled
)
{
this
.
printSimulationButton
.
classList
.
add
(
"
checked
"
)
;
await
this
.
emulationFront
.
startPrintMediaSimulation
(
)
;
}
else
{
this
.
printSimulationButton
.
classList
.
remove
(
"
checked
"
)
;
await
this
.
emulationFront
.
stopPrintMediaSimulation
(
false
)
;
}
this
.
refreshPanel
(
)
;
}
_flashElement
(
element
)
{
flashElementOn
(
element
{
backgroundClass
:
"
theme
-
bg
-
yellow
-
contrast
"
}
)
;
if
(
this
.
_flashMutationTimer
)
{
clearTimeout
(
this
.
_removeFlashOutTimer
)
;
this
.
_flashMutationTimer
=
null
;
}
this
.
_flashMutationTimer
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
element
{
backgroundClass
:
"
theme
-
bg
-
yellow
-
contrast
"
}
)
;
this
.
emit
(
"
scrolled
-
to
-
element
"
)
;
}
PROPERTY_FLASHING_DURATION
)
;
}
_scrollToElement
(
rule
declaration
scrollBehavior
=
"
smooth
"
)
{
let
elementToScrollTo
=
rule
;
if
(
declaration
)
{
const
{
offsetTop
offsetHeight
}
=
declaration
;
const
distance
=
offsetTop
+
offsetHeight
-
rule
.
offsetTop
;
if
(
this
.
element
.
parentNode
.
offsetHeight
<
=
distance
)
{
elementToScrollTo
=
declaration
;
}
}
const
win
=
elementToScrollTo
.
ownerGlobal
;
const
reducedMotion
=
win
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
)
"
)
.
matches
;
scrollBehavior
=
reducedMotion
?
"
auto
"
:
scrollBehavior
;
elementToScrollTo
.
scrollIntoView
(
{
behavior
:
scrollBehavior
}
)
;
}
_togglePseudoElementRuleContainer
(
)
{
const
container
=
this
.
styleDocument
.
getElementById
(
"
pseudo
-
elements
-
container
"
)
;
const
twisty
=
this
.
styleDocument
.
getElementById
(
"
pseudo
-
elements
-
header
-
twisty
"
)
;
this
.
_toggleContainerVisibility
(
twisty
container
true
true
)
;
}
highlightElementRule
:
function
(
ruleId
)
{
let
scrollBehavior
=
"
smooth
"
;
const
rule
=
this
.
rules
.
find
(
r
=
>
r
.
domRule
.
actorID
=
=
=
ruleId
)
;
if
(
!
rule
)
{
return
;
}
if
(
rule
.
domRule
.
actorID
=
=
=
ruleId
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
const
{
editor
:
{
element
}
}
=
rule
;
this
.
_scrollToElement
(
element
null
scrollBehavior
)
;
this
.
_flashElement
(
element
)
;
}
}
highlightProperty
:
function
(
name
)
{
for
(
const
rule
of
this
.
rules
)
{
for
(
const
textProp
of
rule
.
textProps
)
{
if
(
textProp
.
overridden
|
|
textProp
.
invisible
|
|
!
textProp
.
enabled
)
{
continue
;
}
const
{
editor
:
{
selectorText
}
}
=
rule
;
let
scrollBehavior
=
"
smooth
"
;
if
(
textProp
.
name
=
=
=
name
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
this
.
_scrollToElement
(
selectorText
textProp
.
editor
.
element
scrollBehavior
)
;
this
.
_flashElement
(
textProp
.
editor
.
element
)
;
return
true
;
}
for
(
const
computed
of
textProp
.
computed
)
{
if
(
computed
.
overridden
)
{
continue
;
}
if
(
computed
.
name
=
=
=
name
)
{
if
(
!
this
.
inspector
.
is3PaneModeEnabled
)
{
this
.
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
}
if
(
textProp
.
rule
.
pseudoElement
.
length
&
&
!
this
.
showPseudoElements
)
{
scrollBehavior
=
"
auto
"
;
this
.
_togglePseudoElementRuleContainer
(
)
;
}
textProp
.
editor
.
expandForFilter
(
)
;
this
.
_scrollToElement
(
selectorText
computed
.
element
scrollBehavior
)
;
this
.
_flashElement
(
computed
.
element
)
;
return
true
;
}
}
}
}
return
false
;
}
}
;
function
getParentTextPropertyHolder
(
node
)
{
while
(
true
)
{
if
(
!
node
|
|
!
node
.
classList
)
{
return
null
;
}
if
(
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
node
;
}
node
=
node
.
parentNode
;
}
}
function
getParentTextProperty
(
node
)
{
const
parent
=
getParentTextPropertyHolder
(
node
)
;
if
(
!
parent
)
{
return
null
;
}
const
propValue
=
parent
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
;
if
(
!
propValue
)
{
return
null
;
}
return
propValue
.
textProperty
;
}
function
getPropertyNameAndValue
(
node
)
{
while
(
true
)
{
if
(
!
node
|
|
!
node
.
classList
)
{
return
null
;
}
if
(
node
.
classList
.
contains
(
"
ruleview
-
computed
"
)
|
|
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
{
name
:
node
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
.
textContent
value
:
node
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
.
textContent
}
;
}
node
=
node
.
parentNode
;
}
}
function
getShapeToggleActive
(
node
)
{
while
(
true
)
{
if
(
!
node
|
|
!
node
.
classList
)
{
return
null
;
}
if
(
node
.
classList
.
contains
(
"
ruleview
-
computed
"
)
|
|
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
node
.
querySelector
(
"
.
ruleview
-
shapeswatch
.
active
"
)
;
}
node
=
node
.
parentNode
;
}
}
function
getShapePoint
(
node
)
{
const
classList
=
node
.
classList
;
let
point
=
node
.
dataset
.
point
;
const
insetClasses
=
[
]
;
classList
.
forEach
(
className
=
>
{
if
(
INSET_POINT_TYPES
.
includes
(
className
)
)
{
insetClasses
.
push
(
className
)
;
}
}
)
;
if
(
insetClasses
.
length
>
0
)
{
point
=
insetClasses
.
join
(
"
"
)
;
}
return
point
;
}
function
RuleViewTool
(
inspector
window
)
{
this
.
inspector
=
inspector
;
this
.
document
=
window
.
document
;
this
.
view
=
new
CssRuleView
(
this
.
inspector
this
.
document
)
;
this
.
clearUserProperties
=
this
.
clearUserProperties
.
bind
(
this
)
;
this
.
refresh
=
this
.
refresh
.
bind
(
this
)
;
this
.
onDetachedFront
=
this
.
onDetachedFront
.
bind
(
this
)
;
this
.
onPanelSelected
=
this
.
onPanelSelected
.
bind
(
this
)
;
this
.
onDetachedFront
=
this
.
onDetachedFront
.
bind
(
this
)
;
this
.
onSelected
=
this
.
onSelected
.
bind
(
this
)
;
this
.
onViewRefreshed
=
this
.
onViewRefreshed
.
bind
(
this
)
;
this
.
view
.
on
(
"
ruleview
-
refreshed
"
this
.
onViewRefreshed
)
;
this
.
inspector
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetachedFront
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
selection
.
on
(
"
pseudoclass
"
this
.
refresh
)
;
this
.
inspector
.
currentTarget
.
on
(
"
navigate
"
this
.
clearUserProperties
)
;
this
.
inspector
.
ruleViewSideBar
.
on
(
"
ruleview
-
selected
"
this
.
onPanelSelected
)
;
this
.
inspector
.
sidebar
.
on
(
"
ruleview
-
selected
"
this
.
onPanelSelected
)
;
this
.
inspector
.
pageStyle
.
on
(
"
stylesheet
-
updated
"
this
.
refresh
)
;
this
.
inspector
.
styleChangeTracker
.
on
(
"
style
-
changed
"
this
.
refresh
)
;
this
.
onSelected
(
)
;
}
RuleViewTool
.
prototype
=
{
isSidebarActive
:
function
(
)
{
if
(
!
this
.
view
)
{
return
false
;
}
return
this
.
inspector
.
is3PaneModeEnabled
?
true
:
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
"
ruleview
"
;
}
onDetachedFront
:
function
(
)
{
this
.
onSelected
(
false
)
;
}
onSelected
:
function
(
selectElement
=
true
)
{
if
(
!
this
.
view
)
{
return
;
}
const
isInactive
=
!
this
.
isSidebarActive
(
)
&
&
this
.
inspector
.
selection
.
nodeFront
;
if
(
isInactive
)
{
return
;
}
this
.
view
.
setPageStyle
(
this
.
inspector
.
pageStyle
)
;
if
(
!
this
.
inspector
.
selection
.
isConnected
(
)
|
|
!
this
.
inspector
.
selection
.
isElementNode
(
)
)
{
this
.
view
.
selectElement
(
null
)
;
return
;
}
if
(
selectElement
)
{
const
done
=
this
.
inspector
.
updating
(
"
rule
-
view
"
)
;
this
.
view
.
selectElement
(
this
.
inspector
.
selection
.
nodeFront
)
.
then
(
done
done
)
;
}
}
refresh
:
function
(
)
{
if
(
this
.
isSidebarActive
(
)
)
{
this
.
view
.
refreshPanel
(
)
;
}
}
clearUserProperties
:
function
(
)
{
if
(
this
.
view
&
&
this
.
view
.
store
&
&
this
.
view
.
store
.
userProperties
)
{
this
.
view
.
store
.
userProperties
.
clear
(
)
;
}
}
onPanelSelected
:
function
(
)
{
if
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
this
.
view
.
_viewedElement
)
{
this
.
refresh
(
)
;
}
else
{
this
.
onSelected
(
)
;
}
}
onViewRefreshed
:
function
(
)
{
this
.
inspector
.
emit
(
"
rule
-
view
-
refreshed
"
)
;
}
destroy
:
function
(
)
{
this
.
inspector
.
styleChangeTracker
.
off
(
"
style
-
changed
"
this
.
refresh
)
;
this
.
inspector
.
selection
.
off
(
"
detached
-
front
"
this
.
onDetachedFront
)
;
this
.
inspector
.
selection
.
off
(
"
pseudoclass
"
this
.
refresh
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onSelected
)
;
this
.
inspector
.
currentTarget
.
off
(
"
navigate
"
this
.
clearUserProperties
)
;
this
.
inspector
.
sidebar
.
off
(
"
ruleview
-
selected
"
this
.
onPanelSelected
)
;
if
(
this
.
inspector
.
pageStyle
)
{
this
.
inspector
.
pageStyle
.
off
(
"
stylesheet
-
updated
"
this
.
refresh
)
;
}
this
.
view
.
off
(
"
ruleview
-
refreshed
"
this
.
onViewRefreshed
)
;
this
.
view
.
destroy
(
)
;
this
.
view
=
this
.
document
=
this
.
inspector
=
null
;
}
}
;
exports
.
CssRuleView
=
CssRuleView
;
exports
.
RuleViewTool
=
RuleViewTool
;
