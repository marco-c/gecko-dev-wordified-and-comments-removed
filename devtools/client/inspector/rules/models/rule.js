"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
CssLogic
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
const
TextProperty
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
text
-
property
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
updateSourceLink
"
"
devtools
/
client
/
inspector
/
rules
/
actions
/
rules
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
promiseWarn
"
"
devtools
/
client
/
inspector
/
shared
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseNamedDeclarations
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
class
Rule
{
constructor
(
elementStyle
options
)
{
this
.
elementStyle
=
elementStyle
;
this
.
domRule
=
options
.
rule
;
this
.
matchedSelectors
=
options
.
matchedSelectors
|
|
[
]
;
this
.
pseudoElement
=
options
.
pseudoElement
|
|
"
"
;
this
.
isSystem
=
options
.
isSystem
;
this
.
isUnmatched
=
options
.
isUnmatched
|
|
false
;
this
.
inherited
=
options
.
inherited
|
|
null
;
this
.
keyframes
=
options
.
keyframes
|
|
null
;
this
.
mediaText
=
this
.
domRule
&
&
this
.
domRule
.
mediaText
?
this
.
domRule
.
mediaText
:
"
"
;
this
.
cssProperties
=
this
.
elementStyle
.
ruleView
.
cssProperties
;
this
.
inspector
=
this
.
elementStyle
.
ruleView
.
inspector
;
this
.
store
=
this
.
elementStyle
.
ruleView
.
store
;
this
.
textProps
=
this
.
_getTextProperties
(
)
;
this
.
textProps
=
this
.
textProps
.
concat
(
this
.
_getDisabledProperties
(
)
)
;
this
.
getUniqueSelector
=
this
.
getUniqueSelector
.
bind
(
this
)
;
this
.
onDeclarationsUpdated
=
this
.
onDeclarationsUpdated
.
bind
(
this
)
;
this
.
onLocationChanged
=
this
.
onLocationChanged
.
bind
(
this
)
;
this
.
onStyleRuleFrontUpdated
=
this
.
onStyleRuleFrontUpdated
.
bind
(
this
)
;
this
.
updateSourceLocation
=
this
.
updateSourceLocation
.
bind
(
this
)
;
if
(
this
.
domRule
.
traits
.
emitsRuleUpdatedEvent
)
{
this
.
domRule
.
on
(
"
rule
-
updated
"
this
.
onStyleRuleFrontUpdated
)
;
}
else
{
this
.
domRule
.
on
(
"
declarations
-
updated
"
this
.
onDeclarationsUpdated
)
;
}
}
destroy
(
)
{
if
(
this
.
unsubscribeSourceMap
)
{
this
.
unsubscribeSourceMap
(
)
;
}
if
(
this
.
domRule
.
traits
.
emitsRuleUpdatedEvent
)
{
this
.
domRule
.
off
(
"
rule
-
updated
"
this
.
onStyleRuleFrontUpdated
)
;
}
else
{
this
.
domRule
.
off
(
"
declarations
-
updated
"
this
.
onDeclarationsUpdated
)
;
}
this
.
domRule
.
off
(
"
location
-
changed
"
this
.
onLocationChanged
)
;
}
get
declarations
(
)
{
return
this
.
textProps
;
}
get
inheritance
(
)
{
if
(
!
this
.
inherited
)
{
return
null
;
}
return
{
inherited
:
this
.
inherited
inheritedSource
:
this
.
inheritedSource
}
;
}
get
selector
(
)
{
return
{
getUniqueSelector
:
this
.
getUniqueSelector
matchedSelectors
:
this
.
matchedSelectors
selectors
:
this
.
domRule
.
selectors
selectorText
:
this
.
keyframes
?
this
.
domRule
.
keyText
:
this
.
selectorText
}
;
}
get
sourceLink
(
)
{
return
{
label
:
this
.
getSourceText
(
CssLogic
.
shortSource
(
{
href
:
this
.
sourceLocation
.
url
}
)
)
title
:
this
.
getSourceText
(
this
.
sourceLocation
.
url
)
}
;
}
get
sourceMapURLService
(
)
{
return
this
.
inspector
.
toolbox
.
sourceMapURLService
;
}
get
sourceLocation
(
)
{
if
(
!
this
.
_sourceLocation
)
{
this
.
_sourceLocation
=
{
column
:
this
.
ruleColumn
line
:
this
.
ruleLine
url
:
this
.
sheet
?
this
.
sheet
.
href
|
|
this
.
sheet
.
nodeHref
:
null
}
;
}
return
this
.
_sourceLocation
;
}
get
title
(
)
{
let
title
=
CssLogic
.
shortSource
(
this
.
sheet
)
;
if
(
this
.
domRule
.
type
!
=
=
ELEMENT_STYLE
&
&
this
.
ruleLine
>
0
)
{
title
+
=
"
:
"
+
this
.
ruleLine
;
}
return
title
+
(
this
.
mediaText
?
"
media
"
+
this
.
mediaText
:
"
"
)
;
}
get
inheritedSource
(
)
{
if
(
this
.
_inheritedSource
)
{
return
this
.
_inheritedSource
;
}
this
.
_inheritedSource
=
"
"
;
if
(
this
.
inherited
)
{
let
eltText
=
this
.
inherited
.
displayName
;
if
(
this
.
inherited
.
id
)
{
eltText
+
=
"
#
"
+
this
.
inherited
.
id
;
}
this
.
_inheritedSource
=
STYLE_INSPECTOR_L10N
.
getFormatStr
(
"
rule
.
inheritedFrom
"
eltText
)
;
}
return
this
.
_inheritedSource
;
}
get
keyframesName
(
)
{
if
(
this
.
_keyframesName
)
{
return
this
.
_keyframesName
;
}
this
.
_keyframesName
=
"
"
;
if
(
this
.
keyframes
)
{
this
.
_keyframesName
=
STYLE_INSPECTOR_L10N
.
getFormatStr
(
"
rule
.
keyframe
"
this
.
keyframes
.
name
)
;
}
return
this
.
_keyframesName
;
}
get
keyframesRule
(
)
{
if
(
!
this
.
keyframes
)
{
return
null
;
}
return
{
id
:
this
.
keyframes
.
actorID
keyframesName
:
this
.
keyframesName
}
;
}
get
selectorText
(
)
{
return
this
.
domRule
.
selectors
?
this
.
domRule
.
selectors
.
join
(
"
"
)
:
CssLogic
.
l10n
(
"
rule
.
sourceElement
"
)
;
}
get
sheet
(
)
{
return
this
.
domRule
?
this
.
domRule
.
parentStyleSheet
:
null
;
}
get
ruleLine
(
)
{
return
this
.
domRule
?
this
.
domRule
.
line
:
-
1
;
}
get
ruleColumn
(
)
{
return
this
.
domRule
?
this
.
domRule
.
column
:
null
;
}
getDeclaration
(
id
)
{
return
this
.
textProps
.
find
(
textProp
=
>
textProp
.
id
=
=
=
id
)
;
}
getSourceText
(
url
)
{
if
(
this
.
isSystem
)
{
return
{
STYLE_INSPECTOR_L10N
.
getStr
(
"
rule
.
userAgentStyles
"
)
}
{
this
.
title
}
;
}
let
sourceText
=
url
;
if
(
this
.
sourceLocation
.
line
>
0
)
{
sourceText
+
=
"
:
"
+
this
.
sourceLocation
.
line
;
}
if
(
this
.
mediaText
)
{
sourceText
+
=
"
media
"
+
this
.
mediaText
;
}
return
sourceText
;
}
async
getUniqueSelector
(
)
{
let
selector
=
"
"
;
if
(
this
.
domRule
.
selectors
)
{
selector
=
this
.
domRule
.
selectors
.
join
(
"
"
)
;
}
else
if
(
this
.
inherited
)
{
selector
=
await
this
.
inherited
.
getUniqueSelector
(
)
;
}
else
{
selector
=
this
.
inspector
.
selectionCssSelector
;
}
return
selector
;
}
matches
(
options
)
{
return
this
.
domRule
=
=
=
options
.
rule
;
}
createProperty
(
name
value
priority
enabled
siblingProp
)
{
const
prop
=
new
TextProperty
(
this
name
value
priority
enabled
)
;
let
ind
;
if
(
siblingProp
)
{
ind
=
this
.
textProps
.
indexOf
(
siblingProp
)
+
1
;
this
.
textProps
.
splice
(
ind
0
prop
)
;
}
else
{
ind
=
this
.
textProps
.
length
;
this
.
textProps
.
push
(
prop
)
;
}
this
.
applyProperties
(
modifications
=
>
{
modifications
.
createProperty
(
ind
name
value
priority
enabled
)
;
prop
.
updateEditor
(
)
;
}
)
;
return
prop
;
}
_applyPropertiesNoAuthored
(
modifications
)
{
this
.
elementStyle
.
onRuleUpdated
(
)
;
const
disabledProps
=
[
]
;
for
(
const
prop
of
this
.
textProps
)
{
if
(
prop
.
invisible
)
{
continue
;
}
if
(
!
prop
.
enabled
)
{
disabledProps
.
push
(
{
name
:
prop
.
name
value
:
prop
.
value
priority
:
prop
.
priority
}
)
;
continue
;
}
if
(
prop
.
value
.
trim
(
)
=
=
=
"
"
)
{
continue
;
}
modifications
.
setProperty
(
-
1
prop
.
name
prop
.
value
prop
.
priority
)
;
prop
.
updateComputed
(
)
;
}
const
disabled
=
this
.
elementStyle
.
store
.
disabled
;
if
(
disabledProps
.
length
>
0
)
{
disabled
.
set
(
this
.
domRule
disabledProps
)
;
}
else
{
disabled
.
delete
(
this
.
domRule
)
;
}
return
modifications
.
apply
(
)
.
then
(
(
)
=
>
{
const
cssProps
=
{
}
;
for
(
const
cssProp
of
parseNamedDeclarations
(
this
.
cssProperties
.
isKnown
this
.
domRule
.
authoredText
)
)
{
cssProps
[
cssProp
.
name
]
=
cssProp
;
}
for
(
const
textProp
of
this
.
textProps
)
{
if
(
!
textProp
.
enabled
)
{
continue
;
}
let
cssProp
=
cssProps
[
textProp
.
name
]
;
if
(
!
cssProp
)
{
cssProp
=
{
name
:
textProp
.
name
value
:
"
"
priority
:
"
"
}
;
}
textProp
.
priority
=
cssProp
.
priority
;
}
}
)
;
}
_applyPropertiesAuthored
(
modifications
)
{
return
modifications
.
apply
(
)
.
then
(
(
)
=
>
{
for
(
const
index
in
modifications
.
changedDeclarations
)
{
const
newValue
=
modifications
.
changedDeclarations
[
index
]
;
this
.
textProps
[
index
]
.
updateValue
(
newValue
)
;
}
for
(
const
prop
of
this
.
textProps
)
{
if
(
!
prop
.
invisible
&
&
prop
.
enabled
)
{
prop
.
updateComputed
(
)
;
prop
.
updateEditor
(
)
;
}
}
}
)
;
}
applyProperties
(
modifier
)
{
const
resultPromise
=
promise
.
resolve
(
this
.
_applyingModifications
)
.
then
(
(
)
=
>
{
const
modifications
=
this
.
domRule
.
startModifyingProperties
(
this
.
cssProperties
)
;
modifier
(
modifications
)
;
if
(
this
.
domRule
.
canSetRuleText
)
{
return
this
.
_applyPropertiesAuthored
(
modifications
)
;
}
return
this
.
_applyPropertiesNoAuthored
(
modifications
)
;
}
)
.
then
(
(
)
=
>
{
this
.
elementStyle
.
onRuleUpdated
(
)
;
if
(
resultPromise
=
=
=
this
.
_applyingModifications
)
{
this
.
_applyingModifications
=
null
;
this
.
elementStyle
.
_changed
(
)
;
}
}
)
.
catch
(
promiseWarn
)
;
this
.
_applyingModifications
=
resultPromise
;
return
resultPromise
;
}
setPropertyName
(
property
name
)
{
if
(
name
=
=
=
property
.
name
)
{
return
Promise
.
resolve
(
)
;
}
const
oldName
=
property
.
name
;
property
.
name
=
name
;
const
index
=
this
.
textProps
.
indexOf
(
property
)
;
return
this
.
applyProperties
(
modifications
=
>
{
modifications
.
renameProperty
(
index
oldName
name
)
;
}
)
;
}
setPropertyValue
(
property
value
priority
)
{
if
(
value
=
=
=
property
.
value
&
&
priority
=
=
=
property
.
priority
)
{
return
Promise
.
resolve
(
)
;
}
property
.
value
=
value
;
property
.
priority
=
priority
;
const
index
=
this
.
textProps
.
indexOf
(
property
)
;
return
this
.
applyProperties
(
modifications
=
>
{
modifications
.
setProperty
(
index
property
.
name
value
priority
)
;
}
)
;
}
previewPropertyValue
(
property
value
priority
)
{
const
modifications
=
this
.
domRule
.
startModifyingProperties
(
this
.
cssProperties
)
;
modifications
.
setProperty
(
this
.
textProps
.
indexOf
(
property
)
property
.
name
value
priority
)
;
return
modifications
.
apply
(
)
.
then
(
(
)
=
>
{
this
.
elementStyle
.
_changed
(
)
;
}
)
;
}
setPropertyEnabled
(
property
value
)
{
if
(
property
.
enabled
=
=
=
!
!
value
)
{
return
;
}
property
.
enabled
=
!
!
value
;
const
index
=
this
.
textProps
.
indexOf
(
property
)
;
this
.
applyProperties
(
modifications
=
>
{
modifications
.
setPropertyEnabled
(
index
property
.
name
property
.
enabled
)
;
}
)
;
}
removeProperty
(
property
)
{
const
index
=
this
.
textProps
.
indexOf
(
property
)
;
this
.
textProps
.
splice
(
index
1
)
;
this
.
applyProperties
(
modifications
=
>
{
modifications
.
removeProperty
(
index
property
.
name
)
;
}
)
;
}
onStyleRuleFrontUpdated
(
front
)
{
this
.
domRule
=
front
;
}
_getTextProperties
(
)
{
const
textProps
=
[
]
;
const
store
=
this
.
elementStyle
.
store
;
let
props
=
this
.
domRule
.
declarations
;
if
(
!
props
.
length
)
{
props
=
parseNamedDeclarations
(
this
.
cssProperties
.
isKnown
this
.
domRule
.
authoredText
true
)
;
}
for
(
const
prop
of
props
)
{
const
name
=
prop
.
name
;
const
invisible
=
this
.
inherited
&
&
!
this
.
cssProperties
.
isInherited
(
name
)
;
const
value
=
store
.
userProperties
.
getProperty
(
this
.
domRule
name
prop
.
value
)
;
const
textProp
=
new
TextProperty
(
this
name
value
prop
.
priority
!
(
"
commentOffsets
"
in
prop
)
invisible
)
;
textProps
.
push
(
textProp
)
;
}
return
textProps
;
}
_getDisabledProperties
(
)
{
const
store
=
this
.
elementStyle
.
store
;
const
disabledProps
=
store
.
disabled
.
get
(
this
.
domRule
)
;
if
(
!
disabledProps
)
{
return
[
]
;
}
const
textProps
=
[
]
;
for
(
const
prop
of
disabledProps
)
{
const
value
=
store
.
userProperties
.
getProperty
(
this
.
domRule
prop
.
name
prop
.
value
)
;
const
textProp
=
new
TextProperty
(
this
prop
.
name
value
prop
.
priority
)
;
textProp
.
enabled
=
false
;
textProps
.
push
(
textProp
)
;
}
return
textProps
;
}
refresh
(
options
)
{
this
.
matchedSelectors
=
options
.
matchedSelectors
|
|
[
]
;
const
newTextProps
=
this
.
_getTextProperties
(
)
;
if
(
this
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
textProps
=
newTextProps
;
if
(
this
.
editor
)
{
this
.
editor
.
populate
(
true
)
;
}
return
;
}
const
brandNewProps
=
[
]
;
for
(
const
newProp
of
newTextProps
)
{
if
(
!
this
.
_updateTextProperty
(
newProp
)
)
{
brandNewProps
.
push
(
newProp
)
;
}
}
for
(
const
prop
of
this
.
textProps
)
{
if
(
!
prop
.
_visited
)
{
prop
.
enabled
=
false
;
prop
.
updateEditor
(
)
;
}
else
{
delete
prop
.
_visited
;
}
}
this
.
textProps
=
this
.
textProps
.
concat
(
brandNewProps
)
;
if
(
this
.
editor
)
{
this
.
editor
.
populate
(
)
;
}
}
_updateTextProperty
(
newProp
)
{
const
match
=
{
rank
:
0
prop
:
null
}
;
for
(
const
prop
of
this
.
textProps
)
{
if
(
prop
.
name
!
=
=
newProp
.
name
)
{
continue
;
}
prop
.
_visited
=
true
;
let
rank
=
1
;
if
(
prop
.
value
=
=
=
newProp
.
value
)
{
rank
+
=
2
;
if
(
prop
.
priority
=
=
=
newProp
.
priority
)
{
rank
+
=
2
;
}
}
if
(
prop
.
enabled
)
{
rank
+
=
1
;
}
if
(
rank
>
match
.
rank
)
{
if
(
match
.
prop
)
{
match
.
prop
.
enabled
=
false
;
match
.
prop
.
updateEditor
(
)
;
}
match
.
rank
=
rank
;
match
.
prop
=
prop
;
}
else
if
(
rank
)
{
prop
.
enabled
=
false
;
prop
.
updateEditor
(
)
;
}
}
if
(
match
.
prop
)
{
match
.
prop
.
set
(
newProp
)
;
return
true
;
}
return
false
;
}
editClosestTextProperty
(
textProperty
direction
)
{
let
index
=
this
.
textProps
.
indexOf
(
textProperty
)
;
if
(
direction
=
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
for
(
+
+
index
;
index
<
this
.
textProps
.
length
;
+
+
index
)
{
if
(
!
this
.
textProps
[
index
]
.
invisible
)
{
break
;
}
}
if
(
index
=
=
=
this
.
textProps
.
length
)
{
textProperty
.
rule
.
editor
.
closeBrace
.
click
(
)
;
}
else
{
this
.
textProps
[
index
]
.
editor
.
nameSpan
.
click
(
)
;
}
}
else
if
(
direction
=
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
for
(
-
-
index
;
index
>
=
0
;
-
-
index
)
{
if
(
!
this
.
textProps
[
index
]
.
invisible
)
{
break
;
}
}
if
(
index
<
0
)
{
textProperty
.
editor
.
ruleEditor
.
selectorText
.
click
(
)
;
}
else
{
this
.
textProps
[
index
]
.
editor
.
valueSpan
.
click
(
)
;
}
}
}
stringifyRule
(
)
{
const
selectorText
=
this
.
selectorText
;
let
cssText
=
"
"
;
const
terminator
=
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
;
for
(
const
textProp
of
this
.
textProps
)
{
if
(
!
textProp
.
invisible
)
{
cssText
+
=
"
\
t
"
+
textProp
.
stringifyProperty
(
)
+
terminator
;
}
}
return
selectorText
+
"
{
"
+
terminator
+
cssText
+
"
}
"
;
}
hasAnyVisibleProperties
(
)
{
for
(
const
prop
of
this
.
textProps
)
{
if
(
!
prop
.
invisible
)
{
return
true
;
}
}
return
false
;
}
onDeclarationsUpdated
(
declarations
)
{
this
.
textProps
.
forEach
(
(
textProp
index
)
=
>
{
const
isUsedPrevious
=
textProp
.
isUsed
(
)
.
used
;
const
isUsedCurrent
=
declarations
[
index
]
.
isUsed
.
used
;
if
(
isUsedPrevious
=
=
=
isUsedCurrent
)
{
return
;
}
textProp
.
isUsed
=
(
)
=
>
declarations
[
index
]
.
isUsed
;
textProp
.
editor
.
updatePropertyUsedIndicator
(
)
;
}
)
;
}
onLocationChanged
(
)
{
const
url
=
this
.
sheet
?
this
.
sheet
.
href
|
|
this
.
sheet
.
nodeHref
:
null
;
this
.
updateSourceLocation
(
url
this
.
ruleLine
this
.
ruleColumn
)
;
}
subscribeToLocationChange
(
)
{
const
{
url
line
column
}
=
this
.
sourceLocation
;
if
(
url
&
&
!
this
.
isSystem
&
&
this
.
domRule
.
type
!
=
=
ELEMENT_STYLE
)
{
this
.
unsubscribeSourceMap
=
this
.
sourceMapURLService
.
subscribe
(
url
line
column
(
enabled
sourceUrl
sourceLine
sourceColumn
)
=
>
{
if
(
enabled
)
{
this
.
updateSourceLocation
(
sourceUrl
sourceLine
sourceColumn
)
;
}
}
)
;
}
this
.
domRule
.
on
(
"
location
-
changed
"
this
.
onLocationChanged
)
;
}
updateSourceLocation
(
url
line
column
)
{
this
.
_sourceLocation
=
{
column
line
url
}
;
this
.
store
.
dispatch
(
updateSourceLink
(
this
.
domRule
.
actorID
this
.
sourceLink
)
)
;
}
}
module
.
exports
=
Rule
;
