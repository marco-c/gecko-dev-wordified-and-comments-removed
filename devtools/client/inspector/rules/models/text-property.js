"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
{
escapeCSSComment
}
=
require
(
"
devtools
/
shared
/
css
/
parsing
-
utils
"
)
;
const
{
getCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
domUtils
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
function
TextProperty
(
rule
name
value
priority
enabled
=
true
invisible
=
false
)
{
this
.
rule
=
rule
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
priority
=
priority
;
this
.
enabled
=
!
!
enabled
;
this
.
invisible
=
invisible
;
this
.
updateComputed
(
)
;
const
toolbox
=
this
.
rule
.
elementStyle
.
ruleView
.
inspector
.
toolbox
;
this
.
cssProperties
=
getCssProperties
(
toolbox
)
;
}
TextProperty
.
prototype
=
{
updateEditor
:
function
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
update
(
)
;
}
}
updateComputed
:
function
(
)
{
if
(
!
this
.
name
)
{
return
;
}
let
dummyElement
=
this
.
rule
.
elementStyle
.
ruleView
.
dummyElement
;
let
dummyStyle
=
dummyElement
.
style
;
dummyStyle
.
cssText
=
"
"
;
dummyStyle
.
setProperty
(
this
.
name
this
.
value
this
.
priority
)
;
this
.
computed
=
[
]
;
try
{
let
subProps
=
domUtils
.
getSubpropertiesForCSSProperty
(
this
.
name
)
;
for
(
let
prop
of
subProps
)
{
this
.
computed
.
push
(
{
textProp
:
this
name
:
prop
value
:
dummyStyle
.
getPropertyValue
(
prop
)
priority
:
dummyStyle
.
getPropertyPriority
(
prop
)
}
)
;
}
}
catch
(
e
)
{
}
}
set
:
function
(
prop
)
{
let
changed
=
false
;
for
(
let
item
of
[
"
name
"
"
value
"
"
priority
"
"
enabled
"
]
)
{
if
(
this
[
item
]
!
=
=
prop
[
item
]
)
{
this
[
item
]
=
prop
[
item
]
;
changed
=
true
;
}
}
if
(
changed
)
{
this
.
updateEditor
(
)
;
}
}
setValue
:
function
(
value
priority
force
=
false
)
{
let
store
=
this
.
rule
.
elementStyle
.
store
;
if
(
this
.
editor
&
&
value
!
=
=
this
.
editor
.
committed
.
value
|
|
force
)
{
store
.
userProperties
.
setProperty
(
this
.
rule
.
style
this
.
name
value
)
;
}
this
.
rule
.
setPropertyValue
(
this
value
priority
)
;
this
.
updateEditor
(
)
;
}
noticeNewValue
:
function
(
value
)
{
if
(
value
!
=
=
this
.
value
)
{
this
.
value
=
value
;
this
.
updateEditor
(
)
;
}
}
setName
:
function
(
name
)
{
let
store
=
this
.
rule
.
elementStyle
.
store
;
if
(
name
!
=
=
this
.
name
)
{
store
.
userProperties
.
setProperty
(
this
.
rule
.
style
name
this
.
editor
.
committed
.
value
)
;
}
this
.
rule
.
setPropertyName
(
this
name
)
;
this
.
updateEditor
(
)
;
}
setEnabled
:
function
(
value
)
{
this
.
rule
.
setPropertyEnabled
(
this
value
)
;
this
.
updateEditor
(
)
;
}
remove
:
function
(
)
{
this
.
rule
.
removeProperty
(
this
)
;
}
stringifyProperty
:
function
(
)
{
let
declaration
=
this
.
name
+
"
:
"
+
this
.
editor
.
valueSpan
.
textContent
+
"
;
"
;
if
(
!
this
.
enabled
)
{
declaration
=
"
/
*
"
+
escapeCSSComment
(
declaration
)
+
"
*
/
"
;
}
return
declaration
;
}
isKnownProperty
:
function
(
)
{
return
this
.
cssProperties
.
isKnown
(
this
.
name
)
;
}
isValid
:
function
(
)
{
if
(
!
this
.
rule
.
domRule
.
declarations
)
{
return
domUtils
.
cssPropertyIsValid
(
this
.
name
this
.
value
)
;
}
let
selfIndex
=
this
.
rule
.
textProps
.
indexOf
(
this
)
;
if
(
!
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
)
{
return
true
;
}
return
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
.
isValid
;
}
}
;
exports
.
TextProperty
=
TextProperty
;
