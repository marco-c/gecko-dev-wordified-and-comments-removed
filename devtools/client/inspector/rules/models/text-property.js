"
use
strict
"
;
const
{
generateUUID
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
generate
-
uuid
.
js
"
)
;
const
{
COMPATIBILITY_TOOLTIP_MESSAGE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
escapeCSSComment
"
"
resource
:
/
/
devtools
/
shared
/
css
/
parsing
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCSSVariables
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
rules
/
utils
/
utils
.
js
"
true
)
;
class
TextProperty
{
constructor
(
rule
name
value
priority
enabled
=
true
invisible
=
false
)
{
this
.
id
=
name
+
"
_
"
+
generateUUID
(
)
.
toString
(
)
;
this
.
rule
=
rule
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
priority
=
priority
;
this
.
enabled
=
!
!
enabled
;
this
.
invisible
=
invisible
;
this
.
elementStyle
=
this
.
rule
.
elementStyle
;
this
.
cssProperties
=
this
.
elementStyle
.
ruleView
.
cssProperties
;
this
.
panelDoc
=
this
.
elementStyle
.
ruleView
.
inspector
.
panelDoc
;
this
.
userProperties
=
this
.
elementStyle
.
store
.
userProperties
;
this
.
usedVariables
=
new
Set
(
)
;
this
.
updateComputed
(
)
;
this
.
updateUsedVariables
(
)
;
}
get
computedProperties
(
)
{
return
this
.
computed
.
filter
(
computed
=
>
computed
.
name
!
=
=
this
.
name
)
.
map
(
computed
=
>
{
return
{
isOverridden
:
computed
.
overridden
name
:
computed
.
name
priority
:
computed
.
priority
value
:
computed
.
value
}
;
}
)
;
}
get
isKnownProperty
(
)
{
return
this
.
cssProperties
.
isKnown
(
this
.
name
)
;
}
get
isPropertyChanged
(
)
{
return
this
.
userProperties
.
contains
(
this
.
rule
.
domRule
this
.
name
)
;
}
updateEditor
(
)
{
this
.
rule
.
compatibilityIssues
=
null
;
if
(
this
.
editor
)
{
this
.
editor
.
update
(
)
;
}
}
updateComputed
(
)
{
if
(
!
this
.
name
)
{
return
;
}
const
dummyElement
=
this
.
elementStyle
.
ruleView
.
dummyElement
;
const
dummyStyle
=
dummyElement
.
style
;
dummyStyle
.
cssText
=
"
"
;
dummyStyle
.
setProperty
(
this
.
name
this
.
value
this
.
priority
)
;
this
.
computed
=
[
]
;
const
subProps
=
this
.
cssProperties
.
getSubproperties
(
this
.
name
)
;
for
(
const
prop
of
subProps
)
{
this
.
computed
.
push
(
{
textProp
:
this
name
:
prop
value
:
dummyStyle
.
getPropertyValue
(
prop
)
priority
:
dummyStyle
.
getPropertyPriority
(
prop
)
}
)
;
}
}
updateUsedVariables
(
)
{
this
.
usedVariables
.
clear
(
)
;
for
(
const
variable
of
getCSSVariables
(
this
.
value
)
)
{
this
.
usedVariables
.
add
(
variable
)
;
}
}
set
(
prop
)
{
let
changed
=
false
;
for
(
const
item
of
[
"
name
"
"
value
"
"
priority
"
"
enabled
"
]
)
{
if
(
this
[
item
]
!
=
=
prop
[
item
]
)
{
this
[
item
]
=
prop
[
item
]
;
changed
=
true
;
}
}
if
(
changed
)
{
this
.
updateUsedVariables
(
)
;
this
.
updateEditor
(
)
;
}
}
setValue
(
value
priority
force
=
false
)
{
if
(
value
!
=
=
this
.
value
|
|
force
)
{
this
.
userProperties
.
setProperty
(
this
.
rule
.
domRule
this
.
name
value
)
;
}
return
this
.
rule
.
setPropertyValue
(
this
value
priority
)
.
then
(
(
)
=
>
{
this
.
updateUsedVariables
(
)
;
this
.
updateEditor
(
)
;
}
)
;
}
updateValue
(
value
)
{
if
(
value
!
=
=
this
.
value
)
{
this
.
value
=
value
;
this
.
updateUsedVariables
(
)
;
this
.
updateEditor
(
)
;
}
}
async
setName
(
name
)
{
if
(
name
!
=
=
this
.
name
)
{
this
.
userProperties
.
setProperty
(
this
.
rule
.
domRule
name
this
.
value
)
;
}
await
this
.
rule
.
setPropertyName
(
this
name
)
;
this
.
updateEditor
(
)
;
}
setEnabled
(
value
)
{
this
.
rule
.
setPropertyEnabled
(
this
value
)
;
this
.
updateEditor
(
)
;
}
remove
(
)
{
this
.
rule
.
removeProperty
(
this
)
;
}
stringifyProperty
(
)
{
let
declaration
=
this
.
name
+
"
:
"
+
this
.
value
;
if
(
this
.
priority
)
{
declaration
+
=
"
!
"
+
this
.
priority
;
}
declaration
+
=
"
;
"
;
if
(
!
this
.
enabled
)
{
declaration
=
"
/
*
"
+
escapeCSSComment
(
declaration
)
+
"
*
/
"
;
}
return
declaration
;
}
#
getDomRuleDeclaration
(
)
{
const
selfIndex
=
this
.
rule
.
textProps
.
indexOf
(
this
)
;
return
this
.
rule
.
domRule
.
declarations
?
.
[
selfIndex
]
;
}
isValid
(
)
{
const
declaration
=
this
.
#
getDomRuleDeclaration
(
)
;
if
(
!
declaration
)
{
return
true
;
}
return
declaration
.
isValid
;
}
isUsed
(
)
{
const
declaration
=
this
.
#
getDomRuleDeclaration
(
)
;
if
(
!
declaration
?
.
isUsed
)
{
return
{
used
:
true
}
;
}
return
declaration
.
isUsed
;
}
async
isCompatible
(
)
{
if
(
!
this
.
enabled
)
{
return
{
isCompatible
:
true
}
;
}
const
compatibilityIssues
=
await
this
.
rule
.
getCompatibilityIssues
(
)
;
if
(
!
compatibilityIssues
.
length
)
{
return
{
isCompatible
:
true
}
;
}
const
property
=
this
.
name
;
const
indexOfProperty
=
compatibilityIssues
.
findIndex
(
issue
=
>
issue
.
property
=
=
=
property
|
|
issue
.
aliases
?
.
includes
(
property
)
)
;
if
(
indexOfProperty
<
0
)
{
return
{
isCompatible
:
true
}
;
}
const
{
property
:
rootProperty
deprecated
experimental
specUrl
url
unsupportedBrowsers
}
=
compatibilityIssues
[
indexOfProperty
]
;
let
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
.
default
;
if
(
deprecated
&
&
experimental
&
&
!
unsupportedBrowsers
.
length
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
[
"
deprecated
-
experimental
-
supported
"
]
;
}
else
if
(
deprecated
&
&
experimental
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
[
"
deprecated
-
experimental
"
]
;
}
else
if
(
deprecated
&
&
!
unsupportedBrowsers
.
length
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
[
"
deprecated
-
supported
"
]
;
}
else
if
(
deprecated
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
.
deprecated
;
}
else
if
(
experimental
&
&
!
unsupportedBrowsers
.
length
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
[
"
experimental
-
supported
"
]
;
}
else
if
(
experimental
)
{
msgId
=
COMPATIBILITY_TOOLTIP_MESSAGE
.
experimental
;
}
return
{
isCompatible
:
false
property
rootProperty
msgId
specUrl
url
unsupportedBrowsers
}
;
}
isNameValid
(
)
{
const
declaration
=
this
.
#
getDomRuleDeclaration
(
)
;
if
(
!
declaration
)
{
return
true
;
}
return
declaration
.
isNameValid
;
}
hasCSSVariable
(
name
)
{
return
this
.
usedVariables
.
has
(
name
)
;
}
}
module
.
exports
=
TextProperty
;
