"
use
strict
"
;
const
{
generateUUID
}
=
require
(
"
devtools
/
shared
/
generate
-
uuid
"
)
;
loader
.
lazyRequireGetter
(
this
"
escapeCSSComment
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
class
TextProperty
{
constructor
(
rule
name
value
priority
enabled
=
true
invisible
=
false
)
{
this
.
id
=
name
+
"
_
"
+
generateUUID
(
)
.
toString
(
)
;
this
.
rule
=
rule
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
priority
=
priority
;
this
.
enabled
=
!
!
enabled
;
this
.
invisible
=
invisible
;
this
.
elementStyle
=
this
.
rule
.
elementStyle
;
this
.
cssProperties
=
this
.
elementStyle
.
ruleView
.
cssProperties
;
this
.
panelDoc
=
this
.
elementStyle
.
ruleView
.
inspector
.
panelDoc
;
this
.
userProperties
=
this
.
elementStyle
.
store
.
userProperties
;
this
.
updateComputed
(
)
;
}
get
computedProperties
(
)
{
return
this
.
computed
.
filter
(
computed
=
>
computed
.
name
!
=
=
this
.
name
)
.
map
(
computed
=
>
{
return
{
isOverridden
:
computed
.
overridden
name
:
computed
.
name
priority
:
computed
.
priority
value
:
computed
.
value
}
;
}
)
;
}
get
isKnownProperty
(
)
{
return
this
.
cssProperties
.
isKnown
(
this
.
name
)
;
}
get
isPropertyChanged
(
)
{
return
this
.
userProperties
.
contains
(
this
.
rule
.
domRule
this
.
name
)
;
}
updateEditor
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
update
(
)
;
}
}
updateComputed
(
)
{
if
(
!
this
.
name
)
{
return
;
}
const
dummyElement
=
this
.
elementStyle
.
ruleView
.
dummyElement
;
const
dummyStyle
=
dummyElement
.
style
;
dummyStyle
.
cssText
=
"
"
;
dummyStyle
.
setProperty
(
this
.
name
this
.
value
this
.
priority
)
;
this
.
computed
=
[
]
;
const
subProps
=
this
.
cssProperties
.
getSubproperties
(
this
.
name
)
;
for
(
const
prop
of
subProps
)
{
this
.
computed
.
push
(
{
textProp
:
this
name
:
prop
value
:
dummyStyle
.
getPropertyValue
(
prop
)
priority
:
dummyStyle
.
getPropertyPriority
(
prop
)
}
)
;
}
}
set
(
prop
)
{
let
changed
=
false
;
for
(
const
item
of
[
"
name
"
"
value
"
"
priority
"
"
enabled
"
]
)
{
if
(
this
[
item
]
!
=
=
prop
[
item
]
)
{
this
[
item
]
=
prop
[
item
]
;
changed
=
true
;
}
}
if
(
changed
)
{
this
.
updateEditor
(
)
;
}
}
setValue
(
value
priority
force
=
false
)
{
if
(
value
!
=
=
this
.
value
|
|
force
)
{
this
.
userProperties
.
setProperty
(
this
.
rule
.
domRule
this
.
name
value
)
;
}
return
this
.
rule
.
setPropertyValue
(
this
value
priority
)
.
then
(
(
)
=
>
this
.
updateEditor
(
)
)
;
}
updateValue
(
value
)
{
if
(
value
!
=
=
this
.
value
)
{
this
.
value
=
value
;
this
.
updateEditor
(
)
;
}
}
async
setName
(
name
)
{
if
(
name
!
=
=
this
.
name
)
{
this
.
userProperties
.
setProperty
(
this
.
rule
.
domRule
name
this
.
value
)
;
}
await
this
.
rule
.
setPropertyName
(
this
name
)
;
this
.
updateEditor
(
)
;
}
setEnabled
(
value
)
{
this
.
rule
.
setPropertyEnabled
(
this
value
)
;
this
.
updateEditor
(
)
;
}
remove
(
)
{
this
.
rule
.
removeProperty
(
this
)
;
}
stringifyProperty
(
)
{
let
declaration
=
this
.
name
+
"
:
"
+
this
.
value
;
if
(
this
.
priority
)
{
declaration
+
=
"
!
"
+
this
.
priority
;
}
declaration
+
=
"
;
"
;
if
(
!
this
.
enabled
)
{
declaration
=
"
/
*
"
+
escapeCSSComment
(
declaration
)
+
"
*
/
"
;
}
return
declaration
;
}
isValid
(
)
{
const
selfIndex
=
this
.
rule
.
textProps
.
indexOf
(
this
)
;
if
(
!
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
)
{
return
true
;
}
return
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
.
isValid
;
}
isUsed
(
)
{
const
selfIndex
=
this
.
rule
.
textProps
.
indexOf
(
this
)
;
const
declarations
=
this
.
rule
.
domRule
.
declarations
;
if
(
!
declarations
|
|
!
declarations
[
selfIndex
]
|
|
!
declarations
[
selfIndex
]
.
isUsed
)
{
return
{
used
:
true
}
;
}
return
declarations
[
selfIndex
]
.
isUsed
;
}
isNameValid
(
)
{
const
selfIndex
=
this
.
rule
.
textProps
.
indexOf
(
this
)
;
if
(
!
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
)
{
return
true
;
}
return
this
.
rule
.
domRule
.
declarations
[
selfIndex
]
.
isNameValid
;
}
hasCSSVariable
(
name
)
{
const
regex
=
new
RegExp
(
(
^
|
\
\
W
)
var
\
\
(
{
name
}
\
\
s
*
[
)
]
)
;
return
regex
.
test
(
this
.
value
)
;
}
}
module
.
exports
=
TextProperty
;
