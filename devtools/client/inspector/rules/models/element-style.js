"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Rule
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
{
promiseWarn
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
server
/
actors
/
styles
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
loader
.
lazyGetter
(
this
"
PSEUDO_ELEMENTS
"
(
)
=
>
{
return
domUtils
.
getCSSPseudoElementNames
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
domUtils
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
function
ElementStyle
(
element
ruleView
store
pageStyle
showUserAgentStyles
)
{
this
.
element
=
element
;
this
.
ruleView
=
ruleView
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
pageStyle
;
this
.
showUserAgentStyles
=
showUserAgentStyles
;
this
.
rules
=
[
]
;
if
(
!
(
"
userProperties
"
in
this
.
store
)
)
{
this
.
store
.
userProperties
=
new
UserProperties
(
)
;
}
if
(
!
(
"
disabled
"
in
this
.
store
)
)
{
this
.
store
.
disabled
=
new
WeakMap
(
)
;
}
}
ElementStyle
.
prototype
=
{
element
:
null
destroy
:
function
(
)
{
if
(
this
.
destroyed
)
{
return
;
}
this
.
destroyed
=
true
;
for
(
let
rule
of
this
.
rules
)
{
if
(
rule
.
editor
)
{
rule
.
editor
.
destroy
(
)
;
}
}
}
_changed
:
function
(
)
{
if
(
this
.
onChanged
)
{
this
.
onChanged
(
)
;
}
}
populate
:
function
(
)
{
let
populated
=
this
.
pageStyle
.
getApplied
(
this
.
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
this
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
.
then
(
entries
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
if
(
this
.
populated
!
=
=
populated
)
{
return
promise
.
resolve
(
undefined
)
;
}
let
existingRules
=
this
.
rules
;
this
.
rules
=
[
]
;
for
(
let
entry
of
entries
)
{
this
.
_maybeAddRule
(
entry
existingRules
)
;
}
this
.
markOverriddenAll
(
)
;
this
.
_sortRulesForPseudoElement
(
)
;
for
(
let
r
of
existingRules
)
{
if
(
r
&
&
r
.
editor
)
{
r
.
editor
.
destroy
(
)
;
}
}
return
undefined
;
}
)
.
then
(
null
e
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
promiseWarn
(
e
)
;
}
)
;
this
.
populated
=
populated
;
return
this
.
populated
;
}
_sortRulesForPseudoElement
:
function
(
)
{
this
.
rules
=
this
.
rules
.
sort
(
(
a
b
)
=
>
{
return
(
a
.
pseudoElement
|
|
"
z
"
)
>
(
b
.
pseudoElement
|
|
"
z
"
)
;
}
)
;
}
_maybeAddRule
:
function
(
options
existingRules
)
{
if
(
options
.
rule
&
&
this
.
rules
.
some
(
rule
=
>
rule
.
domRule
=
=
=
options
.
rule
)
)
{
return
false
;
}
if
(
options
.
system
)
{
return
false
;
}
let
rule
=
null
;
if
(
existingRules
)
{
let
ruleIndex
=
existingRules
.
findIndex
(
(
r
)
=
>
r
.
matches
(
options
)
)
;
if
(
ruleIndex
>
=
0
)
{
rule
=
existingRules
[
ruleIndex
]
;
rule
.
refresh
(
options
)
;
existingRules
.
splice
(
ruleIndex
1
)
;
}
}
if
(
!
rule
)
{
rule
=
new
Rule
(
this
options
)
;
}
if
(
options
.
inherited
&
&
!
rule
.
hasAnyVisibleProperties
(
)
)
{
return
false
;
}
this
.
rules
.
push
(
rule
)
;
return
true
;
}
markOverriddenAll
:
function
(
)
{
this
.
markOverridden
(
)
;
for
(
let
pseudo
of
PSEUDO_ELEMENTS
)
{
this
.
markOverridden
(
pseudo
)
;
}
}
markOverridden
:
function
(
pseudo
=
"
"
)
{
let
textProps
=
[
]
;
for
(
let
rule
of
this
.
rules
)
{
if
(
(
rule
.
matchedSelectors
.
length
>
0
|
|
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
&
&
rule
.
pseudoElement
=
=
=
pseudo
&
&
!
rule
.
keyframes
)
{
for
(
let
textProp
of
rule
.
textProps
.
slice
(
0
)
.
reverse
(
)
)
{
if
(
textProp
.
enabled
)
{
textProps
.
push
(
textProp
)
;
}
}
}
}
let
computedProps
=
[
]
;
for
(
let
textProp
of
textProps
)
{
computedProps
=
computedProps
.
concat
(
textProp
.
computed
)
;
}
let
taken
=
{
}
;
for
(
let
computedProp
of
computedProps
)
{
let
earlier
=
taken
[
computedProp
.
name
]
;
if
(
!
computedProp
.
textProp
.
isValid
(
)
)
{
computedProp
.
overridden
=
true
;
continue
;
}
let
overridden
;
if
(
earlier
&
&
computedProp
.
priority
=
=
=
"
important
"
&
&
earlier
.
priority
!
=
=
"
important
"
&
&
(
earlier
.
textProp
.
rule
.
inherited
|
|
!
computedProp
.
textProp
.
rule
.
inherited
)
)
{
earlier
.
_overriddenDirty
=
!
earlier
.
_overriddenDirty
;
earlier
.
overridden
=
true
;
overridden
=
false
;
}
else
{
overridden
=
!
!
earlier
;
}
computedProp
.
_overriddenDirty
=
(
!
!
computedProp
.
overridden
!
=
=
overridden
)
;
computedProp
.
overridden
=
overridden
;
if
(
!
computedProp
.
overridden
&
&
computedProp
.
textProp
.
enabled
)
{
taken
[
computedProp
.
name
]
=
computedProp
;
}
}
for
(
let
textProp
of
textProps
)
{
if
(
this
.
_updatePropertyOverridden
(
textProp
)
)
{
textProp
.
updateEditor
(
)
;
}
}
}
_updatePropertyOverridden
:
function
(
prop
)
{
let
overridden
=
true
;
let
dirty
=
false
;
for
(
let
computedProp
of
prop
.
computed
)
{
if
(
!
computedProp
.
overridden
)
{
overridden
=
false
;
}
dirty
=
computedProp
.
_overriddenDirty
|
|
dirty
;
delete
computedProp
.
_overriddenDirty
;
}
dirty
=
(
!
!
prop
.
overridden
!
=
=
overridden
)
|
|
dirty
;
prop
.
overridden
=
overridden
;
return
dirty
;
}
}
;
function
UserProperties
(
)
{
this
.
map
=
new
Map
(
)
;
}
UserProperties
.
prototype
=
{
getProperty
:
function
(
style
name
value
)
{
let
key
=
this
.
getKey
(
style
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
if
(
entry
&
&
name
in
entry
)
{
return
entry
[
name
]
;
}
return
value
;
}
setProperty
:
function
(
style
bame
userValue
)
{
let
key
=
this
.
getKey
(
style
bame
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
if
(
entry
)
{
entry
[
bame
]
=
userValue
;
}
else
{
let
props
=
{
}
;
props
[
bame
]
=
userValue
;
this
.
map
.
set
(
key
props
)
;
}
}
contains
:
function
(
style
name
)
{
let
key
=
this
.
getKey
(
style
name
)
;
let
entry
=
this
.
map
.
get
(
key
null
)
;
return
!
!
entry
&
&
name
in
entry
;
}
getKey
:
function
(
style
name
)
{
return
style
.
actorID
+
"
:
"
+
name
;
}
clear
:
function
(
)
{
this
.
map
.
clear
(
)
;
}
}
;
exports
.
ElementStyle
=
ElementStyle
;
