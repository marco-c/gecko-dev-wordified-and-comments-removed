"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
Rule
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
UserProperties
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
user
-
properties
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
loader
.
lazyRequireGetter
(
this
"
promiseWarn
"
"
devtools
/
client
/
inspector
/
shared
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
parseDeclarations
"
"
parseNamedDeclarations
"
"
parseSingleValue
"
]
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCssVariable
"
"
devtools
/
client
/
fronts
/
css
-
properties
"
true
)
;
const
PREF_INACTIVE_CSS_ENABLED
=
"
devtools
.
inspector
.
inactive
.
css
.
enabled
"
;
class
ElementStyle
{
constructor
(
element
ruleView
store
pageStyle
showUserAgentStyles
)
{
this
.
element
=
element
;
this
.
ruleView
=
ruleView
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
pageStyle
;
this
.
pseudoElements
=
[
]
;
this
.
showUserAgentStyles
=
showUserAgentStyles
;
this
.
rules
=
[
]
;
this
.
cssProperties
=
this
.
ruleView
.
cssProperties
;
this
.
variablesMap
=
new
Map
(
)
;
if
(
!
(
"
userProperties
"
in
this
.
store
)
)
{
this
.
store
.
userProperties
=
new
UserProperties
(
)
;
}
if
(
!
(
"
disabled
"
in
this
.
store
)
)
{
this
.
store
.
disabled
=
new
WeakMap
(
)
;
}
this
.
onRefresh
=
this
.
onRefresh
.
bind
(
this
)
;
if
(
this
.
ruleView
.
isNewRulesView
)
{
this
.
pageStyle
.
on
(
"
stylesheet
-
updated
"
this
.
onRefresh
)
;
this
.
ruleView
.
inspector
.
styleChangeTracker
.
on
(
"
style
-
changed
"
this
.
onRefresh
)
;
this
.
ruleView
.
selection
.
on
(
"
pseudoclass
"
this
.
onRefresh
)
;
}
}
get
unusedCssEnabled
(
)
{
if
(
!
this
.
_unusedCssEnabled
)
{
this
.
_unusedCssEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_INACTIVE_CSS_ENABLED
false
)
;
}
return
this
.
_unusedCssEnabled
;
}
destroy
(
)
{
if
(
this
.
destroyed
)
{
return
;
}
this
.
destroyed
=
true
;
this
.
pseudoElements
=
[
]
;
for
(
const
rule
of
this
.
rules
)
{
if
(
rule
.
editor
)
{
rule
.
editor
.
destroy
(
)
;
}
rule
.
destroy
(
)
;
}
if
(
this
.
ruleView
.
isNewRulesView
)
{
this
.
pageStyle
.
off
(
"
stylesheet
-
updated
"
this
.
onRefresh
)
;
this
.
ruleView
.
inspector
.
styleChangeTracker
.
off
(
"
style
-
changed
"
this
.
onRefresh
)
;
this
.
ruleView
.
selection
.
off
(
"
pseudoclass
"
this
.
onRefresh
)
;
}
}
_changed
(
)
{
if
(
this
.
onChanged
)
{
this
.
onChanged
(
)
;
}
}
populate
(
)
{
const
populated
=
this
.
pageStyle
.
getApplied
(
this
.
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
this
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
.
then
(
entries
=
>
{
if
(
this
.
destroyed
|
|
this
.
populated
!
=
=
populated
)
{
return
promise
.
resolve
(
undefined
)
;
}
const
existingRules
=
this
.
rules
;
this
.
rules
=
[
]
;
for
(
const
entry
of
entries
)
{
this
.
_maybeAddRule
(
entry
existingRules
)
;
}
this
.
pseudoElements
=
this
.
rules
.
filter
(
r
=
>
r
.
pseudoElement
)
.
map
(
r
=
>
r
.
pseudoElement
)
;
this
.
onRuleUpdated
(
)
;
this
.
_sortRulesForPseudoElement
(
)
;
if
(
this
.
ruleView
.
isNewRulesView
)
{
this
.
subscribeRulesToLocationChange
(
)
;
}
for
(
const
r
of
existingRules
)
{
if
(
r
?
.
editor
)
{
r
.
editor
.
destroy
(
)
;
}
r
.
destroy
(
)
;
}
return
undefined
;
}
)
.
catch
(
e
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
promiseWarn
(
e
)
;
}
)
;
this
.
populated
=
populated
;
return
this
.
populated
;
}
getRule
(
id
)
{
return
id
?
this
.
rules
.
find
(
rule
=
>
rule
.
domRule
.
actorID
=
=
=
id
)
:
undefined
;
}
getUsedFontFamilies
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
ruleView
.
styleWindow
.
requestIdleCallback
(
async
(
)
=
>
{
try
{
const
fonts
=
await
this
.
pageStyle
.
getUsedFontFaces
(
this
.
element
{
includePreviews
:
false
}
)
;
resolve
(
fonts
.
map
(
font
=
>
font
.
CSSFamilyName
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
_sortRulesForPseudoElement
(
)
{
this
.
rules
=
this
.
rules
.
sort
(
(
a
b
)
=
>
{
return
(
a
.
pseudoElement
|
|
"
z
"
)
>
(
b
.
pseudoElement
|
|
"
z
"
)
;
}
)
;
}
_maybeAddRule
(
options
existingRules
)
{
if
(
options
.
system
|
|
(
options
.
rule
&
&
this
.
rules
.
some
(
rule
=
>
rule
.
domRule
=
=
=
options
.
rule
)
)
)
{
return
false
;
}
let
rule
=
null
;
if
(
existingRules
)
{
const
ruleIndex
=
existingRules
.
findIndex
(
r
=
>
r
.
matches
(
options
)
)
;
if
(
ruleIndex
>
=
0
)
{
rule
=
existingRules
[
ruleIndex
]
;
rule
.
refresh
(
options
)
;
existingRules
.
splice
(
ruleIndex
1
)
;
}
}
if
(
!
rule
)
{
rule
=
new
Rule
(
this
options
)
;
}
if
(
options
.
inherited
&
&
!
rule
.
hasAnyVisibleProperties
(
)
)
{
return
false
;
}
this
.
rules
.
push
(
rule
)
;
return
true
;
}
onRuleUpdated
(
)
{
this
.
updateDeclarations
(
)
;
for
(
const
pseudo
of
this
.
pseudoElements
)
{
this
.
updateDeclarations
(
pseudo
)
;
}
}
updateDeclarations
(
pseudo
=
"
"
)
{
const
textProps
=
this
.
_getDeclarations
(
pseudo
)
;
let
computedProps
=
[
]
;
for
(
const
textProp
of
textProps
)
{
computedProps
=
computedProps
.
concat
(
textProp
.
computed
)
;
}
const
variables
=
new
Map
(
pseudo
?
this
.
variablesMap
.
get
(
"
"
)
:
null
)
;
const
taken
=
{
}
;
for
(
const
computedProp
of
computedProps
)
{
const
earlier
=
taken
[
computedProp
.
name
]
;
if
(
!
computedProp
.
textProp
.
isValid
(
)
)
{
computedProp
.
overridden
=
true
;
continue
;
}
let
overridden
;
if
(
earlier
&
&
computedProp
.
priority
=
=
=
"
important
"
&
&
earlier
.
priority
!
=
=
"
important
"
&
&
(
earlier
.
textProp
.
rule
.
inherited
|
|
!
computedProp
.
textProp
.
rule
.
inherited
)
)
{
earlier
.
_overriddenDirty
=
!
earlier
.
_overriddenDirty
;
earlier
.
overridden
=
true
;
overridden
=
false
;
}
else
{
overridden
=
!
!
earlier
;
}
computedProp
.
_overriddenDirty
=
!
!
computedProp
.
overridden
!
=
=
overridden
;
computedProp
.
overridden
=
overridden
;
if
(
!
computedProp
.
overridden
&
&
computedProp
.
textProp
.
enabled
)
{
taken
[
computedProp
.
name
]
=
computedProp
;
if
(
isCssVariable
(
computedProp
.
name
)
)
{
variables
.
set
(
computedProp
.
name
computedProp
.
value
)
;
}
}
}
const
previousVariablesMap
=
new
Map
(
this
.
variablesMap
.
get
(
pseudo
)
)
;
const
changedVariableNamesSet
=
new
Set
(
[
.
.
.
variables
.
keys
(
)
.
.
.
previousVariablesMap
.
keys
(
)
]
.
filter
(
k
=
>
variables
.
get
(
k
)
!
=
=
previousVariablesMap
.
get
(
k
)
)
)
;
this
.
variablesMap
.
set
(
pseudo
variables
)
;
for
(
const
textProp
of
textProps
)
{
if
(
this
.
_updatePropertyOverridden
(
textProp
)
|
|
this
.
_hasUpdatedCSSVariable
(
textProp
changedVariableNamesSet
)
)
{
textProp
.
updateEditor
(
)
;
}
if
(
textProp
.
editor
&
&
this
.
unusedCssEnabled
)
{
textProp
.
editor
.
updatePropertyState
(
)
;
}
}
}
_hasUpdatedCSSVariable
(
declaration
variableNamesSet
)
{
for
(
const
variableName
of
variableNamesSet
)
{
if
(
declaration
.
hasCSSVariable
(
variableName
)
)
{
return
true
;
}
}
return
false
;
}
_getDeclarations
(
pseudo
=
"
"
)
{
const
textProps
=
[
]
;
for
(
const
rule
of
this
.
rules
)
{
if
(
rule
.
keyframes
)
{
continue
;
}
const
isStyleRule
=
rule
.
pseudoElement
=
=
=
"
"
&
&
rule
.
matchedSelectors
.
length
>
0
;
const
isPseudoElementRule
=
rule
.
pseudoElement
!
=
=
"
"
&
&
rule
.
pseudoElement
=
=
=
pseudo
;
const
isElementStyle
=
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
;
const
filterCondition
=
pseudo
=
=
=
"
"
?
isStyleRule
|
|
isElementStyle
:
isPseudoElementRule
;
if
(
filterCondition
)
{
for
(
const
textProp
of
rule
.
textProps
.
slice
(
0
)
.
reverse
(
)
)
{
if
(
textProp
.
enabled
)
{
textProps
.
push
(
textProp
)
;
}
}
}
}
return
textProps
;
}
addNewDeclaration
(
ruleId
value
)
{
const
rule
=
this
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
declarationsToAdd
=
parseNamedDeclarations
(
this
.
cssProperties
.
isKnown
value
true
)
;
if
(
!
declarationsToAdd
.
length
)
{
return
;
}
this
.
_addMultipleDeclarations
(
rule
declarationsToAdd
)
;
}
async
addNewRule
(
)
{
await
this
.
pageStyle
.
addNewRule
(
this
.
element
this
.
element
.
pseudoClassLocks
)
;
}
async
modifyDeclarationName
(
ruleId
declarationId
name
)
{
const
rule
=
this
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
declaration
=
rule
.
getDeclaration
(
declarationId
)
;
if
(
!
declaration
|
|
declaration
.
name
=
=
=
name
)
{
return
;
}
const
declarations
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
name
)
;
if
(
!
declarations
.
length
)
{
return
;
}
await
declaration
.
setName
(
declarations
[
0
]
.
name
)
;
if
(
!
declaration
.
enabled
)
{
await
declaration
.
setEnabled
(
true
)
;
}
}
_addMultipleDeclarations
(
rule
declarationsToAdd
siblingDeclaration
=
null
)
{
for
(
const
{
commentOffsets
name
value
priority
}
of
declarationsToAdd
)
{
const
isCommented
=
Boolean
(
commentOffsets
)
;
const
enabled
=
!
isCommented
;
siblingDeclaration
=
rule
.
createProperty
(
name
value
priority
enabled
siblingDeclaration
)
;
}
}
_getValueAndExtraProperties
(
value
)
{
let
firstValue
=
value
;
let
declarationsToAdd
=
[
]
;
const
declarations
=
parseDeclarations
(
this
.
cssProperties
.
isKnown
value
)
;
if
(
declarations
.
length
)
{
if
(
!
declarations
[
0
]
.
name
&
&
declarations
[
0
]
.
value
)
{
firstValue
=
declarations
[
0
]
.
value
;
declarationsToAdd
=
declarations
.
slice
(
1
)
;
}
else
if
(
declarations
[
0
]
.
name
&
&
declarations
[
0
]
.
value
)
{
firstValue
=
declarations
[
0
]
.
name
+
"
:
"
+
declarations
[
0
]
.
value
;
declarationsToAdd
=
declarations
.
slice
(
1
)
;
}
}
return
{
declarationsToAdd
firstValue
}
;
}
async
modifyDeclarationValue
(
ruleId
declarationId
value
)
{
const
rule
=
this
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
declaration
=
rule
.
getDeclaration
(
declarationId
)
;
if
(
!
declaration
)
{
return
;
}
const
{
declarationsToAdd
firstValue
}
=
this
.
_getValueAndExtraProperties
(
value
)
;
const
parsedValue
=
parseSingleValue
(
this
.
cssProperties
.
isKnown
firstValue
)
;
if
(
!
declarationsToAdd
.
length
&
&
declaration
.
value
=
=
=
parsedValue
.
value
&
&
declaration
.
priority
=
=
=
parsedValue
.
priority
)
{
return
;
}
await
declaration
.
setValue
(
parsedValue
.
value
parsedValue
.
priority
)
;
if
(
!
declaration
.
enabled
)
{
await
declaration
.
setEnabled
(
true
)
;
}
this
.
_addMultipleDeclarations
(
rule
declarationsToAdd
declaration
)
;
}
async
modifySelector
(
ruleId
selector
)
{
try
{
const
rule
=
this
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
response
=
await
rule
.
domRule
.
modifySelector
(
this
.
element
selector
)
;
const
{
ruleProps
isMatching
}
=
response
;
if
(
!
ruleProps
)
{
this
.
ruleView
.
emit
(
"
ruleview
-
invalid
-
selector
"
)
;
return
;
}
const
newRule
=
new
Rule
(
this
{
.
.
.
ruleProps
isUnmatched
:
!
isMatching
}
)
;
const
appliedStyles
=
await
this
.
pageStyle
.
getApplied
(
this
.
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
this
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
;
const
newIndex
=
appliedStyles
.
findIndex
(
r
=
>
r
.
rule
=
=
ruleProps
.
rule
)
;
const
oldIndex
=
this
.
rules
.
indexOf
(
rule
)
;
this
.
rules
.
splice
(
oldIndex
1
)
;
this
.
rules
.
splice
(
newIndex
=
=
=
-
1
?
oldIndex
:
newIndex
0
newRule
)
;
this
.
onRuleUpdated
(
)
;
if
(
newIndex
!
=
=
-
1
)
{
this
.
rules
.
splice
(
newIndex
1
)
;
this
.
rules
.
splice
(
oldIndex
0
newRule
)
;
}
this
.
_changed
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
subscribeRulesToLocationChange
(
)
{
for
(
const
rule
of
this
.
rules
)
{
rule
.
subscribeToLocationChange
(
)
;
}
}
toggleDeclaration
(
ruleId
declarationId
)
{
const
rule
=
this
.
getRule
(
ruleId
)
;
if
(
!
rule
)
{
return
;
}
const
declaration
=
rule
.
getDeclaration
(
declarationId
)
;
if
(
!
declaration
)
{
return
;
}
declaration
.
setEnabled
(
!
declaration
.
enabled
)
;
}
_updatePropertyOverridden
(
prop
)
{
let
overridden
=
true
;
let
dirty
=
false
;
for
(
const
computedProp
of
prop
.
computed
)
{
if
(
!
computedProp
.
overridden
)
{
overridden
=
false
;
}
dirty
=
computedProp
.
_overriddenDirty
|
|
dirty
;
delete
computedProp
.
_overriddenDirty
;
}
dirty
=
!
!
prop
.
overridden
!
=
=
overridden
|
|
dirty
;
prop
.
overridden
=
overridden
;
return
dirty
;
}
getVariable
(
name
pseudo
=
"
"
)
{
const
variables
=
this
.
variablesMap
.
get
(
pseudo
)
;
return
variables
?
variables
.
get
(
name
)
:
null
;
}
async
onRefresh
(
)
{
const
promises
=
[
]
;
for
(
const
rule
of
this
.
rules
)
{
if
(
rule
.
_applyingModifications
)
{
promises
.
push
(
rule
.
_applyingModifications
)
;
}
}
await
Promise
.
all
(
promises
)
;
await
this
.
populate
(
)
;
this
.
_changed
(
)
;
}
}
module
.
exports
=
ElementStyle
;
