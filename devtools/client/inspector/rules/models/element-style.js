"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
Rule
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
rule
"
)
;
const
UserProperties
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
models
/
user
-
properties
"
)
;
const
{
getCssProperties
isCssVariable
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
loader
.
lazyRequireGetter
(
this
"
promiseWarn
"
"
devtools
/
client
/
inspector
/
shared
/
utils
"
true
)
;
function
ElementStyle
(
element
ruleView
store
pageStyle
showUserAgentStyles
)
{
this
.
element
=
element
;
this
.
ruleView
=
ruleView
;
this
.
store
=
store
|
|
{
}
;
this
.
pageStyle
=
pageStyle
;
this
.
showUserAgentStyles
=
showUserAgentStyles
;
this
.
rules
=
[
]
;
this
.
cssProperties
=
this
.
ruleView
.
cssProperties
;
this
.
variables
=
new
Map
(
)
;
if
(
!
(
"
userProperties
"
in
this
.
store
)
)
{
this
.
store
.
userProperties
=
new
UserProperties
(
)
;
}
if
(
!
(
"
disabled
"
in
this
.
store
)
)
{
this
.
store
.
disabled
=
new
WeakMap
(
)
;
}
}
ElementStyle
.
prototype
=
{
destroy
:
function
(
)
{
if
(
this
.
destroyed
)
{
return
;
}
this
.
destroyed
=
true
;
for
(
const
rule
of
this
.
rules
)
{
if
(
rule
.
editor
)
{
rule
.
editor
.
destroy
(
)
;
}
}
}
_changed
:
function
(
)
{
if
(
this
.
onChanged
)
{
this
.
onChanged
(
)
;
}
}
populate
:
function
(
)
{
const
populated
=
this
.
pageStyle
.
getApplied
(
this
.
element
{
inherited
:
true
matchedSelectors
:
true
filter
:
this
.
showUserAgentStyles
?
"
ua
"
:
undefined
}
)
.
then
(
entries
=
>
{
if
(
this
.
destroyed
|
|
this
.
populated
!
=
=
populated
)
{
return
promise
.
resolve
(
undefined
)
;
}
const
existingRules
=
this
.
rules
;
this
.
rules
=
[
]
;
for
(
const
entry
of
entries
)
{
this
.
_maybeAddRule
(
entry
existingRules
)
;
}
this
.
markOverriddenAll
(
)
;
this
.
_sortRulesForPseudoElement
(
)
;
for
(
const
r
of
existingRules
)
{
if
(
r
&
&
r
.
editor
)
{
r
.
editor
.
destroy
(
)
;
}
}
return
undefined
;
}
)
.
catch
(
e
=
>
{
if
(
this
.
destroyed
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
promiseWarn
(
e
)
;
}
)
;
this
.
populated
=
populated
;
return
this
.
populated
;
}
getUsedFontFamilies
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
ruleView
.
styleWindow
.
requestIdleCallback
(
async
(
)
=
>
{
try
{
const
fonts
=
await
this
.
pageStyle
.
getUsedFontFaces
(
this
.
element
{
includePreviews
:
false
}
)
;
resolve
(
fonts
.
map
(
font
=
>
font
.
CSSFamilyName
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
_sortRulesForPseudoElement
:
function
(
)
{
this
.
rules
=
this
.
rules
.
sort
(
(
a
b
)
=
>
{
return
(
a
.
pseudoElement
|
|
"
z
"
)
>
(
b
.
pseudoElement
|
|
"
z
"
)
;
}
)
;
}
_maybeAddRule
:
function
(
options
existingRules
)
{
if
(
options
.
system
|
|
(
options
.
rule
&
&
this
.
rules
.
some
(
rule
=
>
rule
.
domRule
=
=
=
options
.
rule
)
)
)
{
return
false
;
}
let
rule
=
null
;
if
(
existingRules
)
{
const
ruleIndex
=
existingRules
.
findIndex
(
(
r
)
=
>
r
.
matches
(
options
)
)
;
if
(
ruleIndex
>
=
0
)
{
rule
=
existingRules
[
ruleIndex
]
;
rule
.
refresh
(
options
)
;
existingRules
.
splice
(
ruleIndex
1
)
;
}
}
if
(
!
rule
)
{
rule
=
new
Rule
(
this
options
)
;
}
if
(
options
.
inherited
&
&
!
rule
.
hasAnyVisibleProperties
(
)
)
{
return
false
;
}
this
.
rules
.
push
(
rule
)
;
return
true
;
}
markOverriddenAll
:
function
(
)
{
this
.
variables
.
clear
(
)
;
this
.
markOverridden
(
)
;
for
(
const
pseudo
of
this
.
cssProperties
.
pseudoElements
)
{
this
.
markOverridden
(
pseudo
)
;
}
}
markOverridden
:
function
(
pseudo
=
"
"
)
{
const
textProps
=
[
]
;
for
(
const
rule
of
this
.
rules
)
{
if
(
(
rule
.
matchedSelectors
.
length
>
0
|
|
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
&
&
rule
.
pseudoElement
=
=
=
pseudo
&
&
!
rule
.
keyframes
)
{
for
(
const
textProp
of
rule
.
textProps
.
slice
(
0
)
.
reverse
(
)
)
{
if
(
textProp
.
enabled
)
{
textProps
.
push
(
textProp
)
;
}
}
}
}
let
computedProps
=
[
]
;
for
(
const
textProp
of
textProps
)
{
computedProps
=
computedProps
.
concat
(
textProp
.
computed
)
;
}
const
taken
=
{
}
;
for
(
const
computedProp
of
computedProps
)
{
const
earlier
=
taken
[
computedProp
.
name
]
;
if
(
!
computedProp
.
textProp
.
isValid
(
)
)
{
computedProp
.
overridden
=
true
;
continue
;
}
let
overridden
;
if
(
earlier
&
&
computedProp
.
priority
=
=
=
"
important
"
&
&
earlier
.
priority
!
=
=
"
important
"
&
&
(
earlier
.
textProp
.
rule
.
inherited
|
|
!
computedProp
.
textProp
.
rule
.
inherited
)
)
{
earlier
.
_overriddenDirty
=
!
earlier
.
_overriddenDirty
;
earlier
.
overridden
=
true
;
overridden
=
false
;
}
else
{
overridden
=
!
!
earlier
;
}
computedProp
.
_overriddenDirty
=
(
!
!
computedProp
.
overridden
!
=
=
overridden
)
;
computedProp
.
overridden
=
overridden
;
if
(
!
computedProp
.
overridden
&
&
computedProp
.
textProp
.
enabled
)
{
taken
[
computedProp
.
name
]
=
computedProp
;
if
(
isCssVariable
(
computedProp
.
name
)
)
{
this
.
variables
.
set
(
computedProp
.
name
computedProp
.
value
)
;
}
}
}
for
(
const
textProp
of
textProps
)
{
if
(
this
.
_updatePropertyOverridden
(
textProp
)
)
{
textProp
.
updateEditor
(
)
;
}
}
}
_updatePropertyOverridden
:
function
(
prop
)
{
let
overridden
=
true
;
let
dirty
=
false
;
for
(
const
computedProp
of
prop
.
computed
)
{
if
(
!
computedProp
.
overridden
)
{
overridden
=
false
;
}
dirty
=
computedProp
.
_overriddenDirty
|
|
dirty
;
delete
computedProp
.
_overriddenDirty
;
}
dirty
=
(
!
!
prop
.
overridden
!
=
=
overridden
)
|
|
dirty
;
prop
.
overridden
=
overridden
;
return
dirty
;
}
getVariable
:
function
(
name
)
{
return
this
.
variables
.
get
(
name
)
;
}
}
;
module
.
exports
=
ElementStyle
;
