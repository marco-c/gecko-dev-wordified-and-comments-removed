"
use
strict
"
;
const
{
VIEW_NODE_CSS_QUERY_CONTAINER
VIEW_NODE_CSS_SELECTOR_WARNINGS
VIEW_NODE_FONT_TYPE
VIEW_NODE_IMAGE_URL_TYPE
VIEW_NODE_INACTIVE_CSS
VIEW_NODE_LOCATION_TYPE
VIEW_NODE_PROPERTY_TYPE
VIEW_NODE_SELECTOR_TYPE
VIEW_NODE_SHAPE_POINT_TYPE
VIEW_NODE_SHAPE_SWATCH
VIEW_NODE_VALUE_TYPE
VIEW_NODE_VARIABLE_TYPE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
node
-
types
.
js
"
)
;
const
INSET_POINT_TYPES
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
function
getRuleFromNode
(
node
elementStyle
)
{
const
ruleEl
=
node
.
closest
(
"
.
ruleview
-
rule
[
data
-
rule
-
id
]
"
)
;
const
ruleId
=
ruleEl
?
ruleEl
.
dataset
.
ruleId
:
null
;
return
ruleId
?
elementStyle
.
getRule
(
ruleId
)
:
null
;
}
function
getDeclarationFromNode
(
node
rule
)
{
if
(
!
rule
)
{
return
null
;
}
const
declarationEl
=
node
.
closest
(
"
.
ruleview
-
property
[
data
-
declaration
-
id
]
"
)
;
const
declarationId
=
declarationEl
?
declarationEl
.
dataset
.
declarationId
:
null
;
return
rule
?
rule
.
getDeclaration
(
declarationId
)
:
null
;
}
function
getNodeInfo
(
node
elementStyle
)
{
if
(
!
node
)
{
return
null
;
}
const
rule
=
getRuleFromNode
(
node
elementStyle
)
;
const
declaration
=
getDeclarationFromNode
(
node
rule
)
;
const
classList
=
node
.
classList
;
let
type
value
;
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
propertyname
"
)
)
{
type
=
VIEW_NODE_PROPERTY_TYPE
;
value
=
{
property
:
node
.
textContent
value
:
getPropertyNameAndValue
(
node
)
.
value
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
}
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
propertyvalue
"
)
)
{
type
=
VIEW_NODE_VALUE_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
}
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
font
-
family
"
)
)
{
const
{
name
:
propertyName
value
:
propertyValue
}
=
getPropertyNameAndValue
(
node
)
;
type
=
VIEW_NODE_FONT_TYPE
;
value
=
{
property
:
propertyName
value
:
propertyValue
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
}
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
shape
-
point
"
)
)
{
type
=
VIEW_NODE_SHAPE_POINT_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
toggleActive
:
getShapeToggleActive
(
node
)
point
:
getShapePoint
(
node
)
}
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
unused
-
warning
"
)
)
{
type
=
VIEW_NODE_INACTIVE_CSS
;
value
=
declaration
.
isUsed
(
)
;
}
else
if
(
node
.
closest
(
"
.
container
-
query
-
declaration
"
)
)
{
type
=
VIEW_NODE_CSS_QUERY_CONTAINER
;
const
containerQueryEl
=
node
.
closest
(
"
.
container
-
query
"
)
;
value
=
{
ancestorIndex
:
containerQueryEl
.
getAttribute
(
"
data
-
ancestor
-
index
"
)
rule
}
;
}
else
if
(
node
.
classList
.
contains
(
"
ruleview
-
selector
-
warnings
"
)
)
{
type
=
VIEW_NODE_CSS_SELECTOR_WARNINGS
;
value
=
node
.
getAttribute
(
"
data
-
selector
-
warning
-
kind
"
)
.
split
(
"
"
)
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
ruleview
-
shapeswatch
"
)
)
{
type
=
VIEW_NODE_SHAPE_SWATCH
;
value
=
{
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
textProperty
:
declaration
}
;
}
else
if
(
declaration
&
&
(
classList
.
contains
(
"
ruleview
-
variable
"
)
|
|
classList
.
contains
(
"
ruleview
-
unmatched
"
)
)
)
{
type
=
VIEW_NODE_VARIABLE_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
textContent
.
trim
(
)
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
variable
:
node
.
dataset
.
variable
variableComputed
:
node
.
dataset
.
variableComputed
startingStyleVariable
:
node
.
dataset
.
startingStyleVariable
registeredProperty
:
{
initialValue
:
node
.
dataset
.
registeredPropertyInitialValue
syntax
:
node
.
dataset
.
registeredPropertySyntax
inherits
:
node
.
dataset
.
registeredPropertyInherits
}
outputParserOptions
:
declaration
.
editor
.
outputParserOptions
cssProperties
:
declaration
.
editor
.
ruleView
.
cssProperties
}
;
}
else
if
(
declaration
&
&
classList
.
contains
(
"
theme
-
link
"
)
&
&
!
classList
.
contains
(
"
ruleview
-
rule
-
source
"
)
)
{
type
=
VIEW_NODE_IMAGE_URL_TYPE
;
value
=
{
property
:
getPropertyNameAndValue
(
node
)
.
name
value
:
node
.
parentNode
.
textContent
url
:
node
.
href
enabled
:
declaration
.
enabled
overridden
:
declaration
.
overridden
pseudoElement
:
rule
.
pseudoElement
sheetHref
:
rule
.
domRule
.
href
textProperty
:
declaration
}
;
}
else
if
(
classList
.
contains
(
"
ruleview
-
selectors
-
container
"
)
|
|
classList
.
contains
(
"
ruleview
-
selector
"
)
|
|
classList
.
contains
(
"
ruleview
-
selector
-
element
"
)
|
|
classList
.
contains
(
"
ruleview
-
selector
-
attribute
"
)
|
|
classList
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
"
)
|
|
classList
.
contains
(
"
ruleview
-
selector
-
pseudo
-
class
-
lock
"
)
)
{
type
=
VIEW_NODE_SELECTOR_TYPE
;
value
=
rule
.
selectorText
;
}
else
if
(
classList
.
contains
(
"
ruleview
-
rule
-
source
"
)
|
|
classList
.
contains
(
"
ruleview
-
rule
-
source
-
label
"
)
)
{
type
=
VIEW_NODE_LOCATION_TYPE
;
const
sourceLabelEl
=
classList
.
contains
(
"
ruleview
-
rule
-
source
-
label
"
)
?
node
:
node
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
;
value
=
sourceLabelEl
.
getAttribute
(
"
href
"
)
|
|
rule
.
sheet
?
.
href
|
|
rule
.
title
;
}
else
{
return
null
;
}
return
{
rule
type
value
view
:
"
rule
"
}
;
}
function
getPropertyNameAndValue
(
node
)
{
while
(
node
?
.
classList
)
{
if
(
node
.
classList
.
contains
(
"
ruleview
-
computed
"
)
|
|
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
{
name
:
node
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
.
textContent
value
:
node
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
.
textContent
}
;
}
node
=
node
.
parentNode
;
}
return
null
;
}
function
getShapeToggleActive
(
node
)
{
while
(
node
?
.
classList
)
{
if
(
node
.
classList
.
contains
(
"
ruleview
-
computed
"
)
|
|
node
.
classList
.
contains
(
"
ruleview
-
property
"
)
)
{
return
node
.
querySelector
(
.
ruleview
-
shapeswatch
[
aria
-
pressed
=
"
true
"
]
)
;
}
node
=
node
.
parentNode
;
}
return
null
;
}
function
getShapePoint
(
node
)
{
const
classList
=
node
.
classList
;
let
point
=
node
.
dataset
.
point
;
const
insetClasses
=
[
]
;
classList
.
forEach
(
className
=
>
{
if
(
INSET_POINT_TYPES
.
includes
(
className
)
)
{
insetClasses
.
push
(
className
)
;
}
}
)
;
if
(
insetClasses
.
length
)
{
point
=
insetClasses
.
join
(
"
"
)
;
}
return
point
;
}
function
getCSSVariables
(
propertyValue
=
"
"
)
{
const
variables
=
[
]
;
const
parts
=
propertyValue
.
split
(
/
var
\
(
\
s
*
-
-
/
)
;
if
(
parts
.
length
)
{
for
(
let
i
=
1
;
i
<
parts
.
length
;
i
+
+
)
{
const
variable
=
parts
[
i
]
.
split
(
/
[
)
\
s
+
]
/
)
.
shift
(
)
;
if
(
variable
)
{
variables
.
push
(
-
-
{
variable
}
)
;
}
}
}
return
variables
;
}
async
function
getNodeCompatibilityInfo
(
node
elementStyle
)
{
const
rule
=
getRuleFromNode
(
node
elementStyle
)
;
const
declaration
=
getDeclarationFromNode
(
node
rule
)
;
const
issue
=
await
declaration
.
isCompatible
(
)
;
return
issue
;
}
function
hasCSSVariable
(
propertyValue
variableName
)
{
return
getCSSVariables
(
propertyValue
)
.
includes
(
variableName
)
;
}
module
.
exports
=
{
getCSSVariables
getNodeInfo
getRuleFromNode
hasCSSVariable
getNodeCompatibilityInfo
}
;
