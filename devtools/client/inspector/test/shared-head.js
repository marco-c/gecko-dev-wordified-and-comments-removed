"
use
strict
"
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
var
openInspector
=
async
function
(
hostType
)
{
info
(
"
Opening
the
inspector
"
)
;
const
toolbox
=
await
openToolboxForTab
(
gBrowser
.
selectedTab
"
inspector
"
hostType
)
;
const
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
const
highlighterTestFront
=
await
getHighlighterTestFront
(
toolbox
)
;
return
{
toolbox
inspector
highlighterTestFront
}
;
}
;
var
openInspectorSidebarTab
=
async
function
(
id
)
{
const
{
toolbox
inspector
highlighterTestFront
}
=
await
openInspector
(
)
;
info
(
"
Selecting
the
"
+
id
+
"
sidebar
"
)
;
const
onSidebarSelect
=
inspector
.
sidebar
.
once
(
"
select
"
)
;
if
(
id
=
=
=
"
layoutview
"
)
{
const
onBoxModelViewReady
=
inspector
.
once
(
"
boxmodel
-
view
-
updated
"
)
;
const
onGridPanelReady
=
inspector
.
once
(
"
grid
-
panel
-
updated
"
)
;
inspector
.
sidebar
.
select
(
id
)
;
await
onBoxModelViewReady
;
await
onGridPanelReady
;
}
else
{
inspector
.
sidebar
.
select
(
id
)
;
}
await
onSidebarSelect
;
return
{
toolbox
inspector
highlighterTestFront
}
;
}
;
async
function
openRuleView
(
)
{
const
{
inspector
toolbox
highlighterTestFront
}
=
await
openInspector
(
)
;
const
ruleViewPanel
=
inspector
.
getPanel
(
"
ruleview
"
)
;
await
ruleViewPanel
.
readyPromise
;
const
view
=
ruleViewPanel
.
view
;
view
.
debounce
=
manualDebounce
(
)
;
return
{
toolbox
inspector
highlighterTestFront
view
}
;
}
function
openComputedView
(
)
{
return
openInspectorSidebarTab
(
"
computedview
"
)
.
then
(
data
=
>
{
const
view
=
data
.
inspector
.
getPanel
(
"
computedview
"
)
.
computedView
;
return
{
toolbox
:
data
.
toolbox
inspector
:
data
.
inspector
highlighterTestFront
:
data
.
highlighterTestFront
view
}
;
}
)
;
}
function
openChangesView
(
)
{
return
openInspectorSidebarTab
(
"
changesview
"
)
.
then
(
data
=
>
{
return
{
toolbox
:
data
.
toolbox
inspector
:
data
.
inspector
highlighterTestFront
:
data
.
highlighterTestFront
view
:
data
.
inspector
.
getPanel
(
"
changesview
"
)
}
;
}
)
;
}
function
openLayoutView
(
)
{
return
openInspectorSidebarTab
(
"
layoutview
"
)
.
then
(
data
=
>
{
return
{
toolbox
:
data
.
toolbox
inspector
:
data
.
inspector
boxmodel
:
data
.
inspector
.
getPanel
(
"
boxmodel
"
)
gridInspector
:
data
.
inspector
.
getPanel
(
"
layoutview
"
)
.
gridInspector
flexboxInspector
:
data
.
inspector
.
getPanel
(
"
layoutview
"
)
.
flexboxInspector
layoutView
:
data
.
inspector
.
getPanel
(
"
layoutview
"
)
highlighterTestFront
:
data
.
highlighterTestFront
}
;
}
)
;
}
function
selectRuleView
(
inspector
)
{
return
inspector
.
getPanel
(
"
ruleview
"
)
.
view
;
}
function
selectComputedView
(
inspector
)
{
inspector
.
sidebar
.
select
(
"
computedview
"
)
;
return
inspector
.
getPanel
(
"
computedview
"
)
.
computedView
;
}
function
selectChangesView
(
inspector
)
{
inspector
.
sidebar
.
select
(
"
changesview
"
)
;
return
inspector
.
getPanel
(
"
changesview
"
)
;
}
function
selectLayoutView
(
inspector
)
{
inspector
.
sidebar
.
select
(
"
layoutview
"
)
;
return
inspector
.
getPanel
(
"
boxmodel
"
)
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
if
(
selector
.
_form
)
{
return
selector
;
}
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
selectNode
=
async
function
(
selector
inspector
reason
=
"
test
"
isSlotted
)
{
info
(
"
Selecting
the
node
for
'
"
+
selector
+
"
'
"
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
{
ELEMENT_NODE
}
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
onSelectionCssSelectorsUpdated
=
nodeFront
?
.
nodeType
=
=
ELEMENT_NODE
?
inspector
.
once
(
"
selection
-
css
-
selectors
-
updated
"
)
:
null
;
inspector
.
selection
.
setNodeFront
(
nodeFront
{
reason
isSlotted
}
)
;
await
updated
;
await
onSelectionCssSelectorsUpdated
;
}
;
async
function
getNodeFrontInFrames
(
selectors
inspector
)
{
let
walker
=
inspector
.
walker
;
let
rootNode
=
walker
.
rootNode
;
selectors
=
[
.
.
.
selectors
]
;
const
nodeSelector
=
selectors
.
pop
(
)
;
const
frameSelectors
=
selectors
;
info
(
"
Loop
through
all
frame
selectors
"
)
;
for
(
const
frameSelector
of
frameSelectors
)
{
const
url
=
walker
.
targetFront
.
url
;
info
(
Find
the
frame
element
for
selector
{
frameSelector
}
in
{
url
}
)
;
const
frameNodeFront
=
await
walker
.
querySelector
(
rootNode
frameSelector
)
;
let
frameTarget
=
frameNodeFront
.
targetFront
;
if
(
frameNodeFront
.
useChildTargetToFetchChildren
)
{
info
(
"
Connect
to
frame
and
retrieve
the
targetFront
"
)
;
frameTarget
=
await
frameNodeFront
.
connectToFrame
(
)
;
}
walker
=
(
await
frameTarget
.
getFront
(
"
inspector
"
)
)
.
walker
;
if
(
frameNodeFront
.
useChildTargetToFetchChildren
)
{
rootNode
=
walker
.
rootNode
;
}
else
{
info
(
"
Retrieve
the
children
of
the
frame
to
find
the
document
node
"
)
;
const
{
nodes
}
=
await
walker
.
children
(
frameNodeFront
)
;
rootNode
=
nodes
.
find
(
n
=
>
n
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
;
}
}
return
walker
.
querySelector
(
rootNode
nodeSelector
)
;
}
async
function
selectNodeInFrames
(
selectors
inspector
reason
=
"
test
"
isSlotted
)
{
const
nodeFront
=
await
getNodeFrontInFrames
(
selectors
inspector
)
;
await
selectNode
(
nodeFront
inspector
reason
isSlotted
)
;
return
nodeFront
;
}
function
manualDebounce
(
)
{
let
calls
=
[
]
;
function
debounce
(
func
wait
scope
)
{
return
function
(
)
{
const
existingCall
=
calls
.
find
(
call
=
>
call
.
func
=
=
=
func
)
;
if
(
existingCall
)
{
existingCall
.
args
=
arguments
;
}
else
{
calls
.
push
(
{
func
wait
scope
args
:
arguments
}
)
;
}
}
;
}
debounce
.
flush
=
function
(
)
{
calls
.
forEach
(
(
{
func
scope
args
}
)
=
>
func
.
apply
(
scope
args
)
)
;
calls
=
[
]
;
}
;
return
debounce
;
}
async
function
getRulePropertyValue
(
styleSheetIndex
ruleIndex
name
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
styleSheetIndex
ruleIndex
name
]
(
styleSheetIndexChild
ruleIndexChild
nameChild
)
=
>
{
let
value
=
null
;
info
(
"
Getting
the
value
for
property
name
"
+
nameChild
+
"
in
sheet
"
+
styleSheetIndexChild
+
"
and
rule
"
+
ruleIndexChild
)
;
const
sheet
=
content
.
document
.
styleSheets
[
styleSheetIndexChild
]
;
if
(
sheet
)
{
const
rule
=
sheet
.
cssRules
[
ruleIndexChild
]
;
if
(
rule
)
{
value
=
rule
.
style
.
getPropertyValue
(
nameChild
)
;
}
}
return
value
;
}
)
;
}
async
function
getComputedStyleProperty
(
selector
pseudo
propName
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
pseudo
propName
]
(
selectorChild
pseudoChild
propNameChild
)
=
>
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
return
content
.
document
.
defaultView
.
getComputedStyle
(
element
pseudoChild
)
.
getPropertyValue
(
propNameChild
)
;
}
)
;
}
async
function
waitForComputedStyleProperty
(
selector
pseudo
propName
expected
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
pseudo
propName
expected
]
(
selectorChild
pseudoChild
propNameChild
expectedChild
)
=
>
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
return
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
value
=
content
.
document
.
defaultView
.
getComputedStyle
(
element
pseudoChild
)
.
getPropertyValue
(
propNameChild
)
;
return
value
=
=
=
expectedChild
;
}
)
;
}
)
;
}
var
focusEditableField
=
async
function
(
ruleView
editable
xOffset
=
1
yOffset
=
1
options
=
{
}
)
{
const
onFocus
=
once
(
editable
.
parentNode
"
focus
"
true
)
;
info
(
"
Clicking
on
editable
field
to
turn
to
edit
mode
"
)
;
if
(
options
.
type
=
=
=
undefined
)
{
options
.
type
=
"
mousedown
"
;
EventUtils
.
synthesizeMouse
(
editable
xOffset
yOffset
options
editable
.
ownerGlobal
)
;
options
.
type
=
"
mouseup
"
;
EventUtils
.
synthesizeMouse
(
editable
xOffset
yOffset
options
editable
.
ownerGlobal
)
;
}
else
{
EventUtils
.
synthesizeMouse
(
editable
xOffset
yOffset
options
editable
.
ownerGlobal
)
;
}
await
onFocus
;
info
(
"
Editable
field
gained
focus
returning
the
input
field
now
"
)
;
const
onEdit
=
inplaceEditor
(
editable
.
ownerDocument
.
activeElement
)
;
return
onEdit
;
}
;
function
getRuleViewRule
(
view
selectorText
index
=
0
)
{
let
rule
;
let
pos
=
0
;
for
(
const
r
of
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
"
)
)
{
const
selector
=
r
.
querySelector
(
"
.
ruleview
-
selectorcontainer
"
+
"
.
ruleview
-
selector
-
matched
"
)
;
if
(
selector
&
&
selector
.
textContent
=
=
=
selectorText
)
{
if
(
index
=
=
pos
)
{
rule
=
r
;
break
;
}
pos
+
+
;
}
}
return
rule
;
}
function
getRuleViewProperty
(
view
selectorText
propertyName
options
=
{
}
)
{
if
(
options
.
wait
)
{
return
waitFor
(
(
)
=
>
_syncGetRuleViewProperty
(
view
selectorText
propertyName
)
)
;
}
return
_syncGetRuleViewProperty
(
view
selectorText
propertyName
)
;
}
function
_syncGetRuleViewProperty
(
view
selectorText
propertyName
)
{
const
rule
=
getRuleViewRule
(
view
selectorText
)
;
if
(
!
rule
)
{
return
null
;
}
for
(
const
p
of
rule
.
querySelectorAll
(
"
.
ruleview
-
property
"
)
)
{
const
nameSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
;
const
valueSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
;
if
(
nameSpan
.
textContent
=
=
=
propertyName
)
{
return
{
nameSpan
valueSpan
}
;
}
}
return
null
;
}
function
getRuleViewPropertyValue
(
view
selectorText
propertyName
)
{
return
getRuleViewProperty
(
view
selectorText
propertyName
)
.
valueSpan
.
textContent
;
}
function
getRuleViewSelector
(
view
selectorText
)
{
const
rule
=
getRuleViewRule
(
view
selectorText
)
;
return
rule
.
querySelector
(
"
.
ruleview
-
selector
.
ruleview
-
selector
-
matched
"
)
;
}
function
getRuleViewLinkByIndex
(
view
index
)
{
const
links
=
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
-
source
"
)
;
return
links
[
index
]
;
}
function
getRuleViewLinkTextByIndex
(
view
index
)
{
const
link
=
getRuleViewLinkByIndex
(
view
index
)
;
return
link
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
.
textContent
;
}
var
focusNewRuleViewProperty
=
async
function
(
ruleEditor
)
{
info
(
"
Clicking
on
a
close
ruleEditor
brace
to
start
editing
a
new
property
"
)
;
ruleEditor
.
closeBrace
.
scrollIntoView
(
false
)
;
const
editor
=
await
focusEditableField
(
ruleEditor
.
ruleView
ruleEditor
.
closeBrace
)
;
is
(
inplaceEditor
(
ruleEditor
.
newPropSpan
)
editor
"
Focused
editor
is
the
new
property
editor
.
"
)
;
return
editor
;
}
;
var
createNewRuleViewProperty
=
async
function
(
ruleEditor
inputValue
)
{
info
(
"
Creating
a
new
property
editor
"
)
;
const
editor
=
await
focusNewRuleViewProperty
(
ruleEditor
)
;
info
(
"
Entering
the
value
"
+
inputValue
)
;
editor
.
input
.
value
=
inputValue
;
info
(
"
Submitting
the
new
value
and
waiting
for
value
field
focus
"
)
;
const
onFocus
=
once
(
ruleEditor
.
element
"
focus
"
true
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
ruleEditor
.
element
.
ownerDocument
.
defaultView
)
;
await
onFocus
;
}
;
var
setSearchFilter
=
async
function
(
view
searchValue
)
{
info
(
'
Setting
filter
text
to
"
'
+
searchValue
+
'
"
'
)
;
const
searchField
=
view
.
searchField
;
searchField
.
focus
(
)
;
for
(
const
key
of
searchValue
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
view
.
styleWindow
)
;
}
await
view
.
inspector
.
once
(
"
ruleview
-
filtered
"
)
;
}
;
function
buildContextMenuItems
(
menu
)
{
const
allItems
=
[
]
.
concat
.
apply
(
[
]
menu
.
items
.
map
(
function
addItem
(
item
)
{
if
(
item
.
submenu
)
{
return
addItem
(
item
.
submenu
.
items
)
;
}
return
item
;
}
)
)
;
return
allItems
;
}
function
openStyleContextMenuAndGetAllItems
(
view
target
)
{
const
menu
=
view
.
contextMenu
.
_openMenu
(
{
target
}
)
;
return
buildContextMenuItems
(
menu
)
;
}
function
openContextMenuAndGetAllItems
(
inspector
options
)
{
const
menu
=
inspector
.
markup
.
contextMenu
.
_openMenu
(
options
)
;
return
buildContextMenuItems
(
menu
)
;
}
async
function
waitUntilVisitedState
(
tab
selectors
)
{
await
asyncWaitUntil
(
async
(
)
=
>
{
const
hasVisitedState
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
selectors
args
=
>
{
const
ELEMENT_STATE_VISITED
=
1
<
<
19
;
for
(
const
selector
of
args
)
{
const
target
=
content
.
wrappedJSObject
.
document
.
querySelector
(
selector
)
;
if
(
!
(
target
&
&
InspectorUtils
.
getContentState
(
target
)
&
ELEMENT_STATE_VISITED
)
)
{
return
false
;
}
}
return
true
;
}
)
;
return
hasVisitedState
;
}
)
;
}
function
hasMatchingElementInContentPage
(
selector
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
function
(
innerSelector
)
{
return
content
.
document
.
querySelector
(
innerSelector
)
!
=
=
null
;
}
)
;
}
function
getNumberOfMatchingElementsInContentPage
(
selector
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
function
(
innerSelector
)
{
return
content
.
document
.
querySelectorAll
(
innerSelector
)
.
length
;
}
)
;
}
function
getContentPageElementProperty
(
selector
propertyName
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
propertyName
]
function
(
innerSelector
innerPropertyName
)
{
return
content
.
document
.
querySelector
(
innerSelector
)
[
innerPropertyName
]
;
}
)
;
}
function
setContentPageElementProperty
(
selector
propertyName
propertyValue
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
propertyName
propertyValue
]
function
(
innerSelector
innerPropertyName
innerPropertyValue
)
{
content
.
document
.
querySelector
(
innerSelector
)
[
innerPropertyName
]
=
innerPropertyValue
;
}
)
;
}
async
function
getContentPageElementAttributes
(
selector
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
_selector
=
>
{
const
node
=
content
.
document
.
querySelector
(
_selector
)
;
return
Array
.
from
(
node
.
attributes
)
.
map
(
(
{
name
value
}
)
=
>
(
{
name
value
}
)
)
;
}
)
;
}
async
function
getContentPageElementAttribute
(
selector
attribute
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
attribute
]
(
_selector
_attribute
)
=
>
{
return
content
.
document
.
querySelector
(
_selector
)
.
getAttribute
(
_attribute
)
;
}
)
;
}
async
function
setContentPageElementAttribute
(
selector
attribute
value
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
attribute
value
]
(
_selector
_attribute
_value
)
=
>
{
content
.
document
.
querySelector
(
_selector
)
.
setAttribute
(
_attribute
_value
)
;
}
)
;
}
async
function
removeContentPageElementAttribute
(
selector
attribute
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
attribute
]
(
_selector
_attribute
)
=
>
{
content
.
document
.
querySelector
(
_selector
)
.
removeAttribute
(
_attribute
)
;
}
)
;
}
