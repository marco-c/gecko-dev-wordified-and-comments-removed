"
use
strict
"
;
var
openInspector
=
Task
.
async
(
function
*
(
hostType
)
{
info
(
"
Opening
the
inspector
"
)
;
let
toolbox
=
yield
openToolboxForTab
(
gBrowser
.
selectedTab
"
inspector
"
hostType
)
;
let
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
if
(
inspector
.
_updateProgress
)
{
info
(
"
Need
to
wait
for
the
inspector
to
update
"
)
;
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
info
(
"
Waiting
for
actor
features
to
be
detected
"
)
;
yield
inspector
.
_detectingActorFeatures
;
yield
registerTestActor
(
toolbox
.
target
.
client
)
;
let
testActor
=
yield
getTestActor
(
toolbox
)
;
return
{
toolbox
inspector
testActor
}
;
}
)
;
var
openInspectorSidebarTab
=
Task
.
async
(
function
*
(
id
)
{
let
{
toolbox
inspector
testActor
}
=
yield
openInspector
(
)
;
info
(
"
Selecting
the
"
+
id
+
"
sidebar
"
)
;
inspector
.
sidebar
.
select
(
id
)
;
return
{
toolbox
inspector
testActor
}
;
}
)
;
function
openRuleView
(
)
{
return
openInspectorSidebarTab
(
"
ruleview
"
)
.
then
(
data
=
>
{
data
.
inspector
.
ruleview
.
view
.
throttle
=
manualThrottle
(
)
;
return
{
toolbox
:
data
.
toolbox
inspector
:
data
.
inspector
testActor
:
data
.
testActor
view
:
data
.
inspector
.
ruleview
.
view
}
;
}
)
;
}
function
openComputedView
(
)
{
return
openInspectorSidebarTab
(
"
computedview
"
)
.
then
(
data
=
>
{
return
{
toolbox
:
data
.
toolbox
inspector
:
data
.
inspector
testActor
:
data
.
testActor
view
:
data
.
inspector
.
computedview
.
computedView
}
;
}
)
;
}
function
selectRuleView
(
inspector
)
{
inspector
.
sidebar
.
select
(
"
ruleview
"
)
;
return
inspector
.
ruleview
.
view
;
}
function
selectComputedView
(
inspector
)
{
inspector
.
sidebar
.
select
(
"
computedview
"
)
;
return
inspector
.
computedview
.
computedView
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
if
(
selector
.
_form
)
{
return
selector
;
}
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
selectNode
=
Task
.
async
(
function
*
(
selector
inspector
reason
=
"
test
"
)
{
info
(
"
Selecting
the
node
for
'
"
+
selector
+
"
'
"
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
reason
)
;
yield
updated
;
}
)
;
function
manualThrottle
(
)
{
let
calls
=
[
]
;
function
throttle
(
func
wait
scope
)
{
return
function
(
)
{
let
existingCall
=
calls
.
find
(
call
=
>
call
.
func
=
=
=
func
)
;
if
(
existingCall
)
{
existingCall
.
args
=
arguments
;
}
else
{
calls
.
push
(
{
func
wait
scope
args
:
arguments
}
)
;
}
}
;
}
throttle
.
flush
=
function
(
)
{
calls
.
forEach
(
(
{
func
scope
args
}
)
=
>
func
.
apply
(
scope
args
)
)
;
calls
=
[
]
;
}
;
return
throttle
;
}
