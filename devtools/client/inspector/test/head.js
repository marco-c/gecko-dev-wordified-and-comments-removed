"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
commandline
/
test
/
helpers
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
test
-
actor
-
registry
.
js
"
this
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
}
)
;
registerCleanupFunction
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
EventUtils
.
synthesizeMouseAtPoint
(
1
1
{
type
:
"
mousemove
"
}
window
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
var
navigateTo
=
function
(
toolbox
url
)
{
let
activeTab
=
toolbox
.
target
.
activeTab
;
return
activeTab
.
navigateTo
(
url
)
;
}
;
function
getNode
(
nodeOrSelector
options
=
{
}
)
{
let
document
=
options
.
document
|
|
content
.
document
;
let
noMatches
=
!
!
options
.
expectNoMatch
;
if
(
typeof
nodeOrSelector
=
=
=
"
string
"
)
{
info
(
"
Looking
for
a
node
that
matches
selector
"
+
nodeOrSelector
)
;
let
node
=
document
.
querySelector
(
nodeOrSelector
)
;
if
(
noMatches
)
{
ok
(
!
node
"
Selector
"
+
nodeOrSelector
+
"
didn
'
t
match
any
nodes
.
"
)
;
}
else
{
ok
(
node
"
Selector
"
+
nodeOrSelector
+
"
matched
a
node
.
"
)
;
}
return
node
;
}
info
(
"
Looking
for
a
node
but
selector
was
not
a
string
.
"
)
;
return
nodeOrSelector
;
}
var
startPicker
=
Task
.
async
(
function
*
(
toolbox
)
{
info
(
"
Start
the
element
picker
"
)
;
yield
toolbox
.
highlighterUtils
.
startPicker
(
)
;
yield
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
function
*
(
)
{
content
.
focus
(
)
;
}
)
;
}
)
;
function
selectAndHighlightNode
(
selector
inspector
)
{
info
(
"
Highlighting
and
selecting
the
node
"
+
selector
)
;
return
selectNode
(
selector
inspector
"
test
-
highlight
"
)
;
}
var
selectNode
=
Task
.
async
(
function
*
(
selector
inspector
reason
=
"
test
"
)
{
info
(
"
Selecting
the
node
for
'
"
+
selector
+
"
'
"
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
reason
)
;
yield
updated
;
}
)
;
var
openInspectorForURL
=
Task
.
async
(
function
*
(
url
hostType
)
{
let
tab
=
yield
addTab
(
url
)
;
let
{
inspector
toolbox
testActor
}
=
yield
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
testActor
}
;
}
)
;
var
openInspector
=
Task
.
async
(
function
*
(
hostType
)
{
info
(
"
Opening
the
inspector
"
)
;
let
toolbox
=
yield
openToolboxForTab
(
gBrowser
.
selectedTab
"
inspector
"
hostType
)
;
let
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
info
(
"
Waiting
for
the
inspector
to
update
"
)
;
if
(
inspector
.
_updateProgress
)
{
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
yield
registerTestActor
(
toolbox
.
target
.
client
)
;
let
testActor
=
yield
getTestActor
(
toolbox
)
;
return
{
toolbox
inspector
testActor
}
;
}
)
;
function
getActiveInspector
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
getToolbox
(
target
)
.
getPanel
(
"
inspector
"
)
;
}
var
openInspectorSidebarTab
=
Task
.
async
(
function
*
(
id
hostType
)
{
let
{
toolbox
inspector
testActor
}
=
yield
openInspector
(
)
;
info
(
"
Selecting
the
"
+
id
+
"
sidebar
"
)
;
inspector
.
sidebar
.
select
(
id
)
;
return
{
toolbox
inspector
testActor
}
;
}
)
;
function
getNodeFront
(
selector
{
walker
}
)
{
if
(
selector
.
_form
)
{
return
selector
;
}
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
getNodeFrontInFrame
=
Task
.
async
(
function
*
(
selector
frameSelector
inspector
reason
=
"
test
"
)
{
let
iframe
=
yield
getNodeFront
(
frameSelector
inspector
)
;
let
{
nodes
}
=
yield
inspector
.
walker
.
children
(
iframe
)
;
return
inspector
.
walker
.
querySelector
(
nodes
[
0
]
selector
)
;
}
)
;
var
focusSearchBoxUsingShortcut
=
Task
.
async
(
function
*
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
let
searchBox
=
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
let
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
synthesizeKeyFromKeyTag
(
panelWin
.
document
.
getElementById
(
"
nodeSearchKey
"
)
)
;
yield
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
)
;
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
info
(
"
Found
markup
-
container
"
+
container
)
;
return
container
;
}
)
;
var
hoverContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Hovering
over
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
highlit
=
inspector
.
toolbox
.
once
(
"
node
-
highlight
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousemove
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
highlit
;
}
)
;
var
clickContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
)
;
function
mouseLeaveMarkupView
(
inspector
)
{
info
(
"
Leaving
the
markup
-
view
area
"
)
;
let
def
=
promise
.
defer
(
)
;
let
btn
=
inspector
.
toolbox
.
doc
.
querySelector
(
"
#
toolbox
-
controls
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
btn
{
type
:
"
mousemove
"
}
inspector
.
toolbox
.
doc
.
defaultView
)
;
executeSoon
(
def
.
resolve
)
;
return
def
.
promise
;
}
function
fireCopyEvent
(
element
)
{
let
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
undoChange
(
inspector
)
{
let
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
let
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
function
dispatchCommandEvent
(
node
)
{
info
(
"
Dispatching
command
event
on
"
+
node
)
;
let
commandEvent
=
document
.
createEvent
(
"
XULCommandEvent
"
)
;
commandEvent
.
initCommandEvent
(
"
command
"
true
true
window
0
false
false
false
false
null
)
;
node
.
dispatchEvent
(
commandEvent
)
;
}
function
contextMenuClick
(
element
)
{
let
evt
=
element
.
ownerDocument
.
createEvent
(
'
MouseEvents
'
)
;
let
button
=
2
;
evt
.
initMouseEvent
(
'
contextmenu
'
true
true
element
.
ownerDocument
.
defaultView
1
0
0
0
0
false
false
false
false
button
null
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
*
getNodeFrontForSelector
(
selector
inspector
)
{
if
(
selector
)
{
info
(
"
Retrieving
front
for
selector
"
+
selector
)
;
return
getNodeFront
(
selector
inspector
)
;
}
else
{
info
(
"
Retrieving
front
for
doctype
node
"
)
;
let
{
nodes
}
=
yield
inspector
.
walker
.
children
(
inspector
.
walker
.
rootNode
)
;
return
nodes
[
0
]
;
}
}
const
getHighlighterHelperFor
=
(
type
)
=
>
Task
.
async
(
function
*
(
{
inspector
testActor
}
)
{
let
front
=
inspector
.
inspector
;
let
highlighter
=
yield
front
.
getHighlighterByType
(
type
)
;
let
prefix
=
"
"
;
return
{
set
prefix
(
value
)
{
prefix
=
value
;
}
show
:
function
*
(
selector
=
"
:
root
"
)
{
let
node
=
yield
getNodeFront
(
selector
inspector
)
;
yield
highlighter
.
show
(
node
)
;
}
isElementHidden
:
function
*
(
id
)
{
return
(
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
"
hidden
"
highlighter
)
)
=
=
=
"
true
"
;
}
getElementTextContent
:
function
*
(
id
)
{
return
yield
testActor
.
getHighlighterNodeTextContent
(
prefix
+
id
highlighter
)
;
}
getElementAttribute
:
function
*
(
id
name
)
{
return
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
}
synthesizeMouse
:
function
*
(
options
)
{
yield
testActor
.
synthesizeMouse
(
options
)
;
}
finalize
:
function
*
(
)
{
yield
highlighter
.
finalize
(
)
;
}
}
;
}
)
;
function
*
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
yield
waitForChildrenUpdated
(
inspector
)
;
return
yield
waitForMultipleChildrenUpdates
(
inspector
)
;
}
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
let
def
=
promise
.
defer
(
)
;
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
def
.
resolve
)
;
}
)
;
return
def
.
promise
;
}
function
waitForStyleEditor
(
toolbox
href
)
{
let
def
=
promise
.
defer
(
)
;
info
(
"
Waiting
for
the
toolbox
to
switch
to
the
styleeditor
"
)
;
toolbox
.
once
(
"
styleeditor
-
selected
"
)
.
then
(
(
)
=
>
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
ok
(
panel
&
&
panel
.
UI
"
Styleeditor
panel
switched
to
front
"
)
;
let
gotEditor
=
(
event
editor
)
=
>
{
let
currentHref
=
editor
.
styleSheet
.
href
;
if
(
!
href
|
|
(
href
&
&
currentHref
.
endsWith
(
href
)
)
)
{
info
(
"
Stylesheet
editor
selected
"
)
;
panel
.
UI
.
off
(
"
editor
-
selected
"
gotEditor
)
;
editor
.
getSourceEditor
(
)
.
then
(
sourceEditor
=
>
{
info
(
"
Stylesheet
editor
fully
loaded
"
)
;
def
.
resolve
(
sourceEditor
)
;
}
)
;
return
true
;
}
info
(
"
The
editor
was
incorrect
.
Waiting
for
editor
-
selected
event
.
"
)
;
return
false
;
}
;
if
(
!
gotEditor
(
"
styleeditor
-
selected
"
panel
.
UI
.
selectedEditor
)
)
{
panel
.
UI
.
on
(
"
editor
-
selected
"
gotEditor
)
;
}
}
)
;
return
def
.
promise
;
}
function
waitForClipboard
(
setup
expected
)
{
let
def
=
promise
.
defer
(
)
;
SimpleTest
.
waitForClipboard
(
expected
setup
def
.
resolve
def
.
reject
)
;
return
def
.
promise
;
}
