"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
commandline
/
test
/
helpers
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
test
-
actor
-
registry
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
locale
/
inspector
.
properties
"
)
;
flags
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
}
)
;
registerCleanupFunction
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
EventUtils
.
synthesizeMouseAtPoint
(
1
1
{
type
:
"
mousemove
"
}
window
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
var
navigateTo
=
function
(
toolbox
url
)
{
let
activeTab
=
toolbox
.
target
.
activeTab
;
return
activeTab
.
navigateTo
(
url
)
;
}
;
function
getNode
(
nodeOrSelector
options
=
{
}
)
{
let
document
=
options
.
document
|
|
content
.
document
;
let
noMatches
=
!
!
options
.
expectNoMatch
;
if
(
typeof
nodeOrSelector
=
=
=
"
string
"
)
{
info
(
"
Looking
for
a
node
that
matches
selector
"
+
nodeOrSelector
)
;
let
node
=
document
.
querySelector
(
nodeOrSelector
)
;
if
(
noMatches
)
{
ok
(
!
node
"
Selector
"
+
nodeOrSelector
+
"
didn
'
t
match
any
nodes
.
"
)
;
}
else
{
ok
(
node
"
Selector
"
+
nodeOrSelector
+
"
matched
a
node
.
"
)
;
}
return
node
;
}
info
(
"
Looking
for
a
node
but
selector
was
not
a
string
.
"
)
;
return
nodeOrSelector
;
}
var
startPicker
=
Task
.
async
(
function
*
(
toolbox
)
{
info
(
"
Start
the
element
picker
"
)
;
yield
toolbox
.
highlighterUtils
.
startPicker
(
)
;
yield
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
function
*
(
)
{
content
.
focus
(
)
;
}
)
;
}
)
;
function
selectAndHighlightNode
(
selector
inspector
)
{
info
(
"
Highlighting
and
selecting
the
node
"
+
selector
)
;
return
selectNode
(
selector
inspector
"
test
-
highlight
"
)
;
}
function
*
focusNode
(
selector
inspector
)
{
getContainerForNodeFront
(
inspector
.
walker
.
rootNode
inspector
)
.
elt
.
focus
(
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
yield
selectNode
(
nodeFront
inspector
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
return
container
;
}
function
clearCurrentNodeSelection
(
inspector
)
{
info
(
"
Clearing
the
current
selection
"
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
null
)
;
return
updated
;
}
var
openInspectorForURL
=
Task
.
async
(
function
*
(
url
hostType
)
{
let
tab
=
yield
addTab
(
url
)
;
let
{
inspector
toolbox
testActor
}
=
yield
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
testActor
}
;
}
)
;
function
getActiveInspector
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
getToolbox
(
target
)
.
getPanel
(
"
inspector
"
)
;
}
var
clickOnInspectMenuItem
=
Task
.
async
(
function
*
(
testActor
selector
)
{
info
(
"
Showing
the
contextual
menu
on
node
"
+
selector
)
;
let
contentAreaContextMenu
=
document
.
querySelector
(
"
#
contentAreaContextMenu
"
)
;
let
contextOpened
=
once
(
contentAreaContextMenu
"
popupshown
"
)
;
yield
testActor
.
synthesizeMouse
(
{
selector
:
selector
center
:
true
options
:
{
type
:
"
contextmenu
"
button
:
2
}
}
)
;
yield
contextOpened
;
info
(
"
Triggering
the
inspect
action
"
)
;
yield
gContextMenu
.
inspectNode
(
)
;
info
(
"
Hiding
the
menu
"
)
;
let
contextClosed
=
once
(
contentAreaContextMenu
"
popuphidden
"
)
;
contentAreaContextMenu
.
hidePopup
(
)
;
yield
contextClosed
;
return
getActiveInspector
(
)
;
}
)
;
var
getNodeFrontInFrame
=
Task
.
async
(
function
*
(
selector
frameSelector
inspector
)
{
let
iframe
=
yield
getNodeFront
(
frameSelector
inspector
)
;
let
{
nodes
}
=
yield
inspector
.
walker
.
children
(
iframe
)
;
return
inspector
.
walker
.
querySelector
(
nodes
[
0
]
selector
)
;
}
)
;
var
focusSearchBoxUsingShortcut
=
Task
.
async
(
function
*
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
let
searchBox
=
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
let
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
synthesizeKeyShortcut
(
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
)
;
yield
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
)
;
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
info
(
"
Found
markup
-
container
"
+
container
)
;
return
container
;
}
)
;
var
hoverContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Hovering
over
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
highlit
=
inspector
.
toolbox
.
once
(
"
node
-
highlight
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousemove
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
highlit
;
}
)
;
var
clickContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
)
;
function
mouseLeaveMarkupView
(
inspector
)
{
info
(
"
Leaving
the
markup
-
view
area
"
)
;
let
def
=
defer
(
)
;
let
btn
=
inspector
.
toolbox
.
doc
.
querySelector
(
"
#
toolbox
-
controls
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
btn
{
type
:
"
mousemove
"
}
inspector
.
toolbox
.
win
)
;
executeSoon
(
def
.
resolve
)
;
return
def
.
promise
;
}
function
fireCopyEvent
(
element
)
{
let
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
undoChange
(
inspector
)
{
let
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
let
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
function
*
getNodeFrontForSelector
(
selector
inspector
)
{
if
(
selector
)
{
info
(
"
Retrieving
front
for
selector
"
+
selector
)
;
return
getNodeFront
(
selector
inspector
)
;
}
info
(
"
Retrieving
front
for
doctype
node
"
)
;
let
{
nodes
}
=
yield
inspector
.
walker
.
children
(
inspector
.
walker
.
rootNode
)
;
return
nodes
[
0
]
;
}
function
*
poll
(
check
desc
attempts
=
10
timeBetweenAttempts
=
200
)
{
info
(
desc
)
;
for
(
let
i
=
0
;
i
<
attempts
;
i
+
+
)
{
if
(
yield
check
(
)
)
{
return
;
}
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeBetweenAttempts
)
)
;
}
throw
new
Error
(
Timeout
while
:
{
desc
}
)
;
}
const
getHighlighterHelperFor
=
(
type
)
=
>
Task
.
async
(
function
*
(
{
inspector
testActor
}
)
{
let
front
=
inspector
.
inspector
;
let
highlighter
=
yield
front
.
getHighlighterByType
(
type
)
;
let
prefix
=
"
"
;
let
prevX
prevY
;
let
highlightedNode
=
null
;
return
{
set
prefix
(
value
)
{
prefix
=
value
;
}
get
highlightedNode
(
)
{
if
(
!
highlightedNode
)
{
return
null
;
}
return
{
getComputedStyle
:
function
*
(
options
=
{
}
)
{
return
yield
inspector
.
pageStyle
.
getComputed
(
highlightedNode
options
)
;
}
}
;
}
show
:
function
*
(
selector
=
"
:
root
"
options
)
{
highlightedNode
=
yield
getNodeFront
(
selector
inspector
)
;
return
yield
highlighter
.
show
(
highlightedNode
options
)
;
}
hide
:
function
*
(
)
{
yield
highlighter
.
hide
(
)
;
}
isElementHidden
:
function
*
(
id
)
{
return
(
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
"
hidden
"
highlighter
)
)
=
=
=
"
true
"
;
}
getElementTextContent
:
function
*
(
id
)
{
return
yield
testActor
.
getHighlighterNodeTextContent
(
prefix
+
id
highlighter
)
;
}
getElementAttribute
:
function
*
(
id
name
)
{
return
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
}
waitForElementAttributeSet
:
function
*
(
id
name
)
{
yield
poll
(
function
*
(
)
{
let
value
=
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
set
)
;
}
waitForElementAttributeRemoved
:
function
*
(
id
name
)
{
yield
poll
(
function
*
(
)
{
let
value
=
yield
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
removed
)
;
}
synthesizeMouse
:
function
*
(
options
)
{
options
=
Object
.
assign
(
{
selector
:
"
:
root
"
}
options
)
;
yield
testActor
.
synthesizeMouse
(
options
)
;
}
mouse
:
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
function
*
(
x
=
prevX
y
=
prevY
)
{
prevX
=
x
;
prevY
=
y
;
yield
testActor
.
synthesizeMouse
(
{
selector
:
"
:
root
"
x
y
options
:
{
type
:
"
mouse
"
+
name
}
}
)
;
}
}
)
reflow
:
function
*
(
)
{
yield
testActor
.
reflow
(
)
;
}
finalize
:
function
*
(
)
{
highlightedNode
=
null
;
yield
highlighter
.
finalize
(
)
;
}
}
;
}
)
;
function
*
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
yield
waitForChildrenUpdated
(
inspector
)
;
return
yield
waitForMultipleChildrenUpdates
(
inspector
)
;
}
return
null
;
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
let
def
=
defer
(
)
;
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
def
.
resolve
)
;
}
)
;
return
def
.
promise
;
}
function
waitForStyleEditor
(
toolbox
href
)
{
let
def
=
defer
(
)
;
info
(
"
Waiting
for
the
toolbox
to
switch
to
the
styleeditor
"
)
;
toolbox
.
once
(
"
styleeditor
-
selected
"
)
.
then
(
(
)
=
>
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
ok
(
panel
&
&
panel
.
UI
"
Styleeditor
panel
switched
to
front
"
)
;
let
gotEditor
=
(
event
editor
)
=
>
{
let
currentHref
=
editor
.
styleSheet
.
href
;
if
(
!
href
|
|
(
href
&
&
currentHref
.
endsWith
(
href
)
)
)
{
info
(
"
Stylesheet
editor
selected
"
)
;
panel
.
UI
.
off
(
"
editor
-
selected
"
gotEditor
)
;
editor
.
getSourceEditor
(
)
.
then
(
sourceEditor
=
>
{
info
(
"
Stylesheet
editor
fully
loaded
"
)
;
def
.
resolve
(
sourceEditor
)
;
}
)
;
return
true
;
}
info
(
"
The
editor
was
incorrect
.
Waiting
for
editor
-
selected
event
.
"
)
;
return
false
;
}
;
if
(
!
gotEditor
(
"
styleeditor
-
selected
"
panel
.
UI
.
selectedEditor
)
)
{
panel
.
UI
.
on
(
"
editor
-
selected
"
gotEditor
)
;
}
}
)
;
return
def
.
promise
;
}
function
waitForClipboard
(
setup
expected
)
{
let
def
=
defer
(
)
;
SimpleTest
.
waitForClipboard
(
expected
setup
def
.
resolve
def
.
reject
)
;
return
def
.
promise
;
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
waitForTab
=
Task
.
async
(
function
*
(
)
{
info
(
"
Waiting
for
a
tab
to
open
"
)
;
yield
once
(
gBrowser
.
tabContainer
"
TabOpen
"
)
;
let
tab
=
gBrowser
.
selectedTab
;
let
browser
=
tab
.
linkedBrowser
;
yield
once
(
browser
"
load
"
true
)
;
info
(
"
The
tab
load
completed
"
)
;
return
tab
;
}
)
;
function
synthesizeKeys
(
input
win
)
{
for
(
let
key
of
input
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
win
)
;
}
}
function
isHoverTooltipTarget
(
tooltip
target
)
{
if
(
!
tooltip
.
_toggle
.
_baseNode
|
|
!
tooltip
.
panel
)
{
return
promise
.
reject
(
new
Error
(
"
The
tooltip
passed
isn
'
t
set
to
toggle
on
hover
or
is
not
a
tooltip
"
)
)
;
}
return
tooltip
.
_toggle
.
isValidHoverTarget
(
target
)
;
}
function
assertHoverTooltipOn
(
tooltip
element
)
{
return
isHoverTooltipTarget
(
tooltip
element
)
.
then
(
(
)
=
>
{
ok
(
true
"
A
tooltip
is
defined
on
hover
of
the
given
element
"
)
;
}
(
)
=
>
{
ok
(
false
"
No
tooltip
is
defined
on
hover
of
the
given
element
"
)
;
}
)
;
}
function
openContextMenuAndGetAllItems
(
inspector
options
)
{
let
menu
=
inspector
.
_openMenu
(
options
)
;
let
allItems
=
[
]
.
concat
.
apply
(
[
]
menu
.
items
.
map
(
function
addItem
(
item
)
{
if
(
item
.
submenu
)
{
return
addItem
(
item
.
submenu
.
items
)
;
}
return
item
;
}
)
)
;
return
allItems
;
}
function
getRuleViewRuleEditor
(
view
childrenIndex
nodeIndex
)
{
return
nodeIndex
!
=
=
undefined
?
view
.
element
.
children
[
childrenIndex
]
.
childNodes
[
nodeIndex
]
.
_ruleEditor
:
view
.
element
.
children
[
childrenIndex
]
.
_ruleEditor
;
}
