"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
selectedSidebar
"
)
;
}
)
;
registerCleanupFunction
(
function
(
)
{
EventUtils
.
synthesizeMouseAtPoint
(
window
.
innerWidth
1
{
type
:
"
mousemove
"
}
window
)
;
}
)
;
var
startPicker
=
async
function
(
toolbox
skipFocus
)
{
info
(
"
Start
the
element
picker
"
)
;
toolbox
.
win
.
focus
(
)
;
await
toolbox
.
nodePicker
.
start
(
)
;
if
(
!
skipFocus
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
async
function
(
)
{
content
.
focus
(
)
;
}
)
;
}
}
;
var
stopPickerWithEscapeKey
=
async
function
(
toolbox
)
{
const
onPickerStopped
=
toolbox
.
nodePicker
.
once
(
"
picker
-
node
-
canceled
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_ESCAPE
"
{
}
toolbox
.
win
)
;
await
onPickerStopped
;
}
;
var
startEyeDropper
=
async
function
(
toolbox
)
{
info
(
"
Start
the
eye
dropper
tool
"
)
;
toolbox
.
win
.
focus
(
)
;
await
toolbox
.
getPanel
(
"
inspector
"
)
.
showEyeDropper
(
)
;
}
;
function
pickElement
(
inspector
selector
x
y
)
{
info
(
"
Waiting
for
element
"
+
selector
+
"
to
be
picked
"
)
;
const
onNewNodeFront
=
inspector
.
selection
.
once
(
"
new
-
node
-
front
"
)
;
BrowserTestUtils
.
synthesizeMouse
(
selector
x
y
{
}
gBrowser
.
selectedTab
.
linkedBrowser
)
;
return
onNewNodeFront
;
}
async
function
hoverElement
(
inspector
selector
x
y
)
{
const
{
waitForHighlighterTypeShown
}
=
getHighlighterTestHelpers
(
inspector
)
;
info
(
Waiting
for
element
"
{
selector
}
"
to
be
hovered
)
;
const
onHovered
=
inspector
.
toolbox
.
nodePicker
.
once
(
"
picker
-
node
-
hovered
"
)
;
const
onHighlighterShown
=
waitForHighlighterTypeShown
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
let
browsingContext
=
gBrowser
.
selectedTab
.
linkedBrowser
;
if
(
Array
.
isArray
(
selector
)
)
{
browsingContext
=
await
getBrowsingContextForNestedFrame
(
selector
.
slice
(
0
selector
.
length
-
1
)
)
;
selector
=
selector
[
selector
.
length
-
1
]
;
}
if
(
isNaN
(
x
)
|
|
isNaN
(
y
)
)
{
BrowserTestUtils
.
synthesizeMouseAtCenter
(
selector
{
type
:
"
mousemove
"
}
browsingContext
)
;
}
else
{
BrowserTestUtils
.
synthesizeMouse
(
selector
x
y
{
type
:
"
mousemove
"
}
browsingContext
)
;
}
info
(
"
Wait
for
picker
-
node
-
hovered
"
)
;
await
onHovered
;
info
(
"
Wait
for
highlighter
shown
"
)
;
await
onHighlighterShown
;
return
Promise
.
all
(
[
onHighlighterShown
onHovered
]
)
;
}
async
function
getBrowsingContextForNestedFrame
(
selectorArray
=
[
]
)
{
let
browsingContext
=
gBrowser
.
selectedTab
.
linkedBrowser
;
if
(
!
Array
.
isArray
(
selectorArray
)
)
{
return
browsingContext
;
}
while
(
selectorArray
.
length
)
{
browsingContext
=
await
SpecialPowers
.
spawn
(
browsingContext
[
selectorArray
.
shift
(
)
]
function
(
selector
)
{
const
iframe
=
content
.
document
.
querySelector
(
selector
)
;
return
iframe
.
browsingContext
;
}
)
;
}
return
browsingContext
;
}
async
function
selectAndHighlightNode
(
selector
inspector
)
{
const
{
waitForHighlighterTypeShown
}
=
getHighlighterTestHelpers
(
inspector
)
;
info
(
"
Highlighting
and
selecting
the
node
"
+
selector
)
;
const
onHighlighterShown
=
waitForHighlighterTypeShown
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
await
selectNode
(
selector
inspector
"
test
-
highlight
"
)
;
await
onHighlighterShown
;
}
async
function
focusNode
(
selector
inspector
)
{
getContainerForNodeFront
(
inspector
.
walker
.
rootNode
inspector
)
.
elt
.
focus
(
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
await
selectNode
(
nodeFront
inspector
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
return
container
;
}
function
clearCurrentNodeSelection
(
inspector
)
{
info
(
"
Clearing
the
current
selection
"
)
;
const
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
null
)
;
return
updated
;
}
var
clickOnInspectMenuItem
=
async
function
(
selector
)
{
info
(
"
Showing
the
contextual
menu
on
node
"
+
selector
)
;
const
contentAreaContextMenu
=
document
.
querySelector
(
"
#
contentAreaContextMenu
"
)
;
const
contextOpened
=
once
(
contentAreaContextMenu
"
popupshown
"
)
;
await
safeSynthesizeMouseEventAtCenterInContentPage
(
selector
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
contextOpened
;
info
(
"
Triggering
the
inspect
action
"
)
;
await
gContextMenu
.
inspectNode
(
)
;
info
(
"
Hiding
the
menu
"
)
;
const
contextClosed
=
once
(
contentAreaContextMenu
"
popuphidden
"
)
;
contentAreaContextMenu
.
hidePopup
(
)
;
await
contextClosed
;
return
getActiveInspector
(
)
;
}
;
var
getFrameDocument
=
async
function
(
frameSelector
inspector
)
{
const
iframe
=
await
getNodeFront
(
frameSelector
inspector
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
iframe
)
;
return
nodes
.
filter
(
node
=
>
node
.
displayName
=
=
=
"
#
document
"
)
[
0
]
;
}
;
var
getShadowRoot
=
async
function
(
hostSelector
inspector
)
{
const
hostFront
=
await
getNodeFront
(
hostSelector
inspector
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
hostFront
)
;
return
nodes
.
filter
(
node
=
>
node
.
isShadowRoot
)
[
0
]
;
}
;
var
getNodeFrontInShadowDom
=
async
function
(
selector
hostSelector
inspector
)
{
const
shadowRoot
=
await
getShadowRoot
(
hostSelector
inspector
)
;
if
(
!
shadowRoot
)
{
throw
new
Error
(
"
Could
not
find
a
shadow
root
under
selector
:
"
+
hostSelector
)
;
}
return
inspector
.
walker
.
querySelector
(
shadowRoot
selector
)
;
}
;
var
focusSearchBoxUsingShortcut
=
async
function
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
const
searchBox
=
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
const
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
synthesizeKeyShortcut
(
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
)
;
await
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
;
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
async
function
(
selector
inspector
expectFailure
=
false
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
if
(
expectFailure
)
{
ok
(
!
container
"
Shouldn
'
t
find
markup
-
container
for
selector
:
"
+
selector
)
;
}
else
{
ok
(
container
"
Found
markup
-
container
for
selector
:
"
+
selector
)
;
}
return
container
;
}
;
var
hoverContainer
=
async
function
(
selector
inspector
)
{
const
{
waitForHighlighterTypeShown
}
=
getHighlighterTestHelpers
(
inspector
)
;
info
(
"
Hovering
over
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
const
onHighlighterShown
=
waitForHighlighterTypeShown
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousemove
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
await
onHighlighterShown
;
}
;
var
clickContainer
=
async
function
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
const
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
;
function
mouseLeaveMarkupView
(
inspector
)
{
info
(
"
Leaving
the
markup
-
view
area
"
)
;
const
btn
=
inspector
.
toolbox
.
doc
.
querySelector
(
"
#
toolbox
-
controls
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
btn
{
type
:
"
mousemove
"
}
inspector
.
toolbox
.
win
)
;
return
new
Promise
(
resolve
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
function
fireCopyEvent
(
element
)
{
const
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
undoChange
(
inspector
)
{
const
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
Promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
const
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
Promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
async
function
getNodeFrontForSelector
(
selector
inspector
)
{
if
(
selector
)
{
info
(
"
Retrieving
front
for
selector
"
+
selector
)
;
return
getNodeFront
(
selector
inspector
)
;
}
info
(
"
Retrieving
front
for
doctype
node
"
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
inspector
.
walker
.
rootNode
)
;
return
nodes
[
0
]
;
}
async
function
poll
(
check
desc
attempts
=
10
timeBetweenAttempts
=
200
)
{
info
(
desc
)
;
for
(
let
i
=
0
;
i
<
attempts
;
i
+
+
)
{
if
(
await
check
(
)
)
{
return
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeBetweenAttempts
)
)
;
}
throw
new
Error
(
Timeout
while
:
{
desc
}
)
;
}
const
getHighlighterHelperFor
=
type
=
>
async
function
(
{
inspector
highlighterTestFront
}
)
{
const
front
=
inspector
.
inspectorFront
;
const
highlighter
=
await
front
.
getHighlighterByType
(
type
)
;
let
prefix
=
"
"
;
let
prevX
prevY
;
let
highlightedNode
=
null
;
return
{
set
prefix
(
value
)
{
prefix
=
value
;
}
get
highlightedNode
(
)
{
if
(
!
highlightedNode
)
{
return
null
;
}
return
{
async
getComputedStyle
(
options
=
{
}
)
{
const
pageStyle
=
highlightedNode
.
inspectorFront
.
pageStyle
;
return
pageStyle
.
getComputed
(
highlightedNode
options
)
;
}
}
;
}
get
actorID
(
)
{
if
(
!
highlighter
)
{
return
null
;
}
return
highlighter
.
actorID
;
}
async
show
(
selector
=
"
:
root
"
options
frameSelector
=
null
)
{
if
(
frameSelector
)
{
highlightedNode
=
await
getNodeFrontInFrames
(
[
frameSelector
selector
]
inspector
)
;
}
else
{
highlightedNode
=
await
getNodeFront
(
selector
inspector
)
;
}
return
highlighter
.
show
(
highlightedNode
options
)
;
}
async
hide
(
)
{
await
highlighter
.
hide
(
)
;
}
async
isElementHidden
(
id
)
{
return
(
(
await
highlighterTestFront
.
getHighlighterNodeAttribute
(
prefix
+
id
"
hidden
"
highlighter
)
)
=
=
=
"
true
"
)
;
}
async
getElementTextContent
(
id
)
{
return
highlighterTestFront
.
getHighlighterNodeTextContent
(
prefix
+
id
highlighter
)
;
}
async
getElementAttribute
(
id
name
)
{
return
highlighterTestFront
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
}
async
waitForElementAttributeSet
(
id
name
)
{
await
poll
(
async
function
(
)
{
const
value
=
await
highlighterTestFront
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
set
)
;
}
async
waitForElementAttributeRemoved
(
id
name
)
{
await
poll
(
async
function
(
)
{
const
value
=
await
highlighterTestFront
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
removed
)
;
}
async
synthesizeMouse
(
{
selector
=
"
:
root
"
center
x
y
options
}
=
{
}
)
{
if
(
center
=
=
=
true
)
{
await
safeSynthesizeMouseEventAtCenterInContentPage
(
selector
options
)
;
}
else
{
await
safeSynthesizeMouseEventInContentPage
(
selector
x
y
options
)
;
}
}
mouse
:
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
async
function
(
x
=
prevX
y
=
prevY
selector
=
"
:
root
"
)
{
prevX
=
x
;
prevY
=
y
;
await
safeSynthesizeMouseEventInContentPage
(
selector
x
y
{
type
:
"
mouse
"
+
name
}
)
;
}
}
)
async
finalize
(
)
{
highlightedNode
=
null
;
await
highlighter
.
finalize
(
)
;
}
}
;
}
;
function
getHighlighterTestHelpers
(
inspector
)
{
function
_waitForHighlighterTypeEvent
(
type
eventName
)
{
return
new
Promise
(
resolve
=
>
{
function
_handler
(
data
)
{
if
(
type
=
=
=
data
.
type
)
{
inspector
.
highlighters
.
off
(
eventName
_handler
)
;
resolve
(
data
)
;
}
}
inspector
.
highlighters
.
on
(
eventName
_handler
)
;
}
)
;
}
return
{
getActiveHighlighter
(
type
)
{
return
inspector
.
highlighters
.
getActiveHighlighter
(
type
)
;
}
getNodeForActiveHighlighter
(
type
)
{
return
inspector
.
highlighters
.
getNodeForActiveHighlighter
(
type
)
;
}
waitForHighlighterTypeShown
(
type
)
{
return
_waitForHighlighterTypeEvent
(
type
"
highlighter
-
shown
"
)
;
}
waitForHighlighterTypeHidden
(
type
)
{
return
_waitForHighlighterTypeEvent
(
type
"
highlighter
-
hidden
"
)
;
}
waitForHighlighterTypeRestored
(
type
)
{
return
_waitForHighlighterTypeEvent
(
type
"
highlighter
-
restored
"
)
;
}
waitForHighlighterTypeDiscarded
(
type
)
{
return
_waitForHighlighterTypeEvent
(
type
"
highlighter
-
discarded
"
)
;
}
}
;
}
async
function
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
await
waitForChildrenUpdated
(
inspector
)
;
return
waitForMultipleChildrenUpdates
(
inspector
)
;
}
return
null
;
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
return
new
Promise
(
resolve
=
>
{
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
)
;
}
function
waitForStyleEditor
(
toolbox
href
)
{
info
(
"
Waiting
for
the
toolbox
to
switch
to
the
styleeditor
"
)
;
return
new
Promise
(
resolve
=
>
{
toolbox
.
once
(
"
styleeditor
-
selected
"
)
.
then
(
(
)
=
>
{
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
ok
(
panel
&
&
panel
.
UI
"
Styleeditor
panel
switched
to
front
"
)
;
const
gotEditor
=
editor
=
>
{
const
currentHref
=
editor
.
styleSheet
.
href
;
if
(
!
href
|
|
(
href
&
&
currentHref
.
endsWith
(
href
)
)
)
{
info
(
"
Stylesheet
editor
selected
"
)
;
panel
.
UI
.
off
(
"
editor
-
selected
"
gotEditor
)
;
editor
.
getSourceEditor
(
)
.
then
(
sourceEditor
=
>
{
info
(
"
Stylesheet
editor
fully
loaded
"
)
;
resolve
(
sourceEditor
)
;
}
)
;
return
true
;
}
info
(
"
The
editor
was
incorrect
.
Waiting
for
editor
-
selected
event
.
"
)
;
return
false
;
}
;
if
(
!
gotEditor
(
panel
.
UI
.
selectedEditor
)
)
{
panel
.
UI
.
on
(
"
editor
-
selected
"
gotEditor
)
;
}
}
)
;
}
)
;
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
waitForTab
=
async
function
(
)
{
info
(
"
Waiting
for
a
tab
to
open
"
)
;
await
once
(
gBrowser
.
tabContainer
"
TabOpen
"
)
;
const
tab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
info
(
"
The
tab
load
completed
"
)
;
return
tab
;
}
;
function
synthesizeKeys
(
input
win
)
{
for
(
const
key
of
input
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
win
)
;
}
}
function
focusAndSendKey
(
win
key
)
{
win
.
document
.
documentElement
.
focus
(
)
;
EventUtils
.
sendKey
(
key
win
)
;
}
async
function
assertTooltipShownOnHover
(
tooltip
target
)
{
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
}
)
;
target
.
dispatchEvent
(
mouseEvent
)
;
if
(
!
tooltip
.
isVisible
(
)
)
{
info
(
"
Waiting
for
tooltip
to
be
shown
"
)
;
await
tooltip
.
once
(
"
shown
"
)
;
}
ok
(
tooltip
.
isVisible
(
)
The
tooltip
is
visible
)
;
return
tooltip
;
}
async
function
assertShowPreviewTooltip
(
view
target
)
{
const
name
=
"
previewTooltip
"
;
const
tooltip
=
view
.
tooltips
.
getTooltip
(
name
)
;
ok
(
tooltip
Tooltip
'
{
name
}
'
has
been
instantiated
)
;
const
shown
=
tooltip
.
once
(
"
shown
"
)
;
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
}
)
;
target
.
dispatchEvent
(
mouseEvent
)
;
info
(
"
Waiting
for
tooltip
to
be
shown
"
)
;
await
shown
;
ok
(
tooltip
.
isVisible
(
)
The
tooltip
'
{
name
}
'
is
visible
)
;
return
tooltip
;
}
async
function
assertTooltipHiddenOnMouseOut
(
tooltip
target
)
{
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
relatedTarget
:
target
}
)
;
target
.
parentNode
.
dispatchEvent
(
mouseEvent
)
;
await
tooltip
.
once
(
"
hidden
"
)
;
ok
(
!
tooltip
.
isVisible
(
)
"
The
tooltip
is
hidden
on
mouseout
"
)
;
}
function
getRuleViewRuleEditor
(
view
childrenIndex
nodeIndex
)
{
return
nodeIndex
!
=
=
undefined
?
view
.
element
.
children
[
childrenIndex
]
.
childNodes
[
nodeIndex
]
.
_ruleEditor
:
view
.
element
.
children
[
childrenIndex
]
.
_ruleEditor
;
}
async
function
getDisplayedNodeTextContent
(
selector
inspector
)
{
await
selectNode
(
selector
inspector
)
;
const
container
=
await
getContainerForSelector
(
selector
inspector
)
;
await
inspector
.
markup
.
expandNode
(
container
.
node
)
;
await
waitForMultipleChildrenUpdates
(
inspector
)
;
if
(
container
)
{
const
textContainer
=
container
.
elt
.
querySelector
(
"
pre
"
)
;
return
textContainer
.
textContent
;
}
return
null
;
}
async
function
toggleShapesHighlighter
(
view
selector
property
show
options
=
{
}
)
{
info
(
Toggle
shapes
highlighter
{
show
?
"
on
"
:
"
off
"
}
for
{
property
}
on
{
selector
}
)
;
const
highlighters
=
view
.
highlighters
;
const
container
=
getRuleViewProperty
(
view
selector
property
)
.
valueSpan
;
const
shapesToggle
=
container
.
querySelector
(
"
.
ruleview
-
shapeswatch
"
)
;
const
metaKey
=
options
.
transformMode
;
const
ctrlKey
=
options
.
transformMode
;
if
(
show
)
{
const
onHighlighterShown
=
highlighters
.
once
(
"
shapes
-
highlighter
-
shown
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
metaKey
ctrlKey
}
shapesToggle
view
.
styleWindow
)
;
await
onHighlighterShown
;
}
else
{
const
onHighlighterHidden
=
highlighters
.
once
(
"
shapes
-
highlighter
-
hidden
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
metaKey
ctrlKey
}
shapesToggle
view
.
styleWindow
)
;
await
onHighlighterHidden
;
}
}
async
function
expandContainer
(
inspector
container
)
{
await
inspector
.
markup
.
expandNode
(
container
.
node
)
;
await
waitForMultipleChildrenUpdates
(
inspector
)
;
}
async
function
toggleContainerByClick
(
inspector
container
{
altKey
=
false
}
=
{
}
)
{
EventUtils
.
synthesizeMouseAtCenter
(
container
.
expander
{
altKey
}
inspector
.
markup
.
doc
.
defaultView
)
;
await
waitForMultipleChildrenUpdates
(
inspector
)
;
}
async
function
simulateColorPickerChange
(
colorPicker
newRgba
)
{
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
const
spectrum
=
await
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
}
async
function
assertMarkupViewAsTree
(
tree
selector
inspector
)
{
const
{
markup
}
=
inspector
;
info
(
Find
and
expand
the
shadow
DOM
host
matching
selector
{
selector
}
.
)
;
const
rootFront
=
await
getNodeFront
(
selector
inspector
)
;
const
rootContainer
=
markup
.
getContainer
(
rootFront
)
;
const
parsedTree
=
_parseMarkupViewTree
(
tree
)
;
const
treeRoot
=
parsedTree
.
children
[
0
]
;
await
_checkMarkupViewNode
(
treeRoot
rootContainer
inspector
)
;
}
async
function
_checkMarkupViewNode
(
treeNode
container
inspector
)
{
const
{
node
children
path
}
=
treeNode
;
info
(
"
Checking
[
"
+
path
+
"
]
"
)
;
info
(
"
Checking
node
:
"
+
node
)
;
const
ignoreChildren
=
node
.
includes
(
"
!
ignore
-
children
"
)
;
const
slotted
=
node
.
includes
(
"
!
slotted
"
)
;
const
nodeText
=
node
.
replace
(
"
!
slotted
"
"
"
)
.
replace
(
"
!
ignore
-
children
"
"
"
)
;
assertContainerHasText
(
container
nodeText
)
;
if
(
slotted
)
{
assertContainerSlotted
(
container
)
;
}
if
(
ignoreChildren
)
{
return
;
}
if
(
!
children
.
length
)
{
ok
(
!
container
.
canExpand
"
Container
for
[
"
+
path
+
"
]
has
no
children
"
)
;
return
;
}
if
(
!
container
.
expanded
)
{
await
expandContainer
(
inspector
container
)
;
}
const
containers
=
container
.
getChildContainers
(
)
;
is
(
containers
.
length
children
.
length
"
Node
[
"
+
path
+
"
]
has
the
expected
number
of
children
"
)
;
for
(
let
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
await
_checkMarkupViewNode
(
children
[
i
]
containers
[
i
]
inspector
)
;
}
}
function
_parseMarkupViewTree
(
inputString
)
{
const
tree
=
{
level
:
0
children
:
[
]
}
;
let
lines
=
inputString
.
split
(
"
\
n
"
)
;
lines
=
lines
.
filter
(
l
=
>
l
.
trim
(
)
)
;
let
currentNode
=
tree
;
for
(
const
line
of
lines
)
{
const
nodeString
=
line
.
trim
(
)
;
const
level
=
line
.
split
(
"
"
)
.
length
;
let
parent
;
if
(
level
>
currentNode
.
level
)
{
parent
=
currentNode
;
}
else
{
parent
=
currentNode
.
parent
;
for
(
let
i
=
0
;
i
<
currentNode
.
level
-
level
;
i
+
+
)
{
parent
=
parent
.
parent
;
}
}
const
node
=
{
node
:
nodeString
children
:
[
]
parent
level
path
:
parent
.
path
+
"
"
+
nodeString
}
;
parent
.
children
.
push
(
node
)
;
currentNode
=
node
;
}
return
tree
;
}
function
assertContainerSlotted
(
container
)
{
ok
(
container
.
isSlotted
(
)
"
Container
is
a
slotted
container
"
)
;
ok
(
container
.
elt
.
querySelector
(
"
.
reveal
-
link
"
)
"
Slotted
container
has
a
reveal
link
element
"
)
;
}
function
assertContainerHasText
(
container
expectedText
)
{
const
textContent
=
container
.
elt
.
textContent
;
ok
(
textContent
.
includes
(
expectedText
)
"
Container
has
expected
text
:
"
+
expectedText
)
;
}
function
waitForMutation
(
inspector
type
)
{
return
waitForNMutations
(
inspector
type
1
)
;
}
function
waitForNMutations
(
inspector
type
count
)
{
info
(
Expecting
{
count
}
markupmutation
of
type
{
type
}
)
;
let
receivedMutations
=
0
;
return
new
Promise
(
resolve
=
>
{
inspector
.
on
(
"
markupmutation
"
function
onMutation
(
mutations
)
{
const
validMutations
=
mutations
.
filter
(
m
=
>
m
.
type
=
=
=
type
)
.
length
;
receivedMutations
=
receivedMutations
+
validMutations
;
if
(
receivedMutations
=
=
count
)
{
inspector
.
off
(
"
markupmutation
"
onMutation
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
async
function
checkEyeDropperColorAt
(
highlighterTestFront
x
y
expectedColor
assertionDescription
)
{
info
(
Move
mouse
to
{
x
}
{
y
}
)
;
await
safeSynthesizeMouseEventInContentPage
(
"
:
root
"
x
y
{
type
:
"
mousemove
"
}
)
;
const
colorValue
=
await
highlighterTestFront
.
getEyeDropperColorValue
(
)
;
is
(
colorValue
expectedColor
assertionDescription
)
;
}
async
function
deleteNodeWithContextMenu
(
node
inspector
)
{
const
container
=
inspector
.
markup
.
getContainer
(
node
)
;
const
allMenuItems
=
openContextMenuAndGetAllItems
(
inspector
{
target
:
container
.
tagLine
}
)
;
const
menuItem
=
allMenuItems
.
find
(
item
=
>
item
.
id
=
=
=
"
node
-
menu
-
delete
"
)
;
const
onInspectorUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
info
(
"
Clicking
'
Delete
Node
'
in
the
context
menu
.
"
)
;
is
(
menuItem
.
disabled
false
"
delete
menu
item
is
enabled
"
)
;
menuItem
.
click
(
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
info
(
"
Waiting
for
inspector
to
update
.
"
)
;
await
onInspectorUpdated
;
if
(
inspector
.
breadcrumbs
.
indexOf
(
node
)
>
-
1
)
{
info
(
"
Crumbs
haven
'
t
seen
deletion
.
Waiting
for
breadcrumbs
-
updated
.
"
)
;
await
inspector
.
once
(
"
breadcrumbs
-
updated
"
)
;
}
}
function
reflowContentPage
(
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
async
function
(
)
{
return
new
Promise
(
resolve
=
>
{
content
.
document
.
documentElement
.
offsetWidth
;
content
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
)
;
}
async
function
getAllAdjustedQuadsForContentPageElement
(
selector
useTopWindowAsBoundary
=
true
)
{
const
selectors
=
Array
.
isArray
(
selector
)
?
selector
:
[
selector
]
;
const
browsingContext
=
selectors
.
length
=
=
1
?
gBrowser
.
selectedBrowser
.
browsingContext
:
await
getBrowsingContextInFrames
(
gBrowser
.
selectedBrowser
.
browsingContext
selectors
.
slice
(
0
-
1
)
)
;
const
inBrowsingContextSelector
=
selectors
.
at
(
-
1
)
;
return
SpecialPowers
.
spawn
(
browsingContext
[
inBrowsingContextSelector
useTopWindowAsBoundary
]
(
_selector
_useTopWindowAsBoundary
)
=
>
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
{
getAdjustedQuads
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
node
=
content
.
document
.
querySelector
(
_selector
)
;
const
boundaryWindow
=
_useTopWindowAsBoundary
?
content
.
top
:
content
;
const
regions
=
{
}
;
for
(
const
boxType
of
[
"
content
"
"
padding
"
"
border
"
"
margin
"
]
)
{
regions
[
boxType
]
=
getAdjustedQuads
(
boundaryWindow
node
boxType
)
;
}
return
regions
;
}
)
;
}
async
function
isNodeCorrectlyHighlighted
(
highlighterTestFront
selector
)
{
const
boxModel
=
await
highlighterTestFront
.
getBoxModelStatus
(
)
;
const
useTopWindowAsBoundary
=
!
!
highlighterTestFront
.
parentFront
.
isTopLevel
;
const
regions
=
await
getAllAdjustedQuadsForContentPageElement
(
selector
useTopWindowAsBoundary
)
;
for
(
const
boxType
of
[
"
content
"
"
padding
"
"
border
"
"
margin
"
]
)
{
const
[
quad
]
=
regions
[
boxType
]
;
for
(
const
point
in
boxModel
[
boxType
]
.
points
)
{
is
(
boxModel
[
boxType
]
.
points
[
point
]
.
x
quad
[
point
]
.
x
{
selector
}
{
boxType
}
point
{
point
}
x
coordinate
is
correct
)
;
is
(
boxModel
[
boxType
]
.
points
[
point
]
.
y
quad
[
point
]
.
y
{
selector
}
{
boxType
}
point
{
point
}
y
coordinate
is
correct
)
;
}
}
}
