"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
}
)
;
registerCleanupFunction
(
function
(
)
{
EventUtils
.
synthesizeMouseAtPoint
(
window
.
innerWidth
1
{
type
:
"
mousemove
"
}
window
)
;
}
)
;
var
navigateTo
=
async
function
(
inspector
url
)
{
const
markuploaded
=
inspector
.
once
(
"
markuploaded
"
)
;
const
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
info
(
"
Navigating
to
:
"
+
url
)
;
const
target
=
inspector
.
toolbox
.
target
;
await
target
.
navigateTo
(
{
url
}
)
;
info
(
"
Waiting
for
markup
view
to
load
after
navigation
.
"
)
;
await
markuploaded
;
info
(
"
Waiting
for
new
root
.
"
)
;
await
onNewRoot
;
info
(
"
Waiting
for
inspector
to
update
after
new
-
root
event
.
"
)
;
await
onUpdated
;
}
;
var
startPicker
=
async
function
(
toolbox
skipFocus
)
{
info
(
"
Start
the
element
picker
"
)
;
toolbox
.
win
.
focus
(
)
;
await
toolbox
.
inspector
.
nodePicker
.
start
(
)
;
if
(
!
skipFocus
)
{
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
content
.
focus
(
)
;
}
)
;
}
}
;
function
pickElement
(
inspector
testActor
selector
x
y
)
{
info
(
"
Waiting
for
element
"
+
selector
+
"
to
be
picked
"
)
;
const
onNewNodeFront
=
inspector
.
selection
.
once
(
"
new
-
node
-
front
"
)
;
testActor
.
synthesizeMouse
(
{
selector
x
y
options
:
{
}
}
)
;
return
onNewNodeFront
;
}
function
hoverElement
(
inspector
testActor
selector
x
y
)
{
info
(
"
Waiting
for
element
"
+
selector
+
"
to
be
hovered
"
)
;
const
onHovered
=
inspector
.
inspector
.
nodePicker
.
once
(
"
picker
-
node
-
hovered
"
)
;
testActor
.
synthesizeMouse
(
{
selector
x
y
options
:
{
type
:
"
mousemove
"
}
}
)
;
return
onHovered
;
}
function
selectAndHighlightNode
(
selector
inspector
)
{
info
(
"
Highlighting
and
selecting
the
node
"
+
selector
)
;
return
selectNode
(
selector
inspector
"
test
-
highlight
"
)
;
}
async
function
focusNode
(
selector
inspector
)
{
getContainerForNodeFront
(
inspector
.
walker
.
rootNode
inspector
)
.
elt
.
focus
(
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
await
selectNode
(
nodeFront
inspector
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
return
container
;
}
function
clearCurrentNodeSelection
(
inspector
)
{
info
(
"
Clearing
the
current
selection
"
)
;
const
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
null
)
;
return
updated
;
}
var
openInspectorForURL
=
async
function
(
url
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
const
{
inspector
toolbox
testActor
}
=
await
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
testActor
}
;
}
;
async
function
getActiveInspector
(
)
{
const
target
=
await
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
getToolbox
(
target
)
.
getPanel
(
"
inspector
"
)
;
}
var
clickOnInspectMenuItem
=
async
function
(
testActor
selector
)
{
info
(
"
Showing
the
contextual
menu
on
node
"
+
selector
)
;
const
contentAreaContextMenu
=
document
.
querySelector
(
"
#
contentAreaContextMenu
"
)
;
const
contextOpened
=
once
(
contentAreaContextMenu
"
popupshown
"
)
;
await
testActor
.
synthesizeMouse
(
{
selector
:
selector
center
:
true
options
:
{
type
:
"
contextmenu
"
button
:
2
}
}
)
;
await
contextOpened
;
info
(
"
Triggering
the
inspect
action
"
)
;
await
gContextMenu
.
inspectNode
(
)
;
info
(
"
Hiding
the
menu
"
)
;
const
contextClosed
=
once
(
contentAreaContextMenu
"
popuphidden
"
)
;
contentAreaContextMenu
.
hidePopup
(
)
;
await
contextClosed
;
return
getActiveInspector
(
)
;
}
;
var
getNodeFrontInFrame
=
async
function
(
selector
frameSelector
inspector
)
{
const
iframe
=
await
getNodeFront
(
frameSelector
inspector
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
iframe
)
;
return
inspector
.
walker
.
querySelector
(
nodes
[
0
]
selector
)
;
}
;
var
getNodeFrontInShadowDom
=
async
function
(
selector
hostSelector
inspector
)
{
const
hostFront
=
await
getNodeFront
(
hostSelector
inspector
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
hostFront
)
;
const
shadowRoot
=
nodes
.
filter
(
node
=
>
node
.
isShadowRoot
)
[
0
]
;
if
(
!
shadowRoot
)
{
throw
new
Error
(
"
Could
not
find
a
shadow
root
under
selector
:
"
+
hostSelector
)
;
}
return
inspector
.
walker
.
querySelector
(
shadowRoot
selector
)
;
}
;
var
focusSearchBoxUsingShortcut
=
async
function
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
const
searchBox
=
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
const
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
synthesizeKeyShortcut
(
INSPECTOR_L10N
.
getStr
(
"
inspector
.
searchHTML
.
key
"
)
)
;
await
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
;
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
async
function
(
selector
inspector
expectFailure
=
false
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
if
(
expectFailure
)
{
ok
(
!
container
"
Shouldn
'
t
find
markup
-
container
for
selector
:
"
+
selector
)
;
}
else
{
ok
(
container
"
Found
markup
-
container
for
selector
:
"
+
selector
)
;
}
return
container
;
}
;
var
hoverContainer
=
async
function
(
selector
inspector
)
{
info
(
"
Hovering
over
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
const
highlit
=
inspector
.
highlighter
.
once
(
"
node
-
highlight
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousemove
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
highlit
;
}
;
var
clickContainer
=
async
function
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
const
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
;
function
mouseLeaveMarkupView
(
inspector
)
{
info
(
"
Leaving
the
markup
-
view
area
"
)
;
const
btn
=
inspector
.
toolbox
.
doc
.
querySelector
(
"
#
toolbox
-
controls
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
btn
{
type
:
"
mousemove
"
}
inspector
.
toolbox
.
win
)
;
return
new
Promise
(
resolve
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
function
fireCopyEvent
(
element
)
{
const
evt
=
element
.
ownerDocument
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
copy
"
true
true
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
undoChange
(
inspector
)
{
const
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
const
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
async
function
getNodeFrontForSelector
(
selector
inspector
)
{
if
(
selector
)
{
info
(
"
Retrieving
front
for
selector
"
+
selector
)
;
return
getNodeFront
(
selector
inspector
)
;
}
info
(
"
Retrieving
front
for
doctype
node
"
)
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
inspector
.
walker
.
rootNode
)
;
return
nodes
[
0
]
;
}
async
function
poll
(
check
desc
attempts
=
10
timeBetweenAttempts
=
200
)
{
info
(
desc
)
;
for
(
let
i
=
0
;
i
<
attempts
;
i
+
+
)
{
if
(
await
check
(
)
)
{
return
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeBetweenAttempts
)
)
;
}
throw
new
Error
(
Timeout
while
:
{
desc
}
)
;
}
const
getHighlighterHelperFor
=
(
type
)
=
>
async
function
(
{
inspector
testActor
}
)
{
const
front
=
inspector
.
inspector
;
const
highlighter
=
await
front
.
getHighlighterByType
(
type
)
;
let
prefix
=
"
"
;
let
prevX
prevY
;
let
highlightedNode
=
null
;
return
{
set
prefix
(
value
)
{
prefix
=
value
;
}
get
highlightedNode
(
)
{
if
(
!
highlightedNode
)
{
return
null
;
}
return
{
getComputedStyle
:
async
function
(
options
=
{
}
)
{
return
inspector
.
pageStyle
.
getComputed
(
highlightedNode
options
)
;
}
}
;
}
get
actorID
(
)
{
if
(
!
highlighter
)
{
return
null
;
}
return
highlighter
.
actorID
;
}
show
:
async
function
(
selector
=
"
:
root
"
options
frameSelector
=
null
)
{
if
(
frameSelector
)
{
highlightedNode
=
await
getNodeFrontInFrame
(
selector
frameSelector
inspector
)
;
}
else
{
highlightedNode
=
await
getNodeFront
(
selector
inspector
)
;
}
return
highlighter
.
show
(
highlightedNode
options
)
;
}
hide
:
async
function
(
)
{
await
highlighter
.
hide
(
)
;
}
isElementHidden
:
async
function
(
id
)
{
return
(
await
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
"
hidden
"
highlighter
)
)
=
=
=
"
true
"
;
}
getElementTextContent
:
async
function
(
id
)
{
return
testActor
.
getHighlighterNodeTextContent
(
prefix
+
id
highlighter
)
;
}
getElementAttribute
:
async
function
(
id
name
)
{
return
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
}
waitForElementAttributeSet
:
async
function
(
id
name
)
{
await
poll
(
async
function
(
)
{
const
value
=
await
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
set
)
;
}
waitForElementAttributeRemoved
:
async
function
(
id
name
)
{
await
poll
(
async
function
(
)
{
const
value
=
await
testActor
.
getHighlighterNodeAttribute
(
prefix
+
id
name
highlighter
)
;
return
!
value
;
}
Waiting
for
element
{
id
}
to
have
attribute
{
name
}
removed
)
;
}
synthesizeMouse
:
async
function
(
options
)
{
options
=
Object
.
assign
(
{
selector
:
"
:
root
"
}
options
)
;
await
testActor
.
synthesizeMouse
(
options
)
;
}
mouse
:
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
async
function
(
x
=
prevX
y
=
prevY
selector
=
"
:
root
"
)
{
prevX
=
x
;
prevY
=
y
;
await
testActor
.
synthesizeMouse
(
{
selector
x
y
options
:
{
type
:
"
mouse
"
+
name
}
}
)
;
}
}
)
reflow
:
async
function
(
)
{
await
testActor
.
reflow
(
)
;
}
finalize
:
async
function
(
)
{
highlightedNode
=
null
;
await
highlighter
.
finalize
(
)
;
}
}
;
}
;
async
function
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
await
waitForChildrenUpdated
(
inspector
)
;
return
waitForMultipleChildrenUpdates
(
inspector
)
;
}
return
null
;
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
return
new
Promise
(
resolve
=
>
{
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
)
;
}
function
waitForStyleEditor
(
toolbox
href
)
{
info
(
"
Waiting
for
the
toolbox
to
switch
to
the
styleeditor
"
)
;
return
new
Promise
(
resolve
=
>
{
toolbox
.
once
(
"
styleeditor
-
selected
"
)
.
then
(
(
)
=
>
{
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
ok
(
panel
&
&
panel
.
UI
"
Styleeditor
panel
switched
to
front
"
)
;
const
gotEditor
=
editor
=
>
{
const
currentHref
=
editor
.
styleSheet
.
href
;
if
(
!
href
|
|
(
href
&
&
currentHref
.
endsWith
(
href
)
)
)
{
info
(
"
Stylesheet
editor
selected
"
)
;
panel
.
UI
.
off
(
"
editor
-
selected
"
gotEditor
)
;
editor
.
getSourceEditor
(
)
.
then
(
sourceEditor
=
>
{
info
(
"
Stylesheet
editor
fully
loaded
"
)
;
resolve
(
sourceEditor
)
;
}
)
;
return
true
;
}
info
(
"
The
editor
was
incorrect
.
Waiting
for
editor
-
selected
event
.
"
)
;
return
false
;
}
;
if
(
!
gotEditor
(
panel
.
UI
.
selectedEditor
)
)
{
panel
.
UI
.
on
(
"
editor
-
selected
"
gotEditor
)
;
}
}
)
;
}
)
;
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
waitForTab
=
async
function
(
)
{
info
(
"
Waiting
for
a
tab
to
open
"
)
;
await
once
(
gBrowser
.
tabContainer
"
TabOpen
"
)
;
const
tab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
info
(
"
The
tab
load
completed
"
)
;
return
tab
;
}
;
function
synthesizeKeys
(
input
win
)
{
for
(
const
key
of
input
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
win
)
;
}
}
function
focusAndSendKey
(
win
key
)
{
win
.
document
.
documentElement
.
focus
(
)
;
EventUtils
.
sendKey
(
key
win
)
;
}
async
function
assertTooltipShownOnHover
(
tooltip
target
)
{
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
}
)
;
target
.
dispatchEvent
(
mouseEvent
)
;
if
(
!
tooltip
.
isVisible
(
)
)
{
info
(
"
Waiting
for
tooltip
to
be
shown
"
)
;
await
tooltip
.
once
(
"
shown
"
)
;
}
ok
(
tooltip
.
isVisible
(
)
The
tooltip
is
visible
)
;
return
tooltip
;
}
async
function
assertShowPreviewTooltip
(
view
target
)
{
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
}
)
;
target
.
dispatchEvent
(
mouseEvent
)
;
const
name
=
"
previewTooltip
"
;
ok
(
view
.
tooltips
.
_instances
.
has
(
name
)
Tooltip
'
{
name
}
'
has
been
instantiated
)
;
const
tooltip
=
view
.
tooltips
.
getTooltip
(
name
)
;
if
(
!
tooltip
.
isVisible
(
)
)
{
info
(
"
Waiting
for
tooltip
to
be
shown
"
)
;
await
tooltip
.
once
(
"
shown
"
)
;
}
ok
(
tooltip
.
isVisible
(
)
The
tooltip
'
{
name
}
'
is
visible
)
;
return
tooltip
;
}
async
function
assertTooltipHiddenOnMouseOut
(
tooltip
target
)
{
const
mouseEvent
=
new
target
.
ownerDocument
.
defaultView
.
MouseEvent
(
"
mousemove
"
{
bubbles
:
true
relatedTarget
:
target
}
)
;
target
.
parentNode
.
dispatchEvent
(
mouseEvent
)
;
await
tooltip
.
once
(
"
hidden
"
)
;
ok
(
!
tooltip
.
isVisible
(
)
"
The
tooltip
is
hidden
on
mouseout
"
)
;
}
function
getRuleViewRuleEditor
(
view
childrenIndex
nodeIndex
)
{
return
nodeIndex
!
=
=
undefined
?
view
.
element
.
children
[
childrenIndex
]
.
childNodes
[
nodeIndex
]
.
_ruleEditor
:
view
.
element
.
children
[
childrenIndex
]
.
_ruleEditor
;
}
async
function
getDisplayedNodeTextContent
(
selector
inspector
)
{
await
selectNode
(
selector
inspector
)
;
const
container
=
await
getContainerForSelector
(
selector
inspector
)
;
await
inspector
.
markup
.
expandNode
(
container
.
node
)
;
await
waitForMultipleChildrenUpdates
(
inspector
)
;
if
(
container
)
{
const
textContainer
=
container
.
elt
.
querySelector
(
"
pre
"
)
;
return
textContainer
.
textContent
;
}
return
null
;
}
async
function
toggleShapesHighlighter
(
view
selector
property
show
options
=
{
}
)
{
info
(
Toggle
shapes
highlighter
{
show
?
"
on
"
:
"
off
"
}
for
{
property
}
on
{
selector
}
)
;
const
highlighters
=
view
.
highlighters
;
const
container
=
getRuleViewProperty
(
view
selector
property
)
.
valueSpan
;
const
shapesToggle
=
container
.
querySelector
(
"
.
ruleview
-
shapeswatch
"
)
;
const
metaKey
=
options
.
transformMode
;
const
ctrlKey
=
options
.
transformMode
;
if
(
show
)
{
const
onHighlighterShown
=
highlighters
.
once
(
"
shapes
-
highlighter
-
shown
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
metaKey
ctrlKey
}
shapesToggle
view
.
styleWindow
)
;
await
onHighlighterShown
;
}
else
{
const
onHighlighterHidden
=
highlighters
.
once
(
"
shapes
-
highlighter
-
hidden
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
metaKey
ctrlKey
}
shapesToggle
view
.
styleWindow
)
;
await
onHighlighterHidden
;
}
}
async
function
expandContainer
(
inspector
container
)
{
await
inspector
.
markup
.
expandNode
(
container
.
node
)
;
await
waitForMultipleChildrenUpdates
(
inspector
)
;
}
async
function
expandContainerByClick
(
inspector
container
)
{
const
onChildren
=
waitForChildrenUpdated
(
inspector
)
;
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
expander
{
}
inspector
.
markup
.
doc
.
defaultView
)
;
await
onChildren
;
await
onUpdated
;
}
async
function
simulateColorPickerChange
(
colorPicker
newRgba
)
{
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
const
spectrum
=
await
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
}
