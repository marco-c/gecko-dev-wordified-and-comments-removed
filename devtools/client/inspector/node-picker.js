"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
class
NodePicker
extends
EventEmitter
{
constructor
(
commands
selection
)
{
super
(
)
;
this
.
commands
=
commands
;
this
.
targetCommand
=
commands
.
targetCommand
;
this
.
isPicking
=
false
;
this
.
doFocus
=
false
;
}
#
currentInspectorFronts
=
new
Set
(
)
;
togglePicker
=
doFocus
=
>
{
if
(
this
.
isPicking
)
{
return
this
.
stop
(
{
canceled
:
true
}
)
;
}
return
this
.
start
(
doFocus
)
;
}
;
#
onWebExtensionDocumentEventAvailable
=
async
resources
=
>
{
const
{
DOCUMENT_EVENT
}
=
this
.
commands
.
resourceCommand
.
TYPES
;
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
=
=
DOCUMENT_EVENT
&
&
resource
.
name
=
=
=
"
dom
-
complete
"
&
&
resource
.
targetFront
.
isTopLevel
&
&
resource
.
isFrameSwitching
)
{
const
inspectorFront
=
await
resource
.
targetFront
.
getFront
(
"
inspector
"
)
;
await
inspectorFront
.
walker
.
cancelPick
(
)
;
await
inspectorFront
.
walker
.
pick
(
this
.
doFocus
)
;
this
.
emitForTests
(
"
node
-
picker
-
webextension
-
target
-
restarted
"
)
;
}
}
}
;
#
onInspectorFrontAvailable
=
async
inspectorFront
=
>
{
this
.
#
currentInspectorFronts
.
add
(
inspectorFront
)
;
await
inspectorFront
.
initialize
(
)
;
const
{
walker
}
=
inspectorFront
;
walker
.
on
(
"
picker
-
node
-
hovered
"
this
.
#
onHovered
)
;
walker
.
on
(
"
picker
-
node
-
picked
"
this
.
#
onPicked
)
;
walker
.
on
(
"
picker
-
node
-
previewed
"
this
.
#
onPreviewed
)
;
walker
.
on
(
"
picker
-
node
-
canceled
"
this
.
#
onCanceled
)
;
await
walker
.
pick
(
this
.
doFocus
)
;
this
.
emitForTests
(
"
inspector
-
front
-
ready
-
for
-
picker
"
walker
)
;
}
;
#
onInspectorFrontDestroyed
=
async
(
inspectorFront
{
isDestroyCodepath
}
=
{
}
)
=
>
{
this
.
#
currentInspectorFronts
.
delete
(
inspectorFront
)
;
const
{
walker
}
=
inspectorFront
;
if
(
!
walker
)
{
return
;
}
walker
.
off
(
"
picker
-
node
-
hovered
"
this
.
#
onHovered
)
;
walker
.
off
(
"
picker
-
node
-
picked
"
this
.
#
onPicked
)
;
walker
.
off
(
"
picker
-
node
-
previewed
"
this
.
#
onPreviewed
)
;
walker
.
off
(
"
picker
-
node
-
canceled
"
this
.
#
onCanceled
)
;
if
(
!
isDestroyCodepath
)
{
await
walker
.
cancelPick
(
)
;
}
}
;
#
onTargetAvailable
=
async
(
{
targetFront
}
)
=
>
{
targetFront
.
watchFronts
(
"
inspector
"
this
.
#
onInspectorFrontAvailable
this
.
#
onInspectorFrontDestroyed
)
;
}
;
start
=
async
doFocus
=
>
{
if
(
this
.
isPicking
)
{
return
;
}
this
.
isPicking
=
true
;
this
.
doFocus
=
doFocus
;
this
.
emit
(
"
picker
-
starting
"
)
;
this
.
targetCommand
.
watchTargets
(
{
types
:
this
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
#
onTargetAvailable
}
)
;
if
(
this
.
targetCommand
.
descriptorFront
.
isWebExtension
)
{
await
this
.
commands
.
resourceCommand
.
watchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
#
onWebExtensionDocumentEventAvailable
}
)
;
}
this
.
emit
(
"
picker
-
started
"
)
;
}
;
stop
=
async
(
{
isDestroyCodepath
canceled
}
=
{
}
)
=
>
{
if
(
!
this
.
isPicking
)
{
return
;
}
this
.
isPicking
=
false
;
this
.
doFocus
=
false
;
this
.
targetCommand
.
unwatchTargets
(
{
types
:
this
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
#
onTargetAvailable
}
)
;
if
(
this
.
targetCommand
.
descriptorFront
.
isWebExtension
)
{
this
.
commands
.
resourceCommand
.
unwatchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
#
onWebExtensionDocumentEventAvailable
}
)
;
}
const
promises
=
[
]
;
for
(
const
inspectorFront
of
this
.
#
currentInspectorFronts
)
{
promises
.
push
(
this
.
#
onInspectorFrontDestroyed
(
inspectorFront
{
isDestroyCodepath
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
this
.
#
currentInspectorFronts
.
clear
(
)
;
this
.
emit
(
"
picker
-
stopped
"
)
;
if
(
canceled
)
{
this
.
emit
(
"
picker
-
node
-
canceled
"
)
;
}
}
;
destroy
(
)
{
this
.
stop
(
{
isDestroyCodepath
:
true
}
)
;
this
.
targetCommand
=
null
;
this
.
commands
=
null
;
}
#
onHovered
=
data
=
>
{
this
.
emit
(
"
picker
-
node
-
hovered
"
data
.
node
)
;
for
(
const
inspectorFront
of
this
.
#
currentInspectorFronts
)
{
if
(
inspectorFront
.
walker
!
=
=
data
.
node
.
walkerFront
)
{
inspectorFront
.
walker
.
clearPicker
(
)
;
}
}
}
;
#
onPicked
=
data
=
>
{
this
.
emit
(
"
picker
-
node
-
picked
"
data
.
node
)
;
return
this
.
stop
(
)
;
}
;
#
onPreviewed
=
data
=
>
{
this
.
emit
(
"
picker
-
node
-
previewed
"
data
.
node
)
;
}
;
#
onCanceled
=
data
=
>
{
return
this
.
stop
(
{
canceled
:
true
}
)
;
}
;
}
module
.
exports
=
NodePicker
;
