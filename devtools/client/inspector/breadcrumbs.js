"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
FocusManager
=
Services
.
focus
;
const
{
waitForTick
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
ELLIPSIS
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
const
MAX_LABEL_LENGTH
=
40
;
const
NS_XHTML
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SCROLL_REPEAT_MS
=
100
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
true
)
;
function
ArrowScrollBox
(
win
container
)
{
this
.
win
=
win
;
this
.
doc
=
win
.
document
;
this
.
container
=
container
;
EventEmitter
.
decorate
(
this
)
;
this
.
init
(
)
;
}
ArrowScrollBox
.
prototype
=
{
init
:
function
(
)
{
this
.
constructHtml
(
)
;
this
.
onUnderflow
(
)
;
this
.
onScroll
=
this
.
onScroll
.
bind
(
this
)
;
this
.
onStartBtnClick
=
this
.
onStartBtnClick
.
bind
(
this
)
;
this
.
onEndBtnClick
=
this
.
onEndBtnClick
.
bind
(
this
)
;
this
.
onStartBtnDblClick
=
this
.
onStartBtnDblClick
.
bind
(
this
)
;
this
.
onEndBtnDblClick
=
this
.
onEndBtnDblClick
.
bind
(
this
)
;
this
.
onUnderflow
=
this
.
onUnderflow
.
bind
(
this
)
;
this
.
onOverflow
=
this
.
onOverflow
.
bind
(
this
)
;
this
.
inner
.
addEventListener
(
"
scroll
"
this
.
onScroll
false
)
;
this
.
startBtn
.
addEventListener
(
"
mousedown
"
this
.
onStartBtnClick
false
)
;
this
.
endBtn
.
addEventListener
(
"
mousedown
"
this
.
onEndBtnClick
false
)
;
this
.
startBtn
.
addEventListener
(
"
dblclick
"
this
.
onStartBtnDblClick
false
)
;
this
.
endBtn
.
addEventListener
(
"
dblclick
"
this
.
onEndBtnDblClick
false
)
;
this
.
inner
.
addEventListener
(
"
underflow
"
this
.
onUnderflow
false
)
;
this
.
inner
.
addEventListener
(
"
overflow
"
this
.
onOverflow
false
)
;
}
clickOrHold
:
function
(
repeatFn
)
{
let
timer
;
let
container
=
this
.
container
;
function
handleClick
(
)
{
cancelHold
(
)
;
repeatFn
(
)
;
}
let
window
=
this
.
win
;
function
cancelHold
(
)
{
window
.
clearTimeout
(
timer
)
;
container
.
removeEventListener
(
"
mouseout
"
cancelHold
false
)
;
container
.
removeEventListener
(
"
mouseup
"
handleClick
false
)
;
}
function
repeated
(
)
{
repeatFn
(
)
;
timer
=
window
.
setTimeout
(
repeated
SCROLL_REPEAT_MS
)
;
}
container
.
addEventListener
(
"
mouseout
"
cancelHold
false
)
;
container
.
addEventListener
(
"
mouseup
"
handleClick
false
)
;
timer
=
window
.
setTimeout
(
repeated
SCROLL_REPEAT_MS
)
;
}
onStartBtnDblClick
:
function
(
)
{
let
children
=
this
.
inner
.
childNodes
;
if
(
children
.
length
<
1
)
{
return
;
}
let
element
=
this
.
inner
.
childNodes
[
0
]
;
element
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
}
onEndBtnDblClick
:
function
(
)
{
let
children
=
this
.
inner
.
childNodes
;
if
(
children
.
length
<
1
)
{
return
;
}
let
element
=
children
[
children
.
length
-
1
]
;
element
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
}
onStartBtnClick
:
function
(
)
{
let
scrollToStart
=
(
)
=
>
{
let
element
=
this
.
getFirstInvisibleElement
(
)
;
if
(
!
element
)
{
return
;
}
element
.
scrollIntoView
(
{
block
:
"
start
"
behavior
:
"
smooth
"
}
)
;
}
;
this
.
clickOrHold
(
scrollToStart
)
;
}
onEndBtnClick
:
function
(
)
{
let
scrollToEnd
=
(
)
=
>
{
let
element
=
this
.
getLastInvisibleElement
(
)
;
if
(
!
element
)
{
return
;
}
element
.
scrollIntoView
(
{
block
:
"
end
"
behavior
:
"
smooth
"
}
)
;
}
;
this
.
clickOrHold
(
scrollToEnd
)
;
}
onScroll
:
function
(
)
{
let
first
=
this
.
getFirstInvisibleElement
(
)
;
if
(
!
first
)
{
this
.
startBtn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
startBtn
.
removeAttribute
(
"
disabled
"
)
;
}
let
last
=
this
.
getLastInvisibleElement
(
)
;
if
(
!
last
)
{
this
.
endBtn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
endBtn
.
removeAttribute
(
"
disabled
"
)
;
}
}
onUnderflow
:
function
(
)
{
this
.
startBtn
.
style
.
visibility
=
"
collapse
"
;
this
.
endBtn
.
style
.
visibility
=
"
collapse
"
;
this
.
emit
(
"
underflow
"
)
;
}
onOverflow
:
function
(
)
{
this
.
startBtn
.
style
.
visibility
=
"
visible
"
;
this
.
endBtn
.
style
.
visibility
=
"
visible
"
;
this
.
emit
(
"
overflow
"
)
;
}
getFirstInvisibleElement
:
function
(
)
{
let
start
=
this
.
inner
.
scrollLeft
;
let
end
=
this
.
inner
.
scrollLeft
+
this
.
inner
.
clientWidth
;
let
crumbs
=
this
.
inner
.
childNodes
;
for
(
let
i
=
crumbs
.
length
-
1
;
i
>
-
1
;
i
-
-
)
{
let
element
=
crumbs
[
i
]
;
let
elementRight
=
element
.
offsetLeft
+
element
.
offsetWidth
;
if
(
element
.
offsetLeft
<
start
)
{
if
(
elementRight
>
=
end
)
{
continue
;
}
return
element
;
}
}
return
null
;
}
getLastInvisibleElement
:
function
(
)
{
let
end
=
this
.
inner
.
scrollLeft
+
this
.
inner
.
clientWidth
;
let
elementStart
=
0
;
for
(
let
element
of
this
.
inner
.
childNodes
)
{
let
elementEnd
=
elementStart
+
element
.
offsetWidth
;
if
(
elementEnd
>
end
)
{
if
(
elementStart
>
this
.
inner
.
scrollLeft
)
{
return
element
;
}
}
elementStart
=
elementEnd
;
}
return
null
;
}
constructHtml
:
function
(
)
{
this
.
startBtn
=
this
.
createElement
(
"
div
"
"
scrollbutton
-
up
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
toolbarbutton
-
icon
"
this
.
startBtn
)
;
this
.
createElement
(
"
div
"
"
arrowscrollbox
-
overflow
-
start
-
indicator
"
this
.
container
)
;
this
.
inner
=
this
.
createElement
(
"
div
"
"
html
-
arrowscrollbox
-
inner
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
arrowscrollbox
-
overflow
-
end
-
indicator
"
this
.
container
)
;
this
.
endBtn
=
this
.
createElement
(
"
div
"
"
scrollbutton
-
down
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
toolbarbutton
-
icon
"
this
.
endBtn
)
;
}
createElement
:
function
(
tagName
className
parent
)
{
let
el
=
this
.
doc
.
createElementNS
(
NS_XHTML
tagName
)
;
el
.
className
=
className
;
if
(
parent
)
{
parent
.
appendChild
(
el
)
;
}
return
el
;
}
destroy
:
function
(
)
{
this
.
inner
.
removeEventListener
(
"
scroll
"
this
.
onScroll
false
)
;
this
.
startBtn
.
removeEventListener
(
"
mousedown
"
this
.
onStartBtnClick
false
)
;
this
.
endBtn
.
removeEventListener
(
"
mousedown
"
this
.
onEndBtnClick
false
)
;
this
.
startBtn
.
removeEventListener
(
"
dblclick
"
this
.
onStartBtnDblClick
false
)
;
this
.
endBtn
.
removeEventListener
(
"
dblclick
"
this
.
onRightBtnDblClick
false
)
;
this
.
inner
.
removeEventListener
(
"
underflow
"
this
.
onUnderflow
false
)
;
this
.
inner
.
removeEventListener
(
"
overflow
"
this
.
onOverflow
false
)
;
}
}
;
function
HTMLBreadcrumbs
(
inspector
)
{
this
.
inspector
=
inspector
;
this
.
selection
=
this
.
inspector
.
selection
;
this
.
chromeWin
=
this
.
inspector
.
panelWin
;
this
.
chromeDoc
=
this
.
inspector
.
panelDoc
;
this
.
_init
(
)
;
}
exports
.
HTMLBreadcrumbs
=
HTMLBreadcrumbs
;
HTMLBreadcrumbs
.
prototype
=
{
get
walker
(
)
{
return
this
.
inspector
.
walker
;
}
_init
:
function
(
)
{
this
.
outer
=
this
.
chromeDoc
.
getElementById
(
"
inspector
-
breadcrumbs
"
)
;
this
.
arrowScrollBox
=
new
ArrowScrollBox
(
this
.
chromeWin
this
.
outer
)
;
this
.
container
=
this
.
arrowScrollBox
.
inner
;
this
.
scroll
=
this
.
scroll
.
bind
(
this
)
;
this
.
arrowScrollBox
.
on
(
"
overflow
"
this
.
scroll
)
;
this
.
separators
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
div
"
)
;
this
.
separators
.
className
=
"
breadcrumb
-
separator
-
container
"
;
this
.
separators
.
innerHTML
=
"
<
div
id
=
'
breadcrumb
-
separator
-
before
'
>
<
/
div
>
"
+
"
<
div
id
=
'
breadcrumb
-
separator
-
after
'
>
<
/
div
>
"
+
"
<
div
id
=
'
breadcrumb
-
separator
-
normal
'
>
<
/
div
>
"
;
this
.
container
.
parentNode
.
appendChild
(
this
.
separators
)
;
this
.
outer
.
addEventListener
(
"
click
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
mouseover
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
mouseout
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
focus
"
this
true
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
chromeWin
target
:
this
.
outer
}
)
;
this
.
handleShortcut
=
this
.
handleShortcut
.
bind
(
this
)
;
this
.
shortcuts
.
on
(
"
Right
"
this
.
handleShortcut
)
;
this
.
shortcuts
.
on
(
"
Left
"
this
.
handleShortcut
)
;
this
.
shortcuts
.
on
(
"
Tab
"
this
.
handleShortcut
)
;
this
.
shortcuts
.
on
(
"
Shift
+
Tab
"
this
.
handleShortcut
)
;
this
.
nodeHierarchy
=
[
]
;
this
.
currentIndex
=
-
1
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
updateSelectors
=
this
.
updateSelectors
.
bind
(
this
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
selection
.
on
(
"
pseudoclass
"
this
.
updateSelectors
)
;
this
.
selection
.
on
(
"
attribute
-
changed
"
this
.
updateSelectors
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
update
)
;
this
.
update
(
)
;
}
prettyPrintNodeAsText
:
function
(
node
)
{
let
text
=
node
.
displayName
;
if
(
node
.
isPseudoElement
)
{
text
=
node
.
isBeforePseudoElement
?
"
:
:
before
"
:
"
:
:
after
"
;
}
if
(
node
.
id
)
{
text
+
=
"
#
"
+
node
.
id
;
}
if
(
node
.
className
)
{
let
classList
=
node
.
className
.
split
(
/
\
s
+
/
)
;
for
(
let
i
=
0
;
i
<
classList
.
length
;
i
+
+
)
{
text
+
=
"
.
"
+
classList
[
i
]
;
}
}
for
(
let
pseudo
of
node
.
pseudoClassLocks
)
{
text
+
=
pseudo
;
}
return
text
;
}
prettyPrintNodeAsXHTML
:
function
(
node
)
{
let
tagLabel
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
tagLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
tag
plain
"
;
let
idLabel
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
idLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
id
plain
"
;
let
classesLabel
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
classesLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
classes
plain
"
;
let
pseudosLabel
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
pseudosLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
pseudo
-
classes
plain
"
;
let
tagText
=
node
.
displayName
;
if
(
node
.
isPseudoElement
)
{
tagText
=
node
.
isBeforePseudoElement
?
"
:
:
before
"
:
"
:
:
after
"
;
}
let
idText
=
node
.
id
?
(
"
#
"
+
node
.
id
)
:
"
"
;
let
classesText
=
"
"
;
if
(
node
.
className
)
{
let
classList
=
node
.
className
.
split
(
/
\
s
+
/
)
;
for
(
let
i
=
0
;
i
<
classList
.
length
;
i
+
+
)
{
classesText
+
=
"
.
"
+
classList
[
i
]
;
}
}
let
maxTagLength
=
MAX_LABEL_LENGTH
;
let
maxIdLength
=
MAX_LABEL_LENGTH
-
tagText
.
length
;
let
maxClassLength
=
MAX_LABEL_LENGTH
-
tagText
.
length
-
idText
.
length
;
if
(
tagText
.
length
>
maxTagLength
)
{
tagText
=
tagText
.
substr
(
0
maxTagLength
)
+
ELLIPSIS
;
idText
=
classesText
=
"
"
;
}
else
if
(
idText
.
length
>
maxIdLength
)
{
idText
=
idText
.
substr
(
0
maxIdLength
)
+
ELLIPSIS
;
classesText
=
"
"
;
}
else
if
(
classesText
.
length
>
maxClassLength
)
{
classesText
=
classesText
.
substr
(
0
maxClassLength
)
+
ELLIPSIS
;
}
tagLabel
.
textContent
=
tagText
;
idLabel
.
textContent
=
idText
;
classesLabel
.
textContent
=
classesText
;
pseudosLabel
.
textContent
=
node
.
pseudoClassLocks
.
join
(
"
"
)
;
let
fragment
=
this
.
chromeDoc
.
createDocumentFragment
(
)
;
fragment
.
appendChild
(
tagLabel
)
;
fragment
.
appendChild
(
idLabel
)
;
fragment
.
appendChild
(
classesLabel
)
;
fragment
.
appendChild
(
pseudosLabel
)
;
return
fragment
;
}
handleEvent
:
function
(
event
)
{
if
(
event
.
type
=
=
"
click
"
&
&
event
.
button
=
=
0
)
{
this
.
handleClick
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseover
"
)
{
this
.
handleMouseOver
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseout
"
)
{
this
.
handleMouseLeave
(
event
)
;
}
else
if
(
event
.
type
=
=
"
focus
"
)
{
this
.
handleFocus
(
event
)
;
}
}
handleFocus
:
function
(
event
)
{
let
control
=
this
.
container
.
querySelector
(
"
.
breadcrumbs
-
widget
-
item
[
checked
]
"
)
;
if
(
!
this
.
suspendFocus
&
&
control
&
&
control
!
=
=
event
.
target
)
{
event
.
preventDefault
(
)
;
control
.
focus
(
)
;
}
this
.
suspendFocus
=
false
;
}
handleClick
:
function
(
event
)
{
this
.
suspendFocus
=
true
;
let
target
=
event
.
originalTarget
;
if
(
target
.
tagName
=
=
"
button
"
)
{
target
.
onBreadcrumbsClick
(
)
;
}
}
handleMouseOver
:
function
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
target
.
tagName
=
=
"
button
"
)
{
target
.
onBreadcrumbsHover
(
)
;
}
}
handleMouseOut
:
function
(
event
)
{
this
.
inspector
.
toolbox
.
highlighterUtils
.
unhighlight
(
)
;
}
handleShortcut
:
function
(
name
event
)
{
if
(
!
this
.
selection
.
isElementNode
(
)
)
{
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
keyPromise
=
(
this
.
keyPromise
|
|
promise
.
resolve
(
null
)
)
.
then
(
(
)
=
>
{
if
(
name
=
=
=
"
Left
"
&
&
this
.
currentIndex
!
=
0
)
{
let
node
=
this
.
nodeHierarchy
[
this
.
currentIndex
-
1
]
.
node
;
return
this
.
selection
.
setNodeFront
(
node
"
breadcrumbs
"
)
;
}
else
if
(
name
=
=
=
"
Right
"
&
&
this
.
currentIndex
<
this
.
nodeHierarchy
.
length
-
1
)
{
let
node
=
this
.
nodeHierarchy
[
this
.
currentIndex
+
1
]
.
node
;
return
this
.
selection
.
setNodeFront
(
node
"
breadcrumbs
"
)
;
}
else
if
(
name
=
=
=
"
Tab
"
)
{
let
last
=
this
.
container
.
lastChild
;
while
(
last
&
&
last
.
lastChild
)
{
last
=
last
.
lastChild
;
}
FocusManager
.
moveFocus
(
this
.
chromeWin
last
FocusManager
.
MOVEFOCUS_FORWARD
0
)
;
}
else
if
(
name
=
=
=
"
Shift
+
Tab
"
)
{
let
elt
=
this
.
container
;
FocusManager
.
moveFocus
(
this
.
chromeWin
elt
FocusManager
.
MOVEFOCUS_BACKWARD
0
)
;
}
return
null
;
}
)
;
}
destroy
:
function
(
)
{
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
selection
.
off
(
"
pseudoclass
"
this
.
updateSelectors
)
;
this
.
selection
.
off
(
"
attribute
-
changed
"
this
.
updateSelectors
)
;
this
.
inspector
.
off
(
"
markupmutation
"
this
.
update
)
;
this
.
container
.
removeEventListener
(
"
click
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
mouseover
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
mouseout
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
focus
"
this
true
)
;
this
.
shortcuts
.
destroy
(
)
;
this
.
empty
(
)
;
this
.
separators
.
remove
(
)
;
this
.
arrowScrollBox
.
off
(
"
overflow
"
this
.
scroll
)
;
this
.
arrowScrollBox
.
destroy
(
)
;
this
.
arrowScrollBox
=
null
;
this
.
outer
=
null
;
this
.
container
=
null
;
this
.
separators
=
null
;
this
.
nodeHierarchy
=
null
;
this
.
isDestroyed
=
true
;
}
empty
:
function
(
)
{
while
(
this
.
container
.
hasChildNodes
(
)
)
{
this
.
container
.
firstChild
.
remove
(
)
;
}
}
setCursor
:
function
(
index
)
{
if
(
this
.
currentIndex
>
-
1
&
&
this
.
currentIndex
<
this
.
nodeHierarchy
.
length
)
{
this
.
nodeHierarchy
[
this
.
currentIndex
]
.
button
.
removeAttribute
(
"
checked
"
)
;
}
if
(
index
>
-
1
)
{
this
.
nodeHierarchy
[
index
]
.
button
.
setAttribute
(
"
checked
"
"
true
"
)
;
if
(
this
.
hadFocus
)
{
this
.
nodeHierarchy
[
index
]
.
button
.
focus
(
)
;
}
}
this
.
currentIndex
=
index
;
}
indexOf
:
function
(
node
)
{
for
(
let
i
=
this
.
nodeHierarchy
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
this
.
nodeHierarchy
[
i
]
.
node
=
=
=
node
)
{
return
i
;
}
}
return
-
1
;
}
cutAfter
:
function
(
index
)
{
while
(
this
.
nodeHierarchy
.
length
>
(
index
+
1
)
)
{
let
toRemove
=
this
.
nodeHierarchy
.
pop
(
)
;
this
.
container
.
removeChild
(
toRemove
.
button
)
;
}
}
buildButton
:
function
(
node
)
{
let
button
=
this
.
chromeDoc
.
createElementNS
(
NS_XHTML
"
button
"
)
;
button
.
appendChild
(
this
.
prettyPrintNodeAsXHTML
(
node
)
)
;
button
.
className
=
"
breadcrumbs
-
widget
-
item
"
;
button
.
setAttribute
(
"
title
"
this
.
prettyPrintNodeAsText
(
node
)
)
;
button
.
onclick
=
(
)
=
>
{
button
.
focus
(
)
;
}
;
button
.
onBreadcrumbsClick
=
(
)
=
>
{
this
.
selection
.
setNodeFront
(
node
"
breadcrumbs
"
)
;
}
;
button
.
onBreadcrumbsHover
=
(
)
=
>
{
this
.
inspector
.
toolbox
.
highlighterUtils
.
highlightNodeFront
(
node
)
;
}
;
return
button
;
}
expand
:
function
(
node
)
{
let
fragment
=
this
.
chromeDoc
.
createDocumentFragment
(
)
;
let
lastButtonInserted
=
null
;
let
originalLength
=
this
.
nodeHierarchy
.
length
;
let
stopNode
=
null
;
if
(
originalLength
>
0
)
{
stopNode
=
this
.
nodeHierarchy
[
originalLength
-
1
]
.
node
;
}
while
(
node
&
&
node
!
=
stopNode
)
{
if
(
node
.
tagName
)
{
let
button
=
this
.
buildButton
(
node
)
;
fragment
.
insertBefore
(
button
lastButtonInserted
)
;
lastButtonInserted
=
button
;
this
.
nodeHierarchy
.
splice
(
originalLength
0
{
node
button
currentPrettyPrintText
:
this
.
prettyPrintNodeAsText
(
node
)
}
)
;
}
node
=
node
.
parentNode
(
)
;
}
this
.
container
.
appendChild
(
fragment
this
.
container
.
firstChild
)
;
}
getCommonAncestor
:
function
(
node
)
{
while
(
node
)
{
let
idx
=
this
.
indexOf
(
node
)
;
if
(
idx
>
-
1
)
{
return
idx
;
}
node
=
node
.
parentNode
(
)
;
}
return
-
1
;
}
scroll
:
function
(
)
{
if
(
!
this
.
isDestroyed
)
{
let
element
=
this
.
nodeHierarchy
[
this
.
currentIndex
]
.
button
;
element
.
scrollIntoView
(
{
block
:
"
end
"
behavior
:
"
smooth
"
}
)
;
}
}
updateSelectors
:
function
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
for
(
let
i
=
this
.
nodeHierarchy
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
{
node
button
currentPrettyPrintText
}
=
this
.
nodeHierarchy
[
i
]
;
let
textOutput
=
this
.
prettyPrintNodeAsText
(
node
)
;
if
(
currentPrettyPrintText
=
=
=
textOutput
)
{
continue
;
}
while
(
button
.
hasChildNodes
(
)
)
{
button
.
firstChild
.
remove
(
)
;
}
button
.
appendChild
(
this
.
prettyPrintNodeAsXHTML
(
node
)
)
;
button
.
setAttribute
(
"
title
"
textOutput
)
;
this
.
nodeHierarchy
[
i
]
.
currentPrettyPrintText
=
textOutput
;
}
}
_hasInterestingMutations
:
function
(
mutations
)
{
if
(
!
mutations
|
|
!
mutations
.
length
)
{
return
false
;
}
for
(
let
{
type
added
removed
target
attributeName
}
of
mutations
)
{
if
(
type
=
=
=
"
childList
"
)
{
return
added
.
some
(
node
=
>
this
.
indexOf
(
node
)
>
-
1
)
|
|
removed
.
some
(
node
=
>
this
.
indexOf
(
node
)
>
-
1
)
;
}
else
if
(
type
=
=
=
"
attributes
"
&
&
this
.
indexOf
(
target
)
>
-
1
)
{
return
attributeName
=
=
=
"
class
"
|
|
attributeName
=
=
=
"
id
"
;
}
}
return
false
;
}
update
:
function
(
reason
mutations
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
let
hasInterestingMutations
=
this
.
_hasInterestingMutations
(
mutations
)
;
if
(
reason
=
=
=
"
markupmutation
"
&
&
!
hasInterestingMutations
)
{
return
;
}
let
cmdDispatcher
=
this
.
chromeDoc
.
commandDispatcher
;
this
.
hadFocus
=
(
cmdDispatcher
.
focusedElement
&
&
cmdDispatcher
.
focusedElement
.
parentNode
=
=
this
.
container
)
;
if
(
!
this
.
selection
.
isConnected
(
)
)
{
this
.
cutAfter
(
-
1
)
;
return
;
}
if
(
reason
=
=
=
"
markupmutation
"
)
{
for
(
let
{
type
removed
}
of
mutations
)
{
if
(
type
!
=
=
"
childList
"
)
{
continue
;
}
for
(
let
node
of
removed
)
{
let
removedIndex
=
this
.
indexOf
(
node
)
;
if
(
removedIndex
>
-
1
)
{
this
.
cutAfter
(
removedIndex
-
1
)
;
}
}
}
}
if
(
!
this
.
selection
.
isElementNode
(
)
)
{
this
.
setCursor
(
-
1
)
;
return
;
}
let
idx
=
this
.
indexOf
(
this
.
selection
.
nodeFront
)
;
if
(
idx
>
-
1
&
&
!
hasInterestingMutations
)
{
this
.
setCursor
(
idx
)
;
}
else
{
if
(
this
.
nodeHierarchy
.
length
>
0
)
{
let
parent
=
this
.
selection
.
nodeFront
.
parentNode
(
)
;
let
ancestorIdx
=
this
.
getCommonAncestor
(
parent
)
;
this
.
cutAfter
(
ancestorIdx
)
;
}
this
.
expand
(
this
.
selection
.
nodeFront
)
;
idx
=
this
.
indexOf
(
this
.
selection
.
nodeFront
)
;
this
.
setCursor
(
idx
)
;
}
let
doneUpdating
=
this
.
inspector
.
updating
(
"
breadcrumbs
"
)
;
this
.
updateSelectors
(
)
;
waitForTick
(
)
.
then
(
(
)
=
>
{
this
.
scroll
(
)
;
this
.
inspector
.
emit
(
"
breadcrumbs
-
updated
"
this
.
selection
.
nodeFront
)
;
doneUpdating
(
)
;
}
e
=
>
{
if
(
!
this
.
isDestroyed
)
{
console
.
error
(
e
)
;
}
}
)
;
}
}
;
