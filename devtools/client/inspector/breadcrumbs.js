"
use
strict
"
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
{
ELLIPSIS
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
MAX_LABEL_LENGTH
=
40
;
const
NS_XHTML
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SCROLL_REPEAT_MS
=
100
;
const
SCROLL_MARGIN
=
1
;
const
SHADOW_ROOT_TAGNAME
=
"
#
shadow
-
root
"
;
function
ArrowScrollBox
(
win
container
)
{
this
.
win
=
win
;
this
.
doc
=
win
.
document
;
this
.
container
=
container
;
EventEmitter
.
decorate
(
this
)
;
this
.
init
(
)
;
}
ArrowScrollBox
.
prototype
=
{
scrollBehavior
:
"
smooth
"
init
(
)
{
this
.
constructHtml
(
)
;
this
.
onScroll
=
this
.
onScroll
.
bind
(
this
)
;
this
.
onStartBtnClick
=
this
.
onStartBtnClick
.
bind
(
this
)
;
this
.
onEndBtnClick
=
this
.
onEndBtnClick
.
bind
(
this
)
;
this
.
onStartBtnDblClick
=
this
.
onStartBtnDblClick
.
bind
(
this
)
;
this
.
onEndBtnDblClick
=
this
.
onEndBtnDblClick
.
bind
(
this
)
;
this
.
onUnderflow
=
this
.
onUnderflow
.
bind
(
this
)
;
this
.
onOverflow
=
this
.
onOverflow
.
bind
(
this
)
;
this
.
inner
.
addEventListener
(
"
scroll
"
this
.
onScroll
)
;
this
.
startBtn
.
addEventListener
(
"
mousedown
"
this
.
onStartBtnClick
)
;
this
.
endBtn
.
addEventListener
(
"
mousedown
"
this
.
onEndBtnClick
)
;
this
.
startBtn
.
addEventListener
(
"
dblclick
"
this
.
onStartBtnDblClick
)
;
this
.
endBtn
.
addEventListener
(
"
dblclick
"
this
.
onEndBtnDblClick
)
;
this
.
inner
.
addEventListener
(
"
underflow
"
this
.
onUnderflow
)
;
this
.
inner
.
addEventListener
(
"
overflow
"
this
.
onOverflow
)
;
}
scrollToElement
(
element
block
)
{
element
.
scrollIntoView
(
{
block
behavior
:
this
.
scrollBehavior
}
)
;
}
clickOrHold
(
repeatFn
)
{
let
timer
;
const
container
=
this
.
container
;
function
handleClick
(
)
{
cancelHold
(
)
;
repeatFn
(
)
;
}
const
window
=
this
.
win
;
function
cancelHold
(
)
{
window
.
clearTimeout
(
timer
)
;
container
.
removeEventListener
(
"
mouseout
"
cancelHold
)
;
container
.
removeEventListener
(
"
mouseup
"
handleClick
)
;
}
function
repeated
(
)
{
repeatFn
(
)
;
timer
=
window
.
setTimeout
(
repeated
SCROLL_REPEAT_MS
)
;
}
container
.
addEventListener
(
"
mouseout
"
cancelHold
)
;
container
.
addEventListener
(
"
mouseup
"
handleClick
)
;
timer
=
window
.
setTimeout
(
repeated
SCROLL_REPEAT_MS
)
;
}
onStartBtnDblClick
(
)
{
const
children
=
this
.
inner
.
childNodes
;
if
(
children
.
length
<
1
)
{
return
;
}
const
element
=
this
.
inner
.
childNodes
[
0
]
;
this
.
scrollToElement
(
element
"
start
"
)
;
}
onEndBtnDblClick
(
)
{
const
children
=
this
.
inner
.
childNodes
;
if
(
children
.
length
<
1
)
{
return
;
}
const
element
=
children
[
children
.
length
-
1
]
;
this
.
scrollToElement
(
element
"
start
"
)
;
}
onStartBtnClick
(
)
{
const
scrollToStart
=
(
)
=
>
{
const
element
=
this
.
getFirstInvisibleElement
(
)
;
if
(
!
element
)
{
return
;
}
this
.
scrollToElement
(
element
"
start
"
)
;
}
;
this
.
clickOrHold
(
scrollToStart
)
;
}
onEndBtnClick
(
)
{
const
scrollToEnd
=
(
)
=
>
{
const
element
=
this
.
getLastInvisibleElement
(
)
;
if
(
!
element
)
{
return
;
}
this
.
scrollToElement
(
element
"
end
"
)
;
}
;
this
.
clickOrHold
(
scrollToEnd
)
;
}
onScroll
(
)
{
const
first
=
this
.
getFirstInvisibleElement
(
)
;
if
(
!
first
)
{
this
.
startBtn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
startBtn
.
removeAttribute
(
"
disabled
"
)
;
}
const
last
=
this
.
getLastInvisibleElement
(
)
;
if
(
!
last
)
{
this
.
endBtn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
{
this
.
endBtn
.
removeAttribute
(
"
disabled
"
)
;
}
}
onUnderflow
(
)
{
this
.
startBtn
.
style
.
visibility
=
"
collapse
"
;
this
.
endBtn
.
style
.
visibility
=
"
collapse
"
;
this
.
emit
(
"
underflow
"
)
;
}
onOverflow
(
)
{
this
.
startBtn
.
style
.
visibility
=
"
visible
"
;
this
.
endBtn
.
style
.
visibility
=
"
visible
"
;
this
.
emit
(
"
overflow
"
)
;
}
elementLeftOfContainer
(
left
right
elementLeft
elementRight
)
{
return
(
elementLeft
<
left
-
SCROLL_MARGIN
&
&
elementRight
<
right
-
SCROLL_MARGIN
)
;
}
elementRightOfContainer
(
left
right
elementLeft
elementRight
)
{
return
(
elementLeft
>
left
+
SCROLL_MARGIN
&
&
elementRight
>
right
+
SCROLL_MARGIN
)
;
}
getFirstInvisibleElement
(
)
{
const
elementsList
=
Array
.
from
(
this
.
inner
.
childNodes
)
.
reverse
(
)
;
const
predicate
=
this
.
elementLeftOfContainer
;
return
this
.
findFirstWithBounds
(
elementsList
predicate
)
;
}
getLastInvisibleElement
(
)
{
const
predicate
=
this
.
elementRightOfContainer
;
return
this
.
findFirstWithBounds
(
this
.
inner
.
childNodes
predicate
)
;
}
findFirstWithBounds
(
elements
predicate
)
{
const
left
=
this
.
inner
.
scrollLeft
;
const
right
=
left
+
this
.
inner
.
clientWidth
;
for
(
const
element
of
elements
)
{
const
elementLeft
=
element
.
offsetLeft
-
element
.
parentElement
.
offsetLeft
;
const
elementRight
=
elementLeft
+
element
.
offsetWidth
;
if
(
predicate
(
left
right
elementLeft
elementRight
)
)
{
return
element
;
}
}
return
null
;
}
constructHtml
(
)
{
this
.
startBtn
=
this
.
createElement
(
"
div
"
"
scrollbutton
-
up
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
toolbarbutton
-
icon
"
this
.
startBtn
)
;
this
.
createElement
(
"
div
"
"
arrowscrollbox
-
overflow
-
start
-
indicator
"
this
.
container
)
;
this
.
inner
=
this
.
createElement
(
"
div
"
"
html
-
arrowscrollbox
-
inner
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
arrowscrollbox
-
overflow
-
end
-
indicator
"
this
.
container
)
;
this
.
endBtn
=
this
.
createElement
(
"
div
"
"
scrollbutton
-
down
"
this
.
container
)
;
this
.
createElement
(
"
div
"
"
toolbarbutton
-
icon
"
this
.
endBtn
)
;
}
createElement
(
tagName
className
parent
)
{
const
el
=
this
.
doc
.
createElementNS
(
NS_XHTML
tagName
)
;
el
.
className
=
className
;
if
(
parent
)
{
parent
.
appendChild
(
el
)
;
}
return
el
;
}
destroy
(
)
{
this
.
inner
.
removeEventListener
(
"
scroll
"
this
.
onScroll
)
;
this
.
startBtn
.
removeEventListener
(
"
mousedown
"
this
.
onStartBtnClick
)
;
this
.
endBtn
.
removeEventListener
(
"
mousedown
"
this
.
onEndBtnClick
)
;
this
.
startBtn
.
removeEventListener
(
"
dblclick
"
this
.
onStartBtnDblClick
)
;
this
.
endBtn
.
removeEventListener
(
"
dblclick
"
this
.
onRightBtnDblClick
)
;
this
.
inner
.
removeEventListener
(
"
underflow
"
this
.
onUnderflow
)
;
this
.
inner
.
removeEventListener
(
"
overflow
"
this
.
onOverflow
)
;
}
}
;
function
HTMLBreadcrumbs
(
inspector
)
{
this
.
inspector
=
inspector
;
this
.
selection
=
this
.
inspector
.
selection
;
this
.
win
=
this
.
inspector
.
panelWin
;
this
.
doc
=
this
.
inspector
.
panelDoc
;
this
.
_init
(
)
;
}
exports
.
HTMLBreadcrumbs
=
HTMLBreadcrumbs
;
HTMLBreadcrumbs
.
prototype
=
{
get
walker
(
)
{
return
this
.
inspector
.
walker
;
}
_init
(
)
{
this
.
outer
=
this
.
doc
.
getElementById
(
"
inspector
-
breadcrumbs
"
)
;
this
.
arrowScrollBox
=
new
ArrowScrollBox
(
this
.
win
this
.
outer
)
;
this
.
container
=
this
.
arrowScrollBox
.
inner
;
this
.
scroll
=
this
.
scroll
.
bind
(
this
)
;
this
.
arrowScrollBox
.
on
(
"
overflow
"
this
.
scroll
)
;
this
.
outer
.
addEventListener
(
"
click
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
mouseover
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
mouseout
"
this
true
)
;
this
.
outer
.
addEventListener
(
"
focus
"
this
true
)
;
this
.
handleShortcut
=
this
.
handleShortcut
.
bind
(
this
)
;
if
(
flags
.
testing
)
{
this
.
initKeyShortcuts
(
)
;
}
else
{
this
.
outer
.
addEventListener
(
"
focus
"
(
)
=
>
{
this
.
initKeyShortcuts
(
)
;
}
{
once
:
true
}
)
;
}
this
.
nodeHierarchy
=
[
]
;
this
.
currentIndex
=
-
1
;
this
.
breadcrumbsWidgetItemId
=
0
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
updateWithMutations
=
this
.
updateWithMutations
.
bind
(
this
)
;
this
.
updateSelectors
=
this
.
updateSelectors
.
bind
(
this
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
selection
.
on
(
"
pseudoclass
"
this
.
updateSelectors
)
;
this
.
selection
.
on
(
"
attribute
-
changed
"
this
.
updateSelectors
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
updateWithMutations
)
;
this
.
update
(
)
;
}
initKeyShortcuts
(
)
{
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
win
target
:
this
.
outer
}
)
;
this
.
shortcuts
.
on
(
"
Right
"
this
.
handleShortcut
)
;
this
.
shortcuts
.
on
(
"
Left
"
this
.
handleShortcut
)
;
}
prettyPrintNodeAsText
(
node
)
{
let
text
=
node
.
isShadowRoot
?
SHADOW_ROOT_TAGNAME
:
node
.
displayName
;
if
(
node
.
isMarkerPseudoElement
)
{
text
=
"
:
:
marker
"
;
}
else
if
(
node
.
isBeforePseudoElement
)
{
text
=
"
:
:
before
"
;
}
else
if
(
node
.
isAfterPseudoElement
)
{
text
=
"
:
:
after
"
;
}
if
(
node
.
id
)
{
text
+
=
"
#
"
+
node
.
id
;
}
if
(
node
.
className
)
{
const
classList
=
node
.
className
.
split
(
/
\
s
+
/
)
;
for
(
let
i
=
0
;
i
<
classList
.
length
;
i
+
+
)
{
text
+
=
"
.
"
+
classList
[
i
]
;
}
}
for
(
const
pseudo
of
node
.
pseudoClassLocks
)
{
text
+
=
pseudo
;
}
return
text
;
}
prettyPrintNodeAsXHTML
(
node
)
{
const
tagLabel
=
this
.
doc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
tagLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
tag
plain
"
;
const
idLabel
=
this
.
doc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
idLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
id
plain
"
;
const
classesLabel
=
this
.
doc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
classesLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
classes
plain
"
;
const
pseudosLabel
=
this
.
doc
.
createElementNS
(
NS_XHTML
"
span
"
)
;
pseudosLabel
.
className
=
"
breadcrumbs
-
widget
-
item
-
pseudo
-
classes
plain
"
;
let
tagText
=
node
.
isShadowRoot
?
SHADOW_ROOT_TAGNAME
:
node
.
displayName
;
if
(
node
.
isMarkerPseudoElement
)
{
tagText
=
"
:
:
marker
"
;
}
else
if
(
node
.
isBeforePseudoElement
)
{
tagText
=
"
:
:
before
"
;
}
else
if
(
node
.
isAfterPseudoElement
)
{
tagText
=
"
:
:
after
"
;
}
let
idText
=
node
.
id
?
"
#
"
+
node
.
id
:
"
"
;
let
classesText
=
"
"
;
if
(
node
.
className
)
{
const
classList
=
node
.
className
.
split
(
/
\
s
+
/
)
;
for
(
let
i
=
0
;
i
<
classList
.
length
;
i
+
+
)
{
classesText
+
=
"
.
"
+
classList
[
i
]
;
}
}
const
maxTagLength
=
MAX_LABEL_LENGTH
;
const
maxIdLength
=
MAX_LABEL_LENGTH
-
tagText
.
length
;
const
maxClassLength
=
MAX_LABEL_LENGTH
-
tagText
.
length
-
idText
.
length
;
if
(
tagText
.
length
>
maxTagLength
)
{
tagText
=
tagText
.
substr
(
0
maxTagLength
)
+
ELLIPSIS
;
idText
=
classesText
=
"
"
;
}
else
if
(
idText
.
length
>
maxIdLength
)
{
idText
=
idText
.
substr
(
0
maxIdLength
)
+
ELLIPSIS
;
classesText
=
"
"
;
}
else
if
(
classesText
.
length
>
maxClassLength
)
{
classesText
=
classesText
.
substr
(
0
maxClassLength
)
+
ELLIPSIS
;
}
tagLabel
.
textContent
=
tagText
;
idLabel
.
textContent
=
idText
;
classesLabel
.
textContent
=
classesText
;
pseudosLabel
.
textContent
=
node
.
pseudoClassLocks
.
join
(
"
"
)
;
const
fragment
=
this
.
doc
.
createDocumentFragment
(
)
;
fragment
.
appendChild
(
tagLabel
)
;
fragment
.
appendChild
(
idLabel
)
;
fragment
.
appendChild
(
classesLabel
)
;
fragment
.
appendChild
(
pseudosLabel
)
;
return
fragment
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
click
"
&
&
event
.
button
=
=
0
)
{
this
.
handleClick
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseover
"
)
{
this
.
handleMouseOver
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseout
"
)
{
this
.
handleMouseOut
(
event
)
;
}
else
if
(
event
.
type
=
=
"
focus
"
)
{
this
.
handleFocus
(
event
)
;
}
}
handleFocus
(
event
)
{
event
.
stopPropagation
(
)
;
const
node
=
this
.
nodeHierarchy
[
this
.
currentIndex
]
;
if
(
node
)
{
this
.
outer
.
setAttribute
(
"
aria
-
activedescendant
"
node
.
button
.
id
)
;
}
else
{
this
.
outer
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
this
.
outer
.
focus
(
)
;
}
handleClick
(
event
)
{
const
target
=
event
.
originalTarget
;
if
(
target
.
tagName
=
=
"
button
"
)
{
target
.
onBreadcrumbsClick
(
)
;
}
}
handleMouseOver
(
event
)
{
const
target
=
event
.
originalTarget
;
if
(
target
.
tagName
=
=
"
button
"
)
{
target
.
onBreadcrumbsHover
(
)
;
}
}
handleMouseOut
(
event
)
{
this
.
inspector
.
highlighters
.
hideHighlighterType
(
this
.
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
handleShortcut
(
event
)
{
if
(
!
this
.
selection
.
isElementNode
(
)
)
{
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
keyPromise
=
(
this
.
keyPromise
|
|
Promise
.
resolve
(
null
)
)
.
then
(
(
)
=
>
{
let
currentnode
;
const
isLeft
=
event
.
code
=
=
=
"
ArrowLeft
"
;
const
isRight
=
event
.
code
=
=
=
"
ArrowRight
"
;
if
(
isLeft
&
&
this
.
currentIndex
!
=
0
)
{
currentnode
=
this
.
nodeHierarchy
[
this
.
currentIndex
-
1
]
;
}
else
if
(
isRight
&
&
this
.
currentIndex
<
this
.
nodeHierarchy
.
length
-
1
)
{
currentnode
=
this
.
nodeHierarchy
[
this
.
currentIndex
+
1
]
;
}
else
{
return
null
;
}
this
.
outer
.
setAttribute
(
"
aria
-
activedescendant
"
currentnode
.
button
.
id
)
;
return
this
.
selection
.
setNodeFront
(
currentnode
.
node
{
reason
:
"
breadcrumbs
"
}
)
;
}
)
;
}
destroy
(
)
{
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
selection
.
off
(
"
pseudoclass
"
this
.
updateSelectors
)
;
this
.
selection
.
off
(
"
attribute
-
changed
"
this
.
updateSelectors
)
;
this
.
inspector
.
off
(
"
markupmutation
"
this
.
updateWithMutations
)
;
this
.
container
.
removeEventListener
(
"
click
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
mouseover
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
mouseout
"
this
true
)
;
this
.
container
.
removeEventListener
(
"
focus
"
this
true
)
;
if
(
this
.
shortcuts
)
{
this
.
shortcuts
.
destroy
(
)
;
}
this
.
empty
(
)
;
this
.
arrowScrollBox
.
off
(
"
overflow
"
this
.
scroll
)
;
this
.
arrowScrollBox
.
destroy
(
)
;
this
.
arrowScrollBox
=
null
;
this
.
outer
=
null
;
this
.
container
=
null
;
this
.
nodeHierarchy
=
null
;
this
.
isDestroyed
=
true
;
}
empty
(
)
{
while
(
this
.
container
.
hasChildNodes
(
)
)
{
this
.
container
.
firstChild
.
remove
(
)
;
}
}
setCursor
(
index
)
{
if
(
this
.
currentIndex
>
-
1
&
&
this
.
currentIndex
<
this
.
nodeHierarchy
.
length
)
{
this
.
nodeHierarchy
[
this
.
currentIndex
]
.
button
.
removeAttribute
(
"
checked
"
)
;
}
if
(
index
>
-
1
)
{
this
.
nodeHierarchy
[
index
]
.
button
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
this
.
outer
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
this
.
currentIndex
=
index
;
}
indexOf
(
node
)
{
for
(
let
i
=
this
.
nodeHierarchy
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
this
.
nodeHierarchy
[
i
]
.
node
=
=
=
node
)
{
return
i
;
}
}
return
-
1
;
}
cutAfter
(
index
)
{
while
(
this
.
nodeHierarchy
.
length
>
index
+
1
)
{
const
toRemove
=
this
.
nodeHierarchy
.
pop
(
)
;
this
.
container
.
removeChild
(
toRemove
.
button
)
;
}
}
buildButton
(
node
)
{
const
button
=
this
.
doc
.
createElementNS
(
NS_XHTML
"
button
"
)
;
button
.
appendChild
(
this
.
prettyPrintNodeAsXHTML
(
node
)
)
;
button
.
className
=
"
breadcrumbs
-
widget
-
item
"
;
button
.
id
=
"
breadcrumbs
-
widget
-
item
-
"
+
this
.
breadcrumbsWidgetItemId
+
+
;
button
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
button
.
setAttribute
(
"
title
"
this
.
prettyPrintNodeAsText
(
node
)
)
;
button
.
onclick
=
(
)
=
>
{
button
.
focus
(
)
;
}
;
button
.
onBreadcrumbsClick
=
(
)
=
>
{
this
.
selection
.
setNodeFront
(
node
{
reason
:
"
breadcrumbs
"
}
)
;
}
;
button
.
onBreadcrumbsHover
=
(
)
=
>
{
this
.
inspector
.
highlighters
.
showHighlighterTypeForNode
(
this
.
inspector
.
highlighters
.
TYPES
.
BOXMODEL
node
)
;
}
;
return
button
;
}
expand
(
node
)
{
const
fragment
=
this
.
doc
.
createDocumentFragment
(
)
;
let
lastButtonInserted
=
null
;
const
originalLength
=
this
.
nodeHierarchy
.
length
;
let
stopNode
=
null
;
if
(
originalLength
>
0
)
{
stopNode
=
this
.
nodeHierarchy
[
originalLength
-
1
]
.
node
;
}
while
(
node
&
&
node
!
=
stopNode
)
{
if
(
node
.
tagName
|
|
node
.
isShadowRoot
)
{
const
button
=
this
.
buildButton
(
node
)
;
fragment
.
insertBefore
(
button
lastButtonInserted
)
;
lastButtonInserted
=
button
;
this
.
nodeHierarchy
.
splice
(
originalLength
0
{
node
button
currentPrettyPrintText
:
this
.
prettyPrintNodeAsText
(
node
)
}
)
;
}
node
=
node
.
parentOrHost
(
)
;
}
this
.
container
.
appendChild
(
fragment
this
.
container
.
firstChild
)
;
}
getCommonAncestor
(
node
)
{
while
(
node
)
{
const
idx
=
this
.
indexOf
(
node
)
;
if
(
idx
>
-
1
)
{
return
idx
;
}
node
=
node
.
parentNode
(
)
;
}
return
-
1
;
}
scroll
(
)
{
if
(
!
this
.
isDestroyed
)
{
const
element
=
this
.
nodeHierarchy
[
this
.
currentIndex
]
.
button
;
this
.
arrowScrollBox
.
scrollToElement
(
element
"
end
"
)
;
}
}
updateSelectors
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
for
(
let
i
=
this
.
nodeHierarchy
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
{
node
button
currentPrettyPrintText
}
=
this
.
nodeHierarchy
[
i
]
;
const
textOutput
=
this
.
prettyPrintNodeAsText
(
node
)
;
if
(
currentPrettyPrintText
=
=
=
textOutput
)
{
continue
;
}
while
(
button
.
hasChildNodes
(
)
)
{
button
.
firstChild
.
remove
(
)
;
}
button
.
appendChild
(
this
.
prettyPrintNodeAsXHTML
(
node
)
)
;
button
.
setAttribute
(
"
title
"
textOutput
)
;
this
.
nodeHierarchy
[
i
]
.
currentPrettyPrintText
=
textOutput
;
}
}
_hasInterestingMutations
(
mutations
)
{
if
(
!
mutations
|
|
!
mutations
.
length
)
{
return
false
;
}
for
(
const
{
type
added
removed
target
attributeName
}
of
mutations
)
{
if
(
type
=
=
=
"
childList
"
)
{
return
(
added
.
some
(
node
=
>
this
.
indexOf
(
node
)
>
-
1
)
|
|
removed
.
some
(
node
=
>
this
.
indexOf
(
node
)
>
-
1
)
)
;
}
else
if
(
type
=
=
=
"
attributes
"
&
&
this
.
indexOf
(
target
)
>
-
1
)
{
return
attributeName
=
=
=
"
class
"
|
|
attributeName
=
=
=
"
id
"
;
}
}
return
false
;
}
updateWithMutations
(
mutations
)
{
return
this
.
update
(
"
markupmutation
"
mutations
)
;
}
update
(
reason
mutations
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
const
hasInterestingMutations
=
this
.
_hasInterestingMutations
(
mutations
)
;
if
(
reason
=
=
=
"
markupmutation
"
&
&
!
hasInterestingMutations
)
{
return
;
}
if
(
!
this
.
selection
.
isConnected
(
)
)
{
this
.
cutAfter
(
-
1
)
;
return
;
}
let
trimmed
=
false
;
if
(
reason
=
=
=
"
markupmutation
"
)
{
for
(
const
{
type
removed
}
of
mutations
)
{
if
(
type
!
=
=
"
childList
"
)
{
continue
;
}
for
(
const
node
of
removed
)
{
const
removedIndex
=
this
.
indexOf
(
node
)
;
if
(
removedIndex
>
-
1
)
{
this
.
cutAfter
(
removedIndex
-
1
)
;
trimmed
=
true
;
}
}
}
}
if
(
!
this
.
selection
.
isElementNode
(
)
&
&
!
this
.
selection
.
isShadowRootNode
(
)
)
{
this
.
setCursor
(
-
1
)
;
if
(
trimmed
)
{
this
.
inspector
.
emit
(
"
breadcrumbs
-
updated
"
this
.
selection
.
nodeFront
)
;
}
return
;
}
let
idx
=
this
.
indexOf
(
this
.
selection
.
nodeFront
)
;
if
(
idx
>
-
1
&
&
!
hasInterestingMutations
)
{
this
.
setCursor
(
idx
)
;
}
else
{
if
(
this
.
nodeHierarchy
.
length
>
0
)
{
const
parent
=
this
.
selection
.
nodeFront
.
parentNode
(
)
;
const
ancestorIdx
=
this
.
getCommonAncestor
(
parent
)
;
this
.
cutAfter
(
ancestorIdx
)
;
}
this
.
expand
(
this
.
selection
.
nodeFront
)
;
idx
=
this
.
indexOf
(
this
.
selection
.
nodeFront
)
;
this
.
setCursor
(
idx
)
;
}
const
doneUpdating
=
this
.
inspector
.
updating
(
"
breadcrumbs
"
)
;
this
.
updateSelectors
(
)
;
setTimeout
(
(
)
=
>
{
try
{
this
.
scroll
(
)
;
this
.
inspector
.
emit
(
"
breadcrumbs
-
updated
"
this
.
selection
.
nodeFront
)
;
doneUpdating
(
)
;
}
catch
(
e
)
{
if
(
!
this
.
isDestroyed
)
{
console
.
error
(
e
)
;
}
}
}
0
)
;
}
}
;
