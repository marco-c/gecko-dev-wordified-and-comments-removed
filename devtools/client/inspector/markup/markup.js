"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
AutocompletePopup
=
require
(
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
scrollIntoViewIfNeeded
}
=
require
(
"
devtools
/
client
/
shared
/
scroll
"
)
;
const
{
UndoStack
}
=
require
(
"
devtools
/
client
/
shared
/
undo
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
MarkupElementContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
element
-
container
"
)
;
const
MarkupReadOnlyContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
read
-
only
-
container
"
)
;
const
MarkupTextContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
text
-
container
"
)
;
const
SlottedNodeContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
slotted
-
node
-
container
"
)
;
const
RootContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
root
-
container
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
PAGE_SIZE
=
10
;
const
DEFAULT_MAX_CHILDREN
=
100
;
const
NEW_SELECTION_HIGHLIGHTER_TIMER
=
1000
;
const
DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE
=
50
;
const
DRAG_DROP_AUTOSCROLL_EDGE_RATIO
=
0
.
1
;
const
DRAG_DROP_MIN_AUTOSCROLL_SPEED
=
2
;
const
DRAG_DROP_MAX_AUTOSCROLL_SPEED
=
8
;
const
DRAG_DROP_HEIGHT_TO_SPEED
=
500
;
const
DRAG_DROP_HEIGHT_TO_SPEED_MIN
=
0
.
5
;
const
DRAG_DROP_HEIGHT_TO_SPEED_MAX
=
1
;
const
ATTR_COLLAPSE_ENABLED_PREF
=
"
devtools
.
markup
.
collapseAttributes
"
;
const
ATTR_COLLAPSE_LENGTH_PREF
=
"
devtools
.
markup
.
collapseAttributeLength
"
;
function
MarkupView
(
inspector
frame
controllerWindow
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
inspector
=
inspector
;
this
.
highlighters
=
inspector
.
highlighters
;
this
.
walker
=
this
.
inspector
.
walker
;
this
.
_frame
=
frame
;
this
.
win
=
this
.
_frame
.
contentWindow
;
this
.
doc
=
this
.
_frame
.
contentDocument
;
this
.
_elt
=
this
.
doc
.
querySelector
(
"
#
root
"
)
;
this
.
telemetry
=
this
.
inspector
.
telemetry
;
this
.
maxChildren
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
markup
.
pagesize
"
DEFAULT_MAX_CHILDREN
)
;
this
.
collapseAttributes
=
Services
.
prefs
.
getBoolPref
(
ATTR_COLLAPSE_ENABLED_PREF
)
;
this
.
collapseAttributeLength
=
Services
.
prefs
.
getIntPref
(
ATTR_COLLAPSE_LENGTH_PREF
)
;
this
.
popup
=
new
AutocompletePopup
(
inspector
.
toolbox
.
doc
{
autoSelect
:
true
}
)
;
this
.
undo
=
new
UndoStack
(
)
;
this
.
undo
.
installController
(
controllerWindow
)
;
this
.
_containers
=
new
Map
(
)
;
this
.
_slottedContainerKeys
=
new
WeakMap
(
)
;
this
.
_handleRejectionIfNotDestroyed
=
this
.
_handleRejectionIfNotDestroyed
.
bind
(
this
)
;
this
.
_isImagePreviewTarget
=
this
.
_isImagePreviewTarget
.
bind
(
this
)
;
this
.
_mutationObserver
=
this
.
_mutationObserver
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onCopy
=
this
.
_onCopy
.
bind
(
this
)
;
this
.
_onCollapseAttributesPrefChange
=
this
.
_onCollapseAttributesPrefChange
.
bind
(
this
)
;
this
.
_onDisplayChange
=
this
.
_onDisplayChange
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onMouseClick
=
this
.
_onMouseClick
.
bind
(
this
)
;
this
.
_onMouseMove
=
this
.
_onMouseMove
.
bind
(
this
)
;
this
.
_onMouseOut
=
this
.
_onMouseOut
.
bind
(
this
)
;
this
.
_onMouseUp
=
this
.
_onMouseUp
.
bind
(
this
)
;
this
.
_onNewSelection
=
this
.
_onNewSelection
.
bind
(
this
)
;
this
.
_onToolboxPickerCanceled
=
this
.
_onToolboxPickerCanceled
.
bind
(
this
)
;
this
.
_onToolboxPickerHover
=
this
.
_onToolboxPickerHover
.
bind
(
this
)
;
this
.
_elt
.
addEventListener
(
"
blur
"
this
.
_onBlur
true
)
;
this
.
_elt
.
addEventListener
(
"
click
"
this
.
_onMouseClick
)
;
this
.
_elt
.
addEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
this
.
_elt
.
addEventListener
(
"
mouseout
"
this
.
_onMouseOut
)
;
this
.
_frame
.
addEventListener
(
"
focus
"
this
.
_onFocus
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
_onNewSelection
)
;
this
.
walker
.
on
(
"
display
-
change
"
this
.
_onDisplayChange
)
;
this
.
walker
.
on
(
"
mutations
"
this
.
_mutationObserver
)
;
this
.
win
.
addEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
win
.
addEventListener
(
"
mouseup
"
this
.
_onMouseUp
)
;
this
.
toolbox
.
on
(
"
picker
-
canceled
"
this
.
_onToolboxPickerCanceled
)
;
this
.
toolbox
.
on
(
"
picker
-
node
-
hovered
"
this
.
_onToolboxPickerHover
)
;
this
.
_onNewSelection
(
)
;
this
.
_initTooltips
(
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
markup
"
)
;
this
.
_prefObserver
.
on
(
ATTR_COLLAPSE_ENABLED_PREF
this
.
_onCollapseAttributesPrefChange
)
;
this
.
_prefObserver
.
on
(
ATTR_COLLAPSE_LENGTH_PREF
this
.
_onCollapseAttributesPrefChange
)
;
this
.
_initShortcuts
(
)
;
}
MarkupView
.
prototype
=
{
CONTAINER_FLASHING_DURATION
:
500
_selectedContainer
:
null
get
toolbox
(
)
{
return
this
.
inspector
.
toolbox
;
}
_handleRejectionIfNotDestroyed
:
function
(
e
)
{
if
(
!
this
.
_destroyer
)
{
console
.
error
(
e
)
;
}
}
_initTooltips
:
function
(
)
{
this
.
eventDetailsTooltip
=
new
HTMLTooltip
(
this
.
toolbox
.
doc
{
type
:
"
arrow
"
consumeOutsideClicks
:
false
}
)
;
this
.
imagePreviewTooltip
=
new
HTMLTooltip
(
this
.
toolbox
.
doc
{
type
:
"
arrow
"
useXulWrapper
:
true
}
)
;
this
.
_enableImagePreviewTooltip
(
)
;
}
_enableImagePreviewTooltip
:
function
(
)
{
this
.
imagePreviewTooltip
.
startTogglingOnHover
(
this
.
_elt
this
.
_isImagePreviewTarget
)
;
}
_disableImagePreviewTooltip
:
function
(
)
{
this
.
imagePreviewTooltip
.
stopTogglingOnHover
(
)
;
}
_onToolboxPickerHover
:
function
(
nodeFront
)
{
this
.
showNode
(
nodeFront
)
.
then
(
(
)
=
>
{
this
.
_showNodeAsHovered
(
nodeFront
)
;
}
console
.
error
)
;
}
_onToolboxPickerCanceled
:
function
(
)
{
if
(
this
.
_selectedContainer
)
{
scrollIntoViewIfNeeded
(
this
.
_selectedContainer
.
editor
.
elt
)
;
}
}
isDragging
:
false
_draggedContainer
:
null
_onMouseMove
:
function
(
event
)
{
let
target
=
event
.
target
;
if
(
this
.
_draggedContainer
)
{
this
.
_draggedContainer
.
onMouseMove
(
event
)
;
}
if
(
this
.
isDragging
)
{
event
.
preventDefault
(
)
;
this
.
_autoScroll
(
event
)
;
return
;
}
while
(
!
target
.
container
)
{
if
(
target
.
tagName
.
toLowerCase
(
)
=
=
=
"
body
"
)
{
return
;
}
target
=
target
.
parentNode
;
}
const
container
=
target
.
container
;
if
(
this
.
_hoveredContainer
!
=
=
container
)
{
this
.
_showBoxModel
(
container
.
node
)
;
}
this
.
_showContainerAsHovered
(
container
)
;
this
.
emit
(
"
node
-
hover
"
)
;
}
_onBlur
:
function
(
event
)
{
if
(
!
this
.
_selectedContainer
)
{
return
;
}
const
{
relatedTarget
}
=
event
;
if
(
relatedTarget
&
&
relatedTarget
.
ownerDocument
=
=
=
this
.
doc
)
{
return
;
}
if
(
this
.
_selectedContainer
)
{
this
.
_selectedContainer
.
clearFocus
(
)
;
}
}
_autoScroll
:
function
(
event
)
{
const
docEl
=
this
.
doc
.
documentElement
;
if
(
this
.
_autoScrollAnimationFrame
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
_autoScrollAnimationFrame
)
;
}
const
fromBottom
=
docEl
.
clientHeight
-
event
.
pageY
+
this
.
win
.
scrollY
;
const
fromTop
=
event
.
pageY
-
this
.
win
.
scrollY
;
const
edgeDistance
=
Math
.
min
(
DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE
docEl
.
clientHeight
*
DRAG_DROP_AUTOSCROLL_EDGE_RATIO
)
;
const
heightToSpeedRatio
=
Math
.
max
(
DRAG_DROP_HEIGHT_TO_SPEED_MIN
Math
.
min
(
DRAG_DROP_HEIGHT_TO_SPEED_MAX
docEl
.
clientHeight
/
DRAG_DROP_HEIGHT_TO_SPEED
)
)
;
if
(
fromBottom
<
=
edgeDistance
)
{
const
speed
=
map
(
fromBottom
0
edgeDistance
DRAG_DROP_MIN_AUTOSCROLL_SPEED
DRAG_DROP_MAX_AUTOSCROLL_SPEED
)
;
this
.
_runUpdateLoop
(
(
)
=
>
{
docEl
.
scrollTop
-
=
heightToSpeedRatio
*
(
speed
-
DRAG_DROP_MAX_AUTOSCROLL_SPEED
)
;
}
)
;
}
if
(
fromTop
<
=
edgeDistance
)
{
const
speed
=
map
(
fromTop
0
edgeDistance
DRAG_DROP_MIN_AUTOSCROLL_SPEED
DRAG_DROP_MAX_AUTOSCROLL_SPEED
)
;
this
.
_runUpdateLoop
(
(
)
=
>
{
docEl
.
scrollTop
+
=
heightToSpeedRatio
*
(
speed
-
DRAG_DROP_MAX_AUTOSCROLL_SPEED
)
;
}
)
;
}
}
_runUpdateLoop
:
function
(
update
)
{
const
loop
=
(
)
=
>
{
update
(
)
;
this
.
_autoScrollAnimationFrame
=
this
.
win
.
requestAnimationFrame
(
loop
)
;
}
;
loop
(
)
;
}
_onMouseClick
:
function
(
event
)
{
let
parentNode
=
event
.
target
;
let
container
;
while
(
parentNode
!
=
=
this
.
doc
.
body
)
{
if
(
parentNode
.
container
)
{
container
=
parentNode
.
container
;
break
;
}
parentNode
=
parentNode
.
parentNode
;
}
if
(
typeof
container
.
onContainerClick
=
=
=
"
function
"
)
{
container
.
onContainerClick
(
event
)
;
}
}
_onMouseUp
:
function
(
event
)
{
if
(
this
.
_draggedContainer
)
{
this
.
_draggedContainer
.
onMouseUp
(
event
)
;
}
this
.
indicateDropTarget
(
null
)
;
this
.
indicateDragTarget
(
null
)
;
if
(
this
.
_autoScrollAnimationFrame
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
_autoScrollAnimationFrame
)
;
}
}
_onCollapseAttributesPrefChange
:
function
(
)
{
this
.
collapseAttributes
=
Services
.
prefs
.
getBoolPref
(
ATTR_COLLAPSE_ENABLED_PREF
)
;
this
.
collapseAttributeLength
=
Services
.
prefs
.
getIntPref
(
ATTR_COLLAPSE_LENGTH_PREF
)
;
this
.
update
(
)
;
}
cancelDragging
:
function
(
)
{
if
(
!
this
.
isDragging
)
{
return
;
}
for
(
const
[
container
]
of
this
.
_containers
)
{
if
(
container
.
isDragging
)
{
container
.
cancelDragging
(
)
;
break
;
}
}
this
.
indicateDropTarget
(
null
)
;
this
.
indicateDragTarget
(
null
)
;
if
(
this
.
_autoScrollAnimationFrame
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
_autoScrollAnimationFrame
)
;
}
}
_hoveredContainer
:
null
_showNodeAsHovered
:
function
(
nodeFront
)
{
const
container
=
this
.
getContainer
(
nodeFront
)
;
this
.
_showContainerAsHovered
(
container
)
;
}
_showContainerAsHovered
:
function
(
container
)
{
if
(
this
.
_hoveredContainer
=
=
=
container
)
{
return
;
}
if
(
this
.
_hoveredContainer
)
{
this
.
_hoveredContainer
.
hovered
=
false
;
}
container
.
hovered
=
true
;
this
.
_hoveredContainer
=
container
;
this
.
emit
(
"
showcontainerhovered
"
)
;
}
_onMouseOut
:
function
(
event
)
{
if
(
this
.
_elt
.
contains
(
event
.
relatedTarget
)
)
{
return
;
}
if
(
this
.
_autoScrollAnimationFrame
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
_autoScrollAnimationFrame
)
;
}
if
(
this
.
isDragging
)
{
return
;
}
this
.
_hideBoxModel
(
true
)
;
if
(
this
.
_hoveredContainer
)
{
this
.
_hoveredContainer
.
hovered
=
false
;
}
this
.
_hoveredContainer
=
null
;
this
.
emit
(
"
leave
"
)
;
}
_showBoxModel
:
function
(
nodeFront
)
{
return
this
.
toolbox
.
highlighterUtils
.
highlightNodeFront
(
nodeFront
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
}
_hideBoxModel
:
function
(
forceHide
)
{
return
this
.
toolbox
.
highlighterUtils
.
unhighlight
(
forceHide
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
}
_briefBoxModelTimer
:
null
_clearBriefBoxModelTimer
:
function
(
)
{
if
(
this
.
_briefBoxModelTimer
)
{
clearTimeout
(
this
.
_briefBoxModelTimer
)
;
this
.
_briefBoxModelPromise
.
resolve
(
)
;
this
.
_briefBoxModelPromise
=
null
;
this
.
_briefBoxModelTimer
=
null
;
}
}
_brieflyShowBoxModel
:
function
(
nodeFront
)
{
this
.
_clearBriefBoxModelTimer
(
)
;
const
onShown
=
this
.
_showBoxModel
(
nodeFront
)
;
let
_resolve
;
this
.
_briefBoxModelPromise
=
new
Promise
(
resolve
=
>
{
_resolve
=
resolve
;
this
.
_briefBoxModelTimer
=
setTimeout
(
(
)
=
>
{
this
.
_hideBoxModel
(
)
.
then
(
resolve
resolve
)
;
}
NEW_SELECTION_HIGHLIGHTER_TIMER
)
;
}
)
;
this
.
_briefBoxModelPromise
.
resolve
=
_resolve
;
return
promise
.
all
(
[
onShown
this
.
_briefBoxModelPromise
]
)
;
}
getSelectedContainer
:
function
(
)
{
return
this
.
_selectedContainer
;
}
getContainer
:
function
(
node
slotted
)
{
const
key
=
this
.
_getContainerKey
(
node
slotted
)
;
return
this
.
_containers
.
get
(
key
)
;
}
setContainer
:
function
(
node
container
slotted
)
{
const
key
=
this
.
_getContainerKey
(
node
slotted
)
;
return
this
.
_containers
.
set
(
key
container
)
;
}
hasContainer
:
function
(
node
slotted
)
{
const
key
=
this
.
_getContainerKey
(
node
slotted
)
;
return
this
.
_containers
.
has
(
key
)
;
}
_getContainerKey
:
function
(
node
slotted
)
{
if
(
!
slotted
)
{
return
node
;
}
if
(
!
this
.
_slottedContainerKeys
.
has
(
node
)
)
{
this
.
_slottedContainerKeys
.
set
(
node
{
node
}
)
;
}
return
this
.
_slottedContainerKeys
.
get
(
node
)
;
}
_isContainerSelected
:
function
(
container
)
{
if
(
!
container
)
{
return
false
;
}
const
selection
=
this
.
inspector
.
selection
;
return
container
.
node
=
=
selection
.
nodeFront
&
&
container
.
isSlotted
(
)
=
=
selection
.
isSlotted
(
)
;
}
update
:
function
(
)
{
const
updateChildren
=
(
node
)
=
>
{
this
.
getContainer
(
node
)
.
update
(
)
;
for
(
const
child
of
node
.
treeChildren
(
)
)
{
updateChildren
(
child
)
;
}
}
;
let
documentElement
;
for
(
const
node
of
this
.
_rootNode
.
treeChildren
(
)
)
{
if
(
node
.
isDocumentElement
=
=
=
true
)
{
documentElement
=
node
;
break
;
}
}
updateChildren
(
documentElement
)
;
}
async
_isImagePreviewTarget
(
target
)
{
if
(
this
.
isDragging
)
{
return
false
;
}
let
parent
=
target
container
;
while
(
parent
)
{
if
(
parent
.
container
)
{
container
=
parent
.
container
;
break
;
}
parent
=
parent
.
parentNode
;
}
if
(
container
instanceof
MarkupElementContainer
)
{
return
container
.
isImagePreviewTarget
(
target
this
.
imagePreviewTooltip
)
;
}
return
false
;
}
_shouldNewSelectionBeHighlighted
:
function
(
)
{
const
reason
=
this
.
inspector
.
selection
.
reason
;
const
unwantedReasons
=
[
"
inspector
-
open
"
"
navigateaway
"
"
nodeselected
"
"
test
"
]
;
const
isHighlight
=
this
.
_isContainerSelected
(
this
.
_hoveredContainer
)
;
return
!
isHighlight
&
&
reason
&
&
!
unwantedReasons
.
includes
(
reason
)
;
}
_onNewSelection
:
function
(
)
{
const
selection
=
this
.
inspector
.
selection
;
if
(
this
.
htmlEditor
)
{
this
.
htmlEditor
.
hide
(
)
;
}
if
(
this
.
_isContainerSelected
(
this
.
_hoveredContainer
)
)
{
this
.
_hoveredContainer
.
hovered
=
false
;
this
.
_hoveredContainer
=
null
;
}
if
(
!
selection
.
isNode
(
)
)
{
this
.
unmarkSelectedNode
(
)
;
return
;
}
const
done
=
this
.
inspector
.
updating
(
"
markup
-
view
"
)
;
let
onShowBoxModel
;
if
(
this
.
_shouldNewSelectionBeHighlighted
(
)
)
{
onShowBoxModel
=
this
.
_brieflyShowBoxModel
(
selection
.
nodeFront
)
;
}
const
slotted
=
selection
.
isSlotted
(
)
;
const
onShow
=
this
.
showNode
(
selection
.
nodeFront
{
slotted
}
)
.
then
(
(
)
=
>
{
if
(
this
.
_destroyer
)
{
return
promise
.
reject
(
"
markupview
destroyed
"
)
;
}
const
container
=
this
.
getContainer
(
selection
.
nodeFront
slotted
)
;
this
.
_markContainerAsSelected
(
container
)
;
this
.
maybeNavigateToNewSelection
(
)
;
return
undefined
;
}
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
promise
.
all
(
[
onShowBoxModel
onShow
]
)
.
then
(
done
)
;
}
maybeNavigateToNewSelection
:
function
(
)
{
const
{
reason
nodeFront
}
=
this
.
inspector
.
selection
;
const
reasonsToNavigate
=
[
"
picker
-
node
-
picked
"
"
picker
-
node
-
previewed
"
"
browser
-
context
-
menu
"
"
node
-
inserted
"
]
;
if
(
reason
&
&
reason
.
endsWith
(
"
-
keyboard
"
)
)
{
this
.
getContainer
(
this
.
_rootNode
)
.
elt
.
focus
(
)
;
}
if
(
reasonsToNavigate
.
includes
(
reason
)
)
{
this
.
getContainer
(
this
.
_rootNode
)
.
elt
.
focus
(
)
;
this
.
navigate
(
this
.
getContainer
(
nodeFront
)
)
;
}
}
_selectionWalker
:
function
(
start
)
{
const
walker
=
this
.
doc
.
createTreeWalker
(
start
|
|
this
.
_elt
nodeFilterConstants
.
SHOW_ELEMENT
function
(
element
)
{
if
(
element
.
container
&
&
element
.
container
.
elt
=
=
=
element
&
&
element
.
container
.
visible
)
{
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
return
nodeFilterConstants
.
FILTER_SKIP
;
}
)
;
walker
.
currentNode
=
this
.
_selectedContainer
.
elt
;
return
walker
;
}
_onCopy
:
function
(
evt
)
{
if
(
this
.
_isInputOrTextarea
(
evt
.
target
)
)
{
return
;
}
const
selection
=
this
.
inspector
.
selection
;
if
(
selection
.
isNode
(
)
)
{
this
.
inspector
.
copyOuterHTML
(
)
;
}
evt
.
stopPropagation
(
)
;
evt
.
preventDefault
(
)
;
}
_initShortcuts
:
function
(
)
{
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
win
}
)
;
this
.
_onShortcut
=
this
.
_onShortcut
.
bind
(
this
)
;
[
"
markupView
.
hide
.
key
"
"
markupView
.
edit
.
key
"
"
markupView
.
scrollInto
.
key
"
]
.
forEach
(
name
=
>
{
const
key
=
INSPECTOR_L10N
.
getStr
(
name
)
;
shortcuts
.
on
(
key
event
=
>
this
.
_onShortcut
(
name
event
)
)
;
}
)
;
[
"
Delete
"
"
Backspace
"
"
Home
"
"
Left
"
"
Right
"
"
Up
"
"
Down
"
"
PageUp
"
"
PageDown
"
"
Esc
"
"
Enter
"
"
Space
"
]
.
forEach
(
key
=
>
{
shortcuts
.
on
(
key
event
=
>
this
.
_onShortcut
(
key
event
)
)
;
}
)
;
}
_onShortcut
(
name
event
)
{
if
(
this
.
_isInputOrTextarea
(
event
.
target
)
)
{
return
;
}
switch
(
name
)
{
case
"
markupView
.
hide
.
key
"
:
{
const
node
=
this
.
_selectedContainer
.
node
;
if
(
node
.
hidden
)
{
this
.
walker
.
unhideNode
(
node
)
;
}
else
{
this
.
walker
.
hideNode
(
node
)
;
}
break
;
}
case
"
markupView
.
edit
.
key
"
:
{
this
.
beginEditingOuterHTML
(
this
.
_selectedContainer
.
node
)
;
break
;
}
case
"
markupView
.
scrollInto
.
key
"
:
{
const
selection
=
this
.
_selectedContainer
.
node
;
this
.
inspector
.
scrollNodeIntoView
(
selection
)
;
break
;
}
case
"
Delete
"
:
{
this
.
deleteNodeOrAttribute
(
)
;
break
;
}
case
"
Backspace
"
:
{
this
.
deleteNodeOrAttribute
(
true
)
;
break
;
}
case
"
Home
"
:
{
const
rootContainer
=
this
.
getContainer
(
this
.
_rootNode
)
;
this
.
navigate
(
rootContainer
.
children
.
firstChild
.
container
)
;
break
;
}
case
"
Left
"
:
{
if
(
this
.
_selectedContainer
.
expanded
)
{
this
.
collapseNode
(
this
.
_selectedContainer
.
node
)
;
}
else
{
const
parent
=
this
.
_selectionWalker
(
)
.
parentNode
(
)
;
if
(
parent
)
{
this
.
navigate
(
parent
.
container
)
;
}
}
break
;
}
case
"
Right
"
:
{
if
(
!
this
.
_selectedContainer
.
expanded
&
&
this
.
_selectedContainer
.
hasChildren
)
{
this
.
_expandContainer
(
this
.
_selectedContainer
)
;
}
else
{
const
next
=
this
.
_selectionWalker
(
)
.
nextNode
(
)
;
if
(
next
)
{
this
.
navigate
(
next
.
container
)
;
}
}
break
;
}
case
"
Up
"
:
{
const
previousNode
=
this
.
_selectionWalker
(
)
.
previousNode
(
)
;
if
(
previousNode
)
{
this
.
navigate
(
previousNode
.
container
)
;
}
break
;
}
case
"
Down
"
:
{
const
nextNode
=
this
.
_selectionWalker
(
)
.
nextNode
(
)
;
if
(
nextNode
)
{
this
.
navigate
(
nextNode
.
container
)
;
}
break
;
}
case
"
PageUp
"
:
{
const
walker
=
this
.
_selectionWalker
(
)
;
let
selection
=
this
.
_selectedContainer
;
for
(
let
i
=
0
;
i
<
PAGE_SIZE
;
i
+
+
)
{
const
previousNode
=
walker
.
previousNode
(
)
;
if
(
!
previousNode
)
{
break
;
}
selection
=
previousNode
.
container
;
}
this
.
navigate
(
selection
)
;
break
;
}
case
"
PageDown
"
:
{
const
walker
=
this
.
_selectionWalker
(
)
;
let
selection
=
this
.
_selectedContainer
;
for
(
let
i
=
0
;
i
<
PAGE_SIZE
;
i
+
+
)
{
const
nextNode
=
walker
.
nextNode
(
)
;
if
(
!
nextNode
)
{
break
;
}
selection
=
nextNode
.
container
;
}
this
.
navigate
(
selection
)
;
break
;
}
case
"
Enter
"
:
case
"
Space
"
:
{
if
(
!
this
.
_selectedContainer
.
canFocus
)
{
this
.
_selectedContainer
.
canFocus
=
true
;
this
.
_selectedContainer
.
focus
(
)
;
}
else
{
return
;
}
break
;
}
case
"
Esc
"
:
{
if
(
this
.
isDragging
)
{
this
.
cancelDragging
(
)
;
}
else
{
return
;
}
break
;
}
default
:
console
.
error
(
"
Unexpected
markup
-
view
key
shortcut
"
name
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
_isInputOrTextarea
:
function
(
element
)
{
const
name
=
element
.
tagName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
|
|
name
=
=
=
"
textarea
"
;
}
deleteNodeOrAttribute
:
function
(
moveBackward
)
{
const
focusedAttribute
=
this
.
doc
.
activeElement
?
this
.
doc
.
activeElement
.
closest
(
"
.
attreditor
"
)
:
null
;
if
(
focusedAttribute
)
{
const
container
=
focusedAttribute
.
closest
(
"
li
.
child
"
)
.
container
;
container
.
removeAttribute
(
focusedAttribute
.
dataset
.
attr
)
;
}
else
{
this
.
deleteNode
(
this
.
_selectedContainer
.
node
moveBackward
)
;
}
}
deleteNode
:
function
(
node
moveBackward
)
{
if
(
!
this
.
inspector
.
isDeletable
(
node
)
)
{
return
;
}
const
container
=
this
.
getContainer
(
node
)
;
this
.
walker
.
retainNode
(
node
)
.
then
(
(
)
=
>
{
const
parent
=
node
.
parentNode
(
)
;
let
nextSibling
=
null
;
this
.
undo
.
do
(
(
)
=
>
{
this
.
walker
.
removeNode
(
node
)
.
then
(
siblings
=
>
{
nextSibling
=
siblings
.
nextSibling
;
const
prevSibling
=
siblings
.
previousSibling
;
let
focusNode
=
moveBackward
?
prevSibling
:
nextSibling
;
if
(
!
focusNode
)
{
focusNode
=
nextSibling
|
|
prevSibling
|
|
parent
;
}
const
isNextSiblingText
=
nextSibling
?
nextSibling
.
nodeType
=
=
=
nodeConstants
.
TEXT_NODE
:
false
;
const
isPrevSiblingText
=
prevSibling
?
prevSibling
.
nodeType
=
=
=
nodeConstants
.
TEXT_NODE
:
false
;
if
(
parent
.
numChildren
=
=
=
2
&
&
(
isNextSiblingText
|
|
isPrevSiblingText
)
)
{
focusNode
=
parent
;
}
if
(
container
.
selected
)
{
this
.
navigate
(
this
.
getContainer
(
focusNode
)
)
;
}
}
)
;
}
(
)
=
>
{
const
isValidSibling
=
nextSibling
&
&
!
nextSibling
.
isPseudoElement
;
nextSibling
=
isValidSibling
?
nextSibling
:
null
;
this
.
walker
.
insertBefore
(
node
parent
nextSibling
)
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
_onFocus
:
function
(
event
)
{
let
parent
=
event
.
target
;
while
(
!
parent
.
container
)
{
parent
=
parent
.
parentNode
;
}
if
(
parent
)
{
this
.
navigate
(
parent
.
container
)
;
}
}
navigate
:
function
(
container
)
{
if
(
!
container
)
{
return
;
}
this
.
_markContainerAsSelected
(
container
"
treepanel
"
)
;
}
importNode
:
function
(
node
flashNode
slotted
)
{
if
(
!
node
)
{
return
null
;
}
if
(
this
.
hasContainer
(
node
slotted
)
)
{
return
this
.
getContainer
(
node
slotted
)
;
}
let
container
;
const
{
nodeType
isPseudoElement
}
=
node
;
if
(
node
=
=
=
this
.
walker
.
rootNode
)
{
container
=
new
RootContainer
(
this
node
)
;
this
.
_elt
.
appendChild
(
container
.
elt
)
;
this
.
_rootNode
=
node
;
}
else
if
(
slotted
)
{
container
=
new
SlottedNodeContainer
(
this
node
this
.
inspector
)
;
}
else
if
(
nodeType
=
=
nodeConstants
.
ELEMENT_NODE
&
&
!
isPseudoElement
)
{
container
=
new
MarkupElementContainer
(
this
node
this
.
inspector
)
;
}
else
if
(
nodeType
=
=
nodeConstants
.
COMMENT_NODE
|
|
nodeType
=
=
nodeConstants
.
TEXT_NODE
)
{
container
=
new
MarkupTextContainer
(
this
node
this
.
inspector
)
;
}
else
{
container
=
new
MarkupReadOnlyContainer
(
this
node
this
.
inspector
)
;
}
if
(
flashNode
)
{
container
.
flashMutation
(
)
;
}
this
.
setContainer
(
node
container
slotted
)
;
container
.
childrenDirty
=
true
;
this
.
_updateChildren
(
container
)
;
this
.
inspector
.
emit
(
"
container
-
created
"
container
)
;
return
container
;
}
_mutationObserver
:
function
(
mutations
)
{
for
(
const
mutation
of
mutations
)
{
let
type
=
mutation
.
type
;
let
target
=
mutation
.
target
;
if
(
mutation
.
type
=
=
=
"
documentUnload
"
)
{
type
=
"
childList
"
;
target
=
mutation
.
targetParent
;
if
(
!
target
)
{
continue
;
}
}
const
container
=
this
.
getContainer
(
target
)
;
if
(
!
container
)
{
continue
;
}
if
(
type
=
=
=
"
attributes
"
|
|
type
=
=
=
"
characterData
"
|
|
type
=
=
=
"
customElementDefined
"
|
|
type
=
=
=
"
events
"
|
|
type
=
=
=
"
pseudoClassLock
"
)
{
container
.
update
(
)
;
}
else
if
(
type
=
=
=
"
childList
"
|
|
type
=
=
=
"
nativeAnonymousChildList
"
|
|
type
=
=
=
"
slotchange
"
|
|
type
=
=
=
"
shadowRootAttached
"
)
{
container
.
childrenDirty
=
true
;
this
.
_updateChildren
(
container
{
flash
:
true
}
)
.
then
(
(
)
=
>
container
.
updateLevel
(
)
)
;
}
else
if
(
type
=
=
=
"
inlineTextChild
"
)
{
container
.
childrenDirty
=
true
;
this
.
_updateChildren
(
container
{
flash
:
true
}
)
;
container
.
update
(
)
;
}
}
this
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_destroyer
)
{
return
;
}
this
.
_flashMutatedNodes
(
mutations
)
;
this
.
inspector
.
emit
(
"
markupmutation
"
mutations
)
;
if
(
this
.
htmlEditor
)
{
this
.
htmlEditor
.
refresh
(
)
;
}
}
)
;
}
_onDisplayChange
:
function
(
nodes
)
{
for
(
const
node
of
nodes
)
{
const
container
=
this
.
getContainer
(
node
)
;
if
(
container
)
{
container
.
update
(
)
;
}
}
}
_flashMutatedNodes
:
function
(
mutations
)
{
const
addedOrEditedContainers
=
new
Set
(
)
;
const
removedContainers
=
new
Set
(
)
;
for
(
const
{
type
target
added
removed
newValue
}
of
mutations
)
{
const
container
=
this
.
getContainer
(
target
)
;
if
(
container
)
{
if
(
type
=
=
=
"
characterData
"
)
{
addedOrEditedContainers
.
add
(
container
)
;
}
else
if
(
type
=
=
=
"
attributes
"
&
&
newValue
=
=
=
null
)
{
addedOrEditedContainers
.
add
(
container
)
;
}
else
if
(
type
=
=
=
"
childList
"
)
{
if
(
removed
.
length
)
{
removedContainers
.
add
(
container
)
;
}
added
.
forEach
(
node
=
>
{
const
addedContainer
=
this
.
getContainer
(
node
)
;
if
(
addedContainer
)
{
addedOrEditedContainers
.
add
(
addedContainer
)
;
removedContainers
.
delete
(
container
)
;
}
}
)
;
}
}
}
for
(
const
container
of
removedContainers
)
{
container
.
flashMutation
(
)
;
}
for
(
const
container
of
addedOrEditedContainers
)
{
container
.
flashMutation
(
)
;
}
}
showNode
:
function
(
node
{
centered
=
true
slotted
}
=
{
}
)
{
if
(
slotted
&
&
!
this
.
hasContainer
(
node
slotted
)
)
{
throw
new
Error
(
"
Tried
to
show
a
slotted
node
not
previously
imported
"
)
;
}
else
{
this
.
_ensureNodeImported
(
node
)
;
}
return
this
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_destroyer
)
{
return
promise
.
reject
(
"
markupview
destroyed
"
)
;
}
return
this
.
_ensureVisible
(
node
)
;
}
)
.
then
(
(
)
=
>
{
const
container
=
this
.
getContainer
(
node
slotted
)
;
scrollIntoViewIfNeeded
(
container
.
editor
.
elt
centered
)
;
}
this
.
_handleRejectionIfNotDestroyed
)
;
}
_ensureNodeImported
:
function
(
node
)
{
let
parent
=
node
;
this
.
importNode
(
node
)
;
while
(
(
parent
=
this
.
_getParentInTree
(
parent
)
)
)
{
this
.
importNode
(
parent
)
;
this
.
expandNode
(
parent
)
;
}
}
_expandContainer
:
function
(
container
)
{
return
this
.
_updateChildren
(
container
{
expand
:
true
}
)
.
then
(
(
)
=
>
{
if
(
this
.
_destroyer
)
{
return
;
}
container
.
setExpanded
(
true
)
;
}
)
;
}
expandNode
:
function
(
node
)
{
const
container
=
this
.
getContainer
(
node
)
;
return
this
.
_expandContainer
(
container
)
;
}
_expandAll
:
function
(
container
)
{
return
this
.
_expandContainer
(
container
)
.
then
(
(
)
=
>
{
let
child
=
container
.
children
.
firstChild
;
const
promises
=
[
]
;
while
(
child
)
{
promises
.
push
(
this
.
_expandAll
(
child
.
container
)
)
;
child
=
child
.
nextSibling
;
}
return
promise
.
all
(
promises
)
;
}
)
.
catch
(
console
.
error
)
;
}
expandAll
:
function
(
node
)
{
node
=
node
|
|
this
.
_rootNode
;
return
this
.
_expandAll
(
this
.
getContainer
(
node
)
)
;
}
collapseNode
:
function
(
node
)
{
const
container
=
this
.
getContainer
(
node
)
;
container
.
setExpanded
(
false
)
;
}
_collapseAll
:
function
(
container
)
{
container
.
setExpanded
(
false
)
;
const
children
=
container
.
getChildContainers
(
)
|
|
[
]
;
children
.
forEach
(
child
=
>
this
.
_collapseAll
(
child
)
)
;
}
collapseAll
:
function
(
node
)
{
this
.
_collapseAll
(
this
.
getContainer
(
node
)
)
;
return
Promise
.
resolve
(
)
;
}
_getNodeHTML
:
function
(
node
isOuter
)
{
let
walkerPromise
=
null
;
if
(
isOuter
)
{
walkerPromise
=
this
.
walker
.
outerHTML
(
node
)
;
}
else
{
walkerPromise
=
this
.
walker
.
innerHTML
(
node
)
;
}
return
walkerPromise
.
then
(
longstr
=
>
{
return
longstr
.
string
(
)
.
then
(
html
=
>
{
longstr
.
release
(
)
.
catch
(
console
.
error
)
;
return
html
;
}
)
;
}
)
;
}
getNodeOuterHTML
:
function
(
node
)
{
return
this
.
_getNodeHTML
(
node
true
)
;
}
getNodeInnerHTML
:
function
(
node
)
{
return
this
.
_getNodeHTML
(
node
)
;
}
reselectOnRemoved
:
function
(
removedNode
reason
)
{
this
.
cancelReselectOnRemoved
(
)
;
const
isHTMLTag
=
removedNode
.
tagName
.
toLowerCase
(
)
=
=
=
"
html
"
;
const
oldContainer
=
this
.
getContainer
(
removedNode
)
;
const
parentContainer
=
this
.
getContainer
(
removedNode
.
parentNode
(
)
)
;
const
childIndex
=
parentContainer
.
getChildContainers
(
)
.
indexOf
(
oldContainer
)
;
const
onMutations
=
this
.
_removedNodeObserver
=
mutations
=
>
{
let
isNodeRemovalMutation
=
false
;
for
(
const
mutation
of
mutations
)
{
const
containsRemovedNode
=
mutation
.
removed
&
&
mutation
.
removed
.
some
(
n
=
>
n
=
=
=
removedNode
)
;
if
(
mutation
.
type
=
=
=
"
childList
"
&
&
(
containsRemovedNode
|
|
isHTMLTag
)
)
{
isNodeRemovalMutation
=
true
;
break
;
}
}
if
(
!
isNodeRemovalMutation
)
{
return
;
}
this
.
inspector
.
off
(
"
markupmutation
"
onMutations
)
;
this
.
_removedNodeObserver
=
null
;
if
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
parentContainer
.
node
|
|
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
removedNode
&
&
isHTMLTag
)
)
{
const
childContainers
=
parentContainer
.
getChildContainers
(
)
;
if
(
childContainers
&
&
childContainers
[
childIndex
]
)
{
const
childContainer
=
childContainers
[
childIndex
]
;
this
.
_markContainerAsSelected
(
childContainer
reason
)
;
if
(
childContainer
.
hasChildren
)
{
this
.
expandNode
(
childContainer
.
node
)
;
}
this
.
emit
(
"
reselectedonremoved
"
)
;
}
}
}
;
this
.
inspector
.
on
(
"
markupmutation
"
onMutations
)
;
}
cancelReselectOnRemoved
:
function
(
)
{
if
(
this
.
_removedNodeObserver
)
{
this
.
inspector
.
off
(
"
markupmutation
"
this
.
_removedNodeObserver
)
;
this
.
_removedNodeObserver
=
null
;
this
.
emit
(
"
canceledreselectonremoved
"
)
;
}
}
updateNodeOuterHTML
:
function
(
node
newValue
)
{
const
container
=
this
.
getContainer
(
node
)
;
if
(
!
container
)
{
return
promise
.
reject
(
)
;
}
this
.
reselectOnRemoved
(
node
"
outerhtml
"
)
;
return
this
.
walker
.
setOuterHTML
(
node
newValue
)
.
catch
(
(
)
=
>
{
this
.
cancelReselectOnRemoved
(
)
;
}
)
;
}
updateNodeInnerHTML
:
function
(
node
newValue
oldValue
)
{
const
container
=
this
.
getContainer
(
node
)
;
if
(
!
container
)
{
return
promise
.
reject
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
container
.
undo
.
do
(
(
)
=
>
{
this
.
walker
.
setInnerHTML
(
node
newValue
)
.
then
(
resolve
reject
)
;
}
(
)
=
>
{
this
.
walker
.
setInnerHTML
(
node
oldValue
)
;
}
)
;
}
)
;
}
insertAdjacentHTMLToNode
:
function
(
node
position
value
)
{
const
container
=
this
.
getContainer
(
node
)
;
if
(
!
container
)
{
return
promise
.
reject
(
)
;
}
let
injectedNodes
=
[
]
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
container
.
undo
.
do
(
(
)
=
>
{
this
.
walker
.
insertAdjacentHTML
(
node
position
value
)
.
then
(
nodeArray
=
>
{
injectedNodes
=
nodeArray
.
nodes
;
return
nodeArray
;
}
)
.
then
(
resolve
reject
)
;
}
(
)
=
>
{
this
.
walker
.
removeNodes
(
injectedNodes
)
;
}
)
;
}
)
;
}
beginEditingOuterHTML
:
function
(
node
)
{
this
.
getNodeOuterHTML
(
node
)
.
then
(
oldValue
=
>
{
const
container
=
this
.
getContainer
(
node
)
;
if
(
!
container
)
{
return
;
}
if
(
!
this
.
htmlEditor
)
{
const
HTMLEditor
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
html
-
editor
"
)
;
this
.
htmlEditor
=
new
HTMLEditor
(
this
.
doc
)
;
}
this
.
htmlEditor
.
show
(
container
.
tagLine
oldValue
)
;
const
start
=
this
.
telemetry
.
msSystemNow
(
)
;
this
.
htmlEditor
.
once
(
"
popuphidden
"
(
commit
value
)
=
>
{
this
.
doc
.
documentElement
.
focus
(
)
;
if
(
commit
)
{
this
.
updateNodeOuterHTML
(
node
value
oldValue
)
;
}
const
end
=
this
.
telemetry
.
msSystemNow
(
)
;
this
.
telemetry
.
recordEvent
(
"
devtools
.
main
"
"
edit_html
"
"
inspector
"
null
{
"
made_changes
"
:
commit
"
time_open
"
:
end
-
start
"
session_id
"
:
this
.
toolbox
.
sessionId
}
)
;
}
)
;
this
.
emit
(
"
begin
-
editing
"
)
;
}
)
;
}
setNodeExpanded
:
function
(
node
expanded
applyToDescendants
)
{
if
(
expanded
)
{
if
(
applyToDescendants
)
{
this
.
expandAll
(
node
)
;
}
else
{
this
.
expandNode
(
node
)
;
}
}
else
if
(
applyToDescendants
)
{
this
.
collapseAll
(
node
)
;
}
else
{
this
.
collapseNode
(
node
)
;
}
}
markNodeAsSelected
:
function
(
node
reason
=
"
nodeselected
"
)
{
const
container
=
this
.
getContainer
(
node
)
;
return
this
.
_markContainerAsSelected
(
container
)
;
}
_markContainerAsSelected
:
function
(
container
reason
)
{
if
(
!
container
|
|
this
.
_selectedContainer
=
=
=
container
)
{
return
false
;
}
const
{
node
}
=
container
;
if
(
this
.
_selectedContainer
)
{
this
.
_selectedContainer
.
selected
=
false
;
this
.
_selectedContainer
.
clearFocus
(
)
;
}
this
.
_selectedContainer
=
container
;
if
(
node
)
{
this
.
_selectedContainer
.
selected
=
true
;
}
if
(
!
this
.
_isContainerSelected
(
this
.
_selectedContainer
)
)
{
const
isSlotted
=
container
.
isSlotted
(
)
;
this
.
inspector
.
selection
.
setNodeFront
(
node
{
reason
isSlotted
}
)
;
}
return
true
;
}
_ensureVisible
:
function
(
node
)
{
while
(
node
)
{
const
container
=
this
.
getContainer
(
node
)
;
const
parent
=
this
.
_getParentInTree
(
node
)
;
if
(
!
container
.
elt
.
parentNode
)
{
const
parentContainer
=
this
.
getContainer
(
parent
)
;
if
(
parentContainer
)
{
parentContainer
.
childrenDirty
=
true
;
this
.
_updateChildren
(
parentContainer
{
expand
:
true
}
)
;
}
}
node
=
parent
;
}
return
this
.
_waitForChildren
(
)
;
}
unmarkSelectedNode
:
function
(
)
{
if
(
this
.
_selectedContainer
)
{
this
.
_selectedContainer
.
selected
=
false
;
this
.
_selectedContainer
=
null
;
}
}
_checkSelectionVisible
:
function
(
container
)
{
let
centered
=
null
;
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
while
(
node
)
{
if
(
this
.
_getParentInTree
(
node
)
=
=
=
container
.
node
)
{
centered
=
node
;
break
;
}
node
=
this
.
_getParentInTree
(
node
)
;
}
return
centered
;
}
_updateChildren
:
function
(
container
options
)
{
if
(
container
.
isSlotted
(
)
)
{
return
promise
.
resolve
(
container
)
;
}
const
expand
=
options
&
&
options
.
expand
;
const
flash
=
options
&
&
options
.
flash
;
container
.
hasChildren
=
container
.
node
.
hasChildren
;
container
.
setChildrenRole
(
)
;
if
(
!
this
.
_queuedChildUpdates
)
{
this
.
_queuedChildUpdates
=
new
Map
(
)
;
}
if
(
this
.
_queuedChildUpdates
.
has
(
container
)
)
{
return
this
.
_queuedChildUpdates
.
get
(
container
)
;
}
if
(
!
container
.
childrenDirty
)
{
return
promise
.
resolve
(
container
)
;
}
if
(
container
.
inlineTextChild
&
&
container
.
inlineTextChild
!
=
container
.
node
.
inlineTextChild
)
{
this
.
_containers
.
delete
(
container
.
inlineTextChild
)
;
container
.
clearInlineTextChild
(
)
;
if
(
container
.
hasChildren
&
&
container
.
selected
)
{
container
.
setExpanded
(
true
)
;
}
}
if
(
container
.
node
.
inlineTextChild
)
{
container
.
setExpanded
(
false
)
;
while
(
container
.
children
.
firstChild
)
{
container
.
children
.
firstChild
.
remove
(
)
;
}
container
.
setInlineTextChild
(
container
.
node
.
inlineTextChild
)
;
this
.
setContainer
(
container
.
node
.
inlineTextChild
container
)
;
container
.
childrenDirty
=
false
;
return
promise
.
resolve
(
container
)
;
}
if
(
!
container
.
hasChildren
)
{
while
(
container
.
children
.
firstChild
)
{
container
.
children
.
firstChild
.
remove
(
)
;
}
container
.
childrenDirty
=
false
;
container
.
setExpanded
(
false
)
;
return
promise
.
resolve
(
container
)
;
}
if
(
!
(
container
.
expanded
|
|
expand
)
)
{
return
promise
.
resolve
(
container
)
;
}
const
centered
=
this
.
_checkSelectionVisible
(
container
)
;
container
.
childrenDirty
=
false
;
const
isShadowHost
=
container
.
node
.
isShadowHost
;
const
updatePromise
=
this
.
_getVisibleChildren
(
container
centered
)
.
then
(
children
=
>
{
if
(
!
this
.
_containers
)
{
return
promise
.
reject
(
"
markup
view
destroyed
"
)
;
}
this
.
_queuedChildUpdates
.
delete
(
container
)
;
if
(
container
.
childrenDirty
)
{
return
this
.
_updateChildren
(
container
{
expand
:
centered
|
|
expand
}
)
;
}
const
fragment
=
this
.
doc
.
createDocumentFragment
(
)
;
for
(
const
child
of
children
.
nodes
)
{
const
slotted
=
!
isShadowHost
&
&
child
.
isDirectShadowHostChild
;
const
childContainer
=
this
.
importNode
(
child
flash
slotted
)
;
fragment
.
appendChild
(
childContainer
.
elt
)
;
}
while
(
container
.
children
.
firstChild
)
{
container
.
children
.
firstChild
.
remove
(
)
;
}
if
(
!
children
.
hasFirst
)
{
const
topItem
=
this
.
buildMoreNodesButtonMarkup
(
container
)
;
fragment
.
insertBefore
(
topItem
fragment
.
firstChild
)
;
}
if
(
!
children
.
hasLast
)
{
const
bottomItem
=
this
.
buildMoreNodesButtonMarkup
(
container
)
;
fragment
.
appendChild
(
bottomItem
)
;
}
container
.
children
.
appendChild
(
fragment
)
;
return
container
;
}
)
.
catch
(
this
.
_handleRejectionIfNotDestroyed
)
;
this
.
_queuedChildUpdates
.
set
(
container
updatePromise
)
;
return
updatePromise
;
}
buildMoreNodesButtonMarkup
:
function
(
container
)
{
const
elt
=
this
.
doc
.
createElement
(
"
li
"
)
;
elt
.
classList
.
add
(
"
more
-
nodes
"
"
devtools
-
class
-
comment
"
)
;
const
label
=
this
.
doc
.
createElement
(
"
span
"
)
;
label
.
textContent
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
more
.
showing
"
)
;
elt
.
appendChild
(
label
)
;
const
button
=
this
.
doc
.
createElement
(
"
button
"
)
;
button
.
setAttribute
(
"
href
"
"
#
"
)
;
const
showAllString
=
PluralForm
.
get
(
container
.
node
.
numChildren
INSPECTOR_L10N
.
getStr
(
"
markupView
.
more
.
showAll2
"
)
)
;
button
.
textContent
=
showAllString
.
replace
(
"
#
1
"
container
.
node
.
numChildren
)
;
elt
.
appendChild
(
button
)
;
button
.
addEventListener
(
"
click
"
(
)
=
>
{
container
.
maxChildren
=
-
1
;
container
.
childrenDirty
=
true
;
this
.
_updateChildren
(
container
)
;
}
)
;
return
elt
;
}
_waitForChildren
:
function
(
)
{
if
(
!
this
.
_queuedChildUpdates
)
{
return
promise
.
resolve
(
undefined
)
;
}
return
promise
.
all
(
[
.
.
.
this
.
_queuedChildUpdates
.
values
(
)
]
)
;
}
_getVisibleChildren
:
function
(
container
centered
)
{
let
maxChildren
=
container
.
maxChildren
|
|
this
.
maxChildren
;
if
(
maxChildren
=
=
-
1
)
{
maxChildren
=
undefined
;
}
return
this
.
walker
.
children
(
container
.
node
{
maxNodes
:
maxChildren
center
:
centered
}
)
;
}
_getParentInTree
:
function
(
node
)
{
return
node
.
parentOrHost
(
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
this
.
_destroyer
=
promise
.
resolve
(
)
;
this
.
_clearBriefBoxModelTimer
(
)
;
this
.
_hoveredContainer
=
null
;
if
(
this
.
htmlEditor
)
{
this
.
htmlEditor
.
destroy
(
)
;
this
.
htmlEditor
=
null
;
}
this
.
undo
.
destroy
(
)
;
this
.
undo
=
null
;
this
.
popup
.
destroy
(
)
;
this
.
popup
=
null
;
this
.
_elt
.
removeEventListener
(
"
blur
"
this
.
_onBlur
true
)
;
this
.
_elt
.
removeEventListener
(
"
click
"
this
.
_onMouseClick
)
;
this
.
_elt
.
removeEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
this
.
_elt
.
removeEventListener
(
"
mouseout
"
this
.
_onMouseOut
)
;
this
.
_frame
.
removeEventListener
(
"
focus
"
this
.
_onFocus
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
_onNewSelection
)
;
this
.
toolbox
.
off
(
"
picker
-
node
-
hovered
"
this
.
_onToolboxPickerHover
)
;
this
.
walker
.
off
(
"
display
-
change
"
this
.
_onDisplayChange
)
;
this
.
walker
.
off
(
"
mutations
"
this
.
_mutationObserver
)
;
this
.
win
.
removeEventListener
(
"
copy
"
this
.
_onCopy
)
;
this
.
win
.
removeEventListener
(
"
mouseup
"
this
.
_onMouseUp
)
;
this
.
_prefObserver
.
off
(
ATTR_COLLAPSE_ENABLED_PREF
this
.
_onCollapseAttributesPrefChange
)
;
this
.
_prefObserver
.
off
(
ATTR_COLLAPSE_LENGTH_PREF
this
.
_onCollapseAttributesPrefChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
this
.
_elt
=
null
;
for
(
const
[
container
]
of
this
.
_containers
)
{
container
.
destroy
(
)
;
}
this
.
_containers
=
null
;
this
.
eventDetailsTooltip
.
destroy
(
)
;
this
.
eventDetailsTooltip
=
null
;
this
.
imagePreviewTooltip
.
destroy
(
)
;
this
.
imagePreviewTooltip
=
null
;
this
.
doc
=
null
;
this
.
highlighters
=
null
;
this
.
win
=
null
;
this
.
_lastDropTarget
=
null
;
this
.
_lastDragTarget
=
null
;
return
this
.
_destroyer
;
}
findClosestDragDropTarget
:
function
(
el
)
{
return
el
.
classList
.
contains
(
"
tag
-
line
"
)
?
el
:
el
.
querySelector
(
"
.
tag
-
line
"
)
|
|
el
.
closest
(
"
.
tag
-
line
"
)
;
}
indicateDropTarget
:
function
(
el
)
{
if
(
this
.
_lastDropTarget
)
{
this
.
_lastDropTarget
.
classList
.
remove
(
"
drop
-
target
"
)
;
}
if
(
!
el
)
{
return
;
}
const
target
=
this
.
findClosestDragDropTarget
(
el
)
;
if
(
target
)
{
target
.
classList
.
add
(
"
drop
-
target
"
)
;
this
.
_lastDropTarget
=
target
;
}
}
indicateDragTarget
:
function
(
el
)
{
if
(
this
.
_lastDragTarget
)
{
this
.
_lastDragTarget
.
classList
.
remove
(
"
drag
-
target
"
)
;
}
if
(
!
el
)
{
return
;
}
const
target
=
this
.
findClosestDragDropTarget
(
el
)
;
if
(
target
)
{
target
.
classList
.
add
(
"
drag
-
target
"
)
;
this
.
_lastDragTarget
=
target
;
}
}
get
dropTargetNodes
(
)
{
const
target
=
this
.
_lastDropTarget
;
if
(
!
target
)
{
return
null
;
}
let
parent
nextSibling
;
if
(
target
.
previousElementSibling
&
&
target
.
previousElementSibling
.
nodeName
.
toLowerCase
(
)
=
=
=
"
ul
"
)
{
parent
=
target
.
parentNode
.
container
.
node
;
nextSibling
=
null
;
}
else
{
parent
=
target
.
parentNode
.
container
.
node
.
parentNode
(
)
;
nextSibling
=
target
.
parentNode
.
container
.
node
;
}
if
(
nextSibling
&
&
nextSibling
.
isBeforePseudoElement
)
{
nextSibling
=
target
.
parentNode
.
parentNode
.
children
[
1
]
.
container
.
node
;
}
if
(
nextSibling
&
&
nextSibling
.
isAfterPseudoElement
)
{
parent
=
target
.
parentNode
.
container
.
node
.
parentNode
(
)
;
nextSibling
=
null
;
}
if
(
parent
.
nodeType
!
=
=
nodeConstants
.
ELEMENT_NODE
)
{
return
null
;
}
return
{
parent
nextSibling
}
;
}
}
;
function
map
(
value
oldMin
oldMax
newMin
newMax
)
{
const
ratio
=
oldMax
-
oldMin
;
if
(
ratio
=
=
0
)
{
return
value
;
}
return
newMin
+
(
newMax
-
newMin
)
*
(
(
value
-
oldMin
)
/
ratio
)
;
}
module
.
exports
=
MarkupView
;
