"
use
strict
"
;
const
PREVIEW_MAX_DIM_PREF
=
"
devtools
.
inspector
.
imagePreviewTooltipSize
"
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
Heritage
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
clipboardHelper
=
require
(
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
{
setImageTooltip
setBrokenImageTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
ImageTooltipHelper
"
)
;
const
{
setEventTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
EventTooltipHelper
"
)
;
const
MarkupContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
markup
-
container
"
)
;
const
ElementEditor
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
element
-
editor
"
)
;
function
MarkupElementContainer
(
markupView
node
)
{
MarkupContainer
.
prototype
.
initialize
.
call
(
this
markupView
node
"
elementcontainer
"
)
;
if
(
node
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
{
this
.
editor
=
new
ElementEditor
(
this
node
)
;
}
else
{
throw
new
Error
(
"
Invalid
node
for
MarkupElementContainer
"
)
;
}
this
.
tagLine
.
appendChild
(
this
.
editor
.
elt
)
;
}
MarkupElementContainer
.
prototype
=
Heritage
.
extend
(
MarkupContainer
.
prototype
{
_buildEventTooltipContent
:
Task
.
async
(
function
*
(
target
tooltip
)
{
if
(
target
.
hasAttribute
(
"
data
-
event
"
)
)
{
yield
tooltip
.
hide
(
)
;
let
listenerInfo
=
yield
this
.
node
.
getEventListenerInfo
(
)
;
let
toolbox
=
this
.
markup
.
toolbox
;
setEventTooltip
(
tooltip
listenerInfo
toolbox
)
;
this
.
markup
.
_disableImagePreviewTooltip
(
)
;
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
this
.
markup
.
_enableImagePreviewTooltip
(
)
;
}
)
;
tooltip
.
show
(
target
)
;
}
}
)
_getPreview
:
function
(
)
{
if
(
!
this
.
isPreviewable
(
)
)
{
return
promise
.
reject
(
"
_getPreview
called
on
a
non
-
previewable
element
.
"
)
;
}
if
(
this
.
tooltipDataPromise
)
{
return
this
.
tooltipDataPromise
;
}
this
.
tooltipDataPromise
=
Task
.
spawn
(
function
*
(
)
{
let
maxDim
=
Services
.
prefs
.
getIntPref
(
PREVIEW_MAX_DIM_PREF
)
;
let
preview
=
yield
this
.
node
.
getImageData
(
maxDim
)
;
let
data
=
yield
preview
.
data
.
string
(
)
;
this
.
tooltipDataPromise
=
null
;
return
{
data
size
:
preview
.
size
}
;
}
.
bind
(
this
)
)
;
return
this
.
tooltipDataPromise
;
}
isImagePreviewTarget
:
Task
.
async
(
function
*
(
target
tooltip
)
{
if
(
!
this
.
isPreviewable
(
)
)
{
return
false
;
}
let
src
=
this
.
editor
.
getAttributeElement
(
"
src
"
)
;
let
expectedTarget
=
src
?
src
.
querySelector
(
"
.
link
"
)
:
this
.
editor
.
tag
;
if
(
target
!
=
=
expectedTarget
)
{
return
false
;
}
try
{
let
{
data
size
}
=
yield
this
.
_getPreview
(
)
;
let
options
=
{
naturalWidth
:
size
.
naturalWidth
naturalHeight
:
size
.
naturalHeight
maxDim
:
Services
.
prefs
.
getIntPref
(
PREVIEW_MAX_DIM_PREF
)
}
;
setImageTooltip
(
tooltip
this
.
markup
.
doc
data
options
)
;
}
catch
(
e
)
{
setBrokenImageTooltip
(
tooltip
this
.
markup
.
doc
)
;
}
return
true
;
}
)
copyImageDataUri
:
function
(
)
{
this
.
node
.
getImageData
(
)
.
then
(
data
=
>
{
data
.
data
.
string
(
)
.
then
(
str
=
>
{
clipboardHelper
.
copyString
(
str
)
;
}
)
;
}
)
;
}
setInlineTextChild
:
function
(
inlineTextChild
)
{
this
.
inlineTextChild
=
inlineTextChild
;
this
.
editor
.
updateTextEditor
(
)
;
}
clearInlineTextChild
:
function
(
)
{
this
.
inlineTextChild
=
undefined
;
this
.
editor
.
updateTextEditor
(
)
;
}
addAttribute
:
function
(
)
{
this
.
editor
.
newAttr
.
editMode
(
)
;
}
editAttribute
:
function
(
attrName
)
{
this
.
editor
.
attrElements
.
get
(
attrName
)
.
editMode
(
)
;
}
removeAttribute
:
function
(
attrName
)
{
let
doMods
=
this
.
editor
.
_startModifyingAttributes
(
)
;
let
undoMods
=
this
.
editor
.
_startModifyingAttributes
(
)
;
this
.
editor
.
_saveAttribute
(
attrName
undoMods
)
;
doMods
.
removeAttribute
(
attrName
)
;
this
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
(
)
=
>
{
undoMods
.
apply
(
)
;
}
)
;
}
}
)
;
module
.
exports
=
MarkupElementContainer
;
