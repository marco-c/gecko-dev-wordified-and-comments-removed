"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
MarkupContainer
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
markup
-
container
"
)
;
const
ElementEditor
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
element
-
editor
"
)
;
const
{
ELEMENT_NODE
}
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventTooltip
"
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
EventTooltipHelper
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
setImageTooltip
"
"
setBrokenImageTooltip
"
]
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
ImageTooltipHelper
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
clipboardHelper
"
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
const
PREVIEW_MAX_DIM_PREF
=
"
devtools
.
inspector
.
imagePreviewTooltipSize
"
;
function
MarkupElementContainer
(
markupView
node
)
{
MarkupContainer
.
prototype
.
initialize
.
call
(
this
markupView
node
"
elementcontainer
"
)
;
if
(
node
.
nodeType
=
=
=
ELEMENT_NODE
)
{
this
.
editor
=
new
ElementEditor
(
this
node
)
;
}
else
{
throw
new
Error
(
"
Invalid
node
for
MarkupElementContainer
"
)
;
}
this
.
tagLine
.
appendChild
(
this
.
editor
.
elt
)
;
}
MarkupElementContainer
.
prototype
=
extend
(
MarkupContainer
.
prototype
{
onContainerClick
(
event
)
{
if
(
!
event
.
target
.
hasAttribute
(
"
data
-
event
"
)
)
{
return
;
}
this
.
_buildEventTooltipContent
(
event
.
target
)
;
}
async
_buildEventTooltipContent
(
target
)
{
const
tooltip
=
this
.
markup
.
eventDetailsTooltip
;
await
tooltip
.
hide
(
)
;
const
listenerInfo
=
await
this
.
node
.
getEventListenerInfo
(
)
;
const
toolbox
=
this
.
markup
.
toolbox
;
const
eventTooltip
=
new
EventTooltip
(
tooltip
listenerInfo
toolbox
this
.
node
)
;
eventTooltip
.
on
(
"
event
-
tooltip
-
listener
-
toggled
"
(
{
hasDisabledEventListeners
}
)
=
>
{
const
className
=
"
has
-
disabled
-
events
"
;
if
(
hasDisabledEventListeners
)
{
this
.
editor
.
_eventBadge
.
classList
.
add
(
className
)
;
}
else
{
this
.
editor
.
_eventBadge
.
classList
.
remove
(
className
)
;
}
}
)
;
this
.
markup
.
_disableImagePreviewTooltip
(
)
;
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
eventTooltip
.
destroy
(
)
;
this
.
markup
.
_enableImagePreviewTooltip
(
)
;
this
.
markup
.
win
.
setTimeout
(
(
)
=
>
{
if
(
this
.
editor
.
_eventBadge
)
{
this
.
editor
.
_eventBadge
.
style
.
pointerEvents
=
"
auto
"
;
}
}
0
)
;
}
)
;
if
(
this
.
editor
.
_eventBadge
)
{
this
.
editor
.
_eventBadge
.
style
.
pointerEvents
=
"
none
"
;
}
tooltip
.
show
(
target
)
;
}
_getPreview
(
)
{
if
(
!
this
.
isPreviewable
(
)
)
{
return
Promise
.
reject
(
"
_getPreview
called
on
a
non
-
previewable
element
.
"
)
;
}
if
(
this
.
tooltipDataPromise
)
{
return
this
.
tooltipDataPromise
;
}
this
.
tooltipDataPromise
=
async
function
(
)
{
const
maxDim
=
Services
.
prefs
.
getIntPref
(
PREVIEW_MAX_DIM_PREF
)
;
const
preview
=
await
this
.
node
.
getImageData
(
maxDim
)
;
const
data
=
await
preview
.
data
.
string
(
)
;
this
.
tooltipDataPromise
=
null
;
return
{
data
size
:
preview
.
size
}
;
}
.
bind
(
this
)
(
)
;
return
this
.
tooltipDataPromise
;
}
async
isImagePreviewTarget
(
target
tooltip
)
{
if
(
!
this
.
isPreviewable
(
)
)
{
return
false
;
}
const
src
=
this
.
editor
.
getAttributeElement
(
"
src
"
)
;
const
expectedTarget
=
src
?
src
.
querySelector
(
"
.
link
"
)
:
this
.
editor
.
tag
;
if
(
target
!
=
=
expectedTarget
)
{
return
false
;
}
try
{
const
{
data
size
}
=
await
this
.
_getPreview
(
)
;
const
options
=
{
naturalWidth
:
size
.
naturalWidth
naturalHeight
:
size
.
naturalHeight
maxDim
:
Services
.
prefs
.
getIntPref
(
PREVIEW_MAX_DIM_PREF
)
}
;
setImageTooltip
(
tooltip
this
.
markup
.
doc
data
options
)
;
}
catch
(
e
)
{
setBrokenImageTooltip
(
tooltip
this
.
markup
.
doc
)
;
}
return
true
;
}
copyImageDataUri
(
)
{
this
.
node
.
getImageData
(
)
.
then
(
data
=
>
{
data
.
data
.
string
(
)
.
then
(
str
=
>
{
clipboardHelper
.
copyString
(
str
)
;
}
)
;
}
)
;
}
setInlineTextChild
(
inlineTextChild
)
{
this
.
inlineTextChild
=
inlineTextChild
;
this
.
editor
.
updateTextEditor
(
)
;
}
clearInlineTextChild
(
)
{
this
.
inlineTextChild
=
undefined
;
this
.
editor
.
updateTextEditor
(
)
;
}
addAttribute
(
)
{
this
.
editor
.
newAttr
.
editMode
(
)
;
}
editAttribute
(
attrName
)
{
this
.
editor
.
attrElements
.
get
(
attrName
)
.
editMode
(
)
;
}
removeAttribute
(
attrName
)
{
const
doMods
=
this
.
editor
.
_startModifyingAttributes
(
)
;
const
undoMods
=
this
.
editor
.
_startModifyingAttributes
(
)
;
this
.
editor
.
_saveAttribute
(
attrName
undoMods
)
;
doMods
.
removeAttribute
(
attrName
)
;
this
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
(
)
=
>
{
undoMods
.
apply
(
)
;
}
)
;
}
}
)
;
module
.
exports
=
MarkupElementContainer
;
