"
use
strict
"
;
const
{
KeyCodes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
keycodes
.
js
"
)
;
const
{
flashElementOn
flashElementOff
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
markup
/
utils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
wrapMoveFocus
"
"
resource
:
/
/
devtools
/
client
/
shared
/
focus
.
js
"
true
)
;
const
DRAG_DROP_MIN_INITIAL_DISTANCE
=
10
;
const
TYPES
=
{
TEXT_CONTAINER
:
"
textcontainer
"
ELEMENT_CONTAINER
:
"
elementcontainer
"
READ_ONLY_CONTAINER
:
"
readonlycontainer
"
}
;
function
MarkupContainer
(
)
{
}
let
markupContainerID
=
0
;
MarkupContainer
.
prototype
=
{
get
undo
(
)
{
return
this
.
markup
.
undo
;
}
initialize
(
markupView
node
type
)
{
this
.
markup
=
markupView
;
this
.
node
=
node
;
this
.
type
=
type
;
this
.
win
=
this
.
markup
.
_frame
.
contentWindow
;
this
.
id
=
"
treeitem
-
"
+
markupContainerID
+
+
;
this
.
htmlElt
=
this
.
win
.
document
.
documentElement
;
this
.
buildMarkup
(
)
;
this
.
elt
.
container
=
this
;
this
.
_onMouseDown
=
this
.
_onMouseDown
.
bind
(
this
)
;
this
.
_onToggle
=
this
.
_onToggle
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
elt
.
addEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
elt
.
addEventListener
(
"
dblclick
"
this
.
_onToggle
)
;
if
(
this
.
expander
)
{
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onToggle
)
;
}
this
.
updateIsDisplayed
(
)
;
if
(
node
.
isShadowRoot
)
{
this
.
markup
.
telemetry
.
scalarSet
(
"
devtools
.
shadowdom
.
shadow_root_displayed
"
true
)
;
}
}
buildMarkup
(
)
{
this
.
elt
=
this
.
win
.
document
.
createElement
(
"
li
"
)
;
this
.
elt
.
classList
.
add
(
"
child
"
"
collapsed
"
)
;
this
.
elt
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
=
this
.
win
.
document
.
createElement
(
"
div
"
)
;
this
.
tagLine
.
setAttribute
(
"
id
"
this
.
id
)
;
this
.
tagLine
.
classList
.
add
(
"
tag
-
line
"
)
;
this
.
tagLine
.
setAttribute
(
"
role
"
"
treeitem
"
)
;
this
.
tagLine
.
setAttribute
(
"
aria
-
level
"
this
.
level
)
;
this
.
tagLine
.
setAttribute
(
"
aria
-
grabbed
"
this
.
isDragging
)
;
this
.
elt
.
appendChild
(
this
.
tagLine
)
;
this
.
mutationMarker
=
this
.
win
.
document
.
createElement
(
"
div
"
)
;
this
.
mutationMarker
.
classList
.
add
(
"
markup
-
tag
-
mutation
-
marker
"
)
;
this
.
mutationMarker
.
style
.
setProperty
(
"
-
-
markup
-
level
"
this
.
level
)
;
this
.
tagLine
.
appendChild
(
this
.
mutationMarker
)
;
this
.
tagState
=
this
.
win
.
document
.
createElement
(
"
span
"
)
;
this
.
tagState
.
classList
.
add
(
"
tag
-
state
"
)
;
this
.
tagState
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
.
appendChild
(
this
.
tagState
)
;
if
(
this
.
type
!
=
=
TYPES
.
TEXT_CONTAINER
)
{
this
.
expander
=
this
.
win
.
document
.
createElement
(
"
span
"
)
;
this
.
expander
.
classList
.
add
(
"
theme
-
twisty
"
"
expander
"
)
;
this
.
expander
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
.
appendChild
(
this
.
expander
)
;
}
this
.
children
=
this
.
win
.
document
.
createElement
(
"
ul
"
)
;
this
.
children
.
classList
.
add
(
"
children
"
)
;
this
.
children
.
setAttribute
(
"
role
"
"
group
"
)
;
this
.
elt
.
appendChild
(
this
.
children
)
;
}
toString
(
)
{
return
"
[
MarkupContainer
for
"
+
this
.
node
+
"
]
"
;
}
isPreviewable
(
)
{
if
(
this
.
node
.
tagName
&
&
!
this
.
node
.
isPseudoElement
)
{
const
tagName
=
this
.
node
.
tagName
.
toLowerCase
(
)
;
const
srcAttr
=
this
.
editor
.
getAttributeElement
(
"
src
"
)
;
const
isImage
=
tagName
=
=
=
"
img
"
&
&
srcAttr
;
const
isCanvas
=
tagName
=
=
=
"
canvas
"
;
return
isImage
|
|
isCanvas
;
}
return
false
;
}
updateIsDisplayed
(
)
{
this
.
elt
.
classList
.
remove
(
"
not
-
displayed
"
)
;
if
(
!
this
.
node
.
isDisplayed
|
|
this
.
node
.
hidden
)
{
this
.
elt
.
classList
.
add
(
"
not
-
displayed
"
)
;
}
}
_hasChildren
:
false
get
hasChildren
(
)
{
return
this
.
_hasChildren
;
}
set
hasChildren
(
value
)
{
this
.
_hasChildren
=
value
;
this
.
updateExpander
(
)
;
}
get
focusableElms
(
)
{
return
[
.
.
.
this
.
tagLine
.
querySelectorAll
(
"
[
tabindex
]
"
)
]
;
}
get
canFocus
(
)
{
return
this
.
_canFocus
;
}
set
canFocus
(
value
)
{
if
(
this
.
_canFocus
=
=
=
value
)
{
return
;
}
this
.
_canFocus
=
value
;
if
(
value
)
{
this
.
tagLine
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
focusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
0
"
)
)
;
}
else
{
this
.
tagLine
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
focusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
}
}
clearFocus
(
)
{
if
(
!
this
.
canFocus
)
{
return
;
}
this
.
canFocus
=
false
;
const
doc
=
this
.
markup
.
doc
;
if
(
!
doc
.
activeElement
|
|
doc
.
activeElement
=
=
=
doc
.
body
)
{
return
;
}
let
parent
=
doc
.
activeElement
;
while
(
parent
&
&
parent
!
=
=
this
.
elt
)
{
parent
=
parent
.
parentNode
;
}
if
(
parent
)
{
doc
.
activeElement
.
blur
(
)
;
}
}
get
canExpand
(
)
{
return
this
.
_hasChildren
&
&
!
this
.
node
.
inlineTextChild
;
}
get
mustExpand
(
)
{
return
this
.
node
.
_parent
=
=
=
this
.
markup
.
walker
.
rootNode
;
}
get
showExpander
(
)
{
return
this
.
canExpand
&
&
!
this
.
mustExpand
;
}
updateExpander
(
)
{
if
(
!
this
.
expander
)
{
return
;
}
if
(
this
.
showExpander
)
{
this
.
elt
.
classList
.
add
(
"
expandable
"
)
;
this
.
expander
.
style
.
visibility
=
"
visible
"
;
this
.
tagLine
.
setAttribute
(
"
aria
-
expanded
"
this
.
expanded
)
;
}
else
{
this
.
elt
.
classList
.
remove
(
"
expandable
"
)
;
this
.
expander
.
style
.
visibility
=
"
hidden
"
;
this
.
tagLine
.
removeAttribute
(
"
aria
-
expanded
"
)
;
}
}
setChildrenRole
(
)
{
this
.
children
.
setAttribute
(
"
role
"
this
.
hasChildren
?
"
group
"
:
"
presentation
"
)
;
}
updateLevel
(
)
{
const
currentLevel
=
this
.
tagLine
.
getAttribute
(
"
aria
-
level
"
)
;
const
newLevel
=
this
.
level
;
if
(
currentLevel
=
=
=
newLevel
)
{
return
;
}
this
.
tagLine
.
setAttribute
(
"
aria
-
level
"
newLevel
)
;
const
childContainers
=
this
.
getChildContainers
(
)
;
if
(
childContainers
)
{
childContainers
.
forEach
(
container
=
>
container
.
updateLevel
(
)
)
;
}
}
getChildContainers
(
)
{
if
(
!
this
.
hasChildren
)
{
return
null
;
}
return
[
.
.
.
this
.
children
.
children
]
.
filter
(
node
=
>
node
.
container
)
.
map
(
node
=
>
node
.
container
)
;
}
get
expanded
(
)
{
return
!
this
.
elt
.
classList
.
contains
(
"
collapsed
"
)
;
}
setExpanded
(
value
)
{
if
(
!
this
.
expander
)
{
return
;
}
if
(
!
this
.
canExpand
)
{
value
=
false
;
}
if
(
this
.
mustExpand
)
{
value
=
true
;
}
if
(
value
&
&
this
.
elt
.
classList
.
contains
(
"
collapsed
"
)
)
{
this
.
showCloseTagLine
(
)
;
this
.
elt
.
classList
.
remove
(
"
collapsed
"
)
;
this
.
expander
.
setAttribute
(
"
open
"
"
"
)
;
this
.
hovered
=
false
;
this
.
markup
.
emit
(
"
expanded
"
)
;
}
else
if
(
!
value
)
{
this
.
hideCloseTagLine
(
)
;
this
.
elt
.
classList
.
add
(
"
collapsed
"
)
;
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
markup
.
emit
(
"
collapsed
"
)
;
}
if
(
this
.
showExpander
)
{
this
.
tagLine
.
setAttribute
(
"
aria
-
expanded
"
this
.
expanded
)
;
}
if
(
this
.
node
.
isShadowRoot
)
{
this
.
markup
.
telemetry
.
scalarSet
(
"
devtools
.
shadowdom
.
shadow_root_expanded
"
true
)
;
}
}
showCloseTagLine
(
)
{
if
(
this
.
type
!
=
=
TYPES
.
ELEMENT_CONTAINER
)
{
return
;
}
const
closingTag
=
this
.
elt
.
querySelector
(
"
.
close
"
)
;
if
(
!
closingTag
)
{
return
;
}
if
(
!
this
.
closeTagLine
)
{
const
line
=
this
.
markup
.
doc
.
createElement
(
"
div
"
)
;
line
.
classList
.
add
(
"
tag
-
line
"
)
;
line
.
setAttribute
(
"
role
"
"
presentation
"
)
;
const
tagState
=
this
.
markup
.
doc
.
createElement
(
"
div
"
)
;
tagState
.
classList
.
add
(
"
tag
-
state
"
)
;
line
.
appendChild
(
tagState
)
;
line
.
appendChild
(
closingTag
.
cloneNode
(
true
)
)
;
flashElementOff
(
line
)
;
this
.
closeTagLine
=
line
;
}
this
.
elt
.
appendChild
(
this
.
closeTagLine
)
;
}
hideCloseTagLine
(
)
{
if
(
!
this
.
closeTagLine
)
{
return
;
}
this
.
elt
.
removeChild
(
this
.
closeTagLine
)
;
this
.
closeTagLine
=
undefined
;
}
parentContainer
(
)
{
return
this
.
elt
.
parentNode
?
this
.
elt
.
parentNode
.
container
:
null
;
}
get
level
(
)
{
let
level
=
1
;
let
parent
=
this
.
node
.
parentNode
(
)
;
while
(
parent
&
&
parent
!
=
=
this
.
markup
.
walker
.
rootNode
)
{
level
+
+
;
parent
=
parent
.
parentNode
(
)
;
}
return
level
;
}
_isDragging
:
false
_dragStartY
:
0
set
isDragging
(
isDragging
)
{
const
rootElt
=
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
.
elt
;
this
.
_isDragging
=
isDragging
;
this
.
markup
.
isDragging
=
isDragging
;
this
.
tagLine
.
setAttribute
(
"
aria
-
grabbed
"
isDragging
)
;
if
(
isDragging
)
{
this
.
htmlElt
.
classList
.
add
(
"
dragging
"
)
;
this
.
elt
.
classList
.
add
(
"
dragging
"
)
;
this
.
markup
.
doc
.
body
.
classList
.
add
(
"
dragging
"
)
;
rootElt
.
setAttribute
(
"
aria
-
dropeffect
"
"
move
"
)
;
}
else
{
this
.
htmlElt
.
classList
.
remove
(
"
dragging
"
)
;
this
.
elt
.
classList
.
remove
(
"
dragging
"
)
;
this
.
markup
.
doc
.
body
.
classList
.
remove
(
"
dragging
"
)
;
rootElt
.
setAttribute
(
"
aria
-
dropeffect
"
"
none
"
)
;
}
}
get
isDragging
(
)
{
return
this
.
_isDragging
;
}
isDraggable
(
)
{
const
tagName
=
this
.
node
.
tagName
&
&
this
.
node
.
tagName
.
toLowerCase
(
)
;
return
(
!
this
.
node
.
isPseudoElement
&
&
!
this
.
node
.
isAnonymous
&
&
!
this
.
node
.
isDocumentElement
&
&
tagName
!
=
=
"
body
"
&
&
tagName
!
=
=
"
head
"
&
&
this
.
win
.
getSelection
(
)
.
isCollapsed
&
&
this
.
node
.
parentNode
(
)
&
&
this
.
node
.
parentNode
(
)
.
tagName
!
=
=
null
)
;
}
isSlotted
(
)
{
return
false
;
}
_onKeyDown
(
event
)
{
const
{
target
keyCode
shiftKey
}
=
event
;
const
isInput
=
this
.
markup
.
_isInputOrTextarea
(
target
)
;
if
(
isInput
&
&
keyCode
!
=
=
KeyCodes
.
DOM_VK_TAB
)
{
return
;
}
switch
(
keyCode
)
{
case
KeyCodes
.
DOM_VK_TAB
:
if
(
isInput
)
{
const
next
=
wrapMoveFocus
(
this
.
focusableElms
target
.
nextSibling
shiftKey
)
;
if
(
next
)
{
event
.
preventDefault
(
)
;
if
(
next
.
_editable
)
{
const
e
=
this
.
markup
.
doc
.
createEvent
(
"
Event
"
)
;
e
.
initEvent
(
next
.
_trigger
true
true
)
;
next
.
dispatchEvent
(
e
)
;
}
}
}
else
{
const
next
=
wrapMoveFocus
(
this
.
focusableElms
target
shiftKey
)
;
if
(
next
)
{
event
.
preventDefault
(
)
;
}
}
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
this
.
clearFocus
(
)
;
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
.
elt
.
focus
(
)
;
if
(
this
.
isDragging
)
{
return
;
}
event
.
preventDefault
(
)
;
break
;
default
:
return
;
}
event
.
stopPropagation
(
)
;
}
_onMouseDown
(
event
)
{
const
{
target
button
metaKey
ctrlKey
}
=
event
;
const
isLeftClick
=
button
=
=
=
0
;
const
isMiddleClick
=
button
=
=
=
1
;
const
isMetaClick
=
isLeftClick
&
&
(
metaKey
|
|
ctrlKey
)
;
if
(
target
.
nodeName
=
=
=
"
button
"
)
{
return
;
}
if
(
target
.
classList
.
contains
(
"
expander
"
)
)
{
return
;
}
this
.
hovered
=
false
;
this
.
markup
.
navigate
(
this
)
;
this
.
canFocus
=
true
;
this
.
focus
(
)
;
event
.
stopPropagation
(
)
;
if
(
!
target
.
closest
(
"
.
editor
[
tabindex
]
"
)
)
{
event
.
preventDefault
(
)
;
}
if
(
isMiddleClick
)
{
event
.
preventDefault
(
)
;
}
if
(
isMiddleClick
|
|
isMetaClick
)
{
const
link
=
target
.
dataset
.
link
;
const
type
=
target
.
dataset
.
type
;
this
.
canFocus
=
false
;
this
.
markup
.
followAttributeLink
(
type
link
)
;
return
;
}
if
(
isLeftClick
&
&
this
.
isDraggable
(
)
)
{
this
.
_isPreDragging
=
true
;
this
.
_dragStartY
=
event
.
pageY
;
this
.
markup
.
_draggedContainer
=
this
;
}
}
async
onMouseUp
(
)
{
this
.
_isPreDragging
=
false
;
this
.
markup
.
_draggedContainer
=
null
;
if
(
this
.
isDragging
)
{
this
.
cancelDragging
(
)
;
if
(
!
this
.
markup
.
dropTargetNodes
)
{
return
;
}
const
{
nextSibling
parent
}
=
this
.
markup
.
dropTargetNodes
;
const
{
walkerFront
}
=
parent
;
await
walkerFront
.
insertBefore
(
this
.
node
parent
nextSibling
)
;
this
.
markup
.
emit
(
"
drop
-
completed
"
)
;
}
}
onMouseMove
(
event
)
{
const
initialDiff
=
Math
.
abs
(
event
.
pageY
-
this
.
_dragStartY
)
;
if
(
this
.
_isPreDragging
&
&
initialDiff
>
=
DRAG_DROP_MIN_INITIAL_DISTANCE
)
{
this
.
_isPreDragging
=
false
;
this
.
isDragging
=
true
;
const
position
=
this
.
elt
.
nextElementSibling
|
|
this
.
markup
.
getContainer
(
this
.
node
.
parentNode
(
)
)
.
closeTagLine
;
this
.
markup
.
indicateDragTarget
(
position
)
;
}
if
(
this
.
isDragging
)
{
const
x
=
0
;
let
y
=
event
.
pageY
-
this
.
win
.
scrollY
;
if
(
y
<
0
)
{
y
=
0
;
}
else
if
(
y
>
=
this
.
markup
.
doc
.
body
.
offsetHeight
-
this
.
win
.
scrollY
)
{
y
=
this
.
markup
.
doc
.
body
.
offsetHeight
-
this
.
win
.
scrollY
-
1
;
}
const
diff
=
y
-
this
.
_dragStartY
+
this
.
win
.
scrollY
;
this
.
elt
.
style
.
top
=
diff
+
"
px
"
;
const
el
=
this
.
markup
.
doc
.
elementFromPoint
(
x
y
)
;
this
.
markup
.
indicateDropTarget
(
el
)
;
}
}
cancelDragging
(
)
{
if
(
!
this
.
isDragging
)
{
return
;
}
this
.
_isPreDragging
=
false
;
this
.
isDragging
=
false
;
this
.
elt
.
style
.
removeProperty
(
"
top
"
)
;
}
flashMutation
(
)
{
if
(
!
this
.
selected
)
{
flashElementOn
(
this
.
tagState
{
foregroundElt
:
this
.
editor
.
elt
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
if
(
this
.
_flashMutationTimer
)
{
clearTimeout
(
this
.
_flashMutationTimer
)
;
this
.
_flashMutationTimer
=
null
;
}
this
.
_flashMutationTimer
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
this
.
tagState
{
foregroundElt
:
this
.
editor
.
elt
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
}
this
.
markup
.
CONTAINER_FLASHING_DURATION
)
;
}
}
_hovered
:
false
set
hovered
(
value
)
{
this
.
tagState
.
classList
.
remove
(
"
flash
-
out
"
)
;
this
.
_hovered
=
value
;
if
(
value
)
{
if
(
!
this
.
selected
)
{
this
.
tagState
.
classList
.
add
(
"
tag
-
hover
"
)
;
}
if
(
this
.
closeTagLine
)
{
this
.
closeTagLine
.
querySelector
(
"
.
tag
-
state
"
)
.
classList
.
add
(
"
tag
-
hover
"
)
;
}
}
else
{
this
.
tagState
.
classList
.
remove
(
"
tag
-
hover
"
)
;
if
(
this
.
closeTagLine
)
{
this
.
closeTagLine
.
querySelector
(
"
.
tag
-
state
"
)
.
classList
.
remove
(
"
tag
-
hover
"
)
;
}
}
}
get
visible
(
)
{
return
this
.
elt
.
getBoundingClientRect
(
)
.
height
>
0
;
}
_selected
:
false
get
selected
(
)
{
return
this
.
_selected
;
}
set
selected
(
value
)
{
this
.
tagState
.
classList
.
remove
(
"
flash
-
out
"
)
;
this
.
_selected
=
value
;
this
.
editor
.
selected
=
value
;
this
.
tagLine
.
setAttribute
(
"
aria
-
selected
"
value
)
;
if
(
this
.
_selected
)
{
const
container
=
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
;
if
(
container
)
{
container
.
elt
.
setAttribute
(
"
aria
-
activedescendant
"
this
.
id
)
;
}
this
.
tagLine
.
setAttribute
(
"
selected
"
"
"
)
;
this
.
tagState
.
classList
.
add
(
"
theme
-
selected
"
)
;
}
else
{
this
.
tagLine
.
removeAttribute
(
"
selected
"
)
;
this
.
tagState
.
classList
.
remove
(
"
theme
-
selected
"
)
;
}
}
update
(
mutationBreakpoints
)
{
if
(
this
.
node
.
pseudoClassLocks
.
length
)
{
this
.
elt
.
classList
.
add
(
"
pseudoclass
-
locked
"
)
;
}
else
{
this
.
elt
.
classList
.
remove
(
"
pseudoclass
-
locked
"
)
;
}
if
(
mutationBreakpoints
)
{
const
allMutationsDisabled
=
Array
.
from
(
mutationBreakpoints
.
values
(
)
)
.
every
(
element
=
>
element
=
=
=
false
)
;
if
(
mutationBreakpoints
.
size
>
0
)
{
this
.
mutationMarker
.
classList
.
add
(
"
has
-
mutations
"
)
;
this
.
mutationMarker
.
classList
.
toggle
(
"
mutation
-
breakpoint
-
disabled
"
allMutationsDisabled
)
;
}
else
{
this
.
mutationMarker
.
classList
.
remove
(
"
has
-
mutations
"
)
;
}
}
this
.
updateIsDisplayed
(
)
;
if
(
this
.
editor
.
update
)
{
this
.
editor
.
update
(
)
;
}
}
focus
(
)
{
const
focusable
=
this
.
editor
.
elt
.
querySelector
(
"
[
tabindex
=
'
0
'
]
"
)
;
if
(
focusable
)
{
focusable
.
focus
(
)
;
}
}
_onToggle
(
event
)
{
event
.
stopPropagation
(
)
;
if
(
event
.
target
.
dataset
.
event
|
|
event
.
target
.
dataset
.
display
|
|
event
.
target
.
dataset
.
scrollable
)
{
return
;
}
this
.
expandContainer
(
event
.
altKey
)
;
}
expandContainer
(
applyToDescendants
)
{
if
(
this
.
hasChildren
)
{
this
.
markup
.
setNodeExpanded
(
this
.
node
!
this
.
expanded
applyToDescendants
)
;
}
}
destroy
(
)
{
this
.
elt
.
removeEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
elt
.
removeEventListener
(
"
dblclick
"
this
.
_onToggle
)
;
this
.
tagLine
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
if
(
this
.
markup
.
_draggedContainer
=
=
=
this
)
{
this
.
markup
.
_draggedContainer
=
null
;
}
this
.
win
=
null
;
this
.
htmlElt
=
null
;
if
(
this
.
expander
)
{
this
.
expander
.
removeEventListener
(
"
click
"
this
.
_onToggle
)
;
}
let
firstChild
=
this
.
children
.
firstChild
;
while
(
firstChild
)
{
if
(
firstChild
.
container
)
{
firstChild
.
container
.
destroy
(
)
;
}
this
.
children
.
removeChild
(
firstChild
)
;
firstChild
=
this
.
children
.
firstChild
;
}
this
.
editor
.
destroy
(
)
;
}
}
;
module
.
exports
=
MarkupContainer
;
