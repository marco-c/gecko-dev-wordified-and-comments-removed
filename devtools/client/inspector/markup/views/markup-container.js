"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
flashElementOn
flashElementOff
}
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
utils
"
)
;
const
DRAG_DROP_MIN_INITIAL_DISTANCE
=
10
;
function
MarkupContainer
(
)
{
}
let
markupContainerID
=
0
;
MarkupContainer
.
prototype
=
{
initialize
:
function
(
markupView
node
type
)
{
this
.
markup
=
markupView
;
this
.
node
=
node
;
this
.
undo
=
this
.
markup
.
undo
;
this
.
win
=
this
.
markup
.
_frame
.
contentWindow
;
this
.
id
=
"
treeitem
-
"
+
markupContainerID
+
+
;
this
.
htmlElt
=
this
.
win
.
document
.
documentElement
;
this
.
buildMarkup
(
type
)
;
this
.
elt
.
container
=
this
;
this
.
_onMouseDown
=
this
.
_onMouseDown
.
bind
(
this
)
;
this
.
_onToggle
=
this
.
_onToggle
.
bind
(
this
)
;
this
.
_onMouseUp
=
this
.
_onMouseUp
.
bind
(
this
)
;
this
.
_onMouseMove
=
this
.
_onMouseMove
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
elt
.
addEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
win
.
addEventListener
(
"
mouseup
"
this
.
_onMouseUp
true
)
;
this
.
win
.
addEventListener
(
"
mousemove
"
this
.
_onMouseMove
true
)
;
this
.
elt
.
addEventListener
(
"
dblclick
"
this
.
_onToggle
)
;
if
(
this
.
expander
)
{
this
.
expander
.
addEventListener
(
"
click
"
this
.
_onToggle
)
;
}
this
.
updateIsDisplayed
(
)
;
}
buildMarkup
:
function
(
type
)
{
this
.
elt
=
this
.
win
.
document
.
createElement
(
"
li
"
)
;
this
.
elt
.
classList
.
add
(
"
child
"
"
collapsed
"
)
;
this
.
elt
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
=
this
.
win
.
document
.
createElement
(
"
div
"
)
;
this
.
tagLine
.
setAttribute
(
"
id
"
this
.
id
)
;
this
.
tagLine
.
classList
.
add
(
"
tag
-
line
"
)
;
this
.
tagLine
.
setAttribute
(
"
role
"
"
treeitem
"
)
;
this
.
tagLine
.
setAttribute
(
"
aria
-
level
"
this
.
level
)
;
this
.
tagLine
.
setAttribute
(
"
aria
-
grabbed
"
this
.
isDragging
)
;
this
.
elt
.
appendChild
(
this
.
tagLine
)
;
this
.
tagState
=
this
.
win
.
document
.
createElement
(
"
span
"
)
;
this
.
tagState
.
classList
.
add
(
"
tag
-
state
"
)
;
this
.
tagState
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
.
appendChild
(
this
.
tagState
)
;
if
(
type
!
=
=
"
textcontainer
"
)
{
this
.
expander
=
this
.
win
.
document
.
createElement
(
"
span
"
)
;
this
.
expander
.
classList
.
add
(
"
theme
-
twisty
"
"
expander
"
)
;
this
.
expander
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
tagLine
.
appendChild
(
this
.
expander
)
;
}
this
.
children
=
this
.
win
.
document
.
createElement
(
"
ul
"
)
;
this
.
children
.
classList
.
add
(
"
children
"
)
;
this
.
children
.
setAttribute
(
"
role
"
"
group
"
)
;
this
.
elt
.
appendChild
(
this
.
children
)
;
}
toString
:
function
(
)
{
return
"
[
MarkupContainer
for
"
+
this
.
node
+
"
]
"
;
}
isPreviewable
:
function
(
)
{
if
(
this
.
node
.
tagName
&
&
!
this
.
node
.
isPseudoElement
)
{
let
tagName
=
this
.
node
.
tagName
.
toLowerCase
(
)
;
let
srcAttr
=
this
.
editor
.
getAttributeElement
(
"
src
"
)
;
let
isImage
=
tagName
=
=
=
"
img
"
&
&
srcAttr
;
let
isCanvas
=
tagName
=
=
=
"
canvas
"
;
return
isImage
|
|
isCanvas
;
}
return
false
;
}
updateIsDisplayed
:
function
(
)
{
this
.
elt
.
classList
.
remove
(
"
not
-
displayed
"
)
;
if
(
!
this
.
node
.
isDisplayed
|
|
this
.
node
.
hidden
)
{
this
.
elt
.
classList
.
add
(
"
not
-
displayed
"
)
;
}
}
_hasChildren
:
false
get
hasChildren
(
)
{
return
this
.
_hasChildren
;
}
set
hasChildren
(
value
)
{
this
.
_hasChildren
=
value
;
this
.
updateExpander
(
)
;
}
get
focusableElms
(
)
{
return
[
.
.
.
this
.
tagLine
.
querySelectorAll
(
"
[
tabindex
]
"
)
]
;
}
get
canFocus
(
)
{
return
this
.
_canFocus
;
}
set
canFocus
(
value
)
{
if
(
this
.
_canFocus
=
=
=
value
)
{
return
;
}
this
.
_canFocus
=
value
;
if
(
value
)
{
this
.
tagLine
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
focusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
0
"
)
)
;
}
else
{
this
.
tagLine
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
this
.
focusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
}
}
clearFocus
:
function
(
)
{
if
(
!
this
.
canFocus
)
{
return
;
}
this
.
canFocus
=
false
;
let
doc
=
this
.
markup
.
doc
;
if
(
!
doc
.
activeElement
|
|
doc
.
activeElement
=
=
=
doc
.
body
)
{
return
;
}
let
parent
=
doc
.
activeElement
;
while
(
parent
&
&
parent
!
=
=
this
.
elt
)
{
parent
=
parent
.
parentNode
;
}
if
(
parent
)
{
doc
.
activeElement
.
blur
(
)
;
}
}
get
canExpand
(
)
{
return
this
.
_hasChildren
&
&
!
this
.
node
.
inlineTextChild
;
}
get
mustExpand
(
)
{
return
this
.
node
.
_parent
=
=
=
this
.
markup
.
walker
.
rootNode
;
}
get
showExpander
(
)
{
return
this
.
canExpand
&
&
!
this
.
mustExpand
;
}
updateExpander
:
function
(
)
{
if
(
!
this
.
expander
)
{
return
;
}
if
(
this
.
showExpander
)
{
this
.
elt
.
classList
.
add
(
"
expandable
"
)
;
this
.
expander
.
style
.
visibility
=
"
visible
"
;
this
.
tagLine
.
setAttribute
(
"
aria
-
expanded
"
this
.
expanded
)
;
}
else
{
this
.
elt
.
classList
.
remove
(
"
expandable
"
)
;
this
.
expander
.
style
.
visibility
=
"
hidden
"
;
this
.
tagLine
.
removeAttribute
(
"
aria
-
expanded
"
)
;
}
}
setChildrenRole
:
function
(
)
{
this
.
children
.
setAttribute
(
"
role
"
this
.
hasChildren
?
"
group
"
:
"
presentation
"
)
;
}
updateLevel
:
function
(
)
{
let
currentLevel
=
this
.
tagLine
.
getAttribute
(
"
aria
-
level
"
)
;
let
newLevel
=
this
.
level
;
if
(
currentLevel
=
=
=
newLevel
)
{
return
;
}
this
.
tagLine
.
setAttribute
(
"
aria
-
level
"
newLevel
)
;
let
childContainers
=
this
.
getChildContainers
(
)
;
if
(
childContainers
)
{
childContainers
.
forEach
(
container
=
>
container
.
updateLevel
(
)
)
;
}
}
getChildContainers
:
function
(
)
{
if
(
!
this
.
hasChildren
)
{
return
null
;
}
return
[
.
.
.
this
.
children
.
children
]
.
filter
(
node
=
>
node
.
container
)
.
map
(
node
=
>
node
.
container
)
;
}
get
expanded
(
)
{
return
!
this
.
elt
.
classList
.
contains
(
"
collapsed
"
)
;
}
setExpanded
:
function
(
value
)
{
if
(
!
this
.
expander
)
{
return
;
}
if
(
!
this
.
canExpand
)
{
value
=
false
;
}
if
(
this
.
mustExpand
)
{
value
=
true
;
}
if
(
value
&
&
this
.
elt
.
classList
.
contains
(
"
collapsed
"
)
)
{
let
closingTag
=
this
.
elt
.
querySelector
(
"
.
close
"
)
;
if
(
closingTag
)
{
if
(
!
this
.
closeTagLine
)
{
let
line
=
this
.
markup
.
doc
.
createElement
(
"
div
"
)
;
line
.
classList
.
add
(
"
tag
-
line
"
)
;
line
.
setAttribute
(
"
role
"
"
presentation
"
)
;
let
tagState
=
this
.
markup
.
doc
.
createElement
(
"
div
"
)
;
tagState
.
classList
.
add
(
"
tag
-
state
"
)
;
line
.
appendChild
(
tagState
)
;
line
.
appendChild
(
closingTag
.
cloneNode
(
true
)
)
;
flashElementOff
(
line
)
;
this
.
closeTagLine
=
line
;
}
this
.
elt
.
appendChild
(
this
.
closeTagLine
)
;
}
this
.
elt
.
classList
.
remove
(
"
collapsed
"
)
;
this
.
expander
.
setAttribute
(
"
open
"
"
"
)
;
this
.
hovered
=
false
;
this
.
markup
.
emit
(
"
expanded
"
)
;
}
else
if
(
!
value
)
{
if
(
this
.
closeTagLine
)
{
this
.
elt
.
removeChild
(
this
.
closeTagLine
)
;
this
.
closeTagLine
=
undefined
;
}
this
.
elt
.
classList
.
add
(
"
collapsed
"
)
;
this
.
expander
.
removeAttribute
(
"
open
"
)
;
this
.
markup
.
emit
(
"
collapsed
"
)
;
}
if
(
this
.
showExpander
)
{
this
.
tagLine
.
setAttribute
(
"
aria
-
expanded
"
this
.
expanded
)
;
}
}
parentContainer
:
function
(
)
{
return
this
.
elt
.
parentNode
?
this
.
elt
.
parentNode
.
container
:
null
;
}
get
level
(
)
{
let
level
=
1
;
let
parent
=
this
.
node
.
parentNode
(
)
;
while
(
parent
&
&
parent
!
=
=
this
.
markup
.
walker
.
rootNode
)
{
level
+
+
;
parent
=
parent
.
parentNode
(
)
;
}
return
level
;
}
_isDragging
:
false
_dragStartY
:
0
set
isDragging
(
isDragging
)
{
let
rootElt
=
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
.
elt
;
this
.
_isDragging
=
isDragging
;
this
.
markup
.
isDragging
=
isDragging
;
this
.
tagLine
.
setAttribute
(
"
aria
-
grabbed
"
isDragging
)
;
if
(
isDragging
)
{
this
.
htmlElt
.
classList
.
add
(
"
dragging
"
)
;
this
.
elt
.
classList
.
add
(
"
dragging
"
)
;
this
.
markup
.
doc
.
body
.
classList
.
add
(
"
dragging
"
)
;
rootElt
.
setAttribute
(
"
aria
-
dropeffect
"
"
move
"
)
;
}
else
{
this
.
htmlElt
.
classList
.
remove
(
"
dragging
"
)
;
this
.
elt
.
classList
.
remove
(
"
dragging
"
)
;
this
.
markup
.
doc
.
body
.
classList
.
remove
(
"
dragging
"
)
;
rootElt
.
setAttribute
(
"
aria
-
dropeffect
"
"
none
"
)
;
}
}
get
isDragging
(
)
{
return
this
.
_isDragging
;
}
isDraggable
:
function
(
)
{
let
tagName
=
this
.
node
.
tagName
&
&
this
.
node
.
tagName
.
toLowerCase
(
)
;
return
!
this
.
node
.
isPseudoElement
&
&
!
this
.
node
.
isAnonymous
&
&
!
this
.
node
.
isDocumentElement
&
&
tagName
!
=
=
"
body
"
&
&
tagName
!
=
=
"
head
"
&
&
this
.
win
.
getSelection
(
)
.
isCollapsed
&
&
this
.
node
.
parentNode
(
)
.
tagName
!
=
=
null
;
}
_wrapMoveFocus
:
function
(
current
back
)
{
let
elms
=
this
.
focusableElms
;
let
next
;
if
(
back
)
{
if
(
elms
.
indexOf
(
current
)
=
=
=
0
)
{
next
=
elms
[
elms
.
length
-
1
]
;
next
.
focus
(
)
;
}
}
else
if
(
elms
.
indexOf
(
current
)
=
=
=
elms
.
length
-
1
)
{
next
=
elms
[
0
]
;
next
.
focus
(
)
;
}
return
next
;
}
_onKeyDown
:
function
(
event
)
{
let
{
target
keyCode
shiftKey
}
=
event
;
let
isInput
=
this
.
markup
.
_isInputOrTextarea
(
target
)
;
if
(
isInput
&
&
keyCode
!
=
=
KeyCodes
.
DOM_VK_TAB
)
{
return
;
}
switch
(
keyCode
)
{
case
KeyCodes
.
DOM_VK_TAB
:
if
(
isInput
)
{
let
next
=
this
.
_wrapMoveFocus
(
target
.
nextSibling
shiftKey
)
;
if
(
next
)
{
event
.
preventDefault
(
)
;
if
(
next
.
_editable
)
{
let
e
=
this
.
markup
.
doc
.
createEvent
(
"
Event
"
)
;
e
.
initEvent
(
next
.
_trigger
true
true
)
;
next
.
dispatchEvent
(
e
)
;
}
}
}
else
{
let
next
=
this
.
_wrapMoveFocus
(
target
shiftKey
)
;
if
(
next
)
{
event
.
preventDefault
(
)
;
}
}
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
this
.
clearFocus
(
)
;
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
.
elt
.
focus
(
)
;
if
(
this
.
isDragging
)
{
return
;
}
event
.
preventDefault
(
)
;
break
;
default
:
return
;
}
event
.
stopPropagation
(
)
;
}
_onMouseDown
:
function
(
event
)
{
let
{
target
button
metaKey
ctrlKey
}
=
event
;
let
isLeftClick
=
button
=
=
=
0
;
let
isMiddleClick
=
button
=
=
=
1
;
let
isMetaClick
=
isLeftClick
&
&
(
metaKey
|
|
ctrlKey
)
;
if
(
target
.
nodeName
=
=
=
"
button
"
)
{
return
;
}
this
.
hovered
=
false
;
this
.
markup
.
navigate
(
this
)
;
this
.
canFocus
=
true
;
this
.
focus
(
)
;
event
.
stopPropagation
(
)
;
if
(
!
target
.
closest
(
"
.
editor
[
tabindex
]
"
)
)
{
event
.
preventDefault
(
)
;
}
if
(
isMiddleClick
|
|
isMetaClick
)
{
let
link
=
target
.
dataset
.
link
;
let
type
=
target
.
dataset
.
type
;
this
.
canFocus
=
false
;
this
.
markup
.
inspector
.
followAttributeLink
(
type
link
)
;
return
;
}
if
(
isLeftClick
&
&
this
.
isDraggable
(
)
)
{
this
.
_isPreDragging
=
true
;
this
.
_dragStartY
=
event
.
pageY
;
}
}
_onMouseUp
:
Task
.
async
(
function
*
(
)
{
this
.
_isPreDragging
=
false
;
if
(
this
.
isDragging
)
{
this
.
cancelDragging
(
)
;
let
dropTargetNodes
=
this
.
markup
.
dropTargetNodes
;
if
(
!
dropTargetNodes
)
{
return
;
}
yield
this
.
markup
.
walker
.
insertBefore
(
this
.
node
dropTargetNodes
.
parent
dropTargetNodes
.
nextSibling
)
;
this
.
markup
.
emit
(
"
drop
-
completed
"
)
;
}
}
)
_onMouseMove
:
function
(
event
)
{
let
initialDiff
=
Math
.
abs
(
event
.
pageY
-
this
.
_dragStartY
)
;
if
(
this
.
_isPreDragging
&
&
initialDiff
>
=
DRAG_DROP_MIN_INITIAL_DISTANCE
)
{
this
.
_isPreDragging
=
false
;
this
.
isDragging
=
true
;
let
position
=
this
.
elt
.
nextElementSibling
|
|
this
.
markup
.
getContainer
(
this
.
node
.
parentNode
(
)
)
.
closeTagLine
;
this
.
markup
.
indicateDragTarget
(
position
)
;
}
if
(
this
.
isDragging
)
{
let
x
=
0
;
let
y
=
event
.
pageY
-
this
.
win
.
scrollY
;
if
(
y
<
0
)
{
y
=
0
;
}
else
if
(
y
>
=
this
.
markup
.
doc
.
body
.
offsetHeight
-
this
.
win
.
scrollY
)
{
y
=
this
.
markup
.
doc
.
body
.
offsetHeight
-
this
.
win
.
scrollY
-
1
;
}
let
diff
=
y
-
this
.
_dragStartY
+
this
.
win
.
scrollY
;
this
.
elt
.
style
.
top
=
diff
+
"
px
"
;
let
el
=
this
.
markup
.
doc
.
elementFromPoint
(
x
y
)
;
this
.
markup
.
indicateDropTarget
(
el
)
;
}
}
cancelDragging
:
function
(
)
{
if
(
!
this
.
isDragging
)
{
return
;
}
this
.
_isPreDragging
=
false
;
this
.
isDragging
=
false
;
this
.
elt
.
style
.
removeProperty
(
"
top
"
)
;
}
flashMutation
:
function
(
)
{
if
(
!
this
.
selected
)
{
flashElementOn
(
this
.
tagState
this
.
editor
.
elt
)
;
if
(
this
.
_flashMutationTimer
)
{
clearTimeout
(
this
.
_flashMutationTimer
)
;
this
.
_flashMutationTimer
=
null
;
}
this
.
_flashMutationTimer
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
this
.
tagState
this
.
editor
.
elt
)
;
}
this
.
markup
.
CONTAINER_FLASHING_DURATION
)
;
}
}
_hovered
:
false
set
hovered
(
value
)
{
this
.
tagState
.
classList
.
remove
(
"
flash
-
out
"
)
;
this
.
_hovered
=
value
;
if
(
value
)
{
if
(
!
this
.
selected
)
{
this
.
tagState
.
classList
.
add
(
"
theme
-
bg
-
darker
"
)
;
}
if
(
this
.
closeTagLine
)
{
this
.
closeTagLine
.
querySelector
(
"
.
tag
-
state
"
)
.
classList
.
add
(
"
theme
-
bg
-
darker
"
)
;
}
}
else
{
this
.
tagState
.
classList
.
remove
(
"
theme
-
bg
-
darker
"
)
;
if
(
this
.
closeTagLine
)
{
this
.
closeTagLine
.
querySelector
(
"
.
tag
-
state
"
)
.
classList
.
remove
(
"
theme
-
bg
-
darker
"
)
;
}
}
}
get
visible
(
)
{
return
this
.
elt
.
getBoundingClientRect
(
)
.
height
>
0
;
}
_selected
:
false
get
selected
(
)
{
return
this
.
_selected
;
}
set
selected
(
value
)
{
this
.
tagState
.
classList
.
remove
(
"
flash
-
out
"
)
;
this
.
_selected
=
value
;
this
.
editor
.
selected
=
value
;
this
.
tagLine
.
setAttribute
(
"
aria
-
selected
"
value
)
;
if
(
this
.
_selected
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
markup
.
_rootNode
)
;
if
(
container
)
{
container
.
elt
.
setAttribute
(
"
aria
-
activedescendant
"
this
.
id
)
;
}
this
.
tagLine
.
setAttribute
(
"
selected
"
"
"
)
;
this
.
tagState
.
classList
.
add
(
"
theme
-
selected
"
)
;
}
else
{
this
.
tagLine
.
removeAttribute
(
"
selected
"
)
;
this
.
tagState
.
classList
.
remove
(
"
theme
-
selected
"
)
;
}
}
update
:
function
(
)
{
if
(
this
.
node
.
pseudoClassLocks
.
length
)
{
this
.
elt
.
classList
.
add
(
"
pseudoclass
-
locked
"
)
;
}
else
{
this
.
elt
.
classList
.
remove
(
"
pseudoclass
-
locked
"
)
;
}
if
(
this
.
editor
.
update
)
{
this
.
editor
.
update
(
)
;
}
}
focus
:
function
(
)
{
let
focusable
=
this
.
editor
.
elt
.
querySelector
(
"
[
tabindex
=
'
0
'
]
"
)
;
if
(
focusable
)
{
focusable
.
focus
(
)
;
}
}
_onToggle
:
function
(
event
)
{
if
(
event
.
target
.
dataset
.
event
)
{
event
.
stopPropagation
(
)
;
return
;
}
this
.
markup
.
navigate
(
this
)
;
if
(
this
.
hasChildren
)
{
this
.
markup
.
setNodeExpanded
(
this
.
node
!
this
.
expanded
event
.
altKey
)
;
}
event
.
stopPropagation
(
)
;
}
destroy
:
function
(
)
{
this
.
elt
.
removeEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
elt
.
removeEventListener
(
"
dblclick
"
this
.
_onToggle
)
;
this
.
tagLine
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
true
)
;
if
(
this
.
win
)
{
this
.
win
.
removeEventListener
(
"
mouseup
"
this
.
_onMouseUp
true
)
;
this
.
win
.
removeEventListener
(
"
mousemove
"
this
.
_onMouseMove
true
)
;
}
this
.
win
=
null
;
this
.
htmlElt
=
null
;
if
(
this
.
expander
)
{
this
.
expander
.
removeEventListener
(
"
click
"
this
.
_onToggle
)
;
}
let
firstChild
=
this
.
children
.
firstChild
;
while
(
firstChild
)
{
if
(
firstChild
.
container
)
{
firstChild
.
container
.
destroy
(
)
;
}
this
.
children
.
removeChild
(
firstChild
)
;
firstChild
=
this
.
children
.
firstChild
;
}
this
.
editor
.
destroy
(
)
;
}
}
;
module
.
exports
=
MarkupContainer
;
