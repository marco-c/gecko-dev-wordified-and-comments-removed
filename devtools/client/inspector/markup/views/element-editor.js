"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
TextEditor
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
text
-
editor
"
)
;
const
{
truncateString
}
=
require
(
"
devtools
/
shared
/
inspector
/
utils
"
)
;
const
{
editableField
InplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
parseAttribute
}
=
require
(
"
devtools
/
client
/
shared
/
node
-
attribute
-
parser
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
flashElementOn
"
"
flashElementOff
"
"
getAutocompleteMaxWidth
"
"
parseAttributeValues
"
]
"
devtools
/
client
/
inspector
/
markup
/
utils
"
true
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
COLLAPSE_DATA_URL_REGEX
=
/
^
data
.
+
base64
/
;
const
COLLAPSE_DATA_URL_LENGTH
=
60
;
const
HTML_VOID_ELEMENTS
=
[
"
area
"
"
base
"
"
br
"
"
col
"
"
command
"
"
embed
"
"
hr
"
"
img
"
"
input
"
"
keygen
"
"
link
"
"
meta
"
"
param
"
"
source
"
"
track
"
"
wbr
"
]
;
const
DISPLAY_TYPES
=
{
flex
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
flex
.
tooltiptext2
"
)
"
inline
-
flex
"
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
inlineFlex
.
tooltiptext2
"
)
grid
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
grid
.
tooltiptext2
"
)
"
inline
-
grid
"
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
inlineGrid
.
tooltiptext2
"
)
subgrid
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
subgrid
.
tooltiptiptext
"
)
"
flow
-
root
"
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
flowRoot
.
tooltiptext
"
)
contents
:
INSPECTOR_L10N
.
getStr
(
"
markupView
.
display
.
contents
.
tooltiptext2
"
)
}
;
function
ElementEditor
(
container
node
)
{
this
.
container
=
container
;
this
.
node
=
node
;
this
.
markup
=
this
.
container
.
markup
;
this
.
doc
=
this
.
markup
.
doc
;
this
.
inspector
=
this
.
markup
.
inspector
;
this
.
highlighters
=
this
.
markup
.
highlighters
;
this
.
_cssProperties
=
this
.
inspector
.
cssProperties
;
this
.
isOverflowDebuggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
overflow
.
debugging
.
enabled
"
)
;
this
.
highlightingOverflowCausingElements
=
this
.
node
.
isScrollable
?
false
:
null
;
this
.
attrElements
=
new
Map
(
)
;
this
.
animationTimers
=
{
}
;
this
.
elt
=
null
;
this
.
tag
=
null
;
this
.
closeTag
=
null
;
this
.
attrList
=
null
;
this
.
newAttr
=
null
;
this
.
closeElt
=
null
;
this
.
onCustomBadgeClick
=
this
.
onCustomBadgeClick
.
bind
(
this
)
;
this
.
onDisplayBadgeClick
=
this
.
onDisplayBadgeClick
.
bind
(
this
)
;
this
.
onScrollableBadgeClick
=
this
.
onScrollableBadgeClick
.
bind
(
this
)
;
this
.
onExpandBadgeClick
=
this
.
onExpandBadgeClick
.
bind
(
this
)
;
this
.
onTagEdit
=
this
.
onTagEdit
.
bind
(
this
)
;
this
.
buildMarkup
(
)
;
const
isVoidElement
=
HTML_VOID_ELEMENTS
.
includes
(
this
.
node
.
displayName
)
;
if
(
node
.
isInHTMLDocument
&
&
isVoidElement
)
{
this
.
elt
.
classList
.
add
(
"
void
-
element
"
)
;
}
this
.
update
(
)
;
this
.
initialized
=
true
;
}
ElementEditor
.
prototype
=
{
buildMarkup
:
function
(
)
{
this
.
elt
=
this
.
doc
.
createElement
(
"
span
"
)
;
this
.
elt
.
classList
.
add
(
"
editor
"
)
;
this
.
renderOpenTag
(
)
;
this
.
renderEventBadge
(
)
;
this
.
renderCloseTag
(
)
;
if
(
!
this
.
node
.
isDocumentElement
)
{
this
.
tag
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
editableField
(
{
element
:
this
.
tag
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
this
.
tag
this
.
container
.
elt
)
trigger
:
"
dblclick
"
stopOnReturn
:
true
done
:
this
.
onTagEdit
cssProperties
:
this
.
_cssProperties
}
)
;
}
}
renderOpenTag
:
function
(
)
{
const
open
=
this
.
doc
.
createElement
(
"
span
"
)
;
open
.
classList
.
add
(
"
open
"
)
;
open
.
appendChild
(
this
.
doc
.
createTextNode
(
"
<
"
)
)
;
this
.
elt
.
appendChild
(
open
)
;
this
.
tag
=
this
.
doc
.
createElement
(
"
span
"
)
;
this
.
tag
.
classList
.
add
(
"
tag
"
"
theme
-
fg
-
color3
"
)
;
this
.
tag
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
this
.
tag
.
textContent
=
this
.
node
.
displayName
;
open
.
appendChild
(
this
.
tag
)
;
this
.
renderAttributes
(
open
)
;
this
.
renderNewAttributeEditor
(
open
)
;
const
closingBracket
=
this
.
doc
.
createElement
(
"
span
"
)
;
closingBracket
.
classList
.
add
(
"
closing
-
bracket
"
)
;
closingBracket
.
textContent
=
"
>
"
;
open
.
appendChild
(
closingBracket
)
;
}
renderAttributes
:
function
(
containerEl
)
{
this
.
attrList
=
this
.
doc
.
createElement
(
"
span
"
)
;
containerEl
.
appendChild
(
this
.
attrList
)
;
}
renderNewAttributeEditor
:
function
(
containerEl
)
{
this
.
newAttr
=
this
.
doc
.
createElement
(
"
span
"
)
;
this
.
newAttr
.
classList
.
add
(
"
newattr
"
)
;
this
.
newAttr
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
this
.
newAttr
.
setAttribute
(
"
aria
-
label
"
INSPECTOR_L10N
.
getStr
(
"
markupView
.
newAttribute
.
label
"
)
)
;
containerEl
.
appendChild
(
this
.
newAttr
)
;
this
.
newAttr
.
editMode
=
editableField
(
{
element
:
this
.
newAttr
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
this
.
newAttr
this
.
container
.
elt
)
trigger
:
"
dblclick
"
stopOnReturn
:
true
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_MIXED
popup
:
this
.
markup
.
popup
done
:
(
val
commit
)
=
>
{
if
(
!
commit
)
{
return
;
}
const
doMods
=
this
.
_startModifyingAttributes
(
)
;
const
undoMods
=
this
.
_startModifyingAttributes
(
)
;
this
.
_applyAttributes
(
val
null
doMods
undoMods
)
;
this
.
container
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
function
(
)
{
undoMods
.
apply
(
)
;
}
)
;
}
cssProperties
:
this
.
_cssProperties
}
)
;
}
renderEventBadge
:
function
(
)
{
this
.
expandBadge
=
this
.
doc
.
createElement
(
"
span
"
)
;
this
.
expandBadge
.
classList
.
add
(
"
markup
-
expand
-
badge
"
)
;
this
.
expandBadge
.
addEventListener
(
"
click
"
this
.
onExpandBadgeClick
)
;
this
.
elt
.
appendChild
(
this
.
expandBadge
)
;
}
renderCloseTag
:
function
(
)
{
const
close
=
this
.
doc
.
createElement
(
"
span
"
)
;
close
.
classList
.
add
(
"
close
"
)
;
close
.
appendChild
(
this
.
doc
.
createTextNode
(
"
<
/
"
)
)
;
this
.
elt
.
appendChild
(
close
)
;
this
.
closeTag
=
this
.
doc
.
createElement
(
"
span
"
)
;
this
.
closeTag
.
classList
.
add
(
"
tag
"
"
theme
-
fg
-
color3
"
)
;
this
.
closeTag
.
textContent
=
this
.
node
.
displayName
;
close
.
appendChild
(
this
.
closeTag
)
;
close
.
appendChild
(
this
.
doc
.
createTextNode
(
"
>
"
)
)
;
}
get
displayBadge
(
)
{
return
this
.
_displayBadge
;
}
set
selected
(
value
)
{
if
(
this
.
textEditor
)
{
this
.
textEditor
.
selected
=
value
;
}
}
flashAttribute
:
function
(
attrName
)
{
if
(
this
.
animationTimers
[
attrName
]
)
{
clearTimeout
(
this
.
animationTimers
[
attrName
]
)
;
}
flashElementOn
(
this
.
getAttributeElement
(
attrName
)
{
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
this
.
animationTimers
[
attrName
]
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
this
.
getAttributeElement
(
attrName
)
{
backgroundClass
:
"
theme
-
bg
-
contrast
"
}
)
;
}
this
.
markup
.
CONTAINER_FLASHING_DURATION
)
;
}
getInfoAtNode
:
function
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
type
=
null
;
let
name
=
null
;
let
value
=
null
;
const
attribute
=
node
.
closest
(
"
.
attreditor
"
)
;
if
(
attribute
)
{
type
=
"
attribute
"
;
name
=
attribute
.
dataset
.
attr
;
value
=
attribute
.
dataset
.
value
;
}
return
{
type
name
value
el
:
node
}
;
}
update
:
function
(
)
{
const
nodeAttributes
=
this
.
node
.
attributes
|
|
[
]
;
const
currentAttributes
=
new
Set
(
nodeAttributes
.
map
(
a
=
>
a
.
name
)
)
;
for
(
const
name
of
this
.
attrElements
.
keys
(
)
)
{
if
(
!
currentAttributes
.
has
(
name
)
)
{
this
.
removeAttribute
(
name
)
;
}
}
for
(
const
attr
of
nodeAttributes
)
{
const
el
=
this
.
attrElements
.
get
(
attr
.
name
)
;
const
valueChanged
=
el
&
&
el
.
dataset
.
value
!
=
=
attr
.
value
;
const
isEditing
=
el
&
&
el
.
querySelector
(
"
.
editable
"
)
.
inplaceEditor
;
const
canSimplyShowEditor
=
el
&
&
(
!
valueChanged
|
|
isEditing
)
;
if
(
canSimplyShowEditor
)
{
el
.
style
.
removeProperty
(
"
display
"
)
;
}
else
{
const
attribute
=
this
.
_createAttribute
(
attr
el
)
;
attribute
.
style
.
removeProperty
(
"
display
"
)
;
if
(
this
.
initialized
)
{
this
.
flashAttribute
(
attr
.
name
)
;
}
}
}
this
.
updateEventBadge
(
)
;
this
.
updateDisplayBadge
(
)
;
this
.
updateCustomBadge
(
)
;
this
.
updateScrollableBadge
(
)
;
this
.
updateTextEditor
(
)
;
this
.
updateUnavailableChildren
(
)
;
this
.
updateOverflowBadge
(
)
;
this
.
updateOverflowHighlight
(
)
;
}
updateEventBadge
:
function
(
)
{
const
showEventBadge
=
this
.
node
.
hasEventListeners
;
if
(
this
.
_eventBadge
&
&
!
showEventBadge
)
{
this
.
_eventBadge
.
remove
(
)
;
this
.
_eventBadge
=
null
;
}
else
if
(
showEventBadge
&
&
!
this
.
_eventBadge
)
{
this
.
_createEventBadge
(
)
;
}
}
_createEventBadge
:
function
(
)
{
this
.
_eventBadge
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
_eventBadge
.
className
=
"
inspector
-
badge
interactive
"
;
this
.
_eventBadge
.
dataset
.
event
=
"
true
"
;
this
.
_eventBadge
.
textContent
=
"
event
"
;
this
.
_eventBadge
.
title
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
event
.
tooltiptext
"
)
;
this
.
elt
.
insertBefore
(
this
.
_eventBadge
this
.
_displayBadge
|
|
this
.
_customBadge
)
;
this
.
markup
.
emit
(
"
badge
-
added
-
event
"
)
;
}
updateScrollableBadge
:
function
(
)
{
if
(
this
.
node
.
isScrollable
&
&
!
this
.
_scrollableBadge
)
{
this
.
_createScrollableBadge
(
)
;
}
else
if
(
this
.
_scrollableBadge
&
&
!
this
.
node
.
isScrollable
)
{
this
.
_scrollableBadge
.
remove
(
)
;
this
.
_scrollableBadge
=
null
;
}
}
_createScrollableBadge
:
function
(
)
{
const
isInteractive
=
this
.
isOverflowDebuggingEnabled
&
&
!
this
.
node
.
isDocumentElement
;
this
.
_scrollableBadge
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
_scrollableBadge
.
className
=
inspector
-
badge
scrollable
-
badge
{
isInteractive
?
"
interactive
"
:
"
"
}
;
this
.
_scrollableBadge
.
dataset
.
scrollable
=
"
true
"
;
this
.
_scrollableBadge
.
textContent
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
scrollableBadge
.
label
"
)
;
this
.
_scrollableBadge
.
title
=
INSPECTOR_L10N
.
getStr
(
isInteractive
?
"
markupView
.
scrollableBadge
.
interactive
.
tooltip
"
:
"
markupView
.
scrollableBadge
.
tooltip
"
)
;
if
(
isInteractive
)
{
this
.
_scrollableBadge
.
addEventListener
(
"
click
"
this
.
onScrollableBadgeClick
)
;
}
this
.
elt
.
insertBefore
(
this
.
_scrollableBadge
this
.
_customBadge
)
;
}
updateDisplayBadge
:
function
(
)
{
const
displayType
=
this
.
node
.
displayType
;
const
showDisplayBadge
=
displayType
in
DISPLAY_TYPES
;
if
(
this
.
_displayBadge
&
&
!
showDisplayBadge
)
{
this
.
_displayBadge
.
remove
(
)
;
this
.
_displayBadge
=
null
;
}
else
if
(
showDisplayBadge
)
{
if
(
!
this
.
_displayBadge
)
{
this
.
_createDisplayBadge
(
)
;
}
this
.
_updateDisplayBadgeContent
(
)
;
}
}
_createDisplayBadge
:
function
(
)
{
this
.
_displayBadge
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
_displayBadge
.
className
=
"
inspector
-
badge
"
;
this
.
_displayBadge
.
addEventListener
(
"
click
"
this
.
onDisplayBadgeClick
)
;
this
.
elt
.
insertBefore
(
this
.
_displayBadge
this
.
_customBadge
)
;
}
_updateDisplayBadgeContent
:
function
(
)
{
const
displayType
=
this
.
node
.
displayType
;
this
.
_displayBadge
.
textContent
=
displayType
;
this
.
_displayBadge
.
dataset
.
display
=
displayType
;
this
.
_displayBadge
.
title
=
DISPLAY_TYPES
[
displayType
]
;
const
isFlex
=
displayType
=
=
=
"
flex
"
|
|
displayType
=
=
=
"
inline
-
flex
"
;
const
isGrid
=
displayType
=
=
=
"
grid
"
|
|
displayType
=
=
=
"
inline
-
grid
"
|
|
displayType
=
=
=
"
subgrid
"
;
const
isInteractive
=
isFlex
|
|
(
isGrid
&
&
this
.
highlighters
.
canGridHighlighterToggle
(
this
.
node
)
)
;
this
.
_displayBadge
.
classList
.
toggle
(
"
interactive
"
isInteractive
)
;
}
updateOverflowBadge
:
function
(
)
{
if
(
!
this
.
isOverflowDebuggingEnabled
)
{
return
;
}
if
(
this
.
node
.
causesOverflow
&
&
!
this
.
_overflowBadge
)
{
this
.
_createOverflowBadge
(
)
;
}
else
if
(
!
this
.
node
.
causesOverflow
&
&
this
.
_overflowBadge
)
{
this
.
_overflowBadge
.
remove
(
)
;
this
.
_overflowBadge
=
null
;
}
}
_createOverflowBadge
:
function
(
)
{
this
.
_overflowBadge
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
_overflowBadge
.
className
=
"
inspector
-
badge
overflow
-
badge
"
;
this
.
_overflowBadge
.
textContent
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
overflowBadge
.
label
"
)
;
this
.
_overflowBadge
.
title
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
overflowBadge
.
tooltip
"
)
;
this
.
elt
.
insertBefore
(
this
.
_overflowBadge
this
.
_customBadge
)
;
}
updateCustomBadge
:
function
(
)
{
const
showCustomBadge
=
!
!
this
.
node
.
customElementLocation
;
if
(
this
.
_customBadge
&
&
!
showCustomBadge
)
{
this
.
_customBadge
.
remove
(
)
;
this
.
_customBadge
=
null
;
}
else
if
(
!
this
.
_customBadge
&
&
showCustomBadge
)
{
this
.
_createCustomBadge
(
)
;
}
}
_createCustomBadge
:
function
(
)
{
this
.
_customBadge
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
_customBadge
.
className
=
"
inspector
-
badge
interactive
"
;
this
.
_customBadge
.
dataset
.
custom
=
"
true
"
;
this
.
_customBadge
.
textContent
=
"
custom
"
;
this
.
_customBadge
.
title
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
custom
.
tooltiptext
"
)
;
this
.
_customBadge
.
addEventListener
(
"
click
"
this
.
onCustomBadgeClick
)
;
this
.
elt
.
appendChild
(
this
.
_customBadge
)
;
}
updateOverflowHighlight
:
async
function
(
)
{
if
(
!
this
.
isOverflowDebuggingEnabled
)
{
return
;
}
let
showOverflowHighlight
=
false
;
if
(
this
.
node
.
causesOverflow
)
{
try
{
const
scrollableAncestor
=
await
this
.
node
.
walkerFront
.
getScrollableAncestorNode
(
this
.
node
)
;
const
markupContainer
=
scrollableAncestor
?
this
.
markup
.
getContainer
(
scrollableAncestor
)
:
null
;
showOverflowHighlight
=
!
!
markupContainer
?
.
editor
.
highlightingOverflowCausingElements
;
}
catch
(
e
)
{
return
;
}
}
this
.
setOverflowHighlight
(
showOverflowHighlight
)
;
}
setOverflowHighlight
:
function
(
showOverflowHighlight
)
{
this
.
container
.
tagState
.
classList
.
toggle
(
"
overflow
-
causing
-
highlighted
"
showOverflowHighlight
)
;
}
updateTextEditor
:
function
(
)
{
const
node
=
this
.
node
.
inlineTextChild
;
if
(
this
.
textEditor
&
&
this
.
textEditor
.
node
!
=
node
)
{
this
.
elt
.
removeChild
(
this
.
textEditor
.
elt
)
;
this
.
textEditor
.
destroy
(
)
;
this
.
textEditor
=
null
;
}
if
(
node
&
&
!
this
.
textEditor
)
{
this
.
textEditor
=
new
TextEditor
(
this
.
container
node
"
text
"
)
;
this
.
elt
.
insertBefore
(
this
.
textEditor
.
elt
this
.
elt
.
querySelector
(
"
.
close
"
)
)
;
}
if
(
this
.
textEditor
)
{
this
.
textEditor
.
update
(
)
;
}
}
hasUnavailableChildren
(
)
{
return
!
!
this
.
childrenUnavailableElt
;
}
updateUnavailableChildren
:
function
(
)
{
const
childrenUnavailable
=
this
.
node
.
childrenUnavailable
;
if
(
this
.
childrenUnavailableElt
)
{
this
.
elt
.
removeChild
(
this
.
childrenUnavailableElt
)
;
this
.
childrenUnavailableElt
=
null
;
}
if
(
childrenUnavailable
)
{
this
.
childrenUnavailableElt
=
this
.
doc
.
createElement
(
"
div
"
)
;
this
.
childrenUnavailableElt
.
className
=
"
unavailable
-
children
"
;
this
.
childrenUnavailableElt
.
dataset
.
label
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
unavailableChildren
.
label
"
)
;
this
.
childrenUnavailableElt
.
title
=
INSPECTOR_L10N
.
getStr
(
"
markupView
.
unavailableChildren
.
title
"
)
;
this
.
elt
.
insertBefore
(
this
.
childrenUnavailableElt
this
.
elt
.
querySelector
(
"
.
close
"
)
)
;
}
}
_startModifyingAttributes
:
function
(
)
{
return
this
.
node
.
startModifyingAttributes
(
)
;
}
getAttributeElement
:
function
(
attrName
)
{
return
this
.
attrList
.
querySelector
(
"
.
attreditor
[
data
-
attr
=
"
+
CSS
.
escape
(
attrName
)
+
"
]
.
attr
-
value
"
)
;
}
removeAttribute
:
function
(
attrName
)
{
const
attr
=
this
.
attrElements
.
get
(
attrName
)
;
if
(
attr
)
{
this
.
attrElements
.
delete
(
attrName
)
;
attr
.
remove
(
)
;
}
}
_createAttribute
:
function
(
attribute
before
=
null
)
{
const
attr
=
this
.
doc
.
createElement
(
"
span
"
)
;
attr
.
dataset
.
attr
=
attribute
.
name
;
attr
.
dataset
.
value
=
attribute
.
value
;
attr
.
classList
.
add
(
"
attreditor
"
)
;
attr
.
style
.
display
=
"
none
"
;
attr
.
appendChild
(
this
.
doc
.
createTextNode
(
"
"
)
)
;
const
inner
=
this
.
doc
.
createElement
(
"
span
"
)
;
inner
.
classList
.
add
(
"
editable
"
)
;
inner
.
setAttribute
(
"
tabindex
"
this
.
container
.
canFocus
?
"
0
"
:
"
-
1
"
)
;
attr
.
appendChild
(
inner
)
;
const
name
=
this
.
doc
.
createElement
(
"
span
"
)
;
name
.
classList
.
add
(
"
attr
-
name
"
)
;
name
.
classList
.
add
(
"
theme
-
fg
-
color1
"
)
;
name
.
textContent
=
attribute
.
name
;
inner
.
appendChild
(
name
)
;
inner
.
appendChild
(
this
.
doc
.
createTextNode
(
'
=
"
'
)
)
;
const
val
=
this
.
doc
.
createElement
(
"
span
"
)
;
val
.
classList
.
add
(
"
attr
-
value
"
)
;
val
.
classList
.
add
(
"
theme
-
fg
-
color2
"
)
;
inner
.
appendChild
(
val
)
;
inner
.
appendChild
(
this
.
doc
.
createTextNode
(
'
"
'
)
)
;
this
.
_setupAttributeEditor
(
attribute
attr
inner
name
val
)
;
if
(
attribute
.
name
=
=
"
id
"
)
{
before
=
this
.
attrList
.
firstChild
;
}
else
if
(
attribute
.
name
=
=
"
class
"
)
{
const
idNode
=
this
.
attrElements
.
get
(
"
id
"
)
;
before
=
idNode
?
idNode
.
nextSibling
:
this
.
attrList
.
firstChild
;
}
this
.
attrList
.
insertBefore
(
attr
before
)
;
this
.
removeAttribute
(
attribute
.
name
)
;
this
.
attrElements
.
set
(
attribute
.
name
attr
)
;
this
.
_appendAttributeValue
(
attribute
val
)
;
return
attr
;
}
_setupAttributeEditor
:
function
(
attribute
attrEditorEl
editableEl
attrNameEl
attrValueEl
)
{
let
editValueDisplayed
=
attribute
.
value
|
|
"
"
;
const
hasDoubleQuote
=
editValueDisplayed
.
includes
(
'
"
'
)
;
const
hasSingleQuote
=
editValueDisplayed
.
includes
(
"
'
"
)
;
let
initial
=
attribute
.
name
+
'
=
"
'
+
editValueDisplayed
+
'
"
'
;
if
(
hasDoubleQuote
&
&
hasSingleQuote
)
{
editValueDisplayed
=
editValueDisplayed
.
replace
(
/
\
"
/
g
"
&
quot
;
"
)
;
initial
=
attribute
.
name
+
'
=
"
'
+
editValueDisplayed
+
'
"
'
;
}
if
(
hasDoubleQuote
&
&
!
hasSingleQuote
)
{
initial
=
attribute
.
name
+
"
=
'
"
+
editValueDisplayed
+
"
'
"
;
}
attrEditorEl
.
editMode
=
editableField
(
{
element
:
editableEl
trigger
:
"
dblclick
"
stopOnReturn
:
true
selectAll
:
false
initial
:
initial
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
editableEl
this
.
container
.
elt
)
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_MIXED
popup
:
this
.
markup
.
popup
start
:
(
editor
event
)
=
>
{
if
(
event
?
.
target
=
=
=
attrNameEl
)
{
editor
.
input
.
setSelectionRange
(
0
attrNameEl
.
textContent
.
length
)
;
}
else
if
(
event
?
.
target
.
closest
(
"
.
attr
-
value
"
)
=
=
=
attrValueEl
)
{
const
length
=
editValueDisplayed
.
length
;
const
editorLength
=
editor
.
input
.
value
.
length
;
const
start
=
editorLength
-
(
length
+
1
)
;
editor
.
input
.
setSelectionRange
(
start
start
+
length
)
;
}
else
{
editor
.
input
.
select
(
)
;
}
}
done
:
(
newValue
commit
direction
)
=
>
{
if
(
!
commit
|
|
newValue
=
=
=
initial
)
{
return
;
}
const
doMods
=
this
.
_startModifyingAttributes
(
)
;
const
undoMods
=
this
.
_startModifyingAttributes
(
)
;
this
.
refocusOnEdit
(
attribute
.
name
attrEditorEl
direction
)
;
this
.
_saveAttribute
(
attribute
.
name
undoMods
)
;
doMods
.
removeAttribute
(
attribute
.
name
)
;
this
.
_applyAttributes
(
newValue
attrEditorEl
doMods
undoMods
)
;
this
.
container
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
(
)
=
>
{
undoMods
.
apply
(
)
;
}
)
;
}
cssProperties
:
this
.
_cssProperties
}
)
;
}
_appendAttributeValue
:
function
(
attribute
attributeValueEl
)
{
const
attributes
=
this
.
node
.
attributes
.
filter
(
existingAttribute
=
>
existingAttribute
.
name
!
=
=
attribute
.
name
)
;
attributes
.
push
(
attribute
)
;
const
parsedLinksData
=
parseAttribute
(
this
.
node
.
namespaceURI
this
.
node
.
tagName
attributes
attribute
.
name
attribute
.
value
)
;
attributeValueEl
.
innerHTML
=
"
"
;
for
(
const
token
of
parsedLinksData
)
{
if
(
token
.
type
=
=
=
"
string
"
)
{
attributeValueEl
.
appendChild
(
this
.
doc
.
createTextNode
(
this
.
_truncateAttributeValue
(
token
.
value
)
)
)
;
}
else
{
const
link
=
this
.
doc
.
createElement
(
"
span
"
)
;
link
.
classList
.
add
(
"
link
"
)
;
link
.
setAttribute
(
"
data
-
type
"
token
.
type
)
;
link
.
setAttribute
(
"
data
-
link
"
token
.
value
)
;
link
.
textContent
=
this
.
_truncateAttributeValue
(
token
.
value
)
;
attributeValueEl
.
appendChild
(
link
)
;
}
}
}
_truncateAttributeValue
:
function
(
value
)
{
if
(
value
&
&
value
.
match
(
COLLAPSE_DATA_URL_REGEX
)
)
{
return
truncateString
(
value
COLLAPSE_DATA_URL_LENGTH
)
;
}
return
this
.
markup
.
collapseAttributes
?
truncateString
(
value
this
.
markup
.
collapseAttributeLength
)
:
value
;
}
_applyAttributes
:
function
(
value
attrNode
doMods
undoMods
)
{
const
attrs
=
parseAttributeValues
(
value
this
.
doc
)
;
for
(
const
attr
of
attrs
)
{
this
.
_createAttribute
(
attr
attrNode
?
attrNode
.
nextSibling
:
null
)
;
this
.
_saveAttribute
(
attr
.
name
undoMods
)
;
doMods
.
setAttribute
(
attr
.
name
attr
.
value
)
;
}
}
_saveAttribute
:
function
(
name
undoMods
)
{
const
node
=
this
.
node
;
if
(
node
.
hasAttribute
(
name
)
)
{
const
oldValue
=
node
.
getAttribute
(
name
)
;
undoMods
.
setAttribute
(
name
oldValue
)
;
}
else
{
undoMods
.
removeAttribute
(
name
)
;
}
}
refocusOnEdit
:
function
(
attrName
attrNode
direction
)
{
if
(
this
.
_editedAttributeObserver
)
{
this
.
markup
.
inspector
.
off
(
"
markupmutation
"
this
.
_editedAttributeObserver
)
;
this
.
_editedAttributeObserver
=
null
;
}
const
activeElement
=
this
.
markup
.
doc
.
activeElement
;
if
(
!
activeElement
|
|
!
activeElement
.
inplaceEditor
)
{
return
;
}
const
container
=
this
.
markup
.
getContainer
(
this
.
node
)
;
const
activeAttrs
=
[
.
.
.
this
.
attrList
.
childNodes
]
.
filter
(
el
=
>
el
.
style
.
display
!
=
"
none
"
)
;
const
attributeIndex
=
activeAttrs
.
indexOf
(
attrNode
)
;
const
onMutations
=
(
this
.
_editedAttributeObserver
=
mutations
=
>
{
let
isDeletedAttribute
=
false
;
let
isNewAttribute
=
false
;
for
(
const
mutation
of
mutations
)
{
const
inContainer
=
this
.
markup
.
getContainer
(
mutation
.
target
)
=
=
=
container
;
if
(
!
inContainer
)
{
continue
;
}
const
isOriginalAttribute
=
mutation
.
attributeName
=
=
=
attrName
;
isDeletedAttribute
=
isDeletedAttribute
|
|
(
isOriginalAttribute
&
&
mutation
.
newValue
=
=
=
null
)
;
isNewAttribute
=
isNewAttribute
|
|
mutation
.
attributeName
!
=
=
attrName
;
}
const
isModifiedOrder
=
isDeletedAttribute
&
&
isNewAttribute
;
this
.
_editedAttributeObserver
=
null
;
const
visibleAttrs
=
[
.
.
.
this
.
attrList
.
childNodes
]
.
filter
(
el
=
>
el
.
style
.
display
!
=
"
none
"
)
;
let
activeEditor
;
if
(
visibleAttrs
.
length
>
0
)
{
if
(
!
direction
)
{
activeEditor
=
visibleAttrs
[
attributeIndex
]
;
}
else
if
(
isModifiedOrder
)
{
activeEditor
=
visibleAttrs
[
0
]
;
}
else
{
let
newAttributeIndex
;
if
(
isDeletedAttribute
)
{
newAttributeIndex
=
attributeIndex
;
}
else
if
(
direction
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
newAttributeIndex
=
attributeIndex
+
1
;
}
else
if
(
direction
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
newAttributeIndex
=
attributeIndex
-
1
;
}
if
(
newAttributeIndex
>
=
0
&
&
newAttributeIndex
<
=
visibleAttrs
.
length
-
1
)
{
activeEditor
=
visibleAttrs
[
newAttributeIndex
]
;
}
}
}
if
(
!
activeEditor
)
{
activeEditor
=
this
.
newAttr
;
}
if
(
direction
)
{
activeEditor
.
editMode
(
)
;
}
else
{
const
editable
=
activeEditor
=
=
=
this
.
newAttr
?
activeEditor
:
activeEditor
.
querySelector
(
"
.
editable
"
)
;
editable
.
focus
(
)
;
}
this
.
markup
.
emit
(
"
refocusedonedit
"
)
;
}
)
;
this
.
markup
.
inspector
.
once
(
"
markupmutation
"
onMutations
)
;
}
onDisplayBadgeClick
:
async
function
(
event
)
{
event
.
stopPropagation
(
)
;
const
target
=
event
.
target
;
if
(
target
.
dataset
.
display
=
=
=
"
flex
"
|
|
target
.
dataset
.
display
=
=
=
"
inline
-
flex
"
)
{
await
this
.
highlighters
.
toggleFlexboxHighlighter
(
this
.
node
"
markup
"
)
;
}
if
(
target
.
dataset
.
display
=
=
=
"
grid
"
|
|
target
.
dataset
.
display
=
=
=
"
inline
-
grid
"
|
|
target
.
dataset
.
display
=
=
=
"
subgrid
"
)
{
if
(
!
this
.
highlighters
.
canGridHighlighterToggle
(
this
.
node
)
)
{
return
;
}
await
this
.
highlighters
.
toggleGridHighlighter
(
this
.
node
"
markup
"
)
;
}
}
onCustomBadgeClick
:
async
function
(
)
{
const
{
url
line
column
}
=
this
.
node
.
customElementLocation
;
this
.
markup
.
toolbox
.
viewSourceInDebugger
(
url
line
column
null
"
show_custom_element
"
)
;
}
onExpandBadgeClick
:
function
(
)
{
this
.
container
.
expandContainer
(
)
;
}
onScrollableBadgeClick
:
async
function
(
)
{
this
.
highlightingOverflowCausingElements
=
this
.
_scrollableBadge
.
classList
.
toggle
(
"
active
"
)
;
const
{
nodes
}
=
await
this
.
node
.
walkerFront
.
getOverflowCausingElements
(
this
.
node
)
;
for
(
const
node
of
nodes
)
{
if
(
this
.
highlightingOverflowCausingElements
)
{
await
this
.
markup
.
showNode
(
node
)
;
}
const
markupContainer
=
this
.
markup
.
getContainer
(
node
)
;
if
(
markupContainer
)
{
markupContainer
.
editor
.
setOverflowHighlight
(
this
.
highlightingOverflowCausingElements
)
;
}
}
this
.
markup
.
telemetry
.
scalarAdd
(
"
devtools
.
markup
.
scrollable
.
badge
.
clicked
"
1
)
;
}
onTagEdit
:
function
(
newTagName
isCommit
)
{
if
(
!
isCommit
|
|
newTagName
.
toLowerCase
(
)
=
=
=
this
.
node
.
tagName
.
toLowerCase
(
)
|
|
!
(
"
editTagName
"
in
this
.
markup
.
walker
)
)
{
return
;
}
this
.
markup
.
reselectOnRemoved
(
this
.
node
"
edittagname
"
)
;
this
.
node
.
walkerFront
.
editTagName
(
this
.
node
newTagName
)
.
catch
(
(
)
=
>
{
this
.
markup
.
cancelReselectOnRemoved
(
)
;
}
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_displayBadge
)
{
this
.
_displayBadge
.
removeEventListener
(
"
click
"
this
.
onDisplayBadgeClick
)
;
}
if
(
this
.
_customBadge
)
{
this
.
_customBadge
.
removeEventListener
(
"
click
"
this
.
onCustomBadgeClick
)
;
}
if
(
this
.
_scrollableBadge
)
{
this
.
_scrollableBadge
.
removeEventListener
(
"
click
"
this
.
onScrollableBadgeClick
)
;
}
this
.
expandBadge
.
removeEventListener
(
"
click
"
this
.
onExpandBadgeClick
)
;
for
(
const
key
in
this
.
animationTimers
)
{
clearTimeout
(
this
.
animationTimers
[
key
]
)
;
}
this
.
animationTimers
=
null
;
}
}
;
module
.
exports
=
ElementEditor
;
