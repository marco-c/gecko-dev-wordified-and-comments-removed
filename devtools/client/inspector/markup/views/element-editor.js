"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
TextEditor
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
views
/
text
-
editor
"
)
;
const
{
getAutocompleteMaxWidth
flashElementOn
flashElementOff
parseAttributeValues
truncateString
}
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
utils
"
)
;
const
{
editableField
InplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
parseAttribute
}
=
require
(
"
devtools
/
client
/
shared
/
node
-
attribute
-
parser
"
)
;
const
{
getCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
COLLAPSE_DATA_URL_REGEX
=
/
^
data
.
+
base64
/
;
const
COLLAPSE_DATA_URL_LENGTH
=
60
;
const
HTML_VOID_ELEMENTS
=
[
"
area
"
"
base
"
"
br
"
"
col
"
"
command
"
"
embed
"
"
hr
"
"
img
"
"
input
"
"
keygen
"
"
link
"
"
meta
"
"
param
"
"
source
"
"
track
"
"
wbr
"
]
;
function
ElementEditor
(
container
node
)
{
this
.
container
=
container
;
this
.
node
=
node
;
this
.
markup
=
this
.
container
.
markup
;
this
.
template
=
this
.
markup
.
template
.
bind
(
this
.
markup
)
;
this
.
doc
=
this
.
markup
.
doc
;
this
.
_cssProperties
=
getCssProperties
(
this
.
markup
.
toolbox
)
;
this
.
attrElements
=
new
Map
(
)
;
this
.
animationTimers
=
{
}
;
this
.
elt
=
null
;
this
.
tag
=
null
;
this
.
closeTag
=
null
;
this
.
attrList
=
null
;
this
.
newAttr
=
null
;
this
.
closeElt
=
null
;
this
.
template
(
"
element
"
this
)
;
if
(
!
node
.
isDocumentElement
)
{
this
.
tag
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
editableField
(
{
element
:
this
.
tag
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
this
.
tag
this
.
container
.
elt
)
trigger
:
"
dblclick
"
stopOnReturn
:
true
done
:
this
.
onTagEdit
.
bind
(
this
)
contextMenu
:
this
.
markup
.
inspector
.
onTextBoxContextMenu
cssProperties
:
this
.
_cssProperties
}
)
;
}
this
.
newAttr
.
editMode
=
editableField
(
{
element
:
this
.
newAttr
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
this
.
newAttr
this
.
container
.
elt
)
trigger
:
"
dblclick
"
stopOnReturn
:
true
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_MIXED
popup
:
this
.
markup
.
popup
done
:
(
val
commit
)
=
>
{
if
(
!
commit
)
{
return
;
}
let
doMods
=
this
.
_startModifyingAttributes
(
)
;
let
undoMods
=
this
.
_startModifyingAttributes
(
)
;
this
.
_applyAttributes
(
val
null
doMods
undoMods
)
;
this
.
container
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
function
(
)
{
undoMods
.
apply
(
)
;
}
)
;
}
contextMenu
:
this
.
markup
.
inspector
.
onTextBoxContextMenu
cssProperties
:
this
.
_cssProperties
}
)
;
let
displayName
=
this
.
node
.
displayName
;
this
.
tag
.
textContent
=
displayName
;
this
.
closeTag
.
textContent
=
displayName
;
let
isVoidElement
=
HTML_VOID_ELEMENTS
.
includes
(
displayName
)
;
if
(
node
.
isInHTMLDocument
&
&
isVoidElement
)
{
this
.
elt
.
classList
.
add
(
"
void
-
element
"
)
;
}
this
.
update
(
)
;
this
.
initialized
=
true
;
}
ElementEditor
.
prototype
=
{
set
selected
(
value
)
{
if
(
this
.
textEditor
)
{
this
.
textEditor
.
selected
=
value
;
}
}
flashAttribute
(
attrName
)
{
if
(
this
.
animationTimers
[
attrName
]
)
{
clearTimeout
(
this
.
animationTimers
[
attrName
]
)
;
}
flashElementOn
(
this
.
getAttributeElement
(
attrName
)
)
;
this
.
animationTimers
[
attrName
]
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
this
.
getAttributeElement
(
attrName
)
)
;
}
this
.
markup
.
CONTAINER_FLASHING_DURATION
)
;
}
getInfoAtNode
(
node
)
{
if
(
!
node
)
{
return
null
;
}
let
type
=
null
;
let
name
=
null
;
let
value
=
null
;
let
attribute
=
node
.
closest
(
"
.
attreditor
"
)
;
if
(
attribute
)
{
type
=
"
attribute
"
;
name
=
attribute
.
querySelector
(
"
.
attr
-
name
"
)
.
textContent
;
value
=
attribute
.
querySelector
(
"
.
attr
-
value
"
)
.
textContent
;
}
return
{
type
name
value
el
:
node
}
;
}
update
(
)
{
let
nodeAttributes
=
this
.
node
.
attributes
|
|
[
]
;
let
currentAttributes
=
new
Set
(
nodeAttributes
.
map
(
a
=
>
a
.
name
)
)
;
for
(
let
name
of
this
.
attrElements
.
keys
(
)
)
{
if
(
!
currentAttributes
.
has
(
name
)
)
{
this
.
removeAttribute
(
name
)
;
}
}
for
(
let
attr
of
nodeAttributes
)
{
let
el
=
this
.
attrElements
.
get
(
attr
.
name
)
;
let
valueChanged
=
el
&
&
el
.
dataset
.
value
!
=
=
attr
.
value
;
let
isEditing
=
el
&
&
el
.
querySelector
(
"
.
editable
"
)
.
inplaceEditor
;
let
canSimplyShowEditor
=
el
&
&
(
!
valueChanged
|
|
isEditing
)
;
if
(
canSimplyShowEditor
)
{
el
.
style
.
removeProperty
(
"
display
"
)
;
}
else
{
let
attribute
=
this
.
_createAttribute
(
attr
el
)
;
attribute
.
style
.
removeProperty
(
"
display
"
)
;
if
(
this
.
initialized
)
{
this
.
flashAttribute
(
attr
.
name
)
;
}
}
}
this
.
eventNode
.
style
.
display
=
this
.
node
.
hasEventListeners
?
"
inline
-
block
"
:
"
none
"
;
this
.
updateTextEditor
(
)
;
}
updateTextEditor
(
)
{
let
node
=
this
.
node
.
inlineTextChild
;
if
(
this
.
textEditor
&
&
this
.
textEditor
.
node
!
=
node
)
{
this
.
elt
.
removeChild
(
this
.
textEditor
.
elt
)
;
this
.
textEditor
=
null
;
}
if
(
node
&
&
!
this
.
textEditor
)
{
this
.
textEditor
=
new
TextEditor
(
this
.
container
node
"
text
"
)
;
this
.
elt
.
insertBefore
(
this
.
textEditor
.
elt
this
.
elt
.
firstChild
.
nextSibling
.
nextSibling
)
;
}
if
(
this
.
textEditor
)
{
this
.
textEditor
.
update
(
)
;
}
}
_startModifyingAttributes
(
)
{
return
this
.
node
.
startModifyingAttributes
(
)
;
}
getAttributeElement
(
attrName
)
{
return
this
.
attrList
.
querySelector
(
"
.
attreditor
[
data
-
attr
=
"
+
CSS
.
escape
(
attrName
)
+
"
]
.
attr
-
value
"
)
;
}
removeAttribute
(
attrName
)
{
let
attr
=
this
.
attrElements
.
get
(
attrName
)
;
if
(
attr
)
{
this
.
attrElements
.
delete
(
attrName
)
;
attr
.
remove
(
)
;
}
}
_createAttribute
(
attribute
before
=
null
)
{
let
data
=
{
attrName
:
attribute
.
name
attrValue
:
attribute
.
value
tabindex
:
this
.
container
.
canFocus
?
"
0
"
:
"
-
1
"
}
;
this
.
template
(
"
attribute
"
data
)
;
let
{
attr
inner
name
val
}
=
data
;
let
editValueDisplayed
=
attribute
.
value
|
|
"
"
;
let
hasDoubleQuote
=
editValueDisplayed
.
includes
(
'
"
'
)
;
let
hasSingleQuote
=
editValueDisplayed
.
includes
(
"
'
"
)
;
let
initial
=
attribute
.
name
+
'
=
"
'
+
editValueDisplayed
+
'
"
'
;
if
(
hasDoubleQuote
&
&
hasSingleQuote
)
{
editValueDisplayed
=
editValueDisplayed
.
replace
(
/
\
"
/
g
"
&
quot
;
"
)
;
initial
=
attribute
.
name
+
'
=
"
'
+
editValueDisplayed
+
'
"
'
;
}
if
(
hasDoubleQuote
&
&
!
hasSingleQuote
)
{
initial
=
attribute
.
name
+
"
=
'
"
+
editValueDisplayed
+
"
'
"
;
}
attr
.
editMode
=
editableField
(
{
element
:
inner
trigger
:
"
dblclick
"
stopOnReturn
:
true
selectAll
:
false
initial
multiline
:
true
maxWidth
:
(
)
=
>
getAutocompleteMaxWidth
(
inner
this
.
container
.
elt
)
contentType
:
InplaceEditor
.
CONTENT_TYPES
.
CSS_MIXED
popup
:
this
.
markup
.
popup
start
:
(
editor
event
)
=
>
{
if
(
event
&
&
event
.
target
=
=
=
name
)
{
editor
.
input
.
setSelectionRange
(
0
name
.
textContent
.
length
)
;
}
else
if
(
event
&
&
event
.
target
.
closest
(
"
.
attr
-
value
"
)
=
=
=
val
)
{
let
length
=
editValueDisplayed
.
length
;
let
editorLength
=
editor
.
input
.
value
.
length
;
let
start
=
editorLength
-
(
length
+
1
)
;
editor
.
input
.
setSelectionRange
(
start
start
+
length
)
;
}
else
{
editor
.
input
.
select
(
)
;
}
}
done
:
(
newValue
commit
direction
)
=
>
{
if
(
!
commit
|
|
newValue
=
=
=
initial
)
{
return
;
}
let
doMods
=
this
.
_startModifyingAttributes
(
)
;
let
undoMods
=
this
.
_startModifyingAttributes
(
)
;
this
.
refocusOnEdit
(
attribute
.
name
attr
direction
)
;
this
.
_saveAttribute
(
attribute
.
name
undoMods
)
;
doMods
.
removeAttribute
(
attribute
.
name
)
;
this
.
_applyAttributes
(
newValue
attr
doMods
undoMods
)
;
this
.
container
.
undo
.
do
(
(
)
=
>
{
doMods
.
apply
(
)
;
}
(
)
=
>
{
undoMods
.
apply
(
)
;
}
)
;
}
contextMenu
:
this
.
markup
.
inspector
.
onTextBoxContextMenu
cssProperties
:
this
.
_cssProperties
}
)
;
if
(
attribute
.
name
=
=
"
id
"
)
{
before
=
this
.
attrList
.
firstChild
;
}
else
if
(
attribute
.
name
=
=
"
class
"
)
{
let
idNode
=
this
.
attrElements
.
get
(
"
id
"
)
;
before
=
idNode
?
idNode
.
nextSibling
:
this
.
attrList
.
firstChild
;
}
this
.
attrList
.
insertBefore
(
attr
before
)
;
this
.
removeAttribute
(
attribute
.
name
)
;
this
.
attrElements
.
set
(
attribute
.
name
attr
)
;
let
attributes
=
this
.
node
.
attributes
.
filter
(
existingAttribute
=
>
{
return
existingAttribute
.
name
!
=
=
attribute
.
name
;
}
)
;
attributes
.
push
(
attribute
)
;
let
parsedLinksData
=
parseAttribute
(
this
.
node
.
namespaceURI
this
.
node
.
tagName
attributes
attribute
.
name
)
;
let
collapse
=
value
=
>
{
if
(
value
&
&
value
.
match
(
COLLAPSE_DATA_URL_REGEX
)
)
{
return
truncateString
(
value
COLLAPSE_DATA_URL_LENGTH
)
;
}
return
this
.
markup
.
collapseAttributes
?
truncateString
(
value
this
.
markup
.
collapseAttributeLength
)
:
value
;
}
;
val
.
innerHTML
=
"
"
;
for
(
let
token
of
parsedLinksData
)
{
if
(
token
.
type
=
=
=
"
string
"
)
{
val
.
appendChild
(
this
.
doc
.
createTextNode
(
collapse
(
token
.
value
)
)
)
;
}
else
{
let
link
=
this
.
doc
.
createElement
(
"
span
"
)
;
link
.
classList
.
add
(
"
link
"
)
;
link
.
setAttribute
(
"
data
-
type
"
token
.
type
)
;
link
.
setAttribute
(
"
data
-
link
"
token
.
value
)
;
link
.
textContent
=
collapse
(
token
.
value
)
;
val
.
appendChild
(
link
)
;
}
}
name
.
textContent
=
attribute
.
name
;
return
attr
;
}
_applyAttributes
(
value
attrNode
doMods
undoMods
)
{
let
attrs
=
parseAttributeValues
(
value
this
.
doc
)
;
for
(
let
attr
of
attrs
)
{
this
.
_createAttribute
(
attr
attrNode
?
attrNode
.
nextSibling
:
null
)
;
this
.
_saveAttribute
(
attr
.
name
undoMods
)
;
doMods
.
setAttribute
(
attr
.
name
attr
.
value
)
;
}
}
_saveAttribute
(
name
undoMods
)
{
let
node
=
this
.
node
;
if
(
node
.
hasAttribute
(
name
)
)
{
let
oldValue
=
node
.
getAttribute
(
name
)
;
undoMods
.
setAttribute
(
name
oldValue
)
;
}
else
{
undoMods
.
removeAttribute
(
name
)
;
}
}
refocusOnEdit
(
attrName
attrNode
direction
)
{
if
(
this
.
_editedAttributeObserver
)
{
this
.
markup
.
inspector
.
off
(
"
markupmutation
"
this
.
_editedAttributeObserver
)
;
this
.
_editedAttributeObserver
=
null
;
}
let
container
=
this
.
markup
.
getContainer
(
this
.
node
)
;
let
activeAttrs
=
[
.
.
.
this
.
attrList
.
childNodes
]
.
filter
(
el
=
>
el
.
style
.
display
!
=
"
none
"
)
;
let
attributeIndex
=
activeAttrs
.
indexOf
(
attrNode
)
;
let
onMutations
=
this
.
_editedAttributeObserver
=
(
e
mutations
)
=
>
{
let
isDeletedAttribute
=
false
;
let
isNewAttribute
=
false
;
for
(
let
mutation
of
mutations
)
{
let
inContainer
=
this
.
markup
.
getContainer
(
mutation
.
target
)
=
=
=
container
;
if
(
!
inContainer
)
{
continue
;
}
let
isOriginalAttribute
=
mutation
.
attributeName
=
=
=
attrName
;
isDeletedAttribute
=
isDeletedAttribute
|
|
isOriginalAttribute
&
&
mutation
.
newValue
=
=
=
null
;
isNewAttribute
=
isNewAttribute
|
|
mutation
.
attributeName
!
=
=
attrName
;
}
let
isModifiedOrder
=
isDeletedAttribute
&
&
isNewAttribute
;
this
.
_editedAttributeObserver
=
null
;
let
visibleAttrs
=
[
.
.
.
this
.
attrList
.
childNodes
]
.
filter
(
el
=
>
el
.
style
.
display
!
=
"
none
"
)
;
let
activeEditor
;
if
(
visibleAttrs
.
length
>
0
)
{
if
(
!
direction
)
{
activeEditor
=
visibleAttrs
[
attributeIndex
]
;
}
else
if
(
isModifiedOrder
)
{
activeEditor
=
visibleAttrs
[
0
]
;
}
else
{
let
newAttributeIndex
;
if
(
isDeletedAttribute
)
{
newAttributeIndex
=
attributeIndex
;
}
else
if
(
direction
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
newAttributeIndex
=
attributeIndex
+
1
;
}
else
if
(
direction
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
newAttributeIndex
=
attributeIndex
-
1
;
}
if
(
newAttributeIndex
>
=
0
&
&
newAttributeIndex
<
=
visibleAttrs
.
length
-
1
)
{
activeEditor
=
visibleAttrs
[
newAttributeIndex
]
;
}
}
}
if
(
!
activeEditor
)
{
activeEditor
=
this
.
newAttr
;
}
if
(
direction
)
{
activeEditor
.
editMode
(
)
;
}
else
{
let
editable
=
activeEditor
=
=
=
this
.
newAttr
?
activeEditor
:
activeEditor
.
querySelector
(
"
.
editable
"
)
;
editable
.
focus
(
)
;
}
this
.
markup
.
emit
(
"
refocusedonedit
"
)
;
}
;
this
.
markup
.
inspector
.
once
(
"
markupmutation
"
onMutations
)
;
}
onTagEdit
(
newTagName
isCommit
)
{
if
(
!
isCommit
|
|
newTagName
.
toLowerCase
(
)
=
=
=
this
.
node
.
tagName
.
toLowerCase
(
)
|
|
!
(
"
editTagName
"
in
this
.
markup
.
walker
)
)
{
return
;
}
this
.
markup
.
reselectOnRemoved
(
this
.
node
"
edittagname
"
)
;
this
.
markup
.
walker
.
editTagName
(
this
.
node
newTagName
)
.
then
(
null
(
)
=
>
{
this
.
markup
.
cancelReselectOnRemoved
(
)
;
}
)
;
}
destroy
(
)
{
for
(
let
key
in
this
.
animationTimers
)
{
clearTimeout
(
this
.
animationTimers
[
key
]
)
;
}
this
.
animationTimers
=
null
;
}
}
;
module
.
exports
=
ElementEditor
;
