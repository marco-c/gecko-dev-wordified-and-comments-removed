"
use
strict
"
;
function
flashElementOn
(
backgroundElt
{
foregroundElt
=
backgroundElt
backgroundClass
=
"
theme
-
bg
-
contrast
"
}
=
{
}
)
{
if
(
!
backgroundElt
|
|
!
foregroundElt
)
{
return
;
}
backgroundElt
.
classList
.
remove
(
"
flash
-
out
"
)
;
backgroundElt
.
classList
.
add
(
backgroundClass
)
;
foregroundElt
.
classList
.
add
(
"
theme
-
fg
-
contrast
"
)
;
[
]
.
forEach
.
call
(
foregroundElt
.
querySelectorAll
(
"
[
class
*
=
theme
-
fg
-
color
]
"
)
span
=
>
span
.
classList
.
add
(
"
theme
-
fg
-
contrast
"
)
)
;
}
function
flashElementOff
(
backgroundElt
{
foregroundElt
=
backgroundElt
backgroundClass
=
"
theme
-
bg
-
contrast
"
}
=
{
}
)
{
if
(
!
backgroundElt
|
|
!
foregroundElt
)
{
return
;
}
backgroundElt
.
classList
.
add
(
"
flash
-
out
"
)
;
backgroundElt
.
classList
.
remove
(
backgroundClass
)
;
foregroundElt
.
classList
.
remove
(
"
theme
-
fg
-
contrast
"
)
;
[
]
.
forEach
.
call
(
foregroundElt
.
querySelectorAll
(
"
[
class
*
=
theme
-
fg
-
color
]
"
)
span
=
>
span
.
classList
.
remove
(
"
theme
-
fg
-
contrast
"
)
)
;
}
function
getAutocompleteMaxWidth
(
element
container
)
{
const
elementRect
=
element
.
getBoundingClientRect
(
)
;
const
containerRect
=
container
.
getBoundingClientRect
(
)
;
return
containerRect
.
right
-
elementRect
.
left
-
2
;
}
function
parseAttributeValues
(
attr
doc
)
{
attr
=
attr
.
trim
(
)
;
const
parseAndGetNode
=
str
=
>
{
return
new
DOMParser
(
)
.
parseFromString
(
str
"
text
/
html
"
)
.
body
.
childNodes
[
0
]
;
}
;
const
el
=
parseAndGetNode
(
"
<
svg
"
+
attr
+
"
>
<
/
svg
>
"
)
|
|
parseAndGetNode
(
"
<
svg
"
+
attr
+
'
"
>
<
/
svg
>
'
)
|
|
parseAndGetNode
(
"
<
svg
"
+
attr
+
"
'
>
<
/
svg
>
"
)
;
const
div
=
doc
.
createElement
(
"
div
"
)
;
const
attributes
=
[
]
;
for
(
const
{
name
value
}
of
el
.
attributes
)
{
try
{
div
.
setAttribute
(
name
value
)
;
attributes
.
push
(
{
name
value
}
)
;
}
catch
(
e
)
{
}
}
return
attributes
;
}
module
.
exports
=
{
flashElementOn
flashElementOff
getAutocompleteMaxWidth
parseAttributeValues
}
;
