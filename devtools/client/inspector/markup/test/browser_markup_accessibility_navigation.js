"
use
strict
"
;
const
TESTS
=
[
{
desc
:
"
Collapse
body
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
body
.
tagLine
"
key
:
"
VK_LEFT
"
options
:
{
}
waitFor
:
"
collapsed
"
}
{
desc
:
"
Expand
body
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
body
.
tagLine
"
key
:
"
VK_RIGHT
"
options
:
{
}
waitFor
:
"
expanded
"
}
{
desc
:
"
Select
header
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_DOWN
"
options
:
{
}
waitFor
:
"
inspector
-
updated
"
}
{
desc
:
"
Expand
header
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_RIGHT
"
options
:
{
}
waitFor
:
"
expanded
"
}
{
desc
:
"
Select
text
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
container
-
0
.
tagLine
"
key
:
"
VK_DOWN
"
options
:
{
}
waitFor
:
"
inspector
-
updated
"
}
{
desc
:
"
Select
header
container
again
"
focused
:
"
root
.
elt
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_UP
"
options
:
{
}
waitFor
:
"
inspector
-
updated
"
}
{
desc
:
"
Collapse
header
container
"
focused
:
"
root
.
elt
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_LEFT
"
options
:
{
}
waitFor
:
"
collapsed
"
}
{
desc
:
"
Focus
on
header
container
tag
"
focused
:
"
header
.
focusableElms
.
0
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_RETURN
"
options
:
{
}
}
{
desc
:
"
Remove
focus
from
header
container
tag
"
focused
:
"
root
.
elt
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_ESCAPE
"
options
:
{
}
}
{
desc
:
"
Focus
on
header
container
tag
again
"
focused
:
"
header
.
focusableElms
.
0
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_SPACE
"
options
:
{
}
}
{
desc
:
"
Focus
on
header
id
attribute
"
focused
:
"
header
.
focusableElms
.
1
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Focus
on
header
class
attribute
"
focused
:
"
header
.
focusableElms
.
2
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Focus
on
header
new
attribute
"
focused
:
"
header
.
focusableElms
.
3
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Circle
back
and
focus
on
header
tag
again
"
focused
:
"
header
.
focusableElms
.
0
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Circle
back
and
focus
on
header
new
attribute
again
"
focused
:
"
header
.
focusableElms
.
3
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
shiftKey
:
true
}
}
{
desc
:
"
Tab
back
and
focus
on
header
class
attribute
"
focused
:
"
header
.
focusableElms
.
2
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
shiftKey
:
true
}
}
{
desc
:
"
Tab
back
and
focus
on
header
id
attribute
"
focused
:
"
header
.
focusableElms
.
1
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
shiftKey
:
true
}
}
{
desc
:
"
Tab
back
and
focus
on
header
tag
"
focused
:
"
header
.
focusableElms
.
0
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
shiftKey
:
true
}
}
{
desc
:
"
Expand
header
container
ensure
that
focus
is
still
on
header
tag
"
focused
:
"
header
.
focusableElms
.
0
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_RIGHT
"
options
:
{
}
waitFor
:
"
expanded
"
}
{
desc
:
"
Activate
header
tag
editor
"
focused
:
"
header
.
editor
.
tag
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_RETURN
"
options
:
{
}
}
{
desc
:
"
Activate
header
id
attribute
editor
"
focused
:
"
header
.
editor
.
attrList
.
children
.
0
.
children
.
1
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Deselect
text
in
header
id
attribute
editor
"
focused
:
"
header
.
editor
.
attrList
.
children
.
0
.
children
.
1
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Activate
header
class
attribute
editor
"
focused
:
"
header
.
editor
.
attrList
.
children
.
1
.
children
.
1
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Deselect
text
in
header
class
attribute
editor
"
focused
:
"
header
.
editor
.
attrList
.
children
.
1
.
children
.
1
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Activate
header
new
attribute
editor
"
focused
:
"
header
.
editor
.
newAttr
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Circle
back
and
activate
header
tag
editor
again
"
focused
:
"
header
.
editor
.
tag
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
}
}
{
desc
:
"
Circle
back
and
activate
header
new
attribute
editor
again
"
focused
:
"
header
.
editor
.
newAttr
.
inplaceEditor
.
input
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_TAB
"
options
:
{
shiftKey
:
true
}
}
{
desc
:
"
Exit
edit
mode
and
keep
focus
on
header
new
attribute
"
focused
:
"
header
.
focusableElms
.
3
"
activedescendant
:
"
header
.
tagLine
"
key
:
"
VK_ESCAPE
"
options
:
{
}
}
{
desc
:
"
Move
the
selection
to
body
and
reset
focus
to
container
tree
"
focused
:
"
docBody
"
activedescendant
:
"
body
.
tagLine
"
key
:
"
VK_UP
"
options
:
{
}
waitFor
:
"
inspector
-
updated
"
}
]
;
let
elms
=
{
}
;
let
containerID
=
0
;
add_task
(
function
*
(
)
{
let
{
inspector
}
=
yield
openInspectorForURL
(
data
:
text
/
html
;
charset
=
utf
-
8
<
h1
id
=
"
some
-
id
"
class
=
"
some
-
class
"
>
foo
<
span
>
Child
span
<
span
>
<
/
h1
>
)
;
let
markup
=
inspector
.
markup
;
let
doc
=
markup
.
doc
;
let
win
=
doc
.
defaultView
;
inspector
.
on
(
"
container
-
created
"
memorizeContainer
)
;
registerCleanupFunction
(
(
)
=
>
{
inspector
.
off
(
"
container
-
created
"
memorizeContainer
)
;
}
)
;
elms
.
docBody
=
doc
.
body
;
elms
.
root
=
markup
.
getContainer
(
markup
.
_rootNode
)
;
elms
.
header
=
yield
getContainerForSelector
(
"
h1
"
inspector
)
;
elms
.
body
=
yield
getContainerForSelector
(
"
body
"
inspector
)
;
testNavigationState
(
doc
elms
.
docBody
elms
.
body
.
tagLine
)
;
elms
.
root
.
elt
.
focus
(
)
;
for
(
let
{
desc
waitFor
focused
activedescendant
key
options
}
of
TESTS
)
{
info
(
desc
)
;
let
updated
;
if
(
waitFor
)
{
updated
=
waitFor
=
=
=
"
inspector
-
updated
"
?
inspector
.
once
(
waitFor
)
:
markup
.
once
(
waitFor
)
;
}
else
{
updated
=
Promise
.
resolve
(
)
;
}
EventUtils
.
synthesizeKey
(
key
options
win
)
;
yield
updated
;
testNavigationState
(
doc
getElm
(
focused
)
getElm
(
activedescendant
)
)
;
}
}
)
;
function
memorizeContainer
(
event
container
)
{
elms
[
container
-
{
containerID
+
+
}
]
=
container
;
}
function
getElm
(
path
)
{
let
segments
=
path
.
split
(
"
.
"
)
;
return
segments
.
reduce
(
(
prev
current
)
=
>
prev
[
current
]
elms
)
;
}
function
testNavigationState
(
doc
focused
activedescendant
)
{
let
id
=
activedescendant
.
getAttribute
(
"
id
"
)
;
is
(
doc
.
activeElement
focused
Keyboard
focus
should
be
set
to
{
focused
}
)
;
is
(
elms
.
root
.
elt
.
getAttribute
(
"
aria
-
activedescendant
"
)
id
Active
descendant
should
be
set
to
{
id
}
)
;
}
