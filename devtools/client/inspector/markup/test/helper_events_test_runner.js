"
use
strict
"
;
const
beautify
=
require
(
"
devtools
/
shared
/
jsbeautify
/
beautify
"
)
;
loadHelperScript
(
"
helper_diff
.
js
"
)
;
async
function
runEventPopupTests
(
url
tests
)
{
const
{
inspector
testActor
}
=
await
openInspectorForURL
(
url
)
;
await
inspector
.
markup
.
expandAll
(
)
;
for
(
const
test
of
tests
)
{
await
checkEventsForNode
(
test
inspector
testActor
)
;
}
await
promiseNextTick
(
)
;
}
async
function
checkEventsForNode
(
test
inspector
testActor
)
{
const
{
selector
expected
beforeTest
isSourceMapped
}
=
test
;
const
container
=
await
getContainerForSelector
(
selector
inspector
)
;
if
(
typeof
beforeTest
=
=
=
"
function
"
)
{
await
beforeTest
(
inspector
testActor
)
;
}
const
evHolder
=
container
.
elt
.
querySelector
(
"
.
inspector
-
badge
.
interactive
[
data
-
event
]
"
)
;
if
(
expected
.
length
=
=
=
0
)
{
ok
(
!
evHolder
"
event
bubble
should
be
hidden
"
)
;
return
;
}
const
tooltip
=
inspector
.
markup
.
eventDetailsTooltip
;
await
selectNode
(
selector
inspector
)
;
let
sourceMapPromise
=
null
;
if
(
isSourceMapped
)
{
sourceMapPromise
=
tooltip
.
once
(
"
event
-
tooltip
-
source
-
map
-
ready
"
)
;
}
info
(
"
Clicking
evHolder
"
)
;
evHolder
.
scrollIntoView
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
evHolder
{
}
inspector
.
markup
.
doc
.
defaultView
)
;
await
tooltip
.
once
(
"
shown
"
)
;
info
(
"
tooltip
shown
"
)
;
if
(
isSourceMapped
)
{
info
(
"
Waiting
for
source
map
to
be
applied
"
)
;
await
sourceMapPromise
;
}
const
headers
=
tooltip
.
panel
.
querySelectorAll
(
"
.
event
-
header
"
)
;
const
nodeFront
=
container
.
node
;
const
cssSelector
=
nodeFront
.
nodeName
+
"
#
"
+
nodeFront
.
id
;
for
(
let
i
=
0
;
i
<
headers
.
length
;
i
+
+
)
{
const
label
=
{
cssSelector
}
.
{
expected
[
i
]
.
type
}
(
index
{
i
}
)
;
info
(
{
label
}
START
)
;
const
header
=
headers
[
i
]
;
const
type
=
header
.
querySelector
(
"
.
event
-
tooltip
-
event
-
type
"
)
;
const
filename
=
header
.
querySelector
(
"
.
event
-
tooltip
-
filename
"
)
;
const
attributes
=
header
.
querySelectorAll
(
"
.
event
-
tooltip
-
attributes
"
)
;
const
contentBox
=
header
.
nextElementSibling
;
info
(
"
Looking
for
"
+
type
.
textContent
)
;
is
(
type
.
textContent
expected
[
i
]
.
type
"
type
matches
for
"
+
cssSelector
)
;
is
(
filename
.
textContent
expected
[
i
]
.
filename
"
filename
matches
for
"
+
cssSelector
)
;
is
(
attributes
.
length
expected
[
i
]
.
attributes
.
length
"
we
have
the
correct
number
of
attributes
"
)
;
for
(
let
j
=
0
;
j
<
expected
[
i
]
.
attributes
.
length
;
j
+
+
)
{
is
(
attributes
[
j
]
.
textContent
expected
[
i
]
.
attributes
[
j
]
"
attribute
[
"
+
j
+
"
]
matches
for
"
+
cssSelector
)
;
}
is
(
header
.
classList
.
contains
(
"
content
-
expanded
"
)
false
"
We
are
not
in
expanded
state
"
)
;
header
.
scrollIntoView
(
)
;
EventUtils
.
synthesizeMouse
(
header
2
2
{
}
type
.
ownerGlobal
)
;
await
tooltip
.
once
(
"
event
-
tooltip
-
ready
"
)
;
is
(
header
.
classList
.
contains
(
"
content
-
expanded
"
)
&
&
contentBox
.
hasAttribute
(
"
open
"
)
true
"
We
are
in
expanded
state
and
icon
changed
"
)
;
is
(
tooltip
.
panel
.
querySelectorAll
(
"
.
event
-
header
.
content
-
expanded
"
)
.
length
=
=
=
1
&
&
tooltip
.
panel
.
querySelectorAll
(
"
.
event
-
tooltip
-
content
-
box
[
open
]
"
)
.
length
=
=
=
1
true
"
Only
one
event
box
is
expanded
at
a
time
"
)
;
const
editor
=
tooltip
.
eventTooltip
.
_eventEditors
.
get
(
contentBox
)
.
editor
;
const
tidiedHandler
=
beautify
.
js
(
expected
[
i
]
.
handler
{
indent_size
:
2
}
)
;
testDiff
(
editor
.
getText
(
)
tidiedHandler
"
handler
matches
for
"
+
cssSelector
ok
)
;
info
(
{
label
}
END
)
;
}
const
tooltipHidden
=
tooltip
.
once
(
"
hidden
"
)
;
tooltip
.
hide
(
)
;
await
tooltipHidden
;
}
function
testDiff
(
text1
text2
msg
)
{
let
out
=
"
"
;
if
(
text1
=
=
=
text2
)
{
ok
(
true
msg
)
;
return
;
}
const
result
=
textDiff
(
text1
text2
)
;
for
(
const
{
atom
operation
}
of
result
)
{
switch
(
operation
)
{
case
"
add
"
:
out
+
=
"
+
"
+
atom
+
"
\
n
"
;
break
;
case
"
delete
"
:
out
+
=
"
-
"
+
atom
+
"
\
n
"
;
break
;
case
"
none
"
:
out
+
=
"
"
+
atom
+
"
\
n
"
;
break
;
}
}
ok
(
false
msg
+
"
\
nDIFF
:
\
n
=
=
=
=
=
=
=
=
=
=
\
n
"
+
out
+
"
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
}
