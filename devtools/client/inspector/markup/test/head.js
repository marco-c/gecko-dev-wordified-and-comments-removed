"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
var
clipboard
=
require
(
"
sdk
/
clipboard
"
)
;
var
{
ActorRegistryFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
actor
-
registry
"
)
;
SimpleTest
.
requestCompleteLog
(
)
;
flags
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
htmlPanelOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
sidebarOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
markup
.
pagesize
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
webcomponents
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
)
;
}
)
;
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
reloadPage
(
inspector
testActor
)
{
info
(
"
Reloading
the
page
"
)
;
let
newRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
testActor
.
reload
(
)
;
return
newRoot
;
}
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
info
(
"
Found
markup
-
container
"
+
container
)
;
return
container
;
}
)
;
function
*
getFirstChildNodeValue
(
selector
testActor
)
{
let
nodeValue
=
yield
testActor
.
eval
(
content
.
document
.
querySelector
(
"
{
selector
}
"
)
.
firstChild
.
nodeValue
;
)
;
return
nodeValue
;
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
let
def
=
defer
(
)
;
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
def
.
resolve
)
;
}
)
;
return
def
.
promise
;
}
var
clickContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
updated
=
container
.
selected
?
promise
.
resolve
(
)
:
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
)
;
function
setEditableFieldValue
(
field
value
inspector
)
{
field
.
focus
(
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
let
input
=
inplaceEditor
(
field
)
.
input
;
ok
(
input
"
Found
editable
field
for
setting
value
:
"
+
value
)
;
input
.
value
=
value
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
var
addNewAttributes
=
Task
.
async
(
function
*
(
selector
text
inspector
)
{
info
(
Entering
text
"
{
text
}
"
in
new
attribute
field
for
node
{
selector
}
)
;
let
container
=
yield
focusNode
(
selector
inspector
)
;
ok
(
container
"
The
container
for
'
"
+
selector
+
"
'
was
found
"
)
;
info
(
"
Listening
for
the
markupmutation
event
"
)
;
let
nodeMutated
=
inspector
.
once
(
"
markupmutation
"
)
;
setEditableFieldValue
(
container
.
editor
.
newAttr
text
inspector
)
;
yield
nodeMutated
;
}
)
;
var
assertAttributes
=
Task
.
async
(
function
*
(
selector
expected
testActor
)
{
let
{
attributes
:
actual
}
=
yield
testActor
.
getNodeInfo
(
selector
)
;
is
(
actual
.
length
Object
.
keys
(
expected
)
.
length
"
The
node
"
+
selector
+
"
has
the
expected
number
of
attributes
.
"
)
;
for
(
let
attr
in
expected
)
{
let
foundAttr
=
actual
.
find
(
(
{
name
}
)
=
>
name
=
=
=
attr
)
;
let
foundValue
=
foundAttr
?
foundAttr
.
value
:
undefined
;
ok
(
foundAttr
"
The
node
"
+
selector
+
"
has
the
attribute
"
+
attr
)
;
is
(
foundValue
expected
[
attr
]
"
The
node
"
+
selector
+
"
has
the
correct
"
+
attr
+
"
attribute
value
"
)
;
}
}
)
;
function
undoChange
(
inspector
)
{
let
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
let
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
function
getSelectorSearchBox
(
inspector
)
{
return
inspector
.
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
}
function
searchUsingSelectorSearch
(
selector
inspector
)
{
info
(
"
Entering
\
"
"
+
selector
+
"
\
"
into
the
selector
-
search
input
field
"
)
;
let
field
=
getSelectorSearchBox
(
inspector
)
;
field
.
focus
(
)
;
field
.
value
=
selector
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
var
isEditingMenuDisabled
=
Task
.
async
(
function
*
(
nodeFront
inspector
assert
=
true
)
{
clipboard
.
set
(
"
<
p
>
test
<
/
p
>
"
"
html
"
)
;
yield
selectNode
(
nodeFront
inspector
)
;
let
allMenuItems
=
openContextMenuAndGetAllItems
(
inspector
)
;
let
deleteMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
delete
"
)
;
let
editHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
edithtml
"
)
;
let
pasteHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
pasteouterhtml
"
)
;
if
(
assert
)
{
ok
(
deleteMenuItem
.
disabled
"
Delete
menu
item
is
disabled
"
)
;
ok
(
editHTMLMenuItem
.
disabled
"
Edit
HTML
menu
item
is
disabled
"
)
;
ok
(
pasteHTMLMenuItem
.
disabled
"
Paste
HTML
menu
item
is
disabled
"
)
;
}
return
deleteMenuItem
.
disabled
&
&
editHTMLMenuItem
.
disabled
&
&
pasteHTMLMenuItem
.
disabled
;
}
)
;
var
isEditingMenuEnabled
=
Task
.
async
(
function
*
(
nodeFront
inspector
assert
=
true
)
{
clipboard
.
set
(
"
<
p
>
test
<
/
p
>
"
"
html
"
)
;
yield
selectNode
(
nodeFront
inspector
)
;
let
allMenuItems
=
openContextMenuAndGetAllItems
(
inspector
)
;
let
deleteMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
delete
"
)
;
let
editHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
edithtml
"
)
;
let
pasteHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
pasteouterhtml
"
)
;
if
(
assert
)
{
ok
(
!
deleteMenuItem
.
disabled
"
Delete
menu
item
is
enabled
"
)
;
ok
(
!
editHTMLMenuItem
.
disabled
"
Edit
HTML
menu
item
is
enabled
"
)
;
ok
(
!
pasteHTMLMenuItem
.
disabled
"
Paste
HTML
menu
item
is
enabled
"
)
;
}
return
!
deleteMenuItem
.
disabled
&
&
!
editHTMLMenuItem
.
disabled
&
&
!
pasteHTMLMenuItem
.
disabled
;
}
)
;
function
promiseNextTick
(
)
{
let
deferred
=
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
collapseSelectionAndTab
(
inspector
)
{
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
}
function
collapseSelectionAndShiftTab
(
inspector
)
{
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
}
function
checkFocusedAttribute
(
attrName
editMode
)
{
let
focusedAttr
=
Services
.
focus
.
focusedElement
;
ok
(
focusedAttr
"
Has
a
focused
element
"
)
;
let
dataAttr
=
focusedAttr
.
parentNode
.
dataset
.
attr
;
is
(
dataAttr
attrName
attrName
+
"
attribute
editor
is
currently
focused
.
"
)
;
if
(
editMode
)
{
is
(
focusedAttr
.
tagName
"
textarea
"
attrName
+
"
is
in
edit
mode
"
)
;
}
else
{
is
(
focusedAttr
.
tagName
"
span
"
attrName
+
"
is
not
in
edit
mode
"
)
;
}
}
var
getAttributesFromEditor
=
Task
.
async
(
function
*
(
selector
inspector
)
{
let
nodeList
=
(
yield
getContainerForSelector
(
selector
inspector
)
)
.
tagLine
.
querySelectorAll
(
"
[
data
-
attr
]
"
)
;
return
[
.
.
.
nodeList
]
.
map
(
node
=
>
node
.
getAttribute
(
"
data
-
attr
"
)
)
;
}
)
;
function
*
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
yield
waitForChildrenUpdated
(
inspector
)
;
return
yield
waitForMultipleChildrenUpdates
(
inspector
)
;
}
return
undefined
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
{
}
)
;
let
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
destroyed
=
defer
(
)
;
server
.
stop
(
(
)
=
>
{
destroyed
.
resolve
(
)
;
}
)
;
yield
destroyed
.
promise
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
function
registerTabActor
(
client
options
)
{
let
moduleUrl
=
options
.
moduleUrl
;
return
client
.
listTabs
(
)
.
then
(
response
=
>
{
let
config
=
{
prefix
:
options
.
prefix
constructor
:
options
.
actorClass
type
:
{
tab
:
true
}
}
;
let
registry
=
ActorRegistryFront
(
client
response
)
;
return
registry
.
registerActor
(
moduleUrl
config
)
.
then
(
registrar
=
>
{
return
client
.
getTab
(
)
.
then
(
tabResponse
=
>
(
{
registrar
:
registrar
form
:
tabResponse
.
tab
}
)
)
;
}
)
;
}
)
;
}
function
unregisterActor
(
registrar
front
)
{
return
front
.
detach
(
)
.
then
(
(
)
=
>
{
return
registrar
.
unregister
(
)
;
}
)
;
}
function
*
simulateNodeDrag
(
inspector
selector
xOffset
=
10
yOffset
=
10
)
{
let
container
=
typeof
selector
=
=
=
"
string
"
?
yield
getContainerForSelector
(
selector
inspector
)
:
selector
;
let
rect
=
container
.
tagLine
.
getBoundingClientRect
(
)
;
let
scrollX
=
inspector
.
markup
.
doc
.
documentElement
.
scrollLeft
;
let
scrollY
=
inspector
.
markup
.
doc
.
documentElement
.
scrollTop
;
info
(
"
Simulate
mouseDown
on
element
"
+
selector
)
;
container
.
_onMouseDown
(
{
target
:
container
.
tagLine
button
:
0
pageX
:
scrollX
+
rect
.
x
pageY
:
scrollY
+
rect
.
y
stopPropagation
:
(
)
=
>
{
}
preventDefault
:
(
)
=
>
{
}
}
)
;
if
(
inspector
.
selection
.
nodeFront
!
=
=
container
.
node
)
{
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
info
(
"
Simulate
mouseMove
on
element
"
+
selector
)
;
container
.
_onMouseMove
(
{
pageX
:
scrollX
+
rect
.
x
+
xOffset
pageY
:
scrollY
+
rect
.
y
+
yOffset
}
)
;
}
function
*
simulateNodeDrop
(
inspector
selector
)
{
info
(
"
Simulate
mouseUp
on
element
"
+
selector
)
;
let
container
=
typeof
selector
=
=
=
"
string
"
?
yield
getContainerForSelector
(
selector
inspector
)
:
selector
;
container
.
_onMouseUp
(
)
;
inspector
.
markup
.
_onMouseUp
(
)
;
}
function
*
simulateNodeDragAndDrop
(
inspector
selector
xOffset
yOffset
)
{
yield
simulateNodeDrag
(
inspector
selector
xOffset
yOffset
)
;
yield
simulateNodeDrop
(
inspector
selector
)
;
}
function
*
waitForScrollStop
(
doc
)
{
let
el
=
doc
.
documentElement
;
let
win
=
doc
.
defaultView
;
let
lastScrollTop
=
el
.
scrollTop
;
let
stopFrameCount
=
0
;
while
(
stopFrameCount
<
30
)
{
yield
new
Promise
(
resolve
=
>
win
.
requestAnimationFrame
(
resolve
)
)
;
if
(
lastScrollTop
=
=
el
.
scrollTop
)
{
stopFrameCount
+
+
;
}
else
{
stopFrameCount
=
0
;
lastScrollTop
=
el
.
scrollTop
;
}
}
return
lastScrollTop
;
}
function
*
checkDeleteAndSelection
(
inspector
key
{
selector
focusedSelector
pseudo
}
)
{
info
(
"
Test
deleting
node
"
+
selector
+
"
with
"
+
key
+
"
"
+
"
expecting
"
+
focusedSelector
+
"
to
be
focused
"
)
;
info
(
"
Select
node
"
+
selector
+
"
and
make
sure
it
is
focused
"
)
;
yield
selectNode
(
selector
inspector
)
;
yield
clickContainer
(
selector
inspector
)
;
info
(
"
Delete
the
node
with
:
"
+
key
)
;
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
EventUtils
.
sendKey
(
key
inspector
.
panelWin
)
;
yield
Promise
.
all
(
[
mutated
inspector
.
once
(
"
inspector
-
updated
"
)
]
)
;
let
nodeFront
=
yield
getNodeFront
(
focusedSelector
inspector
)
;
if
(
pseudo
)
{
focusedSelector
=
focusedSelector
+
"
:
:
"
+
pseudo
;
let
{
nodes
}
=
yield
inspector
.
walker
.
children
(
nodeFront
)
;
nodeFront
=
pseudo
=
=
=
"
before
"
?
nodes
[
0
]
:
nodes
[
nodes
.
length
-
1
]
;
}
is
(
inspector
.
selection
.
nodeFront
nodeFront
focusedSelector
+
"
is
selected
after
deletion
"
)
;
info
(
"
Check
that
the
node
was
really
removed
"
)
;
let
node
=
yield
getNodeFront
(
selector
inspector
)
;
ok
(
!
node
"
The
node
can
'
t
be
found
in
the
page
anymore
"
)
;
info
(
"
Undo
the
deletion
to
restore
the
original
markup
"
)
;
yield
undoChange
(
inspector
)
;
node
=
yield
getNodeFront
(
selector
inspector
)
;
ok
(
node
"
The
node
is
back
"
)
;
}
