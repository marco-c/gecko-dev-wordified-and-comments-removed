"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
var
clipboard
=
require
(
"
sdk
/
clipboard
"
)
;
var
{
setTimeout
clearTimeout
}
=
require
(
"
sdk
/
timers
"
)
;
SimpleTest
.
requestCompleteLog
(
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
DevToolsUtils
.
testing
=
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
htmlPanelOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
sidebarOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
markup
.
pagesize
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
webcomponents
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
)
;
}
)
;
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
reloadPage
(
inspector
)
{
info
(
"
Reloading
the
page
"
)
;
let
newRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
content
.
location
.
reload
(
)
;
return
newRoot
;
}
function
reloadTab
(
testActor
)
{
return
testActor
.
eval
(
"
location
.
reload
(
)
"
)
;
}
function
getNode
(
nodeOrSelector
)
{
info
(
"
Getting
the
node
for
'
"
+
nodeOrSelector
+
"
'
"
)
;
return
typeof
nodeOrSelector
=
=
=
"
string
"
?
content
.
document
.
querySelector
(
nodeOrSelector
)
:
nodeOrSelector
;
}
function
getNodeInfo
(
selector
testActor
)
{
return
testActor
.
getNodeInfo
(
selector
)
;
}
function
setNodeAttribute
(
selector
attributeName
attributeValue
testActor
)
{
return
testActor
.
setAttribute
(
selector
attributeName
attributeValue
)
;
}
function
selectAndHighlightNode
(
nodeOrSelector
inspector
)
{
info
(
"
Highlighting
and
selecting
the
node
"
+
nodeOrSelector
)
;
let
node
=
getNode
(
nodeOrSelector
)
;
let
updated
=
inspector
.
toolbox
.
once
(
"
highlighter
-
ready
"
)
;
inspector
.
selection
.
setNode
(
node
"
test
-
highlight
"
)
;
return
updated
;
}
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
info
(
"
Found
markup
-
container
"
+
container
)
;
return
container
;
}
)
;
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
let
def
=
promise
.
defer
(
)
;
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
def
.
resolve
)
;
}
)
;
return
def
.
promise
;
}
var
clickContainer
=
Task
.
async
(
function
*
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
let
updated
=
container
.
selected
?
promise
.
resolve
(
)
:
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
)
;
function
isHighlighterVisible
(
)
{
let
highlighter
=
gBrowser
.
selectedBrowser
.
parentNode
.
querySelector
(
"
.
highlighter
-
container
.
box
-
model
-
root
"
)
;
return
highlighter
&
&
!
highlighter
.
hasAttribute
(
"
hidden
"
)
;
}
function
setEditableFieldValue
(
field
value
inspector
)
{
field
.
focus
(
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
let
input
=
inplaceEditor
(
field
)
.
input
;
ok
(
input
"
Found
editable
field
for
setting
value
:
"
+
value
)
;
input
.
value
=
value
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
var
addNewAttributes
=
Task
.
async
(
function
*
(
selector
text
inspector
)
{
info
(
"
Entering
text
'
"
+
text
+
"
'
in
node
'
"
+
selector
+
"
'
'
s
new
attribute
field
"
)
;
let
container
=
yield
getContainerForSelector
(
selector
inspector
)
;
ok
(
container
"
The
container
for
'
"
+
selector
+
"
'
was
found
"
)
;
info
(
"
Listening
for
the
markupmutation
event
"
)
;
let
nodeMutated
=
inspector
.
once
(
"
markupmutation
"
)
;
setEditableFieldValue
(
container
.
editor
.
newAttr
text
inspector
)
;
yield
nodeMutated
;
}
)
;
var
assertAttributes
=
Task
.
async
(
function
*
(
selector
expected
testActor
)
{
let
{
attributes
:
actual
}
=
yield
getNodeInfo
(
selector
testActor
)
;
is
(
actual
.
length
Object
.
keys
(
expected
)
.
length
"
The
node
"
+
selector
+
"
has
the
expected
number
of
attributes
.
"
)
;
for
(
let
attr
in
expected
)
{
let
foundAttr
=
actual
.
find
(
(
{
name
value
}
)
=
>
name
=
=
=
attr
)
;
let
foundValue
=
foundAttr
?
foundAttr
.
value
:
undefined
;
ok
(
foundAttr
"
The
node
"
+
selector
+
"
has
the
attribute
"
+
attr
)
;
is
(
foundValue
expected
[
attr
]
"
The
node
"
+
selector
+
"
has
the
correct
"
+
attr
+
"
attribute
value
"
)
;
}
}
)
;
function
undoChange
(
inspector
)
{
let
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
let
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
let
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
function
getSelectorSearchBox
(
inspector
)
{
return
inspector
.
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
}
function
searchUsingSelectorSearch
(
selector
inspector
)
{
info
(
"
Entering
\
"
"
+
selector
+
"
\
"
into
the
selector
-
search
input
field
"
)
;
let
field
=
getSelectorSearchBox
(
inspector
)
;
field
.
focus
(
)
;
field
.
value
=
selector
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
function
wait
(
ms
)
{
let
def
=
promise
.
defer
(
)
;
content
.
setTimeout
(
def
.
resolve
ms
)
;
return
def
.
promise
;
}
var
isEditingMenuDisabled
=
Task
.
async
(
function
*
(
nodeFront
inspector
assert
=
true
)
{
let
deleteMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
delete
"
)
;
let
editHTMLMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
edithtml
"
)
;
let
pasteHTMLMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pasteouterhtml
"
)
;
clipboard
.
set
(
"
<
p
>
test
<
/
p
>
"
"
html
"
)
;
let
menu
=
inspector
.
nodemenu
;
yield
selectNode
(
nodeFront
inspector
)
;
yield
reopenMenu
(
menu
)
;
let
isDeleteMenuDisabled
=
deleteMenuItem
.
hasAttribute
(
"
disabled
"
)
;
let
isEditHTMLMenuDisabled
=
editHTMLMenuItem
.
hasAttribute
(
"
disabled
"
)
;
let
isPasteHTMLMenuDisabled
=
pasteHTMLMenuItem
.
hasAttribute
(
"
disabled
"
)
;
if
(
assert
)
{
ok
(
isDeleteMenuDisabled
"
Delete
menu
item
is
disabled
"
)
;
ok
(
isEditHTMLMenuDisabled
"
Edit
HTML
menu
item
is
disabled
"
)
;
ok
(
isPasteHTMLMenuDisabled
"
Paste
HTML
menu
item
is
disabled
"
)
;
}
return
isDeleteMenuDisabled
&
&
isEditHTMLMenuDisabled
&
&
isPasteHTMLMenuDisabled
;
}
)
;
var
isEditingMenuEnabled
=
Task
.
async
(
function
*
(
nodeFront
inspector
assert
=
true
)
{
let
deleteMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
delete
"
)
;
let
editHTMLMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
edithtml
"
)
;
let
pasteHTMLMenuItem
=
inspector
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pasteouterhtml
"
)
;
clipboard
.
set
(
"
<
p
>
test
<
/
p
>
"
"
html
"
)
;
let
menu
=
inspector
.
nodemenu
;
yield
selectNode
(
nodeFront
inspector
)
;
yield
reopenMenu
(
menu
)
;
let
isDeleteMenuDisabled
=
deleteMenuItem
.
hasAttribute
(
"
disabled
"
)
;
let
isEditHTMLMenuDisabled
=
editHTMLMenuItem
.
hasAttribute
(
"
disabled
"
)
;
let
isPasteHTMLMenuDisabled
=
pasteHTMLMenuItem
.
hasAttribute
(
"
disabled
"
)
;
if
(
assert
)
{
ok
(
!
isDeleteMenuDisabled
"
Delete
menu
item
is
enabled
"
)
;
ok
(
!
isEditHTMLMenuDisabled
"
Edit
HTML
menu
item
is
enabled
"
)
;
ok
(
!
isPasteHTMLMenuDisabled
"
Paste
HTML
menu
item
is
enabled
"
)
;
}
return
!
isDeleteMenuDisabled
&
&
!
isEditHTMLMenuDisabled
&
&
!
isPasteHTMLMenuDisabled
;
}
)
;
var
reopenMenu
=
Task
.
async
(
function
*
(
menu
)
{
if
(
menu
.
state
=
=
"
closing
"
|
|
menu
.
state
=
=
"
open
"
)
{
let
popuphidden
=
once
(
menu
"
popuphidden
"
true
)
;
menu
.
hidePopup
(
)
;
yield
popuphidden
;
}
let
popupshown
=
once
(
menu
"
popupshown
"
true
)
;
menu
.
openPopup
(
)
;
yield
popupshown
;
}
)
;
function
promiseNextTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
collapseSelectionAndTab
(
inspector
)
{
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
}
function
collapseSelectionAndShiftTab
(
inspector
)
{
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
}
function
checkFocusedAttribute
(
attrName
editMode
)
{
let
focusedAttr
=
Services
.
focus
.
focusedElement
;
is
(
focusedAttr
?
focusedAttr
.
parentNode
.
dataset
.
attr
:
undefined
attrName
attrName
+
"
attribute
editor
is
currently
focused
.
"
)
;
is
(
focusedAttr
?
focusedAttr
.
tagName
:
undefined
editMode
?
"
input
"
:
"
span
"
editMode
?
attrName
+
"
is
in
edit
mode
"
:
attrName
+
"
is
not
in
edit
mode
"
)
;
}
var
getAttributesFromEditor
=
Task
.
async
(
function
*
(
selector
inspector
)
{
let
nodeList
=
(
yield
getContainerForSelector
(
selector
inspector
)
)
.
tagLine
.
querySelectorAll
(
"
[
data
-
attr
]
"
)
;
return
[
.
.
.
nodeList
]
.
map
(
node
=
>
node
.
getAttribute
(
"
data
-
attr
"
)
)
;
}
)
;
function
*
waitForMultipleChildrenUpdates
(
inspector
)
{
if
(
inspector
.
markup
.
_queuedChildUpdates
&
&
inspector
.
markup
.
_queuedChildUpdates
.
size
)
{
yield
waitForChildrenUpdated
(
inspector
)
;
return
yield
waitForMultipleChildrenUpdates
(
inspector
)
;
}
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
{
}
)
;
let
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
destroyed
=
promise
.
defer
(
)
;
server
.
stop
(
(
)
=
>
{
destroyed
.
resolve
(
)
;
}
)
;
yield
destroyed
.
promise
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
function
contextMenuClick
(
element
)
{
let
evt
=
element
.
ownerDocument
.
createEvent
(
'
MouseEvents
'
)
;
let
button
=
2
;
evt
.
initMouseEvent
(
'
contextmenu
'
true
true
element
.
ownerDocument
.
defaultView
1
0
0
0
0
false
false
false
false
button
null
)
;
element
.
dispatchEvent
(
evt
)
;
}
function
registerTabActor
(
client
options
)
{
let
moduleUrl
=
options
.
moduleUrl
;
return
client
.
listTabs
(
)
.
then
(
response
=
>
{
let
config
=
{
prefix
:
options
.
prefix
constructor
:
options
.
actorClass
type
:
{
tab
:
true
}
}
;
let
registry
=
ActorRegistryFront
(
client
response
)
;
return
registry
.
registerActor
(
moduleUrl
config
)
.
then
(
registrar
=
>
{
return
client
.
getTab
(
)
.
then
(
response
=
>
{
return
{
registrar
:
registrar
form
:
response
.
tab
}
;
}
)
;
}
)
;
}
)
;
}
function
unregisterActor
(
registrar
front
)
{
return
front
.
detach
(
)
.
then
(
(
)
=
>
{
return
registrar
.
unregister
(
)
;
}
)
;
}
function
*
simulateNodeDrag
(
inspector
selector
xOffset
=
10
yOffset
=
10
)
{
let
container
=
typeof
selector
=
=
=
"
string
"
?
yield
getContainerForSelector
(
selector
inspector
)
:
selector
;
let
rect
=
container
.
tagLine
.
getBoundingClientRect
(
)
;
let
scrollX
=
inspector
.
markup
.
doc
.
documentElement
.
scrollLeft
;
let
scrollY
=
inspector
.
markup
.
doc
.
documentElement
.
scrollTop
;
info
(
"
Simulate
mouseDown
on
element
"
+
selector
)
;
container
.
_onMouseDown
(
{
target
:
container
.
tagLine
button
:
0
pageX
:
scrollX
+
rect
.
x
pageY
:
scrollY
+
rect
.
y
stopPropagation
:
(
)
=
>
{
}
preventDefault
:
(
)
=
>
{
}
}
)
;
if
(
inspector
.
selection
.
nodeFront
!
=
=
container
.
node
)
{
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
info
(
"
Simulate
mouseMove
on
element
"
+
selector
)
;
container
.
_onMouseMove
(
{
pageX
:
scrollX
+
rect
.
x
+
xOffset
pageY
:
scrollY
+
rect
.
y
+
yOffset
}
)
;
}
function
*
simulateNodeDrop
(
inspector
selector
)
{
info
(
"
Simulate
mouseUp
on
element
"
+
selector
)
;
let
container
=
typeof
selector
=
=
=
"
string
"
?
yield
getContainerForSelector
(
selector
inspector
)
:
selector
;
container
.
_onMouseUp
(
)
;
inspector
.
markup
.
_onMouseUp
(
)
;
}
function
*
simulateNodeDragAndDrop
(
inspector
selector
xOffset
yOffset
)
{
yield
simulateNodeDrag
(
inspector
selector
xOffset
yOffset
)
;
yield
simulateNodeDrop
(
inspector
selector
)
;
}
