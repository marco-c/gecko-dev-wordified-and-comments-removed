"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
var
clipboard
=
require
(
"
devtools
/
shared
/
platform
/
clipboard
"
)
;
SimpleTest
.
requestCompleteLog
(
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
htmlPanelOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
sidebarOpen
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
markup
.
pagesize
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
webcomponents
.
shadowdom
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
)
;
}
)
;
function
loadHelperScript
(
filePath
)
{
const
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
reloadPage
(
inspector
testActor
)
{
info
(
"
Reloading
the
page
"
)
;
const
newRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
testActor
.
reload
(
)
;
return
newRoot
;
}
function
getContainerForNodeFront
(
nodeFront
{
markup
}
)
{
return
markup
.
getContainer
(
nodeFront
)
;
}
var
getContainerForSelector
=
async
function
(
selector
inspector
expectFailure
=
false
)
{
info
(
"
Getting
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
if
(
expectFailure
)
{
ok
(
!
container
"
Shouldn
'
t
find
markup
-
container
for
selector
:
"
+
selector
)
;
}
else
{
ok
(
container
"
Found
markup
-
container
for
selector
:
"
+
selector
)
;
}
return
container
;
}
;
async
function
getFirstChildNodeValue
(
selector
testActor
)
{
const
nodeValue
=
await
testActor
.
eval
(
document
.
querySelector
(
"
{
selector
}
"
)
.
firstChild
.
nodeValue
;
)
;
return
nodeValue
;
}
function
waitForChildrenUpdated
(
{
markup
}
)
{
info
(
"
Waiting
for
queued
children
updates
to
be
handled
"
)
;
return
new
Promise
(
resolve
=
>
{
markup
.
_waitForChildren
(
)
.
then
(
(
)
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
)
;
}
var
clickContainer
=
async
function
(
selector
inspector
)
{
info
(
"
Clicking
on
the
markup
-
container
for
node
"
+
selector
)
;
const
nodeFront
=
await
getNodeFront
(
selector
inspector
)
;
const
container
=
getContainerForNodeFront
(
nodeFront
inspector
)
;
const
updated
=
container
.
selected
?
promise
.
resolve
(
)
:
inspector
.
once
(
"
inspector
-
updated
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mousedown
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
EventUtils
.
synthesizeMouseAtCenter
(
container
.
tagLine
{
type
:
"
mouseup
"
}
inspector
.
markup
.
doc
.
defaultView
)
;
return
updated
;
}
;
function
setEditableFieldValue
(
field
value
inspector
)
{
field
.
focus
(
)
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
const
input
=
inplaceEditor
(
field
)
.
input
;
ok
(
input
"
Found
editable
field
for
setting
value
:
"
+
value
)
;
input
.
value
=
value
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
var
addNewAttributes
=
async
function
(
selector
text
inspector
)
{
info
(
Entering
text
"
{
text
}
"
in
new
attribute
field
for
node
{
selector
}
)
;
const
container
=
await
focusNode
(
selector
inspector
)
;
ok
(
container
"
The
container
for
'
"
+
selector
+
"
'
was
found
"
)
;
info
(
"
Listening
for
the
markupmutation
event
"
)
;
const
nodeMutated
=
inspector
.
once
(
"
markupmutation
"
)
;
setEditableFieldValue
(
container
.
editor
.
newAttr
text
inspector
)
;
await
nodeMutated
;
}
;
var
assertAttributes
=
async
function
(
selector
expected
testActor
)
{
const
{
attributes
:
actual
}
=
await
testActor
.
getNodeInfo
(
selector
)
;
is
(
actual
.
length
Object
.
keys
(
expected
)
.
length
"
The
node
"
+
selector
+
"
has
the
expected
number
of
attributes
.
"
)
;
for
(
const
attr
in
expected
)
{
const
foundAttr
=
actual
.
find
(
(
{
name
}
)
=
>
name
=
=
=
attr
)
;
const
foundValue
=
foundAttr
?
foundAttr
.
value
:
undefined
;
ok
(
foundAttr
"
The
node
"
+
selector
+
"
has
the
attribute
"
+
attr
)
;
is
(
foundValue
expected
[
attr
]
"
The
node
"
+
selector
+
"
has
the
correct
"
+
attr
+
"
attribute
value
"
)
;
}
}
;
function
undoChange
(
inspector
)
{
const
canUndo
=
inspector
.
markup
.
undo
.
canUndo
(
)
;
ok
(
canUndo
"
The
last
change
in
the
markup
-
view
can
be
undone
"
)
;
if
(
!
canUndo
)
{
return
promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
undo
(
)
;
return
mutated
;
}
function
redoChange
(
inspector
)
{
const
canRedo
=
inspector
.
markup
.
undo
.
canRedo
(
)
;
ok
(
canRedo
"
The
last
change
in
the
markup
-
view
can
be
redone
"
)
;
if
(
!
canRedo
)
{
return
promise
.
reject
(
)
;
}
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
inspector
.
markup
.
undo
.
redo
(
)
;
return
mutated
;
}
function
getSelectorSearchBox
(
inspector
)
{
return
inspector
.
panelWin
.
document
.
getElementById
(
"
inspector
-
searchbox
"
)
;
}
function
searchUsingSelectorSearch
(
selector
inspector
)
{
info
(
"
Entering
\
"
"
+
selector
+
"
\
"
into
the
selector
-
search
input
field
"
)
;
const
field
=
getSelectorSearchBox
(
inspector
)
;
field
.
focus
(
)
;
field
.
value
=
selector
;
EventUtils
.
sendKey
(
"
return
"
inspector
.
panelWin
)
;
}
var
isEditingMenuDisabled
=
async
function
(
nodeFront
inspector
assert
=
true
)
{
clipboard
.
copyString
(
"
<
p
>
test
<
/
p
>
"
)
;
await
selectNode
(
nodeFront
inspector
)
;
const
allMenuItems
=
openContextMenuAndGetAllItems
(
inspector
)
;
const
deleteMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
delete
"
)
;
const
editHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
edithtml
"
)
;
const
pasteHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
pasteouterhtml
"
)
;
if
(
assert
)
{
ok
(
deleteMenuItem
.
disabled
"
Delete
menu
item
is
disabled
"
)
;
ok
(
editHTMLMenuItem
.
disabled
"
Edit
HTML
menu
item
is
disabled
"
)
;
ok
(
pasteHTMLMenuItem
.
disabled
"
Paste
HTML
menu
item
is
disabled
"
)
;
}
return
deleteMenuItem
.
disabled
&
&
editHTMLMenuItem
.
disabled
&
&
pasteHTMLMenuItem
.
disabled
;
}
;
var
isEditingMenuEnabled
=
async
function
(
nodeFront
inspector
assert
=
true
)
{
clipboard
.
copyString
(
"
<
p
>
test
<
/
p
>
"
)
;
await
selectNode
(
nodeFront
inspector
)
;
const
allMenuItems
=
openContextMenuAndGetAllItems
(
inspector
)
;
const
deleteMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
delete
"
)
;
const
editHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
edithtml
"
)
;
const
pasteHTMLMenuItem
=
allMenuItems
.
find
(
i
=
>
i
.
id
=
=
=
"
node
-
menu
-
pasteouterhtml
"
)
;
if
(
assert
)
{
ok
(
!
deleteMenuItem
.
disabled
"
Delete
menu
item
is
enabled
"
)
;
ok
(
!
editHTMLMenuItem
.
disabled
"
Edit
HTML
menu
item
is
enabled
"
)
;
ok
(
!
pasteHTMLMenuItem
.
disabled
"
Paste
HTML
menu
item
is
enabled
"
)
;
}
return
!
deleteMenuItem
.
disabled
&
&
!
editHTMLMenuItem
.
disabled
&
&
!
pasteHTMLMenuItem
.
disabled
;
}
;
function
promiseNextTick
(
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
function
collapseSelectionAndTab
(
inspector
)
{
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
EventUtils
.
sendKey
(
"
tab
"
inspector
.
panelWin
)
;
}
function
collapseSelectionAndShiftTab
(
inspector
)
{
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
shiftKey
:
true
}
inspector
.
panelWin
)
;
}
function
checkFocusedAttribute
(
attrName
editMode
)
{
const
focusedAttr
=
Services
.
focus
.
focusedElement
;
ok
(
focusedAttr
"
Has
a
focused
element
"
)
;
const
dataAttr
=
focusedAttr
.
parentNode
.
dataset
.
attr
;
is
(
dataAttr
attrName
attrName
+
"
attribute
editor
is
currently
focused
.
"
)
;
if
(
editMode
)
{
is
(
focusedAttr
.
tagName
"
textarea
"
attrName
+
"
is
in
edit
mode
"
)
;
}
else
{
is
(
focusedAttr
.
tagName
"
span
"
attrName
+
"
is
not
in
edit
mode
"
)
;
}
}
var
getAttributesFromEditor
=
async
function
(
selector
inspector
)
{
const
nodeList
=
(
await
getContainerForSelector
(
selector
inspector
)
)
.
tagLine
.
querySelectorAll
(
"
[
data
-
attr
]
"
)
;
return
[
.
.
.
nodeList
]
.
map
(
node
=
>
node
.
getAttribute
(
"
data
-
attr
"
)
)
;
}
;
async
function
simulateNodeDrag
(
inspector
selector
xOffset
=
10
yOffset
=
10
)
{
const
container
=
typeof
selector
=
=
=
"
string
"
?
await
getContainerForSelector
(
selector
inspector
)
:
selector
;
const
rect
=
container
.
tagLine
.
getBoundingClientRect
(
)
;
const
scrollX
=
inspector
.
markup
.
doc
.
documentElement
.
scrollLeft
;
const
scrollY
=
inspector
.
markup
.
doc
.
documentElement
.
scrollTop
;
info
(
"
Simulate
mouseDown
on
element
"
+
selector
)
;
container
.
_onMouseDown
(
{
target
:
container
.
tagLine
button
:
0
pageX
:
scrollX
+
rect
.
x
pageY
:
scrollY
+
rect
.
y
stopPropagation
:
(
)
=
>
{
}
preventDefault
:
(
)
=
>
{
}
}
)
;
if
(
inspector
.
selection
.
nodeFront
!
=
=
container
.
node
)
{
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
info
(
"
Simulate
mouseMove
on
element
"
+
selector
)
;
container
.
onMouseMove
(
{
pageX
:
scrollX
+
rect
.
x
+
xOffset
pageY
:
scrollY
+
rect
.
y
+
yOffset
}
)
;
}
async
function
simulateNodeDrop
(
inspector
selector
)
{
info
(
"
Simulate
mouseUp
on
element
"
+
selector
)
;
const
container
=
typeof
selector
=
=
=
"
string
"
?
await
getContainerForSelector
(
selector
inspector
)
:
selector
;
container
.
onMouseUp
(
)
;
inspector
.
markup
.
_onMouseUp
(
)
;
}
async
function
simulateNodeDragAndDrop
(
inspector
selector
xOffset
yOffset
)
{
await
simulateNodeDrag
(
inspector
selector
xOffset
yOffset
)
;
await
simulateNodeDrop
(
inspector
selector
)
;
}
async
function
waitForScrollStop
(
doc
)
{
const
el
=
doc
.
documentElement
;
const
win
=
doc
.
defaultView
;
let
lastScrollTop
=
el
.
scrollTop
;
let
stopFrameCount
=
0
;
while
(
stopFrameCount
<
30
)
{
await
new
Promise
(
resolve
=
>
win
.
requestAnimationFrame
(
resolve
)
)
;
if
(
lastScrollTop
=
=
el
.
scrollTop
)
{
stopFrameCount
+
+
;
}
else
{
stopFrameCount
=
0
;
lastScrollTop
=
el
.
scrollTop
;
}
}
return
lastScrollTop
;
}
async
function
checkDeleteAndSelection
(
inspector
key
{
selector
focusedSelector
pseudo
}
)
{
info
(
"
Test
deleting
node
"
+
selector
+
"
with
"
+
key
+
"
"
+
"
expecting
"
+
focusedSelector
+
"
to
be
focused
"
)
;
info
(
"
Select
node
"
+
selector
+
"
and
make
sure
it
is
focused
"
)
;
await
selectNode
(
selector
inspector
)
;
await
clickContainer
(
selector
inspector
)
;
info
(
"
Delete
the
node
with
:
"
+
key
)
;
const
mutated
=
inspector
.
once
(
"
markupmutation
"
)
;
EventUtils
.
sendKey
(
key
inspector
.
panelWin
)
;
await
Promise
.
all
(
[
mutated
inspector
.
once
(
"
inspector
-
updated
"
)
]
)
;
let
nodeFront
=
await
getNodeFront
(
focusedSelector
inspector
)
;
if
(
pseudo
)
{
focusedSelector
=
focusedSelector
+
"
:
:
"
+
pseudo
;
const
{
nodes
}
=
await
inspector
.
walker
.
children
(
nodeFront
)
;
nodeFront
=
pseudo
=
=
=
"
before
"
?
nodes
[
0
]
:
nodes
[
nodes
.
length
-
1
]
;
}
is
(
inspector
.
selection
.
nodeFront
nodeFront
focusedSelector
+
"
is
selected
after
deletion
"
)
;
info
(
"
Check
that
the
node
was
really
removed
"
)
;
let
node
=
await
getNodeFront
(
selector
inspector
)
;
ok
(
!
node
"
The
node
can
'
t
be
found
in
the
page
anymore
"
)
;
info
(
"
Undo
the
deletion
to
restore
the
original
markup
"
)
;
await
undoChange
(
inspector
)
;
node
=
await
getNodeFront
(
selector
inspector
)
;
ok
(
node
"
The
node
is
back
"
)
;
}
function
assertContainerSlotted
(
container
)
{
ok
(
container
.
isSlotted
(
)
"
Container
is
a
slotted
container
"
)
;
ok
(
container
.
elt
.
querySelector
(
"
.
reveal
-
link
"
)
"
Slotted
container
has
a
reveal
link
element
"
)
;
}
function
assertContainerHasText
(
container
expectedText
)
{
const
textContent
=
container
.
elt
.
textContent
;
ok
(
textContent
.
includes
(
expectedText
)
"
Container
has
expected
text
:
"
+
expectedText
)
;
}
async
function
assertMarkupViewAsTree
(
tree
selector
inspector
)
{
const
{
markup
}
=
inspector
;
info
(
Find
and
expand
the
shadow
DOM
host
matching
selector
{
selector
}
.
)
;
const
rootFront
=
await
getNodeFront
(
selector
inspector
)
;
const
rootContainer
=
markup
.
getContainer
(
rootFront
)
;
const
parsedTree
=
_parseMarkupViewTree
(
tree
)
;
const
treeRoot
=
parsedTree
.
children
[
0
]
;
await
_checkMarkupViewNode
(
treeRoot
rootContainer
inspector
)
;
}
async
function
_checkMarkupViewNode
(
treeNode
container
inspector
)
{
const
{
node
children
path
}
=
treeNode
;
info
(
"
Checking
[
"
+
path
+
"
]
"
)
;
info
(
"
Checking
node
:
"
+
node
)
;
const
slotted
=
node
.
includes
(
"
!
slotted
"
)
;
if
(
slotted
)
{
const
nodeName
=
node
.
replace
(
"
!
slotted
"
"
"
)
;
assertContainerHasText
(
container
nodeName
)
;
assertContainerSlotted
(
container
)
;
}
else
{
assertContainerHasText
(
container
node
)
;
}
if
(
!
children
.
length
)
{
ok
(
!
container
.
canExpand
"
Container
for
[
"
+
path
+
"
]
has
no
children
"
)
;
return
;
}
if
(
!
container
.
expanded
)
{
await
expandContainer
(
inspector
container
)
;
}
const
containers
=
container
.
getChildContainers
(
)
;
is
(
containers
.
length
children
.
length
"
Node
[
"
+
path
+
"
]
has
the
expected
number
of
children
"
)
;
for
(
let
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
await
_checkMarkupViewNode
(
children
[
i
]
containers
[
i
]
inspector
)
;
}
}
function
_parseMarkupViewTree
(
inputString
)
{
const
tree
=
{
level
:
0
children
:
[
]
}
;
let
lines
=
inputString
.
split
(
"
\
n
"
)
;
lines
=
lines
.
filter
(
l
=
>
l
.
trim
(
)
)
;
let
currentNode
=
tree
;
for
(
const
line
of
lines
)
{
const
nodeString
=
line
.
trim
(
)
;
const
level
=
line
.
split
(
"
"
)
.
length
;
let
parent
;
if
(
level
>
currentNode
.
level
)
{
parent
=
currentNode
;
}
else
{
parent
=
currentNode
.
parent
;
for
(
let
i
=
0
;
i
<
currentNode
.
level
-
level
;
i
+
+
)
{
parent
=
parent
.
parent
;
}
}
const
node
=
{
node
:
nodeString
children
:
[
]
parent
level
path
:
parent
.
path
+
"
"
+
nodeString
}
;
parent
.
children
.
push
(
node
)
;
currentNode
=
node
;
}
return
tree
;
}
function
waitForMutation
(
inspector
type
)
{
return
waitForNMutations
(
inspector
type
1
)
;
}
function
waitForNMutations
(
inspector
type
count
)
{
info
(
Expecting
{
count
}
markupmutation
of
type
{
type
}
)
;
let
receivedMutations
=
0
;
return
new
Promise
(
resolve
=
>
{
inspector
.
on
(
"
markupmutation
"
function
onMutation
(
mutations
)
{
const
validMutations
=
mutations
.
filter
(
m
=
>
m
.
type
=
=
=
type
)
.
length
;
receivedMutations
=
receivedMutations
+
validMutations
;
if
(
receivedMutations
=
=
count
)
{
inspector
.
off
(
"
markupmutation
"
onMutation
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
async
function
clickOnRevealLink
(
inspector
container
)
{
const
onSelection
=
inspector
.
selection
.
once
(
"
new
-
node
-
front
"
)
;
const
revealLink
=
container
.
elt
.
querySelector
(
"
.
reveal
-
link
"
)
;
const
tagline
=
revealLink
.
closest
(
"
.
tag
-
line
"
)
;
const
win
=
inspector
.
markup
.
doc
.
defaultView
;
EventUtils
.
synthesizeMouseAtCenter
(
tagline
{
type
:
"
mouseover
"
}
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
revealLink
{
}
win
)
;
await
onSelection
;
}
