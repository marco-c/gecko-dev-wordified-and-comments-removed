var
LCS
=
function
(
A
B
equals
)
{
if
(
equals
=
=
=
undefined
)
equals
=
function
(
a
b
)
{
return
a
=
=
=
b
;
}
;
var
findMidSnake
=
function
(
startA
endA
startB
endB
)
{
var
N
=
endA
-
startA
+
1
;
var
M
=
endB
-
startB
+
1
;
var
Max
=
N
+
M
;
var
Delta
=
N
-
M
;
var
halfMaxCeil
=
(
Max
+
1
)
/
2
|
0
;
var
foundOverlap
=
false
;
var
overlap
=
null
;
var
V
=
{
}
;
var
U
=
{
}
;
V
[
1
]
=
0
;
U
[
Delta
-
1
]
=
N
;
for
(
var
D
=
0
;
D
<
=
halfMaxCeil
;
D
+
+
)
{
for
(
var
k
=
-
D
;
k
<
=
D
&
&
!
overlap
;
k
+
=
2
)
{
var
x
y
;
if
(
k
=
=
=
-
D
|
|
(
k
!
=
=
D
&
&
V
[
k
-
1
]
<
V
[
k
+
1
]
)
)
x
=
V
[
k
+
1
]
;
else
x
=
V
[
k
-
1
]
+
1
;
y
=
x
-
k
;
if
(
isNaN
(
y
)
|
|
x
>
N
|
|
y
>
M
)
continue
;
var
xx
=
x
;
while
(
x
<
N
&
&
y
<
M
&
&
equals
(
A
[
startA
+
x
]
B
[
startB
+
y
]
)
)
{
x
+
+
;
y
+
+
;
}
V
[
k
]
=
x
;
if
(
(
Delta
&
1
)
=
=
=
1
&
&
inRange
(
k
Delta
-
(
D
-
1
)
Delta
+
(
D
-
1
)
)
)
if
(
V
[
k
]
>
=
U
[
k
]
)
overlap
=
[
xx
x
]
.
map
(
toPoint
k
)
;
}
if
(
overlap
)
var
SES
=
D
*
2
-
1
;
for
(
var
k
=
-
D
;
k
<
=
D
&
&
!
overlap
;
k
+
=
2
)
{
var
K
=
k
+
Delta
;
var
x
y
;
if
(
k
=
=
=
D
|
|
(
k
!
=
=
-
D
&
&
U
[
K
-
1
]
<
U
[
K
+
1
]
)
)
x
=
U
[
K
-
1
]
;
else
x
=
U
[
K
+
1
]
-
1
;
y
=
x
-
K
;
if
(
isNaN
(
y
)
|
|
x
<
0
|
|
y
<
0
)
continue
;
var
xx
=
x
;
while
(
x
>
0
&
&
y
>
0
&
&
equals
(
A
[
startA
+
x
-
1
]
B
[
startB
+
y
-
1
]
)
)
{
x
-
-
;
y
-
-
;
}
U
[
K
]
=
x
;
if
(
Delta
%
2
=
=
=
0
&
&
inRange
(
K
-
D
D
)
)
if
(
U
[
K
]
<
=
V
[
K
]
)
overlap
=
[
x
xx
]
.
map
(
toPoint
K
)
;
}
if
(
overlap
)
{
SES
=
SES
|
|
D
*
2
;
for
(
var
i
=
0
;
i
<
2
;
i
+
+
)
for
(
var
j
=
0
;
j
<
2
;
j
+
+
)
overlap
[
i
]
[
j
]
+
=
[
startA
startB
]
[
j
]
-
i
;
return
overlap
.
concat
(
[
SES
(
Max
-
SES
)
/
2
]
)
;
}
}
}
;
var
lcsAtoms
=
[
]
;
var
lcs
=
function
(
startA
endA
startB
endB
)
{
var
N
=
endA
-
startA
+
1
;
var
M
=
endB
-
startB
+
1
;
if
(
N
>
0
&
&
M
>
0
)
{
var
middleSnake
=
findMidSnake
(
startA
endA
startB
endB
)
;
var
x
=
middleSnake
[
0
]
[
0
]
y
=
middleSnake
[
0
]
[
1
]
;
var
u
=
middleSnake
[
1
]
[
0
]
v
=
middleSnake
[
1
]
[
1
]
;
var
D
=
middleSnake
[
2
]
;
if
(
D
>
1
)
{
lcs
(
startA
x
-
1
startB
y
-
1
)
;
if
(
x
<
=
u
)
{
[
]
.
push
.
apply
(
lcsAtoms
A
.
slice
(
x
u
+
1
)
)
;
}
lcs
(
u
+
1
endA
v
+
1
endB
)
;
}
else
if
(
M
>
N
)
[
]
.
push
.
apply
(
lcsAtoms
A
.
slice
(
startA
endA
+
1
)
)
;
else
[
]
.
push
.
apply
(
lcsAtoms
B
.
slice
(
startB
endB
+
1
)
)
;
}
}
;
lcs
(
0
A
.
length
-
1
0
B
.
length
-
1
)
;
return
lcsAtoms
;
}
;
var
inRange
=
function
(
x
l
r
)
{
return
(
l
<
=
x
&
&
x
<
=
r
)
|
|
(
r
<
=
x
&
&
x
<
=
l
)
;
}
;
var
toPoint
=
function
(
x
)
{
return
[
x
x
-
this
]
;
}
;
LCS
.
StringLCS
=
function
(
A
B
)
{
return
LCS
(
A
.
split
(
'
'
)
B
.
split
(
'
'
)
)
.
join
(
'
'
)
;
}
;
function
diff
(
A
B
equals
)
{
if
(
equals
=
=
=
undefined
)
equals
=
function
(
a
b
)
{
return
a
=
=
=
b
;
}
;
var
diff
=
[
]
;
var
i
=
0
j
=
0
;
var
N
=
A
.
length
M
=
B
.
length
K
=
0
;
while
(
i
<
N
&
&
j
<
M
&
&
equals
(
A
[
i
]
B
[
j
]
)
)
i
+
+
j
+
+
;
while
(
i
<
N
&
&
j
<
M
&
&
equals
(
A
[
N
-
1
]
B
[
M
-
1
]
)
)
N
-
-
M
-
-
K
+
+
;
[
]
.
push
.
apply
(
diff
A
.
slice
(
0
i
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
none
"
atom
:
atom
}
;
}
)
)
;
var
lcs
=
LCS
(
A
.
slice
(
i
N
)
B
.
slice
(
j
M
)
equals
)
;
for
(
var
k
=
0
;
k
<
lcs
.
length
;
k
+
+
)
{
var
atom
=
lcs
[
k
]
;
var
ni
=
customIndexOf
.
call
(
A
atom
i
equals
)
;
var
nj
=
customIndexOf
.
call
(
B
atom
j
equals
)
;
[
]
.
push
.
apply
(
diff
A
.
slice
(
i
ni
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
delete
"
atom
:
atom
}
;
}
)
)
;
[
]
.
push
.
apply
(
diff
B
.
slice
(
j
nj
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
add
"
atom
:
atom
}
;
}
)
)
;
diff
.
push
(
{
operation
:
"
none
"
atom
:
atom
}
)
;
i
=
ni
+
1
;
j
=
nj
+
1
;
}
[
]
.
push
.
apply
(
diff
A
.
slice
(
i
N
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
delete
"
atom
:
atom
}
;
}
)
)
;
[
]
.
push
.
apply
(
diff
B
.
slice
(
j
M
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
add
"
atom
:
atom
}
;
}
)
)
;
[
]
.
push
.
apply
(
diff
A
.
slice
(
N
N
+
K
)
.
map
(
function
(
atom
)
{
return
{
operation
:
"
none
"
atom
:
atom
}
;
}
)
)
;
return
diff
;
}
;
var
customIndexOf
=
function
(
item
start
equals
)
{
var
arr
=
this
;
for
(
var
i
=
start
;
i
<
arr
.
length
;
i
+
+
)
if
(
equals
(
item
arr
[
i
]
)
)
return
i
;
return
-
1
;
}
;
function
textDiff
(
text1
text2
)
{
return
diff
(
text1
.
split
(
"
\
n
"
)
text2
.
split
(
"
\
n
"
)
)
;
}
