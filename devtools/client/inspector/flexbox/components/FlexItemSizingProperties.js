"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
getStr
}
=
require
(
"
devtools
/
client
/
inspector
/
layout
/
utils
/
l10n
"
)
;
const
Types
=
require
(
"
.
.
/
types
"
)
;
class
FlexItemSizingProperties
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
flexDirection
:
PropTypes
.
string
.
isRequired
flexItem
:
PropTypes
.
shape
(
Types
.
flexItem
)
.
isRequired
}
;
}
getRoundedDimension
(
value
)
{
if
(
value
=
=
0
)
{
return
"
0
"
;
}
return
(
Math
.
round
(
value
*
100
)
/
100
)
+
"
px
"
;
}
getFlexibilityValueString
(
grew
mainDeltaSize
)
{
const
value
=
this
.
getRoundedDimension
(
mainDeltaSize
)
;
if
(
grew
)
{
return
"
+
"
+
value
;
}
return
value
;
}
renderCssProperty
(
name
value
isDefaultValue
)
{
return
(
dom
.
span
(
{
className
:
"
css
-
property
-
link
"
}
dom
.
span
(
{
className
:
"
theme
-
fg
-
color5
"
}
name
)
"
:
"
dom
.
span
(
{
className
:
"
theme
-
fg
-
color1
"
}
value
)
"
;
"
)
)
;
}
renderReasons
(
sentences
)
{
return
(
dom
.
ul
(
{
className
:
"
reasons
"
}
sentences
.
map
(
sentence
=
>
dom
.
li
(
{
}
sentence
)
)
)
)
;
}
renderBaseSizeSection
(
{
mainBaseSize
mainMinSize
}
properties
dimension
)
{
const
flexBasisValue
=
properties
[
"
flex
-
basis
"
]
;
const
dimensionValue
=
properties
[
dimension
]
;
const
minDimensionValue
=
properties
[
min
-
{
dimension
}
]
;
const
hasMinClamping
=
mainMinSize
&
&
mainMinSize
=
=
=
mainBaseSize
;
let
property
=
null
;
let
reason
=
null
;
if
(
hasMinClamping
&
&
minDimensionValue
)
{
property
=
this
.
renderCssProperty
(
min
-
{
dimension
}
minDimensionValue
)
;
}
else
if
(
flexBasisValue
&
&
!
hasMinClamping
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
basis
"
flexBasisValue
)
;
}
else
if
(
dimensionValue
)
{
property
=
this
.
renderCssProperty
(
dimension
dimensionValue
)
;
}
else
{
reason
=
this
.
renderReasons
(
[
getStr
(
"
flexbox
.
itemSizing
.
itemBaseSizeFromContent
"
)
]
)
;
}
const
className
=
"
section
base
"
;
return
(
dom
.
li
(
{
className
:
className
+
(
property
?
"
"
:
"
no
-
property
"
)
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
baseSizeSectionHeader
"
)
)
dom
.
span
(
{
className
:
"
value
theme
-
fg
-
color1
"
}
this
.
getRoundedDimension
(
mainBaseSize
)
)
property
reason
)
)
;
}
renderFlexibilitySection
(
flexItemSizing
properties
)
{
const
{
mainDeltaSize
mainBaseSize
mainFinalSize
lineGrowthState
}
=
flexItemSizing
;
if
(
!
mainFinalSize
&
&
!
mainBaseSize
&
&
!
mainDeltaSize
)
{
return
null
;
}
const
flexGrow
=
properties
[
"
flex
-
grow
"
]
;
const
nonZeroFlexGrowDefined
=
flexGrow
&
&
parseFloat
(
flexGrow
)
!
=
=
0
;
const
flexShrink
=
properties
[
"
flex
-
shrink
"
]
;
const
flexShrink0
=
parseFloat
(
flexShrink
)
=
=
=
0
;
const
grew
=
mainDeltaSize
>
0
;
const
shrank
=
mainDeltaSize
<
0
;
const
wasClamped
=
mainDeltaSize
+
mainBaseSize
!
=
=
mainFinalSize
;
const
reasons
=
[
]
;
if
(
lineGrowthState
=
=
=
"
growing
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
extraRoomOnLine
"
)
)
;
}
else
if
(
lineGrowthState
=
=
=
"
shrinking
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
notEnoughRoomOnLine
"
)
)
;
}
if
(
nonZeroFlexGrowDefined
&
&
lineGrowthState
!
=
=
"
shrinking
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
setToGrow
"
)
)
;
}
if
(
flexShrink
&
&
!
flexShrink0
&
&
lineGrowthState
!
=
=
"
growing
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
setToShrink
"
)
)
;
}
if
(
!
nonZeroFlexGrowDefined
&
&
!
grew
&
&
!
shrank
&
&
lineGrowthState
=
=
=
"
growing
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
notSetToGrow
"
)
)
;
}
if
(
!
grew
&
&
!
shrank
&
&
lineGrowthState
=
=
=
"
shrinking
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
notSetToShrink
"
)
)
;
}
let
property
=
null
;
if
(
grew
)
{
if
(
flexGrow
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
grow
"
flexGrow
)
;
}
if
(
wasClamped
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
growthAttemptWhenClamped
"
)
)
;
}
}
else
if
(
shrank
)
{
if
(
flexShrink
&
&
!
flexShrink0
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
flexShrink
)
;
}
else
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
"
1
"
true
)
;
}
if
(
wasClamped
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
shrinkAttemptWhenClamped
"
)
)
;
}
}
else
if
(
lineGrowthState
=
=
=
"
growing
"
&
&
nonZeroFlexGrowDefined
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
grow
"
flexGrow
)
;
if
(
!
wasClamped
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
growthAttemptButSiblings
"
)
)
;
}
}
else
if
(
lineGrowthState
=
=
=
"
shrinking
"
)
{
if
(
!
flexShrink0
)
{
if
(
flexShrink
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
flexShrink
)
;
}
else
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
1
true
)
;
}
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
shrinkAttemptButCouldnt
"
)
)
;
if
(
wasClamped
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
shrinkAttemptWhenClamped
"
)
)
;
}
}
else
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
flexShrink
)
;
}
}
if
(
!
property
&
&
!
reasons
.
length
)
{
return
null
;
}
const
className
=
"
section
flexibility
"
;
return
(
dom
.
li
(
{
className
:
className
+
(
property
?
"
"
:
"
no
-
property
"
)
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
flexibilitySectionHeader
"
)
)
dom
.
span
(
{
className
:
"
value
theme
-
fg
-
color1
"
}
this
.
getFlexibilityValueString
(
grew
mainDeltaSize
)
)
property
this
.
renderReasons
(
reasons
)
)
)
;
}
renderMinimumSizeSection
(
{
mainMinSize
mainFinalSize
}
properties
dimension
)
{
const
minDimensionValue
=
properties
[
min
-
{
dimension
}
]
;
if
(
mainMinSize
!
=
=
mainFinalSize
|
|
!
minDimensionValue
)
{
return
null
;
}
return
(
dom
.
li
(
{
className
:
"
section
min
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
minSizeSectionHeader
"
)
)
dom
.
span
(
{
className
:
"
value
theme
-
fg
-
color1
"
}
this
.
getRoundedDimension
(
mainMinSize
)
)
this
.
renderCssProperty
(
min
-
{
dimension
}
minDimensionValue
)
)
)
;
}
renderMaximumSizeSection
(
{
mainMaxSize
mainFinalSize
}
properties
dimension
)
{
if
(
mainMaxSize
!
=
=
mainFinalSize
)
{
return
null
;
}
const
maxDimensionValue
=
properties
[
max
-
{
dimension
}
]
;
return
(
dom
.
li
(
{
className
:
"
section
max
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
maxSizeSectionHeader
"
)
)
dom
.
span
(
{
className
:
"
value
theme
-
fg
-
color1
"
}
this
.
getRoundedDimension
(
mainMaxSize
)
)
this
.
renderCssProperty
(
max
-
{
dimension
}
maxDimensionValue
)
)
)
;
}
renderFinalSizeSection
(
{
mainFinalSize
}
)
{
return
(
dom
.
li
(
{
className
:
"
section
final
no
-
property
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
finalSizeSectionHeader
"
)
)
dom
.
span
(
{
className
:
"
value
theme
-
fg
-
color1
"
}
this
.
getRoundedDimension
(
mainFinalSize
)
)
)
)
;
}
render
(
)
{
const
{
flexDirection
flexItem
}
=
this
.
props
;
const
{
flexItemSizing
properties
}
=
flexItem
;
const
{
mainBaseSize
mainDeltaSize
mainMaxSize
mainMinSize
}
=
flexItemSizing
;
const
dimension
=
flexDirection
.
startsWith
(
"
row
"
)
?
"
width
"
:
"
height
"
;
let
mainFinalSize
=
mainBaseSize
+
mainDeltaSize
;
mainFinalSize
=
Math
.
max
(
mainFinalSize
mainMinSize
)
;
mainFinalSize
=
Math
.
min
(
mainFinalSize
mainMaxSize
)
;
flexItemSizing
.
mainFinalSize
=
mainFinalSize
;
return
(
dom
.
ul
(
{
className
:
"
flex
-
item
-
sizing
"
}
this
.
renderBaseSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderFlexibilitySection
(
flexItemSizing
properties
)
this
.
renderMinimumSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderMaximumSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderFinalSizeSection
(
flexItemSizing
)
)
)
;
}
}
module
.
exports
=
FlexItemSizingProperties
;
