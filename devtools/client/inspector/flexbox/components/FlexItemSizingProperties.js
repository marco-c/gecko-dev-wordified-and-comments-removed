"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
getStr
}
=
require
(
"
devtools
/
client
/
inspector
/
layout
/
utils
/
l10n
"
)
;
const
Types
=
require
(
"
.
.
/
types
"
)
;
class
FlexItemSizingProperties
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
flexDirection
:
PropTypes
.
string
.
isRequired
flexItem
:
PropTypes
.
shape
(
Types
.
flexItem
)
.
isRequired
}
;
}
renderSize
(
value
prependPlusSign
)
{
if
(
value
=
=
0
)
{
return
dom
.
span
(
{
className
:
"
value
"
}
"
0
"
)
;
}
value
=
(
Math
.
round
(
value
*
100
)
/
100
)
;
if
(
prependPlusSign
&
&
value
>
0
)
{
value
=
"
+
"
+
value
;
}
return
(
dom
.
span
(
{
className
:
"
value
"
}
value
dom
.
span
(
{
className
:
"
unit
"
}
"
px
"
)
)
)
;
}
renderCssProperty
(
name
value
isDefaultValue
)
{
return
dom
.
span
(
{
className
:
"
css
-
property
-
link
"
}
(
{
name
}
:
{
value
}
)
)
;
}
renderReasons
(
sentences
)
{
return
(
dom
.
ul
(
{
className
:
"
reasons
"
}
sentences
.
map
(
sentence
=
>
dom
.
li
(
{
}
sentence
)
)
)
)
;
}
renderBaseSizeSection
(
{
mainBaseSize
clampState
}
properties
dimension
)
{
const
flexBasisValue
=
properties
[
"
flex
-
basis
"
]
;
const
dimensionValue
=
properties
[
dimension
]
;
let
property
=
null
;
let
reason
=
null
;
if
(
flexBasisValue
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
basis
"
flexBasisValue
)
;
}
else
if
(
dimensionValue
)
{
property
=
this
.
renderCssProperty
(
dimension
dimensionValue
)
;
}
else
{
reason
=
this
.
renderReasons
(
[
getStr
(
"
flexbox
.
itemSizing
.
itemBaseSizeFromContent
"
)
]
)
;
}
const
className
=
"
section
base
"
;
return
(
dom
.
li
(
{
className
:
className
+
(
property
?
"
"
:
"
no
-
property
"
)
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
baseSizeSectionHeader
"
)
property
)
this
.
renderSize
(
mainBaseSize
)
reason
)
)
;
}
renderFlexibilitySection
(
flexItemSizing
properties
computedStyle
)
{
const
{
mainDeltaSize
mainBaseSize
mainFinalSize
lineGrowthState
clampState
}
=
flexItemSizing
;
if
(
!
mainFinalSize
&
&
!
mainBaseSize
&
&
!
mainDeltaSize
)
{
return
null
;
}
const
grew
=
mainDeltaSize
>
0
;
const
shrank
=
mainDeltaSize
<
0
;
if
(
!
grew
&
&
!
shrank
)
{
return
null
;
}
const
definedFlexGrow
=
properties
[
"
flex
-
grow
"
]
;
const
computedFlexGrow
=
computedStyle
.
flexGrow
;
const
definedFlexShrink
=
properties
[
"
flex
-
shrink
"
]
;
const
computedFlexShrink
=
computedStyle
.
flexShrink
;
const
wasClamped
=
clampState
!
=
=
"
unclamped
"
;
const
reasons
=
[
]
;
if
(
computedFlexGrow
&
&
lineGrowthState
=
=
=
"
growing
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
setToGrow
"
)
)
;
}
if
(
computedFlexShrink
&
&
lineGrowthState
=
=
=
"
shrinking
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
setToShrink
"
)
)
;
}
if
(
!
computedFlexGrow
&
&
!
grew
&
&
!
shrank
&
&
lineGrowthState
=
=
=
"
growing
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
notSetToGrow
"
)
)
;
}
if
(
!
computedFlexShrink
&
&
!
grew
&
&
!
shrank
&
&
lineGrowthState
=
=
=
"
shrinking
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
notSetToShrink
"
)
)
;
}
let
property
=
null
;
if
(
grew
)
{
if
(
definedFlexGrow
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
grow
"
definedFlexGrow
)
;
}
if
(
wasClamped
&
&
clampState
=
=
=
"
clamped_to_max
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
growthAttemptButMaxClamped
"
)
)
;
}
else
if
(
wasClamped
&
&
clampState
=
=
=
"
clamped_to_min
"
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
growthAttemptButMinClamped
"
)
)
;
}
}
else
if
(
shrank
)
{
if
(
definedFlexShrink
&
&
computedFlexShrink
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
definedFlexShrink
)
;
}
else
if
(
computedFlexShrink
)
{
property
=
this
.
renderCssProperty
(
"
flex
-
shrink
"
computedFlexShrink
true
)
;
}
if
(
wasClamped
)
{
reasons
.
push
(
getStr
(
"
flexbox
.
itemSizing
.
shrinkAttemptWhenClamped
"
)
)
;
}
}
if
(
!
property
&
&
!
reasons
.
length
)
{
return
null
;
}
const
className
=
"
section
flexibility
"
;
return
(
dom
.
li
(
{
className
:
className
+
(
property
?
"
"
:
"
no
-
property
"
)
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
flexibilitySectionHeader
"
)
property
)
this
.
renderSize
(
mainDeltaSize
true
)
this
.
renderReasons
(
reasons
)
)
)
;
}
renderMinimumSizeSection
(
{
clampState
mainMinSize
}
properties
dimension
)
{
if
(
clampState
!
=
=
"
clamped_to_min
"
)
{
return
null
;
}
const
minDimensionValue
=
properties
[
min
-
{
dimension
}
]
;
return
(
dom
.
li
(
{
className
:
"
section
min
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
minSizeSectionHeader
"
)
this
.
renderCssProperty
(
min
-
{
dimension
}
minDimensionValue
)
)
this
.
renderSize
(
mainMinSize
)
)
)
;
}
renderMaximumSizeSection
(
{
clampState
mainMaxSize
}
properties
dimension
)
{
if
(
clampState
!
=
=
"
clamped_to_max
"
)
{
return
null
;
}
const
maxDimensionValue
=
properties
[
max
-
{
dimension
}
]
;
return
(
dom
.
li
(
{
className
:
"
section
max
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
maxSizeSectionHeader
"
)
this
.
renderCssProperty
(
max
-
{
dimension
}
maxDimensionValue
)
)
this
.
renderSize
(
mainMaxSize
)
)
)
;
}
renderFinalSizeSection
(
{
mainFinalSize
}
)
{
return
(
dom
.
li
(
{
className
:
"
section
final
no
-
property
"
}
dom
.
span
(
{
className
:
"
name
"
}
getStr
(
"
flexbox
.
itemSizing
.
finalSizeSectionHeader
"
)
)
this
.
renderSize
(
mainFinalSize
)
)
)
;
}
render
(
)
{
const
{
flexItem
}
=
this
.
props
;
const
{
computedStyle
flexItemSizing
properties
}
=
flexItem
;
const
{
mainAxisDirection
mainBaseSize
mainDeltaSize
mainMaxSize
mainMinSize
}
=
flexItemSizing
;
const
dimension
=
mainAxisDirection
.
startsWith
(
"
horizontal
"
)
?
"
width
"
:
"
height
"
;
let
mainFinalSize
=
mainBaseSize
+
mainDeltaSize
;
mainFinalSize
=
Math
.
max
(
mainFinalSize
mainMinSize
)
;
mainFinalSize
=
Math
.
min
(
mainFinalSize
mainMaxSize
)
;
flexItemSizing
.
mainFinalSize
=
mainFinalSize
;
return
(
dom
.
ul
(
{
className
:
"
flex
-
item
-
sizing
"
}
this
.
renderBaseSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderFlexibilitySection
(
flexItemSizing
properties
computedStyle
)
this
.
renderMinimumSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderMaximumSizeSection
(
flexItemSizing
properties
dimension
)
this
.
renderFinalSizeSection
(
flexItemSizing
)
)
)
;
}
}
module
.
exports
=
FlexItemSizingProperties
;
