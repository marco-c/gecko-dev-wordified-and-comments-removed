"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
Types
=
require
(
"
.
.
/
types
"
)
;
class
FlexItemSizingOutline
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
flexDirection
:
PropTypes
.
string
.
isRequired
flexItem
:
PropTypes
.
shape
(
Types
.
flexItem
)
.
isRequired
}
;
}
renderBasisOutline
(
mainBaseSize
)
{
return
dom
.
div
(
{
className
:
"
flex
-
outline
-
basis
"
+
(
!
mainBaseSize
?
"
zero
-
basis
"
:
"
"
)
}
)
;
}
renderDeltaOutline
(
mainDeltaSize
)
{
if
(
!
mainDeltaSize
)
{
return
null
;
}
return
dom
.
div
(
{
className
:
"
flex
-
outline
-
delta
"
}
)
;
}
renderFinalOutline
(
isClamped
)
{
return
dom
.
div
(
{
className
:
"
flex
-
outline
-
final
"
+
(
isClamped
?
"
clamped
"
:
"
"
)
}
)
;
}
renderPoint
(
className
label
=
className
)
{
return
dom
.
div
(
{
key
:
className
className
:
flex
-
outline
-
point
{
className
}
"
data
-
label
"
:
label
}
)
;
}
render
(
)
{
const
{
flexItemSizing
}
=
this
.
props
.
flexItem
;
const
{
mainAxisDirection
mainBaseSize
mainDeltaSize
mainMaxSize
mainMinSize
clampState
}
=
flexItemSizing
;
let
mainFinalSize
=
mainBaseSize
+
mainDeltaSize
;
mainFinalSize
=
Math
.
max
(
mainFinalSize
mainMinSize
)
;
mainFinalSize
=
mainMaxSize
=
=
=
null
?
mainFinalSize
:
Math
.
min
(
mainFinalSize
mainMaxSize
)
;
if
(
!
mainFinalSize
&
&
!
mainBaseSize
&
&
!
mainDeltaSize
)
{
return
null
;
}
const
showMax
=
clampState
=
=
=
"
clamped_to_max
"
;
const
showMin
=
clampState
=
=
=
"
clamped_to_min
"
;
let
sizes
=
[
{
name
:
"
basis
-
start
"
size
:
0
}
{
name
:
"
basis
-
end
"
size
:
mainBaseSize
}
{
name
:
"
final
-
start
"
size
:
0
}
{
name
:
"
final
-
end
"
size
:
mainFinalSize
}
]
;
if
(
mainDeltaSize
>
0
)
{
sizes
.
push
(
{
name
:
"
delta
-
start
"
size
:
mainBaseSize
}
)
;
sizes
.
push
(
{
name
:
"
delta
-
end
"
size
:
mainBaseSize
+
mainDeltaSize
}
)
;
}
else
{
sizes
.
push
(
{
name
:
"
delta
-
start
"
size
:
mainBaseSize
+
mainDeltaSize
}
)
;
sizes
.
push
(
{
name
:
"
delta
-
end
"
size
:
mainBaseSize
}
)
;
}
if
(
showMax
)
{
sizes
.
push
(
{
name
:
"
max
"
size
:
mainMaxSize
}
)
;
}
if
(
showMin
)
{
sizes
.
push
(
{
name
:
"
min
"
size
:
mainMinSize
}
)
;
}
sizes
=
sizes
.
sort
(
(
a
b
)
=
>
a
.
size
-
b
.
size
)
;
const
offsetBy
=
sizes
.
reduce
(
(
acc
curr
)
=
>
(
curr
.
size
<
acc
?
curr
.
size
:
acc
)
0
)
;
sizes
=
sizes
.
map
(
entry
=
>
(
{
size
:
entry
.
size
-
offsetBy
name
:
entry
.
name
}
)
)
;
let
gridTemplateColumns
=
"
[
"
;
let
accumulatedSize
=
0
;
for
(
const
{
name
size
}
of
sizes
)
{
const
breadth
=
Math
.
round
(
size
-
accumulatedSize
)
;
if
(
breadth
=
=
=
0
)
{
gridTemplateColumns
+
=
{
name
}
;
continue
;
}
gridTemplateColumns
+
=
]
{
breadth
}
fr
[
{
name
}
;
accumulatedSize
=
size
;
}
gridTemplateColumns
+
=
"
]
"
;
const
renderedBaseAndFinalPoints
=
[
]
;
if
(
mainFinalSize
=
=
=
mainBaseSize
)
{
renderedBaseAndFinalPoints
.
push
(
this
.
renderPoint
(
"
basisfinal
"
"
basis
/
final
"
)
)
;
}
else
{
renderedBaseAndFinalPoints
.
push
(
this
.
renderPoint
(
"
basis
"
)
)
;
renderedBaseAndFinalPoints
.
push
(
this
.
renderPoint
(
"
final
"
)
)
;
}
return
dom
.
div
(
{
className
:
"
flex
-
outline
-
container
"
}
dom
.
div
(
{
className
:
flex
-
outline
{
mainAxisDirection
}
+
(
mainDeltaSize
>
0
?
"
growing
"
:
"
shrinking
"
)
style
:
{
gridTemplateColumns
}
}
renderedBaseAndFinalPoints
showMin
?
this
.
renderPoint
(
"
min
"
)
:
null
showMax
?
this
.
renderPoint
(
"
max
"
)
:
null
this
.
renderBasisOutline
(
mainBaseSize
)
this
.
renderDeltaOutline
(
mainDeltaSize
)
this
.
renderFinalOutline
(
clampState
!
=
=
"
unclamped
"
)
)
)
;
}
}
module
.
exports
=
FlexItemSizingOutline
;
