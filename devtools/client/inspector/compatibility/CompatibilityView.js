"
use
strict
"
;
const
{
createFactory
createElement
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
FluentReact
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
fluent
-
react
"
)
;
const
LocalizationProvider
=
createFactory
(
FluentReact
.
LocalizationProvider
)
;
const
compatibilityReducer
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
reducers
/
compatibility
"
)
;
const
{
initUserSettings
updateNodes
updateSelectedNode
updateTopLevelTarget
}
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
actions
/
compatibility
"
)
;
const
CompatibilityApp
=
createFactory
(
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
components
/
CompatibilityApp
"
)
)
;
class
CompatibilityView
{
constructor
(
inspector
window
)
{
this
.
inspector
=
inspector
;
this
.
inspector
.
store
.
injectReducer
(
"
compatibility
"
compatibilityReducer
)
;
this
.
_parseMarkup
=
this
.
_parseMarkup
.
bind
(
this
)
;
this
.
_onChangeAdded
=
this
.
_onChangeAdded
.
bind
(
this
)
;
this
.
_onPanelSelected
=
this
.
_onPanelSelected
.
bind
(
this
)
;
this
.
_onSelectedNodeChanged
=
this
.
_onSelectedNodeChanged
.
bind
(
this
)
;
this
.
_onTopLevelTargetChanged
=
this
.
_onTopLevelTargetChanged
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_init
(
)
;
}
destroy
(
)
{
try
{
this
.
resourceWatcher
.
unwatchResources
(
[
this
.
resourceWatcher
.
TYPES
.
CSS_CHANGE
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
}
catch
(
e
)
{
}
this
.
inspector
.
off
(
"
new
-
root
"
this
.
_onTopLevelTargetChanged
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
_onSelectedNodeChanged
)
;
this
.
inspector
.
sidebar
.
off
(
"
compatibilityview
-
selected
"
this
.
_onPanelSelected
)
;
this
.
inspector
=
null
;
}
get
resourceWatcher
(
)
{
return
this
.
inspector
.
toolbox
.
resourceWatcher
;
}
_init
(
)
{
const
{
onShowBoxModelHighlighterForNode
:
showBoxModelHighlighterForNode
setSelectedNode
}
=
this
.
inspector
.
getCommonComponentProps
(
)
;
const
{
onHideBoxModelHighlighter
:
hideBoxModelHighlighter
}
=
this
.
inspector
.
getPanel
(
"
boxmodel
"
)
.
getComponentProps
(
)
;
const
compatibilityApp
=
new
CompatibilityApp
(
{
hideBoxModelHighlighter
showBoxModelHighlighterForNode
setSelectedNode
}
)
;
this
.
provider
=
createElement
(
Provider
{
id
:
"
compatibilityview
"
store
:
this
.
inspector
.
store
}
LocalizationProvider
(
{
bundles
:
this
.
inspector
.
fluentL10n
.
getBundles
(
)
parseMarkup
:
this
.
_parseMarkup
}
compatibilityApp
)
)
;
this
.
inspector
.
store
.
dispatch
(
initUserSettings
(
)
)
;
this
.
inspector
.
on
(
"
new
-
root
"
this
.
_onTopLevelTargetChanged
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
_onSelectedNodeChanged
)
;
this
.
inspector
.
sidebar
.
on
(
"
compatibilityview
-
selected
"
this
.
_onPanelSelected
)
;
this
.
resourceWatcher
.
watchResources
(
[
this
.
resourceWatcher
.
TYPES
.
CSS_CHANGE
]
{
onAvailable
:
this
.
_onResourceAvailable
ignoreExistingResources
:
true
}
)
;
}
_isAvailable
(
)
{
return
(
this
.
inspector
&
&
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
=
"
compatibilityview
"
&
&
this
.
inspector
.
selection
&
&
this
.
inspector
.
selection
.
isConnected
(
)
)
;
}
_parseMarkup
(
str
)
{
throw
new
Error
(
"
The
inspector
cannot
use
tags
in
ftl
strings
because
it
does
not
run
in
a
BrowserLoader
"
)
;
}
_onChangeAdded
(
{
selector
}
)
{
if
(
!
this
.
_isAvailable
(
)
)
{
this
.
_isChangeAddedWhileHidden
=
true
;
return
;
}
this
.
_isChangeAddedWhileHidden
=
false
;
if
(
this
.
_previousChangedSelector
=
=
=
selector
)
{
clearTimeout
(
this
.
_updateNodesTimeoutId
)
;
}
this
.
_previousChangedSelector
=
selector
;
this
.
_updateNodesTimeoutId
=
setTimeout
(
(
)
=
>
{
this
.
inspector
.
store
.
dispatch
(
updateNodes
(
selector
)
)
;
}
500
)
;
}
_onPanelSelected
(
)
{
const
{
selectedNode
topLevelTarget
}
=
this
.
inspector
.
store
.
getState
(
)
.
compatibility
;
if
(
this
.
inspector
.
selection
.
nodeFront
!
=
=
selectedNode
|
|
this
.
_isChangeAddedWhileHidden
)
{
this
.
_onSelectedNodeChanged
(
)
;
}
if
(
this
.
inspector
.
toolbox
.
target
!
=
=
topLevelTarget
|
|
this
.
_isChangeAddedWhileHidden
)
{
this
.
_onTopLevelTargetChanged
(
)
;
}
this
.
_isChangeAddedWhileHidden
=
false
;
}
_onSelectedNodeChanged
(
)
{
if
(
!
this
.
_isAvailable
(
)
)
{
return
;
}
this
.
inspector
.
store
.
dispatch
(
updateSelectedNode
(
this
.
inspector
.
selection
.
nodeFront
)
)
;
}
_onResourceAvailable
(
{
resource
}
)
{
this
.
_onChangeAdded
(
resource
)
;
}
_onTopLevelTargetChanged
(
)
{
if
(
!
this
.
_isAvailable
(
)
)
{
return
;
}
this
.
inspector
.
store
.
dispatch
(
updateTopLevelTarget
(
this
.
inspector
.
toolbox
.
target
)
)
;
}
}
module
.
exports
=
CompatibilityView
;
