"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
{
COMPATIBILITY_UPDATE_SELECTED_NODE_COMPLETE
COMPATIBILITY_UPDATE_TOP_LEVEL_TARGET_COMPLETE
}
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
actions
/
index
"
)
;
const
{
toCamelCase
}
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
utils
/
cases
"
)
;
async
function
openCompatibilityView
(
)
{
info
(
"
Open
the
compatibility
view
"
)
;
await
pushPref
(
"
devtools
.
inspector
.
compatibility
.
enabled
"
true
)
;
const
{
inspector
}
=
await
openInspectorSidebarTab
(
"
compatibilityview
"
)
;
await
Promise
.
all
(
[
waitForUpdateSelectedNodeAction
(
inspector
.
store
)
waitForUpdateTopLevelTargetAction
(
inspector
.
store
)
]
)
;
const
panel
=
inspector
.
panelDoc
.
querySelector
(
"
#
compatibilityview
-
panel
.
inspector
-
tabpanel
"
)
;
const
selectedElementPane
=
panel
.
querySelector
(
"
#
compatibility
-
app
-
-
selected
-
element
-
pane
"
)
;
const
allElementsPane
=
panel
.
querySelector
(
"
#
compatibility
-
app
-
-
all
-
elements
-
pane
"
)
;
return
{
allElementsPane
inspector
panel
selectedElementPane
}
;
}
async
function
assertIssueList
(
panel
expectedIssues
)
{
info
(
"
Check
the
number
of
issues
"
)
;
await
waitUntil
(
(
)
=
>
panel
.
querySelectorAll
(
"
[
data
-
qa
-
property
]
"
)
.
length
=
=
=
expectedIssues
.
length
)
;
ok
(
true
"
The
number
of
issues
is
correct
"
)
;
if
(
expectedIssues
.
length
=
=
=
0
)
{
return
;
}
for
(
const
expectedIssue
of
expectedIssues
)
{
const
property
=
expectedIssue
.
property
;
info
(
Check
an
element
for
{
property
}
)
;
const
issueEl
=
getIssueItem
(
property
panel
)
;
ok
(
issueEl
Issue
element
for
the
{
property
}
is
in
the
panel
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
expectedIssue
)
)
{
const
datasetKey
=
toCamelCase
(
qa
-
{
key
}
)
;
is
(
issueEl
.
dataset
[
datasetKey
]
JSON
.
stringify
(
value
)
The
value
of
{
datasetKey
}
is
correct
)
;
}
}
}
async
function
assertNodeList
(
panel
expectedNodes
)
{
for
(
const
{
property
nodes
}
of
expectedNodes
)
{
info
(
Check
nodes
for
{
property
}
)
;
const
issueEl
=
getIssueItem
(
property
panel
)
;
await
waitUntil
(
(
)
=
>
issueEl
.
querySelectorAll
(
"
.
compatibility
-
node
-
item
"
)
.
length
=
=
=
nodes
.
length
)
;
ok
(
true
"
The
number
of
nodes
is
correct
"
)
;
const
nodeEls
=
[
.
.
.
issueEl
.
querySelectorAll
(
"
.
compatibility
-
node
-
item
"
)
]
;
for
(
const
node
of
nodes
)
{
const
nodeEl
=
nodeEls
.
find
(
el
=
>
el
.
textContent
=
=
=
node
)
;
ok
(
nodeEl
"
The
text
content
of
the
node
element
is
correct
"
)
;
}
}
}
function
getIssueItem
(
property
element
)
{
return
element
.
querySelector
(
[
data
-
qa
-
property
=
\
"
\
\
"
{
property
}
\
\
"
\
"
]
)
;
}
async
function
togglePropStatusOnRuleView
(
inspector
ruleIndex
propIndex
)
{
const
ruleView
=
inspector
.
getPanel
(
"
ruleview
"
)
.
view
;
const
rule
=
getRuleViewRuleEditor
(
ruleView
ruleIndex
)
.
rule
;
const
onMutation
=
ruleIndex
=
=
=
0
?
inspector
.
once
(
"
markupmutation
"
)
:
Promise
.
resolve
(
)
;
const
textProp
=
rule
.
textProps
[
propIndex
]
;
const
onRuleviewChanged
=
ruleView
.
once
(
"
ruleview
-
changed
"
)
;
textProp
.
editor
.
enable
.
click
(
)
;
await
Promise
.
all
(
[
onRuleviewChanged
onMutation
]
)
;
}
function
waitForUpdateSelectedNodeAction
(
store
)
{
return
waitForDispatch
(
store
COMPATIBILITY_UPDATE_SELECTED_NODE_COMPLETE
)
;
}
function
waitForUpdateTopLevelTargetAction
(
store
)
{
return
waitForDispatch
(
store
COMPATIBILITY_UPDATE_TOP_LEVEL_TARGET_COMPLETE
)
;
}
function
waitForDispatch
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
action
.
type
=
=
=
type
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
