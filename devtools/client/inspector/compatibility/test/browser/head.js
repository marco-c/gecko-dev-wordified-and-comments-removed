"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
{
COMPATIBILITY_UPDATE_SELECTED_NODE_COMPLETE
COMPATIBILITY_UPDATE_TOP_LEVEL_TARGET_COMPLETE
}
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
actions
/
index
"
)
;
const
{
toCamelCase
}
=
require
(
"
devtools
/
client
/
inspector
/
compatibility
/
utils
/
cases
"
)
;
async
function
openCompatibilityView
(
)
{
info
(
"
Open
the
compatibility
view
"
)
;
await
pushPref
(
"
devtools
.
inspector
.
compatibility
.
enabled
"
true
)
;
const
{
inspector
}
=
await
openInspectorSidebarTab
(
"
compatibilityview
"
)
;
await
Promise
.
all
(
[
waitForUpdateSelectedNodeAction
(
inspector
.
store
)
waitForUpdateTopLevelTargetAction
(
inspector
.
store
)
]
)
;
const
panel
=
inspector
.
panelDoc
.
querySelector
(
"
#
compatibilityview
-
panel
.
inspector
-
tabpanel
"
)
;
const
selectedElementPane
=
panel
.
querySelector
(
"
#
compatibility
-
app
-
-
selected
-
element
-
pane
"
)
;
const
allElementsPane
=
panel
.
querySelector
(
"
#
compatibility
-
app
-
-
all
-
elements
-
pane
"
)
;
return
{
allElementsPane
inspector
panel
selectedElementPane
}
;
}
async
function
assertIssueList
(
panel
expectedIssues
)
{
info
(
"
Check
the
number
of
issues
"
)
;
await
waitUntil
(
(
)
=
>
panel
.
querySelectorAll
(
"
[
data
-
qa
-
property
]
"
)
.
length
=
=
=
expectedIssues
.
length
)
;
ok
(
true
"
The
number
of
issues
is
correct
"
)
;
if
(
expectedIssues
.
length
=
=
=
0
)
{
return
;
}
const
issueEls
=
panel
.
querySelectorAll
(
"
[
data
-
qa
-
property
]
"
)
;
for
(
let
i
=
0
;
i
<
expectedIssues
.
length
;
i
+
+
)
{
info
(
Check
an
element
at
index
[
{
i
}
]
)
;
const
issueEl
=
issueEls
[
i
]
;
const
expectedIssue
=
expectedIssues
[
i
]
;
for
(
const
[
key
value
]
of
Object
.
entries
(
expectedIssue
)
)
{
const
datasetKey
=
toCamelCase
(
qa
-
{
key
}
)
;
is
(
issueEl
.
dataset
[
datasetKey
]
JSON
.
stringify
(
value
)
The
value
of
{
datasetKey
}
is
correct
)
;
}
}
}
function
waitForUpdateSelectedNodeAction
(
store
)
{
return
waitForDispatch
(
store
COMPATIBILITY_UPDATE_SELECTED_NODE_COMPLETE
)
;
}
function
waitForUpdateTopLevelTargetAction
(
store
)
{
return
waitForDispatch
(
store
COMPATIBILITY_UPDATE_TOP_LEVEL_TARGET_COMPLETE
)
;
}
function
waitForDispatch
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
action
.
type
=
=
=
type
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
