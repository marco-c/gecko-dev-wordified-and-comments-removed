"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
InplaceEditor
editableItem
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
ReflowFront
}
=
require
(
"
devtools
/
server
/
actors
/
layout
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
shared
.
properties
"
;
const
SHARED_L10N
=
new
ViewHelpers
.
L10N
(
STRINGS_URI
)
;
const
NUMERIC
=
/
^
-
?
[
\
d
\
.
]
+
/
;
const
LONG_TEXT_ROTATE_LIMIT
=
3
;
function
EditingSession
(
doc
rules
)
{
this
.
_doc
=
doc
;
this
.
_rules
=
rules
;
this
.
_modifications
=
new
Map
(
)
;
}
EditingSession
.
prototype
=
{
getPropertyFromRule
:
function
(
rule
property
)
{
let
dummyStyle
=
this
.
_element
.
style
;
dummyStyle
.
cssText
=
rule
.
cssText
;
return
dummyStyle
.
getPropertyValue
(
property
)
;
}
getProperty
:
function
(
property
)
{
let
div
=
this
.
_doc
.
createElement
(
"
div
"
)
;
div
.
setAttribute
(
"
style
"
"
display
:
none
"
)
;
this
.
_doc
.
getElementById
(
"
sidebar
-
panel
-
layoutview
"
)
.
appendChild
(
div
)
;
this
.
_element
=
this
.
_doc
.
createElement
(
"
p
"
)
;
div
.
appendChild
(
this
.
_element
)
;
for
(
let
rule
of
this
.
_rules
)
{
let
value
=
this
.
getPropertyFromRule
(
rule
property
)
;
if
(
value
!
=
=
"
"
)
{
div
.
remove
(
)
;
return
value
;
}
}
div
.
remove
(
)
;
return
"
"
;
}
setProperties
:
function
(
properties
)
{
let
modifications
=
this
.
_rules
[
0
]
.
startModifyingProperties
(
)
;
for
(
let
property
of
properties
)
{
if
(
!
this
.
_modifications
.
has
(
property
.
name
)
)
{
this
.
_modifications
.
set
(
property
.
name
this
.
getPropertyFromRule
(
this
.
_rules
[
0
]
property
.
name
)
)
;
}
if
(
property
.
value
=
=
"
"
)
{
modifications
.
removeProperty
(
-
1
property
.
name
)
;
}
else
{
modifications
.
setProperty
(
-
1
property
.
name
property
.
value
"
"
)
;
}
}
return
modifications
.
apply
(
)
.
then
(
null
console
.
error
)
;
}
revert
:
function
(
)
{
let
modifications
=
this
.
_rules
[
0
]
.
startModifyingProperties
(
)
;
for
(
let
[
property
value
]
of
this
.
_modifications
)
{
if
(
value
!
=
"
"
)
{
modifications
.
setProperty
(
-
1
property
value
"
"
)
;
}
else
{
modifications
.
removeProperty
(
-
1
property
)
;
}
}
return
modifications
.
apply
(
)
.
then
(
null
console
.
error
)
;
}
destroy
:
function
(
)
{
this
.
_doc
=
null
;
this
.
_rules
=
null
;
this
.
_modifications
.
clear
(
)
;
}
}
;
function
LayoutView
(
inspector
win
)
{
this
.
inspector
=
inspector
;
this
.
doc
=
win
.
document
;
this
.
sizeLabel
=
this
.
doc
.
querySelector
(
"
.
layout
-
size
>
span
"
)
;
this
.
sizeHeadingLabel
=
this
.
doc
.
getElementById
(
"
layout
-
element
-
size
"
)
;
this
.
init
(
)
;
}
LayoutView
.
prototype
=
{
init
:
function
(
)
{
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
onNewNode
=
this
.
onNewNode
.
bind
(
this
)
;
this
.
inspector
.
sidebar
.
on
(
"
layoutview
-
selected
"
this
.
onNewNode
)
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
inspector
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
initBoxModelHighlighter
(
)
;
this
.
map
=
{
position
:
{
selector
:
"
#
layout
-
element
-
position
"
property
:
"
position
"
value
:
undefined
}
marginTop
:
{
selector
:
"
.
layout
-
margin
.
layout
-
top
>
span
"
property
:
"
margin
-
top
"
value
:
undefined
}
marginBottom
:
{
selector
:
"
.
layout
-
margin
.
layout
-
bottom
>
span
"
property
:
"
margin
-
bottom
"
value
:
undefined
}
marginLeft
:
{
selector
:
"
.
layout
-
margin
.
layout
-
left
>
span
"
property
:
"
margin
-
left
"
value
:
undefined
}
marginRight
:
{
selector
:
"
.
layout
-
margin
.
layout
-
right
>
span
"
property
:
"
margin
-
right
"
value
:
undefined
}
paddingTop
:
{
selector
:
"
.
layout
-
padding
.
layout
-
top
>
span
"
property
:
"
padding
-
top
"
value
:
undefined
}
paddingBottom
:
{
selector
:
"
.
layout
-
padding
.
layout
-
bottom
>
span
"
property
:
"
padding
-
bottom
"
value
:
undefined
}
paddingLeft
:
{
selector
:
"
.
layout
-
padding
.
layout
-
left
>
span
"
property
:
"
padding
-
left
"
value
:
undefined
}
paddingRight
:
{
selector
:
"
.
layout
-
padding
.
layout
-
right
>
span
"
property
:
"
padding
-
right
"
value
:
undefined
}
borderTop
:
{
selector
:
"
.
layout
-
border
.
layout
-
top
>
span
"
property
:
"
border
-
top
-
width
"
value
:
undefined
}
borderBottom
:
{
selector
:
"
.
layout
-
border
.
layout
-
bottom
>
span
"
property
:
"
border
-
bottom
-
width
"
value
:
undefined
}
borderLeft
:
{
selector
:
"
.
layout
-
border
.
layout
-
left
>
span
"
property
:
"
border
-
left
-
width
"
value
:
undefined
}
borderRight
:
{
selector
:
"
.
layout
-
border
.
layout
-
right
>
span
"
property
:
"
border
-
right
-
width
"
value
:
undefined
}
}
;
for
(
let
i
in
this
.
map
)
{
if
(
i
=
=
"
position
"
)
{
continue
;
}
let
dimension
=
this
.
map
[
i
]
;
editableItem
(
{
element
:
this
.
doc
.
querySelector
(
dimension
.
selector
)
}
(
element
event
)
=
>
{
this
.
initEditor
(
element
event
dimension
)
;
}
)
;
}
this
.
onNewNode
(
)
;
let
chromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
let
dir
=
chromeReg
.
isLocaleRTL
(
"
global
"
)
;
let
container
=
this
.
doc
.
getElementById
(
"
layout
-
container
"
)
;
container
.
setAttribute
(
"
dir
"
dir
?
"
rtl
"
:
"
ltr
"
)
;
}
initBoxModelHighlighter
:
function
(
)
{
let
highlightElts
=
this
.
doc
.
querySelectorAll
(
"
#
layout
-
container
*
[
title
]
"
)
;
this
.
onHighlightMouseOver
=
this
.
onHighlightMouseOver
.
bind
(
this
)
;
this
.
onHighlightMouseOut
=
this
.
onHighlightMouseOut
.
bind
(
this
)
;
for
(
let
element
of
highlightElts
)
{
element
.
addEventListener
(
"
mouseover
"
this
.
onHighlightMouseOver
true
)
;
element
.
addEventListener
(
"
mouseout
"
this
.
onHighlightMouseOut
true
)
;
}
}
trackReflows
:
function
(
)
{
if
(
!
this
.
reflowFront
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
if
(
toolbox
.
target
.
form
.
reflowActor
)
{
this
.
reflowFront
=
ReflowFront
(
toolbox
.
target
.
client
toolbox
.
target
.
form
)
;
}
else
{
return
;
}
}
this
.
reflowFront
.
on
(
"
reflows
"
this
.
update
)
;
this
.
reflowFront
.
start
(
)
;
}
untrackReflows
:
function
(
)
{
if
(
!
this
.
reflowFront
)
{
return
;
}
this
.
reflowFront
.
off
(
"
reflows
"
this
.
update
)
;
this
.
reflowFront
.
stop
(
)
;
}
initEditor
:
function
(
element
event
dimension
)
{
let
{
property
}
=
dimension
;
let
session
=
new
EditingSession
(
this
.
doc
this
.
elementRules
)
;
let
initialValue
=
session
.
getProperty
(
property
)
;
let
editor
=
new
InplaceEditor
(
{
element
:
element
initial
:
initialValue
start
:
editor
=
>
{
editor
.
elt
.
parentNode
.
classList
.
add
(
"
layout
-
editing
"
)
;
}
change
:
value
=
>
{
if
(
NUMERIC
.
test
(
value
)
)
{
value
+
=
"
px
"
;
}
let
properties
=
[
{
name
:
property
value
:
value
}
]
;
if
(
property
.
substring
(
0
7
)
=
=
"
border
-
"
)
{
let
bprop
=
property
.
substring
(
0
property
.
length
-
5
)
+
"
style
"
;
let
style
=
session
.
getProperty
(
bprop
)
;
if
(
!
style
|
|
style
=
=
"
none
"
|
|
style
=
=
"
hidden
"
)
{
properties
.
push
(
{
name
:
bprop
value
:
"
solid
"
}
)
;
}
}
session
.
setProperties
(
properties
)
;
}
done
:
(
value
commit
)
=
>
{
editor
.
elt
.
parentNode
.
classList
.
remove
(
"
layout
-
editing
"
)
;
if
(
!
commit
)
{
session
.
revert
(
)
;
session
.
destroy
(
)
;
}
}
}
event
)
;
}
isViewVisible
:
function
(
)
{
return
this
.
inspector
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
"
layoutview
"
;
}
isViewVisibleAndNodeValid
:
function
(
)
{
return
this
.
isViewVisible
(
)
&
&
this
.
inspector
.
selection
.
isConnected
(
)
&
&
this
.
inspector
.
selection
.
isElementNode
(
)
;
}
destroy
:
function
(
)
{
let
highlightElts
=
this
.
doc
.
querySelectorAll
(
"
#
layout
-
container
*
[
title
]
"
)
;
for
(
let
element
of
highlightElts
)
{
element
.
removeEventListener
(
"
mouseover
"
this
.
onHighlightMouseOver
true
)
;
element
.
removeEventListener
(
"
mouseout
"
this
.
onHighlightMouseOut
true
)
;
}
this
.
inspector
.
sidebar
.
off
(
"
layoutview
-
selected
"
this
.
onNewNode
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
inspector
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelect
)
;
this
.
sizeHeadingLabel
=
null
;
this
.
sizeLabel
=
null
;
this
.
inspector
=
null
;
this
.
doc
=
null
;
if
(
this
.
reflowFront
)
{
this
.
untrackReflows
(
)
;
this
.
reflowFront
.
destroy
(
)
;
this
.
reflowFront
=
null
;
}
}
onSidebarSelect
:
function
(
e
sidebar
)
{
this
.
setActive
(
sidebar
=
=
=
"
layoutview
"
)
;
}
onNewSelection
:
function
(
)
{
let
done
=
this
.
inspector
.
updating
(
"
layoutview
"
)
;
this
.
onNewNode
(
)
.
then
(
done
err
=
>
{
console
.
error
(
err
)
;
done
(
)
;
}
)
;
}
onNewNode
:
function
(
)
{
this
.
setActive
(
this
.
isViewVisibleAndNodeValid
(
)
)
;
return
this
.
update
(
)
;
}
onHighlightMouseOver
:
function
(
e
)
{
let
region
=
e
.
target
.
getAttribute
(
"
data
-
box
"
)
;
if
(
!
region
)
{
return
;
}
this
.
showBoxModel
(
{
region
showOnly
:
region
onlyRegionArea
:
true
}
)
;
}
onHighlightMouseOut
:
function
(
)
{
this
.
hideBoxModel
(
)
;
}
setActive
:
function
(
isActive
)
{
if
(
isActive
=
=
=
this
.
isActive
)
{
return
;
}
this
.
isActive
=
isActive
;
let
panel
=
this
.
doc
.
getElementById
(
"
sidebar
-
panel
-
layoutview
"
)
;
panel
.
classList
.
toggle
(
"
inactive
"
!
isActive
)
;
if
(
isActive
)
{
this
.
trackReflows
(
)
;
}
else
{
this
.
untrackReflows
(
)
;
}
}
update
:
function
(
)
{
let
lastRequest
=
Task
.
spawn
(
(
function
*
(
)
{
if
(
!
this
.
isViewVisibleAndNodeValid
(
)
)
{
return
;
}
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
layout
=
yield
this
.
inspector
.
pageStyle
.
getLayout
(
node
{
autoMargins
:
this
.
isActive
}
)
;
let
styleEntries
=
yield
this
.
inspector
.
pageStyle
.
getApplied
(
node
{
}
)
;
if
(
this
.
_lastRequest
!
=
lastRequest
)
{
return
this
.
_lastRequest
;
}
this
.
_lastRequest
=
null
;
let
width
=
layout
.
width
;
let
height
=
layout
.
height
;
let
newLabel
=
SHARED_L10N
.
getFormatStr
(
"
dimensions
"
width
height
)
;
if
(
this
.
sizeHeadingLabel
.
textContent
!
=
newLabel
)
{
this
.
sizeHeadingLabel
.
textContent
=
newLabel
;
}
if
(
!
this
.
isActive
)
{
this
.
inspector
.
emit
(
"
layoutview
-
updated
"
)
;
return
null
;
}
for
(
let
i
in
this
.
map
)
{
let
property
=
this
.
map
[
i
]
.
property
;
if
(
!
(
property
in
layout
)
)
{
continue
;
}
let
parsedValue
=
parseFloat
(
layout
[
property
]
)
;
if
(
Number
.
isNaN
(
parsedValue
)
)
{
this
.
map
[
i
]
.
value
=
layout
[
property
]
;
}
else
{
this
.
map
[
i
]
.
value
=
parsedValue
;
}
}
let
margins
=
layout
.
autoMargins
;
if
(
"
top
"
in
margins
)
{
this
.
map
.
marginTop
.
value
=
"
auto
"
;
}
if
(
"
right
"
in
margins
)
{
this
.
map
.
marginRight
.
value
=
"
auto
"
;
}
if
(
"
bottom
"
in
margins
)
{
this
.
map
.
marginBottom
.
value
=
"
auto
"
;
}
if
(
"
left
"
in
margins
)
{
this
.
map
.
marginLeft
.
value
=
"
auto
"
;
}
for
(
let
i
in
this
.
map
)
{
let
selector
=
this
.
map
[
i
]
.
selector
;
let
span
=
this
.
doc
.
querySelector
(
selector
)
;
this
.
updateSourceRuleTooltip
(
span
this
.
map
[
i
]
.
property
styleEntries
)
;
if
(
span
.
textContent
.
length
>
0
&
&
span
.
textContent
=
=
this
.
map
[
i
]
.
value
)
{
continue
;
}
span
.
textContent
=
this
.
map
[
i
]
.
value
;
this
.
manageOverflowingText
(
span
)
;
}
width
-
=
this
.
map
.
borderLeft
.
value
+
this
.
map
.
borderRight
.
value
+
this
.
map
.
paddingLeft
.
value
+
this
.
map
.
paddingRight
.
value
;
width
=
parseFloat
(
width
.
toPrecision
(
6
)
)
;
height
-
=
this
.
map
.
borderTop
.
value
+
this
.
map
.
borderBottom
.
value
+
this
.
map
.
paddingTop
.
value
+
this
.
map
.
paddingBottom
.
value
;
height
=
parseFloat
(
height
.
toPrecision
(
6
)
)
;
let
newValue
=
width
+
"
\
u00D7
"
+
height
;
if
(
this
.
sizeLabel
.
textContent
!
=
newValue
)
{
this
.
sizeLabel
.
textContent
=
newValue
;
}
this
.
elementRules
=
styleEntries
.
map
(
e
=
>
e
.
rule
)
;
this
.
inspector
.
emit
(
"
layoutview
-
updated
"
)
;
}
)
.
bind
(
this
)
)
.
then
(
null
console
.
error
)
;
return
this
.
_lastRequest
=
lastRequest
;
}
updateSourceRuleTooltip
:
function
(
el
property
rules
)
{
let
dummyEl
=
this
.
doc
.
createElement
(
"
div
"
)
;
let
sourceRule
value
;
for
(
let
{
rule
}
of
rules
)
{
dummyEl
.
style
.
cssText
=
rule
.
cssText
;
value
=
dummyEl
.
style
.
getPropertyValue
(
property
)
;
if
(
value
!
=
=
"
"
)
{
sourceRule
=
rule
;
break
;
}
}
let
title
=
property
;
if
(
sourceRule
&
&
sourceRule
.
selectors
)
{
title
+
=
"
\
n
"
+
sourceRule
.
selectors
.
join
(
"
"
)
;
}
if
(
sourceRule
&
&
sourceRule
.
parentStyleSheet
)
{
title
+
=
"
\
n
"
+
sourceRule
.
parentStyleSheet
.
href
+
"
:
"
+
sourceRule
.
line
;
}
el
.
setAttribute
(
"
title
"
title
)
;
}
showBoxModel
:
function
(
options
=
{
}
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
let
nodeFront
=
this
.
inspector
.
selection
.
nodeFront
;
toolbox
.
highlighterUtils
.
highlightNodeFront
(
nodeFront
options
)
;
}
hideBoxModel
:
function
(
)
{
let
toolbox
=
this
.
inspector
.
toolbox
;
toolbox
.
highlighterUtils
.
unhighlight
(
)
;
}
manageOverflowingText
:
function
(
span
)
{
let
classList
=
span
.
parentNode
.
classList
;
if
(
classList
.
contains
(
"
layout
-
left
"
)
|
|
classList
.
contains
(
"
layout
-
right
"
)
)
{
let
force
=
span
.
textContent
.
length
>
LONG_TEXT_ROTATE_LIMIT
;
classList
.
toggle
(
"
layout
-
rotate
"
force
)
;
}
}
}
;
exports
.
LayoutView
=
LayoutView
;
