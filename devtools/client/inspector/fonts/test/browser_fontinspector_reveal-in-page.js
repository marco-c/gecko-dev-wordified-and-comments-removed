"
use
strict
"
;
const
TEST_URI
=
URL_ROOT
+
"
doc_browser_fontinspector
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
toolbox
.
footer
.
height
"
500
)
;
const
{
tab
view
}
=
await
openFontInspectorForURL
(
TEST_URI
)
;
const
viewDoc
=
view
.
document
;
const
fontEls
=
getUsedFontsEls
(
viewDoc
)
;
const
expectedSelectionChangeEvents
=
[
2
2
2
1
1
]
;
for
(
let
i
=
0
;
i
<
fontEls
.
length
;
i
+
+
)
{
info
(
Mousing
over
and
out
of
font
number
{
i
}
in
the
list
)
;
const
nameEl
=
fontEls
[
i
]
;
let
onEvents
=
waitForNSelectionEvents
(
tab
expectedSelectionChangeEvents
[
i
]
)
;
EventUtils
.
synthesizeMouse
(
nameEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
{
expectedSelectionChangeEvents
[
i
]
}
selectionchange
events
detected
on
mouseover
)
;
const
otherEl
=
viewDoc
.
querySelector
(
"
body
"
)
;
onEvents
=
waitForNSelectionEvents
(
tab
1
)
;
EventUtils
.
synthesizeMouse
(
otherEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
"
1
selectionchange
events
detected
on
mouseout
"
)
;
}
}
)
;
async
function
waitForNSelectionEvents
(
tab
numberOfTimes
)
{
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
numberOfTimes
async
function
(
n
)
{
const
win
=
content
.
wrappedJSObject
;
await
new
Promise
(
resolve
=
>
{
let
received
=
0
;
win
.
document
.
addEventListener
(
"
selectionchange
"
function
listen
(
)
{
received
+
+
;
if
(
received
=
=
=
n
)
{
win
.
document
.
removeEventListener
(
"
selectionchange
"
listen
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
)
;
}
