"
use
strict
"
;
const
TEST_URI
=
URL_ROOT
+
"
doc_browser_fontinspector
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
toolbox
.
footer
.
height
"
500
)
;
const
{
inspector
view
}
=
await
openFontInspectorForURL
(
TEST_URI
)
;
await
testFontHighlighting
(
view
inspector
)
;
info
(
"
Check
that
highlighting
still
works
after
reloading
the
page
"
)
;
await
reloadBrowser
(
)
;
await
testFontHighlighting
(
view
inspector
)
;
info
(
"
Check
that
highlighting
works
for
iframe
nodes
"
)
;
await
testFontHighlightingInIframe
(
view
inspector
)
;
}
)
;
async
function
testFontHighlighting
(
view
inspector
)
{
await
selectNode
(
"
body
"
inspector
)
;
const
expectedSelectionChangeEvents
=
[
1
1
1
1
1
]
;
const
viewDoc
=
view
.
document
;
const
fontEls
=
(
await
waitFor
(
(
)
=
>
{
const
els
=
getUsedFontsEls
(
viewDoc
)
;
if
(
els
.
length
<
expectedSelectionChangeEvents
.
length
)
{
return
false
;
}
return
[
.
.
.
els
]
;
}
)
)
.
filter
(
el
=
>
{
const
expectedFonts
=
[
"
ostrich
"
"
arial
"
"
liberation
"
]
;
const
font
=
el
.
textContent
.
toLowerCase
(
)
;
return
expectedFonts
.
some
(
f
=
>
font
.
includes
(
f
)
)
;
}
)
;
ok
(
!
!
fontEls
.
length
"
After
filtering
out
unwanted
fonts
we
still
have
fonts
to
test
"
)
;
for
(
let
i
=
0
;
i
<
fontEls
.
length
;
i
+
+
)
{
info
(
Mousing
over
and
out
of
font
number
{
i
}
(
"
{
fontEls
[
i
]
.
textContent
}
"
)
in
the
list
)
;
const
expectedEvents
=
expectedSelectionChangeEvents
[
i
]
;
const
nameEl
=
fontEls
[
i
]
;
let
onEvents
=
waitForNSelectionEvents
(
gBrowser
.
selectedBrowser
expectedEvents
)
;
EventUtils
.
synthesizeMouse
(
nameEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
{
expectedEvents
}
selectionchange
events
detected
on
mouseover
)
;
const
otherEl
=
viewDoc
.
querySelector
(
"
body
"
)
;
onEvents
=
waitForNSelectionEvents
(
gBrowser
.
selectedBrowser
1
)
;
EventUtils
.
synthesizeMouse
(
otherEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
"
1
selectionchange
events
detected
on
mouseout
"
)
;
}
}
async
function
testFontHighlightingInIframe
(
view
inspector
)
{
await
selectNodeInFrames
(
[
"
iframe
"
"
div
"
]
inspector
)
;
const
viewDoc
=
view
.
document
;
const
fontEls
=
await
waitFor
(
(
)
=
>
{
const
els
=
getUsedFontsEls
(
viewDoc
)
;
if
(
!
els
.
length
)
{
return
false
;
}
return
[
.
.
.
els
]
;
}
)
;
is
(
fontEls
.
length
1
"
There
'
s
only
one
font
used
in
the
iframe
document
"
)
;
is
(
fontEls
[
0
]
.
innerText
"
Times
New
Roman
"
"
The
expected
font
is
displayed
"
)
;
const
iframeBrowsingContext
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
content
.
document
.
querySelector
(
"
iframe
"
)
.
browsingContext
)
;
info
(
Mousing
over
and
out
of
the
font
in
the
list
)
;
const
nameEl
=
fontEls
[
0
]
;
let
onEvents
=
waitForNSelectionEvents
(
iframeBrowsingContext
1
)
;
EventUtils
.
synthesizeMouse
(
nameEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
A
selectionchange
events
detected
on
mouseover
)
;
const
otherEl
=
viewDoc
.
querySelector
(
"
body
"
)
;
onEvents
=
waitForNSelectionEvents
(
iframeBrowsingContext
1
)
;
EventUtils
.
synthesizeMouse
(
otherEl
2
2
{
type
:
"
mouseover
"
}
viewDoc
.
defaultView
)
;
await
onEvents
;
ok
(
true
"
1
selectionchange
events
detected
on
mouseout
"
)
;
}
async
function
waitForNSelectionEvents
(
browser
numberOfTimes
)
{
await
SpecialPowers
.
spawn
(
browser
[
numberOfTimes
]
async
function
(
n
)
{
const
win
=
content
.
wrappedJSObject
;
await
new
Promise
(
resolve
=
>
{
let
received
=
0
;
win
.
document
.
addEventListener
(
"
selectionchange
"
function
listen
(
)
{
received
+
+
;
if
(
received
=
=
=
n
)
{
win
.
document
.
removeEventListener
(
"
selectionchange
"
listen
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
)
;
}
