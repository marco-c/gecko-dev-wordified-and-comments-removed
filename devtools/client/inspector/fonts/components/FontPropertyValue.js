"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
AUTOINCREMENT_DELAY
=
300
;
const
UNITS
=
[
"
em
"
"
rem
"
"
%
"
"
px
"
"
vh
"
"
vw
"
]
;
class
FontPropertyValue
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
allowAutoIncrement
:
PropTypes
.
bool
defaultValue
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
label
:
PropTypes
.
string
.
isRequired
min
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
max
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
name
:
PropTypes
.
string
.
isRequired
onChange
:
PropTypes
.
func
.
isRequired
showUnit
:
PropTypes
.
bool
step
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
unit
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
null
]
)
value
:
PropTypes
.
number
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
interval
=
null
;
this
.
state
=
{
interactive
:
false
value
:
null
}
;
this
.
autoIncrement
=
this
.
autoIncrement
.
bind
(
this
)
;
this
.
onBlur
=
this
.
onBlur
.
bind
(
this
)
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onKeyUp
=
this
.
onKeyUp
.
bind
(
this
)
;
this
.
onMouseDown
=
this
.
onMouseDown
.
bind
(
this
)
;
this
.
onMouseUp
=
this
.
onMouseUp
.
bind
(
this
)
;
this
.
onUnitChange
=
this
.
onUnitChange
.
bind
(
this
)
;
this
.
stopAutoIncrement
=
this
.
stopAutoIncrement
.
bind
(
this
)
;
}
componentDidUpdate
(
prevProps
prevState
)
{
if
(
prevState
.
interactive
&
&
!
this
.
state
.
interactive
)
{
this
.
stopAutoIncrement
(
)
;
}
}
componentWillUnmount
(
)
{
this
.
stopAutoIncrement
(
)
;
}
autoIncrement
(
)
{
const
value
=
this
.
props
.
value
+
this
.
props
.
step
*
10
;
this
.
updateValue
(
value
)
;
}
isAtUpperBound
(
value
)
{
return
value
>
=
Math
.
floor
(
this
.
props
.
max
)
;
}
onBlur
(
)
{
this
.
toggleInteractiveState
(
false
)
;
}
onChange
(
e
)
{
const
value
=
parseFloat
(
e
.
target
.
value
)
;
this
.
updateValue
(
value
)
;
if
(
value
<
this
.
props
.
max
&
&
this
.
interval
)
{
this
.
stopAutoIncrement
(
)
;
}
if
(
this
.
isAtUpperBound
(
value
)
&
&
this
.
state
.
interactive
)
{
this
.
startAutoIncrement
(
)
;
}
}
onKeyDown
(
e
)
{
const
inputType
=
e
.
target
.
type
;
if
(
[
KeyCodes
.
DOM_VK_UP
KeyCodes
.
DOM_VK_DOWN
KeyCodes
.
DOM_VK_RIGHT
KeyCodes
.
DOM_VK_LEFT
]
.
includes
(
e
.
keyCode
)
)
{
this
.
toggleInteractiveState
(
true
)
;
}
if
(
this
.
isAtUpperBound
(
this
.
props
.
value
)
)
{
if
(
(
inputType
=
=
=
"
range
"
&
&
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_UP
|
|
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RIGHT
)
|
|
(
inputType
=
=
=
"
number
"
&
&
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_UP
)
)
{
this
.
startAutoIncrement
(
)
;
}
}
}
onKeyUp
(
e
)
{
if
(
[
KeyCodes
.
DOM_VK_UP
KeyCodes
.
DOM_VK_DOWN
KeyCodes
.
DOM_VK_RIGHT
KeyCodes
.
DOM_VK_LEFT
]
.
includes
(
e
.
keyCode
)
)
{
this
.
toggleInteractiveState
(
false
)
;
}
}
onUnitChange
(
e
)
{
this
.
props
.
onChange
(
this
.
props
.
name
this
.
props
.
value
this
.
props
.
unit
e
.
target
.
value
)
;
this
.
setState
(
(
prevState
)
=
>
{
return
{
.
.
.
prevState
value
:
null
}
;
}
)
;
}
onMouseDown
(
e
)
{
if
(
this
.
isAtUpperBound
(
this
.
props
.
value
)
&
&
e
.
target
.
type
=
=
=
"
range
"
)
{
this
.
startAutoIncrement
(
)
;
}
this
.
toggleInteractiveState
(
true
)
;
}
onMouseUp
(
e
)
{
this
.
toggleInteractiveState
(
false
)
;
}
startAutoIncrement
(
)
{
if
(
!
this
.
props
.
allowAutoIncrement
|
|
this
.
interval
)
{
return
;
}
this
.
interval
=
setInterval
(
this
.
autoIncrement
AUTOINCREMENT_DELAY
)
;
}
stopAutoIncrement
(
)
{
clearInterval
(
this
.
interval
)
;
this
.
interval
=
null
;
}
toggleInteractiveState
(
isInteractive
)
{
this
.
setState
(
(
prevState
)
=
>
{
return
{
.
.
.
prevState
interactive
:
isInteractive
}
;
}
)
;
}
updateValue
(
value
)
{
this
.
props
.
onChange
(
this
.
props
.
name
value
this
.
props
.
unit
)
;
this
.
setState
(
(
prevState
)
=
>
{
return
{
.
.
.
prevState
value
}
;
}
)
;
}
render
(
)
{
if
(
this
.
props
.
min
=
=
=
this
.
props
.
max
)
{
return
null
;
}
const
defaults
=
{
min
:
this
.
props
.
min
max
:
this
.
props
.
max
onBlur
:
this
.
onBlur
onChange
:
this
.
onChange
onKeyUp
:
this
.
onKeyUp
onKeyDown
:
this
.
onKeyDown
step
:
this
.
props
.
step
|
|
1
value
:
this
.
state
.
interactive
?
this
.
state
.
value
:
this
.
props
.
value
|
|
this
.
props
.
defaultValue
}
;
const
range
=
dom
.
input
(
{
.
.
.
defaults
onMouseDown
:
this
.
onMouseDown
onMouseUp
:
this
.
onMouseUp
className
:
"
font
-
value
-
slider
"
name
:
this
.
props
.
name
title
:
this
.
props
.
label
type
:
"
range
"
}
)
;
const
input
=
dom
.
input
(
{
.
.
.
defaults
name
:
this
.
props
.
name
className
:
"
font
-
value
-
input
"
type
:
"
number
"
}
)
;
let
unitDropdown
=
null
;
if
(
this
.
props
.
showUnit
)
{
const
options
=
UNITS
.
includes
(
this
.
props
.
unit
)
?
UNITS
:
UNITS
.
concat
(
[
this
.
props
.
unit
]
)
;
unitDropdown
=
dom
.
select
(
{
className
:
"
font
-
unit
-
select
"
onChange
:
this
.
onUnitChange
}
options
.
map
(
unit
=
>
{
return
dom
.
option
(
{
selected
:
unit
=
=
=
this
.
props
.
unit
value
:
unit
}
unit
)
;
}
)
)
;
}
return
dom
.
label
(
{
className
:
"
font
-
control
"
}
dom
.
span
(
{
className
:
"
font
-
control
-
label
"
}
this
.
props
.
label
)
dom
.
div
(
{
className
:
"
font
-
control
-
input
"
}
range
input
this
.
props
.
showUnit
&
&
unitDropdown
)
)
;
}
}
module
.
exports
=
FontPropertyValue
;
