"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
getColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
{
createFactory
createElement
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
getCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
{
debounce
}
=
require
(
"
devtools
/
shared
/
debounce
"
)
;
const
{
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
const
FontsApp
=
createFactory
(
require
(
"
.
/
components
/
FontsApp
"
)
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
{
getStr
}
=
require
(
"
.
/
utils
/
l10n
"
)
;
const
{
parseFontVariationAxes
}
=
require
(
"
.
/
utils
/
font
-
utils
"
)
;
const
{
updateFonts
}
=
require
(
"
.
/
actions
/
fonts
"
)
;
const
{
applyInstance
resetFontEditor
updateAxis
updateCustomInstance
updateFontEditor
updateFontProperty
updateWarningMessage
}
=
require
(
"
.
/
actions
/
font
-
editor
"
)
;
const
{
updatePreviewText
}
=
require
(
"
.
/
actions
/
font
-
options
"
)
;
const
CUSTOM_INSTANCE_NAME
=
getStr
(
"
fontinspector
.
customInstanceName
"
)
;
const
FONT_PROPERTIES
=
[
"
font
-
family
"
"
font
-
optical
-
sizing
"
"
font
-
size
"
"
font
-
stretch
"
"
font
-
style
"
"
font
-
variation
-
settings
"
"
font
-
weight
"
]
;
const
PREF_FONT_EDITOR
=
"
devtools
.
inspector
.
fonteditor
.
enabled
"
;
const
REGISTERED_AXES_TO_FONT_PROPERTIES
=
{
"
ital
"
:
"
font
-
style
"
"
opsz
"
:
"
font
-
optical
-
sizing
"
"
slnt
"
:
"
font
-
style
"
"
wdth
"
:
"
font
-
stretch
"
"
wght
"
:
"
font
-
weight
"
}
;
const
REGISTERED_AXES
=
Object
.
keys
(
REGISTERED_AXES_TO_FONT_PROPERTIES
)
;
const
HISTOGRAM_N_FONT_AXES
=
"
DEVTOOLS_FONTEDITOR_N_FONT_AXES
"
;
const
HISTOGRAM_N_FONTS_RENDERED
=
"
DEVTOOLS_FONTEDITOR_N_FONTS_RENDERED
"
;
const
HISTOGRAM_FONT_TYPE_DISPLAYED
=
"
DEVTOOLS_FONTEDITOR_FONT_TYPE_DISPLAYED
"
;
class
FontInspector
{
constructor
(
inspector
window
)
{
this
.
cssProperties
=
getCssProperties
(
inspector
.
toolbox
)
;
this
.
document
=
window
.
document
;
this
.
inspector
=
inspector
;
this
.
keywordValues
=
new
Set
(
this
.
getFontPropertyValueKeywords
(
)
)
;
this
.
nodeComputedStyle
=
{
}
;
this
.
pageStyle
=
this
.
inspector
.
pageStyle
;
this
.
ruleViewTool
=
this
.
inspector
.
getPanel
(
"
ruleview
"
)
;
this
.
ruleView
=
this
.
ruleViewTool
.
view
;
this
.
selectedRule
=
null
;
this
.
store
=
this
.
inspector
.
store
;
this
.
writers
=
new
Map
(
)
;
this
.
snapshotChanges
=
debounce
(
this
.
snapshotChanges
100
this
)
;
this
.
syncChanges
=
debounce
(
this
.
syncChanges
100
this
)
;
this
.
onInstanceChange
=
this
.
onInstanceChange
.
bind
(
this
)
;
this
.
onNewNode
=
this
.
onNewNode
.
bind
(
this
)
;
this
.
onPreviewFonts
=
this
.
onPreviewFonts
.
bind
(
this
)
;
this
.
onPropertyChange
=
this
.
onPropertyChange
.
bind
(
this
)
;
this
.
onRulePropertyUpdated
=
debounce
(
this
.
onRulePropertyUpdated
100
this
)
;
this
.
onToggleFontHighlight
=
this
.
onToggleFontHighlight
.
bind
(
this
)
;
this
.
onThemeChanged
=
this
.
onThemeChanged
.
bind
(
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
updateFontVariationSettings
=
this
.
updateFontVariationSettings
.
bind
(
this
)
;
this
.
init
(
)
;
}
init
(
)
{
if
(
!
this
.
inspector
)
{
return
;
}
const
fontsApp
=
FontsApp
(
{
fontEditorEnabled
:
Services
.
prefs
.
getBoolPref
(
PREF_FONT_EDITOR
)
onInstanceChange
:
this
.
onInstanceChange
onToggleFontHighlight
:
this
.
onToggleFontHighlight
onPreviewFonts
:
this
.
onPreviewFonts
onPropertyChange
:
this
.
onPropertyChange
}
)
;
const
provider
=
createElement
(
Provider
{
id
:
"
fontinspector
"
key
:
"
fontinspector
"
store
:
this
.
store
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
}
fontsApp
)
;
this
.
provider
=
provider
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewNode
)
;
this
.
inspector
.
sidebar
.
on
(
"
fontinspector
-
selected
"
this
.
onNewNode
)
;
gDevTools
.
on
(
"
theme
-
switched
"
this
.
onThemeChanged
)
;
}
excludeNodeFonts
(
allFonts
nodeFonts
)
{
return
allFonts
.
filter
(
font
=
>
{
return
!
nodeFonts
.
some
(
nodeFont
=
>
nodeFont
.
name
=
=
=
font
.
name
)
;
}
)
;
}
async
convertUnits
(
value
fromUnit
toUnit
)
{
if
(
value
!
=
=
parseFloat
(
value
)
)
{
throw
TypeError
(
Invalid
value
for
conversion
.
Expected
Number
got
{
value
}
)
;
}
if
(
fromUnit
=
=
=
toUnit
)
{
return
value
;
}
if
(
toUnit
!
=
=
"
px
"
&
&
fromUnit
!
=
=
"
px
"
)
{
value
=
await
this
.
convertUnits
(
value
fromUnit
"
px
"
)
;
fromUnit
=
"
px
"
;
}
const
fromPx
=
fromUnit
=
=
=
"
px
"
;
const
unit
=
toUnit
=
=
=
"
px
"
?
fromUnit
:
toUnit
;
const
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
out
=
value
;
let
computedStyle
;
if
(
unit
=
=
=
"
in
"
)
{
out
=
fromPx
?
value
/
96
:
value
*
96
;
}
if
(
unit
=
=
=
"
cm
"
)
{
out
=
fromPx
?
value
*
0
.
02645833333
:
value
/
0
.
02645833333
;
}
if
(
unit
=
=
=
"
mm
"
)
{
out
=
fromPx
?
value
*
0
.
26458333333
:
value
/
0
.
26458333333
;
}
if
(
unit
=
=
=
"
pt
"
)
{
out
=
fromPx
?
value
*
0
.
75
:
value
/
0
.
75
;
}
if
(
unit
=
=
=
"
pc
"
)
{
out
=
fromPx
?
value
*
0
.
0625
:
value
/
0
.
0625
;
}
if
(
unit
=
=
=
"
%
"
)
{
computedStyle
=
await
this
.
pageStyle
.
getComputed
(
node
.
parentNode
(
)
)
.
catch
(
console
.
error
)
;
if
(
!
computedStyle
)
{
return
value
;
}
out
=
fromPx
?
value
*
100
/
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
:
value
/
100
*
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
;
}
if
(
unit
=
=
=
"
em
"
)
{
computedStyle
=
await
this
.
pageStyle
.
getComputed
(
node
.
parentNode
(
)
)
.
catch
(
console
.
error
)
;
if
(
!
computedStyle
)
{
return
value
;
}
out
=
fromPx
?
value
/
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
:
value
*
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
;
}
if
(
unit
=
=
=
"
rem
"
)
{
const
document
=
await
this
.
inspector
.
walker
.
documentElement
(
)
;
computedStyle
=
await
this
.
pageStyle
.
getComputed
(
document
)
.
catch
(
console
.
error
)
;
if
(
!
computedStyle
)
{
return
value
;
}
out
=
fromPx
?
value
/
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
:
value
*
parseFloat
(
computedStyle
[
"
font
-
size
"
]
.
value
)
;
}
if
(
unit
=
=
=
"
vh
"
|
|
unit
=
=
=
"
vw
"
|
|
unit
=
=
=
"
vmin
"
|
|
unit
=
=
=
"
vmax
"
)
{
const
dim
=
await
node
.
getOwnerGlobalDimensions
(
)
;
if
(
!
dim
|
|
!
dim
.
innerWidth
|
|
!
dim
.
innerHeight
)
{
out
=
value
;
}
else
if
(
unit
=
=
=
"
vh
"
)
{
out
=
fromPx
?
value
*
100
/
dim
.
innerHeight
:
value
/
100
*
dim
.
innerHeight
;
}
else
if
(
unit
=
=
=
"
vw
"
)
{
out
=
fromPx
?
value
*
100
/
dim
.
innerWidth
:
value
/
100
*
dim
.
innerWidth
;
}
else
if
(
unit
=
=
=
"
vmin
"
)
{
out
=
fromPx
?
value
*
100
/
Math
.
min
(
dim
.
innerWidth
dim
.
innerHeight
)
:
value
/
100
*
Math
.
min
(
dim
.
innerWidth
dim
.
innerHeight
)
;
}
else
if
(
unit
=
=
=
"
vmax
"
)
{
out
=
fromPx
?
value
*
100
/
Math
.
max
(
dim
.
innerWidth
dim
.
innerHeight
)
:
value
/
100
*
Math
.
max
(
dim
.
innerWidth
dim
.
innerHeight
)
;
}
}
if
(
fromPx
)
{
return
out
=
=
=
Math
.
round
(
out
)
?
Math
.
round
(
out
)
:
out
.
toFixed
(
3
)
;
}
return
Math
.
round
(
out
)
;
}
destroy
(
)
{
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewNode
)
;
this
.
inspector
.
sidebar
.
off
(
"
fontinspector
-
selected
"
this
.
onNewNode
)
;
this
.
ruleView
.
off
(
"
property
-
value
-
updated
"
this
.
onRulePropertyUpdated
)
;
gDevTools
.
off
(
"
theme
-
switched
"
this
.
onThemeChanged
)
;
this
.
document
=
null
;
this
.
inspector
=
null
;
this
.
nodeComputedStyle
=
{
}
;
this
.
pageStyle
=
null
;
this
.
ruleView
=
null
;
this
.
selectedRule
=
null
;
this
.
store
=
null
;
this
.
writers
.
clear
(
)
;
this
.
writers
=
null
;
}
filterFontsUsed
(
fonts
=
[
]
fontFamilies
=
[
]
)
{
return
fontFamilies
.
reduce
(
(
acc
family
)
=
>
{
const
match
=
fonts
.
find
(
font
=
>
{
const
generic
=
typeof
font
.
CSSGeneric
=
=
=
"
string
"
?
font
.
CSSGeneric
.
toLowerCase
(
)
:
font
.
CSSGeneric
;
return
generic
=
=
=
family
.
toLowerCase
(
)
|
|
font
.
CSSFamilyName
.
toLowerCase
(
)
=
=
=
family
.
toLowerCase
(
)
;
}
)
;
if
(
match
)
{
acc
.
push
(
match
)
;
}
return
acc
;
}
[
]
)
;
}
getFontProperties
(
)
{
const
properties
=
{
}
;
for
(
const
prop
of
FONT_PROPERTIES
)
{
properties
[
prop
]
=
(
this
.
nodeComputedStyle
[
prop
]
&
&
this
.
nodeComputedStyle
[
prop
]
.
value
)
?
this
.
nodeComputedStyle
[
prop
]
.
value
:
"
"
;
}
for
(
const
rule
of
this
.
ruleView
.
rules
)
{
if
(
rule
.
inherited
)
{
continue
;
}
for
(
const
textProp
of
rule
.
textProps
)
{
if
(
FONT_PROPERTIES
.
includes
(
textProp
.
name
)
&
&
!
this
.
keywordValues
.
has
(
textProp
.
value
)
&
&
!
textProp
.
value
.
includes
(
"
calc
(
"
)
&
&
!
textProp
.
value
.
includes
(
"
var
(
"
)
&
&
!
textProp
.
overridden
&
&
textProp
.
enabled
)
{
properties
[
textProp
.
name
]
=
textProp
.
value
;
}
}
}
return
properties
;
}
getFontPropertyValueKeywords
(
)
{
return
[
"
font
-
size
"
"
font
-
weight
"
"
font
-
stretch
"
]
.
reduce
(
(
acc
property
)
=
>
{
return
acc
.
concat
(
this
.
cssProperties
.
getValues
(
property
)
)
;
}
[
]
)
;
}
async
getFontsForNode
(
node
options
)
{
if
(
!
this
.
document
)
{
return
[
]
;
}
const
fonts
=
await
this
.
pageStyle
.
getUsedFontFaces
(
node
options
)
.
catch
(
console
.
error
)
;
if
(
!
fonts
)
{
return
[
]
;
}
return
fonts
;
}
async
getFontsNotInNode
(
nodeFonts
options
)
{
if
(
!
this
.
document
)
{
return
[
]
;
}
let
allFonts
=
await
this
.
pageStyle
.
getAllUsedFontFaces
(
options
)
.
catch
(
console
.
error
)
;
if
(
!
allFonts
)
{
allFonts
=
[
]
;
}
return
this
.
excludeNodeFonts
(
allFonts
nodeFonts
)
;
}
getTextProperty
(
name
)
{
if
(
!
this
.
selectedRule
)
{
return
null
;
}
return
this
.
selectedRule
.
textProps
.
find
(
prop
=
>
prop
.
name
=
=
=
name
&
&
prop
.
enabled
&
&
!
prop
.
overridden
)
;
}
getWriterForAxis
(
axis
)
{
const
FVSComputedStyle
=
this
.
nodeComputedStyle
[
"
font
-
variation
-
settings
"
]
;
if
(
FVSComputedStyle
&
&
FVSComputedStyle
.
value
.
includes
(
axis
)
)
{
return
this
.
updateFontVariationSettings
;
}
const
property
=
REGISTERED_AXES_TO_FONT_PROPERTIES
[
axis
]
;
return
(
value
)
=
>
{
let
condition
=
false
;
switch
(
axis
)
{
case
"
wght
"
:
condition
=
this
.
pageStyle
.
supportsFontWeightLevel4
;
break
;
case
"
wdth
"
:
value
=
{
value
}
%
;
condition
=
this
.
pageStyle
.
supportsFontStretchLevel4
;
break
;
case
"
slnt
"
:
value
=
oblique
{
value
}
deg
;
condition
=
this
.
pageStyle
.
supportsFontStyleLevel4
;
break
;
}
if
(
condition
)
{
this
.
updatePropertyValue
(
property
value
)
;
}
else
{
this
.
writers
.
set
(
axis
this
.
updateFontVariationSettings
)
;
this
.
updateFontVariationSettings
(
)
;
}
}
;
}
getWriterForProperty
(
name
)
{
if
(
this
.
writers
.
has
(
name
)
)
{
return
this
.
writers
.
get
(
name
)
;
}
if
(
REGISTERED_AXES
.
includes
(
name
)
)
{
this
.
writers
.
set
(
name
this
.
getWriterForAxis
(
name
)
)
;
}
else
if
(
FONT_PROPERTIES
.
includes
(
name
)
)
{
this
.
writers
.
set
(
name
(
value
)
=
>
{
this
.
updatePropertyValue
(
name
value
)
;
}
)
;
}
else
{
this
.
writers
.
set
(
name
this
.
updateFontVariationSettings
)
;
}
return
this
.
writers
.
get
(
name
)
;
}
groupFontFamilies
(
fontsUsed
=
[
]
fontFamilies
=
[
]
)
{
const
families
=
{
}
;
families
.
used
=
fontsUsed
.
map
(
font
=
>
font
.
CSSGeneric
?
font
.
CSSGeneric
:
font
.
CSSFamilyName
)
;
const
familiesUsedLowercase
=
families
.
used
.
map
(
family
=
>
family
.
toLowerCase
(
)
)
;
families
.
notUsed
=
fontFamilies
.
filter
(
family
=
>
!
familiesUsedLowercase
.
includes
(
family
.
toLowerCase
(
)
)
)
;
return
families
;
}
isPanelVisible
(
)
{
return
this
.
inspector
&
&
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
=
"
fontinspector
"
;
}
isSelectedNodeValid
(
)
{
return
this
.
inspector
&
&
this
.
inspector
.
selection
.
nodeFront
&
&
this
.
inspector
.
selection
.
isConnected
(
)
&
&
this
.
inspector
.
selection
.
isElementNode
(
)
&
&
!
this
.
inspector
.
selection
.
isPseudoElementNode
(
)
;
}
logTelemetryProbesOnNewNode
(
)
{
const
{
fontData
fontEditor
}
=
this
.
store
.
getState
(
)
;
const
{
telemetry
}
=
this
.
inspector
;
const
nbOfFontsRendered
=
fontData
.
fonts
.
length
;
if
(
nbOfFontsRendered
)
{
telemetry
.
getHistogramById
(
HISTOGRAM_N_FONTS_RENDERED
)
.
add
(
nbOfFontsRendered
)
;
}
const
editedFont
=
fontEditor
.
fonts
[
0
]
;
if
(
!
editedFont
)
{
return
;
}
const
nbOfAxes
=
editedFont
.
variationAxes
?
editedFont
.
variationAxes
.
length
:
0
;
telemetry
.
getHistogramById
(
HISTOGRAM_FONT_TYPE_DISPLAYED
)
.
add
(
!
nbOfAxes
?
"
nonvariable
"
:
"
variable
"
)
;
if
(
nbOfAxes
)
{
telemetry
.
getHistogramById
(
HISTOGRAM_N_FONT_AXES
)
.
add
(
nbOfAxes
)
;
}
}
syncChanges
(
name
value
)
{
const
textProperty
=
this
.
getTextProperty
(
name
value
)
;
if
(
textProperty
)
{
textProperty
.
setValue
(
value
)
.
catch
(
error
=
>
{
if
(
!
this
.
document
)
{
return
;
}
throw
error
;
}
)
;
}
this
.
ruleView
.
on
(
"
property
-
value
-
updated
"
this
.
onRulePropertyUpdated
)
;
}
onAxisUpdate
(
tag
value
)
{
this
.
store
.
dispatch
(
updateAxis
(
tag
value
)
)
;
this
.
store
.
dispatch
(
applyInstance
(
CUSTOM_INSTANCE_NAME
null
)
)
;
this
.
snapshotChanges
(
)
;
const
writer
=
this
.
getWriterForProperty
(
tag
)
;
writer
(
value
)
;
}
onFontPropertyUpdate
(
property
value
unit
)
{
value
=
(
unit
!
=
=
null
)
?
value
+
unit
:
value
;
this
.
store
.
dispatch
(
updateFontProperty
(
property
value
)
)
;
const
writer
=
this
.
getWriterForProperty
(
property
)
;
writer
(
value
)
;
}
onInstanceChange
(
name
values
)
{
this
.
store
.
dispatch
(
applyInstance
(
name
values
)
)
;
let
writer
;
values
.
map
(
obj
=
>
{
writer
=
this
.
getWriterForProperty
(
obj
.
axis
)
;
writer
(
obj
.
value
.
toString
(
)
)
;
}
)
;
}
onNewNode
(
)
{
this
.
ruleView
.
off
(
"
property
-
value
-
updated
"
this
.
onRulePropertyUpdated
)
;
if
(
this
.
isPanelVisible
(
)
)
{
Promise
.
all
(
[
this
.
update
(
)
this
.
refreshFontEditor
(
)
]
)
.
then
(
(
)
=
>
{
this
.
logTelemetryProbesOnNewNode
(
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
}
onPreviewFonts
(
value
)
{
this
.
store
.
dispatch
(
updatePreviewText
(
value
)
)
;
this
.
update
(
)
;
}
async
onPropertyChange
(
property
value
fromUnit
toUnit
)
{
if
(
FONT_PROPERTIES
.
includes
(
property
)
)
{
let
unit
=
fromUnit
;
if
(
toUnit
&
&
fromUnit
)
{
value
=
await
this
.
convertUnits
(
value
fromUnit
toUnit
)
;
unit
=
toUnit
;
}
this
.
onFontPropertyUpdate
(
property
value
unit
)
;
}
else
{
this
.
onAxisUpdate
(
property
value
)
;
}
}
async
onRulePropertyUpdated
(
eventData
)
{
if
(
!
this
.
selectedRule
|
|
!
this
.
selectedRule
.
matches
(
{
rule
:
eventData
.
rule
.
domRule
}
)
|
|
!
FONT_PROPERTIES
.
includes
(
eventData
.
property
)
)
{
return
;
}
if
(
this
.
isPanelVisible
(
)
)
{
await
this
.
refreshFontEditor
(
)
;
}
}
async
onToggleFontHighlight
(
font
show
isForCurrentElement
=
true
)
{
if
(
!
this
.
fontsHighlighter
)
{
try
{
this
.
fontsHighlighter
=
await
this
.
inspector
.
toolbox
.
highlighterUtils
.
getHighlighterByType
(
"
FontsHighlighter
"
)
;
}
catch
(
e
)
{
this
.
onToggleFontHighlight
=
(
)
=
>
{
}
;
return
;
}
}
try
{
if
(
show
)
{
const
node
=
isForCurrentElement
?
this
.
inspector
.
selection
.
nodeFront
:
this
.
inspector
.
walker
.
rootNode
;
await
this
.
fontsHighlighter
.
show
(
node
{
CSSFamilyName
:
font
.
CSSFamilyName
name
:
font
.
name
}
)
;
}
else
{
await
this
.
fontsHighlighter
.
hide
(
)
;
}
}
catch
(
e
)
{
}
}
onThemeChanged
(
frame
)
{
if
(
frame
=
=
=
this
.
document
.
defaultView
)
{
this
.
update
(
)
;
}
}
async
refreshFontEditor
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_FONT_EDITOR
)
)
{
return
;
}
if
(
!
this
.
store
|
|
!
this
.
isSelectedNodeValid
(
)
)
{
if
(
this
.
inspector
.
selection
.
isPseudoElementNode
(
)
)
{
const
noPseudoWarning
=
getStr
(
"
fontinspector
.
noPseduoWarning
"
)
;
this
.
store
.
dispatch
(
resetFontEditor
(
)
)
;
this
.
store
.
dispatch
(
updateWarningMessage
(
noPseudoWarning
)
)
;
return
;
}
if
(
this
.
inspector
.
selection
.
isTextNode
(
)
)
{
const
selection
=
this
.
inspector
.
selection
;
selection
.
setNodeFront
(
selection
.
nodeFront
.
parentNode
(
)
)
;
return
;
}
this
.
store
.
dispatch
(
resetFontEditor
(
)
)
;
return
;
}
const
options
=
{
}
;
if
(
this
.
pageStyle
.
supportsFontVariations
)
{
options
.
includeVariations
=
true
;
}
const
node
=
this
.
inspector
.
selection
.
nodeFront
;
const
fonts
=
await
this
.
getFontsForNode
(
node
options
)
;
try
{
this
.
nodeComputedStyle
=
await
this
.
pageStyle
.
getComputed
(
node
{
filterProperties
:
FONT_PROPERTIES
}
)
;
}
catch
(
e
)
{
if
(
!
this
.
document
)
{
return
;
}
throw
e
;
}
if
(
!
this
.
nodeComputedStyle
|
|
!
fonts
.
length
)
{
this
.
store
.
dispatch
(
resetFontEditor
(
)
)
;
this
.
inspector
.
emit
(
"
fonteditor
-
updated
"
)
;
return
;
}
this
.
writers
.
clear
(
)
;
if
(
!
this
.
ruleViewTool
.
isSidebarActive
(
)
)
{
await
this
.
ruleView
.
selectElement
(
node
false
)
;
}
this
.
selectedRule
=
this
.
ruleView
.
rules
.
find
(
rule
=
>
rule
.
domRule
.
type
=
=
=
ELEMENT_STYLE
)
;
const
properties
=
this
.
getFontProperties
(
)
;
const
familiesDeclared
=
properties
[
"
font
-
family
"
]
.
split
(
"
"
)
.
map
(
font
=
>
font
.
replace
(
/
[
"
'
]
+
/
g
"
"
)
.
trim
(
)
)
;
let
fontsUsed
=
this
.
filterFontsUsed
(
fonts
familiesDeclared
)
;
const
families
=
this
.
groupFontFamilies
(
fontsUsed
familiesDeclared
)
;
const
axes
=
parseFontVariationAxes
(
properties
[
"
font
-
variation
-
settings
"
]
)
;
Object
.
keys
(
axes
)
.
map
(
axis
=
>
{
this
.
writers
.
set
(
axis
this
.
getWriterForAxis
(
axis
)
)
;
}
)
;
if
(
!
fontsUsed
.
length
&
&
fonts
.
length
)
{
const
otherVarFonts
=
fonts
.
filter
(
font
=
>
{
return
(
font
.
variationAxes
&
&
font
.
variationAxes
.
length
)
;
}
)
;
fontsUsed
=
otherVarFonts
.
length
?
otherVarFonts
:
fonts
;
}
this
.
store
.
dispatch
(
updateFontEditor
(
fontsUsed
families
properties
node
.
actorID
)
)
;
this
.
inspector
.
emit
(
"
fonteditor
-
updated
"
)
;
this
.
ruleView
.
on
(
"
property
-
value
-
updated
"
this
.
onRulePropertyUpdated
)
;
}
snapshotChanges
(
)
{
this
.
store
.
dispatch
(
updateCustomInstance
(
)
)
;
}
async
update
(
)
{
if
(
!
this
.
inspector
|
|
!
this
.
store
)
{
return
;
}
let
fonts
=
[
]
;
let
otherFonts
=
[
]
;
if
(
!
this
.
isSelectedNodeValid
(
)
)
{
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
return
;
}
const
{
fontOptions
}
=
this
.
store
.
getState
(
)
;
const
{
previewText
}
=
fontOptions
;
const
options
=
{
includePreviews
:
true
previewText
previewFillStyle
:
getColor
(
"
body
-
color
"
)
}
;
if
(
this
.
pageStyle
.
supportsFontVariations
)
{
options
.
includeVariations
=
true
;
}
const
node
=
this
.
inspector
.
selection
.
nodeFront
;
fonts
=
await
this
.
getFontsForNode
(
node
options
)
;
otherFonts
=
await
this
.
getFontsNotInNode
(
fonts
options
)
;
if
(
!
fonts
.
length
&
&
!
otherFonts
.
length
)
{
if
(
this
.
store
)
{
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
}
return
;
}
for
(
const
font
of
[
.
.
.
fonts
.
.
.
otherFonts
]
)
{
font
.
previewUrl
=
await
font
.
preview
.
data
.
string
(
)
;
}
if
(
!
this
.
document
)
{
return
;
}
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
this
.
inspector
.
emit
(
"
fontinspector
-
updated
"
)
;
}
updateFontVariationSettings
(
)
{
const
fontEditor
=
this
.
store
.
getState
(
)
.
fontEditor
;
const
name
=
"
font
-
variation
-
settings
"
;
const
value
=
Object
.
keys
(
fontEditor
.
axes
)
.
filter
(
tag
=
>
this
.
writers
.
get
(
tag
)
=
=
=
this
.
updateFontVariationSettings
)
.
map
(
tag
=
>
"
{
tag
}
"
{
fontEditor
.
axes
[
tag
]
}
)
.
join
(
"
"
)
;
this
.
updatePropertyValue
(
name
value
)
;
}
updatePropertyValue
(
name
value
)
{
const
textProperty
=
this
.
getTextProperty
(
name
)
;
if
(
!
textProperty
)
{
this
.
selectedRule
.
createProperty
(
name
value
"
"
true
)
;
return
;
}
if
(
textProperty
.
value
=
=
=
value
)
{
return
;
}
this
.
ruleView
.
off
(
"
property
-
value
-
updated
"
this
.
onRulePropertyUpdated
)
;
textProperty
.
rule
.
previewPropertyValue
(
textProperty
value
"
"
)
.
catch
(
console
.
error
)
;
this
.
syncChanges
(
name
value
)
;
}
}
module
.
exports
=
FontInspector
;
