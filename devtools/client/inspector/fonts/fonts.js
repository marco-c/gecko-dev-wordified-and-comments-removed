"
use
strict
"
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
getColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
{
createFactory
createElement
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
FontsApp
=
createFactory
(
require
(
"
.
/
components
/
FontsApp
"
)
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
const
{
updateFonts
}
=
require
(
"
.
/
actions
/
fonts
"
)
;
const
{
updatePreviewText
}
=
require
(
"
.
/
actions
/
font
-
options
"
)
;
class
FontInspector
{
constructor
(
inspector
window
)
{
this
.
document
=
window
.
document
;
this
.
inspector
=
inspector
;
this
.
pageStyle
=
this
.
inspector
.
pageStyle
;
this
.
store
=
this
.
inspector
.
store
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
onNewNode
=
this
.
onNewNode
.
bind
(
this
)
;
this
.
onPreviewFonts
=
this
.
onPreviewFonts
.
bind
(
this
)
;
this
.
onThemeChanged
=
this
.
onThemeChanged
.
bind
(
this
)
;
this
.
init
(
)
;
}
init
(
)
{
if
(
!
this
.
inspector
)
{
return
;
}
let
fontsApp
=
FontsApp
(
{
onPreviewFonts
:
this
.
onPreviewFonts
}
)
;
let
provider
=
createElement
(
Provider
{
id
:
"
fontinspector
"
key
:
"
fontinspector
"
store
:
this
.
store
title
:
INSPECTOR_L10N
.
getStr
(
"
inspector
.
sidebar
.
fontInspectorTitle
"
)
}
fontsApp
)
;
this
.
provider
=
provider
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewNode
)
;
this
.
inspector
.
sidebar
.
on
(
"
fontinspector
-
selected
"
this
.
onNewNode
)
;
gDevTools
.
on
(
"
theme
-
switched
"
this
.
onThemeChanged
)
;
this
.
store
.
dispatch
(
updatePreviewText
(
"
"
)
)
;
this
.
update
(
false
"
"
)
;
}
excludeNodeFonts
(
allFonts
nodeFonts
)
{
return
allFonts
.
filter
(
font
=
>
{
return
!
nodeFonts
.
some
(
nodeFont
=
>
nodeFont
.
name
=
=
=
font
.
name
)
;
}
)
;
}
destroy
(
)
{
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewNode
)
;
this
.
inspector
.
sidebar
.
off
(
"
fontinspector
-
selected
"
this
.
onNewNode
)
;
gDevTools
.
off
(
"
theme
-
switched
"
this
.
onThemeChanged
)
;
this
.
document
=
null
;
this
.
inspector
=
null
;
this
.
pageStyle
=
null
;
this
.
store
=
null
;
}
async
getFontsForNode
(
node
options
)
{
if
(
!
this
.
document
)
{
return
[
]
;
}
let
fonts
=
await
this
.
pageStyle
.
getUsedFontFaces
(
node
options
)
.
catch
(
console
.
error
)
;
if
(
!
fonts
)
{
return
[
]
;
}
return
fonts
;
}
async
getFontsNotInNode
(
nodeFonts
options
)
{
if
(
!
this
.
document
)
{
return
[
]
;
}
let
allFonts
=
await
this
.
pageStyle
.
getAllUsedFontFaces
(
options
)
.
catch
(
console
.
error
)
;
if
(
!
allFonts
)
{
allFonts
=
[
]
;
}
return
this
.
excludeNodeFonts
(
allFonts
nodeFonts
)
;
}
isPanelVisible
(
)
{
return
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
=
"
fontinspector
"
;
}
onNewNode
(
)
{
if
(
this
.
isPanelVisible
(
)
)
{
this
.
update
(
)
;
}
}
onPreviewFonts
(
value
)
{
this
.
store
.
dispatch
(
updatePreviewText
(
value
)
)
;
this
.
update
(
)
;
}
onThemeChanged
(
event
frame
)
{
if
(
frame
=
=
=
this
.
document
.
defaultView
)
{
this
.
update
(
)
;
}
}
async
update
(
)
{
if
(
!
this
.
inspector
|
|
!
this
.
store
)
{
return
;
}
let
node
=
this
.
inspector
.
selection
.
nodeFront
;
let
fonts
=
[
]
;
let
otherFonts
=
[
]
;
let
{
fontOptions
}
=
this
.
store
.
getState
(
)
;
let
{
previewText
}
=
fontOptions
;
let
isElementOrTextNode
=
this
.
inspector
.
selection
.
isElementNode
(
)
|
|
this
.
inspector
.
selection
.
isTextNode
(
)
;
if
(
!
node
|
|
!
this
.
isPanelVisible
(
)
|
|
!
this
.
inspector
.
selection
.
isConnected
(
)
|
|
!
isElementOrTextNode
)
{
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
return
;
}
let
options
=
{
includePreviews
:
true
previewText
previewFillStyle
:
getColor
(
"
body
-
color
"
)
}
;
if
(
this
.
pageStyle
.
supportsFontVariations
)
{
options
.
includeVariations
=
true
;
}
fonts
=
await
this
.
getFontsForNode
(
node
options
)
;
otherFonts
=
await
this
.
getFontsNotInNode
(
fonts
options
)
;
if
(
!
fonts
.
length
&
&
!
otherFonts
.
length
)
{
if
(
this
.
store
)
{
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
}
return
;
}
for
(
let
font
of
[
.
.
.
fonts
.
.
.
otherFonts
]
)
{
font
.
previewUrl
=
await
font
.
preview
.
data
.
string
(
)
;
}
if
(
!
this
.
document
)
{
return
;
}
this
.
store
.
dispatch
(
updateFonts
(
fonts
otherFonts
)
)
;
this
.
inspector
.
emit
(
"
fontinspector
-
updated
"
)
;
}
}
module
.
exports
=
FontInspector
;
