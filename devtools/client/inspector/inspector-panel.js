"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
clipboard
=
require
(
"
sdk
/
clipboard
"
)
;
var
{
HostType
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
.
Toolbox
;
loader
.
lazyRequireGetter
(
this
"
CSS
"
"
CSS
"
)
;
loader
.
lazyGetter
(
this
"
MarkupView
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
markup
/
markup
"
)
.
MarkupView
)
;
loader
.
lazyGetter
(
this
"
HTMLBreadcrumbs
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
breadcrumbs
"
)
.
HTMLBreadcrumbs
)
;
loader
.
lazyGetter
(
this
"
ToolSidebar
"
(
)
=
>
require
(
"
devtools
/
client
/
framework
/
sidebar
"
)
.
ToolSidebar
)
;
loader
.
lazyGetter
(
this
"
InspectorSearch
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
inspector
-
search
"
)
.
InspectorSearch
)
;
loader
.
lazyGetter
(
this
"
RuleViewTool
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
.
RuleViewTool
)
;
loader
.
lazyGetter
(
this
"
ComputedViewTool
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
computed
/
computed
"
)
.
ComputedViewTool
)
;
loader
.
lazyGetter
(
this
"
FontInspector
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
fonts
/
fonts
"
)
.
FontInspector
)
;
loader
.
lazyGetter
(
this
"
LayoutView
"
(
)
=
>
require
(
"
devtools
/
client
/
inspector
/
layout
/
layout
"
)
.
LayoutView
)
;
loader
.
lazyGetter
(
this
"
strings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
inspector
.
properties
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
toolboxStrings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
toolbox
.
properties
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
clipboardHelper
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
CommandUtils
"
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
true
)
;
function
InspectorPanel
(
iframeWindow
toolbox
)
{
this
.
_toolbox
=
toolbox
;
this
.
_target
=
toolbox
.
_target
;
this
.
panelDoc
=
iframeWindow
.
document
;
this
.
panelWin
=
iframeWindow
;
this
.
panelWin
.
inspector
=
this
;
this
.
nodeMenuTriggerInfo
=
null
;
this
.
_onBeforeNavigate
=
this
.
_onBeforeNavigate
.
bind
(
this
)
;
this
.
onNewRoot
=
this
.
onNewRoot
.
bind
(
this
)
;
this
.
_setupNodeMenu
=
this
.
_setupNodeMenu
.
bind
(
this
)
;
this
.
_resetNodeMenu
=
this
.
_resetNodeMenu
.
bind
(
this
)
;
this
.
_updateSearchResultsLabel
=
this
.
_updateSearchResultsLabel
.
bind
(
this
)
;
this
.
onNewSelection
=
this
.
onNewSelection
.
bind
(
this
)
;
this
.
onBeforeNewSelection
=
this
.
onBeforeNewSelection
.
bind
(
this
)
;
this
.
onDetached
=
this
.
onDetached
.
bind
(
this
)
;
this
.
onPaneToggleButtonClicked
=
this
.
onPaneToggleButtonClicked
.
bind
(
this
)
;
this
.
_onMarkupFrameLoad
=
this
.
_onMarkupFrameLoad
.
bind
(
this
)
;
this
.
_target
.
on
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
InspectorPanel
=
InspectorPanel
;
InspectorPanel
.
prototype
=
{
open
:
function
(
)
{
return
this
.
target
.
makeRemote
(
)
.
then
(
(
)
=
>
{
return
this
.
_getPageStyle
(
)
;
}
)
.
then
(
(
)
=
>
{
return
this
.
_getDefaultNodeForSelection
(
)
;
}
)
.
then
(
defaultSelection
=
>
{
return
this
.
_deferredOpen
(
defaultSelection
)
;
}
)
.
then
(
null
console
.
error
)
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
inspector
(
)
{
return
this
.
_toolbox
.
inspector
;
}
get
walker
(
)
{
return
this
.
_toolbox
.
walker
;
}
get
selection
(
)
{
return
this
.
_toolbox
.
selection
;
}
get
isOuterHTMLEditable
(
)
{
return
this
.
_target
.
client
.
traits
.
editOuterHTML
;
}
get
hasUrlToImageDataResolver
(
)
{
return
this
.
_target
.
client
.
traits
.
urlToImageDataResolver
;
}
get
canGetUniqueSelector
(
)
{
return
this
.
_target
.
client
.
traits
.
getUniqueSelector
;
}
get
canGetUsedFontFaces
(
)
{
return
this
.
_target
.
client
.
traits
.
getUsedFontFaces
;
}
get
canPasteInnerOrAdjacentHTML
(
)
{
return
this
.
_target
.
client
.
traits
.
pasteHTML
;
}
_deferredOpen
:
function
(
defaultSelection
)
{
let
deferred
=
promise
.
defer
(
)
;
this
.
walker
.
on
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
nodemenu
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
node
-
popup
"
)
;
this
.
lastNodemenuItem
=
this
.
nodemenu
.
lastChild
;
this
.
nodemenu
.
addEventListener
(
"
popupshowing
"
this
.
_setupNodeMenu
true
)
;
this
.
nodemenu
.
addEventListener
(
"
popuphiding
"
this
.
_resetNodeMenu
true
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
on
(
"
before
-
new
-
node
-
front
"
this
.
onBeforeNewSelection
)
;
this
.
selection
.
on
(
"
detached
-
front
"
this
.
onDetached
)
;
this
.
breadcrumbs
=
new
HTMLBreadcrumbs
(
this
)
;
if
(
this
.
target
.
isLocalTab
)
{
this
.
updateDebuggerPausedWarning
=
(
)
=
>
{
let
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
inspector
-
script
-
paused
"
)
;
if
(
!
notification
&
&
this
.
_toolbox
.
currentToolId
=
=
"
inspector
"
&
&
this
.
_toolbox
.
threadClient
.
paused
)
{
let
message
=
strings
.
GetStringFromName
(
"
debuggerPausedWarning
.
message
"
)
;
notificationBox
.
appendNotification
(
message
"
inspector
-
script
-
paused
"
"
"
notificationBox
.
PRIORITY_WARNING_HIGH
)
;
}
if
(
notification
&
&
this
.
_toolbox
.
currentToolId
!
=
"
inspector
"
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
if
(
notification
&
&
!
this
.
_toolbox
.
threadClient
.
paused
)
{
notificationBox
.
removeNotification
(
notification
)
;
}
}
;
this
.
target
.
on
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
on
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
on
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
this
.
updateDebuggerPausedWarning
(
)
;
}
this
.
_initMarkup
(
)
;
this
.
isReady
=
false
;
this
.
once
(
"
markuploaded
"
(
)
=
>
{
this
.
isReady
=
true
;
this
.
selection
.
setNodeFront
(
defaultSelection
"
inspector
-
open
"
)
;
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
this
.
emit
(
"
ready
"
)
;
deferred
.
resolve
(
this
)
;
}
)
;
this
.
setupSearchBox
(
)
;
this
.
setupSidebar
(
)
;
return
deferred
.
promise
;
}
_onBeforeNavigate
:
function
(
)
{
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
this
.
isDirty
=
false
;
this
.
_pendingSelection
=
null
;
}
_getPageStyle
:
function
(
)
{
return
this
.
_toolbox
.
inspector
.
getPageStyle
(
)
.
then
(
pageStyle
=
>
{
this
.
pageStyle
=
pageStyle
;
}
)
;
}
_getDefaultNodeForSelection
:
function
(
)
{
if
(
this
.
_defaultNode
)
{
return
this
.
_defaultNode
;
}
let
walker
=
this
.
walker
;
let
rootNode
=
null
;
let
pendingSelection
=
this
.
_pendingSelection
;
let
hasNavigated
=
(
)
=
>
pendingSelection
!
=
=
this
.
_pendingSelection
;
return
walker
.
getRootNode
(
)
.
then
(
aRootNode
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
rootNode
=
aRootNode
;
if
(
this
.
selectionCssSelector
)
{
return
walker
.
querySelector
(
rootNode
this
.
selectionCssSelector
)
;
}
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
walker
.
querySelector
(
rootNode
"
body
"
)
;
}
)
.
then
(
front
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
if
(
front
)
{
return
front
;
}
return
this
.
walker
.
documentElement
(
)
;
}
)
.
then
(
node
=
>
{
if
(
hasNavigated
(
)
)
{
return
promise
.
reject
(
"
navigated
;
resolution
of
_defaultNode
aborted
"
)
;
}
this
.
_defaultNode
=
node
;
return
node
;
}
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
set
target
(
value
)
{
this
.
_target
=
value
;
}
markDirty
:
function
(
)
{
this
.
isDirty
=
true
;
}
setupSearchBox
:
function
(
)
{
this
.
searchBox
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchbox
"
)
;
this
.
searchResultsLabel
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
searchlabel
"
)
;
this
.
search
=
new
InspectorSearch
(
this
this
.
searchBox
)
;
this
.
search
.
on
(
"
search
-
cleared
"
this
.
_updateSearchResultsLabel
)
;
this
.
search
.
on
(
"
search
-
result
"
this
.
_updateSearchResultsLabel
)
;
}
get
searchSuggestions
(
)
{
return
this
.
search
.
autocompleter
;
}
_updateSearchResultsLabel
:
function
(
event
result
)
{
let
str
=
"
"
;
if
(
event
!
=
=
"
search
-
cleared
"
)
{
if
(
result
)
{
str
=
strings
.
formatStringFromName
(
"
inspector
.
searchResultsCount2
"
[
result
.
resultsIndex
+
1
result
.
resultsLength
]
2
)
;
}
else
{
str
=
strings
.
GetStringFromName
(
"
inspector
.
searchResultsNone
"
)
;
}
}
this
.
searchResultsLabel
.
textContent
=
str
;
}
setupSidebar
:
function
(
)
{
let
tabbox
=
this
.
panelDoc
.
querySelector
(
"
#
inspector
-
sidebar
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
tabbox
this
"
inspector
"
{
showAllTabsMenu
:
true
}
)
;
let
defaultTab
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
this
.
_setDefaultSidebar
=
(
event
toolId
)
=
>
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
inspector
.
activeSidebar
"
toolId
)
;
}
;
this
.
sidebar
.
on
(
"
select
"
this
.
_setDefaultSidebar
)
;
this
.
ruleview
=
new
RuleViewTool
(
this
this
.
panelWin
)
;
this
.
computedview
=
new
ComputedViewTool
(
this
this
.
panelWin
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
fontinspector
.
enabled
"
)
&
&
this
.
canGetUsedFontFaces
)
{
this
.
fontInspector
=
new
FontInspector
(
this
this
.
panelWin
)
;
this
.
panelDoc
.
getElementById
(
"
sidebar
-
tab
-
fontinspector
"
)
.
hidden
=
false
;
}
this
.
layoutview
=
new
LayoutView
(
this
this
.
panelWin
)
;
if
(
this
.
target
.
form
.
animationsActor
)
{
this
.
sidebar
.
addTab
(
"
animationinspector
"
"
chrome
:
/
/
devtools
/
content
/
animationinspector
/
animation
-
inspector
.
xhtml
"
"
animationinspector
"
=
=
defaultTab
)
;
}
this
.
sidebar
.
show
(
defaultTab
)
;
this
.
setupSidebarToggle
(
)
;
}
setupSidebarToggle
:
function
(
)
{
this
.
_paneToggleButton
=
this
.
panelDoc
.
getElementById
(
"
inspector
-
pane
-
toggle
"
)
;
this
.
_paneToggleButton
.
addEventListener
(
"
mousedown
"
this
.
onPaneToggleButtonClicked
)
;
}
onNewRoot
:
function
(
)
{
this
.
_defaultNode
=
null
;
this
.
selection
.
setNodeFront
(
null
)
;
this
.
_destroyMarkup
(
)
;
this
.
isDirty
=
false
;
let
onNodeSelected
=
defaultNode
=
>
{
if
(
this
.
_pendingSelection
!
=
onNodeSelected
)
{
return
;
}
this
.
_pendingSelection
=
null
;
this
.
selection
.
setNodeFront
(
defaultNode
"
navigateaway
"
)
;
this
.
_initMarkup
(
)
;
this
.
once
(
"
markuploaded
"
(
)
=
>
{
if
(
!
this
.
markup
)
{
return
;
}
this
.
markup
.
expandNode
(
this
.
selection
.
nodeFront
)
;
this
.
emit
(
"
new
-
root
"
)
;
}
)
;
}
;
this
.
_pendingSelection
=
onNodeSelected
;
this
.
_getDefaultNodeForSelection
(
)
.
then
(
onNodeSelected
console
.
error
)
;
}
_selectionCssSelector
:
null
set
selectionCssSelector
(
cssSelector
=
null
)
{
if
(
this
.
_panelDestroyer
)
{
return
;
}
this
.
_selectionCssSelector
=
{
selector
:
cssSelector
url
:
this
.
_target
.
url
}
;
}
get
selectionCssSelector
(
)
{
if
(
this
.
_selectionCssSelector
&
&
this
.
_selectionCssSelector
.
url
=
=
=
this
.
_target
.
url
)
{
return
this
.
_selectionCssSelector
.
selector
;
}
else
{
return
null
;
}
}
canAddHTMLChild
:
function
(
)
{
let
selection
=
this
.
selection
;
let
invalidTagNames
=
[
"
html
"
"
iframe
"
]
;
return
selection
.
isHTMLNode
(
)
&
&
selection
.
isElementNode
(
)
&
&
!
selection
.
isPseudoElementNode
(
)
&
&
!
selection
.
isAnonymousNode
(
)
&
&
invalidTagNames
.
indexOf
(
selection
.
nodeFront
.
nodeName
.
toLowerCase
(
)
)
=
=
=
-
1
;
}
onNewSelection
:
function
(
event
value
reason
)
{
if
(
reason
=
=
=
"
selection
-
destroy
"
)
{
return
;
}
let
selection
=
this
.
selection
.
nodeFront
;
let
btn
=
this
.
panelDoc
.
querySelector
(
"
#
inspector
-
element
-
add
-
button
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
btn
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
btn
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
this
.
canGetUniqueSelector
&
&
this
.
selection
.
isElementNode
(
)
)
{
selection
.
getUniqueSelector
(
)
.
then
(
selector
=
>
{
this
.
selectionCssSelector
=
selector
;
}
)
.
then
(
null
e
=
>
{
if
(
!
this
.
_panelDestroyer
)
{
console
.
error
(
e
)
;
}
else
{
console
.
warn
(
"
Could
not
set
the
unique
selector
for
the
newly
"
+
"
selected
node
the
inspector
was
destroyed
.
"
)
;
}
}
)
;
}
let
selfUpdate
=
this
.
updating
(
"
inspector
-
panel
"
)
;
Services
.
tm
.
mainThread
.
dispatch
(
(
)
=
>
{
try
{
selfUpdate
(
selection
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
updating
:
function
(
name
)
{
if
(
this
.
_updateProgress
&
&
this
.
_updateProgress
.
node
!
=
this
.
selection
.
nodeFront
)
{
this
.
cancelUpdate
(
)
;
}
if
(
!
this
.
_updateProgress
)
{
let
self
=
this
;
this
.
_updateProgress
=
{
node
:
this
.
selection
.
nodeFront
outstanding
:
new
Set
(
)
checkDone
:
function
(
)
{
if
(
this
!
=
=
self
.
_updateProgress
)
{
return
;
}
if
(
!
self
.
selection
|
|
(
this
.
node
!
=
=
self
.
selection
.
nodeFront
)
)
{
self
.
cancelUpdate
(
)
;
return
;
}
if
(
this
.
outstanding
.
size
!
=
=
0
)
{
return
;
}
self
.
_updateProgress
=
null
;
self
.
emit
(
"
inspector
-
updated
"
name
)
;
}
}
;
}
let
progress
=
this
.
_updateProgress
;
let
done
=
function
(
)
{
progress
.
outstanding
.
delete
(
done
)
;
progress
.
checkDone
(
)
;
}
;
progress
.
outstanding
.
add
(
done
)
;
return
done
;
}
cancelUpdate
:
function
(
)
{
this
.
_updateProgress
=
null
;
}
onBeforeNewSelection
:
function
(
event
node
)
{
if
(
this
.
breadcrumbs
.
indexOf
(
node
)
=
=
-
1
)
{
this
.
clearPseudoClasses
(
)
;
}
}
onDetached
:
function
(
event
parentNode
)
{
this
.
breadcrumbs
.
cutAfter
(
this
.
breadcrumbs
.
indexOf
(
parentNode
)
)
;
this
.
selection
.
setNodeFront
(
parentNode
?
parentNode
:
this
.
_defaultNode
"
detached
"
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_panelDestroyer
)
{
return
this
.
_panelDestroyer
;
}
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
new
-
root
"
this
.
onNewRoot
)
;
this
.
pageStyle
=
null
;
}
this
.
cancelUpdate
(
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onBeforeNavigate
)
;
this
.
target
.
off
(
"
thread
-
paused
"
this
.
updateDebuggerPausedWarning
)
;
this
.
target
.
off
(
"
thread
-
resumed
"
this
.
updateDebuggerPausedWarning
)
;
this
.
_toolbox
.
off
(
"
select
"
this
.
updateDebuggerPausedWarning
)
;
if
(
this
.
ruleview
)
{
this
.
ruleview
.
destroy
(
)
;
}
if
(
this
.
computedview
)
{
this
.
computedview
.
destroy
(
)
;
}
if
(
this
.
fontInspector
)
{
this
.
fontInspector
.
destroy
(
)
;
}
if
(
this
.
layoutview
)
{
this
.
layoutview
.
destroy
(
)
;
}
this
.
sidebar
.
off
(
"
select
"
this
.
_setDefaultSidebar
)
;
let
sidebarDestroyer
=
this
.
sidebar
.
destroy
(
)
;
this
.
sidebar
=
null
;
this
.
nodemenu
.
removeEventListener
(
"
popupshowing
"
this
.
_setupNodeMenu
true
)
;
this
.
nodemenu
.
removeEventListener
(
"
popuphiding
"
this
.
_resetNodeMenu
true
)
;
this
.
breadcrumbs
.
destroy
(
)
;
this
.
_paneToggleButton
.
removeEventListener
(
"
mousedown
"
this
.
onPaneToggleButtonClicked
)
;
this
.
_paneToggleButton
=
null
;
this
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNewSelection
)
;
this
.
selection
.
off
(
"
before
-
new
-
node
"
this
.
onBeforeNewSelection
)
;
this
.
selection
.
off
(
"
before
-
new
-
node
-
front
"
this
.
onBeforeNewSelection
)
;
this
.
selection
.
off
(
"
detached
-
front
"
this
.
onDetached
)
;
let
markupDestroyer
=
this
.
_destroyMarkup
(
)
;
this
.
panelWin
.
inspector
=
null
;
this
.
target
=
null
;
this
.
panelDoc
=
null
;
this
.
panelWin
=
null
;
this
.
breadcrumbs
=
null
;
this
.
lastNodemenuItem
=
null
;
this
.
nodemenu
=
null
;
this
.
_toolbox
=
null
;
this
.
search
.
destroy
(
)
;
this
.
search
=
null
;
this
.
searchBox
=
null
;
this
.
_panelDestroyer
=
promise
.
all
(
[
sidebarDestroyer
markupDestroyer
]
)
;
return
this
.
_panelDestroyer
;
}
showNodeMenu
:
function
(
aButton
aPosition
aExtraItems
)
{
if
(
aExtraItems
)
{
for
(
let
item
of
aExtraItems
)
{
this
.
nodemenu
.
appendChild
(
item
)
;
}
}
this
.
nodemenu
.
openPopup
(
aButton
aPosition
0
0
true
false
)
;
}
hideNodeMenu
:
function
(
)
{
this
.
nodemenu
.
hidePopup
(
)
;
}
_getClipboardContentForPaste
:
function
(
)
{
let
flavors
=
clipboard
.
currentFlavors
;
if
(
flavors
.
indexOf
(
"
text
"
)
!
=
-
1
|
|
(
flavors
.
indexOf
(
"
html
"
)
!
=
-
1
&
&
flavors
.
indexOf
(
"
image
"
)
=
=
-
1
)
)
{
let
content
=
clipboard
.
get
(
)
;
if
(
content
&
&
content
.
trim
(
)
.
length
>
0
)
{
return
content
;
}
}
return
null
;
}
_setupNodeMenu
:
function
(
event
)
{
let
markupContainer
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
this
.
nodeMenuTriggerInfo
=
markupContainer
.
editor
.
getInfoAtNode
(
event
.
target
.
triggerNode
)
;
let
isSelectionElement
=
this
.
selection
.
isElementNode
(
)
&
&
!
this
.
selection
.
isPseudoElementNode
(
)
;
let
isEditableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
;
let
isDuplicatableElement
=
isSelectionElement
&
&
!
this
.
selection
.
isAnonymousNode
(
)
&
&
!
this
.
selection
.
isRoot
(
)
;
let
isScreenshotable
=
isSelectionElement
&
&
this
.
canGetUniqueSelector
&
&
this
.
selection
.
nodeFront
.
isTreeDisplayed
;
for
(
let
name
of
[
"
hover
"
"
active
"
"
focus
"
]
)
{
let
menu
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pseudo
-
"
+
name
)
;
if
(
isSelectionElement
)
{
let
checked
=
this
.
selection
.
nodeFront
.
hasPseudoClassLock
(
"
:
"
+
name
)
;
menu
.
setAttribute
(
"
checked
"
checked
)
;
menu
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
menu
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
let
deleteNode
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
delete
"
)
;
if
(
isEditableElement
)
{
deleteNode
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
deleteNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
let
addNode
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
add
"
)
;
if
(
this
.
canAddHTMLChild
(
)
)
{
addNode
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
addNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
let
unique
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
copyuniqueselector
"
)
;
let
screenshot
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
screenshotnode
"
)
;
let
duplicateNode
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
duplicatenode
"
)
;
let
copyInnerHTML
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
copyinner
"
)
;
let
copyOuterHTML
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
copyouter
"
)
;
let
scrollIntoView
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
scrollnodeintoview
"
)
;
let
expandAll
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
expand
"
)
;
let
collapse
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
collapse
"
)
;
expandAll
.
setAttribute
(
"
disabled
"
"
true
"
)
;
collapse
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
this
.
selection
.
isNode
(
)
&
&
markupContainer
.
hasChildren
)
{
if
(
markupContainer
.
expanded
)
{
collapse
.
removeAttribute
(
"
disabled
"
)
;
}
expandAll
.
removeAttribute
(
"
disabled
"
)
;
}
this
.
_target
.
actorHasMethod
(
"
domwalker
"
"
duplicateNode
"
)
.
then
(
value
=
>
{
duplicateNode
.
hidden
=
!
value
;
}
)
;
this
.
_target
.
actorHasMethod
(
"
domnode
"
"
scrollIntoView
"
)
.
then
(
value
=
>
{
scrollIntoView
.
hidden
=
!
value
;
}
)
;
if
(
isDuplicatableElement
)
{
duplicateNode
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
duplicateNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
isSelectionElement
)
{
unique
.
removeAttribute
(
"
disabled
"
)
;
copyInnerHTML
.
removeAttribute
(
"
disabled
"
)
;
copyOuterHTML
.
removeAttribute
(
"
disabled
"
)
;
scrollIntoView
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
unique
.
setAttribute
(
"
disabled
"
"
true
"
)
;
copyInnerHTML
.
setAttribute
(
"
disabled
"
"
true
"
)
;
copyOuterHTML
.
setAttribute
(
"
disabled
"
"
true
"
)
;
scrollIntoView
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
!
this
.
canGetUniqueSelector
)
{
unique
.
hidden
=
true
;
}
if
(
isScreenshotable
)
{
screenshot
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
screenshot
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
_setupNodeLinkMenu
(
)
;
let
editHTML
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
edithtml
"
)
;
if
(
isEditableElement
&
&
this
.
isOuterHTMLEditable
)
{
editHTML
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
editHTML
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
let
pasteOuterHTML
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pasteouterhtml
"
)
;
let
pasteInnerHTML
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pasteinnerhtml
"
)
;
let
pasteBefore
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pastebefore
"
)
;
let
pasteAfter
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pasteafter
"
)
;
let
pasteFirstChild
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pastefirstchild
"
)
;
let
pasteLastChild
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
pastelastchild
"
)
;
if
(
isEditableElement
&
&
this
.
_getClipboardContentForPaste
(
)
)
{
pasteInnerHTML
.
disabled
=
!
this
.
canPasteInnerOrAdjacentHTML
;
pasteOuterHTML
.
disabled
=
!
this
.
isOuterHTMLEditable
;
pasteBefore
.
disabled
=
pasteAfter
.
disabled
=
!
this
.
canPasteInnerOrAdjacentHTML
|
|
this
.
selection
.
isRoot
(
)
|
|
this
.
selection
.
isBodyNode
(
)
|
|
this
.
selection
.
isHeadNode
(
)
;
pasteFirstChild
.
disabled
=
pasteLastChild
.
disabled
=
!
this
.
canPasteInnerOrAdjacentHTML
|
|
(
this
.
selection
.
isHTMLNode
(
)
&
&
this
.
selection
.
isRoot
(
)
)
;
}
else
{
pasteOuterHTML
.
disabled
=
true
;
pasteInnerHTML
.
disabled
=
true
;
pasteBefore
.
disabled
=
true
;
pasteAfter
.
disabled
=
true
;
pasteFirstChild
.
disabled
=
true
;
pasteLastChild
.
disabled
=
true
;
}
let
copyImageData
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
copyimagedatauri
"
)
;
if
(
isSelectionElement
&
&
markupContainer
&
&
markupContainer
.
isPreviewable
(
)
)
{
copyImageData
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
copyImageData
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
_setupAttributeMenu
(
isEditableElement
)
;
}
_setupAttributeMenu
:
function
(
isEditableElement
)
{
let
addAttribute
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
add
-
attribute
"
)
;
let
editAttribute
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
edit
-
attribute
"
)
;
let
removeAttribute
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
remove
-
attribute
"
)
;
let
nodeInfo
=
this
.
nodeMenuTriggerInfo
;
if
(
isEditableElement
)
{
addAttribute
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
addAttribute
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
isEditableElement
&
&
nodeInfo
&
&
nodeInfo
.
type
=
=
=
"
attribute
"
)
{
editAttribute
.
removeAttribute
(
"
disabled
"
)
;
editAttribute
.
setAttribute
(
"
label
"
strings
.
formatStringFromName
(
"
inspector
.
menu
.
editAttribute
.
label
"
[
"
{
nodeInfo
.
name
}
"
]
1
)
)
;
removeAttribute
.
removeAttribute
(
"
disabled
"
)
;
removeAttribute
.
setAttribute
(
"
label
"
strings
.
formatStringFromName
(
"
inspector
.
menu
.
removeAttribute
.
label
"
[
"
{
nodeInfo
.
name
}
"
]
1
)
)
;
}
else
{
editAttribute
.
setAttribute
(
"
disabled
"
"
true
"
)
;
editAttribute
.
setAttribute
(
"
label
"
strings
.
formatStringFromName
(
"
inspector
.
menu
.
editAttribute
.
label
"
[
'
'
]
1
)
)
;
removeAttribute
.
setAttribute
(
"
disabled
"
"
true
"
)
;
removeAttribute
.
setAttribute
(
"
label
"
strings
.
formatStringFromName
(
"
inspector
.
menu
.
removeAttribute
.
label
"
[
'
'
]
1
)
)
;
}
}
_resetNodeMenu
:
function
(
)
{
while
(
this
.
lastNodemenuItem
.
nextSibling
)
{
let
toDelete
=
this
.
lastNodemenuItem
.
nextSibling
;
toDelete
.
parentNode
.
removeChild
(
toDelete
)
;
}
}
_setupNodeLinkMenu
:
function
(
)
{
let
linkSeparator
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
link
-
separator
"
)
;
let
linkFollow
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
link
-
follow
"
)
;
let
linkCopy
=
this
.
panelDoc
.
getElementById
(
"
node
-
menu
-
link
-
copy
"
)
;
linkSeparator
.
setAttribute
(
"
hidden
"
"
true
"
)
;
linkFollow
.
setAttribute
(
"
hidden
"
"
true
"
)
;
linkCopy
.
setAttribute
(
"
hidden
"
"
true
"
)
;
let
popupNode
=
this
.
panelDoc
.
popupNode
;
if
(
!
popupNode
|
|
!
popupNode
.
classList
.
contains
(
"
link
"
)
)
{
return
;
}
let
type
=
popupNode
.
dataset
.
type
;
if
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
{
this
.
target
.
actorHasMethod
(
"
inspector
"
"
resolveRelativeURL
"
)
.
then
(
canResolve
=
>
{
if
(
!
canResolve
)
{
return
;
}
linkSeparator
.
removeAttribute
(
"
hidden
"
)
;
if
(
type
=
=
=
"
uri
"
&
&
!
this
.
target
.
chrome
)
{
linkFollow
.
removeAttribute
(
"
hidden
"
)
;
linkFollow
.
setAttribute
(
"
label
"
strings
.
GetStringFromName
(
"
inspector
.
menu
.
openUrlInNewTab
.
label
"
)
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
linkFollow
.
removeAttribute
(
"
hidden
"
)
;
linkFollow
.
setAttribute
(
"
label
"
toolboxStrings
.
GetStringFromName
(
"
toolbox
.
viewCssSourceInStyleEditor
.
label
"
)
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
linkFollow
.
removeAttribute
(
"
hidden
"
)
;
linkFollow
.
setAttribute
(
"
label
"
toolboxStrings
.
GetStringFromName
(
"
toolbox
.
viewJsSourceInDebugger
.
label
"
)
)
;
}
linkCopy
.
removeAttribute
(
"
hidden
"
)
;
linkCopy
.
setAttribute
(
"
label
"
strings
.
GetStringFromName
(
"
inspector
.
menu
.
copyUrlToClipboard
.
label
"
)
)
;
}
console
.
error
)
;
}
else
if
(
type
=
=
=
"
idref
"
)
{
linkSeparator
.
removeAttribute
(
"
hidden
"
)
;
linkFollow
.
removeAttribute
(
"
hidden
"
)
;
linkFollow
.
setAttribute
(
"
label
"
strings
.
formatStringFromName
(
"
inspector
.
menu
.
selectElement
.
label
"
[
popupNode
.
dataset
.
link
]
1
)
)
;
}
}
_initMarkup
:
function
(
)
{
let
doc
=
this
.
panelDoc
;
this
.
_markupBox
=
doc
.
getElementById
(
"
markup
-
box
"
)
;
this
.
_markupFrame
=
doc
.
createElement
(
"
iframe
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
context
"
"
inspector
-
node
-
popup
"
)
;
this
.
_markupFrame
.
addEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupBox
.
setAttribute
(
"
collapsed
"
true
)
;
this
.
_markupBox
.
appendChild
(
this
.
_markupFrame
)
;
this
.
_markupFrame
.
setAttribute
(
"
src
"
"
chrome
:
/
/
devtools
/
content
/
inspector
/
markup
/
markup
.
xhtml
"
)
;
this
.
_markupFrame
.
setAttribute
(
"
aria
-
label
"
strings
.
GetStringFromName
(
"
inspector
.
panelLabel
.
markupView
"
)
)
;
}
_onMarkupFrameLoad
:
function
(
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
this
.
_markupFrame
.
contentWindow
.
focus
(
)
;
this
.
_markupBox
.
removeAttribute
(
"
collapsed
"
)
;
let
controllerWindow
=
this
.
_toolbox
.
doc
.
defaultView
;
this
.
markup
=
new
MarkupView
(
this
this
.
_markupFrame
controllerWindow
)
;
this
.
emit
(
"
markuploaded
"
)
;
}
_destroyMarkup
:
function
(
)
{
let
destroyPromise
;
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
removeEventListener
(
"
load
"
this
.
_onMarkupFrameLoad
true
)
;
}
if
(
this
.
markup
)
{
destroyPromise
=
this
.
markup
.
destroy
(
)
;
this
.
markup
=
null
;
}
else
{
destroyPromise
=
promise
.
resolve
(
)
;
}
if
(
this
.
_markupFrame
)
{
this
.
_markupFrame
.
parentNode
.
removeChild
(
this
.
_markupFrame
)
;
this
.
_markupFrame
=
null
;
}
this
.
_markupBox
=
null
;
return
destroyPromise
;
}
onPaneToggleButtonClicked
:
function
(
e
)
{
let
sidePane
=
this
.
panelDoc
.
querySelector
(
"
#
inspector
-
sidebar
"
)
;
let
button
=
this
.
_paneToggleButton
;
let
isVisible
=
!
button
.
hasAttribute
(
"
pane
-
collapsed
"
)
;
if
(
isVisible
)
{
let
rect
=
sidePane
.
getBoundingClientRect
(
)
;
if
(
!
sidePane
.
hasAttribute
(
"
width
"
)
)
{
sidePane
.
setAttribute
(
"
width
"
rect
.
width
)
;
}
sidePane
.
setAttribute
(
"
height
"
rect
.
height
)
;
}
ViewHelpers
.
togglePane
(
{
visible
:
!
isVisible
animated
:
true
delayed
:
true
}
sidePane
)
;
if
(
isVisible
)
{
button
.
setAttribute
(
"
pane
-
collapsed
"
"
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
strings
.
GetStringFromName
(
"
inspector
.
expandPane
"
)
)
;
}
else
{
button
.
removeAttribute
(
"
pane
-
collapsed
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
strings
.
GetStringFromName
(
"
inspector
.
collapsePane
"
)
)
;
}
}
addNode
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
canAddHTMLChild
(
)
)
{
return
;
}
let
html
=
"
<
div
>
<
/
div
>
"
;
let
onMutations
=
this
.
once
(
"
markupmutation
"
)
;
let
{
nodes
}
=
yield
this
.
walker
.
insertAdjacentHTML
(
this
.
selection
.
nodeFront
"
beforeEnd
"
html
)
;
yield
onMutations
;
this
.
selection
.
setNodeFront
(
nodes
[
0
]
)
;
}
)
togglePseudoClass
:
function
(
aPseudo
)
{
if
(
this
.
selection
.
isElementNode
(
)
)
{
let
node
=
this
.
selection
.
nodeFront
;
if
(
node
.
hasPseudoClassLock
(
aPseudo
)
)
{
return
this
.
walker
.
removePseudoClassLock
(
node
aPseudo
{
parents
:
true
}
)
;
}
let
hierarchical
=
aPseudo
=
=
"
:
hover
"
|
|
aPseudo
=
=
"
:
active
"
;
return
this
.
walker
.
addPseudoClassLock
(
node
aPseudo
{
parents
:
hierarchical
}
)
;
}
}
showDOMProperties
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
jsterm
.
execute
(
"
inspect
(
0
)
"
)
;
jsterm
.
focus
(
)
;
}
)
;
}
useInConsole
:
function
(
)
{
this
.
_toolbox
.
openSplitConsole
(
)
.
then
(
(
)
=
>
{
let
panel
=
this
.
_toolbox
.
getPanel
(
"
webconsole
"
)
;
let
jsterm
=
panel
.
hud
.
jsterm
;
let
evalString
=
{
let
i
=
0
;
while
(
window
.
hasOwnProperty
(
"
temp
"
+
i
)
&
&
i
<
1000
)
{
i
+
+
;
}
window
[
"
temp
"
+
i
]
=
0
;
"
temp
"
+
i
;
}
;
let
options
=
{
selectedNodeActor
:
this
.
selection
.
nodeFront
.
actorID
}
;
jsterm
.
requestEvaluation
(
evalString
options
)
.
then
(
(
res
)
=
>
{
jsterm
.
setInputValue
(
res
.
result
)
;
this
.
emit
(
"
console
-
var
-
ready
"
)
;
}
)
;
}
)
;
}
clearPseudoClasses
:
function
(
)
{
if
(
!
this
.
walker
)
{
return
;
}
return
this
.
walker
.
clearPseudoClassLocks
(
)
.
then
(
null
console
.
error
)
;
}
editHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
beginEditingOuterHTML
(
this
.
selection
.
nodeFront
)
;
}
}
pasteOuterHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeOuterHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeOuterHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteInnerHTML
:
function
(
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
getNodeInnerHTML
(
node
)
.
then
(
oldContent
=
>
{
this
.
markup
.
updateNodeInnerHTML
(
node
content
oldContent
)
;
}
)
;
}
pasteAdjacentHTML
:
function
(
position
)
{
let
content
=
this
.
_getClipboardContentForPaste
(
)
;
if
(
!
content
)
return
promise
.
reject
(
"
No
clipboard
content
for
paste
"
)
;
let
node
=
this
.
selection
.
nodeFront
;
return
this
.
markup
.
insertAdjacentHTMLToNode
(
node
position
content
)
;
}
copyInnerHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
_copyLongString
(
this
.
walker
.
innerHTML
(
this
.
selection
.
nodeFront
)
)
;
}
copyOuterHTML
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
let
node
=
this
.
selection
.
nodeFront
;
switch
(
node
.
nodeType
)
{
case
Ci
.
nsIDOMNode
.
ELEMENT_NODE
:
this
.
_copyLongString
(
this
.
walker
.
outerHTML
(
node
)
)
;
break
;
case
Ci
.
nsIDOMNode
.
COMMENT_NODE
:
this
.
_getLongString
(
node
.
getNodeValue
(
)
)
.
then
(
comment
=
>
{
clipboardHelper
.
copyString
(
"
<
!
-
-
"
+
comment
+
"
-
-
>
"
)
;
}
)
;
break
;
case
Ci
.
nsIDOMNode
.
DOCUMENT_TYPE_NODE
:
clipboardHelper
.
copyString
(
node
.
doctypeString
)
;
break
;
}
}
copyImageDataUri
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
if
(
container
&
&
container
.
isPreviewable
(
)
)
{
container
.
copyImageDataUri
(
)
;
}
}
_copyLongString
:
function
(
longStringActorPromise
)
{
return
this
.
_getLongString
(
longStringActorPromise
)
.
then
(
string
=
>
{
clipboardHelper
.
copyString
(
string
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
_getLongString
:
function
(
longStringActorPromise
)
{
return
longStringActorPromise
.
then
(
longStringActor
=
>
{
return
longStringActor
.
string
(
)
.
then
(
string
=
>
{
longStringActor
.
release
(
)
.
catch
(
Cu
.
reportError
)
;
return
string
;
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
copyUniqueSelector
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
selection
.
nodeFront
.
getUniqueSelector
(
)
.
then
(
(
selector
)
=
>
{
clipboardHelper
.
copyString
(
selector
)
;
}
)
.
then
(
null
console
.
error
)
;
}
screenshotNode
:
function
(
)
{
CommandUtils
.
createRequisition
(
this
.
_target
{
environment
:
CommandUtils
.
createEnvironment
(
this
'
_target
'
)
}
)
.
then
(
requisition
=
>
{
requisition
.
updateExec
(
"
screenshot
-
-
selector
'
"
+
this
.
selectionCssSelector
+
"
'
"
)
;
}
)
;
}
scrollNodeIntoView
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
)
{
return
;
}
this
.
selection
.
nodeFront
.
scrollIntoView
(
)
;
}
duplicateNode
:
function
(
)
{
let
selection
=
this
.
selection
;
if
(
!
selection
.
isElementNode
(
)
|
|
selection
.
isRoot
(
)
|
|
selection
.
isAnonymousNode
(
)
|
|
selection
.
isPseudoElementNode
(
)
)
{
return
;
}
this
.
walker
.
duplicateNode
(
selection
.
nodeFront
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
deleteNode
:
function
(
)
{
if
(
!
this
.
selection
.
isNode
(
)
|
|
this
.
selection
.
isRoot
(
)
)
{
return
;
}
if
(
this
.
markup
)
{
this
.
markup
.
deleteNode
(
this
.
selection
.
nodeFront
)
;
}
else
{
this
.
walker
.
removeNode
(
this
.
selection
.
nodeFront
)
;
}
}
onAddAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
addAttribute
(
)
;
}
onEditAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
editAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
onRemoveAttribute
:
function
(
)
{
let
container
=
this
.
markup
.
getContainer
(
this
.
selection
.
nodeFront
)
;
container
.
removeAttribute
(
this
.
nodeMenuTriggerInfo
.
name
)
;
}
expandNode
:
function
(
)
{
this
.
markup
.
expandAll
(
this
.
selection
.
nodeFront
)
;
}
collapseNode
:
function
(
)
{
this
.
markup
.
collapseNode
(
this
.
selection
.
nodeFront
)
;
}
onFollowLink
:
function
(
)
{
let
type
=
this
.
panelDoc
.
popupNode
.
dataset
.
type
;
let
link
=
this
.
panelDoc
.
popupNode
.
dataset
.
link
;
this
.
followAttributeLink
(
type
link
)
;
}
followAttributeLink
:
function
(
type
link
)
{
if
(
!
type
|
|
!
link
)
{
return
;
}
if
(
type
=
=
=
"
uri
"
|
|
type
=
=
=
"
cssresource
"
|
|
type
=
=
=
"
jsresource
"
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
if
(
type
=
=
=
"
uri
"
)
{
let
browserWin
=
this
.
target
.
tab
.
ownerDocument
.
defaultView
;
browserWin
.
openUILinkIn
(
url
"
tab
"
)
;
}
else
if
(
type
=
=
=
"
cssresource
"
)
{
return
this
.
toolbox
.
viewSourceInStyleEditor
(
url
)
;
}
else
if
(
type
=
=
=
"
jsresource
"
)
{
return
this
.
toolbox
.
viewSourceInDebugger
(
url
)
;
}
}
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
else
if
(
type
=
=
"
idref
"
)
{
this
.
walker
.
document
(
this
.
selection
.
nodeFront
)
.
then
(
doc
=
>
{
return
this
.
walker
.
querySelector
(
doc
"
#
"
+
CSS
.
escape
(
link
)
)
.
then
(
node
=
>
{
if
(
!
node
)
{
this
.
emit
(
"
idref
-
attribute
-
link
-
failed
"
)
;
return
;
}
this
.
selection
.
setNodeFront
(
node
)
;
}
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
}
onCopyLink
:
function
(
)
{
let
link
=
this
.
panelDoc
.
popupNode
.
dataset
.
link
;
this
.
copyAttributeLink
(
link
)
;
}
copyAttributeLink
:
function
(
link
)
{
this
.
inspector
.
resolveRelativeURL
(
link
this
.
selection
.
nodeFront
)
.
then
(
url
=
>
{
clipboardHelper
.
copyString
(
url
)
;
}
console
.
error
)
;
}
}
;
