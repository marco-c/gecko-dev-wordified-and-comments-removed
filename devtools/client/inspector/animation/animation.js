"
use
strict
"
;
const
{
createElement
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
App
=
createFactory
(
require
(
"
.
/
components
/
App
"
)
)
;
const
CurrentTimeTimer
=
require
(
"
.
/
current
-
time
-
timer
"
)
;
const
{
updateAnimations
updateDetailVisibility
updateElementPickerEnabled
updateHighlightedNode
updatePlaybackRates
updateSelectedAnimation
updateSidebarSize
}
=
require
(
"
.
/
actions
/
animations
"
)
;
const
{
hasAnimationIterationCountInfinite
hasRunningAnimation
}
=
require
(
"
.
/
utils
/
utils
"
)
;
class
AnimationInspector
{
constructor
(
inspector
win
)
{
this
.
inspector
=
inspector
;
this
.
win
=
win
;
this
.
addAnimationsCurrentTimeListener
=
this
.
addAnimationsCurrentTimeListener
.
bind
(
this
)
;
this
.
getAnimatedPropertyMap
=
this
.
getAnimatedPropertyMap
.
bind
(
this
)
;
this
.
getAnimationsCurrentTime
=
this
.
getAnimationsCurrentTime
.
bind
(
this
)
;
this
.
getComputedStyle
=
this
.
getComputedStyle
.
bind
(
this
)
;
this
.
getNodeFromActor
=
this
.
getNodeFromActor
.
bind
(
this
)
;
this
.
removeAnimationsCurrentTimeListener
=
this
.
removeAnimationsCurrentTimeListener
.
bind
(
this
)
;
this
.
rewindAnimationsCurrentTime
=
this
.
rewindAnimationsCurrentTime
.
bind
(
this
)
;
this
.
selectAnimation
=
this
.
selectAnimation
.
bind
(
this
)
;
this
.
setAnimationsCurrentTime
=
this
.
setAnimationsCurrentTime
.
bind
(
this
)
;
this
.
setAnimationsPlaybackRate
=
this
.
setAnimationsPlaybackRate
.
bind
(
this
)
;
this
.
setAnimationsPlayState
=
this
.
setAnimationsPlayState
.
bind
(
this
)
;
this
.
setDetailVisibility
=
this
.
setDetailVisibility
.
bind
(
this
)
;
this
.
setHighlightedNode
=
this
.
setHighlightedNode
.
bind
(
this
)
;
this
.
setSelectedNode
=
this
.
setSelectedNode
.
bind
(
this
)
;
this
.
simulateAnimation
=
this
.
simulateAnimation
.
bind
(
this
)
;
this
.
simulateAnimationForKeyframesProgressBar
=
this
.
simulateAnimationForKeyframesProgressBar
.
bind
(
this
)
;
this
.
toggleElementPicker
=
this
.
toggleElementPicker
.
bind
(
this
)
;
this
.
update
=
this
.
update
.
bind
(
this
)
;
this
.
onAnimationStateChanged
=
this
.
onAnimationStateChanged
.
bind
(
this
)
;
this
.
onAnimationsCurrentTimeUpdated
=
this
.
onAnimationsCurrentTimeUpdated
.
bind
(
this
)
;
this
.
onAnimationsMutation
=
this
.
onAnimationsMutation
.
bind
(
this
)
;
this
.
onCurrentTimeTimerUpdated
=
this
.
onCurrentTimeTimerUpdated
.
bind
(
this
)
;
this
.
onElementPickerStarted
=
this
.
onElementPickerStarted
.
bind
(
this
)
;
this
.
onElementPickerStopped
=
this
.
onElementPickerStopped
.
bind
(
this
)
;
this
.
onNavigate
=
this
.
onNavigate
.
bind
(
this
)
;
this
.
onSidebarResized
=
this
.
onSidebarResized
.
bind
(
this
)
;
this
.
onSidebarSelectionChanged
=
this
.
onSidebarSelectionChanged
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
emit
=
this
.
emit
.
bind
(
this
)
;
this
.
init
(
)
;
}
init
(
)
{
const
{
onShowBoxModelHighlighterForNode
}
=
this
.
inspector
.
getCommonComponentProps
(
)
;
const
{
onHideBoxModelHighlighter
}
=
this
.
inspector
.
getPanel
(
"
boxmodel
"
)
.
getComponentProps
(
)
;
const
{
addAnimationsCurrentTimeListener
emit
:
emitEventForTest
getAnimatedPropertyMap
getAnimationsCurrentTime
getComputedStyle
getNodeFromActor
isAnimationsRunning
removeAnimationsCurrentTimeListener
rewindAnimationsCurrentTime
selectAnimation
setAnimationsCurrentTime
setAnimationsPlaybackRate
setAnimationsPlayState
setDetailVisibility
setHighlightedNode
setSelectedNode
simulateAnimation
simulateAnimationForKeyframesProgressBar
toggleElementPicker
}
=
this
;
const
direction
=
this
.
win
.
document
.
dir
;
this
.
_getAnimationsFront
(
)
;
this
.
animationsCurrentTimeListeners
=
[
]
;
this
.
isCurrentTimeSet
=
false
;
const
provider
=
createElement
(
Provider
{
id
:
"
animationinspector
"
key
:
"
animationinspector
"
store
:
this
.
inspector
.
store
}
App
(
{
addAnimationsCurrentTimeListener
direction
emitEventForTest
getAnimatedPropertyMap
getAnimationsCurrentTime
getComputedStyle
getNodeFromActor
isAnimationsRunning
onHideBoxModelHighlighter
onShowBoxModelHighlighterForNode
removeAnimationsCurrentTimeListener
rewindAnimationsCurrentTime
selectAnimation
setAnimationsCurrentTime
setAnimationsPlaybackRate
setAnimationsPlayState
setDetailVisibility
setHighlightedNode
setSelectedNode
simulateAnimation
simulateAnimationForKeyframesProgressBar
toggleElementPicker
}
)
)
;
this
.
provider
=
provider
;
this
.
inspector
.
sidebar
.
on
(
"
select
"
this
.
onSidebarSelectionChanged
)
;
this
.
inspector
.
inspectorFront
.
nodePicker
.
on
(
"
picker
-
started
"
this
.
onElementPickerStarted
)
;
this
.
inspector
.
inspectorFront
.
nodePicker
.
on
(
"
picker
-
stopped
"
this
.
onElementPickerStopped
)
;
this
.
inspector
.
toolbox
.
on
(
"
select
"
this
.
onSidebarSelectionChanged
)
;
}
_getAnimationsFront
(
)
{
if
(
this
.
animationsFrontPromise
)
{
return
this
.
animationsFrontPromise
;
}
this
.
animationsFrontPromise
=
new
Promise
(
async
resolve
=
>
{
const
target
=
this
.
inspector
.
target
;
const
front
=
await
target
.
getFront
(
"
animations
"
)
;
front
.
setWalkerActor
(
this
.
inspector
.
walker
)
;
resolve
(
front
)
;
}
)
;
return
this
.
animationsFrontPromise
;
}
destroy
(
)
{
this
.
setAnimationStateChangedListenerEnabled
(
false
)
;
this
.
inspector
.
off
(
"
new
-
root
"
this
.
onNavigate
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
inspector
.
sidebar
.
off
(
"
select
"
this
.
onSidebarSelectionChanged
)
;
this
.
inspector
.
toolbox
.
off
(
"
inspector
-
sidebar
-
resized
"
this
.
onSidebarResized
)
;
this
.
inspector
.
inspectorFront
.
nodePicker
.
off
(
"
picker
-
started
"
this
.
onElementPickerStarted
)
;
this
.
inspector
.
inspectorFront
.
nodePicker
.
off
(
"
picker
-
stopped
"
this
.
onElementPickerStopped
)
;
this
.
inspector
.
toolbox
.
off
(
"
select
"
this
.
onSidebarSelectionChanged
)
;
this
.
animationsFrontPromise
.
then
(
front
=
>
{
front
.
off
(
"
mutations
"
this
.
onAnimationsMutation
)
;
}
)
;
if
(
this
.
simulatedAnimation
)
{
this
.
simulatedAnimation
.
cancel
(
)
;
this
.
simulatedAnimation
=
null
;
}
if
(
this
.
simulatedElement
)
{
this
.
simulatedElement
.
remove
(
)
;
this
.
simulatedElement
=
null
;
}
if
(
this
.
simulatedAnimationForKeyframesProgressBar
)
{
this
.
simulatedAnimationForKeyframesProgressBar
.
cancel
(
)
;
this
.
simulatedAnimationForKeyframesProgressBar
=
null
;
}
this
.
stopAnimationsCurrentTimeTimer
(
)
;
this
.
inspector
=
null
;
this
.
win
=
null
;
}
get
state
(
)
{
return
this
.
inspector
.
store
.
getState
(
)
.
animations
;
}
addAnimationsCurrentTimeListener
(
listener
)
{
this
.
animationsCurrentTimeListeners
.
push
(
listener
)
;
}
async
doSetCurrentTimes
(
currentTime
)
{
const
{
animations
timeScale
}
=
this
.
state
;
currentTime
=
currentTime
+
timeScale
.
minStartTime
;
const
animationsFront
=
await
this
.
animationsFrontPromise
;
await
animationsFront
.
setCurrentTimes
(
animations
currentTime
true
{
relativeToCreatedTime
:
true
}
)
;
}
async
getAnimatedPropertyMap
(
animation
)
{
const
properties
=
await
animation
.
getProperties
(
)
;
const
animatedPropertyMap
=
new
Map
(
)
;
for
(
const
{
name
values
}
of
properties
)
{
const
keyframes
=
values
.
map
(
(
{
value
offset
easing
distance
=
0
}
)
=
>
{
offset
=
parseFloat
(
offset
.
toFixed
(
3
)
)
;
return
{
value
offset
easing
distance
}
;
}
)
;
animatedPropertyMap
.
set
(
name
keyframes
)
;
}
return
animatedPropertyMap
;
}
getAnimationsCurrentTime
(
)
{
return
this
.
currentTime
;
}
getComputedStyle
(
property
styles
)
{
this
.
simulatedElement
.
style
.
cssText
=
"
"
;
for
(
const
propertyName
in
styles
)
{
this
.
simulatedElement
.
style
.
setProperty
(
propertyName
styles
[
propertyName
]
)
;
}
return
this
.
win
.
getComputedStyle
(
this
.
simulatedElement
)
.
getPropertyValue
(
property
)
;
}
getNodeFromActor
(
actorID
)
{
if
(
!
this
.
inspector
)
{
return
Promise
.
reject
(
"
Animation
inspector
already
destroyed
"
)
;
}
return
this
.
inspector
.
walker
.
getNodeFromActor
(
actorID
[
"
node
"
]
)
;
}
isPanelVisible
(
)
{
return
(
this
.
inspector
&
&
this
.
inspector
.
toolbox
&
&
this
.
inspector
.
sidebar
&
&
this
.
inspector
.
toolbox
.
currentToolId
=
=
=
"
inspector
"
&
&
this
.
inspector
.
sidebar
.
getCurrentTabID
(
)
=
=
=
"
animationinspector
"
)
;
}
onAnimationStateChanged
(
)
{
this
.
updateState
(
[
.
.
.
this
.
state
.
animations
]
)
;
}
onAnimationsCurrentTimeUpdated
(
currentTime
)
{
this
.
currentTime
=
currentTime
;
for
(
const
listener
of
this
.
animationsCurrentTimeListeners
)
{
listener
(
currentTime
)
;
}
}
onCurrentTimeTimerUpdated
(
currentTime
shouldStop
)
{
if
(
shouldStop
)
{
this
.
setAnimationsCurrentTime
(
currentTime
true
)
;
}
else
{
this
.
onAnimationsCurrentTimeUpdated
(
currentTime
)
;
}
}
async
onAnimationsMutation
(
changes
)
{
let
animations
=
[
.
.
.
this
.
state
.
animations
]
;
const
addedAnimations
=
[
]
;
for
(
const
{
type
player
:
animation
}
of
changes
)
{
if
(
type
=
=
=
"
added
"
)
{
if
(
!
animation
.
state
.
type
)
{
continue
;
}
addedAnimations
.
push
(
animation
)
;
animation
.
on
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
else
if
(
type
=
=
=
"
removed
"
)
{
const
index
=
animations
.
indexOf
(
animation
)
;
if
(
index
<
0
)
{
continue
;
}
animations
.
splice
(
index
1
)
;
animation
.
off
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
}
try
{
animations
=
await
this
.
updateAnimations
(
animations
)
;
}
catch
(
_
)
{
console
.
error
(
Updating
Animations
failed
)
;
return
;
}
this
.
updateState
(
animations
.
concat
(
addedAnimations
)
)
;
}
onElementPickerStarted
(
)
{
this
.
inspector
.
store
.
dispatch
(
updateElementPickerEnabled
(
true
)
)
;
}
onElementPickerStopped
(
)
{
this
.
inspector
.
store
.
dispatch
(
updateElementPickerEnabled
(
false
)
)
;
}
onNavigate
(
)
{
this
.
inspector
.
store
.
dispatch
(
updatePlaybackRates
(
)
)
;
}
async
onSidebarSelectionChanged
(
)
{
const
isPanelVisibled
=
this
.
isPanelVisible
(
)
;
if
(
this
.
wasPanelVisibled
=
=
=
isPanelVisibled
)
{
return
;
}
this
.
wasPanelVisibled
=
isPanelVisibled
;
const
animationsFront
=
await
this
.
animationsFrontPromise
;
if
(
this
.
isPanelVisible
(
)
)
{
await
this
.
update
(
)
;
this
.
onSidebarResized
(
null
this
.
inspector
.
getSidebarSize
(
)
)
;
animationsFront
.
on
(
"
mutations
"
this
.
onAnimationsMutation
)
;
this
.
inspector
.
on
(
"
new
-
root
"
this
.
onNavigate
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
inspector
.
toolbox
.
on
(
"
inspector
-
sidebar
-
resized
"
this
.
onSidebarResized
)
;
}
else
{
this
.
stopAnimationsCurrentTimeTimer
(
)
;
animationsFront
.
off
(
"
mutations
"
this
.
onAnimationsMutation
)
;
this
.
inspector
.
off
(
"
new
-
root
"
this
.
onNavigate
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
update
)
;
this
.
inspector
.
toolbox
.
off
(
"
inspector
-
sidebar
-
resized
"
this
.
onSidebarResized
)
;
this
.
setAnimationStateChangedListenerEnabled
(
false
)
;
}
}
onSidebarResized
(
size
)
{
this
.
inspector
.
store
.
dispatch
(
updateSidebarSize
(
size
)
)
;
}
removeAnimationsCurrentTimeListener
(
listener
)
{
this
.
animationsCurrentTimeListeners
=
this
.
animationsCurrentTimeListeners
.
filter
(
l
=
>
l
!
=
=
listener
)
;
}
async
rewindAnimationsCurrentTime
(
)
{
const
{
timeScale
}
=
this
.
state
;
await
this
.
setAnimationsCurrentTime
(
timeScale
.
zeroPositionTime
true
)
;
}
selectAnimation
(
animation
)
{
this
.
inspector
.
store
.
dispatch
(
updateSelectedAnimation
(
animation
)
)
;
}
async
setSelectedNode
(
nodeFront
)
{
if
(
this
.
inspector
.
selection
.
nodeFront
=
=
=
nodeFront
)
{
return
;
}
await
this
.
inspector
.
getCommonComponentProps
(
)
.
setSelectedNode
(
nodeFront
{
reason
:
"
animation
-
panel
"
}
)
;
}
async
setAnimationsCurrentTime
(
currentTime
shouldRefresh
)
{
this
.
stopAnimationsCurrentTimeTimer
(
)
;
this
.
onAnimationsCurrentTimeUpdated
(
currentTime
)
;
if
(
!
shouldRefresh
&
&
this
.
isCurrentTimeSet
)
{
return
;
}
let
animations
=
this
.
state
.
animations
;
this
.
isCurrentTimeSet
=
true
;
try
{
await
this
.
doSetCurrentTimes
(
currentTime
)
;
animations
=
await
this
.
updateAnimations
(
animations
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
;
}
this
.
isCurrentTimeSet
=
false
;
if
(
shouldRefresh
)
{
this
.
updateState
(
animations
)
;
}
}
async
setAnimationsPlaybackRate
(
playbackRate
)
{
let
animations
=
this
.
state
.
animations
;
this
.
setAnimationStateChangedListenerEnabled
(
false
)
;
try
{
const
animationsFront
=
await
this
.
animationsFrontPromise
;
await
animationsFront
.
setPlaybackRates
(
animations
playbackRate
)
;
animations
=
await
this
.
updateAnimations
(
animations
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
;
}
finally
{
this
.
setAnimationStateChangedListenerEnabled
(
true
)
;
}
await
this
.
updateState
(
animations
)
;
}
async
setAnimationsPlayState
(
doPlay
)
{
if
(
typeof
this
.
hasPausePlaySome
=
=
=
"
undefined
"
)
{
this
.
hasPausePlaySome
=
await
this
.
inspector
.
target
.
actorHasMethod
(
"
animations
"
"
pauseSome
"
)
;
}
let
{
animations
timeScale
}
=
this
.
state
;
try
{
if
(
doPlay
&
&
animations
.
every
(
animation
=
>
timeScale
.
getEndTime
(
animation
)
<
=
animation
.
state
.
currentTime
)
)
{
await
this
.
doSetCurrentTimes
(
timeScale
.
zeroPositionTime
)
;
}
const
animationsFront
=
await
this
.
animationsFrontPromise
;
if
(
this
.
hasPausePlaySome
)
{
if
(
doPlay
)
{
await
animationsFront
.
playSome
(
animations
)
;
}
else
{
await
animationsFront
.
pauseSome
(
animations
)
;
}
}
else
if
(
doPlay
)
{
await
animationsFront
.
playAll
(
)
;
}
else
{
await
animationsFront
.
pauseAll
(
)
;
}
animations
=
await
this
.
updateAnimations
(
animations
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
;
}
await
this
.
updateState
(
animations
)
;
}
setAnimationStateChangedListenerEnabled
(
isEnabled
)
{
if
(
isEnabled
)
{
for
(
const
animation
of
this
.
state
.
animations
)
{
animation
.
on
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
}
else
{
for
(
const
animation
of
this
.
state
.
animations
)
{
animation
.
off
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
}
}
setDetailVisibility
(
isVisible
)
{
this
.
inspector
.
store
.
dispatch
(
updateDetailVisibility
(
isVisible
)
)
;
}
async
setHighlightedNode
(
nodeFront
)
{
await
this
.
inspector
.
highlighters
.
hideBoxModelHighlighter
(
)
;
if
(
nodeFront
)
{
await
this
.
inspector
.
highlighters
.
showBoxModelHighlighter
(
nodeFront
{
hideInfoBar
:
true
hideGuides
:
true
}
)
;
}
this
.
inspector
.
store
.
dispatch
(
updateHighlightedNode
(
nodeFront
)
)
;
}
simulateAnimation
(
keyframes
effectTiming
isElementNeeded
)
{
if
(
!
this
.
win
)
{
return
null
;
}
let
targetEl
=
null
;
if
(
isElementNeeded
)
{
if
(
!
this
.
simulatedElement
)
{
this
.
simulatedElement
=
this
.
win
.
document
.
createElement
(
"
div
"
)
;
this
.
win
.
document
.
documentElement
.
appendChild
(
this
.
simulatedElement
)
;
}
else
{
this
.
simulatedElement
.
style
.
cssText
=
"
"
;
}
targetEl
=
this
.
simulatedElement
;
}
if
(
!
this
.
simulatedAnimation
)
{
this
.
simulatedAnimation
=
new
this
.
win
.
Animation
(
)
;
}
this
.
simulatedAnimation
.
effect
=
new
this
.
win
.
KeyframeEffect
(
targetEl
keyframes
effectTiming
)
;
return
this
.
simulatedAnimation
;
}
simulateAnimationForKeyframesProgressBar
(
effectTiming
)
{
if
(
!
this
.
simulatedAnimationForKeyframesProgressBar
)
{
this
.
simulatedAnimationForKeyframesProgressBar
=
new
this
.
win
.
Animation
(
)
;
}
this
.
simulatedAnimationForKeyframesProgressBar
.
effect
=
new
this
.
win
.
KeyframeEffect
(
null
null
effectTiming
)
;
return
this
.
simulatedAnimationForKeyframesProgressBar
;
}
stopAnimationsCurrentTimeTimer
(
)
{
if
(
this
.
currentTimeTimer
)
{
this
.
currentTimeTimer
.
destroy
(
)
;
this
.
currentTimeTimer
=
null
;
}
}
startAnimationsCurrentTimeTimer
(
)
{
const
timeScale
=
this
.
state
.
timeScale
;
const
shouldStopAfterEndTime
=
!
hasAnimationIterationCountInfinite
(
this
.
state
.
animations
)
;
const
currentTimeTimer
=
new
CurrentTimeTimer
(
timeScale
shouldStopAfterEndTime
this
.
win
this
.
onCurrentTimeTimerUpdated
)
;
currentTimeTimer
.
start
(
)
;
this
.
currentTimeTimer
=
currentTimeTimer
;
}
toggleElementPicker
(
)
{
this
.
inspector
.
inspectorFront
.
nodePicker
.
togglePicker
(
)
;
}
async
update
(
)
{
const
done
=
this
.
inspector
.
updating
(
"
animationinspector
"
)
;
const
selection
=
this
.
inspector
.
selection
;
const
animationsFront
=
await
this
.
animationsFrontPromise
;
const
animations
=
selection
.
isConnected
(
)
&
&
selection
.
isElementNode
(
)
?
await
animationsFront
.
getAnimationPlayersForNode
(
selection
.
nodeFront
)
:
[
]
;
this
.
updateState
(
animations
)
;
this
.
setAnimationStateChangedListenerEnabled
(
true
)
;
done
(
)
;
}
async
updateAnimations
(
animations
)
{
let
error
=
null
;
const
promises
=
animations
.
map
(
animation
=
>
{
return
new
Promise
(
resolve
=
>
{
animation
.
refreshState
(
)
.
catch
(
e
=
>
{
error
=
e
;
}
)
.
finally
(
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
if
(
error
)
{
throw
new
Error
(
error
)
;
}
return
animations
.
filter
(
anim
=
>
!
!
anim
.
state
.
type
)
;
}
updateState
(
animations
)
{
if
(
!
this
.
inspector
)
{
return
;
}
this
.
stopAnimationsCurrentTimeTimer
(
)
;
animations
=
animations
.
filter
(
anim
=
>
Math
.
abs
(
anim
.
state
.
delay
)
!
=
=
Infinity
&
&
Math
.
abs
(
anim
.
state
.
endDelay
)
!
=
=
Infinity
)
;
this
.
inspector
.
store
.
dispatch
(
updateAnimations
(
animations
)
)
;
if
(
hasRunningAnimation
(
animations
)
)
{
this
.
startAnimationsCurrentTimeTimer
(
)
;
}
else
{
this
.
onCurrentTimeTimerUpdated
(
this
.
state
.
timeScale
.
getCurrentTime
(
)
)
;
}
}
}
module
.
exports
=
AnimationInspector
;
