"
use
strict
"
;
const
{
createFactory
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
AnimationName
=
createFactory
(
require
(
"
.
/
AnimationName
"
)
)
;
const
DelaySign
=
createFactory
(
require
(
"
.
/
DelaySign
"
)
)
;
const
EndDelaySign
=
createFactory
(
require
(
"
.
/
EndDelaySign
"
)
)
;
const
SummaryGraphPath
=
createFactory
(
require
(
"
.
/
SummaryGraphPath
"
)
)
;
const
{
getFormattedTitle
getFormatStr
getStr
numberWithDecimals
}
=
require
(
"
.
.
/
.
.
/
utils
/
l10n
"
)
;
class
SummaryGraph
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
animation
:
PropTypes
.
object
.
isRequired
emitEventForTest
:
PropTypes
.
func
.
isRequired
getAnimatedPropertyMap
:
PropTypes
.
func
.
isRequired
selectAnimation
:
PropTypes
.
func
.
isRequired
simulateAnimation
:
PropTypes
.
func
.
isRequired
timeScale
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
onClick
(
event
)
{
event
.
stopPropagation
(
)
;
this
.
props
.
selectAnimation
(
this
.
props
.
animation
)
;
}
getTitleText
(
state
)
{
const
getTime
=
time
=
>
getFormatStr
(
"
player
.
timeLabel
"
numberWithDecimals
(
time
/
1000
2
)
)
;
let
text
=
"
"
;
text
+
=
getFormattedTitle
(
state
)
;
text
+
=
"
\
n
"
;
if
(
state
.
delay
)
{
text
+
=
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
delay
)
;
text
+
=
"
\
n
"
;
}
text
+
=
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
;
text
+
=
state
.
duration
=
=
=
Infinity
?
getStr
(
"
player
.
infiniteDurationText
"
)
:
getTime
(
state
.
duration
)
;
text
+
=
"
\
n
"
;
if
(
state
.
endDelay
)
{
text
+
=
getStr
(
"
player
.
animationEndDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
endDelay
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationCount
!
=
=
1
)
{
text
+
=
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
;
text
+
=
state
.
iterationCount
|
|
getStr
(
"
player
.
infiniteIterationCountText
"
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationStart
!
=
=
0
)
{
text
+
=
getFormatStr
(
"
player
.
animationIterationStartLabel2
"
state
.
iterationStart
state
.
duration
=
=
=
Infinity
?
getStr
(
"
player
.
infiniteDurationText
"
)
:
getTime
(
state
.
iterationStart
*
state
.
duration
)
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
easing
&
&
state
.
easing
!
=
=
"
linear
"
)
{
text
+
=
getStr
(
"
player
.
animationOverallEasingLabel
"
)
+
"
"
;
text
+
=
state
.
easing
;
text
+
=
"
\
n
"
;
}
if
(
state
.
fill
&
&
state
.
fill
!
=
=
"
none
"
)
{
text
+
=
getStr
(
"
player
.
animationFillLabel
"
)
+
"
"
;
text
+
=
state
.
fill
;
text
+
=
"
\
n
"
;
}
if
(
state
.
direction
&
&
state
.
direction
!
=
=
"
normal
"
)
{
text
+
=
getStr
(
"
player
.
animationDirectionLabel
"
)
+
"
"
;
text
+
=
state
.
direction
;
text
+
=
"
\
n
"
;
}
if
(
state
.
playbackRate
!
=
=
1
)
{
text
+
=
getStr
(
"
player
.
animationRateLabel
"
)
+
"
"
;
text
+
=
state
.
playbackRate
;
text
+
=
"
\
n
"
;
}
if
(
state
.
animationTimingFunction
&
&
state
.
animationTimingFunction
!
=
=
"
ease
"
)
{
text
+
=
getStr
(
"
player
.
animationTimingFunctionLabel
"
)
+
"
"
;
text
+
=
state
.
animationTimingFunction
;
text
+
=
"
\
n
"
;
}
if
(
state
.
propertyState
)
{
if
(
state
.
propertyState
.
every
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
getStr
(
"
player
.
allPropertiesOnCompositorTooltip
"
)
;
}
else
if
(
state
.
propertyState
.
some
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
getStr
(
"
player
.
somePropertiesOnCompositorTooltip
"
)
;
}
}
else
if
(
state
.
isRunningOnCompositor
)
{
text
+
=
getStr
(
"
player
.
runningOnCompositorTooltip
"
)
;
}
return
text
;
}
render
(
)
{
const
{
animation
emitEventForTest
getAnimatedPropertyMap
simulateAnimation
timeScale
}
=
this
.
props
;
const
{
iterationCount
}
=
animation
.
state
;
const
{
delay
endDelay
}
=
animation
.
state
.
absoluteValues
;
return
dom
.
div
(
{
className
:
"
animation
-
summary
-
graph
"
+
(
animation
.
state
.
isRunningOnCompositor
?
"
compositor
"
:
"
"
)
onClick
:
this
.
onClick
title
:
this
.
getTitleText
(
animation
.
state
)
}
SummaryGraphPath
(
{
animation
emitEventForTest
getAnimatedPropertyMap
simulateAnimation
timeScale
}
)
delay
?
DelaySign
(
{
animation
timeScale
}
)
:
null
iterationCount
&
&
endDelay
?
EndDelaySign
(
{
animation
timeScale
}
)
:
null
animation
.
state
.
name
?
AnimationName
(
{
animation
}
)
:
null
)
;
}
}
module
.
exports
=
SummaryGraph
;
