"
use
strict
"
;
const
{
createFactory
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
AnimationName
=
createFactory
(
require
(
"
.
/
AnimationName
"
)
)
;
const
DelaySign
=
createFactory
(
require
(
"
.
/
DelaySign
"
)
)
;
const
EndDelaySign
=
createFactory
(
require
(
"
.
/
EndDelaySign
"
)
)
;
const
SummaryGraphPath
=
createFactory
(
require
(
"
.
/
SummaryGraphPath
"
)
)
;
const
{
getFormatStr
getStr
numberWithDecimals
}
=
require
(
"
.
.
/
.
.
/
utils
/
l10n
"
)
;
class
SummaryGraph
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
animation
:
PropTypes
.
object
.
isRequired
getAnimatedPropertyMap
:
PropTypes
.
func
.
isRequired
simulateAnimation
:
PropTypes
.
func
.
isRequired
timeScale
:
PropTypes
.
object
.
isRequired
}
;
}
getTitleText
(
state
)
{
const
getTime
=
time
=
>
getFormatStr
(
"
player
.
timeLabel
"
numberWithDecimals
(
time
/
1000
2
)
)
;
let
text
=
"
"
;
text
+
=
getFormattedTitle
(
state
)
;
text
+
=
"
\
n
"
;
if
(
state
.
delay
)
{
text
+
=
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
delay
)
;
text
+
=
"
\
n
"
;
}
text
+
=
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
duration
)
;
text
+
=
"
\
n
"
;
if
(
state
.
endDelay
)
{
text
+
=
getStr
(
"
player
.
animationEndDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
endDelay
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationCount
!
=
=
1
)
{
text
+
=
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
;
text
+
=
state
.
iterationCount
|
|
getStr
(
"
player
.
infiniteIterationCountText
"
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationStart
!
=
=
0
)
{
const
iterationStartTime
=
state
.
iterationStart
*
state
.
duration
/
1000
;
text
+
=
getFormatStr
(
"
player
.
animationIterationStartLabel
"
state
.
iterationStart
numberWithDecimals
(
iterationStartTime
2
)
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
easing
&
&
state
.
easing
!
=
=
"
linear
"
)
{
text
+
=
getStr
(
"
player
.
animationOverallEasingLabel
"
)
+
"
"
;
text
+
=
state
.
easing
;
text
+
=
"
\
n
"
;
}
if
(
state
.
fill
&
&
state
.
fill
!
=
=
"
none
"
)
{
text
+
=
getStr
(
"
player
.
animationFillLabel
"
)
+
"
"
;
text
+
=
state
.
fill
;
text
+
=
"
\
n
"
;
}
if
(
state
.
direction
&
&
state
.
direction
!
=
=
"
normal
"
)
{
text
+
=
getStr
(
"
player
.
animationDirectionLabel
"
)
+
"
"
;
text
+
=
state
.
direction
;
text
+
=
"
\
n
"
;
}
if
(
state
.
playbackRate
!
=
=
1
)
{
text
+
=
getStr
(
"
player
.
animationRateLabel
"
)
+
"
"
;
text
+
=
state
.
playbackRate
;
text
+
=
"
\
n
"
;
}
if
(
state
.
animationTimingFunction
&
&
state
.
animationTimingFunction
!
=
=
"
ease
"
)
{
text
+
=
getStr
(
"
player
.
animationTimingFunctionLabel
"
)
+
"
"
;
text
+
=
state
.
animationTimingFunction
;
text
+
=
"
\
n
"
;
}
if
(
state
.
propertyState
)
{
if
(
state
.
propertyState
.
every
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
getStr
(
"
player
.
allPropertiesOnCompositorTooltip
"
)
;
}
else
if
(
state
.
propertyState
.
some
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
getStr
(
"
player
.
somePropertiesOnCompositorTooltip
"
)
;
}
}
else
if
(
state
.
isRunningOnCompositor
)
{
text
+
=
getStr
(
"
player
.
runningOnCompositorTooltip
"
)
;
}
return
text
;
}
render
(
)
{
const
{
animation
getAnimatedPropertyMap
simulateAnimation
timeScale
}
=
this
.
props
;
return
dom
.
div
(
{
className
:
"
animation
-
summary
-
graph
"
+
(
animation
.
state
.
isRunningOnCompositor
?
"
compositor
"
:
"
"
)
title
:
this
.
getTitleText
(
animation
.
state
)
}
SummaryGraphPath
(
{
animation
getAnimatedPropertyMap
simulateAnimation
timeScale
}
)
animation
.
state
.
delay
?
DelaySign
(
{
animation
timeScale
}
)
:
null
animation
.
state
.
iterationCount
&
&
animation
.
state
.
endDelay
?
EndDelaySign
(
{
animation
timeScale
}
)
:
null
animation
.
state
.
name
?
AnimationName
(
{
animation
}
)
:
null
)
;
}
}
function
getFormattedTitle
(
state
)
{
if
(
!
state
.
type
)
{
return
state
.
name
;
}
if
(
state
.
type
=
=
=
"
scriptanimation
"
&
&
!
state
.
name
)
{
return
getStr
(
"
timeline
.
scriptanimation
.
unnamedLabel
"
)
;
}
return
getFormatStr
(
timeline
.
{
state
.
type
}
.
nameLabel
state
.
name
)
;
}
module
.
exports
=
SummaryGraph
;
