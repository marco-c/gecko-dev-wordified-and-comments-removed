"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
MAX_INFINITE_ANIMATIONS_ITERATIONS
=
10
;
class
TimingPath
extends
PureComponent
{
renderGraph
(
state
helper
)
{
let
mainIterationStartTime
=
0
;
let
iterationStart
=
state
.
iterationStart
;
let
iterationCount
=
state
.
iterationCount
?
state
.
iterationCount
:
Infinity
;
const
pathList
=
[
]
;
if
(
state
.
delay
>
0
)
{
this
.
renderDelay
(
pathList
state
helper
)
;
mainIterationStartTime
=
state
.
delay
;
}
else
{
const
negativeDelayCount
=
-
state
.
delay
/
state
.
duration
;
iterationStart
+
=
negativeDelayCount
;
if
(
iterationCount
!
=
=
Infinity
)
{
iterationCount
-
=
negativeDelayCount
;
}
}
if
(
state
.
duration
=
=
=
Infinity
)
{
this
.
renderInfinityDuration
(
pathList
state
mainIterationStartTime
helper
)
;
return
pathList
;
}
const
firstSectionCount
=
iterationStart
%
1
=
=
=
0
?
0
:
Math
.
min
(
1
-
iterationStart
%
1
iterationCount
)
;
if
(
firstSectionCount
)
{
this
.
renderFirstIteration
(
pathList
state
mainIterationStartTime
firstSectionCount
helper
)
;
}
if
(
iterationCount
=
=
=
Infinity
)
{
this
.
renderInfinity
(
pathList
state
mainIterationStartTime
firstSectionCount
helper
)
;
}
else
{
if
(
state
.
fill
=
=
=
"
both
"
|
|
state
.
fill
=
=
=
"
forwards
"
)
{
this
.
renderForwardsFill
(
pathList
state
mainIterationStartTime
iterationCount
helper
)
;
}
const
middleSectionCount
=
Math
.
floor
(
iterationCount
-
firstSectionCount
)
;
this
.
renderMiddleIterations
(
pathList
state
mainIterationStartTime
firstSectionCount
middleSectionCount
helper
)
;
const
lastSectionCount
=
iterationCount
-
middleSectionCount
-
firstSectionCount
;
if
(
lastSectionCount
)
{
this
.
renderLastIteration
(
pathList
state
mainIterationStartTime
firstSectionCount
middleSectionCount
lastSectionCount
helper
)
;
}
if
(
state
.
endDelay
>
0
)
{
this
.
renderEndDelay
(
pathList
state
mainIterationStartTime
iterationCount
helper
)
;
}
}
return
pathList
;
}
renderDelay
(
pathList
state
helper
)
{
const
startSegment
=
helper
.
getSegment
(
0
)
;
const
endSegment
=
{
x
:
state
.
delay
y
:
startSegment
.
y
}
;
const
segments
=
[
startSegment
endSegment
]
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
delay
-
path
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
renderFirstIteration
(
pathList
state
mainIterationStartTime
firstSectionCount
helper
)
{
const
startTime
=
mainIterationStartTime
;
const
endTime
=
startTime
+
firstSectionCount
*
state
.
duration
;
const
segments
=
helper
.
createPathSegments
(
startTime
endTime
)
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
renderMiddleIterations
(
pathList
state
mainIterationStartTime
firstSectionCount
middleSectionCount
helper
)
{
const
offset
=
mainIterationStartTime
+
firstSectionCount
*
state
.
duration
;
for
(
let
i
=
0
;
i
<
middleSectionCount
;
i
+
+
)
{
const
startTime
=
offset
+
i
*
state
.
duration
;
const
endTime
=
startTime
+
state
.
duration
;
const
segments
=
helper
.
createPathSegments
(
startTime
endTime
)
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
}
renderLastIteration
(
pathList
state
mainIterationStartTime
firstSectionCount
middleSectionCount
lastSectionCount
helper
)
{
const
startTime
=
mainIterationStartTime
+
(
firstSectionCount
+
middleSectionCount
)
*
state
.
duration
;
const
endTime
=
startTime
+
lastSectionCount
*
state
.
duration
;
const
segments
=
helper
.
createPathSegments
(
startTime
endTime
)
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
renderInfinity
(
pathList
state
mainIterationStartTime
firstSectionCount
helper
)
{
let
uncappedInfinityIterationCount
=
(
helper
.
totalDuration
-
firstSectionCount
*
state
.
duration
)
/
state
.
duration
;
uncappedInfinityIterationCount
=
parseFloat
(
uncappedInfinityIterationCount
.
toPrecision
(
6
)
)
;
const
infinityIterationCount
=
Math
.
min
(
MAX_INFINITE_ANIMATIONS_ITERATIONS
Math
.
ceil
(
uncappedInfinityIterationCount
)
)
;
const
firstStartTime
=
mainIterationStartTime
+
firstSectionCount
*
state
.
duration
;
const
firstEndTime
=
firstStartTime
+
state
.
duration
;
const
firstSegments
=
helper
.
createPathSegments
(
firstStartTime
firstEndTime
)
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
"
d
:
helper
.
toPathString
(
firstSegments
)
}
)
)
;
const
isAlternate
=
state
.
direction
.
match
(
/
alternate
/
)
;
for
(
let
i
=
1
;
i
<
infinityIterationCount
;
i
+
+
)
{
const
startTime
=
firstStartTime
+
i
*
state
.
duration
;
let
segments
;
if
(
isAlternate
&
&
i
%
2
)
{
segments
=
firstSegments
.
map
(
segment
=
>
{
return
{
x
:
firstEndTime
-
segment
.
x
+
startTime
y
:
segment
.
y
}
;
}
)
;
}
else
{
segments
=
firstSegments
.
map
(
segment
=
>
{
return
{
x
:
segment
.
x
-
firstStartTime
+
startTime
y
:
segment
.
y
}
;
}
)
;
}
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
infinity
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
}
renderInfinityDuration
(
pathList
state
mainIterationStartTime
helper
)
{
const
startSegment
=
helper
.
getSegment
(
mainIterationStartTime
)
;
const
endSegment
=
{
x
:
helper
.
totalDuration
y
:
startSegment
.
y
}
;
const
segments
=
[
startSegment
endSegment
]
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
iteration
-
path
infinity
-
duration
"
d
:
helper
.
toPathString
(
segments
)
}
)
)
;
}
renderEndDelay
(
pathList
state
mainIterationStartTime
iterationCount
helper
)
{
const
startTime
=
mainIterationStartTime
+
iterationCount
*
state
.
duration
;
const
startSegment
=
helper
.
getSegment
(
startTime
)
;
const
endSegment
=
{
x
:
startTime
+
state
.
endDelay
y
:
startSegment
.
y
}
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
enddelay
-
path
"
d
:
helper
.
toPathString
(
[
startSegment
endSegment
]
)
}
)
)
;
}
renderForwardsFill
(
pathList
state
mainIterationStartTime
iterationCount
helper
)
{
const
startTime
=
mainIterationStartTime
+
iterationCount
*
state
.
duration
+
(
state
.
endDelay
>
0
?
state
.
endDelay
:
0
)
;
const
startSegment
=
helper
.
getSegment
(
startTime
)
;
const
endSegment
=
{
x
:
helper
.
totalDuration
y
:
startSegment
.
y
}
;
pathList
.
push
(
dom
.
path
(
{
className
:
"
animation
-
fill
-
forwards
-
path
"
d
:
helper
.
toPathString
(
[
startSegment
endSegment
]
)
}
)
)
;
}
}
module
.
exports
=
TimingPath
;
