"
use
strict
"
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
SummaryGraphHelper
toPathString
}
=
require
(
"
.
.
/
.
.
/
utils
/
graph
-
helper
"
)
;
const
TimingPath
=
require
(
"
.
/
TimingPath
"
)
;
class
ComputedTimingPath
extends
TimingPath
{
static
get
propTypes
(
)
{
return
{
animation
:
PropTypes
.
object
.
isRequired
durationPerPixel
:
PropTypes
.
number
.
isRequired
keyframes
:
PropTypes
.
object
.
isRequired
offset
:
PropTypes
.
number
.
isRequired
opacity
:
PropTypes
.
number
.
isRequired
simulateAnimation
:
PropTypes
.
func
.
isRequired
totalDuration
:
PropTypes
.
number
.
isRequired
}
;
}
render
(
)
{
const
{
animation
durationPerPixel
keyframes
offset
opacity
simulateAnimation
totalDuration
}
=
this
.
props
;
const
{
state
}
=
animation
;
const
effectTiming
=
Object
.
assign
(
{
}
state
{
iterations
:
state
.
iterationCount
?
state
.
iterationCount
:
Infinity
}
)
;
const
frames
=
keyframes
.
map
(
keyframe
=
>
{
return
{
opacity
:
keyframe
.
offset
offset
:
keyframe
.
offset
easing
:
keyframe
.
easing
}
;
}
)
;
const
simulatedAnimation
=
simulateAnimation
(
frames
effectTiming
true
)
;
const
simulatedElement
=
simulatedAnimation
.
effect
.
target
;
const
win
=
simulatedElement
.
ownerGlobal
;
const
endTime
=
simulatedAnimation
.
effect
.
getComputedTiming
(
)
.
endTime
;
simulatedElement
.
style
.
opacity
=
0
;
const
getValueFunc
=
time
=
>
{
if
(
time
<
0
)
{
return
{
x
:
time
y
:
0
}
;
}
simulatedAnimation
.
currentTime
=
time
<
endTime
?
time
:
endTime
;
return
win
.
getComputedStyle
(
simulatedElement
)
.
opacity
;
}
;
const
toPathStringFunc
=
segments
=
>
{
const
firstSegment
=
segments
[
0
]
;
let
pathString
=
M
{
firstSegment
.
x
}
0
;
pathString
+
=
toPathString
(
segments
)
;
const
lastSegment
=
segments
[
segments
.
length
-
1
]
;
pathString
+
=
L
{
lastSegment
.
x
}
0
Z
;
return
pathString
;
}
;
const
helper
=
new
SummaryGraphHelper
(
state
keyframes
totalDuration
durationPerPixel
getValueFunc
toPathStringFunc
)
;
return
dom
.
g
(
{
className
:
"
animation
-
computed
-
timing
-
path
"
style
:
{
opacity
}
transform
:
translate
(
{
offset
}
)
}
super
.
renderGraph
(
state
helper
)
)
;
}
}
module
.
exports
=
ComputedTimingPath
;
