"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
createPathSegments
DEFAULT_DURATION_RESOLUTION
getPreferredProgressThresholdByKeyframes
toPathString
}
=
require
(
"
.
.
/
.
.
/
utils
/
graph
-
helper
"
)
;
class
ComputedStylePath
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
componentWidth
:
PropTypes
.
number
.
isRequired
graphHeight
:
PropTypes
.
number
.
isRequired
simulateAnimation
:
PropTypes
.
func
.
isRequired
totalDuration
:
PropTypes
.
number
.
isRequired
values
:
PropTypes
.
array
.
isRequired
}
;
}
getPathSegments
(
startValue
endValue
)
{
const
{
componentWidth
simulateAnimation
totalDuration
}
=
this
.
props
;
const
propertyName
=
this
.
getPropertyName
(
)
;
const
offsetDistance
=
endValue
.
offset
-
startValue
.
offset
;
const
duration
=
offsetDistance
*
totalDuration
;
const
keyframes
=
[
startValue
endValue
]
.
map
(
(
keyframe
index
)
=
>
{
return
{
offset
:
index
easing
:
keyframe
.
easing
[
propertyName
]
:
this
.
getPropertyValue
(
keyframe
)
}
;
}
)
;
const
effect
=
{
duration
fill
:
"
forwards
"
}
;
const
simulatedAnimation
=
simulateAnimation
(
keyframes
effect
true
)
;
const
simulatedElement
=
simulatedAnimation
.
effect
.
target
;
const
win
=
simulatedElement
.
ownerGlobal
;
const
threshold
=
getPreferredProgressThresholdByKeyframes
(
keyframes
)
;
const
getSegment
=
time
=
>
{
simulatedAnimation
.
currentTime
=
time
;
const
computedStyle
=
win
.
getComputedStyle
(
simulatedElement
)
.
getPropertyValue
(
propertyName
)
;
return
{
computedStyle
x
:
time
y
:
this
.
toSegmentValue
(
computedStyle
)
}
;
}
;
const
segments
=
createPathSegments
(
0
duration
duration
/
componentWidth
threshold
DEFAULT_DURATION_RESOLUTION
getSegment
)
;
const
offset
=
startValue
.
offset
*
totalDuration
;
for
(
const
segment
of
segments
)
{
segment
.
x
+
=
offset
;
}
return
segments
;
}
renderGraph
(
)
{
const
{
values
}
=
this
.
props
;
const
segments
=
[
]
;
for
(
let
i
=
0
;
i
<
values
.
length
-
1
;
i
+
+
)
{
const
startValue
=
values
[
i
]
;
const
endValue
=
values
[
i
+
1
]
;
segments
.
push
(
.
.
.
this
.
getPathSegments
(
startValue
endValue
)
)
;
}
return
this
.
renderPathSegments
(
segments
)
;
}
renderPathSegments
(
segments
)
{
const
{
graphHeight
}
=
this
.
props
;
for
(
const
segment
of
segments
)
{
segment
.
y
*
=
graphHeight
;
}
let
d
=
M
{
segments
[
0
]
.
x
}
0
;
d
+
=
toPathString
(
segments
)
;
d
+
=
L
{
segments
[
segments
.
length
-
1
]
.
x
}
0
Z
;
return
dom
.
path
(
{
d
}
)
;
}
}
module
.
exports
=
ComputedStylePath
;
