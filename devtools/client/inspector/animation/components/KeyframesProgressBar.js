"
use
strict
"
;
const
{
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
class
KeyframesProgressBar
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
addAnimationsCurrentTimeListener
:
PropTypes
.
func
.
isRequired
animation
:
PropTypes
.
object
.
isRequired
getAnimationsCurrentTime
:
PropTypes
.
func
.
isRequired
removeAnimationsCurrentTimeListener
:
PropTypes
.
func
.
isRequired
simulateAnimationForKeyframesProgressBar
:
PropTypes
.
func
.
isRequired
timeScale
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
onCurrentTimeUpdated
=
this
.
onCurrentTimeUpdated
.
bind
(
this
)
;
this
.
state
=
{
offset
:
0
}
;
}
componentDidMount
(
)
{
const
{
addAnimationsCurrentTimeListener
}
=
this
.
props
;
this
.
element
=
ReactDOM
.
findDOMNode
(
this
)
;
this
.
setupAnimation
(
this
.
props
)
;
addAnimationsCurrentTimeListener
(
this
.
onCurrentTimeUpdated
)
;
}
componentWillReceiveProps
(
nextProps
)
{
const
{
animation
getAnimationsCurrentTime
timeScale
}
=
nextProps
;
this
.
setupAnimation
(
nextProps
)
;
this
.
updateOffset
(
getAnimationsCurrentTime
(
)
animation
timeScale
)
;
}
componentWillUnmount
(
)
{
const
{
removeAnimationsCurrentTimeListener
}
=
this
.
props
;
removeAnimationsCurrentTimeListener
(
this
.
onCurrentTimeUpdated
)
;
this
.
element
=
null
;
this
.
simulatedAnimation
=
null
;
}
onCurrentTimeUpdated
(
currentTime
)
{
const
{
animation
timeScale
}
=
this
.
props
;
this
.
updateOffset
(
currentTime
animation
timeScale
)
;
}
updateOffset
(
currentTime
animation
timeScale
)
{
const
{
createdTime
playbackRate
}
=
animation
.
state
;
const
baseTime
=
typeof
createdTime
=
=
=
"
undefined
"
?
(
animation
.
state
.
previousStartTime
|
|
0
)
:
createdTime
;
const
time
=
(
timeScale
.
minStartTime
+
currentTime
-
baseTime
)
*
playbackRate
;
if
(
isNaN
(
time
)
)
{
return
;
}
this
.
simulatedAnimation
.
currentTime
=
time
;
const
offset
=
this
.
element
.
offsetWidth
*
this
.
simulatedAnimation
.
effect
.
getComputedTiming
(
)
.
progress
;
this
.
setState
(
{
offset
}
)
;
}
setupAnimation
(
props
)
{
const
{
animation
simulateAnimationForKeyframesProgressBar
}
=
props
;
if
(
this
.
simulatedAnimation
)
{
this
.
simulatedAnimation
.
cancel
(
)
;
}
const
timing
=
Object
.
assign
(
{
}
animation
.
state
{
iterations
:
animation
.
state
.
iterationCount
|
|
Infinity
}
)
;
this
.
simulatedAnimation
=
simulateAnimationForKeyframesProgressBar
(
timing
)
;
}
render
(
)
{
const
{
offset
}
=
this
.
state
;
return
dom
.
div
(
{
className
:
"
keyframes
-
progress
-
bar
-
area
devtools
-
toolbar
"
}
dom
.
div
(
{
className
:
"
keyframes
-
progress
-
bar
"
style
:
{
transform
:
translateX
(
{
offset
}
px
)
}
}
)
)
;
}
}
module
.
exports
=
KeyframesProgressBar
;
