"
use
strict
"
;
const
OPTIMAL_TIME_INTERVAL_MAX_ITERS
=
100
;
const
OPTIMAL_TIME_INTERVAL_MULTIPLES
=
[
1
2
.
5
5
]
;
function
findOptimalTimeInterval
(
minTimeInterval
)
{
if
(
!
minTimeInterval
)
{
return
0
;
}
let
numIters
=
0
;
let
multiplier
=
1
;
let
interval
;
while
(
true
)
{
for
(
let
i
=
0
;
i
<
OPTIMAL_TIME_INTERVAL_MULTIPLES
.
length
;
i
+
+
)
{
interval
=
OPTIMAL_TIME_INTERVAL_MULTIPLES
[
i
]
*
multiplier
;
if
(
minTimeInterval
<
=
interval
)
{
return
interval
;
}
}
if
(
+
+
numIters
>
OPTIMAL_TIME_INTERVAL_MAX_ITERS
)
{
return
interval
;
}
multiplier
*
=
10
;
}
}
function
isAllAnimationEqual
(
animationsA
animationsB
)
{
if
(
animationsA
.
length
!
=
=
animationsB
.
length
)
{
return
false
;
}
for
(
let
i
=
0
;
i
<
animationsA
.
length
;
i
+
+
)
{
const
animationA
=
animationsA
[
i
]
;
const
animationB
=
animationsB
[
i
]
;
if
(
animationA
.
actorID
!
=
=
animationB
.
actorID
|
|
!
isTimingEffectEqual
(
animationsA
[
i
]
.
state
animationsB
[
i
]
.
state
)
)
{
return
false
;
}
}
return
true
;
}
function
hasPlayingAnimation
(
animations
)
{
return
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
}
function
isTimingEffectEqual
(
stateA
stateB
)
{
return
stateA
.
delay
=
=
=
stateB
.
delay
&
&
stateA
.
direction
=
=
=
stateB
.
direction
&
&
stateA
.
duration
=
=
=
stateB
.
duration
&
&
stateA
.
easing
=
=
=
stateB
.
easing
&
&
stateA
.
endDelay
=
=
=
stateB
.
endDelay
&
&
stateA
.
fill
=
=
=
stateB
.
fill
&
&
stateA
.
iterationCount
=
=
=
stateB
.
iterationCount
&
&
stateA
.
iterationStart
=
=
=
stateB
.
iterationStart
;
}
exports
.
findOptimalTimeInterval
=
findOptimalTimeInterval
;
exports
.
hasPlayingAnimation
=
hasPlayingAnimation
;
exports
.
isAllAnimationEqual
=
isAllAnimationEqual
;
exports
.
isTimingEffectEqual
=
isTimingEffectEqual
;
