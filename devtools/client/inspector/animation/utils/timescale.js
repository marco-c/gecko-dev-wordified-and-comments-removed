"
use
strict
"
;
const
{
getFormatStr
}
=
require
(
"
.
/
l10n
"
)
;
const
TIME_FORMAT_MAX_DURATION_IN_MS
=
4000
;
class
TimeScale
{
constructor
(
animations
)
{
if
(
!
animations
.
every
(
animation
=
>
animation
.
state
.
createdTime
)
)
{
return
this
.
_initializeWithoutCreatedTime
(
animations
)
;
}
let
animationsCurrentTime
=
-
Number
.
MAX_VALUE
;
let
minStartTime
=
Infinity
;
let
maxEndTime
=
0
;
let
zeroPositionTime
=
0
;
for
(
const
animation
of
animations
)
{
const
{
createdTime
currentTime
currentTimeAtCreated
delay
duration
endDelay
=
0
iterationCount
playbackRate
}
=
animation
.
state
;
const
toRate
=
v
=
>
v
/
playbackRate
;
const
negativeDelay
=
toRate
(
Math
.
min
(
delay
0
)
)
;
let
startPositionTime
=
createdTime
+
negativeDelay
;
const
originalCurrentTime
=
toRate
(
currentTimeAtCreated
?
currentTimeAtCreated
:
startPositionTime
)
;
const
startPositionTimeAtCreated
=
createdTime
+
originalCurrentTime
;
let
animationZeroPositionTime
=
0
;
if
(
originalCurrentTime
<
negativeDelay
&
&
startPositionTimeAtCreated
<
minStartTime
)
{
startPositionTime
=
startPositionTimeAtCreated
;
animationZeroPositionTime
=
Math
.
abs
(
originalCurrentTime
)
;
}
else
if
(
negativeDelay
<
0
&
&
startPositionTime
<
minStartTime
)
{
animationZeroPositionTime
=
Math
.
abs
(
negativeDelay
)
;
}
let
endTime
=
0
;
if
(
duration
=
=
=
Infinity
)
{
endTime
=
createdTime
+
(
delay
>
0
?
delay
*
2
:
1
)
;
}
else
{
endTime
=
createdTime
+
toRate
(
delay
+
duration
*
(
iterationCount
|
|
1
)
+
Math
.
max
(
endDelay
0
)
)
;
}
maxEndTime
=
Math
.
max
(
maxEndTime
endTime
)
;
animationsCurrentTime
=
Math
.
max
(
animationsCurrentTime
createdTime
+
toRate
(
currentTime
)
)
;
if
(
startPositionTime
<
minStartTime
)
{
minStartTime
=
startPositionTime
;
zeroPositionTime
=
animationZeroPositionTime
;
}
else
{
zeroPositionTime
=
Math
.
max
(
zeroPositionTime
animationZeroPositionTime
)
;
}
}
this
.
minStartTime
=
minStartTime
;
this
.
maxEndTime
=
maxEndTime
;
this
.
currentTime
=
animationsCurrentTime
;
this
.
zeroPositionTime
=
zeroPositionTime
;
}
_initializeWithoutCreatedTime
(
animations
)
{
this
.
minStartTime
=
Infinity
;
this
.
maxEndTime
=
0
;
this
.
documentCurrentTime
=
0
;
for
(
const
animation
of
animations
)
{
const
{
delay
documentCurrentTime
duration
endDelay
=
0
iterationCount
playbackRate
previousStartTime
=
0
}
=
animation
.
state
;
const
toRate
=
v
=
>
v
/
playbackRate
;
const
minZero
=
v
=
>
Math
.
max
(
v
0
)
;
const
rateRelativeDuration
=
toRate
(
duration
*
(
!
iterationCount
?
1
:
iterationCount
)
)
;
const
relevantDelay
=
delay
<
0
?
toRate
(
delay
)
:
0
;
const
startTime
=
toRate
(
minZero
(
delay
)
)
+
rateRelativeDuration
+
endDelay
;
this
.
minStartTime
=
Math
.
min
(
this
.
minStartTime
previousStartTime
+
relevantDelay
+
Math
.
min
(
startTime
0
)
)
;
const
length
=
toRate
(
delay
)
+
rateRelativeDuration
+
toRate
(
minZero
(
endDelay
)
)
;
const
endTime
=
previousStartTime
+
length
;
this
.
maxEndTime
=
Math
.
max
(
this
.
maxEndTime
endTime
)
;
this
.
documentCurrentTime
=
Math
.
max
(
this
.
documentCurrentTime
documentCurrentTime
)
;
this
.
zeroPositionTime
=
this
.
minStartTime
;
}
}
distanceToRelativeTime
(
distance
)
{
return
(
this
.
getDuration
(
)
*
distance
/
100
)
-
this
.
zeroPositionTime
;
}
formatTime
(
time
)
{
if
(
Math
.
abs
(
time
)
<
(
1
/
1000
)
)
{
time
=
0
.
0
;
}
if
(
this
.
getDuration
(
)
<
=
TIME_FORMAT_MAX_DURATION_IN_MS
)
{
return
getFormatStr
(
"
timeline
.
timeGraduationLabel
"
time
.
toFixed
(
0
)
)
;
}
return
getFormatStr
(
"
player
.
timeLabel
"
(
time
/
1000
)
.
toFixed
(
1
)
)
;
}
getDuration
(
)
{
return
this
.
maxEndTime
-
this
.
minStartTime
;
}
getCurrentTime
(
)
{
const
baseTime
=
typeof
this
.
currentTime
=
=
=
"
undefined
"
?
this
.
documentCurrentTime
:
this
.
currentTime
;
return
baseTime
-
this
.
minStartTime
;
}
getEndTime
(
{
state
}
)
{
return
state
.
iterationCount
?
state
.
delay
+
state
.
duration
*
state
.
iterationCount
+
state
.
endDelay
:
Infinity
;
}
}
module
.
exports
=
TimeScale
;
