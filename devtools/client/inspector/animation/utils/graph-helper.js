"
use
strict
"
;
const
BOUND_EXCLUDING_TIME
=
0
.
001
;
const
DEFAULT_GRAPH_HEIGHT
=
100
;
const
DEFAULT_KEYFRAMES_GRAPH_DURATION
=
1000
;
const
DEFAULT_MIN_PROGRESS_THRESHOLD
=
0
.
1
;
const
DEFAULT_DURATION_RESOLUTION
=
4
;
const
DEFAULT_EASING_HINT_STROKE_WIDTH
=
5
;
class
SummaryGraphHelper
{
constructor
(
state
keyframes
totalDuration
minSegmentDuration
getValueFunc
toPathStringFunc
)
{
this
.
totalDuration
=
totalDuration
;
this
.
minSegmentDuration
=
minSegmentDuration
;
this
.
minProgressThreshold
=
getPreferredProgressThreshold
(
state
keyframes
)
*
DEFAULT_GRAPH_HEIGHT
;
this
.
durationResolution
=
getPreferredDurationResolution
(
keyframes
)
;
this
.
getValue
=
getValueFunc
;
this
.
toPathString
=
toPathStringFunc
;
this
.
getSegment
=
this
.
getSegment
.
bind
(
this
)
;
}
createPathSegments
(
startTime
endTime
)
{
return
createPathSegments
(
startTime
endTime
this
.
minSegmentDuration
this
.
minProgressThreshold
this
.
durationResolution
this
.
getSegment
)
;
}
getSegment
(
time
)
{
const
value
=
this
.
getValue
(
time
)
;
return
{
x
:
time
y
:
value
*
DEFAULT_GRAPH_HEIGHT
}
;
}
}
function
createPathSegments
(
startTime
endTime
minSegmentDuration
minProgressThreshold
resolution
getSegment
)
{
if
(
endTime
-
startTime
<
minSegmentDuration
)
{
return
[
getSegment
(
startTime
)
getSegment
(
endTime
)
]
;
}
let
pathSegments
=
[
]
;
const
startTimeSegment
=
getSegment
(
startTime
)
;
pathSegments
.
push
(
startTimeSegment
)
;
let
previousSegment
=
startTimeSegment
;
const
interval
=
(
endTime
-
startTime
)
/
resolution
;
for
(
let
index
=
1
;
index
<
=
resolution
;
index
+
+
)
{
const
currentSegment
=
getSegment
(
startTime
+
index
*
interval
)
;
if
(
Math
.
abs
(
currentSegment
.
y
-
previousSegment
.
y
)
>
minProgressThreshold
)
{
const
nextStartTime
=
previousSegment
.
x
+
BOUND_EXCLUDING_TIME
;
const
nextEndTime
=
currentSegment
.
x
-
BOUND_EXCLUDING_TIME
;
const
segments
=
createPathSegments
(
nextStartTime
nextEndTime
minSegmentDuration
minProgressThreshold
DEFAULT_DURATION_RESOLUTION
getSegment
)
;
pathSegments
=
pathSegments
.
concat
(
segments
)
;
}
pathSegments
.
push
(
currentSegment
)
;
previousSegment
=
currentSegment
;
}
return
pathSegments
;
}
function
createSummaryGraphPathStringFunction
(
endTime
playbackRate
)
{
return
segments
=
>
{
segments
=
mapSegmentsToPlaybackRate
(
segments
endTime
playbackRate
)
;
const
firstSegment
=
segments
[
0
]
;
let
pathString
=
M
{
firstSegment
.
x
}
0
;
pathString
+
=
toPathString
(
segments
)
;
const
lastSegment
=
segments
[
segments
.
length
-
1
]
;
pathString
+
=
L
{
lastSegment
.
x
}
0
Z
;
return
pathString
;
}
;
}
function
getPreferredDurationResolution
(
keyframes
)
{
if
(
!
keyframes
)
{
return
DEFAULT_DURATION_RESOLUTION
;
}
let
durationResolution
=
DEFAULT_DURATION_RESOLUTION
;
let
previousOffset
=
0
;
for
(
const
keyframe
of
keyframes
)
{
if
(
previousOffset
&
&
previousOffset
!
=
keyframe
.
offset
)
{
const
interval
=
keyframe
.
offset
-
previousOffset
;
durationResolution
=
Math
.
max
(
durationResolution
Math
.
ceil
(
1
/
interval
)
)
;
}
previousOffset
=
keyframe
.
offset
;
}
return
durationResolution
;
}
function
getPreferredProgressThreshold
(
state
keyframes
)
{
const
steps
=
getStepsCount
(
state
.
easing
)
;
const
threshold
=
Math
.
min
(
DEFAULT_MIN_PROGRESS_THRESHOLD
1
/
(
steps
+
1
)
)
;
if
(
!
keyframes
)
{
return
threshold
;
}
return
Math
.
min
(
threshold
getPreferredProgressThresholdByKeyframes
(
keyframes
)
)
;
}
function
getPreferredProgressThresholdByKeyframes
(
keyframes
)
{
let
threshold
=
DEFAULT_MIN_PROGRESS_THRESHOLD
;
for
(
let
i
=
0
;
i
<
keyframes
.
length
-
1
;
i
+
+
)
{
const
keyframe
=
keyframes
[
i
]
;
if
(
!
keyframe
.
easing
)
{
continue
;
}
const
steps
=
getStepsCount
(
keyframe
.
easing
)
;
if
(
steps
)
{
const
nextKeyframe
=
keyframes
[
i
+
1
]
;
threshold
=
Math
.
min
(
threshold
(
1
/
(
steps
+
1
)
)
*
(
nextKeyframe
.
offset
-
keyframe
.
offset
)
)
;
}
}
return
threshold
;
}
function
getStepsCount
(
easing
)
{
const
stepsFunction
=
easing
.
match
(
/
(
steps
)
\
(
(
\
d
+
)
/
)
;
return
stepsFunction
?
parseInt
(
stepsFunction
[
2
]
10
)
:
0
;
}
function
mapSegmentsToPlaybackRate
(
segments
endTime
playbackRate
)
{
if
(
playbackRate
>
0
)
{
return
segments
;
}
return
segments
.
map
(
segment
=
>
{
segment
.
x
=
endTime
-
segment
.
x
;
return
segment
;
}
)
;
}
function
toPathString
(
segments
)
{
let
pathString
=
"
"
;
segments
.
forEach
(
segment
=
>
{
pathString
+
=
L
{
segment
.
x
}
{
segment
.
y
}
;
}
)
;
return
pathString
;
}
exports
.
createPathSegments
=
createPathSegments
;
exports
.
createSummaryGraphPathStringFunction
=
createSummaryGraphPathStringFunction
;
exports
.
DEFAULT_DURATION_RESOLUTION
=
DEFAULT_DURATION_RESOLUTION
;
exports
.
DEFAULT_EASING_HINT_STROKE_WIDTH
=
DEFAULT_EASING_HINT_STROKE_WIDTH
;
exports
.
DEFAULT_GRAPH_HEIGHT
=
DEFAULT_GRAPH_HEIGHT
;
exports
.
DEFAULT_KEYFRAMES_GRAPH_DURATION
=
DEFAULT_KEYFRAMES_GRAPH_DURATION
;
exports
.
getPreferredProgressThresholdByKeyframes
=
getPreferredProgressThresholdByKeyframes
;
exports
.
SummaryGraphHelper
=
SummaryGraphHelper
;
exports
.
toPathString
=
toPathString
;
