"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
FRAME_SCRIPT_URL
=
CHROME_URL_ROOT
+
"
doc_frame_script
.
js
"
;
const
TAB_NAME
=
"
newanimationinspector
"
;
const
ANIMATION_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
}
)
;
const
openAnimationInspector
=
async
function
(
)
{
const
{
inspector
toolbox
}
=
await
openInspectorSidebarTab
(
TAB_NAME
)
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
{
animationinspector
:
animationInspector
}
=
inspector
;
await
waitForRendering
(
animationInspector
)
;
const
panel
=
inspector
.
panelWin
.
document
.
getElementById
(
"
animation
-
container
"
)
;
return
{
animationInspector
toolbox
inspector
panel
}
;
}
;
const
closeAnimationInspector
=
async
function
(
)
{
const
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
closeToolbox
(
target
)
;
}
;
const
enableAnimationFeatures
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
dom
.
animations
-
api
.
core
.
enabled
"
true
]
[
"
layout
.
css
.
frames
-
timing
.
enabled
"
true
]
]
}
resolve
)
;
}
)
;
}
;
const
_addTab
=
addTab
;
addTab
=
async
function
(
url
)
{
await
enableAnimationFeatures
(
)
;
const
tab
=
await
_addTab
(
url
)
;
const
browser
=
tab
.
linkedBrowser
;
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
loadFrameScriptUtils
(
browser
)
;
return
tab
;
}
;
const
removeAnimatedElementsExcept
=
async
function
(
selectors
)
{
return
executeInContent
(
"
Test
:
RemoveAnimatedElementsExcept
"
{
selectors
}
)
;
}
;
const
clickOnAnimation
=
async
function
(
animationInspector
panel
index
)
{
info
(
"
Click
on
animation
"
+
index
+
"
in
the
timeline
"
)
;
const
summaryGraphEl
=
panel
.
querySelectorAll
(
"
.
animation
-
summary
-
graph
"
)
[
index
]
;
summaryGraphEl
.
scrollIntoView
(
false
)
;
const
bounds
=
summaryGraphEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
summaryGraphEl
x
y
{
}
summaryGraphEl
.
ownerGlobal
)
;
await
waitForAnimationDetail
(
animationInspector
)
;
}
;
const
clickOnDetailCloseButton
=
function
(
panel
)
{
info
(
"
Click
on
close
button
for
animation
detail
pane
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
animation
-
detail
-
close
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
}
;
const
clickOnPauseResumeButton
=
async
function
(
animationInspector
panel
)
{
info
(
"
Click
on
pause
/
resume
button
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
pause
-
resume
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnRewindButton
=
async
function
(
animationInspector
panel
)
{
info
(
"
Click
on
rewind
button
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
rewind
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnCurrentTimeScrubberController
=
async
function
(
animationInspector
panel
mouseDownPosition
mouseMovePosition
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
controller
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
mousedonwX
=
bounds
.
width
*
mouseDownPosition
;
info
(
Click
{
mousedonwX
}
on
scrubber
controller
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousedonwX
0
{
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnPlaybackRateSelector
=
async
function
(
animationInspector
panel
rate
)
{
info
(
Click
on
playback
rate
selector
to
select
{
rate
}
)
;
const
selectEl
=
panel
.
querySelector
(
"
.
playback
-
rate
-
selector
"
)
;
const
optionEl
=
[
.
.
.
selectEl
.
options
]
.
filter
(
o
=
>
Number
(
o
.
value
)
=
=
=
rate
)
[
0
]
;
if
(
!
optionEl
)
{
ok
(
false
Could
not
find
an
option
for
rate
{
rate
}
in
the
rate
selector
.
+
Values
are
:
{
[
.
.
.
selectEl
.
options
]
.
map
(
o
=
>
o
.
value
)
}
)
;
return
;
}
const
win
=
selectEl
.
ownerGlobal
;
EventUtils
.
synthesizeMouseAtCenter
(
selectEl
{
type
:
"
mousedown
"
}
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
optionEl
{
type
:
"
mouseup
"
}
win
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
dragOnCurrentTimeScrubber
=
async
function
(
animationInspector
panel
mouseDownPosition
mouseMovePosition
mouseYPixel
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
mousedonwX
=
bounds
.
width
*
mouseDownPosition
;
const
mousemoveX
=
bounds
.
width
*
mouseMovePosition
;
info
(
Drag
on
scrubber
from
{
mousedonwX
}
to
{
mousemoveX
}
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousedonwX
mouseYPixel
{
type
:
"
mousedown
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
mouseYPixel
{
type
:
"
mousemove
"
}
controllerEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
mouseYPixel
{
type
:
"
mouseup
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
dragOnCurrentTimeScrubberController
=
async
function
(
animationInspector
panel
mouseDownPosition
mouseMovePosition
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
controller
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
mousedonwX
=
bounds
.
width
*
mouseDownPosition
;
const
mousemoveX
=
bounds
.
width
*
mouseMovePosition
;
info
(
Drag
on
scrubber
controller
from
{
mousedonwX
}
to
{
mousemoveX
}
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousedonwX
0
{
type
:
"
mousedown
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
0
{
type
:
"
mousemove
"
}
controllerEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
0
{
type
:
"
mouseup
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
getDurationAndRate
=
function
(
animationInspector
panel
pixels
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
controller
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
duration
=
animationInspector
.
state
.
timeScale
.
getDuration
(
)
/
bounds
.
width
*
pixels
;
const
rate
=
1
/
bounds
.
width
*
pixels
;
return
{
duration
rate
}
;
}
;
const
selectAnimationInspector
=
async
function
(
inspector
)
{
await
inspector
.
toolbox
.
selectTool
(
"
inspector
"
)
;
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
sidebar
.
select
(
"
newanimationinspector
"
)
;
await
onUpdated
;
await
waitForRendering
(
inspector
.
animationinspector
)
;
}
;
const
selectNodeAndWaitForAnimations
=
async
function
(
data
inspector
reason
=
"
test
"
)
{
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
await
selectNode
(
data
inspector
reason
)
;
await
onUpdated
;
await
waitForRendering
(
inspector
.
animationinspector
)
;
}
;
const
sendSpaceKeyEvent
=
async
function
(
animationInspector
panel
)
{
panel
.
focus
(
)
;
EventUtils
.
sendKey
(
"
SPACE
"
panel
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setClassAttribute
=
async
function
(
animationInspector
selector
cls
)
{
const
options
=
{
attributeName
:
"
class
"
attributeValue
:
cls
selector
}
;
await
executeInContent
(
"
devtools
:
test
:
setAttribute
"
options
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setSidebarWidth
=
async
function
(
width
inspector
)
{
const
onUpdated
=
inspector
.
toolbox
.
once
(
"
inspector
-
sidebar
-
resized
"
)
;
inspector
.
splitBox
.
setState
(
{
width
}
)
;
await
onUpdated
;
}
;
const
setStyle
=
async
function
(
animationInspector
selector
propertyName
propertyValue
)
{
const
options
=
{
propertyName
propertyValue
selector
}
;
await
executeInContent
(
"
devtools
:
test
:
setStyle
"
options
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
waitForRendering
=
async
function
(
animationInspector
)
{
await
Promise
.
all
(
[
waitForAllAnimationTargets
(
animationInspector
)
waitForAllSummaryGraph
(
animationInspector
)
waitForAnimationDetail
(
animationInspector
)
]
)
;
}
;
const
waitForAnimationDetail
=
async
function
(
animationInspector
)
{
if
(
animationInspector
.
state
.
selectedAnimation
&
&
animationInspector
.
state
.
detailVisibility
)
{
await
animationInspector
.
once
(
"
animation
-
keyframes
-
rendered
"
)
;
}
}
;
const
waitForAllAnimationTargets
=
async
function
(
animationInspector
)
{
for
(
let
i
=
0
;
i
<
animationInspector
.
state
.
animations
.
length
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
target
-
rendered
"
)
;
}
}
;
const
waitForAllSummaryGraph
=
async
function
(
animationInspector
)
{
for
(
let
i
=
0
;
i
<
animationInspector
.
state
.
animations
.
length
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
summary
-
graph
-
rendered
"
)
;
}
}
;
const
waitForSummaryAndDetail
=
async
function
(
animationInspector
)
{
await
Promise
.
all
(
[
waitForAllSummaryGraph
(
animationInspector
)
waitForAnimationDetail
(
animationInspector
)
]
)
;
}
;
function
assertAnimationsCurrentTime
(
animationInspector
time
)
{
const
isTimeEqual
=
animationInspector
.
state
.
animations
.
every
(
(
{
state
}
)
=
>
state
.
currentTime
=
=
=
time
)
;
ok
(
isTimeEqual
Current
time
of
animations
should
be
{
time
}
)
;
}
function
assertAnimationsPausing
(
animationInspector
panel
)
{
assertAnimationsPausingOrRunning
(
animationInspector
panel
true
)
;
}
function
assertAnimationsPausingOrRunning
(
animationInspector
panel
shouldPause
)
{
const
hasRunningAnimation
=
animationInspector
.
state
.
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
if
(
shouldPause
)
{
is
(
hasRunningAnimation
false
"
All
animations
should
be
paused
"
)
;
}
else
{
is
(
hasRunningAnimation
true
"
Animations
should
be
running
at
least
one
"
)
;
}
}
function
assertAnimationsRunning
(
animationInspector
panel
)
{
assertAnimationsPausingOrRunning
(
animationInspector
panel
false
)
;
}
function
assertLinearGradient
(
linearGradientEl
offset
expectedColor
)
{
const
stopEl
=
findStopElement
(
linearGradientEl
offset
)
;
ok
(
stopEl
stop
element
at
offset
{
offset
}
should
exist
)
;
is
(
stopEl
.
getAttribute
(
"
stop
-
color
"
)
expectedColor
stop
-
color
of
stop
element
at
offset
{
offset
}
should
be
{
expectedColor
}
)
;
}
function
assertPathSegments
(
pathEl
hasClosePath
expectedValues
)
{
const
pathSegList
=
pathEl
.
pathSegList
;
ok
(
pathSegList
"
The
tested
element
should
have
pathSegList
"
)
;
expectedValues
.
forEach
(
expectedValue
=
>
{
ok
(
isPassingThrough
(
pathSegList
expectedValue
.
x
expectedValue
.
y
)
The
path
segment
of
x
{
expectedValue
.
x
}
y
{
expectedValue
.
y
}
+
should
be
passing
through
)
;
}
)
;
if
(
hasClosePath
)
{
const
closePathSeg
=
pathSegList
.
getItem
(
pathSegList
.
numberOfItems
-
1
)
;
is
(
closePathSeg
.
pathSegType
closePathSeg
.
PATHSEG_CLOSEPATH
"
The
last
segment
should
be
close
path
"
)
;
}
}
function
isPassingThrough
(
pathSegList
x
y
)
{
let
previousPathSeg
=
pathSegList
.
getItem
(
0
)
;
for
(
let
i
=
0
;
i
<
pathSegList
.
numberOfItems
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
pathSeg
.
x
=
=
=
undefined
)
{
continue
;
}
const
currentX
=
parseFloat
(
pathSeg
.
x
.
toFixed
(
3
)
)
;
const
currentY
=
parseFloat
(
pathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
currentX
=
=
=
x
&
&
currentY
=
=
=
y
)
{
return
true
;
}
const
previousX
=
parseFloat
(
previousPathSeg
.
x
.
toFixed
(
3
)
)
;
const
previousY
=
parseFloat
(
previousPathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
previousX
<
=
x
&
&
x
<
=
currentX
&
&
Math
.
min
(
previousY
currentY
)
<
=
y
&
&
y
<
=
Math
.
max
(
previousY
currentY
)
)
{
return
true
;
}
previousPathSeg
=
pathSeg
;
}
return
false
;
}
function
findAnimationItemElementsByTargetClassName
(
panel
targetClassName
)
{
const
animationTargetEls
=
panel
.
querySelectorAll
(
"
.
animation
-
target
"
)
;
for
(
const
animationTargetEl
of
animationTargetEls
)
{
const
className
=
animationTargetEl
.
textContent
.
split
(
"
.
"
)
[
1
]
;
if
(
className
=
=
=
targetClassName
)
{
return
animationTargetEl
.
closest
(
"
.
animation
-
item
"
)
;
}
}
return
null
;
}
function
findStopElement
(
linearGradientEl
offset
)
{
for
(
const
stopEl
of
linearGradientEl
.
querySelectorAll
(
"
stop
"
)
)
{
if
(
offset
<
=
parseFloat
(
stopEl
.
getAttribute
(
"
offset
"
)
)
)
{
return
stopEl
;
}
}
return
null
;
}
