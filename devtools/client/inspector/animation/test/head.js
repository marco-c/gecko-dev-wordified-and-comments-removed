"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
TAB_NAME
=
"
animationinspector
"
;
const
ANIMATION_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
}
)
;
const
openAnimationInspector
=
async
function
(
)
{
const
{
inspector
toolbox
}
=
await
openInspectorSidebarTab
(
TAB_NAME
)
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
animationInspector
=
inspector
.
getPanel
(
"
animationinspector
"
)
;
await
waitForRendering
(
animationInspector
)
;
const
panel
=
inspector
.
panelWin
.
document
.
getElementById
(
"
animation
-
container
"
)
;
return
{
animationInspector
toolbox
inspector
panel
}
;
}
;
const
closeAnimationInspector
=
async
function
(
)
{
const
target
=
await
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
closeToolbox
(
target
)
;
}
;
const
enableAnimationFeatures
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
animations
-
api
.
core
.
enabled
"
true
]
[
"
dom
.
animations
-
api
.
getAnimations
.
enabled
"
true
]
[
"
dom
.
animations
-
api
.
implicit
-
keyframes
.
enabled
"
true
]
[
"
dom
.
animations
-
api
.
timelines
.
enabled
"
true
]
[
"
layout
.
css
.
step
-
position
-
jump
.
enabled
"
true
]
]
}
resolve
)
;
}
)
;
}
;
const
_addTab
=
addTab
;
addTab
=
async
function
(
url
)
{
await
enableAnimationFeatures
(
)
;
return
_addTab
(
url
)
;
}
;
const
removeAnimatedElementsExcept
=
function
(
selectors
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selectors
]
selectorsChild
=
>
{
function
isRemovableElement
(
animation
selectorsInner
)
{
for
(
const
selector
of
selectorsInner
)
{
if
(
animation
.
effect
.
target
.
matches
(
selector
)
)
{
return
false
;
}
}
return
true
;
}
for
(
const
animation
of
content
.
document
.
getAnimations
(
)
)
{
if
(
isRemovableElement
(
animation
selectorsChild
)
)
{
animation
.
effect
.
target
.
remove
(
)
;
}
}
}
)
;
}
;
const
clickOnAnimation
=
async
function
(
animationInspector
panel
index
)
{
info
(
"
Click
on
animation
"
+
index
+
"
in
the
timeline
"
)
;
const
summaryGraphEl
=
panel
.
querySelectorAll
(
"
.
animation
-
summary
-
graph
"
)
[
index
]
;
await
clickOnSummaryGraph
(
animationInspector
panel
summaryGraphEl
)
;
}
;
const
clickOnAnimationByTargetSelector
=
async
function
(
animationInspector
panel
selector
)
{
info
(
Click
on
animation
whose
selector
of
target
element
is
'
{
selector
}
'
)
;
const
animationItemEl
=
findAnimationItemElementsByTargetSelector
(
panel
selector
)
;
const
summaryGraphEl
=
animationItemEl
.
querySelector
(
"
.
animation
-
summary
-
graph
"
)
;
await
clickOnSummaryGraph
(
animationInspector
panel
summaryGraphEl
)
;
}
;
const
clickOnDetailCloseButton
=
function
(
panel
)
{
info
(
"
Click
on
close
button
for
animation
detail
pane
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
animation
-
detail
-
close
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
}
;
const
clickOnPauseResumeButton
=
async
function
(
animationInspector
panel
)
{
info
(
"
Click
on
pause
/
resume
button
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
pause
-
resume
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnRewindButton
=
async
function
(
animationInspector
panel
)
{
info
(
"
Click
on
rewind
button
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
rewind
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnCurrentTimeScrubberController
=
async
function
(
animationInspector
panel
mouseDownPosition
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
area
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
mousedonwX
=
bounds
.
width
*
mouseDownPosition
;
info
(
Click
{
mousedonwX
}
on
scrubber
controller
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousedonwX
0
{
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnInspectIcon
=
async
function
(
animationInspector
panel
index
)
{
info
(
Click
on
an
inspect
icon
in
animation
target
component
[
{
index
}
]
)
;
const
iconEl
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
objectBox
.
open
-
inspector
"
)
[
index
]
;
iconEl
.
scrollIntoView
(
false
)
;
EventUtils
.
synthesizeMouseAtCenter
(
iconEl
{
}
iconEl
.
ownerGlobal
)
;
await
animationInspector
.
once
(
"
animation
-
target
-
rendered
"
)
;
}
;
const
clickOnPlaybackRateSelector
=
async
function
(
animationInspector
panel
rate
)
{
info
(
Click
on
playback
rate
selector
to
select
{
rate
}
)
;
const
selectEl
=
panel
.
querySelector
(
"
.
playback
-
rate
-
selector
"
)
;
const
optionEl
=
[
.
.
.
selectEl
.
options
]
.
filter
(
o
=
>
Number
(
o
.
value
)
=
=
=
rate
)
[
0
]
;
if
(
!
optionEl
)
{
ok
(
false
Could
not
find
an
option
for
rate
{
rate
}
in
the
rate
selector
.
+
Values
are
:
{
[
.
.
.
selectEl
.
options
]
.
map
(
o
=
>
o
.
value
)
}
)
;
return
;
}
const
win
=
selectEl
.
ownerGlobal
;
EventUtils
.
synthesizeMouseAtCenter
(
selectEl
{
type
:
"
mousedown
"
}
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
optionEl
{
type
:
"
mouseup
"
}
win
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
clickOnSummaryGraph
=
async
function
(
animationInspector
panel
summaryGraphEl
)
{
const
scrubberEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
"
)
;
scrubberEl
.
style
.
pointerEvents
=
"
none
"
;
summaryGraphEl
.
scrollIntoView
(
false
)
;
EventUtils
.
synthesizeMouseAtCenter
(
summaryGraphEl
{
}
summaryGraphEl
.
ownerGlobal
)
;
await
waitForAnimationDetail
(
animationInspector
)
;
scrubberEl
.
style
.
pointerEvents
=
"
unset
"
;
}
;
const
clickOnTargetNode
=
async
function
(
animationInspector
panel
index
)
{
info
(
Click
on
a
target
node
in
animation
target
component
[
{
index
}
]
)
;
const
targetEl
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
objectBox
"
)
[
index
]
;
targetEl
.
scrollIntoView
(
false
)
;
const
onHighlight
=
animationInspector
.
inspector
.
highlighter
.
once
(
"
node
-
highlight
"
)
;
const
onAnimationTargetUpdated
=
animationInspector
.
once
(
"
animation
-
target
-
rendered
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
targetEl
{
}
targetEl
.
ownerGlobal
)
;
await
onAnimationTargetUpdated
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
await
onHighlight
;
}
;
const
dragOnCurrentTimeScrubber
=
async
function
(
animationInspector
panel
mouseMovePixel
mouseYPixel
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
"
)
;
info
(
Drag
scrubber
to
X
{
mouseMovePixel
}
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
0
mouseYPixel
{
type
:
"
mousedown
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mouseMovePixel
mouseYPixel
{
type
:
"
mousemove
"
}
controllerEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mouseMovePixel
mouseYPixel
{
type
:
"
mouseup
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
dragOnCurrentTimeScrubberController
=
async
function
(
animationInspector
panel
mouseDownPosition
mouseMovePosition
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
area
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
mousedonwX
=
bounds
.
width
*
mouseDownPosition
;
const
mousemoveX
=
bounds
.
width
*
mouseMovePosition
;
info
(
Drag
on
scrubber
controller
from
{
mousedonwX
}
to
{
mousemoveX
}
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousedonwX
0
{
type
:
"
mousedown
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
0
{
type
:
"
mousemove
"
}
controllerEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouse
(
controllerEl
mousemoveX
0
{
type
:
"
mouseup
"
}
controllerEl
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
getDurationAndRate
=
function
(
animationInspector
panel
pixels
)
{
const
controllerEl
=
panel
.
querySelector
(
"
.
current
-
time
-
scrubber
-
area
"
)
;
const
bounds
=
controllerEl
.
getBoundingClientRect
(
)
;
const
duration
=
(
animationInspector
.
state
.
timeScale
.
getDuration
(
)
/
bounds
.
width
)
*
pixels
;
const
rate
=
(
1
/
bounds
.
width
)
*
pixels
;
return
{
duration
rate
}
;
}
;
const
mouseOverOnTargetNode
=
function
(
animationInspector
panel
index
)
{
info
(
Mouse
over
on
a
target
node
in
animation
target
component
[
{
index
}
]
)
;
const
el
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
objectBox
"
)
[
index
]
;
el
.
scrollIntoView
(
false
)
;
EventUtils
.
synthesizeMouse
(
el
10
5
{
type
:
"
mouseover
"
}
el
.
ownerGlobal
)
;
}
;
const
mouseOutOnTargetNode
=
function
(
animationInspector
panel
index
)
{
info
(
Mouse
out
on
a
target
node
in
animation
target
component
[
{
index
}
]
)
;
const
el
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
objectBox
"
)
[
index
]
;
el
.
scrollIntoView
(
false
)
;
EventUtils
.
synthesizeMouse
(
el
-
1
-
1
{
type
:
"
mouseout
"
}
el
.
ownerGlobal
)
;
}
;
const
selectAnimationInspector
=
async
function
(
inspector
)
{
await
inspector
.
toolbox
.
selectTool
(
"
inspector
"
)
;
const
onDispatched
=
waitForDispatch
(
inspector
"
UPDATE_ANIMATIONS
"
)
;
inspector
.
sidebar
.
select
(
"
animationinspector
"
)
;
await
onDispatched
;
await
waitForRendering
(
inspector
.
getPanel
(
"
animationinspector
"
)
)
;
}
;
const
selectNodeAndWaitForAnimations
=
async
function
(
data
inspector
reason
=
"
test
"
)
{
selectNode
(
data
inspector
reason
)
;
await
waitForDispatch
(
inspector
"
UPDATE_ANIMATIONS
"
)
;
await
waitForRendering
(
inspector
.
getPanel
(
"
animationinspector
"
)
)
;
}
;
const
sendSpaceKeyEvent
=
async
function
(
animationInspector
element
)
{
element
.
focus
(
)
;
EventUtils
.
sendKey
(
"
SPACE
"
element
.
ownerGlobal
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setClassAttribute
=
async
function
(
animationInspector
selector
cls
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
cls
selector
]
(
attributeValue
selectorChild
)
=
>
{
const
node
=
content
.
document
.
querySelector
(
selectorChild
)
;
if
(
!
node
)
{
return
;
}
node
.
setAttribute
(
"
class
"
attributeValue
)
;
}
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setEffectTimingAndPlayback
=
async
function
(
animationInspector
selector
effectTiming
playbackRate
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
playbackRate
effectTiming
]
(
selectorChild
playbackRateChild
effectTimingChild
)
=
>
{
let
selectedAnimation
=
null
;
for
(
const
animation
of
content
.
document
.
getAnimations
(
)
)
{
if
(
animation
.
effect
.
target
.
matches
(
selectorChild
)
)
{
selectedAnimation
=
animation
;
break
;
}
}
if
(
!
selectedAnimation
)
{
return
;
}
selectedAnimation
.
playbackRate
=
playbackRateChild
;
selectedAnimation
.
effect
.
updateTiming
(
effectTimingChild
)
;
}
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setSidebarWidth
=
async
function
(
width
inspector
)
{
const
onUpdated
=
inspector
.
toolbox
.
once
(
"
inspector
-
sidebar
-
resized
"
)
;
inspector
.
splitBox
.
setState
(
{
width
}
)
;
await
onUpdated
;
}
;
const
setStyle
=
async
function
(
animationInspector
selector
propertyName
propertyValue
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
propertyName
propertyValue
]
(
selectorChild
propertyNameChild
propertyValueChild
)
=
>
{
const
node
=
content
.
document
.
querySelector
(
selectorChild
)
;
if
(
!
node
)
{
return
;
}
node
.
style
[
propertyNameChild
]
=
propertyValueChild
;
}
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
setStyles
=
async
function
(
animationInspector
selector
properties
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
properties
selector
]
(
propertiesChild
selectorChild
)
=
>
{
const
node
=
content
.
document
.
querySelector
(
selectorChild
)
;
if
(
!
node
)
{
return
;
}
for
(
const
propertyName
in
propertiesChild
)
{
const
propertyValue
=
propertiesChild
[
propertyName
]
;
node
.
style
[
propertyName
]
=
propertyValue
;
}
}
)
;
await
waitForSummaryAndDetail
(
animationInspector
)
;
}
;
const
waitForRendering
=
async
function
(
animationInspector
)
{
await
Promise
.
all
(
[
waitForAllAnimationTargets
(
animationInspector
)
waitForAllSummaryGraph
(
animationInspector
)
waitForAnimationDetail
(
animationInspector
)
]
)
;
}
;
function
_afterDispatchDone
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
if
(
action
.
type
=
=
=
type
)
{
return
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
async
function
waitForDispatch
(
inspector
type
repeat
=
(
)
=
>
1
)
{
let
count
=
0
;
while
(
count
<
repeat
(
)
)
{
await
_afterDispatchDone
(
inspector
.
store
type
)
;
count
+
+
;
}
}
const
waitForAnimationDetail
=
async
function
(
animationInspector
)
{
if
(
animationInspector
.
state
.
selectedAnimation
&
&
animationInspector
.
state
.
detailVisibility
)
{
await
animationInspector
.
once
(
"
animation
-
keyframes
-
rendered
"
)
;
}
}
;
const
waitForAllAnimationTargets
=
async
function
(
animationInspector
)
{
const
panel
=
animationInspector
.
inspector
.
panelWin
.
document
.
getElementById
(
"
animation
-
container
"
)
;
const
objectBoxCount
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
objectBox
"
)
.
length
;
if
(
objectBoxCount
=
=
=
animationInspector
.
state
.
animations
.
length
)
{
return
;
}
for
(
let
i
=
0
;
i
<
animationInspector
.
state
.
animations
.
length
-
objectBoxCount
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
target
-
rendered
"
)
;
}
}
;
const
waitForAllSummaryGraph
=
async
function
(
animationInspector
)
{
for
(
let
i
=
0
;
i
<
animationInspector
.
state
.
animations
.
length
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
summary
-
graph
-
rendered
"
)
;
}
}
;
const
waitForSummaryAndDetail
=
async
function
(
animationInspector
)
{
await
Promise
.
all
(
[
waitForAllSummaryGraph
(
animationInspector
)
waitForAnimationDetail
(
animationInspector
)
]
)
;
}
;
function
assertAnimationsCurrentTime
(
animationInspector
time
)
{
const
isTimeEqual
=
animationInspector
.
state
.
animations
.
every
(
(
{
state
}
)
=
>
state
.
currentTime
=
=
=
time
)
;
ok
(
isTimeEqual
Current
time
of
animations
should
be
{
time
}
)
;
}
function
assertAnimationsPausing
(
animationInspector
)
{
assertAnimationsPausingOrRunning
(
animationInspector
true
)
;
}
function
assertAnimationsPausingOrRunning
(
animationInspector
shouldPause
)
{
const
hasRunningAnimation
=
animationInspector
.
state
.
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
if
(
shouldPause
)
{
is
(
hasRunningAnimation
false
"
All
animations
should
be
paused
"
)
;
}
else
{
is
(
hasRunningAnimation
true
"
Animations
should
be
running
at
least
one
"
)
;
}
}
function
assertAnimationsRunning
(
animationInspector
)
{
assertAnimationsPausingOrRunning
(
animationInspector
false
)
;
}
function
assertLinearGradient
(
linearGradientEl
offset
expectedColor
)
{
const
stopEl
=
findStopElement
(
linearGradientEl
offset
)
;
ok
(
stopEl
stop
element
at
offset
{
offset
}
should
exist
)
;
is
(
stopEl
.
getAttribute
(
"
stop
-
color
"
)
expectedColor
stop
-
color
of
stop
element
at
offset
{
offset
}
should
be
{
expectedColor
}
)
;
}
function
assertPathSegments
(
pathEl
hasClosePath
expectedValues
)
{
const
pathSegList
=
pathEl
.
pathSegList
;
ok
(
pathSegList
"
The
tested
element
should
have
pathSegList
"
)
;
expectedValues
.
forEach
(
expectedValue
=
>
{
ok
(
isPassingThrough
(
pathSegList
expectedValue
.
x
expectedValue
.
y
)
The
path
segment
of
x
{
expectedValue
.
x
}
y
{
expectedValue
.
y
}
+
should
be
passing
through
)
;
}
)
;
if
(
hasClosePath
)
{
const
closePathSeg
=
pathSegList
.
getItem
(
pathSegList
.
numberOfItems
-
1
)
;
is
(
closePathSeg
.
pathSegType
closePathSeg
.
PATHSEG_CLOSEPATH
"
The
last
segment
should
be
close
path
"
)
;
}
}
function
isPassingThrough
(
pathSegList
x
y
)
{
let
previousPathSeg
=
pathSegList
.
getItem
(
0
)
;
for
(
let
i
=
0
;
i
<
pathSegList
.
numberOfItems
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
pathSeg
.
x
=
=
=
undefined
)
{
continue
;
}
const
currentX
=
parseFloat
(
pathSeg
.
x
.
toFixed
(
3
)
)
;
const
currentY
=
parseFloat
(
pathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
currentX
=
=
=
x
&
&
currentY
=
=
=
y
)
{
return
true
;
}
const
previousX
=
parseFloat
(
previousPathSeg
.
x
.
toFixed
(
3
)
)
;
const
previousY
=
parseFloat
(
previousPathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
previousX
<
=
x
&
&
x
<
=
currentX
&
&
Math
.
min
(
previousY
currentY
)
<
=
y
&
&
y
<
=
Math
.
max
(
previousY
currentY
)
)
{
return
true
;
}
previousPathSeg
=
pathSeg
;
}
return
false
;
}
function
findAnimationItemElementsByTargetSelector
(
panel
selector
)
{
const
attrNameEls
=
panel
.
querySelectorAll
(
"
.
animation
-
target
.
attrName
"
)
;
const
regexp
=
new
RegExp
(
\
\
{
selector
}
(
\
\
.
|
)
"
gi
"
)
;
for
(
const
attrNameEl
of
attrNameEls
)
{
if
(
regexp
.
exec
(
attrNameEl
.
textContent
)
)
{
return
attrNameEl
.
closest
(
"
.
animation
-
item
"
)
;
}
}
return
null
;
}
function
findStopElement
(
linearGradientEl
offset
)
{
for
(
const
stopEl
of
linearGradientEl
.
querySelectorAll
(
"
stop
"
)
)
{
if
(
offset
<
=
parseFloat
(
stopEl
.
getAttribute
(
"
offset
"
)
)
)
{
return
stopEl
;
}
}
return
null
;
}
async
function
testKeyframesGraphComputedValuePath
(
testData
)
{
await
addTab
(
URL_ROOT
+
"
doc_multi_keyframes
.
html
"
)
;
await
removeAnimatedElementsExcept
(
testData
.
map
(
t
=
>
.
{
t
.
targetClass
}
)
)
;
const
{
animationInspector
panel
}
=
await
openAnimationInspector
(
)
;
for
(
const
{
properties
targetClass
}
of
testData
)
{
info
(
Checking
keyframes
graph
for
{
targetClass
}
)
;
await
clickOnAnimationByTargetSelector
(
animationInspector
panel
.
{
targetClass
}
)
;
for
(
const
property
of
properties
)
{
const
{
name
computedValuePathClass
expectedPathSegments
expectedStopColors
}
=
property
;
const
testTarget
=
{
name
}
in
{
targetClass
}
;
info
(
Checking
keyframes
graph
for
{
testTarget
}
)
;
info
(
Checking
keyframes
graph
path
existence
for
{
testTarget
}
)
;
const
keyframesGraphPathEl
=
panel
.
querySelector
(
.
{
name
}
)
;
ok
(
keyframesGraphPathEl
The
keyframes
graph
path
element
of
{
testTarget
}
should
be
existence
)
;
info
(
Checking
computed
value
path
existence
for
{
testTarget
}
)
;
const
computedValuePathEl
=
keyframesGraphPathEl
.
querySelector
(
.
{
computedValuePathClass
}
)
;
ok
(
computedValuePathEl
The
computed
value
path
element
of
{
testTarget
}
should
be
existence
)
;
info
(
Checking
path
segments
for
{
testTarget
}
)
;
const
pathEl
=
computedValuePathEl
.
querySelector
(
"
path
"
)
;
ok
(
pathEl
The
<
path
>
element
of
{
testTarget
}
should
be
existence
)
;
assertPathSegments
(
pathEl
true
expectedPathSegments
)
;
if
(
!
expectedStopColors
)
{
continue
;
}
info
(
Checking
linearGradient
for
{
testTarget
}
)
;
const
linearGradientEl
=
computedValuePathEl
.
querySelector
(
"
linearGradient
"
)
;
ok
(
linearGradientEl
The
<
linearGradientEl
>
element
of
{
testTarget
}
should
be
existence
)
;
for
(
const
expectedStopColor
of
expectedStopColors
)
{
const
{
offset
color
}
=
expectedStopColor
;
assertLinearGradient
(
linearGradientEl
offset
color
)
;
}
}
}
}
function
checkAdjustingTheTime
(
animation1
animation2
)
{
const
adjustedCurrentTimeDiff
=
animation2
.
currentTime
/
animation2
.
playbackRate
-
animation1
.
currentTime
/
animation1
.
playbackRate
;
const
createdTimeDiff
=
animation1
.
createdTime
-
animation2
.
createdTime
;
ok
(
Math
.
abs
(
adjustedCurrentTimeDiff
-
createdTimeDiff
)
<
0
.
1
"
Adjusted
time
is
correct
"
)
;
}
