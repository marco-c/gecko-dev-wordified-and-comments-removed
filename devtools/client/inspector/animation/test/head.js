"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
const
COMMON_FRAME_SCRIPT_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
const
FRAME_SCRIPT_URL
=
CHROME_URL_ROOT
+
"
doc_frame_script
.
js
"
;
const
TAB_NAME
=
"
newanimationinspector
"
;
const
ANIMATION_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
new
-
animationinspector
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolsidebar
-
width
.
inspector
"
)
;
}
)
;
const
openAnimationInspector
=
async
function
(
)
{
const
{
inspector
toolbox
}
=
await
openInspectorSidebarTab
(
TAB_NAME
)
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
{
animationinspector
:
animationInspector
}
=
inspector
;
await
waitForRendering
(
animationInspector
)
;
const
panel
=
inspector
.
panelWin
.
document
.
getElementById
(
"
animation
-
container
"
)
;
return
{
animationInspector
toolbox
inspector
panel
}
;
}
;
const
closeAnimationInspector
=
async
function
(
)
{
const
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
return
gDevTools
.
closeToolbox
(
target
)
;
}
;
const
enableAnimationFeatures
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
dom
.
animations
-
api
.
core
.
enabled
"
true
]
[
"
layout
.
css
.
frames
-
timing
.
enabled
"
true
]
]
}
resolve
)
;
}
)
;
}
;
const
_addTab
=
addTab
;
addTab
=
async
function
(
url
)
{
await
enableAnimationFeatures
(
)
;
const
tab
=
await
_addTab
(
url
)
;
const
browser
=
tab
.
linkedBrowser
;
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
info
(
"
Loading
the
helper
frame
script
"
+
COMMON_FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
COMMON_FRAME_SCRIPT_URL
false
)
;
return
tab
;
}
;
const
clickOnAnimation
=
async
function
(
animationInspector
panel
index
)
{
info
(
"
Click
on
animation
"
+
index
+
"
in
the
timeline
"
)
;
const
summaryGraphEl
=
panel
.
querySelectorAll
(
"
.
animation
-
summary
-
graph
"
)
[
index
]
;
summaryGraphEl
.
scrollIntoView
(
false
)
;
const
bounds
=
summaryGraphEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
summaryGraphEl
x
y
{
}
summaryGraphEl
.
ownerGlobal
)
;
await
waitForAnimationDetail
(
animationInspector
)
;
}
;
const
clickOnDetailCloseButton
=
function
(
panel
)
{
info
(
"
Click
on
close
button
for
animation
detail
pane
"
)
;
const
buttonEl
=
panel
.
querySelector
(
"
.
animation
-
detail
-
close
-
button
"
)
;
const
bounds
=
buttonEl
.
getBoundingClientRect
(
)
;
const
x
=
bounds
.
width
/
2
;
const
y
=
bounds
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
buttonEl
x
y
{
}
buttonEl
.
ownerGlobal
)
;
}
;
const
selectNodeAndWaitForAnimations
=
async
function
(
data
inspector
reason
=
"
test
"
)
{
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
await
selectNode
(
data
inspector
reason
)
;
await
onUpdated
;
await
waitForRendering
(
inspector
.
animationinspector
)
;
}
;
const
setSidebarWidth
=
async
function
(
width
inspector
)
{
const
onUpdated
=
inspector
.
toolbox
.
once
(
"
inspector
-
sidebar
-
resized
"
)
;
inspector
.
splitBox
.
setState
(
{
width
}
)
;
await
onUpdated
;
}
;
const
waitForRendering
=
async
function
(
animationInspector
)
{
await
Promise
.
all
(
[
waitForAllAnimationTargets
(
animationInspector
)
waitForAllSummaryGraph
(
animationInspector
)
waitForAnimationDetail
(
animationInspector
)
]
)
;
}
;
const
waitForAnimationDetail
=
async
function
(
animationInspector
)
{
if
(
animationInspector
.
animations
.
length
=
=
=
1
)
{
await
animationInspector
.
once
(
"
animation
-
keyframes
-
rendered
"
)
;
}
}
;
const
waitForAllAnimationTargets
=
async
function
(
animationInspector
)
{
for
(
let
i
=
0
;
i
<
animationInspector
.
animations
.
length
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
target
-
rendered
"
)
;
}
}
;
const
waitForAllSummaryGraph
=
async
function
(
animationInspector
)
{
for
(
let
i
=
0
;
i
<
animationInspector
.
animations
.
length
;
i
+
+
)
{
await
animationInspector
.
once
(
"
animation
-
summary
-
graph
-
rendered
"
)
;
}
}
;
function
assertLinearGradient
(
linearGradientEl
offset
expectedColor
)
{
const
stopEl
=
findStopElement
(
linearGradientEl
offset
)
;
ok
(
stopEl
stop
element
at
offset
{
offset
}
should
exist
)
;
is
(
stopEl
.
getAttribute
(
"
stop
-
color
"
)
expectedColor
stop
-
color
of
stop
element
at
offset
{
offset
}
should
be
{
expectedColor
}
)
;
}
function
assertPathSegments
(
pathEl
hasClosePath
expectedValues
)
{
const
pathSegList
=
pathEl
.
pathSegList
;
ok
(
pathSegList
"
The
tested
element
should
have
pathSegList
"
)
;
expectedValues
.
forEach
(
expectedValue
=
>
{
ok
(
isPassingThrough
(
pathSegList
expectedValue
.
x
expectedValue
.
y
)
The
path
segment
of
x
{
expectedValue
.
x
}
y
{
expectedValue
.
y
}
+
should
be
passing
through
)
;
}
)
;
if
(
hasClosePath
)
{
const
closePathSeg
=
pathSegList
.
getItem
(
pathSegList
.
numberOfItems
-
1
)
;
is
(
closePathSeg
.
pathSegType
closePathSeg
.
PATHSEG_CLOSEPATH
"
The
last
segment
should
be
close
path
"
)
;
}
}
function
isPassingThrough
(
pathSegList
x
y
)
{
let
previousPathSeg
=
pathSegList
.
getItem
(
0
)
;
for
(
let
i
=
0
;
i
<
pathSegList
.
numberOfItems
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
pathSeg
.
x
=
=
=
undefined
)
{
continue
;
}
const
currentX
=
parseFloat
(
pathSeg
.
x
.
toFixed
(
3
)
)
;
const
currentY
=
parseFloat
(
pathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
currentX
=
=
=
x
&
&
currentY
=
=
=
y
)
{
return
true
;
}
const
previousX
=
parseFloat
(
previousPathSeg
.
x
.
toFixed
(
3
)
)
;
const
previousY
=
parseFloat
(
previousPathSeg
.
y
.
toFixed
(
3
)
)
;
if
(
previousX
<
=
x
&
&
x
<
=
currentX
&
&
Math
.
min
(
previousY
currentY
)
<
=
y
&
&
y
<
=
Math
.
max
(
previousY
currentY
)
)
{
return
true
;
}
previousPathSeg
=
pathSeg
;
}
return
false
;
}
function
findAnimationItemElementsByTargetClassName
(
panel
targetClassName
)
{
const
animationTargetEls
=
panel
.
querySelectorAll
(
"
.
animation
-
target
"
)
;
for
(
const
animationTargetEl
of
animationTargetEls
)
{
const
className
=
animationTargetEl
.
textContent
.
split
(
"
.
"
)
[
1
]
;
if
(
className
=
=
=
targetClassName
)
{
return
animationTargetEl
.
closest
(
"
.
animation
-
item
"
)
;
}
}
return
null
;
}
function
findStopElement
(
linearGradientEl
offset
)
{
for
(
const
stopEl
of
linearGradientEl
.
querySelectorAll
(
"
stop
"
)
)
{
if
(
offset
<
=
parseFloat
(
stopEl
.
getAttribute
(
"
offset
"
)
)
)
{
return
stopEl
;
}
}
return
null
;
}
