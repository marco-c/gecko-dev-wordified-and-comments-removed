"
use
strict
"
;
const
{
safeAsyncMethod
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
async
-
utils
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
WalkerEventListener
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
walker
-
event
-
listener
.
js
"
)
;
const
{
VIEW_NODE_VALUE_TYPE
VIEW_NODE_SHAPE_POINT_TYPE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
shared
/
node
-
types
.
js
"
)
;
const
{
TYPES
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
highlighters
.
mjs
"
)
;
loader
.
lazyRequireGetter
(
this
"
parseURL
"
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
resource
:
/
/
devtools
/
shared
/
async
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
gridsReducer
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
grids
/
reducers
/
grids
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
highlighterSettingsReducer
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
grids
/
reducers
/
highlighter
-
settings
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
flexboxReducer
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
flexbox
/
reducers
/
flexbox
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
deepEqual
"
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
true
)
;
loader
.
lazyGetter
(
this
"
HighlightersBundle
"
(
)
=
>
{
return
new
Localization
(
[
"
devtools
/
shared
/
highlighters
.
ftl
"
]
true
)
;
}
)
;
const
DEFAULT_HIGHLIGHTER_COLOR
=
"
#
9400FF
"
;
const
SUBGRID_PARENT_ALPHA
=
0
.
5
;
const
HIGHLIGHTER_EVENTS
=
{
[
TYPES
.
GRID
]
:
{
shown
:
"
grid
-
highlighter
-
shown
"
hidden
:
"
grid
-
highlighter
-
hidden
"
}
[
TYPES
.
GEOMETRY
]
:
{
shown
:
"
geometry
-
editor
-
highlighter
-
shown
"
hidden
:
"
geometry
-
editor
-
highlighter
-
hidden
"
}
[
TYPES
.
SHAPES
]
:
{
shown
:
"
shapes
-
highlighter
-
shown
"
hidden
:
"
shapes
-
highlighter
-
hidden
"
}
[
TYPES
.
TRANSFORM
]
:
{
shown
:
"
css
-
transform
-
highlighter
-
shown
"
hidden
:
"
css
-
transform
-
highlighter
-
hidden
"
}
}
;
const
GLEAN_TOOL_IDS
=
{
[
TYPES
.
FLEXBOX
]
:
"
flexbox_highlighter
"
[
TYPES
.
GRID
]
:
"
grid_highlighter
"
}
;
const
GLEAN_COUNTER_NAMES
=
{
[
TYPES
.
FLEXBOX
]
:
{
layout
:
"
devtoolsLayoutFlexboxhighlighter
"
markup
:
"
devtoolsMarkupFlexboxhighlighter
"
rule
:
"
devtoolsRulesFlexboxhighlighter
"
}
[
TYPES
.
GRID
]
:
{
grid
:
"
devtoolsGridGridinspector
"
markup
:
"
devtoolsMarkupGridinspector
"
rule
:
"
devtoolsRulesGridinspector
"
}
}
;
class
HighlightersOverlay
{
constructor
(
inspector
)
{
this
.
inspector
=
inspector
;
this
.
store
=
this
.
inspector
.
store
;
this
.
telemetry
=
this
.
inspector
.
telemetry
;
this
.
maxGridHighlighters
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
gridinspector
.
maxHighlighters
"
)
;
this
.
highlighters
=
{
}
;
this
.
gridHighlighters
=
new
Map
(
)
;
this
.
editors
=
{
}
;
this
.
state
=
{
grids
:
new
Map
(
)
shapes
:
{
}
}
;
this
.
geometryEditorHighlighterShown
=
null
;
this
.
hoveredHighlighterShown
=
null
;
this
.
shapesHighlighterShown
=
null
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onDisplayChange
=
this
.
onDisplayChange
.
bind
(
this
)
;
this
.
onMarkupMutation
=
this
.
onMarkupMutation
.
bind
(
this
)
;
this
.
onMouseMove
=
this
.
onMouseMove
.
bind
(
this
)
;
this
.
onMouseOut
=
this
.
onMouseOut
.
bind
(
this
)
;
this
.
hideAllHighlighters
=
this
.
hideAllHighlighters
.
bind
(
this
)
;
this
.
hideFlexboxHighlighter
=
this
.
hideFlexboxHighlighter
.
bind
(
this
)
;
this
.
hideGridHighlighter
=
this
.
hideGridHighlighter
.
bind
(
this
)
;
this
.
hideShapesHighlighter
=
this
.
hideShapesHighlighter
.
bind
(
this
)
;
this
.
showFlexboxHighlighter
=
this
.
showFlexboxHighlighter
.
bind
(
this
)
;
this
.
showGridHighlighter
=
this
.
showGridHighlighter
.
bind
(
this
)
;
this
.
showShapesHighlighter
=
this
.
showShapesHighlighter
.
bind
(
this
)
;
this
.
onShapesHighlighterShown
=
this
.
onShapesHighlighterShown
.
bind
(
this
)
;
this
.
onShapesHighlighterHidden
=
this
.
onShapesHighlighterHidden
.
bind
(
this
)
;
this
.
hideHighlighterType
=
safeAsyncMethod
(
this
.
hideHighlighterType
.
bind
(
this
)
(
)
=
>
this
.
destroyed
)
;
this
.
showHighlighterTypeForNode
=
safeAsyncMethod
(
this
.
showHighlighterTypeForNode
.
bind
(
this
)
(
)
=
>
this
.
destroyed
)
;
this
.
showGridHighlighter
=
safeAsyncMethod
(
this
.
showGridHighlighter
.
bind
(
this
)
(
)
=
>
this
.
destroyed
)
;
this
.
restoreState
=
safeAsyncMethod
(
this
.
restoreState
.
bind
(
this
)
(
)
=
>
this
.
destroyed
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
onMarkupMutation
)
;
this
.
resourceCommand
=
this
.
inspector
.
toolbox
.
resourceCommand
;
this
.
resourceCommand
.
watchResources
(
[
this
.
resourceCommand
.
TYPES
.
ROOT_NODE
]
{
onAvailable
:
this
.
#
onResourceAvailable
}
)
;
this
.
walkerEventListener
=
new
WalkerEventListener
(
this
.
inspector
{
"
display
-
change
"
:
this
.
onDisplayChange
}
)
;
if
(
this
.
toolbox
.
win
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
)
"
)
.
matches
)
{
this
.
#
showSimpleHighlightersMessage
(
)
;
}
EventEmitter
.
decorate
(
this
)
;
}
#
activeHighlighters
=
new
Map
(
)
;
#
pendingHighlighters
=
new
Map
(
)
;
#
restorableHighlighters
=
new
Map
(
)
;
#
lastHovered
=
null
;
get
inspectorFront
(
)
{
return
this
.
inspector
.
inspectorFront
;
}
get
target
(
)
{
return
this
.
inspector
.
currentTarget
;
}
get
toolbox
(
)
{
return
this
.
inspector
.
toolbox
;
}
#
afterShowHighlighterTypeForNode
(
type
nodeFront
options
)
{
switch
(
type
)
{
case
TYPES
.
FLEXBOX
:
case
TYPES
.
GRID
:
const
toolID
=
GLEAN_TOOL_IDS
[
type
]
;
if
(
toolID
)
{
this
.
telemetry
.
toolOpened
(
toolID
this
)
;
}
const
counterName
=
GLEAN_COUNTER_NAMES
[
type
]
?
.
[
options
?
.
trigger
]
;
if
(
counterName
)
{
Glean
[
counterName
]
.
opened
.
add
(
1
)
;
}
break
;
}
if
(
type
=
=
=
TYPES
.
FLEXBOX
)
{
const
{
url
}
=
this
.
target
;
const
selectors
=
[
.
.
.
this
.
inspector
.
selectionCssSelectors
]
;
this
.
#
restorableHighlighters
.
set
(
type
{
options
selectors
type
url
}
)
;
}
}
async
#
beforeShowHighlighterTypeForNode
(
type
nodeFront
options
)
{
const
{
highlighter
:
activeHighlighter
nodeFront
:
activeNodeFront
options
:
activeOptions
timer
:
activeTimer
}
=
this
.
getDataForActiveHighlighter
(
type
)
;
if
(
!
activeHighlighter
)
{
return
false
;
}
let
skipShow
=
false
;
clearTimeout
(
activeTimer
)
;
switch
(
type
)
{
case
TYPES
.
SELECTOR
:
if
(
nodeFront
=
=
=
activeNodeFront
&
&
options
?
.
selector
!
=
=
activeOptions
?
.
selector
)
{
await
this
.
hideHighlighterType
(
TYPES
.
SELECTOR
)
;
}
break
;
default
:
if
(
nodeFront
!
=
=
activeNodeFront
)
{
await
this
.
hideHighlighterType
(
type
)
;
}
else
if
(
deepEqual
(
options
activeOptions
)
)
{
skipShow
=
true
;
}
}
return
skipShow
;
}
#
beforeHideHighlighterType
(
type
)
{
switch
(
type
)
{
case
TYPES
.
FLEXBOX
:
case
TYPES
.
GRID
:
const
toolID
=
GLEAN_TOOL_IDS
[
type
]
;
const
conditions
=
{
[
TYPES
.
FLEXBOX
]
:
(
)
=
>
{
return
true
;
}
[
TYPES
.
GRID
]
:
(
)
=
>
{
return
this
.
gridHighlighters
.
size
=
=
=
1
;
}
}
;
if
(
toolID
&
&
conditions
[
type
]
.
call
(
this
)
)
{
this
.
telemetry
.
toolClosed
(
toolID
this
)
;
}
break
;
}
}
#
getMaxActiveHighlighters
(
type
)
{
let
max
;
switch
(
type
)
{
case
TYPES
.
GRID
:
max
=
this
.
maxGridHighlighters
;
break
;
default
:
max
=
1
;
}
return
max
;
}
async
#
getHighlighterTypeForNode
(
type
nodeFront
)
{
const
{
inspectorFront
}
=
nodeFront
;
const
max
=
this
.
#
getMaxActiveHighlighters
(
type
)
;
let
highlighter
;
if
(
max
=
=
=
1
)
{
highlighter
=
await
inspectorFront
.
getOrCreateHighlighterByType
(
type
)
;
}
else
{
highlighter
=
await
inspectorFront
.
getHighlighterByType
(
type
)
;
}
return
highlighter
;
}
getActiveHighlighter
(
type
)
{
if
(
!
this
.
#
activeHighlighters
.
has
(
type
)
)
{
return
null
;
}
const
{
highlighter
}
=
this
.
#
activeHighlighters
.
get
(
type
)
;
return
highlighter
;
}
getDataForActiveHighlighter
(
type
)
{
if
(
!
this
.
#
activeHighlighters
.
has
(
type
)
)
{
return
{
}
;
}
return
this
.
#
activeHighlighters
.
get
(
type
)
;
}
getOptionsForActiveHighlighter
(
type
)
{
const
{
options
}
=
this
.
getDataForActiveHighlighter
(
type
)
;
return
options
;
}
getNodeForActiveHighlighter
(
type
)
{
if
(
!
this
.
#
activeHighlighters
.
has
(
type
)
)
{
return
null
;
}
const
{
nodeFront
}
=
this
.
#
activeHighlighters
.
get
(
type
)
;
return
nodeFront
;
}
async
showHighlighterTypeForNode
(
type
nodeFront
options
)
{
const
promise
=
this
.
#
beforeShowHighlighterTypeForNode
(
type
nodeFront
options
)
;
const
id
=
Symbol
(
)
;
this
.
#
pendingHighlighters
.
set
(
type
id
)
;
const
skipShow
=
await
promise
;
if
(
this
.
#
pendingHighlighters
.
get
(
type
)
!
=
=
id
)
{
return
;
}
else
if
(
skipShow
|
|
nodeFront
.
isDestroyed
(
)
)
{
this
.
#
pendingHighlighters
.
delete
(
type
)
;
return
;
}
const
highlighter
=
await
this
.
#
getHighlighterTypeForNode
(
type
nodeFront
)
;
if
(
this
.
#
pendingHighlighters
.
get
(
type
)
!
=
=
id
)
{
return
;
}
this
.
#
pendingHighlighters
.
delete
(
type
)
;
const
timer
=
this
.
scheduleAutoHideHighlighterType
(
type
options
?
.
duration
)
;
this
.
#
activeHighlighters
.
set
(
type
{
nodeFront
highlighter
options
timer
}
)
;
await
highlighter
.
show
(
nodeFront
options
)
;
this
.
#
afterShowHighlighterTypeForNode
(
type
nodeFront
options
)
;
if
(
HIGHLIGHTER_EVENTS
[
type
]
?
.
shown
)
{
this
.
emit
(
HIGHLIGHTER_EVENTS
[
type
]
.
shown
nodeFront
options
)
;
}
this
.
emit
(
"
highlighter
-
shown
"
{
type
highlighter
nodeFront
options
}
)
;
}
scheduleAutoHideHighlighterType
(
type
duration
)
{
if
(
!
duration
)
{
return
undefined
;
}
const
timer
=
setTimeout
(
async
(
)
=
>
{
await
this
.
hideHighlighterType
(
type
)
;
clearTimeout
(
timer
)
;
}
duration
)
;
return
timer
;
}
async
hideHighlighterType
(
type
)
{
if
(
this
.
#
pendingHighlighters
.
has
(
type
)
)
{
this
.
#
pendingHighlighters
.
delete
(
type
)
;
}
if
(
!
this
.
#
activeHighlighters
.
has
(
type
)
)
{
return
;
}
const
data
=
this
.
getDataForActiveHighlighter
(
type
)
;
const
{
highlighter
nodeFront
timer
}
=
data
;
clearTimeout
(
timer
)
;
this
.
#
restorableHighlighters
.
delete
(
type
)
;
this
.
#
activeHighlighters
.
delete
(
type
)
;
this
.
#
beforeHideHighlighterType
(
type
)
;
await
highlighter
.
hide
(
)
;
if
(
HIGHLIGHTER_EVENTS
[
type
]
?
.
hidden
)
{
this
.
emit
(
HIGHLIGHTER_EVENTS
[
type
]
.
hidden
nodeFront
)
;
}
this
.
emit
(
"
highlighter
-
hidden
"
{
type
.
.
.
data
}
)
;
}
canGridHighlighterToggle
(
node
)
{
return
(
this
.
maxGridHighlighters
=
=
=
1
|
|
this
.
gridHighlighters
.
size
<
this
.
maxGridHighlighters
|
|
this
.
gridHighlighters
.
has
(
node
)
)
;
}
isGridHighlighterLimitReached
(
)
{
return
this
.
gridHighlighters
.
size
=
=
=
this
.
maxGridHighlighters
;
}
isRuleView
(
node
)
{
return
!
!
node
.
closest
(
"
#
ruleview
-
panel
"
)
;
}
addToView
(
view
)
{
const
el
=
view
.
element
;
el
.
addEventListener
(
"
click
"
this
.
onClick
true
)
;
el
.
addEventListener
(
"
mousemove
"
this
.
onMouseMove
)
;
el
.
addEventListener
(
"
mouseout
"
this
.
onMouseOut
)
;
el
.
ownerDocument
.
defaultView
.
addEventListener
(
"
mouseout
"
this
.
onMouseOut
)
;
}
removeFromView
(
view
)
{
const
el
=
view
.
element
;
el
.
removeEventListener
(
"
click
"
this
.
onClick
true
)
;
el
.
removeEventListener
(
"
mousemove
"
this
.
onMouseMove
)
;
el
.
removeEventListener
(
"
mouseout
"
this
.
onMouseOut
)
;
}
async
toggleShapesHighlighter
(
node
options
textProperty
)
{
const
shapesEditor
=
await
this
.
getInContextEditor
(
node
"
shapesEditor
"
)
;
if
(
!
shapesEditor
)
{
return
;
}
shapesEditor
.
toggle
(
node
options
textProperty
)
;
}
async
showShapesHighlighter
(
node
options
)
{
const
shapesEditor
=
await
this
.
getInContextEditor
(
node
"
shapesEditor
"
)
;
if
(
!
shapesEditor
)
{
return
;
}
shapesEditor
.
show
(
node
options
)
;
}
onShapesHighlighterShown
(
data
)
{
const
{
node
options
}
=
data
;
this
.
shapesHighlighterShown
=
node
;
this
.
state
.
shapes
.
options
=
options
;
this
.
emit
(
"
shapes
-
highlighter
-
shown
"
node
options
)
;
}
async
hideShapesHighlighter
(
node
)
{
const
shapesEditor
=
await
this
.
getInContextEditor
(
node
"
shapesEditor
"
)
;
if
(
!
shapesEditor
)
{
return
;
}
shapesEditor
.
hide
(
)
;
}
onShapesHighlighterHidden
(
)
{
this
.
emit
(
"
shapes
-
highlighter
-
hidden
"
this
.
shapesHighlighterShown
this
.
state
.
shapes
.
options
)
;
this
.
shapesHighlighterShown
=
null
;
this
.
state
.
shapes
=
{
}
;
}
async
hoverPointShapesHighlighter
(
node
point
)
{
if
(
node
=
=
this
.
shapesHighlighterShown
)
{
const
options
=
Object
.
assign
(
{
}
this
.
state
.
shapes
.
options
)
;
options
.
hoverPoint
=
point
;
await
this
.
showShapesHighlighter
(
node
options
)
;
}
}
async
getFlexboxHighlighterColor
(
)
{
const
state
=
this
.
store
.
getState
(
)
;
if
(
!
state
.
flexbox
)
{
this
.
store
.
injectReducer
(
"
flexbox
"
flexboxReducer
)
;
}
const
{
flexbox
}
=
this
.
store
.
getState
(
)
;
const
color
=
flexbox
.
color
;
if
(
color
)
{
return
color
;
}
const
customHostColors
=
(
await
asyncStorage
.
getItem
(
"
flexboxInspectorHostColors
"
)
)
|
|
{
}
;
let
hostname
;
try
{
hostname
=
parseURL
(
this
.
target
.
url
)
.
hostname
|
|
parseURL
(
this
.
target
.
url
)
.
protocol
;
}
catch
(
e
)
{
this
.
#
handleRejection
(
e
)
;
}
return
hostname
&
&
customHostColors
[
hostname
]
?
customHostColors
[
hostname
]
:
DEFAULT_HIGHLIGHTER_COLOR
;
}
async
toggleFlexboxHighlighter
(
node
trigger
)
{
const
highlightedNode
=
this
.
getNodeForActiveHighlighter
(
TYPES
.
FLEXBOX
)
;
if
(
node
=
=
highlightedNode
)
{
await
this
.
hideFlexboxHighlighter
(
node
)
;
return
;
}
await
this
.
showFlexboxHighlighter
(
node
{
}
trigger
)
;
}
async
showFlexboxHighlighter
(
node
options
trigger
)
{
const
color
=
await
this
.
getFlexboxHighlighterColor
(
node
)
;
await
this
.
showHighlighterTypeForNode
(
TYPES
.
FLEXBOX
node
{
.
.
.
options
trigger
color
}
)
;
}
async
hideFlexboxHighlighter
(
)
{
await
this
.
hideHighlighterType
(
TYPES
.
FLEXBOX
)
;
}
getGridHighlighterSettings
(
nodeFront
)
{
const
state
=
this
.
store
.
getState
(
)
;
if
(
!
state
.
grids
)
{
this
.
store
.
injectReducer
(
"
grids
"
gridsReducer
)
;
}
if
(
!
state
.
highlighterSettings
)
{
this
.
store
.
injectReducer
(
"
highlighterSettings
"
highlighterSettingsReducer
)
;
}
const
{
grids
highlighterSettings
}
=
this
.
store
.
getState
(
)
;
const
grid
=
grids
.
find
(
g
=
>
g
.
nodeFront
=
=
=
nodeFront
)
;
const
color
=
grid
?
grid
.
color
:
DEFAULT_HIGHLIGHTER_COLOR
;
const
zIndex
=
grid
?
grid
.
zIndex
:
0
;
return
Object
.
assign
(
{
}
highlighterSettings
{
color
zIndex
}
)
;
}
getHighlightedGridNodes
(
)
{
return
[
.
.
.
Array
.
from
(
this
.
gridHighlighters
.
keys
(
)
)
]
;
}
async
toggleGridHighlighter
(
node
trigger
)
{
if
(
this
.
gridHighlighters
.
has
(
node
)
)
{
await
this
.
hideGridHighlighter
(
node
)
;
return
;
}
await
this
.
showGridHighlighter
(
node
{
}
trigger
)
;
}
async
showGridHighlighter
(
node
options
trigger
)
{
if
(
!
this
.
gridHighlighters
.
has
(
node
)
)
{
if
(
this
.
maxGridHighlighters
=
=
=
1
)
{
await
this
.
hideGridHighlighter
(
this
.
gridHighlighters
.
keys
(
)
.
next
(
)
.
value
)
;
}
else
if
(
this
.
gridHighlighters
.
size
=
=
=
this
.
maxGridHighlighters
)
{
return
;
}
}
const
isHighlightedAsParentGrid
=
Array
.
from
(
this
.
gridHighlighters
.
values
(
)
)
.
map
(
value
=
>
value
.
parentGridNode
)
.
includes
(
node
)
;
if
(
isHighlightedAsParentGrid
)
{
await
this
.
hideParentGridHighlighter
(
node
)
;
}
let
parentGridNode
=
null
;
let
parentGridHighlighter
=
null
;
if
(
node
.
displayType
=
=
=
"
subgrid
"
)
{
parentGridNode
=
await
node
.
walkerFront
.
getParentGridNode
(
node
)
;
parentGridHighlighter
=
await
this
.
showParentGridHighlighter
(
parentGridNode
)
;
}
let
highlighter
;
if
(
this
.
gridHighlighters
.
has
(
node
)
)
{
highlighter
=
this
.
gridHighlighters
.
get
(
node
)
.
highlighter
;
}
if
(
!
highlighter
)
{
highlighter
=
await
this
.
#
getHighlighterTypeForNode
(
TYPES
.
GRID
node
)
;
}
this
.
gridHighlighters
.
set
(
node
{
highlighter
parentGridNode
parentGridHighlighter
}
)
;
options
=
{
.
.
.
options
.
.
.
this
.
getGridHighlighterSettings
(
node
)
}
;
await
highlighter
.
show
(
node
options
)
;
this
.
#
afterShowHighlighterTypeForNode
(
TYPES
.
GRID
node
{
.
.
.
options
trigger
}
)
;
try
{
const
{
url
}
=
this
.
target
;
const
selectors
=
await
this
.
inspector
.
commands
.
inspectorCommand
.
getNodeFrontSelectorsFromTopDocument
(
node
)
;
this
.
state
.
grids
.
set
(
node
{
selectors
options
url
}
)
;
this
.
emit
(
"
grid
-
highlighter
-
shown
"
node
options
)
;
this
.
emit
(
"
highlighter
-
shown
"
{
type
:
TYPES
.
GRID
nodeFront
:
node
highlighter
options
}
)
;
}
catch
(
e
)
{
this
.
#
handleRejection
(
e
)
;
}
}
async
showParentGridHighlighter
(
node
)
{
const
isHighlighted
=
Array
.
from
(
this
.
gridHighlighters
.
keys
(
)
)
.
includes
(
node
)
;
if
(
!
node
|
|
isHighlighted
)
{
return
null
;
}
let
highlighter
=
this
.
getParentGridHighlighter
(
node
)
;
if
(
!
highlighter
)
{
highlighter
=
await
this
.
#
getHighlighterTypeForNode
(
TYPES
.
GRID
node
)
;
}
const
options
=
{
.
.
.
this
.
getGridHighlighterSettings
(
node
)
globalAlpha
:
SUBGRID_PARENT_ALPHA
isParent
:
true
}
;
await
highlighter
.
show
(
node
options
)
;
this
.
emitForTests
(
"
highlighter
-
shown
"
{
type
:
TYPES
.
GRID
nodeFront
:
node
highlighter
options
}
)
;
return
highlighter
;
}
getParentGridHighlighter
(
node
)
{
const
value
=
Array
.
from
(
this
.
gridHighlighters
.
values
(
)
)
.
find
(
(
{
parentGridNode
}
)
=
>
{
return
parentGridNode
=
=
=
node
;
}
)
;
if
(
!
value
)
{
return
null
;
}
const
{
parentGridHighlighter
}
=
value
;
return
parentGridHighlighter
;
}
async
restoreParentGridHighlighter
(
node
)
{
const
entry
=
Array
.
from
(
this
.
gridHighlighters
.
entries
(
)
)
.
find
(
(
[
value
]
)
=
>
{
return
value
?
.
parentGridNode
=
=
=
node
;
}
)
;
if
(
!
Array
.
isArray
(
entry
)
)
{
return
;
}
const
[
highlightedSubgridNode
data
]
=
entry
;
if
(
!
data
.
parentGridHighlighter
)
{
const
parentGridHighlighter
=
await
this
.
showParentGridHighlighter
(
node
)
;
this
.
gridHighlighters
.
set
(
highlightedSubgridNode
{
.
.
.
data
parentGridHighlighter
}
)
;
}
}
async
hideGridHighlighter
(
node
)
{
const
{
highlighter
parentGridNode
}
=
this
.
gridHighlighters
.
get
(
node
)
|
|
{
}
;
if
(
!
highlighter
)
{
return
;
}
if
(
parentGridNode
)
{
await
this
.
hideParentGridHighlighter
(
parentGridNode
)
;
}
this
.
#
beforeHideHighlighterType
(
TYPES
.
GRID
)
;
highlighter
.
destroy
(
)
;
this
.
gridHighlighters
.
delete
(
node
)
;
this
.
state
.
grids
.
delete
(
node
)
;
await
this
.
restoreParentGridHighlighter
(
node
)
;
this
.
emit
(
"
grid
-
highlighter
-
hidden
"
node
)
;
this
.
emit
(
"
highlighter
-
hidden
"
{
type
:
TYPES
.
GRID
nodeFront
:
node
}
)
;
}
async
hideParentGridHighlighter
(
node
)
{
let
count
=
0
;
let
parentGridHighlighter
;
let
subgridNode
;
for
(
const
[
key
value
]
of
this
.
gridHighlighters
.
entries
(
)
)
{
if
(
value
.
parentGridNode
=
=
=
node
)
{
parentGridHighlighter
=
value
.
parentGridHighlighter
;
subgridNode
=
key
;
count
+
+
;
}
}
if
(
!
parentGridHighlighter
|
|
count
>
1
)
{
return
;
}
parentGridHighlighter
.
destroy
(
)
;
this
.
gridHighlighters
.
set
(
subgridNode
{
.
.
.
this
.
gridHighlighters
.
get
(
subgridNode
)
parentGridHighlighter
:
null
}
)
;
}
async
toggleGeometryHighlighter
(
node
)
{
if
(
node
=
=
this
.
geometryEditorHighlighterShown
)
{
await
this
.
hideGeometryEditor
(
)
;
return
;
}
await
this
.
showGeometryEditor
(
node
)
;
}
async
showGeometryEditor
(
node
)
{
const
highlighter
=
await
this
.
#
getHighlighterTypeForNode
(
TYPES
.
GEOMETRY
node
)
;
if
(
!
highlighter
)
{
return
;
}
const
isShown
=
await
highlighter
.
show
(
node
)
;
if
(
!
isShown
)
{
return
;
}
this
.
emit
(
"
geometry
-
editor
-
highlighter
-
shown
"
)
;
this
.
geometryEditorHighlighterShown
=
node
;
}
async
hideGeometryEditor
(
)
{
if
(
!
this
.
geometryEditorHighlighterShown
)
{
return
;
}
const
highlighter
=
this
.
geometryEditorHighlighterShown
.
inspectorFront
.
getKnownHighlighter
(
TYPES
.
GEOMETRY
)
;
if
(
!
highlighter
)
{
return
;
}
await
highlighter
.
hide
(
)
;
this
.
emit
(
"
geometry
-
editor
-
highlighter
-
hidden
"
)
;
this
.
geometryEditorHighlighterShown
=
null
;
}
async
restoreFlexboxState
(
)
{
const
state
=
this
.
#
restorableHighlighters
.
get
(
TYPES
.
FLEXBOX
)
;
if
(
!
state
)
{
return
;
}
this
.
#
restorableHighlighters
.
delete
(
TYPES
.
FLEXBOX
)
;
await
this
.
restoreState
(
TYPES
.
FLEXBOX
state
this
.
showFlexboxHighlighter
)
;
}
async
restoreGridState
(
)
{
const
values
=
[
.
.
.
this
.
state
.
grids
.
values
(
)
]
;
this
.
state
.
grids
.
clear
(
)
;
try
{
for
(
const
gridState
of
values
)
{
await
this
.
restoreState
(
TYPES
.
GRID
gridState
this
.
showGridHighlighter
)
;
}
}
catch
(
e
)
{
this
.
#
handleRejection
(
e
)
;
}
}
async
restoreState
(
type
state
showFunction
)
{
const
{
selectors
=
[
]
options
url
}
=
state
;
if
(
!
selectors
.
length
|
|
url
!
=
=
this
.
target
.
url
)
{
this
.
emit
(
highlighter
-
discarded
{
type
}
)
;
return
;
}
const
nodeFront
=
await
this
.
inspector
.
commands
.
inspectorCommand
.
findNodeFrontFromSelectors
(
selectors
)
;
if
(
nodeFront
)
{
await
showFunction
(
nodeFront
options
)
;
this
.
emit
(
highlighter
-
restored
{
type
}
)
;
}
else
{
this
.
emit
(
highlighter
-
discarded
{
type
}
)
;
}
}
async
getInContextEditor
(
node
type
)
{
if
(
this
.
editors
[
type
]
)
{
return
this
.
editors
[
type
]
;
}
let
editor
;
switch
(
type
)
{
case
"
shapesEditor
"
:
const
highlighter
=
await
this
.
#
getHighlighterTypeForNode
(
TYPES
.
SHAPES
node
)
;
if
(
!
highlighter
)
{
return
null
;
}
const
ShapesInContextEditor
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ShapesInContextEditor
.
js
"
)
;
editor
=
new
ShapesInContextEditor
(
highlighter
this
.
inspector
this
.
state
)
;
editor
.
on
(
"
show
"
this
.
onShapesHighlighterShown
)
;
editor
.
on
(
"
hide
"
this
.
onShapesHighlighterHidden
)
;
break
;
default
:
throw
new
Error
(
Unsupported
in
-
context
editor
'
{
name
}
'
)
;
}
this
.
editors
[
type
]
=
editor
;
return
editor
;
}
async
#
getHighlighter
(
type
)
{
if
(
this
.
highlighters
[
type
]
)
{
return
this
.
highlighters
[
type
]
;
}
let
highlighter
;
try
{
highlighter
=
await
this
.
inspectorFront
.
getHighlighterByType
(
type
)
;
}
catch
(
e
)
{
this
.
#
handleRejection
(
e
)
;
}
if
(
!
highlighter
)
{
return
null
;
}
this
.
highlighters
[
type
]
=
highlighter
;
return
highlighter
;
}
#
handleRejection
=
error
=
>
{
if
(
!
this
.
destroyed
)
{
console
.
error
(
error
)
;
}
}
;
_toggleShapePointActive
(
node
active
)
{
if
(
this
.
inspector
.
selection
.
nodeFront
!
=
this
.
shapesHighlighterShown
)
{
return
;
}
node
.
classList
.
toggle
(
"
active
"
active
)
;
}
#
hideHoveredHighlighter
(
)
{
if
(
!
this
.
hoveredHighlighterShown
|
|
!
this
.
highlighters
[
this
.
hoveredHighlighterShown
]
)
{
return
;
}
const
onHidden
=
this
.
highlighters
[
this
.
hoveredHighlighterShown
]
.
hide
(
)
;
if
(
onHidden
)
{
onHidden
.
catch
(
console
.
error
)
;
}
this
.
hoveredHighlighterShown
=
null
;
this
.
emit
(
"
css
-
transform
-
highlighter
-
hidden
"
)
;
}
async
#
hideHighlighterIfDeadNode
(
node
hideHighlighter
)
{
if
(
!
node
)
{
return
;
}
try
{
const
isInTree
=
node
.
walkerFront
&
&
(
await
node
.
walkerFront
.
isInDOMTree
(
node
)
)
;
if
(
!
isInTree
)
{
await
hideHighlighter
(
node
)
;
}
}
catch
(
e
)
{
this
.
#
handleRejection
(
e
)
;
}
}
#
isComputedViewTransform
(
nodeInfo
)
{
if
(
nodeInfo
.
view
!
=
"
computed
"
)
{
return
false
;
}
return
(
nodeInfo
.
type
=
=
=
VIEW_NODE_VALUE_TYPE
&
&
nodeInfo
.
value
.
property
=
=
=
"
transform
"
)
;
}
#
isRuleViewShapeSwatch
(
node
)
{
return
(
this
.
isRuleView
(
node
)
&
&
node
.
classList
.
contains
(
"
inspector
-
shapeswatch
"
)
)
;
}
#
isRuleViewTransform
(
nodeInfo
)
{
if
(
nodeInfo
.
view
!
=
"
rule
"
)
{
return
false
;
}
const
isTransform
=
nodeInfo
.
type
=
=
=
VIEW_NODE_VALUE_TYPE
&
&
nodeInfo
.
value
.
property
=
=
=
"
transform
"
;
const
isEnabled
=
nodeInfo
.
value
.
enabled
&
&
!
nodeInfo
.
value
.
overridden
&
&
!
nodeInfo
.
value
.
pseudoElement
;
return
isTransform
&
&
isEnabled
;
}
isRuleViewShapePoint
(
nodeInfo
)
{
if
(
nodeInfo
.
view
!
=
"
rule
"
)
{
return
false
;
}
const
isShape
=
nodeInfo
.
type
=
=
=
VIEW_NODE_SHAPE_POINT_TYPE
&
&
(
nodeInfo
.
value
.
property
=
=
=
"
clip
-
path
"
|
|
nodeInfo
.
value
.
property
=
=
=
"
shape
-
outside
"
)
;
const
isEnabled
=
nodeInfo
.
value
.
enabled
&
&
!
nodeInfo
.
value
.
overridden
&
&
!
nodeInfo
.
value
.
pseudoElement
;
return
(
isShape
&
&
isEnabled
&
&
nodeInfo
.
value
.
toggleActive
&
&
!
this
.
state
.
shapes
.
options
.
transformMode
)
;
}
onClick
(
event
)
{
if
(
this
.
#
isRuleViewShapeSwatch
(
event
.
target
)
)
{
event
.
stopPropagation
(
)
;
const
view
=
this
.
inspector
.
getPanel
(
"
ruleview
"
)
.
view
;
const
nodeInfo
=
view
.
getNodeInfo
(
event
.
target
)
;
this
.
toggleShapesHighlighter
(
this
.
inspector
.
selection
.
nodeFront
{
mode
:
event
.
target
.
dataset
.
mode
transformMode
:
event
.
metaKey
|
|
event
.
ctrlKey
}
nodeInfo
.
value
.
textProperty
)
;
}
}
async
onDisplayChange
(
nodes
)
{
const
highlightedGridNodes
=
this
.
getHighlightedGridNodes
(
)
;
for
(
const
node
of
nodes
)
{
const
display
=
node
.
displayType
;
if
(
display
!
=
=
"
flex
"
&
&
display
!
=
=
"
inline
-
flex
"
&
&
node
=
=
this
.
getNodeForActiveHighlighter
(
TYPES
.
FLEXBOX
)
)
{
await
this
.
hideFlexboxHighlighter
(
node
)
;
return
;
}
if
(
display
!
=
=
"
grid
"
&
&
display
!
=
=
"
inline
-
grid
"
&
&
display
!
=
=
"
subgrid
"
&
&
highlightedGridNodes
.
includes
(
node
)
)
{
await
this
.
hideGridHighlighter
(
node
)
;
return
;
}
}
}
onMouseMove
(
event
)
{
if
(
event
.
target
=
=
=
this
.
#
lastHovered
)
{
return
;
}
this
.
#
hideHoveredHighlighter
(
)
;
this
.
#
lastHovered
=
event
.
target
;
const
view
=
this
.
isRuleView
(
this
.
#
lastHovered
)
?
this
.
inspector
.
getPanel
(
"
ruleview
"
)
.
view
:
this
.
inspector
.
getPanel
(
"
computedview
"
)
.
computedView
;
const
nodeInfo
=
view
.
getNodeInfo
(
event
.
target
)
;
if
(
!
nodeInfo
)
{
return
;
}
if
(
this
.
isRuleViewShapePoint
(
nodeInfo
)
)
{
const
{
point
}
=
nodeInfo
.
value
;
this
.
hoverPointShapesHighlighter
(
this
.
inspector
.
selection
.
nodeFront
point
)
;
return
;
}
let
type
;
if
(
this
.
#
isRuleViewTransform
(
nodeInfo
)
|
|
this
.
#
isComputedViewTransform
(
nodeInfo
)
)
{
type
=
TYPES
.
TRANSFORM
;
}
if
(
type
)
{
this
.
hoveredHighlighterShown
=
type
;
const
node
=
this
.
inspector
.
selection
.
nodeFront
;
this
.
#
getHighlighter
(
type
)
.
then
(
highlighter
=
>
highlighter
.
show
(
node
)
.
then
(
shown
=
>
{
if
(
shown
)
{
this
.
emit
(
"
css
-
transform
-
highlighter
-
shown
"
highlighter
)
;
}
}
)
)
;
}
}
onMouseOut
(
event
)
{
if
(
!
this
.
#
lastHovered
|
|
(
event
&
&
this
.
#
lastHovered
.
contains
(
event
.
relatedTarget
)
)
)
{
return
;
}
const
view
=
this
.
isRuleView
(
this
.
#
lastHovered
)
?
this
.
inspector
.
getPanel
(
"
ruleview
"
)
.
view
:
this
.
inspector
.
getPanel
(
"
computedview
"
)
.
computedView
;
const
nodeInfo
=
view
.
getNodeInfo
(
this
.
#
lastHovered
)
;
if
(
nodeInfo
&
&
this
.
isRuleViewShapePoint
(
nodeInfo
)
)
{
this
.
hoverPointShapesHighlighter
(
this
.
inspector
.
selection
.
nodeFront
null
)
;
}
this
.
#
lastHovered
=
null
;
this
.
#
hideHoveredHighlighter
(
)
;
}
#
onResourceAvailable
=
async
resources
=
>
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
!
=
=
this
.
resourceCommand
.
TYPES
.
ROOT_NODE
|
|
resource
.
isDestroyed
(
)
)
{
continue
;
}
if
(
resource
.
targetFront
.
isTopLevel
&
&
resource
.
isTopLevelDocument
)
{
continue
;
}
await
this
.
#
hideOrphanedHighlighters
(
)
;
}
}
;
async
onMarkupMutation
(
mutations
)
{
const
hasInterestingMutation
=
mutations
.
some
(
mut
=
>
mut
.
type
=
=
=
"
childList
"
)
;
if
(
!
hasInterestingMutation
)
{
return
;
}
await
this
.
#
hideOrphanedHighlighters
(
)
;
}
async
#
hideOrphanedHighlighters
(
)
{
await
this
.
#
hideHighlighterIfDeadNode
(
this
.
shapesHighlighterShown
this
.
hideShapesHighlighter
)
;
const
promises
=
[
]
;
for
(
const
[
type
data
]
of
this
.
#
activeHighlighters
)
{
promises
.
push
(
this
.
#
hideHighlighterIfDeadNode
(
data
.
nodeFront
(
)
=
>
{
return
this
.
hideHighlighterType
(
type
)
;
}
)
)
;
}
const
highlightedGridNodes
=
this
.
getHighlightedGridNodes
(
)
;
for
(
const
node
of
highlightedGridNodes
)
{
promises
.
push
(
this
.
#
hideHighlighterIfDeadNode
(
node
this
.
hideGridHighlighter
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
hideAllHighlighters
(
)
{
this
.
destroyEditors
(
)
;
for
(
const
{
highlighter
timer
}
of
this
.
#
activeHighlighters
.
values
(
)
)
{
await
highlighter
.
hide
(
)
;
clearTimeout
(
timer
)
;
}
this
.
#
activeHighlighters
.
clear
(
)
;
this
.
#
pendingHighlighters
.
clear
(
)
;
this
.
gridHighlighters
.
clear
(
)
;
this
.
geometryEditorHighlighterShown
=
null
;
this
.
hoveredHighlighterShown
=
null
;
this
.
shapesHighlighterShown
=
null
;
}
#
showSimpleHighlightersMessage
(
)
{
const
pref
=
"
devtools
.
inspector
.
simple
-
highlighters
.
message
-
dismissed
"
;
const
messageDismissed
=
Services
.
prefs
.
getBoolPref
(
pref
false
)
;
if
(
messageDismissed
)
{
return
;
}
const
notificationBox
=
this
.
inspector
.
toolbox
.
getNotificationBox
(
)
;
const
message
=
HighlightersBundle
.
formatValueSync
(
"
simple
-
highlighters
-
message
"
)
;
notificationBox
.
appendNotification
(
message
"
simple
-
highlighters
-
message
"
null
notificationBox
.
PRIORITY_INFO_MEDIUM
[
{
label
:
HighlightersBundle
.
formatValueSync
(
"
simple
-
highlighters
-
settings
-
button
"
)
callback
:
async
(
)
=
>
{
const
{
panelDoc
}
=
await
this
.
toolbox
.
selectTool
(
"
options
"
)
;
const
option
=
panelDoc
.
querySelector
(
"
[
data
-
pref
=
'
devtools
.
inspector
.
simple
-
highlighters
-
reduced
-
motion
'
]
"
)
.
parentNode
;
option
.
scrollIntoView
(
{
block
:
"
center
"
}
)
;
option
.
classList
.
add
(
"
options
-
panel
-
highlight
"
)
;
this
.
toolbox
.
emitForTests
(
"
test
-
highlighters
-
settings
-
opened
"
)
;
}
}
]
evt
=
>
{
if
(
evt
=
=
=
"
removed
"
)
{
Services
.
prefs
.
setBoolPref
(
pref
true
)
;
}
}
)
;
}
destroyEditors
(
)
{
for
(
const
type
in
this
.
editors
)
{
this
.
editors
[
type
]
.
off
(
"
show
"
)
;
this
.
editors
[
type
]
.
off
(
"
hide
"
)
;
this
.
editors
[
type
]
.
destroy
(
)
;
}
this
.
editors
=
{
}
;
}
destroyHighlighters
(
)
{
const
values
=
[
.
.
.
this
.
#
activeHighlighters
.
values
(
)
.
.
.
this
.
gridHighlighters
.
values
(
)
]
;
for
(
const
{
highlighter
parentGridHighlighter
timer
}
of
values
)
{
if
(
highlighter
)
{
highlighter
.
destroy
(
)
;
}
if
(
parentGridHighlighter
)
{
parentGridHighlighter
.
destroy
(
)
;
}
if
(
timer
)
{
clearTimeout
(
timer
)
;
}
}
this
.
#
activeHighlighters
.
clear
(
)
;
this
.
#
pendingHighlighters
.
clear
(
)
;
this
.
gridHighlighters
.
clear
(
)
;
for
(
const
type
in
this
.
highlighters
)
{
if
(
this
.
highlighters
[
type
]
)
{
this
.
highlighters
[
type
]
.
finalize
(
)
;
this
.
highlighters
[
type
]
=
null
;
}
}
}
destroy
(
)
{
this
.
inspector
.
off
(
"
markupmutation
"
this
.
onMarkupMutation
)
;
this
.
resourceCommand
.
unwatchResources
(
[
this
.
resourceCommand
.
TYPES
.
ROOT_NODE
]
{
onAvailable
:
this
.
#
onResourceAvailable
}
)
;
this
.
walkerEventListener
.
destroy
(
)
;
this
.
walkerEventListener
=
null
;
this
.
destroyEditors
(
)
;
this
.
destroyHighlighters
(
)
;
this
.
#
lastHovered
=
null
;
this
.
inspector
=
null
;
this
.
state
=
null
;
this
.
store
=
null
;
this
.
telemetry
=
null
;
this
.
geometryEditorHighlighterShown
=
null
;
this
.
hoveredHighlighterShown
=
null
;
this
.
shapesHighlighterShown
=
null
;
this
.
destroyed
=
true
;
}
}
HighlightersOverlay
.
TYPES
=
HighlightersOverlay
.
prototype
.
TYPES
=
TYPES
;
module
.
exports
=
HighlightersOverlay
;
