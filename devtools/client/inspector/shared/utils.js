"
use
strict
"
;
const
{
parseDeclarations
}
=
require
(
"
devtools
/
shared
/
css
/
parsing
-
utils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
throttle
}
=
require
(
"
devtools
/
shared
/
throttle
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
advanceValidate
(
keyCode
value
insertionPoint
)
{
if
(
keyCode
!
=
=
KeyCodes
.
DOM_VK_SEMICOLON
)
{
return
false
;
}
value
=
value
.
slice
(
0
insertionPoint
)
+
"
;
"
+
value
.
slice
(
insertionPoint
)
;
let
lexer
=
getCSSLexer
(
value
)
;
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
token
.
endOffset
>
insertionPoint
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
;
"
)
{
return
true
;
}
break
;
}
}
return
false
;
}
function
appendText
(
parent
text
)
{
parent
.
appendChild
(
parent
.
ownerDocument
.
createTextNode
(
text
)
)
;
}
function
blurOnMultipleProperties
(
cssProperties
)
{
return
(
e
)
=
>
{
setTimeout
(
(
)
=
>
{
let
props
=
parseDeclarations
(
cssProperties
.
isKnown
e
.
target
.
value
)
;
if
(
props
.
length
>
1
)
{
e
.
target
.
blur
(
)
;
}
}
0
)
;
}
;
}
function
createChild
(
parent
tagName
attributes
=
{
}
)
{
let
elt
=
parent
.
ownerDocument
.
createElementNS
(
HTML_NS
tagName
)
;
for
(
let
attr
in
attributes
)
{
if
(
attributes
.
hasOwnProperty
(
attr
)
)
{
if
(
attr
=
=
=
"
textContent
"
)
{
elt
.
textContent
=
attributes
[
attr
]
;
}
else
if
(
attr
=
=
=
"
child
"
)
{
elt
.
appendChild
(
attributes
[
attr
]
)
;
}
else
{
elt
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
}
parent
.
appendChild
(
elt
)
;
return
elt
;
}
function
promiseWarn
(
error
)
{
console
.
error
(
error
)
;
return
promise
.
reject
(
error
)
;
}
function
translateNodeFrontToGrip
(
nodeFront
)
{
const
{
attributes
}
=
nodeFront
;
let
attributesMap
=
{
}
;
for
(
let
{
name
value
}
of
attributes
)
{
attributesMap
[
name
]
=
value
;
}
return
{
actor
:
nodeFront
.
actorID
preview
:
{
attributes
:
attributesMap
attributesLength
:
attributes
.
length
isConnected
:
true
nodeName
:
nodeFront
.
nodeName
.
toLowerCase
(
)
nodeType
:
nodeFront
.
nodeType
}
}
;
}
exports
.
advanceValidate
=
advanceValidate
;
exports
.
appendText
=
appendText
;
exports
.
blurOnMultipleProperties
=
blurOnMultipleProperties
;
exports
.
createChild
=
createChild
;
exports
.
promiseWarn
=
promiseWarn
;
exports
.
throttle
=
throttle
;
exports
.
translateNodeFrontToGrip
=
translateNodeFrontToGrip
;
