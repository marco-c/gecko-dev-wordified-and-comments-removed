"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCSSLexer
"
"
devtools
/
shared
/
css
/
lexer
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseDeclarations
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
advanceValidate
(
keyCode
value
insertionPoint
)
{
if
(
keyCode
!
=
=
KeyCodes
.
DOM_VK_SEMICOLON
)
{
return
false
;
}
value
=
value
.
slice
(
0
insertionPoint
)
+
"
;
"
+
value
.
slice
(
insertionPoint
)
;
const
lexer
=
getCSSLexer
(
value
)
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
token
.
endOffset
>
insertionPoint
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
;
"
)
{
return
true
;
}
break
;
}
}
return
false
;
}
function
appendText
(
parent
text
)
{
parent
.
appendChild
(
parent
.
ownerDocument
.
createTextNode
(
text
)
)
;
}
function
blurOnMultipleProperties
(
cssProperties
)
{
return
(
e
)
=
>
{
setTimeout
(
(
)
=
>
{
const
props
=
parseDeclarations
(
cssProperties
.
isKnown
e
.
target
.
value
)
;
if
(
props
.
length
>
1
)
{
e
.
target
.
blur
(
)
;
}
}
0
)
;
}
;
}
function
createChild
(
parent
tagName
attributes
=
{
}
)
{
const
elt
=
parent
.
ownerDocument
.
createElementNS
(
HTML_NS
tagName
)
;
for
(
const
attr
in
attributes
)
{
if
(
attributes
.
hasOwnProperty
(
attr
)
)
{
if
(
attr
=
=
=
"
textContent
"
)
{
elt
.
textContent
=
attributes
[
attr
]
;
}
else
if
(
attr
=
=
=
"
child
"
)
{
elt
.
appendChild
(
attributes
[
attr
]
)
;
}
else
{
elt
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
}
parent
.
appendChild
(
elt
)
;
return
elt
;
}
function
getLongString
(
longStringActorPromise
)
{
return
longStringActorPromise
.
then
(
longStringActor
=
>
{
return
longStringActor
.
string
(
)
.
then
(
string
=
>
{
longStringActor
.
release
(
)
.
catch
(
console
.
error
)
;
return
string
;
}
)
;
}
)
.
catch
(
console
.
error
)
;
}
function
getSelectorFromGrip
(
grip
)
{
const
{
attributes
nodeName
isAfterPseudoElement
isBeforePseudoElement
isMarkerPseudoElement
}
=
grip
.
preview
;
if
(
isAfterPseudoElement
)
{
return
"
:
:
after
"
;
}
else
if
(
isBeforePseudoElement
)
{
return
"
:
:
before
"
;
}
else
if
(
isMarkerPseudoElement
)
{
return
"
:
:
marker
"
;
}
let
selector
=
nodeName
;
if
(
attributes
.
id
)
{
selector
+
=
#
{
attributes
.
id
}
;
}
if
(
attributes
.
class
)
{
selector
+
=
attributes
.
class
.
trim
(
)
.
split
(
/
\
s
+
/
)
.
map
(
cls
=
>
.
{
cls
}
)
.
join
(
"
"
)
;
}
return
selector
;
}
function
promiseWarn
(
error
)
{
console
.
error
(
error
)
;
return
promise
.
reject
(
error
)
;
}
function
translateNodeFrontToGrip
(
nodeFront
)
{
const
{
attributes
}
=
nodeFront
;
const
attributesMap
=
{
}
;
for
(
const
{
name
value
}
of
attributes
)
{
attributesMap
[
name
]
=
value
;
}
return
{
actor
:
nodeFront
.
actorID
preview
:
{
attributes
:
attributesMap
attributesLength
:
attributes
.
length
isAfterPseudoElement
:
nodeFront
.
isAfterPseudoElement
isBeforePseudoElement
:
nodeFront
.
isBeforePseudoElement
isMarkerPseudoElement
:
nodeFront
.
isMarkerPseudoElement
isConnected
:
true
nodeName
:
nodeFront
.
nodeName
.
toLowerCase
(
)
nodeType
:
nodeFront
.
nodeType
}
}
;
}
exports
.
advanceValidate
=
advanceValidate
;
exports
.
appendText
=
appendText
;
exports
.
blurOnMultipleProperties
=
blurOnMultipleProperties
;
exports
.
createChild
=
createChild
;
exports
.
getLongString
=
getLongString
;
exports
.
getSelectorFromGrip
=
getSelectorFromGrip
;
exports
.
promiseWarn
=
promiseWarn
;
exports
.
translateNodeFrontToGrip
=
translateNodeFrontToGrip
;
