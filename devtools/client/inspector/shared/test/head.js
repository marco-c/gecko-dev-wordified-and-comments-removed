"
use
strict
"
;
var
Cu
=
Components
.
utils
;
var
{
gDevTools
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
{
}
)
;
var
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
var
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
var
{
CssRuleView
_ElementStyle
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
;
var
{
CssLogic
CssSelector
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
{
editableField
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
var
{
console
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
waitForExplicitFinish
(
)
;
const
TEST_URL_ROOT
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
inspector
/
shared
/
test
/
"
;
const
TEST_URL_ROOT_SSL
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
inspector
/
shared
/
test
/
"
;
const
ROOT_TEST_DIR
=
getRootDirectory
(
gTestPath
)
;
const
FRAME_SCRIPT_URL
=
ROOT_TEST_DIR
+
"
doc_frame_script
.
js
"
;
registerCleanupFunction
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
DevToolsUtils
.
testing
=
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
activeSidebar
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
function
addTab
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
def
=
promise
.
defer
(
)
;
window
.
focus
(
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
=
window
.
gBrowser
.
addTab
(
url
)
;
let
browser
=
tab
.
linkedBrowser
;
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
browser
.
addEventListener
(
"
load
"
function
onload
(
)
{
browser
.
removeEventListener
(
"
load
"
onload
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
def
.
resolve
(
tab
)
;
}
true
)
;
return
def
.
promise
;
}
function
getNode
(
nodeOrSelector
)
{
info
(
"
Getting
the
node
for
'
"
+
nodeOrSelector
+
"
'
"
)
;
return
typeof
nodeOrSelector
=
=
=
"
string
"
?
content
.
document
.
querySelector
(
nodeOrSelector
)
:
nodeOrSelector
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
selectNode
=
Task
.
async
(
function
*
(
data
inspector
reason
=
"
test
"
)
{
info
(
"
Selecting
the
node
for
'
"
+
data
+
"
'
"
)
;
let
nodeFront
=
data
;
if
(
!
data
.
_form
)
{
nodeFront
=
yield
getNodeFront
(
data
inspector
)
;
}
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
reason
)
;
yield
updated
;
}
)
;
function
clearCurrentNodeSelection
(
inspector
)
{
info
(
"
Clearing
the
current
selection
"
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
null
)
;
return
updated
;
}
var
openInspector
=
Task
.
async
(
function
*
(
)
{
info
(
"
Opening
the
inspector
"
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
inspector
toolbox
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
if
(
inspector
)
{
info
(
"
Toolbox
and
inspector
already
open
"
)
;
return
{
toolbox
:
toolbox
inspector
:
inspector
}
;
}
}
info
(
"
Opening
the
toolbox
"
)
;
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
yield
waitForToolboxFrameFocus
(
toolbox
)
;
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
info
(
"
Waiting
for
the
inspector
to
update
"
)
;
if
(
inspector
.
_updateProgress
)
{
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
return
{
toolbox
:
toolbox
inspector
:
inspector
}
;
}
)
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
let
def
=
promise
.
defer
(
)
;
let
win
=
toolbox
.
frame
.
contentWindow
;
waitForFocus
(
def
.
resolve
win
)
;
return
def
.
promise
;
}
var
openInspectorSideBar
=
Task
.
async
(
function
*
(
id
)
{
let
{
toolbox
inspector
}
=
yield
openInspector
(
)
;
info
(
"
Selecting
the
"
+
id
+
"
sidebar
"
)
;
inspector
.
sidebar
.
select
(
id
)
;
return
{
toolbox
:
toolbox
inspector
:
inspector
view
:
inspector
[
id
]
.
view
}
;
}
)
;
function
openComputedView
(
)
{
return
openInspectorSideBar
(
"
computedview
"
)
;
}
function
openRuleView
(
)
{
return
openInspectorSideBar
(
"
ruleview
"
)
;
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
let
count
=
0
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
wait
(
ms
)
{
let
def
=
promise
.
defer
(
)
;
content
.
setTimeout
(
def
.
resolve
ms
)
;
return
def
.
promise
;
}
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
def
=
promise
.
defer
(
)
;
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
def
.
resolve
(
msg
.
data
)
;
}
)
;
return
def
.
promise
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
function
*
getComputedStyleProperty
(
selector
pseudo
propName
)
{
return
yield
executeInContent
(
"
Test
:
GetComputedStylePropertyValue
"
{
selector
pseudo
name
:
propName
}
)
;
}
function
*
waitForComputedStyleProperty
(
selector
pseudo
name
expected
)
{
return
yield
executeInContent
(
"
Test
:
WaitForComputedStylePropertyValue
"
{
selector
pseudo
expected
name
}
)
;
}
var
focusEditableField
=
Task
.
async
(
function
*
(
ruleView
editable
xOffset
=
1
yOffset
=
1
options
=
{
}
)
{
let
onFocus
=
once
(
editable
.
parentNode
"
focus
"
true
)
;
info
(
"
Clicking
on
editable
field
to
turn
to
edit
mode
"
)
;
EventUtils
.
synthesizeMouse
(
editable
xOffset
yOffset
options
editable
.
ownerDocument
.
defaultView
)
;
yield
onFocus
;
info
(
"
Editable
field
gained
focus
returning
the
input
field
now
"
)
;
let
onEdit
=
inplaceEditor
(
editable
.
ownerDocument
.
activeElement
)
;
return
onEdit
;
}
)
;
function
isHoverTooltipTarget
(
tooltip
target
)
{
if
(
!
tooltip
.
_basedNode
|
|
!
tooltip
.
panel
)
{
return
promise
.
reject
(
new
Error
(
"
The
tooltip
passed
isn
'
t
set
to
toggle
on
hover
or
is
not
a
tooltip
"
)
)
;
}
return
tooltip
.
isValidHoverTarget
(
target
)
;
}
function
assertHoverTooltipOn
(
tooltip
element
)
{
return
isHoverTooltipTarget
(
tooltip
element
)
.
then
(
(
)
=
>
{
ok
(
true
"
A
tooltip
is
defined
on
hover
of
the
given
element
"
)
;
}
(
)
=
>
{
ok
(
false
"
No
tooltip
is
defined
on
hover
of
the
given
element
"
)
;
}
)
;
}
var
waitForTab
=
Task
.
async
(
function
*
(
)
{
info
(
"
Waiting
for
a
tab
to
open
"
)
;
yield
once
(
gBrowser
.
tabContainer
"
TabOpen
"
)
;
let
tab
=
gBrowser
.
selectedTab
;
let
browser
=
tab
.
linkedBrowser
;
yield
once
(
browser
"
load
"
true
)
;
info
(
"
The
tab
load
completed
"
)
;
return
tab
;
}
)
;
function
waitForClipboard
(
setup
expected
)
{
let
def
=
promise
.
defer
(
)
;
SimpleTest
.
waitForClipboard
(
expected
setup
def
.
resolve
def
.
reject
)
;
return
def
.
promise
;
}
function
waitForSuccess
(
validatorFn
name
=
"
untitled
"
)
{
let
def
=
promise
.
defer
(
)
;
function
wait
(
validator
)
{
if
(
validator
(
)
)
{
ok
(
true
"
Validator
function
"
+
name
+
"
returned
true
"
)
;
def
.
resolve
(
)
;
}
else
{
setTimeout
(
(
)
=
>
wait
(
validator
)
200
)
;
}
}
wait
(
validatorFn
)
;
return
def
.
promise
;
}
function
addStyle
(
doc
style
)
{
info
(
"
Adding
a
new
style
tag
to
the
document
with
style
content
:
"
+
style
.
substring
(
0
50
)
)
;
let
node
=
doc
.
createElement
(
"
style
"
)
;
node
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
node
.
textContent
=
style
;
doc
.
getElementsByTagName
(
"
head
"
)
[
0
]
.
appendChild
(
node
)
;
return
node
;
}
function
hasSideBarTab
(
inspector
id
)
{
return
!
!
inspector
.
sidebar
.
getWindowForTab
(
id
)
;
}
var
getFontFamilyDataURL
=
Task
.
async
(
function
*
(
font
nodeFront
)
{
let
fillStyle
=
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
=
=
=
"
light
"
)
?
"
black
"
:
"
white
"
;
let
{
data
}
=
yield
nodeFront
.
getFontFamilyDataURL
(
font
fillStyle
)
;
let
dataURL
=
yield
data
.
string
(
)
;
return
dataURL
;
}
)
;
function
synthesizeKeys
(
input
win
)
{
for
(
let
key
of
input
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
win
)
;
}
}
function
getRuleViewRule
(
view
selectorText
)
{
let
rule
;
for
(
let
r
of
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
"
)
)
{
let
selector
=
r
.
querySelector
(
"
.
ruleview
-
selectorcontainer
"
+
"
.
ruleview
-
selector
-
matched
"
)
;
if
(
selector
&
&
selector
.
textContent
=
=
=
selectorText
)
{
rule
=
r
;
break
;
}
}
return
rule
;
}
function
getRuleViewProperty
(
view
selectorText
propertyName
)
{
let
prop
;
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
if
(
rule
)
{
for
(
let
p
of
rule
.
querySelectorAll
(
"
.
ruleview
-
property
"
)
)
{
let
nameSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyname
"
)
;
let
valueSpan
=
p
.
querySelector
(
"
.
ruleview
-
propertyvalue
"
)
;
if
(
nameSpan
.
textContent
=
=
=
propertyName
)
{
prop
=
{
nameSpan
:
nameSpan
valueSpan
:
valueSpan
}
;
break
;
}
}
}
return
prop
;
}
function
getRuleViewPropertyValue
(
view
selectorText
propertyName
)
{
return
getRuleViewProperty
(
view
selectorText
propertyName
)
.
valueSpan
.
textContent
;
}
function
getRuleViewSelector
(
view
selectorText
)
{
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
return
rule
.
querySelector
(
"
.
ruleview
-
selector
.
ruleview
-
selector
-
matched
"
)
;
}
function
getRuleViewSelectorHighlighterIcon
(
view
selectorText
)
{
let
rule
=
getRuleViewRule
(
view
selectorText
)
;
return
rule
.
querySelector
(
"
.
ruleview
-
selectorhighlighter
"
)
;
}
var
simulateColorPickerChange
=
Task
.
async
(
function
*
(
ruleView
colorPicker
newRgba
expectedChange
)
{
let
onRuleViewChanged
=
ruleView
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
let
spectrum
=
yield
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
info
(
"
Waiting
for
rule
-
view
to
update
"
)
;
yield
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
yield
waitForSuccess
(
(
)
=
>
{
let
{
element
name
value
}
=
expectedChange
;
return
content
.
getComputedStyle
(
element
)
[
name
]
=
=
=
value
;
}
"
Color
picker
change
applied
on
the
page
"
)
;
}
}
)
;
function
getRuleViewLinkByIndex
(
view
index
)
{
let
links
=
view
.
styleDocument
.
querySelectorAll
(
"
.
ruleview
-
rule
-
source
"
)
;
return
links
[
index
]
;
}
function
getRuleViewLinkTextByIndex
(
view
index
)
{
let
link
=
getRuleViewLinkByIndex
(
view
index
)
;
return
link
.
querySelector
(
"
.
ruleview
-
rule
-
source
-
label
"
)
.
value
;
}
function
getRuleViewRuleEditor
(
view
childrenIndex
nodeIndex
)
{
return
nodeIndex
!
=
=
undefined
?
view
.
element
.
children
[
childrenIndex
]
.
childNodes
[
nodeIndex
]
.
_ruleEditor
:
view
.
element
.
children
[
childrenIndex
]
.
_ruleEditor
;
}
var
focusNewRuleViewProperty
=
Task
.
async
(
function
*
(
ruleEditor
)
{
info
(
"
Clicking
on
a
close
ruleEditor
brace
to
start
editing
a
new
property
"
)
;
ruleEditor
.
closeBrace
.
scrollIntoView
(
)
;
let
editor
=
yield
focusEditableField
(
ruleEditor
.
ruleView
ruleEditor
.
closeBrace
)
;
is
(
inplaceEditor
(
ruleEditor
.
newPropSpan
)
editor
"
Focused
editor
is
the
new
property
editor
.
"
)
;
return
editor
;
}
)
;
var
createNewRuleViewProperty
=
Task
.
async
(
function
*
(
ruleEditor
inputValue
)
{
info
(
"
Creating
a
new
property
editor
"
)
;
let
editor
=
yield
focusNewRuleViewProperty
(
ruleEditor
)
;
info
(
"
Entering
the
value
"
+
inputValue
)
;
editor
.
input
.
value
=
inputValue
;
info
(
"
Submitting
the
new
value
and
waiting
for
value
field
focus
"
)
;
let
onFocus
=
once
(
ruleEditor
.
element
"
focus
"
true
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
ruleEditor
.
element
.
ownerDocument
.
defaultView
)
;
yield
onFocus
;
}
)
;
var
setSearchFilter
=
Task
.
async
(
function
*
(
view
searchValue
)
{
info
(
"
Setting
filter
text
to
\
"
"
+
searchValue
+
"
\
"
"
)
;
let
win
=
view
.
styleWindow
;
let
searchField
=
view
.
searchField
;
searchField
.
focus
(
)
;
synthesizeKeys
(
searchValue
win
)
;
yield
view
.
inspector
.
once
(
"
ruleview
-
filtered
"
)
;
}
)
;
function
getComputedViewProperty
(
view
name
)
{
let
prop
;
for
(
let
property
of
view
.
styleDocument
.
querySelectorAll
(
"
.
property
-
view
"
)
)
{
let
nameSpan
=
property
.
querySelector
(
"
.
property
-
name
"
)
;
let
valueSpan
=
property
.
querySelector
(
"
.
property
-
value
"
)
;
if
(
nameSpan
.
textContent
=
=
=
name
)
{
prop
=
{
nameSpan
:
nameSpan
valueSpan
:
valueSpan
}
;
break
;
}
}
return
prop
;
}
function
getComputedViewPropertyValue
(
view
name
propertyName
)
{
return
getComputedViewProperty
(
view
name
propertyName
)
.
valueSpan
.
textContent
;
}
function
waitForStyleEditor
(
toolbox
href
)
{
let
def
=
promise
.
defer
(
)
;
info
(
"
Waiting
for
the
toolbox
to
switch
to
the
styleeditor
"
)
;
toolbox
.
once
(
"
styleeditor
-
selected
"
)
.
then
(
(
)
=
>
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
ok
(
panel
&
&
panel
.
UI
"
Styleeditor
panel
switched
to
front
"
)
;
let
gotEditor
=
(
event
editor
)
=
>
{
let
currentHref
=
editor
.
styleSheet
.
href
;
if
(
!
href
|
|
(
href
&
&
currentHref
.
endsWith
(
href
)
)
)
{
info
(
"
Stylesheet
editor
selected
"
)
;
panel
.
UI
.
off
(
"
editor
-
selected
"
gotEditor
)
;
editor
.
getSourceEditor
(
)
.
then
(
sourceEditor
=
>
{
info
(
"
Stylesheet
editor
fully
loaded
"
)
;
def
.
resolve
(
sourceEditor
)
;
}
)
;
return
true
;
}
info
(
"
The
editor
was
incorrect
.
Waiting
for
editor
-
selected
event
.
"
)
;
return
false
;
}
;
if
(
!
gotEditor
(
"
styleeditor
-
selected
"
panel
.
UI
.
selectedEditor
)
)
{
panel
.
UI
.
on
(
"
editor
-
selected
"
gotEditor
)
;
}
}
)
;
return
def
.
promise
;
}
function
reloadPage
(
inspector
)
{
let
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
content
.
location
.
reload
(
)
;
return
onNewRoot
.
then
(
(
)
=
>
{
inspector
.
markup
.
_waitForChildren
(
)
;
}
)
;
}
