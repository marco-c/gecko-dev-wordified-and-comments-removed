"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
head
.
js
"
this
)
;
var
{
CssRuleView
}
=
require
(
"
devtools
/
client
/
inspector
/
rules
/
rules
"
)
;
var
{
getInplaceEditorForSpan
:
inplaceEditor
}
=
require
(
"
devtools
/
client
/
shared
/
inplace
-
editor
"
)
;
const
{
getColor
:
getThemeColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
TEST_URL_ROOT
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
inspector
/
shared
/
test
/
"
;
const
TEST_URL_ROOT_SSL
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
inspector
/
shared
/
test
/
"
;
const
ROOT_TEST_DIR
=
getRootDirectory
(
gTestPath
)
;
const
FRAME_SCRIPT_URL
=
ROOT_TEST_DIR
+
"
doc_frame_script
.
js
"
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
defaultColorUnit
"
)
;
}
)
;
var
_addTab
=
addTab
;
addTab
=
function
(
url
)
{
return
_addTab
(
url
)
.
then
(
tab
=
>
{
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
const
browser
=
tab
.
linkedBrowser
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
return
tab
;
}
)
;
}
;
function
waitForSuccess
(
validatorFn
name
=
"
untitled
"
)
{
return
new
Promise
(
resolve
=
>
{
function
wait
(
validator
)
{
if
(
validator
(
)
)
{
ok
(
true
"
Validator
function
"
+
name
+
"
returned
true
"
)
;
resolve
(
)
;
}
else
{
setTimeout
(
(
)
=
>
wait
(
validator
)
200
)
;
}
}
wait
(
validatorFn
)
;
}
)
;
}
var
getFontFamilyDataURL
=
async
function
(
font
nodeFront
)
{
const
fillStyle
=
getThemeColor
(
"
body
-
color
"
)
;
const
{
data
}
=
await
nodeFront
.
getFontFamilyDataURL
(
font
fillStyle
)
;
const
dataURL
=
await
data
.
string
(
)
;
return
dataURL
;
}
;
var
simulateColorPickerChange
=
async
function
(
ruleView
colorPicker
newRgba
expectedChange
)
{
const
onRuleViewChanged
=
ruleView
.
once
(
"
ruleview
-
changed
"
)
;
info
(
"
Getting
the
spectrum
colorpicker
object
"
)
;
const
spectrum
=
await
colorPicker
.
spectrum
;
info
(
"
Setting
the
new
color
"
)
;
spectrum
.
rgb
=
newRgba
;
info
(
"
Applying
the
change
"
)
;
spectrum
.
updateUI
(
)
;
spectrum
.
onChange
(
)
;
info
(
"
Waiting
for
rule
-
view
to
update
"
)
;
await
onRuleViewChanged
;
if
(
expectedChange
)
{
info
(
"
Waiting
for
the
style
to
be
applied
on
the
page
"
)
;
await
waitForSuccess
(
(
)
=
>
{
const
{
element
name
value
}
=
expectedChange
;
return
content
.
getComputedStyle
(
element
)
[
name
]
=
=
=
value
;
}
"
Color
picker
change
applied
on
the
page
"
)
;
}
}
;
function
getComputedViewProperty
(
view
name
)
{
let
prop
;
for
(
const
property
of
view
.
styleDocument
.
querySelectorAll
(
"
.
computed
-
property
-
view
"
)
)
{
const
nameSpan
=
property
.
querySelector
(
"
.
computed
-
property
-
name
"
)
;
const
valueSpan
=
property
.
querySelector
(
"
.
computed
-
property
-
value
"
)
;
if
(
nameSpan
.
firstChild
.
textContent
=
=
=
name
)
{
prop
=
{
nameSpan
valueSpan
}
;
break
;
}
}
return
prop
;
}
function
getComputedViewPropertyValue
(
view
name
propertyName
)
{
return
getComputedViewProperty
(
view
name
propertyName
)
.
valueSpan
.
textContent
;
}
