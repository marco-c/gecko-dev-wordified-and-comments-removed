"
use
strict
"
;
class
WalkerEventListener
{
constructor
(
inspector
listenerMap
)
{
this
.
_inspector
=
inspector
;
this
.
_listenerMap
=
listenerMap
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_init
(
)
;
}
destroy
(
)
{
this
.
_inspector
.
commands
.
targetCommand
.
unwatchTargets
(
{
types
:
[
this
.
_inspector
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
const
targets
=
this
.
_inspector
.
commands
.
targetCommand
.
getAllTargets
(
[
this
.
_inspector
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
)
;
for
(
const
targetFront
of
targets
)
{
this
.
_onTargetDestroyed
(
{
targetFront
}
)
;
}
this
.
_inspector
=
null
;
this
.
_listenerMap
=
null
;
}
_init
(
)
{
this
.
_inspector
.
commands
.
targetCommand
.
watchTargets
(
{
types
:
[
this
.
_inspector
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
}
async
_onTargetAvailable
(
{
targetFront
}
)
{
const
inspectorFront
=
await
targetFront
.
getFront
(
"
inspector
"
)
;
if
(
inspectorFront
.
isDestroyed
(
)
|
|
!
this
.
_listenerMap
)
{
return
;
}
const
{
walker
}
=
inspectorFront
;
for
(
const
[
name
listener
]
of
Object
.
entries
(
this
.
_listenerMap
)
)
{
walker
.
on
(
name
listener
)
;
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
const
inspectorFront
=
targetFront
.
getCachedFront
(
"
inspector
"
)
;
if
(
inspectorFront
)
{
const
{
walker
}
=
inspectorFront
;
for
(
const
[
name
listener
]
of
Object
.
entries
(
this
.
_listenerMap
)
)
{
walker
.
off
(
name
listener
)
;
}
}
}
}
module
.
exports
=
WalkerEventListener
;
