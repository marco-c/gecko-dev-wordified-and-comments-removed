"
use
strict
"
;
const
{
PureComponent
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
div
button
p
span
img
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
PerfSettings
=
createFactory
(
require
(
"
devtools
/
client
/
performance
-
new
/
components
/
PerfSettings
.
js
"
)
)
;
const
{
openLink
}
=
require
(
"
devtools
/
client
/
shared
/
link
"
)
;
const
NOT_YET_KNOWN
=
"
not
-
yet
-
known
"
;
const
AVAILABLE_TO_RECORD
=
"
available
-
to
-
record
"
;
const
REQUEST_TO_START_RECORDING
=
"
request
-
to
-
start
-
recording
"
;
const
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
=
"
request
-
to
-
get
-
profile
-
and
-
stop
-
profiler
"
;
const
REQUEST_TO_STOP_PROFILER
=
"
request
-
to
-
stop
-
profiler
"
;
const
RECORDING
=
"
recording
"
;
const
OTHER_IS_RECORDING
=
"
other
-
is
-
recording
"
;
const
LOCKED_BY_PRIVATE_BROWSING
=
"
locked
-
by
-
private
-
browsing
"
;
class
Perf
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
toolbox
:
PropTypes
.
object
.
isRequired
perfFront
:
PropTypes
.
object
.
isRequired
receiveProfile
:
PropTypes
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
recordingState
:
NOT_YET_KNOWN
recordingUnexpectedlyStopped
:
false
isSupportedPlatform
:
null
}
;
this
.
startRecording
=
this
.
startRecording
.
bind
(
this
)
;
this
.
getProfileAndStopProfiler
=
this
.
getProfileAndStopProfiler
.
bind
(
this
)
;
this
.
stopProfilerAndDiscardProfile
=
this
.
stopProfilerAndDiscardProfile
.
bind
(
this
)
;
this
.
handleProfilerStarting
=
this
.
handleProfilerStarting
.
bind
(
this
)
;
this
.
handleProfilerStopping
=
this
.
handleProfilerStopping
.
bind
(
this
)
;
this
.
handlePrivateBrowsingStarting
=
this
.
handlePrivateBrowsingStarting
.
bind
(
this
)
;
this
.
handlePrivateBrowsingEnding
=
this
.
handlePrivateBrowsingEnding
.
bind
(
this
)
;
this
.
settingsComponentCreated
=
this
.
settingsComponentCreated
.
bind
(
this
)
;
this
.
handleLinkClick
=
this
.
handleLinkClick
.
bind
(
this
)
;
}
componentDidMount
(
)
{
const
{
perfFront
}
=
this
.
props
;
Promise
.
all
(
[
perfFront
.
isActive
(
)
perfFront
.
isSupportedPlatform
(
)
perfFront
.
isLockedForPrivateBrowsing
(
)
]
)
.
then
(
(
results
)
=
>
{
const
[
isActive
isSupportedPlatform
isLockedForPrivateBrowsing
]
=
results
;
let
recordingState
=
this
.
state
.
recordingState
;
if
(
recordingState
=
=
=
NOT_YET_KNOWN
&
&
isSupportedPlatform
)
{
if
(
isLockedForPrivateBrowsing
)
{
recordingState
=
LOCKED_BY_PRIVATE_BROWSING
;
}
else
{
recordingState
=
isActive
?
OTHER_IS_RECORDING
:
AVAILABLE_TO_RECORD
;
}
}
this
.
setState
(
{
isSupportedPlatform
recordingState
}
)
;
}
)
;
this
.
props
.
perfFront
.
on
(
"
profiler
-
started
"
this
.
handleProfilerStarting
)
;
this
.
props
.
perfFront
.
on
(
"
profiler
-
stopped
"
this
.
handleProfilerStopping
)
;
this
.
props
.
perfFront
.
on
(
"
profile
-
locked
-
by
-
private
-
browsing
"
this
.
handlePrivateBrowsingStarting
)
;
this
.
props
.
perfFront
.
on
(
"
profile
-
unlocked
-
from
-
private
-
browsing
"
this
.
handlePrivateBrowsingEnding
)
;
}
componentWillUnmount
(
)
{
switch
(
this
.
state
.
recordingState
)
{
case
NOT_YET_KNOWN
:
case
AVAILABLE_TO_RECORD
:
case
REQUEST_TO_STOP_PROFILER
:
case
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
case
LOCKED_BY_PRIVATE_BROWSING
:
case
OTHER_IS_RECORDING
:
break
;
case
RECORDING
:
case
REQUEST_TO_START_RECORDING
:
this
.
props
.
perfFront
.
stopProfilerAndDiscardProfile
(
)
;
break
;
default
:
throw
new
Error
(
"
Unhandled
recording
state
.
"
)
;
}
}
settingsComponentCreated
(
settings
)
{
this
.
settings
=
settings
;
}
getRecordingStateForTesting
(
)
{
return
this
.
state
.
recordingState
;
}
handleProfilerStarting
(
)
{
switch
(
this
.
state
.
recordingState
)
{
case
NOT_YET_KNOWN
:
case
AVAILABLE_TO_RECORD
:
case
REQUEST_TO_STOP_PROFILER
:
case
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
this
.
setState
(
{
recordingState
:
OTHER_IS_RECORDING
recordingUnexpectedlyStopped
:
false
}
)
;
break
;
case
REQUEST_TO_START_RECORDING
:
this
.
setState
(
{
recordingState
:
RECORDING
recordingUnexpectedlyStopped
:
false
}
)
;
break
;
case
LOCKED_BY_PRIVATE_BROWSING
:
case
OTHER_IS_RECORDING
:
case
RECORDING
:
throw
new
Error
(
"
The
profiler
started
recording
when
it
shouldn
'
t
have
"
+
been
able
to
.
Current
state
:
"
{
this
.
state
.
recordingState
}
"
)
;
default
:
throw
new
Error
(
"
Unhandled
recording
state
"
)
;
}
}
handleProfilerStopping
(
)
{
switch
(
this
.
state
.
recordingState
)
{
case
NOT_YET_KNOWN
:
case
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
case
REQUEST_TO_STOP_PROFILER
:
case
OTHER_IS_RECORDING
:
this
.
setState
(
{
recordingState
:
AVAILABLE_TO_RECORD
recordingUnexpectedlyStopped
:
false
}
)
;
break
;
case
REQUEST_TO_START_RECORDING
:
case
LOCKED_BY_PRIVATE_BROWSING
:
break
;
case
RECORDING
:
this
.
setState
(
{
recordingState
:
AVAILABLE_TO_RECORD
recordingUnexpectedlyStopped
:
true
}
)
;
break
;
case
AVAILABLE_TO_RECORD
:
throw
new
Error
(
"
The
profiler
stopped
recording
when
it
shouldn
'
t
have
been
able
to
.
"
)
;
default
:
throw
new
Error
(
"
Unhandled
recording
state
"
)
;
}
}
handlePrivateBrowsingStarting
(
)
{
switch
(
this
.
state
.
recordingState
)
{
case
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
case
REQUEST_TO_STOP_PROFILER
:
case
AVAILABLE_TO_RECORD
:
case
OTHER_IS_RECORDING
:
case
NOT_YET_KNOWN
:
this
.
setState
(
{
recordingState
:
LOCKED_BY_PRIVATE_BROWSING
recordingUnexpectedlyStopped
:
false
}
)
;
break
;
case
REQUEST_TO_START_RECORDING
:
case
RECORDING
:
this
.
setState
(
{
recordingState
:
LOCKED_BY_PRIVATE_BROWSING
recordingUnexpectedlyStopped
:
true
}
)
;
break
;
case
LOCKED_BY_PRIVATE_BROWSING
:
break
;
default
:
throw
new
Error
(
"
Unhandled
recording
state
"
)
;
}
}
handlePrivateBrowsingEnding
(
)
{
this
.
setState
(
{
recordingState
:
AVAILABLE_TO_RECORD
recordingUnexpectedlyStopped
:
false
}
)
;
}
startRecording
(
)
{
const
settings
=
this
.
settings
;
if
(
!
settings
)
{
console
.
error
(
"
Expected
the
PerfSettings
panel
to
be
rendered
and
available
.
"
)
;
return
;
}
this
.
setState
(
{
recordingState
:
REQUEST_TO_START_RECORDING
recordingUnexpectedlyStopped
:
false
}
)
;
this
.
props
.
perfFront
.
startProfiler
(
settings
.
getRecordingSettings
(
)
)
;
}
async
getProfileAndStopProfiler
(
)
{
this
.
setState
(
{
recordingState
:
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
}
)
;
const
profile
=
await
this
.
props
.
perfFront
.
getProfileAndStopProfiler
(
)
;
this
.
setState
(
{
recordingState
:
AVAILABLE_TO_RECORD
}
)
;
console
.
log
(
"
getProfileAndStopProfiler
"
)
;
this
.
props
.
receiveProfile
(
profile
)
;
}
stopProfilerAndDiscardProfile
(
)
{
this
.
setState
(
{
recordingState
:
REQUEST_TO_STOP_PROFILER
}
)
;
this
.
props
.
perfFront
.
stopProfilerAndDiscardProfile
(
)
;
}
renderButton
(
)
{
const
{
recordingState
isSupportedPlatform
}
=
this
.
state
;
if
(
!
isSupportedPlatform
)
{
return
renderButton
(
{
label
:
"
Start
recording
"
disabled
:
true
additionalMessage
:
"
Your
platform
is
not
supported
.
The
Gecko
Profiler
only
"
+
"
supports
Tier
-
1
platforms
.
"
}
)
;
}
switch
(
recordingState
)
{
case
NOT_YET_KNOWN
:
return
null
;
case
AVAILABLE_TO_RECORD
:
return
renderButton
(
{
onClick
:
this
.
startRecording
label
:
span
(
null
img
(
{
className
:
"
perf
-
button
-
image
"
src
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
tool
-
profiler
.
svg
"
}
)
"
Start
recording
"
)
additionalMessage
:
this
.
state
.
recordingUnexpectedlyStopped
?
div
(
null
"
The
recording
was
stopped
by
another
tool
.
"
)
:
null
}
)
;
case
REQUEST_TO_STOP_PROFILER
:
return
renderButton
(
{
label
:
"
Stopping
the
recording
"
disabled
:
true
}
)
;
case
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
return
renderButton
(
{
label
:
"
Stopping
the
recording
and
capturing
the
profile
"
disabled
:
true
}
)
;
case
REQUEST_TO_START_RECORDING
:
case
RECORDING
:
return
renderButton
(
{
label
:
"
Stop
and
grab
the
recording
"
onClick
:
this
.
getProfileAndStopProfiler
disabled
:
this
.
state
.
recordingState
=
=
=
REQUEST_TO_START_RECORDING
}
)
;
case
OTHER_IS_RECORDING
:
return
renderButton
(
{
label
:
"
Stop
and
discard
the
other
recording
"
onClick
:
this
.
stopProfilerAndDiscardProfile
additionalMessage
:
"
Another
tool
is
currently
recording
.
"
}
)
;
case
LOCKED_BY_PRIVATE_BROWSING
:
return
renderButton
(
{
label
:
"
Start
recording
"
disabled
:
true
additionalMessage
:
The
profiler
is
disabled
when
Private
Browsing
is
enabled
.
Close
all
Private
Windows
to
re
-
enable
the
profiler
}
)
;
default
:
throw
new
Error
(
"
Unhandled
recording
state
"
)
;
}
}
handleLinkClick
(
event
)
{
openLink
(
event
.
target
.
value
this
.
props
.
toolbox
)
;
}
render
(
)
{
const
{
isSupportedPlatform
}
=
this
.
state
;
if
(
isSupportedPlatform
=
=
=
null
)
{
return
null
;
}
return
div
(
{
className
:
"
perf
"
}
this
.
renderButton
(
)
PerfSettings
(
{
ref
:
this
.
settingsComponentCreated
}
)
div
(
{
className
:
"
perf
-
description
"
}
p
(
null
"
This
new
recording
panel
is
a
bit
different
from
the
existing
"
+
"
performance
panel
.
It
records
the
entire
browser
and
then
opens
up
"
+
"
and
shares
the
profile
with
"
button
(
{
className
:
"
perf
-
external
-
link
"
value
:
"
https
:
/
/
perf
-
html
.
io
"
onClick
:
this
.
handleLinkClick
}
"
perf
-
html
.
io
"
)
"
a
Mozilla
performance
analysis
tool
.
"
)
p
(
null
"
This
is
still
a
prototype
.
Join
along
or
file
bugs
at
:
"
button
(
{
className
:
"
perf
-
external
-
link
"
value
:
"
https
:
/
/
github
.
com
/
devtools
-
html
/
perf
.
html
"
onClick
:
this
.
handleLinkClick
}
"
github
.
com
/
devtools
-
html
/
perf
.
html
"
)
"
.
"
)
)
)
;
}
}
module
.
exports
=
Perf
;
function
renderButton
(
props
)
{
const
{
disabled
label
onClick
additionalMessage
}
=
props
;
const
nbsp
=
"
\
u00A0
"
;
return
div
(
{
className
:
"
perf
-
button
-
container
"
}
div
(
{
className
:
"
perf
-
additional
-
message
"
}
additionalMessage
|
|
nbsp
)
div
(
null
button
(
{
className
:
"
devtools
-
button
perf
-
button
"
"
data
-
standalone
"
:
true
disabled
onClick
}
label
)
)
)
;
}
