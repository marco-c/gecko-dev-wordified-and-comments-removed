"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
profiler_get_symbols
.
js
"
)
;
const
{
WasmMemBuffer
get_compact_symbol_table
}
=
wasm_bindgen
;
function
readFileInto
(
file
dataBuf
)
{
const
dataBufLen
=
dataBuf
.
byteLength
;
const
chunkSize
=
4
*
1024
*
1024
;
let
pos
=
0
;
while
(
pos
<
dataBufLen
)
{
const
chunkData
=
file
.
read
(
{
bytes
:
chunkSize
}
)
;
const
chunkBytes
=
chunkData
.
byteLength
;
if
(
chunkBytes
=
=
=
0
)
{
break
;
}
dataBuf
.
set
(
chunkData
pos
)
;
pos
+
=
chunkBytes
;
}
}
function
createPlainErrorObject
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
)
)
{
if
(
e
instanceof
Error
)
{
const
{
name
message
fileName
lineNumber
}
=
e
;
return
{
name
message
fileName
lineNumber
}
;
}
if
(
e
.
error_type
)
{
return
{
name
:
e
.
error_type
message
:
e
.
error_msg
}
;
}
}
return
{
name
:
e
instanceof
OS
.
File
.
Error
?
"
OSFileError
"
:
"
Error
"
message
:
e
.
toString
(
)
fileName
:
e
.
fileName
lineNumber
:
e
.
lineNumber
}
;
}
class
PathHelper
{
constructor
(
libInfoMap
objdirs
)
{
this
.
_libInfoMap
=
libInfoMap
;
this
.
_objdirs
=
objdirs
;
}
getCandidatePaths
(
debugName
breakpadId
)
{
const
key
=
{
debugName
}
:
{
breakpadId
}
;
const
lib
=
this
.
_libInfoMap
.
get
(
key
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
.
)
;
}
const
{
name
path
debugPath
}
=
lib
;
const
candidatePaths
=
[
]
;
for
(
const
objdirPath
of
this
.
_objdirs
)
{
candidatePaths
.
push
(
{
path
:
OS
.
Path
.
join
(
objdirPath
"
dist
"
"
bin
"
name
)
debugPath
:
OS
.
Path
.
join
(
objdirPath
"
dist
"
"
bin
"
name
)
}
)
;
candidatePaths
.
push
(
{
path
:
OS
.
Path
.
join
(
objdirPath
name
)
debugPath
:
OS
.
Path
.
join
(
objdirPath
name
)
}
)
;
}
candidatePaths
.
push
(
{
path
debugPath
}
)
;
return
candidatePaths
;
}
}
function
getCompactSymbolTableFromPath
(
binaryPath
debugPath
breakpadId
)
{
const
binaryFile
=
OS
.
File
.
open
(
binaryPath
{
read
:
true
}
)
;
const
binaryData
=
new
WasmMemBuffer
(
binaryFile
.
stat
(
)
.
size
array
=
>
{
readFileInto
(
binaryFile
array
)
;
}
)
;
binaryFile
.
close
(
)
;
let
debugData
=
binaryData
;
if
(
debugPath
&
&
debugPath
!
=
=
binaryPath
)
{
const
debugFile
=
OS
.
File
.
open
(
debugPath
{
read
:
true
}
)
;
debugData
=
new
WasmMemBuffer
(
debugFile
.
stat
(
)
.
size
array
=
>
{
readFileInto
(
debugFile
array
)
;
}
)
;
debugFile
.
close
(
)
;
}
try
{
const
output
=
get_compact_symbol_table
(
binaryData
debugData
breakpadId
)
;
const
result
=
[
output
.
take_addr
(
)
output
.
take_index
(
)
output
.
take_buffer
(
)
]
;
output
.
free
(
)
;
return
result
;
}
finally
{
binaryData
.
free
(
)
;
if
(
debugData
!
=
binaryData
)
{
debugData
.
free
(
)
;
}
}
}
function
getSymbolTableInWorker
(
debugName
breakpadId
libInfoMap
objdirs
)
{
const
helper
=
new
PathHelper
(
libInfoMap
objdirs
)
;
const
candidatePaths
=
helper
.
getCandidatePaths
(
debugName
breakpadId
)
;
const
errors
=
[
]
;
for
(
const
{
path
debugPath
}
of
candidatePaths
)
{
try
{
return
getCompactSymbolTableFromPath
(
path
debugPath
breakpadId
)
;
}
catch
(
e
)
{
errors
.
push
(
e
)
;
}
}
throw
new
Error
(
Could
not
obtain
symbols
for
the
library
{
debugName
}
{
breakpadId
}
+
because
there
was
no
matching
file
at
any
of
the
candidate
paths
:
{
JSON
.
stringify
(
candidatePaths
)
}
.
Errors
:
{
errors
.
map
(
e
=
>
e
.
message
)
.
join
(
"
"
)
}
)
;
}
onmessage
=
async
e
=
>
{
try
{
const
{
debugName
breakpadId
libInfoMap
objdirs
module
}
=
e
.
data
;
if
(
!
(
module
instanceof
WebAssembly
.
Module
)
)
{
throw
new
Error
(
"
invalid
WebAssembly
module
"
)
;
}
await
wasm_bindgen
(
module
)
;
const
result
=
getSymbolTableInWorker
(
debugName
breakpadId
libInfoMap
objdirs
)
;
postMessage
(
{
result
}
result
.
map
(
r
=
>
r
.
buffer
)
)
;
}
catch
(
error
)
{
postMessage
(
{
error
:
createPlainErrorObject
(
error
)
}
)
;
}
close
(
)
;
}
;
