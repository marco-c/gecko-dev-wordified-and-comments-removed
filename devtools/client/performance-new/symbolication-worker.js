"
use
strict
"
;
importScripts
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
profiler_get_symbols
.
js
"
)
;
const
{
getCompactSymbolTable
queryAPI
}
=
wasm_bindgen
;
function
createPlainErrorObject
(
e
)
{
const
{
name
message
fileName
lineNumber
}
=
e
;
return
{
name
message
fileName
lineNumber
}
;
}
class
FileAndPathHelper
{
constructor
(
libInfoMap
objdirs
)
{
this
.
_libInfoMap
=
libInfoMap
;
this
.
_objdirs
=
objdirs
;
}
getCandidatePathsForDebugFile
(
libraryInfo
)
{
const
{
debugName
breakpadId
}
=
libraryInfo
;
const
key
=
{
debugName
}
:
{
breakpadId
}
;
const
lib
=
this
.
_libInfoMap
.
get
(
key
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
.
)
;
}
const
{
name
path
debugPath
arch
}
=
lib
;
const
candidatePaths
=
[
]
;
for
(
const
objdirPath
of
this
.
_objdirs
)
{
try
{
candidatePaths
.
push
(
PathUtils
.
join
(
objdirPath
"
dist
"
"
bin
"
name
)
)
;
candidatePaths
.
push
(
PathUtils
.
join
(
objdirPath
name
)
)
;
}
catch
(
e
)
{
}
}
if
(
debugPath
!
=
=
path
)
{
candidatePaths
.
push
(
debugPath
)
;
}
candidatePaths
.
push
(
path
)
;
if
(
arch
&
&
(
path
.
startsWith
(
"
/
usr
/
"
)
|
|
path
.
startsWith
(
"
/
System
/
"
)
)
)
{
candidatePaths
.
push
(
dyldcache
:
/
System
/
Volumes
/
Preboot
/
Cryptexes
/
OS
/
System
/
Library
/
dyld
/
dyld_shared_cache_
{
arch
}
:
{
path
}
)
;
candidatePaths
.
push
(
dyldcache
:
/
System
/
Library
/
dyld
/
dyld_shared_cache_
{
arch
}
:
{
path
}
)
;
}
return
candidatePaths
;
}
getCandidatePathsForBinary
(
libraryInfo
)
{
const
{
debugName
breakpadId
}
=
libraryInfo
;
const
key
=
{
debugName
}
:
{
breakpadId
}
;
const
lib
=
this
.
_libInfoMap
.
get
(
key
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
.
)
;
}
const
{
name
path
arch
}
=
lib
;
const
candidatePaths
=
[
]
;
candidatePaths
.
push
(
path
)
;
for
(
const
objdirPath
of
this
.
_objdirs
)
{
try
{
candidatePaths
.
push
(
PathUtils
.
join
(
objdirPath
"
dist
"
"
bin
"
name
)
)
;
candidatePaths
.
push
(
PathUtils
.
join
(
objdirPath
name
)
)
;
}
catch
(
e
)
{
}
}
if
(
arch
&
&
(
path
.
startsWith
(
"
/
usr
/
"
)
|
|
path
.
startsWith
(
"
/
System
/
"
)
)
)
{
candidatePaths
.
push
(
dyldcache
:
/
System
/
Volumes
/
Preboot
/
Cryptexes
/
OS
/
System
/
Library
/
dyld
/
dyld_shared_cache_
{
arch
}
:
{
path
}
)
;
candidatePaths
.
push
(
dyldcache
:
/
System
/
Library
/
dyld
/
dyld_shared_cache_
{
arch
}
:
{
path
}
)
;
}
return
candidatePaths
;
}
async
readFile
(
path
)
{
const
info
=
await
IOUtils
.
stat
(
path
)
;
if
(
info
.
type
=
=
=
"
directory
"
)
{
throw
new
Error
(
Path
"
{
path
}
"
is
a
directory
.
)
;
}
return
IOUtils
.
openFileForSyncReading
(
path
)
;
}
}
onmessage
=
async
e
=
>
{
try
{
const
{
request
libInfoMap
objdirs
module
}
=
e
.
data
;
if
(
!
(
module
instanceof
WebAssembly
.
Module
)
)
{
throw
new
Error
(
"
invalid
WebAssembly
module
"
)
;
}
await
wasm_bindgen
(
module
)
;
const
helper
=
new
FileAndPathHelper
(
libInfoMap
objdirs
)
;
switch
(
request
.
type
)
{
case
"
GET_SYMBOL_TABLE
"
:
{
const
{
debugName
breakpadId
}
=
request
;
const
result
=
await
getCompactSymbolTable
(
debugName
breakpadId
helper
)
;
postMessage
(
{
result
}
result
.
map
(
r
=
>
r
.
buffer
)
)
;
break
;
}
case
"
QUERY_SYMBOLICATION_API
"
:
{
const
{
path
requestJson
}
=
request
;
const
result
=
await
queryAPI
(
path
requestJson
helper
)
;
postMessage
(
{
result
}
)
;
break
;
}
default
:
throw
new
Error
(
Unexpected
request
type
{
request
.
type
}
)
;
}
}
catch
(
error
)
{
postMessage
(
{
error
:
createPlainErrorObject
(
error
)
}
)
;
}
close
(
)
;
}
;
onunhandledrejection
=
e
=
>
{
e
.
preventDefault
(
)
;
postMessage
(
{
error
:
createPlainErrorObject
(
e
.
reason
)
}
)
;
}
;
onerror
=
e
=
>
{
postMessage
(
{
error
:
createPlainErrorObject
(
e
)
}
)
;
}
;
