"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
profiler_get_symbols
.
js
"
)
;
const
{
getCompactSymbolTable
queryAPI
}
=
wasm_bindgen
;
function
readFileBytesInto
(
file
offset
destBuf
)
{
file
.
setPosition
(
offset
)
;
const
chunkSize
=
4
*
1024
*
1024
;
let
posInDestBuf
=
0
;
let
remainingBytes
=
destBuf
.
byteLength
;
while
(
remainingBytes
>
0
)
{
const
bytes
=
remainingBytes
>
chunkSize
?
chunkSize
:
remainingBytes
;
const
chunkData
=
file
.
read
(
{
bytes
}
)
;
const
chunkBytes
=
chunkData
.
byteLength
;
if
(
chunkBytes
=
=
=
0
)
{
break
;
}
destBuf
.
set
(
chunkData
posInDestBuf
)
;
posInDestBuf
+
=
chunkBytes
;
remainingBytes
-
=
chunkBytes
;
}
}
function
createPlainErrorObject
(
e
)
{
if
(
e
instanceof
OS
.
File
.
Error
)
{
return
{
name
:
"
OSFileError
"
message
:
e
.
toString
(
)
fileName
:
e
.
fileName
lineNumber
:
e
.
lineNumber
}
;
}
const
{
name
message
fileName
lineNumber
}
=
e
;
return
{
name
message
fileName
lineNumber
}
;
}
class
FileAndPathHelper
{
constructor
(
libInfoMap
objdirs
)
{
this
.
_libInfoMap
=
libInfoMap
;
this
.
_objdirs
=
objdirs
;
}
getCandidatePathsForBinaryOrPdb
(
debugName
breakpadId
)
{
const
key
=
{
debugName
}
:
{
breakpadId
}
;
const
lib
=
this
.
_libInfoMap
.
get
(
key
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
.
)
;
}
const
{
name
path
debugPath
}
=
lib
;
const
candidatePaths
=
[
]
;
for
(
const
objdirPath
of
this
.
_objdirs
)
{
candidatePaths
.
push
(
OS
.
Path
.
join
(
objdirPath
"
dist
"
"
bin
"
name
)
)
;
candidatePaths
.
push
(
OS
.
Path
.
join
(
objdirPath
name
)
)
;
}
if
(
debugPath
!
=
=
path
)
{
candidatePaths
.
push
(
debugPath
)
;
}
candidatePaths
.
push
(
path
)
;
return
candidatePaths
;
}
async
readFile
(
path
)
{
const
file
=
OS
.
File
.
open
(
path
{
read
:
true
}
)
;
const
info
=
file
.
stat
(
)
;
if
(
info
.
isDir
)
{
throw
new
Error
(
Path
"
{
path
}
"
is
a
directory
.
)
;
}
const
fileSize
=
info
.
size
;
return
{
getLength
:
(
)
=
>
fileSize
readBytesInto
:
(
dest
offset
)
=
>
{
readFileBytesInto
(
file
offset
dest
)
;
}
drop
:
(
)
=
>
{
file
.
close
(
)
;
}
}
;
}
}
onmessage
=
async
e
=
>
{
try
{
const
{
request
libInfoMap
objdirs
module
}
=
e
.
data
;
if
(
!
(
module
instanceof
WebAssembly
.
Module
)
)
{
throw
new
Error
(
"
invalid
WebAssembly
module
"
)
;
}
await
wasm_bindgen
(
module
)
;
const
helper
=
new
FileAndPathHelper
(
libInfoMap
objdirs
)
;
switch
(
request
.
type
)
{
case
"
GET_SYMBOL_TABLE
"
:
{
const
{
debugName
breakpadId
}
=
request
;
const
result
=
await
getCompactSymbolTable
(
debugName
breakpadId
helper
)
;
postMessage
(
{
result
}
result
.
map
(
r
=
>
r
.
buffer
)
)
;
break
;
}
case
"
QUERY_SYMBOLICATION_API
"
:
{
const
{
path
requestJson
}
=
request
;
const
result
=
await
queryAPI
(
path
requestJson
helper
)
;
postMessage
(
{
result
}
)
;
break
;
}
default
:
throw
new
Error
(
Unexpected
request
type
{
request
.
type
}
)
;
}
}
catch
(
error
)
{
postMessage
(
{
error
:
createPlainErrorObject
(
error
)
}
)
;
}
close
(
)
;
}
;
