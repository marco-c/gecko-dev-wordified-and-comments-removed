"
use
strict
"
;
const
TRANSFER_EVENT
=
"
devtools
:
perf
-
html
-
transfer
-
profile
"
;
const
SYMBOL_TABLE_REQUEST_EVENT
=
"
devtools
:
perf
-
html
-
request
-
symbol
-
table
"
;
const
SYMBOL_TABLE_RESPONSE_EVENT
=
"
devtools
:
perf
-
html
-
reply
-
symbol
-
table
"
;
let
gProfile
=
null
;
const
symbolReplyPromiseMap
=
new
Map
(
)
;
addMessageListener
(
TRANSFER_EVENT
e
=
>
{
gProfile
=
e
.
data
;
connectToPage
(
)
;
addEventListener
(
"
DOMContentLoaded
"
connectToPage
)
;
}
)
;
addMessageListener
(
SYMBOL_TABLE_RESPONSE_EVENT
e
=
>
{
const
{
debugName
breakpadId
status
result
error
}
=
e
.
data
;
const
promiseKey
=
[
debugName
breakpadId
]
.
join
(
"
:
"
)
;
const
{
resolve
reject
}
=
symbolReplyPromiseMap
.
get
(
promiseKey
)
;
symbolReplyPromiseMap
.
delete
(
promiseKey
)
;
if
(
status
=
=
=
"
success
"
)
{
const
[
addresses
index
buffer
]
=
result
;
resolve
(
[
addresses
index
buffer
]
)
;
}
else
{
reject
(
error
)
;
}
}
)
;
function
connectToPage
(
)
{
const
unsafeWindow
=
content
.
wrappedJSObject
;
if
(
unsafeWindow
.
connectToGeckoProfiler
)
{
unsafeWindow
.
connectToGeckoProfiler
(
makeAccessibleToPage
(
{
getProfile
:
(
)
=
>
Promise
.
resolve
(
gProfile
)
getSymbolTable
:
(
debugName
breakpadId
)
=
>
getSymbolTable
(
debugName
breakpadId
)
}
unsafeWindow
)
)
;
}
}
function
getSymbolTable
(
debugName
breakpadId
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
sendAsyncMessage
(
SYMBOL_TABLE_REQUEST_EVENT
{
debugName
breakpadId
}
)
;
symbolReplyPromiseMap
.
set
(
[
debugName
breakpadId
]
.
join
(
"
:
"
)
{
resolve
reject
}
)
;
}
)
;
}
function
createPromiseInPage
(
fun
contentGlobal
)
{
function
funThatClonesObjects
(
resolve
reject
)
{
return
fun
(
result
=
>
resolve
(
Cu
.
cloneInto
(
result
contentGlobal
)
)
error
=
>
reject
(
Cu
.
cloneInto
(
error
contentGlobal
)
)
)
;
}
return
new
contentGlobal
.
Promise
(
Cu
.
exportFunction
(
funThatClonesObjects
contentGlobal
)
)
;
}
function
wrapFunction
(
fun
contentGlobal
)
{
return
function
(
)
{
const
result
=
fun
.
apply
(
this
arguments
)
;
if
(
typeof
result
=
=
=
"
object
"
)
{
if
(
"
then
"
in
result
&
&
typeof
result
.
then
=
=
=
"
function
"
)
{
return
createPromiseInPage
(
(
resolve
reject
)
=
>
result
.
then
(
resolve
reject
)
contentGlobal
)
;
}
return
Cu
.
cloneInto
(
result
contentGlobal
)
;
}
return
result
;
}
;
}
function
makeAccessibleToPage
(
obj
contentGlobal
)
{
const
result
=
Cu
.
createObjectIn
(
contentGlobal
)
;
for
(
const
field
in
obj
)
{
switch
(
typeof
obj
[
field
]
)
{
case
"
function
"
:
Cu
.
exportFunction
(
wrapFunction
(
obj
[
field
]
contentGlobal
)
result
{
defineAs
:
field
}
)
;
break
;
case
"
object
"
:
Cu
.
cloneInto
(
obj
[
field
]
result
{
defineAs
:
field
}
)
;
break
;
default
:
result
[
field
]
=
obj
[
field
]
;
break
;
}
}
return
result
;
}
