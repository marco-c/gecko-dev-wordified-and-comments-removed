"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
global
=
this
;
const
WASM_MODULE_URL
=
"
https
:
/
/
storage
.
googleapis
.
com
/
firefox
-
profiler
-
get
-
symbols
/
b933282e82f871ea76b5373f9fc81800e8550b7b
.
wasm
"
;
const
WASM_MODULE_INTEGRITY
=
"
sha384
-
WeRBd3mn0rbs
+
/
DX4NzsNc77ZhZOPuRTPZR9y10xrvQdUY6Dm0o205EDz3GyYSPv
"
;
const
EXPIRY_TIME_IN_MS
=
5
*
60
*
1000
;
let
gCachedWASMModulePromise
=
null
;
let
gCachedWASMModuleExpiryTimer
=
0
;
const
gActiveWorkers
=
new
Set
(
)
;
function
clearCachedWASMModule
(
)
{
gCachedWASMModulePromise
=
null
;
gCachedWASMModuleExpiryTimer
=
0
;
}
function
getWASMProfilerGetSymbolsModule
(
)
{
if
(
!
gCachedWASMModulePromise
)
{
gCachedWASMModulePromise
=
(
async
function
(
)
{
const
request
=
new
Request
(
WASM_MODULE_URL
{
integrity
:
WASM_MODULE_INTEGRITY
credentials
:
"
omit
"
}
)
;
return
WebAssembly
.
compileStreaming
(
fetch
(
request
)
)
;
}
)
(
)
;
}
clearTimeout
(
gCachedWASMModuleExpiryTimer
)
;
gCachedWASMModuleExpiryTimer
=
setTimeout
(
clearCachedWASMModule
EXPIRY_TIME_IN_MS
)
;
return
gCachedWASMModulePromise
;
}
async
function
getResultFromWorker
(
workerURL
initialMessageToWorker
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
worker
=
new
ChromeWorker
(
workerURL
)
;
gActiveWorkers
.
add
(
worker
)
;
worker
.
onmessage
=
msg
=
>
{
gActiveWorkers
.
delete
(
worker
)
;
if
(
"
error
"
in
msg
.
data
)
{
const
error
=
msg
.
data
.
error
;
if
(
error
.
name
)
{
const
{
name
message
fileName
lineNumber
}
=
error
;
const
ErrorObjConstructor
=
name
in
global
&
&
Error
.
isPrototypeOf
(
global
[
name
]
)
?
global
[
name
]
:
Error
;
const
e
=
new
ErrorObjConstructor
(
message
fileName
lineNumber
)
;
e
.
name
=
name
;
reject
(
e
)
;
}
else
{
reject
(
error
)
;
}
return
;
}
resolve
(
msg
.
data
.
result
)
;
}
;
worker
.
onerror
=
errorEvent
=
>
{
gActiveWorkers
.
delete
(
worker
)
;
worker
.
terminate
(
)
;
if
(
ErrorEvent
.
isInstance
(
errorEvent
)
)
{
const
{
message
filename
lineno
}
=
errorEvent
;
const
error
=
new
Error
(
{
message
}
at
{
filename
}
:
{
lineno
}
)
;
error
.
name
=
"
WorkerError
"
;
reject
(
error
)
;
}
else
{
reject
(
new
Error
(
"
Error
in
worker
"
)
)
;
}
}
;
worker
.
onmessageerror
=
(
)
=
>
{
gActiveWorkers
.
delete
(
worker
)
;
worker
.
terminate
(
)
;
reject
(
new
Error
(
"
Error
in
worker
"
)
)
;
}
;
worker
.
postMessage
(
initialMessageToWorker
)
;
}
)
;
}
async
function
getSymbolTableFromDebuggee
(
perfFront
path
breakpadId
)
{
const
[
addresses
index
buffer
]
=
await
perfFront
.
getSymbolTable
(
path
breakpadId
)
;
return
[
new
Uint32Array
(
addresses
)
new
Uint32Array
(
index
)
new
Uint8Array
(
buffer
)
]
;
}
class
LocalSymbolicationService
{
constructor
(
sharedLibraries
objdirs
)
{
this
.
_libInfoMap
=
new
Map
(
sharedLibraries
.
map
(
lib
=
>
{
const
{
debugName
breakpadId
}
=
lib
;
const
key
=
{
debugName
}
:
{
breakpadId
}
;
return
[
key
lib
]
;
}
)
)
;
this
.
_objdirs
=
objdirs
;
}
async
getSymbolTable
(
debugName
breakpadId
)
{
const
module
=
await
getWASMProfilerGetSymbolsModule
(
)
;
const
initialMessage
=
{
request
:
{
type
:
"
GET_SYMBOL_TABLE
"
debugName
breakpadId
}
libInfoMap
:
this
.
_libInfoMap
objdirs
:
this
.
_objdirs
module
}
;
return
getResultFromWorker
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
symbolication
-
worker
.
js
"
initialMessage
)
;
}
async
querySymbolicationApi
(
path
requestJson
)
{
const
module
=
await
getWASMProfilerGetSymbolsModule
(
)
;
const
initialMessage
=
{
request
:
{
type
:
"
QUERY_SYMBOLICATION_API
"
path
requestJson
}
libInfoMap
:
this
.
_libInfoMap
objdirs
:
this
.
_objdirs
module
}
;
return
getResultFromWorker
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
symbolication
-
worker
.
js
"
initialMessage
)
;
}
}
class
LocalSymbolicationServiceWithRemoteSymbolTableFallback
{
constructor
(
symbolicationService
sharedLibraries
perfFront
)
{
this
.
_symbolicationService
=
symbolicationService
;
this
.
_libs
=
sharedLibraries
;
this
.
_perfFront
=
perfFront
;
}
async
getSymbolTable
(
debugName
breakpadId
)
{
try
{
return
await
this
.
_symbolicationService
.
getSymbolTable
(
debugName
breakpadId
)
;
}
catch
(
errorFromLocalFiles
)
{
const
lib
=
this
.
_libs
.
find
(
l
=
>
l
.
debugName
=
=
=
debugName
&
&
l
.
breakpadId
=
=
=
breakpadId
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
after
falling
+
back
to
remote
symbol
table
querying
because
regular
getSymbolTable
failed
+
with
error
:
{
errorFromLocalFiles
.
message
}
.
)
;
}
return
getSymbolTableFromDebuggee
(
this
.
_perfFront
lib
.
path
breakpadId
)
;
}
}
async
querySymbolicationApi
(
path
requestJson
)
{
return
this
.
_symbolicationService
.
querySymbolicationApi
(
path
requestJson
)
;
}
}
function
createLocalSymbolicationService
(
sharedLibraries
objdirs
perfFront
)
{
const
service
=
new
LocalSymbolicationService
(
sharedLibraries
objdirs
)
;
if
(
perfFront
)
{
return
new
LocalSymbolicationServiceWithRemoteSymbolTableFallback
(
service
sharedLibraries
perfFront
)
;
}
return
service
;
}
(
this
)
.
module
=
{
}
;
module
.
exports
=
{
createLocalSymbolicationService
}
;
var
EXPORTED_SYMBOLS
=
Object
.
keys
(
module
.
exports
)
;
