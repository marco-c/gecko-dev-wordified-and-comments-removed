"
use
strict
"
;
const
{
createLazyLoaders
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
typescript
-
lazy
-
load
.
jsm
.
js
"
)
;
const
lazy
=
createLazyLoaders
(
{
OS
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
ProfilerGetSymbols
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ProfilerGetSymbols
.
jsm
"
)
}
)
;
async
function
getSymbolTableFromDebuggee
(
perfFront
path
breakpadId
)
{
const
[
addresses
index
buffer
]
=
await
perfFront
.
getSymbolTable
(
path
breakpadId
)
;
return
[
new
Uint32Array
(
addresses
)
new
Uint32Array
(
index
)
new
Uint8Array
(
buffer
)
]
;
}
async
function
doesFileExistAtPath
(
path
)
{
const
{
OS
}
=
lazy
.
OS
(
)
;
try
{
const
result
=
await
OS
.
File
.
stat
(
path
)
;
return
!
result
.
isDir
;
}
catch
(
e
)
{
if
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseNoSuchFile
)
{
return
false
;
}
throw
e
;
}
}
async
function
getSymbolTableFromLocalBinary
(
objdirs
filename
breakpadId
)
{
const
{
OS
}
=
lazy
.
OS
(
)
;
const
candidatePaths
=
[
]
;
for
(
const
objdirPath
of
objdirs
)
{
candidatePaths
.
push
(
OS
.
Path
.
join
(
objdirPath
"
dist
"
"
bin
"
filename
)
)
;
candidatePaths
.
push
(
OS
.
Path
.
join
(
objdirPath
filename
)
)
;
}
for
(
const
path
of
candidatePaths
)
{
if
(
await
doesFileExistAtPath
(
path
)
)
{
const
{
ProfilerGetSymbols
}
=
lazy
.
ProfilerGetSymbols
(
)
;
try
{
return
await
ProfilerGetSymbols
.
getSymbolTable
(
path
path
breakpadId
)
;
}
catch
(
e
)
{
}
}
}
throw
new
Error
(
"
Could
not
find
any
matching
binary
.
"
)
;
}
async
function
getSymbolTableMultiModal
(
lib
objdirs
perfFront
=
undefined
)
{
const
{
name
debugName
path
debugPath
breakpadId
}
=
lib
;
try
{
return
await
getSymbolTableFromLocalBinary
(
objdirs
name
breakpadId
)
;
}
catch
(
errorWhenCheckingObjdirs
)
{
if
(
await
doesFileExistAtPath
(
path
)
)
{
const
{
ProfilerGetSymbols
}
=
lazy
.
ProfilerGetSymbols
(
)
;
return
ProfilerGetSymbols
.
getSymbolTable
(
path
debugPath
breakpadId
)
;
}
if
(
!
perfFront
)
{
throw
new
Error
(
Could
not
obtain
symbols
for
the
library
{
debugName
}
{
breakpadId
}
+
because
there
was
no
file
at
the
given
path
"
{
path
}
"
.
Furthermore
+
looking
for
symbols
in
the
given
objdirs
failed
:
{
errorWhenCheckingObjdirs
.
message
}
)
;
}
return
getSymbolTableFromDebuggee
(
perfFront
path
breakpadId
)
;
}
}
function
createLibraryMap
(
sharedLibraries
)
{
const
map
=
new
Map
(
sharedLibraries
.
map
(
lib
=
>
{
const
{
debugName
breakpadId
}
=
lib
;
const
key
=
[
debugName
breakpadId
]
.
join
(
"
:
"
)
;
return
[
key
lib
]
;
}
)
)
;
return
function
getLibraryFor
(
debugName
breakpadId
)
{
const
key
=
[
debugName
breakpadId
]
.
join
(
"
:
"
)
;
return
map
.
get
(
key
)
;
}
;
}
class
LocalSymbolicationService
{
constructor
(
sharedLibraries
objdirs
perfFront
)
{
this
.
_libraryGetter
=
createLibraryMap
(
sharedLibraries
)
;
this
.
_objdirs
=
objdirs
;
this
.
_perfFront
=
perfFront
;
}
async
getSymbolTable
(
debugName
breakpadId
)
{
const
lib
=
this
.
_libraryGetter
(
debugName
breakpadId
)
;
if
(
!
lib
)
{
throw
new
Error
(
Could
not
find
the
library
for
"
{
debugName
}
"
"
{
breakpadId
}
"
.
)
;
}
return
getSymbolTableMultiModal
(
lib
this
.
_objdirs
this
.
_perfFront
)
;
}
}
function
createLocalSymbolicationService
(
sharedLibraries
objdirs
perfFront
)
{
return
new
LocalSymbolicationService
(
sharedLibraries
objdirs
perfFront
)
;
}
(
this
)
.
module
=
{
}
;
module
.
exports
=
{
createLocalSymbolicationService
getSymbolTableFromDebuggee
getSymbolTableFromLocalBinary
getSymbolTableMultiModal
}
;
var
EXPORTED_SYMBOLS
=
Object
.
keys
(
module
.
exports
)
;
