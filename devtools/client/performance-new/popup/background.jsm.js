"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
createLazyLoaders
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
typescript
-
lazy
-
load
.
jsm
.
js
"
)
;
const
AppConstants
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
.
AppConstants
;
const
ENTRIES_PREF
=
"
devtools
.
performance
.
recording
.
entries
"
;
const
INTERVAL_PREF
=
"
devtools
.
performance
.
recording
.
interval
"
;
const
FEATURES_PREF
=
"
devtools
.
performance
.
recording
.
features
"
;
const
THREADS_PREF
=
"
devtools
.
performance
.
recording
.
threads
"
;
const
OBJDIRS_PREF
=
"
devtools
.
performance
.
recording
.
objdirs
"
;
const
DURATION_PREF
=
"
devtools
.
performance
.
recording
.
duration
"
;
const
PRESET_PREF
=
"
devtools
.
performance
.
recording
.
preset
"
;
const
POPUP_FEATURE_FLAG_PREF
=
"
devtools
.
performance
.
popup
.
feature
-
flag
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
lazy
=
createLazyLoaders
(
{
OS
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
Utils
:
(
)
=
>
require
(
"
devtools
/
client
/
performance
-
new
/
utils
"
)
BrowserModule
:
(
)
=
>
require
(
"
devtools
/
client
/
performance
-
new
/
browser
"
)
RecordingUtils
:
(
)
=
>
require
(
"
devtools
/
shared
/
performance
-
new
/
recording
-
utils
"
)
CustomizableUI
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
PerfSymbolication
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
symbolication
.
jsm
.
js
"
)
PreferenceManagement
:
(
)
=
>
require
(
"
devtools
/
client
/
performance
-
new
/
preference
-
management
"
)
ProfilerMenuButton
:
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
}
)
;
const
presets
=
{
"
web
-
developer
"
:
{
label
:
"
Web
Developer
"
description
:
"
Recommended
preset
for
most
web
app
debugging
with
low
overhead
.
"
entries
:
128
*
1024
*
1024
interval
:
1
features
:
[
"
screenshots
"
"
js
"
]
threads
:
[
"
GeckoMain
"
"
Compositor
"
"
Renderer
"
"
DOM
Worker
"
]
duration
:
0
}
"
firefox
-
platform
"
:
{
label
:
"
Firefox
Platform
"
description
:
"
Recommended
preset
for
internal
Firefox
platform
debugging
.
"
entries
:
128
*
1024
*
1024
interval
:
1
features
:
[
"
screenshots
"
"
js
"
"
leaf
"
"
stackwalk
"
"
java
"
]
threads
:
[
"
GeckoMain
"
"
Compositor
"
"
Renderer
"
]
duration
:
0
}
"
firefox
-
front
-
end
"
:
{
label
:
"
Firefox
Front
-
End
"
description
:
"
Recommended
preset
for
internal
Firefox
front
-
end
debugging
.
"
entries
:
128
*
1024
*
1024
interval
:
1
features
:
[
"
screenshots
"
"
js
"
"
leaf
"
"
stackwalk
"
"
java
"
]
threads
:
[
"
GeckoMain
"
"
Compositor
"
"
Renderer
"
"
DOM
Worker
"
]
duration
:
0
}
graphics
:
{
label
:
"
Firefox
Graphics
"
description
:
"
Recommended
preset
for
Firefox
graphics
performance
investigation
.
"
entries
:
128
*
1024
*
1024
interval
:
1
features
:
[
"
leaf
"
"
stackwalk
"
"
js
"
"
java
"
]
threads
:
[
"
GeckoMain
"
"
Compositor
"
"
Renderer
"
"
RenderBackend
"
"
SceneBuilder
"
"
WrWorker
"
]
duration
:
0
}
media
:
{
label
:
"
Media
"
description
:
"
Recommended
preset
for
diagnosing
audio
and
video
problems
.
"
entries
:
128
*
1024
*
1024
interval
:
1
features
:
[
"
js
"
"
leaf
"
"
stackwalk
"
"
audiocallbacktracing
"
]
threads
:
[
"
AsyncCubebTask
"
"
AudioIPC
"
"
Compositor
"
"
GeckoMain
"
"
GraphRunner
"
"
MediaDecoderStateMachine
"
"
MediaPDecoder
"
"
MediaController
"
"
MediaTimer
"
"
NativeAudioCallback
"
"
RenderBackend
"
"
Renderer
"
]
duration
:
0
}
}
;
const
symbolCache
=
new
Map
(
)
;
async
function
getSymbolsFromThisBrowser
(
pageContext
debugName
breakpadId
)
{
if
(
symbolCache
.
size
=
=
=
0
)
{
for
(
const
lib
of
Services
.
profiler
.
sharedLibraries
)
{
symbolCache
.
set
(
{
lib
.
debugName
}
/
{
lib
.
breakpadId
}
lib
)
;
}
}
const
cachedLib
=
symbolCache
.
get
(
{
debugName
}
/
{
breakpadId
}
)
;
if
(
!
cachedLib
)
{
throw
new
Error
(
The
library
{
debugName
}
{
breakpadId
}
is
not
in
the
+
"
Services
.
profiler
.
sharedLibraries
list
so
the
local
path
for
it
is
not
known
"
+
"
and
symbols
for
it
can
not
be
obtained
.
This
usually
happens
if
a
content
"
+
"
process
uses
a
library
that
'
s
not
used
in
the
parent
process
-
"
+
"
Services
.
profiler
.
sharedLibraries
only
knows
about
libraries
in
the
"
+
"
parent
process
.
"
)
;
}
const
lib
=
cachedLib
;
const
objdirs
=
getObjdirPrefValue
(
pageContext
)
;
const
{
getSymbolTableMultiModal
}
=
lazy
.
PerfSymbolication
(
)
;
return
getSymbolTableMultiModal
(
lib
objdirs
)
;
}
async
function
captureProfile
(
pageContext
)
{
if
(
!
Services
.
profiler
.
IsActive
(
)
)
{
return
;
}
if
(
Services
.
profiler
.
IsPaused
(
)
)
{
return
;
}
Services
.
profiler
.
Pause
(
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsGzippedArrayBuffer
(
)
.
catch
(
e
=
>
{
console
.
error
(
e
)
;
return
{
}
;
}
)
;
const
receiveProfile
=
lazy
.
BrowserModule
(
)
.
receiveProfile
;
receiveProfile
(
profile
(
debugName
breakpadId
)
=
>
{
return
getSymbolsFromThisBrowser
(
pageContext
debugName
breakpadId
)
;
}
)
;
Services
.
profiler
.
StopProfiler
(
)
;
}
function
startProfiler
(
pageContext
)
{
const
{
translatePreferencesToState
}
=
lazy
.
PreferenceManagement
(
)
;
const
{
entries
interval
features
threads
duration
}
=
translatePreferencesToState
(
getRecordingPreferences
(
pageContext
Services
.
profiler
.
GetFeatures
(
)
)
)
;
const
{
getActiveBrowsingContextID
}
=
lazy
.
RecordingUtils
(
)
;
const
activeBrowsingContextID
=
getActiveBrowsingContextID
(
)
;
Services
.
profiler
.
StartProfiler
(
entries
interval
features
threads
activeBrowsingContextID
duration
)
;
}
function
stopProfiler
(
)
{
Services
.
profiler
.
StopProfiler
(
)
;
}
function
toggleProfiler
(
pageContext
)
{
if
(
Services
.
profiler
.
IsPaused
(
)
)
{
return
;
}
if
(
Services
.
profiler
.
IsActive
(
)
)
{
stopProfiler
(
)
;
}
else
{
startProfiler
(
pageContext
)
;
}
}
function
restartProfiler
(
pageContext
)
{
stopProfiler
(
)
;
startProfiler
(
pageContext
)
;
}
function
_getArrayOfStringsPref
(
prefName
)
{
const
text
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
return
JSON
.
parse
(
text
)
;
}
function
_getArrayOfStringsHostPref
(
prefName
)
{
const
text
=
Services
.
prefs
.
getStringPref
(
prefName
)
;
return
JSON
.
parse
(
text
)
;
}
function
getPrefPostfix
(
pageContext
)
{
switch
(
pageContext
)
{
case
"
devtools
"
:
case
"
aboutprofiling
"
:
return
"
"
;
case
"
devtools
-
remote
"
:
case
"
aboutprofiling
-
remote
"
:
return
"
.
remote
"
;
default
:
{
const
{
UnhandledCaseError
}
=
lazy
.
Utils
(
)
;
throw
new
UnhandledCaseError
(
pageContext
"
Page
Context
"
)
;
}
}
}
function
getObjdirPrefValue
(
pageContext
)
{
const
postfix
=
getPrefPostfix
(
pageContext
)
;
return
_getArrayOfStringsHostPref
(
OBJDIRS_PREF
+
postfix
)
;
}
function
getRecordingPreferences
(
pageContext
supportedFeatures
)
{
const
postfix
=
getPrefPostfix
(
pageContext
)
;
const
objdirs
=
getObjdirPrefValue
(
pageContext
)
;
const
presetName
=
Services
.
prefs
.
getCharPref
(
PRESET_PREF
+
postfix
)
;
const
recordingPrefs
=
getRecordingPrefsFromPreset
(
presetName
supportedFeatures
objdirs
)
;
if
(
recordingPrefs
)
{
return
recordingPrefs
;
}
const
entries
=
Services
.
prefs
.
getIntPref
(
ENTRIES_PREF
+
postfix
)
;
const
interval
=
Services
.
prefs
.
getIntPref
(
INTERVAL_PREF
+
postfix
)
;
const
features
=
_getArrayOfStringsPref
(
FEATURES_PREF
+
postfix
)
;
const
threads
=
_getArrayOfStringsPref
(
THREADS_PREF
+
postfix
)
;
const
duration
=
Services
.
prefs
.
getIntPref
(
DURATION_PREF
+
postfix
)
;
return
{
presetName
:
"
custom
"
entries
interval
features
:
features
.
filter
(
feature
=
>
supportedFeatures
.
includes
(
feature
)
)
threads
objdirs
duration
}
;
}
function
getRecordingPrefsFromPreset
(
presetName
supportedFeatures
objdirs
)
{
if
(
presetName
=
=
=
"
custom
"
)
{
return
null
;
}
const
preset
=
presets
[
presetName
]
;
if
(
!
preset
)
{
console
.
error
(
Unknown
profiler
preset
was
encountered
:
"
{
presetName
}
"
)
;
return
null
;
}
return
{
presetName
entries
:
preset
.
entries
interval
:
preset
.
interval
*
1000
features
:
preset
.
features
.
filter
(
feature
=
>
supportedFeatures
.
includes
(
feature
)
)
threads
:
preset
.
threads
objdirs
duration
:
preset
.
duration
}
;
}
function
setRecordingPreferences
(
pageContext
prefs
)
{
const
postfix
=
getPrefPostfix
(
pageContext
)
;
Services
.
prefs
.
setCharPref
(
PRESET_PREF
+
postfix
prefs
.
presetName
)
;
Services
.
prefs
.
setIntPref
(
ENTRIES_PREF
+
postfix
prefs
.
entries
)
;
Services
.
prefs
.
setIntPref
(
INTERVAL_PREF
+
postfix
prefs
.
interval
)
;
Services
.
prefs
.
setCharPref
(
FEATURES_PREF
+
postfix
JSON
.
stringify
(
prefs
.
features
)
)
;
Services
.
prefs
.
setCharPref
(
THREADS_PREF
+
postfix
JSON
.
stringify
(
prefs
.
threads
)
)
;
Services
.
prefs
.
setCharPref
(
OBJDIRS_PREF
+
postfix
JSON
.
stringify
(
prefs
.
objdirs
)
)
;
}
const
platform
=
AppConstants
.
platform
;
function
revertRecordingPreferences
(
)
{
for
(
const
postfix
of
[
"
"
"
.
remote
"
]
)
{
Services
.
prefs
.
clearUserPref
(
PRESET_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
ENTRIES_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
INTERVAL_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
FEATURES_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
THREADS_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
OBJDIRS_PREF
+
postfix
)
;
Services
.
prefs
.
clearUserPref
(
DURATION_PREF
+
postfix
)
;
}
Services
.
prefs
.
clearUserPref
(
POPUP_FEATURE_FLAG_PREF
)
;
}
function
changePreset
(
pageContext
presetName
supportedFeatures
)
{
const
postfix
=
getPrefPostfix
(
pageContext
)
;
const
objdirs
=
_getArrayOfStringsHostPref
(
OBJDIRS_PREF
+
postfix
)
;
let
recordingPrefs
=
getRecordingPrefsFromPreset
(
presetName
supportedFeatures
objdirs
)
;
if
(
!
recordingPrefs
)
{
Services
.
prefs
.
setCharPref
(
PRESET_PREF
+
postfix
presetName
)
;
recordingPrefs
=
getRecordingPreferences
(
pageContext
supportedFeatures
)
;
}
setRecordingPreferences
(
pageContext
recordingPrefs
)
;
}
function
handleWebChannelMessage
(
channel
id
message
target
)
{
if
(
typeof
message
!
=
=
"
object
"
|
|
typeof
message
.
type
!
=
=
"
string
"
)
{
console
.
error
(
"
An
malformed
message
was
received
by
the
profiler
'
s
WebChannel
handler
.
"
message
)
;
return
;
}
const
messageFromFrontend
=
(
message
)
;
const
{
requestId
}
=
messageFromFrontend
;
switch
(
messageFromFrontend
.
type
)
{
case
"
STATUS_QUERY
"
:
{
const
{
ProfilerMenuButton
}
=
lazy
.
ProfilerMenuButton
(
)
;
channel
.
send
(
{
type
:
"
STATUS_RESPONSE
"
menuButtonIsEnabled
:
ProfilerMenuButton
.
isInNavbar
(
)
requestId
}
target
)
;
break
;
}
case
"
ENABLE_MENU_BUTTON
"
:
{
const
{
ownerDocument
}
=
target
.
browser
;
if
(
!
ownerDocument
)
{
throw
new
Error
(
"
Could
not
find
the
owner
document
for
the
current
browser
while
enabling
"
+
"
the
profiler
menu
button
"
)
;
}
Services
.
prefs
.
setBoolPref
(
POPUP_FEATURE_FLAG_PREF
true
)
;
const
{
ProfilerMenuButton
}
=
lazy
.
ProfilerMenuButton
(
)
;
ProfilerMenuButton
.
addToNavbar
(
ownerDocument
)
;
const
{
CustomizableUI
}
=
lazy
.
CustomizableUI
(
)
;
CustomizableUI
.
dispatchToolboxEvent
(
"
customizationchange
"
)
;
ProfilerMenuButton
.
openPopup
(
ownerDocument
)
;
channel
.
send
(
{
type
:
"
ENABLE_MENU_BUTTON_DONE
"
requestId
}
target
)
;
break
;
}
default
:
console
.
error
(
"
An
unknown
message
type
was
received
by
the
profiler
'
s
WebChannel
handler
.
"
message
)
;
}
}
(
this
)
.
module
=
{
exports
:
{
}
}
;
module
.
exports
=
{
presets
captureProfile
startProfiler
stopProfiler
restartProfiler
toggleProfiler
platform
getSymbolsFromThisBrowser
getRecordingPreferences
setRecordingPreferences
revertRecordingPreferences
changePreset
handleWebChannelMessage
}
;
var
EXPORTED_SYMBOLS
=
Object
.
keys
(
module
.
exports
)
;
