"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
function
requireLazy
(
callback
)
{
let
cache
;
return
(
)
=
>
{
if
(
cache
=
=
=
undefined
)
{
cache
=
callback
(
)
;
}
return
cache
;
}
;
}
const
lazyOS
=
requireLazy
(
(
)
=
>
(
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
)
)
;
const
lazyProfilerGetSymbols
=
requireLazy
(
(
)
=
>
(
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ProfilerGetSymbols
.
jsm
"
)
)
)
;
const
lazyReceiveProfile
=
requireLazy
(
(
)
=
>
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
browserModule
=
require
(
"
devtools
/
client
/
performance
-
new
/
browser
"
)
;
return
browserModule
.
receiveProfile
;
}
)
;
const
PROFILER_STATE_PREF
=
"
devtools
.
performance
.
popup
"
;
const
DEFAULT_WINDOW_LENGTH
=
20
;
const
DEFAULT_INTERVAL
=
1
;
const
DEFAULT_BUFFER_SIZE
=
10000000
;
const
DEFAULT_THREADS
=
"
GeckoMain
Compositor
"
;
const
DEFAULT_STACKWALK_FEATURE
=
true
;
const
symbolCache
=
new
Map
(
)
;
const
primeSymbolStore
=
libs
=
>
{
for
(
const
{
path
debugName
debugPath
breakpadId
}
of
libs
)
{
symbolCache
.
set
(
{
debugName
}
/
{
breakpadId
}
{
path
debugPath
}
)
;
}
}
;
const
state
=
initializeState
(
)
;
const
forTestsOnly
=
{
DEFAULT_BUFFER_SIZE
DEFAULT_STACKWALK_FEATURE
initializeState
adjustState
getState
(
)
{
return
state
;
}
revertPrefs
(
)
{
Services
.
prefs
.
clearUserPref
(
PROFILER_STATE_PREF
)
;
}
}
;
function
adjustState
(
newState
)
{
newState
=
JSON
.
parse
(
JSON
.
stringify
(
newState
)
)
;
Object
.
assign
(
state
newState
)
;
try
{
Services
.
prefs
.
setStringPref
(
PROFILER_STATE_PREF
JSON
.
stringify
(
state
)
)
;
}
catch
(
error
)
{
console
.
error
(
"
Unable
to
save
the
profiler
state
for
the
popup
.
"
)
;
throw
error
;
}
}
async
function
getSymbolsFromThisBrowser
(
debugName
breakpadId
)
{
if
(
symbolCache
.
size
=
=
=
0
)
{
primeSymbolStore
(
Services
.
profiler
.
sharedLibraries
)
;
}
const
cachedLibInfo
=
symbolCache
.
get
(
{
debugName
}
/
{
breakpadId
}
)
;
if
(
!
cachedLibInfo
)
{
throw
new
Error
(
The
library
{
debugName
}
{
breakpadId
}
is
not
in
the
+
"
Services
.
profiler
.
sharedLibraries
list
so
the
local
path
for
it
is
not
known
"
+
"
and
symbols
for
it
can
not
be
obtained
.
This
usually
happens
if
a
content
"
+
"
process
uses
a
library
that
'
s
not
used
in
the
parent
process
-
"
+
"
Services
.
profiler
.
sharedLibraries
only
knows
about
libraries
in
the
"
+
"
parent
process
.
"
)
;
}
const
{
path
debugPath
}
=
cachedLibInfo
;
const
{
OS
}
=
lazyOS
(
)
;
if
(
!
OS
.
Path
.
split
(
path
)
.
absolute
)
{
throw
new
Error
(
"
Services
.
profiler
.
sharedLibraries
did
not
contain
an
absolute
path
for
"
+
the
library
{
debugName
}
{
breakpadId
}
so
symbols
for
this
library
can
not
+
"
be
obtained
.
"
)
;
}
const
{
ProfilerGetSymbols
}
=
lazyProfilerGetSymbols
(
)
;
return
ProfilerGetSymbols
.
getSymbolTable
(
path
debugPath
breakpadId
)
;
}
async
function
captureProfile
(
)
{
if
(
!
state
.
isRunning
)
{
return
;
}
Services
.
profiler
.
PauseSampling
(
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsGzippedArrayBuffer
(
)
.
catch
(
e
=
>
{
console
.
error
(
e
)
;
return
{
}
;
}
)
;
const
receiveProfile
=
lazyReceiveProfile
(
)
;
receiveProfile
(
profile
getSymbolsFromThisBrowser
)
;
Services
.
profiler
.
StopProfiler
(
)
;
}
function
getEnabledFeatures
(
features
threads
)
{
const
enabledFeatures
=
Object
.
keys
(
features
)
.
filter
(
f
=
>
features
[
f
]
)
;
if
(
threads
.
length
>
0
)
{
enabledFeatures
.
push
(
"
threads
"
)
;
}
const
supportedFeatures
=
Services
.
profiler
.
GetFeatures
(
[
]
)
;
return
enabledFeatures
.
filter
(
feature
=
>
supportedFeatures
.
includes
(
feature
)
)
;
}
function
startProfiler
(
)
{
const
threads
=
state
.
threads
.
split
(
"
"
)
;
const
features
=
getEnabledFeatures
(
state
.
features
threads
)
;
const
windowLength
=
state
.
windowLength
!
=
=
state
.
infiniteWindowLength
?
state
.
windowLength
:
0
;
const
{
buffersize
interval
}
=
state
;
Services
.
profiler
.
StartProfiler
(
buffersize
interval
features
threads
windowLength
)
;
}
function
stopProfiler
(
)
{
Services
.
profiler
.
StopProfiler
(
)
;
}
function
toggleProfiler
(
)
{
if
(
state
.
isRunning
)
{
stopProfiler
(
)
;
}
else
{
startProfiler
(
)
;
}
}
function
restartProfiler
(
)
{
stopProfiler
(
)
;
startProfiler
(
)
;
}
const
isRunningObserver
=
{
_observers
:
new
Set
(
)
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profiler
-
started
"
:
case
"
profiler
-
stopped
"
:
const
isRunningPromise
=
Promise
.
resolve
(
topic
=
=
=
"
profiler
-
started
"
)
;
for
(
const
observer
of
this
.
_observers
)
{
isRunningPromise
.
then
(
observer
)
;
}
break
;
}
}
_startListening
(
)
{
Services
.
obs
.
addObserver
(
this
"
profiler
-
started
"
)
;
Services
.
obs
.
addObserver
(
this
"
profiler
-
stopped
"
)
;
}
_stopListening
(
)
{
Services
.
obs
.
removeObserver
(
this
"
profiler
-
started
"
)
;
Services
.
obs
.
removeObserver
(
this
"
profiler
-
stopped
"
)
;
}
addObserver
(
observer
)
{
if
(
this
.
_observers
.
size
=
=
=
0
)
{
this
.
_startListening
(
)
;
}
this
.
_observers
.
add
(
observer
)
;
Promise
.
resolve
(
Services
.
profiler
.
IsActive
(
)
)
.
then
(
observer
)
;
}
removeObserver
(
observer
)
{
if
(
this
.
_observers
.
delete
(
observer
)
&
&
this
.
_observers
.
size
=
=
=
0
)
{
this
.
_stopListening
(
)
;
}
}
}
;
function
getStoredStateOrNull
(
)
{
const
storedStateString
=
Services
.
prefs
.
getStringPref
(
PROFILER_STATE_PREF
"
"
)
;
if
(
storedStateString
=
=
=
"
"
)
{
return
null
;
}
try
{
return
JSON
.
parse
(
storedStateString
)
;
}
catch
(
error
)
{
console
.
error
(
Could
not
parse
the
stored
state
for
the
profile
in
the
+
preferences
{
PROFILER_STATE_PREF
}
)
;
}
return
null
;
}
function
_getArrayOfStringsPref
(
prefName
defaultValue
)
{
let
array
;
try
{
const
text
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
array
=
JSON
.
parse
(
text
)
;
}
catch
(
error
)
{
return
defaultValue
;
}
if
(
Array
.
isArray
(
array
)
&
&
array
.
every
(
feature
=
>
typeof
feature
=
=
=
"
string
"
)
)
{
return
array
;
}
return
defaultValue
;
}
function
_getArrayOfStringsHostPref
(
prefName
defaultValue
)
{
let
array
;
try
{
const
text
=
Services
.
prefs
.
getStringPref
(
prefName
JSON
.
stringify
(
defaultValue
)
)
;
array
=
JSON
.
parse
(
text
)
;
}
catch
(
error
)
{
return
defaultValue
;
}
if
(
Array
.
isArray
(
array
)
&
&
array
.
every
(
feature
=
>
typeof
feature
=
=
=
"
string
"
)
)
{
return
array
;
}
return
defaultValue
;
}
function
getRecordingPreferencesFromBrowser
(
defaultSettings
)
{
const
[
entries
interval
features
threads
objdirs
]
=
[
Services
.
prefs
.
getIntPref
(
devtools
.
performance
.
recording
.
entries
defaultSettings
.
entries
)
Services
.
prefs
.
getIntPref
(
devtools
.
performance
.
recording
.
interval
defaultSettings
.
interval
)
_getArrayOfStringsPref
(
devtools
.
performance
.
recording
.
features
defaultSettings
.
features
)
_getArrayOfStringsPref
(
devtools
.
performance
.
recording
.
threads
defaultSettings
.
threads
)
_getArrayOfStringsHostPref
(
"
devtools
.
performance
.
recording
.
objdirs
"
defaultSettings
.
objdirs
)
]
;
const
newInterval
=
interval
/
1000
;
return
{
entries
interval
:
newInterval
features
threads
objdirs
}
;
}
function
setRecordingPreferencesOnBrowser
(
settings
)
{
Services
.
prefs
.
setIntPref
(
devtools
.
performance
.
recording
.
entries
settings
.
entries
)
;
Services
.
prefs
.
setIntPref
(
devtools
.
performance
.
recording
.
interval
settings
.
interval
*
1000
)
;
Services
.
prefs
.
setCharPref
(
devtools
.
performance
.
recording
.
features
JSON
.
stringify
(
settings
.
features
)
)
;
Services
.
prefs
.
setCharPref
(
devtools
.
performance
.
recording
.
threads
JSON
.
stringify
(
settings
.
threads
)
)
;
Services
.
prefs
.
setCharPref
(
"
devtools
.
performance
.
recording
.
objdirs
"
JSON
.
stringify
(
settings
.
objdirs
)
)
;
}
function
initializeState
(
)
{
const
features
=
{
java
:
false
js
:
true
leaf
:
true
mainthreadio
:
false
privacy
:
false
responsiveness
:
true
screenshots
:
false
seqstyle
:
false
stackwalk
:
DEFAULT_STACKWALK_FEATURE
tasktracer
:
false
trackopts
:
false
jstracer
:
false
preferencereads
:
false
jsallocations
:
false
nativeallocations
:
false
}
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
features
.
java
=
true
;
}
const
storedState
=
getStoredStateOrNull
(
)
;
if
(
storedState
&
&
storedState
.
features
)
{
const
storedFeatures
=
storedState
.
features
;
for
(
const
key
of
Object
.
keys
(
features
)
)
{
const
featureAsObjMap
=
features
;
featureAsObjMap
[
key
]
=
key
in
storedFeatures
?
Boolean
(
storedFeatures
[
key
]
)
:
featureAsObjMap
[
key
]
;
}
}
function
validateStoredState
(
key
type
defaultValue
)
{
if
(
!
storedState
)
{
return
defaultValue
;
}
const
storedStateAsObjMap
=
storedState
;
const
storedValue
=
storedStateAsObjMap
[
key
]
;
return
typeof
storedValue
=
=
=
type
?
storedValue
:
defaultValue
;
}
return
{
isRunning
:
Services
.
profiler
.
IsActive
(
)
settingsOpen
:
false
features
buffersize
:
validateStoredState
(
"
buffersize
"
"
number
"
DEFAULT_BUFFER_SIZE
)
windowLength
:
validateStoredState
(
"
windowLength
"
"
number
"
DEFAULT_WINDOW_LENGTH
)
interval
:
validateStoredState
(
"
interval
"
"
number
"
DEFAULT_INTERVAL
)
threads
:
validateStoredState
(
"
threads
"
"
string
"
DEFAULT_THREADS
)
}
;
}
isRunningObserver
.
addObserver
(
isRunning
=
>
{
adjustState
(
{
isRunning
}
)
;
}
)
;
const
platform
=
AppConstants
.
platform
;
var
EXPORTED_SYMBOLS
=
[
"
adjustState
"
"
captureProfile
"
"
state
"
"
startProfiler
"
"
stopProfiler
"
"
restartProfiler
"
"
toggleProfiler
"
"
isRunningObserver
"
"
platform
"
"
getRecordingPreferencesFromBrowser
"
"
setRecordingPreferencesOnBrowser
"
"
forTestsOnly
"
"
getSymbolsFromThisBrowser
"
]
;
