const
DEFAULT_VIEWER_URL
=
"
https
:
/
/
profiler
.
firefox
.
com
"
;
const
DEFAULT_WINDOW_LENGTH
=
20
;
const
tabToConnectionMap
=
new
Map
(
)
;
var
profilerState
;
var
profileViewerURL
=
DEFAULT_VIEWER_URL
;
var
isMigratedToNewUrl
;
function
adjustState
(
newState
)
{
newState
=
JSON
.
parse
(
JSON
.
stringify
(
newState
)
)
;
Object
.
assign
(
window
.
profilerState
newState
)
;
browser
.
storage
.
local
.
set
(
{
profilerState
:
window
.
profilerState
}
)
;
}
function
makeProfileAvailableToTab
(
profile
port
)
{
port
.
postMessage
(
{
type
:
"
ProfilerConnectToPage
"
payload
:
profile
}
)
;
port
.
onMessage
.
addListener
(
async
message
=
>
{
if
(
message
.
type
=
=
=
"
ProfilerGetSymbolTable
"
)
{
const
{
debugName
breakpadId
}
=
message
;
try
{
const
[
addresses
index
buffer
]
=
await
browser
.
geckoProfiler
.
getSymbols
(
debugName
breakpadId
)
;
port
.
postMessage
(
{
type
:
"
ProfilerGetSymbolTableReply
"
status
:
"
success
"
result
:
[
addresses
index
buffer
]
debugName
breakpadId
}
)
;
}
catch
(
e
)
{
port
.
postMessage
(
{
type
:
"
ProfilerGetSymbolTableReply
"
status
:
"
error
"
error
:
{
e
}
debugName
breakpadId
}
)
;
}
}
}
)
;
}
async
function
createAndWaitForTab
(
url
)
{
const
tabPromise
=
browser
.
tabs
.
create
(
{
active
:
true
url
}
)
;
return
tabPromise
;
}
function
getProfilePreferablyAsArrayBuffer
(
)
{
if
(
"
getProfileAsArrayBuffer
"
in
browser
.
geckoProfiler
)
{
return
browser
.
geckoProfiler
.
getProfileAsArrayBuffer
(
)
;
}
return
browser
.
geckoProfiler
.
getProfile
(
)
;
}
async
function
captureProfile
(
)
{
await
browser
.
geckoProfiler
.
pause
(
)
.
catch
(
(
)
=
>
{
}
)
;
const
profilePromise
=
getProfilePreferablyAsArrayBuffer
(
)
.
catch
(
e
=
>
{
console
.
error
(
e
)
;
return
{
}
;
}
)
;
const
tabOpenPromise
=
createAndWaitForTab
(
profileViewerURL
+
"
/
from
-
addon
"
)
;
try
{
const
[
profile
tab
]
=
await
Promise
.
all
(
[
profilePromise
tabOpenPromise
]
)
;
const
connection
=
tabToConnectionMap
.
get
(
tab
.
id
)
;
if
(
connection
)
{
makeProfileAvailableToTab
(
profile
connection
.
port
)
;
}
else
{
tabToConnectionMap
.
set
(
tab
.
id
{
profile
}
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
try
{
await
browser
.
geckoProfiler
.
resume
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
function
getEnabledFeatures
(
features
threads
)
{
const
enabledFeatures
=
Object
.
keys
(
features
)
.
filter
(
f
=
>
features
[
f
]
)
;
if
(
threads
.
length
>
0
)
{
enabledFeatures
.
push
(
"
threads
"
)
;
}
const
supportedFeatures
=
Object
.
values
(
browser
.
geckoProfiler
.
ProfilerFeature
)
;
return
enabledFeatures
.
filter
(
feature
=
>
supportedFeatures
.
includes
(
feature
)
)
;
}
async
function
startProfiler
(
)
{
const
settings
=
window
.
profilerState
;
const
threads
=
settings
.
threads
.
split
(
"
"
)
;
const
options
=
{
bufferSize
:
settings
.
buffersize
interval
:
settings
.
interval
features
:
getEnabledFeatures
(
settings
.
features
threads
)
threads
}
;
if
(
browser
.
geckoProfiler
.
supports
&
&
browser
.
geckoProfiler
.
supports
.
WINDOWLENGTH
)
{
options
.
windowLength
=
settings
.
windowLength
!
=
=
settings
.
infiniteWindowLength
?
settings
.
windowLength
:
0
;
}
await
browser
.
geckoProfiler
.
start
(
options
)
;
}
async
function
stopProfiler
(
)
{
await
browser
.
geckoProfiler
.
stop
(
)
;
}
async
function
restartProfiler
(
)
{
await
stopProfiler
(
)
;
await
startProfiler
(
)
;
}
(
async
(
)
=
>
{
const
storageResults
=
await
browser
.
storage
.
local
.
get
(
{
profilerState
:
null
profileViewerURL
:
DEFAULT_VIEWER_URL
isMigratedToNewUrl
:
false
}
)
;
window
.
profilerState
=
storageResults
.
profilerState
;
window
.
profileViewerURL
=
storageResults
.
profileViewerURL
;
if
(
!
storageResults
.
isMigratedToNewUrl
)
{
if
(
window
.
profileViewerURL
.
startsWith
(
"
https
:
/
/
perf
-
html
.
io
"
)
)
{
window
.
profileViewerURL
=
DEFAULT_VIEWER_URL
;
}
await
browser
.
storage
.
local
.
set
(
{
isMigratedToNewUrl
:
true
profileViewerURL
:
window
.
profileViewerURL
}
)
;
}
if
(
!
window
.
profilerState
)
{
window
.
profilerState
=
{
}
;
const
features
=
{
java
:
false
js
:
true
leaf
:
true
mainthreadio
:
false
memory
:
false
privacy
:
false
responsiveness
:
true
screenshots
:
false
seqstyle
:
false
stackwalk
:
true
tasktracer
:
false
trackopts
:
false
jstracer
:
false
}
;
const
platform
=
await
browser
.
runtime
.
getPlatformInfo
(
)
;
switch
(
platform
.
os
)
{
case
"
mac
"
:
features
.
screenshots
=
true
;
break
;
case
"
android
"
:
features
.
java
=
true
;
break
;
}
adjustState
(
{
isRunning
:
false
settingsOpen
:
false
buffersize
:
10000000
windowLength
:
DEFAULT_WINDOW_LENGTH
interval
:
1
features
threads
:
"
GeckoMain
Compositor
"
}
)
;
}
else
if
(
window
.
profilerState
.
windowLength
=
=
=
undefined
)
{
adjustState
(
{
windowLength
:
DEFAULT_WINDOW_LENGTH
}
)
;
}
browser
.
geckoProfiler
.
onRunning
.
addListener
(
isRunning
=
>
{
adjustState
(
{
isRunning
}
)
;
browser
.
browserAction
.
setIcon
(
{
path
:
isRunning
?
"
icons
/
toolbar_on
.
png
"
:
null
}
)
;
browser
.
browserAction
.
setTitle
(
{
title
:
isRunning
?
"
Gecko
Profiler
(
on
)
"
:
null
}
)
;
for
(
const
popup
of
browser
.
extension
.
getViews
(
{
type
:
"
popup
"
}
)
)
{
popup
.
renderState
(
window
.
profilerState
)
;
}
}
)
;
browser
.
storage
.
onChanged
.
addListener
(
changes
=
>
{
if
(
changes
.
profileViewerURL
)
{
profileViewerURL
=
changes
.
profileViewerURL
.
newValue
;
}
}
)
;
browser
.
commands
.
onCommand
.
addListener
(
command
=
>
{
if
(
command
=
=
=
"
ToggleProfiler
"
)
{
if
(
window
.
profilerState
.
isRunning
)
{
stopProfiler
(
)
;
}
else
{
startProfiler
(
)
;
}
}
else
if
(
command
=
=
=
"
CaptureProfile
"
)
{
if
(
window
.
profilerState
.
isRunning
)
{
captureProfile
(
)
;
}
}
}
)
;
browser
.
runtime
.
onConnect
.
addListener
(
port
=
>
{
const
tabId
=
port
.
sender
.
tab
.
id
;
const
connection
=
tabToConnectionMap
.
get
(
tabId
)
;
if
(
connection
&
&
connection
.
profile
)
{
makeProfileAvailableToTab
(
connection
.
profile
port
)
;
}
else
{
tabToConnectionMap
.
set
(
tabId
{
port
}
)
;
}
}
)
;
browser
.
tabs
.
onRemoved
.
addListener
(
tabId
=
>
{
tabToConnectionMap
.
delete
(
tabId
)
;
}
)
;
browser
.
webNavigation
.
onDOMContentLoaded
.
addListener
(
async
(
{
frameId
tabId
url
}
)
=
>
{
if
(
frameId
!
=
=
0
)
{
return
;
}
if
(
url
.
startsWith
(
profileViewerURL
)
)
{
browser
.
tabs
.
executeScript
(
tabId
{
file
:
"
content
.
js
"
}
)
;
}
else
{
tabToConnectionMap
.
delete
(
tabId
)
;
}
}
)
;
}
)
(
)
;
