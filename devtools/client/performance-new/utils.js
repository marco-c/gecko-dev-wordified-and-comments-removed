"
use
strict
"
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
UNITS
=
[
"
B
"
"
kiB
"
"
MiB
"
"
GiB
"
"
TiB
"
"
PiB
"
"
EiB
"
"
ZiB
"
"
YiB
"
]
;
function
lerp
(
frac
rangeStart
rangeEnd
)
{
return
(
1
-
frac
)
*
rangeStart
+
frac
*
rangeEnd
;
}
function
clamp
(
val
min
max
)
{
return
Math
.
max
(
min
Math
.
min
(
max
val
)
)
;
}
function
formatFileSize
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
throw
new
TypeError
(
Expected
a
finite
number
got
{
typeof
num
}
:
{
num
}
)
;
}
const
neg
=
num
<
0
;
if
(
neg
)
{
num
=
-
num
;
}
if
(
num
<
1
)
{
return
(
neg
?
"
-
"
:
"
"
)
+
num
+
"
B
"
;
}
const
exponent
=
Math
.
min
(
Math
.
floor
(
Math
.
log2
(
num
)
/
Math
.
log2
(
1024
)
)
UNITS
.
length
-
1
)
;
const
numStr
=
Number
(
(
num
/
Math
.
pow
(
1024
exponent
)
)
.
toPrecision
(
3
)
)
;
const
unit
=
UNITS
[
exponent
]
;
return
(
neg
?
"
-
"
:
"
"
)
+
numStr
+
"
"
+
unit
;
}
function
makeExponentialScale
(
rangeStart
rangeEnd
)
{
const
startExp
=
Math
.
log
(
rangeStart
)
;
const
endExp
=
Math
.
log
(
rangeEnd
)
;
const
fromFractionToValue
=
frac
=
>
Math
.
exp
(
(
1
-
frac
)
*
startExp
+
frac
*
endExp
)
;
const
fromValueToFraction
=
value
=
>
(
Math
.
log
(
value
)
-
startExp
)
/
(
endExp
-
startExp
)
;
const
fromFractionToSingleDigitValue
=
frac
=
>
{
return
+
fromFractionToValue
(
frac
)
.
toPrecision
(
1
)
;
}
;
return
{
fromFractionToValue
fromValueToFraction
fromFractionToSingleDigitValue
}
;
}
function
makePowerOf2Scale
(
rangeStart
rangeEnd
)
{
const
startExp
=
Math
.
log2
(
rangeStart
)
;
const
endExp
=
Math
.
log2
(
rangeEnd
)
;
const
fromFractionToValue
=
frac
=
>
Math
.
pow
(
2
Math
.
round
(
(
1
-
frac
)
*
startExp
+
frac
*
endExp
)
)
;
const
fromValueToFraction
=
value
=
>
(
Math
.
log2
(
value
)
-
startExp
)
/
(
endExp
-
startExp
)
;
const
fromFractionToSingleDigitValue
=
frac
=
>
{
return
fromFractionToValue
(
frac
)
;
}
;
return
{
fromFractionToValue
fromValueToFraction
fromFractionToSingleDigitValue
}
;
}
function
scaleRangeWithClamping
(
val
sourceRangeStart
sourceRangeEnd
destRangeStart
destRangeEnd
)
{
const
frac
=
clamp
(
(
val
-
sourceRangeStart
)
/
(
sourceRangeEnd
-
sourceRangeStart
)
0
1
)
;
return
lerp
(
frac
destRangeStart
destRangeEnd
)
;
}
function
calculateOverhead
(
interval
bufferSize
features
)
{
const
periodicSampling
=
!
features
.
includes
(
"
nostacksampling
"
)
;
const
overheadFromSampling
=
periodicSampling
?
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
0
.
05
)
Math
.
log
(
1
)
1
0
)
+
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
1
)
Math
.
log
(
100
)
0
.
1
0
)
:
0
;
const
overheadFromBuffersize
=
scaleRangeWithClamping
(
Math
.
log
(
bufferSize
)
Math
.
log
(
10
)
Math
.
log
(
1000000
)
0
0
.
1
)
;
const
overheadFromStackwalk
=
features
.
includes
(
"
stackwalk
"
)
&
&
periodicSampling
?
0
.
05
:
0
;
const
overheadFromJavaScript
=
features
.
includes
(
"
js
"
)
&
&
periodicSampling
?
0
.
05
:
0
;
const
overheadFromTaskTracer
=
features
.
includes
(
"
tasktracer
"
)
?
0
.
05
:
0
;
const
overheadFromJSTracer
=
features
.
includes
(
"
jstracer
"
)
?
0
.
05
:
0
;
const
overheadFromJSAllocations
=
features
.
includes
(
"
jsallocations
"
)
?
0
.
05
:
0
;
const
overheadFromNativeAllocations
=
features
.
includes
(
"
nativeallocations
"
)
?
0
.
5
:
0
;
return
clamp
(
overheadFromSampling
+
overheadFromBuffersize
+
overheadFromStackwalk
+
overheadFromJavaScript
+
overheadFromTaskTracer
+
overheadFromJSTracer
+
overheadFromJSAllocations
+
overheadFromNativeAllocations
0
1
)
;
}
function
withCommonPathPrefixRemoved
(
pathArray
)
{
if
(
pathArray
.
length
=
=
=
0
)
{
return
[
]
;
}
const
splitPaths
=
pathArray
.
map
(
path
=
>
OS
.
Path
.
split
(
path
)
)
;
if
(
!
splitPaths
.
every
(
sp
=
>
sp
.
absolute
)
)
{
return
pathArray
;
}
const
[
firstSplitPath
.
.
.
otherSplitPaths
]
=
splitPaths
;
if
(
"
winDrive
"
in
firstSplitPath
)
{
const
winDrive
=
firstSplitPath
.
winDrive
;
if
(
!
otherSplitPaths
.
every
(
sp
=
>
sp
.
winDrive
=
=
=
winDrive
)
)
{
return
pathArray
;
}
}
else
if
(
otherSplitPaths
.
some
(
sp
=
>
"
winDrive
"
in
sp
)
)
{
return
pathArray
;
}
const
prefix
=
firstSplitPath
.
components
.
slice
(
0
-
1
)
;
for
(
const
sp
of
otherSplitPaths
)
{
prefix
.
length
=
Math
.
min
(
prefix
.
length
sp
.
components
.
length
-
1
)
;
for
(
let
i
=
0
;
i
<
prefix
.
length
;
i
+
+
)
{
if
(
prefix
[
i
]
!
=
=
sp
.
components
[
i
]
)
{
prefix
.
length
=
i
;
break
;
}
}
}
if
(
prefix
.
length
=
=
=
0
|
|
(
prefix
.
length
=
=
=
1
&
&
prefix
[
0
]
=
=
=
"
"
)
)
{
return
pathArray
;
}
return
splitPaths
.
map
(
sp
=
>
OS
.
Path
.
join
(
.
.
.
sp
.
components
.
slice
(
prefix
.
length
)
)
)
;
}
class
UnhandledCaseError
extends
Error
{
constructor
(
value
typeName
)
{
super
(
There
was
an
unhandled
case
for
"
{
typeName
}
"
:
{
value
}
)
;
this
.
name
=
"
UnhandledCaseError
"
;
}
}
const
featureDescriptions
=
[
{
name
:
"
Native
Stacks
"
value
:
"
stackwalk
"
title
:
"
Record
native
stacks
(
C
+
+
and
Rust
)
.
This
is
not
available
on
all
platforms
.
"
recommended
:
true
disabledReason
:
"
Native
stack
walking
is
not
supported
on
this
platform
.
"
}
{
name
:
"
JavaScript
"
value
:
"
js
"
title
:
"
Record
JavaScript
stack
information
and
interleave
it
with
native
stacks
.
"
recommended
:
true
}
{
name
:
"
CPU
Utilization
"
value
:
"
cpu
"
title
:
"
Record
how
much
CPU
has
been
used
between
samples
by
each
profiled
thread
.
"
recommended
:
true
}
{
name
:
"
Java
"
value
:
"
java
"
title
:
"
Profile
Java
code
"
disabledReason
:
"
This
feature
is
only
available
on
Android
.
"
}
{
name
:
"
Native
Leaf
Stack
"
value
:
"
leaf
"
title
:
"
Record
the
native
memory
address
of
the
leaf
-
most
stack
.
This
could
be
"
+
"
useful
on
platforms
that
do
not
support
stack
walking
.
"
}
{
name
:
"
No
Periodic
Sampling
"
value
:
"
nostacksampling
"
title
:
"
Disable
interval
-
based
stack
sampling
"
}
{
name
:
"
Main
Thread
File
IO
"
value
:
"
mainthreadio
"
title
:
"
Record
main
thread
File
I
/
O
markers
.
"
}
{
name
:
"
Profiled
Threads
File
IO
"
value
:
"
fileio
"
title
:
"
Record
File
I
/
O
markers
from
only
profiled
threads
.
"
}
{
name
:
"
All
File
IO
"
value
:
"
fileioall
"
title
:
"
Record
File
I
/
O
markers
from
all
threads
even
unregistered
threads
.
"
}
{
name
:
"
No
File
IO
Stack
Sampling
"
value
:
"
noiostacks
"
title
:
"
Do
not
sample
stacks
when
recording
File
I
/
O
markers
.
"
}
{
name
:
"
Sequential
Styling
"
value
:
"
seqstyle
"
title
:
"
Disable
parallel
traversal
in
styling
.
"
}
{
name
:
"
TaskTracer
"
value
:
"
tasktracer
"
title
:
"
Enable
TaskTracer
"
experimental
:
true
disabledReason
:
"
TaskTracer
requires
a
custom
build
with
the
environment
variable
MOZ_TASK_TRACER
set
.
"
}
{
name
:
"
Screenshots
"
value
:
"
screenshots
"
title
:
"
Record
screenshots
of
all
browser
windows
.
"
}
{
name
:
"
JSTracer
"
value
:
"
jstracer
"
title
:
"
Trace
JS
engine
"
experimental
:
true
disabledReason
:
"
JS
Tracer
is
currently
disabled
due
to
crashes
.
See
Bug
1565788
.
"
}
{
name
:
"
Preference
Read
"
value
:
"
preferencereads
"
title
:
"
Track
Preference
Reads
"
}
{
name
:
"
IPC
Messages
"
value
:
"
ipcmessages
"
title
:
"
Track
IPC
messages
.
"
}
{
name
:
"
JS
Allocations
"
value
:
"
jsallocations
"
title
:
"
Track
JavaScript
allocations
"
}
{
name
:
"
Native
Allocations
"
value
:
"
nativeallocations
"
title
:
"
Track
native
allocations
"
}
{
name
:
"
Audio
Callback
Tracing
"
value
:
"
audiocallbacktracing
"
title
:
"
Trace
real
-
time
audio
callbacks
.
"
}
]
;
module
.
exports
=
{
formatFileSize
makeExponentialScale
makePowerOf2Scale
scaleRangeWithClamping
calculateOverhead
withCommonPathPrefixRemoved
UnhandledCaseError
featureDescriptions
}
;
