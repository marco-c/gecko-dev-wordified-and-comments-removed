"
use
strict
"
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
recordingState
=
{
NOT_YET_KNOWN
:
"
not
-
yet
-
known
"
AVAILABLE_TO_RECORD
:
"
available
-
to
-
record
"
REQUEST_TO_START_RECORDING
:
"
request
-
to
-
start
-
recording
"
REQUEST_TO_GET_PROFILE_AND_STOP_PROFILER
:
"
request
-
to
-
get
-
profile
-
and
-
stop
-
profiler
"
REQUEST_TO_STOP_PROFILER
:
"
request
-
to
-
stop
-
profiler
"
RECORDING
:
"
recording
"
OTHER_IS_RECORDING
:
"
other
-
is
-
recording
"
LOCKED_BY_PRIVATE_BROWSING
:
"
locked
-
by
-
private
-
browsing
"
}
;
const
UNITS
=
[
"
B
"
"
kB
"
"
MB
"
"
GB
"
"
TB
"
"
PB
"
"
EB
"
"
ZB
"
"
YB
"
]
;
function
lerp
(
frac
rangeStart
rangeEnd
)
{
return
(
1
-
frac
)
*
rangeStart
+
frac
*
rangeEnd
;
}
function
clamp
(
val
min
max
)
{
return
Math
.
max
(
min
Math
.
min
(
max
val
)
)
;
}
function
formatFileSize
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
throw
new
TypeError
(
Expected
a
finite
number
got
{
typeof
num
}
:
{
num
}
)
;
}
const
neg
=
num
<
0
;
if
(
neg
)
{
num
=
-
num
;
}
if
(
num
<
1
)
{
return
(
neg
?
"
-
"
:
"
"
)
+
num
+
"
B
"
;
}
const
exponent
=
Math
.
min
(
Math
.
floor
(
Math
.
log
(
num
)
/
Math
.
log
(
1000
)
)
UNITS
.
length
-
1
)
;
const
numStr
=
Number
(
(
num
/
Math
.
pow
(
1000
exponent
)
)
.
toPrecision
(
3
)
)
;
const
unit
=
UNITS
[
exponent
]
;
return
(
neg
?
"
-
"
:
"
"
)
+
numStr
+
"
"
+
unit
;
}
function
makeExponentialScale
(
rangeStart
rangeEnd
)
{
const
startExp
=
Math
.
log
(
rangeStart
)
;
const
endExp
=
Math
.
log
(
rangeEnd
)
;
const
fromFractionToValue
=
frac
=
>
Math
.
exp
(
(
1
-
frac
)
*
startExp
+
frac
*
endExp
)
;
const
fromValueToFraction
=
value
=
>
(
Math
.
log
(
value
)
-
startExp
)
/
(
endExp
-
startExp
)
;
const
fromFractionToSingleDigitValue
=
frac
=
>
{
return
+
fromFractionToValue
(
frac
)
.
toPrecision
(
1
)
;
}
;
return
{
fromFractionToValue
fromValueToFraction
fromFractionToSingleDigitValue
}
;
}
function
scaleRangeWithClamping
(
val
sourceRangeStart
sourceRangeEnd
destRangeStart
destRangeEnd
)
{
const
frac
=
clamp
(
(
val
-
sourceRangeStart
)
/
(
sourceRangeEnd
-
sourceRangeStart
)
0
1
)
;
return
lerp
(
frac
destRangeStart
destRangeEnd
)
;
}
function
calculateOverhead
(
interval
bufferSize
features
)
{
const
overheadFromSampling
=
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
0
.
05
)
Math
.
log
(
1
)
1
0
)
+
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
1
)
Math
.
log
(
100
)
0
.
1
0
)
;
const
overheadFromBuffersize
=
scaleRangeWithClamping
(
Math
.
log
(
bufferSize
)
Math
.
log
(
10
)
Math
.
log
(
1000000
)
0
0
.
1
)
;
const
overheadFromStackwalk
=
features
.
includes
(
"
stackwalk
"
)
?
0
.
05
:
0
;
const
overheadFromJavaScrpt
=
features
.
includes
(
"
js
"
)
?
0
.
05
:
0
;
const
overheadFromTaskTracer
=
features
.
includes
(
"
tasktracer
"
)
?
0
.
05
:
0
;
return
clamp
(
overheadFromSampling
+
overheadFromBuffersize
+
overheadFromStackwalk
+
overheadFromJavaScrpt
+
overheadFromTaskTracer
0
1
)
;
}
function
withCommonPathPrefixRemoved
(
pathArray
)
{
if
(
pathArray
.
length
=
=
=
0
)
{
return
[
]
;
}
const
splitPaths
=
pathArray
.
map
(
path
=
>
OS
.
Path
.
split
(
path
)
)
;
if
(
!
splitPaths
.
every
(
sp
=
>
sp
.
absolute
)
)
{
return
pathArray
;
}
const
[
firstSplitPath
.
.
.
otherSplitPaths
]
=
splitPaths
;
if
(
"
winDrive
"
in
firstSplitPath
)
{
const
winDrive
=
firstSplitPath
.
winDrive
;
if
(
!
otherSplitPaths
.
every
(
sp
=
>
sp
.
winDrive
=
=
=
winDrive
)
)
{
return
pathArray
;
}
}
else
if
(
otherSplitPaths
.
some
(
sp
=
>
(
"
winDrive
"
in
sp
)
)
)
{
return
pathArray
;
}
const
prefix
=
firstSplitPath
.
components
.
slice
(
0
-
1
)
;
for
(
const
sp
of
otherSplitPaths
)
{
prefix
.
length
=
Math
.
min
(
prefix
.
length
sp
.
components
.
length
-
1
)
;
for
(
let
i
=
0
;
i
<
prefix
.
length
;
i
+
+
)
{
if
(
prefix
[
i
]
!
=
=
sp
.
components
[
i
]
)
{
prefix
.
length
=
i
;
break
;
}
}
}
if
(
prefix
.
length
=
=
=
0
|
|
(
prefix
.
length
=
=
=
1
&
&
prefix
[
0
]
=
=
=
"
"
)
)
{
return
pathArray
;
}
return
splitPaths
.
map
(
sp
=
>
OS
.
Path
.
join
(
.
.
.
sp
.
components
.
slice
(
prefix
.
length
)
)
)
;
}
module
.
exports
=
{
formatFileSize
makeExponentialScale
scaleRangeWithClamping
calculateOverhead
recordingState
withCommonPathPrefixRemoved
}
;
