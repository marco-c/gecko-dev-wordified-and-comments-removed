"
use
strict
"
;
const
UNITS
=
[
"
B
"
"
kiB
"
"
MiB
"
"
GiB
"
"
TiB
"
"
PiB
"
"
EiB
"
"
ZiB
"
"
YiB
"
]
;
function
lerp
(
frac
rangeStart
rangeEnd
)
{
return
(
1
-
frac
)
*
rangeStart
+
frac
*
rangeEnd
;
}
function
clamp
(
val
min
max
)
{
return
Math
.
max
(
min
Math
.
min
(
max
val
)
)
;
}
function
formatFileSize
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
throw
new
TypeError
(
Expected
a
finite
number
got
{
typeof
num
}
:
{
num
}
)
;
}
const
neg
=
num
<
0
;
if
(
neg
)
{
num
=
-
num
;
}
if
(
num
<
1
)
{
return
(
neg
?
"
-
"
:
"
"
)
+
num
+
"
B
"
;
}
const
exponent
=
Math
.
min
(
Math
.
floor
(
Math
.
log2
(
num
)
/
Math
.
log2
(
1024
)
)
UNITS
.
length
-
1
)
;
const
numStr
=
Number
(
(
num
/
Math
.
pow
(
1024
exponent
)
)
.
toPrecision
(
3
)
)
;
const
unit
=
UNITS
[
exponent
]
;
return
(
neg
?
"
-
"
:
"
"
)
+
numStr
+
"
"
+
unit
;
}
function
makeLinear10Scale
(
rangeStart
rangeEnd
)
{
const
start10
=
Math
.
log10
(
rangeStart
)
;
const
end10
=
Math
.
log10
(
rangeEnd
)
;
if
(
!
Number
.
isInteger
(
start10
)
)
{
throw
new
Error
(
rangeStart
is
not
a
power
of
10
:
{
rangeStart
}
)
;
}
if
(
!
Number
.
isInteger
(
end10
)
)
{
throw
new
Error
(
rangeEnd
is
not
a
power
of
10
:
{
rangeEnd
}
)
;
}
const
intervals
=
end10
-
start10
;
const
STEP_PER_INTERVAL
=
9
;
const
steps
=
intervals
*
STEP_PER_INTERVAL
;
const
fromFractionToValue
=
frac
=
>
{
const
step
=
Math
.
round
(
frac
*
steps
)
;
const
base
=
Math
.
floor
(
step
/
STEP_PER_INTERVAL
)
;
const
factor
=
(
step
%
STEP_PER_INTERVAL
)
+
1
;
return
Math
.
pow
(
10
base
)
*
factor
*
rangeStart
;
}
;
const
fromValueToFraction
=
value
=
>
{
const
interval
=
Math
.
floor
(
Math
.
log10
(
value
/
rangeStart
)
)
;
const
base
=
rangeStart
*
Math
.
pow
(
10
interval
)
;
return
(
interval
*
STEP_PER_INTERVAL
+
value
/
base
-
1
)
/
steps
;
}
;
const
fromFractionToSingleDigitValue
=
frac
=
>
{
return
+
fromFractionToValue
(
frac
)
.
toPrecision
(
1
)
;
}
;
return
{
fromFractionToValue
fromValueToFraction
fromFractionToSingleDigitValue
steps
}
;
}
function
makePowerOf2Scale
(
rangeStart
rangeEnd
)
{
const
startExp
=
Math
.
log2
(
rangeStart
)
;
const
endExp
=
Math
.
log2
(
rangeEnd
)
;
if
(
!
Number
.
isInteger
(
startExp
)
)
{
throw
new
Error
(
rangeStart
is
not
a
power
of
2
:
{
rangeStart
}
)
;
}
if
(
!
Number
.
isInteger
(
endExp
)
)
{
throw
new
Error
(
rangeEnd
is
not
a
power
of
2
:
{
rangeEnd
}
)
;
}
const
steps
=
endExp
-
startExp
;
const
fromFractionToValue
=
frac
=
>
Math
.
pow
(
2
Math
.
round
(
(
1
-
frac
)
*
startExp
+
frac
*
endExp
)
)
;
const
fromValueToFraction
=
value
=
>
(
Math
.
log2
(
value
)
-
startExp
)
/
(
endExp
-
startExp
)
;
const
fromFractionToSingleDigitValue
=
frac
=
>
{
return
fromFractionToValue
(
frac
)
;
}
;
return
{
fromFractionToValue
fromValueToFraction
fromFractionToSingleDigitValue
steps
}
;
}
function
scaleRangeWithClamping
(
val
sourceRangeStart
sourceRangeEnd
destRangeStart
destRangeEnd
)
{
const
frac
=
clamp
(
(
val
-
sourceRangeStart
)
/
(
sourceRangeEnd
-
sourceRangeStart
)
0
1
)
;
return
lerp
(
frac
destRangeStart
destRangeEnd
)
;
}
function
calculateOverhead
(
interval
bufferSize
features
)
{
const
periodicSampling
=
!
features
.
includes
(
"
nostacksampling
"
)
;
const
overheadFromSampling
=
periodicSampling
?
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
0
.
05
)
Math
.
log
(
1
)
1
0
)
+
scaleRangeWithClamping
(
Math
.
log
(
interval
)
Math
.
log
(
1
)
Math
.
log
(
100
)
0
.
1
0
)
:
0
;
const
overheadFromBuffersize
=
scaleRangeWithClamping
(
Math
.
log
(
bufferSize
)
Math
.
log
(
10
)
Math
.
log
(
1000000
)
0
0
.
1
)
;
const
overheadFromStackwalk
=
features
.
includes
(
"
stackwalk
"
)
&
&
periodicSampling
?
0
.
05
:
0
;
const
overheadFromJavaScript
=
features
.
includes
(
"
js
"
)
&
&
periodicSampling
?
0
.
05
:
0
;
const
overheadFromJSTracer
=
features
.
includes
(
"
jstracer
"
)
?
0
.
05
:
0
;
const
overheadFromJSAllocations
=
features
.
includes
(
"
jsallocations
"
)
?
0
.
05
:
0
;
const
overheadFromNativeAllocations
=
features
.
includes
(
"
nativeallocations
"
)
?
0
.
5
:
0
;
return
clamp
(
overheadFromSampling
+
overheadFromBuffersize
+
overheadFromStackwalk
+
overheadFromJavaScript
+
overheadFromJSTracer
+
overheadFromJSAllocations
+
overheadFromNativeAllocations
0
1
)
;
}
function
withCommonPathPrefixRemoved
(
pathArray
)
{
if
(
pathArray
.
length
=
=
=
0
)
{
return
[
]
;
}
const
firstPath
=
pathArray
[
0
]
;
const
isWin
=
/
^
[
A
-
Za
-
z
]
:
/
.
test
(
firstPath
)
;
const
firstWinDrive
=
getWinDrive
(
firstPath
)
;
for
(
const
path
of
pathArray
)
{
const
winDrive
=
getWinDrive
(
path
)
;
if
(
!
PathUtils
.
isAbsolute
(
path
)
|
|
winDrive
!
=
=
firstWinDrive
)
{
return
pathArray
;
}
}
const
splitPaths
=
pathArray
.
map
(
path
=
>
PathUtils
.
split
(
path
)
)
;
const
[
firstSplitPath
.
.
.
otherSplitPaths
]
=
splitPaths
;
const
prefix
=
firstSplitPath
.
slice
(
0
-
1
)
;
for
(
const
sp
of
otherSplitPaths
)
{
prefix
.
length
=
Math
.
min
(
prefix
.
length
sp
.
length
-
1
)
;
for
(
let
i
=
0
;
i
<
prefix
.
length
;
i
+
+
)
{
if
(
prefix
[
i
]
!
=
=
sp
[
i
]
)
{
prefix
.
length
=
i
;
break
;
}
}
}
if
(
prefix
.
length
=
=
=
0
|
|
(
prefix
.
length
=
=
=
1
&
&
(
prefix
[
0
]
=
=
=
firstWinDrive
|
|
prefix
[
0
]
=
=
=
"
/
"
)
)
)
{
return
pathArray
;
}
return
splitPaths
.
map
(
sp
=
>
{
return
sp
.
slice
(
prefix
.
length
)
.
join
(
isWin
?
"
\
\
"
:
"
/
"
)
;
}
)
;
}
function
getWinDrive
(
path
)
{
if
(
path
=
=
null
)
{
throw
new
TypeError
(
"
path
is
invalid
"
)
;
}
if
(
path
.
startsWith
(
"
\
\
\
\
"
)
)
{
if
(
path
.
length
=
=
2
)
{
return
null
;
}
const
index
=
path
.
indexOf
(
"
\
\
"
2
)
;
if
(
index
=
=
-
1
)
{
return
path
;
}
return
path
.
slice
(
0
index
)
;
}
const
index
=
path
.
indexOf
(
"
:
"
)
;
if
(
index
<
=
0
)
{
return
null
;
}
return
path
.
slice
(
0
index
+
1
)
;
}
class
UnhandledCaseError
extends
Error
{
constructor
(
value
typeName
)
{
super
(
There
was
an
unhandled
case
for
"
{
typeName
}
"
:
{
value
}
)
;
this
.
name
=
"
UnhandledCaseError
"
;
}
}
const
featureDescriptions
=
[
{
name
:
"
Native
Stacks
"
value
:
"
stackwalk
"
title
:
"
Record
native
stacks
(
C
+
+
and
Rust
)
.
This
is
not
available
on
all
platforms
.
"
recommended
:
true
disabledReason
:
"
Native
stack
walking
is
not
supported
on
this
platform
.
"
}
{
name
:
"
JavaScript
"
value
:
"
js
"
title
:
"
Record
JavaScript
stack
information
and
interleave
it
with
native
stacks
.
"
recommended
:
true
}
{
name
:
"
CPU
Utilization
"
value
:
"
cpu
"
title
:
"
Record
how
much
CPU
has
been
used
between
samples
by
each
profiled
thread
.
"
recommended
:
true
}
{
name
:
"
Java
"
value
:
"
java
"
title
:
"
Profile
Java
code
"
disabledReason
:
"
This
feature
is
only
available
on
Android
.
"
}
{
name
:
"
No
Periodic
Sampling
"
value
:
"
nostacksampling
"
title
:
"
Disable
interval
-
based
stack
sampling
"
}
{
name
:
"
Main
Thread
File
IO
"
value
:
"
mainthreadio
"
title
:
"
Record
main
thread
File
I
/
O
markers
.
"
}
{
name
:
"
Profiled
Threads
File
IO
"
value
:
"
fileio
"
title
:
"
Record
File
I
/
O
markers
from
only
profiled
threads
.
"
}
{
name
:
"
All
File
IO
"
value
:
"
fileioall
"
title
:
"
Record
File
I
/
O
markers
from
all
threads
even
unregistered
threads
.
"
}
{
name
:
"
No
File
IO
Stack
Sampling
"
value
:
"
noiostacks
"
title
:
"
Do
not
sample
stacks
when
recording
File
I
/
O
markers
.
"
}
{
name
:
"
Sequential
Styling
"
value
:
"
seqstyle
"
title
:
"
Disable
parallel
traversal
in
styling
.
"
}
{
name
:
"
Screenshots
"
value
:
"
screenshots
"
title
:
"
Record
screenshots
of
all
browser
windows
.
"
}
{
name
:
"
JSTracer
"
value
:
"
jstracer
"
title
:
"
Trace
JS
engine
"
experimental
:
true
disabledReason
:
"
JS
Tracer
is
currently
disabled
due
to
crashes
.
See
Bug
1565788
.
"
}
{
name
:
"
Preference
Read
"
value
:
"
preferencereads
"
title
:
"
Track
Preference
Reads
"
}
{
name
:
"
IPC
Messages
"
value
:
"
ipcmessages
"
title
:
"
Track
IPC
messages
.
"
}
{
name
:
"
JS
Allocations
"
value
:
"
jsallocations
"
title
:
"
Track
JavaScript
allocations
"
}
{
name
:
"
Native
Allocations
"
value
:
"
nativeallocations
"
title
:
"
Track
native
allocations
"
}
{
name
:
"
Audio
Callback
Tracing
"
value
:
"
audiocallbacktracing
"
title
:
"
Trace
real
-
time
audio
callbacks
.
"
}
{
name
:
"
No
Timer
Resolution
Change
"
value
:
"
notimerresolutionchange
"
title
:
"
Do
not
enhance
the
timer
resolution
for
sampling
intervals
<
10ms
to
"
+
"
avoid
affecting
timer
-
sensitive
code
.
Warning
:
Sampling
interval
may
"
+
"
increase
in
some
processes
.
"
disabledReason
:
"
Windows
only
.
"
}
{
name
:
"
CPU
Utilization
-
All
Threads
"
value
:
"
cpuallthreads
"
title
:
"
Record
how
much
CPU
has
been
used
between
samples
by
ALL
registered
thread
.
"
experimental
:
true
}
{
name
:
"
Periodic
Sampling
-
All
Threads
"
value
:
"
samplingallthreads
"
title
:
"
Capture
stack
samples
in
ALL
registered
thread
.
"
experimental
:
true
}
{
name
:
"
Markers
-
All
Threads
"
value
:
"
markersallthreads
"
title
:
"
Record
markers
in
ALL
registered
threads
.
"
experimental
:
true
}
{
name
:
"
Unregistered
Threads
"
value
:
"
unregisteredthreads
"
title
:
"
Periodically
discover
unregistered
threads
and
record
them
and
their
"
+
"
CPU
utilization
as
markers
in
the
main
thread
-
-
Beware
:
expensive
!
"
experimental
:
true
}
{
name
:
"
Process
CPU
Utilization
"
value
:
"
processcpu
"
title
:
"
Record
how
much
CPU
has
been
used
between
samples
by
each
process
.
"
+
"
To
see
graphs
:
When
viewing
the
profile
open
the
JS
console
and
run
:
"
+
"
experimental
.
enableProcessCPUTracks
(
)
"
experimental
:
true
}
{
name
:
"
Power
Use
"
value
:
"
power
"
title
:
"
Record
the
value
of
every
energy
meter
available
on
the
system
with
"
+
"
each
sample
.
Only
available
on
Windows
11
and
Apple
Silicon
.
"
experimental
:
true
}
]
;
module
.
exports
=
{
formatFileSize
makeLinear10Scale
makePowerOf2Scale
scaleRangeWithClamping
calculateOverhead
withCommonPathPrefixRemoved
UnhandledCaseError
featureDescriptions
}
;
