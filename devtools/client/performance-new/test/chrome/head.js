"
use
strict
"
;
const
{
BrowserLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
)
;
var
{
require
}
=
BrowserLoader
(
{
baseURI
:
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
"
window
}
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
perfDescription
}
=
require
(
"
devtools
/
shared
/
specs
/
perf
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
SimpleTest
.
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
function
addPerfTest
(
asyncTest
)
{
window
.
onload
=
async
(
)
=
>
{
try
{
await
asyncTest
(
)
;
}
catch
(
e
)
{
ok
(
false
"
Got
an
error
:
"
+
DevToolsUtils
.
safeErrorString
(
e
)
)
;
}
finally
{
SimpleTest
.
finish
(
)
;
}
}
;
}
class
MockPerfFront
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
_isActive
=
false
;
this
.
_asyncQueue
=
[
]
;
this
.
_startProfilerCalls
=
[
]
;
this
.
mockIsSupported
=
true
;
this
.
mockIsLocked
=
false
;
this
.
isActive
=
this
.
_wrapInAsyncQueue
(
this
.
isActive
)
;
this
.
startProfiler
=
this
.
_wrapInAsyncQueue
(
this
.
startProfiler
)
;
this
.
stopProfilerAndDiscardProfile
=
this
.
_wrapInAsyncQueue
(
this
.
stopProfilerAndDiscardProfile
)
;
this
.
getProfileAndStopProfiler
=
this
.
_wrapInAsyncQueue
(
this
.
getProfileAndStopProfiler
)
;
}
_wrapInAsyncQueue
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
_wrapInAsyncQueue
requires
a
function
"
)
;
}
return
(
.
.
.
args
)
=
>
{
return
new
Promise
(
resolve
=
>
{
this
.
_asyncQueue
.
push
(
(
)
=
>
{
resolve
(
fn
.
apply
(
this
args
)
)
;
}
)
;
}
)
;
}
;
}
_flushAsyncQueue
(
)
{
const
pending
=
this
.
_asyncQueue
;
this
.
_asyncQueue
=
[
]
;
pending
.
forEach
(
fn
=
>
fn
(
)
)
;
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
startProfiler
(
settings
)
{
this
.
_startProfilerCalls
.
push
(
settings
)
;
this
.
_isActive
=
true
;
this
.
emit
(
"
profiler
-
started
"
)
;
}
getProfileAndStopProfiler
(
)
{
this
.
_isActive
=
false
;
this
.
emit
(
"
profiler
-
stopped
"
)
;
return
{
meta
:
{
}
libs
:
[
]
threads
:
[
]
processes
:
[
]
}
;
}
async
getSymbolTable
(
)
{
throw
new
Error
(
"
unimplemented
"
)
;
}
stopProfilerAndDiscardProfile
(
)
{
this
.
_isActive
=
false
;
this
.
emit
(
"
profiler
-
stopped
"
)
;
}
isActive
(
)
{
return
this
.
_isActive
;
}
isSupportedPlatform
(
)
{
return
this
.
mockIsSupported
;
}
isLockedForPrivateBrowsing
(
)
{
return
this
.
mockIsLocked
;
}
}
const
mockKeys
=
Object
.
getOwnPropertyNames
(
MockPerfFront
.
prototype
)
;
Object
.
getOwnPropertyNames
(
perfDescription
.
methods
)
.
forEach
(
methodName
=
>
{
if
(
!
mockKeys
.
includes
(
methodName
)
)
{
throw
new
Error
(
The
MockPerfFront
is
missing
the
method
"
{
methodName
}
"
from
the
+
"
actor
'
s
spec
.
It
should
be
added
to
the
mock
.
"
)
;
}
}
)
;
function
setReactFriendlyInputValue
(
element
value
)
{
const
valueSetter
=
Object
.
getOwnPropertyDescriptor
(
element
"
value
"
)
.
set
;
const
prototype
=
Object
.
getPrototypeOf
(
element
)
;
const
prototypeValueSetter
=
Object
.
getOwnPropertyDescriptor
(
prototype
"
value
"
)
.
set
;
if
(
valueSetter
&
&
valueSetter
!
=
=
prototypeValueSetter
)
{
prototypeValueSetter
.
call
(
element
value
)
;
}
else
{
valueSetter
.
call
(
element
value
)
;
}
element
.
dispatchEvent
(
new
Event
(
"
input
"
{
bubbles
:
true
}
)
)
;
}
function
createPerfComponent
(
)
{
const
Perf
=
require
(
"
devtools
/
client
/
performance
-
new
/
components
/
Perf
"
)
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
ReactRedux
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
createStore
=
require
(
"
devtools
/
client
/
shared
/
redux
/
create
-
store
"
)
(
)
;
const
reducers
=
require
(
"
devtools
/
client
/
performance
-
new
/
store
/
reducers
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
performance
-
new
/
store
/
actions
"
)
;
const
selectors
=
require
(
"
devtools
/
client
/
performance
-
new
/
store
/
selectors
"
)
;
const
perfFrontMock
=
new
MockPerfFront
(
)
;
const
store
=
createStore
(
reducers
)
;
const
container
=
document
.
querySelector
(
"
#
container
"
)
;
const
receiveProfileCalls
=
[
]
;
const
recordingPreferencesCalls
=
[
]
;
function
receiveProfileMock
(
profile
getSymbolTableCallback
)
{
receiveProfileCalls
.
push
(
profile
)
;
}
function
recordingPreferencesMock
(
settings
)
{
recordingPreferencesCalls
.
push
(
settings
)
;
}
function
mountComponent
(
)
{
store
.
dispatch
(
actions
.
initializeStore
(
{
perfFront
:
perfFrontMock
receiveProfile
:
receiveProfileMock
recordingSettingsFromPreferences
:
selectors
.
getRecordingSettings
(
store
.
getState
(
)
)
setRecordingPreferences
:
recordingPreferencesMock
}
)
)
;
return
ReactDOM
.
render
(
React
.
createElement
(
ReactRedux
.
Provider
{
store
}
React
.
createElement
(
Perf
)
)
container
)
;
}
async
function
mountAndInitializeComponent
(
)
{
mountComponent
(
)
;
await
perfFrontMock
.
_flushAsyncQueue
(
)
;
}
return
{
receiveProfileCalls
recordingPreferencesCalls
perfFrontMock
mountComponent
mountAndInitializeComponent
selectors
store
container
getState
:
store
.
getState
dispatch
:
store
.
dispatch
getRecordingState
:
(
)
=
>
selectors
.
getRecordingState
(
store
.
getState
(
)
)
}
;
}
