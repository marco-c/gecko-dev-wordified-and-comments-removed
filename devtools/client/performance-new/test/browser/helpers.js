"
use
strict
"
;
function
tick
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
function
createPeriodicLogger
(
)
{
let
startTime
=
Date
.
now
(
)
;
let
lastCount
=
0
;
let
lastMessage
=
null
;
return
message
=
>
{
if
(
lastMessage
=
=
=
message
)
{
const
now
=
Date
.
now
(
)
;
const
count
=
Math
.
floor
(
(
now
-
startTime
)
/
1000
)
;
if
(
count
!
=
=
lastCount
)
{
info
(
{
message
}
(
After
{
count
}
{
count
=
=
=
1
?
"
second
"
:
"
seconds
"
}
)
)
;
lastCount
=
count
;
}
}
else
{
info
(
message
)
;
startTime
=
Date
.
now
(
)
;
lastCount
=
0
;
lastMessage
=
message
;
}
}
;
}
async
function
waitUntil
(
condition
message
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
while
(
true
)
{
if
(
message
)
{
logPeriodically
(
message
)
;
}
const
result
=
condition
(
)
;
if
(
result
)
{
return
result
;
}
await
tick
(
)
;
}
}
function
getElementByLabel
(
container
label
)
{
return
waitUntil
(
(
)
=
>
container
.
querySelector
(
[
label
=
"
{
label
}
"
]
)
Trying
to
find
the
button
with
the
label
"
{
label
}
"
.
)
;
}
function
getElementByTooltip
(
container
tooltip
)
{
return
waitUntil
(
(
)
=
>
container
.
querySelector
(
[
tooltiptext
=
"
{
tooltip
}
"
]
)
Trying
to
find
the
button
with
the
tooltip
"
{
tooltip
}
"
.
)
;
}
function
getElementByXPath
(
document
path
)
{
return
document
.
evaluate
(
path
document
null
XPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
;
}
async
function
getElementFromDocumentByText
(
document
text
)
{
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
|
/
/
*
[
contains
(
aria
-
label
'
{
text
}
'
)
]
;
return
waitUntil
(
(
)
=
>
getElementByXPath
(
document
xpath
)
Trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
}
function
maybeGetElementFromDocumentByText
(
document
text
)
{
info
(
Immediately
trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
getElementByXPath
(
document
xpath
)
;
}
async
function
makeSureProfilerPopupIsEnabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
enabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
sys
.
mjs
"
)
;
if
(
!
ProfilerMenuButton
.
isInNavbar
(
)
)
{
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
devtools
.
performance
.
popup
.
feature
-
flag
"
true
]
]
}
)
;
info
(
"
>
The
menu
button
is
not
in
the
nav
bar
add
it
.
"
)
;
ProfilerMenuButton
.
addToNavbar
(
document
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
await
SimpleTest
.
promiseFocus
(
gBrowser
.
ownerGlobal
)
;
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Clean
up
after
the
test
by
disabling
the
profiler
popup
menu
button
.
"
)
;
if
(
!
ProfilerMenuButton
.
isInNavbar
(
)
)
{
throw
new
Error
(
"
Expected
the
profiler
popup
to
still
be
in
the
navbar
during
the
test
cleanup
.
"
)
;
}
ProfilerMenuButton
.
remove
(
)
;
}
)
;
}
else
{
info
(
"
>
The
menu
button
was
already
enabled
.
"
)
;
}
}
function
waitForProfilerPopupEvent
(
window
eventName
)
{
return
new
Promise
(
resolve
=
>
{
function
handleEvent
(
event
)
{
if
(
event
.
target
.
getAttribute
(
"
viewId
"
)
=
=
=
"
PanelUI
-
profiler
"
)
{
window
.
removeEventListener
(
eventName
handleEvent
)
;
resolve
(
)
;
}
}
window
.
addEventListener
(
eventName
handleEvent
)
;
}
)
;
}
async
function
_toggleOpenProfilerPopup
(
window
)
{
info
(
"
Toggle
open
the
profiler
popup
.
"
)
;
info
(
"
>
Find
the
profiler
menu
button
.
"
)
;
const
profilerDropmarker
=
window
.
document
.
getElementById
(
"
profiler
-
button
-
dropmarker
"
)
;
if
(
!
profilerDropmarker
)
{
throw
new
Error
(
"
Could
not
find
the
profiler
button
dropmarker
in
the
toolbar
.
"
)
;
}
const
popupShown
=
waitForProfilerPopupEvent
(
window
"
popupshown
"
)
;
info
(
"
>
Trigger
a
click
on
the
profiler
button
dropmarker
.
"
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
profilerDropmarker
{
}
window
)
;
if
(
profilerDropmarker
.
getAttribute
(
"
open
"
)
!
=
=
"
true
"
)
{
throw
new
Error
(
"
This
test
assumes
that
the
button
will
have
an
open
=
true
attribute
after
clicking
it
.
"
)
;
}
info
(
"
>
Wait
for
the
popup
to
be
shown
.
"
)
;
await
popupShown
;
await
tick
(
)
;
}
async
function
_closePopup
(
window
)
{
const
popupHiddenPromise
=
waitForProfilerPopupEvent
(
window
"
popuphidden
"
)
;
info
(
"
>
Trigger
an
escape
key
to
hide
the
popup
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
info
(
"
>
Wait
for
the
popup
to
be
hidden
.
"
)
;
await
popupHiddenPromise
;
await
tick
(
)
;
}
async
function
withPopupOpen
(
window
callback
)
{
await
_toggleOpenProfilerPopup
(
window
)
;
await
callback
(
)
;
await
_closePopup
(
window
)
;
}
async
function
openPopupAndEnsureCloses
(
window
callback
)
{
await
_toggleOpenProfilerPopup
(
window
)
;
const
popupHiddenPromise
=
waitForProfilerPopupEvent
(
window
"
popuphidden
"
)
;
await
callback
(
)
;
info
(
"
>
Verifying
that
the
popup
was
closed
by
the
test
.
"
)
;
await
popupHiddenPromise
;
}
function
setProfilerFrontendUrl
(
origin
pathname
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
origin
]
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
-
path
"
pathname
]
]
}
)
;
}
async
function
checkTabLoadedProfile
(
{
initialTitle
successTitle
errorTitle
}
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
"
Attempting
to
see
if
the
selected
tab
can
receive
a
profile
.
"
)
;
return
waitUntil
(
(
)
=
>
{
switch
(
gBrowser
.
selectedTab
.
label
)
{
case
initialTitle
:
logPeriodically
(
>
Waiting
for
the
profile
to
be
received
.
)
;
return
false
;
case
successTitle
:
ok
(
true
"
The
profile
was
successfully
injected
to
the
page
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
return
true
;
case
errorTitle
:
throw
new
Error
(
"
The
fake
frontend
indicated
that
there
was
an
error
injecting
the
profile
.
"
)
;
default
:
logPeriodically
(
>
Waiting
for
the
fake
frontend
tab
to
be
loaded
.
)
;
return
false
;
}
}
)
;
}
async
function
waitForTabUrl
(
{
initialTitle
successTitle
errorTitle
expectedUrl
}
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
Waiting
for
the
selected
tab
to
have
the
url
"
{
expectedUrl
}
"
.
)
;
return
waitUntil
(
(
)
=
>
{
switch
(
gBrowser
.
selectedTab
.
label
)
{
case
initialTitle
:
case
successTitle
:
if
(
gBrowser
.
currentURI
.
spec
=
=
=
expectedUrl
)
{
ok
(
true
The
selected
tab
has
the
url
{
expectedUrl
}
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
return
true
;
}
throw
new
Error
(
Found
a
different
url
on
the
fake
frontend
:
{
gBrowser
.
currentURI
.
spec
}
(
expecting
{
expectedUrl
}
)
)
;
case
errorTitle
:
throw
new
Error
(
"
The
fake
frontend
indicated
that
there
was
an
error
injecting
the
profile
.
"
)
;
default
:
logPeriodically
(
>
Waiting
for
the
fake
frontend
tab
to
be
loaded
.
)
;
return
false
;
}
}
)
;
}
async
function
waitForTabTitle
(
title
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
Waiting
for
the
selected
tab
to
have
the
title
"
{
title
}
"
.
)
;
return
waitUntil
(
(
)
=
>
{
if
(
gBrowser
.
selectedTab
.
label
=
=
=
title
)
{
ok
(
true
The
selected
tab
has
the
title
{
title
}
)
;
return
true
;
}
logPeriodically
(
>
Waiting
for
the
tab
title
to
change
.
)
;
return
false
;
}
)
;
}
function
withAboutProfiling
(
callback
)
{
info
(
"
Begin
to
open
about
:
profiling
in
a
new
tab
.
"
)
;
return
BrowserTestUtils
.
withNewTab
(
"
about
:
profiling
"
async
contentBrowser
=
>
{
info
(
"
about
:
profiling
is
now
open
in
a
tab
.
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentBrowser
.
contentDocument
.
getElementById
(
"
root
"
)
.
firstElementChild
"
Document
'
s
root
has
been
populated
"
)
;
return
callback
(
contentBrowser
.
contentDocument
)
;
}
)
;
}
async
function
withDevToolsPanel
(
url
callback
aWindow
=
window
)
{
if
(
typeof
url
=
=
=
"
function
"
)
{
aWindow
=
callback
?
?
window
;
callback
=
url
;
url
=
"
about
:
blank
"
;
}
const
{
gBrowser
}
=
aWindow
;
const
{
gDevTools
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
.
js
"
)
;
info
(
Create
a
new
tab
with
url
"
{
url
}
"
.
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
info
(
"
Begin
to
open
the
DevTools
and
the
performance
-
new
panel
.
"
)
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
performance
"
}
)
;
const
{
document
}
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
info
(
"
The
performance
-
new
panel
is
now
open
and
ready
to
use
.
"
)
;
await
callback
(
document
tab
.
linkedBrowser
.
contentDocument
)
;
info
(
"
About
to
remove
the
about
:
blank
tab
"
)
;
await
toolbox
.
destroy
(
)
;
await
TestUtils
.
waitForTick
(
)
;
const
waitForClosingPromise
=
BrowserTestUtils
.
waitForTabClosing
(
tab
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
info
(
"
Requested
closing
the
about
:
blank
tab
waiting
.
.
.
"
)
;
await
waitForClosingPromise
;
info
(
"
The
about
:
blank
tab
is
now
removed
.
"
)
;
}
function
getActiveConfiguration
(
)
{
const
BackgroundJSM
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
shared
/
background
.
sys
.
mjs
"
)
;
const
{
startProfiler
stopProfiler
}
=
BackgroundJSM
;
info
(
"
Start
the
profiler
with
the
current
about
:
profiling
configuration
.
"
)
;
startProfiler
(
"
aboutprofiling
"
)
;
Services
.
profiler
.
Pause
(
)
;
const
{
activeConfiguration
}
=
Services
.
profiler
;
if
(
!
activeConfiguration
)
{
throw
new
Error
(
"
Expected
to
find
an
active
configuration
for
the
profile
.
"
)
;
}
info
(
"
Stop
the
profiler
after
getting
the
active
configuration
.
"
)
;
stopProfiler
(
)
;
return
activeConfiguration
;
}
function
activeConfigurationHasFeature
(
feature
)
{
const
{
features
}
=
getActiveConfiguration
(
)
;
return
features
.
includes
(
feature
)
;
}
function
activeConfigurationHasThread
(
thread
)
{
const
{
threads
}
=
getActiveConfiguration
(
)
;
return
threads
.
includes
(
thread
)
;
}
async
function
devToolsActiveConfigurationHasFeature
(
document
feature
)
{
info
(
"
Get
the
active
configuration
of
the
profiler
via
user
driven
events
.
"
)
;
const
start
=
await
getActiveButtonFromText
(
document
"
Start
recording
"
)
;
info
(
"
Click
the
button
to
start
recording
.
"
)
;
start
.
click
(
)
;
const
cancel
=
await
getActiveButtonFromText
(
document
"
Cancel
recording
"
)
;
const
{
activeConfiguration
}
=
Services
.
profiler
;
if
(
!
activeConfiguration
)
{
throw
new
Error
(
"
Expected
to
find
an
active
configuration
for
the
profile
.
"
)
;
}
info
(
"
Click
the
cancel
button
to
discard
the
profile
.
.
"
)
;
cancel
.
click
(
)
;
await
getActiveButtonFromText
(
document
"
Start
recording
"
)
;
return
activeConfiguration
.
features
.
includes
(
feature
)
;
}
function
_adaptCustomPresetExpectationToCustomBuild
(
fixture
)
{
const
supportedFeatures
=
Services
.
profiler
.
GetFeatures
(
)
;
info
(
"
Supported
features
are
:
"
+
supportedFeatures
.
join
(
"
"
)
)
;
if
(
!
supportedFeatures
.
includes
(
"
stackwalk
"
)
)
{
info
(
"
Supported
features
do
not
include
stackwalk
let
'
s
remove
the
Native
Stacks
from
the
expected
output
.
"
)
;
fixture
=
fixture
.
replace
(
/
^
.
*
Native
Stacks
.
*
\
n
/
m
"
"
)
;
}
return
fixture
;
}
function
getDevtoolsCustomPresetContent
(
devtoolsDocument
)
{
return
devtoolsDocument
.
querySelector
(
"
.
perf
-
presets
-
custom
"
)
.
innerText
;
}
function
checkDevtoolsCustomPresetContent
(
devtoolsDocument
fixture
)
{
fixture
=
fixture
.
replace
(
/
^
\
s
+
/
gm
"
"
)
.
trim
(
)
;
fixture
=
_adaptCustomPresetExpectationToCustomBuild
(
fixture
)
;
is
(
getDevtoolsCustomPresetContent
(
devtoolsDocument
)
fixture
)
;
}
async
function
getNearestInputFromText
(
document
text
)
{
const
textElement
=
await
getElementFromDocumentByText
(
document
text
)
;
if
(
textElement
.
control
)
{
return
textElement
.
control
;
}
let
next
=
textElement
;
while
(
(
next
=
next
.
parentElement
)
)
{
const
input
=
next
.
querySelector
(
"
input
select
"
)
;
if
(
input
)
{
return
input
;
}
}
throw
new
Error
(
"
Could
not
find
an
input
or
select
near
the
text
element
.
"
)
;
}
async
function
getActiveButtonFromText
(
document
text
)
{
let
button
=
await
getElementFromDocumentByText
(
document
text
)
;
while
(
button
.
tagName
!
=
=
"
button
"
)
{
button
=
button
.
parentElement
;
if
(
!
button
)
{
throw
new
Error
(
Unable
to
find
a
button
from
the
text
"
{
text
}
"
)
;
}
}
await
waitUntil
(
(
)
=
>
!
button
.
disabled
"
Waiting
until
the
button
is
not
disabled
.
"
)
;
return
button
;
}
async
function
waitForProfilerMenuButton
(
)
{
info
(
"
Checking
if
the
profiler
menu
button
is
enabled
.
"
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
}
async
function
makeSureProfilerPopupIsDisabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
dsiabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
module
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
sys
.
mjs
"
)
;
const
isOriginallyInNavBar
=
ProfilerMenuButton
.
isInNavbar
(
)
;
if
(
isOriginallyInNavBar
)
{
info
(
"
>
The
menu
button
is
in
the
navbar
remove
it
for
this
test
.
"
)
;
ProfilerMenuButton
.
remove
(
)
;
}
else
{
info
(
"
>
The
menu
button
was
not
in
the
navbar
yet
.
"
)
;
}
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Revert
the
profiler
menu
button
to
be
back
in
its
original
place
"
)
;
if
(
isOriginallyInNavBar
!
=
=
ProfilerMenuButton
.
isInNavbar
(
)
)
{
ProfilerMenuButton
.
remove
(
)
;
}
}
)
;
}
function
withWebChannelTestDocument
(
callback
)
{
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
performance
-
new
/
test
/
browser
/
webchannel
.
html
"
}
callback
)
;
}
function
setNativeValue
(
element
value
)
{
const
{
set
:
valueSetter
}
=
Object
.
getOwnPropertyDescriptor
(
element
"
value
"
)
|
|
{
}
;
const
prototype
=
Object
.
getPrototypeOf
(
element
)
;
const
{
set
:
prototypeValueSetter
}
=
Object
.
getOwnPropertyDescriptor
(
prototype
"
value
"
)
|
|
{
}
;
if
(
prototypeValueSetter
&
&
valueSetter
!
=
=
prototypeValueSetter
)
{
prototypeValueSetter
.
call
(
element
value
)
;
}
else
{
if
(
valueSetter
)
{
valueSetter
.
call
(
element
value
)
;
}
else
{
throw
new
Error
(
"
The
given
element
does
not
have
a
value
setter
"
)
;
}
}
}
function
setReactFriendlyInputValue
(
input
value
)
{
setNativeValue
(
input
value
)
;
input
.
dispatchEvent
(
new
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
function
setupGetRecordingState
(
document
)
{
const
selectors
=
require
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
store
/
selectors
.
js
"
)
;
const
store
=
document
.
defaultView
.
gStore
;
if
(
!
store
)
{
throw
new
Error
(
"
Could
not
find
the
redux
store
on
the
window
object
.
"
)
;
}
return
(
)
=
>
selectors
.
getRecordingState
(
store
.
getState
(
)
)
;
}
