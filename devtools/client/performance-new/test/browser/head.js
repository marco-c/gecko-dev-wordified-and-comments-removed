"
use
strict
"
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
function
tick
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
function
createPeriodicLogger
(
)
{
let
startTime
=
Date
.
now
(
)
;
let
lastCount
=
0
;
let
lastMessage
=
null
;
return
message
=
>
{
if
(
lastMessage
=
=
=
message
)
{
const
now
=
Date
.
now
(
)
;
const
count
=
Math
.
floor
(
(
now
-
startTime
)
/
1000
)
;
if
(
count
!
=
=
lastCount
)
{
info
(
{
message
}
(
After
{
count
}
{
count
=
=
=
1
?
"
second
"
:
"
seconds
"
}
)
)
;
lastCount
=
count
;
}
}
else
{
info
(
message
)
;
startTime
=
Date
.
now
(
)
;
lastCount
=
0
;
lastMessage
=
message
;
}
}
;
}
async
function
waitUntil
(
condition
message
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
while
(
true
)
{
if
(
message
)
{
logPeriodically
(
message
)
;
}
const
result
=
condition
(
)
;
if
(
result
)
{
return
result
;
}
await
tick
(
)
;
}
}
function
getElementByLabel
(
document
label
)
{
return
waitUntil
(
(
)
=
>
document
.
querySelector
(
[
label
=
"
{
label
}
"
]
)
Trying
to
find
the
button
with
the
label
"
{
label
}
"
.
)
;
}
function
getElementByXPath
(
document
path
)
{
return
document
.
evaluate
(
path
document
null
XPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
;
}
async
function
getElementFromDocumentByText
(
document
text
)
{
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
waitUntil
(
(
)
=
>
getElementByXPath
(
document
xpath
)
Trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
}
function
maybeGetElementFromDocumentByText
(
document
text
)
{
info
(
Immediately
trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
getElementByXPath
(
document
xpath
)
;
}
function
getIframeDocument
(
)
{
const
iframe
=
document
.
getElementById
(
"
PanelUI
-
profilerIframe
"
)
;
if
(
!
iframe
)
{
throw
new
Error
(
"
This
function
assumes
the
profiler
iframe
is
already
present
.
"
)
;
}
return
iframe
.
contentDocument
;
}
async
function
makeSureProfilerPopupIsEnabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
enabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
if
(
!
ProfilerMenuButton
.
isEnabled
(
)
)
{
info
(
"
>
The
menu
button
is
not
enabled
turn
it
on
.
"
)
;
ProfilerMenuButton
.
toggle
(
document
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
await
SimpleTest
.
promiseFocus
(
gBrowser
.
ownerGlobal
)
;
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Clean
up
after
the
test
by
disabling
the
profiler
popup
menu
button
.
"
)
;
if
(
!
ProfilerMenuButton
.
isEnabled
(
)
)
{
throw
new
Error
(
"
Expected
the
profiler
popup
to
still
be
enabled
during
the
test
cleanup
.
"
)
;
}
ProfilerMenuButton
.
toggle
(
document
)
;
}
)
;
}
else
{
info
(
"
>
The
menu
button
was
already
enabled
.
"
)
;
}
}
async
function
toggleOpenProfilerPopup
(
)
{
info
(
"
Toggle
open
the
profiler
popup
.
"
)
;
info
(
"
>
Find
the
profiler
menu
button
.
"
)
;
const
profilerButton
=
document
.
getElementById
(
"
profiler
-
button
"
)
;
if
(
!
profilerButton
)
{
throw
new
Error
(
"
Could
not
find
the
profiler
button
in
the
menu
.
"
)
;
}
info
(
"
>
Trigger
a
click
on
the
profiler
menu
button
.
"
)
;
profilerButton
.
click
(
)
;
await
tick
(
)
;
}
function
setProfilerFrontendUrl
(
url
)
{
info
(
"
Setting
the
profiler
URL
to
the
fake
frontend
.
Note
that
this
doesn
'
t
currently
"
+
"
support
the
WebChannels
so
expect
a
few
error
messages
about
the
WebChannel
"
+
"
URLs
not
being
correct
.
"
)
;
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
url
]
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
-
path
"
"
"
]
]
}
)
;
}
async
function
checkTabLoadedProfile
(
{
initialTitle
successTitle
errorTitle
}
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
"
Attempting
to
see
if
the
selected
tab
can
receive
a
profile
.
"
)
;
return
waitUntil
(
(
)
=
>
{
switch
(
gBrowser
.
selectedTab
.
textContent
)
{
case
initialTitle
:
logPeriodically
(
>
Waiting
for
the
profile
to
be
received
.
)
;
return
false
;
case
successTitle
:
ok
(
true
"
The
profile
was
successfully
injected
to
the
page
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
return
true
;
case
errorTitle
:
throw
new
Error
(
"
The
fake
frontend
indicated
that
there
was
an
error
injecting
the
profile
.
"
)
;
default
:
logPeriodically
(
>
Waiting
for
the
fake
frontend
tab
to
be
loaded
.
)
;
return
false
;
}
}
)
;
}
async
function
waitForTabTitle
(
title
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
Waiting
for
the
selected
tab
to
have
the
title
"
{
title
}
"
.
)
;
return
waitUntil
(
(
)
=
>
{
if
(
gBrowser
.
selectedTab
.
textContent
=
=
=
title
)
{
ok
(
true
The
selected
tab
has
the
title
{
title
}
)
;
return
true
;
}
logPeriodically
(
>
Waiting
for
the
tab
title
to
change
.
)
;
return
false
;
}
)
;
}
async
function
closePopup
(
)
{
const
iframe
=
document
.
querySelector
(
"
#
PanelUI
-
profilerIframe
"
)
;
if
(
!
iframe
)
{
throw
new
Error
(
"
Could
not
find
the
profiler
iframe
when
attempting
to
close
the
popup
.
Was
it
"
+
"
already
closed
?
"
)
;
}
const
panel
=
iframe
.
closest
(
"
panel
"
)
;
if
(
!
panel
)
{
throw
new
Error
(
"
Could
not
find
the
closest
panel
to
the
profiler
'
s
iframe
.
"
)
;
}
info
(
"
Hide
the
profiler
popup
.
"
)
;
panel
.
hidePopup
(
)
;
info
(
"
Wait
for
the
profiler
popup
to
be
completely
hidden
.
"
)
;
while
(
true
)
{
if
(
!
iframe
.
ownerDocument
.
contains
(
iframe
)
)
{
info
(
"
The
iframe
was
removed
.
"
)
;
return
;
}
await
tick
(
)
;
}
}
function
withAboutProfiling
(
callback
)
{
info
(
"
Begin
to
open
about
:
profiling
in
a
new
tab
.
"
)
;
return
BrowserTestUtils
.
withNewTab
(
"
about
:
profiling
"
async
contentBrowser
=
>
{
info
(
"
about
:
profiling
is
now
open
in
a
tab
.
"
)
;
return
callback
(
contentBrowser
.
contentDocument
)
;
}
)
;
}
async
function
withDevToolsPanel
(
callback
)
{
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
devtools
.
performance
.
new
-
panel
-
enabled
"
"
true
"
]
]
}
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
info
(
"
Create
a
new
about
:
blank
tab
.
"
)
;
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
info
(
"
Begin
to
open
the
DevTools
and
the
performance
-
new
panel
.
"
)
;
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
performance
"
)
;
const
{
document
}
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
;
info
(
"
The
performance
-
new
panel
is
now
open
and
ready
to
use
.
"
)
;
await
callback
(
document
)
;
info
(
"
About
to
remove
the
about
:
blank
tab
"
)
;
await
toolbox
.
destroy
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
info
(
"
The
about
:
blank
tab
is
now
removed
.
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
500
)
)
;
}
function
getActiveConfiguration
(
)
{
const
{
startProfiler
stopProfiler
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
background
.
jsm
.
js
"
)
;
info
(
"
Start
the
profiler
with
the
current
about
:
profiling
configuration
.
"
)
;
startProfiler
(
"
aboutprofiling
"
)
;
Services
.
profiler
.
PauseSampling
(
)
;
const
{
activeConfiguration
}
=
Services
.
profiler
;
if
(
!
activeConfiguration
)
{
throw
new
Error
(
"
Expected
to
find
an
active
configuration
for
the
profile
.
"
)
;
}
info
(
"
Stop
the
profiler
after
getting
the
active
configuration
.
"
)
;
stopProfiler
(
)
;
return
activeConfiguration
;
}
function
activeConfigurationHasFeature
(
feature
)
{
const
{
features
}
=
getActiveConfiguration
(
)
;
return
features
.
includes
(
feature
)
;
}
function
activeConfigurationHasThread
(
thread
)
{
const
{
threads
}
=
getActiveConfiguration
(
)
;
return
threads
.
includes
(
thread
)
;
}
async
function
devToolsActiveConfigurationHasFeature
(
document
feature
)
{
info
(
"
Get
the
active
configuration
of
the
profiler
via
user
driven
events
.
"
)
;
const
start
=
await
getActiveButtonFromText
(
document
"
Start
recording
"
)
;
info
(
"
Click
the
button
to
start
recording
.
"
)
;
start
.
click
(
)
;
const
cancel
=
await
getActiveButtonFromText
(
document
"
Cancel
recording
"
)
;
const
{
activeConfiguration
}
=
Services
.
profiler
;
if
(
!
activeConfiguration
)
{
throw
new
Error
(
"
Expected
to
find
an
active
configuration
for
the
profile
.
"
)
;
}
info
(
"
Click
the
cancel
button
to
discard
the
profile
.
.
"
)
;
cancel
.
click
(
)
;
await
getActiveButtonFromText
(
document
"
Start
recording
"
)
;
return
activeConfiguration
.
features
.
includes
(
feature
)
;
}
async
function
getNearestInputFromText
(
document
text
)
{
const
textElement
=
await
getElementFromDocumentByText
(
document
text
)
;
if
(
textElement
.
control
)
{
return
textElement
.
control
;
}
let
next
=
textElement
;
while
(
(
next
=
next
.
parentElement
)
)
{
const
input
=
next
.
querySelector
(
"
input
select
"
)
;
if
(
input
)
{
return
input
;
}
}
throw
new
Error
(
"
Could
not
find
an
input
or
select
near
the
text
element
.
"
)
;
}
async
function
getActiveButtonFromText
(
document
text
)
{
let
button
=
await
getElementFromDocumentByText
(
document
text
)
;
while
(
button
.
tagName
!
=
=
"
button
"
)
{
button
=
button
.
parentElement
;
if
(
!
button
)
{
throw
new
Error
(
Unable
to
find
a
button
from
the
text
"
{
text
}
"
)
;
}
}
await
waitUntil
(
(
)
=
>
!
button
.
disabled
"
Waiting
until
the
button
is
not
disabled
.
"
)
;
return
button
;
}
async
function
waitForProfilerMenuButton
(
)
{
info
(
"
Checking
if
the
profiler
menu
button
is
enabled
.
"
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
}
async
function
makeSureProfilerPopupIsDisabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
dsiabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
module
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
const
originallyIsEnabled
=
ProfilerMenuButton
.
isEnabled
(
)
;
if
(
originallyIsEnabled
)
{
info
(
"
>
The
menu
button
is
enabled
turn
it
off
for
this
test
.
"
)
;
ProfilerMenuButton
.
toggle
(
document
)
;
}
else
{
info
(
"
>
The
menu
button
was
already
disabled
.
"
)
;
}
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Revert
the
profiler
menu
button
to
its
original
enabled
state
.
"
)
;
if
(
originallyIsEnabled
!
=
=
ProfilerMenuButton
.
isEnabled
(
)
)
{
ProfilerMenuButton
.
toggle
(
document
)
;
}
}
)
;
}
function
withWebChannelTestDocument
(
callback
)
{
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
performance
-
new
/
test
/
browser
/
webchannel
.
html
"
}
callback
)
;
}
function
setReactFriendlyInputValue
(
input
value
)
{
const
previousValue
=
input
.
value
;
input
.
value
=
value
;
const
tracker
=
input
.
_valueTracker
;
if
(
tracker
)
{
tracker
.
setValue
(
previousValue
)
;
}
input
.
dispatchEvent
(
new
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
function
setupGetRecordingState
(
document
)
{
const
selectors
=
require
(
"
devtools
/
client
/
performance
-
new
/
store
/
selectors
"
)
;
const
store
=
document
.
defaultView
.
gStore
;
if
(
!
store
)
{
throw
new
Error
(
"
Could
not
find
the
redux
store
on
the
window
object
.
"
)
;
}
return
(
)
=
>
selectors
.
getRecordingState
(
store
.
getState
(
)
)
;
}
