"
use
strict
"
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
function
tick
(
)
{
return
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
function
createPeriodicLogger
(
)
{
let
startTime
=
Date
.
now
(
)
;
let
lastCount
=
0
;
let
lastMessage
=
null
;
return
message
=
>
{
if
(
lastMessage
=
=
=
message
)
{
const
now
=
Date
.
now
(
)
;
const
count
=
Math
.
floor
(
(
now
-
startTime
)
/
1000
)
;
if
(
count
!
=
=
lastCount
)
{
info
(
{
message
}
(
After
{
count
}
{
count
=
=
=
1
?
"
second
"
:
"
seconds
"
}
)
)
;
lastCount
=
count
;
}
}
else
{
info
(
message
)
;
startTime
=
Date
.
now
(
)
;
lastCount
=
0
;
lastMessage
=
message
;
}
}
;
}
async
function
waitUntil
(
condition
message
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
while
(
true
)
{
if
(
message
)
{
logPeriodically
(
message
)
;
}
const
result
=
condition
(
)
;
if
(
result
)
{
return
result
;
}
await
tick
(
)
;
}
}
function
getElementByXPath
(
document
path
)
{
return
document
.
evaluate
(
path
document
null
XPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
;
}
async
function
getElementFromPopupByText
(
text
)
{
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
waitUntil
(
(
)
=
>
{
const
iframe
=
document
.
getElementById
(
"
PanelUI
-
profilerIframe
"
)
;
if
(
iframe
)
{
return
getElementByXPath
(
iframe
.
contentDocument
xpath
)
;
}
return
null
;
}
Trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
}
async
function
getElementFromDocumentByText
(
document
text
)
{
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
waitUntil
(
(
)
=
>
getElementByXPath
(
document
xpath
)
Trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
}
function
maybeGetElementFromPopupByText
(
text
)
{
info
(
Immediately
trying
to
find
the
element
with
the
text
"
{
text
}
"
.
)
;
const
xpath
=
/
/
*
[
contains
(
text
(
)
'
{
text
}
'
)
]
;
return
getElementByXPath
(
getIframeDocument
(
)
xpath
)
;
}
function
getIframeDocument
(
)
{
const
iframe
=
document
.
getElementById
(
"
PanelUI
-
profilerIframe
"
)
;
if
(
!
iframe
)
{
throw
new
Error
(
"
This
function
assumes
the
profiler
iframe
is
already
present
.
"
)
;
}
return
iframe
.
contentDocument
;
}
async
function
makeSureProfilerPopupIsEnabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
enabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
if
(
!
ProfilerMenuButton
.
isEnabled
(
)
)
{
info
(
"
>
The
menu
button
is
not
enabled
turn
it
on
.
"
)
;
ProfilerMenuButton
.
toggle
(
document
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
await
SimpleTest
.
promiseFocus
(
gBrowser
.
ownerGlobal
)
;
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Clean
up
after
the
test
by
disabling
the
profiler
popup
menu
button
.
"
)
;
if
(
!
ProfilerMenuButton
.
isEnabled
(
)
)
{
throw
new
Error
(
"
Expected
the
profiler
popup
to
still
be
enabled
during
the
test
cleanup
.
"
)
;
}
ProfilerMenuButton
.
toggle
(
document
)
;
}
)
;
}
else
{
info
(
"
>
The
menu
button
was
already
enabled
.
"
)
;
}
}
function
toggleOpenProfilerPopup
(
)
{
info
(
"
Toggle
open
the
profiler
popup
.
"
)
;
info
(
"
>
Find
the
profiler
menu
button
.
"
)
;
const
profilerButton
=
document
.
getElementById
(
"
profiler
-
button
"
)
;
if
(
!
profilerButton
)
{
throw
new
Error
(
"
Could
not
find
the
profiler
button
in
the
menu
.
"
)
;
}
info
(
"
>
Trigger
a
click
on
the
profiler
menu
button
.
"
)
;
profilerButton
.
click
(
)
;
}
function
setProfilerFrontendUrl
(
url
)
{
info
(
"
Setting
the
profiler
URL
to
the
fake
frontend
.
"
)
;
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
url
]
[
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
-
path
"
"
"
]
]
}
)
;
}
async
function
checkTabLoadedProfile
(
{
initialTitle
successTitle
errorTitle
}
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
"
Attempting
to
see
if
the
selected
tab
can
receive
a
profile
.
"
)
;
return
waitUntil
(
(
)
=
>
{
switch
(
gBrowser
.
selectedTab
.
textContent
)
{
case
initialTitle
:
logPeriodically
(
>
Waiting
for
the
profile
to
be
received
.
)
;
return
false
;
case
successTitle
:
ok
(
true
"
The
profile
was
successfully
injected
to
the
page
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
return
true
;
case
errorTitle
:
throw
new
Error
(
"
The
fake
frontend
indicated
that
there
was
an
error
injecting
the
profile
.
"
)
;
default
:
logPeriodically
(
>
Waiting
for
the
fake
frontend
tab
to
be
loaded
.
)
;
return
false
;
}
}
)
;
}
async
function
waitForTabTitle
(
title
)
{
const
logPeriodically
=
createPeriodicLogger
(
)
;
info
(
Waiting
for
the
selected
tab
to
have
the
title
"
{
title
}
"
.
)
;
return
waitUntil
(
(
)
=
>
{
if
(
gBrowser
.
selectedTab
.
textContent
=
=
=
title
)
{
ok
(
true
The
selected
tab
has
the
title
{
title
}
)
;
return
true
;
}
logPeriodically
(
>
Waiting
for
the
tab
title
to
change
.
)
;
return
false
;
}
)
;
}
async
function
closePopup
(
)
{
const
iframe
=
document
.
querySelector
(
"
#
PanelUI
-
profilerIframe
"
)
;
if
(
!
iframe
)
{
throw
new
Error
(
"
Could
not
find
the
profiler
iframe
when
attempting
to
close
the
popup
.
Was
it
"
+
"
already
closed
?
"
)
;
}
const
panel
=
iframe
.
closest
(
"
panel
"
)
;
if
(
!
panel
)
{
throw
new
Error
(
"
Could
not
find
the
closest
panel
to
the
profiler
'
s
iframe
.
"
)
;
}
info
(
"
Hide
the
profiler
popup
.
"
)
;
panel
.
hidePopup
(
)
;
info
(
"
Wait
for
the
profiler
popup
to
be
completely
hidden
.
"
)
;
while
(
true
)
{
if
(
!
iframe
.
ownerDocument
.
contains
(
iframe
)
)
{
info
(
"
The
iframe
was
removed
.
"
)
;
return
;
}
await
tick
(
)
;
}
}
function
openAboutProfiling
(
callback
)
{
info
(
"
Begin
to
open
about
:
profiling
in
a
new
tab
.
"
)
;
return
BrowserTestUtils
.
withNewTab
(
"
about
:
profiling
"
async
contentBrowser
=
>
{
info
(
"
about
:
profiling
is
now
open
in
a
tab
.
"
)
;
return
callback
(
contentBrowser
.
contentDocument
)
;
}
)
;
}
function
getActiveConfiguration
(
)
{
const
{
startProfiler
stopProfiler
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
background
.
jsm
.
js
"
)
;
info
(
"
Start
the
profiler
with
the
current
about
:
profiling
configuration
.
"
)
;
startProfiler
(
)
;
Services
.
profiler
.
PauseSampling
(
)
;
const
{
activeConfiguration
}
=
Services
.
profiler
;
if
(
!
activeConfiguration
)
{
throw
new
Error
(
"
Expected
to
find
an
active
configuration
for
the
profile
.
"
)
;
}
info
(
"
Stop
the
profiler
after
getting
the
active
configuration
.
"
)
;
stopProfiler
(
)
;
return
activeConfiguration
;
}
function
activeConfigurationHasFeature
(
feature
)
{
const
{
features
}
=
getActiveConfiguration
(
)
;
return
features
.
includes
(
feature
)
;
}
function
activeConfigurationHasThread
(
thread
)
{
const
{
threads
}
=
getActiveConfiguration
(
)
;
return
threads
.
includes
(
thread
)
;
}
async
function
getNearestInputFromText
(
document
text
)
{
const
textElement
=
await
getElementFromDocumentByText
(
document
text
)
;
if
(
textElement
.
control
)
{
return
textElement
.
control
;
}
let
next
=
textElement
;
while
(
(
next
=
next
.
parentElement
)
)
{
const
input
=
next
.
querySelector
(
"
input
"
)
;
if
(
input
)
{
return
input
;
}
}
throw
new
Error
(
"
Could
not
find
an
input
near
text
element
.
"
)
;
}
async
function
waitForProfilerMenuButton
(
)
{
info
(
"
Checking
if
the
profiler
menu
button
is
enabled
.
"
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
ownerDocument
.
getElementById
(
"
profiler
-
button
"
)
"
>
Waiting
until
the
profiler
button
is
added
to
the
browser
.
"
)
;
}
async
function
makeSureProfilerPopupIsDisabled
(
)
{
info
(
"
Make
sure
the
profiler
popup
is
dsiabled
.
"
)
;
info
(
"
>
Load
the
profiler
menu
button
module
.
"
)
;
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
const
originallyIsEnabled
=
ProfilerMenuButton
.
isEnabled
(
)
;
if
(
originallyIsEnabled
)
{
info
(
"
>
The
menu
button
is
enabled
turn
it
off
for
this
test
.
"
)
;
ProfilerMenuButton
.
toggle
(
document
)
;
}
else
{
info
(
"
>
The
menu
button
was
already
disabled
.
"
)
;
}
registerCleanupFunction
(
(
)
=
>
{
info
(
"
Revert
the
profiler
menu
button
to
its
original
enabled
state
.
"
)
;
if
(
originallyIsEnabled
!
=
=
ProfilerMenuButton
.
isEnabled
(
)
)
{
ProfilerMenuButton
.
toggle
(
document
)
;
}
}
)
;
}
function
withWebChannelTestDocument
(
callback
)
{
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
performance
-
new
/
test
/
browser
/
webchannel
.
html
"
}
callback
)
;
}
