"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Task
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
extend
"
"
sdk
/
util
/
object
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Actors
"
"
devtools
/
shared
/
performance
/
legacy
/
actors
"
)
;
loader
.
lazyRequireGetter
(
this
"
LegacyPerformanceRecording
"
"
devtools
/
shared
/
performance
/
legacy
/
recording
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
importRecording
"
"
devtools
/
shared
/
performance
/
legacy
/
recording
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
normalizePerformanceFeatures
"
"
devtools
/
shared
/
performance
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
getDeviceFront
"
"
devtools
/
server
/
actors
/
device
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getSystemInfo
"
"
devtools
/
shared
/
shared
/
system
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventTarget
"
"
sdk
/
event
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Class
"
"
sdk
/
core
/
heritage
"
true
)
;
const
LegacyPerformanceFront
=
Class
(
{
extends
:
EventTarget
LEGACY_FRONT
:
true
traits
:
{
features
:
{
withMarkers
:
true
withTicks
:
true
withMemory
:
false
withAllocations
:
false
withJITOptimizations
:
false
}
}
initialize
:
function
(
target
)
{
let
{
form
client
}
=
target
;
this
.
_target
=
target
;
this
.
_form
=
form
;
this
.
_client
=
client
;
this
.
_pendingConsoleRecordings
=
[
]
;
this
.
_sitesPullTimeout
=
0
;
this
.
_recordings
=
[
]
;
this
.
_pipeToFront
=
this
.
_pipeToFront
.
bind
(
this
)
;
this
.
_onTimelineData
=
this
.
_onTimelineData
.
bind
(
this
)
;
this
.
_onConsoleProfileStart
=
this
.
_onConsoleProfileStart
.
bind
(
this
)
;
this
.
_onConsoleProfileStop
=
this
.
_onConsoleProfileStop
.
bind
(
this
)
;
this
.
_onProfilerStatus
=
this
.
_onProfilerStatus
.
bind
(
this
)
;
this
.
_onProfilerUnexpectedlyStopped
=
this
.
_onProfilerUnexpectedlyStopped
.
bind
(
this
)
;
}
connect
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_connecting
)
{
return
this
.
_connecting
.
promise
;
}
this
.
_connecting
=
promise
.
defer
(
)
;
yield
this
.
_connectActors
(
)
;
yield
this
.
_registerListeners
(
)
;
this
.
_connecting
.
resolve
(
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_connecting
)
{
yield
this
.
_connecting
.
promise
;
}
else
{
return
;
}
yield
this
.
_unregisterListeners
(
)
;
yield
this
.
_disconnectActors
(
)
;
this
.
_connecting
=
null
;
this
.
_profiler
=
null
;
this
.
_timeline
=
null
;
this
.
_client
=
null
;
this
.
_form
=
null
;
this
.
_target
=
this
.
_target
;
}
)
_connectActors
:
Task
.
async
(
function
*
(
)
{
this
.
_profiler
=
new
Actors
.
LegacyProfilerFront
(
this
.
_target
)
;
this
.
_timeline
=
new
Actors
.
LegacyTimelineFront
(
this
.
_target
)
;
yield
promise
.
all
(
[
this
.
_profiler
.
connect
(
)
this
.
_timeline
.
connect
(
)
]
)
;
this
.
traits
.
features
.
withMarkers
=
!
this
.
_timeline
.
IS_MOCK
;
this
.
traits
.
features
.
withTicks
=
!
this
.
_timeline
.
IS_MOCK
;
}
)
_registerListeners
:
function
(
)
{
this
.
_timeline
.
on
(
"
timeline
-
data
"
this
.
_onTimelineData
)
;
this
.
_profiler
.
on
(
"
console
-
profile
-
start
"
this
.
_onConsoleProfileStart
)
;
this
.
_profiler
.
on
(
"
console
-
profile
-
stop
"
this
.
_onConsoleProfileStop
)
;
this
.
_profiler
.
on
(
"
profiler
-
stopped
"
this
.
_onProfilerUnexpectedlyStopped
)
;
this
.
_profiler
.
on
(
"
profiler
-
status
"
this
.
_onProfilerStatus
)
;
}
_unregisterListeners
:
function
(
)
{
this
.
_timeline
.
off
(
"
timeline
-
data
"
this
.
_onTimelineData
)
;
this
.
_profiler
.
off
(
"
console
-
profile
-
start
"
this
.
_onConsoleProfileStart
)
;
this
.
_profiler
.
off
(
"
console
-
profile
-
stop
"
this
.
_onConsoleProfileStop
)
;
this
.
_profiler
.
off
(
"
profiler
-
stopped
"
this
.
_onProfilerUnexpectedlyStopped
)
;
this
.
_profiler
.
off
(
"
profiler
-
status
"
this
.
_onProfilerStatus
)
;
}
_disconnectActors
:
Task
.
async
(
function
*
(
)
{
yield
promise
.
all
(
[
this
.
_profiler
.
destroy
(
)
this
.
_timeline
.
destroy
(
)
]
)
;
}
)
_onConsoleProfileStart
:
Task
.
async
(
function
*
(
_
{
profileLabel
currentTime
:
startTime
}
)
{
let
recordings
=
this
.
_recordings
;
if
(
recordings
.
find
(
e
=
>
e
.
getLabel
(
)
=
=
=
profileLabel
)
)
{
return
;
}
events
.
emit
(
this
"
console
-
profile
-
start
"
)
;
yield
this
.
startRecording
(
extend
(
{
}
getLegacyPerformanceRecordingPrefs
(
)
{
console
:
true
label
:
profileLabel
}
)
)
;
}
)
_onConsoleProfileStop
:
Task
.
async
(
function
*
(
_
data
)
{
if
(
!
data
)
{
return
;
}
let
{
profileLabel
currentTime
:
endTime
}
=
data
;
let
pending
=
this
.
_recordings
.
filter
(
r
=
>
r
.
isConsole
(
)
&
&
r
.
isRecording
(
)
)
;
if
(
pending
.
length
=
=
=
0
)
{
return
;
}
let
model
;
if
(
profileLabel
)
{
model
=
pending
.
find
(
e
=
>
e
.
getLabel
(
)
=
=
=
profileLabel
)
;
}
else
{
model
=
pending
[
pending
.
length
-
1
]
;
}
if
(
!
model
)
{
Cu
.
reportError
(
"
console
.
profileEnd
(
)
called
with
label
that
does
not
match
a
recording
.
"
)
;
return
;
}
yield
this
.
stopRecording
(
model
)
;
}
)
_onProfilerUnexpectedlyStopped
:
function
(
)
{
Cu
.
reportError
(
"
Profiler
unexpectedly
stopped
.
"
arguments
)
;
}
_onTimelineData
:
function
(
_
.
.
.
data
)
{
this
.
_recordings
.
forEach
(
e
=
>
e
.
_addTimelineData
.
apply
(
e
data
)
)
;
events
.
emit
(
this
"
timeline
-
data
"
.
.
.
data
)
;
}
_onProfilerStatus
:
function
(
_
data
)
{
if
(
!
data
|
|
data
.
position
=
=
=
void
0
)
{
return
;
}
this
.
_currentBufferStatus
=
data
;
events
.
emit
(
this
"
profiler
-
status
"
data
)
;
}
startRecording
:
Task
.
async
(
function
*
(
options
=
{
}
)
{
let
model
=
new
LegacyPerformanceRecording
(
normalizePerformanceFeatures
(
options
this
.
traits
.
features
)
)
;
let
profilerStart
=
this
.
_profiler
.
start
(
options
)
;
let
timelineStart
=
this
.
_timeline
.
start
(
options
)
;
let
{
startTime
position
generation
totalSize
}
=
yield
profilerStart
;
let
timelineStartTime
=
yield
timelineStart
;
let
data
=
{
profilerStartTime
:
startTime
timelineStartTime
generation
position
totalSize
}
;
model
.
_populate
(
data
)
;
this
.
_recordings
.
push
(
model
)
;
events
.
emit
(
this
"
recording
-
started
"
model
)
;
return
model
;
}
)
stopRecording
:
Task
.
async
(
function
*
(
model
)
{
if
(
this
.
_recordings
.
indexOf
(
model
)
=
=
=
-
1
)
{
return
;
}
let
endTime
=
Date
.
now
(
)
;
model
.
_onStoppingRecording
(
endTime
)
;
events
.
emit
(
this
"
recording
-
stopping
"
model
)
;
this
.
_recordings
.
splice
(
this
.
_recordings
.
indexOf
(
model
)
1
)
;
let
config
=
model
.
getConfiguration
(
)
;
let
startTime
=
model
.
_getProfilerStartTime
(
)
;
let
profilerData
=
yield
this
.
_profiler
.
getProfile
(
{
startTime
}
)
;
let
timelineEndTime
=
Date
.
now
(
)
;
if
(
!
this
.
isRecording
(
)
)
{
yield
this
.
_profiler
.
stop
(
)
;
timelineEndTime
=
yield
this
.
_timeline
.
stop
(
config
)
;
}
let
systemDeferred
=
promise
.
defer
(
)
;
this
.
_client
.
listTabs
(
form
=
>
{
systemDeferred
.
resolve
(
getDeviceFront
(
this
.
_client
form
)
.
getDescription
(
)
)
;
}
)
;
let
systemHost
=
yield
systemDeferred
.
promise
;
let
systemClient
=
yield
getSystemInfo
(
)
;
model
.
_onStopRecording
(
{
profile
:
profilerData
.
profile
profilerEndTime
:
profilerData
.
currentTime
timelineEndTime
:
timelineEndTime
systemHost
systemClient
}
)
;
events
.
emit
(
this
"
recording
-
stopped
"
model
)
;
return
model
;
}
)
importRecording
:
function
(
file
)
{
return
importRecording
(
file
)
;
}
isRecording
:
function
(
)
{
return
this
.
_recordings
.
some
(
recording
=
>
recording
.
isRecording
(
)
)
;
}
getBufferUsageForRecording
:
function
(
recording
)
{
if
(
!
recording
.
isRecording
(
)
|
|
!
this
.
_currentBufferStatus
)
{
return
null
;
}
let
{
position
:
currentPosition
totalSize
generation
:
currentGeneration
}
=
this
.
_currentBufferStatus
;
let
{
position
:
origPosition
generation
:
origGeneration
}
=
recording
.
getStartingBufferStatus
(
)
;
let
normalizedCurrent
=
(
totalSize
*
(
currentGeneration
-
origGeneration
)
)
+
currentPosition
;
let
percent
=
(
normalizedCurrent
-
origPosition
)
/
totalSize
;
return
percent
>
1
?
1
:
percent
;
}
getConfiguration
:
Task
.
async
(
function
*
(
)
{
let
profilerConfig
=
yield
this
.
_request
(
"
profiler
"
"
getStartOptions
"
)
;
return
profilerConfig
;
}
)
_pipeToFront
:
function
(
eventName
.
.
.
args
)
{
events
.
emit
(
this
eventName
.
.
.
args
)
;
}
_request
:
function
(
actorName
method
.
.
.
args
)
{
if
(
!
DevToolsUtils
.
testing
)
{
throw
new
Error
(
"
LegacyPerformanceFront
.
_request
may
only
be
used
in
tests
.
"
)
;
}
let
actor
=
this
[
_
{
actorName
}
]
;
return
actor
[
method
]
.
apply
(
actor
args
)
;
}
setProfilerStatusInterval
:
function
(
n
)
{
if
(
this
.
_profiler
.
_poller
)
{
this
.
_profiler
.
_poller
.
_wait
=
n
;
}
this
.
_profiler
.
_PROFILER_CHECK_TIMER
=
n
;
}
toString
:
(
)
=
>
"
[
object
LegacyPerformanceFront
]
"
}
)
;
function
getLegacyPerformanceRecordingPrefs
(
)
{
return
{
withMarkers
:
true
withMemory
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
performance
.
ui
.
enable
-
memory
"
)
withTicks
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
performance
.
ui
.
enable
-
framerate
"
)
withAllocations
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
performance
.
ui
.
enable
-
allocations
"
)
withJITOptimizations
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
performance
.
ui
.
enable
-
jit
-
optimizations
"
)
allocationsSampleProbability
:
+
Services
.
prefs
.
getCharPref
(
"
devtools
.
performance
.
memory
.
sample
-
probability
"
)
allocationsMaxLogLength
:
Services
.
prefs
.
getIntPref
(
"
devtools
.
performance
.
memory
.
max
-
log
-
length
"
)
}
;
}
exports
.
LegacyPerformanceFront
=
LegacyPerformanceFront
;
