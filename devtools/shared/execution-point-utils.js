"
use
strict
"
;
function
pointPrecedes
(
pointA
pointB
)
{
if
(
pointA
.
checkpoint
!
=
pointB
.
checkpoint
)
{
return
pointA
.
checkpoint
<
pointB
.
checkpoint
;
}
if
(
pointA
.
progress
!
=
pointB
.
progress
)
{
return
pointA
.
progress
<
pointB
.
progress
;
}
const
posA
=
pointA
.
position
;
const
posB
=
pointB
.
position
;
assert
(
!
!
posA
=
=
!
!
posB
)
;
if
(
!
posA
|
|
positionEquals
(
posA
posB
)
)
{
return
false
;
}
assert
(
"
frameIndex
"
in
posA
&
&
"
frameIndex
"
in
posB
)
;
assert
(
"
script
"
in
posA
&
&
"
script
"
in
posB
)
;
if
(
posA
.
kind
=
=
"
EnterFrame
"
|
|
posB
.
kind
=
=
"
EnterFrame
"
)
{
return
posA
.
kind
=
=
"
EnterFrame
"
;
}
assert
(
posA
.
kind
=
=
"
OnStep
"
|
|
posA
.
kind
=
=
"
OnPop
"
)
;
assert
(
posB
.
kind
=
=
"
OnStep
"
|
|
posB
.
kind
=
=
"
OnPop
"
)
;
if
(
posA
.
frameIndex
!
=
posB
.
frameIndex
)
{
return
posA
.
frameIndex
>
posB
.
frameIndex
;
}
if
(
posA
.
kind
!
=
posB
.
kind
)
{
return
posA
.
kind
=
=
"
OnStep
"
;
}
assert
(
"
offset
"
in
posA
&
&
"
offset
"
in
posB
)
;
return
posA
.
offset
<
posB
.
offset
;
}
function
pointEquals
(
pointA
pointB
)
{
return
!
pointPrecedes
(
pointA
pointB
)
&
&
!
pointPrecedes
(
pointB
pointA
)
;
}
function
pointToString
(
point
)
{
if
(
point
.
position
)
{
return
{
point
.
checkpoint
}
:
{
point
.
progress
}
:
{
positionToString
(
point
.
position
)
}
;
}
return
{
point
.
checkpoint
}
:
{
point
.
progress
}
;
}
function
pointArrayIncludes
(
points
point
)
{
return
points
.
some
(
p
=
>
pointEquals
(
point
p
)
)
;
}
function
findClosestPoint
(
points
point
before
inclusive
)
{
let
result
=
null
;
for
(
const
p
of
points
)
{
if
(
inclusive
&
&
pointEquals
(
p
point
)
)
{
return
p
;
}
if
(
before
?
pointPrecedes
(
p
point
)
:
pointPrecedes
(
point
p
)
)
{
if
(
!
result
|
|
(
before
?
pointPrecedes
(
result
p
)
:
pointPrecedes
(
p
result
)
)
)
{
result
=
p
;
}
}
}
return
result
;
}
function
positionEquals
(
posA
posB
)
{
return
(
posA
.
kind
=
=
posB
.
kind
&
&
posA
.
script
=
=
posB
.
script
&
&
posA
.
offset
=
=
posB
.
offset
&
&
posA
.
frameIndex
=
=
posB
.
frameIndex
)
;
}
function
positionSubsumes
(
posA
posB
)
{
if
(
positionEquals
(
posA
posB
)
)
{
return
true
;
}
if
(
posA
.
kind
=
=
"
Break
"
&
&
posB
.
kind
=
=
"
OnStep
"
&
&
posA
.
script
=
=
posB
.
script
&
&
posA
.
offset
=
=
posB
.
offset
)
{
return
true
;
}
if
(
posA
.
kind
=
=
"
EnterFrame
"
&
&
posB
.
kind
=
=
"
EnterFrame
"
&
&
!
posA
.
script
&
&
posB
.
script
)
{
return
true
;
}
return
false
;
}
function
positionToString
(
pos
)
{
return
{
pos
.
kind
}
:
{
pos
.
script
}
:
{
pos
.
offset
}
:
{
pos
.
frameIndex
}
;
}
function
assert
(
v
)
{
if
(
!
v
)
{
dump
(
Assertion
failed
:
{
Error
(
)
.
stack
}
\
n
)
;
throw
new
Error
(
Assertion
failed
!
{
Error
(
)
.
stack
}
)
;
}
}
this
.
EXPORTED_SYMBOLS
=
[
"
pointPrecedes
"
"
pointEquals
"
"
pointToString
"
"
pointArrayIncludes
"
"
findClosestPoint
"
"
positionEquals
"
"
positionSubsumes
"
"
positionToString
"
]
;
