"
use
strict
"
;
function
pointPrecedes
(
pointA
pointB
)
{
if
(
pointA
.
checkpoint
!
=
pointB
.
checkpoint
)
{
return
pointA
.
checkpoint
<
pointB
.
checkpoint
;
}
if
(
pointA
.
progress
!
=
pointB
.
progress
)
{
return
pointA
.
progress
<
pointB
.
progress
;
}
const
posA
=
pointA
.
position
;
const
posB
=
pointB
.
position
;
assert
(
!
!
posA
=
=
!
!
posB
)
;
if
(
!
posA
|
|
positionEquals
(
posA
posB
)
)
{
return
false
;
}
if
(
"
frameIndex
"
in
posA
!
=
"
frameIndex
"
in
posB
)
{
return
"
frameIndex
"
in
posB
;
}
assert
(
posA
.
kind
=
=
"
OnStep
"
|
|
posA
.
kind
=
=
"
OnPop
"
)
;
assert
(
posB
.
kind
=
=
"
OnStep
"
|
|
posB
.
kind
=
=
"
OnPop
"
)
;
assert
(
"
frameIndex
"
in
posA
&
&
"
frameIndex
"
in
posB
)
;
if
(
posA
.
frameIndex
!
=
posB
.
frameIndex
)
{
return
posA
.
frameIndex
>
posB
.
frameIndex
;
}
if
(
posA
.
kind
!
=
posB
.
kind
)
{
return
posA
.
kind
=
=
"
OnStep
"
;
}
assert
(
"
offset
"
in
posA
&
&
"
offset
"
in
posB
)
;
return
posA
.
offset
<
posB
.
offset
;
}
function
pointEquals
(
pointA
pointB
)
{
return
!
pointPrecedes
(
pointA
pointB
)
&
&
!
pointPrecedes
(
pointB
pointA
)
;
}
function
positionEquals
(
posA
posB
)
{
return
posA
.
kind
=
=
posB
.
kind
&
&
posA
.
script
=
=
posB
.
script
&
&
posA
.
offset
=
=
posB
.
offset
&
&
posA
.
frameIndex
=
=
posB
.
frameIndex
;
}
function
positionSubsumes
(
posA
posB
)
{
if
(
positionEquals
(
posA
posB
)
)
{
return
true
;
}
if
(
posA
.
kind
=
=
"
Break
"
&
&
posB
.
kind
=
=
"
OnStep
"
&
&
posA
.
script
=
=
posB
.
script
&
&
posA
.
offset
=
=
posB
.
offset
)
{
return
true
;
}
return
false
;
}
function
assert
(
v
)
{
if
(
!
v
)
{
dump
(
Assertion
failed
:
{
Error
(
)
.
stack
}
\
n
)
;
throw
new
Error
(
"
Assertion
failed
!
"
)
;
}
}
this
.
EXPORTED_SYMBOLS
=
[
"
pointPrecedes
"
"
pointEquals
"
"
positionEquals
"
"
positionSubsumes
"
]
;
