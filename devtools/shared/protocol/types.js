"
use
strict
"
;
var
{
Actor
}
=
require
(
"
.
/
Actor
"
)
;
var
{
lazyLoadSpec
lazyLoadFront
}
=
require
(
"
devtools
/
shared
/
specs
/
index
"
)
;
var
types
=
Object
.
create
(
null
)
;
exports
.
types
=
types
;
var
registeredTypes
=
(
types
.
registeredTypes
=
new
Map
(
)
)
;
var
registeredLifetimes
=
(
types
.
registeredLifetimes
=
new
Map
(
)
)
;
exports
.
registeredTypes
=
registeredTypes
;
types
.
getType
=
function
(
type
)
{
if
(
!
type
)
{
return
types
.
Primitive
;
}
if
(
typeof
type
!
=
=
"
string
"
)
{
return
type
;
}
let
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
if
(
lazyLoadSpec
(
type
)
)
{
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
}
const
sep
=
type
.
indexOf
(
"
:
"
)
;
if
(
sep
>
=
0
)
{
const
collection
=
type
.
substring
(
0
sep
)
;
const
subtype
=
types
.
getType
(
type
.
substring
(
sep
+
1
)
)
;
if
(
collection
=
=
=
"
array
"
)
{
return
types
.
addArrayType
(
subtype
)
;
}
else
if
(
collection
=
=
=
"
nullable
"
)
{
return
types
.
addNullableType
(
subtype
)
;
}
if
(
registeredLifetimes
.
has
(
collection
)
)
{
return
types
.
addLifetimeType
(
collection
subtype
)
;
}
throw
Error
(
"
Unknown
collection
type
:
"
+
collection
)
;
}
const
pieces
=
type
.
split
(
"
#
"
2
)
;
if
(
pieces
.
length
>
1
)
{
if
(
pieces
[
1
]
!
=
"
actorid
"
)
{
throw
new
Error
(
"
Unsupported
detail
only
support
'
actorid
'
got
:
"
+
pieces
[
1
]
)
;
}
return
types
.
addActorDetail
(
type
pieces
[
0
]
pieces
[
1
]
)
;
}
throw
Error
(
"
Unknown
type
:
"
+
type
)
;
}
;
function
identityWrite
(
v
)
{
if
(
v
=
=
=
undefined
)
{
throw
Error
(
"
undefined
passed
where
a
value
is
required
"
)
;
}
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
return
[
.
.
.
v
]
;
}
return
v
;
}
types
.
addType
=
function
(
name
typeObject
=
{
}
options
=
{
}
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
throw
Error
(
"
Type
'
"
+
name
+
"
'
already
exists
.
"
)
;
}
const
type
=
Object
.
assign
(
{
toString
(
)
{
return
"
[
protocol
type
:
"
+
name
+
"
]
"
;
}
name
:
name
primitive
:
!
(
typeObject
.
read
|
|
typeObject
.
write
)
read
:
identityWrite
write
:
identityWrite
}
typeObject
)
;
registeredTypes
.
set
(
name
type
)
;
return
type
;
}
;
types
.
removeType
=
function
(
name
)
{
const
type
=
registeredTypes
.
get
(
name
)
;
type
.
name
=
"
DEFUNCT
:
"
+
name
;
type
.
category
=
"
defunct
"
;
type
.
primitive
=
false
;
type
.
read
=
type
.
write
=
function
(
)
{
throw
new
Error
(
"
Using
defunct
type
:
"
+
name
)
;
}
;
registeredTypes
.
delete
(
name
)
;
}
;
types
.
addArrayType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
const
name
=
"
array
:
"
+
subtype
.
name
;
if
(
subtype
.
primitive
)
{
return
types
.
addType
(
name
)
;
}
return
types
.
addType
(
name
{
category
:
"
array
"
read
:
(
v
ctx
)
=
>
{
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
v
=
[
.
.
.
v
]
;
}
return
v
.
map
(
i
=
>
subtype
.
read
(
i
ctx
)
)
;
}
write
:
(
v
ctx
)
=
>
{
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
v
=
[
.
.
.
v
]
;
}
return
v
.
map
(
i
=
>
subtype
.
write
(
i
ctx
)
)
;
}
}
)
;
}
;
types
.
addDictType
=
function
(
name
specializations
)
{
const
specTypes
=
{
}
;
for
(
const
prop
in
specializations
)
{
try
{
specTypes
[
prop
]
=
types
.
getType
(
specializations
[
prop
]
)
;
}
catch
(
e
)
{
loader
.
lazyGetter
(
specTypes
prop
(
)
=
>
{
return
types
.
getType
(
specializations
[
prop
]
)
;
}
)
;
}
}
return
types
.
addType
(
name
{
category
:
"
dict
"
specializations
read
:
(
v
ctx
)
=
>
{
const
ret
=
{
}
;
for
(
const
prop
in
v
)
{
if
(
prop
in
specTypes
)
{
ret
[
prop
]
=
specTypes
[
prop
]
.
read
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
write
:
(
v
ctx
)
=
>
{
const
ret
=
{
}
;
for
(
const
prop
in
v
)
{
if
(
prop
in
specTypes
)
{
ret
[
prop
]
=
specTypes
[
prop
]
.
write
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
}
)
;
}
;
types
.
addActorType
=
function
(
name
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
return
registeredTypes
.
get
(
name
)
;
}
const
type
=
types
.
addType
(
name
{
_actor
:
true
category
:
"
actor
"
read
:
(
v
ctx
detail
)
=
>
{
if
(
ctx
instanceof
Actor
)
{
return
ctx
.
conn
.
getActor
(
v
)
;
}
const
actorID
=
typeof
v
=
=
=
"
string
"
?
v
:
v
.
actor
;
let
front
=
ctx
.
conn
.
getActor
(
actorID
)
;
if
(
!
front
)
{
if
(
!
type
.
frontClass
)
{
lazyLoadFront
(
name
)
;
}
const
Class
=
type
.
frontClass
;
front
=
new
Class
(
ctx
.
conn
)
;
front
.
actorID
=
actorID
;
ctx
.
marshallPool
(
)
.
manage
(
front
)
;
}
if
(
detail
!
=
"
actorid
"
)
{
v
=
identityWrite
(
v
)
;
front
.
form
(
v
ctx
)
;
}
return
front
;
}
write
:
(
v
ctx
detail
)
=
>
{
if
(
v
instanceof
Actor
)
{
if
(
!
v
.
actorID
)
{
ctx
.
marshallPool
(
)
.
manage
(
v
)
;
}
if
(
detail
=
=
"
actorid
"
)
{
return
v
.
actorID
;
}
return
identityWrite
(
v
.
form
(
detail
)
)
;
}
return
v
.
actorID
;
}
}
)
;
return
type
;
}
;
types
.
addNullableType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
return
types
.
addType
(
"
nullable
:
"
+
subtype
.
name
{
category
:
"
nullable
"
read
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
read
(
value
ctx
)
;
}
write
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
write
(
value
ctx
)
;
}
}
)
;
}
;
types
.
addActorDetail
=
function
(
name
actorType
detail
)
{
actorType
=
types
.
getType
(
actorType
)
;
if
(
!
actorType
.
_actor
)
{
throw
Error
(
Details
only
apply
to
actor
types
tried
to
add
detail
'
{
detail
}
'
+
to
{
actorType
.
name
}
)
;
}
return
types
.
addType
(
name
{
_actor
:
true
category
:
"
detail
"
read
:
(
v
ctx
)
=
>
actorType
.
read
(
v
ctx
detail
)
write
:
(
v
ctx
)
=
>
actorType
.
write
(
v
ctx
detail
)
}
)
;
}
;
types
.
addLifetime
=
function
(
name
prop
)
{
if
(
registeredLifetimes
.
has
(
name
)
)
{
throw
Error
(
"
Lifetime
'
"
+
name
+
"
'
already
registered
.
"
)
;
}
registeredLifetimes
.
set
(
name
prop
)
;
}
;
types
.
removeLifetime
=
function
(
name
)
{
registeredLifetimes
.
delete
(
name
)
;
}
;
types
.
addLifetimeType
=
function
(
lifetime
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
if
(
!
subtype
.
_actor
)
{
throw
Error
(
Lifetimes
only
apply
to
actor
types
tried
to
apply
+
lifetime
'
{
lifetime
}
'
to
{
subtype
.
name
}
)
;
}
const
prop
=
registeredLifetimes
.
get
(
lifetime
)
;
return
types
.
addType
(
lifetime
+
"
:
"
+
subtype
.
name
{
category
:
"
lifetime
"
read
:
(
value
ctx
)
=
>
subtype
.
read
(
value
ctx
[
prop
]
)
write
:
(
value
ctx
)
=
>
subtype
.
write
(
value
ctx
[
prop
]
)
}
)
;
}
;
types
.
Primitive
=
types
.
addType
(
"
primitive
"
)
;
types
.
String
=
types
.
addType
(
"
string
"
)
;
types
.
Number
=
types
.
addType
(
"
number
"
)
;
types
.
Boolean
=
types
.
addType
(
"
boolean
"
)
;
types
.
JSON
=
types
.
addType
(
"
json
"
)
;
exports
.
registerFront
=
function
(
cls
)
{
const
{
typeName
}
=
cls
.
prototype
;
if
(
!
registeredTypes
.
has
(
typeName
)
)
{
types
.
addActorType
(
typeName
)
;
}
registeredTypes
.
get
(
typeName
)
.
frontClass
=
cls
;
}
;
function
getFront
(
client
typeName
form
)
{
const
type
=
types
.
getType
(
typeName
)
;
if
(
!
type
)
{
throw
new
Error
(
No
spec
for
front
type
'
{
typeName
}
'
.
)
;
}
if
(
!
type
.
frontClass
)
{
lazyLoadFront
(
typeName
)
;
}
const
Class
=
type
.
frontClass
;
const
instance
=
new
Class
(
client
)
;
const
{
formAttributeName
}
=
instance
;
if
(
!
formAttributeName
)
{
throw
new
Error
(
Can
'
t
find
the
form
attribute
name
for
{
typeName
}
)
;
}
instance
.
actorID
=
form
[
formAttributeName
]
;
if
(
!
instance
.
actorID
)
{
throw
new
Error
(
Can
'
t
find
the
actor
ID
for
{
typeName
}
from
root
or
target
+
actor
'
s
form
.
)
;
}
instance
.
manage
(
instance
)
;
if
(
typeof
instance
.
initialize
=
=
"
function
"
)
{
return
instance
.
initialize
(
)
.
then
(
(
)
=
>
instance
)
;
}
return
instance
;
}
exports
.
getFront
=
getFront
;
