"
use
strict
"
;
var
{
BULK_REQUEST
BULK_RESPONSE
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
types
.
js
"
)
;
var
{
Front
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Front
.
js
"
)
;
var
generateRequestMethods
=
function
(
actorSpec
frontProto
)
{
if
(
frontProto
.
_actorSpec
)
{
throw
new
Error
(
"
frontProto
called
twice
on
the
same
front
prototype
!
"
)
;
}
frontProto
.
typeName
=
actorSpec
.
typeName
;
const
methods
=
actorSpec
.
methods
;
methods
.
forEach
(
spec
=
>
{
const
{
name
}
=
spec
;
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
if
(
this
.
isDestroyed
(
)
)
{
throw
new
Error
(
Can
not
send
request
'
{
name
}
'
because
front
'
{
this
.
typeName
}
'
is
already
destroyed
.
)
;
}
const
startTime
=
ChromeUtils
.
now
(
)
;
let
packet
;
try
{
packet
=
spec
.
request
.
write
(
args
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
writing
request
:
"
+
name
)
;
throw
ex
;
}
if
(
spec
.
oneway
)
{
this
.
send
(
packet
)
;
return
undefined
;
}
const
isSendingBulkData
=
spec
.
request
.
template
=
=
=
BULK_REQUEST
;
const
clientBulkCallback
=
isSendingBulkData
?
args
.
at
(
-
1
)
:
null
;
return
this
.
request
(
packet
{
bulk
:
isSendingBulkData
clientBulkCallback
}
)
.
then
(
response
=
>
{
const
isReceivingBulkData
=
spec
.
response
.
template
=
=
=
BULK_RESPONSE
;
if
(
isReceivingBulkData
)
{
return
response
;
}
let
ret
;
if
(
!
this
.
conn
)
{
throw
new
Error
(
"
Missing
conn
on
"
+
this
)
;
}
if
(
this
.
isDestroyed
(
)
)
{
throw
new
Error
(
Can
not
interpret
'
{
name
}
'
response
because
front
'
{
this
.
typeName
}
'
is
already
destroyed
.
)
;
}
try
{
ret
=
spec
.
response
.
read
(
response
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
response
to
:
"
+
name
+
"
\
n
"
+
ex
)
;
throw
ex
;
}
ChromeUtils
.
addProfilerMarker
(
"
RDP
Front
"
startTime
{
this
.
typeName
}
:
{
name
}
(
)
)
;
return
ret
;
}
)
;
}
;
if
(
spec
.
release
)
{
const
fn
=
frontProto
[
name
]
;
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
return
fn
.
apply
(
this
args
)
.
then
(
result
=
>
{
this
.
destroy
(
)
;
return
result
;
}
)
;
}
;
}
}
)
;
frontProto
.
_clientSpec
=
{
}
;
const
actorEvents
=
actorSpec
.
events
;
if
(
actorEvents
)
{
frontProto
.
_clientSpec
.
events
=
new
Map
(
)
;
for
(
const
[
name
request
]
of
actorEvents
)
{
frontProto
.
_clientSpec
.
events
.
set
(
request
.
type
{
name
request
}
)
;
}
}
frontProto
.
_actorSpec
=
actorSpec
;
return
frontProto
;
}
;
var
FrontClassWithSpec
=
function
(
actorSpec
)
{
class
OneFront
extends
Front
{
}
generateRequestMethods
(
actorSpec
OneFront
.
prototype
)
;
return
OneFront
;
}
;
exports
.
FrontClassWithSpec
=
FrontClassWithSpec
;
