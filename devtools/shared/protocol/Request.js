"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
var
{
findPlaceholders
describeTemplate
getPath
}
=
require
(
"
.
/
utils
"
)
;
var
{
types
}
=
require
(
"
.
/
types
"
)
;
var
Request
=
function
(
template
=
{
}
)
{
this
.
type
=
template
.
type
;
this
.
template
=
template
;
this
.
args
=
findPlaceholders
(
template
Arg
)
;
}
;
Request
.
prototype
=
{
write
:
function
(
fnArgs
ctx
)
{
const
ret
=
{
}
;
for
(
const
key
in
this
.
template
)
{
const
value
=
this
.
template
[
key
]
;
if
(
value
instanceof
Arg
)
{
ret
[
key
]
=
value
.
write
(
value
.
index
in
fnArgs
?
fnArgs
[
value
.
index
]
:
undefined
ctx
key
)
;
}
else
if
(
key
=
=
"
type
"
)
{
ret
[
key
]
=
value
;
}
else
{
throw
new
Error
(
"
Request
can
only
an
object
with
Arg
or
Option
properties
"
)
;
}
}
return
ret
;
}
read
:
function
(
packet
ctx
)
{
const
fnArgs
=
[
]
;
for
(
const
templateArg
of
this
.
args
)
{
const
arg
=
templateArg
.
placeholder
;
const
path
=
templateArg
.
path
;
const
name
=
path
[
path
.
length
-
1
]
;
arg
.
read
(
getPath
(
packet
path
)
ctx
fnArgs
name
)
;
}
return
fnArgs
;
}
describe
:
function
(
)
{
return
describeTemplate
(
this
.
template
)
;
}
}
;
exports
.
Request
=
Request
;
var
Arg
=
function
(
index
type
)
{
this
.
index
=
index
;
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
Arg
.
prototype
=
{
write
:
function
(
arg
ctx
)
{
return
this
.
type
.
write
(
arg
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
)
{
outArgs
[
this
.
index
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_arg
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
;
exports
.
Arg
=
function
(
index
type
)
{
return
new
Arg
(
index
type
)
;
}
;
var
Option
=
function
(
index
type
)
{
Arg
.
call
(
this
index
type
)
;
}
;
Option
.
prototype
=
extend
(
Arg
.
prototype
{
write
:
function
(
arg
ctx
name
)
{
if
(
arg
=
=
undefined
|
|
arg
[
name
]
=
=
undefined
)
{
return
undefined
;
}
const
v
=
arg
[
name
]
;
return
this
.
type
.
write
(
v
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
name
)
{
if
(
outArgs
[
this
.
index
]
=
=
=
undefined
)
{
outArgs
[
this
.
index
]
=
{
}
;
}
if
(
v
=
=
=
undefined
)
{
return
;
}
outArgs
[
this
.
index
]
[
name
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_option
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
)
;
exports
.
Option
=
function
(
index
type
)
{
return
new
Option
(
index
type
)
;
}
;
