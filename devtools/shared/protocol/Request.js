"
use
strict
"
;
const
{
extend
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
extend
.
js
"
)
;
var
{
findPlaceholders
getPath
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
utils
.
js
"
)
;
var
{
types
BULK_REQUEST
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
types
.
js
"
)
;
var
Request
=
function
(
type
template
=
{
}
)
{
this
.
type
=
template
.
type
|
|
type
;
this
.
template
=
template
;
this
.
args
=
findPlaceholders
(
template
Arg
)
;
}
;
Request
.
prototype
=
{
write
(
fnArgs
ctx
)
{
if
(
this
.
template
=
=
=
BULK_REQUEST
)
{
if
(
typeof
fnArgs
[
0
]
.
length
!
=
"
number
"
)
{
throw
new
Error
(
"
This
front
'
s
method
is
expected
to
send
a
bulk
request
and
should
be
called
with
an
object
argument
with
a
length
attribute
.
"
)
;
}
return
{
type
:
this
.
type
length
:
fnArgs
[
0
]
.
length
}
;
}
const
ret
=
{
type
:
this
.
type
}
;
for
(
const
key
in
this
.
template
)
{
const
value
=
this
.
template
[
key
]
;
if
(
value
instanceof
Arg
|
|
value
instanceof
Option
)
{
ret
[
key
]
=
value
.
write
(
value
.
index
in
fnArgs
?
fnArgs
[
value
.
index
]
:
undefined
ctx
key
)
;
}
else
if
(
key
=
=
"
type
"
)
{
continue
;
}
else
{
throw
new
Error
(
"
Request
can
only
an
object
with
Arg
or
Option
properties
"
)
;
}
}
return
ret
;
}
read
(
packet
ctx
)
{
if
(
this
.
template
=
=
=
BULK_REQUEST
)
{
return
[
{
length
:
packet
.
length
copyTo
:
packet
.
copyTo
copyToBuffer
:
packet
.
copyToBuffer
}
]
;
}
const
fnArgs
=
[
]
;
for
(
const
templateArg
of
this
.
args
)
{
const
arg
=
templateArg
.
placeholder
;
const
path
=
templateArg
.
path
;
const
name
=
path
[
path
.
length
-
1
]
;
arg
.
read
(
getPath
(
packet
path
)
ctx
fnArgs
name
)
;
}
return
fnArgs
;
}
}
;
exports
.
Request
=
Request
;
var
Arg
=
function
(
index
type
)
{
this
.
index
=
index
;
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
Arg
.
prototype
=
{
write
(
arg
ctx
)
{
return
this
.
type
.
write
(
arg
ctx
)
;
}
read
(
v
ctx
outArgs
)
{
outArgs
[
this
.
index
]
=
this
.
type
.
read
(
v
ctx
)
;
}
}
;
exports
.
Arg
=
function
(
index
type
)
{
return
new
Arg
(
index
type
)
;
}
;
var
Option
=
function
(
index
type
)
{
Arg
.
call
(
this
index
type
)
;
}
;
Option
.
prototype
=
extend
(
Arg
.
prototype
{
write
(
arg
ctx
name
)
{
if
(
arg
=
=
undefined
|
|
arg
[
name
]
=
=
undefined
)
{
return
undefined
;
}
const
v
=
arg
[
name
]
;
return
this
.
type
.
write
(
v
ctx
)
;
}
read
(
v
ctx
outArgs
name
)
{
if
(
outArgs
[
this
.
index
]
=
=
=
undefined
)
{
outArgs
[
this
.
index
]
=
{
}
;
}
if
(
v
=
=
=
undefined
)
{
return
;
}
outArgs
[
this
.
index
]
[
name
]
=
this
.
type
.
read
(
v
ctx
)
;
}
}
)
;
exports
.
Option
=
function
(
index
type
)
{
return
new
Option
(
index
type
)
;
}
;
