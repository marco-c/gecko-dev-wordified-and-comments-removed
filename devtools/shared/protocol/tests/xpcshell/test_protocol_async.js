"
use
strict
"
;
var
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
var
{
Arg
RetVal
}
=
protocol
;
function
simpleHello
(
)
{
return
{
from
:
"
root
"
applicationType
:
"
xpcshell
-
tests
"
traits
:
[
]
}
;
}
const
rootSpec
=
protocol
.
generateActorSpec
(
{
typeName
:
"
root
"
methods
:
{
simpleReturn
:
{
response
:
{
value
:
RetVal
(
)
}
}
promiseReturn
:
{
request
:
{
toWait
:
Arg
(
0
"
number
"
)
}
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
simpleThrow
:
{
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
promiseThrow
:
{
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
}
}
)
;
var
RootActor
=
protocol
.
ActorClassWithSpec
(
rootSpec
{
initialize
:
function
(
conn
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
manage
(
this
)
;
this
.
actorID
=
"
root
"
;
this
.
sequence
=
0
;
}
sayHello
:
simpleHello
simpleReturn
:
function
(
)
{
return
this
.
sequence
+
+
;
}
promiseReturn
:
function
(
toWait
)
{
const
deferred
=
defer
(
)
;
const
sequence
=
this
.
sequence
+
+
;
const
check
=
(
)
=
>
{
if
(
this
.
sequence
-
sequence
<
toWait
)
{
executeSoon
(
check
)
;
return
;
}
deferred
.
resolve
(
sequence
)
;
}
;
executeSoon
(
check
)
;
return
deferred
.
promise
;
}
simpleThrow
:
function
(
)
{
throw
new
Error
(
this
.
sequence
+
+
)
;
}
promiseThrow
:
function
(
)
{
const
deferred
=
defer
(
)
;
let
sequence
=
this
.
sequence
+
+
;
do_timeout
(
150
(
)
=
>
{
deferred
.
reject
(
sequence
+
+
)
;
}
)
;
return
deferred
.
promise
;
}
}
)
;
class
RootFront
extends
protocol
.
FrontClassWithSpec
(
rootSpec
)
{
constructor
(
client
)
{
super
(
client
)
;
this
.
actorID
=
"
root
"
;
this
.
manage
(
this
)
;
}
}
protocol
.
registerFront
(
RootFront
)
;
add_task
(
async
function
(
)
{
DevToolsServer
.
createRootActor
=
RootActor
;
DevToolsServer
.
init
(
)
;
const
trace
=
connectPipeTracing
(
)
;
const
client
=
new
DevToolsClient
(
trace
)
;
await
client
.
connect
(
)
;
const
rootFront
=
client
.
mainRoot
;
const
calls
=
[
]
;
let
sequence
=
0
;
calls
.
push
(
rootFront
.
promiseReturn
(
2
)
.
then
(
ret
=
>
{
Assert
.
equal
(
sequence
0
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
)
;
calls
.
push
(
rootFront
.
simpleReturn
(
)
.
then
(
ret
=
>
{
Assert
.
equal
(
sequence
1
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
)
;
calls
.
push
(
rootFront
.
simpleReturn
(
)
.
then
(
ret
=
>
{
Assert
.
equal
(
sequence
2
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
)
;
calls
.
push
(
rootFront
.
simpleThrow
(
)
.
then
(
(
)
=
>
{
Assert
.
ok
(
false
"
simpleThrow
shouldn
'
t
succeed
!
"
)
;
}
error
=
>
{
Assert
.
equal
(
sequence
+
+
3
)
;
}
)
)
;
const
deferAfterRejection
=
defer
(
)
;
calls
.
push
(
rootFront
.
promiseThrow
(
)
.
then
(
(
)
=
>
{
Assert
.
ok
(
false
"
promiseThrow
shouldn
'
t
succeed
!
"
)
;
}
error
=
>
{
Assert
.
equal
(
sequence
+
+
4
)
;
Assert
.
ok
(
true
"
simple
throw
should
throw
"
)
;
deferAfterRejection
.
resolve
(
)
;
}
)
)
;
calls
.
push
(
rootFront
.
simpleReturn
(
)
.
then
(
ret
=
>
{
return
deferAfterRejection
.
promise
.
then
(
function
(
)
{
Assert
.
equal
(
sequence
5
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
;
}
)
)
;
calls
.
push
(
rootFront
.
promiseReturn
(
1
)
.
then
(
ret
=
>
{
return
deferAfterRejection
.
promise
.
then
(
function
(
)
{
Assert
.
equal
(
sequence
6
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
;
}
)
)
;
calls
.
push
(
rootFront
.
simpleReturn
(
)
.
then
(
ret
=
>
{
return
deferAfterRejection
.
promise
.
then
(
function
(
)
{
Assert
.
equal
(
sequence
7
)
;
Assert
.
equal
(
ret
sequence
+
+
)
;
}
)
;
}
)
)
;
await
Promise
.
all
(
calls
)
;
await
client
.
close
(
)
;
}
)
;
