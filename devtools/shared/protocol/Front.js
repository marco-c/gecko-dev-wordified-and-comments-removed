"
use
strict
"
;
var
{
settleAll
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
{
Pool
}
=
require
(
"
.
/
Pool
"
)
;
var
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
function
defer
(
)
{
let
resolve
reject
;
const
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
class
Front
extends
Pool
{
constructor
(
conn
=
null
)
{
super
(
conn
)
;
this
.
actorID
=
null
;
this
.
targetFront
=
null
;
this
.
_requests
=
[
]
;
this
.
_frontListeners
=
new
EventEmitter
(
)
;
this
.
_beforeListeners
=
new
Map
(
)
;
}
destroy
(
)
{
while
(
this
.
_requests
&
&
this
.
_requests
.
length
>
0
)
{
const
{
deferred
to
type
stack
}
=
this
.
_requests
.
shift
(
)
;
const
msg
=
"
Connection
closed
pending
request
to
"
+
to
+
"
type
"
+
type
+
"
failed
"
+
"
\
n
\
nRequest
stack
:
\
n
"
+
stack
.
formattedStack
;
deferred
.
reject
(
new
Error
(
msg
)
)
;
}
super
.
destroy
(
)
;
this
.
clearEvents
(
)
;
this
.
actorID
=
null
;
this
.
targetFront
=
null
;
this
.
_frontListeners
=
null
;
this
.
_beforeListeners
=
null
;
}
manage
(
front
)
{
if
(
!
front
.
actorID
)
{
throw
new
Error
(
"
Can
'
t
manage
front
without
an
actor
ID
.
\
n
"
+
"
Ensure
server
supports
"
+
front
.
typeName
+
"
.
"
)
;
}
super
.
manage
(
front
)
;
this
.
_frontListeners
.
emit
(
front
.
typeName
front
)
;
}
onFront
(
typeName
callback
)
{
for
(
const
front
of
this
.
poolChildren
(
)
)
{
if
(
front
.
typeName
=
=
typeName
)
{
callback
(
front
)
;
}
}
this
.
_frontListeners
.
on
(
typeName
callback
)
;
}
before
(
type
callback
)
{
if
(
this
.
_beforeListeners
.
has
(
type
)
)
{
throw
new
Error
(
Can
'
t
register
multiple
before
listeners
for
"
{
type
}
"
.
)
;
}
this
.
_beforeListeners
.
set
(
type
callback
)
;
}
toString
(
)
{
return
"
[
Front
for
"
+
this
.
typeName
+
"
/
"
+
this
.
actorID
+
"
]
"
;
}
form
(
form
)
{
}
send
(
packet
)
{
if
(
packet
.
to
)
{
this
.
conn
.
_transport
.
send
(
packet
)
;
}
else
{
packet
.
to
=
this
.
actorID
;
if
(
this
.
conn
.
_transport
)
{
this
.
conn
.
_transport
.
send
(
packet
)
;
}
}
}
request
(
packet
)
{
const
deferred
=
defer
(
)
;
const
{
to
type
}
=
packet
;
this
.
_requests
.
push
(
{
deferred
to
:
to
|
|
this
.
actorID
type
stack
:
getStack
(
)
}
)
;
this
.
send
(
packet
)
;
return
deferred
.
promise
;
}
onPacket
(
packet
)
{
const
type
=
packet
.
type
|
|
undefined
;
if
(
this
.
_clientSpec
.
events
&
&
this
.
_clientSpec
.
events
.
has
(
type
)
)
{
const
event
=
this
.
_clientSpec
.
events
.
get
(
packet
.
type
)
;
let
args
;
try
{
args
=
event
.
request
.
read
(
packet
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
event
:
"
+
packet
.
type
)
;
console
.
exception
(
ex
)
;
throw
ex
;
}
const
beforeEvent
=
this
.
_beforeListeners
.
get
(
event
.
name
)
;
if
(
beforeEvent
)
{
const
result
=
beforeEvent
.
apply
(
this
args
)
;
if
(
result
&
&
typeof
result
.
then
=
=
"
function
"
)
{
result
.
then
(
(
)
=
>
{
super
.
emit
(
event
.
name
.
.
.
args
)
;
}
)
;
return
;
}
}
super
.
emit
(
event
.
name
.
.
.
args
)
;
return
;
}
if
(
this
.
_requests
.
length
=
=
=
0
)
{
const
msg
=
"
Unexpected
packet
"
+
this
.
actorID
+
"
"
+
JSON
.
stringify
(
packet
)
;
const
err
=
Error
(
msg
)
;
console
.
error
(
err
)
;
throw
err
;
}
const
{
deferred
stack
}
=
this
.
_requests
.
shift
(
)
;
callFunctionWithAsyncStack
(
(
)
=
>
{
if
(
packet
.
error
)
{
let
message
;
if
(
packet
.
error
&
&
packet
.
message
)
{
message
=
"
Protocol
error
(
"
+
packet
.
error
+
"
)
:
"
+
packet
.
message
;
}
else
{
message
=
packet
.
error
;
}
deferred
.
reject
(
message
)
;
}
else
{
deferred
.
resolve
(
packet
)
;
}
}
stack
"
DevTools
RDP
"
)
;
}
hasRequests
(
)
{
return
!
!
this
.
_requests
.
length
;
}
waitForRequestsToSettle
(
)
{
return
settleAll
(
this
.
_requests
.
map
(
(
{
deferred
}
)
=
>
deferred
.
promise
)
)
;
}
}
exports
.
Front
=
Front
;
