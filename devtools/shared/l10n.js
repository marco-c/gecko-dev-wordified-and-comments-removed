"
use
strict
"
;
const
parsePropertiesFile
=
require
(
"
.
/
node
-
properties
/
node
-
properties
"
)
;
const
{
sprintf
}
=
require
(
"
.
/
sprintfjs
/
sprintf
"
)
;
const
propertiesMap
=
{
}
;
const
reqShared
=
require
.
context
(
"
raw
!
devtools
/
shared
/
locales
/
"
true
/
^
.
*
\
.
properties
/
)
;
const
reqClient
=
require
.
context
(
"
raw
!
devtools
/
client
/
locales
/
"
true
/
^
.
*
\
.
properties
/
)
;
const
reqStartup
=
require
.
context
(
"
raw
!
devtools
/
startup
/
locales
/
"
true
/
^
.
*
\
.
properties
/
)
;
const
reqGlobal
=
require
.
context
(
"
raw
!
toolkit
/
locales
/
"
true
/
^
.
*
\
.
properties
/
)
;
const
numberFormatters
=
new
Map
(
)
;
const
getNumberFormatter
=
function
(
decimals
)
{
let
formatter
=
numberFormatters
.
get
(
decimals
)
;
if
(
!
formatter
)
{
formatter
=
Intl
.
NumberFormat
(
undefined
{
maximumFractionDigits
:
decimals
minimumFractionDigits
:
decimals
}
)
;
numberFormatters
.
set
(
decimals
formatter
)
;
}
return
formatter
;
}
;
function
getProperties
(
url
)
{
if
(
!
propertiesMap
[
url
]
)
{
const
index
=
url
.
lastIndexOf
(
"
/
"
)
;
const
baseName
=
"
.
"
+
url
.
substr
(
index
)
;
let
reqFn
;
if
(
/
^
toolkit
/
.
test
(
url
)
)
{
reqFn
=
reqGlobal
;
}
else
if
(
/
^
devtools
\
/
shared
/
.
test
(
url
)
)
{
reqFn
=
reqShared
;
}
else
if
(
/
^
devtools
\
/
startup
/
.
test
(
url
)
)
{
reqFn
=
reqStartup
;
}
else
{
reqFn
=
reqClient
;
}
propertiesMap
[
url
]
=
parsePropertiesFile
(
reqFn
(
baseName
)
)
;
}
return
propertiesMap
[
url
]
;
}
function
LocalizationHelper
(
stringBundleName
)
{
this
.
stringBundleName
=
stringBundleName
;
}
LocalizationHelper
.
prototype
=
{
getStr
:
function
(
name
)
{
const
properties
=
getProperties
(
this
.
stringBundleName
)
;
if
(
name
in
properties
)
{
return
properties
[
name
]
;
}
throw
new
Error
(
"
No
localization
found
for
[
"
+
name
+
"
]
"
)
;
}
getFormatStr
:
function
(
name
.
.
.
args
)
{
return
sprintf
(
this
.
getStr
(
name
)
.
.
.
args
)
;
}
getFormatStrWithNumbers
:
function
(
name
.
.
.
args
)
{
const
newArgs
=
args
.
map
(
x
=
>
{
return
typeof
x
=
=
"
number
"
?
this
.
numberWithDecimals
(
x
2
)
:
x
;
}
)
;
return
this
.
getFormatStr
(
name
.
.
.
newArgs
)
;
}
numberWithDecimals
:
function
(
number
decimals
=
0
)
{
if
(
number
=
=
=
(
number
|
0
)
)
{
return
getNumberFormatter
(
0
)
.
format
(
number
)
;
}
if
(
isNaN
(
number
)
|
|
number
=
=
=
null
)
{
return
getNumberFormatter
(
0
)
.
format
(
0
)
;
}
const
localized
=
getNumberFormatter
(
decimals
)
.
format
(
number
)
;
const
localizedNumber
=
localized
*
1
;
if
(
localizedNumber
=
=
=
(
localizedNumber
|
0
)
)
{
return
getNumberFormatter
(
0
)
.
format
(
localizedNumber
)
;
}
return
localized
;
}
}
;
function
getPropertiesForNode
(
node
)
{
const
bundleEl
=
node
.
closest
(
"
[
data
-
localization
-
bundle
]
"
)
;
if
(
!
bundleEl
)
{
return
null
;
}
const
propertiesUrl
=
bundleEl
.
getAttribute
(
"
data
-
localization
-
bundle
"
)
;
return
getProperties
(
propertiesUrl
)
;
}
function
localizeMarkup
(
root
)
{
const
elements
=
root
.
querySelectorAll
(
"
[
data
-
localization
]
"
)
;
for
(
const
element
of
elements
)
{
const
properties
=
getPropertiesForNode
(
element
)
;
if
(
!
properties
)
{
continue
;
}
const
attributes
=
element
.
getAttribute
(
"
data
-
localization
"
)
.
split
(
"
;
"
)
;
for
(
const
attribute
of
attributes
)
{
const
[
name
value
]
=
attribute
.
trim
(
)
.
split
(
"
=
"
)
;
if
(
name
=
=
=
"
content
"
)
{
element
.
textContent
=
properties
[
value
]
;
}
else
{
element
.
setAttribute
(
name
properties
[
value
]
)
;
}
}
element
.
removeAttribute
(
"
data
-
localization
"
)
;
}
}
const
sharedL10N
=
new
LocalizationHelper
(
"
devtools
/
shared
/
locales
/
shared
.
properties
"
)
;
function
MultiLocalizationHelper
(
.
.
.
stringBundleNames
)
{
const
instances
=
stringBundleNames
.
map
(
bundle
=
>
{
return
new
LocalizationHelper
(
bundle
)
;
}
)
;
Object
.
getOwnPropertyNames
(
LocalizationHelper
.
prototype
)
.
map
(
name
=
>
(
{
name
:
name
descriptor
:
Object
.
getOwnPropertyDescriptor
(
LocalizationHelper
.
prototype
name
)
}
)
)
.
filter
(
(
{
descriptor
}
)
=
>
descriptor
.
value
instanceof
Function
)
.
forEach
(
method
=
>
{
this
[
method
.
name
]
=
(
.
.
.
args
)
=
>
{
for
(
const
l10n
of
instances
)
{
try
{
return
method
.
descriptor
.
value
.
apply
(
l10n
args
)
;
}
catch
(
e
)
{
}
}
return
null
;
}
;
}
)
;
}
exports
.
LocalizationHelper
=
LocalizationHelper
;
exports
.
localizeMarkup
=
localizeMarkup
;
exports
.
MultiLocalizationHelper
=
MultiLocalizationHelper
;
Object
.
defineProperty
(
exports
"
ELLIPSIS
"
{
get
:
(
)
=
>
sharedL10N
.
getStr
(
"
ellipsis
"
)
}
)
;
