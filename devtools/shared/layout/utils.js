"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
}
)
;
const
SHEET_TYPE
=
{
agent
:
"
AGENT_SHEET
"
user
:
"
USER_SHEET
"
author
:
"
AUTHOR_SHEET
"
}
;
loader
.
lazyRequireGetter
(
this
"
setIgnoreLayoutChanges
"
"
resource
:
/
/
devtools
/
server
/
actors
/
reflow
.
js
"
true
)
;
exports
.
setIgnoreLayoutChanges
=
(
.
.
.
args
)
=
>
this
.
setIgnoreLayoutChanges
(
.
.
.
args
)
;
const
utilsCache
=
new
WeakMap
(
)
;
function
utilsFor
(
win
)
{
if
(
!
utilsCache
.
has
(
win
)
)
{
utilsCache
.
set
(
win
win
.
windowUtils
)
;
}
return
utilsCache
.
get
(
win
)
;
}
function
isWindowIncluded
(
boundaryWindow
win
)
{
if
(
win
=
=
=
boundaryWindow
)
{
return
true
;
}
const
parent
=
win
.
parent
;
if
(
!
parent
|
|
parent
=
=
=
win
)
{
return
false
;
}
return
isWindowIncluded
(
boundaryWindow
parent
)
;
}
exports
.
isWindowIncluded
=
isWindowIncluded
;
const
getFrameElement
=
win
=
>
{
const
isTopWindow
=
win
&
&
DevToolsUtils
.
getTopWindow
(
win
)
=
=
=
win
;
return
isTopWindow
?
null
:
win
.
browsingContext
.
embedderElement
;
}
;
exports
.
getFrameElement
=
getFrameElement
;
function
getFrameOffsets
(
boundaryWindow
node
)
{
let
xOffset
=
0
;
let
yOffset
=
0
;
let
frameWin
=
getWindowFor
(
node
)
;
const
scale
=
getCurrentZoom
(
node
)
;
if
(
boundaryWindow
=
=
=
null
)
{
boundaryWindow
=
DevToolsUtils
.
getTopWindow
(
frameWin
)
;
}
else
if
(
typeof
boundaryWindow
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
No
boundaryWindow
given
.
Use
null
for
the
default
one
.
"
)
;
}
while
(
frameWin
!
=
=
boundaryWindow
)
{
const
frameElement
=
getFrameElement
(
frameWin
)
;
if
(
!
frameElement
)
{
break
;
}
const
frameRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
[
offsetTop
offsetLeft
]
=
getFrameContentOffset
(
frameElement
)
;
xOffset
+
=
frameRect
.
left
+
offsetLeft
;
yOffset
+
=
frameRect
.
top
+
offsetTop
;
frameWin
=
frameWin
.
parent
;
}
return
[
xOffset
*
scale
yOffset
*
scale
]
;
}
exports
.
getFrameOffsets
=
getFrameOffsets
;
function
getAdjustedQuads
(
boundaryWindow
node
region
{
ignoreZoom
ignoreScroll
}
=
{
}
)
{
if
(
!
node
|
|
!
node
.
getBoxQuads
)
{
return
[
]
;
}
const
quads
=
node
.
getBoxQuads
(
{
box
:
region
relativeTo
:
boundaryWindow
.
document
createFramesForSuppressedWhitespace
:
false
}
)
;
if
(
!
quads
.
length
)
{
return
[
]
;
}
const
scale
=
ignoreZoom
?
1
:
getCurrentZoom
(
node
)
;
const
{
scrollX
scrollY
}
=
ignoreScroll
?
{
scrollX
:
0
scrollY
:
0
}
:
boundaryWindow
;
const
xOffset
=
scrollX
*
scale
;
const
yOffset
=
scrollY
*
scale
;
const
adjustedQuads
=
[
]
;
for
(
const
quad
of
quads
)
{
const
bounds
=
quad
.
getBounds
(
)
;
adjustedQuads
.
push
(
{
p1
:
{
w
:
quad
.
p1
.
w
*
scale
x
:
quad
.
p1
.
x
*
scale
+
xOffset
y
:
quad
.
p1
.
y
*
scale
+
yOffset
z
:
quad
.
p1
.
z
*
scale
}
p2
:
{
w
:
quad
.
p2
.
w
*
scale
x
:
quad
.
p2
.
x
*
scale
+
xOffset
y
:
quad
.
p2
.
y
*
scale
+
yOffset
z
:
quad
.
p2
.
z
*
scale
}
p3
:
{
w
:
quad
.
p3
.
w
*
scale
x
:
quad
.
p3
.
x
*
scale
+
xOffset
y
:
quad
.
p3
.
y
*
scale
+
yOffset
z
:
quad
.
p3
.
z
*
scale
}
p4
:
{
w
:
quad
.
p4
.
w
*
scale
x
:
quad
.
p4
.
x
*
scale
+
xOffset
y
:
quad
.
p4
.
y
*
scale
+
yOffset
z
:
quad
.
p4
.
z
*
scale
}
bounds
:
{
bottom
:
bounds
.
bottom
*
scale
+
yOffset
height
:
bounds
.
height
*
scale
left
:
bounds
.
left
*
scale
+
xOffset
right
:
bounds
.
right
*
scale
+
xOffset
top
:
bounds
.
top
*
scale
+
yOffset
width
:
bounds
.
width
*
scale
x
:
bounds
.
x
*
scale
+
xOffset
y
:
bounds
.
y
*
scale
+
yOffset
}
}
)
;
}
return
adjustedQuads
;
}
exports
.
getAdjustedQuads
=
getAdjustedQuads
;
function
getRect
(
boundaryWindow
node
contentWindow
)
{
let
frameWin
=
node
.
ownerDocument
.
defaultView
;
const
clientRect
=
node
.
getBoundingClientRect
(
)
;
if
(
boundaryWindow
=
=
=
null
)
{
boundaryWindow
=
DevToolsUtils
.
getTopWindow
(
frameWin
)
;
}
else
if
(
typeof
boundaryWindow
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
No
boundaryWindow
given
.
Use
null
for
the
default
one
.
"
)
;
}
const
rect
=
{
top
:
clientRect
.
top
+
contentWindow
.
pageYOffset
left
:
clientRect
.
left
+
contentWindow
.
pageXOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
while
(
frameWin
!
=
=
boundaryWindow
)
{
const
frameElement
=
getFrameElement
(
frameWin
)
;
if
(
!
frameElement
)
{
break
;
}
const
frameRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
[
offsetTop
offsetLeft
]
=
getFrameContentOffset
(
frameElement
)
;
rect
.
top
+
=
frameRect
.
top
+
offsetTop
;
rect
.
left
+
=
frameRect
.
left
+
offsetLeft
;
frameWin
=
frameWin
.
parent
;
}
return
rect
;
}
exports
.
getRect
=
getRect
;
function
getNodeBounds
(
boundaryWindow
node
)
{
if
(
!
node
)
{
return
null
;
}
const
{
scrollX
scrollY
}
=
boundaryWindow
;
const
scale
=
getCurrentZoom
(
node
)
;
let
offsetLeft
=
0
;
let
offsetTop
=
0
;
let
el
=
node
;
while
(
el
?
.
parentNode
)
{
offsetLeft
+
=
el
.
offsetLeft
;
offsetTop
+
=
el
.
offsetTop
;
el
=
el
.
offsetParent
;
}
el
=
node
;
while
(
el
?
.
parentNode
)
{
if
(
el
.
scrollTop
)
{
offsetTop
-
=
el
.
scrollTop
;
}
if
(
el
.
scrollLeft
)
{
offsetLeft
-
=
el
.
scrollLeft
;
}
el
=
el
.
parentNode
;
}
let
[
xOffset
yOffset
]
=
getFrameOffsets
(
boundaryWindow
node
)
;
xOffset
+
=
(
offsetLeft
+
scrollX
)
*
scale
;
yOffset
+
=
(
offsetTop
+
scrollY
)
*
scale
;
const
width
=
node
.
offsetWidth
*
scale
;
const
height
=
node
.
offsetHeight
*
scale
;
return
{
p1
:
{
x
:
xOffset
y
:
yOffset
}
p2
:
{
x
:
xOffset
+
width
y
:
yOffset
}
p3
:
{
x
:
xOffset
+
width
y
:
yOffset
+
height
}
p4
:
{
x
:
xOffset
y
:
yOffset
+
height
}
top
:
yOffset
right
:
xOffset
+
width
bottom
:
yOffset
+
height
left
:
xOffset
width
height
}
;
}
exports
.
getNodeBounds
=
getNodeBounds
;
function
safelyGetContentWindow
(
frame
)
{
if
(
frame
.
contentWindow
)
{
return
frame
.
contentWindow
;
}
const
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
walker
.
showSubDocuments
=
true
;
walker
.
showDocumentsAsNodes
=
true
;
walker
.
init
(
frame
)
;
walker
.
currentNode
=
frame
;
const
document
=
walker
.
nextNode
(
)
;
if
(
!
document
|
|
!
document
.
defaultView
)
{
throw
new
Error
(
"
Couldn
'
t
get
the
content
window
inside
frame
"
+
frame
)
;
}
return
document
.
defaultView
;
}
function
getFrameContentOffset
(
frame
)
{
const
style
=
safelyGetContentWindow
(
frame
)
.
getComputedStyle
(
frame
)
;
if
(
!
style
)
{
return
[
0
0
]
;
}
const
paddingTop
=
parseInt
(
style
.
getPropertyValue
(
"
padding
-
top
"
)
10
)
;
const
paddingLeft
=
parseInt
(
style
.
getPropertyValue
(
"
padding
-
left
"
)
10
)
;
const
borderTop
=
parseInt
(
style
.
getPropertyValue
(
"
border
-
top
-
width
"
)
10
)
;
const
borderLeft
=
parseInt
(
style
.
getPropertyValue
(
"
border
-
left
-
width
"
)
10
)
;
return
[
borderTop
+
paddingTop
borderLeft
+
paddingLeft
]
;
}
function
isNodeConnected
(
node
)
{
if
(
!
node
.
ownerDocument
|
|
!
node
.
ownerDocument
.
defaultView
)
{
return
false
;
}
try
{
return
!
(
node
.
compareDocumentPosition
(
node
.
ownerDocument
.
documentElement
)
&
node
.
DOCUMENT_POSITION_DISCONNECTED
)
;
}
catch
(
e
)
{
return
false
;
}
}
exports
.
isNodeConnected
=
isNodeConnected
;
const
isAnonymous
=
node
=
>
node
.
isNativeAnonymous
;
exports
.
isAnonymous
=
isAnonymous
;
exports
.
isNativeAnonymous
=
isAnonymous
;
function
isTemplateElement
(
node
)
{
return
(
node
.
ownerGlobal
&
&
node
.
ownerGlobal
.
HTMLTemplateElement
.
isInstance
(
node
)
)
;
}
exports
.
isTemplateElement
=
isTemplateElement
;
const
isShadowRoot
=
node
=
>
node
.
containingShadowRoot
=
=
node
;
exports
.
isShadowRoot
=
isShadowRoot
;
function
getShadowRootMode
(
node
)
{
return
isShadowRoot
(
node
)
?
node
.
mode
:
null
;
}
exports
.
getShadowRootMode
=
getShadowRootMode
;
function
isShadowHost
(
node
)
{
const
shadowRoot
=
node
.
openOrClosedShadowRoot
;
return
shadowRoot
&
&
shadowRoot
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
;
}
exports
.
isShadowHost
=
isShadowHost
;
function
isDirectShadowHostChild
(
node
)
{
if
(
isMarkerPseudoElement
(
node
)
|
|
isBeforePseudoElement
(
node
)
|
|
isAfterPseudoElement
(
node
)
|
|
node
.
isNativeAnonymous
)
{
return
false
;
}
const
parentNode
=
node
.
parentNode
;
return
parentNode
&
&
!
!
parentNode
.
openOrClosedShadowRoot
;
}
exports
.
isDirectShadowHostChild
=
isDirectShadowHostChild
;
function
isMarkerPseudoElement
(
node
)
{
return
node
.
nodeName
=
=
=
"
_moz_generated_content_marker
"
;
}
exports
.
isMarkerPseudoElement
=
isMarkerPseudoElement
;
function
isBeforePseudoElement
(
node
)
{
return
node
.
nodeName
=
=
=
"
_moz_generated_content_before
"
;
}
exports
.
isBeforePseudoElement
=
isBeforePseudoElement
;
function
isAfterPseudoElement
(
node
)
{
return
node
.
nodeName
=
=
=
"
_moz_generated_content_after
"
;
}
exports
.
isAfterPseudoElement
=
isAfterPseudoElement
;
function
getCurrentZoom
(
node
)
{
const
win
=
getWindowFor
(
node
)
;
if
(
!
win
)
{
throw
new
Error
(
"
Unable
to
get
the
zoom
from
the
given
argument
.
"
)
;
}
return
win
.
browsingContext
?
.
fullZoom
|
|
1
.
0
;
}
exports
.
getCurrentZoom
=
getCurrentZoom
;
function
getDisplayPixelRatio
(
node
)
{
const
win
=
getWindowFor
(
node
)
;
return
win
.
devicePixelRatio
/
getCurrentZoom
(
node
)
;
}
exports
.
getDisplayPixelRatio
=
getDisplayPixelRatio
;
function
getWindowDimensions
(
window
)
{
const
windowUtils
=
utilsFor
(
window
)
;
let
{
width
height
}
=
windowUtils
.
getRootBounds
(
)
;
if
(
!
width
|
|
!
height
)
{
width
=
window
.
innerWidth
+
window
.
scrollMaxX
-
window
.
scrollMinX
;
height
=
window
.
innerHeight
+
window
.
scrollMaxY
-
window
.
scrollMinY
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
width
-
=
scrollbarWidth
.
value
;
height
-
=
scrollbarHeight
.
value
;
}
return
{
width
height
}
;
}
exports
.
getWindowDimensions
=
getWindowDimensions
;
function
getViewportDimensions
(
window
)
{
const
windowUtils
=
utilsFor
(
window
)
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
const
width
=
window
.
innerWidth
-
scrollbarWidth
.
value
;
const
height
=
window
.
innerHeight
-
scrollbarHeight
.
value
;
return
{
width
height
}
;
}
exports
.
getViewportDimensions
=
getViewportDimensions
;
function
getWindowFor
(
node
)
{
if
(
Node
.
isInstance
(
node
)
)
{
if
(
node
.
nodeType
=
=
=
node
.
DOCUMENT_NODE
)
{
return
node
.
defaultView
;
}
return
node
.
ownerDocument
.
defaultView
;
}
else
if
(
node
instanceof
Ci
.
nsIDOMWindow
)
{
return
node
;
}
return
null
;
}
function
loadSheet
(
window
url
type
=
"
agent
"
)
{
if
(
!
(
type
in
SHEET_TYPE
)
)
{
type
=
"
agent
"
;
}
const
windowUtils
=
utilsFor
(
window
)
;
try
{
windowUtils
.
loadSheetUsingURIString
(
url
windowUtils
[
SHEET_TYPE
[
type
]
]
)
;
}
catch
(
e
)
{
}
}
exports
.
loadSheet
=
loadSheet
;
function
removeSheet
(
window
url
type
=
"
agent
"
)
{
if
(
!
(
type
in
SHEET_TYPE
)
)
{
type
=
"
agent
"
;
}
const
windowUtils
=
utilsFor
(
window
)
;
try
{
windowUtils
.
removeSheetUsingURIString
(
url
windowUtils
[
SHEET_TYPE
[
type
]
]
)
;
}
catch
(
e
)
{
}
}
exports
.
removeSheet
=
removeSheet
;
function
getUntransformedQuad
(
node
region
=
"
border
"
)
{
const
matrix
=
node
.
getTransformToViewport
(
)
;
const
inverse
=
matrix
.
inverse
(
)
;
const
win
=
node
.
ownerGlobal
;
const
quads
=
getAdjustedQuads
(
win
node
region
{
ignoreZoom
:
true
}
)
;
const
p1
=
new
DOMPoint
(
quads
[
0
]
.
p1
.
x
quads
[
0
]
.
p1
.
y
)
;
const
p2
=
new
DOMPoint
(
quads
[
0
]
.
p2
.
x
quads
[
0
]
.
p2
.
y
)
;
const
p3
=
new
DOMPoint
(
quads
[
0
]
.
p3
.
x
quads
[
0
]
.
p3
.
y
)
;
const
p4
=
new
DOMPoint
(
quads
[
0
]
.
p4
.
x
quads
[
0
]
.
p4
.
y
)
;
const
ip1
=
inverse
.
transformPoint
(
p1
)
;
const
ip2
=
inverse
.
transformPoint
(
p2
)
;
const
ip3
=
inverse
.
transformPoint
(
p3
)
;
const
ip4
=
inverse
.
transformPoint
(
p4
)
;
const
quad
=
new
DOMQuad
(
{
x
:
ip1
.
x
y
:
ip1
.
y
}
{
x
:
ip2
.
x
y
:
ip2
.
y
}
{
x
:
ip3
.
x
y
:
ip3
.
y
}
{
x
:
ip4
.
x
y
:
ip4
.
y
}
)
;
const
style
=
win
.
getComputedStyle
(
node
)
;
const
leftAdjustment
=
parseInt
(
style
.
borderLeftWidth
10
)
|
|
0
;
const
topAdjustment
=
parseInt
(
style
.
borderTopWidth
10
)
|
|
0
;
quad
.
p1
.
x
-
=
leftAdjustment
;
quad
.
p2
.
x
-
=
leftAdjustment
;
quad
.
p3
.
x
-
=
leftAdjustment
;
quad
.
p4
.
x
-
=
leftAdjustment
;
quad
.
p1
.
y
-
=
topAdjustment
;
quad
.
p2
.
y
-
=
topAdjustment
;
quad
.
p3
.
y
-
=
topAdjustment
;
quad
.
p4
.
y
-
=
topAdjustment
;
while
(
node
)
{
const
nodeStyle
=
win
.
getComputedStyle
(
node
)
;
const
borderLeftWidth
=
parseInt
(
nodeStyle
.
borderLeftWidth
10
)
|
|
0
;
const
borderTopWidth
=
parseInt
(
nodeStyle
.
borderTopWidth
10
)
|
|
0
;
const
leftOffset
=
node
.
offsetLeft
-
node
.
scrollLeft
+
borderLeftWidth
;
const
topOffset
=
node
.
offsetTop
-
node
.
scrollTop
+
borderTopWidth
;
quad
.
p1
.
x
+
=
leftOffset
;
quad
.
p2
.
x
+
=
leftOffset
;
quad
.
p3
.
x
+
=
leftOffset
;
quad
.
p4
.
x
+
=
leftOffset
;
quad
.
p1
.
y
+
=
topOffset
;
quad
.
p2
.
y
+
=
topOffset
;
quad
.
p3
.
y
+
=
topOffset
;
quad
.
p4
.
y
+
=
topOffset
;
node
=
node
.
offsetParent
;
}
return
quad
;
}
exports
.
getUntransformedQuad
=
getUntransformedQuad
;
function
getAbsoluteScrollOffsetsForNode
(
node
)
{
const
doc
=
node
.
ownerDocument
;
let
scrollTop
=
doc
.
documentElement
.
scrollTop
;
let
scrollLeft
=
doc
.
documentElement
.
scrollLeft
;
const
walker
=
doc
.
createTreeWalker
(
doc
.
body
NodeFilter
.
SHOW_ELEMENT
)
;
walker
.
currentNode
=
node
;
let
currentNode
=
walker
.
currentNode
;
while
(
currentNode
)
{
const
nodeScrollTop
=
currentNode
.
scrollTop
;
const
nodeScrollLeft
=
currentNode
.
scrollLeft
;
if
(
nodeScrollTop
|
|
nodeScrollLeft
)
{
scrollTop
+
=
nodeScrollTop
;
scrollLeft
+
=
nodeScrollLeft
;
}
currentNode
=
walker
.
parentNode
(
)
;
}
return
{
scrollLeft
scrollTop
}
;
}
exports
.
getAbsoluteScrollOffsetsForNode
=
getAbsoluteScrollOffsetsForNode
;
function
isFrame
(
node
)
{
const
className
=
ChromeUtils
.
getClassName
(
node
)
;
return
className
=
=
"
HTMLIFrameElement
"
|
|
className
=
=
"
HTMLFrameElement
"
;
}
function
isRemoteBrowserElement
(
node
)
{
return
(
ChromeUtils
.
getClassName
(
node
)
=
=
"
XULFrameElement
"
&
&
!
node
.
childNodes
.
length
&
&
node
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
)
;
}
exports
.
isRemoteBrowserElement
=
isRemoteBrowserElement
;
function
isRemoteFrame
(
node
)
{
if
(
isFrame
(
node
)
)
{
return
node
.
frameLoader
?
.
isRemoteFrame
;
}
if
(
isRemoteBrowserElement
(
node
)
)
{
return
true
;
}
return
false
;
}
exports
.
isRemoteFrame
=
isRemoteFrame
;
function
isFrameWithChildTarget
(
targetActor
node
)
{
if
(
isFrameBlockedByCSP
(
node
)
)
{
return
false
;
}
return
isRemoteFrame
(
node
)
|
|
(
isFrame
(
node
)
&
&
targetActor
.
ignoreSubFrames
)
;
}
exports
.
isFrameWithChildTarget
=
isFrameWithChildTarget
;
function
isFrameBlockedByCSP
(
node
)
{
if
(
!
isFrame
(
node
)
)
{
return
false
;
}
if
(
!
node
.
src
)
{
return
false
;
}
let
uri
;
try
{
uri
=
lazy
.
NetUtil
.
newURI
(
node
.
src
)
;
}
catch
(
e
)
{
return
false
;
}
const
res
=
node
.
ownerDocument
.
csp
.
shouldLoad
(
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
null
null
uri
null
false
)
;
return
res
!
=
=
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
exports
.
isFrameBlockedByCSP
=
isFrameBlockedByCSP
;
