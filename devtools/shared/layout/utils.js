"
use
strict
"
;
const
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
SHEET_TYPE
=
{
"
agent
"
:
"
AGENT_SHEET
"
"
user
"
:
"
USER_SHEET
"
"
author
"
:
"
AUTHOR_SHEET
"
}
;
loader
.
lazyRequireGetter
(
this
"
setIgnoreLayoutChanges
"
"
devtools
/
server
/
actors
/
reflow
"
true
)
;
exports
.
setIgnoreLayoutChanges
=
(
.
.
.
args
)
=
>
this
.
setIgnoreLayoutChanges
(
.
.
.
args
)
;
const
utilsCache
=
new
WeakMap
(
)
;
function
utilsFor
(
win
)
{
if
(
!
utilsCache
.
has
(
win
)
)
{
utilsCache
.
set
(
win
win
.
windowUtils
)
;
}
return
utilsCache
.
get
(
win
)
;
}
function
getTopWindow
(
win
)
{
const
docShell
=
win
.
docShell
;
if
(
!
docShell
.
isMozBrowser
)
{
return
win
.
top
;
}
const
topDocShell
=
docShell
.
getSameTypeRootTreeItemIgnoreBrowserBoundaries
(
)
;
return
topDocShell
?
topDocShell
.
contentViewer
.
DOMDocument
.
defaultView
:
null
;
}
exports
.
getTopWindow
=
getTopWindow
;
const
isTopWindow
=
win
=
>
win
&
&
getTopWindow
(
win
)
=
=
=
win
;
exports
.
isTopWindow
=
isTopWindow
;
function
isWindowIncluded
(
boundaryWindow
win
)
{
if
(
win
=
=
=
boundaryWindow
)
{
return
true
;
}
const
parent
=
getParentWindow
(
win
)
;
if
(
!
parent
|
|
parent
=
=
=
win
)
{
return
false
;
}
return
isWindowIncluded
(
boundaryWindow
parent
)
;
}
exports
.
isWindowIncluded
=
isWindowIncluded
;
function
getParentWindow
(
win
)
{
if
(
isTopWindow
(
win
)
)
{
return
null
;
}
const
docShell
=
win
.
docShell
;
if
(
!
docShell
.
isMozBrowser
)
{
return
win
.
parent
;
}
const
parentDocShell
=
docShell
.
getSameTypeParentIgnoreBrowserBoundaries
(
)
;
return
parentDocShell
?
parentDocShell
.
contentViewer
.
DOMDocument
.
defaultView
:
null
;
}
exports
.
getParentWindow
=
getParentWindow
;
const
getFrameElement
=
(
win
)
=
>
isTopWindow
(
win
)
?
null
:
utilsFor
(
win
)
.
containerElement
;
exports
.
getFrameElement
=
getFrameElement
;
function
getFrameOffsets
(
boundaryWindow
node
)
{
let
xOffset
=
0
;
let
yOffset
=
0
;
let
frameWin
=
getWindowFor
(
node
)
;
const
scale
=
getCurrentZoom
(
node
)
;
if
(
boundaryWindow
=
=
=
null
)
{
boundaryWindow
=
getTopWindow
(
frameWin
)
;
}
else
if
(
typeof
boundaryWindow
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
No
boundaryWindow
given
.
Use
null
for
the
default
one
.
"
)
;
}
while
(
frameWin
!
=
=
boundaryWindow
)
{
const
frameElement
=
getFrameElement
(
frameWin
)
;
if
(
!
frameElement
)
{
break
;
}
const
frameRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
[
offsetTop
offsetLeft
]
=
getFrameContentOffset
(
frameElement
)
;
xOffset
+
=
frameRect
.
left
+
offsetLeft
;
yOffset
+
=
frameRect
.
top
+
offsetTop
;
frameWin
=
getParentWindow
(
frameWin
)
;
}
return
[
xOffset
*
scale
yOffset
*
scale
]
;
}
exports
.
getFrameOffsets
=
getFrameOffsets
;
function
getAdjustedQuads
(
boundaryWindow
node
region
{
ignoreZoom
}
=
{
}
)
{
if
(
!
node
|
|
!
node
.
getBoxQuads
)
{
return
[
]
;
}
const
quads
=
node
.
getBoxQuads
(
{
box
:
region
relativeTo
:
boundaryWindow
.
document
}
)
;
if
(
!
quads
.
length
)
{
return
[
]
;
}
const
scale
=
ignoreZoom
?
1
:
getCurrentZoom
(
node
)
;
const
{
scrollX
scrollY
}
=
boundaryWindow
;
const
xOffset
=
scrollX
*
scale
;
const
yOffset
=
scrollY
*
scale
;
const
adjustedQuads
=
[
]
;
for
(
const
quad
of
quads
)
{
const
bounds
=
quad
.
getBounds
(
)
;
adjustedQuads
.
push
(
{
p1
:
{
w
:
quad
.
p1
.
w
*
scale
x
:
quad
.
p1
.
x
*
scale
+
xOffset
y
:
quad
.
p1
.
y
*
scale
+
yOffset
z
:
quad
.
p1
.
z
*
scale
}
p2
:
{
w
:
quad
.
p2
.
w
*
scale
x
:
quad
.
p2
.
x
*
scale
+
xOffset
y
:
quad
.
p2
.
y
*
scale
+
yOffset
z
:
quad
.
p2
.
z
*
scale
}
p3
:
{
w
:
quad
.
p3
.
w
*
scale
x
:
quad
.
p3
.
x
*
scale
+
xOffset
y
:
quad
.
p3
.
y
*
scale
+
yOffset
z
:
quad
.
p3
.
z
*
scale
}
p4
:
{
w
:
quad
.
p4
.
w
*
scale
x
:
quad
.
p4
.
x
*
scale
+
xOffset
y
:
quad
.
p4
.
y
*
scale
+
yOffset
z
:
quad
.
p4
.
z
*
scale
}
bounds
:
{
bottom
:
bounds
.
bottom
*
scale
+
yOffset
height
:
bounds
.
height
*
scale
left
:
bounds
.
left
*
scale
+
xOffset
right
:
bounds
.
right
*
scale
+
xOffset
top
:
bounds
.
top
*
scale
+
yOffset
width
:
bounds
.
width
*
scale
x
:
bounds
.
x
*
scale
+
xOffset
y
:
bounds
.
y
*
scale
+
yOffset
}
}
)
;
}
return
adjustedQuads
;
}
exports
.
getAdjustedQuads
=
getAdjustedQuads
;
function
getRect
(
boundaryWindow
node
contentWindow
)
{
let
frameWin
=
node
.
ownerDocument
.
defaultView
;
const
clientRect
=
node
.
getBoundingClientRect
(
)
;
if
(
boundaryWindow
=
=
=
null
)
{
boundaryWindow
=
getTopWindow
(
frameWin
)
;
}
else
if
(
typeof
boundaryWindow
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
No
boundaryWindow
given
.
Use
null
for
the
default
one
.
"
)
;
}
const
rect
=
{
top
:
clientRect
.
top
+
contentWindow
.
pageYOffset
left
:
clientRect
.
left
+
contentWindow
.
pageXOffset
width
:
clientRect
.
width
height
:
clientRect
.
height
}
;
while
(
frameWin
!
=
=
boundaryWindow
)
{
const
frameElement
=
getFrameElement
(
frameWin
)
;
if
(
!
frameElement
)
{
break
;
}
const
frameRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
[
offsetTop
offsetLeft
]
=
getFrameContentOffset
(
frameElement
)
;
rect
.
top
+
=
frameRect
.
top
+
offsetTop
;
rect
.
left
+
=
frameRect
.
left
+
offsetLeft
;
frameWin
=
getParentWindow
(
frameWin
)
;
}
return
rect
;
}
exports
.
getRect
=
getRect
;
function
getNodeBounds
(
boundaryWindow
node
)
{
if
(
!
node
)
{
return
null
;
}
const
{
scrollX
scrollY
}
=
boundaryWindow
;
const
scale
=
getCurrentZoom
(
node
)
;
let
offsetLeft
=
0
;
let
offsetTop
=
0
;
let
el
=
node
;
while
(
el
&
&
el
.
parentNode
)
{
offsetLeft
+
=
el
.
offsetLeft
;
offsetTop
+
=
el
.
offsetTop
;
el
=
el
.
offsetParent
;
}
el
=
node
;
while
(
el
&
&
el
.
parentNode
)
{
if
(
el
.
scrollTop
)
{
offsetTop
-
=
el
.
scrollTop
;
}
if
(
el
.
scrollLeft
)
{
offsetLeft
-
=
el
.
scrollLeft
;
}
el
=
el
.
parentNode
;
}
let
[
xOffset
yOffset
]
=
getFrameOffsets
(
boundaryWindow
node
)
;
xOffset
+
=
(
offsetLeft
+
scrollX
)
*
scale
;
yOffset
+
=
(
offsetTop
+
scrollY
)
*
scale
;
const
width
=
node
.
offsetWidth
*
scale
;
const
height
=
node
.
offsetHeight
*
scale
;
return
{
p1
:
{
x
:
xOffset
y
:
yOffset
}
p2
:
{
x
:
xOffset
+
width
y
:
yOffset
}
p3
:
{
x
:
xOffset
+
width
y
:
yOffset
+
height
}
p4
:
{
x
:
xOffset
y
:
yOffset
+
height
}
top
:
yOffset
right
:
xOffset
+
width
bottom
:
yOffset
+
height
left
:
xOffset
width
height
}
;
}
exports
.
getNodeBounds
=
getNodeBounds
;
function
safelyGetContentWindow
(
frame
)
{
if
(
frame
.
contentWindow
)
{
return
frame
.
contentWindow
;
}
const
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
walker
.
showSubDocuments
=
true
;
walker
.
showDocumentsAsNodes
=
true
;
walker
.
init
(
frame
nodeFilterConstants
.
SHOW_ALL
)
;
walker
.
currentNode
=
frame
;
const
document
=
walker
.
nextNode
(
)
;
if
(
!
document
|
|
!
document
.
defaultView
)
{
throw
new
Error
(
"
Couldn
'
t
get
the
content
window
inside
frame
"
+
frame
)
;
}
return
document
.
defaultView
;
}
function
getFrameContentOffset
(
frame
)
{
const
style
=
safelyGetContentWindow
(
frame
)
.
getComputedStyle
(
frame
)
;
if
(
!
style
)
{
return
[
0
0
]
;
}
const
paddingTop
=
parseInt
(
style
.
getPropertyValue
(
"
padding
-
top
"
)
10
)
;
const
paddingLeft
=
parseInt
(
style
.
getPropertyValue
(
"
padding
-
left
"
)
10
)
;
const
borderTop
=
parseInt
(
style
.
getPropertyValue
(
"
border
-
top
-
width
"
)
10
)
;
const
borderLeft
=
parseInt
(
style
.
getPropertyValue
(
"
border
-
left
-
width
"
)
10
)
;
return
[
borderTop
+
paddingTop
borderLeft
+
paddingLeft
]
;
}
function
isNodeConnected
(
node
)
{
if
(
!
node
.
ownerDocument
|
|
!
node
.
ownerDocument
.
defaultView
)
{
return
false
;
}
try
{
return
!
(
node
.
compareDocumentPosition
(
node
.
ownerDocument
.
documentElement
)
&
node
.
DOCUMENT_POSITION_DISCONNECTED
)
;
}
catch
(
e
)
{
return
false
;
}
}
exports
.
isNodeConnected
=
isNodeConnected
;
function
getRootBindingParent
(
node
)
{
let
parent
;
const
doc
=
node
.
ownerDocument
;
if
(
!
doc
)
{
return
node
;
}
while
(
(
parent
=
doc
.
getBindingParent
(
node
)
)
)
{
node
=
parent
;
}
return
node
;
}
exports
.
getRootBindingParent
=
getRootBindingParent
;
function
getBindingParent
(
node
)
{
const
doc
=
node
.
ownerDocument
;
if
(
!
doc
)
{
return
null
;
}
const
parent
=
doc
.
getBindingParent
(
node
)
;
if
(
!
parent
)
{
return
null
;
}
return
parent
;
}
exports
.
getBindingParent
=
getBindingParent
;
const
isAnonymous
=
(
node
)
=
>
getRootBindingParent
(
node
)
!
=
=
node
;
exports
.
isAnonymous
=
isAnonymous
;
const
hasBindingParent
=
(
node
)
=
>
!
!
getBindingParent
(
node
)
;
const
isNativeAnonymous
=
(
node
)
=
>
hasBindingParent
(
node
)
&
&
!
(
isXBLAnonymous
(
node
)
|
|
isShadowAnonymous
(
node
)
)
;
exports
.
isNativeAnonymous
=
isNativeAnonymous
;
function
isXBLAnonymous
(
node
)
{
const
parent
=
getBindingParent
(
node
)
;
if
(
!
parent
)
{
return
false
;
}
const
anonNodes
=
[
.
.
.
node
.
ownerDocument
.
getAnonymousNodes
(
parent
)
|
|
[
]
]
;
return
anonNodes
.
indexOf
(
node
)
>
-
1
;
}
exports
.
isXBLAnonymous
=
isXBLAnonymous
;
function
isShadowAnonymous
(
node
)
{
const
parent
=
getBindingParent
(
node
)
;
if
(
!
parent
)
{
return
false
;
}
return
parent
.
openOrClosedShadowRoot
&
&
parent
.
openOrClosedShadowRoot
.
contains
(
node
)
;
}
exports
.
isShadowAnonymous
=
isShadowAnonymous
;
function
isTemplateElement
(
node
)
{
return
node
.
ownerGlobal
&
&
node
instanceof
node
.
ownerGlobal
.
HTMLTemplateElement
;
}
exports
.
isTemplateElement
=
isTemplateElement
;
function
isShadowRoot
(
node
)
{
const
isFragment
=
node
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
;
return
isFragment
&
&
!
!
node
.
host
;
}
exports
.
isShadowRoot
=
isShadowRoot
;
function
getShadowRootMode
(
node
)
{
return
isShadowRoot
(
node
)
?
node
.
mode
:
null
;
}
exports
.
getShadowRootMode
=
getShadowRootMode
;
function
isShadowHost
(
node
)
{
const
shadowRoot
=
node
.
openOrClosedShadowRoot
;
return
shadowRoot
&
&
shadowRoot
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
;
}
exports
.
isShadowHost
=
isShadowHost
;
function
isDirectShadowHostChild
(
node
)
{
if
(
isBeforePseudoElement
(
node
)
|
|
isAfterPseudoElement
(
node
)
|
|
isNativeAnonymous
(
node
)
)
{
return
false
;
}
const
parentNode
=
node
.
parentNode
;
return
parentNode
&
&
!
!
parentNode
.
openOrClosedShadowRoot
;
}
exports
.
isDirectShadowHostChild
=
isDirectShadowHostChild
;
function
isBeforePseudoElement
(
node
)
{
return
node
.
nodeName
=
=
=
"
_moz_generated_content_before
"
;
}
exports
.
isBeforePseudoElement
=
isBeforePseudoElement
;
function
isAfterPseudoElement
(
node
)
{
return
node
.
nodeName
=
=
=
"
_moz_generated_content_after
"
;
}
exports
.
isAfterPseudoElement
=
isAfterPseudoElement
;
function
getCurrentZoom
(
node
)
{
const
win
=
getWindowFor
(
node
)
;
if
(
!
win
)
{
throw
new
Error
(
"
Unable
to
get
the
zoom
from
the
given
argument
.
"
)
;
}
return
utilsFor
(
win
)
.
fullZoom
;
}
exports
.
getCurrentZoom
=
getCurrentZoom
;
function
getDisplayPixelRatio
(
node
)
{
const
win
=
getWindowFor
(
node
)
;
return
win
.
devicePixelRatio
/
utilsFor
(
win
)
.
fullZoom
;
}
exports
.
getDisplayPixelRatio
=
getDisplayPixelRatio
;
function
getWindowDimensions
(
window
)
{
const
windowUtils
=
utilsFor
(
window
)
;
let
{
width
height
}
=
windowUtils
.
getRootBounds
(
)
;
if
(
!
width
|
|
!
height
)
{
width
=
window
.
innerWidth
+
window
.
scrollMaxX
-
window
.
scrollMinX
;
height
=
window
.
innerHeight
+
window
.
scrollMaxY
-
window
.
scrollMinY
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
width
-
=
scrollbarWidth
.
value
;
height
-
=
scrollbarHeight
.
value
;
}
return
{
width
height
}
;
}
exports
.
getWindowDimensions
=
getWindowDimensions
;
function
getViewportDimensions
(
window
)
{
const
windowUtils
=
utilsFor
(
window
)
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
const
width
=
window
.
innerWidth
-
scrollbarWidth
.
value
;
const
height
=
window
.
innerHeight
-
scrollbarHeight
.
value
;
return
{
width
height
}
;
}
exports
.
getViewportDimensions
=
getViewportDimensions
;
function
getWindowFor
(
node
)
{
if
(
Node
.
isInstance
(
node
)
)
{
if
(
node
.
nodeType
=
=
=
node
.
DOCUMENT_NODE
)
{
return
node
.
defaultView
;
}
return
node
.
ownerDocument
.
defaultView
;
}
else
if
(
node
instanceof
Ci
.
nsIDOMWindow
)
{
return
node
;
}
return
null
;
}
function
loadSheet
(
window
url
type
=
"
agent
"
)
{
if
(
!
(
type
in
SHEET_TYPE
)
)
{
type
=
"
agent
"
;
}
const
windowUtils
=
utilsFor
(
window
)
;
try
{
windowUtils
.
loadSheetUsingURIString
(
url
windowUtils
[
SHEET_TYPE
[
type
]
]
)
;
}
catch
(
e
)
{
}
}
exports
.
loadSheet
=
loadSheet
;
function
removeSheet
(
window
url
type
=
"
agent
"
)
{
if
(
!
(
type
in
SHEET_TYPE
)
)
{
type
=
"
agent
"
;
}
const
windowUtils
=
utilsFor
(
window
)
;
try
{
windowUtils
.
removeSheetUsingURIString
(
url
windowUtils
[
SHEET_TYPE
[
type
]
]
)
;
}
catch
(
e
)
{
}
}
exports
.
removeSheet
=
removeSheet
;
function
getUntransformedQuad
(
node
region
=
"
border
"
)
{
const
matrix
=
node
.
getTransformToViewport
(
)
;
const
inverse
=
matrix
.
inverse
(
)
;
const
win
=
node
.
ownerGlobal
;
const
quads
=
getAdjustedQuads
(
win
node
region
{
ignoreZoom
:
true
}
)
;
const
p1
=
new
DOMPoint
(
quads
[
0
]
.
p1
.
x
quads
[
0
]
.
p1
.
y
)
;
const
p2
=
new
DOMPoint
(
quads
[
0
]
.
p2
.
x
quads
[
0
]
.
p2
.
y
)
;
const
p3
=
new
DOMPoint
(
quads
[
0
]
.
p3
.
x
quads
[
0
]
.
p3
.
y
)
;
const
p4
=
new
DOMPoint
(
quads
[
0
]
.
p4
.
x
quads
[
0
]
.
p4
.
y
)
;
const
ip1
=
inverse
.
transformPoint
(
p1
)
;
const
ip2
=
inverse
.
transformPoint
(
p2
)
;
const
ip3
=
inverse
.
transformPoint
(
p3
)
;
const
ip4
=
inverse
.
transformPoint
(
p4
)
;
const
quad
=
new
DOMQuad
(
{
x
:
ip1
.
x
y
:
ip1
.
y
}
{
x
:
ip2
.
x
y
:
ip2
.
y
}
{
x
:
ip3
.
x
y
:
ip3
.
y
}
{
x
:
ip4
.
x
y
:
ip4
.
y
}
)
;
const
style
=
win
.
getComputedStyle
(
node
)
;
const
leftAdjustment
=
parseInt
(
style
.
borderLeftWidth
10
)
|
|
0
;
const
topAdjustment
=
parseInt
(
style
.
borderTopWidth
10
)
|
|
0
;
quad
.
p1
.
x
-
=
leftAdjustment
;
quad
.
p2
.
x
-
=
leftAdjustment
;
quad
.
p3
.
x
-
=
leftAdjustment
;
quad
.
p4
.
x
-
=
leftAdjustment
;
quad
.
p1
.
y
-
=
topAdjustment
;
quad
.
p2
.
y
-
=
topAdjustment
;
quad
.
p3
.
y
-
=
topAdjustment
;
quad
.
p4
.
y
-
=
topAdjustment
;
while
(
node
)
{
const
nodeStyle
=
win
.
getComputedStyle
(
node
)
;
const
borderLeftWidth
=
parseInt
(
nodeStyle
.
borderLeftWidth
10
)
|
|
0
;
const
borderTopWidth
=
parseInt
(
nodeStyle
.
borderTopWidth
10
)
|
|
0
;
const
leftOffset
=
node
.
offsetLeft
-
node
.
scrollLeft
+
borderLeftWidth
;
const
topOffset
=
node
.
offsetTop
-
node
.
scrollTop
+
borderTopWidth
;
quad
.
p1
.
x
+
=
leftOffset
;
quad
.
p2
.
x
+
=
leftOffset
;
quad
.
p3
.
x
+
=
leftOffset
;
quad
.
p4
.
x
+
=
leftOffset
;
quad
.
p1
.
y
+
=
topOffset
;
quad
.
p2
.
y
+
=
topOffset
;
quad
.
p3
.
y
+
=
topOffset
;
quad
.
p4
.
y
+
=
topOffset
;
node
=
node
.
offsetParent
;
}
return
quad
;
}
exports
.
getUntransformedQuad
=
getUntransformedQuad
;
function
findFlexOrGridParentContainerForNode
(
node
type
)
{
const
doc
=
node
.
ownerDocument
;
const
win
=
doc
.
defaultView
;
const
treeWalker
=
doc
.
createTreeWalker
(
doc
.
body
NodeFilter
.
SHOW_ELEMENT
)
;
const
flexType
=
type
=
=
=
"
flex
"
;
const
gridType
=
type
=
=
=
"
grid
"
;
let
currentNode
=
null
;
treeWalker
.
currentNode
=
node
;
try
{
while
(
(
currentNode
=
treeWalker
.
parentNode
(
)
)
)
{
const
displayType
=
win
.
getComputedStyle
(
currentNode
)
.
display
;
if
(
!
displayType
)
{
break
;
}
if
(
flexType
&
&
displayType
.
includes
(
"
flex
"
)
)
{
if
(
isNodeAFlexItemInContainer
(
node
currentNode
)
)
{
return
currentNode
;
}
}
else
if
(
gridType
&
&
displayType
.
includes
(
"
grid
"
)
)
{
return
currentNode
;
}
else
if
(
displayType
=
=
=
"
contents
"
)
{
continue
;
}
break
;
}
}
catch
(
e
)
{
}
return
null
;
}
exports
.
findFlexOrGridParentContainerForNode
=
findFlexOrGridParentContainerForNode
;
function
isNodeAFlexItemInContainer
(
supposedItem
container
)
{
const
doc
=
container
.
ownerDocument
;
const
win
=
doc
.
defaultView
;
const
containerDisplayType
=
win
.
getComputedStyle
(
container
)
.
display
;
if
(
containerDisplayType
.
includes
(
"
flex
"
)
)
{
const
containerFlex
=
container
.
getAsFlexContainer
(
)
;
for
(
const
line
of
containerFlex
.
getLines
(
)
)
{
for
(
const
item
of
line
.
getItems
(
)
)
{
if
(
item
.
node
=
=
=
supposedItem
)
{
return
true
;
}
}
}
}
return
false
;
}
exports
.
isNodeAFlexItemInContainer
=
isNodeAFlexItemInContainer
;
function
getAbsoluteScrollOffsetsForNode
(
node
)
{
const
doc
=
node
.
ownerDocument
;
let
scrollTop
=
doc
.
documentElement
.
scrollTop
;
let
scrollLeft
=
doc
.
documentElement
.
scrollLeft
;
const
walker
=
doc
.
createTreeWalker
(
doc
.
body
NodeFilter
.
SHOW_ELEMENT
)
;
walker
.
currentNode
=
node
;
let
currentNode
=
walker
.
currentNode
;
while
(
currentNode
)
{
const
nodeScrollTop
=
currentNode
.
scrollTop
;
const
nodeScrollLeft
=
currentNode
.
scrollLeft
;
if
(
nodeScrollTop
|
|
nodeScrollLeft
)
{
scrollTop
+
=
nodeScrollTop
;
scrollLeft
+
=
nodeScrollLeft
;
}
currentNode
=
walker
.
parentNode
(
)
;
}
return
{
scrollLeft
scrollTop
}
;
}
exports
.
getAbsoluteScrollOffsetsForNode
=
getAbsoluteScrollOffsetsForNode
;
