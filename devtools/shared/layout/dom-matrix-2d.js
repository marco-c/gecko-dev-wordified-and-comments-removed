"
use
strict
"
;
const
scale
=
(
sx
=
1
sy
=
sx
)
=
>
[
sx
0
0
0
sy
0
0
0
1
]
;
exports
.
scale
=
scale
;
const
translate
=
(
tx
=
0
ty
=
tx
)
=
>
[
1
0
tx
0
1
ty
0
0
1
]
;
exports
.
translate
=
translate
;
const
identity
=
(
)
=
>
[
1
0
0
0
1
0
0
0
1
]
;
exports
.
identity
=
identity
;
const
multiply
=
(
M1
M2
)
=
>
{
let
c11
=
M1
[
0
]
*
M2
[
0
]
+
M1
[
1
]
*
M2
[
3
]
+
M1
[
2
]
*
M2
[
6
]
;
let
c12
=
M1
[
0
]
*
M2
[
1
]
+
M1
[
1
]
*
M2
[
4
]
+
M1
[
2
]
*
M2
[
7
]
;
let
c13
=
M1
[
0
]
*
M2
[
2
]
+
M1
[
1
]
*
M2
[
5
]
+
M1
[
2
]
*
M2
[
8
]
;
let
c21
=
M1
[
3
]
*
M2
[
0
]
+
M1
[
4
]
*
M2
[
3
]
+
M1
[
5
]
*
M2
[
6
]
;
let
c22
=
M1
[
3
]
*
M2
[
1
]
+
M1
[
4
]
*
M2
[
4
]
+
M1
[
5
]
*
M2
[
7
]
;
let
c23
=
M1
[
3
]
*
M2
[
2
]
+
M1
[
4
]
*
M2
[
5
]
+
M1
[
5
]
*
M2
[
8
]
;
let
c31
=
M1
[
6
]
*
M2
[
0
]
+
M1
[
7
]
*
M2
[
3
]
+
M1
[
8
]
*
M2
[
6
]
;
let
c32
=
M1
[
6
]
*
M2
[
1
]
+
M1
[
7
]
*
M2
[
4
]
+
M1
[
8
]
*
M2
[
7
]
;
let
c33
=
M1
[
6
]
*
M2
[
2
]
+
M1
[
7
]
*
M2
[
5
]
+
M1
[
8
]
*
M2
[
8
]
;
return
[
c11
c12
c13
c21
c22
c23
c31
c32
c33
]
;
}
;
exports
.
multiply
=
multiply
;
const
apply
=
(
M
P
)
=
>
[
M
[
0
]
*
P
[
0
]
+
M
[
1
]
*
P
[
1
]
+
M
[
2
]
M
[
3
]
*
P
[
0
]
+
M
[
4
]
*
P
[
1
]
+
M
[
5
]
]
;
exports
.
apply
=
apply
;
function
getNodeTransformOrigin
(
node
)
{
let
origin
=
node
.
ownerGlobal
.
getComputedStyle
(
node
)
.
transformOrigin
;
return
origin
.
split
(
/
/
)
.
map
(
parseFloat
)
;
}
exports
.
getNodeTransformOrigin
=
getNodeTransformOrigin
;
function
getNodeTransformationMatrix
(
node
)
{
let
t
=
node
.
ownerGlobal
.
getComputedStyle
(
node
)
.
transform
;
if
(
t
=
=
=
"
none
"
)
{
return
null
;
}
let
m
=
t
.
substring
(
t
.
indexOf
(
"
(
"
)
+
1
t
.
length
-
1
)
.
split
(
/
\
s
*
/
)
.
map
(
Number
)
;
let
[
a
b
c
d
e
f
]
=
m
;
if
(
m
.
length
=
=
=
16
)
{
c
=
m
[
4
]
;
d
=
m
[
5
]
;
e
=
m
[
12
]
;
f
=
m
[
13
]
;
}
return
[
a
c
e
b
d
f
0
0
1
]
;
}
exports
.
getNodeTransformationMatrix
=
getNodeTransformationMatrix
;
