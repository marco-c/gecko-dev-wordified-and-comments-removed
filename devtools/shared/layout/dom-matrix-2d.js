"
use
strict
"
;
const
scale
=
(
sx
=
1
sy
=
sx
)
=
>
[
sx
0
0
0
sy
0
0
0
1
]
;
exports
.
scale
=
scale
;
const
translate
=
(
tx
=
0
ty
=
tx
)
=
>
[
1
0
tx
0
1
ty
0
0
1
]
;
exports
.
translate
=
translate
;
const
reflectAboutY
=
(
)
=
>
[
-
1
0
0
0
1
0
0
0
1
]
;
exports
.
reflectAboutY
=
reflectAboutY
;
const
rotate
=
(
angle
=
0
)
=
>
{
const
cos
=
Math
.
cos
(
angle
)
;
const
sin
=
Math
.
sin
(
angle
)
;
return
[
cos
sin
0
-
sin
cos
0
0
0
1
]
;
}
;
exports
.
rotate
=
rotate
;
const
identity
=
(
)
=
>
[
1
0
0
0
1
0
0
0
1
]
;
exports
.
identity
=
identity
;
const
multiply
=
(
M1
M2
)
=
>
{
const
c11
=
M1
[
0
]
*
M2
[
0
]
+
M1
[
1
]
*
M2
[
3
]
+
M1
[
2
]
*
M2
[
6
]
;
const
c12
=
M1
[
0
]
*
M2
[
1
]
+
M1
[
1
]
*
M2
[
4
]
+
M1
[
2
]
*
M2
[
7
]
;
const
c13
=
M1
[
0
]
*
M2
[
2
]
+
M1
[
1
]
*
M2
[
5
]
+
M1
[
2
]
*
M2
[
8
]
;
const
c21
=
M1
[
3
]
*
M2
[
0
]
+
M1
[
4
]
*
M2
[
3
]
+
M1
[
5
]
*
M2
[
6
]
;
const
c22
=
M1
[
3
]
*
M2
[
1
]
+
M1
[
4
]
*
M2
[
4
]
+
M1
[
5
]
*
M2
[
7
]
;
const
c23
=
M1
[
3
]
*
M2
[
2
]
+
M1
[
4
]
*
M2
[
5
]
+
M1
[
5
]
*
M2
[
8
]
;
const
c31
=
M1
[
6
]
*
M2
[
0
]
+
M1
[
7
]
*
M2
[
3
]
+
M1
[
8
]
*
M2
[
6
]
;
const
c32
=
M1
[
6
]
*
M2
[
1
]
+
M1
[
7
]
*
M2
[
4
]
+
M1
[
8
]
*
M2
[
7
]
;
const
c33
=
M1
[
6
]
*
M2
[
2
]
+
M1
[
7
]
*
M2
[
5
]
+
M1
[
8
]
*
M2
[
8
]
;
return
[
c11
c12
c13
c21
c22
c23
c31
c32
c33
]
;
}
;
exports
.
multiply
=
multiply
;
const
apply
=
(
M
P
)
=
>
[
M
[
0
]
*
P
[
0
]
+
M
[
1
]
*
P
[
1
]
+
M
[
2
]
M
[
3
]
*
P
[
0
]
+
M
[
4
]
*
P
[
1
]
+
M
[
5
]
]
;
exports
.
apply
=
apply
;
const
isIdentity
=
M
=
>
M
[
0
]
=
=
=
1
&
&
M
[
1
]
=
=
=
0
&
&
M
[
2
]
=
=
=
0
&
&
M
[
3
]
=
=
=
0
&
&
M
[
4
]
=
=
=
1
&
&
M
[
5
]
=
=
=
0
&
&
M
[
6
]
=
=
=
0
&
&
M
[
7
]
=
=
=
0
&
&
M
[
8
]
=
=
=
1
;
exports
.
isIdentity
=
isIdentity
;
const
getBasis
=
(
u
v
)
=
>
{
const
uLength
=
Math
.
abs
(
Math
.
sqrt
(
u
[
0
]
*
*
2
+
u
[
1
]
*
*
2
)
)
;
const
vLength
=
Math
.
abs
(
Math
.
sqrt
(
v
[
0
]
*
*
2
+
v
[
1
]
*
*
2
)
)
;
const
basis
=
[
u
[
0
]
/
uLength
v
[
0
]
/
vLength
0
u
[
1
]
/
uLength
v
[
1
]
/
vLength
0
0
0
1
]
;
const
determinant
=
1
/
(
basis
[
0
]
*
basis
[
4
]
-
basis
[
1
]
*
basis
[
3
]
)
;
const
invertedBasis
=
[
basis
[
4
]
/
determinant
-
basis
[
1
]
/
determinant
0
-
basis
[
3
]
/
determinant
basis
[
0
]
/
determinant
0
0
0
1
]
;
return
{
basis
invertedBasis
uLength
vLength
}
;
}
;
exports
.
getBasis
=
getBasis
;
const
changeMatrixBase
=
(
M
basis
invertedBasis
)
=
>
{
return
multiply
(
invertedBasis
multiply
(
M
basis
)
)
;
}
;
exports
.
changeMatrixBase
=
changeMatrixBase
;
function
getNodeTransformationMatrix
(
node
ancestor
=
node
.
parentElement
)
{
const
{
a
b
c
d
e
f
}
=
ancestor
.
getTransformToParent
(
)
.
multiply
(
node
.
getTransformToAncestor
(
ancestor
)
)
;
return
[
a
c
e
b
d
f
0
0
1
]
;
}
exports
.
getNodeTransformationMatrix
=
getNodeTransformationMatrix
;
function
getWritingModeMatrix
(
size
style
)
{
let
currentMatrix
=
identity
(
)
;
const
{
width
height
}
=
size
;
const
{
direction
writingMode
}
=
style
;
switch
(
writingMode
)
{
case
"
horizontal
-
tb
"
:
break
;
case
"
vertical
-
rl
"
:
currentMatrix
=
multiply
(
translate
(
width
0
)
rotate
(
-
Math
.
PI
/
2
)
)
;
break
;
case
"
vertical
-
lr
"
:
currentMatrix
=
multiply
(
reflectAboutY
(
)
rotate
(
-
Math
.
PI
/
2
)
)
;
break
;
case
"
sideways
-
rl
"
:
currentMatrix
=
multiply
(
translate
(
width
0
)
rotate
(
-
Math
.
PI
/
2
)
)
;
break
;
case
"
sideways
-
lr
"
:
currentMatrix
=
multiply
(
rotate
(
Math
.
PI
/
2
)
translate
(
-
height
0
)
)
;
break
;
default
:
console
.
error
(
Unexpected
writing
-
mode
:
{
writingMode
}
)
;
}
switch
(
direction
)
{
case
"
ltr
"
:
break
;
case
"
rtl
"
:
let
rowLength
=
width
;
if
(
writingMode
!
=
"
horizontal
-
tb
"
)
{
rowLength
=
height
;
}
currentMatrix
=
multiply
(
currentMatrix
translate
(
rowLength
0
)
)
;
currentMatrix
=
multiply
(
currentMatrix
reflectAboutY
(
)
)
;
break
;
default
:
console
.
error
(
Unexpected
direction
:
{
direction
}
)
;
}
return
currentMatrix
;
}
exports
.
getWritingModeMatrix
=
getWritingModeMatrix
;
function
getCSSMatrixTransform
(
M
)
{
const
[
a
c
e
b
d
f
]
=
M
;
return
matrix
(
{
a
}
{
b
}
{
c
}
{
d
}
{
e
}
{
f
}
)
;
}
exports
.
getCSSMatrixTransform
=
getCSSMatrixTransform
;
