"
use
strict
"
;
const
scale
=
(
sx
=
1
sy
=
sx
)
=
>
[
sx
0
0
0
sy
0
0
0
1
]
;
exports
.
scale
=
scale
;
const
translate
=
(
tx
=
0
ty
=
tx
)
=
>
[
1
0
tx
0
1
ty
0
0
1
]
;
exports
.
translate
=
translate
;
const
identity
=
(
)
=
>
[
1
0
0
0
1
0
0
0
1
]
;
exports
.
identity
=
identity
;
const
multiply
=
(
M1
M2
)
=
>
{
let
c11
=
M1
[
0
]
*
M2
[
0
]
+
M1
[
1
]
*
M2
[
3
]
+
M1
[
2
]
*
M2
[
6
]
;
let
c12
=
M1
[
0
]
*
M2
[
1
]
+
M1
[
1
]
*
M2
[
4
]
+
M1
[
2
]
*
M2
[
7
]
;
let
c13
=
M1
[
0
]
*
M2
[
2
]
+
M1
[
1
]
*
M2
[
5
]
+
M1
[
2
]
*
M2
[
8
]
;
let
c21
=
M1
[
3
]
*
M2
[
0
]
+
M1
[
4
]
*
M2
[
3
]
+
M1
[
5
]
*
M2
[
6
]
;
let
c22
=
M1
[
3
]
*
M2
[
1
]
+
M1
[
4
]
*
M2
[
4
]
+
M1
[
5
]
*
M2
[
7
]
;
let
c23
=
M1
[
3
]
*
M2
[
2
]
+
M1
[
4
]
*
M2
[
5
]
+
M1
[
5
]
*
M2
[
8
]
;
let
c31
=
M1
[
6
]
*
M2
[
0
]
+
M1
[
7
]
*
M2
[
3
]
+
M1
[
8
]
*
M2
[
6
]
;
let
c32
=
M1
[
6
]
*
M2
[
1
]
+
M1
[
7
]
*
M2
[
4
]
+
M1
[
8
]
*
M2
[
7
]
;
let
c33
=
M1
[
6
]
*
M2
[
2
]
+
M1
[
7
]
*
M2
[
5
]
+
M1
[
8
]
*
M2
[
8
]
;
return
[
c11
c12
c13
c21
c22
c23
c31
c32
c33
]
;
}
;
exports
.
multiply
=
multiply
;
const
apply
=
(
M
P
)
=
>
[
M
[
0
]
*
P
[
0
]
+
M
[
1
]
*
P
[
1
]
+
M
[
2
]
M
[
3
]
*
P
[
0
]
+
M
[
4
]
*
P
[
1
]
+
M
[
5
]
]
;
exports
.
apply
=
apply
;
const
isIdentity
=
(
M
)
=
>
M
[
0
]
=
=
=
1
&
&
M
[
1
]
=
=
=
0
&
&
M
[
2
]
=
=
=
0
&
&
M
[
3
]
=
=
=
0
&
&
M
[
4
]
=
=
=
1
&
&
M
[
5
]
=
=
=
0
&
&
M
[
6
]
=
=
=
0
&
&
M
[
7
]
=
=
=
0
&
&
M
[
8
]
=
=
=
1
;
exports
.
isIdentity
=
isIdentity
;
function
getNodeTransformationMatrix
(
node
ancestor
=
node
.
parentElement
)
{
let
{
a
b
c
d
e
f
}
=
ancestor
.
getTransformToParent
(
)
.
multiply
(
node
.
getTransformToAncestor
(
ancestor
)
)
;
return
[
a
c
e
b
d
f
0
0
1
]
;
}
exports
.
getNodeTransformationMatrix
=
getNodeTransformationMatrix
;
