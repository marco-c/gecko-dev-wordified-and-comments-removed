"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
DOMHelpers
"
]
;
this
.
DOMHelpers
=
function
DOMHelpers
(
win
)
{
if
(
!
win
)
{
throw
new
Error
(
"
window
can
'
t
be
null
or
undefined
"
)
;
}
this
.
window
=
win
;
}
;
DOMHelpers
.
prototype
=
{
getParentObject
:
function
(
node
)
{
const
parentNode
=
node
?
node
.
parentNode
:
null
;
if
(
!
parentNode
)
{
if
(
node
&
&
node
=
=
this
.
window
.
Node
.
DOCUMENT_NODE
)
{
if
(
node
.
defaultView
)
{
const
embeddingFrame
=
node
.
defaultView
.
frameElement
;
if
(
embeddingFrame
)
{
return
embeddingFrame
.
parentNode
;
}
}
}
return
null
;
}
if
(
parentNode
.
nodeType
=
=
this
.
window
.
Node
.
DOCUMENT_NODE
)
{
if
(
parentNode
.
defaultView
)
{
return
parentNode
.
defaultView
.
frameElement
;
}
return
null
;
}
if
(
!
parentNode
.
localName
)
{
return
null
;
}
return
parentNode
;
}
getChildObject
:
function
(
node
index
previousSibling
showTextNodesWithWhitespace
)
{
if
(
!
node
)
{
return
null
;
}
if
(
node
.
contentDocument
)
{
if
(
index
=
=
0
)
{
return
node
.
contentDocument
.
documentElement
;
}
return
null
;
}
if
(
node
.
getSVGDocument
)
{
const
svgDocument
=
node
.
getSVGDocument
(
)
;
if
(
svgDocument
)
{
if
(
index
=
=
0
)
{
return
svgDocument
.
documentElement
;
}
return
null
;
}
}
let
child
=
null
;
if
(
previousSibling
)
{
child
=
this
.
getNextSibling
(
previousSibling
)
;
}
else
{
child
=
this
.
getFirstChild
(
node
)
;
}
if
(
showTextNodesWithWhitespace
)
{
return
child
;
}
for
(
;
child
;
child
=
this
.
getNextSibling
(
child
)
)
{
if
(
!
this
.
isWhitespaceText
(
child
)
)
{
return
child
;
}
}
return
null
;
}
getFirstChild
:
function
(
node
)
{
const
SHOW_ALL
=
nodeFilterConstants
.
SHOW_ALL
;
this
.
treeWalker
=
node
.
ownerDocument
.
createTreeWalker
(
node
SHOW_ALL
null
)
;
return
this
.
treeWalker
.
firstChild
(
)
;
}
getNextSibling
:
function
(
node
)
{
const
next
=
this
.
treeWalker
.
nextSibling
(
)
;
if
(
!
next
)
{
delete
this
.
treeWalker
;
}
return
next
;
}
isWhitespaceText
:
function
(
node
)
{
return
(
node
.
nodeType
=
=
this
.
window
.
Node
.
TEXT_NODE
&
&
!
/
[
^
\
s
]
/
.
exec
(
node
.
nodeValue
)
)
;
}
destroy
:
function
(
)
{
delete
this
.
window
;
delete
this
.
treeWalker
;
}
onceDOMReady
:
function
(
callback
targetURL
)
{
const
window
=
this
.
window
;
const
docShell
=
window
.
docShell
;
const
onReady
=
function
(
event
)
{
if
(
event
.
target
=
=
window
.
document
)
{
docShell
.
chromeEventHandler
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
)
;
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
}
;
if
(
(
window
.
document
.
readyState
=
=
"
complete
"
|
|
window
.
document
.
readyState
=
=
"
interactive
"
)
&
&
window
.
location
.
href
=
=
targetURL
)
{
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
else
{
docShell
.
chromeEventHandler
.
addEventListener
(
"
DOMContentLoaded
"
onReady
)
;
}
}
}
;
