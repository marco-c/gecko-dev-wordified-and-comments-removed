"
use
strict
"
;
var
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
dumpv
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
prompt
"
"
devtools
/
shared
/
security
/
prompt
"
)
;
loader
.
lazyRequireGetter
(
this
"
cert
"
"
devtools
/
shared
/
security
/
cert
"
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
function
createEnum
(
obj
)
{
for
(
const
key
in
obj
)
{
obj
[
key
]
=
key
;
}
return
obj
;
}
var
AuthenticationResult
=
exports
.
AuthenticationResult
=
createEnum
(
{
DISABLE_ALL
:
null
DENY
:
null
PENDING
:
null
ALLOW
:
null
ALLOW_PERSIST
:
null
}
)
;
var
Authenticators
=
{
}
;
var
Prompt
=
Authenticators
.
Prompt
=
{
}
;
Prompt
.
mode
=
"
PROMPT
"
;
Prompt
.
Client
=
function
(
)
{
}
;
Prompt
.
Client
.
prototype
=
{
mode
:
Prompt
.
mode
validateSettings
(
)
{
}
validateConnection
(
)
{
return
true
;
}
authenticate
(
)
{
}
}
;
Prompt
.
Server
=
function
(
)
{
}
;
Prompt
.
Server
.
prototype
=
{
mode
:
Prompt
.
mode
validateOptions
(
)
{
}
augmentSocketOptions
(
)
{
}
augmentAdvertisement
(
listener
advertisement
)
{
advertisement
.
authentication
=
Prompt
.
mode
;
}
authenticate
(
{
client
server
}
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
prompt
-
connection
"
)
)
{
return
AuthenticationResult
.
ALLOW
;
}
return
this
.
allowConnection
(
{
authentication
:
this
.
mode
client
server
}
)
;
}
allowConnection
:
prompt
.
Server
.
defaultAllowConnection
}
;
var
OOBCert
=
Authenticators
.
OOBCert
=
{
}
;
OOBCert
.
mode
=
"
OOB_CERT
"
;
OOBCert
.
Client
=
function
(
)
{
}
;
OOBCert
.
Client
.
prototype
=
{
mode
:
OOBCert
.
mode
validateSettings
(
{
encryption
}
)
{
if
(
!
encryption
)
{
throw
new
Error
(
{
OOBCert
.
mode
}
authentication
requires
encryption
.
)
;
}
}
validateConnection
(
{
cert
socket
}
)
{
dumpv
(
"
Validate
server
cert
hash
"
)
;
const
serverCert
=
socket
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
.
SSLStatus
.
serverCert
;
const
advertisedCert
=
cert
;
if
(
serverCert
.
sha256Fingerprint
!
=
advertisedCert
.
sha256
)
{
dumpn
(
"
Server
cert
hash
doesn
'
t
match
advertisement
"
)
;
return
false
;
}
return
true
;
}
authenticate
(
{
host
port
cert
transport
}
)
{
const
deferred
=
defer
(
)
;
let
oobData
;
let
activeSendDialog
;
const
closeDialog
=
(
)
=
>
{
if
(
activeSendDialog
&
&
activeSendDialog
.
close
)
{
activeSendDialog
.
close
(
)
;
activeSendDialog
=
null
;
}
}
;
transport
.
hooks
=
{
onPacket
:
async
(
packet
)
=
>
{
closeDialog
(
)
;
const
{
authResult
}
=
packet
;
switch
(
authResult
)
{
case
AuthenticationResult
.
PENDING
:
oobData
=
await
this
.
_createOOB
(
)
;
activeSendDialog
=
this
.
sendOOB
(
{
host
port
cert
authResult
oob
:
oobData
}
)
;
break
;
case
AuthenticationResult
.
ALLOW
:
if
(
packet
.
k
!
=
oobData
.
k
)
{
transport
.
close
(
new
Error
(
"
Auth
secret
mismatch
"
)
)
;
return
;
}
transport
.
hooks
=
null
;
deferred
.
resolve
(
transport
)
;
break
;
case
AuthenticationResult
.
ALLOW_PERSIST
:
transport
.
hooks
=
null
;
deferred
.
resolve
(
transport
)
;
break
;
default
:
transport
.
close
(
new
Error
(
"
Invalid
auth
result
:
"
+
authResult
)
)
;
break
;
}
}
onClosed
(
reason
)
{
closeDialog
(
)
;
transport
.
hooks
=
null
;
deferred
.
reject
(
reason
)
;
}
}
;
transport
.
ready
(
)
;
return
deferred
.
promise
;
}
async
_createOOB
(
)
{
const
clientCert
=
await
cert
.
local
.
getOrCreate
(
)
;
return
{
sha256
:
clientCert
.
sha256Fingerprint
k
:
this
.
_createRandom
(
)
}
;
}
_createRandom
(
)
{
const
length
=
16
;
const
rng
=
Cc
[
"
mozilla
.
org
/
security
/
random
-
generator
;
1
"
]
.
createInstance
(
Ci
.
nsIRandomGenerator
)
;
const
bytes
=
rng
.
generateRandomBytes
(
length
)
;
return
bytes
.
map
(
byte
=
>
byte
.
toString
(
16
)
)
.
join
(
"
"
)
;
}
sendOOB
:
prompt
.
Client
.
defaultSendOOB
}
;
OOBCert
.
Server
=
function
(
)
{
}
;
OOBCert
.
Server
.
prototype
=
{
mode
:
OOBCert
.
mode
validateOptions
(
listener
)
{
if
(
!
listener
.
encryption
)
{
throw
new
Error
(
OOBCert
.
mode
+
"
authentication
requires
encryption
.
"
)
;
}
}
augmentSocketOptions
(
listener
socket
)
{
const
requestCert
=
Ci
.
nsITLSServerSocket
.
REQUIRE_ALWAYS
;
socket
.
setRequestClientCertificate
(
requestCert
)
;
}
augmentAdvertisement
(
listener
advertisement
)
{
advertisement
.
authentication
=
OOBCert
.
mode
;
advertisement
.
cert
=
listener
.
cert
;
}
async
authenticate
(
{
client
server
transport
}
)
{
const
storageKey
=
devtools
.
auth
.
{
this
.
mode
}
.
approved
-
clients
;
const
approvedClients
=
(
await
asyncStorage
.
getItem
(
storageKey
)
)
|
|
{
}
;
if
(
approvedClients
[
client
.
cert
.
sha256
]
)
{
const
authResult
=
AuthenticationResult
.
ALLOW_PERSIST
;
transport
.
send
(
{
authResult
}
)
;
return
authResult
;
}
transport
.
send
(
{
authResult
:
AuthenticationResult
.
PENDING
}
)
;
const
authResult
=
await
this
.
allowConnection
(
{
authentication
:
this
.
mode
client
server
}
)
;
switch
(
authResult
)
{
case
AuthenticationResult
.
ALLOW_PERSIST
:
case
AuthenticationResult
.
ALLOW
:
break
;
default
:
return
authResult
;
}
const
oob
=
await
this
.
receiveOOB
(
)
;
if
(
!
oob
)
{
dumpn
(
"
Invalid
OOB
data
received
"
)
;
return
AuthenticationResult
.
DENY
;
}
const
{
sha256
k
}
=
oob
;
if
(
!
sha256
|
|
!
k
)
{
dumpn
(
"
Invalid
OOB
data
received
"
)
;
return
AuthenticationResult
.
DENY
;
}
if
(
client
.
cert
.
sha256
!
=
sha256
)
{
dumpn
(
"
Client
cert
hash
doesn
'
t
match
OOB
data
"
)
;
return
AuthenticationResult
.
DENY
;
}
transport
.
send
(
{
authResult
k
}
)
;
if
(
authResult
=
=
=
AuthenticationResult
.
ALLOW_PERSIST
)
{
approvedClients
[
client
.
cert
.
sha256
]
=
true
;
await
asyncStorage
.
setItem
(
storageKey
approvedClients
)
;
}
return
authResult
;
}
allowConnection
:
prompt
.
Server
.
defaultAllowConnection
receiveOOB
:
prompt
.
Server
.
defaultReceiveOOB
}
;
exports
.
Authenticators
=
{
get
(
mode
)
{
if
(
!
mode
)
{
mode
=
Prompt
.
mode
;
}
for
(
const
key
in
Authenticators
)
{
const
auth
=
Authenticators
[
key
]
;
if
(
auth
.
mode
=
=
=
mode
)
{
return
auth
;
}
}
throw
new
Error
(
"
Unknown
authenticator
mode
:
"
+
mode
)
;
}
}
;
