"
use
strict
"
;
var
{
Ci
Cc
CC
Cr
}
=
require
(
"
chrome
"
)
;
Cc
[
"
mozilla
.
org
/
psm
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
;
var
Services
=
require
(
"
Services
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
WebSocketServer
"
"
devtools
/
server
/
socket
/
websocket
-
server
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerTransport
"
"
devtools
/
shared
/
transport
/
transport
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebSocketDebuggerTransport
"
"
devtools
/
shared
/
transport
/
websocket
-
transport
"
)
;
loader
.
lazyRequireGetter
(
this
"
discovery
"
"
devtools
/
shared
/
discovery
/
discovery
"
)
;
loader
.
lazyRequireGetter
(
this
"
Authenticators
"
"
devtools
/
shared
/
security
/
auth
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AuthenticationResult
"
"
devtools
/
shared
/
security
/
auth
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsSocketStatus
"
"
resource
:
/
/
devtools
/
shared
/
security
/
DevToolsSocketStatus
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
nsFile
"
(
)
=
>
{
return
CC
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
socketTransportService
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
network
/
socket
-
transport
-
service
;
1
"
]
.
getService
(
Ci
.
nsISocketTransportService
)
;
}
)
;
var
DebuggerSocket
=
{
}
;
DebuggerSocket
.
connect
=
async
function
(
settings
)
{
if
(
!
settings
.
authenticator
)
{
settings
.
authenticator
=
new
(
Authenticators
.
get
(
)
.
Client
)
(
)
;
}
_validateSettings
(
settings
)
;
const
{
host
port
authenticator
}
=
settings
;
const
transport
=
await
_getTransport
(
settings
)
;
await
authenticator
.
authenticate
(
{
host
port
transport
}
)
;
transport
.
connectionSettings
=
settings
;
return
transport
;
}
;
function
_validateSettings
(
settings
)
{
const
{
authenticator
}
=
settings
;
authenticator
.
validateSettings
(
settings
)
;
}
var
_getTransport
=
async
function
(
settings
)
{
const
{
host
port
webSocket
}
=
settings
;
if
(
webSocket
)
{
const
socket
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
const
s
=
new
WebSocket
(
ws
:
/
/
{
host
}
:
{
port
}
)
;
s
.
onopen
=
(
)
=
>
resolve
(
s
)
;
s
.
onerror
=
err
=
>
reject
(
err
)
;
}
)
;
return
new
WebSocketDebuggerTransport
(
socket
)
;
}
const
attempt
=
await
_attemptTransport
(
settings
)
;
if
(
attempt
.
transport
)
{
return
attempt
.
transport
;
}
throw
new
Error
(
"
Connection
failed
"
)
;
}
;
var
_attemptTransport
=
async
function
(
settings
)
{
const
{
authenticator
}
=
settings
;
const
{
s
input
output
}
=
await
_attemptConnect
(
settings
)
;
let
alive
;
try
{
const
results
=
await
_isInputAlive
(
input
)
;
alive
=
results
.
alive
;
}
catch
(
e
)
{
input
.
close
(
)
;
output
.
close
(
)
;
throw
e
;
}
alive
=
alive
&
&
authenticator
.
validateConnection
(
{
host
:
settings
.
host
port
:
settings
.
port
socket
:
s
}
)
;
let
transport
;
if
(
alive
)
{
transport
=
new
DebuggerTransport
(
input
output
)
;
}
else
{
input
.
close
(
)
;
output
.
close
(
)
;
}
return
{
transport
s
}
;
}
;
var
_attemptConnect
=
async
function
(
{
host
port
}
)
{
const
s
=
socketTransportService
.
createTransport
(
[
]
host
port
null
null
)
;
if
(
!
host
.
includes
(
"
:
"
)
)
{
s
.
connectionFlags
|
=
Ci
.
nsISocketTransport
.
DISABLE_IPV6
;
}
s
.
setTimeout
(
Ci
.
nsISocketTransport
.
TIMEOUT_CONNECT
2
)
;
let
input
;
let
output
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
s
.
setEventSink
(
{
onTransportStatus
(
transport
status
)
{
if
(
status
!
=
Ci
.
nsISocketTransport
.
STATUS_CONNECTING_TO
)
{
return
;
}
try
{
input
=
s
.
openInputStream
(
0
0
0
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
resolve
(
{
s
input
output
}
)
;
}
}
Services
.
tm
.
currentThread
)
;
try
{
output
=
s
.
openOutputStream
(
0
0
0
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
.
catch
(
e
=
>
{
if
(
input
)
{
input
.
close
(
)
;
}
if
(
output
)
{
output
.
close
(
)
;
}
DevToolsUtils
.
reportException
(
"
_attemptConnect
"
e
)
;
}
)
;
}
;
function
_isInputAlive
(
input
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
input
.
asyncWait
(
{
onInputStreamReady
(
stream
)
{
try
{
stream
.
available
(
)
;
resolve
(
{
alive
:
true
}
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
}
0
0
Services
.
tm
.
currentThread
)
;
}
)
;
}
function
SocketListener
(
devToolsServer
socketOptions
)
{
this
.
_devToolsServer
=
devToolsServer
;
this
.
_socketOptions
=
{
authenticator
:
socketOptions
.
authenticator
|
|
new
(
Authenticators
.
get
(
)
.
Server
)
(
)
discoverable
:
!
!
socketOptions
.
discoverable
fromBrowserToolbox
:
!
!
socketOptions
.
fromBrowserToolbox
portOrPath
:
socketOptions
.
portOrPath
|
|
null
webSocket
:
!
!
socketOptions
.
webSocket
}
;
EventEmitter
.
decorate
(
this
)
;
}
SocketListener
.
prototype
=
{
get
authenticator
(
)
{
return
this
.
_socketOptions
.
authenticator
;
}
get
discoverable
(
)
{
return
this
.
_socketOptions
.
discoverable
;
}
get
fromBrowserToolbox
(
)
{
return
this
.
_socketOptions
.
fromBrowserToolbox
;
}
get
portOrPath
(
)
{
return
this
.
_socketOptions
.
portOrPath
;
}
get
webSocket
(
)
{
return
this
.
_socketOptions
.
webSocket
;
}
_validateOptions
(
)
{
if
(
this
.
portOrPath
=
=
=
null
)
{
throw
new
Error
(
"
Must
set
a
port
/
path
to
listen
on
.
"
)
;
}
if
(
this
.
discoverable
&
&
!
Number
(
this
.
portOrPath
)
)
{
throw
new
Error
(
"
Discovery
only
supported
for
TCP
sockets
.
"
)
;
}
}
open
(
)
{
this
.
_validateOptions
(
)
;
this
.
_devToolsServer
.
addSocketListener
(
this
)
;
let
flags
=
Ci
.
nsIServerSocket
.
KeepWhenOffline
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
force
-
local
"
)
)
{
flags
|
=
Ci
.
nsIServerSocket
.
LoopbackOnly
;
}
const
self
=
this
;
return
(
async
function
(
)
{
const
backlog
=
4
;
self
.
_socket
=
self
.
_createSocketInstance
(
)
;
if
(
self
.
isPortBased
)
{
const
port
=
Number
(
self
.
portOrPath
)
;
self
.
_socket
.
initSpecialConnection
(
port
flags
backlog
)
;
}
else
if
(
self
.
portOrPath
.
startsWith
(
"
/
"
)
)
{
const
file
=
nsFile
(
self
.
portOrPath
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
self
.
_socket
.
initWithFilename
(
file
parseInt
(
"
666
"
8
)
backlog
)
;
}
else
{
self
.
_socket
.
initWithAbstractAddress
(
self
.
portOrPath
backlog
)
;
}
self
.
_socket
.
asyncListen
(
self
)
;
dumpn
(
"
Socket
listening
on
:
"
+
(
self
.
port
|
|
self
.
portOrPath
)
)
;
}
)
(
)
.
then
(
(
)
=
>
{
if
(
!
self
.
fromBrowserToolbox
)
{
DevToolsSocketStatus
.
notifySocketOpened
(
)
;
}
this
.
_advertise
(
)
;
}
)
.
catch
(
e
=
>
{
dumpn
(
"
Could
not
start
debugging
listener
on
'
"
+
this
.
portOrPath
+
"
'
:
"
+
e
)
;
this
.
close
(
)
;
}
)
;
}
_advertise
(
)
{
if
(
!
this
.
discoverable
|
|
!
this
.
port
)
{
return
;
}
const
advertisement
=
{
port
:
this
.
port
}
;
this
.
authenticator
.
augmentAdvertisement
(
this
advertisement
)
;
discovery
.
addService
(
"
devtools
"
advertisement
)
;
}
_createSocketInstance
(
)
{
return
Cc
[
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
]
.
createInstance
(
Ci
.
nsIServerSocket
)
;
}
close
(
)
{
if
(
this
.
discoverable
&
&
this
.
port
)
{
discovery
.
removeService
(
"
devtools
"
)
;
}
if
(
this
.
_socket
)
{
this
.
_socket
.
close
(
)
;
this
.
_socket
=
null
;
if
(
!
this
.
fromBrowserToolbox
)
{
DevToolsSocketStatus
.
notifySocketClosed
(
)
;
}
}
this
.
_devToolsServer
.
removeSocketListener
(
this
)
;
}
get
host
(
)
{
if
(
!
this
.
_socket
)
{
return
null
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
force
-
local
"
)
)
{
return
"
127
.
0
.
0
.
1
"
;
}
return
"
0
.
0
.
0
.
0
"
;
}
get
isPortBased
(
)
{
return
!
!
Number
(
this
.
portOrPath
)
;
}
get
port
(
)
{
if
(
!
this
.
isPortBased
|
|
!
this
.
_socket
)
{
return
null
;
}
return
this
.
_socket
.
port
;
}
onAllowedConnection
(
transport
)
{
dumpn
(
"
onAllowedConnection
transport
:
"
+
transport
)
;
this
.
emit
(
"
accepted
"
transport
this
)
;
}
onSocketAccepted
:
DevToolsUtils
.
makeInfallible
(
function
(
socket
socketTransport
)
{
const
connection
=
new
ServerSocketConnection
(
this
socketTransport
)
;
connection
.
once
(
"
allowed
"
this
.
onAllowedConnection
.
bind
(
this
)
)
;
}
"
SocketListener
.
onSocketAccepted
"
)
onStopListening
(
socket
status
)
{
dumpn
(
"
onStopListening
status
:
"
+
status
)
;
}
}
;
function
ServerSocketConnection
(
listener
socketTransport
)
{
this
.
_listener
=
listener
;
this
.
_socketTransport
=
socketTransport
;
this
.
_handle
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
ServerSocketConnection
.
prototype
=
{
get
authentication
(
)
{
return
this
.
_listener
.
authenticator
.
mode
;
}
get
host
(
)
{
return
this
.
_socketTransport
.
host
;
}
get
port
(
)
{
return
this
.
_socketTransport
.
port
;
}
get
address
(
)
{
return
this
.
host
+
"
:
"
+
this
.
port
;
}
get
client
(
)
{
const
client
=
{
host
:
this
.
host
port
:
this
.
port
}
;
return
client
;
}
get
server
(
)
{
const
server
=
{
host
:
this
.
_listener
.
host
port
:
this
.
_listener
.
port
}
;
return
server
;
}
async
_handle
(
)
{
dumpn
(
"
Debugging
connection
starting
authentication
on
"
+
this
.
address
)
;
try
{
await
this
.
_createTransport
(
)
;
await
this
.
_authenticate
(
)
;
this
.
allow
(
)
;
}
catch
(
e
)
{
this
.
deny
(
e
)
;
}
}
async
_createTransport
(
)
{
const
input
=
this
.
_socketTransport
.
openInputStream
(
0
0
0
)
;
const
output
=
this
.
_socketTransport
.
openOutputStream
(
0
0
0
)
;
if
(
this
.
_listener
.
webSocket
)
{
const
socket
=
await
WebSocketServer
.
accept
(
this
.
_socketTransport
input
output
)
;
this
.
_transport
=
new
WebSocketDebuggerTransport
(
socket
)
;
}
else
{
this
.
_transport
=
new
DebuggerTransport
(
input
output
)
;
}
this
.
_transport
.
hooks
=
{
onTransportClosed
:
reason
=
>
{
this
.
deny
(
reason
)
;
}
}
;
this
.
_transport
.
ready
(
)
;
}
async
_authenticate
(
)
{
const
result
=
await
this
.
_listener
.
authenticator
.
authenticate
(
{
client
:
this
.
client
server
:
this
.
server
transport
:
this
.
_transport
}
)
;
if
(
result
=
=
=
AuthenticationResult
.
ALLOW
|
|
result
=
=
=
AuthenticationResult
.
ALLOW_PERSIST
)
{
return
;
}
if
(
result
=
=
=
AuthenticationResult
.
DISABLE_ALL
)
{
this
.
_listener
.
_devToolsServer
.
closeAllSocketListeners
(
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
false
)
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_CONNECTION_REFUSED
)
;
}
deny
(
result
)
{
if
(
this
.
_destroyed
)
{
return
;
}
let
errorName
=
result
;
for
(
const
name
in
Cr
)
{
if
(
Cr
[
name
]
=
=
=
result
)
{
errorName
=
name
;
break
;
}
}
dumpn
(
"
Debugging
connection
denied
on
"
+
this
.
address
+
"
(
"
+
errorName
+
"
)
"
)
;
if
(
this
.
_transport
)
{
this
.
_transport
.
hooks
=
null
;
this
.
_transport
.
close
(
result
)
;
}
this
.
_socketTransport
.
close
(
result
)
;
this
.
destroy
(
)
;
}
allow
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
dumpn
(
"
Debugging
connection
allowed
on
"
+
this
.
address
)
;
this
.
emit
(
"
allowed
"
this
.
_transport
)
;
this
.
destroy
(
)
;
}
destroy
(
)
{
this
.
_destroyed
=
true
;
this
.
_listener
=
null
;
this
.
_socketTransport
=
null
;
this
.
_transport
=
null
;
}
}
;
exports
.
DebuggerSocket
=
DebuggerSocket
;
exports
.
SocketListener
=
SocketListener
;
