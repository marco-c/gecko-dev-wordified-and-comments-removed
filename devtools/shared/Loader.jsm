"
use
strict
"
;
var
{
Constructor
:
CC
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
{
Loader
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
commonjs
/
toolkit
/
loader
.
js
"
{
}
)
;
var
promise
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
{
}
)
.
Promise
;
this
.
EXPORTED_SYMBOLS
=
[
"
DevToolsLoader
"
"
devtools
"
"
BuiltinProvider
"
"
SrcdirProvider
"
"
require
"
"
loader
"
]
;
var
loaderModules
=
{
"
Services
"
:
Object
.
create
(
Services
)
"
toolkit
/
loader
"
:
Loader
PromiseDebugging
ThreadSafeChromeUtils
HeapSnapshot
}
;
XPCOMUtils
.
defineLazyGetter
(
loaderModules
"
Debugger
"
(
)
=
>
{
let
sandbox
=
Cu
.
Sandbox
(
CC
(
'
mozilla
.
org
/
systemprincipal
;
1
'
'
nsIPrincipal
'
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
return
sandbox
.
Debugger
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
loaderModules
"
Timer
"
(
)
=
>
{
let
{
setTimeout
clearTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
return
{
setTimeout
clearTimeout
}
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
loaderModules
"
xpcInspector
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
jsinspector
;
1
"
]
.
getService
(
Ci
.
nsIJSInspector
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
loaderModules
"
indexedDB
"
(
)
=
>
{
try
{
return
Cu
.
Sandbox
(
this
{
wantGlobalProperties
:
[
"
indexedDB
"
]
}
)
.
indexedDB
;
}
catch
(
e
)
{
return
{
}
;
}
}
)
;
var
sharedGlobalBlacklist
=
[
"
sdk
/
indexed
-
db
"
]
;
function
BuiltinProvider
(
)
{
}
BuiltinProvider
.
prototype
=
{
load
:
function
(
)
{
this
.
loader
=
new
Loader
.
Loader
(
{
id
:
"
fx
-
devtools
"
modules
:
loaderModules
paths
:
{
"
"
:
"
resource
:
/
/
gre
/
modules
/
commonjs
/
"
"
devtools
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
"
"
devtools
/
client
"
:
"
resource
:
/
/
/
modules
/
devtools
/
client
"
"
gcli
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
/
gcli
"
"
promise
"
:
"
resource
:
/
/
gre
/
modules
/
Promise
-
backend
.
js
"
"
acorn
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
/
acorn
"
"
acorn
/
util
/
walk
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
/
acorn
/
walk
.
js
"
"
tern
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
/
tern
"
"
source
-
map
"
:
"
resource
:
/
/
gre
/
modules
/
devtools
/
sourcemap
/
source
-
map
.
js
"
"
xpcshell
-
test
"
:
"
resource
:
/
/
test
"
}
globals
:
this
.
globals
invisibleToDebugger
:
this
.
invisibleToDebugger
sharedGlobal
:
true
sharedGlobalBlacklist
:
sharedGlobalBlacklist
}
)
;
return
promise
.
resolve
(
undefined
)
;
}
unload
:
function
(
reason
)
{
Loader
.
unload
(
this
.
loader
reason
)
;
delete
this
.
loader
;
}
}
;
function
SrcdirProvider
(
)
{
}
SrcdirProvider
.
prototype
=
{
fileURI
:
function
(
path
)
{
let
file
=
new
FileUtils
.
File
(
path
)
;
return
Services
.
io
.
newFileURI
(
file
)
.
spec
;
}
load
:
function
(
)
{
let
srcDir
=
Services
.
prefs
.
getComplexValue
(
"
devtools
.
loader
.
srcdir
"
Ci
.
nsISupportsString
)
;
srcDir
=
OS
.
Path
.
normalize
(
srcDir
.
data
.
trim
(
)
)
;
let
devtoolsDir
=
OS
.
Path
.
join
(
srcDir
"
devtools
"
)
;
let
sharedDir
=
OS
.
Path
.
join
(
devtoolsDir
"
shared
"
)
;
let
modulesDir
=
OS
.
Path
.
join
(
srcDir
"
toolkit
"
"
modules
"
)
;
let
devtoolsURI
=
this
.
fileURI
(
devtoolsDir
)
;
let
gcliURI
=
this
.
fileURI
(
OS
.
Path
.
join
(
sharedDir
"
gcli
"
"
source
"
"
lib
"
"
gcli
"
)
)
;
let
promiseURI
=
this
.
fileURI
(
OS
.
Path
.
join
(
modulesDir
"
Promise
-
backend
.
js
"
)
)
;
let
acornURI
=
this
.
fileURI
(
OS
.
Path
.
join
(
sharedDir
"
acorn
"
)
)
;
let
acornWalkURI
=
OS
.
Path
.
join
(
acornURI
"
walk
.
js
"
)
;
let
ternURI
=
OS
.
Path
.
join
(
sharedDir
"
tern
"
)
;
let
sourceMapURI
=
this
.
fileURI
(
OS
.
Path
.
join
(
sharedDir
"
sourcemap
"
"
source
-
map
.
js
"
)
)
;
this
.
loader
=
new
Loader
.
Loader
(
{
id
:
"
fx
-
devtools
"
modules
:
loaderModules
paths
:
{
"
"
:
"
resource
:
/
/
gre
/
modules
/
commonjs
/
"
"
devtools
"
:
devtoolsURI
"
gcli
"
:
gcliURI
"
promise
"
:
promiseURI
"
acorn
"
:
acornURI
"
acorn
/
util
/
walk
"
:
acornWalkURI
"
tern
"
:
ternURI
"
source
-
map
"
:
sourceMapURI
}
globals
:
this
.
globals
invisibleToDebugger
:
this
.
invisibleToDebugger
sharedGlobal
:
true
sharedGlobalBlacklist
:
sharedGlobalBlacklist
}
)
;
return
this
.
_writeManifest
(
srcDir
)
.
then
(
null
Cu
.
reportError
)
;
}
unload
:
function
(
reason
)
{
Loader
.
unload
(
this
.
loader
reason
)
;
delete
this
.
loader
;
}
_readFile
:
function
(
filename
)
{
let
deferred
=
promise
.
defer
(
)
;
let
file
=
new
FileUtils
.
File
(
filename
)
;
NetUtil
.
asyncFetch
(
{
uri
:
NetUtil
.
newURI
(
file
)
loadUsingSystemPrincipal
:
true
}
(
inputStream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
deferred
.
reject
(
new
Error
(
"
Couldn
'
t
load
manifest
:
"
+
filename
+
"
\
n
"
)
)
;
return
;
}
var
data
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
)
;
deferred
.
resolve
(
data
)
;
}
)
;
return
deferred
.
promise
;
}
_writeFile
:
function
(
filename
data
)
{
let
promise
=
OS
.
File
.
writeAtomic
(
filename
data
{
encoding
:
"
utf
-
8
"
}
)
;
return
promise
.
then
(
null
(
ex
)
=
>
new
Error
(
"
Couldn
'
t
write
manifest
:
"
+
ex
+
"
\
n
"
)
)
;
}
_writeManifest
:
function
(
srcDir
)
{
let
clientDir
=
OS
.
Path
.
join
(
srcDir
"
devtools
"
"
client
"
)
;
return
this
.
_readFile
(
OS
.
Path
.
join
(
clientDir
"
jar
.
mn
"
)
)
.
then
(
(
data
)
=
>
{
let
entries
=
[
]
;
let
lines
=
data
.
split
(
/
\
n
/
)
;
let
preprocessed
=
/
^
\
s
*
\
*
/
;
let
contentEntry
=
new
RegExp
(
"
^
\
\
s
+
content
/
(
\
\
w
+
)
/
(
\
\
S
+
)
\
\
s
+
\
\
(
(
\
\
S
+
)
\
\
)
"
)
;
for
(
let
line
of
lines
)
{
if
(
preprocessed
.
test
(
line
)
)
{
dump
(
"
Unable
to
override
preprocessed
file
:
"
+
line
+
"
\
n
"
)
;
continue
;
}
let
match
=
contentEntry
.
exec
(
line
)
;
if
(
match
)
{
let
pathComponents
=
match
[
3
]
.
split
(
"
/
"
)
;
pathComponents
.
unshift
(
clientDir
)
;
let
path
=
OS
.
Path
.
join
.
apply
(
OS
.
Path
pathComponents
)
;
let
uri
=
this
.
fileURI
(
path
)
;
let
entry
=
"
override
chrome
:
/
/
"
+
match
[
1
]
+
"
/
content
/
"
+
match
[
2
]
+
"
\
t
"
+
uri
;
entries
.
push
(
entry
)
;
}
}
return
this
.
_writeFile
(
OS
.
Path
.
join
(
clientDir
"
chrome
.
manifest
"
)
entries
.
join
(
"
\
n
"
)
)
;
}
)
.
then
(
(
)
=
>
{
let
clientDirFile
=
new
FileUtils
.
File
(
clientDir
)
;
Components
.
manager
.
addBootstrappedManifestLocation
(
clientDirFile
)
;
}
)
;
}
}
;
var
gNextLoaderID
=
0
;
this
.
DevToolsLoader
=
function
DevToolsLoader
(
)
{
this
.
require
=
this
.
require
.
bind
(
this
)
;
this
.
lazyGetter
=
XPCOMUtils
.
defineLazyGetter
.
bind
(
XPCOMUtils
)
;
this
.
lazyImporter
=
XPCOMUtils
.
defineLazyModuleGetter
.
bind
(
XPCOMUtils
)
;
this
.
lazyServiceGetter
=
XPCOMUtils
.
defineLazyServiceGetter
.
bind
(
XPCOMUtils
)
;
this
.
lazyRequireGetter
=
this
.
lazyRequireGetter
.
bind
(
this
)
;
}
;
DevToolsLoader
.
prototype
=
{
get
provider
(
)
{
if
(
!
this
.
_provider
)
{
this
.
_chooseProvider
(
)
;
}
return
this
.
_provider
;
}
_provider
:
null
get
id
(
)
{
if
(
this
.
_id
)
{
return
this
.
_id
;
}
else
{
return
this
.
_id
=
+
+
gNextLoaderID
;
}
}
require
:
function
(
)
{
if
(
!
this
.
_provider
)
{
this
.
_chooseProvider
(
)
;
}
return
this
.
require
.
apply
(
this
arguments
)
;
}
lazyRequireGetter
:
function
(
obj
property
module
destructure
)
{
Object
.
defineProperty
(
obj
property
{
get
:
(
)
=
>
{
delete
obj
[
property
]
;
let
value
=
destructure
?
this
.
require
(
module
)
[
property
]
:
this
.
require
(
module
|
|
property
)
;
Object
.
defineProperty
(
obj
property
{
value
writable
:
true
configurable
:
true
enumerable
:
true
}
)
;
return
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
loadURI
:
function
(
id
uri
)
{
let
module
=
Loader
.
Module
(
id
uri
)
;
return
Loader
.
load
(
this
.
provider
.
loader
module
)
.
exports
;
}
main
:
function
(
id
)
{
if
(
this
.
_mainid
)
{
return
;
}
this
.
_mainid
=
id
;
this
.
_main
=
Loader
.
main
(
this
.
provider
.
loader
id
)
;
Object
.
getOwnPropertyNames
(
this
.
_main
)
.
forEach
(
key
=
>
{
XPCOMUtils
.
defineLazyGetter
(
this
key
(
)
=
>
this
.
_main
[
key
]
)
;
}
)
;
}
setProvider
:
function
(
provider
)
{
if
(
provider
=
=
=
this
.
_provider
)
{
return
;
}
if
(
this
.
_provider
)
{
var
events
=
this
.
require
(
"
sdk
/
system
/
events
"
)
;
events
.
emit
(
"
devtools
-
unloaded
"
{
}
)
;
delete
this
.
require
;
this
.
_provider
.
unload
(
"
newprovider
"
)
;
}
this
.
_provider
=
provider
;
this
.
_provider
.
invisibleToDebugger
=
this
.
invisibleToDebugger
;
this
.
_provider
.
globals
=
{
isWorker
:
false
reportError
:
Cu
.
reportError
btoa
:
btoa
_Iterator
:
Iterator
loader
:
{
lazyGetter
:
this
.
lazyGetter
lazyImporter
:
this
.
lazyImporter
lazyServiceGetter
:
this
.
lazyServiceGetter
lazyRequireGetter
:
this
.
lazyRequireGetter
id
:
this
.
id
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
_provider
.
globals
"
console
"
(
)
=
>
{
return
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
shared
/
Console
.
jsm
"
{
}
)
.
console
;
}
)
;
this
.
_provider
.
load
(
)
;
this
.
require
=
Loader
.
Require
(
this
.
_provider
.
loader
{
id
:
"
devtools
"
}
)
;
if
(
this
.
_mainid
)
{
this
.
main
(
this
.
_mainid
)
;
}
}
_chooseProvider
:
function
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
devtools
.
loader
.
srcdir
"
)
)
{
this
.
setProvider
(
new
SrcdirProvider
(
)
)
;
}
else
{
this
.
setProvider
(
new
BuiltinProvider
(
)
)
;
}
}
reload
:
function
(
)
{
var
events
=
this
.
require
(
"
sdk
/
system
/
events
"
)
;
events
.
emit
(
"
startupcache
-
invalidate
"
{
}
)
;
events
.
emit
(
"
devtools
-
unloaded
"
{
}
)
;
this
.
_provider
.
unload
(
"
reload
"
)
;
delete
this
.
_provider
;
delete
this
.
_mainid
;
this
.
_chooseProvider
(
)
;
this
.
main
(
"
devtools
/
client
/
main
"
)
;
}
invisibleToDebugger
:
Services
.
appinfo
.
name
!
=
=
"
Firefox
"
}
;
this
.
devtools
=
this
.
loader
=
new
DevToolsLoader
(
)
;
this
.
require
=
this
.
devtools
.
require
.
bind
(
this
.
devtools
)
;
