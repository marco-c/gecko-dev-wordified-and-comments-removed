"
use
strict
"
;
const
LINE_BREAK_RE
=
/
\
r
\
n
?
|
\
n
|
\
u2028
|
\
u2029
/
;
const
MAX_DATA_URL_LENGTH
=
40
;
loader
.
lazyRequireGetter
(
this
"
InspectorCSSParserWrapper
"
"
resource
:
/
/
devtools
/
shared
/
css
/
lexer
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getTabPrefs
"
"
resource
:
/
/
devtools
/
shared
/
indentation
.
js
"
true
)
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
styleInspectorL10N
=
new
LocalizationHelper
(
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
)
;
exports
.
FILTER
=
{
USER
:
"
user
"
UA
:
"
ua
"
}
;
exports
.
STATUS
=
{
BEST
:
3
MATCHED
:
2
PARENT_MATCH
:
1
UNMATCHED
:
0
UNKNOWN
:
-
1
}
;
exports
.
CSSAtRuleClassNameType
=
{
CSSContainerRule
:
"
container
"
CSSCounterStyleRule
:
"
counter
-
style
"
CSSDocumentRule
:
"
document
"
CSSFontFaceRule
:
"
font
-
face
"
CSSFontFeatureValuesRule
:
"
font
-
feature
-
values
"
CSSImportRule
:
"
import
"
CSSKeyframeRule
:
"
keyframe
"
CSSKeyframesRule
:
"
keyframes
"
CSSLayerBlockRule
:
"
layer
"
CSSMediaRule
:
"
media
"
CSSNamespaceRule
:
"
namespace
"
CSSPageRule
:
"
page
"
CSSScopeRule
:
"
scope
"
CSSStartingStyleRule
:
"
starting
-
style
"
CSSSupportsRule
:
"
supports
"
}
;
exports
.
getCSSAtRuleTypeName
=
function
(
cssRule
)
{
const
ruleClassName
=
ChromeUtils
.
getClassName
(
cssRule
)
;
const
atRuleTypeName
=
exports
.
CSSAtRuleClassNameType
[
ruleClassName
]
;
if
(
atRuleTypeName
)
{
return
"
"
+
atRuleTypeName
;
}
return
"
"
;
}
;
exports
.
l10n
=
name
=
>
styleInspectorL10N
.
getStr
(
name
)
;
exports
.
l10nFormatStr
=
(
name
.
.
.
args
)
=
>
styleInspectorL10N
.
getFormatStr
(
name
.
.
.
args
)
;
exports
.
isAuthorStylesheet
=
function
(
sheet
)
{
return
sheet
.
parsingMode
=
=
=
"
author
"
;
}
;
exports
.
isUserStylesheet
=
function
(
sheet
)
{
return
sheet
.
parsingMode
=
=
=
"
user
"
;
}
;
exports
.
isAgentStylesheet
=
function
(
sheet
)
{
return
sheet
.
parsingMode
=
=
=
"
agent
"
;
}
;
exports
.
shortSource
=
function
(
sheet
)
{
if
(
!
sheet
)
{
return
exports
.
l10n
(
"
rule
.
sourceInline
"
)
;
}
if
(
!
sheet
.
href
)
{
return
exports
.
l10n
(
sheet
.
constructed
?
"
rule
.
sourceConstructed
"
:
"
rule
.
sourceInline
"
)
;
}
let
name
=
sheet
.
href
;
const
dataUrl
=
sheet
.
href
.
trim
(
)
.
match
(
/
^
data
:
.
*
?
(
(
?
:
.
|
\
r
|
\
n
)
*
)
/
)
;
if
(
dataUrl
)
{
name
=
dataUrl
[
1
]
.
length
>
MAX_DATA_URL_LENGTH
?
{
dataUrl
[
1
]
.
substr
(
0
MAX_DATA_URL_LENGTH
-
1
)
}
:
dataUrl
[
1
]
;
}
else
{
const
url
=
URL
.
parse
(
sheet
.
href
)
;
if
(
url
)
{
if
(
url
.
pathname
)
{
const
index
=
url
.
pathname
.
lastIndexOf
(
"
/
"
)
;
if
(
index
!
=
=
-
1
&
&
index
<
url
.
pathname
.
length
)
{
name
=
url
.
pathname
.
slice
(
index
+
1
)
;
}
else
{
name
=
url
.
pathname
;
}
}
else
if
(
url
.
query
)
{
name
=
url
.
query
;
}
}
}
try
{
name
=
decodeURIComponent
(
name
)
;
}
catch
(
e
)
{
}
return
name
;
}
;
exports
.
longSource
=
function
(
sheet
)
{
if
(
!
sheet
)
{
return
exports
.
l10n
(
"
rule
.
sourceInline
"
)
;
}
if
(
!
sheet
.
href
)
{
return
exports
.
l10n
(
sheet
.
constructed
?
"
rule
.
sourceConstructed
"
:
"
rule
.
sourceInline
"
)
;
}
return
sheet
.
href
;
}
;
const
TAB_CHARS
=
"
\
t
"
;
const
SPACE_CHARS
=
"
"
;
function
getLineCountInComments
(
text
)
{
let
count
=
0
;
for
(
const
comment
of
text
.
match
(
/
\
/
\
*
(
?
:
.
|
\
n
)
*
?
\
*
\
/
/
gm
)
|
|
[
]
)
{
count
+
=
comment
.
split
(
"
\
n
"
)
.
length
+
1
;
}
return
count
;
}
function
prettifyCSS
(
text
ruleCount
)
{
if
(
prettifyCSS
.
LINE_SEPARATOR
=
=
null
)
{
const
os
=
Services
.
appinfo
.
OS
;
prettifyCSS
.
LINE_SEPARATOR
=
os
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
;
}
const
trimmed
=
text
.
trim
(
)
;
if
(
trimmed
.
startsWith
(
"
<
!
-
-
"
)
)
{
text
=
trimmed
.
replace
(
/
^
<
!
-
-
/
"
"
)
.
replace
(
/
-
-
>
/
"
"
)
.
trim
(
)
;
}
const
originalText
=
text
;
text
=
text
.
trim
(
)
;
const
lineCount
=
text
.
split
(
"
\
n
"
)
.
length
-
1
-
getLineCountInComments
(
text
)
;
if
(
ruleCount
!
=
=
null
&
&
lineCount
>
=
ruleCount
)
{
return
{
result
:
originalText
mappings
:
[
]
}
;
}
let
indent
=
"
"
;
let
indentLevel
=
0
;
const
lexer
=
new
InspectorCSSParserWrapper
(
text
)
;
const
mappings
=
[
]
;
let
lineOffset
=
0
;
let
columnOffset
=
0
;
let
indentOffset
=
0
;
let
result
=
"
"
;
let
pushbackToken
=
undefined
;
const
readUntilSignificantToken
=
(
)
=
>
{
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
!
=
=
"
WhiteSpace
"
)
{
pushbackToken
=
token
;
return
token
;
}
const
nextToken
=
lexer
.
nextToken
(
)
;
if
(
!
nextToken
|
|
nextToken
.
tokenType
!
=
=
"
Comment
"
)
{
pushbackToken
=
nextToken
;
return
token
;
}
result
=
result
+
text
.
substring
(
token
.
startOffset
nextToken
.
endOffset
)
;
}
}
;
let
startIndex
;
let
endIndex
;
let
anyNonWS
;
let
isCloseBrace
;
let
isNewLine
;
let
lastWasWS
;
let
isInSelector
=
true
;
let
isInAtRuleDefinition
=
false
;
const
readUntilNewlineNeeded
=
(
)
=
>
{
let
token
;
while
(
true
)
{
if
(
pushbackToken
)
{
token
=
pushbackToken
;
pushbackToken
=
undefined
;
}
else
{
token
=
lexer
.
nextToken
(
)
;
}
if
(
!
token
)
{
endIndex
=
text
.
length
;
break
;
}
const
line
=
lexer
.
lineNumber
;
const
column
=
lexer
.
columnNumber
;
mappings
.
push
(
{
original
:
{
line
column
}
generated
:
{
line
:
lineOffset
+
line
column
:
columnOffset
}
}
)
;
columnOffset
+
=
token
.
endOffset
-
token
.
startOffset
;
if
(
token
.
tokenType
=
=
=
"
AtKeyword
"
)
{
isInAtRuleDefinition
=
true
;
}
if
(
token
.
tokenType
=
=
=
"
CloseCurlyBracket
"
)
{
isInSelector
=
true
;
isCloseBrace
=
true
;
break
;
}
else
if
(
token
.
tokenType
=
=
=
"
CurlyBracketBlock
"
)
{
if
(
isInAtRuleDefinition
)
{
isInAtRuleDefinition
=
false
;
}
else
{
isInSelector
=
false
;
}
break
;
}
if
(
token
.
tokenType
=
=
=
"
WhiteSpace
"
)
{
if
(
LINE_BREAK_RE
.
test
(
token
.
text
)
)
{
isNewLine
=
true
;
break
;
}
}
else
{
anyNonWS
=
true
;
}
if
(
startIndex
=
=
=
undefined
)
{
startIndex
=
token
.
startOffset
;
}
endIndex
=
token
.
endOffset
;
if
(
token
.
tokenType
=
=
=
"
Semicolon
"
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
Comma
"
&
&
isInSelector
&
&
!
isInAtRuleDefinition
)
{
break
;
}
lastWasWS
=
token
.
tokenType
=
=
=
"
WhiteSpace
"
;
}
return
token
;
}
;
const
tabPrefs
=
getTabPrefs
(
)
;
const
baseIndentString
=
tabPrefs
.
indentWithTabs
?
TAB_CHARS
:
SPACE_CHARS
.
repeat
(
tabPrefs
.
indentUnit
)
;
while
(
true
)
{
startIndex
=
undefined
;
endIndex
=
undefined
;
anyNonWS
=
false
;
isCloseBrace
=
false
;
isNewLine
=
false
;
lastWasWS
=
false
;
let
token
=
readUntilNewlineNeeded
(
)
;
if
(
startIndex
!
=
=
undefined
)
{
if
(
isCloseBrace
&
&
!
anyNonWS
)
{
}
else
{
result
=
result
+
indent
+
text
.
substring
(
startIndex
endIndex
)
;
if
(
isNewLine
)
{
lineOffset
=
lineOffset
-
1
;
}
if
(
isCloseBrace
)
{
result
+
=
prettifyCSS
.
LINE_SEPARATOR
;
lineOffset
=
lineOffset
+
1
;
}
}
}
if
(
isCloseBrace
)
{
indentLevel
=
Math
.
max
(
0
indentLevel
-
1
)
;
indent
=
baseIndentString
.
repeat
(
indentLevel
)
;
if
(
tabPrefs
.
indentWithTabs
)
{
indentOffset
=
4
*
indentLevel
;
}
else
{
indentOffset
=
1
*
indentLevel
;
}
result
=
result
+
indent
+
"
}
"
;
}
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
CurlyBracketBlock
"
)
{
if
(
!
lastWasWS
)
{
result
+
=
"
"
;
columnOffset
+
+
;
}
result
+
=
"
{
"
;
indentLevel
+
+
;
indent
=
baseIndentString
.
repeat
(
indentLevel
)
;
indentOffset
=
indent
.
length
;
if
(
tabPrefs
.
indentWithTabs
)
{
indentOffset
=
4
*
indentLevel
;
}
else
{
indentOffset
=
1
*
indentLevel
;
}
}
token
=
readUntilSignificantToken
(
)
;
if
(
ruleCount
!
=
=
null
&
&
pushbackToken
&
&
token
&
&
token
.
tokenType
=
=
=
"
WhiteSpace
"
&
&
/
\
n
/
g
.
test
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
)
{
return
{
result
:
originalText
mappings
:
[
]
}
;
}
result
=
result
+
prettifyCSS
.
LINE_SEPARATOR
;
lineOffset
=
lineOffset
+
1
;
columnOffset
=
0
+
indentOffset
;
if
(
!
pushbackToken
)
{
break
;
}
}
return
{
result
mappings
}
;
}
exports
.
prettifyCSS
=
prettifyCSS
;
function
getBindingElementAndPseudo
(
node
)
{
let
bindingElement
=
node
;
let
pseudo
=
null
;
if
(
node
.
nodeName
=
=
"
_moz_generated_content_marker
"
)
{
bindingElement
=
node
.
parentNode
;
pseudo
=
"
:
:
marker
"
;
}
else
if
(
node
.
nodeName
=
=
"
_moz_generated_content_before
"
)
{
bindingElement
=
node
.
parentNode
;
pseudo
=
"
:
:
before
"
;
}
else
if
(
node
.
nodeName
=
=
"
_moz_generated_content_after
"
)
{
bindingElement
=
node
.
parentNode
;
pseudo
=
"
:
:
after
"
;
}
return
{
bindingElement
pseudo
}
;
}
exports
.
getBindingElementAndPseudo
=
getBindingElementAndPseudo
;
function
getMatchingCSSRules
(
node
)
{
const
{
bindingElement
pseudo
}
=
getBindingElementAndPseudo
(
node
)
;
const
rules
=
InspectorUtils
.
getMatchingCSSRules
(
bindingElement
pseudo
)
;
return
rules
;
}
exports
.
getMatchingCSSRules
=
getMatchingCSSRules
;
function
hasVisitedState
(
node
)
{
if
(
!
node
)
{
return
false
;
}
const
ELEMENT_STATE_VISITED
=
1
<
<
18
;
return
(
!
!
(
InspectorUtils
.
getContentState
(
node
)
&
ELEMENT_STATE_VISITED
)
|
|
InspectorUtils
.
hasPseudoClassLock
(
node
"
:
visited
"
)
)
;
}
exports
.
hasVisitedState
=
hasVisitedState
;
function
positionInNodeList
(
element
nodeList
)
{
for
(
let
i
=
0
;
i
<
nodeList
.
length
;
i
+
+
)
{
if
(
element
=
=
=
nodeList
[
i
]
)
{
return
i
;
}
}
return
-
1
;
}
function
findNodeAndContainer
(
node
)
{
const
shadowRoot
=
node
.
containingShadowRoot
;
while
(
node
?
.
isNativeAnonymous
)
{
node
=
node
.
parentNode
;
}
if
(
shadowRoot
)
{
return
{
containingDocOrShadow
:
shadowRoot
node
}
;
}
return
{
containingDocOrShadow
:
node
.
ownerDocument
node
}
;
}
const
findCssSelector
=
function
(
ele
)
{
const
{
node
containingDocOrShadow
}
=
findNodeAndContainer
(
ele
)
;
ele
=
node
;
if
(
!
containingDocOrShadow
|
|
!
containingDocOrShadow
.
contains
(
ele
)
)
{
return
"
"
;
}
const
cssEscape
=
ele
.
ownerGlobal
.
CSS
.
escape
;
if
(
ele
.
id
&
&
containingDocOrShadow
.
querySelectorAll
(
"
#
"
+
cssEscape
(
ele
.
id
)
)
.
length
=
=
=
1
)
{
return
"
#
"
+
cssEscape
(
ele
.
id
)
;
}
const
tagName
=
ele
.
localName
;
if
(
tagName
=
=
=
"
html
"
)
{
return
"
html
"
;
}
if
(
tagName
=
=
=
"
head
"
)
{
return
"
head
"
;
}
if
(
tagName
=
=
=
"
body
"
)
{
return
"
body
"
;
}
let
selector
index
matches
;
for
(
let
i
=
0
;
i
<
ele
.
classList
.
length
;
i
+
+
)
{
selector
=
"
.
"
+
cssEscape
(
ele
.
classList
.
item
(
i
)
)
;
matches
=
containingDocOrShadow
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
selector
=
cssEscape
(
tagName
)
+
selector
;
matches
=
containingDocOrShadow
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
index
=
positionInNodeList
(
ele
ele
.
parentNode
.
children
)
+
1
;
selector
=
selector
+
"
:
nth
-
child
(
"
+
index
+
"
)
"
;
matches
=
containingDocOrShadow
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
}
index
=
positionInNodeList
(
ele
ele
.
parentNode
.
children
)
+
1
;
selector
=
cssEscape
(
tagName
)
+
"
:
nth
-
child
(
"
+
index
+
"
)
"
;
if
(
ele
.
parentNode
!
=
=
containingDocOrShadow
)
{
selector
=
findCssSelector
(
ele
.
parentNode
)
+
"
>
"
+
selector
;
}
return
selector
;
}
;
exports
.
findCssSelector
=
findCssSelector
;
function
getCssPath
(
ele
)
{
const
{
node
containingDocOrShadow
}
=
findNodeAndContainer
(
ele
)
;
ele
=
node
;
if
(
!
containingDocOrShadow
|
|
!
containingDocOrShadow
.
contains
(
ele
)
)
{
return
"
"
;
}
const
nodeGlobal
=
ele
.
ownerGlobal
.
Node
;
const
getElementSelector
=
element
=
>
{
if
(
!
element
.
localName
)
{
return
"
"
;
}
let
label
=
element
.
nodeName
=
=
element
.
nodeName
.
toUpperCase
(
)
?
element
.
localName
.
toLowerCase
(
)
:
element
.
localName
;
if
(
element
.
id
)
{
label
+
=
"
#
"
+
element
.
id
;
}
if
(
element
.
classList
)
{
for
(
const
cl
of
element
.
classList
)
{
label
+
=
"
.
"
+
cl
;
}
}
return
label
;
}
;
const
paths
=
[
]
;
while
(
ele
)
{
if
(
!
ele
|
|
ele
.
nodeType
!
=
=
nodeGlobal
.
ELEMENT_NODE
)
{
break
;
}
paths
.
splice
(
0
0
getElementSelector
(
ele
)
)
;
ele
=
ele
.
parentNode
;
}
return
paths
.
length
?
paths
.
join
(
"
"
)
:
"
"
;
}
exports
.
getCssPath
=
getCssPath
;
function
getXPath
(
ele
)
{
const
{
node
containingDocOrShadow
}
=
findNodeAndContainer
(
ele
)
;
ele
=
node
;
if
(
!
containingDocOrShadow
|
|
!
containingDocOrShadow
.
contains
(
ele
)
)
{
return
"
"
;
}
if
(
ele
.
id
)
{
return
/
/
*
[
id
=
"
{
ele
.
id
}
"
]
;
}
const
parts
=
[
]
;
const
nodeGlobal
=
ele
.
ownerGlobal
.
Node
;
while
(
ele
&
&
ele
.
nodeType
=
=
=
nodeGlobal
.
ELEMENT_NODE
)
{
let
nbOfPreviousSiblings
=
0
;
let
hasNextSiblings
=
false
;
let
sibling
=
ele
.
previousSibling
;
while
(
sibling
)
{
if
(
sibling
.
nodeType
!
=
=
nodeGlobal
.
DOCUMENT_TYPE_NODE
&
&
sibling
.
nodeName
=
=
ele
.
nodeName
)
{
nbOfPreviousSiblings
+
+
;
}
sibling
=
sibling
.
previousSibling
;
}
sibling
=
ele
.
nextSibling
;
while
(
sibling
)
{
if
(
sibling
.
nodeName
=
=
ele
.
nodeName
)
{
hasNextSiblings
=
true
;
break
;
}
sibling
=
sibling
.
nextSibling
;
}
const
prefix
=
ele
.
prefix
?
ele
.
prefix
+
"
:
"
:
"
"
;
const
nth
=
nbOfPreviousSiblings
|
|
hasNextSiblings
?
[
{
nbOfPreviousSiblings
+
1
}
]
:
"
"
;
parts
.
push
(
prefix
+
ele
.
localName
+
nth
)
;
ele
=
ele
.
parentNode
;
}
return
parts
.
length
?
"
/
"
+
parts
.
reverse
(
)
.
join
(
"
/
"
)
:
"
"
;
}
exports
.
getXPath
=
getXPath
;
var
NON_ASCII
=
"
[
^
\
\
x00
-
\
\
x7F
]
"
;
var
ESCAPE
=
"
\
\
\
\
[
^
\
n
\
r
]
"
;
var
VALID_CHAR
=
[
"
[
_a
-
z0
-
9
-
]
"
NON_ASCII
ESCAPE
]
.
join
(
"
|
"
)
;
var
IS_VARIABLE_TOKEN
=
new
RegExp
(
^
-
-
(
{
VALID_CHAR
}
)
*
"
i
"
)
;
function
isCssVariable
(
input
)
{
return
!
!
input
.
match
(
IS_VARIABLE_TOKEN
)
;
}
exports
.
isCssVariable
=
isCssVariable
;
exports
.
ELEMENT_BACKED_PSEUDO_ELEMENTS
=
new
Set
(
[
"
:
:
details
-
content
"
"
:
:
file
-
selector
-
button
"
]
)
;
