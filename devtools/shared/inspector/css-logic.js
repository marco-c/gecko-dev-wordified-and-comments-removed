"
use
strict
"
;
const
{
getRootBindingParent
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
CSSLexer
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
styleInspectorL10N
=
new
LocalizationHelper
(
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
)
;
exports
.
FILTER
=
{
USER
:
"
user
"
UA
:
"
ua
"
}
;
exports
.
STATUS
=
{
BEST
:
3
MATCHED
:
2
PARENT_MATCH
:
1
UNMATCHED
:
0
UNKNOWN
:
-
1
}
;
exports
.
l10n
=
name
=
>
styleInspectorL10N
.
getStr
(
name
)
;
exports
.
isContentStylesheet
=
function
(
sheet
)
{
return
sheet
.
parsingMode
!
=
=
"
agent
"
;
}
;
exports
.
shortSource
=
function
(
sheet
)
{
if
(
!
sheet
|
|
!
sheet
.
href
)
{
return
exports
.
l10n
(
"
rule
.
sourceInline
"
)
;
}
let
url
=
{
}
;
try
{
url
=
new
URL
(
sheet
.
href
)
;
}
catch
(
ex
)
{
}
if
(
url
.
pathname
)
{
let
index
=
url
.
pathname
.
lastIndexOf
(
"
/
"
)
;
if
(
index
!
=
=
-
1
&
&
index
<
url
.
pathname
.
length
)
{
return
url
.
pathname
.
slice
(
index
+
1
)
;
}
return
url
.
pathname
;
}
if
(
url
.
query
)
{
return
url
.
query
;
}
let
dataUrl
=
sheet
.
href
.
match
(
/
^
(
data
:
[
^
]
*
)
/
)
;
return
dataUrl
?
dataUrl
[
1
]
:
sheet
.
href
;
}
;
const
TAB_CHARS
=
"
\
t
"
;
function
prettifyCSS
(
text
ruleCount
)
{
if
(
prettifyCSS
.
LINE_SEPARATOR
=
=
null
)
{
let
os
=
Services
.
appinfo
.
OS
;
prettifyCSS
.
LINE_SEPARATOR
=
(
os
=
=
=
"
WINNT
"
?
"
\
r
\
n
"
:
"
\
n
"
)
;
}
text
=
text
.
replace
(
/
(
?
:
^
\
s
*
<
!
-
-
[
\
r
\
n
]
*
)
|
(
?
:
\
s
*
-
-
>
\
s
*
)
/
g
"
"
)
;
let
originalText
=
text
;
text
=
text
.
trim
(
)
;
let
lineCount
=
text
.
split
(
"
\
n
"
)
.
length
-
1
;
if
(
ruleCount
!
=
=
null
&
&
lineCount
>
=
ruleCount
)
{
return
originalText
;
}
let
indent
=
"
"
;
let
indentLevel
=
0
;
let
tokens
=
CSSLexer
.
getCSSLexer
(
text
)
;
let
result
=
"
"
;
let
pushbackToken
=
undefined
;
let
readUntilSignificantToken
=
(
)
=
>
{
while
(
true
)
{
let
token
=
tokens
.
nextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
!
=
=
"
whitespace
"
)
{
pushbackToken
=
token
;
return
token
;
}
let
nextToken
=
tokens
.
nextToken
(
)
;
if
(
!
nextToken
|
|
nextToken
.
tokenType
!
=
=
"
comment
"
)
{
pushbackToken
=
nextToken
;
return
token
;
}
result
=
result
+
text
.
substring
(
token
.
startOffset
nextToken
.
endOffset
)
;
}
}
;
let
startIndex
;
let
endIndex
;
let
anyNonWS
;
let
isCloseBrace
;
let
lastWasWS
;
let
readUntilNewlineNeeded
=
(
)
=
>
{
let
token
;
while
(
true
)
{
if
(
pushbackToken
)
{
token
=
pushbackToken
;
pushbackToken
=
undefined
;
}
else
{
token
=
tokens
.
nextToken
(
)
;
}
if
(
!
token
)
{
endIndex
=
text
.
length
;
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
}
"
)
{
isCloseBrace
=
true
;
break
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
break
;
}
if
(
token
.
tokenType
!
=
=
"
whitespace
"
)
{
anyNonWS
=
true
;
}
if
(
startIndex
=
=
=
undefined
)
{
startIndex
=
token
.
startOffset
;
}
endIndex
=
token
.
endOffset
;
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
;
"
)
{
break
;
}
lastWasWS
=
token
.
tokenType
=
=
=
"
whitespace
"
;
}
return
token
;
}
;
while
(
true
)
{
startIndex
=
undefined
;
endIndex
=
undefined
;
anyNonWS
=
false
;
isCloseBrace
=
false
;
lastWasWS
=
false
;
let
token
=
readUntilNewlineNeeded
(
)
;
if
(
startIndex
!
=
=
undefined
)
{
if
(
isCloseBrace
&
&
!
anyNonWS
)
{
}
else
{
result
=
result
+
indent
+
text
.
substring
(
startIndex
endIndex
)
;
if
(
isCloseBrace
)
{
result
+
=
prettifyCSS
.
LINE_SEPARATOR
;
}
}
}
if
(
isCloseBrace
)
{
indent
=
TAB_CHARS
.
repeat
(
-
-
indentLevel
)
;
result
=
result
+
indent
+
"
}
"
;
}
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
if
(
!
lastWasWS
)
{
result
+
=
"
"
;
}
result
+
=
"
{
"
;
indent
=
TAB_CHARS
.
repeat
(
+
+
indentLevel
)
;
}
token
=
readUntilSignificantToken
(
)
;
if
(
pushbackToken
&
&
token
&
&
token
.
tokenType
=
=
=
"
whitespace
"
&
&
/
\
n
/
g
.
test
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
)
{
return
originalText
;
}
result
=
result
+
prettifyCSS
.
LINE_SEPARATOR
;
if
(
!
pushbackToken
)
{
break
;
}
}
return
result
;
}
exports
.
prettifyCSS
=
prettifyCSS
;
function
positionInNodeList
(
element
nodeList
)
{
for
(
let
i
=
0
;
i
<
nodeList
.
length
;
i
+
+
)
{
if
(
element
=
=
=
nodeList
[
i
]
)
{
return
i
;
}
}
return
-
1
;
}
function
findCssSelector
(
ele
)
{
ele
=
getRootBindingParent
(
ele
)
;
let
document
=
ele
.
ownerDocument
;
if
(
!
document
|
|
!
document
.
contains
(
ele
)
)
{
throw
new
Error
(
"
findCssSelector
received
element
not
inside
document
"
)
;
}
if
(
ele
.
id
&
&
document
.
querySelectorAll
(
"
#
"
+
CSS
.
escape
(
ele
.
id
)
)
.
length
=
=
=
1
)
{
return
"
#
"
+
CSS
.
escape
(
ele
.
id
)
;
}
let
tagName
=
ele
.
localName
;
if
(
tagName
=
=
=
"
html
"
)
{
return
"
html
"
;
}
if
(
tagName
=
=
=
"
head
"
)
{
return
"
head
"
;
}
if
(
tagName
=
=
=
"
body
"
)
{
return
"
body
"
;
}
let
selector
index
matches
;
if
(
ele
.
classList
.
length
>
0
)
{
for
(
let
i
=
0
;
i
<
ele
.
classList
.
length
;
i
+
+
)
{
selector
=
"
.
"
+
CSS
.
escape
(
ele
.
classList
.
item
(
i
)
)
;
matches
=
document
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
selector
=
tagName
+
selector
;
matches
=
document
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
index
=
positionInNodeList
(
ele
ele
.
parentNode
.
children
)
+
1
;
selector
=
selector
+
"
:
nth
-
child
(
"
+
index
+
"
)
"
;
matches
=
document
.
querySelectorAll
(
selector
)
;
if
(
matches
.
length
=
=
=
1
)
{
return
selector
;
}
}
}
if
(
ele
.
parentNode
!
=
=
document
)
{
index
=
positionInNodeList
(
ele
ele
.
parentNode
.
children
)
+
1
;
selector
=
findCssSelector
(
ele
.
parentNode
)
+
"
>
"
+
tagName
+
"
:
nth
-
child
(
"
+
index
+
"
)
"
;
}
return
selector
;
}
exports
.
findCssSelector
=
findCssSelector
;
