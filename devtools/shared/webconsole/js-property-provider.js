"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
evalWithDebugger
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
getSyntaxTrees
"
"
devtools
/
shared
/
webconsole
/
parser
-
helper
"
true
)
;
}
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
analyzeInputString
"
"
shouldInputBeAutocompleted
"
"
shouldInputBeEagerlyEvaluated
"
]
"
devtools
/
shared
/
webconsole
/
analyze
-
input
-
string
"
true
)
;
const
MAX_AUTOCOMPLETE_ATTEMPTS
=
(
exports
.
MAX_AUTOCOMPLETE_ATTEMPTS
=
100000
)
;
const
MAX_AUTOCOMPLETIONS
=
(
exports
.
MAX_AUTOCOMPLETIONS
=
1500
)
;
function
JSPropertyProvider
(
{
dbgObject
environment
inputValue
cursor
authorizedEvaluations
=
[
]
webconsoleActor
selectedNodeActor
expressionVars
=
[
]
}
)
{
if
(
cursor
=
=
=
undefined
)
{
cursor
=
inputValue
.
length
;
}
inputValue
=
inputValue
.
substring
(
0
cursor
)
;
const
inputAnalysis
=
analyzeInputString
(
inputValue
)
;
if
(
!
shouldInputBeAutocompleted
(
inputAnalysis
)
)
{
return
null
;
}
let
{
lastStatement
isElementAccess
mainExpression
matchProp
isPropertyAccess
}
=
inputAnalysis
;
if
(
webconsoleActor
&
&
shouldInputBeEagerlyEvaluated
(
inputAnalysis
)
)
{
const
eagerResponse
=
evalWithDebugger
(
mainExpression
{
eager
:
true
selectedNodeActor
}
webconsoleActor
)
;
const
ret
=
eagerResponse
?
.
result
?
.
return
;
if
(
ret
&
&
ret
!
=
=
undefined
)
{
const
matches
=
typeof
ret
!
=
"
object
"
?
getMatchedProps
(
ret
matchProp
)
:
getMatchedPropsInDbgObject
(
ret
matchProp
)
;
return
prepareReturnedObject
(
{
matches
search
:
matchProp
isElementAccess
}
)
;
}
}
let
astExpression
;
const
startQuoteRegex
=
/
^
(
'
|
"
|
)
/
;
const
env
=
environment
|
|
dbgObject
.
asEnvironment
(
)
;
if
(
!
isWorker
&
&
isPropertyAccess
)
{
const
syntaxTrees
=
getSyntaxTrees
(
mainExpression
)
;
const
lastTree
=
syntaxTrees
[
syntaxTrees
.
length
-
1
]
;
const
lastBody
=
lastTree
?
.
body
[
lastTree
.
body
.
length
-
1
]
;
if
(
lastBody
)
{
if
(
!
lastBody
.
expression
)
{
return
null
;
}
astExpression
=
lastBody
.
expression
;
let
matchingObject
;
if
(
astExpression
.
type
=
=
=
"
ArrayExpression
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Array
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
typeof
astExpression
.
value
=
=
=
"
string
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
String
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
Number
.
isFinite
(
astExpression
.
value
)
)
{
if
(
!
Number
.
isInteger
(
astExpression
.
value
)
|
|
/
\
d
[
^
\
.
]
{
0
}
\
.
/
.
test
(
lastStatement
)
=
=
=
false
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Number
"
)
;
}
else
{
return
null
;
}
}
if
(
matchingObject
)
{
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
matchProp
)
)
{
elementAccessQuote
=
matchProp
[
0
]
;
search
=
matchProp
.
replace
(
startQuoteRegex
"
"
)
;
}
let
props
=
getMatchedPropsInDbgObject
(
matchingObject
search
)
;
if
(
isElementAccess
)
{
props
=
wrapMatchesInQuotes
(
props
elementAccessQuote
)
;
}
return
{
isElementAccess
matchProp
matches
:
props
}
;
}
}
}
let
properties
=
[
]
;
if
(
astExpression
)
{
if
(
isPropertyAccess
)
{
properties
=
getPropertiesFromAstExpression
(
astExpression
)
;
if
(
properties
=
=
=
null
)
{
return
null
;
}
}
}
else
{
properties
=
lastStatement
.
split
(
"
.
"
)
;
if
(
isElementAccess
)
{
const
lastPart
=
properties
[
properties
.
length
-
1
]
;
const
openBracketIndex
=
lastPart
.
lastIndexOf
(
"
[
"
)
;
matchProp
=
lastPart
.
substr
(
openBracketIndex
+
1
)
;
properties
[
properties
.
length
-
1
]
=
lastPart
.
substring
(
0
openBracketIndex
)
;
}
else
{
matchProp
=
properties
.
pop
(
)
.
trimLeft
(
)
;
}
}
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
search
)
)
{
elementAccessQuote
=
search
[
0
]
;
search
=
search
.
replace
(
startQuoteRegex
"
"
)
;
}
let
obj
=
dbgObject
;
if
(
properties
.
length
=
=
=
0
)
{
const
environmentProperties
=
getMatchedPropsInEnvironment
(
env
search
)
;
const
expressionVariables
=
new
Set
(
expressionVars
.
filter
(
variableName
=
>
variableName
.
startsWith
(
matchProp
)
)
)
;
for
(
const
prop
of
environmentProperties
)
{
expressionVariables
.
add
(
prop
)
;
}
return
{
isElementAccess
matchProp
matches
:
expressionVariables
}
;
}
let
firstProp
=
properties
.
shift
(
)
;
if
(
typeof
firstProp
=
=
"
string
"
)
{
firstProp
=
firstProp
.
trim
(
)
;
}
if
(
firstProp
=
=
=
"
this
"
)
{
try
{
obj
=
env
.
object
;
}
catch
(
e
)
{
}
}
else
if
(
firstProp
=
=
=
"
_
"
&
&
webconsoleActor
)
{
obj
=
webconsoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
else
if
(
firstProp
=
=
=
"
0
"
&
&
selectedNodeActor
&
&
webconsoleActor
)
{
const
actor
=
webconsoleActor
.
conn
.
getActor
(
selectedNodeActor
)
;
if
(
actor
)
{
try
{
obj
=
webconsoleActor
.
makeDebuggeeValue
(
actor
.
rawNode
)
;
}
catch
(
e
)
{
}
}
}
else
if
(
hasArrayIndex
(
firstProp
)
)
{
obj
=
getArrayMemberProperty
(
null
env
firstProp
)
;
}
else
{
obj
=
getVariableInEnvironment
(
env
firstProp
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
for
(
let
[
index
prop
]
of
properties
.
entries
(
)
)
{
if
(
typeof
prop
=
=
=
"
string
"
)
{
prop
=
prop
.
trim
(
)
;
}
if
(
prop
=
=
=
undefined
|
|
prop
=
=
=
null
|
|
prop
=
=
=
"
"
)
{
return
null
;
}
const
propPath
=
[
firstProp
]
.
concat
(
properties
.
slice
(
0
index
+
1
)
)
;
const
authorized
=
authorizedEvaluations
.
some
(
x
=
>
JSON
.
stringify
(
x
)
=
=
=
JSON
.
stringify
(
propPath
)
)
;
if
(
!
authorized
&
&
DevToolsUtils
.
isUnsafeGetter
(
obj
prop
)
)
{
return
{
isUnsafeGetter
:
true
getterPath
:
propPath
}
;
}
if
(
hasArrayIndex
(
prop
)
)
{
obj
=
getArrayMemberProperty
(
obj
null
prop
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
prop
authorized
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
const
matches
=
typeof
obj
!
=
"
object
"
?
getMatchedProps
(
obj
search
)
:
getMatchedPropsInDbgObject
(
obj
search
)
;
return
prepareReturnedObject
(
{
matches
search
isElementAccess
elementAccessQuote
}
)
;
}
function
hasArrayIndex
(
str
)
{
return
/
\
[
\
d
+
\
]
/
.
test
(
str
)
;
}
function
getContentPrototypeObject
(
env
name
)
{
let
outermostEnv
=
env
;
while
(
outermostEnv
?
.
parent
)
{
outermostEnv
=
outermostEnv
.
parent
;
}
const
constructorObj
=
DevToolsUtils
.
getProperty
(
outermostEnv
.
object
name
)
;
if
(
!
constructorObj
)
{
return
null
;
}
return
DevToolsUtils
.
getProperty
(
constructorObj
"
prototype
"
)
;
}
function
getPropertiesFromAstExpression
(
ast
)
{
let
result
=
[
]
;
if
(
!
ast
)
{
return
result
;
}
const
{
type
property
object
name
expression
}
=
ast
;
if
(
type
=
=
=
"
ThisExpression
"
)
{
result
.
unshift
(
"
this
"
)
;
}
else
if
(
type
=
=
=
"
Identifier
"
&
&
name
)
{
result
.
unshift
(
name
)
;
}
else
if
(
type
=
=
=
"
OptionalExpression
"
&
&
expression
)
{
result
=
(
getPropertiesFromAstExpression
(
expression
)
|
|
[
]
)
.
concat
(
result
)
;
}
else
if
(
type
=
=
=
"
MemberExpression
"
|
|
type
=
=
=
"
OptionalMemberExpression
"
)
{
if
(
property
)
{
if
(
property
.
type
=
=
=
"
Identifier
"
&
&
property
.
name
)
{
result
.
unshift
(
property
.
name
)
;
}
else
if
(
property
.
type
=
=
=
"
Literal
"
)
{
result
.
unshift
(
property
.
value
)
;
}
}
if
(
object
)
{
result
=
(
getPropertiesFromAstExpression
(
object
)
|
|
[
]
)
.
concat
(
result
)
;
}
}
else
{
return
null
;
}
return
result
;
}
function
wrapMatchesInQuotes
(
matches
quote
=
"
)
{
return
new
Set
(
[
.
.
.
matches
]
.
map
(
p
=
>
{
p
=
JSON
.
stringify
(
p
)
;
if
(
quote
=
=
"
)
{
return
p
;
}
p
=
p
.
slice
(
1
-
1
)
;
p
=
p
.
replace
(
/
\
\
(
?
=
"
)
/
g
"
"
)
;
p
=
p
.
replace
(
new
RegExp
(
quote
"
g
"
)
"
\
\
&
"
)
;
if
(
quote
=
=
"
"
)
{
p
=
p
.
replace
(
/
\
{
/
g
"
\
\
&
"
)
;
}
return
{
quote
}
{
p
}
{
quote
}
;
}
)
)
;
}
function
getArrayMemberProperty
(
obj
env
prop
)
{
const
propWithoutIndices
=
prop
.
substr
(
0
prop
.
indexOf
(
"
[
"
)
)
;
if
(
env
)
{
obj
=
getVariableInEnvironment
(
env
propWithoutIndices
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
propWithoutIndices
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
let
result
;
const
arrayIndicesRegex
=
/
\
[
[
^
\
]
]
*
\
]
/
g
;
while
(
(
result
=
arrayIndicesRegex
.
exec
(
prop
)
)
!
=
=
null
)
{
const
indexWithBrackets
=
result
[
0
]
;
const
indexAsText
=
indexWithBrackets
.
substr
(
1
indexWithBrackets
.
length
-
2
)
;
const
index
=
parseInt
(
indexAsText
10
)
;
if
(
isNaN
(
index
)
)
{
return
null
;
}
obj
=
DevToolsUtils
.
getProperty
(
obj
index
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
return
obj
;
}
function
isObjectUsable
(
object
)
{
if
(
object
=
=
null
)
{
return
false
;
}
if
(
typeof
object
=
=
"
object
"
&
&
object
.
class
=
=
"
DeadObject
"
)
{
return
false
;
}
return
true
;
}
function
getVariableInEnvironment
(
environment
name
)
{
return
getExactMatchImpl
(
environment
name
DebuggerEnvironmentSupport
)
;
}
function
prepareReturnedObject
(
{
matches
search
isElementAccess
elementAccessQuote
}
)
{
if
(
isElementAccess
)
{
matches
=
wrapMatchesInQuotes
(
matches
elementAccessQuote
)
;
}
else
if
(
!
isWorker
)
{
for
(
const
match
of
matches
)
{
try
{
Reflect
.
parse
(
(
{
{
match
}
:
true
}
)
)
;
}
catch
(
e
)
{
matches
.
delete
(
match
)
;
}
}
}
return
{
isElementAccess
matchProp
:
search
matches
}
;
}
function
getMatchedPropsInEnvironment
(
environment
match
)
{
return
getMatchedPropsImpl
(
environment
match
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInDbgObject
(
dbgObject
match
)
{
return
getMatchedPropsImpl
(
dbgObject
match
DebuggerObjectSupport
)
;
}
function
getMatchedProps
(
obj
match
)
{
if
(
typeof
obj
!
=
"
object
"
)
{
obj
=
obj
.
constructor
.
prototype
;
}
return
getMatchedPropsImpl
(
obj
match
JSObjectSupport
)
;
}
function
getMatchedPropsImpl
(
obj
match
{
chainIterator
getProperties
}
)
{
const
matches
=
new
Set
(
)
;
let
numProps
=
0
;
const
insensitiveMatching
=
match
&
&
match
[
0
]
.
toUpperCase
(
)
!
=
=
match
[
0
]
;
const
propertyMatches
=
prop
=
>
{
return
insensitiveMatching
?
prop
.
toLocaleLowerCase
(
)
.
startsWith
(
match
.
toLocaleLowerCase
(
)
)
:
prop
.
startsWith
(
match
)
;
}
;
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
props
=
getProperties
(
obj
)
;
if
(
!
props
)
{
continue
;
}
numProps
+
=
props
.
length
;
if
(
numProps
>
=
MAX_AUTOCOMPLETE_ATTEMPTS
|
|
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
const
prop
=
props
[
i
]
;
if
(
!
propertyMatches
(
prop
)
)
{
continue
;
}
if
(
+
prop
!
=
+
prop
)
{
matches
.
add
(
prop
)
;
}
if
(
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
}
}
return
matches
;
}
function
getExactMatchImpl
(
obj
name
{
chainIterator
getProperty
}
)
{
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
prop
=
getProperty
(
obj
name
obj
)
;
if
(
prop
)
{
return
prop
.
value
;
}
}
return
undefined
;
}
var
JSObjectSupport
=
{
*
chainIterator
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
Object
.
getPrototypeOf
(
obj
)
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
(
obj
)
{
try
{
return
Object
.
getOwnPropertyNames
(
obj
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
(
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerObjectSupport
=
{
*
chainIterator
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
obj
.
proto
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
(
obj
)
{
try
{
return
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
(
obj
name
rootObj
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerEnvironmentSupport
=
{
*
chainIterator
(
obj
)
{
while
(
obj
)
{
yield
obj
;
obj
=
obj
.
parent
;
}
}
getProperties
(
obj
)
{
const
names
=
obj
.
names
(
)
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
if
(
i
=
=
=
names
.
length
-
1
|
|
names
[
i
+
1
]
>
"
this
"
)
{
names
.
splice
(
i
+
1
0
"
this
"
)
;
break
;
}
}
return
names
;
}
getProperty
(
obj
name
)
{
let
result
;
try
{
result
=
obj
.
getVariable
(
name
)
;
}
catch
(
e
)
{
}
if
(
result
=
=
null
|
|
(
typeof
result
=
=
"
object
"
&
&
(
result
.
optimizedOut
|
|
result
.
missingArguments
)
)
)
{
return
null
;
}
return
{
value
:
result
}
;
}
}
;
exports
.
JSPropertyProvider
=
DevToolsUtils
.
makeInfallible
(
JSPropertyProvider
)
;
exports
.
FallibleJSPropertyProvider
=
JSPropertyProvider
;
