"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyImporter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
)
;
}
const
MAX_AUTOCOMPLETE_ATTEMPTS
=
exports
.
MAX_AUTOCOMPLETE_ATTEMPTS
=
100000
;
const
MAX_AUTOCOMPLETIONS
=
exports
.
MAX_AUTOCOMPLETIONS
=
1500
;
const
STATE_NORMAL
=
Symbol
(
"
STATE_NORMAL
"
)
;
const
STATE_QUOTE
=
Symbol
(
"
STATE_QUOTE
"
)
;
const
STATE_DQUOTE
=
Symbol
(
"
STATE_DQUOTE
"
)
;
const
STATE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_TEMPLATE_LITERAL
"
)
;
const
OPEN_BODY
=
"
{
[
(
"
.
split
(
"
"
)
;
const
CLOSE_BODY
=
"
}
]
)
"
.
split
(
"
"
)
;
const
OPEN_CLOSE_BODY
=
{
"
{
"
:
"
}
"
"
[
"
:
"
]
"
"
(
"
:
"
)
"
}
;
function
hasArrayIndex
(
str
)
{
return
/
\
[
\
d
+
\
]
/
.
test
(
str
)
;
}
function
findCompletionBeginning
(
str
)
{
const
bodyStack
=
[
]
;
let
state
=
STATE_NORMAL
;
let
start
=
0
;
let
c
;
const
characters
=
Array
.
from
(
str
)
;
for
(
let
i
=
0
;
i
<
characters
.
length
;
i
+
+
)
{
c
=
characters
[
i
]
;
switch
(
state
)
{
case
STATE_NORMAL
:
if
(
c
=
=
'
"
'
)
{
state
=
STATE_DQUOTE
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_QUOTE
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_TEMPLATE_LITERAL
;
}
else
if
(
c
=
=
"
;
"
)
{
start
=
i
+
1
;
}
else
if
(
c
=
=
"
"
)
{
const
before
=
characters
.
slice
(
0
i
)
;
const
after
=
characters
.
slice
(
i
+
1
)
;
const
trimmedBefore
=
Array
.
from
(
before
.
join
(
"
"
)
.
trimRight
(
)
)
;
const
trimmedAfter
=
Array
.
from
(
after
.
join
(
"
"
)
.
trimLeft
(
)
)
;
const
nextNonSpaceChar
=
trimmedAfter
[
0
]
;
const
nextNonSpaceCharIndex
=
after
.
indexOf
(
nextNonSpaceChar
)
;
const
previousNonSpaceChar
=
trimmedBefore
[
trimmedBefore
.
length
-
1
]
;
if
(
previousNonSpaceChar
=
=
=
"
.
"
&
&
!
nextNonSpaceChar
)
{
break
;
}
if
(
nextNonSpaceChar
)
{
if
(
previousNonSpaceChar
!
=
=
"
.
"
&
&
nextNonSpaceChar
!
=
=
"
.
"
)
{
start
=
i
+
nextNonSpaceCharIndex
;
}
i
=
i
+
nextNonSpaceCharIndex
;
}
else
{
break
;
}
}
else
if
(
OPEN_BODY
.
includes
(
c
)
)
{
bodyStack
.
push
(
{
token
:
c
start
:
start
}
)
;
start
=
i
+
1
;
}
else
if
(
CLOSE_BODY
.
includes
(
c
)
)
{
const
last
=
bodyStack
.
pop
(
)
;
if
(
!
last
|
|
OPEN_CLOSE_BODY
[
last
.
token
]
!
=
c
)
{
return
{
err
:
"
syntax
error
"
}
;
}
if
(
c
=
=
"
}
"
)
{
start
=
i
+
1
;
}
else
{
start
=
last
.
start
;
}
}
break
;
case
STATE_DQUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
'
"
'
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_TEMPLATE_LITERAL
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_QUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_NORMAL
;
}
break
;
}
}
return
{
state
:
state
lastStatement
:
characters
.
slice
(
start
)
.
join
(
"
"
)
}
;
}
function
JSPropertyProvider
(
dbgObject
anEnvironment
inputValue
cursor
)
{
if
(
cursor
=
=
=
undefined
)
{
cursor
=
inputValue
.
length
;
}
inputValue
=
inputValue
.
substring
(
0
cursor
)
;
const
{
err
state
lastStatement
}
=
findCompletionBeginning
(
inputValue
)
;
if
(
err
)
{
return
null
;
}
if
(
state
!
=
STATE_NORMAL
)
{
return
null
;
}
const
completionPart
=
lastStatement
;
const
lastDot
=
completionPart
.
lastIndexOf
(
"
.
"
)
;
if
(
completionPart
.
trim
(
)
=
=
"
"
)
{
return
null
;
}
if
(
!
isWorker
&
&
lastDot
>
0
)
{
const
parser
=
new
Parser
(
)
;
parser
.
logExceptions
=
false
;
const
syntaxTree
=
parser
.
get
(
completionPart
.
slice
(
0
lastDot
)
)
;
const
lastTree
=
syntaxTree
.
getLastSyntaxTree
(
)
;
const
lastBody
=
lastTree
&
&
lastTree
.
AST
.
body
[
lastTree
.
AST
.
body
.
length
-
1
]
;
if
(
lastBody
)
{
const
expression
=
lastBody
.
expression
;
const
matchProp
=
completionPart
.
slice
(
lastDot
+
1
)
.
trimLeft
(
)
;
if
(
expression
.
type
=
=
=
"
ArrayExpression
"
)
{
return
getMatchedProps
(
Array
.
prototype
matchProp
)
;
}
else
if
(
expression
.
type
=
=
=
"
Literal
"
&
&
(
typeof
expression
.
value
=
=
=
"
string
"
)
)
{
return
getMatchedProps
(
String
.
prototype
matchProp
)
;
}
}
}
const
properties
=
completionPart
.
split
(
"
.
"
)
;
const
matchProp
=
properties
.
pop
(
)
.
trimLeft
(
)
;
let
obj
=
dbgObject
;
const
env
=
anEnvironment
|
|
obj
.
asEnvironment
(
)
;
if
(
properties
.
length
=
=
=
0
)
{
return
getMatchedPropsInEnvironment
(
env
matchProp
)
;
}
const
firstProp
=
properties
.
shift
(
)
.
trim
(
)
;
if
(
firstProp
=
=
=
"
this
"
)
{
try
{
obj
=
env
.
object
;
}
catch
(
e
)
{
}
}
else
if
(
hasArrayIndex
(
firstProp
)
)
{
obj
=
getArrayMemberProperty
(
null
env
firstProp
)
;
}
else
{
obj
=
getVariableInEnvironment
(
env
firstProp
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
const
prop
=
properties
[
i
]
.
trim
(
)
;
if
(
!
prop
)
{
return
null
;
}
if
(
hasArrayIndex
(
prop
)
)
{
obj
=
getArrayMemberProperty
(
obj
null
prop
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
prop
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
if
(
typeof
obj
!
=
"
object
"
)
{
return
getMatchedProps
(
obj
matchProp
)
;
}
return
getMatchedPropsInDbgObject
(
obj
matchProp
)
;
}
function
getArrayMemberProperty
(
obj
env
prop
)
{
const
propWithoutIndices
=
prop
.
substr
(
0
prop
.
indexOf
(
"
[
"
)
)
;
if
(
env
)
{
obj
=
getVariableInEnvironment
(
env
propWithoutIndices
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
propWithoutIndices
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
let
result
;
const
arrayIndicesRegex
=
/
\
[
[
^
\
]
]
*
\
]
/
g
;
while
(
(
result
=
arrayIndicesRegex
.
exec
(
prop
)
)
!
=
=
null
)
{
const
indexWithBrackets
=
result
[
0
]
;
const
indexAsText
=
indexWithBrackets
.
substr
(
1
indexWithBrackets
.
length
-
2
)
;
const
index
=
parseInt
(
indexAsText
10
)
;
if
(
isNaN
(
index
)
)
{
return
null
;
}
obj
=
DevToolsUtils
.
getProperty
(
obj
index
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
return
obj
;
}
function
isObjectUsable
(
object
)
{
if
(
object
=
=
null
)
{
return
false
;
}
if
(
typeof
object
=
=
"
object
"
&
&
object
.
class
=
=
"
DeadObject
"
)
{
return
false
;
}
return
true
;
}
function
getVariableInEnvironment
(
anEnvironment
name
)
{
return
getExactMatchImpl
(
anEnvironment
name
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInEnvironment
(
anEnvironment
match
)
{
return
getMatchedPropsImpl
(
anEnvironment
match
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInDbgObject
(
dbgObject
match
)
{
return
getMatchedPropsImpl
(
dbgObject
match
DebuggerObjectSupport
)
;
}
function
getMatchedProps
(
obj
match
)
{
if
(
typeof
obj
!
=
"
object
"
)
{
obj
=
obj
.
constructor
.
prototype
;
}
return
getMatchedPropsImpl
(
obj
match
JSObjectSupport
)
;
}
function
getMatchedPropsImpl
(
obj
match
{
chainIterator
getProperties
}
)
{
const
matches
=
new
Set
(
)
;
let
numProps
=
0
;
const
insensitiveMatching
=
match
&
&
match
[
0
]
.
toUpperCase
(
)
!
=
=
match
[
0
]
;
const
propertyMatches
=
prop
=
>
{
return
insensitiveMatching
?
prop
.
toLocaleLowerCase
(
)
.
startsWith
(
match
.
toLocaleLowerCase
(
)
)
:
prop
.
startsWith
(
match
)
;
}
;
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
props
=
getProperties
(
obj
)
;
if
(
!
props
)
{
continue
;
}
numProps
+
=
props
.
length
;
if
(
numProps
>
=
MAX_AUTOCOMPLETE_ATTEMPTS
|
|
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
const
prop
=
props
[
i
]
;
if
(
!
propertyMatches
(
prop
)
)
{
continue
;
}
if
(
prop
.
indexOf
(
"
-
"
)
>
-
1
)
{
continue
;
}
if
(
+
prop
!
=
+
prop
)
{
matches
.
add
(
prop
)
;
}
if
(
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
}
}
return
{
matchProp
:
match
matches
}
;
}
function
getExactMatchImpl
(
obj
name
{
chainIterator
getProperty
}
)
{
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
prop
=
getProperty
(
obj
name
obj
)
;
if
(
prop
)
{
return
prop
.
value
;
}
}
return
undefined
;
}
var
JSObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
Object
.
getPrototypeOf
(
obj
)
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
Object
.
getOwnPropertyNames
(
obj
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
obj
.
proto
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
obj
name
rootObj
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerEnvironmentSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
obj
=
obj
.
parent
;
}
}
getProperties
:
function
(
obj
)
{
const
names
=
obj
.
names
(
)
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
if
(
i
=
=
=
names
.
length
-
1
|
|
names
[
i
+
1
]
>
"
this
"
)
{
names
.
splice
(
i
+
1
0
"
this
"
)
;
break
;
}
}
return
names
;
}
getProperty
:
function
(
obj
name
)
{
let
result
;
try
{
result
=
obj
.
getVariable
(
name
)
;
}
catch
(
e
)
{
}
if
(
result
=
=
=
undefined
|
|
result
.
optimizedOut
|
|
result
.
missingArguments
)
{
return
null
;
}
return
{
value
:
result
}
;
}
}
;
exports
.
JSPropertyProvider
=
DevToolsUtils
.
makeInfallible
(
JSPropertyProvider
)
;
exports
.
FallibleJSPropertyProvider
=
JSPropertyProvider
;
