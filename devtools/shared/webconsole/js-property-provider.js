"
use
strict
"
;
const
{
Cc
Ci
Cu
components
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyImporter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
)
;
}
const
MAX_AUTOCOMPLETE_ATTEMPTS
=
exports
.
MAX_AUTOCOMPLETE_ATTEMPTS
=
100000
;
const
MAX_AUTOCOMPLETIONS
=
exports
.
MAX_AUTOCOMPLETIONS
=
1500
;
const
STATE_NORMAL
=
0
;
const
STATE_QUOTE
=
2
;
const
STATE_DQUOTE
=
3
;
const
OPEN_BODY
=
"
{
[
(
"
.
split
(
"
"
)
;
const
CLOSE_BODY
=
"
}
]
)
"
.
split
(
"
"
)
;
const
OPEN_CLOSE_BODY
=
{
"
{
"
:
"
}
"
"
[
"
:
"
]
"
"
(
"
:
"
)
"
}
;
function
findCompletionBeginning
(
aStr
)
{
let
bodyStack
=
[
]
;
let
state
=
STATE_NORMAL
;
let
start
=
0
;
let
c
;
for
(
let
i
=
0
;
i
<
aStr
.
length
;
i
+
+
)
{
c
=
aStr
[
i
]
;
switch
(
state
)
{
case
STATE_NORMAL
:
if
(
c
=
=
'
"
'
)
{
state
=
STATE_DQUOTE
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_QUOTE
;
}
else
if
(
c
=
=
"
;
"
)
{
start
=
i
+
1
;
}
else
if
(
c
=
=
"
"
)
{
start
=
i
+
1
;
}
else
if
(
OPEN_BODY
.
indexOf
(
c
)
!
=
-
1
)
{
bodyStack
.
push
(
{
token
:
c
start
:
start
}
)
;
start
=
i
+
1
;
}
else
if
(
CLOSE_BODY
.
indexOf
(
c
)
!
=
-
1
)
{
var
last
=
bodyStack
.
pop
(
)
;
if
(
!
last
|
|
OPEN_CLOSE_BODY
[
last
.
token
]
!
=
c
)
{
return
{
err
:
"
syntax
error
"
}
;
}
if
(
c
=
=
"
}
"
)
{
start
=
i
+
1
;
}
else
{
start
=
last
.
start
;
}
}
break
;
case
STATE_DQUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
'
"
'
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_QUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_NORMAL
;
}
break
;
}
}
return
{
state
:
state
startPos
:
start
}
;
}
function
JSPropertyProvider
(
aDbgObject
anEnvironment
aInputValue
aCursor
)
{
if
(
aCursor
=
=
=
undefined
)
{
aCursor
=
aInputValue
.
length
;
}
let
inputValue
=
aInputValue
.
substring
(
0
aCursor
)
;
let
beginning
=
findCompletionBeginning
(
inputValue
)
;
if
(
beginning
.
err
)
{
return
null
;
}
if
(
beginning
.
state
!
=
STATE_NORMAL
)
{
return
null
;
}
let
completionPart
=
inputValue
.
substring
(
beginning
.
startPos
)
;
let
lastDot
=
completionPart
.
lastIndexOf
(
"
.
"
)
;
if
(
completionPart
.
trim
(
)
=
=
"
"
)
{
return
null
;
}
if
(
!
isWorker
&
&
lastDot
>
0
)
{
let
parser
=
new
Parser
(
)
;
parser
.
logExceptions
=
false
;
let
syntaxTree
=
parser
.
get
(
completionPart
.
slice
(
0
lastDot
)
)
;
let
lastTree
=
syntaxTree
.
getLastSyntaxTree
(
)
;
let
lastBody
=
lastTree
&
&
lastTree
.
AST
.
body
[
lastTree
.
AST
.
body
.
length
-
1
]
;
if
(
lastBody
)
{
let
expression
=
lastBody
.
expression
;
let
matchProp
=
completionPart
.
slice
(
lastDot
+
1
)
;
if
(
expression
.
type
=
=
=
"
ArrayExpression
"
)
{
return
getMatchedProps
(
Array
.
prototype
matchProp
)
;
}
else
if
(
expression
.
type
=
=
=
"
Literal
"
&
&
(
typeof
expression
.
value
=
=
=
"
string
"
)
)
{
return
getMatchedProps
(
String
.
prototype
matchProp
)
;
}
}
}
let
properties
=
completionPart
.
split
(
"
.
"
)
;
let
matchProp
=
properties
.
pop
(
)
.
trimLeft
(
)
;
let
obj
=
aDbgObject
;
if
(
anEnvironment
)
{
if
(
properties
.
length
=
=
0
)
{
return
getMatchedPropsInEnvironment
(
anEnvironment
matchProp
)
;
}
obj
=
getVariableInEnvironment
(
anEnvironment
properties
.
shift
(
)
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
let
prop
=
properties
[
i
]
.
trim
(
)
;
if
(
!
prop
)
{
return
null
;
}
if
(
prop
=
=
=
"
this
"
&
&
obj
=
=
=
aDbgObject
&
&
i
=
=
=
0
)
{
continue
;
}
if
(
/
\
[
\
d
+
\
]
/
.
test
(
prop
)
)
{
obj
=
getArrayMemberProperty
(
obj
prop
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
prop
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
if
(
typeof
obj
!
=
"
object
"
)
{
return
getMatchedProps
(
obj
matchProp
)
;
}
let
matchedProps
=
getMatchedPropsInDbgObject
(
obj
matchProp
)
;
if
(
properties
.
length
!
=
=
0
|
|
obj
!
=
=
aDbgObject
)
{
let
thisInd
=
matchedProps
.
matches
.
indexOf
(
"
this
"
)
;
if
(
thisInd
>
-
1
)
{
matchedProps
.
matches
.
splice
(
thisInd
1
)
}
}
return
matchedProps
;
}
function
getArrayMemberProperty
(
aObj
aProp
)
{
let
obj
=
aObj
;
let
propWithoutIndices
=
aProp
.
substr
(
0
aProp
.
indexOf
(
"
[
"
)
)
;
obj
=
DevToolsUtils
.
getProperty
(
obj
propWithoutIndices
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
let
result
;
let
arrayIndicesRegex
=
/
\
[
[
^
\
]
]
*
\
]
/
g
;
while
(
(
result
=
arrayIndicesRegex
.
exec
(
aProp
)
)
!
=
=
null
)
{
let
indexWithBrackets
=
result
[
0
]
;
let
indexAsText
=
indexWithBrackets
.
substr
(
1
indexWithBrackets
.
length
-
2
)
;
let
index
=
parseInt
(
indexAsText
)
;
if
(
isNaN
(
index
)
)
{
return
null
;
}
obj
=
DevToolsUtils
.
getProperty
(
obj
index
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
return
obj
;
}
function
isObjectUsable
(
aObject
)
{
if
(
aObject
=
=
null
)
{
return
false
;
}
if
(
typeof
aObject
=
=
"
object
"
&
&
aObject
.
class
=
=
"
DeadObject
"
)
{
return
false
;
}
return
true
;
}
function
getVariableInEnvironment
(
anEnvironment
aName
)
{
return
getExactMatch_impl
(
anEnvironment
aName
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInEnvironment
(
anEnvironment
aMatch
)
{
return
getMatchedProps_impl
(
anEnvironment
aMatch
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInDbgObject
(
aDbgObject
aMatch
)
{
return
getMatchedProps_impl
(
aDbgObject
aMatch
DebuggerObjectSupport
)
;
}
function
getMatchedProps
(
aObj
aMatch
)
{
if
(
typeof
aObj
!
=
"
object
"
)
{
aObj
=
aObj
.
constructor
.
prototype
;
}
return
getMatchedProps_impl
(
aObj
aMatch
JSObjectSupport
)
;
}
function
getMatchedProps_impl
(
aObj
aMatch
{
chainIterator
getProperties
}
)
{
let
matches
=
new
Set
(
)
;
let
numProps
=
0
;
let
iter
=
chainIterator
(
aObj
)
;
for
(
let
obj
of
iter
)
{
let
props
=
getProperties
(
obj
)
;
numProps
+
=
props
.
length
;
if
(
numProps
>
=
MAX_AUTOCOMPLETE_ATTEMPTS
|
|
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
let
prop
=
props
[
i
]
;
if
(
prop
.
indexOf
(
aMatch
)
!
=
0
)
{
continue
;
}
if
(
prop
.
indexOf
(
'
-
'
)
>
-
1
)
{
continue
;
}
if
(
+
prop
!
=
+
prop
)
{
matches
.
add
(
prop
)
;
}
if
(
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
}
}
return
{
matchProp
:
aMatch
matches
:
[
.
.
.
matches
]
}
;
}
function
getExactMatch_impl
(
aObj
aName
{
chainIterator
getProperty
}
)
{
let
iter
=
chainIterator
(
aObj
)
;
for
(
let
obj
of
iter
)
{
let
prop
=
getProperty
(
obj
aName
aObj
)
;
if
(
prop
)
{
return
prop
.
value
;
}
}
return
undefined
;
}
var
JSObjectSupport
=
{
chainIterator
:
function
*
(
aObj
)
{
while
(
aObj
)
{
yield
aObj
;
aObj
=
Object
.
getPrototypeOf
(
aObj
)
;
}
}
getProperties
:
function
(
aObj
)
{
return
Object
.
getOwnPropertyNames
(
aObj
)
;
}
getProperty
:
function
(
)
{
throw
"
Unimplemented
!
"
;
}
}
;
var
DebuggerObjectSupport
=
{
chainIterator
:
function
*
(
aObj
)
{
while
(
aObj
)
{
yield
aObj
;
aObj
=
aObj
.
proto
;
}
}
getProperties
:
function
(
aObj
)
{
let
names
=
aObj
.
getOwnPropertyNames
(
)
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
if
(
i
=
=
=
names
.
length
-
1
|
|
names
[
i
+
1
]
>
"
this
"
)
{
names
.
splice
(
i
+
1
0
"
this
"
)
;
break
;
}
}
return
names
;
}
getProperty
:
function
(
aObj
aName
aRootObj
)
{
throw
"
Unimplemented
!
"
;
}
}
;
var
DebuggerEnvironmentSupport
=
{
chainIterator
:
function
*
(
aObj
)
{
while
(
aObj
)
{
yield
aObj
;
aObj
=
aObj
.
parent
;
}
}
getProperties
:
function
(
aObj
)
{
return
aObj
.
names
(
)
;
}
getProperty
:
function
(
aObj
aName
)
{
let
result
=
aObj
.
getVariable
(
aName
)
;
if
(
result
=
=
=
undefined
|
|
result
.
optimizedOut
|
|
result
.
missingArguments
)
{
return
null
;
}
return
{
value
:
result
}
;
}
}
;
exports
.
JSPropertyProvider
=
DevToolsUtils
.
makeInfallible
(
JSPropertyProvider
)
;
