"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyImporter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
)
;
}
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
const
MAX_AUTOCOMPLETE_ATTEMPTS
=
(
exports
.
MAX_AUTOCOMPLETE_ATTEMPTS
=
100000
)
;
const
MAX_AUTOCOMPLETIONS
=
(
exports
.
MAX_AUTOCOMPLETIONS
=
1500
)
;
const
STATE_NORMAL
=
Symbol
(
"
STATE_NORMAL
"
)
;
const
STATE_QUOTE
=
Symbol
(
"
STATE_QUOTE
"
)
;
const
STATE_DQUOTE
=
Symbol
(
"
STATE_DQUOTE
"
)
;
const
STATE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_TEMPLATE_LITERAL
"
)
;
const
OPEN_BODY
=
"
{
[
(
"
.
split
(
"
"
)
;
const
CLOSE_BODY
=
"
}
]
)
"
.
split
(
"
"
)
;
const
OPEN_CLOSE_BODY
=
{
"
{
"
:
"
}
"
"
[
"
:
"
]
"
"
(
"
:
"
)
"
}
;
const
NO_AUTOCOMPLETE_PREFIXES
=
[
"
var
"
"
const
"
"
let
"
"
function
"
"
class
"
]
;
const
OPERATOR_CHARS_SET
=
new
Set
(
"
;
:
=
<
>
+
-
*
/
%
|
&
^
~
?
!
"
.
split
(
"
"
)
)
;
function
hasArrayIndex
(
str
)
{
return
/
\
[
\
d
+
\
]
/
.
test
(
str
)
;
}
function
analyzeInputString
(
str
)
{
const
bodyStack
=
[
]
;
let
state
=
STATE_NORMAL
;
let
start
=
0
;
let
c
;
const
characters
=
Array
.
from
(
str
)
;
const
buildReturnObject
=
(
)
=
>
{
let
isElementAccess
=
false
;
if
(
bodyStack
.
length
=
=
=
1
&
&
bodyStack
[
0
]
.
token
=
=
=
"
[
"
)
{
start
=
bodyStack
[
0
]
.
start
;
isElementAccess
=
true
;
if
(
[
STATE_DQUOTE
STATE_QUOTE
STATE_TEMPLATE_LITERAL
]
.
includes
(
state
)
)
{
state
=
STATE_NORMAL
;
}
}
return
{
state
lastStatement
:
characters
.
slice
(
start
)
.
join
(
"
"
)
isElementAccess
}
;
}
;
const
TIMEOUT
=
2500
;
const
startingTime
=
Date
.
now
(
)
;
for
(
let
i
=
0
;
i
<
characters
.
length
;
i
+
+
)
{
if
(
Date
.
now
(
)
-
startingTime
>
TIMEOUT
)
{
return
{
err
:
"
timeout
"
}
;
}
c
=
characters
[
i
]
;
switch
(
state
)
{
case
STATE_NORMAL
:
if
(
c
=
=
'
"
'
)
{
state
=
STATE_DQUOTE
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_QUOTE
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_TEMPLATE_LITERAL
;
}
else
if
(
OPERATOR_CHARS_SET
.
has
(
c
)
)
{
start
=
i
+
1
;
}
else
if
(
c
=
=
"
"
)
{
const
currentLastStatement
=
characters
.
slice
(
start
i
)
.
join
(
"
"
)
;
const
before
=
characters
.
slice
(
0
i
)
;
const
after
=
characters
.
slice
(
i
+
1
)
;
const
trimmedBefore
=
Array
.
from
(
before
.
join
(
"
"
)
.
trimRight
(
)
)
;
const
trimmedAfter
=
Array
.
from
(
after
.
join
(
"
"
)
.
trimLeft
(
)
)
;
const
nextNonSpaceChar
=
trimmedAfter
[
0
]
;
const
nextNonSpaceCharIndex
=
after
.
indexOf
(
nextNonSpaceChar
)
;
const
previousNonSpaceChar
=
trimmedBefore
[
trimmedBefore
.
length
-
1
]
;
if
(
previousNonSpaceChar
!
=
=
"
.
"
&
&
nextNonSpaceChar
!
=
=
"
.
"
&
&
previousNonSpaceChar
!
=
=
"
[
"
&
&
nextNonSpaceChar
!
=
=
"
[
"
&
&
!
NO_AUTOCOMPLETE_PREFIXES
.
includes
(
currentLastStatement
)
)
{
start
=
i
+
(
nextNonSpaceCharIndex
>
=
0
?
nextNonSpaceCharIndex
:
after
.
length
+
1
)
;
}
if
(
!
nextNonSpaceChar
)
{
return
buildReturnObject
(
)
;
}
i
=
i
+
nextNonSpaceCharIndex
;
}
else
if
(
OPEN_BODY
.
includes
(
c
)
)
{
bodyStack
.
push
(
{
token
:
c
start
}
)
;
start
=
i
+
1
;
}
else
if
(
CLOSE_BODY
.
includes
(
c
)
)
{
const
last
=
bodyStack
.
pop
(
)
;
if
(
!
last
|
|
OPEN_CLOSE_BODY
[
last
.
token
]
!
=
c
)
{
return
{
err
:
"
syntax
error
"
}
;
}
if
(
c
=
=
"
}
"
)
{
start
=
i
+
1
;
}
else
{
start
=
last
.
start
;
}
}
break
;
case
STATE_DQUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
'
"
'
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_TEMPLATE_LITERAL
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_QUOTE
:
if
(
c
=
=
"
\
\
"
)
{
i
+
+
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_NORMAL
;
}
break
;
}
}
return
buildReturnObject
(
)
;
}
function
JSPropertyProvider
(
{
dbgObject
environment
inputValue
cursor
authorizedEvaluations
=
[
]
webconsoleActor
selectedNodeActor
}
)
{
if
(
cursor
=
=
=
undefined
)
{
cursor
=
inputValue
.
length
;
}
inputValue
=
inputValue
.
substring
(
0
cursor
)
;
const
{
err
state
lastStatement
isElementAccess
}
=
analyzeInputString
(
inputValue
)
;
if
(
err
)
{
console
.
error
(
"
Failed
to
analyze
input
string
"
err
)
;
return
null
;
}
if
(
state
!
=
STATE_NORMAL
)
{
return
null
;
}
if
(
lastStatement
.
trim
(
)
=
=
"
"
)
{
return
null
;
}
if
(
NO_AUTOCOMPLETE_PREFIXES
.
some
(
prefix
=
>
lastStatement
.
startsWith
(
prefix
+
"
"
)
)
)
{
return
null
;
}
const
env
=
environment
|
|
dbgObject
.
asEnvironment
(
)
;
const
completionPart
=
lastStatement
;
const
lastDotIndex
=
completionPart
.
lastIndexOf
(
"
.
"
)
;
const
lastOpeningBracketIndex
=
isElementAccess
?
completionPart
.
lastIndexOf
(
"
[
"
)
:
-
1
;
const
lastCompletionCharIndex
=
Math
.
max
(
lastDotIndex
lastOpeningBracketIndex
)
;
const
startQuoteRegex
=
/
^
(
'
|
"
|
)
/
;
let
astExpression
;
let
matchProp
=
completionPart
.
slice
(
lastCompletionCharIndex
+
1
)
.
trimLeft
(
)
;
if
(
!
isWorker
&
&
lastCompletionCharIndex
>
0
)
{
const
parser
=
new
Parser
(
)
;
parser
.
logExceptions
=
false
;
const
parsedExpression
=
completionPart
.
slice
(
0
lastCompletionCharIndex
)
;
const
syntaxTree
=
parser
.
get
(
parsedExpression
)
;
const
lastTree
=
syntaxTree
.
getLastSyntaxTree
(
)
;
const
lastBody
=
lastTree
&
&
lastTree
.
AST
.
body
[
lastTree
.
AST
.
body
.
length
-
1
]
;
if
(
lastBody
)
{
astExpression
=
lastBody
.
expression
;
let
matchingObject
;
if
(
astExpression
.
type
=
=
=
"
ArrayExpression
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Array
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
typeof
astExpression
.
value
=
=
=
"
string
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
String
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
Number
.
isFinite
(
astExpression
.
value
)
)
{
if
(
!
Number
.
isInteger
(
astExpression
.
value
)
|
|
/
\
d
[
^
\
.
]
{
0
}
\
.
/
.
test
(
completionPart
)
=
=
=
false
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Number
"
)
;
}
else
{
return
null
;
}
}
if
(
matchingObject
)
{
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
matchProp
)
)
{
elementAccessQuote
=
matchProp
[
0
]
;
search
=
matchProp
.
replace
(
startQuoteRegex
"
"
)
;
}
let
props
=
getMatchedPropsInDbgObject
(
matchingObject
search
)
;
if
(
isElementAccess
)
{
props
=
wrapMatchesInQuotes
(
props
elementAccessQuote
)
;
}
return
{
isElementAccess
matchProp
matches
:
props
}
;
}
}
}
let
properties
=
[
]
;
if
(
astExpression
)
{
if
(
lastCompletionCharIndex
>
-
1
)
{
properties
=
getPropertiesFromAstExpression
(
astExpression
)
;
if
(
properties
=
=
=
null
)
{
return
null
;
}
}
}
else
{
properties
=
completionPart
.
split
(
"
.
"
)
;
if
(
isElementAccess
)
{
const
lastPart
=
properties
[
properties
.
length
-
1
]
;
const
openBracketIndex
=
lastPart
.
lastIndexOf
(
"
[
"
)
;
matchProp
=
lastPart
.
substr
(
openBracketIndex
+
1
)
;
properties
[
properties
.
length
-
1
]
=
lastPart
.
substring
(
0
openBracketIndex
)
;
}
else
{
matchProp
=
properties
.
pop
(
)
.
trimLeft
(
)
;
}
}
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
search
)
)
{
elementAccessQuote
=
search
[
0
]
;
search
=
search
.
replace
(
startQuoteRegex
"
"
)
;
}
let
obj
=
dbgObject
;
if
(
properties
.
length
=
=
=
0
)
{
return
{
isElementAccess
matchProp
matches
:
getMatchedPropsInEnvironment
(
env
search
)
}
;
}
const
firstProp
=
properties
.
shift
(
)
.
trim
(
)
;
if
(
firstProp
=
=
=
"
this
"
)
{
try
{
obj
=
env
.
object
;
}
catch
(
e
)
{
}
}
else
if
(
firstProp
=
=
=
"
_
"
&
&
webconsoleActor
)
{
obj
=
webconsoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
else
if
(
firstProp
=
=
=
"
0
"
&
&
selectedNodeActor
&
&
webconsoleActor
)
{
const
actor
=
webconsoleActor
.
conn
.
getActor
(
selectedNodeActor
)
;
if
(
actor
)
{
try
{
obj
=
webconsoleActor
.
makeDebuggeeValue
(
actor
.
rawNode
)
;
}
catch
(
e
)
{
}
}
}
else
if
(
hasArrayIndex
(
firstProp
)
)
{
obj
=
getArrayMemberProperty
(
null
env
firstProp
)
;
}
else
{
obj
=
getVariableInEnvironment
(
env
firstProp
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
for
(
let
[
index
prop
]
of
properties
.
entries
(
)
)
{
if
(
typeof
prop
=
=
=
"
string
"
)
{
prop
=
prop
.
trim
(
)
;
}
if
(
prop
=
=
=
undefined
|
|
prop
=
=
=
null
|
|
prop
=
=
=
"
"
)
{
return
null
;
}
const
propPath
=
[
firstProp
]
.
concat
(
properties
.
slice
(
0
index
+
1
)
)
;
const
authorized
=
authorizedEvaluations
.
some
(
x
=
>
JSON
.
stringify
(
x
)
=
=
=
JSON
.
stringify
(
propPath
)
)
;
if
(
!
authorized
&
&
DevToolsUtils
.
isUnsafeGetter
(
obj
prop
)
)
{
return
{
isUnsafeGetter
:
true
getterPath
:
propPath
}
;
}
if
(
hasArrayIndex
(
prop
)
)
{
obj
=
getArrayMemberProperty
(
obj
null
prop
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
prop
authorized
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
const
prepareReturnedObject
=
matches
=
>
{
if
(
isElementAccess
)
{
matches
=
wrapMatchesInQuotes
(
matches
elementAccessQuote
)
;
}
else
if
(
!
isWorker
)
{
for
(
const
match
of
matches
)
{
try
{
Reflect
.
parse
(
(
{
{
match
}
:
true
}
)
)
;
}
catch
(
e
)
{
matches
.
delete
(
match
)
;
}
}
}
return
{
isElementAccess
matchProp
matches
}
;
}
;
if
(
typeof
obj
!
=
"
object
"
)
{
return
prepareReturnedObject
(
getMatchedProps
(
obj
search
)
)
;
}
return
prepareReturnedObject
(
getMatchedPropsInDbgObject
(
obj
search
)
)
;
}
function
getContentPrototypeObject
(
env
name
)
{
let
outermostEnv
=
env
;
while
(
outermostEnv
&
&
outermostEnv
.
parent
)
{
outermostEnv
=
outermostEnv
.
parent
;
}
const
constructorObj
=
DevToolsUtils
.
getProperty
(
outermostEnv
.
object
name
)
;
if
(
!
constructorObj
)
{
return
null
;
}
return
DevToolsUtils
.
getProperty
(
constructorObj
"
prototype
"
)
;
}
function
getPropertiesFromAstExpression
(
ast
)
{
let
result
=
[
]
;
if
(
!
ast
)
{
return
result
;
}
const
{
type
property
object
name
}
=
ast
;
if
(
type
=
=
=
"
ThisExpression
"
)
{
result
.
unshift
(
"
this
"
)
;
}
else
if
(
type
=
=
=
"
Identifier
"
&
&
name
)
{
result
.
unshift
(
name
)
;
}
else
if
(
type
=
=
=
"
MemberExpression
"
)
{
if
(
property
)
{
if
(
property
.
type
=
=
=
"
Identifier
"
&
&
property
.
name
)
{
result
.
unshift
(
property
.
name
)
;
}
else
if
(
property
.
type
=
=
=
"
Literal
"
)
{
result
.
unshift
(
property
.
value
)
;
}
}
if
(
object
)
{
result
=
(
getPropertiesFromAstExpression
(
object
)
|
|
[
]
)
.
concat
(
result
)
;
}
}
else
{
return
null
;
}
return
result
;
}
function
wrapMatchesInQuotes
(
matches
quote
=
"
)
{
return
new
Set
(
[
.
.
.
matches
]
.
map
(
p
=
>
{
p
=
JSON
.
stringify
(
p
)
;
if
(
quote
=
=
"
)
{
return
p
;
}
p
=
p
.
slice
(
1
-
1
)
;
p
=
p
.
replace
(
/
\
\
(
?
=
"
)
/
g
"
"
)
;
p
=
p
.
replace
(
new
RegExp
(
quote
"
g
"
)
"
\
\
&
"
)
;
if
(
quote
=
=
"
"
)
{
p
=
p
.
replace
(
/
\
{
/
g
"
\
\
&
"
)
;
}
return
{
quote
}
{
p
}
{
quote
}
;
}
)
)
;
}
function
getArrayMemberProperty
(
obj
env
prop
)
{
const
propWithoutIndices
=
prop
.
substr
(
0
prop
.
indexOf
(
"
[
"
)
)
;
if
(
env
)
{
obj
=
getVariableInEnvironment
(
env
propWithoutIndices
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
propWithoutIndices
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
let
result
;
const
arrayIndicesRegex
=
/
\
[
[
^
\
]
]
*
\
]
/
g
;
while
(
(
result
=
arrayIndicesRegex
.
exec
(
prop
)
)
!
=
=
null
)
{
const
indexWithBrackets
=
result
[
0
]
;
const
indexAsText
=
indexWithBrackets
.
substr
(
1
indexWithBrackets
.
length
-
2
)
;
const
index
=
parseInt
(
indexAsText
10
)
;
if
(
isNaN
(
index
)
)
{
return
null
;
}
obj
=
DevToolsUtils
.
getProperty
(
obj
index
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
return
obj
;
}
function
isObjectUsable
(
object
)
{
if
(
object
=
=
null
)
{
return
false
;
}
if
(
typeof
object
=
=
"
object
"
&
&
object
.
class
=
=
"
DeadObject
"
)
{
return
false
;
}
return
true
;
}
function
getVariableInEnvironment
(
environment
name
)
{
return
getExactMatchImpl
(
environment
name
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInEnvironment
(
environment
match
)
{
return
getMatchedPropsImpl
(
environment
match
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInDbgObject
(
dbgObject
match
)
{
return
getMatchedPropsImpl
(
dbgObject
match
DebuggerObjectSupport
)
;
}
function
getMatchedProps
(
obj
match
)
{
if
(
typeof
obj
!
=
"
object
"
)
{
obj
=
obj
.
constructor
.
prototype
;
}
return
getMatchedPropsImpl
(
obj
match
JSObjectSupport
)
;
}
function
getMatchedPropsImpl
(
obj
match
{
chainIterator
getProperties
}
)
{
const
matches
=
new
Set
(
)
;
let
numProps
=
0
;
const
insensitiveMatching
=
match
&
&
match
[
0
]
.
toUpperCase
(
)
!
=
=
match
[
0
]
;
const
propertyMatches
=
prop
=
>
{
return
insensitiveMatching
?
prop
.
toLocaleLowerCase
(
)
.
startsWith
(
match
.
toLocaleLowerCase
(
)
)
:
prop
.
startsWith
(
match
)
;
}
;
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
props
=
getProperties
(
obj
)
;
if
(
!
props
)
{
continue
;
}
numProps
+
=
props
.
length
;
if
(
numProps
>
=
MAX_AUTOCOMPLETE_ATTEMPTS
|
|
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
const
prop
=
props
[
i
]
;
if
(
!
propertyMatches
(
prop
)
)
{
continue
;
}
if
(
+
prop
!
=
+
prop
)
{
matches
.
add
(
prop
)
;
}
if
(
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
}
}
return
matches
;
}
function
getExactMatchImpl
(
obj
name
{
chainIterator
getProperty
}
)
{
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
prop
=
getProperty
(
obj
name
obj
)
;
if
(
prop
)
{
return
prop
.
value
;
}
}
return
undefined
;
}
var
JSObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
Object
.
getPrototypeOf
(
obj
)
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
Object
.
getOwnPropertyNames
(
obj
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
obj
.
proto
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
obj
name
rootObj
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerEnvironmentSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
obj
=
obj
.
parent
;
}
}
getProperties
:
function
(
obj
)
{
const
names
=
obj
.
names
(
)
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
if
(
i
=
=
=
names
.
length
-
1
|
|
names
[
i
+
1
]
>
"
this
"
)
{
names
.
splice
(
i
+
1
0
"
this
"
)
;
break
;
}
}
return
names
;
}
getProperty
:
function
(
obj
name
)
{
let
result
;
try
{
result
=
obj
.
getVariable
(
name
)
;
}
catch
(
e
)
{
}
if
(
result
=
=
=
undefined
|
|
result
.
optimizedOut
|
|
result
.
missingArguments
)
{
return
null
;
}
return
{
value
:
result
}
;
}
}
;
exports
.
JSPropertyProvider
=
DevToolsUtils
.
makeInfallible
(
JSPropertyProvider
)
;
exports
.
FallibleJSPropertyProvider
=
JSPropertyProvider
;
