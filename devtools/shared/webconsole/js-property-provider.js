"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
evalWithDebugger
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
getSyntaxTrees
"
"
devtools
/
shared
/
webconsole
/
parser
-
helper
"
true
)
;
}
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
const
MAX_AUTOCOMPLETE_ATTEMPTS
=
(
exports
.
MAX_AUTOCOMPLETE_ATTEMPTS
=
100000
)
;
const
MAX_AUTOCOMPLETIONS
=
(
exports
.
MAX_AUTOCOMPLETIONS
=
1500
)
;
function
JSPropertyProvider
(
{
dbgObject
environment
inputValue
cursor
authorizedEvaluations
=
[
]
webconsoleActor
selectedNodeActor
expressionVars
=
[
]
}
)
{
if
(
cursor
=
=
=
undefined
)
{
cursor
=
inputValue
.
length
;
}
inputValue
=
inputValue
.
substring
(
0
cursor
)
;
const
inputAnalysis
=
analyzeInputString
(
inputValue
)
;
if
(
!
shouldInputBeAutocompleted
(
inputAnalysis
)
)
{
return
null
;
}
let
{
lastStatement
isElementAccess
mainExpression
matchProp
isPropertyAccess
}
=
inputAnalysis
;
if
(
webconsoleActor
&
&
shouldInputBeEagerlyEvaluated
(
inputAnalysis
)
)
{
const
eagerResponse
=
evalWithDebugger
(
mainExpression
{
eager
:
true
selectedNodeActor
}
webconsoleActor
)
;
const
ret
=
eagerResponse
?
.
result
?
.
return
;
if
(
ret
&
&
ret
!
=
=
undefined
)
{
const
matches
=
typeof
ret
!
=
"
object
"
?
getMatchedProps
(
ret
matchProp
)
:
getMatchedPropsInDbgObject
(
ret
matchProp
)
;
return
prepareReturnedObject
(
{
matches
search
:
matchProp
isElementAccess
}
)
;
}
}
let
astExpression
;
const
startQuoteRegex
=
/
^
(
'
|
"
|
)
/
;
const
env
=
environment
|
|
dbgObject
.
asEnvironment
(
)
;
if
(
!
isWorker
&
&
isPropertyAccess
)
{
const
syntaxTrees
=
getSyntaxTrees
(
mainExpression
)
;
const
lastTree
=
syntaxTrees
[
syntaxTrees
.
length
-
1
]
;
const
lastBody
=
lastTree
?
.
body
[
lastTree
.
body
.
length
-
1
]
;
if
(
lastBody
)
{
if
(
!
lastBody
.
expression
)
{
return
null
;
}
astExpression
=
lastBody
.
expression
;
let
matchingObject
;
if
(
astExpression
.
type
=
=
=
"
ArrayExpression
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Array
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
typeof
astExpression
.
value
=
=
=
"
string
"
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
String
"
)
;
}
else
if
(
astExpression
.
type
=
=
=
"
Literal
"
&
&
Number
.
isFinite
(
astExpression
.
value
)
)
{
if
(
!
Number
.
isInteger
(
astExpression
.
value
)
|
|
/
\
d
[
^
\
.
]
{
0
}
\
.
/
.
test
(
lastStatement
)
=
=
=
false
)
{
matchingObject
=
getContentPrototypeObject
(
env
"
Number
"
)
;
}
else
{
return
null
;
}
}
if
(
matchingObject
)
{
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
matchProp
)
)
{
elementAccessQuote
=
matchProp
[
0
]
;
search
=
matchProp
.
replace
(
startQuoteRegex
"
"
)
;
}
let
props
=
getMatchedPropsInDbgObject
(
matchingObject
search
)
;
if
(
isElementAccess
)
{
props
=
wrapMatchesInQuotes
(
props
elementAccessQuote
)
;
}
return
{
isElementAccess
matchProp
matches
:
props
}
;
}
}
}
let
properties
=
[
]
;
if
(
astExpression
)
{
if
(
isPropertyAccess
)
{
properties
=
getPropertiesFromAstExpression
(
astExpression
)
;
if
(
properties
=
=
=
null
)
{
return
null
;
}
}
}
else
{
properties
=
lastStatement
.
split
(
"
.
"
)
;
if
(
isElementAccess
)
{
const
lastPart
=
properties
[
properties
.
length
-
1
]
;
const
openBracketIndex
=
lastPart
.
lastIndexOf
(
"
[
"
)
;
matchProp
=
lastPart
.
substr
(
openBracketIndex
+
1
)
;
properties
[
properties
.
length
-
1
]
=
lastPart
.
substring
(
0
openBracketIndex
)
;
}
else
{
matchProp
=
properties
.
pop
(
)
.
trimLeft
(
)
;
}
}
let
search
=
matchProp
;
let
elementAccessQuote
;
if
(
isElementAccess
&
&
startQuoteRegex
.
test
(
search
)
)
{
elementAccessQuote
=
search
[
0
]
;
search
=
search
.
replace
(
startQuoteRegex
"
"
)
;
}
let
obj
=
dbgObject
;
if
(
properties
.
length
=
=
=
0
)
{
const
environmentProperties
=
getMatchedPropsInEnvironment
(
env
search
)
;
const
expressionVariables
=
new
Set
(
expressionVars
.
filter
(
variableName
=
>
variableName
.
startsWith
(
matchProp
)
)
)
;
for
(
const
prop
of
environmentProperties
)
{
expressionVariables
.
add
(
prop
)
;
}
return
{
isElementAccess
matchProp
matches
:
expressionVariables
}
;
}
let
firstProp
=
properties
.
shift
(
)
;
if
(
typeof
firstProp
=
=
"
string
"
)
{
firstProp
=
firstProp
.
trim
(
)
;
}
if
(
firstProp
=
=
=
"
this
"
)
{
try
{
obj
=
env
.
object
;
}
catch
(
e
)
{
}
}
else
if
(
firstProp
=
=
=
"
_
"
&
&
webconsoleActor
)
{
obj
=
webconsoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
else
if
(
firstProp
=
=
=
"
0
"
&
&
selectedNodeActor
&
&
webconsoleActor
)
{
const
actor
=
webconsoleActor
.
conn
.
getActor
(
selectedNodeActor
)
;
if
(
actor
)
{
try
{
obj
=
webconsoleActor
.
makeDebuggeeValue
(
actor
.
rawNode
)
;
}
catch
(
e
)
{
}
}
}
else
if
(
hasArrayIndex
(
firstProp
)
)
{
obj
=
getArrayMemberProperty
(
null
env
firstProp
)
;
}
else
{
obj
=
getVariableInEnvironment
(
env
firstProp
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
for
(
let
[
index
prop
]
of
properties
.
entries
(
)
)
{
if
(
typeof
prop
=
=
=
"
string
"
)
{
prop
=
prop
.
trim
(
)
;
}
if
(
prop
=
=
=
undefined
|
|
prop
=
=
=
null
|
|
prop
=
=
=
"
"
)
{
return
null
;
}
const
propPath
=
[
firstProp
]
.
concat
(
properties
.
slice
(
0
index
+
1
)
)
;
const
authorized
=
authorizedEvaluations
.
some
(
x
=
>
JSON
.
stringify
(
x
)
=
=
=
JSON
.
stringify
(
propPath
)
)
;
if
(
!
authorized
&
&
DevToolsUtils
.
isUnsafeGetter
(
obj
prop
)
)
{
return
{
isUnsafeGetter
:
true
getterPath
:
propPath
}
;
}
if
(
hasArrayIndex
(
prop
)
)
{
obj
=
getArrayMemberProperty
(
obj
null
prop
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
prop
authorized
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
const
matches
=
typeof
obj
!
=
"
object
"
?
getMatchedProps
(
obj
search
)
:
getMatchedPropsInDbgObject
(
obj
search
)
;
return
prepareReturnedObject
(
{
matches
search
isElementAccess
elementAccessQuote
}
)
;
}
function
shouldInputBeEagerlyEvaluated
(
{
lastStatement
}
)
{
const
inComputedProperty
=
lastStatement
.
lastIndexOf
(
"
[
"
)
!
=
=
-
1
&
&
lastStatement
.
lastIndexOf
(
"
[
"
)
>
lastStatement
.
lastIndexOf
(
"
]
"
)
;
const
hasPropertyAccess
=
lastStatement
.
includes
(
"
.
"
)
|
|
lastStatement
.
includes
(
"
[
"
)
;
return
hasPropertyAccess
&
&
!
inComputedProperty
;
}
function
shouldInputBeAutocompleted
(
inputAnalysisState
)
{
const
{
err
state
lastStatement
}
=
inputAnalysisState
;
if
(
err
)
{
return
false
;
}
if
(
state
!
=
STATE_NORMAL
)
{
return
false
;
}
if
(
lastStatement
.
trim
(
)
=
=
"
"
)
{
return
false
;
}
if
(
NO_AUTOCOMPLETE_PREFIXES
.
some
(
prefix
=
>
lastStatement
.
startsWith
(
prefix
+
"
"
)
)
)
{
return
false
;
}
return
true
;
}
function
hasArrayIndex
(
str
)
{
return
/
\
[
\
d
+
\
]
/
.
test
(
str
)
;
}
const
STATE_NORMAL
=
Symbol
(
"
STATE_NORMAL
"
)
;
const
STATE_QUOTE
=
Symbol
(
"
STATE_QUOTE
"
)
;
const
STATE_DQUOTE
=
Symbol
(
"
STATE_DQUOTE
"
)
;
const
STATE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_TEMPLATE_LITERAL
"
)
;
const
STATE_ESCAPE_QUOTE
=
Symbol
(
"
STATE_ESCAPE_QUOTE
"
)
;
const
STATE_ESCAPE_DQUOTE
=
Symbol
(
"
STATE_ESCAPE_DQUOTE
"
)
;
const
STATE_ESCAPE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_ESCAPE_TEMPLATE_LITERAL
"
)
;
const
STATE_SLASH
=
Symbol
(
"
STATE_SLASH
"
)
;
const
STATE_INLINE_COMMENT
=
Symbol
(
"
STATE_INLINE_COMMENT
"
)
;
const
STATE_MULTILINE_COMMENT
=
Symbol
(
"
STATE_MULTILINE_COMMENT
"
)
;
const
STATE_MULTILINE_COMMENT_CLOSE
=
Symbol
(
"
STATE_MULTILINE_COMMENT_CLOSE
"
)
;
const
STATE_QUESTION_MARK
=
Symbol
(
"
STATE_QUESTION_MARK
"
)
;
const
OPEN_BODY
=
"
{
[
(
"
.
split
(
"
"
)
;
const
CLOSE_BODY
=
"
}
]
)
"
.
split
(
"
"
)
;
const
OPEN_CLOSE_BODY
=
{
"
{
"
:
"
}
"
"
[
"
:
"
]
"
"
(
"
:
"
)
"
}
;
const
NO_AUTOCOMPLETE_PREFIXES
=
[
"
var
"
"
const
"
"
let
"
"
function
"
"
class
"
]
;
const
OPERATOR_CHARS_SET
=
new
Set
(
"
;
:
=
<
>
+
-
*
%
|
&
^
~
!
"
.
split
(
"
"
)
)
;
function
analyzeInputString
(
str
)
{
const
bodyStack
=
[
]
;
let
state
=
STATE_NORMAL
;
let
previousNonWhitespaceChar
;
let
lastStatement
=
"
"
;
let
currentIndex
=
-
1
;
let
dotIndex
;
let
pendingWhitespaceChars
=
"
"
;
const
TIMEOUT
=
2500
;
const
startingTime
=
Date
.
now
(
)
;
for
(
const
c
of
str
)
{
if
(
Date
.
now
(
)
-
startingTime
>
TIMEOUT
)
{
return
{
err
:
"
timeout
"
}
;
}
currentIndex
+
=
1
;
let
resetLastStatement
=
false
;
const
isWhitespaceChar
=
c
.
trim
(
)
=
=
=
"
"
;
switch
(
state
)
{
case
STATE_NORMAL
:
if
(
lastStatement
.
endsWith
(
"
?
.
"
)
&
&
/
\
d
/
.
test
(
c
)
)
{
lastStatement
=
"
"
;
}
if
(
c
=
=
=
"
.
"
)
{
dotIndex
=
currentIndex
;
}
if
(
pendingWhitespaceChars
&
&
!
isWhitespaceChar
)
{
if
(
c
=
=
=
"
[
"
|
|
c
=
=
=
"
.
"
|
|
c
=
=
=
"
?
"
)
{
lastStatement
=
lastStatement
+
pendingWhitespaceChars
;
}
else
{
lastStatement
=
"
"
;
}
pendingWhitespaceChars
=
"
"
;
}
if
(
c
=
=
'
"
'
)
{
state
=
STATE_DQUOTE
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_QUOTE
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_TEMPLATE_LITERAL
;
}
else
if
(
c
=
=
"
/
"
)
{
state
=
STATE_SLASH
;
}
else
if
(
c
=
=
"
?
"
)
{
state
=
STATE_QUESTION_MARK
;
}
else
if
(
OPERATOR_CHARS_SET
.
has
(
c
)
)
{
resetLastStatement
=
true
;
}
else
if
(
isWhitespaceChar
)
{
if
(
previousNonWhitespaceChar
!
=
=
"
.
"
&
&
previousNonWhitespaceChar
!
=
=
"
[
"
&
&
!
NO_AUTOCOMPLETE_PREFIXES
.
includes
(
lastStatement
)
)
{
pendingWhitespaceChars
+
=
c
;
continue
;
}
}
else
if
(
OPEN_BODY
.
includes
(
c
)
)
{
bodyStack
.
push
(
{
token
:
c
lastStatement
index
:
currentIndex
}
)
;
resetLastStatement
=
true
;
}
else
if
(
CLOSE_BODY
.
includes
(
c
)
)
{
const
last
=
bodyStack
.
pop
(
)
;
if
(
!
last
|
|
OPEN_CLOSE_BODY
[
last
.
token
]
!
=
c
)
{
return
{
err
:
"
syntax
error
"
}
;
}
if
(
c
=
=
"
}
"
)
{
resetLastStatement
=
true
;
}
else
{
lastStatement
=
last
.
lastStatement
;
}
}
break
;
case
STATE_ESCAPE_QUOTE
:
state
=
STATE_QUOTE
;
break
;
case
STATE_ESCAPE_DQUOTE
:
state
=
STATE_DQUOTE
;
break
;
case
STATE_ESCAPE_TEMPLATE_LITERAL
:
state
=
STATE_TEMPLATE_LITERAL
;
break
;
case
STATE_DQUOTE
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_DQUOTE
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
'
"
'
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_TEMPLATE_LITERAL
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_TEMPLATE_LITERAL
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_QUOTE
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_QUOTE
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_SLASH
:
if
(
c
=
=
"
/
"
)
{
state
=
STATE_INLINE_COMMENT
;
}
else
if
(
c
=
=
"
*
"
)
{
state
=
STATE_MULTILINE_COMMENT
;
}
else
{
lastStatement
=
"
"
;
state
=
STATE_NORMAL
;
}
break
;
case
STATE_INLINE_COMMENT
:
if
(
c
=
=
=
"
\
n
"
)
{
state
=
STATE_NORMAL
;
resetLastStatement
=
true
;
}
break
;
case
STATE_MULTILINE_COMMENT
:
if
(
c
=
=
=
"
*
"
)
{
state
=
STATE_MULTILINE_COMMENT_CLOSE
;
}
break
;
case
STATE_MULTILINE_COMMENT_CLOSE
:
if
(
c
=
=
=
"
/
"
)
{
state
=
STATE_NORMAL
;
resetLastStatement
=
true
;
}
else
{
state
=
STATE_MULTILINE_COMMENT
;
}
break
;
case
STATE_QUESTION_MARK
:
state
=
STATE_NORMAL
;
if
(
c
=
=
=
"
?
"
)
{
resetLastStatement
=
true
;
}
else
if
(
c
!
=
=
"
.
"
)
{
lastStatement
=
"
"
;
}
else
{
dotIndex
=
currentIndex
;
}
break
;
}
if
(
!
isWhitespaceChar
)
{
previousNonWhitespaceChar
=
c
;
}
if
(
resetLastStatement
)
{
lastStatement
=
"
"
;
}
else
{
lastStatement
=
lastStatement
+
c
;
}
bodyStack
.
forEach
(
stack
=
>
{
if
(
stack
.
token
!
=
=
"
}
"
)
{
stack
.
lastStatement
=
stack
.
lastStatement
+
c
;
}
}
)
;
}
let
isElementAccess
=
false
;
let
lastOpeningBracketIndex
=
-
1
;
if
(
bodyStack
.
length
=
=
=
1
&
&
bodyStack
[
0
]
.
token
=
=
=
"
[
"
)
{
lastStatement
=
bodyStack
[
0
]
.
lastStatement
;
lastOpeningBracketIndex
=
bodyStack
[
0
]
.
index
;
isElementAccess
=
true
;
if
(
state
=
=
=
STATE_DQUOTE
|
|
state
=
=
=
STATE_QUOTE
|
|
state
=
=
=
STATE_TEMPLATE_LITERAL
|
|
state
=
=
=
STATE_ESCAPE_QUOTE
|
|
state
=
=
=
STATE_ESCAPE_DQUOTE
|
|
state
=
=
=
STATE_ESCAPE_TEMPLATE_LITERAL
)
{
state
=
STATE_NORMAL
;
}
}
else
if
(
pendingWhitespaceChars
)
{
lastStatement
=
"
"
;
}
const
lastCompletionCharIndex
=
isElementAccess
?
lastOpeningBracketIndex
:
dotIndex
;
const
stringBeforeLastCompletionChar
=
str
.
slice
(
0
lastCompletionCharIndex
)
;
const
isPropertyAccess
=
lastCompletionCharIndex
&
&
lastCompletionCharIndex
>
0
;
const
optionalElementAccessRegex
=
/
\
?
\
.
\
s
*
/
;
const
isOptionalAccess
=
isElementAccess
?
optionalElementAccessRegex
.
test
(
stringBeforeLastCompletionChar
)
:
isPropertyAccess
&
&
str
.
slice
(
lastCompletionCharIndex
-
1
lastCompletionCharIndex
+
1
)
=
=
=
"
?
.
"
;
const
matchProp
=
isPropertyAccess
?
str
.
slice
(
lastCompletionCharIndex
+
1
)
.
trimLeft
(
)
:
null
;
const
expressionBeforePropertyAccess
=
isPropertyAccess
?
str
.
slice
(
0
isOptionalAccess
?
stringBeforeLastCompletionChar
.
lastIndexOf
(
"
?
"
)
:
lastCompletionCharIndex
)
:
str
;
let
mainExpression
=
lastStatement
;
if
(
isPropertyAccess
)
{
if
(
isOptionalAccess
)
{
mainExpression
=
mainExpression
.
slice
(
0
mainExpression
.
lastIndexOf
(
"
?
"
)
)
;
}
else
{
mainExpression
=
mainExpression
.
slice
(
0
-
1
*
(
str
.
length
-
lastCompletionCharIndex
)
)
;
}
}
mainExpression
=
mainExpression
.
trim
(
)
;
return
{
state
isElementAccess
isPropertyAccess
expressionBeforePropertyAccess
lastStatement
mainExpression
matchProp
}
;
}
function
getContentPrototypeObject
(
env
name
)
{
let
outermostEnv
=
env
;
while
(
outermostEnv
?
.
parent
)
{
outermostEnv
=
outermostEnv
.
parent
;
}
const
constructorObj
=
DevToolsUtils
.
getProperty
(
outermostEnv
.
object
name
)
;
if
(
!
constructorObj
)
{
return
null
;
}
return
DevToolsUtils
.
getProperty
(
constructorObj
"
prototype
"
)
;
}
function
getPropertiesFromAstExpression
(
ast
)
{
let
result
=
[
]
;
if
(
!
ast
)
{
return
result
;
}
const
{
type
property
object
name
expression
}
=
ast
;
if
(
type
=
=
=
"
ThisExpression
"
)
{
result
.
unshift
(
"
this
"
)
;
}
else
if
(
type
=
=
=
"
Identifier
"
&
&
name
)
{
result
.
unshift
(
name
)
;
}
else
if
(
type
=
=
=
"
OptionalExpression
"
&
&
expression
)
{
result
=
(
getPropertiesFromAstExpression
(
expression
)
|
|
[
]
)
.
concat
(
result
)
;
}
else
if
(
type
=
=
=
"
MemberExpression
"
|
|
type
=
=
=
"
OptionalMemberExpression
"
)
{
if
(
property
)
{
if
(
property
.
type
=
=
=
"
Identifier
"
&
&
property
.
name
)
{
result
.
unshift
(
property
.
name
)
;
}
else
if
(
property
.
type
=
=
=
"
Literal
"
)
{
result
.
unshift
(
property
.
value
)
;
}
}
if
(
object
)
{
result
=
(
getPropertiesFromAstExpression
(
object
)
|
|
[
]
)
.
concat
(
result
)
;
}
}
else
{
return
null
;
}
return
result
;
}
function
wrapMatchesInQuotes
(
matches
quote
=
"
)
{
return
new
Set
(
[
.
.
.
matches
]
.
map
(
p
=
>
{
p
=
JSON
.
stringify
(
p
)
;
if
(
quote
=
=
"
)
{
return
p
;
}
p
=
p
.
slice
(
1
-
1
)
;
p
=
p
.
replace
(
/
\
\
(
?
=
"
)
/
g
"
"
)
;
p
=
p
.
replace
(
new
RegExp
(
quote
"
g
"
)
"
\
\
&
"
)
;
if
(
quote
=
=
"
"
)
{
p
=
p
.
replace
(
/
\
{
/
g
"
\
\
&
"
)
;
}
return
{
quote
}
{
p
}
{
quote
}
;
}
)
)
;
}
function
getArrayMemberProperty
(
obj
env
prop
)
{
const
propWithoutIndices
=
prop
.
substr
(
0
prop
.
indexOf
(
"
[
"
)
)
;
if
(
env
)
{
obj
=
getVariableInEnvironment
(
env
propWithoutIndices
)
;
}
else
{
obj
=
DevToolsUtils
.
getProperty
(
obj
propWithoutIndices
)
;
}
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
let
result
;
const
arrayIndicesRegex
=
/
\
[
[
^
\
]
]
*
\
]
/
g
;
while
(
(
result
=
arrayIndicesRegex
.
exec
(
prop
)
)
!
=
=
null
)
{
const
indexWithBrackets
=
result
[
0
]
;
const
indexAsText
=
indexWithBrackets
.
substr
(
1
indexWithBrackets
.
length
-
2
)
;
const
index
=
parseInt
(
indexAsText
10
)
;
if
(
isNaN
(
index
)
)
{
return
null
;
}
obj
=
DevToolsUtils
.
getProperty
(
obj
index
)
;
if
(
!
isObjectUsable
(
obj
)
)
{
return
null
;
}
}
return
obj
;
}
function
isObjectUsable
(
object
)
{
if
(
object
=
=
null
)
{
return
false
;
}
if
(
typeof
object
=
=
"
object
"
&
&
object
.
class
=
=
"
DeadObject
"
)
{
return
false
;
}
return
true
;
}
function
getVariableInEnvironment
(
environment
name
)
{
return
getExactMatchImpl
(
environment
name
DebuggerEnvironmentSupport
)
;
}
function
prepareReturnedObject
(
{
matches
search
isElementAccess
elementAccessQuote
}
)
{
if
(
isElementAccess
)
{
matches
=
wrapMatchesInQuotes
(
matches
elementAccessQuote
)
;
}
else
if
(
!
isWorker
)
{
for
(
const
match
of
matches
)
{
try
{
Reflect
.
parse
(
(
{
{
match
}
:
true
}
)
)
;
}
catch
(
e
)
{
matches
.
delete
(
match
)
;
}
}
}
return
{
isElementAccess
matchProp
:
search
matches
}
;
}
function
getMatchedPropsInEnvironment
(
environment
match
)
{
return
getMatchedPropsImpl
(
environment
match
DebuggerEnvironmentSupport
)
;
}
function
getMatchedPropsInDbgObject
(
dbgObject
match
)
{
return
getMatchedPropsImpl
(
dbgObject
match
DebuggerObjectSupport
)
;
}
function
getMatchedProps
(
obj
match
)
{
if
(
typeof
obj
!
=
"
object
"
)
{
obj
=
obj
.
constructor
.
prototype
;
}
return
getMatchedPropsImpl
(
obj
match
JSObjectSupport
)
;
}
function
getMatchedPropsImpl
(
obj
match
{
chainIterator
getProperties
}
)
{
const
matches
=
new
Set
(
)
;
let
numProps
=
0
;
const
insensitiveMatching
=
match
&
&
match
[
0
]
.
toUpperCase
(
)
!
=
=
match
[
0
]
;
const
propertyMatches
=
prop
=
>
{
return
insensitiveMatching
?
prop
.
toLocaleLowerCase
(
)
.
startsWith
(
match
.
toLocaleLowerCase
(
)
)
:
prop
.
startsWith
(
match
)
;
}
;
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
props
=
getProperties
(
obj
)
;
if
(
!
props
)
{
continue
;
}
numProps
+
=
props
.
length
;
if
(
numProps
>
=
MAX_AUTOCOMPLETE_ATTEMPTS
|
|
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
const
prop
=
props
[
i
]
;
if
(
!
propertyMatches
(
prop
)
)
{
continue
;
}
if
(
+
prop
!
=
+
prop
)
{
matches
.
add
(
prop
)
;
}
if
(
matches
.
size
>
=
MAX_AUTOCOMPLETIONS
)
{
break
;
}
}
}
return
matches
;
}
function
getExactMatchImpl
(
obj
name
{
chainIterator
getProperty
}
)
{
const
iter
=
chainIterator
(
obj
)
;
for
(
obj
of
iter
)
{
const
prop
=
getProperty
(
obj
name
obj
)
;
if
(
prop
)
{
return
prop
.
value
;
}
}
return
undefined
;
}
var
JSObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
Object
.
getPrototypeOf
(
obj
)
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
Object
.
getOwnPropertyNames
(
obj
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerObjectSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
try
{
obj
=
obj
.
proto
;
}
catch
(
error
)
{
return
;
}
}
}
getProperties
:
function
(
obj
)
{
try
{
return
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
error
)
{
return
null
;
}
}
getProperty
:
function
(
obj
name
rootObj
)
{
throw
new
Error
(
"
Unimplemented
!
"
)
;
}
}
;
var
DebuggerEnvironmentSupport
=
{
chainIterator
:
function
*
(
obj
)
{
while
(
obj
)
{
yield
obj
;
obj
=
obj
.
parent
;
}
}
getProperties
:
function
(
obj
)
{
const
names
=
obj
.
names
(
)
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
if
(
i
=
=
=
names
.
length
-
1
|
|
names
[
i
+
1
]
>
"
this
"
)
{
names
.
splice
(
i
+
1
0
"
this
"
)
;
break
;
}
}
return
names
;
}
getProperty
:
function
(
obj
name
)
{
let
result
;
try
{
result
=
obj
.
getVariable
(
name
)
;
}
catch
(
e
)
{
}
if
(
result
=
=
null
|
|
(
typeof
result
=
=
"
object
"
&
&
(
result
.
optimizedOut
|
|
result
.
missingArguments
)
)
)
{
return
null
;
}
return
{
value
:
result
}
;
}
}
;
exports
.
JSPropertyProvider
=
DevToolsUtils
.
makeInfallible
(
JSPropertyProvider
)
;
exports
.
FallibleJSPropertyProvider
=
JSPropertyProvider
;
exports
.
analyzeInputString
=
analyzeInputString
;
