"
use
strict
"
;
const
{
Cc
Ci
Cu
components
}
=
require
(
"
chrome
"
)
;
const
{
isWindowIncluded
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
swm
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
const
REGEX_MATCH_FUNCTION_NAME
=
/
^
\
(
?
function
\
s
+
(
[
^
(
\
s
]
+
)
\
s
*
\
(
/
;
const
REGEX_MATCH_FUNCTION_ARGS
=
/
^
\
(
?
function
\
s
*
[
^
\
s
(
]
*
\
s
*
\
(
(
.
+
?
)
\
)
/
;
const
CONSOLE_ENTRY_THRESHOLD
=
5
;
const
CONSOLE_WORKER_IDS
=
exports
.
CONSOLE_WORKER_IDS
=
[
'
SharedWorker
'
'
ServiceWorker
'
'
Worker
'
]
;
var
WebConsoleUtils
=
{
supportsString
:
function
WCU_supportsString
(
aString
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
str
.
data
=
aString
;
return
str
;
}
getWorkerType
:
function
(
message
)
{
let
id
=
message
?
message
.
innerID
:
null
;
return
CONSOLE_WORKER_IDS
[
CONSOLE_WORKER_IDS
.
indexOf
(
id
)
]
|
|
null
;
}
cloneObject
:
function
WCU_cloneObject
(
aObject
aRecursive
aFilter
)
{
if
(
typeof
aObject
!
=
"
object
"
)
{
return
aObject
;
}
let
temp
;
if
(
Array
.
isArray
(
aObject
)
)
{
temp
=
[
]
;
Array
.
forEach
(
aObject
function
(
aValue
aIndex
)
{
if
(
!
aFilter
|
|
aFilter
(
aIndex
aValue
aObject
)
)
{
temp
.
push
(
aRecursive
?
WCU_cloneObject
(
aValue
)
:
aValue
)
;
}
}
)
;
}
else
{
temp
=
{
}
;
for
(
let
key
in
aObject
)
{
let
value
=
aObject
[
key
]
;
if
(
aObject
.
hasOwnProperty
(
key
)
&
&
(
!
aFilter
|
|
aFilter
(
key
value
aObject
)
)
)
{
temp
[
key
]
=
aRecursive
?
WCU_cloneObject
(
value
)
:
value
;
}
}
}
return
temp
;
}
copyTextStyles
:
function
WCU_copyTextStyles
(
aFrom
aTo
)
{
let
win
=
aFrom
.
ownerDocument
.
defaultView
;
let
style
=
win
.
getComputedStyle
(
aFrom
)
;
aTo
.
style
.
fontFamily
=
style
.
getPropertyCSSValue
(
"
font
-
family
"
)
.
cssText
;
aTo
.
style
.
fontSize
=
style
.
getPropertyCSSValue
(
"
font
-
size
"
)
.
cssText
;
aTo
.
style
.
fontWeight
=
style
.
getPropertyCSSValue
(
"
font
-
weight
"
)
.
cssText
;
aTo
.
style
.
fontStyle
=
style
.
getPropertyCSSValue
(
"
font
-
style
"
)
.
cssText
;
}
getInnerWindowId
:
function
WCU_getInnerWindowId
(
aWindow
)
{
return
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
getInnerWindowIDsForFrames
:
function
WCU_getInnerWindowIDsForFrames
(
aWindow
)
{
let
innerWindowID
=
this
.
getInnerWindowId
(
aWindow
)
;
let
ids
=
[
innerWindowID
]
;
if
(
aWindow
.
frames
)
{
for
(
let
i
=
0
;
i
<
aWindow
.
frames
.
length
;
i
+
+
)
{
let
frame
=
aWindow
.
frames
[
i
]
;
ids
=
ids
.
concat
(
this
.
getInnerWindowIDsForFrames
(
frame
)
)
;
}
}
return
ids
;
}
getOuterWindowId
:
function
WCU_getOuterWindowId
(
aWindow
)
{
return
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
abbreviateSourceURL
:
function
WCU_abbreviateSourceURL
(
aSourceURL
aOptions
=
{
}
)
{
if
(
!
aOptions
.
onlyCropQuery
&
&
aSourceURL
.
substr
(
0
5
)
=
=
"
data
:
"
)
{
let
commaIndex
=
aSourceURL
.
indexOf
(
"
"
)
;
if
(
commaIndex
>
-
1
)
{
aSourceURL
=
"
data
:
"
+
aSourceURL
.
substring
(
commaIndex
+
1
)
;
}
}
let
hookIndex
=
aSourceURL
.
indexOf
(
"
?
"
)
;
if
(
hookIndex
>
-
1
)
{
aSourceURL
=
aSourceURL
.
substring
(
0
hookIndex
)
;
}
let
hashIndex
=
aSourceURL
.
indexOf
(
"
#
"
)
;
if
(
hashIndex
>
-
1
)
{
aSourceURL
=
aSourceURL
.
substring
(
0
hashIndex
)
;
}
if
(
aSourceURL
[
aSourceURL
.
length
-
1
]
=
=
"
/
"
)
{
aSourceURL
=
aSourceURL
.
replace
(
/
\
/
+
/
"
"
)
;
}
if
(
!
aOptions
.
onlyCropQuery
)
{
let
slashIndex
=
aSourceURL
.
lastIndexOf
(
"
/
"
)
;
if
(
slashIndex
>
-
1
)
{
aSourceURL
=
aSourceURL
.
substring
(
slashIndex
+
1
)
;
}
}
return
aSourceURL
;
}
isNativeFunction
:
function
WCU_isNativeFunction
(
aFunction
)
{
return
typeof
aFunction
=
=
"
function
"
&
&
!
(
"
prototype
"
in
aFunction
)
;
}
isNonNativeGetter
:
function
WCU_isNonNativeGetter
(
aObject
aProp
)
{
if
(
typeof
aObject
!
=
"
object
"
)
{
return
false
;
}
let
desc
=
this
.
getPropertyDescriptor
(
aObject
aProp
)
;
return
desc
&
&
desc
.
get
&
&
!
this
.
isNativeFunction
(
desc
.
get
)
;
}
getPropertyDescriptor
:
function
WCU_getPropertyDescriptor
(
aObject
aProp
)
{
let
desc
=
null
;
while
(
aObject
)
{
try
{
if
(
(
desc
=
Object
.
getOwnPropertyDescriptor
(
aObject
aProp
)
)
)
{
break
;
}
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NS_ERROR_XPC_BAD_CONVERT_JS
"
&
&
ex
.
name
!
=
"
NS_ERROR_XPC_BAD_OP_ON_WN_PROTO
"
&
&
ex
.
name
!
=
"
TypeError
"
)
{
throw
ex
;
}
}
try
{
aObject
=
Object
.
getPrototypeOf
(
aObject
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
=
=
"
TypeError
"
)
{
return
desc
;
}
throw
ex
;
}
}
return
desc
;
}
propertiesSort
:
function
WCU_propertiesSort
(
a
b
)
{
let
aNumber
=
parseFloat
(
a
.
name
)
;
let
bNumber
=
parseFloat
(
b
.
name
)
;
if
(
!
isNaN
(
aNumber
)
&
&
isNaN
(
bNumber
)
)
{
return
-
1
;
}
else
if
(
isNaN
(
aNumber
)
&
&
!
isNaN
(
bNumber
)
)
{
return
1
;
}
else
if
(
!
isNaN
(
aNumber
)
&
&
!
isNaN
(
bNumber
)
)
{
return
aNumber
-
bNumber
;
}
else
if
(
a
.
name
<
b
.
name
)
{
return
-
1
;
}
else
if
(
a
.
name
>
b
.
name
)
{
return
1
;
}
else
{
return
0
;
}
}
createValueGrip
:
function
WCU_createValueGrip
(
aValue
aObjectWrapper
)
{
switch
(
typeof
aValue
)
{
case
"
boolean
"
:
return
aValue
;
case
"
string
"
:
return
aObjectWrapper
(
aValue
)
;
case
"
number
"
:
if
(
aValue
=
=
=
Infinity
)
{
return
{
type
:
"
Infinity
"
}
;
}
else
if
(
aValue
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
Infinity
"
}
;
}
else
if
(
Number
.
isNaN
(
aValue
)
)
{
return
{
type
:
"
NaN
"
}
;
}
else
if
(
!
aValue
&
&
1
/
aValue
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
0
"
}
;
}
return
aValue
;
case
"
undefined
"
:
return
{
type
:
"
undefined
"
}
;
case
"
object
"
:
if
(
aValue
=
=
=
null
)
{
return
{
type
:
"
null
"
}
;
}
case
"
function
"
:
return
aObjectWrapper
(
aValue
)
;
default
:
Cu
.
reportError
(
"
Failed
to
provide
a
grip
for
value
of
"
+
typeof
aValue
+
"
:
"
+
aValue
)
;
return
null
;
}
}
isIteratorOrGenerator
:
function
WCU_isIteratorOrGenerator
(
aObject
)
{
if
(
aObject
=
=
=
null
)
{
return
false
;
}
if
(
typeof
aObject
=
=
"
object
"
)
{
if
(
typeof
aObject
.
__iterator__
=
=
"
function
"
|
|
aObject
.
constructor
&
&
aObject
.
constructor
.
name
=
=
"
Iterator
"
)
{
return
true
;
}
try
{
let
str
=
aObject
.
toString
(
)
;
if
(
typeof
aObject
.
next
=
=
"
function
"
&
&
str
.
indexOf
(
"
[
object
Generator
"
)
=
=
0
)
{
return
true
;
}
}
catch
(
ex
)
{
return
false
;
}
}
return
false
;
}
isMixedHTTPSRequest
:
function
WCU_isMixedHTTPSRequest
(
aRequest
aLocation
)
{
try
{
let
requestURI
=
Services
.
io
.
newURI
(
aRequest
null
null
)
;
let
contentURI
=
Services
.
io
.
newURI
(
aLocation
null
null
)
;
return
(
contentURI
.
scheme
=
=
"
https
"
&
&
requestURI
.
scheme
!
=
"
https
"
)
;
}
catch
(
ex
)
{
return
false
;
}
}
getFunctionName
:
function
WCF_getFunctionName
(
aFunction
)
{
let
name
=
null
;
if
(
aFunction
.
name
)
{
name
=
aFunction
.
name
;
}
else
{
let
desc
;
try
{
desc
=
aFunction
.
getOwnPropertyDescriptor
(
"
displayName
"
)
;
}
catch
(
ex
)
{
}
if
(
desc
&
&
typeof
desc
.
value
=
=
"
string
"
)
{
name
=
desc
.
value
;
}
}
if
(
!
name
)
{
try
{
let
str
=
(
aFunction
.
toString
(
)
|
|
aFunction
.
toSource
(
)
)
+
"
"
;
name
=
(
str
.
match
(
REGEX_MATCH_FUNCTION_NAME
)
|
|
[
]
)
[
1
]
;
}
catch
(
ex
)
{
}
}
return
name
;
}
getObjectClassName
:
function
WCU_getObjectClassName
(
aObject
)
{
if
(
aObject
=
=
=
null
)
{
return
"
null
"
;
}
if
(
aObject
=
=
=
undefined
)
{
return
"
undefined
"
;
}
let
type
=
typeof
aObject
;
if
(
type
!
=
"
object
"
)
{
return
type
.
charAt
(
0
)
.
toUpperCase
(
)
+
type
.
substr
(
1
)
;
}
let
className
;
try
{
className
=
(
(
aObject
+
"
"
)
.
match
(
/
^
\
[
object
(
\
S
+
)
\
]
/
)
|
|
[
]
)
[
1
]
;
if
(
!
className
)
{
className
=
(
(
aObject
.
constructor
+
"
"
)
.
match
(
/
^
\
[
object
(
\
S
+
)
\
]
/
)
|
|
[
]
)
[
1
]
;
}
if
(
!
className
&
&
typeof
aObject
.
constructor
=
=
"
function
"
)
{
className
=
this
.
getFunctionName
(
aObject
.
constructor
)
;
}
}
catch
(
ex
)
{
}
return
className
;
}
isActorGrip
:
function
WCU_isActorGrip
(
aGrip
)
{
return
aGrip
&
&
typeof
(
aGrip
)
=
=
"
object
"
&
&
aGrip
.
actor
;
}
_usageCount
:
0
get
usageCount
(
)
{
if
(
WebConsoleUtils
.
_usageCount
<
CONSOLE_ENTRY_THRESHOLD
)
{
WebConsoleUtils
.
_usageCount
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
selfxss
.
count
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
WebConsoleUtils
.
usageCount
=
CONSOLE_ENTRY_THRESHOLD
;
}
}
return
WebConsoleUtils
.
_usageCount
;
}
set
usageCount
(
newUC
)
{
if
(
newUC
<
=
CONSOLE_ENTRY_THRESHOLD
)
{
WebConsoleUtils
.
_usageCount
=
newUC
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
selfxss
.
count
"
newUC
)
;
}
}
pasteHandlerGen
:
function
WCU_pasteHandlerGen
(
inputField
notificationBox
msg
okstring
)
{
let
handler
=
function
WCU_pasteHandler
(
aEvent
)
{
if
(
WebConsoleUtils
.
usageCount
>
=
CONSOLE_ENTRY_THRESHOLD
)
{
inputField
.
removeEventListener
(
"
paste
"
handler
)
;
inputField
.
removeEventListener
(
"
drop
"
handler
)
;
return
true
;
}
if
(
notificationBox
.
getNotificationWithValue
(
"
selfxss
-
notification
"
)
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
return
false
;
}
let
notification
=
notificationBox
.
appendNotification
(
msg
"
selfxss
-
notification
"
null
notificationBox
.
PRIORITY_WARNING_HIGH
null
function
(
eventType
)
{
if
(
eventType
=
=
"
removed
"
)
{
inputField
.
removeEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
}
}
)
;
function
pasteKeyUpHandler
(
aEvent2
)
{
let
value
=
inputField
.
value
|
|
inputField
.
textContent
;
if
(
value
.
includes
(
okstring
)
)
{
notificationBox
.
removeNotification
(
notification
)
;
inputField
.
removeEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
WebConsoleUtils
.
usageCount
=
CONSOLE_ENTRY_THRESHOLD
;
}
}
inputField
.
addEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
return
false
;
}
;
return
handler
;
}
}
;
exports
.
Utils
=
WebConsoleUtils
;
WebConsoleUtils
.
L10n
=
function
(
bundleURI
)
{
this
.
_bundleUri
=
bundleURI
;
}
;
WebConsoleUtils
.
L10n
.
prototype
=
{
_stringBundle
:
null
get
stringBundle
(
)
{
if
(
!
this
.
_stringBundle
)
{
this
.
_stringBundle
=
Services
.
strings
.
createBundle
(
this
.
_bundleUri
)
;
}
return
this
.
_stringBundle
;
}
timestampString
:
function
WCU_l10n_timestampString
(
aMilliseconds
)
{
let
d
=
new
Date
(
aMilliseconds
?
aMilliseconds
:
null
)
;
let
hours
=
d
.
getHours
(
)
minutes
=
d
.
getMinutes
(
)
;
let
seconds
=
d
.
getSeconds
(
)
milliseconds
=
d
.
getMilliseconds
(
)
;
let
parameters
=
[
hours
minutes
seconds
milliseconds
]
;
return
this
.
getFormatStr
(
"
timestampFormat
"
parameters
)
;
}
getStr
:
function
WCU_l10n_getStr
(
aName
)
{
let
result
;
try
{
result
=
this
.
stringBundle
.
GetStringFromName
(
aName
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
get
string
:
"
+
aName
)
;
throw
ex
;
}
return
result
;
}
getFormatStr
:
function
WCU_l10n_getFormatStr
(
aName
aArray
)
{
let
result
;
try
{
result
=
this
.
stringBundle
.
formatStringFromName
(
aName
aArray
aArray
.
length
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
format
string
:
"
+
aName
)
;
throw
ex
;
}
return
result
;
}
}
;
function
ConsoleServiceListener
(
aWindow
aListener
)
{
this
.
window
=
aWindow
;
this
.
listener
=
aListener
;
}
exports
.
ConsoleServiceListener
=
ConsoleServiceListener
;
ConsoleServiceListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIConsoleListener
]
)
window
:
null
listener
:
null
init
:
function
CSL_init
(
)
{
Services
.
console
.
registerListener
(
this
)
;
}
observe
:
function
CSL_observe
(
aMessage
)
{
if
(
!
this
.
listener
)
{
return
;
}
if
(
this
.
window
)
{
if
(
!
(
aMessage
instanceof
Ci
.
nsIScriptError
)
|
|
!
aMessage
.
outerWindowID
|
|
!
this
.
isCategoryAllowed
(
aMessage
.
category
)
)
{
return
;
}
let
errorWindow
=
Services
.
wm
.
getOuterWindowWithId
(
aMessage
.
outerWindowID
)
;
if
(
!
errorWindow
|
|
!
isWindowIncluded
(
this
.
window
errorWindow
)
)
{
return
;
}
}
this
.
listener
.
onConsoleServiceMessage
(
aMessage
)
;
}
isCategoryAllowed
:
function
CSL_isCategoryAllowed
(
aCategory
)
{
if
(
!
aCategory
)
{
return
false
;
}
switch
(
aCategory
)
{
case
"
XPConnect
JavaScript
"
:
case
"
component
javascript
"
:
case
"
chrome
javascript
"
:
case
"
chrome
registration
"
:
case
"
XBL
"
:
case
"
XBL
Prototype
Handler
"
:
case
"
XBL
Content
Sink
"
:
case
"
xbl
javascript
"
:
return
false
;
}
return
true
;
}
getCachedMessages
:
function
CSL_getCachedMessages
(
aIncludePrivate
=
false
)
{
let
errors
=
Services
.
console
.
getMessageArray
(
)
|
|
[
]
;
if
(
!
this
.
window
)
{
return
errors
.
filter
(
(
aError
)
=
>
{
if
(
aError
instanceof
Ci
.
nsIScriptError
)
{
if
(
!
aIncludePrivate
&
&
aError
.
isFromPrivateWindow
)
{
return
false
;
}
}
return
true
;
}
)
;
}
let
ids
=
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
this
.
window
)
;
return
errors
.
filter
(
(
aError
)
=
>
{
if
(
aError
instanceof
Ci
.
nsIScriptError
)
{
if
(
!
aIncludePrivate
&
&
aError
.
isFromPrivateWindow
)
{
return
false
;
}
if
(
ids
&
&
(
ids
.
indexOf
(
aError
.
innerWindowID
)
=
=
-
1
|
|
!
this
.
isCategoryAllowed
(
aError
.
category
)
)
)
{
return
false
;
}
}
else
if
(
ids
&
&
ids
[
0
]
)
{
return
false
;
}
return
true
;
}
)
;
}
destroy
:
function
CSL_destroy
(
)
{
Services
.
console
.
unregisterListener
(
this
)
;
this
.
listener
=
this
.
window
=
null
;
}
}
;
function
ConsoleAPIListener
(
aWindow
aOwner
aConsoleID
)
{
this
.
window
=
aWindow
;
this
.
owner
=
aOwner
;
this
.
consoleID
=
aConsoleID
;
}
exports
.
ConsoleAPIListener
=
ConsoleAPIListener
;
ConsoleAPIListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
window
:
null
owner
:
null
consoleID
:
null
init
:
function
CAL_init
(
)
{
Services
.
obs
.
addObserver
(
this
"
console
-
api
-
log
-
event
"
false
)
;
}
observe
:
function
CAL_observe
(
aMessage
aTopic
)
{
if
(
!
this
.
owner
)
{
return
;
}
let
apiMessage
=
aMessage
.
wrappedJSObject
;
if
(
!
this
.
isMessageRelevant
(
apiMessage
)
)
{
return
;
}
this
.
owner
.
onConsoleAPICall
(
apiMessage
)
;
}
isMessageRelevant
:
function
(
message
)
{
let
workerType
=
WebConsoleUtils
.
getWorkerType
(
message
)
;
if
(
this
.
window
&
&
workerType
=
=
=
"
ServiceWorker
"
)
{
let
scope
=
message
.
ID
;
if
(
!
swm
.
shouldReportToWindow
(
this
.
window
scope
)
)
{
return
false
;
}
}
if
(
this
.
window
&
&
!
workerType
)
{
let
msgWindow
=
Services
.
wm
.
getCurrentInnerWindowWithId
(
message
.
innerID
)
;
if
(
!
msgWindow
|
|
!
isWindowIncluded
(
this
.
window
msgWindow
)
)
{
return
false
;
}
}
if
(
this
.
consoleID
&
&
message
.
consoleID
!
=
=
this
.
consoleID
)
{
return
false
;
}
return
true
;
}
getCachedMessages
:
function
CAL_getCachedMessages
(
aIncludePrivate
=
false
)
{
let
messages
=
[
]
;
let
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
if
(
!
this
.
window
)
{
messages
=
ConsoleAPIStorage
.
getEvents
(
)
;
}
else
{
let
ids
=
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
this
.
window
)
;
ids
.
forEach
(
(
id
)
=
>
{
messages
=
messages
.
concat
(
ConsoleAPIStorage
.
getEvents
(
id
)
)
;
}
)
;
}
CONSOLE_WORKER_IDS
.
forEach
(
(
id
)
=
>
{
messages
=
messages
.
concat
(
ConsoleAPIStorage
.
getEvents
(
id
)
)
;
}
)
;
messages
=
messages
.
filter
(
msg
=
>
{
return
this
.
isMessageRelevant
(
msg
)
;
}
)
;
if
(
aIncludePrivate
)
{
return
messages
;
}
return
messages
.
filter
(
(
m
)
=
>
!
m
.
private
)
;
}
destroy
:
function
CAL_destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
console
-
api
-
log
-
event
"
)
;
this
.
window
=
this
.
owner
=
null
;
}
}
;
var
WebConsoleCommands
=
{
_registeredCommands
:
new
Map
(
)
_originalCommands
:
new
Map
(
)
_registerOriginal
:
function
(
name
command
)
{
this
.
register
(
name
command
)
;
this
.
_originalCommands
.
set
(
name
this
.
getCommand
(
name
)
)
;
}
register
:
function
(
name
command
)
{
this
.
_registeredCommands
.
set
(
name
command
)
;
}
unregister
:
function
(
name
)
{
this
.
_registeredCommands
.
delete
(
name
)
;
if
(
this
.
_originalCommands
.
has
(
name
)
)
{
this
.
register
(
name
this
.
_originalCommands
.
get
(
name
)
)
;
}
}
getCommand
:
function
(
name
)
{
return
this
.
_registeredCommands
.
get
(
name
)
;
}
hasCommand
:
function
(
name
)
{
return
this
.
_registeredCommands
.
has
(
name
)
;
}
}
;
exports
.
WebConsoleCommands
=
WebConsoleCommands
;
WebConsoleCommands
.
_registerOriginal
(
"
"
function
JSTH_
(
aOwner
aSelector
)
{
return
aOwner
.
window
.
document
.
querySelector
(
aSelector
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
"
function
JSTH_
(
aOwner
aSelector
)
{
let
nodes
=
aOwner
.
window
.
document
.
querySelectorAll
(
aSelector
)
;
let
result
=
new
aOwner
.
window
.
Array
(
)
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
result
.
push
(
nodes
[
i
]
)
;
}
return
result
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
_
"
{
get
:
function
(
aOwner
)
{
return
aOwner
.
consoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
x
"
function
JSTH_
x
(
aOwner
aXPath
aContext
)
{
let
nodes
=
new
aOwner
.
window
.
Array
(
)
;
let
doc
=
aOwner
.
window
.
document
;
aContext
=
aContext
|
|
doc
;
let
results
=
doc
.
evaluate
(
aXPath
aContext
null
Ci
.
nsIDOMXPathResult
.
ANY_TYPE
null
)
;
let
node
;
while
(
(
node
=
results
.
iterateNext
(
)
)
)
{
nodes
.
push
(
node
)
;
}
return
nodes
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
0
"
{
get
:
function
(
aOwner
)
{
return
aOwner
.
makeDebuggeeValue
(
aOwner
.
selectedNode
)
;
}
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
clear
"
function
JSTH_clear
(
aOwner
)
{
aOwner
.
helperResult
=
{
type
:
"
clearOutput
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
clearHistory
"
function
JSTH_clearHistory
(
aOwner
)
{
aOwner
.
helperResult
=
{
type
:
"
clearHistory
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
keys
"
function
JSTH_keys
(
aOwner
aObject
)
{
return
Cu
.
cloneInto
(
Object
.
keys
(
Cu
.
waiveXrays
(
aObject
)
)
aOwner
.
window
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
values
"
function
JSTH_values
(
aOwner
aObject
)
{
let
values
=
[
]
;
let
waived
=
Cu
.
waiveXrays
(
aObject
)
;
let
names
=
Object
.
getOwnPropertyNames
(
waived
)
;
for
(
let
name
of
names
)
{
values
.
push
(
waived
[
name
]
)
;
}
return
Cu
.
cloneInto
(
values
aOwner
.
window
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
help
"
function
JSTH_help
(
aOwner
)
{
aOwner
.
helperResult
=
{
type
:
"
help
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
cd
"
function
JSTH_cd
(
aOwner
aWindow
)
{
if
(
!
aWindow
)
{
aOwner
.
consoleActor
.
evalWindow
=
null
;
aOwner
.
helperResult
=
{
type
:
"
cd
"
}
;
return
;
}
if
(
typeof
aWindow
=
=
"
string
"
)
{
aWindow
=
aOwner
.
window
.
document
.
querySelector
(
aWindow
)
;
}
if
(
aWindow
instanceof
Ci
.
nsIDOMElement
&
&
aWindow
.
contentWindow
)
{
aWindow
=
aWindow
.
contentWindow
;
}
if
(
!
(
aWindow
instanceof
Ci
.
nsIDOMWindow
)
)
{
aOwner
.
helperResult
=
{
type
:
"
error
"
message
:
"
cdFunctionInvalidArgument
"
}
;
return
;
}
aOwner
.
consoleActor
.
evalWindow
=
aWindow
;
aOwner
.
helperResult
=
{
type
:
"
cd
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
inspect
"
function
JSTH_inspect
(
aOwner
aObject
)
{
let
dbgObj
=
aOwner
.
makeDebuggeeValue
(
aObject
)
;
let
grip
=
aOwner
.
createValueGrip
(
dbgObj
)
;
aOwner
.
helperResult
=
{
type
:
"
inspectObject
"
input
:
aOwner
.
evalInput
object
:
grip
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
pprint
"
function
JSTH_pprint
(
aOwner
aObject
)
{
if
(
aObject
=
=
=
null
|
|
aObject
=
=
=
undefined
|
|
aObject
=
=
=
true
|
|
aObject
=
=
=
false
)
{
aOwner
.
helperResult
=
{
type
:
"
error
"
message
:
"
helperFuncUnsupportedTypeError
"
}
;
return
null
;
}
aOwner
.
helperResult
=
{
rawOutput
:
true
}
;
if
(
typeof
aObject
=
=
"
function
"
)
{
return
aObject
+
"
\
n
"
;
}
let
output
=
[
]
;
let
obj
=
aObject
;
for
(
let
name
in
obj
)
{
let
desc
=
WebConsoleUtils
.
getPropertyDescriptor
(
obj
name
)
|
|
{
}
;
if
(
desc
.
get
|
|
desc
.
set
)
{
let
getGrip
=
VariablesView
.
getGrip
(
desc
.
get
)
;
let
setGrip
=
VariablesView
.
getGrip
(
desc
.
set
)
;
let
getString
=
VariablesView
.
getString
(
getGrip
)
;
let
setString
=
VariablesView
.
getString
(
setGrip
)
;
output
.
push
(
name
+
"
:
"
"
get
:
"
+
getString
"
set
:
"
+
setString
)
;
}
else
{
let
valueGrip
=
VariablesView
.
getGrip
(
obj
[
name
]
)
;
let
valueString
=
VariablesView
.
getString
(
valueGrip
)
;
output
.
push
(
name
+
"
:
"
+
valueString
)
;
}
}
return
"
"
+
output
.
join
(
"
\
n
"
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
print
"
function
JSTH_print
(
aOwner
aValue
)
{
aOwner
.
helperResult
=
{
rawOutput
:
true
}
;
if
(
typeof
aValue
=
=
=
"
symbol
"
)
{
return
Symbol
.
prototype
.
toString
.
call
(
aValue
)
;
}
return
String
(
Cu
.
waiveXrays
(
aValue
)
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
copy
"
function
JSTH_copy
(
aOwner
aValue
)
{
let
payload
;
try
{
if
(
aValue
instanceof
Ci
.
nsIDOMElement
)
{
payload
=
aValue
.
outerHTML
;
}
else
if
(
typeof
aValue
=
=
"
string
"
)
{
payload
=
aValue
;
}
else
{
payload
=
JSON
.
stringify
(
aValue
null
"
"
)
;
}
}
catch
(
ex
)
{
payload
=
"
/
*
"
+
ex
+
"
*
/
"
;
}
aOwner
.
helperResult
=
{
type
:
"
copyValueToClipboard
"
value
:
payload
}
;
}
)
;
function
addWebConsoleCommands
(
owner
)
{
if
(
!
owner
)
{
throw
new
Error
(
"
The
owner
is
required
"
)
;
}
for
(
let
[
name
command
]
of
WebConsoleCommands
.
_registeredCommands
)
{
if
(
typeof
command
=
=
=
"
function
"
)
{
owner
.
sandbox
[
name
]
=
command
.
bind
(
undefined
owner
)
;
}
else
if
(
typeof
command
=
=
=
"
object
"
)
{
let
clone
=
Object
.
assign
(
{
}
command
{
enumerable
:
true
configurable
:
true
}
)
;
if
(
typeof
command
.
get
=
=
=
"
function
"
)
{
clone
.
get
=
command
.
get
.
bind
(
undefined
owner
)
;
}
if
(
typeof
command
.
set
=
=
=
"
function
"
)
{
clone
.
set
=
command
.
set
.
bind
(
undefined
owner
)
;
}
Object
.
defineProperty
(
owner
.
sandbox
name
clone
)
;
}
}
}
exports
.
addWebConsoleCommands
=
addWebConsoleCommands
;
function
ConsoleReflowListener
(
aWindow
aListener
)
{
this
.
docshell
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
listener
=
aListener
;
this
.
docshell
.
addWeakReflowObserver
(
this
)
;
}
exports
.
ConsoleReflowListener
=
ConsoleReflowListener
;
ConsoleReflowListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIReflowObserver
Ci
.
nsISupportsWeakReference
]
)
docshell
:
null
listener
:
null
sendReflow
:
function
CRL_sendReflow
(
aStart
aEnd
aInterruptible
)
{
let
frame
=
components
.
stack
.
caller
.
caller
;
let
filename
=
frame
?
frame
.
filename
:
null
;
if
(
filename
)
{
filename
=
filename
.
split
(
"
"
)
.
pop
(
)
;
}
this
.
listener
.
onReflowActivity
(
{
interruptible
:
aInterruptible
start
:
aStart
end
:
aEnd
sourceURL
:
filename
sourceLine
:
frame
?
frame
.
lineNumber
:
null
functionName
:
frame
?
frame
.
name
:
null
}
)
;
}
reflow
:
function
CRL_reflow
(
aStart
aEnd
)
{
this
.
sendReflow
(
aStart
aEnd
false
)
;
}
reflowInterruptible
:
function
CRL_reflowInterruptible
(
aStart
aEnd
)
{
this
.
sendReflow
(
aStart
aEnd
true
)
;
}
destroy
:
function
CRL_destroy
(
)
{
this
.
docshell
.
removeWeakReflowObserver
(
this
)
;
this
.
listener
=
this
.
docshell
=
null
;
}
}
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
0
;
