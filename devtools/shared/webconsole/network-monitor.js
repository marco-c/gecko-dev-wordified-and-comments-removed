"
use
strict
"
;
const
{
Cc
Ci
Cm
Cr
components
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkHelper
"
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyImporter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
loader
.
lazyServiceGetter
(
this
"
gActivityDistributor
"
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
"
nsIHttpActivityDistributor
"
)
;
const
{
NetworkThrottleManager
}
=
require
(
"
devtools
/
shared
/
webconsole
/
throttle
"
)
;
const
{
CacheEntry
}
=
require
(
"
devtools
/
shared
/
platform
/
cache
-
entry
"
)
;
const
PR_UINT32_MAX
=
4294967295
;
const
HTTP_MOVED_PERMANENTLY
=
301
;
const
HTTP_FOUND
=
302
;
const
HTTP_SEE_OTHER
=
303
;
const
HTTP_TEMPORARY_REDIRECT
=
307
;
function
matchRequest
(
channel
filters
)
{
if
(
!
filters
.
outerWindowID
&
&
!
filters
.
window
)
{
return
true
;
}
if
(
!
flags
.
testing
&
&
channel
.
loadInfo
&
&
channel
.
loadInfo
.
loadingDocument
=
=
=
null
&
&
channel
.
loadInfo
.
loadingPrincipal
=
=
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
{
return
false
;
}
if
(
filters
.
window
)
{
let
win
=
NetworkHelper
.
getWindowForRequest
(
channel
)
;
while
(
win
)
{
if
(
win
=
=
filters
.
window
)
{
return
true
;
}
if
(
win
.
parent
=
=
win
)
{
break
;
}
win
=
win
.
parent
;
}
}
if
(
filters
.
outerWindowID
)
{
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
if
(
topFrame
)
{
try
{
if
(
topFrame
.
outerWindowID
=
=
filters
.
outerWindowID
)
{
return
true
;
}
}
catch
(
e
)
{
}
}
}
return
false
;
}
const
SINK_CLASS_DESCRIPTION
=
"
NetworkMonitor
Channel
Event
Sink
"
;
const
SINK_CLASS_ID
=
components
.
ID
(
"
{
e89fa076
-
c845
-
48a8
-
8c45
-
2604729eba1d
}
"
)
;
const
SINK_CONTRACT_ID
=
"
mozilla
.
org
/
network
/
monitor
/
channeleventsink
;
1
"
;
const
SINK_CATEGORY_NAME
=
"
net
-
channel
-
event
-
sinks
"
;
function
ChannelEventSink
(
)
{
this
.
wrappedJSObject
=
this
;
this
.
collectors
=
new
Set
(
)
;
}
ChannelEventSink
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIChannelEventSink
]
)
registerCollector
(
collector
)
{
this
.
collectors
.
add
(
collector
)
;
}
unregisterCollector
(
collector
)
{
this
.
collectors
.
delete
(
collector
)
;
if
(
this
.
collectors
.
size
=
=
0
)
{
ChannelEventSinkFactory
.
unregister
(
)
;
}
}
asyncOnChannelRedirect
(
oldChannel
newChannel
flags
callback
)
{
for
(
const
collector
of
this
.
collectors
)
{
try
{
collector
.
onChannelRedirect
(
oldChannel
newChannel
flags
)
;
}
catch
(
ex
)
{
console
.
error
(
"
StackTraceCollector
.
onChannelRedirect
threw
an
exception
"
ex
)
;
}
}
callback
.
onRedirectVerifyCallback
(
Cr
.
NS_OK
)
;
}
}
;
const
ChannelEventSinkFactory
=
XPCOMUtils
.
generateSingletonFactory
(
ChannelEventSink
)
;
ChannelEventSinkFactory
.
register
=
function
(
)
{
const
registrar
=
Cm
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
if
(
registrar
.
isCIDRegistered
(
SINK_CLASS_ID
)
)
{
return
;
}
registrar
.
registerFactory
(
SINK_CLASS_ID
SINK_CLASS_DESCRIPTION
SINK_CONTRACT_ID
ChannelEventSinkFactory
)
;
XPCOMUtils
.
categoryManager
.
addCategoryEntry
(
SINK_CATEGORY_NAME
SINK_CONTRACT_ID
SINK_CONTRACT_ID
false
true
)
;
}
;
ChannelEventSinkFactory
.
unregister
=
function
(
)
{
const
registrar
=
Cm
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
unregisterFactory
(
SINK_CLASS_ID
ChannelEventSinkFactory
)
;
XPCOMUtils
.
categoryManager
.
deleteCategoryEntry
(
SINK_CATEGORY_NAME
SINK_CONTRACT_ID
false
)
;
}
;
ChannelEventSinkFactory
.
getService
=
function
(
)
{
ChannelEventSinkFactory
.
register
(
)
;
return
Cc
[
SINK_CONTRACT_ID
]
.
getService
(
Ci
.
nsIChannelEventSink
)
.
wrappedJSObject
;
}
;
function
StackTraceCollector
(
filters
netmonitors
)
{
this
.
filters
=
filters
;
this
.
stacktracesById
=
new
Map
(
)
;
this
.
netmonitors
=
netmonitors
;
}
StackTraceCollector
.
prototype
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
registerCollector
(
this
)
;
this
.
onGetStack
=
this
.
onGetStack
.
bind
(
this
)
;
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
addMessageListener
(
"
debug
:
request
-
stack
"
this
.
onGetStack
)
;
}
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
unregisterCollector
(
this
)
;
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
removeMessageListener
(
"
debug
:
request
-
stack
"
this
.
onGetStack
)
;
}
}
_saveStackTrace
(
channel
stacktrace
)
{
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
stack
-
available
"
{
channelId
:
channel
.
channelId
stacktrace
:
stacktrace
&
&
stacktrace
.
length
>
0
}
)
;
}
this
.
stacktracesById
.
set
(
channel
.
channelId
stacktrace
)
;
}
observe
(
subject
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
matchRequest
(
channel
this
.
filters
)
)
{
return
;
}
let
frame
=
components
.
stack
;
const
stacktrace
=
[
]
;
if
(
frame
&
&
frame
.
caller
)
{
frame
=
frame
.
caller
;
while
(
frame
)
{
stacktrace
.
push
(
{
filename
:
frame
.
filename
lineNumber
:
frame
.
lineNumber
columnNumber
:
frame
.
columnNumber
functionName
:
frame
.
name
asyncCause
:
frame
.
asyncCause
}
)
;
frame
=
frame
.
caller
|
|
frame
.
asyncCaller
;
}
}
this
.
_saveStackTrace
(
channel
stacktrace
)
;
}
onChannelRedirect
(
oldChannel
newChannel
flags
)
{
try
{
oldChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
newChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
}
catch
(
ex
)
{
return
;
}
const
oldId
=
oldChannel
.
channelId
;
const
stacktrace
=
this
.
stacktracesById
.
get
(
oldId
)
;
if
(
stacktrace
)
{
this
.
_saveStackTrace
(
newChannel
stacktrace
)
;
}
}
getStackTrace
(
channelId
)
{
const
trace
=
this
.
stacktracesById
.
get
(
channelId
)
;
this
.
stacktracesById
.
delete
(
channelId
)
;
return
trace
;
}
onGetStack
(
msg
)
{
const
messageManager
=
msg
.
target
;
const
channelId
=
msg
.
data
;
const
stack
=
this
.
getStackTrace
(
channelId
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
stack
"
{
channelId
stack
}
)
;
}
}
;
exports
.
StackTraceCollector
=
StackTraceCollector
;
function
NetworkResponseListener
(
owner
httpActivity
)
{
this
.
owner
=
owner
;
this
.
receivedData
=
"
"
;
this
.
httpActivity
=
httpActivity
;
this
.
bodySize
=
0
;
this
.
truncated
=
false
;
const
channel
=
this
.
httpActivity
.
channel
;
this
.
_wrappedNotificationCallbacks
=
channel
.
notificationCallbacks
;
channel
.
notificationCallbacks
=
this
;
}
NetworkResponseListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIStreamListener
Ci
.
nsIInputStreamCallback
Ci
.
nsIRequestObserver
Ci
.
nsIInterfaceRequestor
]
)
getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIProgressEventSink
)
)
{
return
this
;
}
if
(
this
.
_wrappedNotificationCallbacks
)
{
return
this
.
_wrappedNotificationCallbacks
.
getInterface
(
iid
)
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
_forwardNotification
(
iid
method
args
)
{
if
(
!
this
.
_wrappedNotificationCallbacks
)
{
return
;
}
try
{
const
impl
=
this
.
_wrappedNotificationCallbacks
.
getInterface
(
iid
)
;
impl
[
method
]
.
apply
(
impl
args
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_NO_INTERFACE
)
{
throw
e
;
}
}
}
_foundOpenResponse
:
false
_wrappedNotificationCallbacks
:
null
owner
:
null
sink
:
null
httpActivity
:
null
receivedData
:
null
bodySize
:
null
transferredSize
:
null
request
:
null
setAsyncListener
:
function
(
stream
listener
)
{
stream
.
asyncWait
(
listener
0
0
Services
.
tm
.
mainThread
)
;
}
onDataAvailable
:
function
(
request
context
inputStream
offset
count
)
{
this
.
_findOpenResponse
(
)
;
const
data
=
NetUtil
.
readInputStreamToString
(
inputStream
count
)
;
this
.
bodySize
+
=
count
;
if
(
!
this
.
httpActivity
.
discardResponseBody
)
{
const
limit
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
netmonitor
.
responseBodyLimit
"
)
;
if
(
this
.
receivedData
.
length
<
=
limit
|
|
limit
=
=
0
)
{
this
.
receivedData
+
=
NetworkHelper
.
convertToUnicode
(
data
request
.
contentCharset
)
;
}
if
(
this
.
receivedData
.
length
>
limit
&
&
limit
>
0
)
{
this
.
receivedData
=
this
.
receivedData
.
substr
(
0
limit
)
;
this
.
truncated
=
true
;
}
}
}
onStartRequest
:
function
(
request
)
{
if
(
this
.
request
)
{
return
;
}
this
.
request
=
request
;
this
.
_getSecurityInfo
(
)
;
this
.
_findOpenResponse
(
)
;
this
.
offset
=
0
;
const
channel
=
this
.
request
;
let
isOptimizedContent
=
false
;
try
{
if
(
channel
instanceof
Ci
.
nsICacheInfoChannel
)
{
isOptimizedContent
=
channel
.
alternativeDataType
;
}
}
catch
(
e
)
{
}
if
(
isOptimizedContent
)
{
let
charset
;
try
{
charset
=
this
.
request
.
contentCharset
;
}
catch
(
e
)
{
}
if
(
!
charset
)
{
charset
=
this
.
httpActivity
.
charset
;
}
NetworkHelper
.
loadFromCache
(
this
.
httpActivity
.
url
charset
this
.
_onComplete
.
bind
(
this
)
)
;
return
;
}
if
(
!
this
.
httpActivity
.
fromServiceWorker
&
&
channel
instanceof
Ci
.
nsIEncodedChannel
&
&
channel
.
contentEncodings
&
&
!
channel
.
applyConversion
)
{
const
encodingHeader
=
channel
.
getResponseHeader
(
"
Content
-
Encoding
"
)
;
const
scs
=
Cc
[
"
mozilla
.
org
/
streamConverters
;
1
"
]
.
getService
(
Ci
.
nsIStreamConverterService
)
;
const
encodings
=
encodingHeader
.
split
(
/
\
s
*
\
t
*
\
s
*
\
t
*
/
)
;
let
nextListener
=
this
;
const
acceptedEncodings
=
[
"
gzip
"
"
deflate
"
"
br
"
"
x
-
gzip
"
"
x
-
deflate
"
]
;
for
(
const
i
in
encodings
)
{
const
enc
=
encodings
[
i
]
.
toLowerCase
(
)
;
if
(
acceptedEncodings
.
indexOf
(
enc
)
>
-
1
)
{
this
.
converter
=
scs
.
asyncConvertData
(
enc
"
uncompressed
"
nextListener
null
)
;
nextListener
=
this
.
converter
;
}
}
if
(
this
.
converter
)
{
this
.
converter
.
onStartRequest
(
this
.
request
null
)
;
}
}
this
.
setAsyncListener
(
this
.
sink
.
inputStream
this
)
;
}
_getSecurityInfo
:
DevToolsUtils
.
makeInfallible
(
function
(
)
{
if
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
return
;
}
const
secinfo
=
this
.
httpActivity
.
channel
.
securityInfo
;
const
info
=
NetworkHelper
.
parseSecurityInfo
(
secinfo
this
.
httpActivity
)
;
this
.
httpActivity
.
owner
.
addSecurityInfo
(
info
)
;
}
)
_fetchCacheInformation
:
function
(
)
{
const
httpActivity
=
this
.
httpActivity
;
CacheEntry
.
getCacheEntry
(
this
.
request
(
descriptor
)
=
>
{
httpActivity
.
owner
.
addResponseCache
(
{
responseCache
:
descriptor
}
)
;
}
)
;
}
onStopRequest
:
function
(
)
{
if
(
!
this
.
httpActivity
)
{
return
;
}
this
.
_findOpenResponse
(
)
;
this
.
sink
.
outputStream
.
close
(
)
;
}
onProgress
:
function
(
request
context
progress
progressMax
)
{
this
.
transferredSize
=
progress
;
this
.
_forwardNotification
(
Ci
.
nsIProgressEventSink
"
onProgress
"
arguments
)
;
}
onStatus
:
function
(
)
{
this
.
_forwardNotification
(
Ci
.
nsIProgressEventSink
"
onStatus
"
arguments
)
;
}
_findOpenResponse
:
function
(
)
{
if
(
!
this
.
owner
|
|
this
.
_foundOpenResponse
)
{
return
;
}
const
channel
=
this
.
httpActivity
.
channel
;
const
openResponse
=
this
.
owner
.
openResponses
.
get
(
channel
)
;
if
(
!
openResponse
)
{
return
;
}
this
.
_foundOpenResponse
=
true
;
this
.
owner
.
openResponses
.
delete
(
channel
)
;
this
.
httpActivity
.
owner
.
addResponseHeaders
(
openResponse
.
headers
)
;
this
.
httpActivity
.
owner
.
addResponseCookies
(
openResponse
.
cookies
)
;
}
onStreamClose
:
function
(
)
{
if
(
!
this
.
httpActivity
)
{
return
;
}
this
.
setAsyncListener
(
this
.
sink
.
inputStream
null
)
;
this
.
_findOpenResponse
(
)
;
if
(
this
.
request
.
fromCache
|
|
this
.
httpActivity
.
responseStatus
=
=
304
)
{
this
.
_fetchCacheInformation
(
)
;
}
if
(
!
this
.
httpActivity
.
discardResponseBody
&
&
this
.
receivedData
.
length
)
{
this
.
_onComplete
(
this
.
receivedData
)
;
}
else
if
(
!
this
.
httpActivity
.
discardResponseBody
&
&
this
.
httpActivity
.
responseStatus
=
=
304
)
{
let
charset
;
try
{
charset
=
this
.
request
.
contentCharset
;
}
catch
(
e
)
{
}
if
(
!
charset
)
{
charset
=
this
.
httpActivity
.
charset
;
}
NetworkHelper
.
loadFromCache
(
this
.
httpActivity
.
url
charset
this
.
_onComplete
.
bind
(
this
)
)
;
}
else
{
this
.
_onComplete
(
)
;
}
}
_onComplete
:
function
(
data
)
{
const
response
=
{
mimeType
:
"
"
text
:
data
|
|
"
"
}
;
response
.
size
=
this
.
bodySize
;
response
.
transferredSize
=
this
.
transferredSize
+
this
.
httpActivity
.
headersSize
;
try
{
response
.
mimeType
=
this
.
request
.
contentType
;
}
catch
(
ex
)
{
}
if
(
!
response
.
mimeType
|
|
!
NetworkHelper
.
isTextMimeType
(
response
.
mimeType
)
)
{
response
.
encoding
=
"
base64
"
;
try
{
response
.
text
=
btoa
(
response
.
text
)
;
}
catch
(
err
)
{
}
}
if
(
response
.
mimeType
&
&
this
.
request
.
contentCharset
)
{
response
.
mimeType
+
=
"
;
charset
=
"
+
this
.
request
.
contentCharset
;
}
this
.
receivedData
=
"
"
;
this
.
httpActivity
.
owner
.
addResponseContent
(
response
{
discardResponseBody
:
this
.
httpActivity
.
discardResponseBody
truncated
:
this
.
truncated
}
)
;
this
.
_wrappedNotificationCallbacks
=
null
;
this
.
httpActivity
=
null
;
this
.
sink
=
null
;
this
.
inputStream
=
null
;
this
.
converter
=
null
;
this
.
request
=
null
;
this
.
owner
=
null
;
}
onInputStreamReady
:
function
(
stream
)
{
if
(
!
(
stream
instanceof
Ci
.
nsIAsyncInputStream
)
|
|
!
this
.
httpActivity
)
{
return
;
}
let
available
=
-
1
;
try
{
available
=
stream
.
available
(
)
;
}
catch
(
ex
)
{
}
if
(
available
!
=
-
1
)
{
if
(
available
!
=
0
)
{
if
(
this
.
converter
)
{
this
.
converter
.
onDataAvailable
(
this
.
request
null
stream
this
.
offset
available
)
;
}
else
{
this
.
onDataAvailable
(
this
.
request
null
stream
this
.
offset
available
)
;
}
}
this
.
offset
+
=
available
;
this
.
setAsyncListener
(
stream
this
)
;
}
else
{
this
.
onStreamClose
(
)
;
this
.
offset
=
0
;
}
}
}
;
function
NetworkMonitor
(
filters
owner
)
{
this
.
filters
=
filters
;
this
.
owner
=
owner
;
this
.
openRequests
=
new
Map
(
)
;
this
.
openResponses
=
new
Map
(
)
;
this
.
_httpResponseExaminer
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpResponseExaminer
)
.
bind
(
this
)
;
this
.
_httpModifyExaminer
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpModifyExaminer
)
.
bind
(
this
)
;
this
.
_serviceWorkerRequest
=
this
.
_serviceWorkerRequest
.
bind
(
this
)
;
this
.
_throttleData
=
null
;
this
.
_throttler
=
null
;
}
exports
.
NetworkMonitor
=
NetworkMonitor
;
NetworkMonitor
.
prototype
=
{
filters
:
null
httpTransactionCodes
:
{
0x5001
:
"
REQUEST_HEADER
"
0x5002
:
"
REQUEST_BODY_SENT
"
0x5003
:
"
RESPONSE_START
"
0x5004
:
"
RESPONSE_HEADER
"
0x5005
:
"
RESPONSE_COMPLETE
"
0x5006
:
"
TRANSACTION_CLOSE
"
0x804b0003
:
"
STATUS_RESOLVING
"
0x804b000b
:
"
STATUS_RESOLVED
"
0x804b0007
:
"
STATUS_CONNECTING_TO
"
0x804b0004
:
"
STATUS_CONNECTED_TO
"
0x804b0005
:
"
STATUS_SENDING_TO
"
0x804b000a
:
"
STATUS_WAITING_FOR
"
0x804b0006
:
"
STATUS_RECEIVING_FROM
"
0x804b000c
:
"
STATUS_TLS_STARTING
"
0x804b000d
:
"
STATUS_TLS_ENDING
"
}
httpDownloadActivities
:
[
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_START
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_HEADER
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_COMPLETE
gActivityDistributor
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
]
responsePipeSegmentSize
:
null
owner
:
null
saveRequestAndResponseBodies
:
true
openRequests
:
null
openResponses
:
null
init
:
function
(
)
{
this
.
responsePipeSegmentSize
=
Services
.
prefs
.
getIntPref
(
"
network
.
buffer
.
cache
.
size
"
)
;
this
.
interceptedChannels
=
new
Set
(
)
;
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
gActivityDistributor
.
addObserver
(
this
)
;
Services
.
obs
.
addObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
addObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
Services
.
obs
.
addObserver
(
this
.
_httpModifyExaminer
"
http
-
on
-
modify
-
request
"
)
;
}
Services
.
obs
.
addObserver
(
this
.
_serviceWorkerRequest
"
service
-
worker
-
synthesized
-
response
"
)
;
}
get
throttleData
(
)
{
return
this
.
_throttleData
;
}
set
throttleData
(
value
)
{
this
.
_throttleData
=
value
;
this
.
_throttler
=
null
;
}
_getThrottler
:
function
(
)
{
if
(
this
.
throttleData
!
=
=
null
&
&
this
.
_throttler
=
=
=
null
)
{
this
.
_throttler
=
new
NetworkThrottleManager
(
this
.
throttleData
)
;
}
return
this
.
_throttler
;
}
_serviceWorkerRequest
:
function
(
subject
topic
data
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
matchRequest
(
channel
this
.
filters
)
)
{
return
;
}
this
.
interceptedChannels
.
add
(
subject
)
;
this
.
_httpResponseExaminer
(
channel
"
http
-
on
-
examine
-
cached
-
response
"
)
;
}
_httpResponseExaminer
:
function
(
subject
topic
)
{
if
(
!
this
.
owner
|
|
(
topic
!
=
"
http
-
on
-
examine
-
response
"
&
&
topic
!
=
"
http
-
on
-
examine
-
cached
-
response
"
)
|
|
!
(
subject
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
matchRequest
(
channel
this
.
filters
)
)
{
return
;
}
const
response
=
{
id
:
gSequenceId
(
)
channel
:
channel
headers
:
[
]
cookies
:
[
]
}
;
const
setCookieHeaders
=
[
]
;
channel
.
visitOriginalResponseHeaders
(
{
visitHeader
:
function
(
name
value
)
{
const
lowerName
=
name
.
toLowerCase
(
)
;
if
(
lowerName
=
=
"
set
-
cookie
"
)
{
setCookieHeaders
.
push
(
value
)
;
}
response
.
headers
.
push
(
{
name
:
name
value
:
value
}
)
;
}
}
)
;
if
(
!
response
.
headers
.
length
)
{
return
;
}
if
(
setCookieHeaders
.
length
)
{
response
.
cookies
=
setCookieHeaders
.
reduce
(
(
result
header
)
=
>
{
const
cookies
=
NetworkHelper
.
parseSetCookieHeader
(
header
)
;
return
result
.
concat
(
cookies
)
;
}
[
]
)
;
}
const
httpVersionMaj
=
{
}
;
const
httpVersionMin
=
{
}
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
channel
.
getResponseVersion
(
httpVersionMaj
httpVersionMin
)
;
response
.
status
=
channel
.
responseStatus
;
response
.
statusText
=
channel
.
responseStatusText
;
response
.
httpVersion
=
"
HTTP
/
"
+
httpVersionMaj
.
value
+
"
.
"
+
httpVersionMin
.
value
;
this
.
openResponses
.
set
(
channel
response
)
;
if
(
topic
=
=
=
"
http
-
on
-
examine
-
cached
-
response
"
)
{
const
fromServiceWorker
=
this
.
interceptedChannels
.
has
(
channel
)
;
this
.
interceptedChannels
.
delete
(
channel
)
;
const
httpActivity
=
this
.
_createNetworkEvent
(
channel
{
fromCache
:
!
fromServiceWorker
fromServiceWorker
:
fromServiceWorker
}
)
;
httpActivity
.
owner
.
addResponseStart
(
{
httpVersion
:
response
.
httpVersion
remoteAddress
:
"
"
remotePort
:
"
"
status
:
response
.
status
statusText
:
response
.
statusText
headersSize
:
0
}
"
"
true
)
;
const
timings
=
this
.
_setupHarTimings
(
httpActivity
true
)
;
httpActivity
.
owner
.
addEventTimings
(
timings
.
total
timings
.
timings
timings
.
offsets
)
;
}
}
_httpModifyExaminer
:
function
(
subject
)
{
const
throttler
=
this
.
_getThrottler
(
)
;
if
(
throttler
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
matchRequest
(
channel
this
.
filters
)
)
{
const
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
this
.
_onRequestBodySent
(
httpActivity
)
;
throttler
.
manageUpload
(
channel
)
;
}
}
}
_dispatchActivity
:
function
(
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
{
const
transCodes
=
this
.
httpTransactionCodes
;
if
(
activitySubtype
in
transCodes
)
{
const
stage
=
transCodes
[
activitySubtype
]
;
if
(
stage
in
httpActivity
.
timings
)
{
httpActivity
.
timings
[
stage
]
.
last
=
timestamp
;
}
else
{
httpActivity
.
timings
[
stage
]
=
{
first
:
timestamp
last
:
timestamp
}
;
}
}
switch
(
activitySubtype
)
{
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_REQUEST_BODY_SENT
:
this
.
_onRequestBodySent
(
httpActivity
)
;
if
(
httpActivity
.
sentBody
!
=
=
null
)
{
httpActivity
.
owner
.
addRequestPostData
(
{
text
:
httpActivity
.
sentBody
}
)
;
httpActivity
.
sentBody
=
null
;
}
break
;
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_HEADER
:
this
.
_onResponseHeader
(
httpActivity
extraStringData
)
;
break
;
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
:
this
.
_onTransactionClose
(
httpActivity
)
;
break
;
default
:
break
;
}
}
observeActivity
:
DevToolsUtils
.
makeInfallible
(
function
(
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
{
if
(
!
this
.
owner
|
|
activityType
!
=
gActivityDistributor
.
ACTIVITY_TYPE_HTTP_TRANSACTION
&
&
activityType
!
=
gActivityDistributor
.
ACTIVITY_TYPE_SOCKET_TRANSPORT
)
{
return
;
}
if
(
!
(
channel
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
channel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
activitySubtype
=
=
gActivityDistributor
.
ACTIVITY_SUBTYPE_REQUEST_HEADER
)
{
this
.
_onRequestHeader
(
channel
timestamp
extraStringData
)
;
return
;
}
const
httpActivity
=
this
.
_findActivityObject
(
channel
)
;
if
(
!
httpActivity
)
{
return
;
}
if
(
httpActivity
.
downloadThrottle
&
&
this
.
httpDownloadActivities
.
includes
(
activitySubtype
)
)
{
const
callback
=
this
.
_dispatchActivity
.
bind
(
this
)
;
httpActivity
.
downloadThrottle
.
addActivityCallback
(
callback
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
;
}
else
{
this
.
_dispatchActivity
(
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
;
}
}
)
_createNetworkEvent
:
function
(
channel
{
timestamp
extraStringData
fromCache
fromServiceWorker
}
)
{
const
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
channel
.
QueryInterface
(
Ci
.
nsIPrivateBrowsingChannel
)
;
httpActivity
.
private
=
channel
.
isChannelPrivate
;
if
(
timestamp
)
{
httpActivity
.
timings
.
REQUEST_HEADER
=
{
first
:
timestamp
last
:
timestamp
}
;
}
const
event
=
{
}
;
event
.
method
=
channel
.
requestMethod
;
event
.
channelId
=
channel
.
channelId
;
event
.
url
=
channel
.
URI
.
spec
;
event
.
private
=
httpActivity
.
private
;
event
.
headersSize
=
0
;
event
.
startedDateTime
=
(
timestamp
?
new
Date
(
Math
.
round
(
timestamp
/
1000
)
)
:
new
Date
(
)
)
.
toISOString
(
)
;
event
.
fromCache
=
fromCache
;
event
.
fromServiceWorker
=
fromServiceWorker
;
httpActivity
.
fromServiceWorker
=
fromServiceWorker
;
if
(
extraStringData
)
{
event
.
headersSize
=
extraStringData
.
length
;
}
let
causeType
=
Ci
.
nsIContentPolicy
.
TYPE_OTHER
;
let
causeUri
=
null
;
let
stacktrace
;
if
(
channel
.
loadInfo
)
{
causeType
=
channel
.
loadInfo
.
externalContentPolicyType
;
const
{
loadingPrincipal
}
=
channel
.
loadInfo
;
if
(
loadingPrincipal
&
&
loadingPrincipal
.
URI
)
{
causeUri
=
loadingPrincipal
.
URI
.
spec
;
}
}
event
.
cause
=
{
type
:
causeTypeToString
(
causeType
)
loadingDocumentUri
:
causeUri
stacktrace
}
;
httpActivity
.
isXHR
=
event
.
isXHR
=
(
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
|
|
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_FETCH
)
;
const
httpVersionMaj
=
{
}
;
const
httpVersionMin
=
{
}
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
channel
.
getRequestVersion
(
httpVersionMaj
httpVersionMin
)
;
event
.
httpVersion
=
"
HTTP
/
"
+
httpVersionMaj
.
value
+
"
.
"
+
httpVersionMin
.
value
;
event
.
discardRequestBody
=
!
this
.
saveRequestAndResponseBodies
;
event
.
discardResponseBody
=
!
this
.
saveRequestAndResponseBodies
;
const
headers
=
[
]
;
let
cookies
=
[
]
;
let
cookieHeader
=
null
;
channel
.
visitRequestHeaders
(
{
visitHeader
:
function
(
name
value
)
{
if
(
name
=
=
"
Cookie
"
)
{
cookieHeader
=
value
;
}
headers
.
push
(
{
name
:
name
value
:
value
}
)
;
}
}
)
;
if
(
cookieHeader
)
{
cookies
=
NetworkHelper
.
parseCookieHeader
(
cookieHeader
)
;
}
httpActivity
.
owner
=
this
.
owner
.
onNetworkEvent
(
event
)
;
this
.
_setupResponseListener
(
httpActivity
fromCache
)
;
httpActivity
.
owner
.
addRequestHeaders
(
headers
extraStringData
)
;
httpActivity
.
owner
.
addRequestCookies
(
cookies
)
;
return
httpActivity
;
}
_onRequestHeader
:
function
(
channel
timestamp
extraStringData
)
{
if
(
!
matchRequest
(
channel
this
.
filters
)
)
{
return
;
}
this
.
_createNetworkEvent
(
channel
{
timestamp
extraStringData
}
)
;
}
_findActivityObject
:
function
(
channel
)
{
return
this
.
openRequests
.
get
(
channel
)
|
|
null
;
}
createOrGetActivityObject
:
function
(
channel
)
{
let
httpActivity
=
this
.
_findActivityObject
(
channel
)
;
if
(
!
httpActivity
)
{
const
win
=
NetworkHelper
.
getWindowForRequest
(
channel
)
;
const
charset
=
win
?
win
.
document
.
characterSet
:
null
;
httpActivity
=
{
id
:
gSequenceId
(
)
channel
:
channel
charset
:
charset
sentBody
:
null
url
:
channel
.
URI
.
spec
headersSize
:
null
hostname
:
channel
.
URI
.
host
discardRequestBody
:
!
this
.
saveRequestAndResponseBodies
discardResponseBody
:
!
this
.
saveRequestAndResponseBodies
timings
:
{
}
responseStatus
:
null
owner
:
null
}
;
this
.
openRequests
.
set
(
channel
httpActivity
)
;
}
return
httpActivity
;
}
_setupResponseListener
:
function
(
httpActivity
fromCache
)
{
const
channel
=
httpActivity
.
channel
;
channel
.
QueryInterface
(
Ci
.
nsITraceableChannel
)
;
if
(
!
fromCache
)
{
const
throttler
=
this
.
_getThrottler
(
)
;
if
(
throttler
)
{
httpActivity
.
downloadThrottle
=
throttler
.
manage
(
channel
)
;
}
}
const
sink
=
Cc
[
"
mozilla
.
org
/
pipe
;
1
"
]
.
createInstance
(
Ci
.
nsIPipe
)
;
sink
.
init
(
false
false
this
.
responsePipeSegmentSize
PR_UINT32_MAX
null
)
;
const
newListener
=
new
NetworkResponseListener
(
this
httpActivity
)
;
newListener
.
inputStream
=
sink
.
inputStream
;
newListener
.
sink
=
sink
;
const
tee
=
Cc
[
"
mozilla
.
org
/
network
/
stream
-
listener
-
tee
;
1
"
]
.
createInstance
(
Ci
.
nsIStreamListenerTee
)
;
const
originalListener
=
channel
.
setNewListener
(
tee
)
;
tee
.
init
(
originalListener
sink
.
outputStream
newListener
)
;
}
_onRequestBodySent
:
function
(
httpActivity
)
{
if
(
httpActivity
.
discardRequestBody
|
|
httpActivity
.
sentBody
!
=
=
null
)
{
return
;
}
let
sentBody
=
NetworkHelper
.
readPostTextFromRequest
(
httpActivity
.
channel
httpActivity
.
charset
)
;
if
(
sentBody
!
=
=
null
&
&
this
.
window
&
&
httpActivity
.
url
=
=
this
.
window
.
location
.
href
)
{
const
webNav
=
this
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
sentBody
=
NetworkHelper
.
readPostTextFromPageViaWebNav
(
webNav
httpActivity
.
charset
)
;
}
if
(
sentBody
!
=
=
null
)
{
httpActivity
.
sentBody
=
sentBody
;
}
}
_onResponseHeader
:
function
(
httpActivity
extraStringData
)
{
const
headers
=
extraStringData
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
const
statusLine
=
headers
.
shift
(
)
;
const
statusLineArray
=
statusLine
.
split
(
"
"
)
;
const
response
=
{
}
;
response
.
httpVersion
=
statusLineArray
.
shift
(
)
;
response
.
remoteAddress
=
httpActivity
.
channel
.
remoteAddress
;
response
.
remotePort
=
httpActivity
.
channel
.
remotePort
;
response
.
status
=
statusLineArray
.
shift
(
)
;
response
.
statusText
=
statusLineArray
.
join
(
"
"
)
;
response
.
headersSize
=
extraStringData
.
length
;
httpActivity
.
responseStatus
=
response
.
status
;
httpActivity
.
headersSize
=
response
.
headersSize
;
switch
(
parseInt
(
response
.
status
10
)
)
{
case
HTTP_MOVED_PERMANENTLY
:
case
HTTP_FOUND
:
case
HTTP_SEE_OTHER
:
case
HTTP_TEMPORARY_REDIRECT
:
httpActivity
.
discardResponseBody
=
true
;
break
;
}
response
.
discardResponseBody
=
httpActivity
.
discardResponseBody
;
httpActivity
.
owner
.
addResponseStart
(
response
extraStringData
)
;
}
_onTransactionClose
:
function
(
httpActivity
)
{
const
result
=
this
.
_setupHarTimings
(
httpActivity
)
;
httpActivity
.
owner
.
addEventTimings
(
result
.
total
result
.
timings
result
.
offsets
)
;
this
.
openRequests
.
delete
(
httpActivity
.
channel
)
;
}
_setupHarTimings
:
function
(
httpActivity
fromCache
)
{
if
(
fromCache
)
{
return
{
total
:
0
timings
:
{
blocked
:
0
dns
:
0
ssl
:
0
connect
:
0
send
:
0
wait
:
0
receive
:
0
}
offsets
:
{
blocked
:
0
dns
:
0
ssl
:
0
connect
:
0
send
:
0
wait
:
0
receive
:
0
}
}
;
}
const
timings
=
httpActivity
.
timings
;
const
harTimings
=
{
}
;
let
secureConnectionStartTime
=
0
;
let
secureConnectionStartTimeRelative
=
false
;
let
startSendingTime
=
0
;
let
startSendingTimeRelative
=
false
;
if
(
timings
.
STATUS_RESOLVING
&
&
timings
.
STATUS_CONNECTING_TO
)
{
harTimings
.
blocked
=
timings
.
STATUS_RESOLVING
.
first
-
timings
.
REQUEST_HEADER
.
first
;
}
else
if
(
timings
.
STATUS_SENDING_TO
)
{
harTimings
.
blocked
=
timings
.
STATUS_SENDING_TO
.
first
-
timings
.
REQUEST_HEADER
.
first
;
}
else
{
harTimings
.
blocked
=
-
1
;
}
harTimings
.
dns
=
timings
.
STATUS_RESOLVING
&
&
timings
.
STATUS_RESOLVED
?
timings
.
STATUS_RESOLVED
.
last
-
timings
.
STATUS_RESOLVING
.
first
:
-
1
;
if
(
timings
.
STATUS_CONNECTING_TO
&
&
timings
.
STATUS_CONNECTED_TO
)
{
harTimings
.
connect
=
timings
.
STATUS_CONNECTED_TO
.
last
-
timings
.
STATUS_CONNECTING_TO
.
first
;
}
else
{
harTimings
.
connect
=
-
1
;
}
if
(
timings
.
STATUS_TLS_STARTING
&
&
timings
.
STATUS_TLS_ENDING
)
{
harTimings
.
ssl
=
timings
.
STATUS_TLS_ENDING
.
last
-
timings
.
STATUS_TLS_STARTING
.
first
;
if
(
timings
.
STATUS_CONNECTING_TO
)
{
secureConnectionStartTime
=
timings
.
STATUS_TLS_STARTING
.
first
-
timings
.
STATUS_CONNECTING_TO
.
first
;
}
if
(
secureConnectionStartTime
<
0
)
{
secureConnectionStartTime
=
0
;
}
secureConnectionStartTimeRelative
=
true
;
}
else
{
harTimings
.
ssl
=
-
1
;
}
const
timedChannel
=
httpActivity
.
channel
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
let
tcTcpConnectEndTime
=
0
;
let
tcConnectStartTime
=
0
;
let
tcConnectEndTime
=
0
;
let
tcSecureConnectionStartTime
=
0
;
let
tcDomainLookupEndTime
=
0
;
let
tcDomainLookupStartTime
=
0
;
if
(
timedChannel
)
{
tcTcpConnectEndTime
=
timedChannel
.
tcpConnectEndTime
;
tcConnectStartTime
=
timedChannel
.
connectStartTime
;
tcConnectEndTime
=
timedChannel
.
connectEndTime
;
tcSecureConnectionStartTime
=
timedChannel
.
secureConnectionStartTime
;
tcDomainLookupEndTime
=
timedChannel
.
domainLookupEndTime
;
tcDomainLookupStartTime
=
timedChannel
.
domainLookupStartTime
;
}
if
(
timedChannel
&
&
timedChannel
.
asyncOpenTime
)
{
if
(
(
tcTcpConnectEndTime
!
=
0
)
&
&
(
tcTcpConnectEndTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcTcpConnectEndTime
=
0
;
}
if
(
(
tcConnectStartTime
!
=
0
)
&
&
(
tcConnectStartTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcConnectStartTime
=
0
;
}
if
(
(
tcConnectEndTime
!
=
0
)
&
&
(
tcConnectEndTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcConnectEndTime
=
0
;
}
if
(
(
tcSecureConnectionStartTime
!
=
0
)
&
&
(
tcSecureConnectionStartTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcSecureConnectionStartTime
=
0
;
}
if
(
(
tcDomainLookupEndTime
!
=
0
)
&
&
(
tcDomainLookupEndTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcDomainLookupEndTime
=
0
;
}
if
(
(
tcDomainLookupStartTime
!
=
0
)
&
&
(
tcDomainLookupStartTime
<
timedChannel
.
asyncOpenTime
)
)
{
tcDomainLookupStartTime
=
0
;
}
}
if
(
(
harTimings
.
connect
<
=
0
)
&
&
timedChannel
&
&
(
tcTcpConnectEndTime
!
=
0
)
&
&
(
tcConnectStartTime
!
=
0
)
)
{
harTimings
.
connect
=
tcTcpConnectEndTime
-
tcConnectStartTime
;
if
(
tcSecureConnectionStartTime
!
=
0
)
{
harTimings
.
ssl
=
tcConnectEndTime
-
tcSecureConnectionStartTime
;
secureConnectionStartTime
=
tcSecureConnectionStartTime
-
tcConnectStartTime
;
secureConnectionStartTimeRelative
=
true
;
}
else
{
harTimings
.
ssl
=
-
1
;
}
}
else
if
(
timedChannel
&
&
timings
.
STATUS_TLS_STARTING
&
&
(
tcSecureConnectionStartTime
!
=
0
)
)
{
if
(
tcSecureConnectionStartTime
>
timings
.
STATUS_TLS_STARTING
.
first
)
{
harTimings
.
ssl
=
tcConnectEndTime
-
tcSecureConnectionStartTime
;
secureConnectionStartTimeRelative
=
false
;
}
}
if
(
(
harTimings
.
dns
<
=
0
)
&
&
timedChannel
&
&
(
tcDomainLookupEndTime
!
=
0
)
&
&
(
tcDomainLookupStartTime
!
=
0
)
)
{
harTimings
.
dns
=
tcDomainLookupEndTime
-
tcDomainLookupStartTime
;
}
if
(
timings
.
STATUS_SENDING_TO
)
{
harTimings
.
send
=
timings
.
STATUS_SENDING_TO
.
last
-
timings
.
STATUS_SENDING_TO
.
first
;
if
(
timings
.
STATUS_CONNECTING_TO
)
{
startSendingTime
=
timings
.
STATUS_SENDING_TO
.
first
-
timings
.
STATUS_CONNECTING_TO
.
first
;
startSendingTimeRelative
=
true
;
}
else
if
(
tcConnectStartTime
!
=
0
)
{
startSendingTime
=
timings
.
STATUS_SENDING_TO
.
first
-
tcConnectStartTime
;
startSendingTimeRelative
=
true
;
}
if
(
startSendingTime
<
0
)
{
startSendingTime
=
0
;
}
}
else
if
(
timings
.
REQUEST_HEADER
&
&
timings
.
REQUEST_BODY_SENT
)
{
harTimings
.
send
=
timings
.
REQUEST_BODY_SENT
.
last
-
timings
.
REQUEST_HEADER
.
first
;
}
else
{
harTimings
.
send
=
-
1
;
}
if
(
timings
.
RESPONSE_START
)
{
harTimings
.
wait
=
timings
.
RESPONSE_START
.
first
-
(
timings
.
REQUEST_BODY_SENT
|
|
timings
.
STATUS_SENDING_TO
)
.
last
;
}
else
{
harTimings
.
wait
=
-
1
;
}
if
(
timings
.
RESPONSE_START
&
&
timings
.
RESPONSE_COMPLETE
)
{
harTimings
.
receive
=
timings
.
RESPONSE_COMPLETE
.
last
-
timings
.
RESPONSE_START
.
first
;
}
else
{
harTimings
.
receive
=
-
1
;
}
if
(
secureConnectionStartTimeRelative
)
{
const
time
=
Math
.
max
(
Math
.
round
(
secureConnectionStartTime
/
1000
)
-
1
)
;
secureConnectionStartTime
=
time
;
}
if
(
startSendingTimeRelative
)
{
const
time
=
Math
.
max
(
Math
.
round
(
startSendingTime
/
1000
)
-
1
)
;
startSendingTime
=
time
;
}
const
ot
=
this
.
_calculateOffsetAndTotalTime
(
harTimings
secureConnectionStartTime
startSendingTimeRelative
secureConnectionStartTimeRelative
startSendingTime
)
;
return
{
total
:
ot
.
total
timings
:
harTimings
offsets
:
ot
.
offsets
}
;
}
_calculateOffsetAndTotalTime
:
function
(
harTimings
secureConnectionStartTime
startSendingTimeRelative
secureConnectionStartTimeRelative
startSendingTime
)
{
let
totalTime
=
0
;
for
(
const
timing
in
harTimings
)
{
const
time
=
Math
.
max
(
Math
.
round
(
harTimings
[
timing
]
/
1000
)
-
1
)
;
harTimings
[
timing
]
=
time
;
if
(
(
time
>
-
1
)
&
&
(
timing
!
=
"
connect
"
)
&
&
(
timing
!
=
"
ssl
"
)
)
{
totalTime
+
=
time
;
}
}
if
(
startSendingTimeRelative
)
{
totalTime
+
=
startSendingTime
;
}
else
if
(
secureConnectionStartTimeRelative
)
{
totalTime
+
=
secureConnectionStartTime
;
totalTime
+
=
harTimings
.
ssl
;
}
const
offsets
=
{
}
;
offsets
.
blocked
=
0
;
offsets
.
dns
=
harTimings
.
blocked
;
offsets
.
connect
=
offsets
.
dns
+
harTimings
.
dns
;
if
(
secureConnectionStartTimeRelative
)
{
offsets
.
ssl
=
offsets
.
connect
+
secureConnectionStartTime
;
}
else
{
offsets
.
ssl
=
offsets
.
connect
+
harTimings
.
connect
;
}
if
(
startSendingTimeRelative
)
{
offsets
.
send
=
offsets
.
connect
+
startSendingTime
;
if
(
!
secureConnectionStartTimeRelative
)
{
offsets
.
ssl
=
offsets
.
send
-
harTimings
.
ssl
;
}
}
else
{
offsets
.
send
=
offsets
.
ssl
+
harTimings
.
ssl
;
}
offsets
.
wait
=
offsets
.
send
+
harTimings
.
send
;
offsets
.
receive
=
offsets
.
wait
+
harTimings
.
wait
;
return
{
total
:
totalTime
offsets
:
offsets
}
;
}
destroy
:
function
(
)
{
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
gActivityDistributor
.
removeObserver
(
this
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpModifyExaminer
"
http
-
on
-
modify
-
request
"
)
;
}
Services
.
obs
.
removeObserver
(
this
.
_serviceWorkerRequest
"
service
-
worker
-
synthesized
-
response
"
)
;
this
.
interceptedChannels
.
clear
(
)
;
this
.
openRequests
.
clear
(
)
;
this
.
openResponses
.
clear
(
)
;
this
.
owner
=
null
;
this
.
filters
=
null
;
this
.
_throttler
=
null
;
}
}
;
function
ConsoleProgressListener
(
window
owner
)
{
this
.
window
=
window
;
this
.
owner
=
owner
;
}
exports
.
ConsoleProgressListener
=
ConsoleProgressListener
;
ConsoleProgressListener
.
prototype
=
{
MONITOR_FILE_ACTIVITY
:
1
MONITOR_LOCATION_CHANGE
:
2
_fileActivity
:
false
_locationChange
:
false
_initialized
:
false
_webProgress
:
null
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
_init
:
function
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_webProgress
=
this
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
this
.
_initialized
=
true
;
}
startMonitor
:
function
(
monitor
)
{
switch
(
monitor
)
{
case
this
.
MONITOR_FILE_ACTIVITY
:
this
.
_fileActivity
=
true
;
break
;
case
this
.
MONITOR_LOCATION_CHANGE
:
this
.
_locationChange
=
true
;
break
;
default
:
throw
new
Error
(
"
ConsoleProgressListener
:
unknown
monitor
type
"
+
monitor
+
"
!
"
)
;
}
this
.
_init
(
)
;
}
stopMonitor
:
function
(
monitor
)
{
switch
(
monitor
)
{
case
this
.
MONITOR_FILE_ACTIVITY
:
this
.
_fileActivity
=
false
;
break
;
case
this
.
MONITOR_LOCATION_CHANGE
:
this
.
_locationChange
=
false
;
break
;
default
:
throw
new
Error
(
"
ConsoleProgressListener
:
unknown
monitor
type
"
+
monitor
+
"
!
"
)
;
}
if
(
!
this
.
_fileActivity
&
&
!
this
.
_locationChange
)
{
this
.
destroy
(
)
;
}
}
onStateChange
:
function
(
progress
request
state
status
)
{
if
(
!
this
.
owner
)
{
return
;
}
if
(
this
.
_fileActivity
)
{
this
.
_checkFileActivity
(
progress
request
state
status
)
;
}
if
(
this
.
_locationChange
)
{
this
.
_checkLocationChange
(
progress
request
state
status
)
;
}
}
_checkFileActivity
:
function
(
progress
request
state
status
)
{
if
(
!
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
uri
=
null
;
if
(
request
instanceof
Ci
.
imgIRequest
)
{
const
imgIRequest
=
request
.
QueryInterface
(
Ci
.
imgIRequest
)
;
uri
=
imgIRequest
.
URI
;
}
else
if
(
request
instanceof
Ci
.
nsIChannel
)
{
const
nsIChannel
=
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
uri
=
nsIChannel
.
URI
;
}
if
(
!
uri
|
|
!
uri
.
schemeIs
(
"
file
"
)
&
&
!
uri
.
schemeIs
(
"
ftp
"
)
)
{
return
;
}
this
.
owner
.
onFileActivity
(
uri
.
spec
)
;
}
_checkLocationChange
:
function
(
progress
request
state
)
{
const
isStart
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
isStop
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
const
isNetwork
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
;
const
isWindow
=
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
;
if
(
!
isNetwork
|
|
!
isWindow
|
|
progress
.
DOMWindow
!
=
this
.
window
)
{
return
;
}
if
(
isStart
&
&
request
instanceof
Ci
.
nsIChannel
)
{
this
.
owner
.
onLocationChange
(
"
start
"
request
.
URI
.
spec
"
"
)
;
}
else
if
(
isStop
)
{
this
.
owner
.
onLocationChange
(
"
stop
"
this
.
window
.
location
.
href
this
.
window
.
document
.
title
)
;
}
}
destroy
:
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
_fileActivity
=
false
;
this
.
_locationChange
=
false
;
try
{
this
.
_webProgress
.
removeProgressListener
(
this
)
;
}
catch
(
ex
)
{
}
this
.
_webProgress
=
null
;
this
.
window
=
null
;
this
.
owner
=
null
;
}
}
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
1
;
const
LOAD_CAUSE_STRINGS
=
{
[
Ci
.
nsIContentPolicy
.
TYPE_INVALID
]
:
"
invalid
"
[
Ci
.
nsIContentPolicy
.
TYPE_OTHER
]
:
"
other
"
[
Ci
.
nsIContentPolicy
.
TYPE_SCRIPT
]
:
"
script
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
]
:
"
img
"
[
Ci
.
nsIContentPolicy
.
TYPE_STYLESHEET
]
:
"
stylesheet
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT
]
:
"
object
"
[
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
]
:
"
document
"
[
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
]
:
"
subdocument
"
[
Ci
.
nsIContentPolicy
.
TYPE_REFRESH
]
:
"
refresh
"
[
Ci
.
nsIContentPolicy
.
TYPE_XBL
]
:
"
xbl
"
[
Ci
.
nsIContentPolicy
.
TYPE_PING
]
:
"
ping
"
[
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
]
:
"
xhr
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT_SUBREQUEST
]
:
"
objectSubdoc
"
[
Ci
.
nsIContentPolicy
.
TYPE_DTD
]
:
"
dtd
"
[
Ci
.
nsIContentPolicy
.
TYPE_FONT
]
:
"
font
"
[
Ci
.
nsIContentPolicy
.
TYPE_MEDIA
]
:
"
media
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
]
:
"
websocket
"
[
Ci
.
nsIContentPolicy
.
TYPE_CSP_REPORT
]
:
"
csp
"
[
Ci
.
nsIContentPolicy
.
TYPE_XSLT
]
:
"
xslt
"
[
Ci
.
nsIContentPolicy
.
TYPE_BEACON
]
:
"
beacon
"
[
Ci
.
nsIContentPolicy
.
TYPE_FETCH
]
:
"
fetch
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
]
:
"
imageset
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEB_MANIFEST
]
:
"
webManifest
"
}
;
function
causeTypeToString
(
causeType
)
{
return
LOAD_CAUSE_STRINGS
[
causeType
]
|
|
"
unknown
"
;
}
