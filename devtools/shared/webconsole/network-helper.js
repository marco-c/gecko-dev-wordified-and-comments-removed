"
use
strict
"
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
components
Cc
Ci
}
=
require
(
"
chrome
"
)
;
loader
.
lazyImporter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyGetter
(
this
"
certDecoder
"
(
)
=
>
{
const
{
asn1js
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
global
/
content
/
certviewer
/
asn1js_bundle
.
jsm
"
)
;
const
{
pkijs
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
global
/
content
/
certviewer
/
pkijs_bundle
.
jsm
"
)
;
const
{
pvutils
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
global
/
content
/
certviewer
/
pvutils_bundle
.
jsm
"
)
;
const
{
Integer
fromBER
}
=
asn1js
.
asn1js
;
const
{
Certificate
}
=
pkijs
.
pkijs
;
const
{
fromBase64
stringToArrayBuffer
}
=
pvutils
.
pvutils
;
const
{
certDecoderInitializer
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
global
/
content
/
certviewer
/
certDecoder
.
jsm
"
)
;
const
{
parse
pemToDER
}
=
certDecoderInitializer
(
Integer
fromBER
Certificate
fromBase64
stringToArrayBuffer
crypto
)
;
return
{
parse
pemToDER
}
;
}
)
;
const
COOKIE_SAMESITE
=
{
LAX
:
"
Lax
"
STRICT
:
"
Strict
"
NONE
:
"
None
"
}
;
var
NetworkHelper
=
{
convertToUnicode
(
text
charset
)
{
const
conv
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
try
{
conv
.
charset
=
charset
|
|
"
UTF
-
8
"
;
return
conv
.
ConvertToUnicode
(
text
)
;
}
catch
(
ex
)
{
return
text
;
}
}
readAndConvertFromStream
(
stream
charset
)
{
let
text
=
null
;
try
{
text
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
this
.
convertToUnicode
(
text
charset
)
;
}
catch
(
err
)
{
return
text
;
}
}
readPostTextFromRequest
(
request
charset
)
{
if
(
request
instanceof
Ci
.
nsIUploadChannel
)
{
const
iStream
=
request
.
uploadStream
;
let
isSeekableStream
=
false
;
if
(
iStream
instanceof
Ci
.
nsISeekableStream
)
{
isSeekableStream
=
true
;
}
let
prevOffset
;
if
(
isSeekableStream
)
{
prevOffset
=
iStream
.
tell
(
)
;
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
const
text
=
this
.
readAndConvertFromStream
(
iStream
charset
)
;
if
(
isSeekableStream
&
&
prevOffset
=
=
0
)
{
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
return
text
;
}
return
null
;
}
readPostTextFromPage
(
docShell
charset
)
{
const
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
return
this
.
readPostTextFromPageViaWebNav
(
webNav
charset
)
;
}
readPostTextFromPageViaWebNav
(
webNav
charset
)
{
if
(
webNav
instanceof
Ci
.
nsIWebPageDescriptor
)
{
const
descriptor
=
webNav
.
currentDescriptor
;
if
(
descriptor
instanceof
Ci
.
nsISHEntry
&
&
descriptor
.
postData
&
&
descriptor
instanceof
Ci
.
nsISeekableStream
)
{
descriptor
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
return
this
.
readAndConvertFromStream
(
descriptor
charset
)
;
}
}
return
null
;
}
getTopFrameForRequest
(
request
)
{
try
{
return
this
.
getRequestLoadContext
(
request
)
.
topFrameElement
;
}
catch
(
ex
)
{
}
return
null
;
}
getWindowForRequest
(
request
)
{
try
{
return
this
.
getRequestLoadContext
(
request
)
.
associatedWindow
;
}
catch
(
ex
)
{
}
return
request
.
loadInfo
.
loadingDocument
?
.
defaultView
;
}
getRequestLoadContext
(
request
)
{
try
{
return
request
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
try
{
return
request
.
loadGroup
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
return
null
;
}
isTopLevelLoad
(
request
)
{
if
(
request
instanceof
Ci
.
nsIChannel
)
{
const
loadInfo
=
request
.
loadInfo
;
if
(
loadInfo
?
.
isTopLevelLoad
)
{
return
request
.
loadFlags
&
Ci
.
nsIChannel
.
LOAD_DOCUMENT_URI
;
}
}
return
false
;
}
loadFromCache
(
url
charset
callback
)
{
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
}
)
;
channel
.
loadFlags
=
Ci
.
nsIRequest
.
LOAD_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_ONLY_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
;
NetUtil
.
asyncFetch
(
channel
(
inputStream
statusCode
request
)
=
>
{
if
(
!
components
.
isSuccessCode
(
statusCode
)
)
{
callback
(
null
)
;
return
;
}
const
requestChannel
=
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
const
contentCharset
=
requestChannel
.
contentCharset
|
|
charset
;
callback
(
this
.
readAndConvertFromStream
(
inputStream
contentCharset
)
)
;
}
)
;
}
parseCookieHeader
(
header
)
{
const
cookies
=
header
.
split
(
"
;
"
)
;
const
result
=
[
]
;
cookies
.
forEach
(
function
(
cookie
)
{
const
equal
=
cookie
.
indexOf
(
"
=
"
)
;
const
name
=
cookie
.
substr
(
0
equal
)
;
const
value
=
cookie
.
substr
(
equal
+
1
)
;
result
.
push
(
{
name
:
unescape
(
name
.
trim
(
)
)
value
:
unescape
(
value
.
trim
(
)
)
}
)
;
}
)
;
return
result
;
}
parseSetCookieHeader
(
header
)
{
function
parseSameSiteAttribute
(
attribute
)
{
attribute
=
attribute
.
toLowerCase
(
)
;
switch
(
attribute
)
{
case
COOKIE_SAMESITE
.
LAX
.
toLowerCase
(
)
:
return
COOKIE_SAMESITE
.
LAX
;
case
COOKIE_SAMESITE
.
STRICT
.
toLowerCase
(
)
:
return
COOKIE_SAMESITE
.
STRICT
;
default
:
return
COOKIE_SAMESITE
.
NONE
;
}
}
const
rawCookies
=
header
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
const
cookies
=
[
]
;
rawCookies
.
forEach
(
function
(
cookie
)
{
const
equal
=
cookie
.
indexOf
(
"
=
"
)
;
const
name
=
unescape
(
cookie
.
substr
(
0
equal
)
.
trim
(
)
)
;
const
parts
=
cookie
.
substr
(
equal
+
1
)
.
split
(
"
;
"
)
;
const
value
=
unescape
(
parts
.
shift
(
)
.
trim
(
)
)
;
cookie
=
{
name
value
}
;
parts
.
forEach
(
function
(
part
)
{
part
=
part
.
trim
(
)
;
if
(
part
.
toLowerCase
(
)
=
=
"
secure
"
)
{
cookie
.
secure
=
true
;
}
else
if
(
part
.
toLowerCase
(
)
=
=
"
httponly
"
)
{
cookie
.
httpOnly
=
true
;
}
else
if
(
part
.
indexOf
(
"
=
"
)
>
-
1
)
{
const
pair
=
part
.
split
(
"
=
"
)
;
pair
[
0
]
=
pair
[
0
]
.
toLowerCase
(
)
;
if
(
pair
[
0
]
=
=
"
path
"
|
|
pair
[
0
]
=
=
"
domain
"
)
{
cookie
[
pair
[
0
]
]
=
pair
[
1
]
;
}
else
if
(
pair
[
0
]
=
=
"
samesite
"
)
{
cookie
[
pair
[
0
]
]
=
parseSameSiteAttribute
(
pair
[
1
]
)
;
}
else
if
(
pair
[
0
]
=
=
"
expires
"
)
{
try
{
pair
[
1
]
=
pair
[
1
]
.
replace
(
/
-
/
g
"
"
)
;
cookie
.
expires
=
new
Date
(
pair
[
1
]
)
.
toISOString
(
)
;
}
catch
(
ex
)
{
}
}
}
}
)
;
cookies
.
push
(
cookie
)
;
}
)
;
return
cookies
;
}
mimeCategoryMap
:
{
"
text
/
plain
"
:
"
txt
"
"
text
/
html
"
:
"
html
"
"
text
/
xml
"
:
"
xml
"
"
text
/
xsl
"
:
"
txt
"
"
text
/
xul
"
:
"
txt
"
"
text
/
css
"
:
"
css
"
"
text
/
sgml
"
:
"
txt
"
"
text
/
rtf
"
:
"
txt
"
"
text
/
x
-
setext
"
:
"
txt
"
"
text
/
richtext
"
:
"
txt
"
"
text
/
javascript
"
:
"
js
"
"
text
/
jscript
"
:
"
txt
"
"
text
/
tab
-
separated
-
values
"
:
"
txt
"
"
text
/
rdf
"
:
"
txt
"
"
text
/
xif
"
:
"
txt
"
"
text
/
ecmascript
"
:
"
js
"
"
text
/
vnd
.
curl
"
:
"
txt
"
"
text
/
x
-
json
"
:
"
json
"
"
text
/
x
-
js
"
:
"
txt
"
"
text
/
js
"
:
"
txt
"
"
text
/
vbscript
"
:
"
txt
"
"
view
-
source
"
:
"
txt
"
"
view
-
fragment
"
:
"
txt
"
"
application
/
xml
"
:
"
xml
"
"
application
/
xhtml
+
xml
"
:
"
xml
"
"
application
/
atom
+
xml
"
:
"
xml
"
"
application
/
rss
+
xml
"
:
"
xml
"
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
:
"
xml
"
"
application
/
javascript
"
:
"
js
"
"
application
/
x
-
javascript
"
:
"
js
"
"
application
/
x
-
httpd
-
php
"
:
"
txt
"
"
application
/
rdf
+
xml
"
:
"
xml
"
"
application
/
ecmascript
"
:
"
js
"
"
application
/
http
-
index
-
format
"
:
"
txt
"
"
application
/
json
"
:
"
json
"
"
application
/
x
-
js
"
:
"
txt
"
"
application
/
x
-
mpegurl
"
:
"
txt
"
"
application
/
vnd
.
apple
.
mpegurl
"
:
"
txt
"
"
multipart
/
mixed
"
:
"
txt
"
"
multipart
/
x
-
mixed
-
replace
"
:
"
txt
"
"
image
/
svg
+
xml
"
:
"
svg
"
"
application
/
octet
-
stream
"
:
"
bin
"
"
image
/
jpeg
"
:
"
image
"
"
image
/
jpg
"
:
"
image
"
"
image
/
gif
"
:
"
image
"
"
image
/
png
"
:
"
image
"
"
image
/
bmp
"
:
"
image
"
"
application
/
x
-
shockwave
-
flash
"
:
"
flash
"
"
video
/
x
-
flv
"
:
"
flash
"
"
audio
/
mpeg3
"
:
"
media
"
"
audio
/
x
-
mpeg
-
3
"
:
"
media
"
"
video
/
mpeg
"
:
"
media
"
"
video
/
x
-
mpeg
"
:
"
media
"
"
video
/
vnd
.
mpeg
.
dash
.
mpd
"
:
"
xml
"
"
audio
/
ogg
"
:
"
media
"
"
application
/
ogg
"
:
"
media
"
"
application
/
x
-
ogg
"
:
"
media
"
"
application
/
x
-
midi
"
:
"
media
"
"
audio
/
midi
"
:
"
media
"
"
audio
/
x
-
mid
"
:
"
media
"
"
audio
/
x
-
midi
"
:
"
media
"
"
music
/
crescendo
"
:
"
media
"
"
audio
/
wav
"
:
"
media
"
"
audio
/
x
-
wav
"
:
"
media
"
"
text
/
json
"
:
"
json
"
"
application
/
x
-
json
"
:
"
json
"
"
application
/
json
-
rpc
"
:
"
json
"
"
application
/
x
-
web
-
app
-
manifest
+
json
"
:
"
json
"
"
application
/
manifest
+
json
"
:
"
json
"
}
isTextMimeType
(
mimeType
)
{
if
(
mimeType
.
indexOf
(
"
text
/
"
)
=
=
0
)
{
return
true
;
}
if
(
/
^
application
\
/
\
w
+
(
?
:
[
\
.
-
]
\
w
+
)
*
(
?
:
\
+
xml
|
[
-
+
]
json
)
/
.
test
(
mimeType
)
)
{
return
true
;
}
const
category
=
this
.
mimeCategoryMap
[
mimeType
]
|
|
null
;
switch
(
category
)
{
case
"
txt
"
:
case
"
js
"
:
case
"
json
"
:
case
"
css
"
:
case
"
html
"
:
case
"
svg
"
:
case
"
xml
"
:
return
true
;
default
:
return
false
;
}
}
async
parseSecurityInfo
(
securityInfo
originAttributes
httpActivity
decodedCertificateCache
)
{
const
info
=
{
state
:
"
insecure
"
}
;
if
(
!
securityInfo
)
{
return
info
;
}
const
wpl
=
Ci
.
nsIWebProgressListener
;
const
NSSErrorsService
=
Cc
[
"
mozilla
.
org
/
nss_errors_service
;
1
"
]
.
getService
(
Ci
.
nsINSSErrorsService
)
;
if
(
!
NSSErrorsService
.
isNSSErrorCode
(
securityInfo
.
errorCode
)
)
{
const
state
=
securityInfo
.
securityState
;
let
uri
=
null
;
if
(
httpActivity
.
channel
?
.
URI
)
{
uri
=
httpActivity
.
channel
.
URI
;
}
if
(
uri
&
&
!
uri
.
schemeIs
(
"
https
"
)
&
&
!
uri
.
schemeIs
(
"
wss
"
)
)
{
info
.
state
=
"
insecure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_SECURE
)
{
info
.
state
=
"
secure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
info
.
state
=
"
weak
"
;
info
.
weaknessReasons
=
this
.
getReasonsForWeakness
(
state
)
;
}
else
if
(
state
&
wpl
.
STATE_IS_INSECURE
)
{
return
info
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Security
state
"
+
state
+
"
has
no
known
STATE_IS_
*
flags
.
"
)
;
return
info
;
}
info
.
cipherSuite
=
securityInfo
.
cipherName
;
info
.
keaGroupName
=
securityInfo
.
keaGroupName
;
info
.
signatureSchemeName
=
securityInfo
.
signatureSchemeName
;
info
.
protocolVersion
=
this
.
formatSecurityProtocol
(
securityInfo
.
protocolVersion
)
;
info
.
cert
=
await
this
.
parseCertificateInfo
(
securityInfo
.
serverCert
decodedCertificateCache
)
;
info
.
certificateTransparency
=
securityInfo
.
certificateTransparencyStatus
;
if
(
httpActivity
.
hostname
)
{
const
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
const
pkps
=
Cc
[
"
mozilla
.
org
/
security
/
publickeypinningservice
;
1
"
]
.
getService
(
Ci
.
nsIPublicKeyPinningService
)
;
if
(
!
uri
)
{
const
host
=
httpActivity
.
hostname
;
uri
=
Services
.
io
.
newURI
(
"
https
:
/
/
"
+
host
)
;
}
info
.
hsts
=
sss
.
isSecureURI
(
uri
originAttributes
)
;
info
.
hpkp
=
pkps
.
hostHasPins
(
uri
)
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Could
not
get
HSTS
/
HPKP
status
as
hostname
is
not
available
.
"
)
;
info
.
hsts
=
false
;
info
.
hpkp
=
false
;
}
}
else
{
info
.
state
=
"
broken
"
;
info
.
errorMessage
=
securityInfo
.
errorCodeString
;
}
return
info
;
}
async
parseCertificateInfo
(
cert
decodedCertificateCache
)
{
function
getDNComponent
(
dn
componentType
)
{
for
(
const
[
type
value
]
of
dn
.
entries
)
{
if
(
type
=
=
componentType
)
{
return
value
;
}
}
return
undefined
;
}
const
info
=
{
}
;
if
(
cert
)
{
const
certHash
=
cert
.
sha256Fingerprint
;
let
parsedCert
=
decodedCertificateCache
.
get
(
certHash
)
;
if
(
!
parsedCert
)
{
parsedCert
=
await
certDecoder
.
parse
(
certDecoder
.
pemToDER
(
cert
.
getBase64DERString
(
)
)
)
;
decodedCertificateCache
.
set
(
certHash
parsedCert
)
;
}
info
.
subject
=
{
commonName
:
getDNComponent
(
parsedCert
.
subject
"
Common
Name
"
)
organization
:
getDNComponent
(
parsedCert
.
subject
"
Organization
"
)
organizationalUnit
:
getDNComponent
(
parsedCert
.
subject
"
Organizational
Unit
"
)
}
;
info
.
issuer
=
{
commonName
:
getDNComponent
(
parsedCert
.
issuer
"
Common
Name
"
)
organization
:
getDNComponent
(
parsedCert
.
issuer
"
Organization
"
)
organizationUnit
:
getDNComponent
(
parsedCert
.
issuer
"
Organizational
Unit
"
)
}
;
info
.
validity
=
{
start
:
parsedCert
.
notBeforeUTC
end
:
parsedCert
.
notAfterUTC
}
;
info
.
fingerprint
=
{
sha1
:
parsedCert
.
fingerprint
.
sha1
sha256
:
parsedCert
.
fingerprint
.
sha256
}
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseCertificateInfo
"
"
Secure
connection
established
without
certificate
.
"
)
;
}
return
info
;
}
formatSecurityProtocol
(
version
)
{
switch
(
version
)
{
case
Ci
.
nsITransportSecurityInfo
.
TLS_VERSION_1
:
return
"
TLSv1
"
;
case
Ci
.
nsITransportSecurityInfo
.
TLS_VERSION_1_1
:
return
"
TLSv1
.
1
"
;
case
Ci
.
nsITransportSecurityInfo
.
TLS_VERSION_1_2
:
return
"
TLSv1
.
2
"
;
case
Ci
.
nsITransportSecurityInfo
.
TLS_VERSION_1_3
:
return
"
TLSv1
.
3
"
;
default
:
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
formatSecurityProtocol
"
"
protocolVersion
"
+
version
+
"
is
unknown
.
"
)
;
return
"
Unknown
"
;
}
}
getReasonsForWeakness
(
state
)
{
const
wpl
=
Ci
.
nsIWebProgressListener
;
const
reasons
=
[
]
;
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
const
isCipher
=
state
&
wpl
.
STATE_USES_WEAK_CRYPTO
;
if
(
isCipher
)
{
reasons
.
push
(
"
cipher
"
)
;
}
if
(
!
isCipher
)
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
getReasonsForWeakness
"
"
STATE_IS_BROKEN
without
a
known
reason
.
Full
state
was
:
"
+
state
)
;
}
}
return
reasons
;
}
parseQueryString
(
queryString
)
{
if
(
!
queryString
)
{
return
null
;
}
const
paramsArray
=
queryString
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
const
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
0
]
)
)
:
"
"
value
:
param
[
1
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
1
]
)
)
:
"
"
}
;
}
)
;
return
paramsArray
;
}
}
;
for
(
const
prop
of
Object
.
getOwnPropertyNames
(
NetworkHelper
)
)
{
exports
[
prop
]
=
NetworkHelper
[
prop
]
;
}
