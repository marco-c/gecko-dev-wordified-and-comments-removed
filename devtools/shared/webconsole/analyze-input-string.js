"
use
strict
"
;
const
STATE_NORMAL
=
Symbol
(
"
STATE_NORMAL
"
)
;
const
STATE_QUOTE
=
Symbol
(
"
STATE_QUOTE
"
)
;
const
STATE_DQUOTE
=
Symbol
(
"
STATE_DQUOTE
"
)
;
const
STATE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_TEMPLATE_LITERAL
"
)
;
const
STATE_ESCAPE_QUOTE
=
Symbol
(
"
STATE_ESCAPE_QUOTE
"
)
;
const
STATE_ESCAPE_DQUOTE
=
Symbol
(
"
STATE_ESCAPE_DQUOTE
"
)
;
const
STATE_ESCAPE_TEMPLATE_LITERAL
=
Symbol
(
"
STATE_ESCAPE_TEMPLATE_LITERAL
"
)
;
const
STATE_SLASH
=
Symbol
(
"
STATE_SLASH
"
)
;
const
STATE_INLINE_COMMENT
=
Symbol
(
"
STATE_INLINE_COMMENT
"
)
;
const
STATE_MULTILINE_COMMENT
=
Symbol
(
"
STATE_MULTILINE_COMMENT
"
)
;
const
STATE_MULTILINE_COMMENT_CLOSE
=
Symbol
(
"
STATE_MULTILINE_COMMENT_CLOSE
"
)
;
const
STATE_QUESTION_MARK
=
Symbol
(
"
STATE_QUESTION_MARK
"
)
;
const
OPEN_BODY
=
"
{
[
(
"
.
split
(
"
"
)
;
const
CLOSE_BODY
=
"
}
]
)
"
.
split
(
"
"
)
;
const
OPEN_CLOSE_BODY
=
{
"
{
"
:
"
}
"
"
[
"
:
"
]
"
"
(
"
:
"
)
"
}
;
const
NO_AUTOCOMPLETE_PREFIXES
=
[
"
var
"
"
const
"
"
let
"
"
function
"
"
class
"
]
;
const
OPERATOR_CHARS_SET
=
new
Set
(
"
;
:
=
<
>
+
-
*
%
|
&
^
~
!
"
.
split
(
"
"
)
)
;
exports
.
analyzeInputString
=
function
(
str
timeout
=
2500
)
{
const
bodyStack
=
[
]
;
let
state
=
STATE_NORMAL
;
let
previousNonWhitespaceChar
;
let
lastStatement
=
"
"
;
let
currentIndex
=
-
1
;
let
dotIndex
;
let
pendingWhitespaceChars
=
"
"
;
const
startingTime
=
Date
.
now
(
)
;
for
(
const
c
of
str
)
{
if
(
Date
.
now
(
)
-
startingTime
>
timeout
)
{
return
{
err
:
"
timeout
"
}
;
}
currentIndex
+
=
1
;
let
resetLastStatement
=
false
;
const
isWhitespaceChar
=
c
.
trim
(
)
=
=
=
"
"
;
switch
(
state
)
{
case
STATE_SLASH
:
if
(
c
=
=
"
/
"
)
{
state
=
STATE_INLINE_COMMENT
;
break
;
}
else
if
(
c
=
=
"
*
"
)
{
state
=
STATE_MULTILINE_COMMENT
;
break
;
}
else
{
lastStatement
=
"
"
;
state
=
STATE_NORMAL
;
}
case
STATE_NORMAL
:
if
(
lastStatement
.
endsWith
(
"
?
.
"
)
&
&
/
\
d
/
.
test
(
c
)
)
{
lastStatement
=
"
"
;
}
if
(
c
=
=
=
"
.
"
)
{
dotIndex
=
currentIndex
;
}
if
(
pendingWhitespaceChars
&
&
!
isWhitespaceChar
)
{
if
(
c
=
=
=
"
[
"
|
|
c
=
=
=
"
.
"
|
|
c
=
=
=
"
?
"
)
{
lastStatement
=
lastStatement
+
pendingWhitespaceChars
;
}
else
{
lastStatement
=
"
"
;
}
pendingWhitespaceChars
=
"
"
;
}
if
(
c
=
=
'
"
'
)
{
state
=
STATE_DQUOTE
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_QUOTE
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_TEMPLATE_LITERAL
;
}
else
if
(
c
=
=
"
/
"
)
{
state
=
STATE_SLASH
;
}
else
if
(
c
=
=
"
?
"
)
{
state
=
STATE_QUESTION_MARK
;
}
else
if
(
OPERATOR_CHARS_SET
.
has
(
c
)
)
{
resetLastStatement
=
true
;
}
else
if
(
isWhitespaceChar
)
{
if
(
previousNonWhitespaceChar
!
=
=
"
.
"
&
&
previousNonWhitespaceChar
!
=
=
"
[
"
&
&
!
NO_AUTOCOMPLETE_PREFIXES
.
includes
(
lastStatement
)
)
{
pendingWhitespaceChars
+
=
c
;
continue
;
}
}
else
if
(
OPEN_BODY
.
includes
(
c
)
)
{
bodyStack
.
push
(
{
token
:
c
lastStatement
index
:
currentIndex
}
)
;
resetLastStatement
=
true
;
}
else
if
(
CLOSE_BODY
.
includes
(
c
)
)
{
const
last
=
bodyStack
.
pop
(
)
;
if
(
!
last
|
|
OPEN_CLOSE_BODY
[
last
.
token
]
!
=
c
)
{
return
{
err
:
"
syntax
error
"
}
;
}
if
(
c
=
=
"
}
"
)
{
resetLastStatement
=
true
;
}
else
{
lastStatement
=
last
.
lastStatement
;
}
}
break
;
case
STATE_ESCAPE_QUOTE
:
state
=
STATE_QUOTE
;
break
;
case
STATE_ESCAPE_DQUOTE
:
state
=
STATE_DQUOTE
;
break
;
case
STATE_ESCAPE_TEMPLATE_LITERAL
:
state
=
STATE_TEMPLATE_LITERAL
;
break
;
case
STATE_DQUOTE
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_DQUOTE
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
'
"
'
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_TEMPLATE_LITERAL
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_TEMPLATE_LITERAL
;
}
else
if
(
c
=
=
"
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_QUOTE
:
if
(
c
=
=
"
\
\
"
)
{
state
=
STATE_ESCAPE_QUOTE
;
}
else
if
(
c
=
=
"
\
n
"
)
{
return
{
err
:
"
unterminated
string
literal
"
}
;
}
else
if
(
c
=
=
"
'
"
)
{
state
=
STATE_NORMAL
;
}
break
;
case
STATE_INLINE_COMMENT
:
if
(
c
=
=
=
"
\
n
"
)
{
state
=
STATE_NORMAL
;
resetLastStatement
=
true
;
}
break
;
case
STATE_MULTILINE_COMMENT
:
if
(
c
=
=
=
"
*
"
)
{
state
=
STATE_MULTILINE_COMMENT_CLOSE
;
}
break
;
case
STATE_MULTILINE_COMMENT_CLOSE
:
if
(
c
=
=
=
"
/
"
)
{
state
=
STATE_NORMAL
;
resetLastStatement
=
true
;
}
else
{
state
=
STATE_MULTILINE_COMMENT
;
}
break
;
case
STATE_QUESTION_MARK
:
state
=
STATE_NORMAL
;
if
(
c
=
=
=
"
?
"
)
{
resetLastStatement
=
true
;
}
else
if
(
c
!
=
=
"
.
"
)
{
lastStatement
=
"
"
;
}
else
{
dotIndex
=
currentIndex
;
}
break
;
}
if
(
!
isWhitespaceChar
)
{
previousNonWhitespaceChar
=
c
;
}
if
(
resetLastStatement
)
{
lastStatement
=
"
"
;
}
else
{
lastStatement
=
lastStatement
+
c
;
}
bodyStack
.
forEach
(
stack
=
>
{
if
(
stack
.
token
!
=
=
"
}
"
)
{
stack
.
lastStatement
=
stack
.
lastStatement
+
c
;
}
}
)
;
}
let
isElementAccess
=
false
;
let
lastOpeningBracketIndex
=
-
1
;
if
(
bodyStack
.
length
=
=
=
1
&
&
bodyStack
[
0
]
.
token
=
=
=
"
[
"
)
{
lastStatement
=
bodyStack
[
0
]
.
lastStatement
;
lastOpeningBracketIndex
=
bodyStack
[
0
]
.
index
;
isElementAccess
=
true
;
if
(
state
=
=
=
STATE_DQUOTE
|
|
state
=
=
=
STATE_QUOTE
|
|
state
=
=
=
STATE_TEMPLATE_LITERAL
|
|
state
=
=
=
STATE_ESCAPE_QUOTE
|
|
state
=
=
=
STATE_ESCAPE_DQUOTE
|
|
state
=
=
=
STATE_ESCAPE_TEMPLATE_LITERAL
)
{
state
=
STATE_NORMAL
;
}
}
else
if
(
pendingWhitespaceChars
)
{
lastStatement
=
"
"
;
}
const
lastCompletionCharIndex
=
isElementAccess
?
lastOpeningBracketIndex
:
dotIndex
;
const
stringBeforeLastCompletionChar
=
str
.
slice
(
0
lastCompletionCharIndex
)
;
const
isPropertyAccess
=
lastCompletionCharIndex
&
&
lastCompletionCharIndex
>
0
;
const
optionalElementAccessRegex
=
/
\
?
\
.
\
s
*
/
;
const
isOptionalAccess
=
isElementAccess
?
optionalElementAccessRegex
.
test
(
stringBeforeLastCompletionChar
)
:
isPropertyAccess
&
&
str
.
slice
(
lastCompletionCharIndex
-
1
lastCompletionCharIndex
+
1
)
=
=
=
"
?
.
"
;
const
matchProp
=
isPropertyAccess
?
str
.
slice
(
lastCompletionCharIndex
+
1
)
.
trimLeft
(
)
:
null
;
const
expressionBeforePropertyAccess
=
isPropertyAccess
?
str
.
slice
(
0
isOptionalAccess
?
stringBeforeLastCompletionChar
.
lastIndexOf
(
"
?
"
)
:
lastCompletionCharIndex
)
:
str
;
let
mainExpression
=
lastStatement
;
if
(
isPropertyAccess
)
{
if
(
isOptionalAccess
)
{
mainExpression
=
mainExpression
.
slice
(
0
mainExpression
.
lastIndexOf
(
"
?
"
)
)
;
}
else
{
mainExpression
=
mainExpression
.
slice
(
0
-
1
*
(
str
.
length
-
lastCompletionCharIndex
)
)
;
}
}
mainExpression
=
mainExpression
.
trim
(
)
;
return
{
state
isElementAccess
isPropertyAccess
expressionBeforePropertyAccess
lastStatement
mainExpression
matchProp
}
;
}
;
exports
.
shouldInputBeAutocompleted
=
function
(
inputAnalysisState
)
{
const
{
err
state
lastStatement
}
=
inputAnalysisState
;
if
(
err
)
{
return
false
;
}
if
(
state
!
=
STATE_NORMAL
)
{
return
false
;
}
if
(
lastStatement
.
trim
(
)
=
=
"
"
)
{
return
false
;
}
if
(
NO_AUTOCOMPLETE_PREFIXES
.
some
(
prefix
=
>
lastStatement
.
startsWith
(
prefix
+
"
"
)
)
)
{
return
false
;
}
return
true
;
}
;
exports
.
shouldInputBeEagerlyEvaluated
=
function
(
{
lastStatement
}
)
{
const
inComputedProperty
=
lastStatement
.
lastIndexOf
(
"
[
"
)
!
=
=
-
1
&
&
lastStatement
.
lastIndexOf
(
"
[
"
)
>
lastStatement
.
lastIndexOf
(
"
]
"
)
;
const
hasPropertyAccess
=
lastStatement
.
includes
(
"
.
"
)
|
|
lastStatement
.
includes
(
"
[
"
)
;
return
hasPropertyAccess
&
&
!
inComputedProperty
;
}
;
