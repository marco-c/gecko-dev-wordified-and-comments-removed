"
use
strict
"
;
const
{
Cc
Ci
Cr
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
STRINGS_URI
=
"
devtools
/
shared
/
locales
/
screenshot
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
const
screenshotDescription
=
L10N
.
getStr
(
"
screenshotDesc
"
)
;
const
screenshotGroupOptions
=
L10N
.
getStr
(
"
screenshotGroupOptions
"
)
;
const
screenshotCommandParams
=
[
{
name
:
"
clipboard
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotClipboardDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotClipboardManual
"
)
}
{
name
:
"
delay
"
type
:
"
number
"
description
:
L10N
.
getStr
(
"
screenshotDelayDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotDelayManual
"
)
}
{
name
:
"
dpr
"
type
:
"
number
"
description
:
L10N
.
getStr
(
"
screenshotDPRDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotDPRManual
"
)
}
{
name
:
"
fullpage
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotFullPageDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFullPageManual
"
)
}
{
name
:
"
selector
"
type
:
"
string
"
description
:
L10N
.
getStr
(
"
inspectNodeDesc
"
)
manual
:
L10N
.
getStr
(
"
inspectNodeManual
"
)
}
{
name
:
"
file
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotFileDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFileManual
"
)
}
{
name
:
"
filename
"
type
:
"
string
"
description
:
L10N
.
getStr
(
"
screenshotFilenameDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFilenameManual
"
)
}
]
;
function
formatHelpField
(
param
)
{
const
padding
=
"
"
.
repeat
(
5
)
;
return
Object
.
entries
(
param
)
.
map
(
(
[
key
value
]
)
=
>
{
if
(
key
=
=
=
"
name
"
)
{
const
name
=
{
padding
}
-
-
{
value
}
;
return
name
;
}
return
{
padding
.
repeat
(
2
)
}
{
key
}
:
{
value
}
;
}
)
.
join
(
"
\
n
"
)
;
}
function
getFormattedHelpData
(
)
{
const
formattedParams
=
screenshotCommandParams
.
map
(
formatHelpField
)
.
join
(
"
\
n
\
n
"
)
;
return
{
screenshotDescription
}
\
n
{
screenshotGroupOptions
}
\
n
\
n
{
formattedParams
}
;
}
function
processScreenshot
(
window
args
=
{
}
value
)
{
if
(
args
.
help
)
{
const
message
=
getFormattedHelpData
(
)
;
return
[
message
]
;
}
simulateCameraShutter
(
window
.
document
)
;
return
saveScreenshot
(
window
args
value
)
;
}
function
simulateCameraShutter
(
document
)
{
const
window
=
document
.
defaultView
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
audio
.
enabled
"
)
)
{
const
audioCamera
=
new
window
.
Audio
(
"
resource
:
/
/
devtools
/
client
/
themes
/
audio
/
shutter
.
wav
"
)
;
audioCamera
.
play
(
)
;
}
}
async
function
saveScreenshot
(
window
args
image
)
{
const
fileNeeded
=
args
.
filename
|
|
!
args
.
clipboard
|
|
args
.
file
;
const
results
=
[
]
;
if
(
args
.
clipboard
)
{
const
result
=
await
saveToClipboard
(
window
image
.
data
)
;
results
.
push
(
result
)
;
}
if
(
fileNeeded
)
{
const
result
=
await
saveToFile
(
window
image
)
;
results
.
push
(
result
)
;
}
return
results
;
}
function
saveToClipboard
(
window
data
)
{
return
new
Promise
(
resolve
=
>
{
try
{
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
data
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE
}
)
;
const
input
=
channel
.
open2
(
)
;
const
loadContext
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
const
callback
=
{
onImageReady
(
container
status
)
{
if
(
!
container
)
{
console
.
error
(
"
imgTools
.
decodeImageAsync
failed
"
)
;
resolve
(
L10N
.
getStr
(
"
screenshotErrorCopying
"
)
)
;
return
;
}
try
{
const
wrapped
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
wrapped
.
data
=
container
;
const
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
trans
.
init
(
loadContext
)
;
trans
.
addDataFlavor
(
channel
.
contentType
)
;
trans
.
setTransferData
(
channel
.
contentType
wrapped
-
1
)
;
Services
.
clipboard
.
setData
(
trans
null
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
resolve
(
L10N
.
getStr
(
"
screenshotCopied
"
)
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
resolve
(
L10N
.
getStr
(
"
screenshotErrorCopying
"
)
)
;
}
}
}
;
const
threadManager
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
const
imgTools
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
;
imgTools
.
decodeImageAsync
(
input
channel
.
contentType
callback
threadManager
.
currentThread
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
resolve
(
L10N
.
getStr
(
"
screenshotErrorCopying
"
)
)
;
}
}
)
;
}
function
DownloadListener
(
win
transfer
)
{
this
.
window
=
win
;
this
.
transfer
=
transfer
;
for
(
const
name
in
transfer
)
{
if
(
name
!
=
"
QueryInterface
"
&
&
name
!
=
"
onStateChange
"
)
{
this
[
name
]
=
(
.
.
.
args
)
=
>
transfer
[
name
]
.
apply
(
transfer
args
)
;
}
}
this
.
_completedDeferred
=
{
}
;
this
.
completed
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_completedDeferred
.
resolve
=
resolve
;
this
.
_completedDeferred
.
reject
=
reject
;
}
)
;
}
DownloadListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
"
nsIWebProgressListener
"
"
nsIWebProgressListener2
"
]
)
getInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt
)
|
|
iid
.
equals
(
Ci
.
nsIAuthPrompt2
)
)
{
const
ww
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
window
-
watcher
;
1
"
]
.
getService
(
Ci
.
nsIPromptFactory
)
;
return
ww
.
getPrompt
(
this
.
window
iid
)
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
onStateChange
:
function
(
webProgress
request
state
status
)
{
if
(
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
&
&
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
)
{
if
(
status
=
=
Cr
.
NS_OK
)
{
this
.
_completedDeferred
.
resolve
(
)
;
}
else
{
this
.
_completedDeferred
.
reject
(
)
;
}
}
this
.
transfer
.
onStateChange
.
apply
(
this
.
transfer
arguments
)
;
}
}
;
async
function
saveToFile
(
window
image
)
{
const
document
=
window
.
document
;
let
filename
=
image
.
filename
;
if
(
!
filename
.
match
(
/
.
png
/
i
)
)
{
filename
+
=
"
.
png
"
;
}
const
downloadsDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
const
downloadsDirExists
=
await
OS
.
File
.
exists
(
downloadsDir
)
;
if
(
downloadsDirExists
)
{
filename
=
OS
.
Path
.
join
(
downloadsDir
filename
)
;
}
const
sourceURI
=
Services
.
io
.
newURI
(
image
.
data
)
;
const
targetFile
=
new
FileUtils
.
File
(
filename
)
;
const
targetFileURI
=
Services
.
io
.
newFileURI
(
targetFile
)
;
const
nsIWBP
=
Ci
.
nsIWebBrowserPersist
;
const
flags
=
nsIWBP
.
PERSIST_FLAGS_REPLACE_EXISTING_FILES
|
nsIWBP
.
PERSIST_FLAGS_FORCE_ALLOW_COOKIES
|
nsIWBP
.
PERSIST_FLAGS_BYPASS_CACHE
|
nsIWBP
.
PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION
;
const
isPrivate
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
document
.
defaultView
)
;
const
persist
=
Cc
[
"
mozilla
.
org
/
embedding
/
browser
/
nsWebBrowserPersist
;
1
"
]
.
createInstance
(
Ci
.
nsIWebBrowserPersist
)
;
persist
.
persistFlags
=
flags
;
const
tr
=
Cc
[
"
mozilla
.
org
/
transfer
;
1
"
]
.
createInstance
(
Ci
.
nsITransfer
)
;
tr
.
init
(
sourceURI
targetFileURI
"
"
null
null
null
persist
isPrivate
)
;
const
listener
=
new
DownloadListener
(
window
tr
)
;
persist
.
progressListener
=
listener
;
persist
.
savePrivacyAwareURI
(
sourceURI
0
document
.
documentURIObject
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSET
null
null
targetFileURI
isPrivate
)
;
try
{
await
listener
.
completed
;
return
L10N
.
getFormatStr
(
"
screenshotSavedToFile
"
filename
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
L10N
.
getFormatStr
(
"
screenshotErrorSavingToFile
"
filename
)
;
}
}
module
.
exports
=
processScreenshot
;
