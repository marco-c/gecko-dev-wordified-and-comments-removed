"
use
strict
"
;
const
{
CC
Ci
Cu
Cc
}
=
require
(
"
chrome
"
)
;
const
ArrayBufferInputStream
=
CC
(
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
"
nsIArrayBufferInputStream
"
)
;
const
BinaryInputStream
=
CC
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
loader
.
lazyServiceGetter
(
this
"
gActivityDistributor
"
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
"
nsIHttpActivityDistributor
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
setTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
function
NetworkThrottleListener
(
queue
)
{
this
.
queue
=
queue
;
this
.
pendingData
=
[
]
;
this
.
pendingException
=
null
;
this
.
offset
=
0
;
this
.
responseStarted
=
false
;
this
.
activities
=
{
}
;
}
NetworkThrottleListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIStreamListener
Ci
.
nsIInterfaceRequestor
Ci
.
nsISupports
]
)
setOriginalListener
(
originalListener
)
{
this
.
originalListener
=
originalListener
;
}
onStartRequest
(
request
context
)
{
this
.
originalListener
.
onStartRequest
(
request
context
)
;
this
.
queue
.
start
(
this
)
;
}
onStopRequest
(
request
context
statusCode
)
{
this
.
pendingData
.
push
(
{
request
context
statusCode
}
)
;
this
.
queue
.
dataAvailable
(
this
)
;
}
onDataAvailable
(
request
context
inputStream
offset
count
)
{
if
(
this
.
pendingException
)
{
throw
this
.
pendingException
;
}
const
bin
=
new
BinaryInputStream
(
inputStream
)
;
const
bytes
=
new
ArrayBuffer
(
count
)
;
bin
.
readArrayBuffer
(
count
bytes
)
;
const
stream
=
new
ArrayBufferInputStream
(
)
;
stream
.
setData
(
bytes
0
count
)
;
this
.
pendingData
.
push
(
{
request
context
stream
count
}
)
;
this
.
queue
.
dataAvailable
(
this
)
;
}
sendSomeData
(
bytesPermitted
)
{
if
(
this
.
pendingData
.
length
=
=
=
0
)
{
return
{
length
:
0
done
:
true
}
;
}
const
{
request
context
stream
count
statusCode
}
=
this
.
pendingData
[
0
]
;
if
(
statusCode
!
=
=
undefined
)
{
this
.
pendingData
.
shift
(
)
;
this
.
originalListener
.
onStopRequest
(
request
context
statusCode
)
;
return
{
length
:
0
done
:
true
}
;
}
if
(
bytesPermitted
>
count
)
{
bytesPermitted
=
count
;
}
try
{
this
.
originalListener
.
onDataAvailable
(
request
context
stream
this
.
offset
bytesPermitted
)
;
}
catch
(
e
)
{
this
.
pendingException
=
e
;
}
let
done
=
false
;
if
(
bytesPermitted
=
=
=
count
)
{
this
.
pendingData
.
shift
(
)
;
done
=
true
;
}
else
{
this
.
pendingData
[
0
]
.
count
-
=
bytesPermitted
;
}
this
.
offset
+
=
bytesPermitted
;
this
.
maybeEmitEvents
(
)
;
return
{
length
:
bytesPermitted
done
}
;
}
pendingCount
(
)
{
return
this
.
pendingData
.
length
;
}
addActivityCallback
(
callback
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
{
let
datum
=
{
callback
httpActivity
channel
activityType
activitySubtype
extraSizeData
extraStringData
}
;
this
.
activities
[
activitySubtype
]
=
datum
;
if
(
activitySubtype
=
=
=
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_COMPLETE
)
{
this
.
totalSize
=
extraSizeData
;
}
this
.
maybeEmitEvents
(
)
;
}
responseStart
(
)
{
this
.
responseStarted
=
true
;
this
.
maybeEmitEvents
(
)
;
}
maybeEmitEvents
(
)
{
if
(
this
.
responseStarted
)
{
this
.
maybeEmit
(
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_START
)
;
this
.
maybeEmit
(
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_HEADER
)
;
}
if
(
this
.
totalSize
!
=
=
undefined
&
&
this
.
offset
>
=
this
.
totalSize
)
{
this
.
maybeEmit
(
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_COMPLETE
)
;
this
.
maybeEmit
(
gActivityDistributor
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
)
;
}
}
maybeEmit
(
code
)
{
if
(
this
.
activities
[
code
]
!
=
=
undefined
)
{
let
{
callback
httpActivity
channel
activityType
activitySubtype
extraSizeData
extraStringData
}
=
this
.
activities
[
code
]
;
let
now
=
Date
.
now
(
)
*
1000
;
callback
(
httpActivity
channel
activityType
activitySubtype
now
extraSizeData
extraStringData
)
;
this
.
activities
[
code
]
=
undefined
;
}
}
}
;
function
NetworkThrottleQueue
(
meanBPS
maxBPS
latencyMean
latencyMax
)
{
this
.
meanBPS
=
meanBPS
;
this
.
maxBPS
=
maxBPS
;
this
.
latencyMean
=
latencyMean
;
this
.
latencyMax
=
latencyMax
;
this
.
pendingRequests
=
new
Set
(
)
;
this
.
downloadQueue
=
[
]
;
this
.
previousReads
=
[
]
;
this
.
pumping
=
false
;
}
NetworkThrottleQueue
.
prototype
=
{
random
(
mean
max
)
{
return
mean
-
(
max
-
mean
)
+
Math
.
floor
(
2
*
(
max
-
mean
)
*
Math
.
random
(
)
)
;
}
allowDataFrom
(
throttleListener
)
{
throttleListener
.
responseStart
(
)
;
this
.
pendingRequests
.
delete
(
throttleListener
)
;
const
count
=
throttleListener
.
pendingCount
(
)
;
for
(
let
i
=
0
;
i
<
count
;
+
+
i
)
{
this
.
downloadQueue
.
push
(
throttleListener
)
;
}
this
.
pump
(
)
;
}
start
(
throttleListener
)
{
this
.
pendingRequests
.
add
(
throttleListener
)
;
let
delay
=
this
.
random
(
this
.
latencyMean
this
.
latencyMax
)
;
if
(
delay
>
0
)
{
setTimeout
(
(
)
=
>
this
.
allowDataFrom
(
throttleListener
)
delay
)
;
}
else
{
this
.
allowDataFrom
(
throttleListener
)
;
}
}
dataAvailable
(
throttleListener
)
{
if
(
!
this
.
pendingRequests
.
has
(
throttleListener
)
)
{
this
.
downloadQueue
.
push
(
throttleListener
)
;
this
.
pump
(
)
;
}
}
pump
(
)
{
if
(
this
.
pumping
)
{
return
;
}
this
.
pumping
=
true
;
const
now
=
Date
.
now
(
)
;
const
oneSecondAgo
=
now
-
1000
;
while
(
this
.
previousReads
.
length
&
&
this
.
previousReads
[
0
]
.
when
<
oneSecondAgo
)
{
this
.
previousReads
.
shift
(
)
;
}
const
totalBytes
=
this
.
previousReads
.
reduce
(
(
sum
elt
)
=
>
{
return
sum
+
elt
.
numBytes
;
}
0
)
;
let
thisSliceBytes
=
this
.
random
(
this
.
meanBPS
this
.
maxBPS
)
;
if
(
totalBytes
<
thisSliceBytes
)
{
thisSliceBytes
-
=
totalBytes
;
let
readThisTime
=
0
;
while
(
thisSliceBytes
>
0
&
&
this
.
downloadQueue
.
length
)
{
let
{
length
done
}
=
this
.
downloadQueue
[
0
]
.
sendSomeData
(
thisSliceBytes
)
;
thisSliceBytes
-
=
length
;
readThisTime
+
=
length
;
if
(
done
)
{
this
.
downloadQueue
.
shift
(
)
;
}
}
this
.
previousReads
.
push
(
{
when
:
now
numBytes
:
readThisTime
}
)
;
}
if
(
this
.
downloadQueue
.
length
)
{
const
when
=
this
.
previousReads
[
0
]
.
when
+
1000
;
setTimeout
(
this
.
pump
.
bind
(
this
)
when
-
now
)
;
}
this
.
pumping
=
false
;
}
}
;
function
NetworkThrottleManager
(
{
latencyMean
latencyMax
downloadBPSMean
downloadBPSMax
uploadBPSMean
uploadBPSMax
}
)
{
if
(
downloadBPSMax
<
=
0
&
&
downloadBPSMean
<
=
0
)
{
this
.
downloadQueue
=
null
;
}
else
{
this
.
downloadQueue
=
new
NetworkThrottleQueue
(
downloadBPSMean
downloadBPSMax
latencyMean
latencyMax
)
;
}
if
(
uploadBPSMax
<
=
0
&
&
uploadBPSMean
<
=
0
)
{
this
.
uploadQueue
=
null
;
}
else
{
this
.
uploadQueue
=
Cc
[
"
mozilla
.
org
/
network
/
throttlequeue
;
1
"
]
.
createInstance
(
Ci
.
nsIInputChannelThrottleQueue
)
;
this
.
uploadQueue
.
init
(
uploadBPSMean
uploadBPSMax
)
;
}
}
exports
.
NetworkThrottleManager
=
NetworkThrottleManager
;
NetworkThrottleManager
.
prototype
=
{
manage
(
channel
)
{
if
(
this
.
downloadQueue
)
{
let
listener
=
new
NetworkThrottleListener
(
this
.
downloadQueue
)
;
let
originalListener
=
channel
.
setNewListener
(
listener
)
;
listener
.
setOriginalListener
(
originalListener
)
;
return
listener
;
}
return
null
;
}
manageUpload
(
channel
)
{
if
(
this
.
uploadQueue
)
{
channel
=
channel
.
QueryInterface
(
Ci
.
nsIThrottledInputChannel
)
;
channel
.
throttleQueue
=
this
.
uploadQueue
;
}
}
}
;
