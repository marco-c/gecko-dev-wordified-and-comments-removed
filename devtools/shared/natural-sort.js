"
use
strict
"
;
const
tokenizeNumbersRx
=
/
(
^
(
[
+
\
-
]
?
\
d
+
(
?
:
\
.
\
d
*
)
?
(
?
:
[
eE
]
[
+
\
-
]
?
\
d
+
)
?
(
?
=
\
D
|
\
s
|
)
)
|
^
0x
[
\
da
-
fA
-
F
]
+
|
\
d
+
)
/
g
;
const
dateRx
=
/
(
^
(
[
\
w
]
+
?
[
\
w
]
+
)
?
[
\
w
]
+
?
[
\
w
]
+
\
d
+
:
\
d
+
(
:
\
d
+
)
?
[
\
w
]
?
|
^
\
d
{
1
4
}
[
\
/
\
-
]
\
d
{
1
4
}
[
\
/
\
-
]
\
d
{
1
4
}
|
^
\
w
+
\
w
+
\
d
+
\
d
{
4
}
)
/
;
const
hexRx
=
/
^
0x
[
0
-
9a
-
f
]
+
/
i
;
const
startsWithNullRx
=
/
^
\
0
/
;
const
endsWithNullRx
=
/
\
0
/
;
const
whitespaceRx
=
/
\
s
+
/
g
;
const
startsWithZeroRx
=
/
^
0
/
;
loader
.
lazyGetter
(
this
"
standardSessionString
"
(
)
=
>
{
const
l10n
=
new
Localization
(
[
"
devtools
/
client
/
storage
.
ftl
"
]
true
)
;
return
l10n
.
formatValueSync
(
"
storage
-
expires
-
session
"
)
;
}
)
;
function
naturalSort
(
a
=
"
"
b
=
"
"
insensitive
=
false
)
{
let
sessionString
=
standardSessionString
;
a
=
(
a
+
"
"
)
.
trim
(
)
;
b
=
(
b
+
"
"
)
.
trim
(
)
;
if
(
insensitive
)
{
a
=
a
.
toLowerCase
(
)
;
b
=
b
.
toLowerCase
(
)
;
sessionString
=
standardSessionString
.
toLowerCase
(
)
;
}
const
aChunks
=
a
.
replace
(
tokenizeNumbersRx
"
\
0
1
\
0
"
)
.
replace
(
startsWithNullRx
"
"
)
.
replace
(
endsWithNullRx
"
"
)
.
split
(
"
\
0
"
)
;
const
bChunks
=
b
.
replace
(
tokenizeNumbersRx
"
\
0
1
\
0
"
)
.
replace
(
startsWithNullRx
"
"
)
.
replace
(
endsWithNullRx
"
"
)
.
split
(
"
\
0
"
)
;
const
aHexOrDate
=
parseInt
(
a
.
match
(
hexRx
)
16
)
|
|
(
aChunks
.
length
!
=
=
1
&
&
Date
.
parse
(
a
)
)
;
const
bHexOrDate
=
parseInt
(
b
.
match
(
hexRx
)
16
)
|
|
(
aHexOrDate
&
&
b
.
match
(
dateRx
)
&
&
Date
.
parse
(
b
)
)
|
|
null
;
if
(
(
aHexOrDate
|
|
bHexOrDate
)
&
&
(
a
=
=
=
sessionString
|
|
b
=
=
=
sessionString
)
)
{
if
(
a
=
=
=
sessionString
)
{
return
-
1
;
}
else
if
(
b
=
=
=
sessionString
)
{
return
1
;
}
}
if
(
bHexOrDate
)
{
if
(
aHexOrDate
<
bHexOrDate
)
{
return
-
1
;
}
else
if
(
aHexOrDate
>
bHexOrDate
)
{
return
1
;
}
}
const
aChunksLength
=
aChunks
.
length
;
const
bChunksLength
=
bChunks
.
length
;
const
maxLen
=
Math
.
max
(
aChunksLength
bChunksLength
)
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
const
aChunk
=
normalizeChunk
(
aChunks
[
i
]
|
|
"
"
aChunksLength
)
;
const
bChunk
=
normalizeChunk
(
bChunks
[
i
]
|
|
"
"
bChunksLength
)
;
if
(
isNaN
(
aChunk
)
!
=
=
isNaN
(
bChunk
)
)
{
return
isNaN
(
aChunk
)
?
1
:
-
1
;
}
if
(
/
[
^
\
x00
-
\
x80
]
/
.
test
(
aChunk
+
bChunk
)
&
&
aChunk
.
localeCompare
)
{
const
comp
=
aChunk
.
localeCompare
(
bChunk
)
;
return
comp
/
Math
.
abs
(
comp
)
;
}
if
(
aChunk
<
bChunk
)
{
return
-
1
;
}
else
if
(
aChunk
>
bChunk
)
{
return
1
;
}
}
return
null
;
}
const
normalizeChunk
=
function
(
str
length
)
{
return
(
(
(
!
str
.
match
(
startsWithZeroRx
)
|
|
length
=
=
1
)
&
&
parseFloat
(
str
)
)
|
|
str
.
replace
(
whitespaceRx
"
"
)
.
trim
(
)
|
|
0
)
;
}
;
exports
.
naturalSortCaseSensitive
=
function
naturalSortCaseSensitive
(
a
b
)
{
return
naturalSort
(
a
b
false
)
;
}
;
exports
.
naturalSortCaseInsensitive
=
function
naturalSortCaseInsensitive
(
a
b
)
{
return
naturalSort
(
a
b
true
)
;
}
;
