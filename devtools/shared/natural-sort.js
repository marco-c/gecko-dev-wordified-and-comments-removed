"
use
strict
"
;
const
tokenizeNumbersRx
=
/
(
^
(
[
+
\
-
]
?
\
d
+
(
?
:
\
.
\
d
*
)
?
(
?
:
[
eE
]
[
+
\
-
]
?
\
d
+
)
?
(
?
=
\
D
|
\
s
|
)
)
|
^
0x
[
\
da
-
fA
-
F
]
+
|
\
d
+
)
/
g
;
const
hexRx
=
/
^
0x
[
0
-
9a
-
f
]
+
/
i
;
const
startsWithNullRx
=
/
^
\
0
/
;
const
endsWithNullRx
=
/
\
0
/
;
const
whitespaceRx
=
/
\
s
+
/
g
;
const
startsWithZeroRx
=
/
^
0
/
;
const
versionRx
=
/
^
(
[
\
w
-
]
+
-
)
?
\
d
+
\
.
\
d
+
\
.
\
d
+
/
;
const
numericDateRx
=
/
^
\
d
+
[
-
/
]
\
d
+
[
-
/
]
\
d
+
/
;
const
dateKeywords
=
[
"
mon
"
"
tues
"
"
wed
"
"
thur
"
"
fri
"
"
sat
"
"
sun
"
"
jan
"
"
feb
"
"
mar
"
"
apr
"
"
may
"
"
jun
"
"
jul
"
"
aug
"
"
sep
"
"
oct
"
"
nov
"
"
dec
"
]
;
function
tryParseDate
(
str
)
{
const
lowerCaseStr
=
str
.
toLowerCase
(
)
;
return
(
!
versionRx
.
test
(
str
)
&
&
(
numericDateRx
.
test
(
str
)
|
|
dateKeywords
.
some
(
s
=
>
lowerCaseStr
.
includes
(
s
)
)
)
&
&
Date
.
parse
(
str
)
)
;
}
function
naturalSort
(
a
=
"
"
b
=
"
"
sessionString
insensitive
=
false
)
{
a
=
(
a
+
"
"
)
.
trim
(
)
;
b
=
(
b
+
"
"
)
.
trim
(
)
;
if
(
insensitive
)
{
a
=
a
.
toLowerCase
(
)
;
b
=
b
.
toLowerCase
(
)
;
sessionString
=
sessionString
.
toLowerCase
(
)
;
}
const
aChunks
=
a
.
replace
(
tokenizeNumbersRx
"
\
0
1
\
0
"
)
.
replace
(
startsWithNullRx
"
"
)
.
replace
(
endsWithNullRx
"
"
)
.
split
(
"
\
0
"
)
;
const
bChunks
=
b
.
replace
(
tokenizeNumbersRx
"
\
0
1
\
0
"
)
.
replace
(
startsWithNullRx
"
"
)
.
replace
(
endsWithNullRx
"
"
)
.
split
(
"
\
0
"
)
;
const
aHexOrDate
=
parseInt
(
a
.
match
(
hexRx
)
16
)
|
|
tryParseDate
(
a
)
;
const
bHexOrDate
=
parseInt
(
b
.
match
(
hexRx
)
16
)
|
|
tryParseDate
(
b
)
;
if
(
(
aHexOrDate
|
|
bHexOrDate
)
&
&
(
a
=
=
=
sessionString
|
|
b
=
=
=
sessionString
)
)
{
if
(
a
=
=
=
sessionString
)
{
return
-
1
;
}
else
if
(
b
=
=
=
sessionString
)
{
return
1
;
}
}
if
(
aHexOrDate
&
&
bHexOrDate
)
{
if
(
aHexOrDate
<
bHexOrDate
)
{
return
-
1
;
}
else
if
(
aHexOrDate
>
bHexOrDate
)
{
return
1
;
}
return
0
;
}
const
aChunksLength
=
aChunks
.
length
;
const
bChunksLength
=
bChunks
.
length
;
const
maxLen
=
Math
.
max
(
aChunksLength
bChunksLength
)
;
for
(
let
i
=
0
;
i
<
maxLen
;
i
+
+
)
{
const
aChunk
=
normalizeChunk
(
aChunks
[
i
]
|
|
"
"
aChunksLength
)
;
const
bChunk
=
normalizeChunk
(
bChunks
[
i
]
|
|
"
"
bChunksLength
)
;
if
(
isNaN
(
aChunk
)
!
=
=
isNaN
(
bChunk
)
)
{
return
isNaN
(
aChunk
)
?
1
:
-
1
;
}
if
(
/
[
^
\
x00
-
\
x80
]
/
.
test
(
aChunk
+
bChunk
)
&
&
aChunk
.
localeCompare
)
{
const
comp
=
aChunk
.
localeCompare
(
bChunk
)
;
return
comp
/
Math
.
abs
(
comp
)
;
}
if
(
aChunk
<
bChunk
)
{
return
-
1
;
}
else
if
(
aChunk
>
bChunk
)
{
return
1
;
}
}
return
null
;
}
const
normalizeChunk
=
function
(
str
length
)
{
return
(
(
(
!
str
.
match
(
startsWithZeroRx
)
|
|
length
=
=
1
)
&
&
parseFloat
(
str
)
)
|
|
str
.
replace
(
whitespaceRx
"
"
)
.
trim
(
)
|
|
0
)
;
}
;
exports
.
naturalSortCaseSensitive
=
function
naturalSortCaseSensitive
(
a
b
sessionString
)
{
return
naturalSort
(
a
b
sessionString
false
)
;
}
;
exports
.
naturalSortCaseInsensitive
=
function
naturalSortCaseInsensitive
(
a
b
sessionString
)
{
return
naturalSort
(
a
b
sessionString
true
)
;
}
;
