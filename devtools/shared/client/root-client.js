"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
arg
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
function
RootClient
(
client
greeting
)
{
this
.
_client
=
client
;
this
.
actor
=
greeting
.
from
;
this
.
applicationType
=
greeting
.
applicationType
;
this
.
traits
=
greeting
.
traits
;
}
exports
.
RootClient
=
RootClient
;
RootClient
.
prototype
=
{
constructor
:
RootClient
getRoot
:
DebuggerClient
.
requester
(
{
type
:
"
getRoot
"
}
)
listTabs
:
DebuggerClient
.
requester
(
{
type
:
"
listTabs
"
options
:
arg
(
0
)
}
)
listAddons
:
DebuggerClient
.
requester
(
{
type
:
"
listAddons
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
)
listServiceWorkerRegistrations
:
DebuggerClient
.
requester
(
{
type
:
"
listServiceWorkerRegistrations
"
}
)
listProcesses
:
DebuggerClient
.
requester
(
{
type
:
"
listProcesses
"
}
)
listAllWorkers
:
async
function
(
)
{
let
result
=
{
service
:
[
]
shared
:
[
]
other
:
[
]
}
;
try
{
let
registrations
=
[
]
;
let
workers
=
[
]
;
(
{
registrations
}
=
await
this
.
listServiceWorkerRegistrations
(
)
)
;
(
{
workers
}
=
await
this
.
listWorkers
(
)
)
;
let
{
processes
}
=
await
this
.
listProcesses
(
)
;
for
(
let
process
of
processes
)
{
if
(
process
.
parent
)
{
continue
;
}
let
{
form
}
=
await
this
.
_client
.
getProcess
(
process
.
id
)
;
let
processActor
=
form
.
actor
;
let
response
=
await
this
.
_client
.
request
(
{
to
:
processActor
type
:
"
listWorkers
"
}
)
;
workers
=
workers
.
concat
(
response
.
workers
)
;
}
registrations
.
forEach
(
form
=
>
{
result
.
service
.
push
(
{
name
:
form
.
url
url
:
form
.
url
scope
:
form
.
scope
fetch
:
form
.
fetch
registrationActor
:
form
.
actor
active
:
form
.
active
}
)
;
}
)
;
workers
.
forEach
(
form
=
>
{
let
worker
=
{
name
:
form
.
url
url
:
form
.
url
workerActor
:
form
.
actor
}
;
switch
(
form
.
type
)
{
case
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
:
let
registration
=
result
.
service
.
find
(
r
=
>
r
.
scope
=
=
=
form
.
scope
)
;
if
(
registration
)
{
if
(
!
registration
.
url
)
{
registration
.
name
=
registration
.
url
=
form
.
url
;
}
registration
.
workerActor
=
form
.
actor
;
}
else
{
worker
.
fetch
=
form
.
fetch
;
worker
.
scope
=
form
.
scope
;
worker
.
active
=
false
;
result
.
service
.
push
(
worker
)
;
}
break
;
case
Ci
.
nsIWorkerDebugger
.
TYPE_SHARED
:
result
.
shared
.
push
(
worker
)
;
break
;
default
:
result
.
other
.
push
(
worker
)
;
}
}
)
;
}
catch
(
e
)
{
}
return
result
;
}
getTab
:
function
(
filter
)
{
let
packet
=
{
to
:
this
.
actor
type
:
"
getTab
"
}
;
if
(
filter
)
{
if
(
typeof
(
filter
.
outerWindowID
)
=
=
"
number
"
)
{
packet
.
outerWindowID
=
filter
.
outerWindowID
;
}
else
if
(
typeof
(
filter
.
tabId
)
=
=
"
number
"
)
{
packet
.
tabId
=
filter
.
tabId
;
}
else
if
(
"
tab
"
in
filter
)
{
let
browser
=
filter
.
tab
.
linkedBrowser
;
if
(
browser
.
frameLoader
.
tabParent
)
{
packet
.
tabId
=
browser
.
frameLoader
.
tabParent
.
tabId
;
}
else
if
(
browser
.
outerWindowID
)
{
packet
.
outerWindowID
=
browser
.
outerWindowID
;
}
else
{
let
windowUtils
=
browser
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
packet
.
outerWindowID
=
windowUtils
.
outerWindowID
;
}
}
else
{
throw
new
Error
(
"
Unsupported
argument
given
to
getTab
request
"
)
;
}
}
return
this
.
request
(
packet
)
;
}
getWindow
:
function
(
{
outerWindowID
}
)
{
if
(
!
outerWindowID
)
{
throw
new
Error
(
"
Must
specify
outerWindowID
"
)
;
}
let
packet
=
{
to
:
this
.
actor
type
:
"
getWindow
"
outerWindowID
}
;
return
this
.
request
(
packet
)
;
}
protocolDescription
:
DebuggerClient
.
requester
(
{
type
:
"
protocolDescription
"
}
)
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
}
;
module
.
exports
=
RootClient
;
