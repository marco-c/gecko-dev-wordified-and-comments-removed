"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
const
promise
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
deprecated
-
sync
-
thenables
.
js
"
{
}
)
.
Promise
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleClient
"
"
devtools
/
shared
/
webconsole
/
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerSocket
"
"
devtools
/
shared
/
security
/
socket
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Authentication
"
"
devtools
/
shared
/
security
/
auth
"
)
;
const
noop
=
(
)
=
>
{
}
;
function
eventSource
(
proto
)
{
proto
.
addListener
=
function
(
name
listener
)
{
if
(
typeof
listener
!
=
"
function
"
)
{
throw
TypeError
(
"
Listeners
must
be
functions
.
"
)
;
}
if
(
!
this
.
_listeners
)
{
this
.
_listeners
=
{
}
;
}
this
.
_getListeners
(
name
)
.
push
(
listener
)
;
}
;
proto
.
addOneTimeListener
=
function
(
name
listener
)
{
let
l
=
(
.
.
.
args
)
=
>
{
this
.
removeListener
(
name
l
)
;
listener
.
apply
(
null
args
)
;
}
;
this
.
addListener
(
name
l
)
;
}
;
proto
.
removeListener
=
function
(
name
listener
)
{
if
(
!
this
.
_listeners
|
|
(
listener
&
&
!
this
.
_listeners
[
name
]
)
)
{
return
;
}
if
(
!
listener
)
{
this
.
_listeners
[
name
]
=
[
]
;
}
else
{
this
.
_listeners
[
name
]
=
this
.
_listeners
[
name
]
.
filter
(
l
=
>
l
!
=
listener
)
;
}
}
;
proto
.
_getListeners
=
function
(
name
)
{
if
(
name
in
this
.
_listeners
)
{
return
this
.
_listeners
[
name
]
;
}
this
.
_listeners
[
name
]
=
[
]
;
return
this
.
_listeners
[
name
]
;
}
;
proto
.
emit
=
function
(
)
{
if
(
!
this
.
_listeners
)
{
return
;
}
let
name
=
arguments
[
0
]
;
let
listeners
=
this
.
_getListeners
(
name
)
.
slice
(
0
)
;
for
(
let
listener
of
listeners
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
notify
event
'
"
+
name
+
"
'
"
e
)
;
}
}
}
;
}
const
ThreadStateTypes
=
{
"
paused
"
:
"
paused
"
"
resumed
"
:
"
attached
"
"
detached
"
:
"
detached
"
"
running
"
:
"
attached
"
}
;
const
UnsolicitedNotifications
=
{
"
consoleAPICall
"
:
"
consoleAPICall
"
"
eventNotification
"
:
"
eventNotification
"
"
fileActivity
"
:
"
fileActivity
"
"
lastPrivateContextExited
"
:
"
lastPrivateContextExited
"
"
logMessage
"
:
"
logMessage
"
"
networkEvent
"
:
"
networkEvent
"
"
networkEventUpdate
"
:
"
networkEventUpdate
"
"
newGlobal
"
:
"
newGlobal
"
"
newScript
"
:
"
newScript
"
"
tabDetached
"
:
"
tabDetached
"
"
tabListChanged
"
:
"
tabListChanged
"
"
reflowActivity
"
:
"
reflowActivity
"
"
addonListChanged
"
:
"
addonListChanged
"
"
workerListChanged
"
:
"
workerListChanged
"
"
serviceWorkerRegistrationListChanged
"
:
"
serviceWorkerRegistrationList
"
"
tabNavigated
"
:
"
tabNavigated
"
"
frameUpdate
"
:
"
frameUpdate
"
"
pageError
"
:
"
pageError
"
"
documentLoad
"
:
"
documentLoad
"
"
enteredFrame
"
:
"
enteredFrame
"
"
exitedFrame
"
:
"
exitedFrame
"
"
appOpen
"
:
"
appOpen
"
"
appClose
"
:
"
appClose
"
"
appInstall
"
:
"
appInstall
"
"
appUninstall
"
:
"
appUninstall
"
"
evaluationResult
"
:
"
evaluationResult
"
"
newSource
"
:
"
newSource
"
"
updatedSource
"
:
"
updatedSource
"
}
;
const
UnsolicitedPauses
=
{
"
resumeLimit
"
:
"
resumeLimit
"
"
debuggerStatement
"
:
"
debuggerStatement
"
"
breakpoint
"
:
"
breakpoint
"
"
DOMEvent
"
:
"
DOMEvent
"
"
watchpoint
"
:
"
watchpoint
"
"
exception
"
:
"
exception
"
}
;
const
DebuggerClient
=
exports
.
DebuggerClient
=
function
(
transport
)
{
this
.
_transport
=
transport
;
this
.
_transport
.
hooks
=
this
;
this
.
_clients
=
new
Map
(
)
;
this
.
_pendingRequests
=
new
Map
(
)
;
this
.
_activeRequests
=
new
Map
(
)
;
this
.
_eventsEnabled
=
true
;
this
.
traits
=
{
}
;
this
.
request
=
this
.
request
.
bind
(
this
)
;
this
.
localTransport
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
;
this
.
mainRoot
=
null
;
this
.
expectReply
(
"
root
"
(
packet
)
=
>
{
this
.
mainRoot
=
new
RootClient
(
this
packet
)
;
this
.
emit
(
"
connected
"
packet
.
applicationType
packet
.
traits
)
;
}
)
;
}
;
DebuggerClient
.
requester
=
function
(
packetSkeleton
config
=
{
}
)
{
let
{
before
after
}
=
config
;
return
DevToolsUtils
.
makeInfallible
(
function
(
.
.
.
args
)
{
let
outgoingPacket
=
{
to
:
packetSkeleton
.
to
|
|
this
.
actor
}
;
let
maxPosition
=
-
1
;
for
(
let
k
of
Object
.
keys
(
packetSkeleton
)
)
{
if
(
packetSkeleton
[
k
]
instanceof
DebuggerClient
.
Argument
)
{
let
{
position
}
=
packetSkeleton
[
k
]
;
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
.
getArgument
(
args
)
;
maxPosition
=
Math
.
max
(
position
maxPosition
)
;
}
else
{
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
;
}
}
if
(
before
)
{
outgoingPacket
=
before
.
call
(
this
outgoingPacket
)
;
}
return
this
.
request
(
outgoingPacket
DevToolsUtils
.
makeInfallible
(
(
response
)
=
>
{
if
(
after
)
{
let
{
from
}
=
response
;
response
=
after
.
call
(
this
response
)
;
if
(
!
response
.
from
)
{
response
.
from
=
from
;
}
}
let
thisCallback
=
args
[
maxPosition
+
1
]
;
if
(
thisCallback
)
{
thisCallback
(
response
)
;
}
}
"
DebuggerClient
.
requester
request
callback
"
)
)
;
}
"
DebuggerClient
.
requester
"
)
;
}
;
function
arg
(
pos
)
{
return
new
DebuggerClient
.
Argument
(
pos
)
;
}
DebuggerClient
.
Argument
=
function
(
position
)
{
this
.
position
=
position
;
}
;
DebuggerClient
.
Argument
.
prototype
.
getArgument
=
function
(
params
)
{
if
(
!
(
this
.
position
in
params
)
)
{
throw
new
Error
(
"
Bad
index
into
params
:
"
+
this
.
position
)
;
}
return
params
[
this
.
position
]
;
}
;
DebuggerClient
.
socketConnect
=
function
(
options
)
{
return
DebuggerSocket
.
connect
(
options
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
DebuggerClient
.
prototype
=
{
connect
:
function
(
onConnected
)
{
let
deferred
=
promise
.
defer
(
)
;
this
.
emit
(
"
connect
"
)
;
events
.
emit
(
DebuggerClient
"
connect
"
this
)
;
this
.
addOneTimeListener
(
"
connected
"
(
name
applicationType
traits
)
=
>
{
this
.
traits
=
traits
;
if
(
onConnected
)
{
onConnected
(
applicationType
traits
)
;
}
deferred
.
resolve
(
[
applicationType
traits
]
)
;
}
)
;
this
.
_transport
.
ready
(
)
;
return
deferred
.
promise
;
}
close
:
function
(
onClosed
)
{
let
deferred
=
promise
.
defer
(
)
;
if
(
onClosed
)
{
deferred
.
promise
.
then
(
onClosed
)
;
}
this
.
_eventsEnabled
=
false
;
let
cleanup
=
(
)
=
>
{
this
.
_transport
.
close
(
)
;
this
.
_transport
=
null
;
}
;
if
(
this
.
_closed
)
{
cleanup
(
)
;
deferred
.
resolve
(
)
;
return
deferred
.
promise
;
}
this
.
addOneTimeListener
(
"
closed
"
deferred
.
resolve
)
;
let
clients
=
[
.
.
.
this
.
_clients
.
values
(
)
]
;
this
.
_clients
.
clear
(
)
;
const
detachClients
=
(
)
=
>
{
let
client
=
clients
.
pop
(
)
;
if
(
!
client
)
{
cleanup
(
)
;
return
;
}
if
(
client
.
detach
)
{
client
.
detach
(
detachClients
)
;
return
;
}
detachClients
(
)
;
}
;
detachClients
(
)
;
return
deferred
.
promise
;
}
listTabs
:
function
(
onResponse
)
{
return
this
.
mainRoot
.
listTabs
(
onResponse
)
;
}
listAddons
:
function
(
onResponse
)
{
return
this
.
mainRoot
.
listAddons
(
onResponse
)
;
}
getTab
:
function
(
filter
)
{
return
this
.
mainRoot
.
getTab
(
filter
)
;
}
attachTab
:
function
(
tabActor
onResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
tabActor
)
)
{
let
cachedTab
=
this
.
_clients
.
get
(
tabActor
)
;
let
cachedResponse
=
{
cacheDisabled
:
cachedTab
.
cacheDisabled
javascriptEnabled
:
cachedTab
.
javascriptEnabled
traits
:
cachedTab
.
traits
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
cachedResponse
cachedTab
)
)
;
return
promise
.
resolve
(
[
cachedResponse
cachedTab
]
)
;
}
let
packet
=
{
to
:
tabActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
tabClient
;
if
(
!
response
.
error
)
{
tabClient
=
new
TabClient
(
this
response
)
;
this
.
registerClient
(
tabClient
)
;
}
onResponse
(
response
tabClient
)
;
return
[
response
tabClient
]
;
}
)
;
}
attachWorker
:
function
(
workerActor
onResponse
=
noop
)
{
let
workerClient
=
this
.
_clients
.
get
(
workerActor
)
;
if
(
workerClient
!
=
=
undefined
)
{
let
response
=
{
from
:
workerClient
.
actor
type
:
"
attached
"
url
:
workerClient
.
url
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
response
workerClient
)
)
;
return
promise
.
resolve
(
[
response
workerClient
]
)
;
}
return
this
.
request
(
{
to
:
workerActor
type
:
"
attach
"
}
)
.
then
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
null
)
;
return
[
response
null
]
;
}
workerClient
=
new
WorkerClient
(
this
response
)
;
this
.
registerClient
(
workerClient
)
;
onResponse
(
response
workerClient
)
;
return
[
response
workerClient
]
;
}
)
;
}
attachAddon
:
function
(
addonActor
onResponse
=
noop
)
{
let
packet
=
{
to
:
addonActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
addonClient
;
if
(
!
response
.
error
)
{
addonClient
=
new
AddonClient
(
this
addonActor
)
;
this
.
registerClient
(
addonClient
)
;
this
.
activeAddon
=
addonClient
;
}
onResponse
(
response
addonClient
)
;
return
[
response
addonClient
]
;
}
)
;
}
attachConsole
:
function
(
consoleActor
listeners
onResponse
=
noop
)
{
let
packet
=
{
to
:
consoleActor
type
:
"
startListeners
"
listeners
:
listeners
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
consoleClient
;
if
(
!
response
.
error
)
{
if
(
this
.
_clients
.
has
(
consoleActor
)
)
{
consoleClient
=
this
.
_clients
.
get
(
consoleActor
)
;
}
else
{
consoleClient
=
new
WebConsoleClient
(
this
response
)
;
this
.
registerClient
(
consoleClient
)
;
}
}
onResponse
(
response
consoleClient
)
;
return
[
response
consoleClient
]
;
}
)
;
}
attachThread
:
function
(
threadActor
onResponse
=
noop
options
=
{
}
)
{
if
(
this
.
_clients
.
has
(
threadActor
)
)
{
let
client
=
this
.
_clients
.
get
(
threadActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
threadActor
type
:
"
attach
"
options
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
threadClient
;
if
(
!
response
.
error
)
{
threadClient
=
new
ThreadClient
(
this
threadActor
)
;
this
.
registerClient
(
threadClient
)
;
}
onResponse
(
response
threadClient
)
;
return
[
response
threadClient
]
;
}
)
;
}
attachTracer
:
function
(
traceActor
onResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
traceActor
)
)
{
let
client
=
this
.
_clients
.
get
(
traceActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
traceActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
traceClient
;
if
(
!
response
.
error
)
{
traceClient
=
new
TraceClient
(
this
traceActor
)
;
this
.
registerClient
(
traceClient
)
;
}
onResponse
(
response
traceClient
)
;
return
[
response
traceClient
]
;
}
)
;
}
getProcess
:
function
(
id
)
{
let
packet
=
{
to
:
"
root
"
type
:
"
getProcess
"
}
;
if
(
typeof
(
id
)
=
=
"
number
"
)
{
packet
.
id
=
id
;
}
return
this
.
request
(
packet
)
;
}
release
:
DebuggerClient
.
requester
(
{
to
:
arg
(
0
)
type
:
"
release
"
}
)
request
:
function
(
packet
onResponse
)
{
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
let
type
=
packet
.
type
|
|
"
"
;
if
(
!
packet
.
to
)
{
throw
Error
(
"
'
"
+
type
+
"
'
request
packet
has
no
destination
.
"
)
;
}
if
(
this
.
_closed
)
{
let
msg
=
"
'
"
+
type
+
"
'
request
packet
to
"
+
"
'
"
+
packet
.
to
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
is
closed
.
"
;
let
resp
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
if
(
onResponse
)
{
onResponse
(
resp
)
;
}
return
promise
.
reject
(
resp
)
;
}
let
request
=
new
Request
(
packet
)
;
request
.
format
=
"
json
"
;
request
.
stack
=
getStack
(
)
;
if
(
onResponse
)
{
request
.
on
(
"
json
-
reply
"
onResponse
)
;
}
this
.
_sendOrQueueRequest
(
request
)
;
let
deferred
=
promise
.
defer
(
)
;
function
listenerJson
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
if
(
resp
.
error
)
{
deferred
.
reject
(
resp
)
;
}
else
{
deferred
.
resolve
(
resp
)
;
}
}
function
listenerBulk
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
deferred
.
resolve
(
resp
)
;
}
request
.
on
(
"
json
-
reply
"
listenerJson
)
;
request
.
on
(
"
bulk
-
reply
"
listenerBulk
)
;
request
.
then
=
deferred
.
promise
.
then
.
bind
(
deferred
.
promise
)
;
return
request
;
}
startBulkRequest
:
function
(
request
)
{
if
(
!
this
.
traits
.
bulk
)
{
throw
Error
(
"
Server
doesn
'
t
support
bulk
transfers
"
)
;
}
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
if
(
!
request
.
type
)
{
throw
Error
(
"
Bulk
packet
is
missing
the
required
'
type
'
field
.
"
)
;
}
if
(
!
request
.
actor
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
destination
.
"
)
;
}
if
(
!
request
.
length
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
length
.
"
)
;
}
request
=
new
Request
(
request
)
;
request
.
format
=
"
bulk
"
;
this
.
_sendOrQueueRequest
(
request
)
;
return
request
;
}
_sendOrQueueRequest
(
request
)
{
let
actor
=
request
.
actor
;
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
this
.
_sendRequest
(
request
)
;
}
else
{
this
.
_queueRequest
(
request
)
;
}
}
_sendRequest
(
request
)
{
let
actor
=
request
.
actor
;
this
.
expectReply
(
actor
request
)
;
if
(
request
.
format
=
=
=
"
json
"
)
{
this
.
_transport
.
send
(
request
.
request
)
;
return
;
}
this
.
_transport
.
startBulkSend
(
request
.
request
)
.
then
(
(
.
.
.
args
)
=
>
{
request
.
emit
(
"
bulk
-
send
-
ready
"
.
.
.
args
)
;
}
)
;
}
_queueRequest
(
request
)
{
let
actor
=
request
.
actor
;
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
|
|
[
]
;
queue
.
push
(
request
)
;
this
.
_pendingRequests
.
set
(
actor
queue
)
;
}
_attemptNextRequest
(
actor
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
;
if
(
!
queue
)
{
return
;
}
let
request
=
queue
.
shift
(
)
;
if
(
queue
.
length
=
=
=
0
)
{
this
.
_pendingRequests
.
delete
(
actor
)
;
}
this
.
_sendRequest
(
request
)
;
}
expectReply
:
function
(
actor
request
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
throw
Error
(
"
clashing
handlers
for
next
reply
from
"
+
actor
)
;
}
if
(
typeof
request
=
=
=
"
function
"
)
{
let
handler
=
request
;
request
=
new
Request
(
)
;
request
.
on
(
"
json
-
reply
"
handler
)
;
}
this
.
_activeRequests
.
set
(
actor
request
)
;
}
onPacket
:
function
(
packet
)
{
if
(
!
packet
.
from
)
{
DevToolsUtils
.
reportException
(
"
onPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
let
front
=
this
.
getActor
(
packet
.
from
)
;
if
(
front
)
{
front
.
onPacket
(
packet
)
;
return
;
}
if
(
this
.
mainRoot
&
&
packet
.
from
=
=
this
.
mainRoot
.
actor
&
&
packet
.
type
=
=
"
forwardingCancelled
"
)
{
this
.
purgeRequests
(
packet
.
prefix
)
;
return
;
}
if
(
this
.
_clients
.
has
(
packet
.
from
)
&
&
packet
.
type
)
{
let
client
=
this
.
_clients
.
get
(
packet
.
from
)
;
let
type
=
packet
.
type
;
if
(
client
.
events
.
indexOf
(
type
)
!
=
-
1
)
{
client
.
emit
(
type
packet
)
;
return
;
}
}
let
activeRequest
;
if
(
this
.
_activeRequests
.
has
(
packet
.
from
)
&
&
!
(
packet
.
type
in
UnsolicitedNotifications
)
&
&
!
(
packet
.
type
=
=
ThreadStateTypes
.
paused
&
&
packet
.
why
.
type
in
UnsolicitedPauses
)
)
{
activeRequest
=
this
.
_activeRequests
.
get
(
packet
.
from
)
;
this
.
_activeRequests
.
delete
(
packet
.
from
)
;
}
this
.
_attemptNextRequest
(
packet
.
from
)
;
if
(
packet
.
type
in
ThreadStateTypes
&
&
this
.
_clients
.
has
(
packet
.
from
)
&
&
typeof
this
.
_clients
.
get
(
packet
.
from
)
.
_onThreadState
=
=
"
function
"
)
{
this
.
_clients
.
get
(
packet
.
from
)
.
_onThreadState
(
packet
)
;
}
if
(
!
this
.
traits
.
noNeedToFakeResumptionOnNavigation
)
{
if
(
packet
.
type
=
=
UnsolicitedNotifications
.
tabNavigated
&
&
this
.
_clients
.
has
(
packet
.
from
)
&
&
this
.
_clients
.
get
(
packet
.
from
)
.
thread
)
{
let
thread
=
this
.
_clients
.
get
(
packet
.
from
)
.
thread
;
let
resumption
=
{
from
:
thread
.
_actor
type
:
"
resumed
"
}
;
thread
.
_onThreadState
(
resumption
)
;
}
}
if
(
packet
.
type
)
{
this
.
emit
(
packet
.
type
packet
)
;
}
if
(
activeRequest
)
{
let
emitReply
=
(
)
=
>
activeRequest
.
emit
(
"
json
-
reply
"
packet
)
;
if
(
activeRequest
.
stack
)
{
callFunctionWithAsyncStack
(
emitReply
activeRequest
.
stack
"
DevTools
RDP
"
)
;
}
else
{
emitReply
(
)
;
}
}
}
onBulkPacket
:
function
(
packet
)
{
let
{
actor
}
=
packet
;
if
(
!
actor
)
{
DevToolsUtils
.
reportException
(
"
onBulkPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
bulk
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
activeRequest
=
this
.
_activeRequests
.
get
(
actor
)
;
this
.
_activeRequests
.
delete
(
actor
)
;
this
.
_attemptNextRequest
(
actor
)
;
activeRequest
.
emit
(
"
bulk
-
reply
"
packet
)
;
}
onClosed
:
function
(
)
{
this
.
_closed
=
true
;
this
.
emit
(
"
closed
"
)
;
this
.
purgeRequests
(
)
;
for
(
let
pool
of
this
.
_pools
)
{
pool
.
cleanup
(
)
;
}
}
purgeRequests
(
prefix
=
"
"
)
{
let
reject
=
function
(
type
request
)
{
let
msg
;
if
(
request
.
request
)
{
msg
=
"
'
"
+
request
.
request
.
type
+
"
'
"
+
type
+
"
request
packet
"
+
"
to
'
"
+
request
.
actor
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
just
closed
.
"
;
}
else
{
msg
=
"
server
side
packet
can
'
t
be
received
as
the
connection
just
closed
.
"
;
}
let
packet
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
request
.
emit
(
"
json
-
reply
"
packet
)
;
}
;
let
pendingRequestsToReject
=
[
]
;
this
.
_pendingRequests
.
forEach
(
(
requests
actor
)
=
>
{
if
(
!
actor
.
startsWith
(
prefix
)
)
{
return
;
}
this
.
_pendingRequests
.
delete
(
actor
)
;
pendingRequestsToReject
=
pendingRequestsToReject
.
concat
(
requests
)
;
}
)
;
pendingRequestsToReject
.
forEach
(
request
=
>
reject
(
"
pending
"
request
)
)
;
let
activeRequestsToReject
=
[
]
;
this
.
_activeRequests
.
forEach
(
(
request
actor
)
=
>
{
if
(
!
actor
.
startsWith
(
prefix
)
)
{
return
;
}
this
.
_activeRequests
.
delete
(
actor
)
;
activeRequestsToReject
=
activeRequestsToReject
.
concat
(
request
)
;
}
)
;
activeRequestsToReject
.
forEach
(
request
=
>
reject
(
"
active
"
request
)
)
;
}
waitForRequestsToSettle
(
)
{
let
requests
=
[
]
;
this
.
_pendingRequests
.
forEach
(
requestsForActor
=
>
{
requests
=
requests
.
concat
(
requestsForActor
)
;
}
)
;
this
.
_activeRequests
.
forEach
(
requestForActor
=
>
{
requests
=
requests
.
concat
(
requestForActor
)
;
}
)
;
let
fronts
=
new
Set
(
)
;
let
poolsToVisit
=
[
.
.
.
this
.
_pools
]
;
while
(
poolsToVisit
.
length
)
{
let
pool
=
poolsToVisit
.
shift
(
)
;
fronts
.
add
(
pool
)
;
for
(
let
child
of
pool
.
poolChildren
(
)
)
{
poolsToVisit
.
push
(
child
)
;
}
}
for
(
let
front
of
fronts
)
{
if
(
front
.
hasRequests
(
)
)
{
requests
.
push
(
front
.
waitForRequestsToSettle
(
)
)
;
}
}
if
(
!
requests
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
DevToolsUtils
.
settleAll
(
requests
)
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
return
this
.
waitForRequestsToSettle
(
)
;
}
)
;
}
registerClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
actor
attribute
.
"
)
;
}
if
(
!
Array
.
isArray
(
client
.
events
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
events
attribute
"
+
"
that
is
an
array
.
"
)
;
}
if
(
client
.
events
.
length
>
0
&
&
typeof
(
client
.
emit
)
!
=
"
function
"
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
non
-
empty
events
array
to
"
+
"
have
an
emit
function
.
"
)
;
}
if
(
this
.
_clients
.
has
(
actorID
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
already
registered
"
+
"
a
client
for
this
actor
.
"
)
;
}
this
.
_clients
.
set
(
actorID
client
)
;
}
unregisterClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
unregisterClient
expects
"
+
"
a
Client
instance
with
a
actor
attribute
.
"
)
;
}
this
.
_clients
.
delete
(
actorID
)
;
}
__pools
:
null
get
_pools
(
)
{
if
(
this
.
__pools
)
{
return
this
.
__pools
;
}
this
.
__pools
=
new
Set
(
)
;
return
this
.
__pools
;
}
addActorPool
:
function
(
pool
)
{
this
.
_pools
.
add
(
pool
)
;
}
removeActorPool
:
function
(
pool
)
{
this
.
_pools
.
delete
(
pool
)
;
}
getActor
:
function
(
actorID
)
{
let
pool
=
this
.
poolFor
(
actorID
)
;
return
pool
?
pool
.
get
(
actorID
)
:
null
;
}
poolFor
:
function
(
actorID
)
{
for
(
let
pool
of
this
.
_pools
)
{
if
(
pool
.
has
(
actorID
)
)
{
return
pool
;
}
}
return
null
;
}
activeAddon
:
null
}
;
eventSource
(
DebuggerClient
.
prototype
)
;
function
Request
(
request
)
{
this
.
request
=
request
;
}
Request
.
prototype
=
{
on
:
function
(
type
listener
)
{
events
.
on
(
this
type
listener
)
;
}
off
:
function
(
type
listener
)
{
events
.
off
(
this
type
listener
)
;
}
once
:
function
(
type
listener
)
{
events
.
once
(
this
type
listener
)
;
}
emit
:
function
(
type
.
.
.
args
)
{
events
.
emit
(
this
type
.
.
.
args
)
;
}
get
actor
(
)
{
return
this
.
request
.
to
|
|
this
.
request
.
actor
;
}
}
;
function
TabClient
(
client
form
)
{
this
.
client
=
client
;
this
.
_actor
=
form
.
from
;
this
.
_threadActor
=
form
.
threadActor
;
this
.
javascriptEnabled
=
form
.
javascriptEnabled
;
this
.
cacheDisabled
=
form
.
cacheDisabled
;
this
.
thread
=
null
;
this
.
request
=
this
.
client
.
request
;
this
.
traits
=
form
.
traits
|
|
{
}
;
this
.
events
=
[
"
workerListChanged
"
]
;
}
TabClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
attachThread
:
function
(
options
=
{
}
onResponse
=
noop
)
{
if
(
this
.
thread
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
this
.
thread
)
)
;
return
promise
.
resolve
(
[
{
}
this
.
thread
]
)
;
}
let
packet
=
{
to
:
this
.
_threadActor
type
:
"
attach
"
options
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
if
(
!
response
.
error
)
{
this
.
thread
=
new
ThreadClient
(
this
this
.
_threadActor
)
;
this
.
client
.
registerClient
(
this
.
thread
)
;
}
onResponse
(
response
this
.
thread
)
;
return
[
response
this
.
thread
]
;
}
)
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
thread
)
{
this
.
thread
.
detach
(
)
;
}
return
packet
;
}
after
:
function
(
response
)
{
this
.
client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
focus
:
DebuggerClient
.
requester
(
{
type
:
"
focus
"
}
{
}
)
reload
:
function
(
options
=
{
force
:
false
}
)
{
return
this
.
_reload
(
options
)
;
}
_reload
:
DebuggerClient
.
requester
(
{
type
:
"
reload
"
options
:
arg
(
0
)
}
)
navigateTo
:
DebuggerClient
.
requester
(
{
type
:
"
navigateTo
"
url
:
arg
(
0
)
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
arg
(
0
)
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
)
attachWorker
:
function
(
workerActor
onResponse
)
{
return
this
.
client
.
attachWorker
(
workerActor
onResponse
)
;
}
resolveLocation
:
DebuggerClient
.
requester
(
{
type
:
"
resolveLocation
"
location
:
arg
(
0
)
}
)
}
;
eventSource
(
TabClient
.
prototype
)
;
function
WorkerClient
(
client
form
)
{
this
.
client
=
client
;
this
.
_actor
=
form
.
from
;
this
.
_isClosed
=
false
;
this
.
_url
=
form
.
url
;
this
.
_onClose
=
this
.
_onClose
.
bind
(
this
)
;
this
.
addListener
(
"
close
"
this
.
_onClose
)
;
this
.
traits
=
{
}
;
}
WorkerClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
get
request
(
)
{
return
this
.
client
.
request
;
}
get
actor
(
)
{
return
this
.
_actor
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isClosed
(
)
{
return
this
.
_isClosed
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
attachThread
:
function
(
options
=
{
}
onResponse
=
noop
)
{
if
(
this
.
thread
)
{
let
response
=
[
{
type
:
"
connected
"
threadActor
:
this
.
thread
.
_actor
consoleActor
:
this
.
consoleActor
}
this
.
thread
]
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
response
)
)
;
return
response
;
}
return
this
.
request
(
{
to
:
this
.
_actor
type
:
"
connect
"
options
}
)
.
then
(
connectResponse
=
>
{
if
(
connectResponse
.
error
)
{
onResponse
(
connectResponse
null
)
;
return
[
connectResponse
null
]
;
}
return
this
.
request
(
{
to
:
connectResponse
.
threadActor
type
:
"
attach
"
options
}
)
.
then
(
attachResponse
=
>
{
if
(
attachResponse
.
error
)
{
onResponse
(
attachResponse
null
)
;
}
this
.
thread
=
new
ThreadClient
(
this
connectResponse
.
threadActor
)
;
this
.
consoleActor
=
connectResponse
.
consoleActor
;
this
.
client
.
registerClient
(
this
.
thread
)
;
onResponse
(
connectResponse
this
.
thread
)
;
return
[
connectResponse
this
.
thread
]
;
}
)
;
}
error
=
>
{
onResponse
(
error
null
)
;
}
)
;
}
_onClose
:
function
(
)
{
this
.
removeListener
(
"
close
"
this
.
_onClose
)
;
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
this
.
_isClosed
=
true
;
}
reconfigure
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
events
:
[
"
close
"
]
}
;
eventSource
(
WorkerClient
.
prototype
)
;
function
AddonClient
(
client
actor
)
{
this
.
_client
=
client
;
this
.
_actor
=
actor
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
AddonClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
if
(
this
.
_client
.
activeAddon
=
=
=
this
)
{
this
.
_client
.
activeAddon
=
null
;
}
this
.
_client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
}
;
function
RootClient
(
client
greeting
)
{
this
.
_client
=
client
;
this
.
actor
=
greeting
.
from
;
this
.
applicationType
=
greeting
.
applicationType
;
this
.
traits
=
greeting
.
traits
;
}
exports
.
RootClient
=
RootClient
;
RootClient
.
prototype
=
{
constructor
:
RootClient
listTabs
:
DebuggerClient
.
requester
(
{
type
:
"
listTabs
"
}
)
listAddons
:
DebuggerClient
.
requester
(
{
type
:
"
listAddons
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
)
listServiceWorkerRegistrations
:
DebuggerClient
.
requester
(
{
type
:
"
listServiceWorkerRegistrations
"
}
)
listProcesses
:
DebuggerClient
.
requester
(
{
type
:
"
listProcesses
"
}
)
getTab
:
function
(
filter
)
{
let
packet
=
{
to
:
this
.
actor
type
:
"
getTab
"
}
;
if
(
filter
)
{
if
(
typeof
(
filter
.
outerWindowID
)
=
=
"
number
"
)
{
packet
.
outerWindowID
=
filter
.
outerWindowID
;
}
else
if
(
typeof
(
filter
.
tabId
)
=
=
"
number
"
)
{
packet
.
tabId
=
filter
.
tabId
;
}
else
if
(
"
tab
"
in
filter
)
{
let
browser
=
filter
.
tab
.
linkedBrowser
;
if
(
browser
.
frameLoader
.
tabParent
)
{
packet
.
tabId
=
browser
.
frameLoader
.
tabParent
.
tabId
;
}
else
if
(
browser
.
outerWindowID
)
{
packet
.
outerWindowID
=
browser
.
outerWindowID
;
}
else
{
let
windowUtils
=
browser
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
packet
.
outerWindowID
=
windowUtils
.
outerWindowID
;
}
}
else
{
throw
new
Error
(
"
Unsupported
argument
given
to
getTab
request
"
)
;
}
}
return
this
.
request
(
packet
)
;
}
getWindow
:
function
(
{
outerWindowID
}
)
{
if
(
!
outerWindowID
)
{
throw
new
Error
(
"
Must
specify
outerWindowID
"
)
;
}
let
packet
=
{
to
:
this
.
actor
type
:
"
getWindow
"
outerWindowID
}
;
return
this
.
request
(
packet
)
;
}
protocolDescription
:
DebuggerClient
.
requester
(
{
type
:
"
protocolDescription
"
}
)
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
}
;
function
ThreadClient
(
client
actor
)
{
this
.
_parent
=
client
;
this
.
client
=
client
instanceof
DebuggerClient
?
client
:
client
.
client
;
this
.
_actor
=
actor
;
this
.
_frameCache
=
[
]
;
this
.
_scriptCache
=
{
}
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
request
=
this
.
client
.
request
;
}
ThreadClient
.
prototype
=
{
_state
:
"
paused
"
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
_pauseOnExceptions
:
false
_ignoreCaughtExceptions
:
false
_pauseOnDOMEvents
:
null
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
_assertPaused
:
function
(
command
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
command
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
_doResume
:
DebuggerClient
.
requester
(
{
type
:
"
resume
"
resumeLimit
:
arg
(
0
)
}
{
before
:
function
(
packet
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_previousState
=
this
.
_state
;
this
.
_state
=
"
resuming
"
;
if
(
this
.
_pauseOnExceptions
)
{
packet
.
pauseOnExceptions
=
this
.
_pauseOnExceptions
;
}
if
(
this
.
_ignoreCaughtExceptions
)
{
packet
.
ignoreCaughtExceptions
=
this
.
_ignoreCaughtExceptions
;
}
if
(
this
.
_pauseOnDOMEvents
)
{
packet
.
pauseOnDOMEvents
=
this
.
_pauseOnDOMEvents
;
}
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
error
&
&
this
.
_state
=
=
"
resuming
"
)
{
if
(
response
.
state
)
{
this
.
_state
=
ThreadStateTypes
[
response
.
state
]
;
}
else
{
this
.
_state
=
this
.
_previousState
;
}
}
delete
this
.
_previousState
;
return
response
;
}
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
arg
(
0
)
}
)
resume
:
function
(
onResponse
)
{
return
this
.
_doResume
(
null
onResponse
)
;
}
resumeThenPause
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
onResponse
)
;
}
stepOver
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
onResponse
)
;
}
stepIn
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
onResponse
)
;
}
stepOut
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
onResponse
)
;
}
interrupt
:
function
(
onResponse
)
{
return
this
.
_doInterrupt
(
null
onResponse
)
;
}
breakOnNext
:
function
(
onResponse
)
{
return
this
.
_doInterrupt
(
"
onNext
"
onResponse
)
;
}
_doInterrupt
:
DebuggerClient
.
requester
(
{
type
:
"
interrupt
"
when
:
arg
(
0
)
}
)
pauseOnExceptions
:
function
(
pauseOnExceptions
ignoreCaughtExceptions
onResponse
=
noop
)
{
this
.
_pauseOnExceptions
=
pauseOnExceptions
;
this
.
_ignoreCaughtExceptions
=
ignoreCaughtExceptions
;
if
(
!
this
.
paused
)
{
return
this
.
interrupt
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
return
this
.
resume
(
onResponse
)
;
}
)
;
}
onResponse
(
)
;
return
promise
.
resolve
(
)
;
}
pauseOnDOMEvents
:
function
(
events
onResponse
=
noop
)
{
this
.
_pauseOnDOMEvents
=
events
;
if
(
this
.
paused
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
)
)
;
return
{
}
;
}
return
this
.
interrupt
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
return
this
.
resume
(
onResponse
)
;
}
)
;
}
eval
:
DebuggerClient
.
requester
(
{
type
:
"
clientEvaluate
"
frame
:
arg
(
0
)
expression
:
arg
(
1
)
}
{
before
:
function
(
packet
)
{
this
.
_assertPaused
(
"
eval
"
)
;
this
.
_state
=
"
resuming
"
;
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
response
;
}
}
)
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
this
.
client
.
unregisterClient
(
this
)
;
this
.
_parent
.
thread
=
null
;
return
response
;
}
}
)
releaseMany
:
DebuggerClient
.
requester
(
{
type
:
"
releaseMany
"
actors
:
arg
(
0
)
}
)
threadGrips
:
DebuggerClient
.
requester
(
{
type
:
"
threadGrips
"
actors
:
arg
(
0
)
}
)
eventListeners
:
DebuggerClient
.
requester
(
{
type
:
"
eventListeners
"
}
)
getSources
:
DebuggerClient
.
requester
(
{
type
:
"
sources
"
}
)
_clearScripts
:
function
(
)
{
if
(
Object
.
keys
(
this
.
_scriptCache
)
.
length
>
0
)
{
this
.
_scriptCache
=
{
}
;
this
.
emit
(
"
scriptscleared
"
)
;
}
}
getFrames
:
DebuggerClient
.
requester
(
{
type
:
"
frames
"
start
:
arg
(
0
)
count
:
arg
(
1
)
}
)
get
cachedFrames
(
)
{
return
this
.
_frameCache
;
}
get
moreFrames
(
)
{
return
this
.
paused
&
&
(
!
this
.
_frameCache
|
|
this
.
_frameCache
.
length
=
=
0
|
|
!
this
.
_frameCache
[
this
.
_frameCache
.
length
-
1
]
.
oldest
)
;
}
fillFrames
:
function
(
total
callback
=
noop
)
{
this
.
_assertPaused
(
"
fillFrames
"
)
;
if
(
this
.
_frameCache
.
length
>
=
total
)
{
return
false
;
}
let
numFrames
=
this
.
_frameCache
.
length
;
this
.
getFrames
(
numFrames
total
-
numFrames
(
response
)
=
>
{
if
(
response
.
error
)
{
callback
(
response
)
;
return
;
}
let
threadGrips
=
DevToolsUtils
.
values
(
this
.
_threadGrips
)
;
for
(
let
i
in
response
.
frames
)
{
let
frame
=
response
.
frames
[
i
]
;
if
(
!
frame
.
where
.
source
)
{
for
(
let
grip
of
threadGrips
)
{
if
(
grip
instanceof
SourceClient
&
&
grip
.
url
=
=
=
frame
.
url
)
{
frame
.
where
.
source
=
grip
.
_form
;
}
}
}
this
.
_frameCache
[
frame
.
depth
]
=
frame
;
}
this
.
emit
(
"
framesadded
"
)
;
callback
(
response
)
;
}
)
;
return
true
;
}
_clearFrames
:
function
(
)
{
if
(
this
.
_frameCache
.
length
>
0
)
{
this
.
_frameCache
=
[
]
;
this
.
emit
(
"
framescleared
"
)
;
}
}
pauseGrip
:
function
(
grip
)
{
if
(
grip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
grip
.
actor
]
;
}
let
client
=
new
ObjectClient
(
this
.
client
grip
)
;
this
.
_pauseGrips
[
grip
.
actor
]
=
client
;
return
client
;
}
_longString
:
function
(
grip
gripCacheName
)
{
if
(
grip
.
actor
in
this
[
gripCacheName
]
)
{
return
this
[
gripCacheName
]
[
grip
.
actor
]
;
}
let
client
=
new
LongStringClient
(
this
.
client
grip
)
;
this
[
gripCacheName
]
[
grip
.
actor
]
=
client
;
return
client
;
}
pauseLongString
:
function
(
grip
)
{
return
this
.
_longString
(
grip
"
_pauseGrips
"
)
;
}
threadLongString
:
function
(
grip
)
{
return
this
.
_longString
(
grip
"
_threadGrips
"
)
;
}
_clearObjectClients
:
function
(
gripCacheName
)
{
for
(
let
id
in
this
[
gripCacheName
]
)
{
this
[
gripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
gripCacheName
]
=
{
}
;
}
_clearPauseGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_threadGrips
"
)
;
}
_onThreadState
:
function
(
packet
)
{
this
.
_state
=
ThreadStateTypes
[
packet
.
type
]
;
this
.
_lastPausePacket
=
packet
.
type
=
=
=
"
resumed
"
?
null
:
packet
;
this
.
_clearFrames
(
)
;
this
.
_clearPauseGrips
(
)
;
packet
.
type
=
=
=
ThreadStateTypes
.
detached
&
&
this
.
_clearThreadGrips
(
)
;
this
.
client
.
_eventsEnabled
&
&
this
.
emit
(
packet
.
type
packet
)
;
}
getLastPausePacket
:
function
(
)
{
return
this
.
_lastPausePacket
;
}
environment
:
function
(
form
)
{
return
new
EnvironmentClient
(
this
.
client
form
)
;
}
source
:
function
(
form
)
{
if
(
form
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
form
.
actor
]
;
}
this
.
_threadGrips
[
form
.
actor
]
=
new
SourceClient
(
this
form
)
;
return
this
.
_threadGrips
[
form
.
actor
]
;
}
getPrototypesAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypesAndProperties
"
actors
:
arg
(
0
)
}
)
events
:
[
"
newSource
"
]
}
;
eventSource
(
ThreadClient
.
prototype
)
;
function
TraceClient
(
client
actor
)
{
this
.
_client
=
client
;
this
.
_actor
=
actor
;
this
.
_activeTraces
=
new
Set
(
)
;
this
.
_waitingPackets
=
new
Map
(
)
;
this
.
_expectedPacket
=
0
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
TraceClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
tracing
(
)
{
return
this
.
_activeTraces
.
size
>
0
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
this
.
_client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
startTrace
:
DebuggerClient
.
requester
(
{
type
:
"
startTrace
"
name
:
arg
(
1
)
trace
:
arg
(
0
)
}
{
after
:
function
(
response
)
{
if
(
response
.
error
)
{
return
response
;
}
if
(
!
this
.
tracing
)
{
this
.
_waitingPackets
.
clear
(
)
;
this
.
_expectedPacket
=
0
;
}
this
.
_activeTraces
.
add
(
response
.
name
)
;
return
response
;
}
}
)
stopTrace
:
DebuggerClient
.
requester
(
{
type
:
"
stopTrace
"
name
:
arg
(
0
)
}
{
after
:
function
(
response
)
{
if
(
response
.
error
)
{
return
response
;
}
this
.
_activeTraces
.
delete
(
response
.
name
)
;
return
response
;
}
}
)
}
;
function
ObjectClient
(
client
grip
)
{
this
.
_grip
=
grip
;
this
.
_client
=
client
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
ObjectClient
=
ObjectClient
;
ObjectClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
get
isFrozen
(
)
{
return
this
.
_grip
.
frozen
;
}
get
isSealed
(
)
{
return
this
.
_grip
.
sealed
;
}
get
isExtensible
(
)
{
return
this
.
_grip
.
extensible
;
}
getDefinitionSite
:
DebuggerClient
.
requester
(
{
type
:
"
definitionSite
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
"
Function
"
)
{
throw
new
Error
(
"
getDefinitionSite
is
only
valid
for
function
grips
.
"
)
;
}
return
packet
;
}
}
)
getParameterNames
:
DebuggerClient
.
requester
(
{
type
:
"
parameterNames
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
getParameterNames
is
only
valid
for
function
grips
.
"
)
;
}
return
packet
;
}
}
)
getOwnPropertyNames
:
DebuggerClient
.
requester
(
{
type
:
"
ownPropertyNames
"
}
)
getPrototypeAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypeAndProperties
"
}
)
enumProperties
:
DebuggerClient
.
requester
(
{
type
:
"
enumProperties
"
options
:
arg
(
0
)
}
{
after
:
function
(
response
)
{
if
(
response
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
response
.
iterator
)
}
;
}
return
response
;
}
}
)
enumEntries
:
DebuggerClient
.
requester
(
{
type
:
"
enumEntries
"
}
{
before
:
function
(
packet
)
{
if
(
!
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
this
.
_grip
.
class
)
)
{
throw
new
Error
(
"
enumEntries
is
only
valid
for
Map
/
Set
-
like
grips
.
"
)
;
}
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
response
.
iterator
)
}
;
}
return
response
;
}
}
)
getProperty
:
DebuggerClient
.
requester
(
{
type
:
"
property
"
name
:
arg
(
0
)
}
)
getPrototype
:
DebuggerClient
.
requester
(
{
type
:
"
prototype
"
}
)
getDisplayString
:
DebuggerClient
.
requester
(
{
type
:
"
displayString
"
}
)
getScope
:
DebuggerClient
.
requester
(
{
type
:
"
scope
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
scope
is
only
valid
for
function
grips
.
"
)
;
}
return
packet
;
}
}
)
getDependentPromises
:
DebuggerClient
.
requester
(
{
type
:
"
dependentPromises
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getDependentPromises
is
only
valid
for
promise
"
+
"
grips
.
"
)
;
}
return
packet
;
}
}
)
getPromiseAllocationStack
:
DebuggerClient
.
requester
(
{
type
:
"
allocationStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getAllocationStack
is
only
valid
for
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
getPromiseFulfillmentStack
:
DebuggerClient
.
requester
(
{
type
:
"
fulfillmentStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseFulfillmentStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
getPromiseRejectionStack
:
DebuggerClient
.
requester
(
{
type
:
"
rejectionStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseRejectionStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
}
;
function
PropertyIteratorClient
(
client
grip
)
{
this
.
_grip
=
grip
;
this
.
_client
=
client
;
this
.
request
=
this
.
_client
.
request
;
}
PropertyIteratorClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
count
(
)
{
return
this
.
_grip
.
count
;
}
names
:
DebuggerClient
.
requester
(
{
type
:
"
names
"
indexes
:
arg
(
0
)
}
{
}
)
slice
:
DebuggerClient
.
requester
(
{
type
:
"
slice
"
start
:
arg
(
0
)
count
:
arg
(
1
)
}
{
}
)
all
:
DebuggerClient
.
requester
(
{
type
:
"
all
"
}
{
}
)
}
;
function
LongStringClient
(
client
grip
)
{
this
.
_grip
=
grip
;
this
.
_client
=
client
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
LongStringClient
=
LongStringClient
;
LongStringClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
length
(
)
{
return
this
.
_grip
.
length
;
}
get
initial
(
)
{
return
this
.
_grip
.
initial
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
substring
:
DebuggerClient
.
requester
(
{
type
:
"
substring
"
start
:
arg
(
0
)
end
:
arg
(
1
)
}
)
}
;
function
SourceClient
(
client
form
)
{
this
.
_form
=
form
;
this
.
_isBlackBoxed
=
form
.
isBlackBoxed
;
this
.
_isPrettyPrinted
=
form
.
isPrettyPrinted
;
this
.
_activeThread
=
client
;
this
.
_client
=
client
.
client
;
}
SourceClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
isBlackBoxed
(
)
{
return
this
.
_isBlackBoxed
;
}
get
isPrettyPrinted
(
)
{
return
this
.
_isPrettyPrinted
;
}
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
get
url
(
)
{
return
this
.
_form
.
url
;
}
blackBox
:
DebuggerClient
.
requester
(
{
type
:
"
blackbox
"
}
{
after
:
function
(
response
)
{
if
(
!
response
.
error
)
{
this
.
_isBlackBoxed
=
true
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
response
;
}
}
)
unblackBox
:
DebuggerClient
.
requester
(
{
type
:
"
unblackbox
"
}
{
after
:
function
(
response
)
{
if
(
!
response
.
error
)
{
this
.
_isBlackBoxed
=
false
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
response
;
}
}
)
getExecutableLines
:
function
(
cb
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
getExecutableLines
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
res
=
>
{
cb
(
res
.
lines
)
;
return
res
.
lines
;
}
)
;
}
source
:
function
(
callback
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
source
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
return
this
.
_onSourceResponse
(
response
callback
)
;
}
)
;
}
prettyPrint
:
function
(
indent
callback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
prettyPrint
"
indent
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_isPrettyPrinted
=
true
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
response
callback
)
;
}
)
;
}
disablePrettyPrint
:
function
(
callback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
disablePrettyPrint
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_isPrettyPrinted
=
false
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
response
callback
)
;
}
)
;
}
_onSourceResponse
:
function
(
response
callback
)
{
if
(
response
.
error
)
{
callback
(
response
)
;
return
response
;
}
if
(
typeof
response
.
source
=
=
=
"
string
"
)
{
callback
(
response
)
;
return
response
;
}
let
{
contentType
source
}
=
response
;
let
longString
=
this
.
_activeThread
.
threadLongString
(
source
)
;
return
longString
.
substring
(
0
longString
.
length
)
.
then
(
function
(
resp
)
{
if
(
resp
.
error
)
{
callback
(
resp
)
;
return
resp
;
}
let
newResponse
=
{
source
:
resp
.
substring
contentType
:
contentType
}
;
callback
(
newResponse
)
;
return
newResponse
;
}
)
;
}
setBreakpoint
:
function
(
{
line
column
condition
noSliding
}
onResponse
=
noop
)
{
let
doSetBreakpoint
=
callback
=
>
{
let
root
=
this
.
_client
.
mainRoot
;
let
location
=
{
line
column
}
;
let
packet
=
{
to
:
this
.
actor
type
:
"
setBreakpoint
"
location
condition
noSliding
}
;
if
(
!
root
.
traits
.
debuggerSourceActors
)
{
packet
.
to
=
this
.
_activeThread
.
actor
;
packet
.
location
.
url
=
this
.
url
;
}
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
let
bpClient
;
if
(
response
.
actor
)
{
bpClient
=
new
BreakpointClient
(
this
.
_client
this
response
.
actor
location
root
.
traits
.
conditionalBreakpoints
?
condition
:
undefined
)
;
}
onResponse
(
response
bpClient
)
;
if
(
callback
)
{
callback
(
)
;
}
return
[
response
bpClient
]
;
}
)
;
}
;
if
(
this
.
_activeThread
.
paused
)
{
return
doSetBreakpoint
(
)
;
}
return
this
.
_activeThread
.
interrupt
(
)
.
then
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
const
{
type
why
}
=
response
;
const
cleanUp
=
type
=
=
"
paused
"
&
&
why
.
type
=
=
"
interrupted
"
?
(
)
=
>
this
.
_activeThread
.
resume
(
)
:
noop
;
return
doSetBreakpoint
(
cleanUp
)
;
}
)
;
}
}
;
function
BreakpointClient
(
client
sourceClient
actor
location
condition
)
{
this
.
_client
=
client
;
this
.
_actor
=
actor
;
this
.
location
=
location
;
this
.
location
.
actor
=
sourceClient
.
actor
;
this
.
location
.
url
=
sourceClient
.
url
;
this
.
source
=
sourceClient
;
this
.
request
=
this
.
_client
.
request
;
if
(
condition
)
{
this
.
condition
=
condition
;
}
}
BreakpointClient
.
prototype
=
{
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
remove
:
DebuggerClient
.
requester
(
{
type
:
"
delete
"
}
)
hasCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
"
condition
"
in
this
;
}
return
"
conditionalExpression
"
in
this
;
}
getCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
this
.
condition
;
}
return
this
.
conditionalExpression
;
}
setCondition
:
function
(
gThreadClient
condition
)
{
let
root
=
this
.
_client
.
mainRoot
;
let
deferred
=
promise
.
defer
(
)
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
let
info
=
{
line
:
this
.
location
.
line
column
:
this
.
location
.
column
condition
:
condition
}
;
this
.
remove
(
response
=
>
{
if
(
response
&
&
response
.
error
)
{
deferred
.
reject
(
response
)
;
return
;
}
this
.
source
.
setBreakpoint
(
info
(
resp
newBreakpoint
)
=
>
{
if
(
resp
&
&
resp
.
error
)
{
deferred
.
reject
(
resp
)
;
}
else
{
deferred
.
resolve
(
newBreakpoint
)
;
}
}
)
;
}
)
;
}
else
{
if
(
condition
=
=
=
"
"
)
{
delete
this
.
conditionalExpression
;
}
else
{
this
.
conditionalExpression
=
condition
;
}
deferred
.
resolve
(
this
)
;
}
return
deferred
.
promise
;
}
}
;
eventSource
(
BreakpointClient
.
prototype
)
;
function
EnvironmentClient
(
client
form
)
{
this
.
_client
=
client
;
this
.
_form
=
form
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
EnvironmentClient
=
EnvironmentClient
;
EnvironmentClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
getBindings
:
DebuggerClient
.
requester
(
{
type
:
"
bindings
"
}
)
assign
:
DebuggerClient
.
requester
(
{
type
:
"
assign
"
name
:
arg
(
0
)
value
:
arg
(
1
)
}
)
}
;
eventSource
(
EnvironmentClient
.
prototype
)
;
