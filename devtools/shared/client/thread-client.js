"
use
strict
"
;
const
promise
=
require
(
"
devtools
/
shared
/
deprecated
-
sync
-
thenables
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
arg
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
const
eventSource
=
require
(
"
devtools
/
shared
/
client
/
event
-
source
"
)
;
const
{
ThreadStateTypes
}
=
require
(
"
devtools
/
shared
/
client
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
ArrayBufferClient
"
"
devtools
/
shared
/
client
/
array
-
buffer
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringClient
"
"
devtools
/
shared
/
client
/
long
-
string
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceClient
"
"
devtools
/
shared
/
client
/
source
-
client
"
)
;
const
noop
=
(
)
=
>
{
}
;
function
ThreadClient
(
client
actor
)
{
this
.
client
=
client
;
this
.
_actor
=
actor
;
this
.
_frameCache
=
[
]
;
this
.
_scriptCache
=
{
}
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
request
=
this
.
client
.
request
;
}
ThreadClient
.
prototype
=
{
_state
:
"
paused
"
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
_pauseOnExceptions
:
false
_ignoreCaughtExceptions
:
false
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
_assertPaused
:
function
(
command
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
command
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
_doResume
:
DebuggerClient
.
requester
(
{
type
:
"
resume
"
resumeLimit
:
arg
(
0
)
rewind
:
arg
(
1
)
}
{
before
:
function
(
packet
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_previousState
=
this
.
_state
;
this
.
_state
=
"
resuming
"
;
if
(
this
.
_pauseOnExceptions
)
{
packet
.
pauseOnExceptions
=
this
.
_pauseOnExceptions
;
}
if
(
this
.
_ignoreCaughtExceptions
)
{
packet
.
ignoreCaughtExceptions
=
this
.
_ignoreCaughtExceptions
;
}
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
error
&
&
this
.
_state
=
=
"
resuming
"
)
{
if
(
response
.
state
)
{
this
.
_state
=
ThreadStateTypes
[
response
.
state
]
;
}
else
{
this
.
_state
=
this
.
_previousState
;
}
}
delete
this
.
_previousState
;
return
response
;
}
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
arg
(
0
)
}
)
resume
:
function
(
onResponse
)
{
return
this
.
_doResume
(
null
false
onResponse
)
;
}
resumeThenPause
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
false
onResponse
)
;
}
rewind
:
function
(
onResponse
)
{
this
.
_doResume
(
null
true
onResponse
)
;
}
stepOver
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
false
onResponse
)
;
}
stepIn
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
false
onResponse
)
;
}
stepOut
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
false
onResponse
)
;
}
reverseStepOver
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
true
onResponse
)
;
}
reverseStepIn
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
true
onResponse
)
;
}
reverseStepOut
:
function
(
onResponse
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
true
onResponse
)
;
}
interrupt
:
function
(
onResponse
)
{
return
this
.
_doInterrupt
(
null
onResponse
)
;
}
breakOnNext
:
function
(
onResponse
)
{
return
this
.
_doInterrupt
(
"
onNext
"
onResponse
)
;
}
timeWarp
:
function
(
target
onResponse
)
{
const
warp
=
(
)
=
>
{
this
.
_doResume
(
{
type
:
"
warp
"
target
}
true
onResponse
)
;
}
;
if
(
this
.
paused
)
{
warp
(
)
;
}
else
{
this
.
interrupt
(
warp
)
;
}
}
_doInterrupt
:
DebuggerClient
.
requester
(
{
type
:
"
interrupt
"
when
:
arg
(
0
)
}
)
pauseOnExceptions
:
function
(
pauseOnExceptions
ignoreCaughtExceptions
onResponse
=
noop
)
{
this
.
_pauseOnExceptions
=
pauseOnExceptions
;
this
.
_ignoreCaughtExceptions
=
ignoreCaughtExceptions
;
if
(
!
this
.
paused
)
{
return
this
.
interrupt
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
return
this
.
resume
(
onResponse
)
;
}
)
;
}
onResponse
(
)
;
return
promise
.
resolve
(
)
;
}
eval
:
DebuggerClient
.
requester
(
{
type
:
"
clientEvaluate
"
frame
:
arg
(
0
)
expression
:
arg
(
1
)
}
{
before
:
function
(
packet
)
{
this
.
_assertPaused
(
"
eval
"
)
;
this
.
_state
=
"
resuming
"
;
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
response
;
}
}
)
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
this
.
client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
releaseMany
:
DebuggerClient
.
requester
(
{
type
:
"
releaseMany
"
actors
:
arg
(
0
)
}
)
threadGrips
:
DebuggerClient
.
requester
(
{
type
:
"
threadGrips
"
actors
:
arg
(
0
)
}
)
eventListeners
:
DebuggerClient
.
requester
(
{
type
:
"
eventListeners
"
}
)
getSources
:
DebuggerClient
.
requester
(
{
type
:
"
sources
"
}
)
_clearScripts
:
function
(
)
{
if
(
Object
.
keys
(
this
.
_scriptCache
)
.
length
>
0
)
{
this
.
_scriptCache
=
{
}
;
this
.
emit
(
"
scriptscleared
"
)
;
}
}
getFrames
:
DebuggerClient
.
requester
(
{
type
:
"
frames
"
start
:
arg
(
0
)
count
:
arg
(
1
)
}
)
skipBreakpoints
:
DebuggerClient
.
requester
(
{
type
:
"
skipBreakpoints
"
skip
:
arg
(
0
)
}
)
get
cachedFrames
(
)
{
return
this
.
_frameCache
;
}
get
moreFrames
(
)
{
return
this
.
paused
&
&
(
!
this
.
_frameCache
|
|
this
.
_frameCache
.
length
=
=
0
|
|
!
this
.
_frameCache
[
this
.
_frameCache
.
length
-
1
]
.
oldest
)
;
}
getEnvironment
:
function
(
frameId
)
{
return
this
.
request
(
{
to
:
frameId
type
:
"
getEnvironment
"
}
)
;
}
fillFrames
:
function
(
total
callback
=
noop
)
{
this
.
_assertPaused
(
"
fillFrames
"
)
;
if
(
this
.
_frameCache
.
length
>
=
total
)
{
return
false
;
}
const
numFrames
=
this
.
_frameCache
.
length
;
this
.
getFrames
(
numFrames
total
-
numFrames
(
response
)
=
>
{
if
(
response
.
error
)
{
callback
(
response
)
;
return
;
}
const
threadGrips
=
DevToolsUtils
.
values
(
this
.
_threadGrips
)
;
for
(
const
i
in
response
.
frames
)
{
const
frame
=
response
.
frames
[
i
]
;
if
(
!
frame
.
where
.
source
)
{
for
(
const
grip
of
threadGrips
)
{
if
(
grip
instanceof
SourceClient
&
&
grip
.
url
=
=
=
frame
.
url
)
{
frame
.
where
.
source
=
grip
.
_form
;
}
}
}
this
.
_frameCache
[
frame
.
depth
]
=
frame
;
}
this
.
emit
(
"
framesadded
"
)
;
callback
(
response
)
;
}
)
;
return
true
;
}
_clearFrames
:
function
(
)
{
if
(
this
.
_frameCache
.
length
>
0
)
{
this
.
_frameCache
=
[
]
;
this
.
emit
(
"
framescleared
"
)
;
}
}
pauseGrip
:
function
(
grip
)
{
if
(
grip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
grip
.
actor
]
;
}
const
client
=
new
ObjectClient
(
this
.
client
grip
)
;
this
.
_pauseGrips
[
grip
.
actor
]
=
client
;
return
client
;
}
_longString
:
function
(
grip
gripCacheName
)
{
if
(
grip
.
actor
in
this
[
gripCacheName
]
)
{
return
this
[
gripCacheName
]
[
grip
.
actor
]
;
}
const
client
=
new
LongStringClient
(
this
.
client
grip
)
;
this
[
gripCacheName
]
[
grip
.
actor
]
=
client
;
return
client
;
}
pauseLongString
:
function
(
grip
)
{
return
this
.
_longString
(
grip
"
_pauseGrips
"
)
;
}
threadLongString
:
function
(
grip
)
{
return
this
.
_longString
(
grip
"
_threadGrips
"
)
;
}
_arrayBuffer
:
function
(
grip
gripCacheName
)
{
if
(
grip
.
actor
in
this
[
gripCacheName
]
)
{
return
this
[
gripCacheName
]
[
grip
.
actor
]
;
}
const
client
=
new
ArrayBufferClient
(
this
.
client
grip
)
;
this
[
gripCacheName
]
[
grip
.
actor
]
=
client
;
return
client
;
}
threadArrayBuffer
:
function
(
grip
)
{
return
this
.
_arrayBuffer
(
grip
"
_threadGrips
"
)
;
}
_clearObjectClients
:
function
(
gripCacheName
)
{
for
(
const
id
in
this
[
gripCacheName
]
)
{
this
[
gripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
gripCacheName
]
=
{
}
;
}
_clearPauseGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_threadGrips
"
)
;
}
_onThreadState
:
function
(
packet
)
{
this
.
_state
=
ThreadStateTypes
[
packet
.
type
]
;
this
.
_lastPausePacket
=
packet
.
type
=
=
=
"
resumed
"
?
null
:
packet
;
this
.
_clearFrames
(
)
;
this
.
_clearPauseGrips
(
)
;
packet
.
type
=
=
=
ThreadStateTypes
.
detached
&
&
this
.
_clearThreadGrips
(
)
;
this
.
client
.
_eventsEnabled
&
&
this
.
emit
(
packet
.
type
packet
)
;
}
getLastPausePacket
:
function
(
)
{
return
this
.
_lastPausePacket
;
}
setBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
setBreakpoint
"
location
:
arg
(
0
)
options
:
arg
(
1
)
}
)
removeBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
removeBreakpoint
"
location
:
arg
(
0
)
}
)
setXHRBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
setXHRBreakpoint
"
path
:
arg
(
0
)
method
:
arg
(
1
)
}
)
removeXHRBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
removeXHRBreakpoint
"
path
:
arg
(
0
)
method
:
arg
(
1
)
}
)
source
:
function
(
form
)
{
if
(
form
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
form
.
actor
]
;
}
this
.
_threadGrips
[
form
.
actor
]
=
new
SourceClient
(
this
form
)
;
return
this
.
_threadGrips
[
form
.
actor
]
;
}
events
:
[
"
newSource
"
"
progress
"
]
}
;
eventSource
(
ThreadClient
.
prototype
)
;
module
.
exports
=
ThreadClient
;
