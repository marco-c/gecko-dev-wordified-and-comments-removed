"
use
strict
"
;
const
{
arg
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
const
eventSource
=
require
(
"
devtools
/
shared
/
client
/
event
-
source
"
)
;
const
{
ThreadStateTypes
}
=
require
(
"
devtools
/
shared
/
client
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceFront
"
"
devtools
/
shared
/
fronts
/
source
"
true
)
;
function
ThreadClient
(
client
actor
)
{
this
.
client
=
client
;
this
.
_actor
=
actor
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
request
=
this
.
client
.
request
;
}
ThreadClient
.
prototype
=
{
_state
:
"
paused
"
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
_assertPaused
:
function
(
command
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
command
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
_doResume
:
DebuggerClient
.
requester
(
{
type
:
"
resume
"
resumeLimit
:
arg
(
0
)
rewind
:
arg
(
1
)
}
{
before
:
function
(
packet
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_previousState
=
this
.
_state
;
this
.
_state
=
"
resuming
"
;
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
error
&
&
this
.
_state
=
=
"
resuming
"
)
{
if
(
response
.
state
)
{
this
.
_state
=
ThreadStateTypes
[
response
.
state
]
;
}
else
{
this
.
_state
=
this
.
_previousState
;
}
}
delete
this
.
_previousState
;
return
response
;
}
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
arg
(
0
)
}
)
resume
:
function
(
)
{
return
this
.
_doResume
(
null
false
)
;
}
resumeThenPause
:
function
(
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
false
)
;
}
rewind
:
function
(
)
{
return
this
.
_doResume
(
null
true
)
;
}
stepOver
:
function
(
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
false
)
;
}
stepIn
:
function
(
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
false
)
;
}
stepOut
:
function
(
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
false
)
;
}
reverseStepOver
:
function
(
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
true
)
;
}
interrupt
:
function
(
)
{
return
this
.
_doInterrupt
(
null
)
;
}
breakOnNext
:
function
(
)
{
return
this
.
_doInterrupt
(
"
onNext
"
)
;
}
timeWarp
:
function
(
target
)
{
const
warp
=
(
)
=
>
{
this
.
_doResume
(
{
type
:
"
warp
"
target
}
true
)
;
}
;
if
(
this
.
paused
)
{
return
warp
(
)
;
}
return
this
.
interrupt
(
)
.
then
(
warp
)
;
}
_doInterrupt
:
DebuggerClient
.
requester
(
{
type
:
"
interrupt
"
when
:
arg
(
0
)
}
)
pauseOnExceptions
:
DebuggerClient
.
requester
(
{
type
:
"
pauseOnExceptions
"
pauseOnExceptions
:
arg
(
0
)
ignoreCaughtExceptions
:
arg
(
1
)
}
)
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
response
)
{
this
.
client
.
unregisterClient
(
this
)
;
return
response
;
}
}
)
threadGrips
:
DebuggerClient
.
requester
(
{
type
:
"
threadGrips
"
actors
:
arg
(
0
)
}
)
getSources
:
DebuggerClient
.
requester
(
{
type
:
"
sources
"
}
)
getFrames
:
DebuggerClient
.
requester
(
{
type
:
"
frames
"
start
:
arg
(
0
)
count
:
arg
(
1
)
}
)
skipBreakpoints
:
DebuggerClient
.
requester
(
{
type
:
"
skipBreakpoints
"
skip
:
arg
(
0
)
}
)
getEnvironment
:
function
(
frameId
)
{
return
this
.
request
(
{
to
:
frameId
type
:
"
getEnvironment
"
}
)
;
}
pauseGrip
:
function
(
grip
)
{
if
(
grip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
grip
.
actor
]
;
}
const
client
=
new
ObjectClient
(
this
.
client
grip
)
;
this
.
_pauseGrips
[
grip
.
actor
]
=
client
;
return
client
;
}
_clearObjectClients
:
function
(
gripCacheName
)
{
for
(
const
id
in
this
[
gripCacheName
]
)
{
this
[
gripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
gripCacheName
]
=
{
}
;
}
_clearPauseGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_threadGrips
"
)
;
}
_onThreadState
:
function
(
packet
)
{
this
.
_state
=
ThreadStateTypes
[
packet
.
type
]
;
this
.
_lastPausePacket
=
packet
.
type
=
=
=
"
resumed
"
?
null
:
packet
;
this
.
_clearPauseGrips
(
)
;
packet
.
type
=
=
=
ThreadStateTypes
.
detached
&
&
this
.
_clearThreadGrips
(
)
;
this
.
client
.
_eventsEnabled
&
&
this
.
emit
(
packet
.
type
packet
)
;
}
getLastPausePacket
:
function
(
)
{
return
this
.
_lastPausePacket
;
}
setBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
setBreakpoint
"
location
:
arg
(
0
)
options
:
arg
(
1
)
}
)
removeBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
removeBreakpoint
"
location
:
arg
(
0
)
}
)
setXHRBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
setXHRBreakpoint
"
path
:
arg
(
0
)
method
:
arg
(
1
)
}
)
removeXHRBreakpoint
:
DebuggerClient
.
requester
(
{
type
:
"
removeXHRBreakpoint
"
path
:
arg
(
0
)
method
:
arg
(
1
)
}
)
getAvailableEventBreakpoints
:
DebuggerClient
.
requester
(
{
type
:
"
getAvailableEventBreakpoints
"
}
)
getActiveEventBreakpoints
:
DebuggerClient
.
requester
(
{
type
:
"
getActiveEventBreakpoints
"
}
)
setActiveEventBreakpoints
:
DebuggerClient
.
requester
(
{
type
:
"
setActiveEventBreakpoints
"
ids
:
arg
(
0
)
}
)
source
:
function
(
form
)
{
if
(
form
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
form
.
actor
]
;
}
this
.
_threadGrips
[
form
.
actor
]
=
new
SourceFront
(
this
.
client
form
)
;
return
this
.
_threadGrips
[
form
.
actor
]
;
}
events
:
[
"
newSource
"
"
progress
"
]
}
;
eventSource
(
ThreadClient
.
prototype
)
;
module
.
exports
=
ThreadClient
;
