"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
devtools
/
shared
/
deprecated
-
sync
-
thenables
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
const
eventSource
=
require
(
"
devtools
/
shared
/
client
/
event
-
source
"
)
;
const
{
ThreadStateTypes
UnsolicitedNotifications
UnsolicitedPauses
}
=
require
(
"
.
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
Authentication
"
"
devtools
/
shared
/
security
/
auth
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerSocket
"
"
devtools
/
shared
/
security
/
socket
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
getDeviceFront
"
"
devtools
/
shared
/
fronts
/
device
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleClient
"
"
devtools
/
shared
/
webconsole
/
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AddonClient
"
"
devtools
/
shared
/
client
/
addon
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
RootClient
"
"
devtools
/
shared
/
client
/
root
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
TabClient
"
"
devtools
/
shared
/
client
/
tab
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadClient
"
"
devtools
/
shared
/
client
/
thread
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
TraceClient
"
"
devtools
/
shared
/
client
/
trace
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerClient
"
"
devtools
/
shared
/
client
/
worker
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
const
noop
=
(
)
=
>
{
}
;
const
MIN_SUPPORTED_PLATFORM_VERSION
=
"
52
.
0a1
"
;
const
MS_PER_DAY
=
86400000
;
function
DebuggerClient
(
transport
)
{
this
.
_transport
=
transport
;
this
.
_transport
.
hooks
=
this
;
this
.
_clients
=
new
Map
(
)
;
this
.
_pendingRequests
=
new
Map
(
)
;
this
.
_activeRequests
=
new
Map
(
)
;
this
.
_eventsEnabled
=
true
;
this
.
traits
=
{
}
;
this
.
request
=
this
.
request
.
bind
(
this
)
;
this
.
localTransport
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
;
this
.
mainRoot
=
null
;
this
.
expectReply
(
"
root
"
(
packet
)
=
>
{
this
.
mainRoot
=
new
RootClient
(
this
packet
)
;
this
.
emit
(
"
connected
"
packet
.
applicationType
packet
.
traits
)
;
}
)
;
}
DebuggerClient
.
requester
=
function
(
packetSkeleton
config
=
{
}
)
{
const
{
before
after
}
=
config
;
return
DevToolsUtils
.
makeInfallible
(
function
(
.
.
.
args
)
{
let
outgoingPacket
=
{
to
:
packetSkeleton
.
to
|
|
this
.
actor
}
;
let
maxPosition
=
-
1
;
for
(
const
k
of
Object
.
keys
(
packetSkeleton
)
)
{
if
(
packetSkeleton
[
k
]
instanceof
DebuggerClient
.
Argument
)
{
const
{
position
}
=
packetSkeleton
[
k
]
;
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
.
getArgument
(
args
)
;
maxPosition
=
Math
.
max
(
position
maxPosition
)
;
}
else
{
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
;
}
}
if
(
before
)
{
outgoingPacket
=
before
.
call
(
this
outgoingPacket
)
;
}
return
this
.
request
(
outgoingPacket
DevToolsUtils
.
makeInfallible
(
(
response
)
=
>
{
if
(
after
)
{
const
{
from
}
=
response
;
response
=
after
.
call
(
this
response
)
;
if
(
!
response
.
from
)
{
response
.
from
=
from
;
}
}
const
thisCallback
=
args
[
maxPosition
+
1
]
;
if
(
thisCallback
)
{
thisCallback
(
response
)
;
}
return
response
;
}
"
DebuggerClient
.
requester
request
callback
"
)
)
;
}
"
DebuggerClient
.
requester
"
)
;
}
;
function
arg
(
pos
)
{
return
new
DebuggerClient
.
Argument
(
pos
)
;
}
exports
.
arg
=
arg
;
DebuggerClient
.
Argument
=
function
(
position
)
{
this
.
position
=
position
;
}
;
DebuggerClient
.
Argument
.
prototype
.
getArgument
=
function
(
params
)
{
if
(
!
(
this
.
position
in
params
)
)
{
throw
new
Error
(
"
Bad
index
into
params
:
"
+
this
.
position
)
;
}
return
params
[
this
.
position
]
;
}
;
DebuggerClient
.
socketConnect
=
function
(
options
)
{
return
DebuggerSocket
.
connect
(
options
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
DebuggerClient
.
prototype
=
{
connect
:
function
(
onConnected
)
{
const
deferred
=
promise
.
defer
(
)
;
this
.
addOneTimeListener
(
"
connected
"
(
name
applicationType
traits
)
=
>
{
this
.
traits
=
traits
;
if
(
onConnected
)
{
onConnected
(
applicationType
traits
)
;
}
deferred
.
resolve
(
[
applicationType
traits
]
)
;
}
)
;
this
.
_transport
.
ready
(
)
;
return
deferred
.
promise
;
}
async
checkRuntimeVersion
(
listTabsForm
)
{
let
incompatible
=
null
;
const
deviceFront
=
await
getDeviceFront
(
this
listTabsForm
)
;
const
desc
=
await
deviceFront
.
getDescription
(
)
;
const
runtimeID
=
desc
.
appbuildid
.
substr
(
0
8
)
;
const
localID
=
Services
.
appinfo
.
appBuildID
.
substr
(
0
8
)
;
function
buildIDToDate
(
buildID
)
{
const
fields
=
buildID
.
match
(
/
(
\
d
{
4
}
)
(
\
d
{
2
}
)
(
\
d
{
2
}
)
/
)
;
return
new
Date
(
fields
[
1
]
Number
.
parseInt
(
fields
[
2
]
10
)
-
1
fields
[
3
]
)
;
}
const
runtimeDate
=
buildIDToDate
(
runtimeID
)
;
const
localDate
=
buildIDToDate
(
localID
)
;
if
(
runtimeDate
-
localDate
>
7
*
MS_PER_DAY
)
{
incompatible
=
"
too
-
recent
"
;
}
const
platformversion
=
desc
.
platformversion
;
if
(
Services
.
vc
.
compare
(
platformversion
MIN_SUPPORTED_PLATFORM_VERSION
)
<
0
)
{
incompatible
=
"
too
-
old
"
;
}
return
{
incompatible
minVersion
:
MIN_SUPPORTED_PLATFORM_VERSION
runtimeVersion
:
platformversion
localID
runtimeID
}
;
}
close
:
function
(
onClosed
)
{
const
deferred
=
promise
.
defer
(
)
;
if
(
onClosed
)
{
deferred
.
promise
.
then
(
onClosed
)
;
}
this
.
_eventsEnabled
=
false
;
const
cleanup
=
(
)
=
>
{
this
.
_transport
.
close
(
)
;
this
.
_transport
=
null
;
}
;
if
(
this
.
_closed
)
{
cleanup
(
)
;
deferred
.
resolve
(
)
;
return
deferred
.
promise
;
}
this
.
addOneTimeListener
(
"
closed
"
deferred
.
resolve
)
;
const
clients
=
[
.
.
.
this
.
_clients
.
values
(
)
]
;
this
.
_clients
.
clear
(
)
;
const
detachClients
=
(
)
=
>
{
const
client
=
clients
.
pop
(
)
;
if
(
!
client
)
{
cleanup
(
)
;
return
;
}
if
(
client
.
detach
)
{
client
.
detach
(
detachClients
)
;
return
;
}
detachClients
(
)
;
}
;
detachClients
(
)
;
return
deferred
.
promise
;
}
listTabs
:
function
(
options
onResponse
)
{
return
this
.
mainRoot
.
listTabs
(
options
onResponse
)
;
}
listAddons
:
function
(
onResponse
)
{
return
this
.
mainRoot
.
listAddons
(
onResponse
)
;
}
getTab
:
function
(
filter
)
{
return
this
.
mainRoot
.
getTab
(
filter
)
;
}
attachTab
:
function
(
targetActor
onResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
targetActor
)
)
{
const
cachedTab
=
this
.
_clients
.
get
(
targetActor
)
;
const
cachedResponse
=
{
cacheDisabled
:
cachedTab
.
cacheDisabled
javascriptEnabled
:
cachedTab
.
javascriptEnabled
traits
:
cachedTab
.
traits
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
cachedResponse
cachedTab
)
)
;
return
promise
.
resolve
(
[
cachedResponse
cachedTab
]
)
;
}
const
packet
=
{
to
:
targetActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
tabClient
;
if
(
!
response
.
error
)
{
tabClient
=
new
TabClient
(
this
response
)
;
this
.
registerClient
(
tabClient
)
;
}
onResponse
(
response
tabClient
)
;
return
[
response
tabClient
]
;
}
)
;
}
attachWorker
:
function
(
workerTargetActor
onResponse
=
noop
)
{
let
workerClient
=
this
.
_clients
.
get
(
workerTargetActor
)
;
if
(
workerClient
!
=
=
undefined
)
{
const
response
=
{
from
:
workerClient
.
actor
type
:
"
attached
"
url
:
workerClient
.
url
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
response
workerClient
)
)
;
return
promise
.
resolve
(
[
response
workerClient
]
)
;
}
return
this
.
request
(
{
to
:
workerTargetActor
type
:
"
attach
"
}
)
.
then
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
null
)
;
return
[
response
null
]
;
}
workerClient
=
new
WorkerClient
(
this
response
)
;
this
.
registerClient
(
workerClient
)
;
onResponse
(
response
workerClient
)
;
return
[
response
workerClient
]
;
}
)
;
}
attachAddon
:
function
(
addonTargetActor
onResponse
=
noop
)
{
const
packet
=
{
to
:
addonTargetActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
addonClient
;
if
(
!
response
.
error
)
{
addonClient
=
new
AddonClient
(
this
addonTargetActor
)
;
this
.
registerClient
(
addonClient
)
;
this
.
activeAddon
=
addonClient
;
}
onResponse
(
response
addonClient
)
;
return
[
response
addonClient
]
;
}
)
;
}
attachConsole
:
function
(
consoleActor
listeners
onResponse
=
noop
)
{
const
packet
=
{
to
:
consoleActor
type
:
"
startListeners
"
listeners
:
listeners
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
consoleClient
;
if
(
!
response
.
error
)
{
if
(
this
.
_clients
.
has
(
consoleActor
)
)
{
consoleClient
=
this
.
_clients
.
get
(
consoleActor
)
;
}
else
{
consoleClient
=
new
WebConsoleClient
(
this
response
)
;
this
.
registerClient
(
consoleClient
)
;
}
}
onResponse
(
response
consoleClient
)
;
return
[
response
consoleClient
]
;
}
)
;
}
attachThread
:
function
(
threadActor
onResponse
=
noop
options
=
{
}
)
{
if
(
this
.
_clients
.
has
(
threadActor
)
)
{
const
client
=
this
.
_clients
.
get
(
threadActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
const
packet
=
{
to
:
threadActor
type
:
"
attach
"
options
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
threadClient
;
if
(
!
response
.
error
)
{
threadClient
=
new
ThreadClient
(
this
threadActor
)
;
this
.
registerClient
(
threadClient
)
;
}
onResponse
(
response
threadClient
)
;
return
[
response
threadClient
]
;
}
)
;
}
attachTracer
:
function
(
traceActor
onResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
traceActor
)
)
{
const
client
=
this
.
_clients
.
get
(
traceActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
const
packet
=
{
to
:
traceActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
traceClient
;
if
(
!
response
.
error
)
{
traceClient
=
new
TraceClient
(
this
traceActor
)
;
this
.
registerClient
(
traceClient
)
;
}
onResponse
(
response
traceClient
)
;
return
[
response
traceClient
]
;
}
)
;
}
getProcess
:
function
(
id
)
{
const
packet
=
{
to
:
"
root
"
type
:
"
getProcess
"
}
;
if
(
typeof
(
id
)
=
=
"
number
"
)
{
packet
.
id
=
id
;
}
return
this
.
request
(
packet
)
;
}
release
:
DebuggerClient
.
requester
(
{
to
:
arg
(
0
)
type
:
"
release
"
}
)
request
:
function
(
packet
onResponse
)
{
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
const
type
=
packet
.
type
|
|
"
"
;
if
(
!
packet
.
to
)
{
throw
Error
(
"
'
"
+
type
+
"
'
request
packet
has
no
destination
.
"
)
;
}
const
safeOnResponse
=
response
=
>
{
if
(
!
onResponse
)
{
return
response
;
}
return
onResponse
(
response
)
|
|
response
;
}
;
if
(
this
.
_closed
)
{
const
msg
=
"
'
"
+
type
+
"
'
request
packet
to
"
+
"
'
"
+
packet
.
to
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
is
closed
.
"
;
const
resp
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
return
promise
.
reject
(
safeOnResponse
(
resp
)
)
;
}
const
request
=
new
Request
(
packet
)
;
request
.
format
=
"
json
"
;
request
.
stack
=
getStack
(
)
;
const
deferred
=
promise
.
defer
(
)
;
function
listenerJson
(
resp
)
{
removeRequestListeners
(
)
;
if
(
resp
.
error
)
{
deferred
.
reject
(
safeOnResponse
(
resp
)
)
;
}
else
{
deferred
.
resolve
(
safeOnResponse
(
resp
)
)
;
}
}
function
listenerBulk
(
resp
)
{
removeRequestListeners
(
)
;
deferred
.
resolve
(
safeOnResponse
(
resp
)
)
;
}
const
removeRequestListeners
=
(
)
=
>
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
}
;
request
.
on
(
"
json
-
reply
"
listenerJson
)
;
request
.
on
(
"
bulk
-
reply
"
listenerBulk
)
;
this
.
_sendOrQueueRequest
(
request
)
;
request
.
then
=
deferred
.
promise
.
then
.
bind
(
deferred
.
promise
)
;
return
request
;
}
startBulkRequest
:
function
(
request
)
{
if
(
!
this
.
traits
.
bulk
)
{
throw
Error
(
"
Server
doesn
'
t
support
bulk
transfers
"
)
;
}
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
if
(
!
request
.
type
)
{
throw
Error
(
"
Bulk
packet
is
missing
the
required
'
type
'
field
.
"
)
;
}
if
(
!
request
.
actor
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
destination
.
"
)
;
}
if
(
!
request
.
length
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
length
.
"
)
;
}
request
=
new
Request
(
request
)
;
request
.
format
=
"
bulk
"
;
this
.
_sendOrQueueRequest
(
request
)
;
return
request
;
}
_sendOrQueueRequest
(
request
)
{
const
actor
=
request
.
actor
;
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
this
.
_sendRequest
(
request
)
;
}
else
{
this
.
_queueRequest
(
request
)
;
}
}
_sendRequest
(
request
)
{
const
actor
=
request
.
actor
;
this
.
expectReply
(
actor
request
)
;
if
(
request
.
format
=
=
=
"
json
"
)
{
this
.
_transport
.
send
(
request
.
request
)
;
return
;
}
this
.
_transport
.
startBulkSend
(
request
.
request
)
.
then
(
(
.
.
.
args
)
=
>
{
request
.
emit
(
"
bulk
-
send
-
ready
"
.
.
.
args
)
;
}
)
;
}
_queueRequest
(
request
)
{
const
actor
=
request
.
actor
;
const
queue
=
this
.
_pendingRequests
.
get
(
actor
)
|
|
[
]
;
queue
.
push
(
request
)
;
this
.
_pendingRequests
.
set
(
actor
queue
)
;
}
_attemptNextRequest
(
actor
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
const
queue
=
this
.
_pendingRequests
.
get
(
actor
)
;
if
(
!
queue
)
{
return
;
}
const
request
=
queue
.
shift
(
)
;
if
(
queue
.
length
=
=
=
0
)
{
this
.
_pendingRequests
.
delete
(
actor
)
;
}
this
.
_sendRequest
(
request
)
;
}
expectReply
:
function
(
actor
request
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
throw
Error
(
"
clashing
handlers
for
next
reply
from
"
+
actor
)
;
}
if
(
typeof
request
=
=
=
"
function
"
)
{
const
handler
=
request
;
request
=
new
Request
(
)
;
request
.
on
(
"
json
-
reply
"
handler
)
;
}
this
.
_activeRequests
.
set
(
actor
request
)
;
}
onPacket
:
function
(
packet
)
{
if
(
!
packet
.
from
)
{
DevToolsUtils
.
reportException
(
"
onPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
const
front
=
this
.
getActor
(
packet
.
from
)
;
if
(
front
)
{
front
.
onPacket
(
packet
)
;
return
;
}
if
(
this
.
mainRoot
&
&
packet
.
from
=
=
this
.
mainRoot
.
actor
&
&
packet
.
type
=
=
"
forwardingCancelled
"
)
{
this
.
purgeRequests
(
packet
.
prefix
)
;
return
;
}
if
(
this
.
_clients
.
has
(
packet
.
from
)
&
&
packet
.
type
)
{
const
client
=
this
.
_clients
.
get
(
packet
.
from
)
;
const
type
=
packet
.
type
;
if
(
client
.
events
.
includes
(
type
)
)
{
client
.
emit
(
type
packet
)
;
return
;
}
}
let
activeRequest
;
if
(
this
.
_activeRequests
.
has
(
packet
.
from
)
&
&
!
(
packet
.
type
in
UnsolicitedNotifications
)
&
&
!
(
packet
.
type
=
=
ThreadStateTypes
.
paused
&
&
packet
.
why
.
type
in
UnsolicitedPauses
)
)
{
activeRequest
=
this
.
_activeRequests
.
get
(
packet
.
from
)
;
this
.
_activeRequests
.
delete
(
packet
.
from
)
;
}
this
.
_attemptNextRequest
(
packet
.
from
)
;
if
(
packet
.
type
in
ThreadStateTypes
&
&
this
.
_clients
.
has
(
packet
.
from
)
&
&
typeof
this
.
_clients
.
get
(
packet
.
from
)
.
_onThreadState
=
=
"
function
"
)
{
this
.
_clients
.
get
(
packet
.
from
)
.
_onThreadState
(
packet
)
;
}
if
(
packet
.
type
)
{
this
.
emit
(
packet
.
type
packet
)
;
}
if
(
activeRequest
)
{
const
emitReply
=
(
)
=
>
activeRequest
.
emit
(
"
json
-
reply
"
packet
)
;
if
(
activeRequest
.
stack
)
{
callFunctionWithAsyncStack
(
emitReply
activeRequest
.
stack
"
DevTools
RDP
"
)
;
}
else
{
emitReply
(
)
;
}
}
}
onBulkPacket
:
function
(
packet
)
{
const
{
actor
}
=
packet
;
if
(
!
actor
)
{
DevToolsUtils
.
reportException
(
"
onBulkPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
bulk
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
const
activeRequest
=
this
.
_activeRequests
.
get
(
actor
)
;
this
.
_activeRequests
.
delete
(
actor
)
;
this
.
_attemptNextRequest
(
actor
)
;
activeRequest
.
emit
(
"
bulk
-
reply
"
packet
)
;
}
onClosed
:
function
(
)
{
this
.
_closed
=
true
;
this
.
emit
(
"
closed
"
)
;
this
.
purgeRequests
(
)
;
for
(
const
pool
of
this
.
_pools
)
{
pool
.
cleanup
(
)
;
}
}
purgeRequests
(
prefix
=
"
"
)
{
const
reject
=
function
(
type
request
)
{
let
msg
;
if
(
request
.
request
)
{
msg
=
"
'
"
+
request
.
request
.
type
+
"
'
"
+
type
+
"
request
packet
"
+
"
to
'
"
+
request
.
actor
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
just
closed
.
"
;
}
else
{
msg
=
"
server
side
packet
can
'
t
be
received
as
the
connection
just
closed
.
"
;
}
const
packet
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
request
.
emit
(
"
json
-
reply
"
packet
)
;
}
;
let
pendingRequestsToReject
=
[
]
;
this
.
_pendingRequests
.
forEach
(
(
requests
actor
)
=
>
{
if
(
!
actor
.
startsWith
(
prefix
)
)
{
return
;
}
this
.
_pendingRequests
.
delete
(
actor
)
;
pendingRequestsToReject
=
pendingRequestsToReject
.
concat
(
requests
)
;
}
)
;
pendingRequestsToReject
.
forEach
(
request
=
>
reject
(
"
pending
"
request
)
)
;
let
activeRequestsToReject
=
[
]
;
this
.
_activeRequests
.
forEach
(
(
request
actor
)
=
>
{
if
(
!
actor
.
startsWith
(
prefix
)
)
{
return
;
}
this
.
_activeRequests
.
delete
(
actor
)
;
activeRequestsToReject
=
activeRequestsToReject
.
concat
(
request
)
;
}
)
;
activeRequestsToReject
.
forEach
(
request
=
>
reject
(
"
active
"
request
)
)
;
}
waitForRequestsToSettle
(
)
{
let
requests
=
[
]
;
this
.
_pendingRequests
.
forEach
(
requestsForActor
=
>
{
requests
=
requests
.
concat
(
requestsForActor
)
;
}
)
;
this
.
_activeRequests
.
forEach
(
requestForActor
=
>
{
requests
=
requests
.
concat
(
requestForActor
)
;
}
)
;
const
fronts
=
new
Set
(
)
;
const
poolsToVisit
=
[
.
.
.
this
.
_pools
]
;
while
(
poolsToVisit
.
length
)
{
const
pool
=
poolsToVisit
.
shift
(
)
;
fronts
.
add
(
pool
)
;
for
(
const
child
of
pool
.
poolChildren
(
)
)
{
poolsToVisit
.
push
(
child
)
;
}
}
for
(
const
front
of
fronts
)
{
if
(
front
.
hasRequests
(
)
)
{
requests
.
push
(
front
.
waitForRequestsToSettle
(
)
)
;
}
}
if
(
!
requests
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
DevToolsUtils
.
settleAll
(
requests
)
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
return
this
.
waitForRequestsToSettle
(
)
;
}
)
;
}
registerClient
:
function
(
client
)
{
const
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
actor
attribute
.
"
)
;
}
if
(
!
Array
.
isArray
(
client
.
events
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
events
attribute
"
+
"
that
is
an
array
.
"
)
;
}
if
(
client
.
events
.
length
>
0
&
&
typeof
(
client
.
emit
)
!
=
"
function
"
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
non
-
empty
events
array
to
"
+
"
have
an
emit
function
.
"
)
;
}
if
(
this
.
_clients
.
has
(
actorID
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
already
registered
"
+
"
a
client
for
this
actor
.
"
)
;
}
this
.
_clients
.
set
(
actorID
client
)
;
}
unregisterClient
:
function
(
client
)
{
const
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
unregisterClient
expects
"
+
"
a
Client
instance
with
a
actor
attribute
.
"
)
;
}
this
.
_clients
.
delete
(
actorID
)
;
}
__pools
:
null
get
_pools
(
)
{
if
(
this
.
__pools
)
{
return
this
.
__pools
;
}
this
.
__pools
=
new
Set
(
)
;
return
this
.
__pools
;
}
addActorPool
:
function
(
pool
)
{
this
.
_pools
.
add
(
pool
)
;
}
removeActorPool
:
function
(
pool
)
{
this
.
_pools
.
delete
(
pool
)
;
}
getActor
:
function
(
actorID
)
{
const
pool
=
this
.
poolFor
(
actorID
)
;
return
pool
?
pool
.
get
(
actorID
)
:
null
;
}
poolFor
:
function
(
actorID
)
{
for
(
const
pool
of
this
.
_pools
)
{
if
(
pool
.
has
(
actorID
)
)
{
return
pool
;
}
}
return
null
;
}
activeAddon
:
null
createObjectClient
:
function
(
grip
)
{
return
new
ObjectClient
(
this
grip
)
;
}
}
;
eventSource
(
DebuggerClient
.
prototype
)
;
class
Request
extends
EventEmitter
{
constructor
(
request
)
{
super
(
)
;
this
.
request
=
request
;
}
get
actor
(
)
{
return
this
.
request
.
to
|
|
this
.
request
.
actor
;
}
}
module
.
exports
=
{
arg
DebuggerClient
}
;
