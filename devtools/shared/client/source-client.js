"
use
strict
"
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointClient
"
"
devtools
/
shared
/
client
/
breakpoint
-
client
"
)
;
const
noop
=
(
)
=
>
{
}
;
function
SourceClient
(
client
form
)
{
this
.
_form
=
form
;
this
.
_isBlackBoxed
=
form
.
isBlackBoxed
;
this
.
_activeThread
=
client
;
this
.
_client
=
client
.
client
;
}
SourceClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
isBlackBoxed
(
)
{
return
this
.
_isBlackBoxed
;
}
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
get
url
(
)
{
return
this
.
_form
.
url
;
}
blackBox
:
DebuggerClient
.
requester
(
{
type
:
"
blackbox
"
}
{
after
:
function
(
response
)
{
if
(
!
response
.
error
)
{
this
.
_isBlackBoxed
=
true
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
response
;
}
}
)
unblackBox
:
DebuggerClient
.
requester
(
{
type
:
"
unblackbox
"
}
{
after
:
function
(
response
)
{
if
(
!
response
.
error
)
{
this
.
_isBlackBoxed
=
false
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
response
;
}
}
)
getExecutableLines
:
function
(
cb
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
getExecutableLines
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
res
=
>
{
cb
(
res
.
lines
)
;
return
res
.
lines
;
}
)
;
}
source
:
function
(
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
source
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
return
this
.
_onSourceResponse
(
response
)
;
}
)
;
}
_onSourceResponse
:
function
(
response
)
{
if
(
typeof
response
.
source
=
=
=
"
string
"
)
{
return
response
;
}
const
{
contentType
source
}
=
response
;
if
(
source
.
type
=
=
=
"
arrayBuffer
"
)
{
const
arrayBuffer
=
this
.
_activeThread
.
threadArrayBuffer
(
source
)
;
return
arrayBuffer
.
slice
(
0
arrayBuffer
.
length
)
.
then
(
function
(
resp
)
{
if
(
resp
.
error
)
{
return
resp
;
}
const
str
=
atob
(
resp
.
encoded
)
;
const
newResponse
=
{
source
:
{
binary
:
str
toString
:
(
)
=
>
"
[
wasm
]
"
}
contentType
}
;
return
newResponse
;
}
)
;
}
const
longString
=
this
.
_activeThread
.
threadLongString
(
source
)
;
return
longString
.
substring
(
0
longString
.
length
)
.
then
(
function
(
resp
)
{
if
(
resp
.
error
)
{
return
resp
;
}
const
newResponse
=
{
source
:
resp
.
substring
contentType
:
contentType
}
;
return
newResponse
;
}
)
;
}
setBreakpoint
:
function
(
{
line
column
condition
noSliding
}
)
{
const
doSetBreakpoint
=
callback
=
>
{
const
root
=
this
.
_client
.
mainRoot
;
const
location
=
{
line
column
}
;
const
packet
=
{
to
:
this
.
actor
type
:
"
setBreakpoint
"
location
condition
noSliding
}
;
if
(
!
root
.
traits
.
debuggerSourceActors
)
{
packet
.
to
=
this
.
_activeThread
.
actor
;
packet
.
location
.
url
=
this
.
url
;
}
return
this
.
_client
.
request
(
packet
)
.
then
(
response
=
>
{
let
bpClient
;
if
(
response
.
actor
)
{
bpClient
=
new
BreakpointClient
(
this
.
_client
this
response
.
actor
location
root
.
traits
.
conditionalBreakpoints
?
condition
:
undefined
)
;
}
if
(
callback
)
{
callback
(
)
;
}
return
[
response
bpClient
]
;
}
)
;
}
;
if
(
this
.
_activeThread
.
paused
)
{
return
doSetBreakpoint
(
)
;
}
return
this
.
_activeThread
.
interrupt
(
)
.
then
(
response
=
>
{
if
(
response
.
error
)
{
return
response
;
}
const
{
type
why
}
=
response
;
const
cleanUp
=
type
=
=
"
paused
"
&
&
why
.
type
=
=
"
interrupted
"
?
(
)
=
>
this
.
_activeThread
.
resume
(
)
:
noop
;
return
doSetBreakpoint
(
cleanUp
)
;
}
)
;
}
setPausePoints
:
function
(
pausePoints
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
setPausePoints
"
pausePoints
}
;
return
this
.
_client
.
request
(
packet
)
;
}
}
;
module
.
exports
=
SourceClient
;
