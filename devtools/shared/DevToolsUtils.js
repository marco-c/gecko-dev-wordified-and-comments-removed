"
use
strict
"
;
var
{
Ci
Cc
Cu
components
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
var
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
loader
.
lazyRequireGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectUtils
"
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
true
)
;
var
DevToolsUtils
=
exports
;
const
ThreadSafeDevToolsUtils
=
require
(
"
devtools
/
shared
/
ThreadSafeDevToolsUtils
.
js
"
)
;
for
(
const
key
of
Object
.
keys
(
ThreadSafeDevToolsUtils
)
)
{
exports
[
key
]
=
ThreadSafeDevToolsUtils
[
key
]
;
}
exports
.
executeSoon
=
function
(
fn
)
{
if
(
isWorker
)
{
setImmediate
(
fn
)
;
}
else
{
let
executor
;
if
(
AppConstants
.
DEBUG_JS_MODULES
|
|
flags
.
testing
)
{
const
stack
=
getStack
(
)
;
executor
=
(
)
=
>
{
callFunctionWithAsyncStack
(
fn
stack
"
DevToolsUtils
.
executeSoon
"
)
;
}
;
}
else
{
executor
=
fn
;
}
Services
.
tm
.
dispatchToMainThread
(
{
run
:
exports
.
makeInfallible
(
executor
)
}
)
;
}
}
;
exports
.
executeSoonWithMicroTask
=
function
(
fn
)
{
if
(
isWorker
)
{
setImmediate
(
fn
)
;
}
else
{
let
executor
;
if
(
AppConstants
.
DEBUG_JS_MODULES
|
|
flags
.
testing
)
{
const
stack
=
getStack
(
)
;
executor
=
(
)
=
>
{
callFunctionWithAsyncStack
(
fn
stack
"
DevToolsUtils
.
executeSoonWithMicroTask
"
)
;
}
;
}
else
{
executor
=
fn
;
}
Services
.
tm
.
dispatchToMainThreadWithMicroTask
(
{
run
:
exports
.
makeInfallible
(
executor
)
}
)
;
}
}
;
exports
.
waitForTick
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
exports
.
executeSoon
(
resolve
)
;
}
)
;
}
;
exports
.
waitForTime
=
function
(
delay
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
delay
)
)
;
}
;
exports
.
defineLazyPrototypeGetter
=
function
(
object
key
callback
)
{
Object
.
defineProperty
(
object
key
{
configurable
:
true
get
(
)
{
const
value
=
callback
.
call
(
this
)
;
Object
.
defineProperty
(
this
key
{
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
}
)
;
}
;
exports
.
getProperty
=
function
(
object
key
invokeUnsafeGetters
=
false
)
{
const
root
=
object
;
while
(
object
&
&
exports
.
isSafeDebuggerObject
(
object
)
)
{
let
desc
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
key
)
;
}
catch
(
e
)
{
return
undefined
;
}
if
(
desc
)
{
if
(
"
value
"
in
desc
)
{
return
desc
.
value
;
}
if
(
exports
.
hasSafeGetter
(
desc
)
|
|
invokeUnsafeGetters
=
=
=
true
)
{
try
{
return
desc
.
get
.
call
(
root
)
.
return
;
}
catch
(
e
)
{
exports
.
reportException
(
"
getProperty
"
e
)
;
}
}
return
undefined
;
}
object
=
object
.
proto
;
}
return
undefined
;
}
;
exports
.
unwrap
=
function
unwrap
(
obj
)
{
if
(
obj
.
class
=
=
=
"
Opaque
"
)
{
return
obj
;
}
let
unwrapped
;
try
{
unwrapped
=
obj
.
unwrap
(
)
;
}
catch
(
err
)
{
return
undefined
;
}
if
(
!
unwrapped
|
|
unwrapped
=
=
=
obj
)
{
return
unwrapped
;
}
return
unwrap
(
unwrapped
)
;
}
;
exports
.
isSafeDebuggerObject
=
function
(
obj
)
{
const
unwrapped
=
exports
.
unwrap
(
obj
)
;
if
(
unwrapped
=
=
=
undefined
)
{
return
false
;
}
if
(
unwrapped
=
=
=
null
)
{
return
true
;
}
if
(
unwrapped
.
isProxy
)
{
return
false
;
}
return
true
;
}
;
exports
.
hasSafeGetter
=
function
(
desc
)
{
let
fn
=
desc
.
get
;
fn
=
fn
&
&
exports
.
unwrap
(
fn
)
;
return
fn
?
.
callable
&
&
fn
?
.
class
=
=
"
Function
"
&
&
fn
?
.
script
=
=
=
undefined
;
}
;
exports
.
isUnsafeGetter
=
function
(
object
key
)
{
while
(
object
&
&
exports
.
isSafeDebuggerObject
(
object
)
)
{
let
desc
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
key
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
desc
)
{
if
(
Object
.
getOwnPropertyNames
(
desc
)
.
includes
(
"
get
"
)
)
{
return
!
exports
.
hasSafeGetter
(
desc
)
;
}
}
object
=
object
.
proto
;
}
return
false
;
}
;
exports
.
isSafeJSObject
=
function
(
obj
)
{
if
(
isWorker
)
{
return
false
;
}
if
(
Cu
.
getGlobalForObject
(
obj
)
=
=
Cu
.
getGlobalForObject
(
exports
.
isSafeJSObject
)
)
{
return
true
;
}
if
(
Cu
.
isXrayWrapper
(
obj
)
)
{
return
true
;
}
const
principal
=
Cu
.
getObjectPrincipal
(
obj
)
;
if
(
!
principal
.
isSystemPrincipal
)
{
return
false
;
}
if
(
Cu
.
isProxy
(
obj
)
)
{
return
false
;
}
const
proto
=
Object
.
getPrototypeOf
(
obj
)
;
if
(
proto
&
&
!
exports
.
isSafeJSObject
(
proto
)
)
{
return
false
;
}
return
true
;
}
;
exports
.
dumpn
=
function
(
str
)
{
if
(
flags
.
wantLogging
)
{
dump
(
"
DBG
-
SERVER
:
"
+
str
+
"
\
n
"
)
;
}
}
;
exports
.
dumpv
=
function
(
msg
)
{
if
(
flags
.
wantVerbose
)
{
exports
.
dumpn
(
msg
)
;
}
}
;
exports
.
defineLazyGetter
=
function
(
object
name
lambda
)
{
Object
.
defineProperty
(
object
name
{
get
(
)
{
delete
object
[
name
]
;
object
[
name
]
=
lambda
.
apply
(
object
)
;
return
object
[
name
]
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
this
"
AppConstants
"
(
)
=
>
{
if
(
isWorker
)
{
return
{
}
;
}
return
require
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
.
AppConstants
;
}
)
;
exports
.
noop
=
function
(
)
{
}
;
let
assertionFailureCount
=
0
;
Object
.
defineProperty
(
exports
"
assertionFailureCount
"
{
get
(
)
{
return
assertionFailureCount
;
}
}
)
;
function
reallyAssert
(
condition
message
)
{
if
(
!
condition
)
{
assertionFailureCount
+
+
;
const
err
=
new
Error
(
"
Assertion
failure
:
"
+
message
)
;
exports
.
reportException
(
"
DevToolsUtils
.
assert
"
err
)
;
throw
err
;
}
}
Object
.
defineProperty
(
exports
"
assert
"
{
get
:
(
)
=
>
AppConstants
.
DEBUG_JS_MODULES
|
|
flags
.
testing
?
reallyAssert
:
exports
.
noop
}
)
;
exports
.
defineLazyModuleGetter
=
function
(
object
name
resource
symbol
)
{
this
.
defineLazyGetter
(
object
name
function
(
)
{
const
temp
=
ChromeUtils
.
import
(
resource
)
;
return
temp
[
symbol
|
|
name
]
;
}
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
this
"
NetUtil
"
(
)
=
>
{
return
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
.
NetUtil
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
NetworkHelper
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
}
)
;
function
mainThreadFetch
(
urlIn
aOptions
=
{
loadFromCache
:
true
policy
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
window
:
null
charset
:
null
principal
:
null
cacheKey
:
0
}
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
url
=
urlIn
.
split
(
"
-
>
"
)
.
pop
(
)
;
let
channel
;
try
{
channel
=
newChannelForURL
(
url
aOptions
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
return
;
}
channel
.
loadInfo
.
isInDevToolsContext
=
true
;
channel
.
loadFlags
=
aOptions
.
loadFromCache
?
channel
.
LOAD_FROM_CACHE
:
channel
.
LOAD_BYPASS_CACHE
;
if
(
aOptions
.
loadFromCache
&
&
channel
instanceof
Ci
.
nsICacheInfoChannel
)
{
channel
.
preferCacheLoadOverBypass
=
true
;
if
(
aOptions
.
cacheKey
!
=
0
)
{
channel
.
cacheKey
=
aOptions
.
cacheKey
;
}
}
if
(
aOptions
.
window
)
{
channel
.
loadGroup
=
aOptions
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIDocumentLoader
)
.
loadGroup
;
}
const
onResponse
=
(
stream
status
request
)
=
>
{
if
(
!
components
.
isSuccessCode
(
status
)
)
{
reject
(
new
Error
(
Failed
to
fetch
{
url
}
.
Code
{
status
}
.
)
)
;
return
;
}
try
{
const
available
=
stream
.
available
(
)
;
let
source
=
NetUtil
.
readInputStreamToString
(
stream
available
)
;
stream
.
close
(
)
;
let
bomCharset
=
null
;
if
(
available
>
=
3
&
&
source
.
codePointAt
(
0
)
=
=
0xef
&
&
source
.
codePointAt
(
1
)
=
=
0xbb
&
&
source
.
codePointAt
(
2
)
=
=
0xbf
)
{
bomCharset
=
"
UTF
-
8
"
;
source
=
source
.
slice
(
3
)
;
}
else
if
(
available
>
=
2
&
&
source
.
codePointAt
(
0
)
=
=
0xfe
&
&
source
.
codePointAt
(
1
)
=
=
0xff
)
{
bomCharset
=
"
UTF
-
16BE
"
;
source
=
source
.
slice
(
2
)
;
}
else
if
(
available
>
=
2
&
&
source
.
codePointAt
(
0
)
=
=
0xff
&
&
source
.
codePointAt
(
1
)
=
=
0xfe
)
{
bomCharset
=
"
UTF
-
16LE
"
;
source
=
source
.
slice
(
2
)
;
}
let
charset
=
bomCharset
;
if
(
!
charset
)
{
try
{
charset
=
channel
.
contentCharset
;
}
catch
(
e
)
{
}
}
if
(
!
charset
)
{
charset
=
aOptions
.
charset
|
|
"
UTF
-
8
"
;
}
const
unicodeSource
=
NetworkHelper
.
convertToUnicode
(
source
charset
)
;
let
sourceMapURL
;
if
(
request
instanceof
Ci
.
nsIHttpChannel
)
{
try
{
sourceMapURL
=
request
.
getResponseHeader
(
"
SourceMap
"
)
;
}
catch
(
e
)
{
}
if
(
!
sourceMapURL
)
{
try
{
sourceMapURL
=
request
.
getResponseHeader
(
"
X
-
SourceMap
"
)
;
}
catch
(
e
)
{
}
}
}
resolve
(
{
content
:
unicodeSource
contentType
:
request
.
contentType
sourceMapURL
}
)
;
}
catch
(
ex
)
{
const
uri
=
request
.
originalURI
;
if
(
ex
.
name
=
=
=
"
NS_BASE_STREAM_CLOSED
"
&
&
uri
instanceof
Ci
.
nsIFileURL
)
{
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
const
result
=
OS
.
File
.
read
(
uri
.
file
.
path
)
.
then
(
bytes
=
>
{
const
decoder
=
new
TextDecoder
(
)
;
const
content
=
decoder
.
decode
(
bytes
)
;
return
{
content
contentType
:
"
text
/
plain
"
}
;
}
)
;
resolve
(
result
)
;
}
else
{
reject
(
ex
)
;
}
}
}
;
try
{
NetUtil
.
asyncFetch
(
channel
onResponse
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
;
}
function
newChannelForURL
(
url
{
policy
window
principal
}
recursing
=
false
)
{
const
securityFlags
=
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
;
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
e
)
{
uri
=
Services
.
io
.
newURI
(
"
file
:
/
/
"
+
url
)
;
}
const
channelOptions
=
{
contentPolicyType
:
policy
securityFlags
uri
}
;
if
(
!
channelOptions
.
contentPolicyType
)
{
channelOptions
.
contentPolicyType
=
Ci
.
nsIContentPolicy
.
TYPE_OTHER
;
}
if
(
window
)
{
channelOptions
.
loadingNode
=
window
.
document
;
}
else
{
let
prin
=
principal
;
if
(
!
prin
)
{
prin
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
{
}
)
;
}
channelOptions
.
loadingPrincipal
=
prin
;
}
try
{
return
NetUtil
.
newChannel
(
channelOptions
)
;
}
catch
(
e
)
{
if
(
recursing
)
{
throw
e
;
}
return
newChannelForURL
(
"
file
:
/
/
"
+
url
{
policy
window
principal
}
true
)
;
}
}
if
(
this
.
isWorker
)
{
exports
.
fetch
=
function
(
url
options
)
{
return
rpc
(
"
fetch
"
url
options
)
;
}
;
}
else
{
exports
.
fetch
=
mainThreadFetch
;
}
exports
.
openFileStream
=
function
(
filePath
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
uri
=
NetUtil
.
newURI
(
new
FileUtils
.
File
(
filePath
)
)
;
NetUtil
.
asyncFetch
(
{
uri
loadUsingSystemPrincipal
:
true
}
(
stream
result
)
=
>
{
if
(
!
components
.
isSuccessCode
(
result
)
)
{
reject
(
new
Error
(
Could
not
open
"
{
filePath
}
"
:
result
=
{
result
}
)
)
;
return
;
}
resolve
(
stream
)
;
}
)
;
}
)
;
}
;
exports
.
saveAs
=
async
function
(
parentWindow
dataArray
fileName
=
"
"
filters
=
[
]
)
{
let
returnFile
;
try
{
returnFile
=
await
exports
.
showSaveFileDialog
(
parentWindow
fileName
filters
)
;
}
catch
(
ex
)
{
return
;
}
await
IOUtils
.
write
(
returnFile
.
path
dataArray
{
tmpPath
:
returnFile
.
path
+
"
.
tmp
"
}
)
;
}
;
exports
.
showSaveFileDialog
=
function
(
parentWindow
suggestedFilename
filters
=
[
]
)
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
if
(
suggestedFilename
)
{
fp
.
defaultString
=
suggestedFilename
;
}
fp
.
init
(
parentWindow
null
fp
.
modeSave
)
;
if
(
Array
.
isArray
(
filters
)
&
&
filters
.
length
>
0
)
{
for
(
const
{
pattern
label
}
of
filters
)
{
fp
.
appendFilter
(
label
pattern
)
;
}
}
else
{
fp
.
appendFilters
(
fp
.
filterAll
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
fp
.
open
(
result
=
>
{
if
(
result
=
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
reject
(
)
;
}
else
{
resolve
(
fp
.
file
)
;
}
}
)
;
}
)
;
}
;
function
errorOnFlag
(
exports
name
)
{
Object
.
defineProperty
(
exports
name
{
get
:
(
)
=
>
{
const
msg
=
Cannot
get
the
flag
{
name
}
.
+
Use
the
"
devtools
/
shared
/
flags
"
module
instead
;
console
.
error
(
msg
)
;
throw
new
Error
(
msg
)
;
}
set
:
(
)
=
>
{
const
msg
=
Cannot
set
the
flag
{
name
}
.
+
Use
the
"
devtools
/
shared
/
flags
"
module
instead
;
console
.
error
(
msg
)
;
throw
new
Error
(
msg
)
;
}
}
)
;
}
errorOnFlag
(
exports
"
testing
"
)
;
errorOnFlag
(
exports
"
wantLogging
"
)
;
errorOnFlag
(
exports
"
wantVerbose
"
)
;
function
callPropertyOnObject
(
object
name
.
.
.
args
)
{
let
descriptor
;
let
proto
=
object
;
do
{
descriptor
=
proto
.
getOwnPropertyDescriptor
(
name
)
;
if
(
descriptor
!
=
=
undefined
)
{
break
;
}
proto
=
proto
.
proto
;
}
while
(
proto
!
=
=
null
)
;
if
(
descriptor
=
=
=
undefined
)
{
throw
new
Error
(
"
No
such
property
"
)
;
}
const
value
=
descriptor
.
value
;
if
(
typeof
value
!
=
=
"
object
"
|
|
value
=
=
=
null
|
|
!
(
"
callable
"
in
value
)
)
{
throw
new
Error
(
"
Not
a
callable
object
.
"
)
;
}
const
result
=
value
.
call
(
object
.
.
.
args
)
;
if
(
result
=
=
=
null
)
{
throw
new
Error
(
"
Code
was
terminated
.
"
)
;
}
if
(
"
throw
"
in
result
)
{
throw
result
.
throw
;
}
return
result
.
return
;
}
exports
.
callPropertyOnObject
=
callPropertyOnObject
;
function
*
makeDebuggeeIterator
(
object
)
{
while
(
true
)
{
const
nextValue
=
callPropertyOnObject
(
object
"
next
"
)
;
if
(
exports
.
getProperty
(
nextValue
"
done
"
)
)
{
break
;
}
yield
exports
.
getProperty
(
nextValue
"
value
"
)
;
}
}
exports
.
makeDebuggeeIterator
=
makeDebuggeeIterator
;
function
getTopWindow
(
win
)
{
return
win
.
windowRoot
?
win
.
windowRoot
.
ownerGlobal
:
win
.
top
;
}
exports
.
getTopWindow
=
getTopWindow
;
exports
.
deepEqual
=
(
a
b
)
=
>
{
return
ObjectUtils
.
deepEqual
(
a
b
)
;
}
;
function
isWorkerDebuggerAlive
(
dbg
)
{
return
!
dbg
.
isClosed
&
&
(
!
dbg
.
window
|
|
dbg
.
window
.
docShell
)
;
}
exports
.
isWorkerDebuggerAlive
=
isWorkerDebuggerAlive
;
