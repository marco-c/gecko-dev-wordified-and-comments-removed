"
use
strict
"
;
var
promise
=
require
(
"
promise
"
)
;
var
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
var
{
settleAll
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
lazyLoadSpec
lazyLoadFront
}
=
require
(
"
devtools
/
shared
/
specs
/
index
"
)
;
var
types
=
Object
.
create
(
null
)
;
exports
.
types
=
types
;
var
registeredTypes
=
types
.
registeredTypes
=
new
Map
(
)
;
var
registeredLifetimes
=
types
.
registeredLifetimes
=
new
Map
(
)
;
types
.
getType
=
function
(
type
)
{
if
(
!
type
)
{
return
types
.
Primitive
;
}
if
(
typeof
(
type
)
!
=
=
"
string
"
)
{
return
type
;
}
let
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
if
(
lazyLoadSpec
(
type
)
)
{
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
}
let
sep
=
type
.
indexOf
(
"
:
"
)
;
if
(
sep
>
=
0
)
{
let
collection
=
type
.
substring
(
0
sep
)
;
let
subtype
=
types
.
getType
(
type
.
substring
(
sep
+
1
)
)
;
if
(
collection
=
=
=
"
array
"
)
{
return
types
.
addArrayType
(
subtype
)
;
}
else
if
(
collection
=
=
=
"
nullable
"
)
{
return
types
.
addNullableType
(
subtype
)
;
}
if
(
registeredLifetimes
.
has
(
collection
)
)
{
return
types
.
addLifetimeType
(
collection
subtype
)
;
}
throw
Error
(
"
Unknown
collection
type
:
"
+
collection
)
;
}
let
pieces
=
type
.
split
(
"
#
"
2
)
;
if
(
pieces
.
length
>
1
)
{
return
types
.
addActorDetail
(
type
pieces
[
0
]
pieces
[
1
]
)
;
}
throw
Error
(
"
Unknown
type
:
"
+
type
)
;
}
;
function
identityWrite
(
v
)
{
if
(
v
=
=
=
undefined
)
{
throw
Error
(
"
undefined
passed
where
a
value
is
required
"
)
;
}
if
(
v
&
&
typeof
(
v
)
=
=
=
"
object
"
&
&
Symbol
.
iterator
in
v
)
{
return
[
.
.
.
v
]
;
}
return
v
;
}
types
.
addType
=
function
(
name
typeObject
=
{
}
options
=
{
}
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
throw
Error
(
"
Type
'
"
+
name
+
"
'
already
exists
.
"
)
;
}
let
type
=
Object
.
assign
(
{
toString
(
)
{
return
"
[
protocol
type
:
"
+
name
+
"
]
"
;
}
name
:
name
primitive
:
!
(
typeObject
.
read
|
|
typeObject
.
write
)
read
:
identityWrite
write
:
identityWrite
}
typeObject
)
;
registeredTypes
.
set
(
name
type
)
;
return
type
;
}
;
types
.
removeType
=
function
(
name
)
{
let
type
=
registeredTypes
.
get
(
name
)
;
type
.
name
=
"
DEFUNCT
:
"
+
name
;
type
.
category
=
"
defunct
"
;
type
.
primitive
=
false
;
type
.
read
=
type
.
write
=
function
(
)
{
throw
new
Error
(
"
Using
defunct
type
:
"
+
name
)
;
}
;
registeredTypes
.
delete
(
name
)
;
}
;
types
.
addArrayType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
let
name
=
"
array
:
"
+
subtype
.
name
;
if
(
subtype
.
primitive
)
{
return
types
.
addType
(
name
)
;
}
return
types
.
addType
(
name
{
category
:
"
array
"
read
:
(
v
ctx
)
=
>
[
.
.
.
v
]
.
map
(
i
=
>
subtype
.
read
(
i
ctx
)
)
write
:
(
v
ctx
)
=
>
[
.
.
.
v
]
.
map
(
i
=
>
subtype
.
write
(
i
ctx
)
)
}
)
;
}
;
types
.
addDictType
=
function
(
name
specializations
)
{
return
types
.
addType
(
name
{
category
:
"
dict
"
specializations
:
specializations
read
:
(
v
ctx
)
=
>
{
let
ret
=
{
}
;
for
(
let
prop
in
v
)
{
if
(
prop
in
specializations
)
{
ret
[
prop
]
=
types
.
getType
(
specializations
[
prop
]
)
.
read
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
write
:
(
v
ctx
)
=
>
{
let
ret
=
{
}
;
for
(
let
prop
in
v
)
{
if
(
prop
in
specializations
)
{
ret
[
prop
]
=
types
.
getType
(
specializations
[
prop
]
)
.
write
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
}
)
;
}
;
types
.
addActorType
=
function
(
name
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
return
registeredTypes
.
get
(
name
)
;
}
let
type
=
types
.
addType
(
name
{
_actor
:
true
category
:
"
actor
"
read
:
(
v
ctx
detail
)
=
>
{
if
(
ctx
instanceof
Actor
)
{
return
ctx
.
conn
.
getActor
(
v
)
;
}
let
actorID
=
typeof
(
v
)
=
=
=
"
string
"
?
v
:
v
.
actor
;
let
front
=
ctx
.
conn
.
getActor
(
actorID
)
;
if
(
!
front
)
{
if
(
!
type
.
frontClass
)
{
lazyLoadFront
(
name
)
;
}
front
=
new
type
.
frontClass
(
ctx
.
conn
)
;
front
.
actorID
=
actorID
;
ctx
.
marshallPool
(
)
.
manage
(
front
)
;
}
v
=
type
.
formType
(
detail
)
.
read
(
v
front
detail
)
;
front
.
form
(
v
detail
ctx
)
;
return
front
;
}
write
:
(
v
ctx
detail
)
=
>
{
if
(
v
instanceof
Actor
)
{
if
(
!
v
.
actorID
)
{
ctx
.
marshallPool
(
)
.
manage
(
v
)
;
}
return
type
.
formType
(
detail
)
.
write
(
v
.
form
(
detail
)
ctx
detail
)
;
}
return
v
.
actorID
;
}
formType
:
(
detail
)
=
>
{
if
(
!
(
"
formType
"
in
type
.
actorSpec
)
)
{
return
types
.
Primitive
;
}
let
formAttr
=
"
formType
"
;
if
(
detail
)
{
formAttr
+
=
"
#
"
+
detail
;
}
if
(
!
(
formAttr
in
type
.
actorSpec
)
)
{
throw
new
Error
(
"
No
type
defined
for
"
+
formAttr
)
;
}
return
type
.
actorSpec
[
formAttr
]
;
}
}
)
;
return
type
;
}
;
types
.
addNullableType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
return
types
.
addType
(
"
nullable
:
"
+
subtype
.
name
{
category
:
"
nullable
"
read
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
read
(
value
ctx
)
;
}
write
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
write
(
value
ctx
)
;
}
}
)
;
}
;
types
.
addActorDetail
=
function
(
name
actorType
detail
)
{
actorType
=
types
.
getType
(
actorType
)
;
if
(
!
actorType
.
_actor
)
{
throw
Error
(
Details
only
apply
to
actor
types
tried
to
add
detail
'
{
detail
}
'
+
to
{
actorType
.
name
}
)
;
}
return
types
.
addType
(
name
{
_actor
:
true
category
:
"
detail
"
read
:
(
v
ctx
)
=
>
actorType
.
read
(
v
ctx
detail
)
write
:
(
v
ctx
)
=
>
actorType
.
write
(
v
ctx
detail
)
}
)
;
}
;
types
.
addLifetime
=
function
(
name
prop
)
{
if
(
registeredLifetimes
.
has
(
name
)
)
{
throw
Error
(
"
Lifetime
'
"
+
name
+
"
'
already
registered
.
"
)
;
}
registeredLifetimes
.
set
(
name
prop
)
;
}
;
types
.
removeLifetime
=
function
(
name
)
{
registeredLifetimes
.
delete
(
name
)
;
}
;
types
.
addLifetimeType
=
function
(
lifetime
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
if
(
!
subtype
.
_actor
)
{
throw
Error
(
Lifetimes
only
apply
to
actor
types
tried
to
apply
+
lifetime
'
{
lifetime
}
'
to
{
subtype
.
name
}
)
;
}
let
prop
=
registeredLifetimes
.
get
(
lifetime
)
;
return
types
.
addType
(
lifetime
+
"
:
"
+
subtype
.
name
{
category
:
"
lifetime
"
read
:
(
value
ctx
)
=
>
subtype
.
read
(
value
ctx
[
prop
]
)
write
:
(
value
ctx
)
=
>
subtype
.
write
(
value
ctx
[
prop
]
)
}
)
;
}
;
types
.
Primitive
=
types
.
addType
(
"
primitive
"
)
;
types
.
String
=
types
.
addType
(
"
string
"
)
;
types
.
Number
=
types
.
addType
(
"
number
"
)
;
types
.
Boolean
=
types
.
addType
(
"
boolean
"
)
;
types
.
JSON
=
types
.
addType
(
"
json
"
)
;
var
Arg
=
function
(
index
type
)
{
this
.
index
=
index
;
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
Arg
.
prototype
=
{
write
:
function
(
arg
ctx
)
{
return
this
.
type
.
write
(
arg
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
)
{
outArgs
[
this
.
index
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_arg
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
;
exports
.
Arg
=
function
(
index
type
)
{
return
new
Arg
(
index
type
)
;
}
;
var
Option
=
function
(
index
type
)
{
Arg
.
call
(
this
index
type
)
;
}
;
Option
.
prototype
=
extend
(
Arg
.
prototype
{
write
:
function
(
arg
ctx
name
)
{
if
(
arg
=
=
undefined
|
|
arg
[
name
]
=
=
undefined
)
{
return
undefined
;
}
let
v
=
arg
[
name
]
;
return
this
.
type
.
write
(
v
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
name
)
{
if
(
outArgs
[
this
.
index
]
=
=
=
undefined
)
{
outArgs
[
this
.
index
]
=
{
}
;
}
if
(
v
=
=
=
undefined
)
{
return
;
}
outArgs
[
this
.
index
]
[
name
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_option
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
)
;
exports
.
Option
=
function
(
index
type
)
{
return
new
Option
(
index
type
)
;
}
;
var
RetVal
=
function
(
type
)
{
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
RetVal
.
prototype
=
{
write
:
function
(
v
ctx
)
{
return
this
.
type
.
write
(
v
ctx
)
;
}
read
:
function
(
v
ctx
)
{
return
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_retval
:
this
.
type
.
name
}
;
}
}
;
exports
.
RetVal
=
function
(
type
)
{
return
new
RetVal
(
type
)
;
}
;
function
getPath
(
obj
path
)
{
for
(
let
name
of
path
)
{
if
(
!
(
name
in
obj
)
)
{
return
undefined
;
}
obj
=
obj
[
name
]
;
}
return
obj
;
}
function
findPlaceholders
(
template
constructor
path
=
[
]
placeholders
=
[
]
)
{
if
(
!
template
|
|
typeof
(
template
)
!
=
"
object
"
)
{
return
placeholders
;
}
if
(
template
instanceof
constructor
)
{
placeholders
.
push
(
{
placeholder
:
template
path
:
[
.
.
.
path
]
}
)
;
return
placeholders
;
}
for
(
let
name
in
template
)
{
path
.
push
(
name
)
;
findPlaceholders
(
template
[
name
]
constructor
path
placeholders
)
;
path
.
pop
(
)
;
}
return
placeholders
;
}
function
describeTemplate
(
template
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
template
(
key
value
)
=
>
{
if
(
value
.
describe
)
{
return
value
.
describe
(
)
;
}
return
value
;
}
)
)
;
}
var
Request
=
function
(
template
=
{
}
)
{
this
.
type
=
template
.
type
;
this
.
template
=
template
;
this
.
args
=
findPlaceholders
(
template
Arg
)
;
}
;
Request
.
prototype
=
{
write
:
function
(
fnArgs
ctx
)
{
let
str
=
JSON
.
stringify
(
this
.
template
(
key
value
)
=
>
{
if
(
value
instanceof
Arg
)
{
return
value
.
write
(
value
.
index
in
fnArgs
?
fnArgs
[
value
.
index
]
:
undefined
ctx
key
)
;
}
return
value
;
}
)
;
return
JSON
.
parse
(
str
)
;
}
read
:
function
(
packet
ctx
)
{
let
fnArgs
=
[
]
;
for
(
let
templateArg
of
this
.
args
)
{
let
arg
=
templateArg
.
placeholder
;
let
path
=
templateArg
.
path
;
let
name
=
path
[
path
.
length
-
1
]
;
arg
.
read
(
getPath
(
packet
path
)
ctx
fnArgs
name
)
;
}
return
fnArgs
;
}
describe
:
function
(
)
{
return
describeTemplate
(
this
.
template
)
;
}
}
;
var
Response
=
function
(
template
=
{
}
)
{
this
.
template
=
template
;
let
placeholders
=
findPlaceholders
(
template
RetVal
)
;
if
(
placeholders
.
length
>
1
)
{
throw
Error
(
"
More
than
one
RetVal
specified
in
response
"
)
;
}
let
placeholder
=
placeholders
.
shift
(
)
;
if
(
placeholder
)
{
this
.
retVal
=
placeholder
.
placeholder
;
this
.
path
=
placeholder
.
path
;
}
}
;
Response
.
prototype
=
{
write
:
function
(
ret
ctx
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
this
.
template
function
(
key
value
)
{
if
(
value
instanceof
RetVal
)
{
return
value
.
write
(
ret
ctx
)
;
}
return
value
;
}
)
)
;
}
read
:
function
(
packet
ctx
)
{
if
(
!
this
.
retVal
)
{
return
undefined
;
}
let
v
=
getPath
(
packet
this
.
path
)
;
return
this
.
retVal
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
describeTemplate
(
this
.
template
)
;
}
}
;
var
Pool
=
function
(
conn
)
{
if
(
conn
)
{
this
.
conn
=
conn
;
}
}
;
Pool
.
prototype
=
extend
(
EventEmitter
.
prototype
{
parent
:
function
(
)
{
return
this
.
conn
.
poolFor
(
this
.
actorID
)
;
}
marshallPool
:
function
(
)
{
return
this
;
}
__poolMap
:
null
get
_poolMap
(
)
{
if
(
this
.
__poolMap
)
{
return
this
.
__poolMap
;
}
this
.
__poolMap
=
new
Map
(
)
;
this
.
conn
.
addActorPool
(
this
)
;
return
this
.
__poolMap
;
}
manage
:
function
(
actor
)
{
if
(
!
actor
.
actorID
)
{
actor
.
actorID
=
this
.
conn
.
allocID
(
actor
.
actorPrefix
|
|
actor
.
typeName
)
;
}
this
.
_poolMap
.
set
(
actor
.
actorID
actor
)
;
return
actor
;
}
unmanage
:
function
(
actor
)
{
this
.
__poolMap
&
&
this
.
__poolMap
.
delete
(
actor
.
actorID
)
;
}
has
:
function
(
actorID
)
{
return
this
.
__poolMap
&
&
this
.
_poolMap
.
has
(
actorID
)
;
}
actor
:
function
(
actorID
)
{
return
this
.
__poolMap
?
this
.
_poolMap
.
get
(
actorID
)
:
null
;
}
get
:
function
(
actorID
)
{
return
this
.
__poolMap
?
this
.
_poolMap
.
get
(
actorID
)
:
null
;
}
isEmpty
:
function
(
)
{
return
!
this
.
__poolMap
|
|
this
.
_poolMap
.
size
=
=
0
;
}
poolChildren
:
function
*
(
)
{
if
(
!
this
.
__poolMap
)
{
return
;
}
for
(
let
actor
of
this
.
__poolMap
.
values
(
)
)
{
if
(
actor
=
=
=
this
)
{
continue
;
}
yield
actor
;
}
}
destroy
:
function
(
)
{
let
parent
=
this
.
parent
(
)
;
if
(
parent
)
{
parent
.
unmanage
(
this
)
;
}
if
(
!
this
.
__poolMap
)
{
return
;
}
for
(
let
actor
of
this
.
__poolMap
.
values
(
)
)
{
if
(
actor
=
=
=
this
)
{
continue
;
}
let
destroy
=
actor
.
destroy
;
if
(
destroy
)
{
actor
.
destroy
=
null
;
destroy
.
call
(
actor
)
;
actor
.
destroy
=
destroy
;
}
}
this
.
conn
.
removeActorPool
(
this
true
)
;
this
.
__poolMap
.
clear
(
)
;
this
.
__poolMap
=
null
;
}
cleanup
:
function
(
)
{
this
.
destroy
(
)
;
}
}
)
;
exports
.
Pool
=
Pool
;
var
Actor
=
function
(
conn
)
{
Pool
.
call
(
this
conn
)
;
if
(
this
.
_actorSpec
&
&
this
.
_actorSpec
.
events
)
{
for
(
let
key
of
this
.
_actorSpec
.
events
.
keys
(
)
)
{
let
name
=
key
;
let
sendEvent
=
this
.
_sendEvent
.
bind
(
this
name
)
;
this
.
on
(
name
(
.
.
.
args
)
=
>
{
sendEvent
.
apply
(
null
args
)
;
}
)
;
}
}
}
;
Actor
.
prototype
=
extend
(
Pool
.
prototype
{
actorID
:
null
initialize
:
Actor
toString
:
function
(
)
{
return
"
[
Actor
"
+
this
.
typeName
+
"
/
"
+
this
.
actorID
+
"
]
"
;
}
_sendEvent
:
function
(
name
.
.
.
args
)
{
if
(
!
this
.
_actorSpec
.
events
.
has
(
name
)
)
{
return
;
}
let
request
=
this
.
_actorSpec
.
events
.
get
(
name
)
;
let
packet
;
try
{
packet
=
request
.
write
(
args
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
sending
event
:
"
+
name
)
;
throw
ex
;
}
packet
.
from
=
packet
.
from
|
|
this
.
actorID
;
this
.
conn
.
send
(
packet
)
;
}
destroy
:
function
(
)
{
Pool
.
prototype
.
destroy
.
call
(
this
)
;
this
.
actorID
=
null
;
}
form
:
function
(
hint
)
{
return
{
actor
:
this
.
actorID
}
;
}
writeError
:
function
(
error
)
{
console
.
error
(
error
)
;
if
(
error
.
stack
)
{
dump
(
error
.
stack
)
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
error
:
error
.
error
|
|
"
unknownError
"
message
:
error
.
message
}
)
;
}
_queueResponse
:
function
(
create
)
{
let
pending
=
this
.
_pendingResponse
|
|
promise
.
resolve
(
null
)
;
let
response
=
create
(
pending
)
;
this
.
_pendingResponse
=
response
;
}
}
)
;
exports
.
Actor
=
Actor
;
exports
.
method
=
function
(
fn
spec
=
{
}
)
{
fn
.
_methodSpec
=
Object
.
freeze
(
spec
)
;
if
(
spec
.
request
)
{
Object
.
freeze
(
spec
.
request
)
;
}
if
(
spec
.
response
)
{
Object
.
freeze
(
spec
.
response
)
;
}
return
fn
;
}
;
var
generateActorSpec
=
function
(
actorDesc
)
{
let
actorSpec
=
{
typeName
:
actorDesc
.
typeName
methods
:
[
]
}
;
for
(
let
name
of
Object
.
getOwnPropertyNames
(
actorDesc
)
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
actorDesc
name
)
;
if
(
!
desc
.
value
)
{
continue
;
}
if
(
name
.
startsWith
(
"
formType
"
)
)
{
if
(
typeof
(
desc
.
value
)
=
=
=
"
string
"
)
{
actorSpec
[
name
]
=
types
.
getType
(
desc
.
value
)
;
}
else
if
(
desc
.
value
.
name
&
&
registeredTypes
.
has
(
desc
.
value
.
name
)
)
{
actorSpec
[
name
]
=
desc
.
value
;
}
else
{
actorSpec
[
name
]
=
types
.
addDictType
(
actorDesc
.
typeName
+
"
__
"
+
name
desc
.
value
)
;
}
}
if
(
desc
.
value
.
_methodSpec
)
{
let
methodSpec
=
desc
.
value
.
_methodSpec
;
let
spec
=
{
}
;
spec
.
name
=
methodSpec
.
name
|
|
name
;
spec
.
request
=
new
Request
(
Object
.
assign
(
{
type
:
spec
.
name
}
methodSpec
.
request
|
|
undefined
)
)
;
spec
.
response
=
new
Response
(
methodSpec
.
response
|
|
undefined
)
;
spec
.
release
=
methodSpec
.
release
;
spec
.
oneway
=
methodSpec
.
oneway
;
actorSpec
.
methods
.
push
(
spec
)
;
}
}
if
(
actorDesc
.
methods
)
{
for
(
let
name
in
actorDesc
.
methods
)
{
let
methodSpec
=
actorDesc
.
methods
[
name
]
;
let
spec
=
{
}
;
spec
.
name
=
methodSpec
.
name
|
|
name
;
spec
.
request
=
new
Request
(
Object
.
assign
(
{
type
:
spec
.
name
}
methodSpec
.
request
|
|
undefined
)
)
;
spec
.
response
=
new
Response
(
methodSpec
.
response
|
|
undefined
)
;
spec
.
release
=
methodSpec
.
release
;
spec
.
oneway
=
methodSpec
.
oneway
;
actorSpec
.
methods
.
push
(
spec
)
;
}
}
if
(
actorDesc
.
events
)
{
actorSpec
.
events
=
new
Map
(
)
;
for
(
let
name
in
actorDesc
.
events
)
{
let
eventRequest
=
actorDesc
.
events
[
name
]
;
Object
.
freeze
(
eventRequest
)
;
actorSpec
.
events
.
set
(
name
new
Request
(
Object
.
assign
(
{
type
:
name
}
eventRequest
)
)
)
;
}
}
if
(
!
registeredTypes
.
has
(
actorSpec
.
typeName
)
)
{
types
.
addActorType
(
actorSpec
.
typeName
)
;
}
registeredTypes
.
get
(
actorSpec
.
typeName
)
.
actorSpec
=
actorSpec
;
return
actorSpec
;
}
;
exports
.
generateActorSpec
=
generateActorSpec
;
var
generateRequestHandlers
=
function
(
actorSpec
actorProto
)
{
if
(
actorProto
.
_actorSpec
)
{
throw
new
Error
(
"
actorProto
called
twice
on
the
same
actor
prototype
!
"
)
;
}
actorProto
.
typeName
=
actorSpec
.
typeName
;
actorProto
.
requestTypes
=
Object
.
create
(
null
)
;
actorSpec
.
methods
.
forEach
(
spec
=
>
{
let
handler
=
function
(
packet
conn
)
{
try
{
let
args
;
try
{
args
=
spec
.
request
.
read
(
packet
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
request
:
"
+
packet
.
type
)
;
throw
ex
;
}
let
ret
=
this
[
spec
.
name
]
.
apply
(
this
args
)
;
let
sendReturn
=
(
retToSend
)
=
>
{
if
(
spec
.
oneway
)
{
return
;
}
let
response
;
try
{
response
=
spec
.
response
.
write
(
retToSend
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
writing
response
to
:
"
+
spec
.
name
)
;
throw
ex
;
}
response
.
from
=
this
.
actorID
;
if
(
spec
.
release
)
{
try
{
this
.
destroy
(
)
;
}
catch
(
e
)
{
this
.
writeError
(
e
)
;
return
;
}
}
conn
.
send
(
response
)
;
}
;
this
.
_queueResponse
(
p
=
>
{
return
p
.
then
(
(
)
=
>
ret
)
.
then
(
sendReturn
)
.
catch
(
this
.
writeError
.
bind
(
this
)
)
;
}
)
;
}
catch
(
e
)
{
this
.
_queueResponse
(
p
=
>
{
return
p
.
then
(
(
)
=
>
this
.
writeError
(
e
)
)
;
}
)
;
}
}
;
actorProto
.
requestTypes
[
spec
.
request
.
type
]
=
handler
;
}
)
;
actorProto
.
_actorSpec
=
actorSpec
;
return
actorProto
;
}
;
var
ActorClassWithSpec
=
function
(
actorSpec
actorProto
)
{
if
(
!
actorSpec
.
typeName
)
{
throw
Error
(
"
Actor
specification
must
have
a
typeName
member
.
"
)
;
}
let
cls
=
function
(
)
{
let
instance
=
Object
.
create
(
cls
.
prototype
)
;
instance
.
initialize
.
apply
(
instance
arguments
)
;
return
instance
;
}
;
cls
.
prototype
=
extend
(
Actor
.
prototype
generateRequestHandlers
(
actorSpec
actorProto
)
)
;
return
cls
;
}
;
exports
.
ActorClassWithSpec
=
ActorClassWithSpec
;
var
Front
=
function
(
conn
=
null
form
=
null
detail
=
null
context
=
null
)
{
Pool
.
call
(
this
conn
)
;
this
.
_requests
=
[
]
;
if
(
form
)
{
this
.
actorID
=
form
.
actor
;
form
=
types
.
getType
(
this
.
typeName
)
.
formType
(
detail
)
.
read
(
form
this
detail
)
;
this
.
form
(
form
detail
context
)
;
}
}
;
Front
.
prototype
=
extend
(
Pool
.
prototype
{
actorID
:
null
initialize
:
Front
destroy
:
function
(
)
{
while
(
this
.
_requests
&
&
this
.
_requests
.
length
>
0
)
{
let
{
deferred
to
type
stack
}
=
this
.
_requests
.
shift
(
)
;
let
msg
=
"
Connection
closed
pending
request
to
"
+
to
+
"
type
"
+
type
+
"
failed
"
+
"
\
n
\
nRequest
stack
:
\
n
"
+
stack
.
formattedStack
;
deferred
.
reject
(
new
Error
(
msg
)
)
;
}
Pool
.
prototype
.
destroy
.
call
(
this
)
;
this
.
actorID
=
null
;
}
manage
:
function
(
front
)
{
if
(
!
front
.
actorID
)
{
throw
new
Error
(
"
Can
'
t
manage
front
without
an
actor
ID
.
\
n
"
+
"
Ensure
server
supports
"
+
front
.
typeName
+
"
.
"
)
;
}
return
Pool
.
prototype
.
manage
.
call
(
this
front
)
;
}
actor
:
function
(
)
{
return
promise
.
resolve
(
this
.
actorID
)
;
}
toString
:
function
(
)
{
return
"
[
Front
for
"
+
this
.
typeName
+
"
/
"
+
this
.
actorID
+
"
]
"
;
}
form
:
function
(
form
)
{
}
send
:
function
(
packet
)
{
if
(
packet
.
to
)
{
this
.
conn
.
_transport
.
send
(
packet
)
;
}
else
{
this
.
actor
(
)
.
then
(
actorID
=
>
{
packet
.
to
=
actorID
;
this
.
conn
.
_transport
.
send
(
packet
)
;
}
)
.
catch
(
console
.
error
)
;
}
}
request
:
function
(
packet
)
{
let
deferred
=
defer
(
)
;
let
{
to
type
}
=
packet
;
this
.
_requests
.
push
(
{
deferred
to
:
to
|
|
this
.
actorID
type
stack
:
getStack
(
)
}
)
;
this
.
send
(
packet
)
;
return
deferred
.
promise
;
}
onPacket
:
function
(
packet
)
{
let
type
=
packet
.
type
|
|
undefined
;
if
(
this
.
_clientSpec
.
events
&
&
this
.
_clientSpec
.
events
.
has
(
type
)
)
{
let
event
=
this
.
_clientSpec
.
events
.
get
(
packet
.
type
)
;
let
args
;
try
{
args
=
event
.
request
.
read
(
packet
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
event
:
"
+
packet
.
type
)
;
console
.
exception
(
ex
)
;
throw
ex
;
}
if
(
event
.
pre
)
{
let
results
=
event
.
pre
.
map
(
pre
=
>
pre
.
apply
(
this
args
)
)
;
if
(
results
.
some
(
result
=
>
result
&
&
typeof
result
.
then
=
=
=
"
function
"
)
)
{
promise
.
all
(
results
)
.
then
(
(
)
=
>
{
return
EventEmitter
.
emit
.
apply
(
null
[
this
event
.
name
]
.
concat
(
args
)
)
;
}
)
;
return
;
}
}
EventEmitter
.
emit
.
apply
(
null
[
this
event
.
name
]
.
concat
(
args
)
)
;
return
;
}
if
(
this
.
_requests
.
length
=
=
=
0
)
{
let
msg
=
"
Unexpected
packet
"
+
this
.
actorID
+
"
"
+
JSON
.
stringify
(
packet
)
;
let
err
=
Error
(
msg
)
;
console
.
error
(
err
)
;
throw
err
;
}
let
{
deferred
stack
}
=
this
.
_requests
.
shift
(
)
;
callFunctionWithAsyncStack
(
(
)
=
>
{
if
(
packet
.
error
)
{
let
message
;
if
(
packet
.
error
&
&
packet
.
message
)
{
message
=
"
Protocol
error
(
"
+
packet
.
error
+
"
)
:
"
+
packet
.
message
;
}
else
{
message
=
packet
.
error
;
}
deferred
.
reject
(
message
)
;
}
else
{
deferred
.
resolve
(
packet
)
;
}
}
stack
"
DevTools
RDP
"
)
;
}
hasRequests
(
)
{
return
!
!
this
.
_requests
.
length
;
}
waitForRequestsToSettle
(
)
{
return
settleAll
(
this
.
_requests
.
map
(
(
{
deferred
}
)
=
>
deferred
.
promise
)
)
;
}
}
)
;
exports
.
Front
=
Front
;
exports
.
preEvent
=
function
(
eventName
fn
)
{
fn
.
_preEvent
=
eventName
;
return
fn
;
}
;
exports
.
custom
=
function
(
fn
options
=
{
}
)
{
fn
.
_customFront
=
options
;
return
fn
;
}
;
var
generateRequestMethods
=
function
(
actorSpec
frontProto
)
{
if
(
frontProto
.
_actorSpec
)
{
throw
new
Error
(
"
frontProto
called
twice
on
the
same
front
prototype
!
"
)
;
}
frontProto
.
typeName
=
actorSpec
.
typeName
;
let
methods
=
actorSpec
.
methods
;
methods
.
forEach
(
spec
=
>
{
let
name
=
spec
.
name
;
if
(
name
in
frontProto
)
{
let
custom
=
frontProto
[
spec
.
name
]
.
_customFront
;
if
(
custom
=
=
=
undefined
)
{
throw
Error
(
Existing
method
for
{
spec
.
name
}
not
marked
customFront
while
+
processing
{
actorSpec
.
typeName
}
.
)
;
}
if
(
!
custom
.
impl
)
{
return
;
}
name
=
custom
.
impl
;
}
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
let
packet
;
try
{
packet
=
spec
.
request
.
write
(
args
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
writing
request
:
"
+
name
)
;
throw
ex
;
}
if
(
spec
.
oneway
)
{
this
.
send
(
packet
)
;
return
undefined
;
}
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
ret
;
try
{
ret
=
spec
.
response
.
read
(
response
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
response
to
:
"
+
name
)
;
throw
ex
;
}
return
ret
;
}
)
;
}
;
if
(
spec
.
release
)
{
let
fn
=
frontProto
[
name
]
;
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
return
fn
.
apply
(
this
args
)
.
then
(
result
=
>
{
this
.
destroy
(
)
;
return
result
;
}
)
;
}
;
}
}
)
;
frontProto
.
_clientSpec
=
{
}
;
let
actorEvents
=
actorSpec
.
events
;
if
(
actorEvents
)
{
let
preHandlers
=
new
Map
(
)
;
for
(
let
name
of
Object
.
getOwnPropertyNames
(
frontProto
)
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
frontProto
name
)
;
if
(
!
desc
.
value
)
{
continue
;
}
if
(
desc
.
value
.
_preEvent
)
{
let
preEvent
=
desc
.
value
.
_preEvent
;
if
(
!
actorEvents
.
has
(
preEvent
)
)
{
throw
Error
(
"
preEvent
for
event
that
doesn
'
t
exist
:
"
+
preEvent
)
;
}
let
handlers
=
preHandlers
.
get
(
preEvent
)
;
if
(
!
handlers
)
{
handlers
=
[
]
;
preHandlers
.
set
(
preEvent
handlers
)
;
}
handlers
.
push
(
desc
.
value
)
;
}
}
frontProto
.
_clientSpec
.
events
=
new
Map
(
)
;
for
(
let
[
name
request
]
of
actorEvents
)
{
frontProto
.
_clientSpec
.
events
.
set
(
request
.
type
{
name
:
name
request
:
request
pre
:
preHandlers
.
get
(
name
)
}
)
;
}
}
frontProto
.
_actorSpec
=
actorSpec
;
return
frontProto
;
}
;
var
FrontClassWithSpec
=
function
(
actorSpec
frontProto
)
{
let
cls
=
function
(
)
{
let
instance
=
Object
.
create
(
cls
.
prototype
)
;
instance
.
initialize
.
apply
(
instance
arguments
)
;
return
instance
;
}
;
cls
.
prototype
=
extend
(
Front
.
prototype
generateRequestMethods
(
actorSpec
frontProto
)
)
;
if
(
!
registeredTypes
.
has
(
actorSpec
.
typeName
)
)
{
types
.
addActorType
(
actorSpec
.
typeName
)
;
}
registeredTypes
.
get
(
actorSpec
.
typeName
)
.
frontClass
=
cls
;
return
cls
;
}
;
exports
.
FrontClassWithSpec
=
FrontClassWithSpec
;
exports
.
dumpActorSpec
=
function
(
type
)
{
let
actorSpec
=
type
.
actorSpec
;
let
ret
=
{
category
:
"
actor
"
typeName
:
type
.
name
methods
:
[
]
events
:
{
}
}
;
for
(
let
method
of
actorSpec
.
methods
)
{
ret
.
methods
.
push
(
{
name
:
method
.
name
release
:
method
.
release
|
|
undefined
oneway
:
method
.
oneway
|
|
undefined
request
:
method
.
request
.
describe
(
)
response
:
method
.
response
.
describe
(
)
}
)
;
}
if
(
actorSpec
.
events
)
{
for
(
let
[
name
request
]
of
actorSpec
.
events
)
{
ret
.
events
[
name
]
=
request
.
describe
(
)
;
}
}
JSON
.
stringify
(
ret
)
;
return
ret
;
}
;
exports
.
dumpProtocolSpec
=
function
(
)
{
let
ret
=
{
types
:
{
}
}
;
for
(
let
[
name
type
]
of
registeredTypes
)
{
type
=
types
.
getType
(
name
)
;
let
category
=
type
.
category
|
|
undefined
;
if
(
category
=
=
=
"
dict
"
)
{
ret
.
types
[
name
]
=
{
category
:
"
dict
"
typeName
:
name
specializations
:
type
.
specializations
}
;
}
else
if
(
category
=
=
=
"
actor
"
)
{
ret
.
types
[
name
]
=
exports
.
dumpActorSpec
(
type
)
;
}
}
return
ret
;
}
;
