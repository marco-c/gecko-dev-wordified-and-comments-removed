"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
{
getStack
callFunctionWithAsyncStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
var
{
settleAll
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
lazyLoadSpec
lazyLoadFront
}
=
require
(
"
devtools
/
shared
/
specs
/
index
"
)
;
function
defer
(
)
{
let
resolve
reject
;
const
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
var
types
=
Object
.
create
(
null
)
;
exports
.
types
=
types
;
var
registeredTypes
=
types
.
registeredTypes
=
new
Map
(
)
;
var
registeredLifetimes
=
types
.
registeredLifetimes
=
new
Map
(
)
;
types
.
getType
=
function
(
type
)
{
if
(
!
type
)
{
return
types
.
Primitive
;
}
if
(
typeof
(
type
)
!
=
=
"
string
"
)
{
return
type
;
}
let
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
if
(
lazyLoadSpec
(
type
)
)
{
reg
=
registeredTypes
.
get
(
type
)
;
if
(
reg
)
{
return
reg
;
}
}
const
sep
=
type
.
indexOf
(
"
:
"
)
;
if
(
sep
>
=
0
)
{
const
collection
=
type
.
substring
(
0
sep
)
;
const
subtype
=
types
.
getType
(
type
.
substring
(
sep
+
1
)
)
;
if
(
collection
=
=
=
"
array
"
)
{
return
types
.
addArrayType
(
subtype
)
;
}
else
if
(
collection
=
=
=
"
nullable
"
)
{
return
types
.
addNullableType
(
subtype
)
;
}
if
(
registeredLifetimes
.
has
(
collection
)
)
{
return
types
.
addLifetimeType
(
collection
subtype
)
;
}
throw
Error
(
"
Unknown
collection
type
:
"
+
collection
)
;
}
const
pieces
=
type
.
split
(
"
#
"
2
)
;
if
(
pieces
.
length
>
1
)
{
if
(
pieces
[
1
]
!
=
"
actorid
"
)
{
throw
new
Error
(
"
Unsupported
detail
only
support
'
actorid
'
got
:
"
+
pieces
[
1
]
)
;
}
return
types
.
addActorDetail
(
type
pieces
[
0
]
pieces
[
1
]
)
;
}
throw
Error
(
"
Unknown
type
:
"
+
type
)
;
}
;
function
identityWrite
(
v
)
{
if
(
v
=
=
=
undefined
)
{
throw
Error
(
"
undefined
passed
where
a
value
is
required
"
)
;
}
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
return
[
.
.
.
v
]
;
}
return
v
;
}
types
.
addType
=
function
(
name
typeObject
=
{
}
options
=
{
}
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
throw
Error
(
"
Type
'
"
+
name
+
"
'
already
exists
.
"
)
;
}
const
type
=
Object
.
assign
(
{
toString
(
)
{
return
"
[
protocol
type
:
"
+
name
+
"
]
"
;
}
name
:
name
primitive
:
!
(
typeObject
.
read
|
|
typeObject
.
write
)
read
:
identityWrite
write
:
identityWrite
}
typeObject
)
;
registeredTypes
.
set
(
name
type
)
;
return
type
;
}
;
types
.
removeType
=
function
(
name
)
{
const
type
=
registeredTypes
.
get
(
name
)
;
type
.
name
=
"
DEFUNCT
:
"
+
name
;
type
.
category
=
"
defunct
"
;
type
.
primitive
=
false
;
type
.
read
=
type
.
write
=
function
(
)
{
throw
new
Error
(
"
Using
defunct
type
:
"
+
name
)
;
}
;
registeredTypes
.
delete
(
name
)
;
}
;
types
.
addArrayType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
const
name
=
"
array
:
"
+
subtype
.
name
;
if
(
subtype
.
primitive
)
{
return
types
.
addType
(
name
)
;
}
return
types
.
addType
(
name
{
category
:
"
array
"
read
:
(
v
ctx
)
=
>
{
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
v
=
[
.
.
.
v
]
;
}
return
v
.
map
(
i
=
>
subtype
.
read
(
i
ctx
)
)
;
}
write
:
(
v
ctx
)
=
>
{
if
(
v
&
&
typeof
v
.
next
=
=
=
"
function
"
)
{
v
=
[
.
.
.
v
]
;
}
return
v
.
map
(
i
=
>
subtype
.
write
(
i
ctx
)
)
;
}
}
)
;
}
;
types
.
addDictType
=
function
(
name
specializations
)
{
const
specTypes
=
{
}
;
for
(
const
prop
in
specializations
)
{
try
{
specTypes
[
prop
]
=
types
.
getType
(
specializations
[
prop
]
)
;
}
catch
(
e
)
{
loader
.
lazyGetter
(
specTypes
prop
(
)
=
>
{
return
types
.
getType
(
specializations
[
prop
]
)
;
}
)
;
}
}
return
types
.
addType
(
name
{
category
:
"
dict
"
specializations
read
:
(
v
ctx
)
=
>
{
const
ret
=
{
}
;
for
(
const
prop
in
v
)
{
if
(
prop
in
specTypes
)
{
ret
[
prop
]
=
specTypes
[
prop
]
.
read
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
write
:
(
v
ctx
)
=
>
{
const
ret
=
{
}
;
for
(
const
prop
in
v
)
{
if
(
prop
in
specTypes
)
{
ret
[
prop
]
=
specTypes
[
prop
]
.
write
(
v
[
prop
]
ctx
)
;
}
else
{
ret
[
prop
]
=
v
[
prop
]
;
}
}
return
ret
;
}
}
)
;
}
;
types
.
addActorType
=
function
(
name
)
{
if
(
registeredTypes
.
has
(
name
)
)
{
return
registeredTypes
.
get
(
name
)
;
}
const
type
=
types
.
addType
(
name
{
_actor
:
true
category
:
"
actor
"
read
:
(
v
ctx
detail
)
=
>
{
if
(
ctx
instanceof
Actor
)
{
return
ctx
.
conn
.
getActor
(
v
)
;
}
const
actorID
=
typeof
(
v
)
=
=
=
"
string
"
?
v
:
v
.
actor
;
let
front
=
ctx
.
conn
.
getActor
(
actorID
)
;
if
(
!
front
)
{
if
(
!
type
.
frontClass
)
{
lazyLoadFront
(
name
)
;
}
const
Class
=
type
.
frontClass
;
front
=
new
Class
(
ctx
.
conn
)
;
front
.
actorID
=
actorID
;
ctx
.
marshallPool
(
)
.
manage
(
front
)
;
}
if
(
detail
!
=
"
actorid
"
)
{
v
=
identityWrite
(
v
)
;
front
.
form
(
v
ctx
)
;
}
return
front
;
}
write
:
(
v
ctx
detail
)
=
>
{
if
(
v
instanceof
Actor
)
{
if
(
!
v
.
actorID
)
{
ctx
.
marshallPool
(
)
.
manage
(
v
)
;
}
if
(
detail
=
=
"
actorid
"
)
{
return
v
.
actorID
;
}
return
identityWrite
(
v
.
form
(
detail
)
)
;
}
return
v
.
actorID
;
}
}
)
;
return
type
;
}
;
types
.
addNullableType
=
function
(
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
return
types
.
addType
(
"
nullable
:
"
+
subtype
.
name
{
category
:
"
nullable
"
read
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
read
(
value
ctx
)
;
}
write
:
(
value
ctx
)
=
>
{
if
(
value
=
=
null
)
{
return
value
;
}
return
subtype
.
write
(
value
ctx
)
;
}
}
)
;
}
;
types
.
addActorDetail
=
function
(
name
actorType
detail
)
{
actorType
=
types
.
getType
(
actorType
)
;
if
(
!
actorType
.
_actor
)
{
throw
Error
(
Details
only
apply
to
actor
types
tried
to
add
detail
'
{
detail
}
'
+
to
{
actorType
.
name
}
)
;
}
return
types
.
addType
(
name
{
_actor
:
true
category
:
"
detail
"
read
:
(
v
ctx
)
=
>
actorType
.
read
(
v
ctx
detail
)
write
:
(
v
ctx
)
=
>
actorType
.
write
(
v
ctx
detail
)
}
)
;
}
;
types
.
addLifetime
=
function
(
name
prop
)
{
if
(
registeredLifetimes
.
has
(
name
)
)
{
throw
Error
(
"
Lifetime
'
"
+
name
+
"
'
already
registered
.
"
)
;
}
registeredLifetimes
.
set
(
name
prop
)
;
}
;
types
.
removeLifetime
=
function
(
name
)
{
registeredLifetimes
.
delete
(
name
)
;
}
;
types
.
addLifetimeType
=
function
(
lifetime
subtype
)
{
subtype
=
types
.
getType
(
subtype
)
;
if
(
!
subtype
.
_actor
)
{
throw
Error
(
Lifetimes
only
apply
to
actor
types
tried
to
apply
+
lifetime
'
{
lifetime
}
'
to
{
subtype
.
name
}
)
;
}
const
prop
=
registeredLifetimes
.
get
(
lifetime
)
;
return
types
.
addType
(
lifetime
+
"
:
"
+
subtype
.
name
{
category
:
"
lifetime
"
read
:
(
value
ctx
)
=
>
subtype
.
read
(
value
ctx
[
prop
]
)
write
:
(
value
ctx
)
=
>
subtype
.
write
(
value
ctx
[
prop
]
)
}
)
;
}
;
types
.
Primitive
=
types
.
addType
(
"
primitive
"
)
;
types
.
String
=
types
.
addType
(
"
string
"
)
;
types
.
Number
=
types
.
addType
(
"
number
"
)
;
types
.
Boolean
=
types
.
addType
(
"
boolean
"
)
;
types
.
JSON
=
types
.
addType
(
"
json
"
)
;
var
Arg
=
function
(
index
type
)
{
this
.
index
=
index
;
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
Arg
.
prototype
=
{
write
:
function
(
arg
ctx
)
{
return
this
.
type
.
write
(
arg
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
)
{
outArgs
[
this
.
index
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_arg
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
;
exports
.
Arg
=
function
(
index
type
)
{
return
new
Arg
(
index
type
)
;
}
;
var
Option
=
function
(
index
type
)
{
Arg
.
call
(
this
index
type
)
;
}
;
Option
.
prototype
=
extend
(
Arg
.
prototype
{
write
:
function
(
arg
ctx
name
)
{
if
(
arg
=
=
undefined
|
|
arg
[
name
]
=
=
undefined
)
{
return
undefined
;
}
const
v
=
arg
[
name
]
;
return
this
.
type
.
write
(
v
ctx
)
;
}
read
:
function
(
v
ctx
outArgs
name
)
{
if
(
outArgs
[
this
.
index
]
=
=
=
undefined
)
{
outArgs
[
this
.
index
]
=
{
}
;
}
if
(
v
=
=
=
undefined
)
{
return
;
}
outArgs
[
this
.
index
]
[
name
]
=
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_option
:
this
.
index
type
:
this
.
type
.
name
}
;
}
}
)
;
exports
.
Option
=
function
(
index
type
)
{
return
new
Option
(
index
type
)
;
}
;
var
RetVal
=
function
(
type
)
{
loader
.
lazyGetter
(
this
"
type
"
function
(
)
{
return
types
.
getType
(
type
)
;
}
)
;
}
;
RetVal
.
prototype
=
{
write
:
function
(
v
ctx
)
{
return
this
.
type
.
write
(
v
ctx
)
;
}
read
:
function
(
v
ctx
)
{
return
this
.
type
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
{
_retval
:
this
.
type
.
name
}
;
}
}
;
exports
.
RetVal
=
function
(
type
)
{
return
new
RetVal
(
type
)
;
}
;
function
getPath
(
obj
path
)
{
for
(
const
name
of
path
)
{
if
(
!
(
name
in
obj
)
)
{
return
undefined
;
}
obj
=
obj
[
name
]
;
}
return
obj
;
}
function
findPlaceholders
(
template
constructor
path
=
[
]
placeholders
=
[
]
)
{
if
(
!
template
|
|
typeof
(
template
)
!
=
"
object
"
)
{
return
placeholders
;
}
if
(
template
instanceof
constructor
)
{
placeholders
.
push
(
{
placeholder
:
template
path
:
[
.
.
.
path
]
}
)
;
return
placeholders
;
}
for
(
const
name
in
template
)
{
path
.
push
(
name
)
;
findPlaceholders
(
template
[
name
]
constructor
path
placeholders
)
;
path
.
pop
(
)
;
}
return
placeholders
;
}
function
describeTemplate
(
template
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
template
(
key
value
)
=
>
{
if
(
value
.
describe
)
{
return
value
.
describe
(
)
;
}
return
value
;
}
)
)
;
}
var
Request
=
function
(
template
=
{
}
)
{
this
.
type
=
template
.
type
;
this
.
template
=
template
;
this
.
args
=
findPlaceholders
(
template
Arg
)
;
}
;
Request
.
prototype
=
{
write
:
function
(
fnArgs
ctx
)
{
const
ret
=
{
}
;
for
(
const
key
in
this
.
template
)
{
const
value
=
this
.
template
[
key
]
;
if
(
value
instanceof
Arg
)
{
ret
[
key
]
=
value
.
write
(
value
.
index
in
fnArgs
?
fnArgs
[
value
.
index
]
:
undefined
ctx
key
)
;
}
else
if
(
key
=
=
"
type
"
)
{
ret
[
key
]
=
value
;
}
else
{
throw
new
Error
(
"
Request
can
only
an
object
with
Arg
or
Option
properties
"
)
;
}
}
return
ret
;
}
read
:
function
(
packet
ctx
)
{
const
fnArgs
=
[
]
;
for
(
const
templateArg
of
this
.
args
)
{
const
arg
=
templateArg
.
placeholder
;
const
path
=
templateArg
.
path
;
const
name
=
path
[
path
.
length
-
1
]
;
arg
.
read
(
getPath
(
packet
path
)
ctx
fnArgs
name
)
;
}
return
fnArgs
;
}
describe
:
function
(
)
{
return
describeTemplate
(
this
.
template
)
;
}
}
;
var
Response
=
function
(
template
=
{
}
)
{
this
.
template
=
template
;
const
placeholders
=
findPlaceholders
(
template
RetVal
)
;
if
(
placeholders
.
length
>
1
)
{
throw
Error
(
"
More
than
one
RetVal
specified
in
response
"
)
;
}
const
placeholder
=
placeholders
.
shift
(
)
;
if
(
placeholder
)
{
this
.
retVal
=
placeholder
.
placeholder
;
this
.
path
=
placeholder
.
path
;
}
}
;
Response
.
prototype
=
{
write
:
function
(
ret
ctx
)
{
if
(
this
.
template
instanceof
RetVal
)
{
return
this
.
template
.
write
(
ret
ctx
)
;
}
const
result
=
{
}
;
for
(
const
key
in
this
.
template
)
{
const
value
=
this
.
template
[
key
]
;
if
(
value
instanceof
RetVal
)
{
result
[
key
]
=
value
.
write
(
ret
ctx
)
;
}
else
{
throw
new
Error
(
"
Response
can
only
be
a
RetVal
instance
or
an
object
"
+
"
with
one
property
being
a
RetVal
instance
.
"
)
;
}
}
return
result
;
}
read
:
function
(
packet
ctx
)
{
if
(
!
this
.
retVal
)
{
return
undefined
;
}
const
v
=
getPath
(
packet
this
.
path
)
;
return
this
.
retVal
.
read
(
v
ctx
)
;
}
describe
:
function
(
)
{
return
describeTemplate
(
this
.
template
)
;
}
}
;
class
Pool
extends
EventEmitter
{
constructor
(
conn
)
{
super
(
)
;
if
(
conn
)
{
this
.
conn
=
conn
;
}
this
.
__poolMap
=
null
;
}
parent
(
)
{
return
this
.
conn
.
poolFor
(
this
.
actorID
)
;
}
poolFor
(
actorID
)
{
return
this
.
conn
.
poolFor
(
actorID
)
;
}
marshallPool
(
)
{
return
this
;
}
get
_poolMap
(
)
{
if
(
this
.
__poolMap
)
{
return
this
.
__poolMap
;
}
this
.
__poolMap
=
new
Map
(
)
;
this
.
conn
.
addActorPool
(
this
)
;
return
this
.
__poolMap
;
}
manage
(
actor
)
{
if
(
!
actor
.
actorID
)
{
actor
.
actorID
=
this
.
conn
.
allocID
(
actor
.
actorPrefix
|
|
actor
.
typeName
)
;
}
else
{
const
parent
=
this
.
poolFor
(
actor
.
actorID
)
;
if
(
parent
)
{
parent
.
unmanage
(
actor
)
;
}
}
this
.
_poolMap
.
set
(
actor
.
actorID
actor
)
;
}
unmanage
(
actor
)
{
this
.
__poolMap
&
&
this
.
__poolMap
.
delete
(
actor
.
actorID
)
;
}
has
(
actorID
)
{
return
this
.
__poolMap
&
&
this
.
_poolMap
.
has
(
actorID
)
;
}
actor
(
actorID
)
{
if
(
this
.
__poolMap
)
{
return
this
.
_poolMap
.
get
(
actorID
)
;
}
return
null
;
}
get
(
actorID
)
{
if
(
this
.
__poolMap
)
{
return
this
.
_poolMap
.
get
(
actorID
)
;
}
return
null
;
}
isEmpty
(
)
{
return
!
this
.
__poolMap
|
|
this
.
_poolMap
.
size
=
=
0
;
}
*
poolChildren
(
)
{
if
(
!
this
.
__poolMap
)
{
return
;
}
for
(
const
actor
of
this
.
__poolMap
.
values
(
)
)
{
if
(
actor
=
=
=
this
)
{
continue
;
}
yield
actor
;
}
}
destroy
(
)
{
const
parent
=
this
.
parent
(
)
;
if
(
parent
)
{
parent
.
unmanage
(
this
)
;
}
if
(
!
this
.
__poolMap
)
{
return
;
}
for
(
const
actor
of
this
.
__poolMap
.
values
(
)
)
{
if
(
actor
=
=
=
this
)
{
continue
;
}
const
destroy
=
actor
.
destroy
;
if
(
destroy
)
{
actor
.
destroy
=
null
;
destroy
.
call
(
actor
)
;
actor
.
destroy
=
destroy
;
}
}
this
.
conn
.
removeActorPool
(
this
true
)
;
this
.
__poolMap
.
clear
(
)
;
this
.
__poolMap
=
null
;
}
cleanup
(
)
{
this
.
destroy
(
)
;
}
}
exports
.
Pool
=
Pool
;
var
actorSpecs
=
new
WeakMap
(
)
;
class
Actor
extends
Pool
{
initialize
(
conn
)
{
if
(
conn
)
{
this
.
conn
=
conn
;
}
this
.
actorID
=
null
;
this
.
_actorSpec
=
actorSpecs
.
get
(
Object
.
getPrototypeOf
(
this
)
)
;
if
(
this
.
_actorSpec
&
&
this
.
_actorSpec
.
events
)
{
for
(
const
[
name
request
]
of
this
.
_actorSpec
.
events
.
entries
(
)
)
{
this
.
on
(
name
(
.
.
.
args
)
=
>
{
this
.
_sendEvent
(
name
request
.
.
.
args
)
;
}
)
;
}
}
}
toString
(
)
{
return
"
[
Actor
"
+
this
.
typeName
+
"
/
"
+
this
.
actorID
+
"
]
"
;
}
_sendEvent
(
name
request
.
.
.
args
)
{
if
(
!
this
.
actorID
)
{
console
.
error
(
Tried
to
send
a
'
{
name
}
'
event
on
an
already
destroyed
actor
+
'
{
this
.
typeName
}
'
)
;
return
;
}
let
packet
;
try
{
packet
=
request
.
write
(
args
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
sending
event
:
"
+
name
)
;
throw
ex
;
}
packet
.
from
=
packet
.
from
|
|
this
.
actorID
;
this
.
conn
.
send
(
packet
)
;
}
destroy
(
)
{
super
.
destroy
(
)
;
this
.
actorID
=
null
;
}
form
(
hint
)
{
return
{
actor
:
this
.
actorID
}
;
}
writeError
(
error
typeName
method
)
{
console
.
error
(
Error
while
calling
actor
'
{
typeName
}
'
s
method
'
{
method
}
'
error
.
message
)
;
if
(
error
.
stack
)
{
console
.
error
(
error
.
stack
)
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
error
:
error
.
error
|
|
"
unknownError
"
message
:
error
.
message
}
)
;
}
_queueResponse
(
create
)
{
const
pending
=
this
.
_pendingResponse
|
|
Promise
.
resolve
(
null
)
;
const
response
=
create
(
pending
)
;
this
.
_pendingResponse
=
response
;
}
throwError
(
error
message
)
{
const
err
=
new
Error
(
message
)
;
err
.
error
=
error
;
throw
err
;
}
}
exports
.
Actor
=
Actor
;
exports
.
method
=
function
(
fn
spec
=
{
}
)
{
fn
.
_methodSpec
=
Object
.
freeze
(
spec
)
;
if
(
spec
.
request
)
{
Object
.
freeze
(
spec
.
request
)
;
}
if
(
spec
.
response
)
{
Object
.
freeze
(
spec
.
response
)
;
}
return
fn
;
}
;
var
generateActorSpec
=
function
(
actorDesc
)
{
const
actorSpec
=
{
typeName
:
actorDesc
.
typeName
methods
:
[
]
}
;
for
(
const
name
of
Object
.
getOwnPropertyNames
(
actorDesc
)
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
actorDesc
name
)
;
if
(
!
desc
.
value
)
{
continue
;
}
if
(
desc
.
value
.
_methodSpec
)
{
const
methodSpec
=
desc
.
value
.
_methodSpec
;
const
spec
=
{
}
;
spec
.
name
=
methodSpec
.
name
|
|
name
;
spec
.
request
=
new
Request
(
Object
.
assign
(
{
type
:
spec
.
name
}
methodSpec
.
request
|
|
undefined
)
)
;
spec
.
response
=
new
Response
(
methodSpec
.
response
|
|
undefined
)
;
spec
.
release
=
methodSpec
.
release
;
spec
.
oneway
=
methodSpec
.
oneway
;
actorSpec
.
methods
.
push
(
spec
)
;
}
}
if
(
actorDesc
.
methods
)
{
for
(
const
name
in
actorDesc
.
methods
)
{
const
methodSpec
=
actorDesc
.
methods
[
name
]
;
const
spec
=
{
}
;
spec
.
name
=
methodSpec
.
name
|
|
name
;
spec
.
request
=
new
Request
(
Object
.
assign
(
{
type
:
spec
.
name
}
methodSpec
.
request
|
|
undefined
)
)
;
spec
.
response
=
new
Response
(
methodSpec
.
response
|
|
undefined
)
;
spec
.
release
=
methodSpec
.
release
;
spec
.
oneway
=
methodSpec
.
oneway
;
actorSpec
.
methods
.
push
(
spec
)
;
}
}
if
(
actorDesc
.
events
)
{
actorSpec
.
events
=
new
Map
(
)
;
for
(
const
name
in
actorDesc
.
events
)
{
const
eventRequest
=
actorDesc
.
events
[
name
]
;
Object
.
freeze
(
eventRequest
)
;
actorSpec
.
events
.
set
(
name
new
Request
(
Object
.
assign
(
{
type
:
name
}
eventRequest
)
)
)
;
}
}
if
(
!
registeredTypes
.
has
(
actorSpec
.
typeName
)
)
{
types
.
addActorType
(
actorSpec
.
typeName
)
;
}
registeredTypes
.
get
(
actorSpec
.
typeName
)
.
actorSpec
=
actorSpec
;
return
actorSpec
;
}
;
exports
.
generateActorSpec
=
generateActorSpec
;
var
generateRequestHandlers
=
function
(
actorSpec
actorProto
)
{
actorProto
.
typeName
=
actorSpec
.
typeName
;
actorProto
.
requestTypes
=
Object
.
create
(
null
)
;
actorSpec
.
methods
.
forEach
(
spec
=
>
{
const
handler
=
function
(
packet
conn
)
{
try
{
let
args
;
try
{
args
=
spec
.
request
.
read
(
packet
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
request
:
"
+
packet
.
type
)
;
throw
ex
;
}
if
(
!
this
[
spec
.
name
]
)
{
throw
new
Error
(
Spec
for
'
{
actorProto
.
typeName
}
'
specifies
a
'
{
spec
.
name
}
'
+
method
that
isn
'
t
implemented
by
the
actor
)
;
}
const
ret
=
this
[
spec
.
name
]
.
apply
(
this
args
)
;
const
sendReturn
=
(
retToSend
)
=
>
{
if
(
spec
.
oneway
)
{
return
;
}
let
response
;
try
{
response
=
spec
.
response
.
write
(
retToSend
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
writing
response
to
:
"
+
spec
.
name
)
;
throw
ex
;
}
response
.
from
=
this
.
actorID
;
if
(
spec
.
release
)
{
try
{
this
.
destroy
(
)
;
}
catch
(
e
)
{
this
.
writeError
(
e
actorProto
.
typeName
spec
.
name
)
;
return
;
}
}
conn
.
send
(
response
)
;
}
;
this
.
_queueResponse
(
p
=
>
{
return
p
.
then
(
(
)
=
>
ret
)
.
then
(
sendReturn
)
.
catch
(
e
=
>
this
.
writeError
(
e
actorProto
.
typeName
spec
.
name
)
)
;
}
)
;
}
catch
(
e
)
{
this
.
_queueResponse
(
p
=
>
{
return
p
.
then
(
(
)
=
>
this
.
writeError
(
e
actorProto
.
typeName
spec
.
name
)
)
;
}
)
;
}
}
;
actorProto
.
requestTypes
[
spec
.
request
.
type
]
=
handler
;
}
)
;
return
actorProto
;
}
;
var
ActorClassWithSpec
=
function
(
actorSpec
actorProto
)
{
if
(
!
actorSpec
.
typeName
)
{
throw
Error
(
"
Actor
specification
must
have
a
typeName
member
.
"
)
;
}
const
cls
=
function
(
)
{
const
instance
=
Object
.
create
(
cls
.
prototype
)
;
instance
.
initialize
.
apply
(
instance
arguments
)
;
return
instance
;
}
;
cls
.
prototype
=
extend
(
Actor
.
prototype
generateRequestHandlers
(
actorSpec
actorProto
)
)
;
actorSpecs
.
set
(
cls
.
prototype
actorSpec
)
;
return
cls
;
}
;
exports
.
ActorClassWithSpec
=
ActorClassWithSpec
;
class
Front
extends
Pool
{
constructor
(
conn
=
null
form
=
null
)
{
super
(
conn
)
;
this
.
actorID
=
null
;
this
.
_requests
=
[
]
;
this
.
_frontListeners
=
new
EventEmitter
(
)
;
this
.
_beforeListeners
=
new
Map
(
)
;
if
(
form
)
{
this
.
actorID
=
form
.
actor
;
}
}
destroy
(
)
{
while
(
this
.
_requests
&
&
this
.
_requests
.
length
>
0
)
{
const
{
deferred
to
type
stack
}
=
this
.
_requests
.
shift
(
)
;
const
msg
=
"
Connection
closed
pending
request
to
"
+
to
+
"
type
"
+
type
+
"
failed
"
+
"
\
n
\
nRequest
stack
:
\
n
"
+
stack
.
formattedStack
;
deferred
.
reject
(
new
Error
(
msg
)
)
;
}
super
.
destroy
(
)
;
this
.
clearEvents
(
)
;
this
.
actorID
=
null
;
this
.
_frontListeners
=
null
;
this
.
_beforeListeners
=
null
;
}
manage
(
front
)
{
if
(
!
front
.
actorID
)
{
throw
new
Error
(
"
Can
'
t
manage
front
without
an
actor
ID
.
\
n
"
+
"
Ensure
server
supports
"
+
front
.
typeName
+
"
.
"
)
;
}
super
.
manage
(
front
)
;
this
.
_frontListeners
.
emit
(
front
.
typeName
front
)
;
}
onFront
(
typeName
callback
)
{
for
(
const
front
of
this
.
poolChildren
(
)
)
{
if
(
front
.
typeName
=
=
typeName
)
{
callback
(
front
)
;
}
}
this
.
_frontListeners
.
on
(
typeName
callback
)
;
}
before
(
type
callback
)
{
if
(
this
.
_beforeListeners
.
has
(
type
)
)
{
throw
new
Error
(
Can
'
t
register
multiple
before
listeners
for
"
{
type
}
"
.
)
;
}
this
.
_beforeListeners
.
set
(
type
callback
)
;
}
toString
(
)
{
return
"
[
Front
for
"
+
this
.
typeName
+
"
/
"
+
this
.
actorID
+
"
]
"
;
}
form
(
form
)
{
}
send
(
packet
)
{
if
(
packet
.
to
)
{
this
.
conn
.
_transport
.
send
(
packet
)
;
}
else
{
packet
.
to
=
this
.
actorID
;
if
(
this
.
conn
.
_transport
)
{
this
.
conn
.
_transport
.
send
(
packet
)
;
}
}
}
request
(
packet
)
{
const
deferred
=
defer
(
)
;
const
{
to
type
}
=
packet
;
this
.
_requests
.
push
(
{
deferred
to
:
to
|
|
this
.
actorID
type
stack
:
getStack
(
)
}
)
;
this
.
send
(
packet
)
;
return
deferred
.
promise
;
}
onPacket
(
packet
)
{
const
type
=
packet
.
type
|
|
undefined
;
if
(
this
.
_clientSpec
.
events
&
&
this
.
_clientSpec
.
events
.
has
(
type
)
)
{
const
event
=
this
.
_clientSpec
.
events
.
get
(
packet
.
type
)
;
let
args
;
try
{
args
=
event
.
request
.
read
(
packet
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
event
:
"
+
packet
.
type
)
;
console
.
exception
(
ex
)
;
throw
ex
;
}
const
beforeEvent
=
this
.
_beforeListeners
.
get
(
event
.
name
)
;
if
(
beforeEvent
)
{
const
result
=
beforeEvent
.
apply
(
this
args
)
;
if
(
result
&
&
typeof
result
.
then
=
=
"
function
"
)
{
result
.
then
(
(
)
=
>
{
super
.
emit
(
event
.
name
.
.
.
args
)
;
}
)
;
return
;
}
}
super
.
emit
(
event
.
name
.
.
.
args
)
;
return
;
}
if
(
this
.
_requests
.
length
=
=
=
0
)
{
const
msg
=
"
Unexpected
packet
"
+
this
.
actorID
+
"
"
+
JSON
.
stringify
(
packet
)
;
const
err
=
Error
(
msg
)
;
console
.
error
(
err
)
;
throw
err
;
}
const
{
deferred
stack
}
=
this
.
_requests
.
shift
(
)
;
callFunctionWithAsyncStack
(
(
)
=
>
{
if
(
packet
.
error
)
{
let
message
;
if
(
packet
.
error
&
&
packet
.
message
)
{
message
=
"
Protocol
error
(
"
+
packet
.
error
+
"
)
:
"
+
packet
.
message
;
}
else
{
message
=
packet
.
error
;
}
deferred
.
reject
(
message
)
;
}
else
{
deferred
.
resolve
(
packet
)
;
}
}
stack
"
DevTools
RDP
"
)
;
}
hasRequests
(
)
{
return
!
!
this
.
_requests
.
length
;
}
waitForRequestsToSettle
(
)
{
return
settleAll
(
this
.
_requests
.
map
(
(
{
deferred
}
)
=
>
deferred
.
promise
)
)
;
}
}
exports
.
Front
=
Front
;
var
generateRequestMethods
=
function
(
actorSpec
frontProto
)
{
if
(
frontProto
.
_actorSpec
)
{
throw
new
Error
(
"
frontProto
called
twice
on
the
same
front
prototype
!
"
)
;
}
frontProto
.
typeName
=
actorSpec
.
typeName
;
const
methods
=
actorSpec
.
methods
;
methods
.
forEach
(
spec
=
>
{
const
name
=
spec
.
name
;
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
if
(
!
this
.
actorID
)
{
throw
new
Error
(
Can
not
send
request
because
front
'
{
this
.
typeName
}
'
is
already
destroyed
.
)
;
}
let
packet
;
try
{
packet
=
spec
.
request
.
write
(
args
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
writing
request
:
"
+
name
)
;
throw
ex
;
}
if
(
spec
.
oneway
)
{
this
.
send
(
packet
)
;
return
undefined
;
}
return
this
.
request
(
packet
)
.
then
(
response
=
>
{
let
ret
;
try
{
ret
=
spec
.
response
.
read
(
response
this
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Error
reading
response
to
:
"
+
name
)
;
throw
ex
;
}
return
ret
;
}
)
;
}
;
if
(
spec
.
release
)
{
const
fn
=
frontProto
[
name
]
;
frontProto
[
name
]
=
function
(
.
.
.
args
)
{
return
fn
.
apply
(
this
args
)
.
then
(
result
=
>
{
this
.
destroy
(
)
;
return
result
;
}
)
;
}
;
}
}
)
;
frontProto
.
_clientSpec
=
{
}
;
const
actorEvents
=
actorSpec
.
events
;
if
(
actorEvents
)
{
frontProto
.
_clientSpec
.
events
=
new
Map
(
)
;
for
(
const
[
name
request
]
of
actorEvents
)
{
frontProto
.
_clientSpec
.
events
.
set
(
request
.
type
{
name
request
}
)
;
}
}
frontProto
.
_actorSpec
=
actorSpec
;
return
frontProto
;
}
;
var
FrontClassWithSpec
=
function
(
actorSpec
)
{
class
OneFront
extends
Front
{
}
generateRequestMethods
(
actorSpec
OneFront
.
prototype
)
;
return
OneFront
;
}
;
exports
.
FrontClassWithSpec
=
FrontClassWithSpec
;
exports
.
registerFront
=
function
(
cls
)
{
const
{
typeName
}
=
cls
.
prototype
;
if
(
!
registeredTypes
.
has
(
typeName
)
)
{
types
.
addActorType
(
typeName
)
;
}
registeredTypes
.
get
(
typeName
)
.
frontClass
=
cls
;
}
;
exports
.
dumpActorSpec
=
function
(
type
)
{
const
actorSpec
=
type
.
actorSpec
;
const
ret
=
{
category
:
"
actor
"
typeName
:
type
.
name
methods
:
[
]
events
:
{
}
}
;
for
(
const
method
of
actorSpec
.
methods
)
{
ret
.
methods
.
push
(
{
name
:
method
.
name
release
:
method
.
release
|
|
undefined
oneway
:
method
.
oneway
|
|
undefined
request
:
method
.
request
.
describe
(
)
response
:
method
.
response
.
describe
(
)
}
)
;
}
if
(
actorSpec
.
events
)
{
for
(
const
[
name
request
]
of
actorSpec
.
events
)
{
ret
.
events
[
name
]
=
request
.
describe
(
)
;
}
}
JSON
.
stringify
(
ret
)
;
return
ret
;
}
;
exports
.
dumpProtocolSpec
=
function
(
)
{
const
ret
=
{
types
:
{
}
}
;
for
(
let
[
name
type
]
of
registeredTypes
)
{
type
=
types
.
getType
(
name
)
;
const
category
=
type
.
category
|
|
undefined
;
if
(
category
=
=
=
"
dict
"
)
{
ret
.
types
[
name
]
=
{
category
:
"
dict
"
typeName
:
name
specializations
:
type
.
specializations
}
;
}
else
if
(
category
=
=
=
"
actor
"
)
{
ret
.
types
[
name
]
=
exports
.
dumpActorSpec
(
type
)
;
}
}
return
ret
;
}
;
function
getFront
(
client
typeName
form
)
{
const
type
=
types
.
getType
(
typeName
)
;
if
(
!
type
)
{
throw
new
Error
(
No
spec
for
front
type
'
{
typeName
}
'
.
)
;
}
if
(
!
type
.
frontClass
)
{
lazyLoadFront
(
typeName
)
;
}
const
Class
=
type
.
frontClass
;
const
instance
=
new
Class
(
client
form
)
;
if
(
typeof
(
instance
.
initialize
)
=
=
"
function
"
)
{
return
instance
.
initialize
(
client
form
)
.
then
(
(
)
=
>
instance
)
;
}
return
instance
;
}
exports
.
getFront
=
getFront
;
