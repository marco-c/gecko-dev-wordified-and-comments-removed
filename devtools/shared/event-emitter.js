"
use
strict
"
;
const
BAD_LISTENER
=
"
The
event
listener
must
be
a
function
or
an
object
that
has
"
+
"
EventEmitter
.
handler
Symbol
.
"
;
const
eventListeners
=
Symbol
(
"
EventEmitter
/
listeners
"
)
;
const
onceOriginalListener
=
Symbol
(
"
EventEmitter
/
once
-
original
-
listener
"
)
;
const
handler
=
Symbol
(
"
EventEmitter
/
event
-
handler
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
eventListeners
]
=
new
Map
(
)
;
}
static
on
(
target
type
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
&
&
!
isEventHandler
(
listener
)
)
{
throw
new
Error
(
BAD_LISTENER
)
;
}
if
(
!
(
eventListeners
in
target
)
)
{
target
[
eventListeners
]
=
new
Map
(
)
;
}
let
events
=
target
[
eventListeners
]
;
if
(
events
.
has
(
type
)
)
{
events
.
get
(
type
)
.
add
(
listener
)
;
}
else
{
events
.
set
(
type
new
Set
(
[
listener
]
)
)
;
}
}
static
off
(
target
type
listener
)
{
let
length
=
arguments
.
length
;
let
events
=
target
[
eventListeners
]
;
if
(
!
events
)
{
return
;
}
if
(
length
=
=
=
3
)
{
let
listenersForType
=
events
.
get
(
type
)
;
if
(
!
listenersForType
)
{
return
;
}
if
(
listenersForType
.
has
(
listener
)
)
{
listenersForType
.
delete
(
listener
)
;
}
else
{
for
(
let
value
of
listenersForType
.
values
(
)
)
{
if
(
onceOriginalListener
in
value
&
&
value
[
onceOriginalListener
]
=
=
=
listener
)
{
listenersForType
.
delete
(
value
)
;
break
;
}
}
}
}
else
if
(
length
=
=
=
2
)
{
if
(
events
.
has
(
type
)
)
{
events
.
delete
(
type
)
;
}
}
else
if
(
length
=
=
=
1
)
{
events
.
clear
(
)
;
}
}
static
once
(
target
type
listener
)
{
return
new
Promise
(
resolve
=
>
{
let
newListener
=
(
first
.
.
.
rest
)
=
>
{
EventEmitter
.
off
(
target
type
newListener
)
;
if
(
listener
)
{
if
(
isEventHandler
(
listener
)
)
{
listener
[
handler
]
(
type
first
.
.
.
rest
)
;
}
else
{
listener
.
call
(
target
first
.
.
.
rest
)
;
}
}
resolve
(
first
)
;
}
;
newListener
[
onceOriginalListener
]
=
listener
;
EventEmitter
.
on
(
target
type
newListener
)
;
}
)
;
}
static
emit
(
target
type
.
.
.
rest
)
{
logEvent
(
type
rest
)
;
if
(
!
(
eventListeners
in
target
)
|
|
!
target
[
eventListeners
]
.
has
(
type
)
)
{
return
;
}
let
listenersForType
=
new
Set
(
target
[
eventListeners
]
.
get
(
type
)
)
;
for
(
let
listener
of
listenersForType
)
{
if
(
!
(
eventListeners
in
target
)
)
{
break
;
}
let
events
=
target
[
eventListeners
]
;
let
listeners
=
events
.
get
(
type
)
;
if
(
listeners
&
&
listeners
.
has
(
listener
)
)
{
try
{
if
(
isEventHandler
(
listener
)
)
{
listener
[
handler
]
(
type
.
.
.
rest
)
;
}
else
{
listener
.
call
(
target
.
.
.
rest
)
;
}
}
catch
(
ex
)
{
let
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
error
(
msg
)
;
dump
(
msg
+
"
\
n
"
)
;
}
}
}
}
static
count
(
target
type
)
{
if
(
eventListeners
in
target
)
{
let
listenersForType
=
target
[
eventListeners
]
.
get
(
type
)
;
if
(
listenersForType
)
{
return
listenersForType
.
size
;
}
}
return
0
;
}
static
decorate
(
target
)
{
let
descriptors
=
Object
.
getOwnPropertyDescriptors
(
this
.
prototype
)
;
delete
descriptors
.
constructor
;
return
Object
.
defineProperties
(
target
descriptors
)
;
}
static
get
handler
(
)
{
return
handler
;
}
on
(
.
.
.
args
)
{
EventEmitter
.
on
(
this
.
.
.
args
)
;
}
off
(
.
.
.
args
)
{
EventEmitter
.
off
(
this
.
.
.
args
)
;
}
once
(
.
.
.
args
)
{
return
EventEmitter
.
once
(
this
.
.
.
args
)
;
}
emit
(
.
.
.
args
)
{
EventEmitter
.
emit
(
this
.
.
.
args
)
;
}
}
module
.
exports
=
EventEmitter
;
const
isEventHandler
=
(
listener
)
=
>
listener
&
&
handler
in
listener
&
&
typeof
listener
[
handler
]
=
=
=
"
function
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
describeNthCaller
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
let
loggingEnabled
=
true
;
if
(
!
isWorker
)
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
dump
.
emit
"
{
observe
:
(
)
=
>
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
)
;
}
}
)
;
}
function
serialize
(
target
)
{
let
out
=
String
(
target
)
;
if
(
target
&
&
target
.
nodeName
)
{
out
+
=
"
(
"
+
target
.
nodeName
;
if
(
target
.
id
)
{
out
+
=
"
#
"
+
target
.
id
;
}
if
(
target
.
className
)
{
out
+
=
"
.
"
+
target
.
className
;
}
out
+
=
"
)
"
;
}
return
out
;
}
function
logEvent
(
type
args
)
{
if
(
!
loggingEnabled
)
{
return
;
}
let
argsOut
=
"
"
;
let
description
=
describeNthCaller
(
2
)
;
try
{
argsOut
=
args
.
map
(
serialize
)
.
join
(
"
"
)
;
}
catch
(
e
)
{
}
dump
(
EMITTING
:
emit
(
{
type
}
{
argsOut
}
)
from
{
description
}
\
n
)
;
}
