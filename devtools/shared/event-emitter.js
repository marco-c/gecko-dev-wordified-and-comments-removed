"
use
strict
"
;
const
BAD_LISTENER
=
"
The
event
listener
must
be
a
function
or
an
object
that
has
"
+
"
EventEmitter
.
handler
Symbol
.
"
;
const
eventListeners
=
Symbol
(
"
EventEmitter
/
listeners
"
)
;
const
onceOriginalListener
=
Symbol
(
"
EventEmitter
/
once
-
original
-
listener
"
)
;
const
handler
=
Symbol
(
"
EventEmitter
/
event
-
handler
"
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
class
EventEmitter
{
static
on
(
target
type
listener
{
signal
}
=
{
}
)
{
if
(
typeof
listener
!
=
=
"
function
"
&
&
!
isEventHandler
(
listener
)
)
{
throw
new
Error
(
BAD_LISTENER
)
;
}
if
(
signal
?
.
aborted
=
=
=
true
)
{
return
(
)
=
>
{
}
;
}
if
(
!
(
eventListeners
in
target
)
)
{
target
[
eventListeners
]
=
new
Map
(
)
;
}
const
events
=
target
[
eventListeners
]
;
if
(
events
.
has
(
type
)
)
{
events
.
get
(
type
)
.
add
(
listener
)
;
}
else
{
events
.
set
(
type
new
Set
(
[
listener
]
)
)
;
}
const
offFn
=
(
)
=
>
EventEmitter
.
off
(
target
type
listener
)
;
if
(
signal
)
{
signal
.
addEventListener
(
"
abort
"
offFn
{
once
:
true
}
)
;
}
return
offFn
;
}
static
off
(
target
type
listener
)
{
const
length
=
arguments
.
length
;
const
events
=
target
[
eventListeners
]
;
if
(
!
events
)
{
return
;
}
if
(
length
>
=
3
)
{
const
listenersForType
=
events
.
get
(
type
)
;
if
(
!
listenersForType
)
{
return
;
}
if
(
listenersForType
.
has
(
listener
)
)
{
listenersForType
.
delete
(
listener
)
;
}
else
{
for
(
const
value
of
listenersForType
.
values
(
)
)
{
if
(
onceOriginalListener
in
value
&
&
value
[
onceOriginalListener
]
=
=
=
listener
)
{
listenersForType
.
delete
(
value
)
;
break
;
}
}
}
}
else
if
(
length
=
=
=
2
)
{
if
(
events
.
has
(
type
)
)
{
events
.
delete
(
type
)
;
}
}
else
if
(
length
=
=
=
1
)
{
events
.
clear
(
)
;
}
}
static
clearEvents
(
target
)
{
const
events
=
target
[
eventListeners
]
;
if
(
!
events
)
{
return
;
}
events
.
clear
(
)
;
}
static
once
(
target
type
listener
options
)
{
return
new
Promise
(
resolve
=
>
{
const
newListener
=
(
first
.
.
.
rest
)
=
>
{
EventEmitter
.
off
(
target
type
newListener
)
;
let
rv
;
if
(
listener
)
{
if
(
isEventHandler
(
listener
)
)
{
rv
=
listener
[
handler
]
(
type
first
.
.
.
rest
)
;
}
else
{
rv
=
listener
.
call
(
target
first
.
.
.
rest
)
;
}
}
resolve
(
first
)
;
return
rv
;
}
;
newListener
[
onceOriginalListener
]
=
listener
;
EventEmitter
.
on
(
target
type
newListener
options
)
;
}
)
;
}
static
emit
(
target
type
.
.
.
rest
)
{
EventEmitter
.
_emit
(
target
type
false
rest
)
;
}
static
emitAsync
(
target
type
.
.
.
rest
)
{
return
EventEmitter
.
_emit
(
target
type
true
rest
)
;
}
static
_emit
(
target
type
async
args
)
{
if
(
loggingEnabled
)
{
logEvent
(
type
args
)
;
}
const
targetEventListeners
=
target
[
eventListeners
]
;
if
(
!
targetEventListeners
)
{
return
undefined
;
}
const
listeners
=
targetEventListeners
.
get
(
type
)
;
if
(
!
listeners
?
.
size
)
{
return
undefined
;
}
const
promises
=
async
?
[
]
:
null
;
for
(
const
listener
of
new
Set
(
listeners
)
)
{
if
(
!
(
eventListeners
in
target
)
)
{
break
;
}
if
(
listeners
&
&
listeners
.
has
(
listener
)
)
{
try
{
let
promise
;
if
(
isEventHandler
(
listener
)
)
{
promise
=
listener
[
handler
]
(
type
.
.
.
args
)
;
}
else
{
promise
=
listener
.
apply
(
target
args
)
;
}
if
(
async
)
{
if
(
!
promise
|
|
promise
.
constructor
.
name
!
=
"
Promise
"
)
{
console
.
warn
(
Listener
for
event
'
{
type
}
'
did
not
return
a
promise
.
)
;
}
else
{
promises
.
push
(
promise
)
;
}
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
const
msg
=
ex
+
"
:
"
+
ex
.
stack
;
dump
(
msg
+
"
\
n
"
)
;
}
}
}
if
(
async
)
{
return
Promise
.
all
(
promises
)
;
}
return
undefined
;
}
static
count
(
target
type
)
{
if
(
eventListeners
in
target
)
{
const
listenersForType
=
target
[
eventListeners
]
.
get
(
type
)
;
if
(
listenersForType
)
{
return
listenersForType
.
size
;
}
}
return
0
;
}
static
decorate
(
target
)
{
const
descriptors
=
Object
.
getOwnPropertyDescriptors
(
this
.
prototype
)
;
delete
descriptors
.
constructor
;
return
Object
.
defineProperties
(
target
descriptors
)
;
}
static
get
handler
(
)
{
return
handler
;
}
on
(
.
.
.
args
)
{
return
EventEmitter
.
on
(
this
.
.
.
args
)
;
}
off
(
.
.
.
args
)
{
EventEmitter
.
off
(
this
.
.
.
args
)
;
}
clearEvents
(
)
{
EventEmitter
.
clearEvents
(
this
)
;
}
once
(
.
.
.
args
)
{
return
EventEmitter
.
once
(
this
.
.
.
args
)
;
}
emit
(
.
.
.
args
)
{
EventEmitter
.
emit
(
this
.
.
.
args
)
;
}
emitAsync
(
.
.
.
args
)
{
return
EventEmitter
.
emitAsync
(
this
.
.
.
args
)
;
}
emitForTests
(
.
.
.
args
)
{
if
(
flags
.
testing
)
{
EventEmitter
.
emit
(
this
.
.
.
args
)
;
}
}
count
(
.
.
.
args
)
{
return
EventEmitter
.
count
(
this
.
.
.
args
)
;
}
}
module
.
exports
=
EventEmitter
;
const
isEventHandler
=
listener
=
>
listener
&
&
handler
in
listener
&
&
typeof
listener
[
handler
]
=
=
=
"
function
"
;
const
{
getNthPathExcluding
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
let
loggingEnabled
=
false
;
if
(
!
isWorker
)
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
false
)
;
const
observer
=
{
observe
:
(
)
=
>
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
)
;
}
}
;
Services
.
prefs
.
addObserver
(
"
devtools
.
dump
.
emit
"
observer
)
;
const
unloadObserver
=
function
(
subject
)
{
if
(
subject
.
wrappedJSObject
=
=
require
(
"
loader
/
unload
"
)
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
dump
.
emit
"
observer
)
;
Services
.
obs
.
removeObserver
(
unloadObserver
"
devtools
:
loader
:
destroy
"
)
;
}
}
;
Services
.
obs
.
addObserver
(
unloadObserver
"
devtools
:
loader
:
destroy
"
)
;
}
function
serialize
(
target
)
{
const
MAXLEN
=
60
;
if
(
typeof
target
=
=
=
"
undefined
"
)
{
return
"
undefined
"
;
}
if
(
target
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
target
=
=
=
"
string
"
|
|
typeof
target
=
=
=
"
number
"
)
{
return
truncate
(
target
MAXLEN
)
;
}
if
(
target
.
nodeName
)
{
let
out
=
target
.
nodeName
;
if
(
target
.
id
)
{
out
+
=
"
#
"
+
target
.
id
;
}
if
(
target
.
className
)
{
out
+
=
"
.
"
+
target
.
className
;
}
return
out
;
}
if
(
Array
.
isArray
(
target
)
)
{
return
truncate
(
target
.
toSource
(
)
MAXLEN
)
;
}
if
(
typeof
target
=
=
=
"
function
"
)
{
return
function
{
target
.
name
?
target
.
name
:
"
anonymous
"
}
(
)
;
}
if
(
target
?
.
constructor
?
.
name
=
=
=
"
Window
"
)
{
return
window
(
{
target
.
location
.
origin
}
)
;
}
if
(
typeof
target
=
=
=
"
object
"
)
{
let
out
=
"
{
"
;
const
entries
=
Object
.
entries
(
target
)
;
for
(
let
i
=
0
;
i
<
Math
.
min
(
10
entries
.
length
)
;
i
+
+
)
{
const
[
name
value
]
=
entries
[
i
]
;
if
(
i
>
0
)
{
out
+
=
"
"
;
}
out
+
=
{
name
}
:
{
truncate
(
value
MAXLEN
)
}
;
}
return
out
+
"
}
"
;
}
return
truncate
(
target
.
toSource
(
)
MAXLEN
)
;
}
function
truncate
(
value
maxLen
)
{
const
str
=
String
(
value
)
;
return
str
.
length
>
maxLen
?
str
.
substring
(
0
maxLen
)
+
"
.
.
.
"
:
str
;
}
function
logEvent
(
type
args
)
{
let
argsOut
=
"
"
;
try
{
argsOut
=
{
args
.
map
(
serialize
)
.
join
(
"
"
)
}
;
}
catch
(
e
)
{
}
const
path
=
getNthPathExcluding
(
0
"
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
if
(
args
.
length
)
{
dump
(
EMITTING
:
emit
(
{
type
}
{
argsOut
}
)
from
{
path
}
\
n
)
;
}
else
{
dump
(
EMITTING
:
emit
(
{
type
}
)
from
{
path
}
\
n
)
;
}
}
