"
use
strict
"
;
const
BAD_LISTENER
=
"
The
event
listener
must
be
a
function
or
an
object
that
has
"
+
"
EventEmitter
.
handler
Symbol
.
"
;
const
eventListeners
=
Symbol
(
"
EventEmitter
/
listeners
"
)
;
const
onceOriginalListener
=
Symbol
(
"
EventEmitter
/
once
-
original
-
listener
"
)
;
const
handler
=
Symbol
(
"
EventEmitter
/
event
-
handler
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
eventListeners
]
=
new
Map
(
)
;
}
static
on
(
target
type
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
&
&
!
isEventHandler
(
listener
)
)
{
throw
new
Error
(
BAD_LISTENER
)
;
}
if
(
!
(
eventListeners
in
target
)
)
{
target
[
eventListeners
]
=
new
Map
(
)
;
}
const
events
=
target
[
eventListeners
]
;
if
(
events
.
has
(
type
)
)
{
events
.
get
(
type
)
.
add
(
listener
)
;
}
else
{
events
.
set
(
type
new
Set
(
[
listener
]
)
)
;
}
}
static
off
(
target
type
listener
)
{
const
length
=
arguments
.
length
;
const
events
=
target
[
eventListeners
]
;
if
(
!
events
)
{
return
;
}
if
(
length
>
=
3
)
{
const
listenersForType
=
events
.
get
(
type
)
;
if
(
!
listenersForType
)
{
return
;
}
if
(
listenersForType
.
has
(
listener
)
)
{
listenersForType
.
delete
(
listener
)
;
}
else
{
for
(
const
value
of
listenersForType
.
values
(
)
)
{
if
(
onceOriginalListener
in
value
&
&
value
[
onceOriginalListener
]
=
=
=
listener
)
{
listenersForType
.
delete
(
value
)
;
break
;
}
}
}
}
else
if
(
length
=
=
=
2
)
{
if
(
events
.
has
(
type
)
)
{
events
.
delete
(
type
)
;
}
}
else
if
(
length
=
=
=
1
)
{
events
.
clear
(
)
;
}
}
static
clearEvents
(
target
)
{
const
events
=
target
[
eventListeners
]
;
if
(
!
events
)
{
return
;
}
events
.
clear
(
)
;
}
static
once
(
target
type
listener
)
{
return
new
Promise
(
resolve
=
>
{
const
newListener
=
(
first
.
.
.
rest
)
=
>
{
EventEmitter
.
off
(
target
type
newListener
)
;
if
(
listener
)
{
if
(
isEventHandler
(
listener
)
)
{
listener
[
handler
]
(
type
first
.
.
.
rest
)
;
}
else
{
listener
.
call
(
target
first
.
.
.
rest
)
;
}
}
resolve
(
first
)
;
}
;
newListener
[
onceOriginalListener
]
=
listener
;
EventEmitter
.
on
(
target
type
newListener
)
;
}
)
;
}
static
emit
(
target
type
.
.
.
rest
)
{
logEvent
(
type
rest
)
;
if
(
!
(
eventListeners
in
target
)
)
{
return
;
}
if
(
target
[
eventListeners
]
.
has
(
type
)
)
{
const
listenersForType
=
new
Set
(
target
[
eventListeners
]
.
get
(
type
)
)
;
const
events
=
target
[
eventListeners
]
;
const
listeners
=
events
.
get
(
type
)
;
for
(
const
listener
of
listenersForType
)
{
if
(
!
(
eventListeners
in
target
)
)
{
break
;
}
if
(
listeners
&
&
listeners
.
has
(
listener
)
)
{
try
{
if
(
isEventHandler
(
listener
)
)
{
listener
[
handler
]
(
type
.
.
.
rest
)
;
}
else
{
listener
.
call
(
target
.
.
.
rest
)
;
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
const
msg
=
ex
+
"
:
"
+
ex
.
stack
;
dump
(
msg
+
"
\
n
"
)
;
}
}
}
}
const
hasWildcardListeners
=
target
[
eventListeners
]
.
has
(
"
*
"
)
;
if
(
type
!
=
=
"
*
"
&
&
hasWildcardListeners
)
{
EventEmitter
.
emit
(
target
"
*
"
type
.
.
.
rest
)
;
}
}
static
count
(
target
type
)
{
if
(
eventListeners
in
target
)
{
const
listenersForType
=
target
[
eventListeners
]
.
get
(
type
)
;
if
(
listenersForType
)
{
return
listenersForType
.
size
;
}
}
return
0
;
}
static
decorate
(
target
)
{
const
descriptors
=
Object
.
getOwnPropertyDescriptors
(
this
.
prototype
)
;
delete
descriptors
.
constructor
;
return
Object
.
defineProperties
(
target
descriptors
)
;
}
static
get
handler
(
)
{
return
handler
;
}
on
(
.
.
.
args
)
{
EventEmitter
.
on
(
this
.
.
.
args
)
;
}
off
(
.
.
.
args
)
{
EventEmitter
.
off
(
this
.
.
.
args
)
;
}
clearEvents
(
)
{
EventEmitter
.
clearEvents
(
this
)
;
}
once
(
.
.
.
args
)
{
return
EventEmitter
.
once
(
this
.
.
.
args
)
;
}
emit
(
.
.
.
args
)
{
EventEmitter
.
emit
(
this
.
.
.
args
)
;
}
}
module
.
exports
=
EventEmitter
;
const
isEventHandler
=
listener
=
>
listener
&
&
handler
in
listener
&
&
typeof
listener
[
handler
]
=
=
=
"
function
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
getNthPathExcluding
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
let
loggingEnabled
=
false
;
if
(
!
isWorker
)
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
dump
.
emit
"
{
observe
:
(
)
=
>
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
dump
.
emit
"
)
;
}
}
)
;
}
function
serialize
(
target
)
{
const
MAXLEN
=
60
;
if
(
typeof
target
=
=
=
"
undefined
"
)
{
return
"
undefined
"
;
}
if
(
target
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
target
=
=
=
"
string
"
|
|
typeof
target
=
=
=
"
number
"
)
{
return
truncate
(
target
MAXLEN
)
;
}
if
(
target
.
nodeName
)
{
let
out
=
target
.
nodeName
;
if
(
target
.
id
)
{
out
+
=
"
#
"
+
target
.
id
;
}
if
(
target
.
className
)
{
out
+
=
"
.
"
+
target
.
className
;
}
return
out
;
}
if
(
Array
.
isArray
(
target
)
)
{
return
truncate
(
target
.
toSource
(
)
MAXLEN
)
;
}
if
(
typeof
target
=
=
=
"
function
"
)
{
return
function
{
target
.
name
?
target
.
name
:
"
anonymous
"
}
(
)
;
}
if
(
target
.
constructor
&
&
target
.
constructor
.
name
&
&
target
.
constructor
.
name
=
=
=
"
Window
"
)
{
return
window
(
{
target
.
location
.
origin
}
)
;
}
if
(
typeof
target
=
=
=
"
object
"
)
{
let
out
=
"
{
"
;
const
entries
=
Object
.
entries
(
target
)
;
for
(
let
i
=
0
;
i
<
Math
.
min
(
10
entries
.
length
)
;
i
+
+
)
{
const
[
name
value
]
=
entries
[
i
]
;
if
(
i
>
0
)
{
out
+
=
"
"
;
}
out
+
=
{
name
}
:
{
truncate
(
value
MAXLEN
)
}
;
}
return
out
+
"
}
"
;
}
return
truncate
(
target
.
toSource
(
)
MAXLEN
)
;
}
function
truncate
(
value
maxLen
)
{
const
str
=
String
(
value
)
;
return
str
.
length
>
maxLen
?
str
.
substring
(
0
maxLen
)
+
"
.
.
.
"
:
str
;
}
function
logEvent
(
type
args
)
{
if
(
!
loggingEnabled
)
{
return
;
}
let
argsOut
=
"
"
;
try
{
argsOut
=
{
args
.
map
(
serialize
)
.
join
(
"
"
)
}
;
}
catch
(
e
)
{
}
const
path
=
getNthPathExcluding
(
0
"
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
if
(
args
.
length
>
0
)
{
dump
(
EMITTING
:
emit
(
{
type
}
{
argsOut
}
)
from
{
path
}
\
n
)
;
}
else
{
dump
(
EMITTING
:
emit
(
{
type
}
)
from
{
path
}
\
n
)
;
}
}
