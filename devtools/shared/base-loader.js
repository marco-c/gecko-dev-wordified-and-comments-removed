'
use
strict
'
;
this
.
EXPORTED_SYMBOLS
=
[
"
Loader
"
"
resolveURI
"
"
Module
"
"
Require
"
]
const
{
classes
:
Cc
Constructor
:
CC
interfaces
:
Ci
utils
:
Cu
results
:
Cr
manager
:
Cm
}
=
Components
;
const
systemPrincipal
=
CC
(
'
mozilla
.
org
/
systemprincipal
;
1
'
'
nsIPrincipal
'
)
(
)
;
const
{
loadSubScript
}
=
Cc
[
'
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
'
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
const
{
addObserver
notifyObservers
}
=
Cc
[
'
mozilla
.
org
/
observer
-
service
;
1
'
]
.
getService
(
Ci
.
nsIObserverService
)
;
const
{
XPCOMUtils
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
{
}
)
;
const
{
NetUtil
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
{
}
)
;
const
{
normalize
dirname
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
ospath_unix
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
resProto
"
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
resource
"
"
nsIResProtocolHandler
"
)
;
const
{
defineLazyGetter
}
=
XPCOMUtils
;
const
bind
=
Function
.
call
.
bind
(
Function
.
bind
)
;
const
getOwnPropertyDescriptor
=
Object
.
getOwnPropertyDescriptor
;
const
prototypeOf
=
Object
.
getPrototypeOf
;
function
*
getOwnIdentifiers
(
x
)
{
yield
*
Object
.
getOwnPropertyNames
(
x
)
;
yield
*
Object
.
getOwnPropertySymbols
(
x
)
;
}
function
sourceURI
(
uri
)
{
return
String
(
uri
)
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
function
isntLoaderFrame
(
frame
)
{
return
frame
.
fileName
!
=
=
__URI__
}
function
parseURI
(
uri
)
{
return
String
(
uri
)
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
function
parseStack
(
stack
)
{
let
lines
=
String
(
stack
)
.
split
(
"
\
n
"
)
;
return
lines
.
reduce
(
function
(
frames
line
)
{
if
(
line
)
{
let
atIndex
=
line
.
indexOf
(
"
"
)
;
let
columnIndex
=
line
.
lastIndexOf
(
"
:
"
)
;
let
lineIndex
=
line
.
lastIndexOf
(
"
:
"
columnIndex
-
1
)
;
let
fileName
=
parseURI
(
line
.
slice
(
atIndex
+
1
lineIndex
)
)
;
let
lineNumber
=
parseInt
(
line
.
slice
(
lineIndex
+
1
columnIndex
)
)
;
let
columnNumber
=
parseInt
(
line
.
slice
(
columnIndex
+
1
)
)
;
let
name
=
line
.
slice
(
0
atIndex
)
.
split
(
"
(
"
)
.
shift
(
)
;
frames
.
unshift
(
{
fileName
:
fileName
name
:
name
lineNumber
:
lineNumber
columnNumber
:
columnNumber
}
)
;
}
return
frames
;
}
[
]
)
;
}
function
serializeStack
(
frames
)
{
return
frames
.
reduce
(
function
(
stack
frame
)
{
return
frame
.
name
+
"
"
+
frame
.
fileName
+
"
:
"
+
frame
.
lineNumber
+
"
:
"
+
frame
.
columnNumber
+
"
\
n
"
+
stack
;
}
"
"
)
;
}
function
readURI
(
uri
)
{
let
nsURI
=
NetUtil
.
newURI
(
uri
)
;
if
(
nsURI
.
scheme
=
=
"
resource
"
)
{
uri
=
resProto
.
resolveURI
(
nsURI
)
;
}
let
stream
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
uri
'
UTF
-
8
'
)
loadUsingSystemPrincipal
:
true
}
)
.
open2
(
)
;
let
count
=
stream
.
available
(
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
count
{
charset
:
'
UTF
-
8
'
}
)
;
stream
.
close
(
)
;
return
data
;
}
function
join
(
base
.
.
.
paths
)
{
let
match
=
/
^
(
(
?
:
resource
|
file
|
chrome
)
\
:
\
/
\
/
[
^
\
/
]
*
|
jar
:
[
^
!
]
+
!
)
(
.
*
)
/
.
exec
(
base
)
;
if
(
match
)
{
return
match
[
1
]
+
normalize
(
[
match
[
2
]
.
.
.
paths
]
.
join
(
"
/
"
)
)
;
}
return
normalize
(
[
base
.
.
.
paths
]
.
join
(
"
/
"
)
)
;
}
function
Sandbox
(
options
)
{
options
=
{
wantComponents
:
false
sandboxName
:
options
.
name
principal
:
'
principal
'
in
options
?
options
.
principal
:
systemPrincipal
wantXrays
:
'
wantXrays
'
in
options
?
options
.
wantXrays
:
true
sandboxPrototype
:
'
prototype
'
in
options
?
options
.
prototype
:
{
}
invisibleToDebugger
:
'
invisibleToDebugger
'
in
options
?
options
.
invisibleToDebugger
:
false
metadata
:
'
metadata
'
in
options
?
options
.
metadata
:
{
}
waiveIntereposition
:
!
!
options
.
waiveIntereposition
}
;
if
(
options
.
metadata
&
&
options
.
metadata
.
addonID
)
{
options
.
addonId
=
options
.
metadata
.
addonID
;
}
let
sandbox
=
Cu
.
Sandbox
(
options
.
principal
options
)
;
delete
sandbox
.
Iterator
;
delete
sandbox
.
Components
;
delete
sandbox
.
importFunction
;
delete
sandbox
.
debug
;
return
sandbox
;
}
function
load
(
loader
module
)
{
let
{
sandboxes
globals
loadModuleHook
}
=
loader
;
let
require
=
Require
(
loader
module
)
;
let
descriptors
=
{
require
:
{
configurable
:
true
enumerable
:
true
writable
:
true
value
:
require
}
module
:
{
configurable
:
true
enumerable
:
true
writable
:
true
value
:
module
}
exports
:
{
configurable
:
true
enumerable
:
true
writable
:
true
value
:
module
.
exports
}
}
;
let
sandbox
;
if
(
loader
.
useSharedGlobalSandbox
|
|
isSystemURI
(
module
.
uri
)
)
{
sandbox
=
new
loader
.
sharedGlobalSandbox
.
Object
(
)
;
descriptors
.
lazyRequire
=
{
configurable
:
true
value
:
lazyRequire
.
bind
(
sandbox
)
}
;
descriptors
.
lazyRequireModule
=
{
configurable
:
true
value
:
lazyRequireModule
.
bind
(
sandbox
)
}
;
if
(
"
console
"
in
globals
)
{
descriptors
.
console
=
{
configurable
:
true
get
(
)
{
return
globals
.
console
;
}
}
;
}
let
define
=
Object
.
getOwnPropertyDescriptor
(
globals
"
define
"
)
;
if
(
define
&
&
define
.
value
)
descriptors
.
define
=
define
;
if
(
"
DOMParser
"
in
globals
)
descriptors
.
DOMParser
=
Object
.
getOwnPropertyDescriptor
(
globals
"
DOMParser
"
)
;
Object
.
defineProperties
(
sandbox
descriptors
)
;
}
else
{
sandbox
=
Sandbox
(
{
name
:
module
.
uri
prototype
:
Object
.
create
(
globals
descriptors
)
wantXrays
:
false
invisibleToDebugger
:
loader
.
invisibleToDebugger
metadata
:
{
addonID
:
loader
.
id
URI
:
module
.
uri
}
}
)
;
}
sandboxes
[
module
.
uri
]
=
sandbox
;
let
originalExports
=
module
.
exports
;
try
{
loadSubScript
(
module
.
uri
sandbox
'
UTF
-
8
'
)
;
}
catch
(
error
)
{
let
{
message
fileName
lineNumber
}
=
error
;
let
stack
=
error
.
stack
|
|
Error
(
)
.
stack
;
let
frames
=
parseStack
(
stack
)
.
filter
(
isntLoaderFrame
)
;
let
toString
=
String
(
error
)
;
let
file
=
sourceURI
(
fileName
)
;
if
(
/
^
Error
opening
input
stream
/
.
test
(
String
(
error
)
)
)
{
let
caller
=
frames
.
slice
(
0
)
.
pop
(
)
;
fileName
=
caller
.
fileName
;
lineNumber
=
caller
.
lineNumber
;
message
=
"
Module
"
+
module
.
id
+
"
is
not
found
at
"
+
module
.
uri
;
toString
=
message
;
}
else
if
(
frames
[
frames
.
length
-
1
]
.
fileName
!
=
=
file
)
{
frames
.
push
(
{
fileName
:
file
lineNumber
:
lineNumber
name
:
"
"
}
)
;
}
let
prototype
=
typeof
(
error
)
=
=
=
"
object
"
?
error
.
constructor
.
prototype
:
Error
.
prototype
;
throw
Object
.
create
(
prototype
{
message
:
{
value
:
message
writable
:
true
configurable
:
true
}
fileName
:
{
value
:
fileName
writable
:
true
configurable
:
true
}
lineNumber
:
{
value
:
lineNumber
writable
:
true
configurable
:
true
}
stack
:
{
value
:
serializeStack
(
frames
)
writable
:
true
configurable
:
true
}
toString
:
{
value
:
(
)
=
>
toString
writable
:
true
configurable
:
true
}
}
)
;
}
if
(
loadModuleHook
)
{
module
=
loadModuleHook
(
module
require
)
;
}
if
(
module
.
exports
=
=
=
originalExports
)
Object
.
freeze
(
module
.
exports
)
;
return
module
;
}
function
normalizeExt
(
uri
)
{
return
isJSURI
(
uri
)
?
uri
:
isJSONURI
(
uri
)
?
uri
:
isJSMURI
(
uri
)
?
uri
:
uri
+
'
.
js
'
;
}
function
resolve
(
id
base
)
{
if
(
!
isRelative
(
id
)
)
return
id
;
let
baseDir
=
dirname
(
base
)
;
let
resolved
;
if
(
baseDir
.
includes
(
"
:
"
)
)
resolved
=
join
(
baseDir
id
)
;
else
resolved
=
normalize
(
{
baseDir
}
/
{
id
}
)
;
if
(
base
.
startsWith
(
'
.
/
'
)
)
resolved
=
'
.
/
'
+
resolved
;
return
resolved
;
}
function
addTrailingSlash
(
path
)
{
return
path
.
replace
(
/
\
/
*
/
"
/
"
)
;
}
function
compileMapping
(
paths
)
{
let
mapping
=
Object
.
keys
(
paths
)
.
sort
(
(
a
b
)
=
>
b
.
length
-
a
.
length
)
.
map
(
path
=
>
[
path
paths
[
path
]
]
)
;
const
PATTERN
=
/
(
[
.
\
\
?
+
*
(
)
{
}
[
\
]
^
]
)
/
g
;
const
escapeMeta
=
str
=
>
str
.
replace
(
PATTERN
'
\
\
1
'
)
let
patterns
=
[
]
;
paths
=
{
}
;
for
(
let
[
path
uri
]
of
mapping
)
{
if
(
path
.
endsWith
(
"
/
"
)
)
{
path
=
path
.
slice
(
0
-
1
)
;
uri
=
uri
.
replace
(
/
\
/
+
/
"
"
)
;
}
paths
[
path
]
=
uri
;
if
(
path
=
=
"
"
)
patterns
.
push
(
"
"
)
;
else
patterns
.
push
(
{
escapeMeta
(
path
)
}
(
?
=
|
/
)
)
;
}
let
pattern
=
new
RegExp
(
^
(
{
patterns
.
join
(
'
|
'
)
}
)
)
;
return
id
=
>
{
return
id
.
replace
(
pattern
(
m0
m1
)
=
>
paths
[
m1
]
)
;
}
;
}
function
resolveURI
(
id
mapping
)
{
if
(
isAbsoluteURI
(
id
)
)
return
normalizeExt
(
id
)
;
return
normalizeExt
(
mapping
(
id
)
)
}
function
lazyRequire
(
obj
moduleId
.
.
.
args
)
{
let
module
;
let
getModule
=
(
)
=
>
{
if
(
!
module
)
module
=
this
.
require
(
moduleId
)
;
return
module
;
}
;
for
(
let
props
of
args
)
{
if
(
typeof
props
!
=
=
"
object
"
)
props
=
{
[
props
]
:
props
}
;
for
(
let
[
fromName
toName
]
of
Object
.
entries
(
props
)
)
defineLazyGetter
(
obj
toName
(
)
=
>
getModule
(
)
[
fromName
]
)
;
}
}
function
lazyRequireModule
(
obj
moduleId
prop
=
moduleId
)
{
defineLazyGetter
(
obj
prop
(
)
=
>
this
.
require
(
moduleId
)
)
;
}
function
Require
(
loader
requirer
)
{
let
{
modules
mapping
mappingCache
manifest
rootURI
isNative
requireHook
}
=
loader
;
function
require
(
id
)
{
if
(
!
id
)
throw
Error
(
'
You
must
provide
a
module
name
when
calling
require
(
)
from
'
+
requirer
.
id
requirer
.
uri
)
;
if
(
requireHook
)
{
return
requireHook
(
id
_require
)
;
}
return
_require
(
id
)
;
}
function
_require
(
id
)
{
let
{
uri
requirement
}
=
getRequirements
(
id
)
;
let
module
=
null
;
if
(
uri
in
modules
)
{
module
=
modules
[
uri
]
;
}
else
if
(
isJSMURI
(
uri
)
)
{
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
module
.
exports
=
Cu
.
import
(
uri
{
}
)
;
}
else
if
(
isJSONURI
(
uri
)
)
{
let
data
;
try
{
data
=
JSON
.
parse
(
readURI
(
uri
)
)
;
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
module
.
exports
=
data
;
}
catch
(
err
)
{
if
(
err
&
&
/
JSON
\
.
parse
/
.
test
(
err
.
message
)
)
throw
err
;
uri
=
uri
+
'
.
js
'
;
}
}
if
(
!
(
uri
in
modules
)
)
{
module
=
modules
[
uri
]
=
Module
(
requirement
uri
)
;
try
{
Object
.
freeze
(
load
(
loader
module
)
)
;
}
catch
(
e
)
{
delete
modules
[
uri
]
;
delete
loader
.
sandboxes
[
uri
]
;
throw
e
;
}
}
return
module
.
exports
;
}
function
getRequirements
(
id
)
{
if
(
!
id
)
throw
Error
(
'
you
must
provide
a
module
name
when
calling
require
(
)
from
'
+
requirer
.
id
requirer
.
uri
)
;
let
requirement
uri
;
if
(
modules
[
id
]
)
{
uri
=
requirement
=
id
;
}
else
if
(
requirer
)
{
requirement
=
resolve
(
id
requirer
.
id
)
;
}
else
{
requirement
=
id
;
}
if
(
!
uri
)
{
if
(
mappingCache
.
has
(
requirement
)
)
{
uri
=
mappingCache
.
get
(
requirement
)
;
}
else
{
uri
=
resolveURI
(
requirement
mapping
)
;
mappingCache
.
set
(
requirement
uri
)
;
}
}
if
(
!
uri
)
{
throw
Error
(
'
Module
:
Can
not
resolve
"
'
+
id
+
'
"
module
required
by
'
+
requirer
.
id
+
'
located
at
'
+
requirer
.
uri
requirer
.
uri
)
;
}
return
{
uri
:
uri
requirement
:
requirement
}
;
}
require
.
resolve
=
_require
.
resolve
=
function
resolve
(
id
)
{
let
{
uri
}
=
getRequirements
(
id
)
;
return
uri
;
}
require
.
context
=
prefix
=
>
{
return
id
=
>
{
return
require
(
prefix
+
id
)
;
}
;
}
;
return
require
;
}
function
Module
(
id
uri
)
{
return
Object
.
create
(
null
{
id
:
{
enumerable
:
true
value
:
id
}
exports
:
{
enumerable
:
true
writable
:
true
value
:
Object
.
create
(
null
)
configurable
:
true
}
uri
:
{
value
:
uri
}
}
)
;
}
function
unload
(
loader
reason
)
{
let
subject
=
{
wrappedJSObject
:
loader
.
destructor
}
;
notifyObservers
(
subject
'
sdk
:
loader
:
destroy
'
reason
)
;
}
;
function
Loader
(
options
)
{
function
normalizeRootURI
(
uri
)
{
return
addTrailingSlash
(
join
(
uri
)
)
;
}
let
{
paths
sharedGlobal
globals
}
=
options
;
if
(
!
globals
)
{
globals
=
{
}
;
}
let
destructor
=
Object
.
create
(
null
)
;
let
mapping
=
compileMapping
(
paths
)
;
let
modules
=
{
'
loader
/
unload
'
:
destructor
'
loader
/
options
'
:
options
'
chrome
'
:
{
Cc
:
Cc
Ci
:
Ci
Cu
:
Cu
Cr
:
Cr
Cm
:
Cm
CC
:
bind
(
CC
Components
)
components
:
Components
ChromeWorker
:
ChromeWorker
}
}
;
const
builtinModuleExports
=
modules
;
modules
=
{
}
;
for
(
let
id
of
Object
.
keys
(
builtinModuleExports
)
)
{
let
uri
=
resolveURI
(
id
mapping
)
;
let
module
=
Module
(
id
uri
)
;
Object
.
defineProperty
(
module
"
exports
"
{
enumerable
:
true
get
:
function
(
)
{
return
builtinModuleExports
[
id
]
;
}
}
)
;
modules
[
uri
]
=
module
;
}
let
sharedGlobalSandbox
=
Sandbox
(
{
name
:
options
.
sandboxName
|
|
"
Addon
-
SDK
"
wantXrays
:
false
invisibleToDebugger
:
options
.
invisibleToDebugger
|
|
false
metadata
:
{
addonID
:
options
.
noSandboxAddonId
?
undefined
:
options
.
id
URI
:
options
.
sandboxName
|
|
"
Addon
-
SDK
"
}
prototype
:
options
.
sandboxPrototype
|
|
globals
}
)
;
if
(
options
.
sandboxPrototype
)
{
for
(
let
name
of
getOwnIdentifiers
(
globals
)
)
Object
.
defineProperty
(
sharedGlobalSandbox
name
getOwnPropertyDescriptor
(
globals
name
)
)
;
}
let
returnObj
=
{
destructor
:
{
enumerable
:
false
value
:
destructor
}
globals
:
{
enumerable
:
false
value
:
globals
}
mapping
:
{
enumerable
:
false
value
:
mapping
}
mappingCache
:
{
enumerable
:
false
value
:
new
Map
(
)
}
modules
:
{
enumerable
:
false
value
:
modules
}
useSharedGlobalSandbox
:
{
enumerable
:
false
value
:
!
!
sharedGlobal
}
sharedGlobalSandbox
:
{
enumerable
:
false
value
:
sharedGlobalSandbox
}
sandboxes
:
{
enumerable
:
false
value
:
{
}
}
id
:
{
enumerable
:
false
value
:
options
.
id
}
invisibleToDebugger
:
{
enumerable
:
false
value
:
options
.
invisibleToDebugger
|
|
false
}
requireHook
:
{
enumerable
:
false
value
:
options
.
requireHook
}
loadModuleHook
:
{
enumerable
:
false
value
:
options
.
loadModuleHook
}
}
;
return
Object
.
create
(
null
returnObj
)
;
}
;
var
SystemRegExp
=
/
^
resource
:
\
/
\
/
(
gre
|
devtools
|
testing
-
common
)
\
/
/
;
var
isSystemURI
=
uri
=
>
SystemRegExp
.
test
(
uri
)
;
var
isJSONURI
=
uri
=
>
uri
.
endsWith
(
'
.
json
'
)
;
var
isJSMURI
=
uri
=
>
uri
.
endsWith
(
'
.
jsm
'
)
;
var
isJSURI
=
uri
=
>
uri
.
endsWith
(
'
.
js
'
)
;
var
AbsoluteRegExp
=
/
^
(
resource
|
chrome
|
file
|
jar
)
:
/
;
var
isAbsoluteURI
=
uri
=
>
AbsoluteRegExp
.
test
(
uri
)
;
var
isRelative
=
id
=
>
id
.
startsWith
(
"
.
"
)
;
