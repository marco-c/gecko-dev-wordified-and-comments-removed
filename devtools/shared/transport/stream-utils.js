"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
dumpv
}
=
DevToolsUtils
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
IOUtil
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
io
-
util
;
1
"
]
.
getService
(
Ci
.
nsIIOUtil
)
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
ScriptableInputStream
"
(
)
=
>
{
return
Components
.
Constructor
(
"
mozilla
.
org
/
scriptableinputstream
;
1
"
"
nsIScriptableInputStream
"
"
init
"
)
;
}
)
;
const
BUFFER_SIZE
=
0x8000
;
function
copyStream
(
input
output
length
)
{
const
copier
=
new
StreamCopier
(
input
output
length
)
;
return
copier
.
copy
(
)
;
}
class
StreamCopier
{
static
_nextId
=
0
;
constructor
(
input
output
length
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_id
=
StreamCopier
.
_nextId
+
+
;
this
.
input
=
input
;
this
.
baseAsyncOutput
=
output
;
if
(
IOUtil
.
outputStreamIsBuffered
(
output
)
)
{
this
.
output
=
output
;
}
else
{
this
.
output
=
Cc
[
"
mozilla
.
org
/
network
/
buffered
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIBufferedOutputStream
)
;
this
.
output
.
init
(
output
BUFFER_SIZE
)
;
}
this
.
_length
=
length
;
this
.
_amountLeft
=
length
;
let
_resolve
;
let
_reject
;
this
.
_deferred
=
new
Promise
(
(
resolve
reject
)
=
>
{
_resolve
=
resolve
;
_reject
=
reject
;
}
)
;
this
.
_deferred
.
resolve
=
_resolve
;
this
.
_deferred
.
reject
=
_reject
;
this
.
_copy
=
this
.
_copy
.
bind
(
this
)
;
this
.
_flush
=
this
.
_flush
.
bind
(
this
)
;
this
.
_destroy
=
this
.
_destroy
.
bind
(
this
)
;
this
.
then
=
this
.
_deferred
.
then
.
bind
(
this
.
_deferred
)
;
this
.
then
(
this
.
_destroy
this
.
_destroy
)
;
this
.
_streamReadyCallback
=
this
.
_copy
;
}
copy
(
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
try
{
this
.
_copy
(
)
;
}
catch
(
e
)
{
this
.
_deferred
.
reject
(
e
)
;
}
}
)
;
return
this
;
}
_copy
(
)
{
const
bytesAvailable
=
this
.
input
.
available
(
)
;
const
amountToCopy
=
Math
.
min
(
bytesAvailable
this
.
_amountLeft
)
;
this
.
_debug
(
"
Trying
to
copy
:
"
+
amountToCopy
)
;
let
bytesCopied
;
try
{
bytesCopied
=
this
.
output
.
writeFrom
(
this
.
input
amountToCopy
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
_debug
(
"
Base
stream
would
block
will
retry
"
)
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
throw
e
;
}
this
.
_amountLeft
-
=
bytesCopied
;
this
.
_debug
(
"
Copied
:
"
+
bytesCopied
+
"
Left
:
"
+
this
.
_amountLeft
)
;
this
.
_emitProgress
(
)
;
if
(
this
.
_amountLeft
=
=
=
0
)
{
this
.
_debug
(
"
Copy
done
!
"
)
;
this
.
_flush
(
)
;
return
;
}
this
.
_debug
(
"
Waiting
for
input
stream
"
)
;
this
.
input
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
}
_emitProgress
(
)
{
this
.
emit
(
"
progress
"
{
bytesSent
:
this
.
_length
-
this
.
_amountLeft
totalBytes
:
this
.
_length
}
)
;
}
_flush
(
)
{
try
{
this
.
output
.
flush
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
|
|
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
{
this
.
_debug
(
"
Flush
would
block
will
retry
"
)
;
this
.
_streamReadyCallback
=
this
.
_flush
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
throw
e
;
}
this
.
_deferred
.
resolve
(
)
;
}
_destroy
(
)
{
this
.
_destroy
=
null
;
this
.
_copy
=
null
;
this
.
_flush
=
null
;
this
.
input
=
null
;
this
.
output
=
null
;
}
onInputStreamReady
(
)
{
this
.
_streamReadyCallback
(
)
;
}
onOutputStreamReady
(
)
{
this
.
_streamReadyCallback
(
)
;
}
_debug
(
msg
)
{
dumpv
(
"
Copier
:
"
+
this
.
_id
+
"
"
+
msg
)
;
}
}
function
delimitedRead
(
stream
delimiter
count
)
{
dumpv
(
"
Starting
delimited
read
for
"
+
delimiter
+
"
up
to
"
+
count
+
"
bytes
"
)
;
let
scriptableStream
;
if
(
stream
instanceof
Ci
.
nsIScriptableInputStream
)
{
scriptableStream
=
stream
;
}
else
{
scriptableStream
=
new
ScriptableInputStream
(
stream
)
;
}
let
data
=
"
"
;
count
=
Math
.
min
(
count
stream
.
available
(
)
)
;
if
(
count
<
=
0
)
{
return
data
;
}
let
char
;
while
(
char
!
=
=
delimiter
&
&
count
>
0
)
{
char
=
scriptableStream
.
readBytes
(
1
)
;
count
-
-
;
data
+
=
char
;
}
return
data
;
}
async
function
copyAsyncStreamToArrayBuffer
(
asyncInputStream
buffer
)
{
const
reader
=
new
AsyncStreamToArrayBufferCopier
(
asyncInputStream
buffer
)
;
await
reader
.
asyncRead
(
)
;
}
class
AsyncStreamToArrayBufferCopier
{
#
BUFFER_SIZE
=
16
*
1024
;
/
/
A
16k
buffer
#
originalStream
;
#
binaryStream
;
#
outputArray
;
#
pointer
=
0
;
#
count
;
#
tempBuffer
;
#
tempBufferAsArray
;
constructor
(
stream
arrayBuffer
)
{
this
.
#
originalStream
=
stream
;
this
.
#
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
this
.
#
binaryStream
.
setInputStream
(
stream
)
;
this
.
#
outputArray
=
new
Uint8Array
(
arrayBuffer
)
;
this
.
#
count
=
arrayBuffer
.
byteLength
;
this
.
#
tempBuffer
=
new
ArrayBuffer
(
this
.
#
BUFFER_SIZE
)
;
this
.
#
tempBufferAsArray
=
new
Uint8Array
(
this
.
#
tempBuffer
)
;
}
async
asyncRead
(
)
{
do
{
await
this
.
#
waitForStreamAvailability
(
)
;
this
.
#
syncRead
(
)
;
}
while
(
this
.
#
pointer
<
this
.
#
count
)
;
dumpv
(
Successfully
read
{
this
.
#
count
}
bytes
!
)
;
}
/
*
*
*
returns
{
Promise
<
void
>
}
Resolves
when
the
stream
is
available
.
*
/
async
#
waitForStreamAvailability
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
#
originalStream
.
asyncWait
(
(
)
=
>
resolve
(
)
0
0
Services
.
tm
.
currentThread
)
;
}
)
;
}
/
*
*
*
returns
{
void
}
*
/
#
syncRead
(
)
{
const
amountLeft
=
this
.
#
count
-
this
.
#
pointer
;
const
count
=
Math
.
min
(
this
.
#
binaryStream
.
available
(
)
amountLeft
)
;
if
(
count
<
=
0
)
{
return
;
}
dumpv
(
Will
read
synchronously
{
count
}
bytes
out
of
{
amountLeft
}
bytes
left
.
)
;
let
remaining
=
count
;
while
(
remaining
)
{
/
/
TODO
readArrayBuffer
doesn
'
t
know
how
to
write
to
an
offset
in
the
buffer
/
/
see
bug
1962705
.
const
willRead
=
Math
.
min
(
remaining
this
.
#
BUFFER_SIZE
)
;
const
hasRead
=
this
.
#
binaryStream
.
readArrayBuffer
(
willRead
this
.
#
tempBuffer
)
;
if
(
hasRead
<
willRead
)
{
console
.
error
(
[
devtools
perf
front
]
We
were
expecting
{
willRead
}
bytes
but
received
{
hasRead
}
bytes
instead
.
)
;
}
const
toCopyArray
=
this
.
#
tempBufferAsArray
.
subarray
(
0
hasRead
)
;
this
.
#
outputArray
.
set
(
toCopyArray
this
.
#
pointer
)
;
this
.
#
pointer
+
=
hasRead
;
remaining
-
=
hasRead
;
}
dumpv
(
{
count
}
bytes
have
been
successfully
read
.
Total
:
{
this
.
#
pointer
}
/
{
this
.
#
count
}
)
;
}
}
async
function
copyArrayBufferToAsyncStream
(
buffer
asyncOutputStream
)
{
const
writer
=
new
ArrayBufferToAsyncStreamCopier
(
buffer
asyncOutputStream
)
;
await
writer
.
asyncWrite
(
)
;
}
class
ArrayBufferToAsyncStreamCopier
{
#
BUFFER_SIZE
=
16
*
1024
;
/
/
A
16k
buffer
#
originalStream
;
#
binaryStream
;
#
inputArray
;
#
pointer
=
0
;
#
count
;
constructor
(
arrayBuffer
stream
)
{
this
.
#
originalStream
=
stream
;
this
.
#
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryoutputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryOutputStream
)
;
this
.
#
binaryStream
.
setOutputStream
(
stream
)
;
this
.
#
inputArray
=
new
Uint8Array
(
arrayBuffer
)
;
this
.
#
count
=
arrayBuffer
.
byteLength
;
}
async
asyncWrite
(
)
{
do
{
await
this
.
#
waitForStreamAvailability
(
)
;
this
.
#
syncWrite
(
)
;
}
while
(
this
.
#
pointer
<
this
.
#
count
)
;
dumpv
(
Successfully
wrote
{
this
.
#
count
}
bytes
!
)
;
}
/
*
*
*
returns
{
Promise
<
void
>
}
Resolves
when
the
stream
is
available
.
*
/
async
#
waitForStreamAvailability
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
#
originalStream
.
asyncWait
(
(
)
=
>
resolve
(
)
0
0
Services
.
tm
.
currentThread
)
;
}
)
;
}
/
*
*
*
returns
{
void
}
*
/
#
syncWrite
(
)
{
const
amountLeft
=
this
.
#
count
-
this
.
#
pointer
;
if
(
amountLeft
<
=
0
)
{
return
;
}
let
remaining
=
amountLeft
;
while
(
remaining
)
{
const
willWrite
=
Math
.
min
(
remaining
this
.
#
BUFFER_SIZE
)
;
const
subarray
=
this
.
#
inputArray
.
subarray
(
this
.
#
pointer
this
.
#
pointer
+
willWrite
)
;
try
{
/
/
Bug
1962705
:
writeByteArray
does
a
copy
in
/
/
https
:
/
/
searchfox
.
org
/
mozilla
-
central
/
rev
/
3d294b119bf2add880f615a0fc61a5d54bcd6264
/
js
/
xpconnect
/
src
/
XPCConvert
.
cpp
#
1440
/
/
modify
BinaryOutputStream
so
that
it
can
read
directly
from
the
buffer
.
this
.
#
binaryStream
.
writeByteArray
(
subarray
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
dumpv
(
Base
stream
would
block
will
retry
.
{
amountLeft
-
remaining
}
bytes
have
been
successfully
written
.
Total
:
{
this
.
#
pointer
}
/
{
this
.
#
count
}
)
;
return
;
}
throw
e
;
}
this
.
#
pointer
+
=
willWrite
;
remaining
-
=
willWrite
;
}
dumpv
(
{
amountLeft
-
remaining
}
bytes
have
been
successfully
written
.
Total
:
{
this
.
#
pointer
}
/
{
this
.
#
count
}
)
;
}
}
module
.
exports
=
{
copyStream
delimitedRead
copyAsyncStreamToArrayBuffer
copyArrayBufferToAsyncStream
}
;
