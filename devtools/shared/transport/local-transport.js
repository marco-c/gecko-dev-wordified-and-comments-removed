"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
dumpn
}
=
DevToolsUtils
;
const
flags
=
require
(
"
resource
:
/
/
devtools
/
shared
/
flags
.
js
"
)
;
const
StreamUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
transport
/
stream
-
utils
.
js
"
)
;
loader
.
lazyGetter
(
this
"
Pipe
"
(
)
=
>
{
return
Components
.
Constructor
(
"
mozilla
.
org
/
pipe
;
1
"
"
nsIPipe
"
"
init
"
)
;
}
)
;
class
LocalDebuggerTransport
{
constructor
(
other
)
{
this
.
other
=
other
;
this
.
hooks
=
null
;
this
.
_serial
=
this
.
other
?
this
.
other
.
_serial
:
{
count
:
0
}
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
}
isLocalTransport
=
true
;
send
(
packet
)
{
const
serial
=
this
.
_serial
.
count
+
+
;
if
(
flags
.
wantLogging
)
{
if
(
packet
.
from
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
from
"
+
JSON
.
stringify
(
packet
.
from
)
)
;
}
else
if
(
packet
.
to
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
to
"
+
JSON
.
stringify
(
packet
.
to
)
)
;
}
}
this
.
_deepFreeze
(
packet
)
;
const
other
=
this
.
other
;
if
(
other
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
flags
.
wantLogging
)
{
dumpn
(
"
Received
packet
"
+
serial
+
"
:
"
+
JSON
.
stringify
(
packet
null
2
)
)
;
}
if
(
other
.
hooks
)
{
other
.
hooks
.
onPacket
(
packet
)
;
}
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onPacket
"
)
)
;
}
}
startBulkSend
(
sentPacket
)
{
const
{
actor
type
length
}
=
sentPacket
;
const
serial
=
this
.
_serial
.
count
+
+
;
dumpn
(
"
Sent
bulk
packet
"
+
serial
+
"
for
actor
"
+
actor
)
;
if
(
!
this
.
other
)
{
const
error
=
new
Error
(
"
startBulkSend
:
other
side
of
transport
missing
"
)
;
return
Promise
.
reject
(
error
)
;
}
const
pipe
=
new
Pipe
(
true
true
0
0
null
)
;
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
flags
.
wantLogging
)
{
dumpn
(
"
Received
bulk
packet
"
+
serial
+
"
:
"
+
JSON
.
stringify
(
sentPacket
null
2
)
)
;
}
if
(
!
this
.
other
.
hooks
)
{
return
;
}
new
Promise
(
receiverResolve
=
>
{
const
receivedPacket
=
{
actor
type
length
copyTo
:
output
=
>
{
const
copying
=
StreamUtils
.
copyStream
(
pipe
.
inputStream
output
length
)
;
receiverResolve
(
copying
)
;
return
copying
;
}
copyToBuffer
:
outputBuffer
=
>
{
if
(
outputBuffer
.
byteLength
!
=
=
length
)
{
throw
new
Error
(
In
copyToBuffer
the
output
buffer
needs
to
have
the
same
length
as
the
data
to
read
.
{
outputBuffer
.
byteLength
}
!
=
=
{
length
}
)
;
}
const
copying
=
StreamUtils
.
copyAsyncStreamToArrayBuffer
(
pipe
.
inputStream
outputBuffer
)
;
receiverResolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
inputStream
done
:
receiverResolve
}
;
this
.
other
.
hooks
.
onBulkPacket
(
receivedPacket
)
;
}
)
.
then
(
(
)
=
>
pipe
.
inputStream
.
close
(
)
this
.
close
)
;
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onBulkPacket
"
)
)
;
return
new
Promise
(
senderResolve
=
>
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
return
(
new
Promise
(
copyResolve
=
>
{
senderResolve
(
{
copyFrom
:
input
=
>
{
const
copying
=
StreamUtils
.
copyStream
(
input
pipe
.
outputStream
length
)
;
copyResolve
(
copying
)
;
return
copying
;
}
copyFromBuffer
:
inputBuffer
=
>
{
if
(
inputBuffer
.
byteLength
!
=
=
length
)
{
throw
new
Error
(
In
copyFromBuffer
the
input
buffer
needs
to
have
the
same
length
as
the
data
to
write
.
{
inputBuffer
.
byteLength
}
!
=
=
{
length
}
)
;
}
const
copying
=
StreamUtils
.
copyArrayBufferToAsyncStream
(
inputBuffer
pipe
.
outputStream
)
;
copyResolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
outputStream
done
:
copyResolve
}
)
;
}
)
.
then
(
(
)
=
>
pipe
.
outputStream
.
close
(
)
this
.
close
)
)
;
}
)
;
}
)
;
}
close
(
)
{
if
(
this
.
other
)
{
const
other
=
this
.
other
;
this
.
other
=
null
;
other
.
close
(
)
;
}
if
(
this
.
hooks
)
{
try
{
if
(
this
.
hooks
.
onTransportClosed
)
{
this
.
hooks
.
onTransportClosed
(
)
;
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
this
.
hooks
=
null
;
}
}
ready
(
)
{
}
_deepFreeze
(
object
)
{
Object
.
freeze
(
object
)
;
for
(
const
prop
in
object
)
{
if
(
object
.
hasOwnProperty
(
prop
)
&
&
typeof
object
=
=
=
"
object
"
&
&
!
Object
.
isFrozen
(
object
)
)
{
this
.
_deepFreeze
(
object
[
prop
]
)
;
}
}
}
}
exports
.
LocalDebuggerTransport
=
LocalDebuggerTransport
;
