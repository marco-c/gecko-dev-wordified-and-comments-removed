"
use
strict
"
;
var
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
function
run_test
(
)
{
initTestDebuggerServer
(
)
;
add_task
(
async
function
(
)
{
await
test_transport
(
socket_transport
)
;
await
test_transport
(
local_transport
)
;
DebuggerServer
.
destroy
(
)
;
}
)
;
run_next_test
(
)
;
}
var
test_transport
=
async
function
(
transportFactory
)
{
let
clientResolve
;
const
clientDeferred
=
new
Promise
(
(
resolve
)
=
>
{
clientResolve
=
resolve
;
}
)
;
let
serverResolve
;
const
serverDeferred
=
new
Promise
(
(
resolve
)
=
>
{
serverResolve
=
resolve
;
}
)
;
cleanup_files
(
)
;
const
reallyLong
=
really_long
(
)
;
writeTestTempFile
(
"
bulk
-
input
"
reallyLong
)
;
Assert
.
equal
(
Object
.
keys
(
DebuggerServer
.
_connections
)
.
length
0
)
;
const
transport
=
await
transportFactory
(
)
;
function
write_data
(
{
copyFrom
}
)
{
NetUtil
.
asyncFetch
(
{
uri
:
NetUtil
.
newURI
(
getTestTempFile
(
"
bulk
-
input
"
)
)
loadUsingSystemPrincipal
:
true
}
function
(
input
status
)
{
copyFrom
(
input
)
.
then
(
(
)
=
>
{
input
.
close
(
)
;
}
)
;
}
)
;
}
function
on_bulk_packet
(
{
actor
type
length
copyTo
}
)
{
Assert
.
equal
(
actor
"
root
"
)
;
Assert
.
equal
(
type
"
file
-
stream
"
)
;
Assert
.
equal
(
length
reallyLong
.
length
)
;
const
outputFile
=
getTestTempFile
(
"
bulk
-
output
"
true
)
;
outputFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
666
"
8
)
)
;
const
output
=
FileUtils
.
openSafeFileOutputStream
(
outputFile
)
;
copyTo
(
output
)
.
then
(
(
)
=
>
{
FileUtils
.
closeSafeFileOutputStream
(
output
)
;
return
verify
(
)
;
}
)
.
then
(
(
)
=
>
{
transport
.
hooks
.
onClosed
=
(
)
=
>
{
clientResolve
(
)
;
}
;
transport
.
close
(
)
;
}
)
;
}
function
send_packets
(
)
{
transport
.
send
(
{
actor
:
"
root
"
type
:
"
explode
"
}
)
;
transport
.
startBulkSend
(
{
actor
:
"
root
"
type
:
"
file
-
stream
"
length
:
reallyLong
.
length
}
)
.
then
(
write_data
)
;
}
transport
.
hooks
=
{
onPacket
:
function
(
packet
)
{
if
(
packet
.
error
)
{
transport
.
hooks
.
onError
(
packet
)
;
}
else
if
(
packet
.
applicationType
)
{
transport
.
hooks
.
onServerHello
(
packet
)
;
}
else
{
do_throw
(
"
Unexpected
server
reply
"
)
;
}
}
onServerHello
:
function
(
packet
)
{
Assert
.
equal
(
packet
.
from
"
root
"
)
;
Assert
.
equal
(
packet
.
applicationType
"
xpcshell
-
tests
"
)
;
Assert
.
equal
(
Object
.
keys
(
DebuggerServer
.
_connections
)
.
length
1
)
;
info
(
Object
.
keys
(
DebuggerServer
.
_connections
)
)
;
for
(
const
connId
in
DebuggerServer
.
_connections
)
{
DebuggerServer
.
_connections
[
connId
]
.
onBulkPacket
=
on_bulk_packet
;
}
DebuggerServer
.
on
(
"
connectionchange
"
type
=
>
{
if
(
type
=
=
=
"
closed
"
)
{
serverResolve
(
)
;
}
}
)
;
send_packets
(
)
;
}
onError
:
function
(
packet
)
{
Assert
.
equal
(
packet
.
from
"
root
"
)
;
Assert
.
equal
(
packet
.
error
"
noSuchActor
"
)
;
}
onClosed
:
function
(
)
{
do_throw
(
"
Transport
closed
before
we
expected
"
)
;
}
}
;
transport
.
ready
(
)
;
return
Promise
.
all
(
[
clientDeferred
serverDeferred
]
)
;
}
;
function
verify
(
)
{
const
reallyLong
=
really_long
(
)
;
const
inputFile
=
getTestTempFile
(
"
bulk
-
input
"
)
;
const
outputFile
=
getTestTempFile
(
"
bulk
-
output
"
)
;
Assert
.
equal
(
inputFile
.
fileSize
reallyLong
.
length
)
;
Assert
.
equal
(
outputFile
.
fileSize
reallyLong
.
length
)
;
return
new
Promise
(
(
resolve
)
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
NetUtil
.
newURI
(
getTestTempFile
(
"
bulk
-
output
"
)
)
loadUsingSystemPrincipal
:
true
}
input
=
>
{
const
outputData
=
NetUtil
.
readInputStreamToString
(
input
reallyLong
.
length
)
;
Assert
.
ok
(
outputData
=
=
=
reallyLong
)
;
input
.
close
(
)
;
resolve
(
)
;
}
)
;
}
)
.
then
(
cleanup_files
)
;
}
function
cleanup_files
(
)
{
const
inputFile
=
getTestTempFile
(
"
bulk
-
input
"
true
)
;
if
(
inputFile
.
exists
(
)
)
{
inputFile
.
remove
(
false
)
;
}
const
outputFile
=
getTestTempFile
(
"
bulk
-
output
"
true
)
;
if
(
outputFile
.
exists
(
)
)
{
outputFile
.
remove
(
false
)
;
}
}
