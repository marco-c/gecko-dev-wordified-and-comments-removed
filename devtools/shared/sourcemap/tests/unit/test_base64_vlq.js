function
run_test
(
)
{
for
(
var
k
in
SOURCE_MAP_TEST_MODULE
)
{
if
(
/
^
test
/
.
test
(
k
)
)
{
SOURCE_MAP_TEST_MODULE
[
k
]
(
assert
)
;
}
}
}
var
SOURCE_MAP_TEST_MODULE
=
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
(
function
(
module
exports
__webpack_require__
)
{
var
base64VLQ
=
__webpack_require__
(
1
)
;
exports
[
'
test
normal
encoding
and
decoding
'
]
=
function
(
assert
)
{
var
result
=
{
}
;
for
(
var
i
=
-
255
;
i
<
256
;
i
+
+
)
{
var
str
=
base64VLQ
.
encode
(
i
)
;
base64VLQ
.
decode
(
str
0
result
)
;
assert
.
equal
(
result
.
value
i
)
;
assert
.
equal
(
result
.
rest
str
.
length
)
;
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
base64
=
__webpack_require__
(
2
)
;
var
VLQ_BASE_SHIFT
=
5
;
var
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
var
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
var
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
var
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
var
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
var
encoded
=
"
"
;
var
digit
;
var
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
exports
.
decode
=
function
base64VLQ_decode
(
aStr
aIndex
aOutParam
)
{
var
strLen
=
aStr
.
length
;
var
result
=
0
;
var
shift
=
0
;
var
continuation
digit
;
do
{
if
(
aIndex
>
=
strLen
)
{
throw
new
Error
(
"
Expected
more
digits
in
base
64
VLQ
value
.
"
)
;
}
digit
=
base64
.
decode
(
aStr
.
charCodeAt
(
aIndex
+
+
)
)
;
if
(
digit
=
=
=
-
1
)
{
throw
new
Error
(
"
Invalid
base64
digit
:
"
+
aStr
.
charAt
(
aIndex
-
1
)
)
;
}
continuation
=
!
!
(
digit
&
VLQ_CONTINUATION_BIT
)
;
digit
&
=
VLQ_BASE_MASK
;
result
=
result
+
(
digit
<
<
shift
)
;
shift
+
=
VLQ_BASE_SHIFT
;
}
while
(
continuation
)
;
aOutParam
.
value
=
fromVLQSigned
(
result
)
;
aOutParam
.
rest
=
aIndex
;
}
;
}
)
(
function
(
module
exports
)
{
var
intToCharMap
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
.
split
(
'
'
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
exports
.
decode
=
function
(
charCode
)
{
var
bigA
=
65
;
var
bigZ
=
90
;
var
littleA
=
97
;
var
littleZ
=
122
;
var
zero
=
48
;
var
nine
=
57
;
var
plus
=
43
;
var
slash
=
47
;
var
littleOffset
=
26
;
var
numberOffset
=
52
;
if
(
bigA
<
=
charCode
&
&
charCode
<
=
bigZ
)
{
return
(
charCode
-
bigA
)
;
}
if
(
littleA
<
=
charCode
&
&
charCode
<
=
littleZ
)
{
return
(
charCode
-
littleA
+
littleOffset
)
;
}
if
(
zero
<
=
charCode
&
&
charCode
<
=
nine
)
{
return
(
charCode
-
zero
+
numberOffset
)
;
}
if
(
charCode
=
=
plus
)
{
return
62
;
}
if
(
charCode
=
=
slash
)
{
return
63
;
}
return
-
1
;
}
;
}
)
]
)
;
