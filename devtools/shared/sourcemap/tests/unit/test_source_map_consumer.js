function
run_test
(
)
{
for
(
var
k
in
SOURCE_MAP_TEST_MODULE
)
{
if
(
/
^
test
/
.
test
(
k
)
)
{
SOURCE_MAP_TEST_MODULE
[
k
]
(
assert
)
;
}
}
}
var
SOURCE_MAP_TEST_MODULE
=
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
function
(
module
exports
__webpack_require__
)
{
{
var
util
=
__webpack_require__
(
1
)
;
var
SourceMapConsumer
=
__webpack_require__
(
3
)
.
SourceMapConsumer
;
var
IndexedSourceMapConsumer
=
__webpack_require__
(
3
)
.
IndexedSourceMapConsumer
;
var
BasicSourceMapConsumer
=
__webpack_require__
(
3
)
.
BasicSourceMapConsumer
;
var
SourceMapGenerator
=
__webpack_require__
(
9
)
.
SourceMapGenerator
;
exports
[
'
test
that
we
can
instantiate
with
a
string
or
an
object
'
]
=
function
(
assert
)
{
assert
.
doesNotThrow
(
function
(
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
}
)
;
assert
.
doesNotThrow
(
function
(
)
{
var
map
=
new
SourceMapConsumer
(
JSON
.
stringify
(
util
.
testMap
)
)
;
}
)
;
}
;
exports
[
'
test
that
the
object
returned
from
new
SourceMapConsumer
inherits
from
SourceMapConsumer
'
]
=
function
(
assert
)
{
assert
.
ok
(
new
SourceMapConsumer
(
util
.
testMap
)
instanceof
SourceMapConsumer
)
;
}
exports
[
'
test
that
a
BasicSourceMapConsumer
is
returned
for
sourcemaps
without
sections
'
]
=
function
(
assert
)
{
assert
.
ok
(
new
SourceMapConsumer
(
util
.
testMap
)
instanceof
BasicSourceMapConsumer
)
;
}
;
exports
[
'
test
that
an
IndexedSourceMapConsumer
is
returned
for
sourcemaps
with
sections
'
]
=
function
(
assert
)
{
assert
.
ok
(
new
SourceMapConsumer
(
util
.
indexedTestMap
)
instanceof
IndexedSourceMapConsumer
)
;
}
;
exports
[
'
test
that
the
sources
field
has
the
original
sources
'
]
=
function
(
assert
)
{
var
map
;
var
sources
;
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
sources
=
map
.
sources
;
assert
.
equal
(
sources
[
0
]
'
/
the
/
root
/
one
.
js
'
)
;
assert
.
equal
(
sources
[
1
]
'
/
the
/
root
/
two
.
js
'
)
;
assert
.
equal
(
sources
.
length
2
)
;
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
sources
=
map
.
sources
;
assert
.
equal
(
sources
[
0
]
'
/
the
/
root
/
one
.
js
'
)
;
assert
.
equal
(
sources
[
1
]
'
/
the
/
root
/
two
.
js
'
)
;
assert
.
equal
(
sources
.
length
2
)
;
map
=
new
SourceMapConsumer
(
util
.
indexedTestMapDifferentSourceRoots
)
;
sources
=
map
.
sources
;
assert
.
equal
(
sources
[
0
]
'
/
the
/
root
/
one
.
js
'
)
;
assert
.
equal
(
sources
[
1
]
'
/
different
/
root
/
two
.
js
'
)
;
assert
.
equal
(
sources
.
length
2
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapNoSourceRoot
)
;
sources
=
map
.
sources
;
assert
.
equal
(
sources
[
0
]
'
one
.
js
'
)
;
assert
.
equal
(
sources
[
1
]
'
two
.
js
'
)
;
assert
.
equal
(
sources
.
length
2
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapEmptySourceRoot
)
;
sources
=
map
.
sources
;
assert
.
equal
(
sources
[
0
]
'
one
.
js
'
)
;
assert
.
equal
(
sources
[
1
]
'
two
.
js
'
)
;
assert
.
equal
(
sources
.
length
2
)
;
}
;
exports
[
'
test
that
the
source
root
is
reflected
in
a
mapping
\
'
s
source
field
'
]
=
function
(
assert
)
{
var
map
;
var
mapping
;
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
2
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
/
the
/
root
/
two
.
js
'
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
1
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
/
the
/
root
/
one
.
js
'
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapNoSourceRoot
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
2
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
two
.
js
'
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
1
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
one
.
js
'
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapEmptySourceRoot
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
2
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
two
.
js
'
)
;
mapping
=
map
.
originalPositionFor
(
{
line
:
1
column
:
1
}
)
;
assert
.
equal
(
mapping
.
source
'
one
.
js
'
)
;
}
;
exports
[
'
test
mapping
tokens
back
exactly
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
util
.
assertMapping
(
1
1
'
/
the
/
root
/
one
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
1
5
'
/
the
/
root
/
one
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
1
9
'
/
the
/
root
/
one
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
1
21
'
/
the
/
root
/
one
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
null
map
assert
)
;
util
.
assertMapping
(
1
32
'
/
the
/
root
/
one
.
js
'
2
14
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
2
1
'
/
the
/
root
/
two
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
2
5
'
/
the
/
root
/
two
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
2
18
'
/
the
/
root
/
two
.
js
'
1
21
'
n
'
null
map
assert
)
;
util
.
assertMapping
(
2
21
'
/
the
/
root
/
two
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
2
28
'
/
the
/
root
/
two
.
js
'
2
10
'
n
'
null
map
assert
)
;
}
;
exports
[
'
test
mapping
tokens
back
exactly
in
indexed
source
map
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
util
.
assertMapping
(
1
1
'
/
the
/
root
/
one
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
1
5
'
/
the
/
root
/
one
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
1
9
'
/
the
/
root
/
one
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
1
21
'
/
the
/
root
/
one
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
null
map
assert
)
;
util
.
assertMapping
(
1
32
'
/
the
/
root
/
one
.
js
'
2
14
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
2
1
'
/
the
/
root
/
two
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
2
5
'
/
the
/
root
/
two
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
2
18
'
/
the
/
root
/
two
.
js
'
1
21
'
n
'
null
map
assert
)
;
util
.
assertMapping
(
2
21
'
/
the
/
root
/
two
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
2
28
'
/
the
/
root
/
two
.
js
'
2
10
'
n
'
null
map
assert
)
;
}
;
exports
[
'
test
mapping
tokens
back
exactly
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
util
.
assertMapping
(
1
1
'
/
the
/
root
/
one
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
1
5
'
/
the
/
root
/
one
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
1
9
'
/
the
/
root
/
one
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
1
21
'
/
the
/
root
/
one
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
null
map
assert
)
;
util
.
assertMapping
(
1
32
'
/
the
/
root
/
one
.
js
'
2
14
'
bar
'
null
map
assert
)
;
util
.
assertMapping
(
2
1
'
/
the
/
root
/
two
.
js
'
1
1
null
null
map
assert
)
;
util
.
assertMapping
(
2
5
'
/
the
/
root
/
two
.
js
'
1
5
null
null
map
assert
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
11
null
null
map
assert
)
;
util
.
assertMapping
(
2
18
'
/
the
/
root
/
two
.
js
'
1
21
'
n
'
null
map
assert
)
;
util
.
assertMapping
(
2
21
'
/
the
/
root
/
two
.
js
'
2
3
null
null
map
assert
)
;
util
.
assertMapping
(
2
28
'
/
the
/
root
/
two
.
js
'
2
10
'
n
'
null
map
assert
)
;
}
;
exports
[
'
test
mapping
tokens
fuzzy
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
util
.
assertMapping
(
1
20
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
null
map
assert
true
)
;
util
.
assertMapping
(
1
30
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
null
map
assert
true
)
;
util
.
assertMapping
(
2
12
'
/
the
/
root
/
two
.
js
'
1
11
null
null
map
assert
true
)
;
util
.
assertMapping
(
1
16
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
1
26
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
2
6
'
/
the
/
root
/
two
.
js
'
1
11
null
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
22
'
bar
'
null
map
assert
null
true
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
13
'
baz
'
null
map
assert
null
true
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
16
null
null
map
assert
null
true
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
20
'
bar
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
7
'
baz
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
6
null
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
}
;
exports
[
'
test
mapping
tokens
fuzzy
in
indexed
source
map
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
util
.
assertMapping
(
1
20
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
null
map
assert
true
)
;
util
.
assertMapping
(
1
30
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
null
map
assert
true
)
;
util
.
assertMapping
(
2
12
'
/
the
/
root
/
two
.
js
'
1
11
null
null
map
assert
true
)
;
util
.
assertMapping
(
1
16
'
/
the
/
root
/
one
.
js
'
1
21
'
bar
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
1
26
'
/
the
/
root
/
one
.
js
'
2
10
'
baz
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
2
6
'
/
the
/
root
/
two
.
js
'
1
11
null
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
true
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
22
'
bar
'
null
map
assert
null
true
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
13
'
baz
'
null
map
assert
null
true
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
16
null
null
map
assert
null
true
)
;
util
.
assertMapping
(
1
18
'
/
the
/
root
/
one
.
js
'
1
20
'
bar
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
util
.
assertMapping
(
1
28
'
/
the
/
root
/
one
.
js
'
2
7
'
baz
'
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
util
.
assertMapping
(
2
9
'
/
the
/
root
/
two
.
js
'
1
6
null
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
}
;
exports
[
'
test
mappings
and
end
of
lines
'
]
=
function
(
assert
)
{
var
smg
=
new
SourceMapGenerator
(
{
file
:
'
foo
.
js
'
}
)
;
smg
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
1
}
source
:
'
bar
.
js
'
}
)
;
smg
.
addMapping
(
{
original
:
{
line
:
2
column
:
2
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bar
.
js
'
}
)
;
smg
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
1
}
source
:
'
baz
.
js
'
}
)
;
var
map
=
SourceMapConsumer
.
fromSourceMap
(
smg
)
;
util
.
assertMapping
(
2
1
null
null
null
null
null
map
assert
true
)
util
.
assertMapping
(
1
1
'
bar
.
js
'
2
1
null
null
map
assert
null
true
)
;
util
.
assertMapping
(
null
null
'
bar
.
js
'
3
1
null
SourceMapConsumer
.
LEAST_UPPER_BOUND
map
assert
null
true
)
;
}
;
exports
[
'
test
creating
source
map
consumers
with
)
]
}
\
'
prefix
'
]
=
function
(
assert
)
{
assert
.
doesNotThrow
(
function
(
)
{
var
map
=
new
SourceMapConsumer
(
"
)
]
}
'
"
+
JSON
.
stringify
(
util
.
testMap
)
)
;
}
)
;
}
;
exports
[
'
test
eachMapping
'
]
=
function
(
assert
)
{
var
map
;
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
var
previousLine
=
-
Infinity
;
var
previousColumn
=
-
Infinity
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
generatedLine
>
=
previousLine
)
;
assert
.
ok
(
mapping
.
source
=
=
=
'
/
the
/
root
/
one
.
js
'
|
|
mapping
.
source
=
=
=
'
/
the
/
root
/
two
.
js
'
)
;
if
(
mapping
.
generatedLine
=
=
=
previousLine
)
{
assert
.
ok
(
mapping
.
generatedColumn
>
=
previousColumn
)
;
previousColumn
=
mapping
.
generatedColumn
;
}
else
{
previousLine
=
mapping
.
generatedLine
;
previousColumn
=
-
Infinity
;
}
}
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapNoSourceRoot
)
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
source
=
=
=
'
one
.
js
'
|
|
mapping
.
source
=
=
=
'
two
.
js
'
)
;
}
)
;
map
=
new
SourceMapConsumer
(
util
.
testMapEmptySourceRoot
)
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
source
=
=
=
'
one
.
js
'
|
|
mapping
.
source
=
=
=
'
two
.
js
'
)
;
}
)
;
}
;
exports
[
'
test
eachMapping
for
indexed
source
maps
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
var
previousLine
=
-
Infinity
;
var
previousColumn
=
-
Infinity
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
generatedLine
>
=
previousLine
)
;
if
(
mapping
.
source
)
{
assert
.
equal
(
mapping
.
source
.
indexOf
(
util
.
testMap
.
sourceRoot
)
0
)
;
}
if
(
mapping
.
generatedLine
=
=
=
previousLine
)
{
assert
.
ok
(
mapping
.
generatedColumn
>
=
previousColumn
)
;
previousColumn
=
mapping
.
generatedColumn
;
}
else
{
previousLine
=
mapping
.
generatedLine
;
previousColumn
=
-
Infinity
;
}
}
)
;
}
;
exports
[
'
test
iterating
over
mappings
in
a
different
order
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
var
previousLine
=
-
Infinity
;
var
previousColumn
=
-
Infinity
;
var
previousSource
=
"
"
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
source
>
=
previousSource
)
;
if
(
mapping
.
source
=
=
=
previousSource
)
{
assert
.
ok
(
mapping
.
originalLine
>
=
previousLine
)
;
if
(
mapping
.
originalLine
=
=
=
previousLine
)
{
assert
.
ok
(
mapping
.
originalColumn
>
=
previousColumn
)
;
previousColumn
=
mapping
.
originalColumn
;
}
else
{
previousLine
=
mapping
.
originalLine
;
previousColumn
=
-
Infinity
;
}
}
else
{
previousSource
=
mapping
.
source
;
previousLine
=
-
Infinity
;
previousColumn
=
-
Infinity
;
}
}
null
SourceMapConsumer
.
ORIGINAL_ORDER
)
;
}
;
exports
[
'
test
iterating
over
mappings
in
a
different
order
in
indexed
source
maps
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
var
previousLine
=
-
Infinity
;
var
previousColumn
=
-
Infinity
;
var
previousSource
=
"
"
;
map
.
eachMapping
(
function
(
mapping
)
{
assert
.
ok
(
mapping
.
source
>
=
previousSource
)
;
if
(
mapping
.
source
=
=
=
previousSource
)
{
assert
.
ok
(
mapping
.
originalLine
>
=
previousLine
)
;
if
(
mapping
.
originalLine
=
=
=
previousLine
)
{
assert
.
ok
(
mapping
.
originalColumn
>
=
previousColumn
)
;
previousColumn
=
mapping
.
originalColumn
;
}
else
{
previousLine
=
mapping
.
originalLine
;
previousColumn
=
-
Infinity
;
}
}
else
{
previousSource
=
mapping
.
source
;
previousLine
=
-
Infinity
;
previousColumn
=
-
Infinity
;
}
}
null
SourceMapConsumer
.
ORIGINAL_ORDER
)
;
}
;
exports
[
'
test
that
we
can
set
the
context
for
this
in
eachMapping
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMap
)
;
var
context
=
{
}
;
map
.
eachMapping
(
function
(
)
{
assert
.
equal
(
this
context
)
;
}
context
)
;
}
;
exports
[
'
test
that
we
can
set
the
context
for
this
in
eachMapping
in
indexed
source
maps
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
var
context
=
{
}
;
map
.
eachMapping
(
function
(
)
{
assert
.
equal
(
this
context
)
;
}
context
)
;
}
;
exports
[
'
test
that
the
sourcesContent
field
has
the
original
sources
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMapWithSourcesContent
)
;
var
sourcesContent
=
map
.
sourcesContent
;
assert
.
equal
(
sourcesContent
[
0
]
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
sourcesContent
[
1
]
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
equal
(
sourcesContent
.
length
2
)
;
}
;
exports
[
'
test
that
we
can
get
the
original
sources
for
the
sources
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMapWithSourcesContent
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
0
]
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
1
]
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
one
.
js
"
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
two
.
js
"
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
/
the
/
root
/
three
.
js
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
three
.
js
"
)
;
}
Error
)
;
}
;
exports
[
'
test
that
we
can
get
the
original
source
content
with
relative
source
paths
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
testMapRelativeSources
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
0
]
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
1
]
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
one
.
js
"
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
two
.
js
"
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
/
the
/
root
/
three
.
js
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
three
.
js
"
)
;
}
Error
)
;
}
;
exports
[
'
test
that
we
can
get
the
original
source
content
for
the
sources
on
an
indexed
source
map
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
util
.
indexedTestMap
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
0
]
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
sources
[
1
]
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
one
.
js
"
)
'
ONE
.
foo
=
function
(
bar
)
{
\
n
return
baz
(
bar
)
;
\
n
}
;
'
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
two
.
js
"
)
'
TWO
.
inc
=
function
(
n
)
{
\
n
return
n
+
1
;
\
n
}
;
'
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
/
the
/
root
/
three
.
js
"
)
;
}
Error
)
;
assert
.
throws
(
function
(
)
{
map
.
sourceContentFor
(
"
three
.
js
"
)
;
}
Error
)
;
}
;
exports
[
'
test
hasContentsOfAllSources
single
source
with
contents
'
]
=
function
(
assert
)
{
var
mapWithContents
=
new
SourceMapGenerator
(
)
;
mapWithContents
.
addMapping
(
{
source
:
'
foo
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
mapWithContents
.
setSourceContent
(
'
foo
.
js
'
'
content
of
foo
.
js
'
)
;
var
consumer
=
new
SourceMapConsumer
(
mapWithContents
.
toJSON
(
)
)
;
assert
.
ok
(
consumer
.
hasContentsOfAllSources
(
)
)
;
}
;
exports
[
'
test
hasContentsOfAllSources
single
source
without
contents
'
]
=
function
(
assert
)
{
var
mapWithoutContents
=
new
SourceMapGenerator
(
)
;
mapWithoutContents
.
addMapping
(
{
source
:
'
foo
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
var
consumer
=
new
SourceMapConsumer
(
mapWithoutContents
.
toJSON
(
)
)
;
assert
.
ok
(
!
consumer
.
hasContentsOfAllSources
(
)
)
;
}
;
exports
[
'
test
hasContentsOfAllSources
two
sources
with
contents
'
]
=
function
(
assert
)
{
var
mapWithBothContents
=
new
SourceMapGenerator
(
)
;
mapWithBothContents
.
addMapping
(
{
source
:
'
foo
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
mapWithBothContents
.
addMapping
(
{
source
:
'
bar
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
mapWithBothContents
.
setSourceContent
(
'
foo
.
js
'
'
content
of
foo
.
js
'
)
;
mapWithBothContents
.
setSourceContent
(
'
bar
.
js
'
'
content
of
bar
.
js
'
)
;
var
consumer
=
new
SourceMapConsumer
(
mapWithBothContents
.
toJSON
(
)
)
;
assert
.
ok
(
consumer
.
hasContentsOfAllSources
(
)
)
;
}
;
exports
[
'
test
hasContentsOfAllSources
two
sources
one
with
and
one
without
contents
'
]
=
function
(
assert
)
{
var
mapWithoutSomeContents
=
new
SourceMapGenerator
(
)
;
mapWithoutSomeContents
.
addMapping
(
{
source
:
'
foo
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
mapWithoutSomeContents
.
addMapping
(
{
source
:
'
bar
.
js
'
original
:
{
line
:
1
column
:
10
}
generated
:
{
line
:
1
column
:
10
}
}
)
;
mapWithoutSomeContents
.
setSourceContent
(
'
foo
.
js
'
'
content
of
foo
.
js
'
)
;
var
consumer
=
new
SourceMapConsumer
(
mapWithoutSomeContents
.
toJSON
(
)
)
;
assert
.
ok
(
!
consumer
.
hasContentsOfAllSources
(
)
)
;
}
;
exports
[
'
test
sourceRoot
+
generatedPositionFor
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
foo
/
bar
'
file
:
'
baz
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bang
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
5
column
:
5
}
generated
:
{
line
:
6
column
:
6
}
source
:
'
bang
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
pos
=
map
.
generatedPositionFor
(
{
line
:
1
column
:
1
source
:
'
bang
.
coffee
'
}
)
;
assert
.
equal
(
pos
.
line
2
)
;
assert
.
equal
(
pos
.
column
2
)
;
var
pos
=
map
.
generatedPositionFor
(
{
line
:
1
column
:
1
source
:
'
foo
/
bar
/
bang
.
coffee
'
}
)
;
assert
.
equal
(
pos
.
line
2
)
;
assert
.
equal
(
pos
.
column
2
)
;
}
;
exports
[
'
test
sourceRoot
+
generatedPositionFor
for
path
above
the
root
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
foo
/
bar
'
file
:
'
baz
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
.
.
/
bang
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
pos
=
map
.
generatedPositionFor
(
{
line
:
1
column
:
1
source
:
'
foo
/
bang
.
coffee
'
}
)
;
assert
.
equal
(
pos
.
line
2
)
;
assert
.
equal
(
pos
.
column
2
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
line
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bar
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
1
}
generated
:
{
line
:
3
column
:
2
}
source
:
'
bar
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
2
}
generated
:
{
line
:
3
column
:
3
}
source
:
'
bar
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
3
column
:
1
}
generated
:
{
line
:
4
column
:
2
}
source
:
'
bar
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
2
source
:
'
bar
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
2
)
;
assert
.
equal
(
mappings
[
0
]
.
line
3
)
;
assert
.
equal
(
mappings
[
0
]
.
column
2
)
;
assert
.
equal
(
mappings
[
1
]
.
line
3
)
;
assert
.
equal
(
mappings
[
1
]
.
column
3
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
line
fuzzy
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bar
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
3
column
:
1
}
generated
:
{
line
:
4
column
:
2
}
source
:
'
bar
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
2
source
:
'
bar
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
1
)
;
assert
.
equal
(
mappings
[
0
]
.
line
4
)
;
assert
.
equal
(
mappings
[
0
]
.
column
2
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
empty
source
map
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
2
source
:
'
bar
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
0
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
column
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
3
}
source
:
'
foo
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
1
column
:
1
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
2
)
;
assert
.
equal
(
mappings
[
0
]
.
line
1
)
;
assert
.
equal
(
mappings
[
0
]
.
column
2
)
;
assert
.
equal
(
mappings
[
1
]
.
line
1
)
;
assert
.
equal
(
mappings
[
1
]
.
column
3
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
column
fuzzy
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
3
}
source
:
'
foo
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
1
column
:
0
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
2
)
;
assert
.
equal
(
mappings
[
0
]
.
line
1
)
;
assert
.
equal
(
mappings
[
0
]
.
column
2
)
;
assert
.
equal
(
mappings
[
1
]
.
line
1
)
;
assert
.
equal
(
mappings
[
1
]
.
column
3
)
;
}
;
exports
[
'
test
allGeneratedPositionsFor
for
column
on
different
line
fuzzy
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
1
}
generated
:
{
line
:
2
column
:
3
}
source
:
'
foo
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
1
column
:
0
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
0
)
;
}
;
exports
[
'
test
computeColumnSpans
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
file
:
'
generated
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
1
column
:
1
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
1
}
generated
:
{
line
:
2
column
:
1
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
2
}
generated
:
{
line
:
2
column
:
10
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
2
column
:
3
}
generated
:
{
line
:
2
column
:
20
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
3
column
:
1
}
generated
:
{
line
:
3
column
:
1
}
source
:
'
foo
.
coffee
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
3
column
:
2
}
generated
:
{
line
:
3
column
:
2
}
source
:
'
foo
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
map
.
computeColumnSpans
(
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
1
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
1
)
;
assert
.
equal
(
mappings
[
0
]
.
lastColumn
Infinity
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
2
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
3
)
;
assert
.
equal
(
mappings
[
0
]
.
lastColumn
9
)
;
assert
.
equal
(
mappings
[
1
]
.
lastColumn
19
)
;
assert
.
equal
(
mappings
[
2
]
.
lastColumn
Infinity
)
;
var
mappings
=
map
.
allGeneratedPositionsFor
(
{
line
:
3
source
:
'
foo
.
coffee
'
}
)
;
assert
.
equal
(
mappings
.
length
2
)
;
assert
.
equal
(
mappings
[
0
]
.
lastColumn
1
)
;
assert
.
equal
(
mappings
[
1
]
.
lastColumn
Infinity
)
;
}
;
exports
[
'
test
sourceRoot
+
originalPositionFor
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
foo
/
bar
'
file
:
'
baz
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bang
.
coffee
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
2
column
:
2
}
)
;
assert
.
equal
(
pos
.
source
'
foo
/
bar
/
bang
.
coffee
'
)
;
assert
.
equal
(
pos
.
line
1
)
;
assert
.
equal
(
pos
.
column
1
)
;
}
;
exports
[
'
test
github
issue
#
56
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
http
:
/
/
'
file
:
'
www
.
example
.
com
/
foo
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
www
.
example
.
com
/
original
.
js
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
sources
.
length
1
)
;
assert
.
equal
(
sources
[
0
]
'
http
:
/
/
www
.
example
.
com
/
original
.
js
'
)
;
}
;
exports
[
'
test
github
issue
#
43
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
http
:
/
/
example
.
com
'
file
:
'
foo
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
http
:
/
/
cdn
.
example
.
com
/
original
.
js
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
sources
.
length
1
'
Should
only
be
one
source
.
'
)
;
assert
.
equal
(
sources
[
0
]
'
http
:
/
/
cdn
.
example
.
com
/
original
.
js
'
'
Should
not
be
joined
with
the
sourceRoot
.
'
)
;
}
;
exports
[
'
test
absolute
path
but
same
host
sources
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
http
:
/
/
example
.
com
/
foo
/
bar
'
file
:
'
foo
.
js
'
}
)
;
map
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
/
original
.
js
'
}
)
;
map
=
new
SourceMapConsumer
(
map
.
toString
(
)
)
;
var
sources
=
map
.
sources
;
assert
.
equal
(
sources
.
length
1
'
Should
only
be
one
source
.
'
)
;
assert
.
equal
(
sources
[
0
]
'
http
:
/
/
example
.
com
/
original
.
js
'
'
Source
should
be
relative
the
host
of
the
source
root
.
'
)
;
}
;
exports
[
'
test
indexed
source
map
errors
when
sections
are
out
of
order
by
line
'
]
=
function
(
assert
)
{
var
misorderedIndexedTestMap
=
JSON
.
parse
(
JSON
.
stringify
(
util
.
indexedTestMap
)
)
;
misorderedIndexedTestMap
.
sections
[
0
]
.
offset
=
{
line
:
2
column
:
0
}
;
assert
.
throws
(
function
(
)
{
new
SourceMapConsumer
(
misorderedIndexedTestMap
)
;
}
Error
)
;
}
;
exports
[
'
test
github
issue
#
64
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
{
"
version
"
:
3
"
file
"
:
"
foo
.
js
"
"
sourceRoot
"
:
"
http
:
/
/
example
.
com
/
"
"
sources
"
:
[
"
/
a
"
]
"
names
"
:
[
]
"
mappings
"
:
"
AACA
"
"
sourcesContent
"
:
[
"
foo
"
]
}
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
a
"
)
"
foo
"
)
;
assert
.
equal
(
map
.
sourceContentFor
(
"
/
a
"
)
"
foo
"
)
;
}
;
exports
[
'
test
bug
885597
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
{
"
version
"
:
3
"
file
"
:
"
foo
.
js
"
"
sourceRoot
"
:
"
file
:
/
/
/
Users
/
AlGore
/
Invented
/
The
/
Internet
/
"
"
sources
"
:
[
"
/
a
"
]
"
names
"
:
[
]
"
mappings
"
:
"
AACA
"
"
sourcesContent
"
:
[
"
foo
"
]
}
)
;
var
s
=
map
.
sources
[
0
]
;
assert
.
equal
(
map
.
sourceContentFor
(
s
)
"
foo
"
)
;
}
;
exports
[
'
test
github
issue
#
72
duplicate
sources
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
{
"
version
"
:
3
"
file
"
:
"
foo
.
js
"
"
sources
"
:
[
"
source1
.
js
"
"
source1
.
js
"
"
source3
.
js
"
]
"
names
"
:
[
]
"
mappings
"
:
"
;
EAAC
;
;
IAEE
;
;
MEEE
"
"
sourceRoot
"
:
"
http
:
/
/
example
.
com
"
}
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
2
column
:
2
}
)
;
assert
.
equal
(
pos
.
source
'
http
:
/
/
example
.
com
/
source1
.
js
'
)
;
assert
.
equal
(
pos
.
line
1
)
;
assert
.
equal
(
pos
.
column
1
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
4
column
:
4
}
)
;
assert
.
equal
(
pos
.
source
'
http
:
/
/
example
.
com
/
source1
.
js
'
)
;
assert
.
equal
(
pos
.
line
3
)
;
assert
.
equal
(
pos
.
column
3
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
6
column
:
6
}
)
;
assert
.
equal
(
pos
.
source
'
http
:
/
/
example
.
com
/
source3
.
js
'
)
;
assert
.
equal
(
pos
.
line
5
)
;
assert
.
equal
(
pos
.
column
5
)
;
}
;
exports
[
'
test
github
issue
#
72
duplicate
names
'
]
=
function
(
assert
)
{
var
map
=
new
SourceMapConsumer
(
{
"
version
"
:
3
"
file
"
:
"
foo
.
js
"
"
sources
"
:
[
"
source
.
js
"
]
"
names
"
:
[
"
name1
"
"
name1
"
"
name3
"
]
"
mappings
"
:
"
;
EAACA
;
;
IAEEA
;
;
MAEEE
"
"
sourceRoot
"
:
"
http
:
/
/
example
.
com
"
}
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
2
column
:
2
}
)
;
assert
.
equal
(
pos
.
name
'
name1
'
)
;
assert
.
equal
(
pos
.
line
1
)
;
assert
.
equal
(
pos
.
column
1
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
4
column
:
4
}
)
;
assert
.
equal
(
pos
.
name
'
name1
'
)
;
assert
.
equal
(
pos
.
line
3
)
;
assert
.
equal
(
pos
.
column
3
)
;
var
pos
=
map
.
originalPositionFor
(
{
line
:
6
column
:
6
}
)
;
assert
.
equal
(
pos
.
name
'
name3
'
)
;
assert
.
equal
(
pos
.
line
5
)
;
assert
.
equal
(
pos
.
column
5
)
;
}
;
exports
[
'
test
SourceMapConsumer
.
fromSourceMap
'
]
=
function
(
assert
)
{
var
smg
=
new
SourceMapGenerator
(
{
sourceRoot
:
'
http
:
/
/
example
.
com
/
'
file
:
'
foo
.
js
'
}
)
;
smg
.
addMapping
(
{
original
:
{
line
:
1
column
:
1
}
generated
:
{
line
:
2
column
:
2
}
source
:
'
bar
.
js
'
}
)
;
smg
.
addMapping
(
{
original
:
{
line
:
2
column
:
2
}
generated
:
{
line
:
4
column
:
4
}
source
:
'
baz
.
js
'
name
:
'
dirtMcGirt
'
}
)
;
smg
.
setSourceContent
(
'
baz
.
js
'
'
baz
.
js
content
'
)
;
var
smc
=
SourceMapConsumer
.
fromSourceMap
(
smg
)
;
assert
.
equal
(
smc
.
file
'
foo
.
js
'
)
;
assert
.
equal
(
smc
.
sourceRoot
'
http
:
/
/
example
.
com
/
'
)
;
assert
.
equal
(
smc
.
sources
.
length
2
)
;
assert
.
equal
(
smc
.
sources
[
0
]
'
http
:
/
/
example
.
com
/
bar
.
js
'
)
;
assert
.
equal
(
smc
.
sources
[
1
]
'
http
:
/
/
example
.
com
/
baz
.
js
'
)
;
assert
.
equal
(
smc
.
sourceContentFor
(
'
baz
.
js
'
)
'
baz
.
js
content
'
)
;
var
pos
=
smc
.
originalPositionFor
(
{
line
:
2
column
:
2
}
)
;
assert
.
equal
(
pos
.
line
1
)
;
assert
.
equal
(
pos
.
column
1
)
;
assert
.
equal
(
pos
.
source
'
http
:
/
/
example
.
com
/
bar
.
js
'
)
;
assert
.
equal
(
pos
.
name
null
)
;
pos
=
smc
.
generatedPositionFor
(
{
line
:
1
column
:
1
source
:
'
http
:
/
/
example
.
com
/
bar
.
js
'
}
)
;
assert
.
equal
(
pos
.
line
2
)
;
assert
.
equal
(
pos
.
column
2
)
;
pos
=
smc
.
originalPositionFor
(
{
line
:
4
column
:
4
}
)
;
assert
.
equal
(
pos
.
line
2
)
;
assert
.
equal
(
pos
.
column
2
)
;
assert
.
equal
(
pos
.
source
'
http
:
/
/
example
.
com
/
baz
.
js
'
)
;
assert
.
equal
(
pos
.
name
'
dirtMcGirt
'
)
;
pos
=
smc
.
generatedPositionFor
(
{
line
:
2
column
:
2
source
:
'
http
:
/
/
example
.
com
/
baz
.
js
'
}
)
;
assert
.
equal
(
pos
.
line
4
)
;
assert
.
equal
(
pos
.
column
4
)
;
}
;
exports
[
'
test
issue
#
191
'
]
=
function
(
assert
)
{
var
generator
=
new
SourceMapGenerator
(
{
file
:
'
a
.
css
'
}
)
;
generator
.
addMapping
(
{
source
:
'
b
.
css
'
original
:
{
line
:
1
column
:
0
}
generated
:
{
line
:
1
column
:
0
}
}
)
;
var
consumer
=
SourceMapConsumer
.
fromSourceMap
(
generator
)
;
generator
.
toJSON
(
)
;
assert
.
ok
(
true
"
Using
a
SourceMapGenerator
again
after
creating
a
"
+
"
SourceMapConsumer
from
it
should
not
throw
"
)
;
}
;
exports
[
'
test
sources
where
their
prefix
is
the
source
root
:
issue
#
199
'
]
=
function
(
assert
)
{
var
testSourceMap
=
{
"
version
"
:
3
"
sources
"
:
[
"
/
source
/
app
/
app
/
app
.
js
"
]
"
names
"
:
[
"
System
"
]
"
mappings
"
:
"
AAAAA
"
"
file
"
:
"
app
/
app
.
js
"
"
sourcesContent
"
:
[
"
'
use
strict
'
;
"
]
"
sourceRoot
"
:
"
/
source
/
"
}
;
var
consumer
=
new
SourceMapConsumer
(
testSourceMap
)
;
function
consumerHasSource
(
s
)
{
assert
.
ok
(
consumer
.
sourceContentFor
(
s
)
)
;
}
consumer
.
sources
.
forEach
(
consumerHasSource
)
;
testSourceMap
.
sources
.
forEach
(
consumerHasSource
)
;
}
;
exports
[
'
test
sources
where
their
prefix
is
the
source
root
and
the
source
root
is
a
url
:
issue
#
199
'
]
=
function
(
assert
)
{
var
testSourceMap
=
{
"
version
"
:
3
"
sources
"
:
[
"
http
:
/
/
example
.
com
/
source
/
app
/
app
/
app
.
js
"
]
"
names
"
:
[
"
System
"
]
"
mappings
"
:
"
AAAAA
"
"
sourcesContent
"
:
[
"
'
use
strict
'
;
"
]
"
sourceRoot
"
:
"
http
:
/
/
example
.
com
/
source
/
"
}
;
var
consumer
=
new
SourceMapConsumer
(
testSourceMap
)
;
function
consumerHasSource
(
s
)
{
assert
.
ok
(
consumer
.
sourceContentFor
(
s
)
)
;
}
consumer
.
sources
.
forEach
(
consumerHasSource
)
;
testSourceMap
.
sources
.
forEach
(
consumerHasSource
)
;
}
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
util
=
__webpack_require__
(
2
)
;
exports
.
testGeneratedCode
=
"
ONE
.
foo
=
function
(
a
)
{
return
baz
(
a
)
;
}
;
\
n
"
+
"
TWO
.
inc
=
function
(
a
)
{
return
a
+
1
;
}
;
"
;
exports
.
testMap
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
'
bar
'
'
baz
'
'
n
'
]
sources
:
[
'
one
.
js
'
'
two
.
js
'
]
sourceRoot
:
'
/
the
/
root
'
mappings
:
'
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
;
CCDb
IAAI
IAAM
SAAUE
GAClB
OAAOA
'
}
;
exports
.
testMapNoSourceRoot
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
'
bar
'
'
baz
'
'
n
'
]
sources
:
[
'
one
.
js
'
'
two
.
js
'
]
mappings
:
'
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
;
CCDb
IAAI
IAAM
SAAUE
GAClB
OAAOA
'
}
;
exports
.
testMapEmptySourceRoot
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
'
bar
'
'
baz
'
'
n
'
]
sources
:
[
'
one
.
js
'
'
two
.
js
'
]
sourceRoot
:
'
'
mappings
:
'
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
;
CCDb
IAAI
IAAM
SAAUE
GAClB
OAAOA
'
}
;
exports
.
indexedTestMap
=
{
version
:
3
file
:
'
min
.
js
'
sections
:
[
{
offset
:
{
line
:
0
column
:
0
}
map
:
{
version
:
3
sources
:
[
"
one
.
js
"
]
sourcesContent
:
[
'
ONE
.
foo
=
function
(
bar
)
{
\
n
'
+
'
return
baz
(
bar
)
;
\
n
'
+
'
}
;
'
]
names
:
[
"
bar
"
"
baz
"
]
mappings
:
"
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
"
file
:
"
min
.
js
"
sourceRoot
:
"
/
the
/
root
"
}
}
{
offset
:
{
line
:
1
column
:
0
}
map
:
{
version
:
3
sources
:
[
"
two
.
js
"
]
sourcesContent
:
[
'
TWO
.
inc
=
function
(
n
)
{
\
n
'
+
'
return
n
+
1
;
\
n
'
+
'
}
;
'
]
names
:
[
"
n
"
]
mappings
:
"
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOA
"
file
:
"
min
.
js
"
sourceRoot
:
"
/
the
/
root
"
}
}
]
}
;
exports
.
indexedTestMapDifferentSourceRoots
=
{
version
:
3
file
:
'
min
.
js
'
sections
:
[
{
offset
:
{
line
:
0
column
:
0
}
map
:
{
version
:
3
sources
:
[
"
one
.
js
"
]
sourcesContent
:
[
'
ONE
.
foo
=
function
(
bar
)
{
\
n
'
+
'
return
baz
(
bar
)
;
\
n
'
+
'
}
;
'
]
names
:
[
"
bar
"
"
baz
"
]
mappings
:
"
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
"
file
:
"
min
.
js
"
sourceRoot
:
"
/
the
/
root
"
}
}
{
offset
:
{
line
:
1
column
:
0
}
map
:
{
version
:
3
sources
:
[
"
two
.
js
"
]
sourcesContent
:
[
'
TWO
.
inc
=
function
(
n
)
{
\
n
'
+
'
return
n
+
1
;
\
n
'
+
'
}
;
'
]
names
:
[
"
n
"
]
mappings
:
"
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOA
"
file
:
"
min
.
js
"
sourceRoot
:
"
/
different
/
root
"
}
}
]
}
;
exports
.
testMapWithSourcesContent
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
'
bar
'
'
baz
'
'
n
'
]
sources
:
[
'
one
.
js
'
'
two
.
js
'
]
sourcesContent
:
[
'
ONE
.
foo
=
function
(
bar
)
{
\
n
'
+
'
return
baz
(
bar
)
;
\
n
'
+
'
}
;
'
'
TWO
.
inc
=
function
(
n
)
{
\
n
'
+
'
return
n
+
1
;
\
n
'
+
'
}
;
'
]
sourceRoot
:
'
/
the
/
root
'
mappings
:
'
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
;
CCDb
IAAI
IAAM
SAAUE
GAClB
OAAOA
'
}
;
exports
.
testMapRelativeSources
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
'
bar
'
'
baz
'
'
n
'
]
sources
:
[
'
.
/
one
.
js
'
'
.
/
two
.
js
'
]
sourcesContent
:
[
'
ONE
.
foo
=
function
(
bar
)
{
\
n
'
+
'
return
baz
(
bar
)
;
\
n
'
+
'
}
;
'
'
TWO
.
inc
=
function
(
n
)
{
\
n
'
+
'
return
n
+
1
;
\
n
'
+
'
}
;
'
]
sourceRoot
:
'
/
the
/
root
'
mappings
:
'
CAAC
IAAI
IAAM
SAAUA
GAClB
OAAOC
IAAID
;
CCDb
IAAI
IAAM
SAAUE
GAClB
OAAOA
'
}
;
exports
.
emptyMap
=
{
version
:
3
file
:
'
min
.
js
'
names
:
[
]
sources
:
[
]
mappings
:
'
'
}
;
function
assertMapping
(
generatedLine
generatedColumn
originalSource
originalLine
originalColumn
name
bias
map
assert
dontTestGenerated
dontTestOriginal
)
{
if
(
!
dontTestOriginal
)
{
var
origMapping
=
map
.
originalPositionFor
(
{
line
:
generatedLine
column
:
generatedColumn
bias
:
bias
}
)
;
assert
.
equal
(
origMapping
.
name
name
'
Incorrect
name
expected
'
+
JSON
.
stringify
(
name
)
+
'
got
'
+
JSON
.
stringify
(
origMapping
.
name
)
)
;
assert
.
equal
(
origMapping
.
line
originalLine
'
Incorrect
line
expected
'
+
JSON
.
stringify
(
originalLine
)
+
'
got
'
+
JSON
.
stringify
(
origMapping
.
line
)
)
;
assert
.
equal
(
origMapping
.
column
originalColumn
'
Incorrect
column
expected
'
+
JSON
.
stringify
(
originalColumn
)
+
'
got
'
+
JSON
.
stringify
(
origMapping
.
column
)
)
;
var
expectedSource
;
if
(
originalSource
&
&
map
.
sourceRoot
&
&
originalSource
.
indexOf
(
map
.
sourceRoot
)
=
=
=
0
)
{
expectedSource
=
originalSource
;
}
else
if
(
originalSource
)
{
expectedSource
=
map
.
sourceRoot
?
util
.
join
(
map
.
sourceRoot
originalSource
)
:
originalSource
;
}
else
{
expectedSource
=
null
;
}
assert
.
equal
(
origMapping
.
source
expectedSource
'
Incorrect
source
expected
'
+
JSON
.
stringify
(
expectedSource
)
+
'
got
'
+
JSON
.
stringify
(
origMapping
.
source
)
)
;
}
if
(
!
dontTestGenerated
)
{
var
genMapping
=
map
.
generatedPositionFor
(
{
source
:
originalSource
line
:
originalLine
column
:
originalColumn
bias
:
bias
}
)
;
assert
.
equal
(
genMapping
.
line
generatedLine
'
Incorrect
line
expected
'
+
JSON
.
stringify
(
generatedLine
)
+
'
got
'
+
JSON
.
stringify
(
genMapping
.
line
)
)
;
assert
.
equal
(
genMapping
.
column
generatedColumn
'
Incorrect
column
expected
'
+
JSON
.
stringify
(
generatedColumn
)
+
'
got
'
+
JSON
.
stringify
(
genMapping
.
column
)
)
;
}
}
exports
.
assertMapping
=
assertMapping
;
function
assertEqualMaps
(
assert
actualMap
expectedMap
)
{
assert
.
equal
(
actualMap
.
version
expectedMap
.
version
"
version
mismatch
"
)
;
assert
.
equal
(
actualMap
.
file
expectedMap
.
file
"
file
mismatch
"
)
;
assert
.
equal
(
actualMap
.
names
.
length
expectedMap
.
names
.
length
"
names
length
mismatch
:
"
+
actualMap
.
names
.
join
(
"
"
)
+
"
!
=
"
+
expectedMap
.
names
.
join
(
"
"
)
)
;
for
(
var
i
=
0
;
i
<
actualMap
.
names
.
length
;
i
+
+
)
{
assert
.
equal
(
actualMap
.
names
[
i
]
expectedMap
.
names
[
i
]
"
names
[
"
+
i
+
"
]
mismatch
:
"
+
actualMap
.
names
.
join
(
"
"
)
+
"
!
=
"
+
expectedMap
.
names
.
join
(
"
"
)
)
;
}
assert
.
equal
(
actualMap
.
sources
.
length
expectedMap
.
sources
.
length
"
sources
length
mismatch
:
"
+
actualMap
.
sources
.
join
(
"
"
)
+
"
!
=
"
+
expectedMap
.
sources
.
join
(
"
"
)
)
;
for
(
var
i
=
0
;
i
<
actualMap
.
sources
.
length
;
i
+
+
)
{
assert
.
equal
(
actualMap
.
sources
[
i
]
expectedMap
.
sources
[
i
]
"
sources
[
"
+
i
+
"
]
length
mismatch
:
"
+
actualMap
.
sources
.
join
(
"
"
)
+
"
!
=
"
+
expectedMap
.
sources
.
join
(
"
"
)
)
;
}
assert
.
equal
(
actualMap
.
sourceRoot
expectedMap
.
sourceRoot
"
sourceRoot
mismatch
:
"
+
actualMap
.
sourceRoot
+
"
!
=
"
+
expectedMap
.
sourceRoot
)
;
assert
.
equal
(
actualMap
.
mappings
expectedMap
.
mappings
"
mappings
mismatch
:
\
nActual
:
"
+
actualMap
.
mappings
+
"
\
nExpected
:
"
+
expectedMap
.
mappings
)
;
if
(
actualMap
.
sourcesContent
)
{
assert
.
equal
(
actualMap
.
sourcesContent
.
length
expectedMap
.
sourcesContent
.
length
"
sourcesContent
length
mismatch
"
)
;
for
(
var
i
=
0
;
i
<
actualMap
.
sourcesContent
.
length
;
i
+
+
)
{
assert
.
equal
(
actualMap
.
sourcesContent
[
i
]
expectedMap
.
sourcesContent
[
i
]
"
sourcesContent
[
"
+
i
+
"
]
mismatch
"
)
;
}
}
}
exports
.
assertEqualMaps
=
assertEqualMaps
;
}
}
function
(
module
exports
)
{
{
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
else
{
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
}
exports
.
getArg
=
getArg
;
var
urlRegexp
=
/
^
(
?
:
(
[
\
w
+
\
-
.
]
+
)
:
)
?
\
/
\
/
(
?
:
(
\
w
+
:
\
w
+
)
)
?
(
[
\
w
.
]
*
)
(
?
:
:
(
\
d
+
)
)
?
(
\
S
*
)
/
;
var
dataUrlRegexp
=
/
^
data
:
.
+
\
.
+
/
;
function
urlParse
(
aUrl
)
{
var
match
=
aUrl
.
match
(
urlRegexp
)
;
if
(
!
match
)
{
return
null
;
}
return
{
scheme
:
match
[
1
]
auth
:
match
[
2
]
host
:
match
[
3
]
port
:
match
[
4
]
path
:
match
[
5
]
}
;
}
exports
.
urlParse
=
urlParse
;
function
urlGenerate
(
aParsedUrl
)
{
var
url
=
'
'
;
if
(
aParsedUrl
.
scheme
)
{
url
+
=
aParsedUrl
.
scheme
+
'
:
'
;
}
url
+
=
'
/
/
'
;
if
(
aParsedUrl
.
auth
)
{
url
+
=
aParsedUrl
.
auth
+
'
'
;
}
if
(
aParsedUrl
.
host
)
{
url
+
=
aParsedUrl
.
host
;
}
if
(
aParsedUrl
.
port
)
{
url
+
=
"
:
"
+
aParsedUrl
.
port
}
if
(
aParsedUrl
.
path
)
{
url
+
=
aParsedUrl
.
path
;
}
return
url
;
}
exports
.
urlGenerate
=
urlGenerate
;
function
normalize
(
aPath
)
{
var
path
=
aPath
;
var
url
=
urlParse
(
aPath
)
;
if
(
url
)
{
if
(
!
url
.
path
)
{
return
aPath
;
}
path
=
url
.
path
;
}
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
;
var
parts
=
path
.
split
(
/
\
/
+
/
)
;
for
(
var
part
up
=
0
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
part
=
=
=
'
.
.
'
)
{
up
+
+
;
}
else
if
(
up
>
0
)
{
if
(
part
=
=
=
'
'
)
{
parts
.
splice
(
i
+
1
up
)
;
up
=
0
;
}
else
{
parts
.
splice
(
i
2
)
;
up
-
-
;
}
}
}
path
=
parts
.
join
(
'
/
'
)
;
if
(
path
=
=
=
'
'
)
{
path
=
isAbsolute
?
'
/
'
:
'
.
'
;
}
if
(
url
)
{
url
.
path
=
path
;
return
urlGenerate
(
url
)
;
}
return
path
;
}
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
if
(
aPath
=
=
=
"
"
)
{
aPath
=
"
.
"
;
}
var
aPathUrl
=
urlParse
(
aPath
)
;
var
aRootUrl
=
urlParse
(
aRoot
)
;
if
(
aRootUrl
)
{
aRoot
=
aRootUrl
.
path
|
|
'
/
'
;
}
if
(
aPathUrl
&
&
!
aPathUrl
.
scheme
)
{
if
(
aRootUrl
)
{
aPathUrl
.
scheme
=
aRootUrl
.
scheme
;
}
return
urlGenerate
(
aPathUrl
)
;
}
if
(
aPathUrl
|
|
aPath
.
match
(
dataUrlRegexp
)
)
{
return
aPath
;
}
if
(
aRootUrl
&
&
!
aRootUrl
.
host
&
&
!
aRootUrl
.
path
)
{
aRootUrl
.
host
=
aPath
;
return
urlGenerate
(
aRootUrl
)
;
}
var
joined
=
aPath
.
charAt
(
0
)
=
=
=
'
/
'
?
aPath
:
normalize
(
aRoot
.
replace
(
/
\
/
+
/
'
'
)
+
'
/
'
+
aPath
)
;
if
(
aRootUrl
)
{
aRootUrl
.
path
=
joined
;
return
urlGenerate
(
aRootUrl
)
;
}
return
joined
;
}
exports
.
join
=
join
;
exports
.
isAbsolute
=
function
(
aPath
)
{
return
aPath
.
charAt
(
0
)
=
=
=
'
/
'
|
|
!
!
aPath
.
match
(
urlRegexp
)
;
}
;
function
relative
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
aRoot
=
aRoot
.
replace
(
/
\
/
/
'
'
)
;
var
level
=
0
;
while
(
aPath
.
indexOf
(
aRoot
+
'
/
'
)
!
=
=
0
)
{
var
index
=
aRoot
.
lastIndexOf
(
"
/
"
)
;
if
(
index
<
0
)
{
return
aPath
;
}
aRoot
=
aRoot
.
slice
(
0
index
)
;
if
(
aRoot
.
match
(
/
^
(
[
^
\
/
]
+
:
\
/
)
?
\
/
*
/
)
)
{
return
aPath
;
}
+
+
level
;
}
return
Array
(
level
+
1
)
.
join
(
"
.
.
/
"
)
+
aPath
.
substr
(
aRoot
.
length
+
1
)
;
}
exports
.
relative
=
relative
;
function
toSetString
(
aStr
)
{
return
'
'
+
aStr
;
}
exports
.
toSetString
=
toSetString
;
function
fromSetString
(
aStr
)
{
return
aStr
.
substr
(
1
)
;
}
exports
.
fromSetString
=
fromSetString
;
function
compareByOriginalPositions
(
mappingA
mappingB
onlyCompareOriginal
)
{
var
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareOriginal
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByOriginalPositions
=
compareByOriginalPositions
;
function
compareByGeneratedPositionsDeflated
(
mappingA
mappingB
onlyCompareGenerated
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareGenerated
)
{
return
cmp
;
}
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByGeneratedPositionsDeflated
=
compareByGeneratedPositionsDeflated
;
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
util
=
__webpack_require__
(
2
)
;
var
binarySearch
=
__webpack_require__
(
4
)
;
var
ArraySet
=
__webpack_require__
(
5
)
.
ArraySet
;
var
base64VLQ
=
__webpack_require__
(
6
)
;
var
quickSort
=
__webpack_require__
(
8
)
.
quickSort
;
function
SourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
return
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
)
:
new
BasicSourceMapConsumer
(
sourceMap
)
;
}
SourceMapConsumer
.
fromSourceMap
=
function
(
aSourceMap
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
)
;
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
prototype
.
__generatedMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_generatedMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__generatedMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__generatedMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
__originalMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_originalMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__originalMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__originalMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
_charIsMappingSeparator
=
function
SourceMapConsumer_charIsMappingSeparator
(
aStr
index
)
{
var
c
=
aStr
.
charAt
(
index
)
;
return
c
=
=
=
"
;
"
|
|
c
=
=
=
"
"
;
}
;
SourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
throw
new
Error
(
"
Subclasses
must
implement
_parseMappings
"
)
;
}
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
SourceMapConsumer
.
prototype
.
eachMapping
=
function
SourceMapConsumer_eachMapping
(
aCallback
aContext
aOrder
)
{
var
context
=
aContext
|
|
null
;
var
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
var
mappings
;
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
mappings
=
this
.
_generatedMappings
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
mappings
=
this
.
_originalMappings
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
var
sourceRoot
=
this
.
sourceRoot
;
mappings
.
map
(
function
(
mapping
)
{
var
source
=
mapping
.
source
=
=
=
null
?
null
:
this
.
_sources
.
at
(
mapping
.
source
)
;
if
(
source
!
=
null
&
&
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
sourceRoot
source
)
;
}
return
{
source
:
source
generatedLine
:
mapping
.
generatedLine
generatedColumn
:
mapping
.
generatedColumn
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
mapping
.
name
=
=
=
null
?
null
:
this
.
_names
.
at
(
mapping
.
name
)
}
;
}
this
)
.
forEach
(
aCallback
context
)
;
}
;
SourceMapConsumer
.
prototype
.
allGeneratedPositionsFor
=
function
SourceMapConsumer_allGeneratedPositionsFor
(
aArgs
)
{
var
line
=
util
.
getArg
(
aArgs
'
line
'
)
;
var
needle
=
{
source
:
util
.
getArg
(
aArgs
'
source
'
)
originalLine
:
line
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
0
)
}
;
if
(
this
.
sourceRoot
!
=
null
)
{
needle
.
source
=
util
.
relative
(
this
.
sourceRoot
needle
.
source
)
;
}
if
(
!
this
.
_sources
.
has
(
needle
.
source
)
)
{
return
[
]
;
}
needle
.
source
=
this
.
_sources
.
indexOf
(
needle
.
source
)
;
var
mappings
=
[
]
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
binarySearch
.
LEAST_UPPER_BOUND
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
aArgs
.
column
=
=
=
undefined
)
{
var
originalLine
=
mapping
.
originalLine
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
originalLine
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
else
{
var
originalColumn
=
mapping
.
originalColumn
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
line
&
&
mapping
.
originalColumn
=
=
originalColumn
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
}
return
mappings
;
}
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
function
BasicSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sources
=
util
.
getArg
(
sourceMap
'
sources
'
)
;
var
names
=
util
.
getArg
(
sourceMap
'
names
'
[
]
)
;
var
sourceRoot
=
util
.
getArg
(
sourceMap
'
sourceRoot
'
null
)
;
var
sourcesContent
=
util
.
getArg
(
sourceMap
'
sourcesContent
'
null
)
;
var
mappings
=
util
.
getArg
(
sourceMap
'
mappings
'
)
;
var
file
=
util
.
getArg
(
sourceMap
'
file
'
null
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
sources
=
sources
.
map
(
util
.
normalize
)
.
map
(
function
(
source
)
{
return
sourceRoot
&
&
util
.
isAbsolute
(
sourceRoot
)
&
&
util
.
isAbsolute
(
source
)
?
util
.
relative
(
sourceRoot
source
)
:
source
;
}
)
;
this
.
_names
=
ArraySet
.
fromArray
(
names
true
)
;
this
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
this
.
sourceRoot
=
sourceRoot
;
this
.
sourcesContent
=
sourcesContent
;
this
.
_mappings
=
mappings
;
this
.
file
=
file
;
}
BasicSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
BasicSourceMapConsumer
.
fromSourceMap
=
function
SourceMapConsumer_fromSourceMap
(
aSourceMap
)
{
var
smc
=
Object
.
create
(
BasicSourceMapConsumer
.
prototype
)
;
var
names
=
smc
.
_names
=
ArraySet
.
fromArray
(
aSourceMap
.
_names
.
toArray
(
)
true
)
;
var
sources
=
smc
.
_sources
=
ArraySet
.
fromArray
(
aSourceMap
.
_sources
.
toArray
(
)
true
)
;
smc
.
sourceRoot
=
aSourceMap
.
_sourceRoot
;
smc
.
sourcesContent
=
aSourceMap
.
_generateSourcesContent
(
smc
.
_sources
.
toArray
(
)
smc
.
sourceRoot
)
;
smc
.
file
=
aSourceMap
.
_file
;
var
generatedMappings
=
aSourceMap
.
_mappings
.
toArray
(
)
.
slice
(
)
;
var
destGeneratedMappings
=
smc
.
__generatedMappings
=
[
]
;
var
destOriginalMappings
=
smc
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
length
=
generatedMappings
.
length
;
i
<
length
;
i
+
+
)
{
var
srcMapping
=
generatedMappings
[
i
]
;
var
destMapping
=
new
Mapping
;
destMapping
.
generatedLine
=
srcMapping
.
generatedLine
;
destMapping
.
generatedColumn
=
srcMapping
.
generatedColumn
;
if
(
srcMapping
.
source
)
{
destMapping
.
source
=
sources
.
indexOf
(
srcMapping
.
source
)
;
destMapping
.
originalLine
=
srcMapping
.
originalLine
;
destMapping
.
originalColumn
=
srcMapping
.
originalColumn
;
if
(
srcMapping
.
name
)
{
destMapping
.
name
=
names
.
indexOf
(
srcMapping
.
name
)
;
}
destOriginalMappings
.
push
(
destMapping
)
;
}
destGeneratedMappings
.
push
(
destMapping
)
;
}
quickSort
(
smc
.
__originalMappings
util
.
compareByOriginalPositions
)
;
return
smc
;
}
;
BasicSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
BasicSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
return
this
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
this
.
sourceRoot
!
=
null
?
util
.
join
(
this
.
sourceRoot
s
)
:
s
;
}
this
)
;
}
}
)
;
function
Mapping
(
)
{
this
.
generatedLine
=
0
;
this
.
generatedColumn
=
0
;
this
.
source
=
null
;
this
.
originalLine
=
null
;
this
.
originalColumn
=
null
;
this
.
name
=
null
;
}
BasicSourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
var
generatedLine
=
1
;
var
previousGeneratedColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousOriginalColumn
=
0
;
var
previousSource
=
0
;
var
previousName
=
0
;
var
length
=
aStr
.
length
;
var
index
=
0
;
var
cachedSegments
=
{
}
;
var
temp
=
{
}
;
var
originalMappings
=
[
]
;
var
generatedMappings
=
[
]
;
var
mapping
str
segment
end
value
;
while
(
index
<
length
)
{
if
(
aStr
.
charAt
(
index
)
=
=
=
'
;
'
)
{
generatedLine
+
+
;
index
+
+
;
previousGeneratedColumn
=
0
;
}
else
if
(
aStr
.
charAt
(
index
)
=
=
=
'
'
)
{
index
+
+
;
}
else
{
mapping
=
new
Mapping
(
)
;
mapping
.
generatedLine
=
generatedLine
;
for
(
end
=
index
;
end
<
length
;
end
+
+
)
{
if
(
this
.
_charIsMappingSeparator
(
aStr
end
)
)
{
break
;
}
}
str
=
aStr
.
slice
(
index
end
)
;
segment
=
cachedSegments
[
str
]
;
if
(
segment
)
{
index
+
=
str
.
length
;
}
else
{
segment
=
[
]
;
while
(
index
<
end
)
{
base64VLQ
.
decode
(
aStr
index
temp
)
;
value
=
temp
.
value
;
index
=
temp
.
rest
;
segment
.
push
(
value
)
;
}
if
(
segment
.
length
=
=
=
2
)
{
throw
new
Error
(
'
Found
a
source
but
no
line
and
column
'
)
;
}
if
(
segment
.
length
=
=
=
3
)
{
throw
new
Error
(
'
Found
a
source
and
line
but
no
column
'
)
;
}
cachedSegments
[
str
]
=
segment
;
}
mapping
.
generatedColumn
=
previousGeneratedColumn
+
segment
[
0
]
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
segment
.
length
>
1
)
{
mapping
.
source
=
previousSource
+
segment
[
1
]
;
previousSource
+
=
segment
[
1
]
;
mapping
.
originalLine
=
previousOriginalLine
+
segment
[
2
]
;
previousOriginalLine
=
mapping
.
originalLine
;
mapping
.
originalLine
+
=
1
;
mapping
.
originalColumn
=
previousOriginalColumn
+
segment
[
3
]
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
segment
.
length
>
4
)
{
mapping
.
name
=
previousName
+
segment
[
4
]
;
previousName
+
=
segment
[
4
]
;
}
}
generatedMappings
.
push
(
mapping
)
;
if
(
typeof
mapping
.
originalLine
=
=
=
'
number
'
)
{
originalMappings
.
push
(
mapping
)
;
}
}
}
quickSort
(
generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
this
.
__generatedMappings
=
generatedMappings
;
quickSort
(
originalMappings
util
.
compareByOriginalPositions
)
;
this
.
__originalMappings
=
originalMappings
;
}
;
BasicSourceMapConsumer
.
prototype
.
_findMapping
=
function
SourceMapConsumer_findMapping
(
aNeedle
aMappings
aLineName
aColumnName
aComparator
aBias
)
{
if
(
aNeedle
[
aLineName
]
<
=
0
)
{
throw
new
TypeError
(
'
Line
must
be
greater
than
or
equal
to
1
got
'
+
aNeedle
[
aLineName
]
)
;
}
if
(
aNeedle
[
aColumnName
]
<
0
)
{
throw
new
TypeError
(
'
Column
must
be
greater
than
or
equal
to
0
got
'
+
aNeedle
[
aColumnName
]
)
;
}
return
binarySearch
.
search
(
aNeedle
aMappings
aComparator
aBias
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
computeColumnSpans
=
function
SourceMapConsumer_computeColumnSpans
(
)
{
for
(
var
index
=
0
;
index
<
this
.
_generatedMappings
.
length
;
+
+
index
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
index
+
1
<
this
.
_generatedMappings
.
length
)
{
var
nextMapping
=
this
.
_generatedMappings
[
index
+
1
]
;
if
(
mapping
.
generatedLine
=
=
=
nextMapping
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextMapping
.
generatedColumn
-
1
;
continue
;
}
}
mapping
.
lastGeneratedColumn
=
Infinity
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
SourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_generatedMappings
"
generatedLine
"
"
generatedColumn
"
util
.
compareByGeneratedPositionsDeflated
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
var
source
=
util
.
getArg
(
mapping
'
source
'
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_sources
.
at
(
source
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
this
.
sourceRoot
source
)
;
}
}
var
name
=
util
.
getArg
(
mapping
'
name
'
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
:
source
line
:
util
.
getArg
(
mapping
'
originalLine
'
null
)
column
:
util
.
getArg
(
mapping
'
originalColumn
'
null
)
name
:
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
;
BasicSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
BasicSourceMapConsumer_hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
SourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
if
(
this
.
sourceRoot
!
=
null
)
{
aSource
=
util
.
relative
(
this
.
sourceRoot
aSource
)
;
}
if
(
this
.
_sources
.
has
(
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
aSource
)
]
;
}
var
url
;
if
(
this
.
sourceRoot
!
=
null
&
&
(
url
=
util
.
urlParse
(
this
.
sourceRoot
)
)
)
{
var
fileUriAbsPath
=
aSource
.
replace
(
/
^
file
:
\
/
\
/
/
"
"
)
;
if
(
url
.
scheme
=
=
"
file
"
&
&
this
.
_sources
.
has
(
fileUriAbsPath
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
fileUriAbsPath
)
]
}
if
(
(
!
url
.
path
|
|
url
.
path
=
=
"
/
"
)
&
&
this
.
_sources
.
has
(
"
/
"
+
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
"
/
"
+
aSource
)
]
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
SourceMapConsumer_generatedPositionFor
(
aArgs
)
{
var
source
=
util
.
getArg
(
aArgs
'
source
'
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
sourceRoot
source
)
;
}
if
(
!
this
.
_sources
.
has
(
source
)
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
needle
=
{
source
:
source
originalLine
:
util
.
getArg
(
aArgs
'
line
'
)
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
return
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
function
IndexedSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sections
=
util
.
getArg
(
sourceMap
'
sections
'
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
var
lastOffset
=
{
line
:
-
1
column
:
0
}
;
this
.
_sections
=
sections
.
map
(
function
(
s
)
{
if
(
s
.
url
)
{
throw
new
Error
(
'
Support
for
url
field
in
sections
not
implemented
.
'
)
;
}
var
offset
=
util
.
getArg
(
s
'
offset
'
)
;
var
offsetLine
=
util
.
getArg
(
offset
'
line
'
)
;
var
offsetColumn
=
util
.
getArg
(
offset
'
column
'
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
'
Section
offsets
must
be
ordered
and
non
-
overlapping
.
'
)
;
}
lastOffset
=
offset
;
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
:
new
SourceMapConsumer
(
util
.
getArg
(
s
'
map
'
)
)
}
}
)
;
}
IndexedSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
IndexedSourceMapConsumer
.
prototype
.
constructor
=
SourceMapConsumer
;
IndexedSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
IndexedSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
var
sources
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
}
)
;
IndexedSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
IndexedSourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
needle
section
)
{
var
cmp
=
needle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
needle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
var
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
IndexedSourceMapConsumer_hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
IndexedSourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
IndexedSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
IndexedSourceMapConsumer_generatedPositionFor
(
aArgs
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
if
(
section
.
consumer
.
sources
.
indexOf
(
util
.
getArg
(
aArgs
'
source
'
)
)
=
=
=
-
1
)
{
continue
;
}
var
generatedPosition
=
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
)
{
var
ret
=
{
line
:
generatedPosition
.
line
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
generatedPosition
.
column
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
generatedPosition
.
line
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
}
;
return
ret
;
}
}
return
{
line
:
null
column
:
null
}
;
}
;
IndexedSourceMapConsumer
.
prototype
.
_parseMappings
=
function
IndexedSourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
this
.
__generatedMappings
=
[
]
;
this
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
sectionMappings
=
section
.
consumer
.
_generatedMappings
;
for
(
var
j
=
0
;
j
<
sectionMappings
.
length
;
j
+
+
)
{
var
mapping
=
sectionMappings
[
i
]
;
var
source
=
section
.
consumer
.
_sources
.
at
(
mapping
.
source
)
;
if
(
section
.
consumer
.
sourceRoot
!
=
=
null
)
{
source
=
util
.
join
(
section
.
consumer
.
sourceRoot
source
)
;
}
this
.
_sources
.
add
(
source
)
;
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
name
=
section
.
consumer
.
_names
.
at
(
mapping
.
name
)
;
this
.
_names
.
add
(
name
)
;
name
=
this
.
_names
.
indexOf
(
name
)
;
var
adjustedMapping
=
{
source
:
source
generatedLine
:
mapping
.
generatedLine
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
generatedColumn
:
mapping
.
column
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
mapping
.
generatedLine
)
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
name
}
;
this
.
__generatedMappings
.
push
(
adjustedMapping
)
;
if
(
typeof
adjustedMapping
.
originalLine
=
=
=
'
number
'
)
{
this
.
__originalMappings
.
push
(
adjustedMapping
)
;
}
}
}
quickSort
(
this
.
__generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
quickSort
(
this
.
__originalMappings
util
.
compareByOriginalPositions
)
;
}
;
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
}
}
function
(
module
exports
)
{
{
exports
.
GREATEST_LOWER_BOUND
=
1
;
exports
.
LEAST_UPPER_BOUND
=
2
;
function
recursiveSearch
(
aLow
aHigh
aNeedle
aHaystack
aCompare
aBias
)
{
var
mid
=
Math
.
floor
(
(
aHigh
-
aLow
)
/
2
)
+
aLow
;
var
cmp
=
aCompare
(
aNeedle
aHaystack
[
mid
]
true
)
;
if
(
cmp
=
=
=
0
)
{
return
mid
;
}
else
if
(
cmp
>
0
)
{
if
(
aHigh
-
mid
>
1
)
{
return
recursiveSearch
(
mid
aHigh
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
aHigh
<
aHaystack
.
length
?
aHigh
:
-
1
;
}
else
{
return
mid
;
}
}
else
{
if
(
mid
-
aLow
>
1
)
{
return
recursiveSearch
(
aLow
mid
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
mid
;
}
else
{
return
aLow
<
0
?
-
1
:
aLow
;
}
}
}
exports
.
search
=
function
search
(
aNeedle
aHaystack
aCompare
aBias
)
{
if
(
aHaystack
.
length
=
=
=
0
)
{
return
-
1
;
}
var
index
=
recursiveSearch
(
-
1
aHaystack
.
length
aNeedle
aHaystack
aCompare
aBias
|
|
exports
.
GREATEST_LOWER_BOUND
)
;
if
(
index
<
0
)
{
return
-
1
;
}
while
(
index
-
1
>
=
0
)
{
if
(
aCompare
(
aHaystack
[
index
]
aHaystack
[
index
-
1
]
true
)
!
=
=
0
)
{
break
;
}
-
-
index
;
}
return
index
;
}
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
util
=
__webpack_require__
(
2
)
;
function
ArraySet
(
)
{
this
.
_array
=
[
]
;
this
.
_set
=
{
}
;
}
ArraySet
.
fromArray
=
function
ArraySet_fromArray
(
aArray
aAllowDuplicates
)
{
var
set
=
new
ArraySet
(
)
;
for
(
var
i
=
0
len
=
aArray
.
length
;
i
<
len
;
i
+
+
)
{
set
.
add
(
aArray
[
i
]
aAllowDuplicates
)
;
}
return
set
;
}
;
ArraySet
.
prototype
.
size
=
function
ArraySet_size
(
)
{
return
Object
.
getOwnPropertyNames
(
this
.
_set
)
.
length
;
}
;
ArraySet
.
prototype
.
add
=
function
ArraySet_add
(
aStr
aAllowDuplicates
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
var
isDuplicate
=
this
.
_set
.
hasOwnProperty
(
sStr
)
;
var
idx
=
this
.
_array
.
length
;
if
(
!
isDuplicate
|
|
aAllowDuplicates
)
{
this
.
_array
.
push
(
aStr
)
;
}
if
(
!
isDuplicate
)
{
this
.
_set
[
sStr
]
=
idx
;
}
}
;
ArraySet
.
prototype
.
has
=
function
ArraySet_has
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
return
this
.
_set
.
hasOwnProperty
(
sStr
)
;
}
;
ArraySet
.
prototype
.
indexOf
=
function
ArraySet_indexOf
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
if
(
this
.
_set
.
hasOwnProperty
(
sStr
)
)
{
return
this
.
_set
[
sStr
]
;
}
throw
new
Error
(
'
"
'
+
aStr
+
'
"
is
not
in
the
set
.
'
)
;
}
;
ArraySet
.
prototype
.
at
=
function
ArraySet_at
(
aIdx
)
{
if
(
aIdx
>
=
0
&
&
aIdx
<
this
.
_array
.
length
)
{
return
this
.
_array
[
aIdx
]
;
}
throw
new
Error
(
'
No
element
indexed
by
'
+
aIdx
)
;
}
;
ArraySet
.
prototype
.
toArray
=
function
ArraySet_toArray
(
)
{
return
this
.
_array
.
slice
(
)
;
}
;
exports
.
ArraySet
=
ArraySet
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
base64
=
__webpack_require__
(
7
)
;
var
VLQ_BASE_SHIFT
=
5
;
var
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
var
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
var
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
var
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
var
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
var
encoded
=
"
"
;
var
digit
;
var
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
exports
.
decode
=
function
base64VLQ_decode
(
aStr
aIndex
aOutParam
)
{
var
strLen
=
aStr
.
length
;
var
result
=
0
;
var
shift
=
0
;
var
continuation
digit
;
do
{
if
(
aIndex
>
=
strLen
)
{
throw
new
Error
(
"
Expected
more
digits
in
base
64
VLQ
value
.
"
)
;
}
digit
=
base64
.
decode
(
aStr
.
charCodeAt
(
aIndex
+
+
)
)
;
if
(
digit
=
=
=
-
1
)
{
throw
new
Error
(
"
Invalid
base64
digit
:
"
+
aStr
.
charAt
(
aIndex
-
1
)
)
;
}
continuation
=
!
!
(
digit
&
VLQ_CONTINUATION_BIT
)
;
digit
&
=
VLQ_BASE_MASK
;
result
=
result
+
(
digit
<
<
shift
)
;
shift
+
=
VLQ_BASE_SHIFT
;
}
while
(
continuation
)
;
aOutParam
.
value
=
fromVLQSigned
(
result
)
;
aOutParam
.
rest
=
aIndex
;
}
;
}
}
function
(
module
exports
)
{
{
var
intToCharMap
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
.
split
(
'
'
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
exports
.
decode
=
function
(
charCode
)
{
var
bigA
=
65
;
var
bigZ
=
90
;
var
littleA
=
97
;
var
littleZ
=
122
;
var
zero
=
48
;
var
nine
=
57
;
var
plus
=
43
;
var
slash
=
47
;
var
littleOffset
=
26
;
var
numberOffset
=
52
;
if
(
bigA
<
=
charCode
&
&
charCode
<
=
bigZ
)
{
return
(
charCode
-
bigA
)
;
}
if
(
littleA
<
=
charCode
&
&
charCode
<
=
littleZ
)
{
return
(
charCode
-
littleA
+
littleOffset
)
;
}
if
(
zero
<
=
charCode
&
&
charCode
<
=
nine
)
{
return
(
charCode
-
zero
+
numberOffset
)
;
}
if
(
charCode
=
=
plus
)
{
return
62
;
}
if
(
charCode
=
=
slash
)
{
return
63
;
}
return
-
1
;
}
;
}
}
function
(
module
exports
)
{
{
function
swap
(
ary
x
y
)
{
var
temp
=
ary
[
x
]
;
ary
[
x
]
=
ary
[
y
]
;
ary
[
y
]
=
temp
;
}
function
randomIntInRange
(
low
high
)
{
return
Math
.
round
(
low
+
(
Math
.
random
(
)
*
(
high
-
low
)
)
)
;
}
function
doQuickSort
(
ary
comparator
p
r
)
{
if
(
p
<
r
)
{
var
pivotIndex
=
randomIntInRange
(
p
r
)
;
var
i
=
p
-
1
;
swap
(
ary
pivotIndex
r
)
;
var
pivot
=
ary
[
r
]
;
for
(
var
j
=
p
;
j
<
r
;
j
+
+
)
{
if
(
comparator
(
ary
[
j
]
pivot
)
<
=
0
)
{
i
+
=
1
;
swap
(
ary
i
j
)
;
}
}
swap
(
ary
i
+
1
j
)
;
var
q
=
i
+
1
;
doQuickSort
(
ary
comparator
p
q
-
1
)
;
doQuickSort
(
ary
comparator
q
+
1
r
)
;
}
}
exports
.
quickSort
=
function
(
ary
comparator
)
{
doQuickSort
(
ary
comparator
0
ary
.
length
-
1
)
;
}
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
base64VLQ
=
__webpack_require__
(
6
)
;
var
util
=
__webpack_require__
(
2
)
;
var
ArraySet
=
__webpack_require__
(
5
)
.
ArraySet
;
var
MappingList
=
__webpack_require__
(
10
)
.
MappingList
;
function
SourceMapGenerator
(
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
{
}
;
}
this
.
_file
=
util
.
getArg
(
aArgs
'
file
'
null
)
;
this
.
_sourceRoot
=
util
.
getArg
(
aArgs
'
sourceRoot
'
null
)
;
this
.
_skipValidation
=
util
.
getArg
(
aArgs
'
skipValidation
'
false
)
;
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
this
.
_mappings
=
new
MappingList
(
)
;
this
.
_sourcesContents
=
null
;
}
SourceMapGenerator
.
prototype
.
_version
=
3
;
SourceMapGenerator
.
fromSourceMap
=
function
SourceMapGenerator_fromSourceMap
(
aSourceMapConsumer
)
{
var
sourceRoot
=
aSourceMapConsumer
.
sourceRoot
;
var
generator
=
new
SourceMapGenerator
(
{
file
:
aSourceMapConsumer
.
file
sourceRoot
:
sourceRoot
}
)
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
var
newMapping
=
{
generated
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
}
;
if
(
mapping
.
source
!
=
null
)
{
newMapping
.
source
=
mapping
.
source
;
if
(
sourceRoot
!
=
null
)
{
newMapping
.
source
=
util
.
relative
(
sourceRoot
newMapping
.
source
)
;
}
newMapping
.
original
=
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
;
if
(
mapping
.
name
!
=
null
)
{
newMapping
.
name
=
mapping
.
name
;
}
}
generator
.
addMapping
(
newMapping
)
;
}
)
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
generator
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
generator
;
}
;
SourceMapGenerator
.
prototype
.
addMapping
=
function
SourceMapGenerator_addMapping
(
aArgs
)
{
var
generated
=
util
.
getArg
(
aArgs
'
generated
'
)
;
var
original
=
util
.
getArg
(
aArgs
'
original
'
null
)
;
var
source
=
util
.
getArg
(
aArgs
'
source
'
null
)
;
var
name
=
util
.
getArg
(
aArgs
'
name
'
null
)
;
if
(
!
this
.
_skipValidation
)
{
this
.
_validateMapping
(
generated
original
source
name
)
;
}
if
(
source
!
=
null
&
&
!
this
.
_sources
.
has
(
source
)
)
{
this
.
_sources
.
add
(
source
)
;
}
if
(
name
!
=
null
&
&
!
this
.
_names
.
has
(
name
)
)
{
this
.
_names
.
add
(
name
)
;
}
this
.
_mappings
.
add
(
{
generatedLine
:
generated
.
line
generatedColumn
:
generated
.
column
originalLine
:
original
!
=
null
&
&
original
.
line
originalColumn
:
original
!
=
null
&
&
original
.
column
source
:
source
name
:
name
}
)
;
}
;
SourceMapGenerator
.
prototype
.
setSourceContent
=
function
SourceMapGenerator_setSourceContent
(
aSourceFile
aSourceContent
)
{
var
source
=
aSourceFile
;
if
(
this
.
_sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
_sourceRoot
source
)
;
}
if
(
aSourceContent
!
=
null
)
{
if
(
!
this
.
_sourcesContents
)
{
this
.
_sourcesContents
=
{
}
;
}
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
=
aSourceContent
;
}
else
if
(
this
.
_sourcesContents
)
{
delete
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
;
if
(
Object
.
keys
(
this
.
_sourcesContents
)
.
length
=
=
=
0
)
{
this
.
_sourcesContents
=
null
;
}
}
}
;
SourceMapGenerator
.
prototype
.
applySourceMap
=
function
SourceMapGenerator_applySourceMap
(
aSourceMapConsumer
aSourceFile
aSourceMapPath
)
{
var
sourceFile
=
aSourceFile
;
if
(
aSourceFile
=
=
null
)
{
if
(
aSourceMapConsumer
.
file
=
=
null
)
{
throw
new
Error
(
'
SourceMapGenerator
.
prototype
.
applySourceMap
requires
either
an
explicit
source
file
'
+
'
or
the
source
map
\
'
s
"
file
"
property
.
Both
were
omitted
.
'
)
;
}
sourceFile
=
aSourceMapConsumer
.
file
;
}
var
sourceRoot
=
this
.
_sourceRoot
;
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
var
newSources
=
new
ArraySet
(
)
;
var
newNames
=
new
ArraySet
(
)
;
this
.
_mappings
.
unsortedForEach
(
function
(
mapping
)
{
if
(
mapping
.
source
=
=
=
sourceFile
&
&
mapping
.
originalLine
!
=
null
)
{
var
original
=
aSourceMapConsumer
.
originalPositionFor
(
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
)
;
if
(
original
.
source
!
=
null
)
{
mapping
.
source
=
original
.
source
;
if
(
aSourceMapPath
!
=
null
)
{
mapping
.
source
=
util
.
join
(
aSourceMapPath
mapping
.
source
)
}
if
(
sourceRoot
!
=
null
)
{
mapping
.
source
=
util
.
relative
(
sourceRoot
mapping
.
source
)
;
}
mapping
.
originalLine
=
original
.
line
;
mapping
.
originalColumn
=
original
.
column
;
if
(
original
.
name
!
=
null
)
{
mapping
.
name
=
original
.
name
;
}
}
}
var
source
=
mapping
.
source
;
if
(
source
!
=
null
&
&
!
newSources
.
has
(
source
)
)
{
newSources
.
add
(
source
)
;
}
var
name
=
mapping
.
name
;
if
(
name
!
=
null
&
&
!
newNames
.
has
(
name
)
)
{
newNames
.
add
(
name
)
;
}
}
this
)
;
this
.
_sources
=
newSources
;
this
.
_names
=
newNames
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aSourceMapPath
!
=
null
)
{
sourceFile
=
util
.
join
(
aSourceMapPath
sourceFile
)
;
}
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
this
.
setSourceContent
(
sourceFile
content
)
;
}
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
_validateMapping
=
function
SourceMapGenerator_validateMapping
(
aGenerated
aOriginal
aSource
aName
)
{
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
!
aOriginal
&
&
!
aSource
&
&
!
aName
)
{
return
;
}
else
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aOriginal
&
&
'
line
'
in
aOriginal
&
&
'
column
'
in
aOriginal
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
aOriginal
.
line
>
0
&
&
aOriginal
.
column
>
=
0
&
&
aSource
)
{
return
;
}
else
{
throw
new
Error
(
'
Invalid
mapping
:
'
+
JSON
.
stringify
(
{
generated
:
aGenerated
source
:
aSource
original
:
aOriginal
name
:
aName
}
)
)
;
}
}
;
SourceMapGenerator
.
prototype
.
_serializeMappings
=
function
SourceMapGenerator_serializeMappings
(
)
{
var
previousGeneratedColumn
=
0
;
var
previousGeneratedLine
=
1
;
var
previousOriginalColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousName
=
0
;
var
previousSource
=
0
;
var
result
=
'
'
;
var
mapping
;
var
nameIdx
;
var
sourceIdx
;
var
mappings
=
this
.
_mappings
.
toArray
(
)
;
for
(
var
i
=
0
len
=
mappings
.
length
;
i
<
len
;
i
+
+
)
{
mapping
=
mappings
[
i
]
;
if
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
previousGeneratedColumn
=
0
;
while
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
result
+
=
'
;
'
;
previousGeneratedLine
+
+
;
}
}
else
{
if
(
i
>
0
)
{
if
(
!
util
.
compareByGeneratedPositionsInflated
(
mapping
mappings
[
i
-
1
]
)
)
{
continue
;
}
result
+
=
'
'
;
}
}
result
+
=
base64VLQ
.
encode
(
mapping
.
generatedColumn
-
previousGeneratedColumn
)
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
mapping
.
source
!
=
null
)
{
sourceIdx
=
this
.
_sources
.
indexOf
(
mapping
.
source
)
;
result
+
=
base64VLQ
.
encode
(
sourceIdx
-
previousSource
)
;
previousSource
=
sourceIdx
;
result
+
=
base64VLQ
.
encode
(
mapping
.
originalLine
-
1
-
previousOriginalLine
)
;
previousOriginalLine
=
mapping
.
originalLine
-
1
;
result
+
=
base64VLQ
.
encode
(
mapping
.
originalColumn
-
previousOriginalColumn
)
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
mapping
.
name
!
=
null
)
{
nameIdx
=
this
.
_names
.
indexOf
(
mapping
.
name
)
;
result
+
=
base64VLQ
.
encode
(
nameIdx
-
previousName
)
;
previousName
=
nameIdx
;
}
}
}
return
result
;
}
;
SourceMapGenerator
.
prototype
.
_generateSourcesContent
=
function
SourceMapGenerator_generateSourcesContent
(
aSources
aSourceRoot
)
{
return
aSources
.
map
(
function
(
source
)
{
if
(
!
this
.
_sourcesContents
)
{
return
null
;
}
if
(
aSourceRoot
!
=
null
)
{
source
=
util
.
relative
(
aSourceRoot
source
)
;
}
var
key
=
util
.
toSetString
(
source
)
;
return
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
_sourcesContents
key
)
?
this
.
_sourcesContents
[
key
]
:
null
;
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
toJSON
=
function
SourceMapGenerator_toJSON
(
)
{
var
map
=
{
version
:
this
.
_version
sources
:
this
.
_sources
.
toArray
(
)
names
:
this
.
_names
.
toArray
(
)
mappings
:
this
.
_serializeMappings
(
)
}
;
if
(
this
.
_file
!
=
null
)
{
map
.
file
=
this
.
_file
;
}
if
(
this
.
_sourceRoot
!
=
null
)
{
map
.
sourceRoot
=
this
.
_sourceRoot
;
}
if
(
this
.
_sourcesContents
)
{
map
.
sourcesContent
=
this
.
_generateSourcesContent
(
map
.
sources
map
.
sourceRoot
)
;
}
return
map
;
}
;
SourceMapGenerator
.
prototype
.
toString
=
function
SourceMapGenerator_toString
(
)
{
return
JSON
.
stringify
(
this
.
toJSON
(
)
)
;
}
;
exports
.
SourceMapGenerator
=
SourceMapGenerator
;
}
}
function
(
module
exports
__webpack_require__
)
{
{
var
util
=
__webpack_require__
(
2
)
;
function
generatedPositionAfter
(
mappingA
mappingB
)
{
var
lineA
=
mappingA
.
generatedLine
;
var
lineB
=
mappingB
.
generatedLine
;
var
columnA
=
mappingA
.
generatedColumn
;
var
columnB
=
mappingB
.
generatedColumn
;
return
lineB
>
lineA
|
|
lineB
=
=
lineA
&
&
columnB
>
=
columnA
|
|
util
.
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
<
=
0
;
}
function
MappingList
(
)
{
this
.
_array
=
[
]
;
this
.
_sorted
=
true
;
this
.
_last
=
{
generatedLine
:
-
1
generatedColumn
:
0
}
;
}
MappingList
.
prototype
.
unsortedForEach
=
function
MappingList_forEach
(
aCallback
aThisArg
)
{
this
.
_array
.
forEach
(
aCallback
aThisArg
)
;
}
;
MappingList
.
prototype
.
add
=
function
MappingList_add
(
aMapping
)
{
if
(
generatedPositionAfter
(
this
.
_last
aMapping
)
)
{
this
.
_last
=
aMapping
;
this
.
_array
.
push
(
aMapping
)
;
}
else
{
this
.
_sorted
=
false
;
this
.
_array
.
push
(
aMapping
)
;
}
}
;
MappingList
.
prototype
.
toArray
=
function
MappingList_toArray
(
)
{
if
(
!
this
.
_sorted
)
{
this
.
_array
.
sort
(
util
.
compareByGeneratedPositionsInflated
)
;
this
.
_sorted
=
true
;
}
return
this
.
_array
;
}
;
exports
.
MappingList
=
MappingList
;
}
}
]
)
;
