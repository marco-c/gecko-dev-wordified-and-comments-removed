"
use
strict
"
;
const
{
startTracing
addTracingListener
stopTracing
removeTracingListener
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
jsm
"
)
;
let
lineToTrace
;
const
fileContents
=
new
Map
(
)
;
function
getFileContent
(
url
)
{
let
content
=
fileContents
.
get
(
url
)
;
if
(
content
)
{
return
content
;
}
content
=
readURI
(
url
)
.
split
(
"
\
n
"
)
;
fileContents
.
set
(
url
content
)
;
return
content
;
}
function
isNestedFrame
(
frame
topFrame
)
{
if
(
frame
.
older
)
{
while
(
(
frame
=
frame
.
older
)
)
{
if
(
frame
=
=
topFrame
)
{
return
true
;
}
}
}
else
if
(
frame
.
olderSavedFrame
)
{
frame
=
frame
.
olderSavedFrame
;
const
{
lineNumber
columnNumber
}
=
topFrame
.
script
.
getOffsetMetadata
(
top
.
offset
)
;
while
(
(
frame
=
frame
.
parent
|
|
frame
.
asyncParent
)
)
{
if
(
frame
.
source
=
=
topFrame
.
script
.
source
.
url
&
&
frame
.
line
=
=
lineNumber
&
&
frame
.
column
=
=
columnNumber
)
{
return
true
;
}
}
}
return
false
;
}
let
initialFrame
=
null
;
let
previousSourceUrl
=
null
;
function
traceFrame
(
{
frame
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
if
(
lineToTrace
)
{
if
(
lineNumber
=
=
lineToTrace
)
{
stopTracing
(
)
;
const
{
url
}
=
script
.
source
;
const
filename
=
url
.
substr
(
url
.
lastIndexOf
(
"
/
"
)
+
1
)
;
const
line
=
getFileContent
(
url
)
[
lineNumber
-
1
]
;
logStep
(
Start
tracing
{
filename
}
{
lineNumber
}
:
:
{
line
}
)
;
previousSourceUrl
=
url
;
const
tracerOptions
=
{
traceAllGlobals
:
true
traceSteps
:
true
}
;
lineToTrace
=
null
;
startTracing
(
tracerOptions
)
;
}
return
false
;
}
if
(
!
initialFrame
)
{
initialFrame
=
frame
;
}
else
if
(
initialFrame
.
terminated
)
{
logStep
(
"
End
of
execution
"
)
;
exports
.
stop
(
)
;
return
false
;
}
else
if
(
!
initialFrame
.
onStack
)
{
return
false
;
}
else
if
(
frame
!
=
initialFrame
&
&
!
isNestedFrame
(
frame
initialFrame
)
)
{
return
false
;
}
const
{
url
}
=
script
.
source
;
if
(
previousSourceUrl
&
&
previousSourceUrl
!
=
=
url
)
{
logStep
(
"
"
)
;
logStep
(
url
)
;
logStep
(
\
x1b
[
2m
+
\
u2500
.
repeat
(
url
.
length
)
+
\
x1b
[
0m
)
;
previousSourceUrl
=
url
;
}
const
line
=
getFileContent
(
url
)
[
lineNumber
-
1
]
;
const
code
=
"
\
x1b
[
2m
"
+
line
.
substr
(
0
columnNumber
-
1
)
+
"
\
x1b
[
0m
"
+
"
\
u21A6
"
+
line
.
substr
(
columnNumber
-
1
)
;
const
position
=
(
lineNumber
+
"
:
"
+
columnNumber
)
.
padEnd
(
7
)
;
logStep
(
{
position
}
\
u007C
{
code
}
)
;
return
false
;
}
function
logStep
(
message
)
{
dump
(
\
x1b
[
2m
[
STEP
]
\
x1b
[
0m
{
message
}
\
n
)
;
}
const
tracingListener
=
{
onTracingFrame
:
traceFrame
onTracingFrameStep
:
traceFrame
}
;
exports
.
start
=
function
(
testGlobal
testUrl
line
)
{
lineToTrace
=
line
;
const
tracerOptions
=
{
global
:
testGlobal
traceSteps
:
true
filterFrameSourceUrl
:
testUrl
}
;
startTracing
(
tracerOptions
)
;
addTracingListener
(
tracingListener
)
;
}
;
exports
.
stop
=
function
(
)
{
stopTracing
(
)
;
removeTracingListener
(
tracingListener
)
;
}
;
function
readURI
(
uri
)
{
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
stream
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
uri
"
UTF
-
8
"
)
loadUsingSystemPrincipal
:
true
}
)
.
open
(
)
;
const
count
=
stream
.
available
(
)
;
const
data
=
NetUtil
.
readInputStreamToString
(
stream
count
{
charset
:
"
UTF
-
8
"
}
)
;
stream
.
close
(
)
;
return
data
;
}
