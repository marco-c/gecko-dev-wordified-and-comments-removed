"
use
strict
"
;
const
{
Cu
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
MemoryReporter
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
const
global
=
Cu
.
getGlobalForObject
(
this
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
)
;
addDebuggerToGlobal
(
global
)
;
exports
.
allocationTracker
=
function
(
{
watchGlobal
watchAllGlobals
watchDevToolsGlobals
}
=
{
}
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Start
logging
allocations
\
n
"
)
;
let
dbg
=
new
global
.
Debugger
(
)
;
dbg
.
memory
.
trackingAllocationSites
=
true
;
dbg
.
memory
.
allocationSamplingProbability
=
1
.
0
;
dbg
.
memory
.
maxAllocationsLogLength
=
5000000
;
let
acceptGlobal
;
if
(
watchGlobal
)
{
acceptGlobal
=
(
)
=
>
false
;
dbg
.
addDebuggee
(
watchGlobal
)
;
}
else
if
(
watchAllGlobals
)
{
acceptGlobal
=
(
)
=
>
true
;
}
else
if
(
watchDevToolsGlobals
)
{
acceptGlobal
=
g
=
>
{
if
(
g
.
class
=
=
"
self
-
hosting
-
global
"
)
{
return
false
;
}
const
ref
=
g
.
unsafeDereference
(
)
;
const
location
=
Cu
.
getRealmLocation
(
ref
)
;
const
accept
=
!
!
location
.
match
(
/
devtools
/
i
)
;
dump
(
"
TRACKER
NEW
GLOBAL
:
"
+
(
accept
?
"
+
"
:
"
-
"
)
+
"
:
"
+
location
+
"
\
n
"
)
;
return
accept
;
}
;
}
if
(
watchAllGlobals
|
|
watchDevToolsGlobals
)
{
dbg
.
addAllGlobalsAsDebuggees
(
)
;
for
(
const
g
of
dbg
.
getDebuggees
(
)
)
{
if
(
!
acceptGlobal
(
g
)
)
{
dbg
.
removeDebuggee
(
g
)
;
}
}
}
dbg
.
removeDebuggee
(
global
)
;
dbg
.
onNewGlobalObject
=
function
(
g
)
{
if
(
acceptGlobal
(
g
)
)
{
dbg
.
addDebuggee
(
g
)
;
}
}
;
return
{
get
overflowed
(
)
{
return
dbg
.
memory
.
allocationsLogOverflowed
;
}
logAllocationSites
(
{
first
=
5
}
=
{
}
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
const
sources
=
{
}
;
for
(
const
alloc
of
allocations
)
{
const
{
frame
}
=
alloc
;
let
src
=
"
UNKNOWN
"
;
let
line
=
-
1
;
try
{
if
(
frame
)
{
src
=
frame
.
source
|
|
"
UNKNOWN
"
;
line
=
frame
.
line
|
|
-
1
;
}
}
catch
(
e
)
{
}
let
item
=
sources
[
src
]
;
if
(
!
item
)
{
item
=
sources
[
src
]
=
{
count
:
0
lines
:
{
}
}
;
}
item
.
count
+
+
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
item
.
lines
[
line
]
=
0
;
}
item
.
lines
[
line
]
+
+
;
}
}
const
allocationList
=
Object
.
entries
(
sources
)
.
sort
(
(
[
srcA
itemA
]
[
srcB
itemB
]
)
=
>
itemA
.
count
<
itemB
.
count
)
.
filter
(
(
_
i
)
=
>
i
<
first
)
.
map
(
(
[
src
item
]
)
=
>
{
const
lines
=
[
]
;
Object
.
entries
(
item
.
lines
)
.
filter
(
(
[
line
count
]
)
=
>
count
>
5
)
.
sort
(
(
[
lineA
countA
]
[
lineB
countB
]
)
=
>
{
if
(
countA
!
=
countB
)
{
return
countA
<
countB
;
}
return
lineA
<
lineB
;
}
)
.
forEach
(
(
[
line
count
]
)
=
>
{
lines
.
push
(
line
+
"
:
"
+
count
)
;
}
)
;
return
{
src
count
:
item
.
count
lines
}
;
}
)
;
dump
(
"
DEVTOOLS
ALLOCATION
:
Javascript
object
allocations
:
"
+
allocations
.
length
+
"
\
n
"
+
JSON
.
stringify
(
allocationList
null
2
)
+
"
\
n
"
)
;
}
logCount
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Javascript
object
allocations
:
"
+
this
.
countAllocations
(
)
+
"
\
n
"
)
;
}
countAllocations
(
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
return
allocations
.
length
;
}
flushAllocations
(
)
{
dbg
.
memory
.
drainAllocationsLog
(
)
;
}
stillAllocatedObjects
(
)
{
const
sensus
=
dbg
.
memory
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
}
}
)
;
let
objectsWithStack
=
0
;
let
objectsWithoutStack
=
0
;
for
(
const
[
k
v
]
of
sensus
.
entries
(
)
)
{
if
(
k
=
=
=
"
noStack
"
)
{
objectsWithoutStack
+
=
v
.
count
;
}
else
{
objectsWithStack
+
=
v
.
count
;
}
}
return
{
objectsWithStack
objectsWithoutStack
}
;
}
getAllocatedMemory
(
)
{
return
MemoryReporter
.
residentUnique
;
}
async
doGC
(
)
{
const
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
await
new
Promise
(
resolve
=
>
Cu
.
schedulePreciseShrinkingGC
(
resolve
)
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
}
}
stop
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Stop
logging
allocations
\
n
"
)
;
dbg
.
onNewGlobalObject
=
undefined
;
dbg
.
removeAllDebuggees
(
)
;
dbg
=
null
;
}
}
;
}
;
