"
use
strict
"
;
const
{
Cu
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
MemoryReporter
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
const
global
=
Cu
.
getGlobalForObject
(
this
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
)
;
addDebuggerToGlobal
(
global
)
;
exports
.
allocationTracker
=
function
(
{
watchGlobal
watchAllGlobals
watchDevToolsGlobals
}
=
{
}
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Start
logging
allocations
\
n
"
)
;
let
dbg
=
new
global
.
Debugger
(
)
;
dbg
.
memory
.
trackingAllocationSites
=
true
;
dbg
.
memory
.
allocationSamplingProbability
=
1
.
0
;
dbg
.
memory
.
maxAllocationsLogLength
=
5000000
;
let
acceptGlobal
;
if
(
watchGlobal
)
{
acceptGlobal
=
(
)
=
>
false
;
dbg
.
addDebuggee
(
watchGlobal
)
;
}
else
if
(
watchAllGlobals
)
{
acceptGlobal
=
(
)
=
>
true
;
}
else
if
(
watchDevToolsGlobals
)
{
const
builtinGlobal
=
require
(
"
devtools
/
shared
/
builtin
-
modules
"
)
;
acceptGlobal
=
g
=
>
{
if
(
g
.
class
=
=
"
self
-
hosting
-
global
"
)
{
dump
(
"
TRACKER
NEW
GLOBAL
:
-
:
"
+
g
.
class
+
"
\
n
"
)
;
return
false
;
}
const
ref
=
g
.
unsafeDereference
(
)
;
const
location
=
Cu
.
getRealmLocation
(
ref
)
;
let
accept
=
!
!
location
.
match
(
/
devtools
/
i
)
;
if
(
ref
=
=
Cu
.
getGlobalForObject
(
builtinGlobal
)
|
|
ref
=
=
builtinGlobal
.
internalSandbox
)
{
accept
=
false
;
}
dump
(
"
TRACKER
NEW
GLOBAL
:
"
+
(
accept
?
"
+
"
:
"
-
"
)
+
"
:
"
+
location
+
"
\
n
"
)
;
return
accept
;
}
;
}
if
(
watchAllGlobals
|
|
watchDevToolsGlobals
)
{
dbg
.
addAllGlobalsAsDebuggees
(
)
;
for
(
const
g
of
dbg
.
getDebuggees
(
)
)
{
if
(
!
acceptGlobal
(
g
)
)
{
dbg
.
removeDebuggee
(
g
)
;
}
}
}
dbg
.
removeDebuggee
(
global
)
;
dbg
.
onNewGlobalObject
=
function
(
g
)
{
if
(
acceptGlobal
(
g
)
)
{
dbg
.
addDebuggee
(
g
)
;
}
}
;
return
{
get
overflowed
(
)
{
return
dbg
.
memory
.
allocationsLogOverflowed
;
}
async
startRecordingAllocations
(
debug_allocations
)
{
await
this
.
doGC
(
)
;
const
memory
=
this
.
getAllocatedMemory
(
)
;
const
objects
=
this
.
stillAllocatedObjects
(
)
;
if
(
debug_allocations
=
=
"
allocations
"
)
{
this
.
flushAllocations
(
)
;
}
const
allocations
=
debug_allocations
=
=
"
leaks
"
?
this
.
getAllAllocations
(
)
:
null
;
this
.
data
=
{
memory
objects
allocations
}
;
return
this
.
data
;
}
async
stopRecordingAllocations
(
debug_allocations
)
{
await
this
.
doGC
(
)
;
const
memory
=
this
.
getAllocatedMemory
(
)
;
const
objects
=
this
.
stillAllocatedObjects
(
)
;
if
(
debug_allocations
=
=
"
allocations
"
)
{
this
.
logAllocationLog
(
)
;
}
else
if
(
debug_allocations
=
=
"
leaks
"
)
{
this
.
logAllocationSitesDiff
(
this
.
data
.
allocations
)
;
}
return
{
objectsWithoutStack
:
objects
.
objectsWithoutStack
-
this
.
data
.
objects
.
objectsWithoutStack
objectsWithStack
:
objects
.
objectsWithStack
-
this
.
data
.
objects
.
objectsWithStack
memory
:
memory
-
this
.
data
.
memory
}
;
}
getAllAllocations
(
)
{
const
sensus
=
dbg
.
memory
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
}
}
)
;
const
sources
=
{
}
;
for
(
const
[
k
v
]
of
sensus
.
entries
(
)
)
{
const
src
=
k
.
source
|
|
"
UNKNOWN
"
;
const
line
=
k
.
line
|
|
"
?
"
;
const
count
=
v
.
count
;
let
item
=
sources
[
src
]
;
if
(
!
item
)
{
item
=
sources
[
src
]
=
{
count
:
0
lines
:
{
}
}
;
}
item
.
count
+
=
count
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
item
.
lines
[
line
]
=
0
;
}
item
.
lines
[
line
]
+
=
count
;
}
}
return
sources
;
}
sourcesDiff
(
previousSources
newSources
)
{
for
(
const
src
in
previousSources
)
{
const
previousItem
=
previousSources
[
src
]
;
const
item
=
newSources
[
src
]
;
if
(
!
item
)
{
continue
;
}
item
.
count
-
=
previousItem
.
count
;
for
(
const
line
in
previousItem
.
lines
)
{
const
count
=
previousItem
.
lines
[
line
]
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
continue
;
}
item
.
lines
[
line
]
-
=
count
;
}
}
}
}
logAllocationSites
(
message
sources
{
first
=
1000
}
=
{
}
)
{
const
allocationList
=
Object
.
entries
(
sources
)
.
sort
(
(
[
srcA
itemA
]
[
srcB
itemB
]
)
=
>
itemB
.
count
-
itemA
.
count
)
.
filter
(
(
_
i
)
=
>
i
<
first
)
.
map
(
(
[
src
item
]
)
=
>
{
const
lines
=
[
]
;
Object
.
entries
(
item
.
lines
)
.
filter
(
(
[
line
count
]
)
=
>
count
>
0
)
.
sort
(
(
[
lineA
countA
]
[
lineB
countB
]
)
=
>
{
if
(
countA
!
=
countB
)
{
return
countB
-
countA
;
}
return
lineB
-
lineA
;
}
)
.
forEach
(
(
[
line
count
]
)
=
>
{
lines
.
push
(
line
+
"
:
"
+
count
)
;
}
)
;
return
{
src
count
:
item
.
count
lines
}
;
}
)
.
filter
(
(
{
count
}
)
=
>
count
>
0
)
;
dump
(
"
DEVTOOLS
ALLOCATION
:
"
+
message
+
"
:
\
n
"
+
JSON
.
stringify
(
allocationList
null
2
)
+
"
\
n
"
)
;
}
logAllocationSitesDiff
(
previousSources
)
{
const
newSources
=
this
.
getAllAllocations
(
)
;
this
.
sourcesDiff
(
previousSources
newSources
)
;
return
this
.
logAllocationSites
(
"
allocations
which
leaked
"
newSources
)
;
}
allocationsToSources
(
allocations
)
{
const
sources
=
{
}
;
for
(
const
alloc
of
allocations
)
{
const
{
frame
}
=
alloc
;
let
src
=
"
UNKNOWN
"
;
let
line
=
-
1
;
try
{
if
(
frame
)
{
src
=
frame
.
source
|
|
"
UNKNOWN
"
;
line
=
frame
.
line
|
|
-
1
;
}
}
catch
(
e
)
{
}
let
item
=
sources
[
src
]
;
if
(
!
item
)
{
item
=
sources
[
src
]
=
{
count
:
0
lines
:
{
}
}
;
}
item
.
count
+
+
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
item
.
lines
[
line
]
=
0
;
}
item
.
lines
[
line
]
+
+
;
}
}
return
sources
;
}
logAllocationLog
(
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
const
sources
=
this
.
allocationsToSources
(
allocations
)
;
return
this
.
logAllocationSites
(
"
all
allocations
(
which
may
be
freed
or
are
still
allocated
)
"
sources
)
;
}
logCount
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Javascript
object
allocations
:
"
+
this
.
countAllocations
(
)
+
"
\
n
"
)
;
}
countAllocations
(
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
return
allocations
.
length
;
}
flushAllocations
(
)
{
dbg
.
memory
.
drainAllocationsLog
(
)
;
}
stillAllocatedObjects
(
)
{
const
sensus
=
dbg
.
memory
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
}
}
)
;
let
objectsWithStack
=
0
;
let
objectsWithoutStack
=
0
;
for
(
const
[
k
v
]
of
sensus
.
entries
(
)
)
{
if
(
k
=
=
=
"
noStack
"
)
{
objectsWithoutStack
+
=
v
.
count
;
}
else
{
objectsWithStack
+
=
v
.
count
;
}
}
return
{
objectsWithStack
objectsWithoutStack
}
;
}
getAllocatedMemory
(
)
{
return
MemoryReporter
.
residentUnique
;
}
async
doGC
(
)
{
const
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
await
new
Promise
(
resolve
=
>
Cu
.
schedulePreciseShrinkingGC
(
resolve
)
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
}
}
stop
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Stop
logging
allocations
\
n
"
)
;
dbg
.
onNewGlobalObject
=
undefined
;
dbg
.
removeAllDebuggees
(
)
;
dbg
=
null
;
}
}
;
}
;
