"
use
strict
"
;
const
{
Cu
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
MemoryReporter
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
const
global
=
Cu
.
getGlobalForObject
(
this
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
)
;
addDebuggerToGlobal
(
global
)
;
exports
.
allocationTracker
=
function
(
{
watchGlobal
watchAllGlobals
watchDevToolsGlobals
}
=
{
}
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Start
logging
allocations
\
n
"
)
;
let
dbg
=
new
global
.
Debugger
(
)
;
dbg
.
memory
.
trackingAllocationSites
=
true
;
dbg
.
memory
.
allocationSamplingProbability
=
1
.
0
;
dbg
.
memory
.
maxAllocationsLogLength
=
5000000
;
let
acceptGlobal
;
if
(
watchGlobal
)
{
acceptGlobal
=
(
)
=
>
false
;
dbg
.
addDebuggee
(
watchGlobal
)
;
}
else
if
(
watchAllGlobals
)
{
acceptGlobal
=
(
)
=
>
true
;
}
else
if
(
watchDevToolsGlobals
)
{
const
builtinGlobal
=
require
(
"
devtools
/
shared
/
loader
/
builtin
-
modules
"
)
;
acceptGlobal
=
g
=
>
{
if
(
g
.
class
=
=
"
self
-
hosting
-
global
"
)
{
dump
(
"
TRACKER
NEW
GLOBAL
:
-
:
"
+
g
.
class
+
"
\
n
"
)
;
return
false
;
}
let
ref
=
g
.
unsafeDereference
(
)
;
if
(
g
.
class
=
=
"
Window
"
&
&
ref
.
top
)
{
ref
=
ref
.
top
;
}
const
location
=
Cu
.
getRealmLocation
(
ref
)
;
let
accept
=
!
!
location
.
match
(
/
devtools
/
i
)
;
if
(
ref
=
=
Cu
.
getGlobalForObject
(
builtinGlobal
)
|
|
ref
=
=
builtinGlobal
.
internalSandbox
)
{
accept
=
false
;
}
dump
(
"
TRACKER
NEW
GLOBAL
:
"
+
(
accept
?
"
+
"
:
"
-
"
)
+
"
:
"
+
location
+
"
\
n
"
)
;
return
accept
;
}
;
}
if
(
watchAllGlobals
|
|
watchDevToolsGlobals
)
{
dbg
.
addAllGlobalsAsDebuggees
(
)
;
for
(
const
g
of
dbg
.
getDebuggees
(
)
)
{
if
(
!
acceptGlobal
(
g
)
)
{
dbg
.
removeDebuggee
(
g
)
;
}
}
}
dbg
.
removeDebuggee
(
global
)
;
dbg
.
onNewGlobalObject
=
function
(
g
)
{
if
(
acceptGlobal
(
g
)
)
{
dbg
.
addDebuggee
(
g
)
;
}
}
;
return
{
get
overflowed
(
)
{
return
dbg
.
memory
.
allocationsLogOverflowed
;
}
async
startRecordingAllocations
(
debug_allocations
)
{
dbg
.
memory
.
allocationSamplingProbability
=
0
.
0
;
this
.
flushAllocations
(
)
;
await
this
.
doGC
(
)
;
dbg
.
memory
.
allocationSamplingProbability
=
1
.
0
;
const
memory
=
this
.
getAllocatedMemory
(
)
;
const
objects
=
this
.
stillAllocatedObjects
(
)
;
if
(
debug_allocations
=
=
"
allocations
"
)
{
this
.
flushAllocations
(
)
;
}
const
allocations
=
debug_allocations
=
=
"
leaks
"
?
this
.
getAllAllocations
(
)
:
null
;
this
.
data
=
{
memory
objects
allocations
}
;
return
this
.
data
;
}
async
stopRecordingAllocations
(
debug_allocations
)
{
if
(
debug_allocations
!
=
"
allocations
"
)
{
this
.
flushAllocations
(
)
;
}
if
(
watchAllGlobals
)
{
dbg
.
memory
.
allocationSamplingProbability
=
0
.
0
;
}
await
this
.
doGC
(
)
;
if
(
!
watchAllGlobals
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
if
(
allocations
.
length
)
{
this
.
logAllocationLog
(
allocations
"
Allocation
that
happened
during
the
GC
"
)
;
console
.
error
(
"
Allocation
happened
during
the
GC
.
Are
you
waiting
correctly
before
calling
stopRecordingAllocations
?
"
)
;
}
}
const
memory
=
this
.
getAllocatedMemory
(
)
;
const
objects
=
this
.
stillAllocatedObjects
(
)
;
let
leaks
;
if
(
debug_allocations
=
=
"
allocations
"
)
{
this
.
logAllocationLog
(
)
;
}
else
if
(
debug_allocations
=
=
"
leaks
"
)
{
leaks
=
this
.
logAllocationSitesDiff
(
this
.
data
.
allocations
)
;
}
return
{
objectsWithoutStack
:
objects
.
objectsWithoutStack
-
this
.
data
.
objects
.
objectsWithoutStack
objectsWithStack
:
objects
.
objectsWithStack
-
this
.
data
.
objects
.
objectsWithStack
memory
:
memory
-
this
.
data
.
memory
leaks
}
;
}
getAllAllocations
(
)
{
const
sensus
=
dbg
.
memory
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
}
}
)
;
const
sources
=
{
}
;
for
(
const
[
k
v
]
of
sensus
.
entries
(
)
)
{
const
src
=
k
.
source
|
|
"
UNKNOWN
"
;
const
line
=
k
.
line
|
|
"
?
"
;
const
count
=
v
.
count
;
let
item
=
sources
[
src
]
;
if
(
!
item
)
{
item
=
sources
[
src
]
=
{
count
:
0
lines
:
{
}
}
;
}
item
.
count
+
=
count
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
item
.
lines
[
line
]
=
0
;
}
item
.
lines
[
line
]
+
=
count
;
}
}
return
sources
;
}
sourcesDiff
(
previousSources
newSources
)
{
for
(
const
src
in
previousSources
)
{
const
previousItem
=
previousSources
[
src
]
;
const
item
=
newSources
[
src
]
;
if
(
!
item
)
{
continue
;
}
item
.
count
-
=
previousItem
.
count
;
for
(
const
line
in
previousItem
.
lines
)
{
const
count
=
previousItem
.
lines
[
line
]
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
continue
;
}
item
.
lines
[
line
]
-
=
count
;
}
}
}
}
logAllocationSites
(
message
sources
{
first
=
1000
}
=
{
}
)
{
const
allocationList
=
Object
.
entries
(
sources
)
.
sort
(
(
[
srcA
itemA
]
[
srcB
itemB
]
)
=
>
itemB
.
count
-
itemA
.
count
)
.
filter
(
(
_
i
)
=
>
i
<
first
)
.
map
(
(
[
src
item
]
)
=
>
{
const
lines
=
[
]
;
Object
.
entries
(
item
.
lines
)
.
filter
(
(
[
line
count
]
)
=
>
count
>
0
)
.
sort
(
(
[
lineA
countA
]
[
lineB
countB
]
)
=
>
{
if
(
countA
!
=
countB
)
{
return
countB
-
countA
;
}
return
lineB
-
lineA
;
}
)
.
forEach
(
(
[
line
count
]
)
=
>
{
lines
.
push
(
line
+
"
:
"
+
count
)
;
}
)
;
return
{
src
count
:
item
.
count
lines
}
;
}
)
.
filter
(
(
{
count
}
)
=
>
count
>
0
)
;
dump
(
"
DEVTOOLS
ALLOCATION
:
"
+
message
+
"
:
\
n
"
+
JSON
.
stringify
(
allocationList
null
2
)
+
"
\
n
"
)
;
return
allocationList
;
}
logAllocationSitesDiff
(
previousSources
)
{
const
newSources
=
this
.
getAllAllocations
(
)
;
this
.
sourcesDiff
(
previousSources
newSources
)
;
return
this
.
logAllocationSites
(
"
allocations
which
leaked
"
newSources
)
;
}
allocationsToSources
(
allocations
)
{
const
sources
=
{
}
;
for
(
const
alloc
of
allocations
)
{
const
{
frame
}
=
alloc
;
let
src
=
"
UNKNOWN
"
;
let
line
=
-
1
;
try
{
if
(
frame
)
{
src
=
frame
.
source
|
|
"
UNKNOWN
"
;
line
=
frame
.
line
|
|
-
1
;
}
}
catch
(
e
)
{
}
let
item
=
sources
[
src
]
;
if
(
!
item
)
{
item
=
sources
[
src
]
=
{
count
:
0
lines
:
{
}
}
;
}
item
.
count
+
+
;
if
(
line
!
=
-
1
)
{
if
(
!
item
.
lines
[
line
]
)
{
item
.
lines
[
line
]
=
0
;
}
item
.
lines
[
line
]
+
+
;
}
}
return
sources
;
}
logAllocationLog
(
allocations
msg
=
"
"
)
{
if
(
!
allocations
)
{
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
}
const
sources
=
this
.
allocationsToSources
(
allocations
)
;
return
this
.
logAllocationSites
(
msg
?
msg
:
"
all
allocations
(
which
may
be
freed
or
are
still
allocated
)
"
sources
)
;
}
logCount
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Javascript
object
allocations
:
"
+
this
.
countAllocations
(
)
+
"
\
n
"
)
;
}
countAllocations
(
)
{
const
allocations
=
dbg
.
memory
.
drainAllocationsLog
(
)
;
return
allocations
.
length
;
}
flushAllocations
(
)
{
dbg
.
memory
.
drainAllocationsLog
(
)
;
}
stillAllocatedObjects
(
)
{
const
sensus
=
dbg
.
memory
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
}
}
)
;
let
objectsWithStack
=
0
;
let
objectsWithoutStack
=
0
;
for
(
const
[
k
v
]
of
sensus
.
entries
(
)
)
{
if
(
k
=
=
=
"
noStack
"
)
{
objectsWithoutStack
+
=
v
.
count
;
}
else
{
objectsWithStack
+
=
v
.
count
;
}
}
return
{
objectsWithStack
objectsWithoutStack
}
;
}
getAllocatedMemory
(
)
{
return
MemoryReporter
.
residentUnique
;
}
async
doGC
(
)
{
const
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
await
new
Promise
(
resolve
=
>
Cu
.
schedulePreciseShrinkingGC
(
resolve
)
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
}
await
new
Promise
(
resolve
=
>
MemoryReporter
.
minimizeMemoryUsage
(
resolve
)
)
;
}
getSnapshotFile
(
)
{
return
ChromeUtils
.
saveHeapSnapshot
(
{
debugger
:
dbg
}
)
;
}
traceObjects
(
objects
snapshotFile
)
{
if
(
!
snapshotFile
)
{
snapshotFile
=
this
.
getSnapshotFile
(
)
;
}
const
snapshot
=
ChromeUtils
.
readHeapSnapshot
(
snapshotFile
)
;
function
getObjectClass
(
id
)
{
if
(
!
id
)
{
return
"
<
null
>
"
;
}
try
{
let
stack
=
[
.
.
.
snapshot
.
describeNode
(
{
by
:
"
allocationStack
"
}
id
)
]
;
let
line
;
if
(
stack
)
{
stack
=
stack
.
find
(
(
[
src
]
)
=
>
src
!
=
"
noStack
"
)
;
if
(
stack
)
{
line
=
stack
[
0
]
.
line
;
stack
=
stack
[
0
]
.
source
;
if
(
stack
)
{
const
pstack
=
stack
;
stack
=
stack
.
match
(
/
\
/
(
[
^
\
/
]
+
)
/
)
;
if
(
stack
)
{
stack
=
stack
[
1
]
;
}
else
{
stack
=
pstack
;
}
}
else
{
stack
=
"
no
-
source
"
;
}
}
else
{
stack
=
"
no
-
stack
"
;
}
}
else
{
stack
=
"
no
-
desc
"
;
}
return
(
Object
.
entries
(
snapshot
.
describeNode
(
{
by
:
"
objectClass
"
}
id
)
)
[
0
]
[
0
]
+
(
stack
?
"
"
+
stack
+
"
:
"
+
line
:
"
"
)
)
;
}
catch
(
e
)
{
if
(
e
.
name
=
=
"
NS_ERROR_ILLEGAL_VALUE
"
)
{
return
"
<
not
-
in
-
memory
-
snapshot
:
is
-
from
-
untracked
-
global
?
>
"
;
}
return
"
<
invalid
:
"
+
id
+
"
:
"
+
e
+
"
>
"
;
}
}
function
printPath
(
src
dst
)
{
let
paths
;
try
{
paths
=
snapshot
.
computeShortestPaths
(
src
[
dst
]
10
)
;
}
catch
(
e
)
{
}
if
(
paths
&
&
paths
.
has
(
dst
)
)
{
let
pathLength
=
Infinity
;
for
(
const
path
of
paths
.
get
(
dst
)
)
{
if
(
path
.
length
>
pathLength
)
{
continue
;
}
pathLength
=
path
.
length
;
dump
(
"
-
"
+
path
.
map
(
(
{
predecessor
edge
}
)
=
>
getObjectClass
(
predecessor
)
+
"
.
"
+
edge
)
.
join
(
"
\
n
\
\
-
-
>
"
)
+
"
\
n
\
\
-
-
>
"
+
getObjectClass
(
dst
)
+
"
\
n
"
)
;
}
}
else
{
dump
(
"
NO
-
PATH
\
n
"
)
;
}
}
const
tree
=
snapshot
.
computeDominatorTree
(
)
;
for
(
const
objectNodeId
of
objects
)
{
dump
(
"
#
Tracing
:
"
+
getObjectClass
(
objectNodeId
)
+
"
\
n
"
)
;
dump
(
"
#
#
#
Path
(
s
)
from
root
:
\
n
"
)
;
printPath
(
tree
.
root
objectNodeId
)
;
}
}
stop
(
)
{
dump
(
"
DEVTOOLS
ALLOCATION
:
Stop
logging
allocations
\
n
"
)
;
dbg
.
onNewGlobalObject
=
undefined
;
dbg
.
removeAllDebuggees
(
)
;
dbg
=
null
;
}
}
;
}
;
