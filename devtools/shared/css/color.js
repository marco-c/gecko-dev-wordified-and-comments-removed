"
use
strict
"
;
const
COLOR_UNIT_PREF
=
"
devtools
.
defaultColorUnit
"
;
const
SPECIALVALUES
=
new
Set
(
[
"
currentcolor
"
"
initial
"
"
inherit
"
"
transparent
"
"
unset
"
]
)
;
class
CssColor
{
constructor
(
colorValue
)
{
this
.
#
lowerCased
=
colorValue
.
toLowerCase
(
)
;
this
.
#
authored
=
colorValue
;
this
.
specialValue
=
SPECIALVALUES
.
has
(
this
.
#
lowerCased
)
?
this
.
#
authored
:
null
;
}
static
COLORUNIT
=
{
authored
:
"
authored
"
hex
:
"
hex
"
name
:
"
name
"
rgb
:
"
rgb
"
hsl
:
"
hsl
"
hwb
:
"
hwb
"
}
;
#
authored
=
null
;
#
currentFormat
;
#
lowerCased
=
null
;
get
hasAlpha
(
)
{
if
(
!
this
.
valid
)
{
return
false
;
}
return
this
.
getRGBATuple
(
)
.
a
!
=
=
1
;
}
get
valid
(
)
{
return
InspectorUtils
.
colorToRGBA
(
this
.
#
authored
)
!
=
=
null
;
}
get
highResTuple
(
)
{
const
type
=
classifyColor
(
this
.
#
authored
)
;
if
(
type
=
=
=
CssColor
.
COLORUNIT
.
hex
)
{
return
hexToRGBA
(
this
.
#
authored
.
substring
(
1
)
true
)
;
}
const
tuple
=
InspectorUtils
.
colorToRGBA
(
this
.
#
authored
)
;
tuple
.
a
*
=
255
;
return
tuple
;
}
get
transparent
(
)
{
try
{
const
tuple
=
this
.
getRGBATuple
(
)
;
return
!
(
tuple
.
r
|
|
tuple
.
g
|
|
tuple
.
b
|
|
tuple
.
a
)
;
}
catch
(
e
)
{
return
false
;
}
}
get
name
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
const
tuple
=
this
.
getRGBATuple
(
)
;
if
(
tuple
.
a
!
=
=
1
)
{
return
this
.
hex
;
}
const
{
r
g
b
}
=
tuple
;
return
InspectorUtils
.
rgbToColorName
(
r
g
b
)
|
|
this
.
hex
;
}
get
hex
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
hasAlpha
)
{
return
this
.
alphaHex
;
}
let
hex
=
this
.
longHex
;
if
(
hex
.
charAt
(
1
)
=
=
hex
.
charAt
(
2
)
&
&
hex
.
charAt
(
3
)
=
=
hex
.
charAt
(
4
)
&
&
hex
.
charAt
(
5
)
=
=
hex
.
charAt
(
6
)
)
{
hex
=
"
#
"
+
hex
.
charAt
(
1
)
+
hex
.
charAt
(
3
)
+
hex
.
charAt
(
5
)
;
}
return
hex
;
}
get
alphaHex
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
let
alphaHex
=
this
.
longAlphaHex
;
if
(
alphaHex
.
charAt
(
1
)
=
=
alphaHex
.
charAt
(
2
)
&
&
alphaHex
.
charAt
(
3
)
=
=
alphaHex
.
charAt
(
4
)
&
&
alphaHex
.
charAt
(
5
)
=
=
alphaHex
.
charAt
(
6
)
&
&
alphaHex
.
charAt
(
7
)
=
=
alphaHex
.
charAt
(
8
)
)
{
alphaHex
=
"
#
"
+
alphaHex
.
charAt
(
1
)
+
alphaHex
.
charAt
(
3
)
+
alphaHex
.
charAt
(
5
)
+
alphaHex
.
charAt
(
7
)
;
}
return
alphaHex
;
}
get
longHex
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
hasAlpha
)
{
return
this
.
longAlphaHex
;
}
const
tuple
=
this
.
getRGBATuple
(
)
;
return
(
"
#
"
+
(
(
1
<
<
24
)
+
(
tuple
.
r
<
<
16
)
+
(
tuple
.
g
<
<
8
)
+
(
tuple
.
b
<
<
0
)
)
.
toString
(
16
)
.
substr
(
-
6
)
)
;
}
get
longAlphaHex
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
const
tuple
=
this
.
highResTuple
;
return
(
"
#
"
+
(
(
1
<
<
24
)
+
(
tuple
.
r
<
<
16
)
+
(
tuple
.
g
<
<
8
)
+
(
tuple
.
b
<
<
0
)
)
.
toString
(
16
)
.
substr
(
-
6
)
+
Math
.
round
(
tuple
.
a
)
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
;
}
get
rgb
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
!
this
.
hasAlpha
)
{
if
(
this
.
#
lowerCased
.
startsWith
(
"
rgb
(
"
)
)
{
return
this
.
#
authored
;
}
const
tuple
=
this
.
getRGBATuple
(
)
;
return
"
rgb
(
"
+
tuple
.
r
+
"
"
+
tuple
.
g
+
"
"
+
tuple
.
b
+
"
)
"
;
}
return
this
.
rgba
;
}
get
rgba
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
#
lowerCased
.
startsWith
(
"
rgba
(
"
)
)
{
return
this
.
#
authored
;
}
const
components
=
this
.
getRGBATuple
(
)
;
return
(
"
rgba
(
"
+
components
.
r
+
"
"
+
components
.
g
+
"
"
+
components
.
b
+
"
"
+
components
.
a
+
"
)
"
)
;
}
get
hsl
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
#
lowerCased
.
startsWith
(
"
hsl
(
"
)
)
{
return
this
.
#
authored
;
}
if
(
this
.
hasAlpha
)
{
return
this
.
hsla
;
}
return
this
.
#
hsl
(
)
;
}
get
hsla
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
#
lowerCased
.
startsWith
(
"
hsla
(
"
)
)
{
return
this
.
#
authored
;
}
if
(
this
.
hasAlpha
)
{
const
a
=
this
.
getRGBATuple
(
)
.
a
;
return
this
.
#
hsl
(
a
)
;
}
return
this
.
#
hsl
(
1
)
;
}
get
hwb
(
)
{
const
invalidOrSpecialValue
=
this
.
#
getInvalidOrSpecialValue
(
)
;
if
(
invalidOrSpecialValue
!
=
=
false
)
{
return
invalidOrSpecialValue
;
}
if
(
this
.
#
lowerCased
.
startsWith
(
"
hwb
(
"
)
)
{
return
this
.
#
authored
;
}
if
(
this
.
hasAlpha
)
{
const
a
=
this
.
getRGBATuple
(
)
.
a
;
return
this
.
#
hwb
(
a
)
;
}
return
this
.
#
hwb
(
)
;
}
#
getInvalidOrSpecialValue
(
)
{
if
(
this
.
specialValue
)
{
return
this
.
specialValue
;
}
if
(
!
this
.
valid
)
{
return
"
"
;
}
return
false
;
}
nextColorUnit
(
)
{
let
formats
=
[
"
hex
"
"
hsl
"
"
rgb
"
"
hwb
"
"
name
"
]
;
let
currentFormat
=
this
.
#
currentFormat
;
if
(
!
currentFormat
)
{
const
defaultFormat
=
Services
.
prefs
.
getCharPref
(
COLOR_UNIT_PREF
)
;
currentFormat
=
defaultFormat
=
=
=
CssColor
.
COLORUNIT
.
authored
?
classifyColor
(
this
.
#
authored
)
:
defaultFormat
;
}
const
putOnEnd
=
formats
.
splice
(
0
formats
.
indexOf
(
currentFormat
)
)
;
formats
=
[
.
.
.
formats
.
.
.
putOnEnd
]
;
const
currentDisplayedColor
=
this
[
formats
[
0
]
]
;
let
colorUnit
;
for
(
const
format
of
formats
)
{
if
(
this
[
format
]
.
toLowerCase
(
)
!
=
=
currentDisplayedColor
.
toLowerCase
(
)
)
{
colorUnit
=
CssColor
.
COLORUNIT
[
format
]
;
break
;
}
}
this
.
#
currentFormat
=
colorUnit
;
return
this
.
toString
(
colorUnit
)
;
}
toString
(
colorUnit
forceUppercase
)
{
let
color
;
switch
(
colorUnit
)
{
case
CssColor
.
COLORUNIT
.
authored
:
color
=
this
.
#
authored
;
break
;
case
CssColor
.
COLORUNIT
.
hex
:
color
=
this
.
hex
;
break
;
case
CssColor
.
COLORUNIT
.
hsl
:
color
=
this
.
hsl
;
break
;
case
CssColor
.
COLORUNIT
.
name
:
color
=
this
.
name
;
break
;
case
CssColor
.
COLORUNIT
.
rgb
:
color
=
this
.
rgb
;
break
;
case
CssColor
.
COLORUNIT
.
hwb
:
color
=
this
.
hwb
;
break
;
default
:
color
=
this
.
rgb
;
}
if
(
forceUppercase
|
|
(
colorUnit
!
=
CssColor
.
COLORUNIT
.
authored
&
&
colorIsUppercase
(
this
.
#
authored
)
)
)
{
color
=
color
.
toUpperCase
(
)
;
}
return
color
;
}
getRGBATuple
(
)
{
const
tuple
=
InspectorUtils
.
colorToRGBA
(
this
.
#
authored
)
;
tuple
.
a
=
parseFloat
(
tuple
.
a
.
toFixed
(
2
)
)
;
return
tuple
;
}
#
hsl
(
maybeAlpha
)
{
if
(
this
.
#
lowerCased
.
startsWith
(
"
hsl
(
"
)
&
&
maybeAlpha
=
=
=
undefined
)
{
return
this
.
#
authored
;
}
const
{
r
g
b
}
=
this
.
getRGBATuple
(
)
;
const
[
h
s
l
]
=
rgbToHsl
(
[
r
g
b
]
)
;
if
(
maybeAlpha
!
=
=
undefined
)
{
return
"
hsla
(
"
+
h
+
"
"
+
s
+
"
%
"
+
l
+
"
%
"
+
maybeAlpha
+
"
)
"
;
}
return
"
hsl
(
"
+
h
+
"
"
+
s
+
"
%
"
+
l
+
"
%
)
"
;
}
#
hwb
(
maybeAlpha
)
{
if
(
this
.
#
lowerCased
.
startsWith
(
"
hwb
(
"
)
&
&
maybeAlpha
=
=
=
undefined
)
{
return
this
.
#
authored
;
}
const
{
r
g
b
}
=
this
.
getRGBATuple
(
)
;
const
[
hue
white
black
]
=
rgbToHwb
(
[
r
g
b
]
)
;
return
hwb
(
{
hue
}
{
white
}
%
{
black
}
%
{
maybeAlpha
!
=
=
undefined
?
"
/
"
+
maybeAlpha
:
"
"
}
)
;
}
valueOf
(
)
{
return
this
.
rgba
;
}
isTransparent
(
)
{
return
this
.
getRGBATuple
(
)
.
a
=
=
=
0
;
}
}
function
rgbToHsl
(
[
r
g
b
]
)
{
r
=
r
/
255
;
g
=
g
/
255
;
b
=
b
/
255
;
const
max
=
Math
.
max
(
r
g
b
)
;
const
min
=
Math
.
min
(
r
g
b
)
;
let
h
;
let
s
;
const
l
=
(
max
+
min
)
/
2
;
if
(
max
=
=
min
)
{
h
=
s
=
0
;
}
else
{
const
d
=
max
-
min
;
s
=
l
>
0
.
5
?
d
/
(
2
-
max
-
min
)
:
d
/
(
max
+
min
)
;
switch
(
max
)
{
case
r
:
h
=
(
(
g
-
b
)
/
d
)
%
6
;
break
;
case
g
:
h
=
(
b
-
r
)
/
d
+
2
;
break
;
case
b
:
h
=
(
r
-
g
)
/
d
+
4
;
break
;
}
h
*
=
60
;
if
(
h
<
0
)
{
h
+
=
360
;
}
}
return
[
roundTo
(
h
1
)
roundTo
(
s
*
100
1
)
roundTo
(
l
*
100
1
)
]
;
}
function
rgbToHwb
(
[
r
g
b
]
)
{
const
hsl
=
rgbToHsl
(
[
r
g
b
]
)
;
r
=
r
/
255
;
g
=
g
/
255
;
b
=
b
/
255
;
const
white
=
Math
.
min
(
r
g
b
)
;
const
black
=
1
-
Math
.
max
(
r
g
b
)
;
return
[
roundTo
(
hsl
[
0
]
1
)
roundTo
(
white
*
100
1
)
roundTo
(
black
*
100
1
)
]
;
}
function
rgbToLab
(
[
r
g
b
]
)
{
r
=
r
/
255
;
g
=
g
/
255
;
b
=
b
/
255
;
r
=
r
>
0
.
04045
?
Math
.
pow
(
(
r
+
0
.
055
)
/
1
.
055
2
.
4
)
:
r
/
12
.
92
;
g
=
g
>
0
.
04045
?
Math
.
pow
(
(
g
+
0
.
055
)
/
1
.
055
2
.
4
)
:
g
/
12
.
92
;
b
=
b
>
0
.
04045
?
Math
.
pow
(
(
b
+
0
.
055
)
/
1
.
055
2
.
4
)
:
b
/
12
.
92
;
r
=
r
*
100
;
g
=
g
*
100
;
b
=
b
*
100
;
let
[
x
y
z
]
=
[
r
*
0
.
4124
+
g
*
0
.
3576
+
b
*
0
.
1805
r
*
0
.
2126
+
g
*
0
.
7152
+
b
*
0
.
0722
r
*
0
.
0193
+
g
*
0
.
1192
+
b
*
0
.
9505
]
;
x
=
x
/
94
.
811
;
y
=
y
/
100
;
z
=
z
/
107
.
304
;
x
=
x
>
0
.
008856
?
Math
.
pow
(
x
1
/
3
)
:
7
.
787
*
x
+
16
/
116
;
y
=
y
>
0
.
008856
?
Math
.
pow
(
y
1
/
3
)
:
7
.
787
*
y
+
16
/
116
;
z
=
z
>
0
.
008856
?
Math
.
pow
(
z
1
/
3
)
:
7
.
787
*
z
+
16
/
116
;
return
[
116
*
y
-
16
500
*
(
x
-
y
)
200
*
(
y
-
z
)
]
;
}
function
calculateDeltaE
(
[
l1
a1
b1
]
[
l2
a2
b2
]
)
{
return
Math
.
sqrt
(
Math
.
pow
(
l1
-
l2
2
)
+
Math
.
pow
(
a1
-
a2
2
)
+
Math
.
pow
(
b1
-
b2
2
)
)
;
}
function
roundTo
(
number
digits
)
{
const
multiplier
=
Math
.
pow
(
10
digits
)
;
return
Math
.
round
(
number
*
multiplier
)
/
multiplier
;
}
function
classifyColor
(
value
)
{
value
=
value
.
toLowerCase
(
)
;
if
(
value
.
startsWith
(
"
rgb
(
"
)
|
|
value
.
startsWith
(
"
rgba
(
"
)
)
{
return
CssColor
.
COLORUNIT
.
rgb
;
}
else
if
(
value
.
startsWith
(
"
hsl
(
"
)
|
|
value
.
startsWith
(
"
hsla
(
"
)
)
{
return
CssColor
.
COLORUNIT
.
hsl
;
}
else
if
(
value
.
startsWith
(
"
hwb
(
"
)
)
{
return
CssColor
.
COLORUNIT
.
hwb
;
}
else
if
(
/
^
#
[
0
-
9a
-
f
]
+
/
.
exec
(
value
)
)
{
return
CssColor
.
COLORUNIT
.
hex
;
}
else
if
(
/
^
[
a
-
z
\
-
]
+
/
.
exec
(
value
)
)
{
return
CssColor
.
COLORUNIT
.
name
;
}
return
CssColor
.
COLORUNIT
.
authored
;
}
function
hexToRGBA
(
name
highResolution
)
{
let
r
g
b
a
=
1
;
if
(
name
.
length
=
=
=
3
)
{
r
=
parseInt
(
name
.
charAt
(
0
)
+
name
.
charAt
(
0
)
16
)
;
g
=
parseInt
(
name
.
charAt
(
1
)
+
name
.
charAt
(
1
)
16
)
;
b
=
parseInt
(
name
.
charAt
(
2
)
+
name
.
charAt
(
2
)
16
)
;
}
else
if
(
name
.
length
=
=
=
4
)
{
r
=
parseInt
(
name
.
charAt
(
0
)
+
name
.
charAt
(
0
)
16
)
;
g
=
parseInt
(
name
.
charAt
(
1
)
+
name
.
charAt
(
1
)
16
)
;
b
=
parseInt
(
name
.
charAt
(
2
)
+
name
.
charAt
(
2
)
16
)
;
a
=
parseInt
(
name
.
charAt
(
3
)
+
name
.
charAt
(
3
)
16
)
;
if
(
!
highResolution
)
{
a
/
=
255
;
}
}
else
if
(
name
.
length
=
=
=
6
)
{
r
=
parseInt
(
name
.
charAt
(
0
)
+
name
.
charAt
(
1
)
16
)
;
g
=
parseInt
(
name
.
charAt
(
2
)
+
name
.
charAt
(
3
)
16
)
;
b
=
parseInt
(
name
.
charAt
(
4
)
+
name
.
charAt
(
5
)
16
)
;
}
else
if
(
name
.
length
=
=
=
8
)
{
r
=
parseInt
(
name
.
charAt
(
0
)
+
name
.
charAt
(
1
)
16
)
;
g
=
parseInt
(
name
.
charAt
(
2
)
+
name
.
charAt
(
3
)
16
)
;
b
=
parseInt
(
name
.
charAt
(
4
)
+
name
.
charAt
(
5
)
16
)
;
a
=
parseInt
(
name
.
charAt
(
6
)
+
name
.
charAt
(
7
)
16
)
;
if
(
!
highResolution
)
{
a
/
=
255
;
}
}
else
{
return
null
;
}
if
(
!
highResolution
)
{
a
=
Math
.
round
(
a
*
10
)
/
10
;
}
return
{
r
g
b
a
}
;
}
function
calculateLuminance
(
rgba
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
rgba
[
i
]
/
=
255
;
rgba
[
i
]
=
rgba
[
i
]
<
0
.
03928
?
rgba
[
i
]
/
12
.
92
:
Math
.
pow
(
(
rgba
[
i
]
+
0
.
055
)
/
1
.
055
2
.
4
)
;
}
return
0
.
2126
*
rgba
[
0
]
+
0
.
7152
*
rgba
[
1
]
+
0
.
0722
*
rgba
[
2
]
;
}
function
blendColors
(
foregroundColor
backgroundColor
=
[
255
255
255
1
]
)
{
const
[
fgR
fgG
fgB
fgA
]
=
foregroundColor
;
const
[
bgR
bgG
bgB
bgA
]
=
backgroundColor
;
if
(
fgA
=
=
=
1
)
{
return
foregroundColor
;
}
return
[
(
1
-
fgA
)
*
bgR
+
fgA
*
fgR
(
1
-
fgA
)
*
bgG
+
fgA
*
fgG
(
1
-
fgA
)
*
bgB
+
fgA
*
fgB
fgA
+
bgA
*
(
1
-
fgA
)
]
;
}
function
calculateContrastRatio
(
backgroundColor
textColor
)
{
backgroundColor
=
Array
.
from
(
backgroundColor
)
;
textColor
=
Array
.
from
(
textColor
)
;
backgroundColor
=
blendColors
(
backgroundColor
)
;
textColor
=
blendColors
(
textColor
backgroundColor
)
;
const
backgroundLuminance
=
calculateLuminance
(
backgroundColor
)
;
const
textLuminance
=
calculateLuminance
(
textColor
)
;
const
ratio
=
(
textLuminance
+
0
.
05
)
/
(
backgroundLuminance
+
0
.
05
)
;
return
ratio
>
1
.
0
?
ratio
:
1
/
ratio
;
}
function
colorIsUppercase
(
color
)
{
return
color
=
=
=
color
.
toUpperCase
(
)
&
&
color
!
=
=
color
.
toLowerCase
(
)
;
}
module
.
exports
.
colorUtils
=
{
CssColor
rgbToHsl
rgbToHwb
rgbToLab
classifyColor
calculateContrastRatio
calculateDeltaE
calculateLuminance
blendColors
colorIsUppercase
}
;
