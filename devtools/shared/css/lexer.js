"
use
strict
"
;
const
eEOFCharacters_None
=
0x0000
;
const
eEOFCharacters_DropBackslash
=
0x0001
;
const
eEOFCharacters_ReplacementChar
=
0x0002
;
const
eEOFCharacters_Asterisk
=
0x0004
;
const
eEOFCharacters_Slash
=
0x0008
;
const
eEOFCharacters_DoubleQuote
=
0x0010
;
const
eEOFCharacters_SingleQuote
=
0x0020
;
const
eEOFCharacters_CloseParen
=
0x0040
;
const
APOSTROPHE
=
"
'
"
.
charCodeAt
(
0
)
;
const
ASTERISK
=
"
*
"
.
charCodeAt
(
0
)
;
const
QUOTATION_MARK
=
'
"
'
.
charCodeAt
(
0
)
;
const
RIGHT_PARENTHESIS
=
"
)
"
.
charCodeAt
(
0
)
;
const
SOLIDUS
=
"
/
"
.
charCodeAt
(
0
)
;
const
UCS2_REPLACEMENT_CHAR
=
0xfffd
;
const
kImpliedEOFCharacters
=
[
UCS2_REPLACEMENT_CHAR
ASTERISK
SOLIDUS
QUOTATION_MARK
APOSTROPHE
RIGHT_PARENTHESIS
0
]
;
class
InspectorCSSParserWrapper
{
#
offset
=
0
;
#
trackEOFChars
;
#
eofCharacters
=
eEOFCharacters_None
;
constructor
(
input
options
=
{
}
)
{
this
.
parser
=
new
InspectorCSSParser
(
input
)
;
this
.
#
trackEOFChars
=
options
.
trackEOFChars
;
}
get
lineNumber
(
)
{
return
this
.
parser
.
lineNumber
;
}
get
columnNumber
(
)
{
return
this
.
parser
.
columnNumber
;
}
nextToken
(
)
{
const
token
=
this
.
parser
.
nextToken
(
)
;
if
(
!
token
)
{
return
token
;
}
if
(
this
.
#
trackEOFChars
)
{
const
{
tokenType
text
}
=
token
;
const
lastChar
=
text
[
text
.
length
-
1
]
;
if
(
tokenType
=
=
=
"
Comment
"
&
&
lastChar
!
=
=
/
)
{
if
(
lastChar
=
=
=
*
)
{
this
.
#
eofCharacters
=
eEOFCharacters_Slash
;
}
else
{
this
.
#
eofCharacters
=
eEOFCharacters_Asterisk
|
eEOFCharacters_Slash
;
}
}
else
if
(
tokenType
=
=
=
"
QuotedString
"
|
|
tokenType
=
=
=
"
BadString
"
)
{
if
(
lastChar
=
=
=
"
\
\
"
)
{
this
.
#
eofCharacters
=
this
.
#
eofCharacters
|
eEOFCharacters_DropBackslash
;
}
if
(
text
[
0
]
!
=
=
lastChar
)
{
this
.
#
eofCharacters
=
this
.
#
eofCharacters
|
(
text
[
0
]
=
=
=
"
?
eEOFCharacters_DoubleQuote
:
eEOFCharacters_SingleQuote
)
;
}
}
else
{
if
(
lastChar
=
=
=
"
\
\
"
)
{
this
.
#
eofCharacters
=
eEOFCharacters_ReplacementChar
;
}
if
(
(
tokenType
=
=
=
"
Function
"
&
&
token
.
value
=
=
=
"
url
"
)
|
|
tokenType
=
=
=
"
BadUrl
"
|
|
(
tokenType
=
=
=
"
UnquotedUrl
"
&
&
lastChar
!
=
=
"
)
"
)
)
{
this
.
#
eofCharacters
=
this
.
#
eofCharacters
|
eEOFCharacters_CloseParen
;
}
if
(
tokenType
=
=
=
"
CloseParenthesis
"
)
{
this
.
#
eofCharacters
=
this
.
#
eofCharacters
&
~
eEOFCharacters_CloseParen
;
}
}
}
token
.
startOffset
=
this
.
#
offset
;
this
.
#
offset
+
=
token
.
text
.
length
;
token
.
endOffset
=
this
.
#
offset
;
return
token
;
}
performEOFFixup
(
inputString
preserveBackslash
)
{
let
result
=
inputString
;
let
eofChars
=
this
.
#
eofCharacters
;
if
(
preserveBackslash
&
&
(
eofChars
&
(
eEOFCharacters_DropBackslash
|
eEOFCharacters_ReplacementChar
)
)
!
=
0
)
{
eofChars
&
=
~
(
eEOFCharacters_DropBackslash
|
eEOFCharacters_ReplacementChar
)
;
result
+
=
"
\
\
"
;
}
if
(
(
eofChars
&
eEOFCharacters_DropBackslash
)
!
=
0
&
&
!
!
result
.
length
&
&
result
.
endsWith
(
"
\
\
"
)
)
{
result
=
result
.
slice
(
0
-
1
)
;
}
let
c
=
eofChars
>
>
1
;
for
(
const
p
of
kImpliedEOFCharacters
)
{
if
(
c
&
1
)
{
result
+
=
String
.
fromCharCode
(
p
)
;
}
c
>
>
=
1
;
}
return
result
;
}
}
exports
.
InspectorCSSParserWrapper
=
InspectorCSSParserWrapper
;
