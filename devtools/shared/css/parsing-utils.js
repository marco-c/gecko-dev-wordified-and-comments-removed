"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
loader
.
lazyRequireGetter
(
this
"
CSS_ANGLEUNIT
"
"
devtools
/
shared
/
css
/
constants
"
true
)
;
const
SELECTOR_ATTRIBUTE
=
exports
.
SELECTOR_ATTRIBUTE
=
1
;
const
SELECTOR_ELEMENT
=
exports
.
SELECTOR_ELEMENT
=
2
;
const
SELECTOR_PSEUDO_CLASS
=
exports
.
SELECTOR_PSEUDO_CLASS
=
3
;
const
NEWLINE_RX
=
/
[
\
r
\
n
]
/
;
const
EMPTY_COMMENT_START_RX
=
/
^
\
/
\
*
!
?
[
\
r
\
n
\
t
\
f
]
*
/
;
const
EMPTY_COMMENT_END_RX
=
/
^
[
\
r
\
n
\
t
\
f
]
*
\
*
\
/
/
;
const
BLANK_LINE_RX
=
/
^
[
\
t
]
*
(
?
:
\
r
\
n
|
\
n
|
\
r
|
\
f
|
)
/
;
const
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
=
"
!
"
;
function
*
cssTokenizer
(
string
)
{
const
lexer
=
getCSSLexer
(
string
)
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
!
=
=
"
comment
"
)
{
yield
token
;
}
}
}
function
cssTokenizerWithLineColumn
(
string
)
{
const
lexer
=
getCSSLexer
(
string
)
;
const
result
=
[
]
;
let
prevToken
=
undefined
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
const
lineNumber
=
lexer
.
lineNumber
;
const
columnNumber
=
lexer
.
columnNumber
;
if
(
prevToken
)
{
prevToken
.
loc
.
end
=
{
line
:
lineNumber
column
:
columnNumber
}
;
}
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
prevToken
=
undefined
;
}
else
{
const
startLoc
=
{
line
:
lineNumber
column
:
columnNumber
}
;
token
.
loc
=
{
start
:
startLoc
}
;
result
.
push
(
token
)
;
prevToken
=
token
;
}
}
return
result
;
}
function
escapeCSSComment
(
inputString
)
{
const
result
=
inputString
.
replace
(
/
\
/
(
\
\
*
)
\
*
/
g
"
/
\
\
1
*
"
)
;
return
result
.
replace
(
/
\
*
(
\
\
*
)
\
/
/
g
"
*
\
\
1
/
"
)
;
}
function
unescapeCSSComment
(
inputString
)
{
const
result
=
inputString
.
replace
(
/
\
/
\
\
(
\
\
*
)
\
*
/
g
"
/
1
*
"
)
;
return
result
.
replace
(
/
\
*
\
\
(
\
\
*
)
\
/
/
g
"
*
1
/
"
)
;
}
function
parseCommentDeclarations
(
isCssPropertyKnown
commentText
startOffset
endOffset
)
{
let
commentOverride
=
false
;
if
(
commentText
=
=
=
"
"
)
{
return
[
]
;
}
else
if
(
commentText
[
0
]
=
=
=
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
)
{
commentOverride
=
true
;
commentText
=
commentText
.
substring
(
1
)
;
}
const
rewrittenText
=
unescapeCSSComment
(
commentText
)
;
const
rewrites
=
new
Array
(
rewrittenText
.
length
+
1
)
.
fill
(
0
)
;
const
commentRe
=
/
\
/
\
\
*
\
*
|
\
*
\
\
*
\
/
/
g
;
while
(
true
)
{
const
matchData
=
commentRe
.
exec
(
rewrittenText
)
;
if
(
!
matchData
)
{
break
;
}
rewrites
[
matchData
.
index
]
=
1
;
}
let
delta
=
0
;
for
(
let
i
=
0
;
i
<
=
rewrittenText
.
length
;
+
+
i
)
{
delta
+
=
rewrites
[
i
]
;
rewrites
[
i
]
=
startOffset
+
2
+
i
+
delta
;
if
(
commentOverride
)
{
+
+
rewrites
[
i
]
;
}
}
const
newDecls
=
parseDeclarationsInternal
(
isCssPropertyKnown
rewrittenText
false
true
commentOverride
)
;
for
(
const
decl
of
newDecls
)
{
decl
.
offsets
[
0
]
=
rewrites
[
decl
.
offsets
[
0
]
]
;
decl
.
offsets
[
1
]
=
rewrites
[
decl
.
offsets
[
1
]
]
;
decl
.
colonOffsets
[
0
]
=
rewrites
[
decl
.
colonOffsets
[
0
]
]
;
decl
.
colonOffsets
[
1
]
=
rewrites
[
decl
.
colonOffsets
[
1
]
]
;
decl
.
commentOffsets
=
[
startOffset
endOffset
]
;
}
return
newDecls
;
}
function
getEmptyDeclaration
(
)
{
return
{
name
:
"
"
value
:
"
"
priority
:
"
"
terminator
:
"
"
offsets
:
[
undefined
undefined
]
colonOffsets
:
false
}
;
}
function
cssTrim
(
str
)
{
const
match
=
/
^
[
\
t
\
r
\
n
\
f
]
*
(
.
*
?
)
[
\
t
\
r
\
n
\
f
]
*
/
.
exec
(
str
)
;
if
(
match
)
{
return
match
[
1
]
;
}
return
str
;
}
function
cssTrimRight
(
str
)
{
const
match
=
/
^
(
.
*
?
)
[
\
t
\
r
\
n
\
f
]
*
/
.
exec
(
str
)
;
if
(
match
)
{
return
match
[
1
]
;
}
return
str
;
}
function
parseDeclarationsInternal
(
isCssPropertyKnown
inputString
parseComments
inComment
commentOverride
)
{
if
(
inputString
=
=
=
null
|
|
inputString
=
=
=
undefined
)
{
throw
new
Error
(
"
empty
input
string
"
)
;
}
const
lexer
=
getCSSLexer
(
inputString
)
;
let
declarations
=
[
getEmptyDeclaration
(
)
]
;
let
lastProp
=
declarations
[
0
]
;
let
importantState
=
0
;
let
importantWS
=
false
;
let
current
=
"
"
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
!
=
=
"
whitespace
"
&
&
token
.
tokenType
!
=
=
"
comment
"
)
{
if
(
lastProp
.
offsets
[
0
]
=
=
=
undefined
)
{
lastProp
.
offsets
[
0
]
=
token
.
startOffset
;
}
lastProp
.
offsets
[
1
]
=
token
.
endOffset
;
}
else
if
(
lastProp
.
name
&
&
!
current
&
&
!
importantState
&
&
!
lastProp
.
priority
&
&
lastProp
.
colonOffsets
[
1
]
)
{
lastProp
.
colonOffsets
[
1
]
=
token
.
endOffset
;
}
else
if
(
importantState
=
=
=
1
)
{
importantWS
=
true
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
:
"
)
{
importantState
=
0
;
importantWS
=
false
;
if
(
!
lastProp
.
name
)
{
lastProp
.
name
=
cssTrim
(
current
)
;
lastProp
.
colonOffsets
=
[
token
.
startOffset
token
.
endOffset
]
;
current
=
"
"
;
if
(
inComment
&
&
!
commentOverride
&
&
!
isCssPropertyKnown
(
lastProp
.
name
)
)
{
lastProp
.
name
=
null
;
break
;
}
}
else
{
current
+
=
"
:
"
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
;
"
)
{
lastProp
.
terminator
=
"
"
;
if
(
inComment
&
&
!
lastProp
.
name
)
{
current
=
"
"
;
break
;
}
if
(
importantState
=
=
=
2
)
{
lastProp
.
priority
=
"
important
"
;
}
else
if
(
importantState
=
=
=
1
)
{
current
+
=
"
!
"
;
if
(
importantWS
)
{
current
+
=
"
"
;
}
}
lastProp
.
value
=
cssTrim
(
current
)
;
current
=
"
"
;
importantState
=
0
;
importantWS
=
false
;
declarations
.
push
(
getEmptyDeclaration
(
)
)
;
lastProp
=
declarations
[
declarations
.
length
-
1
]
;
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
)
{
if
(
token
.
text
=
=
=
"
important
"
&
&
importantState
=
=
=
1
)
{
importantState
=
2
;
}
else
{
if
(
importantState
>
0
)
{
current
+
=
"
!
"
;
if
(
importantWS
)
{
current
+
=
"
"
;
}
if
(
importantState
=
=
=
2
)
{
current
+
=
"
important
"
;
}
importantState
=
0
;
importantWS
=
false
;
}
current
+
=
CSS
.
escape
(
token
.
text
)
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
!
"
)
{
importantState
=
1
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
)
{
if
(
current
!
=
=
"
"
)
{
current
=
current
.
trimRight
(
)
+
"
"
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
if
(
parseComments
&
&
!
lastProp
.
name
&
&
!
lastProp
.
value
)
{
const
commentText
=
inputString
.
substring
(
token
.
startOffset
+
2
token
.
endOffset
-
2
)
;
const
newDecls
=
parseCommentDeclarations
(
isCssPropertyKnown
commentText
token
.
startOffset
token
.
endOffset
)
;
const
lastDecl
=
declarations
.
pop
(
)
;
declarations
=
[
.
.
.
declarations
.
.
.
newDecls
lastDecl
]
;
}
else
{
current
=
current
.
trimRight
(
)
+
"
"
;
}
}
else
{
if
(
importantState
>
0
)
{
current
+
=
"
!
"
;
if
(
importantWS
)
{
current
+
=
"
"
;
}
if
(
importantState
=
=
=
2
)
{
current
+
=
"
important
"
;
}
importantState
=
0
;
importantWS
=
false
;
}
current
+
=
inputString
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
}
if
(
current
)
{
if
(
!
lastProp
.
name
)
{
if
(
!
inComment
)
{
lastProp
.
name
=
cssTrim
(
current
)
;
}
}
else
{
if
(
importantState
=
=
=
2
)
{
lastProp
.
priority
=
"
important
"
;
}
else
if
(
importantState
=
=
=
1
)
{
current
+
=
"
!
"
;
}
lastProp
.
value
=
cssTrim
(
current
)
;
const
terminator
=
lexer
.
performEOFFixup
(
"
"
true
)
;
lastProp
.
terminator
=
terminator
+
"
;
"
;
if
(
terminator
)
{
lastProp
.
offsets
[
1
]
=
inputString
.
length
;
}
}
}
declarations
=
declarations
.
filter
(
prop
=
>
prop
.
name
|
|
prop
.
value
)
;
return
declarations
;
}
function
parseDeclarations
(
isCssPropertyKnown
inputString
parseComments
=
false
)
{
return
parseDeclarationsInternal
(
isCssPropertyKnown
inputString
parseComments
false
false
)
;
}
function
parseNamedDeclarations
(
isCssPropertyKnown
inputString
parseComments
=
false
)
{
return
parseDeclarations
(
isCssPropertyKnown
inputString
parseComments
)
.
filter
(
item
=
>
!
!
item
.
name
)
;
}
function
RuleRewriter
(
isCssPropertyKnown
rule
inputString
)
{
this
.
rule
=
rule
;
this
.
isCssPropertyKnown
=
isCssPropertyKnown
;
this
.
modifications
=
[
]
;
this
.
changedDeclarations
=
{
}
;
this
.
editPromise
=
null
;
this
.
defaultIndentation
=
null
;
this
.
startInitialization
(
inputString
)
;
}
RuleRewriter
.
prototype
=
{
startInitialization
:
function
(
inputString
)
{
this
.
inputString
=
inputString
;
this
.
hasNewLine
=
/
[
\
r
\
n
]
/
.
test
(
this
.
inputString
)
;
this
.
declarations
=
parseNamedDeclarations
(
this
.
isCssPropertyKnown
this
.
inputString
true
)
;
this
.
decl
=
null
;
this
.
result
=
null
;
}
completeInitialization
:
function
(
index
)
{
if
(
index
<
0
)
{
throw
new
Error
(
"
Invalid
index
"
+
index
+
"
.
Expected
positive
integer
"
)
;
}
if
(
index
<
this
.
declarations
.
length
)
{
this
.
decl
=
this
.
declarations
[
index
]
;
this
.
result
=
this
.
inputString
.
substring
(
0
this
.
decl
.
offsets
[
0
]
)
;
}
else
{
this
.
decl
=
null
;
this
.
result
=
this
.
inputString
;
}
}
getIndentation
:
function
(
string
offset
)
{
let
originalOffset
=
offset
;
for
(
-
-
offset
;
offset
>
=
0
;
-
-
offset
)
{
const
c
=
string
[
offset
]
;
if
(
c
=
=
=
"
\
r
"
|
|
c
=
=
=
"
\
n
"
|
|
c
=
=
=
"
\
f
"
)
{
return
string
.
substring
(
offset
+
1
originalOffset
)
;
}
if
(
c
!
=
=
"
"
&
&
c
!
=
=
"
\
t
"
)
{
originalOffset
=
offset
;
}
}
return
"
"
;
}
sanitizePropertyValue
:
function
(
text
)
{
text
=
text
.
replace
(
/
;
/
"
"
)
;
const
lexer
=
getCSSLexer
(
text
)
;
let
result
=
"
"
;
let
previousOffset
=
0
;
const
parenStack
=
[
]
;
let
anySanitized
=
false
;
const
pushParen
=
(
token
closer
)
=
>
{
result
=
result
+
text
.
substring
(
previousOffset
token
.
startOffset
)
+
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
parenStack
.
push
(
{
closer
offset
:
result
.
length
-
1
}
)
;
previousOffset
=
token
.
endOffset
;
}
;
const
popSomeParens
=
(
closer
)
=
>
{
while
(
parenStack
.
length
>
0
)
{
const
paren
=
parenStack
.
pop
(
)
;
if
(
paren
.
closer
=
=
=
closer
)
{
return
true
;
}
result
=
result
.
substring
(
0
paren
.
offset
)
+
"
\
\
"
+
result
.
substring
(
paren
.
offset
)
;
anySanitized
=
true
;
}
return
false
;
}
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
switch
(
token
.
text
)
{
case
"
;
"
:
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
previousOffset
=
token
.
endOffset
;
break
;
case
"
{
"
:
pushParen
(
token
"
}
"
)
;
break
;
case
"
(
"
:
pushParen
(
token
"
)
"
)
;
break
;
case
"
[
"
:
pushParen
(
token
"
]
"
)
;
break
;
case
"
}
"
:
case
"
)
"
:
case
"
]
"
:
if
(
!
popSomeParens
(
token
.
text
)
)
{
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
result
+
=
"
\
\
"
+
token
.
text
;
previousOffset
=
token
.
endOffset
;
anySanitized
=
true
;
}
break
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
pushParen
(
token
"
)
"
)
;
}
}
popSomeParens
(
null
)
;
result
+
=
text
.
substring
(
previousOffset
text
.
length
)
;
const
eofFixup
=
lexer
.
performEOFFixup
(
"
"
true
)
;
if
(
eofFixup
)
{
anySanitized
=
true
;
result
+
=
eofFixup
;
}
return
[
anySanitized
result
]
;
}
skipWhitespaceBackward
:
function
(
string
index
)
{
for
(
-
-
index
;
index
>
=
0
&
&
(
string
[
index
]
=
=
=
"
"
|
|
string
[
index
]
=
=
=
"
\
t
"
)
;
-
-
index
)
{
}
return
index
;
}
maybeTerminateDecl
:
function
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
declarations
.
length
|
|
(
"
commentOffsets
"
in
this
.
declarations
[
index
]
)
)
{
return
;
}
const
termDecl
=
this
.
declarations
[
index
]
;
let
endIndex
=
termDecl
.
offsets
[
1
]
;
endIndex
=
this
.
skipWhitespaceBackward
(
this
.
result
endIndex
)
+
1
;
const
trailingText
=
this
.
result
.
substring
(
endIndex
)
;
if
(
termDecl
.
terminator
)
{
this
.
result
=
this
.
result
.
substring
(
0
endIndex
)
+
termDecl
.
terminator
+
trailingText
;
if
(
termDecl
.
terminator
!
=
=
"
;
"
&
&
termDecl
.
terminator
!
=
=
"
*
/
;
"
)
{
this
.
changedDeclarations
[
index
]
=
termDecl
.
value
+
termDecl
.
terminator
.
slice
(
0
-
1
)
;
}
}
if
(
this
.
hasNewLine
&
&
!
NEWLINE_RX
.
test
(
trailingText
)
)
{
this
.
result
+
=
"
\
n
"
;
}
}
sanitizeText
:
function
(
text
index
)
{
const
[
anySanitized
sanitizedText
]
=
this
.
sanitizePropertyValue
(
text
)
;
if
(
anySanitized
)
{
this
.
changedDeclarations
[
index
]
=
sanitizedText
;
}
return
sanitizedText
;
}
renameProperty
:
function
(
index
name
newName
)
{
this
.
completeInitialization
(
index
)
;
this
.
result
+
=
CSS
.
escape
(
newName
)
;
this
.
completeCopying
(
this
.
decl
.
colonOffsets
[
0
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
newName
}
)
;
}
setPropertyEnabled
:
function
(
index
name
isEnabled
)
{
this
.
completeInitialization
(
index
)
;
const
decl
=
this
.
decl
;
let
copyOffset
=
decl
.
offsets
[
1
]
;
if
(
isEnabled
)
{
const
commentStart
=
decl
.
commentOffsets
[
0
]
;
if
(
EMPTY_COMMENT_START_RX
.
test
(
this
.
result
.
substring
(
commentStart
)
)
)
{
this
.
result
=
this
.
result
.
substring
(
0
commentStart
)
;
}
else
{
this
.
result
+
=
"
*
/
"
;
}
const
commentNamePart
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
colonOffsets
[
1
]
)
;
this
.
result
+
=
unescapeCSSComment
(
commentNamePart
)
;
let
newText
=
this
.
inputString
.
substring
(
decl
.
colonOffsets
[
1
]
decl
.
offsets
[
1
]
)
;
newText
=
cssTrimRight
(
unescapeCSSComment
(
newText
)
)
;
this
.
result
+
=
this
.
sanitizeText
(
newText
index
)
+
"
;
"
;
const
trailingText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
1
]
)
;
if
(
EMPTY_COMMENT_END_RX
.
test
(
trailingText
)
)
{
copyOffset
=
decl
.
commentOffsets
[
1
]
;
}
else
{
this
.
result
+
=
"
/
*
"
;
}
}
else
{
const
declText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
offsets
[
1
]
)
;
this
.
result
+
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
declText
)
+
"
*
/
"
;
}
this
.
completeCopying
(
copyOffset
)
;
if
(
isEnabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
:
decl
.
value
}
)
;
}
else
{
this
.
modifications
.
push
(
{
type
:
"
remove
"
index
name
}
)
;
}
}
getDefaultIndentation
:
function
(
)
{
return
this
.
rule
.
parentStyleSheet
.
guessIndentation
(
)
;
}
async
internalCreateProperty
(
index
name
value
priority
enabled
)
{
this
.
completeInitialization
(
index
)
;
let
newIndentation
=
"
"
;
if
(
this
.
hasNewLine
)
{
if
(
this
.
declarations
.
length
>
0
)
{
newIndentation
=
this
.
getIndentation
(
this
.
inputString
this
.
declarations
[
0
]
.
offsets
[
0
]
)
;
}
else
if
(
this
.
defaultIndentation
)
{
newIndentation
=
this
.
defaultIndentation
;
}
else
{
newIndentation
=
await
this
.
getDefaultIndentation
(
)
;
}
}
this
.
maybeTerminateDecl
(
index
-
1
)
;
let
savedWhitespace
=
"
"
;
if
(
this
.
hasNewLine
)
{
const
wsOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
result
.
length
)
;
if
(
this
.
result
[
wsOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
wsOffset
]
=
=
=
"
\
n
"
)
{
savedWhitespace
=
this
.
result
.
substring
(
wsOffset
+
1
)
;
this
.
result
=
this
.
result
.
substring
(
0
wsOffset
+
1
)
;
}
}
let
newText
=
CSS
.
escape
(
name
)
+
"
:
"
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
newText
+
=
"
!
important
"
;
}
newText
+
=
"
;
"
;
if
(
!
enabled
)
{
newText
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
newText
)
+
"
*
/
"
;
}
this
.
result
+
=
newIndentation
+
newText
;
if
(
this
.
hasNewLine
)
{
this
.
result
+
=
"
\
n
"
;
}
this
.
result
+
=
savedWhitespace
;
if
(
this
.
decl
)
{
this
.
completeCopying
(
this
.
decl
.
offsets
[
0
]
)
;
}
}
createProperty
:
function
(
index
name
value
priority
enabled
)
{
this
.
editPromise
=
this
.
internalCreateProperty
(
index
name
value
priority
enabled
)
;
if
(
enabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
}
setProperty
:
function
(
index
name
value
priority
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
this
.
createProperty
(
index
name
value
priority
true
)
;
return
;
}
this
.
result
+
=
this
.
inputString
.
substring
(
this
.
decl
.
offsets
[
0
]
this
.
decl
.
colonOffsets
[
1
]
)
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
this
.
result
+
=
"
!
important
"
;
}
this
.
result
+
=
"
;
"
;
this
.
completeCopying
(
this
.
decl
.
offsets
[
1
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
removeProperty
:
function
(
index
name
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
return
;
}
if
(
this
.
decl
.
commentOffsets
)
{
this
.
setPropertyEnabled
(
index
name
true
)
;
this
.
startInitialization
(
this
.
result
)
;
this
.
completeInitialization
(
index
)
;
}
let
copyOffset
=
this
.
decl
.
offsets
[
1
]
;
if
(
this
.
hasNewLine
)
{
const
nlOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
decl
.
offsets
[
0
]
)
;
if
(
nlOffset
<
0
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
n
"
)
{
const
trailingText
=
this
.
inputString
.
substring
(
copyOffset
)
;
const
match
=
BLANK_LINE_RX
.
exec
(
trailingText
)
;
if
(
match
)
{
this
.
result
=
this
.
result
.
substring
(
0
nlOffset
+
1
)
;
copyOffset
+
=
match
[
0
]
.
length
;
}
}
}
this
.
completeCopying
(
copyOffset
)
;
this
.
modifications
.
push
(
{
type
:
"
remove
"
index
name
}
)
;
}
completeCopying
:
function
(
copyOffset
)
{
this
.
result
+
=
this
.
inputString
.
substring
(
copyOffset
)
;
}
apply
:
function
(
)
{
return
promise
.
resolve
(
this
.
editPromise
)
.
then
(
(
)
=
>
{
return
this
.
rule
.
setRuleText
(
this
.
result
this
.
modifications
)
;
}
)
;
}
getResult
:
function
(
)
{
return
{
changed
:
this
.
changedDeclarations
text
:
this
.
result
}
;
}
}
;
function
parsePseudoClassesAndAttributes
(
value
)
{
if
(
!
value
)
{
throw
new
Error
(
"
empty
input
string
"
)
;
}
const
tokens
=
cssTokenizer
(
value
)
;
const
result
=
[
]
;
let
current
=
"
"
;
let
functionCount
=
0
;
let
hasAttribute
=
false
;
let
hasColon
=
false
;
for
(
const
token
of
tokens
)
{
if
(
token
.
tokenType
=
=
=
"
ident
"
)
{
current
+
=
value
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
hasColon
&
&
!
functionCount
)
{
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_PSEUDO_CLASS
}
)
;
}
current
=
"
"
;
hasColon
=
false
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
:
"
)
{
if
(
!
hasColon
)
{
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_ELEMENT
}
)
;
}
current
=
"
"
;
hasColon
=
true
;
}
current
+
=
token
.
text
;
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
current
+
=
value
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
functionCount
+
+
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
current
+
=
token
.
text
;
if
(
hasColon
&
&
functionCount
=
=
1
)
{
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_PSEUDO_CLASS
}
)
;
}
current
=
"
"
;
functionCount
-
-
;
hasColon
=
false
;
}
else
{
functionCount
-
-
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
[
"
)
{
if
(
!
hasAttribute
&
&
!
functionCount
)
{
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_ELEMENT
}
)
;
}
current
=
"
"
;
hasAttribute
=
true
;
}
current
+
=
token
.
text
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
]
"
)
{
current
+
=
token
.
text
;
if
(
hasAttribute
&
&
!
functionCount
)
{
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_ATTRIBUTE
}
)
;
}
current
=
"
"
;
hasAttribute
=
false
;
}
}
else
{
current
+
=
value
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
}
if
(
current
)
{
result
.
push
(
{
value
:
current
type
:
SELECTOR_ELEMENT
}
)
;
}
return
result
;
}
function
parseSingleValue
(
isCssPropertyKnown
value
)
{
const
declaration
=
parseDeclarations
(
isCssPropertyKnown
"
a
:
"
+
value
+
"
;
"
)
[
0
]
;
return
{
value
:
declaration
?
declaration
.
value
:
"
"
priority
:
declaration
?
declaration
.
priority
:
"
"
}
;
}
function
getAngleValueInDegrees
(
angleValue
angleUnit
)
{
switch
(
angleUnit
)
{
case
CSS_ANGLEUNIT
.
deg
:
return
angleValue
;
case
CSS_ANGLEUNIT
.
grad
:
return
angleValue
*
0
.
9
;
case
CSS_ANGLEUNIT
.
rad
:
return
angleValue
*
180
/
Math
.
PI
;
case
CSS_ANGLEUNIT
.
turn
:
return
angleValue
*
360
;
default
:
throw
new
Error
(
"
No
matched
angle
unit
.
"
)
;
}
}
exports
.
cssTokenizer
=
cssTokenizer
;
exports
.
cssTokenizerWithLineColumn
=
cssTokenizerWithLineColumn
;
exports
.
escapeCSSComment
=
escapeCSSComment
;
exports
.
_unescapeCSSComment
=
unescapeCSSComment
;
exports
.
parseDeclarations
=
parseDeclarations
;
exports
.
parseNamedDeclarations
=
parseNamedDeclarations
;
exports
.
_parseCommentDeclarations
=
parseCommentDeclarations
;
exports
.
RuleRewriter
=
RuleRewriter
;
exports
.
parsePseudoClassesAndAttributes
=
parsePseudoClassesAndAttributes
;
exports
.
parseSingleValue
=
parseSingleValue
;
exports
.
getAngleValueInDegrees
=
getAngleValueInDegrees
;
