"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
client
=
require
(
"
.
/
adb
-
client
"
)
;
const
{
dumpn
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
getFileForBinary
}
=
require
(
"
.
/
adb
-
binary
"
)
;
const
{
setTimeout
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
Services
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
check
"
"
devtools
/
shared
/
adb
/
adb
-
running
-
checker
"
true
)
;
let
ready
=
false
;
let
didRunInitially
=
false
;
const
OKAY
=
0x59414b4f
;
const
ADB
=
{
get
didRunInitially
(
)
{
return
didRunInitially
;
}
set
didRunInitially
(
newVal
)
{
didRunInitially
=
newVal
;
}
get
ready
(
)
{
return
ready
;
}
set
ready
(
newVal
)
{
ready
=
newVal
;
}
get
adbFilePromise
(
)
{
if
(
this
.
_adbFilePromise
)
{
return
this
.
_adbFilePromise
;
}
this
.
_adbFilePromise
=
getFileForBinary
(
)
;
return
this
.
_adbFilePromise
;
}
async
_runProcess
(
process
params
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
process
.
runAsync
(
params
params
.
length
{
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
process
-
finished
"
:
resolve
(
)
;
break
;
case
"
process
-
failed
"
:
reject
(
)
;
break
;
}
}
}
false
)
;
}
)
;
}
async
_waitUntil
(
predicate
retry
=
20
)
{
let
count
=
0
;
while
(
count
+
+
<
retry
)
{
if
(
await
predicate
(
)
)
{
return
true
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
}
return
false
;
}
async
start
(
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
const
onSuccessfulStart
=
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
adb
-
ready
"
)
;
this
.
ready
=
true
;
resolve
(
)
;
}
;
const
isAdbRunning
=
await
check
(
)
;
if
(
isAdbRunning
)
{
this
.
didRunInitially
=
false
;
dumpn
(
"
Found
ADB
process
running
not
restarting
"
)
;
onSuccessfulStart
(
)
;
return
;
}
dumpn
(
"
Didn
'
t
find
ADB
process
running
restarting
"
)
;
this
.
didRunInitially
=
true
;
const
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
const
adbFile
=
await
this
.
adbFilePromise
;
process
.
init
(
adbFile
)
;
process
.
startHidden
=
true
;
process
.
noShell
=
true
;
const
params
=
[
"
start
-
server
"
]
;
let
isStarted
=
false
;
try
{
await
this
.
_runProcess
(
process
params
)
;
isStarted
=
await
this
.
_waitUntil
(
check
)
;
}
catch
(
e
)
{
}
if
(
isStarted
)
{
onSuccessfulStart
(
)
;
}
else
{
this
.
ready
=
false
;
reject
(
)
;
}
}
)
;
}
async
stop
(
)
{
if
(
!
this
.
didRunInitially
)
{
return
;
}
await
this
.
kill
(
)
;
}
async
kill
(
)
{
try
{
await
this
.
runCommand
(
"
host
:
kill
"
)
;
}
catch
(
e
)
{
dumpn
(
"
Failed
to
send
host
:
kill
command
"
)
;
}
dumpn
(
"
adb
server
was
terminated
by
host
:
kill
"
)
;
this
.
ready
=
false
;
this
.
didRunInitially
=
false
;
}
trackDevices
(
)
{
dumpn
(
"
trackDevices
"
)
;
const
socket
=
client
.
connect
(
)
;
let
waitForFirst
=
true
;
const
devices
=
{
}
;
socket
.
s
.
onopen
=
function
(
)
{
dumpn
(
"
trackDevices
onopen
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
start
"
)
;
const
req
=
client
.
createRequest
(
"
host
:
track
-
devices
"
)
;
socket
.
send
(
req
)
;
}
;
socket
.
s
.
onerror
=
function
(
event
)
{
dumpn
(
"
trackDevices
onerror
:
"
+
event
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
stop
"
)
;
}
;
socket
.
s
.
onclose
=
function
(
)
{
dumpn
(
"
trackDevices
onclose
"
)
;
for
(
const
dev
in
devices
)
{
devices
[
dev
]
=
false
;
EventEmitter
.
emit
(
ADB
"
device
-
disconnected
"
dev
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
stop
"
)
;
setTimeout
(
function
(
)
{
if
(
ADB
.
ready
)
{
ADB
.
start
(
)
.
then
(
function
(
)
{
ADB
.
trackDevices
(
)
;
}
)
;
}
}
2000
)
;
}
;
socket
.
s
.
ondata
=
function
(
event
)
{
dumpn
(
"
trackDevices
ondata
"
)
;
const
data
=
event
.
data
;
dumpn
(
"
length
=
"
+
data
.
byteLength
)
;
const
dec
=
new
TextDecoder
(
)
;
dumpn
(
dec
.
decode
(
new
Uint8Array
(
data
)
)
.
trim
(
)
)
;
if
(
waitForFirst
)
{
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
socket
.
close
(
)
;
return
;
}
}
const
packet
=
client
.
unpackPacket
(
data
!
waitForFirst
)
;
waitForFirst
=
false
;
if
(
packet
.
data
=
=
"
"
)
{
for
(
const
dev
in
devices
)
{
devices
[
dev
]
=
false
;
EventEmitter
.
emit
(
ADB
"
device
-
disconnected
"
dev
)
;
}
}
else
{
const
lines
=
packet
.
data
.
split
(
"
\
n
"
)
;
const
newDev
=
{
}
;
lines
.
forEach
(
function
(
line
)
{
if
(
line
.
length
=
=
0
)
{
return
;
}
const
[
dev
status
]
=
line
.
split
(
"
\
t
"
)
;
newDev
[
dev
]
=
status
!
=
=
"
offline
"
;
}
)
;
for
(
const
dev
in
newDev
)
{
if
(
devices
[
dev
]
!
=
newDev
[
dev
]
)
{
if
(
dev
in
devices
|
|
newDev
[
dev
]
)
{
const
topic
=
newDev
[
dev
]
?
"
device
-
connected
"
:
"
device
-
disconnected
"
;
EventEmitter
.
emit
(
ADB
topic
dev
)
;
}
devices
[
dev
]
=
newDev
[
dev
]
;
}
}
}
}
;
}
listDevices
(
)
{
dumpn
(
"
listDevices
"
)
;
return
this
.
runCommand
(
"
host
:
devices
"
)
.
then
(
function
onSuccess
(
data
)
{
const
lines
=
data
.
split
(
"
\
n
"
)
;
const
res
=
[
]
;
lines
.
forEach
(
function
(
line
)
{
if
(
line
.
length
=
=
0
)
{
return
;
}
const
[
device
]
=
line
.
split
(
"
\
t
"
)
;
res
.
push
(
device
)
;
}
)
;
return
res
;
}
)
;
}
forwardPort
(
localPort
devicePort
)
{
dumpn
(
"
forwardPort
"
+
localPort
+
"
-
-
"
+
devicePort
)
;
return
this
.
runCommand
(
"
host
:
forward
:
"
+
localPort
+
"
;
"
+
devicePort
)
.
then
(
function
onSuccess
(
data
)
{
return
data
;
}
)
;
}
async
shell
(
command
)
{
let
state
;
let
stdout
=
"
"
;
dumpn
(
"
shell
"
+
command
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
shutdown
=
function
(
)
{
dumpn
(
"
shell
shutdown
"
)
;
socket
.
close
(
)
;
reject
(
"
BAD_RESPONSE
"
)
;
}
;
const
runFSM
=
function
runFSM
(
data
)
{
dumpn
(
"
runFSM
"
+
state
)
;
let
req
;
let
ignoreResponseCode
=
false
;
switch
(
state
)
{
case
"
start
"
:
state
=
"
send
-
transport
"
;
runFSM
(
)
;
break
;
case
"
send
-
transport
"
:
req
=
client
.
createRequest
(
"
host
:
transport
-
any
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
transport
"
;
break
;
case
"
wait
-
transport
"
:
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
shutdown
(
)
;
return
;
}
state
=
"
send
-
shell
"
;
runFSM
(
)
;
break
;
case
"
send
-
shell
"
:
req
=
client
.
createRequest
(
"
shell
:
"
+
command
)
;
socket
.
send
(
req
)
;
state
=
"
rec
-
shell
"
;
break
;
case
"
rec
-
shell
"
:
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
shutdown
(
)
;
return
;
}
state
=
"
decode
-
shell
"
;
if
(
client
.
getBuffer
(
data
)
.
byteLength
=
=
4
)
{
break
;
}
ignoreResponseCode
=
true
;
case
"
decode
-
shell
"
:
const
decoder
=
new
TextDecoder
(
)
;
const
text
=
new
Uint8Array
(
client
.
getBuffer
(
data
)
ignoreResponseCode
?
4
:
0
)
;
stdout
+
=
decoder
.
decode
(
text
)
;
break
;
default
:
dumpn
(
"
shell
Unexpected
State
:
"
+
state
)
;
reject
(
"
UNEXPECTED_STATE
"
)
;
}
}
;
const
socket
=
client
.
connect
(
)
;
socket
.
s
.
onerror
=
function
(
event
)
{
dumpn
(
"
shell
onerror
"
)
;
reject
(
"
SOCKET_ERROR
"
)
;
}
;
socket
.
s
.
onopen
=
function
(
event
)
{
dumpn
(
"
shell
onopen
"
)
;
state
=
"
start
"
;
runFSM
(
)
;
}
;
socket
.
s
.
onclose
=
function
(
event
)
{
resolve
(
stdout
)
;
dumpn
(
"
shell
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
event
)
{
dumpn
(
"
shell
ondata
"
)
;
runFSM
(
event
.
data
)
;
}
;
}
)
;
}
runCommand
(
command
)
{
dumpn
(
"
runCommand
"
+
command
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
!
this
.
ready
)
{
setTimeout
(
function
(
)
{
reject
(
"
ADB_NOT_READY
"
)
;
}
)
;
return
;
}
const
socket
=
client
.
connect
(
)
;
socket
.
s
.
onopen
=
function
(
)
{
dumpn
(
"
runCommand
onopen
"
)
;
const
req
=
client
.
createRequest
(
command
)
;
socket
.
send
(
req
)
;
}
;
socket
.
s
.
onerror
=
function
(
)
{
dumpn
(
"
runCommand
onerror
"
)
;
reject
(
"
NETWORK_ERROR
"
)
;
}
;
socket
.
s
.
onclose
=
function
(
)
{
dumpn
(
"
runCommand
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
event
)
{
dumpn
(
"
runCommand
ondata
"
)
;
const
data
=
event
.
data
;
const
packet
=
client
.
unpackPacket
(
data
false
)
;
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
socket
.
close
(
)
;
dumpn
(
"
Error
:
"
+
packet
.
data
)
;
reject
(
"
PROTOCOL_ERROR
"
)
;
return
;
}
resolve
(
packet
.
data
)
;
}
;
}
)
;
}
}
;
exports
.
ADB
=
ADB
;
