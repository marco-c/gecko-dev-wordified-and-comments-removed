"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
client
=
require
(
"
.
/
adb
-
client
"
)
;
const
{
getFileForBinary
}
=
require
(
"
.
/
adb
-
binary
"
)
;
const
{
setTimeout
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
PromiseUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
Services
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
check
"
"
devtools
/
shared
/
adb
/
adb
-
running
-
checker
"
true
)
;
let
ready
=
false
;
let
didRunInitially
=
false
;
const
OKAY
=
0x59414b4f
;
const
DATA
=
0x41544144
;
const
DONE
=
0x454e4f44
;
const
ADB
=
{
get
didRunInitially
(
)
{
return
didRunInitially
;
}
set
didRunInitially
(
newVal
)
{
didRunInitially
=
newVal
;
}
get
ready
(
)
{
return
ready
;
}
set
ready
(
newVal
)
{
ready
=
newVal
;
}
get
adbFilePromise
(
)
{
if
(
this
.
_adbFilePromise
)
{
return
this
.
_adbFilePromise
;
}
this
.
_adbFilePromise
=
getFileForBinary
(
)
;
return
this
.
_adbFilePromise
;
}
start
(
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
let
onSuccessfulStart
=
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
adb
-
ready
"
)
;
this
.
ready
=
true
;
resolve
(
)
;
}
;
let
isAdbRunning
=
await
check
(
)
;
if
(
isAdbRunning
)
{
this
.
didRunInitially
=
false
;
console
.
log
(
"
Found
ADB
process
running
not
restarting
"
)
;
onSuccessfulStart
(
)
;
return
;
}
console
.
log
(
"
Didn
'
t
find
ADB
process
running
restarting
"
)
;
this
.
didRunInitially
=
true
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
adbFile
=
await
this
.
adbFilePromise
;
process
.
init
(
adbFile
)
;
try
{
process
.
startHidden
=
true
;
process
.
noShell
=
true
;
}
catch
(
e
)
{
}
let
params
=
[
"
start
-
server
"
]
;
let
self
=
this
;
process
.
runAsync
(
params
params
.
length
{
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
process
-
finished
"
:
onSuccessfulStart
(
)
;
break
;
case
"
process
-
failed
"
:
self
.
ready
=
false
;
reject
(
)
;
break
;
}
}
}
false
)
;
}
)
;
}
async
stop
(
sync
)
{
if
(
!
this
.
didRunInitially
)
{
return
;
}
await
this
.
kill
(
sync
)
;
while
(
true
)
{
const
isAdbRunning
=
await
check
(
)
;
if
(
!
isAdbRunning
)
{
break
;
}
}
}
async
kill
(
sync
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
adbFile
=
await
this
.
adbFilePromise
;
process
.
init
(
adbFile
)
;
try
{
process
.
startHidden
=
true
;
process
.
noShell
=
true
;
}
catch
(
e
)
{
}
let
params
=
[
"
kill
-
server
"
]
;
if
(
sync
)
{
process
.
run
(
true
params
params
.
length
)
;
console
.
log
(
"
adb
kill
-
server
:
"
+
process
.
exitValue
)
;
this
.
ready
=
false
;
this
.
didRunInitially
=
false
;
}
else
{
let
self
=
this
;
process
.
runAsync
(
params
params
.
length
{
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
process
-
finished
"
:
console
.
log
(
"
adb
kill
-
server
:
"
+
process
.
exitValue
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
killed
"
)
;
self
.
ready
=
false
;
self
.
didRunInitially
=
false
;
break
;
case
"
process
-
failed
"
:
console
.
log
(
"
adb
kill
-
server
failure
:
"
+
process
.
exitValue
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
killed
"
)
;
self
.
ready
=
false
;
self
.
didRunInitially
=
false
;
break
;
}
}
}
false
)
;
}
}
trackDevices
:
function
adb_trackDevices
(
)
{
console
.
log
(
"
trackDevices
"
)
;
let
socket
=
client
.
connect
(
)
;
let
waitForFirst
=
true
;
let
devices
=
{
}
;
socket
.
s
.
onopen
=
function
(
)
{
console
.
log
(
"
trackDevices
onopen
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
start
"
)
;
let
req
=
client
.
createRequest
(
"
host
:
track
-
devices
"
)
;
socket
.
send
(
req
)
;
}
;
socket
.
s
.
onerror
=
function
(
event
)
{
console
.
log
(
"
trackDevices
onerror
:
"
+
event
)
;
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
stop
"
)
;
}
;
socket
.
s
.
onclose
=
function
(
)
{
console
.
log
(
"
trackDevices
onclose
"
)
;
for
(
let
dev
in
devices
)
{
devices
[
dev
]
=
false
;
EventEmitter
.
emit
(
ADB
"
device
-
disconnected
"
dev
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
adb
-
track
-
devices
-
stop
"
)
;
setTimeout
(
function
(
)
{
if
(
ADB
.
ready
)
{
ADB
.
start
(
)
.
then
(
function
(
)
{
ADB
.
trackDevices
(
)
;
}
)
;
}
}
2000
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
trackDevices
ondata
"
)
;
let
data
=
aEvent
.
data
;
console
.
log
(
"
length
=
"
+
data
.
byteLength
)
;
let
dec
=
new
TextDecoder
(
)
;
console
.
log
(
dec
.
decode
(
new
Uint8Array
(
data
)
)
.
trim
(
)
)
;
if
(
waitForFirst
)
{
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
socket
.
close
(
)
;
return
;
}
}
let
packet
=
client
.
unpackPacket
(
data
!
waitForFirst
)
;
waitForFirst
=
false
;
if
(
packet
.
data
=
=
"
"
)
{
for
(
let
dev
in
devices
)
{
devices
[
dev
]
=
false
;
EventEmitter
.
emit
(
ADB
"
device
-
disconnected
"
dev
)
;
}
}
else
{
let
lines
=
packet
.
data
.
split
(
"
\
n
"
)
;
let
newDev
=
{
}
;
lines
.
forEach
(
function
(
aLine
)
{
if
(
aLine
.
length
=
=
0
)
{
return
;
}
let
[
dev
status
]
=
aLine
.
split
(
"
\
t
"
)
;
newDev
[
dev
]
=
status
!
=
=
"
offline
"
;
}
)
;
for
(
let
dev
in
newDev
)
{
if
(
devices
[
dev
]
!
=
newDev
[
dev
]
)
{
if
(
dev
in
devices
|
|
newDev
[
dev
]
)
{
let
topic
=
newDev
[
dev
]
?
"
device
-
connected
"
:
"
device
-
disconnected
"
;
EventEmitter
.
emit
(
ADB
topic
dev
)
;
}
devices
[
dev
]
=
newDev
[
dev
]
;
}
}
}
}
;
}
listDevices
:
function
adb_listDevices
(
)
{
console
.
log
(
"
listDevices
"
)
;
return
this
.
runCommand
(
"
host
:
devices
"
)
.
then
(
function
onSuccess
(
data
)
{
let
lines
=
data
.
split
(
"
\
n
"
)
;
let
res
=
[
]
;
lines
.
forEach
(
function
(
aLine
)
{
if
(
aLine
.
length
=
=
0
)
{
return
;
}
let
[
device
]
=
aLine
.
split
(
"
\
t
"
)
;
res
.
push
(
device
)
;
}
)
;
return
res
;
}
)
;
}
forwardPort
:
function
adb_forwardPort
(
aLocalPort
aDevicePort
)
{
console
.
log
(
"
forwardPort
"
+
aLocalPort
+
"
-
-
"
+
aDevicePort
)
;
return
this
.
runCommand
(
"
host
:
forward
:
"
+
aLocalPort
+
"
;
"
+
aDevicePort
)
.
then
(
function
onSuccess
(
data
)
{
return
data
;
}
)
;
}
pull
:
function
adb_pull
(
aFrom
aDest
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
socket
;
let
state
;
let
fileData
=
null
;
let
currentPos
=
0
;
let
chunkSize
=
0
;
let
pkgData
;
let
headerArray
=
new
Uint32Array
(
2
)
;
let
currentHeaderLength
=
0
;
let
encoder
=
new
TextEncoder
(
)
;
let
infoLengthPacket
;
console
.
log
(
"
pulling
"
+
aFrom
+
"
-
>
"
+
aDest
)
;
let
shutdown
=
function
(
)
{
console
.
log
(
"
pull
shutdown
"
)
;
socket
.
close
(
)
;
deferred
.
reject
(
"
BAD_RESPONSE
"
)
;
}
;
let
extractChunkDataHeader
=
function
(
data
)
{
let
tmpArray
=
new
Uint8Array
(
headerArray
.
buffer
)
;
for
(
let
i
=
0
;
i
<
8
-
currentHeaderLength
;
i
+
+
)
{
tmpArray
[
currentHeaderLength
+
i
]
=
data
[
i
]
;
}
}
;
let
checkChunkDataHeader
=
function
(
data
)
{
if
(
data
.
length
+
currentHeaderLength
>
=
8
)
{
extractChunkDataHeader
(
data
)
;
if
(
headerArray
[
0
]
!
=
DATA
)
{
shutdown
(
)
;
return
false
;
}
pkgData
=
data
.
subarray
(
8
-
currentHeaderLength
data
.
length
)
;
chunkSize
=
headerArray
[
1
]
;
currentHeaderLength
=
0
;
return
true
;
}
let
tmpArray
=
new
Uint8Array
(
headerArray
.
buffer
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
tmpArray
[
currentHeaderLength
+
i
]
=
data
[
i
]
;
}
currentHeaderLength
+
=
data
.
length
;
return
true
;
}
;
let
checkDone
=
function
(
data
)
{
if
(
data
.
length
!
=
8
)
{
return
false
;
}
let
doneFlagArray
=
new
Uint32Array
(
1
)
;
let
tmpArray
=
new
Uint8Array
(
doneFlagArray
.
buffer
)
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
tmpArray
[
i
]
=
data
[
i
]
;
}
if
(
doneFlagArray
[
0
]
=
=
DONE
)
{
return
true
;
}
return
false
;
}
;
let
runFSM
=
function
runFSM
(
aData
)
{
console
.
log
(
"
runFSM
"
+
state
)
;
let
req
;
switch
(
state
)
{
case
"
start
"
:
state
=
"
send
-
transport
"
;
runFSM
(
)
;
break
;
case
"
send
-
transport
"
:
req
=
client
.
createRequest
(
"
host
:
transport
-
any
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
transport
"
;
break
;
case
"
wait
-
transport
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
console
.
log
(
"
transport
:
OK
"
)
;
state
=
"
send
-
sync
"
;
runFSM
(
)
;
break
;
case
"
send
-
sync
"
:
req
=
client
.
createRequest
(
"
sync
:
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
sync
"
;
break
;
case
"
wait
-
sync
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
console
.
log
(
"
sync
:
OK
"
)
;
state
=
"
send
-
recv
"
;
runFSM
(
)
;
break
;
case
"
send
-
recv
"
:
infoLengthPacket
=
new
Uint32Array
(
1
)
;
infoLengthPacket
[
0
]
=
aFrom
.
length
;
socket
.
send
(
encoder
.
encode
(
"
RECV
"
)
)
;
socket
.
send
(
infoLengthPacket
)
;
socket
.
send
(
encoder
.
encode
(
aFrom
)
)
;
state
=
"
wait
-
recv
"
;
break
;
case
"
wait
-
recv
"
:
pkgData
=
new
Uint8Array
(
client
.
getBuffer
(
aData
)
)
;
while
(
pkgData
.
length
>
0
)
{
if
(
chunkSize
=
=
0
&
&
checkDone
(
pkgData
)
)
{
OS
.
File
.
writeAtomic
(
aDest
fileData
{
}
)
.
then
(
function
onSuccess
(
number
)
{
console
.
log
(
number
)
;
deferred
.
resolve
(
"
SUCCESS
"
)
;
}
function
onFailure
(
reason
)
{
console
.
log
(
reason
)
;
deferred
.
reject
(
"
CANT_ACCESS_FILE
"
)
;
}
)
;
state
=
"
send
-
quit
"
;
runFSM
(
)
;
return
;
}
if
(
chunkSize
=
=
0
&
&
!
checkChunkDataHeader
(
pkgData
)
)
{
shutdown
(
)
;
return
;
}
if
(
chunkSize
>
0
&
&
pkgData
.
length
>
=
chunkSize
)
{
let
chunkData
=
pkgData
.
subarray
(
0
chunkSize
)
;
let
tmpData
=
new
Uint8Array
(
currentPos
+
chunkSize
)
;
if
(
fileData
)
{
tmpData
.
set
(
fileData
0
)
;
}
tmpData
.
set
(
chunkData
currentPos
)
;
fileData
=
tmpData
;
pkgData
=
pkgData
.
subarray
(
chunkSize
pkgData
.
length
)
;
currentPos
+
=
chunkSize
;
chunkSize
=
0
;
}
if
(
chunkSize
>
0
&
&
pkgData
.
length
>
0
&
&
pkgData
.
length
<
chunkSize
)
{
let
tmpData
=
new
Uint8Array
(
currentPos
+
pkgData
.
length
)
;
if
(
fileData
)
{
tmpData
.
set
(
fileData
0
)
;
}
tmpData
.
set
(
pkgData
currentPos
)
;
fileData
=
tmpData
;
currentPos
+
=
pkgData
.
length
;
chunkSize
-
=
pkgData
.
length
;
break
;
}
}
break
;
case
"
send
-
quit
"
:
infoLengthPacket
=
new
Uint32Array
(
1
)
;
infoLengthPacket
[
0
]
=
0
;
socket
.
send
(
encoder
.
encode
(
"
QUIT
"
)
)
;
socket
.
send
(
infoLengthPacket
)
;
state
=
"
end
"
;
runFSM
(
)
;
break
;
case
"
end
"
:
socket
.
close
(
)
;
break
;
default
:
console
.
log
(
"
pull
Unexpected
State
:
"
+
state
)
;
deferred
.
reject
(
"
UNEXPECTED_STATE
"
)
;
}
}
;
let
setupSocket
=
function
(
)
{
socket
.
s
.
onerror
=
function
(
aEvent
)
{
console
.
log
(
"
pull
onerror
"
)
;
deferred
.
reject
(
"
SOCKET_ERROR
"
)
;
}
;
socket
.
s
.
onopen
=
function
(
aEvent
)
{
console
.
log
(
"
pull
onopen
"
)
;
state
=
"
start
"
;
runFSM
(
)
;
}
;
socket
.
s
.
onclose
=
function
(
aEvent
)
{
console
.
log
(
"
pull
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
pull
ondata
:
"
)
;
runFSM
(
aEvent
.
data
)
;
}
;
}
;
socket
=
client
.
connect
(
)
;
setupSocket
(
)
;
return
deferred
.
promise
;
}
push
:
function
adb_push
(
aFrom
aDest
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
socket
;
let
state
;
let
fileSize
;
let
fileData
;
let
remaining
;
let
currentPos
=
0
;
let
fileTime
;
console
.
log
(
"
pushing
"
+
aFrom
+
"
-
>
"
+
aDest
)
;
let
shutdown
=
function
(
)
{
console
.
log
(
"
push
shutdown
"
)
;
socket
.
close
(
)
;
deferred
.
reject
(
"
BAD_RESPONSE
"
)
;
}
;
let
runFSM
=
function
runFSM
(
aData
)
{
console
.
log
(
"
runFSM
"
+
state
)
;
let
req
;
switch
(
state
)
{
case
"
start
"
:
state
=
"
send
-
transport
"
;
runFSM
(
)
;
break
;
case
"
send
-
transport
"
:
req
=
client
.
createRequest
(
"
host
:
transport
-
any
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
transport
"
;
break
;
case
"
wait
-
transport
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
console
.
log
(
"
transport
:
OK
"
)
;
state
=
"
send
-
sync
"
;
runFSM
(
)
;
break
;
case
"
send
-
sync
"
:
req
=
client
.
createRequest
(
"
sync
:
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
sync
"
;
break
;
case
"
wait
-
sync
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
console
.
log
(
"
sync
:
OK
"
)
;
state
=
"
send
-
send
"
;
runFSM
(
)
;
break
;
case
"
send
-
send
"
:
let
encoder
=
new
TextEncoder
(
)
;
let
infoLengthPacket
=
new
Uint32Array
(
1
)
info
=
aDest
+
"
33204
"
;
infoLengthPacket
[
0
]
=
info
.
length
;
socket
.
send
(
encoder
.
encode
(
"
SEND
"
)
)
;
socket
.
send
(
infoLengthPacket
)
;
socket
.
send
(
encoder
.
encode
(
info
)
)
;
while
(
remaining
>
0
)
{
let
toSend
=
remaining
>
65536
?
65536
:
remaining
;
console
.
log
(
"
Sending
"
+
toSend
+
"
bytes
"
)
;
let
dataLengthPacket
=
new
Uint32Array
(
1
)
;
let
dataPacket
=
new
Uint8Array
(
new
ArrayBuffer
(
toSend
)
)
;
dataPacket
.
set
(
new
Uint8Array
(
fileData
.
buffer
currentPos
toSend
)
)
;
dataLengthPacket
[
0
]
=
toSend
;
socket
.
send
(
encoder
.
encode
(
"
DATA
"
)
)
;
socket
.
send
(
dataLengthPacket
)
;
socket
.
send
(
dataPacket
)
;
currentPos
+
=
toSend
;
remaining
-
=
toSend
;
}
let
fileTimePacket
=
new
Uint32Array
(
1
)
;
fileTimePacket
[
0
]
=
fileTime
;
socket
.
send
(
encoder
.
encode
(
"
DONE
"
)
)
;
socket
.
send
(
fileTimePacket
)
;
state
=
"
wait
-
done
"
;
break
;
case
"
wait
-
done
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
console
.
log
(
"
DONE
:
OK
"
)
;
state
=
"
end
"
;
runFSM
(
)
;
break
;
case
"
end
"
:
socket
.
close
(
)
;
deferred
.
resolve
(
"
SUCCESS
"
)
;
break
;
default
:
console
.
log
(
"
push
Unexpected
State
:
"
+
state
)
;
deferred
.
reject
(
"
UNEXPECTED_STATE
"
)
;
}
}
;
let
setupSocket
=
function
(
)
{
socket
.
s
.
onerror
=
function
(
aEvent
)
{
console
.
log
(
"
push
onerror
"
)
;
deferred
.
reject
(
"
SOCKET_ERROR
"
)
;
}
;
socket
.
s
.
onopen
=
function
(
aEvent
)
{
console
.
log
(
"
push
onopen
"
)
;
state
=
"
start
"
;
runFSM
(
)
;
}
;
socket
.
s
.
onclose
=
function
(
aEvent
)
{
console
.
log
(
"
push
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
push
ondata
"
)
;
runFSM
(
aEvent
.
data
)
;
}
;
}
;
OS
.
File
.
stat
(
aFrom
)
.
then
(
function
onSuccess
(
stat
)
{
if
(
stat
.
isDir
)
{
deferred
.
reject
(
"
CANT_PUSH_DIR
"
)
;
}
else
{
fileSize
=
stat
.
size
;
fileTime
=
stat
.
lastModificationDate
.
getTime
(
)
/
1000
;
remaining
=
fileSize
;
console
.
log
(
aFrom
+
"
size
is
"
+
fileSize
)
;
let
readPromise
=
OS
.
File
.
read
(
aFrom
)
;
readPromise
.
then
(
function
readSuccess
(
aData
)
{
fileData
=
aData
;
socket
=
client
.
connect
(
)
;
setupSocket
(
)
;
}
function
readError
(
)
{
deferred
.
reject
(
"
READ_FAILED
"
)
;
}
)
;
}
}
function
onFailure
(
reason
)
{
console
.
log
(
reason
)
;
deferred
.
reject
(
"
CANT_ACCESS_FILE
"
)
;
}
)
;
return
deferred
.
promise
;
}
shell
:
function
adb_shell
(
aCommand
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
socket
;
let
state
;
let
stdout
=
"
"
;
console
.
log
(
"
shell
"
+
aCommand
)
;
let
shutdown
=
function
(
)
{
console
.
log
(
"
shell
shutdown
"
)
;
socket
.
close
(
)
;
deferred
.
reject
(
"
BAD_RESPONSE
"
)
;
}
;
let
runFSM
=
function
runFSM
(
aData
)
{
console
.
log
(
"
runFSM
"
+
state
)
;
let
req
;
let
ignoreResponseCode
=
false
;
switch
(
state
)
{
case
"
start
"
:
state
=
"
send
-
transport
"
;
runFSM
(
)
;
break
;
case
"
send
-
transport
"
:
req
=
client
.
createRequest
(
"
host
:
transport
-
any
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
transport
"
;
break
;
case
"
wait
-
transport
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
state
=
"
send
-
shell
"
;
runFSM
(
)
;
break
;
case
"
send
-
shell
"
:
req
=
client
.
createRequest
(
"
shell
:
"
+
aCommand
)
;
socket
.
send
(
req
)
;
state
=
"
rec
-
shell
"
;
break
;
case
"
rec
-
shell
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
state
=
"
decode
-
shell
"
;
if
(
client
.
getBuffer
(
aData
)
.
byteLength
=
=
4
)
{
break
;
}
ignoreResponseCode
=
true
;
case
"
decode
-
shell
"
:
let
decoder
=
new
TextDecoder
(
)
;
let
text
=
new
Uint8Array
(
client
.
getBuffer
(
aData
)
ignoreResponseCode
?
4
:
0
)
;
stdout
+
=
decoder
.
decode
(
text
)
;
break
;
default
:
console
.
log
(
"
shell
Unexpected
State
:
"
+
state
)
;
deferred
.
reject
(
"
UNEXPECTED_STATE
"
)
;
}
}
;
socket
=
client
.
connect
(
)
;
socket
.
s
.
onerror
=
function
(
aEvent
)
{
console
.
log
(
"
shell
onerror
"
)
;
deferred
.
reject
(
"
SOCKET_ERROR
"
)
;
}
;
socket
.
s
.
onopen
=
function
(
aEvent
)
{
console
.
log
(
"
shell
onopen
"
)
;
state
=
"
start
"
;
runFSM
(
)
;
}
;
socket
.
s
.
onclose
=
function
(
aEvent
)
{
deferred
.
resolve
(
stdout
)
;
console
.
log
(
"
shell
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
shell
ondata
"
)
;
runFSM
(
aEvent
.
data
)
;
}
;
return
deferred
.
promise
;
}
reboot
:
function
adb_reboot
(
)
{
return
this
.
shell
(
"
reboot
"
)
;
}
rebootRecovery
:
function
adb_rebootRecovery
(
)
{
return
this
.
shell
(
"
reboot
recovery
"
)
;
}
rebootBootloader
:
function
adb_rebootBootloader
(
)
{
return
this
.
shell
(
"
reboot
bootloader
"
)
;
}
root
:
function
adb_root
(
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
socket
;
let
state
;
console
.
log
(
"
root
"
)
;
let
shutdown
=
function
(
)
{
console
.
log
(
"
root
shutdown
"
)
;
socket
.
close
(
)
;
deferred
.
reject
(
"
BAD_RESPONSE
"
)
;
}
;
let
runFSM
=
function
runFSM
(
aData
)
{
console
.
log
(
"
runFSM
"
+
state
)
;
let
req
;
switch
(
state
)
{
case
"
start
"
:
state
=
"
send
-
transport
"
;
runFSM
(
)
;
break
;
case
"
send
-
transport
"
:
req
=
client
.
createRequest
(
"
host
:
transport
-
any
"
)
;
socket
.
send
(
req
)
;
state
=
"
wait
-
transport
"
;
break
;
case
"
wait
-
transport
"
:
if
(
!
client
.
checkResponse
(
aData
OKAY
)
)
{
shutdown
(
)
;
return
;
}
state
=
"
send
-
root
"
;
runFSM
(
)
;
break
;
case
"
send
-
root
"
:
req
=
client
.
createRequest
(
"
root
:
"
)
;
socket
.
send
(
req
)
;
state
=
"
rec
-
root
"
;
break
;
case
"
rec
-
root
"
:
break
;
default
:
console
.
log
(
"
root
Unexpected
State
:
"
+
state
)
;
deferred
.
reject
(
"
UNEXPECTED_STATE
"
)
;
}
}
;
socket
=
client
.
connect
(
)
;
socket
.
s
.
onerror
=
function
(
aEvent
)
{
console
.
log
(
"
root
onerror
"
)
;
deferred
.
reject
(
"
SOCKET_ERROR
"
)
;
}
;
socket
.
s
.
onopen
=
function
(
aEvent
)
{
console
.
log
(
"
root
onopen
"
)
;
state
=
"
start
"
;
runFSM
(
)
;
}
;
socket
.
s
.
onclose
=
function
(
aEvent
)
{
deferred
.
resolve
(
)
;
console
.
log
(
"
root
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
root
ondata
"
)
;
runFSM
(
aEvent
.
data
)
;
}
;
return
deferred
.
promise
;
}
runCommand
:
function
adb_runCommand
(
aCommand
)
{
console
.
log
(
"
runCommand
"
+
aCommand
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
!
this
.
ready
)
{
setTimeout
(
function
(
)
{
deferred
.
reject
(
"
ADB_NOT_READY
"
)
;
}
)
;
return
deferred
.
promise
;
}
let
socket
=
client
.
connect
(
)
;
socket
.
s
.
onopen
=
function
(
)
{
console
.
log
(
"
runCommand
onopen
"
)
;
let
req
=
client
.
createRequest
(
aCommand
)
;
socket
.
send
(
req
)
;
}
;
socket
.
s
.
onerror
=
function
(
)
{
console
.
log
(
"
runCommand
onerror
"
)
;
deferred
.
reject
(
"
NETWORK_ERROR
"
)
;
}
;
socket
.
s
.
onclose
=
function
(
)
{
console
.
log
(
"
runCommand
onclose
"
)
;
}
;
socket
.
s
.
ondata
=
function
(
aEvent
)
{
console
.
log
(
"
runCommand
ondata
"
)
;
let
data
=
aEvent
.
data
;
let
packet
=
client
.
unpackPacket
(
data
false
)
;
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
socket
.
close
(
)
;
console
.
log
(
"
Error
:
"
+
packet
.
data
)
;
deferred
.
reject
(
"
PROTOCOL_ERROR
"
)
;
return
;
}
deferred
.
resolve
(
packet
.
data
)
;
}
;
return
deferred
.
promise
;
}
}
;
exports
.
ADB
=
ADB
;
