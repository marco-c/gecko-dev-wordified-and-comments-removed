"
use
strict
"
;
const
{
AddonManager
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
PREF_ADB_EXTENSION_URL
=
"
devtools
.
remote
.
adb
.
extensionURL
"
;
const
PREF_ADB_EXTENSION_ID
=
"
devtools
.
remote
.
adb
.
extensionID
"
;
const
ADB_HELPER_ADDON_ID
=
"
adbhelper
mozilla
.
org
"
;
const
VALENCE_ADDON_ID
=
"
fxdevtools
-
adapters
mozilla
.
org
"
;
const
ADB_ADDON_STATES
=
{
DOWNLOADING
:
"
downloading
"
INSTALLED
:
"
installed
"
INSTALLING
:
"
installing
"
PREPARING
:
"
preparing
"
UNINSTALLED
:
"
uninstalled
"
UNKNOWN
:
"
unknown
"
}
;
exports
.
ADB_ADDON_STATES
=
ADB_ADDON_STATES
;
class
ADBAddon
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
_status
=
ADB_ADDON_STATES
.
UNKNOWN
;
const
addonsListener
=
{
}
;
addonsListener
.
onEnabled
=
addonsListener
.
onDisabled
=
addonsListener
.
onInstalled
=
addonsListener
.
onUninstalled
=
(
)
=
>
this
.
updateInstallStatus
(
)
;
AddonManager
.
addAddonListener
(
addonsListener
)
;
this
.
updateInstallStatus
(
)
;
}
set
status
(
value
)
{
if
(
this
.
_status
!
=
value
)
{
this
.
_status
=
value
;
this
.
emit
(
"
update
"
)
;
}
}
get
status
(
)
{
return
this
.
_status
;
}
async
_getAddon
(
)
{
const
addonId
=
Services
.
prefs
.
getCharPref
(
PREF_ADB_EXTENSION_ID
)
;
return
AddonManager
.
getAddonByID
(
addonId
)
;
}
async
updateInstallStatus
(
)
{
const
addon
=
await
this
.
_getAddon
(
)
;
if
(
addon
&
&
!
addon
.
userDisabled
)
{
this
.
status
=
ADB_ADDON_STATES
.
INSTALLED
;
}
else
{
this
.
status
=
ADB_ADDON_STATES
.
UNINSTALLED
;
}
}
_getXpiLink
(
)
{
const
platform
=
Services
.
appShell
.
hiddenDOMWindow
.
navigator
.
platform
;
let
OS
=
"
"
;
if
(
platform
.
includes
(
"
Win
"
)
)
{
OS
=
"
win32
"
;
}
else
if
(
platform
.
includes
(
"
Mac
"
)
)
{
OS
=
"
mac64
"
;
}
else
if
(
platform
.
includes
(
"
Linux
"
)
)
{
if
(
platform
.
includes
(
"
x86_64
"
)
)
{
OS
=
"
linux64
"
;
}
else
{
OS
=
"
linux
"
;
}
}
const
xpiLink
=
Services
.
prefs
.
getCharPref
(
PREF_ADB_EXTENSION_URL
)
;
return
xpiLink
.
replace
(
/
#
OS
#
/
g
OS
)
;
}
async
install
(
source
)
{
if
(
!
source
)
{
throw
new
Error
(
"
Missing
mandatory
source
parameter
for
adb
-
addon
.
install
"
)
;
}
const
addon
=
await
this
.
_getAddon
(
)
;
if
(
addon
&
&
!
addon
.
userDisabled
)
{
this
.
status
=
ADB_ADDON_STATES
.
INSTALLED
;
return
;
}
this
.
status
=
ADB_ADDON_STATES
.
PREPARING
;
if
(
addon
&
&
addon
.
userDisabled
)
{
await
addon
.
enable
(
)
;
}
else
{
const
install
=
await
AddonManager
.
getInstallForURL
(
this
.
_getXpiLink
(
)
{
telemetryInfo
:
{
source
}
}
)
;
install
.
addListener
(
this
)
;
install
.
install
(
)
;
}
}
async
uninstall
(
)
{
const
addon
=
await
this
.
_getAddon
(
)
;
addon
.
uninstall
(
)
;
}
async
uninstallUnsupportedExtensions
(
)
{
const
[
adbHelperAddon
valenceAddon
]
=
await
Promise
.
all
(
[
AddonManager
.
getAddonByID
(
ADB_HELPER_ADDON_ID
)
AddonManager
.
getAddonByID
(
VALENCE_ADDON_ID
)
]
)
;
if
(
adbHelperAddon
)
{
adbHelperAddon
.
uninstall
(
)
;
}
if
(
valenceAddon
)
{
valenceAddon
.
uninstall
(
)
;
}
}
installFailureHandler
(
install
message
)
{
this
.
status
=
ADB_ADDON_STATES
.
UNINSTALLED
;
this
.
emit
(
"
failure
"
message
)
;
}
onDownloadStarted
(
)
{
this
.
status
=
ADB_ADDON_STATES
.
DOWNLOADING
;
}
onDownloadProgress
(
install
)
{
if
(
install
.
maxProgress
=
=
-
1
)
{
this
.
emit
(
"
progress
"
-
1
)
;
}
else
{
this
.
emit
(
"
progress
"
install
.
progress
/
install
.
maxProgress
)
;
}
}
onDownloadCancelled
(
install
)
{
this
.
installFailureHandler
(
install
"
Download
cancelled
"
)
;
}
onDownloadFailed
(
install
)
{
this
.
installFailureHandler
(
install
"
Download
failed
"
)
;
}
onInstallStarted
(
)
{
this
.
status
=
ADB_ADDON_STATES
.
INSTALLING
;
}
onInstallCancelled
(
install
)
{
this
.
installFailureHandler
(
install
"
Install
cancelled
"
)
;
}
onInstallFailed
(
install
)
{
this
.
installFailureHandler
(
install
"
Install
failed
"
)
;
}
onInstallEnded
(
{
addon
}
)
{
addon
.
enable
(
)
;
}
}
exports
.
adbAddon
=
new
ADBAddon
(
)
;
