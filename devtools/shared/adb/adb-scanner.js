"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
ConnectionManager
}
=
require
(
"
devtools
/
shared
/
client
/
connection
-
manager
"
)
;
const
{
Devices
}
=
require
(
"
devtools
/
shared
/
apps
/
Devices
.
jsm
"
)
;
const
{
RuntimeTypes
}
=
require
(
"
devtools
/
client
/
webide
/
modules
/
runtime
-
types
"
)
;
const
ADBScanner
=
{
_runtimes
:
[
]
enable
(
)
{
this
.
_updateRuntimes
=
this
.
_updateRuntimes
.
bind
(
this
)
;
Devices
.
on
(
"
register
"
this
.
_updateRuntimes
)
;
Devices
.
on
(
"
unregister
"
this
.
_updateRuntimes
)
;
Devices
.
on
(
"
addon
-
status
-
updated
"
this
.
_updateRuntimes
)
;
this
.
_updateRuntimes
(
)
;
}
disable
(
)
{
Devices
.
off
(
"
register
"
this
.
_updateRuntimes
)
;
Devices
.
off
(
"
unregister
"
this
.
_updateRuntimes
)
;
Devices
.
off
(
"
addon
-
status
-
updated
"
this
.
_updateRuntimes
)
;
}
_emitUpdated
(
)
{
this
.
emit
(
"
runtime
-
list
-
updated
"
)
;
}
_updateRuntimes
(
)
{
if
(
this
.
_updatingPromise
)
{
return
this
.
_updatingPromise
;
}
this
.
_runtimes
=
[
]
;
const
promises
=
[
]
;
for
(
const
id
of
Devices
.
available
(
)
)
{
const
device
=
Devices
.
getByName
(
id
)
;
promises
.
push
(
this
.
_detectRuntimes
(
device
)
)
;
}
this
.
_updatingPromise
=
Promise
.
all
(
promises
)
;
this
.
_updatingPromise
.
then
(
(
)
=
>
{
this
.
_emitUpdated
(
)
;
this
.
_updatingPromise
=
null
;
}
(
)
=
>
{
this
.
_updatingPromise
=
null
;
}
)
;
return
this
.
_updatingPromise
;
}
_detectRuntimes
:
async
function
(
device
)
{
const
model
=
await
device
.
getModel
(
)
;
let
detectedRuntimes
=
await
FirefoxOSRuntime
.
detect
(
device
model
)
;
this
.
_runtimes
.
push
(
.
.
.
detectedRuntimes
)
;
detectedRuntimes
=
await
FirefoxOnAndroidRuntime
.
detect
(
device
model
)
;
this
.
_runtimes
.
push
(
.
.
.
detectedRuntimes
)
;
}
scan
(
)
{
return
this
.
_updateRuntimes
(
)
;
}
listRuntimes
(
)
{
return
this
.
_runtimes
;
}
}
;
EventEmitter
.
decorate
(
ADBScanner
)
;
function
Runtime
(
device
model
socketPath
)
{
this
.
device
=
device
;
this
.
_model
=
model
;
this
.
_socketPath
=
socketPath
;
}
Runtime
.
prototype
=
{
type
:
RuntimeTypes
.
USB
connect
(
connection
)
{
const
port
=
ConnectionManager
.
getFreeTCPPort
(
)
;
const
local
=
"
tcp
:
"
+
port
;
let
remote
;
if
(
this
.
_socketPath
.
startsWith
(
"
"
)
)
{
remote
=
"
localabstract
:
"
+
this
.
_socketPath
.
substring
(
1
)
;
}
else
{
remote
=
"
localfilesystem
:
"
+
this
.
_socketPath
;
}
return
this
.
device
.
forwardPort
(
local
remote
)
.
then
(
(
)
=
>
{
connection
.
host
=
"
localhost
"
;
connection
.
port
=
port
;
connection
.
connect
(
)
;
}
)
;
}
get
id
(
)
{
return
this
.
device
.
id
+
"
|
"
+
this
.
_socketPath
;
}
}
;
function
FirefoxOSRuntime
(
device
model
)
{
Runtime
.
call
(
this
device
model
"
/
data
/
local
/
debugger
-
socket
"
)
;
}
FirefoxOSRuntime
.
detect
=
async
function
(
device
model
)
{
const
runtimes
=
[
]
;
const
query
=
"
test
-
f
/
system
/
b2g
/
b2g
;
echo
?
"
;
let
b2gExists
=
await
device
.
shell
(
query
)
;
for
(
let
attempts
=
3
;
attempts
>
0
;
attempts
-
-
)
{
b2gExists
=
await
device
.
shell
(
query
)
;
if
(
b2gExists
.
length
=
=
3
)
{
break
;
}
}
if
(
b2gExists
=
=
=
"
0
\
r
\
n
"
)
{
const
runtime
=
new
FirefoxOSRuntime
(
device
model
)
;
console
.
log
(
"
Found
"
+
runtime
.
name
)
;
runtimes
.
push
(
runtime
)
;
}
return
runtimes
;
}
;
FirefoxOSRuntime
.
prototype
=
Object
.
create
(
Runtime
.
prototype
)
;
Object
.
defineProperty
(
FirefoxOSRuntime
.
prototype
"
name
"
{
get
(
)
{
return
this
.
_model
|
|
this
.
device
.
id
;
}
}
)
;
function
FirefoxOnAndroidRuntime
(
device
model
socketPath
)
{
Runtime
.
call
(
this
device
model
socketPath
)
;
}
FirefoxOnAndroidRuntime
.
detect
=
async
function
(
device
model
)
{
const
runtimes
=
[
]
;
const
query
=
"
cat
/
proc
/
net
/
unix
"
;
const
rawSocketInfo
=
await
device
.
shell
(
query
)
;
let
socketInfos
=
rawSocketInfo
.
split
(
/
\
r
?
\
n
/
)
;
socketInfos
=
socketInfos
.
filter
(
l
=
>
l
.
includes
(
"
firefox
-
debugger
-
socket
"
)
)
;
const
socketPaths
=
new
Set
(
)
;
for
(
const
socketInfo
of
socketInfos
)
{
const
socketPath
=
socketInfo
.
split
(
"
"
)
.
pop
(
)
;
socketPaths
.
add
(
socketPath
)
;
}
for
(
const
socketPath
of
socketPaths
)
{
const
runtime
=
new
FirefoxOnAndroidRuntime
(
device
model
socketPath
)
;
console
.
log
(
"
Found
"
+
runtime
.
name
)
;
runtimes
.
push
(
runtime
)
;
}
return
runtimes
;
}
;
FirefoxOnAndroidRuntime
.
prototype
=
Object
.
create
(
Runtime
.
prototype
)
;
Object
.
defineProperty
(
FirefoxOnAndroidRuntime
.
prototype
"
name
"
{
get
(
)
{
const
packageName
=
this
.
_socketPath
.
startsWith
(
"
"
)
?
this
.
_socketPath
.
substr
(
1
)
.
split
(
"
/
"
)
[
0
]
:
this
.
_socketPath
.
split
(
"
/
"
)
[
3
]
;
let
channel
;
switch
(
packageName
)
{
case
"
org
.
mozilla
.
firefox
"
:
channel
=
"
"
;
break
;
case
"
org
.
mozilla
.
firefox_beta
"
:
channel
=
"
Beta
"
;
break
;
case
"
org
.
mozilla
.
fennec_aurora
"
:
channel
=
"
Nightly
"
;
break
;
case
"
org
.
mozilla
.
fennec
"
:
channel
=
"
Nightly
"
;
break
;
default
:
channel
=
"
Custom
"
;
}
return
"
Firefox
"
+
channel
+
"
on
Android
(
"
+
(
this
.
_model
|
|
this
.
device
.
id
)
+
"
)
"
;
}
}
)
;
exports
.
ADBScanner
=
ADBScanner
;
