"
use
strict
"
;
const
{
dumpn
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyImporter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
loader
.
lazyGetter
(
this
"
UNPACKED_ROOT_PATH
"
(
)
=
>
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
"
adb
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
EXTENSION_ID
"
(
)
=
>
{
return
Services
.
prefs
.
getCharPref
(
"
devtools
.
remote
.
adb
.
extensionID
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
ADB_BINARY_PATH
"
(
)
=
>
{
let
adbBinaryPath
=
OS
.
Path
.
join
(
UNPACKED_ROOT_PATH
"
adb
"
)
;
if
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
)
{
adbBinaryPath
+
=
"
.
exe
"
;
}
return
adbBinaryPath
;
}
)
;
async
function
getAdbInfo
(
adbUri
)
{
return
new
Promise
(
resolve
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
adbUri
loadUsingSystemPrincipal
:
true
}
(
input
)
=
>
{
try
{
const
string
=
NetUtil
.
readInputStreamToString
(
input
input
.
available
(
)
)
;
resolve
(
JSON
.
parse
(
string
)
)
;
}
catch
(
e
)
{
dumpn
(
Could
not
read
adb
.
json
in
the
extension
:
{
e
}
)
;
resolve
(
null
)
;
}
}
)
;
}
)
;
}
async
function
unpackFile
(
file
)
{
const
policy
=
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
EXTENSION_ID
)
;
if
(
!
policy
)
{
return
;
}
const
filePath
=
OS
.
Path
.
join
(
UNPACKED_ROOT_PATH
file
.
split
(
"
/
"
)
[
1
]
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
policy
.
getURL
(
file
)
loadUsingSystemPrincipal
:
true
}
(
input
)
=
>
{
try
{
const
outputFile
=
new
FileUtils
.
File
(
filePath
)
;
const
output
=
FileUtils
.
openAtomicFileOutputStream
(
outputFile
)
;
NetUtil
.
asyncCopy
(
input
output
resolve
)
;
}
catch
(
e
)
{
dumpn
(
Could
not
unpack
file
{
file
}
in
the
extension
:
{
e
}
)
;
reject
(
e
)
;
}
}
)
;
}
)
;
await
OS
.
File
.
setPermissions
(
filePath
{
unixMode
:
0o744
}
)
;
}
async
function
extractFiles
(
)
{
const
policy
=
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
EXTENSION_ID
)
;
if
(
!
policy
)
{
return
false
;
}
const
uri
=
policy
.
getURL
(
"
adb
.
json
"
)
;
const
adbInfo
=
await
getAdbInfo
(
uri
)
;
if
(
!
adbInfo
)
{
return
false
;
}
let
filesForAdb
;
try
{
filesForAdb
=
adbInfo
[
Services
.
appinfo
.
OS
]
[
Services
.
appinfo
.
XPCOMABI
.
split
(
"
-
"
)
[
0
]
]
;
}
catch
(
e
)
{
return
false
;
}
await
OS
.
File
.
makeDir
(
UNPACKED_ROOT_PATH
)
;
for
(
const
file
of
filesForAdb
)
{
try
{
await
unpackFile
(
file
)
;
}
catch
(
e
)
{
return
false
;
}
}
return
true
;
}
async
function
getFileForBinary
(
)
{
if
(
!
await
extractFiles
(
)
)
{
return
null
;
}
return
new
FileUtils
.
File
(
ADB_BINARY_PATH
)
;
}
exports
.
getFileForBinary
=
getFileForBinary
;
