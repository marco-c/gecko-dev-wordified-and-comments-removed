"
use
strict
"
;
const
{
Front
FrontClassWithSpec
custom
preEvent
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
animationPlayerSpec
animationsSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
animation
"
)
;
const
AnimationPlayerFront
=
FrontClassWithSpec
(
animationPlayerSpec
{
initialize
:
function
(
conn
form
detail
ctx
)
{
Front
.
prototype
.
initialize
.
call
(
this
conn
form
detail
ctx
)
;
this
.
state
=
{
}
;
}
form
:
function
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
this
.
actorID
=
form
;
return
;
}
this
.
_form
=
form
;
this
.
state
=
this
.
initialState
;
}
destroy
:
function
(
)
{
Front
.
prototype
.
destroy
.
call
(
this
)
;
}
get
animationTargetNodeFront
(
)
{
if
(
!
this
.
_form
.
animationTargetNodeActorID
)
{
return
null
;
}
return
this
.
conn
.
getActor
(
this
.
_form
.
animationTargetNodeActorID
)
;
}
get
initialState
(
)
{
return
{
type
:
this
.
_form
.
type
startTime
:
this
.
_form
.
startTime
currentTime
:
this
.
_form
.
currentTime
playState
:
this
.
_form
.
playState
playbackRate
:
this
.
_form
.
playbackRate
name
:
this
.
_form
.
name
duration
:
this
.
_form
.
duration
delay
:
this
.
_form
.
delay
endDelay
:
this
.
_form
.
endDelay
iterationCount
:
this
.
_form
.
iterationCount
iterationStart
:
this
.
_form
.
iterationStart
easing
:
this
.
_form
.
easing
fill
:
this
.
_form
.
fill
direction
:
this
.
_form
.
direction
animationTimingFunction
:
this
.
_form
.
animationTimingFunction
isRunningOnCompositor
:
this
.
_form
.
isRunningOnCompositor
propertyState
:
this
.
_form
.
propertyState
documentCurrentTime
:
this
.
_form
.
documentCurrentTime
createdTime
:
this
.
_form
.
createdTime
currentTimeAtCreated
:
this
.
_form
.
currentTimeAtCreated
absoluteValues
:
this
.
calculateAbsoluteValues
(
this
.
_form
)
}
;
}
onChanged
:
preEvent
(
"
changed
"
function
(
partialState
)
{
const
{
state
}
=
this
.
reconstructState
(
partialState
)
;
this
.
state
=
state
;
}
)
async
refreshState
(
)
{
const
data
=
await
this
.
getCurrentState
(
)
;
if
(
this
.
currentStateHasChanged
)
{
this
.
state
=
data
;
}
}
getCurrentState
:
custom
(
function
(
)
{
this
.
currentStateHasChanged
=
false
;
return
this
.
_getCurrentState
(
)
.
then
(
partialData
=
>
{
const
{
state
hasChanged
}
=
this
.
reconstructState
(
partialData
)
;
this
.
currentStateHasChanged
=
hasChanged
;
return
state
;
}
)
;
}
{
impl
:
"
_getCurrentState
"
}
)
reconstructState
:
function
(
data
)
{
let
hasChanged
=
false
;
for
(
const
key
in
this
.
state
)
{
if
(
typeof
data
[
key
]
=
=
=
"
undefined
"
)
{
data
[
key
]
=
this
.
state
[
key
]
;
}
else
if
(
data
[
key
]
!
=
=
this
.
state
[
key
]
)
{
hasChanged
=
true
;
}
}
data
.
absoluteValues
=
this
.
calculateAbsoluteValues
(
data
)
;
return
{
state
:
data
hasChanged
}
;
}
calculateAbsoluteValues
(
data
)
{
const
{
createdTime
currentTime
currentTimeAtCreated
delay
duration
endDelay
=
0
fill
iterationCount
playbackRate
}
=
data
;
const
toRate
=
v
=
>
v
/
Math
.
abs
(
playbackRate
)
;
const
isPositivePlaybackRate
=
playbackRate
>
0
;
let
absoluteDelay
=
0
;
let
absoluteEndDelay
=
0
;
let
isDelayFilled
=
false
;
let
isEndDelayFilled
=
false
;
if
(
isPositivePlaybackRate
)
{
absoluteDelay
=
toRate
(
delay
)
;
absoluteEndDelay
=
toRate
(
endDelay
)
;
isDelayFilled
=
fill
=
=
=
"
both
"
|
|
fill
=
=
=
"
backwards
"
;
isEndDelayFilled
=
fill
=
=
=
"
both
"
|
|
fill
=
=
=
"
forwards
"
;
}
else
{
absoluteDelay
=
toRate
(
endDelay
)
;
absoluteEndDelay
=
toRate
(
delay
)
;
isDelayFilled
=
fill
=
=
=
"
both
"
|
|
fill
=
=
=
"
forwards
"
;
isEndDelayFilled
=
fill
=
=
=
"
both
"
|
|
fill
=
=
=
"
backwards
"
;
}
let
endTime
=
0
;
if
(
duration
=
=
=
Infinity
)
{
endTime
=
(
absoluteDelay
>
0
?
absoluteDelay
*
2
:
1
)
;
}
else
{
endTime
=
absoluteDelay
+
toRate
(
duration
*
(
iterationCount
|
|
1
)
)
+
absoluteEndDelay
;
}
const
absoluteCreatedTime
=
isPositivePlaybackRate
?
createdTime
:
createdTime
-
endTime
;
const
absoluteCurrentTimeAtCreated
=
isPositivePlaybackRate
?
currentTimeAtCreated
:
endTime
-
currentTimeAtCreated
;
const
animationCurrentTime
=
isPositivePlaybackRate
?
currentTime
:
endTime
-
currentTime
;
const
absoluteCurrentTime
=
absoluteCreatedTime
+
toRate
(
animationCurrentTime
)
;
const
absoluteStartTime
=
absoluteCreatedTime
+
Math
.
min
(
absoluteDelay
0
)
;
const
absoluteStartTimeAtCreated
=
absoluteCreatedTime
+
absoluteCurrentTimeAtCreated
;
const
endTimeWithNegativeEndDelay
=
endTime
-
Math
.
min
(
absoluteEndDelay
0
)
;
const
absoluteEndTime
=
absoluteCreatedTime
+
endTimeWithNegativeEndDelay
;
return
{
createdTime
:
absoluteCreatedTime
currentTime
:
absoluteCurrentTime
currentTimeAtCreated
:
absoluteCurrentTimeAtCreated
delay
:
absoluteDelay
endDelay
:
absoluteEndDelay
endTime
:
absoluteEndTime
isDelayFilled
isEndDelayFilled
startTime
:
absoluteStartTime
startTimeAtCreated
:
absoluteStartTimeAtCreated
}
;
}
}
)
;
exports
.
AnimationPlayerFront
=
AnimationPlayerFront
;
const
AnimationsFront
=
FrontClassWithSpec
(
animationsSpec
{
initialize
:
function
(
client
{
animationsActor
}
)
{
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
animationsActor
}
)
;
this
.
manage
(
this
)
;
}
destroy
:
function
(
)
{
Front
.
prototype
.
destroy
.
call
(
this
)
;
}
}
)
;
exports
.
AnimationsFront
=
AnimationsFront
;
