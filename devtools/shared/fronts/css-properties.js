"
use
strict
"
;
const
{
FrontClassWithSpec
Front
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
cssPropertiesSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
css
-
properties
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
CSS_PROPERTIES_DB
}
=
require
(
"
devtools
/
shared
/
css
/
properties
-
db
"
)
;
const
{
cssColors
}
=
require
(
"
devtools
/
shared
/
css
/
color
-
db
"
)
;
var
NON_ASCII
=
"
[
^
\
\
x00
-
\
\
x7F
]
"
;
var
ESCAPE
=
"
\
\
\
\
[
^
\
n
\
r
]
"
;
var
FIRST_CHAR
=
[
"
[
_a
-
z
]
"
NON_ASCII
ESCAPE
]
.
join
(
"
|
"
)
;
var
TRAILING_CHAR
=
[
"
[
_a
-
z0
-
9
-
]
"
NON_ASCII
ESCAPE
]
.
join
(
"
|
"
)
;
var
IS_VARIABLE_TOKEN
=
new
RegExp
(
^
-
-
(
{
FIRST_CHAR
}
)
(
{
TRAILING_CHAR
}
)
*
"
i
"
)
;
function
isCssVariable
(
input
)
{
return
!
!
input
.
match
(
IS_VARIABLE_TOKEN
)
;
}
var
cachedCssProperties
=
new
WeakMap
(
)
;
const
CssPropertiesFront
=
FrontClassWithSpec
(
cssPropertiesSpec
{
initialize
(
client
{
cssPropertiesActor
}
)
{
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
cssPropertiesActor
}
)
;
this
.
manage
(
this
)
;
}
}
)
;
function
hasFeature
(
featureSet
feature
)
{
if
(
feature
in
featureSet
)
{
return
featureSet
[
feature
]
;
}
return
false
;
}
function
CssProperties
(
db
)
{
this
.
properties
=
db
.
properties
;
this
.
pseudoElements
=
db
.
pseudoElements
;
this
.
cssColor4ColorFunction
=
hasFeature
(
db
.
supportedFeature
"
css
-
color
-
4
-
color
-
function
"
)
;
this
.
isKnown
=
this
.
isKnown
.
bind
(
this
)
;
this
.
isInherited
=
this
.
isInherited
.
bind
(
this
)
;
this
.
supportsType
=
this
.
supportsType
.
bind
(
this
)
;
this
.
isValidOnClient
=
this
.
isValidOnClient
.
bind
(
this
)
;
this
.
supportsCssColor4ColorFunction
=
this
.
supportsCssColor4ColorFunction
.
bind
(
this
)
;
this
.
_dummyElements
=
new
WeakMap
(
)
;
}
CssProperties
.
prototype
=
{
isKnown
(
property
)
{
return
!
!
this
.
properties
[
property
]
|
|
isCssVariable
(
property
)
;
}
isValidOnClient
(
name
value
doc
)
{
let
dummyElement
=
this
.
_dummyElements
.
get
(
doc
)
;
if
(
!
dummyElement
)
{
dummyElement
=
doc
.
createElement
(
"
div
"
)
;
this
.
_dummyElements
.
set
(
doc
dummyElement
)
;
}
const
sanitizedValue
=
(
"
"
+
value
)
.
replace
(
/
!
\
s
*
important
\
s
*
/
"
"
)
;
dummyElement
.
style
[
name
]
=
sanitizedValue
;
const
isValid
=
!
!
dummyElement
.
style
[
name
]
;
dummyElement
.
style
[
name
]
=
"
"
;
return
isValid
;
}
getValidityChecker
(
doc
)
{
return
(
name
value
)
=
>
this
.
isValidOnClient
(
name
value
doc
)
;
}
isInherited
(
property
)
{
return
this
.
properties
[
property
]
&
&
this
.
properties
[
property
]
.
isInherited
;
}
supportsType
(
property
type
)
{
return
this
.
properties
[
property
]
&
&
this
.
properties
[
property
]
.
supports
.
includes
(
type
)
;
}
getValues
(
property
)
{
return
this
.
properties
[
property
]
?
this
.
properties
[
property
]
.
values
:
[
]
;
}
getNames
(
property
)
{
return
Object
.
keys
(
this
.
properties
)
;
}
getSubproperties
(
name
)
{
if
(
this
.
isKnown
(
name
)
)
{
if
(
this
.
properties
[
name
]
&
&
this
.
properties
[
name
]
.
subproperties
)
{
return
this
.
properties
[
name
]
.
subproperties
;
}
return
[
name
]
;
}
return
[
]
;
}
supportsCssColor4ColorFunction
(
)
{
return
this
.
cssColor4ColorFunction
;
}
}
;
const
initCssProperties
=
Task
.
async
(
function
*
(
toolbox
)
{
const
client
=
toolbox
.
target
.
client
;
if
(
cachedCssProperties
.
has
(
client
)
)
{
return
cachedCssProperties
.
get
(
client
)
;
}
let
db
front
;
if
(
toolbox
.
target
.
hasActor
(
"
cssProperties
"
)
)
{
front
=
CssPropertiesFront
(
client
toolbox
.
target
.
form
)
;
db
=
yield
front
.
getCSSDatabase
(
)
;
}
else
{
db
=
CSS_PROPERTIES_DB
;
}
const
cssProperties
=
new
CssProperties
(
normalizeCssData
(
db
)
)
;
cachedCssProperties
.
set
(
client
{
cssProperties
front
}
)
;
return
{
cssProperties
front
}
;
}
)
;
function
getCssProperties
(
toolbox
)
{
if
(
!
cachedCssProperties
.
has
(
toolbox
.
target
.
client
)
)
{
throw
new
Error
(
"
The
CSS
database
has
not
been
initialized
please
make
"
+
"
sure
initCssDatabase
was
called
once
before
for
this
"
+
"
toolbox
.
"
)
;
}
return
cachedCssProperties
.
get
(
toolbox
.
target
.
client
)
.
cssProperties
;
}
function
getClientCssProperties
(
)
{
return
new
CssProperties
(
normalizeCssData
(
CSS_PROPERTIES_DB
)
)
;
}
function
normalizeCssData
(
db
)
{
if
(
db
!
=
=
CSS_PROPERTIES_DB
)
{
if
(
!
db
.
properties
)
{
db
=
{
properties
:
db
}
;
}
let
missingSupports
=
!
db
.
properties
.
color
.
supports
;
let
missingValues
=
!
db
.
properties
.
color
.
values
;
let
missingSubproperties
=
!
db
.
properties
.
background
.
subproperties
;
for
(
let
name
in
db
.
properties
)
{
if
(
typeof
CSS_PROPERTIES_DB
.
properties
[
name
]
!
=
=
"
object
"
)
{
continue
;
}
if
(
missingSupports
)
{
db
.
properties
[
name
]
.
supports
=
CSS_PROPERTIES_DB
.
properties
[
name
]
.
supports
;
}
if
(
missingValues
)
{
db
.
properties
[
name
]
.
values
=
CSS_PROPERTIES_DB
.
properties
[
name
]
.
values
;
}
if
(
missingSubproperties
)
{
db
.
properties
[
name
]
.
subproperties
=
CSS_PROPERTIES_DB
.
properties
[
name
]
.
subproperties
;
}
if
(
db
.
properties
.
font
.
isInherited
)
{
db
.
properties
[
name
]
.
isInherited
=
CSS_PROPERTIES_DB
.
properties
[
name
]
.
isInherited
;
}
}
}
reattachCssColorValues
(
db
)
;
if
(
!
db
.
supportedFeature
)
{
db
.
supportedFeature
=
{
}
;
}
return
db
;
}
function
reattachCssColorValues
(
db
)
{
if
(
db
.
properties
.
color
.
values
[
0
]
=
=
=
"
COLOR
"
)
{
const
colors
=
Object
.
keys
(
cssColors
)
;
for
(
let
name
in
db
.
properties
)
{
const
property
=
db
.
properties
[
name
]
;
if
(
property
.
values
&
&
property
.
values
[
0
]
=
=
=
"
COLOR
"
)
{
property
.
values
.
shift
(
)
;
property
.
values
=
property
.
values
.
concat
(
colors
)
.
sort
(
)
;
}
}
}
}
module
.
exports
=
{
CssPropertiesFront
CssProperties
getCssProperties
getClientCssProperties
initCssProperties
}
;
