"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
PerformanceRecordingFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
performance
-
recording
"
)
;
const
{
performanceSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
performance
"
)
;
loader
.
lazyRequireGetter
(
this
"
PerformanceIO
"
"
devtools
/
client
/
performance
/
modules
/
io
"
)
;
loader
.
lazyRequireGetter
(
this
"
getSystemInfo
"
"
devtools
/
shared
/
system
"
true
)
;
class
PerformanceFront
extends
FrontClassWithSpec
(
performanceSpec
)
{
constructor
(
client
)
{
super
(
client
)
;
this
.
_queuedRecordings
=
[
]
;
this
.
_onRecordingStartedEvent
=
this
.
_onRecordingStartedEvent
.
bind
(
this
)
;
this
.
flushQueuedRecordings
=
this
.
flushQueuedRecordings
.
bind
(
this
)
;
this
.
before
(
"
profiler
-
status
"
this
.
_onProfilerStatus
.
bind
(
this
)
)
;
this
.
before
(
"
timeline
-
data
"
this
.
_onTimelineEvent
.
bind
(
this
)
)
;
this
.
on
(
"
recording
-
started
"
this
.
_onRecordingStartedEvent
)
;
this
.
formAttributeName
=
"
performanceActor
"
;
}
async
initialize
(
)
{
await
this
.
connect
(
)
;
}
async
connect
(
)
{
const
systemClient
=
await
getSystemInfo
(
)
;
const
{
traits
}
=
await
super
.
connect
(
{
systemClient
}
)
;
this
.
_traits
=
traits
;
return
this
.
_traits
;
}
async
_onRecordingStartedEvent
(
recording
)
{
this
.
_queuedRecordings
.
push
(
recording
)
;
}
flushQueuedRecordings
(
)
{
this
.
off
(
"
recording
-
started
"
this
.
_onPerformanceFrontEvent
)
;
const
recordings
=
this
.
_queuedRecordings
;
this
.
_queuedRecordings
=
[
]
;
return
recordings
;
}
get
traits
(
)
{
if
(
!
this
.
_traits
)
{
Cu
.
reportError
(
"
Cannot
access
traits
of
PerformanceFront
before
"
+
"
calling
connect
(
)
.
"
)
;
}
return
this
.
_traits
;
}
getBufferUsageForRecording
(
recording
)
{
if
(
!
recording
.
isRecording
(
)
)
{
return
void
0
;
}
const
{
position
:
currentPosition
totalSize
generation
:
currentGeneration
}
=
this
.
_currentBufferStatus
;
const
{
position
:
origPosition
generation
:
origGeneration
}
=
recording
.
getStartingBufferStatus
(
)
;
const
normalizedCurrent
=
(
totalSize
*
(
currentGeneration
-
origGeneration
)
)
+
currentPosition
;
const
percent
=
(
normalizedCurrent
-
origPosition
)
/
totalSize
;
if
(
percent
<
0
)
{
return
0
;
}
else
if
(
percent
>
1
)
{
return
1
;
}
return
percent
;
}
importRecording
(
file
)
{
return
PerformanceIO
.
loadRecordingFromFile
(
file
)
.
then
(
recordingData
=
>
{
const
model
=
new
PerformanceRecordingFront
(
)
;
model
.
_imported
=
true
;
model
.
_label
=
recordingData
.
label
|
|
"
"
;
model
.
_duration
=
recordingData
.
duration
;
model
.
_markers
=
recordingData
.
markers
;
model
.
_frames
=
recordingData
.
frames
;
model
.
_memory
=
recordingData
.
memory
;
model
.
_ticks
=
recordingData
.
ticks
;
model
.
_allocations
=
recordingData
.
allocations
;
model
.
_profile
=
recordingData
.
profile
;
model
.
_configuration
=
recordingData
.
configuration
|
|
{
}
;
model
.
_systemHost
=
recordingData
.
systemHost
;
model
.
_systemClient
=
recordingData
.
systemClient
;
return
model
;
}
)
;
}
_onProfilerStatus
(
data
)
{
this
.
_currentBufferStatus
=
data
;
}
_onTimelineEvent
(
type
data
recordings
)
{
for
(
const
recording
of
recordings
)
{
recording
.
_addTimelineData
(
type
data
)
;
}
}
}
exports
.
PerformanceFront
=
PerformanceFront
;
registerFront
(
PerformanceFront
)
;
