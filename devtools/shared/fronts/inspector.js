"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
inspectorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
inspector
"
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
const
TELEMETRY_EYEDROPPER_OPENED
=
"
DEVTOOLS_EYEDROPPER_OPENED_COUNT
"
;
const
TELEMETRY_EYEDROPPER_OPENED_MENU
=
"
DEVTOOLS_MENU_EYEDROPPER_OPENED_COUNT
"
;
const
SHOW_ALL_ANONYMOUS_CONTENT_PREF
=
"
devtools
.
inspector
.
showAllAnonymousContent
"
;
const
SHOW_UA_SHADOW_ROOTS_PREF
=
"
devtools
.
inspector
.
showUserAgentShadowRoots
"
;
const
BROWSER_FISSION_ENABLED_PREF
=
"
devtools
.
browsertoolbox
.
fission
"
;
const
CONTENT_FISSION_ENABLED_PREF
=
"
devtools
.
contenttoolbox
.
fission
"
;
const
USE_NEW_BOX_MODEL_HIGHLIGHTER_PREF
=
"
devtools
.
inspector
.
use
-
new
-
box
-
model
-
highlighter
"
;
const
telemetry
=
new
Telemetry
(
)
;
class
InspectorFront
extends
FrontClassWithSpec
(
inspectorSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
_client
=
client
;
this
.
_highlighters
=
new
Map
(
)
;
this
.
formAttributeName
=
"
inspectorActor
"
;
}
async
initialize
(
)
{
await
Promise
.
all
(
[
this
.
_getWalker
(
)
this
.
_getHighlighter
(
)
this
.
_getPageStyle
(
)
]
)
;
}
get
isBrowserFissionEnabled
(
)
{
if
(
this
.
_isBrowserFissionEnabled
=
=
=
undefined
)
{
this
.
_isBrowserFissionEnabled
=
Services
.
prefs
.
getBoolPref
(
BROWSER_FISSION_ENABLED_PREF
)
;
}
return
this
.
_isBrowserFissionEnabled
;
}
get
isContentFissionEnabled
(
)
{
if
(
this
.
_isContentFissionEnabled
=
=
=
undefined
)
{
this
.
_isContentFissionEnabled
=
Services
.
prefs
.
getBoolPref
(
CONTENT_FISSION_ENABLED_PREF
)
;
}
return
this
.
_isContentFissionEnabled
;
}
async
_getWalker
(
)
{
const
showAllAnonymousContent
=
Services
.
prefs
.
getBoolPref
(
SHOW_ALL_ANONYMOUS_CONTENT_PREF
)
;
const
showUserAgentShadowRoots
=
Services
.
prefs
.
getBoolPref
(
SHOW_UA_SHADOW_ROOTS_PREF
)
;
this
.
walker
=
await
this
.
getWalker
(
{
showAllAnonymousContent
showUserAgentShadowRoots
}
)
;
}
async
_getHighlighter
(
)
{
const
autohide
=
!
flags
.
testing
;
this
.
highlighter
=
await
this
.
getHighlighter
(
autohide
Services
.
prefs
.
getBoolPref
(
USE_NEW_BOX_MODEL_HIGHLIGHTER_PREF
)
)
;
}
hasHighlighter
(
type
)
{
return
this
.
_highlighters
.
has
(
type
)
;
}
async
_getPageStyle
(
)
{
this
.
pageStyle
=
await
super
.
getPageStyle
(
)
;
}
destroy
(
)
{
this
.
destroyHighlighters
(
)
;
super
.
destroy
(
)
;
}
destroyHighlighters
(
)
{
for
(
const
type
of
this
.
_highlighters
.
keys
(
)
)
{
if
(
this
.
_highlighters
.
has
(
type
)
)
{
this
.
_highlighters
.
get
(
type
)
.
finalize
(
)
;
this
.
_highlighters
.
delete
(
type
)
;
}
}
}
async
getHighlighterByType
(
typeName
)
{
let
highlighter
=
null
;
try
{
highlighter
=
await
super
.
getHighlighterByType
(
typeName
)
;
}
catch
(
_
)
{
throw
new
Error
(
"
The
target
doesn
'
t
support
"
+
creating
highlighters
by
types
or
{
typeName
}
is
unknown
)
;
}
return
highlighter
;
}
getKnownHighlighter
(
type
)
{
return
this
.
_highlighters
.
get
(
type
)
;
}
async
getOrCreateHighlighterByType
(
type
)
{
let
front
=
this
.
_highlighters
.
get
(
type
)
;
if
(
!
front
)
{
front
=
await
this
.
getHighlighterByType
(
type
)
;
this
.
_highlighters
.
set
(
type
front
)
;
}
return
front
;
}
async
pickColorFromPage
(
options
)
{
await
super
.
pickColorFromPage
(
options
)
;
if
(
options
&
&
options
.
fromMenu
)
{
telemetry
.
getHistogramById
(
TELEMETRY_EYEDROPPER_OPENED_MENU
)
.
add
(
true
)
;
}
else
{
telemetry
.
getHistogramById
(
TELEMETRY_EYEDROPPER_OPENED
)
.
add
(
true
)
;
}
}
async
getChildInspectors
(
)
{
const
childInspectors
=
[
]
;
const
target
=
this
.
targetFront
;
if
(
this
.
isBrowserFissionEnabled
&
&
target
.
chrome
&
&
!
target
.
isAddon
)
{
const
{
frames
}
=
await
target
.
listRemoteFrames
(
)
;
for
(
const
descriptor
of
frames
)
{
const
remoteTarget
=
await
descriptor
.
getTarget
(
)
;
if
(
remoteTarget
)
{
const
remoteInspectorFront
=
await
remoteTarget
.
getFront
(
"
inspector
"
)
;
await
remoteInspectorFront
.
walker
.
reparentRemoteFrame
(
)
;
childInspectors
.
push
(
remoteInspectorFront
)
;
}
}
}
return
childInspectors
;
}
async
getAllInspectorFronts
(
)
{
const
remoteInspectors
=
await
this
.
getChildInspectors
(
)
;
return
[
this
.
.
.
remoteInspectors
]
;
}
async
getNodeFrontFromNodeGrip
(
grip
)
{
const
gripHasContentDomReference
=
"
contentDomReference
"
in
grip
;
if
(
!
this
.
isContentFissionEnabled
|
|
!
gripHasContentDomReference
)
{
return
this
.
walker
.
gripToNodeFront
(
grip
)
;
}
const
{
contentDomReference
}
=
grip
;
const
{
browsingContextId
}
=
contentDomReference
;
if
(
this
.
targetFront
.
browsingContextID
=
=
=
browsingContextId
)
{
return
this
.
walker
.
getNodeActorFromContentDomReference
(
contentDomReference
)
;
}
const
descriptor
=
await
this
.
targetFront
.
client
.
mainRoot
.
getBrowsingContextDescriptor
(
browsingContextId
)
;
const
target
=
await
descriptor
.
getTarget
(
)
;
const
{
walker
}
=
await
target
.
getFront
(
"
inspector
"
)
;
return
walker
.
getNodeActorFromContentDomReference
(
contentDomReference
)
;
}
}
exports
.
InspectorFront
=
InspectorFront
;
registerFront
(
InspectorFront
)
;
