"
use
strict
"
;
const
{
audionodeSpec
webAudioSpec
AUTOMATION_METHODS
NODE_CREATION_METHODS
NODE_ROUTING_METHODS
}
=
require
(
"
devtools
/
shared
/
specs
/
webaudio
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
AUDIO_NODE_DEFINITION
=
require
(
"
devtools
/
server
/
actors
/
utils
/
audionodes
.
json
"
)
;
const
AudioNodeFront
=
protocol
.
FrontClass
(
audionodeSpec
{
form
:
function
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
this
.
actorID
=
form
;
return
;
}
this
.
actorID
=
form
.
actor
;
this
.
type
=
form
.
type
;
this
.
source
=
form
.
source
;
this
.
bypassable
=
form
.
bypassable
;
}
initialize
:
function
(
client
form
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
)
;
if
(
form
)
{
this
.
manage
(
this
)
;
}
}
}
)
;
exports
.
AudioNodeFront
=
AudioNodeFront
;
const
WebAudioFront
=
protocol
.
FrontClass
(
webAudioSpec
{
initialize
:
function
(
client
{
webaudioActor
}
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
webaudioActor
}
)
;
this
.
manage
(
this
)
;
}
_onCreateNode
:
protocol
.
preEvent
(
"
create
-
node
"
function
(
audionode
)
{
if
(
!
audionode
.
type
)
{
return
audionode
.
getType
(
)
.
then
(
type
=
>
{
audionode
.
type
=
type
;
audionode
.
source
=
!
!
AUDIO_NODE_DEFINITION
[
type
]
.
source
;
audionode
.
bypassable
=
!
AUDIO_NODE_DEFINITION
[
type
]
.
unbypassable
;
}
)
;
}
return
null
;
}
)
}
)
;
WebAudioFront
.
AUTOMATION_METHODS
=
new
Set
(
AUTOMATION_METHODS
)
;
WebAudioFront
.
NODE_CREATION_METHODS
=
new
Set
(
NODE_CREATION_METHODS
)
;
WebAudioFront
.
NODE_ROUTING_METHODS
=
new
Set
(
NODE_ROUTING_METHODS
)
;
exports
.
WebAudioFront
=
WebAudioFront
;
