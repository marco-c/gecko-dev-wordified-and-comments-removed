"
use
strict
"
;
const
{
ThreadStateTypes
}
=
require
(
"
devtools
/
shared
/
client
/
constants
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
threadSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
thread
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectFront
"
"
devtools
/
shared
/
fronts
/
object
"
)
;
loader
.
lazyRequireGetter
(
this
"
FrameFront
"
"
devtools
/
shared
/
fronts
/
frame
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceFront
"
"
devtools
/
shared
/
fronts
/
source
"
true
)
;
class
ThreadFront
extends
FrontClassWithSpec
(
threadSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
client
=
client
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
_state
=
"
paused
"
;
this
.
_beforePaused
=
this
.
_beforePaused
.
bind
(
this
)
;
this
.
_beforeResumed
=
this
.
_beforeResumed
.
bind
(
this
)
;
this
.
_beforeDetached
=
this
.
_beforeDetached
.
bind
(
this
)
;
this
.
before
(
"
paused
"
this
.
_beforePaused
)
;
this
.
before
(
"
resumed
"
this
.
_beforeResumed
)
;
this
.
before
(
"
detached
"
this
.
_beforeDetached
)
;
this
.
formAttributeName
=
"
threadActor
"
;
}
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
get
actor
(
)
{
return
this
.
actorID
;
}
_assertPaused
(
command
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
command
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
getFrames
(
start
count
)
{
return
super
.
frames
(
start
count
)
;
}
async
_doResume
(
resumeLimit
rewind
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_previousState
=
this
.
_state
;
this
.
_state
=
"
resuming
"
;
try
{
await
super
.
resume
(
resumeLimit
rewind
)
;
}
catch
(
e
)
{
if
(
this
.
_state
=
=
"
resuming
"
)
{
if
(
e
.
state
)
{
this
.
_state
=
ThreadStateTypes
[
e
.
state
]
;
}
else
{
this
.
_state
=
this
.
_previousState
;
}
}
}
delete
this
.
_previousState
;
}
resume
(
)
{
return
this
.
_doResume
(
null
false
)
;
}
resumeThenPause
(
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
false
)
;
}
async
rewind
(
)
{
if
(
!
this
.
paused
)
{
this
.
interrupt
(
)
;
await
this
.
once
(
"
paused
"
)
;
}
this
.
_doResume
(
null
true
)
;
}
stepOver
(
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
false
)
;
}
stepIn
(
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
false
)
;
}
stepOut
(
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
false
)
;
}
reverseStepOver
(
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
true
)
;
}
interrupt
(
)
{
return
this
.
_doInterrupt
(
null
)
;
}
breakOnNext
(
)
{
return
this
.
_doInterrupt
(
"
onNext
"
)
;
}
timeWarp
(
target
)
{
const
warp
=
(
)
=
>
{
this
.
_doResume
(
{
type
:
"
warp
"
target
}
true
)
;
}
;
if
(
this
.
paused
)
{
return
warp
(
)
;
}
this
.
interrupt
(
)
;
return
this
.
once
(
"
paused
"
warp
)
;
}
_doInterrupt
(
when
)
{
return
super
.
interrupt
(
when
)
;
}
async
getSources
(
)
{
let
sources
=
[
]
;
try
{
(
{
sources
}
=
await
super
.
sources
(
)
)
;
}
catch
(
e
)
{
console
.
log
(
getSources
failed
.
Connection
may
have
closed
:
{
e
}
)
;
}
return
{
sources
}
;
}
async
attach
(
options
)
{
let
response
;
try
{
const
onPaused
=
this
.
once
(
"
paused
"
)
;
response
=
await
super
.
attach
(
options
)
;
await
onPaused
;
}
catch
(
e
)
{
throw
new
Error
(
e
)
;
}
return
response
;
}
async
detach
(
)
{
const
onDetached
=
this
.
once
(
"
detached
"
)
;
await
super
.
detach
(
)
;
await
onDetached
;
await
this
.
destroy
(
)
;
}
pauseGrip
(
grip
)
{
if
(
grip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
grip
.
actor
]
;
}
const
objectFront
=
new
ObjectFront
(
this
.
client
grip
)
;
this
.
_pauseGrips
[
grip
.
actor
]
=
objectFront
;
return
objectFront
;
}
_clearObjectFronts
(
gripCacheName
)
{
for
(
const
id
in
this
[
gripCacheName
]
)
{
this
[
gripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
gripCacheName
]
=
{
}
;
}
_clearFrameFronts
(
)
{
for
(
const
front
of
this
.
poolChildren
(
)
)
{
if
(
front
instanceof
FrameFront
)
{
this
.
unmanage
(
front
)
;
}
}
}
_clearPauseGrips
(
)
{
this
.
_clearObjectFronts
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
(
)
{
this
.
_clearObjectFronts
(
"
_threadGrips
"
)
;
}
_beforePaused
(
packet
)
{
this
.
_state
=
"
paused
"
;
this
.
_onThreadState
(
packet
)
;
}
_beforeResumed
(
)
{
this
.
_state
=
"
attached
"
;
this
.
_onThreadState
(
null
)
;
this
.
_clearFrameFronts
(
)
;
}
_beforeDetached
(
packet
)
{
this
.
_state
=
"
detached
"
;
this
.
_onThreadState
(
packet
)
;
this
.
_clearThreadGrips
(
)
;
this
.
_clearFrameFronts
(
)
;
}
_onThreadState
(
packet
)
{
this
.
_lastPausePacket
=
packet
;
this
.
_clearPauseGrips
(
)
;
}
getLastPausePacket
(
)
{
return
this
.
_lastPausePacket
;
}
source
(
form
)
{
if
(
form
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
form
.
actor
]
;
}
const
sourceFront
=
new
SourceFront
(
this
.
client
form
)
;
this
.
manage
(
sourceFront
)
;
this
.
_threadGrips
[
form
.
actor
]
=
sourceFront
;
return
sourceFront
;
}
}
exports
.
ThreadFront
=
ThreadFront
;
registerFront
(
ThreadFront
)
;
