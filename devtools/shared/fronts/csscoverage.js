"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
cssUsageSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
csscoverage
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
custom
}
=
protocol
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
const
l10n
=
exports
.
l10n
=
{
_URI
:
"
chrome
:
/
/
devtools
-
shared
/
locale
/
csscoverage
.
properties
"
lookup
:
function
(
msg
)
{
if
(
this
.
_stringBundle
=
=
null
)
{
this
.
_stringBundle
=
Services
.
strings
.
createBundle
(
this
.
_URI
)
;
}
return
this
.
_stringBundle
.
GetStringFromName
(
msg
)
;
}
}
;
var
isRunning
=
false
;
var
notification
;
var
target
;
var
chromeWindow
;
const
CSSUsageFront
=
protocol
.
FrontClass
(
cssUsageSpec
{
initialize
:
function
(
client
form
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
)
;
this
.
actorID
=
form
.
cssUsageActor
;
this
.
manage
(
this
)
;
}
_onStateChange
:
protocol
.
preEvent
(
"
state
-
change
"
function
(
ev
)
{
isRunning
=
ev
.
isRunning
;
ev
.
target
=
target
;
if
(
isRunning
)
{
let
gnb
=
chromeWindow
.
document
.
getElementById
(
"
global
-
notificationbox
"
)
;
notification
=
gnb
.
getNotificationWithValue
(
"
csscoverage
-
running
"
)
;
if
(
notification
=
=
null
)
{
let
notifyStop
=
reason
=
>
{
if
(
reason
=
=
"
removed
"
)
{
this
.
stop
(
)
;
}
}
;
let
msg
=
l10n
.
lookup
(
"
csscoverageRunningReply
"
)
;
notification
=
gnb
.
appendNotification
(
msg
"
csscoverage
-
running
"
"
"
gnb
.
PRIORITY_INFO_HIGH
null
notifyStop
)
;
}
}
else
{
if
(
notification
)
{
notification
.
remove
(
)
;
notification
=
undefined
;
}
gDevTools
.
showToolbox
(
target
"
styleeditor
"
)
;
target
=
undefined
;
}
}
)
start
:
custom
(
function
(
newChromeWindow
newTarget
noreload
=
false
)
{
target
=
newTarget
;
chromeWindow
=
newChromeWindow
;
return
this
.
_start
(
noreload
)
;
}
{
impl
:
"
_start
"
}
)
toggle
:
custom
(
function
(
newChromeWindow
newTarget
)
{
target
=
newTarget
;
chromeWindow
=
newChromeWindow
;
return
this
.
_toggle
(
)
;
}
{
impl
:
"
_toggle
"
}
)
isRunning
:
function
(
)
{
return
isRunning
;
}
}
)
;
exports
.
CSSUsageFront
=
CSSUsageFront
;
const
knownFronts
=
new
WeakMap
(
)
;
exports
.
getUsage
=
function
(
trgt
)
{
return
trgt
.
makeRemote
(
)
.
then
(
(
)
=
>
{
let
front
=
knownFronts
.
get
(
trgt
.
client
)
;
if
(
front
=
=
null
&
&
trgt
.
form
.
cssUsageActor
!
=
null
)
{
front
=
new
CSSUsageFront
(
trgt
.
client
trgt
.
form
)
;
knownFronts
.
set
(
trgt
.
client
front
)
;
}
return
front
;
}
)
;
}
;
