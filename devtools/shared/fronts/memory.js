"
use
strict
"
;
const
{
memorySpec
}
=
require
(
"
devtools
/
shared
/
specs
/
memory
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
loader
.
lazyRequireGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HeapSnapshotFileUtils
"
"
devtools
/
shared
/
heapsnapshot
/
HeapSnapshotFileUtils
"
)
;
class
MemoryFront
extends
FrontClassWithSpec
(
memorySpec
)
{
constructor
(
client
)
{
super
(
client
)
;
this
.
_client
=
client
;
this
.
heapSnapshotFileActorID
=
null
;
this
.
formAttributeName
=
"
memoryActor
"
;
}
async
saveHeapSnapshot
(
options
=
{
}
)
{
const
snapshotId
=
await
super
.
saveHeapSnapshot
(
options
.
boundaries
)
;
if
(
!
options
.
forceCopy
&
&
(
await
HeapSnapshotFileUtils
.
haveHeapSnapshotTempFile
(
snapshotId
)
)
)
{
return
HeapSnapshotFileUtils
.
getHeapSnapshotTempFilePath
(
snapshotId
)
;
}
return
this
.
transferHeapSnapshot
(
snapshotId
)
;
}
async
transferHeapSnapshot
(
snapshotId
)
{
if
(
!
this
.
heapSnapshotFileActorID
)
{
const
form
=
await
this
.
_client
.
mainRoot
.
rootForm
;
this
.
heapSnapshotFileActorID
=
form
.
heapSnapshotFileActor
;
}
try
{
const
request
=
this
.
_client
.
request
(
{
to
:
this
.
heapSnapshotFileActorID
type
:
"
transferHeapSnapshot
"
snapshotId
}
)
;
const
outFilePath
=
HeapSnapshotFileUtils
.
getNewUniqueHeapSnapshotTempFilePath
(
)
;
const
outFile
=
new
FileUtils
.
File
(
outFilePath
)
;
const
outFileStream
=
FileUtils
.
openSafeFileOutputStream
(
outFile
)
;
const
{
copyTo
}
=
await
request
;
await
copyTo
(
outFileStream
)
;
FileUtils
.
closeSafeFileOutputStream
(
outFileStream
)
;
return
outFilePath
;
}
catch
(
e
)
{
if
(
e
.
error
)
{
throw
new
Error
(
The
server
'
s
actor
threw
an
error
:
(
{
e
.
error
}
)
{
e
.
message
}
)
;
}
throw
e
;
}
}
}
exports
.
MemoryFront
=
MemoryFront
;
registerFront
(
MemoryFront
)
;
