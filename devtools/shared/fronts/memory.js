"
use
strict
"
;
const
{
memorySpec
}
=
require
(
"
devtools
/
shared
/
specs
/
memory
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
loader
.
lazyRequireGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HeapSnapshotFileUtils
"
"
devtools
/
shared
/
heapsnapshot
/
HeapSnapshotFileUtils
"
)
;
const
MemoryFront
=
protocol
.
FrontClassWithSpec
(
memorySpec
{
initialize
:
function
(
client
form
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
)
;
this
.
_client
=
client
;
this
.
actorID
=
form
.
memoryActor
;
this
.
heapSnapshotFileActorID
=
null
;
this
.
manage
(
this
)
;
}
saveHeapSnapshot
:
protocol
.
custom
(
async
function
(
options
=
{
}
)
{
const
snapshotId
=
await
this
.
_saveHeapSnapshotImpl
(
options
.
boundaries
)
;
if
(
!
options
.
forceCopy
&
&
(
await
HeapSnapshotFileUtils
.
haveHeapSnapshotTempFile
(
snapshotId
)
)
)
{
return
HeapSnapshotFileUtils
.
getHeapSnapshotTempFilePath
(
snapshotId
)
;
}
return
this
.
transferHeapSnapshot
(
snapshotId
)
;
}
{
impl
:
"
_saveHeapSnapshotImpl
"
}
)
transferHeapSnapshot
:
protocol
.
custom
(
async
function
(
snapshotId
)
{
if
(
!
this
.
heapSnapshotFileActorID
)
{
const
form
=
await
this
.
_client
.
mainRoot
.
rootForm
;
this
.
heapSnapshotFileActorID
=
form
.
heapSnapshotFileActor
;
}
const
request
=
this
.
_client
.
request
(
{
to
:
this
.
heapSnapshotFileActorID
type
:
"
transferHeapSnapshot
"
snapshotId
}
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
outFilePath
=
HeapSnapshotFileUtils
.
getNewUniqueHeapSnapshotTempFilePath
(
)
;
const
outFile
=
new
FileUtils
.
File
(
outFilePath
)
;
const
outFileStream
=
FileUtils
.
openSafeFileOutputStream
(
outFile
)
;
request
.
on
(
"
bulk
-
reply
"
async
function
(
{
copyTo
}
)
{
await
copyTo
(
outFileStream
)
;
FileUtils
.
closeSafeFileOutputStream
(
outFileStream
)
;
resolve
(
outFilePath
)
;
}
)
;
}
)
;
}
)
}
)
;
exports
.
MemoryFront
=
MemoryFront
;
