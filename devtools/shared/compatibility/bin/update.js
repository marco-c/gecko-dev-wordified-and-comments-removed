"
use
strict
"
;
const
compatData
=
require
(
"
mdn
/
browser
-
compat
-
data
"
)
;
const
{
properties
}
=
compatData
.
css
;
const
{
TARGET_BROWSER_ID
}
=
require
(
"
.
.
/
constants
.
js
"
)
;
const
{
getCompatTable
}
=
require
(
"
.
.
/
helpers
.
js
"
)
;
flattenAliases
(
properties
)
;
parseBrowserVersion
(
properties
)
;
removeUnusedData
(
properties
)
;
exportData
(
properties
"
css
-
properties
.
json
"
)
;
function
flattenAliases
(
compatNode
)
{
for
(
const
term
in
compatNode
)
{
if
(
term
.
startsWith
(
"
_
"
)
)
{
continue
;
}
const
compatTable
=
getCompatTable
(
compatNode
[
term
]
)
;
if
(
compatTable
)
{
const
aliases
=
findAliasesFrom
(
compatTable
)
;
for
(
const
{
alternative_name
:
name
prefix
}
of
aliases
)
{
const
alias
=
name
|
|
prefix
+
term
;
compatNode
[
alias
]
=
{
_aliasOf
:
term
}
;
}
if
(
aliases
.
length
)
{
compatNode
[
term
]
.
_aliasOf
=
term
;
}
}
flattenAliases
(
compatNode
[
term
]
)
;
}
}
function
findAliasesFrom
(
compatTable
)
{
const
aliases
=
[
]
;
for
(
const
browser
in
compatTable
.
support
)
{
let
supportStates
=
compatTable
.
support
[
browser
]
|
|
[
]
;
supportStates
=
Array
.
isArray
(
supportStates
)
?
supportStates
:
[
supportStates
]
;
for
(
const
{
alternative_name
:
name
prefix
}
of
supportStates
)
{
if
(
!
prefix
&
&
!
name
)
{
continue
;
}
aliases
.
push
(
{
alternative_name
:
name
prefix
}
)
;
}
}
return
aliases
;
}
function
parseBrowserVersion
(
compatNode
)
{
for
(
const
term
in
compatNode
)
{
if
(
term
.
startsWith
(
"
_
"
)
)
{
continue
;
}
const
compatTable
=
getCompatTable
(
compatNode
[
term
]
)
;
if
(
compatTable
?
.
support
)
{
for
(
const
[
browserId
supportItem
]
of
Object
.
entries
(
compatTable
.
support
)
)
{
if
(
!
Array
.
isArray
(
supportItem
)
)
{
compatTable
.
support
[
browserId
]
=
[
supportItem
]
;
}
for
(
const
item
of
compatTable
.
support
[
browserId
]
)
{
replaceVersionsInBrowserSupport
(
item
)
;
}
}
}
parseBrowserVersion
(
compatNode
[
term
]
)
;
}
}
function
replaceVersionsInBrowserSupport
(
browserSupport
)
{
browserSupport
.
added
=
asFloatVersion
(
browserSupport
.
version_added
)
;
browserSupport
.
removed
=
asFloatVersion
(
browserSupport
.
version_removed
)
;
}
function
asFloatVersion
(
version
)
{
if
(
typeof
version
!
=
=
"
string
"
)
{
return
version
;
}
if
(
version
.
startsWith
(
"
\
u2264
"
)
)
{
version
=
version
.
substring
(
1
)
;
}
return
parseFloat
(
version
)
;
}
function
removeUnusedData
(
compatNode
)
{
for
(
const
term
in
compatNode
)
{
if
(
term
.
startsWith
(
"
_
"
)
)
{
continue
;
}
const
compatTable
=
getCompatTable
(
compatNode
[
term
]
)
;
if
(
compatTable
)
{
delete
compatTable
.
source_file
;
delete
compatTable
.
description
;
if
(
compatTable
?
.
support
)
{
for
(
const
[
browserId
supportItem
]
of
Object
.
entries
(
compatTable
.
support
)
)
{
if
(
!
TARGET_BROWSER_ID
.
includes
(
browserId
)
)
{
delete
compatTable
.
support
[
browserId
]
;
continue
;
}
for
(
const
item
of
supportItem
)
{
delete
item
.
version_added
;
delete
item
.
version_removed
;
delete
item
.
notes
;
}
}
}
}
removeUnusedData
(
compatNode
[
term
]
)
;
}
}
function
exportData
(
data
fileName
)
{
const
fs
=
require
(
"
fs
"
)
;
const
path
=
require
(
"
path
"
)
;
const
content
=
{
JSON
.
stringify
(
data
)
}
;
fs
.
writeFile
(
path
.
resolve
(
__dirname
"
.
.
/
dataset
"
fileName
)
content
err
=
>
{
if
(
err
)
{
console
.
error
(
err
)
;
}
else
{
console
.
log
(
{
fileName
}
downloaded
)
;
}
}
)
;
}
