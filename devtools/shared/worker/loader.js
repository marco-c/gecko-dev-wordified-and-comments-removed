"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
WorkerDebuggerLoader
"
"
worker
"
]
;
function
resolveId
(
id
baseId
)
{
return
baseId
+
"
/
.
.
/
"
+
id
;
}
function
normalizeId
(
id
)
{
let
[
root
path
]
=
id
.
match
(
/
^
(
\
w
+
:
\
/
\
/
\
/
?
|
\
/
)
?
(
.
*
)
/
)
;
let
stack
=
[
]
;
path
.
split
(
"
/
"
)
.
forEach
(
function
(
component
)
{
switch
(
component
)
{
case
"
"
:
case
"
.
"
:
break
;
case
"
.
.
"
:
if
(
stack
.
length
=
=
=
0
)
{
if
(
root
!
=
=
undefined
)
{
throw
new
Error
(
"
Can
'
t
normalize
absolute
id
'
"
+
id
+
"
'
!
"
)
;
}
else
{
stack
.
push
(
"
.
.
"
)
;
}
}
else
if
(
stack
[
stack
.
length
-
1
]
=
=
"
.
.
"
)
{
stack
.
push
(
"
.
.
"
)
;
}
else
{
stack
.
pop
(
)
;
}
break
;
default
:
stack
.
push
(
component
)
;
break
;
}
}
)
;
return
(
root
?
root
:
"
"
)
+
stack
.
join
(
"
/
"
)
;
}
function
createModule
(
id
)
{
return
Object
.
create
(
null
{
id
:
{
configurable
:
false
enumerable
:
true
value
:
id
writable
:
false
}
exports
:
{
configurable
:
false
enumerable
:
true
value
:
Object
.
create
(
null
)
writable
:
true
}
}
)
;
}
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
function
lazyRequire
(
obj
moduleId
.
.
.
args
)
{
let
module
;
let
getModule
=
(
)
=
>
{
if
(
!
module
)
{
module
=
this
.
require
(
moduleId
)
;
}
return
module
;
}
;
for
(
let
props
of
args
)
{
if
(
typeof
props
!
=
=
"
object
"
)
{
props
=
{
[
props
]
:
props
}
;
}
for
(
let
[
fromName
toName
]
of
Object
.
entries
(
props
)
)
{
defineLazyGetter
(
obj
toName
(
)
=
>
getModule
(
)
[
fromName
]
)
;
}
}
}
function
lazyRequireModule
(
obj
moduleId
prop
=
moduleId
)
{
defineLazyGetter
(
obj
prop
(
)
=
>
this
.
require
(
moduleId
)
)
;
}
function
WorkerDebuggerLoader
(
options
)
{
function
resolveURL
(
url
)
{
let
found
=
false
;
for
(
let
[
path
baseURL
]
of
paths
)
{
if
(
url
.
startsWith
(
path
)
)
{
found
=
true
;
url
=
url
.
replace
(
path
baseURL
)
;
break
;
}
}
if
(
!
found
)
{
throw
new
Error
(
"
Can
'
t
resolve
relative
URL
'
"
+
url
+
"
'
!
"
)
;
}
return
url
.
endsWith
(
"
.
js
"
)
?
url
:
url
+
"
.
js
"
;
}
function
loadModule
(
module
url
)
{
let
prototype
=
Object
.
create
(
globals
)
;
prototype
.
Components
=
{
}
;
prototype
.
require
=
createRequire
(
module
)
;
prototype
.
exports
=
module
.
exports
;
prototype
.
module
=
module
;
let
sandbox
=
createSandbox
(
url
prototype
)
;
try
{
loadSubScript
(
url
sandbox
)
;
}
catch
(
error
)
{
if
(
/
^
Error
opening
input
stream
/
.
test
(
String
(
error
)
)
)
{
throw
new
Error
(
"
Can
'
t
load
module
'
"
+
module
.
id
+
"
'
with
url
'
"
+
url
+
"
'
!
"
)
;
}
throw
error
;
}
if
(
typeof
module
.
exports
=
=
=
"
object
"
&
&
module
.
exports
!
=
=
null
)
{
Object
.
freeze
(
module
.
exports
)
;
}
}
function
createRequire
(
requirer
)
{
return
function
require
(
id
)
{
if
(
id
=
=
=
undefined
)
{
throw
new
Error
(
"
Can
'
t
require
module
without
id
!
"
)
;
}
let
module
=
modules
[
id
]
;
if
(
module
=
=
=
undefined
)
{
if
(
id
.
startsWith
(
"
.
"
)
)
{
if
(
requirer
=
=
=
undefined
)
{
throw
new
Error
(
"
Can
'
t
require
top
-
level
module
with
relative
id
"
+
"
'
"
+
id
+
"
'
!
"
)
;
}
id
=
resolve
(
id
requirer
.
id
)
;
}
id
=
normalizeId
(
id
)
;
let
url
=
id
;
if
(
url
.
match
(
/
^
\
w
+
:
\
/
\
/
/
)
=
=
=
null
)
{
url
=
resolveURL
(
id
)
;
}
module
=
modules
[
url
]
;
if
(
module
=
=
=
undefined
)
{
module
=
modules
[
url
]
=
createModule
(
id
)
;
try
{
loadModule
(
module
url
)
;
}
catch
(
error
)
{
delete
modules
[
url
]
;
throw
error
;
}
Object
.
freeze
(
module
)
;
}
}
return
module
.
exports
;
}
;
}
let
createSandbox
=
options
.
createSandbox
;
let
globals
=
options
.
globals
|
|
Object
.
create
(
null
)
;
let
loadSubScript
=
options
.
loadSubScript
;
let
modules
=
options
.
modules
|
|
{
}
;
for
(
let
id
in
modules
)
{
let
module
=
createModule
(
id
)
;
module
.
exports
=
Object
.
freeze
(
modules
[
id
]
)
;
modules
[
id
]
=
module
;
}
let
paths
=
options
.
paths
|
|
Object
.
create
(
null
)
;
paths
=
Object
.
keys
(
paths
)
.
sort
(
(
a
b
)
=
>
b
.
length
-
a
.
length
)
.
map
(
path
=
>
[
path
paths
[
path
]
]
)
;
let
resolve
=
options
.
resolve
|
|
resolveId
;
this
.
require
=
createRequire
(
)
;
}
this
.
WorkerDebuggerLoader
=
WorkerDebuggerLoader
;
var
chrome
=
{
CC
:
undefined
Cc
:
undefined
ChromeWorker
:
undefined
Cm
:
undefined
Ci
:
undefined
Cu
:
undefined
Cr
:
undefined
components
:
undefined
}
;
var
loader
=
{
lazyGetter
:
function
(
object
name
lambda
)
{
Object
.
defineProperty
(
object
name
{
get
:
function
(
)
{
delete
object
[
name
]
;
object
[
name
]
=
lambda
.
apply
(
object
)
;
return
object
[
name
]
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
lazyImporter
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
import
JSM
from
worker
thread
!
"
)
;
}
lazyServiceGetter
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
import
XPCOM
service
from
worker
thread
!
"
)
;
}
lazyRequireGetter
:
function
(
obj
property
module
destructure
)
{
Object
.
defineProperty
(
obj
property
{
get
:
(
)
=
>
destructure
?
worker
.
require
(
module
)
[
property
]
:
worker
.
require
(
module
|
|
property
)
}
)
;
}
}
;
var
{
Debugger
URL
createSandbox
dump
rpc
loadSubScript
reportError
setImmediate
xpcInspector
}
=
(
function
(
)
{
if
(
typeof
Components
=
=
=
"
object
"
)
{
let
{
Constructor
:
CC
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
let
principal
=
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
;
let
sandbox
=
Cu
.
Sandbox
(
principal
{
}
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
let
Debugger
=
sandbox
.
Debugger
;
let
createSandbox
=
function
(
name
prototype
)
{
return
Cu
.
Sandbox
(
principal
{
invisibleToDebugger
:
true
sandboxName
:
name
sandboxPrototype
:
prototype
wantComponents
:
false
wantXrays
:
false
}
)
;
}
;
let
rpc
=
undefined
;
let
subScriptLoader
=
Cc
[
"
mozilla
.
org
/
moz
/
jssubscript
-
loader
;
1
"
]
.
getService
(
Ci
.
mozIJSSubScriptLoader
)
;
let
loadSubScript
=
function
(
url
sandbox
)
{
subScriptLoader
.
loadSubScript
(
url
sandbox
"
UTF
-
8
"
)
;
}
;
let
reportError
=
Cu
.
reportError
;
let
Timer
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
let
setImmediate
=
function
(
callback
)
{
Timer
.
setTimeout
(
callback
0
)
;
}
;
let
xpcInspector
=
Cc
[
"
mozilla
.
org
/
jsinspector
;
1
"
]
.
getService
(
Ci
.
nsIJSInspector
)
;
return
{
Debugger
URL
:
this
.
URL
createSandbox
dump
:
this
.
dump
rpc
loadSubScript
reportError
setImmediate
xpcInspector
}
;
}
let
requestors
=
[
]
;
let
scope
=
this
;
let
xpcInspector
=
{
get
eventLoopNestLevel
(
)
{
return
requestors
.
length
;
}
get
lastNestRequestor
(
)
{
return
requestors
.
length
=
=
=
0
?
null
:
requestors
[
requestors
.
length
-
1
]
;
}
enterNestedEventLoop
:
function
(
requestor
)
{
requestors
.
push
(
requestor
)
;
scope
.
enterEventLoop
(
)
;
return
requestors
.
length
;
}
exitNestedEventLoop
:
function
(
)
{
requestors
.
pop
(
)
;
scope
.
leaveEventLoop
(
)
;
return
requestors
.
length
;
}
}
;
return
{
Debugger
:
this
.
Debugger
URL
:
this
.
URL
createSandbox
:
this
.
createSandbox
dump
:
this
.
dump
rpc
:
this
.
rpc
loadSubScript
:
this
.
loadSubScript
reportError
:
this
.
reportError
setImmediate
:
this
.
setImmediate
xpcInspector
:
xpcInspector
}
;
}
)
.
call
(
this
)
;
this
.
worker
=
new
WorkerDebuggerLoader
(
{
createSandbox
:
createSandbox
globals
:
{
"
isWorker
"
:
true
"
dump
"
:
dump
"
loader
"
:
loader
"
reportError
"
:
reportError
"
rpc
"
:
rpc
"
URL
"
:
URL
"
setImmediate
"
:
setImmediate
"
lazyRequire
"
:
lazyRequire
"
lazyRequireModule
"
:
lazyRequireModule
"
retrieveConsoleEvents
"
:
this
.
retrieveConsoleEvents
"
setConsoleEventHandler
"
:
this
.
setConsoleEventHandler
}
loadSubScript
:
loadSubScript
modules
:
{
"
Debugger
"
:
Debugger
"
Services
"
:
Object
.
create
(
null
)
"
chrome
"
:
chrome
"
xpcInspector
"
:
xpcInspector
}
paths
:
{
"
devtools
"
:
"
resource
:
/
/
devtools
"
"
promise
"
:
"
resource
:
/
/
gre
/
modules
/
Promise
-
backend
.
js
"
"
source
-
map
"
:
"
resource
:
/
/
devtools
/
shared
/
sourcemap
/
source
-
map
.
js
"
"
xpcshell
-
test
"
:
"
resource
:
/
/
test
"
}
}
)
;
