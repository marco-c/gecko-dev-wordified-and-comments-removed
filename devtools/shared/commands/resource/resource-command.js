"
use
strict
"
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
BROWSERTOOLBOX_FISSION_ENABLED
=
"
devtools
.
browsertoolbox
.
fission
"
;
let
gLastResourceId
=
0
;
function
cacheKey
(
resourceType
resourceId
)
{
return
{
resourceType
}
:
{
resourceId
}
;
}
class
ResourceCommand
{
constructor
(
{
commands
}
)
{
this
.
targetCommand
=
commands
.
targetCommand
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onResourceDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
)
;
this
.
_watchers
=
[
]
;
this
.
_pendingWatchers
=
new
Set
(
)
;
this
.
_cache
=
new
Map
(
)
;
this
.
_listenedResources
=
new
Set
(
)
;
this
.
_existingLegacyListeners
=
new
WeakMap
(
)
;
this
.
_processingExistingResources
=
new
Set
(
)
;
this
.
_offTargetFrontListeners
=
new
Map
(
)
;
this
.
_notifyWatchers
=
this
.
_notifyWatchers
.
bind
(
this
)
;
this
.
_throttledNotifyWatchers
=
throttle
(
this
.
_notifyWatchers
100
)
;
}
get
watcherFront
(
)
{
return
this
.
targetCommand
.
watcherFront
;
}
addResourceToCache
(
resource
)
{
const
{
resourceId
resourceType
}
=
resource
;
this
.
_cache
.
set
(
cacheKey
(
resourceType
resourceId
)
resource
)
;
}
async
clearResources
(
resourceTypes
)
{
if
(
!
Array
.
isArray
(
resourceTypes
)
)
{
throw
new
Error
(
"
clearResources
expects
a
list
of
resources
types
"
)
;
}
for
(
const
[
key
resource
]
of
this
.
_cache
)
{
if
(
resourceTypes
.
includes
(
resource
.
resourceType
)
)
{
this
.
_cache
.
delete
(
key
)
;
}
}
const
resourcesToClear
=
resourceTypes
.
filter
(
resourceType
=
>
this
.
hasResourceCommandSupport
(
resourceType
)
)
;
if
(
resourcesToClear
.
length
)
{
this
.
watcherFront
.
clearResources
(
resourcesToClear
)
;
}
}
getAllResources
(
resourceType
)
{
const
result
=
[
]
;
for
(
const
resource
of
this
.
_cache
.
values
(
)
)
{
if
(
resource
.
resourceType
=
=
=
resourceType
)
{
result
.
push
(
resource
)
;
}
}
return
result
;
}
getResourceById
(
resourceType
resourceId
)
{
return
this
.
_cache
.
get
(
cacheKey
(
resourceType
resourceId
)
)
;
}
async
watchResources
(
resources
options
)
{
const
{
onAvailable
onUpdated
onDestroyed
ignoreExistingResources
=
false
}
=
options
;
if
(
typeof
onAvailable
!
=
=
"
function
"
)
{
throw
new
Error
(
"
ResourceCommand
.
watchResources
expects
an
onAvailable
function
as
argument
"
)
;
}
for
(
const
type
of
resources
)
{
if
(
!
this
.
_isValidResourceType
(
type
)
)
{
throw
new
Error
(
ResourceCommand
.
watchResources
invoked
with
an
unknown
type
:
"
{
type
}
"
)
;
}
}
const
pendingWatcher
=
{
resources
onAvailable
}
;
this
.
_pendingWatchers
.
add
(
pendingWatcher
)
;
if
(
!
this
.
_listenerRegistered
&
&
this
.
watcherFront
)
{
this
.
_listenerRegistered
=
true
;
this
.
watcherFront
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
watcherFront
:
this
.
watcherFront
}
)
)
;
this
.
watcherFront
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
watcherFront
:
this
.
watcherFront
}
)
)
;
this
.
watcherFront
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
watcherFront
:
this
.
watcherFront
}
)
)
;
}
const
promises
=
[
]
;
for
(
const
resource
of
resources
)
{
promises
.
push
(
this
.
_startListening
(
resource
)
)
;
}
await
Promise
.
all
(
promises
)
;
this
.
_notifyWatchers
(
)
;
this
.
_pendingWatchers
.
delete
(
pendingWatcher
)
;
const
watchedResources
=
pendingWatcher
.
resources
;
if
(
!
watchedResources
.
length
)
{
return
;
}
this
.
_watchers
.
push
(
{
resources
:
watchedResources
onAvailable
onUpdated
onDestroyed
pendingEvents
:
[
]
}
)
;
if
(
!
ignoreExistingResources
)
{
await
this
.
_forwardExistingResources
(
watchedResources
onAvailable
)
;
}
}
unwatchResources
(
resources
options
)
{
const
{
onAvailable
}
=
options
;
if
(
typeof
onAvailable
!
=
=
"
function
"
)
{
throw
new
Error
(
"
ResourceCommand
.
unwatchResources
expects
an
onAvailable
function
as
argument
"
)
;
}
for
(
const
type
of
resources
)
{
if
(
!
this
.
_isValidResourceType
(
type
)
)
{
throw
new
Error
(
ResourceCommand
.
unwatchResources
invoked
with
an
unknown
type
:
"
{
type
}
"
)
;
}
}
const
allWatchers
=
[
.
.
.
this
.
_watchers
.
.
.
this
.
_pendingWatchers
]
;
for
(
const
watcherEntry
of
allWatchers
)
{
if
(
watcherEntry
.
onAvailable
=
=
onAvailable
)
{
watcherEntry
.
resources
=
watcherEntry
.
resources
.
filter
(
resourceType
=
>
{
return
!
resources
.
includes
(
resourceType
)
;
}
)
;
}
}
this
.
_watchers
=
this
.
_watchers
.
filter
(
entry
=
>
{
return
!
!
entry
.
resources
.
length
;
}
)
;
for
(
const
resource
of
resources
)
{
const
isResourceWatched
=
allWatchers
.
some
(
watcherEntry
=
>
watcherEntry
.
resources
.
includes
(
resource
)
)
;
if
(
!
isResourceWatched
&
&
this
.
_listenedResources
.
has
(
resource
)
)
{
this
.
_stopListening
(
resource
)
;
}
}
if
(
this
.
_listenedResources
.
size
=
=
0
)
{
this
.
_unwatchAllTargets
(
)
;
}
}
async
waitForNextResource
(
resourceType
{
ignoreExistingResources
=
false
predicate
}
=
{
}
)
{
predicate
=
predicate
|
|
(
resource
=
>
!
!
resource
)
;
let
resolve
;
const
promise
=
new
Promise
(
r
=
>
(
resolve
=
r
)
)
;
const
onAvailable
=
async
resources
=
>
{
const
matchingResource
=
resources
.
find
(
resource
=
>
predicate
(
resource
)
)
;
if
(
matchingResource
)
{
this
.
unwatchResources
(
[
resourceType
]
{
onAvailable
}
)
;
resolve
(
matchingResource
)
;
}
}
;
await
this
.
watchResources
(
[
resourceType
]
{
ignoreExistingResources
onAvailable
}
)
;
return
{
onResource
:
promise
}
;
}
isResourceWatched
(
resourceType
)
{
return
this
.
_listenedResources
.
has
(
resourceType
)
;
}
async
_watchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
this
.
_watchTargetsPromise
=
this
.
targetCommand
.
watchTargets
(
{
types
:
this
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
}
return
this
.
_watchTargetsPromise
;
}
_unwatchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
return
;
}
for
(
const
offList
of
this
.
_offTargetFrontListeners
.
values
(
)
)
{
offList
.
forEach
(
off
=
>
off
(
)
)
;
}
this
.
_offTargetFrontListeners
.
clear
(
)
;
this
.
_watchTargetsPromise
=
null
;
this
.
targetCommand
.
unwatchTargets
(
{
types
:
this
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
}
async
_startLegacyListenersForExistingTargets
(
resourceType
)
{
const
shouldRunLegacyListeners
=
!
this
.
hasResourceCommandSupport
(
resourceType
)
|
|
this
.
_shouldRunLegacyListenerEvenWithWatcherSupport
(
resourceType
)
;
if
(
shouldRunLegacyListeners
)
{
const
promises
=
[
]
;
const
targets
=
this
.
targetCommand
.
getAllTargets
(
this
.
targetCommand
.
ALL_TYPES
)
;
for
(
const
targetFront
of
targets
)
{
promises
.
push
(
this
.
_watchResourcesForTarget
(
{
targetFront
resourceType
disableWarning
:
true
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
}
async
_onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
const
resources
=
[
]
;
if
(
isTargetSwitching
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceCommand
.
TYPES
)
)
{
if
(
!
this
.
_listenedResources
.
has
(
resourceType
)
)
{
continue
;
}
if
(
this
.
_shouldRestartListenerOnTargetSwitching
(
resourceType
)
)
{
this
.
_stopListening
(
resourceType
{
bypassListenerCount
:
true
}
)
;
resources
.
push
(
resourceType
)
;
}
}
}
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
if
(
!
isTargetSwitching
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceCommand
.
TYPES
)
)
{
if
(
!
this
.
_listenedResources
.
has
(
resourceType
)
)
{
continue
;
}
await
this
.
_watchResourcesForTarget
(
{
targetFront
resourceType
}
)
;
}
}
const
offResourceAvailable
=
targetFront
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
)
;
const
offResourceUpdated
=
targetFront
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
)
;
const
offResourceDestroyed
=
targetFront
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
)
;
const
offList
=
this
.
_offTargetFrontListeners
.
get
(
targetFront
)
|
|
[
]
;
offList
.
push
(
offResourceAvailable
offResourceUpdated
offResourceDestroyed
)
;
if
(
isTargetSwitching
)
{
await
Promise
.
all
(
resources
.
map
(
resourceType
=
>
this
.
_startListening
(
resourceType
{
bypassListenerCount
:
true
}
)
)
)
;
}
if
(
!
this
.
targetCommand
.
hasTargetWatcherSupport
(
)
)
{
const
offWillNavigate
=
targetFront
.
on
(
"
will
-
navigate
"
(
{
url
isFrameSwitching
}
)
=
>
{
targetFront
.
emit
(
"
resource
-
available
-
form
"
[
{
resourceType
:
this
.
TYPES
.
DOCUMENT_EVENT
name
:
"
will
-
navigate
"
time
:
Date
.
now
(
)
isFrameSwitching
newURI
:
url
}
]
)
;
}
)
;
offList
.
push
(
offWillNavigate
)
;
}
this
.
_offTargetFrontListeners
.
set
(
targetFront
offList
)
;
}
_shouldRestartListenerOnTargetSwitching
(
resourceType
)
{
const
isServerSideTarget
=
this
.
targetCommand
.
targetFront
.
targetForm
.
followWindowGlobalLifeCycle
;
if
(
isServerSideTarget
)
{
return
!
this
.
hasResourceCommandSupport
(
resourceType
)
;
}
return
true
;
}
_onTargetDestroyed
(
{
targetFront
isModeSwitching
}
)
{
this
.
_existingLegacyListeners
.
set
(
targetFront
[
]
)
;
this
.
_offTargetFrontListeners
.
delete
(
targetFront
)
;
if
(
!
targetFront
.
isTopLevel
|
|
!
targetFront
.
isBrowsingContext
)
{
for
(
const
[
key
resource
]
of
this
.
_cache
)
{
if
(
resource
.
targetFront
=
=
=
targetFront
)
{
this
.
_cache
.
delete
(
key
)
;
}
}
}
if
(
isModeSwitching
)
{
for
(
const
watcherEntry
of
this
.
_watchers
)
{
for
(
const
pendingEvent
of
watcherEntry
.
pendingEvents
)
{
if
(
pendingEvent
.
callbackType
=
=
"
available
"
)
{
pendingEvent
.
updates
=
pendingEvent
.
updates
.
filter
(
update
=
>
update
.
targetFront
!
=
=
targetFront
)
;
}
}
}
}
}
async
_onResourceAvailable
(
{
targetFront
watcherFront
}
resources
)
{
let
includesDocumentEventWillNavigate
=
false
;
let
includesDocumentEventDomLoading
=
false
;
for
(
let
resource
of
resources
)
{
const
{
resourceType
}
=
resource
;
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
resource
)
;
if
(
targetFront
)
{
await
targetFront
.
initialized
;
}
}
resource
.
isAlreadyExistingResource
=
this
.
_processingExistingResources
.
has
(
resourceType
)
;
if
(
!
resource
.
targetFront
)
{
resource
.
targetFront
=
targetFront
;
}
if
(
ResourceTransformers
[
resourceType
]
)
{
resource
=
ResourceTransformers
[
resourceType
]
(
{
resource
targetCommand
:
this
.
targetCommand
targetFront
watcherFront
:
this
.
watcherFront
}
)
;
}
if
(
!
resource
.
resourceId
)
{
resource
.
resourceId
=
auto
:
{
+
+
gLastResourceId
}
;
}
const
isWillNavigate
=
resourceType
=
=
ResourceCommand
.
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
"
will
-
navigate
"
;
if
(
isWillNavigate
&
&
resource
.
targetFront
.
isTopLevel
)
{
includesDocumentEventWillNavigate
=
true
;
this
.
_onWillNavigate
(
resource
.
targetFront
)
;
}
if
(
resourceType
=
=
ResourceCommand
.
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
"
dom
-
loading
"
&
&
resource
.
targetFront
.
isTopLevel
)
{
includesDocumentEventDomLoading
=
true
;
}
this
.
_queueResourceEvent
(
"
available
"
resourceType
resource
)
;
if
(
!
isWillNavigate
)
{
this
.
addResourceToCache
(
resource
)
;
}
}
if
(
includesDocumentEventWillNavigate
|
|
(
includesDocumentEventDomLoading
&
&
!
this
.
targetCommand
.
hasTargetWatcherSupport
(
"
service_worker
"
)
)
)
{
this
.
_notifyWatchers
(
)
;
}
else
{
this
.
_throttledNotifyWatchers
(
)
;
}
}
async
_onResourceUpdated
(
{
targetFront
watcherFront
}
updates
)
{
for
(
const
update
of
updates
)
{
const
{
resourceType
resourceId
resourceUpdates
nestedResourceUpdates
}
=
update
;
if
(
!
resourceId
)
{
console
.
warn
(
Expected
resource
{
resourceType
}
to
have
a
resourceId
)
;
}
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
update
)
;
if
(
targetFront
)
{
await
targetFront
.
initialized
;
}
}
const
existingResource
=
this
.
_cache
.
get
(
cacheKey
(
resourceType
resourceId
)
)
;
if
(
!
existingResource
)
{
continue
;
}
if
(
resourceUpdates
)
{
Object
.
assign
(
existingResource
resourceUpdates
)
;
}
if
(
nestedResourceUpdates
)
{
for
(
const
{
path
value
}
of
nestedResourceUpdates
)
{
let
target
=
existingResource
;
for
(
let
i
=
0
;
i
<
path
.
length
-
1
;
i
+
+
)
{
target
=
target
[
path
[
i
]
]
;
}
target
[
path
[
path
.
length
-
1
]
]
=
value
;
}
}
this
.
_queueResourceEvent
(
"
updated
"
resourceType
{
resource
:
existingResource
update
}
)
;
}
this
.
_throttledNotifyWatchers
(
)
;
}
async
_onResourceDestroyed
(
{
targetFront
watcherFront
}
resources
)
{
for
(
const
resource
of
resources
)
{
const
{
resourceType
resourceId
}
=
resource
;
this
.
_cache
.
delete
(
cacheKey
(
resourceType
resourceId
)
)
;
this
.
_queueResourceEvent
(
"
destroyed
"
resourceType
resource
)
;
}
this
.
_throttledNotifyWatchers
(
)
;
}
_queueResourceEvent
(
callbackType
resourceType
update
)
{
for
(
const
{
resources
pendingEvents
}
of
this
.
_watchers
)
{
if
(
!
resources
.
includes
(
resourceType
)
)
{
continue
;
}
if
(
pendingEvents
.
length
)
{
const
lastEvent
=
pendingEvents
[
pendingEvents
.
length
-
1
]
;
if
(
lastEvent
.
callbackType
=
=
callbackType
)
{
lastEvent
.
updates
.
push
(
update
)
;
continue
;
}
}
pendingEvents
.
push
(
{
callbackType
updates
:
[
update
]
}
)
;
}
}
_notifyWatchers
(
)
{
for
(
const
watcherEntry
of
this
.
_watchers
)
{
const
{
onAvailable
onUpdated
onDestroyed
pendingEvents
}
=
watcherEntry
;
watcherEntry
.
pendingEvents
=
[
]
;
for
(
const
{
callbackType
updates
}
of
pendingEvents
)
{
try
{
if
(
callbackType
=
=
"
available
"
)
{
onAvailable
(
updates
{
areExistingResources
:
false
}
)
;
}
else
if
(
callbackType
=
=
"
updated
"
&
&
onUpdated
)
{
onUpdated
(
updates
)
;
}
else
if
(
callbackType
=
=
"
destroyed
"
&
&
onDestroyed
)
{
onDestroyed
(
updates
)
;
}
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
calling
a
ResourceCommand
"
callbackType
"
callback
"
"
:
"
e
)
;
}
}
}
}
_getTargetForWatcherResource
(
resource
)
{
const
{
browsingContextID
innerWindowId
resourceType
}
=
resource
;
if
(
browsingContextID
=
=
-
1
)
{
return
null
;
}
if
(
innerWindowId
&
&
this
.
targetCommand
.
isServerTargetSwitchingEnabled
(
)
)
{
return
this
.
watcherFront
.
getWindowGlobalTargetByInnerWindowId
(
innerWindowId
)
;
}
else
if
(
browsingContextID
)
{
return
this
.
watcherFront
.
getWindowGlobalTarget
(
browsingContextID
)
;
}
console
.
error
(
Resource
of
{
resourceType
}
is
missing
a
browsingContextID
or
innerWindowId
attribute
)
;
return
null
;
}
_onWillNavigate
(
targetFront
)
{
this
.
_cache
=
new
Map
(
)
;
}
hasResourceCommandSupport
(
resourceType
)
{
if
(
this
.
targetCommand
.
descriptorFront
.
isBrowserProcessDescriptor
&
&
!
Services
.
prefs
.
getBoolPref
(
BROWSERTOOLBOX_FISSION_ENABLED
false
)
)
{
return
false
;
}
return
this
.
watcherFront
?
.
traits
?
.
resources
?
.
[
resourceType
]
;
}
_hasResourceCommandSupportForTarget
(
resourceType
targetFront
)
{
if
(
!
this
.
targetCommand
.
hasTargetWatcherSupport
(
targetFront
.
targetType
)
)
{
return
false
;
}
return
this
.
hasResourceCommandSupport
(
resourceType
)
;
}
_isValidResourceType
(
type
)
{
return
this
.
ALL_TYPES
.
includes
(
type
)
;
}
async
_startListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
if
(
this
.
_listenedResources
.
has
(
resourceType
)
)
{
return
;
}
this
.
_listenedResources
.
add
(
resourceType
)
;
}
this
.
_processingExistingResources
.
add
(
resourceType
)
;
await
this
.
_watchAllTargets
(
resourceType
)
;
await
this
.
_startLegacyListenersForExistingTargets
(
resourceType
)
;
if
(
this
.
hasResourceCommandSupport
(
resourceType
)
)
{
await
this
.
watcherFront
.
watchResources
(
[
resourceType
]
)
;
}
this
.
_processingExistingResources
.
delete
(
resourceType
)
;
}
_shouldRunLegacyListenerEvenWithWatcherSupport
(
resourceType
)
{
return
(
resourceType
=
=
ResourceCommand
.
TYPES
.
SOURCE
|
|
resourceType
=
=
ResourceCommand
.
TYPES
.
THREAD_STATE
)
;
}
async
_forwardExistingResources
(
resourceTypes
onAvailable
)
{
const
existingResources
=
[
]
;
for
(
const
resource
of
this
.
_cache
.
values
(
)
)
{
if
(
resourceTypes
.
includes
(
resource
.
resourceType
)
)
{
existingResources
.
push
(
resource
)
;
}
}
if
(
existingResources
.
length
)
{
await
onAvailable
(
existingResources
{
areExistingResources
:
true
}
)
;
}
}
async
_watchResourcesForTarget
(
{
targetFront
resourceType
disableWarning
=
false
}
)
{
if
(
this
.
_hasResourceCommandSupportForTarget
(
resourceType
targetFront
)
)
{
return
;
}
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
const
onAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
;
const
onUpdated
=
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
;
const
onDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
;
if
(
!
(
resourceType
in
LegacyListeners
)
)
{
throw
new
Error
(
Missing
legacy
listener
for
{
resourceType
}
)
;
}
const
legacyListeners
=
this
.
_existingLegacyListeners
.
get
(
targetFront
)
|
|
[
]
;
if
(
legacyListeners
.
includes
(
resourceType
)
)
{
if
(
!
disableWarning
)
{
console
.
warn
(
Already
started
legacy
listener
for
{
resourceType
}
on
{
targetFront
.
actorID
}
)
;
}
return
;
}
this
.
_existingLegacyListeners
.
set
(
targetFront
legacyListeners
.
concat
(
resourceType
)
)
;
try
{
await
LegacyListeners
[
resourceType
]
(
{
targetCommand
:
this
.
targetCommand
targetFront
onAvailable
onDestroyed
onUpdated
}
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
start
[
{
resourceType
}
]
legacy
listener
for
target
{
targetFront
.
actorID
}
e
)
;
}
}
_stopListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
if
(
!
this
.
_listenedResources
.
has
(
resourceType
)
)
{
throw
new
Error
(
Stopped
listening
for
resource
'
{
resourceType
}
'
that
isn
'
t
being
listened
to
)
;
}
this
.
_listenedResources
.
delete
(
resourceType
)
;
}
for
(
const
[
key
resource
]
of
this
.
_cache
)
{
if
(
resource
.
resourceType
=
=
resourceType
)
{
this
.
_cache
.
delete
(
key
)
;
}
}
if
(
this
.
hasResourceCommandSupport
(
resourceType
)
)
{
if
(
!
this
.
watcherFront
.
isDestroyed
(
)
)
{
this
.
watcherFront
.
unwatchResources
(
[
resourceType
]
)
;
}
const
shouldRunLegacyListeners
=
this
.
_shouldRunLegacyListenerEvenWithWatcherSupport
(
resourceType
)
;
if
(
!
shouldRunLegacyListeners
)
{
return
;
}
}
const
targets
=
this
.
targetCommand
.
getAllTargets
(
this
.
targetCommand
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
this
.
_unwatchResourcesForTarget
(
target
resourceType
)
;
}
}
_unwatchResourcesForTarget
(
targetFront
resourceType
)
{
if
(
this
.
_hasResourceCommandSupportForTarget
(
resourceType
targetFront
)
)
{
}
const
listeners
=
this
.
_existingLegacyListeners
.
get
(
targetFront
)
;
if
(
listeners
&
&
listeners
.
includes
(
resourceType
)
)
{
const
remainingListeners
=
listeners
.
filter
(
l
=
>
l
!
=
=
resourceType
)
;
this
.
_existingLegacyListeners
.
set
(
targetFront
remainingListeners
)
;
}
}
}
ResourceCommand
.
TYPES
=
ResourceCommand
.
prototype
.
TYPES
=
{
CONSOLE_MESSAGE
:
"
console
-
message
"
CSS_CHANGE
:
"
css
-
change
"
CSS_MESSAGE
:
"
css
-
message
"
ERROR_MESSAGE
:
"
error
-
message
"
PLATFORM_MESSAGE
:
"
platform
-
message
"
CLONED_CONTENT_PROCESS_MESSAGE
:
"
cloned
-
content
-
process
-
message
"
DOCUMENT_EVENT
:
"
document
-
event
"
ROOT_NODE
:
"
root
-
node
"
STYLESHEET
:
"
stylesheet
"
NETWORK_EVENT
:
"
network
-
event
"
WEBSOCKET
:
"
websocket
"
COOKIE
:
"
cookies
"
LOCAL_STORAGE
:
"
local
-
storage
"
SESSION_STORAGE
:
"
session
-
storage
"
CACHE_STORAGE
:
"
Cache
"
EXTENSION_STORAGE
:
"
extension
-
storage
"
INDEXED_DB
:
"
indexed
-
db
"
NETWORK_EVENT_STACKTRACE
:
"
network
-
event
-
stacktrace
"
REFLOW
:
"
reflow
"
SOURCE
:
"
source
"
THREAD_STATE
:
"
thread
-
state
"
SERVER_SENT_EVENT
:
"
server
-
sent
-
event
"
}
;
ResourceCommand
.
ALL_TYPES
=
ResourceCommand
.
prototype
.
ALL_TYPES
=
Object
.
values
(
ResourceCommand
.
TYPES
)
;
module
.
exports
=
ResourceCommand
;
const
LegacyListeners
=
{
async
[
ResourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
(
{
targetCommand
targetFront
onAvailable
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
webConsoleFront
.
on
(
"
documentEvent
"
event
=
>
{
event
.
resourceType
=
ResourceCommand
.
TYPES
.
DOCUMENT_EVENT
;
onAvailable
(
[
event
]
)
;
}
)
;
await
webConsoleFront
.
startListeners
(
[
"
DocumentEvents
"
]
)
;
}
}
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
CONSOLE_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
console
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
CSS_CHANGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
css
-
changes
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
CSS_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
css
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
ERROR_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
error
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
PLATFORM_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
platform
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
CLONED_CONTENT_PROCESS_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
cloned
-
content
-
process
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
ROOT_NODE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
root
-
node
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
STYLESHEET
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
stylesheet
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
NETWORK_EVENT
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
network
-
events
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
WEBSOCKET
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
websocket
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
COOKIE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
cookie
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
CACHE_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
cache
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
LOCAL_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
local
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
SESSION_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
session
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
EXTENSION_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
extension
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
INDEXED_DB
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
indexed
-
db
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
NETWORK_EVENT_STACKTRACE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
network
-
event
-
stacktraces
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
SOURCE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
source
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
THREAD_STATE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
thread
-
states
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
SERVER_SENT_EVENT
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
server
-
sent
-
events
.
js
"
)
;
loader
.
lazyRequireGetter
(
LegacyListeners
ResourceCommand
.
TYPES
.
REFLOW
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
legacy
-
listeners
/
reflow
.
js
"
)
;
const
ResourceTransformers
=
{
}
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
CONSOLE_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
console
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
ERROR_MESSAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
error
-
messages
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
CACHE_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
storage
-
cache
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
COOKIE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
storage
-
cookie
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
INDEXED_DB
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
storage
-
indexed
-
db
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
LOCAL_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
storage
-
local
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
SESSION_STORAGE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
storage
-
session
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
NETWORK_EVENT
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
network
-
events
.
js
"
)
;
loader
.
lazyRequireGetter
(
ResourceTransformers
ResourceCommand
.
TYPES
.
THREAD_STATE
"
resource
:
/
/
devtools
/
shared
/
commands
/
resource
/
transformers
/
thread
-
states
.
js
"
)
;
