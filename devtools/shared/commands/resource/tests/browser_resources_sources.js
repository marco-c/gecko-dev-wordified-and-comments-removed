"
use
strict
"
;
const
ResourceCommand
=
require
(
"
devtools
/
shared
/
commands
/
resource
/
resource
-
command
"
)
;
const
TEST_URL
=
URL_ROOT_SSL
+
"
sources
.
html
"
;
const
TEST_JS_URL
=
URL_ROOT_SSL
+
"
sources
.
js
"
;
const
TEST_WORKER_URL
=
URL_ROOT_SSL
+
"
worker
-
sources
.
js
"
;
const
TEST_SW_URL
=
URL_ROOT_SSL
+
"
service
-
worker
-
sources
.
js
"
;
async
function
getExpectedResources
(
ignoreUnresurrectedSources
=
false
)
{
const
htmlRequest
=
await
fetch
(
TEST_URL
)
;
const
htmlContent
=
await
htmlRequest
.
text
(
)
;
const
expectedSources
=
[
{
description
:
"
eval
"
sourceForm
:
{
introductionType
:
"
eval
"
sourceMapBaseURL
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
this
.
global
=
function
evalFunction
(
)
{
}
"
}
}
{
description
:
"
new
Function
(
)
"
sourceForm
:
{
introductionType
:
"
Function
"
sourceMapBaseURL
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
return
42
;
"
}
}
{
description
:
"
Event
Handler
"
sourceForm
:
{
introductionType
:
"
eventHandler
"
sourceMapBaseURL
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
console
.
log
(
'
link
'
)
"
}
}
{
description
:
"
inline
JS
inserted
at
runtime
"
sourceForm
:
{
introductionType
:
"
scriptElement
"
sourceMapBaseURL
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
console
.
log
(
'
inline
-
script
'
)
"
}
}
{
description
:
"
inline
JS
"
sourceForm
:
{
introductionType
:
"
scriptElement
"
sourceMapBaseURL
:
TEST_URL
url
:
TEST_URL
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
true
}
sourceContent
:
{
contentType
:
"
text
/
html
"
source
:
htmlContent
}
}
{
description
:
"
worker
script
"
sourceForm
:
{
introductionType
:
undefined
sourceMapBaseURL
:
TEST_WORKER_URL
url
:
TEST_WORKER_URL
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
/
*
eslint
-
disable
*
/
\
nfunction
workerSource
(
)
{
}
\
n
"
}
}
{
description
:
"
service
worker
script
"
sourceForm
:
{
introductionType
:
undefined
sourceMapBaseURL
:
TEST_SW_URL
url
:
TEST_SW_URL
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
/
*
eslint
-
disable
*
/
\
nfunction
serviceWorkerSource
(
)
{
}
\
n
"
}
}
{
description
:
"
independent
js
file
"
sourceForm
:
{
introductionType
:
"
scriptElement
"
sourceMapBaseURL
:
TEST_JS_URL
url
:
TEST_JS_URL
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
/
*
eslint
-
disable
*
/
\
nfunction
scriptSource
(
)
{
}
\
n
"
}
}
]
;
const
unresurrectedSources
=
[
{
description
:
"
DOM
Timer
"
sourceForm
:
{
introductionType
:
"
domTimer
"
sourceMapBaseURL
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
new
Array
(
39
)
.
join
(
"
\
n
"
)
+
console
.
log
(
"
timeout
"
)
}
}
{
description
:
"
javascript
URL
"
sourceForm
:
{
introductionType
:
"
javascriptURL
"
sourceMapBaseURL
:
isEveryFrameTargetEnabled
(
)
?
"
about
:
blank
"
:
TEST_URL
url
:
null
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
666
"
}
}
{
description
:
"
srcdoc
attribute
on
iframes
#
1
"
sourceForm
:
{
introductionType
:
"
scriptElement
"
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
console
.
log
(
'
srcdoc
'
)
"
}
}
{
description
:
"
srcdoc
attribute
on
iframes
#
2
"
sourceForm
:
{
introductionType
:
"
scriptElement
"
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
console
.
log
(
'
srcdoc
2
'
)
"
}
}
]
;
if
(
ignoreUnresurrectedSources
)
{
return
expectedSources
;
}
return
expectedSources
.
concat
(
unresurrectedSources
)
;
}
add_task
(
async
function
testSourcesOnload
(
)
{
const
tab
=
await
addTab
(
"
about
:
blank
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
{
targetCommand
resourceCommand
}
=
commands
;
targetCommand
.
listenForWorkers
=
true
;
targetCommand
.
listenForServiceWorkers
=
true
;
await
targetCommand
.
startListening
(
)
;
info
(
"
Check
already
available
resources
"
)
;
const
availableResources
=
[
]
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
resources
=
>
availableResources
.
push
(
.
.
.
resources
)
}
)
;
await
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
TEST_URL
)
;
const
expectedResources
=
await
getExpectedResources
(
)
;
await
waitFor
(
(
)
=
>
availableResources
.
length
>
=
expectedResources
.
length
"
Got
all
the
sources
"
)
;
await
assertResources
(
availableResources
expectedResources
)
;
await
commands
.
destroy
(
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
registration
=
await
content
.
wrappedJSObject
.
registrationPromise
;
registration
.
unregister
(
)
;
}
)
;
}
)
;
add_task
(
async
function
testGarbagedCollectedSources
(
)
{
info
(
"
Assert
SOURCES
on
an
already
loaded
page
with
some
sources
that
have
been
GC
-
ed
"
)
;
const
tab
=
await
addTab
(
TEST_URL
)
;
info
(
"
Force
some
GC
to
free
some
sources
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
}
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
{
targetCommand
resourceCommand
}
=
commands
;
targetCommand
.
listenForWorkers
=
true
;
targetCommand
.
listenForServiceWorkers
=
true
;
await
targetCommand
.
startListening
(
)
;
info
(
"
Check
already
available
resources
"
)
;
const
availableResources
=
[
]
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
resources
=
>
availableResources
.
push
(
.
.
.
resources
)
}
)
;
const
expectedResources
=
await
getExpectedResources
(
true
)
;
await
waitFor
(
(
)
=
>
availableResources
.
length
>
=
expectedResources
.
length
"
Got
all
the
sources
"
)
;
await
assertResources
(
availableResources
expectedResources
)
;
await
commands
.
destroy
(
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
registration
=
await
content
.
wrappedJSObject
.
registrationPromise
;
registration
.
unregister
(
)
;
}
)
;
}
)
;
add_task
(
async
function
testParentProcessPrivilegedSources
(
)
{
const
client
=
await
CommandsFactory
.
spawnClientToDebugSystemPrincipal
(
)
;
const
commands
=
await
CommandsFactory
.
forMainProcess
(
{
client
}
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
{
resourceCommand
}
=
commands
;
info
(
"
Check
already
available
resources
"
)
;
const
availableResources
=
[
]
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
resources
=
>
availableResources
.
push
(
.
.
.
resources
)
}
)
;
ok
(
!
!
availableResources
.
length
"
We
get
many
sources
reported
from
a
multiprocess
command
"
)
;
availableResources
.
length
=
0
;
const
systemPrincipal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
const
sandbox
=
Cu
.
Sandbox
(
systemPrincipal
)
;
Cu
.
evalInSandbox
(
"
function
foo
(
)
{
}
"
sandbox
null
"
http
:
/
/
foo
.
com
"
)
;
info
(
"
Wait
for
the
sandbox
source
"
)
;
await
waitFor
(
(
)
=
>
{
return
availableResources
.
some
(
resource
=
>
resource
.
url
=
=
"
http
:
/
/
foo
.
com
/
"
)
;
}
)
;
const
expectedResources
=
[
{
description
:
"
privileged
sandbox
script
"
sourceForm
:
{
introductionType
:
undefined
sourceMapBaseURL
:
"
http
:
/
/
foo
.
com
/
"
url
:
"
http
:
/
/
foo
.
com
/
"
isBlackBoxed
:
false
sourceMapURL
:
null
extensionName
:
null
isInlineSource
:
false
}
sourceContent
:
{
contentType
:
"
text
/
javascript
"
source
:
"
function
foo
(
)
{
}
"
}
}
]
;
const
matchingResource
=
availableResources
.
filter
(
resource
=
>
resource
.
url
.
includes
(
"
http
:
/
/
foo
.
com
"
)
)
;
await
assertResources
(
matchingResource
expectedResources
)
;
await
commands
.
destroy
(
)
;
}
)
;
async
function
assertResources
(
resources
expected
)
{
is
(
resources
.
length
expected
.
length
"
Length
of
existing
resources
is
correct
at
initial
"
)
;
for
(
let
i
=
0
;
i
<
resources
.
length
;
i
+
+
)
{
await
assertResource
(
resources
[
i
]
expected
)
;
}
}
async
function
assertResource
(
source
expected
)
{
is
(
source
.
resourceType
ResourceCommand
.
TYPES
.
SOURCE
"
Resource
type
is
correct
"
)
;
const
threadFront
=
await
source
.
targetFront
.
getFront
(
"
thread
"
)
;
const
sourceFront
=
threadFront
.
source
(
source
)
;
const
sourceContent
=
await
sourceFront
.
source
(
)
;
const
matchingExpected
=
expected
.
find
(
res
=
>
{
return
res
.
sourceContent
.
source
=
=
sourceContent
.
source
;
}
)
;
ok
(
matchingExpected
This
source
was
expected
with
source
content
being
"
{
sourceContent
.
source
}
"
)
;
info
(
Found
"
#
{
matchingExpected
.
description
}
"
)
;
assertObject
(
sourceContent
matchingExpected
.
sourceContent
matchingExpected
.
description
)
;
assertObject
(
source
matchingExpected
.
sourceForm
matchingExpected
.
description
)
;
}
function
assertObject
(
object
expected
description
)
{
for
(
const
field
in
expected
)
{
is
(
object
[
field
]
expected
[
field
]
The
value
of
{
field
}
is
correct
for
"
#
{
description
}
"
)
;
}
}
