"
use
strict
"
;
class
ObjectCommand
{
constructor
(
{
commands
descriptorFront
watcherFront
}
)
{
this
.
#
commands
=
commands
;
}
#
commands
=
null
;
async
releaseObjects
(
frontsToRelease
)
{
const
{
supportsReleaseActors
}
=
this
.
#
commands
.
client
.
mainRoot
.
traits
;
const
actorsPerTarget
=
new
Map
(
)
;
const
promises
=
[
]
;
for
(
const
frontToRelease
of
frontsToRelease
)
{
const
{
targetFront
}
=
frontToRelease
;
if
(
!
targetFront
)
{
continue
;
}
let
actorIDsToRemove
=
actorsPerTarget
.
get
(
targetFront
)
;
if
(
!
actorIDsToRemove
)
{
actorIDsToRemove
=
[
]
;
actorsPerTarget
.
set
(
targetFront
actorIDsToRemove
)
;
}
if
(
supportsReleaseActors
)
{
actorIDsToRemove
.
push
(
frontToRelease
.
actorID
)
;
frontToRelease
.
destroy
(
)
;
}
else
{
promises
.
push
(
frontToRelease
.
release
(
)
)
;
}
}
if
(
supportsReleaseActors
)
{
for
(
const
[
targetFront
actorIDs
]
of
actorsPerTarget
)
{
const
objectsManagerFront
=
await
targetFront
.
getFront
(
"
objects
-
manager
"
)
;
promises
.
push
(
objectsManagerFront
.
releaseObjects
(
actorIDs
)
)
;
}
}
await
Promise
.
all
(
promises
)
;
}
}
module
.
exports
=
ObjectCommand
;
