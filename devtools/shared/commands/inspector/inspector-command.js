"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
getTargetBrowsers
"
"
resource
:
/
/
devtools
/
shared
/
compatibility
/
compatibility
-
user
-
settings
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TARGET_BROWSER_PREF
"
"
resource
:
/
/
devtools
/
shared
/
compatibility
/
constants
.
js
"
true
)
;
class
InspectorCommand
{
constructor
(
{
commands
}
)
{
this
.
commands
=
commands
;
}
#
cssDeclarationBlockIssuesQueuedDomRulesDeclarations
=
[
]
;
#
cssDeclarationBlockIssuesPendingTimeoutPromise
;
#
cssDeclarationBlockIssuesTargetBrowsersPromise
;
async
getAllInspectorFronts
(
)
{
return
this
.
commands
.
targetCommand
.
getAllFronts
(
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
"
inspector
"
)
;
}
async
walkerSearch
(
walkerFront
query
options
=
{
}
)
{
const
result
=
await
walkerFront
.
search
(
query
options
)
;
return
result
.
list
.
items
(
)
;
}
async
findNextNode
(
query
{
reverse
}
=
{
}
)
{
const
inspectors
=
await
this
.
getAllInspectorFronts
(
)
;
const
nodes
=
await
Promise
.
all
(
inspectors
.
map
(
(
{
walker
}
)
=
>
this
.
walkerSearch
(
walker
query
{
reverse
}
)
)
)
;
const
results
=
nodes
.
flat
(
)
;
if
(
this
.
_searchQuery
!
=
=
query
)
{
this
.
_searchQuery
=
query
;
this
.
_currentIndex
=
-
1
;
}
if
(
!
results
.
length
)
{
return
null
;
}
this
.
_currentIndex
=
reverse
?
this
.
_currentIndex
-
1
:
this
.
_currentIndex
+
1
;
if
(
this
.
_currentIndex
>
=
results
.
length
)
{
this
.
_currentIndex
=
0
;
}
if
(
this
.
_currentIndex
<
0
)
{
this
.
_currentIndex
=
results
.
length
-
1
;
}
return
{
node
:
results
[
this
.
_currentIndex
]
resultsIndex
:
this
.
_currentIndex
resultsLength
:
results
.
length
}
;
}
async
getSuggestionsForQuery
(
query
firstPart
state
)
{
const
inspectors
=
await
this
.
getAllInspectorFronts
(
)
;
const
mergedSuggestions
=
[
]
;
await
Promise
.
all
(
inspectors
.
map
(
async
(
{
walker
}
)
=
>
{
const
{
suggestions
}
=
await
walker
.
getSuggestionsForQuery
(
query
firstPart
state
)
;
for
(
const
[
suggestion
count
type
]
of
suggestions
)
{
const
existing
=
mergedSuggestions
.
find
(
(
[
s
t
]
)
=
>
s
=
=
suggestion
&
&
t
=
=
type
)
;
if
(
existing
)
{
existing
[
1
]
+
=
count
;
}
else
{
mergedSuggestions
.
push
(
[
suggestion
count
type
]
)
;
}
}
}
)
)
;
return
sortSuggestions
(
mergedSuggestions
)
;
}
async
findNodeFrontFromSelectors
(
nodeSelectors
timeoutInMs
=
5000
)
{
if
(
!
nodeSelectors
|
|
!
Array
.
isArray
(
nodeSelectors
)
|
|
nodeSelectors
.
length
=
=
=
0
)
{
console
.
warn
(
"
findNodeFrontFromSelectors
expect
a
non
-
empty
array
but
got
"
nodeSelectors
)
;
return
null
;
}
const
{
walker
}
=
await
this
.
commands
.
targetCommand
.
targetFront
.
getFront
(
"
inspector
"
)
;
nodeSelectors
=
[
.
.
.
nodeSelectors
]
;
const
querySelectors
=
async
nodeFront
=
>
{
const
selector
=
nodeSelectors
.
shift
(
)
;
if
(
!
selector
)
{
return
nodeFront
;
}
nodeFront
=
await
nodeFront
.
walkerFront
.
querySelector
(
nodeFront
selector
)
;
if
(
!
nodeFront
)
{
return
null
;
}
if
(
nodeSelectors
.
length
)
{
if
(
!
nodeFront
.
isShadowHost
)
{
await
this
.
#
waitForFrameLoad
(
nodeFront
)
;
}
const
{
nodes
}
=
await
walker
.
children
(
nodeFront
)
;
nodeFront
=
nodes
.
find
(
node
=
>
{
const
{
nodeType
}
=
node
;
return
(
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
|
|
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
;
}
)
;
if
(
!
nodeFront
)
{
return
null
;
}
}
const
childrenNodeFront
=
await
querySelectors
(
nodeFront
)
;
return
childrenNodeFront
|
|
nodeFront
;
}
;
const
rootNodeFront
=
await
walker
.
getRootNode
(
)
;
const
onTimeout
=
new
Promise
(
res
=
>
setTimeout
(
res
timeoutInMs
)
)
.
then
(
(
)
=
>
null
)
;
const
onQuerySelectors
=
querySelectors
(
rootNodeFront
)
;
return
Promise
.
race
(
[
onTimeout
onQuerySelectors
]
)
;
}
async
#
waitForFrameLoad
(
nodeFront
)
{
const
domLoadingPromises
=
[
]
;
if
(
!
nodeFront
.
useChildTargetToFetchChildren
)
{
domLoadingPromises
.
push
(
nodeFront
.
waitForFrameLoad
(
)
)
;
}
const
{
onResource
:
onDomInteractiveResource
}
=
await
this
.
commands
.
resourceCommand
.
waitForNextResource
(
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
predicate
:
resource
=
>
resource
.
name
=
=
"
dom
-
interactive
"
&
&
resource
.
targetFront
!
=
=
nodeFront
.
targetFront
&
&
resource
.
targetFront
.
browsingContextID
=
=
nodeFront
.
browsingContextID
}
)
;
const
newTargetResolveValue
=
Symbol
(
)
;
domLoadingPromises
.
push
(
onDomInteractiveResource
.
then
(
(
)
=
>
newTargetResolveValue
)
)
;
const
loadResult
=
await
Promise
.
any
(
domLoadingPromises
)
;
if
(
loadResult
=
=
newTargetResolveValue
)
{
nodeFront
.
_form
.
useChildTargetToFetchChildren
=
true
;
}
}
async
getNodeFrontSelectorsFromTopDocument
(
nodeFront
)
{
const
selectors
=
[
]
;
let
currentNode
=
nodeFront
;
while
(
currentNode
)
{
const
selector
=
await
currentNode
.
getUniqueSelector
(
)
;
selectors
.
unshift
(
selector
)
;
const
rootNode
=
currentNode
.
getOwnerRootNodeFront
(
)
;
currentNode
=
rootNode
?
.
parentOrHost
(
)
;
}
return
selectors
;
}
#
updateTargetBrowsersCache
=
async
(
)
=
>
{
this
.
#
cssDeclarationBlockIssuesTargetBrowsersPromise
=
getTargetBrowsers
(
)
;
}
;
async
getCSSDeclarationBlockIssues
(
domRuleDeclarations
)
{
const
nonCustomPropertyDeclarations
=
domRuleDeclarations
.
filter
(
decl
=
>
!
decl
.
isCustomProperty
)
;
const
resultIndex
=
this
.
#
cssDeclarationBlockIssuesQueuedDomRulesDeclarations
.
length
;
this
.
#
cssDeclarationBlockIssuesQueuedDomRulesDeclarations
.
push
(
nonCustomPropertyDeclarations
)
;
if
(
!
this
.
#
cssDeclarationBlockIssuesTargetBrowsersPromise
)
{
this
.
#
updateTargetBrowsersCache
(
)
;
Services
.
prefs
.
addObserver
(
TARGET_BROWSER_PREF
this
.
#
updateTargetBrowsersCache
)
;
}
if
(
!
this
.
#
cssDeclarationBlockIssuesPendingTimeoutPromise
)
{
this
.
#
cssDeclarationBlockIssuesPendingTimeoutPromise
=
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
this
.
#
cssDeclarationBlockIssuesPendingTimeoutPromise
=
null
;
this
.
#
batchedGetCSSDeclarationBlockIssues
(
)
.
then
(
data
=
>
resolve
(
data
)
)
;
}
50
)
;
}
)
;
}
const
results
=
await
this
.
#
cssDeclarationBlockIssuesPendingTimeoutPromise
;
return
results
?
.
[
resultIndex
]
|
|
[
]
;
}
#
batchedGetCSSDeclarationBlockIssues
=
async
(
)
=
>
{
const
declarations
=
this
.
#
cssDeclarationBlockIssuesQueuedDomRulesDeclarations
;
this
.
#
cssDeclarationBlockIssuesQueuedDomRulesDeclarations
=
[
]
;
const
{
targetFront
}
=
this
.
commands
.
targetCommand
;
try
{
const
inspectorFront
=
await
targetFront
.
getFront
(
"
inspector
"
)
;
const
[
compatibilityFront
targetBrowsers
]
=
await
Promise
.
all
(
[
inspectorFront
.
getCompatibilityFront
(
)
this
.
#
cssDeclarationBlockIssuesTargetBrowsersPromise
]
)
;
const
data
=
await
compatibilityFront
.
getCSSDeclarationBlockIssues
(
declarations
targetBrowsers
)
;
return
data
;
}
catch
(
e
)
{
if
(
this
.
destroyed
|
|
targetFront
.
isDestroyed
(
)
)
{
return
[
]
;
}
throw
e
;
}
}
;
destroy
(
)
{
Services
.
prefs
.
removeObserver
(
TARGET_BROWSER_PREF
this
.
#
updateTargetBrowsersCache
)
;
this
.
destroyed
=
true
;
}
}
function
sortSuggestions
(
suggestions
)
{
const
sorted
=
suggestions
.
sort
(
(
a
b
)
=
>
{
let
sortA
=
10000
-
a
[
1
]
+
a
[
0
]
;
let
sortB
=
10000
-
b
[
1
]
+
b
[
0
]
;
const
firstA
=
a
[
0
]
.
substring
(
0
1
)
;
const
firstB
=
b
[
0
]
.
substring
(
0
1
)
;
const
getSortKeyPrefix
=
firstLetter
=
>
{
if
(
firstLetter
=
=
=
"
#
"
)
{
return
"
2
"
;
}
if
(
firstLetter
=
=
=
"
.
"
)
{
return
"
1
"
;
}
return
"
0
"
;
}
;
sortA
=
getSortKeyPrefix
(
firstA
)
+
sortA
;
sortB
=
getSortKeyPrefix
(
firstB
)
+
sortB
;
return
sortA
.
localeCompare
(
sortB
)
;
}
)
;
return
sorted
.
slice
(
0
25
)
;
}
module
.
exports
=
InspectorCommand
;
