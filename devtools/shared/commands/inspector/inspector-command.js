"
use
strict
"
;
class
InspectorCommand
{
constructor
(
{
commands
}
)
{
this
.
commands
=
commands
;
}
async
getAllInspectorFronts
(
)
{
return
this
.
commands
.
targetCommand
.
getAllFronts
(
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
"
inspector
"
)
;
}
async
getSuggestionsForQuery
(
query
firstPart
state
)
{
const
inspectors
=
await
this
.
getAllInspectorFronts
(
)
;
const
mergedSuggestions
=
[
]
;
await
Promise
.
all
(
inspectors
.
map
(
async
(
{
walker
}
)
=
>
{
const
{
suggestions
}
=
await
walker
.
getSuggestionsForQuery
(
query
firstPart
state
)
;
for
(
const
[
suggestion
count
type
]
of
suggestions
)
{
const
existing
=
mergedSuggestions
.
find
(
(
[
s
t
]
)
=
>
s
=
=
suggestion
&
&
t
=
=
type
)
;
if
(
existing
)
{
existing
[
1
]
+
=
count
;
}
else
{
mergedSuggestions
.
push
(
[
suggestion
count
type
]
)
;
}
}
}
)
)
;
return
sortSuggestions
(
mergedSuggestions
)
;
}
}
function
sortSuggestions
(
suggestions
)
{
const
sorted
=
suggestions
.
sort
(
(
a
b
)
=
>
{
let
sortA
=
10000
-
a
[
1
]
+
a
[
0
]
;
let
sortB
=
10000
-
b
[
1
]
+
b
[
0
]
;
const
firstA
=
a
[
0
]
.
substring
(
0
1
)
;
const
firstB
=
b
[
0
]
.
substring
(
0
1
)
;
const
getSortKeyPrefix
=
firstLetter
=
>
{
if
(
firstLetter
=
=
=
"
#
"
)
{
return
"
2
"
;
}
if
(
firstLetter
=
=
=
"
.
"
)
{
return
"
1
"
;
}
return
"
0
"
;
}
;
sortA
=
getSortKeyPrefix
(
firstA
)
+
sortA
;
sortB
=
getSortKeyPrefix
(
firstB
)
+
sortB
;
return
sortA
.
localeCompare
(
sortB
)
;
}
)
;
return
sorted
.
slice
(
0
25
)
;
}
module
.
exports
=
InspectorCommand
;
