"
use
strict
"
;
const
COM_PAGE_URL
=
URL_ROOT_SSL
+
"
test_sw_page
.
html
"
;
const
COM_WORKER_URL
=
URL_ROOT_SSL
+
"
test_sw_page_worker
.
js
"
;
const
ORG_PAGE_URL
=
URL_ROOT_ORG_SSL
+
"
test_sw_page
.
html
"
;
const
ORG_WORKER_URL
=
URL_ROOT_ORG_SSL
+
"
test_sw_page_worker
.
js
"
;
add_task
(
async
function
test_NavigationBetweenTwoDomains_NoDestroy
(
)
{
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
const
{
hooks
commands
targetCommand
}
=
await
watchServiceWorkerTargets
(
tab
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Go
to
.
org
page
wait
for
onAvailable
to
be
called
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
.
selectedBrowser
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
0
targets
:
[
COM_WORKER_URL
ORG_WORKER_URL
]
}
)
;
info
(
"
Reload
.
org
page
onAvailable
and
onDestroyed
should
not
be
called
"
)
;
await
BrowserTestUtils
.
reloadTab
(
gBrowser
.
selectedTab
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
0
targets
:
[
COM_WORKER_URL
ORG_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
org
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
ORG_WORKER_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Go
back
to
.
com
page
"
)
;
const
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
.
selectedBrowser
COM_PAGE_URL
)
;
await
onBrowserLoaded
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
com
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
COM_WORKER_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
2
targets
:
[
]
}
)
;
targetCommand
.
destroy
(
)
;
await
commands
.
waitForRequestsToSettle
(
)
;
await
commands
.
destroy
(
)
;
await
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_NavigationToPageWithExistingWorker
(
)
{
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
info
(
"
Wait
until
the
service
worker
registration
is
registered
"
)
;
await
waitForRegistrationReady
(
tab
COM_PAGE_URL
COM_WORKER_URL
)
;
info
(
"
Navigate
to
another
page
"
)
;
let
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
.
selectedBrowser
ORG_PAGE_URL
)
;
info
(
"
Wait
until
we
have
fully
navigated
to
the
.
org
page
"
)
;
await
onBrowserLoaded
;
await
waitForRegistrationReady
(
tab
ORG_PAGE_URL
ORG_WORKER_URL
)
;
const
{
hooks
commands
targetCommand
}
=
await
watchServiceWorkerTargets
(
tab
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
ORG_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
org
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
ORG_WORKER_URL
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
1
targets
:
[
]
}
)
;
info
(
"
Go
back
.
com
page
wait
for
onAvailable
to
be
called
"
)
;
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
.
selectedBrowser
COM_PAGE_URL
)
;
await
onBrowserLoaded
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
com
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
COM_WORKER_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
2
targets
:
[
]
}
)
;
targetCommand
.
destroy
(
)
;
await
commands
.
waitForRequestsToSettle
(
)
;
await
commands
.
destroy
(
)
;
await
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_NavigationToPageWithExistingStoppedWorker
(
)
{
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
info
(
"
Wait
until
the
service
worker
registration
is
registered
"
)
;
await
waitForRegistrationReady
(
tab
COM_PAGE_URL
COM_WORKER_URL
)
;
await
stopServiceWorker
(
COM_WORKER_URL
)
;
const
{
hooks
commands
targetCommand
}
=
await
watchServiceWorkerTargets
(
tab
)
;
await
wait
(
1000
)
;
info
(
"
Verify
that
no
SW
is
reported
after
it
has
been
stopped
and
we
start
watching
for
service
workers
"
)
;
await
checkHooks
(
hooks
{
available
:
0
destroyed
:
0
targets
:
[
]
}
)
;
info
(
"
Reload
the
worker
module
via
the
postMessage
call
"
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
async
function
(
)
{
const
registration
=
await
content
.
wrappedJSObject
.
registrationPromise
;
registration
.
active
.
postMessage
(
"
"
)
;
}
)
;
info
(
"
Verify
that
the
SW
is
notified
"
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
COM_WORKER_URL
]
}
)
;
await
unregisterServiceWorker
(
COM_WORKER_URL
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
1
targets
:
[
]
}
)
;
targetCommand
.
destroy
(
)
;
await
commands
.
waitForRequestsToSettle
(
)
;
await
commands
.
destroy
(
)
;
await
removeTab
(
tab
)
;
}
)
;
async
function
setupServiceWorkerNavigationTest
(
)
{
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
}
async
function
watchServiceWorkerTargets
(
tab
)
{
info
(
"
Create
a
target
list
for
a
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
targetCommand
=
commands
.
targetCommand
;
targetCommand
.
listenForServiceWorkers
=
true
;
await
targetCommand
.
startListening
(
)
;
const
hooks
=
{
availableCount
:
0
destroyedCount
:
0
targets
:
[
]
}
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
info
(
+
Service
worker
target
available
for
{
targetFront
.
url
}
\
n
)
;
hooks
.
availableCount
+
+
;
hooks
.
targets
.
push
(
targetFront
)
;
}
;
const
onDestroyed
=
(
{
targetFront
}
)
=
>
{
info
(
-
Service
worker
target
destroy
for
{
targetFront
.
url
}
\
n
)
;
hooks
.
destroyedCount
+
+
;
hooks
.
targets
.
splice
(
hooks
.
targets
.
indexOf
(
targetFront
)
1
)
;
}
;
await
targetCommand
.
watchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
SERVICE_WORKER
]
onAvailable
onDestroyed
}
)
;
return
{
hooks
commands
targetCommand
}
;
}
async
function
waitForRegistrationReady
(
tab
expectedPageUrl
workerUrl
)
{
await
asyncWaitUntil
(
(
)
=
>
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
expectedPageUrl
]
function
(
_url
)
{
try
{
const
win
=
content
.
wrappedJSObject
;
const
isExpectedUrl
=
win
.
location
.
href
=
=
=
_url
;
const
hasRegistration
=
!
!
win
.
registrationPromise
;
return
isExpectedUrl
&
&
hasRegistration
;
}
catch
(
e
)
{
return
false
;
}
}
)
)
;
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
await
waitFor
(
(
)
=
>
{
const
registrations
=
swm
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
registrations
.
length
;
i
+
+
)
{
const
info
=
registrations
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
info
.
scriptSpec
=
=
=
workerUrl
)
{
return
true
;
}
}
return
false
;
}
)
;
}
async
function
checkHooks
(
hooks
{
available
destroyed
targets
}
)
{
await
waitUntil
(
(
)
=
>
hooks
.
availableCount
=
=
available
&
&
hooks
.
destroyedCount
=
=
destroyed
)
;
is
(
hooks
.
availableCount
available
"
onAvailable
was
called
as
expected
"
)
;
is
(
hooks
.
destroyedCount
destroyed
"
onDestroyed
was
called
as
expected
"
)
;
is
(
hooks
.
targets
.
length
targets
.
length
"
Expected
number
of
targets
"
)
;
targets
.
forEach
(
(
url
i
)
=
>
{
is
(
hooks
.
targets
[
i
]
.
url
url
SW
target
{
i
}
has
the
expected
url
)
;
}
)
;
}
