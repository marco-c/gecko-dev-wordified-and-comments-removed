"
use
strict
"
;
const
FISSION_TEST_URL
=
URL_ROOT_SSL
+
"
fission_document
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
info
(
"
Setup
the
test
page
with
workers
of
all
types
"
)
;
const
tab
=
await
addTab
(
FISSION_TEST_URL
)
;
info
(
"
Create
a
target
list
for
a
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
targetCommand
=
commands
.
targetCommand
;
const
{
TYPES
}
=
targetCommand
;
targetCommand
.
listenForServiceWorkers
=
true
;
await
targetCommand
.
startListening
(
)
;
const
serviceWorkerTargets
=
targetCommand
.
getAllTargets
(
[
TYPES
.
SERVICE_WORKER
]
)
;
is
(
serviceWorkerTargets
.
length
1
"
TargetCommmand
has
1
service
worker
target
"
)
;
info
(
"
Check
that
the
onAvailable
is
done
when
watchTargets
resolves
"
)
;
const
targets
=
[
]
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
await
wait
(
1000
)
;
targets
.
push
(
targetFront
)
;
}
;
const
onDestroyed
=
(
{
targetFront
}
)
=
>
targets
.
splice
(
targets
.
indexOf
(
targetFront
)
1
)
;
await
targetCommand
.
watchTargets
(
{
types
:
[
TYPES
.
SERVICE_WORKER
]
onAvailable
onDestroyed
}
)
;
is
(
targets
.
length
1
"
onAvailable
has
resolved
"
)
;
is
(
targets
[
0
]
serviceWorkerTargets
[
0
]
"
onAvailable
was
called
with
the
expected
service
worker
target
"
)
;
info
(
"
Unregister
the
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
registration
=
await
content
.
wrappedJSObject
.
registrationPromise
;
registration
.
unregister
(
)
;
}
)
;
await
waitUntil
(
(
)
=
>
targets
.
length
=
=
=
0
)
;
targetCommand
.
destroy
(
)
;
await
commands
.
waitForRequestsToSettle
(
)
;
await
commands
.
destroy
(
)
;
}
)
;
