"
use
strict
"
;
const
TEST_COM_URL
=
URL_ROOT_SSL
+
"
simple_document
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
await
pushPref
(
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
1
)
;
info
(
"
#
#
#
Test
with
client
side
target
switching
"
)
;
await
pushPref
(
"
devtools
.
target
-
switching
.
server
.
enabled
"
false
)
;
await
bfcacheTest
(
)
;
info
(
"
#
#
#
Test
with
server
side
target
switching
"
)
;
await
pushPref
(
"
devtools
.
target
-
switching
.
server
.
enabled
"
true
)
;
await
bfcacheTest
(
)
;
}
)
;
async
function
bfcacheTest
(
)
{
info
(
"
#
#
Test
with
bfcache
in
parent
DISABLED
"
)
;
await
pushPref
(
"
fission
.
bfcacheInParent
"
false
)
;
await
testTopLevelNavigations
(
false
)
;
await
testIframeNavigations
(
false
)
;
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
info
(
"
#
#
Test
with
bfcache
in
parent
ENABLED
"
)
;
await
pushPref
(
"
fission
.
bfcacheInParent
"
true
)
;
await
testTopLevelNavigations
(
true
)
;
await
testIframeNavigations
(
true
)
;
}
}
async
function
testTopLevelNavigations
(
bfcacheInParent
)
{
info
(
"
#
Test
TOP
LEVEL
navigations
"
)
;
const
tab
=
await
addTab
(
TEST_COM_URL
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
targetCommand
=
commands
.
targetCommand
;
const
{
TYPES
}
=
targetCommand
;
await
targetCommand
.
startListening
(
)
;
const
targets
=
[
]
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
is
(
targetFront
.
targetType
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
targetFront
.
isTopLevel
"
all
targets
of
this
test
are
top
level
"
)
;
targets
.
push
(
targetFront
)
;
}
;
const
destroyedTargets
=
[
]
;
const
onDestroyed
=
async
(
{
targetFront
}
)
=
>
{
is
(
targetFront
.
targetType
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
targetFront
.
isTopLevel
"
all
targets
of
this
test
are
top
level
"
)
;
destroyedTargets
.
push
(
targetFront
)
;
}
;
await
targetCommand
.
watchTargets
(
[
TYPES
.
FRAME
]
onAvailable
onDestroyed
)
;
is
(
targets
.
length
1
"
retrieved
only
the
top
level
target
"
)
;
is
(
targets
[
0
]
targetCommand
.
targetFront
"
the
target
is
the
top
level
one
"
)
;
is
(
destroyedTargets
.
length
0
"
We
get
no
destruction
when
calling
watchTargets
"
)
;
if
(
!
isServerTargetSwitchingEnabled
(
)
)
{
ok
(
!
targets
[
0
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
first
client
side
target
still
follows
docshell
lifecycle
when
server
target
switching
isn
'
t
enabled
"
)
;
}
else
{
ok
(
targets
[
0
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
first
server
side
target
follows
the
WindowGlobal
lifecycle
when
server
target
switching
is
enabled
"
)
;
}
info
(
"
Load
the
second
page
"
)
;
let
onDomComplete
=
bfcacheInParent
?
null
:
(
await
waitForNextTopLevelDomCompleteResource
(
commands
)
)
.
onDomCompleteResource
;
const
secondPageUrl
=
TEST_COM_URL
+
"
?
second
-
load
"
;
const
previousBrowsingContextID
=
gBrowser
.
selectedBrowser
.
browsingContext
.
id
;
ok
(
previousBrowsingContextID
"
Fetch
the
tab
'
s
browsing
context
id
before
navigation
"
)
;
const
onLoaded
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
secondPageUrl
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
secondPageUrl
)
;
await
onLoaded
;
if
(
bfcacheInParent
)
{
isnot
(
previousBrowsingContextID
gBrowser
.
selectedBrowser
.
browsingContext
.
id
"
When
bfcacheInParent
is
enabled
same
-
origin
navigations
spawn
new
BrowsingContext
"
)
;
}
else
{
is
(
previousBrowsingContextID
gBrowser
.
selectedBrowser
.
browsingContext
.
id
"
When
bfcacheInParent
is
disabled
same
-
origin
navigations
re
-
use
the
same
BrowsingContext
"
)
;
}
if
(
bfcacheInParent
|
|
isServerTargetSwitchingEnabled
(
)
)
{
await
waitFor
(
(
)
=
>
targets
.
length
=
=
2
"
wait
for
the
next
top
level
target
"
)
;
is
(
targets
[
1
]
targetCommand
.
targetFront
"
the
second
target
is
the
top
level
one
"
)
;
is
(
targets
[
1
]
.
outerWindowID
gBrowser
.
selectedBrowser
.
outerWindowID
"
the
second
target
is
for
the
second
page
"
)
;
if
(
!
isServerTargetSwitchingEnabled
(
)
)
{
ok
(
!
targets
[
1
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
new
client
side
target
still
follows
docshell
lifecycle
"
)
;
}
else
{
ok
(
targets
[
1
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
new
server
side
target
follows
the
WindowGlobal
lifecycle
"
)
;
}
ok
(
targets
[
0
]
.
isDestroyed
(
)
"
the
first
target
is
destroyed
"
)
;
is
(
destroyedTargets
.
length
1
"
We
get
one
target
being
destroyed
.
.
.
"
)
;
is
(
destroyedTargets
[
0
]
targets
[
0
]
"
.
.
.
and
that
'
s
the
first
one
"
)
;
}
else
{
info
(
"
Wait
for
'
dom
-
complete
'
resource
"
)
;
await
onDomComplete
;
}
info
(
"
Go
back
to
the
first
page
"
)
;
onDomComplete
=
bfcacheInParent
?
null
:
(
await
waitForNextTopLevelDomCompleteResource
(
commands
)
)
.
onDomCompleteResource
;
gBrowser
.
selectedBrowser
.
goBack
(
)
;
if
(
bfcacheInParent
|
|
isServerTargetSwitchingEnabled
(
)
)
{
await
waitFor
(
(
)
=
>
targets
.
length
=
=
3
"
wait
for
the
next
top
level
target
"
)
;
is
(
targets
[
2
]
targetCommand
.
targetFront
"
the
third
target
is
the
top
level
one
"
)
;
is
(
targets
[
2
]
.
url
TEST_COM_URL
"
the
third
target
is
for
the
first
url
"
)
;
ok
(
targets
[
2
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
third
target
for
bfcache
navigations
is
following
the
WindowGlobal
lifecycle
"
)
;
ok
(
targets
[
1
]
.
isDestroyed
(
)
"
the
second
target
is
destroyed
"
)
;
is
(
destroyedTargets
.
length
2
"
We
get
one
additional
target
being
destroyed
.
.
.
"
)
;
is
(
destroyedTargets
[
1
]
targets
[
1
]
"
.
.
.
and
that
'
s
the
second
one
"
)
;
await
targets
[
2
]
.
attachAndInitThread
(
targetCommand
)
;
await
waitForAllTargetsToBeAttached
(
targetCommand
)
;
}
else
{
info
(
"
Wait
for
'
dom
-
complete
'
resource
"
)
;
await
onDomComplete
;
}
info
(
"
Go
forward
to
the
second
page
"
)
;
onDomComplete
=
bfcacheInParent
?
null
:
(
await
waitForNextTopLevelDomCompleteResource
(
commands
)
)
.
onDomCompleteResource
;
const
onNewTargetProcessed
=
bfcacheInParent
?
new
Promise
(
resolve
=
>
{
targetCommand
.
on
(
"
processed
-
available
-
target
"
function
onProcessedAvailableTarget
(
targetFront
)
{
if
(
targetFront
=
=
=
targets
[
3
]
)
{
resolve
(
)
;
targetCommand
.
off
(
"
processed
-
available
-
target
"
onProcessedAvailableTarget
)
;
}
}
)
;
}
)
:
null
;
gBrowser
.
selectedBrowser
.
goForward
(
)
;
if
(
bfcacheInParent
|
|
isServerTargetSwitchingEnabled
(
)
)
{
await
waitFor
(
(
)
=
>
targets
.
length
=
=
4
"
wait
for
the
next
top
level
target
"
)
;
is
(
targets
[
3
]
targetCommand
.
targetFront
"
the
4th
target
is
the
top
level
one
"
)
;
is
(
targets
[
3
]
.
url
secondPageUrl
"
the
4th
target
is
for
the
second
url
"
)
;
ok
(
targets
[
3
]
.
targetForm
.
followWindowGlobalLifeCycle
"
the
4th
target
for
bfcache
navigations
is
following
the
WindowGlobal
lifecycle
"
)
;
ok
(
targets
[
2
]
.
isDestroyed
(
)
"
the
third
target
is
destroyed
"
)
;
is
(
destroyedTargets
.
length
3
"
We
get
one
additional
target
being
destroyed
.
.
.
"
)
;
is
(
destroyedTargets
[
2
]
targets
[
2
]
"
.
.
.
and
that
'
s
the
third
one
"
)
;
await
targets
[
3
]
.
attachAndInitThread
(
targetCommand
)
;
await
waitForAllTargetsToBeAttached
(
targetCommand
)
;
await
onNewTargetProcessed
;
}
else
{
info
(
"
Wait
for
'
dom
-
complete
'
resource
"
)
;
await
onDomComplete
;
}
await
waitForAllTargetsToBeAttached
(
targetCommand
)
;
targetCommand
.
unwatchTargets
(
[
TYPES
.
FRAME
]
onAvailable
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
commands
.
destroy
(
)
;
}
async
function
testIframeNavigations
(
)
{
info
(
"
#
Test
IFRAME
navigations
"
)
;
const
tab
=
await
addTab
(
http
:
/
/
example
.
org
/
document
-
builder
.
sjs
?
html
=
<
iframe
src
=
"
{
TEST_COM_URL
}
"
>
<
/
iframe
>
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
targetCommand
=
commands
.
targetCommand
;
const
{
TYPES
}
=
targetCommand
;
await
targetCommand
.
startListening
(
)
;
const
targets
=
[
]
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
is
(
targetFront
.
targetType
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
targets
.
push
(
targetFront
)
;
}
;
await
targetCommand
.
watchTargets
(
[
TYPES
.
FRAME
]
onAvailable
)
;
if
(
!
isFissionEnabled
(
)
&
&
!
isEveryFrameTargetEnabled
(
)
)
{
is
(
targets
.
length
1
"
Without
fission
/
EFT
there
is
only
the
top
level
target
"
)
;
return
;
}
is
(
targets
.
length
2
"
retrieved
the
top
level
and
the
iframe
targets
"
)
;
is
(
targets
[
0
]
targetCommand
.
targetFront
"
the
first
target
is
the
top
level
one
"
)
;
is
(
targets
[
1
]
.
url
TEST_COM_URL
"
the
second
target
is
the
iframe
one
"
)
;
info
(
"
Load
the
second
page
"
)
;
const
secondPageUrl
=
TEST_COM_URL
+
"
?
second
-
load
"
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
secondPageUrl
]
function
(
url
)
{
const
iframe
=
content
.
document
.
querySelector
(
"
iframe
"
)
;
iframe
.
src
=
url
;
}
)
;
await
waitFor
(
(
)
=
>
targets
.
length
=
=
3
"
wait
for
the
next
target
"
)
;
is
(
targets
[
2
]
.
url
secondPageUrl
"
the
second
target
is
for
the
second
url
"
)
;
ok
(
targets
[
1
]
.
isDestroyed
(
)
"
the
first
target
is
destroyed
"
)
;
info
(
"
Go
back
to
the
first
page
"
)
;
const
iframeBrowsingContext
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
const
iframe
=
content
.
document
.
querySelector
(
"
iframe
"
)
;
return
iframe
.
browsingContext
;
}
)
;
await
SpecialPowers
.
spawn
(
iframeBrowsingContext
[
]
function
(
)
{
content
.
history
.
back
(
)
;
}
)
;
await
waitFor
(
(
)
=
>
targets
.
length
=
=
4
"
wait
for
the
next
target
"
)
;
is
(
targets
[
3
]
.
url
TEST_COM_URL
"
the
third
target
is
for
the
first
url
"
)
;
ok
(
targets
[
2
]
.
isDestroyed
(
)
"
the
second
target
is
destroyed
"
)
;
info
(
"
Go
forward
to
the
second
page
"
)
;
await
SpecialPowers
.
spawn
(
iframeBrowsingContext
[
]
function
(
)
{
content
.
history
.
forward
(
)
;
}
)
;
await
waitFor
(
(
)
=
>
targets
.
length
=
=
5
"
wait
for
the
next
target
"
)
;
is
(
targets
[
4
]
.
url
secondPageUrl
"
the
4th
target
is
for
the
second
url
"
)
;
ok
(
targets
[
3
]
.
isDestroyed
(
)
"
the
third
target
is
destroyed
"
)
;
targetCommand
.
unwatchTargets
(
[
TYPES
.
FRAME
]
onAvailable
)
;
await
waitForAllTargetsToBeAttached
(
targetCommand
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
commands
.
destroy
(
)
;
}
