"
use
strict
"
;
add_task
(
async
function
testSwitchToTarget
(
)
{
info
(
"
Test
TargetCommand
.
switchToTarget
method
"
)
;
const
firstTab
=
await
addTab
(
data
:
text
/
html
<
iframe
src
=
"
data
:
text
/
html
foo
"
>
<
/
iframe
>
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
firstTab
)
;
const
targetCommand
=
commands
.
targetCommand
;
const
{
TYPES
}
=
targetCommand
;
await
targetCommand
.
startListening
(
)
;
const
secondTab
=
await
addTab
(
data
:
text
/
html
<
iframe
src
=
"
data
:
text
/
html
bar
"
>
<
/
iframe
>
)
;
const
secondCommands
=
await
CommandsFactory
.
forTab
(
secondTab
{
client
:
commands
.
client
}
)
;
await
secondCommands
.
targetCommand
.
startListening
(
)
;
const
secondTarget
=
secondCommands
.
targetCommand
.
targetFront
;
const
frameTargets
=
[
]
;
const
firstTarget
=
targetCommand
.
targetFront
;
let
currentTarget
=
targetCommand
.
targetFront
;
const
onFrameAvailable
=
(
{
targetFront
isTargetSwitching
}
)
=
>
{
is
(
targetFront
.
targetType
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
targetFront
=
=
currentTarget
?
targetFront
.
isTopLevel
:
!
targetFront
.
isTopLevel
"
isTopLevel
property
is
correct
"
)
;
if
(
targetFront
.
isTopLevel
)
{
is
(
isTargetSwitching
currentTarget
=
=
secondTarget
"
target
switching
boolean
is
correct
"
)
;
}
else
{
ok
(
!
isTargetSwitching
"
for
now
only
top
level
target
can
be
switched
"
)
;
}
frameTargets
.
push
(
targetFront
)
;
}
;
const
destroyedTargets
=
[
]
;
const
onFrameDestroyed
=
(
{
targetFront
isTargetSwitching
}
)
=
>
{
is
(
targetFront
.
targetType
TYPES
.
FRAME
"
target
-
destroyed
:
We
are
only
notified
about
frame
targets
"
)
;
ok
(
targetFront
=
=
firstTarget
?
targetFront
.
isTopLevel
:
!
targetFront
.
isTopLevel
"
target
-
destroyed
:
isTopLevel
property
is
correct
"
)
;
if
(
targetFront
.
isTopLevel
)
{
is
(
isTargetSwitching
true
"
target
-
destroyed
:
target
switching
boolean
is
correct
"
)
;
}
else
{
ok
(
!
isTargetSwitching
"
target
-
destroyed
:
for
now
only
top
level
target
can
be
switched
"
)
;
}
destroyedTargets
.
push
(
targetFront
)
;
}
;
await
targetCommand
.
watchTargets
(
{
types
:
[
TYPES
.
FRAME
]
onAvailable
:
onFrameAvailable
onDestroyed
:
onFrameDestroyed
}
)
;
const
createdTargets
=
[
.
.
.
frameTargets
]
;
frameTargets
.
length
=
0
;
currentTarget
=
secondTarget
;
await
targetCommand
.
switchToTarget
(
secondTarget
)
;
is
(
targetCommand
.
targetFront
currentTarget
"
After
the
switch
the
top
level
target
has
been
updated
"
)
;
is
(
frameTargets
.
length
1
"
We
get
the
report
of
the
top
level
iframe
when
switching
to
the
new
target
"
)
;
is
(
frameTargets
[
0
]
currentTarget
)
;
is
(
destroyedTargets
.
length
createdTargets
.
length
"
All
targets
original
reported
are
destroyed
"
)
;
for
(
const
newTarget
of
createdTargets
)
{
ok
(
destroyedTargets
.
includes
(
newTarget
)
"
Each
originally
target
is
reported
as
destroyed
"
)
;
}
targetCommand
.
destroy
(
)
;
await
commands
.
destroy
(
)
;
await
secondCommands
.
destroy
(
)
;
BrowserTestUtils
.
removeTab
(
firstTab
)
;
BrowserTestUtils
.
removeTab
(
secondTab
)
;
}
)
;
