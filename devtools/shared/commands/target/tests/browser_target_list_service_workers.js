"
use
strict
"
;
const
FISSION_TEST_URL
=
URL_ROOT_SSL
+
"
fission_document
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
info
(
"
Setup
the
test
page
with
workers
of
all
types
"
)
;
const
client
=
await
createLocalClient
(
)
;
const
tab
=
await
addTab
(
FISSION_TEST_URL
)
;
info
(
"
Create
a
target
list
for
a
tab
target
"
)
;
const
descriptor
=
await
client
.
mainRoot
.
getTab
(
{
tab
}
)
;
const
commands
=
await
descriptor
.
getCommands
(
)
;
const
targetList
=
commands
.
targetCommand
;
const
{
TYPES
}
=
targetList
;
targetList
.
listenForServiceWorkers
=
true
;
await
targetList
.
startListening
(
)
;
const
serviceWorkerTargets
=
targetList
.
getAllTargets
(
[
TYPES
.
SERVICE_WORKER
]
)
;
is
(
serviceWorkerTargets
.
length
1
"
TargetCommmand
has
1
service
worker
target
"
)
;
info
(
"
Check
that
the
onAvailable
is
done
when
watchTargets
resolves
"
)
;
const
targets
=
[
]
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
await
wait
(
1000
)
;
targets
.
push
(
targetFront
)
;
}
;
const
onDestroyed
=
(
{
targetFront
}
)
=
>
targets
.
splice
(
targets
.
indexOf
(
targetFront
)
1
)
;
await
targetList
.
watchTargets
(
[
TYPES
.
SERVICE_WORKER
]
onAvailable
onDestroyed
)
;
is
(
targets
.
length
1
"
onAvailable
has
resolved
"
)
;
is
(
targets
[
0
]
serviceWorkerTargets
[
0
]
"
onAvailable
was
called
with
the
expected
service
worker
target
"
)
;
info
(
"
Unregister
the
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
registration
=
await
content
.
wrappedJSObject
.
registrationPromise
;
registration
.
unregister
(
)
;
}
)
;
await
waitUntil
(
(
)
=
>
targets
.
length
=
=
=
0
)
;
targetList
.
destroy
(
)
;
await
client
.
waitForRequestsToSettle
(
)
;
await
client
.
close
(
)
;
}
)
;
