"
use
strict
"
;
async
function
setupServiceWorkerNavigationTest
(
)
{
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
}
async
function
watchServiceWorkerTargets
(
tab
)
{
info
(
"
Create
a
target
list
for
a
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
const
targetCommand
=
commands
.
targetCommand
;
targetCommand
.
listenForServiceWorkers
=
true
;
await
targetCommand
.
startListening
(
)
;
const
hooks
=
{
availableCount
:
0
destroyedCount
:
0
targets
:
[
]
}
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
info
(
+
Service
worker
target
available
for
{
targetFront
.
url
}
\
n
)
;
hooks
.
availableCount
+
+
;
hooks
.
targets
.
push
(
targetFront
)
;
}
;
const
onDestroyed
=
(
{
targetFront
}
)
=
>
{
info
(
-
Service
worker
target
destroy
for
{
targetFront
.
url
}
\
n
)
;
hooks
.
destroyedCount
+
+
;
hooks
.
targets
.
splice
(
hooks
.
targets
.
indexOf
(
targetFront
)
1
)
;
}
;
await
targetCommand
.
watchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
SERVICE_WORKER
]
onAvailable
onDestroyed
}
)
;
return
{
hooks
commands
targetCommand
}
;
}
async
function
waitForRegistrationReady
(
tab
expectedPageUrl
workerUrl
)
{
await
asyncWaitUntil
(
(
)
=
>
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
expectedPageUrl
]
function
(
_url
)
{
try
{
const
win
=
content
.
wrappedJSObject
;
const
isExpectedUrl
=
win
.
location
.
href
=
=
=
_url
;
const
hasRegistration
=
!
!
win
.
registrationPromise
;
return
isExpectedUrl
&
&
hasRegistration
;
}
catch
(
e
)
{
return
false
;
}
}
)
)
;
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
await
waitFor
(
(
)
=
>
{
const
registrations
=
swm
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
registrations
.
length
;
i
+
+
)
{
const
info
=
registrations
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
info
.
scriptSpec
=
=
=
workerUrl
)
{
return
true
;
}
}
return
false
;
}
)
;
}
async
function
checkHooks
(
hooks
{
available
destroyed
targets
}
)
{
await
waitUntil
(
(
)
=
>
hooks
.
availableCount
=
=
available
&
&
hooks
.
destroyedCount
=
=
destroyed
)
;
is
(
hooks
.
availableCount
available
"
onAvailable
was
called
as
expected
"
)
;
is
(
hooks
.
destroyedCount
destroyed
"
onDestroyed
was
called
as
expected
"
)
;
is
(
hooks
.
targets
.
length
targets
.
length
"
Expected
number
of
targets
"
)
;
targets
.
forEach
(
(
url
i
)
=
>
{
is
(
hooks
.
targets
[
i
]
.
url
url
SW
target
{
i
}
has
the
expected
url
)
;
}
)
;
}
