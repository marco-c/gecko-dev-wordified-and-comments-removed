"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
BROWSERTOOLBOX_FISSION_ENABLED
=
"
devtools
.
browsertoolbox
.
fission
"
;
const
{
LegacyProcessesWatcher
}
=
require
(
"
devtools
/
shared
/
commands
/
target
/
legacy
-
target
-
watchers
/
legacy
-
processes
-
watcher
"
)
;
const
{
LegacyServiceWorkersWatcher
}
=
require
(
"
devtools
/
shared
/
commands
/
target
/
legacy
-
target
-
watchers
/
legacy
-
serviceworkers
-
watcher
"
)
;
const
{
LegacySharedWorkersWatcher
}
=
require
(
"
devtools
/
shared
/
commands
/
target
/
legacy
-
target
-
watchers
/
legacy
-
sharedworkers
-
watcher
"
)
;
const
{
LegacyWorkersWatcher
}
=
require
(
"
devtools
/
shared
/
commands
/
target
/
legacy
-
target
-
watchers
/
legacy
-
workers
-
watcher
"
)
;
class
TargetCommand
extends
EventEmitter
{
constructor
(
{
descriptorFront
commands
}
)
{
super
(
)
;
this
.
commands
=
commands
;
this
.
descriptorFront
=
descriptorFront
;
this
.
rootFront
=
descriptorFront
.
client
.
mainRoot
;
this
.
onLocalTabRemotenessChange
=
this
.
onLocalTabRemotenessChange
.
bind
(
this
)
;
if
(
this
.
descriptorFront
.
isLocalTab
)
{
this
.
descriptorFront
.
on
(
"
remoteness
-
change
"
this
.
onLocalTabRemotenessChange
)
;
}
if
(
this
.
isServerTargetSwitchingEnabled
(
)
)
{
this
.
_onFirstTarget
=
new
Promise
(
r
=
>
(
this
.
_resolveOnFirstTarget
=
r
)
)
;
}
this
.
_listenersStarted
=
new
Set
(
)
;
this
.
_targets
=
new
Set
(
)
;
this
.
_pendingWatchTargetInitialization
=
new
Map
(
)
;
this
.
_createListeners
=
new
EventEmitter
(
)
;
this
.
_destroyListeners
=
new
EventEmitter
(
)
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
legacyImplementation
=
{
process
:
new
LegacyProcessesWatcher
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
worker
:
new
LegacyWorkersWatcher
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
shared_worker
:
new
LegacySharedWorkersWatcher
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
service_worker
:
new
LegacyServiceWorkersWatcher
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
this
.
commands
)
}
;
this
.
listenForWorkers
=
this
.
rootFront
.
traits
.
workerConsoleApiMessagesDispatchedToMainThread
=
=
=
false
;
this
.
listenForServiceWorkers
=
false
;
this
.
destroyServiceWorkersOnNavigation
=
false
;
this
.
_gotFirstTopLevelTarget
=
false
;
this
.
commands
=
commands
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
}
async
_onTargetAvailable
(
targetFront
)
{
const
isTargetSwitching
=
targetFront
.
isTopLevel
;
const
isFirstTarget
=
targetFront
.
isTopLevel
&
&
!
this
.
_gotFirstTopLevelTarget
;
if
(
this
.
_targets
.
has
(
targetFront
)
)
{
if
(
targetFront
!
=
this
.
targetFront
)
{
console
.
error
(
"
Target
is
already
registered
in
the
TargetCommand
"
targetFront
.
actorID
)
;
}
return
;
}
if
(
this
.
isDestroyed
(
)
|
|
targetFront
.
isDestroyedOrBeingDestroyed
(
)
)
{
return
;
}
if
(
targetFront
.
isTopLevel
)
{
if
(
!
isFirstTarget
)
{
this
.
_destroyExistingTargetsOnTargetSwitching
(
)
;
}
this
.
targetFront
=
targetFront
;
this
.
descriptorFront
.
setTarget
(
targetFront
)
;
if
(
isFirstTarget
&
&
this
.
isServerTargetSwitchingEnabled
(
)
)
{
this
.
_gotFirstTopLevelTarget
=
true
;
this
.
_resolveOnFirstTarget
(
)
;
}
}
const
targetType
=
this
.
getTargetType
(
targetFront
)
;
targetFront
.
setTargetType
(
targetType
)
;
this
.
_targets
.
add
(
targetFront
)
;
try
{
await
targetFront
.
attachAndInitThread
(
this
)
;
}
catch
(
e
)
{
console
.
error
(
"
Error
when
attaching
target
:
"
e
)
;
this
.
_targets
.
delete
(
targetFront
)
;
return
;
}
for
(
const
targetFrontsSet
of
this
.
_pendingWatchTargetInitialization
.
values
(
)
)
{
targetFrontsSet
.
delete
(
targetFront
)
;
}
if
(
this
.
isDestroyed
(
)
|
|
targetFront
.
isDestroyedOrBeingDestroyed
(
)
)
{
return
;
}
await
this
.
_createListeners
.
emitAsync
(
targetType
{
targetFront
isTargetSwitching
}
)
;
if
(
targetFront
.
isTopLevel
&
&
!
isFirstTarget
)
{
await
this
.
startListening
(
{
isTargetSwitching
:
true
}
)
;
}
this
.
emitForTests
(
"
processed
-
available
-
target
"
targetFront
)
;
if
(
isTargetSwitching
)
{
this
.
emit
(
"
switched
-
target
"
targetFront
)
;
}
}
_destroyExistingTargetsOnTargetSwitching
(
)
{
const
destroyedTargets
=
[
]
;
for
(
const
target
of
this
.
_targets
)
{
const
isDestroyedTargetSwitching
=
target
=
=
this
.
targetFront
;
const
isServiceWorker
=
target
.
targetType
=
=
=
this
.
TYPES
.
SERVICE_WORKER
;
if
(
!
isServiceWorker
|
|
this
.
destroyServiceWorkersOnNavigation
)
{
this
.
_onTargetDestroyed
(
target
{
isTargetSwitching
:
isDestroyedTargetSwitching
shouldDestroyTargetFront
:
!
isServiceWorker
}
)
;
destroyedTargets
.
push
(
target
)
;
}
}
this
.
stopListening
(
{
isTargetSwitching
:
true
}
)
;
for
(
const
target
of
destroyedTargets
)
{
this
.
_targets
.
delete
(
target
)
;
}
}
_onTargetDestroyed
(
targetFront
{
isTargetSwitching
=
false
shouldDestroyTargetFront
=
true
}
=
{
}
)
{
if
(
targetFront
=
=
this
.
targetFront
)
{
isTargetSwitching
=
true
;
}
this
.
_destroyListeners
.
emit
(
targetFront
.
targetType
{
targetFront
isTargetSwitching
}
)
;
this
.
_targets
.
delete
(
targetFront
)
;
if
(
shouldDestroyTargetFront
)
{
targetFront
.
baseFrontClassDestroy
(
)
;
targetFront
.
destroy
(
)
;
}
}
_setListening
(
type
value
)
{
if
(
value
)
{
this
.
_listenersStarted
.
add
(
type
)
;
}
else
{
this
.
_listenersStarted
.
delete
(
type
)
;
}
}
_isListening
(
type
)
{
return
this
.
_listenersStarted
.
has
(
type
)
;
}
hasTargetWatcherSupport
(
targetTypeOrTrait
)
{
if
(
this
.
descriptorFront
.
isParentProcessDescriptor
&
&
!
Services
.
prefs
.
getBoolPref
(
BROWSERTOOLBOX_FISSION_ENABLED
false
)
)
{
return
false
;
}
if
(
targetTypeOrTrait
)
{
return
!
!
this
.
watcherFront
?
.
traits
[
targetTypeOrTrait
]
;
}
return
!
!
this
.
watcherFront
;
}
async
startListening
(
{
isTargetSwitching
=
false
}
=
{
}
)
{
if
(
!
this
.
isServerTargetSwitchingEnabled
(
)
&
&
!
this
.
_gotFirstTopLevelTarget
)
{
await
this
.
_createFirstTarget
(
)
;
}
if
(
!
this
.
watcherFront
)
{
const
supportsWatcher
=
this
.
descriptorFront
.
traits
?
.
watcher
;
if
(
supportsWatcher
)
{
this
.
watcherFront
=
await
this
.
descriptorFront
.
getWatcher
(
)
;
this
.
watcherFront
.
on
(
"
target
-
available
"
this
.
_onTargetAvailable
)
;
this
.
watcherFront
.
on
(
"
target
-
destroyed
"
this
.
_onTargetDestroyed
)
;
}
}
const
types
=
this
.
_computeTargetTypes
(
)
;
for
(
const
type
of
types
)
{
if
(
this
.
_isListening
(
type
)
)
{
continue
;
}
this
.
_setListening
(
type
true
)
;
if
(
this
.
hasTargetWatcherSupport
(
type
)
)
{
if
(
!
isTargetSwitching
)
{
await
this
.
watcherFront
.
watchTargets
(
type
)
;
}
}
else
if
(
this
.
legacyImplementation
[
type
]
)
{
await
this
.
legacyImplementation
[
type
]
.
listen
(
)
;
}
else
{
throw
new
Error
(
Unsupported
target
type
'
{
type
}
'
)
;
}
}
if
(
!
this
.
_watchingDocumentEvent
&
&
!
this
.
isDestroyed
(
)
)
{
this
.
_watchingDocumentEvent
=
true
;
await
this
.
commands
.
resourceCommand
.
watchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
}
if
(
this
.
isServerTargetSwitchingEnabled
(
)
)
{
await
this
.
_onFirstTarget
;
}
}
async
_createFirstTarget
(
)
{
this
.
targetFront
=
await
this
.
descriptorFront
.
getTarget
(
)
;
this
.
targetFront
.
setTargetType
(
this
.
getTargetType
(
this
.
targetFront
)
)
;
this
.
targetFront
.
setIsTopLevel
(
true
)
;
this
.
_gotFirstTopLevelTarget
=
true
;
this
.
_targets
.
add
(
this
.
targetFront
)
;
}
_computeTargetTypes
(
)
{
let
types
=
[
]
;
if
(
this
.
descriptorFront
.
isLocalTab
)
{
types
=
[
TargetCommand
.
TYPES
.
FRAME
]
;
}
else
if
(
this
.
descriptorFront
.
isParentProcessDescriptor
)
{
const
fissionBrowserToolboxEnabled
=
Services
.
prefs
.
getBoolPref
(
BROWSERTOOLBOX_FISSION_ENABLED
)
;
if
(
fissionBrowserToolboxEnabled
)
{
types
=
TargetCommand
.
ALL_TYPES
;
}
}
if
(
this
.
listenForWorkers
&
&
!
types
.
includes
(
TargetCommand
.
TYPES
.
WORKER
)
)
{
types
.
push
(
TargetCommand
.
TYPES
.
WORKER
)
;
}
if
(
this
.
listenForWorkers
&
&
!
types
.
includes
(
TargetCommand
.
TYPES
.
SHARED_WORKER
)
)
{
types
.
push
(
TargetCommand
.
TYPES
.
SHARED_WORKER
)
;
}
if
(
this
.
listenForServiceWorkers
&
&
!
types
.
includes
(
TargetCommand
.
TYPES
.
SERVICE_WORKER
)
)
{
types
.
push
(
TargetCommand
.
TYPES
.
SERVICE_WORKER
)
;
}
return
types
;
}
stopListening
(
{
isTargetSwitching
=
false
}
=
{
}
)
{
if
(
this
.
_watchingDocumentEvent
&
&
!
isTargetSwitching
)
{
this
.
commands
.
resourceCommand
.
unwatchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
this
.
_watchingDocumentEvent
=
false
;
}
for
(
const
type
of
TargetCommand
.
ALL_TYPES
)
{
if
(
!
this
.
_isListening
(
type
)
)
{
continue
;
}
this
.
_setListening
(
type
false
)
;
if
(
this
.
hasTargetWatcherSupport
(
type
)
)
{
if
(
!
isTargetSwitching
)
{
this
.
watcherFront
.
unwatchTargets
(
type
)
;
}
}
else
if
(
this
.
legacyImplementation
[
type
]
)
{
this
.
legacyImplementation
[
type
]
.
unlisten
(
{
isTargetSwitching
}
)
;
}
else
{
throw
new
Error
(
Unsupported
target
type
'
{
type
}
'
)
;
}
}
}
getTargetType
(
target
)
{
const
{
typeName
}
=
target
;
if
(
typeName
=
=
"
browsingContextTarget
"
)
{
return
TargetCommand
.
TYPES
.
FRAME
;
}
if
(
typeName
=
=
"
contentProcessTarget
"
|
|
typeName
=
=
"
parentProcessTarget
"
)
{
return
TargetCommand
.
TYPES
.
PROCESS
;
}
if
(
typeName
=
=
"
workerDescriptor
"
|
|
typeName
=
=
"
workerTarget
"
)
{
if
(
target
.
isSharedWorker
)
{
return
TargetCommand
.
TYPES
.
SHARED_WORKER
;
}
if
(
target
.
isServiceWorker
)
{
return
TargetCommand
.
TYPES
.
SERVICE_WORKER
;
}
return
TargetCommand
.
TYPES
.
WORKER
;
}
throw
new
Error
(
"
Unsupported
target
typeName
:
"
+
typeName
)
;
}
_matchTargetType
(
type
target
)
{
return
type
=
=
=
target
.
targetType
;
}
_onResourceAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
=
=
=
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
)
{
const
{
targetFront
}
=
resource
;
if
(
resource
.
title
!
=
=
undefined
&
&
targetFront
?
.
setTitle
)
{
targetFront
.
setTitle
(
resource
.
title
)
;
}
if
(
resource
.
url
!
=
=
undefined
&
&
targetFront
?
.
setUrl
)
{
targetFront
.
setUrl
(
resource
.
url
)
;
}
}
}
}
async
watchTargets
(
types
onAvailable
onDestroy
)
{
if
(
typeof
onAvailable
!
=
"
function
"
)
{
throw
new
Error
(
"
TargetCommand
.
watchTargets
expects
a
function
as
second
argument
"
)
;
}
for
(
const
type
of
types
)
{
if
(
!
this
.
_isValidTargetType
(
type
)
)
{
throw
new
Error
(
TargetCommand
.
watchTargets
invoked
with
an
unknown
type
:
"
{
type
}
"
)
;
}
}
const
targetFronts
=
[
.
.
.
this
.
_targets
]
.
filter
(
targetFront
=
>
types
.
includes
(
targetFront
.
targetType
)
)
;
this
.
_pendingWatchTargetInitialization
.
set
(
onAvailable
new
Set
(
targetFronts
)
)
;
const
promises
=
targetFronts
.
map
(
async
targetFront
=
>
{
try
{
await
targetFront
.
attachAndInitThread
(
this
)
;
}
catch
(
e
)
{
console
.
error
(
"
Error
when
attaching
target
:
"
e
)
;
return
;
}
if
(
this
.
_pendingWatchTargetInitialization
&
&
this
.
_pendingWatchTargetInitialization
.
has
(
onAvailable
)
&
&
!
this
.
_pendingWatchTargetInitialization
.
get
(
onAvailable
)
.
has
(
targetFront
)
)
{
return
;
}
try
{
await
onAvailable
(
{
targetFront
isTargetSwitching
:
false
}
)
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
when
calling
onAvailable
handler
"
e
.
message
e
)
;
}
}
)
;
for
(
const
type
of
types
)
{
this
.
_createListeners
.
on
(
type
onAvailable
)
;
if
(
onDestroy
)
{
this
.
_destroyListeners
.
on
(
type
onDestroy
)
;
}
}
await
Promise
.
all
(
promises
)
;
this
.
_pendingWatchTargetInitialization
.
delete
(
onAvailable
)
;
}
unwatchTargets
(
types
onAvailable
onDestroy
)
{
if
(
typeof
onAvailable
!
=
"
function
"
)
{
throw
new
Error
(
"
TargetCommand
.
unwatchTargets
expects
a
function
as
second
argument
"
)
;
}
for
(
const
type
of
types
)
{
if
(
!
this
.
_isValidTargetType
(
type
)
)
{
throw
new
Error
(
TargetCommand
.
unwatchTargets
invoked
with
an
unknown
type
:
"
{
type
}
"
)
;
}
this
.
_createListeners
.
off
(
type
onAvailable
)
;
if
(
onDestroy
)
{
this
.
_destroyListeners
.
off
(
type
onDestroy
)
;
}
}
this
.
_pendingWatchTargetInitialization
.
delete
(
onAvailable
)
;
}
getAllTargets
(
types
)
{
if
(
!
types
?
.
length
)
{
throw
new
Error
(
"
getAllTargets
expects
a
non
-
empty
array
of
types
"
)
;
}
const
targets
=
[
.
.
.
this
.
_targets
]
.
filter
(
target
=
>
types
.
some
(
type
=
>
this
.
_matchTargetType
(
type
target
)
)
)
;
return
targets
;
}
async
getAllFronts
(
targetTypes
frontType
)
{
if
(
!
Array
.
isArray
(
targetTypes
)
|
|
!
targetTypes
?
.
length
)
{
throw
new
Error
(
"
getAllFronts
expects
a
non
-
empty
array
of
target
types
"
)
;
}
const
fronts
=
[
]
;
const
targets
=
this
.
getAllTargets
(
targetTypes
)
;
for
(
const
target
of
targets
)
{
if
(
frontType
=
=
"
thread
"
&
&
!
target
.
targetForm
.
threadActor
)
{
continue
;
}
const
front
=
await
target
.
getFront
(
frontType
)
;
fronts
.
push
(
front
)
;
}
return
fronts
;
}
async
onLocalTabRemotenessChange
(
targetFront
)
{
if
(
this
.
isServerTargetSwitchingEnabled
(
)
)
{
return
;
}
if
(
targetFront
)
{
await
targetFront
.
once
(
"
target
-
destroyed
"
)
;
}
const
newTarget
=
await
this
.
descriptorFront
.
getTarget
(
)
;
if
(
!
newTarget
)
{
console
.
warn
(
Couldn
'
t
get
the
target
for
descriptor
{
this
.
descriptorFront
.
actorID
}
)
;
return
;
}
this
.
switchToTarget
(
newTarget
)
;
}
async
reloadTopLevelTarget
(
bypassCache
=
false
)
{
if
(
!
this
.
descriptorFront
.
traits
.
supportsReloadDescriptor
)
{
throw
new
Error
(
"
The
top
level
target
doesn
'
t
support
being
reloaded
"
)
;
}
const
{
onResource
:
onReloaded
}
=
await
this
.
commands
.
resourceCommand
.
waitForNextResource
(
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
(
resource
)
{
return
resource
.
name
=
=
"
dom
-
complete
"
;
}
}
)
;
await
this
.
descriptorFront
.
reloadDescriptor
(
{
bypassCache
}
)
;
await
onReloaded
;
}
async
switchToTarget
(
newTarget
)
{
await
this
.
_onTargetAvailable
(
newTarget
)
;
}
isTargetRegistered
(
targetFront
)
{
return
this
.
_targets
.
has
(
targetFront
)
;
}
isDestroyed
(
)
{
return
this
.
_isDestroyed
;
}
isServerTargetSwitchingEnabled
(
)
{
if
(
this
.
descriptorFront
.
isServerTargetSwitchingEnabled
)
{
return
this
.
descriptorFront
.
isServerTargetSwitchingEnabled
(
)
;
}
return
false
;
}
_isValidTargetType
(
type
)
{
return
this
.
ALL_TYPES
.
includes
(
type
)
;
}
destroy
(
)
{
this
.
stopListening
(
)
;
this
.
_createListeners
.
off
(
)
;
this
.
_destroyListeners
.
off
(
)
;
this
.
_isDestroyed
=
true
;
}
}
TargetCommand
.
TYPES
=
TargetCommand
.
prototype
.
TYPES
=
{
PROCESS
:
"
process
"
FRAME
:
"
frame
"
WORKER
:
"
worker
"
SHARED_WORKER
:
"
shared_worker
"
SERVICE_WORKER
:
"
service_worker
"
}
;
TargetCommand
.
ALL_TYPES
=
TargetCommand
.
prototype
.
ALL_TYPES
=
Object
.
values
(
TargetCommand
.
TYPES
)
;
module
.
exports
=
TargetCommand
;
