"
use
strict
"
;
const
{
WorkersListener
}
=
require
(
"
devtools
/
client
/
shared
/
workers
-
listener
"
)
;
const
{
LegacyWorkersWatcher
}
=
require
(
"
devtools
/
shared
/
commands
/
target
/
legacy
-
target
-
watchers
/
legacy
-
workers
-
watcher
"
)
;
class
LegacyServiceWorkersWatcher
extends
LegacyWorkersWatcher
{
constructor
(
targetCommand
onTargetAvailable
onTargetDestroyed
commands
)
{
super
(
targetCommand
onTargetAvailable
onTargetDestroyed
)
;
this
.
_registrations
=
[
]
;
this
.
_processTargets
=
new
Set
(
)
;
this
.
commands
=
commands
;
this
.
_workersListener
=
new
WorkersListener
(
this
.
rootFront
{
registrationsOnly
:
true
}
)
;
this
.
_onRegistrationListChanged
=
this
.
_onRegistrationListChanged
.
bind
(
this
)
;
this
.
_onDocumentEvent
=
this
.
_onDocumentEvent
.
bind
(
this
)
;
this
.
_isServiceWorkerWatcher
=
true
;
}
_recordWorkerTarget
(
workerTarget
)
{
return
!
!
this
.
_getRegistrationForWorkerTarget
(
workerTarget
)
;
}
_supportWorkerTarget
(
workerTarget
)
{
if
(
!
workerTarget
.
isServiceWorker
)
{
return
false
;
}
const
registration
=
this
.
_getRegistrationForWorkerTarget
(
workerTarget
)
;
return
registration
&
&
this
.
_isRegistrationValidForTarget
(
registration
)
;
}
async
listen
(
)
{
this
.
target
=
this
.
targetCommand
.
targetFront
;
this
.
_workersListener
.
addListener
(
this
.
_onRegistrationListChanged
)
;
await
this
.
_onRegistrationListChanged
(
)
;
if
(
this
.
targetCommand
.
descriptorFront
.
isLocalTab
)
{
await
this
.
commands
.
resourceCommand
.
watchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onDocumentEvent
ignoreExistingResources
:
true
}
)
;
}
await
super
.
listen
(
)
;
}
unlisten
(
)
{
this
.
_workersListener
.
removeListener
(
this
.
_onRegistrationListChanged
)
;
if
(
this
.
targetCommand
.
descriptorFront
.
isLocalTab
)
{
this
.
commands
.
resourceCommand
.
unwatchResources
(
[
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onDocumentEvent
}
)
;
}
super
.
unlisten
(
)
;
}
async
_onProcessAvailable
(
{
targetFront
}
)
{
if
(
this
.
targetCommand
.
descriptorFront
.
isLocalTab
)
{
const
origin
=
new
URL
(
this
.
target
.
url
)
.
origin
;
try
{
await
targetFront
.
pauseMatchingServiceWorkers
(
{
origin
}
)
;
}
catch
(
e
)
{
if
(
targetFront
.
actorID
)
{
throw
e
;
}
else
{
console
.
warn
(
"
Process
target
destroyed
while
calling
pauseMatchingServiceWorkers
"
)
;
}
}
}
this
.
_processTargets
.
add
(
targetFront
)
;
return
super
.
_onProcessAvailable
(
{
targetFront
}
)
;
}
_shouldDestroyTargetsOnNavigation
(
)
{
return
!
!
this
.
targetCommand
.
destroyServiceWorkersOnNavigation
;
}
_onProcessDestroyed
(
{
targetFront
}
)
{
this
.
_processTargets
.
delete
(
targetFront
)
;
return
super
.
_onProcessDestroyed
(
{
targetFront
}
)
;
}
_onDocumentEvent
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
!
=
=
this
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
|
|
resource
.
name
!
=
=
"
dom
-
loading
"
)
{
continue
;
}
const
allServiceWorkerTargets
=
this
.
_getAllServiceWorkerTargets
(
)
;
const
shouldDestroy
=
this
.
_shouldDestroyTargetsOnNavigation
(
)
;
for
(
const
target
of
allServiceWorkerTargets
)
{
const
isRegisteredBefore
=
this
.
targetCommand
.
isTargetRegistered
(
target
)
;
if
(
shouldDestroy
&
&
isRegisteredBefore
)
{
this
.
onTargetDestroyed
(
target
{
shouldDestroyTargetFront
:
false
}
)
;
}
const
isRegisteredAfter
=
this
.
targetCommand
.
isTargetRegistered
(
target
)
;
const
isValidTarget
=
this
.
_supportWorkerTarget
(
target
)
;
if
(
isValidTarget
&
&
!
isRegisteredAfter
)
{
this
.
onTargetAvailable
(
target
)
;
}
}
}
}
async
_onRegistrationListChanged
(
)
{
if
(
this
.
targetCommand
.
isDestroyed
(
)
)
{
return
;
}
await
this
.
_updateRegistrations
(
)
;
const
allServiceWorkerTargets
=
this
.
_getAllServiceWorkerTargets
(
)
;
for
(
const
target
of
allServiceWorkerTargets
)
{
const
hasRegistration
=
this
.
_getRegistrationForWorkerTarget
(
target
)
;
if
(
!
hasRegistration
)
{
if
(
this
.
targetCommand
.
isTargetRegistered
(
target
)
)
{
this
.
onTargetDestroyed
(
target
)
;
}
this
.
_removeTargetReferences
(
target
)
;
}
}
}
_removeTargetReferences
(
target
)
{
const
allProcessTargets
=
this
.
_getProcessTargets
(
)
.
filter
(
t
=
>
this
.
targetsByProcess
.
get
(
t
)
)
;
for
(
const
processTarget
of
allProcessTargets
)
{
this
.
targetsByProcess
.
get
(
processTarget
)
.
delete
(
target
)
;
}
}
async
_updateRegistrations
(
)
{
const
{
registrations
}
=
await
this
.
rootFront
.
listServiceWorkerRegistrations
(
)
;
this
.
_registrations
=
registrations
;
}
_getRegistrationForWorkerTarget
(
workerTarget
)
{
return
this
.
_registrations
.
find
(
r
=
>
{
return
(
r
.
evaluatingWorker
?
.
id
=
=
=
workerTarget
.
id
|
|
r
.
activeWorker
?
.
id
=
=
=
workerTarget
.
id
|
|
r
.
installingWorker
?
.
id
=
=
=
workerTarget
.
id
|
|
r
.
waitingWorker
?
.
id
=
=
=
workerTarget
.
id
)
;
}
)
;
}
_getProcessTargets
(
)
{
return
[
.
.
.
this
.
_processTargets
]
;
}
_getAllServiceWorkerTargets
(
)
{
const
allProcessTargets
=
this
.
_getProcessTargets
(
)
.
filter
(
target
=
>
this
.
targetsByProcess
.
get
(
target
)
)
;
const
serviceWorkerTargets
=
[
]
;
for
(
const
target
of
allProcessTargets
)
{
serviceWorkerTargets
.
push
(
.
.
.
this
.
targetsByProcess
.
get
(
target
)
)
;
}
return
serviceWorkerTargets
;
}
_isRegistrationValidForTarget
(
registration
)
{
if
(
this
.
targetCommand
.
descriptorFront
.
isParentProcessDescriptor
)
{
return
true
;
}
if
(
!
this
.
targetCommand
.
descriptorFront
.
isLocalTab
)
{
return
false
;
}
const
targetDomain
=
new
URL
(
this
.
target
.
url
)
.
hostname
;
try
{
const
registrationDomain
=
new
URL
(
registration
.
url
)
.
hostname
;
return
registrationDomain
=
=
=
targetDomain
;
}
catch
(
e
)
{
return
false
;
}
}
}
module
.
exports
=
{
LegacyServiceWorkersWatcher
}
;
