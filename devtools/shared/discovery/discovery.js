"
use
strict
"
;
const
{
Cu
CC
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
UDPSocket
=
CC
(
"
mozilla
.
org
/
network
/
udp
-
socket
;
1
"
"
nsIUDPSocket
"
"
init
"
)
;
const
SCAN_PORT
=
50624
;
const
UPDATE_PORT
=
50625
;
const
ADDRESS
=
"
224
.
0
.
0
.
115
"
;
const
REPLY_TIMEOUT
=
5000
;
var
logging
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
discovery
.
log
"
)
;
function
log
(
msg
)
{
if
(
logging
)
{
console
.
log
(
"
DISCOVERY
:
"
+
msg
)
;
}
}
function
Transport
(
port
)
{
EventEmitter
.
decorate
(
this
)
;
try
{
this
.
socket
=
new
UDPSocket
(
port
false
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
this
.
socket
.
joinMulticast
(
ADDRESS
)
;
this
.
socket
.
asyncListen
(
this
)
;
}
catch
(
e
)
{
log
(
"
Failed
to
start
new
socket
:
"
+
e
)
;
}
}
Transport
.
prototype
=
{
send
(
object
port
)
{
if
(
logging
)
{
log
(
"
Send
to
"
+
port
+
"
:
\
n
"
+
JSON
.
stringify
(
object
null
2
)
)
;
}
const
message
=
JSON
.
stringify
(
object
)
;
const
rawMessage
=
Uint8Array
.
from
(
message
x
=
>
x
.
charCodeAt
(
0
)
)
;
try
{
this
.
socket
.
send
(
ADDRESS
port
rawMessage
rawMessage
.
length
)
;
}
catch
(
e
)
{
log
(
"
Failed
to
send
message
:
"
+
e
)
;
}
}
destroy
(
)
{
this
.
socket
.
close
(
)
;
}
onPacketReceived
(
socket
message
)
{
const
messageData
=
message
.
data
;
const
object
=
JSON
.
parse
(
messageData
)
;
object
.
from
=
message
.
fromAddr
.
address
;
const
port
=
message
.
fromAddr
.
port
;
if
(
port
=
=
this
.
socket
.
port
)
{
log
(
"
Ignoring
looped
message
"
)
;
return
;
}
if
(
logging
)
{
log
(
"
Recv
on
"
+
this
.
socket
.
port
+
"
:
\
n
"
+
JSON
.
stringify
(
object
null
2
)
)
;
}
this
.
emit
(
"
message
"
object
)
;
}
onStopListening
(
)
{
}
}
;
function
LocalDevice
(
)
{
this
.
_name
=
LocalDevice
.
UNKNOWN
;
this
.
_get
(
)
;
}
LocalDevice
.
UNKNOWN
=
"
unknown
"
;
LocalDevice
.
prototype
=
{
_get
(
)
{
this
.
_generate
(
)
;
}
_generate
(
)
{
if
(
Services
.
appinfo
.
widgetToolkit
=
=
"
android
"
)
{
this
.
name
=
Services
.
sysinfo
.
get
(
"
device
"
)
;
}
else
{
this
.
name
=
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
.
myHostName
;
}
}
get
name
(
)
{
return
this
.
_name
;
}
set
name
(
name
)
{
this
.
_name
=
name
;
log
(
"
Device
:
"
+
this
.
_name
)
;
}
}
;
function
Discovery
(
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
localServices
=
{
}
;
this
.
remoteServices
=
{
}
;
this
.
device
=
new
LocalDevice
(
)
;
this
.
replyTimeout
=
REPLY_TIMEOUT
;
this
.
_factories
=
{
Transport
}
;
this
.
_transports
=
{
scan
:
null
update
:
null
}
;
this
.
_expectingReplies
=
{
from
:
new
Set
(
)
}
;
this
.
_onRemoteScan
=
this
.
_onRemoteScan
.
bind
(
this
)
;
this
.
_onRemoteUpdate
=
this
.
_onRemoteUpdate
.
bind
(
this
)
;
this
.
_purgeMissingDevices
=
this
.
_purgeMissingDevices
.
bind
(
this
)
;
}
Discovery
.
prototype
=
{
addService
(
service
info
)
{
log
(
"
ADDING
LOCAL
SERVICE
"
)
;
if
(
Object
.
keys
(
this
.
localServices
)
.
length
=
=
=
0
)
{
this
.
_startListeningForScan
(
)
;
}
this
.
localServices
[
service
]
=
info
;
}
removeService
(
service
)
{
delete
this
.
localServices
[
service
]
;
if
(
Object
.
keys
(
this
.
localServices
)
.
length
=
=
=
0
)
{
this
.
_stopListeningForScan
(
)
;
}
}
scan
(
)
{
this
.
_startListeningForUpdate
(
)
;
this
.
_waitForReplies
(
)
;
this
.
_sendStatusTo
(
SCAN_PORT
)
;
}
getRemoteDevices
(
)
{
const
devices
=
new
Set
(
)
;
for
(
const
service
in
this
.
remoteServices
)
{
for
(
const
device
in
this
.
remoteServices
[
service
]
)
{
devices
.
add
(
device
)
;
}
}
return
[
.
.
.
devices
]
;
}
getRemoteDevicesWithService
(
service
)
{
const
devicesWithService
=
this
.
remoteServices
[
service
]
|
|
{
}
;
return
Object
.
keys
(
devicesWithService
)
;
}
getRemoteService
(
service
device
)
{
const
devicesWithService
=
this
.
remoteServices
[
service
]
|
|
{
}
;
return
devicesWithService
[
device
]
;
}
_waitForReplies
(
)
{
clearTimeout
(
this
.
_expectingReplies
.
timer
)
;
this
.
_expectingReplies
.
from
=
new
Set
(
this
.
getRemoteDevices
(
)
)
;
this
.
_expectingReplies
.
timer
=
setTimeout
(
this
.
_purgeMissingDevices
this
.
replyTimeout
)
;
}
get
Transport
(
)
{
return
this
.
_factories
.
Transport
;
}
_startListeningForScan
(
)
{
if
(
this
.
_transports
.
scan
)
{
return
;
}
log
(
"
LISTEN
FOR
SCAN
"
)
;
this
.
_transports
.
scan
=
new
this
.
Transport
(
SCAN_PORT
)
;
this
.
_transports
.
scan
.
on
(
"
message
"
this
.
_onRemoteScan
)
;
}
_stopListeningForScan
(
)
{
if
(
!
this
.
_transports
.
scan
)
{
return
;
}
this
.
_transports
.
scan
.
off
(
"
message
"
this
.
_onRemoteScan
)
;
this
.
_transports
.
scan
.
destroy
(
)
;
this
.
_transports
.
scan
=
null
;
}
_startListeningForUpdate
(
)
{
if
(
this
.
_transports
.
update
)
{
return
;
}
log
(
"
LISTEN
FOR
UPDATE
"
)
;
this
.
_transports
.
update
=
new
this
.
Transport
(
UPDATE_PORT
)
;
this
.
_transports
.
update
.
on
(
"
message
"
this
.
_onRemoteUpdate
)
;
}
_stopListeningForUpdate
(
)
{
if
(
!
this
.
_transports
.
update
)
{
return
;
}
this
.
_transports
.
update
.
off
(
"
message
"
this
.
_onRemoteUpdate
)
;
this
.
_transports
.
update
.
destroy
(
)
;
this
.
_transports
.
update
=
null
;
}
_restartListening
(
)
{
if
(
this
.
_transports
.
scan
)
{
this
.
_stopListeningForScan
(
)
;
this
.
_startListeningForScan
(
)
;
}
if
(
this
.
_transports
.
update
)
{
this
.
_stopListeningForUpdate
(
)
;
this
.
_startListeningForUpdate
(
)
;
}
}
get
_outgoingTransport
(
)
{
if
(
this
.
_transports
.
scan
)
{
return
this
.
_transports
.
scan
;
}
if
(
this
.
_transports
.
update
)
{
return
this
.
_transports
.
update
;
}
return
null
;
}
_sendStatusTo
(
port
)
{
const
status
=
{
device
:
this
.
device
.
name
services
:
this
.
localServices
}
;
this
.
_outgoingTransport
.
send
(
status
port
)
;
}
_onRemoteScan
(
)
{
log
(
"
GOT
SCAN
REQUEST
"
)
;
this
.
_sendStatusTo
(
UPDATE_PORT
)
;
}
_onRemoteUpdate
(
update
)
{
log
(
"
GOT
REMOTE
UPDATE
"
)
;
const
remoteDevice
=
update
.
device
;
const
remoteHost
=
update
.
from
;
this
.
_expectingReplies
.
from
.
delete
(
remoteDevice
)
;
for
(
const
service
in
this
.
remoteServices
)
{
const
devicesWithService
=
this
.
remoteServices
[
service
]
;
const
hadServiceForDevice
=
!
!
devicesWithService
[
remoteDevice
]
;
const
haveServiceForDevice
=
service
in
update
.
services
;
if
(
hadServiceForDevice
&
&
!
haveServiceForDevice
)
{
delete
devicesWithService
[
remoteDevice
]
;
log
(
"
REMOVED
"
+
service
+
"
DEVICE
"
+
remoteDevice
)
;
this
.
emit
(
service
+
"
-
device
-
removed
"
remoteDevice
)
;
}
}
for
(
const
service
in
update
.
services
)
{
const
newDevice
=
!
this
.
remoteServices
[
service
]
|
|
!
this
.
remoteServices
[
service
]
[
remoteDevice
]
;
const
devicesWithService
=
this
.
remoteServices
[
service
]
|
|
{
}
;
const
oldDeviceInfo
=
devicesWithService
[
remoteDevice
]
;
const
newDeviceInfo
=
Cu
.
cloneInto
(
update
.
services
[
service
]
{
}
)
;
newDeviceInfo
.
host
=
remoteHost
;
devicesWithService
[
remoteDevice
]
=
newDeviceInfo
;
this
.
remoteServices
[
service
]
=
devicesWithService
;
if
(
newDevice
)
{
log
(
"
ADDED
"
+
service
+
"
DEVICE
"
+
remoteDevice
)
;
this
.
emit
(
service
+
"
-
device
-
added
"
remoteDevice
newDeviceInfo
)
;
}
if
(
!
newDevice
&
&
JSON
.
stringify
(
oldDeviceInfo
)
!
=
JSON
.
stringify
(
newDeviceInfo
)
)
{
log
(
"
UPDATED
"
+
service
+
"
DEVICE
"
+
remoteDevice
)
;
this
.
emit
(
service
+
"
-
device
-
updated
"
remoteDevice
newDeviceInfo
)
;
}
}
}
_purgeMissingDevices
(
)
{
log
(
"
PURGING
MISSING
DEVICES
"
)
;
for
(
const
service
in
this
.
remoteServices
)
{
const
devicesWithService
=
this
.
remoteServices
[
service
]
;
for
(
const
remoteDevice
in
devicesWithService
)
{
if
(
this
.
_expectingReplies
.
from
.
has
(
remoteDevice
)
)
{
delete
devicesWithService
[
remoteDevice
]
;
log
(
"
REMOVED
"
+
service
+
"
DEVICE
"
+
remoteDevice
)
;
this
.
emit
(
service
+
"
-
device
-
removed
"
remoteDevice
)
;
}
}
}
}
}
;
var
discovery
=
new
Discovery
(
)
;
module
.
exports
=
discovery
;
