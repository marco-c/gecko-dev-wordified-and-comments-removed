"
use
strict
"
;
function
stackDepth
(
stack
)
{
return
stack
?
1
+
stackDepth
(
stack
.
parent
)
:
0
;
}
function
run_test
(
)
{
const
debuggee
=
new
Cu
.
Sandbox
(
null
)
;
const
dbg
=
new
Debugger
(
debuggee
)
;
dbg
.
memory
.
trackingAllocationSites
=
true
;
debuggee
.
eval
(
"
this
.
objects
=
[
]
"
)
;
debuggee
.
eval
(
(
function
recursiveAllocate
(
n
)
{
if
(
n
<
=
0
)
{
return
;
}
recursiveAllocate
(
n
-
1
)
;
this
.
objects
.
push
(
{
}
)
;
}
)
.
toString
(
)
)
;
debuggee
.
eval
(
"
recursiveAllocate
=
recursiveAllocate
.
bind
(
this
)
;
"
)
;
debuggee
.
eval
(
"
recursiveAllocate
(
200
)
;
"
)
;
const
filePath
=
ChromeUtils
.
saveHeapSnapshot
(
{
runtime
:
true
}
)
;
ok
(
true
"
Should
be
able
to
save
a
snapshot
.
"
)
;
const
snapshot
=
ChromeUtils
.
readHeapSnapshot
(
filePath
)
;
ok
(
snapshot
"
Should
be
able
to
read
a
heap
snapshot
"
)
;
ok
(
snapshot
instanceof
HeapSnapshot
"
Should
be
an
instanceof
HeapSnapshot
"
)
;
const
report
=
snapshot
.
takeCensus
(
{
breakdown
:
{
by
:
"
allocationStack
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
noStack
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
}
)
;
const
MAX_STACK_DEPTH
=
60
;
let
foundStacks
=
false
;
report
.
forEach
(
(
v
k
)
=
>
{
if
(
k
=
=
=
"
noStack
"
)
{
return
;
}
foundStacks
=
true
;
const
depth
=
stackDepth
(
k
)
;
dumpn
(
"
Stack
depth
is
"
+
depth
)
;
ok
(
depth
<
=
MAX_STACK_DEPTH
"
Every
stack
should
have
depth
less
than
or
equal
to
the
maximum
stack
depth
"
)
;
}
)
;
ok
(
foundStacks
)
;
do_test_finished
(
)
;
}
