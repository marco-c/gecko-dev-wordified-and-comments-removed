function
run_test
(
)
{
run_next_test
(
)
;
}
add_task
(
function
*
test
(
)
{
const
client
=
new
HeapAnalysesClient
(
)
;
const
g
=
newGlobal
(
)
;
const
dbg
=
new
Debugger
(
g
)
;
g
.
eval
(
/
/
1
this
.
log
=
[
]
;
/
/
2
function
f
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
3
function
g
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
4
function
h
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
5
)
;
g
.
f
(
)
;
dbg
.
memory
.
allocationSamplingProbability
=
1
;
for
(
let
[
func
n
]
of
[
[
g
.
f
20
]
[
g
.
g
10
]
[
g
.
h
5
]
]
)
{
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
dbg
.
memory
.
trackingAllocationSites
=
true
;
func
(
)
;
dbg
.
memory
.
trackingAllocationSites
=
false
;
}
}
const
snapshotFilePath
=
saveNewHeapSnapshot
(
{
debugger
:
dbg
}
)
;
yield
client
.
readHeapSnapshot
(
snapshotFilePath
)
;
ok
(
true
"
Should
have
read
the
heap
snapshot
"
)
;
const
report
=
yield
client
.
takeCensus
(
snapshotFilePath
{
breakdown
:
{
by
:
'
objectClass
'
then
:
{
by
:
'
allocationStack
'
then
:
{
by
:
'
count
'
bytes
:
true
count
:
true
}
noStack
:
{
by
:
'
count
'
bytes
:
true
count
:
true
}
}
}
}
)
;
ok
(
report
"
Should
get
a
report
"
)
;
const
map
=
report
.
AllocationMarker
;
ok
(
map
"
Should
get
AllocationMarkers
in
the
report
.
"
)
;
equal
(
map
.
__proto__
.
constructor
.
name
"
Map
"
)
;
equal
(
map
.
size
4
"
Should
have
4
allocation
stacks
(
including
the
lack
of
a
stack
)
"
)
let
stacks
=
{
}
;
map
.
forEach
(
(
v
k
)
=
>
{
if
(
k
=
=
=
'
noStack
'
)
{
}
else
if
(
k
.
functionDisplayName
=
=
=
'
f
'
&
&
k
.
parent
.
functionDisplayName
=
=
=
'
test
'
)
{
stacks
.
f
=
k
;
}
else
if
(
k
.
functionDisplayName
=
=
=
'
g
'
&
&
k
.
parent
.
functionDisplayName
=
=
=
'
test
'
)
{
stacks
.
g
=
k
;
}
else
if
(
k
.
functionDisplayName
=
=
=
'
h
'
&
&
k
.
parent
.
functionDisplayName
=
=
=
'
test
'
)
{
stacks
.
h
=
k
;
}
else
{
dumpn
(
"
Unexpected
allocation
stack
:
"
)
k
.
toString
(
)
.
split
(
/
\
n
/
g
)
.
forEach
(
s
=
>
dumpn
(
s
)
)
;
ok
(
false
)
;
}
}
)
;
ok
(
map
.
get
(
'
noStack
'
)
)
;
equal
(
map
.
get
(
'
noStack
'
)
.
count
1
)
;
ok
(
stacks
.
f
)
;
ok
(
map
.
get
(
stacks
.
f
)
)
;
equal
(
map
.
get
(
stacks
.
f
)
.
count
20
)
;
ok
(
stacks
.
g
)
;
ok
(
map
.
get
(
stacks
.
g
)
)
;
equal
(
map
.
get
(
stacks
.
g
)
.
count
10
)
;
ok
(
stacks
.
h
)
;
ok
(
map
.
get
(
stacks
.
h
)
)
;
equal
(
map
.
get
(
stacks
.
h
)
.
count
5
)
;
client
.
destroy
(
)
;
}
)
;
