"
use
strict
"
;
add_task
(
async
function
test
(
)
{
const
client
=
new
HeapAnalysesClient
(
)
;
const
g
=
newGlobal
(
)
;
const
dbg
=
new
Debugger
(
g
)
;
g
.
eval
(
/
/
1
this
.
log
=
[
]
;
/
/
2
function
f
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
3
function
g
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
4
function
h
(
)
{
this
.
log
.
push
(
allocationMarker
(
)
)
;
}
/
/
5
)
;
g
.
f
(
)
;
dbg
.
memory
.
allocationSamplingProbability
=
1
;
for
(
let
[
func
n
]
of
[
[
g
.
f
20
]
[
g
.
g
10
]
[
g
.
h
5
]
]
)
{
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
dbg
.
memory
.
trackingAllocationSites
=
true
;
func
(
)
;
dbg
.
memory
.
trackingAllocationSites
=
false
;
}
}
const
snapshotFilePath
=
saveNewHeapSnapshot
(
{
debugger
:
dbg
}
)
;
await
client
.
readHeapSnapshot
(
snapshotFilePath
)
;
ok
(
true
"
Should
have
read
the
heap
snapshot
"
)
;
const
{
report
}
=
await
client
.
takeCensus
(
snapshotFilePath
{
breakdown
:
{
by
:
"
objectClass
"
then
:
{
by
:
"
allocationStack
"
then
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
noStack
:
{
by
:
"
count
"
bytes
:
true
count
:
true
}
}
}
}
)
;
ok
(
report
"
Should
get
a
report
"
)
;
const
map
=
report
.
AllocationMarker
;
ok
(
map
"
Should
get
AllocationMarkers
in
the
report
.
"
)
;
equal
(
Object
.
getPrototypeOf
(
map
)
.
constructor
.
name
"
Map
"
)
;
equal
(
map
.
size
4
"
Should
have
4
allocation
stacks
(
including
the
lack
of
a
stack
)
"
)
;
let
stacks
=
{
}
;
map
.
forEach
(
(
v
k
)
=
>
{
if
(
k
=
=
=
"
noStack
"
)
{
}
else
if
(
k
.
functionDisplayName
=
=
=
"
f
"
&
&
k
.
parent
.
functionDisplayName
=
=
=
"
test
"
)
{
stacks
.
f
=
k
;
}
else
if
(
k
.
functionDisplayName
=
=
=
"
g
"
&
&
k
.
parent
.
functionDisplayName
=
=
=
"
test
"
)
{
stacks
.
g
=
k
;
}
else
if
(
k
.
functionDisplayName
=
=
=
"
h
"
&
&
k
.
parent
.
functionDisplayName
=
=
=
"
test
"
)
{
stacks
.
h
=
k
;
}
else
{
dumpn
(
"
Unexpected
allocation
stack
:
"
)
;
k
.
toString
(
)
.
split
(
/
\
n
/
g
)
.
forEach
(
s
=
>
dumpn
(
s
)
)
;
ok
(
false
)
;
}
}
)
;
ok
(
map
.
get
(
"
noStack
"
)
)
;
equal
(
map
.
get
(
"
noStack
"
)
.
count
1
)
;
ok
(
stacks
.
f
)
;
ok
(
map
.
get
(
stacks
.
f
)
)
;
equal
(
map
.
get
(
stacks
.
f
)
.
count
20
)
;
ok
(
stacks
.
g
)
;
ok
(
map
.
get
(
stacks
.
g
)
)
;
equal
(
map
.
get
(
stacks
.
g
)
.
count
10
)
;
ok
(
stacks
.
h
)
;
ok
(
map
.
get
(
stacks
.
h
)
)
;
equal
(
map
.
get
(
stacks
.
h
)
.
count
5
)
;
client
.
destroy
(
)
;
}
)
;
