"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
)
;
importScripts
(
"
resource
:
/
/
devtools
/
shared
/
worker
/
helper
.
js
"
)
;
const
{
censusReportToCensusTreeNode
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
census
-
tree
-
node
.
js
"
)
;
const
DominatorTreeNode
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
DominatorTreeNode
.
js
"
)
;
const
CensusUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
CensusUtils
.
js
"
)
;
const
DEFAULT_START_INDEX
=
0
;
const
DEFAULT_MAX_COUNT
=
50
;
const
snapshots
=
Object
.
create
(
null
)
;
const
dominatorTrees
=
[
]
;
const
dominatorTreeSnapshots
=
[
]
;
workerHelper
.
createTask
(
self
"
readHeapSnapshot
"
(
{
snapshotFilePath
}
)
=
>
{
snapshots
[
snapshotFilePath
]
=
ChromeUtils
.
readHeapSnapshot
(
snapshotFilePath
)
;
return
true
;
}
)
;
workerHelper
.
createTask
(
self
"
deleteHeapSnapshot
"
(
{
snapshotFilePath
}
)
=
>
{
const
snapshot
=
snapshots
[
snapshotFilePath
]
;
if
(
!
snapshot
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
snapshots
[
snapshotFilePath
]
=
undefined
;
const
dominatorTreeId
=
dominatorTreeSnapshots
.
indexOf
(
snapshot
)
;
if
(
dominatorTreeId
!
=
-
1
)
{
dominatorTreeSnapshots
[
dominatorTreeId
]
=
undefined
;
dominatorTrees
[
dominatorTreeId
]
=
undefined
;
}
}
)
;
workerHelper
.
createTask
(
self
"
takeCensus
"
(
{
snapshotFilePath
censusOptions
requestOptions
}
)
=
>
{
if
(
!
snapshots
[
snapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
let
report
=
snapshots
[
snapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
let
parentMap
;
if
(
requestOptions
.
asTreeNode
|
|
requestOptions
.
asInvertedTreeNode
)
{
const
opts
=
{
filter
:
requestOptions
.
filter
|
|
null
}
;
if
(
requestOptions
.
asInvertedTreeNode
)
{
opts
.
invert
=
true
;
}
report
=
censusReportToCensusTreeNode
(
censusOptions
.
breakdown
report
opts
)
;
parentMap
=
CensusUtils
.
createParentMap
(
report
)
;
}
return
{
report
parentMap
}
;
}
)
;
workerHelper
.
createTask
(
self
"
getCensusIndividuals
"
request
=
>
{
const
{
dominatorTreeId
indices
censusBreakdown
labelBreakdown
maxRetainingPaths
maxIndividuals
}
=
request
;
const
dominatorTree
=
dominatorTrees
[
dominatorTreeId
]
;
if
(
!
dominatorTree
)
{
throw
new
Error
(
There
does
not
exist
a
DominatorTree
with
the
id
{
dominatorTreeId
}
)
;
}
const
snapshot
=
dominatorTreeSnapshots
[
dominatorTreeId
]
;
const
nodeIds
=
CensusUtils
.
getCensusIndividuals
(
indices
censusBreakdown
snapshot
)
;
const
nodes
=
nodeIds
.
sort
(
(
a
b
)
=
>
dominatorTree
.
getRetainedSize
(
b
)
-
dominatorTree
.
getRetainedSize
(
a
)
)
.
slice
(
0
maxIndividuals
)
.
map
(
id
=
>
{
const
{
label
shallowSize
}
=
DominatorTreeNode
.
getLabelAndShallowSize
(
id
snapshot
labelBreakdown
)
;
const
retainedSize
=
dominatorTree
.
getRetainedSize
(
id
)
;
const
node
=
new
DominatorTreeNode
(
id
label
shallowSize
retainedSize
)
;
node
.
moreChildrenAvailable
=
false
;
return
node
;
}
)
;
DominatorTreeNode
.
attachShortestPaths
(
snapshot
labelBreakdown
dominatorTree
.
root
nodes
maxRetainingPaths
)
;
return
{
nodes
}
;
}
)
;
workerHelper
.
createTask
(
self
"
takeCensusDiff
"
request
=
>
{
const
{
firstSnapshotFilePath
secondSnapshotFilePath
censusOptions
requestOptions
}
=
request
;
if
(
!
snapshots
[
firstSnapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
firstSnapshotFilePath
}
'
)
;
}
if
(
!
snapshots
[
secondSnapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
secondSnapshotFilePath
}
'
)
;
}
const
first
=
snapshots
[
firstSnapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
const
second
=
snapshots
[
secondSnapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
let
delta
=
CensusUtils
.
diff
(
censusOptions
.
breakdown
first
second
)
;
let
parentMap
;
if
(
requestOptions
.
asTreeNode
|
|
requestOptions
.
asInvertedTreeNode
)
{
const
opts
=
{
filter
:
requestOptions
.
filter
|
|
null
}
;
if
(
requestOptions
.
asInvertedTreeNode
)
{
opts
.
invert
=
true
;
}
delta
=
censusReportToCensusTreeNode
(
censusOptions
.
breakdown
delta
opts
)
;
parentMap
=
CensusUtils
.
createParentMap
(
delta
)
;
}
return
{
delta
parentMap
}
;
}
)
;
workerHelper
.
createTask
(
self
"
getCreationTime
"
snapshotFilePath
=
>
{
if
(
!
snapshots
[
snapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
return
snapshots
[
snapshotFilePath
]
.
creationTime
;
}
)
;
workerHelper
.
createTask
(
self
"
computeDominatorTree
"
snapshotFilePath
=
>
{
const
snapshot
=
snapshots
[
snapshotFilePath
]
;
if
(
!
snapshot
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
const
id
=
dominatorTrees
.
length
;
dominatorTrees
.
push
(
snapshot
.
computeDominatorTree
(
)
)
;
dominatorTreeSnapshots
.
push
(
snapshot
)
;
return
id
;
}
)
;
workerHelper
.
createTask
(
self
"
getDominatorTree
"
request
=
>
{
const
{
dominatorTreeId
breakdown
maxDepth
maxSiblings
maxRetainingPaths
}
=
request
;
if
(
!
(
dominatorTreeId
>
=
0
&
&
dominatorTreeId
<
dominatorTrees
.
length
)
)
{
throw
new
Error
(
There
does
not
exist
a
DominatorTree
with
the
id
{
dominatorTreeId
}
)
;
}
const
dominatorTree
=
dominatorTrees
[
dominatorTreeId
]
;
const
snapshot
=
dominatorTreeSnapshots
[
dominatorTreeId
]
;
const
tree
=
DominatorTreeNode
.
partialTraversal
(
dominatorTree
snapshot
breakdown
maxDepth
maxSiblings
)
;
const
nodes
=
[
]
;
(
function
getNodes
(
node
)
{
nodes
.
push
(
node
)
;
if
(
node
.
children
)
{
for
(
let
i
=
0
length
=
node
.
children
.
length
;
i
<
length
;
i
+
+
)
{
getNodes
(
node
.
children
[
i
]
)
;
}
}
}
)
(
tree
)
;
DominatorTreeNode
.
attachShortestPaths
(
snapshot
breakdown
dominatorTree
.
root
nodes
maxRetainingPaths
)
;
return
tree
;
}
)
;
workerHelper
.
createTask
(
self
"
getImmediatelyDominated
"
request
=
>
{
const
{
dominatorTreeId
nodeId
breakdown
startIndex
maxCount
maxRetainingPaths
}
=
request
;
if
(
!
(
dominatorTreeId
>
=
0
&
&
dominatorTreeId
<
dominatorTrees
.
length
)
)
{
throw
new
Error
(
There
does
not
exist
a
DominatorTree
with
the
id
{
dominatorTreeId
}
)
;
}
const
dominatorTree
=
dominatorTrees
[
dominatorTreeId
]
;
const
snapshot
=
dominatorTreeSnapshots
[
dominatorTreeId
]
;
const
childIds
=
dominatorTree
.
getImmediatelyDominated
(
nodeId
)
;
if
(
!
childIds
)
{
throw
new
Error
(
{
nodeId
}
is
not
a
node
id
in
the
dominator
tree
)
;
}
const
start
=
startIndex
|
|
DEFAULT_START_INDEX
;
const
count
=
maxCount
|
|
DEFAULT_MAX_COUNT
;
const
end
=
start
+
count
;
const
nodes
=
childIds
.
slice
(
start
end
)
.
map
(
id
=
>
{
const
{
label
shallowSize
}
=
DominatorTreeNode
.
getLabelAndShallowSize
(
id
snapshot
breakdown
)
;
const
retainedSize
=
dominatorTree
.
getRetainedSize
(
id
)
;
const
node
=
new
DominatorTreeNode
(
id
label
shallowSize
retainedSize
)
;
node
.
parentId
=
nodeId
;
node
.
moreChildrenAvailable
=
dominatorTree
.
getImmediatelyDominated
(
id
)
.
length
>
0
;
return
node
;
}
)
;
const
path
=
[
]
;
let
id
=
nodeId
;
do
{
path
.
push
(
id
)
;
id
=
dominatorTree
.
getImmediateDominator
(
id
)
;
}
while
(
id
!
=
=
null
)
;
path
.
reverse
(
)
;
const
moreChildrenAvailable
=
childIds
.
length
>
end
;
DominatorTreeNode
.
attachShortestPaths
(
snapshot
breakdown
dominatorTree
.
root
nodes
maxRetainingPaths
)
;
return
{
nodes
moreChildrenAvailable
path
}
;
}
)
;
