"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
)
;
importScripts
(
"
resource
:
/
/
devtools
/
shared
/
worker
/
helper
.
js
"
)
;
const
{
censusReportToCensusTreeNode
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
census
-
tree
-
node
.
js
"
)
;
const
DominatorTreeNode
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
DominatorTreeNode
.
js
"
)
;
const
CensusUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
heapsnapshot
/
CensusUtils
.
js
"
)
;
const
DEFAULT_START_INDEX
=
0
;
const
DEFAULT_MAX_COUNT
=
50
;
const
snapshots
=
Object
.
create
(
null
)
;
workerHelper
.
createTask
(
self
"
readHeapSnapshot
"
(
{
snapshotFilePath
}
)
=
>
{
snapshots
[
snapshotFilePath
]
=
ThreadSafeChromeUtils
.
readHeapSnapshot
(
snapshotFilePath
)
;
return
true
;
}
)
;
workerHelper
.
createTask
(
self
"
takeCensus
"
(
{
snapshotFilePath
censusOptions
requestOptions
}
)
=
>
{
if
(
!
snapshots
[
snapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
const
report
=
snapshots
[
snapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
if
(
requestOptions
.
asTreeNode
|
|
requestOptions
.
asInvertedTreeNode
)
{
const
opts
=
{
filter
:
requestOptions
.
filter
|
|
null
}
;
if
(
requestOptions
.
asInvertedTreeNode
)
{
opts
.
invert
=
true
;
}
return
censusReportToCensusTreeNode
(
censusOptions
.
breakdown
report
opts
)
;
}
return
report
;
}
)
;
workerHelper
.
createTask
(
self
"
takeCensusDiff
"
request
=
>
{
const
{
firstSnapshotFilePath
secondSnapshotFilePath
censusOptions
requestOptions
}
=
request
;
if
(
!
snapshots
[
firstSnapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
firstSnapshotFilePath
}
'
)
;
}
if
(
!
snapshots
[
secondSnapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
secondSnapshotFilePath
}
'
)
;
}
const
first
=
snapshots
[
firstSnapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
const
second
=
snapshots
[
secondSnapshotFilePath
]
.
takeCensus
(
censusOptions
)
;
const
delta
=
CensusUtils
.
diff
(
censusOptions
.
breakdown
first
second
)
;
if
(
requestOptions
.
asTreeNode
|
|
requestOptions
.
asInvertedTreeNode
)
{
const
opts
=
{
filter
:
requestOptions
.
filter
|
|
null
}
;
if
(
requestOptions
.
asInvertedTreeNode
)
{
opts
.
invert
=
true
;
}
return
censusReportToCensusTreeNode
(
censusOptions
.
breakdown
delta
opts
)
;
}
return
delta
;
}
)
;
workerHelper
.
createTask
(
self
"
getCreationTime
"
snapshotFilePath
=
>
{
if
(
!
snapshots
[
snapshotFilePath
]
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
return
snapshots
[
snapshotFilePath
]
.
creationTime
;
}
)
;
const
dominatorTrees
=
[
]
;
const
dominatorTreeSnapshots
=
[
]
;
workerHelper
.
createTask
(
self
"
computeDominatorTree
"
snapshotFilePath
=
>
{
const
snapshot
=
snapshots
[
snapshotFilePath
]
;
if
(
!
snapshot
)
{
throw
new
Error
(
No
known
heap
snapshot
for
'
{
snapshotFilePath
}
'
)
;
}
const
id
=
dominatorTrees
.
length
;
dominatorTrees
.
push
(
snapshot
.
computeDominatorTree
(
)
)
;
dominatorTreeSnapshots
.
push
(
snapshot
)
;
return
id
;
}
)
;
workerHelper
.
createTask
(
self
"
getDominatorTree
"
request
=
>
{
const
{
dominatorTreeId
breakdown
maxDepth
maxSiblings
}
=
request
;
if
(
!
(
0
<
=
dominatorTreeId
&
&
dominatorTreeId
<
dominatorTrees
.
length
)
)
{
throw
new
Error
(
There
does
not
exist
a
DominatorTree
with
the
id
{
dominatorTreeId
}
)
;
}
const
dominatorTree
=
dominatorTrees
[
dominatorTreeId
]
;
const
snapshot
=
dominatorTreeSnapshots
[
dominatorTreeId
]
;
return
DominatorTreeNode
.
partialTraversal
(
dominatorTree
snapshot
breakdown
maxDepth
maxSiblings
)
;
}
)
;
workerHelper
.
createTask
(
self
"
getImmediatelyDominated
"
request
=
>
{
const
{
dominatorTreeId
nodeId
breakdown
startIndex
maxCount
}
=
request
;
if
(
!
(
0
<
=
dominatorTreeId
&
&
dominatorTreeId
<
dominatorTrees
.
length
)
)
{
throw
new
Error
(
There
does
not
exist
a
DominatorTree
with
the
id
{
dominatorTreeId
}
)
;
}
const
dominatorTree
=
dominatorTrees
[
dominatorTreeId
]
;
const
snapshot
=
dominatorTreeSnapshots
[
dominatorTreeId
]
;
const
childIds
=
dominatorTree
.
getImmediatelyDominated
(
nodeId
)
;
if
(
!
childIds
)
{
throw
new
Error
(
{
nodeId
}
is
not
a
node
id
in
the
dominator
tree
)
;
}
const
start
=
startIndex
|
|
DEFAULT_START_INDEX
;
const
count
=
maxCount
|
|
DEFAULT_MAX_COUNT
;
const
end
=
start
+
count
;
const
nodes
=
childIds
.
slice
(
start
end
)
.
map
(
id
=
>
{
const
{
label
shallowSize
}
=
DominatorTreeNode
.
getLabelAndShallowSize
(
id
snapshot
breakdown
)
;
const
retainedSize
=
dominatorTree
.
getRetainedSize
(
id
)
;
const
node
=
new
DominatorTreeNode
(
id
label
shallowSize
retainedSize
)
;
node
.
parentId
=
nodeId
;
node
.
moreChildrenAvailable
=
dominatorTree
.
getImmediatelyDominated
(
id
)
.
length
>
0
;
return
node
;
}
)
;
const
path
=
[
]
;
let
id
=
nodeId
;
do
{
path
.
push
(
id
)
;
id
=
dominatorTree
.
getImmediateDominator
(
id
)
;
}
while
(
id
!
=
=
null
)
;
path
.
reverse
(
)
;
const
moreChildrenAvailable
=
childIds
.
length
>
end
;
return
{
nodes
moreChildrenAvailable
path
}
;
}
)
;
