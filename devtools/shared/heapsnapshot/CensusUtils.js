"
use
strict
"
;
const
{
flatten
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
ThreadSafeDevToolsUtils
.
js
"
)
;
class
Visitor
{
enter
(
)
{
}
exit
(
)
{
}
count
(
)
{
}
}
exports
.
Visitor
=
Visitor
;
const
EDGES
=
Object
.
create
(
null
)
;
EDGES
.
count
=
function
(
)
{
return
[
]
;
}
;
EDGES
.
bucket
=
function
(
)
{
return
[
]
;
}
;
EDGES
.
internalType
=
function
(
breakdown
report
)
{
return
Object
.
keys
(
report
)
.
map
(
key
=
>
(
{
edge
:
key
referent
:
report
[
key
]
breakdown
:
breakdown
.
then
}
)
)
;
}
;
EDGES
.
descriptiveType
=
function
(
breakdown
report
)
{
return
Object
.
keys
(
report
)
.
map
(
key
=
>
(
{
edge
:
key
referent
:
report
[
key
]
breakdown
:
breakdown
.
then
}
)
)
;
}
;
EDGES
.
objectClass
=
function
(
breakdown
report
)
{
return
Object
.
keys
(
report
)
.
map
(
key
=
>
(
{
edge
:
key
referent
:
report
[
key
]
breakdown
:
key
=
=
=
"
other
"
?
breakdown
.
other
:
breakdown
.
then
}
)
)
;
}
;
EDGES
.
coarseType
=
function
(
breakdown
report
)
{
return
[
{
edge
:
"
objects
"
referent
:
report
.
objects
breakdown
:
breakdown
.
objects
}
{
edge
:
"
scripts
"
referent
:
report
.
scripts
breakdown
:
breakdown
.
scripts
}
{
edge
:
"
strings
"
referent
:
report
.
strings
breakdown
:
breakdown
.
strings
}
{
edge
:
"
other
"
referent
:
report
.
other
breakdown
:
breakdown
.
other
}
{
edge
:
"
domNode
"
referent
:
report
.
domNode
breakdown
:
breakdown
.
domNode
}
]
;
}
;
EDGES
.
allocationStack
=
function
(
breakdown
report
)
{
const
edges
=
[
]
;
report
.
forEach
(
(
value
key
)
=
>
{
edges
.
push
(
{
edge
:
key
referent
:
value
breakdown
:
key
=
=
=
"
noStack
"
?
breakdown
.
noStack
:
breakdown
.
then
}
)
;
}
)
;
return
edges
;
}
;
EDGES
.
filename
=
function
(
breakdown
report
)
{
return
Object
.
keys
(
report
)
.
map
(
key
=
>
(
{
edge
:
key
referent
:
report
[
key
]
breakdown
:
key
=
=
=
"
noFilename
"
?
breakdown
.
noFilename
:
breakdown
.
then
}
)
)
;
}
;
function
getReportEdges
(
breakdown
report
)
{
return
EDGES
[
breakdown
.
by
]
(
breakdown
report
)
;
}
exports
.
getReportEdges
=
getReportEdges
;
function
recursiveWalk
(
breakdown
edge
report
visitor
)
{
if
(
breakdown
.
by
=
=
=
"
count
"
)
{
visitor
.
enter
(
breakdown
report
edge
)
;
visitor
.
count
(
breakdown
report
edge
)
;
visitor
.
exit
(
breakdown
report
edge
)
;
}
else
{
visitor
.
enter
(
breakdown
report
edge
)
;
for
(
const
{
edge
:
ed
referent
breakdown
:
subBreakdown
}
of
getReportEdges
(
breakdown
report
)
)
{
recursiveWalk
(
subBreakdown
ed
referent
visitor
)
;
}
visitor
.
exit
(
breakdown
report
edge
)
;
}
}
function
walk
(
breakdown
report
visitor
)
{
recursiveWalk
(
breakdown
null
report
visitor
)
;
}
exports
.
walk
=
walk
;
function
isMap
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
"
[
object
Map
]
"
;
}
const
basisTotalBytes
=
(
exports
.
basisTotalBytes
=
Symbol
(
"
basisTotalBytes
"
)
)
;
const
basisTotalCount
=
(
exports
.
basisTotalCount
=
Symbol
(
"
basisTotalCount
"
)
)
;
class
DiffVisitor
extends
Visitor
{
constructor
(
otherCensus
)
{
super
(
)
;
this
.
_otherCensus
=
otherCensus
;
this
.
_totalBytes
=
0
;
this
.
_totalCount
=
0
;
this
.
_otherCensusStack
=
[
]
;
this
.
_edgesVisited
=
[
new
Set
(
)
]
;
this
.
_results
=
null
;
this
.
_resultsStack
=
[
]
;
}
_get
(
report
edge
)
{
if
(
!
report
)
{
return
undefined
;
}
return
isMap
(
report
)
?
report
.
get
(
edge
)
:
report
[
edge
]
;
}
_set
(
report
edge
val
)
{
if
(
isMap
(
report
)
)
{
report
.
set
(
edge
val
)
;
}
else
{
report
[
edge
]
=
val
;
}
}
enter
(
breakdown
report
edge
)
{
const
newResults
=
breakdown
.
by
=
=
=
"
allocationStack
"
?
new
Map
(
)
:
{
}
;
let
newOther
;
if
(
!
this
.
_results
)
{
this
.
_results
=
newResults
;
newOther
=
this
.
_otherCensus
;
}
else
{
const
topResults
=
this
.
_resultsStack
[
this
.
_resultsStack
.
length
-
1
]
;
this
.
_set
(
topResults
edge
newResults
)
;
const
topOther
=
this
.
_otherCensusStack
[
this
.
_otherCensusStack
.
length
-
1
]
;
newOther
=
this
.
_get
(
topOther
edge
)
;
}
this
.
_resultsStack
.
push
(
newResults
)
;
this
.
_otherCensusStack
.
push
(
newOther
)
;
const
visited
=
this
.
_edgesVisited
[
this
.
_edgesVisited
.
length
-
1
]
;
visited
.
add
(
edge
)
;
this
.
_edgesVisited
.
push
(
new
Set
(
)
)
;
}
exit
(
breakdown
)
{
const
other
=
this
.
_otherCensusStack
[
this
.
_otherCensusStack
.
length
-
1
]
;
if
(
other
)
{
const
visited
=
this
.
_edgesVisited
[
this
.
_edgesVisited
.
length
-
1
]
;
const
unvisited
=
getReportEdges
(
breakdown
other
)
.
map
(
e
=
>
e
.
edge
)
.
filter
(
e
=
>
!
visited
.
has
(
e
)
)
;
const
results
=
this
.
_resultsStack
[
this
.
_resultsStack
.
length
-
1
]
;
for
(
const
edg
of
unvisited
)
{
this
.
_set
(
results
edg
this
.
_get
(
other
edg
)
)
;
}
}
this
.
_otherCensusStack
.
pop
(
)
;
this
.
_resultsStack
.
pop
(
)
;
this
.
_edgesVisited
.
pop
(
)
;
}
count
(
breakdown
report
)
{
const
other
=
this
.
_otherCensusStack
[
this
.
_otherCensusStack
.
length
-
1
]
;
const
results
=
this
.
_resultsStack
[
this
.
_resultsStack
.
length
-
1
]
;
if
(
breakdown
.
count
)
{
this
.
_totalCount
+
=
report
.
count
;
}
if
(
breakdown
.
bytes
)
{
this
.
_totalBytes
+
=
report
.
bytes
;
}
if
(
other
)
{
if
(
breakdown
.
count
)
{
results
.
count
=
other
.
count
-
report
.
count
;
}
if
(
breakdown
.
bytes
)
{
results
.
bytes
=
other
.
bytes
-
report
.
bytes
;
}
}
else
{
if
(
breakdown
.
count
)
{
results
.
count
=
-
report
.
count
;
}
if
(
breakdown
.
bytes
)
{
results
.
bytes
=
-
report
.
bytes
;
}
}
}
results
(
)
{
if
(
!
this
.
_results
)
{
throw
new
Error
(
"
Attempt
to
get
results
before
computing
diff
!
"
)
;
}
if
(
this
.
_resultsStack
.
length
)
{
throw
new
Error
(
"
Attempt
to
get
results
while
still
computing
diff
!
"
)
;
}
this
.
_results
[
basisTotalBytes
]
=
this
.
_totalBytes
;
this
.
_results
[
basisTotalCount
]
=
this
.
_totalCount
;
return
this
.
_results
;
}
}
function
diff
(
breakdown
startCensus
endCensus
)
{
const
visitor
=
new
DiffVisitor
(
endCensus
)
;
walk
(
breakdown
startCensus
visitor
)
;
return
visitor
.
results
(
)
;
}
exports
.
diff
=
diff
;
const
createParentMap
=
function
(
node
getId
=
n
=
>
n
.
id
aggregator
=
{
}
)
{
if
(
node
.
children
)
{
for
(
let
i
=
0
length
=
node
.
children
.
length
;
i
<
length
;
i
+
+
)
{
const
child
=
node
.
children
[
i
]
;
aggregator
[
getId
(
child
)
]
=
node
;
createParentMap
(
child
getId
aggregator
)
;
}
}
return
aggregator
;
}
;
exports
.
createParentMap
=
createParentMap
;
const
BUCKET
=
Object
.
freeze
(
{
by
:
"
bucket
"
}
)
;
exports
.
countToBucketBreakdown
=
function
(
breakdown
)
{
if
(
typeof
breakdown
!
=
=
"
object
"
|
|
!
breakdown
)
{
return
breakdown
;
}
if
(
breakdown
.
by
=
=
=
"
count
"
)
{
return
BUCKET
;
}
const
keys
=
Object
.
keys
(
breakdown
)
;
const
vals
=
keys
.
reduce
(
(
vs
k
)
=
>
{
vs
.
push
(
exports
.
countToBucketBreakdown
(
breakdown
[
k
]
)
)
;
return
vs
;
}
[
]
)
;
const
result
=
{
}
;
for
(
let
i
=
0
length
=
keys
.
length
;
i
<
length
;
i
+
+
)
{
result
[
keys
[
i
]
]
=
vals
[
i
]
;
}
return
Object
.
freeze
(
result
)
;
}
;
class
GetLeavesVisitor
extends
Visitor
{
constructor
(
targetIndices
)
{
super
(
)
;
this
.
_index
=
-
1
;
this
.
_targetIndices
=
targetIndices
;
this
.
_leaves
=
[
]
;
}
enter
(
breakdown
report
)
{
this
.
_index
+
+
;
if
(
this
.
_targetIndices
.
has
(
this
.
_index
)
)
{
this
.
_leaves
.
push
(
report
)
;
}
}
leaves
(
)
{
if
(
this
.
_index
=
=
=
-
1
)
{
throw
new
Error
(
"
Attempt
to
call
leaves
before
traversing
report
!
"
)
;
}
return
this
.
_leaves
;
}
}
exports
.
getReportLeaves
=
function
(
indices
breakdown
report
)
{
const
visitor
=
new
GetLeavesVisitor
(
indices
)
;
walk
(
breakdown
report
visitor
)
;
return
visitor
.
leaves
(
)
;
}
;
exports
.
getCensusIndividuals
=
function
(
indices
countBreakdown
snapshot
)
{
const
bucketBreakdown
=
exports
.
countToBucketBreakdown
(
countBreakdown
)
;
const
bucketReport
=
snapshot
.
takeCensus
(
{
breakdown
:
bucketBreakdown
}
)
;
const
buckets
=
exports
.
getReportLeaves
(
indices
bucketBreakdown
bucketReport
)
;
return
flatten
(
buckets
)
;
}
;
