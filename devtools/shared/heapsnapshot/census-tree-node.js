"
use
strict
"
;
const
COARSE_TYPES
=
new
Set
(
[
"
objects
"
"
scripts
"
"
strings
"
"
other
"
]
)
;
function
CensusTreeNode
(
breakdown
report
name
)
{
this
.
name
=
name
;
this
.
bytes
=
void
0
;
this
.
count
=
void
0
;
this
.
children
=
void
0
;
CensusTreeNodeBreakdowns
[
breakdown
.
by
]
(
this
breakdown
report
)
;
if
(
this
.
children
)
{
this
.
children
.
sort
(
sortByBytes
)
;
}
}
CensusTreeNode
.
prototype
=
null
;
const
CensusTreeNodeBreakdowns
=
Object
.
create
(
null
)
;
CensusTreeNodeBreakdowns
.
count
=
function
(
node
breakdown
report
)
{
if
(
breakdown
.
bytes
=
=
=
true
)
{
node
.
bytes
=
report
.
bytes
;
}
if
(
breakdown
.
count
=
=
=
true
)
{
node
.
count
=
report
.
count
;
}
}
;
CensusTreeNodeBreakdowns
.
internalType
=
function
(
node
breakdown
report
)
{
node
.
children
=
[
]
;
for
(
let
key
of
Object
.
keys
(
report
)
)
{
node
.
children
.
push
(
new
CensusTreeNode
(
breakdown
.
then
report
[
key
]
key
)
)
;
}
}
CensusTreeNodeBreakdowns
.
objectClass
=
function
(
node
breakdown
report
)
{
node
.
children
=
[
]
;
for
(
let
key
of
Object
.
keys
(
report
)
)
{
let
bd
=
key
=
=
=
"
other
"
?
breakdown
.
other
:
breakdown
.
then
;
node
.
children
.
push
(
new
CensusTreeNode
(
bd
report
[
key
]
key
)
)
;
}
}
CensusTreeNodeBreakdowns
.
coarseType
=
function
(
node
breakdown
report
)
{
node
.
children
=
[
]
;
for
(
let
type
of
Object
.
keys
(
breakdown
)
.
filter
(
type
=
>
COARSE_TYPES
.
has
(
type
)
)
)
{
node
.
children
.
push
(
new
CensusTreeNode
(
breakdown
[
type
]
report
[
type
]
type
)
)
;
}
}
function
sortByBytes
(
a
b
)
{
return
(
b
.
bytes
|
|
0
)
-
(
a
.
bytes
|
|
0
)
;
}
exports
.
CensusTreeNode
=
CensusTreeNode
;
