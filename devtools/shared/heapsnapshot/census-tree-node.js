"
use
strict
"
;
const
{
Visitor
walk
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
shared
/
heapsnapshot
/
CensusUtils
.
js
"
)
;
function
isSavedFrame
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
"
[
object
SavedFrame
]
"
;
}
function
FrameCache
(
)
{
}
FrameCache
.
prototype
=
null
;
function
FrameCacheValue
(
frame
)
{
this
.
node
=
new
CensusTreeNode
(
frame
)
;
this
.
children
=
undefined
;
}
FrameCacheValue
.
prototype
=
null
;
FrameCache
.
hash
=
function
(
frame
)
{
return
{
frame
.
functionDisplayName
}
{
frame
.
source
}
{
frame
.
line
}
{
frame
.
column
}
{
frame
.
asyncCause
}
;
}
;
FrameCache
.
insert
=
function
(
cache
frame
value
)
{
cache
[
FrameCache
.
hash
(
frame
)
]
=
value
;
}
;
FrameCache
.
lookup
=
function
(
cache
frame
)
{
return
cache
[
FrameCache
.
hash
(
frame
)
]
;
}
;
function
addChild
(
parent
child
)
{
if
(
!
parent
.
children
)
{
parent
.
children
=
[
]
;
}
parent
.
children
.
push
(
child
)
;
}
function
getArrayOfFrames
(
stack
)
{
const
frames
=
[
]
;
let
frame
=
stack
;
while
(
frame
)
{
frames
.
push
(
frame
)
;
frame
=
frame
.
parent
;
}
frames
.
reverse
(
)
;
return
frames
;
}
function
makeCensusTreeNodeSubTree
(
breakdown
report
edge
frameCache
outParams
)
{
if
(
!
isSavedFrame
(
edge
)
)
{
const
node
=
new
CensusTreeNode
(
edge
)
;
outParams
.
top
=
outParams
.
bottom
=
node
;
return
;
}
const
frames
=
getArrayOfFrames
(
edge
)
;
let
cache
=
frameCache
;
let
prevNode
;
for
(
let
i
=
0
length
=
frames
.
length
;
i
<
length
;
i
+
+
)
{
const
frame
=
frames
[
i
]
;
let
isNewNode
=
false
;
let
val
=
FrameCache
.
lookup
(
cache
frame
)
;
if
(
!
val
)
{
isNewNode
=
true
;
val
=
new
FrameCacheValue
(
frame
)
;
FrameCache
.
insert
(
cache
frame
val
)
;
if
(
prevNode
)
{
addChild
(
prevNode
val
.
node
)
;
}
}
if
(
i
=
=
=
0
)
{
outParams
.
bottom
=
isNewNode
?
val
.
node
:
null
;
}
if
(
i
=
=
=
length
-
1
)
{
outParams
.
top
=
val
.
node
;
}
prevNode
=
val
.
node
;
if
(
i
!
=
=
length
-
1
&
&
!
val
.
children
)
{
val
.
children
=
new
FrameCache
(
)
;
}
cache
=
val
.
children
;
}
}
function
CensusTreeNodeVisitor
(
)
{
this
.
_root
=
null
;
this
.
_nodeStack
=
[
]
;
this
.
_outParams
=
{
top
:
null
bottom
:
null
}
;
this
.
_frameCacheStack
=
[
new
FrameCache
(
)
]
;
}
CensusTreeNodeVisitor
.
prototype
=
Object
.
create
(
Visitor
)
;
CensusTreeNodeVisitor
.
prototype
.
enter
=
function
(
breakdown
report
edge
)
{
const
cache
=
this
.
_frameCacheStack
[
this
.
_frameCacheStack
.
length
-
1
]
;
makeCensusTreeNodeSubTree
(
breakdown
report
edge
cache
this
.
_outParams
)
;
const
{
top
bottom
}
=
this
.
_outParams
;
if
(
!
this
.
_root
)
{
this
.
_root
=
bottom
;
}
else
{
if
(
bottom
)
{
addChild
(
this
.
_nodeStack
[
this
.
_nodeStack
.
length
-
1
]
bottom
)
;
}
}
this
.
_frameCacheStack
.
push
(
new
FrameCache
)
;
this
.
_nodeStack
.
push
(
top
)
;
}
;
function
values
(
cache
)
{
return
Object
.
keys
(
cache
)
.
map
(
k
=
>
cache
[
k
]
)
;
}
CensusTreeNodeVisitor
.
prototype
.
exit
=
function
(
breakdown
report
edge
)
{
function
dfs
(
node
childrenCache
)
{
if
(
childrenCache
)
{
const
childValues
=
values
(
childrenCache
)
;
for
(
let
i
=
0
length
=
childValues
.
length
;
i
<
length
;
i
+
+
)
{
dfs
(
childValues
[
i
]
.
node
childValues
[
i
]
.
children
)
;
}
}
node
.
totalCount
=
node
.
count
;
node
.
totalBytes
=
node
.
bytes
;
if
(
node
.
children
)
{
node
.
children
.
sort
(
compareByTotalBytes
)
;
for
(
let
i
=
0
length
=
node
.
children
.
length
;
i
<
length
;
i
+
+
)
{
node
.
totalCount
+
=
node
.
children
[
i
]
.
totalCount
;
node
.
totalBytes
+
=
node
.
children
[
i
]
.
totalBytes
;
}
}
}
const
top
=
this
.
_nodeStack
.
pop
(
)
;
const
cache
=
this
.
_frameCacheStack
.
pop
(
)
;
dfs
(
top
cache
)
;
}
;
CensusTreeNodeVisitor
.
prototype
.
count
=
function
(
breakdown
report
edge
)
{
const
node
=
this
.
_nodeStack
[
this
.
_nodeStack
.
length
-
1
]
;
if
(
breakdown
.
count
)
{
node
.
count
=
report
.
count
;
}
if
(
breakdown
.
bytes
)
{
node
.
bytes
=
report
.
bytes
;
}
}
;
CensusTreeNodeVisitor
.
prototype
.
root
=
function
(
)
{
if
(
!
this
.
_root
)
{
throw
new
Error
(
"
Attempt
to
get
the
root
before
walking
the
census
report
!
"
)
;
}
if
(
this
.
_nodeStack
.
length
)
{
throw
new
Error
(
"
Attempt
to
get
the
root
while
walking
the
census
report
!
"
)
;
}
return
this
.
_root
;
}
;
function
CensusTreeNode
(
name
)
{
this
.
name
=
name
;
this
.
bytes
=
0
;
this
.
totalBytes
=
0
;
this
.
count
=
0
;
this
.
totalCount
=
0
;
this
.
children
=
undefined
;
}
CensusTreeNode
.
prototype
=
null
;
function
compareByTotalBytes
(
node1
node2
)
{
return
node2
.
totalBytes
-
node1
.
totalBytes
|
|
node2
.
bytes
-
node1
.
bytes
|
|
node2
.
totalCount
-
node1
.
totalCount
|
|
node2
.
count
-
node1
.
count
;
}
exports
.
censusReportToCensusTreeNode
=
function
(
breakdown
report
)
{
const
visitor
=
new
CensusTreeNodeVisitor
(
)
;
walk
(
breakdown
report
visitor
)
;
return
visitor
.
root
(
)
;
}
;
