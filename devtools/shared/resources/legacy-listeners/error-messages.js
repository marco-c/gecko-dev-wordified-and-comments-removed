"
use
strict
"
;
const
{
ResourceWatcher
}
=
require
(
"
devtools
/
shared
/
resources
/
resource
-
watcher
"
)
;
const
{
MESSAGE_CATEGORY
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
module
.
exports
=
async
function
(
{
targetList
targetFront
isFissionEnabledOnContentToolbox
onAvailable
}
)
{
const
isContentToolbox
=
targetList
.
targetFront
.
isLocalTab
;
const
listenForFrames
=
isContentToolbox
&
&
isFissionEnabledOnContentToolbox
;
const
isAllowed
=
targetFront
.
isTopLevel
|
|
targetFront
.
targetType
=
=
=
targetList
.
TYPES
.
PROCESS
|
|
(
targetFront
.
targetType
=
=
=
targetList
.
TYPES
.
FRAME
&
&
listenForFrames
)
;
if
(
!
isAllowed
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
await
webConsoleFront
.
startListeners
(
[
"
PageError
"
]
)
;
let
{
messages
}
=
await
webConsoleFront
.
getCachedMessages
(
[
"
PageError
"
]
)
;
messages
=
messages
.
filter
(
message
=
>
{
return
(
(
webConsoleFront
.
traits
.
newCacheStructure
|
|
!
message
.
_type
|
|
message
.
_type
=
=
"
PageError
"
)
&
&
message
.
pageError
.
category
!
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
)
;
}
)
;
messages
=
messages
.
map
(
message
=
>
{
if
(
message
.
_type
)
{
return
{
pageError
:
message
resourceType
:
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
}
;
}
message
.
resourceType
=
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
;
return
message
;
}
)
;
onAvailable
(
messages
)
;
webConsoleFront
.
on
(
"
pageError
"
message
=
>
{
if
(
message
.
pageError
.
category
=
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
)
{
return
;
}
message
.
resourceType
=
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
;
onAvailable
(
[
message
]
)
;
}
)
;
}
;
