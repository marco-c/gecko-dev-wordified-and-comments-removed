"
use
strict
"
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
throttle
}
=
require
(
"
devtools
/
shared
/
throttle
"
)
;
class
ResourceWatcher
{
constructor
(
targetList
)
{
this
.
targetList
=
targetList
;
this
.
descriptorFront
=
targetList
.
descriptorFront
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onResourceDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
)
;
this
.
_watchers
=
[
]
;
this
.
_cache
=
[
]
;
this
.
_listenerCount
=
new
Map
(
)
;
this
.
_notifyWatchers
=
this
.
_notifyWatchers
.
bind
(
this
)
;
this
.
_throttledNotifyWatchers
=
throttle
(
this
.
_notifyWatchers
100
)
;
}
getAllResources
(
resourceType
)
{
return
this
.
_cache
.
filter
(
r
=
>
r
.
resourceType
=
=
=
resourceType
)
;
}
async
watchResources
(
resources
options
)
{
const
{
onAvailable
onUpdated
onDestroyed
ignoreExistingResources
=
false
}
=
options
;
if
(
typeof
onAvailable
!
=
=
"
function
"
)
{
throw
new
Error
(
"
ResourceWatcher
.
watchResources
expects
an
onAvailable
function
as
argument
"
)
;
}
if
(
!
this
.
watcher
)
{
const
supportsWatcher
=
this
.
descriptorFront
?
.
traits
?
.
watcher
;
if
(
supportsWatcher
)
{
this
.
watcher
=
await
this
.
descriptorFront
.
getWatcher
(
)
;
this
.
watcher
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
this
.
watcher
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
this
.
watcher
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
}
}
await
this
.
_watchAllTargets
(
)
;
for
(
const
resource
of
resources
)
{
if
(
!
this
.
_hasListenerForResource
(
resource
)
)
{
await
this
.
_startListening
(
resource
)
;
}
}
this
.
_notifyWatchers
(
)
;
this
.
_watchers
.
push
(
{
resources
onAvailable
onUpdated
onDestroyed
pendingEvents
:
[
]
}
)
;
if
(
!
ignoreExistingResources
)
{
await
this
.
_forwardCachedResources
(
resources
onAvailable
)
;
}
}
unwatchResources
(
resources
options
)
{
const
{
onAvailable
}
=
options
;
if
(
typeof
onAvailable
!
=
=
"
function
"
)
{
throw
new
Error
(
"
ResourceWatcher
.
unwatchResources
expects
an
onAvailable
function
as
argument
"
)
;
}
const
watchedResources
=
[
]
;
for
(
const
resource
of
resources
)
{
if
(
this
.
_hasListenerForResource
(
resource
)
)
{
watchedResources
.
push
(
resource
)
;
}
}
for
(
const
watcherEntry
of
this
.
_watchers
)
{
if
(
watcherEntry
.
onAvailable
=
=
onAvailable
)
{
watcherEntry
.
resources
=
watcherEntry
.
resources
.
filter
(
resourceType
=
>
{
return
!
resources
.
includes
(
resourceType
)
;
}
)
;
}
}
this
.
_watchers
=
this
.
_watchers
.
filter
(
entry
=
>
{
return
entry
.
resources
.
length
>
0
;
}
)
;
for
(
const
resource
of
watchedResources
)
{
if
(
!
this
.
_hasListenerForResource
(
resource
)
)
{
this
.
_stopListening
(
resource
)
;
}
}
let
listeners
=
0
;
for
(
const
count
of
this
.
_listenerCount
.
values
(
)
)
{
listeners
+
=
count
;
}
if
(
listeners
<
=
0
)
{
this
.
_unwatchAllTargets
(
)
;
}
}
async
_watchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
this
.
_watchTargetsPromise
=
this
.
targetList
.
watchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
return
this
.
_watchTargetsPromise
;
}
_unwatchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
return
;
}
this
.
_watchTargetsPromise
=
null
;
this
.
targetList
.
unwatchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
const
resources
=
[
]
;
if
(
isTargetSwitching
)
{
this
.
_onWillNavigate
(
targetFront
)
;
for
(
const
resourceType
of
this
.
_listenerCount
.
keys
(
)
)
{
await
this
.
_stopListening
(
resourceType
{
bypassListenerCount
:
true
}
)
;
resources
.
push
(
resourceType
)
;
}
}
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
targetFront
.
on
(
"
will
-
navigate
"
(
)
=
>
this
.
_onWillNavigate
(
targetFront
)
)
;
if
(
!
isTargetSwitching
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceWatcher
.
TYPES
)
)
{
if
(
!
this
.
_listenerCount
.
get
(
resourceType
)
)
{
continue
;
}
if
(
this
.
hasWatcherSupport
(
resourceType
)
)
{
continue
;
}
await
this
.
_watchResourcesForTarget
(
targetFront
resourceType
)
;
}
}
targetFront
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
)
;
targetFront
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
)
;
targetFront
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
)
;
if
(
isTargetSwitching
)
{
for
(
const
resourceType
of
resources
)
{
await
this
.
_startListening
(
resourceType
{
bypassListenerCount
:
true
}
)
;
}
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
}
async
_onResourceAvailable
(
{
targetFront
watcherFront
}
resources
)
{
for
(
let
resource
of
resources
)
{
const
{
resourceType
}
=
resource
;
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
resource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
if
(
!
resource
.
targetFront
)
{
resource
.
targetFront
=
targetFront
;
}
if
(
ResourceTransformers
[
resourceType
]
)
{
resource
=
ResourceTransformers
[
resourceType
]
(
{
resource
targetList
:
this
.
targetList
targetFront
isFissionEnabledOnContentToolbox
:
gDevTools
.
isFissionContentToolboxEnabled
(
)
watcher
:
this
.
watcher
}
)
;
}
this
.
_queueResourceEvent
(
"
available
"
resourceType
resource
)
;
this
.
_cache
.
push
(
resource
)
;
}
this
.
_throttledNotifyWatchers
(
)
;
}
async
_onResourceUpdated
(
{
targetFront
watcherFront
}
updates
)
{
for
(
const
update
of
updates
)
{
const
{
resourceType
resourceId
resourceUpdates
nestedResourceUpdates
}
=
update
;
if
(
!
resourceId
)
{
console
.
warn
(
Expected
resource
{
resourceType
}
to
have
a
resourceId
)
;
}
const
existingResource
=
this
.
_cache
.
find
(
cachedResource
=
>
cachedResource
.
resourceType
=
=
=
resourceType
&
&
cachedResource
.
resourceId
=
=
=
resourceId
)
;
if
(
!
existingResource
)
{
continue
;
}
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
existingResource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
if
(
resourceUpdates
)
{
Object
.
assign
(
existingResource
resourceUpdates
)
;
}
if
(
nestedResourceUpdates
)
{
for
(
const
{
path
value
}
of
nestedResourceUpdates
)
{
let
target
=
existingResource
;
for
(
let
i
=
0
;
i
<
path
.
length
-
1
;
i
+
+
)
{
target
=
target
[
path
[
i
]
]
;
}
target
[
path
[
path
.
length
-
1
]
]
=
value
;
}
}
this
.
_queueResourceEvent
(
"
updated
"
resourceType
{
resource
:
existingResource
update
}
)
;
}
this
.
_throttledNotifyWatchers
(
)
;
}
async
_onResourceDestroyed
(
{
targetFront
watcherFront
}
resources
)
{
for
(
const
resource
of
resources
)
{
const
{
resourceType
resourceId
}
=
resource
;
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
resource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
let
index
=
-
1
;
if
(
resourceId
)
{
index
=
this
.
_cache
.
findIndex
(
cachedResource
=
>
cachedResource
.
resourceType
=
=
resourceType
&
&
cachedResource
.
resourceId
=
=
resourceId
)
;
}
else
{
index
=
this
.
_cache
.
indexOf
(
resource
)
;
}
if
(
index
>
=
0
)
{
this
.
_cache
.
splice
(
index
1
)
;
}
else
{
console
.
warn
(
Resource
{
resourceId
|
|
"
"
}
of
{
resourceType
}
was
not
found
.
)
;
}
this
.
_queueResourceEvent
(
"
destroyed
"
resourceType
resource
)
;
}
this
.
_throttledNotifyWatchers
(
)
;
}
_hasListenerForResource
(
resourceType
)
{
return
this
.
_watchers
.
some
(
(
{
resources
}
)
=
>
{
return
resources
.
includes
(
resourceType
)
;
}
)
;
}
_queueResourceEvent
(
callbackType
resourceType
update
)
{
for
(
const
{
resources
pendingEvents
}
of
this
.
_watchers
)
{
if
(
!
resources
.
includes
(
resourceType
)
)
{
continue
;
}
if
(
pendingEvents
.
length
>
0
)
{
const
lastEvent
=
pendingEvents
[
pendingEvents
.
length
-
1
]
;
if
(
lastEvent
.
callbackType
=
=
callbackType
)
{
lastEvent
.
updates
.
push
(
update
)
;
continue
;
}
}
pendingEvents
.
push
(
{
callbackType
updates
:
[
update
]
}
)
;
}
}
_notifyWatchers
(
)
{
for
(
const
watcherEntry
of
this
.
_watchers
)
{
const
{
onAvailable
onUpdated
onDestroyed
pendingEvents
}
=
watcherEntry
;
watcherEntry
.
pendingEvents
=
[
]
;
for
(
const
{
callbackType
updates
}
of
pendingEvents
)
{
try
{
if
(
callbackType
=
=
"
available
"
)
{
onAvailable
(
updates
)
;
}
else
if
(
callbackType
=
=
"
updated
"
&
&
onUpdated
)
{
onUpdated
(
updates
)
;
}
else
if
(
callbackType
=
=
"
destroyed
"
&
&
onDestroyed
)
{
onDestroyed
(
updates
)
;
}
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
calling
a
ResourceWatcher
"
callbackType
"
callback
"
"
:
"
e
)
;
}
}
}
}
_getTargetForWatcherResource
(
resource
)
{
const
{
browsingContextID
resourceType
}
=
resource
;
if
(
!
browsingContextID
)
{
console
.
error
(
Resource
of
{
resourceType
}
is
missing
a
browsingContextID
attribute
)
;
return
null
;
}
return
this
.
watcher
.
getBrowsingContextTarget
(
browsingContextID
)
;
}
_onWillNavigate
(
targetFront
)
{
if
(
targetFront
.
isTopLevel
)
{
this
.
_cache
=
[
]
;
return
;
}
this
.
_cache
=
this
.
_cache
.
filter
(
cachedResource
=
>
cachedResource
.
targetFront
!
=
=
targetFront
)
;
}
hasWatcherSupport
(
resourceType
)
{
return
this
.
watcher
?
.
traits
?
.
resources
?
.
[
resourceType
]
;
}
async
_startListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
|
|
0
;
listeners
+
+
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
1
)
{
return
;
}
}
if
(
this
.
hasWatcherSupport
(
resourceType
)
)
{
await
this
.
watcher
.
watchResources
(
[
resourceType
]
)
;
return
;
}
const
promises
=
[
]
;
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
promises
.
push
(
this
.
_watchResourcesForTarget
(
target
resourceType
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
async
_forwardCachedResources
(
resourceTypes
onAvailable
)
{
const
cachedResources
=
this
.
_cache
.
filter
(
resource
=
>
resourceTypes
.
includes
(
resource
.
resourceType
)
)
;
if
(
cachedResources
.
length
>
0
)
{
await
onAvailable
(
cachedResources
)
;
}
}
_watchResourcesForTarget
(
targetFront
resourceType
)
{
if
(
targetFront
.
isDestroyed
(
)
)
{
return
Promise
.
resolve
(
)
;
}
const
onAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
;
const
onUpdated
=
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
;
const
onDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
;
if
(
!
(
resourceType
in
LegacyListeners
)
)
{
throw
new
Error
(
Missing
legacy
listener
for
{
resourceType
}
)
;
}
return
LegacyListeners
[
resourceType
]
(
{
targetList
:
this
.
targetList
targetFront
isFissionEnabledOnContentToolbox
:
gDevTools
.
isFissionContentToolboxEnabled
(
)
onAvailable
onDestroyed
onUpdated
}
)
;
}
_stopListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
;
if
(
!
listeners
|
|
listeners
<
=
0
)
{
throw
new
Error
(
Stopped
listening
for
resource
'
{
resourceType
}
'
that
isn
'
t
being
listened
to
)
;
}
listeners
-
-
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
0
)
{
return
;
}
}
this
.
_cache
=
this
.
_cache
.
filter
(
cachedResource
=
>
cachedResource
.
resourceType
!
=
=
resourceType
)
;
if
(
this
.
hasWatcherSupport
(
resourceType
)
)
{
this
.
watcher
.
unwatchResources
(
[
resourceType
]
)
;
return
;
}
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
this
.
_unwatchResourcesForTarget
(
target
resourceType
)
;
}
}
_unwatchResourcesForTarget
(
targetFront
resourceType
)
{
}
}
ResourceWatcher
.
TYPES
=
ResourceWatcher
.
prototype
.
TYPES
=
{
CONSOLE_MESSAGE
:
"
console
-
message
"
CSS_CHANGE
:
"
css
-
change
"
CSS_MESSAGE
:
"
css
-
message
"
ERROR_MESSAGE
:
"
error
-
message
"
PLATFORM_MESSAGE
:
"
platform
-
message
"
DOCUMENT_EVENT
:
"
document
-
event
"
ROOT_NODE
:
"
root
-
node
"
STYLESHEET
:
"
stylesheet
"
NETWORK_EVENT
:
"
network
-
event
"
WEBSOCKET
:
"
websocket
"
COOKIE
:
"
cookie
"
LOCAL_STORAGE
:
"
local
-
storage
"
SESSION_STORAGE
:
"
session
-
storage
"
CACHE_STORAGE
:
"
Cache
"
EXTENSION_STORAGE
:
"
extension
-
storage
"
INDEXED_DB
:
"
indexed
-
db
"
NETWORK_EVENT_STACKTRACE
:
"
network
-
event
-
stacktrace
"
SOURCE
:
"
source
"
}
;
module
.
exports
=
{
ResourceWatcher
TYPES
:
ResourceWatcher
.
TYPES
}
;
const
LegacyListeners
=
{
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
console
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
CSS_CHANGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
css
-
changes
"
)
[
ResourceWatcher
.
TYPES
.
CSS_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
css
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
error
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
platform
-
messages
"
)
async
[
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
]
(
{
targetList
targetFront
onAvailable
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
webConsoleFront
.
on
(
"
documentEvent
"
event
=
>
{
event
.
resourceType
=
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
;
onAvailable
(
[
event
]
)
;
}
)
;
await
webConsoleFront
.
startListeners
(
[
"
DocumentEvents
"
]
)
;
}
[
ResourceWatcher
.
TYPES
.
ROOT_NODE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
root
-
node
"
)
[
ResourceWatcher
.
TYPES
.
STYLESHEET
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
stylesheet
"
)
[
ResourceWatcher
.
TYPES
.
NETWORK_EVENT
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
network
-
events
"
)
[
ResourceWatcher
.
TYPES
.
WEBSOCKET
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
websocket
"
)
[
ResourceWatcher
.
TYPES
.
COOKIE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
cookie
"
)
[
ResourceWatcher
.
TYPES
.
LOCAL_STORAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
local
-
storage
"
)
[
ResourceWatcher
.
TYPES
.
SESSION_STORAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
session
-
storage
"
)
[
ResourceWatcher
.
TYPES
.
CACHE_STORAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
cache
-
storage
"
)
[
ResourceWatcher
.
TYPES
.
EXTENSION_STORAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
extension
-
storage
"
)
[
ResourceWatcher
.
TYPES
.
INDEXED_DB
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
indexed
-
db
"
)
[
ResourceWatcher
.
TYPES
.
NETWORK_EVENT_STACKTRACE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
network
-
event
-
stacktraces
"
)
[
ResourceWatcher
.
TYPES
.
SOURCE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
source
"
)
}
;
const
ResourceTransformers
=
{
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
console
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
error
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
INDEXED_DB
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
storage
-
indexed
-
db
.
js
"
)
[
ResourceWatcher
.
TYPES
.
LOCAL_STORAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
storage
-
local
-
storage
.
js
"
)
[
ResourceWatcher
.
TYPES
.
ROOT_NODE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
root
-
node
"
)
}
;
