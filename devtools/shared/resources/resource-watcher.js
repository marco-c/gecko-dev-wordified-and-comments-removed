"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
class
ResourceWatcher
{
constructor
(
targetList
)
{
this
.
targetList
=
targetList
;
this
.
descriptorFront
=
targetList
.
descriptorFront
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onResourceDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
)
;
this
.
_availableListeners
=
new
EventEmitter
(
)
;
this
.
_updatedListeners
=
new
EventEmitter
(
)
;
this
.
_destroyedListeners
=
new
EventEmitter
(
)
;
this
.
_cache
=
[
]
;
this
.
_listenerCount
=
new
Map
(
)
;
}
getAllResources
(
resourceType
)
{
return
this
.
_cache
.
filter
(
r
=
>
r
.
resourceType
=
=
=
resourceType
)
;
}
async
watchResources
(
resources
options
)
{
const
{
onAvailable
onUpdated
onDestroyed
ignoreExistingResources
=
false
}
=
options
;
if
(
!
this
.
watcher
)
{
const
supportsWatcher
=
this
.
descriptorFront
?
.
traits
?
.
watcher
;
if
(
supportsWatcher
)
{
this
.
watcher
=
await
this
.
descriptorFront
.
getWatcher
(
)
;
this
.
watcher
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
this
.
watcher
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
this
.
watcher
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
watcherFront
:
this
.
watcher
}
)
)
;
}
}
await
this
.
_watchAllTargets
(
)
;
for
(
const
resource
of
resources
)
{
if
(
this
.
_availableListeners
.
count
(
resource
)
=
=
=
0
)
{
await
this
.
_startListening
(
resource
)
;
}
this
.
_availableListeners
.
on
(
resource
onAvailable
)
;
if
(
onUpdated
)
{
this
.
_updatedListeners
.
on
(
resource
onUpdated
)
;
}
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
on
(
resource
onDestroyed
)
;
}
}
if
(
!
ignoreExistingResources
)
{
await
this
.
_forwardCachedResources
(
resources
onAvailable
)
;
}
}
unwatchResources
(
resources
options
)
{
const
{
onAvailable
onUpdated
onDestroyed
}
=
options
;
for
(
const
resource
of
resources
)
{
if
(
onUpdated
)
{
this
.
_updatedListeners
.
off
(
resource
onUpdated
)
;
}
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
off
(
resource
onDestroyed
)
;
}
const
hadAtLeastOneListener
=
this
.
_availableListeners
.
count
(
resource
)
>
0
;
this
.
_availableListeners
.
off
(
resource
onAvailable
)
;
if
(
hadAtLeastOneListener
&
&
this
.
_availableListeners
.
count
(
resource
)
=
=
=
0
)
{
this
.
_stopListening
(
resource
)
;
}
}
let
listeners
=
0
;
for
(
const
count
of
this
.
_listenerCount
.
values
(
)
)
{
listeners
+
=
count
;
}
if
(
listeners
<
=
0
)
{
this
.
_unwatchAllTargets
(
)
;
}
}
async
_watchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
this
.
_watchTargetsPromise
=
this
.
targetList
.
watchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
return
this
.
_watchTargetsPromise
;
}
_unwatchAllTargets
(
)
{
if
(
!
this
.
_watchTargetsPromise
)
{
return
;
}
this
.
_watchTargetsPromise
=
null
;
this
.
targetList
.
unwatchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
const
resources
=
[
]
;
if
(
isTargetSwitching
)
{
this
.
_onWillNavigate
(
targetFront
)
;
for
(
const
resourceType
of
this
.
_listenerCount
.
keys
(
)
)
{
await
this
.
_stopListening
(
resourceType
{
bypassListenerCount
:
true
}
)
;
resources
.
push
(
resourceType
)
;
}
}
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
targetFront
.
on
(
"
will
-
navigate
"
(
)
=
>
this
.
_onWillNavigate
(
targetFront
)
)
;
if
(
!
isTargetSwitching
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceWatcher
.
TYPES
)
)
{
if
(
!
this
.
_listenerCount
.
get
(
resourceType
)
)
{
continue
;
}
if
(
this
.
_hasWatcherSupport
(
resourceType
)
)
{
continue
;
}
await
this
.
_watchResourcesForTarget
(
targetFront
resourceType
)
;
}
}
targetFront
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
)
;
targetFront
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
)
;
targetFront
.
on
(
"
resource
-
destroyed
-
form
"
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
)
;
if
(
isTargetSwitching
)
{
for
(
const
resourceType
of
resources
)
{
await
this
.
_startListening
(
resourceType
{
bypassListenerCount
:
true
}
)
;
}
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
}
async
_onResourceAvailable
(
{
targetFront
watcherFront
}
resources
)
{
let
currentType
=
null
;
let
resourceBuffer
=
[
]
;
for
(
let
resource
of
resources
)
{
const
{
resourceType
}
=
resource
;
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
resource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
if
(
!
resource
.
targetFront
)
{
resource
.
targetFront
=
targetFront
;
}
if
(
ResourceTransformers
[
resourceType
]
)
{
resource
=
ResourceTransformers
[
resourceType
]
(
{
resource
targetList
:
this
.
targetList
targetFront
isFissionEnabledOnContentToolbox
:
gDevTools
.
isFissionContentToolboxEnabled
(
)
}
)
;
}
if
(
!
currentType
)
{
currentType
=
resourceType
;
}
else
if
(
currentType
!
=
resourceType
)
{
this
.
_availableListeners
.
emit
(
currentType
resourceBuffer
)
;
currentType
=
resourceType
;
resourceBuffer
=
[
]
;
}
resourceBuffer
.
push
(
resource
)
;
this
.
_cache
.
push
(
resource
)
;
}
if
(
resourceBuffer
.
length
>
0
)
{
this
.
_availableListeners
.
emit
(
currentType
resourceBuffer
)
;
}
}
async
_onResourceUpdated
(
{
targetFront
watcherFront
}
updates
)
{
let
currentType
=
null
;
let
resourceBuffer
=
[
]
;
for
(
const
update
of
updates
)
{
const
{
resourceType
resourceId
resourceUpdates
}
=
update
;
const
existingResource
=
this
.
_cache
.
find
(
cachedResource
=
>
cachedResource
.
resourceType
=
=
=
resourceType
&
&
cachedResource
.
resourceId
=
=
=
resourceId
)
;
if
(
!
existingResource
)
{
continue
;
}
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
existingResource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
if
(
resourceUpdates
)
{
Object
.
assign
(
existingResource
resourceUpdates
)
;
}
if
(
!
currentType
)
{
currentType
=
resourceType
;
}
if
(
currentType
!
=
resourceType
)
{
this
.
_updatedListeners
.
emit
(
currentType
resourceBuffer
)
;
currentType
=
resourceType
;
resourceBuffer
=
[
]
;
}
resourceBuffer
.
push
(
{
resource
:
existingResource
update
}
)
;
}
if
(
resourceBuffer
.
length
>
0
)
{
this
.
_updatedListeners
.
emit
(
currentType
resourceBuffer
)
;
}
}
async
_onResourceDestroyed
(
{
targetFront
watcherFront
}
resources
)
{
let
currentType
=
null
;
let
resourceBuffer
=
[
]
;
for
(
const
resource
of
resources
)
{
const
{
resourceType
resourceId
}
=
resource
;
if
(
watcherFront
)
{
targetFront
=
await
this
.
_getTargetForWatcherResource
(
resource
)
;
if
(
!
targetFront
)
{
continue
;
}
}
let
index
=
-
1
;
if
(
resourceId
)
{
index
=
this
.
_cache
.
findIndex
(
cachedResource
=
>
cachedResource
.
resourceType
=
=
resourceType
&
&
cachedResource
.
resourceId
=
=
resourceId
)
;
}
else
{
index
=
this
.
_cache
.
indexOf
(
resource
)
;
}
if
(
index
>
=
0
)
{
this
.
_cache
.
splice
(
index
1
)
;
}
else
{
console
.
warn
(
Resource
{
resourceId
|
|
"
"
}
of
{
resourceType
}
was
not
found
.
)
;
}
if
(
!
currentType
)
{
currentType
=
resourceType
;
}
if
(
currentType
!
=
resourceType
)
{
this
.
_destroyedListeners
.
emit
(
currentType
resourceBuffer
)
;
currentType
=
resourceType
;
resourceBuffer
=
[
]
;
}
resourceBuffer
.
push
(
resource
)
;
}
if
(
resourceBuffer
.
length
>
0
)
{
this
.
_destroyedListeners
.
emit
(
currentType
resourceBuffer
)
;
}
}
_getTargetForWatcherResource
(
resource
)
{
const
{
browsingContextID
resourceType
}
=
resource
;
if
(
!
browsingContextID
)
{
console
.
error
(
Resource
of
{
resourceType
}
is
missing
a
browsingContextID
attribute
)
;
return
null
;
}
return
this
.
watcher
.
getBrowsingContextTarget
(
browsingContextID
)
;
}
_onWillNavigate
(
targetFront
)
{
if
(
targetFront
.
isTopLevel
)
{
this
.
_cache
=
[
]
;
return
;
}
this
.
_cache
=
this
.
_cache
.
filter
(
cachedResource
=
>
cachedResource
.
targetFront
!
=
=
targetFront
)
;
}
_hasWatcherSupport
(
resourceType
)
{
return
this
.
watcher
?
.
traits
?
.
resources
?
.
[
resourceType
]
;
}
async
_startListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
|
|
0
;
listeners
+
+
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
1
)
{
return
;
}
}
if
(
this
.
_hasWatcherSupport
(
resourceType
)
)
{
await
this
.
watcher
.
watchResources
(
[
resourceType
]
)
;
return
;
}
const
promises
=
[
]
;
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
promises
.
push
(
this
.
_watchResourcesForTarget
(
target
resourceType
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
async
_forwardCachedResources
(
resourceTypes
onAvailable
)
{
const
cachedResources
=
this
.
_cache
.
filter
(
resource
=
>
resourceTypes
.
includes
(
resource
.
resourceType
)
)
;
if
(
cachedResources
.
length
>
0
)
{
await
onAvailable
(
cachedResources
)
;
}
}
_watchResourcesForTarget
(
targetFront
resourceType
)
{
if
(
targetFront
.
isDestroyed
(
)
)
{
return
Promise
.
resolve
(
)
;
}
const
onAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
{
targetFront
}
)
;
const
onDestroyed
=
this
.
_onResourceDestroyed
.
bind
(
this
{
targetFront
}
)
;
const
onUpdated
=
this
.
_onResourceUpdated
.
bind
(
this
{
targetFront
}
)
;
return
LegacyListeners
[
resourceType
]
(
{
targetList
:
this
.
targetList
targetFront
isFissionEnabledOnContentToolbox
:
gDevTools
.
isFissionContentToolboxEnabled
(
)
onAvailable
onDestroyed
onUpdated
}
)
;
}
_stopListening
(
resourceType
{
bypassListenerCount
=
false
}
=
{
}
)
{
if
(
!
bypassListenerCount
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
;
if
(
!
listeners
|
|
listeners
<
=
0
)
{
throw
new
Error
(
Stopped
listening
for
resource
'
{
resourceType
}
'
that
isn
'
t
being
listened
to
)
;
}
listeners
-
-
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
0
)
{
return
;
}
}
this
.
_cache
=
this
.
_cache
.
filter
(
cachedResource
=
>
cachedResource
.
resourceType
!
=
=
resourceType
)
;
if
(
this
.
_hasWatcherSupport
(
resourceType
)
)
{
this
.
watcher
.
unwatchResources
(
[
resourceType
]
)
;
return
;
}
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
this
.
_unwatchResourcesForTarget
(
target
resourceType
)
;
}
}
_unwatchResourcesForTarget
(
targetFront
resourceType
)
{
}
}
ResourceWatcher
.
TYPES
=
ResourceWatcher
.
prototype
.
TYPES
=
{
CONSOLE_MESSAGE
:
"
console
-
message
"
CSS_CHANGE
:
"
css
-
change
"
CSS_MESSAGE
:
"
css
-
message
"
ERROR_MESSAGE
:
"
error
-
message
"
PLATFORM_MESSAGE
:
"
platform
-
message
"
DOCUMENT_EVENT
:
"
document
-
event
"
ROOT_NODE
:
"
root
-
node
"
STYLESHEET
:
"
stylesheet
"
NETWORK_EVENT
:
"
network
-
event
"
WEBSOCKET
:
"
websocket
"
NETWORK_EVENT_STACKTRACE
:
"
network
-
event
-
stacktrace
"
}
;
module
.
exports
=
{
ResourceWatcher
}
;
const
LegacyListeners
=
{
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
console
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
CSS_CHANGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
css
-
changes
"
)
[
ResourceWatcher
.
TYPES
.
CSS_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
css
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
error
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
platform
-
messages
"
)
async
[
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
]
(
{
targetList
targetFront
onAvailable
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
webConsoleFront
.
on
(
"
documentEvent
"
event
=
>
{
event
.
resourceType
=
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
;
onAvailable
(
[
event
]
)
;
}
)
;
await
webConsoleFront
.
startListeners
(
[
"
DocumentEvents
"
]
)
;
}
[
ResourceWatcher
.
TYPES
.
ROOT_NODE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
root
-
node
"
)
[
ResourceWatcher
.
TYPES
.
STYLESHEET
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
stylesheet
"
)
[
ResourceWatcher
.
TYPES
.
NETWORK_EVENT
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
network
-
events
"
)
[
ResourceWatcher
.
TYPES
.
WEBSOCKET
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
websocket
"
)
[
ResourceWatcher
.
TYPES
.
NETWORK_EVENT_STACKTRACE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
network
-
event
-
stacktraces
"
)
}
;
const
ResourceTransformers
=
{
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
console
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
error
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ROOT_NODE
]
:
require
(
"
devtools
/
shared
/
resources
/
transformers
/
root
-
node
"
)
}
;
