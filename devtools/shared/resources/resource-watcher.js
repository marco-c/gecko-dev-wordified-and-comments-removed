"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
class
ResourceWatcher
{
constructor
(
targetList
)
{
this
.
targetList
=
targetList
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_availableListeners
=
new
EventEmitter
(
)
;
this
.
_destroyedListeners
=
new
EventEmitter
(
)
;
this
.
_listenerCount
=
new
Map
(
)
;
this
.
_previouslyListenedTypes
=
new
Set
(
)
;
}
get
contentToolboxFissionPrefValue
(
)
{
if
(
!
this
.
_contentToolboxFissionPrefValue
)
{
this
.
_contentToolboxFissionPrefValue
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
contenttoolbox
.
fission
"
false
)
;
}
return
this
.
_contentToolboxFissionPrefValue
;
}
async
watchResources
(
resources
options
)
{
const
{
ignoreExistingResources
=
false
}
=
options
;
await
this
.
_watchAllTargets
(
)
;
for
(
const
resource
of
resources
)
{
if
(
ignoreExistingResources
)
{
await
this
.
_startListening
(
resource
)
;
this
.
_registerListeners
(
resource
options
)
;
}
else
{
this
.
_registerListeners
(
resource
options
)
;
await
this
.
_startListening
(
resource
)
;
}
}
}
unwatchResources
(
resources
options
)
{
const
{
onAvailable
onDestroyed
}
=
options
;
for
(
const
resource
of
resources
)
{
this
.
_availableListeners
.
off
(
resource
onAvailable
)
;
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
off
(
resource
onDestroyed
)
;
}
this
.
_stopListening
(
resource
)
;
}
let
listeners
=
0
;
for
(
const
count
of
this
.
_listenerCount
)
{
listeners
+
=
count
;
}
if
(
listeners
<
=
0
)
{
this
.
_unwatchAllTargets
(
)
;
}
}
_registerListeners
(
resource
{
onAvailable
onDestroyed
}
)
{
this
.
_availableListeners
.
on
(
resource
onAvailable
)
;
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
on
(
resource
onDestroyed
)
;
}
}
async
_watchAllTargets
(
)
{
if
(
this
.
_isWatchingTargets
)
{
return
;
}
this
.
_isWatchingTargets
=
true
;
await
this
.
targetList
.
watchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_unwatchAllTargets
(
)
{
if
(
!
this
.
_isWatchingTargets
)
{
return
;
}
this
.
_isWatchingTargets
=
false
;
await
this
.
targetList
.
unwatchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_onTargetAvailable
(
{
targetFront
}
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceWatcher
.
TYPES
)
)
{
if
(
!
this
.
_listenerCount
.
get
(
resourceType
)
)
{
continue
;
}
await
this
.
_watchResourcesForTarget
(
targetFront
resourceType
)
;
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
}
_onResourceAvailable
(
targetFront
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
!
resource
.
targetFront
)
{
resource
.
targetFront
=
targetFront
;
}
const
{
resourceType
}
=
resource
;
this
.
_availableListeners
.
emit
(
resourceType
{
resourceType
targetFront
resource
}
)
;
}
}
_onResourceDestroyed
(
targetFront
resourceType
resource
)
{
this
.
_destroyedListeners
.
emit
(
resourceType
{
resourceType
targetFront
resource
}
)
;
}
async
_startListening
(
resourceType
)
{
const
isDocumentEvent
=
resourceType
=
=
=
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
;
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
|
|
0
;
listeners
+
+
;
if
(
listeners
>
1
)
{
if
(
isDocumentEvent
)
{
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
return
;
}
throw
new
Error
(
The
ResourceWatcher
is
already
listening
to
"
{
resourceType
}
"
+
"
the
client
should
call
watchResources
only
once
per
resource
type
.
"
)
;
}
const
wasListening
=
this
.
_previouslyListenedTypes
.
has
(
resourceType
)
;
if
(
wasListening
&
&
!
isDocumentEvent
)
{
throw
new
Error
(
The
ResourceWatcher
previously
watched
"
{
resourceType
}
"
+
"
and
doesn
'
t
support
watching
again
on
a
previous
resource
.
"
)
;
}
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
this
.
_previouslyListenedTypes
.
add
(
resourceType
)
;
const
promises
=
[
]
;
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
promises
.
push
(
this
.
_watchResourcesForTarget
(
target
resourceType
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
_watchResourcesForTarget
(
targetFront
resourceType
)
{
const
onAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
targetFront
)
;
return
LegacyListeners
[
resourceType
]
(
{
targetList
:
this
.
targetList
targetFront
isFissionEnabledOnContentToolbox
:
this
.
contentToolboxFissionPrefValue
onAvailable
}
)
;
}
_stopListening
(
resourceType
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
;
if
(
!
listeners
|
|
listeners
<
=
0
)
{
throw
new
Error
(
Stopped
listening
for
resource
'
{
resourceType
}
'
that
isn
'
t
being
listened
to
)
;
}
listeners
-
-
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
0
)
{
return
;
}
const
targets
=
this
.
targetList
.
getAllTargets
(
this
.
targetList
.
ALL_TYPES
)
;
for
(
const
target
of
targets
)
{
this
.
_unwatchResourcesForTarget
(
target
resourceType
)
;
}
}
_unwatchResourcesForTarget
(
targetFront
resourceType
)
{
}
}
ResourceWatcher
.
TYPES
=
ResourceWatcher
.
prototype
.
TYPES
=
{
CONSOLE_MESSAGE
:
"
console
-
message
"
ERROR_MESSAGE
:
"
error
-
message
"
PLATFORM_MESSAGE
:
"
platform
-
message
"
DOCUMENT_EVENT
:
"
document
-
event
"
ROOT_NODE
:
"
root
-
node
"
}
;
module
.
exports
=
{
ResourceWatcher
}
;
const
LegacyListeners
=
{
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
console
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
ERROR_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
error
-
messages
"
)
[
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
platform
-
messages
"
)
async
[
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
]
(
{
targetList
targetFront
onAvailable
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
webConsoleFront
.
on
(
"
documentEvent
"
event
=
>
{
event
.
resourceType
=
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENT
;
onAvailable
(
[
event
]
)
;
}
)
;
await
webConsoleFront
.
startListeners
(
[
"
DocumentEvents
"
]
)
;
}
[
ResourceWatcher
.
TYPES
.
ROOT_NODE
]
:
require
(
"
devtools
/
shared
/
resources
/
legacy
-
listeners
/
root
-
node
"
)
}
;
