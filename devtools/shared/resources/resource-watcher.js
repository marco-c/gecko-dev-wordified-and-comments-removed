"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
class
ResourceWatcher
{
constructor
(
targetList
)
{
this
.
targetList
=
targetList
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_availableListeners
=
new
EventEmitter
(
)
;
this
.
_destroyedListeners
=
new
EventEmitter
(
)
;
this
.
_listenerCount
=
new
Map
(
)
;
}
async
watch
(
resources
onAvailable
onDestroyed
)
{
await
this
.
_watchAllTargets
(
)
;
for
(
const
resource
of
resources
)
{
this
.
_availableListeners
.
on
(
resource
onAvailable
)
;
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
on
(
resource
onDestroyed
)
;
}
await
this
.
_startListening
(
resource
)
;
}
}
unwatch
(
resources
onAvailable
onDestroyed
)
{
for
(
const
resource
of
resources
)
{
this
.
_availableListeners
.
off
(
resource
onAvailable
)
;
if
(
onDestroyed
)
{
this
.
_destroyedListeners
.
off
(
resource
onDestroyed
)
;
}
this
.
_stopListening
(
resource
)
;
}
let
listeners
=
0
;
for
(
const
count
of
this
.
_listenerCount
)
{
listeners
+
=
count
;
}
if
(
listeners
<
=
0
)
{
this
.
_unwatchAllTargets
(
)
;
}
}
async
_watchAllTargets
(
)
{
if
(
this
.
_isWatchingTargets
)
{
return
;
}
this
.
_isWatchingTargets
=
true
;
await
this
.
targetList
.
watchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_unwatchAllTargets
(
)
{
if
(
!
this
.
_isWatchingTargets
)
{
return
;
}
this
.
_isWatchingTargets
=
false
;
await
this
.
targetList
.
unwatchTargets
(
this
.
targetList
.
ALL_TYPES
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
}
async
_onTargetAvailable
(
{
type
targetFront
isTopLevel
}
)
{
for
(
const
resourceType
of
Object
.
values
(
ResourceWatcher
.
TYPES
)
)
{
if
(
!
this
.
_listenerCount
.
get
(
resourceType
)
)
{
continue
;
}
await
this
.
_watchResourcesForTarget
(
type
targetFront
isTopLevel
resourceType
)
;
}
}
_onTargetDestroyed
(
{
type
targetFront
}
)
{
}
_onResourceAvailable
(
targetFront
resourceType
resource
)
{
this
.
_availableListeners
.
emit
(
resourceType
{
resourceType
targetFront
resource
}
)
;
}
_onResourceDestroyed
(
targetFront
resourceType
resource
)
{
this
.
_destroyedListeners
.
emit
(
resourceType
{
resourceType
targetFront
resource
}
)
;
}
async
_startListening
(
resourceType
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
|
|
0
;
listeners
+
+
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
1
)
{
return
;
}
const
promises
=
[
]
;
for
(
const
targetType
of
this
.
targetList
.
ALL_TYPES
)
{
for
(
const
target
of
this
.
targetList
.
getAllTargets
(
targetType
)
)
{
promises
.
push
(
this
.
_watchResourcesForTarget
(
targetType
target
target
=
=
this
.
targetList
.
targetFront
resourceType
)
)
;
}
}
await
Promise
.
all
(
promises
)
;
}
_watchResourcesForTarget
(
targetType
targetFront
isTopLevel
resourceType
)
{
const
onAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
targetFront
resourceType
)
;
return
LegacyListeners
[
resourceType
]
(
{
targetList
:
this
.
targetList
targetType
targetFront
isTopLevel
onAvailable
}
)
;
}
_stopListening
(
resourceType
)
{
let
listeners
=
this
.
_listenerCount
.
get
(
resourceType
)
;
if
(
!
listeners
|
|
listeners
<
=
0
)
{
throw
new
Error
(
Stopped
listening
for
resource
'
{
resourceType
}
'
that
isn
'
t
being
listened
to
)
;
}
listeners
-
-
;
this
.
_listenerCount
.
set
(
resourceType
listeners
)
;
if
(
listeners
>
0
)
{
return
;
}
for
(
const
targetType
of
this
.
targetList
.
ALL_TYPES
)
{
for
(
const
target
of
this
.
targetList
.
getAllTargets
(
targetType
)
)
{
this
.
_unwatchResourcesForTarget
(
targetType
target
resourceType
)
;
}
}
}
_unwatchResourcesForTarget
(
targetType
targetFront
resourceType
)
{
}
}
ResourceWatcher
.
TYPES
=
ResourceWatcher
.
prototype
.
TYPES
=
{
CONSOLE_MESSAGES
:
"
console
-
messages
"
DOCUMENT_EVENTS
:
"
document
-
events
"
}
;
module
.
exports
=
{
ResourceWatcher
}
;
const
LegacyListeners
=
{
async
[
ResourceWatcher
.
TYPES
.
CONSOLE_MESSAGES
]
(
{
targetList
targetType
targetFront
isTopLevel
onAvailable
}
)
{
const
isContentToolbox
=
targetList
.
targetFront
.
isLocalTab
;
const
listenForFrames
=
isContentToolbox
&
&
Services
.
prefs
.
getBoolPref
(
"
devtools
.
contenttoolbox
.
fission
"
)
;
const
isAllowed
=
isTopLevel
|
|
targetType
=
=
=
targetList
.
TYPES
.
PROCESS
|
|
(
targetType
=
=
=
targetList
.
TYPES
.
FRAME
&
&
listenForFrames
)
;
if
(
!
isAllowed
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
await
webConsoleFront
.
startListeners
(
[
"
ConsoleAPI
"
]
)
;
const
{
messages
}
=
await
webConsoleFront
.
getCachedMessages
(
[
"
ConsoleAPI
"
]
)
;
messages
.
map
(
message
=
>
(
{
message
}
)
)
.
forEach
(
onAvailable
)
;
webConsoleFront
.
on
(
"
consoleAPICall
"
onAvailable
)
;
}
async
[
ResourceWatcher
.
TYPES
.
DOCUMENT_EVENTS
]
(
{
targetList
targetType
targetFront
isTopLevel
onAvailable
}
)
{
if
(
!
isTopLevel
)
{
return
;
}
const
webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
webConsoleFront
.
on
(
"
documentEvent
"
onAvailable
)
;
await
webConsoleFront
.
startListeners
(
[
"
DocumentEvents
"
]
)
;
}
}
;
