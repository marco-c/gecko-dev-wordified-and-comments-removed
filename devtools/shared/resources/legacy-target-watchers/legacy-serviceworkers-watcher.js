"
use
strict
"
;
const
{
WorkersListener
}
=
require
(
"
devtools
/
client
/
shared
/
workers
-
listener
"
)
;
const
{
LegacyWorkersWatcher
}
=
require
(
"
devtools
/
shared
/
resources
/
legacy
-
target
-
watchers
/
legacy
-
workers
-
watcher
"
)
;
class
LegacyServiceWorkersWatcher
extends
LegacyWorkersWatcher
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
_registrations
=
[
]
;
this
.
_processTargets
=
new
Set
(
)
;
this
.
_workersListener
=
new
WorkersListener
(
this
.
rootFront
{
registrationsOnly
:
true
}
)
;
this
.
_onRegistrationListChanged
=
this
.
_onRegistrationListChanged
.
bind
(
this
)
;
this
.
_isServiceWorkerWatcher
=
true
;
}
_supportWorkerTarget
(
workerTarget
)
{
if
(
!
workerTarget
.
isServiceWorker
)
{
return
false
;
}
const
swFronts
=
this
.
_getAllServiceWorkerFronts
(
)
;
return
swFronts
.
some
(
(
{
id
}
)
=
>
id
=
=
=
workerTarget
.
id
)
;
}
async
listen
(
)
{
this
.
_workersListener
.
addListener
(
this
.
_onRegistrationListChanged
)
;
await
this
.
_onRegistrationListChanged
(
)
;
await
super
.
listen
(
)
;
}
unlisten
(
)
{
this
.
_workersListener
.
removeListener
(
this
.
_onRegistrationListChanged
)
;
super
.
unlisten
(
)
;
}
async
_onProcessAvailable
(
{
targetFront
}
)
{
if
(
this
.
target
.
isLocalTab
)
{
const
origin
=
new
URL
(
this
.
target
.
url
)
.
origin
;
try
{
await
targetFront
.
pauseMatchingServiceWorkers
(
{
origin
}
)
;
}
catch
(
e
)
{
if
(
targetFront
.
actorID
)
{
throw
e
;
}
else
{
console
.
warn
(
"
Process
target
destroyed
while
calling
pauseMatchingServiceWorkers
"
)
;
}
}
}
this
.
_processTargets
.
add
(
targetFront
)
;
return
super
.
_onProcessAvailable
(
{
targetFront
}
)
;
}
_onProcessDestroyed
(
{
targetFront
}
)
{
this
.
_processTargets
.
delete
(
targetFront
)
;
return
super
.
_onProcessDestroyed
(
{
targetFront
}
)
;
}
async
_onRegistrationListChanged
(
)
{
const
{
registrations
}
=
await
this
.
rootFront
.
listServiceWorkerRegistrations
(
)
;
this
.
_registrations
=
registrations
.
filter
(
r
=
>
this
.
_isRegistrationValid
(
r
)
)
;
const
allServiceWorkerTargets
=
this
.
_getAllServiceWorkerTargets
(
)
;
const
swFronts
=
this
.
_getAllServiceWorkerFronts
(
)
;
for
(
const
target
of
allServiceWorkerTargets
)
{
const
match
=
swFronts
.
find
(
(
{
id
}
)
=
>
id
=
=
=
target
.
id
)
;
if
(
!
match
)
{
this
.
onTargetDestroyed
(
target
)
;
this
.
_removeTargetReferences
(
target
)
;
}
}
}
_getAllServiceWorkerFronts
(
)
{
return
(
this
.
_registrations
.
reduce
(
(
p
registration
)
=
>
{
return
[
registration
.
evaluatingWorker
registration
.
activeWorker
registration
.
installingWorker
registration
.
waitingWorker
.
.
.
p
]
;
}
[
]
)
.
filter
(
Boolean
)
)
;
}
_getProcessTargets
(
)
{
return
[
.
.
.
this
.
_processTargets
]
;
}
_getAllServiceWorkerTargets
(
)
{
const
allProcessTargets
=
this
.
_getProcessTargets
(
)
.
filter
(
target
=
>
this
.
targetsByProcess
.
get
(
target
)
)
;
const
serviceWorkerTargets
=
[
]
;
for
(
const
target
of
allProcessTargets
)
{
serviceWorkerTargets
.
push
(
.
.
.
this
.
targetsByProcess
.
get
(
target
)
)
;
}
return
serviceWorkerTargets
;
}
_removeTargetReferences
(
target
)
{
const
allProcessTargets
=
this
.
_getProcessTargets
(
)
.
filter
(
t
=
>
this
.
targetsByProcess
.
get
(
t
)
)
;
for
(
const
processTarget
of
allProcessTargets
)
{
this
.
targetsByProcess
.
get
(
processTarget
)
.
delete
(
target
)
;
}
}
_isRegistrationValid
(
registration
)
{
if
(
this
.
target
.
isParentProcess
)
{
return
true
;
}
if
(
!
this
.
target
.
isLocalTab
)
{
return
false
;
}
const
targetDomain
=
new
URL
(
this
.
target
.
url
)
.
hostname
;
try
{
const
registrationDomain
=
new
URL
(
registration
.
url
)
.
hostname
;
return
registrationDomain
=
=
=
targetDomain
;
}
catch
(
e
)
{
return
false
;
}
}
}
module
.
exports
=
{
LegacyServiceWorkersWatcher
}
;
