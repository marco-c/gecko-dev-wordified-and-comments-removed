"
use
strict
"
;
const
{
ResourceWatcher
}
=
require
(
"
devtools
/
shared
/
resources
/
resource
-
watcher
"
)
;
const
{
MESSAGE_CATEGORY
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
const
httpServer
=
createTestHTTPServer
(
)
;
httpServer
.
registerPathHandler
(
/
test_css_messages
.
html
(
req
res
)
=
>
{
res
.
setStatusLine
(
req
.
httpVersion
200
"
OK
"
)
;
res
.
write
(
<
meta
charset
=
utf8
>
<
style
>
html
{
color
:
bloup
;
}
<
/
style
>
Test
CSS
Messages
)
;
}
)
;
const
TEST_URI
=
http
:
/
/
localhost
:
{
httpServer
.
identity
.
primaryPort
}
/
test_css_messages
.
html
;
add_task
(
async
function
(
)
{
info
(
"
Test
css
messages
legacy
listener
"
)
;
await
pushPref
(
"
devtools
.
testing
.
enableServerWatcherSupport
"
false
)
;
await
testWatchingCssMessages
(
)
;
await
testWatchingCachedCssMessages
(
)
;
info
(
"
Test
css
messages
server
listener
"
)
;
await
pushPref
(
"
devtools
.
testing
.
enableServerWatcherSupport
"
true
)
;
await
testWatchingCssMessages
(
)
;
await
testWatchingCachedCssMessages
(
)
;
}
)
;
async
function
testWatchingCssMessages
(
)
{
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
const
tab
=
await
addTab
(
TEST_URI
)
;
const
{
client
resourceWatcher
targetList
}
=
await
initResourceWatcherAndTarget
(
tab
)
;
const
receivedMessages
=
[
]
;
const
{
onAvailable
onAllMessagesReceived
}
=
setupOnAvailableFunction
(
targetList
receivedMessages
)
;
await
resourceWatcher
.
watchResources
(
[
ResourceWatcher
.
TYPES
.
CSS_MESSAGE
]
{
onAvailable
}
)
;
info
(
"
Now
log
CSS
warning
*
after
*
the
call
to
ResourceWatcher
.
watchResources
and
after
"
+
"
having
received
the
existing
message
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
receivedMessages
.
length
=
=
=
1
)
;
info
(
"
Trigger
a
CSS
Warning
"
)
;
triggerCSSWarning
(
tab
)
;
info
(
"
Waiting
for
all
expected
CSS
messages
to
be
received
"
)
;
await
onAllMessagesReceived
;
ok
(
true
"
All
the
expected
CSS
messages
were
received
"
)
;
Services
.
console
.
reset
(
)
;
targetList
.
stopListening
(
)
;
await
client
.
close
(
)
;
}
async
function
testWatchingCachedCssMessages
(
)
{
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
const
tab
=
await
addTab
(
TEST_URI
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
content
.
docShell
.
cssErrorReportingEnabled
=
true
;
}
)
;
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
tab
.
linkedBrowser
.
reload
(
)
;
await
loaded
;
await
triggerCSSWarning
(
tab
)
;
const
{
client
resourceWatcher
targetList
}
=
await
initResourceWatcherAndTarget
(
tab
)
;
const
receivedMessages
=
[
]
;
const
{
onAvailable
}
=
setupOnAvailableFunction
(
targetList
receivedMessages
)
;
await
resourceWatcher
.
watchResources
(
[
ResourceWatcher
.
TYPES
.
CSS_MESSAGE
]
{
onAvailable
}
)
;
is
(
receivedMessages
.
length
3
"
Cached
messages
were
retrieved
as
expected
"
)
;
Services
.
console
.
reset
(
)
;
targetList
.
stopListening
(
)
;
await
client
.
close
(
)
;
}
function
setupOnAvailableFunction
(
targetList
receivedMessages
)
{
const
expectedMessages
=
[
{
pageError
:
{
errorMessage
:
/
Expected
color
but
found
bloup
/
sourceName
:
/
test_css_messages
/
category
:
MESSAGE_CATEGORY
.
CSS_PARSER
timeStamp
:
/
^
\
d
+
/
error
:
false
warning
:
true
}
cssSelectors
:
"
html
"
}
{
pageError
:
{
errorMessage
:
/
Error
in
parsing
value
for
width
/
sourceName
:
/
test_css_messages
/
category
:
MESSAGE_CATEGORY
.
CSS_PARSER
timeStamp
:
/
^
\
d
+
/
error
:
false
warning
:
true
}
}
{
pageError
:
{
errorMessage
:
/
Error
in
parsing
value
for
height
/
sourceName
:
/
test_css_messages
/
category
:
MESSAGE_CATEGORY
.
CSS_PARSER
timeStamp
:
/
^
\
d
+
/
error
:
false
warning
:
true
}
}
]
;
let
done
;
const
onAllMessagesReceived
=
new
Promise
(
resolve
=
>
(
done
=
resolve
)
)
;
const
onAvailable
=
(
{
resourceType
targetFront
resource
}
)
=
>
{
const
{
pageError
}
=
resource
;
is
(
resource
.
targetFront
targetList
.
targetFront
"
The
targetFront
property
is
the
expected
one
"
)
;
if
(
!
pageError
.
sourceName
.
includes
(
"
test_css_messages
"
)
)
{
info
(
Ignore
error
from
unknown
source
:
"
{
pageError
.
sourceName
}
"
)
;
return
;
}
const
index
=
receivedMessages
.
length
;
receivedMessages
.
push
(
pageError
)
;
info
(
checking
received
css
message
#
{
index
}
:
{
pageError
.
errorMessage
}
)
;
ok
(
pageError
"
The
resource
has
a
pageError
attribute
"
)
;
checkObject
(
resource
expectedMessages
[
index
]
)
;
if
(
receivedMessages
.
length
=
=
expectedMessages
.
length
)
{
done
(
)
;
}
}
;
return
{
onAvailable
onAllMessagesReceived
}
;
}
function
triggerCSSWarning
(
tab
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
function
frameScript
(
)
{
content
.
document
.
body
.
style
.
width
=
"
red
"
;
content
.
document
.
body
.
style
.
height
=
"
blue
"
;
}
)
;
}
