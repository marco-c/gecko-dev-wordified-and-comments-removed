"
use
strict
"
;
const
{
TargetList
}
=
require
(
"
devtools
/
shared
/
resources
/
target
-
list
"
)
;
const
{
TYPES
}
=
TargetList
;
const
COM_PAGE_URL
=
URL_ROOT_SSL
+
"
test_sw_page
.
html
"
;
const
COM_WORKER_URL
=
URL_ROOT_SSL
+
"
test_sw_page_worker
.
js
"
;
const
ORG_PAGE_URL
=
URL_ROOT_ORG_SSL
+
"
test_sw_page
.
html
"
;
const
ORG_WORKER_URL
=
URL_ROOT_ORG_SSL
+
"
test_sw_page_worker
.
js
"
;
add_task
(
async
function
test_NavigationBetweenTwoDomains_NoDestroy
(
)
{
const
{
client
mainRoot
}
=
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
const
{
hooks
targetList
}
=
await
watchServiceWorkerTargets
(
{
mainRoot
tab
destroyServiceWorkersOnNavigation
:
false
}
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Go
to
.
org
page
wait
for
onAvailable
to
be
called
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
0
targets
:
[
COM_WORKER_URL
ORG_WORKER_URL
]
}
)
;
info
(
"
Reload
.
org
page
onAvailable
and
onDestroyed
should
not
be
called
"
)
;
const
reloaded
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
gBrowser
.
reloadTab
(
gBrowser
.
selectedTab
)
;
await
reloaded
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
0
targets
:
[
COM_WORKER_URL
ORG_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
org
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Go
back
to
page
1
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
com
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
2
targets
:
[
]
}
)
;
targetList
.
destroy
(
)
;
await
client
.
waitForRequestsToSettle
(
)
;
await
client
.
close
(
)
;
await
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_NavigationBetweenTwoDomains_WithDestroy
(
)
{
const
{
client
mainRoot
}
=
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
const
{
hooks
targetList
}
=
await
watchServiceWorkerTargets
(
{
mainRoot
tab
destroyServiceWorkersOnNavigation
:
true
}
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Go
to
.
org
page
wait
for
onAvailable
to
be
called
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
ORG_WORKER_URL
]
}
)
;
info
(
"
Reload
.
org
page
onAvailable
and
onDestroyed
should
be
called
"
)
;
gBrowser
.
reloadTab
(
gBrowser
.
selectedTab
)
;
await
checkHooks
(
hooks
{
available
:
3
destroyed
:
2
targets
:
[
ORG_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
org
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
3
destroyed
:
3
targets
:
[
]
}
)
;
info
(
"
Go
back
to
page
1
wait
for
onDestroyed
and
onAvailable
to
be
called
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
4
destroyed
:
3
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
com
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
4
destroyed
:
4
targets
:
[
]
}
)
;
targetList
.
destroy
(
)
;
await
client
.
waitForRequestsToSettle
(
)
;
await
client
.
close
(
)
;
await
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_NavigationToPageWithExistingWorker_NoDestroy
(
)
{
await
testNavigationToPageWithExistingWorker
(
{
destroyServiceWorkersOnNavigation
:
false
}
)
;
}
)
;
add_task
(
async
function
test_NavigationToPageWithExistingWorker_WithDestroy
(
)
{
await
testNavigationToPageWithExistingWorker
(
{
destroyServiceWorkersOnNavigation
:
true
}
)
;
}
)
;
async
function
testNavigationToPageWithExistingWorker
(
{
destroyServiceWorkersOnNavigation
}
)
{
const
{
client
mainRoot
}
=
await
setupServiceWorkerNavigationTest
(
)
;
const
tab
=
await
addTab
(
COM_PAGE_URL
)
;
info
(
"
Wait
until
the
service
worker
registration
is
registered
"
)
;
await
waitForRegistrationReady
(
tab
COM_PAGE_URL
)
;
info
(
"
Navigate
to
another
page
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
ORG_PAGE_URL
)
;
info
(
"
Wait
until
we
have
fully
navigated
to
the
.
org
page
"
)
;
await
waitForRegistrationReady
(
tab
ORG_PAGE_URL
)
;
const
{
hooks
targetList
}
=
await
watchServiceWorkerTargets
(
{
mainRoot
tab
destroyServiceWorkersOnNavigation
}
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
0
targets
:
[
ORG_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
org
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
ORG_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
1
destroyed
:
1
targets
:
[
]
}
)
;
info
(
"
Go
back
.
com
page
wait
for
onAvailable
to
be
called
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
1
targets
:
[
COM_WORKER_URL
]
}
)
;
info
(
"
Unregister
.
com
service
worker
and
wait
until
onDestroyed
is
called
.
"
)
;
await
unregisterServiceWorker
(
tab
COM_PAGE_URL
)
;
await
checkHooks
(
hooks
{
available
:
2
destroyed
:
2
targets
:
[
]
}
)
;
targetList
.
destroy
(
)
;
await
client
.
waitForRequestsToSettle
(
)
;
await
client
.
close
(
)
;
await
removeTab
(
tab
)
;
}
async
function
setupServiceWorkerNavigationTest
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
info
(
"
Setup
the
test
page
with
workers
of
all
types
"
)
;
const
client
=
await
createLocalClient
(
)
;
const
mainRoot
=
client
.
mainRoot
;
return
{
client
mainRoot
}
;
}
async
function
watchServiceWorkerTargets
(
{
destroyServiceWorkersOnNavigation
mainRoot
tab
}
)
{
info
(
"
Create
a
target
list
for
a
tab
target
"
)
;
const
descriptor
=
await
mainRoot
.
getTab
(
{
tab
}
)
;
const
target
=
await
descriptor
.
getTarget
(
)
;
const
targetList
=
new
TargetList
(
mainRoot
target
)
;
targetList
.
listenForServiceWorkers
=
true
;
info
(
"
Set
targetList
.
destroyServiceWorkersOnNavigation
to
"
+
destroyServiceWorkersOnNavigation
)
;
targetList
.
destroyServiceWorkersOnNavigation
=
destroyServiceWorkersOnNavigation
;
await
targetList
.
startListening
(
)
;
const
hooks
=
{
availableCount
:
0
destroyedCount
:
0
targets
:
[
]
}
;
const
onAvailable
=
async
(
{
targetFront
}
)
=
>
{
hooks
.
availableCount
+
+
;
hooks
.
targets
.
push
(
targetFront
)
;
}
;
const
onDestroyed
=
(
{
targetFront
}
)
=
>
{
hooks
.
destroyedCount
+
+
;
hooks
.
targets
.
splice
(
hooks
.
targets
.
indexOf
(
targetFront
)
1
)
;
}
;
await
targetList
.
watchTargets
(
[
TYPES
.
SERVICE_WORKER
]
onAvailable
onDestroyed
)
;
return
{
hooks
targetList
}
;
}
async
function
unregisterServiceWorker
(
tab
expectedPageUrl
)
{
await
waitForRegistrationReady
(
tab
expectedPageUrl
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
content
.
wrappedJSObject
.
registration
.
unregister
(
)
)
;
}
async
function
waitForRegistrationReady
(
tab
expectedPageUrl
)
{
await
asyncWaitUntil
(
(
)
=
>
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
expectedPageUrl
]
function
(
_url
)
{
try
{
const
win
=
content
.
wrappedJSObject
;
const
isExpectedUrl
=
win
.
location
.
href
=
=
=
_url
;
const
hasRegistration
=
!
!
win
.
registration
;
return
isExpectedUrl
&
&
hasRegistration
;
}
catch
(
e
)
{
return
false
;
}
}
)
)
;
}
async
function
checkHooks
(
hooks
{
available
destroyed
targets
}
)
{
info
(
Wait
for
availableCount
=
{
available
}
and
destroyedCount
=
{
destroyed
}
)
;
await
waitUntil
(
(
)
=
>
hooks
.
availableCount
=
=
available
&
&
hooks
.
destroyedCount
=
=
destroyed
)
;
is
(
hooks
.
availableCount
available
"
onAvailable
was
called
as
expected
"
)
;
is
(
hooks
.
destroyedCount
destroyed
"
onDestroyed
was
called
as
expected
"
)
;
is
(
hooks
.
targets
.
length
targets
.
length
"
Expected
number
of
targets
"
)
;
targets
.
forEach
(
(
url
i
)
=
>
{
is
(
hooks
.
targets
[
i
]
.
url
url
SW
target
{
i
}
has
the
expected
url
)
;
}
)
;
}
