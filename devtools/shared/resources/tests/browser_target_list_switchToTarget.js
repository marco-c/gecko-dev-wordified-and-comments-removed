"
use
strict
"
;
const
{
TargetList
}
=
require
(
"
devtools
/
shared
/
resources
/
target
-
list
"
)
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
await
pushPref
(
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
1
)
;
const
client
=
await
createLocalClient
(
)
;
await
testSwitchToTarget
(
client
)
;
await
client
.
close
(
)
;
}
)
;
async
function
testSwitchToTarget
(
client
)
{
info
(
"
Test
TargetList
.
switchToTarget
method
"
)
;
const
{
mainRoot
}
=
client
;
let
target
=
await
mainRoot
.
getMainProcess
(
)
;
const
targetList
=
new
TargetList
(
mainRoot
target
)
;
await
targetList
.
startListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
is
(
targetList
.
targetFront
target
"
The
target
list
top
level
target
is
the
main
process
one
"
)
;
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
const
tab
=
await
addTab
(
data
:
text
/
html
<
iframe
src
=
"
data
:
text
/
html
foo
"
>
<
/
iframe
>
)
;
const
secondTarget
=
await
mainRoot
.
getTab
(
{
tab
:
gBrowser
.
selectedTab
}
)
;
const
frameTargets
=
[
]
;
const
onFrameAvailable
=
(
type
newTarget
isTopLevel
)
=
>
{
is
(
type
TargetList
.
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
newTarget
=
=
target
?
isTopLevel
:
!
isTopLevel
"
isTopLevel
argument
is
correct
"
)
;
frameTargets
.
push
(
newTarget
)
;
}
;
await
targetList
.
watchTargets
(
[
TargetList
.
TYPES
.
FRAME
]
onFrameAvailable
)
;
frameTargets
.
length
=
0
;
target
=
secondTarget
;
await
targetList
.
switchToTarget
(
secondTarget
)
;
is
(
targetList
.
targetFront
target
"
After
the
switch
the
top
level
target
has
been
updated
"
)
;
is
(
frameTargets
.
length
1
"
We
get
the
report
of
two
iframe
when
switching
to
the
new
target
"
)
;
is
(
frameTargets
[
0
]
target
)
;
targetList
.
stopListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
