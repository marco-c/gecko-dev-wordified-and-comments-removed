"
use
strict
"
;
const
{
TargetList
}
=
require
(
"
devtools
/
shared
/
resources
/
target
-
list
"
)
;
const
FISSION_TEST_URL
=
URL_ROOT
+
"
/
fission_document
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
await
pushPref
(
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
1
)
;
const
client
=
await
createLocalClient
(
)
;
const
mainRoot
=
client
.
mainRoot
;
await
testBrowserFrames
(
mainRoot
)
;
await
testTabFrames
(
mainRoot
)
;
await
client
.
close
(
)
;
}
)
;
async
function
testBrowserFrames
(
mainRoot
)
{
info
(
"
Test
TargetList
against
frames
via
the
parent
process
target
"
)
;
const
target
=
await
mainRoot
.
getMainProcess
(
)
;
const
targetList
=
new
TargetList
(
mainRoot
target
)
;
await
targetList
.
startListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
const
frames
=
await
targetList
.
getAllTargets
(
TargetList
.
TYPES
.
FRAME
)
;
const
hasBrowserDocument
=
frames
.
find
(
frameTarget
=
>
frameTarget
.
url
=
=
window
.
location
.
href
)
;
ok
(
hasBrowserDocument
"
retrieve
the
target
for
the
browser
document
"
)
;
const
frames2
=
await
targetList
.
getAllTargets
(
TargetList
.
TYPES
.
FRAME
)
;
is
(
frames2
.
length
frames
.
length
"
retrieved
the
same
number
of
frames
"
)
;
function
sortFronts
(
f1
f2
)
{
return
f1
.
actorID
<
f2
.
actorID
;
}
frames
.
sort
(
sortFronts
)
;
frames2
.
sort
(
sortFronts
)
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
is
(
frames
[
i
]
frames2
[
i
]
frame
{
i
}
targets
are
the
same
)
;
}
const
targets
=
[
]
;
const
onAvailable
=
(
type
newTarget
isTopLevel
)
=
>
{
is
(
type
TargetList
.
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
newTarget
=
=
target
?
isTopLevel
:
!
isTopLevel
"
isTopLevel
argument
is
correct
"
)
;
targets
.
push
(
newTarget
)
;
}
;
await
targetList
.
watchTargets
(
[
TargetList
.
TYPES
.
FRAME
]
onAvailable
)
;
is
(
targets
.
length
frames
.
length
"
retrieved
the
same
number
of
frames
via
watchTargets
"
)
;
frames
.
sort
(
sortFronts
)
;
targets
.
sort
(
sortFronts
)
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
is
(
frames
[
i
]
targets
[
i
]
frame
{
i
}
targets
are
the
same
via
watchTargets
)
;
}
targetList
.
unwatchTargets
(
[
TargetList
.
TYPES
.
FRAME
]
onAvailable
)
;
targetList
.
stopListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
}
async
function
testTabFrames
(
mainRoot
)
{
info
(
"
Test
TargetList
against
frames
via
a
tab
target
"
)
;
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
const
tab
=
await
addTab
(
FISSION_TEST_URL
)
;
const
target
=
await
mainRoot
.
getTab
(
{
tab
}
)
;
const
targetList
=
new
TargetList
(
mainRoot
target
)
;
await
targetList
.
startListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
const
frames
=
await
targetList
.
getAllTargets
(
TargetList
.
TYPES
.
FRAME
)
;
is
(
frames
.
length
1
"
retrieved
the
top
level
document
and
the
remoted
frame
"
)
;
is
(
frames
[
0
]
.
url
FISSION_TEST_URL
"
The
first
frame
is
the
top
level
document
"
)
;
const
targets
=
[
]
;
const
onAvailable
=
(
type
newTarget
isTopLevel
)
=
>
{
is
(
type
TargetList
.
TYPES
.
FRAME
"
We
are
only
notified
about
frame
targets
"
)
;
ok
(
newTarget
=
=
target
?
isTopLevel
:
!
isTopLevel
"
isTopLevel
argument
is
correct
"
)
;
targets
.
push
(
newTarget
)
;
}
;
await
targetList
.
watchTargets
(
[
TargetList
.
TYPES
.
FRAME
]
onAvailable
)
;
is
(
targets
.
length
frames
.
length
"
retrieved
the
same
number
of
frames
via
watchTargets
"
)
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
is
(
frames
[
i
]
targets
[
i
]
frame
{
i
}
targets
are
the
same
via
watchTargets
)
;
}
targetList
.
unwatchTargets
(
[
TargetList
.
TYPES
.
FRAME
]
onAvailable
)
;
targetList
.
stopListening
(
[
TargetList
.
TYPES
.
FRAME
]
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
