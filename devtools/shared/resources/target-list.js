"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
BROWSERTOOLBOX_FISSION_ENABLED
=
"
devtools
.
browsertoolbox
.
fission
"
;
const
CONTENTTOOLBOX_FISSION_ENABLED
=
"
devtools
.
contenttoolbox
.
fission
"
;
class
LegacyImplementationProcesses
{
constructor
(
targetList
onTargetAvailable
onTargetDestroyed
)
{
this
.
targetList
=
targetList
;
this
.
rootFront
=
targetList
.
rootFront
;
this
.
target
=
targetList
.
targetFront
;
this
.
onTargetAvailable
=
onTargetAvailable
;
this
.
onTargetDestroyed
=
onTargetDestroyed
;
this
.
descriptors
=
new
Set
(
)
;
this
.
_processListChanged
=
this
.
_processListChanged
.
bind
(
this
)
;
}
async
_processListChanged
(
)
{
const
processes
=
await
this
.
rootFront
.
listProcesses
(
)
;
for
(
const
descriptor
of
this
.
descriptors
)
{
if
(
!
processes
.
includes
(
descriptor
)
)
{
const
target
=
descriptor
.
getCachedTarget
(
)
;
if
(
target
)
{
this
.
onTargetDestroyed
(
target
)
;
}
descriptor
.
destroy
(
)
;
this
.
descriptors
.
delete
(
descriptor
)
;
}
}
const
promises
=
processes
.
filter
(
descriptor
=
>
!
this
.
descriptors
.
has
(
descriptor
)
)
.
map
(
async
descriptor
=
>
{
this
.
descriptors
.
add
(
descriptor
)
;
const
target
=
await
descriptor
.
getTarget
(
)
;
if
(
!
target
)
{
console
.
error
(
"
Wasn
'
t
able
to
retrieve
the
target
for
"
descriptor
.
actorID
)
;
return
;
}
await
this
.
onTargetAvailable
(
target
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
}
async
listen
(
)
{
this
.
rootFront
.
on
(
"
processListChanged
"
this
.
_processListChanged
)
;
await
this
.
_processListChanged
(
)
;
}
unlisten
(
)
{
this
.
rootFront
.
off
(
"
processListChanged
"
this
.
_processListChanged
)
;
}
}
class
LegacyImplementationFrames
{
constructor
(
targetList
onTargetAvailable
)
{
this
.
targetList
=
targetList
;
this
.
rootFront
=
targetList
.
rootFront
;
this
.
target
=
targetList
.
targetFront
;
this
.
onTargetAvailable
=
onTargetAvailable
;
}
async
listen
(
)
{
const
{
frames
}
=
await
this
.
target
.
listRemoteFrames
(
)
;
const
promises
=
frames
.
filter
(
descriptor
=
>
descriptor
.
parentID
=
=
this
.
target
.
browsingContextID
|
|
descriptor
.
id
=
=
this
.
target
.
browsingContextID
)
.
map
(
async
descriptor
=
>
{
const
target
=
await
descriptor
.
getTarget
(
)
;
if
(
!
target
)
{
console
.
error
(
"
Wasn
'
t
able
to
retrieve
the
target
for
"
descriptor
.
actorID
)
;
return
;
}
await
this
.
onTargetAvailable
(
target
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
}
unlisten
(
)
{
}
}
class
LegacyImplementationWorkers
{
constructor
(
targetList
onTargetAvailable
onTargetDestroyed
)
{
this
.
targetList
=
targetList
;
this
.
rootFront
=
targetList
.
rootFront
;
this
.
target
=
targetList
.
targetFront
;
this
.
onTargetAvailable
=
onTargetAvailable
;
this
.
onTargetDestroyed
=
onTargetDestroyed
;
this
.
targetsByProcess
=
new
WeakMap
(
)
;
this
.
targetsListeners
=
new
WeakMap
(
)
;
this
.
_onProcessAvailable
=
this
.
_onProcessAvailable
.
bind
(
this
)
;
this
.
_onProcessDestroyed
=
this
.
_onProcessDestroyed
.
bind
(
this
)
;
}
async
_onProcessAvailable
(
{
targetFront
}
)
{
this
.
targetsByProcess
.
set
(
targetFront
new
Set
(
)
)
;
const
listener
=
this
.
_workerListChanged
.
bind
(
this
targetFront
)
;
this
.
targetsListeners
.
set
(
targetFront
listener
)
;
if
(
targetFront
.
isParentProcess
)
{
this
.
rootFront
.
on
(
"
workerListChanged
"
listener
)
;
}
else
{
targetFront
.
on
(
"
workerListChanged
"
listener
)
;
}
await
this
.
_workerListChanged
(
targetFront
)
;
}
async
_onProcessDestroyed
(
{
targetFront
}
)
{
const
existingTargets
=
this
.
targetsByProcess
.
get
(
targetFront
)
;
for
(
const
target
of
existingTargets
)
{
this
.
onTargetDestroyed
(
target
)
;
target
.
destroy
(
)
;
existingTargets
.
delete
(
target
)
;
}
this
.
targetsByProcess
.
delete
(
targetFront
)
;
this
.
targetsListeners
.
delete
(
targetFront
)
;
}
async
_workerListChanged
(
targetFront
)
{
let
workers
;
if
(
targetFront
.
isParentProcess
)
{
(
{
workers
}
=
await
this
.
rootFront
.
listWorkers
(
)
)
;
}
else
{
(
{
workers
}
=
await
targetFront
.
listWorkers
(
)
)
;
}
const
existingTargets
=
this
.
targetsByProcess
.
get
(
targetFront
)
;
for
(
const
target
of
existingTargets
)
{
if
(
!
workers
.
includes
(
target
)
)
{
this
.
onTargetDestroyed
(
target
)
;
target
.
destroy
(
)
;
existingTargets
.
delete
(
target
)
;
}
}
const
promises
=
workers
.
filter
(
workerTarget
=
>
!
workerTarget
.
url
.
startsWith
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_worker
"
)
)
.
filter
(
workerTarget
=
>
!
existingTargets
.
has
(
workerTarget
)
)
.
map
(
async
workerTarget
=
>
{
existingTargets
.
add
(
workerTarget
)
;
await
this
.
onTargetAvailable
(
workerTarget
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
}
async
listen
(
)
{
if
(
this
.
target
.
isParentProcess
)
{
await
this
.
targetList
.
watchTargets
(
[
TargetList
.
TYPES
.
PROCESS
]
this
.
_onProcessAvailable
this
.
_onProcessDestroyed
)
;
await
this
.
_onProcessAvailable
(
{
targetFront
:
this
.
target
}
)
;
}
else
{
this
.
targetsByProcess
.
set
(
this
.
target
new
Set
(
)
)
;
this
.
_workerListChangedListener
=
this
.
_workerListChanged
.
bind
(
this
this
.
target
)
;
this
.
target
.
on
(
"
workerListChanged
"
this
.
_workerListChangedListener
)
;
await
this
.
_workerListChanged
(
this
.
target
)
;
}
}
unlisten
(
)
{
if
(
this
.
target
.
isParentProcess
)
{
for
(
const
targetFront
of
this
.
targetList
.
getAllTargets
(
TargetList
.
TYPES
.
PROCESS
)
)
{
const
listener
=
this
.
targetsListeners
.
get
(
targetFront
)
;
targetFront
.
off
(
"
workerListChanged
"
listener
)
;
this
.
targetsByProcess
.
delete
(
targetFront
)
;
this
.
targetsListeners
.
delete
(
targetFront
)
;
}
this
.
targetList
.
unwatchTargets
(
[
TargetList
.
TYPES
.
PROCESS
]
this
.
_onProcessAvailable
this
.
_onProcessDestroyed
)
;
}
else
{
this
.
target
.
off
(
"
workerListChanged
"
this
.
_workerListChangedListener
)
;
delete
this
.
_workerListChangedListener
;
this
.
targetsByProcess
.
delete
(
this
.
target
)
;
this
.
targetsListeners
.
delete
(
this
.
target
)
;
}
}
}
class
TargetList
{
constructor
(
rootFront
targetFront
)
{
this
.
rootFront
=
rootFront
;
this
.
descriptorFront
=
targetFront
.
descriptorFront
;
this
.
targetFront
=
targetFront
;
this
.
_listenersStarted
=
new
Set
(
)
;
this
.
_targets
=
new
Set
(
)
;
this
.
_targets
.
add
(
targetFront
)
;
this
.
_createListeners
=
new
EventEmitter
(
)
;
this
.
_destroyListeners
=
new
EventEmitter
(
)
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
legacyImplementation
=
{
process
:
new
LegacyImplementationProcesses
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
frame
:
new
LegacyImplementationFrames
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
worker
:
new
LegacyImplementationWorkers
(
this
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
}
;
this
.
listenForWorkers
=
false
;
}
async
_onTargetAvailable
(
targetFront
isTargetSwitching
=
false
)
{
if
(
this
.
_targets
.
has
(
targetFront
)
)
{
if
(
targetFront
!
=
this
.
targetFront
)
{
console
.
error
(
"
Target
is
already
registered
in
the
TargetList
"
targetFront
.
actorID
)
;
}
return
;
}
this
.
_targets
.
add
(
targetFront
)
;
const
targetType
=
this
.
getTargetType
(
targetFront
)
;
await
this
.
_createListeners
.
emitAsync
(
targetType
{
type
:
targetType
targetFront
isTopLevel
:
targetFront
=
=
this
.
targetFront
isTargetSwitching
}
)
;
}
_onTargetDestroyed
(
targetFront
isTargetSwitching
=
false
)
{
const
targetType
=
this
.
getTargetType
(
targetFront
)
;
this
.
_destroyListeners
.
emit
(
targetType
{
type
:
targetType
targetFront
isTopLevel
:
targetFront
=
=
this
.
targetFront
isTargetSwitching
}
)
;
this
.
_targets
.
delete
(
targetFront
)
;
}
_setListening
(
type
value
)
{
if
(
value
)
{
this
.
_listenersStarted
.
add
(
type
)
;
}
else
{
this
.
_listenersStarted
.
delete
(
type
)
;
}
}
_isListening
(
type
)
{
return
this
.
_listenersStarted
.
has
(
type
)
;
}
async
startListening
(
)
{
let
types
=
[
]
;
if
(
this
.
targetFront
.
isParentProcess
)
{
const
fissionBrowserToolboxEnabled
=
Services
.
prefs
.
getBoolPref
(
BROWSERTOOLBOX_FISSION_ENABLED
)
;
if
(
fissionBrowserToolboxEnabled
)
{
types
=
TargetList
.
ALL_TYPES
;
}
}
else
if
(
this
.
targetFront
.
isLocalTab
)
{
const
fissionContentToolboxEnabled
=
Services
.
prefs
.
getBoolPref
(
CONTENTTOOLBOX_FISSION_ENABLED
)
;
if
(
fissionContentToolboxEnabled
)
{
types
=
[
TargetList
.
TYPES
.
FRAME
]
;
}
}
if
(
this
.
listenForWorkers
&
&
!
types
.
includes
(
TargetList
.
TYPES
.
WORKER
)
)
{
types
.
push
(
TargetList
.
TYPES
.
WORKER
)
;
}
for
(
const
type
of
types
)
{
if
(
this
.
_isListening
(
type
)
)
{
continue
;
}
this
.
_setListening
(
type
true
)
;
const
supportsWatcher
=
this
.
descriptorFront
?
.
traits
?
.
watcher
;
if
(
supportsWatcher
)
{
const
watcher
=
await
this
.
descriptorFront
.
getWatcher
(
)
;
if
(
watcher
.
traits
[
type
]
)
{
if
(
!
this
.
_startedListeningToWatcher
)
{
this
.
_startedListeningToWatcher
=
true
;
watcher
.
on
(
"
target
-
available
"
this
.
_onTargetAvailable
)
;
watcher
.
on
(
"
target
-
destroyed
"
this
.
_onTargetDestroyed
)
;
}
await
watcher
.
watchTargets
(
type
)
;
continue
;
}
}
if
(
this
.
legacyImplementation
[
type
]
)
{
await
this
.
legacyImplementation
[
type
]
.
listen
(
)
;
}
else
{
throw
new
Error
(
Unsupported
target
type
'
{
type
}
'
)
;
}
}
}
stopListening
(
)
{
for
(
const
type
of
TargetList
.
ALL_TYPES
)
{
if
(
!
this
.
_isListening
(
type
)
)
{
continue
;
}
this
.
_setListening
(
type
false
)
;
const
supportsWatcher
=
this
.
descriptorFront
?
.
traits
?
.
watcher
;
if
(
supportsWatcher
)
{
const
watcher
=
this
.
descriptorFront
.
getCachedWatcher
(
)
;
if
(
watcher
&
&
watcher
.
traits
[
type
]
)
{
watcher
.
unwatchTargets
(
type
)
;
continue
;
}
}
if
(
this
.
legacyImplementation
[
type
]
)
{
this
.
legacyImplementation
[
type
]
.
unlisten
(
)
;
}
else
{
throw
new
Error
(
Unsupported
target
type
'
{
type
}
'
)
;
}
}
}
getTargetType
(
target
)
{
const
{
typeName
}
=
target
;
if
(
typeName
=
=
"
browsingContextTarget
"
)
{
return
TargetList
.
TYPES
.
FRAME
;
}
else
if
(
typeName
=
=
"
contentProcessTarget
"
|
|
typeName
=
=
"
parentProcessTarget
"
)
{
return
TargetList
.
TYPES
.
PROCESS
;
}
else
if
(
typeName
=
=
"
workerTarget
"
)
{
return
TargetList
.
TYPES
.
WORKER
;
}
throw
new
Error
(
"
Unsupported
target
typeName
:
"
+
typeName
)
;
}
_matchTargetType
(
type
target
)
{
return
type
=
=
=
this
.
getTargetType
(
target
)
;
}
async
watchTargets
(
types
onAvailable
onDestroy
)
{
if
(
typeof
onAvailable
!
=
"
function
"
)
{
throw
new
Error
(
"
TargetList
.
watchTargets
expects
a
function
as
second
argument
"
)
;
}
const
promises
=
[
.
.
.
this
.
_targets
]
.
filter
(
targetFront
=
>
{
const
targetType
=
this
.
getTargetType
(
targetFront
)
;
return
types
.
includes
(
targetType
)
;
}
)
.
map
(
async
targetFront
=
>
{
try
{
await
onAvailable
(
{
type
:
this
.
getTargetType
(
targetFront
)
targetFront
isTopLevel
:
targetFront
=
=
this
.
targetFront
isTargetSwitching
:
false
}
)
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
when
calling
onAvailable
handler
"
e
.
message
e
)
;
}
}
)
;
for
(
const
type
of
types
)
{
this
.
_createListeners
.
on
(
type
onAvailable
)
;
if
(
onDestroy
)
{
this
.
_destroyListeners
.
on
(
type
onDestroy
)
;
}
}
await
Promise
.
all
(
promises
)
;
}
async
unwatchTargets
(
types
onAvailable
onDestroy
)
{
if
(
typeof
onAvailable
!
=
"
function
"
)
{
throw
new
Error
(
"
TargetList
.
unwatchTargets
expects
a
function
as
second
argument
"
)
;
}
for
(
const
type
of
types
)
{
this
.
_createListeners
.
off
(
type
onAvailable
)
;
if
(
onDestroy
)
{
this
.
_destroyListeners
.
off
(
type
onDestroy
)
;
}
}
}
getAllTargets
(
type
)
{
if
(
!
type
)
{
throw
new
Error
(
"
getAllTargets
expects
a
'
type
'
argument
"
)
;
}
const
targets
=
[
.
.
.
this
.
_targets
]
.
filter
(
target
=
>
this
.
_matchTargetType
(
type
target
)
)
;
return
targets
;
}
async
getAllFronts
(
targetType
frontType
)
{
const
fronts
=
[
]
;
const
targets
=
this
.
getAllTargets
(
targetType
)
;
for
(
const
target
of
targets
)
{
const
front
=
await
target
.
getFront
(
frontType
)
;
fronts
.
push
(
front
)
;
}
return
fronts
;
}
async
switchToTarget
(
newTarget
)
{
for
(
const
target
of
this
.
_targets
)
{
const
isTargetSwitching
=
target
=
=
this
.
targetFront
;
this
.
_onTargetDestroyed
(
target
isTargetSwitching
)
;
}
this
.
stopListening
(
)
;
this
.
_targets
.
clear
(
)
;
this
.
targetFront
=
newTarget
;
await
this
.
_onTargetAvailable
(
newTarget
true
)
;
await
this
.
startListening
(
)
;
}
}
TargetList
.
TYPES
=
TargetList
.
prototype
.
TYPES
=
{
PROCESS
:
"
process
"
FRAME
:
"
frame
"
WORKER
:
"
worker
"
}
;
TargetList
.
ALL_TYPES
=
TargetList
.
prototype
.
ALL_TYPES
=
Object
.
values
(
TargetList
.
TYPES
)
;
module
.
exports
=
{
TargetList
}
;
