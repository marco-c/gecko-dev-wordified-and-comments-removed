"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
Object
.
defineProperty
(
this
"
Promise
"
{
value
:
require
(
"
promise
"
)
writable
:
false
configurable
:
false
}
)
;
const
{
asyncOnce
promiseInvoke
promiseCall
}
=
require
(
"
devtools
/
shared
/
async
-
utils
"
)
;
function
run_test
(
)
{
do_test_pending
(
)
;
Task
.
spawn
(
function
*
(
)
{
yield
test_async_args
(
asyncOnce
)
;
yield
test_async_return
(
asyncOnce
)
;
yield
test_async_throw
(
asyncOnce
)
;
yield
test_async_once
(
)
;
yield
test_async_invoke
(
)
;
do_test_finished
(
)
;
}
)
.
catch
(
error
=
>
{
do_throw
(
error
)
;
}
)
;
}
function
test_async_args
(
async
)
{
let
obj
=
{
method
:
async
(
function
*
(
a
b
)
{
Assert
.
equal
(
this
obj
)
;
Assert
.
equal
(
a
"
foo
"
)
;
Assert
.
equal
(
b
"
bar
"
)
;
}
)
}
;
return
obj
.
method
(
"
foo
"
"
bar
"
)
;
}
function
test_async_return
(
async
)
{
let
obj
=
{
method
:
async
(
function
*
(
a
b
)
{
return
a
+
b
;
}
)
}
;
return
obj
.
method
(
"
foo
"
"
bar
"
)
.
then
(
ret
=
>
{
Assert
.
equal
(
ret
"
foobar
"
)
;
}
)
;
}
function
test_async_throw
(
async
)
{
let
obj
=
{
method
:
async
(
function
*
(
)
{
throw
new
Error
(
"
boom
"
)
;
}
)
}
;
return
obj
.
method
(
)
.
catch
(
error
=
>
{
Assert
.
ok
(
error
instanceof
Error
)
;
Assert
.
equal
(
error
.
message
"
boom
"
)
;
}
)
;
}
function
test_async_once
(
)
{
let
counter
=
0
;
function
Foo
(
)
{
}
Foo
.
prototype
=
{
ran
:
false
method
:
asyncOnce
(
function
*
(
)
{
yield
Promise
.
resolve
(
)
;
if
(
this
.
ran
)
{
do_throw
(
"
asyncOnce
function
unexpectedly
ran
twice
on
the
same
object
"
)
;
}
this
.
ran
=
true
;
return
counter
+
+
;
}
)
}
;
let
foo1
=
new
Foo
(
)
;
let
foo2
=
new
Foo
(
)
;
let
p1
=
foo1
.
method
(
)
;
let
p2
=
foo2
.
method
(
)
;
Assert
.
notEqual
(
p1
p2
)
;
let
p3
=
foo1
.
method
(
)
;
Assert
.
equal
(
p1
p3
)
;
Assert
.
ok
(
!
foo1
.
ran
)
;
let
p4
=
foo2
.
method
(
)
;
Assert
.
equal
(
p2
p4
)
;
Assert
.
ok
(
!
foo2
.
ran
)
;
return
p1
.
then
(
ret
=
>
{
Assert
.
ok
(
foo1
.
ran
)
;
Assert
.
equal
(
ret
0
)
;
return
p2
;
}
)
.
then
(
ret
=
>
{
Assert
.
ok
(
foo2
.
ran
)
;
Assert
.
equal
(
ret
1
)
;
}
)
;
}
function
test_async_invoke
(
)
{
return
Task
.
spawn
(
function
*
(
)
{
function
func
(
a
b
expectedThis
callback
)
{
Assert
.
equal
(
a
"
foo
"
)
;
Assert
.
equal
(
b
"
bar
"
)
;
Assert
.
equal
(
this
expectedThis
)
;
callback
(
a
+
b
)
;
}
let
callResult
=
yield
promiseCall
(
func
"
foo
"
"
bar
"
undefined
)
;
Assert
.
equal
(
callResult
"
foobar
"
)
;
let
obj
=
{
method
:
func
}
;
let
invokeResult
=
yield
promiseInvoke
(
obj
obj
.
method
"
foo
"
"
bar
"
obj
)
;
Assert
.
equal
(
invokeResult
"
foobar
"
)
;
function
multipleResults
(
callback
)
{
callback
(
"
foo
"
"
bar
"
)
;
}
let
results
=
yield
promiseCall
(
multipleResults
)
;
Assert
.
equal
(
results
.
length
2
)
;
Assert
.
equal
(
results
[
0
]
"
foo
"
)
;
Assert
.
equal
(
results
[
1
]
"
bar
"
)
;
function
thrower
(
)
{
throw
new
Error
(
"
boom
"
)
;
}
yield
promiseCall
(
thrower
)
.
catch
(
error
=
>
{
Assert
.
ok
(
error
instanceof
Error
)
;
Assert
.
equal
(
error
.
message
"
boom
"
)
;
}
)
;
}
)
;
}
