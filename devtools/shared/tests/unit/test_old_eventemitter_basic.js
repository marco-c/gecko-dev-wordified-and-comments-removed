"
use
strict
"
;
const
{
ConsoleAPIListener
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
TESTS
=
{
testEventEmitterCreation
(
)
{
let
emitter
=
getEventEmitter
(
)
;
ok
(
emitter
"
We
have
an
event
emitter
"
)
;
}
testEmittingEvents
(
done
)
{
let
emitter
=
getEventEmitter
(
)
;
let
beenHere1
=
false
;
let
beenHere2
=
false
;
function
next
(
eventName
str1
str2
)
{
equal
(
eventName
"
next
"
"
Got
event
"
)
;
equal
(
str1
"
abc
"
"
Argument
1
is
correct
"
)
;
equal
(
str2
"
def
"
"
Argument
2
is
correct
"
)
;
ok
(
!
beenHere1
"
first
time
in
next
callback
"
)
;
beenHere1
=
true
;
emitter
.
off
(
"
next
"
next
)
;
emitter
.
emit
(
"
next
"
)
;
emitter
.
once
(
"
onlyonce
"
onlyOnce
)
;
emitter
.
emit
(
"
onlyonce
"
)
;
emitter
.
emit
(
"
onlyonce
"
)
;
}
function
onlyOnce
(
)
{
ok
(
!
beenHere2
"
\
"
once
\
"
listener
has
been
called
once
"
)
;
beenHere2
=
true
;
emitter
.
emit
(
"
onlyonce
"
)
;
done
(
)
;
}
emitter
.
on
(
"
next
"
next
)
;
emitter
.
emit
(
"
next
"
"
abc
"
"
def
"
)
;
}
testThrowingExceptionInListener
(
done
)
{
let
emitter
=
getEventEmitter
(
)
;
let
listener
=
new
ConsoleAPIListener
(
null
{
onConsoleAPICall
(
message
)
{
equal
(
message
.
level
"
error
"
)
;
equal
(
message
.
arguments
[
0
]
"
foo
:
bar
"
)
;
listener
.
destroy
(
)
;
done
(
)
;
}
}
)
;
listener
.
init
(
)
;
function
throwListener
(
)
{
emitter
.
off
(
"
throw
-
exception
"
)
;
throw
Object
.
create
(
{
toString
:
(
)
=
>
"
foo
"
stack
:
"
bar
"
}
)
;
}
emitter
.
on
(
"
throw
-
exception
"
throwListener
)
;
emitter
.
emit
(
"
throw
-
exception
"
)
;
}
testKillItWhileEmitting
(
done
)
{
let
emitter
=
getEventEmitter
(
)
;
const
c1
=
(
)
=
>
ok
(
true
"
c1
called
"
)
;
const
c2
=
(
)
=
>
{
ok
(
true
"
c2
called
"
)
;
emitter
.
off
(
"
tick
"
c3
)
;
}
;
const
c3
=
(
)
=
>
ok
(
false
"
c3
should
not
be
called
"
)
;
const
c4
=
(
)
=
>
{
ok
(
true
"
c4
called
"
)
;
done
(
)
;
}
;
emitter
.
on
(
"
tick
"
c1
)
;
emitter
.
on
(
"
tick
"
c2
)
;
emitter
.
on
(
"
tick
"
c3
)
;
emitter
.
on
(
"
tick
"
c4
)
;
emitter
.
emit
(
"
tick
"
)
;
}
testOffAfterOnce
(
)
{
let
emitter
=
getEventEmitter
(
)
;
let
enteredC1
=
false
;
let
c1
=
(
)
=
>
(
enteredC1
=
true
)
;
emitter
.
once
(
"
oao
"
c1
)
;
emitter
.
off
(
"
oao
"
c1
)
;
emitter
.
emit
(
"
oao
"
)
;
ok
(
!
enteredC1
"
c1
should
not
be
called
"
)
;
}
testPromise
(
)
{
let
emitter
=
getEventEmitter
(
)
;
let
p
=
emitter
.
once
(
"
thing
"
)
;
let
firstCallbackCalled
=
false
;
let
check1
=
p
.
then
(
arg
=
>
{
equal
(
firstCallbackCalled
false
"
first
callback
called
only
once
"
)
;
firstCallbackCalled
=
true
;
equal
(
arg
"
happened
"
"
correct
arg
in
promise
"
)
;
return
"
rval
from
c1
"
;
}
)
;
emitter
.
emit
(
"
thing
"
"
happened
"
"
ignored
"
)
;
let
secondCallbackCalled
=
false
;
let
check2
=
p
.
then
(
arg
=
>
{
ok
(
true
"
second
callback
called
"
)
;
equal
(
arg
"
happened
"
"
correct
arg
in
promise
"
)
;
secondCallbackCalled
=
true
;
equal
(
arg
"
happened
"
"
correct
arg
in
promise
(
a
second
time
)
"
)
;
return
"
rval
from
c2
"
;
}
)
;
emitter
.
emit
(
"
thing
"
"
trashinate
"
)
;
let
pfoo
=
emitter
.
once
(
"
foo
"
)
;
let
pbar
=
emitter
.
once
(
"
bar
"
)
;
let
check3
=
pfoo
.
then
(
arg
=
>
{
ok
(
arg
=
=
=
undefined
"
no
arg
for
foo
event
"
)
;
return
"
rval
from
c3
"
;
}
)
;
pbar
.
then
(
(
)
=
>
{
ok
(
false
"
pbar
should
not
be
called
"
)
;
}
)
;
emitter
.
emit
(
"
foo
"
)
;
equal
(
secondCallbackCalled
false
"
second
callback
not
called
yet
"
)
;
return
Promise
.
all
(
[
check1
check2
check3
]
)
.
then
(
args
=
>
{
equal
(
args
[
0
]
"
rval
from
c1
"
"
callback
1
done
good
"
)
;
equal
(
args
[
1
]
"
rval
from
c2
"
"
callback
2
done
good
"
)
;
equal
(
args
[
2
]
"
rval
from
c3
"
"
callback
3
done
good
"
)
;
}
)
;
}
}
;
const
runnable
=
(
tests
)
=
>
(
async
function
(
)
{
for
(
let
name
of
Object
.
keys
(
tests
)
)
{
do_print
(
name
)
;
if
(
tests
[
name
]
.
length
=
=
=
1
)
{
await
(
new
Promise
(
resolve
=
>
tests
[
name
]
(
resolve
)
)
)
;
}
else
{
await
tests
[
name
]
(
)
;
}
}
}
)
;
const
createNewEmitter
=
(
)
=
>
new
EventEmitter
(
)
;
const
decorateObject
=
(
)
=
>
EventEmitter
.
decorate
(
{
}
)
;
let
getEventEmitter
=
createNewEmitter
;
add_task
(
runnable
(
TESTS
)
)
;
add_task
(
(
)
=
>
(
getEventEmitter
=
decorateObject
)
)
;
add_task
(
runnable
(
TESTS
)
)
;
