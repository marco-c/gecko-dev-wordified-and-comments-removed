"
use
strict
"
;
const
kDebuggerPrefs
=
[
"
devtools
.
debugger
.
remote
-
enabled
"
"
devtools
.
chrome
.
enabled
"
]
;
const
DEVTOOLS_F12_DISABLED_PREF
=
"
devtools
.
experiment
.
f12
.
shortcut_disabled
"
;
const
DEVTOOLS_POLICY_DISABLED_PREF
=
"
devtools
.
policy
.
disabled
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
CustomizableWidgets
"
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ProfilerMenuButton
"
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
WebChannel
"
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PanelMultiView
"
"
resource
:
/
/
/
modules
/
PanelMultiView
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
Telemetry
"
function
(
)
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
return
Telemetry
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
KeyShortcutsBundle
"
function
(
)
{
return
new
Localization
(
[
"
devtools
/
startup
/
key
-
shortcuts
.
ftl
"
]
true
)
;
}
)
;
function
getLocalizedKeyShortcut
(
id
)
{
try
{
return
lazy
.
KeyShortcutsBundle
.
formatValueSync
(
id
)
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
retrieve
DevTools
localized
shortcut
for
id
"
id
)
;
return
null
;
}
}
XPCOMUtils
.
defineLazyGetter
(
lazy
"
KeyShortcuts
"
function
(
)
{
const
isMac
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
modifiers
=
isMac
?
"
accel
alt
"
:
"
accel
shift
"
;
const
shortcuts
=
[
{
id
:
"
toggleToolbox
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
toggle
-
toolbox
"
)
modifiers
}
{
id
:
"
toggleToolboxF12
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
toggle
-
toolbox
-
f12
"
)
modifiers
:
"
"
}
{
id
:
"
browserToolbox
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
browser
-
toolbox
"
)
modifiers
:
"
accel
alt
shift
"
}
{
id
:
"
browserConsole
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
browser
-
console
"
)
modifiers
:
"
accel
shift
"
}
{
id
:
"
responsiveDesignMode
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
responsive
-
design
-
mode
"
)
modifiers
}
{
toolId
:
"
inspector
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
inspector
"
)
modifiers
}
{
toolId
:
"
webconsole
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
webconsole
"
)
modifiers
}
{
toolId
:
"
jsdebugger
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
jsdebugger
"
)
modifiers
}
{
toolId
:
"
netmonitor
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
netmonitor
"
)
modifiers
}
{
toolId
:
"
styleeditor
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
styleeditor
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
performance
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
performance
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
storage
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
storage
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
dom
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
dom
"
)
modifiers
}
{
toolId
:
"
accessibility
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
accessibility
-
f12
"
)
modifiers
:
"
shift
"
}
]
;
if
(
isMac
)
{
shortcuts
.
push
(
{
id
:
"
inspectorMac
"
toolId
:
"
inspector
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
inspector
"
)
modifiers
:
"
accel
shift
"
}
)
;
}
if
(
lazy
.
ProfilerMenuButton
.
isInNavbar
(
)
)
{
shortcuts
.
push
(
.
.
.
getProfilerKeyShortcuts
(
)
)
;
}
return
shortcuts
;
}
)
;
function
getProfilerKeyShortcuts
(
)
{
return
[
{
id
:
"
profilerStartStop
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
profiler
-
start
-
stop
"
)
modifiers
:
"
control
shift
"
}
{
id
:
"
profilerCapture
"
shortcut
:
getLocalizedKeyShortcut
(
"
devtools
-
commandkey
-
profiler
-
capture
"
)
modifiers
:
"
control
shift
"
}
]
;
}
function
validateProfilerWebChannelUrl
(
targetUrl
)
{
const
frontEndUrl
=
"
https
:
/
/
profiler
.
firefox
.
com
"
;
if
(
targetUrl
!
=
=
frontEndUrl
)
{
if
(
targetUrl
=
=
=
"
http
:
/
/
example
.
com
"
|
|
/
^
http
:
\
/
\
/
localhost
:
\
d
+
\
/
?
/
.
test
(
targetUrl
)
|
|
/
^
https
:
\
/
\
/
(
?
:
deploy
-
preview
-
\
d
+
|
main
)
-
-
perf
-
html
\
.
netlify
\
.
(
?
:
com
|
app
)
\
/
?
/
.
test
(
targetUrl
)
)
{
return
targetUrl
;
}
console
.
error
(
The
preference
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
was
set
to
a
+
"
URL
that
is
not
allowed
.
No
WebChannel
messages
will
be
sent
between
the
"
+
browser
and
that
URL
.
Falling
back
to
{
frontEndUrl
}
.
Only
localhost
+
"
and
deploy
previews
URLs
are
allowed
.
"
targetUrl
)
;
}
return
frontEndUrl
;
}
XPCOMUtils
.
defineLazyGetter
(
lazy
"
ProfilerPopupBackground
"
function
(
)
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
background
.
jsm
.
js
"
)
;
}
)
;
function
DevToolsStartup
(
)
{
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
addDevToolsItemsToSubview
=
this
.
addDevToolsItemsToSubview
.
bind
(
this
)
;
this
.
onMoreToolsViewShowing
=
this
.
onMoreToolsViewShowing
.
bind
(
this
)
;
this
.
toggleProfilerKeyShortcuts
=
this
.
toggleProfilerKeyShortcuts
.
bind
(
this
)
;
}
DevToolsStartup
.
prototype
=
{
initialized
:
false
recorded
:
false
get
telemetry
(
)
{
if
(
!
this
.
_telemetry
)
{
this
.
_telemetry
=
new
lazy
.
Telemetry
(
)
;
this
.
_telemetry
.
setEventRecordingEnabled
(
true
)
;
}
return
this
.
_telemetry
;
}
developerToggleCreated
:
false
profilerRecordingButtonCreated
:
false
isDisabledByPolicy
(
)
{
return
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_POLICY_DISABLED_PREF
false
)
;
}
handle
(
cmdLine
)
{
const
flags
=
this
.
readCommandLineFlags
(
cmdLine
)
;
const
isInitialLaunch
=
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
;
if
(
isInitialLaunch
)
{
if
(
this
.
isDevToolsUser
(
)
)
{
Services
.
prefs
.
setBoolPref
(
DEVTOOLS_F12_DISABLED_PREF
false
)
;
}
this
.
devtoolsFlag
=
flags
.
devtools
;
Services
.
obs
.
addObserver
(
this
.
onWindowReady
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
this
.
onMoreToolsViewShowing
"
web
-
developer
-
tools
-
view
-
showing
"
)
;
if
(
!
this
.
isDisabledByPolicy
(
)
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
this
.
hookDeveloperToggle
(
)
;
}
this
.
hookProfilerRecordingButton
(
)
;
}
}
if
(
flags
.
console
)
{
this
.
commandLine
=
true
;
this
.
handleConsoleFlag
(
cmdLine
)
;
}
if
(
flags
.
debugger
)
{
this
.
commandLine
=
true
;
const
binaryPath
=
typeof
flags
.
debugger
=
=
"
string
"
?
flags
.
debugger
:
null
;
this
.
handleDebuggerFlag
(
cmdLine
binaryPath
)
;
}
if
(
flags
.
devToolsServer
)
{
this
.
handleDevToolsServerFlag
(
cmdLine
flags
.
devToolsServer
)
;
}
}
readCommandLineFlags
(
cmdLine
)
{
if
(
this
.
isDisabledByPolicy
(
)
)
{
return
{
console
:
false
debugger
:
false
devtools
:
false
devToolsServer
:
false
}
;
}
const
console
=
cmdLine
.
handleFlag
(
"
jsconsole
"
false
)
;
const
devtools
=
cmdLine
.
handleFlag
(
"
devtools
"
false
)
;
let
devToolsServer
;
try
{
devToolsServer
=
cmdLine
.
handleFlagWithParam
(
"
start
-
debugger
-
server
"
false
)
;
}
catch
(
e
)
{
devToolsServer
=
cmdLine
.
handleFlag
(
"
start
-
debugger
-
server
"
false
)
;
}
let
debuggerFlag
;
try
{
debuggerFlag
=
cmdLine
.
handleFlagWithParam
(
"
jsdebugger
"
false
)
;
}
catch
(
e
)
{
debuggerFlag
=
cmdLine
.
handleFlag
(
"
jsdebugger
"
false
)
;
}
return
{
console
debugger
:
debuggerFlag
devtools
devToolsServer
}
;
}
onWindowReady
(
window
)
{
if
(
this
.
isDisabledByPolicy
(
)
)
{
return
;
}
this
.
hookWindow
(
window
)
;
if
(
!
this
.
_firstWindowReadyReceived
)
{
this
.
onFirstWindowReady
(
window
)
;
this
.
_firstWindowReadyReceived
=
true
;
}
JsonView
.
initialize
(
)
;
}
onFirstWindowReady
(
window
)
{
if
(
this
.
devtoolsFlag
)
{
this
.
handleDevToolsFlag
(
window
)
;
if
(
this
.
commandLine
)
{
this
.
sendEntryPointTelemetry
(
"
CommandLine
"
)
;
}
}
this
.
setSlowScriptDebugHandler
(
)
;
}
hookWindow
(
window
)
{
this
.
hookKeyShortcuts
(
window
)
;
this
.
hookDeveloperToggle
(
)
;
this
.
hookProfilerRecordingButton
(
)
;
if
(
!
this
.
initialized
)
{
this
.
hookBrowserToolsMenu
(
window
)
;
}
}
hookDeveloperToggle
(
)
{
if
(
this
.
developerToggleCreated
)
{
return
;
}
const
id
=
"
developer
-
button
"
;
const
widget
=
lazy
.
CustomizableUI
.
getWidget
(
id
)
;
if
(
widget
&
&
widget
.
provider
=
=
lazy
.
CustomizableUI
.
PROVIDER_API
)
{
return
;
}
const
panelviewId
=
"
PanelUI
-
developer
-
tools
"
;
const
subviewId
=
"
PanelUI
-
developer
-
tools
-
view
"
;
const
item
=
{
id
type
:
"
view
"
viewId
:
panelviewId
shortcutId
:
"
key_toggleToolbox
"
tooltiptext
:
"
developer
-
button
.
tooltiptext2
"
onViewShowing
:
event
=
>
{
const
doc
=
event
.
target
.
ownerDocument
;
const
developerItems
=
lazy
.
PanelMultiView
.
getViewNode
(
doc
subviewId
)
;
this
.
addDevToolsItemsToSubview
(
developerItems
)
;
}
onInit
(
anchor
)
{
this
.
onBeforeCreated
(
anchor
.
ownerDocument
)
;
}
onBeforeCreated
:
doc
=
>
{
this
.
hookKeyShortcuts
(
doc
.
defaultView
)
;
}
}
;
lazy
.
CustomizableUI
.
createWidget
(
item
)
;
lazy
.
CustomizableWidgets
.
push
(
item
)
;
this
.
developerToggleCreated
=
true
;
}
addDevToolsItemsToSubview
(
subview
)
{
this
.
initDevTools
(
"
HamburgerMenu
"
)
;
const
doc
=
subview
.
ownerDocument
;
const
menu
=
doc
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
const
itemsToDisplay
=
[
.
.
.
menu
.
children
]
;
lazy
.
CustomizableUI
.
clearSubview
(
subview
)
;
lazy
.
CustomizableUI
.
fillSubviewFromMenuItems
(
itemsToDisplay
subview
)
;
}
onMoreToolsViewShowing
(
moreToolsView
)
{
this
.
addDevToolsItemsToSubview
(
moreToolsView
)
;
}
hookProfilerRecordingButton
(
)
{
if
(
this
.
profilerRecordingButtonCreated
)
{
return
;
}
const
featureFlagPref
=
"
devtools
.
performance
.
popup
.
feature
-
flag
"
;
const
isPopupFeatureFlagEnabled
=
Services
.
prefs
.
getBoolPref
(
featureFlagPref
)
;
this
.
profilerRecordingButtonCreated
=
true
;
this
.
initializeProfilerWebChannel
(
)
;
if
(
isPopupFeatureFlagEnabled
)
{
lazy
.
ProfilerMenuButton
.
initialize
(
this
.
toggleProfilerKeyShortcuts
)
;
}
else
{
const
enable
=
(
)
=
>
{
lazy
.
ProfilerMenuButton
.
initialize
(
this
.
toggleProfilerKeyShortcuts
)
;
Services
.
prefs
.
removeObserver
(
featureFlagPref
enable
)
;
}
;
Services
.
prefs
.
addObserver
(
featureFlagPref
enable
)
;
}
}
initializeProfilerWebChannel
(
)
{
let
channel
;
const
urlPref
=
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
;
Services
.
prefs
.
addObserver
(
urlPref
registerWebChannel
)
;
registerWebChannel
(
)
;
function
registerWebChannel
(
)
{
if
(
channel
)
{
channel
.
stopListening
(
)
;
}
const
urlForWebChannel
=
Services
.
io
.
newURI
(
validateProfilerWebChannelUrl
(
Services
.
prefs
.
getStringPref
(
urlPref
)
)
)
;
channel
=
new
lazy
.
WebChannel
(
"
profiler
.
firefox
.
com
"
urlForWebChannel
)
;
channel
.
listen
(
(
id
message
target
)
=
>
{
lazy
.
ProfilerPopupBackground
.
handleWebChannelMessage
(
channel
id
message
target
)
;
}
)
;
}
}
hookBrowserToolsMenu
(
window
)
{
const
menu
=
window
.
document
.
getElementById
(
"
browserToolsMenu
"
)
;
const
onPopupShowing
=
(
)
=
>
{
menu
.
removeEventListener
(
"
popupshowing
"
onPopupShowing
)
;
this
.
initDevTools
(
"
SystemMenu
"
)
;
}
;
menu
.
addEventListener
(
"
popupshowing
"
onPopupShowing
)
;
}
isDevToolsUser
(
)
{
const
selfXssCount
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
selfxss
.
count
"
0
)
;
return
selfXssCount
>
0
;
}
hookKeyShortcuts
(
window
)
{
const
doc
=
window
.
document
;
if
(
doc
.
getElementById
(
"
devtoolsKeyset
"
)
)
{
return
;
}
const
keyset
=
doc
.
createXULElement
(
"
keyset
"
)
;
keyset
.
setAttribute
(
"
id
"
"
devtoolsKeyset
"
)
;
this
.
attachKeys
(
doc
lazy
.
KeyShortcuts
keyset
)
;
const
mainKeyset
=
doc
.
getElementById
(
"
mainKeyset
"
)
;
mainKeyset
.
parentNode
.
insertBefore
(
keyset
mainKeyset
)
;
}
attachKeys
(
doc
keyShortcuts
keyset
=
doc
.
getElementById
(
"
devtoolsKeyset
"
)
)
{
const
window
=
doc
.
defaultView
;
for
(
const
key
of
keyShortcuts
)
{
if
(
!
key
.
shortcut
)
{
continue
;
}
const
xulKey
=
this
.
createKey
(
doc
key
(
)
=
>
this
.
onKey
(
window
key
)
)
;
keyset
.
appendChild
(
xulKey
)
;
}
}
removeKeys
(
doc
keyShortcuts
)
{
for
(
const
key
of
keyShortcuts
)
{
const
keyElement
=
doc
.
getElementById
(
this
.
getKeyElementId
(
key
)
)
;
if
(
keyElement
)
{
keyElement
.
remove
(
)
;
}
}
}
toggleProfilerKeyShortcuts
(
isEnabled
)
{
const
profilerKeyShortcuts
=
getProfilerKeyShortcuts
(
)
;
for
(
const
{
document
}
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
const
devtoolsKeyset
=
document
.
getElementById
(
"
devtoolsKeyset
"
)
;
const
mainKeyset
=
document
.
getElementById
(
"
mainKeyset
"
)
;
if
(
!
devtoolsKeyset
|
|
!
mainKeyset
)
{
continue
;
}
const
areProfilerKeysPresent
=
!
!
document
.
getElementById
(
"
key_profilerStartStop
"
)
;
if
(
isEnabled
=
=
=
areProfilerKeysPresent
)
{
continue
;
}
if
(
isEnabled
)
{
this
.
attachKeys
(
document
profilerKeyShortcuts
)
;
}
else
{
this
.
removeKeys
(
document
profilerKeyShortcuts
)
;
}
mainKeyset
.
parentNode
.
insertBefore
(
devtoolsKeyset
mainKeyset
)
;
}
}
async
onKey
(
window
key
)
{
try
{
switch
(
key
.
id
)
{
case
"
profilerStartStop
"
:
{
lazy
.
ProfilerPopupBackground
.
toggleProfiler
(
"
aboutprofiling
"
)
;
return
;
}
case
"
profilerCapture
"
:
{
lazy
.
ProfilerPopupBackground
.
captureProfile
(
"
aboutprofiling
"
)
;
return
;
}
}
const
startTime
=
Cu
.
now
(
)
;
const
require
=
this
.
initDevTools
(
"
KeyShortcut
"
key
)
;
const
{
gDevToolsBrowser
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
await
gDevToolsBrowser
.
onKeyShortcut
(
window
key
startTime
)
;
}
catch
(
e
)
{
console
.
error
(
Exception
while
trigerring
key
{
key
}
:
{
e
}
\
n
{
e
.
stack
}
)
;
}
}
getKeyElementId
(
{
id
toolId
}
)
{
return
"
key_
"
+
(
id
|
|
toolId
)
;
}
createKey
(
doc
key
oncommand
)
{
const
{
shortcut
modifiers
:
mod
}
=
key
;
const
k
=
doc
.
createXULElement
(
"
key
"
)
;
k
.
id
=
this
.
getKeyElementId
(
key
)
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
k
.
setAttribute
(
"
keycode
"
shortcut
)
;
if
(
shortcut
.
match
(
/
^
VK_
\
d
/
)
)
{
k
.
setAttribute
(
"
event
"
"
keydown
"
)
;
}
}
else
{
k
.
setAttribute
(
"
key
"
shortcut
)
;
}
if
(
mod
)
{
k
.
setAttribute
(
"
modifiers
"
mod
)
;
}
k
.
addEventListener
(
"
command
"
oncommand
)
;
return
k
;
}
initDevTools
(
reason
key
=
"
"
)
{
if
(
reason
!
=
=
"
CommandLine
"
)
{
this
.
sendEntryPointTelemetry
(
reason
key
)
;
}
this
.
initialized
=
true
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
return
require
;
}
handleConsoleFlag
(
cmdLine
)
{
const
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
if
(
!
window
)
{
const
require
=
this
.
initDevTools
(
"
CommandLine
"
)
;
const
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
BrowserConsoleManager
.
toggleBrowserConsole
(
)
.
catch
(
console
.
error
)
;
}
else
{
window
.
focus
(
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
async
handleDevToolsFlag
(
window
)
{
const
require
=
this
.
initDevTools
(
"
CommandLine
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
await
gDevTools
.
showToolboxForTab
(
window
.
gBrowser
.
selectedTab
)
;
}
_isRemoteDebuggingEnabled
(
)
{
let
remoteDebuggingEnabled
=
false
;
try
{
remoteDebuggingEnabled
=
kDebuggerPrefs
.
every
(
pref
=
>
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
false
;
}
if
(
!
remoteDebuggingEnabled
)
{
const
errorMsg
=
"
Could
not
run
chrome
debugger
!
You
need
the
following
"
+
"
prefs
to
be
set
to
true
:
"
+
kDebuggerPrefs
.
join
(
"
"
)
;
console
.
error
(
new
Error
(
errorMsg
)
)
;
dump
(
errorMsg
+
"
\
n
"
)
;
}
return
remoteDebuggingEnabled
;
}
handleDebuggerFlag
(
cmdLine
binaryPath
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
devtoolsThreadResumed
=
false
;
const
pauseOnStartup
=
cmdLine
.
handleFlag
(
"
wait
-
for
-
jsdebugger
"
false
)
;
if
(
pauseOnStartup
)
{
const
observe
=
function
(
subject
topic
data
)
{
devtoolsThreadResumed
=
true
;
Services
.
obs
.
removeObserver
(
observe
"
devtools
-
thread
-
ready
"
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
devtools
-
thread
-
ready
"
)
;
}
const
{
BrowserToolboxLauncher
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
jsm
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
env
.
set
(
"
MOZ_BROWSER_TOOLBOX_BINARY
"
binaryPath
)
;
const
browserToolboxLauncherConfig
=
{
}
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
testing
"
false
)
)
{
browserToolboxLauncherConfig
.
forceMultiprocess
=
true
;
}
BrowserToolboxLauncher
.
init
(
browserToolboxLauncherConfig
)
;
if
(
pauseOnStartup
)
{
const
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
"
DevToolsStartup
.
jsm
:
handleDebuggerFlag
"
(
)
=
>
{
return
devtoolsThreadResumed
;
}
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
handleDevToolsServerFlag
(
cmdLine
portOrPath
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
webSocket
=
false
;
const
defaultPort
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
debugger
.
remote
-
port
"
)
;
if
(
portOrPath
=
=
=
true
)
{
webSocket
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
websocket
"
)
;
portOrPath
=
defaultPort
;
}
else
if
(
portOrPath
.
startsWith
(
"
ws
:
"
)
)
{
webSocket
=
true
;
const
port
=
portOrPath
.
slice
(
3
)
;
portOrPath
=
Number
(
port
)
?
port
:
defaultPort
;
}
const
{
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
try
{
const
serverLoader
=
useDistinctSystemPrincipalLoader
(
this
)
;
const
{
DevToolsServer
:
devToolsServer
}
=
serverLoader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
SocketListener
}
=
serverLoader
.
require
(
"
devtools
/
shared
/
security
/
socket
"
)
;
devToolsServer
.
init
(
)
;
devToolsServer
.
keepAlive
=
true
;
devToolsServer
.
registerAllActors
(
)
;
devToolsServer
.
allowChromeProcess
=
true
;
const
socketOptions
=
{
portOrPath
webSocket
}
;
const
listener
=
new
SocketListener
(
devToolsServer
socketOptions
)
;
listener
.
open
(
)
;
dump
(
"
Started
devtools
server
on
"
+
portOrPath
+
"
\
n
"
)
;
const
close
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
close
"
quit
-
application
"
)
;
dump
(
"
Stopped
devtools
server
on
"
+
portOrPath
+
"
\
n
"
)
;
if
(
listener
)
{
listener
.
close
(
)
;
}
if
(
devToolsServer
)
{
devToolsServer
.
destroy
(
)
;
}
releaseDistinctSystemPrincipalLoader
(
this
)
;
}
;
Services
.
obs
.
addObserver
(
close
"
quit
-
application
"
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
start
devtools
server
on
"
+
portOrPath
+
"
:
"
+
e
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
sendEntryPointTelemetry
(
reason
key
=
"
"
)
{
if
(
!
reason
)
{
return
;
}
let
keys
=
"
"
;
if
(
reason
=
=
=
"
KeyShortcut
"
)
{
let
{
modifiers
shortcut
}
=
key
;
modifiers
=
modifiers
.
replace
(
"
"
"
+
"
)
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
shortcut
=
shortcut
.
substr
(
3
)
;
}
keys
=
{
modifiers
}
+
{
shortcut
}
;
}
const
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
this
.
telemetry
.
addEventProperty
(
window
"
open
"
"
tools
"
null
"
shortcut
"
keys
)
;
this
.
telemetry
.
addEventProperty
(
window
"
open
"
"
tools
"
null
"
entrypoint
"
reason
)
;
if
(
this
.
recorded
)
{
return
;
}
try
{
this
.
telemetry
.
getHistogramById
(
"
DEVTOOLS_ENTRY_POINT
"
)
.
add
(
reason
)
;
}
catch
(
e
)
{
dump
(
"
DevTools
telemetry
entry
point
failed
:
"
+
e
+
"
\
n
"
)
;
}
this
.
recorded
=
true
;
}
setSlowScriptDebugHandler
(
)
{
const
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
debugService
.
activationHandler
=
window
=
>
{
const
chromeWindow
=
window
.
browsingContext
.
topChromeWindow
;
let
setupFinished
=
false
;
this
.
slowScriptDebugHandler
(
chromeWindow
.
gBrowser
.
selectedTab
)
.
then
(
(
)
=
>
{
setupFinished
=
true
;
}
)
;
const
utils
=
window
.
windowUtils
;
utils
.
enterModalState
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
devtools
-
browser
.
js
:
debugService
.
activationHandler
"
(
)
=
>
{
return
setupFinished
;
}
)
;
utils
.
leaveModalState
(
)
;
}
;
debugService
.
remoteActivationHandler
=
async
(
browser
callback
)
=
>
{
try
{
const
chromeWindow
=
browser
.
ownerGlobal
;
const
tab
=
chromeWindow
.
gBrowser
.
getTabForBrowser
(
browser
)
;
chromeWindow
.
gBrowser
.
selectedTab
=
tab
;
await
this
.
slowScriptDebugHandler
(
tab
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
callback
.
finishDebuggerStartup
(
)
;
}
;
}
async
slowScriptDebugHandler
(
tab
)
{
const
require
=
this
.
initDevTools
(
"
SlowScript
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
jsdebugger
"
}
)
;
const
threadFront
=
toolbox
.
threadFront
;
switch
(
threadFront
.
state
)
{
case
"
paused
"
:
threadFront
.
resumeThenPause
(
)
;
break
;
case
"
attached
"
:
const
onPaused
=
threadFront
.
once
(
"
paused
"
)
;
threadFront
.
interrupt
(
)
;
await
onPaused
;
threadFront
.
resumeThenPause
(
)
;
break
;
case
"
resuming
"
:
const
onResumed
=
threadFront
.
once
(
"
resumed
"
)
;
await
threadFront
.
interrupt
(
)
;
await
onResumed
;
threadFront
.
resumeThenPause
(
)
;
break
;
default
:
throw
Error
(
"
invalid
thread
front
state
in
slow
script
debug
handler
:
"
+
threadFront
.
state
)
;
}
}
get
KeyShortcuts
(
)
{
return
lazy
.
KeyShortcuts
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
helpInfo
:
"
-
-
jsconsole
Open
the
Browser
Console
.
\
n
"
+
"
-
-
jsdebugger
[
<
path
>
]
Open
the
Browser
Toolbox
.
Defaults
to
the
local
build
\
n
"
+
"
but
can
be
overridden
by
a
firefox
path
.
\
n
"
+
"
-
-
wait
-
for
-
jsdebugger
Spin
event
loop
until
JS
debugger
connects
.
\
n
"
+
"
Enables
debugging
(
some
)
application
startup
code
paths
.
\
n
"
+
"
Only
has
an
effect
when
-
-
jsdebugger
is
also
supplied
.
\
n
"
+
"
-
-
devtools
Open
DevTools
on
initial
load
.
\
n
"
+
"
-
-
start
-
debugger
-
server
[
ws
:
]
[
<
port
>
|
<
path
>
]
Start
the
devtools
server
on
\
n
"
+
"
a
TCP
port
or
Unix
domain
socket
path
.
Defaults
to
TCP
port
\
n
"
+
"
6000
.
Use
WebSocket
protocol
if
ws
:
prefix
is
specified
.
\
n
"
classID
:
Components
.
ID
(
"
{
9e9a9283
-
0ce9
-
4e4a
-
8f1c
-
ba129a032c32
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
]
)
}
;
const
JsonView
=
{
initialized
:
false
initialize
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
mm
.
addMessageListener
(
"
devtools
:
jsonview
:
save
"
this
.
onSave
)
;
}
onSave
(
message
)
{
const
browser
=
message
.
target
;
const
chrome
=
browser
.
ownerGlobal
;
if
(
message
.
data
=
=
=
null
)
{
chrome
.
saveBrowser
(
browser
)
;
}
else
{
if
(
!
message
.
data
.
startsWith
(
"
blob
:
null
"
)
|
|
!
browser
.
contentPrincipal
.
isNullPrincipal
)
{
Cu
.
reportError
(
"
Got
invalid
request
to
save
JSON
data
"
)
;
return
;
}
const
persistable
=
browser
.
frameLoader
;
persistable
.
startPersistence
(
null
{
onDocumentReady
(
doc
)
{
const
uri
=
chrome
.
makeURI
(
doc
.
documentURI
doc
.
characterSet
)
;
const
filename
=
chrome
.
getDefaultFileName
(
undefined
uri
doc
null
)
;
chrome
.
internalSave
(
message
.
data
null
null
filename
null
doc
.
contentType
false
null
null
null
doc
.
cookieJarSettings
null
false
null
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
onError
(
status
)
{
throw
new
Error
(
"
JSON
Viewer
'
s
onSave
failed
in
startPersistence
"
)
;
}
}
)
;
}
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
DevToolsStartup
"
"
validateProfilerWebChannelUrl
"
]
;
