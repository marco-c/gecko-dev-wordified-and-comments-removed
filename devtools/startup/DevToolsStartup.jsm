"
use
strict
"
;
const
kDebuggerPrefs
=
[
"
devtools
.
debugger
.
remote
-
enabled
"
"
devtools
.
chrome
.
enabled
"
]
;
const
DEVTOOLS_ENABLED_PREF
=
"
devtools
.
enabled
"
;
const
DEVTOOLS_F12_DISABLED_PREF
=
"
devtools
.
experiment
.
f12
.
shortcut_disabled
"
;
const
DEVTOOLS_POLICY_DISABLED_PREF
=
"
devtools
.
policy
.
disabled
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableWidgets
"
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ProfilerMenuButton
"
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebChannel
"
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PanelMultiView
"
"
resource
:
/
/
/
modules
/
PanelMultiView
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Telemetry
"
function
(
)
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
return
Telemetry
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
StartupBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
devtools
-
startup
/
locale
/
startup
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
KeyShortcutsBundle
"
function
(
)
{
const
url
=
"
chrome
:
/
/
devtools
-
startup
/
locale
/
key
-
shortcuts
.
properties
"
;
return
Services
.
strings
.
createBundle
(
url
)
;
}
)
;
function
getLocalizedKeyShortcut
(
id
)
{
try
{
return
KeyShortcutsBundle
.
GetStringFromName
(
id
)
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
retrieve
DevTools
localized
shortcut
for
id
"
id
)
;
return
null
;
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
KeyShortcuts
"
function
(
)
{
const
isMac
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
modifiers
=
isMac
?
"
accel
alt
"
:
"
accel
shift
"
;
const
shortcuts
=
[
{
id
:
"
toggleToolbox
"
shortcut
:
getLocalizedKeyShortcut
(
"
toggleToolbox
.
commandkey
"
)
modifiers
}
{
id
:
"
toggleToolboxF12
"
shortcut
:
getLocalizedKeyShortcut
(
"
toggleToolboxF12
.
commandkey
"
)
modifiers
:
"
"
}
{
id
:
"
browserToolbox
"
shortcut
:
getLocalizedKeyShortcut
(
"
browserToolbox
.
commandkey
"
)
modifiers
:
"
accel
alt
shift
"
}
{
id
:
"
browserConsole
"
shortcut
:
getLocalizedKeyShortcut
(
"
browserConsole
.
commandkey
"
)
modifiers
:
"
accel
shift
"
}
{
id
:
"
responsiveDesignMode
"
shortcut
:
getLocalizedKeyShortcut
(
"
responsiveDesignMode
.
commandkey
"
)
modifiers
}
{
toolId
:
"
inspector
"
shortcut
:
getLocalizedKeyShortcut
(
"
inspector
.
commandkey
"
)
modifiers
}
{
toolId
:
"
webconsole
"
shortcut
:
getLocalizedKeyShortcut
(
"
webconsole
.
commandkey
"
)
modifiers
}
{
toolId
:
"
jsdebugger
"
shortcut
:
getLocalizedKeyShortcut
(
"
jsdebugger
.
commandkey2
"
)
modifiers
}
{
toolId
:
"
netmonitor
"
shortcut
:
getLocalizedKeyShortcut
(
"
netmonitor
.
commandkey
"
)
modifiers
}
{
toolId
:
"
styleeditor
"
shortcut
:
getLocalizedKeyShortcut
(
"
styleeditor
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
performance
"
shortcut
:
getLocalizedKeyShortcut
(
"
performance
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
storage
"
shortcut
:
getLocalizedKeyShortcut
(
"
storage
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
dom
"
shortcut
:
getLocalizedKeyShortcut
(
"
dom
.
commandkey
"
)
modifiers
}
{
toolId
:
"
accessibility
"
shortcut
:
getLocalizedKeyShortcut
(
"
accessibilityF12
.
commandkey
"
)
modifiers
:
"
shift
"
}
]
;
if
(
isMac
)
{
shortcuts
.
push
(
{
id
:
"
inspectorMac
"
toolId
:
"
inspector
"
shortcut
:
getLocalizedKeyShortcut
(
"
inspector
.
commandkey
"
)
modifiers
:
"
accel
shift
"
}
)
;
}
if
(
ProfilerMenuButton
.
isInNavbar
(
)
)
{
shortcuts
.
push
(
.
.
.
getProfilerKeyShortcuts
(
)
)
;
}
return
shortcuts
;
}
)
;
function
getProfilerKeyShortcuts
(
)
{
return
[
{
id
:
"
profilerStartStop
"
shortcut
:
getLocalizedKeyShortcut
(
"
profilerStartStop
.
commandkey
"
)
modifiers
:
"
control
shift
"
}
{
id
:
"
profilerCapture
"
shortcut
:
getLocalizedKeyShortcut
(
"
profilerCapture
.
commandkey
"
)
modifiers
:
"
control
shift
"
}
]
;
}
function
validateProfilerWebChannelUrl
(
targetUrl
)
{
const
frontEndUrl
=
"
https
:
/
/
profiler
.
firefox
.
com
"
;
if
(
targetUrl
!
=
=
frontEndUrl
)
{
if
(
targetUrl
=
=
=
"
http
:
/
/
example
.
com
"
|
|
/
^
http
:
\
/
\
/
localhost
:
\
d
+
\
/
?
/
.
test
(
targetUrl
)
|
|
/
^
https
:
\
/
\
/
(
?
:
deploy
-
preview
-
\
d
+
|
main
)
-
-
perf
-
html
\
.
netlify
\
.
(
?
:
com
|
app
)
\
/
?
/
.
test
(
targetUrl
)
)
{
return
targetUrl
;
}
console
.
error
(
The
preference
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
was
set
to
a
+
"
URL
that
is
not
allowed
.
No
WebChannel
messages
will
be
sent
between
the
"
+
browser
and
that
URL
.
Falling
back
to
{
frontEndUrl
}
.
Only
localhost
+
"
and
deploy
previews
URLs
are
allowed
.
"
targetUrl
)
;
}
return
frontEndUrl
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfilerPopupBackground
"
function
(
)
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
background
.
jsm
.
js
"
)
;
}
)
;
function
DevToolsStartup
(
)
{
this
.
onEnabledPrefChanged
=
this
.
onEnabledPrefChanged
.
bind
(
this
)
;
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
toggleProfilerKeyShortcuts
=
this
.
toggleProfilerKeyShortcuts
.
bind
(
this
)
;
}
DevToolsStartup
.
prototype
=
{
initialized
:
false
recorded
:
false
get
telemetry
(
)
{
if
(
!
this
.
_telemetry
)
{
this
.
_telemetry
=
new
Telemetry
(
)
;
this
.
_telemetry
.
setEventRecordingEnabled
(
true
)
;
}
return
this
.
_telemetry
;
}
developerToggleCreated
:
false
profilerRecordingButtonCreated
:
false
isDisabledByPolicy
:
function
(
)
{
return
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_POLICY_DISABLED_PREF
false
)
;
}
handle
:
function
(
cmdLine
)
{
const
flags
=
this
.
readCommandLineFlags
(
cmdLine
)
;
const
isInitialLaunch
=
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
;
if
(
isInitialLaunch
)
{
Services
.
prefs
.
setBoolPref
(
DEVTOOLS_ENABLED_PREF
true
)
;
if
(
this
.
isDevToolsUser
(
)
)
{
Services
.
prefs
.
setBoolPref
(
DEVTOOLS_F12_DISABLED_PREF
false
)
;
}
this
.
devtoolsFlag
=
flags
.
devtools
;
Services
.
obs
.
addObserver
(
this
.
onWindowReady
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
prefs
.
addObserver
(
DEVTOOLS_ENABLED_PREF
this
.
onEnabledPrefChanged
)
;
if
(
!
this
.
isDisabledByPolicy
(
)
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
this
.
hookDeveloperToggle
(
)
;
}
this
.
hookProfilerRecordingButton
(
)
;
}
}
if
(
flags
.
console
)
{
this
.
commandLine
=
true
;
this
.
handleConsoleFlag
(
cmdLine
)
;
}
if
(
flags
.
debugger
)
{
this
.
commandLine
=
true
;
const
binaryPath
=
typeof
flags
.
debugger
=
=
"
string
"
?
flags
.
debugger
:
null
;
this
.
handleDebuggerFlag
(
cmdLine
binaryPath
)
;
}
if
(
flags
.
devToolsServer
)
{
this
.
handleDevToolsServerFlag
(
cmdLine
flags
.
devToolsServer
)
;
}
}
readCommandLineFlags
(
cmdLine
)
{
if
(
this
.
isDisabledByPolicy
(
)
)
{
return
{
console
:
false
debugger
:
false
devtools
:
false
devToolsServer
:
false
}
;
}
const
console
=
cmdLine
.
handleFlag
(
"
jsconsole
"
false
)
;
const
devtools
=
cmdLine
.
handleFlag
(
"
devtools
"
false
)
;
let
devToolsServer
;
try
{
devToolsServer
=
cmdLine
.
handleFlagWithParam
(
"
start
-
debugger
-
server
"
false
)
;
}
catch
(
e
)
{
devToolsServer
=
cmdLine
.
handleFlag
(
"
start
-
debugger
-
server
"
false
)
;
}
let
debuggerFlag
;
try
{
debuggerFlag
=
cmdLine
.
handleFlagWithParam
(
"
jsdebugger
"
false
)
;
}
catch
(
e
)
{
debuggerFlag
=
cmdLine
.
handleFlag
(
"
jsdebugger
"
false
)
;
}
return
{
console
debugger
:
debuggerFlag
devtools
devToolsServer
}
;
}
onWindowReady
(
window
)
{
if
(
this
.
isDisabledByPolicy
(
)
)
{
this
.
removeDevToolsMenus
(
window
)
;
return
;
}
this
.
hookWindow
(
window
)
;
if
(
!
this
.
_firstWindowReadyReceived
)
{
this
.
onFirstWindowReady
(
window
)
;
this
.
_firstWindowReadyReceived
=
true
;
}
JsonView
.
initialize
(
)
;
}
removeDevToolsMenus
(
window
)
{
window
.
document
.
getElementById
(
"
webDeveloperMenu
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
PanelMultiView
.
getViewNode
(
window
.
document
"
appMenu
-
developer
-
button
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
onFirstWindowReady
(
window
)
{
if
(
this
.
devtoolsFlag
)
{
this
.
handleDevToolsFlag
(
window
)
;
if
(
this
.
commandLine
)
{
this
.
sendEntryPointTelemetry
(
"
CommandLine
"
)
;
}
}
}
hookWindow
(
window
)
{
this
.
hookKeyShortcuts
(
window
)
;
this
.
hookDeveloperToggle
(
)
;
this
.
hookProfilerRecordingButton
(
)
;
if
(
!
this
.
initialized
)
{
this
.
hookWebDeveloperMenu
(
window
)
;
}
this
.
createDevToolsEnableMenuItem
(
window
)
;
this
.
updateDevToolsMenuItems
(
window
)
;
}
hookDeveloperToggle
(
)
{
if
(
this
.
developerToggleCreated
)
{
return
;
}
const
id
=
"
developer
-
button
"
;
const
widget
=
CustomizableUI
.
getWidget
(
id
)
;
if
(
widget
&
&
widget
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
{
return
;
}
const
item
=
{
id
:
id
type
:
"
view
"
viewId
:
"
PanelUI
-
developer
"
shortcutId
:
"
key_toggleToolbox
"
tooltiptext
:
"
developer
-
button
.
tooltiptext2
"
onViewShowing
:
event
=
>
{
if
(
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ENABLED_PREF
)
)
{
this
.
initDevTools
(
"
HamburgerMenu
"
)
;
}
const
doc
=
event
.
target
.
ownerDocument
;
const
menu
=
doc
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
const
itemsToDisplay
=
[
.
.
.
menu
.
children
]
;
itemsToDisplay
.
push
(
{
localName
:
"
menuseparator
"
getAttribute
:
(
)
=
>
{
}
}
)
;
itemsToDisplay
.
push
(
doc
.
getElementById
(
"
goOfflineMenuitem
"
)
)
;
const
developerItems
=
PanelMultiView
.
getViewNode
(
doc
"
PanelUI
-
developerItems
"
)
;
CustomizableUI
.
clearSubview
(
developerItems
)
;
CustomizableUI
.
fillSubviewFromMenuItems
(
itemsToDisplay
developerItems
)
;
}
onInit
(
anchor
)
{
this
.
onBeforeCreated
(
anchor
.
ownerDocument
)
;
}
onBeforeCreated
:
doc
=
>
{
this
.
hookKeyShortcuts
(
doc
.
defaultView
)
;
if
(
PanelMultiView
.
getViewNode
(
doc
"
PanelUI
-
developerItems
"
)
)
{
return
;
}
const
view
=
doc
.
createXULElement
(
"
panelview
"
)
;
view
.
id
=
"
PanelUI
-
developerItems
"
;
const
panel
=
doc
.
createXULElement
(
"
vbox
"
)
;
panel
.
setAttribute
(
"
class
"
"
panel
-
subview
-
body
"
)
;
view
.
appendChild
(
panel
)
;
doc
.
getElementById
(
"
PanelUI
-
multiView
"
)
.
appendChild
(
view
)
;
}
}
;
CustomizableUI
.
createWidget
(
item
)
;
CustomizableWidgets
.
push
(
item
)
;
this
.
developerToggleCreated
=
true
;
}
hookProfilerRecordingButton
(
)
{
if
(
this
.
profilerRecordingButtonCreated
)
{
return
;
}
const
featureFlagPref
=
"
devtools
.
performance
.
popup
.
feature
-
flag
"
;
const
isPopupFeatureFlagEnabled
=
Services
.
prefs
.
getBoolPref
(
featureFlagPref
)
;
this
.
profilerRecordingButtonCreated
=
true
;
this
.
initializeProfilerWebChannel
(
)
;
if
(
isPopupFeatureFlagEnabled
)
{
ProfilerMenuButton
.
initialize
(
this
.
toggleProfilerKeyShortcuts
)
;
}
else
{
const
enable
=
(
)
=
>
{
ProfilerMenuButton
.
initialize
(
this
.
toggleProfilerKeyShortcuts
)
;
Services
.
prefs
.
removeObserver
(
featureFlagPref
enable
)
;
}
;
Services
.
prefs
.
addObserver
(
featureFlagPref
enable
)
;
}
}
initializeProfilerWebChannel
(
)
{
let
channel
;
const
urlPref
=
"
devtools
.
performance
.
recording
.
ui
-
base
-
url
"
;
Services
.
prefs
.
addObserver
(
urlPref
registerWebChannel
)
;
registerWebChannel
(
)
;
function
registerWebChannel
(
)
{
if
(
channel
)
{
channel
.
stopListening
(
)
;
}
const
urlForWebChannel
=
Services
.
io
.
newURI
(
validateProfilerWebChannelUrl
(
Services
.
prefs
.
getStringPref
(
urlPref
)
)
)
;
channel
=
new
WebChannel
(
"
profiler
.
firefox
.
com
"
urlForWebChannel
)
;
channel
.
listen
(
(
id
message
target
)
=
>
{
ProfilerPopupBackground
.
handleWebChannelMessage
(
channel
id
message
target
)
;
}
)
;
}
}
hookWebDeveloperMenu
(
window
)
{
const
menu
=
window
.
document
.
getElementById
(
"
webDeveloperMenu
"
)
;
const
onPopupShowing
=
(
)
=
>
{
if
(
!
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ENABLED_PREF
)
)
{
return
;
}
menu
.
removeEventListener
(
"
popupshowing
"
onPopupShowing
)
;
this
.
initDevTools
(
"
SystemMenu
"
)
;
}
;
menu
.
addEventListener
(
"
popupshowing
"
onPopupShowing
)
;
}
createDevToolsEnableMenuItem
(
window
)
{
const
{
document
}
=
window
;
const
item
=
document
.
createXULElement
(
"
menuitem
"
)
;
item
.
id
=
"
enableDeveloperTools
"
;
item
.
setAttribute
(
"
label
"
StartupBundle
.
GetStringFromName
(
"
enableDevTools
.
label
"
)
)
;
item
.
setAttribute
(
"
accesskey
"
StartupBundle
.
GetStringFromName
(
"
enableDevTools
.
accesskey
"
)
)
;
item
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
openInstallPage
(
"
SystemMenu
"
)
;
}
)
;
const
systemMenuItem
=
document
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
systemMenuItem
.
appendChild
(
item
)
;
}
updateDevToolsMenuItems
(
window
)
{
const
item
=
window
.
document
.
getElementById
(
"
enableDeveloperTools
"
)
;
item
.
hidden
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ENABLED_PREF
)
;
}
onEnabledPrefChanged
(
)
{
for
(
const
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
window
.
gBrowserInit
&
&
window
.
gBrowserInit
.
delayedStartupFinished
)
{
this
.
updateDevToolsMenuItems
(
window
)
;
}
}
}
isDevToolsUser
(
)
{
const
selfXssCount
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
selfxss
.
count
"
0
)
;
return
selfXssCount
>
0
;
}
hookKeyShortcuts
(
window
)
{
const
doc
=
window
.
document
;
if
(
doc
.
getElementById
(
"
devtoolsKeyset
"
)
)
{
return
;
}
const
keyset
=
doc
.
createXULElement
(
"
keyset
"
)
;
keyset
.
setAttribute
(
"
id
"
"
devtoolsKeyset
"
)
;
this
.
attachKeys
(
doc
KeyShortcuts
keyset
)
;
const
mainKeyset
=
doc
.
getElementById
(
"
mainKeyset
"
)
;
mainKeyset
.
parentNode
.
insertBefore
(
keyset
mainKeyset
)
;
}
attachKeys
(
doc
keyShortcuts
keyset
=
doc
.
getElementById
(
"
devtoolsKeyset
"
)
)
{
const
window
=
doc
.
defaultView
;
for
(
const
key
of
keyShortcuts
)
{
if
(
!
key
.
shortcut
)
{
continue
;
}
const
xulKey
=
this
.
createKey
(
doc
key
(
)
=
>
this
.
onKey
(
window
key
)
)
;
keyset
.
appendChild
(
xulKey
)
;
}
}
removeKeys
(
doc
keyShortcuts
)
{
for
(
const
key
of
keyShortcuts
)
{
const
keyElement
=
doc
.
getElementById
(
this
.
getKeyElementId
(
key
)
)
;
if
(
keyElement
)
{
keyElement
.
remove
(
)
;
}
}
}
toggleProfilerKeyShortcuts
(
isEnabled
)
{
const
profilerKeyShortcuts
=
getProfilerKeyShortcuts
(
)
;
for
(
const
{
document
}
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
const
devtoolsKeyset
=
document
.
getElementById
(
"
devtoolsKeyset
"
)
;
const
mainKeyset
=
document
.
getElementById
(
"
mainKeyset
"
)
;
if
(
!
devtoolsKeyset
|
|
!
mainKeyset
)
{
continue
;
}
const
areProfilerKeysPresent
=
!
!
document
.
getElementById
(
"
key_profilerStartStop
"
)
;
if
(
isEnabled
=
=
=
areProfilerKeysPresent
)
{
continue
;
}
if
(
isEnabled
)
{
this
.
attachKeys
(
document
profilerKeyShortcuts
)
;
}
else
{
this
.
removeKeys
(
document
profilerKeyShortcuts
)
;
}
mainKeyset
.
parentNode
.
insertBefore
(
devtoolsKeyset
mainKeyset
)
;
}
}
async
onKey
(
window
key
)
{
try
{
switch
(
key
.
id
)
{
case
"
profilerStartStop
"
:
{
ProfilerPopupBackground
.
toggleProfiler
(
"
aboutprofiling
"
)
;
return
;
}
case
"
profilerCapture
"
:
{
ProfilerPopupBackground
.
captureProfile
(
"
aboutprofiling
"
)
;
return
;
}
}
if
(
!
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ENABLED_PREF
)
)
{
const
id
=
key
.
toolId
|
|
key
.
id
;
this
.
openInstallPage
(
"
KeyShortcut
"
id
)
;
}
else
{
const
startTime
=
Cu
.
now
(
)
;
const
require
=
this
.
initDevTools
(
"
KeyShortcut
"
key
)
;
const
{
gDevToolsBrowser
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
await
gDevToolsBrowser
.
onKeyShortcut
(
window
key
startTime
)
;
}
}
catch
(
e
)
{
console
.
error
(
Exception
while
trigerring
key
{
key
}
:
{
e
}
\
n
{
e
.
stack
}
)
;
}
}
getKeyElementId
(
{
id
toolId
}
)
{
return
"
key_
"
+
(
id
|
|
toolId
)
;
}
createKey
(
doc
key
oncommand
)
{
const
{
shortcut
modifiers
:
mod
}
=
key
;
const
k
=
doc
.
createXULElement
(
"
key
"
)
;
k
.
id
=
this
.
getKeyElementId
(
key
)
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
k
.
setAttribute
(
"
keycode
"
shortcut
)
;
if
(
shortcut
.
match
(
/
^
VK_
\
d
/
)
)
{
k
.
setAttribute
(
"
event
"
"
keydown
"
)
;
}
}
else
{
k
.
setAttribute
(
"
key
"
shortcut
)
;
}
if
(
mod
)
{
k
.
setAttribute
(
"
modifiers
"
mod
)
;
}
k
.
setAttribute
(
"
oncommand
"
"
;
"
)
;
k
.
addEventListener
(
"
command
"
oncommand
)
;
return
k
;
}
initDevTools
:
function
(
reason
key
=
"
"
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ENABLED_PREF
)
)
{
this
.
openInstallPage
(
reason
)
;
return
null
;
}
if
(
reason
!
=
=
"
CommandLine
"
)
{
this
.
sendEntryPointTelemetry
(
reason
key
)
;
}
this
.
initialized
=
true
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
return
require
;
}
openInstallPage
:
function
(
reason
keyId
)
{
if
(
this
.
isDisabledByPolicy
(
)
)
{
return
;
}
const
{
gBrowser
}
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
for
(
const
tab
of
gBrowser
.
tabs
)
{
const
browser
=
tab
.
linkedBrowser
;
const
location
=
browser
.
documentURI
?
browser
.
documentURI
.
spec
:
"
"
;
if
(
location
.
startsWith
(
"
about
:
devtools
"
)
&
&
!
location
.
startsWith
(
"
about
:
devtools
-
toolbox
"
)
)
{
gBrowser
.
selectedTab
=
tab
;
return
;
}
}
let
url
=
"
about
:
devtools
"
;
const
params
=
[
]
;
if
(
reason
)
{
params
.
push
(
"
reason
=
"
+
encodeURIComponent
(
reason
)
)
;
}
const
selectedBrowser
=
gBrowser
.
selectedBrowser
;
if
(
selectedBrowser
)
{
params
.
push
(
"
tabid
=
"
+
selectedBrowser
.
outerWindowID
)
;
}
if
(
keyId
)
{
params
.
push
(
"
keyid
=
"
+
keyId
)
;
}
if
(
params
.
length
>
0
)
{
url
+
=
"
?
"
+
params
.
join
(
"
&
"
)
;
}
gBrowser
.
selectedTab
=
gBrowser
.
addTrustedTab
(
url
{
relatedToCurrent
:
true
}
)
;
}
handleConsoleFlag
:
function
(
cmdLine
)
{
const
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
if
(
!
window
)
{
const
require
=
this
.
initDevTools
(
"
CommandLine
"
)
;
const
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
BrowserConsoleManager
.
toggleBrowserConsole
(
)
.
catch
(
console
.
error
)
;
}
else
{
window
.
focus
(
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
handleDevToolsFlag
:
async
function
(
window
)
{
const
require
=
this
.
initDevTools
(
"
CommandLine
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
target
=
await
TargetFactory
.
forTab
(
window
.
gBrowser
.
selectedTab
)
;
gDevTools
.
showToolbox
(
target
)
;
}
_isRemoteDebuggingEnabled
(
)
{
let
remoteDebuggingEnabled
=
false
;
try
{
remoteDebuggingEnabled
=
kDebuggerPrefs
.
every
(
pref
=
>
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
false
;
}
if
(
!
remoteDebuggingEnabled
)
{
const
errorMsg
=
"
Could
not
run
chrome
debugger
!
You
need
the
following
"
+
"
prefs
to
be
set
to
true
:
"
+
kDebuggerPrefs
.
join
(
"
"
)
;
console
.
error
(
new
Error
(
errorMsg
)
)
;
dump
(
errorMsg
+
"
\
n
"
)
;
}
return
remoteDebuggingEnabled
;
}
handleDebuggerFlag
:
function
(
cmdLine
binaryPath
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
devtoolsThreadResumed
=
false
;
const
pauseOnStartup
=
cmdLine
.
handleFlag
(
"
wait
-
for
-
jsdebugger
"
false
)
;
if
(
pauseOnStartup
)
{
const
observe
=
function
(
subject
topic
data
)
{
devtoolsThreadResumed
=
true
;
Services
.
obs
.
removeObserver
(
observe
"
devtools
-
thread
-
resumed
"
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
devtools
-
thread
-
resumed
"
)
;
}
const
{
BrowserToolboxLauncher
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
jsm
"
)
;
BrowserToolboxLauncher
.
init
(
null
null
null
binaryPath
)
;
if
(
pauseOnStartup
)
{
const
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
(
)
=
>
{
return
devtoolsThreadResumed
;
}
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
handleDevToolsServerFlag
:
function
(
cmdLine
portOrPath
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
webSocket
=
false
;
const
defaultPort
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
debugger
.
remote
-
port
"
)
;
if
(
portOrPath
=
=
=
true
)
{
webSocket
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
websocket
"
)
;
portOrPath
=
defaultPort
;
}
else
if
(
portOrPath
.
startsWith
(
"
ws
:
"
)
)
{
webSocket
=
true
;
const
port
=
portOrPath
.
slice
(
3
)
;
portOrPath
=
Number
(
port
)
?
port
:
defaultPort
;
}
const
{
DevToolsLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
try
{
const
serverLoader
=
new
DevToolsLoader
(
{
invisibleToDebugger
:
true
}
)
;
const
{
DevToolsServer
:
devToolsServer
}
=
serverLoader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
SocketListener
}
=
serverLoader
.
require
(
"
devtools
/
shared
/
security
/
socket
"
)
;
devToolsServer
.
init
(
)
;
devToolsServer
.
registerAllActors
(
)
;
devToolsServer
.
allowChromeProcess
=
true
;
const
socketOptions
=
{
portOrPath
webSocket
}
;
const
listener
=
new
SocketListener
(
devToolsServer
socketOptions
)
;
listener
.
open
(
)
;
dump
(
"
Started
devtools
server
on
"
+
portOrPath
+
"
\
n
"
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
start
devtools
server
on
"
+
portOrPath
+
"
:
"
+
e
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
sendEntryPointTelemetry
(
reason
key
=
"
"
)
{
if
(
!
reason
)
{
return
;
}
let
keys
=
"
"
;
if
(
reason
=
=
=
"
KeyShortcut
"
)
{
let
{
modifiers
shortcut
}
=
key
;
modifiers
=
modifiers
.
replace
(
"
"
"
+
"
)
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
shortcut
=
shortcut
.
substr
(
3
)
;
}
keys
=
{
modifiers
}
+
{
shortcut
}
;
}
const
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
this
.
telemetry
.
addEventProperty
(
window
"
open
"
"
tools
"
null
"
shortcut
"
keys
)
;
this
.
telemetry
.
addEventProperty
(
window
"
open
"
"
tools
"
null
"
entrypoint
"
reason
)
;
if
(
this
.
recorded
)
{
return
;
}
try
{
this
.
telemetry
.
getHistogramById
(
"
DEVTOOLS_ENTRY_POINT
"
)
.
add
(
reason
)
;
}
catch
(
e
)
{
dump
(
"
DevTools
telemetry
entry
point
failed
:
"
+
e
+
"
\
n
"
)
;
}
this
.
recorded
=
true
;
}
get
KeyShortcuts
(
)
{
return
KeyShortcuts
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
helpInfo
:
"
-
-
jsconsole
Open
the
Browser
Console
.
\
n
"
+
"
-
-
jsdebugger
[
<
path
>
]
Open
the
Browser
Toolbox
.
Defaults
to
the
local
build
\
n
"
+
"
but
can
be
overridden
by
a
firefox
path
.
\
n
"
+
"
-
-
wait
-
for
-
jsdebugger
Spin
event
loop
until
JS
debugger
connects
.
\
n
"
+
"
Enables
debugging
(
some
)
application
startup
code
paths
.
\
n
"
+
"
Only
has
an
effect
when
-
-
jsdebugger
is
also
supplied
.
\
n
"
+
"
-
-
devtools
Open
DevTools
on
initial
load
.
\
n
"
+
"
-
-
start
-
debugger
-
server
[
ws
:
]
[
<
port
>
|
<
path
>
]
Start
the
devtools
server
on
\
n
"
+
"
a
TCP
port
or
Unix
domain
socket
path
.
Defaults
to
TCP
port
\
n
"
+
"
6000
.
Use
WebSocket
protocol
if
ws
:
prefix
is
specified
.
\
n
"
classID
:
Components
.
ID
(
"
{
9e9a9283
-
0ce9
-
4e4a
-
8f1c
-
ba129a032c32
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
]
)
}
;
const
JsonView
=
{
initialized
:
false
initialize
:
function
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
mm
.
addMessageListener
(
"
devtools
:
jsonview
:
save
"
this
.
onSave
)
;
}
onSave
:
function
(
message
)
{
const
browser
=
message
.
target
;
const
chrome
=
browser
.
ownerGlobal
;
if
(
message
.
data
=
=
=
null
)
{
chrome
.
saveBrowser
(
browser
)
;
}
else
{
if
(
!
message
.
data
.
startsWith
(
"
blob
:
null
"
)
|
|
!
browser
.
contentPrincipal
.
isNullPrincipal
)
{
Cu
.
reportError
(
"
Got
invalid
request
to
save
JSON
data
"
)
;
return
;
}
const
persistable
=
browser
.
frameLoader
;
persistable
.
startPersistence
(
null
{
onDocumentReady
(
doc
)
{
const
uri
=
chrome
.
makeURI
(
doc
.
documentURI
doc
.
characterSet
)
;
const
filename
=
chrome
.
getDefaultFileName
(
undefined
uri
doc
null
)
;
chrome
.
internalSave
(
message
.
data
null
filename
null
doc
.
contentType
false
null
null
null
doc
.
cookieJarSettings
null
false
null
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
onError
(
status
)
{
throw
new
Error
(
"
JSON
Viewer
'
s
onSave
failed
in
startPersistence
"
)
;
}
}
)
;
}
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
DevToolsStartup
"
"
validateProfilerWebChannelUrl
"
]
;
