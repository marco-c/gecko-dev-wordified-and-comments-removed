"
use
strict
"
;
window
.
addEventListener
(
"
load
"
function
(
)
{
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
REQUEST_TIMEOUT
=
5000
;
const
ABOUTDEVTOOLS_STRINGS
=
"
chrome
:
/
/
devtools
-
startup
/
locale
/
aboutdevtools
.
properties
"
;
const
aboutDevtoolsBundle
=
Services
.
strings
.
createBundle
(
ABOUTDEVTOOLS_STRINGS
)
;
let
emailInput
=
document
.
getElementById
(
"
email
"
)
;
let
newsletterErrors
=
document
.
getElementById
(
"
newsletter
-
errors
"
)
;
let
newsletterForm
=
document
.
getElementById
(
"
newsletter
-
form
"
)
;
let
newsletterPrivacySection
=
document
.
getElementById
(
"
newsletter
-
privacy
"
)
;
let
newsletterThanks
=
document
.
getElementById
(
"
newsletter
-
thanks
"
)
;
function
updateErrorPanel
(
errors
)
{
clearErrorPanel
(
)
;
if
(
!
errors
|
|
errors
.
length
=
=
0
)
{
errors
=
[
aboutDevtoolsBundle
.
GetStringFromName
(
"
newsletter
.
error
.
unknown
"
)
]
;
}
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
error
of
errors
)
{
let
item
=
document
.
createElement
(
"
p
"
)
;
item
.
classList
.
add
(
"
error
"
)
;
item
.
appendChild
(
document
.
createTextNode
(
error
)
)
;
fragment
.
appendChild
(
item
)
;
}
newsletterErrors
.
appendChild
(
fragment
)
;
newsletterErrors
.
classList
.
add
(
"
show
"
)
;
}
function
clearErrorPanel
(
)
{
newsletterErrors
.
classList
.
remove
(
"
show
"
)
;
newsletterErrors
.
innerHTML
=
"
"
;
}
function
onEmailInputFocus
(
)
{
let
container
=
document
.
createElement
(
"
div
"
)
;
container
.
style
.
cssText
=
"
visibility
:
hidden
;
overflow
:
hidden
;
position
:
absolute
"
;
newsletterPrivacySection
.
parentNode
.
appendChild
(
container
)
;
let
clone
=
newsletterPrivacySection
.
cloneNode
(
true
)
;
container
.
appendChild
(
clone
)
;
clone
.
style
.
height
=
"
auto
"
;
let
height
=
clone
.
offsetHeight
;
container
.
remove
(
)
;
newsletterPrivacySection
.
classList
.
add
(
"
animate
"
)
;
newsletterPrivacySection
.
style
.
cssText
=
height
:
{
height
}
px
;
margin
-
bottom
:
0
;
;
}
function
onFormSubmit
(
evt
)
{
evt
.
preventDefault
(
)
;
evt
.
stopPropagation
(
)
;
clearErrorPanel
(
)
;
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
onload
=
function
(
r
)
{
if
(
r
.
target
.
status
>
=
200
&
&
r
.
target
.
status
<
300
)
{
let
{
response
}
=
r
.
target
;
if
(
response
.
success
=
=
=
true
)
{
newsletterForm
.
style
.
display
=
"
none
"
;
newsletterThanks
.
classList
.
add
(
"
show
"
)
;
}
else
{
updateErrorPanel
(
response
.
errors
)
;
}
}
else
{
let
{
status
statusText
}
=
r
.
target
;
let
statusInfo
=
{
status
}
-
{
statusText
}
;
let
error
=
aboutDevtoolsBundle
.
formatStringFromName
(
"
newsletter
.
error
.
common
"
[
statusInfo
]
1
)
;
updateErrorPanel
(
[
error
]
)
;
}
}
;
xhr
.
onerror
=
(
)
=
>
{
updateErrorPanel
(
)
;
}
;
xhr
.
ontimeout
=
(
)
=
>
{
let
error
=
aboutDevtoolsBundle
.
GetStringFromName
(
"
newsletter
.
error
.
timeout
"
)
;
updateErrorPanel
(
[
error
]
)
;
}
;
let
url
=
newsletterForm
.
getAttribute
(
"
action
"
)
;
xhr
.
open
(
"
POST
"
url
true
)
;
xhr
.
setRequestHeader
(
"
Content
-
type
"
"
application
/
x
-
www
-
form
-
urlencoded
"
)
;
xhr
.
setRequestHeader
(
"
X
-
Requested
-
With
"
"
XMLHttpRequest
"
)
;
xhr
.
timeout
=
REQUEST_TIMEOUT
;
xhr
.
responseType
=
"
json
"
;
let
formData
=
new
FormData
(
newsletterForm
)
;
formData
.
append
(
"
source_url
"
document
.
location
.
href
)
;
let
params
=
new
URLSearchParams
(
formData
)
;
xhr
.
send
(
params
.
toString
(
)
)
;
}
newsletterForm
.
addEventListener
(
"
submit
"
onFormSubmit
)
;
emailInput
.
addEventListener
(
"
focus
"
onEmailInputFocus
)
;
}
{
once
:
true
}
)
;
