#
include
"
src
/
utils
/
SkFloatToDecimal
.
h
"
#
include
<
cfloat
>
#
include
<
climits
>
#
include
<
cmath
>
#
include
"
include
/
core
/
SkTypes
.
h
"
static
double
pow_by_squaring
(
double
value
double
base
int
e
)
{
SkASSERT
(
e
>
0
)
;
while
(
true
)
{
if
(
e
&
1
)
{
value
*
=
base
;
}
e
>
>
=
1
;
if
(
0
=
=
e
)
{
return
value
;
}
base
*
=
base
;
}
}
static
double
pow10
(
int
e
)
{
switch
(
e
)
{
case
0
:
return
1
.
0
;
case
1
:
return
10
.
0
;
case
2
:
return
100
.
0
;
case
3
:
return
1e
+
03
;
case
4
:
return
1e
+
04
;
case
5
:
return
1e
+
05
;
case
6
:
return
1e
+
06
;
case
7
:
return
1e
+
07
;
case
8
:
return
1e
+
08
;
case
9
:
return
1e
+
09
;
case
10
:
return
1e
+
10
;
case
11
:
return
1e
+
11
;
case
12
:
return
1e
+
12
;
case
13
:
return
1e
+
13
;
case
14
:
return
1e
+
14
;
case
15
:
return
1e
+
15
;
default
:
if
(
e
>
15
)
{
return
pow_by_squaring
(
1e
+
15
10
.
0
e
-
15
)
;
}
else
{
SkASSERT
(
e
<
0
)
;
return
pow_by_squaring
(
1
.
0
0
.
1
-
e
)
;
}
}
}
unsigned
SkFloatToDecimal
(
float
value
char
output
[
kMaximumSkFloatToDecimalLength
]
)
{
static_assert
(
kMaximumSkFloatToDecimalLength
=
=
49
"
"
)
;
static_assert
(
kMaximumSkFloatToDecimalLength
=
=
3
+
9
-
FLT_MIN_10_EXP
"
"
)
;
char
*
output_ptr
=
&
output
[
0
]
;
const
char
*
const
end
=
&
output
[
kMaximumSkFloatToDecimalLength
-
1
]
;
if
(
value
=
=
INFINITY
)
{
value
=
FLT_MAX
;
}
if
(
value
=
=
-
INFINITY
)
{
value
=
-
FLT_MAX
;
}
if
(
!
std
:
:
isfinite
(
value
)
|
|
value
=
=
0
.
0f
)
{
*
output_ptr
+
+
=
'
0
'
;
*
output_ptr
=
'
\
0
'
;
return
static_cast
<
unsigned
>
(
output_ptr
-
output
)
;
}
if
(
value
<
0
.
0
)
{
*
output_ptr
+
+
=
'
-
'
;
value
=
-
value
;
}
SkASSERT
(
value
>
=
0
.
0f
)
;
int
binaryExponent
;
(
void
)
std
:
:
frexp
(
value
&
binaryExponent
)
;
static
const
double
kLog2
=
0
.
3010299956639812
;
int
decimalExponent
=
static_cast
<
int
>
(
std
:
:
floor
(
kLog2
*
binaryExponent
)
)
;
int
decimalShift
=
decimalExponent
-
8
;
double
power
=
pow10
(
-
decimalShift
)
;
SkASSERT
(
value
*
power
<
=
(
double
)
INT_MAX
)
;
int
d
=
static_cast
<
int
>
(
value
*
power
+
0
.
5
)
;
SkASSERT
(
d
<
=
999999999
)
;
if
(
d
>
167772159
)
{
decimalShift
=
decimalExponent
-
7
;
d
=
static_cast
<
int
>
(
value
*
(
power
*
0
.
1
)
+
0
.
5
)
;
SkASSERT
(
d
<
=
99999999
)
;
}
while
(
d
%
10
=
=
0
)
{
d
/
=
10
;
+
+
decimalShift
;
}
SkASSERT
(
d
>
0
)
;
unsigned
char
buffer
[
9
]
;
int
bufferIndex
=
0
;
do
{
buffer
[
bufferIndex
+
+
]
=
d
%
10
;
d
/
=
10
;
}
while
(
d
!
=
0
)
;
SkASSERT
(
bufferIndex
<
=
(
int
)
sizeof
(
buffer
)
&
&
bufferIndex
>
0
)
;
if
(
decimalShift
>
=
0
)
{
do
{
-
-
bufferIndex
;
*
output_ptr
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
}
while
(
bufferIndex
)
;
for
(
int
i
=
0
;
i
<
decimalShift
;
+
+
i
)
{
*
output_ptr
+
+
=
'
0
'
;
}
}
else
{
int
placesBeforeDecimal
=
bufferIndex
+
decimalShift
;
if
(
placesBeforeDecimal
>
0
)
{
while
(
placesBeforeDecimal
-
-
>
0
)
{
-
-
bufferIndex
;
*
output_ptr
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
}
*
output_ptr
+
+
=
'
.
'
;
}
else
{
*
output_ptr
+
+
=
'
.
'
;
int
placesAfterDecimal
=
-
placesBeforeDecimal
;
while
(
placesAfterDecimal
-
-
>
0
)
{
*
output_ptr
+
+
=
'
0
'
;
}
}
while
(
bufferIndex
>
0
)
{
-
-
bufferIndex
;
*
output_ptr
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
if
(
output_ptr
=
=
end
)
{
break
;
}
}
}
SkASSERT
(
output_ptr
<
=
end
)
;
*
output_ptr
=
'
\
0
'
;
return
static_cast
<
unsigned
>
(
output_ptr
-
output
)
;
}
