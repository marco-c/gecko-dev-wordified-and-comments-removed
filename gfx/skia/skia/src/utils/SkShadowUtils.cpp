#
include
"
include
/
utils
/
SkShadowUtils
.
h
"
#
include
"
include
/
core
/
SkBlendMode
.
h
"
#
include
"
include
/
core
/
SkBlender
.
h
"
#
include
"
include
/
core
/
SkBlurTypes
.
h
"
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkColorFilter
.
h
"
#
include
"
include
/
core
/
SkMaskFilter
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkVertices
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkRandom
.
h
"
#
include
"
src
/
core
/
SkBlurMask
.
h
"
#
include
"
src
/
core
/
SkColorFilterPriv
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkDrawShadowInfo
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
core
/
SkResourceCache
.
h
"
#
include
"
src
/
core
/
SkVerticesPriv
.
h
"
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
#
include
"
src
/
utils
/
SkShadowTessellator
.
h
"
#
endif
#
if
defined
(
SK_GANESH
)
#
include
"
src
/
gpu
/
ganesh
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
endif
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
new
>
#
include
<
utility
>
using
namespace
skia_private
;
class
SkRRect
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
namespace
{
uint64_t
resource_cache_shared_id
(
)
{
return
0x2020776f64616873llu
;
}
struct
AmbientVerticesFactory
{
SkScalar
fOccluderHeight
=
SK_ScalarNaN
;
bool
fTransparent
;
SkVector
fOffset
;
bool
isCompatible
(
const
AmbientVerticesFactory
&
that
SkVector
*
translate
)
const
{
if
(
fOccluderHeight
!
=
that
.
fOccluderHeight
|
|
fTransparent
!
=
that
.
fTransparent
)
{
return
false
;
}
*
translate
=
that
.
fOffset
;
return
true
;
}
sk_sp
<
SkVertices
>
makeVertices
(
const
SkPath
&
path
const
SkMatrix
&
ctm
SkVector
*
translate
)
const
{
SkPoint3
zParams
=
SkPoint3
:
:
Make
(
0
0
fOccluderHeight
)
;
SkMatrix
noTrans
(
ctm
)
;
if
(
!
ctm
.
hasPerspective
(
)
)
{
noTrans
[
SkMatrix
:
:
kMTransX
]
=
0
;
noTrans
[
SkMatrix
:
:
kMTransY
]
=
0
;
}
*
translate
=
fOffset
;
return
SkShadowTessellator
:
:
MakeAmbient
(
path
noTrans
zParams
fTransparent
)
;
}
}
;
struct
SpotVerticesFactory
{
enum
class
OccluderType
{
kPointTransparent
kPointOpaquePartialUmbra
kPointOpaqueNoUmbra
kDirectional
kDirectionalTransparent
}
;
SkVector
fOffset
;
SkPoint
fLocalCenter
;
SkScalar
fOccluderHeight
=
SK_ScalarNaN
;
SkPoint3
fDevLightPos
;
SkScalar
fLightRadius
;
OccluderType
fOccluderType
;
bool
isCompatible
(
const
SpotVerticesFactory
&
that
SkVector
*
translate
)
const
{
if
(
fOccluderHeight
!
=
that
.
fOccluderHeight
|
|
fDevLightPos
.
fZ
!
=
that
.
fDevLightPos
.
fZ
|
|
fLightRadius
!
=
that
.
fLightRadius
|
|
fOccluderType
!
=
that
.
fOccluderType
)
{
return
false
;
}
switch
(
fOccluderType
)
{
case
OccluderType
:
:
kPointTransparent
:
case
OccluderType
:
:
kPointOpaqueNoUmbra
:
*
translate
=
that
.
fOffset
;
return
true
;
case
OccluderType
:
:
kPointOpaquePartialUmbra
:
if
(
fOffset
=
=
that
.
fOffset
)
{
translate
-
>
set
(
0
0
)
;
return
true
;
}
return
false
;
case
OccluderType
:
:
kDirectional
:
case
OccluderType
:
:
kDirectionalTransparent
:
*
translate
=
that
.
fOffset
-
fOffset
;
return
true
;
}
SK_ABORT
(
"
Uninitialized
occluder
type
?
"
)
;
}
sk_sp
<
SkVertices
>
makeVertices
(
const
SkPath
&
path
const
SkMatrix
&
ctm
SkVector
*
translate
)
const
{
bool
transparent
=
fOccluderType
=
=
OccluderType
:
:
kPointTransparent
|
|
fOccluderType
=
=
OccluderType
:
:
kDirectionalTransparent
;
bool
directional
=
fOccluderType
=
=
OccluderType
:
:
kDirectional
|
|
fOccluderType
=
=
OccluderType
:
:
kDirectionalTransparent
;
SkPoint3
zParams
=
SkPoint3
:
:
Make
(
0
0
fOccluderHeight
)
;
if
(
directional
)
{
translate
-
>
set
(
0
0
)
;
return
SkShadowTessellator
:
:
MakeSpot
(
path
ctm
zParams
fDevLightPos
fLightRadius
transparent
true
)
;
}
else
if
(
ctm
.
hasPerspective
(
)
|
|
OccluderType
:
:
kPointOpaquePartialUmbra
=
=
fOccluderType
)
{
translate
-
>
set
(
0
0
)
;
return
SkShadowTessellator
:
:
MakeSpot
(
path
ctm
zParams
fDevLightPos
fLightRadius
transparent
false
)
;
}
else
{
SkMatrix
noTrans
(
ctm
)
;
noTrans
[
SkMatrix
:
:
kMTransX
]
=
0
;
noTrans
[
SkMatrix
:
:
kMTransY
]
=
0
;
SkPoint
devCenter
(
fLocalCenter
)
;
noTrans
.
mapPoints
(
&
devCenter
1
)
;
SkPoint3
centerLightPos
=
SkPoint3
:
:
Make
(
devCenter
.
fX
devCenter
.
fY
fDevLightPos
.
fZ
)
;
*
translate
=
fOffset
;
return
SkShadowTessellator
:
:
MakeSpot
(
path
noTrans
zParams
centerLightPos
fLightRadius
transparent
false
)
;
}
}
}
;
class
CachedTessellations
:
public
SkRefCnt
{
public
:
size_t
size
(
)
const
{
return
fAmbientSet
.
size
(
)
+
fSpotSet
.
size
(
)
;
}
sk_sp
<
SkVertices
>
find
(
const
AmbientVerticesFactory
&
ambient
const
SkMatrix
&
matrix
SkVector
*
translate
)
const
{
return
fAmbientSet
.
find
(
ambient
matrix
translate
)
;
}
sk_sp
<
SkVertices
>
add
(
const
SkPath
&
devPath
const
AmbientVerticesFactory
&
ambient
const
SkMatrix
&
matrix
SkVector
*
translate
)
{
return
fAmbientSet
.
add
(
devPath
ambient
matrix
translate
)
;
}
sk_sp
<
SkVertices
>
find
(
const
SpotVerticesFactory
&
spot
const
SkMatrix
&
matrix
SkVector
*
translate
)
const
{
return
fSpotSet
.
find
(
spot
matrix
translate
)
;
}
sk_sp
<
SkVertices
>
add
(
const
SkPath
&
devPath
const
SpotVerticesFactory
&
spot
const
SkMatrix
&
matrix
SkVector
*
translate
)
{
return
fSpotSet
.
add
(
devPath
spot
matrix
translate
)
;
}
private
:
template
<
typename
FACTORY
int
MAX_ENTRIES
>
class
Set
{
public
:
size_t
size
(
)
const
{
return
fSize
;
}
sk_sp
<
SkVertices
>
find
(
const
FACTORY
&
factory
const
SkMatrix
&
matrix
SkVector
*
translate
)
const
{
for
(
int
i
=
0
;
i
<
MAX_ENTRIES
;
+
+
i
)
{
if
(
fEntries
[
i
]
.
fFactory
.
isCompatible
(
factory
translate
)
)
{
const
SkMatrix
&
m
=
fEntries
[
i
]
.
fMatrix
;
if
(
matrix
.
hasPerspective
(
)
|
|
m
.
hasPerspective
(
)
)
{
if
(
matrix
!
=
fEntries
[
i
]
.
fMatrix
)
{
continue
;
}
}
else
if
(
matrix
.
getScaleX
(
)
!
=
m
.
getScaleX
(
)
|
|
matrix
.
getSkewX
(
)
!
=
m
.
getSkewX
(
)
|
|
matrix
.
getScaleY
(
)
!
=
m
.
getScaleY
(
)
|
|
matrix
.
getSkewY
(
)
!
=
m
.
getSkewY
(
)
)
{
continue
;
}
return
fEntries
[
i
]
.
fVertices
;
}
}
return
nullptr
;
}
sk_sp
<
SkVertices
>
add
(
const
SkPath
&
path
const
FACTORY
&
factory
const
SkMatrix
&
matrix
SkVector
*
translate
)
{
sk_sp
<
SkVertices
>
vertices
=
factory
.
makeVertices
(
path
matrix
translate
)
;
if
(
!
vertices
)
{
return
nullptr
;
}
int
i
;
if
(
fCount
<
MAX_ENTRIES
)
{
i
=
fCount
+
+
;
}
else
{
i
=
fRandom
.
nextULessThan
(
MAX_ENTRIES
)
;
fSize
-
=
fEntries
[
i
]
.
fVertices
-
>
approximateSize
(
)
;
}
fEntries
[
i
]
.
fFactory
=
factory
;
fEntries
[
i
]
.
fVertices
=
vertices
;
fEntries
[
i
]
.
fMatrix
=
matrix
;
fSize
+
=
vertices
-
>
approximateSize
(
)
;
return
vertices
;
}
private
:
struct
Entry
{
FACTORY
fFactory
;
sk_sp
<
SkVertices
>
fVertices
;
SkMatrix
fMatrix
;
}
;
Entry
fEntries
[
MAX_ENTRIES
]
;
int
fCount
=
0
;
size_t
fSize
=
0
;
SkRandom
fRandom
;
}
;
Set
<
AmbientVerticesFactory
4
>
fAmbientSet
;
Set
<
SpotVerticesFactory
4
>
fSpotSet
;
}
;
class
CachedTessellationsRec
:
public
SkResourceCache
:
:
Rec
{
public
:
CachedTessellationsRec
(
const
SkResourceCache
:
:
Key
&
key
sk_sp
<
CachedTessellations
>
tessellations
)
:
fTessellations
(
std
:
:
move
(
tessellations
)
)
{
fKey
.
reset
(
new
uint8_t
[
key
.
size
(
)
]
)
;
memcpy
(
fKey
.
get
(
)
&
key
key
.
size
(
)
)
;
}
const
Key
&
getKey
(
)
const
override
{
return
*
reinterpret_cast
<
SkResourceCache
:
:
Key
*
>
(
fKey
.
get
(
)
)
;
}
size_t
bytesUsed
(
)
const
override
{
return
fTessellations
-
>
size
(
)
;
}
const
char
*
getCategory
(
)
const
override
{
return
"
tessellated
shadow
masks
"
;
}
sk_sp
<
CachedTessellations
>
refTessellations
(
)
const
{
return
fTessellations
;
}
template
<
typename
FACTORY
>
sk_sp
<
SkVertices
>
find
(
const
FACTORY
&
factory
const
SkMatrix
&
matrix
SkVector
*
translate
)
const
{
return
fTessellations
-
>
find
(
factory
matrix
translate
)
;
}
private
:
std
:
:
unique_ptr
<
uint8_t
[
]
>
fKey
;
sk_sp
<
CachedTessellations
>
fTessellations
;
}
;
template
<
typename
FACTORY
>
struct
FindContext
{
FindContext
(
const
SkMatrix
*
viewMatrix
const
FACTORY
*
factory
)
:
fViewMatrix
(
viewMatrix
)
fFactory
(
factory
)
{
}
const
SkMatrix
*
const
fViewMatrix
;
sk_sp
<
SkVertices
>
fVertices
;
SkVector
fTranslate
=
{
0
0
}
;
sk_sp
<
CachedTessellations
>
fTessellationsOnFailure
;
const
FACTORY
*
fFactory
;
}
;
template
<
typename
FACTORY
>
bool
FindVisitor
(
const
SkResourceCache
:
:
Rec
&
baseRec
void
*
ctx
)
{
FindContext
<
FACTORY
>
*
findContext
=
(
FindContext
<
FACTORY
>
*
)
ctx
;
const
CachedTessellationsRec
&
rec
=
static_cast
<
const
CachedTessellationsRec
&
>
(
baseRec
)
;
findContext
-
>
fVertices
=
rec
.
find
(
*
findContext
-
>
fFactory
*
findContext
-
>
fViewMatrix
&
findContext
-
>
fTranslate
)
;
if
(
findContext
-
>
fVertices
)
{
return
true
;
}
findContext
-
>
fTessellationsOnFailure
=
rec
.
refTessellations
(
)
;
return
false
;
}
class
ShadowedPath
{
public
:
ShadowedPath
(
const
SkPath
*
path
const
SkMatrix
*
viewMatrix
)
:
fPath
(
path
)
fViewMatrix
(
viewMatrix
)
#
if
defined
(
SK_GANESH
)
fShapeForKey
(
*
path
GrStyle
:
:
SimpleFill
(
)
)
#
endif
{
}
const
SkPath
&
path
(
)
const
{
return
*
fPath
;
}
const
SkMatrix
&
viewMatrix
(
)
const
{
return
*
fViewMatrix
;
}
#
if
defined
(
SK_GANESH
)
int
keyBytes
(
)
const
{
return
fShapeForKey
.
unstyledKeySize
(
)
*
sizeof
(
uint32_t
)
;
}
void
writeKey
(
void
*
key
)
const
{
fShapeForKey
.
writeUnstyledKey
(
reinterpret_cast
<
uint32_t
*
>
(
key
)
)
;
}
bool
isRRect
(
SkRRect
*
rrect
)
{
return
fShapeForKey
.
asRRect
(
rrect
nullptr
nullptr
nullptr
)
;
}
#
else
int
keyBytes
(
)
const
{
return
-
1
;
}
void
writeKey
(
void
*
key
)
const
{
SK_ABORT
(
"
Should
never
be
called
"
)
;
}
bool
isRRect
(
SkRRect
*
rrect
)
{
return
false
;
}
#
endif
private
:
const
SkPath
*
fPath
;
const
SkMatrix
*
fViewMatrix
;
#
if
defined
(
SK_GANESH
)
GrStyledShape
fShapeForKey
;
#
endif
}
;
static
void
*
kNamespace
;
class
ShadowInvalidator
:
public
SkIDChangeListener
{
public
:
ShadowInvalidator
(
const
SkResourceCache
:
:
Key
&
key
)
{
fKey
.
reset
(
new
uint8_t
[
key
.
size
(
)
]
)
;
memcpy
(
fKey
.
get
(
)
&
key
key
.
size
(
)
)
;
}
private
:
const
SkResourceCache
:
:
Key
&
getKey
(
)
const
{
return
*
reinterpret_cast
<
SkResourceCache
:
:
Key
*
>
(
fKey
.
get
(
)
)
;
}
static
bool
FindVisitor
(
const
SkResourceCache
:
:
Rec
&
void
*
)
{
return
false
;
}
void
changed
(
)
override
{
SkResourceCache
:
:
Find
(
this
-
>
getKey
(
)
ShadowInvalidator
:
:
FindVisitor
nullptr
)
;
}
std
:
:
unique_ptr
<
uint8_t
[
]
>
fKey
;
}
;
template
<
typename
FACTORY
>
bool
draw_shadow
(
const
FACTORY
&
factory
std
:
:
function
<
void
(
const
SkVertices
*
SkBlendMode
const
SkPaint
&
SkScalar
tx
SkScalar
ty
bool
)
>
drawProc
ShadowedPath
&
path
SkColor
color
)
{
FindContext
<
FACTORY
>
context
(
&
path
.
viewMatrix
(
)
&
factory
)
;
SkResourceCache
:
:
Key
*
key
=
nullptr
;
AutoSTArray
<
32
*
4
uint8_t
>
keyStorage
;
int
keyDataBytes
=
path
.
keyBytes
(
)
;
if
(
keyDataBytes
>
=
0
)
{
keyStorage
.
reset
(
keyDataBytes
+
sizeof
(
SkResourceCache
:
:
Key
)
)
;
key
=
new
(
keyStorage
.
begin
(
)
)
SkResourceCache
:
:
Key
(
)
;
path
.
writeKey
(
(
uint32_t
*
)
(
keyStorage
.
begin
(
)
+
sizeof
(
*
key
)
)
)
;
key
-
>
init
(
&
kNamespace
resource_cache_shared_id
(
)
keyDataBytes
)
;
SkResourceCache
:
:
Find
(
*
key
FindVisitor
<
FACTORY
>
&
context
)
;
}
sk_sp
<
SkVertices
>
vertices
;
bool
foundInCache
=
SkToBool
(
context
.
fVertices
)
;
if
(
foundInCache
)
{
vertices
=
std
:
:
move
(
context
.
fVertices
)
;
}
else
{
if
(
key
)
{
sk_sp
<
CachedTessellations
>
tessellations
;
if
(
context
.
fTessellationsOnFailure
)
{
tessellations
=
std
:
:
move
(
context
.
fTessellationsOnFailure
)
;
}
else
{
tessellations
.
reset
(
new
CachedTessellations
(
)
)
;
}
vertices
=
tessellations
-
>
add
(
path
.
path
(
)
factory
path
.
viewMatrix
(
)
&
context
.
fTranslate
)
;
if
(
!
vertices
)
{
return
false
;
}
auto
rec
=
new
CachedTessellationsRec
(
*
key
std
:
:
move
(
tessellations
)
)
;
SkPathPriv
:
:
AddGenIDChangeListener
(
path
.
path
(
)
sk_make_sp
<
ShadowInvalidator
>
(
*
key
)
)
;
SkResourceCache
:
:
Add
(
rec
)
;
}
else
{
vertices
=
factory
.
makeVertices
(
path
.
path
(
)
path
.
viewMatrix
(
)
&
context
.
fTranslate
)
;
if
(
!
vertices
)
{
return
false
;
}
}
}
SkPaint
paint
;
paint
.
setColorFilter
(
SkColorFilters
:
:
Blend
(
color
SkBlendMode
:
:
kModulate
)
-
>
makeComposed
(
SkColorFilterPriv
:
:
MakeGaussian
(
)
)
)
;
drawProc
(
vertices
.
get
(
)
SkBlendMode
:
:
kModulate
paint
context
.
fTranslate
.
fX
context
.
fTranslate
.
fY
path
.
viewMatrix
(
)
.
hasPerspective
(
)
)
;
return
true
;
}
}
static
bool
tilted
(
const
SkPoint3
&
zPlaneParams
)
{
return
!
SkScalarNearlyZero
(
zPlaneParams
.
fX
)
|
|
!
SkScalarNearlyZero
(
zPlaneParams
.
fY
)
;
}
#
endif
void
SkShadowUtils
:
:
ComputeTonalColors
(
SkColor
inAmbientColor
SkColor
inSpotColor
SkColor
*
outAmbientColor
SkColor
*
outSpotColor
)
{
*
outAmbientColor
=
SkColorSetARGB
(
SkColorGetA
(
inAmbientColor
)
0
0
0
)
;
int
spotR
=
SkColorGetR
(
inSpotColor
)
;
int
spotG
=
SkColorGetG
(
inSpotColor
)
;
int
spotB
=
SkColorGetB
(
inSpotColor
)
;
int
max
=
std
:
:
max
(
std
:
:
max
(
spotR
spotG
)
spotB
)
;
int
min
=
std
:
:
min
(
std
:
:
min
(
spotR
spotG
)
spotB
)
;
SkScalar
luminance
=
0
.
5f
*
(
max
+
min
)
/
255
.
f
;
SkScalar
origA
=
SkColorGetA
(
inSpotColor
)
/
255
.
f
;
SkScalar
alphaAdjust
=
(
2
.
6f
+
(
-
2
.
66667f
+
1
.
06667f
*
origA
)
*
origA
)
*
origA
;
SkScalar
colorAlpha
=
(
3
.
544762f
+
(
-
4
.
891428f
+
2
.
3466f
*
luminance
)
*
luminance
)
*
luminance
;
colorAlpha
=
SkTPin
(
alphaAdjust
*
colorAlpha
0
.
0f
1
.
0f
)
;
SkScalar
greyscaleAlpha
=
SkTPin
(
origA
*
(
1
-
0
.
4f
*
luminance
)
0
.
0f
1
.
0f
)
;
SkScalar
colorScale
=
colorAlpha
*
(
SK_Scalar1
-
greyscaleAlpha
)
;
SkScalar
tonalAlpha
=
colorScale
+
greyscaleAlpha
;
SkScalar
unPremulScale
=
colorScale
/
tonalAlpha
;
*
outSpotColor
=
SkColorSetARGB
(
tonalAlpha
*
255
.
999f
unPremulScale
*
spotR
unPremulScale
*
spotG
unPremulScale
*
spotB
)
;
}
static
bool
fill_shadow_rec
(
const
SkPath
&
path
const
SkPoint3
&
zPlaneParams
const
SkPoint3
&
lightPos
SkScalar
lightRadius
SkColor
ambientColor
SkColor
spotColor
uint32_t
flags
const
SkMatrix
&
ctm
SkDrawShadowRec
*
rec
)
{
SkPoint
pt
=
{
lightPos
.
fX
lightPos
.
fY
}
;
if
(
!
SkToBool
(
flags
&
kDirectionalLight_ShadowFlag
)
)
{
SkMatrix
inverse
;
if
(
!
ctm
.
invert
(
&
inverse
)
)
{
return
false
;
}
inverse
.
mapPoints
(
&
pt
1
)
;
}
rec
-
>
fZPlaneParams
=
zPlaneParams
;
rec
-
>
fLightPos
=
{
pt
.
fX
pt
.
fY
lightPos
.
fZ
}
;
rec
-
>
fLightRadius
=
lightRadius
;
rec
-
>
fAmbientColor
=
ambientColor
;
rec
-
>
fSpotColor
=
spotColor
;
rec
-
>
fFlags
=
flags
;
return
true
;
}
void
SkShadowUtils
:
:
DrawShadow
(
SkCanvas
*
canvas
const
SkPath
&
path
const
SkPoint3
&
zPlaneParams
const
SkPoint3
&
lightPos
SkScalar
lightRadius
SkColor
ambientColor
SkColor
spotColor
uint32_t
flags
)
{
SkDrawShadowRec
rec
;
if
(
!
fill_shadow_rec
(
path
zPlaneParams
lightPos
lightRadius
ambientColor
spotColor
flags
canvas
-
>
getTotalMatrix
(
)
&
rec
)
)
{
return
;
}
canvas
-
>
private_draw_shadow_rec
(
path
rec
)
;
}
bool
SkShadowUtils
:
:
GetLocalBounds
(
const
SkMatrix
&
ctm
const
SkPath
&
path
const
SkPoint3
&
zPlaneParams
const
SkPoint3
&
lightPos
SkScalar
lightRadius
uint32_t
flags
SkRect
*
bounds
)
{
SkDrawShadowRec
rec
;
if
(
!
fill_shadow_rec
(
path
zPlaneParams
lightPos
lightRadius
SK_ColorBLACK
SK_ColorBLACK
flags
ctm
&
rec
)
)
{
return
false
;
}
SkDrawShadowMetrics
:
:
GetLocalBounds
(
path
rec
ctm
bounds
)
;
return
true
;
}
static
bool
validate_rec
(
const
SkDrawShadowRec
&
rec
)
{
return
rec
.
fLightPos
.
isFinite
(
)
&
&
rec
.
fZPlaneParams
.
isFinite
(
)
&
&
SkScalarIsFinite
(
rec
.
fLightRadius
)
;
}
void
SkBaseDevice
:
:
drawShadow
(
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
if
(
!
validate_rec
(
rec
)
)
{
return
;
}
SkMatrix
viewMatrix
=
this
-
>
localToDevice
(
)
;
SkAutoDeviceTransformRestore
adr
(
this
SkMatrix
:
:
I
(
)
)
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
auto
drawVertsProc
=
[
this
]
(
const
SkVertices
*
vertices
SkBlendMode
mode
const
SkPaint
&
paint
SkScalar
tx
SkScalar
ty
bool
hasPerspective
)
{
if
(
vertices
-
>
priv
(
)
.
vertexCount
(
)
)
{
SkAutoDeviceTransformRestore
adr
(
this
hasPerspective
?
SkMatrix
:
:
I
(
)
:
this
-
>
localToDevice
(
)
*
SkMatrix
:
:
Translate
(
tx
ty
)
)
;
this
-
>
drawVertices
(
vertices
SkBlender
:
:
Mode
(
mode
)
paint
true
)
;
}
}
;
ShadowedPath
shadowedPath
(
&
path
&
viewMatrix
)
;
bool
tiltZPlane
=
tilted
(
rec
.
fZPlaneParams
)
;
bool
transparent
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kTransparentOccluder_ShadowFlag
)
;
bool
useBlur
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kConcaveBlurOnly_ShadowFlag
)
&
&
!
path
.
isConvex
(
)
;
bool
uncached
=
tiltZPlane
|
|
path
.
isVolatile
(
)
;
#
endif
bool
directional
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kDirectionalLight_ShadowFlag
)
;
SkPoint3
zPlaneParams
=
rec
.
fZPlaneParams
;
SkPoint3
devLightPos
=
rec
.
fLightPos
;
if
(
!
directional
)
{
viewMatrix
.
mapPoints
(
(
SkPoint
*
)
&
devLightPos
.
fX
1
)
;
}
float
lightRadius
=
rec
.
fLightRadius
;
if
(
SkColorGetA
(
rec
.
fAmbientColor
)
>
0
)
{
bool
success
=
false
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
if
(
uncached
&
&
!
useBlur
)
{
sk_sp
<
SkVertices
>
vertices
=
SkShadowTessellator
:
:
MakeAmbient
(
path
viewMatrix
zPlaneParams
transparent
)
;
if
(
vertices
)
{
SkPaint
paint
;
paint
.
setColorFilter
(
SkColorFilters
:
:
Blend
(
rec
.
fAmbientColor
SkBlendMode
:
:
kModulate
)
-
>
makeComposed
(
SkColorFilterPriv
:
:
MakeGaussian
(
)
)
)
;
this
-
>
drawVertices
(
vertices
.
get
(
)
SkBlender
:
:
Mode
(
SkBlendMode
:
:
kModulate
)
paint
true
)
;
success
=
true
;
}
}
if
(
!
success
&
&
!
useBlur
)
{
AmbientVerticesFactory
factory
;
factory
.
fOccluderHeight
=
zPlaneParams
.
fZ
;
factory
.
fTransparent
=
transparent
;
if
(
viewMatrix
.
hasPerspective
(
)
)
{
factory
.
fOffset
.
set
(
0
0
)
;
}
else
{
factory
.
fOffset
.
fX
=
viewMatrix
.
getTranslateX
(
)
;
factory
.
fOffset
.
fY
=
viewMatrix
.
getTranslateY
(
)
;
}
success
=
draw_shadow
(
factory
drawVertsProc
shadowedPath
rec
.
fAmbientColor
)
;
}
#
endif
if
(
!
success
)
{
SkPath
devSpacePath
;
path
.
transform
(
viewMatrix
&
devSpacePath
)
;
devSpacePath
.
setIsVolatile
(
true
)
;
SkScalar
devSpaceOutset
=
SkDrawShadowMetrics
:
:
AmbientBlurRadius
(
zPlaneParams
.
fZ
)
;
SkScalar
oneOverA
=
SkDrawShadowMetrics
:
:
AmbientRecipAlpha
(
zPlaneParams
.
fZ
)
;
SkScalar
blurRadius
=
0
.
5f
*
devSpaceOutset
*
oneOverA
;
SkScalar
strokeWidth
=
0
.
5f
*
(
devSpaceOutset
-
blurRadius
)
;
SkPaint
paint
;
paint
.
setColor
(
rec
.
fAmbientColor
)
;
paint
.
setStrokeWidth
(
strokeWidth
)
;
paint
.
setStyle
(
SkPaint
:
:
kStrokeAndFill_Style
)
;
SkScalar
sigma
=
SkBlurMask
:
:
ConvertRadiusToSigma
(
blurRadius
)
;
bool
respectCTM
=
false
;
paint
.
setMaskFilter
(
SkMaskFilter
:
:
MakeBlur
(
kNormal_SkBlurStyle
sigma
respectCTM
)
)
;
this
-
>
drawPath
(
devSpacePath
paint
)
;
}
}
if
(
SkColorGetA
(
rec
.
fSpotColor
)
>
0
)
{
bool
success
=
false
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
if
(
uncached
&
&
!
useBlur
)
{
sk_sp
<
SkVertices
>
vertices
=
SkShadowTessellator
:
:
MakeSpot
(
path
viewMatrix
zPlaneParams
devLightPos
lightRadius
transparent
directional
)
;
if
(
vertices
)
{
SkPaint
paint
;
paint
.
setColorFilter
(
SkColorFilters
:
:
Blend
(
rec
.
fSpotColor
SkBlendMode
:
:
kModulate
)
-
>
makeComposed
(
SkColorFilterPriv
:
:
MakeGaussian
(
)
)
)
;
this
-
>
drawVertices
(
vertices
.
get
(
)
SkBlender
:
:
Mode
(
SkBlendMode
:
:
kModulate
)
paint
true
)
;
success
=
true
;
}
}
if
(
!
success
&
&
!
useBlur
)
{
SpotVerticesFactory
factory
;
factory
.
fOccluderHeight
=
zPlaneParams
.
fZ
;
factory
.
fDevLightPos
=
devLightPos
;
factory
.
fLightRadius
=
lightRadius
;
SkPoint
center
=
SkPoint
:
:
Make
(
path
.
getBounds
(
)
.
centerX
(
)
path
.
getBounds
(
)
.
centerY
(
)
)
;
factory
.
fLocalCenter
=
center
;
viewMatrix
.
mapPoints
(
&
center
1
)
;
SkScalar
radius
scale
;
if
(
SkToBool
(
rec
.
fFlags
&
kDirectionalLight_ShadowFlag
)
)
{
SkDrawShadowMetrics
:
:
GetDirectionalParams
(
zPlaneParams
.
fZ
devLightPos
.
fX
devLightPos
.
fY
devLightPos
.
fZ
lightRadius
&
radius
&
scale
&
factory
.
fOffset
)
;
}
else
{
SkDrawShadowMetrics
:
:
GetSpotParams
(
zPlaneParams
.
fZ
devLightPos
.
fX
-
center
.
fX
devLightPos
.
fY
-
center
.
fY
devLightPos
.
fZ
lightRadius
&
radius
&
scale
&
factory
.
fOffset
)
;
}
SkRect
devBounds
;
viewMatrix
.
mapRect
(
&
devBounds
path
.
getBounds
(
)
)
;
if
(
transparent
|
|
SkTAbs
(
factory
.
fOffset
.
fX
)
>
0
.
5f
*
devBounds
.
width
(
)
|
|
SkTAbs
(
factory
.
fOffset
.
fY
)
>
0
.
5f
*
devBounds
.
height
(
)
)
{
if
(
directional
)
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kDirectionalTransparent
;
}
else
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kPointTransparent
;
}
}
else
if
(
directional
)
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kDirectional
;
}
else
if
(
factory
.
fOffset
.
length
(
)
*
scale
+
scale
<
radius
)
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kPointOpaqueNoUmbra
;
}
else
if
(
path
.
isConvex
(
)
)
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kPointOpaquePartialUmbra
;
}
else
{
factory
.
fOccluderType
=
SpotVerticesFactory
:
:
OccluderType
:
:
kPointTransparent
;
}
factory
.
fOffset
.
fX
+
=
viewMatrix
.
getTranslateX
(
)
;
factory
.
fOffset
.
fY
+
=
viewMatrix
.
getTranslateY
(
)
;
SkColor
color
=
rec
.
fSpotColor
;
#
ifdef
DEBUG_SHADOW_CHECKS
switch
(
factory
.
fOccluderType
)
{
case
SpotVerticesFactory
:
:
OccluderType
:
:
kPointTransparent
:
color
=
0xFFD2B48C
;
break
;
case
SpotVerticesFactory
:
:
OccluderType
:
:
kPointOpaquePartialUmbra
:
color
=
0xFFFFA500
;
break
;
case
SpotVerticesFactory
:
:
OccluderType
:
:
kPointOpaqueNoUmbra
:
color
=
0xFFE5E500
;
break
;
case
SpotVerticesFactory
:
:
OccluderType
:
:
kDirectional
:
case
SpotVerticesFactory
:
:
OccluderType
:
:
kDirectionalTransparent
:
color
=
0xFF550000
;
break
;
}
#
endif
success
=
draw_shadow
(
factory
drawVertsProc
shadowedPath
color
)
;
}
#
endif
if
(
!
success
)
{
SkMatrix
shadowMatrix
;
SkScalar
radius
;
if
(
!
SkDrawShadowMetrics
:
:
GetSpotShadowTransform
(
devLightPos
lightRadius
viewMatrix
zPlaneParams
path
.
getBounds
(
)
directional
&
shadowMatrix
&
radius
)
)
{
return
;
}
SkAutoDeviceTransformRestore
adr2
(
this
shadowMatrix
)
;
SkPaint
paint
;
paint
.
setColor
(
rec
.
fSpotColor
)
;
SkScalar
sigma
=
SkBlurMask
:
:
ConvertRadiusToSigma
(
radius
)
;
bool
respectCTM
=
false
;
paint
.
setMaskFilter
(
SkMaskFilter
:
:
MakeBlur
(
kNormal_SkBlurStyle
sigma
respectCTM
)
)
;
this
-
>
drawPath
(
path
paint
)
;
}
}
}
