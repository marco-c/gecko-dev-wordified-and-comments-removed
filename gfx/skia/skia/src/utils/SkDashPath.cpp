#
include
"
src
/
utils
/
SkDashPathPriv
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPathBuilder
.
h
"
#
include
"
include
/
core
/
SkPathMeasure
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkPathEffectBase
.
h
"
#
include
"
src
/
core
/
SkPointPriv
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
cstdint
>
static
inline
int
is_even
(
int
x
)
{
return
!
(
x
&
1
)
;
}
static
SkScalar
find_first_interval
(
SkSpan
<
const
SkScalar
>
intervals
SkScalar
phase
size_t
*
index
)
{
for
(
size_t
i
=
0
;
i
<
intervals
.
size
(
)
;
+
+
i
)
{
SkScalar
gap
=
intervals
[
i
]
;
if
(
phase
>
gap
|
|
(
phase
=
=
gap
&
&
gap
)
)
{
phase
-
=
gap
;
}
else
{
*
index
=
i
;
return
gap
-
phase
;
}
}
*
index
=
0
;
return
intervals
[
0
]
;
}
void
SkDashPath
:
:
CalcDashParameters
(
SkScalar
phase
SkSpan
<
const
SkScalar
>
intervals
SkScalar
*
initialDashLength
size_t
*
initialDashIndex
SkScalar
*
intervalLength
SkScalar
*
adjustedPhase
)
{
SkScalar
len
=
0
;
for
(
SkScalar
interval
:
intervals
)
{
len
+
=
interval
;
}
*
intervalLength
=
len
;
if
(
adjustedPhase
)
{
if
(
phase
<
0
)
{
phase
=
-
phase
;
if
(
phase
>
len
)
{
phase
=
SkScalarMod
(
phase
len
)
;
}
phase
=
len
-
phase
;
SkASSERT
(
phase
<
=
len
)
;
if
(
phase
=
=
len
)
{
phase
=
0
;
}
}
else
if
(
phase
>
=
len
)
{
phase
=
SkScalarMod
(
phase
len
)
;
}
*
adjustedPhase
=
phase
;
}
SkASSERT
(
phase
>
=
0
&
&
phase
<
len
)
;
*
initialDashLength
=
find_first_interval
(
intervals
phase
initialDashIndex
)
;
SkASSERT
(
*
initialDashLength
>
=
0
)
;
SkASSERT
(
*
initialDashIndex
<
intervals
.
size
(
)
)
;
}
static
void
outset_for_stroke
(
SkRect
*
rect
const
SkStrokeRec
&
rec
)
{
SkScalar
radius
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
if
(
0
=
=
radius
)
{
radius
=
SK_Scalar1
;
}
if
(
SkPaint
:
:
kMiter_Join
=
=
rec
.
getJoin
(
)
)
{
radius
*
=
rec
.
getMiter
(
)
;
}
rect
-
>
outset
(
radius
radius
)
;
}
static
void
adjust_zero_length_line
(
SkPoint
pts
[
2
]
)
{
SkASSERT
(
pts
[
0
]
=
=
pts
[
1
]
)
;
pts
[
1
]
.
fX
+
=
std
:
:
max
(
1
.
001f
pts
[
1
]
.
fX
)
*
SK_ScalarNearlyZero
;
}
static
bool
clip_line
(
SkPoint
pts
[
2
]
const
SkRect
&
bounds
SkScalar
intervalLength
SkScalar
priorPhase
)
{
SkVector
dxy
=
pts
[
1
]
-
pts
[
0
]
;
if
(
dxy
.
fX
&
&
dxy
.
fY
)
{
return
false
;
}
int
xyOffset
=
SkToBool
(
dxy
.
fY
)
;
SkScalar
minXY
=
(
&
pts
[
0
]
.
fX
)
[
xyOffset
]
;
SkScalar
maxXY
=
(
&
pts
[
1
]
.
fX
)
[
xyOffset
]
;
bool
swapped
=
maxXY
<
minXY
;
if
(
swapped
)
{
using
std
:
:
swap
;
swap
(
minXY
maxXY
)
;
}
SkASSERT
(
minXY
<
=
maxXY
)
;
SkScalar
leftTop
=
(
&
bounds
.
fLeft
)
[
xyOffset
]
;
SkScalar
rightBottom
=
(
&
bounds
.
fRight
)
[
xyOffset
]
;
if
(
maxXY
<
leftTop
|
|
minXY
>
rightBottom
)
{
return
false
;
}
if
(
minXY
<
leftTop
)
{
minXY
=
leftTop
-
SkScalarMod
(
leftTop
-
minXY
intervalLength
)
;
if
(
!
swapped
)
{
minXY
-
=
priorPhase
;
}
}
if
(
maxXY
>
rightBottom
)
{
maxXY
=
rightBottom
+
SkScalarMod
(
maxXY
-
rightBottom
intervalLength
)
;
if
(
swapped
)
{
maxXY
+
=
priorPhase
;
}
}
SkASSERT
(
maxXY
>
=
minXY
)
;
if
(
swapped
)
{
using
std
:
:
swap
;
swap
(
minXY
maxXY
)
;
}
(
&
pts
[
0
]
.
fX
)
[
xyOffset
]
=
minXY
;
(
&
pts
[
1
]
.
fX
)
[
xyOffset
]
=
maxXY
;
if
(
minXY
=
=
maxXY
)
{
adjust_zero_length_line
(
pts
)
;
}
return
true
;
}
static
bool
cull_path
(
const
SkPath
&
srcPath
const
SkStrokeRec
&
rec
const
SkRect
*
cullRect
SkScalar
intervalLength
SkPathBuilder
*
builder
)
{
if
(
!
cullRect
)
{
SkPoint
pts
[
2
]
;
if
(
srcPath
.
isLine
(
pts
)
&
&
pts
[
0
]
=
=
pts
[
1
]
)
{
adjust_zero_length_line
(
pts
)
;
builder
-
>
moveTo
(
pts
[
0
]
)
;
builder
-
>
lineTo
(
pts
[
1
]
)
;
return
true
;
}
return
false
;
}
SkRect
bounds
;
bounds
=
*
cullRect
;
outset_for_stroke
(
&
bounds
rec
)
;
{
SkPoint
pts
[
2
]
;
if
(
srcPath
.
isLine
(
pts
)
)
{
if
(
clip_line
(
pts
bounds
intervalLength
0
)
)
{
builder
-
>
moveTo
(
pts
[
0
]
)
;
builder
-
>
lineTo
(
pts
[
1
]
)
;
return
true
;
}
return
false
;
}
}
if
(
srcPath
.
isRect
(
nullptr
)
)
{
SkPath
:
:
Iter
iter
(
srcPath
false
)
;
std
:
:
optional
<
SkPath
:
:
IterRec
>
it
=
iter
.
next
(
)
;
SkASSERT
(
it
.
has_value
(
)
&
&
it
-
>
fVerb
=
=
SkPathVerb
:
:
kMove
)
;
double
accum
=
0
;
while
(
(
it
=
iter
.
next
(
)
)
&
&
(
it
-
>
fVerb
=
=
SkPathVerb
:
:
kLine
)
)
{
SkVector
v
=
it
-
>
fPoints
[
1
]
-
it
-
>
fPoints
[
0
]
;
SkPoint
pts
[
2
]
=
{
it
-
>
fPoints
[
0
]
it
-
>
fPoints
[
1
]
}
;
if
(
clip_line
(
pts
bounds
intervalLength
std
:
:
fmod
(
accum
intervalLength
)
)
)
{
auto
maybeLast
=
builder
-
>
getLastPt
(
)
;
if
(
!
maybeLast
|
|
*
maybeLast
!
=
pts
[
0
]
)
{
builder
-
>
moveTo
(
pts
[
0
]
)
;
}
builder
-
>
lineTo
(
pts
[
1
]
)
;
}
SkASSERT
(
v
.
fX
=
=
0
|
|
v
.
fY
=
=
0
)
;
accum
+
=
SkScalarAbs
(
v
.
fX
+
v
.
fY
)
;
}
return
!
builder
-
>
isEmpty
(
)
;
}
return
false
;
}
class
SpecialLineRec
{
public
:
bool
init
(
const
SkPath
&
src
SkPathBuilder
*
dst
SkStrokeRec
*
rec
int
intervalCount
SkScalar
intervalLength
)
{
if
(
rec
-
>
isHairlineStyle
(
)
|
|
!
src
.
isLine
(
fPts
)
)
{
return
false
;
}
if
(
SkPaint
:
:
kButt_Cap
!
=
rec
-
>
getCap
(
)
)
{
return
false
;
}
SkScalar
pathLength
=
SkPoint
:
:
Distance
(
fPts
[
0
]
fPts
[
1
]
)
;
fTangent
=
fPts
[
1
]
-
fPts
[
0
]
;
if
(
fTangent
.
isZero
(
)
)
{
return
false
;
}
fPathLength
=
pathLength
;
fTangent
.
scale
(
sk_ieee_float_divide
(
1
.
0f
pathLength
)
)
;
if
(
!
SkIsFinite
(
fTangent
.
fX
fTangent
.
fY
)
)
{
return
false
;
}
SkPointPriv
:
:
RotateCCW
(
fTangent
&
fNormal
)
;
fNormal
.
scale
(
SkScalarHalf
(
rec
-
>
getWidth
(
)
)
)
;
SkScalar
ptCount
=
pathLength
*
intervalCount
/
(
float
)
intervalLength
;
ptCount
=
std
:
:
min
(
ptCount
SkDashPath
:
:
kMaxDashCount
)
;
if
(
SkIsNaN
(
ptCount
)
)
{
return
false
;
}
int
n
=
SkScalarCeilToInt
(
ptCount
)
<
<
2
;
dst
-
>
incReserve
(
n
)
;
rec
-
>
setFillStyle
(
)
;
return
true
;
}
void
addSegment
(
SkScalar
d0
SkScalar
d1
SkPathBuilder
*
path
)
const
{
SkASSERT
(
d0
<
=
fPathLength
)
;
if
(
d1
>
fPathLength
)
{
d1
=
fPathLength
;
}
SkScalar
x0
=
fPts
[
0
]
.
fX
+
fTangent
.
fX
*
d0
;
SkScalar
x1
=
fPts
[
0
]
.
fX
+
fTangent
.
fX
*
d1
;
SkScalar
y0
=
fPts
[
0
]
.
fY
+
fTangent
.
fY
*
d0
;
SkScalar
y1
=
fPts
[
0
]
.
fY
+
fTangent
.
fY
*
d1
;
SkPoint
pts
[
4
]
;
pts
[
0
]
.
set
(
x0
+
fNormal
.
fX
y0
+
fNormal
.
fY
)
;
pts
[
1
]
.
set
(
x1
+
fNormal
.
fX
y1
+
fNormal
.
fY
)
;
pts
[
2
]
.
set
(
x1
-
fNormal
.
fX
y1
-
fNormal
.
fY
)
;
pts
[
3
]
.
set
(
x0
-
fNormal
.
fX
y0
-
fNormal
.
fY
)
;
path
-
>
addPolygon
(
pts
false
)
;
}
private
:
SkPoint
fPts
[
2
]
;
SkVector
fTangent
;
SkVector
fNormal
;
SkScalar
fPathLength
;
}
;
bool
SkDashPath
:
:
InternalFilter
(
SkPathBuilder
*
dst
const
SkPath
&
src
SkStrokeRec
*
rec
const
SkRect
*
cullRect
SkSpan
<
const
SkScalar
>
aIntervals
SkScalar
initialDashLength
int32_t
initialDashIndex
SkScalar
intervalLength
SkScalar
startPhase
StrokeRecApplication
strokeRecApplication
)
{
const
size_t
count
=
aIntervals
.
size
(
)
;
SkASSERT
(
is_even
(
count
)
)
;
SkStrokeRec
:
:
Style
style
=
rec
-
>
getStyle
(
)
;
if
(
SkStrokeRec
:
:
kFill_Style
=
=
style
|
|
SkStrokeRec
:
:
kStrokeAndFill_Style
=
=
style
)
{
return
false
;
}
const
SkScalar
*
intervals
=
aIntervals
.
data
(
)
;
SkScalar
dashCount
=
0
;
SkPathBuilder
builder
;
SkPath
cullPathStorage
;
const
SkPath
*
srcPtr
=
&
src
;
if
(
cull_path
(
src
*
rec
cullRect
intervalLength
&
builder
)
)
{
if
(
src
.
isRect
(
nullptr
)
&
&
src
.
isLastContourClosed
(
)
&
&
is_even
(
initialDashIndex
)
)
{
SkScalar
pathLength
=
SkPathMeasure
(
src
false
rec
-
>
getResScale
(
)
)
.
getLength
(
)
;
SkScalar
endPhase
=
SkScalarMod
(
pathLength
+
startPhase
intervalLength
)
;
size_t
index
=
0
;
while
(
endPhase
>
intervals
[
index
]
)
{
endPhase
-
=
intervals
[
index
+
+
]
;
SkASSERT
(
index
<
=
count
)
;
if
(
index
=
=
count
)
{
endPhase
=
0
;
break
;
}
}
if
(
is_even
(
index
)
=
=
(
endPhase
>
0
)
)
{
SkPoint
midPoint
=
src
.
getPoint
(
0
)
;
int
last
=
src
.
countPoints
(
)
-
1
;
while
(
midPoint
=
=
src
.
getPoint
(
last
)
)
{
-
-
last
;
SkASSERT
(
last
>
=
0
)
;
}
int
next
=
1
;
while
(
midPoint
=
=
src
.
getPoint
(
next
)
)
{
+
+
next
;
SkASSERT
(
next
<
last
)
;
}
SkVector
v
=
midPoint
-
src
.
getPoint
(
last
)
;
const
SkScalar
kTinyOffset
=
SK_ScalarNearlyZero
;
v
*
=
kTinyOffset
;
builder
.
moveTo
(
midPoint
-
v
)
;
builder
.
lineTo
(
midPoint
)
;
v
=
midPoint
-
src
.
getPoint
(
next
)
;
v
*
=
kTinyOffset
;
builder
.
lineTo
(
midPoint
-
v
)
;
}
}
cullPathStorage
=
builder
.
detach
(
)
;
srcPtr
=
&
cullPathStorage
;
}
SpecialLineRec
lineRec
;
bool
specialLine
=
(
StrokeRecApplication
:
:
kAllow
=
=
strokeRecApplication
)
&
&
lineRec
.
init
(
*
srcPtr
dst
rec
count
>
>
1
intervalLength
)
;
SkPathMeasure
meas
(
*
srcPtr
false
rec
-
>
getResScale
(
)
)
;
do
{
bool
skipFirstSegment
=
meas
.
isClosed
(
)
;
bool
addedSegment
=
false
;
SkScalar
length
=
meas
.
getLength
(
)
;
size_t
index
=
initialDashIndex
;
dashCount
+
=
length
*
(
count
>
>
1
)
/
intervalLength
;
if
(
dashCount
>
kMaxDashCount
)
{
dst
-
>
reset
(
)
;
return
false
;
}
double
distance
=
0
;
double
dlen
=
initialDashLength
;
while
(
distance
<
length
)
{
SkASSERT
(
dlen
>
=
0
)
;
addedSegment
=
false
;
if
(
is_even
(
index
)
&
&
!
skipFirstSegment
)
{
addedSegment
=
true
;
if
(
specialLine
)
{
lineRec
.
addSegment
(
SkDoubleToScalar
(
distance
)
SkDoubleToScalar
(
distance
+
dlen
)
dst
)
;
}
else
{
meas
.
getSegment
(
SkDoubleToScalar
(
distance
)
SkDoubleToScalar
(
distance
+
dlen
)
dst
true
)
;
}
}
distance
+
=
dlen
;
skipFirstSegment
=
false
;
index
+
=
1
;
SkASSERT
(
index
<
=
count
)
;
if
(
index
=
=
count
)
{
index
=
0
;
}
dlen
=
intervals
[
index
]
;
}
if
(
meas
.
isClosed
(
)
&
&
is_even
(
initialDashIndex
)
&
&
initialDashLength
>
=
0
)
{
meas
.
getSegment
(
0
initialDashLength
dst
!
addedSegment
)
;
}
}
while
(
meas
.
nextContour
(
)
)
;
return
true
;
}
bool
SkDashPath
:
:
FilterDashPath
(
SkPathBuilder
*
dst
const
SkPath
&
src
SkStrokeRec
*
rec
const
SkRect
*
cullRect
const
SkPathEffectBase
:
:
DashInfo
&
info
)
{
if
(
!
ValidDashPath
(
info
.
fPhase
info
.
fIntervals
)
)
{
return
false
;
}
SkScalar
initialDashLength
=
0
;
size_t
initialDashIndex
=
0
;
SkScalar
intervalLength
=
0
;
CalcDashParameters
(
info
.
fPhase
info
.
fIntervals
&
initialDashLength
&
initialDashIndex
&
intervalLength
)
;
return
InternalFilter
(
dst
src
rec
cullRect
info
.
fIntervals
initialDashLength
initialDashIndex
intervalLength
info
.
fPhase
)
;
}
bool
SkDashPath
:
:
ValidDashPath
(
SkScalar
phase
SkSpan
<
const
SkScalar
>
intervals
)
{
if
(
intervals
.
size
(
)
<
2
|
|
!
SkIsAlign2
(
intervals
.
size
(
)
)
)
{
return
false
;
}
SkScalar
length
=
0
;
for
(
SkScalar
interval
:
intervals
)
{
if
(
interval
<
0
)
{
return
false
;
}
length
+
=
interval
;
}
return
length
>
0
&
&
SkIsFinite
(
phase
length
)
;
}
