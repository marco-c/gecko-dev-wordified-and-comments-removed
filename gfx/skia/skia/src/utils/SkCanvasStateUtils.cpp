#
include
"
include
/
utils
/
SkCanvasStateUtils
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkWriter32
.
h
"
#
include
"
src
/
utils
/
SkCanvasStack
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
enum
RasterConfigs
{
kUnknown_RasterConfig
=
0
kRGB_565_RasterConfig
=
1
kARGB_8888_RasterConfig
=
2
}
;
typedef
int32_t
RasterConfig
;
enum
CanvasBackends
{
kUnknown_CanvasBackend
=
0
kRaster_CanvasBackend
=
1
kGPU_CanvasBackend
=
2
kPDF_CanvasBackend
=
3
}
;
typedef
int32_t
CanvasBackend
;
struct
ClipRect
{
int32_t
left
top
right
bottom
;
}
;
struct
SkMCState
{
float
matrix
[
9
]
;
int32_t
clipRectCount
;
ClipRect
*
clipRects
;
}
;
struct
SkCanvasLayerState
{
CanvasBackend
type
;
int32_t
x
y
;
int32_t
width
;
int32_t
height
;
SkMCState
mcState
;
union
{
struct
{
RasterConfig
config
;
uint64_t
rowBytes
;
void
*
pixels
;
}
raster
;
struct
{
int32_t
textureID
;
}
gpu
;
}
;
}
;
class
SkCanvasState
{
public
:
SkCanvasState
(
int32_t
version
SkCanvas
*
canvas
)
{
SkASSERT
(
canvas
)
;
this
-
>
version
=
version
;
width
=
canvas
-
>
getBaseLayerSize
(
)
.
width
(
)
;
height
=
canvas
-
>
getBaseLayerSize
(
)
.
height
(
)
;
}
int32_t
version
;
int32_t
width
;
int32_t
height
;
int32_t
alignmentPadding
;
}
;
class
SkCanvasState_v1
:
public
SkCanvasState
{
public
:
static
const
int32_t
kVersion
=
1
;
SkCanvasState_v1
(
SkCanvas
*
canvas
)
:
INHERITED
(
kVersion
canvas
)
{
layerCount
=
0
;
layers
=
nullptr
;
mcState
.
clipRectCount
=
0
;
mcState
.
clipRects
=
nullptr
;
originalCanvas
=
canvas
;
}
~
SkCanvasState_v1
(
)
{
for
(
int
i
=
0
;
i
<
layerCount
;
+
+
i
)
{
if
(
layers
[
i
]
.
mcState
.
clipRectCount
>
0
)
{
sk_free
(
layers
[
i
]
.
mcState
.
clipRects
)
;
}
}
if
(
mcState
.
clipRectCount
>
0
)
{
sk_free
(
mcState
.
clipRects
)
;
}
sk_free
(
layers
)
;
}
SkMCState
mcState
;
int32_t
layerCount
;
SkCanvasLayerState
*
layers
;
private
:
SkCanvas
*
originalCanvas
;
using
INHERITED
=
SkCanvasState
;
}
;
static
void
setup_MC_state
(
SkMCState
*
state
const
SkMatrix
&
matrix
const
SkIRect
&
clip
)
{
state
-
>
clipRectCount
=
0
;
for
(
int
i
=
0
;
i
<
9
;
i
+
+
)
{
state
-
>
matrix
[
i
]
=
matrix
.
get
(
i
)
;
}
SkSWriter32
<
sizeof
(
ClipRect
)
>
clipWriter
;
if
(
!
clip
.
isEmpty
(
)
)
{
state
-
>
clipRectCount
=
1
;
state
-
>
clipRects
=
(
ClipRect
*
)
sk_malloc_throw
(
sizeof
(
ClipRect
)
)
;
state
-
>
clipRects
-
>
left
=
clip
.
fLeft
;
state
-
>
clipRects
-
>
top
=
clip
.
fTop
;
state
-
>
clipRects
-
>
right
=
clip
.
fRight
;
state
-
>
clipRects
-
>
bottom
=
clip
.
fBottom
;
}
}
SkCanvasState
*
SkCanvasStateUtils
:
:
CaptureCanvasState
(
SkCanvas
*
canvas
)
{
SkASSERT
(
canvas
)
;
if
(
canvas
-
>
androidFramework_isClipAA
(
)
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkCanvasState_v1
>
canvasState
(
new
SkCanvasState_v1
(
canvas
)
)
;
setup_MC_state
(
&
canvasState
-
>
mcState
canvas
-
>
getTotalMatrix
(
)
canvas
-
>
getDeviceClipBounds
(
)
)
;
SkBaseDevice
*
device
=
canvas
-
>
topDevice
(
)
;
SkASSERT
(
device
)
;
SkSWriter32
<
sizeof
(
SkCanvasLayerState
)
>
layerWriter
;
SkPixmap
pmap
;
if
(
!
device
-
>
accessPixels
(
&
pmap
)
|
|
0
=
=
pmap
.
width
(
)
|
|
0
=
=
pmap
.
height
(
)
)
{
return
nullptr
;
}
if
(
!
device
-
>
isPixelAlignedToGlobal
(
)
)
{
return
nullptr
;
}
SkIPoint
origin
=
device
-
>
getOrigin
(
)
;
SkCanvasLayerState
*
layerState
=
(
SkCanvasLayerState
*
)
layerWriter
.
reserve
(
sizeof
(
SkCanvasLayerState
)
)
;
layerState
-
>
type
=
kRaster_CanvasBackend
;
layerState
-
>
x
=
origin
.
x
(
)
;
layerState
-
>
y
=
origin
.
y
(
)
;
layerState
-
>
width
=
pmap
.
width
(
)
;
layerState
-
>
height
=
pmap
.
height
(
)
;
switch
(
pmap
.
colorType
(
)
)
{
case
kN32_SkColorType
:
layerState
-
>
raster
.
config
=
kARGB_8888_RasterConfig
;
break
;
case
kRGB_565_SkColorType
:
layerState
-
>
raster
.
config
=
kRGB_565_RasterConfig
;
break
;
default
:
return
nullptr
;
}
layerState
-
>
raster
.
rowBytes
=
pmap
.
rowBytes
(
)
;
layerState
-
>
raster
.
pixels
=
pmap
.
writable_addr
(
)
;
setup_MC_state
(
&
layerState
-
>
mcState
device
-
>
localToDevice
(
)
device
-
>
devClipBounds
(
)
)
;
SkASSERT
(
layerWriter
.
bytesWritten
(
)
=
=
sizeof
(
SkCanvasLayerState
)
)
;
canvasState
-
>
layerCount
=
1
;
canvasState
-
>
layers
=
(
SkCanvasLayerState
*
)
sk_malloc_throw
(
layerWriter
.
bytesWritten
(
)
)
;
layerWriter
.
flatten
(
canvasState
-
>
layers
)
;
return
canvasState
.
release
(
)
;
}
static
void
setup_canvas_from_MC_state
(
const
SkMCState
&
state
SkCanvas
*
canvas
)
{
SkMatrix
matrix
;
for
(
int
i
=
0
;
i
<
9
;
i
+
+
)
{
matrix
.
set
(
i
state
.
matrix
[
i
]
)
;
}
SkIRect
bounds
=
SkIRect
:
:
MakeEmpty
(
)
;
if
(
state
.
clipRectCount
>
0
)
{
bounds
.
setLTRB
(
state
.
clipRects
[
0
]
.
left
state
.
clipRects
[
0
]
.
top
state
.
clipRects
[
0
]
.
right
state
.
clipRects
[
0
]
.
bottom
)
;
for
(
int
i
=
1
;
i
<
state
.
clipRectCount
;
+
+
i
)
{
bounds
.
join
(
{
state
.
clipRects
[
i
]
.
left
state
.
clipRects
[
i
]
.
top
state
.
clipRects
[
i
]
.
right
state
.
clipRects
[
i
]
.
bottom
}
)
;
}
}
canvas
-
>
clipRect
(
SkRect
:
:
Make
(
bounds
)
)
;
canvas
-
>
concat
(
matrix
)
;
}
static
std
:
:
unique_ptr
<
SkCanvas
>
make_canvas_from_canvas_layer
(
const
SkCanvasLayerState
&
layerState
)
{
SkASSERT
(
kRaster_CanvasBackend
=
=
layerState
.
type
)
;
SkBitmap
bitmap
;
SkColorType
colorType
=
layerState
.
raster
.
config
=
=
kARGB_8888_RasterConfig
?
kN32_SkColorType
:
layerState
.
raster
.
config
=
=
kRGB_565_RasterConfig
?
kRGB_565_SkColorType
:
kUnknown_SkColorType
;
if
(
colorType
=
=
kUnknown_SkColorType
)
{
return
nullptr
;
}
bitmap
.
installPixels
(
SkImageInfo
:
:
Make
(
layerState
.
width
layerState
.
height
colorType
kPremul_SkAlphaType
)
layerState
.
raster
.
pixels
(
size_t
)
layerState
.
raster
.
rowBytes
)
;
SkASSERT
(
!
bitmap
.
empty
(
)
)
;
SkASSERT
(
!
bitmap
.
isNull
(
)
)
;
std
:
:
unique_ptr
<
SkCanvas
>
canvas
(
new
SkCanvas
(
bitmap
)
)
;
setup_canvas_from_MC_state
(
layerState
.
mcState
canvas
.
get
(
)
)
;
return
canvas
;
}
std
:
:
unique_ptr
<
SkCanvas
>
SkCanvasStateUtils
:
:
MakeFromCanvasState
(
const
SkCanvasState
*
state
)
{
SkASSERT
(
state
)
;
SkASSERT
(
SkCanvasState_v1
:
:
kVersion
=
=
state
-
>
version
)
;
const
SkCanvasState_v1
*
state_v1
=
static_cast
<
const
SkCanvasState_v1
*
>
(
state
)
;
if
(
state_v1
-
>
layerCount
<
1
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkCanvasStack
>
canvas
(
new
SkCanvasStack
(
state
-
>
width
state
-
>
height
)
)
;
setup_canvas_from_MC_state
(
state_v1
-
>
mcState
canvas
.
get
(
)
)
;
for
(
int
i
=
state_v1
-
>
layerCount
-
1
;
i
>
=
0
;
-
-
i
)
{
std
:
:
unique_ptr
<
SkCanvas
>
canvasLayer
=
make_canvas_from_canvas_layer
(
state_v1
-
>
layers
[
i
]
)
;
if
(
!
canvasLayer
)
{
return
nullptr
;
}
canvas
-
>
pushCanvas
(
std
:
:
move
(
canvasLayer
)
SkIPoint
:
:
Make
(
state_v1
-
>
layers
[
i
]
.
x
state_v1
-
>
layers
[
i
]
.
y
)
)
;
}
return
std
:
:
move
(
canvas
)
;
}
void
SkCanvasStateUtils
:
:
ReleaseCanvasState
(
SkCanvasState
*
state
)
{
SkASSERT
(
!
state
|
|
SkCanvasState_v1
:
:
kVersion
=
=
state
-
>
version
)
;
delete
static_cast
<
SkCanvasState_v1
*
>
(
state
)
;
}
