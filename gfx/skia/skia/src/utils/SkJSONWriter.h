#
ifndef
SkJSONWriter_DEFINED
#
define
SkJSONWriter_DEFINED
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
class
SkJSONWriter
:
SkNoncopyable
{
public
:
enum
class
Mode
{
kFast
kPretty
}
;
SkJSONWriter
(
SkWStream
*
stream
Mode
mode
=
Mode
:
:
kFast
)
:
fBlock
(
new
char
[
kBlockSize
]
)
fWrite
(
fBlock
)
fBlockEnd
(
fBlock
+
kBlockSize
)
fStream
(
stream
)
fMode
(
mode
)
fState
(
State
:
:
kStart
)
{
fScopeStack
.
push_back
(
Scope
:
:
kNone
)
;
fNewlineStack
.
push_back
(
true
)
;
}
~
SkJSONWriter
(
)
{
this
-
>
flush
(
)
;
delete
[
]
fBlock
;
SkASSERT
(
fScopeStack
.
count
(
)
=
=
1
)
;
SkASSERT
(
fNewlineStack
.
count
(
)
=
=
1
)
;
}
void
flush
(
)
{
if
(
fWrite
!
=
fBlock
)
{
fStream
-
>
write
(
fBlock
fWrite
-
fBlock
)
;
fWrite
=
fBlock
;
}
}
void
appendName
(
const
char
*
name
)
{
if
(
!
name
)
{
return
;
}
SkASSERT
(
Scope
:
:
kObject
=
=
this
-
>
scope
(
)
)
;
SkASSERT
(
State
:
:
kObjectBegin
=
=
fState
|
|
State
:
:
kObjectValue
=
=
fState
)
;
if
(
State
:
:
kObjectValue
=
=
fState
)
{
this
-
>
write
(
"
"
1
)
;
}
this
-
>
separator
(
this
-
>
multiline
(
)
)
;
this
-
>
write
(
"
\
"
"
1
)
;
this
-
>
write
(
name
strlen
(
name
)
)
;
this
-
>
write
(
"
\
"
:
"
2
)
;
fState
=
State
:
:
kObjectName
;
}
void
beginObject
(
const
char
*
name
=
nullptr
bool
multiline
=
true
)
{
this
-
>
appendName
(
name
)
;
this
-
>
beginValue
(
true
)
;
this
-
>
write
(
"
{
"
1
)
;
fScopeStack
.
push_back
(
Scope
:
:
kObject
)
;
fNewlineStack
.
push_back
(
multiline
)
;
fState
=
State
:
:
kObjectBegin
;
}
void
endObject
(
)
{
SkASSERT
(
Scope
:
:
kObject
=
=
this
-
>
scope
(
)
)
;
SkASSERT
(
State
:
:
kObjectBegin
=
=
fState
|
|
State
:
:
kObjectValue
=
=
fState
)
;
bool
emptyObject
=
State
:
:
kObjectBegin
=
=
fState
;
bool
wasMultiline
=
this
-
>
multiline
(
)
;
this
-
>
popScope
(
)
;
if
(
!
emptyObject
)
{
this
-
>
separator
(
wasMultiline
)
;
}
this
-
>
write
(
"
}
"
1
)
;
}
void
beginArray
(
const
char
*
name
=
nullptr
bool
multiline
=
true
)
{
this
-
>
appendName
(
name
)
;
this
-
>
beginValue
(
true
)
;
this
-
>
write
(
"
[
"
1
)
;
fScopeStack
.
push_back
(
Scope
:
:
kArray
)
;
fNewlineStack
.
push_back
(
multiline
)
;
fState
=
State
:
:
kArrayBegin
;
}
void
endArray
(
)
{
SkASSERT
(
Scope
:
:
kArray
=
=
this
-
>
scope
(
)
)
;
SkASSERT
(
State
:
:
kArrayBegin
=
=
fState
|
|
State
:
:
kArrayValue
=
=
fState
)
;
bool
emptyArray
=
State
:
:
kArrayBegin
=
=
fState
;
bool
wasMultiline
=
this
-
>
multiline
(
)
;
this
-
>
popScope
(
)
;
if
(
!
emptyArray
)
{
this
-
>
separator
(
wasMultiline
)
;
}
this
-
>
write
(
"
]
"
1
)
;
}
void
appendString
(
const
char
*
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
write
(
"
\
"
"
1
)
;
if
(
value
)
{
while
(
*
value
)
{
switch
(
*
value
)
{
case
'
"
'
:
this
-
>
write
(
"
\
\
\
"
"
2
)
;
break
;
case
'
\
\
'
:
this
-
>
write
(
"
\
\
\
\
"
2
)
;
break
;
case
'
\
b
'
:
this
-
>
write
(
"
\
\
b
"
2
)
;
break
;
case
'
\
f
'
:
this
-
>
write
(
"
\
\
f
"
2
)
;
break
;
case
'
\
n
'
:
this
-
>
write
(
"
\
\
n
"
2
)
;
break
;
case
'
\
r
'
:
this
-
>
write
(
"
\
\
r
"
2
)
;
break
;
case
'
\
t
'
:
this
-
>
write
(
"
\
\
t
"
2
)
;
break
;
default
:
this
-
>
write
(
value
1
)
;
break
;
}
value
+
+
;
}
}
this
-
>
write
(
"
\
"
"
1
)
;
}
void
appendPointer
(
const
void
*
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
\
"
%
p
\
"
"
value
)
;
}
void
appendBool
(
bool
value
)
{
this
-
>
beginValue
(
)
;
if
(
value
)
{
this
-
>
write
(
"
true
"
4
)
;
}
else
{
this
-
>
write
(
"
false
"
5
)
;
}
}
void
appendS32
(
int32_t
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
d
"
value
)
;
}
void
appendS64
(
int64_t
value
)
;
void
appendU32
(
uint32_t
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
u
"
value
)
;
}
void
appendU64
(
uint64_t
value
)
;
void
appendFloat
(
float
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
g
"
value
)
;
}
void
appendDouble
(
double
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
g
"
value
)
;
}
void
appendFloatDigits
(
float
value
int
digits
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
.
*
g
"
digits
value
)
;
}
void
appendDoubleDigits
(
double
value
int
digits
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
%
.
*
g
"
digits
value
)
;
}
void
appendHexU32
(
uint32_t
value
)
{
this
-
>
beginValue
(
)
;
this
-
>
appendf
(
"
\
"
0x
%
x
\
"
"
value
)
;
}
void
appendHexU64
(
uint64_t
value
)
;
#
define
DEFINE_NAMED_APPEND
(
function
type
)
\
void
function
(
const
char
*
name
type
value
)
{
this
-
>
appendName
(
name
)
;
this
-
>
function
(
value
)
;
}
DEFINE_NAMED_APPEND
(
appendString
const
char
*
)
DEFINE_NAMED_APPEND
(
appendPointer
const
void
*
)
DEFINE_NAMED_APPEND
(
appendBool
bool
)
DEFINE_NAMED_APPEND
(
appendS32
int32_t
)
DEFINE_NAMED_APPEND
(
appendS64
int64_t
)
DEFINE_NAMED_APPEND
(
appendU32
uint32_t
)
DEFINE_NAMED_APPEND
(
appendU64
uint64_t
)
DEFINE_NAMED_APPEND
(
appendFloat
float
)
DEFINE_NAMED_APPEND
(
appendDouble
double
)
DEFINE_NAMED_APPEND
(
appendHexU32
uint32_t
)
DEFINE_NAMED_APPEND
(
appendHexU64
uint64_t
)
#
undef
DEFINE_NAMED_APPEND
void
appendFloatDigits
(
const
char
*
name
float
value
int
digits
)
{
this
-
>
appendName
(
name
)
;
this
-
>
appendFloatDigits
(
value
digits
)
;
}
void
appendDoubleDigits
(
const
char
*
name
double
value
int
digits
)
{
this
-
>
appendName
(
name
)
;
this
-
>
appendDoubleDigits
(
value
digits
)
;
}
private
:
enum
{
kBlockSize
=
32
*
1024
}
;
enum
class
Scope
{
kNone
kObject
kArray
}
;
enum
class
State
{
kStart
kEnd
kObjectBegin
kObjectName
kObjectValue
kArrayBegin
kArrayValue
}
;
void
appendf
(
const
char
*
fmt
.
.
.
)
;
void
beginValue
(
bool
structure
=
false
)
{
SkASSERT
(
State
:
:
kObjectName
=
=
fState
|
|
State
:
:
kArrayBegin
=
=
fState
|
|
State
:
:
kArrayValue
=
=
fState
|
|
(
structure
&
&
State
:
:
kStart
=
=
fState
)
)
;
if
(
State
:
:
kArrayValue
=
=
fState
)
{
this
-
>
write
(
"
"
1
)
;
}
if
(
Scope
:
:
kArray
=
=
this
-
>
scope
(
)
)
{
this
-
>
separator
(
this
-
>
multiline
(
)
)
;
}
else
if
(
Scope
:
:
kObject
=
=
this
-
>
scope
(
)
&
&
Mode
:
:
kPretty
=
=
fMode
)
{
this
-
>
write
(
"
"
1
)
;
}
if
(
!
structure
)
{
fState
=
Scope
:
:
kArray
=
=
this
-
>
scope
(
)
?
State
:
:
kArrayValue
:
State
:
:
kObjectValue
;
}
}
void
separator
(
bool
multiline
)
{
if
(
Mode
:
:
kPretty
=
=
fMode
)
{
if
(
multiline
)
{
this
-
>
write
(
"
\
n
"
1
)
;
for
(
int
i
=
0
;
i
<
fScopeStack
.
count
(
)
-
1
;
+
+
i
)
{
this
-
>
write
(
"
"
3
)
;
}
}
else
{
this
-
>
write
(
"
"
1
)
;
}
}
}
void
write
(
const
char
*
buf
size_t
length
)
{
if
(
static_cast
<
size_t
>
(
fBlockEnd
-
fWrite
)
<
length
)
{
this
-
>
flush
(
)
;
}
if
(
length
>
kBlockSize
)
{
fStream
-
>
write
(
buf
length
)
;
}
else
{
memcpy
(
fWrite
buf
length
)
;
fWrite
+
=
length
;
}
}
Scope
scope
(
)
const
{
SkASSERT
(
!
fScopeStack
.
empty
(
)
)
;
return
fScopeStack
.
back
(
)
;
}
bool
multiline
(
)
const
{
SkASSERT
(
!
fNewlineStack
.
empty
(
)
)
;
return
fNewlineStack
.
back
(
)
;
}
void
popScope
(
)
{
fScopeStack
.
pop_back
(
)
;
fNewlineStack
.
pop_back
(
)
;
switch
(
this
-
>
scope
(
)
)
{
case
Scope
:
:
kNone
:
fState
=
State
:
:
kEnd
;
break
;
case
Scope
:
:
kObject
:
fState
=
State
:
:
kObjectValue
;
break
;
case
Scope
:
:
kArray
:
fState
=
State
:
:
kArrayValue
;
break
;
default
:
SkDEBUGFAIL
(
"
Invalid
scope
"
)
;
break
;
}
}
char
*
fBlock
;
char
*
fWrite
;
char
*
fBlockEnd
;
SkWStream
*
fStream
;
Mode
fMode
;
State
fState
;
SkSTArray
<
16
Scope
true
>
fScopeStack
;
SkSTArray
<
16
bool
true
>
fNewlineStack
;
}
;
#
endif
