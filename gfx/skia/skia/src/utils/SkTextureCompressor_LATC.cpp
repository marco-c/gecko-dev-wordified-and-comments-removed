#
include
"
SkTextureCompressor_LATC
.
h
"
#
include
"
SkTextureCompressor_Blitter
.
h
"
#
include
"
SkTextureCompressor_Utils
.
h
"
#
include
"
SkBlitter
.
h
"
#
include
"
SkEndian
.
h
"
#
define
COMPRESS_LATC_SLOW
0
#
define
COMPRESS_LATC_FAST
1
static
const
int
kLATCPaletteSize
=
8
;
static
void
generate_latc_palette
(
uint8_t
palette
[
]
uint8_t
lum0
uint8_t
lum1
)
{
palette
[
0
]
=
lum0
;
palette
[
1
]
=
lum1
;
if
(
lum0
>
lum1
)
{
for
(
int
i
=
1
;
i
<
7
;
i
+
+
)
{
palette
[
i
+
1
]
=
(
(
7
-
i
)
*
lum0
+
i
*
lum1
)
/
7
;
}
}
else
{
for
(
int
i
=
1
;
i
<
5
;
i
+
+
)
{
palette
[
i
+
1
]
=
(
(
5
-
i
)
*
lum0
+
i
*
lum1
)
/
5
;
}
palette
[
6
]
=
0
;
palette
[
7
]
=
255
;
}
}
#
if
COMPRESS_LATC_SLOW
template
<
typename
T
>
inline
T
abs_diff
(
const
T
&
a
const
T
&
b
)
{
return
(
a
>
b
)
?
(
a
-
b
)
:
(
b
-
a
)
;
}
static
bool
is_extremal
(
uint8_t
pixel
)
{
return
0
=
=
pixel
|
|
255
=
=
pixel
;
}
typedef
uint64_t
(
*
A84x4To64BitProc
)
(
const
uint8_t
block
[
]
)
;
static
bool
compress_4x4_a8_to_64bit
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
A84x4To64BitProc
proc
)
{
if
(
0
=
=
width
|
|
0
=
=
height
|
|
(
width
%
4
)
!
=
0
|
|
(
height
%
4
)
!
=
0
)
{
return
false
;
}
int
blocksX
=
width
>
>
2
;
int
blocksY
=
height
>
>
2
;
uint8_t
block
[
16
]
;
uint64_t
*
encPtr
=
reinterpret_cast
<
uint64_t
*
>
(
dst
)
;
for
(
int
y
=
0
;
y
<
blocksY
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
blocksX
;
+
+
x
)
{
for
(
int
k
=
0
;
k
<
4
;
+
+
k
)
{
memcpy
(
block
+
k
*
4
src
+
k
*
rowBytes
+
4
*
x
4
)
;
}
*
encPtr
=
proc
(
block
)
;
+
+
encPtr
;
}
src
+
=
4
*
rowBytes
;
}
return
true
;
}
static
const
int
kLATCBlockSize
=
4
;
static
const
int
kLATCPixelsPerBlock
=
kLATCBlockSize
*
kLATCBlockSize
;
static
uint64_t
compress_latc_block_bb
(
const
uint8_t
pixels
[
]
)
{
uint8_t
minVal
=
255
;
uint8_t
maxVal
=
0
;
for
(
int
i
=
0
;
i
<
kLATCPixelsPerBlock
;
+
+
i
)
{
minVal
=
SkTMin
(
pixels
[
i
]
minVal
)
;
maxVal
=
SkTMax
(
pixels
[
i
]
maxVal
)
;
}
SkASSERT
(
!
is_extremal
(
minVal
)
)
;
SkASSERT
(
!
is_extremal
(
maxVal
)
)
;
uint8_t
palette
[
kLATCPaletteSize
]
;
generate_latc_palette
(
palette
maxVal
minVal
)
;
uint64_t
indices
=
0
;
for
(
int
i
=
kLATCPixelsPerBlock
-
1
;
i
>
=
0
;
-
-
i
)
{
uint8_t
bestError
=
abs_diff
(
pixels
[
i
]
palette
[
0
]
)
;
uint8_t
idx
=
0
;
for
(
int
j
=
1
;
j
<
kLATCPaletteSize
;
+
+
j
)
{
uint8_t
error
=
abs_diff
(
pixels
[
i
]
palette
[
j
]
)
;
if
(
error
<
bestError
)
{
bestError
=
error
;
idx
=
j
;
}
}
indices
<
<
=
3
;
indices
|
=
idx
;
}
return
SkEndian_SwapLE64
(
static_cast
<
uint64_t
>
(
maxVal
)
|
(
static_cast
<
uint64_t
>
(
minVal
)
<
<
8
)
|
(
indices
<
<
16
)
)
;
}
static
uint64_t
compress_latc_block_bb_ignore_extremal
(
const
uint8_t
pixels
[
]
)
{
uint8_t
minVal
=
255
;
uint8_t
maxVal
=
0
;
for
(
int
i
=
0
;
i
<
kLATCPixelsPerBlock
;
+
+
i
)
{
if
(
is_extremal
(
pixels
[
i
]
)
)
{
continue
;
}
minVal
=
SkTMin
(
pixels
[
i
]
minVal
)
;
maxVal
=
SkTMax
(
pixels
[
i
]
maxVal
)
;
}
SkASSERT
(
!
is_extremal
(
minVal
)
)
;
SkASSERT
(
!
is_extremal
(
maxVal
)
)
;
uint8_t
palette
[
kLATCPaletteSize
]
;
generate_latc_palette
(
palette
minVal
maxVal
)
;
uint64_t
indices
=
0
;
for
(
int
i
=
kLATCPixelsPerBlock
-
1
;
i
>
=
0
;
-
-
i
)
{
uint8_t
idx
=
0
;
if
(
is_extremal
(
pixels
[
i
]
)
)
{
if
(
0xFF
=
=
pixels
[
i
]
)
{
idx
=
7
;
}
else
if
(
0
=
=
pixels
[
i
]
)
{
idx
=
6
;
}
else
{
SkFAIL
(
"
Pixel
is
extremal
but
not
really
?
!
"
)
;
}
}
else
{
uint8_t
bestError
=
abs_diff
(
pixels
[
i
]
palette
[
0
]
)
;
for
(
int
j
=
1
;
j
<
kLATCPaletteSize
-
2
;
+
+
j
)
{
uint8_t
error
=
abs_diff
(
pixels
[
i
]
palette
[
j
]
)
;
if
(
error
<
bestError
)
{
bestError
=
error
;
idx
=
j
;
}
}
}
indices
<
<
=
3
;
indices
|
=
idx
;
}
return
SkEndian_SwapLE64
(
static_cast
<
uint64_t
>
(
minVal
)
|
(
static_cast
<
uint64_t
>
(
maxVal
)
<
<
8
)
|
(
indices
<
<
16
)
)
;
}
static
uint64_t
compress_latc_block
(
const
uint8_t
pixels
[
]
)
{
int
nUniquePixels
=
0
;
uint8_t
uniquePixels
[
kLATCPixelsPerBlock
]
;
for
(
int
i
=
0
;
i
<
kLATCPixelsPerBlock
;
+
+
i
)
{
bool
foundPixel
=
false
;
for
(
int
j
=
0
;
j
<
nUniquePixels
;
+
+
j
)
{
foundPixel
=
foundPixel
|
|
uniquePixels
[
j
]
=
=
pixels
[
i
]
;
}
if
(
!
foundPixel
)
{
uniquePixels
[
nUniquePixels
]
=
pixels
[
i
]
;
+
+
nUniquePixels
;
}
}
if
(
1
=
=
nUniquePixels
)
{
return
SkEndian_SwapLE64
(
pixels
[
0
]
|
(
pixels
[
0
]
<
<
8
)
)
;
}
else
if
(
2
=
=
nUniquePixels
)
{
uint64_t
outBlock
=
0
;
for
(
int
i
=
kLATCPixelsPerBlock
-
1
;
i
>
=
0
;
-
-
i
)
{
int
idx
=
0
;
if
(
pixels
[
i
]
=
=
uniquePixels
[
1
]
)
{
idx
=
1
;
}
outBlock
<
<
=
3
;
outBlock
|
=
idx
;
}
outBlock
<
<
=
16
;
outBlock
|
=
(
uniquePixels
[
0
]
|
(
uniquePixels
[
1
]
<
<
8
)
)
;
return
SkEndian_SwapLE64
(
outBlock
)
;
}
int
nonExtremalPixels
=
0
;
for
(
int
i
=
0
;
i
<
nUniquePixels
;
+
+
i
)
{
if
(
!
is_extremal
(
uniquePixels
[
i
]
)
)
{
+
+
nonExtremalPixels
;
}
}
if
(
nonExtremalPixels
=
=
nUniquePixels
)
{
return
compress_latc_block_bb
(
pixels
)
;
}
else
{
return
compress_latc_block_bb_ignore_extremal
(
pixels
)
;
}
}
#
endif
#
if
COMPRESS_LATC_FAST
static
inline
uint32_t
pack_index
(
uint32_t
x
)
{
#
if
defined
(
SK_CPU_BENDIAN
)
return
(
x
>
>
24
)
|
(
(
x
>
>
13
)
&
0x38
)
|
(
(
x
>
>
2
)
&
0x1C0
)
|
(
(
x
<
<
9
)
&
0xE00
)
;
#
else
return
(
x
&
0x7
)
|
(
(
x
>
>
5
)
&
0x38
)
|
(
(
x
>
>
10
)
&
0x1C0
)
|
(
(
x
>
>
15
)
&
0xE00
)
;
#
endif
}
static
inline
uint32_t
convert_index
(
uint32_t
x
)
{
x
=
0x07070707
-
SkTextureCompressor
:
:
ConvertToThreeBitIndex
(
x
)
;
const
uint32_t
mask
=
(
x
|
(
x
>
>
1
)
|
(
x
>
>
2
)
)
&
0x01010101
;
x
=
(
x
+
mask
)
;
x
|
=
(
x
>
>
3
)
&
0x01010101
;
x
&
=
0x07070707
;
return
pack_index
(
x
)
;
}
typedef
uint64_t
(
*
PackIndicesProc
)
(
const
uint8_t
*
alpha
size_t
rowBytes
)
;
template
<
PackIndicesProc
packIndicesProc
>
static
void
compress_a8_latc_block
(
uint8_t
*
*
dstPtr
const
uint8_t
*
src
size_t
rowBytes
)
{
*
(
reinterpret_cast
<
uint64_t
*
>
(
*
dstPtr
)
)
=
SkEndian_SwapLE64
(
0xFF
|
(
packIndicesProc
(
src
rowBytes
)
<
<
16
)
)
;
*
dstPtr
+
=
8
;
}
inline
uint64_t
PackRowMajor
(
const
uint8_t
*
indices
size_t
rowBytes
)
{
uint64_t
result
=
0
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
const
uint32_t
idx
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
indices
+
i
*
rowBytes
)
)
;
result
|
=
static_cast
<
uint64_t
>
(
convert_index
(
idx
)
)
<
<
12
*
i
;
}
return
result
;
}
inline
uint64_t
PackColumnMajor
(
const
uint8_t
*
indices
size_t
rowBytes
)
{
uint8_t
transposed
[
16
]
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
transposed
[
j
*
4
+
i
]
=
indices
[
i
*
rowBytes
+
j
]
;
}
}
return
PackRowMajor
(
transposed
4
)
;
}
static
bool
compress_4x4_a8_latc
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
)
{
if
(
width
<
0
|
|
(
(
width
%
4
)
!
=
0
)
|
|
height
<
0
|
|
(
(
height
%
4
)
!
=
0
)
)
{
return
false
;
}
uint8_t
*
*
dstPtr
=
&
dst
;
for
(
int
y
=
0
;
y
<
height
;
y
+
=
4
)
{
for
(
int
x
=
0
;
x
<
width
;
x
+
=
4
)
{
compress_a8_latc_block
<
PackRowMajor
>
(
dstPtr
src
+
y
*
rowBytes
+
x
rowBytes
)
;
}
}
return
true
;
}
void
CompressA8LATCBlockVertical
(
uint8_t
*
dst
const
uint8_t
block
[
]
)
{
compress_a8_latc_block
<
PackColumnMajor
>
(
&
dst
block
4
)
;
}
#
endif
void
decompress_latc_block
(
uint8_t
*
dst
int
dstRowBytes
const
uint8_t
*
src
)
{
uint64_t
block
=
SkEndian_SwapLE64
(
*
(
reinterpret_cast
<
const
uint64_t
*
>
(
src
)
)
)
;
uint8_t
lum0
=
block
&
0xFF
;
uint8_t
lum1
=
(
block
>
>
8
)
&
0xFF
;
uint8_t
palette
[
kLATCPaletteSize
]
;
generate_latc_palette
(
palette
lum0
lum1
)
;
block
>
>
=
16
;
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
dst
[
i
]
=
palette
[
block
&
0x7
]
;
block
>
>
=
3
;
}
dst
+
=
dstRowBytes
;
}
}
struct
CompressorLATC
{
static
inline
void
CompressA8Vertical
(
uint8_t
*
dst
const
uint8_t
block
[
]
)
{
compress_a8_latc_block
<
PackColumnMajor
>
(
&
dst
block
4
)
;
}
static
inline
void
CompressA8Horizontal
(
uint8_t
*
dst
const
uint8_t
*
src
int
srcRowBytes
)
{
compress_a8_latc_block
<
PackRowMajor
>
(
&
dst
src
srcRowBytes
)
;
}
#
if
PEDANTIC_BLIT_RECT
static
inline
void
UpdateBlock
(
uint8_t
*
dst
const
uint8_t
*
src
int
srcRowBytes
const
uint8_t
*
mask
)
{
uint64_t
cmpMask
=
0
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
const
uint32_t
idx
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
src
+
i
*
srcRowBytes
)
)
;
cmpMask
|
=
static_cast
<
uint64_t
>
(
pack_index
(
idx
)
)
<
<
12
*
i
;
}
cmpMask
=
SkEndian_SwapLE64
(
cmpMask
<
<
16
)
;
uint64_t
cmpSrc
;
uint8_t
*
cmpSrcPtr
=
reinterpret_cast
<
uint8_t
*
>
(
&
cmpSrc
)
;
compress_a8_latc_block
<
PackRowMajor
>
(
&
cmpSrcPtr
src
srcRowBytes
)
;
cmpSrc
=
cmpSrc
&
cmpMask
;
uint64_t
*
cmpDst
=
reinterpret_cast
<
uint64_t
*
>
(
dst
)
;
if
(
0
=
=
cmpDst
)
{
*
cmpDst
=
SkTEndian_SwapLE64
(
0x24924924924900FFULL
)
;
}
*
cmpDst
&
=
~
cmpMask
;
*
cmpDst
|
=
cmpSrc
;
}
#
endif
}
;
namespace
SkTextureCompressor
{
bool
CompressA8ToLATC
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
)
{
#
if
COMPRESS_LATC_FAST
return
compress_4x4_a8_latc
(
dst
src
width
height
rowBytes
)
;
#
elif
COMPRESS_LATC_SLOW
return
compress_4x4_a8_to_64bit
(
dst
src
width
height
rowBytes
compress_latc_block
)
;
#
else
#
error
"
Must
choose
either
fast
or
slow
LATC
compression
"
#
endif
}
SkBlitter
*
CreateLATCBlitter
(
int
width
int
height
void
*
outputBuffer
SkTBlitterAllocator
*
allocator
)
{
if
(
(
width
%
4
)
!
=
0
|
|
(
height
%
4
)
!
=
0
)
{
return
nullptr
;
}
#
if
COMPRESS_LATC_FAST
sk_bzero
(
outputBuffer
width
*
height
/
2
)
;
return
allocator
-
>
createT
<
SkTCompressedAlphaBlitter
<
4
8
CompressorLATC
>
int
int
void
*
>
(
width
height
outputBuffer
)
;
#
elif
COMPRESS_LATC_SLOW
return
nullptr
;
#
endif
}
void
DecompressLATC
(
uint8_t
*
dst
int
dstRowBytes
const
uint8_t
*
src
int
width
int
height
)
{
for
(
int
j
=
0
;
j
<
height
;
j
+
=
4
)
{
for
(
int
i
=
0
;
i
<
width
;
i
+
=
4
)
{
decompress_latc_block
(
dst
+
i
dstRowBytes
src
)
;
src
+
=
8
;
}
dst
+
=
4
*
dstRowBytes
;
}
}
}
