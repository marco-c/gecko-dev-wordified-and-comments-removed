#
include
"
SkTextureCompressor
.
h
"
#
include
"
SkTextureCompressor_Blitter
.
h
"
#
include
"
SkTextureCompressor_Utils
.
h
"
#
include
"
SkBlitter
.
h
"
#
include
"
SkEndian
.
h
"
#
define
COMPRESS_R11_EAC_FASTEST
1
static
const
int
kNumR11EACPalettes
=
16
;
static
const
int
kR11EACPaletteSize
=
8
;
static
const
int
kR11EACModifierPalettes
[
kNumR11EACPalettes
]
[
kR11EACPaletteSize
]
=
{
{
-
3
-
6
-
9
-
15
2
5
8
14
}
{
-
3
-
7
-
10
-
13
2
6
9
12
}
{
-
2
-
5
-
8
-
13
1
4
7
12
}
{
-
2
-
4
-
6
-
13
1
3
5
12
}
{
-
3
-
6
-
8
-
12
2
5
7
11
}
{
-
3
-
7
-
9
-
11
2
6
8
10
}
{
-
4
-
7
-
8
-
11
3
6
7
10
}
{
-
3
-
5
-
8
-
11
2
4
7
10
}
{
-
2
-
6
-
8
-
10
1
5
7
9
}
{
-
2
-
5
-
8
-
10
1
4
7
9
}
{
-
2
-
4
-
8
-
10
1
3
7
9
}
{
-
2
-
5
-
7
-
10
1
4
6
9
}
{
-
3
-
4
-
7
-
10
2
3
6
9
}
{
-
1
-
2
-
3
-
10
0
1
2
9
}
{
-
4
-
6
-
8
-
9
3
5
7
8
}
{
-
3
-
5
-
7
-
9
2
4
6
8
}
}
;
#
if
COMPRESS_R11_EAC_SLOW
static
uint64_t
pack_r11eac_block
(
uint16_t
base_cw
uint16_t
palette
uint16_t
multiplier
uint64_t
indices
)
{
SkASSERT
(
palette
<
16
)
;
SkASSERT
(
multiplier
<
16
)
;
SkASSERT
(
indices
<
(
static_cast
<
uint64_t
>
(
1
)
<
<
48
)
)
;
const
uint64_t
b
=
static_cast
<
uint64_t
>
(
base_cw
)
<
<
56
;
const
uint64_t
m
=
static_cast
<
uint64_t
>
(
multiplier
)
<
<
52
;
const
uint64_t
p
=
static_cast
<
uint64_t
>
(
palette
)
<
<
48
;
return
SkEndian_SwapBE64
(
b
|
m
|
p
|
indices
)
;
}
static
uint16_t
compute_r11eac_pixel
(
int
base_cw
int
modifier
int
multiplier
)
{
int
ret
=
(
base_cw
*
8
+
4
)
+
(
modifier
*
multiplier
*
8
)
;
return
(
ret
>
2047
)
?
2047
:
(
(
ret
<
0
)
?
0
:
ret
)
;
}
static
inline
uint64_t
compress_heterogeneous_r11eac_block
(
const
uint8_t
block
[
16
]
)
{
uint16_t
bmin
=
block
[
0
]
;
uint16_t
bmax
=
block
[
0
]
;
for
(
int
i
=
1
;
i
<
16
;
+
+
i
)
{
bmin
=
SkTMin
<
uint16_t
>
(
bmin
block
[
i
]
)
;
bmax
=
SkTMax
<
uint16_t
>
(
bmax
block
[
i
]
)
;
}
uint16_t
center
=
(
bmax
+
bmin
)
>
>
1
;
SkASSERT
(
center
<
=
255
)
;
uint16_t
multiplier
=
(
bmax
-
center
)
/
10
;
uint16_t
cblock
[
16
]
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
int
srcIdx
=
i
*
4
+
j
;
int
dstIdx
=
j
*
4
+
i
;
cblock
[
dstIdx
]
=
(
block
[
srcIdx
]
<
<
3
)
|
(
block
[
srcIdx
]
>
>
5
)
;
}
}
uint32_t
bestError
=
0xFFFFFFFF
;
uint64_t
bestIndices
=
0
;
uint16_t
bestPalette
=
0
;
for
(
uint16_t
paletteIdx
=
0
;
paletteIdx
<
kNumR11EACPalettes
;
+
+
paletteIdx
)
{
const
int
*
palette
=
kR11EACModifierPalettes
[
paletteIdx
]
;
uint32_t
error
=
0
;
uint64_t
indices
=
0
;
for
(
int
pixelIdx
=
0
;
pixelIdx
<
16
;
+
+
pixelIdx
)
{
const
uint16_t
pixel
=
cblock
[
pixelIdx
]
;
uint16_t
bestPixelError
=
abs_diff
(
pixel
compute_r11eac_pixel
(
center
palette
[
0
]
multiplier
)
)
;
int
bestIndex
=
0
;
for
(
int
i
=
1
;
i
<
kR11EACPaletteSize
;
+
+
i
)
{
const
uint16_t
p
=
compute_r11eac_pixel
(
center
palette
[
i
]
multiplier
)
;
const
uint16_t
perror
=
abs_diff
(
pixel
p
)
;
if
(
perror
<
bestPixelError
)
{
bestIndex
=
i
;
bestPixelError
=
perror
;
}
}
SkASSERT
(
bestIndex
<
8
)
;
error
+
=
bestPixelError
;
indices
<
<
=
3
;
indices
|
=
bestIndex
;
}
SkASSERT
(
indices
<
(
static_cast
<
uint64_t
>
(
1
)
<
<
48
)
)
;
if
(
error
<
bestError
)
{
bestPalette
=
paletteIdx
;
bestIndices
=
indices
;
bestError
=
error
;
}
}
return
pack_r11eac_block
(
center
bestPalette
multiplier
bestIndices
)
;
}
#
endif
#
if
COMPRESS_R11_EAC_FAST
static
inline
uint64_t
compress_heterogeneous_r11eac_block
(
const
uint8_t
block
[
16
]
)
{
uint64_t
retVal
=
static_cast
<
uint64_t
>
(
0x8490
)
<
<
48
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
const
int
shift
=
45
-
3
*
(
j
*
4
+
i
)
;
SkASSERT
(
shift
<
=
45
)
;
const
uint64_t
idx
=
block
[
i
*
4
+
j
]
>
>
5
;
SkASSERT
(
idx
<
8
)
;
switch
(
idx
)
{
case
0
:
case
1
:
case
2
:
case
3
:
retVal
|
=
(
3
-
idx
)
<
<
shift
;
break
;
default
:
retVal
|
=
idx
<
<
shift
;
break
;
}
}
}
return
SkEndian_SwapBE64
(
retVal
)
;
}
#
endif
#
if
(
COMPRESS_R11_EAC_SLOW
)
|
|
(
COMPRESS_R11_EAC_FAST
)
static
uint64_t
compress_r11eac_block
(
const
uint8_t
block
[
16
]
)
{
bool
solid
=
true
;
for
(
int
i
=
1
;
i
<
16
;
+
+
i
)
{
if
(
block
[
i
]
!
=
block
[
0
]
)
{
solid
=
false
;
break
;
}
}
if
(
solid
)
{
switch
(
block
[
0
]
)
{
case
0
:
return
0x0020000000002000ULL
;
case
255
:
return
0xFFFFFFFFFFFFFFFFULL
;
default
:
break
;
}
}
return
compress_heterogeneous_r11eac_block
(
block
)
;
}
typedef
uint64_t
(
*
A84x4To64BitProc
)
(
const
uint8_t
block
[
]
)
;
static
bool
compress_4x4_a8_to_64bit
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
A84x4To64BitProc
proc
)
{
if
(
0
=
=
width
|
|
0
=
=
height
|
|
(
width
%
4
)
!
=
0
|
|
(
height
%
4
)
!
=
0
)
{
return
false
;
}
int
blocksX
=
width
>
>
2
;
int
blocksY
=
height
>
>
2
;
uint8_t
block
[
16
]
;
uint64_t
*
encPtr
=
reinterpret_cast
<
uint64_t
*
>
(
dst
)
;
for
(
int
y
=
0
;
y
<
blocksY
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
blocksX
;
+
+
x
)
{
for
(
int
k
=
0
;
k
<
4
;
+
+
k
)
{
memcpy
(
block
+
k
*
4
src
+
k
*
rowBytes
+
4
*
x
4
)
;
}
*
encPtr
=
proc
(
block
)
;
+
+
encPtr
;
}
src
+
=
4
*
rowBytes
;
}
return
true
;
}
#
endif
static
inline
uint32_t
convert_indices
(
uint32_t
x
)
{
x
=
SkTextureCompressor
:
:
ConvertToThreeBitIndex
(
x
)
;
x
=
~
(
(
0x80808080
-
x
)
^
0x7F7F7F7F
)
;
const
uint32_t
s
=
(
x
&
0x7F7F7F7F
)
+
0x03030303
;
x
=
(
(
x
^
0x03030303
)
&
0x80808080
)
^
s
;
const
uint32_t
a
=
x
&
0x80808080
;
const
uint32_t
b
=
a
>
>
7
;
const
uint32_t
m
=
(
a
>
>
6
)
|
b
;
x
=
(
x
^
(
(
a
-
b
)
|
a
)
)
+
b
;
return
x
+
m
;
}
#
if
COMPRESS_R11_EAC_FASTEST
template
<
unsigned
shift
>
static
inline
uint64_t
swap_shift
(
uint64_t
x
uint64_t
mask
)
{
const
uint64_t
t
=
(
x
^
(
x
>
>
shift
)
)
&
mask
;
return
x
^
t
^
(
t
<
<
shift
)
;
}
static
inline
uint64_t
interleave6
(
uint64_t
topRows
uint64_t
bottomRows
)
{
uint64_t
x
=
(
static_cast
<
uint64_t
>
(
topRows
)
<
<
32
)
|
static_cast
<
uint64_t
>
(
bottomRows
)
;
x
=
swap_shift
<
10
>
(
x
0x3FC0003FC00000ULL
)
;
x
=
(
x
|
(
(
x
<
<
52
)
&
(
0x3FULL
<
<
52
)
)
|
(
(
x
<
<
20
)
&
(
0x3FULL
<
<
28
)
)
)
>
>
16
;
x
=
swap_shift
<
6
>
(
x
0xFC0000ULL
)
;
#
if
defined
(
SK_CPU_BENDIAN
)
x
=
swap_shift
<
36
>
(
x
0x3FULL
)
;
x
=
swap_shift
<
12
>
(
x
0xFFF000000ULL
)
;
#
else
x
=
swap_shift
<
36
>
(
x
0xFC0ULL
)
;
x
=
(
x
&
(
0xFFFULL
<
<
36
)
)
|
(
(
x
&
0xFFFFFFULL
)
<
<
12
)
|
(
(
x
>
>
24
)
&
0xFFFULL
)
;
#
endif
return
x
;
}
static
uint64_t
compress_r11eac_block_fast
(
const
uint8_t
*
src
size_t
rowBytes
)
{
const
uint32_t
alphaRow1
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
src
)
)
;
const
uint32_t
alphaRow2
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
src
+
rowBytes
)
)
;
const
uint32_t
alphaRow3
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
src
+
2
*
rowBytes
)
)
;
const
uint32_t
alphaRow4
=
*
(
reinterpret_cast
<
const
uint32_t
*
>
(
src
+
3
*
rowBytes
)
)
;
if
(
alphaRow1
=
=
alphaRow2
&
&
alphaRow1
=
=
alphaRow3
&
&
alphaRow1
=
=
alphaRow4
)
{
if
(
0
=
=
alphaRow1
)
{
return
0x0020000000002000ULL
;
}
else
if
(
0xFFFFFFFF
=
=
alphaRow1
)
{
return
0xFFFFFFFFFFFFFFFFULL
;
}
}
const
uint32_t
indexRow1
=
convert_indices
(
alphaRow1
)
;
const
uint32_t
indexRow2
=
convert_indices
(
alphaRow2
)
;
const
uint32_t
indexRow3
=
convert_indices
(
alphaRow3
)
;
const
uint32_t
indexRow4
=
convert_indices
(
alphaRow4
)
;
const
uint32_t
r1r2
=
(
indexRow1
<
<
3
)
|
indexRow2
;
const
uint32_t
r3r4
=
(
indexRow3
<
<
3
)
|
indexRow4
;
const
uint64_t
indices
=
interleave6
(
r1r2
r3r4
)
;
return
SkEndian_SwapBE64
(
0x8490000000000000ULL
|
indices
)
;
}
static
bool
compress_a8_to_r11eac_fast
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
)
{
if
(
0
=
=
width
|
|
0
=
=
height
|
|
(
width
%
4
)
!
=
0
|
|
(
height
%
4
)
!
=
0
)
{
return
false
;
}
const
int
blocksX
=
width
>
>
2
;
const
int
blocksY
=
height
>
>
2
;
uint64_t
*
encPtr
=
reinterpret_cast
<
uint64_t
*
>
(
dst
)
;
for
(
int
y
=
0
;
y
<
blocksY
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
blocksX
;
+
+
x
)
{
*
encPtr
=
compress_r11eac_block_fast
(
src
+
4
*
x
rowBytes
)
;
+
+
encPtr
;
}
src
+
=
4
*
rowBytes
;
}
return
true
;
}
#
endif
static
inline
uint32_t
pack_indices_vertical
(
uint32_t
x
)
{
#
if
defined
(
SK_CPU_BENDIAN
)
return
(
x
&
7
)
|
(
(
x
>
>
5
)
&
(
7
<
<
3
)
)
|
(
(
x
>
>
10
)
&
(
7
<
<
6
)
)
|
(
(
x
>
>
15
)
&
(
7
<
<
9
)
)
;
#
else
return
(
(
x
>
>
24
)
&
7
)
|
(
(
x
>
>
13
)
&
(
7
<
<
3
)
)
|
(
(
x
>
>
2
)
&
(
7
<
<
6
)
)
|
(
(
x
<
<
9
)
&
(
7
<
<
9
)
)
;
#
endif
}
inline
void
compress_block_vertical
(
uint8_t
*
dstPtr
const
uint8_t
*
block
)
{
const
uint32_t
*
src
=
reinterpret_cast
<
const
uint32_t
*
>
(
block
)
;
uint64_t
*
dst
=
reinterpret_cast
<
uint64_t
*
>
(
dstPtr
)
;
const
uint32_t
alphaColumn0
=
src
[
0
]
;
const
uint32_t
alphaColumn1
=
src
[
1
]
;
const
uint32_t
alphaColumn2
=
src
[
2
]
;
const
uint32_t
alphaColumn3
=
src
[
3
]
;
if
(
alphaColumn0
=
=
alphaColumn1
&
&
alphaColumn2
=
=
alphaColumn3
&
&
alphaColumn0
=
=
alphaColumn2
)
{
if
(
0
=
=
alphaColumn0
)
{
*
dst
=
0x0020000000002000ULL
;
return
;
}
else
if
(
0xFFFFFFFF
=
=
alphaColumn0
)
{
*
dst
=
0xFFFFFFFFFFFFFFFFULL
;
return
;
}
}
const
uint32_t
indexColumn0
=
convert_indices
(
alphaColumn0
)
;
const
uint32_t
indexColumn1
=
convert_indices
(
alphaColumn1
)
;
const
uint32_t
indexColumn2
=
convert_indices
(
alphaColumn2
)
;
const
uint32_t
indexColumn3
=
convert_indices
(
alphaColumn3
)
;
const
uint32_t
packedIndexColumn0
=
pack_indices_vertical
(
indexColumn0
)
;
const
uint32_t
packedIndexColumn1
=
pack_indices_vertical
(
indexColumn1
)
;
const
uint32_t
packedIndexColumn2
=
pack_indices_vertical
(
indexColumn2
)
;
const
uint32_t
packedIndexColumn3
=
pack_indices_vertical
(
indexColumn3
)
;
*
dst
=
SkEndian_SwapBE64
(
0x8490000000000000ULL
|
(
static_cast
<
uint64_t
>
(
packedIndexColumn0
)
<
<
36
)
|
(
static_cast
<
uint64_t
>
(
packedIndexColumn1
)
<
<
24
)
|
static_cast
<
uint64_t
>
(
packedIndexColumn2
<
<
12
)
|
static_cast
<
uint64_t
>
(
packedIndexColumn3
)
)
;
}
static
inline
int
get_r11_eac_index
(
uint64_t
block
int
x
int
y
)
{
SkASSERT
(
x
>
=
0
&
&
x
<
4
)
;
SkASSERT
(
y
>
=
0
&
&
y
<
4
)
;
const
int
idx
=
x
*
4
+
y
;
return
(
block
>
>
(
(
15
-
idx
)
*
3
)
)
&
0x7
;
}
static
void
decompress_r11_eac_block
(
uint8_t
*
dst
int
dstRowBytes
const
uint8_t
*
src
)
{
const
uint64_t
block
=
SkEndian_SwapBE64
(
*
(
reinterpret_cast
<
const
uint64_t
*
>
(
src
)
)
)
;
const
int
base_cw
=
(
block
>
>
56
)
&
0xFF
;
const
int
mod
=
(
block
>
>
52
)
&
0xF
;
const
int
palette_idx
=
(
block
>
>
48
)
&
0xF
;
const
int
*
palette
=
kR11EACModifierPalettes
[
palette_idx
]
;
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
const
int
idx
=
get_r11_eac_index
(
block
i
j
)
;
const
int
val
=
base_cw
*
8
+
4
+
palette
[
idx
]
*
mod
*
8
;
if
(
val
<
0
)
{
dst
[
i
]
=
0
;
}
else
if
(
val
>
2047
)
{
dst
[
i
]
=
0xFF
;
}
else
{
dst
[
i
]
=
(
val
>
>
3
)
&
0xFF
;
}
}
dst
+
=
dstRowBytes
;
}
}
struct
CompressorR11EAC
{
static
inline
void
CompressA8Vertical
(
uint8_t
*
dst
const
uint8_t
*
src
)
{
compress_block_vertical
(
dst
src
)
;
}
static
inline
void
CompressA8Horizontal
(
uint8_t
*
dst
const
uint8_t
*
src
int
srcRowBytes
)
{
*
(
reinterpret_cast
<
uint64_t
*
>
(
dst
)
)
=
compress_r11eac_block_fast
(
src
srcRowBytes
)
;
}
#
if
PEDANTIC_BLIT_RECT
static
inline
void
UpdateBlock
(
uint8_t
*
dst
const
uint8_t
*
src
int
srcRowBytes
const
uint8_t
*
mask
)
{
SkFAIL
(
"
Implement
me
!
"
)
;
}
#
endif
}
;
namespace
SkTextureCompressor
{
bool
CompressA8ToR11EAC
(
uint8_t
*
dst
const
uint8_t
*
src
int
width
int
height
size_t
rowBytes
)
{
#
if
(
COMPRESS_R11_EAC_SLOW
)
|
|
(
COMPRESS_R11_EAC_FAST
)
return
compress_4x4_a8_to_64bit
(
dst
src
width
height
rowBytes
compress_r11eac_block
)
;
#
elif
COMPRESS_R11_EAC_FASTEST
return
compress_a8_to_r11eac_fast
(
dst
src
width
height
rowBytes
)
;
#
else
#
error
"
Must
choose
R11
EAC
algorithm
"
#
endif
}
SkBlitter
*
CreateR11EACBlitter
(
int
width
int
height
void
*
outputBuffer
SkTBlitterAllocator
*
allocator
)
{
if
(
(
width
%
4
)
!
=
0
|
|
(
height
%
4
)
!
=
0
)
{
return
nullptr
;
}
const
int
nBlocks
=
(
width
*
height
/
16
)
;
uint64_t
*
dst
=
reinterpret_cast
<
uint64_t
*
>
(
outputBuffer
)
;
for
(
int
i
=
0
;
i
<
nBlocks
;
+
+
i
)
{
*
dst
=
0x0020000000002000ULL
;
+
+
dst
;
}
return
allocator
-
>
createT
<
SkTCompressedAlphaBlitter
<
4
8
CompressorR11EAC
>
int
int
void
*
>
(
width
height
outputBuffer
)
;
}
void
DecompressR11EAC
(
uint8_t
*
dst
int
dstRowBytes
const
uint8_t
*
src
int
width
int
height
)
{
for
(
int
j
=
0
;
j
<
height
;
j
+
=
4
)
{
for
(
int
i
=
0
;
i
<
width
;
i
+
=
4
)
{
decompress_r11_eac_block
(
dst
+
i
dstRowBytes
src
)
;
src
+
=
8
;
}
dst
+
=
4
*
dstRowBytes
;
}
}
}
