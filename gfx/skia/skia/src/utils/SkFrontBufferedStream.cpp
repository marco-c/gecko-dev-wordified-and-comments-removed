#
include
"
SkFrontBufferedStream
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
class
FrontBufferedStream
:
public
SkStreamRewindable
{
public
:
FrontBufferedStream
(
SkStream
*
size_t
bufferSize
)
;
size_t
read
(
void
*
buffer
size_t
size
)
override
;
bool
peek
(
void
*
buffer
size_t
size
)
const
override
;
bool
isAtEnd
(
)
const
override
;
bool
rewind
(
)
override
;
bool
hasPosition
(
)
const
override
{
return
true
;
}
size_t
getPosition
(
)
const
override
{
return
fOffset
;
}
bool
hasLength
(
)
const
override
{
return
fHasLength
;
}
size_t
getLength
(
)
const
override
{
return
fLength
;
}
SkStreamRewindable
*
duplicate
(
)
const
override
{
return
nullptr
;
}
private
:
SkAutoTDelete
<
SkStream
>
fStream
;
const
bool
fHasLength
;
const
size_t
fLength
;
size_t
fOffset
;
size_t
fBufferedSoFar
;
const
size_t
fBufferSize
;
SkAutoTMalloc
<
char
>
fBuffer
;
size_t
readFromBuffer
(
char
*
dst
size_t
size
)
;
size_t
bufferAndWriteTo
(
char
*
dst
size_t
size
)
;
size_t
readDirectlyFromStream
(
char
*
dst
size_t
size
)
;
typedef
SkStream
INHERITED
;
}
;
SkStreamRewindable
*
SkFrontBufferedStream
:
:
Create
(
SkStream
*
stream
size_t
bufferSize
)
{
if
(
nullptr
=
=
stream
)
{
return
nullptr
;
}
return
new
FrontBufferedStream
(
stream
bufferSize
)
;
}
FrontBufferedStream
:
:
FrontBufferedStream
(
SkStream
*
stream
size_t
bufferSize
)
:
fStream
(
stream
)
fHasLength
(
stream
-
>
hasPosition
(
)
&
&
stream
-
>
hasLength
(
)
)
fLength
(
stream
-
>
getLength
(
)
-
stream
-
>
getPosition
(
)
)
fOffset
(
0
)
fBufferedSoFar
(
0
)
fBufferSize
(
bufferSize
)
fBuffer
(
bufferSize
)
{
}
bool
FrontBufferedStream
:
:
isAtEnd
(
)
const
{
if
(
fOffset
<
fBufferedSoFar
)
{
return
false
;
}
return
fStream
-
>
isAtEnd
(
)
;
}
bool
FrontBufferedStream
:
:
rewind
(
)
{
if
(
fOffset
<
=
fBufferSize
)
{
fOffset
=
0
;
return
true
;
}
return
false
;
}
size_t
FrontBufferedStream
:
:
readFromBuffer
(
char
*
dst
size_t
size
)
{
SkASSERT
(
fOffset
<
fBufferedSoFar
)
;
const
size_t
bytesToCopy
=
SkTMin
(
size
fBufferedSoFar
-
fOffset
)
;
if
(
dst
!
=
nullptr
)
{
memcpy
(
dst
fBuffer
+
fOffset
bytesToCopy
)
;
}
fOffset
+
=
bytesToCopy
;
SkASSERT
(
fOffset
<
=
fBufferedSoFar
)
;
return
bytesToCopy
;
}
size_t
FrontBufferedStream
:
:
bufferAndWriteTo
(
char
*
dst
size_t
size
)
{
SkASSERT
(
size
>
0
)
;
SkASSERT
(
fOffset
>
=
fBufferedSoFar
)
;
SkASSERT
(
fBuffer
)
;
const
size_t
bytesToBuffer
=
SkTMin
(
size
fBufferSize
-
fBufferedSoFar
)
;
char
*
buffer
=
fBuffer
+
fOffset
;
const
size_t
buffered
=
fStream
-
>
read
(
buffer
bytesToBuffer
)
;
fBufferedSoFar
+
=
buffered
;
fOffset
=
fBufferedSoFar
;
SkASSERT
(
fBufferedSoFar
<
=
fBufferSize
)
;
if
(
dst
!
=
nullptr
)
{
memcpy
(
dst
buffer
buffered
)
;
}
return
buffered
;
}
size_t
FrontBufferedStream
:
:
readDirectlyFromStream
(
char
*
dst
size_t
size
)
{
SkASSERT
(
size
>
0
)
;
SkASSERT
(
fBufferSize
=
=
fBufferedSoFar
&
&
fOffset
>
=
fBufferSize
)
;
const
size_t
bytesReadDirectly
=
fStream
-
>
read
(
dst
size
)
;
fOffset
+
=
bytesReadDirectly
;
if
(
bytesReadDirectly
>
0
)
{
sk_free
(
fBuffer
.
detach
(
)
)
;
}
return
bytesReadDirectly
;
}
bool
FrontBufferedStream
:
:
peek
(
void
*
dst
size_t
size
)
const
{
const
size_t
start
=
fOffset
;
if
(
start
+
size
>
fBufferSize
)
{
return
false
;
}
FrontBufferedStream
*
nonConstThis
=
const_cast
<
FrontBufferedStream
*
>
(
this
)
;
SkDEBUGCODE
(
const
size_t
bytesRead
=
)
nonConstThis
-
>
read
(
dst
size
)
;
SkASSERT
(
bytesRead
=
=
size
)
;
nonConstThis
-
>
fOffset
=
start
;
return
true
;
}
size_t
FrontBufferedStream
:
:
read
(
void
*
voidDst
size_t
size
)
{
char
*
dst
=
reinterpret_cast
<
char
*
>
(
voidDst
)
;
SkDEBUGCODE
(
const
size_t
totalSize
=
size
;
)
const
size_t
start
=
fOffset
;
if
(
fOffset
<
fBufferedSoFar
)
{
const
size_t
bytesCopied
=
this
-
>
readFromBuffer
(
dst
size
)
;
size
-
=
bytesCopied
;
SkASSERT
(
size
+
(
fOffset
-
start
)
=
=
totalSize
)
;
if
(
dst
!
=
nullptr
)
{
dst
+
=
bytesCopied
;
}
}
if
(
size
>
0
&
&
fBufferedSoFar
<
fBufferSize
&
&
!
fStream
-
>
isAtEnd
(
)
)
{
const
size_t
buffered
=
this
-
>
bufferAndWriteTo
(
dst
size
)
;
size
-
=
buffered
;
SkASSERT
(
size
+
(
fOffset
-
start
)
=
=
totalSize
)
;
if
(
dst
!
=
nullptr
)
{
dst
+
=
buffered
;
}
}
if
(
size
>
0
&
&
!
fStream
-
>
isAtEnd
(
)
)
{
SkDEBUGCODE
(
const
size_t
bytesReadDirectly
=
)
this
-
>
readDirectlyFromStream
(
dst
size
)
;
SkDEBUGCODE
(
size
-
=
bytesReadDirectly
;
)
SkASSERT
(
size
+
(
fOffset
-
start
)
=
=
totalSize
)
;
}
return
fOffset
-
start
;
}
