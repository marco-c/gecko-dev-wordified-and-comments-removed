#
ifndef
SkJSON_DEFINED
#
define
SkJSON_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
<
cstring
>
class
SkString
;
class
SkWStream
;
namespace
skjson
{
class
alignas
(
8
)
Value
{
public
:
enum
class
Type
{
kNull
kBool
kNumber
kString
kArray
kObject
}
;
Type
getType
(
)
const
;
template
<
typename
T
>
bool
is
(
)
const
{
return
this
-
>
getType
(
)
=
=
T
:
:
kType
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
SkASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
reinterpret_cast
<
const
T
*
>
(
this
)
;
}
template
<
typename
T
>
operator
const
T
*
(
)
const
{
return
this
-
>
is
<
T
>
(
)
?
&
this
-
>
as
<
T
>
(
)
:
nullptr
;
}
SkString
toString
(
)
const
;
protected
:
enum
class
Tag
:
uint8_t
{
kShortString
=
0b00000000
kNull
=
0b00100000
kBool
=
0b01000000
kInt
=
0b01100000
kFloat
=
0b10000000
kString
=
0b10100000
kArray
=
0b11000000
kObject
=
0b11100000
}
;
static
constexpr
uint8_t
kTagMask
=
0b11100000
;
void
init_tagged
(
Tag
)
;
void
init_tagged_pointer
(
Tag
void
*
)
;
Tag
getTag
(
)
const
{
return
static_cast
<
Tag
>
(
fData8
[
kTagOffset
]
&
kTagMask
)
;
}
template
<
typename
T
>
const
T
*
cast
(
)
const
{
static_assert
(
sizeof
(
T
)
<
=
sizeof
(
Value
)
"
"
)
;
static_assert
(
alignof
(
T
)
<
=
alignof
(
Value
)
"
"
)
;
return
reinterpret_cast
<
const
T
*
>
(
this
)
;
}
template
<
typename
T
>
T
*
cast
(
)
{
return
const_cast
<
T
*
>
(
const_cast
<
const
Value
*
>
(
this
)
-
>
cast
<
T
>
(
)
)
;
}
template
<
typename
T
>
const
T
*
ptr
(
)
const
{
static_assert
(
sizeof
(
uintptr_t
)
=
=
sizeof
(
Value
)
|
|
sizeof
(
uintptr_t
)
*
2
=
=
sizeof
(
Value
)
"
"
)
;
return
(
sizeof
(
uintptr_t
)
<
sizeof
(
Value
)
)
?
*
this
-
>
cast
<
const
T
*
>
(
)
:
reinterpret_cast
<
T
*
>
(
*
this
-
>
cast
<
uintptr_t
>
(
)
&
kTagPointerMask
)
;
}
private
:
static
constexpr
size_t
kValueSize
=
8
;
uint8_t
fData8
[
kValueSize
]
;
#
if
defined
(
SK_CPU_LENDIAN
)
static
constexpr
size_t
kTagOffset
=
kValueSize
-
1
;
static
constexpr
uintptr_t
kTagPointerMask
=
~
(
static_cast
<
uintptr_t
>
(
kTagMask
)
<
<
(
(
sizeof
(
uintptr_t
)
-
1
)
*
8
)
)
;
#
else
static_assert
(
false
"
Big
-
endian
builds
are
not
supported
at
this
time
.
"
)
;
#
endif
}
;
class
NullValue
final
:
public
Value
{
public
:
static
constexpr
Type
kType
=
Type
:
:
kNull
;
NullValue
(
)
;
}
;
class
BoolValue
final
:
public
Value
{
public
:
static
constexpr
Type
kType
=
Type
:
:
kBool
;
explicit
BoolValue
(
bool
)
;
bool
operator
*
(
)
const
{
SkASSERT
(
this
-
>
getTag
(
)
=
=
Tag
:
:
kBool
)
;
return
*
this
-
>
cast
<
bool
>
(
)
;
}
}
;
class
NumberValue
final
:
public
Value
{
public
:
static
constexpr
Type
kType
=
Type
:
:
kNumber
;
explicit
NumberValue
(
int32_t
)
;
explicit
NumberValue
(
float
)
;
double
operator
*
(
)
const
{
SkASSERT
(
this
-
>
getTag
(
)
=
=
Tag
:
:
kInt
|
|
this
-
>
getTag
(
)
=
=
Tag
:
:
kFloat
)
;
return
this
-
>
getTag
(
)
=
=
Tag
:
:
kInt
?
static_cast
<
double
>
(
*
this
-
>
cast
<
int32_t
>
(
)
)
:
static_cast
<
double
>
(
*
this
-
>
cast
<
float
>
(
)
)
;
}
}
;
template
<
typename
T
Value
:
:
Type
vtype
>
class
VectorValue
:
public
Value
{
public
:
using
ValueT
=
T
;
static
constexpr
Type
kType
=
vtype
;
size_t
size
(
)
const
{
SkASSERT
(
this
-
>
getType
(
)
=
=
kType
)
;
return
*
this
-
>
ptr
<
size_t
>
(
)
;
}
const
T
*
begin
(
)
const
{
SkASSERT
(
this
-
>
getType
(
)
=
=
kType
)
;
const
auto
*
size_ptr
=
this
-
>
ptr
<
size_t
>
(
)
;
return
reinterpret_cast
<
const
T
*
>
(
size_ptr
+
1
)
;
}
const
T
*
end
(
)
const
{
SkASSERT
(
this
-
>
getType
(
)
=
=
kType
)
;
const
auto
*
size_ptr
=
this
-
>
ptr
<
size_t
>
(
)
;
return
reinterpret_cast
<
const
T
*
>
(
size_ptr
+
1
)
+
*
size_ptr
;
}
const
T
&
operator
[
]
(
size_t
i
)
const
{
SkASSERT
(
this
-
>
getType
(
)
=
=
kType
)
;
SkASSERT
(
i
<
this
-
>
size
(
)
)
;
return
*
(
this
-
>
begin
(
)
+
i
)
;
}
}
;
class
ArrayValue
final
:
public
VectorValue
<
Value
Value
:
:
Type
:
:
kArray
>
{
public
:
ArrayValue
(
const
Value
*
src
size_t
size
SkArenaAlloc
&
alloc
)
;
}
;
class
StringValue
final
:
public
Value
{
public
:
static
constexpr
Type
kType
=
Type
:
:
kString
;
StringValue
(
)
;
StringValue
(
const
char
*
src
size_t
size
SkArenaAlloc
&
alloc
)
;
size_t
size
(
)
const
{
switch
(
this
-
>
getTag
(
)
)
{
case
Tag
:
:
kShortString
:
return
strlen
(
this
-
>
cast
<
char
>
(
)
)
;
case
Tag
:
:
kString
:
return
this
-
>
cast
<
VectorValue
<
char
Value
:
:
Type
:
:
kString
>
>
(
)
-
>
size
(
)
;
default
:
return
0
;
}
}
const
char
*
begin
(
)
const
{
return
this
-
>
getTag
(
)
=
=
Tag
:
:
kShortString
?
this
-
>
cast
<
char
>
(
)
:
this
-
>
cast
<
VectorValue
<
char
Value
:
:
Type
:
:
kString
>
>
(
)
-
>
begin
(
)
;
}
const
char
*
end
(
)
const
{
return
this
-
>
getTag
(
)
=
=
Tag
:
:
kShortString
?
strchr
(
this
-
>
cast
<
char
>
(
)
'
\
0
'
)
:
this
-
>
cast
<
VectorValue
<
char
Value
:
:
Type
:
:
kString
>
>
(
)
-
>
end
(
)
;
}
}
;
struct
Member
{
StringValue
fKey
;
Value
fValue
;
}
;
class
ObjectValue
final
:
public
VectorValue
<
Member
Value
:
:
Type
:
:
kObject
>
{
public
:
ObjectValue
(
const
Member
*
src
size_t
size
SkArenaAlloc
&
alloc
)
;
const
Value
&
operator
[
]
(
const
char
*
)
const
;
private
:
const
Member
&
operator
[
]
(
size_t
i
)
const
=
delete
;
}
;
class
DOM
final
:
public
SkNoncopyable
{
public
:
DOM
(
const
char
*
size_t
)
;
const
Value
&
root
(
)
const
{
return
fRoot
;
}
void
write
(
SkWStream
*
)
const
;
private
:
SkArenaAlloc
fAlloc
;
Value
fRoot
;
}
;
inline
Value
:
:
Type
Value
:
:
getType
(
)
const
{
switch
(
this
-
>
getTag
(
)
)
{
case
Tag
:
:
kNull
:
return
Type
:
:
kNull
;
case
Tag
:
:
kBool
:
return
Type
:
:
kBool
;
case
Tag
:
:
kInt
:
return
Type
:
:
kNumber
;
case
Tag
:
:
kFloat
:
return
Type
:
:
kNumber
;
case
Tag
:
:
kShortString
:
return
Type
:
:
kString
;
case
Tag
:
:
kString
:
return
Type
:
:
kString
;
case
Tag
:
:
kArray
:
return
Type
:
:
kArray
;
case
Tag
:
:
kObject
:
return
Type
:
:
kObject
;
}
SkASSERT
(
false
)
;
return
Type
:
:
kNull
;
}
}
#
endif
