#
ifndef
SkTextureCompressor_Blitter_DEFINED
#
define
SkTextureCompressor_Blitter_DEFINED
#
include
"
SkTypes
.
h
"
#
include
"
SkBlitter
.
h
"
namespace
SkTextureCompressor
{
#
define
PEDANTIC_BLIT_RECT
0
#
if
PEDANTIC_BLIT_RECT
#
endif
template
<
int
BlockDim
int
EncodedBlockSize
typename
CompressorType
>
class
SkTCompressedAlphaBlitter
:
public
SkBlitter
{
public
:
SkTCompressedAlphaBlitter
(
int
width
int
height
void
*
compressedBuffer
)
#
ifdef
SK_DEBUG
:
fCalledOnceWithNonzeroY
(
false
)
fBlitMaskCalled
(
false
)
#
else
:
#
endif
kLongestRun
(
0x7FFE
)
kZeroAlpha
(
0
)
fNextRun
(
0
)
fWidth
(
width
)
fHeight
(
height
)
fBuffer
(
compressedBuffer
)
{
SkASSERT
(
(
width
%
BlockDim
)
=
=
0
)
;
SkASSERT
(
(
height
%
BlockDim
)
=
=
0
)
;
}
virtual
~
SkTCompressedAlphaBlitter
(
)
{
this
-
>
flushRuns
(
)
;
}
void
blitH
(
int
x
int
y
int
width
)
override
{
SkFAIL
(
"
Not
implemented
!
"
)
;
}
void
blitAntiH
(
int
x
int
y
const
SkAlpha
antialias
[
]
const
int16_t
runs
[
]
)
override
{
SkASSERT
(
0
=
=
x
)
;
if
(
fNextRun
>
0
&
&
(
(
x
!
=
fBufferedRuns
[
fNextRun
-
1
]
.
fX
)
|
|
(
y
-
1
!
=
fBufferedRuns
[
fNextRun
-
1
]
.
fY
)
)
)
{
this
-
>
flushRuns
(
)
;
}
const
int
row
=
BlockDim
*
(
y
/
BlockDim
)
;
while
(
(
row
+
fNextRun
)
<
y
)
{
fBufferedRuns
[
fNextRun
]
.
fAlphas
=
&
kZeroAlpha
;
fBufferedRuns
[
fNextRun
]
.
fRuns
=
&
kLongestRun
;
fBufferedRuns
[
fNextRun
]
.
fX
=
0
;
fBufferedRuns
[
fNextRun
]
.
fY
=
row
+
fNextRun
;
+
+
fNextRun
;
}
SkASSERT
(
fNextRun
=
=
(
y
%
BlockDim
)
)
;
SkASSERT
(
fNextRun
=
=
0
|
|
fBufferedRuns
[
fNextRun
-
1
]
.
fY
<
y
)
;
fBufferedRuns
[
fNextRun
]
.
fAlphas
=
antialias
;
fBufferedRuns
[
fNextRun
]
.
fRuns
=
runs
;
fBufferedRuns
[
fNextRun
]
.
fX
=
x
;
fBufferedRuns
[
fNextRun
]
.
fY
=
y
;
if
(
BlockDim
=
=
+
+
fNextRun
)
{
this
-
>
flushRuns
(
)
;
}
}
void
blitV
(
int
x
int
y
int
height
SkAlpha
alpha
)
override
{
SkFAIL
(
"
Not
implemented
!
"
)
;
}
#
ifdef
SK_DEBUG
bool
fCalledOnceWithNonzeroY
;
#
endif
void
blitRect
(
int
x
int
y
int
width
int
height
)
override
{
SkASSERT
(
0
=
=
x
)
;
SkASSERT
(
width
<
=
fWidth
)
;
SkASSERT
(
(
0
=
=
y
)
|
|
(
!
fCalledOnceWithNonzeroY
&
&
(
fCalledOnceWithNonzeroY
=
true
)
)
)
;
#
if
!
(
PEDANTIC_BLIT_RECT
)
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
const
SkAlpha
kFullAlpha
=
0xFF
;
this
-
>
blitAntiH
(
x
y
+
i
&
kFullAlpha
&
kLongestRun
)
;
}
#
else
const
int
startBlockX
=
(
x
/
BlockDim
)
*
BlockDim
;
const
int
startBlockY
=
(
y
/
BlockDim
)
*
BlockDim
;
const
int
endBlockX
=
(
(
x
+
width
)
/
BlockDim
)
*
BlockDim
;
const
int
endBlockY
=
(
(
y
+
height
)
/
BlockDim
)
*
BlockDim
;
if
(
startBlockY
=
=
endBlockY
&
&
startBlockX
=
=
endBlockX
)
{
uint8_t
mask
[
BlockDim
*
BlockDim
]
;
memset
(
mask
0
sizeof
(
mask
)
)
;
const
int
xoff
=
x
-
startBlockX
;
SkASSERT
(
(
xoff
+
width
)
<
=
BlockDim
)
;
const
int
yoff
=
y
-
startBlockY
;
SkASSERT
(
(
yoff
+
height
)
<
=
BlockDim
)
;
for
(
int
j
=
0
;
j
<
height
;
+
+
j
)
{
memset
(
mask
+
(
j
+
yoff
)
*
BlockDim
+
xoff
0xFF
width
)
;
}
uint8_t
*
dst
=
this
-
>
getBlock
(
startBlockX
startBlockY
)
;
CompressorType
:
:
UpdateBlock
(
dst
mask
BlockDim
mask
)
;
}
else
if
(
startBlockY
=
=
endBlockY
)
{
this
-
>
updateBlockRow
(
x
y
width
height
startBlockY
startBlockX
endBlockX
)
;
}
else
if
(
startBlockX
=
=
endBlockX
)
{
this
-
>
updateBlockCol
(
x
y
width
height
startBlockX
startBlockY
endBlockY
)
;
}
else
{
const
int
innerStartBlockX
=
startBlockX
+
BlockDim
;
const
int
innerStartBlockY
=
startBlockY
+
BlockDim
;
const
int
topRowHeight
=
innerStartBlockY
-
y
;
this
-
>
updateBlockRow
(
x
y
width
topRowHeight
startBlockY
startBlockX
endBlockX
)
;
y
+
=
topRowHeight
;
height
-
=
topRowHeight
;
if
(
endBlockY
>
innerStartBlockY
)
{
this
-
>
updateBlockCol
(
x
y
innerStartBlockX
-
x
endBlockY
startBlockY
startBlockX
innerStartBlockX
)
;
uint8_t
mask
[
BlockDim
*
BlockDim
]
;
memset
(
mask
0xFF
sizeof
(
mask
)
)
;
uint8_t
opaqueEncoding
[
EncodedBlockSize
]
;
CompressorType
:
:
CompressA8Horizontal
(
opaqueEncoding
mask
BlockDim
)
;
for
(
int
j
=
innerStartBlockY
;
j
<
endBlockY
;
j
+
=
BlockDim
)
{
uint8_t
*
opaqueDst
=
this
-
>
getBlock
(
innerStartBlockX
j
)
;
for
(
int
i
=
innerStartBlockX
;
i
<
endBlockX
;
i
+
=
BlockDim
)
{
memcpy
(
opaqueDst
opaqueEncoding
EncodedBlockSize
)
;
opaqueDst
+
=
EncodedBlockSize
;
}
}
if
(
x
+
width
>
endBlockX
)
{
this
-
>
updateBlockCol
(
endBlockX
y
x
+
width
-
endBlockX
endBlockY
endBlockX
innerStartBlockY
endBlockY
)
;
}
height
=
y
+
height
-
endBlockY
;
y
=
endBlockY
;
}
if
(
height
>
0
)
{
this
-
>
updateBlockRow
(
x
y
width
height
endBlockY
startBlockX
endBlockX
)
;
}
}
#
endif
}
void
blitAntiRect
(
int
x
int
y
int
width
int
height
SkAlpha
leftAlpha
SkAlpha
rightAlpha
)
override
{
SkFAIL
(
"
Not
implemented
!
"
)
;
}
#
ifdef
SK_DEBUG
bool
fBlitMaskCalled
;
#
endif
void
blitMask
(
const
SkMask
&
mask
const
SkIRect
&
clip
)
override
{
SkASSERT
(
!
fBlitMaskCalled
)
;
SkDEBUGCODE
(
fBlitMaskCalled
=
true
)
;
SkASSERT
(
SkMask
:
:
kA8_Format
=
=
mask
.
fFormat
)
;
SkASSERT
(
mask
.
fBounds
.
contains
(
clip
)
)
;
const
int
startI
=
BlockDim
*
(
clip
.
left
(
)
/
BlockDim
)
;
const
int
startJ
=
BlockDim
*
(
clip
.
top
(
)
/
BlockDim
)
;
for
(
int
j
=
startJ
;
j
<
clip
.
bottom
(
)
;
j
+
=
BlockDim
)
{
uint8_t
*
dst
=
this
-
>
getBlock
(
startI
j
)
;
for
(
int
i
=
startI
;
i
<
clip
.
right
(
)
;
i
+
=
BlockDim
)
{
SkASSERT
(
SkIRect
:
:
IntersectsNoEmptyCheck
(
SkIRect
:
:
MakeXYWH
(
i
j
BlockDim
BlockDim
)
clip
)
)
;
if
(
i
<
clip
.
left
(
)
|
|
j
<
clip
.
top
(
)
|
|
i
+
BlockDim
>
clip
.
right
(
)
|
|
j
+
BlockDim
>
clip
.
bottom
(
)
)
{
uint8_t
block
[
BlockDim
*
BlockDim
]
;
memset
(
block
0
sizeof
(
block
)
)
;
const
int
startX
=
SkMax32
(
i
clip
.
left
(
)
)
;
const
int
startY
=
SkMax32
(
j
clip
.
top
(
)
)
;
const
int
endX
=
SkMin32
(
i
+
BlockDim
clip
.
right
(
)
)
;
const
int
endY
=
SkMin32
(
j
+
BlockDim
clip
.
bottom
(
)
)
;
for
(
int
y
=
startY
;
y
<
endY
;
+
+
y
)
{
const
int
col
=
startX
-
i
;
const
int
row
=
y
-
j
;
const
int
valsWide
=
endX
-
startX
;
SkASSERT
(
valsWide
<
=
BlockDim
)
;
SkASSERT
(
0
<
=
col
&
&
col
<
BlockDim
)
;
SkASSERT
(
0
<
=
row
&
&
row
<
BlockDim
)
;
memcpy
(
block
+
row
*
BlockDim
+
col
mask
.
getAddr8
(
startX
j
+
row
)
valsWide
)
;
}
CompressorType
:
:
CompressA8Horizontal
(
dst
block
BlockDim
)
;
}
else
{
uint8_t
*
const
src
=
mask
.
getAddr8
(
i
j
)
;
const
uint32_t
rb
=
mask
.
fRowBytes
;
CompressorType
:
:
CompressA8Horizontal
(
dst
src
rb
)
;
}
dst
+
=
EncodedBlockSize
;
}
}
}
const
SkPixmap
*
justAnOpaqueColor
(
uint32_t
*
value
)
override
{
return
nullptr
;
}
int
requestRowsPreserved
(
)
const
override
{
return
BlockDim
;
}
private
:
static
const
int
kPixelsPerBlock
=
BlockDim
*
BlockDim
;
const
int16_t
kLongestRun
;
const
SkAlpha
kZeroAlpha
;
struct
BufferedRun
{
const
SkAlpha
*
fAlphas
;
const
int16_t
*
fRuns
;
int
fX
fY
;
}
fBufferedRuns
[
BlockDim
]
;
int
fNextRun
;
const
int
fWidth
;
const
int
fHeight
;
void
*
const
fBuffer
;
int
blocksWide
(
)
const
{
return
fWidth
/
BlockDim
;
}
int
blocksTall
(
)
const
{
return
fHeight
/
BlockDim
;
}
int
totalBlocks
(
)
const
{
return
(
fWidth
*
fHeight
)
/
kPixelsPerBlock
;
}
int
getBlockOffset
(
int
x
int
y
)
const
{
SkASSERT
(
x
<
fWidth
)
;
SkASSERT
(
y
<
fHeight
)
;
const
int
blockCol
=
x
/
BlockDim
;
const
int
blockRow
=
y
/
BlockDim
;
return
blockRow
*
this
-
>
blocksWide
(
)
+
blockCol
;
}
uint8_t
*
getBlock
(
int
x
int
y
)
const
{
uint8_t
*
ptr
=
reinterpret_cast
<
uint8_t
*
>
(
fBuffer
)
;
return
ptr
+
EncodedBlockSize
*
this
-
>
getBlockOffset
(
x
y
)
;
}
typedef
uint32_t
Column
[
BlockDim
/
4
]
;
typedef
uint32_t
Block
[
BlockDim
]
[
BlockDim
/
4
]
;
inline
void
updateBlockColumns
(
Block
block
const
int
col
const
int
colsLeft
const
Column
curAlphai
)
{
SkASSERT
(
block
)
;
SkASSERT
(
col
+
colsLeft
<
=
BlockDim
)
;
for
(
int
i
=
col
;
i
<
(
col
+
colsLeft
)
;
+
+
i
)
{
memcpy
(
block
[
i
]
curAlphai
sizeof
(
Column
)
)
;
}
}
void
flushRuns
(
)
{
if
(
0
=
=
fNextRun
)
{
return
;
}
#
ifndef
NDEBUG
for
(
int
i
=
1
;
i
<
fNextRun
;
+
+
i
)
{
SkASSERT
(
fBufferedRuns
[
i
]
.
fY
=
=
fBufferedRuns
[
i
-
1
]
.
fY
+
1
)
;
SkASSERT
(
fBufferedRuns
[
i
]
.
fX
=
=
fBufferedRuns
[
i
-
1
]
.
fX
)
;
}
#
endif
for
(
int
i
=
fNextRun
;
i
<
BlockDim
;
+
+
i
)
{
fBufferedRuns
[
i
]
.
fY
=
fBufferedRuns
[
0
]
.
fY
+
i
;
fBufferedRuns
[
i
]
.
fX
=
fBufferedRuns
[
0
]
.
fX
;
fBufferedRuns
[
i
]
.
fAlphas
=
&
kZeroAlpha
;
fBufferedRuns
[
i
]
.
fRuns
=
&
kLongestRun
;
}
SkASSERT
(
fNextRun
>
0
&
&
fNextRun
<
=
BlockDim
)
;
SkASSERT
(
(
fBufferedRuns
[
0
]
.
fY
%
BlockDim
)
=
=
0
)
;
Block
block
;
sk_bzero
(
block
sizeof
(
block
)
)
;
Column
curAlphaColumn
;
sk_bzero
(
curAlphaColumn
sizeof
(
curAlphaColumn
)
)
;
SkAlpha
*
curAlpha
=
reinterpret_cast
<
SkAlpha
*
>
(
&
curAlphaColumn
)
;
int
nextX
[
BlockDim
]
;
for
(
int
i
=
0
;
i
<
BlockDim
;
+
+
i
)
{
nextX
[
i
]
=
0x7FFFFF
;
}
uint8_t
*
outPtr
=
this
-
>
getBlock
(
fBufferedRuns
[
0
]
.
fX
fBufferedRuns
[
0
]
.
fY
)
;
int
curX
=
0
;
int
finalX
=
0xFFFFF
;
for
(
int
i
=
0
;
i
<
BlockDim
;
+
+
i
)
{
nextX
[
i
]
=
*
(
fBufferedRuns
[
i
]
.
fRuns
)
;
curAlpha
[
i
]
=
*
(
fBufferedRuns
[
i
]
.
fAlphas
)
;
finalX
=
SkMin32
(
nextX
[
i
]
finalX
)
;
}
SkASSERT
(
finalX
<
0xFFFFF
)
;
if
(
kLongestRun
=
=
finalX
)
{
finalX
=
fWidth
;
}
while
(
curX
!
=
finalX
)
{
SkASSERT
(
finalX
>
=
curX
)
;
if
(
(
finalX
-
(
BlockDim
*
(
curX
/
BlockDim
)
)
)
>
=
BlockDim
)
{
const
int
col
=
curX
%
BlockDim
;
const
int
colsLeft
=
BlockDim
-
col
;
SkASSERT
(
curX
+
colsLeft
<
=
finalX
)
;
this
-
>
updateBlockColumns
(
block
col
colsLeft
curAlphaColumn
)
;
CompressorType
:
:
CompressA8Vertical
(
outPtr
reinterpret_cast
<
uint8_t
*
>
(
block
)
)
;
outPtr
+
=
EncodedBlockSize
;
curX
+
=
colsLeft
;
}
if
(
(
finalX
-
curX
)
>
=
BlockDim
)
{
SkASSERT
(
(
curX
%
BlockDim
)
=
=
0
)
;
const
int
col
=
0
;
const
int
colsLeft
=
BlockDim
;
this
-
>
updateBlockColumns
(
block
col
colsLeft
curAlphaColumn
)
;
uint8_t
lastBlock
[
EncodedBlockSize
]
;
CompressorType
:
:
CompressA8Vertical
(
lastBlock
reinterpret_cast
<
uint8_t
*
>
(
block
)
)
;
while
(
(
finalX
-
curX
)
>
=
BlockDim
)
{
memcpy
(
outPtr
lastBlock
EncodedBlockSize
)
;
outPtr
+
=
EncodedBlockSize
;
curX
+
=
BlockDim
;
}
}
if
(
curX
<
finalX
)
{
const
int
col
=
curX
%
BlockDim
;
const
int
colsLeft
=
finalX
-
curX
;
this
-
>
updateBlockColumns
(
block
col
colsLeft
curAlphaColumn
)
;
curX
+
=
colsLeft
;
}
SkASSERT
(
curX
=
=
finalX
)
;
if
(
finalX
<
fWidth
)
{
for
(
int
i
=
0
;
i
<
BlockDim
;
+
+
i
)
{
if
(
nextX
[
i
]
=
=
finalX
)
{
const
int16_t
run
=
*
(
fBufferedRuns
[
i
]
.
fRuns
)
;
fBufferedRuns
[
i
]
.
fRuns
+
=
run
;
fBufferedRuns
[
i
]
.
fAlphas
+
=
run
;
curAlpha
[
i
]
=
*
(
fBufferedRuns
[
i
]
.
fAlphas
)
;
nextX
[
i
]
+
=
*
(
fBufferedRuns
[
i
]
.
fRuns
)
;
}
}
finalX
=
0xFFFFF
;
for
(
int
i
=
0
;
i
<
BlockDim
;
+
+
i
)
{
finalX
=
SkMin32
(
nextX
[
i
]
finalX
)
;
}
}
else
{
curX
=
finalX
;
}
}
if
(
(
curX
%
BlockDim
)
>
0
)
{
#
ifdef
SK_DEBUG
for
(
int
i
=
0
;
i
<
BlockDim
;
+
+
i
)
{
SkASSERT
(
nextX
[
i
]
=
=
kLongestRun
|
|
nextX
[
i
]
=
=
curX
)
;
}
#
endif
const
int
col
=
curX
%
BlockDim
;
const
int
colsLeft
=
BlockDim
-
col
;
memset
(
curAlphaColumn
0
sizeof
(
curAlphaColumn
)
)
;
this
-
>
updateBlockColumns
(
block
col
colsLeft
curAlphaColumn
)
;
CompressorType
:
:
CompressA8Vertical
(
outPtr
reinterpret_cast
<
uint8_t
*
>
(
block
)
)
;
}
fNextRun
=
0
;
}
#
if
PEDANTIC_BLIT_RECT
void
updateBlockRow
(
int
x
int
y
int
width
int
height
int
blockRow
int
startBlockX
int
endBlockX
)
{
if
(
0
=
=
width
|
|
0
=
=
height
|
|
startBlockX
=
=
endBlockX
)
{
return
;
}
uint8_t
*
dst
=
this
-
>
getBlock
(
startBlockX
BlockDim
*
(
y
/
BlockDim
)
)
;
uint8_t
mask
[
BlockDim
*
BlockDim
]
;
memset
(
mask
0
sizeof
(
mask
)
)
;
int
blockX
=
startBlockX
;
const
int
yoff
=
y
-
blockRow
;
for
(
int
j
=
0
;
j
<
height
;
+
+
j
)
{
const
int
xoff
=
x
-
blockX
;
memset
(
mask
+
(
j
+
yoff
)
*
BlockDim
+
xoff
0xFF
BlockDim
-
xoff
)
;
}
CompressorType
:
:
UpdateBlock
(
dst
mask
BlockDim
mask
)
;
dst
+
=
EncodedBlockSize
;
blockX
+
=
BlockDim
;
if
(
blockX
<
endBlockX
)
{
for
(
int
j
=
0
;
j
<
height
;
+
+
j
)
{
memset
(
mask
+
(
j
+
yoff
)
*
BlockDim
0xFF
BlockDim
)
;
}
while
(
blockX
<
endBlockX
)
{
CompressorType
:
:
UpdateBlock
(
dst
mask
BlockDim
mask
)
;
dst
+
=
EncodedBlockSize
;
blockX
+
=
BlockDim
;
}
}
SkASSERT
(
endBlockX
=
=
blockX
)
;
if
(
x
+
width
>
endBlockX
)
{
memset
(
mask
0
sizeof
(
mask
)
)
;
for
(
int
j
=
0
;
j
<
height
;
+
+
j
)
{
const
int
xoff
=
(
x
+
width
-
blockX
)
;
memset
(
mask
+
(
j
+
yoff
)
*
BlockDim
0xFF
xoff
)
;
}
CompressorType
:
:
UpdateBlock
(
dst
mask
BlockDim
mask
)
;
}
}
void
updateBlockCol
(
int
x
int
y
int
width
int
height
int
blockCol
int
startBlockY
int
endBlockY
)
{
if
(
0
=
=
width
|
|
0
=
=
height
|
|
startBlockY
=
=
endBlockY
)
{
return
;
}
uint8_t
mask
[
BlockDim
*
BlockDim
]
;
memset
(
mask
0
sizeof
(
mask
)
)
;
const
int
maskX0
=
x
-
blockCol
;
const
int
maskWidth
=
maskX0
+
width
;
SkASSERT
(
maskWidth
<
=
BlockDim
)
;
int
blockY
=
startBlockY
;
for
(
int
j
=
(
y
-
blockY
)
;
j
<
BlockDim
;
+
+
j
)
{
memset
(
mask
+
maskX0
+
j
*
BlockDim
0xFF
maskWidth
)
;
}
CompressorType
:
:
UpdateBlock
(
this
-
>
getBlock
(
blockCol
blockY
)
mask
BlockDim
mask
)
;
blockY
+
=
BlockDim
;
if
(
blockY
<
endBlockY
)
{
for
(
int
j
=
0
;
j
<
BlockDim
;
+
+
j
)
{
memset
(
mask
+
maskX0
+
j
*
BlockDim
0xFF
maskWidth
)
;
}
while
(
blockY
<
endBlockY
)
{
CompressorType
:
:
UpdateBlock
(
this
-
>
getBlock
(
blockCol
blockY
)
mask
BlockDim
mask
)
;
blockY
+
=
BlockDim
;
}
}
SkASSERT
(
endBlockY
=
=
blockY
)
;
if
(
y
+
height
>
endBlockY
)
{
for
(
int
j
=
y
+
height
;
j
<
endBlockY
+
BlockDim
;
+
+
j
)
{
memset
(
mask
+
(
j
-
endBlockY
)
*
BlockDim
0
BlockDim
)
;
}
CompressorType
:
:
UpdateBlock
(
this
-
>
getBlock
(
blockCol
blockY
)
mask
BlockDim
mask
)
;
}
}
#
endif
}
;
}
#
endif
