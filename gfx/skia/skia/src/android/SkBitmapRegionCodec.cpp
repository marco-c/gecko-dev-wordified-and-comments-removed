#
include
"
SkAndroidCodec
.
h
"
#
include
"
SkBitmapRegionCodec
.
h
"
#
include
"
SkBitmapRegionDecoderPriv
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkPixelRef
.
h
"
SkBitmapRegionCodec
:
:
SkBitmapRegionCodec
(
SkAndroidCodec
*
codec
)
:
INHERITED
(
codec
-
>
getInfo
(
)
.
width
(
)
codec
-
>
getInfo
(
)
.
height
(
)
)
fCodec
(
codec
)
{
}
bool
SkBitmapRegionCodec
:
:
decodeRegion
(
SkBitmap
*
bitmap
SkBRDAllocator
*
allocator
const
SkIRect
&
desiredSubset
int
sampleSize
SkColorType
dstColorType
bool
requireUnpremul
)
{
if
(
sampleSize
<
1
)
{
sampleSize
=
1
;
}
int
outX
;
int
outY
;
SkIRect
subset
=
desiredSubset
;
SubsetType
type
=
adjust_subset_rect
(
fCodec
-
>
getInfo
(
)
.
dimensions
(
)
&
subset
&
outX
&
outY
)
;
if
(
SubsetType
:
:
kOutside_SubsetType
=
=
type
)
{
return
false
;
}
if
(
!
fCodec
-
>
getSupportedSubset
(
&
subset
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
get
subset
.
\
n
"
)
;
return
false
;
}
SkISize
scaledSize
=
fCodec
-
>
getSampledSubsetDimensions
(
sampleSize
subset
)
;
SkAlphaType
dstAlphaType
=
fCodec
-
>
getInfo
(
)
.
alphaType
(
)
;
if
(
kOpaque_SkAlphaType
!
=
dstAlphaType
)
{
dstAlphaType
=
requireUnpremul
?
kUnpremul_SkAlphaType
:
kPremul_SkAlphaType
;
}
SkImageInfo
decodeInfo
=
SkImageInfo
:
:
Make
(
scaledSize
.
width
(
)
scaledSize
.
height
(
)
dstColorType
dstAlphaType
)
;
SkAutoTUnref
<
SkColorTable
>
colorTable
(
nullptr
)
;
SkPMColor
*
colorPtr
=
nullptr
;
int
*
colorCountPtr
=
nullptr
;
int
maxColors
=
256
;
SkPMColor
colors
[
256
]
;
if
(
kIndex_8_SkColorType
=
=
dstColorType
)
{
colorTable
.
reset
(
new
SkColorTable
(
colors
maxColors
)
)
;
colorPtr
=
const_cast
<
SkPMColor
*
>
(
colorTable
-
>
readColors
(
)
)
;
colorCountPtr
=
&
maxColors
;
}
int
scaledOutX
=
0
;
int
scaledOutY
=
0
;
int
scaledOutWidth
=
scaledSize
.
width
(
)
;
int
scaledOutHeight
=
scaledSize
.
height
(
)
;
if
(
SubsetType
:
:
kPartiallyInside_SubsetType
=
=
type
)
{
scaledOutX
=
outX
/
sampleSize
;
scaledOutY
=
outY
/
sampleSize
;
const
int
extraX
=
SkTMax
(
0
desiredSubset
.
width
(
)
-
outX
-
subset
.
width
(
)
)
;
const
int
extraY
=
SkTMax
(
0
desiredSubset
.
height
(
)
-
outY
-
subset
.
height
(
)
)
;
const
int
scaledExtraX
=
extraX
/
sampleSize
;
const
int
scaledExtraY
=
extraY
/
sampleSize
;
scaledOutWidth
+
=
scaledOutX
+
scaledExtraX
;
scaledOutHeight
+
=
scaledOutY
+
scaledExtraY
;
}
SkImageInfo
outInfo
=
decodeInfo
.
makeWH
(
scaledOutWidth
scaledOutHeight
)
;
bitmap
-
>
setInfo
(
outInfo
)
;
if
(
!
bitmap
-
>
tryAllocPixels
(
allocator
colorTable
.
get
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
allocate
pixels
.
\
n
"
)
;
return
false
;
}
SkCodec
:
:
ZeroInitialized
zeroInit
=
allocator
?
allocator
-
>
zeroInit
(
)
:
SkCodec
:
:
kNo_ZeroInitialized
;
if
(
SubsetType
:
:
kPartiallyInside_SubsetType
=
=
type
&
&
SkCodec
:
:
kNo_ZeroInitialized
=
=
zeroInit
)
{
void
*
pixels
=
bitmap
-
>
getPixels
(
)
;
size_t
bytes
=
outInfo
.
getSafeSize
(
bitmap
-
>
rowBytes
(
)
)
;
memset
(
pixels
0
bytes
)
;
}
SkAndroidCodec
:
:
AndroidOptions
options
;
options
.
fSampleSize
=
sampleSize
;
options
.
fSubset
=
&
subset
;
options
.
fColorPtr
=
colorPtr
;
options
.
fColorCount
=
colorCountPtr
;
options
.
fZeroInitialized
=
zeroInit
;
void
*
dst
=
bitmap
-
>
getAddr
(
scaledOutX
scaledOutY
)
;
SkPixelRef
*
pr
=
SkRef
(
bitmap
-
>
pixelRef
(
)
)
;
size_t
rowBytes
=
pr
-
>
rowBytes
(
)
;
bitmap
-
>
setInfo
(
outInfo
rowBytes
)
;
bitmap
-
>
setPixelRef
(
pr
)
-
>
unref
(
)
;
bitmap
-
>
lockPixels
(
)
;
SkCodec
:
:
Result
result
=
fCodec
-
>
getAndroidPixels
(
decodeInfo
dst
rowBytes
&
options
)
;
if
(
SkCodec
:
:
kSuccess
!
=
result
&
&
SkCodec
:
:
kIncompleteInput
!
=
result
)
{
SkCodecPrintf
(
"
Error
:
Could
not
get
pixels
.
\
n
"
)
;
return
false
;
}
return
true
;
}
bool
SkBitmapRegionCodec
:
:
conversionSupported
(
SkColorType
colorType
)
{
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
0
0
colorType
fCodec
-
>
getInfo
(
)
.
alphaType
(
)
fCodec
-
>
getInfo
(
)
.
profileType
(
)
)
;
return
conversion_possible
(
info
fCodec
-
>
getInfo
(
)
)
;
}
