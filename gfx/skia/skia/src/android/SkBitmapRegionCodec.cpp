#
include
"
SkAndroidCodec
.
h
"
#
include
"
SkBitmapRegionCodec
.
h
"
#
include
"
SkBitmapRegionDecoderPriv
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkPixelRef
.
h
"
SkBitmapRegionCodec
:
:
SkBitmapRegionCodec
(
SkAndroidCodec
*
codec
)
:
INHERITED
(
codec
-
>
getInfo
(
)
.
width
(
)
codec
-
>
getInfo
(
)
.
height
(
)
)
fCodec
(
codec
)
{
}
bool
SkBitmapRegionCodec
:
:
decodeRegion
(
SkBitmap
*
bitmap
SkBRDAllocator
*
allocator
const
SkIRect
&
desiredSubset
int
sampleSize
SkColorType
prefColorType
bool
requireUnpremul
)
{
if
(
sampleSize
<
1
)
{
sampleSize
=
1
;
}
int
outX
;
int
outY
;
SkIRect
subset
=
desiredSubset
;
SubsetType
type
=
adjust_subset_rect
(
fCodec
-
>
getInfo
(
)
.
dimensions
(
)
&
subset
&
outX
&
outY
)
;
if
(
SubsetType
:
:
kOutside_SubsetType
=
=
type
)
{
return
false
;
}
if
(
!
fCodec
-
>
getSupportedSubset
(
&
subset
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
get
subset
.
\
n
"
)
;
return
false
;
}
SkISize
scaledSize
=
fCodec
-
>
getSampledSubsetDimensions
(
sampleSize
subset
)
;
SkColorType
dstColorType
=
fCodec
-
>
computeOutputColorType
(
prefColorType
)
;
SkAlphaType
dstAlphaType
=
fCodec
-
>
computeOutputAlphaType
(
requireUnpremul
)
;
sk_sp
<
SkColorSpace
>
colorSpace
=
nullptr
;
SkImageInfo
decodeInfo
=
SkImageInfo
:
:
Make
(
scaledSize
.
width
(
)
scaledSize
.
height
(
)
dstColorType
dstAlphaType
colorSpace
)
;
SkAutoTUnref
<
SkColorTable
>
colorTable
(
nullptr
)
;
int
maxColors
=
256
;
SkPMColor
colors
[
256
]
;
if
(
kIndex_8_SkColorType
=
=
dstColorType
)
{
colorTable
.
reset
(
new
SkColorTable
(
colors
maxColors
)
)
;
}
int
scaledOutX
=
0
;
int
scaledOutY
=
0
;
int
scaledOutWidth
=
scaledSize
.
width
(
)
;
int
scaledOutHeight
=
scaledSize
.
height
(
)
;
if
(
SubsetType
:
:
kPartiallyInside_SubsetType
=
=
type
)
{
scaledOutX
=
outX
/
sampleSize
;
scaledOutY
=
outY
/
sampleSize
;
const
int
extraX
=
SkTMax
(
0
desiredSubset
.
width
(
)
-
outX
-
subset
.
width
(
)
)
;
const
int
extraY
=
SkTMax
(
0
desiredSubset
.
height
(
)
-
outY
-
subset
.
height
(
)
)
;
const
int
scaledExtraX
=
extraX
/
sampleSize
;
const
int
scaledExtraY
=
extraY
/
sampleSize
;
scaledOutWidth
+
=
scaledOutX
+
scaledExtraX
;
scaledOutHeight
+
=
scaledOutY
+
scaledExtraY
;
}
SkImageInfo
outInfo
=
decodeInfo
.
makeWH
(
scaledOutWidth
scaledOutHeight
)
;
if
(
kGray_8_SkColorType
=
=
dstColorType
)
{
outInfo
=
outInfo
.
makeColorType
(
kAlpha_8_SkColorType
)
.
makeAlphaType
(
kPremul_SkAlphaType
)
;
}
bitmap
-
>
setInfo
(
outInfo
)
;
if
(
!
bitmap
-
>
tryAllocPixels
(
allocator
colorTable
.
get
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
allocate
pixels
.
\
n
"
)
;
return
false
;
}
SkCodec
:
:
ZeroInitialized
zeroInit
=
allocator
?
allocator
-
>
zeroInit
(
)
:
SkCodec
:
:
kNo_ZeroInitialized
;
if
(
SubsetType
:
:
kPartiallyInside_SubsetType
=
=
type
&
&
SkCodec
:
:
kNo_ZeroInitialized
=
=
zeroInit
)
{
void
*
pixels
=
bitmap
-
>
getPixels
(
)
;
size_t
bytes
=
outInfo
.
getSafeSize
(
bitmap
-
>
rowBytes
(
)
)
;
memset
(
pixels
0
bytes
)
;
}
SkAndroidCodec
:
:
AndroidOptions
options
;
options
.
fSampleSize
=
sampleSize
;
options
.
fSubset
=
&
subset
;
options
.
fColorPtr
=
colors
;
options
.
fColorCount
=
&
maxColors
;
options
.
fZeroInitialized
=
zeroInit
;
void
*
dst
=
bitmap
-
>
getAddr
(
scaledOutX
scaledOutY
)
;
SkCodec
:
:
Result
result
=
fCodec
-
>
getAndroidPixels
(
decodeInfo
dst
bitmap
-
>
rowBytes
(
)
&
options
)
;
if
(
SkCodec
:
:
kSuccess
!
=
result
&
&
SkCodec
:
:
kIncompleteInput
!
=
result
)
{
SkCodecPrintf
(
"
Error
:
Could
not
get
pixels
.
\
n
"
)
;
return
false
;
}
if
(
kIndex_8_SkColorType
=
=
dstColorType
)
{
colorTable
-
>
dangerous_overwriteColors
(
colors
maxColors
)
;
}
return
true
;
}
bool
SkBitmapRegionCodec
:
:
conversionSupported
(
SkColorType
colorType
)
{
sk_sp
<
SkColorSpace
>
colorSpace
=
nullptr
;
SkImageInfo
dstInfo
=
fCodec
-
>
getInfo
(
)
.
makeColorType
(
colorType
)
.
makeColorSpace
(
colorSpace
)
;
return
conversion_possible_ignore_color_space
(
dstInfo
fCodec
-
>
getInfo
(
)
)
;
}
