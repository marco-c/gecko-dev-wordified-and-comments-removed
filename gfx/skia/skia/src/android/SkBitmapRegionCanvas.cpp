#
include
"
SkBitmapRegionCanvas
.
h
"
#
include
"
SkBitmapRegionDecoderPriv
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
"
SkCodecPriv
.
h
"
SkBitmapRegionCanvas
:
:
SkBitmapRegionCanvas
(
SkCodec
*
decoder
)
:
INHERITED
(
decoder
-
>
getInfo
(
)
.
width
(
)
decoder
-
>
getInfo
(
)
.
height
(
)
)
fDecoder
(
decoder
)
{
}
bool
SkBitmapRegionCanvas
:
:
decodeRegion
(
SkBitmap
*
bitmap
SkBRDAllocator
*
allocator
const
SkIRect
&
desiredSubset
int
sampleSize
SkColorType
dstColorType
bool
requireUnpremul
)
{
if
(
kIndex_8_SkColorType
=
=
dstColorType
|
|
kGray_8_SkColorType
=
=
dstColorType
)
{
SkCodecPrintf
(
"
Error
:
Color
type
not
supported
.
\
n
"
)
;
return
false
;
}
if
(
requireUnpremul
)
{
SkCodecPrintf
(
"
Error
:
Alpha
type
not
supported
.
\
n
"
)
;
return
false
;
}
SkAlphaType
dstAlphaType
=
fDecoder
-
>
getInfo
(
)
.
alphaType
(
)
;
if
(
kUnpremul_SkAlphaType
=
=
dstAlphaType
)
{
dstAlphaType
=
kPremul_SkAlphaType
;
}
if
(
sampleSize
<
1
)
{
sampleSize
=
1
;
}
int
outX
;
int
outY
;
SkIRect
subset
=
desiredSubset
;
SubsetType
type
=
adjust_subset_rect
(
fDecoder
-
>
getInfo
(
)
.
dimensions
(
)
&
subset
&
outX
&
outY
)
;
if
(
SubsetType
:
:
kOutside_SubsetType
=
=
type
)
{
return
false
;
}
SkImageInfo
decodeInfo
=
SkImageInfo
:
:
Make
(
this
-
>
width
(
)
this
-
>
height
(
)
dstColorType
dstAlphaType
)
;
SkCodec
:
:
Result
r
=
fDecoder
-
>
startScanlineDecode
(
decodeInfo
)
;
if
(
SkCodec
:
:
kSuccess
!
=
r
)
{
SkCodecPrintf
(
"
Error
:
Could
not
start
scanline
decoder
.
\
n
"
)
;
return
false
;
}
SkBitmap
tmp
;
SkImageInfo
tmpInfo
=
decodeInfo
.
makeWH
(
this
-
>
width
(
)
subset
.
height
(
)
)
;
if
(
!
tmp
.
tryAllocPixels
(
tmpInfo
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
allocate
pixels
.
\
n
"
)
;
return
false
;
}
if
(
!
fDecoder
-
>
skipScanlines
(
subset
.
y
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
Failed
to
skip
scanlines
.
\
n
"
)
;
return
false
;
}
fDecoder
-
>
getScanlines
(
tmp
.
getAddr
(
0
0
)
subset
.
height
(
)
tmp
.
rowBytes
(
)
)
;
const
int
outWidth
=
get_scaled_dimension
(
desiredSubset
.
width
(
)
sampleSize
)
;
const
int
outHeight
=
get_scaled_dimension
(
desiredSubset
.
height
(
)
sampleSize
)
;
SkImageInfo
dstInfo
=
decodeInfo
.
makeWH
(
outWidth
outHeight
)
;
bitmap
-
>
setInfo
(
dstInfo
dstInfo
.
minRowBytes
(
)
)
;
if
(
!
bitmap
-
>
tryAllocPixels
(
allocator
nullptr
)
)
{
SkCodecPrintf
(
"
Error
:
Could
not
allocate
pixels
.
\
n
"
)
;
return
false
;
}
if
(
SubsetType
:
:
kPartiallyInside_SubsetType
=
=
type
)
{
SkCodec
:
:
ZeroInitialized
zeroInit
=
allocator
?
allocator
-
>
zeroInit
(
)
:
SkCodec
:
:
kNo_ZeroInitialized
;
if
(
SkCodec
:
:
kNo_ZeroInitialized
=
=
zeroInit
)
{
bitmap
-
>
eraseColor
(
0
)
;
}
}
SkCanvas
canvas
(
*
bitmap
)
;
SkRect
src
=
SkRect
:
:
MakeXYWH
(
(
SkScalar
)
subset
.
x
(
)
(
SkScalar
)
0
(
SkScalar
)
subset
.
width
(
)
(
SkScalar
)
subset
.
height
(
)
)
;
SkRect
dst
=
SkRect
:
:
MakeXYWH
(
(
SkScalar
)
(
outX
/
sampleSize
)
(
SkScalar
)
(
outY
/
sampleSize
)
(
SkScalar
)
get_scaled_dimension
(
subset
.
width
(
)
sampleSize
)
(
SkScalar
)
get_scaled_dimension
(
subset
.
height
(
)
sampleSize
)
)
;
SkPaint
paint
;
paint
.
setXfermodeMode
(
SkXfermode
:
:
kSrc_Mode
)
;
canvas
.
drawBitmapRect
(
tmp
src
dst
&
paint
)
;
return
true
;
}
bool
SkBitmapRegionCanvas
:
:
conversionSupported
(
SkColorType
colorType
)
{
if
(
kIndex_8_SkColorType
=
=
colorType
|
|
kGray_8_SkColorType
=
=
colorType
)
{
return
false
;
}
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
0
0
colorType
fDecoder
-
>
getInfo
(
)
.
alphaType
(
)
fDecoder
-
>
getInfo
(
)
.
profileType
(
)
)
;
return
conversion_possible
(
info
fDecoder
-
>
getInfo
(
)
)
;
}
