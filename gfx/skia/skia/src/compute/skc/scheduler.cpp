extern
"
C
"
{
#
include
"
scheduler
.
h
"
#
include
"
runtime_cl_12
.
h
"
}
#
include
<
mutex
>
#
include
<
condition_variable
>
typedef
enum
skc_scheduler_command_state
{
SKC_SCHEDULER_COMMAND_STATE_READY
SKC_SCHEDULER_COMMAND_STATE_WAITING
SKC_SCHEDULER_COMMAND_STATE_EXECUTING
SKC_SCHEDULER_COMMAND_STATE_COMPLETED
SKC_SCHEDULER_COMMAND_STATE_COUNT
}
skc_scheduler_command_state
;
struct
skc_scheduler_command
{
void
*
data
;
skc_scheduler_command_pfn
pfn
;
skc_scheduler_command_state
state
;
char
const
*
name
;
}
;
#
if
0
struct
skc_scheduler_command
{
union
{
struct
scheduler
*
scheduler
;
struct
skc_scheduler_command
*
next
;
}
;
skc_scheduler_command_pfn
pfn
;
}
;
#
endif
struct
skc_scheduler
{
struct
skc_scheduler_command
*
extent
;
struct
{
std
:
:
mutex
mutex
;
skc_ushort
*
indices
;
skc_uint
rem
;
}
available
;
struct
{
std
:
:
mutex
mutex
;
std
:
:
condition_variable
condvar
;
skc_ushort
*
indices
;
skc_uint
size
;
skc_uint
head
;
skc_uint
tail
;
}
waiting
;
}
;
#
if
1
#
define
SKC_SCHEDULER_EXECUTE
(
sc
)
\
sc
-
>
pfn
(
sc
-
>
data
)
#
else
#
define
SKC_SCHEDULER_EXECUTE
(
sc
)
\
fprintf
(
stderr
"
EXECUTE
+
%
s
\
n
"
sc
-
>
name
)
;
\
sc
-
>
pfn
(
sc
-
>
data
)
;
\
fprintf
(
stderr
"
EXECUTE
-
%
s
\
n
"
sc
-
>
name
)
;
#
endif
struct
skc_scheduler
*
skc_scheduler_create
(
struct
skc_runtime
*
const
runtime
skc_uint
const
size
)
{
struct
skc_scheduler
*
scheduler
=
(
struct
skc_scheduler
*
)
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
scheduler
)
)
;
new
(
scheduler
)
skc_scheduler
(
)
;
scheduler
-
>
extent
=
(
struct
skc_scheduler_command
*
)
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
(
sizeof
(
*
scheduler
-
>
extent
)
*
size
)
)
;
scheduler
-
>
available
.
indices
=
(
skc_ushort
*
)
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
scheduler
-
>
available
.
indices
)
*
size
)
;
scheduler
-
>
available
.
rem
=
size
;
scheduler
-
>
waiting
.
indices
=
(
skc_ushort
*
)
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
scheduler
-
>
available
.
indices
)
*
(
size
+
1
)
)
;
scheduler
-
>
waiting
.
size
=
size
+
1
;
scheduler
-
>
waiting
.
head
=
0
;
scheduler
-
>
waiting
.
tail
=
0
;
for
(
skc_uint
ii
=
0
;
ii
<
size
;
ii
+
+
)
scheduler
-
>
available
.
indices
[
ii
]
=
ii
;
return
scheduler
;
}
void
skc_scheduler_dispose
(
struct
skc_runtime
*
const
runtime
struct
skc_scheduler
*
const
scheduler
)
{
skc_runtime_host_perm_free
(
runtime
scheduler
-
>
waiting
.
indices
)
;
skc_runtime_host_perm_free
(
runtime
scheduler
-
>
available
.
indices
)
;
skc_runtime_host_perm_free
(
runtime
scheduler
-
>
extent
)
;
scheduler
-
>
~
skc_scheduler
(
)
;
skc_runtime_host_perm_free
(
runtime
scheduler
)
;
}
static
skc_scheduler_command_t
skc_scheduler_acquire
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_pfn
pfn
void
*
data
char
const
*
name
)
{
skc_scheduler_command_t
command
=
SKC_SCHEDULER_COMMAND_INVALID
;
{
std
:
:
lock_guard
<
std
:
:
mutex
>
lock
(
scheduler
-
>
available
.
mutex
)
;
if
(
scheduler
-
>
available
.
rem
>
0
)
command
=
scheduler
-
>
available
.
indices
[
-
-
scheduler
-
>
available
.
rem
]
;
}
if
(
command
!
=
SKC_SCHEDULER_COMMAND_INVALID
)
{
struct
skc_scheduler_command
*
const
sc
=
scheduler
-
>
extent
+
command
;
sc
-
>
pfn
=
pfn
;
sc
-
>
data
=
data
;
sc
-
>
name
=
name
;
sc
-
>
state
=
SKC_SCHEDULER_COMMAND_STATE_READY
;
}
return
command
;
}
static
void
skc_scheduler_release
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
const
command
)
{
std
:
:
lock_guard
<
std
:
:
mutex
>
lock
(
scheduler
-
>
available
.
mutex
)
;
scheduler
-
>
available
.
indices
[
scheduler
-
>
available
.
rem
+
+
]
=
command
;
}
static
void
skc_scheduler_append
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
const
command
)
{
scheduler
-
>
extent
[
command
]
.
state
=
SKC_SCHEDULER_COMMAND_STATE_WAITING
;
{
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
scheduler
-
>
waiting
.
mutex
)
;
scheduler
-
>
waiting
.
indices
[
scheduler
-
>
waiting
.
tail
]
=
command
;
if
(
+
+
scheduler
-
>
waiting
.
tail
=
=
scheduler
-
>
waiting
.
size
)
scheduler
-
>
waiting
.
tail
=
0
;
}
scheduler
-
>
waiting
.
condvar
.
notify_one
(
)
;
}
skc_scheduler_command_t
skc_scheduler_schedule
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_pfn
const
pfn
void
*
data
char
const
*
const
name
)
{
while
(
true
)
{
skc_scheduler_command_t
const
command
=
skc_scheduler_acquire
(
scheduler
pfn
data
name
)
;
if
(
command
!
=
SKC_SCHEDULER_COMMAND_INVALID
)
{
skc_scheduler_append
(
scheduler
command
)
;
return
command
;
}
else
{
skc_scheduler_wait
(
scheduler
)
;
}
}
}
static
void
skc_scheduler_pop
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
*
const
command
)
{
*
command
=
SKC_SCHEDULER_COMMAND_INVALID
;
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
scheduler
-
>
waiting
.
mutex
)
;
if
(
scheduler
-
>
waiting
.
head
!
=
scheduler
-
>
waiting
.
tail
)
{
*
command
=
scheduler
-
>
waiting
.
indices
[
scheduler
-
>
waiting
.
head
]
;
if
(
+
+
scheduler
-
>
waiting
.
head
=
=
scheduler
-
>
waiting
.
size
)
scheduler
-
>
waiting
.
head
=
0
;
}
}
static
void
skc_scheduler_pop_wait
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
*
const
command
)
{
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
scheduler
-
>
waiting
.
mutex
)
;
scheduler
-
>
waiting
.
condvar
.
wait
(
lock
[
scheduler
]
{
return
scheduler
-
>
waiting
.
head
!
=
scheduler
-
>
waiting
.
tail
;
}
)
;
*
command
=
scheduler
-
>
waiting
.
indices
[
scheduler
-
>
waiting
.
head
]
;
if
(
+
+
scheduler
-
>
waiting
.
head
=
=
scheduler
-
>
waiting
.
size
)
scheduler
-
>
waiting
.
head
=
0
;
}
static
void
skc_scheduler_command_execute
(
struct
skc_scheduler_command
*
const
sc
)
{
sc
-
>
state
=
SKC_SCHEDULER_COMMAND_STATE_EXECUTING
;
SKC_SCHEDULER_EXECUTE
(
sc
)
;
sc
-
>
state
=
SKC_SCHEDULER_COMMAND_STATE_COMPLETED
;
}
static
void
skc_scheduler_execute
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
const
command
)
{
skc_scheduler_command_execute
(
scheduler
-
>
extent
+
command
)
;
skc_scheduler_release
(
scheduler
command
)
;
}
skc_bool
skc_scheduler_yield
(
struct
skc_scheduler
*
const
scheduler
)
{
while
(
true
)
{
skc_scheduler_command_t
command
;
skc_scheduler_pop
(
scheduler
&
command
)
;
if
(
command
=
=
SKC_SCHEDULER_COMMAND_INVALID
)
{
return
false
;
}
skc_scheduler_execute
(
scheduler
command
)
;
}
return
true
;
}
void
skc_scheduler_wait
(
struct
skc_scheduler
*
const
scheduler
)
{
skc_scheduler_command_t
command
;
skc_scheduler_pop_wait
(
scheduler
&
command
)
;
skc_scheduler_execute
(
scheduler
command
)
;
skc_scheduler_yield
(
scheduler
)
;
}
void
skc_scheduler_wait_one
(
struct
skc_scheduler
*
const
scheduler
)
{
skc_scheduler_command_t
command
;
skc_scheduler_pop_wait
(
scheduler
&
command
)
;
skc_scheduler_execute
(
scheduler
command
)
;
}
#
if
0
skc_bool
skc_scheduler_wait_for
(
struct
skc_scheduler
*
const
scheduler
skc_scheduler_command_t
const
command
)
{
struct
skc_scheduler_command
*
const
sc
=
scheduler
-
>
extent
+
command
;
if
(
sc
-
>
state
=
=
SKC_SCHEDULER_COMMAND_STATE_READY
)
return
false
;
if
(
sc
-
>
state
=
=
SKC_SCHEDULER_COMMAND_STATE_COMPLETED
)
return
true
;
while
(
true
)
{
skc_scheduler_command_t
next
;
skc_scheduler_pop_wait
(
scheduler
&
next
)
;
skc_scheduler_execute
(
scheduler
next
)
;
if
(
next
=
=
command
)
return
true
;
}
}
void
skc_thread_sleep
(
skc_ulong
const
msecs
)
{
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
msecs
)
)
;
}
#
endif
