#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
conio
.
h
>
#
include
"
common
/
cl
/
find_cl
.
h
"
#
include
"
common
/
cl
/
assert_cl
.
h
"
#
include
"
ts
/
transform_stack
.
h
"
#
ifdef
SKC_TEST_SVG
#
include
"
svg
/
svg_doc
.
h
"
#
include
"
svg2skc
/
svg2skc
.
h
"
#
define
SKC_TEST
(
f
.
.
.
)
svg_doc_
#
#
f
(
svg_doc
__VA_ARGS__
)
void
svg_doc_toggle
(
struct
svg_doc
*
sd
)
{
;
}
;
#
else
#
include
"
tests
/
groups
/
groups
.
h
"
#
define
SKC_TEST
(
f
.
.
.
)
groups_
#
#
f
(
__VA_ARGS__
)
#
endif
#
include
"
platforms
/
cl_12
/
skc_cl
.
h
"
#
include
"
interop
.
h
"
typedef
enum
skc_pipeline_start_at_e
{
SKC_PIPELINE_START_AT_DEFINE_PATHS
=
'
1
'
SKC_PIPELINE_START_AT_RASTERIZE
=
'
2
'
SKC_PIPELINE_START_AT_COMPOSITION
=
'
3
'
SKC_PIPELINE_START_AT_RENDER
=
'
4
'
}
skc_pipeline_start_at_e
;
#
if
0
static
void
is_render_complete
(
skc_surface_t
surface
skc_styling_t
styling
skc_composition_t
composition
skc_framebuffer_t
fb
void
*
data
)
{
*
(
bool
*
)
data
=
true
;
}
#
endif
void
skc_runtime_cl_12_debug
(
struct
skc_context
*
const
context
)
;
int
main
(
int
argc
char
const
*
argv
[
]
)
{
if
(
argc
<
=
1
)
{
fprintf
(
stderr
"
-
-
missing
filename
\
n
"
)
;
return
EXIT_FAILURE
;
}
#
ifdef
SKC_TEST_SVG
struct
svg_doc
*
svg_doc
=
svg_doc_parse
(
argv
[
1
]
false
)
;
fprintf
(
stderr
"
p
/
r
/
l
=
%
u
/
%
u
/
%
u
\
n
"
svg_doc_path_count
(
svg_doc
)
svg_doc_raster_count
(
svg_doc
)
svg_doc_layer_count
(
svg_doc
)
)
;
#
endif
struct
skc_interop
*
interop
=
skc_interop_create
(
)
;
cl_platform_id
platform_id_cl
;
cl_device_id
device_id_cl
;
cl
(
FindIdsByName
(
"
Intel
"
"
Graphics
"
&
platform_id_cl
&
device_id_cl
0
NULL
NULL
true
)
)
;
#
ifdef
_WIN32
cl_context_properties
context_properties_cl
[
]
=
{
CL_CONTEXT_PLATFORM
(
cl_context_properties
)
platform_id_cl
CL_GL_CONTEXT_KHR
skc_interop_get_wgl_context
(
)
CL_WGL_HDC_KHR
skc_interop_get_wgl_dc
(
)
0
}
;
#
else
#
error
"
Missing
a
system
-
compatible
context
!
"
#
endif
cl_int
cl_err
;
cl_context
context_cl
=
clCreateContext
(
context_properties_cl
1
&
device_id_cl
NULL
NULL
&
cl_err
)
;
cl_ok
(
cl_err
)
;
skc_interop_set_cl_context
(
interop
context_cl
)
;
skc_context_t
context
;
skc_err
err
=
skc_context_create_cl
(
&
context
context_cl
device_id_cl
)
;
skc_path_builder_t
path_builder
;
err
=
skc_path_builder_create
(
context
&
path_builder
)
;
skc_raster_builder_t
raster_builder
;
err
=
skc_raster_builder_create
(
context
&
raster_builder
)
;
skc_composition_t
composition
;
err
=
skc_composition_create
(
context
&
composition
)
;
skc_styling_t
styling
;
err
=
skc_styling_create
(
context
&
styling
SKC_TEST
(
layer_count
)
1000
2
*
1024
*
1024
)
;
skc_surface_t
surface
;
err
=
skc_surface_create
(
context
&
surface
)
;
struct
ts_transform_stack
*
ts
=
ts_transform_stack_create
(
32
)
;
ts_transform_stack_push_scale
(
ts
32
.
0
32
.
0
)
;
skc_pipeline_start_at_e
pipeline_start_at_base
=
SKC_PIPELINE_START_AT_DEFINE_PATHS
;
skc_pipeline_start_at_e
pipeline_start_at_loop
=
SKC_PIPELINE_START_AT_DEFINE_PATHS
;
skc_path_t
*
paths
;
skc_raster_t
*
rasters
;
while
(
!
skc_interop_should_exit
(
interop
)
)
{
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_DEFINE_PATHS
)
{
paths
=
SKC_TEST
(
paths_decode
path_builder
)
;
}
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_RASTERIZE
)
{
uint32_t
const
ts_save
=
ts_transform_stack_save
(
ts
)
;
skc_interop_transform
(
interop
ts
)
;
rasters
=
SKC_TEST
(
rasters_decode
ts
paths
raster_builder
)
;
ts_transform_stack_restore
(
ts
ts_save
)
;
}
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_COMPOSITION
)
{
skc_styling_reset
(
styling
)
;
skc_composition_unseal
(
composition
true
)
;
SKC_TEST
(
layers_decode
rasters
composition
styling
true
)
;
skc_styling_seal
(
styling
)
;
skc_composition_seal
(
composition
)
;
}
uint32_t
const
clip
[
]
=
{
0
0
65535
65535
}
;
int32_t
const
txty
[
]
=
{
0
0
}
;
skc_surface_render
(
surface
styling
composition
skc_interop_get_framebuffer
(
interop
)
clip
txty
NULL
NULL
)
;
int
key
;
bool
const
transform_changed
=
skc_interop_poll
(
interop
&
key
)
;
if
(
key
=
=
'
I
'
)
skc_runtime_cl_12_debug
(
context
)
;
else
if
(
key
=
=
'
T
'
)
SKC_TEST
(
toggle
)
;
if
(
(
key
>
=
SKC_PIPELINE_START_AT_DEFINE_PATHS
)
&
&
(
key
<
=
SKC_PIPELINE_START_AT_RENDER
)
)
pipeline_start_at_base
=
key
;
pipeline_start_at_loop
=
pipeline_start_at_base
;
if
(
transform_changed
)
pipeline_start_at_loop
=
min
(
pipeline_start_at_loop
SKC_PIPELINE_START_AT_RASTERIZE
)
;
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_COMPOSITION
)
{
SKC_TEST
(
rewind
)
;
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_DEFINE_PATHS
)
{
SKC_TEST
(
paths_release
context
paths
)
;
}
if
(
pipeline_start_at_loop
<
=
SKC_PIPELINE_START_AT_RASTERIZE
)
{
SKC_TEST
(
rasters_release
context
rasters
)
;
}
}
#
if
0
bool
quit
=
false
;
while
(
!
quit
)
{
skc_context_wait
(
context
)
;
}
#
endif
}
ts_transform_stack_release
(
ts
)
;
err
=
skc_surface_release
(
surface
)
;
err
=
skc_styling_release
(
styling
)
;
err
=
skc_composition_release
(
composition
)
;
err
=
skc_raster_builder_release
(
raster_builder
)
;
err
=
skc_path_builder_release
(
path_builder
)
;
err
=
skc_context_release
(
context
)
;
skc_interop_destroy
(
interop
)
;
return
EXIT_SUCCESS
;
}
