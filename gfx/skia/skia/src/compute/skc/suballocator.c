#
include
<
assert
.
h
>
#
include
<
memory
.
h
>
#
include
"
runtime_cl_12
.
h
"
#
include
"
scheduler
.
h
"
#
ifndef
NDEBUG
#
include
<
stdio
.
h
>
#
define
SKC_SUBALLOCATOR_DEBUG_ALLOC
(
suballocator
subbuf_id
ss
)
\
fprintf
(
stderr
\
"
suballocator
%
s
:
[
%
4u
]
:
alloc
(
%
9u
)
%
4u
=
%
u
\
n
"
\
suballocator
-
>
name
\
suballocator
-
>
rem
.
avail
\
(
skc_uint
)
ss
\
subbuf_id
\
(
skc_uint
)
suballocator
-
>
total
)
;
#
define
SKC_SUBALLOCATOR_DEBUG_FREE
(
suballocator
subbuf_id
ss
)
\
fprintf
(
stderr
\
"
suballocator
%
s
:
[
%
4u
]
:
free
(
%
9u
)
%
4u
=
%
u
\
n
"
\
suballocator
-
>
name
\
suballocator
-
>
rem
.
avail
\
(
skc_uint
)
ss
\
subbuf_id
\
(
skc_uint
)
suballocator
-
>
total
)
;
#
else
#
define
SKC_SUBALLOCATOR_DEBUG_ALLOC
(
suballocator
subbuf_id
ss
)
#
define
SKC_SUBALLOCATOR_DEBUG_FREE
(
suballocator
subbuf_id
ss
)
#
endif
void
skc_suballocator_create
(
struct
skc_runtime
*
const
runtime
struct
skc_suballocator
*
const
suballocator
char
const
*
const
name
skc_uint
const
subbufs
size_t
const
align
size_t
const
size
)
{
size_t
const
subbufs_size
=
sizeof
(
*
suballocator
-
>
subbufs
)
*
subbufs
;
suballocator
-
>
subbufs
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
subbufs_size
)
;
memset
(
suballocator
-
>
subbufs
0
subbufs_size
)
;
suballocator
-
>
subbufs
[
0
]
.
size
=
(
skc_subbuf_size_t
)
size
;
suballocator
-
>
ids
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
suballocator
-
>
ids
)
*
subbufs
)
;
for
(
skc_uint
ii
=
0
;
ii
<
subbufs
;
ii
+
+
)
suballocator
-
>
ids
[
ii
]
=
ii
;
suballocator
-
>
rem
.
avail
=
1
;
suballocator
-
>
rem
.
spare
=
subbufs
-
1
;
suballocator
-
>
align
=
(
skc_uint
)
align
;
suballocator
-
>
count
=
subbufs
;
suballocator
-
>
size
=
(
skc_subbuf_size_t
)
size
;
suballocator
-
>
total
=
0
;
suballocator
-
>
name
=
name
;
}
void
skc_suballocator_dispose
(
struct
skc_runtime
*
const
runtime
struct
skc_suballocator
*
const
suballocator
)
{
skc_runtime_host_perm_free
(
runtime
suballocator
-
>
ids
)
;
skc_runtime_host_perm_free
(
runtime
suballocator
-
>
subbufs
)
;
}
size_t
skc_suballocator_subbuf_alloc
(
struct
skc_suballocator
*
const
suballocator
struct
skc_scheduler
*
const
scheduler
size_t
const
size
skc_subbuf_id_t
*
const
subbuf_id
size_t
*
const
subbuf_size
)
{
skc_subbuf_size_t
const
size_ru
=
(
skc_subbuf_size_t
)
SKC_ROUND_UP_POW2
(
size
suballocator
-
>
align
)
;
if
(
subbuf_size
!
=
NULL
)
*
subbuf_size
=
size_ru
;
skc_subbuf_id_t
*
const
ids
=
suballocator
-
>
ids
;
while
(
true
)
{
skc_uint
avail_rem
=
suballocator
-
>
rem
.
avail
;
skc_uint
spare_rem
=
suballocator
-
>
rem
.
spare
;
for
(
skc_uint
avail_idx
=
0
;
avail_idx
<
avail_rem
;
avail_idx
+
+
)
{
skc_subbuf_id_t
const
avail_id
=
ids
[
avail_idx
]
;
struct
skc_subbuf
*
const
avail
=
suballocator
-
>
subbufs
+
avail_id
;
assert
(
avail
-
>
inuse
=
=
0
)
;
if
(
avail
-
>
size
=
=
size_ru
)
{
suballocator
-
>
total
+
=
size_ru
;
*
subbuf_id
=
avail_id
;
SKC_SUBALLOCATOR_DEBUG_ALLOC
(
suballocator
avail_id
size_ru
)
;
avail
-
>
inuse
+
=
1
;
assert
(
avail
-
>
inuse
=
=
1
)
;
suballocator
-
>
rem
.
avail
=
-
-
avail_rem
;
if
(
(
avail_rem
>
0
)
&
&
(
avail_idx
!
=
avail_rem
)
)
{
skc_subbuf_id_t
const
last_id
=
ids
[
avail_rem
]
;
struct
skc_subbuf
*
const
last
=
suballocator
-
>
subbufs
+
last_id
;
ids
[
avail_idx
]
=
last_id
;
last
-
>
idx
=
avail_idx
;
}
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
return
avail
-
>
origin
;
}
else
if
(
(
avail
-
>
size
>
size_ru
)
&
&
(
spare_rem
>
0
)
)
{
suballocator
-
>
total
+
=
size_ru
;
skc_uint
spare_idx
=
suballocator
-
>
count
-
spare_rem
;
skc_subbuf_id_t
const
spare_id
=
ids
[
spare_idx
]
;
struct
skc_subbuf
*
const
spare
=
suballocator
-
>
subbufs
+
spare_id
;
assert
(
spare
-
>
inuse
=
=
0
)
;
suballocator
-
>
rem
.
spare
-
=
1
;
*
subbuf_id
=
spare_id
;
SKC_SUBALLOCATOR_DEBUG_ALLOC
(
suballocator
spare_id
size_ru
)
;
struct
skc_subbuf
*
const
prev
=
avail
-
>
prev
;
if
(
prev
!
=
NULL
)
prev
-
>
next
=
spare
;
spare
-
>
prev
=
prev
;
spare
-
>
next
=
avail
;
spare
-
>
size
=
size_ru
;
spare
-
>
origin
=
avail
-
>
origin
;
spare
-
>
idx
=
SKC_UINT_MAX
;
spare
-
>
inuse
+
=
1
;
avail
-
>
prev
=
spare
;
avail
-
>
size
-
=
size_ru
;
avail
-
>
origin
+
=
size_ru
;
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
return
spare
-
>
origin
;
}
}
skc_scheduler_wait
(
scheduler
)
;
}
}
void
skc_suballocator_subbuf_free
(
struct
skc_suballocator
*
const
suballocator
skc_subbuf_id_t
subbuf_id
)
{
struct
skc_subbuf
*
const
subbuf
=
suballocator
-
>
subbufs
+
subbuf_id
;
assert
(
subbuf
-
>
inuse
=
=
1
)
;
suballocator
-
>
total
-
=
subbuf
-
>
size
;
SKC_SUBALLOCATOR_DEBUG_FREE
(
suballocator
subbuf_id
subbuf
-
>
size
)
;
struct
skc_subbuf
*
prev
;
struct
skc_subbuf
*
next
;
if
(
(
(
prev
=
subbuf
-
>
prev
)
!
=
NULL
)
&
&
!
prev
-
>
inuse
)
{
next
=
subbuf
-
>
next
;
if
(
(
next
!
=
NULL
)
&
&
!
next
-
>
inuse
)
{
subbuf
-
>
inuse
-
=
1
;
assert
(
next
-
>
inuse
=
=
0
)
;
prev
-
>
size
+
=
(
subbuf
-
>
size
+
next
-
>
size
)
;
struct
skc_subbuf
*
const
nextnext
=
next
-
>
next
;
prev
-
>
next
=
nextnext
;
if
(
nextnext
!
=
NULL
)
nextnext
-
>
prev
=
prev
;
skc_uint
const
last_idx
=
-
-
suballocator
-
>
rem
.
avail
;
skc_uint
const
next_idx
=
next
-
>
idx
;
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
if
(
last_idx
!
=
next_idx
)
{
skc_subbuf_id_t
const
last_id
=
suballocator
-
>
ids
[
last_idx
]
;
struct
skc_subbuf
*
const
last
=
suballocator
-
>
subbufs
+
last_id
;
suballocator
-
>
ids
[
next_idx
]
=
last_id
;
last
-
>
idx
=
next_idx
;
}
skc_subbuf_id_t
const
next_id
=
(
skc_subbuf_id_t
)
(
next
-
suballocator
-
>
subbufs
)
;
skc_uint
const
spare_rem
=
suballocator
-
>
rem
.
spare
+
2
;
skc_uint
const
spare_idx
=
suballocator
-
>
count
-
spare_rem
;
suballocator
-
>
rem
.
spare
=
spare_rem
;
suballocator
-
>
ids
[
spare_idx
+
0
]
=
subbuf_id
;
suballocator
-
>
ids
[
spare_idx
+
1
]
=
next_id
;
}
else
{
prev
-
>
size
+
=
subbuf
-
>
size
;
prev
-
>
next
=
next
;
if
(
next
!
=
NULL
)
next
-
>
prev
=
prev
;
subbuf
-
>
inuse
-
=
1
;
assert
(
subbuf
-
>
inuse
=
=
0
)
;
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
suballocator
-
>
ids
[
suballocator
-
>
count
-
+
+
suballocator
-
>
rem
.
spare
]
=
subbuf_id
;
}
}
else
if
(
(
(
next
=
subbuf
-
>
next
)
!
=
NULL
)
&
&
!
next
-
>
inuse
)
{
subbuf
-
>
inuse
-
=
1
;
assert
(
subbuf
-
>
inuse
=
=
0
)
;
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
next
-
>
prev
=
prev
;
next
-
>
origin
=
subbuf
-
>
origin
;
next
-
>
size
+
=
subbuf
-
>
size
;
if
(
prev
!
=
NULL
)
prev
-
>
next
=
next
;
suballocator
-
>
ids
[
suballocator
-
>
count
-
+
+
suballocator
-
>
rem
.
spare
]
=
subbuf_id
;
}
else
{
skc_uint
avail_idx
=
suballocator
-
>
rem
.
avail
+
+
;
subbuf
-
>
idx
=
avail_idx
;
subbuf
-
>
inuse
-
=
1
;
assert
(
subbuf
-
>
inuse
=
=
0
)
;
assert
(
suballocator
-
>
rem
.
avail
>
0
)
;
suballocator
-
>
ids
[
avail_idx
]
=
subbuf_id
;
}
}
#
if
0
static
void
skc_suballocator_optimize
(
struct
skc_suballocator
*
const
suballocator
)
{
;
}
#
endif
