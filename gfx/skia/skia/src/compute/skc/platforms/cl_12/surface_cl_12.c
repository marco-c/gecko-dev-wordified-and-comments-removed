#
include
"
common
/
cl
/
assert_cl
.
h
"
#
include
"
skc_cl
.
h
"
#
include
"
interop
.
h
"
#
include
"
extent_cl_12
.
h
"
#
include
"
runtime_cl_12
.
h
"
#
include
"
styling_cl_12
.
h
"
#
include
"
composition_cl_12
.
h
"
#
include
"
context
.
h
"
#
include
"
surface
.
h
"
#
include
<
stdio
.
h
>
struct
skc_surface_impl
{
struct
skc_surface
*
surface
;
struct
skc_runtime
*
runtime
;
cl_command_queue
cq
;
struct
{
cl_kernel
render
;
}
kernels
;
}
;
struct
skc_surface_render
{
skc_uint
clip
[
4
]
;
skc_uint
txty
[
2
]
;
struct
skc_surface_impl
*
impl
;
struct
skc_styling
*
styling
;
struct
skc_composition
*
composition
;
struct
skc_framebuffer_cl
*
fb
;
skc_surface_render_notify
notify
;
void
*
data
;
skc_grid_t
grid
;
skc_subbuf_id_t
id
;
}
;
static
void
skc_surface_debug_clear
(
struct
skc_surface_impl
*
const
impl
skc_framebuffer_t
fb
float
const
rgba
[
4
]
uint32_t
const
rect
[
4
]
)
{
size_t
const
origin
[
3
]
=
{
rect
[
0
]
rect
[
1
]
0
}
;
size_t
const
region
[
3
]
=
{
rect
[
2
]
rect
[
3
]
1
}
;
cl
(
EnqueueFillImage
(
impl
-
>
cq
(
(
struct
skc_framebuffer_cl
*
)
fb
)
-
>
mem
rgba
origin
region
0
NULL
NULL
)
)
;
}
#
if
0
static
void
skc_surface_debug
(
struct
skc_surface_impl
*
const
impl
)
{
cl_uchar4
*
const
rgba
=
skc_extent_phrN_pdwN_map
(
&
impl
-
>
fb
impl
-
>
cq
NULL
)
;
cl
(
Finish
(
impl
-
>
cq
)
)
;
FILE
*
file
;
errno_t
ferr
=
fopen_s
(
&
file
"
surface
.
ppm
"
"
wb
"
)
;
fprintf
(
file
"
P6
\
n
%
u
%
u
\
n255
\
n
"
SKC_SURFACE_WIDTH
SKC_SURFACE_HEIGHT
)
;
for
(
skc_uint
ii
=
0
;
ii
<
SKC_SURFACE_HEIGHT
*
SKC_SURFACE_WIDTH
;
ii
+
+
)
fwrite
(
rgba
+
ii
sizeof
(
skc_uchar
)
3
file
)
;
ferr
=
fclose
(
file
)
;
skc_extent_phrN_pdwN_unmap
(
&
impl
-
>
fb
rgba
impl
-
>
cq
NULL
)
;
cl
(
Flush
(
impl
-
>
cq
)
)
;
}
#
endif
static
void
skc_surface_pfn_release
(
struct
skc_surface_impl
*
const
impl
)
{
if
(
-
-
impl
-
>
surface
-
>
ref_count
!
=
0
)
return
;
cl
(
Finish
(
impl
-
>
cq
)
)
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
render
)
)
;
skc_runtime_host_perm_free
(
runtime
impl
-
>
surface
)
;
skc_runtime_release_cq_in_order
(
runtime
impl
-
>
cq
)
;
skc_runtime_host_perm_free
(
runtime
impl
)
;
}
void
skc_surface_render_complete
(
struct
skc_surface_render
*
const
render
)
{
#
ifdef
SKC_SURFACE_DEBUG
skc_surface_debug
(
render
-
>
impl
)
;
#
endif
if
(
render
-
>
notify
!
=
NULL
)
{
render
-
>
notify
(
render
-
>
impl
-
>
surface
render
-
>
styling
render
-
>
composition
render
-
>
fb
render
-
>
data
)
;
}
skc_styling_unlock_and_release
(
render
-
>
styling
)
;
skc_composition_unlock_and_release
(
render
-
>
composition
)
;
skc_grid_complete
(
render
-
>
grid
)
;
struct
skc_surface_impl
*
const
impl
=
render
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_surface_pfn_release
(
impl
)
;
skc_runtime_host_temp_free
(
runtime
render
render
-
>
id
)
;
}
static
void
skc_surface_render_cb
(
cl_event
event
cl_int
status
struct
skc_surface_render
*
const
render
)
{
SKC_CL_CB
(
status
)
;
SKC_SCHEDULER_SCHEDULE
(
render
-
>
impl
-
>
runtime
-
>
scheduler
skc_surface_render_complete
render
)
;
}
static
void
skc_surface_grid_pfn_execute
(
skc_grid_t
const
grid
)
{
struct
skc_surface_render
*
const
render
=
skc_grid_get_data
(
grid
)
;
struct
skc_surface_impl
*
const
impl
=
render
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
struct
skc_composition_impl
*
const
ci
=
render
-
>
composition
-
>
impl
;
struct
skc_place_atomics
*
const
atomics
=
ci
-
>
atomics
.
hr
;
if
(
atomics
-
>
offsets
>
0
)
{
if
(
render
-
>
fb
-
>
type
!
=
SKC_FRAMEBUFFER_CL_IMAGE2D
)
cl
(
EnqueueAcquireGLObjects
(
impl
-
>
cq
1
&
render
-
>
fb
-
>
mem
0
NULL
NULL
)
)
;
struct
skc_styling_impl
*
const
si
=
render
-
>
styling
-
>
impl
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
0
SKC_CL_ARG
(
si
-
>
layers
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
1
SKC_CL_ARG
(
si
-
>
groups
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
2
SKC_CL_ARG
(
si
-
>
extras
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
3
SKC_CL_ARG
(
ci
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
4
SKC_CL_ARG
(
atomics
-
>
keys
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
5
SKC_CL_ARG
(
ci
-
>
offsets
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
6
SKC_CL_ARG
(
atomics
-
>
offsets
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
7
SKC_CL_ARG
(
impl
-
>
runtime
-
>
block_pool
.
blocks
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
8
SKC_CL_ARG
(
render
-
>
fb
-
>
mem
)
)
)
;
#
if
1
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
9
sizeof
(
skc_uint4
)
render
-
>
clip
)
)
;
#
else
skc_uint
const
surface_pitch
=
SKC_SURFACE_HEIGHT
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
9
SKC_CL_ARG
(
surface_pitch
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
render
10
sizeof
(
skc_uint4
)
render
-
>
clip
)
)
;
#
endif
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RENDER
impl
-
>
cq
impl
-
>
kernels
.
render
atomics
-
>
offsets
0
NULL
NULL
)
;
cl_event
complete
;
if
(
render
-
>
fb
-
>
type
!
=
SKC_FRAMEBUFFER_CL_IMAGE2D
)
{
cl
(
EnqueueReleaseGLObjects
(
impl
-
>
cq
1
&
render
-
>
fb
-
>
mem
0
NULL
&
complete
)
)
;
render
-
>
fb
-
>
post_render
(
render
-
>
fb
-
>
interop
)
;
float
const
rgba
[
4
]
=
{
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
;
uint32_t
rect
[
4
]
=
{
0
}
;
skc_interop_get_size
(
render
-
>
fb
-
>
interop
rect
+
2
rect
+
3
)
;
skc_surface_debug_clear
(
impl
render
-
>
fb
rgba
rect
)
;
}
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_surface_render_cb
render
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
cl
(
Flush
(
impl
-
>
cq
)
)
;
}
else
{
skc_surface_render_complete
(
render
)
;
}
}
static
void
skc_surface_pfn_render
(
struct
skc_surface_impl
*
const
impl
skc_styling_t
styling
skc_composition_t
composition
skc_framebuffer_t
fb
uint32_t
const
clip
[
4
]
int32_t
const
txty
[
2
]
skc_surface_render_notify
notify
void
*
data
)
{
skc_surface_retain
(
impl
-
>
surface
)
;
skc_styling_retain_and_lock
(
styling
)
;
skc_composition_retain_and_lock
(
composition
)
;
skc_subbuf_id_t
id
;
struct
skc_surface_render
*
const
render
=
skc_runtime_host_temp_alloc
(
impl
-
>
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
render
)
&
id
NULL
)
;
render
-
>
id
=
id
;
render
-
>
clip
[
0
]
=
clip
[
0
]
;
render
-
>
clip
[
1
]
=
clip
[
1
]
;
render
-
>
clip
[
2
]
=
clip
[
2
]
;
render
-
>
clip
[
3
]
=
clip
[
3
]
;
render
-
>
txty
[
0
]
=
txty
[
0
]
;
render
-
>
txty
[
1
]
=
txty
[
1
]
;
render
-
>
impl
=
impl
;
render
-
>
styling
=
styling
;
render
-
>
composition
=
composition
;
render
-
>
notify
=
notify
;
render
-
>
data
=
data
;
render
-
>
fb
=
fb
;
render
-
>
grid
=
SKC_GRID_DEPS_ATTACH
(
impl
-
>
runtime
-
>
deps
NULL
render
NULL
skc_surface_grid_pfn_execute
NULL
)
;
if
(
styling
-
>
impl
-
>
state
!
=
SKC_STYLING_STATE_SEALED
)
skc_grid_happens_after_grid
(
render
-
>
grid
styling
-
>
impl
-
>
grid
)
;
if
(
composition
-
>
impl
-
>
state
!
=
SKC_COMPOSITION_STATE_SEALED
)
skc_grid_happens_after_grid
(
render
-
>
grid
composition
-
>
impl
-
>
grids
.
sort
)
;
skc_grid_start
(
render
-
>
grid
)
;
}
skc_err
skc_surface_cl_12_create
(
struct
skc_context
*
const
context
struct
skc_surface
*
*
const
surface
)
{
struct
skc_runtime
*
const
runtime
=
context
-
>
runtime
;
(
*
surface
)
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
*
surface
)
)
;
struct
skc_surface_impl
*
const
impl
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
impl
)
)
;
(
*
surface
)
-
>
context
=
context
;
(
*
surface
)
-
>
impl
=
impl
;
(
*
surface
)
-
>
ref_count
=
1
;
(
*
surface
)
-
>
release
=
skc_surface_pfn_release
;
(
*
surface
)
-
>
render
=
skc_surface_pfn_render
;
impl
-
>
surface
=
*
surface
;
impl
-
>
runtime
=
runtime
;
#
if
0
size_t
const
fb_size
=
sizeof
(
skc_uchar4
)
*
SKC_SURFACE_WIDTH
*
SKC_SURFACE_HEIGHT
;
skc_extent_phrN_pdwN_alloc
(
runtime
&
impl
-
>
fb
fb_size
)
;
#
endif
impl
-
>
cq
=
skc_runtime_acquire_cq_in_order
(
runtime
)
;
impl
-
>
kernels
.
render
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RENDER
)
;
return
SKC_ERR_SUCCESS
;
}
