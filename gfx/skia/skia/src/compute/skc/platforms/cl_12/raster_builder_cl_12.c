#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
hs
/
cl
/
hs_cl
.
h
"
#
include
"
common
/
cl
/
assert_cl
.
h
"
#
include
"
context
.
h
"
#
include
"
grid
.
h
"
#
include
"
raster
.
h
"
#
include
"
extent_ring
.
h
"
#
include
"
raster_builder
.
h
"
#
include
"
tile
.
h
"
#
include
"
config_cl
.
h
"
#
include
"
runtime_cl_12
.
h
"
#
include
"
extent_cl_12
.
h
"
#
include
"
raster_builder_cl_12
.
h
"
struct
skc_raster_builder_impl
{
struct
skc_raster_builder
*
raster_builder
;
struct
skc_runtime
*
runtime
;
skc_grid_t
cohort
;
struct
skc_extent_phrwg_thr1s
path_ids
;
struct
skc_extent_phw1g_tdrNs
transforms
;
struct
skc_extent_phw1g_tdrNs
clips
;
struct
skc_extent_phw1g_tdrNs
fill_cmds
;
struct
skc_extent_phrwg_tdrNs
raster_ids
;
struct
{
cl_kernel
fills_expand
;
cl_kernel
rasterize_all
;
cl_kernel
segment
;
cl_kernel
rasters_alloc
;
cl_kernel
prefix
;
}
kernels
;
}
;
struct
skc_raster_cohort
{
struct
skc_raster_builder_impl
*
impl
;
struct
skc_extent_phrwg_thr1s_snap
path_ids
;
struct
skc_extent_phw1g_tdrNs_snap
transforms
;
struct
skc_extent_phw1g_tdrNs_snap
clips
;
struct
skc_extent_phw1g_tdrNs_snap
fill_cmds
;
struct
skc_extent_phrwg_tdrNs_snap
raster_ids
;
cl_command_queue
cq
;
struct
skc_extent_thr_tdrw
atomics
;
struct
skc_extent_tdrw
cmds
;
struct
skc_extent_tdrw
keys
;
struct
skc_extent_tdrw
metas
;
skc_subbuf_id_t
id
;
}
;
union
skc_ttrk
{
skc_ulong
u64
;
skc_uint2
u32v2
;
struct
{
skc_uint
block
:
SKC_TTXK_LO_BITS_ID
;
skc_uint
na0
:
SKC_TTRK_LO_BITS_NA
;
skc_uint
x
:
SKC_TTXK_HI_BITS_X
;
skc_uint
y
:
SKC_TTXK_HI_BITS_Y
;
skc_uint
cohort
:
SKC_TTRK_HI_BITS_COHORT
;
}
;
struct
{
skc_uint
na1
;
skc_uint
yx
:
SKC_TTXK_HI_BITS_YX
;
skc_uint
na2
:
SKC_TTRK_HI_BITS_COHORT
;
}
;
struct
{
skc_uint
na3
;
skc_uint
na4
:
SKC_TTXK_HI_BITS_X
;
skc_uint
cohort_y
:
SKC_TTRK_HI_BITS_COHORT_Y
;
}
;
}
;
static
void
skc_raster_builder_pfn_release
(
struct
skc_raster_builder_impl
*
const
impl
)
{
if
(
-
-
impl
-
>
raster_builder
-
>
refcount
!
=
0
)
return
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_runtime_host_perm_free
(
runtime
impl
-
>
raster_builder
)
;
skc_extent_phrwg_thr1s_free
(
runtime
&
impl
-
>
path_ids
)
;
skc_extent_phw1g_tdrNs_free
(
runtime
&
impl
-
>
transforms
)
;
skc_extent_phw1g_tdrNs_free
(
runtime
&
impl
-
>
clips
)
;
skc_extent_phw1g_tdrNs_free
(
runtime
&
impl
-
>
fill_cmds
)
;
skc_extent_phrwg_tdrNs_free
(
runtime
&
impl
-
>
raster_ids
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
fills_expand
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
rasterize_all
)
)
;
#
if
0
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
rasterize_lines
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
rasterize_quads
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
rasterize_cubics
)
)
;
#
endif
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
segment
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
rasters_alloc
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
prefix
)
)
;
skc_runtime_host_perm_free
(
runtime
impl
)
;
}
static
void
skc_raster_builder_rasters_release
(
struct
skc_runtime
*
const
runtime
skc_raster_t
const
*
const
rasters
skc_uint
const
size
skc_uint
const
from
skc_uint
const
to
)
{
if
(
from
<
=
to
)
{
skc_raster_t
const
*
rasters_from
=
rasters
+
from
;
skc_uint
count_from
=
to
-
from
;
skc_grid_deps_unmap
(
runtime
-
>
deps
rasters_from
count_from
)
;
skc_runtime_raster_device_release
(
runtime
rasters_from
count_from
)
;
}
else
{
skc_raster_t
const
*
rasters_lo
=
rasters
+
from
;
skc_uint
count_lo
=
size
-
from
;
skc_grid_deps_unmap
(
runtime
-
>
deps
rasters_lo
count_lo
)
;
skc_runtime_raster_device_release
(
runtime
rasters_lo
count_lo
)
;
skc_grid_deps_unmap
(
runtime
-
>
deps
rasters
to
)
;
skc_runtime_raster_device_release
(
runtime
rasters
to
)
;
}
}
static
void
skc_raster_builder_paths_release
(
struct
skc_runtime
*
const
runtime
struct
skc_extent_phrwg_thr1s_snap
*
const
snap
)
{
skc_runtime_path_device_release
(
runtime
snap
-
>
hr1
.
lo
snap
-
>
count
.
lo
)
;
if
(
snap
-
>
count
.
hi
)
skc_runtime_path_device_release
(
runtime
snap
-
>
hr1
.
hi
snap
-
>
count
.
hi
)
;
}
static
void
skc_raster_builder_cohort_grid_pfn_dispose
(
skc_grid_t
const
grid
)
{
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
struct
skc_raster_builder_impl
*
const
impl
=
cohort
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_extent_phrwg_thr1s_snap_alloc
(
runtime
&
impl
-
>
path_ids
&
cohort
-
>
path_ids
)
;
skc_raster_builder_paths_release
(
runtime
&
cohort
-
>
path_ids
)
;
skc_extent_phrwg_thr1s_snap_free
(
runtime
&
cohort
-
>
path_ids
)
;
skc_uint
const
size
=
cohort
-
>
raster_ids
.
snap
-
>
ring
-
>
size
.
pow2
;
skc_uint
const
from
=
skc_extent_ring_snap_from
(
cohort
-
>
raster_ids
.
snap
)
;
skc_uint
const
to
=
skc_extent_ring_snap_to
(
cohort
-
>
raster_ids
.
snap
)
;
skc_raster_builder_rasters_release
(
runtime
impl
-
>
raster_ids
.
hrw
size
from
to
)
;
skc_extent_phrwg_tdrNs_snap_free
(
runtime
&
cohort
-
>
raster_ids
)
;
skc_runtime_release_cq_in_order
(
runtime
cohort
-
>
cq
)
;
skc_extent_thr_tdrw_free
(
runtime
&
cohort
-
>
atomics
)
;
skc_extent_tdrw_free
(
runtime
&
cohort
-
>
keys
)
;
skc_extent_tdrw_free
(
runtime
&
cohort
-
>
metas
)
;
skc_runtime_host_temp_free
(
runtime
cohort
cohort
-
>
id
)
;
skc_raster_builder_pfn_release
(
impl
)
;
}
static
void
skc_raster_cohort_prefix_release
(
skc_grid_t
const
grid
)
{
skc_grid_complete
(
grid
)
;
}
static
void
skc_raster_cohort_prefix_cb
(
cl_event
event
cl_int
status
skc_grid_t
const
grid
)
{
SKC_CL_CB
(
status
)
;
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
struct
skc_scheduler
*
const
scheduler
=
cohort
-
>
impl
-
>
runtime
-
>
scheduler
;
SKC_SCHEDULER_SCHEDULE
(
scheduler
skc_raster_cohort_prefix_release
grid
)
;
}
#
if
0
static
int
cmp64
(
const
void
*
ptr_a
const
void
*
ptr_b
)
{
skc_ulong
const
a
=
*
(
const
skc_ulong
*
)
ptr_a
;
skc_ulong
const
b
=
*
(
const
skc_ulong
*
)
ptr_b
;
if
(
a
<
b
)
return
-
1
;
if
(
a
>
b
)
return
+
1
;
else
return
0
;
}
#
endif
static
void
skc_raster_cohort_sort_prefix
(
skc_grid_t
const
grid
)
{
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
struct
skc_raster_builder_impl
*
const
impl
=
cohort
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_extent_phw1g_tdrNs_snap_free
(
runtime
&
cohort
-
>
transforms
)
;
skc_extent_phw1g_tdrNs_snap_free
(
runtime
&
cohort
-
>
clips
)
;
skc_extent_tdrw_free
(
runtime
&
cohort
-
>
cmds
)
;
skc_extent_phrwg_tdrNs_snap_alloc
(
runtime
&
impl
-
>
raster_ids
&
cohort
-
>
raster_ids
cohort
-
>
cq
NULL
)
;
skc_uint
const
rasters
=
skc_extent_ring_snap_count
(
cohort
-
>
raster_ids
.
snap
)
;
skc_extent_tdrw_alloc
(
runtime
&
cohort
-
>
metas
sizeof
(
struct
skc_raster_cohort_meta
)
)
;
skc_extent_tdrw_zero
(
&
cohort
-
>
metas
cohort
-
>
cq
NULL
)
;
struct
skc_raster_cohort_atomic
const
*
const
atomics
=
cohort
-
>
atomics
.
hr
;
if
(
atomics
-
>
keys
>
0
)
{
#
ifndef
NDEBUG
fprintf
(
stderr
"
raster
cohort
sort
:
%
u
\
n
"
atomics
-
>
keys
)
;
#
endif
uint32_t
keys_padded_in
keys_padded_out
;
hs_cl_pad
(
runtime
-
>
hs
atomics
-
>
keys
&
keys_padded_in
&
keys_padded_out
)
;
hs_cl_sort
(
runtime
-
>
hs
cohort
-
>
cq
0
NULL
NULL
cohort
-
>
keys
.
drw
NULL
atomics
-
>
keys
keys_padded_in
keys_padded_out
false
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
segment
0
SKC_CL_ARG
(
cohort
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
segment
1
SKC_CL_ARG
(
cohort
-
>
metas
.
drw
)
)
)
;
#
ifndef
NDEBUG
fprintf
(
stderr
"
post
-
sort
\
n
"
)
;
#
endif
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_SEGMENT_TTRK
cohort
-
>
cq
impl
-
>
kernels
.
segment
atomics
-
>
keys
0
NULL
NULL
)
;
#
ifndef
NDEBUG
fprintf
(
stderr
"
post
-
segment
\
n
"
)
;
#
endif
#
if
0
cl
(
Finish
(
cohort
-
>
cq
)
)
;
union
skc_ttrk
*
const
keys
=
skc_extent_thrw_tdrw_map
(
&
cohort
-
>
keys
cohort
-
>
cq
NULL
)
;
struct
skc_raster_cohort_meta
*
const
metas
=
skc_extent_thrw_tdrw_map
(
&
cohort
-
>
metas
cohort
-
>
cq
NULL
)
;
cl
(
Finish
(
cohort
-
>
cq
)
)
;
qsort
(
keys
atomics
-
>
keys
sizeof
(
*
keys
)
cmp64
)
;
skc_uint
const
subblock_mask
=
runtime
-
>
config
-
>
block
.
subblocks
-
1
;
union
skc_raster_cohort_meta_in
meta_in
=
{
.
blocks
=
0
.
offset
=
0
.
pk
=
0
.
rk
=
0
}
;
union
skc_ttrk
curr
=
keys
[
0
]
;
skc_uint
ii
=
0
jj
=
0
;
while
(
true
)
{
meta_in
.
rk
+
=
1
;
if
(
(
curr
.
u32v2
.
lo
&
subblock_mask
)
=
=
0
)
meta_in
.
blocks
+
=
1
;
if
(
+
+
ii
>
=
atomics
-
>
keys
)
break
;
union
skc_ttrk
const
next
=
keys
[
ii
]
;
if
(
next
.
cohort
!
=
curr
.
cohort
)
{
fprintf
(
stderr
"
[
%
u
%
u
%
u
%
u
]
\
n
"
meta_in
.
blocks
meta_in
.
offset
meta_in
.
pk
meta_in
.
rk
)
;
metas
-
>
inout
[
curr
.
cohort
]
.
in
=
meta_in
;
meta_in
.
blocks
=
0
;
meta_in
.
offset
=
ii
;
meta_in
.
pk
=
0
;
meta_in
.
rk
=
0
;
}
else
if
(
(
next
.
y
=
=
curr
.
y
)
&
&
(
next
.
x
!
=
curr
.
x
)
)
{
meta_in
.
pk
+
=
1
;
#
if
0
fprintf
(
stderr
"
%
3u
:
%
3u
:
(
%
3u
%
3u
)
-
>
(
%
3u
)
\
n
"
jj
+
+
curr
.
cohort
curr
.
y
curr
.
x
next
.
x
)
;
#
endif
}
#
if
0
fprintf
(
stderr
"
(
%
3u
%
3u
)
\
n
"
next
.
y
next
.
x
)
;
#
endif
curr
=
next
;
}
fprintf
(
stderr
"
[
%
u
%
u
%
u
%
u
]
\
n
"
meta_in
.
blocks
meta_in
.
offset
meta_in
.
pk
meta_in
.
rk
)
;
metas
-
>
inout
[
curr
.
cohort
]
.
in
=
meta_in
;
skc_extent_thrw_tdrw_unmap
(
&
cohort
-
>
keys
keys
cohort
-
>
cq
NULL
)
;
skc_extent_thrw_tdrw_unmap
(
&
cohort
-
>
metas
metas
cohort
-
>
cq
NULL
)
;
#
endif
}
#
ifndef
NDEBUG
fprintf
(
stderr
"
rasters_alloc
:
%
u
\
n
"
rasters
)
;
#
endif
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
0
SKC_CL_ARG
(
runtime
-
>
block_pool
.
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
1
SKC_CL_ARG
(
runtime
-
>
block_pool
.
ids
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
2
SKC_CL_ARG
(
runtime
-
>
block_pool
.
size
-
>
ring_mask
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
3
SKC_CL_ARG
(
runtime
-
>
handle_pool
.
map
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
4
SKC_CL_ARG
(
cohort
-
>
metas
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
5
SKC_CL_ARG
(
cohort
-
>
raster_ids
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasters_alloc
6
SKC_CL_ARG
(
rasters
)
)
)
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERS_ALLOC
cohort
-
>
cq
impl
-
>
kernels
.
rasters_alloc
rasters
0
NULL
NULL
)
;
#
ifndef
NDEBUG
fprintf
(
stderr
"
post
-
alloc
\
n
"
)
;
#
endif
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
0
SKC_CL_ARG
(
runtime
-
>
block_pool
.
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
1
SKC_CL_ARG
(
runtime
-
>
block_pool
.
ids
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
2
SKC_CL_ARG
(
runtime
-
>
block_pool
.
blocks
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
3
SKC_CL_ARG
(
runtime
-
>
block_pool
.
size
-
>
ring_mask
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
4
SKC_CL_ARG
(
cohort
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
5
SKC_CL_ARG
(
runtime
-
>
handle_pool
.
map
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
6
SKC_CL_ARG
(
cohort
-
>
metas
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
prefix
7
SKC_CL_ARG
(
rasters
)
)
)
;
cl_event
complete
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_PREFIX
cohort
-
>
cq
impl
-
>
kernels
.
prefix
rasters
0
NULL
&
complete
)
;
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_raster_cohort_prefix_cb
grid
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
#
ifndef
NDEBUG
fprintf
(
stderr
"
post
-
prefix
\
n
"
)
;
#
endif
cl
(
Flush
(
cohort
-
>
cq
)
)
;
}
static
void
skc_raster_cohort_rasterize_cb
(
cl_event
event
cl_int
status
skc_grid_t
const
grid
)
{
SKC_CL_CB
(
status
)
;
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
SKC_SCHEDULER_SCHEDULE
(
cohort
-
>
impl
-
>
runtime
-
>
scheduler
skc_raster_cohort_sort_prefix
grid
)
;
}
static
void
skc_raster_cohort_rasterize
(
skc_grid_t
const
grid
)
{
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
struct
skc_raster_builder_impl
*
const
impl
=
cohort
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_extent_phw1g_tdrNs_snap_free
(
runtime
&
cohort
-
>
fill_cmds
)
;
skc_extent_phw1g_tdrNs_snap_alloc
(
runtime
&
impl
-
>
transforms
&
cohort
-
>
transforms
cohort
-
>
cq
NULL
)
;
skc_extent_phw1g_tdrNs_snap_alloc
(
runtime
&
impl
-
>
clips
&
cohort
-
>
clips
cohort
-
>
cq
NULL
)
;
skc_extent_tdrw_alloc
(
runtime
&
cohort
-
>
keys
sizeof
(
union
skc_ttrk
)
*
runtime
-
>
config
-
>
raster_cohort
.
rasterize
.
keys
)
;
struct
skc_raster_cohort_atomic
const
*
const
atomics
=
cohort
-
>
atomics
.
hr
;
if
(
atomics
-
>
cmds
>
0
)
{
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
0
SKC_CL_ARG
(
runtime
-
>
block_pool
.
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
1
SKC_CL_ARG
(
runtime
-
>
block_pool
.
blocks
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
2
SKC_CL_ARG
(
runtime
-
>
block_pool
.
ids
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
3
SKC_CL_ARG
(
runtime
-
>
block_pool
.
size
-
>
ring_mask
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
4
SKC_CL_ARG
(
cohort
-
>
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
5
SKC_CL_ARG
(
cohort
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
6
SKC_CL_ARG
(
cohort
-
>
transforms
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
7
SKC_CL_ARG
(
cohort
-
>
clips
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
8
SKC_CL_ARG
(
cohort
-
>
cmds
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
rasterize_all
9
SKC_CL_ARG
(
atomics
-
>
cmds
)
)
)
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERIZE_ALL
cohort
-
>
cq
impl
-
>
kernels
.
rasterize_all
atomics
-
>
cmds
0
NULL
NULL
)
;
}
cl_event
complete
;
skc_extent_thr_tdrw_read
(
&
cohort
-
>
atomics
cohort
-
>
cq
&
complete
)
;
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_raster_cohort_rasterize_cb
grid
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
cl
(
Flush
(
cohort
-
>
cq
)
)
;
}
static
void
skc_raster_cohort_fills_expand_cb
(
cl_event
event
cl_int
status
skc_grid_t
const
grid
)
{
SKC_CL_CB
(
status
)
;
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
SKC_SCHEDULER_SCHEDULE
(
cohort
-
>
impl
-
>
runtime
-
>
scheduler
skc_raster_cohort_rasterize
grid
)
;
}
static
void
skc_raster_builder_cohort_grid_pfn_execute
(
skc_grid_t
const
grid
)
{
struct
skc_raster_cohort
*
const
cohort
=
skc_grid_get_data
(
grid
)
;
struct
skc_raster_builder_impl
*
const
impl
=
cohort
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
cohort
-
>
cq
=
skc_runtime_acquire_cq_in_order
(
runtime
)
;
skc_extent_phw1g_tdrNs_snap_alloc
(
runtime
&
impl
-
>
fill_cmds
&
cohort
-
>
fill_cmds
cohort
-
>
cq
NULL
)
;
skc_extent_thr_tdrw_alloc
(
runtime
&
cohort
-
>
atomics
sizeof
(
struct
skc_raster_cohort_atomic
)
)
;
skc_extent_thr_tdrw_zero
(
&
cohort
-
>
atomics
cohort
-
>
cq
NULL
)
;
struct
skc_config
const
*
const
config
=
runtime
-
>
config
;
skc_extent_tdrw_alloc
(
runtime
&
cohort
-
>
cmds
sizeof
(
union
skc_cmd_rasterize
)
*
config
-
>
raster_cohort
.
expand
.
cmds
)
;
skc_uint
const
work_size
=
skc_extent_ring_snap_count
(
cohort
-
>
fill_cmds
.
snap
)
;
if
(
work_size
>
0
)
{
cl
(
SetKernelArg
(
impl
-
>
kernels
.
fills_expand
0
SKC_CL_ARG
(
impl
-
>
runtime
-
>
block_pool
.
blocks
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
fills_expand
1
SKC_CL_ARG
(
cohort
-
>
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
fills_expand
2
SKC_CL_ARG
(
runtime
-
>
handle_pool
.
map
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
fills_expand
3
SKC_CL_ARG
(
cohort
-
>
fill_cmds
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
fills_expand
4
SKC_CL_ARG
(
cohort
-
>
cmds
.
drw
)
)
)
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_FILLS_EXPAND
cohort
-
>
cq
impl
-
>
kernels
.
fills_expand
work_size
0
NULL
NULL
)
;
}
cl_event
complete
;
skc_extent_thr_tdrw_read
(
&
cohort
-
>
atomics
cohort
-
>
cq
&
complete
)
;
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_raster_cohort_fills_expand_cb
grid
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
cl
(
Flush
(
cohort
-
>
cq
)
)
;
}
static
void
skc_raster_builder_cohort_grid_pfn_waiting
(
skc_grid_t
const
grid
)
{
struct
skc_raster_builder_impl
*
const
impl
=
skc_grid_get_data
(
grid
)
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
impl
-
>
raster_builder
-
>
refcount
+
=
1
;
skc_subbuf_id_t
id
;
struct
skc_raster_cohort
*
const
cohort
=
skc_runtime_host_temp_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
cohort
)
&
id
NULL
)
;
cohort
-
>
id
=
id
;
cohort
-
>
impl
=
impl
;
skc_grid_set_data
(
grid
cohort
)
;
struct
skc_raster_builder
*
const
raster_builder
=
impl
-
>
raster_builder
;
skc_extent_phrwg_thr1s_snap_init
(
runtime
&
raster_builder
-
>
path_ids
.
ring
&
cohort
-
>
path_ids
)
;
skc_extent_phw1g_tdrNs_snap_init
(
runtime
&
raster_builder
-
>
transforms
.
ring
&
cohort
-
>
transforms
)
;
skc_extent_phw1g_tdrNs_snap_init
(
runtime
&
raster_builder
-
>
clips
.
ring
&
cohort
-
>
clips
)
;
skc_extent_phw1g_tdrNs_snap_init
(
runtime
&
raster_builder
-
>
fill_cmds
.
ring
&
cohort
-
>
fill_cmds
)
;
skc_extent_phrwg_tdrNs_snap_init
(
runtime
&
raster_builder
-
>
raster_ids
.
ring
&
cohort
-
>
raster_ids
)
;
}
static
void
skc_raster_builder_cohort_create
(
struct
skc_raster_builder_impl
*
const
impl
)
{
impl
-
>
cohort
=
SKC_GRID_DEPS_ATTACH
(
impl
-
>
runtime
-
>
deps
&
impl
-
>
cohort
impl
skc_raster_builder_cohort_grid_pfn_waiting
skc_raster_builder_cohort_grid_pfn_execute
skc_raster_builder_cohort_grid_pfn_dispose
)
;
}
static
skc_err
skc_raster_builder_pfn_add
(
struct
skc_raster_builder_impl
*
const
impl
skc_path_t
const
*
paths
skc_uint
count
)
{
skc_err
err
;
err
=
skc_runtime_handle_device_validate_retain
(
impl
-
>
runtime
SKC_TYPED_HANDLE_TYPE_IS_PATH
paths
count
)
;
if
(
err
)
return
err
;
skc_runtime_handle_device_retain
(
impl
-
>
runtime
paths
count
)
;
if
(
impl
-
>
cohort
=
=
NULL
)
{
skc_raster_builder_cohort_create
(
impl
)
;
}
while
(
count
-
-
>
0
)
skc_grid_happens_after_handle
(
impl
-
>
cohort
SKC_TYPED_HANDLE_TO_HANDLE
(
*
paths
+
+
)
)
;
return
SKC_ERR_SUCCESS
;
}
static
void
skc_raster_builder_pfn_end
(
struct
skc_raster_builder_impl
*
const
impl
skc_raster_t
*
const
raster
)
{
*
raster
=
skc_runtime_handle_device_acquire
(
impl
-
>
runtime
)
;
if
(
impl
-
>
cohort
=
=
NULL
)
{
skc_raster_builder_cohort_create
(
impl
)
;
}
skc_grid_map
(
impl
-
>
cohort
*
raster
)
;
}
static
void
skc_raster_builder_pfn_start
(
struct
skc_raster_builder_impl
*
const
impl
)
{
skc_grid_t
const
cohort
=
impl
-
>
cohort
;
if
(
cohort
!
=
NULL
)
{
skc_grid_start
(
cohort
)
;
}
}
static
void
skc_raster_builder_pfn_force
(
struct
skc_raster_builder_impl
*
const
impl
)
{
skc_grid_t
const
cohort
=
impl
-
>
cohort
;
if
(
cohort
!
=
NULL
)
{
skc_grid_force
(
cohort
)
;
}
}
skc_err
skc_raster_builder_cl_12_create
(
struct
skc_context
*
const
context
struct
skc_raster_builder
*
*
const
raster_builder
)
{
struct
skc_runtime
*
const
runtime
=
context
-
>
runtime
;
(
*
raster_builder
)
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
*
raster_builder
)
)
;
(
*
raster_builder
)
-
>
refcount
=
1
;
SKC_ASSERT_STATE_INIT
(
(
*
raster_builder
)
SKC_RASTER_BUILDER_STATE_READY
)
;
struct
skc_raster_builder_impl
*
const
impl
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
impl
)
)
;
(
*
raster_builder
)
-
>
impl
=
impl
;
impl
-
>
raster_builder
=
(
*
raster_builder
)
;
impl
-
>
runtime
=
runtime
;
impl
-
>
cohort
=
NULL
;
struct
skc_config
const
*
const
config
=
runtime
-
>
config
;
skc_extent_phrwg_thr1s_alloc
(
runtime
&
impl
-
>
path_ids
sizeof
(
skc_path_t
)
*
config
-
>
raster_cohort
.
path_ids
.
elem_count
)
;
skc_extent_phw1g_tdrNs_alloc
(
runtime
&
impl
-
>
transforms
sizeof
(
union
skc_transform
)
*
config
-
>
raster_cohort
.
transforms
.
elem_count
)
;
skc_extent_phw1g_tdrNs_alloc
(
runtime
&
impl
-
>
clips
sizeof
(
union
skc_path_clip
)
*
config
-
>
raster_cohort
.
clips
.
elem_count
)
;
skc_extent_phw1g_tdrNs_alloc
(
runtime
&
impl
-
>
fill_cmds
sizeof
(
union
skc_cmd_fill
)
*
config
-
>
raster_cohort
.
fill
.
elem_count
)
;
skc_extent_phrwg_tdrNs_alloc
(
runtime
&
impl
-
>
raster_ids
sizeof
(
skc_raster_t
)
*
config
-
>
raster_cohort
.
raster_ids
.
elem_count
)
;
(
*
raster_builder
)
-
>
context
=
context
;
(
*
raster_builder
)
-
>
add
=
skc_raster_builder_pfn_add
;
(
*
raster_builder
)
-
>
end
=
skc_raster_builder_pfn_end
;
(
*
raster_builder
)
-
>
start
=
skc_raster_builder_pfn_start
;
(
*
raster_builder
)
-
>
force
=
skc_raster_builder_pfn_force
;
(
*
raster_builder
)
-
>
release
=
skc_raster_builder_pfn_release
;
(
*
raster_builder
)
-
>
path_ids
.
extent
=
impl
-
>
path_ids
.
hrw
;
(
*
raster_builder
)
-
>
transforms
.
extent
=
impl
-
>
transforms
.
hw1
;
(
*
raster_builder
)
-
>
clips
.
extent
=
impl
-
>
clips
.
hw1
;
(
*
raster_builder
)
-
>
fill_cmds
.
extent
=
impl
-
>
fill_cmds
.
hw1
;
(
*
raster_builder
)
-
>
raster_ids
.
extent
=
impl
-
>
raster_ids
.
hrw
;
skc_extent_ring_init
(
&
(
*
raster_builder
)
-
>
path_ids
.
ring
config
-
>
raster_cohort
.
path_ids
.
elem_count
config
-
>
raster_cohort
.
path_ids
.
snap_count
sizeof
(
skc_path_t
)
)
;
skc_extent_ring_init
(
&
(
*
raster_builder
)
-
>
transforms
.
ring
config
-
>
raster_cohort
.
transforms
.
elem_count
config
-
>
raster_cohort
.
transforms
.
snap_count
sizeof
(
union
skc_transform
)
)
;
skc_extent_ring_init
(
&
(
*
raster_builder
)
-
>
clips
.
ring
config
-
>
raster_cohort
.
clips
.
elem_count
config
-
>
raster_cohort
.
clips
.
snap_count
sizeof
(
union
skc_path_clip
)
)
;
skc_extent_ring_init
(
&
(
*
raster_builder
)
-
>
fill_cmds
.
ring
config
-
>
raster_cohort
.
fill
.
elem_count
config
-
>
raster_cohort
.
fill
.
snap_count
sizeof
(
union
skc_cmd_fill
)
)
;
skc_extent_ring_init
(
&
(
*
raster_builder
)
-
>
raster_ids
.
ring
config
-
>
raster_cohort
.
raster_ids
.
elem_count
config
-
>
raster_cohort
.
raster_ids
.
snap_count
sizeof
(
skc_raster_t
)
)
;
impl
-
>
kernels
.
fills_expand
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_FILLS_EXPAND
)
;
impl
-
>
kernels
.
rasterize_all
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERIZE_ALL
)
;
#
if
0
impl
-
>
kernels
.
rasterize_lines
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERIZE_LINES
)
;
impl
-
>
kernels
.
rasterize_quads
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERIZE_QUADS
)
;
impl
-
>
kernels
.
rasterize_cubics
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERIZE_CUBICS
)
;
#
endif
impl
-
>
kernels
.
segment
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_SEGMENT_TTRK
)
;
impl
-
>
kernels
.
rasters_alloc
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_RASTERS_ALLOC
)
;
impl
-
>
kernels
.
prefix
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_PREFIX
)
;
return
SKC_ERR_SUCCESS
;
}
