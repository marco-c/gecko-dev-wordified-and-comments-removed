#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
"
hs
/
cl
/
hs_cl
.
h
"
#
include
"
common
/
cl
/
assert_cl
.
h
"
#
include
"
composition_cl_12
.
h
"
#
include
"
config_cl
.
h
"
#
include
"
context
.
h
"
#
include
"
raster
.
h
"
#
include
"
handle
.
h
"
#
include
"
runtime_cl_12
.
h
"
#
include
"
common
.
h
"
#
include
"
tile
.
h
"
union
skc_ttck
{
skc_ulong
u64
;
skc_uint2
u32v2
;
struct
{
skc_uint
id
:
SKC_TTCK_LO_BITS_ID
;
skc_uint
prefix
:
SKC_TTCK_LO_BITS_PREFIX
;
skc_uint
escape
:
SKC_TTCK_LO_BITS_ESCAPE
;
skc_uint
layer_lo
:
SKC_TTCK_LO_BITS_LAYER
;
skc_uint
layer_hi
:
SKC_TTCK_HI_BITS_LAYER
;
skc_uint
x
:
SKC_TTCK_HI_BITS_X
;
skc_uint
y
:
SKC_TTCK_HI_BITS_Y
;
}
;
struct
{
skc_ulong
na0
:
SKC_TTCK_LO_BITS_ID_PREFIX_ESCAPE
;
skc_ulong
layer
:
SKC_TTCK_BITS_LAYER
;
skc_ulong
na1
:
SKC_TTCK_HI_BITS_YX
;
}
;
struct
{
skc_uint
na2
;
skc_uint
na3
:
SKC_TTCK_HI_BITS_LAYER
;
skc_uint
yx
:
SKC_TTCK_HI_BITS_YX
;
}
;
}
;
#
define
SKC_PLACE_CMD_TX_CONVERT
(
f
)
0
#
define
SKC_PLACE_CMD_TY_CONVERT
(
f
)
0
struct
skc_composition_place
{
struct
skc_composition_impl
*
impl
;
cl_command_queue
cq
;
struct
skc_extent_phw1g_tdrNs_snap
cmds
;
skc_subbuf_id_t
id
;
}
;
static
void
skc_composition_unseal_block
(
struct
skc_composition_impl
*
const
impl
skc_bool
const
block
)
;
static
void
skc_composition_pfn_release
(
struct
skc_composition_impl
*
const
impl
)
{
if
(
-
-
impl
-
>
composition
-
>
ref_count
!
=
0
)
return
;
skc_composition_unseal_block
(
impl
true
)
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_runtime_host_perm_free
(
runtime
impl
-
>
composition
)
;
skc_runtime_release_cq_in_order
(
runtime
impl
-
>
cq
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
place
)
)
;
cl
(
ReleaseKernel
(
impl
-
>
kernels
.
segment
)
)
;
skc_extent_phw1g_tdrNs_free
(
runtime
&
impl
-
>
cmds
.
extent
)
;
skc_extent_phrw_free
(
runtime
&
impl
-
>
saved
.
extent
)
;
skc_extent_phr_pdrw_free
(
runtime
&
impl
-
>
atomics
)
;
skc_extent_pdrw_free
(
runtime
&
impl
-
>
keys
)
;
skc_extent_pdrw_free
(
runtime
&
impl
-
>
offsets
)
;
skc_runtime_host_perm_free
(
runtime
impl
)
;
}
static
void
skc_composition_place_grid_pfn_dispose
(
skc_grid_t
const
grid
)
{
struct
skc_composition_place
*
const
place
=
skc_grid_get_data
(
grid
)
;
struct
skc_composition_impl
*
const
impl
=
place
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_runtime_release_cq_in_order
(
runtime
place
-
>
cq
)
;
skc_extent_phw1g_tdrNs_snap_free
(
runtime
&
place
-
>
cmds
)
;
skc_runtime_host_temp_free
(
runtime
place
place
-
>
id
)
;
skc_composition_pfn_release
(
impl
)
;
}
static
void
skc_composition_place_read_complete
(
skc_grid_t
const
grid
)
{
skc_grid_complete
(
grid
)
;
}
static
void
skc_composition_place_read_cb
(
cl_event
event
cl_int
status
skc_grid_t
const
grid
)
{
SKC_CL_CB
(
status
)
;
struct
skc_composition_place
*
const
place
=
skc_grid_get_data
(
grid
)
;
struct
skc_composition_impl
*
const
impl
=
place
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
struct
skc_scheduler
*
const
scheduler
=
runtime
-
>
scheduler
;
SKC_SCHEDULER_SCHEDULE
(
scheduler
skc_composition_place_read_complete
grid
)
;
}
static
void
skc_composition_place_grid_pfn_execute
(
skc_grid_t
const
grid
)
{
struct
skc_composition_place
*
const
place
=
skc_grid_get_data
(
grid
)
;
struct
skc_composition_impl
*
const
impl
=
place
-
>
impl
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
skc_uint
const
work_size
=
skc_extent_ring_snap_count
(
place
-
>
cmds
.
snap
)
;
skc_uint4
const
clip
=
{
0
0
SKC_UINT_MAX
SKC_UINT_MAX
}
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
0
SKC_CL_ARG
(
impl
-
>
runtime
-
>
block_pool
.
blocks
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
1
SKC_CL_ARG
(
impl
-
>
atomics
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
2
SKC_CL_ARG
(
impl
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
3
SKC_CL_ARG
(
place
-
>
cmds
.
drN
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
4
SKC_CL_ARG
(
runtime
-
>
handle_pool
.
map
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
5
SKC_CL_ARG
(
clip
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
place
6
SKC_CL_ARG
(
work_size
)
)
)
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_PLACE
place
-
>
cq
impl
-
>
kernels
.
place
work_size
0
NULL
NULL
)
;
cl_event
complete
;
skc_extent_phr_pdrw_read
(
&
impl
-
>
atomics
place
-
>
cq
&
complete
)
;
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_composition_place_read_cb
grid
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
cl
(
Flush
(
place
-
>
cq
)
)
;
}
static
void
skc_composition_snap
(
struct
skc_composition_impl
*
const
impl
)
{
skc_composition_retain
(
impl
-
>
composition
)
;
skc_subbuf_id_t
id
;
struct
skc_composition_place
*
const
place
=
skc_runtime_host_temp_alloc
(
impl
-
>
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
place
)
&
id
NULL
)
;
place
-
>
id
=
id
;
place
-
>
impl
=
impl
;
skc_grid_set_data
(
impl
-
>
grids
.
place
place
)
;
place
-
>
cq
=
skc_runtime_acquire_cq_in_order
(
impl
-
>
runtime
)
;
skc_extent_ring_checkpoint
(
&
impl
-
>
cmds
.
ring
)
;
skc_extent_phw1g_tdrNs_snap_init
(
impl
-
>
runtime
&
impl
-
>
cmds
.
ring
&
place
-
>
cmds
)
;
skc_extent_phw1g_tdrNs_snap_alloc
(
impl
-
>
runtime
&
impl
-
>
cmds
.
extent
&
place
-
>
cmds
place
-
>
cq
NULL
)
;
skc_grid_force
(
impl
-
>
grids
.
place
)
;
}
static
void
skc_composition_pfn_seal
(
struct
skc_composition_impl
*
const
impl
)
{
if
(
impl
-
>
state
>
=
SKC_COMPOSITION_STATE_SEALING
)
return
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
struct
skc_scheduler
*
const
scheduler
=
runtime
-
>
scheduler
;
if
(
impl
-
>
state
=
=
SKC_COMPOSITION_STATE_UNSEALING
)
{
SKC_SCHEDULER_WAIT_WHILE
(
scheduler
impl
-
>
state
!
=
SKC_COMPOSITION_STATE_UNSEALED
)
;
}
else
{
skc_uint
const
count
=
skc_extent_ring_wip_count
(
&
impl
-
>
cmds
.
ring
)
;
if
(
count
>
0
)
{
skc_composition_snap
(
impl
)
;
}
}
impl
-
>
state
=
SKC_COMPOSITION_STATE_SEALING
;
skc_grid_force
(
impl
-
>
grids
.
sort
)
;
}
void
skc_composition_sort_execute_complete
(
struct
skc_composition_impl
*
const
impl
)
{
impl
-
>
state
=
SKC_COMPOSITION_STATE_SEALED
;
skc_grid_complete
(
impl
-
>
grids
.
sort
)
;
}
static
void
skc_composition_sort_execute_cb
(
cl_event
event
cl_int
status
struct
skc_composition_impl
*
const
impl
)
{
SKC_CL_CB
(
status
)
;
SKC_SCHEDULER_SCHEDULE
(
impl
-
>
runtime
-
>
scheduler
skc_composition_sort_execute_complete
impl
)
;
}
static
void
skc_composition_sort_grid_pfn_execute
(
skc_grid_t
const
grid
)
{
struct
skc_composition_impl
*
const
impl
=
skc_grid_get_data
(
grid
)
;
struct
skc_runtime
*
const
runtime
=
impl
-
>
runtime
;
assert
(
impl
-
>
state
=
=
SKC_COMPOSITION_STATE_SEALING
)
;
struct
skc_place_atomics
*
const
atomics
=
impl
-
>
atomics
.
hr
;
#
ifndef
NDEBUG
fprintf
(
stderr
"
composition
sort
:
%
u
\
n
"
atomics
-
>
keys
)
;
#
endif
if
(
atomics
-
>
keys
>
0
)
{
uint32_t
keys_padded_in
keys_padded_out
;
hs_cl_pad
(
runtime
-
>
hs
atomics
-
>
keys
&
keys_padded_in
&
keys_padded_out
)
;
hs_cl_sort
(
impl
-
>
runtime
-
>
hs
impl
-
>
cq
0
NULL
NULL
impl
-
>
keys
.
drw
NULL
atomics
-
>
keys
keys_padded_in
keys_padded_out
false
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
segment
0
SKC_CL_ARG
(
impl
-
>
keys
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
segment
1
SKC_CL_ARG
(
impl
-
>
offsets
.
drw
)
)
)
;
cl
(
SetKernelArg
(
impl
-
>
kernels
.
segment
2
SKC_CL_ARG
(
impl
-
>
atomics
.
drw
)
)
)
;
skc_device_enqueue_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_SEGMENT_TTCK
impl
-
>
cq
impl
-
>
kernels
.
segment
atomics
-
>
keys
0
NULL
NULL
)
;
}
cl_event
complete
;
skc_extent_phr_pdrw_read
(
&
impl
-
>
atomics
impl
-
>
cq
&
complete
)
;
cl
(
SetEventCallback
(
complete
CL_COMPLETE
skc_composition_sort_execute_cb
impl
)
)
;
cl
(
ReleaseEvent
(
complete
)
)
;
cl
(
Flush
(
impl
-
>
cq
)
)
;
}
static
void
skc_composition_raster_release
(
struct
skc_composition_impl
*
const
impl
)
{
skc_runtime_raster_device_release
(
impl
-
>
runtime
impl
-
>
saved
.
extent
.
hrw
impl
-
>
saved
.
count
)
;
impl
-
>
saved
.
count
=
0
;
}
static
void
skc_composition_unseal_block
(
struct
skc_composition_impl
*
const
impl
skc_bool
const
block
)
{
if
(
impl
-
>
state
=
=
SKC_COMPOSITION_STATE_UNSEALED
)
return
;
struct
skc_scheduler
*
const
scheduler
=
impl
-
>
runtime
-
>
scheduler
;
if
(
impl
-
>
state
=
=
SKC_COMPOSITION_STATE_UNSEALING
)
{
if
(
block
)
{
SKC_SCHEDULER_WAIT_WHILE
(
scheduler
impl
-
>
state
!
=
SKC_COMPOSITION_STATE_UNSEALED
)
;
}
return
;
}
if
(
impl
-
>
state
=
=
SKC_COMPOSITION_STATE_SEALING
)
{
SKC_SCHEDULER_WAIT_WHILE
(
scheduler
impl
-
>
state
!
=
SKC_COMPOSITION_STATE_SEALED
)
;
}
SKC_SCHEDULER_WAIT_WHILE
(
scheduler
impl
-
>
lock_count
>
0
)
;
impl
-
>
grids
.
sort
=
SKC_GRID_DEPS_ATTACH
(
impl
-
>
runtime
-
>
deps
NULL
impl
NULL
skc_composition_sort_grid_pfn_execute
NULL
)
;
impl
-
>
state
=
SKC_COMPOSITION_STATE_UNSEALED
;
}
static
void
skc_composition_reset
(
struct
skc_composition_impl
*
const
impl
)
{
skc_extent_phr_pdrw_zero
(
&
impl
-
>
atomics
impl
-
>
cq
NULL
)
;
cl
(
Flush
(
impl
-
>
cq
)
)
;
skc_composition_raster_release
(
impl
)
;
}
static
void
skc_composition_unseal_block_reset
(
struct
skc_composition_impl
*
const
impl
skc_bool
const
block
skc_bool
const
reset
)
{
skc_composition_unseal_block
(
impl
block
)
;
if
(
reset
)
{
skc_composition_reset
(
impl
)
;
}
}
static
void
skc_composition_pfn_unseal
(
struct
skc_composition_impl
*
const
impl
skc_bool
const
reset
)
{
skc_composition_unseal_block_reset
(
impl
false
reset
)
;
}
static
void
skc_composition_place_create
(
struct
skc_composition_impl
*
const
impl
)
{
impl
-
>
grids
.
place
=
SKC_GRID_DEPS_ATTACH
(
impl
-
>
runtime
-
>
deps
&
impl
-
>
grids
.
place
NULL
NULL
skc_composition_place_grid_pfn_execute
skc_composition_place_grid_pfn_dispose
)
;
skc_grid_happens_after_grid
(
impl
-
>
grids
.
sort
impl
-
>
grids
.
place
)
;
}
static
skc_err
skc_composition_pfn_place
(
struct
skc_composition_impl
*
const
impl
skc_raster_t
const
*
rasters
skc_layer_id
const
*
layer_ids
skc_float
const
*
txs
skc_float
const
*
tys
skc_uint
count
)
{
skc_composition_unseal_block
(
impl
true
)
;
skc_err
err
;
err
=
skc_runtime_handle_device_validate_retain
(
impl
-
>
runtime
SKC_TYPED_HANDLE_TYPE_IS_RASTER
rasters
count
)
;
if
(
err
)
return
err
;
skc_runtime_handle_device_retain
(
impl
-
>
runtime
rasters
count
)
;
skc_raster_t
*
saved
=
impl
-
>
saved
.
extent
.
hrw
;
saved
+
=
impl
-
>
saved
.
count
;
impl
-
>
saved
.
count
+
=
count
;
for
(
skc_uint
ii
=
0
;
ii
<
count
;
ii
+
+
)
{
saved
[
ii
]
=
SKC_TYPED_HANDLE_TO_HANDLE
(
*
rasters
+
+
)
;
}
do
{
skc_uint
rem
;
SKC_SCHEDULER_WAIT_WHILE
(
impl
-
>
runtime
-
>
scheduler
(
rem
=
skc_extent_ring_wip_rem
(
&
impl
-
>
cmds
.
ring
)
)
=
=
0
)
;
skc_uint
avail
=
min
(
rem
count
)
;
count
-
=
avail
;
skc_bool
const
is_wip_full
=
(
avail
=
=
rem
)
;
if
(
impl
-
>
grids
.
place
=
=
NULL
)
{
skc_composition_place_create
(
impl
)
;
}
union
skc_cmd_place
*
const
cmds
=
impl
-
>
cmds
.
extent
.
hw1
;
if
(
(
txs
=
=
NULL
)
&
&
(
tys
=
=
NULL
)
)
{
while
(
avail
-
-
>
0
)
{
skc_raster_t
const
raster
=
*
saved
+
+
;
skc_grid_happens_after_handle
(
impl
-
>
grids
.
place
raster
)
;
cmds
[
skc_extent_ring_wip_index_inc
(
&
impl
-
>
cmds
.
ring
)
]
=
(
union
skc_cmd_place
)
{
raster
*
layer_ids
+
+
0
0
}
;
}
}
else
if
(
txs
=
=
NULL
)
{
while
(
avail
-
-
>
0
)
{
skc_raster_t
const
raster
=
*
saved
+
+
;
skc_grid_happens_after_handle
(
impl
-
>
grids
.
place
raster
)
;
cmds
[
skc_extent_ring_wip_index_inc
(
&
impl
-
>
cmds
.
ring
)
]
=
(
union
skc_cmd_place
)
{
raster
*
layer_ids
+
+
0
SKC_PLACE_CMD_TY_CONVERT
(
*
tys
+
+
)
}
;
}
}
else
if
(
tys
=
=
NULL
)
{
while
(
avail
-
-
>
0
)
{
skc_raster_t
const
raster
=
*
saved
+
+
;
skc_grid_happens_after_handle
(
impl
-
>
grids
.
place
raster
)
;
cmds
[
skc_extent_ring_wip_index_inc
(
&
impl
-
>
cmds
.
ring
)
]
=
(
union
skc_cmd_place
)
{
raster
*
layer_ids
+
+
SKC_PLACE_CMD_TX_CONVERT
(
*
txs
+
+
)
0
}
;
}
}
else
{
while
(
avail
-
-
>
0
)
{
skc_raster_t
const
raster
=
*
saved
+
+
;
skc_grid_happens_after_handle
(
impl
-
>
grids
.
place
raster
)
;
cmds
[
skc_extent_ring_wip_index_inc
(
&
impl
-
>
cmds
.
ring
)
]
=
(
union
skc_cmd_place
)
{
raster
*
layer_ids
+
+
SKC_PLACE_CMD_TX_CONVERT
(
*
txs
+
+
)
SKC_PLACE_CMD_TY_CONVERT
(
*
tys
+
+
)
}
;
}
}
if
(
is_wip_full
)
{
skc_composition_snap
(
impl
)
;
}
}
while
(
count
>
0
)
;
return
SKC_ERR_SUCCESS
;
}
static
void
skc_composition_pfn_bounds
(
struct
skc_composition_impl
*
const
impl
skc_int
bounds
[
4
]
)
{
bounds
[
0
]
=
SKC_INT_MIN
;
bounds
[
1
]
=
SKC_INT_MIN
;
bounds
[
2
]
=
SKC_INT_MAX
;
bounds
[
3
]
=
SKC_INT_MAX
;
}
void
skc_composition_retain_and_lock
(
struct
skc_composition
*
const
composition
)
{
skc_composition_retain
(
composition
)
;
composition
-
>
impl
-
>
lock_count
+
=
1
;
}
void
skc_composition_unlock_and_release
(
struct
skc_composition
*
const
composition
)
{
composition
-
>
impl
-
>
lock_count
-
=
1
;
skc_composition_pfn_release
(
composition
-
>
impl
)
;
}
skc_err
skc_composition_cl_12_create
(
struct
skc_context
*
const
context
struct
skc_composition
*
*
const
composition
)
{
struct
skc_runtime
*
const
runtime
=
context
-
>
runtime
;
struct
skc_composition_impl
*
const
impl
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
impl
)
)
;
(
*
composition
)
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
*
composition
)
)
;
(
*
composition
)
-
>
context
=
context
;
(
*
composition
)
-
>
impl
=
impl
;
(
*
composition
)
-
>
ref_count
=
1
;
(
*
composition
)
-
>
place
=
skc_composition_pfn_place
;
(
*
composition
)
-
>
unseal
=
skc_composition_pfn_unseal
;
(
*
composition
)
-
>
seal
=
skc_composition_pfn_seal
;
(
*
composition
)
-
>
bounds
=
skc_composition_pfn_bounds
;
(
*
composition
)
-
>
release
=
skc_composition_pfn_release
;
impl
-
>
composition
=
(
*
composition
)
;
impl
-
>
runtime
=
runtime
;
SKC_ASSERT_STATE_INIT
(
impl
SKC_COMPOSITION_STATE_SEALED
)
;
impl
-
>
lock_count
=
0
;
impl
-
>
grids
.
sort
=
NULL
;
impl
-
>
grids
.
place
=
NULL
;
impl
-
>
cq
=
skc_runtime_acquire_cq_in_order
(
runtime
)
;
impl
-
>
kernels
.
place
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_PLACE
)
;
impl
-
>
kernels
.
segment
=
skc_device_acquire_kernel
(
runtime
-
>
device
SKC_DEVICE_KERNEL_ID_SEGMENT_TTCK
)
;
struct
skc_config
const
*
const
config
=
runtime
-
>
config
;
skc_extent_ring_init
(
&
impl
-
>
cmds
.
ring
config
-
>
composition
.
cmds
.
elem_count
config
-
>
composition
.
cmds
.
snap_count
sizeof
(
union
skc_cmd_place
)
)
;
skc_extent_phw1g_tdrNs_alloc
(
runtime
&
impl
-
>
cmds
.
extent
sizeof
(
union
skc_cmd_place
)
*
config
-
>
composition
.
cmds
.
elem_count
)
;
skc_extent_phrw_alloc
(
runtime
&
impl
-
>
saved
.
extent
sizeof
(
skc_raster_t
)
*
config
-
>
composition
.
raster_ids
.
elem_count
)
;
skc_extent_phr_pdrw_alloc
(
runtime
&
impl
-
>
atomics
sizeof
(
struct
skc_place_atomics
)
)
;
skc_extent_pdrw_alloc
(
runtime
&
impl
-
>
keys
sizeof
(
skc_ttxk_t
)
*
config
-
>
composition
.
keys
.
elem_count
)
;
skc_extent_pdrw_alloc
(
runtime
&
impl
-
>
offsets
sizeof
(
skc_uint
)
*
(
1u
<
<
SKC_TTCK_HI_BITS_YX
)
)
;
impl
-
>
saved
.
count
=
0
;
skc_composition_unseal_block_reset
(
impl
false
true
)
;
return
SKC_ERR_SUCCESS
;
}
