#
pragma
once
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
<
stdbool
.
h
>
#
include
"
grid
.
h
"
#
include
"
macros
.
h
"
#
include
"
runtime_cl_12
.
h
"
typedef
skc_uchar
skc_grid_id_t
;
#
define
SKC_GRID_ID_INVALID
SKC_UCHAR_MAX
/
/
255
#
define
SKC_GRID_SIZE_IDS
(
SKC_GRID_ID_INVALID
-
1
)
#
define
SKC_GRID_SIZE_WORDS
(
(
SKC_GRID_SIZE_IDS
+
31
)
/
32
)
typedef
enum
skc_grid_state_e
{
SKC_GRID_STATE_READY
SKC_GRID_STATE_WAITING
SKC_GRID_STATE_FORCED
SKC_GRID_STATE_EXECUTING
SKC_GRID_STATE_COMPLETE
SKC_GRID_STATE_DETACHED
SKC_GRID_STATE_COUNT
}
skc_grid_state_e
;
struct
skc_grid_pfn_name
{
skc_grid_pfn
pfn
;
char
const
*
name
;
}
;
struct
skc_grid
{
skc_grid_state_e
state
;
skc_uint
id
;
struct
skc_grid_deps
*
deps
;
void
*
*
addr
;
void
*
data
;
struct
skc_grid_pfn_name
waiting
;
struct
skc_grid_pfn_name
execute
;
struct
skc_grid_pfn_name
dispose
;
struct
{
skc_uint
words
[
SKC_GRID_SIZE_WORDS
]
;
skc_uint
count
;
}
before
;
struct
{
skc_uint
words
[
SKC_GRID_SIZE_WORDS
]
;
skc_uint
count
;
}
after
;
}
;
struct
skc_grid_deps
{
struct
skc_runtime
*
runtime
;
struct
skc_scheduler
*
scheduler
;
skc_grid_id_t
*
handle_map
;
struct
skc_grid
grids
[
SKC_GRID_SIZE_IDS
]
;
skc_uint
active
[
SKC_GRID_SIZE_WORDS
]
;
skc_uint
count
;
}
;
static
void
skc_grid_call
(
skc_grid_t
const
grid
struct
skc_grid_pfn_name
const
*
const
pn
)
{
if
(
pn
-
>
pfn
!
=
NULL
)
{
pn
-
>
pfn
(
grid
)
;
}
}
static
void
skc_grid_schedule
(
skc_grid_t
const
grid
struct
skc_grid_pfn_name
const
*
const
pn
)
{
if
(
pn
-
>
pfn
!
=
NULL
)
{
skc_scheduler_schedule
(
grid
-
>
deps
-
>
scheduler
pn
-
>
pfn
grid
pn
-
>
name
)
;
}
}
static
void
skc_grid_invalidate
(
skc_grid_t
const
grid
)
{
if
(
grid
-
>
addr
!
=
NULL
)
{
*
grid
-
>
addr
=
NULL
;
}
}
#
if
0
skc_grid_t
skc_grid_move
(
skc_grid_t
const
grid
skc_grid_state_e
*
const
state
skc_grid_t
*
const
addr
void
*
const
data
)
{
skc_grid_invalidate
(
grid
)
;
grid
-
>
state
=
state
;
grid
-
>
addr
=
addr
;
grid
-
>
data
=
data
;
return
grid
;
}
#
endif
void
*
skc_grid_get_data
(
skc_grid_t
const
grid
)
{
return
grid
-
>
data
;
}
void
skc_grid_set_data
(
skc_grid_t
const
grid
void
*
const
data
)
{
grid
-
>
data
=
data
;
}
skc_grid_deps_t
skc_grid_deps_create
(
struct
skc_runtime
*
const
runtime
struct
skc_scheduler
*
const
scheduler
skc_uint
const
handle_pool_size
)
{
struct
skc_grid_deps
*
const
deps
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
sizeof
(
*
deps
)
)
;
deps
-
>
runtime
=
runtime
;
deps
-
>
scheduler
=
scheduler
;
size_t
const
handle_map_size
=
sizeof
(
*
deps
-
>
handle_map
)
*
handle_pool_size
;
deps
-
>
handle_map
=
skc_runtime_host_perm_alloc
(
runtime
SKC_MEM_FLAGS_READ_WRITE
handle_map_size
)
;
memset
(
deps
-
>
handle_map
0xFF
handle_map_size
)
;
struct
skc_grid
*
const
grids
=
deps
-
>
grids
;
#
if
0
for
(
skc_uint
id
=
0
;
id
<
SKC_GRID_SIZE_IDS
;
id
+
+
)
grids
[
id
]
.
id
=
id
;
#
endif
for
(
skc_uint
ii
=
0
;
ii
<
SKC_GRID_SIZE_WORDS
-
1
;
ii
+
+
)
deps
-
>
active
[
ii
]
=
0xFFFFFFFF
;
deps
-
>
active
[
SKC_GRID_SIZE_WORDS
-
1
]
=
0x7FFFFFFF
;
deps
-
>
count
=
1
;
return
deps
;
}
void
skc_grid_deps_dispose
(
skc_grid_deps_t
const
deps
)
{
skc_runtime_host_perm_free
(
deps
-
>
runtime
deps
-
>
handle_map
)
;
skc_runtime_host_perm_free
(
deps
-
>
runtime
deps
)
;
}
#
ifndef
NDEBUG
void
skc_grid_deps_debug
(
struct
skc_grid_deps
const
*
const
deps
)
{
fprintf
(
stderr
"
00000000000000001111111111111111
\
n
"
"
0123456789ABCDEF0123456789ABCDEF
\
n
"
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
for
(
skc_uint
ii
=
0
;
ii
<
SKC_GRID_SIZE_WORDS
;
ii
+
+
)
{
skc_uint
const
a
=
deps
-
>
active
[
ii
]
;
fprintf
(
stderr
"
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
"
"
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
%
1u
\
n
"
(
a
>
>
0x00
)
&
1
(
a
>
>
0x01
)
&
1
(
a
>
>
0x02
)
&
1
(
a
>
>
0x03
)
&
1
(
a
>
>
0x04
)
&
1
(
a
>
>
0x05
)
&
1
(
a
>
>
0x06
)
&
1
(
a
>
>
0x07
)
&
1
(
a
>
>
0x08
)
&
1
(
a
>
>
0x09
)
&
1
(
a
>
>
0x0A
)
&
1
(
a
>
>
0x0B
)
&
1
(
a
>
>
0x0C
)
&
1
(
a
>
>
0x0D
)
&
1
(
a
>
>
0x0E
)
&
1
(
a
>
>
0x0F
)
&
1
(
a
>
>
0x10
)
&
1
(
a
>
>
0x11
)
&
1
(
a
>
>
0x12
)
&
1
(
a
>
>
0x13
)
&
1
(
a
>
>
0x14
)
&
1
(
a
>
>
0x15
)
&
1
(
a
>
>
0x16
)
&
1
(
a
>
>
0x17
)
&
1
(
a
>
>
0x18
)
&
1
(
a
>
>
0x19
)
&
1
(
a
>
>
0x1A
)
&
1
(
a
>
>
0x1B
)
&
1
(
a
>
>
0x1C
)
&
1
(
a
>
>
0x1D
)
&
1
(
a
>
>
0x1E
)
&
1
(
a
>
>
0x1F
)
&
1
)
;
}
fprintf
(
stderr
"
\
n
"
)
;
}
#
endif
skc_grid_t
skc_grid_deps_attach
(
skc_grid_deps_t
const
deps
skc_grid_t
*
const
addr
void
*
const
data
skc_grid_pfn
waiting_pfn
skc_grid_pfn
execute_pfn
skc_grid_pfn
dispose_pfn
char
const
*
const
waiting_name
char
const
*
const
execute_name
char
const
*
const
dispose_name
)
{
while
(
deps
-
>
count
=
=
SKC_GRID_SIZE_IDS
)
skc_scheduler_wait_one
(
deps
-
>
scheduler
)
;
deps
-
>
count
+
=
1
;
skc_uint
*
active
=
deps
-
>
active
;
skc_uint
first
=
0
;
while
(
1
)
{
skc_uint
const
idx
=
SKC_LZCNT_32
(
*
active
)
;
first
+
=
idx
;
if
(
idx
<
32
)
{
*
active
&
=
~
(
0x80000000
>
>
idx
)
;
break
;
}
active
+
=
1
;
}
struct
skc_grid
*
const
grid
=
deps
-
>
grids
+
first
;
if
(
addr
!
=
NULL
)
*
addr
=
grid
;
*
grid
=
(
struct
skc_grid
)
{
.
state
=
SKC_GRID_STATE_READY
.
id
=
first
.
deps
=
deps
.
addr
=
addr
.
data
=
data
.
waiting
=
{
.
pfn
=
waiting_pfn
.
name
=
waiting_name
}
.
execute
=
{
.
pfn
=
execute_pfn
.
name
=
execute_name
}
.
dispose
=
{
.
pfn
=
dispose_pfn
.
name
=
dispose_name
}
.
before
=
{
{
0
}
0
}
.
after
=
{
{
0
}
0
}
}
;
return
grid
;
}
static
skc_bool
skc_grid_words_set
(
skc_uint
ids
[
SKC_GRID_SIZE_WORDS
]
skc_uint
const
id
)
{
skc_uint
*
const
ptr
=
ids
+
(
id
/
32
)
;
skc_uint
const
pre
=
*
ptr
;
skc_uint
const
post
=
pre
|
(
0x80000000
>
>
(
id
&
0x1F
)
)
;
*
ptr
=
post
;
return
pre
!
=
post
;
}
static
skc_bool
skc_grid_words_clear
(
skc_uint
ids
[
SKC_GRID_SIZE_WORDS
]
skc_uint
const
id
)
{
skc_uint
*
const
ptr
=
ids
+
(
id
/
32
)
;
skc_uint
const
pre
=
*
ptr
;
skc_uint
const
post
=
pre
&
~
(
0x80000000
>
>
(
id
&
0x1F
)
)
;
*
ptr
=
post
;
return
pre
!
=
post
;
}
static
void
skc_grid_detach
(
skc_grid_t
const
grid
)
{
grid
-
>
state
=
SKC_GRID_STATE_DETACHED
;
if
(
skc_grid_words_set
(
grid
-
>
deps
-
>
active
grid
-
>
id
)
)
grid
-
>
deps
-
>
count
-
=
1
;
}
void
skc_grid_map
(
skc_grid_t
const
grid
skc_handle_t
const
handle
)
{
grid
-
>
deps
-
>
handle_map
[
handle
]
=
grid
-
>
id
;
}
void
skc_grid_deps_force
(
skc_grid_deps_t
const
deps
skc_handle_t
const
*
const
handles
skc_uint
const
count
)
{
skc_grid_id_t
*
const
handle_map
=
deps
-
>
handle_map
;
for
(
skc_uint
ii
=
0
;
ii
<
count
;
ii
+
+
)
{
skc_grid_id_t
grid_id
=
handle_map
[
SKC_TYPED_HANDLE_TO_HANDLE
(
handles
[
ii
]
)
]
;
if
(
grid_id
<
SKC_GRID_ID_INVALID
)
{
skc_grid_t
const
grid
=
deps
-
>
grids
+
grid_id
;
skc_grid_force
(
grid
)
;
while
(
grid
-
>
state
>
=
SKC_GRID_STATE_COMPLETE
)
skc_scheduler_wait_one
(
deps
-
>
scheduler
)
;
}
}
}
void
skc_grid_deps_unmap
(
skc_grid_deps_t
const
deps
skc_handle_t
const
*
const
handles
skc_uint
const
count
)
{
skc_grid_id_t
*
const
handle_map
=
deps
-
>
handle_map
;
for
(
skc_uint
ii
=
0
;
ii
<
count
;
ii
+
+
)
handle_map
[
handles
[
ii
]
]
=
SKC_GRID_ID_INVALID
;
}
void
skc_grid_happens_after_grid
(
skc_grid_t
const
after
skc_grid_t
const
before
)
{
assert
(
after
-
>
state
=
=
SKC_GRID_STATE_READY
)
;
if
(
before
-
>
state
>
=
SKC_GRID_STATE_COMPLETE
)
return
;
if
(
skc_grid_words_set
(
after
-
>
before
.
words
before
-
>
id
)
)
after
-
>
before
.
count
+
=
1
;
if
(
skc_grid_words_set
(
before
-
>
after
.
words
after
-
>
id
)
)
before
-
>
after
.
count
+
=
1
;
}
void
skc_grid_happens_after_handle
(
skc_grid_t
const
after
skc_handle_t
const
before
)
{
assert
(
after
-
>
state
=
=
SKC_GRID_STATE_READY
)
;
skc_uint
const
id_before
=
after
-
>
deps
-
>
handle_map
[
before
]
;
if
(
id_before
>
=
SKC_GRID_ID_INVALID
)
return
;
if
(
skc_grid_words_set
(
after
-
>
before
.
words
id_before
)
)
after
-
>
before
.
count
+
=
1
;
skc_grid_t
const
grid_before
=
after
-
>
deps
-
>
grids
+
id_before
;
if
(
skc_grid_words_set
(
grid_before
-
>
after
.
words
after
-
>
id
)
)
grid_before
-
>
after
.
count
+
=
1
;
}
static
void
skc_grid_clear_dependency
(
skc_grid_t
const
after
skc_uint
const
before
)
{
skc_bool
const
is_change
=
skc_grid_words_clear
(
after
-
>
before
.
words
before
)
;
assert
(
is_change
)
;
after
-
>
before
.
count
-
=
1
;
if
(
(
after
-
>
before
.
count
=
=
0
)
&
&
(
(
after
-
>
state
=
=
SKC_GRID_STATE_WAITING
)
|
|
(
after
-
>
state
=
=
SKC_GRID_STATE_FORCED
)
)
)
{
after
-
>
state
=
SKC_GRID_STATE_EXECUTING
;
skc_grid_schedule
(
after
&
after
-
>
execute
)
;
}
}
void
skc_grid_start
(
skc_grid_t
const
grid
)
{
if
(
grid
-
>
state
!
=
SKC_GRID_STATE_READY
)
return
;
grid
-
>
state
=
SKC_GRID_STATE_WAITING
;
skc_grid_call
(
grid
&
grid
-
>
waiting
)
;
skc_grid_invalidate
(
grid
)
;
if
(
grid
-
>
before
.
count
=
=
0
)
{
grid
-
>
state
=
SKC_GRID_STATE_EXECUTING
;
skc_grid_schedule
(
grid
&
grid
-
>
execute
)
;
}
}
void
skc_grid_force
(
skc_grid_t
const
grid
)
{
if
(
grid
-
>
state
>
=
SKC_GRID_STATE_FORCED
)
return
;
if
(
grid
-
>
state
=
=
SKC_GRID_STATE_READY
)
{
grid
-
>
state
=
SKC_GRID_STATE_WAITING
;
skc_grid_call
(
grid
&
grid
-
>
waiting
)
;
skc_grid_invalidate
(
grid
)
;
}
skc_uint
before_count
=
grid
-
>
before
.
count
;
if
(
before_count
=
=
0
)
{
grid
-
>
state
=
SKC_GRID_STATE_EXECUTING
;
skc_grid_schedule
(
grid
&
grid
-
>
execute
)
;
}
else
{
grid
-
>
state
=
SKC_GRID_STATE_FORCED
;
struct
skc_grid
*
before
=
grid
-
>
deps
-
>
grids
;
skc_uint
*
before_words
=
grid
-
>
before
.
words
;
skc_uint
active
=
*
before_words
+
+
;
while
(
true
)
{
skc_uint
const
idx
=
SKC_LZCNT_32
(
active
)
;
if
(
idx
=
=
32
)
{
active
=
*
before_words
+
+
;
before
+
=
1
;
continue
;
}
else
{
active
&
=
~
(
0x80000000
>
>
idx
)
;
before_count
-
=
1
;
}
skc_grid_force
(
before
+
idx
)
;
if
(
before_count
=
=
0
)
break
;
}
}
}
void
skc_grid_complete
(
skc_grid_t
const
grid
)
{
assert
(
grid
-
>
state
=
=
SKC_GRID_STATE_EXECUTING
)
;
grid
-
>
state
=
SKC_GRID_STATE_COMPLETE
;
skc_uint
after_count
=
grid
-
>
after
.
count
;
if
(
after_count
>
0
)
{
struct
skc_grid
*
after
=
grid
-
>
deps
-
>
grids
;
skc_uint
*
after_words
=
grid
-
>
after
.
words
;
skc_uint
active
=
*
after_words
+
+
;
while
(
true
)
{
skc_uint
const
idx
=
SKC_LZCNT_32
(
active
)
;
if
(
idx
=
=
32
)
{
active
=
*
after_words
+
+
;
after
+
=
32
;
continue
;
}
else
{
active
&
=
~
(
0x80000000
>
>
idx
)
;
after_count
-
=
1
;
}
skc_grid_clear_dependency
(
after
+
idx
grid
-
>
id
)
;
if
(
after_count
=
=
0
)
break
;
}
}
skc_grid_call
(
grid
&
grid
-
>
dispose
)
;
skc_grid_detach
(
grid
)
;
}
#
if
0
#
define
SKC_GRID_STAGE_WORDS_PATH_BUILDER
SKC_GRID_MASK_WORDS
#
define
SKC_GRID_STAGE_WORDS_RASTER_BUILDER
SKC_GRID_MASK_WORDS
#
define
SKC_GRID_STAGE_WORDS_COMPOSITION
SKC_GRID_MASK_WORDS
#
define
SKC_GRID_STAGE_WORDS_STYLING
SKC_GRID_MASK_WORDS
#
define
SKC_GRID_STAGE_WORDS_SURFACE_COMPOSITION
SKC_GRID_MASK_WORDS
#
define
SKC_GRID_STAGE_WORDS_SURFACE_STYLING
SKC_GRID_MASK_WORDS
typedef
enum
skc_grid_stage_type
{
SKC_GRID_STAGE_TYPE_PATH_BUILDER
SKC_GRID_STAGE_TYPE_RASTER_BUILDER
SKC_GRID_STAGE_TYPE_COMPOSITION
SKC_GRID_STAGE_TYPE_STYLING
SKC_GRID_STAGE_TYPE_SURFACE_COMPOSITION
SKC_GRID_STAGE_TYPE_SURFACE_STYLING
SKC_GRID_STAGE_TYPE_COUNT
}
skc_grid_stage_type
;
union
skc_grid_id
{
skc_grid_id_t
u32
;
struct
{
skc_ushort
index
;
skc_ushort
stage
;
}
;
}
SKC_STATIC_ASSERT
(
sizeof
(
union
skc_grid_id
)
=
=
sizeof
(
skc_uint
)
)
;
#
endif
