#
ifndef
Sk4pxXfermode_DEFINED
#
define
Sk4pxXfermode_DEFINED
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
src
/
core
/
Sk4px
.
h
"
#
include
"
src
/
core
/
SkMSAN
.
h
"
#
include
"
src
/
core
/
SkXfermodePriv
.
h
"
#
ifdef
SK_FORCE_RASTER_PIPELINE_BLITTER
namespace
SK_OPTS_NS
{
inline
SkXfermode
*
create_xfermode
(
SkBlendMode
)
{
return
nullptr
;
}
}
#
else
namespace
{
#
define
XFERMODE
(
Xfermode
)
\
struct
Xfermode
{
Sk4px
operator
(
)
(
const
Sk4px
&
const
Sk4px
&
)
const
;
}
;
\
inline
Sk4px
Xfermode
:
:
operator
(
)
(
const
Sk4px
&
d
const
Sk4px
&
s
)
const
XFERMODE
(
Clear
)
{
return
Sk4px
:
:
DupPMColor
(
0
)
;
}
XFERMODE
(
Src
)
{
return
s
;
}
XFERMODE
(
Dst
)
{
return
d
;
}
XFERMODE
(
SrcIn
)
{
return
s
.
approxMulDiv255
(
d
.
alphas
(
)
)
;
}
XFERMODE
(
SrcOut
)
{
return
s
.
approxMulDiv255
(
d
.
alphas
(
)
.
inv
(
)
)
;
}
XFERMODE
(
SrcOver
)
{
return
s
+
d
.
approxMulDiv255
(
s
.
alphas
(
)
.
inv
(
)
)
;
}
XFERMODE
(
DstIn
)
{
return
SrcIn
(
)
(
s
d
)
;
}
XFERMODE
(
DstOut
)
{
return
SrcOut
(
)
(
s
d
)
;
}
XFERMODE
(
DstOver
)
{
return
SrcOver
(
)
(
s
d
)
;
}
XFERMODE
(
SrcATop
)
{
return
(
s
*
d
.
alphas
(
)
+
d
*
s
.
alphas
(
)
.
inv
(
)
)
.
div255
(
)
;
}
XFERMODE
(
DstATop
)
{
return
SrcATop
(
)
(
s
d
)
;
}
XFERMODE
(
Xor
)
{
return
(
s
*
d
.
alphas
(
)
.
inv
(
)
+
d
*
s
.
alphas
(
)
.
inv
(
)
)
.
div255
(
)
;
}
XFERMODE
(
Plus
)
{
return
s
.
saturatedAdd
(
d
)
;
}
XFERMODE
(
Modulate
)
{
return
s
.
approxMulDiv255
(
d
)
;
}
XFERMODE
(
Screen
)
{
return
s
+
d
.
approxMulDiv255
(
s
.
inv
(
)
)
;
}
#
undef
XFERMODE
template
<
typename
Xfermode
>
static
Sk4px
xfer_aa
(
const
Sk4px
&
d
const
Sk4px
&
s
const
Sk4px
&
aa
)
{
Sk4px
bw
=
Xfermode
(
)
(
d
s
)
;
return
(
bw
*
aa
+
d
*
aa
.
inv
(
)
)
.
div255
(
)
;
}
#
define
XFERMODE_AA
(
Xfermode
)
\
template
<
>
Sk4px
xfer_aa
<
Xfermode
>
(
const
Sk4px
&
d
const
Sk4px
&
s
const
Sk4px
&
aa
)
XFERMODE_AA
(
Plus
)
{
return
d
.
saturatedAdd
(
s
.
approxMulDiv255
(
aa
)
)
;
}
#
undef
XFERMODE_AA
template
<
typename
Xfermode
>
static
void
mark_dst_initialized_if_safe
(
void
*
void
*
)
{
}
template
<
>
void
mark_dst_initialized_if_safe
<
Src
>
(
void
*
dst
void
*
end
)
{
sk_msan_mark_initialized
(
dst
end
"
Src
doesn
'
t
read
dst
.
"
)
;
}
template
<
>
void
mark_dst_initialized_if_safe
<
Clear
>
(
void
*
dst
void
*
end
)
{
sk_msan_mark_initialized
(
dst
end
"
Clear
doesn
'
t
read
dst
.
"
)
;
}
template
<
typename
Xfermode
>
class
Sk4pxXfermode
:
public
SkXfermode
{
public
:
Sk4pxXfermode
(
)
{
}
void
xfer32
(
SkPMColor
dst
[
]
const
SkPMColor
src
[
]
int
n
const
SkAlpha
aa
[
]
)
const
override
{
mark_dst_initialized_if_safe
<
Xfermode
>
(
dst
dst
+
n
)
;
if
(
nullptr
=
=
aa
)
{
Sk4px
:
:
MapDstSrc
(
n
dst
src
Xfermode
(
)
)
;
}
else
{
Sk4px
:
:
MapDstSrcAlpha
(
n
dst
src
aa
xfer_aa
<
Xfermode
>
)
;
}
}
}
;
}
namespace
SK_OPTS_NS
{
inline
SkXfermode
*
create_xfermode
(
SkBlendMode
mode
)
{
switch
(
mode
)
{
#
define
CASE
(
Xfermode
)
\
case
SkBlendMode
:
:
k
#
#
Xfermode
:
return
new
Sk4pxXfermode
<
Xfermode
>
(
)
CASE
(
Clear
)
;
CASE
(
Src
)
;
CASE
(
Dst
)
;
CASE
(
SrcOver
)
;
CASE
(
DstOver
)
;
CASE
(
SrcIn
)
;
CASE
(
DstIn
)
;
CASE
(
SrcOut
)
;
CASE
(
DstOut
)
;
CASE
(
SrcATop
)
;
CASE
(
DstATop
)
;
CASE
(
Xor
)
;
CASE
(
Plus
)
;
CASE
(
Modulate
)
;
CASE
(
Screen
)
;
#
undef
CASE
default
:
break
;
}
return
nullptr
;
}
}
#
endif
#
endif
