#
ifndef
Sk4pxXfermode_DEFINED
#
define
Sk4pxXfermode_DEFINED
#
include
"
Sk4px
.
h
"
#
include
"
SkMSAN
.
h
"
#
include
"
SkNx
.
h
"
#
include
"
SkXfermodePriv
.
h
"
namespace
{
#
define
XFERMODE
(
Xfermode
)
\
struct
Xfermode
{
Sk4px
operator
(
)
(
const
Sk4px
&
const
Sk4px
&
)
const
;
}
;
\
inline
Sk4px
Xfermode
:
:
operator
(
)
(
const
Sk4px
&
d
const
Sk4px
&
s
)
const
XFERMODE
(
Clear
)
{
return
Sk4px
:
:
DupPMColor
(
0
)
;
}
XFERMODE
(
Src
)
{
return
s
;
}
XFERMODE
(
Dst
)
{
return
d
;
}
XFERMODE
(
SrcIn
)
{
return
s
.
approxMulDiv255
(
d
.
alphas
(
)
)
;
}
XFERMODE
(
SrcOut
)
{
return
s
.
approxMulDiv255
(
d
.
alphas
(
)
.
inv
(
)
)
;
}
XFERMODE
(
SrcOver
)
{
return
s
+
d
.
approxMulDiv255
(
s
.
alphas
(
)
.
inv
(
)
)
;
}
XFERMODE
(
DstIn
)
{
return
SrcIn
(
)
(
s
d
)
;
}
XFERMODE
(
DstOut
)
{
return
SrcOut
(
)
(
s
d
)
;
}
XFERMODE
(
DstOver
)
{
return
SrcOver
(
)
(
s
d
)
;
}
XFERMODE
(
SrcATop
)
{
return
(
s
*
d
.
alphas
(
)
+
d
*
s
.
alphas
(
)
.
inv
(
)
)
.
div255
(
)
;
}
XFERMODE
(
DstATop
)
{
return
SrcATop
(
)
(
s
d
)
;
}
XFERMODE
(
Xor
)
{
return
(
s
*
d
.
alphas
(
)
.
inv
(
)
+
d
*
s
.
alphas
(
)
.
inv
(
)
)
.
div255
(
)
;
}
XFERMODE
(
Plus
)
{
return
s
.
saturatedAdd
(
d
)
;
}
XFERMODE
(
Modulate
)
{
return
s
.
approxMulDiv255
(
d
)
;
}
XFERMODE
(
Screen
)
{
return
s
+
d
.
approxMulDiv255
(
s
.
inv
(
)
)
;
}
XFERMODE
(
Multiply
)
{
return
(
s
*
d
.
alphas
(
)
.
inv
(
)
+
d
*
s
.
alphas
(
)
.
inv
(
)
+
s
*
d
)
.
div255
(
)
;
}
XFERMODE
(
Difference
)
{
auto
m
=
Sk4px
:
:
Wide
:
:
Min
(
s
*
d
.
alphas
(
)
d
*
s
.
alphas
(
)
)
.
div255
(
)
;
return
(
s
-
m
)
+
(
d
-
m
.
zeroAlphas
(
)
)
;
}
XFERMODE
(
Exclusion
)
{
auto
p
=
s
.
approxMulDiv255
(
d
)
;
return
(
s
-
p
)
+
(
d
-
p
.
zeroAlphas
(
)
)
;
}
XFERMODE
(
HardLight
)
{
auto
sa
=
s
.
alphas
(
)
da
=
d
.
alphas
(
)
;
auto
srcover
=
s
+
(
d
*
sa
.
inv
(
)
)
.
div255
(
)
;
auto
isLite
=
(
(
sa
-
s
)
<
s
)
.
widenLoHi
(
)
;
auto
lite
=
sa
*
da
-
(
(
da
-
d
)
*
(
sa
-
s
)
<
<
1
)
dark
=
s
*
d
<
<
1
both
=
s
*
da
.
inv
(
)
+
d
*
sa
.
inv
(
)
;
auto
alphas
=
srcover
;
auto
colors
=
(
both
+
isLite
.
thenElse
(
lite
dark
)
)
.
div255
(
)
;
return
alphas
.
zeroColors
(
)
+
colors
.
zeroAlphas
(
)
;
}
XFERMODE
(
Overlay
)
{
return
HardLight
(
)
(
s
d
)
;
}
XFERMODE
(
Darken
)
{
auto
sa
=
s
.
alphas
(
)
da
=
d
.
alphas
(
)
;
auto
sda
=
(
s
*
da
)
.
div255
(
)
dsa
=
(
d
*
sa
)
.
div255
(
)
;
auto
srcover
=
s
+
(
d
*
sa
.
inv
(
)
)
.
div255
(
)
dstover
=
d
+
(
s
*
da
.
inv
(
)
)
.
div255
(
)
;
auto
alphas
=
srcover
colors
=
(
sda
<
dsa
)
.
thenElse
(
srcover
dstover
)
;
return
alphas
.
zeroColors
(
)
+
colors
.
zeroAlphas
(
)
;
}
XFERMODE
(
Lighten
)
{
auto
sa
=
s
.
alphas
(
)
da
=
d
.
alphas
(
)
;
auto
sda
=
(
s
*
da
)
.
div255
(
)
dsa
=
(
d
*
sa
)
.
div255
(
)
;
auto
srcover
=
s
+
(
d
*
sa
.
inv
(
)
)
.
div255
(
)
dstover
=
d
+
(
s
*
da
.
inv
(
)
)
.
div255
(
)
;
auto
alphas
=
srcover
colors
=
(
dsa
<
sda
)
.
thenElse
(
srcover
dstover
)
;
return
alphas
.
zeroColors
(
)
+
colors
.
zeroAlphas
(
)
;
}
#
undef
XFERMODE
#
define
XFERMODE
(
Xfermode
)
\
struct
Xfermode
{
Sk4f
operator
(
)
(
const
Sk4f
&
const
Sk4f
&
)
const
;
}
;
\
inline
Sk4f
Xfermode
:
:
operator
(
)
(
const
Sk4f
&
d
const
Sk4f
&
s
)
const
static
inline
Sk4f
a_rgb
(
const
Sk4f
&
a
const
Sk4f
&
rgb
)
{
static_assert
(
SK_A32_SHIFT
=
=
24
"
"
)
;
return
a
*
Sk4f
(
0
0
0
1
)
+
rgb
*
Sk4f
(
1
1
1
0
)
;
}
static
inline
Sk4f
alphas
(
const
Sk4f
&
f
)
{
return
f
[
SK_A32_SHIFT
/
8
]
;
}
XFERMODE
(
ColorDodge
)
{
auto
sa
=
alphas
(
s
)
da
=
alphas
(
d
)
isa
=
Sk4f
(
1
)
-
sa
ida
=
Sk4f
(
1
)
-
da
;
auto
srcover
=
s
+
d
*
isa
dstover
=
d
+
s
*
ida
otherwise
=
sa
*
Sk4f
:
:
Min
(
da
(
d
*
sa
)
*
(
sa
-
s
)
.
invert
(
)
)
+
s
*
ida
+
d
*
isa
;
auto
colors
=
(
d
=
=
Sk4f
(
0
)
)
.
thenElse
(
dstover
(
s
=
=
sa
)
.
thenElse
(
srcover
otherwise
)
)
;
return
a_rgb
(
srcover
colors
)
;
}
XFERMODE
(
ColorBurn
)
{
auto
sa
=
alphas
(
s
)
da
=
alphas
(
d
)
isa
=
Sk4f
(
1
)
-
sa
ida
=
Sk4f
(
1
)
-
da
;
auto
srcover
=
s
+
d
*
isa
dstover
=
d
+
s
*
ida
otherwise
=
sa
*
(
da
-
Sk4f
:
:
Min
(
da
(
da
-
d
)
*
sa
*
s
.
invert
(
)
)
)
+
s
*
ida
+
d
*
isa
;
auto
colors
=
(
d
=
=
da
)
.
thenElse
(
dstover
(
s
=
=
Sk4f
(
0
)
)
.
thenElse
(
srcover
otherwise
)
)
;
return
a_rgb
(
srcover
colors
)
;
}
XFERMODE
(
SoftLight
)
{
auto
sa
=
alphas
(
s
)
da
=
alphas
(
d
)
isa
=
Sk4f
(
1
)
-
sa
ida
=
Sk4f
(
1
)
-
da
;
auto
m
=
(
da
>
Sk4f
(
0
)
)
.
thenElse
(
d
/
da
Sk4f
(
0
)
)
s2
=
Sk4f
(
2
)
*
s
m4
=
Sk4f
(
4
)
*
m
;
auto
darkSrc
=
d
*
(
sa
+
(
s2
-
sa
)
*
(
Sk4f
(
1
)
-
m
)
)
darkDst
=
(
m4
*
m4
+
m4
)
*
(
m
-
Sk4f
(
1
)
)
+
Sk4f
(
7
)
*
m
liteDst
=
m
.
sqrt
(
)
-
m
liteSrc
=
d
*
sa
+
da
*
(
s2
-
sa
)
*
(
Sk4f
(
4
)
*
d
<
=
da
)
.
thenElse
(
darkDst
liteDst
)
;
auto
alpha
=
s
+
d
*
isa
;
auto
colors
=
s
*
ida
+
d
*
isa
+
(
s2
<
=
sa
)
.
thenElse
(
darkSrc
liteSrc
)
;
return
a_rgb
(
alpha
colors
)
;
}
#
undef
XFERMODE
template
<
typename
Xfermode
>
static
Sk4px
xfer_aa
(
const
Sk4px
&
d
const
Sk4px
&
s
const
Sk4px
&
aa
)
{
Sk4px
bw
=
Xfermode
(
)
(
d
s
)
;
return
(
bw
*
aa
+
d
*
aa
.
inv
(
)
)
.
div255
(
)
;
}
#
define
XFERMODE_AA
(
Xfermode
)
\
template
<
>
Sk4px
xfer_aa
<
Xfermode
>
(
const
Sk4px
&
d
const
Sk4px
&
s
const
Sk4px
&
aa
)
XFERMODE_AA
(
Plus
)
{
return
d
.
saturatedAdd
(
s
.
approxMulDiv255
(
aa
)
)
;
}
#
undef
XFERMODE_AA
template
<
typename
Xfermode
>
static
void
mark_dst_initialized_if_safe
(
void
*
void
*
)
{
}
template
<
>
void
mark_dst_initialized_if_safe
<
Src
>
(
void
*
dst
void
*
end
)
{
sk_msan_mark_initialized
(
dst
end
"
Src
doesn
'
t
read
dst
.
"
)
;
}
template
<
>
void
mark_dst_initialized_if_safe
<
Clear
>
(
void
*
dst
void
*
end
)
{
sk_msan_mark_initialized
(
dst
end
"
Clear
doesn
'
t
read
dst
.
"
)
;
}
template
<
typename
Xfermode
>
class
Sk4pxXfermode
:
public
SkXfermode
{
public
:
Sk4pxXfermode
(
)
{
}
void
xfer32
(
SkPMColor
dst
[
]
const
SkPMColor
src
[
]
int
n
const
SkAlpha
aa
[
]
)
const
override
{
mark_dst_initialized_if_safe
<
Xfermode
>
(
dst
dst
+
n
)
;
if
(
nullptr
=
=
aa
)
{
Sk4px
:
:
MapDstSrc
(
n
dst
src
Xfermode
(
)
)
;
}
else
{
Sk4px
:
:
MapDstSrcAlpha
(
n
dst
src
aa
xfer_aa
<
Xfermode
>
)
;
}
}
}
;
template
<
typename
Xfermode
>
class
Sk4fXfermode
:
public
SkXfermode
{
public
:
Sk4fXfermode
(
)
{
}
void
xfer32
(
SkPMColor
dst
[
]
const
SkPMColor
src
[
]
int
n
const
SkAlpha
aa
[
]
)
const
override
{
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
dst
[
i
]
=
Xfer32_1
(
dst
[
i
]
src
[
i
]
aa
?
aa
+
i
:
nullptr
)
;
}
}
private
:
static
SkPMColor
Xfer32_1
(
SkPMColor
dst
const
SkPMColor
src
const
SkAlpha
*
aa
)
{
Sk4f
d
=
Load
(
dst
)
s
=
Load
(
src
)
b
=
Xfermode
(
)
(
d
s
)
;
if
(
aa
)
{
Sk4f
a
=
Sk4f
(
*
aa
)
*
Sk4f
(
1
.
0f
/
255
)
;
b
=
b
*
a
+
d
*
(
Sk4f
(
1
)
-
a
)
;
}
return
Round
(
b
)
;
}
static
Sk4f
Load
(
SkPMColor
c
)
{
return
SkNx_cast
<
float
>
(
Sk4b
:
:
Load
(
&
c
)
)
*
Sk4f
(
1
.
0f
/
255
)
;
}
static
SkPMColor
Round
(
const
Sk4f
&
f
)
{
SkPMColor
c
;
SkNx_cast
<
uint8_t
>
(
f
*
Sk4f
(
255
)
+
Sk4f
(
0
.
5f
)
)
.
store
(
&
c
)
;
return
c
;
}
}
;
}
namespace
SK_OPTS_NS
{
inline
SkXfermode
*
create_xfermode
(
SkBlendMode
mode
)
{
switch
(
mode
)
{
#
define
CASE
(
Xfermode
)
\
case
SkBlendMode
:
:
k
#
#
Xfermode
:
return
new
Sk4pxXfermode
<
Xfermode
>
(
)
CASE
(
Clear
)
;
CASE
(
Src
)
;
CASE
(
Dst
)
;
CASE
(
SrcOver
)
;
CASE
(
DstOver
)
;
CASE
(
SrcIn
)
;
CASE
(
DstIn
)
;
CASE
(
SrcOut
)
;
CASE
(
DstOut
)
;
CASE
(
SrcATop
)
;
CASE
(
DstATop
)
;
CASE
(
Xor
)
;
CASE
(
Plus
)
;
CASE
(
Modulate
)
;
CASE
(
Screen
)
;
CASE
(
Multiply
)
;
CASE
(
Difference
)
;
CASE
(
Exclusion
)
;
CASE
(
HardLight
)
;
CASE
(
Overlay
)
;
CASE
(
Darken
)
;
CASE
(
Lighten
)
;
#
undef
CASE
#
define
CASE
(
Xfermode
)
\
case
SkBlendMode
:
:
k
#
#
Xfermode
:
return
new
Sk4fXfermode
<
Xfermode
>
(
)
CASE
(
ColorDodge
)
;
CASE
(
ColorBurn
)
;
CASE
(
SoftLight
)
;
#
undef
CASE
default
:
break
;
}
return
nullptr
;
}
}
#
endif
