#
ifndef
SkSwizzler_opts_DEFINED
#
define
SkSwizzler_opts_DEFINED
#
include
"
SkColorPriv
.
h
"
namespace
SK_OPTS_NS
{
static
void
premul_xxxa_portable
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
uint8_t
a
=
src
[
i
]
>
>
24
r
=
src
[
i
]
>
>
16
g
=
src
[
i
]
>
>
8
b
=
src
[
i
]
>
>
0
;
r
=
(
r
*
a
+
127
)
/
255
;
g
=
(
g
*
a
+
127
)
/
255
;
b
=
(
b
*
a
+
127
)
/
255
;
dst
[
i
]
=
(
uint32_t
)
a
<
<
24
|
(
uint32_t
)
r
<
<
16
|
(
uint32_t
)
g
<
<
8
|
(
uint32_t
)
b
<
<
0
;
}
}
static
void
premul_swaprb_xxxa_portable
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
uint8_t
a
=
src
[
i
]
>
>
24
r
=
src
[
i
]
>
>
16
g
=
src
[
i
]
>
>
8
b
=
src
[
i
]
>
>
0
;
r
=
(
r
*
a
+
127
)
/
255
;
g
=
(
g
*
a
+
127
)
/
255
;
b
=
(
b
*
a
+
127
)
/
255
;
dst
[
i
]
=
(
uint32_t
)
a
<
<
24
|
(
uint32_t
)
b
<
<
16
|
(
uint32_t
)
g
<
<
8
|
(
uint32_t
)
r
<
<
0
;
}
}
#
if
defined
(
SK_ARM_HAS_NEON
)
static
uint8x8_t
div255_round
(
uint16x8_t
x
)
{
return
vraddhn_u16
(
x
vrshrq_n_u16
(
x
8
)
)
;
}
static
uint8x8_t
scale
(
uint8x8_t
x
uint8x8_t
y
)
{
return
div255_round
(
vmull_u8
(
x
y
)
)
;
}
template
<
bool
kSwapRB
>
static
void
premul_xxxa_should_swaprb
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
while
(
count
>
=
8
)
{
uint8x8x4_t
bgra
=
vld4_u8
(
(
const
uint8_t
*
)
src
)
;
uint8x8_t
a
=
bgra
.
val
[
3
]
r
=
bgra
.
val
[
2
]
g
=
bgra
.
val
[
1
]
b
=
bgra
.
val
[
0
]
;
r
=
scale
(
r
a
)
;
g
=
scale
(
g
a
)
;
b
=
scale
(
b
a
)
;
if
(
kSwapRB
)
{
bgra
.
val
[
2
]
=
b
;
bgra
.
val
[
1
]
=
g
;
bgra
.
val
[
0
]
=
r
;
}
else
{
bgra
.
val
[
2
]
=
r
;
bgra
.
val
[
1
]
=
g
;
bgra
.
val
[
0
]
=
b
;
}
vst4_u8
(
(
uint8_t
*
)
dst
bgra
)
;
src
+
=
8
;
dst
+
=
8
;
count
-
=
8
;
}
auto
proc
=
kSwapRB
?
premul_swaprb_xxxa_portable
:
premul_xxxa_portable
;
proc
(
dst
src
count
)
;
}
static
void
premul_xxxa
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
premul_xxxa_should_swaprb
<
false
>
(
dst
src
count
)
;
}
static
void
premul_swaprb_xxxa
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
premul_xxxa_should_swaprb
<
true
>
(
dst
src
count
)
;
}
#
else
static
void
premul_xxxa
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
premul_xxxa_portable
(
dst
src
count
)
;
}
static
void
premul_swaprb_xxxa
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
premul_swaprb_xxxa_portable
(
dst
src
count
)
;
}
#
endif
static
void
swaprb_xxxa
(
uint32_t
dst
[
]
const
uint32_t
src
[
]
int
count
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
uint8_t
a
=
src
[
i
]
>
>
24
r
=
src
[
i
]
>
>
16
g
=
src
[
i
]
>
>
8
b
=
src
[
i
]
>
>
0
;
dst
[
i
]
=
(
uint32_t
)
a
<
<
24
|
(
uint32_t
)
b
<
<
16
|
(
uint32_t
)
g
<
<
8
|
(
uint32_t
)
r
<
<
0
;
}
}
}
#
endif
