#
include
"
SkOpts
.
h
"
#
define
SK_OPTS_NS
sk_sse41
#
include
"
SkBlurImageFilter_opts
.
h
"
#
ifndef
SK_SUPPORT_LEGACY_X86_BLITS
struct
m128ix2
{
__m128i
lo
hi
;
}
;
static
inline
__m128i
unpacklo
(
__m128i
x
)
{
return
_mm_cvtepu8_epi16
(
x
)
;
}
static
inline
__m128i
unpackhi
(
__m128i
x
)
{
return
_mm_unpackhi_epi8
(
x
_mm_setzero_si128
(
)
)
;
}
static
inline
__m128i
pack
(
__m128i
lo
__m128i
hi
)
{
return
_mm_packus_epi16
(
lo
hi
)
;
}
static
inline
__m128i
next1
(
uint8_t
val
)
{
return
_mm_set1_epi16
(
val
)
;
}
static
inline
__m128i
next2
(
uint8_t
val
)
{
return
_mm_set1_epi16
(
val
)
;
}
static
inline
m128ix2
next4
(
uint8_t
val
)
{
return
{
next2
(
val
)
next2
(
val
)
}
;
}
static
inline
__m128i
next1
(
uint32_t
val
)
{
return
unpacklo
(
_mm_cvtsi32_si128
(
val
)
)
;
}
static
inline
__m128i
next2
(
uint32_t
val
)
{
return
unpacklo
(
_mm_set1_epi32
(
val
)
)
;
}
static
inline
m128ix2
next4
(
uint32_t
val
)
{
return
{
next2
(
val
)
next2
(
val
)
}
;
}
static
inline
__m128i
next1
(
const
uint8_t
*
&
ptr
)
{
return
_mm_set1_epi16
(
*
ptr
+
+
)
;
}
static
inline
__m128i
next2
(
const
uint8_t
*
&
ptr
)
{
auto
r
=
_mm_cvtsi32_si128
(
*
(
const
uint16_t
*
)
ptr
)
;
ptr
+
=
2
;
const
int
_
=
~
0
;
return
_mm_shuffle_epi8
(
r
_mm_setr_epi8
(
0
_
0
_
0
_
0
_
1
_
1
_
1
_
1
_
)
)
;
}
static
inline
m128ix2
next4
(
const
uint8_t
*
&
ptr
)
{
auto
r
=
_mm_cvtsi32_si128
(
*
(
const
uint32_t
*
)
ptr
)
;
ptr
+
=
4
;
const
int
_
=
~
0
;
auto
lo
=
_mm_shuffle_epi8
(
r
_mm_setr_epi8
(
0
_
0
_
0
_
0
_
1
_
1
_
1
_
1
_
)
)
hi
=
_mm_shuffle_epi8
(
r
_mm_setr_epi8
(
2
_
2
_
2
_
2
_
3
_
3
_
3
_
3
_
)
)
;
return
{
lo
hi
}
;
}
static
inline
__m128i
next1
(
const
uint32_t
*
&
ptr
)
{
return
unpacklo
(
_mm_cvtsi32_si128
(
*
ptr
+
+
)
)
;
}
static
inline
__m128i
next2
(
const
uint32_t
*
&
ptr
)
{
auto
r
=
unpacklo
(
_mm_loadl_epi64
(
(
const
__m128i
*
)
ptr
)
)
;
ptr
+
=
2
;
return
r
;
}
static
inline
m128ix2
next4
(
const
uint32_t
*
&
ptr
)
{
auto
packed
=
_mm_loadu_si128
(
(
const
__m128i
*
)
ptr
)
;
ptr
+
=
4
;
return
{
unpacklo
(
packed
)
unpackhi
(
packed
)
}
;
}
static
inline
__m128i
div255_part1
(
__m128i
x
)
{
return
_mm_add_epi16
(
x
_mm_set1_epi16
(
128
)
)
;
}
static
inline
__m128i
div255_part2
(
__m128i
x
)
{
return
_mm_mulhi_epu16
(
x
_mm_set1_epi16
(
257
)
)
;
}
static
inline
__m128i
div255
(
__m128i
x
)
{
return
div255_part2
(
div255_part1
(
x
)
)
;
}
static
inline
__m128i
scale
(
__m128i
x
__m128i
y
)
{
return
div255
(
_mm_mullo_epi16
(
x
y
)
)
;
}
static
inline
__m128i
inv
(
__m128i
x
)
{
return
_mm_xor_si128
(
_mm_set1_epi16
(
0x00ff
)
x
)
;
}
static
inline
__m128i
alphas
(
__m128i
px
)
{
const
int
a
=
2
*
(
SK_A32_SHIFT
/
8
)
;
const
int
_
=
~
0
;
return
_mm_shuffle_epi8
(
px
_mm_setr_epi8
(
a
+
0
_
a
+
0
_
a
+
0
_
a
+
0
_
a
+
8
_
a
+
8
_
a
+
8
_
a
+
8
_
)
)
;
}
template
<
typename
Dst
typename
Src
typename
Cov
typename
Fn
>
static
inline
void
loop
(
int
n
uint32_t
*
t
const
Dst
dst
const
Src
src
const
Cov
cov
Fn
&
&
fn
)
{
Dst
d
=
dst
;
Src
s
=
src
;
Cov
c
=
cov
;
while
(
n
)
{
if
(
n
>
=
4
)
{
auto
d4
=
next4
(
d
)
s4
=
next4
(
s
)
c4
=
next4
(
c
)
;
auto
lo
=
fn
(
d4
.
lo
s4
.
lo
c4
.
lo
)
hi
=
fn
(
d4
.
hi
s4
.
hi
c4
.
hi
)
;
_mm_storeu_si128
(
(
__m128i
*
)
t
pack
(
lo
hi
)
)
;
t
+
=
4
;
n
-
=
4
;
continue
;
}
if
(
n
&
2
)
{
auto
r
=
fn
(
next2
(
d
)
next2
(
s
)
next2
(
c
)
)
;
_mm_storel_epi64
(
(
__m128i
*
)
t
pack
(
r
r
)
)
;
t
+
=
2
;
}
if
(
n
&
1
)
{
auto
r
=
fn
(
next1
(
d
)
next1
(
s
)
next1
(
c
)
)
;
*
t
=
_mm_cvtsi128_si32
(
pack
(
r
r
)
)
;
}
return
;
}
}
namespace
sk_sse41
{
static
void
blit_row_color32
(
SkPMColor
*
tgt
const
SkPMColor
*
dst
int
n
SkPMColor
src
)
{
__m128i
s
=
next2
(
src
)
s_255_128
=
div255_part1
(
_mm_mullo_epi16
(
s
_mm_set1_epi16
(
255
)
)
)
A
=
inv
(
alphas
(
s
)
)
;
const
uint8_t
cov
=
0xff
;
loop
(
n
tgt
dst
src
cov
[
=
]
(
__m128i
d
__m128i
__m128i
)
{
return
div255_part2
(
_mm_add_epi16
(
s_255_128
_mm_mullo_epi16
(
d
A
)
)
)
;
}
)
;
}
static
void
blit_mask_d32_a8
(
SkPMColor
*
dst
size_t
dstRB
const
SkAlpha
*
cov
size_t
covRB
SkColor
color
int
w
int
h
)
{
if
(
SkColorGetA
(
color
)
=
=
0xFF
)
{
const
SkPMColor
src
=
SkSwizzle_BGRA_to_PMColor
(
color
)
;
while
(
h
-
-
>
0
)
{
loop
(
w
dst
(
const
SkPMColor
*
)
dst
src
cov
[
]
(
__m128i
d
__m128i
s
__m128i
c
)
{
return
div255
(
_mm_add_epi16
(
_mm_mullo_epi16
(
inv
(
c
)
d
)
_mm_mullo_epi16
(
c
s
)
)
)
;
}
)
;
dst
+
=
dstRB
/
sizeof
(
*
dst
)
;
cov
+
=
covRB
/
sizeof
(
*
cov
)
;
}
}
else
{
const
SkPMColor
src
=
SkPreMultiplyColor
(
color
)
;
while
(
h
-
-
>
0
)
{
loop
(
w
dst
(
const
SkPMColor
*
)
dst
src
cov
[
]
(
__m128i
d
__m128i
s
__m128i
c
)
{
__m128i
sc
=
scale
(
s
c
)
AC
=
inv
(
alphas
(
sc
)
)
;
return
_mm_add_epi16
(
sc
scale
(
d
AC
)
)
;
}
)
;
dst
+
=
dstRB
/
sizeof
(
*
dst
)
;
cov
+
=
covRB
/
sizeof
(
*
cov
)
;
}
}
}
}
#
endif
namespace
SkOpts
{
void
Init_sse41
(
)
{
box_blur_xx
=
sk_sse41
:
:
box_blur_xx
;
box_blur_xy
=
sk_sse41
:
:
box_blur_xy
;
box_blur_yx
=
sk_sse41
:
:
box_blur_yx
;
#
ifndef
SK_SUPPORT_LEGACY_X86_BLITS
blit_row_color32
=
sk_sse41
:
:
blit_row_color32
;
blit_mask_d32_a8
=
sk_sse41
:
:
blit_mask_d32_a8
;
#
endif
}
}
