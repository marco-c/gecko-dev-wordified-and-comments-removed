#
include
"
SkOpts
.
h
"
#
define
SK_OPTS_NS
sk_sse41
#
include
"
SkBlurImageFilter_opts
.
h
"
#
include
"
SkBlitRow_opts
.
h
"
#
ifndef
SK_SUPPORT_LEGACY_X86_BLITS
namespace
sk_sse41_new
{
struct
m64i
{
__m128i
v
;
m64i
(
__m128i
v
)
:
v
(
v
)
{
}
operator
__m128i
(
)
const
{
return
v
;
}
}
;
static
__m128i
next4
(
uint32_t
val
)
{
return
_mm_set1_epi32
(
val
)
;
}
static
m64i
next2
(
uint32_t
val
)
{
return
_mm_set1_epi32
(
val
)
;
}
static
m64i
next1
(
uint32_t
val
)
{
return
_mm_set1_epi32
(
val
)
;
}
static
__m128i
next4
(
uint8_t
val
)
{
return
_mm_set1_epi8
(
val
)
;
}
static
m64i
next2
(
uint8_t
val
)
{
return
_mm_set1_epi8
(
val
)
;
}
static
m64i
next1
(
uint8_t
val
)
{
return
_mm_set1_epi8
(
val
)
;
}
static
__m128i
next4
(
const
uint32_t
*
&
ptr
)
{
auto
r
=
_mm_loadu_si128
(
(
const
__m128i
*
)
ptr
)
;
ptr
+
=
4
;
return
r
;
}
static
m64i
next2
(
const
uint32_t
*
&
ptr
)
{
auto
r
=
_mm_loadl_epi64
(
(
const
__m128i
*
)
ptr
)
;
ptr
+
=
2
;
return
r
;
}
static
m64i
next1
(
const
uint32_t
*
&
ptr
)
{
auto
r
=
_mm_cvtsi32_si128
(
*
ptr
)
;
ptr
+
=
1
;
return
r
;
}
static
__m128i
replicate_coverage
(
__m128i
xyzw
)
{
return
_mm_shuffle_epi8
(
xyzw
_mm_setr_epi8
(
0
0
0
0
1
1
1
1
2
2
2
2
3
3
3
3
)
)
;
}
static
__m128i
next4
(
const
uint8_t
*
&
ptr
)
{
auto
r
=
replicate_coverage
(
_mm_cvtsi32_si128
(
*
(
const
uint32_t
*
)
ptr
)
)
;
ptr
+
=
4
;
return
r
;
}
static
m64i
next2
(
const
uint8_t
*
&
ptr
)
{
auto
r
=
replicate_coverage
(
_mm_cvtsi32_si128
(
*
(
const
uint16_t
*
)
ptr
)
)
;
ptr
+
=
2
;
return
r
;
}
static
m64i
next1
(
const
uint8_t
*
&
ptr
)
{
auto
r
=
replicate_coverage
(
_mm_cvtsi32_si128
(
*
ptr
)
)
;
ptr
+
=
1
;
return
r
;
}
template
<
typename
Dst
typename
Src
typename
Cov
typename
Fn
>
static
void
loop
(
int
n
uint32_t
*
t
const
Dst
dst
const
Src
src
const
Cov
cov
Fn
&
&
fn
)
{
Dst
d
=
dst
;
Src
s
=
src
;
Cov
c
=
cov
;
while
(
n
)
{
if
(
n
>
=
4
)
{
_mm_storeu_si128
(
(
__m128i
*
)
t
fn
(
next4
(
d
)
next4
(
s
)
next4
(
c
)
)
)
;
t
+
=
4
;
n
-
=
4
;
continue
;
}
if
(
n
&
2
)
{
_mm_storel_epi64
(
(
__m128i
*
)
t
fn
(
next2
(
d
)
next2
(
s
)
next2
(
c
)
)
)
;
t
+
=
2
;
}
if
(
n
&
1
)
{
*
t
=
_mm_cvtsi128_si32
(
fn
(
next1
(
d
)
next1
(
s
)
next1
(
c
)
)
)
;
}
return
;
}
}
template
<
typename
Fn
>
struct
Adapt
{
Fn
fn
;
__m128i
operator
(
)
(
__m128i
d
__m128i
s
__m128i
c
)
{
auto
lo
=
[
]
(
__m128i
x
)
{
return
_mm_unpacklo_epi8
(
x
_mm_setzero_si128
(
)
)
;
}
;
auto
hi
=
[
]
(
__m128i
x
)
{
return
_mm_unpackhi_epi8
(
x
_mm_setzero_si128
(
)
)
;
}
;
return
_mm_packus_epi16
(
fn
(
lo
(
d
)
lo
(
s
)
lo
(
c
)
)
fn
(
hi
(
d
)
hi
(
s
)
hi
(
c
)
)
)
;
}
m64i
operator
(
)
(
const
m64i
&
d
const
m64i
&
s
const
m64i
&
c
)
{
auto
lo
=
[
]
(
__m128i
x
)
{
return
_mm_unpacklo_epi8
(
x
_mm_setzero_si128
(
)
)
;
}
;
auto
r
=
fn
(
lo
(
d
)
lo
(
s
)
lo
(
c
)
)
;
return
_mm_packus_epi16
(
r
r
)
;
}
}
;
template
<
typename
Fn
>
static
Adapt
<
Fn
>
adapt
(
Fn
&
&
fn
)
{
return
{
fn
}
;
}
static
__m128i
div255_part1
(
__m128i
x
)
{
return
_mm_add_epi16
(
x
_mm_set1_epi16
(
128
)
)
;
}
static
__m128i
div255_part2
(
__m128i
x
)
{
return
_mm_mulhi_epu16
(
x
_mm_set1_epi16
(
257
)
)
;
}
static
__m128i
div255
(
__m128i
x
)
{
return
div255_part2
(
div255_part1
(
x
)
)
;
}
static
__m128i
scale
(
__m128i
x
__m128i
y
)
{
return
div255
(
_mm_mullo_epi16
(
x
y
)
)
;
}
static
__m128i
mul255
(
__m128i
x
)
{
return
_mm_sub_epi16
(
_mm_slli_epi16
(
x
8
)
x
)
;
}
static
__m128i
inv
(
__m128i
x
)
{
return
_mm_xor_si128
(
_mm_set1_epi16
(
0x00ff
)
x
)
;
}
static
__m128i
alphas
(
__m128i
px
)
{
const
int
a
=
2
*
(
SK_A32_SHIFT
/
8
)
;
const
int
_
=
~
0
;
return
_mm_shuffle_epi8
(
px
_mm_setr_epi8
(
a
+
0
_
a
+
0
_
a
+
0
_
a
+
0
_
a
+
8
_
a
+
8
_
a
+
8
_
a
+
8
_
)
)
;
}
static
void
blit_row_color32
(
SkPMColor
*
tgt
const
SkPMColor
*
dst
int
n
SkPMColor
src
)
{
__m128i
s
=
_mm_unpacklo_epi8
(
_mm_set1_epi32
(
src
)
_mm_setzero_si128
(
)
)
s_255_128
=
div255_part1
(
mul255
(
s
)
)
A
=
inv
(
alphas
(
s
)
)
;
const
uint8_t
cov
=
0xff
;
loop
(
n
tgt
dst
src
cov
adapt
(
[
=
]
(
__m128i
d
__m128i
__m128i
)
{
return
div255_part2
(
_mm_add_epi16
(
s_255_128
_mm_mullo_epi16
(
d
A
)
)
)
;
}
)
)
;
}
static
void
blit_mask_d32_a8
(
SkPMColor
*
dst
size_t
dstRB
const
SkAlpha
*
cov
size_t
covRB
SkColor
color
int
w
int
h
)
{
if
(
SkColorGetA
(
color
)
=
=
0xFF
)
{
const
SkPMColor
src
=
SkSwizzle_BGRA_to_PMColor
(
color
)
;
while
(
h
-
-
>
0
)
{
loop
(
w
dst
(
const
SkPMColor
*
)
dst
src
cov
adapt
(
[
]
(
__m128i
d
__m128i
s
__m128i
c
)
{
return
div255
(
_mm_add_epi16
(
_mm_mullo_epi16
(
inv
(
c
)
d
)
_mm_mullo_epi16
(
c
s
)
)
)
;
}
)
)
;
dst
+
=
dstRB
/
sizeof
(
*
dst
)
;
cov
+
=
covRB
/
sizeof
(
*
cov
)
;
}
}
else
{
const
SkPMColor
src
=
SkPreMultiplyColor
(
color
)
;
while
(
h
-
-
>
0
)
{
loop
(
w
dst
(
const
SkPMColor
*
)
dst
src
cov
adapt
(
[
]
(
__m128i
d
__m128i
s
__m128i
c
)
{
__m128i
sc
=
scale
(
s
c
)
AC
=
inv
(
alphas
(
sc
)
)
;
return
_mm_add_epi16
(
sc
scale
(
d
AC
)
)
;
}
)
)
;
dst
+
=
dstRB
/
sizeof
(
*
dst
)
;
cov
+
=
covRB
/
sizeof
(
*
cov
)
;
}
}
}
}
#
endif
namespace
SkOpts
{
void
Init_sse41
(
)
{
box_blur_xx
=
sk_sse41
:
:
box_blur_xx
;
box_blur_xy
=
sk_sse41
:
:
box_blur_xy
;
box_blur_yx
=
sk_sse41
:
:
box_blur_yx
;
#
ifndef
SK_SUPPORT_LEGACY_X86_BLITS
blit_row_color32
=
sk_sse41_new
:
:
blit_row_color32
;
blit_mask_d32_a8
=
sk_sse41_new
:
:
blit_mask_d32_a8
;
#
endif
blit_row_s32a_opaque
=
sk_sse41
:
:
blit_row_s32a_opaque
;
}
}
