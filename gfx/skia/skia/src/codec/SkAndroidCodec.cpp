#
include
"
SkAndroidCodec
.
h
"
#
include
"
SkCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkRawAdapterCodec
.
h
"
#
include
"
SkSampledCodec
.
h
"
#
include
"
SkWebpAdapterCodec
.
h
"
static
bool
is_valid_sample_size
(
int
sampleSize
)
{
return
sampleSize
>
0
;
}
static
void
load_gamut
(
SkPoint
rgb
[
]
const
SkMatrix44
&
xyz
)
{
float
rSum
=
xyz
.
get
(
0
0
)
+
xyz
.
get
(
1
0
)
+
xyz
.
get
(
2
0
)
;
float
gSum
=
xyz
.
get
(
0
1
)
+
xyz
.
get
(
1
1
)
+
xyz
.
get
(
2
1
)
;
float
bSum
=
xyz
.
get
(
0
2
)
+
xyz
.
get
(
1
2
)
+
xyz
.
get
(
2
2
)
;
rgb
[
0
]
.
fX
=
xyz
.
get
(
0
0
)
/
rSum
;
rgb
[
0
]
.
fY
=
xyz
.
get
(
1
0
)
/
rSum
;
rgb
[
1
]
.
fX
=
xyz
.
get
(
0
1
)
/
gSum
;
rgb
[
1
]
.
fY
=
xyz
.
get
(
1
1
)
/
gSum
;
rgb
[
2
]
.
fX
=
xyz
.
get
(
0
2
)
/
bSum
;
rgb
[
2
]
.
fY
=
xyz
.
get
(
1
2
)
/
bSum
;
}
static
float
calculate_area
(
SkPoint
abc
[
]
)
{
SkPoint
a
=
abc
[
0
]
;
SkPoint
b
=
abc
[
1
]
;
SkPoint
c
=
abc
[
2
]
;
return
0
.
5f
*
SkTAbs
(
a
.
fX
*
b
.
fY
+
b
.
fX
*
c
.
fY
-
a
.
fX
*
c
.
fY
-
c
.
fX
*
b
.
fY
-
b
.
fX
*
a
.
fY
)
;
}
static
const
float
kSRGB_D50_GamutArea
=
0
.
084f
;
static
bool
is_wide_gamut
(
const
SkColorSpace
*
colorSpace
)
{
const
SkMatrix44
*
toXYZD50
=
as_CSB
(
colorSpace
)
-
>
toXYZD50
(
)
;
if
(
toXYZD50
)
{
SkPoint
rgb
[
3
]
;
load_gamut
(
rgb
*
toXYZD50
)
;
return
calculate_area
(
rgb
)
>
kSRGB_D50_GamutArea
;
}
return
false
;
}
SkAndroidCodec
:
:
SkAndroidCodec
(
SkCodec
*
codec
)
:
fInfo
(
codec
-
>
getInfo
(
)
)
fCodec
(
codec
)
{
}
SkAndroidCodec
*
SkAndroidCodec
:
:
NewFromStream
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
)
{
std
:
:
unique_ptr
<
SkCodec
>
codec
(
SkCodec
:
:
NewFromStream
(
stream
chunkReader
)
)
;
if
(
nullptr
=
=
codec
)
{
return
nullptr
;
}
switch
(
(
SkEncodedImageFormat
)
codec
-
>
getEncodedFormat
(
)
)
{
#
ifdef
SK_HAS_PNG_LIBRARY
case
SkEncodedImageFormat
:
:
kPNG
:
case
SkEncodedImageFormat
:
:
kICO
:
#
endif
#
ifdef
SK_HAS_JPEG_LIBRARY
case
SkEncodedImageFormat
:
:
kJPEG
:
#
endif
case
SkEncodedImageFormat
:
:
kGIF
:
case
SkEncodedImageFormat
:
:
kBMP
:
case
SkEncodedImageFormat
:
:
kWBMP
:
return
new
SkSampledCodec
(
codec
.
release
(
)
)
;
#
ifdef
SK_HAS_WEBP_LIBRARY
case
SkEncodedImageFormat
:
:
kWEBP
:
return
new
SkWebpAdapterCodec
(
(
SkWebpCodec
*
)
codec
.
release
(
)
)
;
#
endif
#
ifdef
SK_CODEC_DECODES_RAW
case
SkEncodedImageFormat
:
:
kDNG
:
return
new
SkRawAdapterCodec
(
(
SkRawCodec
*
)
codec
.
release
(
)
)
;
#
endif
default
:
return
nullptr
;
}
}
SkAndroidCodec
*
SkAndroidCodec
:
:
NewFromData
(
sk_sp
<
SkData
>
data
SkPngChunkReader
*
chunkReader
)
{
if
(
!
data
)
{
return
nullptr
;
}
return
NewFromStream
(
new
SkMemoryStream
(
data
)
chunkReader
)
;
}
SkColorType
SkAndroidCodec
:
:
computeOutputColorType
(
SkColorType
requestedColorType
)
{
const
SkColorType
suggestedColorType
=
this
-
>
getInfo
(
)
.
colorType
(
)
;
switch
(
(
SkEncodedImageFormat
)
this
-
>
getEncodedFormat
(
)
)
{
case
SkEncodedImageFormat
:
:
kGIF
:
if
(
suggestedColorType
=
=
kIndex_8_SkColorType
)
{
return
kIndex_8_SkColorType
;
}
break
;
case
SkEncodedImageFormat
:
:
kWBMP
:
return
kIndex_8_SkColorType
;
default
:
break
;
}
bool
highPrecision
=
fCodec
-
>
getEncodedInfo
(
)
.
bitsPerComponent
(
)
>
8
;
switch
(
requestedColorType
)
{
case
kARGB_4444_SkColorType
:
return
kN32_SkColorType
;
case
kN32_SkColorType
:
return
highPrecision
?
kRGBA_F16_SkColorType
:
kN32_SkColorType
;
case
kIndex_8_SkColorType
:
if
(
kIndex_8_SkColorType
=
=
suggestedColorType
)
{
return
kIndex_8_SkColorType
;
}
break
;
case
kAlpha_8_SkColorType
:
case
kGray_8_SkColorType
:
if
(
kGray_8_SkColorType
=
=
suggestedColorType
)
{
return
kGray_8_SkColorType
;
}
break
;
case
kRGB_565_SkColorType
:
if
(
kOpaque_SkAlphaType
=
=
this
-
>
getInfo
(
)
.
alphaType
(
)
)
{
return
kRGB_565_SkColorType
;
}
break
;
case
kRGBA_F16_SkColorType
:
return
kRGBA_F16_SkColorType
;
default
:
break
;
}
if
(
kGray_8_SkColorType
=
=
suggestedColorType
)
{
return
kN32_SkColorType
;
}
return
highPrecision
?
kRGBA_F16_SkColorType
:
suggestedColorType
;
}
SkAlphaType
SkAndroidCodec
:
:
computeOutputAlphaType
(
bool
requestedUnpremul
)
{
if
(
kOpaque_SkAlphaType
=
=
this
-
>
getInfo
(
)
.
alphaType
(
)
)
{
return
kOpaque_SkAlphaType
;
}
return
requestedUnpremul
?
kUnpremul_SkAlphaType
:
kPremul_SkAlphaType
;
}
sk_sp
<
SkColorSpace
>
SkAndroidCodec
:
:
computeOutputColorSpace
(
SkColorType
outputColorType
sk_sp
<
SkColorSpace
>
prefColorSpace
)
{
switch
(
outputColorType
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
case
kIndex_8_SkColorType
:
{
SkColorSpaceTransferFn
fn
;
if
(
prefColorSpace
&
&
prefColorSpace
-
>
isNumericalTransferFn
(
&
fn
)
)
{
return
prefColorSpace
;
}
SkColorSpace
*
encodedSpace
=
fCodec
-
>
getInfo
(
)
.
colorSpace
(
)
;
if
(
encodedSpace
-
>
isNumericalTransferFn
(
&
fn
)
)
{
return
sk_ref_sp
(
encodedSpace
)
;
}
if
(
is_wide_gamut
(
encodedSpace
)
)
{
return
SkColorSpace
:
:
MakeRGB
(
SkColorSpace
:
:
kSRGB_RenderTargetGamma
SkColorSpace
:
:
kDCIP3_D65_Gamut
)
;
}
return
SkColorSpace
:
:
MakeSRGB
(
)
;
}
case
kRGBA_F16_SkColorType
:
return
SkColorSpace
:
:
MakeSRGBLinear
(
)
;
case
kRGB_565_SkColorType
:
return
SkColorSpace
:
:
MakeSRGB
(
)
;
default
:
return
nullptr
;
}
}
SkISize
SkAndroidCodec
:
:
getSampledDimensions
(
int
sampleSize
)
const
{
if
(
!
is_valid_sample_size
(
sampleSize
)
)
{
return
{
0
0
}
;
}
if
(
1
=
=
sampleSize
)
{
return
fInfo
.
dimensions
(
)
;
}
return
this
-
>
onGetSampledDimensions
(
sampleSize
)
;
}
bool
SkAndroidCodec
:
:
getSupportedSubset
(
SkIRect
*
desiredSubset
)
const
{
if
(
!
desiredSubset
|
|
!
is_valid_subset
(
*
desiredSubset
fInfo
.
dimensions
(
)
)
)
{
return
false
;
}
return
this
-
>
onGetSupportedSubset
(
desiredSubset
)
;
}
SkISize
SkAndroidCodec
:
:
getSampledSubsetDimensions
(
int
sampleSize
const
SkIRect
&
subset
)
const
{
if
(
!
is_valid_sample_size
(
sampleSize
)
)
{
return
{
0
0
}
;
}
SkIRect
copySubset
=
subset
;
if
(
!
this
-
>
getSupportedSubset
(
&
copySubset
)
|
|
copySubset
!
=
subset
)
{
return
{
0
0
}
;
}
if
(
fInfo
.
dimensions
(
)
=
=
subset
.
size
(
)
)
{
return
this
-
>
getSampledDimensions
(
sampleSize
)
;
}
return
{
get_scaled_dimension
(
subset
.
width
(
)
sampleSize
)
get_scaled_dimension
(
subset
.
height
(
)
sampleSize
)
}
;
}
SkCodec
:
:
Result
SkAndroidCodec
:
:
getAndroidPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
AndroidOptions
*
options
)
{
if
(
!
pixels
)
{
return
SkCodec
:
:
kInvalidParameters
;
}
if
(
rowBytes
<
info
.
minRowBytes
(
)
)
{
return
SkCodec
:
:
kInvalidParameters
;
}
AndroidOptions
defaultOptions
;
if
(
!
options
)
{
options
=
&
defaultOptions
;
}
else
if
(
options
-
>
fSubset
)
{
if
(
!
is_valid_subset
(
*
options
-
>
fSubset
fInfo
.
dimensions
(
)
)
)
{
return
SkCodec
:
:
kInvalidParameters
;
}
if
(
SkIRect
:
:
MakeSize
(
fInfo
.
dimensions
(
)
)
=
=
*
options
-
>
fSubset
)
{
defaultOptions
=
*
options
;
defaultOptions
.
fSubset
=
nullptr
;
options
=
&
defaultOptions
;
}
}
return
this
-
>
onGetAndroidPixels
(
info
pixels
rowBytes
*
options
)
;
}
SkCodec
:
:
Result
SkAndroidCodec
:
:
getAndroidPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
)
{
return
this
-
>
getAndroidPixels
(
info
pixels
rowBytes
nullptr
)
;
}
