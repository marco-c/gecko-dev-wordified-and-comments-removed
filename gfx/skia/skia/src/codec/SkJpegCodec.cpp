#
include
"
src
/
codec
/
SkJpegCodec
.
h
"
#
include
"
include
/
codec
/
SkCodec
.
h
"
#
include
"
include
/
codec
/
SkJpegDecoder
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
core
/
SkYUVAInfo
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
modules
/
skcms
/
skcms
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
codec
/
SkJpegDecoderMgr
.
h
"
#
include
"
src
/
codec
/
SkJpegMetadataDecoderImpl
.
h
"
#
include
"
src
/
codec
/
SkJpegPriv
.
h
"
#
include
"
src
/
codec
/
SkParseEncodedOrigin
.
h
"
#
include
"
src
/
codec
/
SkSwizzler
.
h
"
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
#
include
"
include
/
private
/
SkGainmapInfo
.
h
"
#
endif
#
include
<
array
>
#
include
<
csetjmp
>
#
include
<
cstring
>
#
include
<
utility
>
using
namespace
skia_private
;
class
SkSampler
;
struct
SkGainmapInfo
;
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
pragma
GCC
diagnostic
ignored
"
-
Wclobbered
"
#
endif
extern
"
C
"
{
#
include
"
jpeglib
.
h
"
}
bool
SkJpegCodec
:
:
IsJpeg
(
const
void
*
buffer
size_t
bytesRead
)
{
return
bytesRead
>
=
sizeof
(
kJpegSig
)
&
&
!
memcmp
(
buffer
kJpegSig
sizeof
(
kJpegSig
)
)
;
}
SkJpegMarkerList
get_sk_marker_list
(
jpeg_decompress_struct
*
dinfo
)
{
SkJpegMarkerList
markerList
;
for
(
auto
*
marker
=
dinfo
-
>
marker_list
;
marker
;
marker
=
marker
-
>
next
)
{
markerList
.
emplace_back
(
marker
-
>
marker
SkData
:
:
MakeWithoutCopy
(
marker
-
>
data
marker
-
>
data_length
)
)
;
}
return
markerList
;
}
static
SkEncodedOrigin
get_exif_orientation
(
sk_sp
<
SkData
>
exifData
)
{
SkEncodedOrigin
origin
=
kDefault_SkEncodedOrigin
;
if
(
exifData
&
&
SkParseEncodedOrigin
(
exifData
-
>
bytes
(
)
exifData
-
>
size
(
)
&
origin
)
)
{
return
origin
;
}
return
kDefault_SkEncodedOrigin
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
ReadHeader
(
SkStream
*
stream
SkCodec
*
*
codecOut
JpegDecoderMgr
*
*
decoderMgrOut
std
:
:
unique_ptr
<
SkEncodedInfo
:
:
ICCProfile
>
defaultColorProfile
)
{
std
:
:
unique_ptr
<
JpegDecoderMgr
>
decoderMgr
(
new
JpegDecoderMgr
(
stream
)
)
;
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
decoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
decoderMgr
-
>
returnFailure
(
"
ReadHeader
"
kInvalidInput
)
;
}
decoderMgr
-
>
init
(
)
;
auto
*
dinfo
=
decoderMgr
-
>
dinfo
(
)
;
if
(
codecOut
)
{
jpeg_save_markers
(
dinfo
kExifMarker
0xFFFF
)
;
jpeg_save_markers
(
dinfo
kICCMarker
0xFFFF
)
;
jpeg_save_markers
(
dinfo
kMpfMarker
0xFFFF
)
;
}
switch
(
jpeg_read_header
(
dinfo
TRUE
)
)
{
case
JPEG_HEADER_OK
:
break
;
case
JPEG_SUSPENDED
:
return
decoderMgr
-
>
returnFailure
(
"
ReadHeader
"
kIncompleteInput
)
;
default
:
return
decoderMgr
-
>
returnFailure
(
"
ReadHeader
"
kInvalidInput
)
;
}
if
(
codecOut
)
{
SkEncodedInfo
:
:
Color
color
;
if
(
!
decoderMgr
-
>
getEncodedColor
(
&
color
)
)
{
return
kInvalidInput
;
}
auto
metadataDecoder
=
std
:
:
make_unique
<
SkJpegMetadataDecoderImpl
>
(
get_sk_marker_list
(
dinfo
)
)
;
SkEncodedOrigin
orientation
=
get_exif_orientation
(
metadataDecoder
-
>
getExifMetadata
(
false
)
)
;
std
:
:
unique_ptr
<
SkEncodedInfo
:
:
ICCProfile
>
profile
;
if
(
auto
iccProfileData
=
metadataDecoder
-
>
getICCProfileData
(
true
)
)
{
profile
=
SkEncodedInfo
:
:
ICCProfile
:
:
Make
(
std
:
:
move
(
iccProfileData
)
)
;
}
if
(
profile
)
{
auto
type
=
profile
-
>
profile
(
)
-
>
data_color_space
;
switch
(
decoderMgr
-
>
dinfo
(
)
-
>
jpeg_color_space
)
{
case
JCS_CMYK
:
case
JCS_YCCK
:
if
(
type
!
=
skcms_Signature_CMYK
)
{
profile
=
nullptr
;
}
break
;
case
JCS_GRAYSCALE
:
if
(
type
!
=
skcms_Signature_Gray
&
&
type
!
=
skcms_Signature_RGB
)
{
profile
=
nullptr
;
}
break
;
default
:
if
(
type
!
=
skcms_Signature_RGB
)
{
profile
=
nullptr
;
}
break
;
}
}
if
(
!
profile
)
{
profile
=
std
:
:
move
(
defaultColorProfile
)
;
}
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
dinfo
-
>
image_width
dinfo
-
>
image_height
color
SkEncodedInfo
:
:
kOpaque_Alpha
8
std
:
:
move
(
profile
)
)
;
SkJpegCodec
*
codec
=
new
SkJpegCodec
(
std
:
:
move
(
info
)
std
:
:
unique_ptr
<
SkStream
>
(
stream
)
decoderMgr
.
release
(
)
orientation
)
;
*
codecOut
=
codec
;
}
else
{
SkASSERT
(
nullptr
!
=
decoderMgrOut
)
;
*
decoderMgrOut
=
decoderMgr
.
release
(
)
;
}
return
kSuccess
;
}
std
:
:
unique_ptr
<
SkCodec
>
SkJpegCodec
:
:
MakeFromStream
(
std
:
:
unique_ptr
<
SkStream
>
stream
Result
*
result
)
{
return
SkJpegCodec
:
:
MakeFromStream
(
std
:
:
move
(
stream
)
result
nullptr
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
SkJpegCodec
:
:
MakeFromStream
(
std
:
:
unique_ptr
<
SkStream
>
stream
Result
*
result
std
:
:
unique_ptr
<
SkEncodedInfo
:
:
ICCProfile
>
defaultColorProfile
)
{
SkASSERT
(
result
)
;
if
(
!
stream
)
{
*
result
=
SkCodec
:
:
kInvalidInput
;
return
nullptr
;
}
SkCodec
*
codec
=
nullptr
;
*
result
=
ReadHeader
(
stream
.
get
(
)
&
codec
nullptr
std
:
:
move
(
defaultColorProfile
)
)
;
if
(
kSuccess
=
=
*
result
)
{
SkASSERT
(
codec
)
;
stream
.
release
(
)
;
return
std
:
:
unique_ptr
<
SkCodec
>
(
codec
)
;
}
return
nullptr
;
}
SkJpegCodec
:
:
SkJpegCodec
(
SkEncodedInfo
&
&
info
std
:
:
unique_ptr
<
SkStream
>
stream
JpegDecoderMgr
*
decoderMgr
SkEncodedOrigin
origin
)
:
INHERITED
(
std
:
:
move
(
info
)
skcms_PixelFormat_RGBA_8888
std
:
:
move
(
stream
)
origin
)
fDecoderMgr
(
decoderMgr
)
fReadyState
(
decoderMgr
-
>
dinfo
(
)
-
>
global_state
)
{
}
SkJpegCodec
:
:
~
SkJpegCodec
(
)
=
default
;
static
size_t
get_row_bytes
(
const
j_decompress_ptr
dinfo
)
{
const
size_t
colorBytes
=
(
dinfo
-
>
out_color_space
=
=
JCS_RGB565
)
?
2
:
dinfo
-
>
out_color_components
;
return
dinfo
-
>
output_width
*
colorBytes
;
}
void
calc_output_dimensions
(
jpeg_decompress_struct
*
dinfo
unsigned
int
num
unsigned
int
denom
)
{
dinfo
-
>
num_components
=
0
;
dinfo
-
>
scale_num
=
num
;
dinfo
-
>
scale_denom
=
denom
;
jpeg_calc_output_dimensions
(
dinfo
)
;
}
SkISize
SkJpegCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
unsigned
int
num
;
unsigned
int
denom
=
8
;
if
(
desiredScale
>
=
0
.
9375
)
{
num
=
8
;
}
else
if
(
desiredScale
>
=
0
.
8125
)
{
num
=
7
;
}
else
if
(
desiredScale
>
=
0
.
6875f
)
{
num
=
6
;
}
else
if
(
desiredScale
>
=
0
.
5625f
)
{
num
=
5
;
}
else
if
(
desiredScale
>
=
0
.
4375f
)
{
num
=
4
;
}
else
if
(
desiredScale
>
=
0
.
3125f
)
{
num
=
3
;
}
else
if
(
desiredScale
>
=
0
.
1875f
)
{
num
=
2
;
}
else
{
num
=
1
;
}
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
dimensions
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
dimensions
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
return
SkISize
:
:
Make
(
dinfo
.
output_width
dinfo
.
output_height
)
;
}
bool
SkJpegCodec
:
:
onRewind
(
)
{
JpegDecoderMgr
*
decoderMgr
=
nullptr
;
if
(
kSuccess
!
=
ReadHeader
(
this
-
>
stream
(
)
nullptr
&
decoderMgr
nullptr
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onRewind
"
)
;
}
SkASSERT
(
nullptr
!
=
decoderMgr
)
;
fDecoderMgr
.
reset
(
decoderMgr
)
;
fSwizzler
.
reset
(
nullptr
)
;
fSwizzleSrcRow
=
nullptr
;
fColorXformSrcRow
=
nullptr
;
fStorage
.
reset
(
)
;
return
true
;
}
bool
SkJpegCodec
:
:
conversionSupported
(
const
SkImageInfo
&
dstInfo
bool
srcIsOpaque
bool
needsColorXform
)
{
SkASSERT
(
srcIsOpaque
)
;
if
(
kUnknown_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
return
false
;
}
if
(
kOpaque_SkAlphaType
!
=
dstInfo
.
alphaType
(
)
)
{
SkCodecPrintf
(
"
Warning
:
an
opaque
image
should
be
decoded
as
opaque
"
"
-
it
is
being
decoded
as
non
-
opaque
which
will
draw
slower
\
n
"
)
;
}
J_COLOR_SPACE
encodedColorType
=
fDecoderMgr
-
>
dinfo
(
)
-
>
jpeg_color_space
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
break
;
case
kBGRA_8888_SkColorType
:
if
(
needsColorXform
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_BGRA
;
}
break
;
case
kRGB_565_SkColorType
:
if
(
needsColorXform
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
dither_mode
=
JDITHER_NONE
;
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_RGB565
;
}
break
;
case
kGray_8_SkColorType
:
if
(
JCS_GRAYSCALE
!
=
encodedColorType
)
{
return
false
;
}
if
(
needsColorXform
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_GRAYSCALE
;
}
break
;
case
kBGRA_10101010_XR_SkColorType
:
case
kBGR_101010x_XR_SkColorType
:
case
kRGBA_F16_SkColorType
:
SkASSERT
(
needsColorXform
)
;
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
break
;
default
:
return
false
;
}
if
(
JCS_CMYK
=
=
encodedColorType
|
|
JCS_YCCK
=
=
encodedColorType
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
return
true
;
}
bool
SkJpegCodec
:
:
onDimensionsSupported
(
const
SkISize
&
size
)
{
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onDimensionsSupported
"
)
;
}
const
unsigned
int
dstWidth
=
size
.
width
(
)
;
const
unsigned
int
dstHeight
=
size
.
height
(
)
;
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
dimensions
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
dimensions
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
unsigned
int
num
=
8
;
const
unsigned
int
denom
=
8
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
while
(
dinfo
.
output_width
!
=
dstWidth
|
|
dinfo
.
output_height
!
=
dstHeight
)
{
if
(
1
=
=
num
|
|
dstWidth
>
dinfo
.
output_width
|
|
dstHeight
>
dinfo
.
output_height
)
{
return
false
;
}
num
-
=
1
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
}
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_num
=
num
;
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_denom
=
denom
;
return
true
;
}
int
SkJpegCodec
:
:
readRows
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
int
count
const
Options
&
opts
)
{
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
0
;
}
JSAMPLE
*
decodeDst
=
(
JSAMPLE
*
)
dst
;
uint32_t
*
swizzleDst
=
(
uint32_t
*
)
dst
;
size_t
decodeDstRowBytes
=
rowBytes
;
size_t
swizzleDstRowBytes
=
rowBytes
;
int
dstWidth
=
opts
.
fSubset
?
opts
.
fSubset
-
>
width
(
)
:
dstInfo
.
width
(
)
;
if
(
fSwizzleSrcRow
&
&
fColorXformSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fSwizzleSrcRow
;
swizzleDst
=
fColorXformSrcRow
;
decodeDstRowBytes
=
0
;
swizzleDstRowBytes
=
0
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
}
else
if
(
fColorXformSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fColorXformSrcRow
;
swizzleDst
=
fColorXformSrcRow
;
decodeDstRowBytes
=
0
;
swizzleDstRowBytes
=
0
;
}
else
if
(
fSwizzleSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fSwizzleSrcRow
;
decodeDstRowBytes
=
0
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
}
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
uint32_t
lines
=
jpeg_read_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
&
decodeDst
1
)
;
if
(
0
=
=
lines
)
{
return
y
;
}
if
(
fSwizzler
)
{
fSwizzler
-
>
swizzle
(
swizzleDst
decodeDst
)
;
}
if
(
this
-
>
colorXform
(
)
)
{
this
-
>
applyColorXform
(
dst
swizzleDst
dstWidth
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
)
;
}
decodeDst
=
SkTAddOffset
<
JSAMPLE
>
(
decodeDst
decodeDstRowBytes
)
;
swizzleDst
=
SkTAddOffset
<
uint32_t
>
(
swizzleDst
swizzleDstRowBytes
)
;
}
return
count
;
}
static
inline
bool
needs_swizzler_to_convert_from_cmyk
(
J_COLOR_SPACE
jpegColorType
const
skcms_ICCProfile
*
srcProfile
bool
hasColorSpaceXform
)
{
if
(
JCS_CMYK
!
=
jpegColorType
)
{
return
false
;
}
bool
hasCMYKColorSpace
=
srcProfile
&
&
srcProfile
-
>
data_color_space
=
=
skcms_Signature_CMYK
;
return
!
hasCMYKColorSpace
|
|
!
hasColorSpaceXform
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
options
int
*
rowsDecoded
)
{
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
if
(
!
jpeg_start_decompress
(
dinfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
startDecompress
"
kInvalidInput
)
;
}
SkASSERT
(
1
=
=
dinfo
-
>
rec_outbuf_height
)
;
if
(
needs_swizzler_to_convert_from_cmyk
(
dinfo
-
>
out_color_space
this
-
>
getEncodedInfo
(
)
.
profile
(
)
this
-
>
colorXform
(
)
)
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
true
)
;
}
if
(
!
this
-
>
allocateStorage
(
dstInfo
)
)
{
return
kInternalError
;
}
int
rows
=
this
-
>
readRows
(
dstInfo
dst
dstRowBytes
dstInfo
.
height
(
)
options
)
;
if
(
rows
<
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
rows
;
return
fDecoderMgr
-
>
returnFailure
(
"
Incomplete
image
data
"
kIncompleteInput
)
;
}
return
kSuccess
;
}
bool
SkJpegCodec
:
:
allocateStorage
(
const
SkImageInfo
&
dstInfo
)
{
int
dstWidth
=
dstInfo
.
width
(
)
;
size_t
swizzleBytes
=
0
;
if
(
fSwizzler
)
{
swizzleBytes
=
get_row_bytes
(
fDecoderMgr
-
>
dinfo
(
)
)
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
SkASSERT
(
!
this
-
>
colorXform
(
)
|
|
SkIsAlign4
(
swizzleBytes
)
)
;
}
size_t
xformBytes
=
0
;
if
(
this
-
>
colorXform
(
)
&
&
sizeof
(
uint32_t
)
!
=
dstInfo
.
bytesPerPixel
(
)
)
{
xformBytes
=
dstWidth
*
sizeof
(
uint32_t
)
;
}
size_t
totalBytes
=
swizzleBytes
+
xformBytes
;
if
(
totalBytes
>
0
)
{
if
(
!
fStorage
.
reset
(
totalBytes
)
)
{
return
false
;
}
fSwizzleSrcRow
=
(
swizzleBytes
>
0
)
?
fStorage
.
get
(
)
:
nullptr
;
fColorXformSrcRow
=
(
xformBytes
>
0
)
?
SkTAddOffset
<
uint32_t
>
(
fStorage
.
get
(
)
swizzleBytes
)
:
nullptr
;
}
return
true
;
}
void
SkJpegCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
bool
needsCMYKToRGB
)
{
Options
swizzlerOptions
=
options
;
if
(
options
.
fSubset
)
{
SkASSERT
(
!
fSwizzlerSubset
.
isEmpty
(
)
&
&
fSwizzlerSubset
.
x
(
)
<
=
options
.
fSubset
-
>
x
(
)
&
&
fSwizzlerSubset
.
width
(
)
=
=
options
.
fSubset
-
>
width
(
)
)
;
swizzlerOptions
.
fSubset
=
&
fSwizzlerSubset
;
}
SkImageInfo
swizzlerDstInfo
=
dstInfo
;
if
(
this
-
>
colorXform
(
)
)
{
swizzlerDstInfo
=
swizzlerDstInfo
.
makeColorType
(
kRGBA_8888_SkColorType
)
;
}
if
(
needsCMYKToRGB
)
{
auto
swizzlerInfo
=
SkEncodedInfo
:
:
Make
(
0
0
SkEncodedInfo
:
:
kInvertedCMYK_Color
SkEncodedInfo
:
:
kOpaque_Alpha
8
)
;
fSwizzler
=
SkSwizzler
:
:
Make
(
swizzlerInfo
nullptr
swizzlerDstInfo
swizzlerOptions
)
;
}
else
{
int
srcBPP
=
0
;
switch
(
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
)
{
case
JCS_EXT_RGBA
:
case
JCS_EXT_BGRA
:
case
JCS_CMYK
:
srcBPP
=
4
;
break
;
case
JCS_RGB565
:
srcBPP
=
2
;
break
;
case
JCS_GRAYSCALE
:
srcBPP
=
1
;
break
;
default
:
SkASSERT
(
false
)
;
break
;
}
fSwizzler
=
SkSwizzler
:
:
MakeSimple
(
srcBPP
swizzlerDstInfo
swizzlerOptions
)
;
}
SkASSERT
(
fSwizzler
)
;
}
SkSampler
*
SkJpegCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
!
createIfNecessary
|
|
fSwizzler
)
{
SkASSERT
(
!
fSwizzler
|
|
(
fSwizzleSrcRow
&
&
fStorage
.
get
(
)
=
=
fSwizzleSrcRow
)
)
;
return
fSwizzler
.
get
(
)
;
}
bool
needsCMYKToRGB
=
needs_swizzler_to_convert_from_cmyk
(
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
this
-
>
getEncodedInfo
(
)
.
profile
(
)
this
-
>
colorXform
(
)
)
;
this
-
>
initializeSwizzler
(
this
-
>
dstInfo
(
)
this
-
>
options
(
)
needsCMYKToRGB
)
;
if
(
!
this
-
>
allocateStorage
(
this
-
>
dstInfo
(
)
)
)
{
return
nullptr
;
}
return
fSwizzler
.
get
(
)
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
)
{
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
SkCodecPrintf
(
"
setjmp
:
Error
from
libjpeg
\
n
"
)
;
return
kInvalidInput
;
}
if
(
!
jpeg_start_decompress
(
fDecoderMgr
-
>
dinfo
(
)
)
)
{
SkCodecPrintf
(
"
start
decompress
failed
\
n
"
)
;
return
kInvalidInput
;
}
bool
needsCMYKToRGB
=
needs_swizzler_to_convert_from_cmyk
(
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
this
-
>
getEncodedInfo
(
)
.
profile
(
)
this
-
>
colorXform
(
)
)
;
if
(
options
.
fSubset
)
{
uint32_t
startX
=
options
.
fSubset
-
>
x
(
)
;
uint32_t
width
=
options
.
fSubset
-
>
width
(
)
;
jpeg_crop_scanline
(
fDecoderMgr
-
>
dinfo
(
)
&
startX
&
width
)
;
SkASSERT
(
startX
<
=
(
uint32_t
)
options
.
fSubset
-
>
x
(
)
)
;
SkASSERT
(
width
>
=
(
uint32_t
)
options
.
fSubset
-
>
width
(
)
)
;
SkASSERT
(
startX
+
width
>
=
(
uint32_t
)
options
.
fSubset
-
>
right
(
)
)
;
fSwizzlerSubset
.
setXYWH
(
options
.
fSubset
-
>
x
(
)
-
startX
0
options
.
fSubset
-
>
width
(
)
options
.
fSubset
-
>
height
(
)
)
;
if
(
startX
!
=
(
uint32_t
)
options
.
fSubset
-
>
x
(
)
|
|
width
!
=
(
uint32_t
)
options
.
fSubset
-
>
width
(
)
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
needsCMYKToRGB
)
;
}
}
if
(
!
fSwizzler
&
&
needsCMYKToRGB
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
true
)
;
}
if
(
!
this
-
>
allocateStorage
(
dstInfo
)
)
{
return
kInternalError
;
}
return
kSuccess
;
}
int
SkJpegCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
dstRowBytes
)
{
int
rows
=
this
-
>
readRows
(
this
-
>
dstInfo
(
)
dst
dstRowBytes
count
this
-
>
options
(
)
)
;
if
(
rows
<
count
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
output_scanline
=
this
-
>
dstInfo
(
)
.
height
(
)
;
}
return
rows
;
}
bool
SkJpegCodec
:
:
onSkipScanlines
(
int
count
)
{
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onSkipScanlines
"
)
;
}
return
(
uint32_t
)
count
=
=
jpeg_skip_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
count
)
;
}
static
bool
is_yuv_supported
(
const
jpeg_decompress_struct
*
dinfo
const
SkJpegCodec
&
codec
const
SkYUVAPixmapInfo
:
:
SupportedDataTypes
*
supportedDataTypes
SkYUVAPixmapInfo
*
yuvaPixmapInfo
)
{
SkASSERT
(
dinfo
-
>
scale_num
=
=
dinfo
-
>
scale_denom
)
;
static_assert
(
8
=
=
DCTSIZE
"
DCTSIZE
(
defined
in
jpeg
library
)
should
always
be
8
.
"
)
;
if
(
JCS_YCbCr
!
=
dinfo
-
>
jpeg_color_space
)
{
return
false
;
}
SkASSERT
(
3
=
=
dinfo
-
>
num_components
)
;
SkASSERT
(
dinfo
-
>
comp_info
)
;
if
(
(
1
!
=
dinfo
-
>
comp_info
[
1
]
.
h_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
1
]
.
v_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
2
]
.
h_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
2
]
.
v_samp_factor
)
)
{
return
false
;
}
int
hSampY
=
dinfo
-
>
comp_info
[
0
]
.
h_samp_factor
;
int
vSampY
=
dinfo
-
>
comp_info
[
0
]
.
v_samp_factor
;
SkASSERT
(
hSampY
=
=
dinfo
-
>
max_h_samp_factor
)
;
SkASSERT
(
vSampY
=
=
dinfo
-
>
max_v_samp_factor
)
;
SkYUVAInfo
:
:
Subsampling
tempSubsampling
;
if
(
1
=
=
hSampY
&
&
1
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k444
;
}
else
if
(
2
=
=
hSampY
&
&
1
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k422
;
}
else
if
(
2
=
=
hSampY
&
&
2
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k420
;
}
else
if
(
1
=
=
hSampY
&
&
2
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k440
;
}
else
if
(
4
=
=
hSampY
&
&
1
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k411
;
}
else
if
(
4
=
=
hSampY
&
&
2
=
=
vSampY
)
{
tempSubsampling
=
SkYUVAInfo
:
:
Subsampling
:
:
k410
;
}
else
{
return
false
;
}
if
(
supportedDataTypes
&
&
!
supportedDataTypes
-
>
supported
(
SkYUVAInfo
:
:
PlaneConfig
:
:
kY_U_V
SkYUVAPixmapInfo
:
:
DataType
:
:
kUnorm8
)
)
{
return
false
;
}
if
(
yuvaPixmapInfo
)
{
SkColorType
colorTypes
[
SkYUVAPixmapInfo
:
:
kMaxPlanes
]
;
size_t
rowBytes
[
SkYUVAPixmapInfo
:
:
kMaxPlanes
]
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
colorTypes
[
i
]
=
kAlpha_8_SkColorType
;
rowBytes
[
i
]
=
dinfo
-
>
comp_info
[
i
]
.
width_in_blocks
*
DCTSIZE
;
}
SkYUVAInfo
yuvaInfo
(
codec
.
dimensions
(
)
SkYUVAInfo
:
:
PlaneConfig
:
:
kY_U_V
tempSubsampling
kJPEG_Full_SkYUVColorSpace
codec
.
getOrigin
(
)
SkYUVAInfo
:
:
Siting
:
:
kCentered
SkYUVAInfo
:
:
Siting
:
:
kCentered
)
;
*
yuvaPixmapInfo
=
SkYUVAPixmapInfo
(
yuvaInfo
colorTypes
rowBytes
)
;
}
return
true
;
}
bool
SkJpegCodec
:
:
onQueryYUVAInfo
(
const
SkYUVAPixmapInfo
:
:
SupportedDataTypes
&
supportedDataTypes
SkYUVAPixmapInfo
*
yuvaPixmapInfo
)
const
{
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
return
is_yuv_supported
(
dinfo
*
this
&
supportedDataTypes
yuvaPixmapInfo
)
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onGetYUVAPlanes
(
const
SkYUVAPixmaps
&
yuvaPixmaps
)
{
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
if
(
!
is_yuv_supported
(
dinfo
*
this
nullptr
nullptr
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
onGetYUVAPlanes
"
kInvalidInput
)
;
}
skjpeg_error_mgr
:
:
AutoPushJmpBuf
jmp
(
fDecoderMgr
-
>
errorMgr
(
)
)
;
if
(
setjmp
(
jmp
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
dinfo
-
>
raw_data_out
=
TRUE
;
if
(
!
jpeg_start_decompress
(
dinfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
startDecompress
"
kInvalidInput
)
;
}
const
std
:
:
array
<
SkPixmap
SkYUVAPixmaps
:
:
kMaxPlanes
>
&
planes
=
yuvaPixmaps
.
planes
(
)
;
#
ifdef
SK_DEBUG
{
SkYUVAPixmapInfo
info
;
SkASSERT
(
is_yuv_supported
(
dinfo
*
this
nullptr
&
info
)
)
;
SkASSERT
(
info
.
yuvaInfo
(
)
=
=
yuvaPixmaps
.
yuvaInfo
(
)
)
;
for
(
int
i
=
0
;
i
<
info
.
numPlanes
(
)
;
+
+
i
)
{
SkASSERT
(
planes
[
i
]
.
colorType
(
)
=
=
kAlpha_8_SkColorType
)
;
SkASSERT
(
info
.
planeInfo
(
i
)
=
=
planes
[
i
]
.
info
(
)
)
;
}
}
#
endif
JSAMPARRAY
yuv
[
3
]
;
JSAMPROW
rowptrs
[
2
*
DCTSIZE
+
DCTSIZE
+
DCTSIZE
]
;
yuv
[
0
]
=
&
rowptrs
[
0
]
;
yuv
[
1
]
=
&
rowptrs
[
2
*
DCTSIZE
]
;
yuv
[
2
]
=
&
rowptrs
[
3
*
DCTSIZE
]
;
int
numYRowsPerBlock
=
DCTSIZE
*
dinfo
-
>
comp_info
[
0
]
.
v_samp_factor
;
static_assert
(
sizeof
(
JSAMPLE
)
=
=
1
)
;
for
(
int
i
=
0
;
i
<
numYRowsPerBlock
;
i
+
+
)
{
rowptrs
[
i
]
=
static_cast
<
JSAMPLE
*
>
(
planes
[
0
]
.
writable_addr
(
)
)
+
i
*
planes
[
0
]
.
rowBytes
(
)
;
}
for
(
int
i
=
0
;
i
<
DCTSIZE
;
i
+
+
)
{
rowptrs
[
i
+
2
*
DCTSIZE
]
=
static_cast
<
JSAMPLE
*
>
(
planes
[
1
]
.
writable_addr
(
)
)
+
i
*
planes
[
1
]
.
rowBytes
(
)
;
rowptrs
[
i
+
3
*
DCTSIZE
]
=
static_cast
<
JSAMPLE
*
>
(
planes
[
2
]
.
writable_addr
(
)
)
+
i
*
planes
[
2
]
.
rowBytes
(
)
;
}
size_t
blockIncrementY
=
numYRowsPerBlock
*
planes
[
0
]
.
rowBytes
(
)
;
size_t
blockIncrementU
=
DCTSIZE
*
planes
[
1
]
.
rowBytes
(
)
;
size_t
blockIncrementV
=
DCTSIZE
*
planes
[
2
]
.
rowBytes
(
)
;
uint32_t
numRowsPerBlock
=
numYRowsPerBlock
;
const
int
numIters
=
dinfo
-
>
output_height
/
numRowsPerBlock
;
for
(
int
i
=
0
;
i
<
numIters
;
i
+
+
)
{
JDIMENSION
linesRead
=
jpeg_read_raw_data
(
dinfo
yuv
numRowsPerBlock
)
;
if
(
linesRead
<
numRowsPerBlock
)
{
return
kInvalidInput
;
}
for
(
int
j
=
0
;
j
<
numYRowsPerBlock
;
j
+
+
)
{
rowptrs
[
j
]
+
=
blockIncrementY
;
}
for
(
int
j
=
0
;
j
<
DCTSIZE
;
j
+
+
)
{
rowptrs
[
j
+
2
*
DCTSIZE
]
+
=
blockIncrementU
;
rowptrs
[
j
+
3
*
DCTSIZE
]
+
=
blockIncrementV
;
}
}
uint32_t
remainingRows
=
dinfo
-
>
output_height
-
dinfo
-
>
output_scanline
;
SkASSERT
(
remainingRows
=
=
dinfo
-
>
output_height
%
numRowsPerBlock
)
;
SkASSERT
(
dinfo
-
>
output_scanline
=
=
numIters
*
numRowsPerBlock
)
;
if
(
remainingRows
>
0
)
{
AutoTMalloc
<
JSAMPLE
>
extraRow
(
planes
[
0
]
.
rowBytes
(
)
)
;
for
(
int
i
=
remainingRows
;
i
<
numYRowsPerBlock
;
i
+
+
)
{
rowptrs
[
i
]
=
extraRow
.
get
(
)
;
}
int
remainingUVRows
=
dinfo
-
>
comp_info
[
1
]
.
downsampled_height
-
DCTSIZE
*
numIters
;
for
(
int
i
=
remainingUVRows
;
i
<
DCTSIZE
;
i
+
+
)
{
rowptrs
[
i
+
2
*
DCTSIZE
]
=
extraRow
.
get
(
)
;
rowptrs
[
i
+
3
*
DCTSIZE
]
=
extraRow
.
get
(
)
;
}
JDIMENSION
linesRead
=
jpeg_read_raw_data
(
dinfo
yuv
numRowsPerBlock
)
;
if
(
linesRead
<
remainingRows
)
{
return
kInvalidInput
;
}
}
return
kSuccess
;
}
bool
SkJpegCodec
:
:
onGetGainmapCodec
(
SkGainmapInfo
*
info
std
:
:
unique_ptr
<
SkCodec
>
*
gainmapCodec
)
{
std
:
:
unique_ptr
<
SkStream
>
stream
;
if
(
!
this
-
>
onGetGainmapInfo
(
info
&
stream
)
)
{
return
false
;
}
if
(
gainmapCodec
)
{
Result
result
;
*
gainmapCodec
=
MakeFromStream
(
std
:
:
move
(
stream
)
&
result
)
;
if
(
!
*
gainmapCodec
)
{
return
false
;
}
}
return
true
;
}
bool
SkJpegCodec
:
:
onGetGainmapInfo
(
SkGainmapInfo
*
info
std
:
:
unique_ptr
<
SkStream
>
*
gainmapImageStream
)
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
sk_sp
<
SkData
>
gainmap_data
;
SkGainmapInfo
gainmap_info
;
auto
metadataDecoder
=
std
:
:
make_unique
<
SkJpegMetadataDecoderImpl
>
(
get_sk_marker_list
(
fDecoderMgr
-
>
dinfo
(
)
)
)
;
if
(
!
metadataDecoder
-
>
findGainmapImage
(
fDecoderMgr
-
>
getSourceMgr
(
)
gainmap_data
gainmap_info
)
)
{
return
false
;
}
*
info
=
gainmap_info
;
*
gainmapImageStream
=
SkMemoryStream
:
:
Make
(
gainmap_data
)
;
return
true
;
#
else
return
false
;
#
endif
}
namespace
SkJpegDecoder
{
bool
IsJpeg
(
const
void
*
data
size_t
len
)
{
return
SkJpegCodec
:
:
IsJpeg
(
data
len
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
Decode
(
std
:
:
unique_ptr
<
SkStream
>
stream
SkCodec
:
:
Result
*
outResult
SkCodecs
:
:
DecodeContext
)
{
SkCodec
:
:
Result
resultStorage
;
if
(
!
outResult
)
{
outResult
=
&
resultStorage
;
}
return
SkJpegCodec
:
:
MakeFromStream
(
std
:
:
move
(
stream
)
outResult
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
Decode
(
sk_sp
<
SkData
>
data
SkCodec
:
:
Result
*
outResult
SkCodecs
:
:
DecodeContext
)
{
if
(
!
data
)
{
if
(
outResult
)
{
*
outResult
=
SkCodec
:
:
kInvalidInput
;
}
return
nullptr
;
}
return
Decode
(
SkMemoryStream
:
:
Make
(
std
:
:
move
(
data
)
)
outResult
nullptr
)
;
}
}
