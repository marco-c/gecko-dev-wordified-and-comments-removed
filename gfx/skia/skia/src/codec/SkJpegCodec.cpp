#
include
"
SkCodec
.
h
"
#
include
"
SkJpegCodec
.
h
"
#
include
"
SkJpegDecoderMgr
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorSpace_Base
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
stdio
.
h
>
#
include
"
SkJpegUtility
.
h
"
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
pragma
GCC
diagnostic
ignored
"
-
Wclobbered
"
#
endif
extern
"
C
"
{
#
include
"
jerror
.
h
"
#
include
"
jpeglib
.
h
"
}
bool
SkJpegCodec
:
:
IsJpeg
(
const
void
*
buffer
size_t
bytesRead
)
{
static
const
uint8_t
jpegSig
[
]
=
{
0xFF
0xD8
0xFF
}
;
return
bytesRead
>
=
3
&
&
!
memcmp
(
buffer
jpegSig
sizeof
(
jpegSig
)
)
;
}
static
uint32_t
get_endian_int
(
const
uint8_t
*
data
bool
littleEndian
)
{
if
(
littleEndian
)
{
return
(
data
[
3
]
<
<
24
)
|
(
data
[
2
]
<
<
16
)
|
(
data
[
1
]
<
<
8
)
|
(
data
[
0
]
)
;
}
return
(
data
[
0
]
<
<
24
)
|
(
data
[
1
]
<
<
16
)
|
(
data
[
2
]
<
<
8
)
|
(
data
[
3
]
)
;
}
const
uint32_t
kExifHeaderSize
=
14
;
const
uint32_t
kExifMarker
=
JPEG_APP0
+
1
;
static
bool
is_orientation_marker
(
jpeg_marker_struct
*
marker
SkCodec
:
:
Origin
*
orientation
)
{
if
(
kExifMarker
!
=
marker
-
>
marker
|
|
marker
-
>
data_length
<
kExifHeaderSize
)
{
return
false
;
}
const
uint8_t
*
data
=
marker
-
>
data
;
static
const
uint8_t
kExifSig
[
]
{
'
E
'
'
x
'
'
i
'
'
f
'
'
\
0
'
}
;
if
(
memcmp
(
data
kExifSig
sizeof
(
kExifSig
)
)
)
{
return
false
;
}
bool
littleEndian
;
if
(
!
is_valid_endian_marker
(
data
+
6
&
littleEndian
)
)
{
return
false
;
}
uint32_t
offset
=
get_endian_int
(
data
+
10
littleEndian
)
;
offset
+
=
sizeof
(
kExifSig
)
+
1
;
if
(
marker
-
>
data_length
<
offset
+
2
)
{
return
false
;
}
uint32_t
numEntries
=
get_endian_short
(
data
+
offset
littleEndian
)
;
const
uint32_t
kEntrySize
=
12
;
numEntries
=
SkTMin
(
numEntries
(
marker
-
>
data_length
-
offset
-
2
)
/
kEntrySize
)
;
data
+
=
offset
+
2
;
const
uint16_t
kOriginTag
=
0x112
;
const
uint16_t
kOriginType
=
3
;
for
(
uint32_t
i
=
0
;
i
<
numEntries
;
i
+
+
data
+
=
kEntrySize
)
{
uint16_t
tag
=
get_endian_short
(
data
littleEndian
)
;
uint16_t
type
=
get_endian_short
(
data
+
2
littleEndian
)
;
uint32_t
count
=
get_endian_int
(
data
+
4
littleEndian
)
;
if
(
kOriginTag
=
=
tag
&
&
kOriginType
=
=
type
&
&
1
=
=
count
)
{
uint16_t
val
=
get_endian_short
(
data
+
8
littleEndian
)
;
if
(
0
<
val
&
&
val
<
=
SkCodec
:
:
kLast_Origin
)
{
*
orientation
=
(
SkCodec
:
:
Origin
)
val
;
return
true
;
}
}
}
return
false
;
}
static
SkCodec
:
:
Origin
get_exif_orientation
(
jpeg_decompress_struct
*
dinfo
)
{
SkCodec
:
:
Origin
orientation
;
for
(
jpeg_marker_struct
*
marker
=
dinfo
-
>
marker_list
;
marker
;
marker
=
marker
-
>
next
)
{
if
(
is_orientation_marker
(
marker
&
orientation
)
)
{
return
orientation
;
}
}
return
SkCodec
:
:
kDefault_Origin
;
}
static
bool
is_icc_marker
(
jpeg_marker_struct
*
marker
)
{
if
(
kICCMarker
!
=
marker
-
>
marker
|
|
marker
-
>
data_length
<
kICCMarkerHeaderSize
)
{
return
false
;
}
return
!
memcmp
(
marker
-
>
data
kICCSig
sizeof
(
kICCSig
)
)
;
}
static
sk_sp
<
SkData
>
get_icc_profile
(
jpeg_decompress_struct
*
dinfo
)
{
jpeg_marker_struct
*
markerSequence
[
256
]
;
memset
(
markerSequence
0
sizeof
(
markerSequence
)
)
;
uint8_t
numMarkers
=
0
;
size_t
totalBytes
=
0
;
for
(
jpeg_marker_struct
*
marker
=
dinfo
-
>
marker_list
;
marker
;
marker
=
marker
-
>
next
)
{
if
(
is_icc_marker
(
marker
)
)
{
if
(
0
=
=
numMarkers
)
{
numMarkers
=
marker
-
>
data
[
13
]
;
if
(
0
=
=
numMarkers
)
{
SkCodecPrintf
(
"
ICC
Profile
Error
:
numMarkers
must
be
greater
than
zero
.
\
n
"
)
;
return
nullptr
;
}
}
else
if
(
numMarkers
!
=
marker
-
>
data
[
13
]
)
{
SkCodecPrintf
(
"
ICC
Profile
Error
:
numMarkers
must
be
consistent
.
\
n
"
)
;
return
nullptr
;
}
uint8_t
markerIndex
=
marker
-
>
data
[
12
]
;
if
(
markerIndex
=
=
0
|
|
markerIndex
>
numMarkers
)
{
SkCodecPrintf
(
"
ICC
Profile
Error
:
markerIndex
is
invalid
.
\
n
"
)
;
return
nullptr
;
}
if
(
markerSequence
[
markerIndex
]
)
{
SkCodecPrintf
(
"
ICC
Profile
Error
:
Duplicate
value
of
markerIndex
.
\
n
"
)
;
return
nullptr
;
}
markerSequence
[
markerIndex
]
=
marker
;
SkASSERT
(
marker
-
>
data_length
>
=
kICCMarkerHeaderSize
)
;
totalBytes
+
=
marker
-
>
data_length
-
kICCMarkerHeaderSize
;
}
}
if
(
0
=
=
totalBytes
)
{
return
nullptr
;
}
sk_sp
<
SkData
>
iccData
=
SkData
:
:
MakeUninitialized
(
totalBytes
)
;
void
*
dst
=
iccData
-
>
writable_data
(
)
;
for
(
uint32_t
i
=
1
;
i
<
=
numMarkers
;
i
+
+
)
{
jpeg_marker_struct
*
marker
=
markerSequence
[
i
]
;
if
(
!
marker
)
{
SkCodecPrintf
(
"
ICC
Profile
Error
:
Missing
marker
%
d
of
%
d
.
\
n
"
i
numMarkers
)
;
return
nullptr
;
}
void
*
src
=
SkTAddOffset
<
void
>
(
marker
-
>
data
kICCMarkerHeaderSize
)
;
size_t
bytes
=
marker
-
>
data_length
-
kICCMarkerHeaderSize
;
memcpy
(
dst
src
bytes
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
bytes
)
;
}
return
iccData
;
}
bool
SkJpegCodec
:
:
ReadHeader
(
SkStream
*
stream
SkCodec
*
*
codecOut
JpegDecoderMgr
*
*
decoderMgrOut
sk_sp
<
SkColorSpace
>
defaultColorSpace
)
{
std
:
:
unique_ptr
<
JpegDecoderMgr
>
decoderMgr
(
new
JpegDecoderMgr
(
stream
)
)
;
if
(
setjmp
(
decoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
decoderMgr
-
>
returnFalse
(
"
ReadHeader
"
)
;
}
decoderMgr
-
>
init
(
)
;
if
(
codecOut
)
{
jpeg_save_markers
(
decoderMgr
-
>
dinfo
(
)
kExifMarker
0xFFFF
)
;
jpeg_save_markers
(
decoderMgr
-
>
dinfo
(
)
kICCMarker
0xFFFF
)
;
}
if
(
JPEG_HEADER_OK
!
=
jpeg_read_header
(
decoderMgr
-
>
dinfo
(
)
true
)
)
{
return
decoderMgr
-
>
returnFalse
(
"
ReadHeader
"
)
;
}
if
(
codecOut
)
{
SkEncodedInfo
:
:
Color
color
;
if
(
!
decoderMgr
-
>
getEncodedColor
(
&
color
)
)
{
return
false
;
}
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
color
SkEncodedInfo
:
:
kOpaque_Alpha
8
)
;
Origin
orientation
=
get_exif_orientation
(
decoderMgr
-
>
dinfo
(
)
)
;
sk_sp
<
SkData
>
iccData
=
get_icc_profile
(
decoderMgr
-
>
dinfo
(
)
)
;
sk_sp
<
SkColorSpace
>
colorSpace
=
nullptr
;
bool
unsupportedICC
=
false
;
if
(
iccData
)
{
SkColorSpace_Base
:
:
ICCTypeFlag
iccType
=
SkColorSpace_Base
:
:
kRGB_ICCTypeFlag
;
switch
(
decoderMgr
-
>
dinfo
(
)
-
>
jpeg_color_space
)
{
case
JCS_CMYK
:
case
JCS_YCCK
:
iccType
=
SkColorSpace_Base
:
:
kCMYK_ICCTypeFlag
;
break
;
case
JCS_GRAYSCALE
:
iccType
|
=
SkColorSpace_Base
:
:
kGray_ICCTypeFlag
;
break
;
default
:
break
;
}
colorSpace
=
SkColorSpace_Base
:
:
MakeICC
(
iccData
-
>
data
(
)
iccData
-
>
size
(
)
iccType
)
;
if
(
!
colorSpace
)
{
SkCodecPrintf
(
"
Could
not
create
SkColorSpace
from
ICC
data
.
\
n
"
)
;
unsupportedICC
=
true
;
}
}
if
(
!
colorSpace
)
{
colorSpace
=
defaultColorSpace
;
}
const
int
width
=
decoderMgr
-
>
dinfo
(
)
-
>
image_width
;
const
int
height
=
decoderMgr
-
>
dinfo
(
)
-
>
image_height
;
SkJpegCodec
*
codec
=
new
SkJpegCodec
(
width
height
info
stream
decoderMgr
.
release
(
)
std
:
:
move
(
colorSpace
)
orientation
)
;
codec
-
>
setUnsupportedICC
(
unsupportedICC
)
;
*
codecOut
=
codec
;
}
else
{
SkASSERT
(
nullptr
!
=
decoderMgrOut
)
;
*
decoderMgrOut
=
decoderMgr
.
release
(
)
;
}
return
true
;
}
SkCodec
*
SkJpegCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
return
SkJpegCodec
:
:
NewFromStream
(
stream
SkColorSpace
:
:
MakeSRGB
(
)
)
;
}
SkCodec
*
SkJpegCodec
:
:
NewFromStream
(
SkStream
*
stream
sk_sp
<
SkColorSpace
>
defaultColorSpace
)
{
std
:
:
unique_ptr
<
SkStream
>
streamDeleter
(
stream
)
;
SkCodec
*
codec
=
nullptr
;
if
(
ReadHeader
(
stream
&
codec
nullptr
std
:
:
move
(
defaultColorSpace
)
)
)
{
SkASSERT
(
codec
)
;
streamDeleter
.
release
(
)
;
return
codec
;
}
return
nullptr
;
}
SkJpegCodec
:
:
SkJpegCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
SkStream
*
stream
JpegDecoderMgr
*
decoderMgr
sk_sp
<
SkColorSpace
>
colorSpace
Origin
origin
)
:
INHERITED
(
width
height
info
stream
std
:
:
move
(
colorSpace
)
origin
)
fDecoderMgr
(
decoderMgr
)
fReadyState
(
decoderMgr
-
>
dinfo
(
)
-
>
global_state
)
fSwizzleSrcRow
(
nullptr
)
fColorXformSrcRow
(
nullptr
)
fSwizzlerSubset
(
SkIRect
:
:
MakeEmpty
(
)
)
{
}
static
size_t
get_row_bytes
(
const
j_decompress_ptr
dinfo
)
{
const
size_t
colorBytes
=
(
dinfo
-
>
out_color_space
=
=
JCS_RGB565
)
?
2
:
dinfo
-
>
out_color_components
;
return
dinfo
-
>
output_width
*
colorBytes
;
}
void
calc_output_dimensions
(
jpeg_decompress_struct
*
dinfo
unsigned
int
num
unsigned
int
denom
)
{
dinfo
-
>
num_components
=
0
;
dinfo
-
>
scale_num
=
num
;
dinfo
-
>
scale_denom
=
denom
;
jpeg_calc_output_dimensions
(
dinfo
)
;
}
SkISize
SkJpegCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
unsigned
int
num
;
unsigned
int
denom
=
8
;
if
(
desiredScale
>
=
0
.
9375
)
{
num
=
8
;
}
else
if
(
desiredScale
>
=
0
.
8125
)
{
num
=
7
;
}
else
if
(
desiredScale
>
=
0
.
6875f
)
{
num
=
6
;
}
else
if
(
desiredScale
>
=
0
.
5625f
)
{
num
=
5
;
}
else
if
(
desiredScale
>
=
0
.
4375f
)
{
num
=
4
;
}
else
if
(
desiredScale
>
=
0
.
3125f
)
{
num
=
3
;
}
else
if
(
desiredScale
>
=
0
.
1875f
)
{
num
=
2
;
}
else
{
num
=
1
;
}
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
getInfo
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
getInfo
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
return
SkISize
:
:
Make
(
dinfo
.
output_width
dinfo
.
output_height
)
;
}
bool
SkJpegCodec
:
:
onRewind
(
)
{
JpegDecoderMgr
*
decoderMgr
=
nullptr
;
if
(
!
ReadHeader
(
this
-
>
stream
(
)
nullptr
&
decoderMgr
nullptr
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onRewind
"
)
;
}
SkASSERT
(
nullptr
!
=
decoderMgr
)
;
fDecoderMgr
.
reset
(
decoderMgr
)
;
fSwizzler
.
reset
(
nullptr
)
;
fSwizzleSrcRow
=
nullptr
;
fColorXformSrcRow
=
nullptr
;
fStorage
.
reset
(
)
;
return
true
;
}
bool
SkJpegCodec
:
:
setOutputColorSpace
(
const
SkImageInfo
&
dstInfo
)
{
if
(
kUnknown_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
return
false
;
}
if
(
kOpaque_SkAlphaType
!
=
dstInfo
.
alphaType
(
)
)
{
SkCodecPrintf
(
"
Warning
:
an
opaque
image
should
be
decoded
as
opaque
"
"
-
it
is
being
decoded
as
non
-
opaque
which
will
draw
slower
\
n
"
)
;
}
J_COLOR_SPACE
encodedColorType
=
fDecoderMgr
-
>
dinfo
(
)
-
>
jpeg_color_space
;
bool
isCMYK
=
(
JCS_CMYK
=
=
encodedColorType
|
|
JCS_YCCK
=
=
encodedColorType
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
return
true
;
case
kBGRA_8888_SkColorType
:
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
if
(
this
-
>
colorXform
(
)
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_BGRA
;
}
return
true
;
case
kRGB_565_SkColorType
:
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
if
(
this
-
>
colorXform
(
)
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
dither_mode
=
JDITHER_NONE
;
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_RGB565
;
}
return
true
;
case
kGray_8_SkColorType
:
if
(
this
-
>
colorXform
(
)
|
|
JCS_GRAYSCALE
!
=
encodedColorType
)
{
return
false
;
}
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_GRAYSCALE
;
return
true
;
case
kRGBA_F16_SkColorType
:
SkASSERT
(
this
-
>
colorXform
(
)
)
;
if
(
!
dstInfo
.
colorSpace
(
)
-
>
gammaIsLinear
(
)
)
{
return
false
;
}
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
}
return
true
;
default
:
return
false
;
}
}
bool
SkJpegCodec
:
:
onDimensionsSupported
(
const
SkISize
&
size
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onDimensionsSupported
"
)
;
}
const
unsigned
int
dstWidth
=
size
.
width
(
)
;
const
unsigned
int
dstHeight
=
size
.
height
(
)
;
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
getInfo
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
getInfo
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
unsigned
int
num
=
8
;
const
unsigned
int
denom
=
8
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
while
(
dinfo
.
output_width
!
=
dstWidth
|
|
dinfo
.
output_height
!
=
dstHeight
)
{
if
(
1
=
=
num
|
|
dstWidth
>
dinfo
.
output_width
|
|
dstHeight
>
dinfo
.
output_height
)
{
return
false
;
}
num
-
=
1
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
}
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_num
=
num
;
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_denom
=
denom
;
return
true
;
}
int
SkJpegCodec
:
:
readRows
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
int
count
const
Options
&
opts
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
0
;
}
JSAMPLE
*
decodeDst
=
(
JSAMPLE
*
)
dst
;
uint32_t
*
swizzleDst
=
(
uint32_t
*
)
dst
;
size_t
decodeDstRowBytes
=
rowBytes
;
size_t
swizzleDstRowBytes
=
rowBytes
;
int
dstWidth
=
opts
.
fSubset
?
opts
.
fSubset
-
>
width
(
)
:
dstInfo
.
width
(
)
;
if
(
fSwizzleSrcRow
&
&
fColorXformSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fSwizzleSrcRow
;
swizzleDst
=
fColorXformSrcRow
;
decodeDstRowBytes
=
0
;
swizzleDstRowBytes
=
0
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
}
else
if
(
fColorXformSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fColorXformSrcRow
;
swizzleDst
=
fColorXformSrcRow
;
decodeDstRowBytes
=
0
;
swizzleDstRowBytes
=
0
;
}
else
if
(
fSwizzleSrcRow
)
{
decodeDst
=
(
JSAMPLE
*
)
fSwizzleSrcRow
;
decodeDstRowBytes
=
0
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
}
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
uint32_t
lines
=
jpeg_read_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
&
decodeDst
1
)
;
if
(
0
=
=
lines
)
{
return
y
;
}
if
(
fSwizzler
)
{
fSwizzler
-
>
swizzle
(
swizzleDst
decodeDst
)
;
}
if
(
this
-
>
colorXform
(
)
)
{
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
select_xform_format
(
dstInfo
.
colorType
(
)
)
dst
SkColorSpaceXform
:
:
kRGBA_8888_ColorFormat
swizzleDst
dstWidth
kOpaque_SkAlphaType
)
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
)
;
}
decodeDst
=
SkTAddOffset
<
JSAMPLE
>
(
decodeDst
decodeDstRowBytes
)
;
swizzleDst
=
SkTAddOffset
<
uint32_t
>
(
swizzleDst
swizzleDstRowBytes
)
;
}
return
count
;
}
static
inline
bool
needs_swizzler_to_convert_from_cmyk
(
J_COLOR_SPACE
jpegColorType
const
SkImageInfo
&
srcInfo
bool
hasColorSpaceXform
)
{
if
(
JCS_CMYK
!
=
jpegColorType
)
{
return
false
;
}
bool
hasCMYKColorSpace
=
as_CSB
(
srcInfo
.
colorSpace
(
)
)
-
>
onIsCMYK
(
)
;
return
!
hasCMYKColorSpace
|
|
!
hasColorSpaceXform
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
options
SkPMColor
*
int
*
int
*
rowsDecoded
)
{
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
if
(
!
this
-
>
initializeColorXform
(
dstInfo
options
.
fPremulBehavior
)
)
{
return
kInvalidConversion
;
}
if
(
!
this
-
>
setOutputColorSpace
(
dstInfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setOutputColorSpace
"
kInvalidConversion
)
;
}
if
(
!
jpeg_start_decompress
(
dinfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
startDecompress
"
kInvalidInput
)
;
}
SkASSERT
(
1
=
=
dinfo
-
>
rec_outbuf_height
)
;
if
(
needs_swizzler_to_convert_from_cmyk
(
dinfo
-
>
out_color_space
this
-
>
getInfo
(
)
this
-
>
colorXform
(
)
)
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
true
)
;
}
this
-
>
allocateStorage
(
dstInfo
)
;
int
rows
=
this
-
>
readRows
(
dstInfo
dst
dstRowBytes
dstInfo
.
height
(
)
options
)
;
if
(
rows
<
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
rows
;
return
fDecoderMgr
-
>
returnFailure
(
"
Incomplete
image
data
"
kIncompleteInput
)
;
}
return
kSuccess
;
}
void
SkJpegCodec
:
:
allocateStorage
(
const
SkImageInfo
&
dstInfo
)
{
int
dstWidth
=
dstInfo
.
width
(
)
;
size_t
swizzleBytes
=
0
;
if
(
fSwizzler
)
{
swizzleBytes
=
get_row_bytes
(
fDecoderMgr
-
>
dinfo
(
)
)
;
dstWidth
=
fSwizzler
-
>
swizzleWidth
(
)
;
SkASSERT
(
!
this
-
>
colorXform
(
)
|
|
SkIsAlign4
(
swizzleBytes
)
)
;
}
size_t
xformBytes
=
0
;
if
(
this
-
>
colorXform
(
)
&
&
(
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
|
|
kRGB_565_SkColorType
=
=
dstInfo
.
colorType
(
)
)
)
{
xformBytes
=
dstWidth
*
sizeof
(
uint32_t
)
;
}
size_t
totalBytes
=
swizzleBytes
+
xformBytes
;
if
(
totalBytes
>
0
)
{
fStorage
.
reset
(
totalBytes
)
;
fSwizzleSrcRow
=
(
swizzleBytes
>
0
)
?
fStorage
.
get
(
)
:
nullptr
;
fColorXformSrcRow
=
(
xformBytes
>
0
)
?
SkTAddOffset
<
uint32_t
>
(
fStorage
.
get
(
)
swizzleBytes
)
:
nullptr
;
}
}
void
SkJpegCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
bool
needsCMYKToRGB
)
{
SkEncodedInfo
swizzlerInfo
=
this
-
>
getEncodedInfo
(
)
;
if
(
needsCMYKToRGB
)
{
swizzlerInfo
=
SkEncodedInfo
:
:
Make
(
SkEncodedInfo
:
:
kInvertedCMYK_Color
swizzlerInfo
.
alpha
(
)
swizzlerInfo
.
bitsPerComponent
(
)
)
;
}
Options
swizzlerOptions
=
options
;
if
(
options
.
fSubset
)
{
SkASSERT
(
!
fSwizzlerSubset
.
isEmpty
(
)
&
&
fSwizzlerSubset
.
x
(
)
<
=
options
.
fSubset
-
>
x
(
)
&
&
fSwizzlerSubset
.
width
(
)
=
=
options
.
fSubset
-
>
width
(
)
)
;
swizzlerOptions
.
fSubset
=
&
fSwizzlerSubset
;
}
SkImageInfo
swizzlerDstInfo
=
dstInfo
;
if
(
this
-
>
colorXform
(
)
)
{
swizzlerDstInfo
=
swizzlerDstInfo
.
makeColorType
(
kRGBA_8888_SkColorType
)
;
}
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
swizzlerInfo
nullptr
swizzlerDstInfo
swizzlerOptions
nullptr
!
needsCMYKToRGB
)
)
;
SkASSERT
(
fSwizzler
)
;
}
SkSampler
*
SkJpegCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
!
createIfNecessary
|
|
fSwizzler
)
{
SkASSERT
(
!
fSwizzler
|
|
(
fSwizzleSrcRow
&
&
fStorage
.
get
(
)
=
=
fSwizzleSrcRow
)
)
;
return
fSwizzler
.
get
(
)
;
}
bool
needsCMYKToRGB
=
needs_swizzler_to_convert_from_cmyk
(
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
this
-
>
getInfo
(
)
this
-
>
colorXform
(
)
)
;
this
-
>
initializeSwizzler
(
this
-
>
dstInfo
(
)
this
-
>
options
(
)
needsCMYKToRGB
)
;
this
-
>
allocateStorage
(
this
-
>
dstInfo
(
)
)
;
return
fSwizzler
.
get
(
)
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
SkCodecPrintf
(
"
setjmp
:
Error
from
libjpeg
\
n
"
)
;
return
kInvalidInput
;
}
if
(
!
this
-
>
initializeColorXform
(
dstInfo
options
.
fPremulBehavior
)
)
{
return
kInvalidConversion
;
}
if
(
!
this
-
>
setOutputColorSpace
(
dstInfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setOutputColorSpace
"
kInvalidConversion
)
;
}
if
(
!
jpeg_start_decompress
(
fDecoderMgr
-
>
dinfo
(
)
)
)
{
SkCodecPrintf
(
"
start
decompress
failed
\
n
"
)
;
return
kInvalidInput
;
}
bool
needsCMYKToRGB
=
needs_swizzler_to_convert_from_cmyk
(
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
this
-
>
getInfo
(
)
this
-
>
colorXform
(
)
)
;
if
(
options
.
fSubset
)
{
uint32_t
startX
=
options
.
fSubset
-
>
x
(
)
;
uint32_t
width
=
options
.
fSubset
-
>
width
(
)
;
jpeg_crop_scanline
(
fDecoderMgr
-
>
dinfo
(
)
&
startX
&
width
)
;
SkASSERT
(
startX
<
=
(
uint32_t
)
options
.
fSubset
-
>
x
(
)
)
;
SkASSERT
(
width
>
=
(
uint32_t
)
options
.
fSubset
-
>
width
(
)
)
;
SkASSERT
(
startX
+
width
>
=
(
uint32_t
)
options
.
fSubset
-
>
right
(
)
)
;
fSwizzlerSubset
.
setXYWH
(
options
.
fSubset
-
>
x
(
)
-
startX
0
options
.
fSubset
-
>
width
(
)
options
.
fSubset
-
>
height
(
)
)
;
if
(
startX
!
=
(
uint32_t
)
options
.
fSubset
-
>
x
(
)
|
|
width
!
=
(
uint32_t
)
options
.
fSubset
-
>
width
(
)
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
needsCMYKToRGB
)
;
}
}
if
(
!
fSwizzler
&
&
needsCMYKToRGB
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
true
)
;
}
this
-
>
allocateStorage
(
dstInfo
)
;
return
kSuccess
;
}
int
SkJpegCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
dstRowBytes
)
{
int
rows
=
this
-
>
readRows
(
this
-
>
dstInfo
(
)
dst
dstRowBytes
count
this
-
>
options
(
)
)
;
if
(
rows
<
count
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
output_scanline
=
this
-
>
dstInfo
(
)
.
height
(
)
;
}
return
rows
;
}
bool
SkJpegCodec
:
:
onSkipScanlines
(
int
count
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onSkipScanlines
"
)
;
}
return
(
uint32_t
)
count
=
=
jpeg_skip_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
count
)
;
}
static
bool
is_yuv_supported
(
jpeg_decompress_struct
*
dinfo
)
{
SkASSERT
(
dinfo
-
>
scale_num
=
=
dinfo
-
>
scale_denom
)
;
static_assert
(
8
=
=
DCTSIZE
"
DCTSIZE
(
defined
in
jpeg
library
)
should
always
be
8
.
"
)
;
if
(
JCS_YCbCr
!
=
dinfo
-
>
jpeg_color_space
)
{
return
false
;
}
SkASSERT
(
3
=
=
dinfo
-
>
num_components
)
;
SkASSERT
(
dinfo
-
>
comp_info
)
;
if
(
(
1
!
=
dinfo
-
>
comp_info
[
1
]
.
h_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
1
]
.
v_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
2
]
.
h_samp_factor
)
|
|
(
1
!
=
dinfo
-
>
comp_info
[
2
]
.
v_samp_factor
)
)
{
return
false
;
}
int
hSampY
=
dinfo
-
>
comp_info
[
0
]
.
h_samp_factor
;
int
vSampY
=
dinfo
-
>
comp_info
[
0
]
.
v_samp_factor
;
return
(
1
=
=
hSampY
&
&
1
=
=
vSampY
)
|
|
(
2
=
=
hSampY
&
&
1
=
=
vSampY
)
|
|
(
2
=
=
hSampY
&
&
2
=
=
vSampY
)
|
|
(
1
=
=
hSampY
&
&
2
=
=
vSampY
)
|
|
(
4
=
=
hSampY
&
&
1
=
=
vSampY
)
|
|
(
4
=
=
hSampY
&
&
2
=
=
vSampY
)
;
}
bool
SkJpegCodec
:
:
onQueryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
{
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
if
(
!
is_yuv_supported
(
dinfo
)
)
{
return
false
;
}
sizeInfo
-
>
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
set
(
dinfo
-
>
comp_info
[
0
]
.
downsampled_width
dinfo
-
>
comp_info
[
0
]
.
downsampled_height
)
;
sizeInfo
-
>
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
set
(
dinfo
-
>
comp_info
[
1
]
.
downsampled_width
dinfo
-
>
comp_info
[
1
]
.
downsampled_height
)
;
sizeInfo
-
>
fSizes
[
SkYUVSizeInfo
:
:
kV
]
.
set
(
dinfo
-
>
comp_info
[
2
]
.
downsampled_width
dinfo
-
>
comp_info
[
2
]
.
downsampled_height
)
;
sizeInfo
-
>
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
=
dinfo
-
>
comp_info
[
0
]
.
width_in_blocks
*
DCTSIZE
;
sizeInfo
-
>
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
=
dinfo
-
>
comp_info
[
1
]
.
width_in_blocks
*
DCTSIZE
;
sizeInfo
-
>
fWidthBytes
[
SkYUVSizeInfo
:
:
kV
]
=
dinfo
-
>
comp_info
[
2
]
.
width_in_blocks
*
DCTSIZE
;
if
(
colorSpace
)
{
*
colorSpace
=
kJPEG_SkYUVColorSpace
;
}
return
true
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
{
SkYUVSizeInfo
defaultInfo
;
bool
supportsYUV
=
this
-
>
onQueryYUV8
(
&
defaultInfo
nullptr
)
;
if
(
!
supportsYUV
|
|
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
!
=
defaultInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
|
|
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
!
=
defaultInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
|
|
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kV
]
!
=
defaultInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kV
]
|
|
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
<
defaultInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
|
|
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
<
defaultInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
|
|
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kV
]
<
defaultInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kV
]
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
onGetYUV8Planes
"
kInvalidInput
)
;
}
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
dinfo
-
>
raw_data_out
=
TRUE
;
if
(
!
jpeg_start_decompress
(
dinfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
startDecompress
"
kInvalidInput
)
;
}
SkASSERT
(
is_yuv_supported
(
dinfo
)
)
;
SkASSERT
(
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
=
=
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kV
]
)
;
SkASSERT
(
(
uint32_t
)
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
width
(
)
=
=
dinfo
-
>
output_width
&
&
(
uint32_t
)
sizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
height
(
)
=
=
dinfo
-
>
output_height
)
;
JSAMPARRAY
yuv
[
3
]
;
JSAMPROW
rowptrs
[
2
*
DCTSIZE
+
DCTSIZE
+
DCTSIZE
]
;
yuv
[
0
]
=
&
rowptrs
[
0
]
;
yuv
[
1
]
=
&
rowptrs
[
2
*
DCTSIZE
]
;
yuv
[
2
]
=
&
rowptrs
[
3
*
DCTSIZE
]
;
int
numYRowsPerBlock
=
DCTSIZE
*
dinfo
-
>
comp_info
[
0
]
.
v_samp_factor
;
for
(
int
i
=
0
;
i
<
numYRowsPerBlock
;
i
+
+
)
{
rowptrs
[
i
]
=
SkTAddOffset
<
JSAMPLE
>
(
planes
[
SkYUVSizeInfo
:
:
kY
]
i
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
)
;
}
for
(
int
i
=
0
;
i
<
DCTSIZE
;
i
+
+
)
{
rowptrs
[
i
+
2
*
DCTSIZE
]
=
SkTAddOffset
<
JSAMPLE
>
(
planes
[
SkYUVSizeInfo
:
:
kU
]
i
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
)
;
rowptrs
[
i
+
3
*
DCTSIZE
]
=
SkTAddOffset
<
JSAMPLE
>
(
planes
[
SkYUVSizeInfo
:
:
kV
]
i
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kV
]
)
;
}
size_t
blockIncrementY
=
numYRowsPerBlock
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
;
size_t
blockIncrementU
=
DCTSIZE
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
;
size_t
blockIncrementV
=
DCTSIZE
*
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kV
]
;
uint32_t
numRowsPerBlock
=
numYRowsPerBlock
;
const
int
numIters
=
dinfo
-
>
output_height
/
numRowsPerBlock
;
for
(
int
i
=
0
;
i
<
numIters
;
i
+
+
)
{
JDIMENSION
linesRead
=
jpeg_read_raw_data
(
dinfo
yuv
numRowsPerBlock
)
;
if
(
linesRead
<
numRowsPerBlock
)
{
return
kInvalidInput
;
}
for
(
int
i
=
0
;
i
<
numYRowsPerBlock
;
i
+
+
)
{
rowptrs
[
i
]
+
=
blockIncrementY
;
}
for
(
int
i
=
0
;
i
<
DCTSIZE
;
i
+
+
)
{
rowptrs
[
i
+
2
*
DCTSIZE
]
+
=
blockIncrementU
;
rowptrs
[
i
+
3
*
DCTSIZE
]
+
=
blockIncrementV
;
}
}
uint32_t
remainingRows
=
dinfo
-
>
output_height
-
dinfo
-
>
output_scanline
;
SkASSERT
(
remainingRows
=
=
dinfo
-
>
output_height
%
numRowsPerBlock
)
;
SkASSERT
(
dinfo
-
>
output_scanline
=
=
numIters
*
numRowsPerBlock
)
;
if
(
remainingRows
>
0
)
{
SkAutoTMalloc
<
JSAMPLE
>
dummyRow
(
sizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
)
;
for
(
int
i
=
remainingRows
;
i
<
numYRowsPerBlock
;
i
+
+
)
{
rowptrs
[
i
]
=
dummyRow
.
get
(
)
;
}
int
remainingUVRows
=
dinfo
-
>
comp_info
[
1
]
.
downsampled_height
-
DCTSIZE
*
numIters
;
for
(
int
i
=
remainingUVRows
;
i
<
DCTSIZE
;
i
+
+
)
{
rowptrs
[
i
+
2
*
DCTSIZE
]
=
dummyRow
.
get
(
)
;
rowptrs
[
i
+
3
*
DCTSIZE
]
=
dummyRow
.
get
(
)
;
}
JDIMENSION
linesRead
=
jpeg_read_raw_data
(
dinfo
yuv
numRowsPerBlock
)
;
if
(
linesRead
<
remainingRows
)
{
return
kInvalidInput
;
}
}
return
kSuccess
;
}
