#
include
"
SkCodec
.
h
"
#
include
"
SkJpegCodec
.
h
"
#
include
"
SkJpegDecoderMgr
.
h
"
#
include
"
SkJpegUtility_codec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
stdio
.
h
>
extern
"
C
"
{
#
include
"
jerror
.
h
"
#
include
"
jpeglib
.
h
"
}
bool
SkJpegCodec
:
:
IsJpeg
(
const
void
*
buffer
size_t
bytesRead
)
{
static
const
uint8_t
jpegSig
[
]
=
{
0xFF
0xD8
0xFF
}
;
return
bytesRead
>
=
3
&
&
!
memcmp
(
buffer
jpegSig
sizeof
(
jpegSig
)
)
;
}
bool
SkJpegCodec
:
:
ReadHeader
(
SkStream
*
stream
SkCodec
*
*
codecOut
JpegDecoderMgr
*
*
decoderMgrOut
)
{
SkAutoTDelete
<
JpegDecoderMgr
>
decoderMgr
(
new
JpegDecoderMgr
(
stream
)
)
;
if
(
setjmp
(
decoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
decoderMgr
-
>
returnFalse
(
"
setjmp
"
)
;
}
decoderMgr
-
>
init
(
)
;
if
(
JPEG_HEADER_OK
!
=
jpeg_read_header
(
decoderMgr
-
>
dinfo
(
)
true
)
)
{
return
decoderMgr
-
>
returnFalse
(
"
read_header
"
)
;
}
if
(
nullptr
!
=
codecOut
)
{
const
SkColorType
colorType
=
decoderMgr
-
>
getColorType
(
)
;
const
SkImageInfo
&
imageInfo
=
SkImageInfo
:
:
Make
(
decoderMgr
-
>
dinfo
(
)
-
>
image_width
decoderMgr
-
>
dinfo
(
)
-
>
image_height
colorType
kOpaque_SkAlphaType
)
;
*
codecOut
=
new
SkJpegCodec
(
imageInfo
stream
decoderMgr
.
detach
(
)
)
;
}
else
{
SkASSERT
(
nullptr
!
=
decoderMgrOut
)
;
*
decoderMgrOut
=
decoderMgr
.
detach
(
)
;
}
return
true
;
}
SkCodec
*
SkJpegCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
SkCodec
*
codec
=
nullptr
;
if
(
ReadHeader
(
stream
&
codec
nullptr
)
)
{
SkASSERT
(
codec
)
;
streamDeleter
.
detach
(
)
;
return
codec
;
}
return
nullptr
;
}
SkJpegCodec
:
:
SkJpegCodec
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
JpegDecoderMgr
*
decoderMgr
)
:
INHERITED
(
srcInfo
stream
)
fDecoderMgr
(
decoderMgr
)
fReadyState
(
decoderMgr
-
>
dinfo
(
)
-
>
global_state
)
{
}
static
int
get_row_bytes
(
const
j_decompress_ptr
dinfo
)
{
int
colorBytes
=
(
dinfo
-
>
out_color_space
=
=
JCS_RGB565
)
?
2
:
dinfo
-
>
out_color_components
;
return
dinfo
-
>
output_width
*
colorBytes
;
}
void
calc_output_dimensions
(
jpeg_decompress_struct
*
dinfo
unsigned
int
num
unsigned
int
denom
)
{
dinfo
-
>
num_components
=
0
;
dinfo
-
>
scale_num
=
num
;
dinfo
-
>
scale_denom
=
denom
;
jpeg_calc_output_dimensions
(
dinfo
)
;
}
SkISize
SkJpegCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
unsigned
int
num
;
unsigned
int
denom
=
8
;
if
(
desiredScale
>
=
0
.
9375
)
{
num
=
8
;
}
else
if
(
desiredScale
>
=
0
.
8125
)
{
num
=
7
;
}
else
if
(
desiredScale
>
=
0
.
6875f
)
{
num
=
6
;
}
else
if
(
desiredScale
>
=
0
.
5625f
)
{
num
=
5
;
}
else
if
(
desiredScale
>
=
0
.
4375f
)
{
num
=
4
;
}
else
if
(
desiredScale
>
=
0
.
3125f
)
{
num
=
3
;
}
else
if
(
desiredScale
>
=
0
.
1875f
)
{
num
=
2
;
}
else
{
num
=
1
;
}
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
getInfo
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
getInfo
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
return
SkISize
:
:
Make
(
dinfo
.
output_width
dinfo
.
output_height
)
;
}
bool
SkJpegCodec
:
:
onRewind
(
)
{
JpegDecoderMgr
*
decoderMgr
=
nullptr
;
if
(
!
ReadHeader
(
this
-
>
stream
(
)
nullptr
&
decoderMgr
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
could
not
rewind
"
)
;
}
SkASSERT
(
nullptr
!
=
decoderMgr
)
;
fDecoderMgr
.
reset
(
decoderMgr
)
;
return
true
;
}
bool
SkJpegCodec
:
:
setOutputColorSpace
(
const
SkImageInfo
&
dst
)
{
const
SkImageInfo
&
src
=
this
-
>
getInfo
(
)
;
if
(
dst
.
profileType
(
)
!
=
src
.
profileType
(
)
)
{
return
false
;
}
if
(
kOpaque_SkAlphaType
!
=
dst
.
alphaType
(
)
)
{
return
false
;
}
J_COLOR_SPACE
colorSpace
=
fDecoderMgr
-
>
dinfo
(
)
-
>
jpeg_color_space
;
bool
isCMYK
=
JCS_CMYK
=
=
colorSpace
|
|
JCS_YCCK
=
=
colorSpace
;
switch
(
dst
.
colorType
(
)
)
{
case
kN32_SkColorType
:
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
{
#
if
defined
(
SK_PMCOLOR_IS_RGBA
)
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_RGBA
;
#
else
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_EXT_BGRA
;
#
endif
}
return
true
;
case
kRGB_565_SkColorType
:
if
(
isCMYK
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_CMYK
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
dither_mode
=
JDITHER_NONE
;
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_RGB565
;
}
return
true
;
case
kGray_8_SkColorType
:
if
(
isCMYK
)
{
return
false
;
}
else
{
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
=
JCS_GRAYSCALE
;
}
return
true
;
default
:
return
false
;
}
}
bool
SkJpegCodec
:
:
onDimensionsSupported
(
const
SkISize
&
size
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
onDimensionsSupported
/
setjmp
"
)
;
}
const
unsigned
int
dstWidth
=
size
.
width
(
)
;
const
unsigned
int
dstHeight
=
size
.
height
(
)
;
jpeg_decompress_struct
dinfo
;
sk_bzero
(
&
dinfo
sizeof
(
dinfo
)
)
;
dinfo
.
image_width
=
this
-
>
getInfo
(
)
.
width
(
)
;
dinfo
.
image_height
=
this
-
>
getInfo
(
)
.
height
(
)
;
dinfo
.
global_state
=
fReadyState
;
unsigned
int
num
=
8
;
const
unsigned
int
denom
=
8
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
while
(
dinfo
.
output_width
!
=
dstWidth
|
|
dinfo
.
output_height
!
=
dstHeight
)
{
if
(
1
=
=
num
|
|
dstWidth
>
dinfo
.
output_width
|
|
dstHeight
>
dinfo
.
output_height
)
{
return
false
;
}
num
-
=
1
;
calc_output_dimensions
(
&
dinfo
num
denom
)
;
}
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_num
=
num
;
fDecoderMgr
-
>
dinfo
(
)
-
>
scale_denom
=
denom
;
return
true
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
options
SkPMColor
*
int
*
int
*
rowsDecoded
)
{
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
jpeg_decompress_struct
*
dinfo
=
fDecoderMgr
-
>
dinfo
(
)
;
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
if
(
!
this
-
>
setOutputColorSpace
(
dstInfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
conversion_possible
"
kInvalidConversion
)
;
}
if
(
!
jpeg_start_decompress
(
dinfo
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
startDecompress
"
kInvalidInput
)
;
}
SkASSERT
(
1
=
=
dinfo
-
>
rec_outbuf_height
)
;
if
(
JCS_CMYK
=
=
dinfo
-
>
out_color_space
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
)
;
}
uint32_t
dstHeight
=
dstInfo
.
height
(
)
;
JSAMPLE
*
dstRow
;
if
(
fSwizzler
)
{
dstRow
=
fSrcRow
;
}
else
{
dstRow
=
(
JSAMPLE
*
)
dst
;
}
for
(
uint32_t
y
=
0
;
y
<
dstHeight
;
y
+
+
)
{
uint32_t
lines
=
jpeg_read_scanlines
(
dinfo
&
dstRow
1
)
;
if
(
lines
!
=
1
)
{
*
rowsDecoded
=
y
;
return
fDecoderMgr
-
>
returnFailure
(
"
Incomplete
image
data
"
kIncompleteInput
)
;
}
if
(
fSwizzler
)
{
fSwizzler
-
>
swizzle
(
dst
dstRow
)
;
dst
=
SkTAddOffset
<
JSAMPLE
>
(
dst
dstRowBytes
)
;
}
else
{
dstRow
=
SkTAddOffset
<
JSAMPLE
>
(
dstRow
dstRowBytes
)
;
}
}
return
kSuccess
;
}
void
SkJpegCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
)
{
SkSwizzler
:
:
SrcConfig
srcConfig
=
SkSwizzler
:
:
kUnknown
;
if
(
JCS_CMYK
=
=
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
)
{
srcConfig
=
SkSwizzler
:
:
kCMYK
;
}
else
{
switch
(
dstInfo
.
colorType
(
)
)
{
case
kGray_8_SkColorType
:
srcConfig
=
SkSwizzler
:
:
kGray
;
break
;
case
kRGBA_8888_SkColorType
:
srcConfig
=
SkSwizzler
:
:
kRGBX
;
break
;
case
kBGRA_8888_SkColorType
:
srcConfig
=
SkSwizzler
:
:
kBGRX
;
break
;
case
kRGB_565_SkColorType
:
srcConfig
=
SkSwizzler
:
:
kRGB_565
;
break
;
default
:
SkASSERT
(
false
)
;
}
}
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
srcConfig
nullptr
dstInfo
options
)
)
;
fStorage
.
reset
(
get_row_bytes
(
fDecoderMgr
-
>
dinfo
(
)
)
)
;
fSrcRow
=
fStorage
.
get
(
)
;
}
SkSampler
*
SkJpegCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
!
createIfNecessary
|
|
fSwizzler
)
{
SkASSERT
(
!
fSwizzler
|
|
(
fSrcRow
&
&
fStorage
.
get
(
)
=
=
fSrcRow
)
)
;
return
fSwizzler
;
}
this
-
>
initializeSwizzler
(
this
-
>
dstInfo
(
)
this
-
>
options
(
)
)
;
return
fSwizzler
;
}
SkCodec
:
:
Result
SkJpegCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
SkCodecPrintf
(
"
setjmp
:
Error
from
libjpeg
\
n
"
)
;
return
kInvalidInput
;
}
if
(
!
this
-
>
setOutputColorSpace
(
dstInfo
)
)
{
return
kInvalidConversion
;
}
fSwizzler
.
reset
(
nullptr
)
;
fSrcRow
=
nullptr
;
fStorage
.
free
(
)
;
if
(
!
jpeg_start_decompress
(
fDecoderMgr
-
>
dinfo
(
)
)
)
{
SkCodecPrintf
(
"
start
decompress
failed
\
n
"
)
;
return
kInvalidInput
;
}
if
(
options
.
fSubset
|
|
JCS_CMYK
=
=
fDecoderMgr
-
>
dinfo
(
)
-
>
out_color_space
)
{
this
-
>
initializeSwizzler
(
dstInfo
options
)
;
}
return
kSuccess
;
}
int
SkJpegCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFailure
(
"
setjmp
"
kInvalidInput
)
;
}
JSAMPLE
*
dstRow
;
if
(
fSwizzler
)
{
dstRow
=
fSrcRow
;
}
else
{
dstRow
=
(
JSAMPLE
*
)
dst
;
}
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
uint32_t
rowsDecoded
=
jpeg_read_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
&
dstRow
1
)
;
if
(
rowsDecoded
!
=
1
)
{
fDecoderMgr
-
>
dinfo
(
)
-
>
output_scanline
=
this
-
>
dstInfo
(
)
.
height
(
)
;
return
y
;
}
if
(
fSwizzler
)
{
fSwizzler
-
>
swizzle
(
dst
dstRow
)
;
dst
=
SkTAddOffset
<
JSAMPLE
>
(
dst
rowBytes
)
;
}
else
{
dstRow
=
SkTAddOffset
<
JSAMPLE
>
(
dstRow
rowBytes
)
;
}
}
return
count
;
}
#
ifndef
TURBO_HAS_SKIP
static
uint32_t
jpeg_skip_scanlines
(
jpeg_decompress_struct
*
dinfo
int
count
)
{
SkAutoTMalloc
<
uint8_t
>
storage
(
get_row_bytes
(
dinfo
)
)
;
uint8_t
*
storagePtr
=
storage
.
get
(
)
;
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
if
(
1
!
=
jpeg_read_scanlines
(
dinfo
&
storagePtr
1
)
)
{
return
y
;
}
}
return
count
;
}
#
endif
bool
SkJpegCodec
:
:
onSkipScanlines
(
int
count
)
{
if
(
setjmp
(
fDecoderMgr
-
>
getJmpBuf
(
)
)
)
{
return
fDecoderMgr
-
>
returnFalse
(
"
setjmp
"
)
;
}
return
(
uint32_t
)
count
=
=
jpeg_skip_scanlines
(
fDecoderMgr
-
>
dinfo
(
)
count
)
;
}
