#
include
"
src
/
codec
/
SkJpegMetadataDecoderImpl
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
memory
>
#
include
<
utility
>
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
SkExif
.
h
"
#
include
"
include
/
private
/
SkGainmapInfo
.
h
"
#
include
"
include
/
private
/
SkXmp
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
codec
/
SkJpegMultiPicture
.
h
"
#
include
"
src
/
codec
/
SkJpegSegmentScan
.
h
"
#
include
"
src
/
codec
/
SkJpegSourceMgr
.
h
"
#
include
"
src
/
codec
/
SkJpegXmp
.
h
"
#
else
struct
SkGainmapInfo
;
#
endif
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
std
:
:
unique_ptr
<
SkXmp
>
SkJpegMetadataDecoderImpl
:
:
getXmpMetadata
(
)
const
{
std
:
:
vector
<
sk_sp
<
SkData
>
>
decoderApp1Params
;
for
(
const
auto
&
marker
:
fMarkerList
)
{
if
(
marker
.
fMarker
=
=
kXMPMarker
)
{
decoderApp1Params
.
push_back
(
marker
.
fData
)
;
}
}
return
SkJpegMakeXmp
(
decoderApp1Params
)
;
}
static
std
:
:
unique_ptr
<
SkJpegMultiPictureParameters
>
find_mp_params
(
const
SkJpegMarkerList
&
markerList
SkJpegSourceMgr
*
sourceMgr
SkJpegSegment
*
outMpParamsSegment
)
{
std
:
:
unique_ptr
<
SkJpegMultiPictureParameters
>
mpParams
;
size_t
skippedSegmentCount
=
0
;
for
(
const
auto
&
marker
:
markerList
)
{
if
(
marker
.
fMarker
!
=
kMpfMarker
)
{
continue
;
}
mpParams
=
SkJpegMultiPictureParameters
:
:
Make
(
marker
.
fData
)
;
if
(
mpParams
)
{
break
;
}
+
+
skippedSegmentCount
;
}
if
(
!
mpParams
)
{
return
nullptr
;
}
if
(
!
sourceMgr
)
{
SkASSERT
(
!
outMpParamsSegment
)
;
return
mpParams
;
}
for
(
const
auto
&
segment
:
sourceMgr
-
>
getAllSegments
(
)
)
{
if
(
segment
.
marker
!
=
kMpfMarker
)
{
continue
;
}
if
(
skippedSegmentCount
=
=
0
)
{
*
outMpParamsSegment
=
segment
;
return
mpParams
;
}
skippedSegmentCount
-
-
;
}
return
nullptr
;
}
static
bool
extract_gainmap
(
SkJpegSourceMgr
*
decoderSource
size_t
offset
size_t
size
bool
baseImageHasIsoVersion
bool
baseImageHasAdobeXmp
std
:
:
optional
<
float
>
baseImageAppleHdrHeadroom
SkGainmapInfo
&
outInfo
sk_sp
<
SkData
>
&
outData
)
{
bool
imageDataWasCopied
=
false
;
auto
imageData
=
decoderSource
-
>
getSubsetData
(
offset
size
&
imageDataWasCopied
)
;
if
(
!
imageData
)
{
SkCodecPrintf
(
"
Failed
to
extract
MP
image
.
\
n
"
)
;
return
false
;
}
SkJpegMetadataDecoderImpl
metadataDecoder
(
imageData
)
;
bool
didPopulateInfo
=
false
;
SkGainmapInfo
info
;
if
(
baseImageHasIsoVersion
)
{
didPopulateInfo
=
SkGainmapInfo
:
:
Parse
(
metadataDecoder
.
getISOGainmapMetadata
(
false
)
.
get
(
)
info
)
;
if
(
didPopulateInfo
&
&
info
.
fGainmapMathColorSpace
)
{
auto
iccData
=
metadataDecoder
.
getICCProfileData
(
false
)
;
skcms_ICCProfile
iccProfile
;
if
(
iccData
&
&
skcms_Parse
(
iccData
-
>
data
(
)
iccData
-
>
size
(
)
&
iccProfile
)
)
{
auto
iccProfileSpace
=
SkColorSpace
:
:
Make
(
iccProfile
)
;
if
(
iccProfileSpace
)
{
info
.
fGainmapMathColorSpace
=
std
:
:
move
(
iccProfileSpace
)
;
}
}
}
}
if
(
!
didPopulateInfo
)
{
auto
xmp
=
metadataDecoder
.
getXmpMetadata
(
)
;
if
(
!
xmp
)
{
return
false
;
}
if
(
!
didPopulateInfo
&
&
baseImageHasAdobeXmp
)
{
didPopulateInfo
=
xmp
-
>
getGainmapInfoAdobe
(
&
info
)
;
}
if
(
!
didPopulateInfo
&
&
baseImageAppleHdrHeadroom
.
has_value
(
)
)
{
didPopulateInfo
=
xmp
-
>
getGainmapInfoApple
(
baseImageAppleHdrHeadroom
.
value
(
)
&
info
)
;
}
}
if
(
!
didPopulateInfo
)
{
return
false
;
}
outInfo
=
info
;
if
(
imageDataWasCopied
)
{
outData
=
imageData
;
}
else
{
outData
=
SkData
:
:
MakeWithCopy
(
imageData
-
>
data
(
)
imageData
-
>
size
(
)
)
;
}
return
true
;
}
#
endif
bool
SkJpegMetadataDecoderImpl
:
:
findGainmapImage
(
SkJpegSourceMgr
*
sourceMgr
sk_sp
<
SkData
>
&
outData
SkGainmapInfo
&
outInfo
)
const
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
SkExif
:
:
Metadata
baseExif
;
SkExif
:
:
Parse
(
baseExif
getExifMetadata
(
false
)
.
get
(
)
)
;
auto
xmp
=
getXmpMetadata
(
)
;
bool
isoGainmapPresent
=
SkGainmapInfo
:
:
ParseVersion
(
getISOGainmapMetadata
(
false
)
.
get
(
)
)
;
bool
adobeGainmapPresent
=
xmp
&
&
xmp
-
>
getGainmapInfoAdobe
(
nullptr
)
;
size_t
containerGainmapOffset
=
0
;
size_t
containerGainmapSize
=
0
;
if
(
xmp
&
&
xmp
-
>
getContainerGainmapLocation
(
&
containerGainmapOffset
&
containerGainmapSize
)
)
{
const
auto
&
segments
=
sourceMgr
-
>
getAllSegments
(
)
;
if
(
!
segments
.
empty
(
)
)
{
const
auto
&
lastSegment
=
segments
.
back
(
)
;
if
(
lastSegment
.
marker
=
=
kJpegMarkerEndOfImage
)
{
containerGainmapOffset
+
=
lastSegment
.
offset
+
kJpegMarkerCodeSize
;
}
}
}
SkJpegSegment
mpParamsSegment
;
auto
mpParams
=
find_mp_params
(
fMarkerList
sourceMgr
&
mpParamsSegment
)
;
if
(
mpParams
)
{
for
(
size_t
mpImageIndex
=
1
;
mpImageIndex
<
mpParams
-
>
images
.
size
(
)
;
+
+
mpImageIndex
)
{
size_t
mpImageOffset
=
SkJpegMultiPictureParameters
:
:
GetImageAbsoluteOffset
(
mpParams
-
>
images
[
mpImageIndex
]
.
dataOffset
mpParamsSegment
.
offset
)
;
size_t
mpImageSize
=
mpParams
-
>
images
[
mpImageIndex
]
.
size
;
if
(
extract_gainmap
(
sourceMgr
mpImageOffset
mpImageSize
isoGainmapPresent
adobeGainmapPresent
baseExif
.
fHdrHeadroom
outInfo
outData
)
)
{
if
(
containerGainmapOffset
)
{
SkASSERT
(
containerGainmapOffset
=
=
mpImageOffset
)
;
SkASSERT
(
containerGainmapSize
=
=
mpImageSize
)
;
}
return
true
;
}
}
}
if
(
containerGainmapOffset
)
{
if
(
extract_gainmap
(
sourceMgr
containerGainmapOffset
containerGainmapSize
false
adobeGainmapPresent
std
:
:
nullopt
outInfo
outData
)
)
{
return
true
;
}
SkCodecPrintf
(
"
Failed
to
extract
container
-
specified
gainmap
.
\
n
"
)
;
}
#
endif
return
false
;
}
static
bool
marker_has_signature
(
const
SkJpegMarker
&
marker
const
uint32_t
targetMarker
const
uint8_t
*
signature
size_t
signatureSize
)
{
if
(
targetMarker
!
=
marker
.
fMarker
)
{
return
false
;
}
if
(
marker
.
fData
-
>
size
(
)
<
=
signatureSize
)
{
return
false
;
}
if
(
memcmp
(
marker
.
fData
-
>
bytes
(
)
signature
signatureSize
)
!
=
0
)
{
return
false
;
}
return
true
;
}
static
sk_sp
<
SkData
>
read_metadata
(
const
SkJpegMarkerList
&
markerList
const
uint32_t
targetMarker
const
uint8_t
*
signature
size_t
signatureSize
size_t
signaturePadding
size_t
bytesInIndex
bool
alwaysCopyData
)
{
const
size_t
headerSize
=
signatureSize
+
signaturePadding
+
2
*
bytesInIndex
;
std
:
:
vector
<
sk_sp
<
SkData
>
>
parts
;
size_t
partsTotalSize
=
0
;
uint32_t
foundPartCount
=
0
;
uint32_t
expectedPartCount
=
0
;
for
(
const
auto
&
marker
:
markerList
)
{
if
(
!
marker_has_signature
(
marker
targetMarker
signature
signatureSize
)
)
{
continue
;
}
const
size_t
dataLength
=
marker
.
fData
-
>
size
(
)
;
if
(
dataLength
<
=
headerSize
)
{
continue
;
}
const
uint8_t
*
data
=
marker
.
fData
-
>
bytes
(
)
;
uint32_t
partIndex
=
0
;
uint32_t
partCount
=
0
;
if
(
bytesInIndex
=
=
0
)
{
partIndex
=
1
;
partCount
=
1
;
}
else
{
for
(
size_t
i
=
0
;
i
<
bytesInIndex
;
+
+
i
)
{
const
size_t
offset
=
signatureSize
+
signaturePadding
;
partIndex
=
(
partIndex
<
<
8
)
+
data
[
offset
+
i
]
;
partCount
=
(
partCount
<
<
8
)
+
data
[
offset
+
bytesInIndex
+
i
]
;
}
}
if
(
!
partCount
)
{
SkCodecPrintf
(
"
Invalid
marker
part
count
zero
\
n
"
)
;
return
nullptr
;
}
if
(
partIndex
<
=
0
|
|
partIndex
>
partCount
)
{
SkCodecPrintf
(
"
Invalid
marker
index
%
u
for
count
%
u
\
n
"
partIndex
partCount
)
;
return
nullptr
;
}
if
(
expectedPartCount
=
=
0
)
{
expectedPartCount
=
partCount
;
parts
.
resize
(
expectedPartCount
)
;
}
if
(
partCount
!
=
expectedPartCount
)
{
SkCodecPrintf
(
"
Conflicting
marker
counts
%
u
vs
%
u
\
n
"
partCount
expectedPartCount
)
;
return
nullptr
;
}
auto
partData
=
SkData
:
:
MakeWithoutCopy
(
data
+
headerSize
dataLength
-
headerSize
)
;
if
(
parts
[
partIndex
-
1
]
)
{
SkCodecPrintf
(
"
Duplicate
parts
for
index
%
u
of
%
u
\
n
"
partIndex
expectedPartCount
)
;
return
nullptr
;
}
partsTotalSize
+
=
partData
-
>
size
(
)
;
parts
[
partIndex
-
1
]
=
std
:
:
move
(
partData
)
;
foundPartCount
+
=
1
;
if
(
foundPartCount
=
=
expectedPartCount
)
{
break
;
}
}
if
(
expectedPartCount
=
=
0
)
{
return
nullptr
;
}
if
(
foundPartCount
!
=
expectedPartCount
)
{
SkCodecPrintf
(
"
Incomplete
set
of
markers
(
expected
%
u
got
%
u
)
\
n
"
expectedPartCount
foundPartCount
)
;
return
nullptr
;
}
if
(
!
alwaysCopyData
&
&
expectedPartCount
=
=
1
)
{
return
std
:
:
move
(
parts
[
0
]
)
;
}
auto
result
=
SkData
:
:
MakeUninitialized
(
partsTotalSize
)
;
void
*
copyDest
=
result
-
>
writable_data
(
)
;
for
(
const
auto
&
part
:
parts
)
{
memcpy
(
copyDest
part
-
>
data
(
)
part
-
>
size
(
)
)
;
copyDest
=
SkTAddOffset
<
void
>
(
copyDest
part
-
>
size
(
)
)
;
}
return
result
;
}
SkJpegMetadataDecoderImpl
:
:
SkJpegMetadataDecoderImpl
(
SkJpegMarkerList
markerList
)
:
fMarkerList
(
std
:
:
move
(
markerList
)
)
{
}
SkJpegMetadataDecoderImpl
:
:
SkJpegMetadataDecoderImpl
(
sk_sp
<
SkData
>
data
)
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
SkJpegSegmentScanner
scan
(
kJpegMarkerStartOfScan
)
;
scan
.
onBytes
(
data
-
>
data
(
)
data
-
>
size
(
)
)
;
if
(
scan
.
hadError
(
)
|
|
!
scan
.
isDone
(
)
)
{
SkCodecPrintf
(
"
Failed
to
scan
header
of
MP
image
.
\
n
"
)
;
return
;
}
for
(
const
auto
&
segment
:
scan
.
getSegments
(
)
)
{
if
(
segment
.
marker
!
=
kJpegMarkerAPP0
+
1
&
&
segment
.
marker
!
=
kJpegMarkerAPP0
+
2
)
{
continue
;
}
auto
parameters
=
SkJpegSegmentScanner
:
:
GetParameters
(
data
.
get
(
)
segment
)
;
if
(
!
parameters
)
{
continue
;
}
fMarkerList
.
emplace_back
(
segment
.
marker
std
:
:
move
(
parameters
)
)
;
}
#
endif
}
sk_sp
<
SkData
>
SkJpegMetadataDecoderImpl
:
:
getExifMetadata
(
bool
copyData
)
const
{
return
read_metadata
(
fMarkerList
kExifMarker
kExifSig
sizeof
(
kExifSig
)
1
0
copyData
)
;
}
sk_sp
<
SkData
>
SkJpegMetadataDecoderImpl
:
:
getICCProfileData
(
bool
copyData
)
const
{
return
read_metadata
(
fMarkerList
kICCMarker
kICCSig
sizeof
(
kICCSig
)
0
kICCMarkerIndexSize
copyData
)
;
}
sk_sp
<
SkData
>
SkJpegMetadataDecoderImpl
:
:
getISOGainmapMetadata
(
bool
copyData
)
const
{
return
read_metadata
(
fMarkerList
kISOGainmapMarker
kISOGainmapSig
sizeof
(
kISOGainmapSig
)
0
0
copyData
)
;
}
bool
SkJpegMetadataDecoderImpl
:
:
mightHaveGainmapImage
(
)
const
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
return
find_mp_params
(
fMarkerList
nullptr
nullptr
)
!
=
nullptr
;
#
else
return
false
;
#
endif
}
bool
SkJpegMetadataDecoderImpl
:
:
findGainmapImage
(
sk_sp
<
SkData
>
baseImageData
sk_sp
<
SkData
>
&
outGainmapImageData
SkGainmapInfo
&
outGainmapInfo
)
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
auto
baseImageStream
=
SkMemoryStream
:
:
Make
(
baseImageData
)
;
auto
sourceMgr
=
SkJpegSourceMgr
:
:
Make
(
baseImageStream
.
get
(
)
)
;
return
findGainmapImage
(
sourceMgr
.
get
(
)
outGainmapImageData
outGainmapInfo
)
;
#
else
return
false
;
#
endif
}
std
:
:
unique_ptr
<
SkJpegMetadataDecoder
>
SkJpegMetadataDecoder
:
:
Make
(
std
:
:
vector
<
Segment
>
segments
)
{
return
std
:
:
make_unique
<
SkJpegMetadataDecoderImpl
>
(
std
:
:
move
(
segments
)
)
;
}
std
:
:
unique_ptr
<
SkJpegMetadataDecoder
>
SkJpegMetadataDecoder
:
:
Make
(
sk_sp
<
SkData
>
data
)
{
return
std
:
:
make_unique
<
SkJpegMetadataDecoderImpl
>
(
std
:
:
move
(
data
)
)
;
}
