#
include
"
SkBmpStandardCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkStream
.
h
"
SkBmpStandardCodec
:
:
SkBmpStandardCodec
(
const
SkImageInfo
&
info
SkStream
*
stream
uint16_t
bitsPerPixel
uint32_t
numColors
uint32_t
bytesPerColor
uint32_t
offset
SkCodec
:
:
SkScanlineOrder
rowOrder
bool
inIco
)
:
INHERITED
(
info
stream
bitsPerPixel
rowOrder
)
fColorTable
(
nullptr
)
fNumColors
(
numColors
)
fBytesPerColor
(
bytesPerColor
)
fOffset
(
offset
)
fSwizzler
(
nullptr
)
fSrcRowBytes
(
SkAlign4
(
compute_row_bytes
(
this
-
>
getInfo
(
)
.
width
(
)
this
-
>
bitsPerPixel
(
)
)
)
)
fSrcBuffer
(
new
uint8_t
[
fSrcRowBytes
]
)
fInIco
(
inIco
)
fAndMaskRowBytes
(
fInIco
?
SkAlign4
(
compute_row_bytes
(
this
-
>
getInfo
(
)
.
width
(
)
1
)
)
:
0
)
{
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
if
(
dstInfo
.
dimensions
(
)
!
=
this
-
>
getInfo
(
)
.
dimensions
(
)
)
{
SkCodecPrintf
(
"
Error
:
scaling
not
supported
.
\
n
"
)
;
return
kInvalidScale
;
}
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
convert
input
type
to
output
type
.
\
n
"
)
;
return
kInvalidConversion
;
}
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
opts
inputColorPtr
inputColorCount
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
int
rows
=
this
-
>
decodeRows
(
dstInfo
dst
dstRowBytes
opts
)
;
if
(
rows
!
=
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
rows
;
return
kIncompleteInput
;
}
return
kSuccess
;
}
bool
SkBmpStandardCodec
:
:
createColorTable
(
SkAlphaType
alphaType
int
*
numColors
)
{
uint32_t
colorBytes
=
0
;
SkPMColor
colorTable
[
256
]
;
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
uint32_t
maxColors
=
1
<
<
this
-
>
bitsPerPixel
(
)
;
if
(
nullptr
!
=
numColors
)
{
*
numColors
=
maxColors
;
}
const
uint32_t
numColorsToRead
=
fNumColors
=
=
0
?
maxColors
:
SkTMin
(
fNumColors
maxColors
)
;
colorBytes
=
numColorsToRead
*
fBytesPerColor
;
SkAutoTDeleteArray
<
uint8_t
>
cBuffer
(
new
uint8_t
[
colorBytes
]
)
;
if
(
stream
(
)
-
>
read
(
cBuffer
.
get
(
)
colorBytes
)
!
=
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
color
table
.
\
n
"
)
;
return
false
;
}
SkPMColor
(
*
packARGB
)
(
uint32_t
uint32_t
uint32_t
uint32_t
)
;
switch
(
alphaType
)
{
case
kOpaque_SkAlphaType
:
case
kUnpremul_SkAlphaType
:
packARGB
=
&
SkPackARGB32NoCheck
;
break
;
case
kPremul_SkAlphaType
:
packARGB
=
&
SkPreMultiplyARGB
;
break
;
default
:
SkASSERT
(
false
)
;
packARGB
=
nullptr
;
break
;
}
uint32_t
i
=
0
;
for
(
;
i
<
numColorsToRead
;
i
+
+
)
{
uint8_t
blue
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
)
;
uint8_t
green
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
1
)
;
uint8_t
red
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
2
)
;
uint8_t
alpha
;
if
(
kOpaque_SkAlphaType
=
=
alphaType
)
{
alpha
=
0xFF
;
}
else
{
alpha
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
3
)
;
}
colorTable
[
i
]
=
packARGB
(
alpha
red
green
blue
)
;
}
for
(
;
i
<
maxColors
;
i
+
+
)
{
colorTable
[
i
]
=
SkPackARGB32NoCheck
(
0xFF
0
0
0
)
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorTable
maxColors
)
)
;
}
if
(
!
fInIco
)
{
if
(
fOffset
<
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
color
table
size
.
\
n
"
)
;
return
false
;
}
if
(
stream
(
)
-
>
skip
(
fOffset
-
colorBytes
)
!
=
fOffset
-
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
}
return
true
;
}
bool
SkBmpStandardCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
opts
)
{
SkSwizzler
:
:
SrcConfig
config
;
switch
(
this
-
>
bitsPerPixel
(
)
)
{
case
1
:
config
=
SkSwizzler
:
:
kIndex1
;
break
;
case
2
:
config
=
SkSwizzler
:
:
kIndex2
;
break
;
case
4
:
config
=
SkSwizzler
:
:
kIndex4
;
break
;
case
8
:
config
=
SkSwizzler
:
:
kIndex
;
break
;
case
24
:
config
=
SkSwizzler
:
:
kBGR
;
break
;
case
32
:
if
(
kOpaque_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
config
=
SkSwizzler
:
:
kBGRX
;
}
else
{
config
=
SkSwizzler
:
:
kBGRA
;
}
break
;
default
:
SkASSERT
(
false
)
;
return
false
;
}
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
config
colorPtr
dstInfo
opts
)
)
;
if
(
nullptr
=
=
fSwizzler
.
get
(
)
)
{
return
false
;
}
return
true
;
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
prepareToDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
SkPMColor
inputColorPtr
[
]
int
*
inputColorCount
)
{
if
(
!
this
-
>
createColorTable
(
dstInfo
.
alphaType
(
)
inputColorCount
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
create
color
table
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
copy_color_table
(
dstInfo
this
-
>
fColorTable
inputColorPtr
inputColorCount
)
;
if
(
!
this
-
>
initializeSwizzler
(
dstInfo
options
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
initialize
swizzler
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidConversion
;
}
return
SkCodec
:
:
kSuccess
;
}
int
SkBmpStandardCodec
:
:
decodeRows
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
)
{
const
int
height
=
dstInfo
.
height
(
)
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
if
(
this
-
>
stream
(
)
-
>
read
(
fSrcBuffer
.
get
(
)
fSrcRowBytes
)
!
=
fSrcRowBytes
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
input
stream
.
\
n
"
)
;
return
y
;
}
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
void
*
dstRow
=
SkTAddOffset
<
void
>
(
dst
row
*
dstRowBytes
)
;
fSwizzler
-
>
swizzle
(
dstRow
fSrcBuffer
.
get
(
)
)
;
}
if
(
fInIco
)
{
const
int
startScanline
=
this
-
>
currScanline
(
)
;
if
(
startScanline
<
0
)
{
decodeIcoMask
(
this
-
>
stream
(
)
dstInfo
dst
dstRowBytes
)
;
return
height
;
}
const
void
*
memoryBase
=
this
-
>
stream
(
)
-
>
getMemoryBase
(
)
;
SkASSERT
(
nullptr
!
=
memoryBase
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasLength
(
)
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasPosition
(
)
)
;
const
size_t
length
=
this
-
>
stream
(
)
-
>
getLength
(
)
;
const
size_t
currPosition
=
this
-
>
stream
(
)
-
>
getPosition
(
)
;
const
int
remainingScanlines
=
this
-
>
getInfo
(
)
.
height
(
)
-
startScanline
-
height
;
const
size_t
bytesToSkip
=
remainingScanlines
*
fSrcRowBytes
+
startScanline
*
fAndMaskRowBytes
;
const
size_t
subStreamStartPosition
=
currPosition
+
bytesToSkip
;
if
(
subStreamStartPosition
>
=
length
)
{
return
height
;
}
const
void
*
subStreamMemoryBase
=
SkTAddOffset
<
const
void
>
(
memoryBase
subStreamStartPosition
)
;
const
size_t
subStreamLength
=
length
-
subStreamStartPosition
;
SkMemoryStream
subStream
(
subStreamMemoryBase
subStreamLength
false
)
;
decodeIcoMask
(
&
subStream
dstInfo
dst
dstRowBytes
)
;
}
return
height
;
}
void
SkBmpStandardCodec
:
:
decodeIcoMask
(
SkStream
*
stream
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
)
{
SkASSERT
(
dstInfo
.
colorType
(
)
=
=
kN32_SkColorType
)
;
const
int
sampleX
=
fSwizzler
-
>
sampleX
(
)
;
const
int
sampledWidth
=
get_scaled_dimension
(
this
-
>
getInfo
(
)
.
width
(
)
sampleX
)
;
const
int
srcStartX
=
get_start_coord
(
sampleX
)
;
SkPMColor
*
dstPtr
=
(
SkPMColor
*
)
dst
;
for
(
int
y
=
0
;
y
<
dstInfo
.
height
(
)
;
y
+
+
)
{
if
(
stream
-
>
read
(
fSrcBuffer
.
get
(
)
fAndMaskRowBytes
)
!
=
fAndMaskRowBytes
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
AND
mask
for
bmp
-
in
-
ico
.
\
n
"
)
;
return
;
}
int
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dstPtr
row
*
dstRowBytes
)
;
int
srcX
=
srcStartX
;
for
(
int
dstX
=
0
;
dstX
<
sampledWidth
;
dstX
+
+
)
{
int
quotient
;
int
modulus
;
SkTDivMod
(
srcX
8
&
quotient
&
modulus
)
;
uint32_t
shift
=
7
-
modulus
;
uint32_t
alphaBit
=
(
fSrcBuffer
.
get
(
)
[
quotient
]
>
>
shift
)
&
0x1
;
dstRow
[
dstX
]
&
=
alphaBit
-
1
;
srcX
+
=
sampleX
;
}
}
}
uint32_t
SkBmpStandardCodec
:
:
onGetFillValue
(
SkColorType
colorType
SkAlphaType
alphaType
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
if
(
colorPtr
)
{
return
get_color_table_fill_value
(
colorType
colorPtr
0
)
;
}
return
INHERITED
:
:
onGetFillValue
(
colorType
alphaType
)
;
}
