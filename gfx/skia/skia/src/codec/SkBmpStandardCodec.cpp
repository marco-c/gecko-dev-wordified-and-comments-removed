#
include
"
src
/
codec
/
SkBmpStandardCodec
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorPriv
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
SkBmpStandardCodec
:
:
SkBmpStandardCodec
(
SkEncodedInfo
&
&
info
std
:
:
unique_ptr
<
SkStream
>
stream
uint16_t
bitsPerPixel
uint32_t
numColors
uint32_t
bytesPerColor
uint32_t
offset
SkCodec
:
:
SkScanlineOrder
rowOrder
bool
isOpaque
bool
inIco
)
:
INHERITED
(
std
:
:
move
(
info
)
std
:
:
move
(
stream
)
bitsPerPixel
rowOrder
)
fColorTable
(
nullptr
)
fNumColors
(
numColors
)
fBytesPerColor
(
bytesPerColor
)
fOffset
(
offset
)
fSwizzler
(
nullptr
)
fIsOpaque
(
isOpaque
)
fInIco
(
inIco
)
fAndMaskRowBytes
(
fInIco
?
SkAlign4
(
compute_row_bytes
(
this
-
>
dimensions
(
)
.
width
(
)
1
)
)
:
0
)
{
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
if
(
dstInfo
.
dimensions
(
)
!
=
this
-
>
dimensions
(
)
)
{
SkCodecPrintf
(
"
Error
:
scaling
not
supported
.
\
n
"
)
;
return
kInvalidScale
;
}
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
opts
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
int
rows
=
this
-
>
decodeRows
(
dstInfo
dst
dstRowBytes
opts
)
;
if
(
rows
!
=
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
rows
;
return
kIncompleteInput
;
}
return
kSuccess
;
}
bool
SkBmpStandardCodec
:
:
createColorTable
(
SkColorType
dstColorType
SkAlphaType
dstAlphaType
)
{
uint32_t
colorBytes
=
0
;
SkPMColor
colorTable
[
256
]
;
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
uint32_t
maxColors
=
1
<
<
this
-
>
bitsPerPixel
(
)
;
const
uint32_t
numColorsToRead
=
fNumColors
=
=
0
?
maxColors
:
std
:
:
min
(
fNumColors
maxColors
)
;
colorBytes
=
numColorsToRead
*
fBytesPerColor
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
cBuffer
(
new
uint8_t
[
colorBytes
]
)
;
if
(
stream
(
)
-
>
read
(
cBuffer
.
get
(
)
colorBytes
)
!
=
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
color
table
.
\
n
"
)
;
return
false
;
}
SkColorType
packColorType
=
dstColorType
;
SkAlphaType
packAlphaType
=
dstAlphaType
;
if
(
this
-
>
colorXform
(
)
)
{
packColorType
=
kBGRA_8888_SkColorType
;
packAlphaType
=
kUnpremul_SkAlphaType
;
}
bool
isPremul
=
(
kPremul_SkAlphaType
=
=
packAlphaType
)
&
&
!
fIsOpaque
;
PackColorProc
packARGB
=
choose_pack_color_proc
(
isPremul
packColorType
)
;
uint32_t
i
=
0
;
for
(
;
i
<
numColorsToRead
;
i
+
+
)
{
uint8_t
blue
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
)
;
uint8_t
green
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
1
)
;
uint8_t
red
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
2
)
;
uint8_t
alpha
;
if
(
fIsOpaque
)
{
alpha
=
0xFF
;
}
else
{
alpha
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
3
)
;
}
colorTable
[
i
]
=
packARGB
(
alpha
red
green
blue
)
;
}
for
(
;
i
<
maxColors
;
i
+
+
)
{
colorTable
[
i
]
=
SkPackARGB32
(
0xFF
0
0
0
)
;
}
if
(
this
-
>
colorXform
(
)
&
&
!
this
-
>
xformOnDecode
(
)
)
{
this
-
>
applyColorXform
(
colorTable
colorTable
maxColors
)
;
}
fColorTable
.
reset
(
new
SkColorPalette
(
colorTable
maxColors
)
)
;
}
if
(
!
fInIco
)
{
if
(
fOffset
<
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
color
table
size
.
\
n
"
)
;
return
false
;
}
if
(
stream
(
)
-
>
skip
(
fOffset
-
colorBytes
)
!
=
fOffset
-
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
}
return
true
;
}
static
SkEncodedInfo
make_info
(
SkEncodedInfo
:
:
Color
color
SkEncodedInfo
:
:
Alpha
alpha
int
bitsPerPixel
)
{
return
SkEncodedInfo
:
:
Make
(
0
0
color
alpha
bitsPerPixel
)
;
}
SkEncodedInfo
SkBmpStandardCodec
:
:
swizzlerInfo
(
)
const
{
const
auto
&
info
=
this
-
>
getEncodedInfo
(
)
;
if
(
fInIco
)
{
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
return
make_info
(
SkEncodedInfo
:
:
kPalette_Color
info
.
alpha
(
)
this
-
>
bitsPerPixel
(
)
)
;
}
if
(
this
-
>
bitsPerPixel
(
)
=
=
24
)
{
return
make_info
(
SkEncodedInfo
:
:
kBGR_Color
SkEncodedInfo
:
:
kOpaque_Alpha
8
)
;
}
}
return
make_info
(
info
.
color
(
)
info
.
alpha
(
)
info
.
bitsPerComponent
(
)
)
;
}
void
SkBmpStandardCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
opts
)
{
SkEncodedInfo
encodedInfo
=
this
-
>
swizzlerInfo
(
)
;
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
SkImageInfo
swizzlerInfo
=
dstInfo
;
SkCodec
:
:
Options
swizzlerOptions
=
opts
;
if
(
this
-
>
colorXform
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeColorType
(
kXformSrcColorType
)
;
if
(
kPremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
}
swizzlerOptions
.
fZeroInitialized
=
kNo_ZeroInitialized
;
}
fSwizzler
=
SkSwizzler
:
:
Make
(
encodedInfo
colorPtr
swizzlerInfo
swizzlerOptions
)
;
SkASSERT
(
fSwizzler
)
;
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
onPrepareToDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
)
{
if
(
this
-
>
xformOnDecode
(
)
)
{
this
-
>
resetXformBuffer
(
dstInfo
.
width
(
)
)
;
}
if
(
!
this
-
>
createColorTable
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
create
color
table
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
this
-
>
initializeSwizzler
(
dstInfo
options
)
;
return
SkCodec
:
:
kSuccess
;
}
int
SkBmpStandardCodec
:
:
decodeRows
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
)
{
const
int
height
=
dstInfo
.
height
(
)
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
if
(
this
-
>
stream
(
)
-
>
read
(
this
-
>
srcBuffer
(
)
this
-
>
srcRowBytes
(
)
)
!
=
this
-
>
srcRowBytes
(
)
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
input
stream
.
\
n
"
)
;
return
y
;
}
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
void
*
dstRow
=
SkTAddOffset
<
void
>
(
dst
row
*
dstRowBytes
)
;
if
(
this
-
>
xformOnDecode
(
)
)
{
SkASSERT
(
this
-
>
colorXform
(
)
)
;
fSwizzler
-
>
swizzle
(
this
-
>
xformBuffer
(
)
this
-
>
srcBuffer
(
)
)
;
this
-
>
applyColorXform
(
dstRow
this
-
>
xformBuffer
(
)
fSwizzler
-
>
swizzleWidth
(
)
)
;
}
else
{
fSwizzler
-
>
swizzle
(
dstRow
this
-
>
srcBuffer
(
)
)
;
}
}
if
(
fInIco
&
&
fIsOpaque
)
{
const
int
startScanline
=
this
-
>
currScanline
(
)
;
if
(
startScanline
<
0
)
{
decodeIcoMask
(
this
-
>
stream
(
)
dstInfo
dst
dstRowBytes
)
;
return
height
;
}
const
void
*
memoryBase
=
this
-
>
stream
(
)
-
>
getMemoryBase
(
)
;
SkASSERT
(
nullptr
!
=
memoryBase
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasLength
(
)
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasPosition
(
)
)
;
const
size_t
length
=
this
-
>
stream
(
)
-
>
getLength
(
)
;
const
size_t
currPosition
=
this
-
>
stream
(
)
-
>
getPosition
(
)
;
const
int
remainingScanlines
=
this
-
>
dimensions
(
)
.
height
(
)
-
startScanline
-
height
;
const
size_t
bytesToSkip
=
remainingScanlines
*
this
-
>
srcRowBytes
(
)
+
startScanline
*
fAndMaskRowBytes
;
const
size_t
subStreamStartPosition
=
currPosition
+
bytesToSkip
;
if
(
subStreamStartPosition
>
=
length
)
{
return
height
;
}
const
void
*
subStreamMemoryBase
=
SkTAddOffset
<
const
void
>
(
memoryBase
subStreamStartPosition
)
;
const
size_t
subStreamLength
=
length
-
subStreamStartPosition
;
SkMemoryStream
subStream
(
subStreamMemoryBase
subStreamLength
false
)
;
decodeIcoMask
(
&
subStream
dstInfo
dst
dstRowBytes
)
;
}
return
height
;
}
void
SkBmpStandardCodec
:
:
decodeIcoMask
(
SkStream
*
stream
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
)
{
SkASSERT
(
kRGBA_8888_SkColorType
=
=
dstInfo
.
colorType
(
)
|
|
kBGRA_8888_SkColorType
=
=
dstInfo
.
colorType
(
)
|
|
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
;
const
int
sampleX
=
fSwizzler
-
>
sampleX
(
)
;
const
int
sampledWidth
=
get_scaled_dimension
(
this
-
>
dimensions
(
)
.
width
(
)
sampleX
)
;
const
int
srcStartX
=
get_start_coord
(
sampleX
)
;
SkPMColor
*
dstPtr
=
(
SkPMColor
*
)
dst
;
for
(
int
y
=
0
;
y
<
dstInfo
.
height
(
)
;
y
+
+
)
{
if
(
stream
-
>
read
(
this
-
>
srcBuffer
(
)
fAndMaskRowBytes
)
!
=
fAndMaskRowBytes
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
AND
mask
for
bmp
-
in
-
ico
.
\
n
"
)
;
return
;
}
auto
applyMask
=
[
dstInfo
]
(
void
*
dstRow
int
x
uint64_t
bit
)
{
if
(
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
{
uint64_t
*
dst64
=
(
uint64_t
*
)
dstRow
;
dst64
[
x
]
&
=
bit
-
1
;
}
else
{
uint32_t
*
dst32
=
(
uint32_t
*
)
dstRow
;
dst32
[
x
]
&
=
bit
-
1
;
}
}
;
int
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
void
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dstPtr
row
*
dstRowBytes
)
;
int
srcX
=
srcStartX
;
for
(
int
dstX
=
0
;
dstX
<
sampledWidth
;
dstX
+
+
)
{
int
quotient
;
int
modulus
;
SkTDivMod
(
srcX
8
&
quotient
&
modulus
)
;
uint32_t
shift
=
7
-
modulus
;
uint64_t
alphaBit
=
(
this
-
>
srcBuffer
(
)
[
quotient
]
>
>
shift
)
&
0x1
;
applyMask
(
dstRow
dstX
alphaBit
)
;
srcX
+
=
sampleX
;
}
}
}
