#
include
"
SkBmpStandardCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkStream
.
h
"
SkBmpStandardCodec
:
:
SkBmpStandardCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
SkStream
*
stream
uint16_t
bitsPerPixel
uint32_t
numColors
uint32_t
bytesPerColor
uint32_t
offset
SkCodec
:
:
SkScanlineOrder
rowOrder
bool
isOpaque
bool
inIco
)
:
INHERITED
(
width
height
info
stream
bitsPerPixel
rowOrder
)
fColorTable
(
nullptr
)
fNumColors
(
numColors
)
fBytesPerColor
(
bytesPerColor
)
fOffset
(
offset
)
fSwizzler
(
nullptr
)
fSrcBuffer
(
new
uint8_t
[
this
-
>
srcRowBytes
(
)
]
)
fIsOpaque
(
isOpaque
)
fInIco
(
inIco
)
fAndMaskRowBytes
(
fInIco
?
SkAlign4
(
compute_row_bytes
(
this
-
>
getInfo
(
)
.
width
(
)
1
)
)
:
0
)
fXformOnDecode
(
false
)
{
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
if
(
dstInfo
.
dimensions
(
)
!
=
this
-
>
getInfo
(
)
.
dimensions
(
)
)
{
SkCodecPrintf
(
"
Error
:
scaling
not
supported
.
\
n
"
)
;
return
kInvalidScale
;
}
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
opts
inputColorPtr
inputColorCount
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
int
rows
=
this
-
>
decodeRows
(
dstInfo
dst
dstRowBytes
opts
)
;
if
(
rows
!
=
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
rows
;
return
kIncompleteInput
;
}
return
kSuccess
;
}
bool
SkBmpStandardCodec
:
:
createColorTable
(
SkColorType
dstColorType
SkAlphaType
dstAlphaType
int
*
numColors
)
{
uint32_t
colorBytes
=
0
;
SkPMColor
colorTable
[
256
]
;
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
uint32_t
maxColors
=
1
<
<
this
-
>
bitsPerPixel
(
)
;
if
(
nullptr
!
=
numColors
)
{
*
numColors
=
maxColors
;
}
const
uint32_t
numColorsToRead
=
fNumColors
=
=
0
?
maxColors
:
SkTMin
(
fNumColors
maxColors
)
;
colorBytes
=
numColorsToRead
*
fBytesPerColor
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
cBuffer
(
new
uint8_t
[
colorBytes
]
)
;
if
(
stream
(
)
-
>
read
(
cBuffer
.
get
(
)
colorBytes
)
!
=
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
color
table
.
\
n
"
)
;
return
false
;
}
SkColorType
packColorType
=
dstColorType
;
SkAlphaType
packAlphaType
=
dstAlphaType
;
if
(
this
-
>
colorXform
(
)
)
{
packColorType
=
kBGRA_8888_SkColorType
;
packAlphaType
=
kUnpremul_SkAlphaType
;
}
bool
isPremul
=
(
kPremul_SkAlphaType
=
=
packAlphaType
)
&
&
!
fIsOpaque
;
PackColorProc
packARGB
=
choose_pack_color_proc
(
isPremul
packColorType
)
;
uint32_t
i
=
0
;
for
(
;
i
<
numColorsToRead
;
i
+
+
)
{
uint8_t
blue
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
)
;
uint8_t
green
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
1
)
;
uint8_t
red
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
2
)
;
uint8_t
alpha
;
if
(
fIsOpaque
)
{
alpha
=
0xFF
;
}
else
{
alpha
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
3
)
;
}
colorTable
[
i
]
=
packARGB
(
alpha
red
green
blue
)
;
}
for
(
;
i
<
maxColors
;
i
+
+
)
{
colorTable
[
i
]
=
SkPackARGB32NoCheck
(
0xFF
0
0
0
)
;
}
if
(
this
-
>
colorXform
(
)
&
&
!
fXformOnDecode
)
{
SkColorSpaceXform
:
:
ColorFormat
dstFormat
=
select_xform_format_ct
(
dstColorType
)
;
SkColorSpaceXform
:
:
ColorFormat
srcFormat
=
SkColorSpaceXform
:
:
kBGRA_8888_ColorFormat
;
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstAlphaType
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
dstFormat
colorTable
srcFormat
colorTable
maxColors
xformAlphaType
)
)
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorTable
maxColors
)
)
;
}
if
(
!
fInIco
)
{
if
(
fOffset
<
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
color
table
size
.
\
n
"
)
;
return
false
;
}
if
(
stream
(
)
-
>
skip
(
fOffset
-
colorBytes
)
!
=
fOffset
-
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
}
return
true
;
}
void
SkBmpStandardCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
opts
)
{
SkEncodedInfo
encodedInfo
=
this
-
>
getEncodedInfo
(
)
;
if
(
fInIco
)
{
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
encodedInfo
=
SkEncodedInfo
:
:
Make
(
SkEncodedInfo
:
:
kPalette_Color
encodedInfo
.
alpha
(
)
this
-
>
bitsPerPixel
(
)
)
;
}
else
if
(
this
-
>
bitsPerPixel
(
)
=
=
24
)
{
encodedInfo
=
SkEncodedInfo
:
:
Make
(
SkEncodedInfo
:
:
kBGR_Color
SkEncodedInfo
:
:
kOpaque_Alpha
8
)
;
}
}
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
SkImageInfo
swizzlerInfo
=
dstInfo
;
SkCodec
:
:
Options
swizzlerOptions
=
opts
;
if
(
this
-
>
colorXform
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeColorType
(
kXformSrcColorType
)
;
if
(
kPremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
}
swizzlerOptions
.
fZeroInitialized
=
kNo_ZeroInitialized
;
}
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
encodedInfo
colorPtr
swizzlerInfo
swizzlerOptions
)
)
;
SkASSERT
(
fSwizzler
)
;
}
SkCodec
:
:
Result
SkBmpStandardCodec
:
:
onPrepareToDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
SkPMColor
inputColorPtr
[
]
int
*
inputColorCount
)
{
fXformOnDecode
=
false
;
if
(
this
-
>
colorXform
(
)
)
{
fXformOnDecode
=
apply_xform_on_decode
(
dstInfo
.
colorType
(
)
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
;
if
(
fXformOnDecode
)
{
this
-
>
resetXformBuffer
(
dstInfo
.
width
(
)
)
;
}
}
if
(
!
this
-
>
createColorTable
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
inputColorCount
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
create
color
table
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
copy_color_table
(
dstInfo
fColorTable
.
get
(
)
inputColorPtr
inputColorCount
)
;
this
-
>
initializeSwizzler
(
dstInfo
options
)
;
return
SkCodec
:
:
kSuccess
;
}
int
SkBmpStandardCodec
:
:
decodeRows
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
)
{
const
int
height
=
dstInfo
.
height
(
)
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
if
(
this
-
>
stream
(
)
-
>
read
(
fSrcBuffer
.
get
(
)
this
-
>
srcRowBytes
(
)
)
!
=
this
-
>
srcRowBytes
(
)
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
input
stream
.
\
n
"
)
;
return
y
;
}
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
void
*
dstRow
=
SkTAddOffset
<
void
>
(
dst
row
*
dstRowBytes
)
;
if
(
fXformOnDecode
)
{
SkASSERT
(
this
-
>
colorXform
(
)
)
;
SkImageInfo
xformInfo
=
dstInfo
.
makeWH
(
fSwizzler
-
>
swizzleWidth
(
)
dstInfo
.
height
(
)
)
;
fSwizzler
-
>
swizzle
(
this
-
>
xformBuffer
(
)
fSrcBuffer
.
get
(
)
)
;
this
-
>
applyColorXform
(
xformInfo
dstRow
this
-
>
xformBuffer
(
)
)
;
}
else
{
fSwizzler
-
>
swizzle
(
dstRow
fSrcBuffer
.
get
(
)
)
;
}
}
if
(
fInIco
&
&
fIsOpaque
)
{
const
int
startScanline
=
this
-
>
currScanline
(
)
;
if
(
startScanline
<
0
)
{
decodeIcoMask
(
this
-
>
stream
(
)
dstInfo
dst
dstRowBytes
)
;
return
height
;
}
const
void
*
memoryBase
=
this
-
>
stream
(
)
-
>
getMemoryBase
(
)
;
SkASSERT
(
nullptr
!
=
memoryBase
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasLength
(
)
)
;
SkASSERT
(
this
-
>
stream
(
)
-
>
hasPosition
(
)
)
;
const
size_t
length
=
this
-
>
stream
(
)
-
>
getLength
(
)
;
const
size_t
currPosition
=
this
-
>
stream
(
)
-
>
getPosition
(
)
;
const
int
remainingScanlines
=
this
-
>
getInfo
(
)
.
height
(
)
-
startScanline
-
height
;
const
size_t
bytesToSkip
=
remainingScanlines
*
this
-
>
srcRowBytes
(
)
+
startScanline
*
fAndMaskRowBytes
;
const
size_t
subStreamStartPosition
=
currPosition
+
bytesToSkip
;
if
(
subStreamStartPosition
>
=
length
)
{
return
height
;
}
const
void
*
subStreamMemoryBase
=
SkTAddOffset
<
const
void
>
(
memoryBase
subStreamStartPosition
)
;
const
size_t
subStreamLength
=
length
-
subStreamStartPosition
;
SkMemoryStream
subStream
(
subStreamMemoryBase
subStreamLength
false
)
;
decodeIcoMask
(
&
subStream
dstInfo
dst
dstRowBytes
)
;
}
return
height
;
}
void
SkBmpStandardCodec
:
:
decodeIcoMask
(
SkStream
*
stream
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
)
{
SkASSERT
(
kRGBA_8888_SkColorType
=
=
dstInfo
.
colorType
(
)
|
|
kBGRA_8888_SkColorType
=
=
dstInfo
.
colorType
(
)
|
|
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
;
const
int
sampleX
=
fSwizzler
-
>
sampleX
(
)
;
const
int
sampledWidth
=
get_scaled_dimension
(
this
-
>
getInfo
(
)
.
width
(
)
sampleX
)
;
const
int
srcStartX
=
get_start_coord
(
sampleX
)
;
SkPMColor
*
dstPtr
=
(
SkPMColor
*
)
dst
;
for
(
int
y
=
0
;
y
<
dstInfo
.
height
(
)
;
y
+
+
)
{
if
(
stream
-
>
read
(
fSrcBuffer
.
get
(
)
fAndMaskRowBytes
)
!
=
fAndMaskRowBytes
)
{
SkCodecPrintf
(
"
Warning
:
incomplete
AND
mask
for
bmp
-
in
-
ico
.
\
n
"
)
;
return
;
}
auto
applyMask
=
[
dstInfo
]
(
void
*
dstRow
int
x
uint64_t
bit
)
{
if
(
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
{
uint64_t
*
dst64
=
(
uint64_t
*
)
dstRow
;
dst64
[
x
]
&
=
bit
-
1
;
}
else
{
uint32_t
*
dst32
=
(
uint32_t
*
)
dstRow
;
dst32
[
x
]
&
=
bit
-
1
;
}
}
;
int
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
void
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dstPtr
row
*
dstRowBytes
)
;
int
srcX
=
srcStartX
;
for
(
int
dstX
=
0
;
dstX
<
sampledWidth
;
dstX
+
+
)
{
int
quotient
;
int
modulus
;
SkTDivMod
(
srcX
8
&
quotient
&
modulus
)
;
uint32_t
shift
=
7
-
modulus
;
uint64_t
alphaBit
=
(
fSrcBuffer
.
get
(
)
[
quotient
]
>
>
shift
)
&
0x1
;
applyMask
(
dstRow
dstX
alphaBit
)
;
srcX
+
=
sampleX
;
}
}
}
uint64_t
SkBmpStandardCodec
:
:
onGetFillValue
(
const
SkImageInfo
&
dstInfo
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
if
(
colorPtr
)
{
return
get_color_table_fill_value
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
colorPtr
0
this
-
>
colorXform
(
)
false
)
;
}
return
INHERITED
:
:
onGetFillValue
(
dstInfo
)
;
}
