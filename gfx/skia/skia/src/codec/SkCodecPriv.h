#
ifndef
SkCodecPriv_DEFINED
#
define
SkCodecPriv_DEFINED
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkUtils
.
h
"
inline
float
get_scale_from_sample_size
(
int
sampleSize
)
{
return
1
.
0f
/
(
(
float
)
sampleSize
)
;
}
inline
bool
is_valid_subset
(
const
SkIRect
&
subset
const
SkISize
&
imageDims
)
{
return
SkIRect
:
:
MakeSize
(
imageDims
)
.
contains
(
subset
)
;
}
inline
int
get_scaled_dimension
(
int
srcDimension
int
sampleSize
)
{
if
(
sampleSize
>
srcDimension
)
{
return
1
;
}
return
srcDimension
/
sampleSize
;
}
inline
int
get_start_coord
(
int
sampleFactor
)
{
return
sampleFactor
/
2
;
}
;
inline
int
get_dst_coord
(
int
srcCoord
int
sampleFactor
)
{
return
srcCoord
/
sampleFactor
;
}
;
inline
bool
is_coord_necessary
(
int
srcCoord
int
sampleFactor
int
scaledDim
)
{
int
startCoord
=
get_start_coord
(
sampleFactor
)
;
if
(
srcCoord
<
startCoord
|
|
get_dst_coord
(
srcCoord
sampleFactor
)
>
=
scaledDim
)
{
return
false
;
}
return
(
(
srcCoord
-
startCoord
)
%
sampleFactor
)
=
=
0
;
}
inline
bool
valid_alpha
(
SkAlphaType
dstAlpha
SkAlphaType
srcAlpha
)
{
if
(
srcAlpha
!
=
dstAlpha
)
{
if
(
kOpaque_SkAlphaType
=
=
srcAlpha
)
{
return
false
;
}
switch
(
dstAlpha
)
{
case
kPremul_SkAlphaType
:
case
kUnpremul_SkAlphaType
:
break
;
default
:
return
false
;
}
}
return
true
;
}
inline
bool
conversion_possible
(
const
SkImageInfo
&
dst
const
SkImageInfo
&
src
)
{
if
(
dst
.
profileType
(
)
!
=
src
.
profileType
(
)
)
{
return
false
;
}
if
(
!
valid_alpha
(
dst
.
alphaType
(
)
src
.
alphaType
(
)
)
)
{
return
false
;
}
switch
(
dst
.
colorType
(
)
)
{
case
kN32_SkColorType
:
return
true
;
case
kRGB_565_SkColorType
:
return
src
.
alphaType
(
)
=
=
kOpaque_SkAlphaType
;
default
:
return
dst
.
colorType
(
)
=
=
src
.
colorType
(
)
;
}
}
inline
const
SkPMColor
*
get_color_ptr
(
SkColorTable
*
colorTable
)
{
return
nullptr
!
=
colorTable
?
colorTable
-
>
readColors
(
)
:
nullptr
;
}
inline
uint32_t
get_color_table_fill_value
(
SkColorType
colorType
const
SkPMColor
*
colorPtr
uint8_t
fillIndex
)
{
SkASSERT
(
nullptr
!
=
colorPtr
)
;
switch
(
colorType
)
{
case
kN32_SkColorType
:
return
colorPtr
[
fillIndex
]
;
case
kRGB_565_SkColorType
:
return
SkPixel32ToPixel16
(
colorPtr
[
fillIndex
]
)
;
case
kIndex_8_SkColorType
:
return
fillIndex
;
default
:
SkASSERT
(
false
)
;
return
0
;
}
}
inline
void
copy_color_table
(
const
SkImageInfo
&
dstInfo
SkColorTable
*
colorTable
SkPMColor
*
inputColorPtr
int
*
inputColorCount
)
{
if
(
kIndex_8_SkColorType
=
=
dstInfo
.
colorType
(
)
)
{
SkASSERT
(
nullptr
!
=
inputColorPtr
)
;
SkASSERT
(
nullptr
!
=
inputColorCount
)
;
SkASSERT
(
nullptr
!
=
colorTable
)
;
memcpy
(
inputColorPtr
colorTable
-
>
readColors
(
)
*
inputColorCount
*
sizeof
(
SkPMColor
)
)
;
}
}
inline
size_t
compute_row_bytes_ppb
(
int
width
uint32_t
pixelsPerByte
)
{
return
(
width
+
pixelsPerByte
-
1
)
/
pixelsPerByte
;
}
inline
size_t
compute_row_bytes_bpp
(
int
width
uint32_t
bytesPerPixel
)
{
return
width
*
bytesPerPixel
;
}
inline
size_t
compute_row_bytes
(
int
width
uint32_t
bitsPerPixel
)
{
if
(
bitsPerPixel
<
16
)
{
SkASSERT
(
0
=
=
8
%
bitsPerPixel
)
;
const
uint32_t
pixelsPerByte
=
8
/
bitsPerPixel
;
return
compute_row_bytes_ppb
(
width
pixelsPerByte
)
;
}
else
{
SkASSERT
(
0
=
=
bitsPerPixel
%
8
)
;
const
uint32_t
bytesPerPixel
=
bitsPerPixel
/
8
;
return
compute_row_bytes_bpp
(
width
bytesPerPixel
)
;
}
}
inline
uint8_t
get_byte
(
uint8_t
*
buffer
uint32_t
i
)
{
return
buffer
[
i
]
;
}
inline
uint16_t
get_short
(
uint8_t
*
buffer
uint32_t
i
)
{
uint16_t
result
;
memcpy
(
&
result
&
(
buffer
[
i
]
)
2
)
;
#
ifdef
SK_CPU_BENDIAN
return
SkEndianSwap16
(
result
)
;
#
else
return
result
;
#
endif
}
inline
uint32_t
get_int
(
uint8_t
*
buffer
uint32_t
i
)
{
uint32_t
result
;
memcpy
(
&
result
&
(
buffer
[
i
]
)
4
)
;
#
ifdef
SK_CPU_BENDIAN
return
SkEndianSwap32
(
result
)
;
#
else
return
result
;
#
endif
}
#
ifdef
SK_PRINT_CODEC_MESSAGES
#
define
SkCodecPrintf
SkDebugf
#
else
#
define
SkCodecPrintf
(
.
.
.
)
#
endif
#
endif
