#
ifndef
SkJpegCodec_DEFINED
#
define
SkJpegCodec_DEFINED
#
include
"
SkCodec
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
class
JpegDecoderMgr
;
class
SkJpegCodec
:
public
SkCodec
{
public
:
static
bool
IsJpeg
(
const
void
*
size_t
)
;
static
SkCodec
*
NewFromStream
(
SkStream
*
)
;
protected
:
SkISize
onGetScaledDimensions
(
float
desiredScale
)
const
override
;
Result
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
SkPMColor
*
int
*
int
*
)
override
;
bool
onQueryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
override
;
Result
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
override
;
SkEncodedFormat
onGetEncodedFormat
(
)
const
override
{
return
kJPEG_SkEncodedFormat
;
}
bool
onRewind
(
)
override
;
bool
onDimensionsSupported
(
const
SkISize
&
)
override
;
private
:
static
bool
ReadHeader
(
SkStream
*
stream
SkCodec
*
*
codecOut
JpegDecoderMgr
*
*
decoderMgrOut
)
;
SkJpegCodec
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
JpegDecoderMgr
*
decoderMgr
sk_sp
<
SkColorSpace
>
colorSpace
Origin
origin
)
;
bool
setOutputColorSpace
(
const
SkImageInfo
&
dst
)
;
void
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
)
;
SkSampler
*
getSampler
(
bool
createIfNecessary
)
override
;
Result
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
;
int
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
override
;
bool
onSkipScanlines
(
int
count
)
override
;
SkAutoTDelete
<
JpegDecoderMgr
>
fDecoderMgr
;
const
int
fReadyState
;
SkAutoTMalloc
<
uint8_t
>
fStorage
;
uint8_t
*
fSrcRow
;
SkIRect
fSwizzlerSubset
;
SkAutoTDelete
<
SkSwizzler
>
fSwizzler
;
typedef
SkCodec
INHERITED
;
}
;
#
endif
