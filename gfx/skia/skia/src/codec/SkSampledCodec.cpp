#
include
"
SkCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkSampledCodec
.
h
"
#
include
"
SkSampler
.
h
"
#
include
"
SkTemplates
.
h
"
SkSampledCodec
:
:
SkSampledCodec
(
SkCodec
*
codec
)
:
INHERITED
(
codec
)
{
}
SkISize
SkSampledCodec
:
:
accountForNativeScaling
(
int
*
sampleSizePtr
int
*
nativeSampleSize
)
const
{
SkISize
preSampledSize
=
this
-
>
codec
(
)
-
>
getInfo
(
)
.
dimensions
(
)
;
int
sampleSize
=
*
sampleSizePtr
;
SkASSERT
(
sampleSize
>
1
)
;
if
(
nativeSampleSize
)
{
*
nativeSampleSize
=
1
;
}
if
(
this
-
>
codec
(
)
-
>
getEncodedFormat
(
)
=
=
kJPEG_SkEncodedFormat
)
{
switch
(
sampleSize
)
{
case
2
:
case
4
:
case
8
:
*
sampleSizePtr
=
1
;
return
this
-
>
codec
(
)
-
>
getScaledDimensions
(
get_scale_from_sample_size
(
sampleSize
)
)
;
default
:
break
;
}
int
remainder
;
const
int
sampleSizes
[
]
=
{
8
4
2
}
;
for
(
int
supportedSampleSize
:
sampleSizes
)
{
int
actualSampleSize
;
SkTDivMod
(
sampleSize
supportedSampleSize
&
actualSampleSize
&
remainder
)
;
if
(
0
=
=
remainder
)
{
float
scale
=
get_scale_from_sample_size
(
supportedSampleSize
)
;
preSampledSize
=
this
-
>
codec
(
)
-
>
getScaledDimensions
(
scale
)
;
*
sampleSizePtr
=
actualSampleSize
;
if
(
nativeSampleSize
)
{
*
nativeSampleSize
=
supportedSampleSize
;
}
break
;
}
}
}
return
preSampledSize
;
}
SkISize
SkSampledCodec
:
:
onGetSampledDimensions
(
int
sampleSize
)
const
{
const
SkISize
size
=
this
-
>
accountForNativeScaling
(
&
sampleSize
)
;
return
SkISize
:
:
Make
(
get_scaled_dimension
(
size
.
width
(
)
sampleSize
)
get_scaled_dimension
(
size
.
height
(
)
sampleSize
)
)
;
}
SkCodec
:
:
Result
SkSampledCodec
:
:
onGetAndroidPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
AndroidOptions
&
options
)
{
SkCodec
:
:
Options
codecOptions
;
codecOptions
.
fZeroInitialized
=
options
.
fZeroInitialized
;
SkIRect
*
subset
=
options
.
fSubset
;
if
(
!
subset
|
|
subset
-
>
size
(
)
=
=
this
-
>
codec
(
)
-
>
getInfo
(
)
.
dimensions
(
)
)
{
if
(
this
-
>
codec
(
)
-
>
dimensionsSupported
(
info
.
dimensions
(
)
)
)
{
return
this
-
>
codec
(
)
-
>
getPixels
(
info
pixels
rowBytes
&
codecOptions
options
.
fColorPtr
options
.
fColorCount
)
;
}
return
this
-
>
sampledDecode
(
info
pixels
rowBytes
options
)
;
}
int
sampleSize
=
options
.
fSampleSize
;
SkISize
scaledSize
=
this
-
>
getSampledDimensions
(
sampleSize
)
;
if
(
!
this
-
>
codec
(
)
-
>
dimensionsSupported
(
scaledSize
)
)
{
return
this
-
>
sampledDecode
(
info
pixels
rowBytes
options
)
;
}
int
scaledSubsetX
=
subset
-
>
x
(
)
/
sampleSize
;
int
scaledSubsetY
=
subset
-
>
y
(
)
/
sampleSize
;
int
scaledSubsetWidth
=
info
.
width
(
)
;
int
scaledSubsetHeight
=
info
.
height
(
)
;
SkIRect
scanlineSubset
=
SkIRect
:
:
MakeXYWH
(
scaledSubsetX
0
scaledSubsetWidth
scaledSize
.
height
(
)
)
;
codecOptions
.
fSubset
=
&
scanlineSubset
;
SkCodec
:
:
Result
result
=
this
-
>
codec
(
)
-
>
startScanlineDecode
(
info
.
makeWH
(
scaledSize
.
width
(
)
scaledSize
.
height
(
)
)
&
codecOptions
options
.
fColorPtr
options
.
fColorCount
)
;
if
(
SkCodec
:
:
kSuccess
!
=
result
)
{
return
result
;
}
switch
(
this
-
>
codec
(
)
-
>
getScanlineOrder
(
)
)
{
case
SkCodec
:
:
kTopDown_SkScanlineOrder
:
case
SkCodec
:
:
kNone_SkScanlineOrder
:
{
if
(
!
this
-
>
codec
(
)
-
>
skipScanlines
(
scaledSubsetY
)
)
{
this
-
>
codec
(
)
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
.
fZeroInitialized
scaledSubsetHeight
0
)
;
return
SkCodec
:
:
kIncompleteInput
;
}
int
decodedLines
=
this
-
>
codec
(
)
-
>
getScanlines
(
pixels
scaledSubsetHeight
rowBytes
)
;
if
(
decodedLines
!
=
scaledSubsetHeight
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
return
SkCodec
:
:
kSuccess
;
}
default
:
SkASSERT
(
false
)
;
return
SkCodec
:
:
kUnimplemented
;
}
}
SkCodec
:
:
Result
SkSampledCodec
:
:
sampledDecode
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
AndroidOptions
&
options
)
{
SkASSERT
(
options
.
fSampleSize
>
1
)
;
SkCodec
:
:
Options
sampledOptions
;
sampledOptions
.
fZeroInitialized
=
options
.
fZeroInitialized
;
int
sampleSize
=
options
.
fSampleSize
;
int
nativeSampleSize
;
SkISize
nativeSize
=
this
-
>
accountForNativeScaling
(
&
sampleSize
&
nativeSampleSize
)
;
SkIRect
subset
;
int
subsetY
=
0
;
int
subsetWidth
=
nativeSize
.
width
(
)
;
int
subsetHeight
=
nativeSize
.
height
(
)
;
if
(
options
.
fSubset
)
{
SkIRect
*
subsetPtr
=
options
.
fSubset
;
const
int
subsetX
=
subsetPtr
-
>
x
(
)
/
nativeSampleSize
;
subsetY
=
subsetPtr
-
>
y
(
)
/
nativeSampleSize
;
subsetWidth
=
get_scaled_dimension
(
subsetPtr
-
>
width
(
)
nativeSampleSize
)
;
subsetHeight
=
get_scaled_dimension
(
subsetPtr
-
>
height
(
)
nativeSampleSize
)
;
subset
.
setXYWH
(
subsetX
0
subsetWidth
nativeSize
.
height
(
)
)
;
sampledOptions
.
fSubset
=
&
subset
;
}
SkCodec
:
:
Result
result
=
this
-
>
codec
(
)
-
>
startScanlineDecode
(
info
.
makeWH
(
nativeSize
.
width
(
)
nativeSize
.
height
(
)
)
&
sampledOptions
options
.
fColorPtr
options
.
fColorCount
)
;
if
(
SkCodec
:
:
kSuccess
!
=
result
)
{
return
result
;
}
SkSampler
*
sampler
=
this
-
>
codec
(
)
-
>
getSampler
(
true
)
;
if
(
!
sampler
)
{
return
SkCodec
:
:
kUnimplemented
;
}
const
int
sampleX
=
subsetWidth
/
info
.
width
(
)
;
const
int
sampleY
=
subsetHeight
/
info
.
height
(
)
;
if
(
sampler
-
>
setSampleX
(
sampleX
)
!
=
info
.
width
(
)
)
{
return
SkCodec
:
:
kInvalidScale
;
}
if
(
get_scaled_dimension
(
subsetHeight
sampleY
)
!
=
info
.
height
(
)
)
{
return
SkCodec
:
:
kInvalidScale
;
}
const
int
samplingOffsetY
=
get_start_coord
(
sampleY
)
;
const
int
startY
=
samplingOffsetY
+
subsetY
;
int
dstHeight
=
info
.
height
(
)
;
switch
(
this
-
>
codec
(
)
-
>
getScanlineOrder
(
)
)
{
case
SkCodec
:
:
kTopDown_SkScanlineOrder
:
{
if
(
!
this
-
>
codec
(
)
-
>
skipScanlines
(
startY
)
)
{
this
-
>
codec
(
)
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
.
fZeroInitialized
dstHeight
0
)
;
return
SkCodec
:
:
kIncompleteInput
;
}
void
*
pixelPtr
=
pixels
;
for
(
int
y
=
0
;
y
<
dstHeight
;
y
+
+
)
{
if
(
1
!
=
this
-
>
codec
(
)
-
>
getScanlines
(
pixelPtr
1
rowBytes
)
)
{
this
-
>
codec
(
)
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
.
fZeroInitialized
dstHeight
y
+
1
)
;
return
SkCodec
:
:
kIncompleteInput
;
}
if
(
y
<
dstHeight
-
1
)
{
if
(
!
this
-
>
codec
(
)
-
>
skipScanlines
(
sampleY
-
1
)
)
{
this
-
>
codec
(
)
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
.
fZeroInitialized
dstHeight
y
+
1
)
;
return
SkCodec
:
:
kIncompleteInput
;
}
}
pixelPtr
=
SkTAddOffset
<
void
>
(
pixelPtr
rowBytes
)
;
}
return
SkCodec
:
:
kSuccess
;
}
case
SkCodec
:
:
kOutOfOrder_SkScanlineOrder
:
case
SkCodec
:
:
kBottomUp_SkScanlineOrder
:
{
SkASSERT
(
0
=
=
subsetY
&
&
nativeSize
.
height
(
)
=
=
subsetHeight
)
;
int
y
;
for
(
y
=
0
;
y
<
nativeSize
.
height
(
)
;
y
+
+
)
{
int
srcY
=
this
-
>
codec
(
)
-
>
nextScanline
(
)
;
if
(
is_coord_necessary
(
srcY
sampleY
dstHeight
)
)
{
void
*
pixelPtr
=
SkTAddOffset
<
void
>
(
pixels
rowBytes
*
get_dst_coord
(
srcY
sampleY
)
)
;
if
(
1
!
=
this
-
>
codec
(
)
-
>
getScanlines
(
pixelPtr
1
rowBytes
)
)
{
break
;
}
}
else
{
if
(
!
this
-
>
codec
(
)
-
>
skipScanlines
(
1
)
)
{
break
;
}
}
}
if
(
nativeSize
.
height
(
)
=
=
y
)
{
return
SkCodec
:
:
kSuccess
;
}
const
uint32_t
fillValue
=
this
-
>
codec
(
)
-
>
getFillValue
(
info
.
colorType
(
)
info
.
alphaType
(
)
)
;
const
SkImageInfo
fillInfo
=
info
.
makeWH
(
info
.
width
(
)
1
)
;
for
(
;
y
<
nativeSize
.
height
(
)
;
y
+
+
)
{
int
srcY
=
this
-
>
codec
(
)
-
>
outputScanline
(
y
)
;
if
(
!
is_coord_necessary
(
srcY
sampleY
dstHeight
)
)
{
continue
;
}
void
*
rowPtr
=
SkTAddOffset
<
void
>
(
pixels
rowBytes
*
get_dst_coord
(
srcY
sampleY
)
)
;
SkSampler
:
:
Fill
(
fillInfo
rowPtr
rowBytes
fillValue
options
.
fZeroInitialized
)
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
case
SkCodec
:
:
kNone_SkScanlineOrder
:
{
const
int
linesNeeded
=
subsetHeight
-
samplingOffsetY
;
SkAutoTMalloc
<
uint8_t
>
storage
(
linesNeeded
*
rowBytes
)
;
uint8_t
*
storagePtr
=
storage
.
get
(
)
;
if
(
!
this
-
>
codec
(
)
-
>
skipScanlines
(
startY
)
)
{
this
-
>
codec
(
)
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
.
fZeroInitialized
dstHeight
0
)
;
return
SkCodec
:
:
kIncompleteInput
;
}
int
scanlines
=
this
-
>
codec
(
)
-
>
getScanlines
(
storagePtr
linesNeeded
rowBytes
)
;
for
(
int
y
=
0
;
y
<
dstHeight
;
y
+
+
)
{
memcpy
(
pixels
storagePtr
info
.
minRowBytes
(
)
)
;
storagePtr
+
=
sampleY
*
rowBytes
;
pixels
=
SkTAddOffset
<
void
>
(
pixels
rowBytes
)
;
}
if
(
scanlines
<
dstHeight
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
return
SkCodec
:
:
kSuccess
;
}
default
:
SkASSERT
(
false
)
;
return
SkCodec
:
:
kUnimplemented
;
}
}
