#
include
"
src
/
codec
/
SkJpegSourceMgr
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
ifdef
SK_CODEC_DECODES_JPEG
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
codec
/
SkJpegSegmentScan
.
h
"
#
endif
class
ScopedSkStreamRestorer
{
public
:
ScopedSkStreamRestorer
(
SkStream
*
stream
)
:
fStream
(
stream
)
fPosition
(
stream
-
>
getPosition
(
)
)
{
if
(
!
fStream
-
>
rewind
(
)
)
{
SkCodecPrintf
(
"
Failed
to
rewind
decoder
stream
.
\
n
"
)
;
}
}
~
ScopedSkStreamRestorer
(
)
{
if
(
!
fStream
-
>
seek
(
fPosition
)
)
{
SkCodecPrintf
(
"
Failed
to
restore
decoder
stream
.
\
n
"
)
;
}
}
private
:
SkStream
*
const
fStream
;
const
size_t
fPosition
;
}
;
class
SkJpegMemorySourceMgr
:
public
SkJpegSourceMgr
{
public
:
SkJpegMemorySourceMgr
(
SkStream
*
stream
)
:
SkJpegSourceMgr
(
stream
)
{
}
~
SkJpegMemorySourceMgr
(
)
override
{
}
void
initSource
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
nextInputByte
=
reinterpret_cast
<
const
uint8_t
*
>
(
fStream
-
>
getMemoryBase
(
)
)
;
bytesInBuffer
=
static_cast
<
size_t
>
(
fStream
-
>
getLength
(
)
)
;
}
bool
fillInputBuffer
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
SkCodecPrintf
(
"
Asked
to
re
-
fill
a
memory
-
mapped
stream
.
\
n
"
)
;
return
false
;
}
bool
skipInputBytes
(
size_t
bytesToSkip
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
if
(
bytesToSkip
>
bytesInBuffer
)
{
SkCodecPrintf
(
"
Asked
to
read
past
end
of
a
memory
-
mapped
stream
.
\
n
"
)
;
return
false
;
}
nextInputByte
+
=
bytesToSkip
;
bytesInBuffer
-
=
bytesToSkip
;
return
true
;
}
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
const
std
:
:
vector
<
SkJpegSegment
>
&
getAllSegments
(
)
override
{
if
(
fScanner
)
{
return
fScanner
-
>
getSegments
(
)
;
}
fScanner
=
std
:
:
make_unique
<
SkJpegSegmentScanner
>
(
kJpegMarkerEndOfImage
)
;
fScanner
-
>
onBytes
(
fStream
-
>
getMemoryBase
(
)
fStream
-
>
getLength
(
)
)
;
return
fScanner
-
>
getSegments
(
)
;
}
sk_sp
<
SkData
>
getSubsetData
(
size_t
offset
size_t
size
bool
*
wasCopied
)
override
{
if
(
offset
>
fStream
-
>
getLength
(
)
|
|
size
>
fStream
-
>
getLength
(
)
-
offset
)
{
return
nullptr
;
}
if
(
wasCopied
)
{
*
wasCopied
=
false
;
}
return
SkData
:
:
MakeWithoutCopy
(
reinterpret_cast
<
const
uint8_t
*
>
(
fStream
-
>
getMemoryBase
(
)
)
+
offset
size
)
;
}
sk_sp
<
SkData
>
getSegmentParameters
(
const
SkJpegSegment
&
segment
)
override
{
const
uint8_t
*
base
=
reinterpret_cast
<
const
uint8_t
*
>
(
fStream
-
>
getMemoryBase
(
)
)
+
segment
.
offset
;
SkASSERT
(
segment
.
offset
<
fStream
-
>
getLength
(
)
)
;
SkASSERT
(
kJpegMarkerCodeSize
+
segment
.
parameterLength
<
=
fStream
-
>
getLength
(
)
-
segment
.
offset
)
;
SkASSERT
(
base
[
0
]
=
=
0xFF
)
;
SkASSERT
(
base
[
1
]
=
=
segment
.
marker
)
;
SkASSERT
(
256
*
base
[
2
]
+
base
[
3
]
=
=
segment
.
parameterLength
)
;
if
(
segment
.
parameterLength
<
=
kJpegSegmentParameterLengthSize
)
{
return
nullptr
;
}
return
SkData
:
:
MakeWithoutCopy
(
base
+
kJpegMarkerCodeSize
+
kJpegSegmentParameterLengthSize
segment
.
parameterLength
-
kJpegSegmentParameterLengthSize
)
;
}
#
endif
}
;
class
SkJpegBufferedSourceMgr
:
public
SkJpegSourceMgr
{
public
:
SkJpegBufferedSourceMgr
(
SkStream
*
stream
size_t
bufferSize
)
:
SkJpegSourceMgr
(
stream
)
{
fBuffer
=
SkData
:
:
MakeUninitialized
(
bufferSize
)
;
}
~
SkJpegBufferedSourceMgr
(
)
override
{
}
void
initSource
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
bytesInBuffer
=
0
;
}
bool
fillInputBuffer
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
size_t
bytesRead
=
fStream
-
>
read
(
fBuffer
-
>
writable_data
(
)
fBuffer
-
>
size
(
)
)
;
if
(
bytesRead
=
=
0
)
{
SkCodecPrintf
(
"
Hit
end
of
file
reading
a
buffered
stream
.
\
n
"
)
;
return
false
;
}
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
bytesInBuffer
=
bytesRead
;
return
true
;
}
bool
skipInputBytes
(
size_t
bytesToSkip
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
if
(
bytesToSkip
<
=
bytesInBuffer
)
{
nextInputByte
+
=
bytesToSkip
;
bytesInBuffer
-
=
bytesToSkip
;
return
true
;
}
bytesToSkip
-
=
bytesInBuffer
;
if
(
fStream
-
>
skip
(
bytesToSkip
)
!
=
bytesToSkip
)
{
SkCodecPrintf
(
"
Failed
to
skip
through
buffered
stream
.
\
n
"
)
;
return
false
;
}
bytesInBuffer
=
0
;
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
return
true
;
}
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
const
std
:
:
vector
<
SkJpegSegment
>
&
getAllSegments
(
)
override
{
if
(
fScanner
)
{
return
fScanner
-
>
getSegments
(
)
;
}
ScopedSkStreamRestorer
streamRestorer
(
fStream
)
;
fScanner
=
std
:
:
make_unique
<
SkJpegSegmentScanner
>
(
kJpegMarkerEndOfImage
)
;
while
(
!
fScanner
-
>
isDone
(
)
&
&
!
fScanner
-
>
hadError
(
)
)
{
constexpr
size_t
kBufferSize
=
1024
;
uint8_t
buffer
[
kBufferSize
]
;
size_t
bytesRead
=
fStream
-
>
read
(
buffer
kBufferSize
)
;
if
(
bytesRead
=
=
0
)
{
SkCodecPrintf
(
"
Unexpected
EOF
.
\
n
"
)
;
break
;
}
fScanner
-
>
onBytes
(
buffer
bytesRead
)
;
}
return
fScanner
-
>
getSegments
(
)
;
}
sk_sp
<
SkData
>
getSubsetData
(
size_t
offset
size_t
size
bool
*
wasCopied
)
override
{
ScopedSkStreamRestorer
streamRestorer
(
fStream
)
;
if
(
!
fStream
-
>
seek
(
offset
)
)
{
SkCodecPrintf
(
"
Failed
to
seek
to
subset
stream
position
.
\
n
"
)
;
return
nullptr
;
}
sk_sp
<
SkData
>
data
=
SkData
:
:
MakeUninitialized
(
size
)
;
if
(
fStream
-
>
read
(
data
-
>
writable_data
(
)
size
)
!
=
size
)
{
SkCodecPrintf
(
"
Failed
to
read
subset
stream
data
.
\
n
"
)
;
return
nullptr
;
}
if
(
wasCopied
)
{
*
wasCopied
=
true
;
}
return
data
;
}
sk_sp
<
SkData
>
getSegmentParameters
(
const
SkJpegSegment
&
segment
)
override
{
if
(
segment
.
parameterLength
<
=
kJpegSegmentParameterLengthSize
)
{
return
nullptr
;
}
ScopedSkStreamRestorer
streamRestorer
(
fStream
)
;
if
(
!
fStream
-
>
seek
(
segment
.
offset
)
)
{
SkCodecPrintf
(
"
Failed
to
seek
to
segment
\
n
"
)
;
return
nullptr
;
}
uint8_t
markerCode
[
kJpegMarkerCodeSize
]
=
{
0
}
;
if
(
fStream
-
>
read
(
markerCode
kJpegMarkerCodeSize
)
!
=
kJpegMarkerCodeSize
)
{
SkCodecPrintf
(
"
Failed
to
read
segment
marker
code
\
n
"
)
;
return
nullptr
;
}
SkASSERT
(
markerCode
[
0
]
=
=
0xFF
)
;
SkASSERT
(
markerCode
[
1
]
=
=
segment
.
marker
)
;
uint8_t
parameterLength
[
kJpegSegmentParameterLengthSize
]
=
{
0
}
;
if
(
fStream
-
>
read
(
parameterLength
kJpegSegmentParameterLengthSize
)
!
=
kJpegSegmentParameterLengthSize
)
{
SkCodecPrintf
(
"
Failed
to
read
parameter
length
\
n
"
)
;
return
nullptr
;
}
SkASSERT
(
256
*
parameterLength
[
0
]
+
parameterLength
[
1
]
=
=
segment
.
parameterLength
)
;
size_t
sizeToRead
=
segment
.
parameterLength
-
kJpegSegmentParameterLengthSize
;
auto
result
=
SkData
:
:
MakeUninitialized
(
sizeToRead
)
;
if
(
fStream
-
>
read
(
result
-
>
writable_data
(
)
sizeToRead
)
!
=
sizeToRead
)
{
return
nullptr
;
}
return
result
;
}
#
endif
private
:
sk_sp
<
SkData
>
fBuffer
;
}
;
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
class
SkJpegUnseekableSourceMgr
:
public
SkJpegSourceMgr
{
public
:
SkJpegUnseekableSourceMgr
(
SkStream
*
stream
size_t
bufferSize
)
:
SkJpegSourceMgr
(
stream
)
{
fBuffer
=
SkData
:
:
MakeUninitialized
(
bufferSize
)
;
fScanner
=
std
:
:
make_unique
<
SkJpegSegmentScanner
>
(
kJpegMarkerEndOfImage
)
;
}
~
SkJpegUnseekableSourceMgr
(
)
override
{
}
void
initSource
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
bytesInBuffer
=
0
;
}
bool
fillInputBuffer
(
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
if
(
!
readToBufferAndScan
(
fBuffer
-
>
size
(
)
)
)
{
SkCodecPrintf
(
"
Failure
filling
unseekable
input
buffer
.
\
n
"
)
;
return
false
;
}
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
bytesInBuffer
=
fLastReadSize
;
return
true
;
}
bool
skipInputBytes
(
size_t
bytesToSkip
const
uint8_t
*
&
nextInputByte
size_t
&
bytesInBuffer
)
override
{
if
(
bytesToSkip
<
=
bytesInBuffer
)
{
nextInputByte
+
=
bytesToSkip
;
bytesInBuffer
-
=
bytesToSkip
;
return
true
;
}
bytesToSkip
-
=
bytesInBuffer
;
while
(
bytesToSkip
>
0
)
{
if
(
!
readToBufferAndScan
(
std
:
:
min
(
bytesToSkip
fBuffer
-
>
size
(
)
)
)
)
{
SkCodecPrintf
(
"
Failure
filling
unseekable
input
buffer
.
\
n
"
)
;
return
false
;
}
bytesToSkip
-
=
fLastReadSize
;
}
bytesInBuffer
=
0
;
nextInputByte
=
fBuffer
-
>
bytes
(
)
;
return
true
;
}
const
std
:
:
vector
<
SkJpegSegment
>
&
getAllSegments
(
)
override
{
while
(
!
fScanner
-
>
isDone
(
)
&
&
!
fScanner
-
>
hadError
(
)
)
{
if
(
!
readToBufferAndScan
(
fBuffer
-
>
size
(
)
)
)
{
SkCodecPrintf
(
"
Failure
finishing
unseekable
input
buffer
.
\
n
"
)
;
break
;
}
}
return
fScanner
-
>
getSegments
(
)
;
}
sk_sp
<
SkData
>
getSubsetData
(
size_t
offset
size_t
size
bool
*
wasCopied
)
override
{
if
(
!
fScanner
-
>
isDone
(
)
)
{
SkCodecPrintf
(
"
getSubsetData
is
prematurely
terminating
scan
.
\
n
"
)
;
}
if
(
offset
<
fLastReadOffset
)
{
SkCodecPrintf
(
"
Requested
that
is
gone
.
\
n
"
)
;
return
nullptr
;
}
sk_sp
<
SkData
>
subsetData
=
SkData
:
:
MakeUninitialized
(
size
)
;
uint8_t
*
subsetDataCurrent
=
reinterpret_cast
<
uint8_t
*
>
(
subsetData
-
>
writable_data
(
)
)
;
size_t
offsetIntoBuffer
=
offset
-
fLastReadOffset
;
if
(
offsetIntoBuffer
>
=
fLastReadSize
)
{
fLastReadOffset
+
=
fLastReadSize
;
fLastReadSize
=
0
;
size_t
bytesToSkip
=
offset
-
fLastReadOffset
;
while
(
bytesToSkip
>
0
)
{
size_t
bytesSkipped
=
fStream
-
>
skip
(
bytesToSkip
)
;
if
(
bytesSkipped
=
=
0
)
{
SkCodecPrintf
(
"
Failed
to
skip
bytes
before
subset
.
\
n
"
)
;
return
nullptr
;
}
bytesToSkip
-
=
bytesSkipped
;
fLastReadOffset
+
=
bytesSkipped
;
}
}
else
{
SkASSERT
(
offsetIntoBuffer
<
fLastReadSize
)
;
size_t
bytesToReadFromBuffer
=
std
:
:
min
(
fLastReadSize
-
offsetIntoBuffer
size
)
;
memcpy
(
subsetDataCurrent
fBuffer
-
>
bytes
(
)
+
offsetIntoBuffer
bytesToReadFromBuffer
)
;
size
-
=
bytesToReadFromBuffer
;
subsetDataCurrent
+
=
bytesToReadFromBuffer
;
if
(
size
=
=
0
)
{
if
(
wasCopied
)
{
*
wasCopied
=
true
;
}
return
subsetData
;
}
fLastReadOffset
+
=
fLastReadSize
;
fLastReadSize
=
0
;
}
while
(
size
>
0
)
{
size_t
bytesRead
=
fStream
-
>
read
(
subsetDataCurrent
size
)
;
if
(
bytesRead
=
=
0
)
{
SkCodecPrintf
(
"
Failed
to
read
subset
stream
data
.
\
n
"
)
;
return
nullptr
;
}
size
-
=
bytesRead
;
subsetDataCurrent
+
=
bytesRead
;
fLastReadOffset
+
=
bytesRead
;
}
if
(
wasCopied
)
{
*
wasCopied
=
true
;
}
return
subsetData
;
}
sk_sp
<
SkData
>
getSegmentParameters
(
const
SkJpegSegment
&
segment
)
override
{
return
nullptr
;
}
private
:
bool
readToBufferAndScan
(
size_t
bytesToRead
)
{
SkASSERT
(
bytesToRead
<
=
fBuffer
-
>
size
(
)
)
;
fLastReadOffset
+
=
fLastReadSize
;
fLastReadSize
=
fStream
-
>
read
(
fBuffer
-
>
writable_data
(
)
bytesToRead
)
;
if
(
fLastReadSize
=
=
0
)
{
SkCodecPrintf
(
"
Hit
end
of
file
reading
an
unseekable
stream
.
\
n
"
)
;
return
false
;
}
fScanner
-
>
onBytes
(
fBuffer
-
>
bytes
(
)
fLastReadSize
)
;
return
true
;
}
sk_sp
<
SkData
>
fBuffer
;
size_t
fLastReadSize
=
0
;
size_t
fLastReadOffset
=
0
;
}
;
#
endif
std
:
:
unique_ptr
<
SkJpegSourceMgr
>
SkJpegSourceMgr
:
:
Make
(
SkStream
*
stream
size_t
bufferSize
)
{
#
ifdef
SK_CODEC_DECODES_JPEG_GAINMAPS
if
(
!
stream
-
>
hasPosition
(
)
)
{
return
std
:
:
make_unique
<
SkJpegUnseekableSourceMgr
>
(
stream
bufferSize
)
;
}
#
endif
if
(
stream
-
>
hasLength
(
)
&
&
stream
-
>
getMemoryBase
(
)
)
{
return
std
:
:
make_unique
<
SkJpegMemorySourceMgr
>
(
stream
)
;
}
return
std
:
:
make_unique
<
SkJpegBufferedSourceMgr
>
(
stream
bufferSize
)
;
}
SkJpegSourceMgr
:
:
SkJpegSourceMgr
(
SkStream
*
stream
)
:
fStream
(
stream
)
{
}
SkJpegSourceMgr
:
:
~
SkJpegSourceMgr
(
)
=
default
;
#
else
std
:
:
unique_ptr
<
SkJpegSourceMgr
>
SkJpegSourceMgr
:
:
Make
(
SkStream
*
stream
size_t
bufferSize
)
{
return
nullptr
;
}
SkJpegSourceMgr
:
:
SkJpegSourceMgr
(
SkStream
*
stream
)
:
fStream
(
nullptr
)
{
}
SkJpegSourceMgr
:
:
~
SkJpegSourceMgr
(
)
=
default
;
#
endif
