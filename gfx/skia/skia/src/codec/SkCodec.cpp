#
include
"
SkBmpCodec
.
h
"
#
include
"
SkCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkGifCodec
.
h
"
#
include
"
SkHalf
.
h
"
#
include
"
SkIcoCodec
.
h
"
#
include
"
SkJpegCodec
.
h
"
#
ifdef
SK_HAS_PNG_LIBRARY
#
include
"
SkPngCodec
.
h
"
#
endif
#
include
"
SkRawCodec
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkWbmpCodec
.
h
"
#
include
"
SkWebpCodec
.
h
"
struct
DecoderProc
{
bool
(
*
IsFormat
)
(
const
void
*
size_t
)
;
SkCodec
*
(
*
NewFromStream
)
(
SkStream
*
)
;
}
;
static
const
DecoderProc
gDecoderProcs
[
]
=
{
#
ifdef
SK_HAS_JPEG_LIBRARY
{
SkJpegCodec
:
:
IsJpeg
SkJpegCodec
:
:
NewFromStream
}
#
endif
#
ifdef
SK_HAS_WEBP_LIBRARY
{
SkWebpCodec
:
:
IsWebp
SkWebpCodec
:
:
NewFromStream
}
#
endif
#
ifdef
SK_HAS_GIF_LIBRARY
{
SkGifCodec
:
:
IsGif
SkGifCodec
:
:
NewFromStream
}
#
endif
#
ifdef
SK_HAS_PNG_LIBRARY
{
SkIcoCodec
:
:
IsIco
SkIcoCodec
:
:
NewFromStream
}
#
endif
{
SkBmpCodec
:
:
IsBmp
SkBmpCodec
:
:
NewFromStream
}
{
SkWbmpCodec
:
:
IsWbmp
SkWbmpCodec
:
:
NewFromStream
}
}
;
size_t
SkCodec
:
:
MinBufferedBytesNeeded
(
)
{
return
WEBP_VP8_HEADER_SIZE
;
}
SkCodec
*
SkCodec
:
:
NewFromStream
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
)
{
if
(
!
stream
)
{
return
nullptr
;
}
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
const
size_t
bytesToRead
=
14
;
SkASSERT
(
bytesToRead
<
=
MinBufferedBytesNeeded
(
)
)
;
char
buffer
[
bytesToRead
]
;
size_t
bytesRead
=
stream
-
>
peek
(
buffer
bytesToRead
)
;
if
(
0
=
=
bytesRead
)
{
bytesRead
=
stream
-
>
read
(
buffer
bytesToRead
)
;
if
(
!
stream
-
>
rewind
(
)
)
{
SkCodecPrintf
(
"
Encoded
image
data
could
not
peek
or
rewind
to
determine
format
!
\
n
"
)
;
return
nullptr
;
}
}
#
ifdef
SK_HAS_PNG_LIBRARY
if
(
SkPngCodec
:
:
IsPng
(
buffer
bytesRead
)
)
{
return
SkPngCodec
:
:
NewFromStream
(
streamDeleter
.
release
(
)
chunkReader
)
;
}
else
#
endif
{
for
(
DecoderProc
proc
:
gDecoderProcs
)
{
if
(
proc
.
IsFormat
(
buffer
bytesRead
)
)
{
return
proc
.
NewFromStream
(
streamDeleter
.
release
(
)
)
;
}
}
#
ifdef
SK_CODEC_DECODES_RAW
return
SkRawCodec
:
:
NewFromStream
(
streamDeleter
.
release
(
)
)
;
#
endif
}
return
nullptr
;
}
SkCodec
*
SkCodec
:
:
NewFromData
(
sk_sp
<
SkData
>
data
SkPngChunkReader
*
reader
)
{
if
(
!
data
)
{
return
nullptr
;
}
return
NewFromStream
(
new
SkMemoryStream
(
data
)
reader
)
;
}
SkCodec
:
:
SkCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
SkStream
*
stream
sk_sp
<
SkColorSpace
>
colorSpace
Origin
origin
)
:
fEncodedInfo
(
info
)
fSrcInfo
(
info
.
makeImageInfo
(
width
height
std
:
:
move
(
colorSpace
)
)
)
fStream
(
stream
)
fNeedsRewind
(
false
)
fOrigin
(
origin
)
fDstInfo
(
)
fOptions
(
)
fCurrScanline
(
-
1
)
{
}
SkCodec
:
:
SkCodec
(
const
SkEncodedInfo
&
info
const
SkImageInfo
&
imageInfo
SkStream
*
stream
Origin
origin
)
:
fEncodedInfo
(
info
)
fSrcInfo
(
imageInfo
)
fStream
(
stream
)
fNeedsRewind
(
false
)
fOrigin
(
origin
)
fDstInfo
(
)
fOptions
(
)
fCurrScanline
(
-
1
)
{
}
SkCodec
:
:
~
SkCodec
(
)
{
}
bool
SkCodec
:
:
rewindIfNeeded
(
)
{
if
(
!
fStream
)
{
return
true
;
}
const
bool
needsRewind
=
fNeedsRewind
;
fNeedsRewind
=
true
;
if
(
!
needsRewind
)
{
return
true
;
}
fCurrScanline
=
-
1
;
fStartedIncrementalDecode
=
false
;
if
(
!
fStream
-
>
rewind
(
)
)
{
return
false
;
}
return
this
-
>
onRewind
(
)
;
}
#
define
CHECK_COLOR_TABLE
\
if
(
kIndex_8_SkColorType
=
=
info
.
colorType
(
)
)
{
\
if
(
nullptr
=
=
ctable
|
|
nullptr
=
=
ctableCount
)
{
\
return
SkCodec
:
:
kInvalidParameters
;
\
}
\
}
else
{
\
if
(
ctableCount
)
{
\
*
ctableCount
=
0
;
\
}
\
ctableCount
=
nullptr
;
\
ctable
=
nullptr
;
\
}
SkCodec
:
:
Result
SkCodec
:
:
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
Options
*
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
kUnknown_SkColorType
=
=
info
.
colorType
(
)
)
{
return
kInvalidConversion
;
}
if
(
nullptr
=
=
pixels
)
{
return
kInvalidParameters
;
}
if
(
rowBytes
<
info
.
minRowBytes
(
)
)
{
return
kInvalidParameters
;
}
CHECK_COLOR_TABLE
;
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
Options
optsStorage
;
if
(
nullptr
=
=
options
)
{
options
=
&
optsStorage
;
}
else
if
(
options
-
>
fSubset
)
{
SkIRect
subset
(
*
options
-
>
fSubset
)
;
if
(
!
this
-
>
onGetValidSubset
(
&
subset
)
|
|
subset
!
=
*
options
-
>
fSubset
)
{
return
kUnimplemented
;
}
}
if
(
!
this
-
>
dimensionsSupported
(
info
.
dimensions
(
)
)
)
{
return
kInvalidScale
;
}
fDstInfo
=
info
;
int
rowsDecoded
=
0
;
const
Result
result
=
this
-
>
onGetPixels
(
info
pixels
rowBytes
*
options
ctable
ctableCount
&
rowsDecoded
)
;
if
(
(
kIncompleteInput
=
=
result
|
|
kSuccess
=
=
result
)
&
&
ctableCount
)
{
SkASSERT
(
*
ctableCount
>
=
0
&
&
*
ctableCount
<
=
256
)
;
}
if
(
kIncompleteInput
=
=
result
&
&
rowsDecoded
!
=
info
.
height
(
)
)
{
this
-
>
fillIncompleteImage
(
info
pixels
rowBytes
options
-
>
fZeroInitialized
info
.
height
(
)
rowsDecoded
)
;
}
return
result
;
}
SkCodec
:
:
Result
SkCodec
:
:
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
)
{
return
this
-
>
getPixels
(
info
pixels
rowBytes
nullptr
nullptr
nullptr
)
;
}
SkCodec
:
:
Result
SkCodec
:
:
startIncrementalDecode
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
SkCodec
:
:
Options
*
options
SkPMColor
*
ctable
int
*
ctableCount
)
{
fStartedIncrementalDecode
=
false
;
if
(
kUnknown_SkColorType
=
=
info
.
colorType
(
)
)
{
return
kInvalidConversion
;
}
if
(
nullptr
=
=
pixels
)
{
return
kInvalidParameters
;
}
CHECK_COLOR_TABLE
;
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
Options
optsStorage
;
if
(
nullptr
=
=
options
)
{
options
=
&
optsStorage
;
}
else
if
(
options
-
>
fSubset
)
{
SkIRect
size
=
SkIRect
:
:
MakeSize
(
info
.
dimensions
(
)
)
;
if
(
!
size
.
contains
(
*
options
-
>
fSubset
)
)
{
return
kInvalidParameters
;
}
const
int
top
=
options
-
>
fSubset
-
>
top
(
)
;
const
int
bottom
=
options
-
>
fSubset
-
>
bottom
(
)
;
if
(
top
<
0
|
|
top
>
=
info
.
height
(
)
|
|
top
>
=
bottom
|
|
bottom
>
info
.
height
(
)
)
{
return
kInvalidParameters
;
}
}
if
(
!
this
-
>
dimensionsSupported
(
info
.
dimensions
(
)
)
)
{
return
kInvalidScale
;
}
fDstInfo
=
info
;
fOptions
=
*
options
;
const
Result
result
=
this
-
>
onStartIncrementalDecode
(
info
pixels
rowBytes
fOptions
ctable
ctableCount
)
;
if
(
kSuccess
=
=
result
)
{
fStartedIncrementalDecode
=
true
;
}
else
if
(
kUnimplemented
=
=
result
)
{
fNeedsRewind
=
false
;
}
return
result
;
}
SkCodec
:
:
Result
SkCodec
:
:
startScanlineDecode
(
const
SkImageInfo
&
info
const
SkCodec
:
:
Options
*
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
fCurrScanline
=
-
1
;
CHECK_COLOR_TABLE
;
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
Options
optsStorage
;
if
(
nullptr
=
=
options
)
{
options
=
&
optsStorage
;
}
else
if
(
options
-
>
fSubset
)
{
SkIRect
size
=
SkIRect
:
:
MakeSize
(
info
.
dimensions
(
)
)
;
if
(
!
size
.
contains
(
*
options
-
>
fSubset
)
)
{
return
kInvalidInput
;
}
if
(
options
-
>
fSubset
-
>
top
(
)
!
=
0
|
|
options
-
>
fSubset
-
>
height
(
)
!
=
info
.
height
(
)
)
{
return
kInvalidInput
;
}
}
if
(
!
this
-
>
dimensionsSupported
(
info
.
dimensions
(
)
)
)
{
return
kInvalidScale
;
}
const
Result
result
=
this
-
>
onStartScanlineDecode
(
info
*
options
ctable
ctableCount
)
;
if
(
result
!
=
SkCodec
:
:
kSuccess
)
{
return
result
;
}
fCurrScanline
=
0
;
fDstInfo
=
info
;
fOptions
=
*
options
;
return
kSuccess
;
}
#
undef
CHECK_COLOR_TABLE
SkCodec
:
:
Result
SkCodec
:
:
startScanlineDecode
(
const
SkImageInfo
&
info
)
{
return
this
-
>
startScanlineDecode
(
info
nullptr
nullptr
nullptr
)
;
}
int
SkCodec
:
:
getScanlines
(
void
*
dst
int
countLines
size_t
rowBytes
)
{
if
(
fCurrScanline
<
0
)
{
return
0
;
}
SkASSERT
(
!
fDstInfo
.
isEmpty
(
)
)
;
if
(
countLines
<
=
0
|
|
fCurrScanline
+
countLines
>
fDstInfo
.
height
(
)
)
{
return
0
;
}
const
int
linesDecoded
=
this
-
>
onGetScanlines
(
dst
countLines
rowBytes
)
;
if
(
linesDecoded
<
countLines
)
{
this
-
>
fillIncompleteImage
(
this
-
>
dstInfo
(
)
dst
rowBytes
this
-
>
options
(
)
.
fZeroInitialized
countLines
linesDecoded
)
;
}
fCurrScanline
+
=
countLines
;
return
linesDecoded
;
}
bool
SkCodec
:
:
skipScanlines
(
int
countLines
)
{
if
(
fCurrScanline
<
0
)
{
return
false
;
}
SkASSERT
(
!
fDstInfo
.
isEmpty
(
)
)
;
if
(
countLines
<
0
|
|
fCurrScanline
+
countLines
>
fDstInfo
.
height
(
)
)
{
return
false
;
}
bool
result
=
this
-
>
onSkipScanlines
(
countLines
)
;
fCurrScanline
+
=
countLines
;
return
result
;
}
int
SkCodec
:
:
outputScanline
(
int
inputScanline
)
const
{
SkASSERT
(
0
<
=
inputScanline
&
&
inputScanline
<
this
-
>
getInfo
(
)
.
height
(
)
)
;
return
this
-
>
onOutputScanline
(
inputScanline
)
;
}
int
SkCodec
:
:
onOutputScanline
(
int
inputScanline
)
const
{
switch
(
this
-
>
getScanlineOrder
(
)
)
{
case
kTopDown_SkScanlineOrder
:
return
inputScanline
;
case
kBottomUp_SkScanlineOrder
:
return
this
-
>
getInfo
(
)
.
height
(
)
-
inputScanline
-
1
;
default
:
SkASSERT
(
false
)
;
return
0
;
}
}
uint64_t
SkCodec
:
:
onGetFillValue
(
const
SkImageInfo
&
dstInfo
)
const
{
switch
(
dstInfo
.
colorType
(
)
)
{
case
kRGBA_F16_SkColorType
:
{
static
constexpr
uint64_t
transparentColor
=
0
;
static
constexpr
uint64_t
opaqueColor
=
(
(
uint64_t
)
SK_Half1
)
<
<
48
;
return
(
kOpaque_SkAlphaType
=
=
fSrcInfo
.
alphaType
(
)
)
?
opaqueColor
:
transparentColor
;
}
default
:
{
return
(
kOpaque_SkAlphaType
=
=
fSrcInfo
.
alphaType
(
)
)
?
SK_ColorBLACK
:
SK_ColorTRANSPARENT
;
}
}
}
static
void
fill_proc
(
const
SkImageInfo
&
info
void
*
dst
size_t
rowBytes
uint64_t
colorOrIndex
SkCodec
:
:
ZeroInitialized
zeroInit
SkSampler
*
sampler
)
{
if
(
sampler
)
{
sampler
-
>
fill
(
info
dst
rowBytes
colorOrIndex
zeroInit
)
;
}
else
{
SkSampler
:
:
Fill
(
info
dst
rowBytes
colorOrIndex
zeroInit
)
;
}
}
void
SkCodec
:
:
fillIncompleteImage
(
const
SkImageInfo
&
info
void
*
dst
size_t
rowBytes
ZeroInitialized
zeroInit
int
linesRequested
int
linesDecoded
)
{
void
*
fillDst
;
const
uint64_t
fillValue
=
this
-
>
getFillValue
(
info
)
;
const
int
linesRemaining
=
linesRequested
-
linesDecoded
;
SkSampler
*
sampler
=
this
-
>
getSampler
(
false
)
;
int
fillWidth
=
info
.
width
(
)
;
if
(
fOptions
.
fSubset
)
{
fillWidth
=
fOptions
.
fSubset
-
>
width
(
)
;
}
switch
(
this
-
>
getScanlineOrder
(
)
)
{
case
kTopDown_SkScanlineOrder
:
{
const
SkImageInfo
fillInfo
=
info
.
makeWH
(
fillWidth
linesRemaining
)
;
fillDst
=
SkTAddOffset
<
void
>
(
dst
linesDecoded
*
rowBytes
)
;
fill_proc
(
fillInfo
fillDst
rowBytes
fillValue
zeroInit
sampler
)
;
break
;
}
case
kBottomUp_SkScanlineOrder
:
{
fillDst
=
dst
;
const
SkImageInfo
fillInfo
=
info
.
makeWH
(
fillWidth
linesRemaining
)
;
fill_proc
(
fillInfo
fillDst
rowBytes
fillValue
zeroInit
sampler
)
;
break
;
}
case
kOutOfOrder_SkScanlineOrder
:
{
SkASSERT
(
1
=
=
linesRequested
|
|
this
-
>
getInfo
(
)
.
height
(
)
=
=
linesRequested
)
;
const
SkImageInfo
fillInfo
=
info
.
makeWH
(
fillWidth
1
)
;
for
(
int
srcY
=
linesDecoded
;
srcY
<
linesRequested
;
srcY
+
+
)
{
fillDst
=
SkTAddOffset
<
void
>
(
dst
this
-
>
outputScanline
(
srcY
)
*
rowBytes
)
;
fill_proc
(
fillInfo
fillDst
rowBytes
fillValue
zeroInit
sampler
)
;
}
break
;
}
}
}
