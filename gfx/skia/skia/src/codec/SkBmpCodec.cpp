#
include
"
SkBmpCodec
.
h
"
#
include
"
SkBmpMaskCodec
.
h
"
#
include
"
SkBmpRLECodec
.
h
"
#
include
"
SkBmpStandardCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkStream
.
h
"
enum
BmpHeaderType
{
kInfoV1_BmpHeaderType
kInfoV2_BmpHeaderType
kInfoV3_BmpHeaderType
kInfoV4_BmpHeaderType
kInfoV5_BmpHeaderType
kOS2V1_BmpHeaderType
kOS2VX_BmpHeaderType
kUnknown_BmpHeaderType
}
;
enum
BmpCompressionMethod
{
kNone_BmpCompressionMethod
=
0
k8BitRLE_BmpCompressionMethod
=
1
k4BitRLE_BmpCompressionMethod
=
2
kBitMasks_BmpCompressionMethod
=
3
kJpeg_BmpCompressionMethod
=
4
kPng_BmpCompressionMethod
=
5
kAlphaBitMasks_BmpCompressionMethod
=
6
kCMYK_BmpCompressionMethod
=
11
kCMYK8BitRLE_BmpCompressionMethod
=
12
kCMYK4BitRLE_BmpCompressionMethod
=
13
}
;
enum
BmpInputFormat
{
kStandard_BmpInputFormat
kRLE_BmpInputFormat
kBitMask_BmpInputFormat
kUnknown_BmpInputFormat
}
;
bool
SkBmpCodec
:
:
IsBmp
(
const
void
*
buffer
size_t
bytesRead
)
{
const
char
bmpSig
[
]
=
{
'
B
'
'
M
'
}
;
return
bytesRead
>
=
sizeof
(
bmpSig
)
&
&
!
memcmp
(
buffer
bmpSig
sizeof
(
bmpSig
)
)
;
}
SkCodec
*
SkBmpCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
return
SkBmpCodec
:
:
NewFromStream
(
stream
false
)
;
}
SkCodec
*
SkBmpCodec
:
:
NewFromIco
(
SkStream
*
stream
)
{
return
SkBmpCodec
:
:
NewFromStream
(
stream
true
)
;
}
bool
SkBmpCodec
:
:
ReadHeader
(
SkStream
*
stream
bool
inIco
SkCodec
*
*
codecOut
)
{
static
const
uint32_t
kBmpHeaderBytes
=
14
;
static
const
uint32_t
kBmpHeaderBytesPlusFour
=
kBmpHeaderBytes
+
4
;
static
const
uint32_t
kBmpOS2V1Bytes
=
12
;
static
const
uint32_t
kBmpOS2V2Bytes
=
64
;
static
const
uint32_t
kBmpInfoBaseBytes
=
16
;
static
const
uint32_t
kBmpInfoV1Bytes
=
40
;
static
const
uint32_t
kBmpInfoV2Bytes
=
52
;
static
const
uint32_t
kBmpInfoV3Bytes
=
56
;
static
const
uint32_t
kBmpInfoV4Bytes
=
108
;
static
const
uint32_t
kBmpInfoV5Bytes
=
124
;
static
const
uint32_t
kBmpMaskBytes
=
12
;
uint32_t
totalBytes
;
uint32_t
offset
;
uint32_t
infoBytes
;
if
(
!
inIco
)
{
SkAutoTDeleteArray
<
uint8_t
>
hBuffer
(
new
uint8_t
[
kBmpHeaderBytesPlusFour
]
)
;
if
(
stream
-
>
read
(
hBuffer
.
get
(
)
kBmpHeaderBytesPlusFour
)
!
=
kBmpHeaderBytesPlusFour
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
first
bitmap
header
.
\
n
"
)
;
return
false
;
}
totalBytes
=
get_int
(
hBuffer
.
get
(
)
2
)
;
offset
=
get_int
(
hBuffer
.
get
(
)
10
)
;
if
(
offset
<
kBmpHeaderBytes
+
kBmpOS2V1Bytes
)
{
SkCodecPrintf
(
"
Error
:
invalid
starting
location
for
pixel
data
\
n
"
)
;
return
false
;
}
infoBytes
=
get_int
(
hBuffer
.
get
(
)
14
)
;
if
(
infoBytes
<
kBmpOS2V1Bytes
)
{
SkCodecPrintf
(
"
Error
:
invalid
second
header
size
.
\
n
"
)
;
return
false
;
}
}
else
{
totalBytes
=
0
;
offset
=
0
;
SkAutoTDeleteArray
<
uint8_t
>
hBuffer
(
new
uint8_t
[
4
]
)
;
if
(
stream
-
>
read
(
hBuffer
.
get
(
)
4
)
!
=
4
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
size
of
second
bitmap
header
.
\
n
"
)
;
return
false
;
}
infoBytes
=
get_int
(
hBuffer
.
get
(
)
0
)
;
if
(
infoBytes
<
kBmpOS2V1Bytes
)
{
SkCodecPrintf
(
"
Error
:
invalid
second
header
size
.
\
n
"
)
;
return
false
;
}
}
const
uint32_t
infoBytesRemaining
=
infoBytes
-
4
;
SkAutoTDeleteArray
<
uint8_t
>
iBuffer
(
new
uint8_t
[
infoBytesRemaining
]
)
;
if
(
stream
-
>
read
(
iBuffer
.
get
(
)
infoBytesRemaining
)
!
=
infoBytesRemaining
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
second
bitmap
header
.
\
n
"
)
;
return
false
;
}
uint16_t
bitsPerPixel
;
uint32_t
compression
=
kNone_BmpCompressionMethod
;
uint32_t
numColors
=
0
;
uint32_t
bytesPerColor
;
int
width
height
;
BmpHeaderType
headerType
;
if
(
infoBytes
>
=
kBmpInfoBaseBytes
)
{
switch
(
infoBytes
)
{
case
kBmpInfoV1Bytes
:
headerType
=
kInfoV1_BmpHeaderType
;
break
;
case
kBmpInfoV2Bytes
:
headerType
=
kInfoV2_BmpHeaderType
;
break
;
case
kBmpInfoV3Bytes
:
headerType
=
kInfoV3_BmpHeaderType
;
break
;
case
kBmpInfoV4Bytes
:
headerType
=
kInfoV4_BmpHeaderType
;
break
;
case
kBmpInfoV5Bytes
:
headerType
=
kInfoV5_BmpHeaderType
;
break
;
case
16
:
case
20
:
case
24
:
case
28
:
case
32
:
case
36
:
case
42
:
case
46
:
case
48
:
case
60
:
case
kBmpOS2V2Bytes
:
headerType
=
kOS2VX_BmpHeaderType
;
break
;
default
:
SkCodecPrintf
(
"
Warning
:
unknown
bmp
header
format
.
\
n
"
)
;
headerType
=
kUnknown_BmpHeaderType
;
break
;
}
SkASSERT
(
infoBytesRemaining
>
=
12
)
;
width
=
get_int
(
iBuffer
.
get
(
)
0
)
;
height
=
get_int
(
iBuffer
.
get
(
)
4
)
;
bitsPerPixel
=
get_short
(
iBuffer
.
get
(
)
10
)
;
if
(
infoBytesRemaining
>
=
16
)
{
compression
=
get_int
(
iBuffer
.
get
(
)
12
)
;
if
(
infoBytesRemaining
>
=
32
)
{
numColors
=
get_int
(
iBuffer
.
get
(
)
28
)
;
}
}
bytesPerColor
=
4
;
}
else
if
(
infoBytes
>
=
kBmpOS2V1Bytes
)
{
headerType
=
kOS2V1_BmpHeaderType
;
width
=
(
int
)
get_short
(
iBuffer
.
get
(
)
0
)
;
height
=
(
int
)
get_short
(
iBuffer
.
get
(
)
2
)
;
bitsPerPixel
=
get_short
(
iBuffer
.
get
(
)
6
)
;
bytesPerColor
=
3
;
}
else
{
SkCodecPrintf
(
"
Error
:
second
bitmap
header
size
is
invalid
.
\
n
"
)
;
return
false
;
}
SkCodec
:
:
SkScanlineOrder
rowOrder
=
SkCodec
:
:
kBottomUp_SkScanlineOrder
;
if
(
height
<
0
)
{
height
=
-
height
;
rowOrder
=
SkCodec
:
:
kTopDown_SkScanlineOrder
;
}
if
(
inIco
)
{
height
/
=
2
;
}
if
(
width
<
=
0
|
|
height
<
=
0
)
{
SkCodecPrintf
(
"
Error
:
invalid
bitmap
dimensions
.
\
n
"
)
;
return
false
;
}
SkMasks
:
:
InputMasks
inputMasks
;
memset
(
&
inputMasks
0
sizeof
(
SkMasks
:
:
InputMasks
)
)
;
uint32_t
maskBytes
=
0
;
BmpInputFormat
inputFormat
=
kUnknown_BmpInputFormat
;
switch
(
compression
)
{
case
kNone_BmpCompressionMethod
:
inputFormat
=
kStandard_BmpInputFormat
;
if
(
16
=
=
bitsPerPixel
)
{
inputMasks
.
red
=
0x7C00
;
inputMasks
.
green
=
0x03E0
;
inputMasks
.
blue
=
0x001F
;
inputFormat
=
kBitMask_BmpInputFormat
;
}
break
;
case
k8BitRLE_BmpCompressionMethod
:
if
(
bitsPerPixel
!
=
8
)
{
SkCodecPrintf
(
"
Warning
:
correcting
invalid
bitmap
format
.
\
n
"
)
;
bitsPerPixel
=
8
;
}
inputFormat
=
kRLE_BmpInputFormat
;
break
;
case
k4BitRLE_BmpCompressionMethod
:
if
(
bitsPerPixel
!
=
4
)
{
SkCodecPrintf
(
"
Warning
:
correcting
invalid
bitmap
format
.
\
n
"
)
;
bitsPerPixel
=
4
;
}
inputFormat
=
kRLE_BmpInputFormat
;
break
;
case
kAlphaBitMasks_BmpCompressionMethod
:
case
kBitMasks_BmpCompressionMethod
:
inputFormat
=
kBitMask_BmpInputFormat
;
switch
(
headerType
)
{
case
kInfoV1_BmpHeaderType
:
{
SkAutoTDeleteArray
<
uint8_t
>
mBuffer
(
new
uint8_t
[
kBmpMaskBytes
]
)
;
if
(
stream
-
>
read
(
mBuffer
.
get
(
)
kBmpMaskBytes
)
!
=
kBmpMaskBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
bit
inputMasks
.
\
n
"
)
;
return
false
;
}
maskBytes
=
kBmpMaskBytes
;
inputMasks
.
red
=
get_int
(
mBuffer
.
get
(
)
0
)
;
inputMasks
.
green
=
get_int
(
mBuffer
.
get
(
)
4
)
;
inputMasks
.
blue
=
get_int
(
mBuffer
.
get
(
)
8
)
;
break
;
}
case
kInfoV2_BmpHeaderType
:
case
kInfoV3_BmpHeaderType
:
case
kInfoV4_BmpHeaderType
:
case
kInfoV5_BmpHeaderType
:
SkASSERT
(
infoBytesRemaining
>
=
48
)
;
inputMasks
.
red
=
get_int
(
iBuffer
.
get
(
)
36
)
;
inputMasks
.
green
=
get_int
(
iBuffer
.
get
(
)
40
)
;
inputMasks
.
blue
=
get_int
(
iBuffer
.
get
(
)
44
)
;
if
(
kInfoV2_BmpHeaderType
=
=
headerType
|
|
(
kInfoV3_BmpHeaderType
=
=
headerType
&
&
!
inIco
)
)
{
break
;
}
SkASSERT
(
infoBytesRemaining
>
52
)
;
inputMasks
.
alpha
=
get_int
(
iBuffer
.
get
(
)
48
)
;
break
;
case
kOS2VX_BmpHeaderType
:
SkCodecPrintf
(
"
Error
:
huffman
format
unsupported
.
\
n
"
)
;
return
false
;
default
:
SkCodecPrintf
(
"
Error
:
invalid
bmp
bit
masks
header
.
\
n
"
)
;
return
false
;
}
break
;
case
kJpeg_BmpCompressionMethod
:
if
(
24
=
=
bitsPerPixel
)
{
inputFormat
=
kRLE_BmpInputFormat
;
break
;
}
case
kPng_BmpCompressionMethod
:
SkCodecPrintf
(
"
Error
:
compression
format
not
supported
.
\
n
"
)
;
return
false
;
case
kCMYK_BmpCompressionMethod
:
case
kCMYK8BitRLE_BmpCompressionMethod
:
case
kCMYK4BitRLE_BmpCompressionMethod
:
SkCodecPrintf
(
"
Error
:
CMYK
not
supported
for
bitmap
decoding
.
\
n
"
)
;
return
false
;
default
:
SkCodecPrintf
(
"
Error
:
invalid
format
for
bitmap
decoding
.
\
n
"
)
;
return
false
;
}
iBuffer
.
reset
(
)
;
const
uint32_t
bytesRead
=
kBmpHeaderBytes
+
infoBytes
+
maskBytes
;
if
(
!
inIco
&
&
offset
<
bytesRead
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
header
size
.
\
n
"
)
;
return
false
;
}
switch
(
inputFormat
)
{
case
kStandard_BmpInputFormat
:
{
SkEncodedInfo
:
:
Alpha
alpha
=
inIco
?
SkEncodedInfo
:
:
kBinary_Alpha
:
SkEncodedInfo
:
:
kOpaque_Alpha
;
bool
isOpaque
=
true
;
SkEncodedInfo
:
:
Color
color
;
uint8_t
bitsPerComponent
;
switch
(
bitsPerPixel
)
{
case
1
:
case
2
:
case
4
:
case
8
:
if
(
inIco
)
{
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
bitsPerComponent
=
8
;
}
else
{
color
=
SkEncodedInfo
:
:
kPalette_Color
;
bitsPerComponent
=
(
uint8_t
)
bitsPerPixel
;
}
break
;
case
24
:
color
=
inIco
?
SkEncodedInfo
:
:
kBGRA_Color
:
SkEncodedInfo
:
:
kBGR_Color
;
bitsPerComponent
=
8
;
break
;
case
32
:
if
(
inIco
)
{
isOpaque
=
false
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
}
else
{
color
=
SkEncodedInfo
:
:
kBGRX_Color
;
}
bitsPerComponent
=
8
;
break
;
default
:
SkCodecPrintf
(
"
Error
:
invalid
input
value
for
bits
per
pixel
.
\
n
"
)
;
return
false
;
}
if
(
codecOut
)
{
SkASSERT
(
!
inIco
|
|
nullptr
!
=
stream
-
>
getMemoryBase
(
)
)
;
const
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
color
alpha
bitsPerComponent
)
;
*
codecOut
=
new
SkBmpStandardCodec
(
width
height
info
stream
bitsPerPixel
numColors
bytesPerColor
offset
-
bytesRead
rowOrder
isOpaque
inIco
)
;
}
return
true
;
}
case
kBitMask_BmpInputFormat
:
{
if
(
inIco
)
{
SkCodecPrintf
(
"
Error
:
Icos
may
not
use
bit
mask
format
.
\
n
"
)
;
return
false
;
}
switch
(
bitsPerPixel
)
{
case
16
:
case
24
:
case
32
:
break
;
default
:
SkCodecPrintf
(
"
Error
:
invalid
input
value
for
bits
per
pixel
.
\
n
"
)
;
return
false
;
}
if
(
stream
-
>
skip
(
offset
-
bytesRead
)
!
=
offset
-
bytesRead
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
if
(
codecOut
)
{
SkAutoTDelete
<
SkMasks
>
masks
(
SkMasks
:
:
CreateMasks
(
inputMasks
bitsPerPixel
)
)
;
if
(
nullptr
=
=
masks
)
{
SkCodecPrintf
(
"
Error
:
invalid
input
masks
.
\
n
"
)
;
return
false
;
}
SkEncodedInfo
:
:
Color
color
;
SkEncodedInfo
:
:
Alpha
alpha
;
if
(
masks
-
>
getAlphaMask
(
)
)
{
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
else
{
color
=
SkEncodedInfo
:
:
kBGR_Color
;
alpha
=
SkEncodedInfo
:
:
kOpaque_Alpha
;
}
const
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
color
alpha
8
)
;
*
codecOut
=
new
SkBmpMaskCodec
(
width
height
info
stream
bitsPerPixel
masks
.
release
(
)
rowOrder
)
;
}
return
true
;
}
case
kRLE_BmpInputFormat
:
{
SkASSERT
(
4
=
=
bitsPerPixel
|
|
8
=
=
bitsPerPixel
|
|
24
=
=
bitsPerPixel
)
;
if
(
totalBytes
<
=
offset
)
{
SkCodecPrintf
(
"
Error
:
RLE
requires
valid
input
size
.
\
n
"
)
;
return
false
;
}
const
size_t
RLEBytes
=
totalBytes
-
offset
;
SkASSERT
(
!
inIco
)
;
if
(
codecOut
)
{
const
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
SkEncodedInfo
:
:
kBGRA_Color
SkEncodedInfo
:
:
kBinary_Alpha
8
)
;
*
codecOut
=
new
SkBmpRLECodec
(
width
height
info
stream
bitsPerPixel
numColors
bytesPerColor
offset
-
bytesRead
rowOrder
RLEBytes
)
;
}
return
true
;
}
default
:
SkASSERT
(
false
)
;
return
false
;
}
}
SkCodec
*
SkBmpCodec
:
:
NewFromStream
(
SkStream
*
stream
bool
inIco
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
SkCodec
*
codec
=
nullptr
;
if
(
ReadHeader
(
stream
inIco
&
codec
)
)
{
SkASSERT
(
codec
)
;
streamDeleter
.
release
(
)
;
return
codec
;
}
return
nullptr
;
}
SkBmpCodec
:
:
SkBmpCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
SkStream
*
stream
uint16_t
bitsPerPixel
SkCodec
:
:
SkScanlineOrder
rowOrder
)
:
INHERITED
(
width
height
info
stream
)
fBitsPerPixel
(
bitsPerPixel
)
fRowOrder
(
rowOrder
)
fSrcRowBytes
(
SkAlign4
(
compute_row_bytes
(
width
fBitsPerPixel
)
)
)
{
}
bool
SkBmpCodec
:
:
onRewind
(
)
{
return
SkBmpCodec
:
:
ReadHeader
(
this
-
>
stream
(
)
this
-
>
inIco
(
)
nullptr
)
;
}
int32_t
SkBmpCodec
:
:
getDstRow
(
int32_t
y
int32_t
height
)
const
{
if
(
SkCodec
:
:
kTopDown_SkScanlineOrder
=
=
fRowOrder
)
{
return
y
;
}
SkASSERT
(
SkCodec
:
:
kBottomUp_SkScanlineOrder
=
=
fRowOrder
)
;
return
height
-
y
-
1
;
}
SkCodec
:
:
Result
SkBmpCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
SkPMColor
inputColorPtr
[
]
int
*
inputColorCount
)
{
if
(
!
conversion_possible_ignore_color_space
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
convert
input
type
to
output
type
.
\
n
"
)
;
return
kInvalidConversion
;
}
return
prepareToDecode
(
dstInfo
options
inputColorPtr
inputColorCount
)
;
}
int
SkBmpCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
{
SkImageInfo
rowInfo
=
this
-
>
dstInfo
(
)
.
makeWH
(
this
-
>
dstInfo
(
)
.
width
(
)
count
)
;
return
this
-
>
decodeRows
(
rowInfo
dst
rowBytes
this
-
>
options
(
)
)
;
}
bool
SkBmpCodec
:
:
skipRows
(
int
count
)
{
const
size_t
bytesToSkip
=
count
*
fSrcRowBytes
;
return
this
-
>
stream
(
)
-
>
skip
(
bytesToSkip
)
=
=
bytesToSkip
;
}
bool
SkBmpCodec
:
:
onSkipScanlines
(
int
count
)
{
return
this
-
>
skipRows
(
count
)
;
}
