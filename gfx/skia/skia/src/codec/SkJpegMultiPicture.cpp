#
include
"
src
/
codec
/
SkJpegMultiPicture
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
codec
/
SkJpegSegmentScan
.
h
"
#
include
<
cstring
>
constexpr
size_t
kMpEndianSize
=
4
;
constexpr
uint8_t
kMpLittleEndian
[
kMpEndianSize
]
=
{
0x49
0x49
0x2A
0x00
}
;
constexpr
uint8_t
kMpBigEndian
[
kMpEndianSize
]
=
{
0x4D
0x4D
0x00
0x2A
}
;
constexpr
uint16_t
kTypeLong
=
0x4
;
constexpr
uint16_t
kTypeUndefined
=
0x7
;
constexpr
uint32_t
kTagSize
=
12
;
constexpr
uint32_t
kTagSerializedCount
=
3
;
constexpr
uint16_t
kVersionTag
=
0xB000
;
constexpr
uint16_t
kVersionType
=
kTypeUndefined
;
constexpr
uint32_t
kVersionCount
=
4
;
constexpr
size_t
kVersionSize
=
4
;
constexpr
uint8_t
kVersionExpected
[
kVersionSize
]
=
{
'
0
'
'
1
'
'
0
'
'
0
'
}
;
constexpr
uint16_t
kNumberOfImagesTag
=
0xB001
;
constexpr
uint16_t
kNumberOfImagesType
=
kTypeLong
;
constexpr
uint32_t
kNumberOfImagesCount
=
1
;
constexpr
uint16_t
kMPEntryTag
=
0xB002
;
constexpr
uint16_t
kMPEntryType
=
kTypeUndefined
;
constexpr
uint32_t
kMPEntrySize
=
16
;
constexpr
uint32_t
kMPEntryAttributeFormatMask
=
0x7000000
;
constexpr
uint32_t
kMPEntryAttributeFormatJpeg
=
0x0000000
;
constexpr
uint32_t
kMPEntryAttributeTypeMask
=
0xFFFFFF
;
constexpr
uint32_t
kMPEntryAttributeTypePrimary
=
0x030000
;
constexpr
uint16_t
kIndividualImageUniqueIDTag
=
0xB003
;
constexpr
uint32_t
kIndividualImageUniqueIDSize
=
33
;
constexpr
uint16_t
kTotalNumberCapturedFramesTag
=
0xB004
;
constexpr
uint32_t
kTotalNumberCaptureFramesCount
=
1
;
#
define
DEFINE_AND_READ_UINT
(
TYPE
VAR
)
\
TYPE
VAR
=
0
;
\
uint8_t
VAR
#
#
Bytes
[
sizeof
(
TYPE
)
]
=
{
0
}
;
\
{
\
if
(
!
stream
-
>
read
(
VAR
#
#
Bytes
sizeof
(
TYPE
)
)
)
{
\
return
nullptr
;
\
}
\
for
(
size_t
VAR
#
#
i
=
0
;
VAR
#
#
i
<
sizeof
(
TYPE
)
;
+
+
VAR
#
#
i
)
{
\
VAR
*
=
256
;
\
VAR
+
=
VAR
#
#
Bytes
[
streamIsBigEndian
?
VAR
#
#
i
:
(
sizeof
(
TYPE
)
-
VAR
#
#
i
-
1
)
]
;
\
}
\
}
\
(
void
)
VAR
std
:
:
unique_ptr
<
SkJpegMultiPictureParameters
>
SkJpegMultiPictureParameters
:
:
Make
(
const
sk_sp
<
const
SkData
>
&
segmentParameters
)
{
if
(
segmentParameters
-
>
size
(
)
<
sizeof
(
kMpfSig
)
)
{
return
nullptr
;
}
if
(
memcmp
(
segmentParameters
-
>
data
(
)
kMpfSig
sizeof
(
kMpfSig
)
)
!
=
0
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkMemoryStream
>
stream
=
SkMemoryStream
:
:
MakeDirect
(
segmentParameters
-
>
bytes
(
)
+
sizeof
(
kMpfSig
)
segmentParameters
-
>
size
(
)
-
sizeof
(
kMpfSig
)
)
;
bool
streamIsBigEndian
=
false
;
{
uint8_t
endianTag
[
kMpEndianSize
]
=
{
0
}
;
if
(
!
stream
-
>
read
(
endianTag
kMpEndianSize
)
)
{
SkCodecPrintf
(
"
Failed
to
read
MP
endian
tag
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
memcmp
(
endianTag
kMpBigEndian
kMpEndianSize
)
)
{
streamIsBigEndian
=
true
;
}
else
if
(
!
memcmp
(
endianTag
kMpLittleEndian
kMpEndianSize
)
)
{
streamIsBigEndian
=
false
;
}
else
{
SkCodecPrintf
(
"
MP
endian
tag
was
invalid
.
\
n
"
)
;
return
nullptr
;
}
}
DEFINE_AND_READ_UINT
(
uint32_t
indexIfdOffset
)
;
if
(
stream
-
>
getPosition
(
)
<
indexIfdOffset
)
{
SkCodecPrintf
(
"
MP
Index
IFD
offset
moves
backwards
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
stream
-
>
seek
(
indexIfdOffset
)
)
{
SkCodecPrintf
(
"
Failed
to
seek
to
MPF
IFD
.
\
n
"
)
;
return
nullptr
;
}
DEFINE_AND_READ_UINT
(
uint16_t
tagCount
)
;
uint32_t
numberOfImages
=
0
;
uint32_t
mpEntryOffset
=
0
;
uint16_t
previousTagId
=
0
;
for
(
uint16_t
tagIndex
=
0
;
tagIndex
<
tagCount
;
+
+
tagIndex
)
{
DEFINE_AND_READ_UINT
(
uint16_t
tagId
)
;
DEFINE_AND_READ_UINT
(
uint16_t
type
)
;
DEFINE_AND_READ_UINT
(
uint32_t
count
)
;
DEFINE_AND_READ_UINT
(
uint32_t
value
)
;
if
(
previousTagId
>
=
tagId
)
{
SkCodecPrintf
(
"
MPF
tags
not
in
order
.
\
n
"
)
;
return
nullptr
;
}
previousTagId
=
tagId
;
switch
(
tagId
)
{
case
kVersionTag
:
if
(
memcmp
(
valueBytes
kVersionExpected
kVersionSize
)
!
=
0
)
{
SkCodecPrintf
(
"
Version
value
is
not
0100
.
\
n
"
)
;
return
nullptr
;
}
if
(
count
!
=
kVersionCount
)
{
SkCodecPrintf
(
"
Version
count
not
4
.
\
n
"
)
;
return
nullptr
;
}
break
;
case
kNumberOfImagesTag
:
numberOfImages
=
value
;
if
(
type
!
=
kTypeLong
)
{
SkCodecPrintf
(
"
Invalid
Total
Number
of
Captured
Frames
type
.
\
n
"
)
;
return
nullptr
;
}
if
(
numberOfImages
<
1
)
{
SkCodecPrintf
(
"
Invalid
number
of
images
.
\
n
"
)
;
return
nullptr
;
}
break
;
case
kMPEntryTag
:
{
if
(
count
!
=
kMPEntrySize
*
numberOfImages
)
{
SkCodecPrintf
(
"
Invalid
MPEntry
count
.
\
n
"
)
;
return
nullptr
;
}
mpEntryOffset
=
value
;
break
;
}
case
kIndividualImageUniqueIDTag
:
if
(
count
!
=
kIndividualImageUniqueIDSize
*
numberOfImages
)
{
SkCodecPrintf
(
"
Invalid
Image
Unique
ID
count
.
\
n
"
)
;
return
nullptr
;
}
break
;
case
kTotalNumberCapturedFramesTag
:
if
(
type
!
=
kTypeLong
)
{
SkCodecPrintf
(
"
Invalid
Total
Number
of
Captured
Frames
type
.
\
n
"
)
;
return
nullptr
;
}
if
(
count
!
=
kTotalNumberCaptureFramesCount
)
{
SkCodecPrintf
(
"
Invalid
Total
Number
of
Captured
Frames
count
.
\
n
"
)
;
return
nullptr
;
}
break
;
default
:
return
nullptr
;
}
}
if
(
!
numberOfImages
)
{
SkCodecPrintf
(
"
Number
of
images
must
be
greater
than
zero
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
mpEntryOffset
)
{
SkCodecPrintf
(
"
MP
Entry
tag
was
not
present
or
had
invalid
offset
.
\
n
"
)
;
return
nullptr
;
}
auto
result
=
std
:
:
make_unique
<
SkJpegMultiPictureParameters
>
(
)
;
result
-
>
images
.
resize
(
numberOfImages
)
;
DEFINE_AND_READ_UINT
(
uint32_t
attributeIfdOffset
)
;
if
(
attributeIfdOffset
>
0
)
{
if
(
stream
-
>
getPosition
(
)
<
attributeIfdOffset
)
{
SkCodecPrintf
(
"
MP
Attribute
IFD
offset
moves
backwards
.
\
n
"
)
;
return
nullptr
;
}
}
if
(
!
stream
-
>
seek
(
mpEntryOffset
)
)
{
SkCodecPrintf
(
"
Failed
to
seek
to
MP
entries
'
offset
.
\
n
"
)
;
return
nullptr
;
}
for
(
uint32_t
i
=
0
;
i
<
numberOfImages
;
+
+
i
)
{
DEFINE_AND_READ_UINT
(
uint32_t
attribute
)
;
const
bool
isPrimary
=
(
attribute
&
kMPEntryAttributeTypeMask
)
=
=
kMPEntryAttributeTypePrimary
;
const
bool
isJpeg
=
(
attribute
&
kMPEntryAttributeFormatMask
)
=
=
kMPEntryAttributeFormatJpeg
;
if
(
isPrimary
!
=
(
i
=
=
0
)
)
{
SkCodecPrintf
(
"
Image
must
be
primary
iff
it
is
the
first
image
.
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
isJpeg
)
{
SkCodecPrintf
(
"
Image
format
must
be
0
(
JPEG
)
.
\
n
"
)
;
return
nullptr
;
}
DEFINE_AND_READ_UINT
(
uint32_t
size
)
;
DEFINE_AND_READ_UINT
(
uint32_t
dataOffset
)
;
if
(
i
=
=
0
&
&
dataOffset
!
=
0
)
{
SkCodecPrintf
(
"
First
individual
Image
offset
must
be
NULL
.
\
n
"
)
;
return
nullptr
;
}
DEFINE_AND_READ_UINT
(
uint16_t
dependentImage1EntryNumber
)
;
DEFINE_AND_READ_UINT
(
uint16_t
dependentImage2EntryNumber
)
;
result
-
>
images
[
i
]
.
dataOffset
=
dataOffset
;
result
-
>
images
[
i
]
.
size
=
size
;
}
return
result
;
}
#
undef
DEFINE_AND_READ_UINT
size_t
multi_picture_params_serialized_size
(
size_t
numberOfImages
)
{
return
sizeof
(
kMpfSig
)
+
kMpEndianSize
+
sizeof
(
uint32_t
)
+
sizeof
(
uint16_t
)
+
kTagSerializedCount
*
kTagSize
+
sizeof
(
uint32_t
)
+
numberOfImages
*
kMPEntrySize
;
}
#
define
WRITE_UINT16
(
value
)
\
do
{
\
if
(
!
s
.
write16
(
SkEndian_SwapBE16
(
value
)
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
#
define
WRITE_UINT32
(
value
)
\
do
{
\
if
(
!
s
.
write32
(
SkEndian_SwapBE32
(
value
)
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
sk_sp
<
SkData
>
SkJpegMultiPictureParameters
:
:
serialize
(
)
const
{
SkDynamicMemoryWStream
s
;
if
(
!
s
.
write
(
kMpfSig
sizeof
(
kMpfSig
)
)
)
{
SkCodecPrintf
(
"
Failed
to
write
signature
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
s
.
write
(
kMpBigEndian
kMpEndianSize
)
)
{
SkCodecPrintf
(
"
Failed
to
write
endianness
.
\
n
"
)
;
return
nullptr
;
}
uint32_t
numberOfImages
=
static_cast
<
uint32_t
>
(
images
.
size
(
)
)
;
constexpr
uint32_t
indexIfdOffset
=
static_cast
<
uint16_t
>
(
sizeof
(
kMpBigEndian
)
+
sizeof
(
uint32_t
)
)
;
WRITE_UINT32
(
indexIfdOffset
)
;
constexpr
uint32_t
numberOfTags
=
3
;
WRITE_UINT16
(
numberOfTags
)
;
WRITE_UINT16
(
kVersionTag
)
;
WRITE_UINT16
(
kVersionType
)
;
WRITE_UINT32
(
kVersionCount
)
;
if
(
!
s
.
write
(
kVersionExpected
kVersionSize
)
)
{
SkCodecPrintf
(
"
Failed
to
write
version
.
\
n
"
)
;
return
nullptr
;
}
WRITE_UINT16
(
kNumberOfImagesTag
)
;
WRITE_UINT16
(
kNumberOfImagesType
)
;
WRITE_UINT32
(
kNumberOfImagesCount
)
;
WRITE_UINT32
(
numberOfImages
)
;
WRITE_UINT16
(
kMPEntryTag
)
;
WRITE_UINT16
(
kMPEntryType
)
;
WRITE_UINT32
(
kMPEntrySize
*
numberOfImages
)
;
const
uint32_t
mpEntryOffset
=
static_cast
<
uint32_t
>
(
s
.
bytesWritten
(
)
-
sizeof
(
kMpfSig
)
+
sizeof
(
uint32_t
)
+
sizeof
(
uint32_t
)
)
;
WRITE_UINT32
(
mpEntryOffset
)
;
WRITE_UINT32
(
0
)
;
for
(
size_t
i
=
0
;
i
<
images
.
size
(
)
;
+
+
i
)
{
const
auto
&
image
=
images
[
i
]
;
uint32_t
attribute
=
kMPEntryAttributeFormatJpeg
;
if
(
i
=
=
0
)
{
attribute
|
=
kMPEntryAttributeTypePrimary
;
}
WRITE_UINT32
(
attribute
)
;
WRITE_UINT32
(
image
.
size
)
;
WRITE_UINT32
(
image
.
dataOffset
)
;
WRITE_UINT16
(
0
)
;
WRITE_UINT16
(
0
)
;
}
SkASSERT
(
s
.
bytesWritten
(
)
=
=
multi_picture_params_serialized_size
(
images
.
size
(
)
)
)
;
return
s
.
detachAsData
(
)
;
}
#
undef
WRITE_UINT16
#
undef
WRITE_UINT32
size_t
SkJpegMultiPictureParameters
:
:
GetAbsoluteOffset
(
uint32_t
dataOffset
size_t
mpSegmentOffset
)
{
if
(
dataOffset
=
=
0
)
{
return
0
;
}
return
mpSegmentOffset
+
kJpegMarkerCodeSize
+
kJpegSegmentParameterLengthSize
+
sizeof
(
kMpfSig
)
+
dataOffset
;
}
