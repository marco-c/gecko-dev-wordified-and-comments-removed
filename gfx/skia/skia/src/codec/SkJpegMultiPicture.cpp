#
include
"
src
/
codec
/
SkJpegMultiPicture
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
codec
/
SkJpegSegmentScan
.
h
"
#
include
"
src
/
codec
/
SkTiffUtility
.
h
"
#
include
<
cstring
>
constexpr
size_t
kMpEndianSize
=
4
;
constexpr
uint8_t
kMpBigEndian
[
kMpEndianSize
]
=
{
0x4D
0x4D
0x00
0x2A
}
;
constexpr
uint16_t
kTypeUnsignedLong
=
0x4
;
constexpr
uint16_t
kTypeUndefined
=
0x7
;
constexpr
uint32_t
kIfdEntrySize
=
12
;
constexpr
uint32_t
kIfdSerializedEntryCount
=
3
;
constexpr
uint16_t
kVersionTag
=
0xB000
;
constexpr
uint32_t
kVersionCount
=
4
;
constexpr
size_t
kVersionSize
=
4
;
constexpr
uint8_t
kVersionExpected
[
kVersionSize
]
=
{
'
0
'
'
1
'
'
0
'
'
0
'
}
;
constexpr
uint16_t
kNumberOfImagesTag
=
0xB001
;
constexpr
uint32_t
kNumberOfImagesCount
=
1
;
constexpr
uint16_t
kMPEntryTag
=
0xB002
;
constexpr
uint32_t
kMPEntrySize
=
16
;
constexpr
uint32_t
kMPEntryAttributeFormatMask
=
0x7000000
;
constexpr
uint32_t
kMPEntryAttributeFormatJpeg
=
0x0000000
;
constexpr
uint32_t
kMPEntryAttributeTypeMask
=
0xFFFFFF
;
constexpr
uint32_t
kMPEntryAttributeTypePrimary
=
0x030000
;
constexpr
uint16_t
kIndividualImageUniqueIDTag
=
0xB003
;
constexpr
uint32_t
kIndividualImageUniqueIDSize
=
33
;
constexpr
uint16_t
kTotalNumberCapturedFramesTag
=
0xB004
;
std
:
:
unique_ptr
<
SkJpegMultiPictureParameters
>
SkJpegMultiPictureParameters
:
:
Make
(
const
sk_sp
<
const
SkData
>
&
segmentParameters
)
{
if
(
segmentParameters
-
>
size
(
)
<
sizeof
(
kMpfSig
)
)
{
return
nullptr
;
}
if
(
memcmp
(
segmentParameters
-
>
data
(
)
kMpfSig
sizeof
(
kMpfSig
)
)
!
=
0
)
{
return
nullptr
;
}
auto
ifdData
=
SkData
:
:
MakeSubset
(
segmentParameters
.
get
(
)
sizeof
(
kMpfSig
)
segmentParameters
-
>
size
(
)
-
sizeof
(
kMpfSig
)
)
;
SkASSERT
(
ifdData
)
;
bool
littleEndian
=
false
;
uint32_t
ifdOffset
=
0
;
if
(
!
SkTiffImageFileDirectory
:
:
ParseHeader
(
ifdData
.
get
(
)
&
littleEndian
&
ifdOffset
)
)
{
SkCodecPrintf
(
"
Failed
to
parse
endian
-
ness
and
index
IFD
offset
.
\
n
"
)
;
return
nullptr
;
}
auto
ifd
=
SkTiffImageFileDirectory
:
:
MakeFromOffset
(
ifdData
littleEndian
ifdOffset
)
;
if
(
!
ifd
)
{
SkCodecPrintf
(
"
Failed
to
create
MP
Index
IFD
offset
.
\
n
"
)
;
return
nullptr
;
}
uint16_t
tagCount
=
ifd
-
>
getNumEntries
(
)
;
uint32_t
numberOfImages
=
0
;
sk_sp
<
SkData
>
mpEntriesData
;
uint16_t
previousTag
=
0
;
for
(
uint16_t
idfEntryIndex
=
0
;
idfEntryIndex
<
tagCount
;
+
+
idfEntryIndex
)
{
uint16_t
tag
=
ifd
-
>
getEntryTag
(
idfEntryIndex
)
;
if
(
previousTag
>
=
tag
)
{
SkCodecPrintf
(
"
MPF
tags
not
in
order
.
\
n
"
)
;
return
nullptr
;
}
previousTag
=
tag
;
switch
(
tag
)
{
case
kVersionTag
:
{
sk_sp
<
SkData
>
data
=
ifd
-
>
getEntryUndefinedData
(
idfEntryIndex
)
;
if
(
!
data
)
{
SkCodecPrintf
(
"
Version
must
be
undefined
type
.
\
n
"
)
;
return
nullptr
;
}
if
(
data
-
>
size
(
)
!
=
kVersionSize
)
{
SkCodecPrintf
(
"
Version
must
be
4
bytes
.
\
n
"
)
;
return
nullptr
;
}
if
(
memcmp
(
data
-
>
data
(
)
kVersionExpected
kVersionSize
)
!
=
0
)
{
SkCodecPrintf
(
"
Version
value
is
not
0100
.
\
n
"
)
;
return
nullptr
;
}
break
;
}
case
kNumberOfImagesTag
:
if
(
!
ifd
-
>
getEntryUnsignedLong
(
idfEntryIndex
1
&
numberOfImages
)
)
{
SkCodecPrintf
(
"
Number
of
Images
was
not
1
unsigned
long
.
\
n
"
)
;
}
if
(
numberOfImages
<
1
)
{
SkCodecPrintf
(
"
Invalid
number
of
images
.
\
n
"
)
;
return
nullptr
;
}
break
;
case
kMPEntryTag
:
{
mpEntriesData
=
ifd
-
>
getEntryUndefinedData
(
idfEntryIndex
)
;
if
(
!
mpEntriesData
)
{
SkCodecPrintf
(
"
MP
entries
data
could
not
be
extracted
.
\
n
"
)
;
return
nullptr
;
}
if
(
mpEntriesData
-
>
size
(
)
!
=
kMPEntrySize
*
numberOfImages
)
{
SkCodecPrintf
(
"
MP
entries
data
should
be
%
ux
%
u
bytes
was
%
u
.
\
n
"
kMPEntrySize
numberOfImages
static_cast
<
uint32_t
>
(
mpEntriesData
-
>
size
(
)
)
)
;
return
nullptr
;
}
break
;
}
case
kIndividualImageUniqueIDTag
:
{
sk_sp
<
SkData
>
data
=
ifd
-
>
getEntryUndefinedData
(
idfEntryIndex
)
;
if
(
!
data
)
{
SkCodecPrintf
(
"
Image
Unique
ID
must
be
undefined
type
.
\
n
"
)
;
return
nullptr
;
}
if
(
data
-
>
size
(
)
!
=
kIndividualImageUniqueIDSize
*
numberOfImages
)
{
SkCodecPrintf
(
"
Invalid
Image
Unique
ID
count
.
\
n
"
)
;
return
nullptr
;
}
break
;
}
case
kTotalNumberCapturedFramesTag
:
{
uint32_t
totalNumCapturedFrames
=
0
;
if
(
!
ifd
-
>
getEntryUnsignedLong
(
idfEntryIndex
1
&
totalNumCapturedFrames
)
)
{
SkCodecPrintf
(
"
Total
Number
of
Captures
Frames
was
not
1
unsigned
long
.
\
n
"
)
;
}
break
;
}
default
:
return
nullptr
;
}
}
if
(
!
numberOfImages
)
{
SkCodecPrintf
(
"
Number
of
images
must
be
greater
than
zero
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
mpEntriesData
)
{
SkCodecPrintf
(
"
MP
Entry
data
was
not
present
.
\
n
"
)
;
return
nullptr
;
}
auto
result
=
std
:
:
make_unique
<
SkJpegMultiPictureParameters
>
(
)
;
result
-
>
images
.
resize
(
numberOfImages
)
;
for
(
uint32_t
i
=
0
;
i
<
numberOfImages
;
+
+
i
)
{
const
uint8_t
*
mpEntryData
=
mpEntriesData
-
>
bytes
(
)
+
kMPEntrySize
*
i
;
const
uint32_t
attribute
=
get_endian_int
(
mpEntryData
+
0
littleEndian
)
;
const
uint32_t
size
=
get_endian_int
(
mpEntryData
+
4
littleEndian
)
;
const
uint32_t
dataOffset
=
get_endian_int
(
mpEntryData
+
8
littleEndian
)
;
const
bool
isPrimary
=
(
attribute
&
kMPEntryAttributeTypeMask
)
=
=
kMPEntryAttributeTypePrimary
;
const
bool
isJpeg
=
(
attribute
&
kMPEntryAttributeFormatMask
)
=
=
kMPEntryAttributeFormatJpeg
;
if
(
isPrimary
!
=
(
i
=
=
0
)
)
{
SkCodecPrintf
(
"
Image
must
be
primary
iff
it
is
the
first
image
.
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
isJpeg
)
{
SkCodecPrintf
(
"
Image
format
must
be
0
(
JPEG
)
.
\
n
"
)
;
return
nullptr
;
}
if
(
i
=
=
0
&
&
dataOffset
!
=
0
)
{
SkCodecPrintf
(
"
First
individual
Image
offset
must
be
NULL
.
\
n
"
)
;
return
nullptr
;
}
result
-
>
images
[
i
]
.
dataOffset
=
dataOffset
;
result
-
>
images
[
i
]
.
size
=
size
;
}
return
result
;
}
size_t
multi_picture_params_serialized_size
(
size_t
numberOfImages
)
{
return
sizeof
(
kMpfSig
)
+
kMpEndianSize
+
sizeof
(
uint32_t
)
+
sizeof
(
uint16_t
)
+
kIfdSerializedEntryCount
*
kIfdEntrySize
+
sizeof
(
uint32_t
)
+
numberOfImages
*
kMPEntrySize
;
}
#
define
WRITE_UINT16
(
value
)
\
do
{
\
if
(
!
s
.
write16
(
SkEndian_SwapBE16
(
value
)
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
#
define
WRITE_UINT32
(
value
)
\
do
{
\
if
(
!
s
.
write32
(
SkEndian_SwapBE32
(
value
)
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
sk_sp
<
SkData
>
SkJpegMultiPictureParameters
:
:
serialize
(
)
const
{
SkDynamicMemoryWStream
s
;
if
(
!
s
.
write
(
kMpfSig
sizeof
(
kMpfSig
)
)
)
{
SkCodecPrintf
(
"
Failed
to
write
signature
.
\
n
"
)
;
return
nullptr
;
}
if
(
!
s
.
write
(
kMpBigEndian
kMpEndianSize
)
)
{
SkCodecPrintf
(
"
Failed
to
write
endianness
.
\
n
"
)
;
return
nullptr
;
}
uint32_t
numberOfImages
=
static_cast
<
uint32_t
>
(
images
.
size
(
)
)
;
constexpr
uint32_t
indexIfdOffset
=
static_cast
<
uint16_t
>
(
sizeof
(
kMpBigEndian
)
+
sizeof
(
uint32_t
)
)
;
WRITE_UINT32
(
indexIfdOffset
)
;
constexpr
uint32_t
numberOfTags
=
3
;
WRITE_UINT16
(
numberOfTags
)
;
WRITE_UINT16
(
kVersionTag
)
;
WRITE_UINT16
(
kTypeUndefined
)
;
WRITE_UINT32
(
kVersionCount
)
;
if
(
!
s
.
write
(
kVersionExpected
kVersionSize
)
)
{
SkCodecPrintf
(
"
Failed
to
write
version
.
\
n
"
)
;
return
nullptr
;
}
WRITE_UINT16
(
kNumberOfImagesTag
)
;
WRITE_UINT16
(
kTypeUnsignedLong
)
;
WRITE_UINT32
(
kNumberOfImagesCount
)
;
WRITE_UINT32
(
numberOfImages
)
;
WRITE_UINT16
(
kMPEntryTag
)
;
WRITE_UINT16
(
kTypeUndefined
)
;
WRITE_UINT32
(
kMPEntrySize
*
numberOfImages
)
;
const
uint32_t
mpEntryOffset
=
static_cast
<
uint32_t
>
(
s
.
bytesWritten
(
)
-
sizeof
(
kMpfSig
)
+
sizeof
(
uint32_t
)
+
sizeof
(
uint32_t
)
)
;
WRITE_UINT32
(
mpEntryOffset
)
;
WRITE_UINT32
(
0
)
;
for
(
size_t
i
=
0
;
i
<
images
.
size
(
)
;
+
+
i
)
{
const
auto
&
image
=
images
[
i
]
;
uint32_t
attribute
=
kMPEntryAttributeFormatJpeg
;
if
(
i
=
=
0
)
{
attribute
|
=
kMPEntryAttributeTypePrimary
;
}
WRITE_UINT32
(
attribute
)
;
WRITE_UINT32
(
image
.
size
)
;
WRITE_UINT32
(
image
.
dataOffset
)
;
WRITE_UINT16
(
0
)
;
WRITE_UINT16
(
0
)
;
}
SkASSERT
(
s
.
bytesWritten
(
)
=
=
multi_picture_params_serialized_size
(
images
.
size
(
)
)
)
;
return
s
.
detachAsData
(
)
;
}
#
undef
WRITE_UINT16
#
undef
WRITE_UINT32
size_t
SkJpegMultiPictureParameters
:
:
GetAbsoluteOffset
(
uint32_t
dataOffset
size_t
mpSegmentOffset
)
{
if
(
dataOffset
=
=
0
)
{
return
0
;
}
return
mpSegmentOffset
+
kJpegMarkerCodeSize
+
kJpegSegmentParameterLengthSize
+
sizeof
(
kMpfSig
)
+
dataOffset
;
}
