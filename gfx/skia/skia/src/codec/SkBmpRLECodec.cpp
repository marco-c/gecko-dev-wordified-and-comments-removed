#
include
"
SkBmpRLECodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkStream
.
h
"
SkBmpRLECodec
:
:
SkBmpRLECodec
(
const
SkImageInfo
&
info
SkStream
*
stream
uint16_t
bitsPerPixel
uint32_t
numColors
uint32_t
bytesPerColor
uint32_t
offset
SkCodec
:
:
SkScanlineOrder
rowOrder
size_t
RLEBytes
)
:
INHERITED
(
info
stream
bitsPerPixel
rowOrder
)
fColorTable
(
nullptr
)
fNumColors
(
this
-
>
computeNumColors
(
numColors
)
)
fBytesPerColor
(
bytesPerColor
)
fOffset
(
offset
)
fStreamBuffer
(
new
uint8_t
[
RLEBytes
]
)
fRLEBytes
(
RLEBytes
)
fCurrRLEByte
(
0
)
fSampleX
(
1
)
{
}
SkCodec
:
:
Result
SkBmpRLECodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
convert
input
type
to
output
type
.
\
n
"
)
;
return
kInvalidConversion
;
}
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
opts
inputColorPtr
inputColorCount
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
int
rows
=
this
-
>
decodeRows
(
dstInfo
dst
dstRowBytes
opts
)
;
if
(
rows
!
=
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
dstInfo
.
height
(
)
;
return
kIncompleteInput
;
}
return
kSuccess
;
}
bool
SkBmpRLECodec
:
:
createColorTable
(
int
*
numColors
)
{
uint32_t
colorBytes
=
0
;
SkPMColor
colorTable
[
256
]
;
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
uint32_t
maxColors
=
1
<
<
this
-
>
bitsPerPixel
(
)
;
if
(
nullptr
!
=
numColors
)
{
*
numColors
=
maxColors
;
}
colorBytes
=
fNumColors
*
fBytesPerColor
;
SkAutoTDeleteArray
<
uint8_t
>
cBuffer
(
new
uint8_t
[
colorBytes
]
)
;
if
(
stream
(
)
-
>
read
(
cBuffer
.
get
(
)
colorBytes
)
!
=
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
color
table
.
\
n
"
)
;
return
false
;
}
uint32_t
i
=
0
;
for
(
;
i
<
fNumColors
;
i
+
+
)
{
uint8_t
blue
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
)
;
uint8_t
green
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
1
)
;
uint8_t
red
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
2
)
;
colorTable
[
i
]
=
SkPackARGB32NoCheck
(
0xFF
red
green
blue
)
;
}
for
(
;
i
<
maxColors
;
i
+
+
)
{
colorTable
[
i
]
=
SkPackARGB32NoCheck
(
0xFF
0
0
0
)
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorTable
maxColors
)
)
;
}
if
(
fOffset
<
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
color
table
size
.
\
n
"
)
;
return
false
;
}
if
(
stream
(
)
-
>
skip
(
fOffset
-
colorBytes
)
!
=
fOffset
-
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
return
true
;
}
bool
SkBmpRLECodec
:
:
initializeStreamBuffer
(
)
{
size_t
totalBytes
=
this
-
>
stream
(
)
-
>
read
(
fStreamBuffer
.
get
(
)
fRLEBytes
)
;
if
(
totalBytes
<
fRLEBytes
)
{
fRLEBytes
=
totalBytes
;
SkCodecPrintf
(
"
Warning
:
incomplete
RLE
file
.
\
n
"
)
;
}
if
(
fRLEBytes
=
=
0
)
{
SkCodecPrintf
(
"
Error
:
could
not
read
RLE
image
data
.
\
n
"
)
;
return
false
;
}
fCurrRLEByte
=
0
;
return
true
;
}
size_t
SkBmpRLECodec
:
:
checkForMoreData
(
)
{
const
size_t
remainingBytes
=
fRLEBytes
-
fCurrRLEByte
;
uint8_t
*
buffer
=
fStreamBuffer
.
get
(
)
;
memmove
(
buffer
SkTAddOffset
<
uint8_t
>
(
buffer
fCurrRLEByte
)
remainingBytes
)
;
buffer
+
=
remainingBytes
;
size_t
additionalBytes
=
this
-
>
stream
(
)
-
>
read
(
buffer
fCurrRLEByte
)
;
fCurrRLEByte
=
0
;
fRLEBytes
=
remainingBytes
+
additionalBytes
;
return
fRLEBytes
;
}
void
SkBmpRLECodec
:
:
setPixel
(
void
*
dst
size_t
dstRowBytes
const
SkImageInfo
&
dstInfo
uint32_t
x
uint32_t
y
uint8_t
index
)
{
if
(
is_coord_necessary
(
x
fSampleX
dstInfo
.
width
(
)
)
)
{
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
const
int
dstX
=
get_dst_coord
(
x
fSampleX
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kN32_SkColorType
:
{
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
fColorTable
-
>
operator
[
]
(
index
)
;
break
;
}
case
kRGB_565_SkColorType
:
{
uint16_t
*
dstRow
=
SkTAddOffset
<
uint16_t
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPixel32ToPixel16
(
fColorTable
-
>
operator
[
]
(
index
)
)
;
break
;
}
default
:
SkASSERT
(
false
)
;
break
;
}
}
}
void
SkBmpRLECodec
:
:
setRGBPixel
(
void
*
dst
size_t
dstRowBytes
const
SkImageInfo
&
dstInfo
uint32_t
x
uint32_t
y
uint8_t
red
uint8_t
green
uint8_t
blue
)
{
if
(
is_coord_necessary
(
x
fSampleX
dstInfo
.
width
(
)
)
)
{
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
const
int
dstX
=
get_dst_coord
(
x
fSampleX
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kN32_SkColorType
:
{
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPackARGB32NoCheck
(
0xFF
red
green
blue
)
;
break
;
}
case
kRGB_565_SkColorType
:
{
uint16_t
*
dstRow
=
SkTAddOffset
<
uint16_t
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPack888ToRGB16
(
red
green
blue
)
;
break
;
}
default
:
SkASSERT
(
false
)
;
break
;
}
}
}
SkCodec
:
:
Result
SkBmpRLECodec
:
:
prepareToDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
SkPMColor
inputColorPtr
[
]
int
*
inputColorCount
)
{
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
fSampleX
=
1
;
if
(
!
this
-
>
createColorTable
(
inputColorCount
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
create
color
table
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
copy_color_table
(
dstInfo
this
-
>
fColorTable
inputColorPtr
inputColorCount
)
;
if
(
!
this
-
>
initializeStreamBuffer
(
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
initialize
stream
buffer
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidConversion
;
}
return
SkCodec
:
:
kSuccess
;
}
int
SkBmpRLECodec
:
:
decodeRows
(
const
SkImageInfo
&
info
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
)
{
static
const
uint8_t
RLE_ESCAPE
=
0
;
static
const
uint8_t
RLE_EOL
=
0
;
static
const
uint8_t
RLE_EOF
=
1
;
static
const
uint8_t
RLE_DELTA
=
2
;
const
int
width
=
this
-
>
getInfo
(
)
.
width
(
)
;
const
int
height
=
info
.
height
(
)
;
SkImageInfo
dstInfo
=
info
.
makeWH
(
get_scaled_dimension
(
width
fSampleX
)
height
)
;
int
x
=
0
;
int
y
=
0
;
SkASSERT
(
kN32_SkColorType
=
=
dstInfo
.
colorType
(
)
)
;
SkSampler
:
:
Fill
(
dstInfo
dst
dstRowBytes
SK_ColorTRANSPARENT
opts
.
fZeroInitialized
)
;
while
(
true
)
{
if
(
y
>
=
height
)
{
return
height
;
}
if
(
(
int
)
fRLEBytes
-
fCurrRLEByte
<
2
)
{
SkCodecPrintf
(
"
Warning
:
might
be
incomplete
RLE
input
.
\
n
"
)
;
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
const
uint8_t
flag
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
const
uint8_t
task
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
if
(
RLE_ESCAPE
=
=
flag
)
{
switch
(
task
)
{
case
RLE_EOL
:
x
=
0
;
y
+
+
;
break
;
case
RLE_EOF
:
return
height
;
case
RLE_DELTA
:
{
if
(
(
int
)
fRLEBytes
-
fCurrRLEByte
<
2
)
{
SkCodecPrintf
(
"
Warning
:
might
be
incomplete
RLE
input
.
\
n
"
)
;
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
const
uint8_t
dx
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
const
uint8_t
dy
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
x
+
=
dx
;
y
+
=
dy
;
if
(
x
>
width
|
|
y
>
height
)
{
SkCodecPrintf
(
"
Warning
:
invalid
RLE
input
.
\
n
"
)
;
return
y
-
dy
;
}
break
;
}
default
:
{
uint8_t
numPixels
=
task
;
const
size_t
rowBytes
=
compute_row_bytes
(
numPixels
this
-
>
bitsPerPixel
(
)
)
;
if
(
x
+
numPixels
>
width
)
{
SkCodecPrintf
(
"
Warning
:
invalid
RLE
input
.
\
n
"
)
;
return
y
;
}
if
(
(
int
)
fRLEBytes
-
fCurrRLEByte
<
SkAlign2
(
rowBytes
)
)
{
SkCodecPrintf
(
"
Warning
:
might
be
incomplete
RLE
input
.
\
n
"
)
;
if
(
this
-
>
checkForMoreData
(
)
<
SkAlign2
(
rowBytes
)
)
{
return
y
;
}
}
while
(
numPixels
>
0
)
{
switch
(
this
-
>
bitsPerPixel
(
)
)
{
case
4
:
{
SkASSERT
(
fCurrRLEByte
<
fRLEBytes
)
;
uint8_t
val
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
val
>
>
4
)
;
numPixels
-
-
;
if
(
numPixels
!
=
0
)
{
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
val
&
0xF
)
;
numPixels
-
-
;
}
break
;
}
case
8
:
SkASSERT
(
fCurrRLEByte
<
fRLEBytes
)
;
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
)
;
numPixels
-
-
;
break
;
case
24
:
{
SkASSERT
(
fCurrRLEByte
+
2
<
fRLEBytes
)
;
uint8_t
blue
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
uint8_t
green
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
uint8_t
red
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
setRGBPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
red
green
blue
)
;
numPixels
-
-
;
}
default
:
SkASSERT
(
false
)
;
return
y
;
}
}
if
(
!
SkIsAlign2
(
rowBytes
)
)
{
fCurrRLEByte
+
+
;
}
break
;
}
}
}
else
{
const
uint8_t
numPixels
=
flag
;
const
int
endX
=
SkTMin
<
int
>
(
x
+
numPixels
width
)
;
if
(
24
=
=
this
-
>
bitsPerPixel
(
)
)
{
if
(
(
int
)
fRLEBytes
-
fCurrRLEByte
<
2
)
{
SkCodecPrintf
(
"
Warning
:
might
be
incomplete
RLE
input
.
\
n
"
)
;
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
uint8_t
blue
=
task
;
uint8_t
green
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
uint8_t
red
=
fStreamBuffer
.
get
(
)
[
fCurrRLEByte
+
+
]
;
while
(
x
<
endX
)
{
setRGBPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
red
green
blue
)
;
}
}
else
{
uint8_t
indices
[
2
]
=
{
task
task
}
;
if
(
4
=
=
this
-
>
bitsPerPixel
(
)
)
{
indices
[
0
]
>
>
=
4
;
indices
[
1
]
&
=
0xf
;
}
for
(
int
which
=
0
;
x
<
endX
;
x
+
+
)
{
setPixel
(
dst
dstRowBytes
dstInfo
x
y
indices
[
which
]
)
;
which
=
!
which
;
}
}
}
}
}
class
SkBmpRLESampler
:
public
SkSampler
{
public
:
SkBmpRLESampler
(
SkBmpRLECodec
*
codec
)
:
fCodec
(
codec
)
{
SkASSERT
(
fCodec
)
;
}
private
:
int
onSetSampleX
(
int
sampleX
)
override
{
return
fCodec
-
>
setSampleX
(
sampleX
)
;
}
SkBmpRLECodec
*
fCodec
;
}
;
SkSampler
*
SkBmpRLECodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
!
fSampler
&
&
createIfNecessary
)
{
fSampler
.
reset
(
new
SkBmpRLESampler
(
this
)
)
;
}
return
fSampler
;
}
int
SkBmpRLECodec
:
:
setSampleX
(
int
sampleX
)
{
fSampleX
=
sampleX
;
return
get_scaled_dimension
(
this
-
>
getInfo
(
)
.
width
(
)
sampleX
)
;
}
