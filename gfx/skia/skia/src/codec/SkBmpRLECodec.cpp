#
include
"
src
/
codec
/
SkBmpRLECodec
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorPriv
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkEncodedInfo
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
memory
>
#
include
<
utility
>
SkBmpRLECodec
:
:
SkBmpRLECodec
(
SkEncodedInfo
&
&
info
std
:
:
unique_ptr
<
SkStream
>
stream
uint16_t
bitsPerPixel
uint32_t
numColors
uint32_t
bytesPerColor
uint32_t
offset
SkCodec
:
:
SkScanlineOrder
rowOrder
)
:
INHERITED
(
std
:
:
move
(
info
)
std
:
:
move
(
stream
)
bitsPerPixel
rowOrder
)
fColorTable
(
nullptr
)
fNumColors
(
numColors
)
fBytesPerColor
(
bytesPerColor
)
fOffset
(
offset
)
fBytesBuffered
(
0
)
fCurrRLEByte
(
0
)
fSampleX
(
1
)
{
}
SkCodec
:
:
Result
SkBmpRLECodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
opts
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
int
rows
=
this
-
>
decodeRows
(
dstInfo
dst
dstRowBytes
opts
)
;
if
(
rows
!
=
dstInfo
.
height
(
)
)
{
*
rowsDecoded
=
dstInfo
.
height
(
)
;
return
kIncompleteInput
;
}
return
kSuccess
;
}
bool
SkBmpRLECodec
:
:
createColorTable
(
SkColorType
dstColorType
)
{
uint32_t
colorBytes
=
0
;
SkPMColor
colorTable
[
256
]
;
if
(
this
-
>
bitsPerPixel
(
)
<
=
8
)
{
uint32_t
maxColors
=
1
<
<
this
-
>
bitsPerPixel
(
)
;
const
uint32_t
numColorsToRead
=
fNumColors
=
=
0
?
maxColors
:
std
:
:
min
(
fNumColors
maxColors
)
;
colorBytes
=
numColorsToRead
*
fBytesPerColor
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
cBuffer
(
new
uint8_t
[
colorBytes
]
)
;
if
(
stream
(
)
-
>
read
(
cBuffer
.
get
(
)
colorBytes
)
!
=
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
color
table
.
\
n
"
)
;
return
false
;
}
PackColorProc
packARGB
=
choose_pack_color_proc
(
false
dstColorType
)
;
uint32_t
i
=
0
;
for
(
;
i
<
numColorsToRead
;
i
+
+
)
{
uint8_t
blue
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
)
;
uint8_t
green
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
1
)
;
uint8_t
red
=
get_byte
(
cBuffer
.
get
(
)
i
*
fBytesPerColor
+
2
)
;
colorTable
[
i
]
=
packARGB
(
0xFF
red
green
blue
)
;
}
for
(
;
i
<
maxColors
;
i
+
+
)
{
colorTable
[
i
]
=
SkPackARGB32NoCheck
(
0xFF
0
0
0
)
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorTable
maxColors
)
)
;
}
if
(
fOffset
<
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
pixel
data
offset
less
than
color
table
size
.
\
n
"
)
;
return
false
;
}
if
(
stream
(
)
-
>
skip
(
fOffset
-
colorBytes
)
!
=
fOffset
-
colorBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
skip
to
image
data
.
\
n
"
)
;
return
false
;
}
return
true
;
}
bool
SkBmpRLECodec
:
:
initializeStreamBuffer
(
)
{
fBytesBuffered
=
this
-
>
stream
(
)
-
>
read
(
fStreamBuffer
kBufferSize
)
;
if
(
fBytesBuffered
=
=
0
)
{
SkCodecPrintf
(
"
Error
:
could
not
read
RLE
image
data
.
\
n
"
)
;
return
false
;
}
fCurrRLEByte
=
0
;
return
true
;
}
size_t
SkBmpRLECodec
:
:
checkForMoreData
(
)
{
const
size_t
remainingBytes
=
fBytesBuffered
-
fCurrRLEByte
;
uint8_t
*
buffer
=
fStreamBuffer
;
memmove
(
buffer
SkTAddOffset
<
uint8_t
>
(
buffer
fCurrRLEByte
)
remainingBytes
)
;
buffer
+
=
remainingBytes
;
size_t
additionalBytes
=
this
-
>
stream
(
)
-
>
read
(
buffer
fCurrRLEByte
)
;
fCurrRLEByte
=
0
;
fBytesBuffered
=
remainingBytes
+
additionalBytes
;
return
fBytesBuffered
;
}
void
SkBmpRLECodec
:
:
setPixel
(
void
*
dst
size_t
dstRowBytes
const
SkImageInfo
&
dstInfo
uint32_t
x
uint32_t
y
uint8_t
index
)
{
if
(
dst
&
&
is_coord_necessary
(
x
fSampleX
dstInfo
.
width
(
)
)
)
{
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
const
int
dstX
=
get_dst_coord
(
x
fSampleX
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
{
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
fColorTable
-
>
operator
[
]
(
index
)
;
break
;
}
case
kRGB_565_SkColorType
:
{
uint16_t
*
dstRow
=
SkTAddOffset
<
uint16_t
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPixel32ToPixel16
(
fColorTable
-
>
operator
[
]
(
index
)
)
;
break
;
}
default
:
SkASSERT
(
false
)
;
break
;
}
}
}
void
SkBmpRLECodec
:
:
setRGBPixel
(
void
*
dst
size_t
dstRowBytes
const
SkImageInfo
&
dstInfo
uint32_t
x
uint32_t
y
uint8_t
red
uint8_t
green
uint8_t
blue
)
{
if
(
dst
&
&
is_coord_necessary
(
x
fSampleX
dstInfo
.
width
(
)
)
)
{
uint32_t
row
=
this
-
>
getDstRow
(
y
dstInfo
.
height
(
)
)
;
const
int
dstX
=
get_dst_coord
(
x
fSampleX
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
{
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPackARGB_as_RGBA
(
0xFF
red
green
blue
)
;
break
;
}
case
kBGRA_8888_SkColorType
:
{
SkPMColor
*
dstRow
=
SkTAddOffset
<
SkPMColor
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPackARGB_as_BGRA
(
0xFF
red
green
blue
)
;
break
;
}
case
kRGB_565_SkColorType
:
{
uint16_t
*
dstRow
=
SkTAddOffset
<
uint16_t
>
(
dst
row
*
(
int
)
dstRowBytes
)
;
dstRow
[
dstX
]
=
SkPack888ToRGB16
(
red
green
blue
)
;
break
;
}
default
:
SkASSERT
(
false
)
;
break
;
}
}
}
SkCodec
:
:
Result
SkBmpRLECodec
:
:
onPrepareToDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
)
{
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
fSampleX
=
1
;
fLinesToSkip
=
0
;
SkColorType
colorTableColorType
=
dstInfo
.
colorType
(
)
;
if
(
this
-
>
colorXform
(
)
)
{
colorTableColorType
=
kBGRA_8888_SkColorType
;
}
if
(
!
this
-
>
createColorTable
(
colorTableColorType
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
create
color
table
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
if
(
!
this
-
>
initializeStreamBuffer
(
)
)
{
SkCodecPrintf
(
"
Error
:
cannot
initialize
stream
buffer
.
\
n
"
)
;
return
SkCodec
:
:
kInvalidInput
;
}
return
SkCodec
:
:
kSuccess
;
}
int
SkBmpRLECodec
:
:
decodeRows
(
const
SkImageInfo
&
info
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
)
{
int
height
=
info
.
height
(
)
;
SkImageInfo
dstInfo
=
info
.
makeWH
(
this
-
>
fillWidth
(
)
height
)
;
if
(
dst
)
{
SkSampler
:
:
Fill
(
dstInfo
dst
dstRowBytes
opts
.
fZeroInitialized
)
;
}
if
(
height
>
fLinesToSkip
)
{
height
-
=
fLinesToSkip
;
if
(
dst
)
{
dst
=
SkTAddOffset
<
void
>
(
dst
fLinesToSkip
*
dstRowBytes
)
;
}
fLinesToSkip
=
0
;
dstInfo
=
dstInfo
.
makeWH
(
dstInfo
.
width
(
)
height
)
;
}
else
{
fLinesToSkip
-
=
height
;
return
height
;
}
void
*
decodeDst
=
dst
;
size_t
decodeRowBytes
=
dstRowBytes
;
SkImageInfo
decodeInfo
=
dstInfo
;
if
(
decodeDst
)
{
if
(
this
-
>
colorXform
(
)
)
{
decodeInfo
=
decodeInfo
.
makeColorType
(
kXformSrcColorType
)
;
if
(
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
{
int
count
=
height
*
dstInfo
.
width
(
)
;
this
-
>
resetXformBuffer
(
count
)
;
sk_bzero
(
this
-
>
xformBuffer
(
)
count
*
sizeof
(
uint32_t
)
)
;
decodeDst
=
this
-
>
xformBuffer
(
)
;
decodeRowBytes
=
dstInfo
.
width
(
)
*
sizeof
(
uint32_t
)
;
}
}
}
int
decodedHeight
=
this
-
>
decodeRLE
(
decodeInfo
decodeDst
decodeRowBytes
)
;
if
(
this
-
>
colorXform
(
)
&
&
decodeDst
)
{
for
(
int
y
=
0
;
y
<
decodedHeight
;
y
+
+
)
{
this
-
>
applyColorXform
(
dst
decodeDst
dstInfo
.
width
(
)
)
;
decodeDst
=
SkTAddOffset
<
void
>
(
decodeDst
decodeRowBytes
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
dstRowBytes
)
;
}
}
return
decodedHeight
;
}
int
SkBmpRLECodec
:
:
decodeRLE
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
)
{
const
int
width
=
this
-
>
dimensions
(
)
.
width
(
)
;
const
int
height
=
dstInfo
.
height
(
)
;
constexpr
uint8_t
RLE_ESCAPE
=
0
;
constexpr
uint8_t
RLE_EOL
=
0
;
constexpr
uint8_t
RLE_EOF
=
1
;
constexpr
uint8_t
RLE_DELTA
=
2
;
int
x
=
0
;
int
y
=
0
;
while
(
true
)
{
if
(
y
>
=
height
)
{
return
height
;
}
if
(
(
int
)
fBytesBuffered
-
fCurrRLEByte
<
2
)
{
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
const
uint8_t
flag
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
const
uint8_t
task
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
if
(
RLE_ESCAPE
=
=
flag
)
{
switch
(
task
)
{
case
RLE_EOL
:
x
=
0
;
y
+
+
;
break
;
case
RLE_EOF
:
return
height
;
case
RLE_DELTA
:
{
if
(
(
int
)
fBytesBuffered
-
fCurrRLEByte
<
2
)
{
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
const
uint8_t
dx
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
const
uint8_t
dy
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
x
+
=
dx
;
y
+
=
dy
;
if
(
x
>
width
)
{
SkCodecPrintf
(
"
Warning
:
invalid
RLE
input
.
\
n
"
)
;
return
y
-
dy
;
}
else
if
(
y
>
height
)
{
fLinesToSkip
=
y
-
height
;
return
height
;
}
break
;
}
default
:
{
uint8_t
numPixels
=
task
;
const
size_t
rowBytes
=
compute_row_bytes
(
numPixels
this
-
>
bitsPerPixel
(
)
)
;
if
(
x
+
numPixels
>
width
)
{
SkCodecPrintf
(
"
Warning
:
invalid
RLE
input
.
\
n
"
)
;
}
static_assert
(
255
*
3
+
1
<
kBufferSize
"
kBufferSize
needs
to
be
larger
!
"
)
;
const
size_t
alignedRowBytes
=
SkAlign2
(
rowBytes
)
;
if
(
(
int
)
fBytesBuffered
-
fCurrRLEByte
<
alignedRowBytes
)
{
SkASSERT
(
alignedRowBytes
<
kBufferSize
)
;
if
(
this
-
>
checkForMoreData
(
)
<
alignedRowBytes
)
{
return
y
;
}
}
while
(
(
numPixels
>
0
)
&
&
(
x
<
width
)
)
{
switch
(
this
-
>
bitsPerPixel
(
)
)
{
case
4
:
{
SkASSERT
(
fCurrRLEByte
<
fBytesBuffered
)
;
uint8_t
val
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
val
>
>
4
)
;
numPixels
-
-
;
if
(
numPixels
!
=
0
)
{
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
val
&
0xF
)
;
numPixels
-
-
;
}
break
;
}
case
8
:
SkASSERT
(
fCurrRLEByte
<
fBytesBuffered
)
;
setPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
fStreamBuffer
[
fCurrRLEByte
+
+
]
)
;
numPixels
-
-
;
break
;
case
24
:
{
SkASSERT
(
fCurrRLEByte
+
2
<
fBytesBuffered
)
;
uint8_t
blue
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
uint8_t
green
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
uint8_t
red
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
setRGBPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
red
green
blue
)
;
numPixels
-
-
;
break
;
}
default
:
SkASSERT
(
false
)
;
return
y
;
}
}
if
(
!
SkIsAlign2
(
rowBytes
)
)
{
fCurrRLEByte
+
+
;
}
break
;
}
}
}
else
{
const
uint8_t
numPixels
=
flag
;
const
int
endX
=
std
:
:
min
<
int
>
(
x
+
numPixels
width
)
;
if
(
24
=
=
this
-
>
bitsPerPixel
(
)
)
{
if
(
(
int
)
fBytesBuffered
-
fCurrRLEByte
<
2
)
{
if
(
this
-
>
checkForMoreData
(
)
<
2
)
{
return
y
;
}
}
uint8_t
blue
=
task
;
uint8_t
green
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
uint8_t
red
=
fStreamBuffer
[
fCurrRLEByte
+
+
]
;
while
(
x
<
endX
)
{
setRGBPixel
(
dst
dstRowBytes
dstInfo
x
+
+
y
red
green
blue
)
;
}
}
else
{
uint8_t
indices
[
2
]
=
{
task
task
}
;
if
(
4
=
=
this
-
>
bitsPerPixel
(
)
)
{
indices
[
0
]
>
>
=
4
;
indices
[
1
]
&
=
0xf
;
}
for
(
int
which
=
0
;
x
<
endX
;
x
+
+
)
{
setPixel
(
dst
dstRowBytes
dstInfo
x
y
indices
[
which
]
)
;
which
=
!
which
;
}
}
}
}
}
bool
SkBmpRLECodec
:
:
skipRows
(
int
count
)
{
const
SkImageInfo
rowInfo
=
SkImageInfo
:
:
Make
(
this
-
>
dimensions
(
)
.
width
(
)
count
kN32_SkColorType
kUnpremul_SkAlphaType
)
;
return
count
=
=
this
-
>
decodeRows
(
rowInfo
nullptr
0
this
-
>
options
(
)
)
;
}
class
SkBmpRLESampler
:
public
SkSampler
{
public
:
SkBmpRLESampler
(
SkBmpRLECodec
*
codec
)
:
fCodec
(
codec
)
{
SkASSERT
(
fCodec
)
;
}
int
fillWidth
(
)
const
override
{
return
fCodec
-
>
fillWidth
(
)
;
}
private
:
int
onSetSampleX
(
int
sampleX
)
override
{
return
fCodec
-
>
setSampleX
(
sampleX
)
;
}
SkBmpRLECodec
*
fCodec
;
}
;
SkSampler
*
SkBmpRLECodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
!
fSampler
&
&
createIfNecessary
)
{
fSampler
=
std
:
:
make_unique
<
SkBmpRLESampler
>
(
this
)
;
}
return
fSampler
.
get
(
)
;
}
int
SkBmpRLECodec
:
:
setSampleX
(
int
sampleX
)
{
fSampleX
=
sampleX
;
return
this
-
>
fillWidth
(
)
;
}
int
SkBmpRLECodec
:
:
fillWidth
(
)
const
{
return
get_scaled_dimension
(
this
-
>
dimensions
(
)
.
width
(
)
fSampleX
)
;
}
