#
include
"
src
/
codec
/
SkJpegSegmentScan
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
<
cstring
>
#
include
<
utility
>
SkJpegSegmentScanner
:
:
SkJpegSegmentScanner
(
uint8_t
stopMarker
)
:
fStopMarker
(
stopMarker
)
{
}
const
std
:
:
vector
<
SkJpegSegment
>
&
SkJpegSegmentScanner
:
:
getSegments
(
)
const
{
return
fSegments
;
}
sk_sp
<
SkData
>
SkJpegSegmentScanner
:
:
GetParameters
(
const
SkData
*
scannedData
const
SkJpegSegment
&
segment
)
{
return
SkData
:
:
MakeSubset
(
scannedData
segment
.
offset
+
kJpegMarkerCodeSize
+
kJpegSegmentParameterLengthSize
segment
.
parameterLength
-
kJpegSegmentParameterLengthSize
)
;
}
void
SkJpegSegmentScanner
:
:
onBytes
(
const
void
*
data
size_t
size
)
{
const
uint8_t
*
bytes
=
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
;
size_t
bytesRemaining
=
size
;
while
(
bytesRemaining
>
0
)
{
size_t
bytesToMoveForward
=
0
;
switch
(
fState
)
{
case
State
:
:
kSegmentParam
:
{
SkASSERT
(
fSegmentParamBytesRemaining
>
0
)
;
bytesToMoveForward
=
std
:
:
min
(
fSegmentParamBytesRemaining
bytesRemaining
)
;
fSegmentParamBytesRemaining
-
=
bytesToMoveForward
;
if
(
fSegmentParamBytesRemaining
=
=
0
)
{
fState
=
State
:
:
kEntropyCodedData
;
}
break
;
}
case
State
:
:
kEntropyCodedData
:
{
const
uint8_t
*
sentinel
=
reinterpret_cast
<
const
uint8_t
*
>
(
memchr
(
bytes
0xFF
bytesRemaining
)
)
;
if
(
sentinel
)
{
bytesToMoveForward
=
(
sentinel
-
bytes
)
+
1
;
fState
=
State
:
:
kEntropyCodedDataSentinel
;
}
else
{
bytesToMoveForward
=
bytesRemaining
;
}
break
;
}
case
State
:
:
kDone
:
bytesToMoveForward
=
bytesRemaining
;
break
;
default
:
{
onByte
(
*
bytes
)
;
bytesToMoveForward
=
1
;
break
;
}
}
SkASSERT
(
bytesToMoveForward
>
0
)
;
fOffset
+
=
bytesToMoveForward
;
bytes
+
=
bytesToMoveForward
;
bytesRemaining
-
=
bytesToMoveForward
;
}
}
void
SkJpegSegmentScanner
:
:
saveCurrentSegment
(
uint16_t
length
)
{
SkJpegSegment
s
=
{
fCurrentSegmentOffset
fCurrentSegmentMarker
length
}
;
fSegments
.
push_back
(
s
)
;
fCurrentSegmentMarker
=
0
;
fCurrentSegmentOffset
=
0
;
}
void
SkJpegSegmentScanner
:
:
onMarkerSecondByte
(
uint8_t
byte
)
{
SkASSERT
(
fState
=
=
State
:
:
kStartOfImageByte1
|
|
fState
=
=
State
:
:
kSecondMarkerByte1
|
|
fState
=
=
State
:
:
kEntropyCodedDataSentinel
|
|
fState
=
=
State
:
:
kPostEntropyCodedDataFill
)
;
fCurrentSegmentMarker
=
byte
;
fCurrentSegmentOffset
=
fOffset
-
1
;
if
(
byte
=
=
fStopMarker
)
{
saveCurrentSegment
(
0
)
;
fState
=
State
:
:
kDone
;
}
else
if
(
byte
=
=
kJpegMarkerStartOfImage
)
{
saveCurrentSegment
(
0
)
;
fState
=
State
:
:
kSecondMarkerByte0
;
}
else
if
(
MarkerStandsAlone
(
byte
)
)
{
saveCurrentSegment
(
0
)
;
fState
=
State
:
:
kEntropyCodedData
;
}
else
{
fCurrentSegmentMarker
=
byte
;
fState
=
State
:
:
kSegmentParamLengthByte0
;
}
}
void
SkJpegSegmentScanner
:
:
onByte
(
uint8_t
byte
)
{
switch
(
fState
)
{
case
State
:
:
kStartOfImageByte0
:
if
(
byte
!
=
0xFF
)
{
SkCodecPrintf
(
"
First
byte
was
%
02x
not
0xFF
"
byte
)
;
fState
=
State
:
:
kError
;
return
;
}
fState
=
State
:
:
kStartOfImageByte1
;
break
;
case
State
:
:
kStartOfImageByte1
:
if
(
byte
!
=
kJpegMarkerStartOfImage
)
{
SkCodecPrintf
(
"
Second
byte
was
%
02x
not
%
02x
"
byte
kJpegMarkerStartOfImage
)
;
fState
=
State
:
:
kError
;
return
;
}
onMarkerSecondByte
(
byte
)
;
break
;
case
State
:
:
kSecondMarkerByte0
:
if
(
byte
!
=
0xFF
)
{
SkCodecPrintf
(
"
Third
byte
was
%
02x
not
0xFF
"
byte
)
;
fState
=
State
:
:
kError
;
return
;
}
fState
=
State
:
:
kSecondMarkerByte1
;
break
;
case
State
:
:
kSecondMarkerByte1
:
if
(
byte
=
=
0xFF
|
|
byte
=
=
0x00
)
{
SkCodecPrintf
(
"
SkJpegSegment
marker
was
0xFF
0xFF
or
0xFF
0x00
"
)
;
fState
=
State
:
:
kError
;
return
;
}
onMarkerSecondByte
(
byte
)
;
break
;
case
State
:
:
kSegmentParamLengthByte0
:
fSegmentParamLengthByte0
=
byte
;
fState
=
State
:
:
kSegmentParamLengthByte1
;
break
;
case
State
:
:
kSegmentParamLengthByte1
:
{
uint16_t
paramLength
=
256u
*
fSegmentParamLengthByte0
+
byte
;
fSegmentParamLengthByte0
=
0
;
if
(
paramLength
<
kJpegSegmentParameterLengthSize
)
{
SkCodecPrintf
(
"
SkJpegSegment
payload
length
was
%
u
<
2
bytes
"
paramLength
)
;
fState
=
State
:
:
kError
;
return
;
}
saveCurrentSegment
(
paramLength
)
;
fSegmentParamBytesRemaining
=
paramLength
-
kJpegSegmentParameterLengthSize
;
if
(
fSegmentParamBytesRemaining
>
0
)
{
fState
=
State
:
:
kSegmentParam
;
}
else
{
fState
=
State
:
:
kEntropyCodedData
;
}
break
;
}
case
State
:
:
kSegmentParam
:
SkASSERT
(
fSegmentParamBytesRemaining
>
0
)
;
fSegmentParamBytesRemaining
-
=
1
;
if
(
fSegmentParamBytesRemaining
=
=
0
)
{
fState
=
State
:
:
kEntropyCodedData
;
}
break
;
case
State
:
:
kEntropyCodedData
:
if
(
byte
=
=
0xFF
)
{
fState
=
State
:
:
kEntropyCodedDataSentinel
;
}
break
;
case
State
:
:
kEntropyCodedDataSentinel
:
if
(
byte
=
=
0x00
)
{
fState
=
State
:
:
kEntropyCodedData
;
}
else
if
(
byte
=
=
0xFF
)
{
fState
=
State
:
:
kPostEntropyCodedDataFill
;
}
else
{
onMarkerSecondByte
(
byte
)
;
}
break
;
case
State
:
:
kPostEntropyCodedDataFill
:
if
(
byte
=
=
0xFF
)
{
fState
=
State
:
:
kPostEntropyCodedDataFill
;
}
else
if
(
byte
=
=
0x00
)
{
SkCodecPrintf
(
"
Post
entropy
coded
data
had
0xFF
0x00
"
)
;
fState
=
State
:
:
kError
;
return
;
}
else
{
onMarkerSecondByte
(
byte
)
;
}
break
;
case
State
:
:
kDone
:
break
;
case
State
:
:
kError
:
break
;
}
}
