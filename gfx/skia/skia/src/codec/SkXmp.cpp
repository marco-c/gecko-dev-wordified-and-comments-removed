#
include
"
include
/
private
/
SkXmp
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
SkGainmapInfo
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
utils
/
SkParse
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
xml
/
SkDOM
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
utility
>
const
char
*
kXmlnsPrefix
=
"
xmlns
:
"
;
const
size_t
kXmlnsPrefixLength
=
6
;
static
const
char
*
get_namespace_prefix
(
const
char
*
name
)
{
if
(
strlen
(
name
)
<
=
kXmlnsPrefixLength
)
{
return
nullptr
;
}
return
name
+
kXmlnsPrefixLength
;
}
static
const
char
*
get_unique_child_text
(
const
SkDOM
&
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
childName
)
{
if
(
dom
.
countChildren
(
node
childName
.
c_str
(
)
)
!
=
1
)
{
return
nullptr
;
}
const
auto
*
child
=
dom
.
getFirstChild
(
node
childName
.
c_str
(
)
)
;
if
(
!
child
)
{
return
nullptr
;
}
if
(
dom
.
countChildren
(
child
)
!
=
1
)
{
return
nullptr
;
}
const
auto
*
grandChild
=
dom
.
getFirstChild
(
child
)
;
if
(
dom
.
getType
(
grandChild
)
!
=
SkDOM
:
:
kText_Type
)
{
return
nullptr
;
}
return
dom
.
getName
(
grandChild
)
;
}
static
const
SkDOM
:
:
Node
*
get_typed_child
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
type
)
{
const
auto
name
=
prefix
+
std
:
:
string
(
"
:
"
)
+
type
;
const
SkDOM
:
:
Node
*
child
=
dom
-
>
getFirstChild
(
node
name
.
c_str
(
)
)
;
if
(
child
)
{
return
child
;
}
const
SkDOM
:
:
Node
*
typeChild
=
dom
-
>
getFirstChild
(
node
"
rdf
:
type
"
)
;
if
(
!
typeChild
)
{
return
nullptr
;
}
const
char
*
typeChildResource
=
dom
-
>
findAttr
(
typeChild
"
rdf
:
resource
"
)
;
if
(
!
typeChildResource
|
|
typeChildResource
!
=
type
)
{
return
nullptr
;
}
const
SkDOM
:
:
Node
*
valueChild
=
dom
-
>
getFirstChild
(
node
"
rdf
:
value
"
)
;
if
(
!
valueChild
)
{
return
nullptr
;
}
const
char
*
valueChildParseType
=
dom
-
>
findAttr
(
valueChild
"
rdf
:
parseType
"
)
;
if
(
!
valueChildParseType
|
|
strcmp
(
valueChildParseType
"
Resource
"
)
!
=
0
)
{
return
nullptr
;
}
return
valueChild
;
}
static
const
char
*
get_attr
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
)
{
const
auto
name
=
prefix
+
"
:
"
+
key
;
const
char
*
attr
=
dom
-
>
findAttr
(
node
name
.
c_str
(
)
)
;
if
(
attr
)
{
return
attr
;
}
return
get_unique_child_text
(
*
dom
node
name
)
;
}
static
bool
get_attr_bool
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
bool
*
outValue
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
switch
(
SkParse
:
:
FindList
(
attr
"
False
True
"
)
)
{
case
0
:
*
outValue
=
false
;
return
true
;
case
1
:
*
outValue
=
true
;
return
true
;
default
:
break
;
}
return
false
;
}
static
bool
get_attr_int32
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
int32_t
*
value
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
if
(
!
SkParse
:
:
FindS32
(
attr
value
)
)
{
return
false
;
}
return
true
;
}
static
bool
get_attr_float
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
float
*
outValue
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
SkScalar
value
=
0
.
f
;
if
(
SkParse
:
:
FindScalar
(
attr
&
value
)
)
{
*
outValue
=
value
;
return
true
;
}
return
false
;
}
static
bool
get_attr_float3_as_list
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
SkColor4f
*
outValue
)
{
const
auto
name
=
prefix
+
"
:
"
+
key
;
if
(
dom
-
>
countChildren
(
node
name
.
c_str
(
)
)
!
=
1
)
{
return
false
;
}
const
auto
*
child
=
dom
-
>
getFirstChild
(
node
name
.
c_str
(
)
)
;
if
(
!
child
)
{
return
false
;
}
const
auto
*
seq
=
dom
-
>
getFirstChild
(
child
"
rdf
:
Seq
"
)
;
if
(
!
seq
)
{
return
false
;
}
size_t
count
=
0
;
SkScalar
values
[
3
]
=
{
0
.
f
0
.
f
0
.
f
}
;
for
(
const
auto
*
liNode
=
dom
-
>
getFirstChild
(
seq
"
rdf
:
li
"
)
;
liNode
;
liNode
=
dom
-
>
getNextSibling
(
liNode
"
rdf
:
li
"
)
)
{
if
(
count
>
2
)
{
SkCodecPrintf
(
"
Too
many
items
in
list
.
\
n
"
)
;
return
false
;
}
if
(
dom
-
>
countChildren
(
liNode
)
!
=
1
)
{
SkCodecPrintf
(
"
Item
can
only
have
one
child
.
\
n
"
)
;
return
false
;
}
const
auto
*
liTextNode
=
dom
-
>
getFirstChild
(
liNode
)
;
if
(
dom
-
>
getType
(
liTextNode
)
!
=
SkDOM
:
:
kText_Type
)
{
SkCodecPrintf
(
"
Item
'
s
only
child
must
be
text
.
\
n
"
)
;
return
false
;
}
const
char
*
liText
=
dom
-
>
getName
(
liTextNode
)
;
if
(
!
liText
)
{
SkCodecPrintf
(
"
Failed
to
get
item
'
s
text
.
\
n
"
)
;
return
false
;
}
if
(
!
SkParse
:
:
FindScalar
(
liText
values
+
count
)
)
{
SkCodecPrintf
(
"
Failed
to
parse
item
'
s
text
to
float
.
\
n
"
)
;
return
false
;
}
count
+
=
1
;
}
if
(
count
<
3
)
{
SkCodecPrintf
(
"
List
didn
'
t
have
enough
items
.
\
n
"
)
;
return
false
;
}
*
outValue
=
{
values
[
0
]
values
[
1
]
values
[
2
]
1
.
f
}
;
return
true
;
}
static
bool
get_attr_float3
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
SkColor4f
*
outValue
)
{
if
(
get_attr_float3_as_list
(
dom
node
prefix
key
outValue
)
)
{
return
true
;
}
SkScalar
value
=
-
1
.
0
;
if
(
get_attr_float
(
dom
node
prefix
key
&
value
)
)
{
*
outValue
=
{
value
value
value
1
.
f
}
;
return
true
;
}
return
false
;
}
static
void
find_uri_namespaces
(
const
SkDOM
&
dom
const
SkDOM
:
:
Node
*
node
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
)
{
for
(
const
auto
*
attr
=
dom
.
getFirstAttr
(
node
)
;
attr
;
attr
=
dom
.
getNextAttr
(
node
attr
)
)
{
const
char
*
attrName
=
dom
.
getAttrName
(
node
attr
)
;
const
char
*
attrValue
=
dom
.
getAttrValue
(
node
attr
)
;
if
(
!
attrName
|
|
!
attrValue
)
{
continue
;
}
if
(
strlen
(
attrName
)
<
=
kXmlnsPrefixLength
)
{
continue
;
}
if
(
memcmp
(
attrName
kXmlnsPrefix
kXmlnsPrefixLength
)
!
=
0
)
{
continue
;
}
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
strcmp
(
attrValue
uris
[
i
]
)
!
=
0
)
{
continue
;
}
outNamespaces
[
i
]
=
attrName
;
}
}
}
static
const
SkDOM
:
:
Node
*
find_uri_namespaces
(
const
SkDOM
&
dom
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
)
{
const
SkDOM
:
:
Node
*
root
=
dom
.
getRootNode
(
)
;
if
(
!
root
)
{
return
nullptr
;
}
const
char
*
rootName
=
dom
.
getName
(
root
)
;
if
(
!
rootName
|
|
strcmp
(
rootName
"
x
:
xmpmeta
"
)
!
=
0
)
{
return
nullptr
;
}
const
char
*
kRdf
=
"
rdf
:
RDF
"
;
for
(
const
auto
*
rdf
=
dom
.
getFirstChild
(
root
kRdf
)
;
rdf
;
rdf
=
dom
.
getNextSibling
(
rdf
kRdf
)
)
{
std
:
:
vector
<
const
char
*
>
rdfNamespaces
(
count
nullptr
)
;
find_uri_namespaces
(
dom
rdf
count
uris
rdfNamespaces
.
data
(
)
)
;
const
char
*
kDesc
=
"
rdf
:
Description
"
;
for
(
const
auto
*
desc
=
dom
.
getFirstChild
(
rdf
kDesc
)
;
desc
;
desc
=
dom
.
getNextSibling
(
desc
kDesc
)
)
{
std
:
:
vector
<
const
char
*
>
descNamespaces
=
rdfNamespaces
;
find_uri_namespaces
(
dom
desc
count
uris
descNamespaces
.
data
(
)
)
;
bool
foundAllUris
=
true
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
!
descNamespaces
[
i
]
)
{
foundAllUris
=
false
;
break
;
}
}
if
(
foundAllUris
)
{
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
outNamespaces
[
i
]
=
descNamespaces
[
i
]
;
}
return
desc
;
}
}
}
return
nullptr
;
}
class
SkXmpImpl
final
:
public
SkXmp
{
public
:
SkXmpImpl
(
)
=
default
;
bool
getGainmapInfoHDRGM
(
SkGainmapInfo
*
info
)
const
override
;
bool
getGainmapInfoHDRGainMap
(
SkGainmapInfo
*
info
)
const
override
;
bool
getContainerGainmapLocation
(
size_t
*
offset
size_t
*
size
)
const
override
;
const
char
*
getExtendedXmpGuid
(
)
const
override
;
bool
parseDom
(
sk_sp
<
SkData
>
xmpData
bool
extended
)
;
private
:
bool
findUriNamespaces
(
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
const
SkDOM
*
*
outDom
const
SkDOM
:
:
Node
*
*
outNode
)
const
;
SkDOM
fStandardDOM
;
SkDOM
fExtendedDOM
;
}
;
const
char
*
SkXmpImpl
:
:
getExtendedXmpGuid
(
)
const
{
const
char
*
namespaces
[
1
]
=
{
nullptr
}
;
const
char
*
uris
[
1
]
=
{
"
http
:
/
/
ns
.
adobe
.
com
/
xmp
/
note
/
"
}
;
const
auto
*
extendedNode
=
find_uri_namespaces
(
fStandardDOM
1
uris
namespaces
)
;
if
(
!
extendedNode
)
{
return
nullptr
;
}
const
auto
xmpNotePrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
return
get_attr
(
&
fStandardDOM
extendedNode
xmpNotePrefix
"
HasExtendedXMP
"
)
;
}
bool
SkXmpImpl
:
:
findUriNamespaces
(
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
const
SkDOM
*
*
outDom
const
SkDOM
:
:
Node
*
*
outNode
)
const
{
*
outNode
=
find_uri_namespaces
(
fStandardDOM
count
uris
outNamespaces
)
;
if
(
*
outNode
)
{
*
outDom
=
&
fStandardDOM
;
return
true
;
}
*
outNode
=
find_uri_namespaces
(
fExtendedDOM
count
uris
outNamespaces
)
;
if
(
*
outNode
)
{
*
outDom
=
&
fExtendedDOM
;
return
true
;
}
*
outDom
=
nullptr
;
return
false
;
}
bool
SkXmpImpl
:
:
getContainerGainmapLocation
(
size_t
*
outOffset
size_t
*
outSize
)
const
{
const
char
*
namespaces
[
2
]
=
{
nullptr
nullptr
}
;
const
char
*
uris
[
2
]
=
{
"
http
:
/
/
ns
.
google
.
com
/
photos
/
1
.
0
/
container
/
"
"
http
:
/
/
ns
.
google
.
com
/
photos
/
1
.
0
/
container
/
item
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
2
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
containerPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
itemPrefix
=
get_namespace_prefix
(
namespaces
[
1
]
)
;
const
auto
*
directory
=
get_typed_child
(
dom
node
containerPrefix
"
Directory
"
)
;
if
(
!
directory
)
{
SkCodecPrintf
(
"
Missing
Container
Directory
"
)
;
return
false
;
}
const
auto
*
seq
=
dom
-
>
getFirstChild
(
directory
"
rdf
:
Seq
"
)
;
if
(
!
seq
)
{
SkCodecPrintf
(
"
Missing
rdf
:
Seq
"
)
;
return
false
;
}
bool
isFirstItem
=
true
;
size_t
offset
=
0
;
for
(
const
auto
*
li
=
dom
-
>
getFirstChild
(
seq
"
rdf
:
li
"
)
;
li
;
li
=
dom
-
>
getNextSibling
(
li
"
rdf
:
li
"
)
)
{
const
auto
*
item
=
get_typed_child
(
dom
li
containerPrefix
"
Item
"
)
;
if
(
!
item
)
{
SkCodecPrintf
(
"
List
item
does
not
have
container
Item
.
\
n
"
)
;
return
false
;
}
const
char
*
itemSemantic
=
get_attr
(
dom
item
itemPrefix
"
Semantic
"
)
;
if
(
!
itemSemantic
)
{
SkCodecPrintf
(
"
Item
is
missing
Semantic
.
\
n
"
)
;
return
false
;
}
const
char
*
itemMime
=
get_attr
(
dom
item
itemPrefix
"
Mime
"
)
;
if
(
!
itemMime
)
{
SkCodecPrintf
(
"
Item
is
missing
Mime
.
\
n
"
)
;
return
false
;
}
if
(
isFirstItem
)
{
isFirstItem
=
false
;
if
(
strcmp
(
itemSemantic
"
Primary
"
)
!
=
0
)
{
SkCodecPrintf
(
"
First
item
is
not
Primary
.
\
n
"
)
;
return
false
;
}
if
(
strcmp
(
itemMime
"
image
/
jpeg
"
)
!
=
0
)
{
SkCodecPrintf
(
"
Primary
does
not
report
that
it
is
image
/
jpeg
.
\
n
"
)
;
return
false
;
}
int32_t
padding
=
0
;
if
(
get_attr_int32
(
dom
item
itemPrefix
"
Padding
"
&
padding
)
)
{
if
(
padding
<
0
)
{
SkCodecPrintf
(
"
Item
padding
must
be
non
-
negative
.
"
)
;
return
false
;
}
offset
+
=
padding
;
}
}
else
{
int32_t
length
=
0
;
if
(
!
get_attr_int32
(
dom
item
itemPrefix
"
Length
"
&
length
)
)
{
SkCodecPrintf
(
"
Item
length
is
absent
.
"
)
;
return
false
;
}
if
(
length
<
0
)
{
SkCodecPrintf
(
"
Item
length
must
be
non
-
negative
.
"
)
;
return
false
;
}
if
(
strcmp
(
itemSemantic
"
GainMap
"
)
!
=
0
)
{
offset
+
=
length
;
continue
;
}
if
(
strcmp
(
itemMime
"
image
/
jpeg
"
)
!
=
0
)
{
SkCodecPrintf
(
"
GainMap
does
not
report
that
it
is
image
/
jpeg
.
\
n
"
)
;
return
false
;
}
*
outOffset
=
offset
;
*
outSize
=
length
;
return
true
;
}
}
return
false
;
}
bool
SkXmpImpl
:
:
getGainmapInfoHDRGainMap
(
SkGainmapInfo
*
info
)
const
{
const
char
*
namespaces
[
2
]
=
{
nullptr
nullptr
}
;
const
char
*
uris
[
2
]
=
{
"
http
:
/
/
ns
.
apple
.
com
/
pixeldatainfo
/
1
.
0
/
"
"
http
:
/
/
ns
.
apple
.
com
/
HDRGainMap
/
1
.
0
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
2
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
adpiPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
hdrGainMapPrefix
=
get_namespace_prefix
(
namespaces
[
1
]
)
;
const
char
*
auxiliaryImageType
=
get_attr
(
dom
node
adpiPrefix
"
AuxiliaryImageType
"
)
;
if
(
!
auxiliaryImageType
)
{
SkCodecPrintf
(
"
Did
not
find
AuxiliaryImageType
.
\
n
"
)
;
return
false
;
}
if
(
strcmp
(
auxiliaryImageType
"
urn
:
com
:
apple
:
photo
:
2020
:
aux
:
hdrgainmap
"
)
!
=
0
)
{
SkCodecPrintf
(
"
AuxiliaryImageType
was
not
HDR
gain
map
.
\
n
"
)
;
return
false
;
}
int32_t
version
=
0
;
if
(
!
get_attr_int32
(
dom
node
hdrGainMapPrefix
"
HDRGainMapVersion
"
&
version
)
)
{
SkCodecPrintf
(
"
Did
not
find
HDRGainMapVersion
.
\
n
"
)
;
return
false
;
}
if
(
version
!
=
65536
)
{
SkCodecPrintf
(
"
HDRGainMapVersion
was
not
65536
.
\
n
"
)
;
return
false
;
}
const
float
kRatioMax
=
sk_float_exp
(
1
.
f
)
;
info
-
>
fGainmapRatioMin
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
info
-
>
fGainmapRatioMax
=
{
kRatioMax
kRatioMax
kRatioMax
1
.
f
}
;
info
-
>
fGainmapGamma
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
info
-
>
fEpsilonSdr
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
info
-
>
fEpsilonHdr
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
info
-
>
fDisplayRatioSdr
=
1
.
f
;
info
-
>
fDisplayRatioHdr
=
kRatioMax
;
info
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kSDR
;
return
true
;
}
bool
SkXmpImpl
:
:
getGainmapInfoHDRGM
(
SkGainmapInfo
*
outGainmapInfo
)
const
{
const
char
*
namespaces
[
1
]
=
{
nullptr
}
;
const
char
*
uris
[
1
]
=
{
"
http
:
/
/
ns
.
adobe
.
com
/
hdr
-
gain
-
map
/
1
.
0
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
1
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
hdrgmPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
version
=
get_attr
(
dom
node
hdrgmPrefix
"
Version
"
)
;
if
(
!
version
)
{
SkCodecPrintf
(
"
Version
attribute
is
absent
.
\
n
"
)
;
return
false
;
}
if
(
strcmp
(
version
"
1
.
0
"
)
!
=
0
)
{
SkCodecPrintf
(
"
Version
is
\
"
%
s
\
"
not
\
"
1
.
0
\
"
.
\
n
"
version
)
;
return
false
;
}
bool
baseRenditionIsHDR
=
false
;
SkColor4f
gainMapMin
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
SkColor4f
gainMapMax
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
SkColor4f
gamma
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
SkColor4f
offsetSdr
=
{
1
.
f
/
64
.
f
1
.
f
/
64
.
f
1
.
f
/
64
.
f
0
.
f
}
;
SkColor4f
offsetHdr
=
{
1
.
f
/
64
.
f
1
.
f
/
64
.
f
1
.
f
/
64
.
f
0
.
f
}
;
SkScalar
hdrCapacityMin
=
0
.
f
;
SkScalar
hdrCapacityMax
=
1
.
f
;
get_attr_bool
(
dom
node
hdrgmPrefix
"
BaseRenditionIsHDR
"
&
baseRenditionIsHDR
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
GainMapMin
"
&
gainMapMin
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
GainMapMax
"
&
gainMapMax
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
Gamma
"
&
gamma
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
OffsetSDR
"
&
offsetSdr
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
OffsetHDR
"
&
offsetHdr
)
;
get_attr_float
(
dom
node
hdrgmPrefix
"
HDRCapacityMin
"
&
hdrCapacityMin
)
;
get_attr_float
(
dom
node
hdrgmPrefix
"
HDRCapacityMax
"
&
hdrCapacityMax
)
;
const
float
kLog2
=
sk_float_log
(
2
.
f
)
;
outGainmapInfo
-
>
fGainmapRatioMin
=
{
sk_float_exp
(
gainMapMin
.
fR
*
kLog2
)
sk_float_exp
(
gainMapMin
.
fG
*
kLog2
)
sk_float_exp
(
gainMapMin
.
fB
*
kLog2
)
1
.
f
}
;
outGainmapInfo
-
>
fGainmapRatioMax
=
{
sk_float_exp
(
gainMapMax
.
fR
*
kLog2
)
sk_float_exp
(
gainMapMax
.
fG
*
kLog2
)
sk_float_exp
(
gainMapMax
.
fB
*
kLog2
)
1
.
f
}
;
outGainmapInfo
-
>
fGainmapGamma
=
{
1
.
f
/
gamma
.
fR
1
.
f
/
gamma
.
fG
1
.
f
/
gamma
.
fB
1
.
f
}
;
outGainmapInfo
-
>
fEpsilonSdr
=
offsetSdr
;
outGainmapInfo
-
>
fEpsilonHdr
=
offsetHdr
;
outGainmapInfo
-
>
fDisplayRatioSdr
=
sk_float_exp
(
hdrCapacityMin
*
kLog2
)
;
outGainmapInfo
-
>
fDisplayRatioHdr
=
sk_float_exp
(
hdrCapacityMax
*
kLog2
)
;
if
(
baseRenditionIsHDR
)
{
outGainmapInfo
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kHDR
;
}
else
{
outGainmapInfo
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kSDR
;
}
return
true
;
}
bool
SkXmpImpl
:
:
parseDom
(
sk_sp
<
SkData
>
xmpData
bool
extended
)
{
SkDOM
*
dom
=
extended
?
&
fExtendedDOM
:
&
fStandardDOM
;
auto
xmpdStream
=
SkMemoryStream
:
:
Make
(
std
:
:
move
(
xmpData
)
)
;
if
(
!
dom
-
>
build
(
*
xmpdStream
)
)
{
SkCodecPrintf
(
"
Failed
to
parse
XMP
%
s
metadata
.
\
n
"
extended
?
"
extended
"
:
"
standard
"
)
;
return
false
;
}
return
true
;
}
std
:
:
unique_ptr
<
SkXmp
>
SkXmp
:
:
Make
(
sk_sp
<
SkData
>
xmpData
)
{
std
:
:
unique_ptr
<
SkXmpImpl
>
xmp
(
new
SkXmpImpl
)
;
if
(
!
xmp
-
>
parseDom
(
std
:
:
move
(
xmpData
)
false
)
)
{
return
nullptr
;
}
return
xmp
;
}
std
:
:
unique_ptr
<
SkXmp
>
SkXmp
:
:
Make
(
sk_sp
<
SkData
>
xmpStandard
sk_sp
<
SkData
>
xmpExtended
)
{
std
:
:
unique_ptr
<
SkXmpImpl
>
xmp
(
new
SkXmpImpl
)
;
if
(
!
xmp
-
>
parseDom
(
std
:
:
move
(
xmpStandard
)
false
)
)
{
return
nullptr
;
}
(
void
)
xmp
-
>
parseDom
(
std
:
:
move
(
xmpExtended
)
true
)
;
return
xmp
;
}
