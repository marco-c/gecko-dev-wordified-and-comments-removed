#
include
"
SkCodec
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkSampler
.
h
"
#
include
"
SkUtils
.
h
"
void
SkSampler
:
:
Fill
(
const
SkImageInfo
&
info
void
*
dst
size_t
rowBytes
uint64_t
colorOrIndex
SkCodec
:
:
ZeroInitialized
zeroInit
)
{
SkASSERT
(
dst
!
=
nullptr
)
;
const
size_t
bytesToFill
=
info
.
computeByteSize
(
rowBytes
)
;
const
int
width
=
info
.
width
(
)
;
const
int
numRows
=
info
.
height
(
)
;
switch
(
info
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
{
uint32_t
color
=
(
uint32_t
)
colorOrIndex
;
if
(
SkCodec
:
:
kYes_ZeroInitialized
=
=
zeroInit
&
&
0
=
=
color
)
{
return
;
}
uint32_t
*
dstRow
=
(
uint32_t
*
)
dst
;
for
(
int
row
=
0
;
row
<
numRows
;
row
+
+
)
{
sk_memset32
(
(
uint32_t
*
)
dstRow
color
width
)
;
dstRow
=
SkTAddOffset
<
uint32_t
>
(
dstRow
rowBytes
)
;
}
break
;
}
case
kRGB_565_SkColorType
:
{
uint16_t
color
=
(
uint16_t
)
colorOrIndex
;
if
(
SkCodec
:
:
kYes_ZeroInitialized
=
=
zeroInit
&
&
0
=
=
color
)
{
return
;
}
uint16_t
*
dstRow
=
(
uint16_t
*
)
dst
;
for
(
int
row
=
0
;
row
<
numRows
;
row
+
+
)
{
sk_memset16
(
(
uint16_t
*
)
dstRow
color
width
)
;
dstRow
=
SkTAddOffset
<
uint16_t
>
(
dstRow
rowBytes
)
;
}
break
;
}
case
kGray_8_SkColorType
:
if
(
SkCodec
:
:
kYes_ZeroInitialized
=
=
zeroInit
&
&
0
=
=
(
uint8_t
)
colorOrIndex
)
{
return
;
}
memset
(
dst
(
uint8_t
)
colorOrIndex
bytesToFill
)
;
break
;
case
kRGBA_F16_SkColorType
:
{
uint64_t
color
=
colorOrIndex
;
if
(
SkCodec
:
:
kYes_ZeroInitialized
=
=
zeroInit
&
&
0
=
=
color
)
{
return
;
}
uint64_t
*
dstRow
=
(
uint64_t
*
)
dst
;
for
(
int
row
=
0
;
row
<
numRows
;
row
+
+
)
{
sk_memset64
(
(
uint64_t
*
)
dstRow
color
width
)
;
dstRow
=
SkTAddOffset
<
uint64_t
>
(
dstRow
rowBytes
)
;
}
break
;
}
default
:
SkCodecPrintf
(
"
Error
:
Unsupported
dst
color
type
for
fill
(
)
.
Doing
nothing
.
\
n
"
)
;
SkASSERT
(
false
)
;
break
;
}
}
