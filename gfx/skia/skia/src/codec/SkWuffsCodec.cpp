#
include
"
src
/
codec
/
SkWuffsCodec
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
private
/
SkMalloc
.
h
"
#
include
"
src
/
codec
/
SkFrameHolder
.
h
"
#
include
"
src
/
codec
/
SkSampler
.
h
"
#
include
"
src
/
codec
/
SkScalingCodec
.
h
"
#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkRasterClip
.
h
"
#
include
"
src
/
core
/
SkUtils
.
h
"
#
include
<
limits
.
h
>
#
if
defined
(
WUFFS_IMPLEMENTATION
)
#
error
"
SkWuffsCodec
should
not
#
define
WUFFS_IMPLEMENTATION
"
#
endif
#
include
"
wuffs
-
v0
.
2
.
c
"
#
if
WUFFS_VERSION_BUILD_METADATA_COMMIT_COUNT
<
1942
#
error
"
Wuffs
version
is
too
old
.
Upgrade
to
the
latest
version
.
"
#
endif
#
define
SK_WUFFS_CODEC_BUFFER_SIZE
4096
static
bool
fill_buffer
(
wuffs_base__io_buffer
*
b
SkStream
*
s
)
{
b
-
>
compact
(
)
;
size_t
num_read
=
s
-
>
read
(
b
-
>
data
.
ptr
+
b
-
>
meta
.
wi
b
-
>
data
.
len
-
b
-
>
meta
.
wi
)
;
b
-
>
meta
.
wi
+
=
num_read
;
b
-
>
meta
.
closed
=
s
-
>
isAtEnd
(
)
;
return
num_read
>
0
;
}
static
bool
seek_buffer
(
wuffs_base__io_buffer
*
b
SkStream
*
s
uint64_t
pos
)
{
if
(
(
pos
>
=
b
-
>
meta
.
pos
)
&
&
(
pos
-
b
-
>
meta
.
pos
<
=
b
-
>
meta
.
wi
)
)
{
b
-
>
meta
.
ri
=
pos
-
b
-
>
meta
.
pos
;
return
true
;
}
if
(
(
pos
>
SIZE_MAX
)
|
|
(
!
s
-
>
seek
(
pos
)
)
)
{
return
false
;
}
b
-
>
meta
.
wi
=
0
;
b
-
>
meta
.
ri
=
0
;
b
-
>
meta
.
pos
=
pos
;
b
-
>
meta
.
closed
=
false
;
return
true
;
}
static
SkEncodedInfo
:
:
Alpha
wuffs_blend_to_skia_alpha
(
wuffs_base__animation_blend
w
)
{
return
(
w
=
=
WUFFS_BASE__ANIMATION_BLEND__OPAQUE
)
?
SkEncodedInfo
:
:
kOpaque_Alpha
:
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
static
SkCodecAnimation
:
:
Blend
wuffs_blend_to_skia_blend
(
wuffs_base__animation_blend
w
)
{
return
(
w
=
=
WUFFS_BASE__ANIMATION_BLEND__SRC
)
?
SkCodecAnimation
:
:
Blend
:
:
kBG
:
SkCodecAnimation
:
:
Blend
:
:
kPriorFrame
;
}
static
SkCodecAnimation
:
:
DisposalMethod
wuffs_disposal_to_skia_disposal
(
wuffs_base__animation_disposal
w
)
{
switch
(
w
)
{
case
WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_BACKGROUND
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kRestoreBGColor
;
case
WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_PREVIOUS
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kRestorePrevious
;
default
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kKeep
;
}
}
class
SkWuffsCodec
;
class
SkWuffsFrame
final
:
public
SkFrame
{
public
:
SkWuffsFrame
(
wuffs_base__frame_config
*
fc
)
;
SkCodec
:
:
FrameInfo
frameInfo
(
bool
fullyReceived
)
const
;
uint64_t
ioPosition
(
)
const
;
SkEncodedInfo
:
:
Alpha
onReportedAlpha
(
)
const
override
;
private
:
uint64_t
fIOPosition
;
SkEncodedInfo
:
:
Alpha
fReportedAlpha
;
typedef
SkFrame
INHERITED
;
}
;
class
SkWuffsFrameHolder
final
:
public
SkFrameHolder
{
public
:
SkWuffsFrameHolder
(
)
:
INHERITED
(
)
{
}
void
init
(
SkWuffsCodec
*
codec
int
width
int
height
)
;
const
SkFrame
*
onGetFrame
(
int
i
)
const
override
;
private
:
const
SkWuffsCodec
*
fCodec
;
typedef
SkFrameHolder
INHERITED
;
}
;
class
SkWuffsCodec
final
:
public
SkScalingCodec
{
public
:
SkWuffsCodec
(
SkEncodedInfo
&
&
encodedInfo
std
:
:
unique_ptr
<
SkStream
>
stream
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
dec
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
size_t
workbuf_len
wuffs_base__image_config
imgcfg
wuffs_base__pixel_buffer
pixbuf
wuffs_base__io_buffer
iobuf
)
;
const
SkWuffsFrame
*
frame
(
int
i
)
const
;
private
:
SkEncodedImageFormat
onGetEncodedFormat
(
)
const
override
;
Result
onGetPixels
(
const
SkImageInfo
&
void
*
size_t
const
Options
&
int
*
)
override
;
const
SkFrameHolder
*
getFrameHolder
(
)
const
override
;
Result
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
)
override
;
Result
onIncrementalDecode
(
int
*
rowsDecoded
)
override
;
int
onGetFrameCount
(
)
override
;
bool
onGetFrameInfo
(
int
FrameInfo
*
)
const
override
;
int
onGetRepetitionCount
(
)
override
;
void
readFrames
(
)
;
Result
seekFrame
(
int
frameIndex
)
;
Result
resetDecoder
(
)
;
const
char
*
decodeFrameConfig
(
)
;
const
char
*
decodeFrame
(
)
;
void
updateNumFullyReceivedFrames
(
)
;
SkWuffsFrameHolder
fFrameHolder
;
std
:
:
unique_ptr
<
SkStream
>
fStream
;
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
fDecoder
;
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
fPixbufPtr
;
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
fWorkbufPtr
;
size_t
fWorkbufLen
;
const
uint64_t
fFirstFrameIOPosition
;
wuffs_base__frame_config
fFrameConfig
;
wuffs_base__pixel_buffer
fPixelBuffer
;
wuffs_base__io_buffer
fIOBuffer
;
uint8_t
*
fIncrDecDst
;
size_t
fIncrDecRowBytes
;
bool
fFirstCallToIncrementalDecode
;
uint64_t
fNumFullyReceivedFrames
;
std
:
:
vector
<
SkWuffsFrame
>
fFrames
;
bool
fFramesComplete
;
bool
fDecoderIsSuspended
;
uint8_t
fBuffer
[
SK_WUFFS_CODEC_BUFFER_SIZE
]
;
typedef
SkScalingCodec
INHERITED
;
}
;
SkWuffsFrame
:
:
SkWuffsFrame
(
wuffs_base__frame_config
*
fc
)
:
INHERITED
(
fc
-
>
index
(
)
)
fIOPosition
(
fc
-
>
io_position
(
)
)
fReportedAlpha
(
wuffs_blend_to_skia_alpha
(
fc
-
>
blend
(
)
)
)
{
wuffs_base__rect_ie_u32
r
=
fc
-
>
bounds
(
)
;
this
-
>
setXYWH
(
r
.
min_incl_x
r
.
min_incl_y
r
.
width
(
)
r
.
height
(
)
)
;
this
-
>
setDisposalMethod
(
wuffs_disposal_to_skia_disposal
(
fc
-
>
disposal
(
)
)
)
;
this
-
>
setDuration
(
fc
-
>
duration
(
)
/
WUFFS_BASE__FLICKS_PER_MILLISECOND
)
;
this
-
>
setBlend
(
wuffs_blend_to_skia_blend
(
fc
-
>
blend
(
)
)
)
;
}
SkCodec
:
:
FrameInfo
SkWuffsFrame
:
:
frameInfo
(
bool
fullyReceived
)
const
{
SkCodec
:
:
FrameInfo
ret
;
ret
.
fRequiredFrame
=
getRequiredFrame
(
)
;
ret
.
fDuration
=
getDuration
(
)
;
ret
.
fFullyReceived
=
fullyReceived
;
ret
.
fAlphaType
=
hasAlpha
(
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
;
ret
.
fDisposalMethod
=
getDisposalMethod
(
)
;
return
ret
;
}
uint64_t
SkWuffsFrame
:
:
ioPosition
(
)
const
{
return
fIOPosition
;
}
SkEncodedInfo
:
:
Alpha
SkWuffsFrame
:
:
onReportedAlpha
(
)
const
{
return
fReportedAlpha
;
}
void
SkWuffsFrameHolder
:
:
init
(
SkWuffsCodec
*
codec
int
width
int
height
)
{
fCodec
=
codec
;
fScreenWidth
=
width
;
fScreenHeight
=
height
;
}
const
SkFrame
*
SkWuffsFrameHolder
:
:
onGetFrame
(
int
i
)
const
{
return
fCodec
-
>
frame
(
i
)
;
}
;
SkWuffsCodec
:
:
SkWuffsCodec
(
SkEncodedInfo
&
&
encodedInfo
std
:
:
unique_ptr
<
SkStream
>
stream
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
dec
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
size_t
workbuf_len
wuffs_base__image_config
imgcfg
wuffs_base__pixel_buffer
pixbuf
wuffs_base__io_buffer
iobuf
)
:
INHERITED
(
std
:
:
move
(
encodedInfo
)
skcms_PixelFormat_RGBA_8888
nullptr
)
fFrameHolder
(
)
fStream
(
std
:
:
move
(
stream
)
)
fDecoder
(
std
:
:
move
(
dec
)
)
fPixbufPtr
(
std
:
:
move
(
pixbuf_ptr
)
)
fWorkbufPtr
(
std
:
:
move
(
workbuf_ptr
)
)
fWorkbufLen
(
workbuf_len
)
fFirstFrameIOPosition
(
imgcfg
.
first_frame_io_position
(
)
)
fFrameConfig
(
wuffs_base__null_frame_config
(
)
)
fPixelBuffer
(
pixbuf
)
fIOBuffer
(
wuffs_base__empty_io_buffer
(
)
)
fIncrDecDst
(
nullptr
)
fIncrDecRowBytes
(
0
)
fFirstCallToIncrementalDecode
(
false
)
fNumFullyReceivedFrames
(
0
)
fFramesComplete
(
false
)
fDecoderIsSuspended
(
false
)
{
fFrameHolder
.
init
(
this
imgcfg
.
pixcfg
.
width
(
)
imgcfg
.
pixcfg
.
height
(
)
)
;
SkASSERT
(
iobuf
.
data
.
len
=
=
SK_WUFFS_CODEC_BUFFER_SIZE
)
;
memmove
(
fBuffer
iobuf
.
data
.
ptr
iobuf
.
meta
.
wi
)
;
fIOBuffer
.
data
=
wuffs_base__make_slice_u8
(
fBuffer
SK_WUFFS_CODEC_BUFFER_SIZE
)
;
fIOBuffer
.
meta
=
iobuf
.
meta
;
}
const
SkWuffsFrame
*
SkWuffsCodec
:
:
frame
(
int
i
)
const
{
if
(
(
0
<
=
i
)
&
&
(
static_cast
<
size_t
>
(
i
)
<
fFrames
.
size
(
)
)
)
{
return
&
fFrames
[
i
]
;
}
return
nullptr
;
}
SkEncodedImageFormat
SkWuffsCodec
:
:
onGetEncodedFormat
(
)
const
{
return
SkEncodedImageFormat
:
:
kGIF
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
int
*
rowsDecoded
)
{
SkCodec
:
:
Result
result
=
this
-
>
onStartIncrementalDecode
(
dstInfo
dst
rowBytes
options
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
return
this
-
>
onIncrementalDecode
(
rowsDecoded
)
;
}
const
SkFrameHolder
*
SkWuffsCodec
:
:
getFrameHolder
(
)
const
{
return
&
fFrameHolder
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
)
{
if
(
!
dst
)
{
return
SkCodec
:
:
kInvalidParameters
;
}
if
(
options
.
fSubset
)
{
return
SkCodec
:
:
kUnimplemented
;
}
if
(
options
.
fFrameIndex
>
0
&
&
SkColorTypeIsAlwaysOpaque
(
dstInfo
.
colorType
(
)
)
)
{
return
SkCodec
:
:
kInvalidConversion
;
}
SkCodec
:
:
Result
result
=
this
-
>
seekFrame
(
options
.
fFrameIndex
)
;
if
(
result
!
=
SkCodec
:
:
kSuccess
)
{
return
result
;
}
const
char
*
status
=
this
-
>
decodeFrameConfig
(
)
;
if
(
status
=
=
wuffs_base__suspension__short_read
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
else
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
decodeFrameConfig
:
%
s
"
status
)
;
return
SkCodec
:
:
kErrorInInput
;
}
uint32_t
src_bits_per_pixel
=
wuffs_base__pixel_format__bits_per_pixel
(
fPixelBuffer
.
pixcfg
.
pixel_format
(
)
)
;
if
(
(
src_bits_per_pixel
=
=
0
)
|
|
(
src_bits_per_pixel
%
8
!
=
0
)
)
{
return
SkCodec
:
:
kInternalError
;
}
size_t
src_bytes_per_pixel
=
src_bits_per_pixel
/
8
;
wuffs_base__rect_ie_u32
frame_rect
=
fFrameConfig
.
bounds
(
)
;
wuffs_base__table_u8
pixels
=
fPixelBuffer
.
plane
(
0
)
;
for
(
uint32_t
y
=
frame_rect
.
min_incl_y
;
y
<
frame_rect
.
max_excl_y
;
y
+
+
)
{
sk_bzero
(
pixels
.
ptr
+
(
y
*
pixels
.
stride
)
+
(
frame_rect
.
min_incl_x
*
src_bytes_per_pixel
)
frame_rect
.
width
(
)
*
src_bytes_per_pixel
)
;
}
fIncrDecDst
=
static_cast
<
uint8_t
*
>
(
dst
)
;
fIncrDecRowBytes
=
rowBytes
;
fFirstCallToIncrementalDecode
=
true
;
return
SkCodec
:
:
kSuccess
;
}
static
SkAlphaType
to_alpha_type
(
bool
opaque
)
{
return
opaque
?
kOpaque_SkAlphaType
:
kPremul_SkAlphaType
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onIncrementalDecode
(
int
*
rowsDecoded
)
{
if
(
!
fIncrDecDst
)
{
return
SkCodec
:
:
kInternalError
;
}
SkCodec
:
:
Result
result
=
SkCodec
:
:
kSuccess
;
const
char
*
status
=
this
-
>
decodeFrame
(
)
;
bool
independent
;
SkAlphaType
alphaType
;
const
int
index
=
options
(
)
.
fFrameIndex
;
if
(
index
=
=
0
)
{
independent
=
true
;
alphaType
=
to_alpha_type
(
getEncodedInfo
(
)
.
opaque
(
)
)
;
}
else
{
const
SkWuffsFrame
*
f
=
this
-
>
frame
(
index
)
;
independent
=
f
-
>
getRequiredFrame
(
)
=
=
SkCodec
:
:
kNoFrame
;
alphaType
=
to_alpha_type
(
f
-
>
reportedAlpha
(
)
=
=
SkEncodedInfo
:
:
kOpaque_Alpha
)
;
}
if
(
status
!
=
nullptr
)
{
if
(
status
=
=
wuffs_base__suspension__short_read
)
{
result
=
SkCodec
:
:
kIncompleteInput
;
}
else
{
SkCodecPrintf
(
"
decodeFrame
:
%
s
"
status
)
;
result
=
SkCodec
:
:
kErrorInInput
;
}
if
(
!
independent
)
{
return
result
;
}
}
uint32_t
src_bits_per_pixel
=
wuffs_base__pixel_format__bits_per_pixel
(
fPixelBuffer
.
pixcfg
.
pixel_format
(
)
)
;
if
(
(
src_bits_per_pixel
=
=
0
)
|
|
(
src_bits_per_pixel
%
8
!
=
0
)
)
{
return
SkCodec
:
:
kInternalError
;
}
size_t
src_bytes_per_pixel
=
src_bits_per_pixel
/
8
;
wuffs_base__rect_ie_u32
frame_rect
=
fFrameConfig
.
bounds
(
)
;
if
(
fFirstCallToIncrementalDecode
)
{
if
(
frame_rect
.
width
(
)
>
(
SIZE_MAX
/
src_bytes_per_pixel
)
)
{
return
SkCodec
:
:
kInternalError
;
}
auto
bounds
=
SkIRect
:
:
MakeLTRB
(
frame_rect
.
min_incl_x
frame_rect
.
min_incl_y
frame_rect
.
max_excl_x
frame_rect
.
max_excl_y
)
;
if
(
independent
&
&
(
bounds
!
=
this
-
>
bounds
(
)
|
|
result
!
=
kSuccess
)
)
{
SkSampler
:
:
Fill
(
dstInfo
(
)
fIncrDecDst
fIncrDecRowBytes
options
(
)
.
fZeroInitialized
)
;
}
fFirstCallToIncrementalDecode
=
false
;
}
else
{
SkASSERT
(
index
=
=
0
)
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
dstInfo
(
)
.
height
(
)
;
}
wuffs_base__rect_ie_u32
dirty_rect
=
fDecoder
-
>
frame_dirty_rect
(
)
;
if
(
!
dirty_rect
.
is_empty
(
)
)
{
wuffs_base__table_u8
pixels
=
fPixelBuffer
.
plane
(
0
)
;
uint8_t
*
s
=
pixels
.
ptr
+
(
dirty_rect
.
min_incl_y
*
pixels
.
stride
)
+
(
dirty_rect
.
min_incl_x
*
src_bytes_per_pixel
)
;
SkASSERT
(
!
getEncodedInfo
(
)
.
profile
(
)
)
;
auto
srcInfo
=
getInfo
(
)
.
makeWH
(
dirty_rect
.
width
(
)
dirty_rect
.
height
(
)
)
.
makeAlphaType
(
alphaType
)
;
SkBitmap
src
;
src
.
installPixels
(
srcInfo
s
pixels
.
stride
)
;
SkPaint
paint
;
if
(
independent
)
{
paint
.
setBlendMode
(
SkBlendMode
:
:
kSrc
)
;
}
SkDraw
draw
;
draw
.
fDst
.
reset
(
dstInfo
(
)
fIncrDecDst
fIncrDecRowBytes
)
;
SkMatrix
matrix
=
SkMatrix
:
:
MakeRectToRect
(
SkRect
:
:
Make
(
this
-
>
dimensions
(
)
)
SkRect
:
:
Make
(
this
-
>
dstInfo
(
)
.
dimensions
(
)
)
SkMatrix
:
:
kFill_ScaleToFit
)
;
draw
.
fMatrix
=
&
matrix
;
SkRasterClip
rc
(
SkIRect
:
:
MakeSize
(
this
-
>
dstInfo
(
)
.
dimensions
(
)
)
)
;
draw
.
fRC
=
&
rc
;
SkMatrix
translate
=
SkMatrix
:
:
MakeTrans
(
dirty_rect
.
min_incl_x
dirty_rect
.
min_incl_y
)
;
draw
.
drawBitmap
(
src
translate
nullptr
paint
)
;
}
if
(
result
=
=
SkCodec
:
:
kSuccess
)
{
fIncrDecDst
=
nullptr
;
fIncrDecRowBytes
=
0
;
}
return
result
;
}
int
SkWuffsCodec
:
:
onGetFrameCount
(
)
{
bool
incrementalDecodeIsInProgress
=
fIncrDecDst
!
=
nullptr
;
if
(
!
fFramesComplete
&
&
!
incrementalDecodeIsInProgress
)
{
this
-
>
readFrames
(
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
}
return
fFrames
.
size
(
)
;
}
bool
SkWuffsCodec
:
:
onGetFrameInfo
(
int
i
SkCodec
:
:
FrameInfo
*
frameInfo
)
const
{
const
SkWuffsFrame
*
f
=
this
-
>
frame
(
i
)
;
if
(
!
f
)
{
return
false
;
}
if
(
frameInfo
)
{
*
frameInfo
=
f
-
>
frameInfo
(
static_cast
<
uint64_t
>
(
i
)
<
this
-
>
fNumFullyReceivedFrames
)
;
}
return
true
;
}
int
SkWuffsCodec
:
:
onGetRepetitionCount
(
)
{
uint32_t
n
=
fDecoder
-
>
num_animation_loops
(
)
;
if
(
n
=
=
0
)
{
return
SkCodec
:
:
kRepetitionCountInfinite
;
}
n
-
-
;
return
n
<
INT_MAX
?
n
:
INT_MAX
;
}
void
SkWuffsCodec
:
:
readFrames
(
)
{
size_t
n
=
fFrames
.
size
(
)
;
int
i
=
n
?
n
-
1
:
0
;
if
(
this
-
>
seekFrame
(
i
)
!
=
SkCodec
:
:
kSuccess
)
{
return
;
}
for
(
;
i
<
INT_MAX
;
i
+
+
)
{
const
char
*
status
=
this
-
>
decodeFrameConfig
(
)
;
if
(
status
=
=
nullptr
)
{
}
else
if
(
status
=
=
wuffs_base__warning__end_of_data
)
{
break
;
}
else
{
return
;
}
if
(
static_cast
<
size_t
>
(
i
)
<
fFrames
.
size
(
)
)
{
continue
;
}
fFrames
.
emplace_back
(
&
fFrameConfig
)
;
SkWuffsFrame
*
f
=
&
fFrames
[
fFrames
.
size
(
)
-
1
]
;
fFrameHolder
.
setAlphaAndRequiredFrame
(
f
)
;
}
fFramesComplete
=
true
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
seekFrame
(
int
frameIndex
)
{
if
(
fDecoderIsSuspended
)
{
SkCodec
:
:
Result
res
=
this
-
>
resetDecoder
(
)
;
if
(
res
!
=
SkCodec
:
:
kSuccess
)
{
return
res
;
}
}
uint64_t
pos
=
0
;
if
(
frameIndex
<
0
)
{
return
SkCodec
:
:
kInternalError
;
}
else
if
(
frameIndex
=
=
0
)
{
pos
=
fFirstFrameIOPosition
;
}
else
if
(
static_cast
<
size_t
>
(
frameIndex
)
<
fFrames
.
size
(
)
)
{
pos
=
fFrames
[
frameIndex
]
.
ioPosition
(
)
;
}
else
{
return
SkCodec
:
:
kInternalError
;
}
if
(
!
seek_buffer
(
&
fIOBuffer
fStream
.
get
(
)
pos
)
)
{
return
SkCodec
:
:
kInternalError
;
}
const
char
*
status
=
fDecoder
-
>
restart_frame
(
frameIndex
fIOBuffer
.
reader_io_position
(
)
)
;
if
(
status
!
=
nullptr
)
{
return
SkCodec
:
:
kInternalError
;
}
return
SkCodec
:
:
kSuccess
;
}
static
SkCodec
:
:
Result
reset_and_decode_image_config
(
wuffs_gif__decoder
*
decoder
wuffs_base__image_config
*
imgcfg
wuffs_base__io_buffer
*
b
SkStream
*
s
)
{
const
char
*
status
=
decoder
-
>
initialize
(
sizeof__wuffs_gif__decoder
(
)
WUFFS_VERSION
0
)
;
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
initialize
:
%
s
"
status
)
;
return
SkCodec
:
:
kInternalError
;
}
while
(
true
)
{
status
=
decoder
-
>
decode_image_config
(
imgcfg
b
)
;
if
(
status
=
=
nullptr
)
{
break
;
}
else
if
(
status
!
=
wuffs_base__suspension__short_read
)
{
SkCodecPrintf
(
"
decode_image_config
:
%
s
"
status
)
;
return
SkCodec
:
:
kErrorInInput
;
}
else
if
(
!
fill_buffer
(
b
s
)
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
}
wuffs_base__pixel_format
pixfmt
=
0
;
switch
(
kN32_SkColorType
)
{
case
kBGRA_8888_SkColorType
:
pixfmt
=
WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL
;
break
;
case
kRGBA_8888_SkColorType
:
pixfmt
=
WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL
;
break
;
default
:
return
SkCodec
:
:
kInternalError
;
}
if
(
imgcfg
)
{
imgcfg
-
>
pixcfg
.
set
(
pixfmt
WUFFS_BASE__PIXEL_SUBSAMPLING__NONE
imgcfg
-
>
pixcfg
.
width
(
)
imgcfg
-
>
pixcfg
.
height
(
)
)
;
}
return
SkCodec
:
:
kSuccess
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
resetDecoder
(
)
{
if
(
!
fStream
-
>
rewind
(
)
)
{
return
SkCodec
:
:
kInternalError
;
}
fIOBuffer
.
meta
=
wuffs_base__empty_io_buffer_meta
(
)
;
SkCodec
:
:
Result
result
=
reset_and_decode_image_config
(
fDecoder
.
get
(
)
nullptr
&
fIOBuffer
fStream
.
get
(
)
)
;
if
(
result
=
=
SkCodec
:
:
kIncompleteInput
)
{
return
SkCodec
:
:
kInternalError
;
}
else
if
(
result
!
=
SkCodec
:
:
kSuccess
)
{
return
result
;
}
fDecoderIsSuspended
=
false
;
return
SkCodec
:
:
kSuccess
;
}
const
char
*
SkWuffsCodec
:
:
decodeFrameConfig
(
)
{
while
(
true
)
{
const
char
*
status
=
fDecoder
-
>
decode_frame_config
(
&
fFrameConfig
&
fIOBuffer
)
;
if
(
(
status
=
=
wuffs_base__suspension__short_read
)
&
&
fill_buffer
(
&
fIOBuffer
fStream
.
get
(
)
)
)
{
continue
;
}
fDecoderIsSuspended
=
!
wuffs_base__status__is_complete
(
status
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
return
status
;
}
}
const
char
*
SkWuffsCodec
:
:
decodeFrame
(
)
{
while
(
true
)
{
const
char
*
status
=
fDecoder
-
>
decode_frame
(
&
fPixelBuffer
&
fIOBuffer
wuffs_base__make_slice_u8
(
fWorkbufPtr
.
get
(
)
fWorkbufLen
)
NULL
)
;
if
(
(
status
=
=
wuffs_base__suspension__short_read
)
&
&
fill_buffer
(
&
fIOBuffer
fStream
.
get
(
)
)
)
{
continue
;
}
fDecoderIsSuspended
=
!
wuffs_base__status__is_complete
(
status
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
return
status
;
}
}
void
SkWuffsCodec
:
:
updateNumFullyReceivedFrames
(
)
{
uint64_t
n
=
fDecoder
-
>
num_decoded_frames
(
)
;
if
(
fNumFullyReceivedFrames
<
n
)
{
fNumFullyReceivedFrames
=
n
;
}
}
bool
SkWuffsCodec_IsFormat
(
const
void
*
buf
size_t
bytesRead
)
{
constexpr
const
char
*
gif_ptr
=
"
GIF8
"
;
constexpr
size_t
gif_len
=
4
;
return
(
bytesRead
>
=
gif_len
)
&
&
(
memcmp
(
buf
gif_ptr
gif_len
)
=
=
0
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
SkWuffsCodec_MakeFromStream
(
std
:
:
unique_ptr
<
SkStream
>
stream
SkCodec
:
:
Result
*
result
)
{
uint8_t
buffer
[
SK_WUFFS_CODEC_BUFFER_SIZE
]
;
wuffs_base__io_buffer
iobuf
=
wuffs_base__make_io_buffer
(
wuffs_base__make_slice_u8
(
buffer
SK_WUFFS_CODEC_BUFFER_SIZE
)
wuffs_base__empty_io_buffer_meta
(
)
)
;
wuffs_base__image_config
imgcfg
=
wuffs_base__null_image_config
(
)
;
void
*
decoder_raw
=
sk_malloc_canfail
(
sizeof__wuffs_gif__decoder
(
)
)
;
if
(
!
decoder_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
decoder
(
reinterpret_cast
<
wuffs_gif__decoder
*
>
(
decoder_raw
)
&
sk_free
)
;
SkCodec
:
:
Result
reset_result
=
reset_and_decode_image_config
(
decoder
.
get
(
)
&
imgcfg
&
iobuf
stream
.
get
(
)
)
;
if
(
reset_result
!
=
SkCodec
:
:
kSuccess
)
{
*
result
=
reset_result
;
return
nullptr
;
}
uint32_t
width
=
imgcfg
.
pixcfg
.
width
(
)
;
uint32_t
height
=
imgcfg
.
pixcfg
.
height
(
)
;
if
(
(
width
=
=
0
)
|
|
(
width
>
INT_MAX
)
|
|
(
height
=
=
0
)
|
|
(
height
>
INT_MAX
)
)
{
*
result
=
SkCodec
:
:
kInvalidInput
;
return
nullptr
;
}
uint64_t
workbuf_len
=
decoder
-
>
workbuf_len
(
)
.
max_incl
;
void
*
workbuf_ptr_raw
=
nullptr
;
if
(
workbuf_len
)
{
workbuf_ptr_raw
=
workbuf_len
<
=
SIZE_MAX
?
sk_malloc_canfail
(
workbuf_len
)
:
nullptr
;
if
(
!
workbuf_ptr_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
}
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
(
reinterpret_cast
<
uint8_t
*
>
(
workbuf_ptr_raw
)
&
sk_free
)
;
uint64_t
pixbuf_len
=
imgcfg
.
pixcfg
.
pixbuf_len
(
)
;
void
*
pixbuf_ptr_raw
=
pixbuf_len
<
=
SIZE_MAX
?
sk_malloc_canfail
(
pixbuf_len
)
:
nullptr
;
if
(
!
pixbuf_ptr_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
(
reinterpret_cast
<
uint8_t
*
>
(
pixbuf_ptr_raw
)
&
sk_free
)
;
wuffs_base__pixel_buffer
pixbuf
=
wuffs_base__null_pixel_buffer
(
)
;
const
char
*
status
=
pixbuf
.
set_from_slice
(
&
imgcfg
.
pixcfg
wuffs_base__make_slice_u8
(
pixbuf_ptr
.
get
(
)
SkToSizeT
(
pixbuf_len
)
)
)
;
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
set_from_slice
:
%
s
"
status
)
;
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
SkEncodedInfo
:
:
Color
color
=
(
imgcfg
.
pixcfg
.
pixel_format
(
)
=
=
WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL
)
?
SkEncodedInfo
:
:
kBGRA_Color
:
SkEncodedInfo
:
:
kRGBA_Color
;
SkEncodedInfo
:
:
Alpha
alpha
=
imgcfg
.
first_frame_is_opaque
(
)
?
SkEncodedInfo
:
:
kOpaque_Alpha
:
SkEncodedInfo
:
:
kBinary_Alpha
;
SkEncodedInfo
encodedInfo
=
SkEncodedInfo
:
:
Make
(
width
height
color
alpha
8
)
;
*
result
=
SkCodec
:
:
kSuccess
;
return
std
:
:
unique_ptr
<
SkCodec
>
(
new
SkWuffsCodec
(
std
:
:
move
(
encodedInfo
)
std
:
:
move
(
stream
)
std
:
:
move
(
decoder
)
std
:
:
move
(
pixbuf_ptr
)
std
:
:
move
(
workbuf_ptr
)
workbuf_len
imgcfg
pixbuf
iobuf
)
)
;
}
