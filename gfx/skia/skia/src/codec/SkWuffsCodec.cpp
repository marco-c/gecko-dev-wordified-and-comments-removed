#
include
"
SkWuffsCodec
.
h
"
#
include
"
.
.
/
private
/
SkMalloc
.
h
"
#
include
"
SkFrameHolder
.
h
"
#
include
"
SkSampler
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
wuffs
-
v0
.
2
.
c
"
#
if
WUFFS_VERSION_BUILD_METADATA_COMMIT_COUNT
<
1640
#
error
"
Wuffs
version
is
too
old
.
Upgrade
to
the
latest
version
.
"
#
endif
#
define
SK_WUFFS_CODEC_BUFFER_SIZE
4096
static
bool
fill_buffer
(
wuffs_base__io_buffer
*
b
SkStream
*
s
)
{
b
-
>
compact
(
)
;
size_t
num_read
=
s
-
>
read
(
b
-
>
data
.
ptr
+
b
-
>
meta
.
wi
b
-
>
data
.
len
-
b
-
>
meta
.
wi
)
;
b
-
>
meta
.
wi
+
=
num_read
;
b
-
>
meta
.
closed
=
s
-
>
isAtEnd
(
)
;
return
num_read
>
0
;
}
static
bool
seek_buffer
(
wuffs_base__io_buffer
*
b
SkStream
*
s
uint64_t
pos
)
{
if
(
(
pos
>
=
b
-
>
meta
.
pos
)
&
&
(
pos
-
b
-
>
meta
.
pos
<
=
b
-
>
meta
.
wi
)
)
{
b
-
>
meta
.
ri
=
pos
-
b
-
>
meta
.
pos
;
return
true
;
}
if
(
(
pos
>
SIZE_MAX
)
|
|
(
!
s
-
>
seek
(
pos
)
)
)
{
return
false
;
}
b
-
>
meta
.
wi
=
0
;
b
-
>
meta
.
ri
=
0
;
b
-
>
meta
.
pos
=
pos
;
b
-
>
meta
.
closed
=
false
;
return
true
;
}
static
SkEncodedInfo
:
:
Alpha
wuffs_blend_to_skia_alpha
(
wuffs_base__animation_blend
w
)
{
return
(
w
=
=
WUFFS_BASE__ANIMATION_BLEND__OPAQUE
)
?
SkEncodedInfo
:
:
kOpaque_Alpha
:
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
static
SkCodecAnimation
:
:
Blend
wuffs_blend_to_skia_blend
(
wuffs_base__animation_blend
w
)
{
return
(
w
=
=
WUFFS_BASE__ANIMATION_BLEND__SRC
)
?
SkCodecAnimation
:
:
Blend
:
:
kBG
:
SkCodecAnimation
:
:
Blend
:
:
kPriorFrame
;
}
static
SkCodecAnimation
:
:
DisposalMethod
wuffs_disposal_to_skia_disposal
(
wuffs_base__animation_disposal
w
)
{
switch
(
w
)
{
case
WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_BACKGROUND
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kRestoreBGColor
;
case
WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_PREVIOUS
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kRestorePrevious
;
default
:
return
SkCodecAnimation
:
:
DisposalMethod
:
:
kKeep
;
}
}
class
SkWuffsCodec
;
class
SkWuffsFrame
final
:
public
SkFrame
{
public
:
SkWuffsFrame
(
wuffs_base__frame_config
*
fc
)
;
SkCodec
:
:
FrameInfo
frameInfo
(
bool
fullyReceived
)
const
;
uint64_t
ioPosition
(
)
const
;
SkEncodedInfo
:
:
Alpha
onReportedAlpha
(
)
const
override
;
private
:
uint64_t
fIOPosition
;
SkEncodedInfo
:
:
Alpha
fReportedAlpha
;
typedef
SkFrame
INHERITED
;
}
;
class
SkWuffsFrameHolder
final
:
public
SkFrameHolder
{
public
:
SkWuffsFrameHolder
(
)
:
INHERITED
(
)
{
}
void
init
(
SkWuffsCodec
*
codec
int
width
int
height
)
;
const
SkFrame
*
onGetFrame
(
int
i
)
const
override
;
private
:
const
SkWuffsCodec
*
fCodec
;
typedef
SkFrameHolder
INHERITED
;
}
;
class
SkWuffsSpySampler
final
:
public
SkSampler
{
public
:
SkWuffsSpySampler
(
int
imageWidth
)
:
INHERITED
(
)
fFillWidth
(
0
)
fImageWidth
(
imageWidth
)
fSampleX
(
1
)
{
}
void
reset
(
)
;
int
sampleX
(
)
const
;
int
fFillWidth
;
private
:
int
fillWidth
(
)
const
override
;
int
onSetSampleX
(
int
sampleX
)
override
;
const
int
fImageWidth
;
int
fSampleX
;
typedef
SkSampler
INHERITED
;
}
;
class
SkWuffsCodec
final
:
public
SkCodec
{
public
:
SkWuffsCodec
(
SkEncodedInfo
&
&
encodedInfo
std
:
:
unique_ptr
<
SkStream
>
stream
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
dec
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
size_t
workbuf_len
wuffs_base__image_config
imgcfg
wuffs_base__pixel_buffer
pixbuf
wuffs_base__io_buffer
iobuf
)
;
const
SkWuffsFrame
*
frame
(
int
i
)
const
;
private
:
SkEncodedImageFormat
onGetEncodedFormat
(
)
const
override
;
Result
onGetPixels
(
const
SkImageInfo
&
void
*
size_t
const
Options
&
int
*
)
override
;
const
SkFrameHolder
*
getFrameHolder
(
)
const
override
;
Result
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
)
override
;
Result
onIncrementalDecode
(
int
*
rowsDecoded
)
override
;
int
onGetFrameCount
(
)
override
;
bool
onGetFrameInfo
(
int
FrameInfo
*
)
const
override
;
int
onGetRepetitionCount
(
)
override
;
SkSampler
*
getSampler
(
bool
createIfNecessary
)
override
;
bool
conversionSupported
(
const
SkImageInfo
&
dst
bool
bool
)
override
;
void
readFrames
(
)
;
Result
seekFrame
(
int
frameIndex
)
;
Result
resetDecoder
(
)
;
const
char
*
decodeFrameConfig
(
)
;
const
char
*
decodeFrame
(
)
;
void
updateNumFullyReceivedFrames
(
)
;
SkWuffsSpySampler
fSpySampler
;
SkWuffsFrameHolder
fFrameHolder
;
std
:
:
unique_ptr
<
SkStream
>
fStream
;
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
fDecoder
;
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
fPixbufPtr
;
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
fWorkbufPtr
;
size_t
fWorkbufLen
;
const
uint64_t
fFirstFrameIOPosition
;
wuffs_base__frame_config
fFrameConfig
;
wuffs_base__pixel_buffer
fPixelBuffer
;
wuffs_base__io_buffer
fIOBuffer
;
uint8_t
*
fIncrDecDst
;
size_t
fIncrDecRowBytes
;
std
:
:
unique_ptr
<
SkSwizzler
>
fSwizzler
;
int
fScaledHeight
;
uint64_t
fNumFullyReceivedFrames
;
std
:
:
vector
<
SkWuffsFrame
>
fFrames
;
bool
fFramesComplete
;
bool
fDecoderIsSuspended
;
uint8_t
fBuffer
[
SK_WUFFS_CODEC_BUFFER_SIZE
]
;
typedef
SkCodec
INHERITED
;
}
;
SkWuffsFrame
:
:
SkWuffsFrame
(
wuffs_base__frame_config
*
fc
)
:
INHERITED
(
fc
-
>
index
(
)
)
fIOPosition
(
fc
-
>
io_position
(
)
)
fReportedAlpha
(
wuffs_blend_to_skia_alpha
(
fc
-
>
blend
(
)
)
)
{
wuffs_base__rect_ie_u32
r
=
fc
-
>
bounds
(
)
;
this
-
>
setXYWH
(
r
.
min_incl_x
r
.
min_incl_y
r
.
width
(
)
r
.
height
(
)
)
;
this
-
>
setDisposalMethod
(
wuffs_disposal_to_skia_disposal
(
fc
-
>
disposal
(
)
)
)
;
this
-
>
setDuration
(
fc
-
>
duration
(
)
/
WUFFS_BASE__FLICKS_PER_MILLISECOND
)
;
this
-
>
setBlend
(
wuffs_blend_to_skia_blend
(
fc
-
>
blend
(
)
)
)
;
}
SkCodec
:
:
FrameInfo
SkWuffsFrame
:
:
frameInfo
(
bool
fullyReceived
)
const
{
return
(
(
SkCodec
:
:
FrameInfo
)
{
.
fRequiredFrame
=
getRequiredFrame
(
)
.
fDuration
=
getDuration
(
)
.
fFullyReceived
=
fullyReceived
.
fAlphaType
=
hasAlpha
(
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
.
fDisposalMethod
=
getDisposalMethod
(
)
}
)
;
}
uint64_t
SkWuffsFrame
:
:
ioPosition
(
)
const
{
return
fIOPosition
;
}
SkEncodedInfo
:
:
Alpha
SkWuffsFrame
:
:
onReportedAlpha
(
)
const
{
return
fReportedAlpha
;
}
void
SkWuffsFrameHolder
:
:
init
(
SkWuffsCodec
*
codec
int
width
int
height
)
{
fCodec
=
codec
;
fScreenWidth
=
width
;
fScreenHeight
=
height
;
}
const
SkFrame
*
SkWuffsFrameHolder
:
:
onGetFrame
(
int
i
)
const
{
return
fCodec
-
>
frame
(
i
)
;
}
;
void
SkWuffsSpySampler
:
:
reset
(
)
{
fFillWidth
=
0
;
fSampleX
=
1
;
this
-
>
setSampleY
(
1
)
;
}
int
SkWuffsSpySampler
:
:
sampleX
(
)
const
{
return
fSampleX
;
}
int
SkWuffsSpySampler
:
:
fillWidth
(
)
const
{
return
fFillWidth
;
}
int
SkWuffsSpySampler
:
:
onSetSampleX
(
int
sampleX
)
{
fSampleX
=
sampleX
;
return
get_scaled_dimension
(
fImageWidth
sampleX
)
;
}
SkWuffsCodec
:
:
SkWuffsCodec
(
SkEncodedInfo
&
&
encodedInfo
std
:
:
unique_ptr
<
SkStream
>
stream
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
dec
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
size_t
workbuf_len
wuffs_base__image_config
imgcfg
wuffs_base__pixel_buffer
pixbuf
wuffs_base__io_buffer
iobuf
)
:
INHERITED
(
std
:
:
move
(
encodedInfo
)
skcms_PixelFormat_RGBA_8888
nullptr
)
fSpySampler
(
imgcfg
.
pixcfg
.
width
(
)
)
fFrameHolder
(
)
fStream
(
std
:
:
move
(
stream
)
)
fDecoder
(
std
:
:
move
(
dec
)
)
fPixbufPtr
(
std
:
:
move
(
pixbuf_ptr
)
)
fWorkbufPtr
(
std
:
:
move
(
workbuf_ptr
)
)
fWorkbufLen
(
workbuf_len
)
fFirstFrameIOPosition
(
imgcfg
.
first_frame_io_position
(
)
)
fFrameConfig
(
(
wuffs_base__frame_config
)
{
}
)
fPixelBuffer
(
pixbuf
)
fIOBuffer
(
(
wuffs_base__io_buffer
)
{
}
)
fIncrDecDst
(
nullptr
)
fIncrDecRowBytes
(
0
)
fSwizzler
(
nullptr
)
fScaledHeight
(
0
)
fNumFullyReceivedFrames
(
0
)
fFramesComplete
(
false
)
fDecoderIsSuspended
(
false
)
{
fFrameHolder
.
init
(
this
imgcfg
.
pixcfg
.
width
(
)
imgcfg
.
pixcfg
.
height
(
)
)
;
SkASSERT
(
iobuf
.
data
.
len
=
=
SK_WUFFS_CODEC_BUFFER_SIZE
)
;
memmove
(
fBuffer
iobuf
.
data
.
ptr
iobuf
.
meta
.
wi
)
;
fIOBuffer
=
(
(
wuffs_base__io_buffer
)
{
.
data
=
(
(
wuffs_base__slice_u8
)
{
.
ptr
=
fBuffer
.
len
=
SK_WUFFS_CODEC_BUFFER_SIZE
}
)
.
meta
=
iobuf
.
meta
}
)
;
}
const
SkWuffsFrame
*
SkWuffsCodec
:
:
frame
(
int
i
)
const
{
if
(
(
0
<
=
i
)
&
&
(
static_cast
<
size_t
>
(
i
)
<
fFrames
.
size
(
)
)
)
{
return
&
fFrames
[
i
]
;
}
return
nullptr
;
}
SkEncodedImageFormat
SkWuffsCodec
:
:
onGetEncodedFormat
(
)
const
{
return
SkEncodedImageFormat
:
:
kGIF
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
int
*
rowsDecoded
)
{
SkCodec
:
:
Result
result
=
this
-
>
onStartIncrementalDecode
(
dstInfo
dst
rowBytes
options
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
return
this
-
>
onIncrementalDecode
(
rowsDecoded
)
;
}
const
SkFrameHolder
*
SkWuffsCodec
:
:
getFrameHolder
(
)
const
{
return
&
fFrameHolder
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
)
{
if
(
options
.
fSubset
)
{
return
SkCodec
:
:
kUnimplemented
;
}
SkCodec
:
:
Result
result
=
this
-
>
seekFrame
(
options
.
fFrameIndex
)
;
if
(
result
!
=
SkCodec
:
:
kSuccess
)
{
return
result
;
}
fSpySampler
.
reset
(
)
;
fSwizzler
=
nullptr
;
fScaledHeight
=
0
;
const
char
*
status
=
this
-
>
decodeFrameConfig
(
)
;
if
(
status
=
=
wuffs_base__suspension__short_read
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
else
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
decodeFrameConfig
:
%
s
"
status
)
;
return
SkCodec
:
:
kErrorInInput
;
}
uint32_t
src_bits_per_pixel
=
wuffs_base__pixel_format__bits_per_pixel
(
fPixelBuffer
.
pixcfg
.
pixel_format
(
)
)
;
if
(
(
src_bits_per_pixel
=
=
0
)
|
|
(
src_bits_per_pixel
%
8
!
=
0
)
)
{
return
SkCodec
:
:
kInternalError
;
}
size_t
src_bytes_per_pixel
=
src_bits_per_pixel
/
8
;
wuffs_base__rect_ie_u32
frame_rect
=
fFrameConfig
.
bounds
(
)
;
wuffs_base__table_u8
pixels
=
fPixelBuffer
.
plane
(
0
)
;
for
(
uint32_t
y
=
frame_rect
.
min_incl_y
;
y
<
frame_rect
.
max_excl_y
;
y
+
+
)
{
sk_bzero
(
pixels
.
ptr
+
(
y
*
pixels
.
stride
)
+
(
frame_rect
.
min_incl_x
*
src_bytes_per_pixel
)
frame_rect
.
width
(
)
*
src_bytes_per_pixel
)
;
}
fIncrDecDst
=
static_cast
<
uint8_t
*
>
(
dst
)
;
fIncrDecRowBytes
=
rowBytes
;
return
SkCodec
:
:
kSuccess
;
}
static
bool
independent_frame
(
SkCodec
*
codec
int
frameIndex
)
{
if
(
frameIndex
=
=
0
)
{
return
true
;
}
SkCodec
:
:
FrameInfo
frameInfo
;
SkAssertResult
(
codec
-
>
getFrameInfo
(
frameIndex
&
frameInfo
)
)
;
return
frameInfo
.
fRequiredFrame
=
=
SkCodec
:
:
kNoFrame
;
}
static
void
blend
(
uint32_t
*
dst
const
uint32_t
*
src
int
width
)
{
while
(
width
-
-
>
0
)
{
if
(
*
src
!
=
0
)
{
*
dst
=
*
src
;
}
src
+
+
;
dst
+
+
;
}
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
onIncrementalDecode
(
int
*
rowsDecoded
)
{
if
(
!
fIncrDecDst
)
{
return
SkCodec
:
:
kInternalError
;
}
SkCodec
:
:
Result
result
=
SkCodec
:
:
kSuccess
;
const
char
*
status
=
this
-
>
decodeFrame
(
)
;
const
bool
independent
=
independent_frame
(
this
options
(
)
.
fFrameIndex
)
;
if
(
status
!
=
nullptr
)
{
if
(
status
=
=
wuffs_base__suspension__short_read
)
{
result
=
SkCodec
:
:
kIncompleteInput
;
}
else
{
SkCodecPrintf
(
"
decodeFrame
:
%
s
"
status
)
;
result
=
SkCodec
:
:
kErrorInInput
;
}
if
(
!
independent
)
{
return
result
;
}
}
uint32_t
src_bits_per_pixel
=
wuffs_base__pixel_format__bits_per_pixel
(
fPixelBuffer
.
pixcfg
.
pixel_format
(
)
)
;
if
(
(
src_bits_per_pixel
=
=
0
)
|
|
(
src_bits_per_pixel
%
8
!
=
0
)
)
{
return
SkCodec
:
:
kInternalError
;
}
size_t
src_bytes_per_pixel
=
src_bits_per_pixel
/
8
;
wuffs_base__rect_ie_u32
frame_rect
=
fFrameConfig
.
bounds
(
)
;
if
(
!
fSwizzler
)
{
auto
bounds
=
SkIRect
:
:
MakeLTRB
(
frame_rect
.
min_incl_x
frame_rect
.
min_incl_y
frame_rect
.
max_excl_x
frame_rect
.
max_excl_y
)
;
fSwizzler
=
SkSwizzler
:
:
Make
(
this
-
>
getEncodedInfo
(
)
nullptr
dstInfo
(
)
this
-
>
options
(
)
&
bounds
)
;
fSwizzler
-
>
setSampleX
(
fSpySampler
.
sampleX
(
)
)
;
fSwizzler
-
>
setSampleY
(
fSpySampler
.
sampleY
(
)
)
;
fScaledHeight
=
get_scaled_dimension
(
dstInfo
(
)
.
height
(
)
fSpySampler
.
sampleY
(
)
)
;
if
(
frame_rect
.
width
(
)
>
(
SIZE_MAX
/
src_bytes_per_pixel
)
)
{
return
SkCodec
:
:
kInternalError
;
}
if
(
independent
&
&
(
bounds
!
=
this
-
>
bounds
(
)
|
|
result
!
=
kSuccess
)
)
{
auto
fillInfo
=
dstInfo
(
)
.
makeWH
(
fSwizzler
-
>
fillWidth
(
)
fScaledHeight
)
;
SkSampler
:
:
Fill
(
fillInfo
fIncrDecDst
fIncrDecRowBytes
options
(
)
.
fZeroInitialized
)
;
}
}
if
(
fScaledHeight
=
=
0
)
{
return
SkCodec
:
:
kInternalError
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
fScaledHeight
;
}
wuffs_base__rect_ie_u32
dirty_rect
=
fDecoder
-
>
frame_dirty_rect
(
)
;
if
(
!
dirty_rect
.
is_empty
(
)
)
{
std
:
:
unique_ptr
<
uint8_t
[
]
>
tmpBuffer
;
if
(
!
independent
)
{
tmpBuffer
.
reset
(
new
uint8_t
[
dstInfo
(
)
.
minRowBytes
(
)
]
)
;
}
wuffs_base__table_u8
pixels
=
fPixelBuffer
.
plane
(
0
)
;
const
int
sampleY
=
fSwizzler
-
>
sampleY
(
)
;
for
(
uint32_t
y
=
dirty_rect
.
min_incl_y
;
y
<
dirty_rect
.
max_excl_y
;
y
+
+
)
{
int
dstY
=
y
;
if
(
sampleY
!
=
1
)
{
if
(
!
fSwizzler
-
>
rowNeeded
(
y
)
)
{
continue
;
}
dstY
/
=
sampleY
;
if
(
dstY
>
=
fScaledHeight
)
{
break
;
}
}
uint8_t
*
d
=
fIncrDecDst
+
(
dstY
*
fIncrDecRowBytes
)
;
uint8_t
*
s
=
pixels
.
ptr
+
(
y
*
pixels
.
stride
)
+
(
frame_rect
.
min_incl_x
*
src_bytes_per_pixel
)
;
if
(
independent
)
{
fSwizzler
-
>
swizzle
(
d
s
)
;
}
else
{
SkASSERT
(
tmpBuffer
.
get
(
)
)
;
fSwizzler
-
>
swizzle
(
tmpBuffer
.
get
(
)
s
)
;
d
=
SkTAddOffset
<
uint8_t
>
(
d
fSwizzler
-
>
swizzleOffsetBytes
(
)
)
;
const
auto
*
swizzled
=
SkTAddOffset
<
uint32_t
>
(
tmpBuffer
.
get
(
)
fSwizzler
-
>
swizzleOffsetBytes
(
)
)
;
blend
(
reinterpret_cast
<
uint32_t
*
>
(
d
)
swizzled
fSwizzler
-
>
swizzleWidth
(
)
)
;
}
}
}
if
(
result
=
=
SkCodec
:
:
kSuccess
)
{
fSpySampler
.
reset
(
)
;
fIncrDecDst
=
nullptr
;
fIncrDecRowBytes
=
0
;
fSwizzler
=
nullptr
;
}
else
{
fSpySampler
.
fFillWidth
=
fSwizzler
-
>
fillWidth
(
)
;
}
return
result
;
}
int
SkWuffsCodec
:
:
onGetFrameCount
(
)
{
if
(
!
fFramesComplete
)
{
this
-
>
readFrames
(
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
}
return
fFrames
.
size
(
)
;
}
bool
SkWuffsCodec
:
:
onGetFrameInfo
(
int
i
SkCodec
:
:
FrameInfo
*
frameInfo
)
const
{
const
SkWuffsFrame
*
f
=
this
-
>
frame
(
i
)
;
if
(
!
f
)
{
return
false
;
}
if
(
frameInfo
)
{
*
frameInfo
=
f
-
>
frameInfo
(
static_cast
<
uint64_t
>
(
i
)
<
this
-
>
fNumFullyReceivedFrames
)
;
}
return
true
;
}
int
SkWuffsCodec
:
:
onGetRepetitionCount
(
)
{
uint32_t
n
=
fDecoder
-
>
num_animation_loops
(
)
;
if
(
n
=
=
0
)
{
return
SkCodec
:
:
kRepetitionCountInfinite
;
}
n
-
-
;
return
n
<
INT_MAX
?
n
:
INT_MAX
;
}
SkSampler
*
SkWuffsCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
createIfNecessary
|
|
fIncrDecDst
)
{
return
&
fSpySampler
;
}
return
nullptr
;
}
bool
SkWuffsCodec
:
:
conversionSupported
(
const
SkImageInfo
&
dst
bool
srcIsOpaque
bool
needsColorXform
)
{
if
(
!
this
-
>
INHERITED
:
:
conversionSupported
(
dst
srcIsOpaque
needsColorXform
)
)
{
return
false
;
}
switch
(
dst
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
return
true
;
default
:
return
false
;
}
}
void
SkWuffsCodec
:
:
readFrames
(
)
{
size_t
n
=
fFrames
.
size
(
)
;
int
i
=
n
?
n
-
1
:
0
;
if
(
this
-
>
seekFrame
(
i
)
!
=
SkCodec
:
:
kSuccess
)
{
return
;
}
for
(
;
i
<
INT_MAX
;
i
+
+
)
{
const
char
*
status
=
this
-
>
decodeFrameConfig
(
)
;
if
(
status
=
=
nullptr
)
{
}
else
if
(
status
=
=
wuffs_base__warning__end_of_data
)
{
break
;
}
else
{
return
;
}
if
(
static_cast
<
size_t
>
(
i
)
<
fFrames
.
size
(
)
)
{
continue
;
}
fFrames
.
emplace_back
(
&
fFrameConfig
)
;
SkWuffsFrame
*
f
=
&
fFrames
[
fFrames
.
size
(
)
-
1
]
;
fFrameHolder
.
setAlphaAndRequiredFrame
(
f
)
;
}
fFramesComplete
=
true
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
seekFrame
(
int
frameIndex
)
{
if
(
fDecoderIsSuspended
)
{
SkCodec
:
:
Result
res
=
this
-
>
resetDecoder
(
)
;
if
(
res
!
=
SkCodec
:
:
kSuccess
)
{
return
res
;
}
}
uint64_t
pos
=
0
;
if
(
frameIndex
<
0
)
{
return
SkCodec
:
:
kInternalError
;
}
else
if
(
frameIndex
=
=
0
)
{
pos
=
fFirstFrameIOPosition
;
}
else
if
(
static_cast
<
size_t
>
(
frameIndex
)
<
fFrames
.
size
(
)
)
{
pos
=
fFrames
[
frameIndex
]
.
ioPosition
(
)
;
}
else
{
return
SkCodec
:
:
kInternalError
;
}
if
(
!
seek_buffer
(
&
fIOBuffer
fStream
.
get
(
)
pos
)
)
{
return
SkCodec
:
:
kInternalError
;
}
const
char
*
status
=
fDecoder
-
>
restart_frame
(
frameIndex
fIOBuffer
.
reader_io_position
(
)
)
;
if
(
status
!
=
nullptr
)
{
return
SkCodec
:
:
kInternalError
;
}
return
SkCodec
:
:
kSuccess
;
}
static
SkCodec
:
:
Result
reset_and_decode_image_config
(
wuffs_gif__decoder
*
decoder
wuffs_base__image_config
*
imgcfg
wuffs_base__io_buffer
*
b
SkStream
*
s
)
{
const
char
*
status
=
decoder
-
>
initialize
(
sizeof__wuffs_gif__decoder
(
)
WUFFS_VERSION
0
)
;
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
initialize
:
%
s
"
status
)
;
return
SkCodec
:
:
kInternalError
;
}
while
(
true
)
{
status
=
decoder
-
>
decode_image_config
(
imgcfg
b
-
>
reader
(
)
)
;
if
(
status
=
=
nullptr
)
{
break
;
}
else
if
(
status
!
=
wuffs_base__suspension__short_read
)
{
SkCodecPrintf
(
"
decode_image_config
:
%
s
"
status
)
;
return
SkCodec
:
:
kErrorInInput
;
}
else
if
(
!
fill_buffer
(
b
s
)
)
{
return
SkCodec
:
:
kIncompleteInput
;
}
}
wuffs_base__pixel_format
pixfmt
=
0
;
switch
(
kN32_SkColorType
)
{
case
kBGRA_8888_SkColorType
:
pixfmt
=
WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL
;
break
;
case
kRGBA_8888_SkColorType
:
pixfmt
=
WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL
;
break
;
default
:
return
SkCodec
:
:
kInternalError
;
}
imgcfg
-
>
pixcfg
.
set
(
pixfmt
WUFFS_BASE__PIXEL_SUBSAMPLING__NONE
imgcfg
-
>
pixcfg
.
width
(
)
imgcfg
-
>
pixcfg
.
height
(
)
)
;
return
SkCodec
:
:
kSuccess
;
}
SkCodec
:
:
Result
SkWuffsCodec
:
:
resetDecoder
(
)
{
if
(
!
fStream
-
>
rewind
(
)
)
{
return
SkCodec
:
:
kInternalError
;
}
fIOBuffer
.
meta
=
(
(
wuffs_base__io_buffer_meta
)
{
}
)
;
SkCodec
:
:
Result
result
=
reset_and_decode_image_config
(
fDecoder
.
get
(
)
nullptr
&
fIOBuffer
fStream
.
get
(
)
)
;
if
(
result
=
=
SkCodec
:
:
kIncompleteInput
)
{
return
SkCodec
:
:
kInternalError
;
}
else
if
(
result
!
=
SkCodec
:
:
kSuccess
)
{
return
result
;
}
fDecoderIsSuspended
=
false
;
return
SkCodec
:
:
kSuccess
;
}
const
char
*
SkWuffsCodec
:
:
decodeFrameConfig
(
)
{
while
(
true
)
{
const
char
*
status
=
fDecoder
-
>
decode_frame_config
(
&
fFrameConfig
fIOBuffer
.
reader
(
)
)
;
if
(
(
status
=
=
wuffs_base__suspension__short_read
)
&
&
fill_buffer
(
&
fIOBuffer
fStream
.
get
(
)
)
)
{
continue
;
}
fDecoderIsSuspended
=
!
wuffs_base__status__is_complete
(
status
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
return
status
;
}
}
const
char
*
SkWuffsCodec
:
:
decodeFrame
(
)
{
while
(
true
)
{
const
char
*
status
=
fDecoder
-
>
decode_frame
(
&
fPixelBuffer
fIOBuffer
.
reader
(
)
(
(
wuffs_base__slice_u8
)
{
.
ptr
=
fWorkbufPtr
.
get
(
)
.
len
=
fWorkbufLen
}
)
NULL
)
;
if
(
(
status
=
=
wuffs_base__suspension__short_read
)
&
&
fill_buffer
(
&
fIOBuffer
fStream
.
get
(
)
)
)
{
continue
;
}
fDecoderIsSuspended
=
!
wuffs_base__status__is_complete
(
status
)
;
this
-
>
updateNumFullyReceivedFrames
(
)
;
return
status
;
}
}
void
SkWuffsCodec
:
:
updateNumFullyReceivedFrames
(
)
{
uint64_t
n
=
fDecoder
-
>
num_decoded_frames
(
)
;
if
(
fNumFullyReceivedFrames
<
n
)
{
fNumFullyReceivedFrames
=
n
;
}
}
bool
SkWuffsCodec_IsFormat
(
const
void
*
buf
size_t
bytesRead
)
{
constexpr
const
char
*
gif_ptr
=
"
GIF8
"
;
constexpr
size_t
gif_len
=
4
;
return
(
bytesRead
>
=
gif_len
)
&
&
(
memcmp
(
buf
gif_ptr
gif_len
)
=
=
0
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
SkWuffsCodec_MakeFromStream
(
std
:
:
unique_ptr
<
SkStream
>
stream
SkCodec
:
:
Result
*
result
)
{
uint8_t
buffer
[
SK_WUFFS_CODEC_BUFFER_SIZE
]
;
wuffs_base__io_buffer
iobuf
=
(
(
wuffs_base__io_buffer
)
{
.
data
=
(
(
wuffs_base__slice_u8
)
{
.
ptr
=
buffer
.
len
=
SK_WUFFS_CODEC_BUFFER_SIZE
}
)
.
meta
=
(
(
wuffs_base__io_buffer_meta
)
{
}
)
}
)
;
wuffs_base__image_config
imgcfg
=
(
(
wuffs_base__image_config
)
{
}
)
;
void
*
decoder_raw
=
sk_malloc_canfail
(
sizeof__wuffs_gif__decoder
(
)
)
;
if
(
!
decoder_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
std
:
:
unique_ptr
<
wuffs_gif__decoder
decltype
(
&
sk_free
)
>
decoder
(
reinterpret_cast
<
wuffs_gif__decoder
*
>
(
decoder_raw
)
&
sk_free
)
;
SkCodec
:
:
Result
reset_result
=
reset_and_decode_image_config
(
decoder
.
get
(
)
&
imgcfg
&
iobuf
stream
.
get
(
)
)
;
if
(
reset_result
!
=
SkCodec
:
:
kSuccess
)
{
*
result
=
reset_result
;
return
nullptr
;
}
uint32_t
width
=
imgcfg
.
pixcfg
.
width
(
)
;
uint32_t
height
=
imgcfg
.
pixcfg
.
height
(
)
;
if
(
(
width
=
=
0
)
|
|
(
width
>
INT_MAX
)
|
|
(
height
=
=
0
)
|
|
(
height
>
INT_MAX
)
)
{
*
result
=
SkCodec
:
:
kInvalidInput
;
return
nullptr
;
}
uint64_t
workbuf_len
=
decoder
-
>
workbuf_len
(
)
.
max_incl
;
void
*
workbuf_ptr_raw
=
nullptr
;
if
(
workbuf_len
)
{
workbuf_ptr_raw
=
workbuf_len
<
=
SIZE_MAX
?
sk_malloc_canfail
(
workbuf_len
)
:
nullptr
;
if
(
!
workbuf_ptr_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
}
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
workbuf_ptr
(
reinterpret_cast
<
uint8_t
*
>
(
workbuf_ptr_raw
)
&
sk_free
)
;
uint64_t
pixbuf_len
=
imgcfg
.
pixcfg
.
pixbuf_len
(
)
;
void
*
pixbuf_ptr_raw
=
pixbuf_len
<
=
SIZE_MAX
?
sk_malloc_canfail
(
pixbuf_len
)
:
nullptr
;
if
(
!
pixbuf_ptr_raw
)
{
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
std
:
:
unique_ptr
<
uint8_t
decltype
(
&
sk_free
)
>
pixbuf_ptr
(
reinterpret_cast
<
uint8_t
*
>
(
pixbuf_ptr_raw
)
&
sk_free
)
;
wuffs_base__pixel_buffer
pixbuf
=
(
(
wuffs_base__pixel_buffer
)
{
}
)
;
const
char
*
status
=
pixbuf
.
set_from_slice
(
&
imgcfg
.
pixcfg
(
(
wuffs_base__slice_u8
)
{
.
ptr
=
pixbuf_ptr
.
get
(
)
.
len
=
SkToSizeT
(
pixbuf_len
)
}
)
)
;
if
(
status
!
=
nullptr
)
{
SkCodecPrintf
(
"
set_from_slice
:
%
s
"
status
)
;
*
result
=
SkCodec
:
:
kInternalError
;
return
nullptr
;
}
SkEncodedInfo
:
:
Color
color
=
(
imgcfg
.
pixcfg
.
pixel_format
(
)
=
=
WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL
)
?
SkEncodedInfo
:
:
kBGRA_Color
:
SkEncodedInfo
:
:
kRGBA_Color
;
SkEncodedInfo
:
:
Alpha
alpha
=
imgcfg
.
first_frame_is_opaque
(
)
?
SkEncodedInfo
:
:
kOpaque_Alpha
:
SkEncodedInfo
:
:
kBinary_Alpha
;
SkEncodedInfo
encodedInfo
=
SkEncodedInfo
:
:
Make
(
width
height
color
alpha
8
)
;
*
result
=
SkCodec
:
:
kSuccess
;
return
std
:
:
unique_ptr
<
SkCodec
>
(
new
SkWuffsCodec
(
std
:
:
move
(
encodedInfo
)
std
:
:
move
(
stream
)
std
:
:
move
(
decoder
)
std
:
:
move
(
pixbuf_ptr
)
std
:
:
move
(
workbuf_ptr
)
workbuf_len
imgcfg
pixbuf
iobuf
)
)
;
}
