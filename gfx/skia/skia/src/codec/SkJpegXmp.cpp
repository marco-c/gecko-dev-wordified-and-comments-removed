#
include
"
src
/
codec
/
SkJpegXmp
.
h
"
#
include
"
include
/
private
/
SkGainmapInfo
.
h
"
#
include
"
include
/
utils
/
SkParse
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
core
/
SkMD5
.
h
"
#
include
"
src
/
xml
/
SkDOM
.
h
"
#
include
<
string
>
#
include
<
tuple
>
constexpr
size_t
kGuidAsciiSize
=
32
;
static
sk_sp
<
SkData
>
read_xmp_standard
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
)
{
constexpr
size_t
kSigSize
=
sizeof
(
kXMPStandardSig
)
;
for
(
const
auto
&
params
:
decoderApp1Params
)
{
if
(
params
-
>
size
(
)
<
=
kSigSize
)
{
continue
;
}
if
(
memcmp
(
params
-
>
bytes
(
)
kXMPStandardSig
kSigSize
)
!
=
0
)
{
continue
;
}
return
SkData
:
:
MakeWithoutCopy
(
params
-
>
bytes
(
)
+
kSigSize
params
-
>
size
(
)
-
kSigSize
)
;
}
return
nullptr
;
}
static
sk_sp
<
SkData
>
read_xmp_extended
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
const
char
*
guidAscii
)
{
constexpr
size_t
kSigSize
=
sizeof
(
kXMPExtendedSig
)
;
constexpr
size_t
kFullLengthSize
=
4
;
constexpr
size_t
kOffsetSize
=
4
;
constexpr
size_t
kHeaderSize
=
kSigSize
+
kGuidAsciiSize
+
kFullLengthSize
+
kOffsetSize
;
if
(
strlen
(
guidAscii
)
!
=
kGuidAsciiSize
)
{
SkCodecPrintf
(
"
Invalid
ASCII
GUID
size
.
\
n
"
)
;
return
nullptr
;
}
SkMD5
:
:
Digest
guidAsDigest
;
for
(
size_t
i
=
0
;
i
<
kGuidAsciiSize
;
+
+
i
)
{
uint8_t
digit
=
0
;
if
(
guidAscii
[
i
]
>
=
'
0
'
&
&
guidAscii
[
i
]
<
=
'
9
'
)
{
digit
=
guidAscii
[
i
]
-
'
0
'
;
}
else
if
(
guidAscii
[
i
]
>
=
'
A
'
&
&
guidAscii
[
i
]
<
=
'
F
'
)
{
digit
=
guidAscii
[
i
]
-
'
A
'
+
10
;
}
else
{
SkCodecPrintf
(
"
GUID
is
not
upper
-
case
hex
.
\
n
"
)
;
return
nullptr
;
}
if
(
i
%
2
=
=
0
)
{
guidAsDigest
.
data
[
i
/
2
]
=
16
*
digit
;
}
else
{
guidAsDigest
.
data
[
i
/
2
]
+
=
digit
;
}
}
uint32_t
fullLength
=
0
;
using
Part
=
std
:
:
tuple
<
uint32_t
sk_sp
<
SkData
>
>
;
std
:
:
vector
<
Part
>
parts
;
for
(
const
auto
&
params
:
decoderApp1Params
)
{
if
(
params
-
>
size
(
)
<
=
kHeaderSize
)
{
continue
;
}
if
(
memcmp
(
params
-
>
bytes
(
)
kXMPExtendedSig
kSigSize
)
!
=
0
)
{
continue
;
}
const
uint8_t
*
partGuidAscii
=
params
-
>
bytes
(
)
+
kSigSize
;
if
(
memcmp
(
guidAscii
partGuidAscii
kGuidAsciiSize
)
!
=
0
)
{
SkCodecPrintf
(
"
Ignoring
unexpected
GUID
.
\
n
"
)
;
continue
;
}
uint32_t
partFullLength
=
0
;
uint32_t
partOffset
=
0
;
const
uint8_t
*
partFullLengthBytes
=
params
-
>
bytes
(
)
+
kSigSize
+
kGuidAsciiSize
;
const
uint8_t
*
partOffsetBytes
=
params
-
>
bytes
(
)
+
kSigSize
+
kGuidAsciiSize
+
kFullLengthSize
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
{
partFullLength
*
=
256
;
partOffset
*
=
256
;
partFullLength
+
=
partFullLengthBytes
[
i
]
;
partOffset
+
=
partOffsetBytes
[
i
]
;
}
if
(
parts
.
empty
(
)
)
{
fullLength
=
partFullLength
;
}
if
(
partFullLength
!
=
fullLength
)
{
SkCodecPrintf
(
"
Multiple
parts
had
different
total
lengths
.
\
n
"
)
;
return
nullptr
;
}
auto
partData
=
SkData
:
:
MakeWithoutCopy
(
params
-
>
bytes
(
)
+
kHeaderSize
params
-
>
size
(
)
-
kHeaderSize
)
;
parts
.
push_back
(
{
partOffset
partData
}
)
;
}
if
(
parts
.
empty
(
)
|
|
fullLength
=
=
0
)
{
return
nullptr
;
}
std
:
:
sort
(
parts
.
begin
(
)
parts
.
end
(
)
[
]
(
const
Part
&
a
const
Part
&
b
)
{
return
std
:
:
get
<
0
>
(
a
)
<
std
:
:
get
<
0
>
(
b
)
;
}
)
;
auto
xmpExtendedData
=
SkData
:
:
MakeUninitialized
(
fullLength
)
;
uint8_t
*
xmpExtendedBase
=
reinterpret_cast
<
uint8_t
*
>
(
xmpExtendedData
-
>
writable_data
(
)
)
;
uint8_t
*
xmpExtendedCurrent
=
xmpExtendedBase
;
SkMD5
md5
;
for
(
const
auto
&
part
:
parts
)
{
uint32_t
currentOffset
=
static_cast
<
uint32_t
>
(
xmpExtendedCurrent
-
xmpExtendedBase
)
;
uint32_t
partOffset
=
std
:
:
get
<
0
>
(
part
)
;
const
sk_sp
<
SkData
>
&
partData
=
std
:
:
get
<
1
>
(
part
)
;
if
(
partOffset
!
=
currentOffset
)
{
SkCodecPrintf
(
"
XMP
extension
parts
not
contiguous
\
n
"
)
;
return
nullptr
;
}
if
(
partData
-
>
size
(
)
>
fullLength
-
currentOffset
)
{
SkCodecPrintf
(
"
XMP
extension
parts
overflow
\
n
"
)
;
return
nullptr
;
}
memcpy
(
xmpExtendedCurrent
partData
-
>
data
(
)
partData
-
>
size
(
)
)
;
xmpExtendedCurrent
+
=
partData
-
>
size
(
)
;
}
if
(
static_cast
<
uint32_t
>
(
xmpExtendedCurrent
-
xmpExtendedBase
)
!
=
fullLength
)
{
SkCodecPrintf
(
"
XMP
extension
did
not
match
full
length
.
\
n
"
)
;
return
nullptr
;
}
md5
.
write
(
xmpExtendedData
-
>
data
(
)
xmpExtendedData
-
>
size
(
)
)
;
if
(
md5
.
finish
(
)
!
=
guidAsDigest
)
{
SkCodecPrintf
(
"
XMP
extension
did
not
hash
to
GUID
.
\
n
"
)
;
return
nullptr
;
}
return
xmpExtendedData
;
}
std
:
:
unique_ptr
<
SkXmp
>
SkJpegMakeXmp
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
)
{
auto
xmpStandard
=
read_xmp_standard
(
decoderApp1Params
)
;
if
(
!
xmpStandard
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkXmp
>
xmp
=
SkXmp
:
:
Make
(
xmpStandard
)
;
if
(
!
xmp
)
{
return
nullptr
;
}
const
char
*
extendedGuid
=
xmp
-
>
getExtendedXmpGuid
(
)
;
if
(
!
extendedGuid
)
{
return
xmp
;
}
auto
xmpExtended
=
read_xmp_extended
(
decoderApp1Params
extendedGuid
)
;
if
(
!
xmpExtended
)
{
SkCodecPrintf
(
"
Extended
XMP
was
indicated
but
failed
to
read
or
validate
.
\
n
"
)
;
return
xmp
;
}
return
SkXmp
:
:
Make
(
xmpStandard
xmpExtended
)
;
}
