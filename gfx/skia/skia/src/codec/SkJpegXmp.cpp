#
include
"
src
/
codec
/
SkJpegXmp
.
h
"
#
include
"
include
/
private
/
SkGainmapInfo
.
h
"
#
include
"
include
/
utils
/
SkParse
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
"
src
/
core
/
SkMD5
.
h
"
#
include
"
src
/
xml
/
SkDOM
.
h
"
#
include
<
string
>
SkJpegXmp
:
:
SkJpegXmp
(
)
=
default
;
constexpr
size_t
kGuidAsciiSize
=
32
;
static
sk_sp
<
SkData
>
read_xmp_standard
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
)
{
constexpr
size_t
kSigSize
=
sizeof
(
kXMPStandardSig
)
;
for
(
const
auto
&
params
:
decoderApp1Params
)
{
if
(
params
-
>
size
(
)
<
=
kSigSize
)
{
continue
;
}
if
(
memcmp
(
params
-
>
bytes
(
)
kXMPStandardSig
kSigSize
)
!
=
0
)
{
continue
;
}
return
SkData
:
:
MakeWithoutCopy
(
params
-
>
bytes
(
)
+
kSigSize
params
-
>
size
(
)
-
kSigSize
)
;
}
return
nullptr
;
}
static
sk_sp
<
SkData
>
read_xmp_extended
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
const
char
*
guidAscii
)
{
constexpr
size_t
kSigSize
=
sizeof
(
kXMPExtendedSig
)
;
constexpr
size_t
kFullLengthSize
=
4
;
constexpr
size_t
kOffsetSize
=
4
;
constexpr
size_t
kHeaderSize
=
kSigSize
+
kGuidAsciiSize
+
kFullLengthSize
+
kOffsetSize
;
SkMD5
:
:
Digest
guidAsDigest
;
if
(
strlen
(
guidAscii
)
!
=
kGuidAsciiSize
)
{
SkCodecPrintf
(
"
Invalid
ASCII
GUID
size
.
\
n
"
)
;
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
kGuidAsciiSize
;
+
+
i
)
{
uint8_t
digit
=
0
;
if
(
guidAscii
[
i
]
>
=
'
0
'
&
&
guidAscii
[
i
]
<
=
'
9
'
)
{
digit
=
guidAscii
[
i
]
-
'
0
'
;
}
else
if
(
guidAscii
[
i
]
>
=
'
A
'
&
&
guidAscii
[
i
]
<
=
'
F
'
)
{
digit
=
guidAscii
[
i
]
-
'
A
'
+
10
;
}
else
{
SkCodecPrintf
(
"
GUID
is
not
upper
-
case
hex
.
\
n
"
)
;
return
nullptr
;
}
if
(
i
%
2
=
=
0
)
{
guidAsDigest
.
data
[
i
/
2
]
=
16
*
digit
;
}
else
{
guidAsDigest
.
data
[
i
/
2
]
+
=
digit
;
}
}
uint32_t
fullLength
=
0
;
using
Part
=
std
:
:
tuple
<
uint32_t
sk_sp
<
SkData
>
>
;
std
:
:
vector
<
Part
>
parts
;
for
(
const
auto
&
params
:
decoderApp1Params
)
{
if
(
params
-
>
size
(
)
<
=
kHeaderSize
)
{
continue
;
}
if
(
memcmp
(
params
-
>
bytes
(
)
kXMPExtendedSig
kSigSize
)
!
=
0
)
{
continue
;
}
const
uint8_t
*
partGuidAscii
=
params
-
>
bytes
(
)
+
kSigSize
;
if
(
memcmp
(
guidAscii
partGuidAscii
kGuidAsciiSize
)
!
=
0
)
{
SkCodecPrintf
(
"
Ignoring
unexpected
GUID
.
\
n
"
)
;
continue
;
}
uint32_t
partFullLength
=
0
;
uint32_t
partOffset
=
0
;
const
uint8_t
*
partFullLengthBytes
=
params
-
>
bytes
(
)
+
kSigSize
+
kGuidAsciiSize
;
const
uint8_t
*
partOffsetBytes
=
params
-
>
bytes
(
)
+
kSigSize
+
kGuidAsciiSize
+
kFullLengthSize
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
{
partFullLength
*
=
256
;
partOffset
*
=
256
;
partFullLength
+
=
partFullLengthBytes
[
i
]
;
partOffset
+
=
partOffsetBytes
[
i
]
;
}
if
(
parts
.
empty
(
)
)
{
fullLength
=
partFullLength
;
}
if
(
partFullLength
!
=
fullLength
)
{
SkCodecPrintf
(
"
Multiple
parts
had
different
total
lengths
.
\
n
"
)
;
return
nullptr
;
}
auto
partData
=
SkData
:
:
MakeWithoutCopy
(
params
-
>
bytes
(
)
+
kHeaderSize
params
-
>
size
(
)
-
kHeaderSize
)
;
parts
.
push_back
(
{
partOffset
partData
}
)
;
}
if
(
parts
.
empty
(
)
|
|
fullLength
=
=
0
)
{
return
nullptr
;
}
std
:
:
sort
(
parts
.
begin
(
)
parts
.
end
(
)
[
]
(
const
Part
&
a
const
Part
&
b
)
{
return
std
:
:
get
<
0
>
(
a
)
<
std
:
:
get
<
0
>
(
b
)
;
}
)
;
auto
xmpExtendedData
=
SkData
:
:
MakeUninitialized
(
fullLength
)
;
uint8_t
*
xmpExtendedBase
=
reinterpret_cast
<
uint8_t
*
>
(
xmpExtendedData
-
>
writable_data
(
)
)
;
uint8_t
*
xmpExtendedCurrent
=
xmpExtendedBase
;
SkMD5
md5
;
for
(
const
auto
&
part
:
parts
)
{
uint32_t
currentOffset
=
static_cast
<
uint32_t
>
(
xmpExtendedCurrent
-
xmpExtendedBase
)
;
uint32_t
partOffset
=
std
:
:
get
<
0
>
(
part
)
;
const
sk_sp
<
SkData
>
&
partData
=
std
:
:
get
<
1
>
(
part
)
;
if
(
partOffset
!
=
currentOffset
)
{
SkCodecPrintf
(
"
XMP
extension
parts
not
contiguous
\
n
"
)
;
return
nullptr
;
}
if
(
partData
-
>
size
(
)
>
fullLength
-
currentOffset
)
{
SkCodecPrintf
(
"
XMP
extension
parts
overflow
\
n
"
)
;
return
nullptr
;
}
memcpy
(
xmpExtendedCurrent
partData
-
>
data
(
)
partData
-
>
size
(
)
)
;
xmpExtendedCurrent
+
=
partData
-
>
size
(
)
;
}
if
(
static_cast
<
uint32_t
>
(
xmpExtendedCurrent
-
xmpExtendedBase
)
!
=
fullLength
)
{
SkCodecPrintf
(
"
XMP
extension
did
not
match
full
length
.
\
n
"
)
;
return
nullptr
;
}
md5
.
write
(
xmpExtendedData
-
>
data
(
)
xmpExtendedData
-
>
size
(
)
)
;
if
(
md5
.
finish
(
)
!
=
guidAsDigest
)
{
SkCodecPrintf
(
"
XMP
extension
did
not
hash
to
GUID
.
\
n
"
)
;
return
nullptr
;
}
return
xmpExtendedData
;
}
const
char
*
kXmlnsPrefix
=
"
xmlns
:
"
;
const
size_t
kXmlnsPrefixLength
=
6
;
static
const
char
*
get_namespace_prefix
(
const
char
*
name
)
{
if
(
strlen
(
name
)
<
=
kXmlnsPrefixLength
)
{
return
nullptr
;
}
return
name
+
kXmlnsPrefixLength
;
}
static
const
char
*
get_unique_child_text
(
const
SkDOM
&
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
childName
)
{
if
(
dom
.
countChildren
(
node
childName
.
c_str
(
)
)
!
=
1
)
{
return
nullptr
;
}
const
auto
*
child
=
dom
.
getFirstChild
(
node
childName
.
c_str
(
)
)
;
if
(
!
child
)
{
return
nullptr
;
}
if
(
dom
.
countChildren
(
child
)
!
=
1
)
{
return
nullptr
;
}
const
auto
*
grandChild
=
dom
.
getFirstChild
(
child
)
;
if
(
dom
.
getType
(
grandChild
)
!
=
SkDOM
:
:
kText_Type
)
{
return
nullptr
;
}
return
dom
.
getName
(
grandChild
)
;
}
static
const
SkDOM
:
:
Node
*
get_typed_child
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
type
)
{
const
auto
name
=
prefix
+
std
:
:
string
(
"
:
"
)
+
type
;
const
SkDOM
:
:
Node
*
child
=
dom
-
>
getFirstChild
(
node
name
.
c_str
(
)
)
;
if
(
child
)
{
return
child
;
}
const
SkDOM
:
:
Node
*
typeChild
=
dom
-
>
getFirstChild
(
node
"
rdf
:
type
"
)
;
if
(
!
typeChild
)
{
return
nullptr
;
}
const
char
*
typeChildResource
=
dom
-
>
findAttr
(
typeChild
"
rdf
:
resource
"
)
;
if
(
!
typeChildResource
|
|
typeChildResource
!
=
type
)
{
return
nullptr
;
}
const
SkDOM
:
:
Node
*
valueChild
=
dom
-
>
getFirstChild
(
node
"
rdf
:
value
"
)
;
if
(
!
valueChild
)
{
return
nullptr
;
}
const
char
*
valueChildParseType
=
dom
-
>
findAttr
(
valueChild
"
rdf
:
parseType
"
)
;
if
(
!
valueChildParseType
|
|
strcmp
(
valueChildParseType
"
Resource
"
)
!
=
0
)
{
return
nullptr
;
}
return
valueChild
;
}
static
const
char
*
get_attr
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
)
{
const
auto
name
=
prefix
+
"
:
"
+
key
;
const
char
*
attr
=
dom
-
>
findAttr
(
node
name
.
c_str
(
)
)
;
if
(
attr
)
{
return
attr
;
}
return
get_unique_child_text
(
*
dom
node
name
)
;
}
static
bool
get_attr_int32
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
int32_t
*
value
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
if
(
!
SkParse
:
:
FindS32
(
attr
value
)
)
{
return
false
;
}
return
true
;
}
static
bool
get_attr_float
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
float
*
outValue
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
SkScalar
value
=
0
.
f
;
if
(
SkParse
:
:
FindScalar
(
attr
&
value
)
)
{
*
outValue
=
value
;
return
true
;
}
return
false
;
}
static
bool
get_attr_float3
(
const
SkDOM
*
dom
const
SkDOM
:
:
Node
*
node
const
std
:
:
string
&
prefix
const
std
:
:
string
&
key
SkColor4f
*
outValue
)
{
const
char
*
attr
=
get_attr
(
dom
node
prefix
key
)
;
if
(
!
attr
)
{
return
false
;
}
SkScalar
values
[
3
]
=
{
0
.
f
0
.
f
0
.
f
}
;
if
(
SkParse
:
:
FindScalars
(
attr
values
3
)
)
{
*
outValue
=
{
values
[
0
]
values
[
1
]
values
[
2
]
1
.
f
}
;
return
true
;
}
if
(
SkParse
:
:
FindScalars
(
attr
values
1
)
)
{
*
outValue
=
{
values
[
0
]
values
[
0
]
values
[
0
]
1
.
f
}
;
return
true
;
}
return
false
;
}
static
void
find_uri_namespaces
(
const
SkDOM
&
dom
const
SkDOM
:
:
Node
*
node
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
)
{
for
(
const
auto
*
attr
=
dom
.
getFirstAttr
(
node
)
;
attr
;
attr
=
dom
.
getNextAttr
(
node
attr
)
)
{
const
char
*
attrName
=
dom
.
getAttrName
(
node
attr
)
;
const
char
*
attrValue
=
dom
.
getAttrValue
(
node
attr
)
;
if
(
!
attrName
|
|
!
attrValue
)
{
continue
;
}
if
(
strlen
(
attrName
)
<
=
kXmlnsPrefixLength
)
{
continue
;
}
if
(
memcmp
(
attrName
kXmlnsPrefix
kXmlnsPrefixLength
)
!
=
0
)
{
continue
;
}
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
strcmp
(
attrValue
uris
[
i
]
)
!
=
0
)
{
continue
;
}
outNamespaces
[
i
]
=
attrName
;
}
}
}
static
const
SkDOM
:
:
Node
*
find_uri_namespaces
(
const
SkDOM
&
dom
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
)
{
const
SkDOM
:
:
Node
*
root
=
dom
.
getRootNode
(
)
;
if
(
!
root
)
{
return
nullptr
;
}
const
char
*
rootName
=
dom
.
getName
(
root
)
;
if
(
!
rootName
|
|
strcmp
(
rootName
"
x
:
xmpmeta
"
)
!
=
0
)
{
return
nullptr
;
}
const
char
*
kRdf
=
"
rdf
:
RDF
"
;
for
(
const
auto
*
rdf
=
dom
.
getFirstChild
(
root
kRdf
)
;
rdf
;
rdf
=
dom
.
getNextSibling
(
rdf
kRdf
)
)
{
std
:
:
vector
<
const
char
*
>
rdfNamespaces
(
count
nullptr
)
;
find_uri_namespaces
(
dom
rdf
count
uris
rdfNamespaces
.
data
(
)
)
;
const
char
*
kDesc
=
"
rdf
:
Description
"
;
for
(
const
auto
*
desc
=
dom
.
getFirstChild
(
rdf
kDesc
)
;
desc
;
desc
=
dom
.
getNextSibling
(
desc
kDesc
)
)
{
std
:
:
vector
<
const
char
*
>
descNamespaces
=
rdfNamespaces
;
find_uri_namespaces
(
dom
desc
count
uris
descNamespaces
.
data
(
)
)
;
bool
foundAllUris
=
true
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
!
descNamespaces
[
i
]
)
{
foundAllUris
=
false
;
break
;
}
}
if
(
foundAllUris
)
{
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
outNamespaces
[
i
]
=
descNamespaces
[
i
]
;
}
return
desc
;
}
}
}
return
nullptr
;
}
std
:
:
unique_ptr
<
SkJpegXmp
>
SkJpegXmp
:
:
Make
(
const
std
:
:
vector
<
sk_sp
<
SkData
>
>
&
decoderApp1Params
)
{
auto
xmpStandard
=
read_xmp_standard
(
decoderApp1Params
)
;
if
(
!
xmpStandard
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkJpegXmp
>
xmp
(
new
SkJpegXmp
)
;
auto
xmpStandardStream
=
SkMemoryStream
:
:
Make
(
xmpStandard
)
;
if
(
!
xmp
-
>
fStandardDOM
.
build
(
*
xmpStandardStream
)
)
{
SkCodecPrintf
(
"
Failed
to
parse
XMP
standard
metadata
.
\
n
"
)
;
return
nullptr
;
}
const
char
*
namespaces
[
1
]
=
{
nullptr
}
;
const
char
*
uris
[
1
]
=
{
"
http
:
/
/
ns
.
adobe
.
com
/
xmp
/
note
/
"
}
;
const
auto
*
extendedNode
=
find_uri_namespaces
(
xmp
-
>
fStandardDOM
1
uris
namespaces
)
;
if
(
!
extendedNode
)
{
return
xmp
;
}
const
auto
xmpNotePrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
extendedGuid
=
get_attr
(
&
xmp
-
>
fStandardDOM
extendedNode
xmpNotePrefix
"
HasExtendedXMP
"
)
;
if
(
!
extendedGuid
)
{
return
xmp
;
}
auto
xmpExtended
=
read_xmp_extended
(
decoderApp1Params
extendedGuid
)
;
if
(
!
xmpExtended
)
{
SkCodecPrintf
(
"
Extended
XMP
was
indicated
but
failed
to
read
or
validate
.
\
n
"
)
;
return
xmp
;
}
auto
xmpExtendedStream
=
SkMemoryStream
:
:
Make
(
xmpExtended
)
;
if
(
xmp
-
>
fExtendedDOM
.
build
(
*
xmpExtendedStream
)
)
{
SkCodecPrintf
(
"
Failed
to
parse
extended
XMP
metadata
.
\
n
"
)
;
return
xmp
;
}
return
xmp
;
}
bool
SkJpegXmp
:
:
findUriNamespaces
(
size_t
count
const
char
*
uris
[
]
const
char
*
outNamespaces
[
]
const
SkDOM
*
*
outDom
const
SkDOM
:
:
Node
*
*
outNode
)
const
{
*
outNode
=
find_uri_namespaces
(
fStandardDOM
count
uris
outNamespaces
)
;
if
(
*
outNode
)
{
*
outDom
=
&
fStandardDOM
;
return
true
;
}
*
outNode
=
find_uri_namespaces
(
fExtendedDOM
count
uris
outNamespaces
)
;
if
(
*
outNode
)
{
*
outDom
=
&
fExtendedDOM
;
return
true
;
}
*
outDom
=
nullptr
;
return
false
;
}
bool
SkJpegXmp
:
:
getContainerGainmapLocation
(
size_t
*
outOffset
size_t
*
outSize
)
const
{
const
char
*
namespaces
[
2
]
=
{
nullptr
nullptr
}
;
const
char
*
uris
[
2
]
=
{
"
http
:
/
/
ns
.
google
.
com
/
photos
/
1
.
0
/
container
/
"
"
http
:
/
/
ns
.
google
.
com
/
photos
/
1
.
0
/
container
/
item
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
2
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
containerPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
itemPrefix
=
get_namespace_prefix
(
namespaces
[
1
]
)
;
const
auto
*
directory
=
get_typed_child
(
dom
node
containerPrefix
"
Directory
"
)
;
if
(
!
directory
)
{
SkCodecPrintf
(
"
Missing
Container
Directory
"
)
;
return
false
;
}
const
auto
*
seq
=
dom
-
>
getFirstChild
(
directory
"
rdf
:
Seq
"
)
;
if
(
!
seq
)
{
SkCodecPrintf
(
"
Missing
rdf
:
Seq
"
)
;
return
false
;
}
bool
isFirstItem
=
true
;
size_t
offset
=
0
;
for
(
const
auto
*
li
=
dom
-
>
getFirstChild
(
seq
"
rdf
:
li
"
)
;
li
;
li
=
dom
-
>
getNextSibling
(
li
"
rdf
:
li
"
)
)
{
const
auto
*
item
=
get_typed_child
(
dom
li
containerPrefix
"
Item
"
)
;
if
(
!
item
)
{
SkCodecPrintf
(
"
List
item
does
not
have
container
Item
.
\
n
"
)
;
return
false
;
}
const
char
*
itemSemantic
=
get_attr
(
dom
item
itemPrefix
"
Semantic
"
)
;
if
(
!
itemSemantic
)
{
SkCodecPrintf
(
"
Item
is
missing
Semantic
.
\
n
"
)
;
return
false
;
}
const
char
*
itemMime
=
get_attr
(
dom
item
itemPrefix
"
Mime
"
)
;
if
(
!
itemMime
)
{
SkCodecPrintf
(
"
Item
is
missing
Mime
.
\
n
"
)
;
return
false
;
}
if
(
isFirstItem
)
{
isFirstItem
=
false
;
if
(
strcmp
(
itemSemantic
"
Primary
"
)
!
=
0
)
{
SkCodecPrintf
(
"
First
item
is
not
Primary
.
\
n
"
)
;
return
false
;
}
if
(
strcmp
(
itemMime
"
image
/
jpeg
"
)
!
=
0
)
{
SkCodecPrintf
(
"
Primary
does
not
report
that
it
is
image
/
jpeg
.
\
n
"
)
;
return
false
;
}
int32_t
padding
=
0
;
if
(
get_attr_int32
(
dom
item
itemPrefix
"
Padding
"
&
padding
)
)
{
if
(
padding
<
0
)
{
SkCodecPrintf
(
"
Item
padding
must
be
non
-
negative
.
"
)
;
return
false
;
}
offset
+
=
padding
;
}
}
else
{
int32_t
length
=
0
;
if
(
!
get_attr_int32
(
dom
item
itemPrefix
"
Length
"
&
length
)
)
{
SkCodecPrintf
(
"
Item
length
is
absent
.
"
)
;
return
false
;
}
if
(
length
<
0
)
{
SkCodecPrintf
(
"
Item
length
must
be
non
-
negative
.
"
)
;
return
false
;
}
if
(
strcmp
(
itemSemantic
"
RecoveryMap
"
)
!
=
0
)
{
offset
+
=
length
;
continue
;
}
if
(
strcmp
(
itemMime
"
image
/
jpeg
"
)
!
=
0
)
{
SkCodecPrintf
(
"
RecoveryMap
does
not
report
that
it
is
image
/
jpeg
.
\
n
"
)
;
return
false
;
}
*
outOffset
=
offset
;
*
outSize
=
length
;
return
true
;
}
}
return
false
;
}
bool
SkJpegXmp
:
:
getGainmapInfoHDRGainMap
(
SkGainmapInfo
*
info
)
const
{
const
char
*
namespaces
[
2
]
=
{
nullptr
nullptr
}
;
const
char
*
uris
[
2
]
=
{
"
http
:
/
/
ns
.
apple
.
com
/
pixeldatainfo
/
1
.
0
/
"
"
http
:
/
/
ns
.
apple
.
com
/
HDRGainMap
/
1
.
0
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
2
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
adpiPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
const
char
*
hdrGainMapPrefix
=
get_namespace_prefix
(
namespaces
[
1
]
)
;
const
char
*
auxiliaryImageType
=
get_attr
(
dom
node
adpiPrefix
"
AuxiliaryImageType
"
)
;
if
(
!
auxiliaryImageType
)
{
SkCodecPrintf
(
"
Did
not
find
AuxiliaryImageType
.
\
n
"
)
;
return
false
;
}
if
(
strcmp
(
auxiliaryImageType
"
urn
:
com
:
apple
:
photo
:
2020
:
aux
:
hdrgainmap
"
)
!
=
0
)
{
SkCodecPrintf
(
"
AuxiliaryImageType
was
not
HDR
gain
map
.
\
n
"
)
;
return
false
;
}
int32_t
version
=
0
;
if
(
!
get_attr_int32
(
dom
node
hdrGainMapPrefix
"
HDRGainMapVersion
"
&
version
)
)
{
SkCodecPrintf
(
"
Did
not
find
HDRGainMapVersion
.
\
n
"
)
;
return
false
;
}
if
(
version
!
=
65536
)
{
SkCodecPrintf
(
"
HDRGainMapVersion
was
not
65536
.
\
n
"
)
;
return
false
;
}
const
float
kRatioMax
=
sk_float_exp
(
1
.
f
)
;
info
-
>
fGainmapRatioMin
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
info
-
>
fGainmapRatioMax
=
{
kRatioMax
kRatioMax
kRatioMax
1
.
f
}
;
info
-
>
fGainmapGamma
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
info
-
>
fEpsilonSdr
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
info
-
>
fEpsilonHdr
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
info
-
>
fDisplayRatioSdr
=
1
.
f
;
info
-
>
fDisplayRatioHdr
=
kRatioMax
;
info
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kSDR
;
info
-
>
fType
=
SkGainmapInfo
:
:
Type
:
:
kMultiPicture
;
return
true
;
}
bool
SkJpegXmp
:
:
getGainmapInfoHDRGM
(
SkGainmapInfo
*
outGainmapInfo
)
const
{
const
char
*
namespaces
[
1
]
=
{
nullptr
}
;
const
char
*
uris
[
1
]
=
{
"
http
:
/
/
ns
.
adobe
.
com
/
hdr
-
gain
-
map
/
1
.
0
/
"
}
;
const
SkDOM
*
dom
=
nullptr
;
const
SkDOM
:
:
Node
*
node
=
nullptr
;
if
(
!
findUriNamespaces
(
1
uris
namespaces
&
dom
&
node
)
)
{
return
false
;
}
const
char
*
hdrgmPrefix
=
get_namespace_prefix
(
namespaces
[
0
]
)
;
SkColor4f
gainMapMin
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
SkColor4f
gainMapMax
=
{
2
.
f
2
.
f
2
.
f
1
.
f
}
;
SkColor4f
gamma
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
SkColor4f
offsetSdr
=
{
1
.
f
/
64
.
f
1
.
f
/
64
.
f
1
.
f
/
64
.
f
0
.
f
}
;
SkColor4f
offsetHdr
=
{
1
.
f
/
64
.
f
1
.
f
/
64
.
f
1
.
f
/
64
.
f
0
.
f
}
;
SkScalar
hdrCapacityMin
=
1
.
f
;
SkScalar
hdrCapacityMax
=
2
.
f
;
const
char
*
baseRendition
=
get_attr
(
dom
node
hdrgmPrefix
"
BaseRendition
"
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
GainMapMin
"
&
gainMapMin
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
GainMapMax
"
&
gainMapMax
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
Gamma
"
&
gamma
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
OffsetSDR
"
&
offsetSdr
)
;
get_attr_float3
(
dom
node
hdrgmPrefix
"
OffsetHDR
"
&
offsetHdr
)
;
get_attr_float
(
dom
node
hdrgmPrefix
"
HDRCapacityMin
"
&
hdrCapacityMin
)
;
get_attr_float
(
dom
node
hdrgmPrefix
"
HDRCapacityMax
"
&
hdrCapacityMax
)
;
const
float
kLog2
=
sk_float_log
(
2
.
f
)
;
outGainmapInfo
-
>
fGainmapRatioMin
=
{
sk_float_exp
(
gainMapMin
.
fR
*
kLog2
)
sk_float_exp
(
gainMapMin
.
fG
*
kLog2
)
sk_float_exp
(
gainMapMin
.
fB
*
kLog2
)
1
.
f
}
;
outGainmapInfo
-
>
fGainmapRatioMax
=
{
sk_float_exp
(
gainMapMax
.
fR
*
kLog2
)
sk_float_exp
(
gainMapMax
.
fG
*
kLog2
)
sk_float_exp
(
gainMapMax
.
fB
*
kLog2
)
1
.
f
}
;
outGainmapInfo
-
>
fGainmapGamma
=
gamma
;
outGainmapInfo
-
>
fEpsilonSdr
=
offsetSdr
;
outGainmapInfo
-
>
fEpsilonHdr
=
offsetHdr
;
outGainmapInfo
-
>
fDisplayRatioSdr
=
sk_float_exp
(
hdrCapacityMin
*
kLog2
)
;
outGainmapInfo
-
>
fDisplayRatioHdr
=
sk_float_exp
(
hdrCapacityMax
*
kLog2
)
;
if
(
baseRendition
&
&
!
strcmp
(
baseRendition
"
HDR
"
)
)
{
outGainmapInfo
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kHDR
;
}
else
{
outGainmapInfo
-
>
fBaseImageType
=
SkGainmapInfo
:
:
BaseImageType
:
:
kSDR
;
}
outGainmapInfo
-
>
fType
=
SkGainmapInfo
:
:
Type
:
:
kHDRGM
;
return
true
;
}
