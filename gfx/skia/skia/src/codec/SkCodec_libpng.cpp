#
include
"
SkCodec_libpng
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkBitmap
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkSize
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkSwizzler
.
h
"
#
ifndef
png_jmpbuf
#
define
png_jmpbuf
(
png_ptr
)
(
(
png_ptr
)
-
>
jmpbuf
)
#
endif
#
ifndef
png_infopp_NULL
#
define
png_infopp_NULL
nullptr
#
endif
#
ifndef
png_bytepp_NULL
#
define
png_bytepp_NULL
nullptr
#
endif
#
ifndef
int_p_NULL
#
define
int_p_NULL
nullptr
#
endif
#
ifndef
png_flush_ptr_NULL
#
define
png_flush_ptr_NULL
nullptr
#
endif
static
void
sk_error_fn
(
png_structp
png_ptr
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
-
png
error
%
s
\
n
"
msg
)
;
longjmp
(
png_jmpbuf
(
png_ptr
)
1
)
;
}
void
sk_warning_fn
(
png_structp
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
png
warning
%
s
\
n
"
msg
)
;
}
static
void
sk_read_fn
(
png_structp
png_ptr
png_bytep
data
png_size_t
length
)
{
SkStream
*
stream
=
static_cast
<
SkStream
*
>
(
png_get_io_ptr
(
png_ptr
)
)
;
const
size_t
bytes
=
stream
-
>
read
(
data
length
)
;
if
(
bytes
!
=
length
)
{
png_error
(
png_ptr
"
Read
Error
!
"
)
;
}
}
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
static
int
sk_read_user_chunk
(
png_structp
png_ptr
png_unknown_chunkp
chunk
)
{
SkPngChunkReader
*
chunkReader
=
(
SkPngChunkReader
*
)
png_get_user_chunk_ptr
(
png_ptr
)
;
return
chunkReader
-
>
readChunk
(
(
const
char
*
)
chunk
-
>
name
chunk
-
>
data
chunk
-
>
size
)
?
1
:
-
1
;
}
#
endif
class
AutoCleanPng
:
public
SkNoncopyable
{
public
:
AutoCleanPng
(
png_structp
png_ptr
)
:
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
nullptr
)
{
}
~
AutoCleanPng
(
)
{
if
(
fPng_ptr
)
{
png_infopp
info_pp
=
fInfo_ptr
?
&
fInfo_ptr
:
nullptr
;
png_destroy_read_struct
(
&
fPng_ptr
info_pp
png_infopp_NULL
)
;
}
}
void
setInfoPtr
(
png_infop
info_ptr
)
{
SkASSERT
(
nullptr
=
=
fInfo_ptr
)
;
fInfo_ptr
=
info_ptr
;
}
void
detach
(
)
{
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
private
:
png_structp
fPng_ptr
;
png_infop
fInfo_ptr
;
}
;
#
define
AutoCleanPng
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
AutoCleanPng
)
static
bool
has_transparency_in_tRNS
(
png_structp
png_ptr
png_infop
info_ptr
)
{
if
(
!
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
return
false
;
}
png_bytep
trans
;
int
num_trans
;
png_get_tRNS
(
png_ptr
info_ptr
&
trans
&
num_trans
nullptr
)
;
return
num_trans
>
0
;
}
typedef
uint32_t
(
*
PackColorProc
)
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
;
bool
SkPngCodec
:
:
decodePalette
(
bool
premultiply
int
*
ctableCount
)
{
int
numPalette
;
png_colorp
palette
;
png_bytep
trans
;
if
(
!
png_get_PLTE
(
fPng_ptr
fInfo_ptr
&
palette
&
numPalette
)
)
{
return
false
;
}
SkPMColor
colorStorage
[
256
]
;
SkPMColor
*
colorPtr
=
colorStorage
;
int
numTrans
;
if
(
png_get_valid
(
fPng_ptr
fInfo_ptr
PNG_INFO_tRNS
)
)
{
png_get_tRNS
(
fPng_ptr
fInfo_ptr
&
trans
&
numTrans
nullptr
)
;
}
else
{
numTrans
=
0
;
}
if
(
numTrans
>
numPalette
)
{
numTrans
=
numPalette
;
}
int
index
=
0
;
int
transLessThanFF
=
0
;
PackColorProc
proc
;
if
(
premultiply
)
{
proc
=
&
SkPreMultiplyARGB
;
}
else
{
proc
=
&
SkPackARGB32NoCheck
;
}
for
(
;
index
<
numTrans
;
index
+
+
)
{
transLessThanFF
|
=
(
int
)
*
trans
-
0xFF
;
*
colorPtr
+
+
=
proc
(
*
trans
+
+
palette
-
>
red
palette
-
>
green
palette
-
>
blue
)
;
palette
+
+
;
}
if
(
transLessThanFF
>
=
0
)
{
fAlphaState
=
kOpaque_AlphaState
;
}
for
(
;
index
<
numPalette
;
index
+
+
)
{
*
colorPtr
+
+
=
SkPackARGB32
(
0xFF
palette
-
>
red
palette
-
>
green
palette
-
>
blue
)
;
palette
+
+
;
}
int
colorCount
=
SkTMax
(
numPalette
1
<
<
SkTMin
(
fBitDepth
8
)
)
;
SkPMColor
lastColor
=
index
>
0
?
colorPtr
[
-
1
]
:
SkPackARGB32
(
0xFF
0
0
0
)
;
for
(
;
index
<
colorCount
;
index
+
+
)
{
*
colorPtr
+
+
=
lastColor
;
}
if
(
ctableCount
!
=
nullptr
)
{
*
ctableCount
=
colorCount
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorStorage
colorCount
)
)
;
return
true
;
}
#
define
PNG_BYTES_TO_CHECK
4
bool
SkPngCodec
:
:
IsPng
(
SkStream
*
stream
)
{
char
buf
[
PNG_BYTES_TO_CHECK
]
;
if
(
stream
-
>
read
(
buf
PNG_BYTES_TO_CHECK
)
!
=
PNG_BYTES_TO_CHECK
)
{
return
false
;
}
if
(
png_sig_cmp
(
(
png_bytep
)
buf
(
png_size_t
)
0
PNG_BYTES_TO_CHECK
)
)
{
return
false
;
}
return
true
;
}
static
bool
read_header
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
*
png_ptrp
png_infop
*
info_ptrp
SkImageInfo
*
imageInfo
int
*
bitDepthPtr
int
*
numberPassesPtr
)
{
png_structp
png_ptr
=
png_create_read_struct
(
PNG_LIBPNG_VER_STRING
nullptr
sk_error_fn
sk_warning_fn
)
;
if
(
!
png_ptr
)
{
return
false
;
}
AutoCleanPng
autoClean
(
png_ptr
)
;
png_infop
info_ptr
=
png_create_info_struct
(
png_ptr
)
;
if
(
info_ptr
=
=
nullptr
)
{
return
false
;
}
autoClean
.
setInfoPtr
(
info_ptr
)
;
if
(
setjmp
(
png_jmpbuf
(
png_ptr
)
)
)
{
return
false
;
}
png_set_read_fn
(
png_ptr
static_cast
<
void
*
>
(
stream
)
sk_read_fn
)
;
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if
(
chunkReader
)
{
png_set_keep_unknown_chunks
(
png_ptr
PNG_HANDLE_CHUNK_ALWAYS
(
png_byte
*
)
"
"
0
)
;
png_set_read_user_chunk_fn
(
png_ptr
(
png_voidp
)
chunkReader
sk_read_user_chunk
)
;
}
#
endif
png_read_info
(
png_ptr
info_ptr
)
;
png_uint_32
origWidth
origHeight
;
int
bitDepth
colorType
;
png_get_IHDR
(
png_ptr
info_ptr
&
origWidth
&
origHeight
&
bitDepth
&
colorType
int_p_NULL
int_p_NULL
int_p_NULL
)
;
if
(
bitDepthPtr
)
{
*
bitDepthPtr
=
bitDepth
;
}
{
int64_t
size
=
sk_64_mul
(
origWidth
origHeight
)
;
if
(
size
<
0
|
|
size
>
(
0x7FFFFFFF
>
>
2
)
)
{
return
false
;
}
}
if
(
bitDepth
=
=
16
)
{
png_set_strip_16
(
png_ptr
)
;
}
#
ifdef
PNG_READ_PACK_SUPPORTED
if
(
bitDepth
<
8
)
{
png_set_packing
(
png_ptr
)
;
}
#
endif
if
(
colorType
=
=
PNG_COLOR_TYPE_GRAY
&
&
bitDepth
<
8
)
{
png_set_expand_gray_1_2_4_to_8
(
png_ptr
)
;
}
SkColorType
skColorType
=
kUnknown_SkColorType
;
SkAlphaType
skAlphaType
=
kUnknown_SkAlphaType
;
switch
(
colorType
)
{
case
PNG_COLOR_TYPE_PALETTE
:
skColorType
=
kIndex_8_SkColorType
;
skAlphaType
=
has_transparency_in_tRNS
(
png_ptr
info_ptr
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
;
break
;
case
PNG_COLOR_TYPE_RGB
:
if
(
has_transparency_in_tRNS
(
png_ptr
info_ptr
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
skAlphaType
=
kUnpremul_SkAlphaType
;
}
else
{
png_set_filler
(
png_ptr
0xff
PNG_FILLER_AFTER
)
;
skAlphaType
=
kOpaque_SkAlphaType
;
}
skColorType
=
kN32_SkColorType
;
break
;
case
PNG_COLOR_TYPE_GRAY
:
if
(
has_transparency_in_tRNS
(
png_ptr
info_ptr
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
png_set_gray_to_rgb
(
png_ptr
)
;
skColorType
=
kN32_SkColorType
;
skAlphaType
=
kUnpremul_SkAlphaType
;
}
else
{
skColorType
=
kGray_8_SkColorType
;
skAlphaType
=
kOpaque_SkAlphaType
;
}
break
;
case
PNG_COLOR_TYPE_GRAY_ALPHA
:
png_set_gray_to_rgb
(
png_ptr
)
;
skColorType
=
kN32_SkColorType
;
skAlphaType
=
kUnpremul_SkAlphaType
;
break
;
case
PNG_COLOR_TYPE_RGBA
:
skColorType
=
kN32_SkColorType
;
skAlphaType
=
kUnpremul_SkAlphaType
;
break
;
default
:
SkASSERT
(
false
)
;
}
int
numberPasses
=
png_set_interlace_handling
(
png_ptr
)
;
if
(
numberPassesPtr
)
{
*
numberPassesPtr
=
numberPasses
;
}
if
(
imageInfo
)
{
*
imageInfo
=
SkImageInfo
:
:
Make
(
origWidth
origHeight
skColorType
skAlphaType
)
;
}
autoClean
.
detach
(
)
;
if
(
png_ptrp
)
{
*
png_ptrp
=
png_ptr
;
}
if
(
info_ptrp
)
{
*
info_ptrp
=
info_ptr
;
}
return
true
;
}
SkPngCodec
:
:
SkPngCodec
(
const
SkImageInfo
&
info
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
int
numberPasses
)
:
INHERITED
(
info
stream
)
fPngChunkReader
(
SkSafeRef
(
chunkReader
)
)
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
info_ptr
)
fSrcConfig
(
SkSwizzler
:
:
kUnknown
)
fNumberPasses
(
numberPasses
)
fBitDepth
(
bitDepth
)
{
if
(
info
.
alphaType
(
)
=
=
kOpaque_SkAlphaType
)
{
fAlphaState
=
kOpaque_AlphaState
;
}
else
{
fAlphaState
=
kUnknown_AlphaState
;
}
}
SkPngCodec
:
:
~
SkPngCodec
(
)
{
this
-
>
destroyReadStruct
(
)
;
}
void
SkPngCodec
:
:
destroyReadStruct
(
)
{
if
(
fPng_ptr
)
{
SkASSERT
(
fInfo_ptr
)
;
png_destroy_read_struct
(
&
fPng_ptr
&
fInfo_ptr
png_infopp_NULL
)
;
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
}
SkCodec
:
:
Result
SkPngCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
requestedInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
setjmp
(
png_jmpbuf
(
fPng_ptr
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
kInvalidInput
;
}
png_read_update_info
(
fPng_ptr
fInfo_ptr
)
;
const
SkColorType
srcColorType
=
this
-
>
getInfo
(
)
.
colorType
(
)
;
switch
(
srcColorType
)
{
case
kIndex_8_SkColorType
:
fSrcConfig
=
SkSwizzler
:
:
kIndex
;
if
(
!
this
-
>
decodePalette
(
kPremul_SkAlphaType
=
=
requestedInfo
.
alphaType
(
)
ctableCount
)
)
{
return
kInvalidInput
;
}
break
;
case
kGray_8_SkColorType
:
fSrcConfig
=
SkSwizzler
:
:
kGray
;
break
;
case
kN32_SkColorType
:
if
(
this
-
>
getInfo
(
)
.
alphaType
(
)
=
=
kOpaque_SkAlphaType
)
{
fSrcConfig
=
SkSwizzler
:
:
kRGBX
;
}
else
{
fSrcConfig
=
SkSwizzler
:
:
kRGBA
;
}
break
;
default
:
SkASSERT
(
false
)
;
}
copy_color_table
(
requestedInfo
fColorTable
ctable
ctableCount
)
;
const
SkPMColor
*
colors
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
fSrcConfig
colors
requestedInfo
options
)
)
;
if
(
!
fSwizzler
)
{
return
kUnimplemented
;
}
return
kSuccess
;
}
bool
SkPngCodec
:
:
onRewind
(
)
{
this
-
>
destroyReadStruct
(
)
;
png_structp
png_ptr
;
png_infop
info_ptr
;
if
(
!
read_header
(
this
-
>
stream
(
)
fPngChunkReader
.
get
(
)
&
png_ptr
&
info_ptr
nullptr
nullptr
nullptr
)
)
{
return
false
;
}
fPng_ptr
=
png_ptr
;
fInfo_ptr
=
info_ptr
;
return
true
;
}
SkCodec
:
:
Result
SkPngCodec
:
:
onGetPixels
(
const
SkImageInfo
&
requestedInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
int
*
rowsDecoded
)
{
if
(
!
conversion_possible
(
requestedInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
requestedInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
int
row
=
0
;
SkAutoMalloc
storage
;
if
(
setjmp
(
png_jmpbuf
(
fPng_ptr
)
)
)
{
if
(
fNumberPasses
>
1
)
{
return
kInvalidInput
;
}
*
rowsDecoded
=
row
;
return
kIncompleteInput
;
}
bool
hasAlpha
=
false
;
void
*
dstRow
=
dst
;
if
(
fNumberPasses
>
1
)
{
const
int
width
=
requestedInfo
.
width
(
)
;
const
int
height
=
requestedInfo
.
height
(
)
;
const
int
bpp
=
SkSwizzler
:
:
BytesPerPixel
(
fSrcConfig
)
;
const
size_t
srcRowBytes
=
width
*
bpp
;
storage
.
reset
(
width
*
height
*
bpp
)
;
uint8_t
*
const
base
=
static_cast
<
uint8_t
*
>
(
storage
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
fNumberPasses
;
i
+
+
)
{
uint8_t
*
srcRow
=
base
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
uint8_t
*
bmRow
=
srcRow
;
png_read_rows
(
fPng_ptr
&
bmRow
png_bytepp_NULL
1
)
;
srcRow
+
=
srcRowBytes
;
}
}
uint8_t
*
srcRow
=
base
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
hasAlpha
|
=
!
SkSwizzler
:
:
IsOpaque
(
fSwizzler
-
>
swizzle
(
dstRow
srcRow
)
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
srcRow
+
=
srcRowBytes
;
}
}
else
{
storage
.
reset
(
requestedInfo
.
width
(
)
*
SkSwizzler
:
:
BytesPerPixel
(
fSrcConfig
)
)
;
uint8_t
*
srcRow
=
static_cast
<
uint8_t
*
>
(
storage
.
get
(
)
)
;
for
(
;
row
<
requestedInfo
.
height
(
)
;
row
+
+
)
{
png_read_rows
(
fPng_ptr
&
srcRow
png_bytepp_NULL
1
)
;
hasAlpha
|
=
!
SkSwizzler
:
:
IsOpaque
(
fSwizzler
-
>
swizzle
(
dstRow
srcRow
)
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
}
}
if
(
hasAlpha
)
{
fAlphaState
=
kHasAlpha_AlphaState
;
}
else
{
fAlphaState
=
kOpaque_AlphaState
;
}
if
(
setjmp
(
png_jmpbuf
(
fPng_ptr
)
)
)
{
return
kSuccess
;
}
png_read_end
(
fPng_ptr
fInfo_ptr
)
;
return
kSuccess
;
}
uint32_t
SkPngCodec
:
:
onGetFillValue
(
SkColorType
colorType
SkAlphaType
alphaType
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
if
(
colorPtr
)
{
return
get_color_table_fill_value
(
colorType
colorPtr
0
)
;
}
return
INHERITED
:
:
onGetFillValue
(
colorType
alphaType
)
;
}
bool
SkPngCodec
:
:
onReallyHasAlpha
(
)
const
{
switch
(
fAlphaState
)
{
case
kOpaque_AlphaState
:
return
false
;
case
kUnknown_AlphaState
:
return
this
-
>
alphaInScanlineDecode
(
)
=
=
kHasAlpha_AlphaState
;
case
kHasAlpha_AlphaState
:
switch
(
this
-
>
alphaInScanlineDecode
(
)
)
{
case
kUnknown_AlphaState
:
return
true
;
case
kOpaque_AlphaState
:
return
false
;
case
kHasAlpha_AlphaState
:
return
true
;
}
}
SkASSERT
(
false
)
;
return
true
;
}
class
SkPngScanlineDecoder
:
public
SkPngCodec
{
public
:
SkPngScanlineDecoder
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
)
:
INHERITED
(
srcInfo
stream
chunkReader
png_ptr
info_ptr
bitDepth
1
)
fAlphaState
(
kUnknown_AlphaState
)
fSrcRow
(
nullptr
)
{
}
Result
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
dstInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
fAlphaState
=
kUnknown_AlphaState
;
fStorage
.
reset
(
this
-
>
getInfo
(
)
.
width
(
)
*
SkSwizzler
:
:
BytesPerPixel
(
this
-
>
srcConfig
(
)
)
)
;
fSrcRow
=
static_cast
<
uint8_t
*
>
(
fStorage
.
get
(
)
)
;
return
kSuccess
;
}
int
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
override
{
int
row
=
0
;
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
row
;
}
void
*
dstRow
=
dst
;
bool
hasAlpha
=
false
;
for
(
;
row
<
count
;
row
+
+
)
{
png_read_rows
(
this
-
>
png_ptr
(
)
&
fSrcRow
png_bytepp_NULL
1
)
;
hasAlpha
|
=
!
SkSwizzler
:
:
IsOpaque
(
this
-
>
swizzler
(
)
-
>
swizzle
(
dstRow
fSrcRow
)
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
rowBytes
)
;
}
if
(
hasAlpha
)
{
fAlphaState
=
kHasAlpha_AlphaState
;
}
else
{
if
(
kUnknown_AlphaState
=
=
fAlphaState
)
{
fAlphaState
=
kOpaque_AlphaState
;
}
}
return
row
;
}
bool
onSkipScanlines
(
int
count
)
override
{
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
false
;
}
for
(
int
row
=
0
;
row
<
count
;
row
+
+
)
{
png_read_rows
(
this
-
>
png_ptr
(
)
&
fSrcRow
png_bytepp_NULL
1
)
;
}
return
true
;
}
AlphaState
alphaInScanlineDecode
(
)
const
override
{
return
fAlphaState
;
}
private
:
AlphaState
fAlphaState
;
SkAutoMalloc
fStorage
;
uint8_t
*
fSrcRow
;
typedef
SkPngCodec
INHERITED
;
}
;
class
SkPngInterlacedScanlineDecoder
:
public
SkPngCodec
{
public
:
SkPngInterlacedScanlineDecoder
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
int
numberPasses
)
:
INHERITED
(
srcInfo
stream
chunkReader
png_ptr
info_ptr
bitDepth
numberPasses
)
fAlphaState
(
kUnknown_AlphaState
)
fHeight
(
-
1
)
fCanSkipRewind
(
false
)
{
SkASSERT
(
numberPasses
!
=
1
)
;
}
Result
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
dstInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
fAlphaState
=
kUnknown_AlphaState
;
fHeight
=
dstInfo
.
height
(
)
;
fSrcRowBytes
=
this
-
>
getInfo
(
)
.
width
(
)
*
SkSwizzler
:
:
BytesPerPixel
(
this
-
>
srcConfig
(
)
)
;
fGarbageRow
.
reset
(
fSrcRowBytes
)
;
fGarbageRowPtr
=
static_cast
<
uint8_t
*
>
(
fGarbageRow
.
get
(
)
)
;
fCanSkipRewind
=
true
;
return
SkCodec
:
:
kSuccess
;
}
int
onGetScanlines
(
void
*
dst
int
count
size_t
dstRowBytes
)
override
{
if
(
fCanSkipRewind
)
{
fCanSkipRewind
=
false
;
}
else
{
const
int
currScanline
=
this
-
>
nextScanline
(
)
;
SkASSERT
(
currScanline
!
=
-
1
)
;
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
this
-
>
updateNextScanline
(
currScanline
)
;
}
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
0
;
}
SkAutoMalloc
storage
(
count
*
fSrcRowBytes
)
;
uint8_t
*
storagePtr
=
static_cast
<
uint8_t
*
>
(
storage
.
get
(
)
)
;
uint8_t
*
srcRow
;
const
int
startRow
=
this
-
>
nextScanline
(
)
;
for
(
int
i
=
0
;
i
<
this
-
>
numberPasses
(
)
;
i
+
+
)
{
for
(
int
y
=
0
;
y
<
startRow
;
y
+
+
)
{
png_read_rows
(
this
-
>
png_ptr
(
)
&
fGarbageRowPtr
png_bytepp_NULL
1
)
;
}
srcRow
=
storagePtr
;
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
png_read_rows
(
this
-
>
png_ptr
(
)
&
srcRow
png_bytepp_NULL
1
)
;
srcRow
+
=
fSrcRowBytes
;
}
for
(
int
y
=
0
;
y
<
fHeight
-
startRow
-
count
;
y
+
+
)
{
png_read_rows
(
this
-
>
png_ptr
(
)
&
fGarbageRowPtr
png_bytepp_NULL
1
)
;
}
}
srcRow
=
storagePtr
;
void
*
dstRow
=
dst
;
bool
hasAlpha
=
false
;
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
hasAlpha
|
=
!
SkSwizzler
:
:
IsOpaque
(
this
-
>
swizzler
(
)
-
>
swizzle
(
dstRow
srcRow
)
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
srcRow
+
=
fSrcRowBytes
;
}
if
(
hasAlpha
)
{
fAlphaState
=
kHasAlpha_AlphaState
;
}
else
{
if
(
kUnknown_AlphaState
=
=
fAlphaState
)
{
fAlphaState
=
kOpaque_AlphaState
;
}
}
return
count
;
}
bool
onSkipScanlines
(
int
count
)
override
{
return
true
;
}
AlphaState
alphaInScanlineDecode
(
)
const
override
{
return
fAlphaState
;
}
SkScanlineOrder
onGetScanlineOrder
(
)
const
override
{
return
kNone_SkScanlineOrder
;
}
private
:
AlphaState
fAlphaState
;
int
fHeight
;
size_t
fSrcRowBytes
;
SkAutoMalloc
fGarbageRow
;
uint8_t
*
fGarbageRowPtr
;
bool
fCanSkipRewind
;
typedef
SkPngCodec
INHERITED
;
}
;
SkCodec
*
SkPngCodec
:
:
NewFromStream
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
png_structp
png_ptr
;
png_infop
info_ptr
;
SkImageInfo
imageInfo
;
int
bitDepth
;
int
numberPasses
;
if
(
!
read_header
(
stream
chunkReader
&
png_ptr
&
info_ptr
&
imageInfo
&
bitDepth
&
numberPasses
)
)
{
return
nullptr
;
}
if
(
1
=
=
numberPasses
)
{
return
new
SkPngScanlineDecoder
(
imageInfo
streamDeleter
.
detach
(
)
chunkReader
png_ptr
info_ptr
bitDepth
)
;
}
return
new
SkPngInterlacedScanlineDecoder
(
imageInfo
streamDeleter
.
detach
(
)
chunkReader
png_ptr
info_ptr
bitDepth
numberPasses
)
;
}
