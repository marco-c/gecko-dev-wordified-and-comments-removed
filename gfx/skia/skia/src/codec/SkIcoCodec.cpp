#
include
"
SkBmpCodec
.
h
"
#
include
"
SkCodec_libpng
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkIcoCodec
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTSort
.
h
"
static
bool
ico_conversion_possible
(
const
SkImageInfo
&
dstInfo
)
{
if
(
kN32_SkColorType
!
=
dstInfo
.
colorType
(
)
)
{
return
false
;
}
return
kPremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
|
|
kUnpremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
;
}
static
SkImageInfo
fix_embedded_alpha
(
const
SkImageInfo
&
dstInfo
SkAlphaType
embeddedAlpha
)
{
switch
(
embeddedAlpha
)
{
case
kPremul_SkAlphaType
:
case
kUnpremul_SkAlphaType
:
embeddedAlpha
=
dstInfo
.
alphaType
(
)
;
break
;
case
kOpaque_SkAlphaType
:
break
;
default
:
SkASSERT
(
false
)
;
break
;
}
return
dstInfo
.
makeAlphaType
(
embeddedAlpha
)
;
}
bool
SkIcoCodec
:
:
IsIco
(
const
void
*
buffer
size_t
bytesRead
)
{
const
char
icoSig
[
]
=
{
'
\
x00
'
'
\
x00
'
'
\
x01
'
'
\
x00
'
}
;
const
char
curSig
[
]
=
{
'
\
x00
'
'
\
x00
'
'
\
x02
'
'
\
x00
'
}
;
return
bytesRead
>
=
sizeof
(
icoSig
)
&
&
(
!
memcmp
(
buffer
icoSig
sizeof
(
icoSig
)
)
|
|
!
memcmp
(
buffer
curSig
sizeof
(
curSig
)
)
)
;
}
SkCodec
*
SkIcoCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
SkAutoTDelete
<
SkStream
>
inputStream
(
stream
)
;
static
const
uint32_t
kIcoDirectoryBytes
=
6
;
static
const
uint32_t
kIcoDirEntryBytes
=
16
;
SkAutoTDeleteArray
<
uint8_t
>
dirBuffer
(
new
uint8_t
[
kIcoDirectoryBytes
]
)
;
if
(
inputStream
.
get
(
)
-
>
read
(
dirBuffer
.
get
(
)
kIcoDirectoryBytes
)
!
=
kIcoDirectoryBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
ico
directory
header
.
\
n
"
)
;
return
nullptr
;
}
const
uint16_t
numImages
=
get_short
(
dirBuffer
.
get
(
)
4
)
;
if
(
0
=
=
numImages
)
{
SkCodecPrintf
(
"
Error
:
No
images
embedded
in
ico
.
\
n
"
)
;
return
nullptr
;
}
SkAutoTDeleteArray
<
uint8_t
>
entryBuffer
(
new
uint8_t
[
numImages
*
kIcoDirEntryBytes
]
)
;
if
(
inputStream
.
get
(
)
-
>
read
(
entryBuffer
.
get
(
)
numImages
*
kIcoDirEntryBytes
)
!
=
numImages
*
kIcoDirEntryBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
ico
directory
entries
.
\
n
"
)
;
return
nullptr
;
}
struct
Entry
{
uint32_t
offset
;
uint32_t
size
;
}
;
SkAutoTDeleteArray
<
Entry
>
directoryEntries
(
new
Entry
[
numImages
]
)
;
for
(
uint32_t
i
=
0
;
i
<
numImages
;
i
+
+
)
{
uint32_t
size
=
get_int
(
entryBuffer
.
get
(
)
8
+
i
*
kIcoDirEntryBytes
)
;
uint32_t
offset
=
get_int
(
entryBuffer
.
get
(
)
12
+
i
*
kIcoDirEntryBytes
)
;
directoryEntries
.
get
(
)
[
i
]
.
offset
=
offset
;
directoryEntries
.
get
(
)
[
i
]
.
size
=
size
;
}
struct
EntryLessThan
{
bool
operator
(
)
(
Entry
a
Entry
b
)
const
{
return
a
.
offset
<
b
.
offset
;
}
}
;
EntryLessThan
lessThan
;
SkTQSort
(
directoryEntries
.
get
(
)
directoryEntries
.
get
(
)
+
numImages
-
1
lessThan
)
;
uint32_t
bytesRead
=
kIcoDirectoryBytes
+
numImages
*
kIcoDirEntryBytes
;
SkAutoTDelete
<
SkTArray
<
SkAutoTDelete
<
SkCodec
>
true
>
>
codecs
(
new
(
SkTArray
<
SkAutoTDelete
<
SkCodec
>
true
>
)
(
numImages
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numImages
;
i
+
+
)
{
uint32_t
offset
=
directoryEntries
.
get
(
)
[
i
]
.
offset
;
uint32_t
size
=
directoryEntries
.
get
(
)
[
i
]
.
size
;
if
(
offset
<
bytesRead
)
{
SkCodecPrintf
(
"
Warning
:
invalid
ico
offset
.
\
n
"
)
;
continue
;
}
if
(
inputStream
.
get
(
)
-
>
skip
(
offset
-
bytesRead
)
!
=
offset
-
bytesRead
)
{
SkCodecPrintf
(
"
Warning
:
could
not
skip
to
ico
offset
.
\
n
"
)
;
break
;
}
bytesRead
=
offset
;
SkAutoTUnref
<
SkData
>
data
(
SkData
:
:
NewFromStream
(
inputStream
.
get
(
)
size
)
)
;
if
(
nullptr
=
=
data
.
get
(
)
)
{
SkCodecPrintf
(
"
Warning
:
could
not
create
embedded
stream
.
\
n
"
)
;
break
;
}
SkAutoTDelete
<
SkMemoryStream
>
embeddedStream
(
new
SkMemoryStream
(
data
.
get
(
)
)
)
;
bytesRead
+
=
size
;
SkCodec
*
codec
=
nullptr
;
if
(
SkPngCodec
:
:
IsPng
(
(
const
char
*
)
data
-
>
bytes
(
)
data
-
>
size
(
)
)
)
{
codec
=
SkPngCodec
:
:
NewFromStream
(
embeddedStream
.
detach
(
)
)
;
}
else
{
codec
=
SkBmpCodec
:
:
NewFromIco
(
embeddedStream
.
detach
(
)
)
;
}
if
(
nullptr
!
=
codec
)
{
codecs
-
>
push_back
(
)
.
reset
(
codec
)
;
}
}
if
(
0
=
=
codecs
-
>
count
(
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
find
any
valid
embedded
ico
codecs
.
\
n
"
)
;
return
nullptr
;
}
uint32_t
maxSize
=
0
;
uint32_t
maxIndex
=
0
;
for
(
int32_t
i
=
0
;
i
<
codecs
-
>
count
(
)
;
i
+
+
)
{
SkImageInfo
info
=
codecs
-
>
operator
[
]
(
i
)
-
>
getInfo
(
)
;
uint32_t
size
=
info
.
width
(
)
*
info
.
height
(
)
;
if
(
size
>
maxSize
)
{
maxSize
=
size
;
maxIndex
=
i
;
}
}
SkImageInfo
info
=
codecs
-
>
operator
[
]
(
maxIndex
)
-
>
getInfo
(
)
;
info
=
info
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
return
new
SkIcoCodec
(
info
codecs
.
detach
(
)
)
;
}
SkIcoCodec
:
:
SkIcoCodec
(
const
SkImageInfo
&
info
SkTArray
<
SkAutoTDelete
<
SkCodec
>
true
>
*
codecs
)
:
INHERITED
(
info
nullptr
)
fEmbeddedCodecs
(
codecs
)
fCurrScanlineCodec
(
nullptr
)
{
}
SkISize
SkIcoCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
int
origWidth
=
this
-
>
getInfo
(
)
.
width
(
)
;
int
origHeight
=
this
-
>
getInfo
(
)
.
height
(
)
;
float
desiredSize
=
desiredScale
*
origWidth
*
origHeight
;
float
minError
=
(
(
float
)
(
origWidth
*
origHeight
)
)
-
desiredSize
+
1
.
0f
;
int32_t
minIndex
=
-
1
;
for
(
int32_t
i
=
0
;
i
<
fEmbeddedCodecs
-
>
count
(
)
;
i
+
+
)
{
int
width
=
fEmbeddedCodecs
-
>
operator
[
]
(
i
)
-
>
getInfo
(
)
.
width
(
)
;
int
height
=
fEmbeddedCodecs
-
>
operator
[
]
(
i
)
-
>
getInfo
(
)
.
height
(
)
;
float
error
=
SkTAbs
(
(
(
float
)
(
width
*
height
)
)
-
desiredSize
)
;
if
(
error
<
minError
)
{
minError
=
error
;
minIndex
=
i
;
}
}
SkASSERT
(
minIndex
>
=
0
)
;
return
fEmbeddedCodecs
-
>
operator
[
]
(
minIndex
)
-
>
getInfo
(
)
.
dimensions
(
)
;
}
int
SkIcoCodec
:
:
chooseCodec
(
const
SkISize
&
requestedSize
int
startIndex
)
{
SkASSERT
(
startIndex
>
=
0
)
;
for
(
int
i
=
startIndex
;
i
<
fEmbeddedCodecs
-
>
count
(
)
;
i
+
+
)
{
if
(
fEmbeddedCodecs
-
>
operator
[
]
(
i
)
-
>
getInfo
(
)
.
dimensions
(
)
=
=
requestedSize
)
{
return
i
;
}
}
return
-
1
;
}
bool
SkIcoCodec
:
:
onDimensionsSupported
(
const
SkISize
&
dim
)
{
return
this
-
>
chooseCodec
(
dim
0
)
>
=
0
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
colorTable
int
*
colorCount
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
if
(
!
ico_conversion_possible
(
dstInfo
)
)
{
return
kInvalidConversion
;
}
int
index
=
0
;
SkCodec
:
:
Result
result
=
kInvalidScale
;
while
(
true
)
{
index
=
this
-
>
chooseCodec
(
dstInfo
.
dimensions
(
)
index
)
;
if
(
index
<
0
)
{
break
;
}
SkCodec
*
embeddedCodec
=
fEmbeddedCodecs
-
>
operator
[
]
(
index
)
;
SkImageInfo
decodeInfo
=
fix_embedded_alpha
(
dstInfo
embeddedCodec
-
>
getInfo
(
)
.
alphaType
(
)
)
;
SkASSERT
(
decodeInfo
.
colorType
(
)
=
=
kN32_SkColorType
)
;
result
=
embeddedCodec
-
>
getPixels
(
decodeInfo
dst
dstRowBytes
&
opts
colorTable
colorCount
)
;
switch
(
result
)
{
case
kSuccess
:
case
kIncompleteInput
:
*
rowsDecoded
=
decodeInfo
.
height
(
)
;
return
result
;
default
:
break
;
}
index
+
+
;
}
SkCodecPrintf
(
"
Error
:
No
matching
candidate
image
in
ico
.
\
n
"
)
;
return
result
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
SkPMColor
colorTable
[
]
int
*
colorCount
)
{
if
(
!
ico_conversion_possible
(
dstInfo
)
)
{
return
kInvalidConversion
;
}
int
index
=
0
;
SkCodec
:
:
Result
result
=
kInvalidScale
;
while
(
true
)
{
index
=
this
-
>
chooseCodec
(
dstInfo
.
dimensions
(
)
index
)
;
if
(
index
<
0
)
{
break
;
}
SkCodec
*
embeddedCodec
=
fEmbeddedCodecs
-
>
operator
[
]
(
index
)
;
SkImageInfo
decodeInfo
=
fix_embedded_alpha
(
dstInfo
embeddedCodec
-
>
getInfo
(
)
.
alphaType
(
)
)
;
result
=
embeddedCodec
-
>
startScanlineDecode
(
decodeInfo
&
options
colorTable
colorCount
)
;
if
(
kSuccess
=
=
result
)
{
fCurrScanlineCodec
=
embeddedCodec
;
return
result
;
}
index
+
+
;
}
SkCodecPrintf
(
"
Error
:
No
matching
candidate
image
in
ico
.
\
n
"
)
;
return
result
;
}
int
SkIcoCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
{
SkASSERT
(
fCurrScanlineCodec
)
;
return
fCurrScanlineCodec
-
>
getScanlines
(
dst
count
rowBytes
)
;
}
bool
SkIcoCodec
:
:
onSkipScanlines
(
int
count
)
{
SkASSERT
(
fCurrScanlineCodec
)
;
return
fCurrScanlineCodec
-
>
skipScanlines
(
count
)
;
}
SkCodec
:
:
SkScanlineOrder
SkIcoCodec
:
:
onGetScanlineOrder
(
)
const
{
return
fCurrScanlineCodec
?
fCurrScanlineCodec
-
>
getScanlineOrder
(
)
:
INHERITED
:
:
onGetScanlineOrder
(
)
;
}
SkSampler
*
SkIcoCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
return
fCurrScanlineCodec
?
fCurrScanlineCodec
-
>
getSampler
(
createIfNecessary
)
:
nullptr
;
}
