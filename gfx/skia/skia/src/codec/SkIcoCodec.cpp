#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkTDArray
.
h
"
#
include
"
src
/
codec
/
SkBmpCodec
.
h
"
#
include
"
src
/
codec
/
SkCodecPriv
.
h
"
#
include
"
src
/
codec
/
SkIcoCodec
.
h
"
#
include
"
src
/
codec
/
SkPngCodec
.
h
"
#
include
"
src
/
core
/
SkTSort
.
h
"
bool
SkIcoCodec
:
:
IsIco
(
const
void
*
buffer
size_t
bytesRead
)
{
const
char
icoSig
[
]
=
{
'
\
x00
'
'
\
x00
'
'
\
x01
'
'
\
x00
'
}
;
const
char
curSig
[
]
=
{
'
\
x00
'
'
\
x00
'
'
\
x02
'
'
\
x00
'
}
;
return
bytesRead
>
=
sizeof
(
icoSig
)
&
&
(
!
memcmp
(
buffer
icoSig
sizeof
(
icoSig
)
)
|
|
!
memcmp
(
buffer
curSig
sizeof
(
curSig
)
)
)
;
}
std
:
:
unique_ptr
<
SkCodec
>
SkIcoCodec
:
:
MakeFromStream
(
std
:
:
unique_ptr
<
SkStream
>
stream
Result
*
result
)
{
constexpr
uint32_t
kIcoDirectoryBytes
=
6
;
constexpr
uint32_t
kIcoDirEntryBytes
=
16
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
dirBuffer
(
new
uint8_t
[
kIcoDirectoryBytes
]
)
;
if
(
stream
-
>
read
(
dirBuffer
.
get
(
)
kIcoDirectoryBytes
)
!
=
kIcoDirectoryBytes
)
{
SkCodecPrintf
(
"
Error
:
unable
to
read
ico
directory
header
.
\
n
"
)
;
*
result
=
kIncompleteInput
;
return
nullptr
;
}
const
uint16_t
numImages
=
get_short
(
dirBuffer
.
get
(
)
4
)
;
if
(
0
=
=
numImages
)
{
SkCodecPrintf
(
"
Error
:
No
images
embedded
in
ico
.
\
n
"
)
;
*
result
=
kInvalidInput
;
return
nullptr
;
}
struct
Entry
{
uint32_t
offset
;
uint32_t
size
;
}
;
SkAutoFree
dirEntryBuffer
(
sk_malloc_canfail
(
sizeof
(
Entry
)
*
numImages
)
)
;
if
(
!
dirEntryBuffer
)
{
SkCodecPrintf
(
"
Error
:
OOM
allocating
ICO
directory
for
%
i
images
.
\
n
"
numImages
)
;
*
result
=
kInternalError
;
return
nullptr
;
}
auto
*
directoryEntries
=
reinterpret_cast
<
Entry
*
>
(
dirEntryBuffer
.
get
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numImages
;
i
+
+
)
{
uint8_t
entryBuffer
[
kIcoDirEntryBytes
]
;
if
(
stream
-
>
read
(
entryBuffer
kIcoDirEntryBytes
)
!
=
kIcoDirEntryBytes
)
{
SkCodecPrintf
(
"
Error
:
Dir
entries
truncated
in
ico
.
\
n
"
)
;
*
result
=
kIncompleteInput
;
return
nullptr
;
}
uint32_t
size
=
get_int
(
entryBuffer
8
)
;
uint32_t
offset
=
get_int
(
entryBuffer
12
)
;
directoryEntries
[
i
]
.
offset
=
offset
;
directoryEntries
[
i
]
.
size
=
size
;
}
*
result
=
kInvalidInput
;
struct
EntryLessThan
{
bool
operator
(
)
(
Entry
a
Entry
b
)
const
{
return
a
.
offset
<
b
.
offset
;
}
}
;
EntryLessThan
lessThan
;
SkTQSort
(
directoryEntries
&
directoryEntries
[
numImages
-
1
]
lessThan
)
;
uint32_t
bytesRead
=
kIcoDirectoryBytes
+
numImages
*
kIcoDirEntryBytes
;
std
:
:
unique_ptr
<
SkTArray
<
std
:
:
unique_ptr
<
SkCodec
>
true
>
>
codecs
(
new
SkTArray
<
std
:
:
unique_ptr
<
SkCodec
>
true
>
(
numImages
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numImages
;
i
+
+
)
{
uint32_t
offset
=
directoryEntries
[
i
]
.
offset
;
uint32_t
size
=
directoryEntries
[
i
]
.
size
;
if
(
offset
<
bytesRead
)
{
SkCodecPrintf
(
"
Warning
:
invalid
ico
offset
.
\
n
"
)
;
continue
;
}
if
(
stream
-
>
skip
(
offset
-
bytesRead
)
!
=
offset
-
bytesRead
)
{
SkCodecPrintf
(
"
Warning
:
could
not
skip
to
ico
offset
.
\
n
"
)
;
break
;
}
bytesRead
=
offset
;
SkAutoFree
buffer
(
sk_malloc_canfail
(
size
)
)
;
if
(
!
buffer
)
{
SkCodecPrintf
(
"
Warning
:
OOM
trying
to
create
embedded
stream
.
\
n
"
)
;
break
;
}
if
(
stream
-
>
read
(
buffer
.
get
(
)
size
)
!
=
size
)
{
SkCodecPrintf
(
"
Warning
:
could
not
create
embedded
stream
.
\
n
"
)
;
*
result
=
kIncompleteInput
;
break
;
}
sk_sp
<
SkData
>
data
(
SkData
:
:
MakeFromMalloc
(
buffer
.
release
(
)
size
)
)
;
auto
embeddedStream
=
SkMemoryStream
:
:
Make
(
data
)
;
bytesRead
+
=
size
;
std
:
:
unique_ptr
<
SkCodec
>
codec
;
Result
dummyResult
;
if
(
SkPngCodec
:
:
IsPng
(
(
const
char
*
)
data
-
>
bytes
(
)
data
-
>
size
(
)
)
)
{
codec
=
SkPngCodec
:
:
MakeFromStream
(
std
:
:
move
(
embeddedStream
)
&
dummyResult
)
;
}
else
{
codec
=
SkBmpCodec
:
:
MakeFromIco
(
std
:
:
move
(
embeddedStream
)
&
dummyResult
)
;
}
if
(
nullptr
!
=
codec
)
{
codecs
-
>
push_back
(
)
.
reset
(
codec
.
release
(
)
)
;
}
}
if
(
0
=
=
codecs
-
>
count
(
)
)
{
SkCodecPrintf
(
"
Error
:
could
not
find
any
valid
embedded
ico
codecs
.
\
n
"
)
;
return
nullptr
;
}
size_t
maxSize
=
0
;
int
maxIndex
=
0
;
for
(
int
i
=
0
;
i
<
codecs
-
>
count
(
)
;
i
+
+
)
{
SkImageInfo
info
=
codecs
-
>
operator
[
]
(
i
)
-
>
getInfo
(
)
;
size_t
size
=
info
.
computeMinByteSize
(
)
;
if
(
size
>
maxSize
)
{
maxSize
=
size
;
maxIndex
=
i
;
}
}
auto
maxInfo
=
codecs
-
>
operator
[
]
(
maxIndex
)
-
>
getEncodedInfo
(
)
.
copy
(
)
;
*
result
=
kSuccess
;
return
std
:
:
unique_ptr
<
SkCodec
>
(
new
SkIcoCodec
(
std
:
:
move
(
maxInfo
)
codecs
.
release
(
)
)
)
;
}
SkIcoCodec
:
:
SkIcoCodec
(
SkEncodedInfo
&
&
info
SkTArray
<
std
:
:
unique_ptr
<
SkCodec
>
true
>
*
codecs
)
:
INHERITED
(
std
:
:
move
(
info
)
skcms_PixelFormat
(
)
nullptr
)
fEmbeddedCodecs
(
codecs
)
fCurrCodec
(
nullptr
)
{
}
SkISize
SkIcoCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
int
origWidth
=
this
-
>
dimensions
(
)
.
width
(
)
;
int
origHeight
=
this
-
>
dimensions
(
)
.
height
(
)
;
float
desiredSize
=
desiredScale
*
origWidth
*
origHeight
;
float
minError
=
(
(
float
)
(
origWidth
*
origHeight
)
)
-
desiredSize
+
1
.
0f
;
int32_t
minIndex
=
-
1
;
for
(
int32_t
i
=
0
;
i
<
fEmbeddedCodecs
-
>
count
(
)
;
i
+
+
)
{
auto
dimensions
=
fEmbeddedCodecs
-
>
operator
[
]
(
i
)
-
>
dimensions
(
)
;
int
width
=
dimensions
.
width
(
)
;
int
height
=
dimensions
.
height
(
)
;
float
error
=
SkTAbs
(
(
(
float
)
(
width
*
height
)
)
-
desiredSize
)
;
if
(
error
<
minError
)
{
minError
=
error
;
minIndex
=
i
;
}
}
SkASSERT
(
minIndex
>
=
0
)
;
return
fEmbeddedCodecs
-
>
operator
[
]
(
minIndex
)
-
>
dimensions
(
)
;
}
int
SkIcoCodec
:
:
chooseCodec
(
const
SkISize
&
requestedSize
int
startIndex
)
{
SkASSERT
(
startIndex
>
=
0
)
;
for
(
int
i
=
startIndex
;
i
<
fEmbeddedCodecs
-
>
count
(
)
;
i
+
+
)
{
if
(
fEmbeddedCodecs
-
>
operator
[
]
(
i
)
-
>
dimensions
(
)
=
=
requestedSize
)
{
return
i
;
}
}
return
-
1
;
}
bool
SkIcoCodec
:
:
onDimensionsSupported
(
const
SkISize
&
dim
)
{
return
this
-
>
chooseCodec
(
dim
0
)
>
=
0
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
int
*
rowsDecoded
)
{
if
(
opts
.
fSubset
)
{
return
kUnimplemented
;
}
int
index
=
0
;
SkCodec
:
:
Result
result
=
kInvalidScale
;
while
(
true
)
{
index
=
this
-
>
chooseCodec
(
dstInfo
.
dimensions
(
)
index
)
;
if
(
index
<
0
)
{
break
;
}
SkCodec
*
embeddedCodec
=
fEmbeddedCodecs
-
>
operator
[
]
(
index
)
.
get
(
)
;
result
=
embeddedCodec
-
>
getPixels
(
dstInfo
dst
dstRowBytes
&
opts
)
;
switch
(
result
)
{
case
kSuccess
:
case
kIncompleteInput
:
*
rowsDecoded
=
dstInfo
.
height
(
)
;
return
result
;
default
:
break
;
}
index
+
+
;
}
SkCodecPrintf
(
"
Error
:
No
matching
candidate
image
in
ico
.
\
n
"
)
;
return
result
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
options
)
{
int
index
=
0
;
SkCodec
:
:
Result
result
=
kInvalidScale
;
while
(
true
)
{
index
=
this
-
>
chooseCodec
(
dstInfo
.
dimensions
(
)
index
)
;
if
(
index
<
0
)
{
break
;
}
SkCodec
*
embeddedCodec
=
fEmbeddedCodecs
-
>
operator
[
]
(
index
)
.
get
(
)
;
result
=
embeddedCodec
-
>
startScanlineDecode
(
dstInfo
&
options
)
;
if
(
kSuccess
=
=
result
)
{
fCurrCodec
=
embeddedCodec
;
return
result
;
}
index
+
+
;
}
SkCodecPrintf
(
"
Error
:
No
matching
candidate
image
in
ico
.
\
n
"
)
;
return
result
;
}
int
SkIcoCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
{
SkASSERT
(
fCurrCodec
)
;
return
fCurrCodec
-
>
getScanlines
(
dst
count
rowBytes
)
;
}
bool
SkIcoCodec
:
:
onSkipScanlines
(
int
count
)
{
SkASSERT
(
fCurrCodec
)
;
return
fCurrCodec
-
>
skipScanlines
(
count
)
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
pixels
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
)
{
int
index
=
0
;
while
(
true
)
{
index
=
this
-
>
chooseCodec
(
dstInfo
.
dimensions
(
)
index
)
;
if
(
index
<
0
)
{
break
;
}
SkCodec
*
embeddedCodec
=
fEmbeddedCodecs
-
>
operator
[
]
(
index
)
.
get
(
)
;
switch
(
embeddedCodec
-
>
startIncrementalDecode
(
dstInfo
pixels
rowBytes
&
options
)
)
{
case
kSuccess
:
fCurrCodec
=
embeddedCodec
;
return
kSuccess
;
case
kUnimplemented
:
if
(
embeddedCodec
-
>
startScanlineDecode
(
dstInfo
)
=
=
kSuccess
)
{
return
kUnimplemented
;
}
break
;
default
:
break
;
}
index
+
+
;
}
SkCodecPrintf
(
"
Error
:
No
matching
candidate
image
in
ico
.
\
n
"
)
;
return
kInvalidScale
;
}
SkCodec
:
:
Result
SkIcoCodec
:
:
onIncrementalDecode
(
int
*
rowsDecoded
)
{
SkASSERT
(
fCurrCodec
)
;
return
fCurrCodec
-
>
incrementalDecode
(
rowsDecoded
)
;
}
SkCodec
:
:
SkScanlineOrder
SkIcoCodec
:
:
onGetScanlineOrder
(
)
const
{
if
(
fCurrCodec
)
{
return
fCurrCodec
-
>
getScanlineOrder
(
)
;
}
return
INHERITED
:
:
onGetScanlineOrder
(
)
;
}
SkSampler
*
SkIcoCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
fCurrCodec
)
{
return
fCurrCodec
-
>
getSampler
(
createIfNecessary
)
;
}
return
nullptr
;
}
