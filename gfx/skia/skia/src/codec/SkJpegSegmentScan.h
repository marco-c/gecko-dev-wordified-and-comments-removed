#
ifndef
SkJpegSegmentScan_codec_DEFINED
#
define
SkJpegSegmentScan_codec_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
src
/
codec
/
SkJpegConstants
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
vector
>
class
SkData
;
class
SkStream
;
struct
SkJpegSegment
{
size_t
offset
=
0
;
uint8_t
marker
=
0
;
uint16_t
parameterLength
=
0
;
}
;
class
SkJpegSegmentScanner
{
public
:
SkJpegSegmentScanner
(
uint8_t
stopMarker
=
kJpegMarkerEndOfImage
)
;
bool
isDone
(
)
const
{
return
fState
=
=
State
:
:
kDone
;
}
bool
hadError
(
)
const
{
return
fState
=
=
State
:
:
kError
;
}
void
onBytes
(
const
void
*
data
size_t
size
)
;
const
std
:
:
vector
<
SkJpegSegment
>
&
getSegments
(
)
const
;
static
sk_sp
<
SkData
>
GetParameters
(
const
SkData
*
scannedData
const
SkJpegSegment
&
segment
)
;
private
:
enum
class
State
{
kStartOfImageByte0
kStartOfImageByte1
kSecondMarkerByte0
kSecondMarkerByte1
kSegmentParamLengthByte0
kSegmentParamLengthByte1
kSegmentParam
kEntropyCodedData
kEntropyCodedDataSentinel
kPostEntropyCodedDataFill
kDone
kError
}
;
State
fState
=
State
:
:
kStartOfImageByte0
;
void
onByte
(
uint8_t
byte
)
;
void
onMarkerSecondByte
(
uint8_t
byte
)
;
void
saveCurrentSegment
(
uint16_t
length
)
;
static
bool
MarkerStandsAlone
(
uint8_t
marker
)
{
return
marker
=
=
0x01
|
|
(
marker
>
=
0xD0
&
&
marker
<
=
0xD9
)
;
}
const
uint8_t
fStopMarker
;
size_t
fOffset
=
0
;
uint8_t
fSegmentParamLengthByte0
=
0
;
size_t
fSegmentParamBytesRemaining
=
0
;
size_t
fCurrentSegmentOffset
=
0
;
uint8_t
fCurrentSegmentMarker
=
0
;
std
:
:
vector
<
SkJpegSegment
>
fSegments
;
}
;
#
endif
