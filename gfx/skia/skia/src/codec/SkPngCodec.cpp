#
include
"
SkBitmap
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPngCodec
.
h
"
#
include
"
SkSize
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkUtils
.
h
"
static
void
sk_error_fn
(
png_structp
png_ptr
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
-
png
error
%
s
\
n
"
msg
)
;
longjmp
(
png_jmpbuf
(
png_ptr
)
1
)
;
}
void
sk_warning_fn
(
png_structp
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
png
warning
%
s
\
n
"
msg
)
;
}
static
void
sk_read_fn
(
png_structp
png_ptr
png_bytep
data
png_size_t
length
)
{
SkStream
*
stream
=
static_cast
<
SkStream
*
>
(
png_get_io_ptr
(
png_ptr
)
)
;
const
size_t
bytes
=
stream
-
>
read
(
data
length
)
;
if
(
bytes
!
=
length
)
{
png_error
(
png_ptr
"
Read
Error
!
"
)
;
}
}
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
static
int
sk_read_user_chunk
(
png_structp
png_ptr
png_unknown_chunkp
chunk
)
{
SkPngChunkReader
*
chunkReader
=
(
SkPngChunkReader
*
)
png_get_user_chunk_ptr
(
png_ptr
)
;
return
chunkReader
-
>
readChunk
(
(
const
char
*
)
chunk
-
>
name
chunk
-
>
data
chunk
-
>
size
)
?
1
:
-
1
;
}
#
endif
class
AutoCleanPng
:
public
SkNoncopyable
{
public
:
AutoCleanPng
(
png_structp
png_ptr
)
:
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
nullptr
)
{
}
~
AutoCleanPng
(
)
{
if
(
fPng_ptr
)
{
png_infopp
info_pp
=
fInfo_ptr
?
&
fInfo_ptr
:
nullptr
;
png_destroy_read_struct
(
&
fPng_ptr
info_pp
nullptr
)
;
}
}
void
setInfoPtr
(
png_infop
info_ptr
)
{
SkASSERT
(
nullptr
=
=
fInfo_ptr
)
;
fInfo_ptr
=
info_ptr
;
}
void
release
(
)
{
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
private
:
png_structp
fPng_ptr
;
png_infop
fInfo_ptr
;
}
;
#
define
AutoCleanPng
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
AutoCleanPng
)
typedef
uint32_t
(
*
PackColorProc
)
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
;
bool
SkPngCodec
:
:
decodePalette
(
bool
premultiply
int
*
ctableCount
)
{
int
numColors
;
png_color
*
palette
;
if
(
!
png_get_PLTE
(
fPng_ptr
fInfo_ptr
&
palette
&
numColors
)
)
{
return
false
;
}
SkPMColor
colorPtr
[
256
]
;
png_bytep
alphas
;
int
numColorsWithAlpha
=
0
;
if
(
png_get_tRNS
(
fPng_ptr
fInfo_ptr
&
alphas
&
numColorsWithAlpha
nullptr
)
)
{
PackColorProc
proc
;
if
(
premultiply
)
{
proc
=
&
SkPremultiplyARGBInline
;
}
else
{
proc
=
&
SkPackARGB32NoCheck
;
}
for
(
int
i
=
0
;
i
<
numColorsWithAlpha
;
i
+
+
)
{
colorPtr
[
i
]
=
proc
(
alphas
[
i
]
palette
-
>
red
palette
-
>
green
palette
-
>
blue
)
;
palette
+
+
;
}
}
if
(
numColorsWithAlpha
<
numColors
)
{
static_assert
(
3
=
=
sizeof
(
png_color
)
"
png_color
struct
has
changed
.
Opts
are
broken
.
"
)
;
#
ifdef
SK_DEBUG
SkASSERT
(
&
palette
-
>
red
<
&
palette
-
>
green
)
;
SkASSERT
(
&
palette
-
>
green
<
&
palette
-
>
blue
)
;
#
endif
#
ifdef
SK_PMCOLOR_IS_RGBA
SkOpts
:
:
RGB_to_RGB1
(
colorPtr
+
numColorsWithAlpha
palette
numColors
-
numColorsWithAlpha
)
;
#
else
SkOpts
:
:
RGB_to_BGR1
(
colorPtr
+
numColorsWithAlpha
palette
numColors
-
numColorsWithAlpha
)
;
#
endif
}
const
int
maxColors
=
1
<
<
fBitDepth
;
if
(
numColors
<
maxColors
)
{
SkPMColor
lastColor
=
numColors
>
0
?
colorPtr
[
numColors
-
1
]
:
SK_ColorBLACK
;
sk_memset32
(
colorPtr
+
numColors
lastColor
maxColors
-
numColors
)
;
}
if
(
ctableCount
!
=
nullptr
)
{
*
ctableCount
=
maxColors
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorPtr
maxColors
)
)
;
return
true
;
}
bool
SkPngCodec
:
:
IsPng
(
const
char
*
buf
size_t
bytesRead
)
{
return
!
png_sig_cmp
(
(
png_bytep
)
buf
(
png_size_t
)
0
bytesRead
)
;
}
static
float
png_fixed_point_to_float
(
png_fixed_point
x
)
{
return
(
(
float
)
x
)
*
0
.
00001f
;
}
static
float
png_inverted_fixed_point_to_float
(
png_fixed_point
x
)
{
return
1
.
0f
/
png_fixed_point_to_float
(
x
)
;
}
sk_sp
<
SkColorSpace
>
read_color_space
(
png_structp
png_ptr
png_infop
info_ptr
)
{
#
if
(
PNG_LIBPNG_VER_MAJOR
>
1
)
|
|
(
PNG_LIBPNG_VER_MAJOR
=
=
1
&
&
PNG_LIBPNG_VER_MINOR
>
=
6
)
png_bytep
profile
;
png_uint_32
length
;
png_charp
name
;
int
compression
;
if
(
PNG_INFO_iCCP
=
=
png_get_iCCP
(
png_ptr
info_ptr
&
name
&
compression
&
profile
&
length
)
)
{
return
SkColorSpace
:
:
NewICC
(
profile
length
)
;
}
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_sRGB
)
)
{
return
SkColorSpace
:
:
NewNamed
(
SkColorSpace
:
:
kSRGB_Named
)
;
}
png_fixed_point
XYZ
[
9
]
;
SkFloat3x3
toXYZD50
;
png_fixed_point
gamma
;
SkFloat3
gammas
;
if
(
png_get_cHRM_XYZ_fixed
(
png_ptr
info_ptr
&
XYZ
[
0
]
&
XYZ
[
1
]
&
XYZ
[
2
]
&
XYZ
[
3
]
&
XYZ
[
4
]
&
XYZ
[
5
]
&
XYZ
[
6
]
&
XYZ
[
7
]
&
XYZ
[
8
]
)
)
{
for
(
int
i
=
0
;
i
<
9
;
i
+
+
)
{
toXYZD50
.
fMat
[
i
]
=
png_fixed_point_to_float
(
XYZ
[
i
]
)
;
}
if
(
PNG_INFO_gAMA
=
=
png_get_gAMA_fixed
(
png_ptr
info_ptr
&
gamma
)
)
{
gammas
.
fVec
[
0
]
=
gammas
.
fVec
[
1
]
=
gammas
.
fVec
[
2
]
=
png_inverted_fixed_point_to_float
(
gamma
)
;
}
else
{
gammas
.
fVec
[
0
]
=
gammas
.
fVec
[
1
]
=
gammas
.
fVec
[
2
]
=
1
.
0f
;
}
return
SkColorSpace
:
:
NewRGB
(
toXYZD50
gammas
)
;
}
if
(
PNG_INFO_gAMA
=
=
png_get_gAMA_fixed
(
png_ptr
info_ptr
&
gamma
)
)
{
memset
(
toXYZD50
.
fMat
0
9
*
sizeof
(
float
)
)
;
toXYZD50
.
fMat
[
0
]
=
toXYZD50
.
fMat
[
4
]
=
toXYZD50
.
fMat
[
8
]
=
1
.
0f
;
gammas
.
fVec
[
0
]
=
gammas
.
fVec
[
1
]
=
gammas
.
fVec
[
2
]
=
png_inverted_fixed_point_to_float
(
gamma
)
;
return
SkColorSpace
:
:
NewRGB
(
toXYZD50
gammas
)
;
}
#
endif
return
nullptr
;
}
static
bool
read_header
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
*
png_ptrp
png_infop
*
info_ptrp
SkImageInfo
*
imageInfo
int
*
bitDepthPtr
int
*
numberPassesPtr
)
{
png_structp
png_ptr
=
png_create_read_struct
(
PNG_LIBPNG_VER_STRING
nullptr
sk_error_fn
sk_warning_fn
)
;
if
(
!
png_ptr
)
{
return
false
;
}
AutoCleanPng
autoClean
(
png_ptr
)
;
png_infop
info_ptr
=
png_create_info_struct
(
png_ptr
)
;
if
(
info_ptr
=
=
nullptr
)
{
return
false
;
}
autoClean
.
setInfoPtr
(
info_ptr
)
;
if
(
setjmp
(
png_jmpbuf
(
png_ptr
)
)
)
{
return
false
;
}
png_set_read_fn
(
png_ptr
static_cast
<
void
*
>
(
stream
)
sk_read_fn
)
;
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if
(
chunkReader
)
{
png_set_keep_unknown_chunks
(
png_ptr
PNG_HANDLE_CHUNK_ALWAYS
(
png_byte
*
)
"
"
0
)
;
png_set_read_user_chunk_fn
(
png_ptr
(
png_voidp
)
chunkReader
sk_read_user_chunk
)
;
}
#
endif
png_read_info
(
png_ptr
info_ptr
)
;
png_uint_32
origWidth
origHeight
;
int
bitDepth
encodedColorType
;
png_get_IHDR
(
png_ptr
info_ptr
&
origWidth
&
origHeight
&
bitDepth
&
encodedColorType
nullptr
nullptr
nullptr
)
;
if
(
bitDepthPtr
)
{
*
bitDepthPtr
=
bitDepth
;
}
if
(
bitDepth
=
=
16
)
{
SkASSERT
(
PNG_COLOR_TYPE_PALETTE
!
=
encodedColorType
)
;
png_set_strip_16
(
png_ptr
)
;
}
SkColorType
colorType
=
kUnknown_SkColorType
;
SkAlphaType
alphaType
=
kUnknown_SkAlphaType
;
switch
(
encodedColorType
)
{
case
PNG_COLOR_TYPE_PALETTE
:
if
(
bitDepth
<
8
)
{
png_set_packing
(
png_ptr
)
;
}
colorType
=
kIndex_8_SkColorType
;
alphaType
=
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
;
break
;
case
PNG_COLOR_TYPE_RGB
:
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
alphaType
=
kUnpremul_SkAlphaType
;
}
else
{
alphaType
=
kOpaque_SkAlphaType
;
}
colorType
=
kN32_SkColorType
;
break
;
case
PNG_COLOR_TYPE_GRAY
:
if
(
bitDepth
<
8
)
{
png_set_expand_gray_1_2_4_to_8
(
png_ptr
)
;
}
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
colorType
=
kN32_SkColorType
;
alphaType
=
kUnpremul_SkAlphaType
;
}
else
{
colorType
=
kGray_8_SkColorType
;
alphaType
=
kOpaque_SkAlphaType
;
}
break
;
case
PNG_COLOR_TYPE_GRAY_ALPHA
:
colorType
=
kN32_SkColorType
;
alphaType
=
kUnpremul_SkAlphaType
;
break
;
case
PNG_COLOR_TYPE_RGBA
:
colorType
=
kN32_SkColorType
;
alphaType
=
kUnpremul_SkAlphaType
;
break
;
default
:
SkASSERT
(
false
)
;
}
int
numberPasses
=
png_set_interlace_handling
(
png_ptr
)
;
if
(
numberPassesPtr
)
{
*
numberPassesPtr
=
numberPasses
;
}
SkColorProfileType
profileType
=
kLinear_SkColorProfileType
;
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_sRGB
)
)
{
profileType
=
kSRGB_SkColorProfileType
;
}
if
(
imageInfo
)
{
*
imageInfo
=
SkImageInfo
:
:
Make
(
origWidth
origHeight
colorType
alphaType
profileType
)
;
}
autoClean
.
release
(
)
;
if
(
png_ptrp
)
{
*
png_ptrp
=
png_ptr
;
}
if
(
info_ptrp
)
{
*
info_ptrp
=
info_ptr
;
}
return
true
;
}
SkPngCodec
:
:
SkPngCodec
(
const
SkImageInfo
&
info
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
int
numberPasses
sk_sp
<
SkColorSpace
>
colorSpace
)
:
INHERITED
(
info
stream
colorSpace
)
fPngChunkReader
(
SkSafeRef
(
chunkReader
)
)
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
info_ptr
)
fSrcConfig
(
SkSwizzler
:
:
kUnknown
)
fNumberPasses
(
numberPasses
)
fBitDepth
(
bitDepth
)
{
}
SkPngCodec
:
:
~
SkPngCodec
(
)
{
this
-
>
destroyReadStruct
(
)
;
}
void
SkPngCodec
:
:
destroyReadStruct
(
)
{
if
(
fPng_ptr
)
{
SkASSERT
(
fInfo_ptr
)
;
png_destroy_read_struct
(
&
fPng_ptr
&
fInfo_ptr
nullptr
)
;
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
}
SkCodec
:
:
Result
SkPngCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
requestedInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
setjmp
(
png_jmpbuf
(
fPng_ptr
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
kInvalidInput
;
}
png_read_update_info
(
fPng_ptr
fInfo_ptr
)
;
const
SkColorType
suggestedColorType
=
this
-
>
getInfo
(
)
.
colorType
(
)
;
switch
(
suggestedColorType
)
{
case
kIndex_8_SkColorType
:
fSrcConfig
=
SkSwizzler
:
:
kIndex
;
if
(
!
this
-
>
decodePalette
(
kPremul_SkAlphaType
=
=
requestedInfo
.
alphaType
(
)
ctableCount
)
)
{
return
kInvalidInput
;
}
break
;
case
kGray_8_SkColorType
:
fSrcConfig
=
SkSwizzler
:
:
kGray
;
break
;
case
kN32_SkColorType
:
{
const
uint8_t
encodedColorType
=
png_get_color_type
(
fPng_ptr
fInfo_ptr
)
;
if
(
PNG_COLOR_TYPE_GRAY_ALPHA
=
=
encodedColorType
|
|
PNG_COLOR_TYPE_GRAY
=
=
encodedColorType
)
{
SkASSERT
(
encodedColorType
=
=
PNG_COLOR_TYPE_GRAY_ALPHA
|
|
png_get_valid
(
fPng_ptr
fInfo_ptr
PNG_INFO_tRNS
)
)
;
fSrcConfig
=
SkSwizzler
:
:
kGrayAlpha
;
}
else
{
if
(
this
-
>
getInfo
(
)
.
alphaType
(
)
=
=
kOpaque_SkAlphaType
)
{
fSrcConfig
=
SkSwizzler
:
:
kRGB
;
}
else
{
fSrcConfig
=
SkSwizzler
:
:
kRGBA
;
}
}
break
;
}
default
:
SkASSERT
(
false
)
;
}
copy_color_table
(
requestedInfo
fColorTable
ctable
ctableCount
)
;
const
SkPMColor
*
colors
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
fSrcConfig
colors
requestedInfo
options
)
)
;
SkASSERT
(
fSwizzler
)
;
return
kSuccess
;
}
bool
SkPngCodec
:
:
onRewind
(
)
{
this
-
>
destroyReadStruct
(
)
;
png_structp
png_ptr
;
png_infop
info_ptr
;
if
(
!
read_header
(
this
-
>
stream
(
)
fPngChunkReader
.
get
(
)
&
png_ptr
&
info_ptr
nullptr
nullptr
nullptr
)
)
{
return
false
;
}
fPng_ptr
=
png_ptr
;
fInfo_ptr
=
info_ptr
;
return
true
;
}
SkCodec
:
:
Result
SkPngCodec
:
:
onGetPixels
(
const
SkImageInfo
&
requestedInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
int
*
rowsDecoded
)
{
if
(
!
conversion_possible
(
requestedInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
requestedInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
const
int
width
=
requestedInfo
.
width
(
)
;
const
int
height
=
requestedInfo
.
height
(
)
;
const
int
bpp
=
SkSwizzler
:
:
BytesPerPixel
(
fSrcConfig
)
;
const
size_t
srcRowBytes
=
width
*
bpp
;
int
row
=
0
;
SkAutoTMalloc
<
uint8_t
>
storage
;
if
(
setjmp
(
png_jmpbuf
(
fPng_ptr
)
)
)
{
if
(
fNumberPasses
>
1
)
{
return
(
row
=
=
height
)
?
kSuccess
:
kInvalidInput
;
}
*
rowsDecoded
=
row
;
return
(
row
=
=
height
)
?
kSuccess
:
kIncompleteInput
;
}
void
*
dstRow
=
dst
;
if
(
fNumberPasses
>
1
)
{
storage
.
reset
(
height
*
srcRowBytes
)
;
uint8_t
*
const
base
=
storage
.
get
(
)
;
for
(
int
i
=
0
;
i
<
fNumberPasses
;
i
+
+
)
{
uint8_t
*
srcRow
=
base
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
png_read_row
(
fPng_ptr
srcRow
nullptr
)
;
srcRow
+
=
srcRowBytes
;
}
}
uint8_t
*
srcRow
=
base
;
for
(
;
row
<
height
;
row
+
+
)
{
fSwizzler
-
>
swizzle
(
dstRow
srcRow
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
srcRow
+
=
srcRowBytes
;
}
}
else
{
storage
.
reset
(
srcRowBytes
)
;
uint8_t
*
srcRow
=
storage
.
get
(
)
;
for
(
;
row
<
height
;
row
+
+
)
{
png_read_row
(
fPng_ptr
srcRow
nullptr
)
;
fSwizzler
-
>
swizzle
(
dstRow
srcRow
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
}
}
png_read_end
(
fPng_ptr
fInfo_ptr
)
;
return
kSuccess
;
}
uint32_t
SkPngCodec
:
:
onGetFillValue
(
SkColorType
colorType
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
if
(
colorPtr
)
{
return
get_color_table_fill_value
(
colorType
colorPtr
0
)
;
}
return
INHERITED
:
:
onGetFillValue
(
colorType
)
;
}
class
SkPngScanlineDecoder
:
public
SkPngCodec
{
public
:
SkPngScanlineDecoder
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
sk_sp
<
SkColorSpace
>
colorSpace
)
:
INHERITED
(
srcInfo
stream
chunkReader
png_ptr
info_ptr
bitDepth
1
colorSpace
)
fSrcRow
(
nullptr
)
{
}
Result
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
dstInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
fStorage
.
reset
(
this
-
>
getInfo
(
)
.
width
(
)
*
SkSwizzler
:
:
BytesPerPixel
(
this
-
>
srcConfig
(
)
)
)
;
fSrcRow
=
fStorage
.
get
(
)
;
return
kSuccess
;
}
int
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
override
{
int
row
=
0
;
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
row
;
}
void
*
dstRow
=
dst
;
for
(
;
row
<
count
;
row
+
+
)
{
png_read_row
(
this
-
>
png_ptr
(
)
fSrcRow
nullptr
)
;
this
-
>
swizzler
(
)
-
>
swizzle
(
dstRow
fSrcRow
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
rowBytes
)
;
}
return
row
;
}
bool
onSkipScanlines
(
int
count
)
override
{
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
false
;
}
for
(
int
row
=
0
;
row
<
count
;
row
+
+
)
{
png_read_row
(
this
-
>
png_ptr
(
)
fSrcRow
nullptr
)
;
}
return
true
;
}
private
:
SkAutoTMalloc
<
uint8_t
>
fStorage
;
uint8_t
*
fSrcRow
;
typedef
SkPngCodec
INHERITED
;
}
;
class
SkPngInterlacedScanlineDecoder
:
public
SkPngCodec
{
public
:
SkPngInterlacedScanlineDecoder
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
SkPngChunkReader
*
chunkReader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
int
numberPasses
sk_sp
<
SkColorSpace
>
colorSpace
)
:
INHERITED
(
srcInfo
stream
chunkReader
png_ptr
info_ptr
bitDepth
numberPasses
colorSpace
)
fHeight
(
-
1
)
fCanSkipRewind
(
false
)
{
SkASSERT
(
numberPasses
!
=
1
)
;
}
Result
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
const
Result
result
=
this
-
>
initializeSwizzler
(
dstInfo
options
ctable
ctableCount
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
fHeight
=
dstInfo
.
height
(
)
;
fSrcRowBytes
=
this
-
>
getInfo
(
)
.
width
(
)
*
SkSwizzler
:
:
BytesPerPixel
(
this
-
>
srcConfig
(
)
)
;
fGarbageRow
.
reset
(
fSrcRowBytes
)
;
fGarbageRowPtr
=
static_cast
<
uint8_t
*
>
(
fGarbageRow
.
get
(
)
)
;
fCanSkipRewind
=
true
;
return
SkCodec
:
:
kSuccess
;
}
int
onGetScanlines
(
void
*
dst
int
count
size_t
dstRowBytes
)
override
{
if
(
fCanSkipRewind
)
{
fCanSkipRewind
=
false
;
}
else
{
const
int
currScanline
=
this
-
>
nextScanline
(
)
;
SkASSERT
(
currScanline
!
=
-
1
)
;
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
this
-
>
updateCurrScanline
(
currScanline
)
;
}
if
(
setjmp
(
png_jmpbuf
(
this
-
>
png_ptr
(
)
)
)
)
{
SkCodecPrintf
(
"
setjmp
long
jump
!
\
n
"
)
;
return
0
;
}
SkAutoTMalloc
<
uint8_t
>
storage
(
count
*
fSrcRowBytes
)
;
uint8_t
*
storagePtr
=
storage
.
get
(
)
;
uint8_t
*
srcRow
;
const
int
startRow
=
this
-
>
nextScanline
(
)
;
for
(
int
i
=
0
;
i
<
this
-
>
numberPasses
(
)
;
i
+
+
)
{
for
(
int
y
=
0
;
y
<
startRow
;
y
+
+
)
{
png_read_row
(
this
-
>
png_ptr
(
)
fGarbageRowPtr
nullptr
)
;
}
srcRow
=
storagePtr
;
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
png_read_row
(
this
-
>
png_ptr
(
)
srcRow
nullptr
)
;
srcRow
+
=
fSrcRowBytes
;
}
for
(
int
y
=
0
;
y
<
fHeight
-
startRow
-
count
;
y
+
+
)
{
png_read_row
(
this
-
>
png_ptr
(
)
fGarbageRowPtr
nullptr
)
;
}
}
srcRow
=
storagePtr
;
void
*
dstRow
=
dst
;
for
(
int
y
=
0
;
y
<
count
;
y
+
+
)
{
this
-
>
swizzler
(
)
-
>
swizzle
(
dstRow
srcRow
)
;
dstRow
=
SkTAddOffset
<
void
>
(
dstRow
dstRowBytes
)
;
srcRow
+
=
fSrcRowBytes
;
}
return
count
;
}
bool
onSkipScanlines
(
int
count
)
override
{
return
true
;
}
SkScanlineOrder
onGetScanlineOrder
(
)
const
override
{
return
kNone_SkScanlineOrder
;
}
private
:
int
fHeight
;
size_t
fSrcRowBytes
;
SkAutoMalloc
fGarbageRow
;
uint8_t
*
fGarbageRowPtr
;
bool
fCanSkipRewind
;
typedef
SkPngCodec
INHERITED
;
}
;
SkCodec
*
SkPngCodec
:
:
NewFromStream
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
png_structp
png_ptr
;
png_infop
info_ptr
;
SkImageInfo
imageInfo
;
int
bitDepth
;
int
numberPasses
;
if
(
!
read_header
(
stream
chunkReader
&
png_ptr
&
info_ptr
&
imageInfo
&
bitDepth
&
numberPasses
)
)
{
return
nullptr
;
}
auto
colorSpace
=
read_color_space
(
png_ptr
info_ptr
)
;
if
(
1
=
=
numberPasses
)
{
return
new
SkPngScanlineDecoder
(
imageInfo
streamDeleter
.
release
(
)
chunkReader
png_ptr
info_ptr
bitDepth
colorSpace
)
;
}
return
new
SkPngInterlacedScanlineDecoder
(
imageInfo
streamDeleter
.
release
(
)
chunkReader
png_ptr
info_ptr
bitDepth
numberPasses
colorSpace
)
;
}
