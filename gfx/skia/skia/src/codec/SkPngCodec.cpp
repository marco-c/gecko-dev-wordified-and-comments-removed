#
include
"
SkBitmap
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkColorSpacePriv
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPngCodec
.
h
"
#
include
"
SkPoint3
.
h
"
#
include
"
SkSize
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
png
.
h
"
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
pragma
GCC
diagnostic
ignored
"
-
Wclobbered
"
#
endif
#
if
PNG_LIBPNG_VER_MAJOR
>
1
|
|
(
PNG_LIBPNG_VER_MAJOR
=
=
1
&
&
PNG_LIBPNG_VER_MINOR
>
=
5
)
#
undef
SK_GOOGLE3_PNG_HACK
#
endif
#
define
PNG_JMPBUF
(
x
)
png_jmpbuf
(
(
png_structp
)
x
)
constexpr
int
kSetJmpOkay
=
0
;
constexpr
int
kPngError
=
1
;
constexpr
int
kStopDecoding
=
2
;
static
void
sk_error_fn
(
png_structp
png_ptr
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
-
png
error
%
s
\
n
"
msg
)
;
longjmp
(
PNG_JMPBUF
(
png_ptr
)
kPngError
)
;
}
void
sk_warning_fn
(
png_structp
png_const_charp
msg
)
{
SkCodecPrintf
(
"
-
-
-
-
-
png
warning
%
s
\
n
"
msg
)
;
}
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
static
int
sk_read_user_chunk
(
png_structp
png_ptr
png_unknown_chunkp
chunk
)
{
SkPngChunkReader
*
chunkReader
=
(
SkPngChunkReader
*
)
png_get_user_chunk_ptr
(
png_ptr
)
;
return
chunkReader
-
>
readChunk
(
(
const
char
*
)
chunk
-
>
name
chunk
-
>
data
chunk
-
>
size
)
?
1
:
-
1
;
}
#
endif
class
AutoCleanPng
:
public
SkNoncopyable
{
public
:
AutoCleanPng
(
png_structp
png_ptr
SkStream
*
stream
SkPngChunkReader
*
reader
SkCodec
*
*
codecPtr
)
:
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
nullptr
)
fDecodedBounds
(
false
)
fReadHeader
(
false
)
fStream
(
stream
)
fChunkReader
(
reader
)
fOutCodec
(
codecPtr
)
{
}
~
AutoCleanPng
(
)
{
if
(
fPng_ptr
)
{
png_infopp
info_pp
=
fInfo_ptr
?
&
fInfo_ptr
:
nullptr
;
png_destroy_read_struct
(
&
fPng_ptr
info_pp
nullptr
)
;
}
}
void
setInfoPtr
(
png_infop
info_ptr
)
{
SkASSERT
(
nullptr
=
=
fInfo_ptr
)
;
fInfo_ptr
=
info_ptr
;
}
bool
decodeBounds
(
)
;
private
:
png_structp
fPng_ptr
;
png_infop
fInfo_ptr
;
bool
fDecodedBounds
;
bool
fReadHeader
;
SkStream
*
fStream
;
SkPngChunkReader
*
fChunkReader
;
SkCodec
*
*
fOutCodec
;
static
void
InfoCallback
(
png_structp
png_ptr
png_infop
)
{
static_cast
<
AutoCleanPng
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
-
>
infoCallback
(
)
;
}
void
infoCallback
(
)
;
#
ifdef
SK_GOOGLE3_PNG_HACK
public
:
#
endif
void
releasePngPtrs
(
)
{
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
}
;
#
define
AutoCleanPng
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
AutoCleanPng
)
bool
AutoCleanPng
:
:
decodeBounds
(
)
{
if
(
setjmp
(
PNG_JMPBUF
(
fPng_ptr
)
)
)
{
return
false
;
}
png_set_progressive_read_fn
(
fPng_ptr
this
InfoCallback
nullptr
nullptr
)
;
constexpr
size_t
kBufferSize
=
4096
;
char
buffer
[
kBufferSize
]
;
while
(
true
)
{
const
size_t
bytesRead
=
fStream
-
>
read
(
buffer
kBufferSize
)
;
if
(
!
bytesRead
)
{
break
;
}
png_process_data
(
fPng_ptr
fInfo_ptr
(
png_bytep
)
buffer
bytesRead
)
;
if
(
fReadHeader
)
{
break
;
}
}
png_set_progressive_read_fn
(
fPng_ptr
nullptr
nullptr
nullptr
nullptr
)
;
return
fDecodedBounds
;
}
void
SkPngCodec
:
:
processData
(
)
{
switch
(
setjmp
(
PNG_JMPBUF
(
fPng_ptr
)
)
)
{
case
kPngError
:
return
;
case
kStopDecoding
:
return
;
case
kSetJmpOkay
:
break
;
default
:
SkASSERT
(
false
)
;
}
constexpr
size_t
kBufferSize
=
4096
;
char
buffer
[
kBufferSize
]
;
while
(
true
)
{
const
size_t
bytesRead
=
this
-
>
stream
(
)
-
>
read
(
buffer
kBufferSize
)
;
png_process_data
(
fPng_ptr
fInfo_ptr
(
png_bytep
)
buffer
bytesRead
)
;
if
(
!
bytesRead
)
{
break
;
}
}
}
static
const
SkColorType
kXformSrcColorType
=
kRGBA_8888_SkColorType
;
bool
SkPngCodec
:
:
createColorTable
(
const
SkImageInfo
&
dstInfo
int
*
ctableCount
)
{
int
numColors
;
png_color
*
palette
;
if
(
!
png_get_PLTE
(
fPng_ptr
fInfo_ptr
&
palette
&
numColors
)
)
{
return
false
;
}
SkPMColor
colorTable
[
256
]
;
SkColorType
tableColorType
=
this
-
>
colorXform
(
)
?
kXformSrcColorType
:
dstInfo
.
colorType
(
)
;
png_bytep
alphas
;
int
numColorsWithAlpha
=
0
;
if
(
png_get_tRNS
(
fPng_ptr
fInfo_ptr
&
alphas
&
numColorsWithAlpha
nullptr
)
)
{
bool
premultiply
=
!
this
-
>
colorXform
(
)
&
&
needs_premul
(
dstInfo
this
-
>
getEncodedInfo
(
)
)
;
PackColorProc
proc
=
choose_pack_color_proc
(
premultiply
tableColorType
)
;
for
(
int
i
=
0
;
i
<
numColorsWithAlpha
;
i
+
+
)
{
colorTable
[
i
]
=
proc
(
alphas
[
i
]
palette
-
>
red
palette
-
>
green
palette
-
>
blue
)
;
palette
+
+
;
}
}
if
(
numColorsWithAlpha
<
numColors
)
{
static_assert
(
3
=
=
sizeof
(
png_color
)
"
png_color
struct
has
changed
.
Opts
are
broken
.
"
)
;
#
ifdef
SK_DEBUG
SkASSERT
(
&
palette
-
>
red
<
&
palette
-
>
green
)
;
SkASSERT
(
&
palette
-
>
green
<
&
palette
-
>
blue
)
;
#
endif
if
(
is_rgba
(
tableColorType
)
)
{
SkOpts
:
:
RGB_to_RGB1
(
colorTable
+
numColorsWithAlpha
palette
numColors
-
numColorsWithAlpha
)
;
}
else
{
SkOpts
:
:
RGB_to_BGR1
(
colorTable
+
numColorsWithAlpha
palette
numColors
-
numColorsWithAlpha
)
;
}
}
if
(
this
-
>
colorXform
(
)
&
&
!
apply_xform_on_decode
(
dstInfo
.
colorType
(
)
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
)
{
const
SkColorSpaceXform
:
:
ColorFormat
dstFormat
=
select_xform_format_ct
(
dstInfo
.
colorType
(
)
)
;
const
SkColorSpaceXform
:
:
ColorFormat
srcFormat
=
select_xform_format
(
kXformSrcColorType
)
;
const
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
dstFormat
colorTable
srcFormat
colorTable
numColors
xformAlphaType
)
)
;
}
const
int
maxColors
=
1
<
<
fBitDepth
;
if
(
numColors
<
maxColors
)
{
SkPMColor
lastColor
=
numColors
>
0
?
colorTable
[
numColors
-
1
]
:
SK_ColorBLACK
;
sk_memset32
(
colorTable
+
numColors
lastColor
maxColors
-
numColors
)
;
}
if
(
ctableCount
!
=
nullptr
)
{
*
ctableCount
=
maxColors
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorTable
maxColors
)
)
;
return
true
;
}
bool
SkPngCodec
:
:
IsPng
(
const
char
*
buf
size_t
bytesRead
)
{
return
!
png_sig_cmp
(
(
png_bytep
)
buf
(
png_size_t
)
0
bytesRead
)
;
}
#
if
(
PNG_LIBPNG_VER_MAJOR
>
1
)
|
|
(
PNG_LIBPNG_VER_MAJOR
=
=
1
&
&
PNG_LIBPNG_VER_MINOR
>
=
6
)
static
float
png_fixed_point_to_float
(
png_fixed_point
x
)
{
return
(
(
float
)
x
)
*
0
.
00001f
;
}
static
float
png_inverted_fixed_point_to_float
(
png_fixed_point
x
)
{
return
1
.
0f
/
png_fixed_point_to_float
(
x
)
;
}
#
endif
sk_sp
<
SkColorSpace
>
read_color_space
(
png_structp
png_ptr
png_infop
info_ptr
SkColorSpace_Base
:
:
ICCTypeFlag
iccType
)
{
#
if
(
PNG_LIBPNG_VER_MAJOR
>
1
)
|
|
(
PNG_LIBPNG_VER_MAJOR
=
=
1
&
&
PNG_LIBPNG_VER_MINOR
>
=
6
)
png_bytep
profile
;
png_uint_32
length
;
png_charp
name
;
int
compression
;
if
(
PNG_INFO_iCCP
=
=
png_get_iCCP
(
png_ptr
info_ptr
&
name
&
compression
&
profile
&
length
)
)
{
return
SkColorSpace_Base
:
:
MakeICC
(
profile
length
iccType
)
;
}
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_sRGB
)
)
{
return
SkColorSpace
:
:
MakeSRGB
(
)
;
}
png_fixed_point
chrm
[
8
]
;
png_fixed_point
gamma
;
if
(
png_get_cHRM_fixed
(
png_ptr
info_ptr
&
chrm
[
0
]
&
chrm
[
1
]
&
chrm
[
2
]
&
chrm
[
3
]
&
chrm
[
4
]
&
chrm
[
5
]
&
chrm
[
6
]
&
chrm
[
7
]
)
)
{
SkColorSpacePrimaries
primaries
;
primaries
.
fRX
=
png_fixed_point_to_float
(
chrm
[
2
]
)
;
primaries
.
fRY
=
png_fixed_point_to_float
(
chrm
[
3
]
)
;
primaries
.
fGX
=
png_fixed_point_to_float
(
chrm
[
4
]
)
;
primaries
.
fGY
=
png_fixed_point_to_float
(
chrm
[
5
]
)
;
primaries
.
fBX
=
png_fixed_point_to_float
(
chrm
[
6
]
)
;
primaries
.
fBY
=
png_fixed_point_to_float
(
chrm
[
7
]
)
;
primaries
.
fWX
=
png_fixed_point_to_float
(
chrm
[
0
]
)
;
primaries
.
fWY
=
png_fixed_point_to_float
(
chrm
[
1
]
)
;
SkMatrix44
toXYZD50
(
SkMatrix44
:
:
kUninitialized_Constructor
)
;
if
(
!
primaries
.
toXYZD50
(
&
toXYZD50
)
)
{
toXYZD50
.
set3x3RowMajorf
(
gSRGB_toXYZD50
)
;
}
if
(
PNG_INFO_gAMA
=
=
png_get_gAMA_fixed
(
png_ptr
info_ptr
&
gamma
)
)
{
SkColorSpaceTransferFn
fn
;
fn
.
fA
=
1
.
0f
;
fn
.
fB
=
fn
.
fC
=
fn
.
fD
=
fn
.
fE
=
fn
.
fF
=
0
.
0f
;
fn
.
fG
=
png_inverted_fixed_point_to_float
(
gamma
)
;
return
SkColorSpace
:
:
MakeRGB
(
fn
toXYZD50
)
;
}
return
SkColorSpace
:
:
MakeRGB
(
SkColorSpace
:
:
kSRGB_RenderTargetGamma
toXYZD50
)
;
}
if
(
PNG_INFO_gAMA
=
=
png_get_gAMA_fixed
(
png_ptr
info_ptr
&
gamma
)
)
{
SkColorSpaceTransferFn
fn
;
fn
.
fA
=
1
.
0f
;
fn
.
fB
=
fn
.
fC
=
fn
.
fD
=
fn
.
fE
=
fn
.
fF
=
0
.
0f
;
fn
.
fG
=
png_inverted_fixed_point_to_float
(
gamma
)
;
SkMatrix44
toXYZD50
(
SkMatrix44
:
:
kUninitialized_Constructor
)
;
toXYZD50
.
set3x3RowMajorf
(
gSRGB_toXYZD50
)
;
return
SkColorSpace
:
:
MakeRGB
(
fn
toXYZD50
)
;
}
#
endif
return
SkColorSpace
:
:
MakeSRGB
(
)
;
}
void
SkPngCodec
:
:
allocateStorage
(
const
SkImageInfo
&
dstInfo
)
{
switch
(
fXformMode
)
{
case
kSwizzleOnly_XformMode
:
break
;
case
kColorOnly_XformMode
:
case
kSwizzleColor_XformMode
:
{
const
int
bitsPerPixel
=
this
-
>
getEncodedInfo
(
)
.
bitsPerPixel
(
)
;
const
size_t
bytesPerPixel
=
(
bitsPerPixel
>
32
)
?
bitsPerPixel
/
8
:
4
;
const
size_t
colorXformBytes
=
dstInfo
.
width
(
)
*
bytesPerPixel
;
fStorage
.
reset
(
colorXformBytes
)
;
fColorXformSrcRow
=
fStorage
.
get
(
)
;
break
;
}
}
}
static
SkColorSpaceXform
:
:
ColorFormat
png_select_xform_format
(
const
SkEncodedInfo
&
info
)
{
if
(
16
=
=
info
.
bitsPerComponent
(
)
)
{
if
(
SkEncodedInfo
:
:
kRGBA_Color
=
=
info
.
color
(
)
)
{
return
SkColorSpaceXform
:
:
kRGBA_U16_BE_ColorFormat
;
}
else
if
(
SkEncodedInfo
:
:
kRGB_Color
=
=
info
.
color
(
)
)
{
return
SkColorSpaceXform
:
:
kRGB_U16_BE_ColorFormat
;
}
}
return
SkColorSpaceXform
:
:
kRGBA_8888_ColorFormat
;
}
void
SkPngCodec
:
:
applyXformRow
(
void
*
dst
const
void
*
src
)
{
const
SkColorSpaceXform
:
:
ColorFormat
srcColorFormat
=
png_select_xform_format
(
this
-
>
getEncodedInfo
(
)
)
;
switch
(
fXformMode
)
{
case
kSwizzleOnly_XformMode
:
fSwizzler
-
>
swizzle
(
dst
(
const
uint8_t
*
)
src
)
;
break
;
case
kColorOnly_XformMode
:
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
fXformColorFormat
dst
srcColorFormat
src
fXformWidth
fXformAlphaType
)
)
;
break
;
case
kSwizzleColor_XformMode
:
fSwizzler
-
>
swizzle
(
fColorXformSrcRow
(
const
uint8_t
*
)
src
)
;
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
fXformColorFormat
dst
srcColorFormat
fColorXformSrcRow
fXformWidth
fXformAlphaType
)
)
;
break
;
}
}
class
SkPngNormalDecoder
:
public
SkPngCodec
{
public
:
SkPngNormalDecoder
(
const
SkEncodedInfo
&
info
const
SkImageInfo
&
imageInfo
SkStream
*
stream
SkPngChunkReader
*
reader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
)
:
INHERITED
(
info
imageInfo
stream
reader
png_ptr
info_ptr
bitDepth
)
fRowsWrittenToOutput
(
0
)
fDst
(
nullptr
)
fRowBytes
(
0
)
fFirstRow
(
0
)
fLastRow
(
0
)
{
}
static
void
AllRowsCallback
(
png_structp
png_ptr
png_bytep
row
png_uint_32
rowNum
int
)
{
GetDecoder
(
png_ptr
)
-
>
allRowsCallback
(
row
rowNum
)
;
}
static
void
RowCallback
(
png_structp
png_ptr
png_bytep
row
png_uint_32
rowNum
int
)
{
GetDecoder
(
png_ptr
)
-
>
rowCallback
(
row
rowNum
)
;
}
#
ifdef
SK_GOOGLE3_PNG_HACK
static
void
RereadInfoCallback
(
png_structp
png_ptr
png_infop
)
{
GetDecoder
(
png_ptr
)
-
>
rereadInfoCallback
(
)
;
}
#
endif
private
:
int
fRowsWrittenToOutput
;
void
*
fDst
;
size_t
fRowBytes
;
int
fFirstRow
;
int
fLastRow
;
int
fRowsNeeded
;
typedef
SkPngCodec
INHERITED
;
static
SkPngNormalDecoder
*
GetDecoder
(
png_structp
png_ptr
)
{
return
static_cast
<
SkPngNormalDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
}
Result
decodeAllRows
(
void
*
dst
size_t
rowBytes
int
*
rowsDecoded
)
override
{
const
int
height
=
this
-
>
getInfo
(
)
.
height
(
)
;
png_progressive_info_ptr
callback
=
nullptr
;
#
ifdef
SK_GOOGLE3_PNG_HACK
callback
=
RereadInfoCallback
;
#
endif
png_set_progressive_read_fn
(
this
-
>
png_ptr
(
)
this
callback
AllRowsCallback
nullptr
)
;
fDst
=
dst
;
fRowBytes
=
rowBytes
;
fRowsWrittenToOutput
=
0
;
fFirstRow
=
0
;
fLastRow
=
height
-
1
;
this
-
>
processData
(
)
;
if
(
fRowsWrittenToOutput
=
=
height
)
{
return
SkCodec
:
:
kSuccess
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
fRowsWrittenToOutput
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
void
allRowsCallback
(
png_bytep
row
int
rowNum
)
{
SkASSERT
(
rowNum
=
=
fRowsWrittenToOutput
)
;
fRowsWrittenToOutput
+
+
;
this
-
>
applyXformRow
(
fDst
row
)
;
fDst
=
SkTAddOffset
<
void
>
(
fDst
fRowBytes
)
;
}
void
setRange
(
int
firstRow
int
lastRow
void
*
dst
size_t
rowBytes
)
override
{
png_progressive_info_ptr
callback
=
nullptr
;
#
ifdef
SK_GOOGLE3_PNG_HACK
callback
=
RereadInfoCallback
;
#
endif
png_set_progressive_read_fn
(
this
-
>
png_ptr
(
)
this
callback
RowCallback
nullptr
)
;
fFirstRow
=
firstRow
;
fLastRow
=
lastRow
;
fDst
=
dst
;
fRowBytes
=
rowBytes
;
fRowsWrittenToOutput
=
0
;
fRowsNeeded
=
fLastRow
-
fFirstRow
+
1
;
}
SkCodec
:
:
Result
decode
(
int
*
rowsDecoded
)
override
{
if
(
this
-
>
swizzler
(
)
)
{
const
int
sampleY
=
this
-
>
swizzler
(
)
-
>
sampleY
(
)
;
fRowsNeeded
=
get_scaled_dimension
(
fLastRow
-
fFirstRow
+
1
sampleY
)
;
}
this
-
>
processData
(
)
;
if
(
fRowsWrittenToOutput
=
=
fRowsNeeded
)
{
return
SkCodec
:
:
kSuccess
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
fRowsWrittenToOutput
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
void
rowCallback
(
png_bytep
row
int
rowNum
)
{
if
(
rowNum
<
fFirstRow
)
{
return
;
}
SkASSERT
(
rowNum
<
=
fLastRow
)
;
SkASSERT
(
fRowsWrittenToOutput
<
fRowsNeeded
)
;
if
(
!
this
-
>
swizzler
(
)
|
|
this
-
>
swizzler
(
)
-
>
rowNeeded
(
rowNum
-
fFirstRow
)
)
{
this
-
>
applyXformRow
(
fDst
row
)
;
fDst
=
SkTAddOffset
<
void
>
(
fDst
fRowBytes
)
;
fRowsWrittenToOutput
+
+
;
}
if
(
fRowsWrittenToOutput
=
=
fRowsNeeded
)
{
longjmp
(
PNG_JMPBUF
(
this
-
>
png_ptr
(
)
)
kStopDecoding
)
;
}
}
}
;
class
SkPngInterlacedDecoder
:
public
SkPngCodec
{
public
:
SkPngInterlacedDecoder
(
const
SkEncodedInfo
&
info
const
SkImageInfo
&
imageInfo
SkStream
*
stream
SkPngChunkReader
*
reader
png_structp
png_ptr
png_infop
info_ptr
int
bitDepth
int
numberPasses
)
:
INHERITED
(
info
imageInfo
stream
reader
png_ptr
info_ptr
bitDepth
)
fNumberPasses
(
numberPasses
)
fFirstRow
(
0
)
fLastRow
(
0
)
fLinesDecoded
(
0
)
fInterlacedComplete
(
false
)
fPng_rowbytes
(
0
)
{
}
static
void
InterlacedRowCallback
(
png_structp
png_ptr
png_bytep
row
png_uint_32
rowNum
int
pass
)
{
auto
decoder
=
static_cast
<
SkPngInterlacedDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
decoder
-
>
interlacedRowCallback
(
row
rowNum
pass
)
;
}
#
ifdef
SK_GOOGLE3_PNG_HACK
static
void
RereadInfoInterlacedCallback
(
png_structp
png_ptr
png_infop
)
{
static_cast
<
SkPngInterlacedDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
-
>
rereadInfoInterlaced
(
)
;
}
#
endif
private
:
const
int
fNumberPasses
;
int
fFirstRow
;
int
fLastRow
;
void
*
fDst
;
size_t
fRowBytes
;
int
fLinesDecoded
;
bool
fInterlacedComplete
;
size_t
fPng_rowbytes
;
SkAutoTMalloc
<
png_byte
>
fInterlaceBuffer
;
typedef
SkPngCodec
INHERITED
;
#
ifdef
SK_GOOGLE3_PNG_HACK
void
rereadInfoInterlaced
(
)
{
this
-
>
rereadInfoCallback
(
)
;
this
-
>
setUpInterlaceBuffer
(
this
-
>
getInfo
(
)
.
height
(
)
)
;
}
#
endif
void
interlacedRowCallback
(
png_bytep
row
int
rowNum
int
pass
)
{
if
(
rowNum
<
fFirstRow
|
|
rowNum
>
fLastRow
)
{
return
;
}
png_bytep
oldRow
=
fInterlaceBuffer
.
get
(
)
+
(
rowNum
-
fFirstRow
)
*
fPng_rowbytes
;
png_progressive_combine_row
(
this
-
>
png_ptr
(
)
oldRow
row
)
;
if
(
0
=
=
pass
)
{
SkASSERT
(
row
)
;
SkASSERT
(
fLinesDecoded
=
=
rowNum
-
fFirstRow
)
;
fLinesDecoded
+
+
;
}
else
{
SkASSERT
(
fLinesDecoded
=
=
fLastRow
-
fFirstRow
+
1
)
;
if
(
fNumberPasses
-
1
=
=
pass
&
&
rowNum
=
=
fLastRow
)
{
fInterlacedComplete
=
true
;
longjmp
(
PNG_JMPBUF
(
this
-
>
png_ptr
(
)
)
kStopDecoding
)
;
}
}
}
SkCodec
:
:
Result
decodeAllRows
(
void
*
dst
size_t
rowBytes
int
*
rowsDecoded
)
override
{
const
int
height
=
this
-
>
getInfo
(
)
.
height
(
)
;
this
-
>
setUpInterlaceBuffer
(
height
)
;
png_progressive_info_ptr
callback
=
nullptr
;
#
ifdef
SK_GOOGLE3_PNG_HACK
callback
=
RereadInfoInterlacedCallback
;
#
endif
png_set_progressive_read_fn
(
this
-
>
png_ptr
(
)
this
callback
InterlacedRowCallback
nullptr
)
;
fFirstRow
=
0
;
fLastRow
=
height
-
1
;
fLinesDecoded
=
0
;
this
-
>
processData
(
)
;
png_bytep
srcRow
=
fInterlaceBuffer
.
get
(
)
;
for
(
int
rowNum
=
0
;
rowNum
<
fLinesDecoded
;
rowNum
+
+
)
{
this
-
>
applyXformRow
(
dst
srcRow
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
)
;
srcRow
=
SkTAddOffset
<
png_byte
>
(
srcRow
fPng_rowbytes
)
;
}
if
(
fInterlacedComplete
)
{
return
SkCodec
:
:
kSuccess
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
fLinesDecoded
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
void
setRange
(
int
firstRow
int
lastRow
void
*
dst
size_t
rowBytes
)
override
{
this
-
>
setUpInterlaceBuffer
(
lastRow
-
firstRow
+
1
)
;
png_progressive_info_ptr
callback
=
nullptr
;
#
ifdef
SK_GOOGLE3_PNG_HACK
callback
=
RereadInfoInterlacedCallback
;
#
endif
png_set_progressive_read_fn
(
this
-
>
png_ptr
(
)
this
callback
InterlacedRowCallback
nullptr
)
;
fFirstRow
=
firstRow
;
fLastRow
=
lastRow
;
fDst
=
dst
;
fRowBytes
=
rowBytes
;
fLinesDecoded
=
0
;
}
SkCodec
:
:
Result
decode
(
int
*
rowsDecoded
)
override
{
this
-
>
processData
(
)
;
if
(
!
fLinesDecoded
)
{
if
(
rowsDecoded
)
{
*
rowsDecoded
=
0
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
const
int
sampleY
=
this
-
>
swizzler
(
)
?
this
-
>
swizzler
(
)
-
>
sampleY
(
)
:
1
;
const
int
rowsNeeded
=
get_scaled_dimension
(
fLastRow
-
fFirstRow
+
1
sampleY
)
;
int
rowsWrittenToOutput
=
0
;
png_bytep
srcRow
=
SkTAddOffset
<
png_byte
>
(
fInterlaceBuffer
.
get
(
)
fPng_rowbytes
*
get_start_coord
(
sampleY
)
)
;
void
*
dst
=
fDst
;
for
(
;
rowsWrittenToOutput
<
rowsNeeded
;
rowsWrittenToOutput
+
+
)
{
this
-
>
applyXformRow
(
dst
srcRow
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
fRowBytes
)
;
srcRow
=
SkTAddOffset
<
png_byte
>
(
srcRow
fPng_rowbytes
*
sampleY
)
;
}
if
(
fInterlacedComplete
)
{
return
SkCodec
:
:
kSuccess
;
}
if
(
rowsDecoded
)
{
*
rowsDecoded
=
rowsWrittenToOutput
;
}
return
SkCodec
:
:
kIncompleteInput
;
}
void
setUpInterlaceBuffer
(
int
height
)
{
fPng_rowbytes
=
png_get_rowbytes
(
this
-
>
png_ptr
(
)
this
-
>
info_ptr
(
)
)
;
fInterlaceBuffer
.
reset
(
fPng_rowbytes
*
height
)
;
fInterlacedComplete
=
false
;
}
}
;
#
ifdef
SK_GOOGLE3_PNG_HACK
bool
SkPngCodec
:
:
rereadHeaderIfNecessary
(
)
{
if
(
!
fNeedsToRereadHeader
)
{
return
true
;
}
if
(
this
-
>
stream
(
)
-
>
getPosition
(
)
>
0
)
{
this
-
>
stream
(
)
-
>
rewind
(
)
;
}
this
-
>
destroyReadStruct
(
)
;
png_structp
png_ptr
=
png_create_read_struct
(
PNG_LIBPNG_VER_STRING
nullptr
sk_error_fn
sk_warning_fn
)
;
if
(
!
png_ptr
)
{
return
false
;
}
AutoCleanPng
autoClean
(
png_ptr
nullptr
nullptr
nullptr
)
;
png_infop
info_ptr
=
png_create_info_struct
(
png_ptr
)
;
if
(
info_ptr
=
=
nullptr
)
{
return
false
;
}
autoClean
.
setInfoPtr
(
info_ptr
)
;
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if
(
fPngChunkReader
.
get
(
)
)
{
png_set_keep_unknown_chunks
(
png_ptr
PNG_HANDLE_CHUNK_ALWAYS
(
png_byte
*
)
"
"
0
)
;
png_set_read_user_chunk_fn
(
png_ptr
(
png_voidp
)
fPngChunkReader
.
get
(
)
sk_read_user_chunk
)
;
}
#
endif
fPng_ptr
=
png_ptr
;
fInfo_ptr
=
info_ptr
;
autoClean
.
releasePngPtrs
(
)
;
fNeedsToRereadHeader
=
false
;
return
true
;
}
#
endif
static
bool
read_header
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
SkCodec
*
*
outCodec
png_structp
*
png_ptrp
png_infop
*
info_ptrp
)
{
png_structp
png_ptr
=
png_create_read_struct
(
PNG_LIBPNG_VER_STRING
nullptr
sk_error_fn
sk_warning_fn
)
;
if
(
!
png_ptr
)
{
return
false
;
}
AutoCleanPng
autoClean
(
png_ptr
stream
chunkReader
outCodec
)
;
png_infop
info_ptr
=
png_create_info_struct
(
png_ptr
)
;
if
(
info_ptr
=
=
nullptr
)
{
return
false
;
}
autoClean
.
setInfoPtr
(
info_ptr
)
;
if
(
setjmp
(
PNG_JMPBUF
(
png_ptr
)
)
)
{
return
false
;
}
#
ifdef
PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if
(
chunkReader
)
{
png_set_keep_unknown_chunks
(
png_ptr
PNG_HANDLE_CHUNK_ALWAYS
(
png_byte
*
)
"
"
0
)
;
png_set_read_user_chunk_fn
(
png_ptr
(
png_voidp
)
chunkReader
sk_read_user_chunk
)
;
}
#
endif
const
bool
decodedBounds
=
autoClean
.
decodeBounds
(
)
;
if
(
!
decodedBounds
)
{
return
false
;
}
if
(
png_ptrp
)
{
*
png_ptrp
=
png_ptr
;
}
if
(
info_ptrp
)
{
*
info_ptrp
=
info_ptr
;
}
if
(
outCodec
)
{
SkASSERT
(
*
outCodec
)
;
}
return
true
;
}
static
void
general_info_callback
(
png_structp
png_ptr
png_infop
info_ptr
SkEncodedInfo
:
:
Color
*
outColor
SkEncodedInfo
:
:
Alpha
*
outAlpha
int
*
outBitDepth
)
{
png_uint_32
origWidth
origHeight
;
int
bitDepth
encodedColorType
;
png_get_IHDR
(
png_ptr
info_ptr
&
origWidth
&
origHeight
&
bitDepth
&
encodedColorType
nullptr
nullptr
nullptr
)
;
if
(
bitDepth
=
=
16
&
&
(
PNG_COLOR_TYPE_GRAY
=
=
encodedColorType
|
|
PNG_COLOR_TYPE_GRAY_ALPHA
=
=
encodedColorType
)
)
{
bitDepth
=
8
;
png_set_strip_16
(
png_ptr
)
;
}
SkEncodedInfo
:
:
Color
color
;
SkEncodedInfo
:
:
Alpha
alpha
;
switch
(
encodedColorType
)
{
case
PNG_COLOR_TYPE_PALETTE
:
if
(
bitDepth
<
8
)
{
bitDepth
=
8
;
png_set_packing
(
png_ptr
)
;
}
color
=
SkEncodedInfo
:
:
kPalette_Color
;
alpha
=
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
?
SkEncodedInfo
:
:
kUnpremul_Alpha
:
SkEncodedInfo
:
:
kOpaque_Alpha
;
break
;
case
PNG_COLOR_TYPE_RGB
:
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
color
=
SkEncodedInfo
:
:
kRGBA_Color
;
alpha
=
SkEncodedInfo
:
:
kBinary_Alpha
;
}
else
{
color
=
SkEncodedInfo
:
:
kRGB_Color
;
alpha
=
SkEncodedInfo
:
:
kOpaque_Alpha
;
}
break
;
case
PNG_COLOR_TYPE_GRAY
:
if
(
bitDepth
<
8
)
{
bitDepth
=
8
;
png_set_expand_gray_1_2_4_to_8
(
png_ptr
)
;
}
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
png_set_tRNS_to_alpha
(
png_ptr
)
;
color
=
SkEncodedInfo
:
:
kGrayAlpha_Color
;
alpha
=
SkEncodedInfo
:
:
kBinary_Alpha
;
}
else
{
color
=
SkEncodedInfo
:
:
kGray_Color
;
alpha
=
SkEncodedInfo
:
:
kOpaque_Alpha
;
}
break
;
case
PNG_COLOR_TYPE_GRAY_ALPHA
:
color
=
SkEncodedInfo
:
:
kGrayAlpha_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
case
PNG_COLOR_TYPE_RGBA
:
color
=
SkEncodedInfo
:
:
kRGBA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
default
:
SkASSERT
(
false
)
;
color
=
SkEncodedInfo
:
:
kRGBA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
if
(
outColor
)
{
*
outColor
=
color
;
}
if
(
outAlpha
)
{
*
outAlpha
=
alpha
;
}
if
(
outBitDepth
)
{
*
outBitDepth
=
bitDepth
;
}
}
#
ifdef
SK_GOOGLE3_PNG_HACK
void
SkPngCodec
:
:
rereadInfoCallback
(
)
{
general_info_callback
(
fPng_ptr
fInfo_ptr
nullptr
nullptr
nullptr
)
;
png_set_interlace_handling
(
fPng_ptr
)
;
png_read_update_info
(
fPng_ptr
fInfo_ptr
)
;
}
#
endif
void
AutoCleanPng
:
:
infoCallback
(
)
{
SkEncodedInfo
:
:
Color
color
;
SkEncodedInfo
:
:
Alpha
alpha
;
int
bitDepth
;
general_info_callback
(
fPng_ptr
fInfo_ptr
&
color
&
alpha
&
bitDepth
)
;
const
int
numberPasses
=
png_set_interlace_handling
(
fPng_ptr
)
;
fReadHeader
=
true
;
fDecodedBounds
=
true
;
#
ifndef
SK_GOOGLE3_PNG_HACK
png_process_data_pause
(
fPng_ptr
1
)
;
#
else
fPng_ptr
-
>
buffer_size
=
0
;
#
endif
if
(
fOutCodec
)
{
SkASSERT
(
nullptr
=
=
*
fOutCodec
)
;
SkColorSpace_Base
:
:
ICCTypeFlag
iccType
=
SkColorSpace_Base
:
:
kRGB_ICCTypeFlag
;
if
(
SkEncodedInfo
:
:
kGray_Color
=
=
color
|
|
SkEncodedInfo
:
:
kGrayAlpha_Color
=
=
color
)
{
iccType
|
=
SkColorSpace_Base
:
:
kGray_ICCTypeFlag
;
}
sk_sp
<
SkColorSpace
>
colorSpace
=
read_color_space
(
fPng_ptr
fInfo_ptr
iccType
)
;
const
bool
unsupportedICC
=
!
colorSpace
;
if
(
!
colorSpace
)
{
colorSpace
=
SkColorSpace
:
:
MakeSRGB
(
)
;
}
SkEncodedInfo
encodedInfo
=
SkEncodedInfo
:
:
Make
(
color
alpha
bitDepth
)
;
png_uint_32
origWidth
=
png_get_image_width
(
fPng_ptr
fInfo_ptr
)
;
png_uint_32
origHeight
=
png_get_image_height
(
fPng_ptr
fInfo_ptr
)
;
png_byte
bitDepth
=
png_get_bit_depth
(
fPng_ptr
fInfo_ptr
)
;
SkImageInfo
imageInfo
=
encodedInfo
.
makeImageInfo
(
origWidth
origHeight
colorSpace
)
;
if
(
SkEncodedInfo
:
:
kOpaque_Alpha
=
=
alpha
)
{
png_color_8p
sigBits
;
if
(
png_get_sBIT
(
fPng_ptr
fInfo_ptr
&
sigBits
)
)
{
if
(
5
=
=
sigBits
-
>
red
&
&
6
=
=
sigBits
-
>
green
&
&
5
=
=
sigBits
-
>
blue
)
{
imageInfo
=
imageInfo
.
makeColorType
(
kRGB_565_SkColorType
)
;
}
}
}
if
(
1
=
=
numberPasses
)
{
*
fOutCodec
=
new
SkPngNormalDecoder
(
encodedInfo
imageInfo
fStream
fChunkReader
fPng_ptr
fInfo_ptr
bitDepth
)
;
}
else
{
*
fOutCodec
=
new
SkPngInterlacedDecoder
(
encodedInfo
imageInfo
fStream
fChunkReader
fPng_ptr
fInfo_ptr
bitDepth
numberPasses
)
;
}
(
*
fOutCodec
)
-
>
setUnsupportedICC
(
unsupportedICC
)
;
}
this
-
>
releasePngPtrs
(
)
;
}
SkPngCodec
:
:
SkPngCodec
(
const
SkEncodedInfo
&
encodedInfo
const
SkImageInfo
&
imageInfo
SkStream
*
stream
SkPngChunkReader
*
chunkReader
void
*
png_ptr
void
*
info_ptr
int
bitDepth
)
:
INHERITED
(
encodedInfo
imageInfo
stream
)
fPngChunkReader
(
SkSafeRef
(
chunkReader
)
)
fPng_ptr
(
png_ptr
)
fInfo_ptr
(
info_ptr
)
fColorXformSrcRow
(
nullptr
)
fBitDepth
(
bitDepth
)
#
ifdef
SK_GOOGLE3_PNG_HACK
fNeedsToRereadHeader
(
true
)
#
endif
{
}
SkPngCodec
:
:
~
SkPngCodec
(
)
{
this
-
>
destroyReadStruct
(
)
;
}
void
SkPngCodec
:
:
destroyReadStruct
(
)
{
if
(
fPng_ptr
)
{
SkASSERT
(
fInfo_ptr
)
;
png_destroy_read_struct
(
(
png_struct
*
*
)
&
fPng_ptr
(
png_info
*
*
)
&
fInfo_ptr
nullptr
)
;
fPng_ptr
=
nullptr
;
fInfo_ptr
=
nullptr
;
}
}
bool
SkPngCodec
:
:
initializeXforms
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
{
if
(
setjmp
(
PNG_JMPBUF
(
(
png_struct
*
)
fPng_ptr
)
)
)
{
SkCodecPrintf
(
"
Failed
on
png_read_update_info
.
\
n
"
)
;
return
false
;
}
png_read_update_info
(
fPng_ptr
fInfo_ptr
)
;
fSwizzler
.
reset
(
nullptr
)
;
if
(
!
this
-
>
initializeColorXform
(
dstInfo
options
.
fPremulBehavior
)
)
{
return
false
;
}
bool
skipFormatConversion
=
false
;
switch
(
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
{
case
SkEncodedInfo
:
:
kRGB_Color
:
if
(
this
-
>
getEncodedInfo
(
)
.
bitsPerComponent
(
)
!
=
16
)
{
break
;
}
case
SkEncodedInfo
:
:
kRGBA_Color
:
skipFormatConversion
=
this
-
>
colorXform
(
)
;
break
;
default
:
break
;
}
if
(
skipFormatConversion
&
&
!
options
.
fSubset
)
{
fXformMode
=
kColorOnly_XformMode
;
return
true
;
}
if
(
SkEncodedInfo
:
:
kPalette_Color
=
=
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
{
if
(
!
this
-
>
createColorTable
(
dstInfo
ctableCount
)
)
{
return
false
;
}
}
copy_color_table
(
dstInfo
fColorTable
.
get
(
)
ctable
ctableCount
)
;
this
-
>
initializeSwizzler
(
dstInfo
options
skipFormatConversion
)
;
return
true
;
}
void
SkPngCodec
:
:
initializeXformParams
(
)
{
switch
(
fXformMode
)
{
case
kColorOnly_XformMode
:
fXformColorFormat
=
select_xform_format
(
this
-
>
dstInfo
(
)
.
colorType
(
)
)
;
fXformAlphaType
=
select_xform_alpha
(
this
-
>
dstInfo
(
)
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
fXformWidth
=
this
-
>
dstInfo
(
)
.
width
(
)
;
break
;
case
kSwizzleColor_XformMode
:
fXformColorFormat
=
select_xform_format
(
this
-
>
dstInfo
(
)
.
colorType
(
)
)
;
fXformAlphaType
=
select_xform_alpha
(
this
-
>
dstInfo
(
)
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
fXformWidth
=
this
-
>
swizzler
(
)
-
>
swizzleWidth
(
)
;
break
;
default
:
break
;
}
}
void
SkPngCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
options
bool
skipFormatConversion
)
{
SkImageInfo
swizzlerInfo
=
dstInfo
;
Options
swizzlerOptions
=
options
;
fXformMode
=
kSwizzleOnly_XformMode
;
if
(
this
-
>
colorXform
(
)
&
&
apply_xform_on_decode
(
dstInfo
.
colorType
(
)
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeColorType
(
kXformSrcColorType
)
;
if
(
kPremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
}
fXformMode
=
kSwizzleColor_XformMode
;
swizzlerOptions
.
fZeroInitialized
=
kNo_ZeroInitialized
;
}
const
SkPMColor
*
colors
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
this
-
>
getEncodedInfo
(
)
colors
swizzlerInfo
swizzlerOptions
nullptr
skipFormatConversion
)
)
;
SkASSERT
(
fSwizzler
)
;
}
SkSampler
*
SkPngCodec
:
:
getSampler
(
bool
createIfNecessary
)
{
if
(
fSwizzler
|
|
!
createIfNecessary
)
{
return
fSwizzler
.
get
(
)
;
}
this
-
>
initializeSwizzler
(
this
-
>
dstInfo
(
)
this
-
>
options
(
)
true
)
;
return
fSwizzler
.
get
(
)
;
}
bool
SkPngCodec
:
:
onRewind
(
)
{
#
ifdef
SK_GOOGLE3_PNG_HACK
fNeedsToRereadHeader
=
true
;
return
true
;
#
else
this
-
>
destroyReadStruct
(
)
;
png_structp
png_ptr
;
png_infop
info_ptr
;
if
(
!
read_header
(
this
-
>
stream
(
)
fPngChunkReader
.
get
(
)
nullptr
&
png_ptr
&
info_ptr
)
)
{
return
false
;
}
fPng_ptr
=
png_ptr
;
fInfo_ptr
=
info_ptr
;
return
true
;
#
endif
}
SkCodec
:
:
Result
SkPngCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
SkPMColor
ctable
[
]
int
*
ctableCount
int
*
rowsDecoded
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
|
|
!
this
-
>
initializeXforms
(
dstInfo
options
ctable
ctableCount
)
)
{
return
kInvalidConversion
;
}
#
ifdef
SK_GOOGLE3_PNG_HACK
if
(
!
this
-
>
rereadHeaderIfNecessary
(
)
)
{
return
kCouldNotRewind
;
}
#
endif
if
(
options
.
fSubset
)
{
return
kUnimplemented
;
}
this
-
>
allocateStorage
(
dstInfo
)
;
this
-
>
initializeXformParams
(
)
;
return
this
-
>
decodeAllRows
(
dst
rowBytes
rowsDecoded
)
;
}
SkCodec
:
:
Result
SkPngCodec
:
:
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
&
options
SkPMColor
*
ctable
int
*
ctableCount
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
|
|
!
this
-
>
initializeXforms
(
dstInfo
options
ctable
ctableCount
)
)
{
return
kInvalidConversion
;
}
#
ifdef
SK_GOOGLE3_PNG_HACK
if
(
!
this
-
>
rereadHeaderIfNecessary
(
)
)
{
return
kCouldNotRewind
;
}
#
endif
this
-
>
allocateStorage
(
dstInfo
)
;
int
firstRow
lastRow
;
if
(
options
.
fSubset
)
{
firstRow
=
options
.
fSubset
-
>
top
(
)
;
lastRow
=
options
.
fSubset
-
>
bottom
(
)
-
1
;
}
else
{
firstRow
=
0
;
lastRow
=
dstInfo
.
height
(
)
-
1
;
}
this
-
>
setRange
(
firstRow
lastRow
dst
rowBytes
)
;
return
kSuccess
;
}
SkCodec
:
:
Result
SkPngCodec
:
:
onIncrementalDecode
(
int
*
rowsDecoded
)
{
this
-
>
initializeXformParams
(
)
;
return
this
-
>
decode
(
rowsDecoded
)
;
}
uint64_t
SkPngCodec
:
:
onGetFillValue
(
const
SkImageInfo
&
dstInfo
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
if
(
colorPtr
)
{
SkAlphaType
alphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
return
get_color_table_fill_value
(
dstInfo
.
colorType
(
)
alphaType
colorPtr
0
this
-
>
colorXform
(
)
true
)
;
}
return
INHERITED
:
:
onGetFillValue
(
dstInfo
)
;
}
SkCodec
*
SkPngCodec
:
:
NewFromStream
(
SkStream
*
stream
SkPngChunkReader
*
chunkReader
)
{
std
:
:
unique_ptr
<
SkStream
>
streamDeleter
(
stream
)
;
SkCodec
*
outCodec
=
nullptr
;
if
(
read_header
(
streamDeleter
.
get
(
)
chunkReader
&
outCodec
nullptr
nullptr
)
)
{
SkASSERT
(
outCodec
)
;
streamDeleter
.
release
(
)
;
return
outCodec
;
}
return
nullptr
;
}
