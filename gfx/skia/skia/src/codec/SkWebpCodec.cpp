#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorSpaceXform
.
h
"
#
include
"
SkWebpCodec
.
h
"
#
include
"
SkStreamPriv
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
webp
/
decode
.
h
"
#
include
"
webp
/
demux
.
h
"
#
include
"
webp
/
encode
.
h
"
bool
SkWebpCodec
:
:
IsWebp
(
const
void
*
buf
size_t
bytesRead
)
{
const
char
*
bytes
=
static_cast
<
const
char
*
>
(
buf
)
;
return
bytesRead
>
=
14
&
&
!
memcmp
(
bytes
"
RIFF
"
4
)
&
&
!
memcmp
(
&
bytes
[
8
]
"
WEBPVP
"
6
)
;
}
SkCodec
*
SkWebpCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
sk_sp
<
SkData
>
data
=
nullptr
;
if
(
stream
-
>
getMemoryBase
(
)
)
{
data
=
SkData
:
:
MakeWithoutCopy
(
stream
-
>
getMemoryBase
(
)
stream
-
>
getLength
(
)
)
;
}
else
{
data
=
SkCopyStreamToData
(
stream
)
;
streamDeleter
.
reset
(
nullptr
)
;
}
WebPData
webpData
=
{
data
-
>
bytes
(
)
data
-
>
size
(
)
}
;
SkAutoTCallVProc
<
WebPDemuxer
WebPDemuxDelete
>
demux
(
WebPDemuxPartial
(
&
webpData
nullptr
)
)
;
if
(
nullptr
=
=
demux
)
{
return
nullptr
;
}
WebPChunkIterator
chunkIterator
;
SkAutoTCallVProc
<
WebPChunkIterator
WebPDemuxReleaseChunkIterator
>
autoCI
(
&
chunkIterator
)
;
sk_sp
<
SkColorSpace
>
colorSpace
=
nullptr
;
if
(
WebPDemuxGetChunk
(
demux
"
ICCP
"
1
&
chunkIterator
)
)
{
colorSpace
=
SkColorSpace
:
:
NewICC
(
chunkIterator
.
chunk
.
bytes
chunkIterator
.
chunk
.
size
)
;
}
if
(
!
colorSpace
)
{
colorSpace
=
SkColorSpace
:
:
NewNamed
(
SkColorSpace
:
:
kSRGB_Named
)
;
}
WebPIterator
frame
;
SkAutoTCallVProc
<
WebPIterator
WebPDemuxReleaseIterator
>
autoFrame
(
&
frame
)
;
if
(
!
WebPDemuxGetFrame
(
demux
1
&
frame
)
)
{
return
nullptr
;
}
{
const
int64_t
size
=
sk_64_mul
(
frame
.
width
frame
.
height
)
;
if
(
!
sk_64_isS32
(
size
)
)
{
return
nullptr
;
}
if
(
sk_64_asS32
(
size
)
>
(
0x7FFFFFFF
>
>
2
)
)
{
return
nullptr
;
}
}
WebPBitstreamFeatures
features
;
VP8StatusCode
status
=
WebPGetFeatures
(
frame
.
fragment
.
bytes
frame
.
fragment
.
size
&
features
)
;
if
(
VP8_STATUS_OK
!
=
status
)
{
return
nullptr
;
}
SkEncodedInfo
:
:
Color
color
;
SkEncodedInfo
:
:
Alpha
alpha
;
switch
(
features
.
format
)
{
case
0
:
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
case
1
:
if
(
SkToBool
(
features
.
has_alpha
)
)
{
color
=
SkEncodedInfo
:
:
kYUVA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
else
{
color
=
SkEncodedInfo
:
:
kYUV_Color
;
alpha
=
SkEncodedInfo
:
:
kOpaque_Alpha
;
}
break
;
case
2
:
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
default
:
return
nullptr
;
}
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
color
alpha
8
)
;
return
new
SkWebpCodec
(
features
.
width
features
.
height
info
std
:
:
move
(
colorSpace
)
streamDeleter
.
release
(
)
demux
.
release
(
)
std
:
:
move
(
data
)
)
;
}
SkISize
SkWebpCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
SkISize
dim
=
this
-
>
getInfo
(
)
.
dimensions
(
)
;
dim
.
fWidth
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fWidth
)
)
;
dim
.
fHeight
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fHeight
)
)
;
return
dim
;
}
bool
SkWebpCodec
:
:
onDimensionsSupported
(
const
SkISize
&
dim
)
{
const
SkImageInfo
&
info
=
this
-
>
getInfo
(
)
;
return
dim
.
width
(
)
>
=
1
&
&
dim
.
width
(
)
<
=
info
.
width
(
)
&
&
dim
.
height
(
)
>
=
1
&
&
dim
.
height
(
)
<
=
info
.
height
(
)
;
}
static
WEBP_CSP_MODE
webp_decode_mode
(
SkColorType
ct
bool
premultiply
)
{
switch
(
ct
)
{
case
kBGRA_8888_SkColorType
:
return
premultiply
?
MODE_bgrA
:
MODE_BGRA
;
case
kRGBA_8888_SkColorType
:
return
premultiply
?
MODE_rgbA
:
MODE_RGBA
;
case
kRGB_565_SkColorType
:
return
MODE_RGB_565
;
default
:
return
MODE_LAST
;
}
}
bool
SkWebpCodec
:
:
onGetValidSubset
(
SkIRect
*
desiredSubset
)
const
{
if
(
!
desiredSubset
)
{
return
false
;
}
SkIRect
dimensions
=
SkIRect
:
:
MakeSize
(
this
-
>
getInfo
(
)
.
dimensions
(
)
)
;
if
(
!
dimensions
.
contains
(
*
desiredSubset
)
)
{
return
false
;
}
desiredSubset
-
>
fLeft
=
(
desiredSubset
-
>
fLeft
>
>
1
)
<
<
1
;
desiredSubset
-
>
fTop
=
(
desiredSubset
-
>
fTop
>
>
1
)
<
<
1
;
return
true
;
}
SkCodec
:
:
Result
SkWebpCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
SkPMColor
*
int
*
int
*
rowsDecodedPtr
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
std
:
:
unique_ptr
<
SkColorSpaceXform
>
colorXform
=
nullptr
;
if
(
needs_color_xform
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
colorXform
=
SkColorSpaceXform
:
:
New
(
this
-
>
getInfo
(
)
.
colorSpace
(
)
dstInfo
.
colorSpace
(
)
)
;
SkASSERT
(
colorXform
)
;
}
WebPDecoderConfig
config
;
if
(
0
=
=
WebPInitDecoderConfig
(
&
config
)
)
{
return
kInvalidInput
;
}
SkAutoTCallVProc
<
WebPDecBuffer
WebPFreeDecBuffer
>
autoFree
(
&
(
config
.
output
)
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeSize
(
this
-
>
getInfo
(
)
.
dimensions
(
)
)
;
if
(
options
.
fSubset
)
{
if
(
!
bounds
.
contains
(
*
options
.
fSubset
)
)
{
return
kInvalidParameters
;
}
bounds
=
*
options
.
fSubset
;
if
(
!
SkIsAlign2
(
bounds
.
fLeft
)
|
|
!
SkIsAlign2
(
bounds
.
fTop
)
)
{
return
kInvalidParameters
;
}
#
ifdef
SK_DEBUG
{
SkIRect
subset
(
bounds
)
;
SkASSERT
(
this
-
>
getValidSubset
(
&
subset
)
&
&
subset
=
=
bounds
)
;
}
#
endif
config
.
options
.
use_cropping
=
1
;
config
.
options
.
crop_left
=
bounds
.
fLeft
;
config
.
options
.
crop_top
=
bounds
.
fTop
;
config
.
options
.
crop_width
=
bounds
.
width
(
)
;
config
.
options
.
crop_height
=
bounds
.
height
(
)
;
}
SkISize
dstDimensions
=
dstInfo
.
dimensions
(
)
;
if
(
bounds
.
size
(
)
!
=
dstDimensions
)
{
config
.
options
.
use_scaling
=
1
;
config
.
options
.
scaled_width
=
dstDimensions
.
width
(
)
;
config
.
options
.
scaled_height
=
dstDimensions
.
height
(
)
;
}
config
.
output
.
colorspace
=
colorXform
?
MODE_BGRA
:
webp_decode_mode
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
=
=
kPremul_SkAlphaType
)
;
config
.
output
.
is_external_memory
=
1
;
SkAutoTMalloc
<
uint32_t
>
pixels
;
if
(
kRGBA_F16_SkColorType
=
=
dstInfo
.
colorType
(
)
)
{
pixels
.
reset
(
dstDimensions
.
width
(
)
*
dstDimensions
.
height
(
)
)
;
config
.
output
.
u
.
RGBA
.
rgba
=
(
uint8_t
*
)
pixels
.
get
(
)
;
config
.
output
.
u
.
RGBA
.
stride
=
(
int
)
dstDimensions
.
width
(
)
*
sizeof
(
uint32_t
)
;
config
.
output
.
u
.
RGBA
.
size
=
config
.
output
.
u
.
RGBA
.
stride
*
dstDimensions
.
height
(
)
;
}
else
{
config
.
output
.
u
.
RGBA
.
rgba
=
(
uint8_t
*
)
dst
;
config
.
output
.
u
.
RGBA
.
stride
=
(
int
)
rowBytes
;
config
.
output
.
u
.
RGBA
.
size
=
dstInfo
.
getSafeSize
(
rowBytes
)
;
}
WebPIterator
frame
;
SkAutoTCallVProc
<
WebPIterator
WebPDemuxReleaseIterator
>
autoFrame
(
&
frame
)
;
SkAssertResult
(
WebPDemuxGetFrame
(
fDemux
1
&
frame
)
)
;
SkAutoTCallVProc
<
WebPIDecoder
WebPIDelete
>
idec
(
WebPIDecode
(
nullptr
0
&
config
)
)
;
if
(
!
idec
)
{
return
kInvalidInput
;
}
int
rowsDecoded
;
SkCodec
:
:
Result
result
;
switch
(
WebPIUpdate
(
idec
frame
.
fragment
.
bytes
frame
.
fragment
.
size
)
)
{
case
VP8_STATUS_OK
:
rowsDecoded
=
dstInfo
.
height
(
)
;
result
=
kSuccess
;
break
;
case
VP8_STATUS_SUSPENDED
:
WebPIDecGetRGB
(
idec
rowsDecodedPtr
nullptr
nullptr
nullptr
)
;
rowsDecoded
=
*
rowsDecodedPtr
;
result
=
kIncompleteInput
;
break
;
default
:
return
kInvalidInput
;
}
if
(
colorXform
)
{
SkColorSpaceXform
:
:
ColorFormat
dstColorFormat
=
select_xform_format
(
dstInfo
.
colorType
(
)
)
;
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
uint32_t
*
src
=
(
uint32_t
*
)
config
.
output
.
u
.
RGBA
.
rgba
;
size_t
srcRowBytes
=
config
.
output
.
u
.
RGBA
.
stride
;
for
(
int
y
=
0
;
y
<
rowsDecoded
;
y
+
+
)
{
colorXform
-
>
apply
(
dst
src
dstInfo
.
width
(
)
dstColorFormat
SkColorSpaceXform
:
:
kBGRA_8888_ColorFormat
xformAlphaType
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
)
;
src
=
SkTAddOffset
<
uint32_t
>
(
src
srcRowBytes
)
;
}
}
return
result
;
}
SkWebpCodec
:
:
SkWebpCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
sk_sp
<
SkColorSpace
>
colorSpace
SkStream
*
stream
WebPDemuxer
*
demux
sk_sp
<
SkData
>
data
)
:
INHERITED
(
width
height
info
stream
std
:
:
move
(
colorSpace
)
)
fDemux
(
demux
)
fData
(
std
:
:
move
(
data
)
)
{
}
