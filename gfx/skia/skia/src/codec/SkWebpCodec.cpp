#
include
"
SkCodecPriv
.
h
"
#
include
"
SkWebpCodec
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
webp
/
decode
.
h
"
#
include
"
webp
/
encode
.
h
"
bool
SkWebpCodec
:
:
IsWebp
(
SkStream
*
stream
)
{
const
char
LENGTH
=
14
;
char
bytes
[
LENGTH
]
;
if
(
stream
-
>
read
(
&
bytes
LENGTH
)
!
=
LENGTH
)
{
return
false
;
}
return
!
memcmp
(
bytes
"
RIFF
"
4
)
&
&
!
memcmp
(
&
bytes
[
8
]
"
WEBPVP
"
6
)
;
}
static
const
size_t
WEBP_VP8_HEADER_SIZE
=
30
;
static
bool
webp_parse_header
(
SkStream
*
stream
SkImageInfo
*
info
)
{
unsigned
char
buffer
[
WEBP_VP8_HEADER_SIZE
]
;
if
(
!
stream
-
>
peek
(
buffer
WEBP_VP8_HEADER_SIZE
)
)
{
return
false
;
}
WebPBitstreamFeatures
features
;
VP8StatusCode
status
=
WebPGetFeatures
(
buffer
WEBP_VP8_HEADER_SIZE
&
features
)
;
if
(
VP8_STATUS_OK
!
=
status
)
{
return
false
;
}
{
const
int64_t
size
=
sk_64_mul
(
features
.
width
features
.
height
)
;
if
(
!
sk_64_isS32
(
size
)
)
{
return
false
;
}
if
(
sk_64_asS32
(
size
)
>
(
0x7FFFFFFF
>
>
2
)
)
{
return
false
;
}
}
if
(
info
)
{
*
info
=
SkImageInfo
:
:
Make
(
features
.
width
features
.
height
kN32_SkColorType
SkToBool
(
features
.
has_alpha
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
)
;
}
return
true
;
}
SkCodec
*
SkWebpCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
SkImageInfo
info
;
if
(
webp_parse_header
(
stream
&
info
)
)
{
return
new
SkWebpCodec
(
info
streamDeleter
.
detach
(
)
)
;
}
return
nullptr
;
}
static
bool
webp_conversion_possible
(
const
SkImageInfo
&
dst
const
SkImageInfo
&
src
)
{
if
(
dst
.
profileType
(
)
!
=
src
.
profileType
(
)
)
{
return
false
;
}
if
(
!
valid_alpha
(
dst
.
alphaType
(
)
src
.
alphaType
(
)
)
)
{
return
false
;
}
switch
(
dst
.
colorType
(
)
)
{
case
kBGRA_8888_SkColorType
:
case
kRGBA_8888_SkColorType
:
return
true
;
case
kRGB_565_SkColorType
:
return
src
.
alphaType
(
)
=
=
kOpaque_SkAlphaType
;
default
:
return
false
;
}
}
SkISize
SkWebpCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
SkISize
dim
=
this
-
>
getInfo
(
)
.
dimensions
(
)
;
dim
.
fWidth
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fWidth
)
)
;
dim
.
fHeight
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fHeight
)
)
;
return
dim
;
}
bool
SkWebpCodec
:
:
onDimensionsSupported
(
const
SkISize
&
dim
)
{
const
SkImageInfo
&
info
=
this
-
>
getInfo
(
)
;
return
dim
.
width
(
)
>
=
1
&
&
dim
.
width
(
)
<
=
info
.
width
(
)
&
&
dim
.
height
(
)
>
=
1
&
&
dim
.
height
(
)
<
=
info
.
height
(
)
;
}
static
WEBP_CSP_MODE
webp_decode_mode
(
SkColorType
ct
bool
premultiply
)
{
switch
(
ct
)
{
case
kBGRA_8888_SkColorType
:
return
premultiply
?
MODE_bgrA
:
MODE_BGRA
;
case
kRGBA_8888_SkColorType
:
return
premultiply
?
MODE_rgbA
:
MODE_RGBA
;
case
kRGB_565_SkColorType
:
return
MODE_RGB_565
;
default
:
return
MODE_LAST
;
}
}
static
const
size_t
BUFFER_SIZE
=
4096
;
bool
SkWebpCodec
:
:
onGetValidSubset
(
SkIRect
*
desiredSubset
)
const
{
if
(
!
desiredSubset
)
{
return
false
;
}
SkIRect
dimensions
=
SkIRect
:
:
MakeSize
(
this
-
>
getInfo
(
)
.
dimensions
(
)
)
;
if
(
!
dimensions
.
contains
(
*
desiredSubset
)
)
{
return
false
;
}
desiredSubset
-
>
fLeft
=
(
desiredSubset
-
>
fLeft
>
>
1
)
<
<
1
;
desiredSubset
-
>
fTop
=
(
desiredSubset
-
>
fTop
>
>
1
)
<
<
1
;
return
true
;
}
SkCodec
:
:
Result
SkWebpCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
SkPMColor
*
int
*
int
*
rowsDecoded
)
{
if
(
!
webp_conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
kInvalidConversion
;
}
WebPDecoderConfig
config
;
if
(
0
=
=
WebPInitDecoderConfig
(
&
config
)
)
{
return
kInvalidInput
;
}
SkAutoTCallVProc
<
WebPDecBuffer
WebPFreeDecBuffer
>
autoFree
(
&
(
config
.
output
)
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeSize
(
this
-
>
getInfo
(
)
.
dimensions
(
)
)
;
if
(
options
.
fSubset
)
{
if
(
!
bounds
.
contains
(
*
options
.
fSubset
)
)
{
return
kInvalidParameters
;
}
bounds
=
*
options
.
fSubset
;
if
(
!
SkIsAlign2
(
bounds
.
fLeft
)
|
|
!
SkIsAlign2
(
bounds
.
fTop
)
)
{
return
kInvalidParameters
;
}
#
ifdef
SK_DEBUG
{
SkIRect
subset
(
bounds
)
;
SkASSERT
(
this
-
>
getValidSubset
(
&
subset
)
&
&
subset
=
=
bounds
)
;
}
#
endif
config
.
options
.
use_cropping
=
1
;
config
.
options
.
crop_left
=
bounds
.
fLeft
;
config
.
options
.
crop_top
=
bounds
.
fTop
;
config
.
options
.
crop_width
=
bounds
.
width
(
)
;
config
.
options
.
crop_height
=
bounds
.
height
(
)
;
}
SkISize
dstDimensions
=
dstInfo
.
dimensions
(
)
;
if
(
bounds
.
size
(
)
!
=
dstDimensions
)
{
config
.
options
.
use_scaling
=
1
;
config
.
options
.
scaled_width
=
dstDimensions
.
width
(
)
;
config
.
options
.
scaled_height
=
dstDimensions
.
height
(
)
;
}
config
.
output
.
colorspace
=
webp_decode_mode
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
=
=
kPremul_SkAlphaType
)
;
config
.
output
.
u
.
RGBA
.
rgba
=
(
uint8_t
*
)
dst
;
config
.
output
.
u
.
RGBA
.
stride
=
(
int
)
rowBytes
;
config
.
output
.
u
.
RGBA
.
size
=
dstInfo
.
getSafeSize
(
rowBytes
)
;
config
.
output
.
is_external_memory
=
1
;
SkAutoTCallVProc
<
WebPIDecoder
WebPIDelete
>
idec
(
WebPIDecode
(
nullptr
0
&
config
)
)
;
if
(
!
idec
)
{
return
kInvalidInput
;
}
SkAutoMalloc
storage
(
BUFFER_SIZE
)
;
uint8_t
*
buffer
=
static_cast
<
uint8_t
*
>
(
storage
.
get
(
)
)
;
while
(
true
)
{
const
size_t
bytesRead
=
stream
(
)
-
>
read
(
buffer
BUFFER_SIZE
)
;
if
(
0
=
=
bytesRead
)
{
WebPIDecGetRGB
(
idec
rowsDecoded
NULL
NULL
NULL
)
;
return
kIncompleteInput
;
}
switch
(
WebPIAppend
(
idec
buffer
bytesRead
)
)
{
case
VP8_STATUS_OK
:
return
kSuccess
;
case
VP8_STATUS_SUSPENDED
:
break
;
default
:
return
kInvalidInput
;
}
}
}
SkWebpCodec
:
:
SkWebpCodec
(
const
SkImageInfo
&
info
SkStream
*
stream
)
:
INHERITED
(
info
stream
)
{
}
