#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorSpaceXform
.
h
"
#
include
"
SkSampler
.
h
"
#
include
"
SkStreamPriv
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkWebpCodec
.
h
"
#
include
"
webp
/
decode
.
h
"
#
include
"
webp
/
demux
.
h
"
#
include
"
webp
/
encode
.
h
"
bool
SkWebpCodec
:
:
IsWebp
(
const
void
*
buf
size_t
bytesRead
)
{
const
char
*
bytes
=
static_cast
<
const
char
*
>
(
buf
)
;
return
bytesRead
>
=
14
&
&
!
memcmp
(
bytes
"
RIFF
"
4
)
&
&
!
memcmp
(
&
bytes
[
8
]
"
WEBPVP
"
6
)
;
}
SkCodec
*
SkWebpCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
std
:
:
unique_ptr
<
SkStream
>
streamDeleter
(
stream
)
;
sk_sp
<
SkData
>
data
=
nullptr
;
if
(
stream
-
>
getMemoryBase
(
)
)
{
data
=
SkData
:
:
MakeWithoutCopy
(
stream
-
>
getMemoryBase
(
)
stream
-
>
getLength
(
)
)
;
}
else
{
data
=
SkCopyStreamToData
(
stream
)
;
streamDeleter
.
reset
(
nullptr
)
;
}
WebPData
webpData
=
{
data
-
>
bytes
(
)
data
-
>
size
(
)
}
;
SkAutoTCallVProc
<
WebPDemuxer
WebPDemuxDelete
>
demux
(
WebPDemuxPartial
(
&
webpData
nullptr
)
)
;
if
(
nullptr
=
=
demux
)
{
return
nullptr
;
}
const
int
width
=
WebPDemuxGetI
(
demux
WEBP_FF_CANVAS_WIDTH
)
;
const
int
height
=
WebPDemuxGetI
(
demux
WEBP_FF_CANVAS_HEIGHT
)
;
{
const
int64_t
size
=
sk_64_mul
(
width
height
)
;
if
(
!
sk_64_isS32
(
size
)
)
{
return
nullptr
;
}
if
(
sk_64_asS32
(
size
)
>
(
0x7FFFFFFF
>
>
2
)
)
{
return
nullptr
;
}
}
WebPChunkIterator
chunkIterator
;
SkAutoTCallVProc
<
WebPChunkIterator
WebPDemuxReleaseChunkIterator
>
autoCI
(
&
chunkIterator
)
;
sk_sp
<
SkColorSpace
>
colorSpace
=
nullptr
;
bool
unsupportedICC
=
false
;
if
(
WebPDemuxGetChunk
(
demux
"
ICCP
"
1
&
chunkIterator
)
)
{
colorSpace
=
SkColorSpace
:
:
MakeICC
(
chunkIterator
.
chunk
.
bytes
chunkIterator
.
chunk
.
size
)
;
if
(
!
colorSpace
)
{
unsupportedICC
=
true
;
}
}
if
(
!
colorSpace
)
{
colorSpace
=
SkColorSpace
:
:
MakeSRGB
(
)
;
}
WebPIterator
frame
;
SkAutoTCallVProc
<
WebPIterator
WebPDemuxReleaseIterator
>
autoFrame
(
&
frame
)
;
if
(
!
WebPDemuxGetFrame
(
demux
1
&
frame
)
)
{
return
nullptr
;
}
WebPBitstreamFeatures
features
;
VP8StatusCode
status
=
WebPGetFeatures
(
frame
.
fragment
.
bytes
frame
.
fragment
.
size
&
features
)
;
if
(
VP8_STATUS_OK
!
=
status
)
{
return
nullptr
;
}
SkEncodedInfo
:
:
Color
color
;
SkEncodedInfo
:
:
Alpha
alpha
;
switch
(
features
.
format
)
{
case
0
:
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
case
1
:
if
(
SkToBool
(
features
.
has_alpha
)
|
|
frame
.
width
!
=
width
|
|
frame
.
height
!
=
height
)
{
color
=
SkEncodedInfo
:
:
kYUVA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
}
else
{
color
=
SkEncodedInfo
:
:
kYUV_Color
;
alpha
=
SkEncodedInfo
:
:
kOpaque_Alpha
;
}
break
;
case
2
:
color
=
SkEncodedInfo
:
:
kBGRA_Color
;
alpha
=
SkEncodedInfo
:
:
kUnpremul_Alpha
;
break
;
default
:
return
nullptr
;
}
SkEncodedInfo
info
=
SkEncodedInfo
:
:
Make
(
color
alpha
8
)
;
SkWebpCodec
*
codecOut
=
new
SkWebpCodec
(
width
height
info
std
:
:
move
(
colorSpace
)
streamDeleter
.
release
(
)
demux
.
release
(
)
std
:
:
move
(
data
)
)
;
codecOut
-
>
setUnsupportedICC
(
unsupportedICC
)
;
return
codecOut
;
}
SkISize
SkWebpCodec
:
:
onGetScaledDimensions
(
float
desiredScale
)
const
{
SkISize
dim
=
this
-
>
getInfo
(
)
.
dimensions
(
)
;
dim
.
fWidth
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fWidth
)
)
;
dim
.
fHeight
=
SkTMax
(
1
SkScalarRoundToInt
(
desiredScale
*
dim
.
fHeight
)
)
;
return
dim
;
}
bool
SkWebpCodec
:
:
onDimensionsSupported
(
const
SkISize
&
dim
)
{
const
SkImageInfo
&
info
=
this
-
>
getInfo
(
)
;
return
dim
.
width
(
)
>
=
1
&
&
dim
.
width
(
)
<
=
info
.
width
(
)
&
&
dim
.
height
(
)
>
=
1
&
&
dim
.
height
(
)
<
=
info
.
height
(
)
;
}
static
WEBP_CSP_MODE
webp_decode_mode
(
SkColorType
ct
bool
premultiply
)
{
switch
(
ct
)
{
case
kBGRA_8888_SkColorType
:
return
premultiply
?
MODE_bgrA
:
MODE_BGRA
;
case
kRGBA_8888_SkColorType
:
return
premultiply
?
MODE_rgbA
:
MODE_RGBA
;
case
kRGB_565_SkColorType
:
return
MODE_RGB_565
;
default
:
return
MODE_LAST
;
}
}
bool
SkWebpCodec
:
:
onGetValidSubset
(
SkIRect
*
desiredSubset
)
const
{
if
(
!
desiredSubset
)
{
return
false
;
}
SkIRect
dimensions
=
SkIRect
:
:
MakeSize
(
this
-
>
getInfo
(
)
.
dimensions
(
)
)
;
if
(
!
dimensions
.
contains
(
*
desiredSubset
)
)
{
return
false
;
}
desiredSubset
-
>
fLeft
=
(
desiredSubset
-
>
fLeft
>
>
1
)
<
<
1
;
desiredSubset
-
>
fTop
=
(
desiredSubset
-
>
fTop
>
>
1
)
<
<
1
;
return
true
;
}
SkCodec
:
:
Result
SkWebpCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
Options
&
options
SkPMColor
*
int
*
int
*
rowsDecodedPtr
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
|
|
!
this
-
>
initializeColorXform
(
dstInfo
options
.
fPremulBehavior
)
)
{
return
kInvalidConversion
;
}
WebPDecoderConfig
config
;
if
(
0
=
=
WebPInitDecoderConfig
(
&
config
)
)
{
return
kInvalidInput
;
}
SkAutoTCallVProc
<
WebPDecBuffer
WebPFreeDecBuffer
>
autoFree
(
&
(
config
.
output
)
)
;
WebPIterator
frame
;
SkAutoTCallVProc
<
WebPIterator
WebPDemuxReleaseIterator
>
autoFrame
(
&
frame
)
;
SkAssertResult
(
WebPDemuxGetFrame
(
fDemux
1
&
frame
)
)
;
auto
frameRect
=
SkIRect
:
:
MakeXYWH
(
frame
.
x_offset
frame
.
y_offset
frame
.
width
frame
.
height
)
;
SkASSERT
(
this
-
>
getInfo
(
)
.
bounds
(
)
.
contains
(
frameRect
)
)
;
bool
frameIsSubset
=
frameRect
.
size
(
)
!
=
this
-
>
getInfo
(
)
.
dimensions
(
)
;
if
(
frameIsSubset
)
{
SkSampler
:
:
Fill
(
dstInfo
dst
rowBytes
0
options
.
fZeroInitialized
)
;
}
int
dstX
=
frameRect
.
x
(
)
;
int
dstY
=
frameRect
.
y
(
)
;
int
subsetWidth
=
frameRect
.
width
(
)
;
int
subsetHeight
=
frameRect
.
height
(
)
;
if
(
options
.
fSubset
)
{
SkIRect
subset
=
*
options
.
fSubset
;
SkASSERT
(
this
-
>
getInfo
(
)
.
bounds
(
)
.
contains
(
subset
)
)
;
SkASSERT
(
SkIsAlign2
(
subset
.
fLeft
)
&
&
SkIsAlign2
(
subset
.
fTop
)
)
;
SkASSERT
(
this
-
>
getValidSubset
(
&
subset
)
&
&
subset
=
=
*
options
.
fSubset
)
;
if
(
!
SkIRect
:
:
IntersectsNoEmptyCheck
(
subset
frameRect
)
)
{
return
kSuccess
;
}
int
minXOffset
=
SkTMin
(
dstX
subset
.
x
(
)
)
;
int
minYOffset
=
SkTMin
(
dstY
subset
.
y
(
)
)
;
dstX
-
=
minXOffset
;
dstY
-
=
minYOffset
;
frameRect
.
offset
(
-
minXOffset
-
minYOffset
)
;
subset
.
offset
(
-
minXOffset
-
minYOffset
)
;
SkASSERT
(
SkIsAlign2
(
subset
.
fLeft
)
&
&
SkIsAlign2
(
subset
.
fTop
)
)
;
SkIRect
intersection
;
SkAssertResult
(
intersection
.
intersect
(
frameRect
subset
)
)
;
subsetWidth
=
intersection
.
width
(
)
;
subsetHeight
=
intersection
.
height
(
)
;
config
.
options
.
use_cropping
=
1
;
config
.
options
.
crop_left
=
subset
.
x
(
)
;
config
.
options
.
crop_top
=
subset
.
y
(
)
;
config
.
options
.
crop_width
=
subsetWidth
;
config
.
options
.
crop_height
=
subsetHeight
;
}
int
scaledWidth
=
subsetWidth
;
int
scaledHeight
=
subsetHeight
;
SkISize
srcSize
=
options
.
fSubset
?
options
.
fSubset
-
>
size
(
)
:
this
-
>
getInfo
(
)
.
dimensions
(
)
;
if
(
srcSize
!
=
dstInfo
.
dimensions
(
)
)
{
config
.
options
.
use_scaling
=
1
;
if
(
frameIsSubset
)
{
float
scaleX
=
(
(
float
)
dstInfo
.
width
(
)
)
/
srcSize
.
width
(
)
;
float
scaleY
=
(
(
float
)
dstInfo
.
height
(
)
)
/
srcSize
.
height
(
)
;
dstX
=
scaleX
*
dstX
;
scaledWidth
=
scaleX
*
scaledWidth
;
dstY
=
scaleY
*
dstY
;
scaledHeight
=
scaleY
*
scaledHeight
;
if
(
0
=
=
scaledWidth
|
|
0
=
=
scaledHeight
)
{
return
kSuccess
;
}
}
else
{
scaledWidth
=
dstInfo
.
width
(
)
;
scaledHeight
=
dstInfo
.
height
(
)
;
}
config
.
options
.
scaled_width
=
scaledWidth
;
config
.
options
.
scaled_height
=
scaledHeight
;
}
config
.
output
.
colorspace
=
this
-
>
colorXform
(
)
?
MODE_BGRA
:
webp_decode_mode
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
=
=
kPremul_SkAlphaType
)
;
config
.
output
.
is_external_memory
=
1
;
SkAutoTMalloc
<
uint32_t
>
pixels
;
bool
needsCopy
=
this
-
>
colorXform
(
)
&
&
kRGBA_8888_SkColorType
!
=
dstInfo
.
colorType
(
)
&
&
kBGRA_8888_SkColorType
!
=
dstInfo
.
colorType
(
)
;
void
*
webpDst
=
needsCopy
?
pixels
.
reset
(
dstInfo
.
width
(
)
*
dstInfo
.
height
(
)
)
:
dst
;
size_t
webpRowBytes
=
needsCopy
?
dstInfo
.
width
(
)
*
sizeof
(
uint32_t
)
:
rowBytes
;
size_t
totalBytes
=
needsCopy
?
webpRowBytes
*
dstInfo
.
height
(
)
:
dstInfo
.
getSafeSize
(
webpRowBytes
)
;
size_t
dstBpp
=
SkColorTypeBytesPerPixel
(
dstInfo
.
colorType
(
)
)
;
size_t
webpBpp
=
needsCopy
?
sizeof
(
uint32_t
)
:
dstBpp
;
size_t
offset
=
dstX
*
webpBpp
+
dstY
*
webpRowBytes
;
config
.
output
.
u
.
RGBA
.
rgba
=
SkTAddOffset
<
uint8_t
>
(
webpDst
offset
)
;
config
.
output
.
u
.
RGBA
.
stride
=
(
int
)
webpRowBytes
;
config
.
output
.
u
.
RGBA
.
size
=
totalBytes
-
offset
;
SkAutoTCallVProc
<
WebPIDecoder
WebPIDelete
>
idec
(
WebPIDecode
(
nullptr
0
&
config
)
)
;
if
(
!
idec
)
{
return
kInvalidInput
;
}
int
rowsDecoded
;
SkCodec
:
:
Result
result
;
switch
(
WebPIUpdate
(
idec
frame
.
fragment
.
bytes
frame
.
fragment
.
size
)
)
{
case
VP8_STATUS_OK
:
rowsDecoded
=
scaledHeight
;
result
=
kSuccess
;
break
;
case
VP8_STATUS_SUSPENDED
:
WebPIDecGetRGB
(
idec
&
rowsDecoded
nullptr
nullptr
nullptr
)
;
*
rowsDecodedPtr
=
rowsDecoded
+
dstY
;
result
=
kIncompleteInput
;
break
;
default
:
return
kInvalidInput
;
}
if
(
this
-
>
colorXform
(
)
)
{
SkColorSpaceXform
:
:
ColorFormat
dstColorFormat
=
select_xform_format
(
dstInfo
.
colorType
(
)
)
;
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
uint32_t
*
xformSrc
=
(
uint32_t
*
)
config
.
output
.
u
.
RGBA
.
rgba
;
void
*
xformDst
=
SkTAddOffset
<
void
>
(
dst
dstBpp
*
dstX
+
rowBytes
*
dstY
)
;
size_t
srcRowBytes
=
config
.
output
.
u
.
RGBA
.
stride
;
for
(
int
y
=
0
;
y
<
rowsDecoded
;
y
+
+
)
{
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
dstColorFormat
xformDst
SkColorSpaceXform
:
:
kBGRA_8888_ColorFormat
xformSrc
scaledWidth
xformAlphaType
)
)
;
xformDst
=
SkTAddOffset
<
void
>
(
xformDst
rowBytes
)
;
xformSrc
=
SkTAddOffset
<
uint32_t
>
(
xformSrc
srcRowBytes
)
;
}
}
return
result
;
}
SkWebpCodec
:
:
SkWebpCodec
(
int
width
int
height
const
SkEncodedInfo
&
info
sk_sp
<
SkColorSpace
>
colorSpace
SkStream
*
stream
WebPDemuxer
*
demux
sk_sp
<
SkData
>
data
)
:
INHERITED
(
width
height
info
stream
std
:
:
move
(
colorSpace
)
)
fDemux
(
demux
)
fData
(
std
:
:
move
(
data
)
)
{
}
