#
include
"
SkCodecAnimation
.
h
"
#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkGifCodec
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
<
algorithm
>
#
define
GIF87_STAMP
"
GIF87a
"
#
define
GIF89_STAMP
"
GIF89a
"
#
define
GIF_STAMP_LEN
6
bool
SkGifCodec
:
:
IsGif
(
const
void
*
buf
size_t
bytesRead
)
{
if
(
bytesRead
>
=
GIF_STAMP_LEN
)
{
if
(
memcmp
(
GIF87_STAMP
buf
GIF_STAMP_LEN
)
=
=
0
|
|
memcmp
(
GIF89_STAMP
buf
GIF_STAMP_LEN
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
SkCodec
:
:
Result
gif_error
(
const
char
*
msg
SkCodec
:
:
Result
result
=
SkCodec
:
:
kInvalidInput
)
{
SkCodecPrintf
(
"
Gif
Error
:
%
s
\
n
"
msg
)
;
return
result
;
}
SkCodec
*
SkGifCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
std
:
:
unique_ptr
<
SkGifImageReader
>
reader
(
new
SkGifImageReader
(
stream
)
)
;
if
(
!
reader
-
>
parse
(
SkGifImageReader
:
:
SkGIFSizeQuery
)
)
{
return
nullptr
;
}
if
(
0
=
=
reader
-
>
imagesCount
(
)
|
|
!
reader
-
>
frameContext
(
0
)
-
>
isHeaderDefined
(
)
)
{
return
nullptr
;
}
SkASSERT
(
reader
-
>
screenHeight
(
)
>
0
&
&
reader
-
>
screenWidth
(
)
>
0
)
;
const
auto
alpha
=
reader
-
>
firstFrameHasAlpha
(
)
?
SkEncodedInfo
:
:
kBinary_Alpha
:
SkEncodedInfo
:
:
kOpaque_Alpha
;
const
auto
encodedInfo
=
SkEncodedInfo
:
:
Make
(
SkEncodedInfo
:
:
kPalette_Color
alpha
8
)
;
const
auto
colorType
=
reader
-
>
firstFrameSupportsIndex8
(
)
?
kIndex_8_SkColorType
:
kN32_SkColorType
;
const
auto
alphaType
=
reader
-
>
firstFrameHasAlpha
(
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
;
const
auto
imageInfo
=
SkImageInfo
:
:
Make
(
reader
-
>
screenWidth
(
)
reader
-
>
screenHeight
(
)
colorType
alphaType
SkColorSpace
:
:
MakeSRGB
(
)
)
;
return
new
SkGifCodec
(
encodedInfo
imageInfo
reader
.
release
(
)
)
;
}
bool
SkGifCodec
:
:
onRewind
(
)
{
fReader
-
>
clearDecodeState
(
)
;
return
true
;
}
SkGifCodec
:
:
SkGifCodec
(
const
SkEncodedInfo
&
encodedInfo
const
SkImageInfo
&
imageInfo
SkGifImageReader
*
reader
)
:
INHERITED
(
encodedInfo
imageInfo
nullptr
)
fReader
(
reader
)
fTmpBuffer
(
nullptr
)
fSwizzler
(
nullptr
)
fCurrColorTable
(
nullptr
)
fCurrColorTableIsReal
(
false
)
fFilledBackground
(
false
)
fFirstCallToIncrementalDecode
(
false
)
fDst
(
nullptr
)
fDstRowBytes
(
0
)
fRowsDecoded
(
0
)
{
reader
-
>
setClient
(
this
)
;
}
size_t
SkGifCodec
:
:
onGetFrameCount
(
)
{
fReader
-
>
parse
(
SkGifImageReader
:
:
SkGIFFrameCountQuery
)
;
return
fReader
-
>
imagesCount
(
)
;
}
bool
SkGifCodec
:
:
onGetFrameInfo
(
size_t
i
SkCodec
:
:
FrameInfo
*
frameInfo
)
const
{
if
(
i
>
=
fReader
-
>
imagesCount
(
)
)
{
return
false
;
}
const
SkGIFFrameContext
*
frameContext
=
fReader
-
>
frameContext
(
i
)
;
if
(
!
frameContext
-
>
reachedStartOfData
(
)
)
{
return
false
;
}
if
(
frameInfo
)
{
frameInfo
-
>
fDuration
=
frameContext
-
>
delayTime
(
)
;
frameInfo
-
>
fRequiredFrame
=
frameContext
-
>
getRequiredFrame
(
)
;
frameInfo
-
>
fFullyReceived
=
frameContext
-
>
isComplete
(
)
;
frameInfo
-
>
fAlphaType
=
frameContext
-
>
hasAlpha
(
)
?
kUnpremul_SkAlphaType
:
kOpaque_SkAlphaType
;
}
return
true
;
}
int
SkGifCodec
:
:
onGetRepetitionCount
(
)
{
fReader
-
>
parse
(
SkGifImageReader
:
:
SkGIFLoopCountQuery
)
;
return
fReader
-
>
loopCount
(
)
;
}
static
const
SkColorType
kXformSrcColorType
=
kRGBA_8888_SkColorType
;
void
SkGifCodec
:
:
initializeColorTable
(
const
SkImageInfo
&
dstInfo
size_t
frameIndex
)
{
SkColorType
colorTableColorType
=
dstInfo
.
colorType
(
)
;
if
(
this
-
>
colorXform
(
)
)
{
colorTableColorType
=
kXformSrcColorType
;
}
sk_sp
<
SkColorTable
>
currColorTable
=
fReader
-
>
getColorTable
(
colorTableColorType
frameIndex
)
;
fCurrColorTableIsReal
=
currColorTable
;
if
(
!
fCurrColorTableIsReal
)
{
SkPMColor
color
=
SK_ColorTRANSPARENT
;
fCurrColorTable
.
reset
(
new
SkColorTable
(
&
color
1
)
)
;
}
else
if
(
this
-
>
colorXform
(
)
&
&
!
fXformOnDecode
)
{
SkPMColor
dstColors
[
256
]
;
const
SkColorSpaceXform
:
:
ColorFormat
dstFormat
=
select_xform_format_ct
(
dstInfo
.
colorType
(
)
)
;
const
SkColorSpaceXform
:
:
ColorFormat
srcFormat
=
select_xform_format
(
kXformSrcColorType
)
;
const
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
dstFormat
dstColors
srcFormat
currColorTable
-
>
readColors
(
)
currColorTable
-
>
count
(
)
xformAlphaType
)
)
;
fCurrColorTable
.
reset
(
new
SkColorTable
(
dstColors
currColorTable
-
>
count
(
)
)
)
;
}
else
{
fCurrColorTable
=
std
:
:
move
(
currColorTable
)
;
}
}
SkCodec
:
:
Result
SkGifCodec
:
:
prepareToDecode
(
const
SkImageInfo
&
dstInfo
SkPMColor
*
inputColorPtr
int
*
inputColorCount
const
Options
&
opts
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
|
|
!
this
-
>
initializeColorXform
(
dstInfo
opts
.
fPremulBehavior
)
)
{
return
gif_error
(
"
Cannot
convert
input
type
to
output
type
.
\
n
"
kInvalidConversion
)
;
}
fXformOnDecode
=
false
;
if
(
this
-
>
colorXform
(
)
)
{
fXformOnDecode
=
apply_xform_on_decode
(
dstInfo
.
colorType
(
)
this
-
>
getEncodedInfo
(
)
.
color
(
)
)
;
if
(
fXformOnDecode
)
{
fXformBuffer
.
reset
(
new
uint32_t
[
dstInfo
.
width
(
)
]
)
;
sk_bzero
(
fXformBuffer
.
get
(
)
dstInfo
.
width
(
)
*
sizeof
(
uint32_t
)
)
;
}
}
if
(
opts
.
fSubset
)
{
return
gif_error
(
"
Subsets
not
supported
.
\
n
"
kUnimplemented
)
;
}
const
size_t
frameIndex
=
opts
.
fFrameIndex
;
if
(
frameIndex
>
0
)
{
switch
(
dstInfo
.
colorType
(
)
)
{
case
kIndex_8_SkColorType
:
return
gif_error
(
"
Cannot
decode
multiframe
gif
(
except
frame
0
)
as
index
8
.
\
n
"
kInvalidConversion
)
;
case
kRGB_565_SkColorType
:
return
gif_error
(
"
Cannot
decode
multiframe
gif
(
except
frame
0
)
as
565
.
\
n
"
kInvalidConversion
)
;
default
:
break
;
}
}
fReader
-
>
parse
(
(
SkGifImageReader
:
:
SkGIFParseQuery
)
frameIndex
)
;
if
(
frameIndex
>
=
fReader
-
>
imagesCount
(
)
)
{
return
gif_error
(
"
frame
index
out
of
range
!
\
n
"
kIncompleteInput
)
;
}
if
(
!
fReader
-
>
frameContext
(
frameIndex
)
-
>
reachedStartOfData
(
)
)
{
return
gif_error
(
"
color
map
not
available
yet
\
n
"
kIncompleteInput
)
;
}
fTmpBuffer
.
reset
(
new
uint8_t
[
dstInfo
.
minRowBytes
(
)
]
)
;
this
-
>
initializeColorTable
(
dstInfo
frameIndex
)
;
this
-
>
initializeSwizzler
(
dstInfo
frameIndex
)
;
SkASSERT
(
fCurrColorTable
)
;
if
(
inputColorCount
)
{
*
inputColorCount
=
fCurrColorTable
-
>
count
(
)
;
}
copy_color_table
(
dstInfo
fCurrColorTable
.
get
(
)
inputColorPtr
inputColorCount
)
;
return
kSuccess
;
}
void
SkGifCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
size_t
frameIndex
)
{
const
SkGIFFrameContext
*
frame
=
fReader
-
>
frameContext
(
frameIndex
)
;
SkASSERT
(
frame
)
;
const
int
xBegin
=
frame
-
>
xOffset
(
)
;
const
int
xEnd
=
std
:
:
min
(
static_cast
<
int
>
(
frame
-
>
xOffset
(
)
+
frame
-
>
width
(
)
)
static_cast
<
int
>
(
fReader
-
>
screenWidth
(
)
)
)
;
SkIRect
swizzleRect
=
SkIRect
:
:
MakeLTRB
(
xBegin
0
xEnd
0
)
;
SkImageInfo
swizzlerInfo
=
dstInfo
;
if
(
this
-
>
colorXform
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeColorType
(
kXformSrcColorType
)
;
if
(
kPremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
swizzlerInfo
=
swizzlerInfo
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
}
}
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
this
-
>
getEncodedInfo
(
)
fCurrColorTable
-
>
readColors
(
)
swizzlerInfo
Options
(
)
&
swizzleRect
)
)
;
SkASSERT
(
fSwizzler
.
get
(
)
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
pixels
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
int
*
rowsDecoded
)
{
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
inputColorPtr
inputColorCount
opts
)
;
switch
(
result
)
{
case
kSuccess
:
break
;
case
kIncompleteInput
:
return
kInvalidInput
;
default
:
return
result
;
}
if
(
dstInfo
.
dimensions
(
)
!
=
this
-
>
getInfo
(
)
.
dimensions
(
)
)
{
return
gif_error
(
"
Scaling
not
supported
.
\
n
"
kInvalidScale
)
;
}
fDst
=
pixels
;
fDstRowBytes
=
dstRowBytes
;
return
this
-
>
decodeFrame
(
true
opts
rowsDecoded
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
onStartIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
pixels
size_t
dstRowBytes
const
SkCodec
:
:
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
)
{
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
inputColorPtr
inputColorCount
opts
)
;
if
(
result
!
=
kSuccess
)
{
return
result
;
}
fDst
=
pixels
;
fDstRowBytes
=
dstRowBytes
;
fFirstCallToIncrementalDecode
=
true
;
return
kSuccess
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
onIncrementalDecode
(
int
*
rowsDecoded
)
{
const
auto
&
options
=
this
-
>
options
(
)
;
const
size_t
frameIndex
=
options
.
fFrameIndex
;
fReader
-
>
parse
(
(
SkGifImageReader
:
:
SkGIFParseQuery
)
frameIndex
)
;
const
bool
firstCallToIncrementalDecode
=
fFirstCallToIncrementalDecode
;
fFirstCallToIncrementalDecode
=
false
;
return
this
-
>
decodeFrame
(
firstCallToIncrementalDecode
options
rowsDecoded
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
decodeFrame
(
bool
firstAttempt
const
Options
&
opts
int
*
rowsDecoded
)
{
const
SkImageInfo
&
dstInfo
=
this
-
>
dstInfo
(
)
;
const
size_t
frameIndex
=
opts
.
fFrameIndex
;
SkASSERT
(
frameIndex
<
fReader
-
>
imagesCount
(
)
)
;
const
SkGIFFrameContext
*
frameContext
=
fReader
-
>
frameContext
(
frameIndex
)
;
if
(
firstAttempt
)
{
bool
filledBackground
=
false
;
if
(
frameContext
-
>
getRequiredFrame
(
)
=
=
kNone
)
{
if
(
frameContext
-
>
frameRect
(
)
!
=
this
-
>
getInfo
(
)
.
bounds
(
)
|
|
frameContext
-
>
interlaced
(
)
|
|
!
fCurrColorTableIsReal
)
{
const
int
scaledHeight
=
get_scaled_dimension
(
dstInfo
.
height
(
)
fSwizzler
-
>
sampleY
(
)
)
;
auto
fillInfo
=
dstInfo
.
makeWH
(
0
scaledHeight
)
;
fSwizzler
-
>
fill
(
fillInfo
fDst
fDstRowBytes
this
-
>
getFillValue
(
dstInfo
)
opts
.
fZeroInitialized
)
;
filledBackground
=
true
;
}
}
else
{
if
(
!
opts
.
fHasPriorFrame
)
{
Options
prevFrameOpts
(
opts
)
;
prevFrameOpts
.
fFrameIndex
=
frameContext
-
>
getRequiredFrame
(
)
;
prevFrameOpts
.
fHasPriorFrame
=
false
;
this
-
>
initializeColorTable
(
dstInfo
prevFrameOpts
.
fFrameIndex
)
;
this
-
>
initializeSwizzler
(
dstInfo
prevFrameOpts
.
fFrameIndex
)
;
const
Result
prevResult
=
this
-
>
decodeFrame
(
true
prevFrameOpts
nullptr
)
;
switch
(
prevResult
)
{
case
kSuccess
:
break
;
case
kIncompleteInput
:
return
kInvalidInput
;
default
:
return
prevResult
;
}
this
-
>
initializeColorTable
(
dstInfo
frameIndex
)
;
this
-
>
initializeSwizzler
(
dstInfo
frameIndex
)
;
}
const
auto
*
prevFrame
=
fReader
-
>
frameContext
(
frameContext
-
>
getRequiredFrame
(
)
)
;
if
(
prevFrame
-
>
getDisposalMethod
(
)
=
=
SkCodecAnimation
:
:
RestoreBGColor_DisposalMethod
)
{
SkIRect
prevRect
=
prevFrame
-
>
frameRect
(
)
;
if
(
prevRect
.
intersect
(
this
-
>
getInfo
(
)
.
bounds
(
)
)
)
{
auto
left
=
prevRect
.
fLeft
/
fSwizzler
-
>
sampleX
(
)
;
auto
top
=
prevRect
.
fTop
/
fSwizzler
-
>
sampleY
(
)
;
void
*
const
eraseDst
=
SkTAddOffset
<
void
>
(
fDst
top
*
fDstRowBytes
+
left
*
SkColorTypeBytesPerPixel
(
dstInfo
.
colorType
(
)
)
)
;
auto
width
=
get_scaled_dimension
(
prevRect
.
width
(
)
fSwizzler
-
>
sampleX
(
)
)
;
auto
height
=
get_scaled_dimension
(
prevRect
.
height
(
)
fSwizzler
-
>
sampleY
(
)
)
;
SkSampler
:
:
Fill
(
dstInfo
.
makeWH
(
width
height
)
eraseDst
fDstRowBytes
this
-
>
getFillValue
(
dstInfo
)
kNo_ZeroInitialized
)
;
}
}
filledBackground
=
true
;
}
fFilledBackground
=
filledBackground
;
if
(
filledBackground
)
{
fRowsDecoded
=
get_scaled_dimension
(
dstInfo
.
height
(
)
fSwizzler
-
>
sampleY
(
)
)
;
}
else
{
fRowsDecoded
=
0
;
}
}
if
(
!
fCurrColorTableIsReal
)
{
return
kSuccess
;
}
bool
frameDecoded
=
false
;
if
(
!
fReader
-
>
decode
(
frameIndex
&
frameDecoded
)
|
|
!
frameDecoded
)
{
if
(
rowsDecoded
)
{
*
rowsDecoded
=
fRowsDecoded
;
}
return
kIncompleteInput
;
}
return
kSuccess
;
}
uint64_t
SkGifCodec
:
:
onGetFillValue
(
const
SkImageInfo
&
dstInfo
)
const
{
if
(
dstInfo
.
colorType
(
)
=
=
kIndex_8_SkColorType
&
&
fCurrColorTableIsReal
)
{
SkASSERT
(
this
-
>
options
(
)
.
fFrameIndex
=
=
0
)
;
const
size_t
transPixel
=
fReader
-
>
frameContext
(
0
)
-
>
transparentPixel
(
)
;
if
(
transPixel
<
(
size_t
)
fCurrColorTable
-
>
count
(
)
)
{
return
transPixel
;
}
}
return
SK_ColorTRANSPARENT
;
}
void
SkGifCodec
:
:
applyXformRow
(
const
SkImageInfo
&
dstInfo
void
*
dst
const
uint8_t
*
src
)
const
{
if
(
this
-
>
colorXform
(
)
&
&
fXformOnDecode
)
{
fSwizzler
-
>
swizzle
(
fXformBuffer
.
get
(
)
src
)
;
const
SkColorSpaceXform
:
:
ColorFormat
dstFormat
=
select_xform_format
(
dstInfo
.
colorType
(
)
)
;
const
SkColorSpaceXform
:
:
ColorFormat
srcFormat
=
select_xform_format
(
kXformSrcColorType
)
;
const
SkAlphaType
xformAlphaType
=
select_xform_alpha
(
dstInfo
.
alphaType
(
)
this
-
>
getInfo
(
)
.
alphaType
(
)
)
;
const
int
xformWidth
=
get_scaled_dimension
(
dstInfo
.
width
(
)
fSwizzler
-
>
sampleX
(
)
)
;
SkAssertResult
(
this
-
>
colorXform
(
)
-
>
apply
(
dstFormat
dst
srcFormat
fXformBuffer
.
get
(
)
xformWidth
xformAlphaType
)
)
;
}
else
{
fSwizzler
-
>
swizzle
(
dst
src
)
;
}
}
bool
SkGifCodec
:
:
haveDecodedRow
(
size_t
frameIndex
const
unsigned
char
*
rowBegin
size_t
rowNumber
unsigned
repeatCount
bool
writeTransparentPixels
)
{
const
SkGIFFrameContext
*
frameContext
=
fReader
-
>
frameContext
(
frameIndex
)
;
const
size_t
width
=
frameContext
-
>
width
(
)
;
const
int
xBegin
=
frameContext
-
>
xOffset
(
)
;
const
int
yBegin
=
frameContext
-
>
yOffset
(
)
+
rowNumber
;
const
int
xEnd
=
std
:
:
min
(
static_cast
<
int
>
(
frameContext
-
>
xOffset
(
)
+
width
)
this
-
>
getInfo
(
)
.
width
(
)
)
;
const
int
yEnd
=
std
:
:
min
(
static_cast
<
int
>
(
frameContext
-
>
yOffset
(
)
+
rowNumber
+
repeatCount
)
this
-
>
getInfo
(
)
.
height
(
)
)
;
if
(
!
width
|
|
(
xBegin
<
0
)
|
|
(
yBegin
<
0
)
|
|
(
xEnd
<
=
xBegin
)
|
|
(
yEnd
<
=
yBegin
)
)
return
true
;
int
dstRow
=
yBegin
;
const
int
sampleY
=
fSwizzler
-
>
sampleY
(
)
;
if
(
sampleY
>
1
)
{
bool
foundNecessaryRow
=
false
;
for
(
unsigned
i
=
0
;
i
<
repeatCount
;
i
+
+
)
{
const
int
potentialRow
=
yBegin
+
i
;
if
(
fSwizzler
-
>
rowNeeded
(
potentialRow
)
)
{
dstRow
=
potentialRow
/
sampleY
;
const
int
scaledHeight
=
get_scaled_dimension
(
this
-
>
dstInfo
(
)
.
height
(
)
sampleY
)
;
if
(
dstRow
>
=
scaledHeight
)
{
return
true
;
}
foundNecessaryRow
=
true
;
repeatCount
-
=
i
;
repeatCount
=
(
repeatCount
-
1
)
/
sampleY
+
1
;
if
(
dstRow
+
(
int
)
repeatCount
>
scaledHeight
)
{
repeatCount
=
scaledHeight
-
dstRow
;
SkASSERT
(
repeatCount
>
=
1
)
;
}
break
;
}
}
if
(
!
foundNecessaryRow
)
{
return
true
;
}
}
else
{
SkASSERT
(
this
-
>
dstInfo
(
)
.
height
(
)
>
=
yBegin
)
;
repeatCount
=
SkTMin
(
repeatCount
(
unsigned
)
(
this
-
>
dstInfo
(
)
.
height
(
)
-
yBegin
)
)
;
}
if
(
!
fFilledBackground
)
{
fRowsDecoded
+
+
;
}
SkASSERT
(
fCurrColorTableIsReal
)
;
void
*
dstLine
=
SkTAddOffset
<
void
>
(
fDst
dstRow
*
fDstRowBytes
)
;
const
auto
dstInfo
=
this
-
>
dstInfo
(
)
;
if
(
writeTransparentPixels
)
{
this
-
>
applyXformRow
(
dstInfo
dstLine
rowBegin
)
;
}
else
{
sk_bzero
(
fTmpBuffer
.
get
(
)
dstInfo
.
minRowBytes
(
)
)
;
this
-
>
applyXformRow
(
dstInfo
fTmpBuffer
.
get
(
)
rowBegin
)
;
const
size_t
offsetBytes
=
fSwizzler
-
>
swizzleOffsetBytes
(
)
;
switch
(
dstInfo
.
colorType
(
)
)
{
case
kBGRA_8888_SkColorType
:
case
kRGBA_8888_SkColorType
:
{
uint32_t
*
dstPixel
=
SkTAddOffset
<
uint32_t
>
(
dstLine
offsetBytes
)
;
uint32_t
*
srcPixel
=
SkTAddOffset
<
uint32_t
>
(
fTmpBuffer
.
get
(
)
offsetBytes
)
;
for
(
int
i
=
0
;
i
<
fSwizzler
-
>
swizzleWidth
(
)
;
i
+
+
)
{
if
(
*
srcPixel
!
=
SK_ColorTRANSPARENT
)
{
*
dstPixel
=
*
srcPixel
;
}
dstPixel
+
+
;
srcPixel
+
+
;
}
break
;
}
case
kRGBA_F16_SkColorType
:
{
uint64_t
*
dstPixel
=
SkTAddOffset
<
uint64_t
>
(
dstLine
offsetBytes
)
;
uint64_t
*
srcPixel
=
SkTAddOffset
<
uint64_t
>
(
fTmpBuffer
.
get
(
)
offsetBytes
)
;
for
(
int
i
=
0
;
i
<
fSwizzler
-
>
swizzleWidth
(
)
;
i
+
+
)
{
if
(
*
srcPixel
!
=
0
)
{
*
dstPixel
=
*
srcPixel
;
}
dstPixel
+
+
;
srcPixel
+
+
;
}
break
;
}
default
:
SkASSERT
(
false
)
;
break
;
}
}
if
(
repeatCount
>
1
)
{
const
size_t
bytesPerPixel
=
SkColorTypeBytesPerPixel
(
this
-
>
dstInfo
(
)
.
colorType
(
)
)
;
const
size_t
bytesToCopy
=
fSwizzler
-
>
swizzleWidth
(
)
*
bytesPerPixel
;
void
*
copiedLine
=
SkTAddOffset
<
void
>
(
dstLine
fSwizzler
-
>
swizzleOffsetBytes
(
)
)
;
void
*
dst
=
copiedLine
;
for
(
unsigned
i
=
1
;
i
<
repeatCount
;
i
+
+
)
{
dst
=
SkTAddOffset
<
void
>
(
dst
fDstRowBytes
)
;
memcpy
(
dst
copiedLine
bytesToCopy
)
;
}
}
return
true
;
}
