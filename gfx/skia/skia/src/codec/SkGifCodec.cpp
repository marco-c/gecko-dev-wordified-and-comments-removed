#
include
"
SkCodecPriv
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorTable
.
h
"
#
include
"
SkGifCodec
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkSwizzler
.
h
"
#
include
"
SkUtils
.
h
"
bool
SkGifCodec
:
:
IsGif
(
const
void
*
buf
size_t
bytesRead
)
{
if
(
bytesRead
>
=
GIF_STAMP_LEN
)
{
if
(
memcmp
(
GIF_STAMP
buf
GIF_STAMP_LEN
)
=
=
0
|
|
memcmp
(
GIF87_STAMP
buf
GIF_STAMP_LEN
)
=
=
0
|
|
memcmp
(
GIF89_STAMP
buf
GIF_STAMP_LEN
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
SkCodec
:
:
Result
gif_error
(
const
char
*
msg
SkCodec
:
:
Result
result
=
SkCodec
:
:
kInvalidInput
)
{
SkCodecPrintf
(
"
Gif
Error
:
%
s
\
n
"
msg
)
;
return
result
;
}
static
int32_t
read_bytes_callback
(
GifFileType
*
fileType
GifByteType
*
out
int32_t
size
)
{
SkStream
*
stream
=
(
SkStream
*
)
fileType
-
>
UserData
;
return
(
int32_t
)
stream
-
>
read
(
out
size
)
;
}
static
GifFileType
*
open_gif
(
SkStream
*
stream
)
{
return
DGifOpen
(
stream
read_bytes_callback
nullptr
)
;
}
static
uint32_t
find_trans_index
(
const
SavedImage
&
image
)
{
for
(
int32_t
i
=
image
.
ExtensionBlockCount
-
1
;
i
>
=
0
;
i
-
-
)
{
const
ExtensionBlock
&
extBlock
=
image
.
ExtensionBlocks
[
i
]
;
if
(
GRAPHICS_EXT_FUNC_CODE
=
=
extBlock
.
Function
&
&
extBlock
.
ByteCount
>
=
4
)
{
if
(
1
=
=
(
extBlock
.
Bytes
[
0
]
&
1
)
)
{
return
extBlock
.
Bytes
[
3
]
;
}
break
;
}
}
return
SK_MaxU32
;
}
inline
uint32_t
ceil_div
(
uint32_t
a
uint32_t
b
)
{
return
(
a
+
b
-
1
)
/
b
;
}
inline
uint32_t
get_output_row_interlaced
(
uint32_t
encodedRow
uint32_t
height
)
{
SkASSERT
(
encodedRow
<
height
)
;
if
(
encodedRow
*
8
<
height
)
{
return
encodedRow
*
8
;
}
if
(
encodedRow
*
4
<
height
)
{
return
4
+
8
*
(
encodedRow
-
ceil_div
(
height
8
)
)
;
}
if
(
encodedRow
*
2
<
height
)
{
return
2
+
4
*
(
encodedRow
-
ceil_div
(
height
4
)
)
;
}
return
1
+
2
*
(
encodedRow
-
ceil_div
(
height
2
)
)
;
}
void
SkGifCodec
:
:
CloseGif
(
GifFileType
*
gif
)
{
DGifCloseFile
(
gif
NULL
)
;
}
void
SkGifCodec
:
:
FreeExtension
(
SavedImage
*
image
)
{
if
(
NULL
!
=
image
-
>
ExtensionBlocks
)
{
GifFreeExtensions
(
&
image
-
>
ExtensionBlockCount
&
image
-
>
ExtensionBlocks
)
;
}
}
bool
SkGifCodec
:
:
ReadHeader
(
SkStream
*
stream
SkCodec
*
*
codecOut
GifFileType
*
*
gifOut
)
{
SkAutoTDelete
<
SkStream
>
streamDeleter
(
stream
)
;
SkAutoTCallVProc
<
GifFileType
CloseGif
>
gif
(
open_gif
(
stream
)
)
;
if
(
nullptr
=
=
gif
)
{
gif_error
(
"
DGifOpen
failed
.
\
n
"
)
;
return
false
;
}
uint32_t
transIndex
;
SkCodec
:
:
Result
result
=
ReadUpToFirstImage
(
gif
&
transIndex
)
;
if
(
kSuccess
!
=
result
)
{
return
false
;
}
if
(
GIF_ERROR
=
=
DGifGetImageDesc
(
gif
)
)
{
return
false
;
}
SkASSERT
(
gif
-
>
ImageCount
>
=
1
)
;
if
(
nullptr
!
=
codecOut
)
{
SkISize
size
;
SkIRect
frameRect
;
if
(
!
GetDimensions
(
gif
&
size
&
frameRect
)
)
{
gif_error
(
"
Invalid
gif
size
.
\
n
"
)
;
return
false
;
}
bool
frameIsSubset
=
(
size
!
=
frameRect
.
size
(
)
)
;
SkAlphaType
alphaType
=
(
transIndex
<
256
)
?
kPremul_SkAlphaType
:
kOpaque_SkAlphaType
;
SkImageInfo
imageInfo
=
SkImageInfo
:
:
Make
(
size
.
width
(
)
size
.
height
(
)
kIndex_8_SkColorType
alphaType
)
;
*
codecOut
=
new
SkGifCodec
(
imageInfo
streamDeleter
.
detach
(
)
gif
.
detach
(
)
transIndex
frameRect
frameIsSubset
)
;
}
else
{
SkASSERT
(
nullptr
!
=
gifOut
)
;
streamDeleter
.
detach
(
)
;
*
gifOut
=
gif
.
detach
(
)
;
}
return
true
;
}
SkCodec
*
SkGifCodec
:
:
NewFromStream
(
SkStream
*
stream
)
{
SkCodec
*
codec
=
nullptr
;
if
(
ReadHeader
(
stream
&
codec
nullptr
)
)
{
return
codec
;
}
return
nullptr
;
}
SkGifCodec
:
:
SkGifCodec
(
const
SkImageInfo
&
srcInfo
SkStream
*
stream
GifFileType
*
gif
uint32_t
transIndex
const
SkIRect
&
frameRect
bool
frameIsSubset
)
:
INHERITED
(
srcInfo
stream
)
fGif
(
gif
)
fSrcBuffer
(
new
uint8_t
[
this
-
>
getInfo
(
)
.
width
(
)
]
)
fFrameRect
(
frameRect
)
fTransIndex
(
transIndex
)
fFillIndex
(
0
)
fFrameIsSubset
(
frameIsSubset
)
fSwizzler
(
NULL
)
fColorTable
(
NULL
)
{
}
bool
SkGifCodec
:
:
onRewind
(
)
{
GifFileType
*
gifOut
=
nullptr
;
if
(
!
ReadHeader
(
this
-
>
stream
(
)
nullptr
&
gifOut
)
)
{
return
false
;
}
SkASSERT
(
nullptr
!
=
gifOut
)
;
fGif
.
reset
(
gifOut
)
;
return
true
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
ReadUpToFirstImage
(
GifFileType
*
gif
uint32_t
*
transIndex
)
{
SavedImage
saveExt
;
SkAutoTCallVProc
<
SavedImage
FreeExtension
>
autoFreeExt
(
&
saveExt
)
;
saveExt
.
ExtensionBlocks
=
nullptr
;
saveExt
.
ExtensionBlockCount
=
0
;
GifByteType
*
extData
;
int32_t
extFunction
;
GifRecordType
recordType
;
do
{
if
(
GIF_ERROR
=
=
DGifGetRecordType
(
gif
&
recordType
)
)
{
return
gif_error
(
"
DGifGetRecordType
failed
.
\
n
"
kInvalidInput
)
;
}
switch
(
recordType
)
{
case
IMAGE_DESC_RECORD_TYPE
:
{
*
transIndex
=
find_trans_index
(
saveExt
)
;
return
kSuccess
;
}
case
EXTENSION_RECORD_TYPE
:
if
(
GIF_ERROR
=
=
DGifGetExtension
(
gif
&
extFunction
&
extData
)
)
{
return
gif_error
(
"
Could
not
get
extension
.
\
n
"
kIncompleteInput
)
;
}
while
(
nullptr
!
=
extData
)
{
if
(
GIF_ERROR
=
=
GifAddExtensionBlock
(
&
saveExt
.
ExtensionBlockCount
&
saveExt
.
ExtensionBlocks
extFunction
extData
[
0
]
&
extData
[
1
]
)
)
{
return
gif_error
(
"
Could
not
add
extension
block
.
\
n
"
kIncompleteInput
)
;
}
if
(
GIF_ERROR
=
=
DGifGetExtensionNext
(
gif
&
extData
)
)
{
return
gif_error
(
"
Could
not
get
next
extension
.
\
n
"
kIncompleteInput
)
;
}
}
break
;
case
TERMINATE_RECORD_TYPE
:
break
;
default
:
SkASSERT
(
false
)
;
break
;
}
}
while
(
TERMINATE_RECORD_TYPE
!
=
recordType
)
;
return
gif_error
(
"
Could
not
find
any
images
to
decode
in
gif
file
.
\
n
"
kInvalidInput
)
;
}
bool
SkGifCodec
:
:
GetDimensions
(
GifFileType
*
gif
SkISize
*
size
SkIRect
*
frameRect
)
{
SavedImage
*
image
=
&
gif
-
>
SavedImages
[
gif
-
>
ImageCount
-
1
]
;
const
GifImageDesc
&
desc
=
image
-
>
ImageDesc
;
int
frameLeft
=
desc
.
Left
;
int
frameTop
=
desc
.
Top
;
int
frameWidth
=
desc
.
Width
;
int
frameHeight
=
desc
.
Height
;
int
width
=
gif
-
>
SWidth
;
int
height
=
gif
-
>
SHeight
;
width
=
SkTMax
(
width
frameWidth
+
frameLeft
)
;
height
=
SkTMax
(
height
frameHeight
+
frameTop
)
;
if
(
frameLeft
<
0
|
|
frameTop
<
0
|
|
frameWidth
<
0
|
|
frameHeight
<
0
|
|
width
<
=
0
|
|
height
<
=
0
)
{
return
false
;
}
frameRect
-
>
setXYWH
(
frameLeft
frameTop
frameWidth
frameHeight
)
;
size
-
>
set
(
width
height
)
;
return
true
;
}
void
SkGifCodec
:
:
initializeColorTable
(
const
SkImageInfo
&
dstInfo
SkPMColor
*
inputColorPtr
int
*
inputColorCount
)
{
const
uint32_t
maxColors
=
256
;
SkPMColor
colorPtr
[
256
]
;
if
(
NULL
!
=
inputColorCount
)
{
*
inputColorCount
=
maxColors
;
}
ColorMapObject
*
colorMap
=
fGif
-
>
Image
.
ColorMap
;
if
(
NULL
=
=
colorMap
)
{
colorMap
=
fGif
-
>
SColorMap
;
}
uint32_t
colorCount
=
0
;
if
(
NULL
!
=
colorMap
)
{
colorCount
=
colorMap
-
>
ColorCount
;
SkASSERT
(
colorCount
=
=
(
unsigned
)
(
1
<
<
(
colorMap
-
>
BitsPerPixel
)
)
)
;
SkASSERT
(
colorCount
<
=
256
)
;
for
(
uint32_t
i
=
0
;
i
<
colorCount
;
i
+
+
)
{
colorPtr
[
i
]
=
SkPackARGB32
(
0xFF
colorMap
-
>
Colors
[
i
]
.
Red
colorMap
-
>
Colors
[
i
]
.
Green
colorMap
-
>
Colors
[
i
]
.
Blue
)
;
}
}
uint32_t
backgroundIndex
=
fGif
-
>
SBackGroundColor
;
if
(
fTransIndex
<
colorCount
)
{
colorPtr
[
fTransIndex
]
=
SK_ColorTRANSPARENT
;
fFillIndex
=
fTransIndex
;
}
else
if
(
backgroundIndex
<
colorCount
)
{
fFillIndex
=
backgroundIndex
;
}
for
(
uint32_t
i
=
colorCount
;
i
<
maxColors
;
i
+
+
)
{
colorPtr
[
i
]
=
colorPtr
[
fFillIndex
]
;
}
fColorTable
.
reset
(
new
SkColorTable
(
colorPtr
maxColors
)
)
;
copy_color_table
(
dstInfo
this
-
>
fColorTable
inputColorPtr
inputColorCount
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
prepareToDecode
(
const
SkImageInfo
&
dstInfo
SkPMColor
*
inputColorPtr
int
*
inputColorCount
const
Options
&
opts
)
{
if
(
!
conversion_possible
(
dstInfo
this
-
>
getInfo
(
)
)
)
{
return
gif_error
(
"
Cannot
convert
input
type
to
output
type
.
\
n
"
kInvalidConversion
)
;
}
this
-
>
initializeColorTable
(
dstInfo
inputColorPtr
inputColorCount
)
;
return
this
-
>
initializeSwizzler
(
dstInfo
opts
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
initializeSwizzler
(
const
SkImageInfo
&
dstInfo
const
Options
&
opts
)
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
const
SkIRect
*
frameRect
=
fFrameIsSubset
?
&
fFrameRect
:
nullptr
;
fSwizzler
.
reset
(
SkSwizzler
:
:
CreateSwizzler
(
SkSwizzler
:
:
kIndex
colorPtr
dstInfo
opts
frameRect
)
)
;
if
(
nullptr
!
=
fSwizzler
.
get
(
)
)
{
return
kSuccess
;
}
return
kUnimplemented
;
}
bool
SkGifCodec
:
:
readRow
(
)
{
return
GIF_ERROR
!
=
DGifGetLine
(
fGif
fSrcBuffer
.
get
(
)
fFrameRect
.
width
(
)
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
onGetPixels
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
dstRowBytes
const
Options
&
opts
SkPMColor
*
inputColorPtr
int
*
inputColorCount
int
*
rowsDecoded
)
{
Result
result
=
this
-
>
prepareToDecode
(
dstInfo
inputColorPtr
inputColorCount
opts
)
;
if
(
kSuccess
!
=
result
)
{
return
result
;
}
if
(
dstInfo
.
dimensions
(
)
!
=
this
-
>
getInfo
(
)
.
dimensions
(
)
)
{
return
gif_error
(
"
Scaling
not
supported
.
\
n
"
kInvalidScale
)
;
}
if
(
fFrameIsSubset
)
{
SkSampler
:
:
Fill
(
dstInfo
dst
dstRowBytes
this
-
>
getFillValue
(
dstInfo
.
colorType
(
)
dstInfo
.
alphaType
(
)
)
opts
.
fZeroInitialized
)
;
}
for
(
int
y
=
fFrameRect
.
top
(
)
;
y
<
fFrameRect
.
bottom
(
)
;
y
+
+
)
{
if
(
!
this
-
>
readRow
(
)
)
{
*
rowsDecoded
=
y
;
return
gif_error
(
"
Could
not
decode
line
.
\
n
"
kIncompleteInput
)
;
}
void
*
dstRow
=
SkTAddOffset
<
void
>
(
dst
dstRowBytes
*
this
-
>
outputScanline
(
y
)
)
;
fSwizzler
-
>
swizzle
(
dstRow
fSrcBuffer
.
get
(
)
)
;
}
return
kSuccess
;
}
uint32_t
SkGifCodec
:
:
onGetFillValue
(
SkColorType
colorType
SkAlphaType
alphaType
)
const
{
const
SkPMColor
*
colorPtr
=
get_color_ptr
(
fColorTable
.
get
(
)
)
;
return
get_color_table_fill_value
(
colorType
colorPtr
fFillIndex
)
;
}
SkCodec
:
:
Result
SkGifCodec
:
:
onStartScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
&
opts
SkPMColor
inputColorPtr
[
]
int
*
inputColorCount
)
{
return
this
-
>
prepareToDecode
(
dstInfo
inputColorPtr
inputColorCount
this
-
>
options
(
)
)
;
}
void
SkGifCodec
:
:
handleScanlineFrame
(
int
count
int
*
rowsBeforeFrame
int
*
rowsInFrame
)
{
if
(
fFrameIsSubset
)
{
const
int
currRow
=
this
-
>
currScanline
(
)
;
*
rowsBeforeFrame
=
SkTMin
(
count
SkTMax
(
0
fFrameRect
.
top
(
)
-
currRow
)
)
;
const
int
rowsLeft
=
count
-
*
rowsBeforeFrame
;
const
int
rowsAfterFrame
=
SkTMax
(
0
currRow
+
rowsLeft
-
fFrameRect
.
bottom
(
)
)
;
*
rowsInFrame
=
rowsLeft
-
rowsAfterFrame
;
}
else
{
*
rowsBeforeFrame
=
0
;
*
rowsInFrame
=
count
;
}
}
int
SkGifCodec
:
:
onGetScanlines
(
void
*
dst
int
count
size_t
rowBytes
)
{
int
rowsBeforeFrame
;
int
rowsInFrame
;
this
-
>
handleScanlineFrame
(
count
&
rowsBeforeFrame
&
rowsInFrame
)
;
if
(
fFrameIsSubset
)
{
SkImageInfo
fillInfo
=
this
-
>
dstInfo
(
)
.
makeWH
(
this
-
>
dstInfo
(
)
.
width
(
)
count
)
;
uint32_t
fillValue
=
this
-
>
onGetFillValue
(
this
-
>
dstInfo
(
)
.
colorType
(
)
this
-
>
dstInfo
(
)
.
alphaType
(
)
)
;
fSwizzler
-
>
fill
(
fillInfo
dst
rowBytes
fillValue
this
-
>
options
(
)
.
fZeroInitialized
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
*
rowsBeforeFrame
)
;
}
for
(
int
i
=
0
;
i
<
rowsInFrame
;
i
+
+
)
{
if
(
!
this
-
>
readRow
(
)
)
{
return
i
+
rowsBeforeFrame
;
}
fSwizzler
-
>
swizzle
(
dst
fSrcBuffer
.
get
(
)
)
;
dst
=
SkTAddOffset
<
void
>
(
dst
rowBytes
)
;
}
return
count
;
}
bool
SkGifCodec
:
:
onSkipScanlines
(
int
count
)
{
int
rowsBeforeFrame
;
int
rowsInFrame
;
this
-
>
handleScanlineFrame
(
count
&
rowsBeforeFrame
&
rowsInFrame
)
;
for
(
int
i
=
0
;
i
<
rowsInFrame
;
i
+
+
)
{
if
(
!
this
-
>
readRow
(
)
)
{
return
false
;
}
}
return
true
;
}
SkCodec
:
:
SkScanlineOrder
SkGifCodec
:
:
onGetScanlineOrder
(
)
const
{
if
(
fGif
-
>
Image
.
Interlace
)
{
return
kOutOfOrder_SkScanlineOrder
;
}
return
kTopDown_SkScanlineOrder
;
}
int
SkGifCodec
:
:
onOutputScanline
(
int
inputScanline
)
const
{
if
(
fGif
-
>
Image
.
Interlace
)
{
if
(
inputScanline
<
fFrameRect
.
top
(
)
|
|
inputScanline
>
=
fFrameRect
.
bottom
(
)
)
{
return
inputScanline
;
}
return
get_output_row_interlaced
(
inputScanline
-
fFrameRect
.
top
(
)
fFrameRect
.
height
(
)
)
+
fFrameRect
.
top
(
)
;
}
return
inputScanline
;
}
