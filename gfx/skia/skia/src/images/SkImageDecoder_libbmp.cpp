#
include
"
bmpdecoderhelper
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkImageDecoder
.
h
"
#
include
"
SkScaledBitmapSampler
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkStreamPriv
.
h
"
#
include
"
SkTDArray
.
h
"
class
SkBMPImageDecoder
:
public
SkImageDecoder
{
public
:
SkBMPImageDecoder
(
)
{
}
Format
getFormat
(
)
const
override
{
return
kBMP_Format
;
}
protected
:
Result
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
mode
)
override
;
private
:
typedef
SkImageDecoder
INHERITED
;
}
;
DEFINE_DECODER_CREATOR
(
BMPImageDecoder
)
;
static
bool
is_bmp
(
SkStreamRewindable
*
stream
)
{
static
const
char
kBmpMagic
[
]
=
{
'
B
'
'
M
'
}
;
char
buffer
[
sizeof
(
kBmpMagic
)
]
;
return
stream
-
>
read
(
buffer
sizeof
(
kBmpMagic
)
)
=
=
sizeof
(
kBmpMagic
)
&
&
!
memcmp
(
buffer
kBmpMagic
sizeof
(
kBmpMagic
)
)
;
}
static
SkImageDecoder
*
sk_libbmp_dfactory
(
SkStreamRewindable
*
stream
)
{
if
(
is_bmp
(
stream
)
)
{
return
new
SkBMPImageDecoder
;
}
return
nullptr
;
}
static
SkImageDecoder_DecodeReg
gReg
(
sk_libbmp_dfactory
)
;
static
SkImageDecoder
:
:
Format
get_format_bmp
(
SkStreamRewindable
*
stream
)
{
if
(
is_bmp
(
stream
)
)
{
return
SkImageDecoder
:
:
kBMP_Format
;
}
return
SkImageDecoder
:
:
kUnknown_Format
;
}
static
SkImageDecoder_FormatReg
gFormatReg
(
get_format_bmp
)
;
class
SkBmpDecoderCallback
:
public
image_codec
:
:
BmpDecoderCallback
{
public
:
SkBmpDecoderCallback
(
bool
justBounds
)
:
fJustBounds
(
justBounds
)
{
}
virtual
uint8
*
SetSize
(
int
width
int
height
)
{
fWidth
=
width
;
fHeight
=
height
;
if
(
fJustBounds
)
{
return
nullptr
;
}
fRGB
.
setCount
(
width
*
height
*
3
)
;
return
fRGB
.
begin
(
)
;
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
const
uint8_t
*
rgb
(
)
const
{
return
fRGB
.
begin
(
)
;
}
private
:
SkTDArray
<
uint8_t
>
fRGB
;
int
fWidth
;
int
fHeight
;
bool
fJustBounds
;
}
;
SkImageDecoder
:
:
Result
SkBMPImageDecoder
:
:
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
mode
)
{
SkAutoMalloc
storage
;
const
size_t
length
=
SkCopyStreamToStorage
(
&
storage
stream
)
;
if
(
0
=
=
length
)
{
return
kFailure
;
}
const
bool
justBounds
=
SkImageDecoder
:
:
kDecodeBounds_Mode
=
=
mode
;
SkBmpDecoderCallback
callback
(
justBounds
)
;
{
image_codec
:
:
BmpDecoderHelper
helper
;
const
int
max_pixels
=
16383
*
16383
;
if
(
!
helper
.
DecodeImage
(
(
const
char
*
)
storage
.
get
(
)
length
max_pixels
&
callback
)
)
{
return
kFailure
;
}
}
storage
.
free
(
)
;
int
width
=
callback
.
width
(
)
;
int
height
=
callback
.
height
(
)
;
SkColorType
colorType
=
this
-
>
getPrefColorType
(
k32Bit_SrcDepth
false
)
;
if
(
kARGB_4444_SkColorType
!
=
colorType
&
&
kRGB_565_SkColorType
!
=
colorType
)
{
colorType
=
kN32_SkColorType
;
}
SkScaledBitmapSampler
sampler
(
width
height
getSampleSize
(
)
)
;
bm
-
>
setInfo
(
SkImageInfo
:
:
Make
(
sampler
.
scaledWidth
(
)
sampler
.
scaledHeight
(
)
colorType
kOpaque_SkAlphaType
)
)
;
if
(
justBounds
)
{
return
kSuccess
;
}
if
(
!
this
-
>
allocPixelRef
(
bm
nullptr
)
)
{
return
kFailure
;
}
SkAutoLockPixels
alp
(
*
bm
)
;
if
(
!
sampler
.
begin
(
bm
SkScaledBitmapSampler
:
:
kRGB
*
this
)
)
{
return
kFailure
;
}
const
int
srcRowBytes
=
width
*
3
;
const
int
dstHeight
=
sampler
.
scaledHeight
(
)
;
const
uint8_t
*
srcRow
=
callback
.
rgb
(
)
;
srcRow
+
=
sampler
.
srcY0
(
)
*
srcRowBytes
;
for
(
int
y
=
0
;
y
<
dstHeight
;
y
+
+
)
{
sampler
.
next
(
srcRow
)
;
srcRow
+
=
sampler
.
srcDY
(
)
*
srcRowBytes
;
}
return
kSuccess
;
}
