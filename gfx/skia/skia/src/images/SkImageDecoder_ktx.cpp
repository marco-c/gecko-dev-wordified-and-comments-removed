#
include
"
SkColorPriv
.
h
"
#
include
"
SkImageDecoder
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkScaledBitmapSampler
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkStreamPriv
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
ktx
.
h
"
#
include
"
etc1
.
h
"
class
SkKTXImageDecoder
:
public
SkImageDecoder
{
public
:
SkKTXImageDecoder
(
)
{
}
Format
getFormat
(
)
const
override
{
return
kKTX_Format
;
}
protected
:
Result
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
)
override
;
private
:
typedef
SkImageDecoder
INHERITED
;
}
;
SkImageDecoder
:
:
Result
SkKTXImageDecoder
:
:
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
mode
)
{
SkAutoDataUnref
data
(
SkCopyStreamToData
(
stream
)
)
;
if
(
nullptr
=
=
data
)
{
return
kFailure
;
}
SkKTXFile
ktxFile
(
data
)
;
if
(
!
ktxFile
.
valid
(
)
)
{
return
kFailure
;
}
const
unsigned
short
width
=
ktxFile
.
width
(
)
;
const
unsigned
short
height
=
ktxFile
.
height
(
)
;
const
SkString
premulKey
(
"
KTXPremultipliedAlpha
"
)
;
const
bool
bSrcIsPremul
=
ktxFile
.
getValueForKey
(
premulKey
)
=
=
SkString
(
"
True
"
)
;
SkScaledBitmapSampler
sampler
(
width
height
this
-
>
getSampleSize
(
)
)
;
SkAlphaType
alphaType
=
kOpaque_SkAlphaType
;
if
(
ktxFile
.
isRGBA8
(
)
)
{
if
(
this
-
>
getRequireUnpremultipliedColors
(
)
)
{
alphaType
=
kUnpremul_SkAlphaType
;
if
(
bSrcIsPremul
)
{
return
kFailure
;
}
}
else
{
alphaType
=
kPremul_SkAlphaType
;
}
}
bool
ktxIsCompressed
=
false
;
SkTextureCompressor
:
:
Format
ktxCompressedFormat
;
for
(
int
i
=
0
;
i
<
SkTextureCompressor
:
:
kFormatCnt
;
+
+
i
)
{
SkTextureCompressor
:
:
Format
fmt
=
static_cast
<
SkTextureCompressor
:
:
Format
>
(
i
)
;
if
(
ktxFile
.
isCompressedFormat
(
fmt
)
)
{
ktxIsCompressed
=
true
;
ktxCompressedFormat
=
fmt
;
break
;
}
}
bool
isCompressedAlpha
=
ktxIsCompressed
&
&
(
(
SkTextureCompressor
:
:
kLATC_Format
=
=
ktxCompressedFormat
)
|
|
(
SkTextureCompressor
:
:
kR11_EAC_Format
=
=
ktxCompressedFormat
)
)
;
if
(
isCompressedAlpha
)
{
const
int
w
=
sampler
.
scaledWidth
(
)
;
const
int
h
=
sampler
.
scaledHeight
(
)
;
bm
-
>
setInfo
(
SkImageInfo
:
:
MakeA8
(
w
h
)
)
;
}
else
{
const
int
w
=
sampler
.
scaledWidth
(
)
;
const
int
h
=
sampler
.
scaledHeight
(
)
;
bm
-
>
setInfo
(
SkImageInfo
:
:
MakeN32
(
w
h
alphaType
)
)
;
}
if
(
SkImageDecoder
:
:
kDecodeBounds_Mode
=
=
mode
)
{
return
kSuccess
;
}
if
(
!
this
-
>
allocPixelRef
(
bm
nullptr
)
)
{
return
kFailure
;
}
SkAutoLockPixels
alp
(
*
bm
)
;
if
(
isCompressedAlpha
)
{
if
(
!
sampler
.
begin
(
bm
SkScaledBitmapSampler
:
:
kGray
*
this
)
)
{
return
kFailure
;
}
int
nPixels
=
width
*
height
;
SkAutoMalloc
outRGBData
(
nPixels
)
;
uint8_t
*
outRGBDataPtr
=
reinterpret_cast
<
uint8_t
*
>
(
outRGBData
.
get
(
)
)
;
const
uint8_t
*
buf
=
reinterpret_cast
<
const
uint8_t
*
>
(
ktxFile
.
pixelData
(
)
)
;
if
(
!
SkTextureCompressor
:
:
DecompressBufferFromFormat
(
outRGBDataPtr
width
buf
width
height
ktxCompressedFormat
)
)
{
return
kFailure
;
}
const
int
srcRowBytes
=
width
;
const
int
dstHeight
=
sampler
.
scaledHeight
(
)
;
const
uint8_t
*
srcRow
=
reinterpret_cast
<
uint8_t
*
>
(
outRGBDataPtr
)
;
srcRow
+
=
sampler
.
srcY0
(
)
*
srcRowBytes
;
for
(
int
y
=
0
;
y
<
dstHeight
;
+
+
y
)
{
sampler
.
next
(
srcRow
)
;
srcRow
+
=
sampler
.
srcDY
(
)
*
srcRowBytes
;
}
return
kSuccess
;
}
else
if
(
ktxFile
.
isCompressedFormat
(
SkTextureCompressor
:
:
kETC1_Format
)
)
{
if
(
!
sampler
.
begin
(
bm
SkScaledBitmapSampler
:
:
kRGB
*
this
)
)
{
return
kFailure
;
}
int
nPixels
=
width
*
height
;
SkAutoMalloc
outRGBData
(
nPixels
*
3
)
;
uint8_t
*
outRGBDataPtr
=
reinterpret_cast
<
uint8_t
*
>
(
outRGBData
.
get
(
)
)
;
const
uint8_t
*
buf
=
reinterpret_cast
<
const
uint8_t
*
>
(
ktxFile
.
pixelData
(
)
)
;
if
(
!
SkTextureCompressor
:
:
DecompressBufferFromFormat
(
outRGBDataPtr
width
*
3
buf
width
height
SkTextureCompressor
:
:
kETC1_Format
)
)
{
return
kFailure
;
}
const
int
srcRowBytes
=
width
*
3
;
const
int
dstHeight
=
sampler
.
scaledHeight
(
)
;
const
uint8_t
*
srcRow
=
reinterpret_cast
<
uint8_t
*
>
(
outRGBDataPtr
)
;
srcRow
+
=
sampler
.
srcY0
(
)
*
srcRowBytes
;
for
(
int
y
=
0
;
y
<
dstHeight
;
+
+
y
)
{
sampler
.
next
(
srcRow
)
;
srcRow
+
=
sampler
.
srcDY
(
)
*
srcRowBytes
;
}
return
kSuccess
;
}
else
if
(
ktxFile
.
isRGB8
(
)
)
{
if
(
!
sampler
.
begin
(
bm
SkScaledBitmapSampler
:
:
kRGB
*
this
)
)
{
return
kFailure
;
}
const
int
srcRowBytes
=
width
*
3
;
const
int
dstHeight
=
sampler
.
scaledHeight
(
)
;
const
uint8_t
*
srcRow
=
reinterpret_cast
<
const
uint8_t
*
>
(
ktxFile
.
pixelData
(
)
)
;
srcRow
+
=
sampler
.
srcY0
(
)
*
srcRowBytes
;
for
(
int
y
=
0
;
y
<
dstHeight
;
+
+
y
)
{
sampler
.
next
(
srcRow
)
;
srcRow
+
=
sampler
.
srcDY
(
)
*
srcRowBytes
;
}
return
kSuccess
;
}
else
if
(
ktxFile
.
isRGBA8
(
)
)
{
SkScaledBitmapSampler
:
:
Options
opts
(
*
this
)
;
if
(
bSrcIsPremul
)
{
SkASSERT
(
bm
-
>
alphaType
(
)
=
=
kPremul_SkAlphaType
)
;
SkASSERT
(
!
this
-
>
getRequireUnpremultipliedColors
(
)
)
;
opts
.
fPremultiplyAlpha
=
false
;
}
if
(
!
sampler
.
begin
(
bm
SkScaledBitmapSampler
:
:
kRGBA
opts
)
)
{
return
kFailure
;
}
const
int
srcRowBytes
=
width
*
4
;
const
int
dstHeight
=
sampler
.
scaledHeight
(
)
;
const
uint8_t
*
srcRow
=
reinterpret_cast
<
const
uint8_t
*
>
(
ktxFile
.
pixelData
(
)
)
;
srcRow
+
=
sampler
.
srcY0
(
)
*
srcRowBytes
;
for
(
int
y
=
0
;
y
<
dstHeight
;
+
+
y
)
{
sampler
.
next
(
srcRow
)
;
srcRow
+
=
sampler
.
srcDY
(
)
*
srcRowBytes
;
}
return
kSuccess
;
}
return
kFailure
;
}
class
SkKTXImageEncoder
:
public
SkImageEncoder
{
protected
:
bool
onEncode
(
SkWStream
*
stream
const
SkBitmap
&
bm
int
quality
)
override
;
private
:
virtual
bool
encodePKM
(
SkWStream
*
stream
const
SkData
*
data
)
;
typedef
SkImageEncoder
INHERITED
;
}
;
bool
SkKTXImageEncoder
:
:
onEncode
(
SkWStream
*
stream
const
SkBitmap
&
bitmap
int
)
{
if
(
!
bitmap
.
pixelRef
(
)
)
{
return
false
;
}
SkAutoDataUnref
data
(
bitmap
.
pixelRef
(
)
-
>
refEncodedData
(
)
)
;
if
(
data
)
{
const
uint8_t
*
bytes
=
data
-
>
bytes
(
)
;
if
(
etc1_pkm_is_valid
(
bytes
)
)
{
return
this
-
>
encodePKM
(
stream
data
)
;
}
if
(
SkKTXFile
:
:
is_ktx
(
bytes
)
)
{
return
stream
-
>
write
(
bytes
data
-
>
size
(
)
)
;
}
}
return
SkKTXFile
:
:
WriteBitmapToKTX
(
stream
bitmap
)
;
}
bool
SkKTXImageEncoder
:
:
encodePKM
(
SkWStream
*
stream
const
SkData
*
data
)
{
const
uint8_t
*
bytes
=
data
-
>
bytes
(
)
;
SkASSERT
(
etc1_pkm_is_valid
(
bytes
)
)
;
etc1_uint32
width
=
etc1_pkm_get_width
(
bytes
)
;
etc1_uint32
height
=
etc1_pkm_get_height
(
bytes
)
;
if
(
width
=
=
0
|
|
(
width
&
3
)
!
=
0
|
|
height
=
=
0
|
|
(
height
&
3
)
!
=
0
)
{
return
false
;
}
bytes
+
=
ETC_PKM_HEADER_SIZE
;
return
SkKTXFile
:
:
WriteETC1ToKTX
(
stream
bytes
width
height
)
;
}
DEFINE_DECODER_CREATOR
(
KTXImageDecoder
)
;
DEFINE_ENCODER_CREATOR
(
KTXImageEncoder
)
;
static
SkImageDecoder
*
sk_libktx_dfactory
(
SkStreamRewindable
*
stream
)
{
if
(
SkKTXFile
:
:
is_ktx
(
stream
)
)
{
return
new
SkKTXImageDecoder
;
}
return
nullptr
;
}
static
SkImageDecoder
:
:
Format
get_format_ktx
(
SkStreamRewindable
*
stream
)
{
if
(
SkKTXFile
:
:
is_ktx
(
stream
)
)
{
return
SkImageDecoder
:
:
kKTX_Format
;
}
return
SkImageDecoder
:
:
kUnknown_Format
;
}
SkImageEncoder
*
sk_libktx_efactory
(
SkImageEncoder
:
:
Type
t
)
{
return
(
SkImageEncoder
:
:
kKTX_Type
=
=
t
)
?
new
SkKTXImageEncoder
:
nullptr
;
}
static
SkImageDecoder_DecodeReg
gReg
(
sk_libktx_dfactory
)
;
static
SkImageDecoder_FormatReg
gFormatReg
(
get_format_ktx
)
;
static
SkImageEncoder_EncodeReg
gEReg
(
sk_libktx_efactory
)
;
