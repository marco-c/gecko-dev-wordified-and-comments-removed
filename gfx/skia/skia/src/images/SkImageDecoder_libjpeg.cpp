#
include
"
SkImageDecoder
.
h
"
#
include
"
SkImageEncoder
.
h
"
#
include
"
SkJpegUtility
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkDither
.
h
"
#
include
"
SkScaledBitmapSampler
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTime
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
SkRTConf
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
<
stdio
.
h
>
extern
"
C
"
{
#
include
"
jpeglib
.
h
"
#
include
"
jerror
.
h
"
}
#
define
WE_CONVERT_TO_YUV
#
define
DEFAULT_FOR_SUPPRESS_JPEG_IMAGE_DECODER_WARNINGS
true
#
define
DEFAULT_FOR_SUPPRESS_JPEG_IMAGE_DECODER_ERRORS
true
SK_CONF_DECLARE
(
bool
c_suppressJPEGImageDecoderWarnings
"
images
.
jpeg
.
suppressDecoderWarnings
"
DEFAULT_FOR_SUPPRESS_JPEG_IMAGE_DECODER_WARNINGS
"
Suppress
most
JPG
warnings
when
calling
decode
functions
.
"
)
;
SK_CONF_DECLARE
(
bool
c_suppressJPEGImageDecoderErrors
"
images
.
jpeg
.
suppressDecoderErrors
"
DEFAULT_FOR_SUPPRESS_JPEG_IMAGE_DECODER_ERRORS
"
Suppress
most
JPG
error
messages
when
decode
"
"
function
fails
.
"
)
;
static
void
do_nothing_emit_message
(
jpeg_common_struct
*
int
)
{
}
static
void
do_nothing_output_message
(
j_common_ptr
)
{
}
static
void
initialize_info
(
jpeg_decompress_struct
*
cinfo
skjpeg_source_mgr
*
src_mgr
)
{
SkASSERT
(
cinfo
!
=
nullptr
)
;
SkASSERT
(
src_mgr
!
=
nullptr
)
;
jpeg_create_decompress
(
cinfo
)
;
cinfo
-
>
src
=
src_mgr
;
if
(
c_suppressJPEGImageDecoderWarnings
)
{
cinfo
-
>
err
-
>
emit_message
=
&
do_nothing_emit_message
;
}
if
(
c_suppressJPEGImageDecoderErrors
)
{
cinfo
-
>
err
-
>
output_message
=
&
do_nothing_output_message
;
}
}
class
SkJPEGImageDecoder
:
public
SkImageDecoder
{
public
:
Format
getFormat
(
)
const
override
{
return
kJPEG_Format
;
}
protected
:
Result
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
)
override
;
bool
onDecodeYUV8Planes
(
SkStream
*
stream
SkISize
componentSizes
[
3
]
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
SkYUVColorSpace
*
colorSpace
)
override
;
private
:
SkColorType
getBitmapColorType
(
jpeg_decompress_struct
*
)
;
typedef
SkImageDecoder
INHERITED
;
}
;
class
JPEGAutoClean
{
public
:
JPEGAutoClean
(
)
:
cinfo_ptr
(
nullptr
)
{
}
~
JPEGAutoClean
(
)
{
if
(
cinfo_ptr
)
{
jpeg_destroy_decompress
(
cinfo_ptr
)
;
}
}
void
set
(
jpeg_decompress_struct
*
info
)
{
cinfo_ptr
=
info
;
}
private
:
jpeg_decompress_struct
*
cinfo_ptr
;
}
;
static
int
recompute_sampleSize
(
int
sampleSize
const
jpeg_decompress_struct
&
cinfo
)
{
return
sampleSize
*
cinfo
.
output_width
/
cinfo
.
image_width
;
}
static
bool
valid_output_dimensions
(
const
jpeg_decompress_struct
&
cinfo
)
{
return
0
!
=
cinfo
.
output_width
&
&
0
!
=
cinfo
.
output_height
;
}
static
bool
skip_src_rows
(
jpeg_decompress_struct
*
cinfo
void
*
buffer
int
count
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
JSAMPLE
*
rowptr
=
(
JSAMPLE
*
)
buffer
;
int
row_count
=
jpeg_read_scanlines
(
cinfo
&
rowptr
1
)
;
if
(
1
!
=
row_count
)
{
return
false
;
}
}
return
true
;
}
static
void
print_jpeg_decoder_errors
(
const
jpeg_decompress_struct
&
cinfo
int
width
int
height
const
char
caller
[
]
)
{
if
(
!
(
c_suppressJPEGImageDecoderErrors
)
)
{
char
buffer
[
JMSG_LENGTH_MAX
]
;
cinfo
.
err
-
>
format_message
(
(
const
j_common_ptr
)
&
cinfo
buffer
)
;
SkDebugf
(
"
libjpeg
error
%
d
<
%
s
>
from
%
s
[
%
d
%
d
]
\
n
"
cinfo
.
err
-
>
msg_code
buffer
caller
width
height
)
;
}
}
static
bool
return_false
(
const
jpeg_decompress_struct
&
cinfo
const
char
caller
[
]
)
{
print_jpeg_decoder_errors
(
cinfo
0
0
caller
)
;
return
false
;
}
static
SkImageDecoder
:
:
Result
return_failure
(
const
jpeg_decompress_struct
&
cinfo
const
SkBitmap
&
bm
const
char
caller
[
]
)
{
print_jpeg_decoder_errors
(
cinfo
bm
.
width
(
)
bm
.
height
(
)
caller
)
;
return
SkImageDecoder
:
:
kFailure
;
}
static
void
convert_CMYK_to_RGB
(
uint8_t
*
scanline
unsigned
int
width
)
{
for
(
unsigned
int
x
=
0
;
x
<
width
;
+
+
x
scanline
+
=
4
)
{
scanline
[
0
]
=
SkMulDiv255Round
(
scanline
[
0
]
scanline
[
3
]
)
;
scanline
[
1
]
=
SkMulDiv255Round
(
scanline
[
1
]
scanline
[
3
]
)
;
scanline
[
2
]
=
SkMulDiv255Round
(
scanline
[
2
]
scanline
[
3
]
)
;
scanline
[
3
]
=
255
;
}
}
static
void
set_error_mgr
(
jpeg_decompress_struct
*
cinfo
skjpeg_error_mgr
*
errorManager
)
{
SkASSERT
(
cinfo
!
=
nullptr
)
;
SkASSERT
(
errorManager
!
=
nullptr
)
;
cinfo
-
>
err
=
jpeg_std_error
(
errorManager
)
;
errorManager
-
>
error_exit
=
skjpeg_error_exit
;
}
static
void
set_dct_method
(
const
SkImageDecoder
&
decoder
jpeg_decompress_struct
*
cinfo
)
{
SkASSERT
(
cinfo
!
=
nullptr
)
;
cinfo
-
>
dct_method
=
JDCT_ISLOW
;
}
SkColorType
SkJPEGImageDecoder
:
:
getBitmapColorType
(
jpeg_decompress_struct
*
cinfo
)
{
SkASSERT
(
cinfo
!
=
nullptr
)
;
SrcDepth
srcDepth
=
k32Bit_SrcDepth
;
if
(
JCS_GRAYSCALE
=
=
cinfo
-
>
jpeg_color_space
)
{
srcDepth
=
k8BitGray_SrcDepth
;
}
SkColorType
colorType
=
this
-
>
getPrefColorType
(
srcDepth
false
)
;
switch
(
colorType
)
{
case
kAlpha_8_SkColorType
:
if
(
cinfo
-
>
jpeg_color_space
!
=
JCS_GRAYSCALE
)
{
colorType
=
kN32_SkColorType
;
}
break
;
case
kN32_SkColorType
:
case
kARGB_4444_SkColorType
:
case
kRGB_565_SkColorType
:
break
;
default
:
colorType
=
kN32_SkColorType
;
break
;
}
switch
(
cinfo
-
>
jpeg_color_space
)
{
case
JCS_CMYK
:
case
JCS_YCCK
:
cinfo
-
>
out_color_space
=
JCS_CMYK
;
break
;
case
JCS_GRAYSCALE
:
if
(
kAlpha_8_SkColorType
=
=
colorType
)
{
cinfo
-
>
out_color_space
=
JCS_GRAYSCALE
;
break
;
}
default
:
cinfo
-
>
out_color_space
=
JCS_RGB
;
break
;
}
return
colorType
;
}
static
void
adjust_out_color_space_and_dither
(
jpeg_decompress_struct
*
cinfo
SkColorType
colorType
const
SkImageDecoder
&
decoder
)
{
SkASSERT
(
cinfo
!
=
nullptr
)
;
#
ifdef
ANDROID_RGB
cinfo
-
>
dither_mode
=
JDITHER_NONE
;
if
(
JCS_CMYK
=
=
cinfo
-
>
out_color_space
)
{
return
;
}
switch
(
colorType
)
{
case
kN32_SkColorType
:
cinfo
-
>
out_color_space
=
JCS_RGBA_8888
;
break
;
case
kRGB_565_SkColorType
:
cinfo
-
>
out_color_space
=
JCS_RGB_565
;
if
(
decoder
.
getDitherImage
(
)
)
{
cinfo
-
>
dither_mode
=
JDITHER_ORDERED
;
}
break
;
default
:
break
;
}
#
endif
}
static
void
fill_below_level
(
int
y
SkBitmap
*
bitmap
)
{
SkIRect
rect
=
SkIRect
:
:
MakeLTRB
(
0
y
bitmap
-
>
width
(
)
bitmap
-
>
height
(
)
)
;
SkCanvas
canvas
(
*
bitmap
)
;
canvas
.
clipRect
(
SkRect
:
:
Make
(
rect
)
)
;
canvas
.
drawColor
(
SK_ColorWHITE
)
;
}
static
bool
get_src_config
(
const
jpeg_decompress_struct
&
cinfo
SkScaledBitmapSampler
:
:
SrcConfig
*
sc
int
*
srcBytesPerPixel
)
{
SkASSERT
(
sc
!
=
nullptr
&
&
srcBytesPerPixel
!
=
nullptr
)
;
if
(
JCS_CMYK
=
=
cinfo
.
out_color_space
)
{
*
sc
=
SkScaledBitmapSampler
:
:
kRGBX
;
*
srcBytesPerPixel
=
4
;
}
else
if
(
3
=
=
cinfo
.
out_color_components
&
&
JCS_RGB
=
=
cinfo
.
out_color_space
)
{
*
sc
=
SkScaledBitmapSampler
:
:
kRGB
;
*
srcBytesPerPixel
=
3
;
#
ifdef
ANDROID_RGB
}
else
if
(
JCS_RGBA_8888
=
=
cinfo
.
out_color_space
)
{
*
sc
=
SkScaledBitmapSampler
:
:
kRGBX
;
*
srcBytesPerPixel
=
4
;
}
else
if
(
JCS_RGB_565
=
=
cinfo
.
out_color_space
)
{
*
sc
=
SkScaledBitmapSampler
:
:
kRGB_565
;
*
srcBytesPerPixel
=
2
;
#
endif
}
else
if
(
1
=
=
cinfo
.
out_color_components
&
&
JCS_GRAYSCALE
=
=
cinfo
.
out_color_space
)
{
*
sc
=
SkScaledBitmapSampler
:
:
kGray
;
*
srcBytesPerPixel
=
1
;
}
else
{
return
false
;
}
return
true
;
}
SkImageDecoder
:
:
Result
SkJPEGImageDecoder
:
:
onDecode
(
SkStream
*
stream
SkBitmap
*
bm
Mode
mode
)
{
#
ifdef
TIME_DECODE
SkAutoTime
atm
(
"
JPEG
Decode
"
)
;
#
endif
JPEGAutoClean
autoClean
;
jpeg_decompress_struct
cinfo
;
skjpeg_source_mgr
srcManager
(
stream
this
)
;
skjpeg_error_mgr
errorManager
;
set_error_mgr
(
&
cinfo
&
errorManager
)
;
if
(
setjmp
(
errorManager
.
fJmpBuf
)
)
{
return
return_failure
(
cinfo
*
bm
"
setjmp
"
)
;
}
initialize_info
(
&
cinfo
&
srcManager
)
;
autoClean
.
set
(
&
cinfo
)
;
int
status
=
jpeg_read_header
(
&
cinfo
true
)
;
if
(
status
!
=
JPEG_HEADER_OK
)
{
return
return_failure
(
cinfo
*
bm
"
read_header
"
)
;
}
int
sampleSize
=
this
-
>
getSampleSize
(
)
;
set_dct_method
(
*
this
&
cinfo
)
;
SkASSERT
(
1
=
=
cinfo
.
scale_num
)
;
cinfo
.
scale_denom
=
sampleSize
;
const
SkColorType
colorType
=
this
-
>
getBitmapColorType
(
&
cinfo
)
;
const
SkAlphaType
alphaType
=
kAlpha_8_SkColorType
=
=
colorType
?
kPremul_SkAlphaType
:
kOpaque_SkAlphaType
;
adjust_out_color_space_and_dither
(
&
cinfo
colorType
*
this
)
;
if
(
1
=
=
sampleSize
&
&
SkImageDecoder
:
:
kDecodeBounds_Mode
=
=
mode
)
{
bool
success
=
bm
-
>
setInfo
(
SkImageInfo
:
:
Make
(
cinfo
.
image_width
cinfo
.
image_height
colorType
alphaType
)
)
;
return
success
?
kSuccess
:
kFailure
;
}
if
(
!
jpeg_start_decompress
(
&
cinfo
)
)
{
if
(
SkImageDecoder
:
:
kDecodeBounds_Mode
=
=
mode
&
&
valid_output_dimensions
(
cinfo
)
)
{
SkScaledBitmapSampler
smpl
(
cinfo
.
output_width
cinfo
.
output_height
recompute_sampleSize
(
sampleSize
cinfo
)
)
;
bool
success
=
bm
-
>
setInfo
(
SkImageInfo
:
:
Make
(
smpl
.
scaledWidth
(
)
smpl
.
scaledHeight
(
)
colorType
alphaType
)
)
;
return
success
?
kSuccess
:
kFailure
;
}
else
{
return
return_failure
(
cinfo
*
bm
"
start_decompress
"
)
;
}
}
sampleSize
=
recompute_sampleSize
(
sampleSize
cinfo
)
;
SkScaledBitmapSampler
sampler
(
cinfo
.
output_width
cinfo
.
output_height
sampleSize
)
;
bm
-
>
setInfo
(
SkImageInfo
:
:
Make
(
sampler
.
scaledWidth
(
)
sampler
.
scaledHeight
(
)
colorType
alphaType
)
)
;
if
(
SkImageDecoder
:
:
kDecodeBounds_Mode
=
=
mode
)
{
return
kSuccess
;
}
if
(
!
this
-
>
allocPixelRef
(
bm
nullptr
)
)
{
return
return_failure
(
cinfo
*
bm
"
allocPixelRef
"
)
;
}
SkAutoLockPixels
alp
(
*
bm
)
;
#
ifdef
ANDROID_RGB
if
(
sampleSize
=
=
1
&
&
(
(
kN32_SkColorType
=
=
colorType
&
&
cinfo
.
out_color_space
=
=
JCS_RGBA_8888
)
|
|
(
kRGB_565_SkColorType
=
=
colorType
&
&
cinfo
.
out_color_space
=
=
JCS_RGB_565
)
)
)
{
JSAMPLE
*
rowptr
=
(
JSAMPLE
*
)
bm
-
>
getPixels
(
)
;
INT32
const
bpr
=
bm
-
>
rowBytes
(
)
;
while
(
cinfo
.
output_scanline
<
cinfo
.
output_height
)
{
int
row_count
=
jpeg_read_scanlines
(
&
cinfo
&
rowptr
1
)
;
if
(
0
=
=
row_count
)
{
fill_below_level
(
cinfo
.
output_scanline
bm
)
;
cinfo
.
output_scanline
=
cinfo
.
output_height
;
jpeg_finish_decompress
(
&
cinfo
)
;
return
kPartialSuccess
;
}
if
(
this
-
>
shouldCancelDecode
(
)
)
{
return
return_failure
(
cinfo
*
bm
"
shouldCancelDecode
"
)
;
}
rowptr
+
=
bpr
;
}
jpeg_finish_decompress
(
&
cinfo
)
;
return
kSuccess
;
}
#
endif
SkScaledBitmapSampler
:
:
SrcConfig
sc
;
int
srcBytesPerPixel
;
if
(
!
get_src_config
(
cinfo
&
sc
&
srcBytesPerPixel
)
)
{
return
return_failure
(
cinfo
*
bm
"
jpeg
colorspace
"
)
;
}
if
(
!
sampler
.
begin
(
bm
sc
*
this
)
)
{
return
return_failure
(
cinfo
*
bm
"
sampler
.
begin
"
)
;
}
SkAutoTMalloc
<
uint8_t
>
srcStorage
(
cinfo
.
output_width
*
srcBytesPerPixel
)
;
uint8_t
*
srcRow
=
srcStorage
.
get
(
)
;
if
(
!
skip_src_rows
(
&
cinfo
srcRow
sampler
.
srcY0
(
)
)
)
{
return
return_failure
(
cinfo
*
bm
"
skip
rows
"
)
;
}
for
(
int
y
=
0
;
;
y
+
+
)
{
JSAMPLE
*
rowptr
=
(
JSAMPLE
*
)
srcRow
;
int
row_count
=
jpeg_read_scanlines
(
&
cinfo
&
rowptr
1
)
;
if
(
0
=
=
row_count
)
{
fill_below_level
(
y
bm
)
;
cinfo
.
output_scanline
=
cinfo
.
output_height
;
jpeg_finish_decompress
(
&
cinfo
)
;
return
kPartialSuccess
;
}
if
(
this
-
>
shouldCancelDecode
(
)
)
{
return
return_failure
(
cinfo
*
bm
"
shouldCancelDecode
"
)
;
}
if
(
JCS_CMYK
=
=
cinfo
.
out_color_space
)
{
convert_CMYK_to_RGB
(
srcRow
cinfo
.
output_width
)
;
}
sampler
.
next
(
srcRow
)
;
if
(
bm
-
>
height
(
)
-
1
=
=
y
)
{
break
;
}
if
(
!
skip_src_rows
(
&
cinfo
srcRow
sampler
.
srcDY
(
)
-
1
)
)
{
return
return_failure
(
cinfo
*
bm
"
skip
rows
"
)
;
}
}
if
(
!
skip_src_rows
(
&
cinfo
srcRow
cinfo
.
output_height
-
cinfo
.
output_scanline
)
)
{
return
return_failure
(
cinfo
*
bm
"
skip
rows
"
)
;
}
jpeg_finish_decompress
(
&
cinfo
)
;
return
kSuccess
;
}
enum
SizeType
{
kSizeForMemoryAllocation_SizeType
kActualSize_SizeType
}
;
static
SkISize
compute_yuv_size
(
const
jpeg_decompress_struct
&
info
int
component
SizeType
sizeType
)
{
if
(
sizeType
=
=
kSizeForMemoryAllocation_SizeType
)
{
return
SkISize
:
:
Make
(
info
.
cur_comp_info
[
component
]
-
>
width_in_blocks
*
DCTSIZE
info
.
cur_comp_info
[
component
]
-
>
height_in_blocks
*
DCTSIZE
)
;
}
return
SkISize
:
:
Make
(
info
.
cur_comp_info
[
component
]
-
>
downsampled_width
info
.
cur_comp_info
[
component
]
-
>
downsampled_height
)
;
}
static
bool
appears_to_be_yuv
(
const
jpeg_decompress_struct
&
info
)
{
return
(
info
.
jpeg_color_space
=
=
JCS_YCbCr
)
&
&
(
DCTSIZE
=
=
8
)
&
&
(
info
.
num_components
=
=
3
)
&
&
(
info
.
comps_in_scan
>
=
info
.
num_components
)
&
&
(
info
.
scale_denom
<
=
8
)
&
&
(
info
.
cur_comp_info
[
0
]
)
&
&
(
info
.
cur_comp_info
[
1
]
)
&
&
(
info
.
cur_comp_info
[
2
]
)
&
&
(
info
.
cur_comp_info
[
1
]
-
>
h_samp_factor
=
=
1
)
&
&
(
info
.
cur_comp_info
[
1
]
-
>
v_samp_factor
=
=
1
)
&
&
(
info
.
cur_comp_info
[
2
]
-
>
h_samp_factor
=
=
1
)
&
&
(
info
.
cur_comp_info
[
2
]
-
>
v_samp_factor
=
=
1
)
;
}
static
void
update_components_sizes
(
const
jpeg_decompress_struct
&
cinfo
SkISize
componentSizes
[
3
]
SizeType
sizeType
)
{
SkASSERT
(
appears_to_be_yuv
(
cinfo
)
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
componentSizes
[
i
]
=
compute_yuv_size
(
cinfo
i
sizeType
)
;
}
}
static
bool
output_raw_data
(
jpeg_decompress_struct
&
cinfo
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
)
{
SkASSERT
(
appears_to_be_yuv
(
cinfo
)
)
;
SkISize
uvSize
=
compute_yuv_size
(
cinfo
1
kSizeForMemoryAllocation_SizeType
)
;
SkASSERT
(
uvSize
=
=
compute_yuv_size
(
cinfo
2
kSizeForMemoryAllocation_SizeType
)
)
;
JSAMPARRAY
bufferraw
[
3
]
;
JSAMPROW
bufferraw2
[
32
]
;
bufferraw
[
0
]
=
&
bufferraw2
[
0
]
;
bufferraw
[
1
]
=
&
bufferraw2
[
16
]
;
bufferraw
[
2
]
=
&
bufferraw2
[
24
]
;
int
yWidth
=
cinfo
.
output_width
;
int
yHeight
=
cinfo
.
output_height
;
int
yMaxH
=
yHeight
-
1
;
int
v
=
cinfo
.
cur_comp_info
[
0
]
-
>
v_samp_factor
;
int
uvMaxH
=
uvSize
.
height
(
)
-
1
;
JSAMPROW
outputY
=
static_cast
<
JSAMPROW
>
(
planes
[
0
]
)
;
JSAMPROW
outputU
=
static_cast
<
JSAMPROW
>
(
planes
[
1
]
)
;
JSAMPROW
outputV
=
static_cast
<
JSAMPROW
>
(
planes
[
2
]
)
;
size_t
rowBytesY
=
rowBytes
[
0
]
;
size_t
rowBytesU
=
rowBytes
[
1
]
;
size_t
rowBytesV
=
rowBytes
[
2
]
;
int
yScanlinesToRead
=
DCTSIZE
*
v
;
SkAutoMalloc
lastRowStorage
(
rowBytesY
*
4
)
;
JSAMPROW
yLastRow
=
(
JSAMPROW
)
lastRowStorage
.
get
(
)
;
JSAMPROW
uLastRow
=
yLastRow
+
rowBytesY
;
JSAMPROW
vLastRow
=
uLastRow
+
rowBytesY
;
JSAMPROW
dummyRow
=
vLastRow
+
rowBytesY
;
while
(
cinfo
.
output_scanline
<
cinfo
.
output_height
)
{
bool
hasYLastRow
(
false
)
hasUVLastRow
(
false
)
;
for
(
int
i
=
0
;
i
<
yScanlinesToRead
;
+
+
i
)
{
int
scanline
=
(
cinfo
.
output_scanline
+
i
)
;
if
(
scanline
<
yMaxH
)
{
bufferraw2
[
i
]
=
&
outputY
[
scanline
*
rowBytesY
]
;
}
else
if
(
scanline
=
=
yMaxH
)
{
bufferraw2
[
i
]
=
yLastRow
;
hasYLastRow
=
true
;
}
else
{
bufferraw2
[
i
]
=
dummyRow
;
}
}
int
scaledScanline
=
cinfo
.
output_scanline
/
v
;
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
int
scanline
=
(
scaledScanline
+
i
)
;
if
(
scanline
<
uvMaxH
)
{
bufferraw2
[
16
+
i
]
=
&
outputU
[
scanline
*
rowBytesU
]
;
bufferraw2
[
24
+
i
]
=
&
outputV
[
scanline
*
rowBytesV
]
;
}
else
if
(
scanline
=
=
uvMaxH
)
{
bufferraw2
[
16
+
i
]
=
uLastRow
;
bufferraw2
[
24
+
i
]
=
vLastRow
;
hasUVLastRow
=
true
;
}
else
{
bufferraw2
[
16
+
i
]
=
dummyRow
;
bufferraw2
[
24
+
i
]
=
dummyRow
;
}
}
JDIMENSION
scanlinesRead
=
jpeg_read_raw_data
(
&
cinfo
bufferraw
yScanlinesToRead
)
;
if
(
scanlinesRead
=
=
0
)
{
return
false
;
}
if
(
hasYLastRow
)
{
memcpy
(
&
outputY
[
yMaxH
*
rowBytesY
]
yLastRow
yWidth
)
;
}
if
(
hasUVLastRow
)
{
memcpy
(
&
outputU
[
uvMaxH
*
rowBytesU
]
uLastRow
uvSize
.
width
(
)
)
;
memcpy
(
&
outputV
[
uvMaxH
*
rowBytesV
]
vLastRow
uvSize
.
width
(
)
)
;
}
}
cinfo
.
output_scanline
=
SkMin32
(
cinfo
.
output_scanline
cinfo
.
output_height
)
;
return
true
;
}
bool
SkJPEGImageDecoder
:
:
onDecodeYUV8Planes
(
SkStream
*
stream
SkISize
componentSizes
[
3
]
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
SkYUVColorSpace
*
colorSpace
)
{
#
ifdef
TIME_DECODE
SkAutoTime
atm
(
"
JPEG
YUV8
Decode
"
)
;
#
endif
if
(
this
-
>
getSampleSize
(
)
!
=
1
)
{
return
false
;
}
JPEGAutoClean
autoClean
;
jpeg_decompress_struct
cinfo
;
skjpeg_source_mgr
srcManager
(
stream
this
)
;
skjpeg_error_mgr
errorManager
;
set_error_mgr
(
&
cinfo
&
errorManager
)
;
if
(
setjmp
(
errorManager
.
fJmpBuf
)
)
{
return
return_false
(
cinfo
"
setjmp
YUV8
"
)
;
}
initialize_info
(
&
cinfo
&
srcManager
)
;
autoClean
.
set
(
&
cinfo
)
;
int
status
=
jpeg_read_header
(
&
cinfo
true
)
;
if
(
status
!
=
JPEG_HEADER_OK
)
{
return
return_false
(
cinfo
"
read_header
YUV8
"
)
;
}
if
(
!
appears_to_be_yuv
(
cinfo
)
)
{
return
false
;
}
cinfo
.
out_color_space
=
JCS_YCbCr
;
cinfo
.
raw_data_out
=
TRUE
;
if
(
!
planes
|
|
!
planes
[
0
]
|
|
!
rowBytes
|
|
!
rowBytes
[
0
]
)
{
update_components_sizes
(
cinfo
componentSizes
kSizeForMemoryAllocation_SizeType
)
;
return
true
;
}
set_dct_method
(
*
this
&
cinfo
)
;
SkASSERT
(
1
=
=
cinfo
.
scale_num
)
;
cinfo
.
scale_denom
=
1
;
#
ifdef
ANDROID_RGB
cinfo
.
dither_mode
=
JDITHER_NONE
;
#
endif
if
(
!
jpeg_start_decompress
(
&
cinfo
)
)
{
return
return_false
(
cinfo
"
start_decompress
YUV8
"
)
;
}
if
(
!
appears_to_be_yuv
(
cinfo
)
)
{
return
false
;
}
if
(
!
output_raw_data
(
cinfo
planes
rowBytes
)
)
{
return
return_false
(
cinfo
"
output_raw_data
"
)
;
}
update_components_sizes
(
cinfo
componentSizes
kActualSize_SizeType
)
;
jpeg_finish_decompress
(
&
cinfo
)
;
if
(
nullptr
!
=
colorSpace
)
{
*
colorSpace
=
kJPEG_SkYUVColorSpace
;
}
return
true
;
}
#
include
"
SkColorPriv
.
h
"
#
if
0
#
define
CYR
19595
/
/
0
.
299
#
define
CYG
38470
/
/
0
.
587
#
define
CYB
7471
/
/
0
.
114
#
define
CUR
-
11059
/
/
-
0
.
16874
#
define
CUG
-
21709
/
/
-
0
.
33126
#
define
CUB
32768
/
/
0
.
5
#
define
CVR
32768
/
/
0
.
5
#
define
CVG
-
27439
/
/
-
0
.
41869
#
define
CVB
-
5329
/
/
-
0
.
08131
#
define
CSHIFT
16
#
else
#
define
CYR
77
/
/
0
.
299
#
define
CYG
150
/
/
0
.
587
#
define
CYB
29
/
/
0
.
114
#
define
CUR
-
43
/
/
-
0
.
16874
#
define
CUG
-
85
/
/
-
0
.
33126
#
define
CUB
128
/
/
0
.
5
#
define
CVR
128
/
/
0
.
5
#
define
CVG
-
107
/
/
-
0
.
41869
#
define
CVB
-
21
/
/
-
0
.
08131
#
define
CSHIFT
8
#
endif
static
void
rgb2yuv_32
(
uint8_t
dst
[
]
SkPMColor
c
)
{
int
r
=
SkGetPackedR32
(
c
)
;
int
g
=
SkGetPackedG32
(
c
)
;
int
b
=
SkGetPackedB32
(
c
)
;
int
y
=
(
CYR
*
r
+
CYG
*
g
+
CYB
*
b
)
>
>
CSHIFT
;
int
u
=
(
CUR
*
r
+
CUG
*
g
+
CUB
*
b
)
>
>
CSHIFT
;
int
v
=
(
CVR
*
r
+
CVG
*
g
+
CVB
*
b
)
>
>
CSHIFT
;
dst
[
0
]
=
SkToU8
(
y
)
;
dst
[
1
]
=
SkToU8
(
u
+
128
)
;
dst
[
2
]
=
SkToU8
(
v
+
128
)
;
}
static
void
rgb2yuv_4444
(
uint8_t
dst
[
]
U16CPU
c
)
{
int
r
=
SkGetPackedR4444
(
c
)
;
int
g
=
SkGetPackedG4444
(
c
)
;
int
b
=
SkGetPackedB4444
(
c
)
;
int
y
=
(
CYR
*
r
+
CYG
*
g
+
CYB
*
b
)
>
>
(
CSHIFT
-
4
)
;
int
u
=
(
CUR
*
r
+
CUG
*
g
+
CUB
*
b
)
>
>
(
CSHIFT
-
4
)
;
int
v
=
(
CVR
*
r
+
CVG
*
g
+
CVB
*
b
)
>
>
(
CSHIFT
-
4
)
;
dst
[
0
]
=
SkToU8
(
y
)
;
dst
[
1
]
=
SkToU8
(
u
+
128
)
;
dst
[
2
]
=
SkToU8
(
v
+
128
)
;
}
static
void
rgb2yuv_16
(
uint8_t
dst
[
]
U16CPU
c
)
{
int
r
=
SkGetPackedR16
(
c
)
;
int
g
=
SkGetPackedG16
(
c
)
;
int
b
=
SkGetPackedB16
(
c
)
;
int
y
=
(
2
*
CYR
*
r
+
CYG
*
g
+
2
*
CYB
*
b
)
>
>
(
CSHIFT
-
2
)
;
int
u
=
(
2
*
CUR
*
r
+
CUG
*
g
+
2
*
CUB
*
b
)
>
>
(
CSHIFT
-
2
)
;
int
v
=
(
2
*
CVR
*
r
+
CVG
*
g
+
2
*
CVB
*
b
)
>
>
(
CSHIFT
-
2
)
;
dst
[
0
]
=
SkToU8
(
y
)
;
dst
[
1
]
=
SkToU8
(
u
+
128
)
;
dst
[
2
]
=
SkToU8
(
v
+
128
)
;
}
typedef
void
(
*
WriteScanline
)
(
uint8_t
*
SK_RESTRICT
dst
const
void
*
SK_RESTRICT
src
int
width
const
SkPMColor
*
SK_RESTRICT
ctable
)
;
static
void
Write_32_YUV
(
uint8_t
*
SK_RESTRICT
dst
const
void
*
SK_RESTRICT
srcRow
int
width
const
SkPMColor
*
)
{
const
uint32_t
*
SK_RESTRICT
src
=
(
const
uint32_t
*
)
srcRow
;
while
(
-
-
width
>
=
0
)
{
#
ifdef
WE_CONVERT_TO_YUV
rgb2yuv_32
(
dst
*
src
+
+
)
;
#
else
uint32_t
c
=
*
src
+
+
;
dst
[
0
]
=
SkGetPackedR32
(
c
)
;
dst
[
1
]
=
SkGetPackedG32
(
c
)
;
dst
[
2
]
=
SkGetPackedB32
(
c
)
;
#
endif
dst
+
=
3
;
}
}
static
void
Write_4444_YUV
(
uint8_t
*
SK_RESTRICT
dst
const
void
*
SK_RESTRICT
srcRow
int
width
const
SkPMColor
*
)
{
const
SkPMColor16
*
SK_RESTRICT
src
=
(
const
SkPMColor16
*
)
srcRow
;
while
(
-
-
width
>
=
0
)
{
#
ifdef
WE_CONVERT_TO_YUV
rgb2yuv_4444
(
dst
*
src
+
+
)
;
#
else
SkPMColor16
c
=
*
src
+
+
;
dst
[
0
]
=
SkPacked4444ToR32
(
c
)
;
dst
[
1
]
=
SkPacked4444ToG32
(
c
)
;
dst
[
2
]
=
SkPacked4444ToB32
(
c
)
;
#
endif
dst
+
=
3
;
}
}
static
void
Write_16_YUV
(
uint8_t
*
SK_RESTRICT
dst
const
void
*
SK_RESTRICT
srcRow
int
width
const
SkPMColor
*
)
{
const
uint16_t
*
SK_RESTRICT
src
=
(
const
uint16_t
*
)
srcRow
;
while
(
-
-
width
>
=
0
)
{
#
ifdef
WE_CONVERT_TO_YUV
rgb2yuv_16
(
dst
*
src
+
+
)
;
#
else
uint16_t
c
=
*
src
+
+
;
dst
[
0
]
=
SkPacked16ToR32
(
c
)
;
dst
[
1
]
=
SkPacked16ToG32
(
c
)
;
dst
[
2
]
=
SkPacked16ToB32
(
c
)
;
#
endif
dst
+
=
3
;
}
}
static
void
Write_Index_YUV
(
uint8_t
*
SK_RESTRICT
dst
const
void
*
SK_RESTRICT
srcRow
int
width
const
SkPMColor
*
SK_RESTRICT
ctable
)
{
const
uint8_t
*
SK_RESTRICT
src
=
(
const
uint8_t
*
)
srcRow
;
while
(
-
-
width
>
=
0
)
{
#
ifdef
WE_CONVERT_TO_YUV
rgb2yuv_32
(
dst
ctable
[
*
src
+
+
]
)
;
#
else
uint32_t
c
=
ctable
[
*
src
+
+
]
;
dst
[
0
]
=
SkGetPackedR32
(
c
)
;
dst
[
1
]
=
SkGetPackedG32
(
c
)
;
dst
[
2
]
=
SkGetPackedB32
(
c
)
;
#
endif
dst
+
=
3
;
}
}
static
WriteScanline
ChooseWriter
(
const
SkBitmap
&
bm
)
{
switch
(
bm
.
colorType
(
)
)
{
case
kN32_SkColorType
:
return
Write_32_YUV
;
case
kRGB_565_SkColorType
:
return
Write_16_YUV
;
case
kARGB_4444_SkColorType
:
return
Write_4444_YUV
;
case
kIndex_8_SkColorType
:
return
Write_Index_YUV
;
default
:
return
nullptr
;
}
}
class
SkJPEGImageEncoder
:
public
SkImageEncoder
{
protected
:
virtual
bool
onEncode
(
SkWStream
*
stream
const
SkBitmap
&
bm
int
quality
)
{
#
ifdef
TIME_ENCODE
SkAutoTime
atm
(
"
JPEG
Encode
"
)
;
#
endif
SkAutoLockPixels
alp
(
bm
)
;
if
(
nullptr
=
=
bm
.
getPixels
(
)
)
{
return
false
;
}
jpeg_compress_struct
cinfo
;
skjpeg_error_mgr
sk_err
;
skjpeg_destination_mgr
sk_wstream
(
stream
)
;
SkAutoTMalloc
<
uint8_t
>
oneRow
;
cinfo
.
err
=
jpeg_std_error
(
&
sk_err
)
;
sk_err
.
error_exit
=
skjpeg_error_exit
;
if
(
setjmp
(
sk_err
.
fJmpBuf
)
)
{
return
false
;
}
const
WriteScanline
writer
=
ChooseWriter
(
bm
)
;
if
(
nullptr
=
=
writer
)
{
return
false
;
}
jpeg_create_compress
(
&
cinfo
)
;
cinfo
.
dest
=
&
sk_wstream
;
cinfo
.
image_width
=
bm
.
width
(
)
;
cinfo
.
image_height
=
bm
.
height
(
)
;
cinfo
.
input_components
=
3
;
#
ifdef
WE_CONVERT_TO_YUV
cinfo
.
in_color_space
=
JCS_YCbCr
;
#
else
cinfo
.
in_color_space
=
JCS_RGB
;
#
endif
cinfo
.
input_gamma
=
1
;
jpeg_set_defaults
(
&
cinfo
)
;
jpeg_set_quality
(
&
cinfo
quality
TRUE
)
;
#
ifdef
DCT_IFAST_SUPPORTED
cinfo
.
dct_method
=
JDCT_IFAST
;
#
endif
jpeg_start_compress
(
&
cinfo
TRUE
)
;
const
int
width
=
bm
.
width
(
)
;
uint8_t
*
oneRowP
=
oneRow
.
reset
(
width
*
3
)
;
const
SkPMColor
*
colors
=
bm
.
getColorTable
(
)
?
bm
.
getColorTable
(
)
-
>
readColors
(
)
:
nullptr
;
const
void
*
srcRow
=
bm
.
getPixels
(
)
;
while
(
cinfo
.
next_scanline
<
cinfo
.
image_height
)
{
JSAMPROW
row_pointer
[
1
]
;
writer
(
oneRowP
srcRow
width
colors
)
;
row_pointer
[
0
]
=
oneRowP
;
(
void
)
jpeg_write_scanlines
(
&
cinfo
row_pointer
1
)
;
srcRow
=
(
const
void
*
)
(
(
const
char
*
)
srcRow
+
bm
.
rowBytes
(
)
)
;
}
jpeg_finish_compress
(
&
cinfo
)
;
jpeg_destroy_compress
(
&
cinfo
)
;
return
true
;
}
}
;
DEFINE_DECODER_CREATOR
(
JPEGImageDecoder
)
;
DEFINE_ENCODER_CREATOR
(
JPEGImageEncoder
)
;
static
bool
is_jpeg
(
SkStreamRewindable
*
stream
)
{
static
const
unsigned
char
gHeader
[
]
=
{
0xFF
0xD8
0xFF
}
;
static
const
size_t
HEADER_SIZE
=
sizeof
(
gHeader
)
;
char
buffer
[
HEADER_SIZE
]
;
size_t
len
=
stream
-
>
read
(
buffer
HEADER_SIZE
)
;
if
(
len
!
=
HEADER_SIZE
)
{
return
false
;
}
if
(
memcmp
(
buffer
gHeader
HEADER_SIZE
)
)
{
return
false
;
}
return
true
;
}
static
SkImageDecoder
*
sk_libjpeg_dfactory
(
SkStreamRewindable
*
stream
)
{
if
(
is_jpeg
(
stream
)
)
{
return
new
SkJPEGImageDecoder
;
}
return
nullptr
;
}
static
SkImageDecoder
:
:
Format
get_format_jpeg
(
SkStreamRewindable
*
stream
)
{
if
(
is_jpeg
(
stream
)
)
{
return
SkImageDecoder
:
:
kJPEG_Format
;
}
return
SkImageDecoder
:
:
kUnknown_Format
;
}
static
SkImageEncoder
*
sk_libjpeg_efactory
(
SkImageEncoder
:
:
Type
t
)
{
return
(
SkImageEncoder
:
:
kJPEG_Type
=
=
t
)
?
new
SkJPEGImageEncoder
:
nullptr
;
}
static
SkImageDecoder_DecodeReg
gDReg
(
sk_libjpeg_dfactory
)
;
static
SkImageDecoder_FormatReg
gFormatReg
(
get_format_jpeg
)
;
static
SkImageEncoder_EncodeReg
gEReg
(
sk_libjpeg_efactory
)
;
