#
include
"
SkData
.
h
"
#
include
"
SkDecodingImageGenerator
.
h
"
#
include
"
SkImageDecoder
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkImageGenerator
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkUtils
.
h
"
namespace
{
bool
equal_modulo_alpha
(
const
SkImageInfo
&
a
const
SkImageInfo
&
b
)
{
return
a
.
width
(
)
=
=
b
.
width
(
)
&
&
a
.
height
(
)
=
=
b
.
height
(
)
&
&
a
.
colorType
(
)
=
=
b
.
colorType
(
)
;
}
class
DecodingImageGenerator
:
public
SkImageGenerator
{
public
:
virtual
~
DecodingImageGenerator
(
)
;
SkData
*
fData
;
SkAutoTDelete
<
SkStreamRewindable
>
fStream
;
const
SkImageInfo
fInfo
;
const
int
fSampleSize
;
const
bool
fDitherImage
;
DecodingImageGenerator
(
SkData
*
data
SkStreamRewindable
*
stream
const
SkImageInfo
&
info
int
sampleSize
bool
ditherImage
)
;
protected
:
SkData
*
onRefEncodedData
(
SK_REFENCODEDDATA_CTXPARAM
)
override
;
bool
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctable
[
]
int
*
ctableCount
)
override
;
bool
onGetYUV8Planes
(
SkISize
sizes
[
3
]
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
SkYUVColorSpace
*
colorSpace
)
override
;
private
:
typedef
SkImageGenerator
INHERITED
;
}
;
class
TargetAllocator
:
public
SkBitmap
:
:
Allocator
{
public
:
TargetAllocator
(
const
SkImageInfo
&
info
void
*
target
size_t
rowBytes
)
:
fInfo
(
info
)
fTarget
(
target
)
fRowBytes
(
rowBytes
)
{
}
bool
isReady
(
)
{
return
(
fTarget
!
=
nullptr
)
;
}
virtual
bool
allocPixelRef
(
SkBitmap
*
bm
SkColorTable
*
ct
)
{
if
(
nullptr
=
=
fTarget
|
|
!
equal_modulo_alpha
(
fInfo
bm
-
>
info
(
)
)
)
{
return
bm
-
>
tryAllocPixels
(
nullptr
ct
)
;
}
bm
-
>
installPixels
(
fInfo
fTarget
fRowBytes
ct
nullptr
nullptr
)
;
fTarget
=
nullptr
;
return
true
;
}
private
:
const
SkImageInfo
fInfo
;
void
*
fTarget
;
const
size_t
fRowBytes
;
typedef
SkBitmap
:
:
Allocator
INHERITED
;
}
;
#
ifdef
SK_DEBUG
#
define
SkCheckResult
(
expr
value
)
SkASSERT
(
(
value
)
=
=
(
expr
)
)
#
else
#
define
SkCheckResult
(
expr
value
)
(
void
)
(
expr
)
#
endif
#
ifdef
SK_DEBUG
inline
bool
check_alpha
(
SkAlphaType
reported
SkAlphaType
actual
)
{
return
(
(
reported
=
=
actual
)
|
|
(
(
reported
=
=
kPremul_SkAlphaType
)
&
&
(
actual
=
=
kOpaque_SkAlphaType
)
)
)
;
}
#
endif
DecodingImageGenerator
:
:
DecodingImageGenerator
(
SkData
*
data
SkStreamRewindable
*
stream
const
SkImageInfo
&
info
int
sampleSize
bool
ditherImage
)
:
INHERITED
(
info
)
fData
(
data
)
fStream
(
stream
)
fInfo
(
info
)
fSampleSize
(
sampleSize
)
fDitherImage
(
ditherImage
)
{
SkASSERT
(
stream
!
=
nullptr
)
;
SkSafeRef
(
fData
)
;
}
DecodingImageGenerator
:
:
~
DecodingImageGenerator
(
)
{
SkSafeUnref
(
fData
)
;
}
SkData
*
DecodingImageGenerator
:
:
onRefEncodedData
(
SK_REFENCODEDDATA_CTXPARAM
)
{
if
(
nullptr
=
=
fData
)
{
if
(
!
fStream
-
>
rewind
(
)
)
{
return
nullptr
;
}
size_t
length
=
fStream
-
>
getLength
(
)
;
if
(
length
)
{
fData
=
SkData
:
:
NewFromStream
(
fStream
length
)
;
}
}
return
SkSafeRef
(
fData
)
;
}
bool
DecodingImageGenerator
:
:
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctableEntries
[
]
int
*
ctableCount
)
{
if
(
fInfo
!
=
info
)
{
return
false
;
}
SkAssertResult
(
fStream
-
>
rewind
(
)
)
;
SkAutoTDelete
<
SkImageDecoder
>
decoder
(
SkImageDecoder
:
:
Factory
(
fStream
)
)
;
if
(
nullptr
=
=
decoder
.
get
(
)
)
{
return
false
;
}
decoder
-
>
setDitherImage
(
fDitherImage
)
;
decoder
-
>
setSampleSize
(
fSampleSize
)
;
decoder
-
>
setRequireUnpremultipliedColors
(
info
.
alphaType
(
)
=
=
kUnpremul_SkAlphaType
)
;
SkBitmap
bitmap
;
TargetAllocator
allocator
(
fInfo
pixels
rowBytes
)
;
decoder
-
>
setAllocator
(
&
allocator
)
;
const
SkImageDecoder
:
:
Result
decodeResult
=
decoder
-
>
decode
(
fStream
&
bitmap
info
.
colorType
(
)
SkImageDecoder
:
:
kDecodePixels_Mode
)
;
decoder
-
>
setAllocator
(
nullptr
)
;
if
(
SkImageDecoder
:
:
kFailure
=
=
decodeResult
)
{
return
false
;
}
if
(
allocator
.
isReady
(
)
)
{
SkBitmap
bm
;
SkASSERT
(
bitmap
.
canCopyTo
(
info
.
colorType
(
)
)
)
;
bool
copySuccess
=
bitmap
.
copyTo
(
&
bm
info
.
colorType
(
)
&
allocator
)
;
if
(
!
copySuccess
|
|
allocator
.
isReady
(
)
)
{
SkDEBUGFAIL
(
"
bitmap
.
copyTo
(
requestedConfig
)
failed
.
"
)
;
return
false
;
}
SkASSERT
(
check_alpha
(
info
.
alphaType
(
)
bm
.
alphaType
(
)
)
)
;
}
else
{
SkASSERT
(
check_alpha
(
info
.
alphaType
(
)
bitmap
.
alphaType
(
)
)
)
;
}
if
(
kIndex_8_SkColorType
=
=
info
.
colorType
(
)
)
{
if
(
kIndex_8_SkColorType
!
=
bitmap
.
colorType
(
)
)
{
return
false
;
}
SkColorTable
*
ctable
=
bitmap
.
getColorTable
(
)
;
if
(
nullptr
=
=
ctable
)
{
return
false
;
}
const
int
count
=
ctable
-
>
count
(
)
;
memcpy
(
ctableEntries
ctable
-
>
readColors
(
)
count
*
sizeof
(
SkPMColor
)
)
;
*
ctableCount
=
count
;
}
return
true
;
}
bool
DecodingImageGenerator
:
:
onGetYUV8Planes
(
SkISize
sizes
[
3
]
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
SkYUVColorSpace
*
colorSpace
)
{
if
(
!
fStream
-
>
rewind
(
)
)
{
return
false
;
}
SkAutoTDelete
<
SkImageDecoder
>
decoder
(
SkImageDecoder
:
:
Factory
(
fStream
)
)
;
if
(
nullptr
=
=
decoder
.
get
(
)
)
{
return
false
;
}
return
decoder
-
>
decodeYUV8Planes
(
fStream
sizes
planes
rowBytes
colorSpace
)
;
}
SkImageGenerator
*
CreateDecodingImageGenerator
(
SkData
*
data
SkStreamRewindable
*
stream
const
SkDecodingImageGenerator
:
:
Options
&
opts
)
{
SkASSERT
(
stream
)
;
SkAutoTDelete
<
SkStreamRewindable
>
autoStream
(
stream
)
;
SkAssertResult
(
autoStream
-
>
rewind
(
)
)
;
SkAutoTDelete
<
SkImageDecoder
>
decoder
(
SkImageDecoder
:
:
Factory
(
autoStream
)
)
;
if
(
nullptr
=
=
decoder
.
get
(
)
)
{
return
nullptr
;
}
SkBitmap
bitmap
;
decoder
-
>
setSampleSize
(
opts
.
fSampleSize
)
;
decoder
-
>
setRequireUnpremultipliedColors
(
opts
.
fRequireUnpremul
)
;
if
(
!
decoder
-
>
decode
(
stream
&
bitmap
SkImageDecoder
:
:
kDecodeBounds_Mode
)
)
{
return
nullptr
;
}
if
(
kUnknown_SkColorType
=
=
bitmap
.
colorType
(
)
)
{
return
nullptr
;
}
SkImageInfo
info
=
bitmap
.
info
(
)
;
if
(
opts
.
fUseRequestedColorType
&
&
(
opts
.
fRequestedColorType
!
=
info
.
colorType
(
)
)
)
{
if
(
!
bitmap
.
canCopyTo
(
opts
.
fRequestedColorType
)
)
{
SkASSERT
(
bitmap
.
colorType
(
)
!
=
opts
.
fRequestedColorType
)
;
return
nullptr
;
}
info
=
info
.
makeColorType
(
opts
.
fRequestedColorType
)
;
}
if
(
opts
.
fRequireUnpremul
&
&
info
.
alphaType
(
)
!
=
kOpaque_SkAlphaType
)
{
info
=
info
.
makeAlphaType
(
kUnpremul_SkAlphaType
)
;
}
SkAlphaType
newAlphaType
=
info
.
alphaType
(
)
;
if
(
!
SkColorTypeValidateAlphaType
(
info
.
colorType
(
)
info
.
alphaType
(
)
&
newAlphaType
)
)
{
return
nullptr
;
}
return
new
DecodingImageGenerator
(
data
autoStream
.
detach
(
)
info
.
makeAlphaType
(
newAlphaType
)
opts
.
fSampleSize
opts
.
fDitherImage
)
;
}
}
SkImageGenerator
*
SkDecodingImageGenerator
:
:
Create
(
SkData
*
data
const
SkDecodingImageGenerator
:
:
Options
&
opts
)
{
SkASSERT
(
data
!
=
nullptr
)
;
if
(
nullptr
=
=
data
)
{
return
nullptr
;
}
SkStreamRewindable
*
stream
=
new
SkMemoryStream
(
data
)
;
SkASSERT
(
stream
!
=
nullptr
)
;
return
CreateDecodingImageGenerator
(
data
stream
opts
)
;
}
SkImageGenerator
*
SkDecodingImageGenerator
:
:
Create
(
SkStreamRewindable
*
stream
const
SkDecodingImageGenerator
:
:
Options
&
opts
)
{
SkASSERT
(
stream
!
=
nullptr
)
;
if
(
stream
=
=
nullptr
)
{
return
nullptr
;
}
return
CreateDecodingImageGenerator
(
nullptr
stream
opts
)
;
}
