#
include
"
SkColorPriv
.
h
"
#
include
"
SkImageEncoder
.
h
"
#
include
"
SkImageGenerator
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkStreamPriv
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
ktx
.
h
"
#
include
"
etc1
.
h
"
class
SkKTXImageEncoder
:
public
SkImageEncoder
{
protected
:
bool
onEncode
(
SkWStream
*
stream
const
SkBitmap
&
bm
int
quality
)
override
;
private
:
virtual
bool
encodePKM
(
SkWStream
*
stream
const
SkData
*
data
)
;
typedef
SkImageEncoder
INHERITED
;
}
;
bool
SkKTXImageEncoder
:
:
onEncode
(
SkWStream
*
stream
const
SkBitmap
&
bitmap
int
)
{
if
(
!
bitmap
.
pixelRef
(
)
)
{
return
false
;
}
sk_sp
<
SkData
>
data
(
bitmap
.
pixelRef
(
)
-
>
refEncodedData
(
)
)
;
if
(
data
)
{
const
uint8_t
*
bytes
=
data
-
>
bytes
(
)
;
if
(
etc1_pkm_is_valid
(
bytes
)
)
{
return
this
-
>
encodePKM
(
stream
data
.
get
(
)
)
;
}
if
(
SkKTXFile
:
:
is_ktx
(
bytes
data
-
>
size
(
)
)
)
{
return
stream
-
>
write
(
bytes
data
-
>
size
(
)
)
;
}
}
return
SkKTXFile
:
:
WriteBitmapToKTX
(
stream
bitmap
)
;
}
bool
SkKTXImageEncoder
:
:
encodePKM
(
SkWStream
*
stream
const
SkData
*
data
)
{
const
uint8_t
*
bytes
=
data
-
>
bytes
(
)
;
SkASSERT
(
etc1_pkm_is_valid
(
bytes
)
)
;
etc1_uint32
width
=
etc1_pkm_get_width
(
bytes
)
;
etc1_uint32
height
=
etc1_pkm_get_height
(
bytes
)
;
if
(
width
=
=
0
|
|
(
width
&
3
)
!
=
0
|
|
height
=
=
0
|
|
(
height
&
3
)
!
=
0
)
{
return
false
;
}
bytes
+
=
ETC_PKM_HEADER_SIZE
;
return
SkKTXFile
:
:
WriteETC1ToKTX
(
stream
bytes
width
height
)
;
}
DEFINE_ENCODER_CREATOR
(
KTXImageEncoder
)
;
SkImageEncoder
*
sk_libktx_efactory
(
SkImageEncoder
:
:
Type
t
)
{
return
(
SkImageEncoder
:
:
kKTX_Type
=
=
t
)
?
new
SkKTXImageEncoder
:
nullptr
;
}
static
SkImageEncoder_EncodeReg
gEReg
(
sk_libktx_efactory
)
;
