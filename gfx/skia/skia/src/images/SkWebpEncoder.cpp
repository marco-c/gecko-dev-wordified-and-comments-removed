#
include
"
src
/
images
/
SkImageEncoderPriv
.
h
"
#
ifdef
SK_HAS_WEBP_LIBRARY
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkUnPreMultiply
.
h
"
#
include
"
include
/
encode
/
SkWebpEncoder
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
#
include
"
src
/
images
/
SkImageEncoderFns
.
h
"
#
include
"
src
/
utils
/
SkUTF
.
h
"
#
include
<
stdio
.
h
>
extern
"
C
"
{
#
include
"
webp
/
encode
.
h
"
#
include
"
webp
/
mux
.
h
"
}
static
transform_scanline_proc
choose_proc
(
const
SkImageInfo
&
info
)
{
switch
(
info
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
switch
(
info
.
alphaType
(
)
)
{
case
kOpaque_SkAlphaType
:
return
transform_scanline_RGBX
;
case
kUnpremul_SkAlphaType
:
return
transform_scanline_memcpy
;
case
kPremul_SkAlphaType
:
return
transform_scanline_rgbA
;
default
:
return
nullptr
;
}
case
kBGRA_8888_SkColorType
:
switch
(
info
.
alphaType
(
)
)
{
case
kOpaque_SkAlphaType
:
return
transform_scanline_BGRX
;
case
kUnpremul_SkAlphaType
:
return
transform_scanline_BGRA
;
case
kPremul_SkAlphaType
:
return
transform_scanline_bgrA
;
default
:
return
nullptr
;
}
case
kRGB_565_SkColorType
:
if
(
!
info
.
isOpaque
(
)
)
{
return
nullptr
;
}
return
transform_scanline_565
;
case
kARGB_4444_SkColorType
:
switch
(
info
.
alphaType
(
)
)
{
case
kOpaque_SkAlphaType
:
return
transform_scanline_444
;
case
kPremul_SkAlphaType
:
return
transform_scanline_4444
;
default
:
return
nullptr
;
}
case
kGray_8_SkColorType
:
return
transform_scanline_gray
;
case
kRGBA_F16_SkColorType
:
switch
(
info
.
alphaType
(
)
)
{
case
kOpaque_SkAlphaType
:
case
kUnpremul_SkAlphaType
:
return
transform_scanline_F16_to_8888
;
case
kPremul_SkAlphaType
:
return
transform_scanline_F16_premul_to_8888
;
default
:
return
nullptr
;
}
default
:
return
nullptr
;
}
}
static
int
stream_writer
(
const
uint8_t
*
data
size_t
data_size
const
WebPPicture
*
const
picture
)
{
SkWStream
*
const
stream
=
(
SkWStream
*
)
picture
-
>
custom_ptr
;
return
stream
-
>
write
(
data
data_size
)
?
1
:
0
;
}
bool
SkWebpEncoder
:
:
Encode
(
SkWStream
*
stream
const
SkPixmap
&
pixmap
const
Options
&
opts
)
{
if
(
!
SkPixmapIsValid
(
pixmap
)
)
{
return
false
;
}
const
transform_scanline_proc
proc
=
choose_proc
(
pixmap
.
info
(
)
)
;
if
(
!
proc
)
{
return
false
;
}
int
bpp
;
if
(
kRGBA_F16_SkColorType
=
=
pixmap
.
colorType
(
)
)
{
bpp
=
4
;
}
else
{
bpp
=
pixmap
.
isOpaque
(
)
?
3
:
4
;
}
if
(
nullptr
=
=
pixmap
.
addr
(
)
)
{
return
false
;
}
WebPConfig
webp_config
;
if
(
!
WebPConfigPreset
(
&
webp_config
WEBP_PRESET_DEFAULT
opts
.
fQuality
)
)
{
return
false
;
}
WebPPicture
pic
;
WebPPictureInit
(
&
pic
)
;
SkAutoTCallVProc
<
WebPPicture
WebPPictureFree
>
autoPic
(
&
pic
)
;
pic
.
width
=
pixmap
.
width
(
)
;
pic
.
height
=
pixmap
.
height
(
)
;
pic
.
writer
=
stream_writer
;
if
(
Compression
:
:
kLossy
=
=
opts
.
fCompression
)
{
webp_config
.
lossless
=
0
;
#
ifndef
SK_WEBP_ENCODER_USE_DEFAULT_METHOD
webp_config
.
method
=
3
;
#
endif
pic
.
use_argb
=
0
;
}
else
{
webp_config
.
lossless
=
1
;
webp_config
.
method
=
0
;
pic
.
use_argb
=
1
;
}
sk_sp
<
SkData
>
icc
=
icc_from_color_space
(
pixmap
.
info
(
)
)
;
SkDynamicMemoryWStream
tmp
;
pic
.
custom_ptr
=
icc
?
(
void
*
)
&
tmp
:
(
void
*
)
stream
;
const
uint8_t
*
src
=
(
uint8_t
*
)
pixmap
.
addr
(
)
;
const
int
rgbStride
=
pic
.
width
*
bpp
;
const
size_t
rowBytes
=
pixmap
.
rowBytes
(
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
rgb
(
new
uint8_t
[
rgbStride
*
pic
.
height
]
)
;
for
(
int
y
=
0
;
y
<
pic
.
height
;
+
+
y
)
{
proc
(
(
char
*
)
&
rgb
[
y
*
rgbStride
]
(
const
char
*
)
&
src
[
y
*
rowBytes
]
pic
.
width
bpp
)
;
}
auto
importProc
=
WebPPictureImportRGB
;
if
(
3
!
=
bpp
)
{
if
(
pixmap
.
isOpaque
(
)
)
{
importProc
=
WebPPictureImportRGBX
;
}
else
{
importProc
=
WebPPictureImportRGBA
;
}
}
if
(
!
importProc
(
&
pic
&
rgb
[
0
]
rgbStride
)
)
{
return
false
;
}
if
(
!
WebPEncode
(
&
webp_config
&
pic
)
)
{
return
false
;
}
if
(
icc
)
{
sk_sp
<
SkData
>
encodedData
=
tmp
.
detachAsData
(
)
;
WebPData
encoded
=
{
encodedData
-
>
bytes
(
)
encodedData
-
>
size
(
)
}
;
WebPData
iccChunk
=
{
icc
-
>
bytes
(
)
icc
-
>
size
(
)
}
;
SkAutoTCallVProc
<
WebPMux
WebPMuxDelete
>
mux
(
WebPMuxNew
(
)
)
;
if
(
WEBP_MUX_OK
!
=
WebPMuxSetImage
(
mux
&
encoded
0
)
)
{
return
false
;
}
if
(
WEBP_MUX_OK
!
=
WebPMuxSetChunk
(
mux
"
ICCP
"
&
iccChunk
0
)
)
{
return
false
;
}
WebPData
assembled
;
if
(
WEBP_MUX_OK
!
=
WebPMuxAssemble
(
mux
&
assembled
)
)
{
return
false
;
}
stream
-
>
write
(
assembled
.
bytes
assembled
.
size
)
;
WebPDataClear
(
&
assembled
)
;
}
return
true
;
}
#
endif
