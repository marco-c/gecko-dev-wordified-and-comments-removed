#
ifndef
SkLinearBitmapPipeline_core_DEFINED
#
define
SkLinearBitmapPipeline_core_DEFINED
#
include
<
cmath
>
#
if
defined
(
_MSC_VER
)
&
&
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE2
#
define
VECTORCALL
__vectorcall
#
elif
defined
(
SK_CPU_ARM32
)
&
&
defined
(
SK_ARM_HAS_NEON
)
#
define
VECTORCALL
__attribute__
(
(
pcs
(
"
aapcs
-
vfp
"
)
)
)
#
else
#
define
VECTORCALL
#
endif
namespace
{
struct
X
{
explicit
X
(
SkScalar
val
)
:
fVal
{
val
}
{
}
explicit
X
(
SkPoint
pt
)
:
fVal
{
pt
.
fX
}
{
}
explicit
X
(
SkSize
s
)
:
fVal
{
s
.
fWidth
}
{
}
explicit
X
(
SkISize
s
)
:
fVal
(
(
SkScalar
)
s
.
fWidth
)
{
}
operator
SkScalar
(
)
const
{
return
fVal
;
}
private
:
SkScalar
fVal
;
}
;
struct
Y
{
explicit
Y
(
SkScalar
val
)
:
fVal
{
val
}
{
}
explicit
Y
(
SkPoint
pt
)
:
fVal
{
pt
.
fY
}
{
}
explicit
Y
(
SkSize
s
)
:
fVal
{
s
.
fHeight
}
{
}
explicit
Y
(
SkISize
s
)
:
fVal
(
(
SkScalar
)
s
.
fHeight
)
{
}
operator
SkScalar
(
)
const
{
return
fVal
;
}
private
:
SkScalar
fVal
;
}
;
class
Span
{
public
:
Span
(
SkPoint
start
SkScalar
length
int
count
)
:
fStart
(
start
)
fLength
(
length
)
fCount
{
count
}
{
SkASSERT
(
std
:
:
isfinite
(
length
)
)
;
}
operator
std
:
:
tuple
<
SkPoint
&
SkScalar
&
int
&
>
(
)
{
return
std
:
:
tie
(
fStart
fLength
fCount
)
;
}
bool
isEmpty
(
)
const
{
return
0
=
=
fCount
;
}
void
clear
(
)
{
fCount
=
0
;
}
int
count
(
)
const
{
return
fCount
;
}
SkScalar
length
(
)
const
{
return
fLength
;
}
SkScalar
startX
(
)
const
{
return
X
(
fStart
)
;
}
SkScalar
endX
(
)
const
{
return
this
-
>
startX
(
)
+
this
-
>
length
(
)
;
}
SkScalar
startY
(
)
const
{
return
Y
(
fStart
)
;
}
Span
emptySpan
(
)
{
return
Span
{
{
0
.
0
0
.
0
}
0
.
0f
0
}
;
}
bool
completelyWithin
(
SkScalar
xMin
SkScalar
xMax
)
const
{
SkScalar
sMin
=
startX
(
)
sMax
=
endX
(
)
;
if
(
sMax
<
sMin
)
{
std
:
:
swap
(
sMin
sMax
)
;
}
return
xMin
<
=
sMin
&
&
sMax
<
xMax
;
}
void
offset
(
SkScalar
offsetX
)
{
fStart
.
offset
(
offsetX
0
.
0f
)
;
}
Span
breakAt
(
SkScalar
breakX
SkScalar
dx
)
{
SkASSERT
(
std
:
:
isfinite
(
breakX
)
)
;
SkASSERT
(
std
:
:
isfinite
(
dx
)
)
;
SkASSERT
(
dx
!
=
0
.
0f
)
;
if
(
this
-
>
isEmpty
(
)
)
{
return
this
-
>
emptySpan
(
)
;
}
int
dxSteps
=
SkScalarFloorToInt
(
(
breakX
-
this
-
>
startX
(
)
)
/
dx
)
;
if
(
dxSteps
<
0
)
{
return
this
-
>
emptySpan
(
)
;
}
else
if
(
dxSteps
>
=
fCount
)
{
Span
answer
=
*
this
;
this
-
>
clear
(
)
;
return
answer
;
}
SkScalar
newLength
=
dxSteps
*
dx
;
if
(
this
-
>
startX
(
)
+
newLength
=
=
breakX
&
&
dx
>
0
)
{
if
(
dxSteps
>
0
)
{
dxSteps
-
=
1
;
newLength
-
=
dx
;
}
else
{
return
this
-
>
emptySpan
(
)
;
}
}
SkPoint
newStart
=
fStart
;
int
newCount
=
dxSteps
+
1
;
SkASSERT
(
newCount
>
0
)
;
SkScalar
lengthToStart
=
newLength
+
dx
;
fLength
-
=
lengthToStart
;
fCount
-
=
newCount
;
fStart
=
{
this
-
>
startX
(
)
+
lengthToStart
Y
(
fStart
)
}
;
return
Span
{
newStart
newLength
newCount
}
;
}
void
clampToSinglePixel
(
SkPoint
pixel
)
{
fStart
=
pixel
;
fLength
=
0
.
0f
;
}
private
:
SkPoint
fStart
;
SkScalar
fLength
;
int
fCount
;
}
;
template
<
typename
Stage
>
void
span_fallback
(
Span
span
Stage
*
stage
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
Sk4f
xs
{
X
(
start
)
}
;
Sk4f
ys
{
Y
(
start
)
}
;
Sk4s
fourDx
{
0
.
0f
}
;
if
(
count
>
1
)
{
SkScalar
dx
=
length
/
(
count
-
1
)
;
xs
=
xs
+
Sk4f
{
0
.
0f
1
.
0f
2
.
0f
3
.
0f
}
*
dx
;
fourDx
=
Sk4f
{
4
.
0f
*
dx
}
;
}
while
(
count
>
=
4
)
{
stage
-
>
pointList4
(
xs
ys
)
;
xs
=
xs
+
fourDx
;
count
-
=
4
;
}
if
(
count
>
0
)
{
stage
-
>
pointListFew
(
count
xs
ys
)
;
}
}
}
#
endif
