#
ifndef
SkLinearBitmapPipeline_core_DEFINED
#
define
SkLinearBitmapPipeline_core_DEFINED
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
"
SkNx
.
h
"
namespace
{
struct
X
{
explicit
X
(
SkScalar
val
)
:
fVal
{
val
}
{
}
explicit
X
(
SkPoint
pt
)
:
fVal
{
pt
.
fX
}
{
}
explicit
X
(
SkSize
s
)
:
fVal
{
s
.
fWidth
}
{
}
explicit
X
(
SkISize
s
)
:
fVal
(
(
SkScalar
)
s
.
fWidth
)
{
}
operator
SkScalar
(
)
const
{
return
fVal
;
}
private
:
SkScalar
fVal
;
}
;
struct
Y
{
explicit
Y
(
SkScalar
val
)
:
fVal
{
val
}
{
}
explicit
Y
(
SkPoint
pt
)
:
fVal
{
pt
.
fY
}
{
}
explicit
Y
(
SkSize
s
)
:
fVal
{
s
.
fHeight
}
{
}
explicit
Y
(
SkISize
s
)
:
fVal
(
(
SkScalar
)
s
.
fHeight
)
{
}
operator
SkScalar
(
)
const
{
return
fVal
;
}
private
:
SkScalar
fVal
;
}
;
class
Span
{
public
:
Span
(
SkPoint
start
SkScalar
length
int
count
)
:
fStart
(
start
)
fLength
(
length
)
fCount
{
count
}
{
SkASSERT
(
std
:
:
isfinite
(
length
)
)
;
}
operator
std
:
:
tuple
<
SkPoint
&
SkScalar
&
int
&
>
(
)
{
return
std
:
:
tie
(
fStart
fLength
fCount
)
;
}
bool
isEmpty
(
)
const
{
return
0
=
=
fCount
;
}
void
clear
(
)
{
fCount
=
0
;
}
int
count
(
)
const
{
return
fCount
;
}
SkScalar
length
(
)
const
{
return
fLength
;
}
SkScalar
startX
(
)
const
{
return
X
(
fStart
)
;
}
SkScalar
endX
(
)
const
{
return
this
-
>
startX
(
)
+
this
-
>
length
(
)
;
}
SkScalar
startY
(
)
const
{
return
Y
(
fStart
)
;
}
Span
emptySpan
(
)
{
return
Span
{
{
0
.
0
0
.
0
}
0
.
0f
0
}
;
}
bool
completelyWithin
(
SkScalar
xMin
SkScalar
xMax
)
const
{
SkScalar
sMin
sMax
;
std
:
:
tie
(
sMin
sMax
)
=
std
:
:
minmax
(
startX
(
)
endX
(
)
)
;
return
xMin
<
=
sMin
&
&
sMax
<
xMax
;
}
void
offset
(
SkScalar
offsetX
)
{
fStart
.
offset
(
offsetX
0
.
0f
)
;
}
Span
breakAt
(
SkScalar
breakX
SkScalar
dx
)
{
SkASSERT
(
std
:
:
isfinite
(
breakX
)
)
;
SkASSERT
(
std
:
:
isfinite
(
dx
)
)
;
SkASSERT
(
dx
!
=
0
.
0f
)
;
if
(
this
-
>
isEmpty
(
)
)
{
return
this
-
>
emptySpan
(
)
;
}
int
dxSteps
=
SkScalarFloorToInt
(
(
breakX
-
this
-
>
startX
(
)
)
/
dx
)
;
if
(
dxSteps
<
0
)
{
return
this
-
>
emptySpan
(
)
;
}
else
if
(
dxSteps
>
=
fCount
)
{
Span
answer
=
*
this
;
this
-
>
clear
(
)
;
return
answer
;
}
SkScalar
newLength
=
dxSteps
*
dx
;
if
(
this
-
>
startX
(
)
+
newLength
=
=
breakX
&
&
dx
>
0
)
{
if
(
dxSteps
>
0
)
{
dxSteps
-
=
1
;
newLength
-
=
dx
;
}
else
{
return
this
-
>
emptySpan
(
)
;
}
}
SkPoint
newStart
=
fStart
;
int
newCount
=
dxSteps
+
1
;
SkASSERT
(
newCount
>
0
)
;
SkScalar
lengthToStart
=
newLength
+
dx
;
fLength
-
=
lengthToStart
;
fCount
-
=
newCount
;
fStart
=
{
this
-
>
startX
(
)
+
lengthToStart
Y
(
fStart
)
}
;
return
Span
{
newStart
newLength
newCount
}
;
}
void
clampToSinglePixel
(
SkPoint
pixel
)
{
fStart
=
pixel
;
fLength
=
0
.
0f
;
}
private
:
SkPoint
fStart
;
SkScalar
fLength
;
int
fCount
;
}
;
template
<
typename
Stage
>
void
span_fallback
(
Span
span
Stage
*
stage
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
Sk4f
xs
{
X
(
start
)
}
;
Sk4f
ys
{
Y
(
start
)
}
;
Sk4s
fourDx
{
0
.
0f
}
;
if
(
count
>
1
)
{
SkScalar
dx
=
length
/
(
count
-
1
)
;
xs
=
xs
+
Sk4f
{
0
.
0f
1
.
0f
2
.
0f
3
.
0f
}
*
dx
;
fourDx
=
Sk4f
{
4
.
0f
*
dx
}
;
}
while
(
count
>
=
4
)
{
stage
-
>
pointList4
(
xs
ys
)
;
xs
=
xs
+
fourDx
;
count
-
=
4
;
}
if
(
count
>
0
)
{
stage
-
>
pointListFew
(
count
xs
ys
)
;
}
}
inline
Sk4f
SK_VECTORCALL
check_pixel
(
const
Sk4f
&
pixel
)
{
SkASSERTF
(
0
.
0f
<
=
pixel
[
0
]
&
&
pixel
[
0
]
<
=
1
.
0f
"
pixel
[
0
]
:
%
f
"
pixel
[
0
]
)
;
SkASSERTF
(
0
.
0f
<
=
pixel
[
1
]
&
&
pixel
[
1
]
<
=
1
.
0f
"
pixel
[
1
]
:
%
f
"
pixel
[
1
]
)
;
SkASSERTF
(
0
.
0f
<
=
pixel
[
2
]
&
&
pixel
[
2
]
<
=
1
.
0f
"
pixel
[
2
]
:
%
f
"
pixel
[
2
]
)
;
SkASSERTF
(
0
.
0f
<
=
pixel
[
3
]
&
&
pixel
[
3
]
<
=
1
.
0f
"
pixel
[
3
]
:
%
f
"
pixel
[
3
]
)
;
return
pixel
;
}
}
class
SkLinearBitmapPipeline
:
:
PointProcessorInterface
{
public
:
virtual
~
PointProcessorInterface
(
)
{
}
virtual
void
SK_VECTORCALL
pointListFew
(
int
n
Sk4s
xs
Sk4s
ys
)
=
0
;
virtual
void
SK_VECTORCALL
pointList4
(
Sk4s
xs
Sk4s
ys
)
=
0
;
virtual
void
pointSpan
(
Span
span
)
=
0
;
}
;
class
SkLinearBitmapPipeline
:
:
SampleProcessorInterface
:
public
SkLinearBitmapPipeline
:
:
PointProcessorInterface
{
public
:
virtual
void
repeatSpan
(
Span
span
int32_t
repeatCount
)
=
0
;
}
;
class
SkLinearBitmapPipeline
:
:
DestinationInterface
{
public
:
virtual
~
DestinationInterface
(
)
{
}
virtual
void
setDestination
(
void
*
dst
int
count
)
=
0
;
}
;
class
SkLinearBitmapPipeline
:
:
BlendProcessorInterface
:
public
SkLinearBitmapPipeline
:
:
DestinationInterface
{
public
:
virtual
void
SK_VECTORCALL
blendPixel
(
Sk4f
pixel0
)
=
0
;
virtual
void
SK_VECTORCALL
blend4Pixels
(
Sk4f
p0
Sk4f
p1
Sk4f
p2
Sk4f
p3
)
=
0
;
}
;
class
SkLinearBitmapPipeline
:
:
PixelAccessorInterface
{
public
:
virtual
~
PixelAccessorInterface
(
)
{
}
virtual
void
SK_VECTORCALL
getFewPixels
(
int
n
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
)
const
=
0
;
virtual
void
SK_VECTORCALL
get4Pixels
(
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
=
0
;
virtual
void
get4Pixels
(
const
void
*
src
int
index
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
=
0
;
virtual
Sk4f
getPixelFromRow
(
const
void
*
row
int
index
)
const
=
0
;
virtual
Sk4f
getPixelAt
(
int
index
)
const
=
0
;
virtual
const
void
*
row
(
int
y
)
const
=
0
;
}
;
#
endif
