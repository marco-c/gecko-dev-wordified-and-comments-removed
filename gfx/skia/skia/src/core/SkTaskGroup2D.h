#
ifndef
SkTaskGroup2D_DEFINED
#
define
SkTaskGroup2D_DEFINED
#
include
"
SkTaskGroup
.
h
"
#
include
"
SkMutex
.
h
"
#
include
<
vector
>
class
SkWorkKernel2D
{
public
:
virtual
bool
work2D
(
int
row
int
column
int
thread
)
=
0
;
virtual
bool
initColumn
(
int
column
int
thread
)
=
0
;
virtual
~
SkWorkKernel2D
(
)
{
}
}
;
class
SkTaskGroup2D
{
public
:
SkTaskGroup2D
(
SkWorkKernel2D
*
kernel
int
height
SkExecutor
*
executor
int
threadCnt
)
:
fKernel
(
kernel
)
fHeight
(
height
)
fThreadCnt
(
threadCnt
)
fIsFinishing
(
false
)
fWidth
(
0
)
fThreadsGroup
(
new
SkTaskGroup
(
*
executor
)
)
{
}
virtual
~
SkTaskGroup2D
(
)
{
}
virtual
void
addColumn
(
)
;
void
start
(
)
;
void
finish
(
)
;
SK_ALWAYS_INLINE
bool
isFinishing
(
)
const
{
return
fIsFinishing
.
load
(
std
:
:
memory_order_relaxed
)
;
}
protected
:
static
constexpr
int
MAX_CACHE_LINE
=
64
;
virtual
void
work
(
int
threadId
)
=
0
;
void
initAnUninitializedColumn
(
int
&
initCol
int
threadId
)
{
bool
didSomeInit
=
false
;
while
(
initCol
<
fWidth
&
&
!
didSomeInit
)
{
didSomeInit
=
fKernel
-
>
initColumn
(
initCol
+
+
threadId
)
;
}
}
SkWorkKernel2D
*
fKernel
;
const
int
fHeight
;
const
int
fThreadCnt
;
std
:
:
atomic
<
bool
>
fIsFinishing
;
std
:
:
atomic
<
int
>
fWidth
;
std
:
:
unique_ptr
<
SkTaskGroup
>
fThreadsGroup
;
}
;
class
SkSpinningTaskGroup2D
final
:
public
SkTaskGroup2D
{
public
:
SkSpinningTaskGroup2D
(
SkWorkKernel2D
*
kernel
int
h
SkExecutor
*
x
int
t
)
:
SkTaskGroup2D
(
kernel
h
x
t
)
{
SkASSERT
(
h
=
=
t
)
;
}
protected
:
void
work
(
int
threadId
)
override
;
}
;
class
SkFlexibleTaskGroup2D
final
:
public
SkTaskGroup2D
{
public
:
SkFlexibleTaskGroup2D
(
SkWorkKernel2D
*
kernel
int
h
SkExecutor
*
x
int
t
)
:
SkTaskGroup2D
(
kernel
h
x
t
)
fRowData
(
h
)
{
}
protected
:
void
work
(
int
threadId
)
override
;
private
:
struct
alignas
(
MAX_CACHE_LINE
)
RowData
{
RowData
(
)
:
fNextColumn
(
0
)
{
}
int
fNextColumn
;
SkMutex
fMutex
;
}
;
std
:
:
vector
<
RowData
>
fRowData
;
}
;
#
endif
