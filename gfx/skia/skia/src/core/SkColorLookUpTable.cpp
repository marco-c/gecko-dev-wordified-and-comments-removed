#
include
"
SkColorLookUpTable
.
h
"
#
include
"
SkColorSpaceXformPriv
.
h
"
#
include
"
SkFloatingPoint
.
h
"
void
SkColorLookUpTable
:
:
interp
(
float
*
dst
const
float
*
src
)
const
{
if
(
fInputChannels
=
=
3
)
{
interp3D
(
dst
src
)
;
}
else
{
SkASSERT
(
dst
!
=
src
)
;
int
index
[
kMaxColorChannels
]
;
for
(
uint8_t
outputDimension
=
0
;
outputDimension
<
kOutputChannels
;
+
+
outputDimension
)
{
dst
[
outputDimension
]
=
interpDimension
(
src
fInputChannels
-
1
outputDimension
index
)
;
}
}
}
void
SkColorLookUpTable
:
:
interp3D
(
float
*
dst
const
float
*
src
)
const
{
SkASSERT
(
3
=
=
kOutputChannels
)
;
const
uint8_t
maxX
=
fGridPoints
[
0
]
-
1
;
const
uint8_t
maxY
=
fGridPoints
[
1
]
-
1
;
const
uint8_t
maxZ
=
fGridPoints
[
2
]
-
1
;
const
float
x
=
src
[
0
]
*
maxX
;
const
float
y
=
src
[
1
]
*
maxY
;
const
float
z
=
src
[
2
]
*
maxZ
;
int
ix
=
sk_float_floor2int
(
x
)
;
int
iy
=
sk_float_floor2int
(
y
)
;
int
iz
=
sk_float_floor2int
(
z
)
;
ix
=
(
maxX
=
=
ix
)
?
ix
-
1
:
ix
;
iy
=
(
maxY
=
=
iy
)
?
iy
-
1
:
iy
;
iz
=
(
maxZ
=
=
iz
)
?
iz
-
1
:
iz
;
const
float
diffX
=
x
-
ix
;
const
float
diffY
=
y
-
iy
;
const
float
diffZ
=
z
-
iz
;
const
int
n000
=
0
;
const
int
n001
=
3
*
fGridPoints
[
1
]
*
fGridPoints
[
2
]
;
const
int
n010
=
3
*
fGridPoints
[
2
]
;
const
int
n011
=
n001
+
n010
;
const
int
n100
=
3
;
const
int
n101
=
n100
+
n001
;
const
int
n110
=
n100
+
n010
;
const
int
n111
=
n110
+
n001
;
const
float
*
ptr
=
&
(
table
(
)
[
ix
*
n001
+
iy
*
n010
+
iz
*
n100
]
)
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
if
(
diffZ
<
diffY
)
{
if
(
diffZ
>
diffX
)
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n110
]
-
ptr
[
n010
]
)
+
diffY
*
(
ptr
[
n010
]
-
ptr
[
n000
]
)
+
diffX
*
(
ptr
[
n111
]
-
ptr
[
n110
]
)
)
;
}
else
if
(
diffY
<
diffX
)
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n111
]
-
ptr
[
n011
]
)
+
diffY
*
(
ptr
[
n011
]
-
ptr
[
n001
]
)
+
diffX
*
(
ptr
[
n001
]
-
ptr
[
n000
]
)
)
;
}
else
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n111
]
-
ptr
[
n011
]
)
+
diffY
*
(
ptr
[
n010
]
-
ptr
[
n000
]
)
+
diffX
*
(
ptr
[
n011
]
-
ptr
[
n010
]
)
)
;
}
}
else
{
if
(
diffZ
<
diffX
)
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n101
]
-
ptr
[
n001
]
)
+
diffY
*
(
ptr
[
n111
]
-
ptr
[
n101
]
)
+
diffX
*
(
ptr
[
n001
]
-
ptr
[
n000
]
)
)
;
}
else
if
(
diffY
<
diffX
)
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n100
]
-
ptr
[
n000
]
)
+
diffY
*
(
ptr
[
n111
]
-
ptr
[
n101
]
)
+
diffX
*
(
ptr
[
n101
]
-
ptr
[
n100
]
)
)
;
}
else
{
dst
[
i
]
=
(
ptr
[
n000
]
+
diffZ
*
(
ptr
[
n100
]
-
ptr
[
n000
]
)
+
diffY
*
(
ptr
[
n110
]
-
ptr
[
n100
]
)
+
diffX
*
(
ptr
[
n111
]
-
ptr
[
n110
]
)
)
;
}
}
dst
[
i
]
=
clamp_0_1
(
dst
[
i
]
)
;
ptr
+
+
;
}
}
float
SkColorLookUpTable
:
:
interpDimension
(
const
float
*
src
int
inputDimension
int
outputDimension
int
index
[
kMaxColorChannels
]
)
const
{
if
(
inputDimension
<
0
)
{
int
outputIndex
=
outputDimension
;
int
indexMultiplier
=
kOutputChannels
;
for
(
int
i
=
fInputChannels
-
1
;
i
>
=
0
;
-
-
i
)
{
outputIndex
+
=
index
[
i
]
*
indexMultiplier
;
indexMultiplier
*
=
fGridPoints
[
i
]
;
}
return
table
(
)
[
outputIndex
]
;
}
const
float
x
=
src
[
inputDimension
]
*
(
fGridPoints
[
inputDimension
]
-
1
)
;
index
[
inputDimension
]
=
sk_float_floor2int
(
x
)
;
const
float
diff
=
x
-
index
[
inputDimension
]
;
const
float
lo
=
interpDimension
(
src
inputDimension
-
1
outputDimension
index
)
;
index
[
inputDimension
]
=
sk_float_ceil2int
(
x
)
;
const
float
hi
=
interpDimension
(
src
inputDimension
-
1
outputDimension
index
)
;
return
clamp_0_1
(
(
1
-
diff
)
*
lo
+
diff
*
hi
)
;
}
