#
include
"
SkNormalBevelSource
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkNormalSource
.
h
"
#
include
"
SkNormalSourcePriv
.
h
"
#
include
"
SkPoint3
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
SkGr
.
h
"
class
NormalBevelFP
:
public
GrFragmentProcessor
{
public
:
NormalBevelFP
(
SkNormalSource
:
:
BevelType
bevelType
SkScalar
bevelWidth
SkScalar
bevelHeight
)
:
INHERITED
(
kNone_OptimizationFlags
)
fBevelType
(
bevelType
)
fBevelWidth
(
bevelWidth
)
fBevelHeight
(
bevelHeight
)
{
this
-
>
initClassID
<
NormalBevelFP
>
(
)
;
this
-
>
setWillUseDistanceVectorField
(
)
;
}
class
GLSLNormalBevelFP
:
public
GLSLNormalFP
{
public
:
GLSLNormalBevelFP
(
)
{
fPrevWidth
=
SkFloatToScalar
(
0
.
0f
)
;
fPrevHeight
=
SkFloatToScalar
(
0
.
0f
)
;
}
void
onEmitCode
(
EmitArgs
&
args
)
override
{
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
const
NormalBevelFP
&
fp
=
args
.
fFp
.
cast
<
NormalBevelFP
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
bool
needWidth
=
true
;
bool
needHeight
=
(
fp
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedOut
|
|
fp
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedIn
)
;
bool
needNormalized
=
(
fp
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kLinear
)
;
const
char
*
widthUniName
=
nullptr
;
if
(
needWidth
)
{
fWidthUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kFloat_GrSLType
kDefault_GrSLPrecision
"
Width
"
&
widthUniName
)
;
}
const
char
*
heightUniName
=
nullptr
;
if
(
needHeight
)
{
fHeightUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kFloat_GrSLType
kDefault_GrSLPrecision
"
Height
"
&
heightUniName
)
;
}
const
char
*
normalizedWidthUniName
=
nullptr
;
const
char
*
normalizedHeightUniName
=
nullptr
;
if
(
needNormalized
)
{
fNormalizedWidthUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kFloat_GrSLType
kDefault_GrSLPrecision
"
NormalizedWidth
"
&
normalizedWidthUniName
)
;
fNormalizedHeightUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kFloat_GrSLType
kDefault_GrSLPrecision
"
NormalizedHeight
"
&
normalizedHeightUniName
)
;
}
fragBuilder
-
>
codeAppendf
(
"
float
dv_length
=
%
s
.
z
;
"
fragBuilder
-
>
distanceVectorName
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
dv_norm
=
%
s
.
xy
;
"
fragBuilder
-
>
distanceVectorName
(
)
)
;
SkASSERT
(
widthUniName
)
;
fragBuilder
-
>
codeAppend
(
"
vec3
normal
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
if
(
dv_length
>
=
%
s
)
{
"
widthUniName
)
;
fragBuilder
-
>
codeAppend
(
"
normal
=
vec3
(
0
.
0
0
.
0
1
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
}
else
{
"
)
;
this
-
>
emitMath
(
fragBuilder
fp
.
fBevelType
widthUniName
heightUniName
normalizedWidthUniName
normalizedHeightUniName
)
;
fragBuilder
-
>
codeAppend
(
"
}
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
normal
0
.
0
)
;
"
args
.
fOutputColor
)
;
}
static
void
GenKey
(
const
GrProcessor
&
proc
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
NormalBevelFP
&
fp
=
proc
.
cast
<
NormalBevelFP
>
(
)
;
b
-
>
add32
(
static_cast
<
int
>
(
fp
.
fBevelType
)
)
;
}
protected
:
void
setNormalData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
proc
)
override
{
const
NormalBevelFP
&
normalBevelFP
=
proc
.
cast
<
NormalBevelFP
>
(
)
;
bool
needWidth
=
true
;
bool
needHeight
=
(
normalBevelFP
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedOut
|
|
normalBevelFP
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedIn
)
;
bool
needNormalized
=
(
normalBevelFP
.
fBevelType
=
=
SkNormalSource
:
:
BevelType
:
:
kLinear
)
;
bool
dirtyWidth
=
(
fPrevWidth
!
=
normalBevelFP
.
fBevelWidth
)
;
bool
dirtyHeight
=
(
fPrevHeight
!
=
normalBevelFP
.
fBevelHeight
)
;
bool
dirtyNormalized
=
(
dirtyHeight
|
|
dirtyWidth
)
;
if
(
needWidth
&
&
dirtyWidth
)
{
pdman
.
set1f
(
fWidthUni
normalBevelFP
.
fBevelWidth
)
;
fPrevWidth
=
normalBevelFP
.
fBevelWidth
;
}
if
(
needHeight
&
&
dirtyHeight
)
{
pdman
.
set1f
(
fHeightUni
normalBevelFP
.
fBevelHeight
)
;
fPrevHeight
=
normalBevelFP
.
fBevelHeight
;
}
if
(
needNormalized
&
&
dirtyNormalized
)
{
SkScalar
height
=
normalBevelFP
.
fBevelHeight
;
SkScalar
width
=
normalBevelFP
.
fBevelWidth
;
SkScalar
length
=
SkScalarSqrt
(
SkScalarSquare
(
height
)
+
SkScalarSquare
(
width
)
)
;
pdman
.
set1f
(
fNormalizedHeightUni
height
/
length
)
;
pdman
.
set1f
(
fNormalizedWidthUni
width
/
length
)
;
}
}
void
emitMath
(
GrGLSLFPFragmentBuilder
*
fb
SkNormalSource
:
:
BevelType
type
const
char
*
width
const
char
*
height
const
char
*
normalizedWidth
const
char
*
normalizedHeight
)
{
switch
(
type
)
{
case
SkNormalSource
:
:
BevelType
:
:
kLinear
:
SkASSERT
(
normalizedHeight
)
;
SkASSERT
(
normalizedWidth
)
;
fb
-
>
codeAppendf
(
"
normal
=
vec3
(
%
s
*
dv_norm
%
s
)
;
"
normalizedHeight
normalizedWidth
)
;
break
;
case
SkNormalSource
:
:
BevelType
:
:
kRoundedOut
:
case
SkNormalSource
:
:
BevelType
:
:
kRoundedIn
:
SkASSERT
(
height
)
;
SkASSERT
(
width
)
;
if
(
type
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedIn
)
{
fb
-
>
codeAppendf
(
"
float
currentPos_d
=
%
s
-
dv_length
;
"
width
)
;
}
else
if
(
type
=
=
SkNormalSource
:
:
BevelType
:
:
kRoundedOut
)
{
fb
-
>
codeAppendf
(
"
float
currentPos_d
=
dv_length
;
"
)
;
}
fb
-
>
codeAppendf
(
"
float
rootDOverW
=
sqrt
(
currentPos_d
/
%
s
)
;
"
width
)
;
fb
-
>
codeAppendf
(
"
vec2
unnormalizedNormal_dz
=
vec2
(
%
s
*
(
1
.
0
-
rootDOverW
)
"
"
%
s
*
rootDOverW
)
;
"
height
width
)
;
fb
-
>
codeAppendf
(
"
vec2
normal_dz
=
normalize
(
unnormalizedNormal_dz
)
;
"
)
;
fb
-
>
codeAppendf
(
"
normal
=
vec3
(
normal_dz
.
x
*
dv_norm
normal_dz
.
y
)
;
"
)
;
break
;
default
:
SkDEBUGFAIL
(
"
Invalid
bevel
type
passed
to
emitMath
"
)
;
}
}
private
:
SkScalar
fPrevWidth
;
GrGLSLProgramDataManager
:
:
UniformHandle
fWidthUni
;
SkScalar
fPrevHeight
;
GrGLSLProgramDataManager
:
:
UniformHandle
fHeightUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fNormalizedWidthUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fNormalizedHeightUni
;
}
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GLSLNormalBevelFP
:
:
GenKey
(
*
this
caps
b
)
;
}
const
char
*
name
(
)
const
override
{
return
"
NormalBevelFP
"
;
}
private
:
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
{
return
new
GLSLNormalBevelFP
;
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
proc
)
const
override
{
const
NormalBevelFP
&
normalBevelFP
=
proc
.
cast
<
NormalBevelFP
>
(
)
;
return
fBevelType
=
=
normalBevelFP
.
fBevelType
&
&
fBevelWidth
=
=
normalBevelFP
.
fBevelWidth
&
&
fBevelHeight
=
=
normalBevelFP
.
fBevelHeight
;
}
SkNormalSource
:
:
BevelType
fBevelType
;
SkScalar
fBevelWidth
;
SkScalar
fBevelHeight
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
sk_sp
<
GrFragmentProcessor
>
SkNormalBevelSourceImpl
:
:
asFragmentProcessor
(
const
SkShader
:
:
AsFPArgs
&
args
)
const
{
SkScalar
maxScale
=
args
.
fViewMatrix
-
>
getMaxScale
(
)
;
return
sk_make_sp
<
NormalBevelFP
>
(
fType
maxScale
*
fWidth
maxScale
*
fHeight
)
;
}
#
endif
SkNormalBevelSourceImpl
:
:
Provider
:
:
Provider
(
)
{
}
SkNormalBevelSourceImpl
:
:
Provider
:
:
~
Provider
(
)
{
}
SkNormalSource
:
:
Provider
*
SkNormalBevelSourceImpl
:
:
asProvider
(
const
SkShader
:
:
ContextRec
&
rec
SkArenaAlloc
*
alloc
)
const
{
return
alloc
-
>
make
<
Provider
>
(
)
;
}
void
SkNormalBevelSourceImpl
:
:
Provider
:
:
fillScanLine
(
int
x
int
y
SkPoint3
output
[
]
int
count
)
const
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
output
[
i
]
=
{
0
.
0f
0
.
0f
1
.
0f
}
;
}
}
sk_sp
<
SkFlattenable
>
SkNormalBevelSourceImpl
:
:
CreateProc
(
SkReadBuffer
&
buf
)
{
auto
type
=
static_cast
<
SkNormalSource
:
:
BevelType
>
(
buf
.
readInt
(
)
)
;
SkScalar
width
=
buf
.
readScalar
(
)
;
SkScalar
height
=
buf
.
readScalar
(
)
;
return
sk_make_sp
<
SkNormalBevelSourceImpl
>
(
type
width
height
)
;
}
void
SkNormalBevelSourceImpl
:
:
flatten
(
SkWriteBuffer
&
buf
)
const
{
this
-
>
INHERITED
:
:
flatten
(
buf
)
;
buf
.
writeInt
(
static_cast
<
int
>
(
fType
)
)
;
buf
.
writeScalar
(
fWidth
)
;
buf
.
writeScalar
(
fHeight
)
;
}
sk_sp
<
SkNormalSource
>
SkNormalSource
:
:
MakeBevel
(
BevelType
type
SkScalar
width
SkScalar
height
)
{
SkASSERT
(
width
>
0
.
0f
&
&
!
SkScalarNearlyZero
(
width
)
)
;
if
(
SkScalarNearlyZero
(
height
)
)
{
return
SkNormalSource
:
:
MakeFlat
(
)
;
}
return
sk_make_sp
<
SkNormalBevelSourceImpl
>
(
type
width
height
)
;
}
