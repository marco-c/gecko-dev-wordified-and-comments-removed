#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkMaskFilter
.
h
"
#
include
"
include
/
core
/
SkPathBuilder
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
core
/
SkVertices
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkBlitter_A8
.
h
"
#
include
"
src
/
core
/
SkBlurMask
.
h
"
#
include
"
src
/
core
/
SkDrawBase
.
h
"
#
include
"
src
/
core
/
SkGpuBlurUtils
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
core
/
SkRasterClip
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkStringUtils
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
gpu
/
SkBackingFit
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrThreadSafeCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBlendFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrMatrixEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrSkSLFP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
#
endif
using
namespace
skia_private
;
class
SkBlurMaskFilterImpl
:
public
SkMaskFilterBase
{
public
:
SkBlurMaskFilterImpl
(
SkScalar
sigma
SkBlurStyle
bool
respectCTM
)
;
SkMask
:
:
Format
getFormat
(
)
const
override
;
bool
filterMask
(
SkMask
*
dst
const
SkMask
&
src
const
SkMatrix
&
SkIPoint
*
margin
)
const
override
;
#
if
defined
(
SK_GANESH
)
bool
canFilterMaskGPU
(
const
GrStyledShape
&
shape
const
SkIRect
&
devSpaceShapeBounds
const
SkIRect
&
clipBounds
const
SkMatrix
&
ctm
SkIRect
*
maskRect
)
const
override
;
bool
directFilterMaskGPU
(
GrRecordingContext
*
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
GrPaint
&
&
const
GrClip
*
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
)
const
override
;
GrSurfaceProxyView
filterMaskGPU
(
GrRecordingContext
*
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
const
SkMatrix
&
ctm
const
SkIRect
&
maskRect
)
const
override
;
#
endif
void
computeFastBounds
(
const
SkRect
&
SkRect
*
)
const
override
;
bool
asABlur
(
BlurRec
*
)
const
override
;
protected
:
FilterReturn
filterRectsToNine
(
const
SkRect
[
]
int
count
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
override
;
FilterReturn
filterRRectToNine
(
const
SkRRect
&
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
override
;
bool
filterRectMask
(
SkMask
*
dstM
const
SkRect
&
r
const
SkMatrix
&
matrix
SkIPoint
*
margin
SkMask
:
:
CreateMode
createMode
)
const
;
bool
filterRRectMask
(
SkMask
*
dstM
const
SkRRect
&
r
const
SkMatrix
&
matrix
SkIPoint
*
margin
SkMask
:
:
CreateMode
createMode
)
const
;
bool
ignoreXform
(
)
const
{
return
!
fRespectCTM
;
}
private
:
SK_FLATTENABLE_HOOKS
(
SkBlurMaskFilterImpl
)
static
const
SkScalar
kMAX_BLUR_SIGMA
;
SkScalar
fSigma
;
SkBlurStyle
fBlurStyle
;
bool
fRespectCTM
;
SkBlurMaskFilterImpl
(
SkReadBuffer
&
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
SkScalar
computeXformedSigma
(
const
SkMatrix
&
ctm
)
const
{
SkScalar
xformedSigma
=
this
-
>
ignoreXform
(
)
?
fSigma
:
ctm
.
mapRadius
(
fSigma
)
;
return
std
:
:
min
(
xformedSigma
kMAX_BLUR_SIGMA
)
;
}
friend
class
SkBlurMaskFilter
;
using
INHERITED
=
SkMaskFilter
;
friend
void
sk_register_blur_maskfilter_createproc
(
)
;
}
;
const
SkScalar
SkBlurMaskFilterImpl
:
:
kMAX_BLUR_SIGMA
=
SkIntToScalar
(
128
)
;
SkBlurMaskFilterImpl
:
:
SkBlurMaskFilterImpl
(
SkScalar
sigma
SkBlurStyle
style
bool
respectCTM
)
:
fSigma
(
sigma
)
fBlurStyle
(
style
)
fRespectCTM
(
respectCTM
)
{
SkASSERT
(
fSigma
>
0
)
;
SkASSERT
(
(
unsigned
)
style
<
=
kLastEnum_SkBlurStyle
)
;
}
SkMask
:
:
Format
SkBlurMaskFilterImpl
:
:
getFormat
(
)
const
{
return
SkMask
:
:
kA8_Format
;
}
bool
SkBlurMaskFilterImpl
:
:
asABlur
(
BlurRec
*
rec
)
const
{
if
(
this
-
>
ignoreXform
(
)
)
{
return
false
;
}
if
(
rec
)
{
rec
-
>
fSigma
=
fSigma
;
rec
-
>
fStyle
=
fBlurStyle
;
}
return
true
;
}
bool
SkBlurMaskFilterImpl
:
:
filterMask
(
SkMask
*
dst
const
SkMask
&
src
const
SkMatrix
&
matrix
SkIPoint
*
margin
)
const
{
SkScalar
sigma
=
this
-
>
computeXformedSigma
(
matrix
)
;
return
SkBlurMask
:
:
BoxBlur
(
dst
src
sigma
fBlurStyle
margin
)
;
}
bool
SkBlurMaskFilterImpl
:
:
filterRectMask
(
SkMask
*
dst
const
SkRect
&
r
const
SkMatrix
&
matrix
SkIPoint
*
margin
SkMask
:
:
CreateMode
createMode
)
const
{
SkScalar
sigma
=
computeXformedSigma
(
matrix
)
;
return
SkBlurMask
:
:
BlurRect
(
sigma
dst
r
fBlurStyle
margin
createMode
)
;
}
bool
SkBlurMaskFilterImpl
:
:
filterRRectMask
(
SkMask
*
dst
const
SkRRect
&
r
const
SkMatrix
&
matrix
SkIPoint
*
margin
SkMask
:
:
CreateMode
createMode
)
const
{
SkScalar
sigma
=
computeXformedSigma
(
matrix
)
;
return
SkBlurMask
:
:
BlurRRect
(
sigma
dst
r
fBlurStyle
margin
createMode
)
;
}
static
bool
prepare_to_draw_into_mask
(
const
SkRect
&
bounds
SkMask
*
mask
)
{
SkASSERT
(
mask
!
=
nullptr
)
;
mask
-
>
fBounds
=
bounds
.
roundOut
(
)
;
mask
-
>
fRowBytes
=
SkAlign4
(
mask
-
>
fBounds
.
width
(
)
)
;
mask
-
>
fFormat
=
SkMask
:
:
kA8_Format
;
const
size_t
size
=
mask
-
>
computeImageSize
(
)
;
mask
-
>
fImage
=
SkMask
:
:
AllocImage
(
size
SkMask
:
:
kZeroInit_Alloc
)
;
if
(
nullptr
=
=
mask
-
>
fImage
)
{
return
false
;
}
return
true
;
}
template
<
typename
Proc
>
bool
draw_into_mask
(
SkMask
*
mask
const
SkRect
&
bounds
Proc
proc
)
{
if
(
!
prepare_to_draw_into_mask
(
bounds
mask
)
)
{
return
false
;
}
const
int
dx
=
mask
-
>
fBounds
.
fLeft
;
const
int
dy
=
mask
-
>
fBounds
.
fTop
;
SkRasterClip
rclip
(
mask
-
>
fBounds
)
;
rclip
.
setRect
(
mask
-
>
fBounds
.
makeOffset
(
-
dx
-
dy
)
)
;
SkASSERT
(
mask
-
>
fFormat
=
=
SkMask
:
:
kA8_Format
)
;
auto
info
=
SkImageInfo
:
:
MakeA8
(
mask
-
>
fBounds
.
width
(
)
mask
-
>
fBounds
.
height
(
)
)
;
auto
pm
=
SkPixmap
(
info
mask
-
>
fImage
mask
-
>
fRowBytes
)
;
SkMatrix
ctm
=
SkMatrix
:
:
Translate
(
-
SkIntToScalar
(
dx
)
-
SkIntToScalar
(
dy
)
)
;
SkMatrixProvider
matrixProvider
(
ctm
)
;
SkDrawBase
draw
;
draw
.
fBlitterChooser
=
SkA8Blitter_Choose
;
draw
.
fMatrixProvider
=
&
matrixProvider
;
draw
.
fDst
=
pm
;
draw
.
fRC
=
&
rclip
;
SkPaint
paint
;
paint
.
setAntiAlias
(
true
)
;
proc
(
draw
paint
)
;
return
true
;
}
static
bool
draw_rects_into_mask
(
const
SkRect
rects
[
]
int
count
SkMask
*
mask
)
{
return
draw_into_mask
(
mask
rects
[
0
]
[
&
]
(
SkDrawBase
&
draw
const
SkPaint
&
paint
)
{
if
(
1
=
=
count
)
{
draw
.
drawRect
(
rects
[
0
]
paint
)
;
}
else
{
SkPath
path
=
SkPathBuilder
(
)
.
addRect
(
rects
[
0
]
)
.
addRect
(
rects
[
1
]
)
.
setFillType
(
SkPathFillType
:
:
kEvenOdd
)
.
detach
(
)
;
draw
.
drawPath
(
path
paint
)
;
}
}
)
;
}
static
bool
draw_rrect_into_mask
(
const
SkRRect
rrect
SkMask
*
mask
)
{
return
draw_into_mask
(
mask
rrect
.
rect
(
)
[
&
]
(
SkDrawBase
&
draw
const
SkPaint
&
paint
)
{
draw
.
drawRRect
(
rrect
paint
)
;
}
)
;
}
static
bool
rect_exceeds
(
const
SkRect
&
r
SkScalar
v
)
{
return
r
.
fLeft
<
-
v
|
|
r
.
fTop
<
-
v
|
|
r
.
fRight
>
v
|
|
r
.
fBottom
>
v
|
|
r
.
width
(
)
>
v
|
|
r
.
height
(
)
>
v
;
}
#
include
"
src
/
core
/
SkMaskCache
.
h
"
static
SkCachedData
*
copy_mask_to_cacheddata
(
SkMask
*
mask
)
{
const
size_t
size
=
mask
-
>
computeTotalImageSize
(
)
;
SkCachedData
*
data
=
SkResourceCache
:
:
NewCachedData
(
size
)
;
if
(
data
)
{
memcpy
(
data
-
>
writable_data
(
)
mask
-
>
fImage
size
)
;
SkMask
:
:
FreeImage
(
mask
-
>
fImage
)
;
mask
-
>
fImage
=
(
uint8_t
*
)
data
-
>
data
(
)
;
}
return
data
;
}
static
SkCachedData
*
find_cached_rrect
(
SkMask
*
mask
SkScalar
sigma
SkBlurStyle
style
const
SkRRect
&
rrect
)
{
return
SkMaskCache
:
:
FindAndRef
(
sigma
style
rrect
mask
)
;
}
static
SkCachedData
*
add_cached_rrect
(
SkMask
*
mask
SkScalar
sigma
SkBlurStyle
style
const
SkRRect
&
rrect
)
{
SkCachedData
*
cache
=
copy_mask_to_cacheddata
(
mask
)
;
if
(
cache
)
{
SkMaskCache
:
:
Add
(
sigma
style
rrect
*
mask
cache
)
;
}
return
cache
;
}
static
SkCachedData
*
find_cached_rects
(
SkMask
*
mask
SkScalar
sigma
SkBlurStyle
style
const
SkRect
rects
[
]
int
count
)
{
return
SkMaskCache
:
:
FindAndRef
(
sigma
style
rects
count
mask
)
;
}
static
SkCachedData
*
add_cached_rects
(
SkMask
*
mask
SkScalar
sigma
SkBlurStyle
style
const
SkRect
rects
[
]
int
count
)
{
SkCachedData
*
cache
=
copy_mask_to_cacheddata
(
mask
)
;
if
(
cache
)
{
SkMaskCache
:
:
Add
(
sigma
style
rects
count
*
mask
cache
)
;
}
return
cache
;
}
static
const
bool
c_analyticBlurRRect
{
true
}
;
SkMaskFilterBase
:
:
FilterReturn
SkBlurMaskFilterImpl
:
:
filterRRectToNine
(
const
SkRRect
&
rrect
const
SkMatrix
&
matrix
const
SkIRect
&
clipBounds
NinePatch
*
patch
)
const
{
SkASSERT
(
patch
!
=
nullptr
)
;
switch
(
rrect
.
getType
(
)
)
{
case
SkRRect
:
:
kEmpty_Type
:
return
kFalse_FilterReturn
;
case
SkRRect
:
:
kRect_Type
:
SkASSERT
(
false
)
;
[
[
fallthrough
]
]
;
case
SkRRect
:
:
kOval_Type
:
return
kUnimplemented_FilterReturn
;
case
SkRRect
:
:
kSimple_Type
:
case
SkRRect
:
:
kNinePatch_Type
:
case
SkRRect
:
:
kComplex_Type
:
break
;
}
if
(
kInner_SkBlurStyle
=
=
fBlurStyle
)
{
return
kUnimplemented_FilterReturn
;
}
if
(
rect_exceeds
(
rrect
.
rect
(
)
SkIntToScalar
(
32767
)
)
)
{
return
kUnimplemented_FilterReturn
;
}
SkIPoint
margin
;
SkMask
srcM
dstM
;
srcM
.
fBounds
=
rrect
.
rect
(
)
.
roundOut
(
)
;
srcM
.
fFormat
=
SkMask
:
:
kA8_Format
;
srcM
.
fRowBytes
=
0
;
bool
filterResult
=
false
;
if
(
c_analyticBlurRRect
)
{
filterResult
=
this
-
>
filterRRectMask
(
&
dstM
rrect
matrix
&
margin
SkMask
:
:
kJustComputeBounds_CreateMode
)
;
}
if
(
!
filterResult
)
{
filterResult
=
this
-
>
filterMask
(
&
dstM
srcM
matrix
&
margin
)
;
}
if
(
!
filterResult
)
{
return
kFalse_FilterReturn
;
}
const
SkVector
&
UL
=
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
;
const
SkVector
&
UR
=
rrect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
;
const
SkVector
&
LR
=
rrect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
;
const
SkVector
&
LL
=
rrect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
;
const
SkScalar
leftUnstretched
=
std
:
:
max
(
UL
.
fX
LL
.
fX
)
+
SkIntToScalar
(
2
*
margin
.
fX
)
;
const
SkScalar
rightUnstretched
=
std
:
:
max
(
UR
.
fX
LR
.
fX
)
+
SkIntToScalar
(
2
*
margin
.
fX
)
;
const
SkScalar
stretchSize
=
SkIntToScalar
(
3
)
;
const
SkScalar
totalSmallWidth
=
leftUnstretched
+
rightUnstretched
+
stretchSize
;
if
(
totalSmallWidth
>
=
rrect
.
rect
(
)
.
width
(
)
)
{
return
kUnimplemented_FilterReturn
;
}
const
SkScalar
topUnstretched
=
std
:
:
max
(
UL
.
fY
UR
.
fY
)
+
SkIntToScalar
(
2
*
margin
.
fY
)
;
const
SkScalar
bottomUnstretched
=
std
:
:
max
(
LL
.
fY
LR
.
fY
)
+
SkIntToScalar
(
2
*
margin
.
fY
)
;
const
SkScalar
totalSmallHeight
=
topUnstretched
+
bottomUnstretched
+
stretchSize
;
if
(
totalSmallHeight
>
=
rrect
.
rect
(
)
.
height
(
)
)
{
return
kUnimplemented_FilterReturn
;
}
SkRect
smallR
=
SkRect
:
:
MakeWH
(
totalSmallWidth
totalSmallHeight
)
;
SkRRect
smallRR
;
SkVector
radii
[
4
]
;
radii
[
SkRRect
:
:
kUpperLeft_Corner
]
=
UL
;
radii
[
SkRRect
:
:
kUpperRight_Corner
]
=
UR
;
radii
[
SkRRect
:
:
kLowerRight_Corner
]
=
LR
;
radii
[
SkRRect
:
:
kLowerLeft_Corner
]
=
LL
;
smallRR
.
setRectRadii
(
smallR
radii
)
;
const
SkScalar
sigma
=
this
-
>
computeXformedSigma
(
matrix
)
;
SkCachedData
*
cache
=
find_cached_rrect
(
&
patch
-
>
fMask
sigma
fBlurStyle
smallRR
)
;
if
(
!
cache
)
{
bool
analyticBlurWorked
=
false
;
if
(
c_analyticBlurRRect
)
{
analyticBlurWorked
=
this
-
>
filterRRectMask
(
&
patch
-
>
fMask
smallRR
matrix
&
margin
SkMask
:
:
kComputeBoundsAndRenderImage_CreateMode
)
;
}
if
(
!
analyticBlurWorked
)
{
if
(
!
draw_rrect_into_mask
(
smallRR
&
srcM
)
)
{
return
kFalse_FilterReturn
;
}
SkAutoMaskFreeImage
amf
(
srcM
.
fImage
)
;
if
(
!
this
-
>
filterMask
(
&
patch
-
>
fMask
srcM
matrix
&
margin
)
)
{
return
kFalse_FilterReturn
;
}
}
cache
=
add_cached_rrect
(
&
patch
-
>
fMask
sigma
fBlurStyle
smallRR
)
;
}
patch
-
>
fMask
.
fBounds
.
offsetTo
(
0
0
)
;
patch
-
>
fOuterRect
=
dstM
.
fBounds
;
patch
-
>
fCenter
.
fX
=
SkScalarCeilToInt
(
leftUnstretched
)
+
1
;
patch
-
>
fCenter
.
fY
=
SkScalarCeilToInt
(
topUnstretched
)
+
1
;
SkASSERT
(
nullptr
=
=
patch
-
>
fCache
)
;
patch
-
>
fCache
=
cache
;
return
kTrue_FilterReturn
;
}
static
const
bool
c_analyticBlurNinepatch
{
true
}
;
SkMaskFilterBase
:
:
FilterReturn
SkBlurMaskFilterImpl
:
:
filterRectsToNine
(
const
SkRect
rects
[
]
int
count
const
SkMatrix
&
matrix
const
SkIRect
&
clipBounds
NinePatch
*
patch
)
const
{
if
(
count
<
1
|
|
count
>
2
)
{
return
kUnimplemented_FilterReturn
;
}
if
(
kInner_SkBlurStyle
=
=
fBlurStyle
|
|
kOuter_SkBlurStyle
=
=
fBlurStyle
)
{
return
kUnimplemented_FilterReturn
;
}
if
(
rect_exceeds
(
rects
[
0
]
SkIntToScalar
(
32767
)
)
)
{
return
kUnimplemented_FilterReturn
;
}
SkIPoint
margin
;
SkMask
srcM
dstM
;
srcM
.
fBounds
=
rects
[
0
]
.
roundOut
(
)
;
srcM
.
fFormat
=
SkMask
:
:
kA8_Format
;
srcM
.
fRowBytes
=
0
;
bool
filterResult
=
false
;
if
(
count
=
=
1
&
&
c_analyticBlurNinepatch
)
{
filterResult
=
this
-
>
filterRectMask
(
&
dstM
rects
[
0
]
matrix
&
margin
SkMask
:
:
kJustComputeBounds_CreateMode
)
;
}
else
{
filterResult
=
this
-
>
filterMask
(
&
dstM
srcM
matrix
&
margin
)
;
}
if
(
!
filterResult
)
{
return
kFalse_FilterReturn
;
}
SkRect
smallR
[
2
]
;
SkIPoint
center
;
int
smallW
=
dstM
.
fBounds
.
width
(
)
-
srcM
.
fBounds
.
width
(
)
+
2
;
int
smallH
=
dstM
.
fBounds
.
height
(
)
-
srcM
.
fBounds
.
height
(
)
+
2
;
SkIRect
innerIR
;
if
(
1
=
=
count
)
{
innerIR
=
srcM
.
fBounds
;
center
.
set
(
smallW
smallH
)
;
}
else
{
SkASSERT
(
2
=
=
count
)
;
rects
[
1
]
.
roundIn
(
&
innerIR
)
;
center
.
set
(
smallW
+
(
innerIR
.
left
(
)
-
srcM
.
fBounds
.
left
(
)
)
smallH
+
(
innerIR
.
top
(
)
-
srcM
.
fBounds
.
top
(
)
)
)
;
}
smallW
+
=
1
;
smallH
+
=
1
;
const
SkScalar
dx
=
SkIntToScalar
(
innerIR
.
width
(
)
-
smallW
)
;
const
SkScalar
dy
=
SkIntToScalar
(
innerIR
.
height
(
)
-
smallH
)
;
if
(
dx
<
0
|
|
dy
<
0
)
{
return
kUnimplemented_FilterReturn
;
}
smallR
[
0
]
.
setLTRB
(
rects
[
0
]
.
left
(
)
rects
[
0
]
.
top
(
)
rects
[
0
]
.
right
(
)
-
dx
rects
[
0
]
.
bottom
(
)
-
dy
)
;
if
(
smallR
[
0
]
.
width
(
)
<
2
|
|
smallR
[
0
]
.
height
(
)
<
2
)
{
return
kUnimplemented_FilterReturn
;
}
if
(
2
=
=
count
)
{
smallR
[
1
]
.
setLTRB
(
rects
[
1
]
.
left
(
)
rects
[
1
]
.
top
(
)
rects
[
1
]
.
right
(
)
-
dx
rects
[
1
]
.
bottom
(
)
-
dy
)
;
SkASSERT
(
!
smallR
[
1
]
.
isEmpty
(
)
)
;
}
const
SkScalar
sigma
=
this
-
>
computeXformedSigma
(
matrix
)
;
SkCachedData
*
cache
=
find_cached_rects
(
&
patch
-
>
fMask
sigma
fBlurStyle
smallR
count
)
;
if
(
!
cache
)
{
if
(
count
>
1
|
|
!
c_analyticBlurNinepatch
)
{
if
(
!
draw_rects_into_mask
(
smallR
count
&
srcM
)
)
{
return
kFalse_FilterReturn
;
}
SkAutoMaskFreeImage
amf
(
srcM
.
fImage
)
;
if
(
!
this
-
>
filterMask
(
&
patch
-
>
fMask
srcM
matrix
&
margin
)
)
{
return
kFalse_FilterReturn
;
}
}
else
{
if
(
!
this
-
>
filterRectMask
(
&
patch
-
>
fMask
smallR
[
0
]
matrix
&
margin
SkMask
:
:
kComputeBoundsAndRenderImage_CreateMode
)
)
{
return
kFalse_FilterReturn
;
}
}
cache
=
add_cached_rects
(
&
patch
-
>
fMask
sigma
fBlurStyle
smallR
count
)
;
}
patch
-
>
fMask
.
fBounds
.
offsetTo
(
0
0
)
;
patch
-
>
fOuterRect
=
dstM
.
fBounds
;
patch
-
>
fCenter
=
center
;
SkASSERT
(
nullptr
=
=
patch
-
>
fCache
)
;
patch
-
>
fCache
=
cache
;
return
kTrue_FilterReturn
;
}
void
SkBlurMaskFilterImpl
:
:
computeFastBounds
(
const
SkRect
&
src
SkRect
*
dst
)
const
{
SkScalar
pad
=
3
.
0f
*
fSigma
;
dst
-
>
setLTRB
(
src
.
fLeft
-
pad
src
.
fTop
-
pad
src
.
fRight
+
pad
src
.
fBottom
+
pad
)
;
}
sk_sp
<
SkFlattenable
>
SkBlurMaskFilterImpl
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
const
SkScalar
sigma
=
buffer
.
readScalar
(
)
;
SkBlurStyle
style
=
buffer
.
read32LE
(
kLastEnum_SkBlurStyle
)
;
uint32_t
flags
=
buffer
.
read32LE
(
0x3
)
;
bool
respectCTM
=
!
(
flags
&
1
)
;
return
SkMaskFilter
:
:
MakeBlur
(
(
SkBlurStyle
)
style
sigma
respectCTM
)
;
}
void
SkBlurMaskFilterImpl
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeScalar
(
fSigma
)
;
buffer
.
writeUInt
(
fBlurStyle
)
;
buffer
.
writeUInt
(
!
fRespectCTM
)
;
}
#
if
defined
(
SK_GANESH
)
&
&
defined
(
SK_GANESH
)
static
float
make_unnormalized_half_kernel
(
float
*
halfKernel
int
halfKernelSize
float
sigma
)
{
const
float
invSigma
=
1
.
f
/
sigma
;
const
float
b
=
-
0
.
5f
*
invSigma
*
invSigma
;
float
tot
=
0
.
0f
;
float
t
=
0
.
5f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
float
value
=
expf
(
t
*
t
*
b
)
;
tot
+
=
value
;
halfKernel
[
i
]
=
value
;
t
+
=
1
.
f
;
}
return
tot
;
}
static
void
make_half_kernel_and_summed_table
(
float
*
halfKernel
float
*
summedHalfKernel
int
halfKernelSize
float
sigma
)
{
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
i
]
/
=
tot
;
sum
+
=
halfKernel
[
i
]
;
summedHalfKernel
[
i
]
=
sum
;
}
}
void
apply_kernel_in_y
(
float
*
results
int
numSteps
float
firstX
float
circleR
int
halfKernelSize
const
float
*
summedHalfKernelTable
)
{
float
x
=
firstX
;
for
(
int
i
=
0
;
i
<
numSteps
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
results
[
i
]
=
0
;
continue
;
}
float
y
=
sqrtf
(
circleR
*
circleR
-
x
*
x
)
;
y
-
=
0
.
5f
;
int
yInt
=
SkScalarFloorToInt
(
y
)
;
SkASSERT
(
yInt
>
=
-
1
)
;
if
(
y
<
0
)
{
results
[
i
]
=
(
y
+
0
.
5f
)
*
summedHalfKernelTable
[
0
]
;
}
else
if
(
yInt
>
=
halfKernelSize
-
1
)
{
results
[
i
]
=
0
.
5f
;
}
else
{
float
yFrac
=
y
-
yInt
;
results
[
i
]
=
(
1
.
f
-
yFrac
)
*
summedHalfKernelTable
[
yInt
]
+
yFrac
*
summedHalfKernelTable
[
yInt
+
1
]
;
}
}
}
static
uint8_t
eval_at
(
float
evalX
float
circleR
const
float
*
halfKernel
int
halfKernelSize
const
float
*
yKernelEvaluations
)
{
float
acc
=
0
;
float
x
=
evalX
-
halfKernelSize
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
]
;
acc
+
=
verticalEval
*
halfKernel
[
halfKernelSize
-
i
-
1
]
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
+
halfKernelSize
]
;
acc
+
=
verticalEval
*
halfKernel
[
i
]
;
}
return
SkUnitScalarClampToByte
(
2
.
f
*
acc
)
;
}
static
void
create_circle_profile
(
uint8_t
*
weights
float
sigma
float
circleR
int
profileTextureWidth
)
{
const
int
numSteps
=
profileTextureWidth
;
int
halfKernelSize
=
SkScalarCeilToInt
(
6
.
0f
*
sigma
)
;
halfKernelSize
=
(
(
halfKernelSize
+
1
)
&
~
1
)
>
>
1
;
int
numYSteps
=
numSteps
+
2
*
halfKernelSize
;
AutoTArray
<
float
>
bulkAlloc
(
halfKernelSize
+
halfKernelSize
+
numYSteps
)
;
float
*
halfKernel
=
bulkAlloc
.
get
(
)
;
float
*
summedKernel
=
bulkAlloc
.
get
(
)
+
halfKernelSize
;
float
*
yEvals
=
bulkAlloc
.
get
(
)
+
2
*
halfKernelSize
;
make_half_kernel_and_summed_table
(
halfKernel
summedKernel
halfKernelSize
sigma
)
;
float
firstX
=
-
halfKernelSize
+
0
.
5f
;
apply_kernel_in_y
(
yEvals
numYSteps
firstX
circleR
halfKernelSize
summedKernel
)
;
for
(
int
i
=
0
;
i
<
numSteps
-
1
;
+
+
i
)
{
float
evalX
=
i
+
0
.
5f
;
weights
[
i
]
=
eval_at
(
evalX
circleR
halfKernel
halfKernelSize
yEvals
+
i
)
;
}
weights
[
numSteps
-
1
]
=
0
;
}
static
void
create_half_plane_profile
(
uint8_t
*
profile
int
profileWidth
)
{
SkASSERT
(
!
(
profileWidth
&
0x1
)
)
;
float
sigma
=
profileWidth
/
6
.
f
;
int
halfKernelSize
=
profileWidth
/
2
;
AutoTArray
<
float
>
halfKernel
(
halfKernelSize
)
;
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
.
get
(
)
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
halfKernelSize
-
i
-
1
]
/
=
tot
;
sum
+
=
halfKernel
[
halfKernelSize
-
i
-
1
]
;
profile
[
profileWidth
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
sum
+
=
halfKernel
[
i
]
;
profile
[
halfKernelSize
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
profile
[
profileWidth
-
1
]
=
0
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
create_profile_effect
(
GrRecordingContext
*
rContext
const
SkRect
&
circle
float
sigma
float
*
solidRadius
float
*
textureRadius
)
{
float
circleR
=
circle
.
width
(
)
/
2
.
0f
;
if
(
!
sk_float_isfinite
(
circleR
)
|
|
circleR
<
SK_ScalarNearlyZero
)
{
return
nullptr
;
}
auto
threadSafeCache
=
rContext
-
>
priv
(
)
.
threadSafeCache
(
)
;
SkScalar
sigmaToCircleRRatio
=
sigma
/
circleR
;
sigmaToCircleRRatio
=
std
:
:
min
(
sigmaToCircleRRatio
8
.
f
)
;
SkFixed
sigmaToCircleRRatioFixed
;
static
const
SkScalar
kHalfPlaneThreshold
=
0
.
1f
;
bool
useHalfPlaneApprox
=
false
;
if
(
sigmaToCircleRRatio
<
=
kHalfPlaneThreshold
)
{
useHalfPlaneApprox
=
true
;
sigmaToCircleRRatioFixed
=
0
;
*
solidRadius
=
circleR
-
3
*
sigma
;
*
textureRadius
=
6
*
sigma
;
}
else
{
sigmaToCircleRRatioFixed
=
SkScalarToFixed
(
sigmaToCircleRRatio
)
;
sigmaToCircleRRatioFixed
&
=
~
0xff
;
sigmaToCircleRRatio
=
SkFixedToScalar
(
sigmaToCircleRRatioFixed
)
;
sigma
=
circleR
*
sigmaToCircleRRatio
;
*
solidRadius
=
0
;
*
textureRadius
=
circleR
+
3
*
sigma
;
}
static
constexpr
int
kProfileTextureWidth
=
512
;
SkMatrix
texM
=
SkMatrix
:
:
Scale
(
kProfileTextureWidth
1
.
f
)
;
static
const
skgpu
:
:
UniqueKey
:
:
Domain
kDomain
=
skgpu
:
:
UniqueKey
:
:
GenerateDomain
(
)
;
skgpu
:
:
UniqueKey
key
;
skgpu
:
:
UniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
"
1
-
D
Circular
Blur
"
)
;
builder
[
0
]
=
sigmaToCircleRRatioFixed
;
builder
.
finish
(
)
;
GrSurfaceProxyView
profileView
=
threadSafeCache
-
>
find
(
key
)
;
if
(
profileView
)
{
SkASSERT
(
profileView
.
asTextureProxy
(
)
)
;
SkASSERT
(
profileView
.
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
profileView
)
kPremul_SkAlphaType
texM
)
;
}
SkBitmap
bm
;
if
(
!
bm
.
tryAllocPixels
(
SkImageInfo
:
:
MakeA8
(
kProfileTextureWidth
1
)
)
)
{
return
nullptr
;
}
if
(
useHalfPlaneApprox
)
{
create_half_plane_profile
(
bm
.
getAddr8
(
0
0
)
kProfileTextureWidth
)
;
}
else
{
SkScalar
scale
=
kProfileTextureWidth
/
*
textureRadius
;
create_circle_profile
(
bm
.
getAddr8
(
0
0
)
sigma
*
scale
circleR
*
scale
kProfileTextureWidth
)
;
}
bm
.
setImmutable
(
)
;
profileView
=
std
:
:
get
<
0
>
(
GrMakeUncachedBitmapProxyView
(
rContext
bm
)
)
;
if
(
!
profileView
)
{
return
nullptr
;
}
profileView
=
threadSafeCache
-
>
add
(
key
profileView
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
profileView
)
kPremul_SkAlphaType
texM
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_circle_blur
(
GrRecordingContext
*
context
const
SkRect
&
circle
float
sigma
)
{
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
)
)
{
return
nullptr
;
}
float
solidRadius
;
float
textureRadius
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
profile
=
create_profile_effect
(
context
circle
sigma
&
solidRadius
&
textureRadius
)
;
if
(
!
profile
)
{
return
nullptr
;
}
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
shader
blurProfile
;
"
"
uniform
half4
circleData
;
"
"
half4
main
(
float2
xy
)
{
"
"
half2
vec
=
half2
(
(
sk_FragCoord
.
xy
-
circleData
.
xy
)
*
circleData
.
w
)
;
"
"
half
dist
=
length
(
vec
)
+
(
0
.
5
-
circleData
.
z
)
*
circleData
.
w
;
"
"
return
blurProfile
.
eval
(
half2
(
dist
0
.
5
)
)
.
aaaa
;
"
"
}
"
)
;
SkV4
circleData
=
{
circle
.
centerX
(
)
circle
.
centerY
(
)
solidRadius
1
.
f
/
textureRadius
}
;
auto
circleBlurFP
=
GrSkSLFP
:
:
Make
(
effect
"
CircleBlur
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kCompatibleWithCoverageAsAlpha
"
blurProfile
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
profile
)
)
"
circleData
"
circleData
)
;
return
GrBlendFragmentProcessor
:
:
Make
<
SkBlendMode
:
:
kModulate
>
(
std
:
:
move
(
circleBlurFP
)
nullptr
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_rect_integral_fp
(
GrRecordingContext
*
rContext
float
sixSigma
)
{
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sixSigma
/
6
.
f
)
)
;
auto
threadSafeCache
=
rContext
-
>
priv
(
)
.
threadSafeCache
(
)
;
int
width
=
SkGpuBlurUtils
:
:
CreateIntegralTable
(
sixSigma
nullptr
)
;
static
const
skgpu
:
:
UniqueKey
:
:
Domain
kDomain
=
skgpu
:
:
UniqueKey
:
:
GenerateDomain
(
)
;
skgpu
:
:
UniqueKey
key
;
skgpu
:
:
UniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
"
Rect
Blur
Mask
"
)
;
builder
[
0
]
=
width
;
builder
.
finish
(
)
;
SkMatrix
m
=
SkMatrix
:
:
Scale
(
width
/
sixSigma
1
.
f
)
;
GrSurfaceProxyView
view
=
threadSafeCache
-
>
find
(
key
)
;
if
(
view
)
{
SkASSERT
(
view
.
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
kPremul_SkAlphaType
m
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
}
SkBitmap
bitmap
;
if
(
!
SkGpuBlurUtils
:
:
CreateIntegralTable
(
sixSigma
&
bitmap
)
)
{
return
{
}
;
}
view
=
std
:
:
get
<
0
>
(
GrMakeUncachedBitmapProxyView
(
rContext
bitmap
)
)
;
if
(
!
view
)
{
return
{
}
;
}
view
=
threadSafeCache
-
>
add
(
key
view
)
;
SkASSERT
(
view
.
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
kPremul_SkAlphaType
m
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_rect_blur
(
GrRecordingContext
*
context
const
GrShaderCaps
&
caps
const
SkRect
&
srcRect
const
SkMatrix
&
viewMatrix
float
transformedSigma
)
{
SkASSERT
(
viewMatrix
.
preservesRightAngles
(
)
)
;
SkASSERT
(
srcRect
.
isSorted
(
)
)
;
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
transformedSigma
)
)
{
return
nullptr
;
}
SkMatrix
invM
;
SkRect
rect
;
if
(
viewMatrix
.
rectStaysRect
(
)
)
{
invM
=
SkMatrix
:
:
I
(
)
;
SkAssertResult
(
viewMatrix
.
mapRect
(
&
rect
srcRect
)
)
;
}
else
{
SkMatrix
m
;
SkSize
scale
;
if
(
!
viewMatrix
.
decomposeScale
(
&
scale
&
m
)
)
{
return
nullptr
;
}
if
(
!
m
.
invert
(
&
invM
)
)
{
return
nullptr
;
}
rect
=
{
srcRect
.
left
(
)
*
scale
.
width
(
)
srcRect
.
top
(
)
*
scale
.
height
(
)
srcRect
.
right
(
)
*
scale
.
width
(
)
srcRect
.
bottom
(
)
*
scale
.
height
(
)
}
;
}
if
(
!
caps
.
fFloatIs32Bits
)
{
if
(
SkScalarAbs
(
rect
.
fLeft
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fTop
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fRight
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fBottom
)
>
16000
.
f
)
{
return
nullptr
;
}
}
const
float
sixSigma
=
6
*
transformedSigma
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
integral
=
make_rect_integral_fp
(
context
sixSigma
)
;
if
(
!
integral
)
{
return
nullptr
;
}
float
threeSigma
=
sixSigma
/
2
;
SkRect
insetRect
=
{
rect
.
left
(
)
+
threeSigma
rect
.
top
(
)
+
threeSigma
rect
.
right
(
)
-
threeSigma
rect
.
bottom
(
)
-
threeSigma
}
;
bool
isFast
=
insetRect
.
isSorted
(
)
;
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
shader
integral
;
"
"
uniform
float4
rect
;
"
"
uniform
int
isFast
;
"
"
half4
main
(
float2
pos
)
{
"
"
half
xCoverage
yCoverage
;
"
"
if
(
bool
(
isFast
)
)
{
"
"
half2
xy
=
max
(
half2
(
rect
.
LT
-
pos
)
half2
(
pos
-
rect
.
RB
)
)
;
"
"
xCoverage
=
integral
.
eval
(
half2
(
xy
.
x
0
.
5
)
)
.
a
;
"
"
yCoverage
=
integral
.
eval
(
half2
(
xy
.
y
0
.
5
)
)
.
a
;
"
"
}
else
{
"
"
half4
rect
=
half4
(
half2
(
rect
.
LT
-
pos
)
half2
(
pos
-
rect
.
RB
)
)
;
"
"
xCoverage
=
1
-
integral
.
eval
(
half2
(
rect
.
L
0
.
5
)
)
.
a
"
"
-
integral
.
eval
(
half2
(
rect
.
R
0
.
5
)
)
.
a
;
"
"
yCoverage
=
1
-
integral
.
eval
(
half2
(
rect
.
T
0
.
5
)
)
.
a
"
"
-
integral
.
eval
(
half2
(
rect
.
B
0
.
5
)
)
.
a
;
"
"
}
"
"
return
half4
(
xCoverage
*
yCoverage
)
;
"
"
}
"
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
=
GrSkSLFP
:
:
Make
(
effect
"
RectBlur
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kCompatibleWithCoverageAsAlpha
"
integral
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
integral
)
)
"
rect
"
insetRect
"
isFast
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isFast
)
)
;
fp
=
GrBlendFragmentProcessor
:
:
Make
<
SkBlendMode
:
:
kModulate
>
(
std
:
:
move
(
fp
)
nullptr
)
;
if
(
!
invM
.
isIdentity
(
)
)
{
fp
=
GrMatrixEffect
:
:
Make
(
invM
std
:
:
move
(
fp
)
)
;
}
return
GrFragmentProcessor
:
:
DeviceSpace
(
std
:
:
move
(
fp
)
)
;
}
static
constexpr
auto
kBlurredRRectMaskOrigin
=
kTopLeft_GrSurfaceOrigin
;
static
void
make_blurred_rrect_key
(
skgpu
:
:
UniqueKey
*
key
const
SkRRect
&
rrectToDraw
float
xformedSigma
)
{
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
;
static
const
skgpu
:
:
UniqueKey
:
:
Domain
kDomain
=
skgpu
:
:
UniqueKey
:
:
GenerateDomain
(
)
;
skgpu
:
:
UniqueKey
:
:
Builder
builder
(
key
kDomain
9
"
RoundRect
Blur
Mask
"
)
;
builder
[
0
]
=
SkScalarCeilToInt
(
xformedSigma
-
1
/
6
.
0f
)
;
int
index
=
1
;
for
(
auto
c
:
{
SkRRect
:
:
kUpperLeft_Corner
SkRRect
:
:
kUpperRight_Corner
SkRRect
:
:
kLowerRight_Corner
SkRRect
:
:
kLowerLeft_Corner
}
)
{
SkASSERT
(
SkScalarIsInt
(
rrectToDraw
.
radii
(
c
)
.
fX
)
&
&
SkScalarIsInt
(
rrectToDraw
.
radii
(
c
)
.
fY
)
)
;
builder
[
index
+
+
]
=
SkScalarCeilToInt
(
rrectToDraw
.
radii
(
c
)
.
fX
)
;
builder
[
index
+
+
]
=
SkScalarCeilToInt
(
rrectToDraw
.
radii
(
c
)
.
fY
)
;
}
builder
.
finish
(
)
;
}
static
bool
fillin_view_on_gpu
(
GrDirectContext
*
dContext
const
GrSurfaceProxyView
&
lazyView
sk_sp
<
GrThreadSafeCache
:
:
Trampoline
>
trampoline
const
SkRRect
&
rrectToDraw
const
SkISize
&
dimensions
float
xformedSigma
)
{
#
if
defined
(
SK_GANESH
)
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
;
SkSurfaceProps
defaultSurfaceProps
;
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
sdc
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
MakeWithFallback
(
dContext
GrColorType
:
:
kAlpha_8
nullptr
SkBackingFit
:
:
kExact
dimensions
defaultSurfaceProps
1
GrMipmapped
:
:
kNo
GrProtected
:
:
kNo
kBlurredRRectMaskOrigin
)
;
if
(
!
sdc
)
{
return
false
;
}
GrPaint
paint
;
sdc
-
>
clear
(
SK_PMColor4fTRANSPARENT
)
;
sdc
-
>
drawRRect
(
nullptr
std
:
:
move
(
paint
)
GrAA
:
:
kYes
SkMatrix
:
:
I
(
)
rrectToDraw
GrStyle
:
:
SimpleFill
(
)
)
;
GrSurfaceProxyView
srcView
=
sdc
-
>
readSurfaceView
(
)
;
SkASSERT
(
srcView
.
asTextureProxy
(
)
)
;
auto
rtc2
=
SkGpuBlurUtils
:
:
GaussianBlur
(
dContext
std
:
:
move
(
srcView
)
sdc
-
>
colorInfo
(
)
.
colorType
(
)
sdc
-
>
colorInfo
(
)
.
alphaType
(
)
nullptr
SkIRect
:
:
MakeSize
(
dimensions
)
SkIRect
:
:
MakeSize
(
dimensions
)
xformedSigma
xformedSigma
SkTileMode
:
:
kClamp
SkBackingFit
:
:
kExact
)
;
if
(
!
rtc2
|
|
!
rtc2
-
>
readSurfaceView
(
)
)
{
return
false
;
}
auto
view
=
rtc2
-
>
readSurfaceView
(
)
;
SkASSERT
(
view
.
swizzle
(
)
=
=
lazyView
.
swizzle
(
)
)
;
SkASSERT
(
view
.
origin
(
)
=
=
lazyView
.
origin
(
)
)
;
trampoline
-
>
fProxy
=
view
.
asTextureProxyRef
(
)
;
return
true
;
#
else
return
false
;
#
endif
}
static
uint8_t
eval_V
(
float
top
int
y
const
uint8_t
*
integral
int
integralSize
float
sixSigma
)
{
if
(
top
<
0
)
{
return
0
;
}
float
fT
=
(
top
-
y
-
0
.
5f
)
*
(
integralSize
/
sixSigma
)
;
if
(
fT
<
0
)
{
return
255
;
}
else
if
(
fT
>
=
integralSize
-
1
)
{
return
0
;
}
int
lower
=
(
int
)
fT
;
float
frac
=
fT
-
lower
;
SkASSERT
(
lower
+
1
<
integralSize
)
;
return
integral
[
lower
]
*
(
1
.
0f
-
frac
)
+
integral
[
lower
+
1
]
*
frac
;
}
static
uint8_t
eval_H
(
int
x
int
y
const
std
:
:
vector
<
float
>
&
topVec
const
float
*
kernel
int
kernelSize
const
uint8_t
*
integral
int
integralSize
float
sixSigma
)
{
SkASSERT
(
0
<
=
x
&
&
x
<
(
int
)
topVec
.
size
(
)
)
;
SkASSERT
(
kernelSize
%
2
)
;
float
accum
=
0
.
0f
;
int
xSampleLoc
=
x
-
(
kernelSize
/
2
)
;
for
(
int
i
=
0
;
i
<
kernelSize
;
+
+
i
+
+
xSampleLoc
)
{
if
(
xSampleLoc
<
0
|
|
xSampleLoc
>
=
(
int
)
topVec
.
size
(
)
)
{
continue
;
}
accum
+
=
kernel
[
i
]
*
eval_V
(
topVec
[
xSampleLoc
]
y
integral
integralSize
sixSigma
)
;
}
return
accum
+
0
.
5f
;
}
static
GrSurfaceProxyView
create_mask_on_cpu
(
GrRecordingContext
*
rContext
const
SkRRect
&
rrectToDraw
const
SkISize
&
dimensions
float
xformedSigma
)
{
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
;
int
radius
=
SkGpuBlurUtils
:
:
SigmaRadius
(
xformedSigma
)
;
int
kernelSize
=
2
*
radius
+
1
;
SkASSERT
(
kernelSize
%
2
)
;
SkASSERT
(
dimensions
.
width
(
)
%
2
)
;
SkASSERT
(
dimensions
.
height
(
)
%
2
)
;
SkVector
radii
=
rrectToDraw
.
getSimpleRadii
(
)
;
SkASSERT
(
SkScalarNearlyEqual
(
radii
.
fX
radii
.
fY
)
)
;
const
int
halfWidthPlus1
=
(
dimensions
.
width
(
)
/
2
)
+
1
;
const
int
halfHeightPlus1
=
(
dimensions
.
height
(
)
/
2
)
+
1
;
std
:
:
unique_ptr
<
float
[
]
>
kernel
(
new
float
[
kernelSize
]
)
;
SkGpuBlurUtils
:
:
Compute1DGaussianKernel
(
kernel
.
get
(
)
xformedSigma
radius
)
;
SkBitmap
integral
;
if
(
!
SkGpuBlurUtils
:
:
CreateIntegralTable
(
6
*
xformedSigma
&
integral
)
)
{
return
{
}
;
}
SkBitmap
result
;
if
(
!
result
.
tryAllocPixels
(
SkImageInfo
:
:
MakeA8
(
dimensions
.
width
(
)
dimensions
.
height
(
)
)
)
)
{
return
{
}
;
}
std
:
:
vector
<
float
>
topVec
;
topVec
.
reserve
(
dimensions
.
width
(
)
)
;
for
(
int
x
=
0
;
x
<
dimensions
.
width
(
)
;
+
+
x
)
{
if
(
x
<
rrectToDraw
.
rect
(
)
.
fLeft
|
|
x
>
rrectToDraw
.
rect
(
)
.
fRight
)
{
topVec
.
push_back
(
-
1
)
;
}
else
{
if
(
x
+
0
.
5f
<
rrectToDraw
.
rect
(
)
.
fLeft
+
radii
.
fX
)
{
float
xDist
=
rrectToDraw
.
rect
(
)
.
fLeft
+
radii
.
fX
-
x
-
0
.
5f
;
float
h
=
sqrtf
(
radii
.
fX
*
radii
.
fX
-
xDist
*
xDist
)
;
SkASSERT
(
0
<
=
h
&
&
h
<
radii
.
fY
)
;
topVec
.
push_back
(
rrectToDraw
.
rect
(
)
.
fTop
+
radii
.
fX
-
h
+
3
*
xformedSigma
)
;
}
else
{
topVec
.
push_back
(
rrectToDraw
.
rect
(
)
.
fTop
+
3
*
xformedSigma
)
;
}
}
}
for
(
int
y
=
0
;
y
<
halfHeightPlus1
;
+
+
y
)
{
uint8_t
*
scanline
=
result
.
getAddr8
(
0
y
)
;
for
(
int
x
=
0
;
x
<
halfWidthPlus1
;
+
+
x
)
{
scanline
[
x
]
=
eval_H
(
x
y
topVec
kernel
.
get
(
)
kernelSize
integral
.
getAddr8
(
0
0
)
integral
.
width
(
)
6
*
xformedSigma
)
;
scanline
[
dimensions
.
width
(
)
-
x
-
1
]
=
scanline
[
x
]
;
}
memcpy
(
result
.
getAddr8
(
0
dimensions
.
height
(
)
-
y
-
1
)
scanline
result
.
rowBytes
(
)
)
;
}
result
.
setImmutable
(
)
;
auto
view
=
std
:
:
get
<
0
>
(
GrMakeUncachedBitmapProxyView
(
rContext
result
)
)
;
if
(
!
view
)
{
return
{
}
;
}
SkASSERT
(
view
.
origin
(
)
=
=
kBlurredRRectMaskOrigin
)
;
return
view
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
find_or_create_rrect_blur_mask_fp
(
GrRecordingContext
*
rContext
const
SkRRect
&
rrectToDraw
const
SkISize
&
dimensions
float
xformedSigma
)
{
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
;
skgpu
:
:
UniqueKey
key
;
make_blurred_rrect_key
(
&
key
rrectToDraw
xformedSigma
)
;
auto
threadSafeCache
=
rContext
-
>
priv
(
)
.
threadSafeCache
(
)
;
auto
m
=
SkMatrix
:
:
Scale
(
dimensions
.
width
(
)
dimensions
.
height
(
)
)
;
GrSurfaceProxyView
view
;
if
(
GrDirectContext
*
dContext
=
rContext
-
>
asDirectContext
(
)
)
{
auto
[
lazyView
trampoline
]
=
GrThreadSafeCache
:
:
CreateLazyView
(
dContext
GrColorType
:
:
kAlpha_8
dimensions
kBlurredRRectMaskOrigin
SkBackingFit
:
:
kExact
)
;
if
(
!
lazyView
)
{
return
nullptr
;
}
view
=
threadSafeCache
-
>
findOrAdd
(
key
lazyView
)
;
if
(
view
!
=
lazyView
)
{
SkASSERT
(
view
.
asTextureProxy
(
)
)
;
SkASSERT
(
view
.
origin
(
)
=
=
kBlurredRRectMaskOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
kPremul_SkAlphaType
m
)
;
}
if
(
!
fillin_view_on_gpu
(
dContext
lazyView
std
:
:
move
(
trampoline
)
rrectToDraw
dimensions
xformedSigma
)
)
{
threadSafeCache
-
>
remove
(
key
)
;
return
nullptr
;
}
}
else
{
view
=
threadSafeCache
-
>
find
(
key
)
;
if
(
view
)
{
SkASSERT
(
view
.
asTextureProxy
(
)
)
;
SkASSERT
(
view
.
origin
(
)
=
=
kBlurredRRectMaskOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
kPremul_SkAlphaType
m
)
;
}
view
=
create_mask_on_cpu
(
rContext
rrectToDraw
dimensions
xformedSigma
)
;
if
(
!
view
)
{
return
nullptr
;
}
view
=
threadSafeCache
-
>
add
(
key
view
)
;
}
SkASSERT
(
view
.
asTextureProxy
(
)
)
;
SkASSERT
(
view
.
origin
(
)
=
=
kBlurredRRectMaskOrigin
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
kPremul_SkAlphaType
m
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_rrect_blur
(
GrRecordingContext
*
context
float
sigma
float
xformedSigma
const
SkRRect
&
srcRRect
const
SkRRect
&
devRRect
)
{
#
ifdef
SK_DEBUG
SkASSERTF
(
!
SkRRectPriv
:
:
IsCircle
(
devRRect
)
"
Unexpected
circle
.
%
d
\
n
\
t
%
s
\
n
\
t
%
s
"
SkRRectPriv
:
:
IsCircle
(
srcRRect
)
srcRRect
.
dumpToString
(
true
)
.
c_str
(
)
devRRect
.
dumpToString
(
true
)
.
c_str
(
)
)
;
SkASSERTF
(
!
devRRect
.
isRect
(
)
"
Unexpected
rect
.
%
d
\
n
\
t
%
s
\
n
\
t
%
s
"
srcRRect
.
isRect
(
)
srcRRect
.
dumpToString
(
true
)
.
c_str
(
)
devRRect
.
dumpToString
(
true
)
.
c_str
(
)
)
;
#
endif
if
(
!
SkRRectPriv
:
:
IsSimpleCircular
(
devRRect
)
)
{
return
nullptr
;
}
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
{
return
nullptr
;
}
SkRRect
rrectToDraw
;
SkISize
dimensions
;
SkScalar
ignored
[
SkGpuBlurUtils
:
:
kBlurRRectMaxDivisions
]
;
bool
ninePatchable
=
SkGpuBlurUtils
:
:
ComputeBlurredRRectParams
(
srcRRect
devRRect
sigma
xformedSigma
&
rrectToDraw
&
dimensions
ignored
ignored
ignored
ignored
)
;
if
(
!
ninePatchable
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
maskFP
=
find_or_create_rrect_blur_mask_fp
(
context
rrectToDraw
dimensions
xformedSigma
)
;
if
(
!
maskFP
)
{
return
nullptr
;
}
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
shader
ninePatchFP
;
"
"
uniform
half
cornerRadius
;
"
"
uniform
float4
proxyRect
;
"
"
uniform
half
blurRadius
;
"
"
half4
main
(
float2
xy
)
{
"
"
float2
translatedFragPosFloat
=
sk_FragCoord
.
xy
-
proxyRect
.
LT
;
"
"
float2
proxyCenter
=
(
proxyRect
.
RB
-
proxyRect
.
LT
)
*
0
.
5
;
"
"
half
edgeSize
=
2
.
0
*
blurRadius
+
cornerRadius
+
0
.
5
;
"
"
translatedFragPosFloat
-
=
proxyCenter
;
"
"
half2
fragDirection
=
half2
(
sign
(
translatedFragPosFloat
)
)
;
"
"
translatedFragPosFloat
=
abs
(
translatedFragPosFloat
)
;
"
"
half2
translatedFragPosHalf
=
half2
(
translatedFragPosFloat
-
(
proxyCenter
-
edgeSize
)
)
;
"
"
translatedFragPosHalf
=
max
(
translatedFragPosHalf
0
)
;
"
"
translatedFragPosHalf
*
=
fragDirection
;
"
"
translatedFragPosHalf
+
=
half2
(
edgeSize
)
;
"
"
half2
proxyDims
=
half2
(
2
.
0
*
edgeSize
)
;
"
"
half2
texCoord
=
translatedFragPosHalf
/
proxyDims
;
"
"
return
ninePatchFP
.
eval
(
texCoord
)
.
aaaa
;
"
"
}
"
)
;
float
cornerRadius
=
SkRRectPriv
:
:
GetSimpleRadii
(
devRRect
)
.
fX
;
float
blurRadius
=
3
.
f
*
SkScalarCeilToScalar
(
xformedSigma
-
1
/
6
.
0f
)
;
SkRect
proxyRect
=
devRRect
.
getBounds
(
)
.
makeOutset
(
blurRadius
blurRadius
)
;
auto
rrectBlurFP
=
GrSkSLFP
:
:
Make
(
effect
"
RRectBlur
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kCompatibleWithCoverageAsAlpha
"
ninePatchFP
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
maskFP
)
)
"
cornerRadius
"
cornerRadius
"
proxyRect
"
proxyRect
"
blurRadius
"
blurRadius
)
;
return
GrBlendFragmentProcessor
:
:
Make
<
SkBlendMode
:
:
kModulate
>
(
std
:
:
move
(
rrectBlurFP
)
nullptr
)
;
}
bool
SkBlurMaskFilterImpl
:
:
directFilterMaskGPU
(
GrRecordingContext
*
context
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
GrPaint
&
&
paint
const
GrClip
*
clip
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
shape
)
const
{
SkASSERT
(
sdc
)
;
if
(
fBlurStyle
!
=
kNormal_SkBlurStyle
)
{
return
false
;
}
if
(
!
shape
.
style
(
)
.
isSimpleFill
(
)
)
{
return
false
;
}
SkScalar
xformedSigma
=
this
-
>
computeXformedSigma
(
viewMatrix
)
;
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
{
sdc
-
>
drawShape
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kYes
viewMatrix
GrStyledShape
(
shape
)
)
;
return
true
;
}
SkRRect
srcRRect
;
bool
inverted
;
if
(
!
shape
.
asRRect
(
&
srcRRect
nullptr
nullptr
&
inverted
)
|
|
inverted
)
{
return
false
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
;
SkRRect
devRRect
;
bool
devRRectIsValid
=
srcRRect
.
transform
(
viewMatrix
&
devRRect
)
;
bool
devRRectIsCircle
=
devRRectIsValid
&
&
SkRRectPriv
:
:
IsCircle
(
devRRect
)
;
bool
canBeRect
=
srcRRect
.
isRect
(
)
&
&
viewMatrix
.
preservesRightAngles
(
)
;
bool
canBeCircle
=
(
SkRRectPriv
:
:
IsCircle
(
srcRRect
)
&
&
viewMatrix
.
isSimilarity
(
)
)
|
|
devRRectIsCircle
;
if
(
canBeRect
|
|
canBeCircle
)
{
if
(
canBeRect
)
{
fp
=
make_rect_blur
(
context
*
context
-
>
priv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
srcRRect
.
rect
(
)
viewMatrix
xformedSigma
)
;
}
else
{
SkRect
devBounds
;
if
(
devRRectIsCircle
)
{
devBounds
=
devRRect
.
getBounds
(
)
;
}
else
{
SkPoint
center
=
{
srcRRect
.
getBounds
(
)
.
centerX
(
)
srcRRect
.
getBounds
(
)
.
centerY
(
)
}
;
viewMatrix
.
mapPoints
(
&
center
1
)
;
SkScalar
radius
=
viewMatrix
.
mapVector
(
0
srcRRect
.
width
(
)
/
2
.
f
)
.
length
(
)
;
devBounds
=
{
center
.
x
(
)
-
radius
center
.
y
(
)
-
radius
center
.
x
(
)
+
radius
center
.
y
(
)
+
radius
}
;
}
fp
=
make_circle_blur
(
context
devBounds
xformedSigma
)
;
}
if
(
!
fp
)
{
return
false
;
}
SkRect
srcProxyRect
=
srcRRect
.
rect
(
)
;
SkScalar
outsetX
=
3
.
0f
*
xformedSigma
;
SkScalar
outsetY
=
3
.
0f
*
xformedSigma
;
if
(
viewMatrix
.
isScaleTranslate
(
)
)
{
outsetX
/
=
SkScalarAbs
(
viewMatrix
.
getScaleX
(
)
)
;
outsetY
/
=
SkScalarAbs
(
viewMatrix
.
getScaleY
(
)
)
;
}
else
{
SkSize
scale
;
if
(
!
viewMatrix
.
decomposeScale
(
&
scale
nullptr
)
)
{
return
false
;
}
outsetX
/
=
scale
.
width
(
)
;
outsetY
/
=
scale
.
height
(
)
;
}
srcProxyRect
.
outset
(
outsetX
outsetY
)
;
paint
.
setCoverageFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
sdc
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
viewMatrix
srcProxyRect
)
;
return
true
;
}
if
(
!
viewMatrix
.
isScaleTranslate
(
)
)
{
return
false
;
}
if
(
!
devRRectIsValid
|
|
!
SkRRectPriv
:
:
AllCornersCircular
(
devRRect
)
)
{
return
false
;
}
fp
=
make_rrect_blur
(
context
fSigma
xformedSigma
srcRRect
devRRect
)
;
if
(
!
fp
)
{
return
false
;
}
if
(
!
this
-
>
ignoreXform
(
)
)
{
SkRect
srcProxyRect
=
srcRRect
.
rect
(
)
;
srcProxyRect
.
outset
(
3
.
0f
*
fSigma
3
.
0f
*
fSigma
)
;
paint
.
setCoverageFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
sdc
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
viewMatrix
srcProxyRect
)
;
}
else
{
SkMatrix
inverse
;
if
(
!
viewMatrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
SkIRect
proxyBounds
;
float
extra
=
3
.
f
*
SkScalarCeilToScalar
(
xformedSigma
-
1
/
6
.
0f
)
;
devRRect
.
rect
(
)
.
makeOutset
(
extra
extra
)
.
roundOut
(
&
proxyBounds
)
;
paint
.
setCoverageFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
sdc
-
>
fillPixelsWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
proxyBounds
inverse
)
;
}
return
true
;
}
bool
SkBlurMaskFilterImpl
:
:
canFilterMaskGPU
(
const
GrStyledShape
&
shape
const
SkIRect
&
devSpaceShapeBounds
const
SkIRect
&
clipBounds
const
SkMatrix
&
ctm
SkIRect
*
maskRect
)
const
{
SkScalar
xformedSigma
=
this
-
>
computeXformedSigma
(
ctm
)
;
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
xformedSigma
)
)
{
*
maskRect
=
devSpaceShapeBounds
;
return
maskRect
-
>
intersect
(
clipBounds
)
;
}
if
(
maskRect
)
{
float
sigma3
=
3
*
SkScalarToFloat
(
xformedSigma
)
;
SkIRect
clipRect
=
clipBounds
.
makeOutset
(
sigma3
sigma3
)
;
SkIRect
srcRect
=
devSpaceShapeBounds
.
makeOutset
(
sigma3
sigma3
)
;
if
(
!
srcRect
.
intersect
(
clipRect
)
)
{
srcRect
.
setEmpty
(
)
;
}
*
maskRect
=
srcRect
;
}
static
const
SkScalar
kMIN_GPU_BLUR_SIZE
=
SkIntToScalar
(
64
)
;
static
const
SkScalar
kMIN_GPU_BLUR_SIGMA
=
SkIntToScalar
(
32
)
;
if
(
devSpaceShapeBounds
.
width
(
)
<
=
kMIN_GPU_BLUR_SIZE
&
&
devSpaceShapeBounds
.
height
(
)
<
=
kMIN_GPU_BLUR_SIZE
&
&
xformedSigma
<
=
kMIN_GPU_BLUR_SIGMA
)
{
return
false
;
}
return
true
;
}
GrSurfaceProxyView
SkBlurMaskFilterImpl
:
:
filterMaskGPU
(
GrRecordingContext
*
context
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
const
SkMatrix
&
ctm
const
SkIRect
&
maskRect
)
const
{
const
SkIRect
clipRect
=
SkIRect
:
:
MakeWH
(
maskRect
.
width
(
)
maskRect
.
height
(
)
)
;
SkScalar
xformedSigma
=
this
-
>
computeXformedSigma
(
ctm
)
;
bool
isNormalBlur
=
(
kNormal_SkBlurStyle
=
=
fBlurStyle
)
;
auto
srcBounds
=
SkIRect
:
:
MakeSize
(
srcView
.
proxy
(
)
-
>
dimensions
(
)
)
;
auto
surfaceDrawContext
=
SkGpuBlurUtils
:
:
GaussianBlur
(
context
srcView
srcColorType
srcAlphaType
nullptr
clipRect
srcBounds
xformedSigma
xformedSigma
SkTileMode
:
:
kClamp
)
;
if
(
!
surfaceDrawContext
|
|
!
surfaceDrawContext
-
>
asTextureProxy
(
)
)
{
return
{
}
;
}
if
(
!
isNormalBlur
)
{
GrPaint
paint
;
paint
.
setCoverageFragmentProcessor
(
GrTextureEffect
:
:
Make
(
std
:
:
move
(
srcView
)
srcAlphaType
)
)
;
if
(
kInner_SkBlurStyle
=
=
fBlurStyle
)
{
paint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kIntersect_Op
)
;
}
else
if
(
kSolid_SkBlurStyle
=
=
fBlurStyle
)
{
paint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kUnion_Op
)
;
}
else
if
(
kOuter_SkBlurStyle
=
=
fBlurStyle
)
{
paint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kDifference_Op
)
;
}
else
{
paint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kReplace_Op
)
;
}
surfaceDrawContext
-
>
fillPixelsWithLocalMatrix
(
nullptr
std
:
:
move
(
paint
)
clipRect
SkMatrix
:
:
I
(
)
)
;
}
return
surfaceDrawContext
-
>
readSurfaceView
(
)
;
}
#
endif
void
sk_register_blur_maskfilter_createproc
(
)
{
SK_REGISTER_FLATTENABLE
(
SkBlurMaskFilterImpl
)
;
}
sk_sp
<
SkMaskFilter
>
SkMaskFilter
:
:
MakeBlur
(
SkBlurStyle
style
SkScalar
sigma
bool
respectCTM
)
{
if
(
SkScalarIsFinite
(
sigma
)
&
&
sigma
>
0
)
{
return
sk_sp
<
SkMaskFilter
>
(
new
SkBlurMaskFilterImpl
(
sigma
style
respectCTM
)
)
;
}
return
nullptr
;
}
