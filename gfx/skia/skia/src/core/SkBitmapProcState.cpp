#
include
"
SkBitmapCache
.
h
"
#
include
"
SkBitmapController
.
h
"
#
include
"
SkBitmapProcState
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkFilterProc
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkUtilsArm
.
h
"
#
include
"
SkBitmapScaler
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkImageEncoder
.
h
"
#
include
"
SkResourceCache
.
h
"
#
if
!
SK_ARM_NEON_IS_NONE
extern
const
SkBitmapProcState
:
:
SampleProc32
gSkBitmapProcStateSample32_neon
[
]
;
extern
void
S16_D16_filter_DX_neon
(
const
SkBitmapProcState
&
const
uint32_t
*
int
uint16_t
*
)
;
extern
void
Clamp_S16_D16_filter_DX_shaderproc_neon
(
const
void
*
int
int
uint16_t
*
int
)
;
extern
void
Repeat_S16_D16_filter_DX_shaderproc_neon
(
const
void
*
int
int
uint16_t
*
int
)
;
extern
void
SI8_opaque_D32_filter_DX_neon
(
const
SkBitmapProcState
&
const
uint32_t
*
int
SkPMColor
*
)
;
extern
void
SI8_opaque_D32_filter_DX_shaderproc_neon
(
const
void
*
int
int
uint32_t
*
int
)
;
extern
void
Clamp_SI8_opaque_D32_filter_DX_shaderproc_neon
(
const
void
*
int
int
uint32_t
*
int
)
;
#
endif
extern
void
Clamp_S32_opaque_D32_nofilter_DX_shaderproc
(
const
void
*
int
int
uint32_t
*
int
)
;
#
define
NAME_WRAP
(
x
)
x
#
include
"
SkBitmapProcState_filter
.
h
"
#
include
"
SkBitmapProcState_procs
.
h
"
SkBitmapProcState
:
:
SkBitmapProcState
(
const
SkBitmapProvider
&
provider
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
)
:
fProvider
(
provider
)
fBMState
(
nullptr
)
{
fTileModeX
=
tmx
;
fTileModeY
=
tmy
;
}
SkBitmapProcState
:
:
SkBitmapProcState
(
const
SkBitmap
&
bm
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
)
:
fProvider
(
SkBitmapProvider
(
bm
)
)
fBMState
(
nullptr
)
{
fTileModeX
=
tmx
;
fTileModeY
=
tmy
;
}
SkBitmapProcState
:
:
~
SkBitmapProcState
(
)
{
SkInPlaceDeleteCheck
(
fBMState
fBMStateStorage
.
get
(
)
)
;
}
static
bool
matrix_only_scale_translate
(
const
SkMatrix
&
m
)
{
return
m
.
getType
(
)
<
=
(
SkMatrix
:
:
kScale_Mask
|
SkMatrix
:
:
kTranslate_Mask
)
;
}
static
bool
just_trans_clamp
(
const
SkMatrix
&
matrix
const
SkPixmap
&
pixmap
)
{
SkASSERT
(
matrix_only_scale_translate
(
matrix
)
)
;
if
(
matrix
.
getType
(
)
&
SkMatrix
:
:
kScale_Mask
)
{
SkRect
dst
;
SkRect
src
=
SkRect
:
:
Make
(
pixmap
.
bounds
(
)
)
;
matrix
.
mapPoints
(
SkTCast
<
SkPoint
*
>
(
&
dst
)
SkTCast
<
const
SkPoint
*
>
(
&
src
)
2
)
;
SkIRect
idst
;
dst
.
round
(
&
idst
)
;
return
idst
.
width
(
)
=
=
pixmap
.
width
(
)
&
&
idst
.
height
(
)
=
=
pixmap
.
height
(
)
;
}
return
true
;
}
static
bool
just_trans_general
(
const
SkMatrix
&
matrix
)
{
SkASSERT
(
matrix_only_scale_translate
(
matrix
)
)
;
if
(
matrix
.
getType
(
)
&
SkMatrix
:
:
kScale_Mask
)
{
const
SkScalar
tol
=
SK_Scalar1
/
32768
;
if
(
!
SkScalarNearlyZero
(
matrix
[
SkMatrix
:
:
kMScaleX
]
-
SK_Scalar1
tol
)
)
{
return
false
;
}
if
(
!
SkScalarNearlyZero
(
matrix
[
SkMatrix
:
:
kMScaleY
]
-
SK_Scalar1
tol
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
valid_for_filtering
(
unsigned
dimension
)
{
return
(
dimension
&
~
0x3FFF
)
=
=
0
;
}
bool
SkBitmapProcState
:
:
chooseProcs
(
const
SkMatrix
&
inv
const
SkPaint
&
paint
)
{
fPixmap
.
reset
(
)
;
fInvMatrix
=
inv
;
fFilterLevel
=
paint
.
getFilterQuality
(
)
;
SkDefaultBitmapController
controller
;
fBMState
=
controller
.
requestBitmap
(
fProvider
inv
paint
.
getFilterQuality
(
)
fBMStateStorage
.
get
(
)
fBMStateStorage
.
size
(
)
)
;
if
(
nullptr
=
=
fBMState
|
|
fBMState
-
>
pixmap
(
)
.
info
(
)
.
isEmpty
(
)
)
{
return
false
;
}
fPixmap
=
fBMState
-
>
pixmap
(
)
;
fInvMatrix
=
fBMState
-
>
invMatrix
(
)
;
fFilterLevel
=
fBMState
-
>
quality
(
)
;
SkASSERT
(
fPixmap
.
addr
(
)
)
;
bool
trivialMatrix
=
(
fInvMatrix
.
getType
(
)
&
~
SkMatrix
:
:
kTranslate_Mask
)
=
=
0
;
bool
clampClamp
=
SkShader
:
:
kClamp_TileMode
=
=
fTileModeX
&
&
SkShader
:
:
kClamp_TileMode
=
=
fTileModeY
;
if
(
!
(
clampClamp
|
|
trivialMatrix
)
)
{
fInvMatrix
.
postIDiv
(
fPixmap
.
width
(
)
fPixmap
.
height
(
)
)
;
}
if
(
matrix_only_scale_translate
(
fInvMatrix
)
)
{
SkMatrix
forward
;
if
(
fInvMatrix
.
invert
(
&
forward
)
)
{
if
(
clampClamp
?
just_trans_clamp
(
forward
fPixmap
)
:
just_trans_general
(
forward
)
)
{
SkScalar
tx
=
-
SkScalarRoundToScalar
(
forward
.
getTranslateX
(
)
)
;
SkScalar
ty
=
-
SkScalarRoundToScalar
(
forward
.
getTranslateY
(
)
)
;
fInvMatrix
.
setTranslate
(
tx
ty
)
;
}
}
}
fInvProc
=
fInvMatrix
.
getMapXYProc
(
)
;
fInvType
=
fInvMatrix
.
getType
(
)
;
fInvSx
=
SkScalarToFixed
(
fInvMatrix
.
getScaleX
(
)
)
;
fInvSxFractionalInt
=
SkScalarToFractionalInt
(
fInvMatrix
.
getScaleX
(
)
)
;
fInvKy
=
SkScalarToFixed
(
fInvMatrix
.
getSkewY
(
)
)
;
fInvKyFractionalInt
=
SkScalarToFractionalInt
(
fInvMatrix
.
getSkewY
(
)
)
;
fAlphaScale
=
SkAlpha255To256
(
paint
.
getAlpha
(
)
)
;
fShaderProc32
=
nullptr
;
fShaderProc16
=
nullptr
;
fSampleProc32
=
nullptr
;
trivialMatrix
=
(
fInvMatrix
.
getType
(
)
&
~
SkMatrix
:
:
kTranslate_Mask
)
=
=
0
;
if
(
kLow_SkFilterQuality
=
=
fFilterLevel
)
{
if
(
fInvType
<
=
SkMatrix
:
:
kTranslate_Mask
|
|
!
valid_for_filtering
(
fPixmap
.
width
(
)
|
fPixmap
.
height
(
)
)
)
{
fFilterLevel
=
kNone_SkFilterQuality
;
}
}
return
this
-
>
chooseScanlineProcs
(
trivialMatrix
clampClamp
paint
)
;
}
bool
SkBitmapProcState
:
:
chooseScanlineProcs
(
bool
trivialMatrix
bool
clampClamp
const
SkPaint
&
paint
)
{
fMatrixProc
=
this
-
>
chooseMatrixProc
(
trivialMatrix
)
;
if
(
nullptr
=
=
fMatrixProc
)
{
return
false
;
}
const
SkAlphaType
at
=
fPixmap
.
alphaType
(
)
;
if
(
fFilterLevel
<
kHigh_SkFilterQuality
)
{
int
index
=
0
;
if
(
fAlphaScale
<
256
)
{
index
|
=
1
;
}
if
(
fInvType
<
=
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
{
index
|
=
2
;
}
if
(
fFilterLevel
>
kNone_SkFilterQuality
)
{
index
|
=
4
;
}
switch
(
fPixmap
.
colorType
(
)
)
{
case
kN32_SkColorType
:
if
(
kPremul_SkAlphaType
!
=
at
&
&
kOpaque_SkAlphaType
!
=
at
)
{
return
false
;
}
index
|
=
0
;
break
;
case
kRGB_565_SkColorType
:
index
|
=
8
;
break
;
case
kIndex_8_SkColorType
:
if
(
kPremul_SkAlphaType
!
=
at
&
&
kOpaque_SkAlphaType
!
=
at
)
{
return
false
;
}
index
|
=
16
;
break
;
case
kARGB_4444_SkColorType
:
if
(
kPremul_SkAlphaType
!
=
at
&
&
kOpaque_SkAlphaType
!
=
at
)
{
return
false
;
}
index
|
=
24
;
break
;
case
kAlpha_8_SkColorType
:
index
|
=
32
;
fPaintPMColor
=
SkPreMultiplyColor
(
paint
.
getColor
(
)
)
;
break
;
case
kGray_8_SkColorType
:
index
|
=
40
;
fPaintPMColor
=
SkPreMultiplyColor
(
paint
.
getColor
(
)
)
;
break
;
default
:
return
false
;
}
#
if
!
SK_ARM_NEON_IS_ALWAYS
static
const
SampleProc32
gSkBitmapProcStateSample32
[
]
=
{
S32_opaque_D32_nofilter_DXDY
S32_alpha_D32_nofilter_DXDY
S32_opaque_D32_nofilter_DX
S32_alpha_D32_nofilter_DX
S32_opaque_D32_filter_DXDY
S32_alpha_D32_filter_DXDY
S32_opaque_D32_filter_DX
S32_alpha_D32_filter_DX
S16_opaque_D32_nofilter_DXDY
S16_alpha_D32_nofilter_DXDY
S16_opaque_D32_nofilter_DX
S16_alpha_D32_nofilter_DX
S16_opaque_D32_filter_DXDY
S16_alpha_D32_filter_DXDY
S16_opaque_D32_filter_DX
S16_alpha_D32_filter_DX
SI8_opaque_D32_nofilter_DXDY
SI8_alpha_D32_nofilter_DXDY
SI8_opaque_D32_nofilter_DX
SI8_alpha_D32_nofilter_DX
SI8_opaque_D32_filter_DXDY
SI8_alpha_D32_filter_DXDY
SI8_opaque_D32_filter_DX
SI8_alpha_D32_filter_DX
S4444_opaque_D32_nofilter_DXDY
S4444_alpha_D32_nofilter_DXDY
S4444_opaque_D32_nofilter_DX
S4444_alpha_D32_nofilter_DX
S4444_opaque_D32_filter_DXDY
S4444_alpha_D32_filter_DXDY
S4444_opaque_D32_filter_DX
S4444_alpha_D32_filter_DX
SA8_alpha_D32_nofilter_DXDY
SA8_alpha_D32_nofilter_DXDY
SA8_alpha_D32_nofilter_DX
SA8_alpha_D32_nofilter_DX
SA8_alpha_D32_filter_DXDY
SA8_alpha_D32_filter_DXDY
SA8_alpha_D32_filter_DX
SA8_alpha_D32_filter_DX
SG8_alpha_D32_nofilter_DXDY
SG8_alpha_D32_nofilter_DXDY
SG8_alpha_D32_nofilter_DX
SG8_alpha_D32_nofilter_DX
SG8_alpha_D32_filter_DXDY
SG8_alpha_D32_filter_DXDY
SG8_alpha_D32_filter_DX
SG8_alpha_D32_filter_DX
}
;
#
endif
fSampleProc32
=
SK_ARM_NEON_WRAP
(
gSkBitmapProcStateSample32
)
[
index
]
;
index
>
>
=
1
;
if
(
SK_ARM_NEON_WRAP
(
SI8_opaque_D32_filter_DX
)
=
=
fSampleProc32
&
&
clampClamp
)
{
fShaderProc32
=
SK_ARM_NEON_WRAP
(
Clamp_SI8_opaque_D32_filter_DX_shaderproc
)
;
}
else
if
(
S32_opaque_D32_nofilter_DX
=
=
fSampleProc32
&
&
clampClamp
)
{
fShaderProc32
=
Clamp_S32_opaque_D32_nofilter_DX_shaderproc
;
}
if
(
nullptr
=
=
fShaderProc32
)
{
fShaderProc32
=
this
-
>
chooseShaderProc32
(
)
;
}
}
this
-
>
platformProcs
(
)
;
return
true
;
}
static
void
Clamp_S32_D32_nofilter_trans_shaderproc
(
const
void
*
sIn
int
x
int
y
SkPMColor
*
SK_RESTRICT
colors
int
count
)
{
const
SkBitmapProcState
&
s
=
*
static_cast
<
const
SkBitmapProcState
*
>
(
sIn
)
;
SkASSERT
(
(
(
s
.
fInvType
&
~
SkMatrix
:
:
kTranslate_Mask
)
)
=
=
0
)
;
SkASSERT
(
s
.
fInvKy
=
=
0
)
;
SkASSERT
(
count
>
0
&
&
colors
!
=
nullptr
)
;
SkASSERT
(
kNone_SkFilterQuality
=
=
s
.
fFilterLevel
)
;
const
int
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
const
int
maxY
=
s
.
fPixmap
.
height
(
)
-
1
;
int
ix
=
s
.
fFilterOneX
+
x
;
int
iy
=
SkClampMax
(
s
.
fFilterOneY
+
y
maxY
)
;
#
ifdef
SK_DEBUG
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
int
iy2
=
SkClampMax
(
SkScalarFloorToInt
(
pt
.
fY
)
maxY
)
;
int
ix2
=
SkScalarFloorToInt
(
pt
.
fX
)
;
SkASSERT
(
iy
=
=
iy2
)
;
SkASSERT
(
ix
=
=
ix2
)
;
}
#
endif
const
SkPMColor
*
row
=
s
.
fPixmap
.
addr32
(
0
iy
)
;
if
(
ix
<
0
)
{
int
n
=
SkMin32
(
-
ix
count
)
;
sk_memset32
(
colors
row
[
0
]
n
)
;
count
-
=
n
;
if
(
0
=
=
count
)
{
return
;
}
colors
+
=
n
;
SkASSERT
(
-
ix
=
=
n
)
;
ix
=
0
;
}
if
(
ix
<
=
maxX
)
{
int
n
=
SkMin32
(
maxX
-
ix
+
1
count
)
;
memcpy
(
colors
row
+
ix
n
*
sizeof
(
SkPMColor
)
)
;
count
-
=
n
;
if
(
0
=
=
count
)
{
return
;
}
colors
+
=
n
;
}
SkASSERT
(
count
>
0
)
;
sk_memset32
(
colors
row
[
maxX
]
count
)
;
}
static
inline
int
sk_int_mod
(
int
x
int
n
)
{
SkASSERT
(
n
>
0
)
;
if
(
(
unsigned
)
x
>
=
(
unsigned
)
n
)
{
if
(
x
<
0
)
{
x
=
n
+
~
(
~
x
%
n
)
;
}
else
{
x
=
x
%
n
;
}
}
return
x
;
}
static
inline
int
sk_int_mirror
(
int
x
int
n
)
{
x
=
sk_int_mod
(
x
2
*
n
)
;
if
(
x
>
=
n
)
{
x
=
n
+
~
(
x
-
n
)
;
}
return
x
;
}
static
void
Repeat_S32_D32_nofilter_trans_shaderproc
(
const
void
*
sIn
int
x
int
y
SkPMColor
*
SK_RESTRICT
colors
int
count
)
{
const
SkBitmapProcState
&
s
=
*
static_cast
<
const
SkBitmapProcState
*
>
(
sIn
)
;
SkASSERT
(
(
(
s
.
fInvType
&
~
SkMatrix
:
:
kTranslate_Mask
)
)
=
=
0
)
;
SkASSERT
(
s
.
fInvKy
=
=
0
)
;
SkASSERT
(
count
>
0
&
&
colors
!
=
nullptr
)
;
SkASSERT
(
kNone_SkFilterQuality
=
=
s
.
fFilterLevel
)
;
const
int
stopX
=
s
.
fPixmap
.
width
(
)
;
const
int
stopY
=
s
.
fPixmap
.
height
(
)
;
int
ix
=
s
.
fFilterOneX
+
x
;
int
iy
=
sk_int_mod
(
s
.
fFilterOneY
+
y
stopY
)
;
#
ifdef
SK_DEBUG
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
int
iy2
=
sk_int_mod
(
SkScalarFloorToInt
(
pt
.
fY
)
stopY
)
;
int
ix2
=
SkScalarFloorToInt
(
pt
.
fX
)
;
SkASSERT
(
iy
=
=
iy2
)
;
SkASSERT
(
ix
=
=
ix2
)
;
}
#
endif
const
SkPMColor
*
row
=
s
.
fPixmap
.
addr32
(
0
iy
)
;
ix
=
sk_int_mod
(
ix
stopX
)
;
for
(
;
;
)
{
int
n
=
SkMin32
(
stopX
-
ix
count
)
;
memcpy
(
colors
row
+
ix
n
*
sizeof
(
SkPMColor
)
)
;
count
-
=
n
;
if
(
0
=
=
count
)
{
return
;
}
colors
+
=
n
;
ix
=
0
;
}
}
static
void
S32_D32_constX_shaderproc
(
const
void
*
sIn
int
x
int
y
SkPMColor
*
SK_RESTRICT
colors
int
count
)
{
const
SkBitmapProcState
&
s
=
*
static_cast
<
const
SkBitmapProcState
*
>
(
sIn
)
;
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
SkASSERT
(
s
.
fInvKy
=
=
0
)
;
SkASSERT
(
count
>
0
&
&
colors
!
=
nullptr
)
;
SkASSERT
(
1
=
=
s
.
fPixmap
.
width
(
)
)
;
int
iY0
;
int
iY1
SK_INIT_TO_AVOID_WARNING
;
int
iSubY
SK_INIT_TO_AVOID_WARNING
;
if
(
kNone_SkFilterQuality
!
=
s
.
fFilterLevel
)
{
SkBitmapProcState
:
:
MatrixProc
mproc
=
s
.
getMatrixProc
(
)
;
uint32_t
xy
[
2
]
;
mproc
(
s
xy
1
x
y
)
;
iY0
=
xy
[
0
]
>
>
18
;
iY1
=
xy
[
0
]
&
0x3FFF
;
iSubY
=
(
xy
[
0
]
>
>
14
)
&
0xF
;
}
else
{
int
yTemp
;
if
(
s
.
fInvType
>
SkMatrix
:
:
kTranslate_Mask
)
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
if
(
SkShader
:
:
kClamp_TileMode
!
=
s
.
fTileModeX
|
|
SkShader
:
:
kClamp_TileMode
!
=
s
.
fTileModeY
)
{
yTemp
=
SkScalarFloorToInt
(
pt
.
fY
*
s
.
fPixmap
.
height
(
)
)
;
}
else
{
yTemp
=
SkScalarFloorToInt
(
pt
.
fY
)
;
}
}
else
{
yTemp
=
s
.
fFilterOneY
+
y
;
}
const
int
stopY
=
s
.
fPixmap
.
height
(
)
;
switch
(
s
.
fTileModeY
)
{
case
SkShader
:
:
kClamp_TileMode
:
iY0
=
SkClampMax
(
yTemp
stopY
-
1
)
;
break
;
case
SkShader
:
:
kRepeat_TileMode
:
iY0
=
sk_int_mod
(
yTemp
stopY
)
;
break
;
case
SkShader
:
:
kMirror_TileMode
:
default
:
iY0
=
sk_int_mirror
(
yTemp
stopY
)
;
break
;
}
#
ifdef
SK_DEBUG
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
if
(
s
.
fInvType
>
SkMatrix
:
:
kTranslate_Mask
&
&
(
SkShader
:
:
kClamp_TileMode
!
=
s
.
fTileModeX
|
|
SkShader
:
:
kClamp_TileMode
!
=
s
.
fTileModeY
)
)
{
pt
.
fY
*
=
s
.
fPixmap
.
height
(
)
;
}
int
iY2
;
switch
(
s
.
fTileModeY
)
{
case
SkShader
:
:
kClamp_TileMode
:
iY2
=
SkClampMax
(
SkScalarFloorToInt
(
pt
.
fY
)
stopY
-
1
)
;
break
;
case
SkShader
:
:
kRepeat_TileMode
:
iY2
=
sk_int_mod
(
SkScalarFloorToInt
(
pt
.
fY
)
stopY
)
;
break
;
case
SkShader
:
:
kMirror_TileMode
:
default
:
iY2
=
sk_int_mirror
(
SkScalarFloorToInt
(
pt
.
fY
)
stopY
)
;
break
;
}
SkASSERT
(
iY0
=
=
iY2
)
;
}
#
endif
}
const
SkPMColor
*
row0
=
s
.
fPixmap
.
addr32
(
0
iY0
)
;
SkPMColor
color
;
if
(
kNone_SkFilterQuality
!
=
s
.
fFilterLevel
)
{
const
SkPMColor
*
row1
=
s
.
fPixmap
.
addr32
(
0
iY1
)
;
if
(
s
.
fAlphaScale
<
256
)
{
Filter_32_alpha
(
iSubY
*
row0
*
row1
&
color
s
.
fAlphaScale
)
;
}
else
{
Filter_32_opaque
(
iSubY
*
row0
*
row1
&
color
)
;
}
}
else
{
if
(
s
.
fAlphaScale
<
256
)
{
color
=
SkAlphaMulQ
(
*
row0
s
.
fAlphaScale
)
;
}
else
{
color
=
*
row0
;
}
}
sk_memset32
(
colors
color
count
)
;
}
static
void
DoNothing_shaderproc
(
const
void
*
int
x
int
y
SkPMColor
*
SK_RESTRICT
colors
int
count
)
{
sk_memset32
(
colors
0
count
)
;
}
bool
SkBitmapProcState
:
:
setupForTranslate
(
)
{
SkPoint
pt
;
fInvProc
(
fInvMatrix
SK_ScalarHalf
SK_ScalarHalf
&
pt
)
;
const
SkScalar
too_big
=
SkIntToScalar
(
1
<
<
30
)
;
if
(
SkScalarAbs
(
pt
.
fX
)
>
too_big
|
|
SkScalarAbs
(
pt
.
fY
)
>
too_big
)
{
return
false
;
}
fFilterOneX
=
SkScalarFloorToInt
(
pt
.
fX
)
;
fFilterOneY
=
SkScalarFloorToInt
(
pt
.
fY
)
;
return
true
;
}
SkBitmapProcState
:
:
ShaderProc32
SkBitmapProcState
:
:
chooseShaderProc32
(
)
{
if
(
kN32_SkColorType
!
=
fPixmap
.
colorType
(
)
)
{
return
nullptr
;
}
static
const
unsigned
kMask
=
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
;
if
(
1
=
=
fPixmap
.
width
(
)
&
&
0
=
=
(
fInvType
&
~
kMask
)
)
{
if
(
kNone_SkFilterQuality
=
=
fFilterLevel
&
&
fInvType
<
=
SkMatrix
:
:
kTranslate_Mask
&
&
!
this
-
>
setupForTranslate
(
)
)
{
return
DoNothing_shaderproc
;
}
return
S32_D32_constX_shaderproc
;
}
if
(
fAlphaScale
<
256
)
{
return
nullptr
;
}
if
(
fInvType
>
SkMatrix
:
:
kTranslate_Mask
)
{
return
nullptr
;
}
if
(
kNone_SkFilterQuality
!
=
fFilterLevel
)
{
return
nullptr
;
}
SkShader
:
:
TileMode
tx
=
(
SkShader
:
:
TileMode
)
fTileModeX
;
SkShader
:
:
TileMode
ty
=
(
SkShader
:
:
TileMode
)
fTileModeY
;
if
(
SkShader
:
:
kClamp_TileMode
=
=
tx
&
&
SkShader
:
:
kClamp_TileMode
=
=
ty
)
{
if
(
this
-
>
setupForTranslate
(
)
)
{
return
Clamp_S32_D32_nofilter_trans_shaderproc
;
}
return
DoNothing_shaderproc
;
}
if
(
SkShader
:
:
kRepeat_TileMode
=
=
tx
&
&
SkShader
:
:
kRepeat_TileMode
=
=
ty
)
{
if
(
this
-
>
setupForTranslate
(
)
)
{
return
Repeat_S32_D32_nofilter_trans_shaderproc
;
}
return
DoNothing_shaderproc
;
}
return
nullptr
;
}
#
ifdef
SK_DEBUG
static
void
check_scale_nofilter
(
uint32_t
bitmapXY
[
]
int
count
unsigned
mx
unsigned
my
)
{
unsigned
y
=
*
bitmapXY
+
+
;
SkASSERT
(
y
<
my
)
;
const
uint16_t
*
xptr
=
reinterpret_cast
<
const
uint16_t
*
>
(
bitmapXY
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
xptr
[
i
]
<
mx
)
;
}
}
static
void
check_scale_filter
(
uint32_t
bitmapXY
[
]
int
count
unsigned
mx
unsigned
my
)
{
uint32_t
YY
=
*
bitmapXY
+
+
;
unsigned
y0
=
YY
>
>
18
;
unsigned
y1
=
YY
&
0x3FFF
;
SkASSERT
(
y0
<
my
)
;
SkASSERT
(
y1
<
my
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
uint32_t
XX
=
bitmapXY
[
i
]
;
unsigned
x0
=
XX
>
>
18
;
unsigned
x1
=
XX
&
0x3FFF
;
SkASSERT
(
x0
<
mx
)
;
SkASSERT
(
x1
<
mx
)
;
}
}
static
void
check_affine_nofilter
(
uint32_t
bitmapXY
[
]
int
count
unsigned
mx
unsigned
my
)
{
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
uint32_t
XY
=
bitmapXY
[
i
]
;
unsigned
x
=
XY
&
0xFFFF
;
unsigned
y
=
XY
>
>
16
;
SkASSERT
(
x
<
mx
)
;
SkASSERT
(
y
<
my
)
;
}
}
static
void
check_affine_filter
(
uint32_t
bitmapXY
[
]
int
count
unsigned
mx
unsigned
my
)
{
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
uint32_t
YY
=
*
bitmapXY
+
+
;
unsigned
y0
=
YY
>
>
18
;
unsigned
y1
=
YY
&
0x3FFF
;
SkASSERT
(
y0
<
my
)
;
SkASSERT
(
y1
<
my
)
;
uint32_t
XX
=
*
bitmapXY
+
+
;
unsigned
x0
=
XX
>
>
18
;
unsigned
x1
=
XX
&
0x3FFF
;
SkASSERT
(
x0
<
mx
)
;
SkASSERT
(
x1
<
mx
)
;
}
}
void
SkBitmapProcState
:
:
DebugMatrixProc
(
const
SkBitmapProcState
&
state
uint32_t
bitmapXY
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
bitmapXY
)
;
SkASSERT
(
count
>
0
)
;
state
.
fMatrixProc
(
state
bitmapXY
count
x
y
)
;
void
(
*
proc
)
(
uint32_t
bitmapXY
[
]
int
count
unsigned
mx
unsigned
my
)
;
if
(
state
.
fInvType
<
=
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
{
proc
=
state
.
fFilterLevel
!
=
kNone_SkFilterQuality
?
check_scale_filter
:
check_scale_nofilter
;
}
else
{
proc
=
state
.
fFilterLevel
!
=
kNone_SkFilterQuality
?
check_affine_filter
:
check_affine_nofilter
;
}
proc
(
bitmapXY
count
state
.
fPixmap
.
width
(
)
state
.
fPixmap
.
height
(
)
)
;
}
SkBitmapProcState
:
:
MatrixProc
SkBitmapProcState
:
:
getMatrixProc
(
)
const
{
return
DebugMatrixProc
;
}
#
endif
int
SkBitmapProcState
:
:
maxCountForBufferSize
(
size_t
bufferSize
)
const
{
int32_t
size
=
static_cast
<
int32_t
>
(
bufferSize
)
;
size
&
=
~
3
;
if
(
fInvType
<
=
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
{
size
-
=
4
;
if
(
size
<
0
)
{
size
=
0
;
}
size
>
>
=
1
;
}
else
{
size
>
>
=
2
;
}
if
(
fFilterLevel
!
=
kNone_SkFilterQuality
)
{
size
>
>
=
1
;
}
return
size
;
}
void
Clamp_S32_opaque_D32_nofilter_DX_shaderproc
(
const
void
*
sIn
int
x
int
y
SkPMColor
*
SK_RESTRICT
dst
int
count
)
{
const
SkBitmapProcState
&
s
=
*
static_cast
<
const
SkBitmapProcState
*
>
(
sIn
)
;
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
const
unsigned
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
SkFractionalInt
fx
;
int
dstY
;
{
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
const
unsigned
maxY
=
s
.
fPixmap
.
height
(
)
-
1
;
dstY
=
SkClampMax
(
SkFractionalIntToInt
(
mapper
.
y
(
)
)
maxY
)
;
fx
=
mapper
.
x
(
)
;
}
const
SkPMColor
*
SK_RESTRICT
src
=
s
.
fPixmap
.
addr32
(
0
dstY
)
;
const
SkFractionalInt
dx
=
s
.
fInvSxFractionalInt
;
if
(
(
uint64_t
)
SkFractionalIntToInt
(
fx
)
<
=
maxX
&
&
(
uint64_t
)
SkFractionalIntToInt
(
fx
+
dx
*
(
count
-
1
)
)
<
=
maxX
)
{
int
count4
=
count
>
>
2
;
for
(
int
i
=
0
;
i
<
count4
;
+
+
i
)
{
SkPMColor
src0
=
src
[
SkFractionalIntToInt
(
fx
)
]
;
fx
+
=
dx
;
SkPMColor
src1
=
src
[
SkFractionalIntToInt
(
fx
)
]
;
fx
+
=
dx
;
SkPMColor
src2
=
src
[
SkFractionalIntToInt
(
fx
)
]
;
fx
+
=
dx
;
SkPMColor
src3
=
src
[
SkFractionalIntToInt
(
fx
)
]
;
fx
+
=
dx
;
dst
[
0
]
=
src0
;
dst
[
1
]
=
src1
;
dst
[
2
]
=
src2
;
dst
[
3
]
=
src3
;
dst
+
=
4
;
}
for
(
int
i
=
(
count4
<
<
2
)
;
i
<
count
;
+
+
i
)
{
unsigned
index
=
SkFractionalIntToInt
(
fx
)
;
SkASSERT
(
index
<
=
maxX
)
;
*
dst
+
+
=
src
[
index
]
;
fx
+
=
dx
;
}
}
else
{
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
dst
[
i
]
=
src
[
SkClampMax
(
SkFractionalIntToInt
(
fx
)
maxX
)
]
;
fx
+
=
dx
;
}
}
}
