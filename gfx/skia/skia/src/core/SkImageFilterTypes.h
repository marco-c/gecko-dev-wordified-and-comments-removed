#
ifndef
SkImageFilterTypes_DEFINED
#
define
SkImageFilterTypes_DEFINED
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkSpecialSurface
.
h
"
class
GrRecordingContext
;
class
SkImageFilter
;
class
SkImageFilterCache
;
class
SkSpecialSurface
;
class
SkSurfaceProps
;
namespace
skif
{
struct
IVector
{
int32_t
fX
;
int32_t
fY
;
IVector
(
)
=
default
;
IVector
(
int32_t
x
int32_t
y
)
:
fX
(
x
)
fY
(
y
)
{
}
explicit
IVector
(
const
SkIVector
&
v
)
:
fX
(
v
.
fX
)
fY
(
v
.
fY
)
{
}
}
;
struct
Vector
{
SkScalar
fX
;
SkScalar
fY
;
Vector
(
)
=
default
;
Vector
(
SkScalar
x
SkScalar
y
)
:
fX
(
x
)
fY
(
y
)
{
}
explicit
Vector
(
const
SkVector
&
v
)
:
fX
(
v
.
fX
)
fY
(
v
.
fY
)
{
}
}
;
template
<
typename
T
>
class
ParameterSpace
{
public
:
explicit
ParameterSpace
(
const
T
&
data
)
:
fData
(
data
)
{
}
explicit
ParameterSpace
(
T
&
&
data
)
:
fData
(
std
:
:
move
(
data
)
)
{
}
explicit
operator
const
T
&
(
)
const
{
return
fData
;
}
private
:
T
fData
;
}
;
template
<
typename
T
>
class
DeviceSpace
{
public
:
explicit
DeviceSpace
(
const
T
&
data
)
:
fData
(
data
)
{
}
explicit
DeviceSpace
(
T
&
&
data
)
:
fData
(
std
:
:
move
(
data
)
)
{
}
explicit
operator
const
T
&
(
)
const
{
return
fData
;
}
private
:
T
fData
;
}
;
template
<
typename
T
>
class
LayerSpace
{
}
;
template
<
>
class
LayerSpace
<
IVector
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
IVector
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
IVector
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
IVector
&
(
)
const
{
return
fData
;
}
explicit
operator
SkIVector
(
)
const
{
return
SkIVector
:
:
Make
(
fData
.
fX
fData
.
fY
)
;
}
int32_t
x
(
)
const
{
return
fData
.
fX
;
}
int32_t
y
(
)
const
{
return
fData
.
fY
;
}
LayerSpace
<
IVector
>
operator
-
(
)
const
{
return
LayerSpace
<
IVector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
LayerSpace
<
IVector
>
operator
+
(
const
LayerSpace
<
IVector
>
&
v
)
const
{
LayerSpace
<
IVector
>
sum
=
*
this
;
sum
+
=
v
;
return
sum
;
}
LayerSpace
<
IVector
>
operator
-
(
const
LayerSpace
<
IVector
>
&
v
)
const
{
LayerSpace
<
IVector
>
diff
=
*
this
;
diff
-
=
v
;
return
diff
;
}
void
operator
+
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
fX
+
=
v
.
fData
.
fX
;
fData
.
fY
+
=
v
.
fData
.
fY
;
}
void
operator
-
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
fX
-
=
v
.
fData
.
fX
;
fData
.
fY
-
=
v
.
fData
.
fY
;
}
private
:
IVector
fData
;
}
;
template
<
>
class
LayerSpace
<
Vector
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
Vector
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
Vector
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
Vector
&
(
)
const
{
return
fData
;
}
explicit
operator
SkVector
(
)
const
{
return
SkVector
:
:
Make
(
fData
.
fX
fData
.
fY
)
;
}
SkScalar
x
(
)
const
{
return
fData
.
fX
;
}
SkScalar
y
(
)
const
{
return
fData
.
fY
;
}
SkScalar
length
(
)
const
{
return
SkVector
:
:
Length
(
fData
.
fX
fData
.
fY
)
;
}
LayerSpace
<
Vector
>
operator
-
(
)
const
{
return
LayerSpace
<
Vector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
LayerSpace
<
Vector
>
operator
*
(
SkScalar
s
)
const
{
LayerSpace
<
Vector
>
scaled
=
*
this
;
scaled
*
=
s
;
return
scaled
;
}
LayerSpace
<
Vector
>
operator
+
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
LayerSpace
<
Vector
>
sum
=
*
this
;
sum
+
=
v
;
return
sum
;
}
LayerSpace
<
Vector
>
operator
-
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
LayerSpace
<
Vector
>
diff
=
*
this
;
diff
-
=
v
;
return
diff
;
}
void
operator
*
=
(
SkScalar
s
)
{
fData
.
fX
*
=
s
;
fData
.
fY
*
=
s
;
}
void
operator
+
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
fX
+
=
v
.
fData
.
fX
;
fData
.
fY
+
=
v
.
fData
.
fY
;
}
void
operator
-
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
fX
-
=
v
.
fData
.
fX
;
fData
.
fY
-
=
v
.
fData
.
fY
;
}
friend
LayerSpace
<
Vector
>
operator
*
(
SkScalar
s
const
LayerSpace
<
Vector
>
&
b
)
{
return
b
*
s
;
}
private
:
Vector
fData
;
}
;
template
<
>
class
LayerSpace
<
SkIPoint
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkIPoint
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkIPoint
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkIPoint
&
(
)
const
{
return
fData
;
}
int32_t
x
(
)
const
{
return
fData
.
fX
;
}
int32_t
y
(
)
const
{
return
fData
.
fY
;
}
LayerSpace
<
SkIPoint
>
operator
+
(
const
LayerSpace
<
IVector
>
&
v
)
{
return
LayerSpace
<
SkIPoint
>
(
fData
+
SkIVector
(
v
)
)
;
}
LayerSpace
<
SkIPoint
>
operator
-
(
const
LayerSpace
<
IVector
>
&
v
)
{
return
LayerSpace
<
SkIPoint
>
(
fData
-
SkIVector
(
v
)
)
;
}
void
operator
+
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
+
=
SkIVector
(
v
)
;
}
void
operator
-
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
-
=
SkIVector
(
v
)
;
}
LayerSpace
<
IVector
>
operator
-
(
const
LayerSpace
<
SkIPoint
>
&
p
)
{
return
LayerSpace
<
IVector
>
(
IVector
(
fData
-
p
.
fData
)
)
;
}
private
:
SkIPoint
fData
;
}
;
template
<
>
class
LayerSpace
<
SkPoint
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkPoint
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkPoint
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkPoint
&
(
)
const
{
return
fData
;
}
SkScalar
x
(
)
const
{
return
fData
.
fX
;
}
SkScalar
y
(
)
const
{
return
fData
.
fY
;
}
SkScalar
distanceToOrigin
(
)
const
{
return
fData
.
distanceToOrigin
(
)
;
}
LayerSpace
<
SkPoint
>
operator
+
(
const
LayerSpace
<
Vector
>
&
v
)
{
return
LayerSpace
<
SkPoint
>
(
fData
+
SkVector
(
v
)
)
;
}
LayerSpace
<
SkPoint
>
operator
-
(
const
LayerSpace
<
Vector
>
&
v
)
{
return
LayerSpace
<
SkPoint
>
(
fData
-
SkVector
(
v
)
)
;
}
void
operator
+
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
+
=
SkVector
(
v
)
;
}
void
operator
-
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
-
=
SkVector
(
v
)
;
}
LayerSpace
<
Vector
>
operator
-
(
const
LayerSpace
<
SkPoint
>
&
p
)
{
return
LayerSpace
<
Vector
>
(
Vector
(
fData
-
p
.
fData
)
)
;
}
private
:
SkPoint
fData
;
}
;
template
<
>
class
LayerSpace
<
SkISize
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkISize
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkISize
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkISize
&
(
)
const
{
return
fData
;
}
int32_t
width
(
)
const
{
return
fData
.
width
(
)
;
}
int32_t
height
(
)
const
{
return
fData
.
height
(
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
private
:
SkISize
fData
;
}
;
template
<
>
class
LayerSpace
<
SkSize
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkSize
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkSize
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkSize
&
(
)
const
{
return
fData
;
}
SkScalar
width
(
)
const
{
return
fData
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fData
.
height
(
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
bool
isZero
(
)
const
{
return
fData
.
isZero
(
)
;
}
LayerSpace
<
SkISize
>
round
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toRound
(
)
)
;
}
LayerSpace
<
SkISize
>
ceil
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toCeil
(
)
)
;
}
LayerSpace
<
SkISize
>
floor
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toFloor
(
)
)
;
}
private
:
SkSize
fData
;
}
;
template
<
>
class
LayerSpace
<
SkIRect
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkIRect
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkIRect
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkIRect
&
(
)
const
{
return
fData
;
}
int32_t
left
(
)
const
{
return
fData
.
fLeft
;
}
int32_t
top
(
)
const
{
return
fData
.
fTop
;
}
int32_t
right
(
)
const
{
return
fData
.
fRight
;
}
int32_t
bottom
(
)
const
{
return
fData
.
fBottom
;
}
int32_t
width
(
)
const
{
return
fData
.
width
(
)
;
}
int32_t
height
(
)
const
{
return
fData
.
height
(
)
;
}
LayerSpace
<
SkIPoint
>
topLeft
(
)
const
{
return
LayerSpace
<
SkIPoint
>
(
fData
.
topLeft
(
)
)
;
}
LayerSpace
<
SkISize
>
size
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
size
(
)
)
;
}
bool
intersect
(
const
LayerSpace
<
SkIRect
>
&
r
)
{
return
fData
.
intersect
(
r
.
fData
)
;
}
void
join
(
const
LayerSpace
<
SkIRect
>
&
r
)
{
fData
.
join
(
r
.
fData
)
;
}
void
offset
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
offset
(
SkIVector
(
v
)
)
;
}
void
outset
(
const
LayerSpace
<
SkISize
>
&
delta
)
{
fData
.
outset
(
delta
.
width
(
)
delta
.
height
(
)
)
;
}
private
:
SkIRect
fData
;
}
;
template
<
>
class
LayerSpace
<
SkRect
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkRect
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkRect
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkRect
&
(
)
const
{
return
fData
;
}
SkScalar
left
(
)
const
{
return
fData
.
fLeft
;
}
SkScalar
top
(
)
const
{
return
fData
.
fTop
;
}
SkScalar
right
(
)
const
{
return
fData
.
fRight
;
}
SkScalar
bottom
(
)
const
{
return
fData
.
fBottom
;
}
SkScalar
width
(
)
const
{
return
fData
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fData
.
height
(
)
;
}
LayerSpace
<
SkPoint
>
topLeft
(
)
const
{
return
LayerSpace
<
SkPoint
>
(
SkPoint
:
:
Make
(
fData
.
fLeft
fData
.
fTop
)
)
;
}
LayerSpace
<
SkSize
>
size
(
)
const
{
return
LayerSpace
<
SkSize
>
(
SkSize
:
:
Make
(
fData
.
width
(
)
fData
.
height
(
)
)
)
;
}
LayerSpace
<
SkIRect
>
roundOut
(
)
const
{
return
LayerSpace
<
SkIRect
>
(
fData
.
roundOut
(
)
)
;
}
bool
intersect
(
const
LayerSpace
<
SkRect
>
&
r
)
{
return
fData
.
intersect
(
r
.
fData
)
;
}
void
join
(
const
LayerSpace
<
SkRect
>
&
r
)
{
fData
.
join
(
r
.
fData
)
;
}
void
offset
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
offset
(
SkVector
(
v
)
)
;
}
void
outset
(
const
LayerSpace
<
SkSize
>
&
delta
)
{
fData
.
outset
(
delta
.
width
(
)
delta
.
height
(
)
)
;
}
private
:
SkRect
fData
;
}
;
class
Mapping
{
public
:
Mapping
(
const
SkMatrix
&
layerToDev
const
SkMatrix
&
paramToLayer
)
:
fLayerToDevMatrix
(
layerToDev
)
fParamToLayerMatrix
(
paramToLayer
)
{
}
static
Mapping
Make
(
const
SkMatrix
&
ctm
const
SkImageFilter
*
filter
)
;
Mapping
concatLocal
(
const
SkMatrix
&
local
)
const
{
return
Mapping
(
fLayerToDevMatrix
SkMatrix
:
:
Concat
(
fParamToLayerMatrix
local
)
)
;
}
const
SkMatrix
&
deviceMatrix
(
)
const
{
return
fLayerToDevMatrix
;
}
const
SkMatrix
&
layerMatrix
(
)
const
{
return
fParamToLayerMatrix
;
}
SkMatrix
totalMatrix
(
)
const
{
return
SkMatrix
:
:
Concat
(
fLayerToDevMatrix
fParamToLayerMatrix
)
;
}
template
<
typename
T
>
LayerSpace
<
T
>
paramToLayer
(
const
ParameterSpace
<
T
>
&
paramGeometry
)
const
{
return
LayerSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
paramGeometry
)
fParamToLayerMatrix
)
)
;
}
template
<
typename
T
>
LayerSpace
<
T
>
deviceToLayer
(
const
DeviceSpace
<
T
>
&
devGeometry
)
const
{
SkMatrix
devToLayerMatrix
;
if
(
!
fLayerToDevMatrix
.
invert
(
&
devToLayerMatrix
)
)
{
return
LayerSpace
<
T
>
(
static_cast
<
const
T
&
>
(
devGeometry
)
)
;
}
else
{
return
LayerSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
devGeometry
)
devToLayerMatrix
)
)
;
}
}
template
<
typename
T
>
DeviceSpace
<
T
>
layerToDevice
(
const
LayerSpace
<
T
>
&
layerGeometry
)
const
{
return
DeviceSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
layerGeometry
)
fLayerToDevMatrix
)
)
;
}
private
:
SkMatrix
fLayerToDevMatrix
;
SkMatrix
fParamToLayerMatrix
;
template
<
typename
T
>
static
T
map
(
const
T
&
geom
const
SkMatrix
&
matrix
)
;
}
;
enum
class
Usage
{
kInput
kInput0
kInput1
kOutput
}
;
#
define
SK_USE_FLUENT_IMAGE_FILTER_TYPES
\
using
For
=
skif
:
:
Usage
;
#
define
SK_USE_FLUENT_IMAGE_FILTER_TYPES_IN_CLASS
\
protected
:
SK_USE_FLUENT_IMAGE_FILTER_TYPES
public
:
template
<
Usage
kU
>
class
FilterResult
{
public
:
FilterResult
(
)
:
fImage
(
nullptr
)
fOrigin
(
SkIPoint
:
:
Make
(
0
0
)
)
{
}
FilterResult
(
sk_sp
<
SkSpecialImage
>
image
const
LayerSpace
<
SkIPoint
>
&
origin
)
:
fImage
(
std
:
:
move
(
image
)
)
fOrigin
(
origin
)
{
}
template
<
Usage
kI
>
explicit
FilterResult
(
FilterResult
<
kI
>
&
&
image
)
:
fImage
(
std
:
:
move
(
image
.
fImage
)
)
fOrigin
(
image
.
fOrigin
)
{
static_assert
(
(
kU
!
=
Usage
:
:
kInput
)
|
|
(
kI
!
=
Usage
:
:
kInput0
&
&
kI
!
=
Usage
:
:
kInput1
)
"
kInput0
and
kInput1
cannot
be
moved
to
more
generic
kInput
usage
.
"
)
;
static_assert
(
(
kU
!
=
Usage
:
:
kInput0
&
&
kU
!
=
Usage
:
:
kInput1
)
|
|
(
kI
=
=
kU
|
|
kI
=
=
Usage
:
:
kInput
|
|
kI
=
=
Usage
:
:
kOutput
)
"
Can
only
move
to
specific
input
from
the
generic
kInput
or
kOutput
usage
.
"
)
;
}
template
<
Usage
kI
>
explicit
FilterResult
(
const
FilterResult
<
kI
>
&
image
)
:
fImage
(
image
.
fImage
)
fOrigin
(
image
.
fOrigin
)
{
static_assert
(
(
kU
!
=
Usage
:
:
kInput
)
|
|
(
kI
!
=
Usage
:
:
kInput0
&
&
kI
!
=
Usage
:
:
kInput1
)
"
kInput0
and
kInput1
cannot
be
copied
to
more
generic
kInput
usage
.
"
)
;
static_assert
(
(
kU
!
=
Usage
:
:
kInput0
&
&
kU
!
=
Usage
:
:
kInput1
)
|
|
(
kI
=
=
kU
|
|
kI
=
=
Usage
:
:
kInput
|
|
kI
=
=
Usage
:
:
kOutput
)
"
Can
only
copy
to
specific
input
from
the
generic
kInput
usage
.
"
)
;
}
const
SkSpecialImage
*
image
(
)
const
{
return
fImage
.
get
(
)
;
}
sk_sp
<
SkSpecialImage
>
refImage
(
)
const
{
return
fImage
;
}
LayerSpace
<
SkIRect
>
layerBounds
(
)
const
{
return
LayerSpace
<
SkIRect
>
(
SkIRect
:
:
MakeXYWH
(
fOrigin
.
x
(
)
fOrigin
.
y
(
)
fImage
-
>
width
(
)
fImage
-
>
height
(
)
)
)
;
}
const
LayerSpace
<
SkIPoint
>
&
layerOrigin
(
)
const
{
return
fOrigin
;
}
sk_sp
<
SkSpecialImage
>
imageAndOffset
(
SkIPoint
*
offset
)
const
{
if
(
fImage
)
{
*
offset
=
SkIPoint
(
fOrigin
)
;
return
fImage
;
}
else
{
*
offset
=
{
0
0
}
;
return
nullptr
;
}
}
private
:
template
<
Usage
kO
>
friend
class
FilterResult
;
sk_sp
<
SkSpecialImage
>
fImage
;
LayerSpace
<
SkIPoint
>
fOrigin
;
}
;
class
Context
{
public
:
SK_USE_FLUENT_IMAGE_FILTER_TYPES_IN_CLASS
Context
(
const
SkMatrix
&
layerMatrix
const
SkIRect
&
clipBounds
SkImageFilterCache
*
cache
SkColorType
colorType
SkColorSpace
*
colorSpace
const
SkSpecialImage
*
source
)
:
fMapping
(
SkMatrix
:
:
I
(
)
layerMatrix
)
fDesiredOutput
(
clipBounds
)
fCache
(
cache
)
fColorType
(
colorType
)
fColorSpace
(
colorSpace
)
fSource
(
sk_ref_sp
(
source
)
LayerSpace
<
SkIPoint
>
(
{
0
0
}
)
)
{
}
Context
(
const
Mapping
&
mapping
const
LayerSpace
<
SkIRect
>
&
desiredOutput
SkImageFilterCache
*
cache
SkColorType
colorType
SkColorSpace
*
colorSpace
const
FilterResult
<
For
:
:
kInput
>
&
source
)
:
fMapping
(
mapping
)
fDesiredOutput
(
desiredOutput
)
fCache
(
cache
)
fColorType
(
colorType
)
fColorSpace
(
colorSpace
)
fSource
(
source
)
{
}
const
Mapping
&
mapping
(
)
const
{
return
fMapping
;
}
const
SkMatrix
&
ctm
(
)
const
{
return
fMapping
.
layerMatrix
(
)
;
}
const
LayerSpace
<
SkIRect
>
&
desiredOutput
(
)
const
{
return
fDesiredOutput
;
}
const
SkIRect
&
clipBounds
(
)
const
{
return
static_cast
<
const
SkIRect
&
>
(
fDesiredOutput
)
;
}
SkImageFilterCache
*
cache
(
)
const
{
return
fCache
;
}
SkColorType
colorType
(
)
const
{
return
fColorType
;
}
#
if
SK_SUPPORT_GPU
GrColorType
grColorType
(
)
const
{
return
SkColorTypeToGrColorType
(
fColorType
)
;
}
#
endif
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorSpace
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
sk_ref_sp
(
fColorSpace
)
;
}
const
SkSurfaceProps
*
surfaceProps
(
)
const
{
return
&
fSource
.
image
(
)
-
>
props
(
)
;
}
const
FilterResult
<
For
:
:
kInput
>
&
source
(
)
const
{
return
fSource
;
}
const
SkSpecialImage
*
sourceImage
(
)
const
{
return
fSource
.
image
(
)
;
}
bool
gpuBacked
(
)
const
{
return
fSource
.
image
(
)
-
>
isTextureBacked
(
)
;
}
GrRecordingContext
*
getContext
(
)
const
{
return
fSource
.
image
(
)
-
>
getContext
(
)
;
}
bool
isValid
(
)
const
{
return
fSource
.
image
(
)
!
=
nullptr
&
&
fMapping
.
layerMatrix
(
)
.
isFinite
(
)
;
}
sk_sp
<
SkSpecialSurface
>
makeSurface
(
const
SkISize
&
size
const
SkSurfaceProps
*
props
=
nullptr
)
const
{
return
fSource
.
image
(
)
-
>
makeSurface
(
fColorType
fColorSpace
size
kPremul_SkAlphaType
props
)
;
}
Context
withNewMapping
(
const
Mapping
&
mapping
)
const
{
return
Context
(
mapping
fDesiredOutput
fCache
fColorType
fColorSpace
fSource
)
;
}
Context
withNewDesiredOutput
(
const
LayerSpace
<
SkIRect
>
&
desiredOutput
)
const
{
return
Context
(
fMapping
desiredOutput
fCache
fColorType
fColorSpace
fSource
)
;
}
private
:
Mapping
fMapping
;
LayerSpace
<
SkIRect
>
fDesiredOutput
;
SkImageFilterCache
*
fCache
;
SkColorType
fColorType
;
SkColorSpace
*
fColorSpace
;
FilterResult
<
For
:
:
kInput
>
fSource
;
}
;
}
#
endif
