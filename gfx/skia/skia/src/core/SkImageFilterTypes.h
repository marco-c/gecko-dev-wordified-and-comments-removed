#
ifndef
SkImageFilterTypes_DEFINED
#
define
SkImageFilterTypes_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkSpecialSurface
.
h
"
class
GrRecordingContext
;
class
SkImageFilter
;
class
SkImageFilterCache
;
class
SkSpecialSurface
;
class
SkSurfaceProps
;
namespace
skif
{
SkIRect
RoundOut
(
SkRect
)
;
SkIRect
RoundIn
(
SkRect
)
;
struct
IVector
{
int32_t
fX
;
int32_t
fY
;
IVector
(
)
=
default
;
IVector
(
int32_t
x
int32_t
y
)
:
fX
(
x
)
fY
(
y
)
{
}
explicit
IVector
(
const
SkIVector
&
v
)
:
fX
(
v
.
fX
)
fY
(
v
.
fY
)
{
}
}
;
struct
Vector
{
SkScalar
fX
;
SkScalar
fY
;
Vector
(
)
=
default
;
Vector
(
SkScalar
x
SkScalar
y
)
:
fX
(
x
)
fY
(
y
)
{
}
explicit
Vector
(
const
SkVector
&
v
)
:
fX
(
v
.
fX
)
fY
(
v
.
fY
)
{
}
}
;
template
<
typename
T
>
class
ParameterSpace
{
public
:
ParameterSpace
(
)
=
default
;
explicit
ParameterSpace
(
const
T
&
data
)
:
fData
(
data
)
{
}
explicit
ParameterSpace
(
T
&
&
data
)
:
fData
(
std
:
:
move
(
data
)
)
{
}
explicit
operator
const
T
&
(
)
const
{
return
fData
;
}
static
const
ParameterSpace
<
T
>
*
Optional
(
const
T
*
ptr
)
{
return
static_cast
<
const
ParameterSpace
<
T
>
*
>
(
reinterpret_cast
<
const
void
*
>
(
ptr
)
)
;
}
private
:
T
fData
;
}
;
template
<
typename
T
>
class
DeviceSpace
{
public
:
DeviceSpace
(
)
=
default
;
explicit
DeviceSpace
(
const
T
&
data
)
:
fData
(
data
)
{
}
explicit
DeviceSpace
(
T
&
&
data
)
:
fData
(
std
:
:
move
(
data
)
)
{
}
explicit
operator
const
T
&
(
)
const
{
return
fData
;
}
private
:
T
fData
;
}
;
template
<
typename
T
>
class
LayerSpace
{
}
;
template
<
>
class
LayerSpace
<
IVector
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
IVector
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
IVector
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
IVector
&
(
)
const
{
return
fData
;
}
explicit
operator
SkIVector
(
)
const
{
return
SkIVector
:
:
Make
(
fData
.
fX
fData
.
fY
)
;
}
int32_t
x
(
)
const
{
return
fData
.
fX
;
}
int32_t
y
(
)
const
{
return
fData
.
fY
;
}
LayerSpace
<
IVector
>
operator
-
(
)
const
{
return
LayerSpace
<
IVector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
LayerSpace
<
IVector
>
operator
+
(
const
LayerSpace
<
IVector
>
&
v
)
const
{
LayerSpace
<
IVector
>
sum
=
*
this
;
sum
+
=
v
;
return
sum
;
}
LayerSpace
<
IVector
>
operator
-
(
const
LayerSpace
<
IVector
>
&
v
)
const
{
LayerSpace
<
IVector
>
diff
=
*
this
;
diff
-
=
v
;
return
diff
;
}
void
operator
+
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
fX
+
=
v
.
fData
.
fX
;
fData
.
fY
+
=
v
.
fData
.
fY
;
}
void
operator
-
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
fX
-
=
v
.
fData
.
fX
;
fData
.
fY
-
=
v
.
fData
.
fY
;
}
private
:
IVector
fData
;
}
;
template
<
>
class
LayerSpace
<
Vector
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
Vector
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
Vector
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
Vector
&
(
)
const
{
return
fData
;
}
explicit
operator
SkVector
(
)
const
{
return
SkVector
:
:
Make
(
fData
.
fX
fData
.
fY
)
;
}
SkScalar
x
(
)
const
{
return
fData
.
fX
;
}
SkScalar
y
(
)
const
{
return
fData
.
fY
;
}
SkScalar
length
(
)
const
{
return
SkVector
:
:
Length
(
fData
.
fX
fData
.
fY
)
;
}
LayerSpace
<
Vector
>
operator
-
(
)
const
{
return
LayerSpace
<
Vector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
LayerSpace
<
Vector
>
operator
*
(
SkScalar
s
)
const
{
LayerSpace
<
Vector
>
scaled
=
*
this
;
scaled
*
=
s
;
return
scaled
;
}
LayerSpace
<
Vector
>
operator
+
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
LayerSpace
<
Vector
>
sum
=
*
this
;
sum
+
=
v
;
return
sum
;
}
LayerSpace
<
Vector
>
operator
-
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
LayerSpace
<
Vector
>
diff
=
*
this
;
diff
-
=
v
;
return
diff
;
}
void
operator
*
=
(
SkScalar
s
)
{
fData
.
fX
*
=
s
;
fData
.
fY
*
=
s
;
}
void
operator
+
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
fX
+
=
v
.
fData
.
fX
;
fData
.
fY
+
=
v
.
fData
.
fY
;
}
void
operator
-
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
fX
-
=
v
.
fData
.
fX
;
fData
.
fY
-
=
v
.
fData
.
fY
;
}
friend
LayerSpace
<
Vector
>
operator
*
(
SkScalar
s
const
LayerSpace
<
Vector
>
&
b
)
{
return
b
*
s
;
}
private
:
Vector
fData
;
}
;
template
<
>
class
LayerSpace
<
SkIPoint
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkIPoint
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkIPoint
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkIPoint
&
(
)
const
{
return
fData
;
}
int32_t
x
(
)
const
{
return
fData
.
fX
;
}
int32_t
y
(
)
const
{
return
fData
.
fY
;
}
LayerSpace
<
SkIPoint
>
operator
+
(
const
LayerSpace
<
IVector
>
&
v
)
{
return
LayerSpace
<
SkIPoint
>
(
fData
+
SkIVector
(
v
)
)
;
}
LayerSpace
<
SkIPoint
>
operator
-
(
const
LayerSpace
<
IVector
>
&
v
)
{
return
LayerSpace
<
SkIPoint
>
(
fData
-
SkIVector
(
v
)
)
;
}
void
operator
+
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
+
=
SkIVector
(
v
)
;
}
void
operator
-
=
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
-
=
SkIVector
(
v
)
;
}
LayerSpace
<
IVector
>
operator
-
(
const
LayerSpace
<
SkIPoint
>
&
p
)
{
return
LayerSpace
<
IVector
>
(
IVector
(
fData
-
p
.
fData
)
)
;
}
LayerSpace
<
IVector
>
operator
-
(
)
const
{
return
LayerSpace
<
IVector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
private
:
SkIPoint
fData
;
}
;
template
<
>
class
LayerSpace
<
SkPoint
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkPoint
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkPoint
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkPoint
&
(
)
const
{
return
fData
;
}
SkScalar
x
(
)
const
{
return
fData
.
fX
;
}
SkScalar
y
(
)
const
{
return
fData
.
fY
;
}
SkScalar
distanceToOrigin
(
)
const
{
return
fData
.
distanceToOrigin
(
)
;
}
LayerSpace
<
SkPoint
>
operator
+
(
const
LayerSpace
<
Vector
>
&
v
)
{
return
LayerSpace
<
SkPoint
>
(
fData
+
SkVector
(
v
)
)
;
}
LayerSpace
<
SkPoint
>
operator
-
(
const
LayerSpace
<
Vector
>
&
v
)
{
return
LayerSpace
<
SkPoint
>
(
fData
-
SkVector
(
v
)
)
;
}
void
operator
+
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
+
=
SkVector
(
v
)
;
}
void
operator
-
=
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
-
=
SkVector
(
v
)
;
}
LayerSpace
<
Vector
>
operator
-
(
const
LayerSpace
<
SkPoint
>
&
p
)
{
return
LayerSpace
<
Vector
>
(
Vector
(
fData
-
p
.
fData
)
)
;
}
LayerSpace
<
Vector
>
operator
-
(
)
const
{
return
LayerSpace
<
Vector
>
(
{
-
fData
.
fX
-
fData
.
fY
}
)
;
}
private
:
SkPoint
fData
;
}
;
template
<
>
class
LayerSpace
<
SkISize
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkISize
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkISize
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkISize
&
(
)
const
{
return
fData
;
}
int32_t
width
(
)
const
{
return
fData
.
width
(
)
;
}
int32_t
height
(
)
const
{
return
fData
.
height
(
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
private
:
SkISize
fData
;
}
;
template
<
>
class
LayerSpace
<
SkSize
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkSize
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkSize
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
operator
const
SkSize
&
(
)
const
{
return
fData
;
}
SkScalar
width
(
)
const
{
return
fData
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fData
.
height
(
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
bool
isZero
(
)
const
{
return
fData
.
isZero
(
)
;
}
LayerSpace
<
SkISize
>
round
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toRound
(
)
)
;
}
LayerSpace
<
SkISize
>
ceil
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toCeil
(
)
)
;
}
LayerSpace
<
SkISize
>
floor
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toFloor
(
)
)
;
}
private
:
SkSize
fData
;
}
;
template
<
>
class
LayerSpace
<
SkIRect
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkIRect
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkIRect
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
LayerSpace
(
const
SkISize
&
size
)
:
fData
(
SkIRect
:
:
MakeSize
(
size
)
)
{
}
explicit
operator
const
SkIRect
&
(
)
const
{
return
fData
;
}
static
LayerSpace
<
SkIRect
>
Empty
(
)
{
return
LayerSpace
<
SkIRect
>
(
SkIRect
:
:
MakeEmpty
(
)
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
bool
contains
(
const
LayerSpace
<
SkIRect
>
&
r
)
const
{
return
fData
.
contains
(
r
.
fData
)
;
}
int32_t
left
(
)
const
{
return
fData
.
fLeft
;
}
int32_t
top
(
)
const
{
return
fData
.
fTop
;
}
int32_t
right
(
)
const
{
return
fData
.
fRight
;
}
int32_t
bottom
(
)
const
{
return
fData
.
fBottom
;
}
int32_t
width
(
)
const
{
return
fData
.
width
(
)
;
}
int32_t
height
(
)
const
{
return
fData
.
height
(
)
;
}
LayerSpace
<
SkIPoint
>
topLeft
(
)
const
{
return
LayerSpace
<
SkIPoint
>
(
fData
.
topLeft
(
)
)
;
}
LayerSpace
<
SkISize
>
size
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
size
(
)
)
;
}
bool
intersect
(
const
LayerSpace
<
SkIRect
>
&
r
)
{
return
fData
.
intersect
(
r
.
fData
)
;
}
void
join
(
const
LayerSpace
<
SkIRect
>
&
r
)
{
fData
.
join
(
r
.
fData
)
;
}
void
offset
(
const
LayerSpace
<
IVector
>
&
v
)
{
fData
.
offset
(
SkIVector
(
v
)
)
;
}
void
outset
(
const
LayerSpace
<
SkISize
>
&
delta
)
{
fData
.
outset
(
delta
.
width
(
)
delta
.
height
(
)
)
;
}
private
:
SkIRect
fData
;
}
;
template
<
>
class
LayerSpace
<
SkRect
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkRect
&
geometry
)
:
fData
(
geometry
)
{
}
explicit
LayerSpace
(
SkRect
&
&
geometry
)
:
fData
(
std
:
:
move
(
geometry
)
)
{
}
explicit
LayerSpace
(
const
LayerSpace
<
SkIRect
>
&
rect
)
:
fData
(
SkRect
:
:
Make
(
SkIRect
(
rect
)
)
)
{
}
explicit
operator
const
SkRect
&
(
)
const
{
return
fData
;
}
static
LayerSpace
<
SkRect
>
Empty
(
)
{
return
LayerSpace
<
SkRect
>
(
SkRect
:
:
MakeEmpty
(
)
)
;
}
bool
isEmpty
(
)
const
{
return
fData
.
isEmpty
(
)
;
}
bool
contains
(
const
LayerSpace
<
SkRect
>
&
r
)
const
{
return
fData
.
contains
(
r
.
fData
)
;
}
SkScalar
left
(
)
const
{
return
fData
.
fLeft
;
}
SkScalar
top
(
)
const
{
return
fData
.
fTop
;
}
SkScalar
right
(
)
const
{
return
fData
.
fRight
;
}
SkScalar
bottom
(
)
const
{
return
fData
.
fBottom
;
}
SkScalar
width
(
)
const
{
return
fData
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fData
.
height
(
)
;
}
LayerSpace
<
SkPoint
>
topLeft
(
)
const
{
return
LayerSpace
<
SkPoint
>
(
SkPoint
:
:
Make
(
fData
.
fLeft
fData
.
fTop
)
)
;
}
LayerSpace
<
SkSize
>
size
(
)
const
{
return
LayerSpace
<
SkSize
>
(
SkSize
:
:
Make
(
fData
.
width
(
)
fData
.
height
(
)
)
)
;
}
LayerSpace
<
SkIRect
>
round
(
)
const
{
return
LayerSpace
<
SkIRect
>
(
fData
.
round
(
)
)
;
}
LayerSpace
<
SkIRect
>
roundIn
(
)
const
{
return
LayerSpace
<
SkIRect
>
(
RoundIn
(
fData
)
)
;
}
LayerSpace
<
SkIRect
>
roundOut
(
)
const
{
return
LayerSpace
<
SkIRect
>
(
RoundOut
(
fData
)
)
;
}
bool
intersect
(
const
LayerSpace
<
SkRect
>
&
r
)
{
return
fData
.
intersect
(
r
.
fData
)
;
}
void
join
(
const
LayerSpace
<
SkRect
>
&
r
)
{
fData
.
join
(
r
.
fData
)
;
}
void
offset
(
const
LayerSpace
<
Vector
>
&
v
)
{
fData
.
offset
(
SkVector
(
v
)
)
;
}
void
outset
(
const
LayerSpace
<
SkSize
>
&
delta
)
{
fData
.
outset
(
delta
.
width
(
)
delta
.
height
(
)
)
;
}
private
:
SkRect
fData
;
}
;
template
<
>
class
LayerSpace
<
SkMatrix
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
const
SkMatrix
&
m
)
:
fData
(
m
)
{
}
explicit
LayerSpace
(
SkMatrix
&
&
m
)
:
fData
(
std
:
:
move
(
m
)
)
{
}
explicit
operator
const
SkMatrix
&
(
)
const
{
return
fData
;
}
LayerSpace
<
SkRect
>
mapRect
(
const
LayerSpace
<
SkRect
>
&
r
)
const
;
LayerSpace
<
SkIRect
>
mapRect
(
const
LayerSpace
<
SkIRect
>
&
r
)
const
;
LayerSpace
<
SkPoint
>
mapPoint
(
const
LayerSpace
<
SkPoint
>
&
p
)
const
{
return
LayerSpace
<
SkPoint
>
(
fData
.
mapPoint
(
SkPoint
(
p
)
)
)
;
}
LayerSpace
<
Vector
>
mapVector
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
return
LayerSpace
<
Vector
>
(
Vector
(
fData
.
mapVector
(
v
.
x
(
)
v
.
y
(
)
)
)
)
;
}
LayerSpace
<
SkMatrix
>
&
preConcat
(
const
LayerSpace
<
SkMatrix
>
&
m
)
{
fData
=
SkMatrix
:
:
Concat
(
fData
m
.
fData
)
;
return
*
this
;
}
LayerSpace
<
SkMatrix
>
&
postConcat
(
const
LayerSpace
<
SkMatrix
>
&
m
)
{
fData
=
SkMatrix
:
:
Concat
(
m
.
fData
fData
)
;
return
*
this
;
}
bool
invert
(
LayerSpace
<
SkMatrix
>
*
inverse
)
const
{
return
fData
.
invert
(
&
inverse
-
>
fData
)
;
}
float
rc
(
int
row
int
col
)
const
{
return
fData
.
rc
(
row
col
)
;
}
float
get
(
int
i
)
const
{
return
fData
.
get
(
i
)
;
}
private
:
SkMatrix
fData
;
}
;
class
Mapping
{
public
:
Mapping
(
)
=
default
;
explicit
Mapping
(
const
SkMatrix
&
paramToLayer
)
:
fLayerToDevMatrix
(
SkMatrix
:
:
I
(
)
)
fParamToLayerMatrix
(
paramToLayer
)
fDevToLayerMatrix
(
SkMatrix
:
:
I
(
)
)
{
}
Mapping
(
const
SkMatrix
&
layerToDev
const
SkMatrix
&
devToLayer
const
SkMatrix
&
paramToLayer
)
:
fLayerToDevMatrix
(
layerToDev
)
fParamToLayerMatrix
(
paramToLayer
)
fDevToLayerMatrix
(
devToLayer
)
{
}
bool
SK_WARN_UNUSED_RESULT
decomposeCTM
(
const
SkMatrix
&
ctm
const
SkImageFilter
*
filter
const
skif
:
:
ParameterSpace
<
SkPoint
>
&
representativePt
)
;
void
concatLocal
(
const
SkMatrix
&
local
)
{
fParamToLayerMatrix
.
preConcat
(
local
)
;
}
bool
adjustLayerSpace
(
const
SkMatrix
&
layer
)
;
void
applyOrigin
(
const
LayerSpace
<
SkIPoint
>
&
origin
)
{
SkAssertResult
(
this
-
>
adjustLayerSpace
(
SkMatrix
:
:
Translate
(
-
origin
.
x
(
)
-
origin
.
y
(
)
)
)
)
;
}
const
SkMatrix
&
layerToDevice
(
)
const
{
return
fLayerToDevMatrix
;
}
const
SkMatrix
&
deviceToLayer
(
)
const
{
return
fDevToLayerMatrix
;
}
const
SkMatrix
&
layerMatrix
(
)
const
{
return
fParamToLayerMatrix
;
}
SkMatrix
totalMatrix
(
)
const
{
return
SkMatrix
:
:
Concat
(
fLayerToDevMatrix
fParamToLayerMatrix
)
;
}
template
<
typename
T
>
LayerSpace
<
T
>
paramToLayer
(
const
ParameterSpace
<
T
>
&
paramGeometry
)
const
{
return
LayerSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
paramGeometry
)
fParamToLayerMatrix
)
)
;
}
template
<
typename
T
>
LayerSpace
<
T
>
deviceToLayer
(
const
DeviceSpace
<
T
>
&
devGeometry
)
const
{
return
LayerSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
devGeometry
)
fDevToLayerMatrix
)
)
;
}
template
<
typename
T
>
DeviceSpace
<
T
>
layerToDevice
(
const
LayerSpace
<
T
>
&
layerGeometry
)
const
{
return
DeviceSpace
<
T
>
(
map
(
static_cast
<
const
T
&
>
(
layerGeometry
)
fLayerToDevMatrix
)
)
;
}
private
:
SkMatrix
fLayerToDevMatrix
;
SkMatrix
fParamToLayerMatrix
;
SkMatrix
fDevToLayerMatrix
;
template
<
typename
T
>
static
T
map
(
const
T
&
geom
const
SkMatrix
&
matrix
)
;
}
;
class
Context
;
class
FilterResult
{
static
constexpr
SkSamplingOptions
kDefaultSampling
{
SkFilterMode
:
:
kLinear
}
;
public
:
FilterResult
(
)
:
FilterResult
(
nullptr
)
{
}
explicit
FilterResult
(
sk_sp
<
SkSpecialImage
>
image
)
:
FilterResult
(
std
:
:
move
(
image
)
LayerSpace
<
SkIPoint
>
(
{
0
0
}
)
)
{
}
FilterResult
(
std
:
:
pair
<
sk_sp
<
SkSpecialImage
>
LayerSpace
<
SkIPoint
>
>
imageAndOrigin
)
:
FilterResult
(
std
:
:
move
(
std
:
:
get
<
0
>
(
imageAndOrigin
)
)
std
:
:
get
<
1
>
(
imageAndOrigin
)
)
{
}
FilterResult
(
sk_sp
<
SkSpecialImage
>
image
const
LayerSpace
<
SkIPoint
>
&
origin
)
:
fImage
(
std
:
:
move
(
image
)
)
fSamplingOptions
(
kDefaultSampling
)
fTransform
(
SkMatrix
:
:
Translate
(
origin
.
x
(
)
origin
.
y
(
)
)
)
fLayerBounds
(
fTransform
.
mapRect
(
LayerSpace
<
SkIRect
>
(
fImage
?
fImage
-
>
dimensions
(
)
:
SkISize
{
0
0
}
)
)
)
{
}
explicit
operator
bool
(
)
const
{
return
SkToBool
(
fImage
)
;
}
const
SkSpecialImage
*
image
(
)
const
{
return
fImage
.
get
(
)
;
}
sk_sp
<
SkSpecialImage
>
refImage
(
)
const
{
return
fImage
;
}
LayerSpace
<
SkIRect
>
layerBounds
(
)
const
{
return
fLayerBounds
;
}
FilterResult
applyCrop
(
const
Context
&
ctx
const
LayerSpace
<
SkIRect
>
&
crop
)
const
;
FilterResult
applyTransform
(
const
Context
&
ctx
const
LayerSpace
<
SkMatrix
>
&
transform
const
SkSamplingOptions
&
sampling
)
const
;
sk_sp
<
SkSpecialImage
>
imageAndOffset
(
SkIPoint
*
offset
)
const
;
private
:
std
:
:
pair
<
sk_sp
<
SkSpecialImage
>
LayerSpace
<
SkIPoint
>
>
resolve
(
LayerSpace
<
SkIRect
>
dstBounds
)
const
;
void
concatTransform
(
const
LayerSpace
<
SkMatrix
>
&
transform
const
SkSamplingOptions
&
newSampling
const
LayerSpace
<
SkIRect
>
&
outputBounds
)
;
sk_sp
<
SkSpecialImage
>
fImage
;
SkSamplingOptions
fSamplingOptions
;
LayerSpace
<
SkMatrix
>
fTransform
;
LayerSpace
<
SkIRect
>
fLayerBounds
;
}
;
class
Context
{
public
:
Context
(
const
SkMatrix
&
layerMatrix
const
SkIRect
&
clipBounds
SkImageFilterCache
*
cache
SkColorType
colorType
SkColorSpace
*
colorSpace
const
SkSpecialImage
*
source
)
:
fMapping
(
layerMatrix
)
fDesiredOutput
(
clipBounds
)
fCache
(
cache
)
fColorType
(
colorType
)
fColorSpace
(
colorSpace
)
fSource
(
sk_ref_sp
(
source
)
LayerSpace
<
SkIPoint
>
(
{
0
0
}
)
)
{
}
Context
(
const
Mapping
&
mapping
const
LayerSpace
<
SkIRect
>
&
desiredOutput
SkImageFilterCache
*
cache
SkColorType
colorType
SkColorSpace
*
colorSpace
const
FilterResult
&
source
)
:
fMapping
(
mapping
)
fDesiredOutput
(
desiredOutput
)
fCache
(
cache
)
fColorType
(
colorType
)
fColorSpace
(
colorSpace
)
fSource
(
source
)
{
}
const
Mapping
&
mapping
(
)
const
{
return
fMapping
;
}
const
SkMatrix
&
ctm
(
)
const
{
return
fMapping
.
layerMatrix
(
)
;
}
const
LayerSpace
<
SkIRect
>
&
desiredOutput
(
)
const
{
return
fDesiredOutput
;
}
const
SkIRect
&
clipBounds
(
)
const
{
return
static_cast
<
const
SkIRect
&
>
(
fDesiredOutput
)
;
}
SkImageFilterCache
*
cache
(
)
const
{
return
fCache
;
}
SkColorType
colorType
(
)
const
{
return
fColorType
;
}
#
if
defined
(
SK_GANESH
)
GrColorType
grColorType
(
)
const
{
return
SkColorTypeToGrColorType
(
fColorType
)
;
}
#
endif
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorSpace
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
sk_ref_sp
(
fColorSpace
)
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSource
.
image
(
)
-
>
props
(
)
;
}
const
FilterResult
&
source
(
)
const
{
return
fSource
;
}
const
SkSpecialImage
*
sourceImage
(
)
const
{
return
fSource
.
image
(
)
;
}
bool
gpuBacked
(
)
const
{
return
fSource
.
image
(
)
-
>
isTextureBacked
(
)
;
}
GrRecordingContext
*
getContext
(
)
const
{
return
fSource
.
image
(
)
-
>
getContext
(
)
;
}
bool
isValid
(
)
const
{
return
fSource
.
image
(
)
!
=
nullptr
&
&
fMapping
.
layerMatrix
(
)
.
isFinite
(
)
;
}
sk_sp
<
SkSpecialSurface
>
makeSurface
(
const
SkISize
&
size
const
SkSurfaceProps
*
props
=
nullptr
)
const
{
if
(
!
props
)
{
props
=
&
this
-
>
surfaceProps
(
)
;
}
return
fSource
.
image
(
)
-
>
makeSurface
(
fColorType
fColorSpace
size
kPremul_SkAlphaType
*
props
)
;
}
Context
withNewMapping
(
const
Mapping
&
mapping
)
const
{
return
Context
(
mapping
fDesiredOutput
fCache
fColorType
fColorSpace
fSource
)
;
}
Context
withNewDesiredOutput
(
const
LayerSpace
<
SkIRect
>
&
desiredOutput
)
const
{
return
Context
(
fMapping
desiredOutput
fCache
fColorType
fColorSpace
fSource
)
;
}
private
:
Mapping
fMapping
;
LayerSpace
<
SkIRect
>
fDesiredOutput
;
SkImageFilterCache
*
fCache
;
SkColorType
fColorType
;
SkColorSpace
*
fColorSpace
;
FilterResult
fSource
;
}
;
}
#
endif
