#
ifndef
SkLinearBitmapPipeline_tile_DEFINED
#
define
SkLinearBitmapPipeline_tile_DEFINED
#
include
"
SkLinearBitmapPipeline_core
.
h
"
#
include
"
SkPM4f
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
namespace
{
class
XClampStrategy
{
public
:
XClampStrategy
(
int32_t
max
)
:
fXsMax
{
SkScalar
(
max
-
0
.
5f
)
}
fXMax
{
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
*
xs
=
Sk4s
:
:
Min
(
Sk4s
:
:
Max
(
*
xs
0
.
0f
)
fXsMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
0
]
&
&
(
*
xs
)
[
0
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
1
]
&
&
(
*
xs
)
[
1
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
2
]
&
&
(
*
xs
)
[
2
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
3
]
&
&
(
*
xs
)
[
3
]
<
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
X
(
start
)
;
SkScalar
y
=
Y
(
start
)
;
Span
span
{
{
x
y
}
length
count
}
;
if
(
span
.
completelyWithin
(
0
.
0f
fXMax
)
)
{
next
-
>
pointSpan
(
span
)
;
return
true
;
}
if
(
1
=
=
count
|
|
0
.
0f
=
=
length
)
{
return
false
;
}
SkScalar
dx
=
length
/
(
count
-
1
)
;
if
(
dx
>
=
0
)
{
Span
leftClamped
=
span
.
breakAt
(
0
.
0f
dx
)
;
if
(
!
leftClamped
.
isEmpty
(
)
)
{
leftClamped
.
clampToSinglePixel
(
{
0
.
0f
y
}
)
;
next
-
>
pointSpan
(
leftClamped
)
;
}
Span
center
=
span
.
breakAt
(
fXMax
dx
)
;
if
(
!
center
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
center
)
;
}
if
(
!
span
.
isEmpty
(
)
)
{
span
.
clampToSinglePixel
(
{
fXMax
-
1
y
}
)
;
next
-
>
pointSpan
(
span
)
;
}
}
else
{
Span
rightClamped
=
span
.
breakAt
(
fXMax
dx
)
;
if
(
!
rightClamped
.
isEmpty
(
)
)
{
rightClamped
.
clampToSinglePixel
(
{
fXMax
-
1
y
}
)
;
next
-
>
pointSpan
(
rightClamped
)
;
}
Span
center
=
span
.
breakAt
(
0
.
0f
dx
)
;
if
(
!
center
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
center
)
;
}
if
(
!
span
.
isEmpty
(
)
)
{
span
.
clampToSinglePixel
(
{
0
.
0f
y
}
)
;
next
-
>
pointSpan
(
span
)
;
}
}
return
true
;
}
private
:
const
Sk4s
fXsMax
;
const
SkScalar
fXMax
;
}
;
class
YClampStrategy
{
public
:
YClampStrategy
(
int32_t
max
)
:
fYMax
{
SkScalar
(
max
)
-
0
.
5f
}
fYsMax
{
SkScalar
(
max
)
-
0
.
5f
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
*
ys
=
Sk4s
:
:
Min
(
Sk4s
:
:
Max
(
*
ys
0
.
0f
)
fYsMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
0
]
&
&
(
*
ys
)
[
0
]
<
=
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
1
]
&
&
(
*
ys
)
[
1
]
<
=
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
2
]
&
&
(
*
ys
)
[
2
]
<
=
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
3
]
&
&
(
*
ys
)
[
3
]
<
=
fYMax
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
return
std
:
:
min
(
std
:
:
max
<
SkScalar
>
(
0
.
0f
y
)
fYMax
)
;
}
private
:
const
SkScalar
fYMax
;
const
Sk4s
fYsMax
;
}
;
SkScalar
tile_mod
(
SkScalar
x
SkScalar
base
)
{
return
x
-
SkScalarFloorToScalar
(
x
/
base
)
*
base
;
}
class
XRepeatStrategy
{
public
:
XRepeatStrategy
(
int32_t
max
)
:
fXMax
{
SkScalar
(
max
)
}
fXsMax
{
SkScalar
(
max
)
}
fXsCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXsInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4s
divX
=
*
xs
*
fXsInvMax
;
Sk4s
modX
=
*
xs
-
divX
.
floor
(
)
*
fXsMax
;
*
xs
=
Sk4s
:
:
Min
(
fXsCap
modX
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
0
]
&
&
(
*
xs
)
[
0
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
1
]
&
&
(
*
xs
)
[
1
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
2
]
&
&
(
*
xs
)
[
2
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
3
]
&
&
(
*
xs
)
[
3
]
<
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
tile_mod
(
X
(
start
)
fXMax
)
;
SkScalar
y
=
Y
(
start
)
;
SkScalar
dx
=
length
/
(
count
-
1
)
;
if
(
SkScalarAbs
(
dx
)
>
=
fXMax
|
|
count
<
=
1
)
{
return
false
;
}
Span
span
(
{
x
y
}
length
count
)
;
if
(
dx
>
0
)
{
while
(
!
span
.
isEmpty
(
)
&
&
span
.
endX
(
)
>
=
fXMax
)
{
Span
toDraw
=
span
.
breakAt
(
fXMax
dx
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
-
fXMax
)
;
}
}
else
{
while
(
!
span
.
isEmpty
(
)
&
&
span
.
endX
(
)
<
0
.
0f
)
{
Span
toDraw
=
span
.
breakAt
(
0
.
0f
dx
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
fXMax
)
;
}
}
if
(
!
span
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
span
)
;
}
return
true
;
}
private
:
const
SkScalar
fXMax
;
const
Sk4s
fXsMax
;
const
Sk4s
fXsCap
;
const
Sk4s
fXsInvMax
;
}
;
class
XRepeatUnitScaleStrategy
{
public
:
XRepeatUnitScaleStrategy
(
int32_t
max
)
:
fXMax
{
SkScalar
(
max
)
}
fXsMax
{
SkScalar
(
max
)
}
fXsCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXsInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4s
divX
=
*
xs
*
fXsInvMax
;
Sk4s
modX
=
*
xs
-
divX
.
floor
(
)
*
fXsMax
;
*
xs
=
Sk4s
:
:
Min
(
fXsCap
modX
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
0
]
&
&
(
*
xs
)
[
0
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
1
]
&
&
(
*
xs
)
[
1
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
2
]
&
&
(
*
xs
)
[
2
]
<
fXMax
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
3
]
&
&
(
*
xs
)
[
3
]
<
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
tile_mod
(
X
(
start
)
fXMax
)
;
SkScalar
y
=
Y
(
start
)
;
if
(
fXMax
=
=
1
|
|
count
<
=
1
)
{
return
false
;
}
SkASSERT
(
0
.
0f
<
=
x
&
&
x
<
fXMax
)
;
Span
span
(
{
x
y
}
length
count
)
;
if
(
SkScalarFloorToScalar
(
x
)
!
=
0
.
0f
)
{
Span
toDraw
=
span
.
breakAt
(
fXMax
1
.
0f
)
;
SkASSERT
(
0
.
0f
<
=
toDraw
.
startX
(
)
&
&
toDraw
.
endX
(
)
<
fXMax
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
-
fXMax
)
;
}
if
(
span
.
isEmpty
(
)
)
return
true
;
SkASSERT
(
SkScalarFloorToScalar
(
span
.
startX
(
)
)
=
=
0
.
0f
)
;
SkScalar
div
=
(
span
.
length
(
)
+
1
.
0f
)
/
fXMax
;
int32_t
repeatCount
=
SkScalarFloorToInt
(
div
)
;
Span
repeatableSpan
{
{
0
.
0f
y
}
fXMax
-
1
.
0f
SkScalarFloorToInt
(
fXMax
)
}
;
SkASSERT
(
0
.
0f
<
=
repeatableSpan
.
startX
(
)
&
&
repeatableSpan
.
endX
(
)
<
fXMax
)
;
if
(
repeatCount
>
0
)
{
next
-
>
repeatSpan
(
repeatableSpan
repeatCount
)
;
}
SkScalar
advance
=
SkScalar
(
repeatCount
)
*
fXMax
;
span
.
breakAt
(
advance
1
.
0f
)
;
if
(
!
span
.
isEmpty
(
)
)
{
span
.
offset
(
-
advance
)
;
SkASSERT
(
0
.
0f
<
=
span
.
startX
(
)
&
&
span
.
endX
(
)
<
fXMax
)
;
next
-
>
pointSpan
(
span
)
;
}
return
true
;
}
private
:
const
SkScalar
fXMax
;
const
Sk4s
fXsMax
;
const
Sk4s
fXsCap
;
const
Sk4s
fXsInvMax
;
}
;
class
YRepeatStrategy
{
public
:
YRepeatStrategy
(
int32_t
max
)
:
fYMax
{
SkScalar
(
max
)
}
fYsMax
{
SkScalar
(
max
)
}
fYsInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
Sk4s
divY
=
*
ys
*
fYsInvMax
;
Sk4s
modY
=
*
ys
-
divY
.
floor
(
)
*
fYsMax
;
*
ys
=
modY
;
SkASSERT
(
0
<
=
(
*
ys
)
[
0
]
&
&
(
*
ys
)
[
0
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
1
]
&
&
(
*
ys
)
[
1
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
2
]
&
&
(
*
ys
)
[
2
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
3
]
&
&
(
*
ys
)
[
3
]
<
fYMax
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
SkScalar
answer
=
tile_mod
(
y
fYMax
)
;
SkASSERT
(
0
<
=
answer
&
&
answer
<
fYMax
)
;
return
answer
;
}
private
:
const
SkScalar
fYMax
;
const
Sk4s
fYsMax
;
const
Sk4s
fYsInvMax
;
}
;
class
XMirrorStrategy
{
public
:
XMirrorStrategy
(
int32_t
max
)
:
fXsMax
{
SkScalar
(
max
)
}
fXsCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXsDoubleInvMax
{
1
.
0f
/
(
2
.
0f
*
SkScalar
(
max
)
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4f
bias
=
*
xs
-
fXsMax
;
Sk4f
div
=
bias
*
fXsDoubleInvMax
;
Sk4f
mod
=
bias
-
div
.
floor
(
)
*
2
.
0f
*
fXsMax
;
Sk4f
unbias
=
mod
-
fXsMax
;
*
xs
=
Sk4f
:
:
Min
(
unbias
.
abs
(
)
fXsCap
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
0
]
&
&
(
*
xs
)
[
0
]
<
fXsMax
[
0
]
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
1
]
&
&
(
*
xs
)
[
1
]
<
fXsMax
[
0
]
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
2
]
&
&
(
*
xs
)
[
2
]
<
fXsMax
[
0
]
)
;
SkASSERT
(
0
<
=
(
*
xs
)
[
3
]
&
&
(
*
xs
)
[
3
]
<
fXsMax
[
0
]
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
return
false
;
}
private
:
Sk4f
fXsMax
;
Sk4f
fXsCap
;
Sk4f
fXsDoubleInvMax
;
}
;
class
YMirrorStrategy
{
public
:
YMirrorStrategy
(
int32_t
max
)
:
fYMax
{
SkScalar
(
max
)
}
fYsMax
{
SkScalar
(
max
)
}
fYsCap
{
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
}
fYsDoubleInvMax
{
1
.
0f
/
(
2
.
0f
*
SkScalar
(
max
)
)
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
Sk4f
bias
=
*
ys
-
fYsMax
;
Sk4f
div
=
bias
*
fYsDoubleInvMax
;
Sk4f
mod
=
bias
-
div
.
floor
(
)
*
2
.
0f
*
fYsMax
;
Sk4f
unbias
=
mod
-
fYsMax
;
*
ys
=
Sk4f
:
:
Min
(
unbias
.
abs
(
)
fYsCap
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
0
]
&
&
(
*
ys
)
[
0
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
1
]
&
&
(
*
ys
)
[
1
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
2
]
&
&
(
*
ys
)
[
2
]
<
fYMax
)
;
SkASSERT
(
0
<
=
(
*
ys
)
[
3
]
&
&
(
*
ys
)
[
3
]
<
fYMax
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
SkScalar
bias
=
y
-
fYMax
;
SkScalar
div
=
bias
*
fYsDoubleInvMax
[
0
]
;
SkScalar
mod
=
bias
-
SkScalarFloorToScalar
(
div
)
*
2
.
0f
*
fYMax
;
SkScalar
unbias
=
mod
-
fYMax
;
SkScalar
answer
=
SkMinScalar
(
SkScalarAbs
(
unbias
)
fYsCap
[
0
]
)
;
SkASSERT
(
0
<
=
answer
&
&
answer
<
fYMax
)
;
return
answer
;
}
private
:
SkScalar
fYMax
;
Sk4f
fYsMax
;
Sk4f
fYsCap
;
Sk4f
fYsDoubleInvMax
;
}
;
}
#
endif
