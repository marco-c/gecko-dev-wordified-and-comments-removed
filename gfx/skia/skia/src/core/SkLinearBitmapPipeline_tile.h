#
ifndef
SkLinearBitmapPipeline_tile_DEFINED
#
define
SkLinearBitmapPipeline_tile_DEFINED
#
include
"
SkLinearBitmapPipeline_core
.
h
"
#
include
"
SkPM4f
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
namespace
{
void
assertTiled
(
const
Sk4s
&
vs
SkScalar
vMax
)
{
SkASSERT
(
0
<
=
vs
[
0
]
&
&
vs
[
0
]
<
vMax
)
;
SkASSERT
(
0
<
=
vs
[
1
]
&
&
vs
[
1
]
<
vMax
)
;
SkASSERT
(
0
<
=
vs
[
2
]
&
&
vs
[
2
]
<
vMax
)
;
SkASSERT
(
0
<
=
vs
[
3
]
&
&
vs
[
3
]
<
vMax
)
;
}
class
XClampStrategy
{
public
:
XClampStrategy
(
int32_t
max
)
:
fXMaxPixel
{
SkScalar
(
max
-
SK_ScalarHalf
)
}
fXMax
{
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
*
xs
=
Sk4s
:
:
Min
(
Sk4s
:
:
Max
(
*
xs
SK_ScalarHalf
)
fXMaxPixel
)
;
assertTiled
(
*
xs
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
X
(
start
)
;
SkScalar
y
=
Y
(
start
)
;
Span
span
{
{
x
y
}
length
count
}
;
if
(
span
.
completelyWithin
(
0
.
0f
fXMax
)
)
{
next
-
>
pointSpan
(
span
)
;
return
true
;
}
if
(
1
=
=
count
|
|
0
.
0f
=
=
length
)
{
return
false
;
}
SkScalar
dx
=
length
/
(
count
-
1
)
;
if
(
dx
>
=
0
)
{
Span
leftClamped
=
span
.
breakAt
(
SK_ScalarHalf
dx
)
;
if
(
!
leftClamped
.
isEmpty
(
)
)
{
leftClamped
.
clampToSinglePixel
(
{
SK_ScalarHalf
y
}
)
;
next
-
>
pointSpan
(
leftClamped
)
;
}
Span
center
=
span
.
breakAt
(
fXMax
dx
)
;
if
(
!
center
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
center
)
;
}
if
(
!
span
.
isEmpty
(
)
)
{
span
.
clampToSinglePixel
(
{
fXMaxPixel
y
}
)
;
next
-
>
pointSpan
(
span
)
;
}
}
else
{
Span
rightClamped
=
span
.
breakAt
(
fXMax
dx
)
;
if
(
!
rightClamped
.
isEmpty
(
)
)
{
rightClamped
.
clampToSinglePixel
(
{
fXMaxPixel
y
}
)
;
next
-
>
pointSpan
(
rightClamped
)
;
}
Span
center
=
span
.
breakAt
(
SK_ScalarHalf
dx
)
;
if
(
!
center
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
center
)
;
}
if
(
!
span
.
isEmpty
(
)
)
{
span
.
clampToSinglePixel
(
{
SK_ScalarHalf
y
}
)
;
next
-
>
pointSpan
(
span
)
;
}
}
return
true
;
}
private
:
const
SkScalar
fXMaxPixel
;
const
SkScalar
fXMax
;
}
;
class
YClampStrategy
{
public
:
YClampStrategy
(
int32_t
max
)
:
fYMaxPixel
{
SkScalar
(
max
)
-
SK_ScalarHalf
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
*
ys
=
Sk4s
:
:
Min
(
Sk4s
:
:
Max
(
*
ys
SK_ScalarHalf
)
fYMaxPixel
)
;
assertTiled
(
*
ys
fYMaxPixel
+
SK_ScalarHalf
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
Sk4f
ys
{
y
}
;
tileYPoints
(
&
ys
)
;
return
ys
[
0
]
;
}
private
:
const
SkScalar
fYMaxPixel
;
}
;
SkScalar
tile_mod
(
SkScalar
x
SkScalar
base
SkScalar
cap
)
{
return
std
:
:
min
(
x
-
SkScalarFloorToScalar
(
x
/
base
)
*
base
cap
)
;
}
class
XRepeatStrategy
{
public
:
XRepeatStrategy
(
int32_t
max
)
:
fXMax
{
SkScalar
(
max
)
}
fXCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4s
divX
=
*
xs
*
fXInvMax
;
Sk4s
modX
=
*
xs
-
divX
.
floor
(
)
*
fXMax
;
*
xs
=
Sk4s
:
:
Min
(
fXCap
modX
)
;
assertTiled
(
*
xs
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
tile_mod
(
X
(
start
)
fXMax
fXCap
)
;
SkScalar
y
=
Y
(
start
)
;
SkScalar
dx
=
length
/
(
count
-
1
)
;
if
(
SkScalarAbs
(
dx
)
>
=
fXMax
|
|
count
<
=
1
)
{
return
false
;
}
Span
span
(
{
x
y
}
length
count
)
;
if
(
dx
>
0
)
{
while
(
!
span
.
isEmpty
(
)
&
&
span
.
endX
(
)
>
=
fXMax
)
{
Span
toDraw
=
span
.
breakAt
(
fXMax
dx
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
-
fXMax
)
;
}
}
else
{
while
(
!
span
.
isEmpty
(
)
&
&
span
.
endX
(
)
<
0
.
0f
)
{
Span
toDraw
=
span
.
breakAt
(
0
.
0f
dx
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
fXMax
)
;
}
}
if
(
!
span
.
isEmpty
(
)
)
{
next
-
>
pointSpan
(
span
)
;
}
return
true
;
}
private
:
const
SkScalar
fXMax
;
const
SkScalar
fXCap
;
const
SkScalar
fXInvMax
;
}
;
class
XRepeatUnitScaleStrategy
{
public
:
XRepeatUnitScaleStrategy
(
int32_t
max
)
:
fXMax
{
SkScalar
(
max
)
}
fXCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4s
divX
=
*
xs
*
fXInvMax
;
Sk4s
modX
=
*
xs
-
divX
.
floor
(
)
*
fXMax
;
*
xs
=
Sk4s
:
:
Min
(
fXCap
modX
)
;
assertTiled
(
*
xs
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
SkASSERT
(
!
originalSpan
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
originalSpan
;
SkScalar
x
=
tile_mod
(
X
(
start
)
fXMax
fXCap
)
;
SkScalar
y
=
Y
(
start
)
;
if
(
fXMax
=
=
1
|
|
count
<
=
1
)
{
return
false
;
}
SkASSERT
(
0
.
0f
<
=
x
&
&
x
<
fXMax
)
;
Span
span
(
{
x
y
}
length
count
)
;
if
(
SkScalarFloorToScalar
(
x
)
!
=
0
.
0f
)
{
Span
toDraw
=
span
.
breakAt
(
fXMax
1
.
0f
)
;
SkASSERT
(
0
.
0f
<
=
toDraw
.
startX
(
)
&
&
toDraw
.
endX
(
)
<
fXMax
)
;
next
-
>
pointSpan
(
toDraw
)
;
span
.
offset
(
-
fXMax
)
;
}
if
(
span
.
isEmpty
(
)
)
return
true
;
SkASSERT
(
SkScalarFloorToScalar
(
span
.
startX
(
)
)
=
=
0
.
0f
)
;
SkScalar
div
=
(
span
.
length
(
)
+
1
.
0f
)
/
fXMax
;
int32_t
repeatCount
=
SkScalarFloorToInt
(
div
)
;
Span
repeatableSpan
{
{
0
.
0f
y
}
fXMax
-
1
.
0f
SkScalarFloorToInt
(
fXMax
)
}
;
SkASSERT
(
0
.
0f
<
=
repeatableSpan
.
startX
(
)
&
&
repeatableSpan
.
endX
(
)
<
fXMax
)
;
if
(
repeatCount
>
0
)
{
next
-
>
repeatSpan
(
repeatableSpan
repeatCount
)
;
}
SkScalar
advance
=
SkScalar
(
repeatCount
)
*
fXMax
;
span
.
breakAt
(
advance
1
.
0f
)
;
if
(
!
span
.
isEmpty
(
)
)
{
span
.
offset
(
-
advance
)
;
SkASSERT
(
0
.
0f
<
=
span
.
startX
(
)
&
&
span
.
endX
(
)
<
fXMax
)
;
next
-
>
pointSpan
(
span
)
;
}
return
true
;
}
private
:
const
SkScalar
fXMax
;
const
SkScalar
fXCap
;
const
SkScalar
fXInvMax
;
}
;
class
YRepeatStrategy
{
public
:
YRepeatStrategy
(
int32_t
max
)
:
fYMax
{
SkScalar
(
max
)
}
fYCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fYsInvMax
{
1
.
0f
/
SkScalar
(
max
)
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
Sk4s
divY
=
*
ys
*
fYsInvMax
;
Sk4s
modY
=
*
ys
-
divY
.
floor
(
)
*
fYMax
;
*
ys
=
Sk4s
:
:
Min
(
fYCap
modY
)
;
assertTiled
(
*
ys
fYMax
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
SkScalar
answer
=
tile_mod
(
y
fYMax
fYCap
)
;
SkASSERT
(
0
<
=
answer
&
&
answer
<
fYMax
)
;
return
answer
;
}
private
:
const
SkScalar
fYMax
;
const
SkScalar
fYCap
;
const
SkScalar
fYsInvMax
;
}
;
class
XMirrorStrategy
{
public
:
XMirrorStrategy
(
int32_t
max
)
:
fXMax
{
SkScalar
(
max
)
}
fXCap
{
SkScalar
(
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
)
}
fXDoubleInvMax
{
1
.
0f
/
(
2
.
0f
*
SkScalar
(
max
)
)
}
{
}
void
tileXPoints
(
Sk4s
*
xs
)
{
Sk4f
bias
=
*
xs
-
fXMax
;
Sk4f
div
=
bias
*
fXDoubleInvMax
;
Sk4f
mod
=
bias
-
div
.
floor
(
)
*
2
.
0f
*
fXMax
;
Sk4f
unbias
=
mod
-
fXMax
;
*
xs
=
Sk4f
:
:
Min
(
unbias
.
abs
(
)
fXCap
)
;
assertTiled
(
*
xs
fXMax
)
;
}
template
<
typename
Next
>
bool
maybeProcessSpan
(
Span
originalSpan
Next
*
next
)
{
return
false
;
}
private
:
SkScalar
fXMax
;
SkScalar
fXCap
;
SkScalar
fXDoubleInvMax
;
}
;
class
YMirrorStrategy
{
public
:
YMirrorStrategy
(
int32_t
max
)
:
fYMax
{
SkScalar
(
max
)
}
fYCap
{
nextafterf
(
SkScalar
(
max
)
0
.
0f
)
}
fYDoubleInvMax
{
1
.
0f
/
(
2
.
0f
*
SkScalar
(
max
)
)
}
{
}
void
tileYPoints
(
Sk4s
*
ys
)
{
Sk4f
bias
=
*
ys
-
fYMax
;
Sk4f
div
=
bias
*
fYDoubleInvMax
;
Sk4f
mod
=
bias
-
div
.
floor
(
)
*
2
.
0f
*
fYMax
;
Sk4f
unbias
=
mod
-
fYMax
;
*
ys
=
Sk4f
:
:
Min
(
unbias
.
abs
(
)
fYCap
)
;
assertTiled
(
*
ys
fYMax
)
;
}
SkScalar
tileY
(
SkScalar
y
)
{
SkScalar
bias
=
y
-
fYMax
;
SkScalar
div
=
bias
*
fYDoubleInvMax
;
SkScalar
mod
=
bias
-
SkScalarFloorToScalar
(
div
)
*
2
.
0f
*
fYMax
;
SkScalar
unbias
=
mod
-
fYMax
;
SkScalar
answer
=
SkMinScalar
(
SkScalarAbs
(
unbias
)
fYCap
)
;
SkASSERT
(
0
<
=
answer
&
&
answer
<
fYMax
)
;
return
answer
;
}
private
:
SkScalar
fYMax
;
SkScalar
fYCap
;
SkScalar
fYDoubleInvMax
;
}
;
}
#
endif
