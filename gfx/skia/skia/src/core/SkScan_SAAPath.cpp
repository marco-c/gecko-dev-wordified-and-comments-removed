#
include
"
src
/
core
/
SkScanPriv
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkRegion
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkAntiRun
.
h
"
#
include
"
src
/
core
/
SkBlitter
.
h
"
#
if
defined
(
SK_FORCE_AAA
)
void
SkScan
:
:
SAAFillPath
(
const
SkPath
&
SkBlitter
*
const
SkIRect
&
const
SkIRect
&
bool
)
{
SkDEBUGFAIL
(
"
SAA
Disabled
"
)
;
}
#
else
#
define
SHIFT
SK_SUPERSAMPLE_SHIFT
#
define
SCALE
(
1
<
<
SHIFT
)
#
define
MASK
(
SCALE
-
1
)
class
BaseSuperBlitter
:
public
SkBlitter
{
public
:
BaseSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
;
void
blitAntiH
(
int
x
int
y
const
SkAlpha
antialias
[
]
const
int16_t
runs
[
]
)
override
{
SkDEBUGFAIL
(
"
How
did
I
get
here
?
"
)
;
}
void
blitV
(
int
x
int
y
int
height
SkAlpha
alpha
)
override
{
SkDEBUGFAIL
(
"
How
did
I
get
here
?
"
)
;
}
protected
:
SkBlitter
*
fRealBlitter
;
int
fCurrIY
;
int
fWidth
;
int
fLeft
;
int
fSuperLeft
;
SkDEBUGCODE
(
int
fCurrX
;
)
int
fCurrY
;
int
fTop
;
SkIRect
fSectBounds
;
}
;
BaseSuperBlitter
:
:
BaseSuperBlitter
(
SkBlitter
*
realBlit
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
{
fRealBlitter
=
realBlit
;
SkIRect
sectBounds
;
if
(
isInverse
)
{
sectBounds
=
clipBounds
;
}
else
{
if
(
!
sectBounds
.
intersect
(
ir
clipBounds
)
)
{
sectBounds
.
setEmpty
(
)
;
}
}
const
int
left
=
sectBounds
.
left
(
)
;
const
int
right
=
sectBounds
.
right
(
)
;
fLeft
=
left
;
fSuperLeft
=
SkLeftShift
(
left
SHIFT
)
;
fWidth
=
right
-
left
;
fTop
=
sectBounds
.
top
(
)
;
fCurrIY
=
fTop
-
1
;
fCurrY
=
SkLeftShift
(
fTop
SHIFT
)
-
1
;
SkDEBUGCODE
(
fCurrX
=
-
1
;
)
}
class
SuperBlitter
:
public
BaseSuperBlitter
{
public
:
SuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
;
~
SuperBlitter
(
)
override
{
this
-
>
flush
(
)
;
}
void
flush
(
)
;
void
blitH
(
int
x
int
y
int
width
)
override
;
void
blitRect
(
int
x
int
y
int
width
int
height
)
override
;
private
:
int
fRunsToBuffer
;
void
*
fRunsBuffer
;
int
fCurrentRun
;
SkAlphaRuns
fRuns
;
int
getRunsSz
(
)
const
{
return
(
fWidth
+
1
+
(
fWidth
+
2
)
/
2
)
*
sizeof
(
int16_t
)
;
}
void
advanceRuns
(
)
{
const
size_t
kRunsSz
=
this
-
>
getRunsSz
(
)
;
fCurrentRun
=
(
fCurrentRun
+
1
)
%
fRunsToBuffer
;
fRuns
.
fRuns
=
reinterpret_cast
<
int16_t
*
>
(
reinterpret_cast
<
uint8_t
*
>
(
fRunsBuffer
)
+
fCurrentRun
*
kRunsSz
)
;
fRuns
.
fAlpha
=
reinterpret_cast
<
SkAlpha
*
>
(
fRuns
.
fRuns
+
fWidth
+
1
)
;
fRuns
.
reset
(
fWidth
)
;
}
int
fOffsetX
;
}
;
SuperBlitter
:
:
SuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
:
BaseSuperBlitter
(
realBlitter
ir
clipBounds
isInverse
)
{
fRunsToBuffer
=
realBlitter
-
>
requestRowsPreserved
(
)
;
fRunsBuffer
=
realBlitter
-
>
allocBlitMemory
(
fRunsToBuffer
*
this
-
>
getRunsSz
(
)
)
;
fCurrentRun
=
-
1
;
this
-
>
advanceRuns
(
)
;
fOffsetX
=
0
;
}
void
SuperBlitter
:
:
flush
(
)
{
if
(
fCurrIY
>
=
fTop
)
{
SkASSERT
(
fCurrentRun
<
fRunsToBuffer
)
;
if
(
!
fRuns
.
empty
(
)
)
{
fRealBlitter
-
>
blitAntiH
(
fLeft
fCurrIY
fRuns
.
fAlpha
fRuns
.
fRuns
)
;
this
-
>
advanceRuns
(
)
;
fOffsetX
=
0
;
}
fCurrIY
=
fTop
-
1
;
SkDEBUGCODE
(
fCurrX
=
-
1
;
)
}
}
static
inline
int
coverage_to_partial_alpha
(
int
aa
)
{
aa
<
<
=
8
-
2
*
SHIFT
;
return
aa
;
}
static
inline
int
coverage_to_exact_alpha
(
int
aa
)
{
int
alpha
=
(
256
>
>
SHIFT
)
*
aa
;
return
alpha
-
(
alpha
>
>
8
)
;
}
void
SuperBlitter
:
:
blitH
(
int
x
int
y
int
width
)
{
SkASSERT
(
width
>
0
)
;
int
iy
=
y
>
>
SHIFT
;
SkASSERT
(
iy
>
=
fCurrIY
)
;
x
-
=
fSuperLeft
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
#
ifdef
SK_DEBUG
SkASSERT
(
y
!
=
fCurrY
|
|
x
>
=
fCurrX
)
;
#
endif
SkASSERT
(
y
>
=
fCurrY
)
;
if
(
fCurrY
!
=
y
)
{
fOffsetX
=
0
;
fCurrY
=
y
;
}
if
(
iy
!
=
fCurrIY
)
{
this
-
>
flush
(
)
;
fCurrIY
=
iy
;
}
int
start
=
x
;
int
stop
=
x
+
width
;
SkASSERT
(
start
>
=
0
&
&
stop
>
start
)
;
int
fb
=
start
&
MASK
;
int
fe
=
stop
&
MASK
;
int
n
=
(
stop
>
>
SHIFT
)
-
(
start
>
>
SHIFT
)
-
1
;
if
(
n
<
0
)
{
fb
=
fe
-
fb
;
n
=
0
;
fe
=
0
;
}
else
{
if
(
fb
=
=
0
)
{
n
+
=
1
;
}
else
{
fb
=
SCALE
-
fb
;
}
}
fOffsetX
=
fRuns
.
add
(
x
>
>
SHIFT
coverage_to_partial_alpha
(
fb
)
n
coverage_to_partial_alpha
(
fe
)
(
1
<
<
(
8
-
SHIFT
)
)
-
(
(
(
y
&
MASK
)
+
1
)
>
>
SHIFT
)
fOffsetX
)
;
#
ifdef
SK_DEBUG
fRuns
.
assertValid
(
y
&
MASK
(
1
<
<
(
8
-
SHIFT
)
)
)
;
fCurrX
=
x
+
width
;
#
endif
}
#
if
0
static
void
set_left_rite_runs
(
SkAlphaRuns
&
runs
int
ileft
U8CPU
leftA
int
n
U8CPU
riteA
)
{
SkASSERT
(
leftA
<
=
0xFF
)
;
SkASSERT
(
riteA
<
=
0xFF
)
;
int16_t
*
run
=
runs
.
fRuns
;
uint8_t
*
aa
=
runs
.
fAlpha
;
if
(
ileft
>
0
)
{
run
[
0
]
=
ileft
;
aa
[
0
]
=
0
;
run
+
=
ileft
;
aa
+
=
ileft
;
}
SkASSERT
(
leftA
<
0xFF
)
;
if
(
leftA
>
0
)
{
*
run
+
+
=
1
;
*
aa
+
+
=
leftA
;
}
if
(
n
>
0
)
{
run
[
0
]
=
n
;
aa
[
0
]
=
0xFF
;
run
+
=
n
;
aa
+
=
n
;
}
SkASSERT
(
riteA
<
0xFF
)
;
if
(
riteA
>
0
)
{
*
run
+
+
=
1
;
*
aa
+
+
=
riteA
;
}
run
[
0
]
=
0
;
}
#
endif
void
SuperBlitter
:
:
blitRect
(
int
x
int
y
int
width
int
height
)
{
SkASSERT
(
width
>
0
)
;
SkASSERT
(
height
>
0
)
;
while
(
(
y
&
MASK
)
)
{
this
-
>
blitH
(
x
y
+
+
width
)
;
if
(
-
-
height
<
=
0
)
{
return
;
}
}
SkASSERT
(
height
>
0
)
;
int
start_y
=
y
>
>
SHIFT
;
int
stop_y
=
(
y
+
height
)
>
>
SHIFT
;
int
count
=
stop_y
-
start_y
;
if
(
count
>
0
)
{
y
+
=
count
<
<
SHIFT
;
height
-
=
count
<
<
SHIFT
;
int
origX
=
x
;
x
-
=
fSuperLeft
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
int
ileft
=
x
>
>
SHIFT
;
int
xleft
=
x
&
MASK
;
int
irite
=
(
x
+
width
)
>
>
SHIFT
;
int
xrite
=
(
x
+
width
)
&
MASK
;
if
(
!
xrite
)
{
xrite
=
SCALE
;
irite
-
-
;
}
SkASSERT
(
start_y
>
fCurrIY
)
;
this
-
>
flush
(
)
;
int
n
=
irite
-
ileft
-
1
;
if
(
n
<
0
)
{
xleft
=
xrite
-
xleft
;
SkASSERT
(
xleft
<
=
SCALE
)
;
SkASSERT
(
xleft
>
0
)
;
fRealBlitter
-
>
blitV
(
ileft
+
fLeft
start_y
count
coverage_to_exact_alpha
(
xleft
)
)
;
}
else
{
xleft
=
SCALE
-
xleft
;
const
int
coverageL
=
coverage_to_exact_alpha
(
xleft
)
;
const
int
coverageR
=
coverage_to_exact_alpha
(
xrite
)
;
SkASSERT
(
coverageL
>
0
|
|
n
>
0
|
|
coverageR
>
0
)
;
SkASSERT
(
(
coverageL
!
=
0
)
+
n
+
(
coverageR
!
=
0
)
<
=
fWidth
)
;
fRealBlitter
-
>
blitAntiRect
(
ileft
+
fLeft
start_y
n
count
coverageL
coverageR
)
;
}
fCurrIY
=
stop_y
-
1
;
fOffsetX
=
0
;
fCurrY
=
y
-
1
;
fRuns
.
reset
(
fWidth
)
;
x
=
origX
;
}
SkASSERT
(
height
<
=
MASK
)
;
while
(
-
-
height
>
=
0
)
{
this
-
>
blitH
(
x
y
+
+
width
)
;
}
}
class
MaskSuperBlitter
:
public
BaseSuperBlitter
{
public
:
MaskSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
bool
isInverse
)
;
~
MaskSuperBlitter
(
)
override
{
fRealBlitter
-
>
blitMask
(
fMask
fClipRect
)
;
}
void
blitH
(
int
x
int
y
int
width
)
override
;
static
bool
CanHandleRect
(
const
SkIRect
&
bounds
)
{
#
ifdef
FORCE_RLE
return
false
;
#
endif
int
width
=
bounds
.
width
(
)
;
int64_t
rb
=
SkAlign4
(
width
)
;
int64_t
storage
=
rb
*
bounds
.
height
(
)
;
return
(
width
<
=
MaskSuperBlitter
:
:
kMAX_WIDTH
)
&
&
(
storage
<
=
MaskSuperBlitter
:
:
kMAX_STORAGE
)
;
}
private
:
enum
{
#
ifdef
FORCE_SUPERMASK
kMAX_WIDTH
=
2048
kMAX_STORAGE
=
1024
*
1024
*
2
#
else
kMAX_WIDTH
=
32
kMAX_STORAGE
=
1024
#
endif
}
;
SkMask
fMask
;
SkIRect
fClipRect
;
uint32_t
fStorage
[
(
kMAX_STORAGE
>
>
2
)
+
1
]
;
}
;
MaskSuperBlitter
:
:
MaskSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
:
BaseSuperBlitter
(
realBlitter
ir
clipBounds
isInverse
)
{
SkASSERT
(
CanHandleRect
(
ir
)
)
;
SkASSERT
(
!
isInverse
)
;
fMask
.
fImage
=
(
uint8_t
*
)
fStorage
;
fMask
.
fBounds
=
ir
;
fMask
.
fRowBytes
=
ir
.
width
(
)
;
fMask
.
fFormat
=
SkMask
:
:
kA8_Format
;
fClipRect
=
ir
;
if
(
!
fClipRect
.
intersect
(
clipBounds
)
)
{
SkASSERT
(
0
)
;
fClipRect
.
setEmpty
(
)
;
}
memset
(
fStorage
0
fMask
.
fBounds
.
height
(
)
*
fMask
.
fRowBytes
+
1
)
;
}
static
void
add_aa_span
(
uint8_t
*
alpha
U8CPU
startAlpha
)
{
unsigned
tmp
=
*
alpha
+
startAlpha
;
SkASSERT
(
tmp
<
=
256
)
;
*
alpha
=
SkToU8
(
tmp
-
(
tmp
>
>
8
)
)
;
}
static
inline
uint32_t
quadplicate_byte
(
U8CPU
value
)
{
uint32_t
pair
=
(
value
<
<
8
)
|
value
;
return
(
pair
<
<
16
)
|
pair
;
}
static
inline
void
saturated_add
(
uint8_t
*
ptr
U8CPU
add
)
{
unsigned
tmp
=
*
ptr
+
add
;
SkASSERT
(
tmp
<
=
256
)
;
*
ptr
=
SkToU8
(
tmp
-
(
tmp
>
>
8
)
)
;
}
#
define
MIN_COUNT_FOR_QUAD_LOOP
16
static
void
add_aa_span
(
uint8_t
*
alpha
U8CPU
startAlpha
int
middleCount
U8CPU
stopAlpha
U8CPU
maxValue
)
{
SkASSERT
(
middleCount
>
=
0
)
;
saturated_add
(
alpha
startAlpha
)
;
alpha
+
=
1
;
if
(
middleCount
>
=
MIN_COUNT_FOR_QUAD_LOOP
)
{
while
(
reinterpret_cast
<
intptr_t
>
(
alpha
)
&
0x3
)
{
alpha
[
0
]
=
SkToU8
(
alpha
[
0
]
+
maxValue
)
;
alpha
+
=
1
;
middleCount
-
=
1
;
}
int
bigCount
=
middleCount
>
>
2
;
uint32_t
*
qptr
=
reinterpret_cast
<
uint32_t
*
>
(
alpha
)
;
uint32_t
qval
=
quadplicate_byte
(
maxValue
)
;
do
{
*
qptr
+
+
+
=
qval
;
}
while
(
-
-
bigCount
>
0
)
;
middleCount
&
=
3
;
alpha
=
reinterpret_cast
<
uint8_t
*
>
(
qptr
)
;
}
while
(
-
-
middleCount
>
=
0
)
{
alpha
[
0
]
=
SkToU8
(
alpha
[
0
]
+
maxValue
)
;
alpha
+
=
1
;
}
saturated_add
(
alpha
stopAlpha
)
;
}
void
MaskSuperBlitter
:
:
blitH
(
int
x
int
y
int
width
)
{
int
iy
=
(
y
>
>
SHIFT
)
;
SkASSERT
(
iy
>
=
fMask
.
fBounds
.
fTop
&
&
iy
<
fMask
.
fBounds
.
fBottom
)
;
iy
-
=
fMask
.
fBounds
.
fTop
;
if
(
iy
<
0
)
{
return
;
}
#
ifdef
SK_DEBUG
{
int
ix
=
x
>
>
SHIFT
;
SkASSERT
(
ix
>
=
fMask
.
fBounds
.
fLeft
&
&
ix
<
fMask
.
fBounds
.
fRight
)
;
}
#
endif
x
-
=
SkLeftShift
(
fMask
.
fBounds
.
fLeft
SHIFT
)
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
uint8_t
*
row
=
fMask
.
fImage
+
iy
*
fMask
.
fRowBytes
+
(
x
>
>
SHIFT
)
;
int
start
=
x
;
int
stop
=
x
+
width
;
SkASSERT
(
start
>
=
0
&
&
stop
>
start
)
;
int
fb
=
start
&
MASK
;
int
fe
=
stop
&
MASK
;
int
n
=
(
stop
>
>
SHIFT
)
-
(
start
>
>
SHIFT
)
-
1
;
if
(
n
<
0
)
{
SkASSERT
(
row
>
=
fMask
.
fImage
)
;
SkASSERT
(
row
<
fMask
.
fImage
+
kMAX_STORAGE
+
1
)
;
add_aa_span
(
row
coverage_to_partial_alpha
(
fe
-
fb
)
)
;
}
else
{
fb
=
SCALE
-
fb
;
SkASSERT
(
row
>
=
fMask
.
fImage
)
;
SkASSERT
(
row
+
n
+
1
<
fMask
.
fImage
+
kMAX_STORAGE
+
1
)
;
add_aa_span
(
row
coverage_to_partial_alpha
(
fb
)
n
coverage_to_partial_alpha
(
fe
)
(
1
<
<
(
8
-
SHIFT
)
)
-
(
(
(
y
&
MASK
)
+
1
)
>
>
SHIFT
)
)
;
}
#
ifdef
SK_DEBUG
fCurrX
=
x
+
width
;
#
endif
}
void
SkScan
:
:
SAAFillPath
(
const
SkPath
&
path
SkBlitter
*
blitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
forceRLE
)
{
bool
containedInClip
=
clipBounds
.
contains
(
ir
)
;
bool
isInverse
=
path
.
isInverseFillType
(
)
;
if
(
!
isInverse
&
&
MaskSuperBlitter
:
:
CanHandleRect
(
ir
)
&
&
!
forceRLE
)
{
MaskSuperBlitter
superBlit
(
blitter
ir
clipBounds
isInverse
)
;
SkASSERT
(
SkIntToScalar
(
ir
.
fTop
)
<
=
path
.
getBounds
(
)
.
fTop
)
;
sk_fill_path
(
path
clipBounds
&
superBlit
ir
.
fTop
ir
.
fBottom
SHIFT
containedInClip
)
;
}
else
{
SuperBlitter
superBlit
(
blitter
ir
clipBounds
isInverse
)
;
sk_fill_path
(
path
clipBounds
&
superBlit
ir
.
fTop
ir
.
fBottom
SHIFT
containedInClip
)
;
}
}
#
endif
