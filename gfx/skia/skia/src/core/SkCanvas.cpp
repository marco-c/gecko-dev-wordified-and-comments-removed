#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkBlendMode
.
h
"
#
include
"
include
/
core
/
SkBlender
.
h
"
#
include
"
include
/
core
/
SkBlurTypes
.
h
"
#
include
"
include
/
core
/
SkColorFilter
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkMaskFilter
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPathEffect
.
h
"
#
include
"
include
/
core
/
SkPicture
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRSXform
.
h
"
#
include
"
include
/
core
/
SkRasterHandleAllocator
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkRegion
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
core
/
SkTextBlob
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
core
/
SkVertices
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkSafe32
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
chromium
/
Slug
.
h
"
#
include
"
include
/
utils
/
SkNoDrawCanvas
.
h
"
#
include
"
src
/
base
/
SkEnumBitMask
.
h
"
#
include
"
src
/
base
/
SkMSAN
.
h
"
#
include
"
src
/
core
/
SkBlenderBase
.
h
"
#
include
"
src
/
core
/
SkBlurMaskFilterImpl
.
h
"
#
include
"
src
/
core
/
SkCanvasPriv
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkImagePriv
.
h
"
#
include
"
src
/
core
/
SkLatticeIter
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkSurfacePriv
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
core
/
SkVerticesPriv
.
h
"
#
include
"
src
/
effects
/
colorfilters
/
SkColorFilterBase
.
h
"
#
include
"
src
/
image
/
SkSurface_Base
.
h
"
#
include
"
src
/
text
/
GlyphRun
.
h
"
#
include
"
src
/
utils
/
SkPatchUtils
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
new
>
#
include
<
optional
>
#
include
<
tuple
>
#
include
<
utility
>
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
#
include
"
src
/
core
/
SkMatrixUtils
.
h
"
#
endif
#
define
RETURN_ON_NULL
(
ptr
)
do
{
if
(
nullptr
=
=
(
ptr
)
)
return
;
}
while
(
0
)
#
define
RETURN_ON_FALSE
(
pred
)
do
{
if
(
!
(
pred
)
)
return
;
}
while
(
0
)
static_assert
(
std
:
:
max
(
3
4
)
=
=
4
)
;
using
Slug
=
sktext
:
:
gpu
:
:
Slug
;
SK_MAKE_BITMASK_OPS
(
SkCanvas
:
:
PredrawFlags
)
bool
SkCanvas
:
:
wouldOverwriteEntireSurface
(
const
SkRect
*
rect
const
SkPaint
*
paint
SkEnumBitMask
<
PredrawFlags
>
flags
)
const
{
auto
overrideOpacity
=
(
flags
&
PredrawFlags
:
:
kOpaqueShaderOverride
)
?
SkPaintPriv
:
:
kOpaque_ShaderOverrideOpacity
:
(
flags
&
PredrawFlags
:
:
kNonOpaqueShaderOverride
)
?
SkPaintPriv
:
:
kNotOpaque_ShaderOverrideOpacity
:
SkPaintPriv
:
:
kNone_ShaderOverrideOpacity
;
const
SkISize
size
=
this
-
>
getBaseLayerSize
(
)
;
const
SkRect
bounds
=
SkRect
:
:
MakeIWH
(
size
.
width
(
)
size
.
height
(
)
)
;
{
const
SkDevice
*
root
=
this
-
>
rootDevice
(
)
;
const
SkDevice
*
top
=
this
-
>
topDevice
(
)
;
if
(
root
!
=
top
)
{
return
false
;
}
if
(
!
root
-
>
isClipWideOpen
(
)
)
{
return
false
;
}
}
if
(
rect
)
{
if
(
!
this
-
>
getTotalMatrix
(
)
.
isScaleTranslate
(
)
)
{
return
false
;
}
SkRect
devRect
;
this
-
>
getTotalMatrix
(
)
.
mapRectScaleTranslate
(
&
devRect
*
rect
)
;
if
(
!
devRect
.
contains
(
bounds
)
)
{
return
false
;
}
}
if
(
paint
)
{
SkPaint
:
:
Style
paintStyle
=
paint
-
>
getStyle
(
)
;
if
(
!
(
paintStyle
=
=
SkPaint
:
:
kFill_Style
|
|
paintStyle
=
=
SkPaint
:
:
kStrokeAndFill_Style
)
)
{
return
false
;
}
if
(
paint
-
>
getMaskFilter
(
)
|
|
paint
-
>
getPathEffect
(
)
|
|
paint
-
>
getImageFilter
(
)
)
{
return
false
;
}
}
return
SkPaintPriv
:
:
Overwrites
(
paint
overrideOpacity
)
;
}
bool
SkCanvas
:
:
predrawNotify
(
bool
willOverwritesEntireSurface
)
{
if
(
fSurfaceBase
)
{
if
(
!
fSurfaceBase
-
>
aboutToDraw
(
willOverwritesEntireSurface
?
SkSurface
:
:
kDiscard_ContentChangeMode
:
SkSurface
:
:
kRetain_ContentChangeMode
)
)
{
return
false
;
}
}
return
true
;
}
bool
SkCanvas
:
:
predrawNotify
(
const
SkRect
*
rect
const
SkPaint
*
paint
SkEnumBitMask
<
PredrawFlags
>
flags
)
{
if
(
fSurfaceBase
)
{
SkSurface
:
:
ContentChangeMode
mode
=
SkSurface
:
:
kRetain_ContentChangeMode
;
if
(
fSurfaceBase
-
>
outstandingImageSnapshot
(
)
)
{
if
(
this
-
>
wouldOverwriteEntireSurface
(
rect
paint
flags
)
)
{
mode
=
SkSurface
:
:
kDiscard_ContentChangeMode
;
}
}
if
(
!
fSurfaceBase
-
>
aboutToDraw
(
mode
)
)
{
return
false
;
}
}
return
true
;
}
SkCanvas
:
:
Layer
:
:
Layer
(
sk_sp
<
SkDevice
>
device
FilterSpan
imageFilters
const
SkPaint
&
paint
bool
isCoverage
)
:
fDevice
(
std
:
:
move
(
device
)
)
fImageFilters
(
imageFilters
.
data
(
)
imageFilters
.
size
(
)
)
fPaint
(
paint
)
fIsCoverage
(
isCoverage
)
fDiscard
(
false
)
{
SkASSERT
(
fDevice
)
;
SkASSERT
(
!
fPaint
.
getImageFilter
(
)
)
;
}
SkCanvas
:
:
BackImage
:
:
BackImage
(
sk_sp
<
SkSpecialImage
>
img
SkIPoint
loc
)
:
fImage
(
img
)
fLoc
(
loc
)
{
}
SkCanvas
:
:
BackImage
:
:
BackImage
(
const
BackImage
&
)
=
default
;
SkCanvas
:
:
BackImage
:
:
BackImage
(
BackImage
&
&
)
=
default
;
SkCanvas
:
:
BackImage
&
SkCanvas
:
:
BackImage
:
:
operator
=
(
const
BackImage
&
)
=
default
;
SkCanvas
:
:
BackImage
:
:
~
BackImage
(
)
=
default
;
SkCanvas
:
:
MCRec
:
:
MCRec
(
SkDevice
*
device
)
:
fDevice
(
device
)
{
SkASSERT
(
fDevice
)
;
}
SkCanvas
:
:
MCRec
:
:
MCRec
(
const
MCRec
*
prev
)
:
fDevice
(
prev
-
>
fDevice
)
fMatrix
(
prev
-
>
fMatrix
)
{
SkASSERT
(
fDevice
)
;
}
SkCanvas
:
:
MCRec
:
:
~
MCRec
(
)
{
}
void
SkCanvas
:
:
MCRec
:
:
newLayer
(
sk_sp
<
SkDevice
>
layerDevice
FilterSpan
filters
const
SkPaint
&
restorePaint
bool
layerIsCoverage
)
{
SkASSERT
(
!
fBackImage
)
;
fLayer
=
std
:
:
make_unique
<
Layer
>
(
std
:
:
move
(
layerDevice
)
filters
restorePaint
layerIsCoverage
)
;
fDevice
=
fLayer
-
>
fDevice
.
get
(
)
;
}
void
SkCanvas
:
:
MCRec
:
:
reset
(
SkDevice
*
device
)
{
SkASSERT
(
!
fLayer
)
;
SkASSERT
(
device
)
;
SkASSERT
(
fDeferredSaveCount
=
=
0
)
;
fDevice
=
device
;
fMatrix
.
setIdentity
(
)
;
}
class
SkCanvas
:
:
AutoUpdateQRBounds
{
public
:
explicit
AutoUpdateQRBounds
(
SkCanvas
*
canvas
)
:
fCanvas
(
canvas
)
{
fCanvas
-
>
validateClip
(
)
;
}
~
AutoUpdateQRBounds
(
)
{
fCanvas
-
>
fQuickRejectBounds
=
fCanvas
-
>
computeDeviceClipBounds
(
)
;
fCanvas
-
>
validateClip
(
)
;
}
private
:
SkCanvas
*
fCanvas
;
AutoUpdateQRBounds
(
AutoUpdateQRBounds
&
&
)
=
delete
;
AutoUpdateQRBounds
(
const
AutoUpdateQRBounds
&
)
=
delete
;
AutoUpdateQRBounds
&
operator
=
(
AutoUpdateQRBounds
&
&
)
=
delete
;
AutoUpdateQRBounds
&
operator
=
(
const
AutoUpdateQRBounds
&
)
=
delete
;
}
;
std
:
:
optional
<
AutoLayerForImageFilter
>
SkCanvas
:
:
aboutToDraw
(
const
SkPaint
&
paint
const
SkRect
*
rawBounds
SkEnumBitMask
<
PredrawFlags
>
flags
)
{
if
(
flags
&
PredrawFlags
:
:
kCheckForOverwrite
)
{
if
(
!
this
-
>
predrawNotify
(
rawBounds
&
paint
flags
)
)
{
return
std
:
:
nullopt
;
}
}
else
{
if
(
!
this
-
>
predrawNotify
(
)
)
{
return
std
:
:
nullopt
;
}
}
const
bool
skipMaskFilterLayer
=
(
flags
&
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
|
|
!
this
-
>
topDevice
(
)
-
>
useDrawCoverageMaskForMaskFilters
(
)
;
return
std
:
:
optional
<
AutoLayerForImageFilter
>
(
std
:
:
in_place
this
paint
rawBounds
skipMaskFilterLayer
)
;
}
std
:
:
optional
<
AutoLayerForImageFilter
>
SkCanvas
:
:
aboutToDraw
(
const
SkPaint
&
paint
const
SkRect
*
rawBounds
)
{
return
this
-
>
aboutToDraw
(
paint
rawBounds
PredrawFlags
:
:
kNone
)
;
}
void
SkCanvas
:
:
resetForNextPicture
(
const
SkIRect
&
bounds
)
{
this
-
>
restoreToCount
(
1
)
;
SkASSERT
(
fRootDevice
-
>
isNoPixelsDevice
(
)
)
;
SkNoPixelsDevice
*
asNoPixelsDevice
=
static_cast
<
SkNoPixelsDevice
*
>
(
fRootDevice
.
get
(
)
)
;
if
(
!
asNoPixelsDevice
-
>
resetForNextPicture
(
bounds
)
)
{
fRootDevice
=
sk_make_sp
<
SkNoPixelsDevice
>
(
bounds
fRootDevice
-
>
surfaceProps
(
)
fRootDevice
-
>
imageInfo
(
)
.
refColorSpace
(
)
)
;
}
fMCRec
-
>
reset
(
fRootDevice
.
get
(
)
)
;
fQuickRejectBounds
=
this
-
>
computeDeviceClipBounds
(
)
;
}
void
SkCanvas
:
:
init
(
sk_sp
<
SkDevice
>
device
)
{
static_assert
(
sizeof
(
MCRec
)
<
=
kMCRecSize
)
;
if
(
!
device
)
{
device
=
sk_make_sp
<
SkNoPixelsDevice
>
(
SkIRect
:
:
MakeEmpty
(
)
fProps
)
;
}
SkASSERT
(
device
)
;
fSaveCount
=
1
;
fMCRec
=
new
(
fMCStack
.
push_back
(
)
)
MCRec
(
device
.
get
(
)
)
;
SkASSERT
(
fProps
.
pixelGeometry
(
)
=
=
device
-
>
surfaceProps
(
)
.
pixelGeometry
(
)
)
;
fSurfaceBase
=
nullptr
;
fRootDevice
=
std
:
:
move
(
device
)
;
fScratchGlyphRunBuilder
=
std
:
:
make_unique
<
sktext
:
:
GlyphRunBuilder
>
(
)
;
fQuickRejectBounds
=
this
-
>
computeDeviceClipBounds
(
)
;
}
SkCanvas
:
:
SkCanvas
(
)
:
fMCStack
(
sizeof
(
MCRec
)
fMCRecStorage
sizeof
(
fMCRecStorage
)
)
{
this
-
>
init
(
nullptr
)
;
}
SkCanvas
:
:
SkCanvas
(
int
width
int
height
const
SkSurfaceProps
*
props
)
:
fMCStack
(
sizeof
(
MCRec
)
fMCRecStorage
sizeof
(
fMCRecStorage
)
)
fProps
(
SkSurfacePropsCopyOrDefault
(
props
)
)
{
this
-
>
init
(
sk_make_sp
<
SkNoPixelsDevice
>
(
SkIRect
:
:
MakeWH
(
std
:
:
max
(
width
0
)
std
:
:
max
(
height
0
)
)
fProps
)
)
;
}
SkCanvas
:
:
SkCanvas
(
const
SkIRect
&
bounds
)
:
fMCStack
(
sizeof
(
MCRec
)
fMCRecStorage
sizeof
(
fMCRecStorage
)
)
{
SkIRect
r
=
bounds
.
isEmpty
(
)
?
SkIRect
:
:
MakeEmpty
(
)
:
bounds
;
this
-
>
init
(
sk_make_sp
<
SkNoPixelsDevice
>
(
r
fProps
)
)
;
}
SkCanvas
:
:
SkCanvas
(
sk_sp
<
SkDevice
>
device
)
:
fMCStack
(
sizeof
(
MCRec
)
fMCRecStorage
sizeof
(
fMCRecStorage
)
)
fProps
(
device
-
>
surfaceProps
(
)
)
{
this
-
>
init
(
std
:
:
move
(
device
)
)
;
}
SkCanvas
:
:
~
SkCanvas
(
)
{
SkDeque
:
:
Iter
iter
(
fMCStack
SkDeque
:
:
Iter
:
:
kFront_IterStart
)
;
for
(
;
;
)
{
MCRec
*
rec
=
(
MCRec
*
)
iter
.
next
(
)
;
if
(
!
rec
)
{
break
;
}
if
(
rec
-
>
fLayer
)
{
rec
-
>
fLayer
-
>
fDiscard
=
true
;
}
}
this
-
>
restoreToCount
(
1
)
;
this
-
>
internalRestore
(
)
;
}
SkSurface
*
SkCanvas
:
:
getSurface
(
)
const
{
return
fSurfaceBase
;
}
SkISize
SkCanvas
:
:
getBaseLayerSize
(
)
const
{
return
this
-
>
rootDevice
(
)
-
>
imageInfo
(
)
.
dimensions
(
)
;
}
SkDevice
*
SkCanvas
:
:
topDevice
(
)
const
{
SkASSERT
(
fMCRec
-
>
fDevice
)
;
return
fMCRec
-
>
fDevice
;
}
bool
SkCanvas
:
:
readPixels
(
const
SkPixmap
&
pm
int
x
int
y
)
{
return
pm
.
addr
(
)
&
&
this
-
>
rootDevice
(
)
-
>
readPixels
(
pm
x
y
)
;
}
bool
SkCanvas
:
:
readPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstP
size_t
rowBytes
int
x
int
y
)
{
return
this
-
>
readPixels
(
{
dstInfo
dstP
rowBytes
}
x
y
)
;
}
bool
SkCanvas
:
:
readPixels
(
const
SkBitmap
&
bm
int
x
int
y
)
{
SkPixmap
pm
;
return
bm
.
peekPixels
(
&
pm
)
&
&
this
-
>
readPixels
(
pm
x
y
)
;
}
bool
SkCanvas
:
:
writePixels
(
const
SkBitmap
&
bitmap
int
x
int
y
)
{
SkPixmap
pm
;
if
(
bitmap
.
peekPixels
(
&
pm
)
)
{
return
this
-
>
writePixels
(
pm
.
info
(
)
pm
.
addr
(
)
pm
.
rowBytes
(
)
x
y
)
;
}
return
false
;
}
bool
SkCanvas
:
:
writePixels
(
const
SkImageInfo
&
srcInfo
const
void
*
pixels
size_t
rowBytes
int
x
int
y
)
{
SkDevice
*
device
=
this
-
>
rootDevice
(
)
;
SkIRect
srcRect
=
SkIRect
:
:
MakeXYWH
(
x
y
srcInfo
.
width
(
)
srcInfo
.
height
(
)
)
;
if
(
!
srcRect
.
intersect
(
{
0
0
device
-
>
width
(
)
device
-
>
height
(
)
}
)
)
{
return
false
;
}
const
bool
completeOverwrite
=
srcRect
.
size
(
)
=
=
device
-
>
imageInfo
(
)
.
dimensions
(
)
;
if
(
!
this
-
>
predrawNotify
(
completeOverwrite
)
)
{
return
false
;
}
return
device
-
>
writePixels
(
{
srcInfo
pixels
rowBytes
}
x
y
)
;
}
void
SkCanvas
:
:
checkForDeferredSave
(
)
{
if
(
fMCRec
-
>
fDeferredSaveCount
>
0
)
{
this
-
>
doSave
(
)
;
}
}
int
SkCanvas
:
:
getSaveCount
(
)
const
{
#
ifdef
SK_DEBUG
int
count
=
0
;
SkDeque
:
:
Iter
iter
(
fMCStack
SkDeque
:
:
Iter
:
:
kFront_IterStart
)
;
for
(
;
;
)
{
const
MCRec
*
rec
=
(
const
MCRec
*
)
iter
.
next
(
)
;
if
(
!
rec
)
{
break
;
}
count
+
=
1
+
rec
-
>
fDeferredSaveCount
;
}
SkASSERT
(
count
=
=
fSaveCount
)
;
#
endif
return
fSaveCount
;
}
int
SkCanvas
:
:
save
(
)
{
fSaveCount
+
=
1
;
fMCRec
-
>
fDeferredSaveCount
+
=
1
;
return
this
-
>
getSaveCount
(
)
-
1
;
}
void
SkCanvas
:
:
doSave
(
)
{
this
-
>
willSave
(
)
;
SkASSERT
(
fMCRec
-
>
fDeferredSaveCount
>
0
)
;
fMCRec
-
>
fDeferredSaveCount
-
=
1
;
this
-
>
internalSave
(
)
;
}
void
SkCanvas
:
:
restore
(
)
{
if
(
fMCRec
-
>
fDeferredSaveCount
>
0
)
{
SkASSERT
(
fSaveCount
>
1
)
;
fSaveCount
-
=
1
;
fMCRec
-
>
fDeferredSaveCount
-
=
1
;
}
else
{
if
(
fMCStack
.
count
(
)
>
1
)
{
this
-
>
willRestore
(
)
;
SkASSERT
(
fSaveCount
>
1
)
;
fSaveCount
-
=
1
;
this
-
>
internalRestore
(
)
;
this
-
>
didRestore
(
)
;
}
}
}
void
SkCanvas
:
:
restoreToCount
(
int
count
)
{
if
(
count
<
1
)
{
count
=
1
;
}
int
n
=
this
-
>
getSaveCount
(
)
-
count
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
this
-
>
restore
(
)
;
}
}
void
SkCanvas
:
:
internalSave
(
)
{
fMCRec
=
new
(
fMCStack
.
push_back
(
)
)
MCRec
(
fMCRec
)
;
this
-
>
topDevice
(
)
-
>
pushClipStack
(
)
;
}
int
SkCanvas
:
:
saveLayer
(
const
SkRect
*
bounds
const
SkPaint
*
paint
)
{
return
this
-
>
saveLayer
(
SaveLayerRec
(
bounds
paint
0
)
)
;
}
int
SkCanvas
:
:
saveLayer
(
const
SaveLayerRec
&
rec
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
rec
.
fPaint
&
&
rec
.
fPaint
-
>
nothingToDraw
(
)
)
{
this
-
>
save
(
)
;
this
-
>
clipRect
(
{
0
0
0
0
}
)
;
}
else
{
SaveLayerStrategy
strategy
=
this
-
>
getSaveLayerStrategy
(
rec
)
;
fSaveCount
+
=
1
;
this
-
>
internalSaveLayer
(
rec
strategy
)
;
}
return
this
-
>
getSaveCount
(
)
-
1
;
}
int
SkCanvas
:
:
only_axis_aligned_saveBehind
(
const
SkRect
*
bounds
)
{
if
(
bounds
&
&
!
this
-
>
getLocalClipBounds
(
)
.
intersects
(
*
bounds
)
)
{
this
-
>
save
(
)
;
}
else
{
bool
doTheWork
=
this
-
>
onDoSaveBehind
(
bounds
)
;
fSaveCount
+
=
1
;
this
-
>
internalSave
(
)
;
if
(
doTheWork
)
{
this
-
>
internalSaveBehind
(
bounds
)
;
}
}
return
this
-
>
getSaveCount
(
)
-
1
;
}
static
void
check_drawdevice_colorspaces
(
SkDevice
*
src
SkDevice
*
dst
)
{
SkASSERT
(
dst
&
&
(
!
src
|
|
dst
-
>
imageInfo
(
)
.
colorSpace
(
)
=
=
src
-
>
imageInfo
(
)
.
colorSpace
(
)
)
)
;
}
static
skif
:
:
ParameterSpace
<
SkPoint
>
compute_decomposition_center
(
const
SkMatrix
&
dstToLocal
std
:
:
optional
<
skif
:
:
ParameterSpace
<
SkRect
>
>
contentBounds
const
skif
:
:
DeviceSpace
<
SkIRect
>
&
targetOutput
)
{
SkRect
rect
=
contentBounds
?
SkRect
(
*
contentBounds
)
:
SkRect
:
:
Make
(
SkIRect
(
targetOutput
)
)
;
SkPoint
center
=
{
rect
.
centerX
(
)
rect
.
centerY
(
)
}
;
if
(
!
contentBounds
)
{
dstToLocal
.
mapPoints
(
&
center
1
)
;
}
return
skif
:
:
ParameterSpace
<
SkPoint
>
(
center
)
;
}
struct
FilterToSpan
{
FilterToSpan
(
const
SkImageFilter
*
filter
)
:
fFilter
(
sk_ref_sp
(
filter
)
)
{
}
operator
SkCanvas
:
:
FilterSpan
(
)
{
return
fFilter
?
SkCanvas
:
:
FilterSpan
{
&
fFilter
1
}
:
SkCanvas
:
:
FilterSpan
{
}
;
}
sk_sp
<
SkImageFilter
>
fFilter
;
}
;
static
std
:
:
optional
<
std
:
:
pair
<
skif
:
:
Mapping
skif
:
:
LayerSpace
<
SkIRect
>
>
>
get_layer_mapping_and_bounds
(
SkCanvas
:
:
FilterSpan
filters
const
SkMatrix
&
localToDst
const
skif
:
:
DeviceSpace
<
SkIRect
>
&
targetOutput
std
:
:
optional
<
skif
:
:
ParameterSpace
<
SkRect
>
>
contentBounds
=
{
}
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
bool
mustCoverDst
=
true
#
endif
SkScalar
scaleFactor
=
1
.
0f
)
{
SkMatrix
dstToLocal
;
if
(
!
localToDst
.
isFinite
(
)
|
|
!
localToDst
.
invert
(
&
dstToLocal
)
)
{
return
{
}
;
}
skif
:
:
ParameterSpace
<
SkPoint
>
center
=
compute_decomposition_center
(
dstToLocal
contentBounds
targetOutput
)
;
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
if
(
mustCoverDst
)
{
contentBounds
.
reset
(
)
;
}
#
endif
skif
:
:
Mapping
mapping
;
skif
:
:
MatrixCapability
capability
=
skif
:
:
MatrixCapability
:
:
kComplex
;
for
(
const
sk_sp
<
SkImageFilter
>
&
filter
:
filters
)
{
if
(
filter
)
{
capability
=
std
:
:
min
(
capability
as_IFB
(
filter
)
-
>
getCTMCapability
(
)
)
;
}
}
if
(
!
mapping
.
decomposeCTM
(
localToDst
capability
center
)
)
{
return
{
}
;
}
if
(
scaleFactor
!
=
1
.
0f
&
&
!
mapping
.
adjustLayerSpace
(
SkMatrix
:
:
Scale
(
scaleFactor
scaleFactor
)
)
)
{
return
{
}
;
}
static
const
int
kMinDimThreshold
=
2048
;
int
maxLayerDim
=
std
:
:
max
(
Sk64_pin_to_s32
(
2
*
std
:
:
max
(
SkIRect
(
targetOutput
)
.
width64
(
)
SkIRect
(
targetOutput
)
.
height64
(
)
)
)
kMinDimThreshold
)
;
auto
baseLayerBounds
=
mapping
.
deviceToLayer
(
targetOutput
)
;
if
(
contentBounds
)
{
skif
:
:
LayerSpace
<
SkIRect
>
knownBounds
=
mapping
.
paramToLayer
(
*
contentBounds
)
.
roundOut
(
)
;
if
(
!
baseLayerBounds
.
intersect
(
knownBounds
)
)
{
baseLayerBounds
=
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
skif
:
:
LayerSpace
<
SkIRect
>
layerBounds
;
if
(
!
filters
.
empty
(
)
)
{
layerBounds
=
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Union
(
filters
.
size
(
)
[
&
]
(
int
i
)
{
return
filters
[
i
]
?
as_IFB
(
filters
[
i
]
)
-
>
getInputBounds
(
mapping
targetOutput
contentBounds
)
:
baseLayerBounds
;
}
)
;
if
(
layerBounds
.
width
(
)
>
maxLayerDim
|
|
layerBounds
.
height
(
)
>
maxLayerDim
)
{
skif
:
:
Mapping
idealMapping
{
mapping
.
layerMatrix
(
)
}
;
for
(
const
sk_sp
<
SkImageFilter
>
&
filter
:
filters
)
{
if
(
filter
)
{
auto
idealLayerBounds
=
as_IFB
(
filter
)
-
>
getInputBounds
(
idealMapping
targetOutput
contentBounds
)
;
maxLayerDim
=
std
:
:
max
(
std
:
:
max
(
idealLayerBounds
.
width
(
)
idealLayerBounds
.
height
(
)
)
maxLayerDim
)
;
}
}
}
}
else
{
if
(
baseLayerBounds
.
isEmpty
(
)
)
{
return
{
}
;
}
layerBounds
=
baseLayerBounds
;
}
if
(
layerBounds
.
width
(
)
>
maxLayerDim
|
|
layerBounds
.
height
(
)
>
maxLayerDim
)
{
skif
:
:
LayerSpace
<
SkIRect
>
newLayerBounds
(
SkIRect
:
:
MakeWH
(
std
:
:
min
(
layerBounds
.
width
(
)
maxLayerDim
)
std
:
:
min
(
layerBounds
.
height
(
)
maxLayerDim
)
)
)
;
SkMatrix
adjust
=
SkMatrix
:
:
MakeRectToRect
(
SkRect
:
:
Make
(
SkIRect
(
layerBounds
)
)
SkRect
:
:
Make
(
SkIRect
(
newLayerBounds
)
)
SkMatrix
:
:
kFill_ScaleToFit
)
;
if
(
!
mapping
.
adjustLayerSpace
(
adjust
)
)
{
return
{
}
;
}
else
{
layerBounds
=
newLayerBounds
;
}
}
return
std
:
:
make_pair
(
mapping
layerBounds
)
;
}
static
SkColorType
image_filter_color_type
(
SkImageInfo
dstInfo
)
{
if
(
dstInfo
.
bytesPerPixel
(
)
<
=
4
&
&
dstInfo
.
colorType
(
)
!
=
kRGBA_8888_SkColorType
&
&
dstInfo
.
colorType
(
)
!
=
kBGRA_8888_SkColorType
)
{
return
kN32_SkColorType
;
}
else
{
return
dstInfo
.
colorType
(
)
;
}
}
#
if
!
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
static
skif
:
:
FilterResult
apply_alpha_and_colorfilter
(
const
skif
:
:
Context
&
ctx
const
skif
:
:
FilterResult
&
image
const
SkPaint
&
paint
)
{
skif
:
:
FilterResult
result
=
image
;
if
(
paint
.
getAlphaf
(
)
<
1
.
f
)
{
result
=
result
.
applyColorFilter
(
ctx
SkColorFilters
:
:
Blend
(
paint
.
getColor4f
(
)
nullptr
SkBlendMode
:
:
kDstIn
)
)
;
}
if
(
paint
.
getColorFilter
(
)
)
{
result
=
result
.
applyColorFilter
(
ctx
paint
.
refColorFilter
(
)
)
;
}
return
result
;
}
void
SkCanvas
:
:
internalDrawDeviceWithFilter
(
SkDevice
*
src
SkDevice
*
dst
FilterSpan
filters
const
SkPaint
&
paint
DeviceCompatibleWithFilter
compat
SkScalar
scaleFactor
bool
srcIsCoverageLayer
)
{
SkASSERT
(
dst
)
;
check_drawdevice_colorspaces
(
src
dst
)
;
sk_sp
<
SkColorSpace
>
filterColorSpace
=
dst
-
>
imageInfo
(
)
.
refColorSpace
(
)
;
const
SkColorType
filterColorType
=
srcIsCoverageLayer
?
kAlpha_8_SkColorType
:
image_filter_color_type
(
dst
-
>
imageInfo
(
)
)
;
SkMatrix
localToSrc
=
src
?
(
src
-
>
globalToDevice
(
)
*
fMCRec
-
>
fMatrix
)
.
asM33
(
)
:
SkMatrix
:
:
I
(
)
;
SkISize
srcDims
=
src
?
src
-
>
imageInfo
(
)
.
dimensions
(
)
:
SkISize
:
:
Make
(
0
0
)
;
skif
:
:
LayerSpace
<
SkMatrix
>
srcToLayer
;
skif
:
:
Mapping
mapping
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
;
skif
:
:
DeviceSpace
<
SkIRect
>
outputBounds
{
dst
-
>
devClipBounds
(
)
}
;
if
(
compat
=
=
DeviceCompatibleWithFilter
:
:
kYes
)
{
SkASSERT
(
src
)
;
SkASSERT
(
scaleFactor
=
=
1
.
0f
)
;
SkASSERT
(
!
srcDims
.
isEmpty
(
)
)
;
mapping
=
skif
:
:
Mapping
(
src
-
>
getRelativeTransform
(
*
dst
)
dst
-
>
getRelativeTransform
(
*
src
)
localToSrc
)
;
requiredInput
=
skif
:
:
LayerSpace
<
SkIRect
>
(
SkIRect
:
:
MakeSize
(
srcDims
)
)
;
srcToLayer
=
skif
:
:
LayerSpace
<
SkMatrix
>
(
SkMatrix
:
:
I
(
)
)
;
}
else
{
auto
mappingAndBounds
=
get_layer_mapping_and_bounds
(
filters
dst
-
>
localToDevice
(
)
outputBounds
{
}
SkTPin
(
scaleFactor
0
.
f
1
.
f
)
)
;
if
(
!
mappingAndBounds
)
{
return
;
}
std
:
:
tie
(
mapping
requiredInput
)
=
*
mappingAndBounds
;
if
(
src
)
{
if
(
!
requiredInput
.
isEmpty
(
)
)
{
SkMatrix
srcToLocal
;
if
(
!
localToSrc
.
invert
(
&
srcToLocal
)
)
{
return
;
}
srcToLayer
=
skif
:
:
LayerSpace
<
SkMatrix
>
(
SkMatrix
:
:
Concat
(
mapping
.
layerMatrix
(
)
srcToLocal
)
)
;
}
}
else
{
requiredInput
=
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
auto
backend
=
dst
-
>
createImageFilteringBackend
(
src
?
src
-
>
surfaceProps
(
)
:
dst
-
>
surfaceProps
(
)
filterColorType
)
;
skif
:
:
Stats
stats
;
skif
:
:
Context
ctx
{
std
:
:
move
(
backend
)
mapping
requiredInput
skif
:
:
FilterResult
{
}
filterColorSpace
.
get
(
)
&
stats
}
;
skif
:
:
FilterResult
source
;
if
(
src
&
&
!
requiredInput
.
isEmpty
(
)
)
{
skif
:
:
LayerSpace
<
SkIRect
>
srcSubset
;
if
(
!
srcToLayer
.
inverseMapRect
(
requiredInput
&
srcSubset
)
)
{
return
;
}
ctx
.
markNewSurface
(
)
;
auto
availSrc
=
skif
:
:
LayerSpace
<
SkIRect
>
(
src
-
>
size
(
)
)
.
relevantSubset
(
srcSubset
SkTileMode
:
:
kClamp
)
;
if
(
SkMatrix
(
srcToLayer
)
.
isScaleTranslate
(
)
)
{
auto
requiredSubset
=
srcToLayer
.
mapRect
(
availSrc
)
;
if
(
requiredSubset
.
width
(
)
=
=
availSrc
.
width
(
)
&
&
requiredSubset
.
height
(
)
=
=
availSrc
.
height
(
)
)
{
source
=
{
src
-
>
snapSpecial
(
SkIRect
(
availSrc
)
)
requiredSubset
.
topLeft
(
)
}
;
}
else
{
SkASSERT
(
compat
=
=
DeviceCompatibleWithFilter
:
:
kUnknown
)
;
source
=
{
src
-
>
snapSpecialScaled
(
SkIRect
(
availSrc
)
SkISize
(
requiredSubset
.
size
(
)
)
)
requiredSubset
.
topLeft
(
)
}
;
ctx
.
markNewSurface
(
)
;
}
}
if
(
compat
=
=
DeviceCompatibleWithFilter
:
:
kYes
)
{
#
if
defined
(
SK_DONT_PAD_LAYER_IMAGES
)
source
=
source
.
applyCrop
(
ctx
source
.
layerBounds
(
)
SkTileMode
:
:
kClamp
)
;
#
else
source
=
source
.
insetForSaveLayer
(
)
;
#
endif
}
else
if
(
source
)
{
source
=
source
.
applyCrop
(
ctx
source
.
layerBounds
(
)
SkTileMode
:
:
kClamp
)
;
}
else
if
(
!
requiredInput
.
isEmpty
(
)
)
{
source
=
{
src
-
>
snapSpecial
(
SkIRect
(
availSrc
)
)
availSrc
.
topLeft
(
)
}
;
source
=
source
.
applyCrop
(
ctx
.
withNewDesiredOutput
(
srcSubset
)
source
.
layerBounds
(
)
SkTileMode
:
:
kClamp
)
.
applyTransform
(
ctx
srcToLayer
SkFilterMode
:
:
kLinear
)
;
}
}
ctx
=
ctx
.
withNewDesiredOutput
(
mapping
.
deviceToLayer
(
outputBounds
)
)
.
withNewSource
(
source
)
;
sk_sp
<
SkImageFilter
>
nullFilter
;
FilterSpan
filtersOrNull
=
filters
.
empty
(
)
?
FilterSpan
{
&
nullFilter
1
}
:
filters
;
for
(
const
sk_sp
<
SkImageFilter
>
&
filter
:
filtersOrNull
)
{
auto
result
=
filter
?
as_IFB
(
filter
)
-
>
filterImage
(
ctx
)
:
source
;
if
(
srcIsCoverageLayer
)
{
SkASSERT
(
dst
-
>
useDrawCoverageMaskForMaskFilters
(
)
)
;
auto
[
coverageMask
origin
]
=
result
.
imageAndOffset
(
ctx
)
;
if
(
coverageMask
)
{
SkMatrix
deviceMatrixWithOffset
=
mapping
.
layerToDevice
(
)
;
deviceMatrixWithOffset
.
preTranslate
(
origin
.
x
(
)
origin
.
y
(
)
)
;
dst
-
>
drawCoverageMask
(
coverageMask
.
get
(
)
deviceMatrixWithOffset
result
.
sampling
(
)
paint
)
;
}
}
else
{
result
=
apply_alpha_and_colorfilter
(
ctx
result
paint
)
;
result
.
draw
(
ctx
dst
paint
.
getBlender
(
)
)
;
}
}
stats
.
reportStats
(
)
;
}
#
else
static
bool
can_layer_be_drawn_as_sprite
(
const
SkMatrix
&
matrix
const
SkISize
&
size
)
{
SkPaint
paint
;
paint
.
setAntiAlias
(
true
)
;
SkSamplingOptions
sampling
{
SkFilterMode
:
:
kLinear
}
;
return
SkTreatAsSprite
(
matrix
size
sampling
paint
.
isAntiAlias
(
)
)
;
}
void
SkCanvas
:
:
internalDrawDeviceWithFilter
(
SkDevice
*
src
SkDevice
*
dst
FilterSpan
filters
const
SkPaint
&
paint
DeviceCompatibleWithFilter
compat
SkScalar
scaleFactor
bool
srcIsCoverageLayer
)
{
const
SkImageFilter
*
filter
=
filters
.
empty
(
)
?
nullptr
:
filters
.
front
(
)
.
get
(
)
;
(
void
)
srcIsCoverageLayer
;
check_drawdevice_colorspaces
(
src
dst
)
;
sk_sp
<
SkColorSpace
>
filterColorSpace
=
dst
-
>
imageInfo
(
)
.
refColorSpace
(
)
;
const
SkColorType
filterColorType
=
image_filter_color_type
(
dst
-
>
imageInfo
(
)
)
;
SkMatrix
localToSrc
=
(
src
-
>
globalToDevice
(
)
*
fMCRec
-
>
fMatrix
)
.
asM33
(
)
;
SkISize
srcDims
=
src
-
>
imageInfo
(
)
.
dimensions
(
)
;
bool
needsIntermediateImage
=
false
;
SkMatrix
srcToIntermediate
;
skif
:
:
Mapping
mapping
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
;
if
(
compat
=
=
DeviceCompatibleWithFilter
:
:
kYes
)
{
SkASSERT
(
scaleFactor
=
=
1
.
0f
)
;
mapping
=
skif
:
:
Mapping
(
src
-
>
getRelativeTransform
(
*
dst
)
dst
-
>
getRelativeTransform
(
*
src
)
localToSrc
)
;
requiredInput
=
skif
:
:
LayerSpace
<
SkIRect
>
(
SkIRect
:
:
MakeSize
(
srcDims
)
)
;
SkASSERT
(
!
requiredInput
.
isEmpty
(
)
)
;
}
else
{
auto
mappingAndBounds
=
get_layer_mapping_and_bounds
(
filters
dst
-
>
localToDevice
(
)
skif
:
:
DeviceSpace
<
SkIRect
>
(
dst
-
>
devClipBounds
(
)
)
{
}
true
SkTPin
(
scaleFactor
0
.
f
1
.
f
)
)
;
if
(
!
mappingAndBounds
)
{
return
;
}
std
:
:
tie
(
mapping
requiredInput
)
=
*
mappingAndBounds
;
if
(
!
requiredInput
.
isEmpty
(
)
)
{
if
(
!
localToSrc
.
invert
(
&
srcToIntermediate
)
)
{
return
;
}
srcToIntermediate
.
postConcat
(
mapping
.
layerMatrix
(
)
)
;
if
(
can_layer_be_drawn_as_sprite
(
srcToIntermediate
srcDims
)
)
{
skif
:
:
LayerSpace
<
SkIPoint
>
srcOrigin
(
{
(
int
)
srcToIntermediate
.
getTranslateX
(
)
(
int
)
srcToIntermediate
.
getTranslateY
(
)
}
)
;
mapping
.
applyOrigin
(
srcOrigin
)
;
requiredInput
.
offset
(
-
srcOrigin
)
;
}
else
{
needsIntermediateImage
=
true
;
}
}
}
sk_sp
<
SkSpecialImage
>
filterInput
;
if
(
!
needsIntermediateImage
)
{
skif
:
:
LayerSpace
<
SkIRect
>
srcSubset
(
SkIRect
:
:
MakeSize
(
srcDims
)
)
;
if
(
srcSubset
.
intersect
(
requiredInput
)
)
{
filterInput
=
src
-
>
snapSpecial
(
SkIRect
(
srcSubset
)
)
;
mapping
.
applyOrigin
(
srcSubset
.
topLeft
(
)
)
;
}
}
else
{
SkASSERT
(
compat
=
=
DeviceCompatibleWithFilter
:
:
kUnknown
)
;
SkRect
srcRect
;
if
(
!
SkMatrixPriv
:
:
InverseMapRect
(
srcToIntermediate
&
srcRect
SkRect
:
:
Make
(
SkIRect
(
requiredInput
)
)
)
)
{
return
;
}
if
(
!
srcRect
.
intersect
(
SkRect
:
:
Make
(
srcDims
)
)
)
{
return
;
}
SkIRect
srcSubset
=
skif
:
:
RoundOut
(
srcRect
)
;
if
(
srcToIntermediate
.
isScaleTranslate
(
)
)
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredSubset
(
skif
:
:
RoundOut
(
srcToIntermediate
.
mapRect
(
srcRect
)
)
)
;
filterInput
=
src
-
>
snapSpecialScaled
(
srcSubset
{
requiredSubset
.
width
(
)
requiredSubset
.
height
(
)
}
)
;
if
(
filterInput
)
{
mapping
.
applyOrigin
(
requiredSubset
.
topLeft
(
)
)
;
}
}
if
(
!
filterInput
)
{
sk_sp
<
SkSpecialImage
>
srcImage
=
src
-
>
snapSpecial
(
srcSubset
)
;
if
(
!
srcImage
)
{
return
;
}
SkDevice
:
:
CreateInfo
info
(
SkImageInfo
:
:
Make
(
requiredInput
.
width
(
)
requiredInput
.
height
(
)
filterColorType
kPremul_SkAlphaType
filterColorSpace
)
SkPixelGeometry
:
:
kUnknown_SkPixelGeometry
fAllocator
.
get
(
)
)
;
sk_sp
<
SkDevice
>
intermediateDevice
=
src
-
>
createDevice
(
info
&
paint
)
;
if
(
!
intermediateDevice
)
{
return
;
}
intermediateDevice
-
>
setOrigin
(
SkM44
(
srcToIntermediate
)
requiredInput
.
left
(
)
requiredInput
.
top
(
)
)
;
SkPaint
imageFill
;
imageFill
.
setShader
(
srcImage
-
>
asShader
(
SkTileMode
:
:
kClamp
SkFilterMode
:
:
kLinear
SkMatrix
:
:
Translate
(
srcSubset
.
topLeft
(
)
)
)
)
;
intermediateDevice
-
>
drawPaint
(
imageFill
)
;
filterInput
=
intermediateDevice
-
>
snapSpecial
(
)
;
mapping
.
applyOrigin
(
requiredInput
.
topLeft
(
)
)
;
}
}
if
(
filterInput
|
|
requiredInput
.
isEmpty
(
)
)
{
const
bool
useNN
=
can_layer_be_drawn_as_sprite
(
mapping
.
layerToDevice
(
)
dst
-
>
devClipBounds
(
)
.
size
(
)
)
;
SkSamplingOptions
sampling
{
useNN
?
SkFilterMode
:
:
kNearest
:
SkFilterMode
:
:
kLinear
}
;
if
(
filter
)
{
dst
-
>
drawFilteredImage
(
mapping
filterInput
.
get
(
)
filterColorType
filter
sampling
paint
)
;
}
else
{
SkASSERT
(
filterInput
)
;
dst
-
>
drawSpecial
(
filterInput
.
get
(
)
mapping
.
layerToDevice
(
)
sampling
paint
)
;
}
}
}
static
const
SkImageFilter
*
optimize_layer_filter
(
const
SkImageFilter
*
filter
SkPaint
*
paint
)
{
SkASSERT
(
paint
)
;
SkColorFilter
*
cf
;
if
(
filter
&
&
filter
-
>
isColorFilterNode
(
&
cf
)
)
{
sk_sp
<
SkColorFilter
>
inner
(
cf
)
;
if
(
paint
-
>
getAlphaf
(
)
<
1
.
f
)
{
inner
=
SkColorFilters
:
:
Compose
(
SkColorFilters
:
:
Blend
(
paint
-
>
getColor4f
(
)
nullptr
SkBlendMode
:
:
kDstIn
)
std
:
:
move
(
inner
)
)
;
paint
-
>
setAlphaf
(
1
.
f
)
;
}
paint
-
>
setColorFilter
(
SkColorFilters
:
:
Compose
(
paint
-
>
refColorFilter
(
)
std
:
:
move
(
inner
)
)
)
;
SkASSERT
(
filter
-
>
countInputs
(
)
=
=
1
)
;
return
filter
-
>
getInput
(
0
)
;
}
else
{
return
filter
;
}
}
static
bool
must_cover_prior_device
(
const
SkImageFilter
*
backdrop
const
SkPaint
&
restorePaint
)
{
const
SkColorFilter
*
cf
=
restorePaint
.
getColorFilter
(
)
;
if
(
backdrop
|
|
(
cf
&
&
as_CFB
(
cf
)
-
>
affectsTransparentBlack
(
)
)
)
{
return
true
;
}
if
(
auto
blendMode
=
restorePaint
.
asBlendMode
(
)
)
{
SkBlendModeCoeff
src
dst
;
if
(
SkBlendMode_AsCoeff
(
*
blendMode
&
src
&
dst
)
)
{
return
dst
!
=
SkBlendModeCoeff
:
:
kOne
&
&
dst
!
=
SkBlendModeCoeff
:
:
kISA
&
&
dst
!
=
SkBlendModeCoeff
:
:
kISC
;
}
else
{
return
false
;
}
}
else
{
return
true
;
}
}
#
endif
void
SkCanvas
:
:
internalSaveLayer
(
const
SaveLayerRec
&
rec
SaveLayerStrategy
strategy
bool
coverageOnly
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
internalSave
(
)
;
if
(
this
-
>
isClipEmpty
(
)
)
{
return
;
}
SkPaint
restorePaint
(
rec
.
fPaint
?
*
rec
.
fPaint
:
SkPaint
(
)
)
;
restorePaint
.
setStyle
(
SkPaint
:
:
kFill_Style
)
;
restorePaint
.
setPathEffect
(
nullptr
)
;
restorePaint
.
setMaskFilter
(
nullptr
)
;
restorePaint
.
setImageFilter
(
nullptr
)
;
restorePaint
.
setAntiAlias
(
true
)
;
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
sk_sp
<
SkImageFilter
>
paintFilter
=
sk_ref_sp
(
optimize_layer_filter
(
rec
.
fPaint
?
rec
.
fPaint
-
>
getImageFilter
(
)
:
nullptr
&
restorePaint
)
)
;
SkASSERT
(
rec
.
fFilters
.
empty
(
)
)
;
FilterSpan
filters
=
paintFilter
?
FilterSpan
{
&
paintFilter
1
}
:
FilterSpan
{
}
;
SkDevice
*
priorDevice
=
this
-
>
topDevice
(
)
;
skif
:
:
Mapping
newLayerMapping
;
skif
:
:
LayerSpace
<
SkIRect
>
layerBounds
;
std
:
:
optional
<
skif
:
:
ParameterSpace
<
SkRect
>
>
contentBounds
;
if
(
rec
.
fBounds
)
{
contentBounds
=
skif
:
:
ParameterSpace
<
SkRect
>
(
*
rec
.
fBounds
)
;
}
auto
mappingAndBounds
=
get_layer_mapping_and_bounds
(
filters
priorDevice
-
>
localToDevice
(
)
skif
:
:
DeviceSpace
<
SkIRect
>
(
priorDevice
-
>
devClipBounds
(
)
)
contentBounds
must_cover_prior_device
(
rec
.
fBackdrop
restorePaint
)
)
;
#
else
sk_sp
<
SkImageFilter
>
paintFilter
=
rec
.
fPaint
?
rec
.
fPaint
-
>
refImageFilter
(
)
:
nullptr
;
FilterSpan
filters
=
paintFilter
?
FilterSpan
{
&
paintFilter
1
}
:
rec
.
fFilters
;
if
(
filters
.
size
(
)
>
kMaxFiltersPerLayer
)
{
filters
=
filters
.
first
(
kMaxFiltersPerLayer
)
;
}
const
SkColorFilter
*
cf
=
restorePaint
.
getColorFilter
(
)
;
const
SkBlender
*
blender
=
restorePaint
.
getBlender
(
)
;
bool
filtersPriorDevice
=
rec
.
fBackdrop
;
#
if
!
defined
(
SK_LEGACY_INITWITHPREV_LAYER_SIZING
)
filtersPriorDevice
|
=
(
(
rec
.
fSaveLayerFlags
&
kInitWithPrevious_SaveLayerFlag
)
&
&
(
!
filters
.
empty
(
)
|
|
cf
|
|
blender
|
|
restorePaint
.
getAlphaf
(
)
<
1
.
f
)
)
;
#
endif
const
bool
drawDeviceMustFillClip
=
filters
.
empty
(
)
&
&
(
(
cf
&
&
as_CFB
(
cf
)
-
>
affectsTransparentBlack
(
)
)
|
|
(
blender
&
&
as_BB
(
blender
)
-
>
affectsTransparentBlack
(
)
)
)
;
const
bool
trivialRestore
=
!
filtersPriorDevice
&
&
!
drawDeviceMustFillClip
;
SkDevice
*
priorDevice
=
this
-
>
topDevice
(
)
;
skif
:
:
Mapping
newLayerMapping
;
skif
:
:
LayerSpace
<
SkIRect
>
layerBounds
;
skif
:
:
DeviceSpace
<
SkIRect
>
outputBounds
{
priorDevice
-
>
devClipBounds
(
)
}
;
std
:
:
optional
<
skif
:
:
ParameterSpace
<
SkRect
>
>
contentBounds
;
if
(
rec
.
fBounds
&
&
trivialRestore
)
{
contentBounds
=
skif
:
:
ParameterSpace
<
SkRect
>
(
*
rec
.
fBounds
)
;
}
auto
mappingAndBounds
=
get_layer_mapping_and_bounds
(
filters
priorDevice
-
>
localToDevice
(
)
outputBounds
contentBounds
)
;
#
endif
auto
abortLayer
=
[
this
]
(
)
{
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipRect
(
SkRect
:
:
MakeEmpty
(
)
SkClipOp
:
:
kIntersect
false
)
;
}
;
if
(
!
mappingAndBounds
)
{
abortLayer
(
)
;
return
;
}
std
:
:
tie
(
newLayerMapping
layerBounds
)
=
*
mappingAndBounds
;
if
(
layerBounds
.
isEmpty
(
)
)
{
if
(
!
filters
.
empty
(
)
&
&
!
priorDevice
-
>
isNoPixelsDevice
(
)
)
{
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
const
SkImageFilter
*
filter
=
filters
.
empty
(
)
?
nullptr
:
filters
.
front
(
)
.
get
(
)
;
skif
:
:
ParameterSpace
<
SkRect
>
emptyInput
{
SkRect
:
:
MakeEmpty
(
)
}
;
std
:
:
optional
<
skif
:
:
DeviceSpace
<
SkIRect
>
>
output
=
as_IFB
(
filter
)
-
>
getOutputBounds
(
newLayerMapping
emptyInput
)
;
if
(
!
output
|
|
SkIRect
:
:
Intersects
(
SkIRect
(
*
output
)
priorDevice
-
>
devClipBounds
(
)
)
)
{
SkISize
targetSize
=
output
?
SkIRect
(
*
output
)
.
size
(
)
:
priorDevice
-
>
devClipBounds
(
)
.
size
(
)
;
const
bool
useNN
=
can_layer_be_drawn_as_sprite
(
newLayerMapping
.
layerToDevice
(
)
targetSize
)
;
SkSamplingOptions
sampling
{
useNN
?
SkFilterMode
:
:
kNearest
:
SkFilterMode
:
:
kLinear
}
;
priorDevice
-
>
drawFilteredImage
(
newLayerMapping
nullptr
image_filter_color_type
(
priorDevice
-
>
imageInfo
(
)
)
filter
sampling
restorePaint
)
;
}
#
else
this
-
>
internalDrawDeviceWithFilter
(
nullptr
priorDevice
filters
restorePaint
DeviceCompatibleWithFilter
:
:
kUnknown
)
;
#
endif
}
abortLayer
(
)
;
return
;
}
else
{
#
if
!
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
&
&
!
defined
(
SK_DONT_PAD_LAYER_IMAGES
)
if
(
!
filters
.
empty
(
)
)
{
layerBounds
.
outset
(
skif
:
:
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
}
#
endif
}
sk_sp
<
SkDevice
>
newDevice
;
if
(
strategy
=
=
kFullLayer_SaveLayerStrategy
)
{
SkASSERT
(
!
layerBounds
.
isEmpty
(
)
)
;
SkColorType
layerColorType
;
if
(
coverageOnly
)
{
layerColorType
=
kAlpha_8_SkColorType
;
}
else
{
layerColorType
=
SkToBool
(
rec
.
fSaveLayerFlags
&
kF16ColorType
)
?
kRGBA_F16_SkColorType
:
image_filter_color_type
(
priorDevice
-
>
imageInfo
(
)
)
;
}
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
layerBounds
.
width
(
)
layerBounds
.
height
(
)
layerColorType
kPremul_SkAlphaType
priorDevice
-
>
imageInfo
(
)
.
refColorSpace
(
)
)
;
SkPixelGeometry
geo
=
rec
.
fSaveLayerFlags
&
kPreserveLCDText_SaveLayerFlag
?
fProps
.
pixelGeometry
(
)
:
kUnknown_SkPixelGeometry
;
const
auto
createInfo
=
SkDevice
:
:
CreateInfo
(
info
geo
fAllocator
.
get
(
)
)
;
newDevice
=
priorDevice
-
>
createDevice
(
createInfo
rec
.
fPaint
)
;
}
bool
initBackdrop
=
(
rec
.
fSaveLayerFlags
&
kInitWithPrevious_SaveLayerFlag
)
|
|
rec
.
fBackdrop
;
if
(
!
newDevice
)
{
newDevice
=
sk_make_sp
<
SkNoPixelsDevice
>
(
SkIRect
:
:
MakeWH
(
layerBounds
.
width
(
)
layerBounds
.
height
(
)
)
fProps
this
-
>
imageInfo
(
)
.
refColorSpace
(
)
)
;
initBackdrop
=
false
;
}
#
if
!
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
&
&
!
defined
(
SK_DONT_PAD_LAYER_IMAGES
)
if
(
!
filters
.
empty
(
)
)
{
newDevice
-
>
clipRect
(
SkRect
:
:
Make
(
newDevice
-
>
devClipBounds
(
)
.
makeInset
(
1
1
)
)
SkClipOp
:
:
kIntersect
false
)
;
}
#
endif
newDevice
-
>
setDeviceCoordinateSystem
(
priorDevice
-
>
deviceToGlobal
(
)
*
SkM44
(
newLayerMapping
.
layerToDevice
(
)
)
SkM44
(
newLayerMapping
.
deviceToLayer
(
)
)
*
priorDevice
-
>
globalToDevice
(
)
SkM44
(
newLayerMapping
.
layerMatrix
(
)
)
layerBounds
.
left
(
)
layerBounds
.
top
(
)
)
;
if
(
initBackdrop
)
{
SkASSERT
(
!
coverageOnly
)
;
SkPaint
backdropPaint
;
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
const
SkImageFilter
*
backdropFilter
=
optimize_layer_filter
(
rec
.
fBackdrop
&
backdropPaint
)
;
#
else
const
SkImageFilter
*
backdropFilter
=
rec
.
fBackdrop
;
#
endif
FilterToSpan
backdropAsSpan
(
backdropFilter
)
;
bool
scaleBackdrop
=
rec
.
fExperimentalBackdropScale
!
=
1
.
0f
;
auto
compat
=
(
!
filters
.
empty
(
)
|
|
backdropFilter
|
|
scaleBackdrop
)
?
DeviceCompatibleWithFilter
:
:
kUnknown
:
DeviceCompatibleWithFilter
:
:
kYes
;
this
-
>
internalDrawDeviceWithFilter
(
priorDevice
newDevice
.
get
(
)
backdropAsSpan
backdropPaint
compat
rec
.
fExperimentalBackdropScale
)
;
}
fMCRec
-
>
newLayer
(
std
:
:
move
(
newDevice
)
filters
restorePaint
coverageOnly
)
;
fQuickRejectBounds
=
this
-
>
computeDeviceClipBounds
(
)
;
}
int
SkCanvas
:
:
saveLayerAlphaf
(
const
SkRect
*
bounds
float
alpha
)
{
if
(
alpha
>
=
1
.
0f
)
{
return
this
-
>
saveLayer
(
bounds
nullptr
)
;
}
else
{
SkPaint
tmpPaint
;
tmpPaint
.
setAlphaf
(
alpha
)
;
return
this
-
>
saveLayer
(
bounds
&
tmpPaint
)
;
}
}
void
SkCanvas
:
:
internalSaveBehind
(
const
SkRect
*
localBounds
)
{
SkDevice
*
device
=
this
-
>
topDevice
(
)
;
SkIRect
devBounds
;
if
(
localBounds
)
{
SkRect
tmp
;
device
-
>
localToDevice
(
)
.
mapRect
(
&
tmp
*
localBounds
)
;
if
(
!
devBounds
.
intersect
(
tmp
.
round
(
)
device
-
>
devClipBounds
(
)
)
)
{
devBounds
.
setEmpty
(
)
;
}
}
else
{
devBounds
=
device
-
>
devClipBounds
(
)
;
}
if
(
devBounds
.
isEmpty
(
)
)
{
return
;
}
auto
backImage
=
device
-
>
snapSpecial
(
devBounds
true
)
;
if
(
!
backImage
)
{
return
;
}
this
-
>
checkForDeferredSave
(
)
;
fMCRec
-
>
fBackImage
=
std
:
:
make_unique
<
BackImage
>
(
BackImage
{
std
:
:
move
(
backImage
)
devBounds
.
topLeft
(
)
}
)
;
SkPaint
paint
;
paint
.
setBlendMode
(
SkBlendMode
:
:
kClear
)
;
this
-
>
drawClippedToSaveBehind
(
paint
)
;
}
void
SkCanvas
:
:
internalRestore
(
)
{
SkASSERT
(
!
fMCStack
.
empty
(
)
)
;
std
:
:
unique_ptr
<
Layer
>
layer
=
std
:
:
move
(
fMCRec
-
>
fLayer
)
;
std
:
:
unique_ptr
<
BackImage
>
backImage
=
std
:
:
move
(
fMCRec
-
>
fBackImage
)
;
fMCRec
-
>
~
MCRec
(
)
;
fMCStack
.
pop_back
(
)
;
fMCRec
=
(
MCRec
*
)
fMCStack
.
back
(
)
;
if
(
!
fMCRec
)
{
return
;
}
this
-
>
topDevice
(
)
-
>
popClipStack
(
)
;
this
-
>
topDevice
(
)
-
>
setGlobalCTM
(
fMCRec
-
>
fMatrix
)
;
if
(
backImage
)
{
SkPaint
paint
;
paint
.
setBlendMode
(
SkBlendMode
:
:
kDstOver
)
;
this
-
>
topDevice
(
)
-
>
drawSpecial
(
backImage
-
>
fImage
.
get
(
)
SkMatrix
:
:
Translate
(
backImage
-
>
fLoc
)
SkSamplingOptions
(
)
paint
)
;
}
if
(
layer
&
&
!
layer
-
>
fDevice
-
>
isNoPixelsDevice
(
)
&
&
!
layer
-
>
fDiscard
)
{
layer
-
>
fDevice
-
>
setImmutable
(
)
;
if
(
this
-
>
predrawNotify
(
)
)
{
SkDevice
*
dstDev
=
this
-
>
topDevice
(
)
;
if
(
!
layer
-
>
fImageFilters
.
empty
(
)
)
{
this
-
>
internalDrawDeviceWithFilter
(
layer
-
>
fDevice
.
get
(
)
dstDev
layer
-
>
fImageFilters
layer
-
>
fPaint
DeviceCompatibleWithFilter
:
:
kYes
1
.
0f
layer
-
>
fIsCoverage
)
;
}
else
{
SkASSERT
(
!
layer
-
>
fIsCoverage
)
;
SkSamplingOptions
sampling
;
dstDev
-
>
drawDevice
(
layer
-
>
fDevice
.
get
(
)
sampling
layer
-
>
fPaint
)
;
}
}
}
if
(
this
-
>
getSaveCount
(
)
<
fClipRestrictionSaveCount
)
{
fClipRestrictionRect
.
setEmpty
(
)
;
fClipRestrictionSaveCount
=
-
1
;
}
fQuickRejectBounds
=
this
-
>
computeDeviceClipBounds
(
)
;
this
-
>
validateClip
(
)
;
}
sk_sp
<
SkSurface
>
SkCanvas
:
:
makeSurface
(
const
SkImageInfo
&
info
const
SkSurfaceProps
*
props
)
{
if
(
nullptr
=
=
props
)
{
props
=
&
fProps
;
}
return
this
-
>
onNewSurface
(
info
*
props
)
;
}
sk_sp
<
SkSurface
>
SkCanvas
:
:
onNewSurface
(
const
SkImageInfo
&
info
const
SkSurfaceProps
&
props
)
{
return
this
-
>
rootDevice
(
)
-
>
makeSurface
(
info
props
)
;
}
SkImageInfo
SkCanvas
:
:
imageInfo
(
)
const
{
return
this
-
>
onImageInfo
(
)
;
}
SkImageInfo
SkCanvas
:
:
onImageInfo
(
)
const
{
return
this
-
>
rootDevice
(
)
-
>
imageInfo
(
)
;
}
bool
SkCanvas
:
:
getProps
(
SkSurfaceProps
*
props
)
const
{
return
this
-
>
onGetProps
(
props
false
)
;
}
SkSurfaceProps
SkCanvas
:
:
getBaseProps
(
)
const
{
SkSurfaceProps
props
;
this
-
>
onGetProps
(
&
props
false
)
;
return
props
;
}
SkSurfaceProps
SkCanvas
:
:
getTopProps
(
)
const
{
SkSurfaceProps
props
;
this
-
>
onGetProps
(
&
props
true
)
;
return
props
;
}
bool
SkCanvas
:
:
onGetProps
(
SkSurfaceProps
*
props
bool
top
)
const
{
if
(
props
)
{
*
props
=
top
?
topDevice
(
)
-
>
surfaceProps
(
)
:
fProps
;
}
return
true
;
}
bool
SkCanvas
:
:
peekPixels
(
SkPixmap
*
pmap
)
{
return
this
-
>
onPeekPixels
(
pmap
)
;
}
bool
SkCanvas
:
:
onPeekPixels
(
SkPixmap
*
pmap
)
{
return
this
-
>
rootDevice
(
)
-
>
peekPixels
(
pmap
)
;
}
void
*
SkCanvas
:
:
accessTopLayerPixels
(
SkImageInfo
*
info
size_t
*
rowBytes
SkIPoint
*
origin
)
{
SkPixmap
pmap
;
if
(
!
this
-
>
onAccessTopLayerPixels
(
&
pmap
)
)
{
return
nullptr
;
}
if
(
info
)
{
*
info
=
pmap
.
info
(
)
;
}
if
(
rowBytes
)
{
*
rowBytes
=
pmap
.
rowBytes
(
)
;
}
if
(
origin
)
{
if
(
this
-
>
topDevice
(
)
-
>
isPixelAlignedToGlobal
(
)
)
{
*
origin
=
this
-
>
topDevice
(
)
-
>
getOrigin
(
)
;
}
else
{
return
nullptr
;
}
}
return
pmap
.
writable_addr
(
)
;
}
bool
SkCanvas
:
:
onAccessTopLayerPixels
(
SkPixmap
*
pmap
)
{
return
this
-
>
topDevice
(
)
-
>
accessPixels
(
pmap
)
;
}
void
SkCanvas
:
:
translate
(
SkScalar
dx
SkScalar
dy
)
{
if
(
dx
|
|
dy
)
{
this
-
>
checkForDeferredSave
(
)
;
fMCRec
-
>
fMatrix
.
preTranslate
(
dx
dy
)
;
this
-
>
topDevice
(
)
-
>
setGlobalCTM
(
fMCRec
-
>
fMatrix
)
;
this
-
>
didTranslate
(
dx
dy
)
;
}
}
void
SkCanvas
:
:
scale
(
SkScalar
sx
SkScalar
sy
)
{
if
(
sx
!
=
1
|
|
sy
!
=
1
)
{
this
-
>
checkForDeferredSave
(
)
;
fMCRec
-
>
fMatrix
.
preScale
(
sx
sy
)
;
this
-
>
topDevice
(
)
-
>
setGlobalCTM
(
fMCRec
-
>
fMatrix
)
;
this
-
>
didScale
(
sx
sy
)
;
}
}
void
SkCanvas
:
:
rotate
(
SkScalar
degrees
)
{
SkMatrix
m
;
m
.
setRotate
(
degrees
)
;
this
-
>
concat
(
m
)
;
}
void
SkCanvas
:
:
rotate
(
SkScalar
degrees
SkScalar
px
SkScalar
py
)
{
SkMatrix
m
;
m
.
setRotate
(
degrees
px
py
)
;
this
-
>
concat
(
m
)
;
}
void
SkCanvas
:
:
skew
(
SkScalar
sx
SkScalar
sy
)
{
SkMatrix
m
;
m
.
setSkew
(
sx
sy
)
;
this
-
>
concat
(
m
)
;
}
void
SkCanvas
:
:
concat
(
const
SkMatrix
&
matrix
)
{
if
(
matrix
.
isIdentity
(
)
)
{
return
;
}
this
-
>
concat
(
SkM44
(
matrix
)
)
;
}
void
SkCanvas
:
:
internalConcat44
(
const
SkM44
&
m
)
{
this
-
>
checkForDeferredSave
(
)
;
fMCRec
-
>
fMatrix
.
preConcat
(
m
)
;
this
-
>
topDevice
(
)
-
>
setGlobalCTM
(
fMCRec
-
>
fMatrix
)
;
}
void
SkCanvas
:
:
concat
(
const
SkM44
&
m
)
{
this
-
>
internalConcat44
(
m
)
;
this
-
>
didConcat44
(
m
)
;
}
void
SkCanvas
:
:
internalSetMatrix
(
const
SkM44
&
m
)
{
fMCRec
-
>
fMatrix
=
m
;
this
-
>
topDevice
(
)
-
>
setGlobalCTM
(
fMCRec
-
>
fMatrix
)
;
}
void
SkCanvas
:
:
setMatrix
(
const
SkMatrix
&
matrix
)
{
this
-
>
setMatrix
(
SkM44
(
matrix
)
)
;
}
void
SkCanvas
:
:
setMatrix
(
const
SkM44
&
m
)
{
this
-
>
checkForDeferredSave
(
)
;
this
-
>
internalSetMatrix
(
m
)
;
this
-
>
didSetM44
(
m
)
;
}
void
SkCanvas
:
:
resetMatrix
(
)
{
this
-
>
setMatrix
(
SkM44
(
)
)
;
}
void
SkCanvas
:
:
clipRect
(
const
SkRect
&
rect
SkClipOp
op
bool
doAA
)
{
if
(
!
rect
.
isFinite
(
)
)
{
return
;
}
this
-
>
checkForDeferredSave
(
)
;
ClipEdgeStyle
edgeStyle
=
doAA
?
kSoft_ClipEdgeStyle
:
kHard_ClipEdgeStyle
;
this
-
>
onClipRect
(
rect
.
makeSorted
(
)
op
edgeStyle
)
;
}
void
SkCanvas
:
:
onClipRect
(
const
SkRect
&
rect
SkClipOp
op
ClipEdgeStyle
edgeStyle
)
{
SkASSERT
(
rect
.
isSorted
(
)
)
;
const
bool
isAA
=
kSoft_ClipEdgeStyle
=
=
edgeStyle
;
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipRect
(
rect
op
isAA
)
;
}
void
SkCanvas
:
:
androidFramework_setDeviceClipRestriction
(
const
SkIRect
&
rect
)
{
SkASSERT
(
this
-
>
topDevice
(
)
=
=
this
-
>
rootDevice
(
)
)
;
SkASSERT
(
fClipRestrictionSaveCount
<
0
&
&
fClipRestrictionRect
.
isEmpty
(
)
)
;
if
(
fClipRestrictionSaveCount
<
0
&
&
!
rect
.
isEmpty
(
)
)
{
fClipRestrictionRect
=
rect
;
fClipRestrictionSaveCount
=
this
-
>
getSaveCount
(
)
;
this
-
>
checkForDeferredSave
(
)
;
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipRegion
(
SkRegion
(
rect
)
SkClipOp
:
:
kIntersect
)
;
}
}
void
SkCanvas
:
:
internal_private_resetClip
(
)
{
this
-
>
checkForDeferredSave
(
)
;
this
-
>
onResetClip
(
)
;
}
void
SkCanvas
:
:
onResetClip
(
)
{
SkIRect
deviceRestriction
=
this
-
>
topDevice
(
)
-
>
imageInfo
(
)
.
bounds
(
)
;
if
(
fClipRestrictionSaveCount
>
=
0
&
&
this
-
>
topDevice
(
)
=
=
this
-
>
rootDevice
(
)
)
{
if
(
!
deviceRestriction
.
intersect
(
fClipRestrictionRect
)
)
{
deviceRestriction
=
SkIRect
:
:
MakeEmpty
(
)
;
}
}
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
replaceClip
(
deviceRestriction
)
;
}
void
SkCanvas
:
:
clipRRect
(
const
SkRRect
&
rrect
SkClipOp
op
bool
doAA
)
{
this
-
>
checkForDeferredSave
(
)
;
ClipEdgeStyle
edgeStyle
=
doAA
?
kSoft_ClipEdgeStyle
:
kHard_ClipEdgeStyle
;
if
(
rrect
.
isRect
(
)
)
{
this
-
>
onClipRect
(
rrect
.
getBounds
(
)
op
edgeStyle
)
;
}
else
{
this
-
>
onClipRRect
(
rrect
op
edgeStyle
)
;
}
}
void
SkCanvas
:
:
onClipRRect
(
const
SkRRect
&
rrect
SkClipOp
op
ClipEdgeStyle
edgeStyle
)
{
bool
isAA
=
kSoft_ClipEdgeStyle
=
=
edgeStyle
;
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipRRect
(
rrect
op
isAA
)
;
}
void
SkCanvas
:
:
clipPath
(
const
SkPath
&
path
SkClipOp
op
bool
doAA
)
{
this
-
>
checkForDeferredSave
(
)
;
ClipEdgeStyle
edgeStyle
=
doAA
?
kSoft_ClipEdgeStyle
:
kHard_ClipEdgeStyle
;
if
(
!
path
.
isInverseFillType
(
)
&
&
fMCRec
-
>
fMatrix
.
asM33
(
)
.
rectStaysRect
(
)
)
{
SkRect
r
;
if
(
path
.
isRect
(
&
r
)
)
{
this
-
>
onClipRect
(
r
op
edgeStyle
)
;
return
;
}
SkRRect
rrect
;
if
(
path
.
isOval
(
&
r
)
)
{
rrect
.
setOval
(
r
)
;
this
-
>
onClipRRect
(
rrect
op
edgeStyle
)
;
return
;
}
if
(
path
.
isRRect
(
&
rrect
)
)
{
this
-
>
onClipRRect
(
rrect
op
edgeStyle
)
;
return
;
}
}
this
-
>
onClipPath
(
path
op
edgeStyle
)
;
}
void
SkCanvas
:
:
onClipPath
(
const
SkPath
&
path
SkClipOp
op
ClipEdgeStyle
edgeStyle
)
{
bool
isAA
=
kSoft_ClipEdgeStyle
=
=
edgeStyle
;
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipPath
(
path
op
isAA
)
;
}
void
SkCanvas
:
:
clipShader
(
sk_sp
<
SkShader
>
sh
SkClipOp
op
)
{
if
(
sh
)
{
if
(
sh
-
>
isOpaque
(
)
)
{
if
(
op
=
=
SkClipOp
:
:
kIntersect
)
{
}
else
{
SkASSERT
(
op
=
=
SkClipOp
:
:
kDifference
)
;
this
-
>
clipRect
(
{
0
0
0
0
}
)
;
}
}
else
{
this
-
>
checkForDeferredSave
(
)
;
this
-
>
onClipShader
(
std
:
:
move
(
sh
)
op
)
;
}
}
}
void
SkCanvas
:
:
onClipShader
(
sk_sp
<
SkShader
>
sh
SkClipOp
op
)
{
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipShader
(
sh
op
)
;
}
void
SkCanvas
:
:
clipRegion
(
const
SkRegion
&
rgn
SkClipOp
op
)
{
this
-
>
checkForDeferredSave
(
)
;
this
-
>
onClipRegion
(
rgn
op
)
;
}
void
SkCanvas
:
:
onClipRegion
(
const
SkRegion
&
rgn
SkClipOp
op
)
{
AutoUpdateQRBounds
aqr
(
this
)
;
this
-
>
topDevice
(
)
-
>
clipRegion
(
rgn
op
)
;
}
void
SkCanvas
:
:
validateClip
(
)
const
{
#
ifdef
SK_DEBUG
#
ifndef
SK_DISABLE_SLOW_DEBUG_VALIDATION
SkRect
tmp
=
this
-
>
computeDeviceClipBounds
(
)
;
if
(
this
-
>
isClipEmpty
(
)
)
{
SkASSERT
(
fQuickRejectBounds
.
isEmpty
(
)
)
;
}
else
{
SkASSERT
(
tmp
=
=
fQuickRejectBounds
)
;
}
#
endif
#
endif
}
bool
SkCanvas
:
:
androidFramework_isClipAA
(
)
const
{
return
this
-
>
topDevice
(
)
-
>
isClipAntiAliased
(
)
;
}
void
SkCanvas
:
:
temporary_internal_getRgnClip
(
SkRegion
*
rgn
)
{
rgn
-
>
setEmpty
(
)
;
SkDevice
*
device
=
this
-
>
topDevice
(
)
;
if
(
device
&
&
device
-
>
isPixelAlignedToGlobal
(
)
)
{
device
-
>
android_utils_clipAsRgn
(
rgn
)
;
SkIPoint
origin
=
device
-
>
getOrigin
(
)
;
if
(
origin
.
x
(
)
|
origin
.
y
(
)
)
{
rgn
-
>
translate
(
origin
.
x
(
)
origin
.
y
(
)
)
;
}
}
}
bool
SkCanvas
:
:
isClipEmpty
(
)
const
{
return
this
-
>
topDevice
(
)
-
>
isClipEmpty
(
)
;
}
bool
SkCanvas
:
:
isClipRect
(
)
const
{
return
this
-
>
topDevice
(
)
-
>
isClipRect
(
)
;
}
bool
SkCanvas
:
:
quickReject
(
const
SkRect
&
src
)
const
{
#
ifdef
SK_DEBUG
this
-
>
validateClip
(
)
;
#
endif
SkRect
devRect
=
SkMatrixPriv
:
:
MapRect
(
fMCRec
-
>
fMatrix
src
)
;
return
!
devRect
.
isFinite
(
)
|
|
!
devRect
.
intersects
(
fQuickRejectBounds
)
;
}
bool
SkCanvas
:
:
quickReject
(
const
SkPath
&
path
)
const
{
return
path
.
isEmpty
(
)
|
|
this
-
>
quickReject
(
path
.
getBounds
(
)
)
;
}
bool
SkCanvas
:
:
internalQuickReject
(
const
SkRect
&
bounds
const
SkPaint
&
paint
const
SkMatrix
*
matrix
)
{
if
(
!
bounds
.
isFinite
(
)
|
|
paint
.
nothingToDraw
(
)
)
{
return
true
;
}
if
(
paint
.
canComputeFastBounds
(
)
)
{
SkRect
tmp
=
matrix
?
matrix
-
>
mapRect
(
bounds
)
:
bounds
;
return
this
-
>
quickReject
(
paint
.
computeFastBounds
(
tmp
&
tmp
)
)
;
}
return
false
;
}
SkRect
SkCanvas
:
:
getLocalClipBounds
(
)
const
{
SkIRect
ibounds
=
this
-
>
getDeviceClipBounds
(
)
;
if
(
ibounds
.
isEmpty
(
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
SkMatrix
inverse
;
if
(
!
fMCRec
-
>
fMatrix
.
asM33
(
)
.
invert
(
&
inverse
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
SkRect
bounds
;
const
int
margin
=
1
;
SkRect
r
=
SkRect
:
:
Make
(
ibounds
.
makeOutset
(
margin
margin
)
)
;
inverse
.
mapRect
(
&
bounds
r
)
;
return
bounds
;
}
SkIRect
SkCanvas
:
:
getDeviceClipBounds
(
)
const
{
return
this
-
>
computeDeviceClipBounds
(
false
)
.
roundOut
(
)
;
}
SkRect
SkCanvas
:
:
computeDeviceClipBounds
(
bool
outsetForAA
)
const
{
const
SkDevice
*
dev
=
this
-
>
topDevice
(
)
;
if
(
dev
-
>
isClipEmpty
(
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
else
{
SkRect
devClipBounds
=
SkMatrixPriv
:
:
MapRect
(
dev
-
>
deviceToGlobal
(
)
SkRect
:
:
Make
(
dev
-
>
devClipBounds
(
)
)
)
;
if
(
outsetForAA
)
{
devClipBounds
.
outset
(
1
.
f
1
.
f
)
;
}
return
devClipBounds
;
}
}
SkMatrix
SkCanvas
:
:
getTotalMatrix
(
)
const
{
return
fMCRec
-
>
fMatrix
.
asM33
(
)
;
}
SkM44
SkCanvas
:
:
getLocalToDevice
(
)
const
{
return
fMCRec
-
>
fMatrix
;
}
GrRecordingContext
*
SkCanvas
:
:
recordingContext
(
)
const
{
return
this
-
>
topDevice
(
)
-
>
recordingContext
(
)
;
}
skgpu
:
:
graphite
:
:
Recorder
*
SkCanvas
:
:
recorder
(
)
const
{
return
this
-
>
topDevice
(
)
-
>
recorder
(
)
;
}
void
SkCanvas
:
:
drawDRRect
(
const
SkRRect
&
outer
const
SkRRect
&
inner
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
outer
.
isEmpty
(
)
)
{
return
;
}
if
(
inner
.
isEmpty
(
)
)
{
this
-
>
drawRRect
(
outer
paint
)
;
return
;
}
if
(
!
outer
.
getBounds
(
)
.
contains
(
inner
.
getBounds
(
)
)
)
{
return
;
}
this
-
>
onDrawDRRect
(
outer
inner
paint
)
;
}
void
SkCanvas
:
:
drawPaint
(
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawPaint
(
paint
)
;
}
void
SkCanvas
:
:
drawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawRect
(
r
.
makeSorted
(
)
paint
)
;
}
void
SkCanvas
:
:
drawClippedToSaveBehind
(
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawBehind
(
paint
)
;
}
void
SkCanvas
:
:
drawRegion
(
const
SkRegion
&
region
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
region
.
isEmpty
(
)
)
{
return
;
}
if
(
region
.
isRect
(
)
)
{
return
this
-
>
drawIRect
(
region
.
getBounds
(
)
paint
)
;
}
this
-
>
onDrawRegion
(
region
paint
)
;
}
void
SkCanvas
:
:
drawOval
(
const
SkRect
&
r
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawOval
(
r
.
makeSorted
(
)
paint
)
;
}
void
SkCanvas
:
:
drawRRect
(
const
SkRRect
&
rrect
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawRRect
(
rrect
paint
)
;
}
void
SkCanvas
:
:
drawPoints
(
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawPoints
(
mode
count
pts
paint
)
;
}
void
SkCanvas
:
:
drawVertices
(
const
sk_sp
<
SkVertices
>
&
vertices
SkBlendMode
mode
const
SkPaint
&
paint
)
{
this
-
>
drawVertices
(
vertices
.
get
(
)
mode
paint
)
;
}
void
SkCanvas
:
:
drawVertices
(
const
SkVertices
*
vertices
SkBlendMode
mode
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
vertices
)
;
SkASSERT
(
vertices
-
>
priv
(
)
.
mode
(
)
!
=
SkVertices
:
:
kTriangleFan_VertexMode
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
if
(
paint
.
getShader
(
)
&
&
!
vertices
-
>
priv
(
)
.
hasTexCoords
(
)
)
{
SkPaint
noShaderPaint
(
paint
)
;
noShaderPaint
.
setShader
(
nullptr
)
;
this
-
>
onDrawVerticesObject
(
vertices
mode
noShaderPaint
)
;
return
;
}
#
endif
this
-
>
onDrawVerticesObject
(
vertices
mode
paint
)
;
}
void
SkCanvas
:
:
drawMesh
(
const
SkMesh
&
mesh
sk_sp
<
SkBlender
>
blender
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
!
blender
)
{
blender
=
SkBlender
:
:
Mode
(
SkBlendMode
:
:
kModulate
)
;
}
this
-
>
onDrawMesh
(
mesh
std
:
:
move
(
blender
)
paint
)
;
}
void
SkCanvas
:
:
drawPath
(
const
SkPath
&
path
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawPath
(
path
paint
)
;
}
static
bool
fillable
(
const
SkRect
&
r
)
{
SkScalar
w
=
r
.
width
(
)
;
SkScalar
h
=
r
.
height
(
)
;
return
SkScalarIsFinite
(
w
)
&
&
w
>
0
&
&
SkScalarIsFinite
(
h
)
&
&
h
>
0
;
}
static
SkPaint
clean_paint_for_lattice
(
const
SkPaint
*
paint
)
{
SkPaint
cleaned
;
if
(
paint
)
{
cleaned
=
*
paint
;
cleaned
.
setMaskFilter
(
nullptr
)
;
cleaned
.
setAntiAlias
(
false
)
;
}
return
cleaned
;
}
void
SkCanvas
:
:
drawImageNine
(
const
SkImage
*
image
const
SkIRect
&
center
const
SkRect
&
dst
SkFilterMode
filter
const
SkPaint
*
paint
)
{
RETURN_ON_NULL
(
image
)
;
const
int
xdivs
[
]
=
{
center
.
fLeft
center
.
fRight
}
;
const
int
ydivs
[
]
=
{
center
.
fTop
center
.
fBottom
}
;
Lattice
lat
;
lat
.
fXDivs
=
xdivs
;
lat
.
fYDivs
=
ydivs
;
lat
.
fRectTypes
=
nullptr
;
lat
.
fXCount
=
lat
.
fYCount
=
2
;
lat
.
fBounds
=
nullptr
;
lat
.
fColors
=
nullptr
;
this
-
>
drawImageLattice
(
image
lat
dst
filter
paint
)
;
}
void
SkCanvas
:
:
drawImageLattice
(
const
SkImage
*
image
const
Lattice
&
lattice
const
SkRect
&
dst
SkFilterMode
filter
const
SkPaint
*
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
image
)
;
if
(
dst
.
isEmpty
(
)
)
{
return
;
}
SkIRect
bounds
;
Lattice
latticePlusBounds
=
lattice
;
if
(
!
latticePlusBounds
.
fBounds
)
{
bounds
=
SkIRect
:
:
MakeWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
;
latticePlusBounds
.
fBounds
=
&
bounds
;
}
SkPaint
latticePaint
=
clean_paint_for_lattice
(
paint
)
;
if
(
SkLatticeIter
:
:
Valid
(
image
-
>
width
(
)
image
-
>
height
(
)
latticePlusBounds
)
)
{
this
-
>
onDrawImageLattice2
(
image
latticePlusBounds
dst
filter
&
latticePaint
)
;
}
else
{
this
-
>
drawImageRect
(
image
SkRect
:
:
MakeIWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
dst
SkSamplingOptions
(
filter
)
&
latticePaint
kStrict_SrcRectConstraint
)
;
}
}
void
SkCanvas
:
:
drawAtlas
(
const
SkImage
*
atlas
const
SkRSXform
xform
[
]
const
SkRect
tex
[
]
const
SkColor
colors
[
]
int
count
SkBlendMode
mode
const
SkSamplingOptions
&
sampling
const
SkRect
*
cull
const
SkPaint
*
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
atlas
)
;
if
(
count
<
=
0
)
{
return
;
}
SkASSERT
(
atlas
)
;
SkASSERT
(
tex
)
;
this
-
>
onDrawAtlas2
(
atlas
xform
tex
colors
count
mode
sampling
cull
paint
)
;
}
void
SkCanvas
:
:
drawAnnotation
(
const
SkRect
&
rect
const
char
key
[
]
SkData
*
value
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
key
)
{
this
-
>
onDrawAnnotation
(
rect
key
value
)
;
}
}
void
SkCanvas
:
:
private_draw_shadow_rec
(
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawShadowRec
(
path
rec
)
;
}
void
SkCanvas
:
:
onDrawShadowRec
(
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
if
(
!
this
-
>
predrawNotify
(
)
)
{
return
;
}
this
-
>
topDevice
(
)
-
>
drawShadow
(
path
rec
)
;
}
void
SkCanvas
:
:
experimental_DrawEdgeAAQuad
(
const
SkRect
&
rect
const
SkPoint
clip
[
4
]
QuadAAFlags
aaFlags
const
SkColor4f
&
color
SkBlendMode
mode
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
this
-
>
onDrawEdgeAAQuad
(
rect
.
makeSorted
(
)
clip
aaFlags
color
mode
)
;
}
void
SkCanvas
:
:
experimental_DrawEdgeAAImageSet
(
const
ImageSetEntry
imageSet
[
]
int
cnt
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
SrcRectConstraint
constraint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
#
if
!
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
if
(
paint
&
&
paint
-
>
getImageFilter
(
)
&
&
cnt
=
=
1
)
{
const
auto
&
entry
=
imageSet
[
0
]
;
const
bool
canMapDstRect
=
entry
.
fMatrixIndex
<
0
|
|
(
preViewMatrices
[
entry
.
fMatrixIndex
]
.
isScaleTranslate
(
)
&
&
preViewMatrices
[
entry
.
fMatrixIndex
]
.
getScaleX
(
)
>
0
.
f
&
&
preViewMatrices
[
entry
.
fMatrixIndex
]
.
getScaleY
(
)
>
0
.
f
)
;
if
(
!
entry
.
fHasClip
&
&
canMapDstRect
)
{
SkRect
dst
=
entry
.
fDstRect
;
if
(
entry
.
fMatrixIndex
>
=
0
)
{
preViewMatrices
[
entry
.
fMatrixIndex
]
.
mapRect
(
&
dst
)
;
}
this
-
>
drawImageRect
(
entry
.
fImage
.
get
(
)
entry
.
fSrcRect
dst
sampling
paint
constraint
)
;
return
;
}
}
#
endif
this
-
>
onDrawEdgeAAImageSet2
(
imageSet
cnt
dstClips
preViewMatrices
sampling
paint
constraint
)
;
}
void
SkCanvas
:
:
onDiscard
(
)
{
if
(
fSurfaceBase
)
{
sk_ignore_unused_variable
(
fSurfaceBase
-
>
aboutToDraw
(
SkSurface
:
:
kDiscard_ContentChangeMode
)
)
;
}
}
void
SkCanvas
:
:
onDrawPaint
(
const
SkPaint
&
paint
)
{
this
-
>
internalDrawPaint
(
paint
)
;
}
void
SkCanvas
:
:
internalDrawPaint
(
const
SkPaint
&
paint
)
{
if
(
paint
.
nothingToDraw
(
)
|
|
this
-
>
isClipEmpty
(
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
nullptr
PredrawFlags
:
:
kCheckForOverwrite
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawPaint
(
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawPoints
(
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
const
SkPaint
&
paint
)
{
if
(
(
long
)
count
<
=
0
|
|
paint
.
nothingToDraw
(
)
)
{
return
;
}
SkASSERT
(
pts
!
=
nullptr
)
;
SkRect
bounds
;
if
(
count
=
=
2
)
{
bounds
.
set
(
pts
[
0
]
pts
[
1
]
)
;
}
else
{
bounds
.
setBounds
(
pts
SkToInt
(
count
)
)
;
}
SkPaint
strokePaint
=
paint
;
strokePaint
.
setStyle
(
SkPaint
:
:
kStroke_Style
)
;
if
(
this
-
>
internalQuickReject
(
bounds
strokePaint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
strokePaint
&
bounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawPoints
(
mode
count
pts
layer
-
>
paint
(
)
)
;
}
}
static
const
SkBlurMaskFilterImpl
*
can_attempt_blurred_rrect_draw
(
const
SkPaint
&
paint
)
{
if
(
paint
.
getPathEffect
(
)
)
{
return
nullptr
;
}
if
(
SkStrokeRec
(
paint
)
.
getStyle
(
)
!
=
SkStrokeRec
:
:
kFill_Style
)
{
return
nullptr
;
}
const
SkMaskFilterBase
*
maskFilter
=
as_MFB
(
paint
.
getMaskFilter
(
)
)
;
if
(
!
maskFilter
|
|
maskFilter
-
>
type
(
)
!
=
SkMaskFilterBase
:
:
Type
:
:
kBlur
)
{
return
nullptr
;
}
const
SkBlurMaskFilterImpl
*
blurMaskFilter
=
static_cast
<
const
SkBlurMaskFilterImpl
*
>
(
maskFilter
)
;
if
(
blurMaskFilter
-
>
blurStyle
(
)
!
=
kNormal_SkBlurStyle
)
{
return
nullptr
;
}
return
blurMaskFilter
;
}
std
:
:
optional
<
AutoLayerForImageFilter
>
SkCanvas
:
:
attemptBlurredRRectDraw
(
const
SkRRect
&
rrect
const
SkPaint
&
paint
SkEnumBitMask
<
PredrawFlags
>
flags
)
{
SkASSERT
(
!
(
flags
&
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
)
;
const
SkRect
&
bounds
=
rrect
.
getBounds
(
)
;
if
(
!
this
-
>
topDevice
(
)
-
>
useDrawCoverageMaskForMaskFilters
(
)
)
{
return
this
-
>
aboutToDraw
(
paint
&
bounds
flags
)
;
}
if
(
!
this
-
>
getTotalMatrix
(
)
.
isSimilarity
(
)
)
{
return
this
-
>
aboutToDraw
(
paint
&
bounds
flags
)
;
}
const
SkBlurMaskFilterImpl
*
blurMaskFilter
=
can_attempt_blurred_rrect_draw
(
paint
)
;
if
(
!
blurMaskFilter
)
{
return
this
-
>
aboutToDraw
(
paint
&
bounds
flags
)
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
flags
|
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
;
if
(
!
layer
)
{
return
std
:
:
nullopt
;
}
const
float
deviceSigma
=
blurMaskFilter
-
>
computeXformedSigma
(
this
-
>
getTotalMatrix
(
)
)
;
if
(
this
-
>
topDevice
(
)
-
>
drawBlurredRRect
(
rrect
layer
-
>
paint
(
)
deviceSigma
)
)
{
return
std
:
:
nullopt
;
}
layer
-
>
addMaskFilterLayer
(
&
bounds
)
;
return
layer
;
}
void
SkCanvas
:
:
onDrawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
{
SkASSERT
(
r
.
isSorted
(
)
)
;
if
(
this
-
>
internalQuickReject
(
r
paint
)
)
{
return
;
}
std
:
:
optional
<
AutoLayerForImageFilter
>
layer
=
this
-
>
attemptBlurredRRectDraw
(
SkRRect
:
:
MakeRect
(
r
)
paint
PredrawFlags
:
:
kCheckForOverwrite
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawRect
(
r
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawRegion
(
const
SkRegion
&
region
const
SkPaint
&
paint
)
{
const
SkRect
bounds
=
SkRect
:
:
Make
(
region
.
getBounds
(
)
)
;
if
(
this
-
>
internalQuickReject
(
bounds
paint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawRegion
(
region
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawBehind
(
const
SkPaint
&
paint
)
{
SkDevice
*
dev
=
this
-
>
topDevice
(
)
;
if
(
!
dev
)
{
return
;
}
SkIRect
bounds
;
SkDeque
:
:
Iter
iter
(
fMCStack
SkDeque
:
:
Iter
:
:
kBack_IterStart
)
;
for
(
;
;
)
{
const
MCRec
*
rec
=
(
const
MCRec
*
)
iter
.
prev
(
)
;
if
(
!
rec
)
{
return
;
}
if
(
rec
-
>
fBackImage
)
{
SkASSERT
(
dev
=
=
rec
-
>
fDevice
)
;
bounds
=
SkIRect
:
:
MakeXYWH
(
rec
-
>
fBackImage
-
>
fLoc
.
fX
rec
-
>
fBackImage
-
>
fLoc
.
fY
rec
-
>
fBackImage
-
>
fImage
-
>
width
(
)
rec
-
>
fBackImage
-
>
fImage
-
>
height
(
)
)
;
break
;
}
}
dev
-
>
pushClipStack
(
)
;
{
SkAutoDeviceTransformRestore
adtr
(
dev
SkMatrix
:
:
I
(
)
)
;
dev
-
>
clipRect
(
SkRect
:
:
Make
(
bounds
)
SkClipOp
:
:
kIntersect
false
)
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawPaint
(
layer
-
>
paint
(
)
)
;
}
dev
-
>
popClipStack
(
)
;
}
void
SkCanvas
:
:
onDrawOval
(
const
SkRect
&
oval
const
SkPaint
&
paint
)
{
SkASSERT
(
oval
.
isSorted
(
)
)
;
if
(
this
-
>
internalQuickReject
(
oval
paint
)
)
{
return
;
}
std
:
:
optional
<
AutoLayerForImageFilter
>
layer
=
this
-
>
attemptBlurredRRectDraw
(
SkRRect
:
:
MakeOval
(
oval
)
paint
PredrawFlags
:
:
kNone
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawOval
(
oval
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
SkPaint
&
paint
)
{
SkASSERT
(
oval
.
isSorted
(
)
)
;
if
(
this
-
>
internalQuickReject
(
oval
paint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
oval
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawArc
(
oval
startAngle
sweepAngle
useCenter
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawRRect
(
const
SkRRect
&
rrect
const
SkPaint
&
paint
)
{
const
SkRect
&
bounds
=
rrect
.
getBounds
(
)
;
if
(
rrect
.
isRect
(
)
)
{
this
-
>
SkCanvas
:
:
drawRect
(
bounds
paint
)
;
return
;
}
else
if
(
rrect
.
isOval
(
)
)
{
this
-
>
SkCanvas
:
:
drawOval
(
bounds
paint
)
;
return
;
}
if
(
this
-
>
internalQuickReject
(
bounds
paint
)
)
{
return
;
}
std
:
:
optional
<
AutoLayerForImageFilter
>
layer
=
this
-
>
attemptBlurredRRectDraw
(
rrect
paint
PredrawFlags
:
:
kNone
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawRRect
(
rrect
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawDRRect
(
const
SkRRect
&
outer
const
SkRRect
&
inner
const
SkPaint
&
paint
)
{
const
SkRect
&
bounds
=
outer
.
getBounds
(
)
;
if
(
this
-
>
internalQuickReject
(
bounds
paint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawDRRect
(
outer
inner
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawPath
(
const
SkPath
&
path
const
SkPaint
&
paint
)
{
if
(
!
path
.
isFinite
(
)
)
{
return
;
}
const
SkRect
&
pathBounds
=
path
.
getBounds
(
)
;
if
(
!
path
.
isInverseFillType
(
)
&
&
this
-
>
internalQuickReject
(
pathBounds
paint
)
)
{
return
;
}
if
(
path
.
isInverseFillType
(
)
&
&
pathBounds
.
width
(
)
<
=
0
&
&
pathBounds
.
height
(
)
<
=
0
)
{
this
-
>
internalDrawPaint
(
paint
)
;
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
path
.
isInverseFillType
(
)
?
nullptr
:
&
pathBounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawPath
(
path
layer
-
>
paint
(
)
)
;
}
}
bool
SkCanvas
:
:
canDrawBitmapAsSprite
(
SkScalar
x
SkScalar
y
int
w
int
h
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
)
{
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
if
(
!
paint
.
getImageFilter
(
)
)
{
return
false
;
}
const
SkMatrix
&
ctm
=
this
-
>
getTotalMatrix
(
)
;
if
(
!
SkTreatAsSprite
(
ctm
SkISize
:
:
Make
(
w
h
)
sampling
paint
.
isAntiAlias
(
)
)
)
{
return
false
;
}
if
(
paint
.
getAlphaf
(
)
<
1
.
f
|
|
paint
.
getColorFilter
(
)
|
|
paint
.
getMaskFilter
(
)
)
{
return
false
;
}
SkPoint
pt
;
ctm
.
mapXY
(
x
y
&
pt
)
;
SkIRect
ir
=
SkIRect
:
:
MakeXYWH
(
SkScalarRoundToInt
(
pt
.
x
(
)
)
SkScalarRoundToInt
(
pt
.
y
(
)
)
w
h
)
;
ir
.
outset
(
1
1
)
;
return
ir
.
contains
(
fQuickRejectBounds
)
;
#
else
return
false
;
#
endif
}
static
SkPaint
clean_paint_for_drawImage
(
const
SkPaint
*
paint
)
{
SkPaint
cleaned
;
if
(
paint
)
{
cleaned
=
*
paint
;
cleaned
.
setStyle
(
SkPaint
:
:
kFill_Style
)
;
cleaned
.
setPathEffect
(
nullptr
)
;
}
return
cleaned
;
}
static
SkPaint
clean_paint_for_drawVertices
(
SkPaint
paint
)
{
paint
.
setStyle
(
SkPaint
:
:
kFill_Style
)
;
paint
.
setMaskFilter
(
nullptr
)
;
paint
.
setPathEffect
(
nullptr
)
;
return
paint
;
}
void
SkCanvas
:
:
onDrawImage2
(
const
SkImage
*
image
SkScalar
x
SkScalar
y
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
)
{
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
SkPaint
realPaint
=
clean_paint_for_drawImage
(
paint
)
;
SkRect
dst
=
SkRect
:
:
MakeXYWH
(
x
y
image
-
>
width
(
)
image
-
>
height
(
)
)
;
if
(
this
-
>
internalQuickReject
(
dst
realPaint
)
)
{
return
;
}
if
(
realPaint
.
getImageFilter
(
)
&
&
this
-
>
canDrawBitmapAsSprite
(
x
y
image
-
>
width
(
)
image
-
>
height
(
)
sampling
realPaint
)
&
&
!
SkCanvasPriv
:
:
ImageToColorFilter
(
&
realPaint
)
)
{
SkDevice
*
device
=
this
-
>
topDevice
(
)
;
sk_sp
<
SkSpecialImage
>
special
;
if
(
(
special
=
device
-
>
makeSpecial
(
image
)
)
)
{
sk_sp
<
SkImageFilter
>
filter
=
realPaint
.
refImageFilter
(
)
;
realPaint
.
setImageFilter
(
nullptr
)
;
SkMatrix
layerToDevice
=
device
-
>
localToDevice
(
)
;
layerToDevice
.
preTranslate
(
x
y
)
;
SkMatrix
deviceToLayer
;
if
(
!
layerToDevice
.
invert
(
&
deviceToLayer
)
)
{
return
;
}
skif
:
:
Mapping
mapping
(
layerToDevice
deviceToLayer
SkMatrix
:
:
Translate
(
-
x
-
y
)
)
;
if
(
this
-
>
predrawNotify
(
)
)
{
const
auto
filterColorType
=
image_filter_color_type
(
device
-
>
imageInfo
(
)
)
;
device
-
>
drawFilteredImage
(
mapping
special
.
get
(
)
filterColorType
filter
.
get
(
)
sampling
realPaint
)
;
}
return
;
}
}
if
(
this
-
>
topDevice
(
)
-
>
shouldDrawAsTiledImageRect
(
)
)
{
if
(
this
-
>
topDevice
(
)
-
>
drawAsTiledImageRect
(
this
image
nullptr
dst
sampling
realPaint
kFast_SrcRectConstraint
)
)
{
return
;
}
}
auto
layer
=
this
-
>
aboutToDraw
(
realPaint
&
dst
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawImageRect
(
image
nullptr
dst
sampling
layer
-
>
paint
(
)
kFast_SrcRectConstraint
)
;
}
#
else
SkUNREACHABLE
;
#
endif
}
static
SkSamplingOptions
clean_sampling_for_constraint
(
const
SkSamplingOptions
&
sampling
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
if
(
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
)
{
if
(
sampling
.
mipmap
!
=
SkMipmapMode
:
:
kNone
)
{
return
SkSamplingOptions
(
sampling
.
filter
)
;
}
if
(
sampling
.
isAniso
(
)
)
{
return
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
)
;
}
}
return
sampling
;
}
void
SkCanvas
:
:
onDrawImageRect2
(
const
SkImage
*
image
const
SkRect
&
src
const
SkRect
&
dst
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
SrcRectConstraint
constraint
)
{
SkPaint
realPaint
=
clean_paint_for_drawImage
(
paint
)
;
SkSamplingOptions
realSampling
=
clean_sampling_for_constraint
(
sampling
constraint
)
;
if
(
this
-
>
internalQuickReject
(
dst
realPaint
)
)
{
return
;
}
if
(
this
-
>
topDevice
(
)
-
>
shouldDrawAsTiledImageRect
(
)
)
{
if
(
this
-
>
topDevice
(
)
-
>
drawAsTiledImageRect
(
this
image
&
src
dst
realSampling
realPaint
constraint
)
)
{
return
;
}
}
#
if
!
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
if
(
realPaint
.
getImageFilter
(
)
&
&
!
image
-
>
isAlphaOnly
(
)
&
&
!
realPaint
.
getMaskFilter
(
)
)
{
SkDevice
*
device
=
this
-
>
topDevice
(
)
;
skif
:
:
ParameterSpace
<
SkRect
>
imageBounds
{
dst
}
;
skif
:
:
DeviceSpace
<
SkIRect
>
outputBounds
{
device
-
>
devClipBounds
(
)
}
;
FilterToSpan
filterAsSpan
(
realPaint
.
getImageFilter
(
)
)
;
auto
mappingAndBounds
=
get_layer_mapping_and_bounds
(
filterAsSpan
device
-
>
localToDevice
(
)
outputBounds
imageBounds
)
;
if
(
!
mappingAndBounds
)
{
return
;
}
if
(
!
this
-
>
predrawNotify
(
)
)
{
return
;
}
auto
backend
=
device
-
>
createImageFilteringBackend
(
device
-
>
surfaceProps
(
)
image_filter_color_type
(
device
-
>
imageInfo
(
)
)
)
;
auto
[
mapping
srcBounds
]
=
*
mappingAndBounds
;
skif
:
:
Stats
stats
;
skif
:
:
Context
ctx
{
std
:
:
move
(
backend
)
mapping
srcBounds
skif
:
:
FilterResult
{
}
device
-
>
imageInfo
(
)
.
colorSpace
(
)
&
stats
}
;
auto
source
=
skif
:
:
FilterResult
:
:
MakeFromImage
(
ctx
sk_ref_sp
(
image
)
src
imageBounds
sampling
)
;
source
=
apply_alpha_and_colorfilter
(
ctx
source
realPaint
)
;
ctx
=
ctx
.
withNewDesiredOutput
(
mapping
.
deviceToLayer
(
outputBounds
)
)
.
withNewSource
(
source
)
;
auto
result
=
as_IFB
(
realPaint
.
getImageFilter
(
)
)
-
>
filterImage
(
ctx
)
;
result
.
draw
(
ctx
device
realPaint
.
getBlender
(
)
)
;
stats
.
reportStats
(
)
;
return
;
}
#
endif
if
(
realPaint
.
getMaskFilter
(
)
&
&
this
-
>
topDevice
(
)
-
>
useDrawCoverageMaskForMaskFilters
(
)
)
{
SkRect
drawDst
=
SkModifyPaintAndDstForDrawImageRect
(
image
sampling
src
dst
constraint
=
=
kStrict_SrcRectConstraint
&
realPaint
)
;
if
(
drawDst
.
isEmpty
(
)
)
{
return
;
}
else
{
this
-
>
drawRect
(
drawDst
realPaint
)
;
return
;
}
}
auto
layer
=
this
-
>
aboutToDraw
(
realPaint
&
dst
PredrawFlags
:
:
kCheckForOverwrite
|
(
image
-
>
isOpaque
(
)
?
PredrawFlags
:
:
kOpaqueShaderOverride
:
PredrawFlags
:
:
kNonOpaqueShaderOverride
)
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawImageRect
(
image
&
src
dst
realSampling
layer
-
>
paint
(
)
constraint
)
;
}
}
void
SkCanvas
:
:
onDrawImageLattice2
(
const
SkImage
*
image
const
Lattice
&
lattice
const
SkRect
&
dst
SkFilterMode
filter
const
SkPaint
*
paint
)
{
SkPaint
realPaint
=
clean_paint_for_drawImage
(
paint
)
;
if
(
this
-
>
internalQuickReject
(
dst
realPaint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
realPaint
&
dst
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawImageLattice
(
image
lattice
dst
filter
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
drawImage
(
const
SkImage
*
image
SkScalar
x
SkScalar
y
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
image
)
;
#
if
defined
(
SK_RESOLVE_FILTERS_BEFORE_RESTORE
)
this
-
>
onDrawImage2
(
image
x
y
sampling
paint
)
;
#
else
this
-
>
drawImageRect
(
image
SkRect
:
:
MakeWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
SkRect
:
:
MakeXYWH
(
x
y
image
-
>
width
(
)
image
-
>
height
(
)
)
sampling
paint
kFast_SrcRectConstraint
)
;
#
endif
}
void
SkCanvas
:
:
drawImageRect
(
const
SkImage
*
image
const
SkRect
&
src
const
SkRect
&
dst
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
SrcRectConstraint
constraint
)
{
RETURN_ON_NULL
(
image
)
;
if
(
!
fillable
(
dst
)
|
|
!
fillable
(
src
)
)
{
return
;
}
this
-
>
onDrawImageRect2
(
image
src
dst
sampling
paint
constraint
)
;
}
void
SkCanvas
:
:
drawImageRect
(
const
SkImage
*
image
const
SkRect
&
dst
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
)
{
RETURN_ON_NULL
(
image
)
;
this
-
>
drawImageRect
(
image
SkRect
:
:
MakeIWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
dst
sampling
paint
kFast_SrcRectConstraint
)
;
}
void
SkCanvas
:
:
onDrawTextBlob
(
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
auto
glyphRunList
=
fScratchGlyphRunBuilder
-
>
blobToGlyphRunList
(
*
blob
{
x
y
}
)
;
this
-
>
onDrawGlyphRunList
(
glyphRunList
paint
)
;
}
void
SkCanvas
:
:
onDrawGlyphRunList
(
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
)
{
SkRect
bounds
=
glyphRunList
.
sourceBoundsWithOrigin
(
)
;
if
(
this
-
>
internalQuickReject
(
bounds
paint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawGlyphRunList
(
this
glyphRunList
layer
-
>
paint
(
)
)
;
}
}
sk_sp
<
Slug
>
SkCanvas
:
:
convertBlobToSlug
(
const
SkTextBlob
&
blob
SkPoint
origin
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
auto
glyphRunList
=
fScratchGlyphRunBuilder
-
>
blobToGlyphRunList
(
blob
origin
)
;
return
this
-
>
onConvertGlyphRunListToSlug
(
glyphRunList
paint
)
;
}
sk_sp
<
Slug
>
SkCanvas
:
:
onConvertGlyphRunListToSlug
(
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
)
{
SkRect
bounds
=
glyphRunList
.
sourceBoundsWithOrigin
(
)
;
if
(
bounds
.
isEmpty
(
)
|
|
!
bounds
.
isFinite
(
)
|
|
paint
.
nothingToDraw
(
)
)
{
return
nullptr
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
;
if
(
layer
)
{
return
this
-
>
topDevice
(
)
-
>
convertGlyphRunListToSlug
(
glyphRunList
layer
-
>
paint
(
)
)
;
}
return
nullptr
;
}
void
SkCanvas
:
:
drawSlug
(
const
Slug
*
slug
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
slug
)
{
this
-
>
onDrawSlug
(
slug
paint
)
;
}
}
void
SkCanvas
:
:
onDrawSlug
(
const
Slug
*
slug
const
SkPaint
&
paint
)
{
SkRect
bounds
=
slug
-
>
sourceBoundsWithOrigin
(
)
;
if
(
this
-
>
internalQuickReject
(
bounds
paint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
paint
&
bounds
PredrawFlags
:
:
kSkipMaskFilterAutoLayer
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawSlug
(
this
slug
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
drawSimpleText
(
const
void
*
text
size_t
byteLength
SkTextEncoding
encoding
SkScalar
x
SkScalar
y
const
SkFont
&
font
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
byteLength
)
{
sk_msan_assert_initialized
(
text
SkTAddOffset
<
const
void
>
(
text
byteLength
)
)
;
const
sktext
:
:
GlyphRunList
&
glyphRunList
=
fScratchGlyphRunBuilder
-
>
textToGlyphRunList
(
font
paint
text
byteLength
{
x
y
}
encoding
)
;
if
(
!
glyphRunList
.
empty
(
)
)
{
this
-
>
onDrawGlyphRunList
(
glyphRunList
paint
)
;
}
}
}
void
SkCanvas
:
:
drawGlyphs
(
int
count
const
SkGlyphID
*
glyphs
const
SkPoint
*
positions
const
uint32_t
*
clusters
int
textByteCount
const
char
*
utf8text
SkPoint
origin
const
SkFont
&
font
const
SkPaint
&
paint
)
{
if
(
count
<
=
0
)
{
return
;
}
sktext
:
:
GlyphRun
glyphRun
{
font
SkSpan
(
positions
count
)
SkSpan
(
glyphs
count
)
SkSpan
(
utf8text
textByteCount
)
SkSpan
(
clusters
count
)
SkSpan
<
SkVector
>
(
)
}
;
sktext
:
:
GlyphRunList
glyphRunList
=
fScratchGlyphRunBuilder
-
>
makeGlyphRunList
(
glyphRun
paint
origin
)
;
this
-
>
onDrawGlyphRunList
(
glyphRunList
paint
)
;
}
void
SkCanvas
:
:
drawGlyphs
(
int
count
const
SkGlyphID
glyphs
[
]
const
SkPoint
positions
[
]
SkPoint
origin
const
SkFont
&
font
const
SkPaint
&
paint
)
{
if
(
count
<
=
0
)
{
return
;
}
sktext
:
:
GlyphRun
glyphRun
{
font
SkSpan
(
positions
count
)
SkSpan
(
glyphs
count
)
SkSpan
<
const
char
>
(
)
SkSpan
<
const
uint32_t
>
(
)
SkSpan
<
SkVector
>
(
)
}
;
sktext
:
:
GlyphRunList
glyphRunList
=
fScratchGlyphRunBuilder
-
>
makeGlyphRunList
(
glyphRun
paint
origin
)
;
this
-
>
onDrawGlyphRunList
(
glyphRunList
paint
)
;
}
void
SkCanvas
:
:
drawGlyphs
(
int
count
const
SkGlyphID
glyphs
[
]
const
SkRSXform
xforms
[
]
SkPoint
origin
const
SkFont
&
font
const
SkPaint
&
paint
)
{
if
(
count
<
=
0
)
{
return
;
}
auto
[
positions
rotateScales
]
=
fScratchGlyphRunBuilder
-
>
convertRSXForm
(
SkSpan
(
xforms
count
)
)
;
sktext
:
:
GlyphRun
glyphRun
{
font
positions
SkSpan
(
glyphs
count
)
SkSpan
<
const
char
>
(
)
SkSpan
<
const
uint32_t
>
(
)
rotateScales
}
;
sktext
:
:
GlyphRunList
glyphRunList
=
fScratchGlyphRunBuilder
-
>
makeGlyphRunList
(
glyphRun
paint
origin
)
;
this
-
>
onDrawGlyphRunList
(
glyphRunList
paint
)
;
}
void
SkCanvas
:
:
drawTextBlob
(
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
blob
)
;
RETURN_ON_FALSE
(
blob
-
>
bounds
(
)
.
makeOffset
(
x
y
)
.
isFinite
(
)
)
;
int
totalGlyphCount
=
0
;
constexpr
int
kMaxGlyphCount
=
1
<
<
21
;
SkTextBlob
:
:
Iter
i
(
*
blob
)
;
SkTextBlob
:
:
Iter
:
:
Run
r
;
while
(
i
.
next
(
&
r
)
)
{
int
glyphsLeft
=
kMaxGlyphCount
-
totalGlyphCount
;
RETURN_ON_FALSE
(
r
.
fGlyphCount
<
=
glyphsLeft
)
;
totalGlyphCount
+
=
r
.
fGlyphCount
;
}
this
-
>
onDrawTextBlob
(
blob
x
y
paint
)
;
}
void
SkCanvas
:
:
onDrawVerticesObject
(
const
SkVertices
*
vertices
SkBlendMode
bmode
const
SkPaint
&
paint
)
{
SkPaint
simplePaint
=
clean_paint_for_drawVertices
(
paint
)
;
const
SkRect
&
bounds
=
vertices
-
>
bounds
(
)
;
if
(
this
-
>
internalQuickReject
(
bounds
simplePaint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
simplePaint
&
bounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawVertices
(
vertices
SkBlender
:
:
Mode
(
bmode
)
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawMesh
(
const
SkMesh
&
mesh
sk_sp
<
SkBlender
>
blender
const
SkPaint
&
paint
)
{
SkPaint
simplePaint
=
clean_paint_for_drawVertices
(
paint
)
;
auto
layer
=
this
-
>
aboutToDraw
(
simplePaint
nullptr
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawMesh
(
mesh
std
:
:
move
(
blender
)
paint
)
;
}
}
void
SkCanvas
:
:
drawPatch
(
const
SkPoint
cubics
[
12
]
const
SkColor
colors
[
4
]
const
SkPoint
texCoords
[
4
]
SkBlendMode
bmode
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
nullptr
=
=
cubics
)
{
return
;
}
this
-
>
onDrawPatch
(
cubics
colors
texCoords
bmode
paint
)
;
}
void
SkCanvas
:
:
onDrawPatch
(
const
SkPoint
cubics
[
12
]
const
SkColor
colors
[
4
]
const
SkPoint
texCoords
[
4
]
SkBlendMode
bmode
const
SkPaint
&
paint
)
{
SkPaint
simplePaint
=
clean_paint_for_drawVertices
(
paint
)
;
SkRect
bounds
;
bounds
.
setBounds
(
cubics
SkPatchUtils
:
:
kNumCtrlPts
)
;
if
(
this
-
>
internalQuickReject
(
bounds
simplePaint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
simplePaint
&
bounds
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawPatch
(
cubics
colors
texCoords
SkBlender
:
:
Mode
(
bmode
)
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
drawDrawable
(
SkDrawable
*
dr
SkScalar
x
SkScalar
y
)
{
#
ifndef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
#
endif
RETURN_ON_NULL
(
dr
)
;
if
(
x
|
|
y
)
{
SkMatrix
matrix
=
SkMatrix
:
:
Translate
(
x
y
)
;
this
-
>
onDrawDrawable
(
dr
&
matrix
)
;
}
else
{
this
-
>
onDrawDrawable
(
dr
nullptr
)
;
}
}
void
SkCanvas
:
:
drawDrawable
(
SkDrawable
*
dr
const
SkMatrix
*
matrix
)
{
#
ifndef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
#
endif
RETURN_ON_NULL
(
dr
)
;
if
(
matrix
&
&
matrix
-
>
isIdentity
(
)
)
{
matrix
=
nullptr
;
}
this
-
>
onDrawDrawable
(
dr
matrix
)
;
}
void
SkCanvas
:
:
onDrawDrawable
(
SkDrawable
*
dr
const
SkMatrix
*
matrix
)
{
if
(
this
-
>
predrawNotify
(
)
)
{
this
-
>
topDevice
(
)
-
>
drawDrawable
(
this
dr
matrix
)
;
}
}
void
SkCanvas
:
:
onDrawAtlas2
(
const
SkImage
*
atlas
const
SkRSXform
xform
[
]
const
SkRect
tex
[
]
const
SkColor
colors
[
]
int
count
SkBlendMode
bmode
const
SkSamplingOptions
&
sampling
const
SkRect
*
cull
const
SkPaint
*
paint
)
{
SkPaint
realPaint
=
clean_paint_for_drawVertices
(
clean_paint_for_drawImage
(
paint
)
)
;
realPaint
.
setShader
(
atlas
-
>
makeShader
(
sampling
)
)
;
if
(
cull
&
&
this
-
>
internalQuickReject
(
*
cull
realPaint
)
)
{
return
;
}
SkASSERT
(
!
realPaint
.
getMaskFilter
(
)
)
;
auto
layer
=
this
-
>
aboutToDraw
(
realPaint
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawAtlas
(
xform
tex
colors
count
SkBlender
:
:
Mode
(
bmode
)
layer
-
>
paint
(
)
)
;
}
}
void
SkCanvas
:
:
onDrawAnnotation
(
const
SkRect
&
rect
const
char
key
[
]
SkData
*
value
)
{
SkASSERT
(
key
)
;
if
(
this
-
>
predrawNotify
(
)
)
{
this
-
>
topDevice
(
)
-
>
drawAnnotation
(
rect
key
value
)
;
}
}
void
SkCanvas
:
:
onDrawEdgeAAQuad
(
const
SkRect
&
r
const
SkPoint
clip
[
4
]
QuadAAFlags
edgeAA
const
SkColor4f
&
color
SkBlendMode
mode
)
{
SkASSERT
(
r
.
isSorted
(
)
)
;
SkPaint
paint
{
color
}
;
paint
.
setBlendMode
(
mode
)
;
if
(
this
-
>
internalQuickReject
(
r
paint
)
)
{
return
;
}
if
(
this
-
>
predrawNotify
(
)
)
{
this
-
>
topDevice
(
)
-
>
drawEdgeAAQuad
(
r
clip
edgeAA
color
mode
)
;
}
}
void
SkCanvas
:
:
onDrawEdgeAAImageSet2
(
const
ImageSetEntry
imageSet
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
SrcRectConstraint
constraint
)
{
if
(
count
<
=
0
)
{
return
;
}
SkPaint
realPaint
=
clean_paint_for_drawImage
(
paint
)
;
SkSamplingOptions
realSampling
=
clean_sampling_for_constraint
(
sampling
constraint
)
;
bool
needsAutoLayer
=
SkToBool
(
realPaint
.
getImageFilter
(
)
)
;
bool
setBoundsValid
=
count
=
=
1
|
|
needsAutoLayer
;
SkRect
setBounds
=
imageSet
[
0
]
.
fDstRect
;
if
(
imageSet
[
0
]
.
fMatrixIndex
>
=
0
)
{
preViewMatrices
[
imageSet
[
0
]
.
fMatrixIndex
]
.
mapRect
(
&
setBounds
)
;
}
if
(
needsAutoLayer
)
{
for
(
int
i
=
1
;
i
<
count
;
+
+
i
)
{
SkRect
entryBounds
=
imageSet
[
i
]
.
fDstRect
;
if
(
imageSet
[
i
]
.
fMatrixIndex
>
=
0
)
{
preViewMatrices
[
imageSet
[
i
]
.
fMatrixIndex
]
.
mapRect
(
&
entryBounds
)
;
}
setBounds
.
joinPossiblyEmptyRect
(
entryBounds
)
;
}
}
if
(
setBoundsValid
&
&
this
-
>
internalQuickReject
(
setBounds
realPaint
)
)
{
return
;
}
auto
layer
=
this
-
>
aboutToDraw
(
realPaint
setBoundsValid
?
&
setBounds
:
nullptr
)
;
if
(
layer
)
{
this
-
>
topDevice
(
)
-
>
drawEdgeAAImageSet
(
imageSet
count
dstClips
preViewMatrices
realSampling
layer
-
>
paint
(
)
constraint
)
;
}
}
void
SkCanvas
:
:
drawColor
(
const
SkColor4f
&
c
SkBlendMode
mode
)
{
SkPaint
paint
;
paint
.
setColor
(
c
)
;
paint
.
setBlendMode
(
mode
)
;
this
-
>
drawPaint
(
paint
)
;
}
void
SkCanvas
:
:
drawPoint
(
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
const
SkPoint
pt
=
{
x
y
}
;
this
-
>
drawPoints
(
kPoints_PointMode
1
&
pt
paint
)
;
}
void
SkCanvas
:
:
drawLine
(
SkScalar
x0
SkScalar
y0
SkScalar
x1
SkScalar
y1
const
SkPaint
&
paint
)
{
SkPoint
pts
[
2
]
;
pts
[
0
]
.
set
(
x0
y0
)
;
pts
[
1
]
.
set
(
x1
y1
)
;
this
-
>
drawPoints
(
kLines_PointMode
2
pts
paint
)
;
}
void
SkCanvas
:
:
drawCircle
(
SkScalar
cx
SkScalar
cy
SkScalar
radius
const
SkPaint
&
paint
)
{
if
(
radius
<
0
)
{
radius
=
0
;
}
SkRect
r
;
r
.
setLTRB
(
cx
-
radius
cy
-
radius
cx
+
radius
cy
+
radius
)
;
this
-
>
drawOval
(
r
paint
)
;
}
void
SkCanvas
:
:
drawRoundRect
(
const
SkRect
&
r
SkScalar
rx
SkScalar
ry
const
SkPaint
&
paint
)
{
if
(
rx
>
0
&
&
ry
>
0
)
{
SkRRect
rrect
;
rrect
.
setRectXY
(
r
rx
ry
)
;
this
-
>
drawRRect
(
rrect
paint
)
;
}
else
{
this
-
>
drawRect
(
r
paint
)
;
}
}
void
SkCanvas
:
:
drawArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
SkPaint
&
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
if
(
oval
.
isEmpty
(
)
|
|
!
sweepAngle
)
{
return
;
}
this
-
>
onDrawArc
(
oval
startAngle
sweepAngle
useCenter
paint
)
;
}
#
ifdef
SK_DISABLE_SKPICTURE
void
SkCanvas
:
:
drawPicture
(
const
SkPicture
*
picture
const
SkMatrix
*
matrix
const
SkPaint
*
paint
)
{
}
void
SkCanvas
:
:
onDrawPicture
(
const
SkPicture
*
picture
const
SkMatrix
*
matrix
const
SkPaint
*
paint
)
{
}
#
else
void
SkCanvas
:
:
drawPicture
(
const
SkPicture
*
picture
const
SkMatrix
*
matrix
const
SkPaint
*
paint
)
{
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
RETURN_ON_NULL
(
picture
)
;
if
(
matrix
&
&
matrix
-
>
isIdentity
(
)
)
{
matrix
=
nullptr
;
}
if
(
picture
-
>
approximateOpCount
(
)
<
=
kMaxPictureOpsToUnrollInsteadOfRef
)
{
SkAutoCanvasMatrixPaint
acmp
(
this
matrix
paint
picture
-
>
cullRect
(
)
)
;
picture
-
>
playback
(
this
)
;
}
else
{
this
-
>
onDrawPicture
(
picture
matrix
paint
)
;
}
}
void
SkCanvas
:
:
onDrawPicture
(
const
SkPicture
*
picture
const
SkMatrix
*
matrix
const
SkPaint
*
paint
)
{
if
(
this
-
>
internalQuickReject
(
picture
-
>
cullRect
(
)
paint
?
*
paint
:
SkPaint
{
}
matrix
)
)
{
return
;
}
SkAutoCanvasMatrixPaint
acmp
(
this
matrix
paint
picture
-
>
cullRect
(
)
)
;
picture
-
>
playback
(
this
)
;
}
#
endif
SkCanvas
:
:
ImageSetEntry
:
:
ImageSetEntry
(
)
=
default
;
SkCanvas
:
:
ImageSetEntry
:
:
~
ImageSetEntry
(
)
=
default
;
SkCanvas
:
:
ImageSetEntry
:
:
ImageSetEntry
(
const
ImageSetEntry
&
)
=
default
;
SkCanvas
:
:
ImageSetEntry
&
SkCanvas
:
:
ImageSetEntry
:
:
operator
=
(
const
ImageSetEntry
&
)
=
default
;
SkCanvas
:
:
ImageSetEntry
:
:
ImageSetEntry
(
sk_sp
<
const
SkImage
>
image
const
SkRect
&
srcRect
const
SkRect
&
dstRect
int
matrixIndex
float
alpha
unsigned
aaFlags
bool
hasClip
)
:
fImage
(
std
:
:
move
(
image
)
)
fSrcRect
(
srcRect
)
fDstRect
(
dstRect
)
fMatrixIndex
(
matrixIndex
)
fAlpha
(
alpha
)
fAAFlags
(
aaFlags
)
fHasClip
(
hasClip
)
{
}
SkCanvas
:
:
ImageSetEntry
:
:
ImageSetEntry
(
sk_sp
<
const
SkImage
>
image
const
SkRect
&
srcRect
const
SkRect
&
dstRect
float
alpha
unsigned
aaFlags
)
:
fImage
(
std
:
:
move
(
image
)
)
fSrcRect
(
srcRect
)
fDstRect
(
dstRect
)
fAlpha
(
alpha
)
fAAFlags
(
aaFlags
)
{
}
std
:
:
unique_ptr
<
SkCanvas
>
SkCanvas
:
:
MakeRasterDirect
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
if
(
!
SkSurfaceValidateRasterInfo
(
info
rowBytes
)
)
{
return
nullptr
;
}
SkBitmap
bitmap
;
if
(
!
bitmap
.
installPixels
(
info
pixels
rowBytes
)
)
{
return
nullptr
;
}
return
props
?
std
:
:
make_unique
<
SkCanvas
>
(
bitmap
*
props
)
:
std
:
:
make_unique
<
SkCanvas
>
(
bitmap
)
;
}
SkNoDrawCanvas
:
:
SkNoDrawCanvas
(
int
width
int
height
)
:
INHERITED
(
SkIRect
:
:
MakeWH
(
width
height
)
)
{
}
SkNoDrawCanvas
:
:
SkNoDrawCanvas
(
const
SkIRect
&
bounds
)
:
INHERITED
(
bounds
)
{
}
SkCanvas
:
:
SaveLayerStrategy
SkNoDrawCanvas
:
:
getSaveLayerStrategy
(
const
SaveLayerRec
&
rec
)
{
(
void
)
this
-
>
INHERITED
:
:
getSaveLayerStrategy
(
rec
)
;
return
kNoLayer_SaveLayerStrategy
;
}
bool
SkNoDrawCanvas
:
:
onDoSaveBehind
(
const
SkRect
*
)
{
return
false
;
}
static_assert
(
(
int
)
SkRegion
:
:
kDifference_Op
=
=
(
int
)
SkClipOp
:
:
kDifference
"
"
)
;
static_assert
(
(
int
)
SkRegion
:
:
kIntersect_Op
=
=
(
int
)
SkClipOp
:
:
kIntersect
"
"
)
;
SkRasterHandleAllocator
:
:
Handle
SkCanvas
:
:
accessTopRasterHandle
(
)
const
{
const
SkDevice
*
dev
=
this
-
>
topDevice
(
)
;
if
(
fAllocator
)
{
SkRasterHandleAllocator
:
:
Handle
handle
=
dev
-
>
getRasterHandle
(
)
;
SkIRect
clip
=
dev
-
>
devClipBounds
(
)
;
if
(
!
clip
.
intersect
(
{
0
0
dev
-
>
width
(
)
dev
-
>
height
(
)
}
)
)
{
clip
.
setEmpty
(
)
;
}
fAllocator
-
>
updateHandle
(
handle
dev
-
>
localToDevice
(
)
clip
)
;
return
handle
;
}
return
nullptr
;
}
static
bool
install
(
SkBitmap
*
bm
const
SkImageInfo
&
info
const
SkRasterHandleAllocator
:
:
Rec
&
rec
)
{
return
bm
-
>
installPixels
(
info
rec
.
fPixels
rec
.
fRowBytes
rec
.
fReleaseProc
rec
.
fReleaseCtx
)
;
}
SkRasterHandleAllocator
:
:
Handle
SkRasterHandleAllocator
:
:
allocBitmap
(
const
SkImageInfo
&
info
SkBitmap
*
bm
)
{
SkRasterHandleAllocator
:
:
Rec
rec
;
if
(
!
this
-
>
allocHandle
(
info
&
rec
)
|
|
!
install
(
bm
info
rec
)
)
{
return
nullptr
;
}
return
rec
.
fHandle
;
}
std
:
:
unique_ptr
<
SkCanvas
>
SkRasterHandleAllocator
:
:
MakeCanvas
(
std
:
:
unique_ptr
<
SkRasterHandleAllocator
>
alloc
const
SkImageInfo
&
info
const
Rec
*
rec
const
SkSurfaceProps
*
props
)
{
if
(
!
alloc
|
|
!
SkSurfaceValidateRasterInfo
(
info
rec
?
rec
-
>
fRowBytes
:
kIgnoreRowBytesValue
)
)
{
return
nullptr
;
}
SkBitmap
bm
;
Handle
hndl
;
if
(
rec
)
{
hndl
=
install
(
&
bm
info
*
rec
)
?
rec
-
>
fHandle
:
nullptr
;
}
else
{
hndl
=
alloc
-
>
allocBitmap
(
info
&
bm
)
;
}
return
hndl
?
std
:
:
unique_ptr
<
SkCanvas
>
(
new
SkCanvas
(
bm
std
:
:
move
(
alloc
)
hndl
props
)
)
:
nullptr
;
}
