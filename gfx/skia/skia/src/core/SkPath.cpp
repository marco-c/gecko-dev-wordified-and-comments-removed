#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkMath
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
private
/
SkMacros
.
h
"
#
include
"
include
/
private
/
SkPathRef
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkBuffer
.
h
"
#
include
"
src
/
core
/
SkCubicClipper
.
h
"
#
include
"
src
/
core
/
SkGeometry
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkPathMakers
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
core
/
SkPointPriv
.
h
"
#
include
"
src
/
core
/
SkSafeMath
.
h
"
#
include
"
src
/
core
/
SkTLazy
.
h
"
#
include
"
src
/
pathops
/
SkPathOpsPoint
.
h
"
#
include
<
cmath
>
#
include
<
utility
>
struct
SkPath_Storage_Equivalent
{
void
*
fPtr
;
int32_t
fIndex
;
uint32_t
fFlags
;
}
;
static_assert
(
sizeof
(
SkPath
)
=
=
sizeof
(
SkPath_Storage_Equivalent
)
"
Please
keep
an
eye
on
SkPath
packing
.
"
)
;
static
float
poly_eval
(
float
A
float
B
float
C
float
t
)
{
return
(
A
*
t
+
B
)
*
t
+
C
;
}
static
float
poly_eval
(
float
A
float
B
float
C
float
D
float
t
)
{
return
(
(
A
*
t
+
B
)
*
t
+
C
)
*
t
+
D
;
}
static
void
joinNoEmptyChecks
(
SkRect
*
dst
const
SkRect
&
src
)
{
dst
-
>
fLeft
=
SkMinScalar
(
dst
-
>
fLeft
src
.
fLeft
)
;
dst
-
>
fTop
=
SkMinScalar
(
dst
-
>
fTop
src
.
fTop
)
;
dst
-
>
fRight
=
SkMaxScalar
(
dst
-
>
fRight
src
.
fRight
)
;
dst
-
>
fBottom
=
SkMaxScalar
(
dst
-
>
fBottom
src
.
fBottom
)
;
}
static
bool
is_degenerate
(
const
SkPath
&
path
)
{
return
path
.
countVerbs
(
)
<
=
1
;
}
class
SkAutoDisableDirectionCheck
{
public
:
SkAutoDisableDirectionCheck
(
SkPath
*
path
)
:
fPath
(
path
)
{
fSaved
=
static_cast
<
SkPathPriv
:
:
FirstDirection
>
(
fPath
-
>
getFirstDirection
(
)
)
;
}
~
SkAutoDisableDirectionCheck
(
)
{
fPath
-
>
setFirstDirection
(
fSaved
)
;
}
private
:
SkPath
*
fPath
;
SkPathPriv
:
:
FirstDirection
fSaved
;
}
;
#
define
SkAutoDisableDirectionCheck
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoDisableDirectionCheck
)
class
SkAutoPathBoundsUpdate
{
public
:
SkAutoPathBoundsUpdate
(
SkPath
*
path
const
SkRect
&
r
)
:
fPath
(
path
)
fRect
(
r
)
{
fRect
.
sort
(
)
;
fHasValidBounds
=
path
-
>
hasComputedBounds
(
)
&
&
path
-
>
isFinite
(
)
;
fEmpty
=
path
-
>
isEmpty
(
)
;
if
(
fHasValidBounds
&
&
!
fEmpty
)
{
joinNoEmptyChecks
(
&
fRect
fPath
-
>
getBounds
(
)
)
;
}
fDegenerate
=
is_degenerate
(
*
path
)
;
}
~
SkAutoPathBoundsUpdate
(
)
{
fPath
-
>
setConvexity
(
fDegenerate
?
SkPath
:
:
kConvex_Convexity
:
SkPath
:
:
kUnknown_Convexity
)
;
if
(
(
fEmpty
|
|
fHasValidBounds
)
&
&
fRect
.
isFinite
(
)
)
{
fPath
-
>
setBounds
(
fRect
)
;
}
}
private
:
SkPath
*
fPath
;
SkRect
fRect
;
bool
fHasValidBounds
;
bool
fDegenerate
;
bool
fEmpty
;
}
;
#
define
SkAutoPathBoundsUpdate
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoPathBoundsUpdate
)
#
define
INITIAL_LASTMOVETOINDEX_VALUE
~
0
SkPath
:
:
SkPath
(
)
:
fPathRef
(
SkPathRef
:
:
CreateEmpty
(
)
)
{
this
-
>
resetFields
(
)
;
fIsVolatile
=
false
;
}
void
SkPath
:
:
resetFields
(
)
{
fLastMoveToIndex
=
INITIAL_LASTMOVETOINDEX_VALUE
;
fFillType
=
kWinding_FillType
;
this
-
>
setConvexity
(
kUnknown_Convexity
)
;
this
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
}
SkPath
:
:
SkPath
(
const
SkPath
&
that
)
:
fPathRef
(
SkRef
(
that
.
fPathRef
.
get
(
)
)
)
{
this
-
>
copyFields
(
that
)
;
SkDEBUGCODE
(
that
.
validate
(
)
;
)
}
SkPath
:
:
~
SkPath
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPath
&
SkPath
:
:
operator
=
(
const
SkPath
&
that
)
{
SkDEBUGCODE
(
that
.
validate
(
)
;
)
if
(
this
!
=
&
that
)
{
fPathRef
.
reset
(
SkRef
(
that
.
fPathRef
.
get
(
)
)
)
;
this
-
>
copyFields
(
that
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
*
this
;
}
void
SkPath
:
:
copyFields
(
const
SkPath
&
that
)
{
fLastMoveToIndex
=
that
.
fLastMoveToIndex
;
fFillType
=
that
.
fFillType
;
fIsVolatile
=
that
.
fIsVolatile
;
this
-
>
setConvexity
(
that
.
getConvexityOrUnknown
(
)
)
;
this
-
>
setFirstDirection
(
that
.
getFirstDirection
(
)
)
;
}
bool
operator
=
=
(
const
SkPath
&
a
const
SkPath
&
b
)
{
return
&
a
=
=
&
b
|
|
(
a
.
fFillType
=
=
b
.
fFillType
&
&
*
a
.
fPathRef
.
get
(
)
=
=
*
b
.
fPathRef
.
get
(
)
)
;
}
void
SkPath
:
:
swap
(
SkPath
&
that
)
{
if
(
this
!
=
&
that
)
{
fPathRef
.
swap
(
that
.
fPathRef
)
;
std
:
:
swap
(
fLastMoveToIndex
that
.
fLastMoveToIndex
)
;
const
auto
ft
=
fFillType
;
fFillType
=
that
.
fFillType
;
that
.
fFillType
=
ft
;
const
auto
iv
=
fIsVolatile
;
fIsVolatile
=
that
.
fIsVolatile
;
that
.
fIsVolatile
=
iv
;
Convexity
c
=
this
-
>
getConvexityOrUnknown
(
)
;
this
-
>
setConvexity
(
that
.
getConvexityOrUnknown
(
)
)
;
that
.
setConvexity
(
c
)
;
uint8_t
fd
=
this
-
>
getFirstDirection
(
)
;
this
-
>
setFirstDirection
(
that
.
getFirstDirection
(
)
)
;
that
.
setFirstDirection
(
fd
)
;
}
}
bool
SkPath
:
:
isInterpolatable
(
const
SkPath
&
compare
)
const
{
return
fPathRef
-
>
fPoints
.
count
(
)
=
=
compare
.
fPathRef
-
>
fPoints
.
count
(
)
&
&
fPathRef
-
>
fVerbs
=
=
compare
.
fPathRef
-
>
fVerbs
&
&
fPathRef
-
>
fConicWeights
=
=
compare
.
fPathRef
-
>
fConicWeights
;
}
bool
SkPath
:
:
interpolate
(
const
SkPath
&
ending
SkScalar
weight
SkPath
*
out
)
const
{
int
pointCount
=
fPathRef
-
>
countPoints
(
)
;
if
(
pointCount
!
=
ending
.
fPathRef
-
>
countPoints
(
)
)
{
return
false
;
}
if
(
!
pointCount
)
{
return
true
;
}
out
-
>
reset
(
)
;
out
-
>
addPath
(
*
this
)
;
fPathRef
-
>
interpolate
(
*
ending
.
fPathRef
weight
out
-
>
fPathRef
.
get
(
)
)
;
return
true
;
}
static
inline
bool
check_edge_against_rect
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkRect
&
rect
SkPathPriv
:
:
FirstDirection
dir
)
{
const
SkPoint
*
edgeBegin
;
SkVector
v
;
if
(
SkPathPriv
:
:
kCW_FirstDirection
=
=
dir
)
{
v
=
p1
-
p0
;
edgeBegin
=
&
p0
;
}
else
{
v
=
p0
-
p1
;
edgeBegin
=
&
p1
;
}
if
(
v
.
fX
|
|
v
.
fY
)
{
SkScalar
yL
=
v
.
fY
*
(
rect
.
fLeft
-
edgeBegin
-
>
fX
)
;
SkScalar
xT
=
v
.
fX
*
(
rect
.
fTop
-
edgeBegin
-
>
fY
)
;
SkScalar
yR
=
v
.
fY
*
(
rect
.
fRight
-
edgeBegin
-
>
fX
)
;
SkScalar
xB
=
v
.
fX
*
(
rect
.
fBottom
-
edgeBegin
-
>
fY
)
;
if
(
(
xT
<
yL
)
|
|
(
xT
<
yR
)
|
|
(
xB
<
yL
)
|
|
(
xB
<
yR
)
)
{
return
false
;
}
}
return
true
;
}
bool
SkPath
:
:
conservativelyContainsRect
(
const
SkRect
&
rect
)
const
{
if
(
kConvex_Convexity
!
=
this
-
>
getConvexity
(
)
)
{
return
false
;
}
SkPathPriv
:
:
FirstDirection
direction
;
if
(
!
SkPathPriv
:
:
CheapComputeFirstDirection
(
*
this
&
direction
)
)
{
return
false
;
}
SkPoint
firstPt
;
SkPoint
prevPt
;
SkPath
:
:
Iter
iter
(
*
this
true
)
;
SkPath
:
:
Verb
verb
;
SkPoint
pts
[
4
]
;
int
segmentCount
=
0
;
SkDEBUGCODE
(
int
moveCnt
=
0
;
)
SkDEBUGCODE
(
int
closeCount
=
0
;
)
while
(
(
verb
=
iter
.
next
(
pts
)
)
!
=
kDone_Verb
)
{
int
nextPt
=
-
1
;
switch
(
verb
)
{
case
kMove_Verb
:
SkASSERT
(
!
segmentCount
&
&
!
closeCount
)
;
SkDEBUGCODE
(
+
+
moveCnt
)
;
firstPt
=
prevPt
=
pts
[
0
]
;
break
;
case
kLine_Verb
:
if
(
!
SkPathPriv
:
:
AllPointsEq
(
pts
2
)
)
{
nextPt
=
1
;
SkASSERT
(
moveCnt
&
&
!
closeCount
)
;
+
+
segmentCount
;
}
break
;
case
kQuad_Verb
:
case
kConic_Verb
:
if
(
!
SkPathPriv
:
:
AllPointsEq
(
pts
3
)
)
{
SkASSERT
(
moveCnt
&
&
!
closeCount
)
;
+
+
segmentCount
;
nextPt
=
2
;
}
break
;
case
kCubic_Verb
:
if
(
!
SkPathPriv
:
:
AllPointsEq
(
pts
4
)
)
{
SkASSERT
(
moveCnt
&
&
!
closeCount
)
;
+
+
segmentCount
;
nextPt
=
3
;
}
break
;
case
kClose_Verb
:
SkDEBUGCODE
(
+
+
closeCount
;
)
break
;
default
:
SkDEBUGFAIL
(
"
unknown
verb
"
)
;
}
if
(
-
1
!
=
nextPt
)
{
if
(
SkPath
:
:
kConic_Verb
=
=
verb
)
{
SkConic
orig
;
orig
.
set
(
pts
iter
.
conicWeight
(
)
)
;
SkPoint
quadPts
[
5
]
;
int
count
=
orig
.
chopIntoQuadsPOW2
(
quadPts
1
)
;
SkASSERT_RELEASE
(
2
=
=
count
)
;
if
(
!
check_edge_against_rect
(
quadPts
[
0
]
quadPts
[
2
]
rect
direction
)
)
{
return
false
;
}
if
(
!
check_edge_against_rect
(
quadPts
[
2
]
quadPts
[
4
]
rect
direction
)
)
{
return
false
;
}
}
else
{
if
(
!
check_edge_against_rect
(
prevPt
pts
[
nextPt
]
rect
direction
)
)
{
return
false
;
}
}
prevPt
=
pts
[
nextPt
]
;
}
}
if
(
segmentCount
)
{
return
check_edge_against_rect
(
prevPt
firstPt
rect
direction
)
;
}
return
false
;
}
uint32_t
SkPath
:
:
getGenerationID
(
)
const
{
uint32_t
genID
=
fPathRef
-
>
genID
(
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkASSERT
(
(
unsigned
)
fFillType
<
(
1
<
<
(
32
-
SkPathPriv
:
:
kPathRefGenIDBitCnt
)
)
)
;
genID
|
=
static_cast
<
uint32_t
>
(
fFillType
)
<
<
SkPathPriv
:
:
kPathRefGenIDBitCnt
;
#
endif
return
genID
;
}
SkPath
&
SkPath
:
:
reset
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fPathRef
.
reset
(
SkPathRef
:
:
CreateEmpty
(
)
)
;
this
-
>
resetFields
(
)
;
return
*
this
;
}
SkPath
&
SkPath
:
:
rewind
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkPathRef
:
:
Rewind
(
&
fPathRef
)
;
this
-
>
resetFields
(
)
;
return
*
this
;
}
bool
SkPath
:
:
isLastContourClosed
(
)
const
{
int
verbCount
=
fPathRef
-
>
countVerbs
(
)
;
if
(
0
=
=
verbCount
)
{
return
false
;
}
return
kClose_Verb
=
=
fPathRef
-
>
atVerb
(
verbCount
-
1
)
;
}
bool
SkPath
:
:
isLine
(
SkPoint
line
[
2
]
)
const
{
int
verbCount
=
fPathRef
-
>
countVerbs
(
)
;
if
(
2
=
=
verbCount
)
{
SkASSERT
(
kMove_Verb
=
=
fPathRef
-
>
atVerb
(
0
)
)
;
if
(
kLine_Verb
=
=
fPathRef
-
>
atVerb
(
1
)
)
{
SkASSERT
(
2
=
=
fPathRef
-
>
countPoints
(
)
)
;
if
(
line
)
{
const
SkPoint
*
pts
=
fPathRef
-
>
points
(
)
;
line
[
0
]
=
pts
[
0
]
;
line
[
1
]
=
pts
[
1
]
;
}
return
true
;
}
}
return
false
;
}
static
int
rect_make_dir
(
SkScalar
dx
SkScalar
dy
)
{
return
(
(
0
!
=
dx
)
<
<
0
)
|
(
(
dx
>
0
|
|
dy
>
0
)
<
<
1
)
;
}
bool
SkPath
:
:
isRect
(
SkRect
*
rect
bool
*
isClosed
Direction
*
direction
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
int
currVerb
=
0
;
const
SkPoint
*
pts
=
fPathRef
-
>
points
(
)
;
return
SkPathPriv
:
:
IsRectContour
(
*
this
false
&
currVerb
&
pts
isClosed
direction
rect
)
;
}
bool
SkPath
:
:
isOval
(
SkRect
*
bounds
)
const
{
return
SkPathPriv
:
:
IsOval
(
*
this
bounds
nullptr
nullptr
)
;
}
bool
SkPath
:
:
isRRect
(
SkRRect
*
rrect
)
const
{
return
SkPathPriv
:
:
IsRRect
(
*
this
rrect
nullptr
nullptr
)
;
}
int
SkPath
:
:
countPoints
(
)
const
{
return
fPathRef
-
>
countPoints
(
)
;
}
int
SkPath
:
:
getPoints
(
SkPoint
dst
[
]
int
max
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
max
>
=
0
)
;
SkASSERT
(
!
max
|
|
dst
)
;
int
count
=
SkMin32
(
max
fPathRef
-
>
countPoints
(
)
)
;
sk_careful_memcpy
(
dst
fPathRef
-
>
points
(
)
count
*
sizeof
(
SkPoint
)
)
;
return
fPathRef
-
>
countPoints
(
)
;
}
SkPoint
SkPath
:
:
getPoint
(
int
index
)
const
{
if
(
(
unsigned
)
index
<
(
unsigned
)
fPathRef
-
>
countPoints
(
)
)
{
return
fPathRef
-
>
atPoint
(
index
)
;
}
return
SkPoint
:
:
Make
(
0
0
)
;
}
int
SkPath
:
:
countVerbs
(
)
const
{
return
fPathRef
-
>
countVerbs
(
)
;
}
int
SkPath
:
:
getVerbs
(
uint8_t
dst
[
]
int
max
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
max
>
=
0
)
;
SkASSERT
(
!
max
|
|
dst
)
;
int
count
=
SkMin32
(
max
fPathRef
-
>
countVerbs
(
)
)
;
if
(
count
)
{
memcpy
(
dst
fPathRef
-
>
verbsBegin
(
)
count
)
;
}
return
fPathRef
-
>
countVerbs
(
)
;
}
size_t
SkPath
:
:
approximateBytesUsed
(
)
const
{
size_t
size
=
sizeof
(
SkPath
)
;
if
(
fPathRef
!
=
nullptr
)
{
size
+
=
fPathRef
-
>
countPoints
(
)
*
sizeof
(
SkPoint
)
+
fPathRef
-
>
countVerbs
(
)
+
fPathRef
-
>
countWeights
(
)
*
sizeof
(
SkScalar
)
;
}
return
size
;
}
bool
SkPath
:
:
getLastPt
(
SkPoint
*
lastPt
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
int
count
=
fPathRef
-
>
countPoints
(
)
;
if
(
count
>
0
)
{
if
(
lastPt
)
{
*
lastPt
=
fPathRef
-
>
atPoint
(
count
-
1
)
;
}
return
true
;
}
if
(
lastPt
)
{
lastPt
-
>
set
(
0
0
)
;
}
return
false
;
}
void
SkPath
:
:
setPt
(
int
index
SkScalar
x
SkScalar
y
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
int
count
=
fPathRef
-
>
countPoints
(
)
;
if
(
count
<
=
index
)
{
return
;
}
else
{
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
atPoint
(
index
)
-
>
set
(
x
y
)
;
}
}
void
SkPath
:
:
setLastPt
(
SkScalar
x
SkScalar
y
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
int
count
=
fPathRef
-
>
countPoints
(
)
;
if
(
count
=
=
0
)
{
this
-
>
moveTo
(
x
y
)
;
}
else
{
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
atPoint
(
count
-
1
)
-
>
set
(
x
y
)
;
}
}
void
SkPath
:
:
setConvexity
(
Convexity
c
)
{
fConvexity
.
store
(
c
std
:
:
memory_order_relaxed
)
;
}
void
SkPath
:
:
setConvexity
(
Convexity
c
)
const
{
fConvexity
.
store
(
c
std
:
:
memory_order_relaxed
)
;
}
void
SkPath
:
:
setFirstDirection
(
uint8_t
d
)
const
{
fFirstDirection
.
store
(
d
std
:
:
memory_order_relaxed
)
;
}
uint8_t
SkPath
:
:
getFirstDirection
(
)
const
{
return
fFirstDirection
.
load
(
std
:
:
memory_order_relaxed
)
;
}
#
define
DIRTY_AFTER_EDIT
\
do
{
\
this
-
>
setConvexity
(
kUnknown_Convexity
)
;
\
this
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
\
}
while
(
0
)
void
SkPath
:
:
incReserve
(
int
inc
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
inc
>
0
)
{
SkPathRef
:
:
Editor
(
&
fPathRef
inc
inc
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPath
&
SkPath
:
:
moveTo
(
SkScalar
x
SkScalar
y
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
fLastMoveToIndex
=
fPathRef
-
>
countPoints
(
)
;
ed
.
growForVerb
(
kMove_Verb
)
-
>
set
(
x
y
)
;
DIRTY_AFTER_EDIT
;
return
*
this
;
}
SkPath
&
SkPath
:
:
rMoveTo
(
SkScalar
x
SkScalar
y
)
{
SkPoint
pt
;
this
-
>
getLastPt
(
&
pt
)
;
return
this
-
>
moveTo
(
pt
.
fX
+
x
pt
.
fY
+
y
)
;
}
void
SkPath
:
:
injectMoveToIfNeeded
(
)
{
if
(
fLastMoveToIndex
<
0
)
{
SkScalar
x
y
;
if
(
fPathRef
-
>
countVerbs
(
)
=
=
0
)
{
x
=
y
=
0
;
}
else
{
const
SkPoint
&
pt
=
fPathRef
-
>
atPoint
(
~
fLastMoveToIndex
)
;
x
=
pt
.
fX
;
y
=
pt
.
fY
;
}
this
-
>
moveTo
(
x
y
)
;
}
}
SkPath
&
SkPath
:
:
lineTo
(
SkScalar
x
SkScalar
y
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
injectMoveToIfNeeded
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
growForVerb
(
kLine_Verb
)
-
>
set
(
x
y
)
;
DIRTY_AFTER_EDIT
;
return
*
this
;
}
SkPath
&
SkPath
:
:
rLineTo
(
SkScalar
x
SkScalar
y
)
{
this
-
>
injectMoveToIfNeeded
(
)
;
SkPoint
pt
;
this
-
>
getLastPt
(
&
pt
)
;
return
this
-
>
lineTo
(
pt
.
fX
+
x
pt
.
fY
+
y
)
;
}
SkPath
&
SkPath
:
:
quadTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
injectMoveToIfNeeded
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
SkPoint
*
pts
=
ed
.
growForVerb
(
kQuad_Verb
)
;
pts
[
0
]
.
set
(
x1
y1
)
;
pts
[
1
]
.
set
(
x2
y2
)
;
DIRTY_AFTER_EDIT
;
return
*
this
;
}
SkPath
&
SkPath
:
:
rQuadTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
)
{
this
-
>
injectMoveToIfNeeded
(
)
;
SkPoint
pt
;
this
-
>
getLastPt
(
&
pt
)
;
return
this
-
>
quadTo
(
pt
.
fX
+
x1
pt
.
fY
+
y1
pt
.
fX
+
x2
pt
.
fY
+
y2
)
;
}
SkPath
&
SkPath
:
:
conicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
w
)
{
if
(
!
(
w
>
0
)
)
{
this
-
>
lineTo
(
x2
y2
)
;
}
else
if
(
!
SkScalarIsFinite
(
w
)
)
{
this
-
>
lineTo
(
x1
y1
)
;
this
-
>
lineTo
(
x2
y2
)
;
}
else
if
(
SK_Scalar1
=
=
w
)
{
this
-
>
quadTo
(
x1
y1
x2
y2
)
;
}
else
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
injectMoveToIfNeeded
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
SkPoint
*
pts
=
ed
.
growForVerb
(
kConic_Verb
w
)
;
pts
[
0
]
.
set
(
x1
y1
)
;
pts
[
1
]
.
set
(
x2
y2
)
;
DIRTY_AFTER_EDIT
;
}
return
*
this
;
}
SkPath
&
SkPath
:
:
rConicTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
SkScalar
w
)
{
this
-
>
injectMoveToIfNeeded
(
)
;
SkPoint
pt
;
this
-
>
getLastPt
(
&
pt
)
;
return
this
-
>
conicTo
(
pt
.
fX
+
dx1
pt
.
fY
+
dy1
pt
.
fX
+
dx2
pt
.
fY
+
dy2
w
)
;
}
SkPath
&
SkPath
:
:
cubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
injectMoveToIfNeeded
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
SkPoint
*
pts
=
ed
.
growForVerb
(
kCubic_Verb
)
;
pts
[
0
]
.
set
(
x1
y1
)
;
pts
[
1
]
.
set
(
x2
y2
)
;
pts
[
2
]
.
set
(
x3
y3
)
;
DIRTY_AFTER_EDIT
;
return
*
this
;
}
SkPath
&
SkPath
:
:
rCubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
{
this
-
>
injectMoveToIfNeeded
(
)
;
SkPoint
pt
;
this
-
>
getLastPt
(
&
pt
)
;
return
this
-
>
cubicTo
(
pt
.
fX
+
x1
pt
.
fY
+
y1
pt
.
fX
+
x2
pt
.
fY
+
y2
pt
.
fX
+
x3
pt
.
fY
+
y3
)
;
}
SkPath
&
SkPath
:
:
close
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
int
count
=
fPathRef
-
>
countVerbs
(
)
;
if
(
count
>
0
)
{
switch
(
fPathRef
-
>
atVerb
(
count
-
1
)
)
{
case
kLine_Verb
:
case
kQuad_Verb
:
case
kConic_Verb
:
case
kCubic_Verb
:
case
kMove_Verb
:
{
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
growForVerb
(
kClose_Verb
)
;
break
;
}
case
kClose_Verb
:
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
verb
"
)
;
break
;
}
}
#
if
0
if
(
fLastMoveToIndex
>
=
0
)
{
fLastMoveToIndex
=
~
fLastMoveToIndex
;
}
#
else
fLastMoveToIndex
^
=
~
fLastMoveToIndex
>
>
(
8
*
sizeof
(
fLastMoveToIndex
)
-
1
)
;
#
endif
return
*
this
;
}
static
void
assert_known_direction
(
int
dir
)
{
SkASSERT
(
SkPath
:
:
kCW_Direction
=
=
dir
|
|
SkPath
:
:
kCCW_Direction
=
=
dir
)
;
}
SkPath
&
SkPath
:
:
addRect
(
const
SkRect
&
rect
Direction
dir
)
{
return
this
-
>
addRect
(
rect
dir
0
)
;
}
SkPath
&
SkPath
:
:
addRect
(
SkScalar
left
SkScalar
top
SkScalar
right
SkScalar
bottom
Direction
dir
)
{
return
this
-
>
addRect
(
SkRect
:
:
MakeLTRB
(
left
top
right
bottom
)
dir
0
)
;
}
SkPath
&
SkPath
:
:
addRect
(
const
SkRect
&
rect
Direction
dir
unsigned
startIndex
)
{
assert_known_direction
(
dir
)
;
this
-
>
setFirstDirection
(
this
-
>
hasOnlyMoveTos
(
)
?
(
SkPathPriv
:
:
FirstDirection
)
dir
:
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
SkAutoDisableDirectionCheck
addc
(
this
)
;
SkAutoPathBoundsUpdate
apbu
(
this
rect
)
;
SkDEBUGCODE
(
int
initialVerbCount
=
this
-
>
countVerbs
(
)
)
;
const
int
kVerbs
=
5
;
this
-
>
incReserve
(
kVerbs
)
;
SkPath_RectPointIterator
iter
(
rect
dir
startIndex
)
;
this
-
>
moveTo
(
iter
.
current
(
)
)
;
this
-
>
lineTo
(
iter
.
next
(
)
)
;
this
-
>
lineTo
(
iter
.
next
(
)
)
;
this
-
>
lineTo
(
iter
.
next
(
)
)
;
this
-
>
close
(
)
;
SkASSERT
(
this
-
>
countVerbs
(
)
=
=
initialVerbCount
+
kVerbs
)
;
return
*
this
;
}
SkPath
&
SkPath
:
:
addPoly
(
const
SkPoint
pts
[
]
int
count
bool
close
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
count
<
=
0
)
{
return
*
this
;
}
fLastMoveToIndex
=
fPathRef
-
>
countPoints
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
count
+
close
count
)
;
ed
.
growForVerb
(
kMove_Verb
)
-
>
set
(
pts
[
0
]
.
fX
pts
[
0
]
.
fY
)
;
if
(
count
>
1
)
{
SkPoint
*
p
=
ed
.
growForRepeatedVerb
(
kLine_Verb
count
-
1
)
;
memcpy
(
p
&
pts
[
1
]
(
count
-
1
)
*
sizeof
(
SkPoint
)
)
;
}
if
(
close
)
{
ed
.
growForVerb
(
kClose_Verb
)
;
fLastMoveToIndex
^
=
~
fLastMoveToIndex
>
>
(
8
*
sizeof
(
fLastMoveToIndex
)
-
1
)
;
}
DIRTY_AFTER_EDIT
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
*
this
;
}
#
include
"
src
/
core
/
SkGeometry
.
h
"
static
bool
arc_is_lone_point
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
SkPoint
*
pt
)
{
if
(
0
=
=
sweepAngle
&
&
(
0
=
=
startAngle
|
|
SkIntToScalar
(
360
)
=
=
startAngle
)
)
{
pt
-
>
set
(
oval
.
fRight
oval
.
centerY
(
)
)
;
return
true
;
}
else
if
(
0
=
=
oval
.
width
(
)
&
&
0
=
=
oval
.
height
(
)
)
{
pt
-
>
set
(
oval
.
fRight
oval
.
fTop
)
;
return
true
;
}
return
false
;
}
static
void
angles_to_unit_vectors
(
SkScalar
startAngle
SkScalar
sweepAngle
SkVector
*
startV
SkVector
*
stopV
SkRotationDirection
*
dir
)
{
SkScalar
startRad
=
SkDegreesToRadians
(
startAngle
)
stopRad
=
SkDegreesToRadians
(
startAngle
+
sweepAngle
)
;
startV
-
>
fY
=
SkScalarSinSnapToZero
(
startRad
)
;
startV
-
>
fX
=
SkScalarCosSnapToZero
(
startRad
)
;
stopV
-
>
fY
=
SkScalarSinSnapToZero
(
stopRad
)
;
stopV
-
>
fX
=
SkScalarCosSnapToZero
(
stopRad
)
;
if
(
*
startV
=
=
*
stopV
)
{
SkScalar
sw
=
SkScalarAbs
(
sweepAngle
)
;
if
(
sw
<
SkIntToScalar
(
360
)
&
&
sw
>
SkIntToScalar
(
359
)
)
{
SkScalar
deltaRad
=
SkScalarCopySign
(
SK_Scalar1
/
512
sweepAngle
)
;
do
{
stopRad
-
=
deltaRad
;
stopV
-
>
fY
=
SkScalarSinSnapToZero
(
stopRad
)
;
stopV
-
>
fX
=
SkScalarCosSnapToZero
(
stopRad
)
;
}
while
(
*
startV
=
=
*
stopV
)
;
}
}
*
dir
=
sweepAngle
>
0
?
kCW_SkRotationDirection
:
kCCW_SkRotationDirection
;
}
static
int
build_arc_conics
(
const
SkRect
&
oval
const
SkVector
&
start
const
SkVector
&
stop
SkRotationDirection
dir
SkConic
conics
[
SkConic
:
:
kMaxConicsForArc
]
SkPoint
*
singlePt
)
{
SkMatrix
matrix
;
matrix
.
setScale
(
SkScalarHalf
(
oval
.
width
(
)
)
SkScalarHalf
(
oval
.
height
(
)
)
)
;
matrix
.
postTranslate
(
oval
.
centerX
(
)
oval
.
centerY
(
)
)
;
int
count
=
SkConic
:
:
BuildUnitArc
(
start
stop
dir
&
matrix
conics
)
;
if
(
0
=
=
count
)
{
matrix
.
mapXY
(
stop
.
x
(
)
stop
.
y
(
)
singlePt
)
;
}
return
count
;
}
SkPath
&
SkPath
:
:
addRoundRect
(
const
SkRect
&
rect
const
SkScalar
radii
[
]
Direction
dir
)
{
SkRRect
rrect
;
rrect
.
setRectRadii
(
rect
(
const
SkVector
*
)
radii
)
;
return
this
-
>
addRRect
(
rrect
dir
)
;
}
SkPath
&
SkPath
:
:
addRRect
(
const
SkRRect
&
rrect
Direction
dir
)
{
return
this
-
>
addRRect
(
rrect
dir
dir
=
=
kCW_Direction
?
6
:
7
)
;
}
SkPath
&
SkPath
:
:
addRRect
(
const
SkRRect
&
rrect
Direction
dir
unsigned
startIndex
)
{
assert_known_direction
(
dir
)
;
bool
isRRect
=
hasOnlyMoveTos
(
)
;
const
SkRect
&
bounds
=
rrect
.
getBounds
(
)
;
if
(
rrect
.
isRect
(
)
|
|
rrect
.
isEmpty
(
)
)
{
this
-
>
addRect
(
bounds
dir
(
startIndex
+
1
)
/
2
)
;
}
else
if
(
rrect
.
isOval
(
)
)
{
this
-
>
addOval
(
bounds
dir
startIndex
/
2
)
;
}
else
{
this
-
>
setFirstDirection
(
this
-
>
hasOnlyMoveTos
(
)
?
(
SkPathPriv
:
:
FirstDirection
)
dir
:
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
SkAutoPathBoundsUpdate
apbu
(
this
bounds
)
;
SkAutoDisableDirectionCheck
addc
(
this
)
;
const
bool
startsWithConic
=
(
(
startIndex
&
1
)
=
=
(
dir
=
=
kCW_Direction
)
)
;
const
SkScalar
weight
=
SK_ScalarRoot2Over2
;
SkDEBUGCODE
(
int
initialVerbCount
=
this
-
>
countVerbs
(
)
)
;
const
int
kVerbs
=
startsWithConic
?
9
:
10
;
this
-
>
incReserve
(
kVerbs
)
;
SkPath_RRectPointIterator
rrectIter
(
rrect
dir
startIndex
)
;
const
unsigned
rectStartIndex
=
startIndex
/
2
+
(
dir
=
=
kCW_Direction
?
0
:
1
)
;
SkPath_RectPointIterator
rectIter
(
bounds
dir
rectStartIndex
)
;
this
-
>
moveTo
(
rrectIter
.
current
(
)
)
;
if
(
startsWithConic
)
{
for
(
unsigned
i
=
0
;
i
<
3
;
+
+
i
)
{
this
-
>
conicTo
(
rectIter
.
next
(
)
rrectIter
.
next
(
)
weight
)
;
this
-
>
lineTo
(
rrectIter
.
next
(
)
)
;
}
this
-
>
conicTo
(
rectIter
.
next
(
)
rrectIter
.
next
(
)
weight
)
;
}
else
{
for
(
unsigned
i
=
0
;
i
<
4
;
+
+
i
)
{
this
-
>
lineTo
(
rrectIter
.
next
(
)
)
;
this
-
>
conicTo
(
rectIter
.
next
(
)
rrectIter
.
next
(
)
weight
)
;
}
}
this
-
>
close
(
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
setIsRRect
(
isRRect
dir
startIndex
%
8
)
;
SkASSERT
(
this
-
>
countVerbs
(
)
=
=
initialVerbCount
+
kVerbs
)
;
}
SkDEBUGCODE
(
fPathRef
-
>
validate
(
)
;
)
return
*
this
;
}
bool
SkPath
:
:
hasOnlyMoveTos
(
)
const
{
int
count
=
fPathRef
-
>
countVerbs
(
)
;
const
uint8_t
*
verbs
=
fPathRef
-
>
verbsBegin
(
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
*
verbs
=
=
kLine_Verb
|
|
*
verbs
=
=
kQuad_Verb
|
|
*
verbs
=
=
kConic_Verb
|
|
*
verbs
=
=
kCubic_Verb
)
{
return
false
;
}
+
+
verbs
;
}
return
true
;
}
bool
SkPath
:
:
isZeroLengthSincePoint
(
int
startPtIndex
)
const
{
int
count
=
fPathRef
-
>
countPoints
(
)
-
startPtIndex
;
if
(
count
<
2
)
{
return
true
;
}
const
SkPoint
*
pts
=
fPathRef
.
get
(
)
-
>
points
(
)
+
startPtIndex
;
const
SkPoint
&
first
=
*
pts
;
for
(
int
index
=
1
;
index
<
count
;
+
+
index
)
{
if
(
first
!
=
pts
[
index
]
)
{
return
false
;
}
}
return
true
;
}
SkPath
&
SkPath
:
:
addRoundRect
(
const
SkRect
&
rect
SkScalar
rx
SkScalar
ry
Direction
dir
)
{
assert_known_direction
(
dir
)
;
if
(
rx
<
0
|
|
ry
<
0
)
{
return
*
this
;
}
SkRRect
rrect
;
rrect
.
setRectXY
(
rect
rx
ry
)
;
return
this
-
>
addRRect
(
rrect
dir
)
;
}
SkPath
&
SkPath
:
:
addOval
(
const
SkRect
&
oval
Direction
dir
)
{
return
this
-
>
addOval
(
oval
dir
1
)
;
}
SkPath
&
SkPath
:
:
addOval
(
const
SkRect
&
oval
Direction
dir
unsigned
startPointIndex
)
{
assert_known_direction
(
dir
)
;
bool
isOval
=
hasOnlyMoveTos
(
)
;
if
(
isOval
)
{
this
-
>
setFirstDirection
(
(
SkPathPriv
:
:
FirstDirection
)
dir
)
;
}
else
{
this
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
}
SkAutoDisableDirectionCheck
addc
(
this
)
;
SkAutoPathBoundsUpdate
apbu
(
this
oval
)
;
SkDEBUGCODE
(
int
initialVerbCount
=
this
-
>
countVerbs
(
)
)
;
const
int
kVerbs
=
6
;
this
-
>
incReserve
(
kVerbs
)
;
SkPath_OvalPointIterator
ovalIter
(
oval
dir
startPointIndex
)
;
SkPath_RectPointIterator
rectIter
(
oval
dir
startPointIndex
+
(
dir
=
=
kCW_Direction
?
0
:
1
)
)
;
const
SkScalar
weight
=
SK_ScalarRoot2Over2
;
this
-
>
moveTo
(
ovalIter
.
current
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
4
;
+
+
i
)
{
this
-
>
conicTo
(
rectIter
.
next
(
)
ovalIter
.
next
(
)
weight
)
;
}
this
-
>
close
(
)
;
SkASSERT
(
this
-
>
countVerbs
(
)
=
=
initialVerbCount
+
kVerbs
)
;
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
setIsOval
(
isOval
kCCW_Direction
=
=
dir
startPointIndex
%
4
)
;
return
*
this
;
}
SkPath
&
SkPath
:
:
addCircle
(
SkScalar
x
SkScalar
y
SkScalar
r
Direction
dir
)
{
if
(
r
>
0
)
{
this
-
>
addOval
(
SkRect
:
:
MakeLTRB
(
x
-
r
y
-
r
x
+
r
y
+
r
)
dir
)
;
}
return
*
this
;
}
SkPath
&
SkPath
:
:
arcTo
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
forceMoveTo
)
{
if
(
oval
.
width
(
)
<
0
|
|
oval
.
height
(
)
<
0
)
{
return
*
this
;
}
if
(
fPathRef
-
>
countVerbs
(
)
=
=
0
)
{
forceMoveTo
=
true
;
}
SkPoint
lonePt
;
if
(
arc_is_lone_point
(
oval
startAngle
sweepAngle
&
lonePt
)
)
{
return
forceMoveTo
?
this
-
>
moveTo
(
lonePt
)
:
this
-
>
lineTo
(
lonePt
)
;
}
SkVector
startV
stopV
;
SkRotationDirection
dir
;
angles_to_unit_vectors
(
startAngle
sweepAngle
&
startV
&
stopV
&
dir
)
;
SkPoint
singlePt
;
auto
addPt
=
[
&
forceMoveTo
this
]
(
const
SkPoint
&
pt
)
{
SkPoint
lastPt
;
if
(
forceMoveTo
)
{
this
-
>
moveTo
(
pt
)
;
}
else
if
(
!
this
-
>
getLastPt
(
&
lastPt
)
|
|
!
SkScalarNearlyEqual
(
lastPt
.
fX
pt
.
fX
)
|
|
!
SkScalarNearlyEqual
(
lastPt
.
fY
pt
.
fY
)
)
{
this
-
>
lineTo
(
pt
)
;
}
}
;
if
(
startV
=
=
stopV
)
{
SkScalar
endAngle
=
SkDegreesToRadians
(
startAngle
+
sweepAngle
)
;
SkScalar
radiusX
=
oval
.
width
(
)
/
2
;
SkScalar
radiusY
=
oval
.
height
(
)
/
2
;
singlePt
.
set
(
oval
.
centerX
(
)
+
radiusX
*
SkScalarCos
(
endAngle
)
oval
.
centerY
(
)
+
radiusY
*
SkScalarSin
(
endAngle
)
)
;
addPt
(
singlePt
)
;
return
*
this
;
}
SkConic
conics
[
SkConic
:
:
kMaxConicsForArc
]
;
int
count
=
build_arc_conics
(
oval
startV
stopV
dir
conics
&
singlePt
)
;
if
(
count
)
{
this
-
>
incReserve
(
count
*
2
+
1
)
;
const
SkPoint
&
pt
=
conics
[
0
]
.
fPts
[
0
]
;
addPt
(
pt
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
this
-
>
conicTo
(
conics
[
i
]
.
fPts
[
1
]
conics
[
i
]
.
fPts
[
2
]
conics
[
i
]
.
fW
)
;
}
}
else
{
addPt
(
singlePt
)
;
}
return
*
this
;
}
SkPath
&
SkPath
:
:
arcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
angle
SkPath
:
:
ArcSize
arcLarge
SkPath
:
:
Direction
arcSweep
SkScalar
x
SkScalar
y
)
{
this
-
>
injectMoveToIfNeeded
(
)
;
SkPoint
srcPts
[
2
]
;
this
-
>
getLastPt
(
&
srcPts
[
0
]
)
;
if
(
!
rx
|
|
!
ry
)
{
return
this
-
>
lineTo
(
x
y
)
;
}
srcPts
[
1
]
.
set
(
x
y
)
;
if
(
srcPts
[
0
]
=
=
srcPts
[
1
]
)
{
return
this
-
>
lineTo
(
x
y
)
;
}
rx
=
SkScalarAbs
(
rx
)
;
ry
=
SkScalarAbs
(
ry
)
;
SkVector
midPointDistance
=
srcPts
[
0
]
-
srcPts
[
1
]
;
midPointDistance
*
=
0
.
5f
;
SkMatrix
pointTransform
;
pointTransform
.
setRotate
(
-
angle
)
;
SkPoint
transformedMidPoint
;
pointTransform
.
mapPoints
(
&
transformedMidPoint
&
midPointDistance
1
)
;
SkScalar
squareRx
=
rx
*
rx
;
SkScalar
squareRy
=
ry
*
ry
;
SkScalar
squareX
=
transformedMidPoint
.
fX
*
transformedMidPoint
.
fX
;
SkScalar
squareY
=
transformedMidPoint
.
fY
*
transformedMidPoint
.
fY
;
SkScalar
radiiScale
=
squareX
/
squareRx
+
squareY
/
squareRy
;
if
(
radiiScale
>
1
)
{
radiiScale
=
SkScalarSqrt
(
radiiScale
)
;
rx
*
=
radiiScale
;
ry
*
=
radiiScale
;
}
pointTransform
.
setScale
(
1
/
rx
1
/
ry
)
;
pointTransform
.
preRotate
(
-
angle
)
;
SkPoint
unitPts
[
2
]
;
pointTransform
.
mapPoints
(
unitPts
srcPts
(
int
)
SK_ARRAY_COUNT
(
unitPts
)
)
;
SkVector
delta
=
unitPts
[
1
]
-
unitPts
[
0
]
;
SkScalar
d
=
delta
.
fX
*
delta
.
fX
+
delta
.
fY
*
delta
.
fY
;
SkScalar
scaleFactorSquared
=
SkTMax
(
1
/
d
-
0
.
25f
0
.
f
)
;
SkScalar
scaleFactor
=
SkScalarSqrt
(
scaleFactorSquared
)
;
if
(
SkToBool
(
arcSweep
)
!
=
SkToBool
(
arcLarge
)
)
{
scaleFactor
=
-
scaleFactor
;
}
delta
.
scale
(
scaleFactor
)
;
SkPoint
centerPoint
=
unitPts
[
0
]
+
unitPts
[
1
]
;
centerPoint
*
=
0
.
5f
;
centerPoint
.
offset
(
-
delta
.
fY
delta
.
fX
)
;
unitPts
[
0
]
-
=
centerPoint
;
unitPts
[
1
]
-
=
centerPoint
;
SkScalar
theta1
=
SkScalarATan2
(
unitPts
[
0
]
.
fY
unitPts
[
0
]
.
fX
)
;
SkScalar
theta2
=
SkScalarATan2
(
unitPts
[
1
]
.
fY
unitPts
[
1
]
.
fX
)
;
SkScalar
thetaArc
=
theta2
-
theta1
;
if
(
thetaArc
<
0
&
&
!
arcSweep
)
{
thetaArc
+
=
SK_ScalarPI
*
2
;
}
else
if
(
thetaArc
>
0
&
&
arcSweep
)
{
thetaArc
-
=
SK_ScalarPI
*
2
;
}
if
(
SkScalarAbs
(
thetaArc
)
<
(
SK_ScalarPI
/
(
1000
*
1000
)
)
)
{
return
this
-
>
lineTo
(
x
y
)
;
}
pointTransform
.
setRotate
(
angle
)
;
pointTransform
.
preScale
(
rx
ry
)
;
int
segments
=
SkScalarCeilToInt
(
SkScalarAbs
(
thetaArc
/
(
2
*
SK_ScalarPI
/
3
)
)
)
;
SkScalar
thetaWidth
=
thetaArc
/
segments
;
SkScalar
t
=
SkScalarTan
(
0
.
5f
*
thetaWidth
)
;
if
(
!
SkScalarIsFinite
(
t
)
)
{
return
*
this
;
}
SkScalar
startTheta
=
theta1
;
SkScalar
w
=
SkScalarSqrt
(
SK_ScalarHalf
+
SkScalarCos
(
thetaWidth
)
*
SK_ScalarHalf
)
;
auto
scalar_is_integer
=
[
]
(
SkScalar
scalar
)
-
>
bool
{
return
scalar
=
=
SkScalarFloorToScalar
(
scalar
)
;
}
;
bool
expectIntegers
=
SkScalarNearlyZero
(
SK_ScalarPI
/
2
-
SkScalarAbs
(
thetaWidth
)
)
&
&
scalar_is_integer
(
rx
)
&
&
scalar_is_integer
(
ry
)
&
&
scalar_is_integer
(
x
)
&
&
scalar_is_integer
(
y
)
;
for
(
int
i
=
0
;
i
<
segments
;
+
+
i
)
{
SkScalar
endTheta
=
startTheta
+
thetaWidth
sinEndTheta
=
SkScalarSinSnapToZero
(
endTheta
)
cosEndTheta
=
SkScalarCosSnapToZero
(
endTheta
)
;
unitPts
[
1
]
.
set
(
cosEndTheta
sinEndTheta
)
;
unitPts
[
1
]
+
=
centerPoint
;
unitPts
[
0
]
=
unitPts
[
1
]
;
unitPts
[
0
]
.
offset
(
t
*
sinEndTheta
-
t
*
cosEndTheta
)
;
SkPoint
mapped
[
2
]
;
pointTransform
.
mapPoints
(
mapped
unitPts
(
int
)
SK_ARRAY_COUNT
(
unitPts
)
)
;
if
(
expectIntegers
)
{
for
(
SkPoint
&
point
:
mapped
)
{
point
.
fX
=
SkScalarRoundToScalar
(
point
.
fX
)
;
point
.
fY
=
SkScalarRoundToScalar
(
point
.
fY
)
;
}
}
this
-
>
conicTo
(
mapped
[
0
]
mapped
[
1
]
w
)
;
startTheta
=
endTheta
;
}
return
*
this
;
}
SkPath
&
SkPath
:
:
rArcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
SkPath
:
:
ArcSize
largeArc
SkPath
:
:
Direction
sweep
SkScalar
dx
SkScalar
dy
)
{
SkPoint
currentPoint
;
this
-
>
getLastPt
(
&
currentPoint
)
;
return
this
-
>
arcTo
(
rx
ry
xAxisRotate
largeArc
sweep
currentPoint
.
fX
+
dx
currentPoint
.
fY
+
dy
)
;
}
SkPath
&
SkPath
:
:
addArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
)
{
if
(
oval
.
isEmpty
(
)
|
|
0
=
=
sweepAngle
)
{
return
*
this
;
}
const
SkScalar
kFullCircleAngle
=
SkIntToScalar
(
360
)
;
if
(
sweepAngle
>
=
kFullCircleAngle
|
|
sweepAngle
<
=
-
kFullCircleAngle
)
{
SkScalar
startOver90
=
startAngle
/
90
.
f
;
SkScalar
startOver90I
=
SkScalarRoundToScalar
(
startOver90
)
;
SkScalar
error
=
startOver90
-
startOver90I
;
if
(
SkScalarNearlyEqual
(
error
0
)
)
{
SkScalar
startIndex
=
std
:
:
fmod
(
startOver90I
+
1
.
f
4
.
f
)
;
startIndex
=
startIndex
<
0
?
startIndex
+
4
.
f
:
startIndex
;
return
this
-
>
addOval
(
oval
sweepAngle
>
0
?
kCW_Direction
:
kCCW_Direction
(
unsigned
)
startIndex
)
;
}
}
return
this
-
>
arcTo
(
oval
startAngle
sweepAngle
true
)
;
}
SkPath
&
SkPath
:
:
arcTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
radius
)
{
if
(
radius
=
=
0
)
{
return
this
-
>
lineTo
(
x1
y1
)
;
}
SkPoint
start
;
this
-
>
getLastPt
(
&
start
)
;
SkDVector
befored
afterd
;
befored
.
set
(
{
x1
-
start
.
fX
y1
-
start
.
fY
}
)
.
normalize
(
)
;
afterd
.
set
(
{
x2
-
x1
y2
-
y1
}
)
.
normalize
(
)
;
double
cosh
=
befored
.
dot
(
afterd
)
;
double
sinh
=
befored
.
cross
(
afterd
)
;
if
(
!
befored
.
isFinite
(
)
|
|
!
afterd
.
isFinite
(
)
|
|
SkScalarNearlyZero
(
SkDoubleToScalar
(
sinh
)
)
)
{
return
this
-
>
lineTo
(
x1
y1
)
;
}
SkVector
before
=
befored
.
asSkVector
(
)
;
SkVector
after
=
afterd
.
asSkVector
(
)
;
SkScalar
dist
=
SkScalarAbs
(
SkDoubleToScalar
(
radius
*
(
1
-
cosh
)
/
sinh
)
)
;
SkScalar
xx
=
x1
-
dist
*
before
.
fX
;
SkScalar
yy
=
y1
-
dist
*
before
.
fY
;
after
.
setLength
(
dist
)
;
this
-
>
lineTo
(
xx
yy
)
;
SkScalar
weight
=
SkScalarSqrt
(
SkDoubleToScalar
(
SK_ScalarHalf
+
cosh
*
0
.
5
)
)
;
return
this
-
>
conicTo
(
x1
y1
x1
+
after
.
fX
y1
+
after
.
fY
weight
)
;
}
SkPath
&
SkPath
:
:
addPath
(
const
SkPath
&
path
SkScalar
dx
SkScalar
dy
AddPathMode
mode
)
{
SkMatrix
matrix
;
matrix
.
setTranslate
(
dx
dy
)
;
return
this
-
>
addPath
(
path
matrix
mode
)
;
}
SkPath
&
SkPath
:
:
addPath
(
const
SkPath
&
srcPath
const
SkMatrix
&
matrix
AddPathMode
mode
)
{
const
SkPath
*
src
=
&
srcPath
;
SkTLazy
<
SkPath
>
tmp
;
if
(
this
=
=
src
)
{
src
=
tmp
.
set
(
srcPath
)
;
}
SkPathRef
:
:
Editor
(
&
fPathRef
src
-
>
countVerbs
(
)
src
-
>
countPoints
(
)
)
;
RawIter
iter
(
*
src
)
;
SkPoint
pts
[
4
]
;
Verb
verb
;
SkMatrixPriv
:
:
MapPtsProc
proc
=
SkMatrixPriv
:
:
GetMapPtsProc
(
matrix
)
;
bool
firstVerb
=
true
;
while
(
(
verb
=
iter
.
next
(
pts
)
)
!
=
kDone_Verb
)
{
switch
(
verb
)
{
case
kMove_Verb
:
proc
(
matrix
&
pts
[
0
]
&
pts
[
0
]
1
)
;
if
(
firstVerb
&
&
mode
=
=
kExtend_AddPathMode
&
&
!
isEmpty
(
)
)
{
injectMoveToIfNeeded
(
)
;
SkPoint
lastPt
;
if
(
fLastMoveToIndex
<
0
|
|
!
this
-
>
getLastPt
(
&
lastPt
)
|
|
lastPt
!
=
pts
[
0
]
)
{
this
-
>
lineTo
(
pts
[
0
]
)
;
}
}
else
{
this
-
>
moveTo
(
pts
[
0
]
)
;
}
break
;
case
kLine_Verb
:
proc
(
matrix
&
pts
[
1
]
&
pts
[
1
]
1
)
;
this
-
>
lineTo
(
pts
[
1
]
)
;
break
;
case
kQuad_Verb
:
proc
(
matrix
&
pts
[
1
]
&
pts
[
1
]
2
)
;
this
-
>
quadTo
(
pts
[
1
]
pts
[
2
]
)
;
break
;
case
kConic_Verb
:
proc
(
matrix
&
pts
[
1
]
&
pts
[
1
]
2
)
;
this
-
>
conicTo
(
pts
[
1
]
pts
[
2
]
iter
.
conicWeight
(
)
)
;
break
;
case
kCubic_Verb
:
proc
(
matrix
&
pts
[
1
]
&
pts
[
1
]
3
)
;
this
-
>
cubicTo
(
pts
[
1
]
pts
[
2
]
pts
[
3
]
)
;
break
;
case
kClose_Verb
:
this
-
>
close
(
)
;
break
;
default
:
SkDEBUGFAIL
(
"
unknown
verb
"
)
;
}
firstVerb
=
false
;
}
return
*
this
;
}
static
int
pts_in_verb
(
unsigned
verb
)
{
static
const
uint8_t
gPtsInVerb
[
]
=
{
1
1
2
2
3
0
0
}
;
SkASSERT
(
verb
<
SK_ARRAY_COUNT
(
gPtsInVerb
)
)
;
return
gPtsInVerb
[
verb
]
;
}
SkPath
&
SkPath
:
:
reversePathTo
(
const
SkPath
&
path
)
{
if
(
path
.
fPathRef
-
>
fVerbs
.
count
(
)
=
=
0
)
{
return
*
this
;
}
const
uint8_t
*
verbs
=
path
.
fPathRef
-
>
verbsEnd
(
)
;
const
uint8_t
*
verbsBegin
=
path
.
fPathRef
-
>
verbsBegin
(
)
;
SkASSERT
(
verbsBegin
[
0
]
=
=
kMove_Verb
)
;
const
SkPoint
*
pts
=
path
.
fPathRef
-
>
pointsEnd
(
)
-
1
;
const
SkScalar
*
conicWeights
=
path
.
fPathRef
-
>
conicWeightsEnd
(
)
;
while
(
verbs
>
verbsBegin
)
{
uint8_t
v
=
*
-
-
verbs
;
pts
-
=
pts_in_verb
(
v
)
;
switch
(
v
)
{
case
kMove_Verb
:
return
*
this
;
case
kLine_Verb
:
this
-
>
lineTo
(
pts
[
0
]
)
;
break
;
case
kQuad_Verb
:
this
-
>
quadTo
(
pts
[
1
]
pts
[
0
]
)
;
break
;
case
kConic_Verb
:
this
-
>
conicTo
(
pts
[
1
]
pts
[
0
]
*
-
-
conicWeights
)
;
break
;
case
kCubic_Verb
:
this
-
>
cubicTo
(
pts
[
2
]
pts
[
1
]
pts
[
0
]
)
;
break
;
case
kClose_Verb
:
break
;
default
:
SkDEBUGFAIL
(
"
bad
verb
"
)
;
break
;
}
}
return
*
this
;
}
SkPath
&
SkPath
:
:
reverseAddPath
(
const
SkPath
&
srcPath
)
{
const
SkPath
*
src
=
&
srcPath
;
SkTLazy
<
SkPath
>
tmp
;
if
(
this
=
=
src
)
{
src
=
tmp
.
set
(
srcPath
)
;
}
SkPathRef
:
:
Editor
ed
(
&
fPathRef
src
-
>
countVerbs
(
)
src
-
>
countPoints
(
)
)
;
const
uint8_t
*
verbsBegin
=
src
-
>
fPathRef
-
>
verbsBegin
(
)
;
const
uint8_t
*
verbs
=
src
-
>
fPathRef
-
>
verbsEnd
(
)
;
const
SkPoint
*
pts
=
src
-
>
fPathRef
-
>
pointsEnd
(
)
;
const
SkScalar
*
conicWeights
=
src
-
>
fPathRef
-
>
conicWeightsEnd
(
)
;
bool
needMove
=
true
;
bool
needClose
=
false
;
while
(
verbs
>
verbsBegin
)
{
uint8_t
v
=
*
-
-
verbs
;
int
n
=
pts_in_verb
(
v
)
;
if
(
needMove
)
{
-
-
pts
;
this
-
>
moveTo
(
pts
-
>
fX
pts
-
>
fY
)
;
needMove
=
false
;
}
pts
-
=
n
;
switch
(
v
)
{
case
kMove_Verb
:
if
(
needClose
)
{
this
-
>
close
(
)
;
needClose
=
false
;
}
needMove
=
true
;
pts
+
=
1
;
break
;
case
kLine_Verb
:
this
-
>
lineTo
(
pts
[
0
]
)
;
break
;
case
kQuad_Verb
:
this
-
>
quadTo
(
pts
[
1
]
pts
[
0
]
)
;
break
;
case
kConic_Verb
:
this
-
>
conicTo
(
pts
[
1
]
pts
[
0
]
*
-
-
conicWeights
)
;
break
;
case
kCubic_Verb
:
this
-
>
cubicTo
(
pts
[
2
]
pts
[
1
]
pts
[
0
]
)
;
break
;
case
kClose_Verb
:
needClose
=
true
;
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
verb
"
)
;
}
}
return
*
this
;
}
void
SkPath
:
:
offset
(
SkScalar
dx
SkScalar
dy
SkPath
*
dst
)
const
{
SkMatrix
matrix
;
matrix
.
setTranslate
(
dx
dy
)
;
this
-
>
transform
(
matrix
dst
)
;
}
static
void
subdivide_cubic_to
(
SkPath
*
path
const
SkPoint
pts
[
4
]
int
level
=
2
)
{
if
(
-
-
level
>
=
0
)
{
SkPoint
tmp
[
7
]
;
SkChopCubicAtHalf
(
pts
tmp
)
;
subdivide_cubic_to
(
path
&
tmp
[
0
]
level
)
;
subdivide_cubic_to
(
path
&
tmp
[
3
]
level
)
;
}
else
{
path
-
>
cubicTo
(
pts
[
1
]
pts
[
2
]
pts
[
3
]
)
;
}
}
void
SkPath
:
:
transform
(
const
SkMatrix
&
matrix
SkPath
*
dst
)
const
{
if
(
matrix
.
isIdentity
(
)
)
{
if
(
dst
!
=
nullptr
&
&
dst
!
=
this
)
{
*
dst
=
*
this
;
}
return
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
dst
=
=
nullptr
)
{
dst
=
(
SkPath
*
)
this
;
}
if
(
matrix
.
hasPerspective
(
)
)
{
SkPath
tmp
;
tmp
.
fFillType
=
fFillType
;
SkPath
:
:
Iter
iter
(
*
this
false
)
;
SkPoint
pts
[
4
]
;
SkPath
:
:
Verb
verb
;
while
(
(
verb
=
iter
.
next
(
pts
)
)
!
=
kDone_Verb
)
{
switch
(
verb
)
{
case
kMove_Verb
:
tmp
.
moveTo
(
pts
[
0
]
)
;
break
;
case
kLine_Verb
:
tmp
.
lineTo
(
pts
[
1
]
)
;
break
;
case
kQuad_Verb
:
tmp
.
conicTo
(
pts
[
1
]
pts
[
2
]
SkConic
:
:
TransformW
(
pts
SK_Scalar1
matrix
)
)
;
break
;
case
kConic_Verb
:
tmp
.
conicTo
(
pts
[
1
]
pts
[
2
]
SkConic
:
:
TransformW
(
pts
iter
.
conicWeight
(
)
matrix
)
)
;
break
;
case
kCubic_Verb
:
subdivide_cubic_to
(
&
tmp
pts
)
;
break
;
case
kClose_Verb
:
tmp
.
close
(
)
;
break
;
default
:
SkDEBUGFAIL
(
"
unknown
verb
"
)
;
break
;
}
}
dst
-
>
swap
(
tmp
)
;
SkPathRef
:
:
Editor
ed
(
&
dst
-
>
fPathRef
)
;
matrix
.
mapPoints
(
ed
.
writablePoints
(
)
ed
.
pathRef
(
)
-
>
countPoints
(
)
)
;
dst
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
}
else
{
Convexity
convexity
=
this
-
>
getConvexityOrUnknown
(
)
;
SkPathRef
:
:
CreateTransformedCopy
(
&
dst
-
>
fPathRef
*
fPathRef
.
get
(
)
matrix
)
;
if
(
this
!
=
dst
)
{
dst
-
>
fLastMoveToIndex
=
fLastMoveToIndex
;
dst
-
>
fFillType
=
fFillType
;
dst
-
>
fIsVolatile
=
fIsVolatile
;
}
if
(
matrix
.
isScaleTranslate
(
)
&
&
SkPathPriv
:
:
IsAxisAligned
(
*
this
)
)
{
dst
-
>
setConvexity
(
convexity
)
;
}
else
{
dst
-
>
setConvexity
(
kUnknown_Convexity
)
;
}
if
(
this
-
>
getFirstDirection
(
)
=
=
SkPathPriv
:
:
kUnknown_FirstDirection
)
{
dst
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
}
else
{
SkScalar
det2x2
=
matrix
.
get
(
SkMatrix
:
:
kMScaleX
)
*
matrix
.
get
(
SkMatrix
:
:
kMScaleY
)
-
matrix
.
get
(
SkMatrix
:
:
kMSkewX
)
*
matrix
.
get
(
SkMatrix
:
:
kMSkewY
)
;
if
(
det2x2
<
0
)
{
dst
-
>
setFirstDirection
(
SkPathPriv
:
:
OppositeFirstDirection
(
(
SkPathPriv
:
:
FirstDirection
)
this
-
>
getFirstDirection
(
)
)
)
;
}
else
if
(
det2x2
>
0
)
{
dst
-
>
setFirstDirection
(
this
-
>
getFirstDirection
(
)
)
;
}
else
{
dst
-
>
setFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
;
}
}
SkDEBUGCODE
(
dst
-
>
validate
(
)
;
)
}
}
SkPath
:
:
Iter
:
:
Iter
(
)
{
#
ifdef
SK_DEBUG
fPts
=
nullptr
;
fConicWeights
=
nullptr
;
fMoveTo
.
fX
=
fMoveTo
.
fY
=
fLastPt
.
fX
=
fLastPt
.
fY
=
0
;
fForceClose
=
fCloseLine
=
false
;
fSegmentState
=
kEmptyContour_SegmentState
;
#
endif
fVerbs
=
nullptr
;
fVerbStop
=
nullptr
;
fNeedClose
=
false
;
}
SkPath
:
:
Iter
:
:
Iter
(
const
SkPath
&
path
bool
forceClose
)
{
this
-
>
setPath
(
path
forceClose
)
;
}
void
SkPath
:
:
Iter
:
:
setPath
(
const
SkPath
&
path
bool
forceClose
)
{
fPts
=
path
.
fPathRef
-
>
points
(
)
;
fVerbs
=
path
.
fPathRef
-
>
verbsBegin
(
)
;
fVerbStop
=
path
.
fPathRef
-
>
verbsEnd
(
)
;
fConicWeights
=
path
.
fPathRef
-
>
conicWeights
(
)
;
if
(
fConicWeights
)
{
fConicWeights
-
=
1
;
}
fLastPt
.
fX
=
fLastPt
.
fY
=
0
;
fMoveTo
.
fX
=
fMoveTo
.
fY
=
0
;
fForceClose
=
SkToU8
(
forceClose
)
;
fNeedClose
=
false
;
fSegmentState
=
kEmptyContour_SegmentState
;
}
bool
SkPath
:
:
Iter
:
:
isClosedContour
(
)
const
{
if
(
fVerbs
=
=
nullptr
|
|
fVerbs
=
=
fVerbStop
)
{
return
false
;
}
if
(
fForceClose
)
{
return
true
;
}
const
uint8_t
*
verbs
=
fVerbs
;
const
uint8_t
*
stop
=
fVerbStop
;
if
(
kMove_Verb
=
=
*
verbs
)
{
verbs
+
=
1
;
}
while
(
verbs
<
stop
)
{
unsigned
v
=
*
verbs
+
+
;
if
(
kMove_Verb
=
=
v
)
{
break
;
}
if
(
kClose_Verb
=
=
v
)
{
return
true
;
}
}
return
false
;
}
SkPath
:
:
Verb
SkPath
:
:
Iter
:
:
autoClose
(
SkPoint
pts
[
2
]
)
{
SkASSERT
(
pts
)
;
if
(
fLastPt
!
=
fMoveTo
)
{
if
(
SkScalarIsNaN
(
fLastPt
.
fX
)
|
|
SkScalarIsNaN
(
fLastPt
.
fY
)
|
|
SkScalarIsNaN
(
fMoveTo
.
fX
)
|
|
SkScalarIsNaN
(
fMoveTo
.
fY
)
)
{
return
kClose_Verb
;
}
pts
[
0
]
=
fLastPt
;
pts
[
1
]
=
fMoveTo
;
fLastPt
=
fMoveTo
;
fCloseLine
=
true
;
return
kLine_Verb
;
}
else
{
pts
[
0
]
=
fMoveTo
;
return
kClose_Verb
;
}
}
const
SkPoint
&
SkPath
:
:
Iter
:
:
cons_moveTo
(
)
{
if
(
fSegmentState
=
=
kAfterMove_SegmentState
)
{
fSegmentState
=
kAfterPrimitive_SegmentState
;
return
fMoveTo
;
}
SkASSERT
(
fSegmentState
=
=
kAfterPrimitive_SegmentState
)
;
return
fPts
[
-
1
]
;
}
SkPath
:
:
Verb
SkPath
:
:
Iter
:
:
next
(
SkPoint
ptsParam
[
4
]
)
{
SkASSERT
(
ptsParam
)
;
if
(
fVerbs
=
=
fVerbStop
)
{
if
(
fNeedClose
&
&
fSegmentState
=
=
kAfterPrimitive_SegmentState
)
{
if
(
kLine_Verb
=
=
this
-
>
autoClose
(
ptsParam
)
)
{
return
kLine_Verb
;
}
fNeedClose
=
false
;
return
kClose_Verb
;
}
return
kDone_Verb
;
}
unsigned
verb
=
*
fVerbs
+
+
;
const
SkPoint
*
SK_RESTRICT
srcPts
=
fPts
;
SkPoint
*
SK_RESTRICT
pts
=
ptsParam
;
switch
(
verb
)
{
case
kMove_Verb
:
if
(
fNeedClose
)
{
fVerbs
-
-
;
verb
=
this
-
>
autoClose
(
pts
)
;
if
(
verb
=
=
kClose_Verb
)
{
fNeedClose
=
false
;
}
return
(
Verb
)
verb
;
}
if
(
fVerbs
=
=
fVerbStop
)
{
return
kDone_Verb
;
}
fMoveTo
=
*
srcPts
;
pts
[
0
]
=
*
srcPts
;
srcPts
+
=
1
;
fSegmentState
=
kAfterMove_SegmentState
;
fLastPt
=
fMoveTo
;
fNeedClose
=
fForceClose
;
break
;
case
kLine_Verb
:
pts
[
0
]
=
this
-
>
cons_moveTo
(
)
;
pts
[
1
]
=
srcPts
[
0
]
;
fLastPt
=
srcPts
[
0
]
;
fCloseLine
=
false
;
srcPts
+
=
1
;
break
;
case
kConic_Verb
:
fConicWeights
+
=
1
;
case
kQuad_Verb
:
pts
[
0
]
=
this
-
>
cons_moveTo
(
)
;
memcpy
(
&
pts
[
1
]
srcPts
2
*
sizeof
(
SkPoint
)
)
;
fLastPt
=
srcPts
[
1
]
;
srcPts
+
=
2
;
break
;
case
kCubic_Verb
:
pts
[
0
]
=
this
-
>
cons_moveTo
(
)
;
memcpy
(
&
pts
[
1
]
srcPts
3
*
sizeof
(
SkPoint
)
)
;
fLastPt
=
srcPts
[
2
]
;
srcPts
+
=
3
;
break
;
case
kClose_Verb
:
verb
=
this
-
>
autoClose
(
pts
)
;
if
(
verb
=
=
kLine_Verb
)
{
fVerbs
-
-
;
}
else
{
fNeedClose
=
false
;
fSegmentState
=
kEmptyContour_SegmentState
;
}
fLastPt
=
fMoveTo
;
break
;
}
fPts
=
srcPts
;
return
(
Verb
)
verb
;
}
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
src
/
core
/
SkStringUtils
.
h
"
static
void
append_params
(
SkString
*
str
const
char
label
[
]
const
SkPoint
pts
[
]
int
count
SkScalarAsStringType
strType
SkScalar
conicWeight
=
-
12345
)
{
str
-
>
append
(
label
)
;
str
-
>
append
(
"
(
"
)
;
const
SkScalar
*
values
=
&
pts
[
0
]
.
fX
;
count
*
=
2
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkAppendScalar
(
str
values
[
i
]
strType
)
;
if
(
i
<
count
-
1
)
{
str
-
>
append
(
"
"
)
;
}
}
if
(
conicWeight
!
=
-
12345
)
{
str
-
>
append
(
"
"
)
;
SkAppendScalar
(
str
conicWeight
strType
)
;
}
str
-
>
append
(
"
)
;
"
)
;
if
(
kHex_SkScalarAsStringType
=
=
strType
)
{
str
-
>
append
(
"
/
/
"
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkAppendScalarDec
(
str
values
[
i
]
)
;
if
(
i
<
count
-
1
)
{
str
-
>
append
(
"
"
)
;
}
}
if
(
conicWeight
>
=
0
)
{
str
-
>
append
(
"
"
)
;
SkAppendScalarDec
(
str
conicWeight
)
;
}
}
str
-
>
append
(
"
\
n
"
)
;
}
void
SkPath
:
:
dump
(
SkWStream
*
wStream
bool
forceClose
bool
dumpAsHex
)
const
{
SkScalarAsStringType
asType
=
dumpAsHex
?
kHex_SkScalarAsStringType
:
kDec_SkScalarAsStringType
;
Iter
iter
(
*
this
forceClose
)
;
SkPoint
pts
[
4
]
;
Verb
verb
;
SkString
builder
;
char
const
*
const
gFillTypeStrs
[
]
=
{
"
Winding
"
"
EvenOdd
"
"
InverseWinding
"
"
InverseEvenOdd
"
}
;
builder
.
printf
(
"
path
.
setFillType
(
SkPath
:
:
k
%
s_FillType
)
;
\
n
"
gFillTypeStrs
[
(
int
)
this
-
>
getFillType
(
)
]
)
;
while
(
(
verb
=
iter
.
next
(
pts
)
)
!
=
kDone_Verb
)
{
switch
(
verb
)
{
case
kMove_Verb
:
append_params
(
&
builder
"
path
.
moveTo
"
&
pts
[
0
]
1
asType
)
;
break
;
case
kLine_Verb
:
append_params
(
&
builder
"
path
.
lineTo
"
&
pts
[
1
]
1
asType
)
;
break
;
case
kQuad_Verb
:
append_params
(
&
builder
"
path
.
quadTo
"
&
pts
[
1
]
2
asType
)
;
break
;
case
kConic_Verb
:
append_params
(
&
builder
"
path
.
conicTo
"
&
pts
[
1
]
2
asType
iter
.
conicWeight
(
)
)
;
break
;
case
kCubic_Verb
:
append_params
(
&
builder
"
path
.
cubicTo
"
&
pts
[
1
]
3
asType
)
;
break
;
case
kClose_Verb
:
builder
.
append
(
"
path
.
close
(
)
;
\
n
"
)
;
break
;
default
:
SkDebugf
(
"
path
:
UNKNOWN
VERB
%
d
aborting
dump
.
.
.
\
n
"
verb
)
;
verb
=
kDone_Verb
;
break
;
}
if
(
!
wStream
&
&
builder
.
size
(
)
)
{
SkDebugf
(
"
%
s
"
builder
.
c_str
(
)
)
;
builder
.
reset
(
)
;
}
}
if
(
wStream
)
{
wStream
-
>
writeText
(
builder
.
c_str
(
)
)
;
}
}
void
SkPath
:
:
dump
(
)
const
{
this
-
>
dump
(
nullptr
false
false
)
;
}
void
SkPath
:
:
dumpHex
(
)
const
{
this
-
>
dump
(
nullptr
false
true
)
;
}
bool
SkPath
:
:
isValidImpl
(
)
const
{
if
(
(
fFillType
&
~
3
)
!
=
0
)
{
return
false
;
}
#
ifdef
SK_DEBUG_PATH
if
(
!
fBoundsIsDirty
)
{
SkRect
bounds
;
bool
isFinite
=
compute_pt_bounds
(
&
bounds
*
fPathRef
.
get
(
)
)
;
if
(
SkToBool
(
fIsFinite
)
!
=
isFinite
)
{
return
false
;
}
if
(
fPathRef
-
>
countPoints
(
)
<
=
1
)
{
if
(
!
bounds
.
isEmpty
(
)
|
|
!
fBounds
.
isEmpty
(
)
)
{
return
false
;
}
}
else
{
if
(
bounds
.
isEmpty
(
)
)
{
if
(
!
fBounds
.
isEmpty
(
)
)
{
return
false
;
}
}
else
{
if
(
!
fBounds
.
isEmpty
(
)
)
{
if
(
!
fBounds
.
contains
(
bounds
)
)
{
return
false
;
}
}
}
}
}
#
endif
return
true
;
}
#
ifdef
SK_LEGACY_PATH_CONVEXITY
static
int
sign
(
SkScalar
x
)
{
return
x
<
0
;
}
#
define
kValueNeverReturnedBySign
2
enum
DirChange
{
kLeft_DirChange
kRight_DirChange
kStraight_DirChange
kBackwards_DirChange
kInvalid_DirChange
}
;
static
bool
almost_equal
(
SkScalar
compA
SkScalar
compB
)
{
const
int
epsilon
=
16
;
if
(
!
SkScalarIsFinite
(
compA
)
|
|
!
SkScalarIsFinite
(
compB
)
)
{
return
false
;
}
int
aBits
=
SkFloatAs2sCompliment
(
compA
)
;
int
bBits
=
SkFloatAs2sCompliment
(
compB
)
;
return
aBits
<
bBits
+
epsilon
&
&
bBits
<
aBits
+
epsilon
;
}
struct
Convexicator
{
Convexicator
(
)
:
fPtCount
(
0
)
fConvexity
(
SkPath
:
:
kConvex_Convexity
)
fFirstDirection
(
SkPathPriv
:
:
kUnknown_FirstDirection
)
fIsFinite
(
true
)
fIsCurve
(
false
)
fBackwards
(
false
)
{
fExpectedDir
=
kInvalid_DirChange
;
fPriorPt
.
set
(
0
0
)
;
fLastPt
.
set
(
0
0
)
;
fCurrPt
.
set
(
0
0
)
;
fLastVec
.
set
(
0
0
)
;
fFirstVec
.
set
(
0
0
)
;
fDx
=
fDy
=
0
;
fSx
=
fSy
=
kValueNeverReturnedBySign
;
}
SkPath
:
:
Convexity
getConvexity
(
)
const
{
return
fConvexity
;
}
SkPathPriv
:
:
FirstDirection
getFirstDirection
(
)
const
{
return
fFirstDirection
;
}
void
addPt
(
const
SkPoint
&
pt
)
{
if
(
SkPath
:
:
kConcave_Convexity
=
=
fConvexity
|
|
!
fIsFinite
)
{
return
;
}
if
(
0
=
=
fPtCount
)
{
fCurrPt
=
pt
;
+
+
fPtCount
;
}
else
{
SkVector
vec
=
pt
-
fCurrPt
;
SkScalar
lengthSqd
=
SkPointPriv
:
:
LengthSqd
(
vec
)
;
if
(
!
SkScalarIsFinite
(
lengthSqd
)
)
{
fIsFinite
=
false
;
}
else
if
(
lengthSqd
)
{
fPriorPt
=
fLastPt
;
fLastPt
=
fCurrPt
;
fCurrPt
=
pt
;
if
(
+
+
fPtCount
=
=
2
)
{
fFirstVec
=
fLastVec
=
vec
;
}
else
{
SkASSERT
(
fPtCount
>
2
)
;
this
-
>
addVec
(
vec
)
;
}
int
sx
=
sign
(
vec
.
fX
)
;
int
sy
=
sign
(
vec
.
fY
)
;
fDx
+
=
(
sx
!
=
fSx
)
;
fDy
+
=
(
sy
!
=
fSy
)
;
fSx
=
sx
;
fSy
=
sy
;
if
(
fDx
>
3
|
|
fDy
>
3
)
{
fConvexity
=
SkPath
:
:
kConcave_Convexity
;
}
}
}
}
void
close
(
)
{
if
(
fPtCount
>
2
)
{
this
-
>
addVec
(
fFirstVec
)
;
}
}
DirChange
directionChange
(
const
SkVector
&
curVec
)
{
SkScalar
cross
=
SkPoint
:
:
CrossProduct
(
fLastVec
curVec
)
;
SkScalar
smallest
=
SkTMin
(
fCurrPt
.
fX
SkTMin
(
fCurrPt
.
fY
SkTMin
(
fLastPt
.
fX
fLastPt
.
fY
)
)
)
;
SkScalar
largest
=
SkTMax
(
fCurrPt
.
fX
SkTMax
(
fCurrPt
.
fY
SkTMax
(
fLastPt
.
fX
fLastPt
.
fY
)
)
)
;
largest
=
SkTMax
(
largest
-
smallest
)
;
if
(
!
almost_equal
(
largest
largest
+
cross
)
)
{
int
sign
=
SkScalarSignAsInt
(
cross
)
;
if
(
sign
)
{
return
(
1
=
=
sign
)
?
kRight_DirChange
:
kLeft_DirChange
;
}
}
if
(
cross
)
{
double
dLastVecX
=
SkScalarToDouble
(
fLastPt
.
fX
)
-
SkScalarToDouble
(
fPriorPt
.
fX
)
;
double
dLastVecY
=
SkScalarToDouble
(
fLastPt
.
fY
)
-
SkScalarToDouble
(
fPriorPt
.
fY
)
;
double
dCurrVecX
=
SkScalarToDouble
(
fCurrPt
.
fX
)
-
SkScalarToDouble
(
fLastPt
.
fX
)
;
double
dCurrVecY
=
SkScalarToDouble
(
fCurrPt
.
fY
)
-
SkScalarToDouble
(
fLastPt
.
fY
)
;
double
dCross
=
dLastVecX
*
dCurrVecY
-
dLastVecY
*
dCurrVecX
;
if
(
!
approximately_zero_when_compared_to
(
dCross
SkScalarToDouble
(
largest
)
)
)
{
int
sign
=
SkScalarSignAsInt
(
SkDoubleToScalar
(
dCross
)
)
;
if
(
sign
)
{
return
(
1
=
=
sign
)
?
kRight_DirChange
:
kLeft_DirChange
;
}
}
}
if
(
!
SkScalarNearlyZero
(
SkPointPriv
:
:
LengthSqd
(
fLastVec
)
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
)
&
&
!
SkScalarNearlyZero
(
SkPointPriv
:
:
LengthSqd
(
curVec
)
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
)
&
&
fLastVec
.
dot
(
curVec
)
<
0
.
0f
)
{
return
kBackwards_DirChange
;
}
return
kStraight_DirChange
;
}
bool
hasBackwards
(
)
const
{
return
fBackwards
;
}
bool
isFinite
(
)
const
{
return
fIsFinite
;
}
void
setCurve
(
bool
isCurve
)
{
fIsCurve
=
isCurve
;
}
private
:
void
addVec
(
const
SkVector
&
vec
)
{
SkASSERT
(
vec
.
fX
|
|
vec
.
fY
)
;
DirChange
dir
=
this
-
>
directionChange
(
vec
)
;
switch
(
dir
)
{
case
kLeft_DirChange
:
case
kRight_DirChange
:
if
(
kInvalid_DirChange
=
=
fExpectedDir
)
{
fExpectedDir
=
dir
;
fFirstDirection
=
(
kRight_DirChange
=
=
dir
)
?
SkPathPriv
:
:
kCW_FirstDirection
:
SkPathPriv
:
:
kCCW_FirstDirection
;
}
else
if
(
dir
!
=
fExpectedDir
)
{
fConvexity
=
SkPath
:
:
kConcave_Convexity
;
fFirstDirection
=
SkPathPriv
:
:
kUnknown_FirstDirection
;
}
fLastVec
=
vec
;
break
;
case
kStraight_DirChange
:
break
;
case
kBackwards_DirChange
:
if
(
fIsCurve
)
{
fExpectedDir
=
dir
;
}
fLastVec
=
vec
;
fBackwards
=
true
;
break
;
case
kInvalid_DirChange
:
SK_ABORT
(
"
Use
of
invalid
direction
change
flag
"
)
;
break
;
}
}
SkPoint
fPriorPt
;
SkPoint
fLastPt
;
SkPoint
fCurrPt
;
SkVector
fLastVec
fFirstVec
;
int
fPtCount
;
DirChange
fExpectedDir
;
SkPath
:
:
Convexity
fConvexity
;
SkPathPriv
:
:
FirstDirection
fFirstDirection
;
int
fDx
fDy
fSx
fSy
;
bool
fIsFinite
;
bool
fIsCurve
;
bool
fBackwards
;
}
;
SkPath
:
:
Convexity
SkPath
:
:
internalGetConvexity
(
)
const
{
auto
c
=
this
-
>
getConvexityOrUnknown
(
)
;
if
(
c
!
=
kUnknown_Convexity
)
{
return
c
;
}
SkPoint
pts
[
4
]
;
SkPath
:
:
Verb
verb
;
SkPath
:
:
Iter
iter
(
*
this
true
)
;
int
contourCount
=
0
;
int
count
;
Convexicator
state
;
if
(
!
isFinite
(
)
)
{
return
kUnknown_Convexity
;
}
while
(
(
verb
=
iter
.
next
(
pts
false
false
)
)
!
=
SkPath
:
:
kDone_Verb
)
{
switch
(
verb
)
{
case
kMove_Verb
:
if
(
+
+
contourCount
>
1
)
{
this
-
>
setConvexity
(
kConcave_Convexity
)
;
return
kConcave_Convexity
;
}
pts
[
1
]
=
pts
[
0
]
;
case
kLine_Verb
:
count
=
1
;
state
.
setCurve
(
false
)
;
break
;
case
kQuad_Verb
:
case
kConic_Verb
:
case
kCubic_Verb
:
count
=
2
+
(
kCubic_Verb
=
=
verb
)
;
state
.
setCurve
(
true
)
;
break
;
case
kClose_Verb
:
state
.
setCurve
(
false
)
;
state
.
close
(
)
;
count
=
0
;
break
;
default
:
SkDEBUGFAIL
(
"
bad
verb
"
)
;
this
-
>
setConvexity
(
kConcave_Convexity
)
;
return
kConcave_Convexity
;
}
for
(
int
i
=
1
;
i
<
=
count
;
i
+
+
)
{
state
.
addPt
(
pts
[
i
]
)
;
}
if
(
!
state
.
isFinite
(
)
)
{
return
kUnknown_Convexity
;
}
if
(
kConcave_Convexity
=
=
state
.
getConvexity
(
)
)
{
this
-
>
setConvexity
(
kConcave_Convexity
)
;
return
kConcave_Convexity
;
}
}
this
-
>
setConvexity
(
state
.
getConvexity
(
)
)
;
if
(
this
-
>
getConvexityOrUnknown
(
)
=
=
kConvex_Convexity
&
&
this
-
>
getFirstDirection
(
)
=
=
SkPathPriv
:
:
kUnknown_FirstDirection
)
{
if
(
state
.
getFirstDirection
(
)
=
=
SkPathPriv
:
:
kUnknown_FirstDirection
&
&
!
this
-
>
getBounds
(
)
.
isEmpty
(
)
&
&
!
state
.
hasBackwards
(
)
)
{
this
-
>
setConvexity
(
Convexity
:
:
kConcave_Convexity
)
;
}
else
{
this
-
>
setFirstDirection
(
state
.
getFirstDirection
(
)
)
;
}
}
return
this
-
>
getConvexityOrUnknown
(
)
;
}
#
else
static
int
sign
(
SkScalar
x
)
{
return
x
<
0
;
}
#
define
kValueNeverReturnedBySign
2
enum
DirChange
{
kUnknown_DirChange
kLeft_DirChange
kRight_DirChange
kStraight_DirChange
kBackwards_DirChange
kInvalid_DirChange
}
;
static
bool
almost_equal
(
SkScalar
compA
SkScalar
compB
)
{
const
int
epsilon
=
16
;
if
(
!
SkScalarIsFinite
(
compA
)
|
|
!
SkScalarIsFinite
(
compB
)
)
{
return
false
;
}
int
aBits
=
SkFloatAs2sCompliment
(
compA
)
;
int
bBits
=
SkFloatAs2sCompliment
(
compB
)
;
return
aBits
<
bBits
+
epsilon
&
&
bBits
<
aBits
+
epsilon
;
}
struct
Convexicator
{
SkPathPriv
:
:
FirstDirection
getFirstDirection
(
)
const
{
return
fFirstDirection
;
}
void
setMovePt
(
const
SkPoint
&
pt
)
{
fPriorPt
=
fLastPt
=
fCurrPt
=
pt
;
}
bool
addPt
(
const
SkPoint
&
pt
)
{
if
(
fCurrPt
=
=
pt
)
{
return
true
;
}
fCurrPt
=
pt
;
if
(
fPriorPt
=
=
fLastPt
)
{
fLastVec
=
fCurrPt
-
fLastPt
;
fFirstPt
=
pt
;
}
else
if
(
!
this
-
>
addVec
(
fCurrPt
-
fLastPt
)
)
{
return
false
;
}
fPriorPt
=
fLastPt
;
fLastPt
=
fCurrPt
;
return
true
;
}
static
SkPath
:
:
Convexity
BySign
(
const
SkPoint
points
[
]
int
count
)
{
const
SkPoint
*
last
=
points
+
count
;
SkPoint
currPt
=
*
points
+
+
;
SkPoint
firstPt
=
currPt
;
int
dxes
=
0
;
int
dyes
=
0
;
int
lastSx
=
kValueNeverReturnedBySign
;
int
lastSy
=
kValueNeverReturnedBySign
;
for
(
int
outerLoop
=
0
;
outerLoop
<
2
;
+
+
outerLoop
)
{
while
(
points
!
=
last
)
{
SkVector
vec
=
*
points
-
currPt
;
if
(
!
vec
.
isZero
(
)
)
{
if
(
!
vec
.
isFinite
(
)
)
{
return
SkPath
:
:
kUnknown_Convexity
;
}
int
sx
=
sign
(
vec
.
fX
)
;
int
sy
=
sign
(
vec
.
fY
)
;
dxes
+
=
(
sx
!
=
lastSx
)
;
dyes
+
=
(
sy
!
=
lastSy
)
;
if
(
dxes
>
3
|
|
dyes
>
3
)
{
return
SkPath
:
:
kConcave_Convexity
;
}
lastSx
=
sx
;
lastSy
=
sy
;
}
currPt
=
*
points
+
+
;
if
(
outerLoop
)
{
break
;
}
}
points
=
&
firstPt
;
}
return
SkPath
:
:
kConvex_Convexity
;
}
bool
close
(
)
{
return
this
-
>
addPt
(
fFirstPt
)
;
}
bool
isFinite
(
)
const
{
return
fIsFinite
;
}
int
reversals
(
)
const
{
return
fReversals
;
}
private
:
DirChange
directionChange
(
const
SkVector
&
curVec
)
{
SkScalar
cross
=
SkPoint
:
:
CrossProduct
(
fLastVec
curVec
)
;
if
(
!
SkScalarIsFinite
(
cross
)
)
{
return
kUnknown_DirChange
;
}
SkScalar
smallest
=
SkTMin
(
fCurrPt
.
fX
SkTMin
(
fCurrPt
.
fY
SkTMin
(
fLastPt
.
fX
fLastPt
.
fY
)
)
)
;
SkScalar
largest
=
SkTMax
(
fCurrPt
.
fX
SkTMax
(
fCurrPt
.
fY
SkTMax
(
fLastPt
.
fX
fLastPt
.
fY
)
)
)
;
largest
=
SkTMax
(
largest
-
smallest
)
;
if
(
almost_equal
(
largest
largest
+
cross
)
)
{
constexpr
SkScalar
nearlyZeroSqd
=
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
;
if
(
SkScalarNearlyZero
(
SkPointPriv
:
:
LengthSqd
(
fLastVec
)
nearlyZeroSqd
)
|
|
SkScalarNearlyZero
(
SkPointPriv
:
:
LengthSqd
(
curVec
)
nearlyZeroSqd
)
)
{
return
kUnknown_DirChange
;
}
return
fLastVec
.
dot
(
curVec
)
<
0
?
kBackwards_DirChange
:
kStraight_DirChange
;
}
return
1
=
=
SkScalarSignAsInt
(
cross
)
?
kRight_DirChange
:
kLeft_DirChange
;
}
bool
addVec
(
const
SkVector
&
curVec
)
{
DirChange
dir
=
this
-
>
directionChange
(
curVec
)
;
switch
(
dir
)
{
case
kLeft_DirChange
:
case
kRight_DirChange
:
if
(
kInvalid_DirChange
=
=
fExpectedDir
)
{
fExpectedDir
=
dir
;
fFirstDirection
=
(
kRight_DirChange
=
=
dir
)
?
SkPathPriv
:
:
kCW_FirstDirection
:
SkPathPriv
:
:
kCCW_FirstDirection
;
}
else
if
(
dir
!
=
fExpectedDir
)
{
fFirstDirection
=
SkPathPriv
:
:
kUnknown_FirstDirection
;
return
false
;
}
fLastVec
=
curVec
;
break
;
case
kStraight_DirChange
:
break
;
case
kBackwards_DirChange
:
fLastVec
=
curVec
;
return
+
+
fReversals
<
3
;
case
kUnknown_DirChange
:
return
(
fIsFinite
=
false
)
;
case
kInvalid_DirChange
:
SK_ABORT
(
"
Use
of
invalid
direction
change
flag
"
)
;
break
;
}
return
true
;
}
SkPoint
fFirstPt
{
0
0
}
;
SkPoint
fPriorPt
{
0
0
}
;
SkPoint
fLastPt
{
0
0
}
;
SkPoint
fCurrPt
{
0
0
}
;
SkVector
fLastVec
{
0
0
}
;
DirChange
fExpectedDir
{
kInvalid_DirChange
}
;
SkPathPriv
:
:
FirstDirection
fFirstDirection
{
SkPathPriv
:
:
kUnknown_FirstDirection
}
;
int
fReversals
{
0
}
;
bool
fIsFinite
{
true
}
;
}
;
SkPath
:
:
Convexity
SkPath
:
:
internalGetConvexity
(
)
const
{
SkPoint
pts
[
4
]
;
SkPath
:
:
Verb
verb
;
SkPath
:
:
Iter
iter
(
*
this
true
)
;
auto
setComputedConvexity
=
[
=
]
(
Convexity
convexity
)
{
SkASSERT
(
kUnknown_Convexity
!
=
convexity
)
;
this
-
>
setConvexity
(
convexity
)
;
return
convexity
;
}
;
int
pointCount
=
this
-
>
countPoints
(
)
;
if
(
0
<
fLastMoveToIndex
&
&
fLastMoveToIndex
<
pointCount
)
{
pointCount
=
fLastMoveToIndex
;
}
if
(
pointCount
>
3
)
{
const
SkPoint
*
points
=
fPathRef
-
>
points
(
)
;
const
SkPoint
*
last
=
&
points
[
pointCount
]
;
while
(
SkPath
:
:
kMove_Verb
=
=
iter
.
next
(
pts
)
)
{
+
+
points
;
}
-
-
points
;
SkPath
:
:
Convexity
convexity
=
Convexicator
:
:
BySign
(
points
(
int
)
(
last
-
points
)
)
;
if
(
SkPath
:
:
kConcave_Convexity
=
=
convexity
)
{
return
setComputedConvexity
(
SkPath
:
:
kConcave_Convexity
)
;
}
else
if
(
SkPath
:
:
kUnknown_Convexity
=
=
convexity
)
{
return
SkPath
:
:
kUnknown_Convexity
;
}
iter
.
setPath
(
*
this
true
)
;
}
else
if
(
!
this
-
>
isFinite
(
)
)
{
return
kUnknown_Convexity
;
}
int
contourCount
=
0
;
int
count
;
Convexicator
state
;
auto
setFail
=
[
=
]
(
)
{
if
(
!
state
.
isFinite
(
)
)
{
return
SkPath
:
:
kUnknown_Convexity
;
}
return
setComputedConvexity
(
SkPath
:
:
kConcave_Convexity
)
;
}
;
while
(
(
verb
=
iter
.
next
(
pts
)
)
!
=
SkPath
:
:
kDone_Verb
)
{
switch
(
verb
)
{
case
kMove_Verb
:
if
(
+
+
contourCount
>
1
)
{
return
setComputedConvexity
(
kConcave_Convexity
)
;
}
state
.
setMovePt
(
pts
[
0
]
)
;
count
=
0
;
break
;
case
kLine_Verb
:
count
=
1
;
break
;
case
kQuad_Verb
:
case
kConic_Verb
:
count
=
2
;
break
;
case
kCubic_Verb
:
count
=
3
;
break
;
case
kClose_Verb
:
if
(
!
state
.
close
(
)
)
{
return
setFail
(
)
;
}
count
=
0
;
break
;
default
:
SkDEBUGFAIL
(
"
bad
verb
"
)
;
return
setComputedConvexity
(
kConcave_Convexity
)
;
}
for
(
int
i
=
1
;
i
<
=
count
;
i
+
+
)
{
if
(
!
state
.
addPt
(
pts
[
i
]
)
)
{
return
setFail
(
)
;
}
}
}
if
(
this
-
>
getFirstDirection
(
)
=
=
SkPathPriv
:
:
kUnknown_FirstDirection
)
{
if
(
state
.
getFirstDirection
(
)
=
=
SkPathPriv
:
:
kUnknown_FirstDirection
&
&
!
this
-
>
getBounds
(
)
.
isEmpty
(
)
)
{
return
setComputedConvexity
(
state
.
reversals
(
)
<
3
?
kConvex_Convexity
:
kConcave_Convexity
)
;
}
this
-
>
setFirstDirection
(
state
.
getFirstDirection
(
)
)
;
}
return
setComputedConvexity
(
kConvex_Convexity
)
;
}
bool
SkPathPriv
:
:
IsConvex
(
const
SkPoint
points
[
]
int
count
)
{
SkPath
:
:
Convexity
convexity
=
Convexicator
:
:
BySign
(
points
count
)
;
if
(
SkPath
:
:
kConvex_Convexity
!
=
convexity
)
{
return
false
;
}
Convexicator
state
;
state
.
setMovePt
(
points
[
0
]
)
;
for
(
int
i
=
1
;
i
<
count
;
i
+
+
)
{
if
(
!
state
.
addPt
(
points
[
i
]
)
)
{
return
false
;
}
}
if
(
!
state
.
addPt
(
points
[
0
]
)
)
{
return
false
;
}
if
(
!
state
.
close
(
)
)
{
return
false
;
}
return
state
.
getFirstDirection
(
)
!
=
SkPathPriv
:
:
kUnknown_FirstDirection
|
|
state
.
reversals
(
)
<
3
;
}
#
endif
class
ContourIter
{
public
:
ContourIter
(
const
SkPathRef
&
pathRef
)
;
bool
done
(
)
const
{
return
fDone
;
}
int
count
(
)
const
{
return
fCurrPtCount
;
}
const
SkPoint
*
pts
(
)
const
{
return
fCurrPt
;
}
void
next
(
)
;
private
:
int
fCurrPtCount
;
const
SkPoint
*
fCurrPt
;
const
uint8_t
*
fCurrVerb
;
const
uint8_t
*
fStopVerbs
;
const
SkScalar
*
fCurrConicWeight
;
bool
fDone
;
SkDEBUGCODE
(
int
fContourCounter
;
)
}
;
ContourIter
:
:
ContourIter
(
const
SkPathRef
&
pathRef
)
{
fStopVerbs
=
pathRef
.
verbsEnd
(
)
;
fDone
=
false
;
fCurrPt
=
pathRef
.
points
(
)
;
fCurrVerb
=
pathRef
.
verbsBegin
(
)
;
fCurrConicWeight
=
pathRef
.
conicWeights
(
)
;
fCurrPtCount
=
0
;
SkDEBUGCODE
(
fContourCounter
=
0
;
)
this
-
>
next
(
)
;
}
void
ContourIter
:
:
next
(
)
{
if
(
fCurrVerb
>
=
fStopVerbs
)
{
fDone
=
true
;
}
if
(
fDone
)
{
return
;
}
fCurrPt
+
=
fCurrPtCount
;
SkASSERT
(
SkPath
:
:
kMove_Verb
=
=
fCurrVerb
[
0
]
)
;
int
ptCount
=
1
;
const
uint8_t
*
verbs
=
fCurrVerb
;
for
(
verbs
+
+
;
verbs
<
fStopVerbs
;
verbs
+
+
)
{
switch
(
*
verbs
)
{
case
SkPath
:
:
kMove_Verb
:
goto
CONTOUR_END
;
case
SkPath
:
:
kLine_Verb
:
ptCount
+
=
1
;
break
;
case
SkPath
:
:
kConic_Verb
:
fCurrConicWeight
+
=
1
;
case
SkPath
:
:
kQuad_Verb
:
ptCount
+
=
2
;
break
;
case
SkPath
:
:
kCubic_Verb
:
ptCount
+
=
3
;
break
;
case
SkPath
:
:
kClose_Verb
:
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
verb
"
)
;
break
;
}
}
CONTOUR_END
:
fCurrPtCount
=
ptCount
;
fCurrVerb
=
verbs
;
SkDEBUGCODE
(
+
+
fContourCounter
;
)
}
static
SkScalar
cross_prod
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
)
{
SkScalar
cross
=
SkPoint
:
:
CrossProduct
(
p1
-
p0
p2
-
p0
)
;
if
(
0
=
=
cross
)
{
double
p0x
=
SkScalarToDouble
(
p0
.
fX
)
;
double
p0y
=
SkScalarToDouble
(
p0
.
fY
)
;
double
p1x
=
SkScalarToDouble
(
p1
.
fX
)
;
double
p1y
=
SkScalarToDouble
(
p1
.
fY
)
;
double
p2x
=
SkScalarToDouble
(
p2
.
fX
)
;
double
p2y
=
SkScalarToDouble
(
p2
.
fY
)
;
cross
=
SkDoubleToScalar
(
(
p1x
-
p0x
)
*
(
p2y
-
p0y
)
-
(
p1y
-
p0y
)
*
(
p2x
-
p0x
)
)
;
}
return
cross
;
}
static
int
find_max_y
(
const
SkPoint
pts
[
]
int
count
)
{
SkASSERT
(
count
>
0
)
;
SkScalar
max
=
pts
[
0
]
.
fY
;
int
firstIndex
=
0
;
for
(
int
i
=
1
;
i
<
count
;
+
+
i
)
{
SkScalar
y
=
pts
[
i
]
.
fY
;
if
(
y
>
max
)
{
max
=
y
;
firstIndex
=
i
;
}
}
return
firstIndex
;
}
static
int
find_diff_pt
(
const
SkPoint
pts
[
]
int
index
int
n
int
inc
)
{
int
i
=
index
;
for
(
;
;
)
{
i
=
(
i
+
inc
)
%
n
;
if
(
i
=
=
index
)
{
break
;
}
if
(
pts
[
index
]
!
=
pts
[
i
]
)
{
break
;
}
}
return
i
;
}
static
int
find_min_max_x_at_y
(
const
SkPoint
pts
[
]
int
index
int
n
int
*
maxIndexPtr
)
{
const
SkScalar
y
=
pts
[
index
]
.
fY
;
SkScalar
min
=
pts
[
index
]
.
fX
;
SkScalar
max
=
min
;
int
minIndex
=
index
;
int
maxIndex
=
index
;
for
(
int
i
=
index
+
1
;
i
<
n
;
+
+
i
)
{
if
(
pts
[
i
]
.
fY
!
=
y
)
{
break
;
}
SkScalar
x
=
pts
[
i
]
.
fX
;
if
(
x
<
min
)
{
min
=
x
;
minIndex
=
i
;
}
else
if
(
x
>
max
)
{
max
=
x
;
maxIndex
=
i
;
}
}
*
maxIndexPtr
=
maxIndex
;
return
minIndex
;
}
static
void
crossToDir
(
SkScalar
cross
SkPathPriv
:
:
FirstDirection
*
dir
)
{
*
dir
=
cross
>
0
?
SkPathPriv
:
:
kCW_FirstDirection
:
SkPathPriv
:
:
kCCW_FirstDirection
;
}
bool
SkPathPriv
:
:
CheapComputeFirstDirection
(
const
SkPath
&
path
FirstDirection
*
dir
)
{
auto
d
=
path
.
getFirstDirection
(
)
;
if
(
d
!
=
kUnknown_FirstDirection
)
{
*
dir
=
static_cast
<
FirstDirection
>
(
d
)
;
return
true
;
}
if
(
path
.
getConvexityOrUnknown
(
)
=
=
SkPath
:
:
kConvex_Convexity
)
{
SkASSERT
(
path
.
getFirstDirection
(
)
=
=
kUnknown_FirstDirection
)
;
*
dir
=
static_cast
<
FirstDirection
>
(
path
.
getFirstDirection
(
)
)
;
return
false
;
}
ContourIter
iter
(
*
path
.
fPathRef
.
get
(
)
)
;
SkScalar
ymax
=
path
.
getBounds
(
)
.
fTop
;
SkScalar
ymaxCross
=
0
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
int
n
=
iter
.
count
(
)
;
if
(
n
<
3
)
{
continue
;
}
const
SkPoint
*
pts
=
iter
.
pts
(
)
;
SkScalar
cross
=
0
;
int
index
=
find_max_y
(
pts
n
)
;
if
(
pts
[
index
]
.
fY
<
ymax
)
{
continue
;
}
if
(
pts
[
(
index
+
1
)
%
n
]
.
fY
=
=
pts
[
index
]
.
fY
)
{
int
maxIndex
;
int
minIndex
=
find_min_max_x_at_y
(
pts
index
n
&
maxIndex
)
;
if
(
minIndex
=
=
maxIndex
)
{
goto
TRY_CROSSPROD
;
}
SkASSERT
(
pts
[
minIndex
]
.
fY
=
=
pts
[
index
]
.
fY
)
;
SkASSERT
(
pts
[
maxIndex
]
.
fY
=
=
pts
[
index
]
.
fY
)
;
SkASSERT
(
pts
[
minIndex
]
.
fX
<
=
pts
[
maxIndex
]
.
fX
)
;
cross
=
minIndex
-
maxIndex
;
}
else
{
TRY_CROSSPROD
:
int
prev
=
find_diff_pt
(
pts
index
n
n
-
1
)
;
if
(
prev
=
=
index
)
{
continue
;
}
int
next
=
find_diff_pt
(
pts
index
n
1
)
;
SkASSERT
(
next
!
=
index
)
;
cross
=
cross_prod
(
pts
[
prev
]
pts
[
index
]
pts
[
next
]
)
;
if
(
0
=
=
cross
&
&
pts
[
prev
]
.
fY
=
=
pts
[
index
]
.
fY
&
&
pts
[
next
]
.
fY
=
=
pts
[
index
]
.
fY
)
{
cross
=
pts
[
index
]
.
fX
-
pts
[
next
]
.
fX
;
}
}
if
(
cross
)
{
ymax
=
pts
[
index
]
.
fY
;
ymaxCross
=
cross
;
}
}
if
(
ymaxCross
)
{
crossToDir
(
ymaxCross
dir
)
;
path
.
setFirstDirection
(
*
dir
)
;
return
true
;
}
else
{
return
false
;
}
}
static
bool
between
(
SkScalar
a
SkScalar
b
SkScalar
c
)
{
SkASSERT
(
(
(
a
<
=
b
&
&
b
<
=
c
)
|
|
(
a
>
=
b
&
&
b
>
=
c
)
)
=
=
(
(
a
-
b
)
*
(
c
-
b
)
<
=
0
)
|
|
(
SkScalarNearlyZero
(
a
)
&
&
SkScalarNearlyZero
(
b
)
&
&
SkScalarNearlyZero
(
c
)
)
)
;
return
(
a
-
b
)
*
(
c
-
b
)
<
=
0
;
}
static
SkScalar
eval_cubic_pts
(
SkScalar
c0
SkScalar
c1
SkScalar
c2
SkScalar
c3
SkScalar
t
)
{
SkScalar
A
=
c3
+
3
*
(
c1
-
c2
)
-
c0
;
SkScalar
B
=
3
*
(
c2
-
c1
-
c1
+
c0
)
;
SkScalar
C
=
3
*
(
c1
-
c0
)
;
SkScalar
D
=
c0
;
return
poly_eval
(
A
B
C
D
t
)
;
}
template
<
size_t
N
>
static
void
find_minmax
(
const
SkPoint
pts
[
]
SkScalar
*
minPtr
SkScalar
*
maxPtr
)
{
SkScalar
min
max
;
min
=
max
=
pts
[
0
]
.
fX
;
for
(
size_t
i
=
1
;
i
<
N
;
+
+
i
)
{
min
=
SkMinScalar
(
min
pts
[
i
]
.
fX
)
;
max
=
SkMaxScalar
(
max
pts
[
i
]
.
fX
)
;
}
*
minPtr
=
min
;
*
maxPtr
=
max
;
}
static
bool
checkOnCurve
(
SkScalar
x
SkScalar
y
const
SkPoint
&
start
const
SkPoint
&
end
)
{
if
(
start
.
fY
=
=
end
.
fY
)
{
return
between
(
start
.
fX
x
end
.
fX
)
&
&
x
!
=
end
.
fX
;
}
else
{
return
x
=
=
start
.
fX
&
&
y
=
=
start
.
fY
;
}
}
static
int
winding_mono_cubic
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
SkScalar
y0
=
pts
[
0
]
.
fY
;
SkScalar
y3
=
pts
[
3
]
.
fY
;
int
dir
=
1
;
if
(
y0
>
y3
)
{
using
std
:
:
swap
;
swap
(
y0
y3
)
;
dir
=
-
1
;
}
if
(
y
<
y0
|
|
y
>
y3
)
{
return
0
;
}
if
(
checkOnCurve
(
x
y
pts
[
0
]
pts
[
3
]
)
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
if
(
y
=
=
y3
)
{
return
0
;
}
SkScalar
min
max
;
find_minmax
<
4
>
(
pts
&
min
&
max
)
;
if
(
x
<
min
)
{
return
0
;
}
if
(
x
>
max
)
{
return
dir
;
}
SkScalar
t
;
if
(
!
SkCubicClipper
:
:
ChopMonoAtY
(
pts
y
&
t
)
)
{
return
0
;
}
SkScalar
xt
=
eval_cubic_pts
(
pts
[
0
]
.
fX
pts
[
1
]
.
fX
pts
[
2
]
.
fX
pts
[
3
]
.
fX
t
)
;
if
(
SkScalarNearlyEqual
(
xt
x
)
)
{
if
(
x
!
=
pts
[
3
]
.
fX
|
|
y
!
=
pts
[
3
]
.
fY
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
}
return
xt
<
x
?
dir
:
0
;
}
static
int
winding_cubic
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
SkPoint
dst
[
10
]
;
int
n
=
SkChopCubicAtYExtrema
(
pts
dst
)
;
int
w
=
0
;
for
(
int
i
=
0
;
i
<
=
n
;
+
+
i
)
{
w
+
=
winding_mono_cubic
(
&
dst
[
i
*
3
]
x
y
onCurveCount
)
;
}
return
w
;
}
static
double
conic_eval_numerator
(
const
SkScalar
src
[
]
SkScalar
w
SkScalar
t
)
{
SkASSERT
(
src
)
;
SkASSERT
(
t
>
=
0
&
&
t
<
=
1
)
;
SkScalar
src2w
=
src
[
2
]
*
w
;
SkScalar
C
=
src
[
0
]
;
SkScalar
A
=
src
[
4
]
-
2
*
src2w
+
C
;
SkScalar
B
=
2
*
(
src2w
-
C
)
;
return
poly_eval
(
A
B
C
t
)
;
}
static
double
conic_eval_denominator
(
SkScalar
w
SkScalar
t
)
{
SkScalar
B
=
2
*
(
w
-
1
)
;
SkScalar
C
=
1
;
SkScalar
A
=
-
B
;
return
poly_eval
(
A
B
C
t
)
;
}
static
int
winding_mono_conic
(
const
SkConic
&
conic
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
const
SkPoint
*
pts
=
conic
.
fPts
;
SkScalar
y0
=
pts
[
0
]
.
fY
;
SkScalar
y2
=
pts
[
2
]
.
fY
;
int
dir
=
1
;
if
(
y0
>
y2
)
{
using
std
:
:
swap
;
swap
(
y0
y2
)
;
dir
=
-
1
;
}
if
(
y
<
y0
|
|
y
>
y2
)
{
return
0
;
}
if
(
checkOnCurve
(
x
y
pts
[
0
]
pts
[
2
]
)
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
if
(
y
=
=
y2
)
{
return
0
;
}
SkScalar
roots
[
2
]
;
SkScalar
A
=
pts
[
2
]
.
fY
;
SkScalar
B
=
pts
[
1
]
.
fY
*
conic
.
fW
-
y
*
conic
.
fW
+
y
;
SkScalar
C
=
pts
[
0
]
.
fY
;
A
+
=
C
-
2
*
B
;
B
-
=
C
;
C
-
=
y
;
int
n
=
SkFindUnitQuadRoots
(
A
2
*
B
C
roots
)
;
SkASSERT
(
n
<
=
1
)
;
SkScalar
xt
;
if
(
0
=
=
n
)
{
xt
=
pts
[
1
-
dir
]
.
fX
;
}
else
{
SkScalar
t
=
roots
[
0
]
;
xt
=
conic_eval_numerator
(
&
pts
[
0
]
.
fX
conic
.
fW
t
)
/
conic_eval_denominator
(
conic
.
fW
t
)
;
}
if
(
SkScalarNearlyEqual
(
xt
x
)
)
{
if
(
x
!
=
pts
[
2
]
.
fX
|
|
y
!
=
pts
[
2
]
.
fY
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
}
return
xt
<
x
?
dir
:
0
;
}
static
bool
is_mono_quad
(
SkScalar
y0
SkScalar
y1
SkScalar
y2
)
{
if
(
y0
=
=
y1
)
{
return
true
;
}
if
(
y0
<
y1
)
{
return
y1
<
=
y2
;
}
else
{
return
y1
>
=
y2
;
}
}
static
int
winding_conic
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
SkScalar
weight
int
*
onCurveCount
)
{
SkConic
conic
(
pts
weight
)
;
SkConic
chopped
[
2
]
;
bool
isMono
=
is_mono_quad
(
pts
[
0
]
.
fY
pts
[
1
]
.
fY
pts
[
2
]
.
fY
)
|
|
!
conic
.
chopAtYExtrema
(
chopped
)
;
int
w
=
winding_mono_conic
(
isMono
?
conic
:
chopped
[
0
]
x
y
onCurveCount
)
;
if
(
!
isMono
)
{
w
+
=
winding_mono_conic
(
chopped
[
1
]
x
y
onCurveCount
)
;
}
return
w
;
}
static
int
winding_mono_quad
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
SkScalar
y0
=
pts
[
0
]
.
fY
;
SkScalar
y2
=
pts
[
2
]
.
fY
;
int
dir
=
1
;
if
(
y0
>
y2
)
{
using
std
:
:
swap
;
swap
(
y0
y2
)
;
dir
=
-
1
;
}
if
(
y
<
y0
|
|
y
>
y2
)
{
return
0
;
}
if
(
checkOnCurve
(
x
y
pts
[
0
]
pts
[
2
]
)
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
if
(
y
=
=
y2
)
{
return
0
;
}
#
if
0
if
(
pts
[
0
]
.
fX
>
x
&
&
pts
[
1
]
.
fX
>
x
&
&
pts
[
2
]
.
fX
>
x
)
{
return
0
;
}
#
endif
SkScalar
roots
[
2
]
;
int
n
=
SkFindUnitQuadRoots
(
pts
[
0
]
.
fY
-
2
*
pts
[
1
]
.
fY
+
pts
[
2
]
.
fY
2
*
(
pts
[
1
]
.
fY
-
pts
[
0
]
.
fY
)
pts
[
0
]
.
fY
-
y
roots
)
;
SkASSERT
(
n
<
=
1
)
;
SkScalar
xt
;
if
(
0
=
=
n
)
{
xt
=
pts
[
1
-
dir
]
.
fX
;
}
else
{
SkScalar
t
=
roots
[
0
]
;
SkScalar
C
=
pts
[
0
]
.
fX
;
SkScalar
A
=
pts
[
2
]
.
fX
-
2
*
pts
[
1
]
.
fX
+
C
;
SkScalar
B
=
2
*
(
pts
[
1
]
.
fX
-
C
)
;
xt
=
poly_eval
(
A
B
C
t
)
;
}
if
(
SkScalarNearlyEqual
(
xt
x
)
)
{
if
(
x
!
=
pts
[
2
]
.
fX
|
|
y
!
=
pts
[
2
]
.
fY
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
}
return
xt
<
x
?
dir
:
0
;
}
static
int
winding_quad
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
SkPoint
dst
[
5
]
;
int
n
=
0
;
if
(
!
is_mono_quad
(
pts
[
0
]
.
fY
pts
[
1
]
.
fY
pts
[
2
]
.
fY
)
)
{
n
=
SkChopQuadAtYExtrema
(
pts
dst
)
;
pts
=
dst
;
}
int
w
=
winding_mono_quad
(
pts
x
y
onCurveCount
)
;
if
(
n
>
0
)
{
w
+
=
winding_mono_quad
(
&
pts
[
2
]
x
y
onCurveCount
)
;
}
return
w
;
}
static
int
winding_line
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
int
*
onCurveCount
)
{
SkScalar
x0
=
pts
[
0
]
.
fX
;
SkScalar
y0
=
pts
[
0
]
.
fY
;
SkScalar
x1
=
pts
[
1
]
.
fX
;
SkScalar
y1
=
pts
[
1
]
.
fY
;
SkScalar
dy
=
y1
-
y0
;
int
dir
=
1
;
if
(
y0
>
y1
)
{
using
std
:
:
swap
;
swap
(
y0
y1
)
;
dir
=
-
1
;
}
if
(
y
<
y0
|
|
y
>
y1
)
{
return
0
;
}
if
(
checkOnCurve
(
x
y
pts
[
0
]
pts
[
1
]
)
)
{
*
onCurveCount
+
=
1
;
return
0
;
}
if
(
y
=
=
y1
)
{
return
0
;
}
SkScalar
cross
=
(
x1
-
x0
)
*
(
y
-
pts
[
0
]
.
fY
)
-
dy
*
(
x
-
x0
)
;
if
(
!
cross
)
{
if
(
x
!
=
x1
|
|
y
!
=
pts
[
1
]
.
fY
)
{
*
onCurveCount
+
=
1
;
}
dir
=
0
;
}
else
if
(
SkScalarSignAsInt
(
cross
)
=
=
dir
)
{
dir
=
0
;
}
return
dir
;
}
static
void
tangent_cubic
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
SkTDArray
<
SkVector
>
*
tangents
)
{
if
(
!
between
(
pts
[
0
]
.
fY
y
pts
[
1
]
.
fY
)
&
&
!
between
(
pts
[
1
]
.
fY
y
pts
[
2
]
.
fY
)
&
&
!
between
(
pts
[
2
]
.
fY
y
pts
[
3
]
.
fY
)
)
{
return
;
}
if
(
!
between
(
pts
[
0
]
.
fX
x
pts
[
1
]
.
fX
)
&
&
!
between
(
pts
[
1
]
.
fX
x
pts
[
2
]
.
fX
)
&
&
!
between
(
pts
[
2
]
.
fX
x
pts
[
3
]
.
fX
)
)
{
return
;
}
SkPoint
dst
[
10
]
;
int
n
=
SkChopCubicAtYExtrema
(
pts
dst
)
;
for
(
int
i
=
0
;
i
<
=
n
;
+
+
i
)
{
SkPoint
*
c
=
&
dst
[
i
*
3
]
;
SkScalar
t
;
if
(
!
SkCubicClipper
:
:
ChopMonoAtY
(
c
y
&
t
)
)
{
continue
;
}
SkScalar
xt
=
eval_cubic_pts
(
c
[
0
]
.
fX
c
[
1
]
.
fX
c
[
2
]
.
fX
c
[
3
]
.
fX
t
)
;
if
(
!
SkScalarNearlyEqual
(
x
xt
)
)
{
continue
;
}
SkVector
tangent
;
SkEvalCubicAt
(
c
t
nullptr
&
tangent
nullptr
)
;
tangents
-
>
push_back
(
tangent
)
;
}
}
static
void
tangent_conic
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
SkScalar
w
SkTDArray
<
SkVector
>
*
tangents
)
{
if
(
!
between
(
pts
[
0
]
.
fY
y
pts
[
1
]
.
fY
)
&
&
!
between
(
pts
[
1
]
.
fY
y
pts
[
2
]
.
fY
)
)
{
return
;
}
if
(
!
between
(
pts
[
0
]
.
fX
x
pts
[
1
]
.
fX
)
&
&
!
between
(
pts
[
1
]
.
fX
x
pts
[
2
]
.
fX
)
)
{
return
;
}
SkScalar
roots
[
2
]
;
SkScalar
A
=
pts
[
2
]
.
fY
;
SkScalar
B
=
pts
[
1
]
.
fY
*
w
-
y
*
w
+
y
;
SkScalar
C
=
pts
[
0
]
.
fY
;
A
+
=
C
-
2
*
B
;
B
-
=
C
;
C
-
=
y
;
int
n
=
SkFindUnitQuadRoots
(
A
2
*
B
C
roots
)
;
for
(
int
index
=
0
;
index
<
n
;
+
+
index
)
{
SkScalar
t
=
roots
[
index
]
;
SkScalar
xt
=
conic_eval_numerator
(
&
pts
[
0
]
.
fX
w
t
)
/
conic_eval_denominator
(
w
t
)
;
if
(
!
SkScalarNearlyEqual
(
x
xt
)
)
{
continue
;
}
SkConic
conic
(
pts
w
)
;
tangents
-
>
push_back
(
conic
.
evalTangentAt
(
t
)
)
;
}
}
static
void
tangent_quad
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
SkTDArray
<
SkVector
>
*
tangents
)
{
if
(
!
between
(
pts
[
0
]
.
fY
y
pts
[
1
]
.
fY
)
&
&
!
between
(
pts
[
1
]
.
fY
y
pts
[
2
]
.
fY
)
)
{
return
;
}
if
(
!
between
(
pts
[
0
]
.
fX
x
pts
[
1
]
.
fX
)
&
&
!
between
(
pts
[
1
]
.
fX
x
pts
[
2
]
.
fX
)
)
{
return
;
}
SkScalar
roots
[
2
]
;
int
n
=
SkFindUnitQuadRoots
(
pts
[
0
]
.
fY
-
2
*
pts
[
1
]
.
fY
+
pts
[
2
]
.
fY
2
*
(
pts
[
1
]
.
fY
-
pts
[
0
]
.
fY
)
pts
[
0
]
.
fY
-
y
roots
)
;
for
(
int
index
=
0
;
index
<
n
;
+
+
index
)
{
SkScalar
t
=
roots
[
index
]
;
SkScalar
C
=
pts
[
0
]
.
fX
;
SkScalar
A
=
pts
[
2
]
.
fX
-
2
*
pts
[
1
]
.
fX
+
C
;
SkScalar
B
=
2
*
(
pts
[
1
]
.
fX
-
C
)
;
SkScalar
xt
=
poly_eval
(
A
B
C
t
)
;
if
(
!
SkScalarNearlyEqual
(
x
xt
)
)
{
continue
;
}
tangents
-
>
push_back
(
SkEvalQuadTangentAt
(
pts
t
)
)
;
}
}
static
void
tangent_line
(
const
SkPoint
pts
[
]
SkScalar
x
SkScalar
y
SkTDArray
<
SkVector
>
*
tangents
)
{
SkScalar
y0
=
pts
[
0
]
.
fY
;
SkScalar
y1
=
pts
[
1
]
.
fY
;
if
(
!
between
(
y0
y
y1
)
)
{
return
;
}
SkScalar
x0
=
pts
[
0
]
.
fX
;
SkScalar
x1
=
pts
[
1
]
.
fX
;
if
(
!
between
(
x0
x
x1
)
)
{
return
;
}
SkScalar
dx
=
x1
-
x0
;
SkScalar
dy
=
y1
-
y0
;
if
(
!
SkScalarNearlyEqual
(
(
x
-
x0
)
*
dy
dx
*
(
y
-
y0
)
)
)
{
return
;
}
SkVector
v
;
v
.
set
(
dx
dy
)
;
tangents
-
>
push_back
(
v
)
;
}
static
bool
contains_inclusive
(
const
SkRect
&
r
SkScalar
x
SkScalar
y
)
{
return
r
.
fLeft
<
=
x
&
&
x
<
=
r
.
fRight
&
&
r
.
fTop
<
=
y
&
&
y
<
=
r
.
fBottom
;
}
bool
SkPath
:
:
contains
(
SkScalar
x
SkScalar
y
)
const
{
bool
isInverse
=
this
-
>
isInverseFillType
(
)
;
if
(
this
-
>
isEmpty
(
)
)
{
return
isInverse
;
}
if
(
!
contains_inclusive
(
this
-
>
getBounds
(
)
x
y
)
)
{
return
isInverse
;
}
SkPath
:
:
Iter
iter
(
*
this
true
)
;
bool
done
=
false
;
int
w
=
0
;
int
onCurveCount
=
0
;
do
{
SkPoint
pts
[
4
]
;
switch
(
iter
.
next
(
pts
)
)
{
case
SkPath
:
:
kMove_Verb
:
case
SkPath
:
:
kClose_Verb
:
break
;
case
SkPath
:
:
kLine_Verb
:
w
+
=
winding_line
(
pts
x
y
&
onCurveCount
)
;
break
;
case
SkPath
:
:
kQuad_Verb
:
w
+
=
winding_quad
(
pts
x
y
&
onCurveCount
)
;
break
;
case
SkPath
:
:
kConic_Verb
:
w
+
=
winding_conic
(
pts
x
y
iter
.
conicWeight
(
)
&
onCurveCount
)
;
break
;
case
SkPath
:
:
kCubic_Verb
:
w
+
=
winding_cubic
(
pts
x
y
&
onCurveCount
)
;
break
;
case
SkPath
:
:
kDone_Verb
:
done
=
true
;
break
;
}
}
while
(
!
done
)
;
bool
evenOddFill
=
SkPath
:
:
kEvenOdd_FillType
=
=
this
-
>
getFillType
(
)
|
|
SkPath
:
:
kInverseEvenOdd_FillType
=
=
this
-
>
getFillType
(
)
;
if
(
evenOddFill
)
{
w
&
=
1
;
}
if
(
w
)
{
return
!
isInverse
;
}
if
(
onCurveCount
<
=
1
)
{
return
SkToBool
(
onCurveCount
)
^
isInverse
;
}
if
(
(
onCurveCount
&
1
)
|
|
evenOddFill
)
{
return
SkToBool
(
onCurveCount
&
1
)
^
isInverse
;
}
iter
.
setPath
(
*
this
true
)
;
done
=
false
;
SkTDArray
<
SkVector
>
tangents
;
do
{
SkPoint
pts
[
4
]
;
int
oldCount
=
tangents
.
count
(
)
;
switch
(
iter
.
next
(
pts
)
)
{
case
SkPath
:
:
kMove_Verb
:
case
SkPath
:
:
kClose_Verb
:
break
;
case
SkPath
:
:
kLine_Verb
:
tangent_line
(
pts
x
y
&
tangents
)
;
break
;
case
SkPath
:
:
kQuad_Verb
:
tangent_quad
(
pts
x
y
&
tangents
)
;
break
;
case
SkPath
:
:
kConic_Verb
:
tangent_conic
(
pts
x
y
iter
.
conicWeight
(
)
&
tangents
)
;
break
;
case
SkPath
:
:
kCubic_Verb
:
tangent_cubic
(
pts
x
y
&
tangents
)
;
break
;
case
SkPath
:
:
kDone_Verb
:
done
=
true
;
break
;
}
if
(
tangents
.
count
(
)
>
oldCount
)
{
int
last
=
tangents
.
count
(
)
-
1
;
const
SkVector
&
tangent
=
tangents
[
last
]
;
if
(
SkScalarNearlyZero
(
SkPointPriv
:
:
LengthSqd
(
tangent
)
)
)
{
tangents
.
remove
(
last
)
;
}
else
{
for
(
int
index
=
0
;
index
<
last
;
+
+
index
)
{
const
SkVector
&
test
=
tangents
[
index
]
;
if
(
SkScalarNearlyZero
(
test
.
cross
(
tangent
)
)
&
&
SkScalarSignAsInt
(
tangent
.
fX
*
test
.
fX
)
<
=
0
&
&
SkScalarSignAsInt
(
tangent
.
fY
*
test
.
fY
)
<
=
0
)
{
tangents
.
remove
(
last
)
;
tangents
.
removeShuffle
(
index
)
;
break
;
}
}
}
}
}
while
(
!
done
)
;
return
SkToBool
(
tangents
.
count
(
)
)
^
isInverse
;
}
int
SkPath
:
:
ConvertConicToQuads
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
SkPoint
pts
[
]
int
pow2
)
{
const
SkConic
conic
(
p0
p1
p2
w
)
;
return
conic
.
chopIntoQuadsPOW2
(
pts
pow2
)
;
}
bool
SkPathPriv
:
:
IsSimpleClosedRect
(
const
SkPath
&
path
SkRect
*
rect
SkPath
:
:
Direction
*
direction
unsigned
*
start
)
{
if
(
path
.
getSegmentMasks
(
)
!
=
SkPath
:
:
kLine_SegmentMask
)
{
return
false
;
}
SkPath
:
:
RawIter
iter
(
path
)
;
SkPoint
verbPts
[
4
]
;
SkPath
:
:
Verb
v
;
SkPoint
rectPts
[
5
]
;
int
rectPtCnt
=
0
;
while
(
(
v
=
iter
.
next
(
verbPts
)
)
!
=
SkPath
:
:
kDone_Verb
)
{
switch
(
v
)
{
case
SkPath
:
:
kMove_Verb
:
if
(
0
!
=
rectPtCnt
)
{
return
false
;
}
rectPts
[
0
]
=
verbPts
[
0
]
;
+
+
rectPtCnt
;
break
;
case
SkPath
:
:
kLine_Verb
:
if
(
5
=
=
rectPtCnt
)
{
return
false
;
}
rectPts
[
rectPtCnt
]
=
verbPts
[
1
]
;
+
+
rectPtCnt
;
break
;
case
SkPath
:
:
kClose_Verb
:
if
(
4
=
=
rectPtCnt
)
{
rectPts
[
4
]
=
rectPts
[
0
]
;
rectPtCnt
=
5
;
}
break
;
default
:
return
false
;
}
}
if
(
rectPtCnt
<
5
)
{
return
false
;
}
if
(
rectPts
[
0
]
!
=
rectPts
[
4
]
)
{
return
false
;
}
bool
vec03IsVertical
;
if
(
rectPts
[
0
]
.
fX
=
=
rectPts
[
3
]
.
fX
&
&
rectPts
[
1
]
.
fX
=
=
rectPts
[
2
]
.
fX
&
&
rectPts
[
0
]
.
fY
=
=
rectPts
[
1
]
.
fY
&
&
rectPts
[
3
]
.
fY
=
=
rectPts
[
2
]
.
fY
)
{
if
(
rectPts
[
0
]
.
fX
=
=
rectPts
[
1
]
.
fX
|
|
rectPts
[
0
]
.
fY
=
=
rectPts
[
3
]
.
fY
)
{
return
false
;
}
vec03IsVertical
=
true
;
}
else
if
(
rectPts
[
0
]
.
fY
=
=
rectPts
[
3
]
.
fY
&
&
rectPts
[
1
]
.
fY
=
=
rectPts
[
2
]
.
fY
&
&
rectPts
[
0
]
.
fX
=
=
rectPts
[
1
]
.
fX
&
&
rectPts
[
3
]
.
fX
=
=
rectPts
[
2
]
.
fX
)
{
if
(
rectPts
[
0
]
.
fY
=
=
rectPts
[
1
]
.
fY
|
|
rectPts
[
0
]
.
fX
=
=
rectPts
[
3
]
.
fX
)
{
return
false
;
}
vec03IsVertical
=
false
;
}
else
{
return
false
;
}
unsigned
sortFlags
=
(
(
rectPts
[
0
]
.
fX
<
rectPts
[
2
]
.
fX
)
?
0b00
:
0b01
)
|
(
(
rectPts
[
0
]
.
fY
<
rectPts
[
2
]
.
fY
)
?
0b00
:
0b10
)
;
switch
(
sortFlags
)
{
case
0b00
:
rect
-
>
setLTRB
(
rectPts
[
0
]
.
fX
rectPts
[
0
]
.
fY
rectPts
[
2
]
.
fX
rectPts
[
2
]
.
fY
)
;
*
direction
=
vec03IsVertical
?
SkPath
:
:
kCW_Direction
:
SkPath
:
:
kCCW_Direction
;
*
start
=
0
;
break
;
case
0b01
:
rect
-
>
setLTRB
(
rectPts
[
2
]
.
fX
rectPts
[
0
]
.
fY
rectPts
[
0
]
.
fX
rectPts
[
2
]
.
fY
)
;
*
direction
=
vec03IsVertical
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
*
start
=
1
;
break
;
case
0b10
:
rect
-
>
setLTRB
(
rectPts
[
0
]
.
fX
rectPts
[
2
]
.
fY
rectPts
[
2
]
.
fX
rectPts
[
0
]
.
fY
)
;
*
direction
=
vec03IsVertical
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
*
start
=
3
;
break
;
case
0b11
:
rect
-
>
setLTRB
(
rectPts
[
2
]
.
fX
rectPts
[
2
]
.
fY
rectPts
[
0
]
.
fX
rectPts
[
0
]
.
fY
)
;
*
direction
=
vec03IsVertical
?
SkPath
:
:
kCW_Direction
:
SkPath
:
:
kCCW_Direction
;
*
start
=
2
;
break
;
}
return
true
;
}
bool
SkPathPriv
:
:
DrawArcIsConvex
(
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
{
if
(
isFillNoPathEffect
&
&
SkScalarAbs
(
sweepAngle
)
>
=
360
.
f
)
{
return
true
;
}
if
(
useCenter
)
{
return
SkScalarAbs
(
sweepAngle
)
<
=
180
.
f
;
}
return
SkScalarAbs
(
sweepAngle
)
<
=
360
.
f
;
}
void
SkPathPriv
:
:
CreateDrawArcPath
(
SkPath
*
path
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
{
SkASSERT
(
!
oval
.
isEmpty
(
)
)
;
SkASSERT
(
sweepAngle
)
;
path
-
>
reset
(
)
;
path
-
>
setIsVolatile
(
true
)
;
path
-
>
setFillType
(
SkPath
:
:
kWinding_FillType
)
;
if
(
isFillNoPathEffect
&
&
SkScalarAbs
(
sweepAngle
)
>
=
360
.
f
)
{
path
-
>
addOval
(
oval
)
;
SkASSERT
(
path
-
>
isConvex
(
)
&
&
DrawArcIsConvex
(
sweepAngle
false
isFillNoPathEffect
)
)
;
return
;
}
if
(
useCenter
)
{
path
-
>
moveTo
(
oval
.
centerX
(
)
oval
.
centerY
(
)
)
;
}
auto
firstDir
=
sweepAngle
>
0
?
SkPathPriv
:
:
kCW_FirstDirection
:
SkPathPriv
:
:
kCCW_FirstDirection
;
bool
convex
=
DrawArcIsConvex
(
sweepAngle
useCenter
isFillNoPathEffect
)
;
bool
forceMoveTo
=
!
useCenter
;
while
(
sweepAngle
<
=
-
360
.
f
)
{
path
-
>
arcTo
(
oval
startAngle
-
180
.
f
forceMoveTo
)
;
startAngle
-
=
180
.
f
;
path
-
>
arcTo
(
oval
startAngle
-
180
.
f
false
)
;
startAngle
-
=
180
.
f
;
forceMoveTo
=
false
;
sweepAngle
+
=
360
.
f
;
}
while
(
sweepAngle
>
=
360
.
f
)
{
path
-
>
arcTo
(
oval
startAngle
180
.
f
forceMoveTo
)
;
startAngle
+
=
180
.
f
;
path
-
>
arcTo
(
oval
startAngle
180
.
f
false
)
;
startAngle
+
=
180
.
f
;
forceMoveTo
=
false
;
sweepAngle
-
=
360
.
f
;
}
path
-
>
arcTo
(
oval
startAngle
sweepAngle
forceMoveTo
)
;
if
(
useCenter
)
{
path
-
>
close
(
)
;
}
path
-
>
setConvexity
(
convex
?
SkPath
:
:
kConvex_Convexity
:
SkPath
:
:
kConcave_Convexity
)
;
path
-
>
setFirstDirection
(
firstDir
)
;
}
#
include
"
include
/
private
/
SkNx
.
h
"
static
int
compute_quad_extremas
(
const
SkPoint
src
[
3
]
SkPoint
extremas
[
3
]
)
{
SkScalar
ts
[
2
]
;
int
n
=
SkFindQuadExtrema
(
src
[
0
]
.
fX
src
[
1
]
.
fX
src
[
2
]
.
fX
ts
)
;
n
+
=
SkFindQuadExtrema
(
src
[
0
]
.
fY
src
[
1
]
.
fY
src
[
2
]
.
fY
&
ts
[
n
]
)
;
SkASSERT
(
n
>
=
0
&
&
n
<
=
2
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
extremas
[
i
]
=
SkEvalQuadAt
(
src
ts
[
i
]
)
;
}
extremas
[
n
]
=
src
[
2
]
;
return
n
+
1
;
}
static
int
compute_conic_extremas
(
const
SkPoint
src
[
3
]
SkScalar
w
SkPoint
extremas
[
3
]
)
{
SkConic
conic
(
src
[
0
]
src
[
1
]
src
[
2
]
w
)
;
SkScalar
ts
[
2
]
;
int
n
=
conic
.
findXExtrema
(
ts
)
;
n
+
=
conic
.
findYExtrema
(
&
ts
[
n
]
)
;
SkASSERT
(
n
>
=
0
&
&
n
<
=
2
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
extremas
[
i
]
=
conic
.
evalAt
(
ts
[
i
]
)
;
}
extremas
[
n
]
=
src
[
2
]
;
return
n
+
1
;
}
static
int
compute_cubic_extremas
(
const
SkPoint
src
[
4
]
SkPoint
extremas
[
5
]
)
{
SkScalar
ts
[
4
]
;
int
n
=
SkFindCubicExtrema
(
src
[
0
]
.
fX
src
[
1
]
.
fX
src
[
2
]
.
fX
src
[
3
]
.
fX
ts
)
;
n
+
=
SkFindCubicExtrema
(
src
[
0
]
.
fY
src
[
1
]
.
fY
src
[
2
]
.
fY
src
[
3
]
.
fY
&
ts
[
n
]
)
;
SkASSERT
(
n
>
=
0
&
&
n
<
=
4
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
SkEvalCubicAt
(
src
ts
[
i
]
&
extremas
[
i
]
nullptr
nullptr
)
;
}
extremas
[
n
]
=
src
[
3
]
;
return
n
+
1
;
}
SkRect
SkPath
:
:
computeTightBounds
(
)
const
{
if
(
0
=
=
this
-
>
countVerbs
(
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
if
(
this
-
>
getSegmentMasks
(
)
=
=
SkPath
:
:
kLine_SegmentMask
)
{
return
this
-
>
getBounds
(
)
;
}
SkPoint
extremas
[
5
]
;
SkPoint
pts
[
4
]
;
SkPath
:
:
RawIter
iter
(
*
this
)
;
Sk2s
min
max
;
min
=
max
=
from_point
(
this
-
>
getPoint
(
0
)
)
;
for
(
;
;
)
{
int
count
=
0
;
switch
(
iter
.
next
(
pts
)
)
{
case
SkPath
:
:
kMove_Verb
:
extremas
[
0
]
=
pts
[
0
]
;
count
=
1
;
break
;
case
SkPath
:
:
kLine_Verb
:
extremas
[
0
]
=
pts
[
1
]
;
count
=
1
;
break
;
case
SkPath
:
:
kQuad_Verb
:
count
=
compute_quad_extremas
(
pts
extremas
)
;
break
;
case
SkPath
:
:
kConic_Verb
:
count
=
compute_conic_extremas
(
pts
iter
.
conicWeight
(
)
extremas
)
;
break
;
case
SkPath
:
:
kCubic_Verb
:
count
=
compute_cubic_extremas
(
pts
extremas
)
;
break
;
case
SkPath
:
:
kClose_Verb
:
break
;
case
SkPath
:
:
kDone_Verb
:
goto
DONE
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
Sk2s
tmp
=
from_point
(
extremas
[
i
]
)
;
min
=
Sk2s
:
:
Min
(
min
tmp
)
;
max
=
Sk2s
:
:
Max
(
max
tmp
)
;
}
}
DONE
:
SkRect
bounds
;
min
.
store
(
(
SkPoint
*
)
&
bounds
.
fLeft
)
;
max
.
store
(
(
SkPoint
*
)
&
bounds
.
fRight
)
;
return
bounds
;
}
bool
SkPath
:
:
IsLineDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
bool
exact
)
{
return
exact
?
p1
=
=
p2
:
SkPointPriv
:
:
EqualsWithinTolerance
(
p1
p2
)
;
}
bool
SkPath
:
:
IsQuadDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
bool
exact
)
{
return
exact
?
p1
=
=
p2
&
&
p2
=
=
p3
:
SkPointPriv
:
:
EqualsWithinTolerance
(
p1
p2
)
&
&
SkPointPriv
:
:
EqualsWithinTolerance
(
p2
p3
)
;
}
bool
SkPath
:
:
IsCubicDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
const
SkPoint
&
p4
bool
exact
)
{
return
exact
?
p1
=
=
p2
&
&
p2
=
=
p3
&
&
p3
=
=
p4
:
SkPointPriv
:
:
EqualsWithinTolerance
(
p1
p2
)
&
&
SkPointPriv
:
:
EqualsWithinTolerance
(
p2
p3
)
&
&
SkPointPriv
:
:
EqualsWithinTolerance
(
p3
p4
)
;
}
bool
SkPathPriv
:
:
IsRectContour
(
const
SkPath
&
path
bool
allowPartial
int
*
currVerb
const
SkPoint
*
*
ptsPtr
bool
*
isClosed
SkPath
:
:
Direction
*
direction
SkRect
*
rect
)
{
int
corners
=
0
;
SkPoint
closeXY
;
SkPoint
lineStart
;
const
SkPoint
*
firstPt
=
nullptr
;
const
SkPoint
*
lastPt
=
nullptr
;
SkPoint
firstCorner
;
SkPoint
thirdCorner
;
const
SkPoint
*
pts
=
*
ptsPtr
;
const
SkPoint
*
savePts
=
nullptr
;
lineStart
.
set
(
0
0
)
;
signed
char
directions
[
]
=
{
-
1
-
1
-
1
-
1
-
1
}
;
bool
closedOrMoved
=
false
;
bool
autoClose
=
false
;
bool
insertClose
=
false
;
int
verbCnt
=
path
.
fPathRef
-
>
countVerbs
(
)
;
while
(
*
currVerb
<
verbCnt
&
&
(
!
allowPartial
|
|
!
autoClose
)
)
{
uint8_t
verb
=
insertClose
?
(
uint8_t
)
SkPath
:
:
kClose_Verb
:
path
.
fPathRef
-
>
atVerb
(
*
currVerb
)
;
switch
(
verb
)
{
case
SkPath
:
:
kClose_Verb
:
savePts
=
pts
;
autoClose
=
true
;
insertClose
=
false
;
case
SkPath
:
:
kLine_Verb
:
{
if
(
SkPath
:
:
kClose_Verb
!
=
verb
)
{
lastPt
=
pts
;
}
SkPoint
lineEnd
=
SkPath
:
:
kClose_Verb
=
=
verb
?
*
firstPt
:
*
pts
+
+
;
SkVector
lineDelta
=
lineEnd
-
lineStart
;
if
(
lineDelta
.
fX
&
&
lineDelta
.
fY
)
{
return
false
;
}
if
(
!
lineDelta
.
isFinite
(
)
)
{
return
false
;
}
if
(
lineStart
=
=
lineEnd
)
{
break
;
}
int
nextDirection
=
rect_make_dir
(
lineDelta
.
fX
lineDelta
.
fY
)
;
if
(
0
=
=
corners
)
{
directions
[
0
]
=
nextDirection
;
corners
=
1
;
closedOrMoved
=
false
;
lineStart
=
lineEnd
;
break
;
}
if
(
closedOrMoved
)
{
return
false
;
}
if
(
autoClose
&
&
nextDirection
=
=
directions
[
0
]
)
{
break
;
}
closedOrMoved
=
autoClose
;
if
(
directions
[
corners
-
1
]
=
=
nextDirection
)
{
if
(
3
=
=
corners
&
&
SkPath
:
:
kLine_Verb
=
=
verb
)
{
thirdCorner
=
lineEnd
;
}
lineStart
=
lineEnd
;
break
;
}
directions
[
corners
+
+
]
=
nextDirection
;
switch
(
corners
)
{
case
2
:
firstCorner
=
lineStart
;
break
;
case
3
:
if
(
(
directions
[
0
]
^
directions
[
2
]
)
!
=
2
)
{
return
false
;
}
thirdCorner
=
lineEnd
;
break
;
case
4
:
if
(
(
directions
[
1
]
^
directions
[
3
]
)
!
=
2
)
{
return
false
;
}
break
;
default
:
return
false
;
}
lineStart
=
lineEnd
;
break
;
}
case
SkPath
:
:
kQuad_Verb
:
case
SkPath
:
:
kConic_Verb
:
case
SkPath
:
:
kCubic_Verb
:
return
false
;
case
SkPath
:
:
kMove_Verb
:
if
(
allowPartial
&
&
!
autoClose
&
&
directions
[
0
]
>
=
0
)
{
insertClose
=
true
;
*
currVerb
-
=
1
;
goto
addMissingClose
;
}
if
(
pts
!
=
*
ptsPtr
)
{
return
false
;
}
if
(
!
corners
)
{
firstPt
=
pts
;
}
else
{
closeXY
=
*
firstPt
-
*
lastPt
;
if
(
closeXY
.
fX
&
&
closeXY
.
fY
)
{
return
false
;
}
}
lineStart
=
*
pts
+
+
;
closedOrMoved
=
true
;
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
verb
"
)
;
break
;
}
*
currVerb
+
=
1
;
addMissingClose
:
;
}
if
(
corners
<
3
|
|
corners
>
4
)
{
return
false
;
}
if
(
savePts
)
{
*
ptsPtr
=
savePts
;
}
closeXY
=
*
firstPt
-
*
lastPt
;
if
(
closeXY
.
fX
&
&
closeXY
.
fY
)
{
return
false
;
}
if
(
rect
)
{
rect
-
>
set
(
firstCorner
thirdCorner
)
;
}
if
(
isClosed
)
{
*
isClosed
=
autoClose
;
}
if
(
direction
)
{
*
direction
=
directions
[
0
]
=
=
(
(
directions
[
1
]
+
1
)
&
3
)
?
SkPath
:
:
kCW_Direction
:
SkPath
:
:
kCCW_Direction
;
}
return
true
;
}
bool
SkPathPriv
:
:
IsNestedFillRects
(
const
SkPath
&
path
SkRect
rects
[
2
]
SkPath
:
:
Direction
dirs
[
2
]
)
{
SkDEBUGCODE
(
path
.
validate
(
)
;
)
int
currVerb
=
0
;
const
SkPoint
*
pts
=
path
.
fPathRef
-
>
points
(
)
;
SkPath
:
:
Direction
testDirs
[
2
]
;
SkRect
testRects
[
2
]
;
if
(
!
IsRectContour
(
path
true
&
currVerb
&
pts
nullptr
&
testDirs
[
0
]
&
testRects
[
0
]
)
)
{
return
false
;
}
if
(
IsRectContour
(
path
false
&
currVerb
&
pts
nullptr
&
testDirs
[
1
]
&
testRects
[
1
]
)
)
{
if
(
testRects
[
0
]
.
contains
(
testRects
[
1
]
)
)
{
if
(
rects
)
{
rects
[
0
]
=
testRects
[
0
]
;
rects
[
1
]
=
testRects
[
1
]
;
}
if
(
dirs
)
{
dirs
[
0
]
=
testDirs
[
0
]
;
dirs
[
1
]
=
testDirs
[
1
]
;
}
return
true
;
}
if
(
testRects
[
1
]
.
contains
(
testRects
[
0
]
)
)
{
if
(
rects
)
{
rects
[
0
]
=
testRects
[
1
]
;
rects
[
1
]
=
testRects
[
0
]
;
}
if
(
dirs
)
{
dirs
[
0
]
=
testDirs
[
1
]
;
dirs
[
1
]
=
testDirs
[
0
]
;
}
return
true
;
}
}
return
false
;
}
