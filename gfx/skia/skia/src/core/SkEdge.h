#
ifndef
SkEdge_DEFINED
#
define
SkEdge_DEFINED
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkFixed
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
src
/
core
/
SkFDot6
.
h
"
#
include
<
cstdint
>
#
include
<
utility
>
struct
SkIRect
;
#
define
SkEdge_Compute_DY
(
top
y0
)
(
SkLeftShift
(
top
6
)
+
32
-
(
y0
)
)
class
SkEdge
{
public
:
virtual
~
SkEdge
(
)
=
default
;
enum
class
Type
:
int8_t
{
kLine
kQuad
kCubic
}
;
enum
class
Winding
:
int8_t
{
kCW
=
1
kCCW
=
-
1
}
;
SkEdge
*
fNext
;
SkEdge
*
fPrev
;
SkFixed
fX
;
SkFixed
fDxDy
;
int32_t
fFirstY
;
int32_t
fLastY
;
Type
fEdgeType
;
Winding
fWinding
;
bool
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkIRect
*
clip
)
;
inline
bool
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
)
;
bool
hasNextSegment
(
)
const
{
return
fSegmentCount
!
=
0
;
}
virtual
bool
nextSegment
(
)
;
uint8_t
segmentsLeft
(
)
const
{
return
fSegmentCount
;
}
protected
:
inline
bool
updateLine
(
SkFixed
ax
SkFixed
ay
SkFixed
bx
SkFixed
by
)
;
uint8_t
fSegmentCount
;
uint8_t
fCurveShift
;
private
:
void
chopLineWithClip
(
const
SkIRect
&
clip
)
;
#
if
defined
(
SK_DEBUG
)
public
:
virtual
void
dump
(
)
const
;
void
validate
(
)
const
{
SkASSERT
(
fPrev
&
&
fNext
)
;
SkASSERT
(
fPrev
-
>
fNext
=
=
this
)
;
SkASSERT
(
fNext
-
>
fPrev
=
=
this
)
;
SkASSERT
(
fFirstY
<
=
fLastY
)
;
SkASSERT
(
fWinding
=
=
Winding
:
:
kCW
|
|
fWinding
=
=
Winding
:
:
kCCW
)
;
}
#
endif
}
;
class
SkQuadraticEdge
final
:
public
SkEdge
{
public
:
bool
setQuadratic
(
const
SkPoint
pts
[
3
]
)
;
bool
nextSegment
(
)
override
;
private
:
SkFixed
fQx
fQy
;
SkFixed
fQDxDt
fQDyDt
;
SkFixed
fQD2xDt2
fQD2yDt2
;
SkFixed
fQLastX
fQLastY
;
#
if
defined
(
SK_DEBUG
)
public
:
void
dump
(
)
const
override
;
#
endif
}
;
class
SkCubicEdge
final
:
public
SkEdge
{
public
:
bool
setCubic
(
const
SkPoint
pts
[
4
]
)
;
bool
nextSegment
(
)
override
;
private
:
SkFixed
fCx
fCy
;
SkFixed
fCDxDt
fCDyDt
;
SkFixed
fCD2xDt2
fCD2yDt2
;
SkFixed
fCD3xDt3
fCD3yDt3
;
SkFixed
fCLastX
fCLastY
;
uint8_t
fCubicDShift
;
#
if
defined
(
SK_DEBUG
)
public
:
void
dump
(
)
const
override
;
#
endif
}
;
bool
SkEdge
:
:
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
)
{
SkFDot6
x0
y0
x1
y1
;
#
if
defined
(
SK_RASTERIZE_EVEN_ROUNDING
)
x0
=
SkScalarRoundToFDot6
(
p0
.
fX
0
)
;
y0
=
SkScalarRoundToFDot6
(
p0
.
fY
0
)
;
x1
=
SkScalarRoundToFDot6
(
p1
.
fX
0
)
;
y1
=
SkScalarRoundToFDot6
(
p1
.
fY
0
)
;
#
else
x0
=
SkFloatToFDot6
(
p0
.
fX
)
;
y0
=
SkFloatToFDot6
(
p0
.
fY
)
;
x1
=
SkFloatToFDot6
(
p1
.
fX
)
;
y1
=
SkFloatToFDot6
(
p1
.
fY
)
;
#
endif
Winding
winding
=
Winding
:
:
kCW
;
if
(
y0
>
y1
)
{
using
std
:
:
swap
;
swap
(
x0
x1
)
;
swap
(
y0
y1
)
;
winding
=
Winding
:
:
kCCW
;
}
int
top
=
SkFDot6Round
(
y0
)
;
int
bot
=
SkFDot6Round
(
y1
)
;
if
(
top
=
=
bot
)
{
return
false
;
}
SkFixed
slope
=
SkFDot6Div
(
x1
-
x0
y1
-
y0
)
;
const
SkFDot6
dy
=
SkEdge_Compute_DY
(
top
y0
)
;
fX
=
SkFDot6ToFixed
(
x0
+
SkFixedMul
(
slope
dy
)
)
;
fDxDy
=
slope
;
fFirstY
=
top
;
fLastY
=
bot
-
1
;
fEdgeType
=
Type
:
:
kLine
;
fSegmentCount
=
0
;
fWinding
=
winding
;
fCurveShift
=
0
;
return
true
;
}
#
endif
