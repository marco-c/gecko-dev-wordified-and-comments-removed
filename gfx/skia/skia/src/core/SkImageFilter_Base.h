#
ifndef
SkImageFilter_Base_DEFINED
#
define
SkImageFilter_Base_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
class
GrFragmentProcessor
;
class
GrRecordingContext
;
class
SkImageFilter_Base
:
public
SkImageFilter
{
public
:
SK_USE_FLUENT_IMAGE_FILTER_TYPES_IN_CLASS
using
Context
=
skif
:
:
Context
;
skif
:
:
FilterResult
<
For
:
:
kOutput
>
filterImage
(
const
skif
:
:
Context
&
context
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
getInputBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
DeviceSpace
<
SkRect
>
&
desiredOutput
const
skif
:
:
ParameterSpace
<
SkRect
>
*
knownContentBounds
)
const
;
skif
:
:
DeviceSpace
<
SkIRect
>
getOutputBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
ParameterSpace
<
SkRect
>
&
contentBounds
)
const
;
bool
cropRectIsSet
(
)
const
{
return
fCropRect
.
flags
(
)
!
=
0x0
;
}
CropRect
getCropRect
(
)
const
{
return
fCropRect
;
}
SkIRect
filterNodeBounds
(
const
SkIRect
&
srcRect
const
SkMatrix
&
ctm
MapDirection
dir
const
SkIRect
*
inputRect
)
const
{
return
this
-
>
onFilterNodeBounds
(
srcRect
ctm
dir
inputRect
)
;
}
bool
canHandleComplexCTM
(
)
const
;
sk_sp
<
SkImageFilter
>
applyCTM
(
const
SkMatrix
&
ctm
SkMatrix
*
remainder
)
const
;
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
protected
:
class
Common
{
public
:
bool
unflatten
(
SkReadBuffer
&
int
expectedInputs
)
;
const
CropRect
&
cropRect
(
)
const
{
return
fCropRect
;
}
int
inputCount
(
)
const
{
return
fInputs
.
count
(
)
;
}
sk_sp
<
SkImageFilter
>
*
inputs
(
)
{
return
fInputs
.
begin
(
)
;
}
sk_sp
<
SkImageFilter
>
getInput
(
int
index
)
{
return
fInputs
[
index
]
;
}
private
:
CropRect
fCropRect
;
SkSTArray
<
2
sk_sp
<
SkImageFilter
>
true
>
fInputs
;
}
;
enum
class
VisitChildren
:
bool
{
kNo
=
false
kYes
=
true
}
;
SkImageFilter_Base
(
sk_sp
<
SkImageFilter
>
const
*
inputs
int
inputCount
const
CropRect
*
cropRect
)
;
~
SkImageFilter_Base
(
)
override
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
virtual
sk_sp
<
SkSpecialImage
>
onFilterImage
(
const
Context
&
SkIPoint
*
offset
)
const
=
0
;
virtual
SkIRect
onFilterBounds
(
const
SkIRect
&
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
;
virtual
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
;
sk_sp
<
SkSpecialImage
>
filterInput
(
int
index
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
return
this
-
>
getInputFilteredImage
(
index
ctx
)
.
imageAndOffset
(
offset
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
visitInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
visitOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
skif
:
:
FilterResult
<
For
:
:
kInput
>
getInputFilteredImage
(
int
index
const
skif
:
:
Context
&
context
)
const
{
return
this
-
>
filterInput
<
For
:
:
kInput
>
(
index
context
)
;
}
skif
:
:
FilterResult
<
For
:
:
kInput0
>
getInputFilteredImage0
(
const
skif
:
:
Context
&
context
)
const
{
return
this
-
>
filterInput
<
For
:
:
kInput0
>
(
0
context
)
;
}
skif
:
:
FilterResult
<
For
:
:
kInput1
>
getInputFilteredImage1
(
const
skif
:
:
Context
&
context
)
const
{
return
this
-
>
filterInput
<
For
:
:
kInput1
>
(
1
context
)
;
}
const
CropRect
*
getCropRectIfSet
(
)
const
{
return
this
-
>
cropRectIsSet
(
)
?
&
fCropRect
:
nullptr
;
}
bool
applyCropRect
(
const
Context
&
const
SkIRect
&
srcBounds
SkIRect
*
dstBounds
)
const
;
sk_sp
<
SkSpecialImage
>
applyCropRectAndPad
(
const
Context
&
SkSpecialImage
*
src
SkIPoint
*
srcOffset
SkIRect
*
bounds
)
const
;
Context
mapContext
(
const
Context
&
ctx
)
const
;
#
if
SK_SUPPORT_GPU
static
sk_sp
<
SkSpecialImage
>
DrawWithFP
(
GrRecordingContext
*
context
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
const
SkIRect
&
bounds
SkColorType
colorType
const
SkColorSpace
*
colorSpace
GrProtected
isProtected
=
GrProtected
:
:
kNo
)
;
static
sk_sp
<
SkSpecialImage
>
ImageToColorSpace
(
SkSpecialImage
*
src
SkColorType
colorType
SkColorSpace
*
colorSpace
)
;
#
endif
static
SkIRect
DetermineRepeatedSrcBound
(
const
SkIRect
&
srcBounds
const
SkIVector
&
filterOffset
const
SkISize
&
filterSize
const
SkIRect
&
originalSrcBounds
)
;
private
:
friend
class
SkImageFilter
;
friend
class
SkGraphics
;
static
void
PurgeCache
(
)
;
void
init
(
sk_sp
<
SkImageFilter
>
const
*
inputs
int
inputCount
const
CropRect
*
cropRect
)
;
virtual
bool
onIsColorFilterNode
(
SkColorFilter
*
*
)
const
{
return
false
;
}
virtual
bool
onCanHandleComplexCTM
(
)
const
{
return
false
;
}
virtual
bool
affectsTransparentBlack
(
)
const
{
return
false
;
}
virtual
skif
:
:
FilterResult
<
For
:
:
kOutput
>
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
;
virtual
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
VisitChildren
recurse
=
VisitChildren
:
:
kYes
)
const
;
virtual
skif
:
:
LayerSpace
<
SkIRect
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
template
<
skif
:
:
Usage
kU
>
skif
:
:
FilterResult
<
kU
>
filterInput
(
int
index
const
skif
:
:
Context
&
ctx
)
const
;
SkAutoSTArray
<
2
sk_sp
<
SkImageFilter
>
>
fInputs
;
bool
fUsesSrcInput
;
CropRect
fCropRect
;
uint32_t
fUniqueID
;
typedef
SkImageFilter
INHERITED
;
}
;
static
inline
SkImageFilter_Base
*
as_IFB
(
SkImageFilter
*
filter
)
{
return
static_cast
<
SkImageFilter_Base
*
>
(
filter
)
;
}
static
inline
SkImageFilter_Base
*
as_IFB
(
const
sk_sp
<
SkImageFilter
>
&
filter
)
{
return
static_cast
<
SkImageFilter_Base
*
>
(
filter
.
get
(
)
)
;
}
static
inline
const
SkImageFilter_Base
*
as_IFB
(
const
SkImageFilter
*
filter
)
{
return
static_cast
<
const
SkImageFilter_Base
*
>
(
filter
)
;
}
#
define
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
localVar
expectedCount
)
\
Common
localVar
;
\
do
{
\
if
(
!
localVar
.
unflatten
(
buffer
expectedCount
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
#
endif
