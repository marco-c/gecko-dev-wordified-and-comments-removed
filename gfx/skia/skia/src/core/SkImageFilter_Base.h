#
ifndef
SkImageFilter_Base_DEFINED
#
define
SkImageFilter_Base_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
class
GrFragmentProcessor
;
class
GrRecordingContext
;
class
SkImageFilter_Base
:
public
SkImageFilter
{
public
:
using
Context
=
skif
:
:
Context
;
skif
:
:
FilterResult
filterImage
(
const
skif
:
:
Context
&
context
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
getInputBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
DeviceSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
ParameterSpace
<
SkRect
>
*
knownContentBounds
)
const
;
skif
:
:
DeviceSpace
<
SkIRect
>
getOutputBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
ParameterSpace
<
SkRect
>
&
contentBounds
)
const
;
bool
affectsTransparentBlack
(
)
const
;
enum
class
MatrixCapability
{
kTranslate
kScaleTranslate
kComplex
}
;
MatrixCapability
getCTMCapability
(
)
const
;
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
static
SkFlattenable
:
:
Type
GetFlattenableType
(
)
{
return
kSkImageFilter_Type
;
}
SkFlattenable
:
:
Type
getFlattenableType
(
)
const
override
{
return
kSkImageFilter_Type
;
}
protected
:
class
CropRect
{
public
:
enum
CropEdge
{
kHasLeft_CropEdge
=
0x01
kHasTop_CropEdge
=
0x02
kHasWidth_CropEdge
=
0x04
kHasHeight_CropEdge
=
0x08
kHasAll_CropEdge
=
0x0F
}
;
CropRect
(
)
:
fFlags
(
0
)
{
}
explicit
CropRect
(
const
SkRect
*
rect
)
:
fRect
(
rect
?
*
rect
:
SkRect
:
:
MakeEmpty
(
)
)
fFlags
(
rect
?
kHasAll_CropEdge
:
0x0
)
{
}
uint32_t
flags
(
)
const
{
return
fFlags
;
}
const
SkRect
&
rect
(
)
const
{
return
fRect
;
}
void
applyTo
(
const
SkIRect
&
imageBounds
const
SkMatrix
&
matrix
bool
embiggen
SkIRect
*
cropped
)
const
;
private
:
SkRect
fRect
;
uint32_t
fFlags
;
}
;
class
Common
{
public
:
bool
unflatten
(
SkReadBuffer
&
int
expectedInputs
)
;
const
SkRect
*
cropRect
(
)
const
{
return
fCropRect
.
flags
(
)
!
=
0x0
?
&
fCropRect
.
rect
(
)
:
nullptr
;
}
int
inputCount
(
)
const
{
return
fInputs
.
size
(
)
;
}
sk_sp
<
SkImageFilter
>
*
inputs
(
)
{
return
fInputs
.
begin
(
)
;
}
sk_sp
<
SkImageFilter
>
getInput
(
int
index
)
{
return
fInputs
[
index
]
;
}
private
:
CropRect
fCropRect
;
SkSTArray
<
2
sk_sp
<
SkImageFilter
>
true
>
fInputs
;
}
;
enum
class
VisitChildren
:
bool
{
kNo
=
false
kYes
=
true
}
;
SkImageFilter_Base
(
sk_sp
<
SkImageFilter
>
const
*
inputs
int
inputCount
const
SkRect
*
cropRect
)
;
~
SkImageFilter_Base
(
)
override
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
virtual
sk_sp
<
SkSpecialImage
>
onFilterImage
(
const
Context
&
SkIPoint
*
offset
)
const
{
return
nullptr
;
}
virtual
SkIRect
onFilterBounds
(
const
SkIRect
&
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
;
virtual
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
;
sk_sp
<
SkSpecialImage
>
filterInput
(
int
index
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
return
this
-
>
filterInput
(
index
ctx
)
.
imageAndOffset
(
offset
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
visitInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
visitOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
skif
:
:
FilterResult
filterInput
(
int
index
const
skif
:
:
Context
&
ctx
)
const
;
bool
cropRectIsSet
(
)
const
{
return
fCropRect
.
flags
(
)
!
=
0x0
;
}
CropRect
getCropRect
(
)
const
{
return
fCropRect
;
}
const
CropRect
*
getCropRectIfSet
(
)
const
{
return
this
-
>
cropRectIsSet
(
)
?
&
fCropRect
:
nullptr
;
}
bool
applyCropRect
(
const
Context
&
const
SkIRect
&
srcBounds
SkIRect
*
dstBounds
)
const
;
sk_sp
<
SkSpecialImage
>
applyCropRectAndPad
(
const
Context
&
SkSpecialImage
*
src
SkIPoint
*
srcOffset
SkIRect
*
bounds
)
const
;
Context
mapContext
(
const
Context
&
ctx
)
const
;
#
if
defined
(
SK_GANESH
)
static
sk_sp
<
SkSpecialImage
>
DrawWithFP
(
GrRecordingContext
*
context
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
const
SkIRect
&
bounds
SkColorType
colorType
const
SkColorSpace
*
colorSpace
const
SkSurfaceProps
&
GrSurfaceOrigin
surfaceOrigin
GrProtected
isProtected
=
GrProtected
:
:
kNo
)
;
static
sk_sp
<
SkSpecialImage
>
ImageToColorSpace
(
SkSpecialImage
*
src
SkColorType
colorType
SkColorSpace
*
colorSpace
const
SkSurfaceProps
&
)
;
#
endif
static
SkIRect
DetermineRepeatedSrcBound
(
const
SkIRect
&
srcBounds
const
SkIVector
&
filterOffset
const
SkISize
&
filterSize
const
SkIRect
&
originalSrcBounds
)
;
private
:
friend
class
SkImageFilter
;
friend
class
SkGraphics
;
static
void
PurgeCache
(
)
;
virtual
bool
onIsColorFilterNode
(
SkColorFilter
*
*
)
const
{
return
false
;
}
virtual
MatrixCapability
onGetCTMCapability
(
)
const
{
return
MatrixCapability
:
:
kScaleTranslate
;
}
virtual
bool
onAffectsTransparentBlack
(
)
const
{
return
false
;
}
virtual
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
;
virtual
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
VisitChildren
recurse
=
VisitChildren
:
:
kYes
)
const
;
virtual
skif
:
:
LayerSpace
<
SkIRect
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
;
skia_private
:
:
AutoSTArray
<
2
sk_sp
<
SkImageFilter
>
>
fInputs
;
bool
fUsesSrcInput
;
CropRect
fCropRect
;
uint32_t
fUniqueID
;
using
INHERITED
=
SkImageFilter
;
}
;
static
inline
SkImageFilter_Base
*
as_IFB
(
SkImageFilter
*
filter
)
{
return
static_cast
<
SkImageFilter_Base
*
>
(
filter
)
;
}
static
inline
SkImageFilter_Base
*
as_IFB
(
const
sk_sp
<
SkImageFilter
>
&
filter
)
{
return
static_cast
<
SkImageFilter_Base
*
>
(
filter
.
get
(
)
)
;
}
static
inline
const
SkImageFilter_Base
*
as_IFB
(
const
SkImageFilter
*
filter
)
{
return
static_cast
<
const
SkImageFilter_Base
*
>
(
filter
)
;
}
#
define
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
localVar
expectedCount
)
\
Common
localVar
;
\
do
{
\
if
(
!
localVar
.
unflatten
(
buffer
expectedCount
)
)
{
\
return
nullptr
;
\
}
\
}
while
(
0
)
void
SkRegisterAlphaThresholdImageFilterFlattenable
(
)
;
void
SkRegisterArithmeticImageFilterFlattenable
(
)
;
void
SkRegisterBlendImageFilterFlattenable
(
)
;
void
SkRegisterBlurImageFilterFlattenable
(
)
;
void
SkRegisterColorFilterImageFilterFlattenable
(
)
;
void
SkRegisterComposeImageFilterFlattenable
(
)
;
void
SkRegisterCropImageFilterFlattenable
(
)
;
void
SkRegisterDisplacementMapImageFilterFlattenable
(
)
;
void
SkRegisterDropShadowImageFilterFlattenable
(
)
;
void
SkRegisterImageImageFilterFlattenable
(
)
;
void
SkRegisterLightingImageFilterFlattenables
(
)
;
void
SkRegisterMagnifierImageFilterFlattenable
(
)
;
void
SkRegisterMatrixConvolutionImageFilterFlattenable
(
)
;
void
SkRegisterMatrixTransformImageFilterFlattenable
(
)
;
void
SkRegisterMergeImageFilterFlattenable
(
)
;
void
SkRegisterMorphologyImageFilterFlattenables
(
)
;
void
SkRegisterPictureImageFilterFlattenable
(
)
;
#
ifdef
SK_ENABLE_SKSL
void
SkRegisterRuntimeImageFilterFlattenable
(
)
;
#
endif
void
SkRegisterShaderImageFilterFlattenable
(
)
;
void
SkRegisterTileImageFilterFlattenable
(
)
;
#
endif
