#
ifndef
SkSamplingPriv_DEFINED
#
define
SkSamplingPriv_DEFINED
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
class
SkReadBuffer
;
class
SkWriteBuffer
;
enum
SkLegacyFQ
{
kNone_SkLegacyFQ
=
0
kLow_SkLegacyFQ
=
1
kMedium_SkLegacyFQ
=
2
kHigh_SkLegacyFQ
=
3
kLast_SkLegacyFQ
=
kHigh_SkLegacyFQ
}
;
enum
SkMediumAs
{
kNearest_SkMediumAs
kLinear_SkMediumAs
}
;
class
SkSamplingPriv
{
public
:
static
size_t
FlatSize
(
const
SkSamplingOptions
&
options
)
{
size_t
size
=
sizeof
(
uint32_t
)
;
if
(
!
options
.
isAniso
(
)
)
{
size
+
=
3
*
sizeof
(
uint32_t
)
;
}
return
size
;
}
static
bool
NoChangeWithIdentityMatrix
(
const
SkSamplingOptions
&
sampling
)
{
return
!
sampling
.
useCubic
|
|
sampling
.
cubic
.
B
=
=
0
;
}
static
SkSamplingOptions
AnisoFallback
(
bool
imageIsMipped
)
{
auto
mm
=
imageIsMipped
?
SkMipmapMode
:
:
kLinear
:
SkMipmapMode
:
:
kNone
;
return
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
mm
)
;
}
static
SkSamplingOptions
FromFQ
(
SkLegacyFQ
fq
SkMediumAs
behavior
=
kNearest_SkMediumAs
)
{
switch
(
fq
)
{
case
kHigh_SkLegacyFQ
:
return
SkSamplingOptions
(
SkCubicResampler
{
1
/
3
.
0f
1
/
3
.
0f
}
)
;
case
kMedium_SkLegacyFQ
:
return
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
behavior
=
=
kNearest_SkMediumAs
?
SkMipmapMode
:
:
kNearest
:
SkMipmapMode
:
:
kLinear
)
;
case
kLow_SkLegacyFQ
:
return
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
SkMipmapMode
:
:
kNone
)
;
case
kNone_SkLegacyFQ
:
break
;
}
return
SkSamplingOptions
(
SkFilterMode
:
:
kNearest
SkMipmapMode
:
:
kNone
)
;
}
}
;
#
endif
