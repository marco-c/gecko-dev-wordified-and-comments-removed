#
ifndef
SkLinearBitmapPipeline_sampler_DEFINED
#
define
SkLinearBitmapPipeline_sampler_DEFINED
#
include
<
tuple
>
#
include
"
SkColor
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkFixed
.
h
"
#
include
"
SkHalf
.
h
"
#
include
"
SkLinearBitmapPipeline_core
.
h
"
#
include
"
SkNx
.
h
"
#
include
"
SkPM4fPriv
.
h
"
namespace
{
static
Sk4s
SK_VECTORCALL
bilerp4
(
Sk4s
xs
Sk4s
ys
Sk4f
px00
Sk4f
px10
Sk4f
px01
Sk4f
px11
)
{
Sk4s
fxs
=
xs
-
xs
.
floor
(
)
;
Sk4s
fys
=
ys
-
ys
.
floor
(
)
;
Sk4s
fxys
{
fxs
*
fys
}
;
Sk4f
sum
=
px11
*
fxys
;
sum
=
sum
+
px01
*
(
fys
-
fxys
)
;
sum
=
sum
+
px10
*
(
fxs
-
fxys
)
;
sum
=
sum
+
px00
*
(
Sk4f
{
1
.
0f
}
-
fxs
-
fys
+
fxys
)
;
return
sum
;
}
template
<
SkColorType
SkGammaType
>
class
PixelConverter
;
template
<
>
class
PixelConverter
<
kAlpha_8_SkColorType
kLinear_SkGammaType
>
{
public
:
using
Element
=
uint8_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
SkColor
tintColor
)
:
fTintColor
{
set_alpha
(
Sk4f_from_SkColor
(
tintColor
)
1
.
0f
)
}
{
}
Sk4f
toSk4f
(
const
Element
pixel
)
const
{
return
fTintColor
*
(
pixel
*
(
1
.
0f
/
255
.
0f
)
)
;
}
private
:
const
Sk4f
fTintColor
;
}
;
template
<
SkGammaType
gammaType
>
static
inline
Sk4f
pmcolor_to_rgba
(
SkPMColor
pixel
)
{
return
swizzle_rb_if_bgra
(
(
gammaType
=
=
kSRGB_SkGammaType
)
?
Sk4f_fromS32
(
pixel
)
:
Sk4f_fromL32
(
pixel
)
)
;
}
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kRGB_565_SkColorType
gammaType
>
{
public
:
using
Element
=
uint16_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
Element
pixel
)
const
{
return
pmcolor_to_rgba
<
gammaType
>
(
SkPixel16ToPixel32
(
pixel
)
)
;
}
}
;
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kARGB_4444_SkColorType
gammaType
>
{
public
:
using
Element
=
uint16_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
Element
pixel
)
const
{
return
pmcolor_to_rgba
<
gammaType
>
(
SkPixel4444ToPixel32
(
pixel
)
)
;
}
}
;
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kRGBA_8888_SkColorType
gammaType
>
{
public
:
using
Element
=
uint32_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
Element
pixel
)
const
{
return
gammaType
=
=
kSRGB_SkGammaType
?
Sk4f_fromS32
(
pixel
)
:
Sk4f_fromL32
(
pixel
)
;
}
}
;
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kBGRA_8888_SkColorType
gammaType
>
{
public
:
using
Element
=
uint32_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
Element
pixel
)
const
{
return
swizzle_rb
(
gammaType
=
=
kSRGB_SkGammaType
?
Sk4f_fromS32
(
pixel
)
:
Sk4f_fromL32
(
pixel
)
)
;
}
}
;
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kIndex_8_SkColorType
gammaType
>
{
public
:
using
Element
=
uint8_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
:
fColorTableSize
(
srcPixmap
.
ctable
(
)
-
>
count
(
)
)
{
SkColorTable
*
skColorTable
=
srcPixmap
.
ctable
(
)
;
SkASSERT
(
skColorTable
!
=
nullptr
)
;
fColorTable
=
(
Sk4f
*
)
SkAlign16
(
(
intptr_t
)
fColorTableStorage
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
fColorTableSize
;
i
+
+
)
{
fColorTable
[
i
]
=
pmcolor_to_rgba
<
gammaType
>
(
(
*
skColorTable
)
[
i
]
)
;
}
}
PixelConverter
(
const
PixelConverter
&
strategy
)
:
fColorTableSize
{
strategy
.
fColorTableSize
}
{
fColorTable
=
(
Sk4f
*
)
SkAlign16
(
(
intptr_t
)
fColorTableStorage
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
fColorTableSize
;
i
+
+
)
{
fColorTable
[
i
]
=
strategy
.
fColorTable
[
i
]
;
}
}
Sk4f
toSk4f
(
Element
index
)
const
{
return
fColorTable
[
index
]
;
}
private
:
static
const
size_t
kColorTableSize
=
sizeof
(
Sk4f
[
256
]
)
+
12
;
const
int
fColorTableSize
;
SkAutoMalloc
fColorTableStorage
{
kColorTableSize
}
;
Sk4f
*
fColorTable
;
}
;
template
<
SkGammaType
gammaType
>
class
PixelConverter
<
kGray_8_SkColorType
gammaType
>
{
public
:
using
Element
=
uint8_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
Element
pixel
)
const
{
float
gray
=
(
gammaType
=
=
kSRGB_SkGammaType
)
?
sk_linear_from_srgb
[
pixel
]
:
pixel
*
(
1
/
255
.
0f
)
;
return
{
gray
gray
gray
1
.
0f
}
;
}
}
;
template
<
>
class
PixelConverter
<
kRGBA_F16_SkColorType
kLinear_SkGammaType
>
{
public
:
using
Element
=
uint64_t
;
PixelConverter
(
const
SkPixmap
&
srcPixmap
)
{
}
Sk4f
toSk4f
(
const
Element
pixel
)
const
{
return
SkHalfToFloat_finite_ftz
(
pixel
)
;
}
}
;
class
PixelAccessorShim
{
public
:
explicit
PixelAccessorShim
(
SkLinearBitmapPipeline
:
:
PixelAccessorInterface
*
accessor
)
:
fPixelAccessor
(
accessor
)
{
}
void
SK_VECTORCALL
getFewPixels
(
int
n
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
)
const
{
fPixelAccessor
-
>
getFewPixels
(
n
xs
ys
px0
px1
px2
)
;
}
void
SK_VECTORCALL
get4Pixels
(
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
{
fPixelAccessor
-
>
get4Pixels
(
xs
ys
px0
px1
px2
px3
)
;
}
void
get4Pixels
(
const
void
*
src
int
index
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
{
fPixelAccessor
-
>
get4Pixels
(
src
index
px0
px1
px2
px3
)
;
}
Sk4f
getPixelFromRow
(
const
void
*
row
int
index
)
const
{
return
fPixelAccessor
-
>
getPixelFromRow
(
row
index
)
;
}
Sk4f
getPixelAt
(
int
index
)
const
{
return
fPixelAccessor
-
>
getPixelAt
(
index
)
;
}
const
void
*
row
(
int
y
)
const
{
return
fPixelAccessor
-
>
row
(
y
)
;
}
private
:
SkLinearBitmapPipeline
:
:
PixelAccessorInterface
*
const
fPixelAccessor
;
}
;
template
<
SkColorType
colorType
SkGammaType
gammaType
>
class
PixelAccessor
final
:
public
SkLinearBitmapPipeline
:
:
PixelAccessorInterface
{
using
Element
=
typename
PixelConverter
<
colorType
gammaType
>
:
:
Element
;
public
:
template
<
typename
.
.
.
Args
>
PixelAccessor
(
const
SkPixmap
&
srcPixmap
Args
&
&
.
.
.
args
)
:
fSrc
{
static_cast
<
const
Element
*
>
(
srcPixmap
.
addr
(
)
)
}
fWidth
{
srcPixmap
.
rowBytesAsPixels
(
)
}
fConverter
{
srcPixmap
std
:
:
move
<
Args
>
(
args
)
.
.
.
}
{
}
void
SK_VECTORCALL
getFewPixels
(
int
n
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
)
const
override
{
Sk4i
bufferLoc
=
ys
*
fWidth
+
xs
;
switch
(
n
)
{
case
3
:
*
px2
=
this
-
>
getPixelAt
(
bufferLoc
[
2
]
)
;
case
2
:
*
px1
=
this
-
>
getPixelAt
(
bufferLoc
[
1
]
)
;
case
1
:
*
px0
=
this
-
>
getPixelAt
(
bufferLoc
[
0
]
)
;
default
:
break
;
}
}
void
SK_VECTORCALL
get4Pixels
(
Sk4i
xs
Sk4i
ys
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
override
{
Sk4i
bufferLoc
=
ys
*
fWidth
+
xs
;
*
px0
=
this
-
>
getPixelAt
(
bufferLoc
[
0
]
)
;
*
px1
=
this
-
>
getPixelAt
(
bufferLoc
[
1
]
)
;
*
px2
=
this
-
>
getPixelAt
(
bufferLoc
[
2
]
)
;
*
px3
=
this
-
>
getPixelAt
(
bufferLoc
[
3
]
)
;
}
void
get4Pixels
(
const
void
*
src
int
index
Sk4f
*
px0
Sk4f
*
px1
Sk4f
*
px2
Sk4f
*
px3
)
const
override
{
*
px0
=
this
-
>
getPixelFromRow
(
src
index
+
0
)
;
*
px1
=
this
-
>
getPixelFromRow
(
src
index
+
1
)
;
*
px2
=
this
-
>
getPixelFromRow
(
src
index
+
2
)
;
*
px3
=
this
-
>
getPixelFromRow
(
src
index
+
3
)
;
}
Sk4f
getPixelFromRow
(
const
void
*
row
int
index
)
const
override
{
const
Element
*
src
=
static_cast
<
const
Element
*
>
(
row
)
;
return
fConverter
.
toSk4f
(
src
[
index
]
)
;
}
Sk4f
getPixelAt
(
int
index
)
const
override
{
return
this
-
>
getPixelFromRow
(
fSrc
index
)
;
}
const
void
*
row
(
int
y
)
const
override
{
return
fSrc
+
y
*
fWidth
;
}
private
:
const
Element
*
const
fSrc
;
const
int
fWidth
;
PixelConverter
<
colorType
gammaType
>
fConverter
;
}
;
template
<
typename
Next
typename
Strategy
>
static
void
src_strategy_blend
(
Span
span
Next
*
next
Strategy
*
strategy
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
int
ix
=
SkScalarFloorToInt
(
X
(
start
)
)
;
const
void
*
row
=
strategy
-
>
row
(
(
int
)
std
:
:
floor
(
Y
(
start
)
)
)
;
if
(
length
>
0
)
{
while
(
count
>
=
4
)
{
Sk4f
px0
px1
px2
px3
;
strategy
-
>
get4Pixels
(
row
ix
&
px0
&
px1
&
px2
&
px3
)
;
next
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
ix
+
=
4
;
count
-
=
4
;
}
while
(
count
>
0
)
{
next
-
>
blendPixel
(
strategy
-
>
getPixelFromRow
(
row
ix
)
)
;
ix
+
=
1
;
count
-
=
1
;
}
}
else
{
while
(
count
>
=
4
)
{
Sk4f
px0
px1
px2
px3
;
strategy
-
>
get4Pixels
(
row
ix
-
3
&
px3
&
px2
&
px1
&
px0
)
;
next
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
ix
-
=
4
;
count
-
=
4
;
}
while
(
count
>
0
)
{
next
-
>
blendPixel
(
strategy
-
>
getPixelFromRow
(
row
ix
)
)
;
ix
-
=
1
;
count
-
=
1
;
}
}
}
template
<
typename
Accessor
typename
Next
>
class
NearestNeighborSampler
:
public
SkLinearBitmapPipeline
:
:
SampleProcessorInterface
{
public
:
template
<
typename
.
.
.
Args
>
NearestNeighborSampler
(
SkLinearBitmapPipeline
:
:
BlendProcessorInterface
*
next
Args
&
&
.
.
.
args
)
:
fNext
{
next
}
fAccessor
{
std
:
:
forward
<
Args
>
(
args
)
.
.
.
}
{
}
NearestNeighborSampler
(
SkLinearBitmapPipeline
:
:
BlendProcessorInterface
*
next
const
NearestNeighborSampler
&
sampler
)
:
fNext
{
next
}
fAccessor
{
sampler
.
fAccessor
}
{
}
void
SK_VECTORCALL
pointListFew
(
int
n
Sk4s
xs
Sk4s
ys
)
override
{
SkASSERT
(
0
<
n
&
&
n
<
4
)
;
Sk4f
px0
px1
px2
;
fAccessor
.
getFewPixels
(
n
SkNx_cast
<
int
>
(
xs
)
SkNx_cast
<
int
>
(
ys
)
&
px0
&
px1
&
px2
)
;
if
(
n
>
=
1
)
fNext
-
>
blendPixel
(
px0
)
;
if
(
n
>
=
2
)
fNext
-
>
blendPixel
(
px1
)
;
if
(
n
>
=
3
)
fNext
-
>
blendPixel
(
px2
)
;
}
void
SK_VECTORCALL
pointList4
(
Sk4s
xs
Sk4s
ys
)
override
{
Sk4f
px0
px1
px2
px3
;
fAccessor
.
get4Pixels
(
SkNx_cast
<
int
>
(
xs
)
SkNx_cast
<
int
>
(
ys
)
&
px0
&
px1
&
px2
&
px3
)
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
}
void
pointSpan
(
Span
span
)
override
{
SkASSERT
(
!
span
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
SkScalar
absLength
=
SkScalarAbs
(
length
)
;
if
(
absLength
<
(
count
-
1
)
)
{
this
-
>
spanSlowRate
(
span
)
;
}
else
if
(
absLength
=
=
(
count
-
1
)
)
{
src_strategy_blend
(
span
fNext
&
fAccessor
)
;
}
else
{
this
-
>
spanFastRate
(
span
)
;
}
}
void
repeatSpan
(
Span
span
int32_t
repeatCount
)
override
{
while
(
repeatCount
>
0
)
{
this
-
>
pointSpan
(
span
)
;
repeatCount
-
-
;
}
}
private
:
void
spanSlowRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
SkScalar
x
=
X
(
start
)
;
SkFixed
fx
=
SkScalarToFixed
(
x
)
;
SkScalar
dx
=
length
/
(
count
-
1
)
;
SkFixed
fdx
=
SkScalarToFixed
(
dx
)
;
const
void
*
row
=
fAccessor
.
row
(
(
int
)
std
:
:
floor
(
Y
(
start
)
)
)
;
Next
*
next
=
fNext
;
int
ix
=
SkFixedFloorToInt
(
fx
)
;
int
prevIX
=
ix
;
Sk4f
fpixel
=
fAccessor
.
getPixelFromRow
(
row
ix
)
;
auto
getNextPixel
=
[
&
]
(
)
{
if
(
ix
!
=
prevIX
)
{
fpixel
=
fAccessor
.
getPixelFromRow
(
row
ix
)
;
prevIX
=
ix
;
}
fx
+
=
fdx
;
ix
=
SkFixedFloorToInt
(
fx
)
;
return
fpixel
;
}
;
while
(
count
>
=
4
)
{
Sk4f
px0
=
getNextPixel
(
)
;
Sk4f
px1
=
getNextPixel
(
)
;
Sk4f
px2
=
getNextPixel
(
)
;
Sk4f
px3
=
getNextPixel
(
)
;
next
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
next
-
>
blendPixel
(
getNextPixel
(
)
)
;
count
-
=
1
;
}
}
void
spanUnitRate
(
Span
span
)
{
src_strategy_blend
(
span
fNext
&
fAccessor
)
;
}
void
spanFastRate
(
Span
span
)
{
span_fallback
(
span
this
)
;
}
Next
*
const
fNext
;
Accessor
fAccessor
;
}
;
static
inline
int
adjust_edge
(
SkShader
:
:
TileMode
edgeType
int
vs
int
vMax
)
{
SkASSERT
(
-
1
<
=
vs
&
&
vs
<
=
vMax
+
1
)
;
switch
(
edgeType
)
{
case
SkShader
:
:
kClamp_TileMode
:
case
SkShader
:
:
kMirror_TileMode
:
vs
=
std
:
:
max
(
vs
0
)
;
vs
=
std
:
:
min
(
vs
vMax
)
;
break
;
case
SkShader
:
:
kRepeat_TileMode
:
vs
=
(
vs
<
=
vMax
)
?
vs
:
0
;
vs
=
(
vs
>
=
0
)
?
vs
:
vMax
;
break
;
}
SkASSERT
(
0
<
=
vs
&
&
vs
<
=
vMax
)
;
return
vs
;
}
static
SkScalar
sample_to_filter
(
SkScalar
x
)
{
SkASSERT
(
x
>
=
0
.
0f
)
;
SkScalar
v
=
x
+
0
.
5f
;
SkScalar
f
=
v
-
SkScalarTruncToScalar
(
v
)
;
SkScalar
r
=
1
.
0f
-
f
;
SkASSERT
(
0
.
0f
<
r
&
&
r
<
=
1
.
0f
)
;
return
r
;
}
template
<
typename
Accessor
typename
Next
>
class
BilerpSampler
:
public
SkLinearBitmapPipeline
:
:
SampleProcessorInterface
{
public
:
template
<
typename
.
.
.
Args
>
BilerpSampler
(
SkLinearBitmapPipeline
:
:
BlendProcessorInterface
*
next
SkISize
dimensions
SkShader
:
:
TileMode
xTile
SkShader
:
:
TileMode
yTile
Args
&
&
.
.
.
args
)
:
fNext
{
next
}
fXEdgeType
{
xTile
}
fXMax
{
dimensions
.
width
(
)
-
1
}
fYEdgeType
{
yTile
}
fYMax
{
dimensions
.
height
(
)
-
1
}
fAccessor
{
std
:
:
forward
<
Args
>
(
args
)
.
.
.
}
{
}
BilerpSampler
(
SkLinearBitmapPipeline
:
:
BlendProcessorInterface
*
next
const
BilerpSampler
&
sampler
)
:
fNext
{
next
}
fXEdgeType
{
sampler
.
fXEdgeType
}
fXMax
{
sampler
.
fXMax
}
fYEdgeType
{
sampler
.
fYEdgeType
}
fYMax
{
sampler
.
fYMax
}
fAccessor
{
sampler
.
fAccessor
}
{
}
void
SK_VECTORCALL
pointListFew
(
int
n
Sk4s
xs
Sk4s
ys
)
override
{
SkASSERT
(
0
<
n
&
&
n
<
4
)
;
auto
bilerpPixel
=
[
&
]
(
int
index
)
{
return
this
-
>
bilerpSamplePoint
(
SkPoint
{
xs
[
index
]
ys
[
index
]
}
)
;
}
;
if
(
n
>
=
1
)
fNext
-
>
blendPixel
(
bilerpPixel
(
0
)
)
;
if
(
n
>
=
2
)
fNext
-
>
blendPixel
(
bilerpPixel
(
1
)
)
;
if
(
n
>
=
3
)
fNext
-
>
blendPixel
(
bilerpPixel
(
2
)
)
;
}
void
SK_VECTORCALL
pointList4
(
Sk4s
xs
Sk4s
ys
)
override
{
auto
bilerpPixel
=
[
&
]
(
int
index
)
{
return
this
-
>
bilerpSamplePoint
(
SkPoint
{
xs
[
index
]
ys
[
index
]
}
)
;
}
;
fNext
-
>
blend4Pixels
(
bilerpPixel
(
0
)
bilerpPixel
(
1
)
bilerpPixel
(
2
)
bilerpPixel
(
3
)
)
;
}
void
pointSpan
(
Span
span
)
override
{
SkASSERT
(
!
span
.
isEmpty
(
)
)
;
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
if
(
count
=
=
0
)
{
return
;
}
if
(
count
=
=
1
)
{
fNext
-
>
blendPixel
(
this
-
>
bilerpSamplePoint
(
start
)
)
;
return
;
}
SkScalar
absLength
=
SkScalarAbs
(
length
)
;
if
(
absLength
=
=
0
.
0f
)
{
this
-
>
spanZeroRate
(
span
)
;
}
else
if
(
absLength
<
(
count
-
1
)
)
{
this
-
>
spanSlowRate
(
span
)
;
}
else
if
(
absLength
=
=
(
count
-
1
)
)
{
if
(
sample_to_filter
(
span
.
startX
(
)
)
=
=
1
.
0f
&
&
sample_to_filter
(
span
.
startY
(
)
)
=
=
1
.
0f
)
{
src_strategy_blend
(
span
fNext
&
fAccessor
)
;
}
else
{
this
-
>
spanUnitRate
(
span
)
;
}
}
else
if
(
absLength
<
2
.
0f
*
(
count
-
1
)
)
{
this
-
>
spanMediumRate
(
span
)
;
}
else
{
this
-
>
spanFastRate
(
span
)
;
}
}
void
repeatSpan
(
Span
span
int32_t
repeatCount
)
override
{
while
(
repeatCount
>
0
)
{
this
-
>
pointSpan
(
span
)
;
repeatCount
-
-
;
}
}
private
:
void
filterPoints
(
SkPoint
sample
Sk4i
*
filterXs
Sk4i
*
filterYs
)
{
int
x0
=
adjust_edge
(
fXEdgeType
SkScalarFloorToInt
(
X
(
sample
)
-
0
.
5
)
fXMax
)
;
int
x1
=
adjust_edge
(
fXEdgeType
SkScalarTruncToInt
(
X
(
sample
)
+
0
.
5
)
fXMax
)
;
int
y0
=
adjust_edge
(
fYEdgeType
SkScalarFloorToInt
(
Y
(
sample
)
-
0
.
5
)
fYMax
)
;
int
y1
=
adjust_edge
(
fYEdgeType
SkScalarTruncToInt
(
Y
(
sample
)
+
0
.
5
)
fYMax
)
;
*
filterXs
=
Sk4i
{
x0
x1
x0
x1
}
;
*
filterYs
=
Sk4i
{
y0
y0
y1
y1
}
;
}
Sk4f
bilerpSamplePoint
(
SkPoint
sample
)
{
Sk4i
iXs
iYs
;
filterPoints
(
sample
&
iXs
&
iYs
)
;
Sk4f
px00
px10
px01
px11
;
fAccessor
.
get4Pixels
(
iXs
iYs
&
px00
&
px10
&
px01
&
px11
)
;
return
bilerp4
(
Sk4f
{
X
(
sample
)
-
0
.
5f
}
Sk4f
{
Y
(
sample
)
-
0
.
5f
}
px00
px10
px01
px11
)
;
}
void
get2PixelColumn
(
const
void
*
row0
const
void
*
row1
int
x
Sk4f
*
px0
Sk4f
*
px1
)
{
*
px0
=
fAccessor
.
getPixelFromRow
(
row0
x
)
;
*
px1
=
fAccessor
.
getPixelFromRow
(
row1
x
)
;
}
void
spanZeroRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
SkASSERT
(
length
=
=
0
.
0f
)
;
SkScalar
filterY
=
sample_to_filter
(
Y
(
start
)
)
;
Sk4i
iXs
iYs
;
this
-
>
filterPoints
(
start
&
iXs
&
iYs
)
;
const
void
*
const
row0
=
fAccessor
.
row
(
iYs
[
0
]
)
;
const
void
*
const
row1
=
fAccessor
.
row
(
iYs
[
2
]
)
;
Sk4f
pxTop
pxBottom
;
this
-
>
get2PixelColumn
(
row0
row1
SkScalarFloorToInt
(
X
(
start
)
)
&
pxTop
&
pxBottom
)
;
Sk4f
pixel
=
pxTop
*
filterY
+
(
1
.
0f
-
filterY
)
*
pxBottom
;
while
(
count
>
=
4
)
{
fNext
-
>
blend4Pixels
(
pixel
pixel
pixel
pixel
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
pixel
)
;
count
-
=
1
;
}
}
void
spanSlowRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
const
SkScalar
dx
=
length
/
(
count
-
1
)
;
SkASSERT
(
-
1
.
0f
<
dx
&
&
dx
<
1
.
0f
&
&
dx
!
=
0
.
0f
)
;
SkScalar
filterX
=
sample_to_filter
(
X
(
start
)
)
;
SkScalar
filterY
=
sample_to_filter
(
Y
(
start
)
)
;
Sk4i
iXs
iYs
;
this
-
>
filterPoints
(
start
&
iXs
&
iYs
)
;
const
void
*
const
row0
=
fAccessor
.
row
(
iYs
[
0
]
)
;
const
void
*
const
row1
=
fAccessor
.
row
(
iYs
[
2
]
)
;
auto
partAtColumn
=
[
&
]
(
int
xColumn
)
{
int
adjustedColumn
=
adjust_edge
(
fXEdgeType
xColumn
fXMax
)
;
Sk4f
pxTop
pxBottom
;
this
-
>
get2PixelColumn
(
row0
row1
adjustedColumn
&
pxTop
&
pxBottom
)
;
return
pxTop
*
filterY
+
(
1
.
0f
-
filterY
)
*
pxBottom
;
}
;
Sk4f
leftPart
=
partAtColumn
(
iXs
[
0
]
)
;
Sk4f
rightPart
=
partAtColumn
(
iXs
[
1
]
)
;
auto
bilerp
=
[
&
]
(
const
Sk4f
&
leftPart
const
Sk4f
&
rightPart
)
{
Sk4f
pixel
=
leftPart
*
filterX
+
rightPart
*
(
1
.
0f
-
filterX
)
;
return
check_pixel
(
pixel
)
;
}
;
fNext
-
>
blendPixel
(
bilerp
(
leftPart
rightPart
)
)
;
count
-
=
1
;
if
(
dx
>
0
.
0f
)
{
int
rightPartCursor
=
iXs
[
1
]
;
auto
advanceFilter
=
[
&
]
(
)
{
filterX
-
=
dx
;
if
(
filterX
<
=
0
.
0f
)
{
filterX
+
=
1
.
0f
;
leftPart
=
rightPart
;
rightPartCursor
+
=
1
;
rightPart
=
partAtColumn
(
rightPartCursor
)
;
}
SkASSERT
(
0
.
0f
<
filterX
&
&
filterX
<
=
1
.
0f
)
;
return
bilerp
(
leftPart
rightPart
)
;
}
;
while
(
count
>
=
4
)
{
Sk4f
px0
=
advanceFilter
(
)
px1
=
advanceFilter
(
)
px2
=
advanceFilter
(
)
px3
=
advanceFilter
(
)
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
advanceFilter
(
)
)
;
count
-
=
1
;
}
}
else
{
int
leftPartCursor
=
iXs
[
0
]
;
auto
advanceFilter
=
[
&
]
(
)
{
filterX
-
=
dx
;
if
(
filterX
>
1
.
0f
)
{
filterX
-
=
1
.
0f
;
rightPart
=
leftPart
;
leftPartCursor
-
=
1
;
leftPart
=
partAtColumn
(
leftPartCursor
)
;
}
SkASSERT
(
0
.
0f
<
filterX
&
&
filterX
<
=
1
.
0f
)
;
return
bilerp
(
leftPart
rightPart
)
;
}
;
while
(
count
>
=
4
)
{
Sk4f
px0
=
advanceFilter
(
)
px1
=
advanceFilter
(
)
px2
=
advanceFilter
(
)
px3
=
advanceFilter
(
)
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
advanceFilter
(
)
)
;
count
-
=
1
;
}
}
}
void
spanUnitRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
SkASSERT
(
SkScalarAbs
(
length
)
=
=
(
count
-
1
)
)
;
Sk4i
iXs
iYs
;
filterPoints
(
start
&
iXs
&
iYs
)
;
const
void
*
row0
=
fAccessor
.
row
(
iYs
[
0
]
)
;
const
void
*
row1
=
fAccessor
.
row
(
iYs
[
2
]
)
;
const
SkScalar
filterX
=
sample_to_filter
(
X
(
start
)
)
;
const
SkScalar
filterY
=
sample_to_filter
(
Y
(
start
)
)
;
auto
partAtColumn
=
[
&
]
(
int
xColumn
)
{
int
adjustedColumn
=
adjust_edge
(
fXEdgeType
xColumn
fXMax
)
;
Sk4f
pxTop
pxBottom
;
this
-
>
get2PixelColumn
(
row0
row1
adjustedColumn
&
pxTop
&
pxBottom
)
;
return
pxTop
*
filterY
+
(
1
.
0f
-
filterY
)
*
pxBottom
;
}
;
auto
get4Parts
=
[
&
]
(
int
ix
Sk4f
*
part0
Sk4f
*
part1
Sk4f
*
part2
Sk4f
*
part3
)
{
if
(
0
<
=
ix
&
&
ix
<
=
fXMax
-
3
)
{
Sk4f
px00
px10
px20
px30
px01
px11
px21
px31
;
fAccessor
.
get4Pixels
(
row0
ix
&
px00
&
px10
&
px20
&
px30
)
;
fAccessor
.
get4Pixels
(
row1
ix
&
px01
&
px11
&
px21
&
px31
)
;
*
part0
=
filterY
*
px00
+
(
1
.
0f
-
filterY
)
*
px01
;
*
part1
=
filterY
*
px10
+
(
1
.
0f
-
filterY
)
*
px11
;
*
part2
=
filterY
*
px20
+
(
1
.
0f
-
filterY
)
*
px21
;
*
part3
=
filterY
*
px30
+
(
1
.
0f
-
filterY
)
*
px31
;
}
else
{
*
part0
=
partAtColumn
(
ix
+
0
)
;
*
part1
=
partAtColumn
(
ix
+
1
)
;
*
part2
=
partAtColumn
(
ix
+
2
)
;
*
part3
=
partAtColumn
(
ix
+
3
)
;
}
}
;
auto
bilerp
=
[
&
]
(
const
Sk4f
&
part0
const
Sk4f
&
part1
)
{
return
part0
*
filterX
+
part1
*
(
1
.
0f
-
filterX
)
;
}
;
if
(
length
>
0
)
{
Sk4f
overlapPart
=
partAtColumn
(
iXs
[
0
]
)
;
int
rightColumnCursor
=
iXs
[
1
]
;
while
(
count
>
=
4
)
{
Sk4f
part0
part1
part2
part3
;
get4Parts
(
rightColumnCursor
&
part0
&
part1
&
part2
&
part3
)
;
Sk4f
px0
=
bilerp
(
overlapPart
part0
)
;
Sk4f
px1
=
bilerp
(
part0
part1
)
;
Sk4f
px2
=
bilerp
(
part1
part2
)
;
Sk4f
px3
=
bilerp
(
part2
part3
)
;
overlapPart
=
part3
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
rightColumnCursor
+
=
4
;
count
-
=
4
;
}
while
(
count
>
0
)
{
Sk4f
rightPart
=
partAtColumn
(
rightColumnCursor
)
;
fNext
-
>
blendPixel
(
bilerp
(
overlapPart
rightPart
)
)
;
overlapPart
=
rightPart
;
rightColumnCursor
+
=
1
;
count
-
=
1
;
}
}
else
{
Sk4f
overlapPart
=
partAtColumn
(
iXs
[
1
]
)
;
int
leftColumnCursor
=
iXs
[
0
]
;
while
(
count
>
=
4
)
{
Sk4f
part0
part1
part2
part3
;
get4Parts
(
leftColumnCursor
-
3
&
part3
&
part2
&
part1
&
part0
)
;
Sk4f
px0
=
bilerp
(
part0
overlapPart
)
;
Sk4f
px1
=
bilerp
(
part1
part0
)
;
Sk4f
px2
=
bilerp
(
part2
part1
)
;
Sk4f
px3
=
bilerp
(
part3
part2
)
;
overlapPart
=
part3
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
leftColumnCursor
-
=
4
;
count
-
=
4
;
}
while
(
count
>
0
)
{
Sk4f
leftPart
=
partAtColumn
(
leftColumnCursor
)
;
fNext
-
>
blendPixel
(
bilerp
(
leftPart
overlapPart
)
)
;
overlapPart
=
leftPart
;
leftColumnCursor
-
=
1
;
count
-
=
1
;
}
}
}
void
spanMediumRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
const
SkScalar
dx
=
length
/
(
count
-
1
)
;
SkASSERT
(
(
-
2
.
0f
<
dx
&
&
dx
<
-
1
.
0f
)
|
|
(
1
.
0f
<
dx
&
&
dx
<
2
.
0f
)
)
;
SkScalar
filterX
=
sample_to_filter
(
X
(
start
)
)
;
SkScalar
filterY
=
sample_to_filter
(
Y
(
start
)
)
;
Sk4i
iXs
iYs
;
this
-
>
filterPoints
(
start
&
iXs
&
iYs
)
;
const
void
*
const
row0
=
fAccessor
.
row
(
iYs
[
0
]
)
;
const
void
*
const
row1
=
fAccessor
.
row
(
iYs
[
2
]
)
;
auto
partAtColumn
=
[
&
]
(
int
xColumn
)
{
int
adjustedColumn
=
adjust_edge
(
fXEdgeType
xColumn
fXMax
)
;
Sk4f
pxTop
pxBottom
;
this
-
>
get2PixelColumn
(
row0
row1
adjustedColumn
&
pxTop
&
pxBottom
)
;
return
pxTop
*
filterY
+
(
1
.
0f
-
filterY
)
*
pxBottom
;
}
;
Sk4f
leftPart
=
partAtColumn
(
iXs
[
0
]
)
;
Sk4f
rightPart
=
partAtColumn
(
iXs
[
1
]
)
;
auto
bilerp
=
[
&
]
(
const
Sk4f
&
leftPart
const
Sk4f
&
rightPart
)
{
Sk4f
pixel
=
leftPart
*
filterX
+
rightPart
*
(
1
.
0f
-
filterX
)
;
return
check_pixel
(
pixel
)
;
}
;
fNext
-
>
blendPixel
(
bilerp
(
leftPart
rightPart
)
)
;
count
-
=
1
;
if
(
dx
>
0
.
0f
)
{
int
rightPartCursor
=
iXs
[
1
]
;
auto
advanceFilter
=
[
&
]
(
)
{
filterX
-
=
dx
;
if
(
filterX
>
-
1
.
0f
)
{
filterX
+
=
1
.
0f
;
leftPart
=
rightPart
;
rightPartCursor
+
=
1
;
rightPart
=
partAtColumn
(
rightPartCursor
)
;
}
else
{
filterX
+
=
2
.
0f
;
rightPartCursor
+
=
2
;
leftPart
=
partAtColumn
(
rightPartCursor
-
1
)
;
rightPart
=
partAtColumn
(
rightPartCursor
)
;
}
SkASSERT
(
0
.
0f
<
filterX
&
&
filterX
<
=
1
.
0f
)
;
return
bilerp
(
leftPart
rightPart
)
;
}
;
while
(
count
>
=
4
)
{
Sk4f
px0
=
advanceFilter
(
)
px1
=
advanceFilter
(
)
px2
=
advanceFilter
(
)
px3
=
advanceFilter
(
)
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
advanceFilter
(
)
)
;
count
-
=
1
;
}
}
else
{
int
leftPartCursor
=
iXs
[
0
]
;
auto
advanceFilter
=
[
&
]
(
)
{
filterX
-
=
dx
;
if
(
filterX
<
2
.
0f
)
{
filterX
-
=
1
.
0f
;
rightPart
=
leftPart
;
leftPartCursor
-
=
1
;
leftPart
=
partAtColumn
(
leftPartCursor
)
;
}
else
{
filterX
-
=
2
.
0f
;
leftPartCursor
-
=
2
;
rightPart
=
partAtColumn
(
leftPartCursor
-
1
)
;
leftPart
=
partAtColumn
(
leftPartCursor
)
;
}
SkASSERT
(
0
.
0f
<
filterX
&
&
filterX
<
=
1
.
0f
)
;
return
bilerp
(
leftPart
rightPart
)
;
}
;
while
(
count
>
=
4
)
{
Sk4f
px0
=
advanceFilter
(
)
px1
=
advanceFilter
(
)
px2
=
advanceFilter
(
)
px3
=
advanceFilter
(
)
;
fNext
-
>
blend4Pixels
(
px0
px1
px2
px3
)
;
count
-
=
4
;
}
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
advanceFilter
(
)
)
;
count
-
=
1
;
}
}
}
void
spanFastRate
(
Span
span
)
{
SkPoint
start
;
SkScalar
length
;
int
count
;
std
:
:
tie
(
start
length
count
)
=
span
;
SkScalar
x
=
X
(
start
)
;
SkScalar
y
=
Y
(
start
)
;
SkScalar
dx
=
length
/
(
count
-
1
)
;
while
(
count
>
0
)
{
fNext
-
>
blendPixel
(
this
-
>
bilerpSamplePoint
(
SkPoint
{
x
y
}
)
)
;
x
+
=
dx
;
count
-
=
1
;
}
}
Next
*
const
fNext
;
const
SkShader
:
:
TileMode
fXEdgeType
;
const
int
fXMax
;
const
SkShader
:
:
TileMode
fYEdgeType
;
const
int
fYMax
;
Accessor
fAccessor
;
}
;
}
#
endif
