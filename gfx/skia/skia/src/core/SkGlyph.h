#
ifndef
SkGlyph_DEFINED
#
define
SkGlyph_DEFINED
#
include
"
SkChecksum
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkFixed
.
h
"
#
include
"
SkMask
.
h
"
class
SkPath
;
class
SkGlyphCache
;
#
define
MASK_FORMAT_UNKNOWN
(
0xFF
)
#
define
MASK_FORMAT_JUST_ADVANCE
MASK_FORMAT_UNKNOWN
#
define
kMaxGlyphWidth
(
1
<
<
13
)
SK_BEGIN_REQUIRE_DENSE
class
SkGlyph
{
enum
{
kSubBits
=
2
kSubMask
=
(
(
1
<
<
kSubBits
)
-
1
)
kSubShift
=
24
kCodeMask
=
(
(
1
<
<
kSubShift
)
-
1
)
kSubShiftX
=
kSubBits
kSubShiftY
=
0
}
;
struct
Intercept
{
Intercept
*
fNext
;
SkScalar
fBounds
[
2
]
;
SkScalar
fInterval
[
2
]
;
}
;
struct
PathData
{
Intercept
*
fIntercept
;
SkPath
*
fPath
;
}
;
public
:
static
const
SkFixed
kSubpixelRound
=
SK_FixedHalf
>
>
SkGlyph
:
:
kSubBits
;
static
const
uint32_t
kImpossibleID
=
~
0
;
void
*
fImage
;
PathData
*
fPathData
;
float
fAdvanceX
fAdvanceY
;
uint16_t
fWidth
fHeight
;
int16_t
fTop
fLeft
;
uint8_t
fMaskFormat
;
int8_t
fRsbDelta
fLsbDelta
;
int8_t
fForceBW
;
void
initWithGlyphID
(
uint32_t
glyph_id
)
{
this
-
>
initCommon
(
MakeID
(
glyph_id
)
)
;
}
void
initGlyphIdFrom
(
const
SkGlyph
&
glyph
)
{
this
-
>
initCommon
(
glyph
.
fID
)
;
}
void
initGlyphFromCombinedID
(
uint32_t
combined_id
)
{
this
-
>
initCommon
(
combined_id
)
;
}
static
unsigned
ComputeRowBytes
(
unsigned
width
SkMask
:
:
Format
format
)
{
unsigned
rb
=
width
;
if
(
SkMask
:
:
kBW_Format
=
=
format
)
{
rb
=
(
rb
+
7
)
>
>
3
;
}
else
if
(
SkMask
:
:
kARGB32_Format
=
=
format
)
{
rb
<
<
=
2
;
}
else
if
(
SkMask
:
:
kLCD16_Format
=
=
format
)
{
rb
=
SkAlign4
(
rb
<
<
1
)
;
}
else
{
rb
=
SkAlign4
(
rb
)
;
}
return
rb
;
}
unsigned
rowBytes
(
)
const
{
return
ComputeRowBytes
(
fWidth
(
SkMask
:
:
Format
)
fMaskFormat
)
;
}
bool
isJustAdvance
(
)
const
{
return
MASK_FORMAT_JUST_ADVANCE
=
=
fMaskFormat
;
}
bool
isFullMetrics
(
)
const
{
return
MASK_FORMAT_JUST_ADVANCE
!
=
fMaskFormat
;
}
uint16_t
getGlyphID
(
)
const
{
return
ID2Code
(
fID
)
;
}
unsigned
getSubX
(
)
const
{
return
ID2SubX
(
fID
)
;
}
SkFixed
getSubXFixed
(
)
const
{
return
SubToFixed
(
ID2SubX
(
fID
)
)
;
}
SkFixed
getSubYFixed
(
)
const
{
return
SubToFixed
(
ID2SubY
(
fID
)
)
;
}
size_t
computeImageSize
(
)
const
;
void
zeroMetrics
(
)
;
void
toMask
(
SkMask
*
mask
)
const
;
class
HashTraits
{
public
:
static
uint32_t
GetKey
(
const
SkGlyph
&
glyph
)
{
return
glyph
.
fID
;
}
static
uint32_t
Hash
(
uint32_t
glyphId
)
{
return
SkChecksum
:
:
CheapMix
(
glyphId
)
;
}
}
;
private
:
friend
class
SkGlyphCache
;
void
initCommon
(
uint32_t
id
)
{
fID
=
id
;
fImage
=
nullptr
;
fPathData
=
nullptr
;
fMaskFormat
=
MASK_FORMAT_UNKNOWN
;
fForceBW
=
0
;
}
static
unsigned
ID2Code
(
uint32_t
id
)
{
return
id
&
kCodeMask
;
}
static
unsigned
ID2SubX
(
uint32_t
id
)
{
return
id
>
>
(
kSubShift
+
kSubShiftX
)
;
}
static
unsigned
ID2SubY
(
uint32_t
id
)
{
return
(
id
>
>
(
kSubShift
+
kSubShiftY
)
)
&
kSubMask
;
}
static
unsigned
FixedToSub
(
SkFixed
n
)
{
return
(
n
>
>
(
16
-
kSubBits
)
)
&
kSubMask
;
}
static
SkFixed
SubToFixed
(
unsigned
sub
)
{
SkASSERT
(
sub
<
=
kSubMask
)
;
return
sub
<
<
(
16
-
kSubBits
)
;
}
static
uint32_t
MakeID
(
unsigned
code
)
{
SkASSERT
(
code
<
=
kCodeMask
)
;
SkASSERT
(
code
!
=
kImpossibleID
)
;
return
code
;
}
static
uint32_t
MakeID
(
unsigned
code
SkFixed
x
SkFixed
y
)
{
SkASSERT
(
code
<
=
kCodeMask
)
;
x
=
FixedToSub
(
x
)
;
y
=
FixedToSub
(
y
)
;
uint32_t
ID
=
(
x
<
<
(
kSubShift
+
kSubShiftX
)
)
|
(
y
<
<
(
kSubShift
+
kSubShiftY
)
)
|
code
;
SkASSERT
(
ID
!
=
kImpossibleID
)
;
return
ID
;
}
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
public
:
#
endif
uint32_t
fID
;
}
;
SK_END_REQUIRE_DENSE
#
endif
