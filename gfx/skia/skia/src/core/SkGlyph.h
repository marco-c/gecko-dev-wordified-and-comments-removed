#
ifndef
SkGlyph_DEFINED
#
define
SkGlyph_DEFINED
#
include
"
SkChecksum
.
h
"
#
include
"
SkFixed
.
h
"
#
include
"
SkMask
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkTo
.
h
"
#
include
"
SkTypes
.
h
"
class
SkArenaAlloc
;
class
SkStrike
;
class
SkScalerContext
;
#
define
MASK_FORMAT_UNKNOWN
(
0xFF
)
#
define
MASK_FORMAT_JUST_ADVANCE
MASK_FORMAT_UNKNOWN
#
define
kMaxGlyphWidth
(
1
<
<
13
)
struct
SkPackedID
{
static
constexpr
uint32_t
kImpossibleID
=
~
0
;
enum
{
kSubBits
=
2
kSubMask
=
(
(
1
<
<
kSubBits
)
-
1
)
kSubShift
=
24
kCodeMask
=
(
(
1
<
<
kSubShift
)
-
1
)
kSubShiftX
=
kSubBits
kSubShiftY
=
0
}
;
SkPackedID
(
uint32_t
code
)
{
SkASSERT
(
code
<
=
kCodeMask
)
;
SkASSERT
(
code
!
=
kImpossibleID
)
;
fID
=
code
;
}
SkPackedID
(
uint32_t
code
SkFixed
x
SkFixed
y
)
{
SkASSERT
(
code
<
=
kCodeMask
)
;
x
=
FixedToSub
(
x
)
;
y
=
FixedToSub
(
y
)
;
uint32_t
ID
=
(
x
<
<
(
kSubShift
+
kSubShiftX
)
)
|
(
y
<
<
(
kSubShift
+
kSubShiftY
)
)
|
code
;
SkASSERT
(
ID
!
=
kImpossibleID
)
;
fID
=
ID
;
}
constexpr
SkPackedID
(
)
:
fID
(
kImpossibleID
)
{
}
bool
operator
=
=
(
const
SkPackedID
&
that
)
const
{
return
fID
=
=
that
.
fID
;
}
bool
operator
!
=
(
const
SkPackedID
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
bool
operator
<
(
SkPackedID
that
)
const
{
return
this
-
>
fID
<
that
.
fID
;
}
uint32_t
code
(
)
const
{
return
fID
&
kCodeMask
;
}
uint32_t
value
(
)
const
{
return
fID
;
}
SkFixed
getSubXFixed
(
)
const
{
return
SubToFixed
(
ID2SubX
(
fID
)
)
;
}
SkFixed
getSubYFixed
(
)
const
{
return
SubToFixed
(
ID2SubY
(
fID
)
)
;
}
uint32_t
hash
(
)
const
{
return
SkChecksum
:
:
CheapMix
(
fID
)
;
}
SkString
dump
(
)
const
{
SkString
str
;
str
.
appendf
(
"
code
:
%
d
x
:
%
d
y
:
%
d
"
code
(
)
getSubXFixed
(
)
getSubYFixed
(
)
)
;
return
str
;
}
private
:
static
unsigned
ID2SubX
(
uint32_t
id
)
{
return
id
>
>
(
kSubShift
+
kSubShiftX
)
;
}
static
unsigned
ID2SubY
(
uint32_t
id
)
{
return
(
id
>
>
(
kSubShift
+
kSubShiftY
)
)
&
kSubMask
;
}
static
unsigned
FixedToSub
(
SkFixed
n
)
{
return
(
n
>
>
(
16
-
kSubBits
)
)
&
kSubMask
;
}
static
SkFixed
SubToFixed
(
unsigned
sub
)
{
SkASSERT
(
sub
<
=
kSubMask
)
;
return
sub
<
<
(
16
-
kSubBits
)
;
}
uint32_t
fID
;
}
;
struct
SkPackedGlyphID
:
public
SkPackedID
{
SkPackedGlyphID
(
SkGlyphID
code
)
:
SkPackedID
(
code
)
{
}
SkPackedGlyphID
(
SkGlyphID
code
SkFixed
x
SkFixed
y
)
:
SkPackedID
(
code
x
y
)
{
}
SkPackedGlyphID
(
SkGlyphID
code
SkIPoint
pt
)
:
SkPackedID
(
code
pt
.
x
(
)
pt
.
y
(
)
)
{
}
constexpr
SkPackedGlyphID
(
)
=
default
;
SkGlyphID
code
(
)
const
{
return
SkTo
<
SkGlyphID
>
(
SkPackedID
:
:
code
(
)
)
;
}
}
;
class
SkGlyph
{
struct
PathData
;
public
:
constexpr
explicit
SkGlyph
(
SkPackedGlyphID
id
)
:
fID
{
id
}
{
}
static
constexpr
SkFixed
kSubpixelRound
=
SK_FixedHalf
>
>
SkPackedID
:
:
kSubBits
;
bool
isEmpty
(
)
const
{
return
fWidth
=
=
0
|
|
fHeight
=
=
0
;
}
bool
isJustAdvance
(
)
const
{
return
MASK_FORMAT_JUST_ADVANCE
=
=
fMaskFormat
;
}
bool
isFullMetrics
(
)
const
{
return
MASK_FORMAT_JUST_ADVANCE
!
=
fMaskFormat
;
}
SkGlyphID
getGlyphID
(
)
const
{
return
fID
.
code
(
)
;
}
SkPackedGlyphID
getPackedID
(
)
const
{
return
fID
;
}
SkFixed
getSubXFixed
(
)
const
{
return
fID
.
getSubXFixed
(
)
;
}
SkFixed
getSubYFixed
(
)
const
{
return
fID
.
getSubYFixed
(
)
;
}
size_t
formatAlignment
(
)
const
;
size_t
allocImage
(
SkArenaAlloc
*
alloc
)
;
size_t
rowBytes
(
)
const
;
size_t
computeImageSize
(
)
const
;
size_t
rowBytesUsingFormat
(
SkMask
:
:
Format
format
)
const
;
void
zeroMetrics
(
)
;
void
toMask
(
SkMask
*
mask
)
const
;
SkPath
*
addPath
(
SkScalerContext
*
SkArenaAlloc
*
)
;
SkPath
*
path
(
)
const
{
return
fPathData
!
=
nullptr
&
&
fPathData
-
>
fHasPath
?
&
fPathData
-
>
fPath
:
nullptr
;
}
size_t
copyImageData
(
const
SkGlyph
&
from
SkArenaAlloc
*
alloc
)
;
void
*
fImage
=
nullptr
;
PathData
*
fPathData
=
nullptr
;
float
fAdvanceX
=
0
fAdvanceY
=
0
;
uint16_t
fWidth
=
0
fHeight
=
0
;
int16_t
fTop
=
0
fLeft
=
0
;
int8_t
fForceBW
=
0
;
uint8_t
fMaskFormat
=
MASK_FORMAT_UNKNOWN
;
private
:
struct
Intercept
{
Intercept
*
fNext
;
SkScalar
fBounds
[
2
]
;
SkScalar
fInterval
[
2
]
;
}
;
struct
PathData
{
Intercept
*
fIntercept
{
nullptr
}
;
SkPath
fPath
;
bool
fHasPath
{
false
}
;
}
;
friend
class
SkStrike
;
SkPackedGlyphID
fID
;
}
;
#
endif
