#
ifndef
SkRemoteGlyphCache_DEFINED
#
define
SkRemoteGlyphCache_DEFINED
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSerialProcs
.
h
"
#
include
"
include
/
core
/
SkTypeface
.
h
"
#
include
"
include
/
private
/
SkTHash
.
h
"
#
include
"
include
/
utils
/
SkNoDrawCanvas
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkMakeUnique
.
h
"
#
include
"
src
/
core
/
SkStrikeForGPU
.
h
"
#
include
"
src
/
core
/
SkTLazy
.
h
"
class
Deserializer
;
class
Serializer
;
enum
SkAxisAlignment
:
uint32_t
;
class
SkDescriptor
;
class
SkStrike
;
struct
SkPackedGlyphID
;
enum
SkScalerContextFlags
:
uint32_t
;
class
SkStrikeCache
;
class
SkTypefaceProxy
;
struct
WireTypeface
;
class
SkStrikeServer
;
class
SkTextBlobCacheDiffCanvas
:
public
SkNoDrawCanvas
{
public
:
SkTextBlobCacheDiffCanvas
(
int
width
int
height
const
SkSurfaceProps
&
props
SkStrikeServer
*
strikeServer
bool
DFTSupport
=
true
)
;
SK_API
SkTextBlobCacheDiffCanvas
(
int
width
int
height
const
SkSurfaceProps
&
props
SkStrikeServer
*
strikeServer
sk_sp
<
SkColorSpace
>
colorSpace
bool
DFTSupport
)
;
SK_API
~
SkTextBlobCacheDiffCanvas
(
)
override
;
protected
:
SkCanvas
:
:
SaveLayerStrategy
getSaveLayerStrategy
(
const
SaveLayerRec
&
rec
)
override
;
bool
onDoSaveBehind
(
const
SkRect
*
)
override
;
void
onDrawTextBlob
(
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
override
;
private
:
class
TrackLayerDevice
;
}
;
using
SkDiscardableHandleId
=
uint32_t
;
class
SkStrikeServer
final
:
public
SkStrikeForGPUCacheInterface
{
public
:
class
DiscardableHandleManager
{
public
:
SK_API
virtual
~
DiscardableHandleManager
(
)
=
default
;
SK_API
virtual
SkDiscardableHandleId
createHandle
(
)
=
0
;
SK_API
virtual
bool
lockHandle
(
SkDiscardableHandleId
)
=
0
;
SK_API
virtual
bool
isHandleDeleted
(
SkDiscardableHandleId
)
{
return
false
;
}
}
;
SK_API
explicit
SkStrikeServer
(
DiscardableHandleManager
*
discardableHandleManager
)
;
SK_API
~
SkStrikeServer
(
)
override
;
SK_API
sk_sp
<
SkData
>
serializeTypeface
(
SkTypeface
*
)
;
SK_API
void
writeStrikeData
(
std
:
:
vector
<
uint8_t
>
*
memory
)
;
class
RemoteStrike
;
RemoteStrike
*
getOrCreateCache
(
const
SkPaint
&
const
SkFont
&
font
const
SkSurfaceProps
&
const
SkMatrix
&
SkScalerContextFlags
flags
SkScalerContextEffects
*
effects
)
;
SkScopedStrikeForGPU
findOrCreateScopedStrike
(
const
SkDescriptor
&
desc
const
SkScalerContextEffects
&
effects
const
SkTypeface
&
typeface
)
override
;
static
void
AddGlyphForTesting
(
RemoteStrike
*
cache
SkPackedGlyphID
glyphID
bool
asPath
)
;
void
setMaxEntriesInDescriptorMapForTesting
(
size_t
count
)
{
fMaxEntriesInDescriptorMap
=
count
;
}
size_t
remoteStrikeMapSizeForTesting
(
)
const
{
return
fDescToRemoteStrike
.
size
(
)
;
}
private
:
static
constexpr
size_t
kMaxEntriesInDescriptorMap
=
2000u
;
void
checkForDeletedEntries
(
)
;
RemoteStrike
*
getOrCreateCache
(
const
SkDescriptor
&
desc
const
SkTypeface
&
typeface
SkScalerContextEffects
effects
)
;
struct
MapOps
{
size_t
operator
(
)
(
const
SkDescriptor
*
key
)
const
;
bool
operator
(
)
(
const
SkDescriptor
*
lhs
const
SkDescriptor
*
rhs
)
const
;
}
;
using
DescToRemoteStrike
=
std
:
:
unordered_map
<
const
SkDescriptor
*
std
:
:
unique_ptr
<
RemoteStrike
>
MapOps
MapOps
>
;
DescToRemoteStrike
fDescToRemoteStrike
;
DiscardableHandleManager
*
const
fDiscardableHandleManager
;
SkTHashSet
<
SkFontID
>
fCachedTypefaces
;
size_t
fMaxEntriesInDescriptorMap
=
kMaxEntriesInDescriptorMap
;
SkTHashMap
<
SkFontID
sk_sp
<
SkData
>
>
fSerializedTypefaces
;
SkTHashSet
<
RemoteStrike
*
>
fRemoteStrikesToSend
;
std
:
:
vector
<
WireTypeface
>
fTypefacesToSend
;
}
;
class
SkStrikeClient
{
public
:
enum
CacheMissType
:
uint32_t
{
kFontMetrics
=
0
kGlyphMetrics
=
1
kGlyphImage
=
2
kGlyphPath
=
3
kGlyphMetricsFallback
=
4
kGlyphPathFallback
=
5
kLast
=
kGlyphPathFallback
}
;
class
DiscardableHandleManager
:
public
SkRefCnt
{
public
:
~
DiscardableHandleManager
(
)
override
=
default
;
virtual
bool
deleteHandle
(
SkDiscardableHandleId
)
=
0
;
virtual
void
notifyCacheMiss
(
CacheMissType
)
{
}
struct
ReadFailureData
{
size_t
memorySize
;
size_t
bytesRead
;
uint64_t
typefaceSize
;
uint64_t
strikeCount
;
uint64_t
glyphImagesCount
;
uint64_t
glyphPathsCount
;
}
;
virtual
void
notifyReadFailure
(
const
ReadFailureData
&
data
)
{
}
}
;
SK_API
explicit
SkStrikeClient
(
sk_sp
<
DiscardableHandleManager
>
bool
isLogging
=
true
SkStrikeCache
*
strikeCache
=
nullptr
)
;
SK_API
~
SkStrikeClient
(
)
;
SK_API
sk_sp
<
SkTypeface
>
deserializeTypeface
(
const
void
*
data
size_t
length
)
;
SK_API
bool
readStrikeData
(
const
volatile
void
*
memory
size_t
memorySize
)
;
private
:
class
DiscardableStrikePinner
;
static
bool
ReadGlyph
(
SkTLazy
<
SkGlyph
>
&
glyph
Deserializer
*
deserializer
)
;
sk_sp
<
SkTypeface
>
addTypeface
(
const
WireTypeface
&
wire
)
;
SkTHashMap
<
SkFontID
sk_sp
<
SkTypeface
>
>
fRemoteFontIdToTypeface
;
sk_sp
<
DiscardableHandleManager
>
fDiscardableHandleManager
;
SkStrikeCache
*
const
fStrikeCache
;
const
bool
fIsLogging
;
}
;
#
endif
