#
include
"
SkCoverageDelta
.
h
"
SkCoverageDeltaList
:
:
SkCoverageDeltaList
(
SkArenaAlloc
*
alloc
const
SkIRect
&
bounds
bool
forceRLE
)
{
fAlloc
=
alloc
;
fBounds
=
bounds
;
fForceRLE
=
forceRLE
;
int
top
=
bounds
.
fTop
;
int
bottom
=
bounds
.
fBottom
;
fAntiRect
.
fY
=
bottom
;
fAntiRect
.
fHeight
=
0
;
fSorted
=
fAlloc
-
>
makeArrayDefault
<
bool
>
(
bottom
-
top
)
;
fCounts
=
fAlloc
-
>
makeArrayDefault
<
int
>
(
(
bottom
-
top
)
*
2
)
;
fMaxCounts
=
fCounts
+
bottom
-
top
;
fRows
=
fAlloc
-
>
makeArrayDefault
<
SkCoverageDelta
*
>
(
bottom
-
top
)
-
top
;
fRows
[
top
]
=
fAlloc
-
>
makeArrayDefault
<
SkCoverageDelta
>
(
INIT_ROW_SIZE
*
(
bottom
-
top
)
)
;
memset
(
fSorted
true
bottom
-
top
)
;
memset
(
fCounts
0
sizeof
(
int
)
*
(
bottom
-
top
)
)
;
fSorted
-
=
top
;
fCounts
-
=
top
;
fMaxCounts
-
=
top
;
for
(
int
y
=
top
;
y
<
bottom
;
+
+
y
)
{
fMaxCounts
[
y
]
=
INIT_ROW_SIZE
;
}
for
(
int
y
=
top
+
1
;
y
<
bottom
;
+
+
y
)
{
fRows
[
y
]
=
fRows
[
y
-
1
]
+
INIT_ROW_SIZE
;
}
}
int
SkCoverageDeltaMask
:
:
ExpandWidth
(
int
width
)
{
int
result
=
width
+
PADDING
*
2
;
return
result
+
(
SIMD_WIDTH
-
result
%
SIMD_WIDTH
)
%
SIMD_WIDTH
;
}
bool
SkCoverageDeltaMask
:
:
CanHandle
(
const
SkIRect
&
bounds
)
{
if
(
bounds
.
width
(
)
>
=
MAX_MASK_SIZE
|
|
bounds
.
height
(
)
>
=
MAX_MASK_SIZE
)
{
return
false
;
}
return
ExpandWidth
(
bounds
.
width
(
)
)
*
bounds
.
height
(
)
+
PADDING
*
2
<
MAX_MASK_SIZE
;
}
bool
SkCoverageDeltaMask
:
:
Suitable
(
const
SkIRect
&
bounds
)
{
return
bounds
.
width
(
)
<
=
SUITABLE_WIDTH
&
&
CanHandle
(
bounds
)
;
}
SkCoverageDeltaMask
:
:
SkCoverageDeltaMask
(
SkArenaAlloc
*
alloc
const
SkIRect
&
bounds
)
{
SkASSERT
(
CanHandle
(
bounds
)
)
;
fBounds
=
bounds
;
fAntiRect
.
fY
=
fBounds
.
fBottom
;
fAntiRect
.
fHeight
=
0
;
fExpandedWidth
=
ExpandWidth
(
fBounds
.
width
(
)
)
;
int
size
=
fExpandedWidth
*
bounds
.
height
(
)
+
PADDING
*
2
;
fDeltaStorage
=
alloc
-
>
makeArray
<
SkFixed
>
(
size
)
;
fMask
=
alloc
-
>
makeArrayDefault
<
SkAlpha
>
(
size
)
;
fDeltas
=
fDeltaStorage
+
PADDING
-
this
-
>
index
(
fBounds
.
fLeft
fBounds
.
fTop
)
;
}
void
SkCoverageDeltaMask
:
:
convertCoverageToAlpha
(
bool
isEvenOdd
bool
isInverse
bool
isConvex
)
{
SkFixed
*
deltaRow
=
&
this
-
>
delta
(
fBounds
.
fLeft
fBounds
.
fTop
)
;
SkAlpha
*
maskRow
=
fMask
;
for
(
int
iy
=
0
;
iy
<
fBounds
.
height
(
)
;
+
+
iy
)
{
if
(
fAntiRect
.
fHeight
&
&
iy
=
=
fAntiRect
.
fY
-
fBounds
.
fTop
)
{
int
L
=
fAntiRect
.
fX
-
fBounds
.
fLeft
;
for
(
int
i
=
0
;
i
<
fAntiRect
.
fHeight
;
+
+
i
)
{
sk_bzero
(
maskRow
fBounds
.
width
(
)
)
;
SkAlpha
*
tMask
=
maskRow
+
L
;
if
(
fAntiRect
.
fLeftAlpha
)
{
tMask
[
0
]
=
fAntiRect
.
fLeftAlpha
;
}
memset
(
tMask
+
1
0xff
fAntiRect
.
fWidth
)
;
if
(
fAntiRect
.
fRightAlpha
)
{
tMask
[
fAntiRect
.
fWidth
+
1
]
=
fAntiRect
.
fRightAlpha
;
}
maskRow
+
=
fBounds
.
width
(
)
;
}
deltaRow
+
=
fExpandedWidth
*
fAntiRect
.
fHeight
;
iy
+
=
fAntiRect
.
fHeight
-
1
;
continue
;
}
SkFixed
c
[
SIMD_WIDTH
]
=
{
0
}
;
for
(
int
ix
=
0
;
ix
<
fExpandedWidth
;
ix
+
=
SIMD_WIDTH
)
{
c
[
0
]
=
c
[
SIMD_WIDTH
-
1
]
+
deltaRow
[
ix
]
;
for
(
int
j
=
1
;
j
<
SIMD_WIDTH
;
+
+
j
)
{
c
[
j
]
=
c
[
j
-
1
]
+
deltaRow
[
ix
+
j
]
;
}
using
SkNi
=
SkNx
<
SIMD_WIDTH
int
>
;
SkNi
cn
=
SkNi
:
:
Load
(
c
)
;
SkNi
an
=
isConvex
?
ConvexCoverageToAlpha
(
cn
isInverse
)
:
CoverageToAlpha
(
cn
isEvenOdd
isInverse
)
;
SkNx_cast
<
SkAlpha
>
(
an
)
.
store
(
maskRow
+
ix
)
;
}
deltaRow
+
=
fExpandedWidth
;
maskRow
+
=
fBounds
.
width
(
)
;
}
}
