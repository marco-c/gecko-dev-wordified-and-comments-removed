#
include
"
include
/
core
/
SkExecutor
.
h
"
#
include
"
src
/
core
/
SkTaskGroup
.
h
"
#
include
<
utility
>
SkTaskGroup
:
:
SkTaskGroup
(
SkExecutor
&
executor
)
:
fPending
(
0
)
fExecutor
(
executor
)
{
}
void
SkTaskGroup
:
:
add
(
std
:
:
function
<
void
(
void
)
>
fn
)
{
fPending
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
fExecutor
.
add
(
[
this
fn
{
std
:
:
move
(
fn
)
}
]
{
fn
(
)
;
fPending
.
fetch_add
(
-
1
std
:
:
memory_order_release
)
;
}
)
;
}
void
SkTaskGroup
:
:
batch
(
int
N
std
:
:
function
<
void
(
int
)
>
fn
)
{
fPending
.
fetch_add
(
+
N
std
:
:
memory_order_relaxed
)
;
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
fExecutor
.
add
(
[
=
]
{
fn
(
i
)
;
fPending
.
fetch_add
(
-
1
std
:
:
memory_order_release
)
;
}
)
;
}
}
bool
SkTaskGroup
:
:
done
(
)
const
{
return
fPending
.
load
(
std
:
:
memory_order_acquire
)
=
=
0
;
}
void
SkTaskGroup
:
:
wait
(
)
{
while
(
!
this
-
>
done
(
)
)
{
fExecutor
.
borrow
(
)
;
}
}
SkTaskGroup
:
:
Enabler
:
:
Enabler
(
int
threads
)
{
if
(
threads
)
{
fThreadPool
=
SkExecutor
:
:
MakeLIFOThreadPool
(
threads
)
;
SkExecutor
:
:
SetDefault
(
fThreadPool
.
get
(
)
)
;
}
}
