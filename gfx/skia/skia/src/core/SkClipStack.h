#
ifndef
SkClipStack_DEFINED
#
define
SkClipStack_DEFINED
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkDeque
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRegion
.
h
"
#
include
"
src
/
core
/
SkClipOpPriv
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
core
/
SkTLazy
.
h
"
#
if
SK_SUPPORT_GPU
class
GrProxyProvider
;
#
include
"
include
/
private
/
GrResourceKey
.
h
"
#
endif
class
SkClipStack
{
public
:
enum
BoundsType
{
kNormal_BoundsType
kInsideOut_BoundsType
}
;
class
Element
{
public
:
enum
class
DeviceSpaceType
{
kEmpty
kRect
kRRect
kPath
kLastType
=
kPath
}
;
static
const
int
kTypeCnt
=
(
int
)
DeviceSpaceType
:
:
kLastType
+
1
;
Element
(
)
{
this
-
>
initCommon
(
0
kReplace_SkClipOp
false
)
;
this
-
>
setEmpty
(
)
;
}
Element
(
const
Element
&
)
;
Element
(
const
SkRect
&
rect
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initRect
(
0
rect
m
op
doAA
)
;
}
Element
(
const
SkRRect
&
rrect
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initRRect
(
0
rrect
m
op
doAA
)
;
}
Element
(
const
SkPath
&
path
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initPath
(
0
path
m
op
doAA
)
;
}
~
Element
(
)
;
bool
operator
=
=
(
const
Element
&
element
)
const
;
bool
operator
!
=
(
const
Element
&
element
)
const
{
return
!
(
*
this
=
=
element
)
;
}
DeviceSpaceType
getDeviceSpaceType
(
)
const
{
return
fDeviceSpaceType
;
}
int
getSaveCount
(
)
const
{
return
fSaveCount
;
}
const
SkPath
&
getDeviceSpacePath
(
)
const
{
SkASSERT
(
DeviceSpaceType
:
:
kPath
=
=
fDeviceSpaceType
)
;
return
*
fDeviceSpacePath
.
get
(
)
;
}
const
SkRRect
&
getDeviceSpaceRRect
(
)
const
{
SkASSERT
(
DeviceSpaceType
:
:
kRRect
=
=
fDeviceSpaceType
)
;
return
fDeviceSpaceRRect
;
}
const
SkRect
&
getDeviceSpaceRect
(
)
const
{
SkASSERT
(
DeviceSpaceType
:
:
kRect
=
=
fDeviceSpaceType
&
&
(
fDeviceSpaceRRect
.
isRect
(
)
|
|
fDeviceSpaceRRect
.
isEmpty
(
)
)
)
;
return
fDeviceSpaceRRect
.
getBounds
(
)
;
}
SkClipOp
getOp
(
)
const
{
return
fOp
;
}
void
asDeviceSpacePath
(
SkPath
*
path
)
const
;
const
SkRRect
&
asDeviceSpaceRRect
(
)
const
{
SkASSERT
(
DeviceSpaceType
:
:
kPath
!
=
fDeviceSpaceType
)
;
return
fDeviceSpaceRRect
;
}
bool
isAA
(
)
const
{
return
fDoAA
;
}
void
invertShapeFillType
(
)
;
void
setOp
(
SkClipOp
op
)
{
fOp
=
op
;
}
uint32_t
getGenID
(
)
const
{
SkASSERT
(
kInvalidGenID
!
=
fGenID
)
;
return
fGenID
;
}
const
SkRect
&
getBounds
(
)
const
;
bool
contains
(
const
SkRect
&
rect
)
const
;
bool
contains
(
const
SkRRect
&
rrect
)
const
;
bool
isInverseFilled
(
)
const
{
return
DeviceSpaceType
:
:
kPath
=
=
fDeviceSpaceType
&
&
fDeviceSpacePath
.
get
(
)
-
>
isInverseFillType
(
)
;
}
#
ifdef
SK_DEBUG
void
dump
(
)
const
;
#
endif
#
if
SK_SUPPORT_GPU
void
addResourceInvalidationMessage
(
GrProxyProvider
*
proxyProvider
const
GrUniqueKey
&
key
)
const
{
SkASSERT
(
proxyProvider
)
;
if
(
!
fProxyProvider
)
{
fProxyProvider
=
proxyProvider
;
}
SkASSERT
(
fProxyProvider
=
=
proxyProvider
)
;
fKeysToInvalidate
.
push_back
(
key
)
;
}
#
endif
private
:
friend
class
SkClipStack
;
SkTLazy
<
SkPath
>
fDeviceSpacePath
;
SkRRect
fDeviceSpaceRRect
;
int
fSaveCount
;
SkClipOp
fOp
;
DeviceSpaceType
fDeviceSpaceType
;
bool
fDoAA
;
SkClipStack
:
:
BoundsType
fFiniteBoundType
;
SkRect
fFiniteBound
;
bool
fIsIntersectionOfRects
;
uint32_t
fGenID
;
#
if
SK_SUPPORT_GPU
mutable
GrProxyProvider
*
fProxyProvider
=
nullptr
;
mutable
SkTArray
<
GrUniqueKey
>
fKeysToInvalidate
;
#
endif
Element
(
int
saveCount
)
{
this
-
>
initCommon
(
saveCount
kReplace_SkClipOp
false
)
;
this
-
>
setEmpty
(
)
;
}
Element
(
int
saveCount
const
SkRRect
&
rrect
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initRRect
(
saveCount
rrect
m
op
doAA
)
;
}
Element
(
int
saveCount
const
SkRect
&
rect
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initRect
(
saveCount
rect
m
op
doAA
)
;
}
Element
(
int
saveCount
const
SkPath
&
path
const
SkMatrix
&
m
SkClipOp
op
bool
doAA
)
{
this
-
>
initPath
(
saveCount
path
m
op
doAA
)
;
}
void
initCommon
(
int
saveCount
SkClipOp
op
bool
doAA
)
;
void
initRect
(
int
saveCount
const
SkRect
&
const
SkMatrix
&
SkClipOp
bool
doAA
)
;
void
initRRect
(
int
saveCount
const
SkRRect
&
const
SkMatrix
&
SkClipOp
bool
doAA
)
;
void
initPath
(
int
saveCount
const
SkPath
&
const
SkMatrix
&
SkClipOp
bool
doAA
)
;
void
initAsPath
(
int
saveCount
const
SkPath
&
const
SkMatrix
&
SkClipOp
bool
doAA
)
;
void
setEmpty
(
)
;
inline
void
checkEmpty
(
)
const
;
inline
bool
canBeIntersectedInPlace
(
int
saveCount
SkClipOp
op
)
const
;
bool
rectRectIntersectAllowed
(
const
SkRect
&
newR
bool
newAA
)
const
;
void
updateBoundAndGenID
(
const
Element
*
prior
)
;
enum
FillCombo
{
kPrev_Cur_FillCombo
kPrev_InvCur_FillCombo
kInvPrev_Cur_FillCombo
kInvPrev_InvCur_FillCombo
}
;
inline
void
combineBoundsDiff
(
FillCombo
combination
const
SkRect
&
prevFinite
)
;
inline
void
combineBoundsXOR
(
int
combination
const
SkRect
&
prevFinite
)
;
inline
void
combineBoundsUnion
(
int
combination
const
SkRect
&
prevFinite
)
;
inline
void
combineBoundsIntersection
(
int
combination
const
SkRect
&
prevFinite
)
;
inline
void
combineBoundsRevDiff
(
int
combination
const
SkRect
&
prevFinite
)
;
}
;
SkClipStack
(
)
;
SkClipStack
(
void
*
storage
size_t
size
)
;
SkClipStack
(
const
SkClipStack
&
b
)
;
~
SkClipStack
(
)
;
SkClipStack
&
operator
=
(
const
SkClipStack
&
b
)
;
bool
operator
=
=
(
const
SkClipStack
&
b
)
const
;
bool
operator
!
=
(
const
SkClipStack
&
b
)
const
{
return
!
(
*
this
=
=
b
)
;
}
void
reset
(
)
;
int
getSaveCount
(
)
const
{
return
fSaveCount
;
}
void
save
(
)
;
void
restore
(
)
;
class
AutoRestore
{
public
:
AutoRestore
(
SkClipStack
*
cs
bool
doSave
)
:
fCS
(
cs
)
fSaveCount
(
cs
-
>
getSaveCount
(
)
)
{
if
(
doSave
)
{
fCS
-
>
save
(
)
;
}
}
~
AutoRestore
(
)
{
SkASSERT
(
fCS
-
>
getSaveCount
(
)
>
=
fSaveCount
)
;
while
(
fCS
-
>
getSaveCount
(
)
>
fSaveCount
)
{
fCS
-
>
restore
(
)
;
}
}
private
:
SkClipStack
*
fCS
;
const
int
fSaveCount
;
}
;
void
getBounds
(
SkRect
*
canvFiniteBound
BoundsType
*
boundType
bool
*
isIntersectionOfRects
=
nullptr
)
const
;
SkRect
bounds
(
const
SkIRect
&
deviceBounds
)
const
;
bool
isEmpty
(
const
SkIRect
&
deviceBounds
)
const
;
bool
quickContains
(
const
SkRect
&
devRect
)
const
{
return
this
-
>
isWideOpen
(
)
|
|
this
-
>
internalQuickContains
(
devRect
)
;
}
bool
quickContains
(
const
SkRRect
&
devRRect
)
const
{
return
this
-
>
isWideOpen
(
)
|
|
this
-
>
internalQuickContains
(
devRRect
)
;
}
bool
asPath
(
SkPath
*
path
)
const
;
void
clipDevRect
(
const
SkIRect
&
ir
SkClipOp
op
)
{
SkRect
r
;
r
.
set
(
ir
)
;
this
-
>
clipRect
(
r
SkMatrix
:
:
I
(
)
op
false
)
;
}
void
clipRect
(
const
SkRect
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
void
clipRRect
(
const
SkRRect
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
void
clipPath
(
const
SkPath
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
void
clipEmpty
(
)
;
void
setDeviceClipRestriction
(
const
SkIRect
&
rect
)
{
fClipRestrictionRect
=
SkRect
:
:
Make
(
rect
)
;
}
bool
isWideOpen
(
)
const
{
return
this
-
>
getTopmostGenID
(
)
=
=
kWideOpenGenID
;
}
bool
isRRect
(
const
SkRect
&
bounds
SkRRect
*
rrect
bool
*
aa
)
const
;
static
const
uint32_t
kInvalidGenID
=
0
;
static
const
uint32_t
kEmptyGenID
=
1
;
static
const
uint32_t
kWideOpenGenID
=
2
;
uint32_t
getTopmostGenID
(
)
const
;
#
ifdef
SK_DEBUG
void
dump
(
)
const
;
#
endif
public
:
class
Iter
{
public
:
enum
IterStart
{
kBottom_IterStart
=
SkDeque
:
:
Iter
:
:
kFront_IterStart
kTop_IterStart
=
SkDeque
:
:
Iter
:
:
kBack_IterStart
}
;
Iter
(
)
;
Iter
(
const
SkClipStack
&
stack
IterStart
startLoc
)
;
const
Element
*
next
(
)
;
const
Element
*
prev
(
)
;
const
Element
*
skipToTopmost
(
SkClipOp
op
)
;
void
reset
(
const
SkClipStack
&
stack
IterStart
startLoc
)
;
private
:
const
SkClipStack
*
fStack
;
SkDeque
:
:
Iter
fIter
;
}
;
class
B2TIter
:
private
Iter
{
public
:
B2TIter
(
)
{
}
B2TIter
(
const
SkClipStack
&
stack
)
:
INHERITED
(
stack
kBottom_IterStart
)
{
}
using
Iter
:
:
next
;
void
reset
(
const
SkClipStack
&
stack
)
{
this
-
>
INHERITED
:
:
reset
(
stack
kBottom_IterStart
)
;
}
private
:
typedef
Iter
INHERITED
;
}
;
void
getConservativeBounds
(
int
offsetX
int
offsetY
int
maxWidth
int
maxHeight
SkRect
*
devBounds
bool
*
isIntersectionOfRects
=
nullptr
)
const
;
private
:
friend
class
Iter
;
SkDeque
fDeque
;
int
fSaveCount
;
SkRect
fClipRestrictionRect
=
SkRect
:
:
MakeEmpty
(
)
;
bool
internalQuickContains
(
const
SkRect
&
devRect
)
const
;
bool
internalQuickContains
(
const
SkRRect
&
devRRect
)
const
;
void
pushElement
(
const
Element
&
element
)
;
void
restoreTo
(
int
saveCount
)
;
inline
bool
hasClipRestriction
(
SkClipOp
op
)
{
return
op
>
=
kUnion_SkClipOp
&
&
!
fClipRestrictionRect
.
isEmpty
(
)
;
}
static
uint32_t
GetNextGenID
(
)
;
}
;
#
endif
