#
ifndef
SkRasterPipeline_DEFINED
#
define
SkRasterPipeline_DEFINED
#
include
"
SkNx
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTypes
.
h
"
class
SkRasterPipeline
{
public
:
struct
Stage
;
using
Fn
=
void
(
SK_VECTORCALL
*
)
(
Stage
*
size_t
size_t
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
)
;
struct
Stage
{
template
<
typename
T
>
T
ctx
(
)
{
return
static_cast
<
T
>
(
fCtx
)
;
}
void
SK_VECTORCALL
next
(
size_t
x
size_t
tail
Sk4f
v0
Sk4f
v1
Sk4f
v2
Sk4f
v3
Sk4f
v4
Sk4f
v5
Sk4f
v6
Sk4f
v7
)
{
fNext
(
this
+
1
x
tail
v0
v1
v2
v3
v4
v5
v6
v7
)
;
}
Fn
fNext
;
void
*
fCtx
;
}
;
SkRasterPipeline
(
)
;
void
run
(
size_t
x
size_t
n
)
;
void
run
(
size_t
n
)
{
this
-
>
run
(
0
n
)
;
}
enum
StockStage
{
store_565
store_srgb
store_f16
load_s_565
load_s_srgb
load_s_f16
load_d_565
load_d_srgb
load_d_f16
scale_u8
lerp_u8
lerp_565
lerp_constant_float
constant_color
dst
dstatop
dstin
dstout
dstover
srcatop
srcin
srcout
srcover
clear
modulate
multiply
plus_
screen
xor_
colorburn
colordodge
darken
difference
exclusion
hardlight
lighten
overlay
softlight
kNumStockStages
}
;
void
append
(
StockStage
void
*
=
nullptr
)
;
void
append
(
StockStage
stage
const
void
*
ctx
)
{
this
-
>
append
(
stage
const_cast
<
void
*
>
(
ctx
)
)
;
}
void
extend
(
const
SkRasterPipeline
&
)
;
private
:
using
Stages
=
SkSTArray
<
10
Stage
true
>
;
void
append
(
Fn
body
Fn
tail
void
*
)
;
static
void
SK_VECTORCALL
JustReturn
(
Stage
*
size_t
size_t
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
Sk4f
)
;
Stages
fBody
fTail
;
Fn
fBodyStart
=
&
JustReturn
fTailStart
=
&
JustReturn
;
}
;
#
endif
