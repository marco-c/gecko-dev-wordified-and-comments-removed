#
ifndef
SkRasterPipeline_DEFINED
#
define
SkRasterPipeline_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkRasterPipelineOpContexts
.
h
"
#
include
"
src
/
core
/
SkRasterPipelineOpList
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
class
SkMatrix
;
enum
SkColorType
:
int
;
struct
SkImageInfo
;
struct
skcms_TransferFunction
;
#
if
__has_cpp_attribute
(
clang
:
:
musttail
)
&
&
!
defined
(
__EMSCRIPTEN__
)
&
&
!
defined
(
SK_CPU_ARM32
)
#
define
SK_HAS_MUSTTAIL
1
#
else
#
define
SK_HAS_MUSTTAIL
0
#
endif
SK_BEGIN_REQUIRE_DENSE
struct
SkRasterPipelineStage
{
void
(
*
fn
)
(
)
;
void
*
ctx
;
}
;
SK_END_REQUIRE_DENSE
class
SkRasterPipeline
{
public
:
explicit
SkRasterPipeline
(
SkArenaAlloc
*
)
;
SkRasterPipeline
(
const
SkRasterPipeline
&
)
=
delete
;
SkRasterPipeline
(
SkRasterPipeline
&
&
)
=
default
;
SkRasterPipeline
&
operator
=
(
const
SkRasterPipeline
&
)
=
delete
;
SkRasterPipeline
&
operator
=
(
SkRasterPipeline
&
&
)
=
default
;
void
reset
(
)
;
void
append
(
SkRasterPipelineOp
void
*
=
nullptr
)
;
void
append
(
SkRasterPipelineOp
op
const
void
*
ctx
)
{
this
-
>
append
(
op
const_cast
<
void
*
>
(
ctx
)
)
;
}
void
append
(
SkRasterPipelineOp
uintptr_t
ctx
)
;
void
extend
(
const
SkRasterPipeline
&
)
;
void
run
(
size_t
x
size_t
y
size_t
w
size_t
h
)
const
;
std
:
:
function
<
void
(
size_t
size_t
size_t
size_t
)
>
compile
(
)
const
;
struct
StageList
{
StageList
*
prev
;
SkRasterPipelineOp
stage
;
void
*
ctx
;
}
;
static
const
char
*
GetOpName
(
SkRasterPipelineOp
op
)
;
const
StageList
*
getStageList
(
)
const
{
return
fStages
;
}
int
getNumStages
(
)
const
{
return
fNumStages
;
}
void
dump
(
)
const
;
void
append_matrix
(
SkArenaAlloc
*
const
SkMatrix
&
)
;
void
append_constant_color
(
SkArenaAlloc
*
const
float
rgba
[
4
]
)
;
void
append_constant_color
(
SkArenaAlloc
*
alloc
const
SkColor4f
&
color
)
{
this
-
>
append_constant_color
(
alloc
color
.
vec
(
)
)
;
}
void
append_set_rgb
(
SkArenaAlloc
*
const
float
rgb
[
3
]
)
;
void
append_set_rgb
(
SkArenaAlloc
*
alloc
const
SkColor4f
&
color
)
{
this
-
>
append_set_rgb
(
alloc
color
.
vec
(
)
)
;
}
void
append_load
(
SkColorType
const
SkRasterPipeline_MemoryCtx
*
)
;
void
append_load_dst
(
SkColorType
const
SkRasterPipeline_MemoryCtx
*
)
;
void
append_store
(
SkColorType
const
SkRasterPipeline_MemoryCtx
*
)
;
void
append_clamp_if_normalized
(
const
SkImageInfo
&
)
;
void
append_transfer_function
(
const
skcms_TransferFunction
&
)
;
void
append_stack_rewind
(
)
;
bool
empty
(
)
const
{
return
fStages
=
=
nullptr
;
}
private
:
bool
build_lowp_pipeline
(
SkRasterPipelineStage
*
ip
)
const
;
void
build_highp_pipeline
(
SkRasterPipelineStage
*
ip
)
const
;
using
StartPipelineFn
=
void
(
*
)
(
size_t
size_t
size_t
size_t
SkRasterPipelineStage
*
program
)
;
StartPipelineFn
build_pipeline
(
SkRasterPipelineStage
*
)
const
;
void
unchecked_append
(
SkRasterPipelineOp
void
*
)
;
int
stages_needed
(
)
const
;
SkArenaAlloc
*
fAlloc
;
SkRasterPipeline_RewindCtx
*
fRewindCtx
;
StageList
*
fStages
;
int
fNumStages
;
}
;
template
<
size_t
bytes
>
class
SkRasterPipeline_
:
public
SkRasterPipeline
{
public
:
SkRasterPipeline_
(
)
:
SkRasterPipeline
(
&
fBuiltinAlloc
)
{
}
private
:
SkSTArenaAlloc
<
bytes
>
fBuiltinAlloc
;
}
;
#
endif
