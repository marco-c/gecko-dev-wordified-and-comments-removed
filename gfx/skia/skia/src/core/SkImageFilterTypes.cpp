#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBlendMode
.
h
"
#
include
"
include
/
core
/
SkBlender
.
h
"
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkClipOp
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPicture
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkBitmapDevice
.
h
"
#
include
"
src
/
core
/
SkBlenderBase
.
h
"
#
include
"
src
/
core
/
SkBlurEngine
.
h
"
#
include
"
src
/
core
/
SkCanvasPriv
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkImageFilterCache
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkKnownRuntimeEffects
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
effects
/
colorfilters
/
SkColorFilterBase
.
h
"
#
include
<
algorithm
>
namespace
skif
{
namespace
{
static
constexpr
float
kRoundEpsilon
=
1e
-
3f
;
std
:
:
pair
<
bool
bool
>
are_axes_nearly_integer_aligned
(
const
LayerSpace
<
SkMatrix
>
&
m
LayerSpace
<
SkIPoint
>
*
out
=
nullptr
)
{
float
invW
=
sk_ieee_float_divide
(
1
.
f
m
.
rc
(
2
2
)
)
;
float
tx
=
SkScalarRoundToScalar
(
m
.
rc
(
0
2
)
*
invW
)
;
float
ty
=
SkScalarRoundToScalar
(
m
.
rc
(
1
2
)
*
invW
)
;
bool
affine
=
SkScalarNearlyEqual
(
m
.
rc
(
2
0
)
*
invW
0
.
f
kRoundEpsilon
)
&
&
SkScalarNearlyEqual
(
m
.
rc
(
2
1
)
*
invW
0
.
f
kRoundEpsilon
)
;
if
(
!
affine
)
{
return
{
false
false
}
;
}
bool
xAxis
=
SkScalarNearlyEqual
(
1
.
f
m
.
rc
(
0
0
)
*
invW
kRoundEpsilon
)
&
&
SkScalarNearlyEqual
(
0
.
f
m
.
rc
(
0
1
)
*
invW
kRoundEpsilon
)
&
&
SkScalarNearlyEqual
(
tx
m
.
rc
(
0
2
)
*
invW
kRoundEpsilon
)
;
bool
yAxis
=
SkScalarNearlyEqual
(
0
.
f
m
.
rc
(
1
0
)
*
invW
kRoundEpsilon
)
&
&
SkScalarNearlyEqual
(
1
.
f
m
.
rc
(
1
1
)
*
invW
kRoundEpsilon
)
&
&
SkScalarNearlyEqual
(
ty
m
.
rc
(
1
2
)
*
invW
kRoundEpsilon
)
;
if
(
out
&
&
xAxis
&
&
yAxis
)
{
*
out
=
LayerSpace
<
SkIPoint
>
(
{
(
int
)
tx
(
int
)
ty
}
)
;
}
return
{
xAxis
yAxis
}
;
}
bool
is_nearly_integer_translation
(
const
LayerSpace
<
SkMatrix
>
&
m
LayerSpace
<
SkIPoint
>
*
out
=
nullptr
)
{
auto
[
axisX
axisY
]
=
are_axes_nearly_integer_aligned
(
m
out
)
;
return
axisX
&
&
axisY
;
}
void
decompose_transform
(
const
SkMatrix
&
transform
SkPoint
representativePoint
SkMatrix
*
postScaling
SkMatrix
*
scaling
)
{
SkSize
scale
;
if
(
transform
.
decomposeScale
(
&
scale
postScaling
)
)
{
*
scaling
=
SkMatrix
:
:
Scale
(
scale
.
fWidth
scale
.
fHeight
)
;
}
else
{
SkScalar
approxScale
=
SkMatrixPriv
:
:
DifferentialAreaScale
(
transform
representativePoint
)
;
if
(
SkScalarIsFinite
(
approxScale
)
&
&
!
SkScalarNearlyZero
(
approxScale
)
)
{
approxScale
=
SkScalarSqrt
(
approxScale
)
;
}
else
{
approxScale
=
1
.
f
;
}
*
postScaling
=
transform
;
postScaling
-
>
preScale
(
SkScalarInvert
(
approxScale
)
SkScalarInvert
(
approxScale
)
)
;
*
scaling
=
SkMatrix
:
:
Scale
(
approxScale
approxScale
)
;
}
}
std
:
:
optional
<
LayerSpace
<
SkMatrix
>
>
periodic_axis_transform
(
SkTileMode
tileMode
const
LayerSpace
<
SkIRect
>
&
crop
const
LayerSpace
<
SkIRect
>
&
output
)
{
if
(
tileMode
=
=
SkTileMode
:
:
kClamp
|
|
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
return
{
}
;
}
double
cropL
=
(
double
)
crop
.
left
(
)
;
double
cropT
=
(
double
)
crop
.
top
(
)
;
double
cropWidth
=
crop
.
right
(
)
-
cropL
;
double
cropHeight
=
crop
.
bottom
(
)
-
cropT
;
int
periodL
=
sk_double_floor2int
(
(
output
.
left
(
)
-
cropL
)
/
cropWidth
)
;
int
periodT
=
sk_double_floor2int
(
(
output
.
top
(
)
-
cropT
)
/
cropHeight
)
;
int
periodR
=
sk_double_ceil2int
(
(
output
.
right
(
)
-
cropL
)
/
cropWidth
)
;
int
periodB
=
sk_double_ceil2int
(
(
output
.
bottom
(
)
-
cropT
)
/
cropHeight
)
;
if
(
periodR
-
periodL
<
=
1
&
&
periodB
-
periodT
<
=
1
)
{
float
sx
=
1
.
f
;
float
sy
=
1
.
f
;
double
tx
=
-
cropL
;
double
ty
=
-
cropT
;
if
(
tileMode
=
=
SkTileMode
:
:
kMirror
)
{
if
(
periodL
%
2
!
=
0
)
{
sx
=
-
1
.
f
;
tx
=
cropWidth
-
tx
;
}
if
(
periodT
%
2
!
=
0
)
{
sy
=
-
1
.
f
;
ty
=
cropHeight
-
ty
;
}
}
tx
+
=
periodL
*
cropWidth
+
cropL
;
ty
+
=
periodT
*
cropHeight
+
cropT
;
if
(
sk_double_saturate2int
(
tx
)
!
=
(
float
)
tx
|
|
sk_double_saturate2int
(
ty
)
!
=
(
float
)
ty
)
{
return
{
}
;
}
SkMatrix
periodicTransform
;
periodicTransform
.
setScaleTranslate
(
sx
sy
(
float
)
tx
(
float
)
ty
)
;
return
LayerSpace
<
SkMatrix
>
(
periodicTransform
)
;
}
else
{
return
{
}
;
}
}
class
RasterBackend
:
public
Backend
{
public
:
RasterBackend
(
const
SkSurfaceProps
&
surfaceProps
SkColorType
colorType
)
:
Backend
(
SkImageFilterCache
:
:
Get
(
)
surfaceProps
colorType
)
{
}
sk_sp
<
SkDevice
>
makeDevice
(
SkISize
size
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
props
)
const
override
{
SkImageInfo
imageInfo
=
SkImageInfo
:
:
Make
(
size
this
-
>
colorType
(
)
kPremul_SkAlphaType
std
:
:
move
(
colorSpace
)
)
;
return
SkBitmapDevice
:
:
Create
(
imageInfo
props
?
*
props
:
this
-
>
surfaceProps
(
)
)
;
}
sk_sp
<
SkSpecialImage
>
makeImage
(
const
SkIRect
&
subset
sk_sp
<
SkImage
>
image
)
const
override
{
return
SkSpecialImages
:
:
MakeFromRaster
(
subset
image
this
-
>
surfaceProps
(
)
)
;
}
sk_sp
<
SkImage
>
getCachedBitmap
(
const
SkBitmap
&
data
)
const
override
{
return
SkImages
:
:
RasterFromBitmap
(
data
)
;
}
const
SkBlurEngine
*
getBlurEngine
(
)
const
override
{
return
nullptr
;
}
}
;
}
Backend
:
:
Backend
(
sk_sp
<
SkImageFilterCache
>
cache
const
SkSurfaceProps
&
surfaceProps
const
SkColorType
colorType
)
:
fCache
(
std
:
:
move
(
cache
)
)
fSurfaceProps
(
surfaceProps
)
fColorType
(
colorType
)
{
}
Backend
:
:
~
Backend
(
)
=
default
;
sk_sp
<
Backend
>
MakeRasterBackend
(
const
SkSurfaceProps
&
surfaceProps
SkColorType
colorType
)
{
colorType
=
kN32_SkColorType
;
return
sk_make_sp
<
RasterBackend
>
(
surfaceProps
colorType
)
;
}
void
Stats
:
:
dumpStats
(
)
const
{
SkDebugf
(
"
ImageFilter
Stats
:
\
n
"
"
#
visited
filters
:
%
d
\
n
"
"
#
cache
hits
:
%
d
\
n
"
"
#
offscreen
surfaces
:
%
d
\
n
"
"
#
shader
-
clamped
draws
:
%
d
\
n
"
"
#
shader
-
tiled
draws
:
%
d
\
n
"
fNumVisitedImageFilters
fNumCacheHits
fNumOffscreenSurfaces
fNumShaderClampedDraws
fNumShaderBasedTilingDraws
)
;
}
void
Stats
:
:
reportStats
(
)
const
{
TRACE_EVENT_INSTANT2
(
"
skia
"
"
ImageFilter
Graph
Size
"
TRACE_EVENT_SCOPE_THREAD
"
count
"
fNumVisitedImageFilters
"
cache
hits
"
fNumCacheHits
)
;
TRACE_EVENT_INSTANT1
(
"
skia
"
"
ImageFilter
Surfaces
"
TRACE_EVENT_SCOPE_THREAD
"
count
"
fNumOffscreenSurfaces
)
;
TRACE_EVENT_INSTANT2
(
"
skia
"
"
ImageFilter
Shader
Tiling
"
TRACE_EVENT_SCOPE_THREAD
"
clamp
"
fNumShaderClampedDraws
"
other
"
fNumShaderBasedTilingDraws
)
;
}
SkIRect
RoundOut
(
SkRect
r
)
{
return
r
.
makeInset
(
kRoundEpsilon
kRoundEpsilon
)
.
roundOut
(
)
;
}
SkIRect
RoundIn
(
SkRect
r
)
{
return
r
.
makeOutset
(
kRoundEpsilon
kRoundEpsilon
)
.
roundIn
(
)
;
}
bool
Mapping
:
:
decomposeCTM
(
const
SkMatrix
&
ctm
MatrixCapability
capability
const
skif
:
:
ParameterSpace
<
SkPoint
>
&
representativePt
)
{
SkMatrix
remainder
layer
;
if
(
capability
=
=
MatrixCapability
:
:
kTranslate
)
{
remainder
=
ctm
;
layer
=
SkMatrix
:
:
I
(
)
;
}
else
if
(
ctm
.
isScaleTranslate
(
)
|
|
capability
=
=
MatrixCapability
:
:
kComplex
)
{
remainder
=
SkMatrix
:
:
I
(
)
;
layer
=
ctm
;
}
else
{
decompose_transform
(
ctm
SkPoint
(
representativePt
)
&
remainder
&
layer
)
;
}
SkMatrix
invRemainder
;
if
(
!
remainder
.
invert
(
&
invRemainder
)
)
{
return
false
;
}
else
{
fParamToLayerMatrix
=
layer
;
fLayerToDevMatrix
=
remainder
;
fDevToLayerMatrix
=
invRemainder
;
return
true
;
}
}
bool
Mapping
:
:
decomposeCTM
(
const
SkMatrix
&
ctm
const
SkImageFilter
*
filter
const
skif
:
:
ParameterSpace
<
SkPoint
>
&
representativePt
)
{
return
this
-
>
decomposeCTM
(
ctm
filter
?
as_IFB
(
filter
)
-
>
getCTMCapability
(
)
:
MatrixCapability
:
:
kComplex
representativePt
)
;
}
bool
Mapping
:
:
adjustLayerSpace
(
const
SkMatrix
&
layer
)
{
SkMatrix
invLayer
;
if
(
!
layer
.
invert
(
&
invLayer
)
)
{
return
false
;
}
fParamToLayerMatrix
.
postConcat
(
layer
)
;
fDevToLayerMatrix
.
postConcat
(
layer
)
;
fLayerToDevMatrix
.
preConcat
(
invLayer
)
;
return
true
;
}
template
<
>
SkRect
Mapping
:
:
map
<
SkRect
>
(
const
SkRect
&
geom
const
SkMatrix
&
matrix
)
{
return
geom
.
isEmpty
(
)
?
SkRect
:
:
MakeEmpty
(
)
:
matrix
.
mapRect
(
geom
)
;
}
template
<
>
SkIRect
Mapping
:
:
map
<
SkIRect
>
(
const
SkIRect
&
geom
const
SkMatrix
&
matrix
)
{
if
(
geom
.
isEmpty
(
)
)
{
return
SkIRect
:
:
MakeEmpty
(
)
;
}
if
(
matrix
.
isScaleTranslate
(
)
)
{
double
l
=
(
double
)
matrix
.
getScaleX
(
)
*
geom
.
fLeft
+
(
double
)
matrix
.
getTranslateX
(
)
;
double
r
=
(
double
)
matrix
.
getScaleX
(
)
*
geom
.
fRight
+
(
double
)
matrix
.
getTranslateX
(
)
;
double
t
=
(
double
)
matrix
.
getScaleY
(
)
*
geom
.
fTop
+
(
double
)
matrix
.
getTranslateY
(
)
;
double
b
=
(
double
)
matrix
.
getScaleY
(
)
*
geom
.
fBottom
+
(
double
)
matrix
.
getTranslateY
(
)
;
return
{
sk_double_saturate2int
(
sk_double_floor
(
std
:
:
min
(
l
r
)
+
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_floor
(
std
:
:
min
(
t
b
)
+
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_ceil
(
std
:
:
max
(
l
r
)
-
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_ceil
(
std
:
:
max
(
t
b
)
-
kRoundEpsilon
)
)
}
;
}
else
{
return
RoundOut
(
matrix
.
mapRect
(
SkRect
:
:
Make
(
geom
)
)
)
;
}
}
template
<
>
SkIPoint
Mapping
:
:
map
<
SkIPoint
>
(
const
SkIPoint
&
geom
const
SkMatrix
&
matrix
)
{
SkPoint
p
=
SkPoint
:
:
Make
(
SkIntToScalar
(
geom
.
fX
)
SkIntToScalar
(
geom
.
fY
)
)
;
matrix
.
mapPoints
(
&
p
1
)
;
return
SkIPoint
:
:
Make
(
SkScalarRoundToInt
(
p
.
fX
)
SkScalarRoundToInt
(
p
.
fY
)
)
;
}
template
<
>
SkPoint
Mapping
:
:
map
<
SkPoint
>
(
const
SkPoint
&
geom
const
SkMatrix
&
matrix
)
{
SkPoint
p
;
matrix
.
mapPoints
(
&
p
&
geom
1
)
;
return
p
;
}
template
<
>
Vector
Mapping
:
:
map
<
Vector
>
(
const
Vector
&
geom
const
SkMatrix
&
matrix
)
{
SkVector
v
=
SkVector
:
:
Make
(
geom
.
fX
geom
.
fY
)
;
matrix
.
mapVectors
(
&
v
1
)
;
return
Vector
{
v
}
;
}
template
<
>
IVector
Mapping
:
:
map
<
IVector
>
(
const
IVector
&
geom
const
SkMatrix
&
matrix
)
{
SkVector
v
=
SkVector
:
:
Make
(
SkIntToScalar
(
geom
.
fX
)
SkIntToScalar
(
geom
.
fY
)
)
;
matrix
.
mapVectors
(
&
v
1
)
;
return
IVector
(
SkScalarRoundToInt
(
v
.
fX
)
SkScalarRoundToInt
(
v
.
fY
)
)
;
}
template
<
>
SkSize
Mapping
:
:
map
<
SkSize
>
(
const
SkSize
&
geom
const
SkMatrix
&
matrix
)
{
if
(
matrix
.
isScaleTranslate
(
)
)
{
SkVector
sizes
=
matrix
.
mapVector
(
geom
.
fWidth
geom
.
fHeight
)
;
return
{
SkScalarAbs
(
sizes
.
fX
)
SkScalarAbs
(
sizes
.
fY
)
}
;
}
SkVector
xAxis
=
matrix
.
mapVector
(
geom
.
fWidth
0
.
f
)
;
SkVector
yAxis
=
matrix
.
mapVector
(
0
.
f
geom
.
fHeight
)
;
return
{
xAxis
.
length
(
)
yAxis
.
length
(
)
}
;
}
template
<
>
SkISize
Mapping
:
:
map
<
SkISize
>
(
const
SkISize
&
geom
const
SkMatrix
&
matrix
)
{
SkSize
size
=
map
(
SkSize
:
:
Make
(
geom
)
matrix
)
;
return
SkISize
:
:
Make
(
SkScalarCeilToInt
(
size
.
fWidth
-
kRoundEpsilon
)
SkScalarCeilToInt
(
size
.
fHeight
-
kRoundEpsilon
)
)
;
}
template
<
>
SkMatrix
Mapping
:
:
map
<
SkMatrix
>
(
const
SkMatrix
&
m
const
SkMatrix
&
matrix
)
{
SkMatrix
inv
;
SkAssertResult
(
matrix
.
invert
(
&
inv
)
)
;
inv
.
postConcat
(
m
)
;
inv
.
postConcat
(
matrix
)
;
return
inv
;
}
LayerSpace
<
SkIRect
>
LayerSpace
<
SkIRect
>
:
:
relevantSubset
(
const
LayerSpace
<
SkIRect
>
dstRect
SkTileMode
tileMode
)
const
{
LayerSpace
<
SkIRect
>
fittedSrc
=
*
this
;
if
(
tileMode
=
=
SkTileMode
:
:
kDecal
|
|
tileMode
=
=
SkTileMode
:
:
kClamp
)
{
if
(
!
fittedSrc
.
intersect
(
dstRect
)
)
{
if
(
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
fittedSrc
=
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
else
{
auto
edge
=
SkRectPriv
:
:
ClosestDisjointEdge
(
SkIRect
(
fittedSrc
)
SkIRect
(
dstRect
)
)
;
fittedSrc
=
LayerSpace
<
SkIRect
>
(
edge
)
;
}
}
}
return
fittedSrc
;
}
LayerSpace
<
SkISize
>
LayerSpace
<
SkSize
>
:
:
round
(
)
const
{
return
LayerSpace
<
SkISize
>
(
fData
.
toRound
(
)
)
;
}
LayerSpace
<
SkISize
>
LayerSpace
<
SkSize
>
:
:
ceil
(
)
const
{
return
LayerSpace
<
SkISize
>
(
{
SkScalarCeilToInt
(
fData
.
fWidth
-
kRoundEpsilon
)
SkScalarCeilToInt
(
fData
.
fHeight
-
kRoundEpsilon
)
}
)
;
}
LayerSpace
<
SkISize
>
LayerSpace
<
SkSize
>
:
:
floor
(
)
const
{
return
LayerSpace
<
SkISize
>
(
{
SkScalarFloorToInt
(
fData
.
fWidth
+
kRoundEpsilon
)
SkScalarFloorToInt
(
fData
.
fHeight
+
kRoundEpsilon
)
}
)
;
}
LayerSpace
<
SkRect
>
LayerSpace
<
SkMatrix
>
:
:
mapRect
(
const
LayerSpace
<
SkRect
>
&
r
)
const
{
return
LayerSpace
<
SkRect
>
(
Mapping
:
:
map
(
SkRect
(
r
)
fData
)
)
;
}
LayerSpace
<
SkIRect
>
LayerSpace
<
SkMatrix
>
:
:
mapRect
(
const
LayerSpace
<
SkIRect
>
&
r
)
const
{
return
LayerSpace
<
SkIRect
>
(
Mapping
:
:
map
(
SkIRect
(
r
)
fData
)
)
;
}
LayerSpace
<
SkPoint
>
LayerSpace
<
SkMatrix
>
:
:
mapPoint
(
const
LayerSpace
<
SkPoint
>
&
p
)
const
{
return
LayerSpace
<
SkPoint
>
(
Mapping
:
:
map
(
SkPoint
(
p
)
fData
)
)
;
}
LayerSpace
<
Vector
>
LayerSpace
<
SkMatrix
>
:
:
mapVector
(
const
LayerSpace
<
Vector
>
&
v
)
const
{
return
LayerSpace
<
Vector
>
(
Mapping
:
:
map
(
Vector
(
v
)
fData
)
)
;
}
LayerSpace
<
SkSize
>
LayerSpace
<
SkMatrix
>
:
:
mapSize
(
const
LayerSpace
<
SkSize
>
&
s
)
const
{
return
LayerSpace
<
SkSize
>
(
Mapping
:
:
map
(
SkSize
(
s
)
fData
)
)
;
}
bool
LayerSpace
<
SkMatrix
>
:
:
inverseMapRect
(
const
LayerSpace
<
SkRect
>
&
r
LayerSpace
<
SkRect
>
*
out
)
const
{
SkRect
mapped
;
if
(
r
.
isEmpty
(
)
)
{
*
out
=
LayerSpace
<
SkRect
>
:
:
Empty
(
)
;
return
true
;
}
else
if
(
SkMatrixPriv
:
:
InverseMapRect
(
fData
&
mapped
SkRect
(
r
)
)
)
{
*
out
=
LayerSpace
<
SkRect
>
(
mapped
)
;
return
true
;
}
else
{
return
false
;
}
}
bool
LayerSpace
<
SkMatrix
>
:
:
inverseMapRect
(
const
LayerSpace
<
SkIRect
>
&
rect
LayerSpace
<
SkIRect
>
*
out
)
const
{
if
(
rect
.
isEmpty
(
)
)
{
*
out
=
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
return
true
;
}
else
if
(
fData
.
isScaleTranslate
(
)
)
{
if
(
fData
.
getScaleX
(
)
=
=
0
.
f
|
|
fData
.
getScaleY
(
)
=
=
0
.
f
)
{
return
false
;
}
double
l
=
(
rect
.
left
(
)
-
(
double
)
fData
.
getTranslateX
(
)
)
/
(
double
)
fData
.
getScaleX
(
)
;
double
r
=
(
rect
.
right
(
)
-
(
double
)
fData
.
getTranslateX
(
)
)
/
(
double
)
fData
.
getScaleX
(
)
;
double
t
=
(
rect
.
top
(
)
-
(
double
)
fData
.
getTranslateY
(
)
)
/
(
double
)
fData
.
getScaleY
(
)
;
double
b
=
(
rect
.
bottom
(
)
-
(
double
)
fData
.
getTranslateY
(
)
)
/
(
double
)
fData
.
getScaleY
(
)
;
SkIRect
mapped
{
sk_double_saturate2int
(
sk_double_floor
(
std
:
:
min
(
l
r
)
+
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_floor
(
std
:
:
min
(
t
b
)
+
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_ceil
(
std
:
:
max
(
l
r
)
-
kRoundEpsilon
)
)
sk_double_saturate2int
(
sk_double_ceil
(
std
:
:
max
(
t
b
)
-
kRoundEpsilon
)
)
}
;
*
out
=
LayerSpace
<
SkIRect
>
(
mapped
)
;
return
true
;
}
else
{
SkRect
mapped
;
if
(
SkMatrixPriv
:
:
InverseMapRect
(
fData
&
mapped
SkRect
:
:
Make
(
SkIRect
(
rect
)
)
)
)
{
*
out
=
LayerSpace
<
SkRect
>
(
mapped
)
.
roundOut
(
)
;
return
true
;
}
}
return
false
;
}
class
FilterResult
:
:
AutoSurface
{
public
:
AutoSurface
(
const
Context
&
ctx
const
LayerSpace
<
SkIRect
>
&
dstBounds
[
[
maybe_unused
]
]
PixelBoundary
boundary
bool
renderInParameterSpace
const
SkSurfaceProps
*
props
=
nullptr
)
:
fDstBounds
(
dstBounds
)
#
if
defined
(
SK_DONT_PAD_LAYER_IMAGES
)
fBoundary
(
PixelBoundary
:
:
kUnknown
)
{
#
else
fBoundary
(
boundary
)
{
#
endif
sk_sp
<
SkDevice
>
device
=
nullptr
;
if
(
!
dstBounds
.
isEmpty
(
)
)
{
fDstBounds
.
outset
(
LayerSpace
<
SkISize
>
(
{
this
-
>
padding
(
)
this
-
>
padding
(
)
}
)
)
;
device
=
ctx
.
backend
(
)
-
>
makeDevice
(
SkISize
(
fDstBounds
.
size
(
)
)
ctx
.
refColorSpace
(
)
props
)
;
}
if
(
!
device
)
{
return
;
}
ctx
.
markNewSurface
(
)
;
fCanvas
.
emplace
(
std
:
:
move
(
device
)
)
;
fCanvas
-
>
translate
(
-
fDstBounds
.
left
(
)
-
fDstBounds
.
top
(
)
)
;
fCanvas
-
>
clear
(
SkColors
:
:
kTransparent
)
;
if
(
fBoundary
=
=
PixelBoundary
:
:
kTransparent
)
{
fCanvas
-
>
clipIRect
(
SkIRect
(
dstBounds
)
)
;
}
else
{
fCanvas
-
>
clipIRect
(
SkIRect
(
fDstBounds
)
)
;
}
if
(
renderInParameterSpace
)
{
fCanvas
-
>
concat
(
SkMatrix
(
ctx
.
mapping
(
)
.
layerMatrix
(
)
)
)
;
}
}
explicit
operator
bool
(
)
const
{
return
fCanvas
.
has_value
(
)
;
}
SkDevice
*
device
(
)
{
SkASSERT
(
fCanvas
.
has_value
(
)
)
;
return
SkCanvasPriv
:
:
TopDevice
(
&
*
fCanvas
)
;
}
SkCanvas
*
operator
-
>
(
)
{
SkASSERT
(
fCanvas
.
has_value
(
)
)
;
return
&
*
fCanvas
;
}
FilterResult
snap
(
)
{
if
(
fCanvas
.
has_value
(
)
)
{
fCanvas
-
>
restoreToCount
(
0
)
;
this
-
>
device
(
)
-
>
setImmutable
(
)
;
SkIRect
subset
=
SkIRect
:
:
MakeWH
(
fDstBounds
.
width
(
)
fDstBounds
.
height
(
)
)
;
sk_sp
<
SkSpecialImage
>
image
=
this
-
>
device
(
)
-
>
snapSpecial
(
subset
)
;
fCanvas
.
reset
(
)
;
if
(
image
&
&
fBoundary
!
=
PixelBoundary
:
:
kUnknown
)
{
const
int
padding
=
this
-
>
padding
(
)
;
subset
=
SkIRect
:
:
MakeSize
(
image
-
>
dimensions
(
)
)
.
makeInset
(
padding
padding
)
;
LayerSpace
<
SkIPoint
>
origin
{
{
fDstBounds
.
left
(
)
+
padding
fDstBounds
.
top
(
)
+
padding
}
}
;
return
{
image
-
>
makeSubset
(
subset
)
origin
fBoundary
}
;
}
else
{
return
{
image
fDstBounds
.
topLeft
(
)
PixelBoundary
:
:
kUnknown
}
;
}
}
else
{
return
{
}
;
}
}
private
:
int
padding
(
)
const
{
return
fBoundary
=
=
PixelBoundary
:
:
kUnknown
?
0
:
1
;
}
std
:
:
optional
<
SkCanvas
>
fCanvas
;
LayerSpace
<
SkIRect
>
fDstBounds
;
PixelBoundary
fBoundary
;
}
;
sk_sp
<
SkSpecialImage
>
FilterResult
:
:
imageAndOffset
(
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
auto
[
image
origin
]
=
this
-
>
imageAndOffset
(
ctx
)
;
*
offset
=
SkIPoint
(
origin
)
;
return
image
;
}
std
:
:
pair
<
sk_sp
<
SkSpecialImage
>
LayerSpace
<
SkIPoint
>
>
FilterResult
:
:
imageAndOffset
(
const
Context
&
ctx
)
const
{
FilterResult
resolved
=
this
-
>
resolve
(
ctx
ctx
.
desiredOutput
(
)
)
;
return
{
resolved
.
fImage
resolved
.
layerBounds
(
)
.
topLeft
(
)
}
;
}
FilterResult
FilterResult
:
:
insetForSaveLayer
(
)
const
{
if
(
!
fImage
)
{
return
{
}
;
}
SkASSERT
(
fTileMode
=
=
SkTileMode
:
:
kDecal
)
;
FilterResult
inset
=
this
-
>
insetByPixel
(
)
;
SkASSERT
(
inset
.
fBoundary
=
=
PixelBoundary
:
:
kInitialized
&
&
inset
.
fTileMode
=
=
SkTileMode
:
:
kDecal
)
;
inset
.
fBoundary
=
PixelBoundary
:
:
kTransparent
;
return
inset
;
}
FilterResult
FilterResult
:
:
insetByPixel
(
)
const
{
auto
insetBounds
=
fLayerBounds
;
insetBounds
.
inset
(
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
SkASSERT
(
!
insetBounds
.
isEmpty
(
)
)
;
return
this
-
>
subset
(
fLayerBounds
.
topLeft
(
)
insetBounds
)
;
}
SkEnumBitMask
<
FilterResult
:
:
BoundsAnalysis
>
FilterResult
:
:
analyzeBounds
(
const
SkMatrix
&
xtraTransform
const
SkIRect
&
dstBounds
BoundsScope
scope
)
const
{
static
constexpr
SkSamplingOptions
kNearestNeighbor
=
{
}
;
static
constexpr
float
kHalfPixel
=
0
.
5f
;
static
constexpr
float
kCubicRadius
=
1
.
5f
;
SkEnumBitMask
<
BoundsAnalysis
>
analysis
=
BoundsAnalysis
:
:
kSimple
;
const
bool
fillsLayerBounds
=
fTileMode
!
=
SkTileMode
:
:
kDecal
|
|
(
fColorFilter
&
&
as_CFB
(
fColorFilter
)
-
>
affectsTransparentBlack
(
)
)
;
SkRect
pixelCenterBounds
=
SkRect
:
:
Make
(
dstBounds
)
;
if
(
!
SkRectPriv
:
:
QuadContainsRect
(
xtraTransform
SkIRect
(
fLayerBounds
)
dstBounds
kRoundEpsilon
)
)
{
bool
requireLayerCrop
=
fillsLayerBounds
;
if
(
!
fillsLayerBounds
)
{
LayerSpace
<
SkIRect
>
imageBounds
=
fTransform
.
mapRect
(
LayerSpace
<
SkIRect
>
{
fImage
-
>
dimensions
(
)
}
)
;
requireLayerCrop
=
!
fLayerBounds
.
contains
(
imageBounds
)
;
}
if
(
requireLayerCrop
)
{
analysis
|
=
BoundsAnalysis
:
:
kRequiresLayerCrop
;
SkIRect
layerBoundsInDst
=
Mapping
:
:
map
(
SkIRect
(
fLayerBounds
)
xtraTransform
)
;
(
void
)
pixelCenterBounds
.
intersect
(
SkRect
:
:
Make
(
layerBoundsInDst
)
)
;
}
}
SkRect
imageBounds
=
SkRect
:
:
Make
(
fImage
-
>
dimensions
(
)
)
;
LayerSpace
<
SkMatrix
>
netTransform
=
fTransform
;
netTransform
.
postConcat
(
LayerSpace
<
SkMatrix
>
(
xtraTransform
)
)
;
SkM44
netM44
{
SkMatrix
(
netTransform
)
}
;
const
auto
[
xAxisAligned
yAxisAligned
]
=
are_axes_nearly_integer_aligned
(
netTransform
)
;
const
bool
isPixelAligned
=
xAxisAligned
&
&
yAxisAligned
;
const
bool
decalLeaks
=
fTileMode
=
=
SkTileMode
:
:
kDecal
&
&
fSamplingOptions
!
=
kNearestNeighbor
&
&
!
isPixelAligned
;
const
float
sampleRadius
=
fSamplingOptions
.
useCubic
?
kCubicRadius
:
kHalfPixel
;
SkRect
safeImageBounds
=
imageBounds
.
makeInset
(
sampleRadius
sampleRadius
)
;
if
(
fSamplingOptions
=
=
kDefaultSampling
&
&
!
isPixelAligned
)
{
safeImageBounds
.
inset
(
xAxisAligned
?
0
.
f
:
kRoundEpsilon
yAxisAligned
?
0
.
f
:
kRoundEpsilon
)
;
}
bool
hasPixelPadding
=
fBoundary
!
=
PixelBoundary
:
:
kUnknown
;
if
(
!
SkRectPriv
:
:
QuadContainsRect
(
netM44
decalLeaks
?
safeImageBounds
:
imageBounds
pixelCenterBounds
kRoundEpsilon
)
)
{
analysis
|
=
BoundsAnalysis
:
:
kDstBoundsNotCovered
;
if
(
fillsLayerBounds
)
{
analysis
|
=
BoundsAnalysis
:
:
kHasLayerFillingEffect
;
}
if
(
decalLeaks
)
{
float
scaleFactors
[
2
]
;
if
(
!
(
SkMatrix
(
netTransform
)
.
getMinMaxScales
(
scaleFactors
)
&
&
SkScalarNearlyEqual
(
scaleFactors
[
0
]
1
.
f
0
.
2f
)
&
&
SkScalarNearlyEqual
(
scaleFactors
[
1
]
1
.
f
0
.
2f
)
)
)
{
analysis
|
=
BoundsAnalysis
:
:
kRequiresDecalInLayerSpace
;
if
(
fBoundary
=
=
PixelBoundary
:
:
kTransparent
)
{
hasPixelPadding
=
false
;
}
}
}
}
if
(
scope
=
=
BoundsScope
:
:
kDeferred
)
{
return
analysis
;
}
else
if
(
scope
=
=
BoundsScope
:
:
kCanDrawDirectly
&
&
!
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
)
{
const
bool
nnOrBilerp
=
fSamplingOptions
=
=
kDefaultSampling
|
|
fSamplingOptions
=
=
kNearestNeighbor
;
if
(
nnOrBilerp
&
&
(
hasPixelPadding
|
|
isPixelAligned
)
)
{
return
analysis
;
}
}
if
(
hasPixelPadding
)
{
safeImageBounds
.
outset
(
1
.
f
1
.
f
)
;
}
pixelCenterBounds
.
inset
(
kHalfPixel
kHalfPixel
)
;
skvx
:
:
int4
edgeMask
=
SkRectPriv
:
:
QuadContainsRectMask
(
netM44
safeImageBounds
pixelCenterBounds
kRoundEpsilon
)
;
if
(
!
all
(
edgeMask
)
)
{
skvx
:
:
int4
hwEdge
{
fImage
-
>
subset
(
)
.
fTop
=
=
0
fImage
-
>
subset
(
)
.
fRight
=
=
fImage
-
>
backingStoreDimensions
(
)
.
fWidth
fImage
-
>
subset
(
)
.
fBottom
=
=
fImage
-
>
backingStoreDimensions
(
)
.
fHeight
fImage
-
>
subset
(
)
.
fLeft
=
=
0
}
;
if
(
fTileMode
=
=
SkTileMode
:
:
kRepeat
|
|
fTileMode
=
=
SkTileMode
:
:
kMirror
)
{
hwEdge
=
hwEdge
&
skvx
:
:
shuffle
<
2
3
0
1
>
(
hwEdge
)
;
}
if
(
!
all
(
edgeMask
|
hwEdge
)
)
{
analysis
|
=
BoundsAnalysis
:
:
kRequiresShaderTiling
;
}
}
return
analysis
;
}
void
FilterResult
:
:
updateTileMode
(
const
Context
&
ctx
SkTileMode
tileMode
)
{
if
(
fImage
)
{
fTileMode
=
tileMode
;
if
(
tileMode
!
=
SkTileMode
:
:
kDecal
)
{
fLayerBounds
=
ctx
.
desiredOutput
(
)
;
}
}
}
FilterResult
FilterResult
:
:
applyCrop
(
const
Context
&
ctx
const
LayerSpace
<
SkIRect
>
&
crop
SkTileMode
tileMode
)
const
{
static
const
LayerSpace
<
SkMatrix
>
kIdentity
{
SkMatrix
:
:
I
(
)
}
;
if
(
crop
.
isEmpty
(
)
|
|
ctx
.
desiredOutput
(
)
.
isEmpty
(
)
)
{
return
{
}
;
}
LayerSpace
<
SkIRect
>
cropContent
=
crop
;
if
(
!
fImage
|
|
!
cropContent
.
intersect
(
fLayerBounds
)
)
{
return
{
}
;
}
LayerSpace
<
SkIRect
>
fittedCrop
=
crop
.
relevantSubset
(
ctx
.
desiredOutput
(
)
tileMode
)
;
if
(
!
cropContent
.
intersect
(
fittedCrop
)
)
{
return
{
}
;
}
auto
periodicTransform
=
periodic_axis_transform
(
tileMode
fittedCrop
ctx
.
desiredOutput
(
)
)
;
if
(
periodicTransform
)
{
return
this
-
>
applyTransform
(
ctx
*
periodicTransform
FilterResult
:
:
kDefaultSampling
)
;
}
bool
preserveTransparencyInCrop
=
false
;
if
(
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
fittedCrop
=
cropContent
;
}
else
if
(
fittedCrop
.
contains
(
ctx
.
desiredOutput
(
)
)
)
{
tileMode
=
SkTileMode
:
:
kDecal
;
fittedCrop
=
ctx
.
desiredOutput
(
)
;
}
else
if
(
!
cropContent
.
contains
(
fittedCrop
)
)
{
preserveTransparencyInCrop
=
true
;
if
(
fTileMode
=
=
SkTileMode
:
:
kDecal
&
&
tileMode
=
=
SkTileMode
:
:
kClamp
)
{
cropContent
.
outset
(
skif
:
:
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
SkAssertResult
(
fittedCrop
.
intersect
(
cropContent
)
)
;
}
}
const
bool
doubleClamp
=
fTileMode
=
=
SkTileMode
:
:
kClamp
&
&
tileMode
=
=
SkTileMode
:
:
kClamp
;
LayerSpace
<
SkIPoint
>
origin
;
if
(
!
preserveTransparencyInCrop
&
&
is_nearly_integer_translation
(
fTransform
&
origin
)
&
&
(
doubleClamp
|
|
!
(
this
-
>
analyzeBounds
(
fittedCrop
)
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
)
)
{
FilterResult
restrictedOutput
=
this
-
>
subset
(
origin
fittedCrop
doubleClamp
)
;
restrictedOutput
.
updateTileMode
(
ctx
tileMode
)
;
if
(
restrictedOutput
.
fBoundary
=
=
PixelBoundary
:
:
kInitialized
|
|
tileMode
!
=
SkTileMode
:
:
kDecal
)
{
restrictedOutput
.
fBoundary
=
PixelBoundary
:
:
kUnknown
;
}
return
restrictedOutput
;
}
else
if
(
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
SkASSERT
(
!
preserveTransparencyInCrop
)
;
FilterResult
restrictedOutput
=
*
this
;
restrictedOutput
.
fLayerBounds
=
fittedCrop
;
return
restrictedOutput
;
}
else
{
FilterResult
tiled
=
this
-
>
resolve
(
ctx
fittedCrop
true
)
;
tiled
.
updateTileMode
(
ctx
tileMode
)
;
return
tiled
;
}
}
FilterResult
FilterResult
:
:
applyColorFilter
(
const
Context
&
ctx
sk_sp
<
SkColorFilter
>
colorFilter
)
const
{
SkASSERT
(
colorFilter
)
;
if
(
ctx
.
desiredOutput
(
)
.
isEmpty
(
)
)
{
return
{
}
;
}
LayerSpace
<
SkIRect
>
newLayerBounds
=
fLayerBounds
;
if
(
as_CFB
(
colorFilter
)
-
>
affectsTransparentBlack
(
)
)
{
if
(
!
fImage
|
|
!
newLayerBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
AutoSurface
surface
{
ctx
LayerSpace
<
SkIRect
>
{
SkIRect
:
:
MakeXYWH
(
ctx
.
desiredOutput
(
)
.
left
(
)
ctx
.
desiredOutput
(
)
.
top
(
)
1
1
)
}
PixelBoundary
:
:
kInitialized
false
}
;
if
(
surface
)
{
SkPaint
paint
;
paint
.
setColor4f
(
SkColors
:
:
kTransparent
nullptr
)
;
paint
.
setColorFilter
(
std
:
:
move
(
colorFilter
)
)
;
surface
-
>
drawPaint
(
paint
)
;
}
FilterResult
solidColor
=
surface
.
snap
(
)
;
solidColor
.
updateTileMode
(
ctx
SkTileMode
:
:
kClamp
)
;
return
solidColor
;
}
if
(
this
-
>
analyzeBounds
(
ctx
.
desiredOutput
(
)
)
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
{
newLayerBounds
.
outset
(
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
SkAssertResult
(
newLayerBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
;
FilterResult
filtered
=
this
-
>
resolve
(
ctx
newLayerBounds
true
)
;
filtered
.
fColorFilter
=
std
:
:
move
(
colorFilter
)
;
filtered
.
updateTileMode
(
ctx
SkTileMode
:
:
kClamp
)
;
return
filtered
;
}
newLayerBounds
=
ctx
.
desiredOutput
(
)
;
}
else
{
if
(
!
fImage
|
|
!
LayerSpace
<
SkIRect
>
:
:
Intersects
(
newLayerBounds
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
}
FilterResult
filtered
=
*
this
;
filtered
.
fLayerBounds
=
newLayerBounds
;
filtered
.
fColorFilter
=
SkColorFilters
:
:
Compose
(
std
:
:
move
(
colorFilter
)
fColorFilter
)
;
return
filtered
;
}
static
bool
compatible_sampling
(
const
SkSamplingOptions
&
currentSampling
bool
currentXformWontAffectNearest
SkSamplingOptions
*
nextSampling
bool
nextXformWontAffectNearest
)
{
if
(
currentSampling
.
isAniso
(
)
&
&
nextSampling
-
>
isAniso
(
)
)
{
*
nextSampling
=
SkSamplingOptions
:
:
Aniso
(
std
:
:
max
(
currentSampling
.
maxAniso
nextSampling
-
>
maxAniso
)
)
;
return
true
;
}
else
if
(
currentSampling
.
isAniso
(
)
&
&
nextSampling
-
>
filter
=
=
SkFilterMode
:
:
kLinear
)
{
*
nextSampling
=
currentSampling
;
return
true
;
}
else
if
(
nextSampling
-
>
isAniso
(
)
&
&
currentSampling
.
filter
=
=
SkFilterMode
:
:
kLinear
)
{
return
true
;
}
else
if
(
currentSampling
.
useCubic
&
&
(
nextSampling
-
>
filter
=
=
SkFilterMode
:
:
kLinear
|
|
(
nextSampling
-
>
useCubic
&
&
currentSampling
.
cubic
.
B
=
=
nextSampling
-
>
cubic
.
B
&
&
currentSampling
.
cubic
.
C
=
=
nextSampling
-
>
cubic
.
C
)
)
)
{
*
nextSampling
=
currentSampling
;
return
true
;
}
else
if
(
nextSampling
-
>
useCubic
&
&
currentSampling
.
filter
=
=
SkFilterMode
:
:
kLinear
)
{
return
true
;
}
else
if
(
currentSampling
.
filter
=
=
SkFilterMode
:
:
kLinear
&
&
nextSampling
-
>
filter
=
=
SkFilterMode
:
:
kLinear
)
{
return
true
;
}
else
if
(
nextSampling
-
>
filter
=
=
SkFilterMode
:
:
kNearest
&
&
currentXformWontAffectNearest
)
{
SkASSERT
(
currentSampling
.
filter
=
=
SkFilterMode
:
:
kLinear
)
;
return
true
;
}
else
if
(
currentSampling
.
filter
=
=
SkFilterMode
:
:
kNearest
&
&
nextXformWontAffectNearest
)
{
SkASSERT
(
nextSampling
-
>
filter
=
=
SkFilterMode
:
:
kLinear
)
;
*
nextSampling
=
currentSampling
;
return
true
;
}
else
{
return
false
;
}
}
FilterResult
FilterResult
:
:
applyTransform
(
const
Context
&
ctx
const
LayerSpace
<
SkMatrix
>
&
transform
const
SkSamplingOptions
&
sampling
)
const
{
if
(
!
fImage
|
|
ctx
.
desiredOutput
(
)
.
isEmpty
(
)
)
{
SkASSERT
(
!
fColorFilter
)
;
return
{
}
;
}
const
bool
currentXformIsInteger
=
is_nearly_integer_translation
(
fTransform
)
;
const
bool
nextXformIsInteger
=
is_nearly_integer_translation
(
transform
)
;
SkASSERT
(
!
currentXformIsInteger
|
|
fSamplingOptions
=
=
kDefaultSampling
)
;
SkSamplingOptions
nextSampling
=
nextXformIsInteger
?
kDefaultSampling
:
sampling
;
bool
isCropped
=
!
nextXformIsInteger
&
&
(
this
-
>
analyzeBounds
(
SkMatrix
(
transform
)
SkIRect
(
ctx
.
desiredOutput
(
)
)
)
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
;
FilterResult
transformed
;
if
(
!
isCropped
&
&
compatible_sampling
(
fSamplingOptions
currentXformIsInteger
&
nextSampling
nextXformIsInteger
)
)
{
transformed
=
*
this
;
}
else
{
LayerSpace
<
SkIRect
>
tightBounds
;
if
(
transform
.
inverseMapRect
(
ctx
.
desiredOutput
(
)
&
tightBounds
)
)
{
transformed
=
this
-
>
resolve
(
ctx
tightBounds
)
;
}
if
(
!
transformed
.
fImage
)
{
return
{
}
;
}
}
transformed
.
fSamplingOptions
=
nextSampling
;
transformed
.
fTransform
.
postConcat
(
transform
)
;
transformed
.
fLayerBounds
=
transform
.
mapRect
(
transformed
.
fLayerBounds
)
;
if
(
!
LayerSpace
<
SkIRect
>
:
:
Intersects
(
transformed
.
fLayerBounds
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
return
transformed
;
}
FilterResult
FilterResult
:
:
resolve
(
const
Context
&
ctx
LayerSpace
<
SkIRect
>
dstBounds
bool
preserveDstBounds
)
const
{
if
(
!
fImage
|
|
(
!
preserveDstBounds
&
&
!
dstBounds
.
intersect
(
fLayerBounds
)
)
)
{
return
{
nullptr
{
}
}
;
}
const
bool
subsetCompatible
=
!
fColorFilter
&
&
fTileMode
=
=
SkTileMode
:
:
kDecal
&
&
!
preserveDstBounds
;
LayerSpace
<
SkIPoint
>
origin
;
if
(
subsetCompatible
&
&
is_nearly_integer_translation
(
fTransform
&
origin
)
)
{
return
this
-
>
subset
(
origin
dstBounds
)
;
}
SkSurfaceProps
props
=
{
}
;
PixelBoundary
boundary
=
preserveDstBounds
?
PixelBoundary
:
:
kUnknown
:
PixelBoundary
:
:
kTransparent
;
AutoSurface
surface
{
ctx
dstBounds
boundary
false
&
props
}
;
if
(
surface
)
{
this
-
>
draw
(
ctx
surface
.
device
(
)
false
)
;
}
return
surface
.
snap
(
)
;
}
FilterResult
FilterResult
:
:
subset
(
const
LayerSpace
<
SkIPoint
>
&
knownOrigin
const
LayerSpace
<
SkIRect
>
&
subsetBounds
bool
clampSrcIfDisjoint
)
const
{
SkDEBUGCODE
(
LayerSpace
<
SkIPoint
>
actualOrigin
;
)
SkASSERT
(
is_nearly_integer_translation
(
fTransform
&
actualOrigin
)
&
&
SkIPoint
(
actualOrigin
)
=
=
SkIPoint
(
knownOrigin
)
)
;
LayerSpace
<
SkIRect
>
imageBounds
(
SkIRect
:
:
MakeXYWH
(
knownOrigin
.
x
(
)
knownOrigin
.
y
(
)
fImage
-
>
width
(
)
fImage
-
>
height
(
)
)
)
;
imageBounds
=
imageBounds
.
relevantSubset
(
subsetBounds
clampSrcIfDisjoint
?
SkTileMode
:
:
kClamp
:
SkTileMode
:
:
kDecal
)
;
if
(
imageBounds
.
isEmpty
(
)
)
{
return
{
}
;
}
SkIRect
subset
=
{
imageBounds
.
left
(
)
-
knownOrigin
.
x
(
)
imageBounds
.
top
(
)
-
knownOrigin
.
y
(
)
imageBounds
.
right
(
)
-
knownOrigin
.
x
(
)
imageBounds
.
bottom
(
)
-
knownOrigin
.
y
(
)
}
;
SkASSERT
(
subset
.
fLeft
>
=
0
&
&
subset
.
fTop
>
=
0
&
&
subset
.
fRight
<
=
fImage
-
>
width
(
)
&
&
subset
.
fBottom
<
=
fImage
-
>
height
(
)
)
;
FilterResult
result
{
fImage
-
>
makeSubset
(
subset
)
imageBounds
.
topLeft
(
)
}
;
result
.
fColorFilter
=
fColorFilter
;
SkASSERT
(
result
.
fBoundary
=
=
PixelBoundary
:
:
kUnknown
)
;
if
(
fImage
-
>
subset
(
)
=
=
result
.
fImage
-
>
subset
(
)
)
{
result
.
fBoundary
=
fBoundary
;
}
else
{
SkIRect
safeSubset
=
fImage
-
>
subset
(
)
;
if
(
fBoundary
=
=
PixelBoundary
:
:
kUnknown
)
{
safeSubset
.
inset
(
1
1
)
;
}
if
(
safeSubset
.
contains
(
result
.
fImage
-
>
subset
(
)
)
)
{
result
.
fBoundary
=
PixelBoundary
:
:
kInitialized
;
}
}
return
result
;
}
void
FilterResult
:
:
draw
(
const
Context
&
ctx
SkDevice
*
target
const
SkBlender
*
blender
)
const
{
SkAutoDeviceTransformRestore
adtr
{
target
ctx
.
mapping
(
)
.
layerToDevice
(
)
}
;
this
-
>
draw
(
ctx
target
true
blender
)
;
}
void
FilterResult
:
:
draw
(
const
Context
&
ctx
SkDevice
*
device
bool
preserveDeviceState
const
SkBlender
*
blender
)
const
{
const
bool
blendAffectsTransparentBlack
=
blender
&
&
as_BB
(
blender
)
-
>
affectsTransparentBlack
(
)
;
if
(
!
fImage
)
{
if
(
blendAffectsTransparentBlack
)
{
SkPaint
clear
;
clear
.
setColor4f
(
SkColors
:
:
kTransparent
)
;
clear
.
setBlender
(
sk_ref_sp
(
blender
)
)
;
device
-
>
drawPaint
(
clear
)
;
}
return
;
}
BoundsScope
scope
=
blendAffectsTransparentBlack
?
BoundsScope
:
:
kShaderOnly
:
BoundsScope
:
:
kCanDrawDirectly
;
SkEnumBitMask
<
BoundsAnalysis
>
analysis
=
this
-
>
analyzeBounds
(
device
-
>
localToDevice
(
)
device
-
>
devClipBounds
(
)
scope
)
;
if
(
analysis
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
{
if
(
blendAffectsTransparentBlack
)
{
LayerSpace
<
SkIRect
>
dstBounds
;
if
(
!
LayerSpace
<
SkMatrix
>
(
device
-
>
localToDevice
(
)
)
.
inverseMapRect
(
LayerSpace
<
SkIRect
>
(
device
-
>
devClipBounds
(
)
)
&
dstBounds
)
)
{
return
;
}
FilterResult
clipped
=
this
-
>
resolve
(
ctx
dstBounds
)
;
clipped
.
draw
(
ctx
device
preserveDeviceState
blender
)
;
return
;
}
if
(
preserveDeviceState
)
{
device
-
>
pushClipStack
(
)
;
}
device
-
>
clipRect
(
SkRect
:
:
Make
(
SkIRect
(
fLayerBounds
)
)
SkClipOp
:
:
kIntersect
true
)
;
}
const
bool
pixelAligned
=
is_nearly_integer_translation
(
fTransform
)
&
&
is_nearly_integer_translation
(
skif
:
:
LayerSpace
<
SkMatrix
>
(
device
-
>
localToDevice
(
)
)
)
;
SkSamplingOptions
sampling
=
fSamplingOptions
;
if
(
sampling
=
=
kDefaultSampling
&
&
pixelAligned
)
{
sampling
=
{
}
;
}
if
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
|
|
(
blendAffectsTransparentBlack
&
&
(
analysis
&
BoundsAnalysis
:
:
kDstBoundsNotCovered
)
)
)
{
SkPaint
paint
;
paint
.
setBlender
(
sk_ref_sp
(
blender
)
)
;
paint
.
setShader
(
this
-
>
getAnalyzedShaderView
(
ctx
sampling
analysis
)
)
;
device
-
>
drawPaint
(
paint
)
;
}
else
{
this
-
>
drawAnalyzedImage
(
ctx
device
sampling
analysis
blender
)
;
}
if
(
preserveDeviceState
&
&
(
analysis
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
)
{
device
-
>
popClipStack
(
)
;
}
}
void
FilterResult
:
:
drawAnalyzedImage
(
const
Context
&
ctx
SkDevice
*
device
const
SkSamplingOptions
&
finalSampling
SkEnumBitMask
<
BoundsAnalysis
>
analysis
const
SkBlender
*
blender
)
const
{
SkASSERT
(
!
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
)
;
SkPaint
paint
;
paint
.
setBlender
(
sk_ref_sp
(
blender
)
)
;
paint
.
setColorFilter
(
fColorFilter
)
;
SkMatrix
netTransform
=
SkMatrix
:
:
Concat
(
device
-
>
localToDevice
(
)
SkMatrix
(
fTransform
)
)
;
if
(
this
-
>
canClampToTransparentBoundary
(
analysis
)
&
&
fSamplingOptions
=
=
kDefaultSampling
)
{
SkASSERT
(
!
(
analysis
&
BoundsAnalysis
:
:
kRequiresShaderTiling
)
)
;
netTransform
.
preTranslate
(
-
1
.
f
-
1
.
f
)
;
device
-
>
drawSpecial
(
fImage
-
>
makePixelOutset
(
)
.
get
(
)
netTransform
finalSampling
paint
SkCanvas
:
:
kFast_SrcRectConstraint
)
;
}
else
{
paint
.
setAntiAlias
(
true
)
;
SkCanvas
:
:
SrcRectConstraint
constraint
=
SkCanvas
:
:
kFast_SrcRectConstraint
;
if
(
analysis
&
BoundsAnalysis
:
:
kRequiresShaderTiling
)
{
constraint
=
SkCanvas
:
:
kStrict_SrcRectConstraint
;
ctx
.
markShaderBasedTilingRequired
(
SkTileMode
:
:
kClamp
)
;
}
device
-
>
drawSpecial
(
fImage
.
get
(
)
netTransform
finalSampling
paint
constraint
)
;
}
}
sk_sp
<
SkShader
>
FilterResult
:
:
asShader
(
const
Context
&
ctx
const
SkSamplingOptions
&
xtraSampling
SkEnumBitMask
<
ShaderFlags
>
flags
const
LayerSpace
<
SkIRect
>
&
sampleBounds
)
const
{
if
(
!
fImage
)
{
return
nullptr
;
}
const
bool
currentXformIsInteger
=
is_nearly_integer_translation
(
fTransform
)
;
const
bool
nextXformIsInteger
=
!
(
flags
&
ShaderFlags
:
:
kNonTrivialSampling
)
;
SkBlendMode
colorFilterMode
;
SkEnumBitMask
<
BoundsAnalysis
>
analysis
=
this
-
>
analyzeBounds
(
sampleBounds
BoundsScope
:
:
kShaderOnly
)
;
SkSamplingOptions
sampling
=
xtraSampling
;
const
bool
needsResolve
=
(
flags
&
ShaderFlags
:
:
kSampledRepeatedly
&
&
(
(
fColorFilter
&
&
(
!
fColorFilter
-
>
asAColorMode
(
nullptr
&
colorFilterMode
)
|
|
colorFilterMode
>
SkBlendMode
:
:
kLastCoeffMode
)
)
|
|
!
SkColorSpace
:
:
Equals
(
fImage
-
>
getColorSpace
(
)
ctx
.
colorSpace
(
)
)
)
)
|
|
!
compatible_sampling
(
fSamplingOptions
currentXformIsInteger
&
sampling
nextXformIsInteger
)
|
|
(
analysis
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
;
if
(
sampling
=
=
kDefaultSampling
&
&
nextXformIsInteger
&
&
(
needsResolve
|
|
currentXformIsInteger
)
)
{
sampling
=
{
}
;
}
sk_sp
<
SkShader
>
shader
;
if
(
needsResolve
)
{
FilterResult
resolved
=
this
-
>
resolve
(
ctx
sampleBounds
)
;
if
(
resolved
)
{
[
[
maybe_unused
]
]
static
constexpr
SkEnumBitMask
<
BoundsAnalysis
>
kExpectedAnalysis
=
BoundsAnalysis
:
:
kDstBoundsNotCovered
|
BoundsAnalysis
:
:
kRequiresShaderTiling
;
analysis
=
resolved
.
analyzeBounds
(
sampleBounds
BoundsScope
:
:
kShaderOnly
)
;
SkASSERT
(
!
(
analysis
&
~
kExpectedAnalysis
)
)
;
return
resolved
.
getAnalyzedShaderView
(
ctx
sampling
analysis
)
;
}
}
else
{
shader
=
this
-
>
getAnalyzedShaderView
(
ctx
sampling
analysis
)
;
}
return
shader
;
}
sk_sp
<
SkShader
>
FilterResult
:
:
getAnalyzedShaderView
(
const
Context
&
ctx
const
SkSamplingOptions
&
finalSampling
SkEnumBitMask
<
BoundsAnalysis
>
analysis
)
const
{
const
SkMatrix
&
localMatrix
(
fTransform
)
;
const
SkRect
imageBounds
=
SkRect
:
:
Make
(
fImage
-
>
dimensions
(
)
)
;
SkMatrix
postDecal
preDecal
;
if
(
localMatrix
.
rectStaysRect
(
)
|
|
!
(
analysis
&
BoundsAnalysis
:
:
kRequiresDecalInLayerSpace
)
)
{
postDecal
=
SkMatrix
:
:
I
(
)
;
preDecal
=
localMatrix
;
}
else
{
decompose_transform
(
localMatrix
imageBounds
.
center
(
)
&
postDecal
&
preDecal
)
;
}
SkTileMode
effectiveTileMode
=
fTileMode
;
const
bool
decalClampToTransparent
=
this
-
>
canClampToTransparentBoundary
(
analysis
)
;
const
bool
strict
=
SkToBool
(
analysis
&
BoundsAnalysis
:
:
kRequiresShaderTiling
)
;
sk_sp
<
SkShader
>
imageShader
;
if
(
strict
&
&
decalClampToTransparent
)
{
preDecal
.
preTranslate
(
-
1
.
f
-
1
.
f
)
;
imageShader
=
fImage
-
>
makePixelOutset
(
)
-
>
asShader
(
SkTileMode
:
:
kClamp
finalSampling
preDecal
strict
)
;
effectiveTileMode
=
SkTileMode
:
:
kClamp
;
}
else
{
if
(
!
(
analysis
&
BoundsAnalysis
:
:
kDstBoundsNotCovered
)
|
|
(
analysis
&
BoundsAnalysis
:
:
kRequiresDecalInLayerSpace
)
)
{
effectiveTileMode
=
SkTileMode
:
:
kClamp
;
}
imageShader
=
fImage
-
>
asShader
(
effectiveTileMode
finalSampling
preDecal
strict
)
;
}
if
(
strict
)
{
ctx
.
markShaderBasedTilingRequired
(
effectiveTileMode
)
;
}
if
(
analysis
&
BoundsAnalysis
:
:
kRequiresDecalInLayerSpace
)
{
SkASSERT
(
fTileMode
=
=
SkTileMode
:
:
kDecal
)
;
const
SkRuntimeEffect
*
decalEffect
=
GetKnownRuntimeEffect
(
SkKnownRuntimeEffects
:
:
StableKey
:
:
kDecal
)
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
decalEffect
)
)
;
builder
.
child
(
"
image
"
)
=
std
:
:
move
(
imageShader
)
;
builder
.
uniform
(
"
decalBounds
"
)
=
preDecal
.
mapRect
(
imageBounds
)
;
imageShader
=
builder
.
makeShader
(
)
;
}
if
(
imageShader
&
&
!
postDecal
.
isIdentity
(
)
)
{
imageShader
=
imageShader
-
>
makeWithLocalMatrix
(
postDecal
)
;
}
if
(
imageShader
&
&
fColorFilter
)
{
imageShader
=
imageShader
-
>
makeWithColorFilter
(
fColorFilter
)
;
}
return
imageShader
;
}
static
int
downscale_step_count
(
float
netScaleFactor
)
{
int
steps
=
SkNextLog2
(
sk_float_ceil2int
(
1
.
f
/
netScaleFactor
)
)
;
if
(
steps
>
0
)
{
static
constexpr
float
kMultiPassLimit
=
0
.
8f
;
static
constexpr
float
kNearIdentityLimit
=
1
.
f
-
kRoundEpsilon
;
float
finalStepScale
=
netScaleFactor
*
(
1
<
<
(
steps
-
1
)
)
;
float
limit
=
steps
=
=
1
?
kNearIdentityLimit
:
kMultiPassLimit
;
if
(
finalStepScale
>
=
limit
)
{
steps
-
-
;
}
}
return
steps
;
}
template
<
typename
T
>
using
PixelSpace
=
LayerSpace
<
T
>
;
FilterResult
FilterResult
:
:
rescale
(
const
Context
&
ctx
const
LayerSpace
<
SkSize
>
&
scale
bool
enforceDecal
)
const
{
LayerSpace
<
SkIRect
>
visibleLayerBounds
=
fLayerBounds
;
if
(
!
fImage
|
|
!
visibleLayerBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
|
|
scale
.
width
(
)
<
=
0
.
f
|
|
scale
.
height
(
)
<
=
0
.
f
)
{
return
{
}
;
}
int
xSteps
=
downscale_step_count
(
scale
.
width
(
)
)
;
int
ySteps
=
downscale_step_count
(
scale
.
height
(
)
)
;
PixelSpace
<
SkIPoint
>
origin
;
const
bool
pixelAligned
=
is_nearly_integer_translation
(
fTransform
&
origin
)
;
SkEnumBitMask
<
BoundsAnalysis
>
analysis
=
this
-
>
analyzeBounds
(
ctx
.
desiredOutput
(
)
BoundsScope
:
:
kShaderOnly
)
;
const
bool
canDeferTiling
=
pixelAligned
&
&
!
(
analysis
&
BoundsAnalysis
:
:
kRequiresLayerCrop
)
&
&
!
(
enforceDecal
&
&
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
)
;
const
bool
hasEffectsToApply
=
!
canDeferTiling
|
|
SkToBool
(
fColorFilter
)
|
|
fImage
-
>
colorType
(
)
!
=
ctx
.
backend
(
)
-
>
colorType
(
)
|
|
!
SkColorSpace
:
:
Equals
(
fImage
-
>
getColorSpace
(
)
ctx
.
colorSpace
(
)
)
;
if
(
xSteps
=
=
0
&
&
ySteps
=
=
0
&
&
!
hasEffectsToApply
)
{
if
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
{
FilterResult
noop
=
*
this
;
noop
.
fLayerBounds
=
visibleLayerBounds
;
return
noop
;
}
else
{
return
this
-
>
subset
(
origin
visibleLayerBounds
)
;
}
}
PixelSpace
<
SkIRect
>
srcRect
;
SkTileMode
tileMode
;
if
(
canDeferTiling
&
&
(
analysis
&
BoundsAnalysis
:
:
kHasLayerFillingEffect
)
)
{
srcRect
=
LayerSpace
<
SkIRect
>
(
SkIRect
:
:
MakeXYWH
(
origin
.
x
(
)
origin
.
y
(
)
fImage
-
>
width
(
)
fImage
-
>
height
(
)
)
)
;
tileMode
=
fTileMode
;
}
else
{
srcRect
=
visibleLayerBounds
;
tileMode
=
SkTileMode
:
:
kDecal
;
}
srcRect
=
srcRect
.
relevantSubset
(
ctx
.
desiredOutput
(
)
tileMode
)
;
if
(
srcRect
.
isEmpty
(
)
)
{
return
{
}
;
}
PixelSpace
<
SkRect
>
stepBoundsF
{
srcRect
}
;
PixelSpace
<
SkIRect
>
stepPixelBounds
{
srcRect
}
;
stepPixelBounds
.
outset
(
PixelSpace
<
SkISize
>
(
{
1
1
}
)
)
;
sk_sp
<
SkSpecialImage
>
image
=
nullptr
;
while
(
!
image
|
|
xSteps
>
0
|
|
ySteps
>
0
)
{
float
sx
=
1
.
f
;
if
(
xSteps
>
0
)
{
sx
=
xSteps
>
1
?
0
.
5f
:
srcRect
.
width
(
)
*
scale
.
width
(
)
/
stepBoundsF
.
width
(
)
;
xSteps
-
-
;
}
float
sy
=
1
.
f
;
if
(
ySteps
>
0
)
{
sy
=
ySteps
>
1
?
0
.
5f
:
srcRect
.
height
(
)
*
scale
.
height
(
)
/
stepBoundsF
.
height
(
)
;
ySteps
-
-
;
}
PixelSpace
<
SkRect
>
dstBoundsF
{
SkRect
:
:
MakeWH
(
stepBoundsF
.
width
(
)
*
sx
stepBoundsF
.
height
(
)
*
sy
)
}
;
PixelSpace
<
SkIRect
>
dstPixelBounds
=
dstBoundsF
.
roundOut
(
)
;
if
(
tileMode
=
=
SkTileMode
:
:
kClamp
|
|
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
float
srcFracX
=
stepPixelBounds
.
right
(
)
-
stepBoundsF
.
right
(
)
-
0
.
5f
;
float
dstFracX
=
dstPixelBounds
.
right
(
)
-
dstBoundsF
.
right
(
)
-
0
.
5f
;
int
px
=
std
:
:
max
(
1
sk_float_ceil2int
(
(
sx
*
srcFracX
-
dstFracX
)
)
)
;
float
srcFracY
=
stepPixelBounds
.
bottom
(
)
-
stepBoundsF
.
bottom
(
)
-
0
.
5f
;
float
dstFracY
=
dstPixelBounds
.
bottom
(
)
-
dstBoundsF
.
bottom
(
)
-
0
.
5f
;
int
py
=
std
:
:
max
(
1
sk_float_ceil2int
(
(
sy
*
srcFracY
-
dstFracY
)
)
)
;
dstPixelBounds
.
outset
(
PixelSpace
<
SkISize
>
(
{
px
py
}
)
)
;
SkASSERT
(
sx
!
=
1
.
f
|
|
dstPixelBounds
.
width
(
)
=
=
stepPixelBounds
.
width
(
)
)
;
SkASSERT
(
sy
!
=
1
.
f
|
|
dstPixelBounds
.
height
(
)
=
=
stepPixelBounds
.
height
(
)
)
;
}
AutoSurface
surface
{
ctx
dstPixelBounds
PixelBoundary
:
:
kUnknown
false
}
;
if
(
surface
)
{
const
auto
scaleXform
=
PixelSpace
<
SkMatrix
>
:
:
RectToRect
(
stepBoundsF
dstBoundsF
)
;
surface
-
>
concat
(
SkMatrix
(
scaleXform
)
)
;
SkPaint
paint
;
if
(
!
image
)
{
analysis
=
this
-
>
analyzeBounds
(
SkMatrix
(
scaleXform
)
SkIRect
(
dstPixelBounds
)
BoundsScope
:
:
kShaderOnly
)
;
analysis
&
=
~
BoundsAnalysis
:
:
kRequiresDecalInLayerSpace
;
paint
.
setShader
(
this
-
>
getAnalyzedShaderView
(
ctx
fSamplingOptions
analysis
)
)
;
}
else
{
paint
.
setShader
(
image
-
>
asShader
(
tileMode
SkFilterMode
:
:
kLinear
SkMatrix
:
:
Translate
(
origin
.
x
(
)
origin
.
y
(
)
)
)
)
;
if
(
!
image
-
>
isExactFit
(
)
)
{
ctx
.
markShaderBasedTilingRequired
(
tileMode
)
;
}
}
surface
-
>
drawPaint
(
paint
)
;
}
else
{
return
{
}
;
}
if
(
tileMode
=
=
SkTileMode
:
:
kDecal
)
{
tileMode
=
SkTileMode
:
:
kClamp
;
}
FilterResult
snapped
=
surface
.
snap
(
)
;
image
=
snapped
.
fImage
;
origin
=
snapped
.
fLayerBounds
.
topLeft
(
)
;
stepBoundsF
=
dstBoundsF
;
stepPixelBounds
=
dstPixelBounds
;
}
FilterResult
result
{
std
:
:
move
(
image
)
origin
}
;
result
.
fTransform
.
postConcat
(
LayerSpace
<
SkMatrix
>
:
:
RectToRect
(
stepBoundsF
LayerSpace
<
SkRect
>
{
srcRect
}
)
)
;
result
.
fLayerBounds
=
visibleLayerBounds
;
if
(
enforceDecal
)
{
SkASSERT
(
!
canDeferTiling
&
&
tileMode
=
=
SkTileMode
:
:
kClamp
)
;
result
.
fTileMode
=
SkTileMode
:
:
kDecal
;
}
else
{
result
.
fTileMode
=
tileMode
;
}
return
result
;
}
FilterResult
FilterResult
:
:
MakeFromPicture
(
const
Context
&
ctx
sk_sp
<
SkPicture
>
pic
ParameterSpace
<
SkRect
>
cullRect
)
{
SkASSERT
(
pic
)
;
LayerSpace
<
SkIRect
>
dstBounds
=
ctx
.
mapping
(
)
.
paramToLayer
(
cullRect
)
.
roundOut
(
)
;
if
(
!
dstBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
SkSurfaceProps
props
=
ctx
.
backend
(
)
-
>
surfaceProps
(
)
.
cloneWithPixelGeometry
(
kUnknown_SkPixelGeometry
)
;
AutoSurface
surface
{
ctx
dstBounds
PixelBoundary
:
:
kTransparent
true
&
props
}
;
if
(
surface
)
{
surface
-
>
clipRect
(
SkRect
(
cullRect
)
)
;
surface
-
>
drawPicture
(
std
:
:
move
(
pic
)
)
;
}
return
surface
.
snap
(
)
;
}
FilterResult
FilterResult
:
:
MakeFromShader
(
const
Context
&
ctx
sk_sp
<
SkShader
>
shader
bool
dither
)
{
SkASSERT
(
shader
)
;
AutoSurface
surface
{
ctx
ctx
.
desiredOutput
(
)
PixelBoundary
:
:
kTransparent
true
}
;
if
(
surface
)
{
SkPaint
paint
;
paint
.
setShader
(
shader
)
;
paint
.
setDither
(
dither
)
;
surface
-
>
drawPaint
(
paint
)
;
}
return
surface
.
snap
(
)
;
}
FilterResult
FilterResult
:
:
MakeFromImage
(
const
Context
&
ctx
sk_sp
<
SkImage
>
image
SkRect
srcRect
ParameterSpace
<
SkRect
>
dstRect
const
SkSamplingOptions
&
sampling
)
{
SkASSERT
(
image
)
;
SkRect
imageBounds
=
SkRect
:
:
Make
(
image
-
>
dimensions
(
)
)
;
if
(
!
imageBounds
.
contains
(
srcRect
)
)
{
SkMatrix
srcToDst
=
SkMatrix
:
:
RectToRect
(
srcRect
SkRect
(
dstRect
)
)
;
if
(
!
srcRect
.
intersect
(
imageBounds
)
)
{
return
{
}
;
}
dstRect
=
ParameterSpace
<
SkRect
>
{
srcToDst
.
mapRect
(
srcRect
)
}
;
}
if
(
SkRect
(
dstRect
)
.
isEmpty
(
)
)
{
return
{
}
;
}
SkIRect
srcSubset
=
RoundOut
(
srcRect
)
;
if
(
SkRect
:
:
Make
(
srcSubset
)
=
=
srcRect
)
{
sk_sp
<
SkSpecialImage
>
specialImage
=
ctx
.
backend
(
)
-
>
makeImage
(
srcSubset
std
:
:
move
(
image
)
)
;
skif
:
:
FilterResult
subset
{
std
:
:
move
(
specialImage
)
skif
:
:
LayerSpace
<
SkIPoint
>
(
srcSubset
.
topLeft
(
)
)
}
;
SkMatrix
transform
=
SkMatrix
:
:
Concat
(
ctx
.
mapping
(
)
.
layerMatrix
(
)
SkMatrix
:
:
RectToRect
(
srcRect
SkRect
(
dstRect
)
)
)
;
return
subset
.
applyTransform
(
ctx
skif
:
:
LayerSpace
<
SkMatrix
>
(
transform
)
sampling
)
;
}
LayerSpace
<
SkIRect
>
dstBounds
=
ctx
.
mapping
(
)
.
paramToLayer
(
dstRect
)
.
roundOut
(
)
;
if
(
!
dstBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
AutoSurface
surface
{
ctx
dstBounds
PixelBoundary
:
:
kTransparent
true
}
;
if
(
surface
)
{
SkPaint
paint
;
paint
.
setAntiAlias
(
true
)
;
surface
-
>
drawImageRect
(
std
:
:
move
(
image
)
srcRect
SkRect
(
dstRect
)
sampling
&
paint
SkCanvas
:
:
kStrict_SrcRectConstraint
)
;
}
return
surface
.
snap
(
)
;
}
FilterResult
:
:
Builder
:
:
Builder
(
const
Context
&
context
)
:
fContext
(
context
)
{
}
FilterResult
:
:
Builder
:
:
~
Builder
(
)
=
default
;
SkSpan
<
sk_sp
<
SkShader
>
>
FilterResult
:
:
Builder
:
:
createInputShaders
(
const
LayerSpace
<
SkIRect
>
&
outputBounds
bool
evaluateInParameterSpace
)
{
SkEnumBitMask
<
ShaderFlags
>
xtraFlags
=
ShaderFlags
:
:
kNone
;
SkMatrix
layerToParam
;
if
(
evaluateInParameterSpace
)
{
SkAssertResult
(
fContext
.
mapping
(
)
.
layerMatrix
(
)
.
invert
(
&
layerToParam
)
)
;
if
(
!
is_nearly_integer_translation
(
LayerSpace
<
SkMatrix
>
(
layerToParam
)
)
)
{
xtraFlags
|
=
ShaderFlags
:
:
kNonTrivialSampling
;
}
}
fInputShaders
.
reserve
(
fInputs
.
size
(
)
)
;
for
(
const
SampledFilterResult
&
input
:
fInputs
)
{
auto
sampleBounds
=
input
.
fSampleBounds
?
*
input
.
fSampleBounds
:
outputBounds
;
auto
shader
=
input
.
fImage
.
asShader
(
fContext
input
.
fSampling
input
.
fFlags
|
xtraFlags
sampleBounds
)
;
if
(
evaluateInParameterSpace
&
&
shader
)
{
shader
=
shader
-
>
makeWithLocalMatrix
(
layerToParam
)
;
}
fInputShaders
.
push_back
(
std
:
:
move
(
shader
)
)
;
}
return
SkSpan
<
sk_sp
<
SkShader
>
>
(
fInputShaders
)
;
}
LayerSpace
<
SkIRect
>
FilterResult
:
:
Builder
:
:
outputBounds
(
std
:
:
optional
<
LayerSpace
<
SkIRect
>
>
explicitOutput
)
const
{
LayerSpace
<
SkIRect
>
output
=
fContext
.
desiredOutput
(
)
;
if
(
explicitOutput
.
has_value
(
)
)
{
if
(
!
output
.
intersect
(
*
explicitOutput
)
)
{
return
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
return
output
;
}
FilterResult
FilterResult
:
:
Builder
:
:
drawShader
(
sk_sp
<
SkShader
>
shader
const
LayerSpace
<
SkIRect
>
&
outputBounds
bool
evaluateInParameterSpace
)
const
{
SkASSERT
(
!
outputBounds
.
isEmpty
(
)
)
;
if
(
!
shader
)
{
return
{
}
;
}
AutoSurface
surface
{
fContext
outputBounds
PixelBoundary
:
:
kTransparent
evaluateInParameterSpace
}
;
if
(
surface
)
{
SkPaint
paint
;
paint
.
setShader
(
std
:
:
move
(
shader
)
)
;
surface
-
>
drawPaint
(
paint
)
;
}
return
surface
.
snap
(
)
;
}
FilterResult
FilterResult
:
:
Builder
:
:
merge
(
)
{
SkASSERT
(
!
fInputs
.
empty
(
)
)
;
if
(
fInputs
.
size
(
)
=
=
1
)
{
SkASSERT
(
!
fInputs
[
0
]
.
fSampleBounds
.
has_value
(
)
&
&
fInputs
[
0
]
.
fSampling
=
=
kDefaultSampling
&
&
fInputs
[
0
]
.
fFlags
=
=
ShaderFlags
:
:
kNone
)
;
return
fInputs
[
0
]
.
fImage
;
}
const
auto
mergedBounds
=
LayerSpace
<
SkIRect
>
:
:
Union
(
(
int
)
fInputs
.
size
(
)
[
this
]
(
int
i
)
{
return
fInputs
[
i
]
.
fImage
.
layerBounds
(
)
;
}
)
;
const
auto
outputBounds
=
this
-
>
outputBounds
(
mergedBounds
)
;
AutoSurface
surface
{
fContext
outputBounds
PixelBoundary
:
:
kTransparent
false
}
;
if
(
surface
)
{
for
(
const
SampledFilterResult
&
input
:
fInputs
)
{
SkASSERT
(
!
input
.
fSampleBounds
.
has_value
(
)
&
&
input
.
fSampling
=
=
kDefaultSampling
&
&
input
.
fFlags
=
=
ShaderFlags
:
:
kNone
)
;
input
.
fImage
.
draw
(
fContext
surface
.
device
(
)
true
)
;
}
}
return
surface
.
snap
(
)
;
}
FilterResult
FilterResult
:
:
Builder
:
:
blur
(
const
LayerSpace
<
SkSize
>
&
sigma
)
{
SkASSERT
(
fInputs
.
size
(
)
=
=
1
)
;
const
SkBlurEngine
*
blurEngine
=
fContext
.
backend
(
)
-
>
getBlurEngine
(
)
;
SkASSERT
(
blurEngine
)
;
const
SkBlurEngine
:
:
Algorithm
*
algorithm
=
blurEngine
-
>
findAlgorithm
(
SkSize
(
sigma
)
fContext
.
backend
(
)
-
>
colorType
(
)
)
;
if
(
!
algorithm
)
{
return
{
}
;
}
SkASSERT
(
sigma
.
width
(
)
<
=
algorithm
-
>
maxSigma
(
)
&
&
sigma
.
height
(
)
<
=
algorithm
-
>
maxSigma
(
)
)
;
skif
:
:
LayerSpace
<
SkISize
>
radii
=
LayerSpace
<
SkSize
>
(
{
3
.
f
*
sigma
.
width
(
)
3
.
f
*
sigma
.
height
(
)
}
)
.
ceil
(
)
;
auto
maxOutput
=
fInputs
[
0
]
.
fImage
.
layerBounds
(
)
;
maxOutput
.
outset
(
radii
)
;
const
auto
outputBounds
=
this
-
>
outputBounds
(
maxOutput
)
;
if
(
outputBounds
.
isEmpty
(
)
)
{
return
{
}
;
}
auto
sampleBounds
=
outputBounds
;
sampleBounds
.
outset
(
radii
)
;
FilterResult
resolved
=
fInputs
[
0
]
.
fImage
.
resolve
(
fContext
sampleBounds
)
;
if
(
!
resolved
)
{
return
{
}
;
}
auto
srcRelativeOutput
=
outputBounds
;
srcRelativeOutput
.
offset
(
-
resolved
.
layerBounds
(
)
.
topLeft
(
)
)
;
resolved
=
{
algorithm
-
>
blur
(
SkSize
(
sigma
)
resolved
.
fImage
SkIRect
:
:
MakeSize
(
resolved
.
fImage
-
>
dimensions
(
)
)
SkTileMode
:
:
kDecal
SkIRect
(
srcRelativeOutput
)
)
outputBounds
.
topLeft
(
)
}
;
return
resolved
;
}
}
