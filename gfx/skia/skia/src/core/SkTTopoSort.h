#
ifndef
SkTTopoSort_DEFINED
#
define
SkTTopoSort_DEFINED
#
include
"
SkTDArray
.
h
"
#
ifdef
SK_DEBUG
template
<
typename
T
typename
Traits
=
T
>
void
SkTTopoSort_CheckAllUnmarked
(
const
SkTDArray
<
T
*
>
&
graph
)
{
for
(
int
i
=
0
;
i
<
graph
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
graph
[
i
]
)
)
;
SkASSERT
(
!
Traits
:
:
WasOutput
(
graph
[
i
]
)
)
;
}
}
template
<
typename
T
typename
Traits
=
T
>
void
SkTTopoSort_CleanExit
(
const
SkTDArray
<
T
*
>
&
graph
)
{
for
(
int
i
=
0
;
i
<
graph
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
graph
[
i
]
)
)
;
SkASSERT
(
Traits
:
:
WasOutput
(
graph
[
i
]
)
)
;
}
}
#
endif
template
<
typename
T
typename
Traits
=
T
>
bool
SkTTopoSort_Visit
(
T
*
node
SkTDArray
<
T
*
>
*
result
)
{
if
(
Traits
:
:
IsTempMarked
(
node
)
)
{
return
false
;
}
if
(
!
Traits
:
:
WasOutput
(
node
)
)
{
Traits
:
:
SetTempMark
(
node
)
;
for
(
int
i
=
0
;
i
<
Traits
:
:
NumDependencies
(
node
)
;
+
+
i
)
{
if
(
!
SkTTopoSort_Visit
<
T
Traits
>
(
Traits
:
:
Dependency
(
node
i
)
result
)
)
{
return
false
;
}
}
Traits
:
:
Output
(
node
result
-
>
count
(
)
)
;
Traits
:
:
ResetTempMark
(
node
)
;
*
result
-
>
append
(
)
=
node
;
}
return
true
;
}
template
<
typename
T
typename
Traits
=
T
>
bool
SkTTopoSort
(
SkTDArray
<
T
*
>
*
graph
)
{
SkTDArray
<
T
*
>
result
;
#
ifdef
SK_DEBUG
SkTTopoSort_CheckAllUnmarked
<
T
Traits
>
(
*
graph
)
;
#
endif
result
.
setReserve
(
graph
-
>
count
(
)
)
;
for
(
int
i
=
0
;
i
<
graph
-
>
count
(
)
;
+
+
i
)
{
if
(
Traits
:
:
WasOutput
(
(
*
graph
)
[
i
]
)
)
{
continue
;
}
if
(
!
SkTTopoSort_Visit
<
T
Traits
>
(
(
*
graph
)
[
i
]
&
result
)
)
{
return
false
;
}
}
SkASSERT
(
graph
-
>
count
(
)
=
=
result
.
count
(
)
)
;
graph
-
>
swap
(
result
)
;
#
ifdef
SK_DEBUG
SkTTopoSort_CleanExit
<
T
Traits
>
(
*
graph
)
;
#
endif
return
true
;
}
#
endif
