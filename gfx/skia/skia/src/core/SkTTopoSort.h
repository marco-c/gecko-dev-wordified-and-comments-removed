#
ifndef
SkTTopoSort_DEFINED
#
define
SkTTopoSort_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
ifdef
SK_DEBUG
template
<
typename
T
typename
Traits
=
T
>
void
SkTTopoSort_CheckAllUnmarked
(
const
SkTArray
<
sk_sp
<
T
>
>
&
graph
)
{
for
(
int
i
=
0
;
i
<
graph
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
graph
[
i
]
.
get
(
)
)
)
;
SkASSERT
(
!
Traits
:
:
WasOutput
(
graph
[
i
]
.
get
(
)
)
)
;
}
}
template
<
typename
T
typename
Traits
=
T
>
void
SkTTopoSort_CleanExit
(
const
SkTArray
<
sk_sp
<
T
>
>
&
graph
)
{
for
(
int
i
=
0
;
i
<
graph
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
graph
[
i
]
.
get
(
)
)
)
;
SkASSERT
(
Traits
:
:
WasOutput
(
graph
[
i
]
.
get
(
)
)
)
;
}
}
#
endif
template
<
typename
T
typename
Traits
=
T
>
bool
SkTTopoSort_Visit
(
T
*
node
SkTArray
<
sk_sp
<
T
>
>
*
result
)
{
if
(
Traits
:
:
IsTempMarked
(
node
)
)
{
return
false
;
}
if
(
!
Traits
:
:
WasOutput
(
node
)
)
{
Traits
:
:
SetTempMark
(
node
)
;
for
(
int
i
=
0
;
i
<
Traits
:
:
NumDependencies
(
node
)
;
+
+
i
)
{
if
(
!
SkTTopoSort_Visit
<
T
Traits
>
(
Traits
:
:
Dependency
(
node
i
)
result
)
)
{
return
false
;
}
}
Traits
:
:
Output
(
node
result
-
>
count
(
)
)
;
Traits
:
:
ResetTempMark
(
node
)
;
result
-
>
push_back
(
sk_ref_sp
(
node
)
)
;
}
return
true
;
}
template
<
typename
T
typename
Traits
=
T
>
bool
SkTTopoSort
(
SkTArray
<
sk_sp
<
T
>
>
*
graph
)
{
SkTArray
<
sk_sp
<
T
>
>
result
;
#
ifdef
SK_DEBUG
SkTTopoSort_CheckAllUnmarked
<
T
Traits
>
(
*
graph
)
;
#
endif
result
.
reserve
(
graph
-
>
count
(
)
)
;
for
(
int
i
=
0
;
i
<
graph
-
>
count
(
)
;
+
+
i
)
{
if
(
Traits
:
:
WasOutput
(
(
*
graph
)
[
i
]
.
get
(
)
)
)
{
continue
;
}
if
(
!
SkTTopoSort_Visit
<
T
Traits
>
(
(
*
graph
)
[
i
]
.
get
(
)
&
result
)
)
{
return
false
;
}
}
SkASSERT
(
graph
-
>
count
(
)
=
=
result
.
count
(
)
)
;
graph
-
>
swap
(
result
)
;
#
ifdef
SK_DEBUG
SkTTopoSort_CleanExit
<
T
Traits
>
(
*
graph
)
;
#
endif
return
true
;
}
#
endif
