#
include
"
SkBitmapScaler
.
h
"
#
include
"
SkBitmapFilter
.
h
"
#
include
"
SkConvolver
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkPixmap
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkTArray
.
h
"
class
SkResizeFilter
{
public
:
SkResizeFilter
(
SkBitmapScaler
:
:
ResizeMethod
method
int
srcFullWidth
int
srcFullHeight
float
destWidth
float
destHeight
const
SkRect
&
destSubset
const
SkConvolutionProcs
&
convolveProcs
)
;
~
SkResizeFilter
(
)
{
delete
fBitmapFilter
;
}
const
SkConvolutionFilter1D
&
xFilter
(
)
{
return
fXFilter
;
}
const
SkConvolutionFilter1D
&
yFilter
(
)
{
return
fYFilter
;
}
private
:
SkBitmapFilter
*
fBitmapFilter
;
void
computeFilters
(
int
srcSize
float
destSubsetLo
float
destSubsetSize
float
scale
SkConvolutionFilter1D
*
output
const
SkConvolutionProcs
&
convolveProcs
)
;
SkConvolutionFilter1D
fXFilter
;
SkConvolutionFilter1D
fYFilter
;
}
;
SkResizeFilter
:
:
SkResizeFilter
(
SkBitmapScaler
:
:
ResizeMethod
method
int
srcFullWidth
int
srcFullHeight
float
destWidth
float
destHeight
const
SkRect
&
destSubset
const
SkConvolutionProcs
&
convolveProcs
)
{
SkASSERT
(
method
>
=
SkBitmapScaler
:
:
RESIZE_FirstMethod
&
&
method
<
=
SkBitmapScaler
:
:
RESIZE_LastMethod
)
;
fBitmapFilter
=
nullptr
;
switch
(
method
)
{
case
SkBitmapScaler
:
:
RESIZE_BOX
:
fBitmapFilter
=
new
SkBoxFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_TRIANGLE
:
fBitmapFilter
=
new
SkTriangleFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_MITCHELL
:
fBitmapFilter
=
new
SkMitchellFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_HAMMING
:
fBitmapFilter
=
new
SkHammingFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_LANCZOS3
:
fBitmapFilter
=
new
SkLanczosFilter
;
break
;
}
float
scaleX
=
destWidth
/
srcFullWidth
;
float
scaleY
=
destHeight
/
srcFullHeight
;
this
-
>
computeFilters
(
srcFullWidth
destSubset
.
fLeft
destSubset
.
width
(
)
scaleX
&
fXFilter
convolveProcs
)
;
if
(
srcFullWidth
=
=
srcFullHeight
&
&
destSubset
.
fLeft
=
=
destSubset
.
fTop
&
&
destSubset
.
width
(
)
=
=
destSubset
.
height
(
)
&
&
scaleX
=
=
scaleY
)
{
fYFilter
=
fXFilter
;
}
else
{
this
-
>
computeFilters
(
srcFullHeight
destSubset
.
fTop
destSubset
.
height
(
)
scaleY
&
fYFilter
convolveProcs
)
;
}
}
void
SkResizeFilter
:
:
computeFilters
(
int
srcSize
float
destSubsetLo
float
destSubsetSize
float
scale
SkConvolutionFilter1D
*
output
const
SkConvolutionProcs
&
convolveProcs
)
{
float
destSubsetHi
=
destSubsetLo
+
destSubsetSize
;
float
clampedScale
=
SkTMin
(
1
.
0f
scale
)
;
float
srcSupport
=
fBitmapFilter
-
>
width
(
)
/
clampedScale
;
float
invScale
=
1
.
0f
/
scale
;
SkSTArray
<
64
float
true
>
filterValuesArray
;
SkSTArray
<
64
SkConvolutionFilter1D
:
:
ConvolutionFixed
true
>
fixedFilterValuesArray
;
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
int
destLimit
=
SkScalarTruncToInt
(
SkScalarCeilToScalar
(
destSubsetHi
)
-
SkScalarFloorToScalar
(
destSubsetLo
)
)
;
#
else
destSubsetLo
=
SkScalarFloorToScalar
(
destSubsetLo
)
;
destSubsetHi
=
SkScalarCeilToScalar
(
destSubsetHi
)
;
float
srcPixel
=
(
destSubsetLo
+
0
.
5f
)
*
invScale
;
int
destLimit
=
SkScalarTruncToInt
(
destSubsetHi
-
destSubsetLo
)
;
#
endif
output
-
>
reserveAdditional
(
destLimit
SkScalarCeilToInt
(
destLimit
*
srcSupport
*
2
)
)
;
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
for
(
int
destSubsetI
=
SkScalarFloorToInt
(
destSubsetLo
)
;
destSubsetI
<
SkScalarCeilToInt
(
destSubsetHi
)
;
destSubsetI
+
+
)
#
else
for
(
int
destI
=
0
;
destI
<
destLimit
;
srcPixel
+
=
invScale
destI
+
+
)
#
endif
{
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
float
srcPixel
=
(
static_cast
<
float
>
(
destSubsetI
)
+
0
.
5f
)
*
invScale
;
int
srcBegin
=
SkTMax
(
0
SkScalarFloorToInt
(
srcPixel
-
srcSupport
)
)
;
int
srcEnd
=
SkTMin
(
srcSize
-
1
SkScalarCeilToInt
(
srcPixel
+
srcSupport
)
)
;
#
else
float
srcBegin
=
SkTMax
(
0
.
f
SkScalarFloorToScalar
(
srcPixel
-
srcSupport
)
)
;
float
srcEnd
=
SkTMin
(
srcSize
-
1
.
f
SkScalarCeilToScalar
(
srcPixel
+
srcSupport
)
)
;
#
endif
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
float
filterSum
=
0
.
0f
;
int
filterCount
=
srcEnd
-
srcBegin
+
1
;
filterValuesArray
.
reset
(
filterCount
)
;
for
(
int
curFilterPixel
=
srcBegin
;
curFilterPixel
<
=
srcEnd
;
curFilterPixel
+
+
)
{
#
endif
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
float
srcFilterDist
=
(
(
static_cast
<
float
>
(
curFilterPixel
)
+
0
.
5f
)
-
srcPixel
)
;
float
destFilterDist
=
srcFilterDist
*
clampedScale
;
float
filterValue
=
fBitmapFilter
-
>
evaluate
(
destFilterDist
)
;
filterValuesArray
[
curFilterPixel
-
srcBegin
]
=
filterValue
;
filterSum
+
=
filterValue
;
}
#
else
float
destFilterDist
=
(
srcBegin
+
0
.
5f
-
srcPixel
)
*
clampedScale
;
int
filterCount
=
SkScalarTruncToInt
(
srcEnd
-
srcBegin
)
+
1
;
SkASSERT
(
filterCount
>
0
)
;
filterValuesArray
.
reset
(
filterCount
)
;
float
filterSum
=
fBitmapFilter
-
>
evaluate_n
(
destFilterDist
clampedScale
filterCount
filterValuesArray
.
begin
(
)
)
;
#
endif
int
fixedSum
=
0
;
fixedFilterValuesArray
.
reset
(
filterCount
)
;
const
float
*
filterValues
=
filterValuesArray
.
begin
(
)
;
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
fixedFilterValues
=
fixedFilterValuesArray
.
begin
(
)
;
#
ifndef
SK_SUPPORT_LEGACY_BITMAP_FILTER
float
invFilterSum
=
1
/
filterSum
;
#
endif
for
(
int
fixedI
=
0
;
fixedI
<
filterCount
;
fixedI
+
+
)
{
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
int
curFixed
=
SkConvolutionFilter1D
:
:
FloatToFixed
(
filterValues
[
fixedI
]
/
filterSum
)
;
#
else
int
curFixed
=
SkConvolutionFilter1D
:
:
FloatToFixed
(
filterValues
[
fixedI
]
*
invFilterSum
)
;
#
endif
fixedSum
+
=
curFixed
;
fixedFilterValues
[
fixedI
]
=
SkToS16
(
curFixed
)
;
}
SkASSERT
(
fixedSum
<
=
0x7FFF
)
;
int
leftovers
=
SkConvolutionFilter1D
:
:
FloatToFixed
(
1
)
-
fixedSum
;
fixedFilterValues
[
filterCount
/
2
]
+
=
leftovers
;
#
ifdef
SK_SUPPORT_LEGACY_BITMAP_FILTER
output
-
>
AddFilter
(
srcBegin
fixedFilterValues
filterCount
)
;
#
else
output
-
>
AddFilter
(
SkScalarFloorToInt
(
srcBegin
)
fixedFilterValues
filterCount
)
;
#
endif
}
if
(
convolveProcs
.
fApplySIMDPadding
)
{
convolveProcs
.
fApplySIMDPadding
(
output
)
;
}
}
static
bool
valid_for_resize
(
const
SkPixmap
&
source
int
dstW
int
dstH
)
{
return
source
.
addr
(
)
&
&
source
.
colorType
(
)
=
=
kN32_SkColorType
&
&
source
.
width
(
)
>
=
1
&
&
source
.
height
(
)
>
=
1
&
&
dstW
>
=
1
&
&
dstH
>
=
1
;
}
bool
SkBitmapScaler
:
:
Resize
(
const
SkPixmap
&
result
const
SkPixmap
&
source
ResizeMethod
method
)
{
if
(
!
valid_for_resize
(
source
result
.
width
(
)
result
.
height
(
)
)
)
{
return
false
;
}
if
(
!
result
.
addr
(
)
|
|
result
.
colorType
(
)
!
=
source
.
colorType
(
)
)
{
return
false
;
}
SkConvolutionProcs
convolveProcs
=
{
0
nullptr
nullptr
nullptr
nullptr
}
;
PlatformConvolutionProcs
(
&
convolveProcs
)
;
SkRect
destSubset
=
SkRect
:
:
MakeIWH
(
result
.
width
(
)
result
.
height
(
)
)
;
SkResizeFilter
filter
(
method
source
.
width
(
)
source
.
height
(
)
result
.
width
(
)
result
.
height
(
)
destSubset
convolveProcs
)
;
const
uint8_t
*
sourceSubset
=
reinterpret_cast
<
const
uint8_t
*
>
(
source
.
addr
(
)
)
;
return
BGRAConvolve2D
(
sourceSubset
static_cast
<
int
>
(
source
.
rowBytes
(
)
)
!
source
.
isOpaque
(
)
filter
.
xFilter
(
)
filter
.
yFilter
(
)
static_cast
<
int
>
(
result
.
rowBytes
(
)
)
static_cast
<
unsigned
char
*
>
(
result
.
writable_addr
(
)
)
convolveProcs
true
)
;
}
bool
SkBitmapScaler
:
:
Resize
(
SkBitmap
*
resultPtr
const
SkPixmap
&
source
ResizeMethod
method
int
destWidth
int
destHeight
SkBitmap
:
:
Allocator
*
allocator
)
{
if
(
!
valid_for_resize
(
source
destWidth
destHeight
)
)
{
return
false
;
}
SkBitmap
result
;
result
.
setInfo
(
SkImageInfo
:
:
MakeN32
(
destWidth
destHeight
source
.
alphaType
(
)
)
)
;
result
.
allocPixels
(
allocator
nullptr
)
;
SkPixmap
resultPM
;
if
(
!
result
.
peekPixels
(
&
resultPM
)
|
|
!
Resize
(
resultPM
source
method
)
)
{
return
false
;
}
*
resultPtr
=
result
;
resultPtr
-
>
lockPixels
(
)
;
SkASSERT
(
resultPtr
-
>
getPixels
(
)
)
;
return
true
;
}
