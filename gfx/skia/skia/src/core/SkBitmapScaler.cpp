#
include
"
SkBitmapScaler
.
h
"
#
include
"
SkBitmapFilter
.
h
"
#
include
"
SkConvolver
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkPixmap
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkScalar
.
h
"
#
include
"
SkTArray
.
h
"
class
SkResizeFilter
{
public
:
SkResizeFilter
(
SkBitmapScaler
:
:
ResizeMethod
method
int
srcFullWidth
int
srcFullHeight
float
destWidth
float
destHeight
const
SkRect
&
destSubset
const
SkConvolutionProcs
&
convolveProcs
)
;
~
SkResizeFilter
(
)
{
delete
fBitmapFilter
;
}
const
SkConvolutionFilter1D
&
xFilter
(
)
{
return
fXFilter
;
}
const
SkConvolutionFilter1D
&
yFilter
(
)
{
return
fYFilter
;
}
private
:
SkBitmapFilter
*
fBitmapFilter
;
void
computeFilters
(
int
srcSize
float
destSubsetLo
float
destSubsetSize
float
scale
SkConvolutionFilter1D
*
output
const
SkConvolutionProcs
&
convolveProcs
)
;
SkConvolutionFilter1D
fXFilter
;
SkConvolutionFilter1D
fYFilter
;
}
;
SkResizeFilter
:
:
SkResizeFilter
(
SkBitmapScaler
:
:
ResizeMethod
method
int
srcFullWidth
int
srcFullHeight
float
destWidth
float
destHeight
const
SkRect
&
destSubset
const
SkConvolutionProcs
&
convolveProcs
)
{
SkASSERT
(
method
>
=
SkBitmapScaler
:
:
RESIZE_FirstMethod
&
&
method
<
=
SkBitmapScaler
:
:
RESIZE_LastMethod
)
;
fBitmapFilter
=
nullptr
;
switch
(
method
)
{
case
SkBitmapScaler
:
:
RESIZE_BOX
:
fBitmapFilter
=
new
SkBoxFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_TRIANGLE
:
fBitmapFilter
=
new
SkTriangleFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_MITCHELL
:
fBitmapFilter
=
new
SkMitchellFilter
(
1
.
f
/
3
.
f
1
.
f
/
3
.
f
)
;
break
;
case
SkBitmapScaler
:
:
RESIZE_HAMMING
:
fBitmapFilter
=
new
SkHammingFilter
;
break
;
case
SkBitmapScaler
:
:
RESIZE_LANCZOS3
:
fBitmapFilter
=
new
SkLanczosFilter
;
break
;
}
float
scaleX
=
destWidth
/
srcFullWidth
;
float
scaleY
=
destHeight
/
srcFullHeight
;
this
-
>
computeFilters
(
srcFullWidth
destSubset
.
fLeft
destSubset
.
width
(
)
scaleX
&
fXFilter
convolveProcs
)
;
if
(
srcFullWidth
=
=
srcFullHeight
&
&
destSubset
.
fLeft
=
=
destSubset
.
fTop
&
&
destSubset
.
width
(
)
=
=
destSubset
.
height
(
)
&
&
scaleX
=
=
scaleY
)
{
fYFilter
=
fXFilter
;
}
else
{
this
-
>
computeFilters
(
srcFullHeight
destSubset
.
fTop
destSubset
.
height
(
)
scaleY
&
fYFilter
convolveProcs
)
;
}
}
void
SkResizeFilter
:
:
computeFilters
(
int
srcSize
float
destSubsetLo
float
destSubsetSize
float
scale
SkConvolutionFilter1D
*
output
const
SkConvolutionProcs
&
convolveProcs
)
{
float
destSubsetHi
=
destSubsetLo
+
destSubsetSize
;
float
clampedScale
=
SkTMin
(
1
.
0f
scale
)
;
float
srcSupport
=
fBitmapFilter
-
>
width
(
)
/
clampedScale
;
float
invScale
=
1
.
0f
/
scale
;
SkTArray
<
float
>
filterValues
(
64
)
;
SkTArray
<
short
>
fixedFilterValues
(
64
)
;
for
(
int
destSubsetI
=
SkScalarFloorToInt
(
destSubsetLo
)
;
destSubsetI
<
SkScalarCeilToInt
(
destSubsetHi
)
;
destSubsetI
+
+
)
{
filterValues
.
reset
(
)
;
fixedFilterValues
.
reset
(
)
;
float
srcPixel
=
(
static_cast
<
float
>
(
destSubsetI
)
+
0
.
5f
)
*
invScale
;
int
srcBegin
=
SkTMax
(
0
SkScalarFloorToInt
(
srcPixel
-
srcSupport
)
)
;
int
srcEnd
=
SkTMin
(
srcSize
-
1
SkScalarCeilToInt
(
srcPixel
+
srcSupport
)
)
;
float
filterSum
=
0
.
0f
;
for
(
int
curFilterPixel
=
srcBegin
;
curFilterPixel
<
=
srcEnd
;
curFilterPixel
+
+
)
{
float
srcFilterDist
=
(
(
static_cast
<
float
>
(
curFilterPixel
)
+
0
.
5f
)
-
srcPixel
)
;
float
destFilterDist
=
srcFilterDist
*
clampedScale
;
float
filterValue
=
fBitmapFilter
-
>
evaluate
(
destFilterDist
)
;
filterValues
.
push_back
(
filterValue
)
;
filterSum
+
=
filterValue
;
}
SkASSERT
(
!
filterValues
.
empty
(
)
)
;
short
fixedSum
=
0
;
for
(
int
i
=
0
;
i
<
filterValues
.
count
(
)
;
i
+
+
)
{
short
curFixed
=
output
-
>
FloatToFixed
(
filterValues
[
i
]
/
filterSum
)
;
fixedSum
+
=
curFixed
;
fixedFilterValues
.
push_back
(
curFixed
)
;
}
short
leftovers
=
output
-
>
FloatToFixed
(
1
.
0f
)
-
fixedSum
;
fixedFilterValues
[
fixedFilterValues
.
count
(
)
/
2
]
+
=
leftovers
;
output
-
>
AddFilter
(
srcBegin
&
fixedFilterValues
[
0
]
static_cast
<
int
>
(
fixedFilterValues
.
count
(
)
)
)
;
}
if
(
convolveProcs
.
fApplySIMDPadding
)
{
convolveProcs
.
fApplySIMDPadding
(
output
)
;
}
}
bool
SkBitmapScaler
:
:
Resize
(
SkBitmap
*
resultPtr
const
SkPixmap
&
source
ResizeMethod
method
int
destWidth
int
destHeight
SkBitmap
:
:
Allocator
*
allocator
)
{
if
(
nullptr
=
=
source
.
addr
(
)
|
|
source
.
colorType
(
)
!
=
kN32_SkColorType
|
|
source
.
width
(
)
<
1
|
|
source
.
height
(
)
<
1
)
{
return
false
;
}
if
(
destWidth
<
1
|
|
destHeight
<
1
)
{
return
false
;
}
SkConvolutionProcs
convolveProcs
=
{
0
nullptr
nullptr
nullptr
nullptr
}
;
PlatformConvolutionProcs
(
&
convolveProcs
)
;
SkRect
destSubset
=
SkRect
:
:
MakeIWH
(
destWidth
destHeight
)
;
SkResizeFilter
filter
(
method
source
.
width
(
)
source
.
height
(
)
destWidth
destHeight
destSubset
convolveProcs
)
;
const
uint8_t
*
sourceSubset
=
reinterpret_cast
<
const
uint8_t
*
>
(
source
.
addr
(
)
)
;
SkBitmap
result
;
result
.
setInfo
(
SkImageInfo
:
:
MakeN32
(
SkScalarCeilToInt
(
destSubset
.
width
(
)
)
SkScalarCeilToInt
(
destSubset
.
height
(
)
)
source
.
alphaType
(
)
)
)
;
result
.
allocPixels
(
allocator
nullptr
)
;
if
(
!
result
.
readyToDraw
(
)
)
{
return
false
;
}
if
(
!
BGRAConvolve2D
(
sourceSubset
static_cast
<
int
>
(
source
.
rowBytes
(
)
)
!
source
.
isOpaque
(
)
filter
.
xFilter
(
)
filter
.
yFilter
(
)
static_cast
<
int
>
(
result
.
rowBytes
(
)
)
static_cast
<
unsigned
char
*
>
(
result
.
getPixels
(
)
)
convolveProcs
true
)
)
{
return
false
;
}
*
resultPtr
=
result
;
resultPtr
-
>
lockPixels
(
)
;
SkASSERT
(
resultPtr
-
>
getPixels
(
)
)
;
return
true
;
}
