#
include
"
SkXfermode
.
h
"
#
include
"
SkXfermode_proccoeff
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkMathPriv
.
h
"
#
include
"
SkOncePtr
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkString
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
define
SkAlphaMulAlpha
(
a
b
)
SkMulDiv255Round
(
a
b
)
static
inline
unsigned
saturated_add
(
unsigned
a
unsigned
b
)
{
SkASSERT
(
a
<
=
255
)
;
SkASSERT
(
b
<
=
255
)
;
unsigned
sum
=
a
+
b
;
if
(
sum
>
255
)
{
sum
=
255
;
}
return
sum
;
}
static
inline
int
clamp_signed_byte
(
int
n
)
{
if
(
n
<
0
)
{
n
=
0
;
}
else
if
(
n
>
255
)
{
n
=
255
;
}
return
n
;
}
static
inline
int
clamp_div255round
(
int
prod
)
{
if
(
prod
<
=
0
)
{
return
0
;
}
else
if
(
prod
>
=
255
*
255
)
{
return
255
;
}
else
{
return
SkDiv255Round
(
prod
)
;
}
}
static
SkPMColor
clear_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
0
;
}
static
SkPMColor
src_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
src
;
}
static
SkPMColor
dst_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
dst
;
}
static
SkPMColor
srcover_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
#
if
0
return
src
+
SkAlphaMulQ
(
dst
SkAlpha255To256
(
255
-
SkGetPackedA32
(
src
)
)
)
;
#
else
return
src
+
SkAlphaMulQ
(
dst
256
-
SkGetPackedA32
(
src
)
)
;
#
endif
}
static
SkPMColor
dstover_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
dst
+
SkAlphaMulQ
(
src
256
-
SkGetPackedA32
(
dst
)
)
;
}
static
SkPMColor
srcin_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
SkAlphaMulQ
(
src
SkAlpha255To256
(
SkGetPackedA32
(
dst
)
)
)
;
}
static
SkPMColor
dstin_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
SkAlphaMulQ
(
dst
SkAlpha255To256
(
SkGetPackedA32
(
src
)
)
)
;
}
static
SkPMColor
srcout_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
SkAlphaMulQ
(
src
SkAlpha255To256
(
255
-
SkGetPackedA32
(
dst
)
)
)
;
}
static
SkPMColor
dstout_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
return
SkAlphaMulQ
(
dst
SkAlpha255To256
(
255
-
SkGetPackedA32
(
src
)
)
)
;
}
static
SkPMColor
srcatop_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
unsigned
sa
=
SkGetPackedA32
(
src
)
;
unsigned
da
=
SkGetPackedA32
(
dst
)
;
unsigned
isa
=
255
-
sa
;
return
SkPackARGB32
(
da
SkAlphaMulAlpha
(
da
SkGetPackedR32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedR32
(
dst
)
)
SkAlphaMulAlpha
(
da
SkGetPackedG32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedG32
(
dst
)
)
SkAlphaMulAlpha
(
da
SkGetPackedB32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedB32
(
dst
)
)
)
;
}
static
SkPMColor
dstatop_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
unsigned
sa
=
SkGetPackedA32
(
src
)
;
unsigned
da
=
SkGetPackedA32
(
dst
)
;
unsigned
ida
=
255
-
da
;
return
SkPackARGB32
(
sa
SkAlphaMulAlpha
(
ida
SkGetPackedR32
(
src
)
)
+
SkAlphaMulAlpha
(
sa
SkGetPackedR32
(
dst
)
)
SkAlphaMulAlpha
(
ida
SkGetPackedG32
(
src
)
)
+
SkAlphaMulAlpha
(
sa
SkGetPackedG32
(
dst
)
)
SkAlphaMulAlpha
(
ida
SkGetPackedB32
(
src
)
)
+
SkAlphaMulAlpha
(
sa
SkGetPackedB32
(
dst
)
)
)
;
}
static
SkPMColor
xor_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
unsigned
sa
=
SkGetPackedA32
(
src
)
;
unsigned
da
=
SkGetPackedA32
(
dst
)
;
unsigned
isa
=
255
-
sa
;
unsigned
ida
=
255
-
da
;
return
SkPackARGB32
(
sa
+
da
-
(
SkAlphaMulAlpha
(
sa
da
)
<
<
1
)
SkAlphaMulAlpha
(
ida
SkGetPackedR32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedR32
(
dst
)
)
SkAlphaMulAlpha
(
ida
SkGetPackedG32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedG32
(
dst
)
)
SkAlphaMulAlpha
(
ida
SkGetPackedB32
(
src
)
)
+
SkAlphaMulAlpha
(
isa
SkGetPackedB32
(
dst
)
)
)
;
}
static
SkPMColor
plus_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
unsigned
b
=
saturated_add
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
)
;
unsigned
g
=
saturated_add
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
)
;
unsigned
r
=
saturated_add
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
)
;
unsigned
a
=
saturated_add
(
SkGetPackedA32
(
src
)
SkGetPackedA32
(
dst
)
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SkPMColor
modulate_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
a
=
SkAlphaMulAlpha
(
SkGetPackedA32
(
src
)
SkGetPackedA32
(
dst
)
)
;
int
r
=
SkAlphaMulAlpha
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
)
;
int
g
=
SkAlphaMulAlpha
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
)
;
int
b
=
SkAlphaMulAlpha
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
srcover_byte
(
int
a
int
b
)
{
return
a
+
b
-
SkAlphaMulAlpha
(
a
b
)
;
}
static
int
blendfunc_multiply_byte
(
int
sc
int
dc
int
sa
int
da
)
{
return
clamp_div255round
(
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
+
sc
*
dc
)
;
}
static
SkPMColor
multiply_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
blendfunc_multiply_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
blendfunc_multiply_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
blendfunc_multiply_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SkPMColor
screen_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
a
=
srcover_byte
(
SkGetPackedA32
(
src
)
SkGetPackedA32
(
dst
)
)
;
int
r
=
srcover_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
)
;
int
g
=
srcover_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
)
;
int
b
=
srcover_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
overlay_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
tmp
=
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
;
int
rc
;
if
(
2
*
dc
<
=
da
)
{
rc
=
2
*
sc
*
dc
;
}
else
{
rc
=
sa
*
da
-
2
*
(
da
-
dc
)
*
(
sa
-
sc
)
;
}
return
clamp_div255round
(
rc
+
tmp
)
;
}
static
SkPMColor
overlay_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
overlay_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
overlay_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
overlay_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
darken_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
sd
=
sc
*
da
;
int
ds
=
dc
*
sa
;
if
(
sd
<
ds
)
{
return
sc
+
dc
-
SkDiv255Round
(
ds
)
;
}
else
{
return
dc
+
sc
-
SkDiv255Round
(
sd
)
;
}
}
static
SkPMColor
darken_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
darken_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
darken_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
darken_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
lighten_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
sd
=
sc
*
da
;
int
ds
=
dc
*
sa
;
if
(
sd
>
ds
)
{
return
sc
+
dc
-
SkDiv255Round
(
ds
)
;
}
else
{
return
dc
+
sc
-
SkDiv255Round
(
sd
)
;
}
}
static
SkPMColor
lighten_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
lighten_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
lighten_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
lighten_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
colordodge_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
diff
=
sa
-
sc
;
int
rc
;
if
(
0
=
=
dc
)
{
return
SkAlphaMulAlpha
(
sc
255
-
da
)
;
}
else
if
(
0
=
=
diff
)
{
rc
=
sa
*
da
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
;
}
else
{
diff
=
dc
*
sa
/
diff
;
rc
=
sa
*
(
(
da
<
diff
)
?
da
:
diff
)
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
;
}
return
clamp_div255round
(
rc
)
;
}
static
SkPMColor
colordodge_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
colordodge_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
colordodge_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
colordodge_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
colorburn_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
rc
;
if
(
dc
=
=
da
)
{
rc
=
sa
*
da
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
;
}
else
if
(
0
=
=
sc
)
{
return
SkAlphaMulAlpha
(
dc
255
-
sa
)
;
}
else
{
int
tmp
=
(
da
-
dc
)
*
sa
/
sc
;
rc
=
sa
*
(
da
-
(
(
da
<
tmp
)
?
da
:
tmp
)
)
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
;
}
return
clamp_div255round
(
rc
)
;
}
static
SkPMColor
colorburn_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
colorburn_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
colorburn_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
colorburn_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
hardlight_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
rc
;
if
(
2
*
sc
<
=
sa
)
{
rc
=
2
*
sc
*
dc
;
}
else
{
rc
=
sa
*
da
-
2
*
(
da
-
dc
)
*
(
sa
-
sc
)
;
}
return
clamp_div255round
(
rc
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
)
;
}
static
SkPMColor
hardlight_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
hardlight_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
hardlight_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
hardlight_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
U8CPU
sqrt_unit_byte
(
U8CPU
n
)
{
return
SkSqrtBits
(
n
15
+
4
)
;
}
static
inline
int
softlight_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
m
=
da
?
dc
*
256
/
da
:
0
;
int
rc
;
if
(
2
*
sc
<
=
sa
)
{
rc
=
dc
*
(
sa
+
(
(
2
*
sc
-
sa
)
*
(
256
-
m
)
>
>
8
)
)
;
}
else
if
(
4
*
dc
<
=
da
)
{
int
tmp
=
(
4
*
m
*
(
4
*
m
+
256
)
*
(
m
-
256
)
>
>
16
)
+
7
*
m
;
rc
=
dc
*
sa
+
(
da
*
(
2
*
sc
-
sa
)
*
tmp
>
>
8
)
;
}
else
{
int
tmp
=
sqrt_unit_byte
(
m
)
-
m
;
rc
=
dc
*
sa
+
(
da
*
(
2
*
sc
-
sa
)
*
tmp
>
>
8
)
;
}
return
clamp_div255round
(
rc
+
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
)
;
}
static
SkPMColor
softlight_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
softlight_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
softlight_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
softlight_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
difference_byte
(
int
sc
int
dc
int
sa
int
da
)
{
int
tmp
=
SkMin32
(
sc
*
da
dc
*
sa
)
;
return
clamp_signed_byte
(
sc
+
dc
-
2
*
SkDiv255Round
(
tmp
)
)
;
}
static
SkPMColor
difference_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
difference_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
difference_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
difference_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
exclusion_byte
(
int
sc
int
dc
int
int
)
{
int
r
=
255
*
(
sc
+
dc
)
-
2
*
sc
*
dc
;
return
clamp_div255round
(
r
)
;
}
static
SkPMColor
exclusion_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sa
=
SkGetPackedA32
(
src
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
exclusion_byte
(
SkGetPackedR32
(
src
)
SkGetPackedR32
(
dst
)
sa
da
)
;
int
g
=
exclusion_byte
(
SkGetPackedG32
(
src
)
SkGetPackedG32
(
dst
)
sa
da
)
;
int
b
=
exclusion_byte
(
SkGetPackedB32
(
src
)
SkGetPackedB32
(
dst
)
sa
da
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
inline
int
Lum
(
int
r
int
g
int
b
)
{
return
SkDiv255Round
(
r
*
77
+
g
*
150
+
b
*
28
)
;
}
static
inline
int
min2
(
int
a
int
b
)
{
return
a
<
b
?
a
:
b
;
}
static
inline
int
max2
(
int
a
int
b
)
{
return
a
>
b
?
a
:
b
;
}
#
define
minimum
(
a
b
c
)
min2
(
min2
(
a
b
)
c
)
#
define
maximum
(
a
b
c
)
max2
(
max2
(
a
b
)
c
)
static
inline
int
Sat
(
int
r
int
g
int
b
)
{
return
maximum
(
r
g
b
)
-
minimum
(
r
g
b
)
;
}
static
inline
void
setSaturationComponents
(
int
*
Cmin
int
*
Cmid
int
*
Cmax
int
s
)
{
if
(
*
Cmax
>
*
Cmin
)
{
*
Cmid
=
SkMulDiv
(
*
Cmid
-
*
Cmin
s
*
Cmax
-
*
Cmin
)
;
*
Cmax
=
s
;
}
else
{
*
Cmax
=
0
;
*
Cmid
=
0
;
}
*
Cmin
=
0
;
}
static
inline
void
SetSat
(
int
*
r
int
*
g
int
*
b
int
s
)
{
if
(
*
r
<
=
*
g
)
{
if
(
*
g
<
=
*
b
)
{
setSaturationComponents
(
r
g
b
s
)
;
}
else
if
(
*
r
<
=
*
b
)
{
setSaturationComponents
(
r
b
g
s
)
;
}
else
{
setSaturationComponents
(
b
r
g
s
)
;
}
}
else
if
(
*
r
<
=
*
b
)
{
setSaturationComponents
(
g
r
b
s
)
;
}
else
if
(
*
g
<
=
*
b
)
{
setSaturationComponents
(
g
b
r
s
)
;
}
else
{
setSaturationComponents
(
b
g
r
s
)
;
}
}
static
inline
void
clipColor
(
int
*
r
int
*
g
int
*
b
int
a
)
{
int
L
=
Lum
(
*
r
*
g
*
b
)
;
int
n
=
minimum
(
*
r
*
g
*
b
)
;
int
x
=
maximum
(
*
r
*
g
*
b
)
;
int
denom
;
if
(
(
n
<
0
)
&
&
(
denom
=
L
-
n
)
)
{
*
r
=
L
+
SkMulDiv
(
*
r
-
L
L
denom
)
;
*
g
=
L
+
SkMulDiv
(
*
g
-
L
L
denom
)
;
*
b
=
L
+
SkMulDiv
(
*
b
-
L
L
denom
)
;
}
if
(
(
x
>
a
)
&
&
(
denom
=
x
-
L
)
)
{
int
numer
=
a
-
L
;
*
r
=
L
+
SkMulDiv
(
*
r
-
L
numer
denom
)
;
*
g
=
L
+
SkMulDiv
(
*
g
-
L
numer
denom
)
;
*
b
=
L
+
SkMulDiv
(
*
b
-
L
numer
denom
)
;
}
}
static
inline
void
SetLum
(
int
*
r
int
*
g
int
*
b
int
a
int
l
)
{
int
d
=
l
-
Lum
(
*
r
*
g
*
b
)
;
*
r
+
=
d
;
*
g
+
=
d
;
*
b
+
=
d
;
clipColor
(
r
g
b
a
)
;
}
#
define
blendfunc_nonsep_byte
(
sc
dc
sa
da
blendval
)
\
clamp_div255round
(
sc
*
(
255
-
da
)
+
dc
*
(
255
-
sa
)
+
blendval
)
static
SkPMColor
hue_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sr
=
SkGetPackedR32
(
src
)
;
int
sg
=
SkGetPackedG32
(
src
)
;
int
sb
=
SkGetPackedB32
(
src
)
;
int
sa
=
SkGetPackedA32
(
src
)
;
int
dr
=
SkGetPackedR32
(
dst
)
;
int
dg
=
SkGetPackedG32
(
dst
)
;
int
db
=
SkGetPackedB32
(
dst
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
Sr
Sg
Sb
;
if
(
sa
&
&
da
)
{
Sr
=
sr
*
sa
;
Sg
=
sg
*
sa
;
Sb
=
sb
*
sa
;
SetSat
(
&
Sr
&
Sg
&
Sb
Sat
(
dr
dg
db
)
*
sa
)
;
SetLum
(
&
Sr
&
Sg
&
Sb
sa
*
da
Lum
(
dr
dg
db
)
*
sa
)
;
}
else
{
Sr
=
0
;
Sg
=
0
;
Sb
=
0
;
}
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
blendfunc_nonsep_byte
(
sr
dr
sa
da
Sr
)
;
int
g
=
blendfunc_nonsep_byte
(
sg
dg
sa
da
Sg
)
;
int
b
=
blendfunc_nonsep_byte
(
sb
db
sa
da
Sb
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SkPMColor
saturation_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sr
=
SkGetPackedR32
(
src
)
;
int
sg
=
SkGetPackedG32
(
src
)
;
int
sb
=
SkGetPackedB32
(
src
)
;
int
sa
=
SkGetPackedA32
(
src
)
;
int
dr
=
SkGetPackedR32
(
dst
)
;
int
dg
=
SkGetPackedG32
(
dst
)
;
int
db
=
SkGetPackedB32
(
dst
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
Dr
Dg
Db
;
if
(
sa
&
&
da
)
{
Dr
=
dr
*
sa
;
Dg
=
dg
*
sa
;
Db
=
db
*
sa
;
SetSat
(
&
Dr
&
Dg
&
Db
Sat
(
sr
sg
sb
)
*
da
)
;
SetLum
(
&
Dr
&
Dg
&
Db
sa
*
da
Lum
(
dr
dg
db
)
*
sa
)
;
}
else
{
Dr
=
0
;
Dg
=
0
;
Db
=
0
;
}
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
blendfunc_nonsep_byte
(
sr
dr
sa
da
Dr
)
;
int
g
=
blendfunc_nonsep_byte
(
sg
dg
sa
da
Dg
)
;
int
b
=
blendfunc_nonsep_byte
(
sb
db
sa
da
Db
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SkPMColor
color_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sr
=
SkGetPackedR32
(
src
)
;
int
sg
=
SkGetPackedG32
(
src
)
;
int
sb
=
SkGetPackedB32
(
src
)
;
int
sa
=
SkGetPackedA32
(
src
)
;
int
dr
=
SkGetPackedR32
(
dst
)
;
int
dg
=
SkGetPackedG32
(
dst
)
;
int
db
=
SkGetPackedB32
(
dst
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
Sr
Sg
Sb
;
if
(
sa
&
&
da
)
{
Sr
=
sr
*
da
;
Sg
=
sg
*
da
;
Sb
=
sb
*
da
;
SetLum
(
&
Sr
&
Sg
&
Sb
sa
*
da
Lum
(
dr
dg
db
)
*
sa
)
;
}
else
{
Sr
=
0
;
Sg
=
0
;
Sb
=
0
;
}
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
blendfunc_nonsep_byte
(
sr
dr
sa
da
Sr
)
;
int
g
=
blendfunc_nonsep_byte
(
sg
dg
sa
da
Sg
)
;
int
b
=
blendfunc_nonsep_byte
(
sb
db
sa
da
Sb
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SkPMColor
luminosity_modeproc
(
SkPMColor
src
SkPMColor
dst
)
{
int
sr
=
SkGetPackedR32
(
src
)
;
int
sg
=
SkGetPackedG32
(
src
)
;
int
sb
=
SkGetPackedB32
(
src
)
;
int
sa
=
SkGetPackedA32
(
src
)
;
int
dr
=
SkGetPackedR32
(
dst
)
;
int
dg
=
SkGetPackedG32
(
dst
)
;
int
db
=
SkGetPackedB32
(
dst
)
;
int
da
=
SkGetPackedA32
(
dst
)
;
int
Dr
Dg
Db
;
if
(
sa
&
&
da
)
{
Dr
=
dr
*
sa
;
Dg
=
dg
*
sa
;
Db
=
db
*
sa
;
SetLum
(
&
Dr
&
Dg
&
Db
sa
*
da
Lum
(
sr
sg
sb
)
*
da
)
;
}
else
{
Dr
=
0
;
Dg
=
0
;
Db
=
0
;
}
int
a
=
srcover_byte
(
sa
da
)
;
int
r
=
blendfunc_nonsep_byte
(
sr
dr
sa
da
Dr
)
;
int
g
=
blendfunc_nonsep_byte
(
sg
dg
sa
da
Dg
)
;
int
b
=
blendfunc_nonsep_byte
(
sb
db
sa
da
Db
)
;
return
SkPackARGB32
(
a
r
g
b
)
;
}
const
ProcCoeff
gProcCoeffs
[
]
=
{
{
clear_modeproc
SkXfermode
:
:
kZero_Coeff
SkXfermode
:
:
kZero_Coeff
}
{
src_modeproc
SkXfermode
:
:
kOne_Coeff
SkXfermode
:
:
kZero_Coeff
}
{
dst_modeproc
SkXfermode
:
:
kZero_Coeff
SkXfermode
:
:
kOne_Coeff
}
{
srcover_modeproc
SkXfermode
:
:
kOne_Coeff
SkXfermode
:
:
kISA_Coeff
}
{
dstover_modeproc
SkXfermode
:
:
kIDA_Coeff
SkXfermode
:
:
kOne_Coeff
}
{
srcin_modeproc
SkXfermode
:
:
kDA_Coeff
SkXfermode
:
:
kZero_Coeff
}
{
dstin_modeproc
SkXfermode
:
:
kZero_Coeff
SkXfermode
:
:
kSA_Coeff
}
{
srcout_modeproc
SkXfermode
:
:
kIDA_Coeff
SkXfermode
:
:
kZero_Coeff
}
{
dstout_modeproc
SkXfermode
:
:
kZero_Coeff
SkXfermode
:
:
kISA_Coeff
}
{
srcatop_modeproc
SkXfermode
:
:
kDA_Coeff
SkXfermode
:
:
kISA_Coeff
}
{
dstatop_modeproc
SkXfermode
:
:
kIDA_Coeff
SkXfermode
:
:
kSA_Coeff
}
{
xor_modeproc
SkXfermode
:
:
kIDA_Coeff
SkXfermode
:
:
kISA_Coeff
}
{
plus_modeproc
SkXfermode
:
:
kOne_Coeff
SkXfermode
:
:
kOne_Coeff
}
{
modulate_modeproc
SkXfermode
:
:
kZero_Coeff
SkXfermode
:
:
kSC_Coeff
}
{
screen_modeproc
SkXfermode
:
:
kOne_Coeff
SkXfermode
:
:
kISC_Coeff
}
{
overlay_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
darken_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
lighten_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
colordodge_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
colorburn_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
hardlight_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
softlight_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
difference_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
exclusion_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
multiply_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
hue_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
saturation_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
color_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
{
luminosity_modeproc
CANNOT_USE_COEFF
CANNOT_USE_COEFF
}
}
;
bool
SkXfermode
:
:
asMode
(
Mode
*
mode
)
const
{
return
false
;
}
bool
SkXfermode
:
:
asFragmentProcessor
(
const
GrFragmentProcessor
*
*
const
GrFragmentProcessor
*
)
const
{
return
false
;
}
bool
SkXfermode
:
:
asXPFactory
(
GrXPFactory
*
*
)
const
{
return
false
;
}
SkPMColor
SkXfermode
:
:
xferColor
(
SkPMColor
src
SkPMColor
dst
)
const
{
return
dst
;
}
void
SkXfermode
:
:
xfer32
(
SkPMColor
*
SK_RESTRICT
dst
const
SkPMColor
*
SK_RESTRICT
src
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
dst
[
i
]
=
this
-
>
xferColor
(
src
[
i
]
dst
[
i
]
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkPMColor
dstC
=
dst
[
i
]
;
SkPMColor
C
=
this
-
>
xferColor
(
src
[
i
]
dstC
)
;
if
(
0xFF
!
=
a
)
{
C
=
SkFourByteInterp
(
C
dstC
a
)
;
}
dst
[
i
]
=
C
;
}
}
}
}
void
SkXfermode
:
:
xfer16
(
uint16_t
*
dst
const
SkPMColor
*
SK_RESTRICT
src
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
SkPMColor
dstC
=
SkPixel16ToPixel32
(
dst
[
i
]
)
;
dst
[
i
]
=
SkPixel32ToPixel16_ToU16
(
this
-
>
xferColor
(
src
[
i
]
dstC
)
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkPMColor
dstC
=
SkPixel16ToPixel32
(
dst
[
i
]
)
;
SkPMColor
C
=
this
-
>
xferColor
(
src
[
i
]
dstC
)
;
if
(
0xFF
!
=
a
)
{
C
=
SkFourByteInterp
(
C
dstC
a
)
;
}
dst
[
i
]
=
SkPixel32ToPixel16_ToU16
(
C
)
;
}
}
}
}
void
SkXfermode
:
:
xferA8
(
SkAlpha
*
SK_RESTRICT
dst
const
SkPMColor
src
[
]
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
SkPMColor
res
=
this
-
>
xferColor
(
src
[
i
]
(
dst
[
i
]
<
<
SK_A32_SHIFT
)
)
;
dst
[
i
]
=
SkToU8
(
SkGetPackedA32
(
res
)
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkAlpha
dstA
=
dst
[
i
]
;
unsigned
A
=
SkGetPackedA32
(
this
-
>
xferColor
(
src
[
i
]
(
SkPMColor
)
(
dstA
<
<
SK_A32_SHIFT
)
)
)
;
if
(
0xFF
!
=
a
)
{
A
=
SkAlphaBlend
(
A
dstA
SkAlpha255To256
(
a
)
)
;
}
dst
[
i
]
=
SkToU8
(
A
)
;
}
}
}
}
bool
SkXfermode
:
:
supportsCoverageAsAlpha
(
)
const
{
return
false
;
}
bool
SkXfermode
:
:
isOpaque
(
SkXfermode
:
:
SrcColorOpacity
opacityType
)
const
{
return
false
;
}
SkFlattenable
*
SkProcCoeffXfermode
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
uint32_t
mode32
=
buffer
.
read32
(
)
;
if
(
!
buffer
.
validate
(
mode32
<
SK_ARRAY_COUNT
(
gProcCoeffs
)
)
)
{
return
nullptr
;
}
return
SkXfermode
:
:
Create
(
(
SkXfermode
:
:
Mode
)
mode32
)
;
}
void
SkProcCoeffXfermode
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
write32
(
fMode
)
;
}
bool
SkProcCoeffXfermode
:
:
asMode
(
Mode
*
mode
)
const
{
if
(
mode
)
{
*
mode
=
fMode
;
}
return
true
;
}
bool
SkProcCoeffXfermode
:
:
supportsCoverageAsAlpha
(
)
const
{
if
(
CANNOT_USE_COEFF
=
=
fSrcCoeff
)
{
return
false
;
}
switch
(
fDstCoeff
)
{
case
SkXfermode
:
:
kOne_Coeff
:
case
SkXfermode
:
:
kISA_Coeff
:
case
SkXfermode
:
:
kISC_Coeff
:
return
true
;
default
:
return
false
;
}
}
bool
SkProcCoeffXfermode
:
:
isOpaque
(
SkXfermode
:
:
SrcColorOpacity
opacityType
)
const
{
if
(
CANNOT_USE_COEFF
=
=
fSrcCoeff
)
{
return
false
;
}
if
(
SkXfermode
:
:
kDA_Coeff
=
=
fSrcCoeff
|
|
SkXfermode
:
:
kDC_Coeff
=
=
fSrcCoeff
|
|
SkXfermode
:
:
kIDA_Coeff
=
=
fSrcCoeff
|
|
SkXfermode
:
:
kIDC_Coeff
=
=
fSrcCoeff
)
{
return
false
;
}
switch
(
fDstCoeff
)
{
case
SkXfermode
:
:
kZero_Coeff
:
return
true
;
case
SkXfermode
:
:
kISA_Coeff
:
return
SkXfermode
:
:
kOpaque_SrcColorOpacity
=
=
opacityType
;
case
SkXfermode
:
:
kSA_Coeff
:
return
SkXfermode
:
:
kTransparentBlack_SrcColorOpacity
=
=
opacityType
|
|
SkXfermode
:
:
kTransparentAlpha_SrcColorOpacity
=
=
opacityType
;
case
SkXfermode
:
:
kSC_Coeff
:
return
SkXfermode
:
:
kTransparentBlack_SrcColorOpacity
=
=
opacityType
;
default
:
return
false
;
}
}
void
SkProcCoeffXfermode
:
:
xfer32
(
SkPMColor
*
SK_RESTRICT
dst
const
SkPMColor
*
SK_RESTRICT
src
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
SkXfermodeProc
proc
=
fProc
;
if
(
proc
)
{
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
dst
[
i
]
=
proc
(
src
[
i
]
dst
[
i
]
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkPMColor
dstC
=
dst
[
i
]
;
SkPMColor
C
=
proc
(
src
[
i
]
dstC
)
;
if
(
a
!
=
0xFF
)
{
C
=
SkFourByteInterp
(
C
dstC
a
)
;
}
dst
[
i
]
=
C
;
}
}
}
}
}
void
SkProcCoeffXfermode
:
:
xfer16
(
uint16_t
*
SK_RESTRICT
dst
const
SkPMColor
*
SK_RESTRICT
src
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
SkXfermodeProc
proc
=
fProc
;
if
(
proc
)
{
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
SkPMColor
dstC
=
SkPixel16ToPixel32
(
dst
[
i
]
)
;
dst
[
i
]
=
SkPixel32ToPixel16_ToU16
(
proc
(
src
[
i
]
dstC
)
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkPMColor
dstC
=
SkPixel16ToPixel32
(
dst
[
i
]
)
;
SkPMColor
C
=
proc
(
src
[
i
]
dstC
)
;
if
(
0xFF
!
=
a
)
{
C
=
SkFourByteInterp
(
C
dstC
a
)
;
}
dst
[
i
]
=
SkPixel32ToPixel16_ToU16
(
C
)
;
}
}
}
}
}
void
SkProcCoeffXfermode
:
:
xferA8
(
SkAlpha
*
SK_RESTRICT
dst
const
SkPMColor
*
SK_RESTRICT
src
int
count
const
SkAlpha
*
SK_RESTRICT
aa
)
const
{
SkASSERT
(
dst
&
&
src
&
&
count
>
=
0
)
;
SkXfermodeProc
proc
=
fProc
;
if
(
proc
)
{
if
(
nullptr
=
=
aa
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
SkPMColor
res
=
proc
(
src
[
i
]
dst
[
i
]
<
<
SK_A32_SHIFT
)
;
dst
[
i
]
=
SkToU8
(
SkGetPackedA32
(
res
)
)
;
}
}
else
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
unsigned
a
=
aa
[
i
]
;
if
(
0
!
=
a
)
{
SkAlpha
dstA
=
dst
[
i
]
;
SkPMColor
res
=
proc
(
src
[
i
]
dstA
<
<
SK_A32_SHIFT
)
;
unsigned
A
=
SkGetPackedA32
(
res
)
;
if
(
0xFF
!
=
a
)
{
A
=
SkAlphaBlend
(
A
dstA
SkAlpha255To256
(
a
)
)
;
}
dst
[
i
]
=
SkToU8
(
A
)
;
}
}
}
}
}
#
if
SK_SUPPORT_GPU
#
include
"
effects
/
GrCustomXfermode
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrXfermodeFragmentProcessor
.
h
"
bool
SkProcCoeffXfermode
:
:
asFragmentProcessor
(
const
GrFragmentProcessor
*
*
fp
const
GrFragmentProcessor
*
dst
)
const
{
if
(
fp
)
{
SkASSERT
(
dst
)
;
*
fp
=
GrXfermodeFragmentProcessor
:
:
CreateFromDstProcessor
(
dst
fMode
)
;
SkASSERT
(
*
fp
|
|
kSrc_Mode
=
=
fMode
)
;
}
return
true
;
}
bool
SkProcCoeffXfermode
:
:
asXPFactory
(
GrXPFactory
*
*
xp
)
const
{
if
(
CANNOT_USE_COEFF
!
=
fSrcCoeff
)
{
if
(
xp
)
{
*
xp
=
GrPorterDuffXPFactory
:
:
Create
(
fMode
)
;
SkASSERT
(
*
xp
)
;
}
return
true
;
}
if
(
GrCustomXfermode
:
:
IsSupportedMode
(
fMode
)
)
{
if
(
xp
)
{
*
xp
=
GrCustomXfermode
:
:
CreateXPFactory
(
fMode
)
;
SkASSERT
(
*
xp
)
;
}
return
true
;
}
return
false
;
}
#
endif
const
char
*
SkXfermode
:
:
ModeName
(
Mode
mode
)
{
SkASSERT
(
(
unsigned
)
mode
<
=
(
unsigned
)
kLastMode
)
;
const
char
*
gModeStrings
[
]
=
{
"
Clear
"
"
Src
"
"
Dst
"
"
SrcOver
"
"
DstOver
"
"
SrcIn
"
"
DstIn
"
"
SrcOut
"
"
DstOut
"
"
SrcATop
"
"
DstATop
"
"
Xor
"
"
Plus
"
"
Modulate
"
"
Screen
"
"
Overlay
"
"
Darken
"
"
Lighten
"
"
ColorDodge
"
"
ColorBurn
"
"
HardLight
"
"
SoftLight
"
"
Difference
"
"
Exclusion
"
"
Multiply
"
"
Hue
"
"
Saturation
"
"
Color
"
"
Luminosity
"
}
;
return
gModeStrings
[
mode
]
;
static_assert
(
SK_ARRAY_COUNT
(
gModeStrings
)
=
=
kLastMode
+
1
"
mode_count
"
)
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
SkProcCoeffXfermode
:
:
toString
(
SkString
*
str
)
const
{
str
-
>
append
(
"
SkProcCoeffXfermode
:
"
)
;
str
-
>
append
(
"
mode
:
"
)
;
str
-
>
append
(
ModeName
(
fMode
)
)
;
static
const
char
*
gCoeffStrings
[
kCoeffCount
]
=
{
"
Zero
"
"
One
"
"
SC
"
"
ISC
"
"
DC
"
"
IDC
"
"
SA
"
"
ISA
"
"
DA
"
"
IDA
"
}
;
str
-
>
append
(
"
src
:
"
)
;
if
(
CANNOT_USE_COEFF
=
=
fSrcCoeff
)
{
str
-
>
append
(
"
can
'
t
use
"
)
;
}
else
{
str
-
>
append
(
gCoeffStrings
[
fSrcCoeff
]
)
;
}
str
-
>
append
(
"
dst
:
"
)
;
if
(
CANNOT_USE_COEFF
=
=
fDstCoeff
)
{
str
-
>
append
(
"
can
'
t
use
"
)
;
}
else
{
str
-
>
append
(
gCoeffStrings
[
fDstCoeff
]
)
;
}
}
#
endif
SK_DECLARE_STATIC_ONCE_PTR
(
SkXfermode
cached
[
SkXfermode
:
:
kLastMode
+
1
]
)
;
SkXfermode
*
SkXfermode
:
:
Create
(
Mode
mode
)
{
SkASSERT
(
SK_ARRAY_COUNT
(
gProcCoeffs
)
=
=
kModeCount
)
;
if
(
(
unsigned
)
mode
>
=
kModeCount
)
{
return
nullptr
;
}
if
(
kSrcOver_Mode
=
=
mode
)
{
return
nullptr
;
}
return
SkSafeRef
(
cached
[
mode
]
.
get
(
[
=
]
{
ProcCoeff
rec
=
gProcCoeffs
[
mode
]
;
if
(
auto
xfermode
=
SkOpts
:
:
create_xfermode
(
rec
mode
)
)
{
return
xfermode
;
}
return
(
SkXfermode
*
)
new
SkProcCoeffXfermode
(
rec
mode
)
;
}
)
)
;
}
SkXfermodeProc
SkXfermode
:
:
GetProc
(
Mode
mode
)
{
SkXfermodeProc
proc
=
nullptr
;
if
(
(
unsigned
)
mode
<
kModeCount
)
{
proc
=
gProcCoeffs
[
mode
]
.
fProc
;
}
return
proc
;
}
bool
SkXfermode
:
:
ModeAsCoeff
(
Mode
mode
Coeff
*
src
Coeff
*
dst
)
{
SkASSERT
(
SK_ARRAY_COUNT
(
gProcCoeffs
)
=
=
kModeCount
)
;
if
(
(
unsigned
)
mode
>
=
(
unsigned
)
kModeCount
)
{
return
false
;
}
const
ProcCoeff
&
rec
=
gProcCoeffs
[
mode
]
;
if
(
CANNOT_USE_COEFF
=
=
rec
.
fSC
)
{
return
false
;
}
SkASSERT
(
CANNOT_USE_COEFF
!
=
rec
.
fDC
)
;
if
(
src
)
{
*
src
=
rec
.
fSC
;
}
if
(
dst
)
{
*
dst
=
rec
.
fDC
;
}
return
true
;
}
bool
SkXfermode
:
:
AsMode
(
const
SkXfermode
*
xfer
Mode
*
mode
)
{
if
(
nullptr
=
=
xfer
)
{
if
(
mode
)
{
*
mode
=
kSrcOver_Mode
;
}
return
true
;
}
return
xfer
-
>
asMode
(
mode
)
;
}
bool
SkXfermode
:
:
IsMode
(
const
SkXfermode
*
xfer
Mode
mode
)
{
Mode
m
=
kSrcOver_Mode
;
if
(
xfer
&
&
!
xfer
-
>
asMode
(
&
m
)
)
{
return
false
;
}
return
mode
=
=
m
;
}
bool
SkXfermode
:
:
SupportsCoverageAsAlpha
(
const
SkXfermode
*
xfer
)
{
if
(
!
xfer
)
{
return
true
;
}
return
xfer
-
>
supportsCoverageAsAlpha
(
)
;
}
bool
SkXfermode
:
:
IsOpaque
(
const
SkXfermode
*
xfer
SrcColorOpacity
opacityType
)
{
if
(
!
xfer
)
{
return
SkXfermode
:
:
kOpaque_SrcColorOpacity
=
=
opacityType
;
}
return
xfer
-
>
isOpaque
(
opacityType
)
;
}
SK_DEFINE_FLATTENABLE_REGISTRAR_GROUP_START
(
SkXfermode
)
SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY
(
SkProcCoeffXfermode
)
SK_DEFINE_FLATTENABLE_REGISTRAR_GROUP_END
