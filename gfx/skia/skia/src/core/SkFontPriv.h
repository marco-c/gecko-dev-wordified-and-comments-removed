#
ifndef
SkFontPriv_DEFINED
#
define
SkFontPriv_DEFINED
#
include
"
include
/
core
/
SkFont
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkTypeface
.
h
"
class
SkReadBuffer
;
class
SkWriteBuffer
;
class
SkFontPriv
{
public
:
static
constexpr
int
kCanonicalTextSizeForPaths
=
64
;
static
SkMatrix
MakeTextMatrix
(
SkScalar
size
SkScalar
scaleX
SkScalar
skewX
)
{
SkMatrix
m
=
SkMatrix
:
:
MakeScale
(
size
*
scaleX
size
)
;
if
(
skewX
)
{
m
.
postSkew
(
skewX
0
)
;
}
return
m
;
}
static
SkMatrix
MakeTextMatrix
(
const
SkFont
&
font
)
{
return
MakeTextMatrix
(
font
.
getSize
(
)
font
.
getScaleX
(
)
font
.
getSkewX
(
)
)
;
}
static
void
ScaleFontMetrics
(
SkFontMetrics
*
SkScalar
)
;
static
SkRect
GetFontBounds
(
const
SkFont
&
)
;
static
bool
IsFinite
(
const
SkFont
&
font
)
{
return
SkScalarIsFinite
(
font
.
getSize
(
)
)
&
&
SkScalarIsFinite
(
font
.
getScaleX
(
)
)
&
&
SkScalarIsFinite
(
font
.
getSkewX
(
)
)
;
}
static
int
CountTextElements
(
const
void
*
text
size_t
byteLength
SkTextEncoding
)
;
static
void
GlyphsToUnichars
(
const
SkFont
&
const
uint16_t
glyphs
[
]
int
count
SkUnichar
[
]
)
;
static
void
Flatten
(
const
SkFont
&
SkWriteBuffer
&
buffer
)
;
static
bool
Unflatten
(
SkFont
*
SkReadBuffer
&
buffer
)
;
}
;
class
SkAutoToGlyphs
{
public
:
SkAutoToGlyphs
(
const
SkFont
&
font
const
void
*
text
size_t
length
SkTextEncoding
encoding
)
{
if
(
encoding
=
=
SkTextEncoding
:
:
kGlyphID
|
|
length
=
=
0
)
{
fGlyphs
=
reinterpret_cast
<
const
uint16_t
*
>
(
text
)
;
fCount
=
length
>
>
1
;
}
else
{
fCount
=
font
.
countText
(
text
length
encoding
)
;
fStorage
.
reset
(
fCount
)
;
font
.
textToGlyphs
(
text
length
encoding
fStorage
.
get
(
)
fCount
)
;
fGlyphs
=
fStorage
.
get
(
)
;
}
}
int
count
(
)
const
{
return
fCount
;
}
const
uint16_t
*
glyphs
(
)
const
{
return
fGlyphs
;
}
private
:
SkAutoSTArray
<
32
uint16_t
>
fStorage
;
const
uint16_t
*
fGlyphs
;
int
fCount
;
}
;
#
endif
