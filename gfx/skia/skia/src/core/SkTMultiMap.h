#
ifndef
SkTMultiMap_DEFINED
#
define
SkTMultiMap_DEFINED
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
template
<
typename
T
typename
Key
typename
HashTraits
=
T
>
class
SkTMultiMap
{
struct
ValueList
{
explicit
ValueList
(
T
*
value
)
:
fValue
(
value
)
fNext
(
nullptr
)
fCount
(
1
)
{
}
static
const
Key
&
GetKey
(
const
ValueList
&
e
)
{
return
HashTraits
:
:
GetKey
(
*
e
.
fValue
)
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
HashTraits
:
:
Hash
(
key
)
;
}
T
*
fValue
;
ValueList
*
fNext
;
uint32_t
fCount
;
}
;
public
:
SkTMultiMap
(
)
:
fCount
(
0
)
{
}
~
SkTMultiMap
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fHash
.
foreach
(
[
&
]
(
ValueList
*
vl
)
{
ValueList
*
next
;
for
(
ValueList
*
it
=
vl
;
it
;
it
=
next
)
{
HashTraits
:
:
OnFree
(
it
-
>
fValue
)
;
next
=
it
-
>
fNext
;
delete
it
;
}
}
)
;
fHash
.
reset
(
)
;
fCount
=
0
;
}
void
insert
(
const
Key
&
key
T
*
value
)
{
ValueList
*
list
=
fHash
.
find
(
key
)
;
if
(
list
)
{
ValueList
*
newEntry
=
new
ValueList
(
list
-
>
fValue
)
;
newEntry
-
>
fNext
=
list
-
>
fNext
;
list
-
>
fNext
=
newEntry
;
list
-
>
fValue
=
value
;
list
-
>
fCount
+
+
;
}
else
{
fHash
.
add
(
new
ValueList
(
value
)
)
;
}
+
+
fCount
;
}
void
remove
(
const
Key
&
key
const
T
*
value
)
{
ValueList
*
root
=
fHash
.
find
(
key
)
;
ValueList
*
list
=
root
;
#
if
0
SkASSERT
(
list
)
;
ValueList
*
prev
=
nullptr
;
while
(
list
-
>
fValue
!
=
value
)
{
prev
=
list
;
list
=
list
-
>
fNext
;
}
this
-
>
internalRemove
(
root
prev
list
key
)
;
#
else
ValueList
*
prev
=
nullptr
;
while
(
list
&
&
list
-
>
fValue
!
=
value
)
{
prev
=
list
;
list
=
list
-
>
fNext
;
}
SkASSERT
(
list
)
;
if
(
list
)
{
this
-
>
internalRemove
(
root
prev
list
key
)
;
}
#
endif
}
T
*
find
(
const
Key
&
key
)
const
{
ValueList
*
list
=
fHash
.
find
(
key
)
;
if
(
list
)
{
return
list
-
>
fValue
;
}
return
nullptr
;
}
template
<
class
FindPredicate
>
T
*
find
(
const
Key
&
key
const
FindPredicate
f
)
{
ValueList
*
list
=
fHash
.
find
(
key
)
;
while
(
list
)
{
if
(
f
(
list
-
>
fValue
)
)
{
return
list
-
>
fValue
;
}
list
=
list
-
>
fNext
;
}
return
nullptr
;
}
template
<
class
FindPredicate
>
T
*
findAndRemove
(
const
Key
&
key
const
FindPredicate
f
)
{
ValueList
*
root
=
fHash
.
find
(
key
)
;
ValueList
*
list
=
root
;
ValueList
*
prev
=
nullptr
;
while
(
list
)
{
if
(
f
(
list
-
>
fValue
)
)
{
T
*
value
=
list
-
>
fValue
;
this
-
>
internalRemove
(
root
prev
list
key
)
;
return
value
;
}
prev
=
list
;
list
=
list
-
>
fNext
;
}
return
nullptr
;
}
int
count
(
)
const
{
return
fCount
;
}
#
ifdef
SK_DEBUG
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
const
{
fHash
.
foreach
(
[
&
]
(
const
ValueList
&
vl
)
{
for
(
const
ValueList
*
it
=
&
vl
;
it
;
it
=
it
-
>
fNext
)
{
fn
(
*
it
-
>
fValue
)
;
}
}
)
;
}
bool
has
(
const
T
*
value
const
Key
&
key
)
const
{
for
(
ValueList
*
list
=
fHash
.
find
(
key
)
;
list
;
list
=
list
-
>
fNext
)
{
if
(
list
-
>
fValue
=
=
value
)
{
return
true
;
}
}
return
false
;
}
int
countForKey
(
const
Key
&
key
)
const
{
int
count
=
0
;
ValueList
*
list
=
fHash
.
find
(
key
)
;
while
(
list
)
{
list
=
list
-
>
fNext
;
+
+
count
;
}
return
count
;
}
#
endif
private
:
SkTDynamicHash
<
ValueList
Key
>
fHash
;
int
fCount
;
void
internalRemove
(
ValueList
*
root
ValueList
*
prev
ValueList
*
elem
const
Key
&
key
)
{
root
-
>
fCount
-
-
;
if
(
elem
-
>
fNext
)
{
ValueList
*
next
=
elem
-
>
fNext
;
elem
-
>
fValue
=
next
-
>
fValue
;
elem
-
>
fNext
=
next
-
>
fNext
;
delete
next
;
}
else
if
(
prev
)
{
prev
-
>
fNext
=
nullptr
;
delete
elem
;
}
else
{
fHash
.
remove
(
key
)
;
delete
elem
;
}
-
-
fCount
;
}
}
;
#
endif
