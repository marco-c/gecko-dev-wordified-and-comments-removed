#
ifndef
SkDevice_DEFINED
#
define
SkDevice_DEFINED
#
include
"
include
/
core
/
SkBlender
.
h
"
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkRegion
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkRasterClip
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
shaders
/
SkShaderBase
.
h
"
namespace
sktext
{
class
GlyphRun
;
class
GlyphRunList
;
}
class
SkBitmap
;
class
SkColorSpace
;
class
SkMesh
;
struct
SkDrawShadowRec
;
class
SkImageFilter
;
class
SkImageFilterCache
;
struct
SkIRect
;
class
SkRasterHandleAllocator
;
class
SkSpecialImage
;
namespace
skif
{
class
Mapping
;
}
namespace
skgpu
:
:
ganesh
{
class
Device
;
}
namespace
skgpu
:
:
graphite
{
class
Device
;
}
namespace
sktext
:
:
gpu
{
class
SDFTControl
;
}
struct
SkStrikeDeviceInfo
{
const
SkSurfaceProps
fSurfaceProps
;
const
SkScalerContextFlags
fScalerContextFlags
;
const
sktext
:
:
gpu
:
:
SDFTControl
*
const
fSDFTControl
;
}
;
class
SkBaseDevice
:
public
SkRefCnt
public
SkMatrixProvider
{
public
:
SkBaseDevice
(
const
SkImageInfo
&
const
SkSurfaceProps
&
)
;
const
SkImageInfo
&
imageInfo
(
)
const
{
return
fInfo
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
SkScalerContextFlags
scalerContextFlags
(
)
const
;
virtual
SkStrikeDeviceInfo
strikeDeviceInfo
(
)
const
{
return
{
fSurfaceProps
this
-
>
scalerContextFlags
(
)
nullptr
}
;
}
SkIRect
bounds
(
)
const
{
return
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
}
void
getGlobalBounds
(
SkIRect
*
bounds
)
const
{
SkASSERT
(
bounds
)
;
*
bounds
=
SkMatrixPriv
:
:
MapRect
(
fDeviceToGlobal
SkRect
:
:
Make
(
this
-
>
bounds
(
)
)
)
.
roundOut
(
)
;
}
SkIRect
getGlobalBounds
(
)
const
{
SkIRect
bounds
;
this
-
>
getGlobalBounds
(
&
bounds
)
;
return
bounds
;
}
SkIRect
devClipBounds
(
)
const
{
return
this
-
>
onDevClipBounds
(
)
;
}
int
width
(
)
const
{
return
this
-
>
imageInfo
(
)
.
width
(
)
;
}
int
height
(
)
const
{
return
this
-
>
imageInfo
(
)
.
height
(
)
;
}
bool
isOpaque
(
)
const
{
return
this
-
>
imageInfo
(
)
.
isOpaque
(
)
;
}
bool
writePixels
(
const
SkPixmap
&
int
x
int
y
)
;
bool
accessPixels
(
SkPixmap
*
pmap
)
;
bool
peekPixels
(
SkPixmap
*
)
;
const
SkM44
&
deviceToGlobal
(
)
const
{
return
fDeviceToGlobal
;
}
const
SkM44
&
globalToDevice
(
)
const
{
return
fGlobalToDevice
;
}
SkIPoint
getOrigin
(
)
const
;
bool
isPixelAlignedToGlobal
(
)
const
;
SkMatrix
getRelativeTransform
(
const
SkBaseDevice
&
)
const
;
virtual
void
*
getRasterHandle
(
)
const
{
return
nullptr
;
}
const
SkMatrixProvider
&
asMatrixProvider
(
)
const
{
return
*
this
;
}
void
save
(
)
{
this
-
>
onSave
(
)
;
}
void
restore
(
const
SkM44
&
ctm
)
{
this
-
>
onRestore
(
)
;
this
-
>
setGlobalCTM
(
ctm
)
;
}
void
restoreLocal
(
const
SkM44
&
localToDevice
)
{
this
-
>
onRestore
(
)
;
this
-
>
setLocalToDevice
(
localToDevice
)
;
}
void
clipRect
(
const
SkRect
&
rect
SkClipOp
op
bool
aa
)
{
this
-
>
onClipRect
(
rect
op
aa
)
;
}
void
clipRRect
(
const
SkRRect
&
rrect
SkClipOp
op
bool
aa
)
{
this
-
>
onClipRRect
(
rrect
op
aa
)
;
}
void
clipPath
(
const
SkPath
&
path
SkClipOp
op
bool
aa
)
{
this
-
>
onClipPath
(
path
op
aa
)
;
}
void
clipShader
(
sk_sp
<
SkShader
>
sh
SkClipOp
op
)
{
sh
=
as_SB
(
sh
)
-
>
makeWithCTM
(
this
-
>
localToDevice
(
)
)
;
if
(
op
=
=
SkClipOp
:
:
kDifference
)
{
sh
=
as_SB
(
sh
)
-
>
makeInvertAlpha
(
)
;
}
this
-
>
onClipShader
(
std
:
:
move
(
sh
)
)
;
}
void
clipRegion
(
const
SkRegion
&
region
SkClipOp
op
)
{
this
-
>
onClipRegion
(
region
op
)
;
}
void
replaceClip
(
const
SkIRect
&
rect
)
{
this
-
>
onReplaceClip
(
rect
)
;
}
bool
clipIsWideOpen
(
)
const
{
return
this
-
>
onClipIsWideOpen
(
)
;
}
void
setLocalToDevice
(
const
SkM44
&
localToDevice
)
{
fLocalToDevice
=
localToDevice
;
fLocalToDevice33
=
fLocalToDevice
.
asM33
(
)
;
fLocalToDeviceDirty
=
true
;
}
void
setGlobalCTM
(
const
SkM44
&
ctm
)
;
virtual
void
validateDevBounds
(
const
SkIRect
&
)
{
}
virtual
bool
android_utils_clipWithStencil
(
)
{
return
false
;
}
virtual
skgpu
:
:
ganesh
:
:
Device
*
asGaneshDevice
(
)
{
return
nullptr
;
}
virtual
skgpu
:
:
graphite
:
:
Device
*
asGraphiteDevice
(
)
{
return
nullptr
;
}
void
drawGlyphRunList
(
SkCanvas
*
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
)
;
virtual
sk_sp
<
SkSpecialImage
>
snapSpecial
(
const
SkIRect
&
subset
bool
forceCopy
=
false
)
;
virtual
sk_sp
<
SkSpecialImage
>
snapSpecialScaled
(
const
SkIRect
&
subset
const
SkISize
&
dstDims
)
;
sk_sp
<
SkSpecialImage
>
snapSpecial
(
)
;
protected
:
enum
TileUsage
{
kPossible_TileUsage
kNever_TileUsage
}
;
struct
TextFlags
{
uint32_t
fFlags
;
}
;
virtual
void
onSave
(
)
{
}
virtual
void
onRestore
(
)
{
}
virtual
void
onClipRect
(
const
SkRect
&
rect
SkClipOp
bool
aa
)
{
}
virtual
void
onClipRRect
(
const
SkRRect
&
rrect
SkClipOp
bool
aa
)
{
}
virtual
void
onClipPath
(
const
SkPath
&
path
SkClipOp
bool
aa
)
{
}
virtual
void
onClipShader
(
sk_sp
<
SkShader
>
)
{
}
virtual
void
onClipRegion
(
const
SkRegion
&
deviceRgn
SkClipOp
)
{
}
virtual
void
onReplaceClip
(
const
SkIRect
&
rect
)
{
}
virtual
bool
onClipIsAA
(
)
const
=
0
;
virtual
bool
onClipIsWideOpen
(
)
const
=
0
;
virtual
void
onAsRgnClip
(
SkRegion
*
)
const
=
0
;
enum
class
ClipType
{
kEmpty
kRect
kComplex
}
;
virtual
ClipType
onGetClipType
(
)
const
=
0
;
virtual
SkIRect
onDevClipBounds
(
)
const
=
0
;
virtual
void
drawPaint
(
const
SkPaint
&
paint
)
=
0
;
virtual
void
drawPoints
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
[
]
const
SkPaint
&
paint
)
=
0
;
virtual
void
drawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
=
0
;
virtual
void
drawRegion
(
const
SkRegion
&
r
const
SkPaint
&
paint
)
;
virtual
void
drawOval
(
const
SkRect
&
oval
const
SkPaint
&
paint
)
=
0
;
virtual
void
drawArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
SkPaint
&
paint
)
;
virtual
void
drawRRect
(
const
SkRRect
&
rr
const
SkPaint
&
paint
)
=
0
;
virtual
void
drawDRRect
(
const
SkRRect
&
outer
const
SkRRect
&
inner
const
SkPaint
&
)
;
virtual
void
drawPath
(
const
SkPath
&
path
const
SkPaint
&
paint
bool
pathIsMutable
=
false
)
=
0
;
virtual
void
drawImageRect
(
const
SkImage
*
const
SkRect
*
src
const
SkRect
&
dst
const
SkSamplingOptions
&
const
SkPaint
&
SkCanvas
:
:
SrcRectConstraint
)
=
0
;
virtual
void
drawImageLattice
(
const
SkImage
*
const
SkCanvas
:
:
Lattice
&
const
SkRect
&
dst
SkFilterMode
const
SkPaint
&
)
;
virtual
void
drawVertices
(
const
SkVertices
*
sk_sp
<
SkBlender
>
const
SkPaint
&
bool
skipColorXform
=
false
)
=
0
;
#
ifdef
SK_ENABLE_SKSL
virtual
void
drawMesh
(
const
SkMesh
&
mesh
sk_sp
<
SkBlender
>
const
SkPaint
&
)
=
0
;
#
endif
virtual
void
drawShadow
(
const
SkPath
&
const
SkDrawShadowRec
&
)
;
virtual
void
drawPatch
(
const
SkPoint
cubics
[
12
]
const
SkColor
colors
[
4
]
const
SkPoint
texCoords
[
4
]
sk_sp
<
SkBlender
>
const
SkPaint
&
paint
)
;
virtual
void
drawAtlas
(
const
SkRSXform
[
]
const
SkRect
[
]
const
SkColor
[
]
int
count
sk_sp
<
SkBlender
>
const
SkPaint
&
)
;
virtual
void
drawAnnotation
(
const
SkRect
&
const
char
[
]
SkData
*
)
{
}
virtual
void
drawEdgeAAQuad
(
const
SkRect
&
rect
const
SkPoint
clip
[
4
]
SkCanvas
:
:
QuadAAFlags
aaFlags
const
SkColor4f
&
color
SkBlendMode
mode
)
;
virtual
void
drawEdgeAAImageSet
(
const
SkCanvas
:
:
ImageSetEntry
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkSamplingOptions
&
const
SkPaint
&
SkCanvas
:
:
SrcRectConstraint
)
;
virtual
void
drawDrawable
(
SkCanvas
*
SkDrawable
*
const
SkMatrix
*
)
;
virtual
void
onDrawGlyphRunList
(
SkCanvas
*
const
sktext
:
:
GlyphRunList
&
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
)
=
0
;
#
if
(
defined
(
SK_GANESH
)
|
|
defined
(
SK_GRAPHITE
)
)
virtual
sk_sp
<
sktext
:
:
gpu
:
:
Slug
>
convertGlyphRunListToSlug
(
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
)
;
virtual
void
drawSlug
(
SkCanvas
*
const
sktext
:
:
gpu
:
:
Slug
*
slug
const
SkPaint
&
drawingPaint
)
;
#
endif
virtual
void
drawDevice
(
SkBaseDevice
*
const
SkSamplingOptions
&
const
SkPaint
&
)
;
virtual
void
drawSpecial
(
SkSpecialImage
*
const
SkMatrix
&
localToDevice
const
SkSamplingOptions
&
const
SkPaint
&
)
;
void
drawFilteredImage
(
const
skif
:
:
Mapping
&
mapping
SkSpecialImage
*
src
SkColorType
ct
const
SkImageFilter
*
const
SkSamplingOptions
&
const
SkPaint
&
)
;
virtual
sk_sp
<
SkSpecialImage
>
makeSpecial
(
const
SkBitmap
&
)
;
virtual
sk_sp
<
SkSpecialImage
>
makeSpecial
(
const
SkImage
*
)
;
virtual
void
setImmutable
(
)
{
}
bool
readPixels
(
const
SkPixmap
&
int
x
int
y
)
;
virtual
sk_sp
<
SkSurface
>
makeSurface
(
const
SkImageInfo
&
const
SkSurfaceProps
&
)
;
virtual
bool
onPeekPixels
(
SkPixmap
*
)
{
return
false
;
}
virtual
bool
onReadPixels
(
const
SkPixmap
&
int
x
int
y
)
;
virtual
bool
onWritePixels
(
const
SkPixmap
&
int
x
int
y
)
;
virtual
bool
onAccessPixels
(
SkPixmap
*
)
{
return
false
;
}
struct
CreateInfo
{
CreateInfo
(
const
SkImageInfo
&
info
SkPixelGeometry
geo
TileUsage
tileUsage
SkRasterHandleAllocator
*
allocator
)
:
fInfo
(
info
)
fTileUsage
(
tileUsage
)
fPixelGeometry
(
geo
)
fAllocator
(
allocator
)
{
}
const
SkImageInfo
fInfo
;
const
TileUsage
fTileUsage
;
const
SkPixelGeometry
fPixelGeometry
;
SkRasterHandleAllocator
*
fAllocator
=
nullptr
;
}
;
virtual
SkBaseDevice
*
onCreateDevice
(
const
CreateInfo
&
const
SkPaint
*
)
{
return
nullptr
;
}
virtual
bool
isNoPixelsDevice
(
)
const
{
return
false
;
}
bool
checkLocalToDeviceDirty
(
)
{
bool
wasDirty
=
fLocalToDeviceDirty
;
fLocalToDeviceDirty
=
false
;
return
wasDirty
;
}
private
:
friend
class
SkAndroidFrameworkUtils
;
friend
class
SkCanvas
;
friend
class
SkDraw
;
friend
class
SkDrawBase
;
friend
class
SkSurface_Raster
;
friend
class
DeviceTestingAccess
;
void
simplifyGlyphRunRSXFormAndRedraw
(
SkCanvas
*
const
sktext
:
:
GlyphRunList
&
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
)
;
virtual
void
replaceBitmapBackendForRasterSurface
(
const
SkBitmap
&
)
{
}
virtual
bool
forceConservativeRasterClip
(
)
const
{
return
false
;
}
void
setDeviceCoordinateSystem
(
const
SkM44
&
deviceToGlobal
const
SkM44
&
globalToDevice
const
SkM44
&
localToDevice
int
bufferOriginX
int
bufferOriginY
)
;
void
setOrigin
(
const
SkM44
&
globalCTM
int
x
int
y
)
{
this
-
>
setDeviceCoordinateSystem
(
SkM44
(
)
SkM44
(
)
globalCTM
x
y
)
;
}
virtual
SkImageFilterCache
*
getImageFilterCache
(
)
{
return
nullptr
;
}
friend
class
SkNoPixelsDevice
;
friend
class
SkBitmapDevice
;
void
privateResize
(
int
w
int
h
)
{
*
const_cast
<
SkImageInfo
*
>
(
&
fInfo
)
=
fInfo
.
makeWH
(
w
h
)
;
}
const
SkImageInfo
fInfo
;
const
SkSurfaceProps
fSurfaceProps
;
SkM44
fDeviceToGlobal
;
SkM44
fGlobalToDevice
;
bool
fLocalToDeviceDirty
=
true
;
using
INHERITED
=
SkRefCnt
;
}
;
class
SkNoPixelsDevice
:
public
SkBaseDevice
{
public
:
SkNoPixelsDevice
(
const
SkIRect
&
bounds
const
SkSurfaceProps
&
props
)
;
SkNoPixelsDevice
(
const
SkIRect
&
bounds
const
SkSurfaceProps
&
props
sk_sp
<
SkColorSpace
>
colorSpace
)
;
void
resetForNextPicture
(
const
SkIRect
&
bounds
)
{
this
-
>
privateResize
(
bounds
.
width
(
)
bounds
.
height
(
)
)
;
this
-
>
setOrigin
(
SkM44
(
)
bounds
.
left
(
)
bounds
.
top
(
)
)
;
this
-
>
resetClipStack
(
)
;
}
protected
:
void
onSave
(
)
override
;
void
onRestore
(
)
override
;
void
onClipRect
(
const
SkRect
&
rect
SkClipOp
op
bool
aa
)
override
;
void
onClipRRect
(
const
SkRRect
&
rrect
SkClipOp
op
bool
aa
)
override
;
void
onClipPath
(
const
SkPath
&
path
SkClipOp
op
bool
aa
)
override
;
void
onClipRegion
(
const
SkRegion
&
globalRgn
SkClipOp
op
)
override
;
void
onClipShader
(
sk_sp
<
SkShader
>
shader
)
override
;
void
onReplaceClip
(
const
SkIRect
&
rect
)
override
;
bool
onClipIsAA
(
)
const
override
{
return
this
-
>
clip
(
)
.
fIsAA
;
}
bool
onClipIsWideOpen
(
)
const
override
{
return
this
-
>
clip
(
)
.
fIsRect
&
&
this
-
>
onDevClipBounds
(
)
=
=
this
-
>
bounds
(
)
;
}
void
onAsRgnClip
(
SkRegion
*
rgn
)
const
override
{
rgn
-
>
setRect
(
this
-
>
onDevClipBounds
(
)
)
;
}
ClipType
onGetClipType
(
)
const
override
;
SkIRect
onDevClipBounds
(
)
const
override
{
return
this
-
>
clip
(
)
.
fClipBounds
;
}
void
drawPaint
(
const
SkPaint
&
paint
)
override
{
}
void
drawPoints
(
SkCanvas
:
:
PointMode
size_t
const
SkPoint
[
]
const
SkPaint
&
)
override
{
}
void
drawImageRect
(
const
SkImage
*
const
SkRect
*
const
SkRect
&
const
SkSamplingOptions
&
const
SkPaint
&
SkCanvas
:
:
SrcRectConstraint
)
override
{
}
void
drawRect
(
const
SkRect
&
const
SkPaint
&
)
override
{
}
void
drawOval
(
const
SkRect
&
const
SkPaint
&
)
override
{
}
void
drawRRect
(
const
SkRRect
&
const
SkPaint
&
)
override
{
}
void
drawPath
(
const
SkPath
&
const
SkPaint
&
bool
)
override
{
}
void
drawDevice
(
SkBaseDevice
*
const
SkSamplingOptions
&
const
SkPaint
&
)
override
{
}
void
drawVertices
(
const
SkVertices
*
sk_sp
<
SkBlender
>
const
SkPaint
&
bool
)
override
{
}
#
ifdef
SK_ENABLE_SKSL
void
drawMesh
(
const
SkMesh
&
sk_sp
<
SkBlender
>
const
SkPaint
&
)
override
{
}
#
endif
#
if
defined
(
SK_GANESH
)
void
drawSlug
(
SkCanvas
*
const
sktext
:
:
gpu
:
:
Slug
*
const
SkPaint
&
)
override
{
}
#
endif
void
onDrawGlyphRunList
(
SkCanvas
*
const
sktext
:
:
GlyphRunList
&
const
SkPaint
&
const
SkPaint
&
)
override
{
}
bool
isNoPixelsDevice
(
)
const
override
{
return
true
;
}
private
:
struct
ClipState
{
SkIRect
fClipBounds
;
int
fDeferredSaveCount
;
bool
fIsAA
;
bool
fIsRect
;
ClipState
(
const
SkIRect
&
bounds
bool
isAA
bool
isRect
)
:
fClipBounds
(
bounds
)
fDeferredSaveCount
(
0
)
fIsAA
(
isAA
)
fIsRect
(
isRect
)
{
}
void
op
(
SkClipOp
op
const
SkM44
&
transform
const
SkRect
&
bounds
bool
isAA
bool
fillsBounds
)
;
}
;
const
ClipState
&
clip
(
)
const
{
return
fClipStack
.
back
(
)
;
}
ClipState
&
writableClip
(
)
;
void
resetClipStack
(
)
{
fClipStack
.
clear
(
)
;
fClipStack
.
emplace_back
(
this
-
>
bounds
(
)
false
true
)
;
}
SkSTArray
<
4
ClipState
>
fClipStack
;
using
INHERITED
=
SkBaseDevice
;
}
;
class
SkAutoDeviceTransformRestore
:
SkNoncopyable
{
public
:
SkAutoDeviceTransformRestore
(
SkBaseDevice
*
device
const
SkMatrix
&
localToDevice
)
:
fDevice
(
device
)
fPrevLocalToDevice
(
device
-
>
localToDevice
(
)
)
{
fDevice
-
>
setLocalToDevice
(
SkM44
(
localToDevice
)
)
;
}
~
SkAutoDeviceTransformRestore
(
)
{
fDevice
-
>
setLocalToDevice
(
fPrevLocalToDevice
)
;
}
private
:
SkBaseDevice
*
fDevice
;
const
SkM44
fPrevLocalToDevice
;
}
;
#
endif
