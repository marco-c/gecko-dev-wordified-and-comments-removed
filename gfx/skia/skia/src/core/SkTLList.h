#
ifndef
SkTLList_DEFINED
#
define
SkTLList_DEFINED
#
include
"
SkTInternalLList
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkUtility
.
h
"
template
<
typename
T
unsigned
int
N
>
class
SkTLList
:
SkNoncopyable
{
private
:
struct
Block
;
struct
Node
{
char
fObj
[
sizeof
(
T
)
]
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
Node
)
;
Block
*
fBlock
;
}
;
typedef
SkTInternalLList
<
Node
>
NodeList
;
public
:
class
Iter
;
SkTLList
(
)
:
fCount
(
0
)
{
fFirstBlock
.
fNodesInUse
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
N
;
+
+
i
)
{
fFreeList
.
addToHead
(
fFirstBlock
.
fNodes
+
i
)
;
fFirstBlock
.
fNodes
[
i
]
.
fBlock
=
&
fFirstBlock
;
}
this
-
>
validate
(
)
;
}
~
SkTLList
(
)
{
this
-
>
validate
(
)
;
typename
NodeList
:
:
Iter
iter
;
Node
*
node
=
iter
.
init
(
fList
Iter
:
:
kHead_IterStart
)
;
while
(
node
)
{
SkTCast
<
T
*
>
(
node
-
>
fObj
)
-
>
~
T
(
)
;
Block
*
block
=
node
-
>
fBlock
;
node
=
iter
.
next
(
)
;
if
(
0
=
=
-
-
block
-
>
fNodesInUse
)
{
for
(
unsigned
int
i
=
0
;
i
<
N
;
+
+
i
)
{
block
-
>
fNodes
[
i
]
.
~
Node
(
)
;
}
if
(
block
!
=
&
fFirstBlock
)
{
sk_free
(
block
)
;
}
}
}
}
template
<
typename
.
.
.
Args
>
T
*
addToHead
(
Args
&
&
.
.
.
args
)
{
this
-
>
validate
(
)
;
Node
*
node
=
this
-
>
createNode
(
)
;
fList
.
addToHead
(
node
)
;
this
-
>
validate
(
)
;
return
new
(
node
-
>
fObj
)
T
(
skstd
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
T
*
addToTail
(
Args
&
&
.
.
.
args
)
{
this
-
>
validate
(
)
;
Node
*
node
=
this
-
>
createNode
(
)
;
fList
.
addToTail
(
node
)
;
this
-
>
validate
(
)
;
return
new
(
node
-
>
fObj
)
T
(
skstd
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
T
*
addBefore
(
Iter
location
Args
&
&
.
.
.
args
)
{
this
-
>
validate
(
)
;
Node
*
node
=
this
-
>
createNode
(
)
;
fList
.
addBefore
(
node
location
.
getNode
(
)
)
;
this
-
>
validate
(
)
;
return
new
(
node
-
>
fObj
)
T
(
skstd
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
T
*
addAfter
(
Iter
location
Args
&
&
.
.
.
args
)
{
this
-
>
validate
(
)
;
Node
*
node
=
this
-
>
createNode
(
)
;
fList
.
addAfter
(
node
location
.
getNode
(
)
)
;
this
-
>
validate
(
)
;
return
new
(
node
-
>
fObj
)
T
(
skstd
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
Iter
headIter
(
)
const
{
return
Iter
(
*
this
Iter
:
:
kHead_IterStart
)
;
}
Iter
tailIter
(
)
const
{
return
Iter
(
*
this
Iter
:
:
kTail_IterStart
)
;
}
T
*
head
(
)
{
return
Iter
(
*
this
Iter
:
:
kHead_IterStart
)
.
get
(
)
;
}
T
*
tail
(
)
{
return
Iter
(
*
this
Iter
:
:
kTail_IterStart
)
.
get
(
)
;
}
const
T
*
head
(
)
const
{
return
Iter
(
*
this
Iter
:
:
kHead_IterStart
)
.
get
(
)
;
}
const
T
*
tail
(
)
const
{
return
Iter
(
*
this
Iter
:
:
kTail_IterStart
)
.
get
(
)
;
}
void
popHead
(
)
{
this
-
>
validate
(
)
;
Node
*
node
=
fList
.
head
(
)
;
if
(
node
)
{
this
-
>
removeNode
(
node
)
;
}
this
-
>
validate
(
)
;
}
void
popTail
(
)
{
this
-
>
validate
(
)
;
Node
*
node
=
fList
.
head
(
)
;
if
(
node
)
{
this
-
>
removeNode
(
node
)
;
}
this
-
>
validate
(
)
;
}
void
remove
(
T
*
t
)
{
this
-
>
validate
(
)
;
Node
*
node
=
reinterpret_cast
<
Node
*
>
(
t
)
;
SkASSERT
(
reinterpret_cast
<
T
*
>
(
node
-
>
fObj
)
=
=
t
)
;
this
-
>
removeNode
(
node
)
;
this
-
>
validate
(
)
;
}
void
reset
(
)
{
this
-
>
validate
(
)
;
Iter
iter
(
*
this
Iter
:
:
kHead_IterStart
)
;
while
(
iter
.
get
(
)
)
{
Iter
next
=
iter
;
next
.
next
(
)
;
this
-
>
remove
(
iter
.
get
(
)
)
;
iter
=
next
;
}
SkASSERT
(
0
=
=
fCount
)
;
this
-
>
validate
(
)
;
}
int
count
(
)
const
{
return
fCount
;
}
bool
isEmpty
(
)
const
{
this
-
>
validate
(
)
;
return
0
=
=
fCount
;
}
bool
operator
=
=
(
const
SkTLList
&
list
)
const
{
if
(
this
=
=
&
list
)
{
return
true
;
}
if
(
fCount
!
=
list
.
fCount
)
{
return
false
;
}
for
(
Iter
a
(
*
this
Iter
:
:
kHead_IterStart
)
b
(
list
Iter
:
:
kHead_IterStart
)
;
a
.
get
(
)
;
a
.
next
(
)
b
.
next
(
)
)
{
SkASSERT
(
b
.
get
(
)
)
;
if
(
!
(
*
a
.
get
(
)
=
=
*
b
.
get
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
SkTLList
&
list
)
const
{
return
!
(
*
this
=
=
list
)
;
}
class
Iter
:
private
NodeList
:
:
Iter
{
private
:
typedef
typename
NodeList
:
:
Iter
INHERITED
;
public
:
typedef
typename
INHERITED
:
:
IterStart
IterStart
;
static
const
IterStart
kHead_IterStart
=
INHERITED
:
:
kHead_IterStart
;
static
const
IterStart
kTail_IterStart
=
INHERITED
:
:
kTail_IterStart
;
Iter
(
)
{
}
Iter
(
const
SkTLList
&
list
IterStart
start
=
kHead_IterStart
)
{
INHERITED
:
:
init
(
list
.
fList
start
)
;
}
T
*
init
(
const
SkTLList
&
list
IterStart
start
=
kHead_IterStart
)
{
return
this
-
>
nodeToObj
(
INHERITED
:
:
init
(
list
.
fList
start
)
)
;
}
T
*
get
(
)
{
return
this
-
>
nodeToObj
(
INHERITED
:
:
get
(
)
)
;
}
T
*
next
(
)
{
return
this
-
>
nodeToObj
(
INHERITED
:
:
next
(
)
)
;
}
T
*
prev
(
)
{
return
this
-
>
nodeToObj
(
INHERITED
:
:
prev
(
)
)
;
}
Iter
&
operator
=
(
const
Iter
&
iter
)
{
INHERITED
:
:
operator
=
(
iter
)
;
return
*
this
;
}
private
:
friend
class
SkTLList
;
Node
*
getNode
(
)
{
return
INHERITED
:
:
get
(
)
;
}
T
*
nodeToObj
(
Node
*
node
)
{
if
(
node
)
{
return
reinterpret_cast
<
T
*
>
(
node
-
>
fObj
)
;
}
else
{
return
nullptr
;
}
}
}
;
private
:
struct
Block
{
int
fNodesInUse
;
Node
fNodes
[
N
]
;
}
;
Node
*
createNode
(
)
{
Node
*
node
=
fFreeList
.
head
(
)
;
if
(
node
)
{
fFreeList
.
remove
(
node
)
;
+
+
node
-
>
fBlock
-
>
fNodesInUse
;
}
else
{
SkASSERT
(
fCount
>
0
)
;
Block
*
block
=
reinterpret_cast
<
Block
*
>
(
sk_malloc_throw
(
sizeof
(
Block
)
)
)
;
node
=
&
block
-
>
fNodes
[
0
]
;
new
(
node
)
Node
;
node
-
>
fBlock
=
block
;
block
-
>
fNodesInUse
=
1
;
for
(
unsigned
int
i
=
1
;
i
<
N
;
+
+
i
)
{
new
(
block
-
>
fNodes
+
i
)
Node
;
fFreeList
.
addToHead
(
block
-
>
fNodes
+
i
)
;
block
-
>
fNodes
[
i
]
.
fBlock
=
block
;
}
}
+
+
fCount
;
return
node
;
}
void
removeNode
(
Node
*
node
)
{
SkASSERT
(
node
)
;
fList
.
remove
(
node
)
;
SkTCast
<
T
*
>
(
node
-
>
fObj
)
-
>
~
T
(
)
;
Block
*
block
=
node
-
>
fBlock
;
if
(
0
=
=
-
-
block
-
>
fNodesInUse
&
&
block
!
=
&
fFirstBlock
)
{
for
(
unsigned
int
i
=
0
;
i
<
N
;
+
+
i
)
{
if
(
block
-
>
fNodes
+
i
!
=
node
)
{
fFreeList
.
remove
(
block
-
>
fNodes
+
i
)
;
}
block
-
>
fNodes
[
i
]
.
~
Node
(
)
;
}
sk_free
(
block
)
;
}
else
{
fFreeList
.
addToHead
(
node
)
;
}
-
-
fCount
;
this
-
>
validate
(
)
;
}
void
validate
(
)
const
{
#
ifdef
SK_DEBUG
SkASSERT
(
(
0
=
=
fCount
)
=
=
fList
.
isEmpty
(
)
)
;
if
(
0
=
=
fCount
)
{
SkASSERT
(
fFreeList
.
countEntries
(
)
=
=
N
)
;
}
fList
.
validate
(
)
;
fFreeList
.
validate
(
)
;
typename
NodeList
:
:
Iter
iter
;
Node
*
freeNode
=
iter
.
init
(
fFreeList
Iter
:
:
kHead_IterStart
)
;
while
(
freeNode
)
{
SkASSERT
(
fFreeList
.
isInList
(
freeNode
)
)
;
Block
*
block
=
freeNode
-
>
fBlock
;
SkASSERT
(
block
-
>
fNodesInUse
>
0
|
|
block
=
=
&
fFirstBlock
)
;
SkASSERT
(
(
unsigned
)
block
-
>
fNodesInUse
<
N
)
;
int
activeCnt
=
0
;
int
freeCnt
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
N
;
+
+
i
)
{
bool
free
=
fFreeList
.
isInList
(
block
-
>
fNodes
+
i
)
;
bool
active
=
fList
.
isInList
(
block
-
>
fNodes
+
i
)
;
SkASSERT
(
free
!
=
active
)
;
activeCnt
+
=
active
;
freeCnt
+
=
free
;
}
SkASSERT
(
activeCnt
=
=
block
-
>
fNodesInUse
)
;
freeNode
=
iter
.
next
(
)
;
}
int
count
=
0
;
Node
*
activeNode
=
iter
.
init
(
fList
Iter
:
:
kHead_IterStart
)
;
while
(
activeNode
)
{
+
+
count
;
SkASSERT
(
fList
.
isInList
(
activeNode
)
)
;
Block
*
block
=
activeNode
-
>
fBlock
;
SkASSERT
(
block
-
>
fNodesInUse
>
0
&
&
(
unsigned
)
block
-
>
fNodesInUse
<
=
N
)
;
int
activeCnt
=
0
;
int
freeCnt
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
N
;
+
+
i
)
{
bool
free
=
fFreeList
.
isInList
(
block
-
>
fNodes
+
i
)
;
bool
active
=
fList
.
isInList
(
block
-
>
fNodes
+
i
)
;
SkASSERT
(
free
!
=
active
)
;
activeCnt
+
=
active
;
freeCnt
+
=
free
;
}
SkASSERT
(
activeCnt
=
=
block
-
>
fNodesInUse
)
;
activeNode
=
iter
.
next
(
)
;
}
SkASSERT
(
count
=
=
fCount
)
;
#
endif
}
NodeList
fList
;
NodeList
fFreeList
;
Block
fFirstBlock
;
int
fCount
;
}
;
#
endif
