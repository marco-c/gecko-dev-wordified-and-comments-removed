#
ifndef
SkHalf_DEFINED
#
define
SkHalf_DEFINED
#
include
"
SkNx
.
h
"
#
include
"
SkTypes
.
h
"
typedef
uint16_t
SkHalf
;
static
constexpr
uint16_t
SK_HalfMin
=
0x0400
;
static
constexpr
uint16_t
SK_HalfMax
=
0x7bff
;
static
constexpr
uint16_t
SK_HalfEpsilon
=
0x1400
;
static
constexpr
uint16_t
SK_Half1
=
0x3C00
;
float
SkHalfToFloat
(
SkHalf
h
)
;
SkHalf
SK_API
SkFloatToHalf
(
float
f
)
;
static
inline
Sk4f
SkHalfToFloat_finite_ftz
(
uint64_t
)
;
static
inline
Sk4h
SkFloatToHalf_finite_ftz
(
const
Sk4f
&
)
;
static
inline
Sk4f
SkHalfToFloat_finite_ftz
(
uint64_t
rgba
)
{
Sk4h
hs
=
Sk4h
:
:
Load
(
&
rgba
)
;
#
if
!
defined
(
SKNX_NO_SIMD
)
&
&
defined
(
SK_CPU_ARM64
)
float32x4_t
fs
;
asm
(
"
fcvtl
%
[
fs
]
.
4s
%
[
hs
]
.
4h
\
n
"
:
[
fs
]
"
=
w
"
(
fs
)
:
[
hs
]
"
w
"
(
hs
.
fVec
)
)
;
return
fs
;
#
else
Sk4i
bits
=
SkNx_cast
<
int
>
(
hs
)
sign
=
bits
&
0x00008000
positive
=
bits
^
sign
is_norm
=
0x03ff
<
positive
;
Sk4i
norm
=
(
positive
<
<
13
)
+
(
(
127
-
15
)
<
<
23
)
;
Sk4i
merged
=
(
sign
<
<
16
)
|
(
norm
&
is_norm
)
;
return
Sk4f
:
:
Load
(
&
merged
)
;
#
endif
}
static
inline
Sk4h
SkFloatToHalf_finite_ftz
(
const
Sk4f
&
fs
)
{
#
if
!
defined
(
SKNX_NO_SIMD
)
&
&
defined
(
SK_CPU_ARM64
)
float32x4_t
vec
=
fs
.
fVec
;
asm
(
"
fcvtn
%
[
vec
]
.
4h
%
[
vec
]
.
4s
\
n
"
:
[
vec
]
"
+
w
"
(
vec
)
)
;
return
vreinterpret_u16_f32
(
vget_low_f32
(
vec
)
)
;
#
else
Sk4i
bits
=
Sk4i
:
:
Load
(
&
fs
)
sign
=
bits
&
0x80000000
positive
=
bits
^
sign
will_be_norm
=
0x387fdfff
<
positive
;
Sk4i
norm
=
(
positive
-
(
(
127
-
15
)
<
<
23
)
)
>
>
13
;
Sk4i
merged
=
(
sign
>
>
16
)
|
(
will_be_norm
&
norm
)
;
return
SkNx_cast
<
uint16_t
>
(
merged
)
;
#
endif
}
#
endif
