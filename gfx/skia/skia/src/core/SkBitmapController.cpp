#
include
"
SkBitmap
.
h
"
#
include
"
SkBitmapController
.
h
"
#
include
"
SkBitmapProvider
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkTemplates
.
h
"
#
define
kHQ_RESIZE_METHOD
SkBitmapScaler
:
:
RESIZE_MITCHELL
SkBitmapController
:
:
State
*
SkBitmapController
:
:
requestBitmap
(
const
SkBitmapProvider
&
provider
const
SkMatrix
&
inv
SkFilterQuality
quality
void
*
storage
size_t
storageSize
)
{
if
(
!
provider
.
validForDrawing
(
)
)
{
return
nullptr
;
}
State
*
state
=
this
-
>
onRequestBitmap
(
provider
inv
quality
storage
storageSize
)
;
if
(
state
)
{
if
(
nullptr
=
=
state
-
>
fPixmap
.
addr
(
)
)
{
SkInPlaceDeleteCheck
(
state
storage
)
;
state
=
nullptr
;
}
}
return
state
;
}
#
include
"
SkBitmapCache
.
h
"
#
include
"
SkBitmapScaler
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkResourceCache
.
h
"
class
SkDefaultBitmapControllerState
:
public
SkBitmapController
:
:
State
{
public
:
SkDefaultBitmapControllerState
(
const
SkBitmapProvider
&
const
SkMatrix
&
inv
SkFilterQuality
)
;
private
:
SkBitmap
fResultBitmap
;
SkAutoTUnref
<
const
SkMipMap
>
fCurrMip
;
bool
processHQRequest
(
const
SkBitmapProvider
&
)
;
bool
processMediumRequest
(
const
SkBitmapProvider
&
)
;
}
;
static
inline
bool
cache_size_okay
(
const
SkBitmapProvider
&
provider
const
SkMatrix
&
invMat
)
{
size_t
maximumAllocation
=
SkResourceCache
:
:
GetEffectiveSingleAllocationByteLimit
(
)
;
if
(
0
=
=
maximumAllocation
)
{
return
true
;
}
const
size_t
size
=
provider
.
info
(
)
.
getSafeSize
(
provider
.
info
(
)
.
minRowBytes
(
)
)
;
return
size
<
(
maximumAllocation
*
invMat
.
getScaleX
(
)
*
invMat
.
getScaleY
(
)
)
;
}
bool
SkDefaultBitmapControllerState
:
:
processHQRequest
(
const
SkBitmapProvider
&
provider
)
{
if
(
fQuality
!
=
kHigh_SkFilterQuality
)
{
return
false
;
}
fQuality
=
kMedium_SkFilterQuality
;
if
(
kN32_SkColorType
!
=
provider
.
info
(
)
.
colorType
(
)
|
|
!
cache_size_okay
(
provider
fInvMatrix
)
|
|
fInvMatrix
.
hasPerspective
(
)
)
{
return
false
;
}
SkScalar
invScaleX
=
fInvMatrix
.
getScaleX
(
)
;
SkScalar
invScaleY
=
fInvMatrix
.
getScaleY
(
)
;
if
(
fInvMatrix
.
getType
(
)
&
SkMatrix
:
:
kAffine_Mask
)
{
SkSize
scale
;
if
(
!
fInvMatrix
.
decomposeScale
(
&
scale
)
)
{
return
false
;
}
invScaleX
=
scale
.
width
(
)
;
invScaleY
=
scale
.
height
(
)
;
}
if
(
SkScalarNearlyEqual
(
invScaleX
1
)
&
&
SkScalarNearlyEqual
(
invScaleY
1
)
)
{
return
false
;
}
#
ifndef
SK_SUPPORT_LEGACY_HQ_DOWNSAMPLING
if
(
invScaleX
>
1
|
|
invScaleY
>
1
)
{
return
false
;
}
#
endif
const
int
dstW
=
SkScalarRoundToScalar
(
provider
.
width
(
)
/
invScaleX
)
;
const
int
dstH
=
SkScalarRoundToScalar
(
provider
.
height
(
)
/
invScaleY
)
;
const
SkBitmapCacheDesc
desc
=
provider
.
makeCacheDesc
(
dstW
dstH
)
;
if
(
!
SkBitmapCache
:
:
FindWH
(
desc
&
fResultBitmap
)
)
{
SkBitmap
orig
;
if
(
!
provider
.
asBitmap
(
&
orig
)
)
{
return
false
;
}
SkAutoPixmapUnlock
src
;
if
(
!
orig
.
requestLock
(
&
src
)
)
{
return
false
;
}
if
(
!
SkBitmapScaler
:
:
Resize
(
&
fResultBitmap
src
.
pixmap
(
)
kHQ_RESIZE_METHOD
dstW
dstH
SkResourceCache
:
:
GetAllocator
(
)
)
)
{
return
false
;
}
SkASSERT
(
fResultBitmap
.
getPixels
(
)
)
;
fResultBitmap
.
setImmutable
(
)
;
if
(
!
provider
.
isVolatile
(
)
)
{
if
(
SkBitmapCache
:
:
AddWH
(
desc
fResultBitmap
)
)
{
provider
.
notifyAddedToCache
(
)
;
}
}
}
SkASSERT
(
fResultBitmap
.
getPixels
(
)
)
;
fInvMatrix
.
postScale
(
SkIntToScalar
(
dstW
)
/
provider
.
width
(
)
SkIntToScalar
(
dstH
)
/
provider
.
height
(
)
)
;
fQuality
=
kLow_SkFilterQuality
;
return
true
;
}
bool
SkDefaultBitmapControllerState
:
:
processMediumRequest
(
const
SkBitmapProvider
&
provider
)
{
SkASSERT
(
fQuality
<
=
kMedium_SkFilterQuality
)
;
if
(
fQuality
!
=
kMedium_SkFilterQuality
)
{
return
false
;
}
fQuality
=
kLow_SkFilterQuality
;
SkSize
invScaleSize
;
if
(
!
fInvMatrix
.
decomposeScale
(
&
invScaleSize
nullptr
)
)
{
return
false
;
}
SkScalar
invScale
=
SkScalarSqrt
(
invScaleSize
.
width
(
)
*
invScaleSize
.
height
(
)
)
;
if
(
invScale
>
SK_Scalar1
)
{
fCurrMip
.
reset
(
SkMipMapCache
:
:
FindAndRef
(
provider
.
makeCacheDesc
(
)
)
)
;
if
(
nullptr
=
=
fCurrMip
.
get
(
)
)
{
SkBitmap
orig
;
if
(
!
provider
.
asBitmap
(
&
orig
)
)
{
return
false
;
}
fCurrMip
.
reset
(
SkMipMapCache
:
:
AddAndRef
(
orig
)
)
;
if
(
nullptr
=
=
fCurrMip
.
get
(
)
)
{
return
false
;
}
}
if
(
nullptr
=
=
fCurrMip
-
>
data
(
)
)
{
sk_throw
(
)
;
}
SkScalar
levelScale
=
SkScalarInvert
(
invScale
)
;
SkMipMap
:
:
Level
level
;
if
(
fCurrMip
-
>
extractLevel
(
levelScale
&
level
)
)
{
SkScalar
invScaleFixup
=
level
.
fScale
;
fInvMatrix
.
postScale
(
invScaleFixup
invScaleFixup
)
;
const
SkImageInfo
info
=
provider
.
info
(
)
.
makeWH
(
level
.
fWidth
level
.
fHeight
)
;
return
fResultBitmap
.
installPixels
(
info
level
.
fPixels
level
.
fRowBytes
)
;
}
else
{
fCurrMip
.
reset
(
nullptr
)
;
}
}
return
false
;
}
SkDefaultBitmapControllerState
:
:
SkDefaultBitmapControllerState
(
const
SkBitmapProvider
&
provider
const
SkMatrix
&
inv
SkFilterQuality
qual
)
{
fInvMatrix
=
inv
;
fQuality
=
qual
;
if
(
this
-
>
processHQRequest
(
provider
)
|
|
this
-
>
processMediumRequest
(
provider
)
)
{
SkASSERT
(
fResultBitmap
.
getPixels
(
)
)
;
}
else
{
(
void
)
provider
.
asBitmap
(
&
fResultBitmap
)
;
fResultBitmap
.
lockPixels
(
)
;
}
SkASSERT
(
fQuality
<
=
kLow_SkFilterQuality
)
;
fPixmap
.
reset
(
fResultBitmap
.
info
(
)
fResultBitmap
.
getPixels
(
)
fResultBitmap
.
rowBytes
(
)
fResultBitmap
.
getColorTable
(
)
)
;
}
SkBitmapController
:
:
State
*
SkDefaultBitmapController
:
:
onRequestBitmap
(
const
SkBitmapProvider
&
bm
const
SkMatrix
&
inverse
SkFilterQuality
quality
void
*
storage
size_t
size
)
{
return
SkInPlaceNewCheck
<
SkDefaultBitmapControllerState
>
(
storage
size
bm
inverse
quality
)
;
}
