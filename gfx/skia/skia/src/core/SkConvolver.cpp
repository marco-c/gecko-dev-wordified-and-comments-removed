#
include
"
SkConvolver
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkTArray
.
h
"
namespace
{
class
CircularRowBuffer
{
public
:
CircularRowBuffer
(
int
destRowPixelWidth
int
maxYFilterSize
int
firstInputRow
)
:
fRowByteWidth
(
destRowPixelWidth
*
4
)
fNumRows
(
maxYFilterSize
)
fNextRow
(
0
)
fNextRowCoordinate
(
firstInputRow
)
{
fBuffer
.
reset
(
fRowByteWidth
*
maxYFilterSize
)
;
fRowAddresses
.
reset
(
fNumRows
)
;
}
unsigned
char
*
advanceRow
(
)
{
unsigned
char
*
row
=
&
fBuffer
[
fNextRow
*
fRowByteWidth
]
;
fNextRowCoordinate
+
+
;
fNextRow
+
+
;
if
(
fNextRow
=
=
fNumRows
)
{
fNextRow
=
0
;
}
return
row
;
}
unsigned
char
*
const
*
GetRowAddresses
(
int
*
firstRowIndex
)
{
*
firstRowIndex
=
fNextRowCoordinate
-
fNumRows
;
int
curRow
=
fNextRow
;
for
(
int
i
=
0
;
i
<
fNumRows
;
i
+
+
)
{
fRowAddresses
[
i
]
=
&
fBuffer
[
curRow
*
fRowByteWidth
]
;
curRow
+
+
;
if
(
curRow
=
=
fNumRows
)
{
curRow
=
0
;
}
}
return
&
fRowAddresses
[
0
]
;
}
private
:
SkTArray
<
unsigned
char
>
fBuffer
;
int
fRowByteWidth
;
int
fNumRows
;
int
fNextRow
;
int
fNextRowCoordinate
;
SkTArray
<
unsigned
char
*
>
fRowAddresses
;
}
;
}
SkConvolutionFilter1D
:
:
SkConvolutionFilter1D
(
)
:
fMaxFilter
(
0
)
{
}
SkConvolutionFilter1D
:
:
~
SkConvolutionFilter1D
(
)
{
}
void
SkConvolutionFilter1D
:
:
AddFilter
(
int
filterOffset
const
ConvolutionFixed
*
filterValues
int
filterLength
)
{
int
filterSize
=
filterLength
;
int
firstNonZero
=
0
;
while
(
firstNonZero
<
filterLength
&
&
filterValues
[
firstNonZero
]
=
=
0
)
{
firstNonZero
+
+
;
}
if
(
firstNonZero
<
filterLength
)
{
int
lastNonZero
=
filterLength
-
1
;
while
(
lastNonZero
>
=
0
&
&
filterValues
[
lastNonZero
]
=
=
0
)
{
lastNonZero
-
-
;
}
filterOffset
+
=
firstNonZero
;
filterLength
=
lastNonZero
+
1
-
firstNonZero
;
SkASSERT
(
filterLength
>
0
)
;
fFilterValues
.
append
(
filterLength
&
filterValues
[
firstNonZero
]
)
;
}
else
{
filterLength
=
0
;
}
FilterInstance
instance
;
instance
.
fDataLocation
=
(
static_cast
<
int
>
(
fFilterValues
.
count
(
)
)
-
filterLength
)
;
instance
.
fOffset
=
filterOffset
;
instance
.
fTrimmedLength
=
filterLength
;
instance
.
fLength
=
filterSize
;
fFilters
.
push
(
instance
)
;
fMaxFilter
=
SkTMax
(
fMaxFilter
filterLength
)
;
}
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
SkConvolutionFilter1D
:
:
GetSingleFilter
(
int
*
specifiedFilterlength
int
*
filterOffset
int
*
filterLength
)
const
{
const
FilterInstance
&
filter
=
fFilters
[
0
]
;
*
filterOffset
=
filter
.
fOffset
;
*
filterLength
=
filter
.
fTrimmedLength
;
*
specifiedFilterlength
=
filter
.
fLength
;
if
(
filter
.
fTrimmedLength
=
=
0
)
{
return
nullptr
;
}
return
&
fFilterValues
[
filter
.
fDataLocation
]
;
}
bool
BGRAConvolve2D
(
const
unsigned
char
*
sourceData
int
sourceByteRowStride
bool
sourceHasAlpha
const
SkConvolutionFilter1D
&
filterX
const
SkConvolutionFilter1D
&
filterY
int
outputByteRowStride
unsigned
char
*
output
)
{
int
maxYFilterSize
=
filterY
.
maxFilter
(
)
;
int
filterOffset
filterLength
;
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
=
filterY
.
FilterForValue
(
0
&
filterOffset
&
filterLength
)
;
int
nextXRow
=
filterOffset
;
int
rowBufferWidth
=
(
filterX
.
numValues
(
)
+
31
)
&
~
0x1F
;
int
rowBufferHeight
=
maxYFilterSize
+
(
SkOpts
:
:
convolve_4_rows_horizontally
!
=
nullptr
?
4
:
0
)
;
{
int64_t
size
=
sk_64_mul
(
rowBufferWidth
rowBufferHeight
)
;
if
(
size
>
100
*
1024
*
1024
)
{
return
false
;
}
}
CircularRowBuffer
rowBuffer
(
rowBufferWidth
rowBufferHeight
filterOffset
)
;
SkASSERT
(
outputByteRowStride
>
=
filterX
.
numValues
(
)
*
4
)
;
int
numOutputRows
=
filterY
.
numValues
(
)
;
int
lastFilterOffset
lastFilterLength
;
filterY
.
FilterForValue
(
numOutputRows
-
1
&
lastFilterOffset
&
lastFilterLength
)
;
for
(
int
outY
=
0
;
outY
<
numOutputRows
;
outY
+
+
)
{
filterValues
=
filterY
.
FilterForValue
(
outY
&
filterOffset
&
filterLength
)
;
while
(
nextXRow
<
filterOffset
+
filterLength
)
{
if
(
SkOpts
:
:
convolve_4_rows_horizontally
!
=
nullptr
&
&
nextXRow
+
3
<
lastFilterOffset
+
lastFilterLength
)
{
const
unsigned
char
*
src
[
4
]
;
unsigned
char
*
outRow
[
4
]
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
src
[
i
]
=
&
sourceData
[
(
uint64_t
)
(
nextXRow
+
i
)
*
sourceByteRowStride
]
;
outRow
[
i
]
=
rowBuffer
.
advanceRow
(
)
;
}
SkOpts
:
:
convolve_4_rows_horizontally
(
src
filterX
outRow
4
*
rowBufferWidth
)
;
nextXRow
+
=
4
;
}
else
{
SkOpts
:
:
convolve_horizontally
(
&
sourceData
[
(
uint64_t
)
nextXRow
*
sourceByteRowStride
]
filterX
rowBuffer
.
advanceRow
(
)
sourceHasAlpha
)
;
nextXRow
+
+
;
}
}
unsigned
char
*
curOutputRow
=
&
output
[
(
uint64_t
)
outY
*
outputByteRowStride
]
;
int
firstRowInCircularBuffer
;
unsigned
char
*
const
*
rowsToConvolve
=
rowBuffer
.
GetRowAddresses
(
&
firstRowInCircularBuffer
)
;
unsigned
char
*
const
*
firstRowForFilter
=
&
rowsToConvolve
[
filterOffset
-
firstRowInCircularBuffer
]
;
SkOpts
:
:
convolve_vertically
(
filterValues
filterLength
firstRowForFilter
filterX
.
numValues
(
)
curOutputRow
sourceHasAlpha
)
;
}
return
true
;
}
