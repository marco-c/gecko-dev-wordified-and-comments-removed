#
include
"
include
/
core
/
SkExecutor
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkSemaphore
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
src
/
base
/
SkNoDestructor
.
h
"
#
include
<
deque
>
#
include
<
thread
>
#
include
<
utility
>
using
namespace
skia_private
;
#
if
defined
(
SK_BUILD_FOR_WIN
)
#
include
"
src
/
base
/
SkLeanWindows
.
h
"
static
int
num_cores
(
)
{
SYSTEM_INFO
sysinfo
;
GetNativeSystemInfo
(
&
sysinfo
)
;
return
(
int
)
sysinfo
.
dwNumberOfProcessors
;
}
#
else
#
include
<
unistd
.
h
>
static
int
num_cores
(
)
{
return
(
int
)
sysconf
(
_SC_NPROCESSORS_ONLN
)
;
}
#
endif
SkExecutor
:
:
~
SkExecutor
(
)
{
}
class
SkTrivialExecutor
final
:
public
SkExecutor
{
public
:
void
add
(
std
:
:
function
<
void
(
void
)
>
work
int
)
override
{
work
(
)
;
}
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
this
-
>
add
(
std
:
:
move
(
work
)
0
)
;
}
int
discardAllPendingWork
(
)
override
{
return
0
;
}
}
;
static
SkExecutor
&
trivial_executor
(
)
{
static
SkNoDestructor
<
SkTrivialExecutor
>
executor
;
return
*
executor
;
}
static
SkExecutor
*
gDefaultExecutor
=
nullptr
;
SkExecutor
&
SkExecutor
:
:
GetDefault
(
)
{
if
(
gDefaultExecutor
)
{
return
*
gDefaultExecutor
;
}
return
trivial_executor
(
)
;
}
void
SkExecutor
:
:
SetDefault
(
SkExecutor
*
executor
)
{
gDefaultExecutor
=
executor
;
}
static
inline
std
:
:
function
<
void
(
void
)
>
pop
(
std
:
:
deque
<
std
:
:
function
<
void
(
void
)
>
>
*
list
)
{
std
:
:
function
<
void
(
void
)
>
fn
=
std
:
:
move
(
list
-
>
front
(
)
)
;
list
-
>
pop_front
(
)
;
return
fn
;
}
static
inline
std
:
:
function
<
void
(
void
)
>
pop
(
TArray
<
std
:
:
function
<
void
(
void
)
>
>
*
list
)
{
std
:
:
function
<
void
(
void
)
>
fn
=
std
:
:
move
(
list
-
>
back
(
)
)
;
list
-
>
pop_back
(
)
;
return
fn
;
}
template
<
typename
WorkList
>
class
SkThreadPool
final
:
public
SkExecutor
{
public
:
explicit
SkThreadPool
(
int
numWorkLists
int
threads
bool
allowBorrowing
)
:
fNumWorkLists
(
numWorkLists
<
1
?
1
:
numWorkLists
)
fAllowBorrowing
(
allowBorrowing
)
{
fWorkLists
=
std
:
:
make_unique
<
WorkList
[
]
>
(
fNumWorkLists
)
;
for
(
int
i
=
0
;
i
<
threads
;
i
+
+
)
{
fThreads
.
emplace_back
(
&
Loop
this
)
;
}
}
~
SkThreadPool
(
)
override
{
for
(
int
i
=
0
;
i
<
fThreads
.
size
(
)
;
i
+
+
)
{
this
-
>
add
(
nullptr
0
)
;
}
for
(
int
i
=
0
;
i
<
fThreads
.
size
(
)
;
i
+
+
)
{
fThreads
[
i
]
.
join
(
)
;
}
}
void
add
(
std
:
:
function
<
void
(
void
)
>
work
int
workList
)
override
{
workList
=
SkTPin
(
workList
0
fNumWorkLists
-
1
)
;
{
SkAutoMutexExclusive
lock
(
fWorkLock
)
;
fWorkLists
[
workList
]
.
emplace_back
(
std
:
:
move
(
work
)
)
;
}
fWorkAvailable
.
signal
(
1
)
;
}
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
this
-
>
add
(
std
:
:
move
(
work
)
0
)
;
}
int
discardAllPendingWork
(
)
override
{
SkAutoMutexExclusive
lock
(
fWorkLock
)
;
int
numDiscarded
=
0
;
for
(
int
i
=
0
;
i
<
fNumWorkLists
;
+
+
i
)
{
numDiscarded
+
=
fWorkLists
[
i
]
.
size
(
)
;
fWorkLists
[
i
]
.
clear
(
)
;
}
return
numDiscarded
;
}
void
borrow
(
)
override
{
if
(
fAllowBorrowing
&
&
fWorkAvailable
.
try_wait
(
)
)
{
SkAssertResult
(
this
-
>
do_work
(
)
)
;
}
}
private
:
bool
do_work
(
)
{
std
:
:
function
<
void
(
void
)
>
work
;
bool
workAvailable
=
false
;
{
SkAutoMutexExclusive
lock
(
fWorkLock
)
;
for
(
int
i
=
0
;
i
<
fNumWorkLists
;
+
+
i
)
{
if
(
!
fWorkLists
[
i
]
.
empty
(
)
)
{
workAvailable
=
true
;
work
=
pop
(
&
fWorkLists
[
i
]
)
;
break
;
}
}
}
if
(
!
workAvailable
)
{
return
true
;
}
if
(
!
work
)
{
return
false
;
}
work
(
)
;
return
true
;
}
static
void
Loop
(
void
*
ctx
)
{
auto
pool
=
(
SkThreadPool
*
)
ctx
;
do
{
pool
-
>
fWorkAvailable
.
wait
(
)
;
}
while
(
pool
-
>
do_work
(
)
)
;
}
using
Lock
=
SkMutex
;
TArray
<
std
:
:
thread
>
fThreads
;
const
int
fNumWorkLists
;
std
:
:
unique_ptr
<
WorkList
[
]
>
fWorkLists
SK_GUARDED_BY
(
fWorkLock
)
;
Lock
fWorkLock
;
SkSemaphore
fWorkAvailable
;
const
bool
fAllowBorrowing
;
}
;
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeFIFOThreadPool
(
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
std
:
:
deque
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
1
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeLIFOThreadPool
(
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
TArray
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
1
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeMultiListFIFOThreadPool
(
int
numWorkLists
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
std
:
:
deque
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
numWorkLists
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeMultiListLIFOThreadPool
(
int
numWorkLists
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
TArray
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
numWorkLists
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
