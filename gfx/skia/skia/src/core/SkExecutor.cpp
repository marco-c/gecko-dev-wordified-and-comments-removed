#
include
"
include
/
core
/
SkExecutor
.
h
"
#
include
"
include
/
private
/
SkSpinlock
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkSemaphore
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
<
deque
>
#
include
<
thread
>
using
namespace
skia_private
;
#
if
defined
(
SK_BUILD_FOR_WIN
)
#
include
"
src
/
base
/
SkLeanWindows
.
h
"
static
int
num_cores
(
)
{
SYSTEM_INFO
sysinfo
;
GetNativeSystemInfo
(
&
sysinfo
)
;
return
(
int
)
sysinfo
.
dwNumberOfProcessors
;
}
#
else
#
include
<
unistd
.
h
>
static
int
num_cores
(
)
{
return
(
int
)
sysconf
(
_SC_NPROCESSORS_ONLN
)
;
}
#
endif
SkExecutor
:
:
~
SkExecutor
(
)
{
}
class
SkTrivialExecutor
final
:
public
SkExecutor
{
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
work
(
)
;
}
}
;
static
SkExecutor
&
trivial_executor
(
)
{
static
auto
*
executor
=
new
SkTrivialExecutor
(
)
;
return
*
executor
;
}
static
SkExecutor
*
gDefaultExecutor
=
nullptr
;
SkExecutor
&
SkExecutor
:
:
GetDefault
(
)
{
if
(
gDefaultExecutor
)
{
return
*
gDefaultExecutor
;
}
return
trivial_executor
(
)
;
}
void
SkExecutor
:
:
SetDefault
(
SkExecutor
*
executor
)
{
gDefaultExecutor
=
executor
;
}
static
inline
std
:
:
function
<
void
(
void
)
>
pop
(
std
:
:
deque
<
std
:
:
function
<
void
(
void
)
>
>
*
list
)
{
std
:
:
function
<
void
(
void
)
>
fn
=
std
:
:
move
(
list
-
>
front
(
)
)
;
list
-
>
pop_front
(
)
;
return
fn
;
}
static
inline
std
:
:
function
<
void
(
void
)
>
pop
(
TArray
<
std
:
:
function
<
void
(
void
)
>
>
*
list
)
{
std
:
:
function
<
void
(
void
)
>
fn
=
std
:
:
move
(
list
-
>
back
(
)
)
;
list
-
>
pop_back
(
)
;
return
fn
;
}
template
<
typename
WorkList
>
class
SkThreadPool
final
:
public
SkExecutor
{
public
:
explicit
SkThreadPool
(
int
threads
bool
allowBorrowing
)
:
fAllowBorrowing
(
allowBorrowing
)
{
for
(
int
i
=
0
;
i
<
threads
;
i
+
+
)
{
fThreads
.
emplace_back
(
&
Loop
this
)
;
}
}
~
SkThreadPool
(
)
override
{
for
(
int
i
=
0
;
i
<
fThreads
.
size
(
)
;
i
+
+
)
{
this
-
>
add
(
nullptr
)
;
}
for
(
int
i
=
0
;
i
<
fThreads
.
size
(
)
;
i
+
+
)
{
fThreads
[
i
]
.
join
(
)
;
}
}
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
{
SkAutoMutexExclusive
lock
(
fWorkLock
)
;
fWork
.
emplace_back
(
std
:
:
move
(
work
)
)
;
}
fWorkAvailable
.
signal
(
1
)
;
}
void
borrow
(
)
override
{
if
(
fAllowBorrowing
&
&
fWorkAvailable
.
try_wait
(
)
)
{
SkAssertResult
(
this
-
>
do_work
(
)
)
;
}
}
private
:
bool
do_work
(
)
{
std
:
:
function
<
void
(
void
)
>
work
;
{
SkAutoMutexExclusive
lock
(
fWorkLock
)
;
SkASSERT
(
!
fWork
.
empty
(
)
)
;
work
=
pop
(
&
fWork
)
;
}
if
(
!
work
)
{
return
false
;
}
work
(
)
;
return
true
;
}
static
void
Loop
(
void
*
ctx
)
{
auto
pool
=
(
SkThreadPool
*
)
ctx
;
do
{
pool
-
>
fWorkAvailable
.
wait
(
)
;
}
while
(
pool
-
>
do_work
(
)
)
;
}
using
Lock
=
SkMutex
;
TArray
<
std
:
:
thread
>
fThreads
;
WorkList
fWork
;
Lock
fWorkLock
;
SkSemaphore
fWorkAvailable
;
bool
fAllowBorrowing
;
}
;
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeFIFOThreadPool
(
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
std
:
:
deque
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeLIFOThreadPool
(
int
threads
bool
allowBorrowing
)
{
using
WorkList
=
TArray
<
std
:
:
function
<
void
(
void
)
>
>
;
return
std
:
:
make_unique
<
SkThreadPool
<
WorkList
>
>
(
threads
>
0
?
threads
:
num_cores
(
)
allowBorrowing
)
;
}
