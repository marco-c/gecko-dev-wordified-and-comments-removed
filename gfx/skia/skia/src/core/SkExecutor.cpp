#
include
"
SkExecutor
.
h
"
#
include
"
SkMakeUnique
.
h
"
#
include
"
SkMutex
.
h
"
#
include
"
SkSemaphore
.
h
"
#
include
"
SkSpinlock
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkThreadUtils
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
windows
.
h
>
static
int
num_cores
(
)
{
SYSTEM_INFO
sysinfo
;
GetNativeSystemInfo
(
&
sysinfo
)
;
return
(
int
)
sysinfo
.
dwNumberOfProcessors
;
}
#
else
#
include
<
unistd
.
h
>
static
int
num_cores
(
)
{
return
(
int
)
sysconf
(
_SC_NPROCESSORS_ONLN
)
;
}
#
endif
SkExecutor
:
:
~
SkExecutor
(
)
{
}
class
SkTrivialExecutor
final
:
public
SkExecutor
{
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
work
(
)
;
}
}
;
static
SkTrivialExecutor
gTrivial
;
static
SkExecutor
*
gDefaultExecutor
=
&
gTrivial
;
SkExecutor
&
SkExecutor
:
:
GetDefault
(
)
{
return
*
gDefaultExecutor
;
}
void
SkExecutor
:
:
SetDefault
(
SkExecutor
*
executor
)
{
gDefaultExecutor
=
executor
?
executor
:
&
gTrivial
;
}
class
SkThreadPool
final
:
public
SkExecutor
{
public
:
explicit
SkThreadPool
(
int
threads
)
{
for
(
int
i
=
0
;
i
<
threads
;
i
+
+
)
{
fThreads
.
emplace_back
(
new
SkThread
(
&
Loop
this
)
)
;
fThreads
.
back
(
)
-
>
start
(
)
;
}
}
~
SkThreadPool
(
)
override
{
for
(
int
i
=
0
;
i
<
fThreads
.
count
(
)
;
i
+
+
)
{
this
-
>
add
(
nullptr
)
;
}
for
(
int
i
=
0
;
i
<
fThreads
.
count
(
)
;
i
+
+
)
{
fThreads
[
i
]
-
>
join
(
)
;
}
}
virtual
void
add
(
std
:
:
function
<
void
(
void
)
>
work
)
override
{
{
SkAutoExclusive
lock
(
fWorkLock
)
;
fWork
.
emplace_back
(
std
:
:
move
(
work
)
)
;
}
fWorkAvailable
.
signal
(
1
)
;
}
virtual
void
borrow
(
)
override
{
if
(
fWorkAvailable
.
try_wait
(
)
)
{
SkAssertResult
(
this
-
>
do_work
(
)
)
;
}
}
private
:
bool
do_work
(
)
{
std
:
:
function
<
void
(
void
)
>
work
;
{
SkAutoExclusive
lock
(
fWorkLock
)
;
SkASSERT
(
!
fWork
.
empty
(
)
)
;
work
=
std
:
:
move
(
fWork
.
back
(
)
)
;
fWork
.
pop_back
(
)
;
}
if
(
!
work
)
{
return
false
;
}
work
(
)
;
return
true
;
}
static
void
Loop
(
void
*
ctx
)
{
auto
pool
=
(
SkThreadPool
*
)
ctx
;
do
{
pool
-
>
fWorkAvailable
.
wait
(
)
;
}
while
(
pool
-
>
do_work
(
)
)
;
}
using
Lock
=
SkMutex
;
SkTArray
<
std
:
:
unique_ptr
<
SkThread
>
>
fThreads
;
SkTArray
<
std
:
:
function
<
void
(
void
)
>
>
fWork
;
Lock
fWorkLock
;
SkSemaphore
fWorkAvailable
;
}
;
std
:
:
unique_ptr
<
SkExecutor
>
SkExecutor
:
:
MakeThreadPool
(
int
threads
)
{
return
skstd
:
:
make_unique
<
SkThreadPool
>
(
threads
>
0
?
threads
:
num_cores
(
)
)
;
}
