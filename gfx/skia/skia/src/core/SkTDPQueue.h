#
ifndef
SkTDPQueue_DEFINED
#
define
SkTDPQueue_DEFINED
#
include
"
SkTDArray
.
h
"
template
<
typename
T
bool
(
*
LESS
)
(
const
T
&
const
T
&
)
int
*
(
*
INDEX
)
(
const
T
&
)
=
(
int
*
(
*
)
(
const
T
&
)
)
nullptr
>
class
SkTDPQueue
:
public
SkNoncopyable
{
public
:
SkTDPQueue
(
)
{
}
int
count
(
)
const
{
return
fArray
.
count
(
)
;
}
const
T
&
peek
(
)
const
{
return
fArray
[
0
]
;
}
T
&
peek
(
)
{
return
fArray
[
0
]
;
}
void
pop
(
)
{
this
-
>
validate
(
)
;
SkDEBUGCODE
(
if
(
SkToBool
(
INDEX
)
)
{
*
INDEX
(
fArray
[
0
]
)
=
-
1
;
}
)
if
(
1
=
=
fArray
.
count
(
)
)
{
fArray
.
pop
(
)
;
return
;
}
fArray
[
0
]
=
fArray
[
fArray
.
count
(
)
-
1
]
;
this
-
>
setIndex
(
0
)
;
fArray
.
pop
(
)
;
this
-
>
percolateDownIfNecessary
(
0
)
;
this
-
>
validate
(
)
;
}
void
insert
(
T
entry
)
{
this
-
>
validate
(
)
;
int
index
=
fArray
.
count
(
)
;
*
fArray
.
append
(
)
=
entry
;
this
-
>
setIndex
(
fArray
.
count
(
)
-
1
)
;
this
-
>
percolateUpIfNecessary
(
index
)
;
this
-
>
validate
(
)
;
}
void
remove
(
T
entry
)
{
SkASSERT
(
nullptr
!
=
INDEX
)
;
int
index
=
*
INDEX
(
entry
)
;
SkASSERT
(
index
>
=
0
&
&
index
<
fArray
.
count
(
)
)
;
this
-
>
validate
(
)
;
SkDEBUGCODE
(
*
INDEX
(
fArray
[
index
]
)
=
-
1
;
)
if
(
index
=
=
fArray
.
count
(
)
-
1
)
{
fArray
.
pop
(
)
;
return
;
}
fArray
[
index
]
=
fArray
[
fArray
.
count
(
)
-
1
]
;
fArray
.
pop
(
)
;
this
-
>
setIndex
(
index
)
;
this
-
>
percolateUpOrDown
(
index
)
;
this
-
>
validate
(
)
;
}
void
priorityDidChange
(
T
entry
)
{
SkASSERT
(
nullptr
!
=
INDEX
)
;
int
index
=
*
INDEX
(
entry
)
;
SkASSERT
(
index
>
=
0
&
&
index
<
fArray
.
count
(
)
)
;
this
-
>
validate
(
index
)
;
this
-
>
percolateUpOrDown
(
index
)
;
this
-
>
validate
(
)
;
}
T
at
(
int
i
)
const
{
return
fArray
[
i
]
;
}
private
:
static
int
LeftOf
(
int
x
)
{
SkASSERT
(
x
>
=
0
)
;
return
2
*
x
+
1
;
}
static
int
ParentOf
(
int
x
)
{
SkASSERT
(
x
>
0
)
;
return
(
x
-
1
)
>
>
1
;
}
void
percolateUpOrDown
(
int
index
)
{
SkASSERT
(
index
>
=
0
)
;
if
(
!
percolateUpIfNecessary
(
index
)
)
{
this
-
>
validate
(
index
)
;
this
-
>
percolateDownIfNecessary
(
index
)
;
}
}
bool
percolateUpIfNecessary
(
int
index
)
{
SkASSERT
(
index
>
=
0
)
;
bool
percolated
=
false
;
do
{
if
(
0
=
=
index
)
{
this
-
>
setIndex
(
index
)
;
return
percolated
;
}
int
p
=
ParentOf
(
index
)
;
if
(
LESS
(
fArray
[
index
]
fArray
[
p
]
)
)
{
SkTSwap
(
fArray
[
index
]
fArray
[
p
]
)
;
this
-
>
setIndex
(
index
)
;
index
=
p
;
percolated
=
true
;
}
else
{
this
-
>
setIndex
(
index
)
;
return
percolated
;
}
this
-
>
validate
(
index
)
;
}
while
(
true
)
;
}
void
percolateDownIfNecessary
(
int
index
)
{
SkASSERT
(
index
>
=
0
)
;
do
{
int
child
=
LeftOf
(
index
)
;
if
(
child
>
=
fArray
.
count
(
)
)
{
this
-
>
setIndex
(
index
)
;
return
;
}
if
(
child
+
1
>
=
fArray
.
count
(
)
)
{
if
(
LESS
(
fArray
[
child
]
fArray
[
index
]
)
)
{
SkTSwap
(
fArray
[
child
]
fArray
[
index
]
)
;
this
-
>
setIndex
(
child
)
;
this
-
>
setIndex
(
index
)
;
return
;
}
}
else
if
(
LESS
(
fArray
[
child
+
1
]
fArray
[
child
]
)
)
{
child
+
+
;
}
if
(
LESS
(
fArray
[
child
]
fArray
[
index
]
)
)
{
SkTSwap
(
fArray
[
child
]
fArray
[
index
]
)
;
this
-
>
setIndex
(
index
)
;
index
=
child
;
}
else
{
this
-
>
setIndex
(
index
)
;
return
;
}
this
-
>
validate
(
index
)
;
}
while
(
true
)
;
}
void
setIndex
(
int
index
)
{
SkASSERT
(
index
<
fArray
.
count
(
)
)
;
if
(
SkToBool
(
INDEX
)
)
{
*
INDEX
(
fArray
[
index
]
)
=
index
;
}
}
void
validate
(
int
excludedIndex
=
-
1
)
const
{
#
ifdef
SK_DEBUG
for
(
int
i
=
1
;
i
<
fArray
.
count
(
)
;
+
+
i
)
{
int
p
=
ParentOf
(
i
)
;
if
(
excludedIndex
!
=
p
&
&
excludedIndex
!
=
i
)
{
SkASSERT
(
!
(
LESS
(
fArray
[
i
]
fArray
[
p
]
)
)
)
;
SkASSERT
(
!
SkToBool
(
INDEX
)
|
|
*
INDEX
(
fArray
[
i
]
)
=
=
i
)
;
}
}
#
endif
}
SkTDArray
<
T
>
fArray
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
endif
