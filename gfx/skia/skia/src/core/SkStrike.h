#
ifndef
SkStrike_DEFINED
#
define
SkStrike_DEFINED
#
include
"
include
/
core
/
SkFontMetrics
.
h
"
#
include
"
include
/
core
/
SkFontTypes
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
private
/
SkTHash
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkDescriptor
.
h
"
#
include
"
src
/
core
/
SkGlyph
.
h
"
#
include
"
src
/
core
/
SkGlyphRunPainter
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
core
/
SkStrikeForGPU
.
h
"
#
include
<
memory
>
class
SkStrike
final
:
public
SkStrikeForGPU
{
public
:
SkStrike
(
const
SkDescriptor
&
desc
std
:
:
unique_ptr
<
SkScalerContext
>
scaler
const
SkFontMetrics
&
)
;
SkGlyph
*
glyph
(
SkPackedGlyphID
packedID
)
;
SkGlyph
*
glyph
(
SkGlyphID
glyphID
)
;
SkGlyph
*
glyph
(
SkGlyphID
SkPoint
)
;
SkGlyph
*
glyphFromPrototype
(
const
SkGlyphPrototype
&
p
void
*
image
=
nullptr
)
;
SkGlyph
*
glyphOrNull
(
SkPackedGlyphID
id
)
const
;
const
void
*
prepareImage
(
SkGlyph
*
glyph
)
;
SkGlyph
*
mergeGlyphAndImage
(
SkPackedGlyphID
toID
const
SkGlyph
&
from
)
;
const
SkPath
*
preparePath
(
SkGlyph
*
)
;
const
SkPath
*
preparePath
(
SkGlyph
*
glyph
const
SkPath
*
path
)
;
unsigned
getGlyphCount
(
)
const
;
int
countCachedGlyphs
(
)
const
;
void
findIntercepts
(
const
SkScalar
bounds
[
2
]
SkScalar
scale
SkScalar
xPos
SkGlyph
*
SkScalar
*
array
int
*
count
)
;
bool
belongsToCache
(
const
SkGlyph
*
glyph
)
const
;
const
SkGlyph
*
getCachedGlyphAnySubPix
(
SkGlyphID
SkPackedGlyphID
vetoID
=
SkPackedGlyphID
(
)
)
const
;
const
SkFontMetrics
&
getFontMetrics
(
)
const
{
return
fFontMetrics
;
}
SkMask
:
:
Format
getMaskFormat
(
)
const
{
return
fScalerContext
-
>
getMaskFormat
(
)
;
}
const
SkGlyphPositionRoundingSpec
&
roundingSpec
(
)
const
override
{
return
fRoundingSpec
;
}
const
SkDescriptor
&
getDescriptor
(
)
const
override
;
SkSpan
<
const
SkGlyph
*
>
metrics
(
SkSpan
<
const
SkGlyphID
>
glyphIDs
const
SkGlyph
*
results
[
]
)
;
SkSpan
<
const
SkGlyph
*
>
preparePaths
(
SkSpan
<
const
SkGlyphID
>
glyphIDs
const
SkGlyph
*
results
[
]
)
;
SkSpan
<
const
SkGlyph
*
>
prepareImages
(
SkSpan
<
const
SkPackedGlyphID
>
glyphIDs
const
SkGlyph
*
results
[
]
)
;
void
prepareForDrawingMasksCPU
(
SkDrawableGlyphBuffer
*
drawables
)
;
void
prepareForDrawingPathsCPU
(
SkDrawableGlyphBuffer
*
drawables
)
;
SkSpan
<
const
SkGlyphPos
>
prepareForDrawingRemoveEmpty
(
const
SkPackedGlyphID
packedGlyphIDs
[
]
const
SkPoint
positions
[
]
size_t
n
int
maxDimension
SkGlyphPos
results
[
]
)
override
;
void
onAboutToExitScope
(
)
override
;
size_t
getMemoryUsed
(
)
const
{
return
fMemoryUsed
;
}
void
dump
(
)
const
;
SkScalerContext
*
getScalerContext
(
)
const
{
return
fScalerContext
.
get
(
)
;
}
#
ifdef
SK_DEBUG
void
forceValidate
(
)
const
;
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
class
AutoValidate
:
SkNoncopyable
{
public
:
AutoValidate
(
const
SkStrike
*
cache
)
:
fCache
(
cache
)
{
if
(
fCache
)
{
fCache
-
>
validate
(
)
;
}
}
~
AutoValidate
(
)
{
if
(
fCache
)
{
fCache
-
>
validate
(
)
;
}
}
void
forget
(
)
{
fCache
=
nullptr
;
}
private
:
const
SkStrike
*
fCache
;
}
;
private
:
class
GlyphMapHashTraits
{
public
:
static
SkPackedGlyphID
GetKey
(
const
SkGlyph
*
glyph
)
{
return
glyph
-
>
getPackedID
(
)
;
}
static
uint32_t
Hash
(
SkPackedGlyphID
glyphId
)
{
return
glyphId
.
hash
(
)
;
}
}
;
SkGlyph
*
makeGlyph
(
SkPackedGlyphID
)
;
enum
PathDetail
{
kMetricsOnly
kMetricsAndPath
}
;
SkSpan
<
const
SkGlyph
*
>
internalPrepare
(
SkSpan
<
const
SkGlyphID
>
glyphIDs
PathDetail
pathDetail
const
SkGlyph
*
*
results
)
;
const
SkAutoDescriptor
fDesc
;
const
std
:
:
unique_ptr
<
SkScalerContext
>
fScalerContext
;
SkFontMetrics
fFontMetrics
;
SkTHashTable
<
SkGlyph
*
SkPackedGlyphID
GlyphMapHashTraits
>
fGlyphMap
;
static
constexpr
size_t
kMinGlyphCount
=
8
;
static
constexpr
size_t
kMinGlyphImageSize
=
16
*
8
;
static
constexpr
size_t
kMinAllocAmount
=
kMinGlyphImageSize
*
kMinGlyphCount
;
SkArenaAlloc
fAlloc
{
kMinAllocAmount
}
;
size_t
fMemoryUsed
;
const
SkGlyphPositionRoundingSpec
fRoundingSpec
;
}
;
#
endif
