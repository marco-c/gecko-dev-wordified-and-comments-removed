#
include
"
SkScalerContext
.
h
"
#
include
"
SkAutoPixmapStorage
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGlyph
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkMaskGamma
.
h
"
#
include
"
SkMatrix22
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkRasterizer
.
h
"
#
include
"
SkRasterClip
.
h
"
#
include
"
SkStroke
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
define
ComputeBWRowBytes
(
width
)
(
(
(
unsigned
)
(
width
)
+
7
)
>
>
3
)
void
SkGlyph
:
:
toMask
(
SkMask
*
mask
)
const
{
SkASSERT
(
mask
)
;
mask
-
>
fImage
=
(
uint8_t
*
)
fImage
;
mask
-
>
fBounds
.
set
(
fLeft
fTop
fLeft
+
fWidth
fTop
+
fHeight
)
;
mask
-
>
fRowBytes
=
this
-
>
rowBytes
(
)
;
mask
-
>
fFormat
=
static_cast
<
SkMask
:
:
Format
>
(
fMaskFormat
)
;
}
size_t
SkGlyph
:
:
computeImageSize
(
)
const
{
const
size_t
size
=
this
-
>
rowBytes
(
)
*
fHeight
;
switch
(
fMaskFormat
)
{
case
SkMask
:
:
k3D_Format
:
return
3
*
size
;
default
:
return
size
;
}
}
void
SkGlyph
:
:
zeroMetrics
(
)
{
fAdvanceX
=
0
;
fAdvanceY
=
0
;
fWidth
=
0
;
fHeight
=
0
;
fTop
=
0
;
fLeft
=
0
;
fRsbDelta
=
0
;
fLsbDelta
=
0
;
}
#
ifdef
SK_DEBUG
#
define
DUMP_RECx
#
endif
SkScalerContext
:
:
SkScalerContext
(
SkTypeface
*
typeface
const
SkScalerContextEffects
&
effects
const
SkDescriptor
*
desc
)
:
fRec
(
*
static_cast
<
const
Rec
*
>
(
desc
-
>
findEntry
(
kRec_SkDescriptorTag
nullptr
)
)
)
fTypeface
(
sk_ref_sp
(
typeface
)
)
fPathEffect
(
sk_ref_sp
(
effects
.
fPathEffect
)
)
fMaskFilter
(
sk_ref_sp
(
effects
.
fMaskFilter
)
)
fRasterizer
(
sk_ref_sp
(
effects
.
fRasterizer
)
)
fGenerateImageFromPath
(
fRec
.
fFrameWidth
>
0
|
|
fPathEffect
!
=
nullptr
|
|
fRasterizer
!
=
nullptr
)
fPreBlend
(
fMaskFilter
?
SkMaskGamma
:
:
PreBlend
(
)
:
SkScalerContext
:
:
GetMaskPreBlend
(
fRec
)
)
fPreBlendForFilter
(
fMaskFilter
?
SkScalerContext
:
:
GetMaskPreBlend
(
fRec
)
:
SkMaskGamma
:
:
PreBlend
(
)
)
{
#
ifdef
DUMP_REC
desc
-
>
assertChecksum
(
)
;
SkDebugf
(
"
SkScalerContext
checksum
%
x
count
%
d
length
%
d
\
n
"
desc
-
>
getChecksum
(
)
desc
-
>
getCount
(
)
desc
-
>
getLength
(
)
)
;
SkDebugf
(
"
textsize
%
g
prescale
%
g
preskew
%
g
post
[
%
g
%
g
%
g
%
g
]
\
n
"
rec
-
>
fTextSize
rec
-
>
fPreScaleX
rec
-
>
fPreSkewX
rec
-
>
fPost2x2
[
0
]
[
0
]
rec
-
>
fPost2x2
[
0
]
[
1
]
rec
-
>
fPost2x2
[
1
]
[
0
]
rec
-
>
fPost2x2
[
1
]
[
1
]
)
;
SkDebugf
(
"
frame
%
g
miter
%
g
hints
%
d
framefill
%
d
format
%
d
join
%
d
cap
%
d
\
n
"
rec
-
>
fFrameWidth
rec
-
>
fMiterLimit
rec
-
>
fHints
rec
-
>
fFrameAndFill
rec
-
>
fMaskFormat
rec
-
>
fStrokeJoin
rec
-
>
fStrokeCap
)
;
SkDebugf
(
"
pathEffect
%
x
maskFilter
%
x
\
n
"
desc
-
>
findEntry
(
kPathEffect_SkDescriptorTag
nullptr
)
desc
-
>
findEntry
(
kMaskFilter_SkDescriptorTag
nullptr
)
)
;
#
endif
}
SkScalerContext
:
:
~
SkScalerContext
(
)
{
}
void
SkScalerContext
:
:
getAdvance
(
SkGlyph
*
glyph
)
{
glyph
-
>
fMaskFormat
=
MASK_FORMAT_JUST_ADVANCE
;
generateAdvance
(
glyph
)
;
}
void
SkScalerContext
:
:
getMetrics
(
SkGlyph
*
glyph
)
{
generateMetrics
(
glyph
)
;
if
(
(
fRec
.
fFlags
&
SkScalerContext
:
:
kDevKernText_Flag
)
=
=
0
)
{
glyph
-
>
fLsbDelta
=
glyph
-
>
fRsbDelta
=
0
;
}
if
(
0
=
=
glyph
-
>
fWidth
|
|
0
=
=
glyph
-
>
fHeight
)
{
glyph
-
>
fWidth
=
0
;
glyph
-
>
fHeight
=
0
;
glyph
-
>
fTop
=
0
;
glyph
-
>
fLeft
=
0
;
glyph
-
>
fMaskFormat
=
0
;
return
;
}
if
(
fGenerateImageFromPath
)
{
SkPath
devPath
fillPath
;
SkMatrix
fillToDevMatrix
;
this
-
>
internalGetPath
(
*
glyph
&
fillPath
&
devPath
&
fillToDevMatrix
)
;
if
(
fRasterizer
)
{
SkMask
mask
;
if
(
fRasterizer
-
>
rasterize
(
fillPath
fillToDevMatrix
nullptr
fMaskFilter
.
get
(
)
&
mask
SkMask
:
:
kJustComputeBounds_CreateMode
)
)
{
glyph
-
>
fLeft
=
mask
.
fBounds
.
fLeft
;
glyph
-
>
fTop
=
mask
.
fBounds
.
fTop
;
glyph
-
>
fWidth
=
SkToU16
(
mask
.
fBounds
.
width
(
)
)
;
glyph
-
>
fHeight
=
SkToU16
(
mask
.
fBounds
.
height
(
)
)
;
}
else
{
goto
SK_ERROR
;
}
}
else
{
const
SkIRect
ir
=
devPath
.
getBounds
(
)
.
roundOut
(
)
;
if
(
ir
.
isEmpty
(
)
|
|
!
ir
.
is16Bit
(
)
)
{
goto
SK_ERROR
;
}
glyph
-
>
fLeft
=
ir
.
fLeft
;
glyph
-
>
fTop
=
ir
.
fTop
;
glyph
-
>
fWidth
=
SkToU16
(
ir
.
width
(
)
)
;
glyph
-
>
fHeight
=
SkToU16
(
ir
.
height
(
)
)
;
if
(
glyph
-
>
fWidth
>
0
)
{
switch
(
fRec
.
fMaskFormat
)
{
case
SkMask
:
:
kLCD16_Format
:
glyph
-
>
fWidth
+
=
2
;
glyph
-
>
fLeft
-
=
1
;
break
;
default
:
break
;
}
}
}
}
if
(
SkMask
:
:
kARGB32_Format
!
=
glyph
-
>
fMaskFormat
)
{
glyph
-
>
fMaskFormat
=
fRec
.
fMaskFormat
;
}
if
(
(
fGenerateImageFromPath
|
|
fMaskFilter
)
&
&
SkMask
:
:
kARGB32_Format
=
=
glyph
-
>
fMaskFormat
)
{
glyph
-
>
fMaskFormat
=
SkMask
:
:
kA8_Format
;
}
if
(
fMaskFilter
)
{
SkMask
src
dst
;
SkMatrix
matrix
;
glyph
-
>
toMask
(
&
src
)
;
fRec
.
getMatrixFrom2x2
(
&
matrix
)
;
src
.
fImage
=
nullptr
;
if
(
fMaskFilter
-
>
filterMask
(
&
dst
src
matrix
nullptr
)
)
{
if
(
dst
.
fBounds
.
isEmpty
(
)
|
|
!
dst
.
fBounds
.
is16Bit
(
)
)
{
goto
SK_ERROR
;
}
SkASSERT
(
dst
.
fImage
=
=
nullptr
)
;
glyph
-
>
fLeft
=
dst
.
fBounds
.
fLeft
;
glyph
-
>
fTop
=
dst
.
fBounds
.
fTop
;
glyph
-
>
fWidth
=
SkToU16
(
dst
.
fBounds
.
width
(
)
)
;
glyph
-
>
fHeight
=
SkToU16
(
dst
.
fBounds
.
height
(
)
)
;
glyph
-
>
fMaskFormat
=
dst
.
fFormat
;
}
}
return
;
SK_ERROR
:
glyph
-
>
fLeft
=
0
;
glyph
-
>
fTop
=
0
;
glyph
-
>
fWidth
=
0
;
glyph
-
>
fHeight
=
0
;
glyph
-
>
fMaskFormat
=
fRec
.
fMaskFormat
;
}
#
define
SK_SHOW_TEXT_BLIT_COVERAGE
0
static
void
applyLUTToA8Mask
(
const
SkMask
&
mask
const
uint8_t
*
lut
)
{
uint8_t
*
SK_RESTRICT
dst
=
(
uint8_t
*
)
mask
.
fImage
;
unsigned
rowBytes
=
mask
.
fRowBytes
;
for
(
int
y
=
mask
.
fBounds
.
height
(
)
-
1
;
y
>
=
0
;
-
-
y
)
{
for
(
int
x
=
mask
.
fBounds
.
width
(
)
-
1
;
x
>
=
0
;
-
-
x
)
{
dst
[
x
]
=
lut
[
dst
[
x
]
]
;
}
dst
+
=
rowBytes
;
}
}
template
<
bool
APPLY_PREBLEND
>
static
void
pack4xHToLCD16
(
const
SkPixmap
&
src
const
SkMask
&
dst
const
SkMaskGamma
:
:
PreBlend
&
maskPreBlend
)
{
#
define
SAMPLES_PER_PIXEL
4
#
define
LCD_PER_PIXEL
3
SkASSERT
(
kAlpha_8_SkColorType
=
=
src
.
colorType
(
)
)
;
SkASSERT
(
SkMask
:
:
kLCD16_Format
=
=
dst
.
fFormat
)
;
const
int
sample_width
=
src
.
width
(
)
;
const
int
height
=
src
.
height
(
)
;
uint16_t
*
dstP
=
(
uint16_t
*
)
dst
.
fImage
;
size_t
dstRB
=
dst
.
fRowBytes
;
static
const
unsigned
int
coefficients
[
LCD_PER_PIXEL
]
[
SAMPLES_PER_PIXEL
*
3
]
=
{
{
0x03
0x0b
0x1c
0x33
0x40
0x39
0x24
0x10
0x05
0x01
0x00
0x00
}
{
0x00
0x02
0x08
0x16
0x2b
0x3d
0x3d
0x2b
0x16
0x08
0x02
0x00
}
{
0x00
0x00
0x01
0x05
0x10
0x24
0x39
0x40
0x33
0x1c
0x0b
0x03
}
}
;
for
(
int
y
=
0
;
y
<
height
;
+
+
y
)
{
const
uint8_t
*
srcP
=
src
.
addr8
(
0
y
)
;
for
(
int
sample_x
=
-
4
pixel_x
=
0
;
sample_x
<
sample_width
+
4
;
sample_x
+
=
4
+
+
pixel_x
)
{
int
fir
[
LCD_PER_PIXEL
]
=
{
0
}
;
for
(
int
sample_index
=
SkMax32
(
0
sample_x
-
4
)
coeff_index
=
sample_index
-
(
sample_x
-
4
)
;
sample_index
<
SkMin32
(
sample_x
+
8
sample_width
)
;
+
+
sample_index
+
+
coeff_index
)
{
int
sample_value
=
srcP
[
sample_index
]
;
for
(
int
subpxl_index
=
0
;
subpxl_index
<
LCD_PER_PIXEL
;
+
+
subpxl_index
)
{
fir
[
subpxl_index
]
+
=
coefficients
[
subpxl_index
]
[
coeff_index
]
*
sample_value
;
}
}
for
(
int
subpxl_index
=
0
;
subpxl_index
<
LCD_PER_PIXEL
;
+
+
subpxl_index
)
{
fir
[
subpxl_index
]
/
=
0x100
;
fir
[
subpxl_index
]
=
SkMin32
(
fir
[
subpxl_index
]
255
)
;
}
U8CPU
r
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
fir
[
0
]
maskPreBlend
.
fR
)
;
U8CPU
g
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
fir
[
1
]
maskPreBlend
.
fG
)
;
U8CPU
b
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
fir
[
2
]
maskPreBlend
.
fB
)
;
#
if
SK_SHOW_TEXT_BLIT_COVERAGE
r
=
SkMax32
(
r
10
)
;
g
=
SkMax32
(
g
10
)
;
b
=
SkMax32
(
b
10
)
;
#
endif
dstP
[
pixel_x
]
=
SkPack888ToRGB16
(
r
g
b
)
;
}
dstP
=
(
uint16_t
*
)
(
(
char
*
)
dstP
+
dstRB
)
;
}
}
static
inline
int
convert_8_to_1
(
unsigned
byte
)
{
SkASSERT
(
byte
<
=
0xFF
)
;
return
byte
>
>
7
;
}
static
uint8_t
pack_8_to_1
(
const
uint8_t
alpha
[
8
]
)
{
unsigned
bits
=
0
;
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
bits
<
<
=
1
;
bits
|
=
convert_8_to_1
(
alpha
[
i
]
)
;
}
return
SkToU8
(
bits
)
;
}
static
void
packA8ToA1
(
const
SkMask
&
mask
const
uint8_t
*
src
size_t
srcRB
)
{
const
int
height
=
mask
.
fBounds
.
height
(
)
;
const
int
width
=
mask
.
fBounds
.
width
(
)
;
const
int
octs
=
width
>
>
3
;
const
int
leftOverBits
=
width
&
7
;
uint8_t
*
dst
=
mask
.
fImage
;
const
int
dstPad
=
mask
.
fRowBytes
-
SkAlign8
(
width
)
/
8
;
SkASSERT
(
dstPad
>
=
0
)
;
SkASSERT
(
width
>
=
0
)
;
SkASSERT
(
srcRB
>
=
(
size_t
)
width
)
;
const
size_t
srcPad
=
srcRB
-
width
;
for
(
int
y
=
0
;
y
<
height
;
+
+
y
)
{
for
(
int
i
=
0
;
i
<
octs
;
+
+
i
)
{
*
dst
+
+
=
pack_8_to_1
(
src
)
;
src
+
=
8
;
}
if
(
leftOverBits
>
0
)
{
unsigned
bits
=
0
;
int
shift
=
7
;
for
(
int
i
=
0
;
i
<
leftOverBits
;
+
+
i
-
-
shift
)
{
bits
|
=
convert_8_to_1
(
*
src
+
+
)
<
<
shift
;
}
*
dst
+
+
=
bits
;
}
src
+
=
srcPad
;
dst
+
=
dstPad
;
}
}
static
void
generateMask
(
const
SkMask
&
mask
const
SkPath
&
path
const
SkMaskGamma
:
:
PreBlend
&
maskPreBlend
)
{
SkPaint
paint
;
int
srcW
=
mask
.
fBounds
.
width
(
)
;
int
srcH
=
mask
.
fBounds
.
height
(
)
;
int
dstW
=
srcW
;
int
dstH
=
srcH
;
int
dstRB
=
mask
.
fRowBytes
;
SkMatrix
matrix
;
matrix
.
setTranslate
(
-
SkIntToScalar
(
mask
.
fBounds
.
fLeft
)
-
SkIntToScalar
(
mask
.
fBounds
.
fTop
)
)
;
paint
.
setAntiAlias
(
SkMask
:
:
kBW_Format
!
=
mask
.
fFormat
)
;
switch
(
mask
.
fFormat
)
{
case
SkMask
:
:
kBW_Format
:
dstRB
=
0
;
break
;
case
SkMask
:
:
kA8_Format
:
break
;
case
SkMask
:
:
kLCD16_Format
:
dstW
=
4
*
dstW
-
8
;
matrix
.
setTranslate
(
-
SkIntToScalar
(
mask
.
fBounds
.
fLeft
+
1
)
-
SkIntToScalar
(
mask
.
fBounds
.
fTop
)
)
;
matrix
.
postScale
(
SkIntToScalar
(
4
)
SK_Scalar1
)
;
dstRB
=
0
;
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
mask
format
"
)
;
}
SkRasterClip
clip
;
clip
.
setRect
(
SkIRect
:
:
MakeWH
(
dstW
dstH
)
)
;
const
SkImageInfo
info
=
SkImageInfo
:
:
MakeA8
(
dstW
dstH
)
;
SkAutoPixmapStorage
dst
;
if
(
0
=
=
dstRB
)
{
if
(
!
dst
.
tryAlloc
(
info
)
)
{
sk_bzero
(
mask
.
fImage
mask
.
computeImageSize
(
)
)
;
return
;
}
}
else
{
dst
.
reset
(
info
mask
.
fImage
dstRB
)
;
}
sk_bzero
(
dst
.
writable_addr
(
)
dst
.
getSafeSize
(
)
)
;
SkDraw
draw
;
draw
.
fDst
=
dst
;
draw
.
fRC
=
&
clip
;
draw
.
fMatrix
=
&
matrix
;
draw
.
drawPath
(
path
paint
)
;
switch
(
mask
.
fFormat
)
{
case
SkMask
:
:
kBW_Format
:
packA8ToA1
(
mask
dst
.
addr8
(
0
0
)
dst
.
rowBytes
(
)
)
;
break
;
case
SkMask
:
:
kA8_Format
:
if
(
maskPreBlend
.
isApplicable
(
)
)
{
applyLUTToA8Mask
(
mask
maskPreBlend
.
fG
)
;
}
break
;
case
SkMask
:
:
kLCD16_Format
:
if
(
maskPreBlend
.
isApplicable
(
)
)
{
pack4xHToLCD16
<
true
>
(
dst
mask
maskPreBlend
)
;
}
else
{
pack4xHToLCD16
<
false
>
(
dst
mask
maskPreBlend
)
;
}
break
;
default
:
break
;
}
}
static
void
extract_alpha
(
const
SkMask
&
dst
const
SkPMColor
*
srcRow
size_t
srcRB
)
{
int
width
=
dst
.
fBounds
.
width
(
)
;
int
height
=
dst
.
fBounds
.
height
(
)
;
int
dstRB
=
dst
.
fRowBytes
;
uint8_t
*
dstRow
=
dst
.
fImage
;
for
(
int
y
=
0
;
y
<
height
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
width
;
+
+
x
)
{
dstRow
[
x
]
=
SkGetPackedA32
(
srcRow
[
x
]
)
;
}
for
(
int
x
=
width
;
x
<
dstRB
;
+
+
x
)
{
dstRow
[
x
]
=
0
;
}
dstRow
+
=
dstRB
;
srcRow
=
(
const
SkPMColor
*
)
(
(
const
char
*
)
srcRow
+
srcRB
)
;
}
}
void
SkScalerContext
:
:
getImage
(
const
SkGlyph
&
origGlyph
)
{
const
SkGlyph
*
glyph
=
&
origGlyph
;
SkGlyph
tmpGlyph
;
SkAutoMalloc
tmpGlyphImageStorage
;
SkASSERT
(
!
fGenerateImageFromPath
|
|
SkMask
:
:
kARGB32_Format
!
=
origGlyph
.
fMaskFormat
)
;
if
(
fMaskFilter
)
{
tmpGlyph
.
initGlyphIdFrom
(
origGlyph
)
;
SkMaskFilter
*
mf
=
fMaskFilter
.
release
(
)
;
this
-
>
getMetrics
(
&
tmpGlyph
)
;
fMaskFilter
=
sk_sp
<
SkMaskFilter
>
(
mf
)
;
SkASSERT
(
tmpGlyph
.
fWidth
<
=
origGlyph
.
fWidth
)
;
SkASSERT
(
tmpGlyph
.
fHeight
<
=
origGlyph
.
fHeight
)
;
if
(
tmpGlyph
.
fMaskFormat
=
=
origGlyph
.
fMaskFormat
)
{
tmpGlyph
.
fImage
=
origGlyph
.
fImage
;
}
else
{
tmpGlyphImageStorage
.
reset
(
tmpGlyph
.
computeImageSize
(
)
)
;
tmpGlyph
.
fImage
=
tmpGlyphImageStorage
.
get
(
)
;
}
glyph
=
&
tmpGlyph
;
}
if
(
fGenerateImageFromPath
)
{
SkPath
devPath
fillPath
;
SkMatrix
fillToDevMatrix
;
SkMask
mask
;
this
-
>
internalGetPath
(
*
glyph
&
fillPath
&
devPath
&
fillToDevMatrix
)
;
glyph
-
>
toMask
(
&
mask
)
;
if
(
fRasterizer
)
{
mask
.
fFormat
=
SkMask
:
:
kA8_Format
;
sk_bzero
(
glyph
-
>
fImage
mask
.
computeImageSize
(
)
)
;
if
(
!
fRasterizer
-
>
rasterize
(
fillPath
fillToDevMatrix
nullptr
fMaskFilter
.
get
(
)
&
mask
SkMask
:
:
kJustRenderImage_CreateMode
)
)
{
return
;
}
if
(
fPreBlend
.
isApplicable
(
)
)
{
applyLUTToA8Mask
(
mask
fPreBlend
.
fG
)
;
}
}
else
{
SkASSERT
(
SkMask
:
:
kARGB32_Format
!
=
mask
.
fFormat
)
;
generateMask
(
mask
devPath
fPreBlend
)
;
}
}
else
{
generateImage
(
*
glyph
)
;
}
if
(
fMaskFilter
)
{
SkMask
srcM
dstM
;
SkMatrix
matrix
;
SkASSERT
(
SkMask
:
:
k3D_Format
!
=
glyph
-
>
fMaskFormat
)
;
SkAutoSMalloc
<
32
*
32
>
a8storage
;
glyph
-
>
toMask
(
&
srcM
)
;
if
(
SkMask
:
:
kARGB32_Format
=
=
srcM
.
fFormat
)
{
srcM
.
fFormat
=
SkMask
:
:
kA8_Format
;
srcM
.
fRowBytes
=
SkAlign4
(
srcM
.
fBounds
.
width
(
)
)
;
size_t
size
=
srcM
.
computeImageSize
(
)
;
a8storage
.
reset
(
size
)
;
srcM
.
fImage
=
(
uint8_t
*
)
a8storage
.
get
(
)
;
extract_alpha
(
srcM
(
const
SkPMColor
*
)
glyph
-
>
fImage
glyph
-
>
rowBytes
(
)
)
;
}
fRec
.
getMatrixFrom2x2
(
&
matrix
)
;
if
(
fMaskFilter
-
>
filterMask
(
&
dstM
srcM
matrix
nullptr
)
)
{
int
width
=
SkFastMin32
(
origGlyph
.
fWidth
dstM
.
fBounds
.
width
(
)
)
;
int
height
=
SkFastMin32
(
origGlyph
.
fHeight
dstM
.
fBounds
.
height
(
)
)
;
int
dstRB
=
origGlyph
.
rowBytes
(
)
;
int
srcRB
=
dstM
.
fRowBytes
;
const
uint8_t
*
src
=
(
const
uint8_t
*
)
dstM
.
fImage
;
uint8_t
*
dst
=
(
uint8_t
*
)
origGlyph
.
fImage
;
if
(
SkMask
:
:
k3D_Format
=
=
dstM
.
fFormat
)
{
height
*
=
3
;
}
while
(
-
-
height
>
=
0
)
{
memcpy
(
dst
src
width
)
;
src
+
=
srcRB
;
dst
+
=
dstRB
;
}
SkMask
:
:
FreeImage
(
dstM
.
fImage
)
;
if
(
fPreBlendForFilter
.
isApplicable
(
)
)
{
applyLUTToA8Mask
(
srcM
fPreBlendForFilter
.
fG
)
;
}
}
}
}
void
SkScalerContext
:
:
getPath
(
const
SkGlyph
&
glyph
SkPath
*
path
)
{
this
-
>
internalGetPath
(
glyph
nullptr
path
nullptr
)
;
}
void
SkScalerContext
:
:
getFontMetrics
(
SkPaint
:
:
FontMetrics
*
fm
)
{
this
-
>
generateFontMetrics
(
fm
)
;
}
SkUnichar
SkScalerContext
:
:
generateGlyphToChar
(
uint16_t
glyph
)
{
return
0
;
}
void
SkScalerContext
:
:
internalGetPath
(
const
SkGlyph
&
glyph
SkPath
*
fillPath
SkPath
*
devPath
SkMatrix
*
fillToDevMatrix
)
{
SkPath
path
;
generatePath
(
glyph
&
path
)
;
if
(
fRec
.
fFlags
&
SkScalerContext
:
:
kSubpixelPositioning_Flag
)
{
SkFixed
dx
=
glyph
.
getSubXFixed
(
)
;
SkFixed
dy
=
glyph
.
getSubYFixed
(
)
;
if
(
dx
|
dy
)
{
path
.
offset
(
SkFixedToScalar
(
dx
)
SkFixedToScalar
(
dy
)
)
;
}
}
if
(
fRec
.
fFrameWidth
>
0
|
|
fPathEffect
!
=
nullptr
)
{
SkPath
localPath
;
SkMatrix
matrix
inverse
;
fRec
.
getMatrixFrom2x2
(
&
matrix
)
;
if
(
!
matrix
.
invert
(
&
inverse
)
)
{
return
;
}
path
.
transform
(
inverse
&
localPath
)
;
SkStrokeRec
rec
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
if
(
fRec
.
fFrameWidth
>
0
)
{
rec
.
setStrokeStyle
(
fRec
.
fFrameWidth
SkToBool
(
fRec
.
fFlags
&
kFrameAndFill_Flag
)
)
;
rec
.
setStrokeParams
(
(
SkPaint
:
:
Cap
)
fRec
.
fStrokeCap
(
SkPaint
:
:
Join
)
fRec
.
fStrokeJoin
fRec
.
fMiterLimit
)
;
}
if
(
fPathEffect
)
{
SkPath
effectPath
;
if
(
fPathEffect
-
>
filterPath
(
&
effectPath
localPath
&
rec
nullptr
)
)
{
localPath
.
swap
(
effectPath
)
;
}
}
if
(
rec
.
needToApply
(
)
)
{
SkPath
strokePath
;
if
(
rec
.
applyToPath
(
&
strokePath
localPath
)
)
{
localPath
.
swap
(
strokePath
)
;
}
}
if
(
fillToDevMatrix
)
{
*
fillToDevMatrix
=
matrix
;
}
if
(
devPath
)
{
localPath
.
transform
(
matrix
devPath
)
;
}
if
(
fillPath
)
{
fillPath
-
>
swap
(
localPath
)
;
}
}
else
{
if
(
fillToDevMatrix
)
{
fillToDevMatrix
-
>
reset
(
)
;
}
if
(
devPath
)
{
if
(
fillPath
=
=
nullptr
)
{
devPath
-
>
swap
(
path
)
;
}
else
{
*
devPath
=
path
;
}
}
if
(
fillPath
)
{
fillPath
-
>
swap
(
path
)
;
}
}
if
(
devPath
)
{
devPath
-
>
updateBoundsCache
(
)
;
}
if
(
fillPath
)
{
fillPath
-
>
updateBoundsCache
(
)
;
}
}
void
SkScalerContextRec
:
:
getMatrixFrom2x2
(
SkMatrix
*
dst
)
const
{
dst
-
>
setAll
(
fPost2x2
[
0
]
[
0
]
fPost2x2
[
0
]
[
1
]
0
fPost2x2
[
1
]
[
0
]
fPost2x2
[
1
]
[
1
]
0
0
0
1
)
;
}
void
SkScalerContextRec
:
:
getLocalMatrix
(
SkMatrix
*
m
)
const
{
SkPaint
:
:
SetTextMatrix
(
m
fTextSize
fPreScaleX
fPreSkewX
)
;
}
void
SkScalerContextRec
:
:
getSingleMatrix
(
SkMatrix
*
m
)
const
{
this
-
>
getLocalMatrix
(
m
)
;
SkMatrix
deviceMatrix
;
this
-
>
getMatrixFrom2x2
(
&
deviceMatrix
)
;
m
-
>
postConcat
(
deviceMatrix
)
;
}
bool
SkScalerContextRec
:
:
computeMatrices
(
PreMatrixScale
preMatrixScale
SkVector
*
s
SkMatrix
*
sA
SkMatrix
*
GsA
SkMatrix
*
G_inv
SkMatrix
*
A_out
)
{
SkMatrix
A
;
this
-
>
getSingleMatrix
(
&
A
)
;
if
(
A_out
)
{
*
A_out
=
A
;
}
SkVector
diag
[
4
]
=
{
{
A
.
getScaleX
(
)
A
.
getSkewY
(
)
}
{
A
.
getSkewX
(
)
A
.
getScaleY
(
)
}
{
A
.
getScaleX
(
)
+
A
.
getSkewX
(
)
A
.
getScaleY
(
)
+
A
.
getSkewY
(
)
}
{
A
.
getScaleX
(
)
-
A
.
getSkewX
(
)
A
.
getScaleY
(
)
-
A
.
getSkewY
(
)
}
}
;
if
(
diag
[
0
]
.
lengthSqd
(
)
<
=
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
|
|
diag
[
1
]
.
lengthSqd
(
)
<
=
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
|
|
diag
[
2
]
.
lengthSqd
(
)
<
=
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
|
|
diag
[
3
]
.
lengthSqd
(
)
<
=
SK_ScalarNearlyZero
*
SK_ScalarNearlyZero
)
{
s
-
>
fX
=
SK_Scalar1
;
s
-
>
fY
=
SK_Scalar1
;
sA
-
>
setScale
(
0
0
)
;
if
(
GsA
)
{
GsA
-
>
setScale
(
0
0
)
;
}
if
(
G_inv
)
{
G_inv
-
>
reset
(
)
;
}
return
false
;
}
SkMatrix
GA
;
bool
skewedOrFlipped
=
A
.
getSkewX
(
)
|
|
A
.
getSkewY
(
)
|
|
A
.
getScaleX
(
)
<
0
|
|
A
.
getScaleY
(
)
<
0
;
if
(
skewedOrFlipped
)
{
SkPoint
h
=
SkPoint
:
:
Make
(
SK_Scalar1
0
)
;
A
.
mapPoints
(
&
h
1
)
;
SkMatrix
G
;
SkComputeGivensRotation
(
h
&
G
)
;
GA
=
G
;
GA
.
preConcat
(
A
)
;
if
(
G_inv
)
{
G_inv
-
>
setAll
(
G
.
get
(
SkMatrix
:
:
kMScaleX
)
-
G
.
get
(
SkMatrix
:
:
kMSkewX
)
G
.
get
(
SkMatrix
:
:
kMTransX
)
-
G
.
get
(
SkMatrix
:
:
kMSkewY
)
G
.
get
(
SkMatrix
:
:
kMScaleY
)
G
.
get
(
SkMatrix
:
:
kMTransY
)
G
.
get
(
SkMatrix
:
:
kMPersp0
)
G
.
get
(
SkMatrix
:
:
kMPersp1
)
G
.
get
(
SkMatrix
:
:
kMPersp2
)
)
;
}
}
else
{
GA
=
A
;
if
(
G_inv
)
{
G_inv
-
>
reset
(
)
;
}
}
switch
(
preMatrixScale
)
{
case
kFull_PreMatrixScale
:
s
-
>
fX
=
SkScalarAbs
(
GA
.
get
(
SkMatrix
:
:
kMScaleX
)
)
;
s
-
>
fY
=
SkScalarAbs
(
GA
.
get
(
SkMatrix
:
:
kMScaleY
)
)
;
break
;
case
kVertical_PreMatrixScale
:
{
SkScalar
yScale
=
SkScalarAbs
(
GA
.
get
(
SkMatrix
:
:
kMScaleY
)
)
;
s
-
>
fX
=
yScale
;
s
-
>
fY
=
yScale
;
break
;
}
case
kVerticalInteger_PreMatrixScale
:
{
SkScalar
realYScale
=
SkScalarAbs
(
GA
.
get
(
SkMatrix
:
:
kMScaleY
)
)
;
SkScalar
intYScale
=
SkScalarRoundToScalar
(
realYScale
)
;
if
(
intYScale
=
=
0
)
{
intYScale
=
SK_Scalar1
;
}
s
-
>
fX
=
intYScale
;
s
-
>
fY
=
intYScale
;
break
;
}
}
if
(
!
skewedOrFlipped
&
&
(
(
kFull_PreMatrixScale
=
=
preMatrixScale
)
|
|
(
kVertical_PreMatrixScale
=
=
preMatrixScale
&
&
A
.
getScaleX
(
)
=
=
A
.
getScaleY
(
)
)
)
)
{
sA
-
>
reset
(
)
;
}
else
if
(
!
skewedOrFlipped
&
&
kVertical_PreMatrixScale
=
=
preMatrixScale
)
{
sA
-
>
reset
(
)
;
sA
-
>
setScaleX
(
A
.
getScaleX
(
)
/
s
-
>
fY
)
;
}
else
{
*
sA
=
A
;
sA
-
>
preScale
(
SkScalarInvert
(
s
-
>
fX
)
SkScalarInvert
(
s
-
>
fY
)
)
;
}
if
(
GsA
)
{
*
GsA
=
GA
;
GsA
-
>
preScale
(
SkScalarInvert
(
s
-
>
fX
)
SkScalarInvert
(
s
-
>
fY
)
)
;
}
return
true
;
}
SkAxisAlignment
SkScalerContext
:
:
computeAxisAlignmentForHText
(
)
{
if
(
0
=
=
fRec
.
fPost2x2
[
1
]
[
0
]
)
{
return
kX_SkAxisAlignment
;
}
if
(
0
=
=
fRec
.
fPost2x2
[
0
]
[
0
]
)
{
return
kY_SkAxisAlignment
;
}
return
kNone_SkAxisAlignment
;
}
class
SkScalerContext_Empty
:
public
SkScalerContext
{
public
:
SkScalerContext_Empty
(
SkTypeface
*
typeface
const
SkScalerContextEffects
&
effects
const
SkDescriptor
*
desc
)
:
SkScalerContext
(
typeface
effects
desc
)
{
}
protected
:
unsigned
generateGlyphCount
(
)
override
{
return
0
;
}
uint16_t
generateCharToGlyph
(
SkUnichar
uni
)
override
{
return
0
;
}
void
generateAdvance
(
SkGlyph
*
glyph
)
override
{
glyph
-
>
zeroMetrics
(
)
;
}
void
generateMetrics
(
SkGlyph
*
glyph
)
override
{
glyph
-
>
zeroMetrics
(
)
;
}
void
generateImage
(
const
SkGlyph
&
glyph
)
override
{
}
void
generatePath
(
const
SkGlyph
&
glyph
SkPath
*
path
)
override
{
}
void
generateFontMetrics
(
SkPaint
:
:
FontMetrics
*
metrics
)
override
{
if
(
metrics
)
{
sk_bzero
(
metrics
sizeof
(
*
metrics
)
)
;
}
}
}
;
extern
SkScalerContext
*
SkCreateColorScalerContext
(
const
SkDescriptor
*
desc
)
;
SkScalerContext
*
SkTypeface
:
:
createScalerContext
(
const
SkScalerContextEffects
&
effects
const
SkDescriptor
*
desc
bool
allowFailure
)
const
{
SkScalerContext
*
c
=
this
-
>
onCreateScalerContext
(
effects
desc
)
;
if
(
!
c
&
&
!
allowFailure
)
{
c
=
new
SkScalerContext_Empty
(
const_cast
<
SkTypeface
*
>
(
this
)
effects
desc
)
;
}
return
c
;
}
