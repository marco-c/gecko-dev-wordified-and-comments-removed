#
include
"
src
/
core
/
SkEdge
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkSafe32
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkFDot6
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
static
inline
SkFixed
SkFDot6ToFixedDiv2
(
SkFDot6
value
)
{
return
SkLeftShift
(
value
16
-
6
-
1
)
;
}
#
if
defined
(
SK_DEBUG
)
void
SkEdge
:
:
dump
(
)
const
{
SkASSERT
(
fSegmentCount
=
=
0
)
;
SkDebugf
(
"
line
edge
:
firstY
:
%
d
lastY
:
%
d
x
:
%
g
dx
/
dy
:
%
g
\
n
"
"
\
twinding
:
%
d
curveShift
:
%
u
\
n
"
fFirstY
fLastY
SkFixedToFloat
(
fX
)
SkFixedToFloat
(
fDxDy
)
static_cast
<
int8_t
>
(
fWinding
)
fCurveShift
)
;
}
void
SkQuadraticEdge
:
:
dump
(
)
const
{
SkDebugf
(
"
quad
edge
;
%
u
segment
(
s
)
left
:
firstY
:
%
d
lastY
:
%
d
x
:
%
g
dx
/
dy
:
%
g
\
n
"
"
\
tqx
:
%
g
qy
:
%
g
dqx
:
%
g
dqy
:
%
g
ddqx
:
%
g
ddqy
:
%
g
qLastX
:
%
g
qLastY
:
%
g
\
n
"
"
\
twinding
:
%
d
curveShift
:
%
u
\
n
"
fSegmentCount
fFirstY
fLastY
SkFixedToFloat
(
fX
)
SkFixedToFloat
(
fDxDy
)
SkFixedToFloat
(
fQx
)
SkFixedToFloat
(
fQy
)
SkFixedToFloat
(
fQDxDt
)
SkFixedToFloat
(
fQDyDt
)
SkFixedToFloat
(
fQD2xDt2
)
SkFixedToFloat
(
fQD2yDt2
)
SkFixedToFloat
(
fQLastX
)
SkFixedToFloat
(
fQLastY
)
static_cast
<
int8_t
>
(
fWinding
)
fCurveShift
)
;
}
void
SkCubicEdge
:
:
dump
(
)
const
{
SkDebugf
(
"
cube
edge
;
%
u
segment
(
s
)
left
:
firstY
:
%
d
lastY
:
%
d
x
:
%
g
dx
/
dy
:
%
g
\
n
"
"
qx
:
%
g
qy
:
%
g
dcx
:
%
g
dcy
:
%
g
ddcx
:
%
g
ddcy
:
%
g
dddcx
:
%
g
dddcy
:
%
g
cLastX
:
%
g
cLastY
:
%
g
\
n
"
"
\
twinding
:
%
d
curveShift
:
%
u
dShift
:
%
u
\
n
"
fSegmentCount
fFirstY
fLastY
SkFixedToFloat
(
fX
)
SkFixedToFloat
(
fDxDy
)
SkFixedToFloat
(
fCx
)
SkFixedToFloat
(
fCy
)
SkFixedToFloat
(
fCDxDt
)
SkFixedToFloat
(
fCDyDt
)
SkFixedToFloat
(
fCD2xDt2
)
SkFixedToFloat
(
fCD2yDt2
)
SkFixedToFloat
(
fCD3xDt3
)
SkFixedToFloat
(
fCD3yDt3
)
SkFixedToFloat
(
fCLastX
)
SkFixedToFloat
(
fCLastY
)
static_cast
<
int8_t
>
(
fWinding
)
fCurveShift
fCubicDShift
)
;
}
#
endif
bool
SkEdge
:
:
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkIRect
*
clip
)
{
SkFDot6
x0
y0
x1
y1
;
#
ifdef
SK_RASTERIZE_EVEN_ROUNDING
x0
=
SkScalarRoundToFDot6
(
p0
.
fX
0
)
;
y0
=
SkScalarRoundToFDot6
(
p0
.
fY
0
)
;
x1
=
SkScalarRoundToFDot6
(
p1
.
fX
0
)
;
y1
=
SkScalarRoundToFDot6
(
p1
.
fY
0
)
;
#
else
x0
=
SkFloatToFDot6
(
p0
.
fX
)
;
y0
=
SkFloatToFDot6
(
p0
.
fY
)
;
x1
=
SkFloatToFDot6
(
p1
.
fX
)
;
y1
=
SkFloatToFDot6
(
p1
.
fY
)
;
#
endif
Winding
winding
=
Winding
:
:
kCW
;
if
(
y0
>
y1
)
{
std
:
:
swap
(
x0
x1
)
;
std
:
:
swap
(
y0
y1
)
;
winding
=
Winding
:
:
kCCW
;
}
int
top
=
SkFDot6Round
(
y0
)
;
int
bot
=
SkFDot6Round
(
y1
)
;
if
(
top
=
=
bot
)
{
return
false
;
}
if
(
clip
&
&
(
top
>
=
clip
-
>
fBottom
|
|
bot
<
=
clip
-
>
fTop
)
)
{
return
false
;
}
SkFixed
slope
=
SkFDot6Div
(
x1
-
x0
y1
-
y0
)
;
const
SkFDot6
dy
=
SkEdge_Compute_DY
(
top
y0
)
;
fX
=
SkFDot6ToFixed
(
x0
+
SkFixedMul
(
slope
dy
)
)
;
fDxDy
=
slope
;
fFirstY
=
top
;
fLastY
=
bot
-
1
;
fEdgeType
=
Type
:
:
kLine
;
fSegmentCount
=
0
;
fWinding
=
winding
;
fCurveShift
=
0
;
if
(
clip
)
{
this
-
>
chopLineWithClip
(
*
clip
)
;
}
return
true
;
}
bool
SkEdge
:
:
nextSegment
(
)
{
SkDEBUGFAILF
(
"
Shouldn
'
t
be
asking
a
linear
edge
to
go
to
the
next
curve
.
"
)
;
return
false
;
}
bool
SkEdge
:
:
updateLine
(
SkFixed
xStart
SkFixed
yStart
SkFixed
xEnd
SkFixed
yEnd
)
{
SkASSERT
(
fWinding
=
=
Winding
:
:
kCW
|
|
fWinding
=
=
Winding
:
:
kCCW
)
;
SkASSERT
(
fSegmentCount
!
=
0
)
;
const
SkFDot6
y0
=
SkFixedToFDot6
(
yStart
)
;
const
SkFDot6
y1
=
SkFixedToFDot6
(
yEnd
)
;
SkASSERT
(
y0
<
=
y1
)
;
const
int
top
=
SkFDot6Round
(
y0
)
;
const
int
bot
=
SkFDot6Round
(
y1
)
;
if
(
top
=
=
bot
)
{
return
false
;
}
const
SkFDot6
x0
=
SkFixedToFDot6
(
xStart
)
;
const
SkFDot6
x1
=
SkFixedToFDot6
(
xEnd
)
;
SkFixed
slope
=
SkFDot6Div
(
x1
-
x0
y1
-
y0
)
;
const
SkFDot6
dy
=
SkEdge_Compute_DY
(
top
y0
)
;
fX
=
SkFDot6ToFixed
(
x0
+
SkFixedMul
(
slope
dy
)
)
;
fDxDy
=
slope
;
fFirstY
=
top
;
fLastY
=
bot
-
1
;
return
true
;
}
void
SkEdge
:
:
chopLineWithClip
(
const
SkIRect
&
clip
)
{
int
top
=
fFirstY
;
SkASSERT
(
top
<
clip
.
fBottom
)
;
if
(
top
<
clip
.
fTop
)
{
SkASSERT
(
fLastY
>
=
clip
.
fTop
)
;
fX
+
=
fDxDy
*
(
clip
.
fTop
-
top
)
;
fFirstY
=
clip
.
fTop
;
}
}
#
define
MAX_COEFF_SHIFT
6
static
inline
SkFDot6
cheap_distance
(
SkFDot6
dx
SkFDot6
dy
)
{
dx
=
SkAbs32
(
dx
)
;
dy
=
SkAbs32
(
dy
)
;
if
(
dx
>
dy
)
{
return
dx
+
(
dy
/
2
)
;
}
return
dy
+
(
dx
/
2
)
;
}
static
inline
int
diff_to_shift
(
SkFDot6
dx
SkFDot6
dy
int
accuracy
)
{
SkFDot6
dist
=
cheap_distance
(
dx
dy
)
;
dist
=
(
dist
+
(
1
<
<
(
2
+
accuracy
)
)
)
>
>
(
3
+
accuracy
)
;
return
(
32
-
SkCLZ
(
dist
)
)
>
>
1
;
}
bool
SkQuadraticEdge
:
:
setQuadratic
(
const
SkPoint
pts
[
3
]
)
{
SkFDot6
x0
y0
x1
y1
x2
y2
;
#
if
defined
(
SK_RASTERIZE_EVEN_ROUNDING
)
x0
=
SkScalarRoundToFDot6
(
pts
[
0
]
.
fX
0
)
;
y0
=
SkScalarRoundToFDot6
(
pts
[
0
]
.
fY
0
)
;
x1
=
SkScalarRoundToFDot6
(
pts
[
1
]
.
fX
0
)
;
y1
=
SkScalarRoundToFDot6
(
pts
[
1
]
.
fY
0
)
;
x2
=
SkScalarRoundToFDot6
(
pts
[
2
]
.
fX
0
)
;
y2
=
SkScalarRoundToFDot6
(
pts
[
2
]
.
fY
0
)
;
#
else
x0
=
SkFloatToFDot6
(
pts
[
0
]
.
fX
)
;
y0
=
SkFloatToFDot6
(
pts
[
0
]
.
fY
)
;
x1
=
SkFloatToFDot6
(
pts
[
1
]
.
fX
)
;
y1
=
SkFloatToFDot6
(
pts
[
1
]
.
fY
)
;
x2
=
SkFloatToFDot6
(
pts
[
2
]
.
fX
)
;
y2
=
SkFloatToFDot6
(
pts
[
2
]
.
fY
)
;
#
endif
Winding
winding
=
Winding
:
:
kCW
;
if
(
y0
>
y2
)
{
std
:
:
swap
(
x0
x2
)
;
std
:
:
swap
(
y0
y2
)
;
winding
=
Winding
:
:
kCCW
;
}
SkASSERTF
(
y0
<
=
y1
&
&
y1
<
=
y2
"
curve
must
be
monotonic
"
)
;
const
int
top
=
SkFDot6Round
(
y0
)
;
const
int
bot
=
SkFDot6Round
(
y2
)
;
if
(
top
=
=
bot
)
{
return
false
;
}
SkFDot6
deltaX
=
(
2
*
x1
-
x0
-
x2
)
>
>
2
;
SkFDot6
deltaY
=
(
2
*
y1
-
y0
-
y2
)
>
>
2
;
int
shift
=
diff_to_shift
(
deltaX
deltaY
0
)
;
SkASSERT
(
shift
>
=
0
)
;
if
(
shift
=
=
0
)
{
shift
=
1
;
}
else
if
(
shift
>
MAX_COEFF_SHIFT
)
{
shift
=
MAX_COEFF_SHIFT
;
}
fWinding
=
winding
;
fEdgeType
=
Type
:
:
kQuad
;
fSegmentCount
=
SkToU8
(
1
<
<
shift
)
;
fCurveShift
=
SkToU8
(
shift
-
1
)
;
SkFixed
A_half
=
SkFDot6ToFixedDiv2
(
x0
-
x1
-
x1
+
x2
)
;
SkFixed
B_half
=
SkFDot6ToFixed
(
x1
-
x0
)
;
fQDxDt
=
B_half
+
(
A_half
>
>
shift
)
;
fQD2xDt2
=
A_half
>
>
(
shift
-
1
)
;
A_half
=
SkFDot6ToFixedDiv2
(
y0
-
y1
-
y1
+
y2
)
;
B_half
=
SkFDot6ToFixed
(
y1
-
y0
)
;
fQDyDt
=
B_half
+
(
A_half
>
>
shift
)
;
fQD2yDt2
=
A_half
>
>
(
shift
-
1
)
;
fQx
=
SkFDot6ToFixed
(
x0
)
;
fQy
=
SkFDot6ToFixed
(
y0
)
;
fQLastX
=
SkFDot6ToFixed
(
x2
)
;
fQLastY
=
SkFDot6ToFixed
(
y2
)
;
return
this
-
>
nextSegment
(
)
;
}
bool
SkQuadraticEdge
:
:
nextSegment
(
)
{
bool
success
;
int
count
=
fSegmentCount
;
SkFixed
oldx
=
fQx
;
SkFixed
oldy
=
fQy
;
SkFixed
dx
=
fQDxDt
;
SkFixed
dy
=
fQDyDt
;
SkFixed
newx
newy
;
int
shift
=
fCurveShift
;
SkASSERT
(
count
>
0
)
;
do
{
if
(
-
-
count
>
0
)
{
newx
=
oldx
+
(
dx
>
>
shift
)
;
dx
+
=
fQD2xDt2
;
newy
=
oldy
+
(
dy
>
>
shift
)
;
dy
+
=
fQD2yDt2
;
}
else
{
newx
=
fQLastX
;
newy
=
fQLastY
;
}
success
=
this
-
>
updateLine
(
oldx
oldy
newx
newy
)
;
oldx
=
newx
;
oldy
=
newy
;
}
while
(
count
>
0
&
&
!
success
)
;
fQx
=
newx
;
fQy
=
newy
;
fQDxDt
=
dx
;
fQDyDt
=
dy
;
fSegmentCount
=
SkToU8
(
count
)
;
return
success
;
}
static
inline
int
SkFDot6UpShift
(
SkFDot6
x
int
upShift
)
{
SkASSERT
(
(
SkLeftShift
(
x
upShift
)
>
>
upShift
)
=
=
x
)
;
return
SkLeftShift
(
x
upShift
)
;
}
static
SkFDot6
cubic_delta_from_line
(
SkFDot6
a
SkFDot6
b
SkFDot6
c
SkFDot6
d
)
{
SkFDot6
oneThird
=
(
a
*
8
-
b
*
15
+
6
*
c
+
d
)
*
19
>
>
9
;
SkFDot6
twoThird
=
(
a
+
6
*
b
-
c
*
15
+
d
*
8
)
*
19
>
>
9
;
return
std
:
:
max
(
SkAbs32
(
oneThird
)
SkAbs32
(
twoThird
)
)
;
}
bool
SkCubicEdge
:
:
setCubic
(
const
SkPoint
pts
[
4
]
)
{
SkFDot6
x0
y0
x1
y1
x2
y2
x3
y3
;
#
if
defined
(
SK_RASTERIZE_EVEN_ROUNDING
)
x0
=
SkScalarRoundToFDot6
(
pts
[
0
]
.
fX
0
)
;
y0
=
SkScalarRoundToFDot6
(
pts
[
0
]
.
fY
0
)
;
x1
=
SkScalarRoundToFDot6
(
pts
[
1
]
.
fX
0
)
;
y1
=
SkScalarRoundToFDot6
(
pts
[
1
]
.
fY
0
)
;
x2
=
SkScalarRoundToFDot6
(
pts
[
2
]
.
fX
0
)
;
y2
=
SkScalarRoundToFDot6
(
pts
[
2
]
.
fY
0
)
;
x3
=
SkScalarRoundToFDot6
(
pts
[
3
]
.
fX
0
)
;
y3
=
SkScalarRoundToFDot6
(
pts
[
3
]
.
fY
0
)
;
#
else
x0
=
SkFloatToFDot6
(
pts
[
0
]
.
fX
)
;
y0
=
SkFloatToFDot6
(
pts
[
0
]
.
fY
)
;
x1
=
SkFloatToFDot6
(
pts
[
1
]
.
fX
)
;
y1
=
SkFloatToFDot6
(
pts
[
1
]
.
fY
)
;
x2
=
SkFloatToFDot6
(
pts
[
2
]
.
fX
)
;
y2
=
SkFloatToFDot6
(
pts
[
2
]
.
fY
)
;
x3
=
SkFloatToFDot6
(
pts
[
3
]
.
fX
)
;
y3
=
SkFloatToFDot6
(
pts
[
3
]
.
fY
)
;
#
endif
Winding
winding
=
Winding
:
:
kCW
;
if
(
y0
>
y3
)
{
std
:
:
swap
(
x0
x3
)
;
std
:
:
swap
(
x1
x2
)
;
std
:
:
swap
(
y0
y3
)
;
std
:
:
swap
(
y1
y2
)
;
winding
=
Winding
:
:
kCCW
;
}
int
top
=
SkFDot6Round
(
y0
)
;
int
bot
=
SkFDot6Round
(
y3
)
;
if
(
top
=
=
bot
)
{
return
false
;
}
SkFDot6
dx
=
cubic_delta_from_line
(
x0
x1
x2
x3
)
;
SkFDot6
dy
=
cubic_delta_from_line
(
y0
y1
y2
y3
)
;
int
shift
=
diff_to_shift
(
dx
dy
2
)
+
1
;
SkASSERT
(
shift
>
0
)
;
if
(
shift
>
MAX_COEFF_SHIFT
)
{
shift
=
MAX_COEFF_SHIFT
;
}
int
upShift
=
6
;
int
downShift
=
shift
+
upShift
-
10
;
if
(
downShift
<
0
)
{
downShift
=
0
;
upShift
=
10
-
shift
;
}
fWinding
=
winding
;
fEdgeType
=
Type
:
:
kCubic
;
fSegmentCount
=
SkToU8
(
SkLeftShift
(
1
shift
)
)
;
fCurveShift
=
SkToU8
(
shift
)
;
fCubicDShift
=
SkToU8
(
downShift
)
;
SkFixed
A
=
SkFDot6UpShift
(
x3
+
3
*
(
x1
-
x2
)
-
x0
upShift
)
;
SkFixed
B
=
SkFDot6UpShift
(
3
*
(
x0
-
2
*
x1
+
x2
)
upShift
)
;
SkFixed
C
=
SkFDot6UpShift
(
3
*
(
x1
-
x0
)
upShift
)
;
fCDxDt
=
(
A
>
>
2
*
shift
)
+
(
B
>
>
shift
)
+
C
;
fCD2xDt2
=
(
3
*
A
>
>
(
shift
-
1
)
)
+
2
*
B
;
fCD3xDt3
=
3
*
A
>
>
(
shift
-
1
)
;
A
=
SkFDot6UpShift
(
y3
+
3
*
(
y1
-
y2
)
-
y0
upShift
)
;
B
=
SkFDot6UpShift
(
3
*
(
y0
-
2
*
y1
+
y2
)
upShift
)
;
C
=
SkFDot6UpShift
(
3
*
(
y1
-
y0
)
upShift
)
;
fCDyDt
=
(
A
>
>
2
*
shift
)
+
(
B
>
>
shift
)
+
C
;
fCD2yDt2
=
(
3
*
A
>
>
(
shift
-
1
)
)
+
2
*
B
;
fCD3yDt3
=
3
*
A
>
>
(
shift
-
1
)
;
fCx
=
SkFDot6ToFixed
(
x0
)
;
fCy
=
SkFDot6ToFixed
(
y0
)
;
fCLastX
=
SkFDot6ToFixed
(
x3
)
;
fCLastY
=
SkFDot6ToFixed
(
y3
)
;
return
this
-
>
nextSegment
(
)
;
}
bool
SkCubicEdge
:
:
nextSegment
(
)
{
bool
success
;
int
count
=
fSegmentCount
;
SkFixed
oldx
=
fCx
;
SkFixed
oldy
=
fCy
;
SkFixed
newx
newy
;
const
int
ddshift
=
fCurveShift
;
const
int
dshift
=
fCubicDShift
;
SkASSERT
(
count
>
0
)
;
do
{
if
(
-
-
count
>
0
)
{
newx
=
oldx
+
(
fCDxDt
>
>
dshift
)
;
fCDxDt
+
=
fCD2xDt2
>
>
ddshift
;
fCD2xDt2
+
=
fCD3xDt3
;
newy
=
oldy
+
(
fCDyDt
>
>
dshift
)
;
fCDyDt
+
=
fCD2yDt2
>
>
ddshift
;
fCD2yDt2
+
=
fCD3yDt3
;
}
else
{
newx
=
fCLastX
;
newy
=
fCLastY
;
}
if
(
newy
<
oldy
)
{
newy
=
oldy
;
}
success
=
this
-
>
updateLine
(
oldx
oldy
newx
newy
)
;
oldx
=
newx
;
oldy
=
newy
;
}
while
(
count
>
0
&
&
!
success
)
;
fCx
=
newx
;
fCy
=
newy
;
fSegmentCount
=
SkToU8
(
count
)
;
return
success
;
}
