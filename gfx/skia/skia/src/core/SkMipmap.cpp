#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkHalf
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkImageInfoPriv
.
h
"
#
include
"
src
/
core
/
SkMipmap
.
h
"
#
include
"
src
/
core
/
SkMipmapBuilder
.
h
"
#
include
<
new
>
struct
ColorTypeFilter_8888
{
typedef
uint32_t
Type
;
static
skvx
:
:
Vec
<
4
uint16_t
>
Expand
(
uint32_t
x
)
{
return
skvx
:
:
cast
<
uint16_t
>
(
skvx
:
:
byte4
:
:
Load
(
&
x
)
)
;
}
static
uint32_t
Compact
(
const
skvx
:
:
Vec
<
4
uint16_t
>
&
x
)
{
uint32_t
r
;
skvx
:
:
cast
<
uint8_t
>
(
x
)
.
store
(
&
r
)
;
return
r
;
}
}
;
struct
ColorTypeFilter_565
{
typedef
uint16_t
Type
;
static
uint32_t
Expand
(
uint16_t
x
)
{
return
(
x
&
~
SK_G16_MASK_IN_PLACE
)
|
(
(
x
&
SK_G16_MASK_IN_PLACE
)
<
<
16
)
;
}
static
uint16_t
Compact
(
uint32_t
x
)
{
return
(
(
x
&
~
SK_G16_MASK_IN_PLACE
)
&
0xFFFF
)
|
(
(
x
>
>
16
)
&
SK_G16_MASK_IN_PLACE
)
;
}
}
;
struct
ColorTypeFilter_4444
{
typedef
uint16_t
Type
;
static
uint32_t
Expand
(
uint16_t
x
)
{
return
(
x
&
0xF0F
)
|
(
(
x
&
~
0xF0F
)
<
<
12
)
;
}
static
uint16_t
Compact
(
uint32_t
x
)
{
return
(
x
&
0xF0F
)
|
(
(
x
>
>
12
)
&
~
0xF0F
)
;
}
}
;
struct
ColorTypeFilter_8
{
typedef
uint8_t
Type
;
static
unsigned
Expand
(
unsigned
x
)
{
return
x
;
}
static
uint8_t
Compact
(
unsigned
x
)
{
return
(
uint8_t
)
x
;
}
}
;
struct
ColorTypeFilter_Alpha_F16
{
typedef
uint16_t
Type
;
static
skvx
:
:
float4
Expand
(
uint16_t
x
)
{
return
SkHalfToFloat_finite_ftz
(
(
uint64_t
)
x
)
;
}
static
uint16_t
Compact
(
const
skvx
:
:
float4
&
x
)
{
uint64_t
r
;
SkFloatToHalf_finite_ftz
(
x
)
.
store
(
&
r
)
;
return
r
&
0xFFFF
;
}
}
;
struct
ColorTypeFilter_RGBA_F16
{
typedef
uint64_t
Type
;
static
skvx
:
:
float4
Expand
(
uint64_t
x
)
{
return
SkHalfToFloat_finite_ftz
(
x
)
;
}
static
uint64_t
Compact
(
const
skvx
:
:
float4
&
x
)
{
uint64_t
r
;
SkFloatToHalf_finite_ftz
(
x
)
.
store
(
&
r
)
;
return
r
;
}
}
;
struct
ColorTypeFilter_88
{
typedef
uint16_t
Type
;
static
uint32_t
Expand
(
uint16_t
x
)
{
return
(
x
&
0xFF
)
|
(
(
x
&
~
0xFF
)
<
<
8
)
;
}
static
uint16_t
Compact
(
uint32_t
x
)
{
return
(
x
&
0xFF
)
|
(
(
x
>
>
8
)
&
~
0xFF
)
;
}
}
;
struct
ColorTypeFilter_1616
{
typedef
uint32_t
Type
;
static
uint64_t
Expand
(
uint32_t
x
)
{
return
(
x
&
0xFFFF
)
|
(
(
x
&
~
0xFFFF
)
<
<
16
)
;
}
static
uint16_t
Compact
(
uint64_t
x
)
{
return
(
x
&
0xFFFF
)
|
(
(
x
>
>
16
)
&
~
0xFFFF
)
;
}
}
;
struct
ColorTypeFilter_F16F16
{
typedef
uint32_t
Type
;
static
skvx
:
:
float4
Expand
(
uint32_t
x
)
{
return
SkHalfToFloat_finite_ftz
(
(
uint64_t
)
x
)
;
}
static
uint32_t
Compact
(
const
skvx
:
:
float4
&
x
)
{
uint64_t
r
;
SkFloatToHalf_finite_ftz
(
x
)
.
store
(
&
r
)
;
return
(
uint32_t
)
(
r
&
0xFFFFFFFF
)
;
}
}
;
struct
ColorTypeFilter_16161616
{
typedef
uint64_t
Type
;
static
skvx
:
:
Vec
<
4
uint32_t
>
Expand
(
uint64_t
x
)
{
return
skvx
:
:
cast
<
uint32_t
>
(
skvx
:
:
Vec
<
4
uint16_t
>
:
:
Load
(
&
x
)
)
;
}
static
uint64_t
Compact
(
const
skvx
:
:
Vec
<
4
uint32_t
>
&
x
)
{
uint64_t
r
;
skvx
:
:
cast
<
uint16_t
>
(
x
)
.
store
(
&
r
)
;
return
r
;
}
}
;
struct
ColorTypeFilter_16
{
typedef
uint16_t
Type
;
static
uint32_t
Expand
(
uint16_t
x
)
{
return
x
;
}
static
uint16_t
Compact
(
uint32_t
x
)
{
return
(
uint16_t
)
x
;
}
}
;
struct
ColorTypeFilter_1010102
{
typedef
uint32_t
Type
;
static
uint64_t
Expand
(
uint64_t
x
)
{
return
(
(
(
x
)
&
0x3ff
)
)
|
(
(
(
x
>
>
10
)
&
0x3ff
)
<
<
20
)
|
(
(
(
x
>
>
20
)
&
0x3ff
)
<
<
40
)
|
(
(
(
x
>
>
30
)
&
0x3
)
<
<
60
)
;
}
static
uint32_t
Compact
(
uint64_t
x
)
{
return
(
(
(
x
)
&
0x3ff
)
)
|
(
(
(
x
>
>
20
)
&
0x3ff
)
<
<
10
)
|
(
(
(
x
>
>
40
)
&
0x3ff
)
<
<
20
)
|
(
(
(
x
>
>
60
)
&
0x3
)
<
<
30
)
;
}
}
;
template
<
typename
T
>
T
add_121
(
const
T
&
a
const
T
&
b
const
T
&
c
)
{
return
a
+
b
+
b
+
c
;
}
template
<
typename
T
>
T
shift_right
(
const
T
&
x
int
bits
)
{
return
x
>
>
bits
;
}
skvx
:
:
float4
shift_right
(
const
skvx
:
:
float4
&
x
int
bits
)
{
return
x
*
(
1
.
0f
/
(
1
<
<
bits
)
)
;
}
template
<
typename
T
>
T
shift_left
(
const
T
&
x
int
bits
)
{
return
x
<
<
bits
;
}
skvx
:
:
float4
shift_left
(
const
skvx
:
:
float4
&
x
int
bits
)
{
return
x
*
(
1
<
<
bits
)
;
}
template
<
typename
F
>
void
downsample_1_2
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c10
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c
=
c00
+
c10
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
1
)
)
;
p0
+
=
2
;
p1
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_1_3
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
p2
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p1
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c10
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c20
=
F
:
:
Expand
(
p2
[
0
]
)
;
auto
c
=
add_121
(
c00
c10
c20
)
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
2
)
)
;
p0
+
=
2
;
p1
+
=
2
;
p2
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_2_1
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c01
=
F
:
:
Expand
(
p0
[
1
]
)
;
auto
c
=
c00
+
c01
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
1
)
)
;
p0
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_2_2
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c01
=
F
:
:
Expand
(
p0
[
1
]
)
;
auto
c10
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c11
=
F
:
:
Expand
(
p1
[
1
]
)
;
auto
c
=
c00
+
c10
+
c01
+
c11
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
2
)
)
;
p0
+
=
2
;
p1
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_2_3
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
p2
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p1
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c01
=
F
:
:
Expand
(
p0
[
1
]
)
;
auto
c10
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c11
=
F
:
:
Expand
(
p1
[
1
]
)
;
auto
c20
=
F
:
:
Expand
(
p2
[
0
]
)
;
auto
c21
=
F
:
:
Expand
(
p2
[
1
]
)
;
auto
c
=
add_121
(
c00
c10
c20
)
+
add_121
(
c01
c11
c21
)
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
3
)
)
;
p0
+
=
2
;
p1
+
=
2
;
p2
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_3_1
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
auto
c02
=
F
:
:
Expand
(
p0
[
0
]
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
c00
=
c02
;
auto
c01
=
F
:
:
Expand
(
p0
[
1
]
)
;
c02
=
F
:
:
Expand
(
p0
[
2
]
)
;
auto
c
=
add_121
(
c00
c01
c02
)
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
c
2
)
)
;
p0
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_3_2
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
auto
c0
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c1
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c
=
c0
+
c1
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
a
=
c
;
auto
b0
=
F
:
:
Expand
(
p0
[
1
]
)
;
auto
b1
=
F
:
:
Expand
(
p1
[
1
]
)
;
auto
b
=
b0
+
b0
+
b1
+
b1
;
c0
=
F
:
:
Expand
(
p0
[
2
]
)
;
c1
=
F
:
:
Expand
(
p1
[
2
]
)
;
c
=
c0
+
c1
;
auto
sum
=
a
+
b
+
c
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
sum
3
)
)
;
p0
+
=
2
;
p1
+
=
2
;
}
}
template
<
typename
F
>
void
downsample_3_3
(
void
*
dst
const
void
*
src
size_t
srcRB
int
count
)
{
SkASSERT
(
count
>
0
)
;
auto
p0
=
static_cast
<
const
typename
F
:
:
Type
*
>
(
src
)
;
auto
p1
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p0
+
srcRB
)
;
auto
p2
=
(
const
typename
F
:
:
Type
*
)
(
(
const
char
*
)
p1
+
srcRB
)
;
auto
d
=
static_cast
<
typename
F
:
:
Type
*
>
(
dst
)
;
auto
c0
=
F
:
:
Expand
(
p0
[
0
]
)
;
auto
c1
=
F
:
:
Expand
(
p1
[
0
]
)
;
auto
c2
=
F
:
:
Expand
(
p2
[
0
]
)
;
auto
c
=
add_121
(
c0
c1
c2
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
a
=
c
;
auto
b0
=
F
:
:
Expand
(
p0
[
1
]
)
;
auto
b1
=
F
:
:
Expand
(
p1
[
1
]
)
;
auto
b2
=
F
:
:
Expand
(
p2
[
1
]
)
;
auto
b
=
shift_left
(
add_121
(
b0
b1
b2
)
1
)
;
c0
=
F
:
:
Expand
(
p0
[
2
]
)
;
c1
=
F
:
:
Expand
(
p1
[
2
]
)
;
c2
=
F
:
:
Expand
(
p2
[
2
]
)
;
c
=
add_121
(
c0
c1
c2
)
;
auto
sum
=
a
+
b
+
c
;
d
[
i
]
=
F
:
:
Compact
(
shift_right
(
sum
4
)
)
;
p0
+
=
2
;
p1
+
=
2
;
p2
+
=
2
;
}
}
SkMipmap
:
:
SkMipmap
(
void
*
malloc
size_t
size
)
:
SkCachedData
(
malloc
size
)
{
}
SkMipmap
:
:
SkMipmap
(
size_t
size
SkDiscardableMemory
*
dm
)
:
SkCachedData
(
size
dm
)
{
}
SkMipmap
:
:
~
SkMipmap
(
)
=
default
;
size_t
SkMipmap
:
:
AllocLevelsSize
(
int
levelCount
size_t
pixelSize
)
{
if
(
levelCount
<
0
)
{
return
0
;
}
int64_t
size
=
sk_64_mul
(
levelCount
+
1
sizeof
(
Level
)
)
+
pixelSize
;
if
(
!
SkTFitsIn
<
int32_t
>
(
size
)
)
{
return
0
;
}
return
SkTo
<
int32_t
>
(
size
)
;
}
SkMipmap
*
SkMipmap
:
:
Build
(
const
SkPixmap
&
src
SkDiscardableFactoryProc
fact
bool
computeContents
)
{
typedef
void
FilterProc
(
void
*
const
void
*
srcPtr
size_t
srcRB
int
count
)
;
FilterProc
*
proc_1_2
=
nullptr
;
FilterProc
*
proc_1_3
=
nullptr
;
FilterProc
*
proc_2_1
=
nullptr
;
FilterProc
*
proc_2_2
=
nullptr
;
FilterProc
*
proc_2_3
=
nullptr
;
FilterProc
*
proc_3_1
=
nullptr
;
FilterProc
*
proc_3_2
=
nullptr
;
FilterProc
*
proc_3_3
=
nullptr
;
const
SkColorType
ct
=
src
.
colorType
(
)
;
const
SkAlphaType
at
=
src
.
alphaType
(
)
;
switch
(
ct
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_8888
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_8888
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_8888
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_8888
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_8888
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_8888
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_8888
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_8888
>
;
break
;
case
kRGB_565_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_565
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_565
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_565
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_565
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_565
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_565
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_565
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_565
>
;
break
;
case
kARGB_4444_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_4444
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_4444
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_4444
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_4444
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_4444
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_4444
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_4444
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_4444
>
;
break
;
case
kAlpha_8_SkColorType
:
case
kGray_8_SkColorType
:
case
kR8_unorm_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_8
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_8
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_8
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_8
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_8
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_8
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_8
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_8
>
;
break
;
case
kRGBA_F16Norm_SkColorType
:
case
kRGBA_F16_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_RGBA_F16
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_RGBA_F16
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_RGBA_F16
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_RGBA_F16
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_RGBA_F16
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_RGBA_F16
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_RGBA_F16
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_RGBA_F16
>
;
break
;
case
kR8G8_unorm_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_88
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_88
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_88
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_88
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_88
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_88
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_88
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_88
>
;
break
;
case
kR16G16_unorm_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_1616
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_1616
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_1616
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_1616
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_1616
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_1616
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_1616
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_1616
>
;
break
;
case
kA16_unorm_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_16
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_16
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_16
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_16
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_16
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_16
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_16
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_16
>
;
break
;
case
kRGBA_1010102_SkColorType
:
case
kBGRA_1010102_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_1010102
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_1010102
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_1010102
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_1010102
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_1010102
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_1010102
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_1010102
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_1010102
>
;
break
;
case
kA16_float_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_Alpha_F16
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_Alpha_F16
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_Alpha_F16
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_Alpha_F16
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_Alpha_F16
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_Alpha_F16
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_Alpha_F16
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_Alpha_F16
>
;
break
;
case
kR16G16_float_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_F16F16
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_F16F16
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_F16F16
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_F16F16
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_F16F16
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_F16F16
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_F16F16
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_F16F16
>
;
break
;
case
kR16G16B16A16_unorm_SkColorType
:
proc_1_2
=
downsample_1_2
<
ColorTypeFilter_16161616
>
;
proc_1_3
=
downsample_1_3
<
ColorTypeFilter_16161616
>
;
proc_2_1
=
downsample_2_1
<
ColorTypeFilter_16161616
>
;
proc_2_2
=
downsample_2_2
<
ColorTypeFilter_16161616
>
;
proc_2_3
=
downsample_2_3
<
ColorTypeFilter_16161616
>
;
proc_3_1
=
downsample_3_1
<
ColorTypeFilter_16161616
>
;
proc_3_2
=
downsample_3_2
<
ColorTypeFilter_16161616
>
;
proc_3_3
=
downsample_3_3
<
ColorTypeFilter_16161616
>
;
break
;
case
kUnknown_SkColorType
:
case
kRGB_888x_SkColorType
:
case
kRGB_101010x_SkColorType
:
case
kBGR_101010x_SkColorType
:
case
kBGR_101010x_XR_SkColorType
:
case
kRGBA_F32_SkColorType
:
return
nullptr
;
case
kSRGBA_8888_SkColorType
:
return
nullptr
;
}
if
(
src
.
width
(
)
<
=
1
&
&
src
.
height
(
)
<
=
1
)
{
return
nullptr
;
}
size_t
size
=
0
;
int
countLevels
=
ComputeLevelCount
(
src
.
width
(
)
src
.
height
(
)
)
;
for
(
int
currentMipLevel
=
countLevels
;
currentMipLevel
>
=
0
;
currentMipLevel
-
-
)
{
SkISize
mipSize
=
ComputeLevelSize
(
src
.
width
(
)
src
.
height
(
)
currentMipLevel
)
;
size
+
=
SkColorTypeMinRowBytes
(
ct
mipSize
.
fWidth
)
*
mipSize
.
fHeight
;
}
size_t
storageSize
=
SkMipmap
:
:
AllocLevelsSize
(
countLevels
size
)
;
if
(
0
=
=
storageSize
)
{
return
nullptr
;
}
SkMipmap
*
mipmap
;
if
(
fact
)
{
SkDiscardableMemory
*
dm
=
fact
(
storageSize
)
;
if
(
nullptr
=
=
dm
)
{
return
nullptr
;
}
mipmap
=
new
SkMipmap
(
storageSize
dm
)
;
}
else
{
mipmap
=
new
SkMipmap
(
sk_malloc_throw
(
storageSize
)
storageSize
)
;
}
mipmap
-
>
fCS
=
sk_ref_sp
(
src
.
info
(
)
.
colorSpace
(
)
)
;
mipmap
-
>
fCount
=
countLevels
;
mipmap
-
>
fLevels
=
(
Level
*
)
mipmap
-
>
writable_data
(
)
;
SkASSERT
(
mipmap
-
>
fLevels
)
;
Level
*
levels
=
mipmap
-
>
fLevels
;
uint8_t
*
baseAddr
=
(
uint8_t
*
)
&
levels
[
countLevels
]
;
uint8_t
*
addr
=
baseAddr
;
int
width
=
src
.
width
(
)
;
int
height
=
src
.
height
(
)
;
uint32_t
rowBytes
;
SkPixmap
srcPM
(
src
)
;
SkASSERT
(
SkIsAlign8
(
(
uintptr_t
)
addr
)
)
;
for
(
int
i
=
0
;
i
<
countLevels
;
+
+
i
)
{
FilterProc
*
proc
;
if
(
height
&
1
)
{
if
(
height
=
=
1
)
{
if
(
width
&
1
)
{
proc
=
proc_3_1
;
}
else
{
proc
=
proc_2_1
;
}
}
else
{
if
(
width
&
1
)
{
if
(
width
=
=
1
)
{
proc
=
proc_1_3
;
}
else
{
proc
=
proc_3_3
;
}
}
else
{
proc
=
proc_2_3
;
}
}
}
else
{
if
(
width
&
1
)
{
if
(
width
=
=
1
)
{
proc
=
proc_1_2
;
}
else
{
proc
=
proc_3_2
;
}
}
else
{
proc
=
proc_2_2
;
}
}
width
=
std
:
:
max
(
1
width
>
>
1
)
;
height
=
std
:
:
max
(
1
height
>
>
1
)
;
rowBytes
=
SkToU32
(
SkColorTypeMinRowBytes
(
ct
width
)
)
;
new
(
&
levels
[
i
]
.
fPixmap
)
SkPixmap
(
SkImageInfo
:
:
Make
(
width
height
ct
at
)
addr
rowBytes
)
;
levels
[
i
]
.
fScale
=
SkSize
:
:
Make
(
SkIntToScalar
(
width
)
/
src
.
width
(
)
SkIntToScalar
(
height
)
/
src
.
height
(
)
)
;
const
SkPixmap
&
dstPM
=
levels
[
i
]
.
fPixmap
;
if
(
computeContents
)
{
const
void
*
srcBasePtr
=
srcPM
.
addr
(
)
;
void
*
dstBasePtr
=
dstPM
.
writable_addr
(
)
;
const
size_t
srcRB
=
srcPM
.
rowBytes
(
)
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
proc
(
dstBasePtr
srcBasePtr
srcRB
width
)
;
srcBasePtr
=
(
char
*
)
srcBasePtr
+
srcRB
*
2
;
dstBasePtr
=
(
char
*
)
dstBasePtr
+
dstPM
.
rowBytes
(
)
;
}
}
srcPM
=
dstPM
;
addr
+
=
height
*
rowBytes
;
}
SkASSERT
(
addr
=
=
baseAddr
+
size
)
;
SkASSERT
(
mipmap
-
>
fLevels
)
;
return
mipmap
;
}
int
SkMipmap
:
:
ComputeLevelCount
(
int
baseWidth
int
baseHeight
)
{
if
(
baseWidth
<
1
|
|
baseHeight
<
1
)
{
return
0
;
}
const
int
largestAxis
=
std
:
:
max
(
baseWidth
baseHeight
)
;
if
(
largestAxis
<
2
)
{
return
0
;
}
const
int
leadingZeros
=
SkCLZ
(
static_cast
<
uint32_t
>
(
largestAxis
)
)
;
const
int
significantBits
=
(
sizeof
(
uint32_t
)
*
8
)
-
leadingZeros
;
int
mipLevelCount
=
significantBits
;
if
(
mipLevelCount
>
0
)
{
-
-
mipLevelCount
;
}
return
mipLevelCount
;
}
SkISize
SkMipmap
:
:
ComputeLevelSize
(
int
baseWidth
int
baseHeight
int
level
)
{
if
(
baseWidth
<
1
|
|
baseHeight
<
1
)
{
return
SkISize
:
:
Make
(
0
0
)
;
}
int
maxLevelCount
=
ComputeLevelCount
(
baseWidth
baseHeight
)
;
if
(
level
>
=
maxLevelCount
|
|
level
<
0
)
{
return
SkISize
:
:
Make
(
0
0
)
;
}
int
width
=
std
:
:
max
(
1
baseWidth
>
>
(
level
+
1
)
)
;
int
height
=
std
:
:
max
(
1
baseHeight
>
>
(
level
+
1
)
)
;
return
SkISize
:
:
Make
(
width
height
)
;
}
float
SkMipmap
:
:
ComputeLevel
(
SkSize
scaleSize
)
{
SkASSERT
(
scaleSize
.
width
(
)
>
=
0
&
&
scaleSize
.
height
(
)
>
=
0
)
;
#
ifndef
SK_SUPPORT_LEGACY_ANISOTROPIC_MIPMAP_SCALE
const
float
scale
=
std
:
:
min
(
scaleSize
.
width
(
)
scaleSize
.
height
(
)
)
;
#
else
const
float
scale
=
sk_float_sqrt
(
scaleSize
.
width
(
)
*
scaleSize
.
height
(
)
)
;
#
endif
if
(
scale
>
=
SK_Scalar1
|
|
scale
<
=
0
|
|
!
SkScalarIsFinite
(
scale
)
)
{
return
-
1
;
}
float
L
=
std
:
:
max
(
-
SkScalarLog2
(
scale
)
-
0
.
5f
0
.
f
)
;
if
(
!
SkScalarIsFinite
(
L
)
)
{
return
-
1
;
}
return
L
;
}
bool
SkMipmap
:
:
extractLevel
(
SkSize
scaleSize
Level
*
levelPtr
)
const
{
if
(
nullptr
=
=
fLevels
)
{
return
false
;
}
float
L
=
ComputeLevel
(
scaleSize
)
;
int
level
=
sk_float_round2int
(
L
)
;
if
(
level
<
=
0
)
{
return
false
;
}
if
(
level
>
fCount
)
{
level
=
fCount
;
}
if
(
levelPtr
)
{
*
levelPtr
=
fLevels
[
level
-
1
]
;
levelPtr
-
>
fPixmap
.
setColorSpace
(
fCS
)
;
}
return
true
;
}
bool
SkMipmap
:
:
validForRootLevel
(
const
SkImageInfo
&
root
)
const
{
if
(
nullptr
=
=
fLevels
)
{
return
false
;
}
const
SkISize
dimension
=
root
.
dimensions
(
)
;
if
(
dimension
.
width
(
)
<
=
1
&
&
dimension
.
height
(
)
<
=
1
)
{
return
false
;
}
if
(
fLevels
[
0
]
.
fPixmap
.
width
(
)
!
=
std
:
:
max
(
1
dimension
.
width
(
)
>
>
1
)
|
|
fLevels
[
0
]
.
fPixmap
.
height
(
)
!
=
std
:
:
max
(
1
dimension
.
height
(
)
>
>
1
)
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
this
-
>
countLevels
(
)
;
+
+
i
)
{
if
(
fLevels
[
i
]
.
fPixmap
.
colorType
(
)
!
=
root
.
colorType
(
)
|
|
fLevels
[
i
]
.
fPixmap
.
alphaType
(
)
!
=
root
.
alphaType
(
)
)
{
return
false
;
}
}
return
true
;
}
SkMipmap
*
SkMipmap
:
:
Build
(
const
SkBitmap
&
src
SkDiscardableFactoryProc
fact
)
{
SkPixmap
srcPixmap
;
if
(
!
src
.
peekPixels
(
&
srcPixmap
)
)
{
return
nullptr
;
}
return
Build
(
srcPixmap
fact
)
;
}
int
SkMipmap
:
:
countLevels
(
)
const
{
return
fCount
;
}
bool
SkMipmap
:
:
getLevel
(
int
index
Level
*
levelPtr
)
const
{
if
(
nullptr
=
=
fLevels
)
{
return
false
;
}
if
(
index
<
0
)
{
return
false
;
}
if
(
index
>
fCount
-
1
)
{
return
false
;
}
if
(
levelPtr
)
{
*
levelPtr
=
fLevels
[
index
]
;
levelPtr
-
>
fPixmap
.
setColorSpace
(
fCS
)
;
}
return
true
;
}
#
include
"
include
/
core
/
SkImageGenerator
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
encode
/
SkPngEncoder
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
static
sk_sp
<
SkData
>
encode_to_data
(
const
SkPixmap
&
pm
)
{
SkDynamicMemoryWStream
stream
;
if
(
SkPngEncoder
:
:
Encode
(
&
stream
pm
SkPngEncoder
:
:
Options
(
)
)
)
{
return
stream
.
detachAsData
(
)
;
}
return
nullptr
;
}
sk_sp
<
SkData
>
SkMipmap
:
:
serialize
(
)
const
{
const
int
count
=
this
-
>
countLevels
(
)
;
SkBinaryWriteBuffer
buffer
;
buffer
.
write32
(
count
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
Level
level
;
if
(
this
-
>
getLevel
(
i
&
level
)
)
{
buffer
.
writeDataAsByteArray
(
encode_to_data
(
level
.
fPixmap
)
.
get
(
)
)
;
}
else
{
return
nullptr
;
}
}
return
buffer
.
snapshotAsData
(
)
;
}
bool
SkMipmap
:
:
Deserialize
(
SkMipmapBuilder
*
builder
const
void
*
data
size_t
length
)
{
SkReadBuffer
buffer
(
data
length
)
;
int
count
=
buffer
.
read32
(
)
;
if
(
builder
-
>
countLevels
(
)
!
=
count
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
size_t
size
=
buffer
.
read32
(
)
;
const
void
*
ptr
=
buffer
.
skip
(
size
)
;
if
(
!
ptr
)
{
return
false
;
}
auto
gen
=
SkImageGenerator
:
:
MakeFromEncoded
(
SkData
:
:
MakeWithProc
(
ptr
size
nullptr
nullptr
)
)
;
if
(
!
gen
)
{
return
false
;
}
SkPixmap
pm
=
builder
-
>
level
(
i
)
;
if
(
gen
-
>
getInfo
(
)
.
dimensions
(
)
!
=
pm
.
dimensions
(
)
)
{
return
false
;
}
if
(
!
gen
-
>
getPixels
(
pm
)
)
{
return
false
;
}
}
return
buffer
.
isValid
(
)
;
}
