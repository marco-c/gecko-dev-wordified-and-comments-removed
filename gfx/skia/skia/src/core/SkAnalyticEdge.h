#
ifndef
SkAnalyticEdge_DEFINED
#
define
SkAnalyticEdge_DEFINED
#
include
"
SkEdge
.
h
"
struct
SkAnalyticEdge
{
enum
Type
{
kLine_Type
kQuad_Type
kCubic_Type
}
;
SkAnalyticEdge
*
fNext
;
SkAnalyticEdge
*
fPrev
;
SkAnalyticEdge
*
fRiteE
;
SkFixed
fX
;
SkFixed
fDX
;
SkFixed
fUpperX
;
SkFixed
fY
;
SkFixed
fUpperY
;
SkFixed
fLowerY
;
SkFixed
fDY
;
SkFixed
fSavedX
;
SkFixed
fSavedY
;
SkFixed
fSavedDY
;
int8_t
fCurveCount
;
uint8_t
fCurveShift
;
uint8_t
fCubicDShift
;
int8_t
fWinding
;
static
const
int
kDefaultAccuracy
=
2
;
static
inline
SkFixed
SnapY
(
SkFixed
y
)
{
const
int
accuracy
=
kDefaultAccuracy
;
return
(
(
unsigned
)
y
+
(
SK_Fixed1
>
>
(
accuracy
+
1
)
)
)
>
>
(
16
-
accuracy
)
<
<
(
16
-
accuracy
)
;
}
inline
void
goY
(
SkFixed
y
)
{
if
(
y
=
=
fY
+
SK_Fixed1
)
{
fX
=
fX
+
fDX
;
fY
=
y
;
}
else
if
(
y
!
=
fY
)
{
fX
=
fUpperX
+
SkFixedMul
(
fDX
y
-
fUpperY
)
;
fY
=
y
;
}
}
inline
void
goY
(
SkFixed
y
int
yShift
)
{
SkASSERT
(
yShift
>
=
0
&
&
yShift
<
=
kDefaultAccuracy
)
;
SkASSERT
(
fDX
=
=
0
|
|
y
-
fY
=
=
SK_Fixed1
>
>
yShift
)
;
fY
=
y
;
fX
+
=
fDX
>
>
yShift
;
}
inline
void
saveXY
(
SkFixed
x
SkFixed
y
SkFixed
dY
)
{
fSavedX
=
x
;
fSavedY
=
y
;
fSavedDY
=
dY
;
}
inline
bool
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
)
;
inline
bool
updateLine
(
SkFixed
ax
SkFixed
ay
SkFixed
bx
SkFixed
by
SkFixed
slope
)
;
#
ifdef
SK_DEBUG
void
dump
(
)
const
{
SkDebugf
(
"
edge
:
upperY
:
%
d
lowerY
:
%
d
y
:
%
g
x
:
%
g
dx
:
%
g
w
:
%
d
\
n
"
fUpperY
fLowerY
SkFixedToFloat
(
fY
)
SkFixedToFloat
(
fX
)
SkFixedToFloat
(
fDX
)
fWinding
)
;
}
void
validate
(
)
const
{
SkASSERT
(
fPrev
&
&
fNext
)
;
SkASSERT
(
fPrev
-
>
fNext
=
=
this
)
;
SkASSERT
(
fNext
-
>
fPrev
=
=
this
)
;
SkASSERT
(
fUpperY
<
fLowerY
)
;
SkASSERT
(
SkAbs32
(
fWinding
)
=
=
1
)
;
}
#
endif
}
;
struct
SkAnalyticQuadraticEdge
:
public
SkAnalyticEdge
{
SkQuadraticEdge
fQEdge
;
SkFixed
fSnappedX
fSnappedY
;
bool
setQuadratic
(
const
SkPoint
pts
[
3
]
)
;
bool
updateQuadratic
(
)
;
inline
void
keepContinuous
(
)
{
SkASSERT
(
SkAbs32
(
fX
-
SkFixedMul
(
fY
-
fSnappedY
fDX
)
-
fSnappedX
)
<
SK_Fixed1
)
;
SkASSERT
(
SkAbs32
(
fY
-
fSnappedY
)
<
SK_Fixed1
)
;
fSnappedX
=
fX
;
fSnappedY
=
fY
;
}
}
;
struct
SkAnalyticCubicEdge
:
public
SkAnalyticEdge
{
SkCubicEdge
fCEdge
;
SkFixed
fSnappedY
;
bool
setCubic
(
const
SkPoint
pts
[
4
]
)
;
bool
updateCubic
(
)
;
inline
void
keepContinuous
(
)
{
SkASSERT
(
SkAbs32
(
fX
-
SkFixedMul
(
fDX
fY
-
SnapY
(
fCEdge
.
fCy
)
)
-
fCEdge
.
fCx
)
<
SK_Fixed1
)
;
fCEdge
.
fCx
=
fX
;
fSnappedY
=
fY
;
}
}
;
bool
SkAnalyticEdge
:
:
setLine
(
const
SkPoint
&
p0
const
SkPoint
&
p1
)
{
#
if
defined
(
__arm__
)
asm
volatile
(
"
dsb
"
)
;
#
endif
fRiteE
=
nullptr
;
const
int
accuracy
=
kDefaultAccuracy
;
#
ifdef
SK_RASTERIZE_EVEN_ROUNDING
SkFixed
x0
=
SkFDot6ToFixed
(
SkScalarRoundToFDot6
(
p0
.
fX
accuracy
)
)
>
>
accuracy
;
SkFixed
y0
=
SnapY
(
SkFDot6ToFixed
(
SkScalarRoundToFDot6
(
p0
.
fY
accuracy
)
)
>
>
accuracy
)
;
SkFixed
x1
=
SkFDot6ToFixed
(
SkScalarRoundToFDot6
(
p1
.
fX
accuracy
)
)
>
>
accuracy
;
SkFixed
y1
=
SnapY
(
SkFDot6ToFixed
(
SkScalarRoundToFDot6
(
p1
.
fY
accuracy
)
)
>
>
accuracy
)
;
#
else
const
int
multiplier
=
(
1
<
<
kDefaultAccuracy
)
;
SkFixed
x0
=
SkFDot6ToFixed
(
SkScalarToFDot6
(
p0
.
fX
*
multiplier
)
)
>
>
accuracy
;
SkFixed
y0
=
SnapY
(
SkFDot6ToFixed
(
SkScalarToFDot6
(
p0
.
fY
*
multiplier
)
)
>
>
accuracy
)
;
SkFixed
x1
=
SkFDot6ToFixed
(
SkScalarToFDot6
(
p1
.
fX
*
multiplier
)
)
>
>
accuracy
;
SkFixed
y1
=
SnapY
(
SkFDot6ToFixed
(
SkScalarToFDot6
(
p1
.
fY
*
multiplier
)
)
>
>
accuracy
)
;
#
endif
int
winding
=
1
;
if
(
y0
>
y1
)
{
SkTSwap
(
x0
x1
)
;
SkTSwap
(
y0
y1
)
;
winding
=
-
1
;
}
SkFDot6
dy
=
SkFixedToFDot6
(
y1
-
y0
)
;
if
(
dy
=
=
0
)
{
return
false
;
}
SkFDot6
dx
=
SkFixedToFDot6
(
x1
-
x0
)
;
SkFixed
slope
=
QuickSkFDot6Div
(
dx
dy
)
;
SkFixed
absSlope
=
SkAbs32
(
slope
)
;
fX
=
x0
;
fDX
=
slope
;
fUpperX
=
x0
;
fY
=
y0
;
fUpperY
=
y0
;
fLowerY
=
y1
;
fDY
=
dx
=
=
0
|
|
slope
=
=
0
?
SK_MaxS32
:
absSlope
<
kInverseTableSize
?
QuickFDot6Inverse
:
:
Lookup
(
absSlope
)
:
SkAbs32
(
QuickSkFDot6Div
(
dy
dx
)
)
;
fCurveCount
=
0
;
fWinding
=
SkToS8
(
winding
)
;
fCurveShift
=
0
;
return
true
;
}
#
endif
