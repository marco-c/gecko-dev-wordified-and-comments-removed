#
ifndef
SkGlyphRunPainter_DEFINED
#
define
SkGlyphRunPainter_DEFINED
#
include
"
SkDistanceFieldGen
.
h
"
#
include
"
SkGlyphRun
.
h
"
#
include
"
SkScalerContext
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTextBlobPriv
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
text
/
GrTextContext
.
h
"
class
GrColorSpaceInfo
;
class
GrRenderTargetContext
;
#
endif
class
SkStrikeCommon
{
public
:
static
SkVector
PixelRounding
(
bool
isSubpixel
SkAxisAlignment
axisAlignment
)
;
static
SkIPoint
SubpixelLookup
(
SkAxisAlignment
axisAlignment
SkPoint
position
)
;
static
constexpr
uint16_t
kSkSideTooBigForAtlas
=
256
;
static
bool
GlyphTooBigForAtlas
(
const
SkGlyph
&
glyph
)
;
}
;
class
SkGlyphRunListPainter
{
public
:
SkGlyphRunListPainter
(
const
SkSurfaceProps
&
props
SkColorType
colorType
SkColorSpace
*
cs
SkStrikeCacheInterface
*
strikeCache
)
;
#
if
SK_SUPPORT_GPU
SkGlyphRunListPainter
(
const
SkSurfaceProps
&
const
GrColorSpaceInfo
&
)
;
explicit
SkGlyphRunListPainter
(
const
GrRenderTargetContext
&
renderTargetContext
)
;
#
endif
struct
PathAndPos
{
const
SkPath
*
path
;
SkPoint
position
;
}
;
struct
GlyphAndPos
{
const
SkGlyph
*
glyph
;
SkPoint
position
;
}
;
class
BitmapDevicePainter
{
public
:
virtual
~
BitmapDevicePainter
(
)
=
default
;
virtual
void
paintPaths
(
SkSpan
<
const
PathAndPos
>
pathsAndPositions
SkScalar
scale
const
SkPaint
&
paint
)
const
=
0
;
virtual
void
paintMasks
(
SkSpan
<
const
SkMask
>
masks
const
SkPaint
&
paint
)
const
=
0
;
}
;
void
drawForBitmapDevice
(
const
SkGlyphRunList
&
glyphRunList
const
SkMatrix
&
deviceMatrix
const
BitmapDevicePainter
*
bitmapDevice
)
;
template
<
typename
MasksT
typename
PathsT
>
void
drawGlyphRunAsBMPWithPathFallback
(
const
SkPaint
&
paint
const
SkFont
&
font
const
SkGlyphRun
&
glyphRun
SkPoint
origin
const
SkMatrix
&
deviceMatrix
MasksT
&
&
processMasks
PathsT
&
&
processPaths
)
;
enum
NeedsTransform
:
bool
{
kTransformDone
=
false
kDoTransform
=
true
}
;
using
ARGBFallback
=
std
:
:
function
<
void
(
const
SkPaint
&
fallbackPaint
const
SkFont
&
fallbackFont
SkSpan
<
const
SkGlyphID
>
fallbackGlyphIDs
SkSpan
<
const
SkPoint
>
fallbackPositions
SkScalar
fallbackTextScale
const
SkMatrix
&
glyphCacheMatrix
NeedsTransform
handleTransformLater
)
>
;
template
<
typename
ProcessPathsT
typename
ProcessDeviceT
typename
ProcessSourceT
>
void
drawGlyphRunAsPathWithARGBFallback
(
const
SkPaint
&
runPaint
const
SkFont
&
runFont
const
SkGlyphRun
&
glyphRun
SkPoint
origin
const
SkMatrix
&
viewMatrix
ProcessPathsT
&
&
processPaths
ProcessDeviceT
&
&
processDevice
ProcessSourceT
&
&
processSource
)
;
#
if
SK_SUPPORT_GPU
template
<
typename
ProcessMasksT
typename
ProcessPathsT
typename
ProcessDeviceT
typename
ProcessSourceT
>
void
drawGlyphRunAsSDFWithARGBFallback
(
const
SkPaint
&
runPaint
const
SkFont
&
runFont
const
SkGlyphRun
&
glyphRun
SkPoint
origin
const
SkMatrix
&
viewMatrix
const
GrTextContext
:
:
Options
&
options
ProcessMasksT
&
&
perSDF
ProcessPathsT
&
&
perPath
ProcessDeviceT
&
&
processDevice
ProcessSourceT
&
&
processSource
)
;
#
endif
static
bool
ShouldDrawAsPath
(
const
SkPaint
&
paint
const
SkFont
&
font
const
SkMatrix
&
matrix
)
;
private
:
SkGlyphRunListPainter
(
const
SkSurfaceProps
&
props
SkColorType
colorType
SkScalerContextFlags
flags
SkStrikeCacheInterface
*
strikeCache
)
;
struct
ScopedBuffers
{
ScopedBuffers
(
SkGlyphRunListPainter
*
painter
int
size
)
;
~
ScopedBuffers
(
)
;
SkGlyphRunListPainter
*
fPainter
;
}
;
ScopedBuffers
SK_WARN_UNUSED_RESULT
ensureBuffers
(
const
SkGlyphRunList
&
glyphRunList
)
;
ScopedBuffers
SK_WARN_UNUSED_RESULT
ensureBuffers
(
const
SkGlyphRun
&
glyphRun
)
;
template
<
typename
ProcessDeviceT
typename
ProcessSourceT
>
void
processARGBFallback
(
SkScalar
maxGlyphDimension
const
SkPaint
&
runPaint
const
SkFont
&
runFont
const
SkMatrix
&
viewMatrix
SkScalar
textScale
ProcessDeviceT
&
&
processDevice
ProcessSourceT
&
&
processSource
)
;
const
SkSurfaceProps
fDeviceProps
;
const
SkSurfaceProps
fBitmapFallbackProps
;
const
SkColorType
fColorType
;
const
SkScalerContextFlags
fScalerContextFlags
;
SkStrikeCacheInterface
*
const
fStrikeCache
;
int
fMaxRunSize
{
0
}
;
SkAutoTMalloc
<
SkPoint
>
fPositions
;
SkAutoTMalloc
<
GlyphAndPos
>
fGlyphPos
;
std
:
:
vector
<
GlyphAndPos
>
fPaths
;
std
:
:
vector
<
SkGlyphID
>
fARGBGlyphsIDs
;
std
:
:
vector
<
SkPoint
>
fARGBPositions
;
}
;
#
endif
