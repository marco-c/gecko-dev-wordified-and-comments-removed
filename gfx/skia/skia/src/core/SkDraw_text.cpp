#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkFontPriv
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
core
/
SkRasterClip
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
core
/
SkStrike
.
h
"
#
include
"
src
/
core
/
SkUtils
.
h
"
#
include
<
climits
>
#
if
defined
_WIN32
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4701
)
#
endif
static
bool
check_glyph_position
(
SkPoint
position
)
{
auto
gt
=
[
]
(
float
a
int
b
)
{
return
!
(
a
<
=
(
float
)
b
)
;
}
;
auto
lt
=
[
]
(
float
a
int
b
)
{
return
!
(
a
>
=
(
float
)
b
)
;
}
;
return
!
(
gt
(
position
.
fX
INT_MAX
-
(
INT16_MAX
+
SkTo
<
int
>
(
UINT16_MAX
)
)
)
|
|
lt
(
position
.
fX
INT_MIN
-
(
INT16_MIN
+
0
)
)
|
|
gt
(
position
.
fY
INT_MAX
-
(
INT16_MAX
+
SkTo
<
int
>
(
UINT16_MAX
)
)
)
|
|
lt
(
position
.
fY
INT_MIN
-
(
INT16_MIN
+
0
)
)
)
;
}
void
SkDraw
:
:
paintMasks
(
SkDrawableGlyphBuffer
*
drawables
const
SkPaint
&
paint
)
const
{
SkSTArenaAlloc
<
3308
>
alloc
;
SkBlitter
*
blitter
=
SkBlitter
:
:
Choose
(
fDst
*
fMatrix
paint
&
alloc
false
)
;
if
(
fCoverage
)
{
blitter
=
alloc
.
make
<
SkPairBlitter
>
(
blitter
SkBlitter
:
:
Choose
(
*
fCoverage
*
fMatrix
SkPaint
(
)
&
alloc
true
)
)
;
}
SkAAClipBlitterWrapper
wrapper
{
*
fRC
blitter
}
;
blitter
=
wrapper
.
getBlitter
(
)
;
bool
useRegion
=
fRC
-
>
isBW
(
)
&
&
!
fRC
-
>
isRect
(
)
;
if
(
useRegion
)
{
for
(
auto
t
:
drawables
-
>
drawable
(
)
)
{
SkGlyphVariant
glyph
;
SkPoint
pos
;
std
:
:
tie
(
glyph
pos
)
=
t
;
if
(
check_glyph_position
(
pos
)
)
{
SkMask
mask
=
glyph
.
glyph
(
)
-
>
mask
(
pos
)
;
SkRegion
:
:
Cliperator
clipper
(
fRC
-
>
bwRgn
(
)
mask
.
fBounds
)
;
if
(
!
clipper
.
done
(
)
)
{
if
(
SkMask
:
:
kARGB32_Format
=
=
mask
.
fFormat
)
{
SkBitmap
bm
;
bm
.
installPixels
(
SkImageInfo
:
:
MakeN32Premul
(
mask
.
fBounds
.
size
(
)
)
mask
.
fImage
mask
.
fRowBytes
)
;
this
-
>
drawSprite
(
bm
mask
.
fBounds
.
x
(
)
mask
.
fBounds
.
y
(
)
paint
)
;
}
else
{
const
SkIRect
&
cr
=
clipper
.
rect
(
)
;
do
{
blitter
-
>
blitMask
(
mask
cr
)
;
clipper
.
next
(
)
;
}
while
(
!
clipper
.
done
(
)
)
;
}
}
}
}
}
else
{
SkIRect
clipBounds
=
fRC
-
>
isBW
(
)
?
fRC
-
>
bwRgn
(
)
.
getBounds
(
)
:
fRC
-
>
aaRgn
(
)
.
getBounds
(
)
;
for
(
auto
t
:
drawables
-
>
drawable
(
)
)
{
SkGlyphVariant
glyph
;
SkPoint
pos
;
std
:
:
tie
(
glyph
pos
)
=
t
;
if
(
check_glyph_position
(
pos
)
)
{
SkMask
mask
=
glyph
.
glyph
(
)
-
>
mask
(
pos
)
;
SkIRect
storage
;
const
SkIRect
*
bounds
=
&
mask
.
fBounds
;
if
(
!
clipBounds
.
containsNoEmptyCheck
(
mask
.
fBounds
)
)
{
if
(
!
storage
.
intersect
(
mask
.
fBounds
clipBounds
)
)
{
continue
;
}
bounds
=
&
storage
;
}
if
(
SkMask
:
:
kARGB32_Format
=
=
mask
.
fFormat
)
{
SkBitmap
bm
;
bm
.
installPixels
(
SkImageInfo
:
:
MakeN32Premul
(
mask
.
fBounds
.
size
(
)
)
mask
.
fImage
mask
.
fRowBytes
)
;
this
-
>
drawSprite
(
bm
mask
.
fBounds
.
x
(
)
mask
.
fBounds
.
y
(
)
paint
)
;
}
else
{
blitter
-
>
blitMask
(
mask
*
bounds
)
;
}
}
}
}
}
void
SkDraw
:
:
paintPaths
(
SkDrawableGlyphBuffer
*
drawables
SkScalar
scale
const
SkPaint
&
paint
)
const
{
for
(
auto
t
:
drawables
-
>
drawable
(
)
)
{
SkGlyphVariant
path
;
SkPoint
pos
;
std
:
:
tie
(
path
pos
)
=
t
;
SkMatrix
m
;
m
.
setScaleTranslate
(
scale
scale
pos
.
x
(
)
pos
.
y
(
)
)
;
this
-
>
drawPath
(
*
path
.
path
(
)
paint
&
m
false
)
;
}
}
void
SkDraw
:
:
drawGlyphRunList
(
const
SkGlyphRunList
&
glyphRunList
SkGlyphRunListPainter
*
glyphPainter
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
fRC
-
>
isEmpty
(
)
)
{
return
;
}
glyphPainter
-
>
drawForBitmapDevice
(
glyphRunList
*
fMatrix
this
)
;
}
#
if
defined
_WIN32
#
pragma
warning
(
pop
)
#
endif
