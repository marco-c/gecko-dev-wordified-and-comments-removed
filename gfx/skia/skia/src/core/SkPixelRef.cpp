#
include
"
SkBitmapCache
.
h
"
#
include
"
SkMutex
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkTraceEvent
.
h
"
#
include
"
SkNextID
.
h
"
uint32_t
SkNextID
:
:
ImageID
(
)
{
static
uint32_t
gID
=
0
;
uint32_t
id
;
do
{
id
=
sk_atomic_fetch_add
(
&
gID
2u
)
+
2
;
}
while
(
0
=
=
id
)
;
return
id
;
}
#
define
SKPIXELREF_PRELOCKED_LOCKCOUNT
123456789
static
SkImageInfo
validate_info
(
const
SkImageInfo
&
info
)
{
SkAlphaType
newAlphaType
=
info
.
alphaType
(
)
;
SkAssertResult
(
SkColorTypeValidateAlphaType
(
info
.
colorType
(
)
info
.
alphaType
(
)
&
newAlphaType
)
)
;
return
info
.
makeAlphaType
(
newAlphaType
)
;
}
static
void
validate_pixels_ctable
(
const
SkImageInfo
&
info
const
SkColorTable
*
ctable
)
{
if
(
info
.
isEmpty
(
)
)
{
return
;
}
if
(
kIndex_8_SkColorType
=
=
info
.
colorType
(
)
)
{
SkASSERT
(
ctable
)
;
}
else
{
SkASSERT
(
nullptr
=
=
ctable
)
;
}
}
#
ifdef
SK_TRACE_PIXELREF_LIFETIME
static
int32_t
gInstCounter
;
#
endif
#
ifdef
SK_SUPPORT_LEGACY_NO_ADDR_PIXELREF
SkPixelRef
:
:
SkPixelRef
(
const
SkImageInfo
&
info
)
:
fInfo
(
validate_info
(
info
)
)
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
fStableID
(
SkNextID
:
:
ImageID
(
)
)
#
endif
{
#
ifdef
SK_TRACE_PIXELREF_LIFETIME
SkDebugf
(
"
pixelref
%
d
\
n
"
sk_atomic_inc
(
&
gInstCounter
)
)
;
#
endif
fRec
.
zero
(
)
;
fLockCount
=
0
;
this
-
>
needsNewGenID
(
)
;
fMutability
=
kMutable
;
fPreLocked
=
false
;
fAddedToCache
.
store
(
false
)
;
}
#
endif
SkPixelRef
:
:
SkPixelRef
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
sk_sp
<
SkColorTable
>
ctable
)
:
fInfo
(
validate_info
(
info
)
)
fCTable
(
std
:
:
move
(
ctable
)
)
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
fStableID
(
SkNextID
:
:
ImageID
(
)
)
#
endif
{
validate_pixels_ctable
(
fInfo
fCTable
.
get
(
)
)
;
SkASSERT
(
rowBytes
>
=
info
.
minRowBytes
(
)
)
;
#
ifdef
SK_TRACE_PIXELREF_LIFETIME
SkDebugf
(
"
pixelref
%
d
\
n
"
sk_atomic_inc
(
&
gInstCounter
)
)
;
#
endif
fRec
.
fPixels
=
pixels
;
fRec
.
fRowBytes
=
rowBytes
;
fRec
.
fColorTable
=
fCTable
.
get
(
)
;
fLockCount
=
SKPIXELREF_PRELOCKED_LOCKCOUNT
;
this
-
>
needsNewGenID
(
)
;
fMutability
=
kMutable
;
fPreLocked
=
true
;
fAddedToCache
.
store
(
false
)
;
}
SkPixelRef
:
:
~
SkPixelRef
(
)
{
#
ifndef
SK_SUPPORT_LEGACY_UNBALANCED_PIXELREF_LOCKCOUNT
SkASSERT
(
SKPIXELREF_PRELOCKED_LOCKCOUNT
=
=
fLockCount
|
|
0
=
=
fLockCount
)
;
#
endif
#
ifdef
SK_TRACE_PIXELREF_LIFETIME
SkDebugf
(
"
~
pixelref
%
d
\
n
"
sk_atomic_dec
(
&
gInstCounter
)
-
1
)
;
#
endif
this
-
>
callGenIDChangeListeners
(
)
;
}
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
void
SkPixelRef
:
:
android_only_reset
(
const
SkImageInfo
&
info
size_t
rowBytes
sk_sp
<
SkColorTable
>
ctable
)
{
validate_pixels_ctable
(
info
ctable
.
get
(
)
)
;
*
const_cast
<
SkImageInfo
*
>
(
&
fInfo
)
=
info
;
fCTable
=
std
:
:
move
(
ctable
)
;
fRec
.
fRowBytes
=
rowBytes
;
fRec
.
fColorTable
=
fCTable
.
get
(
)
;
this
-
>
notifyPixelsChanged
(
)
;
}
#
endif
void
SkPixelRef
:
:
needsNewGenID
(
)
{
fTaggedGenID
.
store
(
0
)
;
SkASSERT
(
!
this
-
>
genIDIsUnique
(
)
)
;
}
void
SkPixelRef
:
:
cloneGenID
(
const
SkPixelRef
&
that
)
{
uint32_t
genID
=
that
.
getGenerationID
(
)
;
this
-
>
fTaggedGenID
.
store
(
genID
&
~
1u
)
;
that
.
fTaggedGenID
.
store
(
genID
&
~
1u
)
;
SkASSERT
(
!
this
-
>
genIDIsUnique
(
)
)
;
SkASSERT
(
!
that
.
genIDIsUnique
(
)
)
;
}
#
ifdef
SK_SUPPORT_LEGACY_NO_ADDR_PIXELREF
void
SkPixelRef
:
:
setPreLocked
(
void
*
pixels
size_t
rowBytes
SkColorTable
*
ctable
)
{
SkASSERT
(
pixels
)
;
validate_pixels_ctable
(
fInfo
ctable
)
;
fRec
.
fPixels
=
pixels
;
fRec
.
fColorTable
=
ctable
;
fRec
.
fRowBytes
=
rowBytes
;
fLockCount
=
SKPIXELREF_PRELOCKED_LOCKCOUNT
;
fPreLocked
=
true
;
}
#
endif
bool
SkPixelRef
:
:
lockPixelsInsideMutex
(
)
{
fMutex
.
assertHeld
(
)
;
if
(
1
=
=
+
+
fLockCount
)
{
SkASSERT
(
fRec
.
isZero
(
)
)
;
if
(
!
this
-
>
onNewLockPixels
(
&
fRec
)
)
{
fRec
.
zero
(
)
;
fLockCount
-
=
1
;
return
false
;
}
}
if
(
fRec
.
fPixels
)
{
validate_pixels_ctable
(
fInfo
fRec
.
fColorTable
)
;
return
true
;
}
-
-
fLockCount
;
return
false
;
}
bool
SkPixelRef
:
:
lockPixels
(
)
{
SkASSERT
(
!
fPreLocked
|
|
SKPIXELREF_PRELOCKED_LOCKCOUNT
=
=
fLockCount
)
;
if
(
!
fPreLocked
)
{
TRACE_EVENT_BEGIN0
(
"
skia
"
"
SkPixelRef
:
:
lockPixelsMutex
"
)
;
SkAutoMutexAcquire
ac
(
fMutex
)
;
TRACE_EVENT_END0
(
"
skia
"
"
SkPixelRef
:
:
lockPixelsMutex
"
)
;
SkDEBUGCODE
(
int
oldCount
=
fLockCount
;
)
bool
success
=
this
-
>
lockPixelsInsideMutex
(
)
;
SkASSERT
(
oldCount
+
(
int
)
success
=
=
fLockCount
)
;
if
(
!
success
)
{
fLockCount
+
=
1
;
return
false
;
}
}
if
(
fRec
.
fPixels
)
{
validate_pixels_ctable
(
fInfo
fRec
.
fColorTable
)
;
return
true
;
}
return
false
;
}
bool
SkPixelRef
:
:
lockPixels
(
LockRec
*
rec
)
{
if
(
this
-
>
lockPixels
(
)
)
{
*
rec
=
fRec
;
return
true
;
}
return
false
;
}
void
SkPixelRef
:
:
unlockPixels
(
)
{
SkASSERT
(
!
fPreLocked
|
|
SKPIXELREF_PRELOCKED_LOCKCOUNT
=
=
fLockCount
)
;
if
(
!
fPreLocked
)
{
SkAutoMutexAcquire
ac
(
fMutex
)
;
SkASSERT
(
fLockCount
>
0
)
;
if
(
0
=
=
-
-
fLockCount
)
{
if
(
fRec
.
fPixels
)
{
this
-
>
onUnlockPixels
(
)
;
fRec
.
zero
(
)
;
}
else
{
SkASSERT
(
fRec
.
isZero
(
)
)
;
}
}
}
}
bool
SkPixelRef
:
:
requestLock
(
const
LockRequest
&
request
LockResult
*
result
)
{
SkASSERT
(
result
)
;
if
(
request
.
fSize
.
isEmpty
(
)
)
{
return
false
;
}
if
(
request
.
fSize
.
width
(
)
!
=
fInfo
.
width
(
)
|
|
request
.
fSize
.
height
(
)
!
=
fInfo
.
height
(
)
)
{
return
false
;
}
if
(
fPreLocked
)
{
result
-
>
fUnlockProc
=
nullptr
;
result
-
>
fUnlockContext
=
nullptr
;
result
-
>
fCTable
=
fRec
.
fColorTable
;
result
-
>
fPixels
=
fRec
.
fPixels
;
result
-
>
fRowBytes
=
fRec
.
fRowBytes
;
result
-
>
fSize
.
set
(
fInfo
.
width
(
)
fInfo
.
height
(
)
)
;
}
else
{
SkAutoMutexAcquire
ac
(
fMutex
)
;
if
(
!
this
-
>
internalRequestLock
(
request
result
)
)
{
return
false
;
}
}
if
(
result
-
>
fPixels
)
{
validate_pixels_ctable
(
fInfo
result
-
>
fCTable
)
;
return
true
;
}
return
false
;
}
uint32_t
SkPixelRef
:
:
getGenerationID
(
)
const
{
uint32_t
id
=
fTaggedGenID
.
load
(
)
;
if
(
0
=
=
id
)
{
uint32_t
next
=
SkNextID
:
:
ImageID
(
)
|
1u
;
if
(
fTaggedGenID
.
compare_exchange
(
&
id
next
)
)
{
id
=
next
;
}
else
{
}
}
return
id
&
~
1u
;
}
void
SkPixelRef
:
:
addGenIDChangeListener
(
GenIDChangeListener
*
listener
)
{
if
(
nullptr
=
=
listener
|
|
!
this
-
>
genIDIsUnique
(
)
)
{
delete
listener
;
return
;
}
*
fGenIDChangeListeners
.
append
(
)
=
listener
;
}
void
SkPixelRef
:
:
callGenIDChangeListeners
(
)
{
if
(
this
-
>
genIDIsUnique
(
)
)
{
for
(
int
i
=
0
;
i
<
fGenIDChangeListeners
.
count
(
)
;
i
+
+
)
{
fGenIDChangeListeners
[
i
]
-
>
onChange
(
)
;
}
if
(
fAddedToCache
.
load
(
)
)
{
SkNotifyBitmapGenIDIsStale
(
this
-
>
getGenerationID
(
)
)
;
fAddedToCache
.
store
(
false
)
;
}
}
fGenIDChangeListeners
.
deleteAll
(
)
;
}
void
SkPixelRef
:
:
notifyPixelsChanged
(
)
{
#
ifdef
SK_DEBUG
if
(
this
-
>
isImmutable
(
)
)
{
SkDebugf
(
"
=
=
=
=
=
=
=
=
=
=
notifyPixelsChanged
called
on
immutable
pixelref
"
)
;
}
#
endif
this
-
>
callGenIDChangeListeners
(
)
;
this
-
>
needsNewGenID
(
)
;
this
-
>
onNotifyPixelsChanged
(
)
;
}
void
SkPixelRef
:
:
changeAlphaType
(
SkAlphaType
at
)
{
*
const_cast
<
SkImageInfo
*
>
(
&
fInfo
)
=
fInfo
.
makeAlphaType
(
at
)
;
}
void
SkPixelRef
:
:
setImmutable
(
)
{
fMutability
=
kImmutable
;
}
void
SkPixelRef
:
:
setImmutableWithID
(
uint32_t
genID
)
{
fMutability
=
kImmutable
;
fTaggedGenID
.
store
(
genID
)
;
}
void
SkPixelRef
:
:
setTemporarilyImmutable
(
)
{
SkASSERT
(
fMutability
!
=
kImmutable
)
;
fMutability
=
kTemporarilyImmutable
;
}
void
SkPixelRef
:
:
restoreMutability
(
)
{
SkASSERT
(
fMutability
!
=
kImmutable
)
;
fMutability
=
kMutable
;
}
void
SkPixelRef
:
:
onNotifyPixelsChanged
(
)
{
}
size_t
SkPixelRef
:
:
getAllocatedSizeInBytes
(
)
const
{
return
0
;
}
static
void
unlock_legacy_result
(
void
*
ctx
)
{
SkPixelRef
*
pr
=
(
SkPixelRef
*
)
ctx
;
pr
-
>
unlockPixels
(
)
;
pr
-
>
unref
(
)
;
}
bool
SkPixelRef
:
:
internalRequestLock
(
const
LockRequest
&
request
LockResult
*
result
)
{
if
(
!
this
-
>
lockPixelsInsideMutex
(
)
)
{
return
false
;
}
result
-
>
fUnlockProc
=
unlock_legacy_result
;
result
-
>
fUnlockContext
=
SkRef
(
this
)
;
result
-
>
fCTable
=
fRec
.
fColorTable
;
result
-
>
fPixels
=
fRec
.
fPixels
;
result
-
>
fRowBytes
=
fRec
.
fRowBytes
;
result
-
>
fSize
.
set
(
fInfo
.
width
(
)
fInfo
.
height
(
)
)
;
return
true
;
}
