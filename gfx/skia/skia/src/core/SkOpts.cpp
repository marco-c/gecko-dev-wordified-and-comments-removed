#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
include
/
private
/
base
/
SkFeatures
.
h
"
#
include
"
src
/
core
/
SkCpu
.
h
"
#
include
"
src
/
core
/
SkOptsTargets
.
h
"
#
define
SK_OPTS_TARGET
SK_OPTS_TARGET_DEFAULT
#
include
"
src
/
opts
/
SkOpts_SetTarget
.
h
"
#
include
"
src
/
opts
/
SkRasterPipeline_opts
.
h
"
#
include
"
src
/
opts
/
SkOpts_RestoreTarget
.
h
"
namespace
SkOpts
{
size_t
raster_pipeline_lowp_stride
=
SK_OPTS_NS
:
:
raster_pipeline_lowp_stride
(
)
;
size_t
raster_pipeline_highp_stride
=
SK_OPTS_NS
:
:
raster_pipeline_highp_stride
(
)
;
#
define
M
(
st
)
(
StageFn
)
SK_OPTS_NS
:
:
st
StageFn
ops_highp
[
]
=
{
SK_RASTER_PIPELINE_OPS_ALL
(
M
)
}
;
StageFn
just_return_highp
=
(
StageFn
)
SK_OPTS_NS
:
:
just_return
;
void
(
*
start_pipeline_highp
)
(
size_t
size_t
size_t
size_t
SkRasterPipelineStage
*
SkSpan
<
SkRasterPipeline_MemoryCtxPatch
>
uint8_t
*
)
=
SK_OPTS_NS
:
:
start_pipeline
;
#
undef
M
#
define
M
(
st
)
(
StageFn
)
SK_OPTS_NS
:
:
lowp
:
:
st
StageFn
ops_lowp
[
]
=
{
SK_RASTER_PIPELINE_OPS_LOWP
(
M
)
}
;
StageFn
just_return_lowp
=
(
StageFn
)
SK_OPTS_NS
:
:
lowp
:
:
just_return
;
void
(
*
start_pipeline_lowp
)
(
size_t
size_t
size_t
size_t
SkRasterPipelineStage
*
SkSpan
<
SkRasterPipeline_MemoryCtxPatch
>
uint8_t
*
)
=
SK_OPTS_NS
:
:
lowp
:
:
start_pipeline
;
#
undef
M
void
Init_hsw
(
)
;
void
Init_skx
(
)
;
static
bool
init
(
)
{
#
if
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
#
elif
defined
(
SK_CPU_X86
)
#
if
SK_CPU_SSE_LEVEL
<
SK_CPU_SSE_LEVEL_AVX2
if
(
SkCpu
:
:
Supports
(
SkCpu
:
:
HSW
)
)
{
Init_hsw
(
)
;
}
#
endif
#
if
(
SK_CPU_SSE_LEVEL
<
SK_CPU_SSE_LEVEL_SKX
)
&
&
defined
(
SK_ENABLE_AVX512_OPTS
)
if
(
SkCpu
:
:
Supports
(
SkCpu
:
:
SKX
)
)
{
Init_skx
(
)
;
}
#
endif
#
endif
return
true
;
}
void
Init
(
)
{
[
[
maybe_unused
]
]
static
bool
gInitialized
=
init
(
)
;
}
}
