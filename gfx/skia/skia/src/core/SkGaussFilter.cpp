#
include
"
SkGaussFilter
.
h
"
#
include
<
cmath
>
#
include
"
SkTypes
.
h
"
static
constexpr
double
kPi
=
3
.
14159265358979323846264338327950288
;
static
constexpr
double
kGoodEnough
=
1
.
0
/
100
.
0
;
static
void
normalize
(
int
n
double
*
gauss
)
{
double
sum
=
0
;
for
(
int
i
=
n
-
1
;
i
>
=
1
;
i
-
-
)
{
sum
+
=
2
*
gauss
[
i
]
;
}
sum
+
=
gauss
[
0
]
;
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
gauss
[
i
]
/
=
sum
;
}
sum
=
0
;
for
(
int
i
=
n
-
1
;
i
>
=
1
;
i
-
-
)
{
sum
+
=
2
*
gauss
[
i
]
;
}
gauss
[
0
]
=
1
-
sum
;
}
static
int
calculate_bessel_factors
(
double
sigma
double
*
gauss
)
{
auto
var
=
sigma
*
sigma
;
auto
besselI_0
=
[
]
(
double
t
)
-
>
double
{
auto
tSquaredOver4
=
t
*
t
/
4
.
0
;
auto
sum
=
1
.
0
;
auto
factor
=
1
.
0
;
auto
k
=
1
;
while
(
factor
>
1
.
0
/
1000000
.
0
)
{
factor
*
=
tSquaredOver4
/
(
k
*
k
)
;
sum
+
=
factor
;
k
+
=
1
;
}
return
sum
;
}
;
auto
besselI_1
=
[
]
(
double
t
)
-
>
double
{
auto
tSquaredOver4
=
t
*
t
/
4
.
0
;
auto
sum
=
t
/
2
.
0
;
auto
factor
=
sum
;
auto
k
=
1
;
while
(
factor
>
1
.
0
/
1000000
.
0
)
{
factor
*
=
tSquaredOver4
/
(
k
*
(
k
+
1
)
)
;
sum
+
=
factor
;
k
+
=
1
;
}
return
sum
;
}
;
auto
d
=
std
:
:
exp
(
var
)
;
double
b
[
SkGaussFilter
:
:
kGaussArrayMax
]
=
{
besselI_0
(
var
)
besselI_1
(
var
)
}
;
gauss
[
0
]
=
b
[
0
]
/
d
;
gauss
[
1
]
=
b
[
1
]
/
d
;
int
n
=
1
;
while
(
gauss
[
n
]
>
kGoodEnough
)
{
b
[
n
+
1
]
=
-
(
2
*
n
/
var
)
*
b
[
n
]
+
b
[
n
-
1
]
;
gauss
[
n
+
1
]
=
b
[
n
+
1
]
/
d
;
n
+
=
1
;
}
normalize
(
n
gauss
)
;
return
n
;
}
static
int
calculate_gauss_factors
(
double
sigma
double
*
gauss
)
{
SkASSERT
(
0
<
=
sigma
&
&
sigma
<
2
)
;
auto
var
=
sigma
*
sigma
;
auto
expGaussDenom
=
-
2
*
var
;
auto
normalizeDenom
=
std
:
:
sqrt
(
2
*
kPi
)
*
sigma
;
double
g0
=
1
.
0
/
normalizeDenom
;
double
g1
=
std
:
:
exp
(
1
.
0
/
expGaussDenom
)
;
double
g2
=
g1
*
g1
;
gauss
[
0
]
=
g0
;
g0
*
=
g1
;
g1
*
=
g2
;
gauss
[
1
]
=
g0
;
int
n
=
1
;
while
(
gauss
[
n
]
>
kGoodEnough
)
{
g0
*
=
g1
;
g1
*
=
g2
;
gauss
[
n
+
1
]
=
g0
;
n
+
=
1
;
}
normalize
(
n
gauss
)
;
return
n
;
}
SkGaussFilter
:
:
SkGaussFilter
(
double
sigma
Type
type
)
{
SkASSERT
(
0
<
=
sigma
&
&
sigma
<
2
)
;
if
(
type
=
=
Type
:
:
Bessel
)
{
fN
=
calculate_bessel_factors
(
sigma
fBasis
)
;
}
else
{
fN
=
calculate_gauss_factors
(
sigma
fBasis
)
;
}
}
