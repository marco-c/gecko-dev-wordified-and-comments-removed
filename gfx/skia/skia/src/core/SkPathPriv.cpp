#
include
"
include
/
private
/
SkPathRef
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
static
int
rect_make_dir
(
SkScalar
dx
SkScalar
dy
)
{
return
(
(
0
!
=
dx
)
<
<
0
)
|
(
(
dx
>
0
|
|
dy
>
0
)
<
<
1
)
;
}
std
:
:
optional
<
SkPathPriv
:
:
RectContour
>
SkPathPriv
:
:
IsRectContour
(
SkSpan
<
const
SkPoint
>
ptSpan
SkSpan
<
const
SkPathVerb
>
vbSpan
bool
allowPartial
)
{
if
(
ptSpan
.
size
(
)
<
4
)
{
return
{
}
;
}
size_t
currVerb
=
0
;
const
size_t
verbCnt
=
vbSpan
.
size
(
)
;
int
corners
=
0
;
SkPoint
closeXY
;
SkPoint
lineStart
;
const
SkPoint
*
firstPt
=
nullptr
;
const
SkPoint
*
lastPt
=
nullptr
;
SkPoint
firstCorner
;
SkPoint
thirdCorner
;
const
SkPoint
*
pts
=
ptSpan
.
data
(
)
;
const
SkPoint
*
savePts
=
nullptr
;
lineStart
.
set
(
0
0
)
;
signed
char
directions
[
]
=
{
-
1
-
1
-
1
-
1
-
1
}
;
bool
closedOrMoved
=
false
;
bool
autoClose
=
false
;
bool
insertClose
=
false
;
while
(
currVerb
<
verbCnt
&
&
(
!
allowPartial
|
|
!
autoClose
)
)
{
SkPathVerb
verb
=
insertClose
?
SkPathVerb
:
:
kClose
:
vbSpan
[
currVerb
]
;
switch
(
verb
)
{
case
SkPathVerb
:
:
kClose
:
savePts
=
pts
;
autoClose
=
true
;
insertClose
=
false
;
[
[
fallthrough
]
]
;
case
SkPathVerb
:
:
kLine
:
{
if
(
SkPathVerb
:
:
kClose
!
=
verb
)
{
lastPt
=
pts
;
}
SkPoint
lineEnd
=
SkPathVerb
:
:
kClose
=
=
verb
?
*
firstPt
:
*
pts
+
+
;
SkVector
lineDelta
=
lineEnd
-
lineStart
;
if
(
lineDelta
.
fX
&
&
lineDelta
.
fY
)
{
return
{
}
;
}
if
(
!
lineDelta
.
isFinite
(
)
)
{
return
{
}
;
}
if
(
lineStart
=
=
lineEnd
)
{
break
;
}
int
nextDirection
=
rect_make_dir
(
lineDelta
.
fX
lineDelta
.
fY
)
;
if
(
0
=
=
corners
)
{
directions
[
0
]
=
nextDirection
;
corners
=
1
;
closedOrMoved
=
false
;
lineStart
=
lineEnd
;
break
;
}
if
(
closedOrMoved
)
{
return
{
}
;
}
if
(
autoClose
&
&
nextDirection
=
=
directions
[
0
]
)
{
break
;
}
closedOrMoved
=
autoClose
;
if
(
directions
[
corners
-
1
]
=
=
nextDirection
)
{
if
(
3
=
=
corners
&
&
SkPathVerb
:
:
kLine
=
=
verb
)
{
thirdCorner
=
lineEnd
;
}
lineStart
=
lineEnd
;
break
;
}
directions
[
corners
+
+
]
=
nextDirection
;
switch
(
corners
)
{
case
2
:
firstCorner
=
lineStart
;
break
;
case
3
:
if
(
(
directions
[
0
]
^
directions
[
2
]
)
!
=
2
)
{
return
{
}
;
}
thirdCorner
=
lineEnd
;
break
;
case
4
:
if
(
(
directions
[
1
]
^
directions
[
3
]
)
!
=
2
)
{
return
{
}
;
}
break
;
default
:
return
{
}
;
}
lineStart
=
lineEnd
;
break
;
}
case
SkPathVerb
:
:
kQuad
:
case
SkPathVerb
:
:
kConic
:
case
SkPathVerb
:
:
kCubic
:
return
{
}
;
case
SkPathVerb
:
:
kMove
:
if
(
allowPartial
&
&
!
autoClose
&
&
directions
[
0
]
>
=
0
)
{
insertClose
=
true
;
currVerb
-
=
1
;
goto
addMissingClose
;
}
if
(
pts
!
=
ptSpan
.
data
(
)
)
{
return
{
}
;
}
if
(
!
corners
)
{
firstPt
=
pts
;
}
else
{
closeXY
=
*
firstPt
-
*
lastPt
;
if
(
closeXY
.
fX
&
&
closeXY
.
fY
)
{
return
{
}
;
}
}
lineStart
=
*
pts
+
+
;
closedOrMoved
=
true
;
break
;
default
:
SkDEBUGFAIL
(
"
unexpected
verb
"
)
;
break
;
}
currVerb
+
=
1
;
addMissingClose
:
;
}
if
(
corners
<
3
|
|
corners
>
4
)
{
return
{
}
;
}
closeXY
=
*
firstPt
-
*
lastPt
;
if
(
closeXY
.
fX
&
&
closeXY
.
fY
)
{
return
{
}
;
}
auto
bounds
=
[
]
(
SkPoint
a
SkPoint
b
)
{
SkRect
r
;
r
.
set
(
a
b
)
;
return
r
;
}
;
return
{
{
bounds
(
firstCorner
thirdCorner
)
autoClose
directions
[
0
]
=
=
(
(
directions
[
1
]
+
1
)
&
3
)
?
SkPathDirection
:
:
kCW
:
SkPathDirection
:
:
kCCW
savePts
?
size_t
(
savePts
-
ptSpan
.
data
(
)
)
:
0
currVerb
}
}
;
}
bool
SkPathPriv
:
:
IsNestedFillRects
(
const
SkPathRaw
&
raw
SkRect
rects
[
2
]
SkPathDirection
dirs
[
2
]
)
{
SkPathDirection
testDirs
[
2
]
;
SkRect
testRects
[
2
]
;
SkSpan
<
const
SkPoint
>
pts
=
raw
.
points
(
)
;
SkSpan
<
const
SkPathVerb
>
vbs
=
raw
.
verbs
(
)
;
auto
rc
=
IsRectContour
(
pts
vbs
true
)
;
if
(
!
rc
)
{
return
false
;
}
testDirs
[
0
]
=
rc
-
>
fDirection
;
testRects
[
0
]
=
rc
-
>
fRect
;
pts
=
pts
.
subspan
(
rc
-
>
fPointsConsumed
)
;
vbs
=
vbs
.
subspan
(
rc
-
>
fVerbsConsumed
)
;
rc
=
IsRectContour
(
pts
vbs
false
)
;
if
(
rc
)
{
testDirs
[
1
]
=
rc
-
>
fDirection
;
testRects
[
1
]
=
rc
-
>
fRect
;
if
(
testRects
[
0
]
.
contains
(
testRects
[
1
]
)
)
{
if
(
rects
)
{
rects
[
0
]
=
testRects
[
0
]
;
rects
[
1
]
=
testRects
[
1
]
;
}
if
(
dirs
)
{
dirs
[
0
]
=
testDirs
[
0
]
;
dirs
[
1
]
=
testDirs
[
1
]
;
}
return
true
;
}
if
(
testRects
[
1
]
.
contains
(
testRects
[
0
]
)
)
{
if
(
rects
)
{
rects
[
0
]
=
testRects
[
1
]
;
rects
[
1
]
=
testRects
[
0
]
;
}
if
(
dirs
)
{
dirs
[
0
]
=
testDirs
[
1
]
;
dirs
[
1
]
=
testDirs
[
0
]
;
}
return
true
;
}
}
return
false
;
}
