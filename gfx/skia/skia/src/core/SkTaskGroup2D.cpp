#
include
"
SkTaskGroup2D
.
h
"
void
SkTaskGroup2D
:
:
start
(
)
{
fThreadsGroup
-
>
batch
(
fThreadCnt
[
this
]
(
int
threadId
)
{
this
-
>
work
(
threadId
)
;
}
)
;
}
void
SkTaskGroup2D
:
:
addColumn
(
)
{
SkASSERT
(
!
fIsFinishing
)
;
fWidth
+
+
;
}
void
SkTaskGroup2D
:
:
finish
(
)
{
fIsFinishing
.
store
(
true
std
:
:
memory_order_relaxed
)
;
fThreadsGroup
-
>
wait
(
)
;
}
void
SkSpinningTaskGroup2D
:
:
work
(
int
threadId
)
{
int
workCol
=
0
;
int
initCol
=
0
;
while
(
true
)
{
SkASSERT
(
workCol
<
=
fWidth
)
;
if
(
this
-
>
isFinishing
(
)
&
&
workCol
>
=
fWidth
)
{
return
;
}
if
(
workCol
<
fWidth
&
&
fKernel
-
>
work2D
(
threadId
workCol
threadId
)
)
{
workCol
+
+
;
}
else
{
this
-
>
initAnUninitializedColumn
(
initCol
threadId
)
;
}
}
}
void
SkFlexibleTaskGroup2D
:
:
work
(
int
threadId
)
{
int
row
=
threadId
;
int
initCol
=
0
;
int
numRowsCompleted
=
0
;
std
:
:
vector
<
bool
>
completedRows
(
fHeight
false
)
;
while
(
threadId
<
fHeight
-
numRowsCompleted
)
{
RowData
&
rowData
=
fRowData
[
row
]
;
#
ifdef
__clang__
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wthread
-
safety
-
analysis
"
#
endif
if
(
rowData
.
fMutex
.
try_acquire
(
)
)
{
while
(
rowData
.
fNextColumn
<
fWidth
&
&
fKernel
-
>
work2D
(
row
rowData
.
fNextColumn
threadId
)
)
{
rowData
.
fNextColumn
+
+
;
}
if
(
rowData
.
fNextColumn
=
=
fWidth
&
&
this
-
>
isFinishing
(
)
)
{
numRowsCompleted
+
=
(
completedRows
[
row
]
=
=
false
)
;
completedRows
[
row
]
=
true
;
}
rowData
.
fMutex
.
release
(
)
;
}
#
ifdef
__clang__
#
pragma
clang
diagnostic
pop
#
endif
row
=
(
row
+
1
)
%
fHeight
;
this
-
>
initAnUninitializedColumn
(
initCol
threadId
)
;
}
}
