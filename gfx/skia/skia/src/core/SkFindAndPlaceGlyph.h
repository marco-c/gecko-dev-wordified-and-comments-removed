#
ifndef
SkFindAndPositionGlyph_DEFINED
#
define
SkFindAndPositionGlyph_DEFINED
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkGlyph
.
h
"
#
include
"
SkMatrixPriv
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkStrike
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkUTF
.
h
"
#
include
<
utility
>
class
SkFindAndPlaceGlyph
{
public
:
template
<
typename
ProcessOneGlyph
>
static
void
ProcessPosText
(
const
SkGlyphID
[
]
int
count
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkStrike
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
;
static
SkIPoint
SubpixelAlignment
(
SkAxisAlignment
axisAlignment
SkPoint
position
)
{
if
(
!
SkScalarsAreFinite
(
position
.
fX
position
.
fY
)
)
{
return
{
0
0
}
;
}
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
SkScalarToFixed
(
SkScalarFraction
(
position
.
fX
)
+
kSubpixelRounding
)
0
}
;
case
kY_SkAxisAlignment
:
return
{
0
SkScalarToFixed
(
SkScalarFraction
(
position
.
fY
)
+
kSubpixelRounding
)
}
;
case
kNone_SkAxisAlignment
:
return
{
SkScalarToFixed
(
SkScalarFraction
(
position
.
fX
)
+
kSubpixelRounding
)
SkScalarToFixed
(
SkScalarFraction
(
position
.
fY
)
+
kSubpixelRounding
)
}
;
}
SK_ABORT
(
"
Should
not
get
here
.
"
)
;
return
{
0
0
}
;
}
static
SkPoint
SubpixelPositionRounding
(
SkAxisAlignment
axisAlignment
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
kSubpixelRounding
SK_ScalarHalf
}
;
case
kY_SkAxisAlignment
:
return
{
SK_ScalarHalf
kSubpixelRounding
}
;
case
kNone_SkAxisAlignment
:
return
{
kSubpixelRounding
kSubpixelRounding
}
;
}
SK_ABORT
(
"
Should
not
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
class
MapperInterface
{
public
:
virtual
~
MapperInterface
(
)
{
}
virtual
SkPoint
map
(
SkPoint
position
)
const
=
0
;
}
;
static
MapperInterface
*
CreateMapper
(
const
SkMatrix
&
matrix
const
SkPoint
&
offset
int
scalarsPerPosition
SkArenaAlloc
*
arena
)
{
auto
mtype
=
matrix
.
getType
(
)
;
if
(
mtype
&
(
SkMatrix
:
:
kAffine_Mask
|
SkMatrix
:
:
kPerspective_Mask
)
|
|
scalarsPerPosition
=
=
2
)
{
return
arena
-
>
make
<
GeneralMapper
>
(
matrix
offset
)
;
}
if
(
mtype
&
SkMatrix
:
:
kScale_Mask
)
{
return
arena
-
>
make
<
XScaleMapper
>
(
matrix
offset
)
;
}
return
arena
-
>
make
<
TranslationMapper
>
(
matrix
offset
)
;
}
private
:
class
PositionReaderInterface
{
public
:
virtual
~
PositionReaderInterface
(
)
{
}
virtual
SkPoint
nextPoint
(
)
=
0
;
}
;
class
HorizontalPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
HorizontalPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkScalar
x
=
*
fPositions
+
+
;
return
{
x
0
}
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
class
ArbitraryPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
ArbitraryPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkPoint
to_return
{
fPositions
[
0
]
fPositions
[
1
]
}
;
fPositions
+
=
2
;
return
to_return
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
class
TranslationMapper
final
:
public
MapperInterface
{
public
:
TranslationMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
position
+
fTranslate
;
}
private
:
const
SkPoint
fTranslate
;
}
;
class
XScaleMapper
final
:
public
MapperInterface
{
public
:
XScaleMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
fXScale
(
matrix
.
getScaleX
(
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
{
fXScale
*
position
.
fX
+
fTranslate
.
fX
fTranslate
.
fY
}
;
}
private
:
const
SkPoint
fTranslate
;
const
SkScalar
fXScale
;
}
;
class
GeneralMapper
final
:
public
MapperInterface
{
public
:
GeneralMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fOrigin
(
origin
)
fMatrix
(
matrix
)
fMapProc
(
SkMatrixPriv
:
:
GetMapXYProc
(
matrix
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
SkPoint
result
;
fMapProc
(
fMatrix
position
.
fX
+
fOrigin
.
fX
position
.
fY
+
fOrigin
.
fY
&
result
)
;
return
result
;
}
private
:
const
SkPoint
fOrigin
;
const
SkMatrix
&
fMatrix
;
const
SkMatrixPriv
:
:
MapXYProc
fMapProc
;
}
;
static
constexpr
SkScalar
kSubpixelRounding
=
SkFixedToScalar
(
SkGlyph
:
:
kSubpixelRound
)
;
template
<
typename
ProcessOneGlyph
>
class
GlyphFindAndPlaceInterface
:
SkNoncopyable
{
public
:
virtual
~
GlyphFindAndPlaceInterface
(
)
{
}
virtual
SkPoint
findAndPositionGlyph
(
SkGlyphID
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
{
SK_ABORT
(
"
Should
never
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
}
;
template
<
typename
ProcessOneGlyph
SkAxisAlignment
kAxisAlignment
>
class
GlyphFindAndPlaceSubpixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
explicit
GlyphFindAndPlaceSubpixel
(
SkStrike
*
cache
)
:
fCache
(
cache
)
{
}
SkPoint
findAndPositionGlyph
(
SkGlyphID
glyphID
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkIPoint
lookupPosition
=
SubpixelAlignment
(
kAxisAlignment
position
)
;
const
SkGlyph
&
renderGlyph
=
fCache
-
>
getGlyphIDMetrics
(
glyphID
lookupPosition
.
fX
lookupPosition
.
fY
)
;
if
(
renderGlyph
.
fWidth
>
0
)
{
processOneGlyph
(
renderGlyph
position
SubpixelPositionRounding
(
kAxisAlignment
)
)
;
}
return
position
+
SkPoint
{
SkFloatToScalar
(
renderGlyph
.
fAdvanceX
)
SkFloatToScalar
(
renderGlyph
.
fAdvanceY
)
}
;
}
private
:
SkStrike
*
fCache
;
}
;
template
<
typename
ProcessOneGlyph
>
class
GlyphFindAndPlaceFullPixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
explicit
GlyphFindAndPlaceFullPixel
(
SkStrike
*
cache
)
:
fCache
(
cache
)
{
}
SkPoint
findAndPositionGlyph
(
SkGlyphID
glyphID
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkPoint
finalPosition
=
position
;
const
SkGlyph
&
glyph
=
fCache
-
>
getGlyphIDMetrics
(
glyphID
)
;
if
(
glyph
.
fWidth
>
0
)
{
processOneGlyph
(
glyph
finalPosition
{
SK_ScalarHalf
SK_ScalarHalf
}
)
;
}
return
finalPosition
+
SkPoint
{
SkFloatToScalar
(
glyph
.
fAdvanceX
)
SkFloatToScalar
(
glyph
.
fAdvanceY
)
}
;
}
private
:
SkStrike
*
fCache
;
}
;
template
<
typename
ProcessOneGlyph
>
static
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
*
getSubpixel
(
SkArenaAlloc
*
arena
SkAxisAlignment
axisAlignment
SkStrike
*
cache
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kX_SkAxisAlignment
>
>
(
cache
)
;
case
kNone_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kNone_SkAxisAlignment
>
>
(
cache
)
;
case
kY_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kY_SkAxisAlignment
>
>
(
cache
)
;
}
SK_ABORT
(
"
Should
never
get
here
.
"
)
;
return
nullptr
;
}
}
;
template
<
typename
ProcessOneGlyph
>
inline
void
SkFindAndPlaceGlyph
:
:
ProcessPosText
(
const
SkGlyphID
glyphs
[
]
int
count
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkStrike
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
{
SkAxisAlignment
axisAlignment
=
cache
-
>
getScalerContext
(
)
-
>
computeAxisAlignmentForHText
(
)
;
uint32_t
mtype
=
matrix
.
getType
(
)
;
if
(
axisAlignment
=
=
kX_SkAxisAlignment
&
&
cache
-
>
isSubpixel
(
)
&
&
mtype
<
=
SkMatrix
:
:
kTranslate_Mask
)
{
using
Positioner
=
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kX_SkAxisAlignment
>
;
HorizontalPositions
hPositions
{
pos
}
;
ArbitraryPositions
aPositions
{
pos
}
;
PositionReaderInterface
*
positions
=
nullptr
;
if
(
scalarsPerPosition
=
=
2
)
{
positions
=
&
aPositions
;
}
else
{
positions
=
&
hPositions
;
}
TranslationMapper
mapper
{
matrix
offset
}
;
Positioner
positioner
(
cache
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkPoint
mappedPoint
=
mapper
.
TranslationMapper
:
:
map
(
positions
-
>
nextPoint
(
)
)
;
positioner
.
Positioner
:
:
findAndPositionGlyph
(
glyphs
[
i
]
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
return
;
}
SkSTArenaAlloc
<
120
>
arena
;
PositionReaderInterface
*
positionReader
=
nullptr
;
if
(
2
=
=
scalarsPerPosition
)
{
positionReader
=
arena
.
make
<
ArbitraryPositions
>
(
pos
)
;
}
else
{
positionReader
=
arena
.
make
<
HorizontalPositions
>
(
pos
)
;
}
MapperInterface
*
mapper
=
CreateMapper
(
matrix
offset
scalarsPerPosition
&
arena
)
;
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
*
findAndPosition
=
nullptr
;
if
(
cache
-
>
isSubpixel
(
)
)
{
findAndPosition
=
getSubpixel
<
ProcessOneGlyph
>
(
&
arena
axisAlignment
cache
)
;
}
else
{
findAndPosition
=
arena
.
make
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
>
>
(
cache
)
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkPoint
mappedPoint
=
mapper
-
>
map
(
positionReader
-
>
nextPoint
(
)
)
;
findAndPosition
-
>
findAndPositionGlyph
(
glyphs
[
i
]
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
}
#
endif
