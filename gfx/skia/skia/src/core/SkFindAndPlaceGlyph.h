#
ifndef
SkFindAndPositionGlyph_DEFINED
#
define
SkFindAndPositionGlyph_DEFINED
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkGlyph
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkMatrixPriv
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkUTF
.
h
"
#
include
<
utility
>
class
SkFindAndPlaceGlyph
{
public
:
template
<
typename
ProcessOneGlyph
>
static
void
ProcessPosText
(
SkPaint
:
:
TextEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
;
static
SkIPoint
SubpixelAlignment
(
SkAxisAlignment
axisAlignment
SkPoint
position
)
{
if
(
!
SkScalarsAreFinite
(
position
.
fX
position
.
fY
)
)
{
return
{
0
0
}
;
}
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
SkScalarToFixed
(
SkScalarFraction
(
position
.
fX
)
+
kSubpixelRounding
)
0
}
;
case
kY_SkAxisAlignment
:
return
{
0
SkScalarToFixed
(
SkScalarFraction
(
position
.
fY
)
+
kSubpixelRounding
)
}
;
case
kNone_SkAxisAlignment
:
return
{
SkScalarToFixed
(
SkScalarFraction
(
position
.
fX
)
+
kSubpixelRounding
)
SkScalarToFixed
(
SkScalarFraction
(
position
.
fY
)
+
kSubpixelRounding
)
}
;
}
SK_ABORT
(
"
Should
not
get
here
.
"
)
;
return
{
0
0
}
;
}
static
SkPoint
SubpixelPositionRounding
(
SkAxisAlignment
axisAlignment
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
kSubpixelRounding
SK_ScalarHalf
}
;
case
kY_SkAxisAlignment
:
return
{
SK_ScalarHalf
kSubpixelRounding
}
;
case
kNone_SkAxisAlignment
:
return
{
kSubpixelRounding
kSubpixelRounding
}
;
}
SK_ABORT
(
"
Should
not
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
class
MapperInterface
{
public
:
virtual
~
MapperInterface
(
)
{
}
virtual
SkPoint
map
(
SkPoint
position
)
const
=
0
;
}
;
static
MapperInterface
*
CreateMapper
(
const
SkMatrix
&
matrix
const
SkPoint
&
offset
int
scalarsPerPosition
SkArenaAlloc
*
arena
)
{
auto
mtype
=
matrix
.
getType
(
)
;
if
(
mtype
&
(
SkMatrix
:
:
kAffine_Mask
|
SkMatrix
:
:
kPerspective_Mask
)
|
|
scalarsPerPosition
=
=
2
)
{
return
arena
-
>
make
<
GeneralMapper
>
(
matrix
offset
)
;
}
if
(
mtype
&
SkMatrix
:
:
kScale_Mask
)
{
return
arena
-
>
make
<
XScaleMapper
>
(
matrix
offset
)
;
}
return
arena
-
>
make
<
TranslationMapper
>
(
matrix
offset
)
;
}
private
:
class
GlyphFinderInterface
{
public
:
virtual
~
GlyphFinderInterface
(
)
{
}
virtual
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
const
char
*
stop
)
=
0
;
virtual
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
const
char
*
stop
SkFixed
x
SkFixed
y
)
=
0
;
}
;
class
UtfNGlyphFinder
:
public
GlyphFinderInterface
{
public
:
explicit
UtfNGlyphFinder
(
SkGlyphCache
*
cache
)
:
fCache
(
cache
)
{
SkASSERT
(
cache
!
=
nullptr
)
;
}
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
const
char
*
stop
)
override
{
SkASSERT
(
text
!
=
nullptr
)
;
return
fCache
-
>
getUnicharMetrics
(
nextUnichar
(
text
stop
)
)
;
}
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
const
char
*
stop
SkFixed
x
SkFixed
y
)
override
{
SkASSERT
(
text
!
=
nullptr
)
;
return
fCache
-
>
getUnicharMetrics
(
nextUnichar
(
text
stop
)
x
y
)
;
}
private
:
virtual
SkUnichar
nextUnichar
(
const
char
*
*
text
const
char
*
stop
)
=
0
;
SkGlyphCache
*
fCache
;
}
;
class
Utf8GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
explicit
Utf8GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
const
char
*
stop
)
override
{
return
SkUTF
:
:
NextUTF8
(
text
stop
)
;
}
}
;
class
Utf16GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
explicit
Utf16GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
const
char
*
stop
)
override
{
return
SkUTF
:
:
NextUTF16
(
(
const
uint16_t
*
*
)
text
(
const
uint16_t
*
)
stop
)
;
}
}
;
class
Utf32GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
explicit
Utf32GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
const
char
*
stop
)
override
{
return
SkUTF
:
:
NextUTF32
(
(
const
int32_t
*
*
)
text
(
const
int32_t
*
)
stop
)
;
}
}
;
class
GlyphIdGlyphFinder
final
:
public
GlyphFinderInterface
{
public
:
explicit
GlyphIdGlyphFinder
(
SkGlyphCache
*
cache
)
:
fCache
(
cache
)
{
SkASSERT
(
cache
!
=
nullptr
)
;
}
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
const
char
*
stop
)
override
{
return
fCache
-
>
getGlyphIDMetrics
(
nextGlyphId
(
text
stop
)
)
;
}
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
const
char
*
stop
SkFixed
x
SkFixed
y
)
override
{
return
fCache
-
>
getGlyphIDMetrics
(
nextGlyphId
(
text
stop
)
x
y
)
;
}
private
:
uint16_t
nextGlyphId
(
const
char
*
*
text
const
char
*
stop
)
{
SkASSERT
(
text
!
=
nullptr
)
;
const
uint16_t
*
ptr
=
*
(
const
uint16_t
*
*
)
text
;
SkASSERT
(
ptr
)
;
if
(
ptr
+
1
>
(
const
uint16_t
*
)
stop
)
{
*
text
=
stop
;
return
0
;
}
uint16_t
glyphID
=
*
ptr
;
ptr
+
=
1
;
*
text
=
(
const
char
*
)
ptr
;
return
glyphID
;
}
SkGlyphCache
*
fCache
;
}
;
static
GlyphFinderInterface
*
getGlyphFinder
(
SkArenaAlloc
*
arena
SkPaint
:
:
TextEncoding
encoding
SkGlyphCache
*
cache
)
{
switch
(
encoding
)
{
case
SkPaint
:
:
kUTF8_TextEncoding
:
return
arena
-
>
make
<
Utf8GlyphFinder
>
(
cache
)
;
case
SkPaint
:
:
kUTF16_TextEncoding
:
return
arena
-
>
make
<
Utf16GlyphFinder
>
(
cache
)
;
case
SkPaint
:
:
kUTF32_TextEncoding
:
return
arena
-
>
make
<
Utf32GlyphFinder
>
(
cache
)
;
case
SkPaint
:
:
kGlyphID_TextEncoding
:
return
arena
-
>
make
<
GlyphIdGlyphFinder
>
(
cache
)
;
}
SK_ABORT
(
"
Should
not
get
here
.
"
)
;
return
nullptr
;
}
class
PositionReaderInterface
{
public
:
virtual
~
PositionReaderInterface
(
)
{
}
virtual
SkPoint
nextPoint
(
)
=
0
;
}
;
class
HorizontalPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
HorizontalPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkScalar
x
=
*
fPositions
+
+
;
return
{
x
0
}
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
class
ArbitraryPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
ArbitraryPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkPoint
to_return
{
fPositions
[
0
]
fPositions
[
1
]
}
;
fPositions
+
=
2
;
return
to_return
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
class
TranslationMapper
final
:
public
MapperInterface
{
public
:
TranslationMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
position
+
fTranslate
;
}
private
:
const
SkPoint
fTranslate
;
}
;
class
XScaleMapper
final
:
public
MapperInterface
{
public
:
XScaleMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
fXScale
(
matrix
.
getScaleX
(
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
{
fXScale
*
position
.
fX
+
fTranslate
.
fX
fTranslate
.
fY
}
;
}
private
:
const
SkPoint
fTranslate
;
const
SkScalar
fXScale
;
}
;
class
GeneralMapper
final
:
public
MapperInterface
{
public
:
GeneralMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fOrigin
(
origin
)
fMatrix
(
matrix
)
fMapProc
(
SkMatrixPriv
:
:
GetMapXYProc
(
matrix
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
SkPoint
result
;
fMapProc
(
fMatrix
position
.
fX
+
fOrigin
.
fX
position
.
fY
+
fOrigin
.
fY
&
result
)
;
return
result
;
}
private
:
const
SkPoint
fOrigin
;
const
SkMatrix
&
fMatrix
;
const
SkMatrixPriv
:
:
MapXYProc
fMapProc
;
}
;
static
constexpr
SkScalar
kSubpixelRounding
=
SkFixedToScalar
(
SkGlyph
:
:
kSubpixelRound
)
;
template
<
typename
ProcessOneGlyph
>
class
GlyphFindAndPlaceInterface
:
SkNoncopyable
{
public
:
virtual
~
GlyphFindAndPlaceInterface
(
)
{
}
virtual
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
const
char
*
stop
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
{
SK_ABORT
(
"
Should
never
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
}
;
template
<
typename
ProcessOneGlyph
SkAxisAlignment
kAxisAlignment
>
class
GlyphFindAndPlaceSubpixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
explicit
GlyphFindAndPlaceSubpixel
(
GlyphFinderInterface
*
glyphFinder
)
:
fGlyphFinder
(
glyphFinder
)
{
}
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
const
char
*
stop
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkIPoint
lookupPosition
=
SubpixelAlignment
(
kAxisAlignment
position
)
;
const
SkGlyph
&
renderGlyph
=
fGlyphFinder
-
>
lookupGlyphXY
(
text
stop
lookupPosition
.
fX
lookupPosition
.
fY
)
;
if
(
renderGlyph
.
fWidth
>
0
)
{
processOneGlyph
(
renderGlyph
position
SubpixelPositionRounding
(
kAxisAlignment
)
)
;
}
return
position
+
SkPoint
{
SkFloatToScalar
(
renderGlyph
.
fAdvanceX
)
SkFloatToScalar
(
renderGlyph
.
fAdvanceY
)
}
;
}
private
:
GlyphFinderInterface
*
fGlyphFinder
;
}
;
template
<
typename
ProcessOneGlyph
>
class
GlyphFindAndPlaceFullPixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
explicit
GlyphFindAndPlaceFullPixel
(
GlyphFinderInterface
*
glyphFinder
)
:
fGlyphFinder
(
glyphFinder
)
{
}
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
const
char
*
stop
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkPoint
finalPosition
=
position
;
const
SkGlyph
&
glyph
=
fGlyphFinder
-
>
lookupGlyph
(
text
stop
)
;
if
(
glyph
.
fWidth
>
0
)
{
processOneGlyph
(
glyph
finalPosition
{
SK_ScalarHalf
SK_ScalarHalf
}
)
;
}
return
finalPosition
+
SkPoint
{
SkFloatToScalar
(
glyph
.
fAdvanceX
)
SkFloatToScalar
(
glyph
.
fAdvanceY
)
}
;
}
private
:
GlyphFinderInterface
*
fGlyphFinder
;
}
;
template
<
typename
ProcessOneGlyph
>
static
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
*
getSubpixel
(
SkArenaAlloc
*
arena
SkAxisAlignment
axisAlignment
GlyphFinderInterface
*
glyphFinder
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kX_SkAxisAlignment
>
>
(
glyphFinder
)
;
case
kNone_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kNone_SkAxisAlignment
>
>
(
glyphFinder
)
;
case
kY_SkAxisAlignment
:
return
arena
-
>
make
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kY_SkAxisAlignment
>
>
(
glyphFinder
)
;
}
SK_ABORT
(
"
Should
never
get
here
.
"
)
;
return
nullptr
;
}
static
SkPoint
MeasureText
(
GlyphFinderInterface
*
glyphFinder
const
char
text
[
]
size_t
byteLength
)
{
SkScalar
x
=
0
y
=
0
;
const
char
*
stop
=
text
+
byteLength
;
while
(
text
<
stop
)
{
const
SkGlyph
&
glyph
=
glyphFinder
-
>
lookupGlyph
(
&
text
stop
)
;
x
+
=
SkFloatToScalar
(
glyph
.
fAdvanceX
)
;
y
+
=
SkFloatToScalar
(
glyph
.
fAdvanceY
)
;
}
SkASSERT
(
text
=
=
stop
)
;
return
{
x
y
}
;
}
}
;
template
<
typename
ProcessOneGlyph
>
inline
void
SkFindAndPlaceGlyph
:
:
ProcessPosText
(
SkPaint
:
:
TextEncoding
textEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
{
SkAxisAlignment
axisAlignment
=
cache
-
>
getScalerContext
(
)
-
>
computeAxisAlignmentForHText
(
)
;
uint32_t
mtype
=
matrix
.
getType
(
)
;
if
(
textEncoding
=
=
SkPaint
:
:
kGlyphID_TextEncoding
&
&
axisAlignment
=
=
kX_SkAxisAlignment
&
&
cache
-
>
isSubpixel
(
)
&
&
mtype
<
=
SkMatrix
:
:
kTranslate_Mask
)
{
GlyphIdGlyphFinder
glyphFinder
(
cache
)
;
using
Positioner
=
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kX_SkAxisAlignment
>
;
HorizontalPositions
hPositions
{
pos
}
;
ArbitraryPositions
aPositions
{
pos
}
;
PositionReaderInterface
*
positions
=
nullptr
;
if
(
scalarsPerPosition
=
=
2
)
{
positions
=
&
aPositions
;
}
else
{
positions
=
&
hPositions
;
}
TranslationMapper
mapper
{
matrix
offset
}
;
Positioner
positioner
(
&
glyphFinder
)
;
const
char
*
cursor
=
text
;
const
char
*
stop
=
text
+
byteLength
;
while
(
cursor
<
stop
)
{
SkPoint
mappedPoint
=
mapper
.
TranslationMapper
:
:
map
(
positions
-
>
nextPoint
(
)
)
;
positioner
.
Positioner
:
:
findAndPositionGlyph
(
&
cursor
stop
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
return
;
}
SkSTArenaAlloc
<
120
>
arena
;
GlyphFinderInterface
*
glyphFinder
=
getGlyphFinder
(
&
arena
textEncoding
cache
)
;
PositionReaderInterface
*
positionReader
=
nullptr
;
if
(
2
=
=
scalarsPerPosition
)
{
positionReader
=
arena
.
make
<
ArbitraryPositions
>
(
pos
)
;
}
else
{
positionReader
=
arena
.
make
<
HorizontalPositions
>
(
pos
)
;
}
MapperInterface
*
mapper
=
CreateMapper
(
matrix
offset
scalarsPerPosition
&
arena
)
;
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
*
findAndPosition
=
nullptr
;
if
(
cache
-
>
isSubpixel
(
)
)
{
findAndPosition
=
getSubpixel
<
ProcessOneGlyph
>
(
&
arena
axisAlignment
glyphFinder
)
;
}
else
{
findAndPosition
=
arena
.
make
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
>
>
(
glyphFinder
)
;
}
const
char
*
stop
=
text
+
byteLength
;
while
(
text
<
stop
)
{
SkPoint
mappedPoint
=
mapper
-
>
map
(
positionReader
-
>
nextPoint
(
)
)
;
findAndPosition
-
>
findAndPositionGlyph
(
&
text
stop
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
}
#
endif
