#
ifndef
SkFindAndPositionGlyph_DEFINED
#
define
SkFindAndPositionGlyph_DEFINED
#
include
"
SkAutoKern
.
h
"
#
include
"
SkGlyph
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkUtils
.
h
"
#
include
<
utility
>
template
<
typename
.
.
.
Ts
>
struct
SkMaxSizeOf
;
template
<
>
struct
SkMaxSizeOf
<
>
{
static
const
size_t
value
=
0
;
}
;
template
<
typename
H
typename
.
.
.
Ts
>
struct
SkMaxSizeOf
<
H
Ts
.
.
.
>
{
static
const
size_t
value
=
sizeof
(
H
)
>
=
SkMaxSizeOf
<
Ts
.
.
.
>
:
:
value
?
sizeof
(
H
)
:
SkMaxSizeOf
<
Ts
.
.
.
>
:
:
value
;
}
;
extern
void
FixGCC49Arm64Bug
(
int
v
)
;
class
SkFindAndPlaceGlyph
{
public
:
template
<
typename
ProcessOneGlyph
>
static
void
ProcessText
(
SkPaint
:
:
TextEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
SkPaint
:
:
Align
textAlignment
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
;
template
<
typename
ProcessOneGlyph
>
static
void
ProcessPosText
(
SkPaint
:
:
TextEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkPaint
:
:
Align
textAlignment
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
;
private
:
template
<
typename
.
.
.
Ts
>
class
UntaggedVariant
{
public
:
UntaggedVariant
(
)
{
}
~
UntaggedVariant
(
)
{
}
UntaggedVariant
(
const
UntaggedVariant
&
)
=
delete
;
UntaggedVariant
&
operator
=
(
const
UntaggedVariant
&
)
=
delete
;
UntaggedVariant
(
UntaggedVariant
&
&
)
=
delete
;
UntaggedVariant
&
operator
=
(
UntaggedVariant
&
&
)
=
delete
;
template
<
typename
Variant
typename
.
.
.
Args
>
void
initialize
(
Args
&
&
.
.
.
args
)
{
SkASSERT
(
sizeof
(
Variant
)
<
=
sizeof
(
fSpace
)
)
;
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
define
alignof
__alignof
#
endif
SkASSERT
(
alignof
(
Variant
)
<
=
alignof
(
Space
)
)
;
new
(
&
fSpace
)
Variant
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
private
:
typedef
SkAlignedSStorage
<
SkMaxSizeOf
<
Ts
.
.
.
>
:
:
value
>
Space
;
Space
fSpace
;
}
;
template
<
typename
Base
typename
.
.
.
Ts
>
class
PolymorphicVariant
{
public
:
typedef
UntaggedVariant
<
Ts
.
.
.
>
Variants
;
template
<
typename
Initializer
>
PolymorphicVariant
(
Initializer
&
&
initializer
)
{
initializer
(
&
fVariants
)
;
}
~
PolymorphicVariant
(
)
{
get
(
)
-
>
~
Base
(
)
;
}
Base
*
get
(
)
const
{
return
reinterpret_cast
<
Base
*
>
(
&
fVariants
)
;
}
Base
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
Base
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
private
:
mutable
Variants
fVariants
;
}
;
class
GlyphFinderInterface
{
public
:
virtual
~
GlyphFinderInterface
(
)
{
}
virtual
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
)
=
0
;
virtual
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
SkFixed
x
SkFixed
y
)
=
0
;
}
;
class
UtfNGlyphFinder
:
public
GlyphFinderInterface
{
public
:
UtfNGlyphFinder
(
SkGlyphCache
*
cache
)
:
fCache
(
cache
)
{
SkASSERT
(
cache
!
=
nullptr
)
;
}
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
)
override
{
SkASSERT
(
text
!
=
nullptr
)
;
return
fCache
-
>
getUnicharMetrics
(
nextUnichar
(
text
)
)
;
}
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
SkFixed
x
SkFixed
y
)
override
{
SkASSERT
(
text
!
=
nullptr
)
;
return
fCache
-
>
getUnicharMetrics
(
nextUnichar
(
text
)
x
y
)
;
}
private
:
virtual
SkUnichar
nextUnichar
(
const
char
*
*
text
)
=
0
;
SkGlyphCache
*
fCache
;
}
;
class
Utf8GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
Utf8GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
)
override
{
return
SkUTF8_NextUnichar
(
text
)
;
}
}
;
class
Utf16GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
Utf16GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
)
override
{
return
SkUTF16_NextUnichar
(
(
const
uint16_t
*
*
)
text
)
;
}
}
;
class
Utf32GlyphFinder
final
:
public
UtfNGlyphFinder
{
public
:
Utf32GlyphFinder
(
SkGlyphCache
*
cache
)
:
UtfNGlyphFinder
(
cache
)
{
}
private
:
SkUnichar
nextUnichar
(
const
char
*
*
text
)
override
{
const
int32_t
*
ptr
=
*
(
const
int32_t
*
*
)
text
;
SkUnichar
uni
=
*
ptr
+
+
;
*
text
=
(
const
char
*
)
ptr
;
return
uni
;
}
}
;
class
GlyphIdGlyphFinder
final
:
public
GlyphFinderInterface
{
public
:
GlyphIdGlyphFinder
(
SkGlyphCache
*
cache
)
:
fCache
(
cache
)
{
SkASSERT
(
cache
!
=
nullptr
)
;
}
const
SkGlyph
&
lookupGlyph
(
const
char
*
*
text
)
override
{
return
fCache
-
>
getGlyphIDMetrics
(
nextGlyphId
(
text
)
)
;
}
const
SkGlyph
&
lookupGlyphXY
(
const
char
*
*
text
SkFixed
x
SkFixed
y
)
override
{
return
fCache
-
>
getGlyphIDMetrics
(
nextGlyphId
(
text
)
x
y
)
;
}
private
:
uint16_t
nextGlyphId
(
const
char
*
*
text
)
{
SkASSERT
(
text
!
=
nullptr
)
;
const
uint16_t
*
ptr
=
*
(
const
uint16_t
*
*
)
text
;
uint16_t
glyphID
=
*
ptr
;
ptr
+
=
1
;
*
text
=
(
const
char
*
)
ptr
;
return
glyphID
;
}
SkGlyphCache
*
fCache
;
}
;
typedef
PolymorphicVariant
<
GlyphFinderInterface
Utf8GlyphFinder
Utf16GlyphFinder
Utf32GlyphFinder
GlyphIdGlyphFinder
>
LookupGlyphVariant
;
class
LookupGlyph
:
public
LookupGlyphVariant
{
public
:
LookupGlyph
(
SkPaint
:
:
TextEncoding
encoding
SkGlyphCache
*
cache
)
:
LookupGlyphVariant
(
[
&
]
(
LookupGlyphVariant
:
:
Variants
*
to_init
)
{
switch
(
encoding
)
{
case
SkPaint
:
:
kUTF8_TextEncoding
:
to_init
-
>
initialize
<
Utf8GlyphFinder
>
(
cache
)
;
break
;
case
SkPaint
:
:
kUTF16_TextEncoding
:
to_init
-
>
initialize
<
Utf16GlyphFinder
>
(
cache
)
;
break
;
case
SkPaint
:
:
kUTF32_TextEncoding
:
to_init
-
>
initialize
<
Utf32GlyphFinder
>
(
cache
)
;
break
;
case
SkPaint
:
:
kGlyphID_TextEncoding
:
to_init
-
>
initialize
<
GlyphIdGlyphFinder
>
(
cache
)
;
break
;
}
}
)
{
}
}
;
class
PositionReaderInterface
{
public
:
virtual
~
PositionReaderInterface
(
)
{
}
virtual
SkPoint
nextPoint
(
)
=
0
;
virtual
int
forceUseForBug
(
)
=
0
;
}
;
class
HorizontalPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
HorizontalPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkScalar
x
=
*
fPositions
+
+
;
return
{
x
0
}
;
}
int
forceUseForBug
(
)
override
{
return
1
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
class
ArbitraryPositions
final
:
public
PositionReaderInterface
{
public
:
explicit
ArbitraryPositions
(
const
SkScalar
*
positions
)
:
fPositions
(
positions
)
{
}
SkPoint
nextPoint
(
)
override
{
SkPoint
to_return
{
fPositions
[
0
]
fPositions
[
1
]
}
;
fPositions
+
=
2
;
return
to_return
;
}
int
forceUseForBug
(
)
override
{
return
2
;
}
private
:
const
SkScalar
*
fPositions
;
}
;
typedef
PolymorphicVariant
<
PositionReaderInterface
HorizontalPositions
ArbitraryPositions
>
PositionReader
;
class
MapperInterface
{
public
:
virtual
~
MapperInterface
(
)
{
}
virtual
SkPoint
map
(
SkPoint
position
)
const
=
0
;
}
;
class
TranslationMapper
final
:
public
MapperInterface
{
public
:
TranslationMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
position
+
fTranslate
;
}
private
:
const
SkPoint
fTranslate
;
}
;
class
XScaleMapper
final
:
public
MapperInterface
{
public
:
XScaleMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fTranslate
(
matrix
.
mapXY
(
origin
.
fX
origin
.
fY
)
)
fXScale
(
matrix
.
getScaleX
(
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
return
{
fXScale
*
position
.
fX
+
fTranslate
.
fX
fTranslate
.
fY
}
;
}
private
:
const
SkPoint
fTranslate
;
const
SkScalar
fXScale
;
}
;
class
GeneralMapper
final
:
public
MapperInterface
{
public
:
GeneralMapper
(
const
SkMatrix
&
matrix
const
SkPoint
origin
)
:
fOrigin
(
origin
)
fMatrix
(
matrix
)
fMapProc
(
matrix
.
getMapXYProc
(
)
)
{
}
SkPoint
map
(
SkPoint
position
)
const
override
{
SkPoint
result
;
fMapProc
(
fMatrix
position
.
fX
+
fOrigin
.
fX
position
.
fY
+
fOrigin
.
fY
&
result
)
;
return
result
;
}
private
:
const
SkPoint
fOrigin
;
const
SkMatrix
&
fMatrix
;
const
SkMatrix
:
:
MapXYProc
fMapProc
;
}
;
typedef
PolymorphicVariant
<
MapperInterface
TranslationMapper
XScaleMapper
GeneralMapper
>
Mapper
;
static
SkPoint
TextAlignmentAdjustment
(
SkPaint
:
:
Align
textAlignment
const
SkGlyph
&
glyph
)
{
switch
(
textAlignment
)
{
case
SkPaint
:
:
kLeft_Align
:
return
{
0
.
0f
0
.
0f
}
;
case
SkPaint
:
:
kCenter_Align
:
return
{
SkFixedToScalar
(
glyph
.
fAdvanceX
>
>
1
)
SkFixedToScalar
(
glyph
.
fAdvanceY
>
>
1
)
}
;
case
SkPaint
:
:
kRight_Align
:
return
{
SkFixedToScalar
(
glyph
.
fAdvanceX
)
SkFixedToScalar
(
glyph
.
fAdvanceY
)
}
;
}
SkFAIL
(
"
Should
never
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
#
define
kSubpixelRounding
(
SkFixedToScalar
(
SkGlyph
:
:
kSubpixelRound
)
)
static
SkPoint
SubpixelPositionRounding
(
SkAxisAlignment
axisAlignment
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
SkFixedToScalar
(
SkGlyph
:
:
kSubpixelRound
)
SK_ScalarHalf
}
;
case
kY_SkAxisAlignment
:
return
{
SK_ScalarHalf
kSubpixelRounding
}
;
case
kNone_SkAxisAlignment
:
return
{
kSubpixelRounding
kSubpixelRounding
}
;
}
SkFAIL
(
"
Should
not
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
static
SkIPoint
SubpixelAlignment
(
SkAxisAlignment
axisAlignment
SkPoint
position
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
return
{
SkScalarToFixed
(
position
.
fX
+
kSubpixelRounding
)
0
}
;
case
kY_SkAxisAlignment
:
return
{
0
SkScalarToFixed
(
position
.
fY
+
kSubpixelRounding
)
}
;
case
kNone_SkAxisAlignment
:
return
{
SkScalarToFixed
(
position
.
fX
+
kSubpixelRounding
)
SkScalarToFixed
(
position
.
fY
+
kSubpixelRounding
)
}
;
}
SkFAIL
(
"
Should
not
get
here
.
"
)
;
return
{
0
0
}
;
}
#
undef
kSubpixelRounding
template
<
typename
ProcessOneGlyph
>
class
GlyphFindAndPlaceInterface
:
SkNoncopyable
{
public
:
virtual
~
GlyphFindAndPlaceInterface
(
)
{
}
;
virtual
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
{
SkFAIL
(
"
Should
never
get
here
.
"
)
;
return
{
0
.
0f
0
.
0f
}
;
}
;
}
;
template
<
typename
ProcessOneGlyph
SkPaint
:
:
Align
kTextAlignment
SkAxisAlignment
kAxisAlignment
>
class
GlyphFindAndPlaceSubpixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
GlyphFindAndPlaceSubpixel
(
LookupGlyph
&
glyphFinder
)
:
fGlyphFinder
(
glyphFinder
)
{
FixGCC49Arm64Bug
(
1
)
;
}
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkPoint
finalPosition
=
position
;
if
(
kTextAlignment
!
=
SkPaint
:
:
kLeft_Align
)
{
const
char
*
tempText
=
*
text
;
const
SkGlyph
&
metricGlyph
=
fGlyphFinder
-
>
lookupGlyph
(
&
tempText
)
;
if
(
metricGlyph
.
fWidth
<
=
0
)
{
*
text
=
tempText
;
return
finalPosition
+
SkPoint
{
SkFixedToScalar
(
metricGlyph
.
fAdvanceX
)
SkFixedToScalar
(
metricGlyph
.
fAdvanceY
)
}
;
}
finalPosition
-
=
TextAlignmentAdjustment
(
kTextAlignment
metricGlyph
)
;
}
SkIPoint
lookupPosition
=
SubpixelAlignment
(
kAxisAlignment
finalPosition
)
;
const
SkGlyph
&
renderGlyph
=
fGlyphFinder
-
>
lookupGlyphXY
(
text
lookupPosition
.
fX
lookupPosition
.
fY
)
;
if
(
renderGlyph
.
fWidth
>
0
)
{
processOneGlyph
(
renderGlyph
finalPosition
SubpixelPositionRounding
(
kAxisAlignment
)
)
;
}
return
finalPosition
+
SkPoint
{
SkFixedToScalar
(
renderGlyph
.
fAdvanceX
)
SkFixedToScalar
(
renderGlyph
.
fAdvanceY
)
}
;
}
private
:
LookupGlyph
&
fGlyphFinder
;
}
;
enum
SelectKerning
{
kNoKerning
=
false
kUseKerning
=
true
}
;
template
<
typename
ProcessOneGlyph
SkPaint
:
:
Align
kTextAlignment
SelectKerning
kUseKerning
>
class
GlyphFindAndPlaceFullPixel
final
:
public
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
{
public
:
GlyphFindAndPlaceFullPixel
(
LookupGlyph
&
glyphFinder
)
:
fGlyphFinder
(
glyphFinder
)
{
FixGCC49Arm64Bug
(
2
)
;
static_assert
(
!
kUseKerning
|
|
SkPaint
:
:
kLeft_Align
=
=
kTextAlignment
"
Kerning
can
only
be
used
with
left
aligned
text
.
"
)
;
}
SkPoint
findAndPositionGlyph
(
const
char
*
*
text
SkPoint
position
ProcessOneGlyph
&
&
processOneGlyph
)
override
{
SkPoint
finalPosition
=
position
;
const
SkGlyph
&
glyph
=
fGlyphFinder
-
>
lookupGlyph
(
text
)
;
if
(
kUseKerning
)
{
finalPosition
+
=
{
SkFixedToScalar
(
fAutoKern
.
adjust
(
glyph
)
)
0
.
0f
}
;
}
if
(
glyph
.
fWidth
>
0
)
{
finalPosition
-
=
TextAlignmentAdjustment
(
kTextAlignment
glyph
)
;
processOneGlyph
(
glyph
finalPosition
{
SK_ScalarHalf
SK_ScalarHalf
}
)
;
}
return
finalPosition
+
SkPoint
{
SkFixedToScalar
(
glyph
.
fAdvanceX
)
SkFixedToScalar
(
glyph
.
fAdvanceY
)
}
;
}
private
:
LookupGlyph
&
fGlyphFinder
;
SkAutoKern
fAutoKern
;
}
;
template
<
typename
ProcessOneGlyph
>
using
GlyphFindAndPlace
=
PolymorphicVariant
<
GlyphFindAndPlaceInterface
<
ProcessOneGlyph
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kNone_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kX_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kY_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
kNone_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
kX_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
kY_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
kNone_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
kX_SkAxisAlignment
>
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
kY_SkAxisAlignment
>
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kNoKerning
>
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
kNoKerning
>
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
kNoKerning
>
>
;
template
<
typename
ProcessOneGlyph
SkPaint
:
:
Align
kTextAlignment
>
static
void
InitSubpixel
(
typename
GlyphFindAndPlace
<
ProcessOneGlyph
>
:
:
Variants
*
to_init
SkAxisAlignment
axisAlignment
LookupGlyph
&
glyphFinder
)
{
switch
(
axisAlignment
)
{
case
kX_SkAxisAlignment
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kTextAlignment
kX_SkAxisAlignment
>
>
(
glyphFinder
)
;
break
;
case
kNone_SkAxisAlignment
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kTextAlignment
kNone_SkAxisAlignment
>
>
(
glyphFinder
)
;
break
;
case
kY_SkAxisAlignment
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
kTextAlignment
kY_SkAxisAlignment
>
>
(
glyphFinder
)
;
break
;
}
}
static
SkPoint
MeasureText
(
LookupGlyph
&
glyphFinder
const
char
text
[
]
size_t
byteLength
)
{
SkFixed
x
=
0
y
=
0
;
const
char
*
stop
=
text
+
byteLength
;
SkAutoKern
autokern
;
while
(
text
<
stop
)
{
const
SkGlyph
&
glyph
=
glyphFinder
-
>
lookupGlyph
(
&
text
)
;
x
+
=
autokern
.
adjust
(
glyph
)
+
glyph
.
fAdvanceX
;
y
+
=
glyph
.
fAdvanceY
;
}
SkASSERT
(
text
=
=
stop
)
;
return
{
SkFixedToScalar
(
x
)
SkFixedToScalar
(
y
)
}
;
}
}
;
template
<
typename
ProcessOneGlyph
>
inline
void
SkFindAndPlaceGlyph
:
:
ProcessPosText
(
SkPaint
:
:
TextEncoding
textEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
const
SkScalar
pos
[
]
int
scalarsPerPosition
SkPaint
:
:
Align
textAlignment
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
{
SkAxisAlignment
axisAlignment
=
SkComputeAxisAlignmentForHText
(
matrix
)
;
uint32_t
mtype
=
matrix
.
getType
(
)
;
LookupGlyph
glyphFinder
(
textEncoding
cache
)
;
if
(
scalarsPerPosition
=
=
1
&
&
textAlignment
=
=
SkPaint
:
:
kLeft_Align
&
&
axisAlignment
=
=
kX_SkAxisAlignment
&
&
cache
-
>
isSubpixel
(
)
&
&
mtype
<
=
SkMatrix
:
:
kTranslate_Mask
)
{
typedef
GlyphFindAndPlaceSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kX_SkAxisAlignment
>
Positioner
;
HorizontalPositions
positions
{
pos
}
;
TranslationMapper
mapper
{
matrix
offset
}
;
Positioner
positioner
(
glyphFinder
)
;
const
char
*
cursor
=
text
;
const
char
*
stop
=
text
+
byteLength
;
while
(
cursor
<
stop
)
{
SkPoint
mappedPoint
=
mapper
.
TranslationMapper
:
:
map
(
positions
.
HorizontalPositions
:
:
nextPoint
(
)
)
;
positioner
.
Positioner
:
:
findAndPositionGlyph
(
&
cursor
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
return
;
}
PositionReader
positionReader
{
[
&
]
(
PositionReader
:
:
Variants
*
to_init
)
{
if
(
2
=
=
scalarsPerPosition
)
{
to_init
-
>
initialize
<
ArbitraryPositions
>
(
pos
)
;
}
else
{
to_init
-
>
initialize
<
HorizontalPositions
>
(
pos
)
;
}
positionReader
-
>
forceUseForBug
(
)
;
}
}
;
Mapper
mapper
{
[
&
]
(
Mapper
:
:
Variants
*
to_init
)
{
if
(
mtype
&
(
SkMatrix
:
:
kAffine_Mask
|
SkMatrix
:
:
kPerspective_Mask
)
|
|
scalarsPerPosition
=
=
2
)
{
to_init
-
>
initialize
<
GeneralMapper
>
(
matrix
offset
)
;
}
else
if
(
mtype
&
SkMatrix
:
:
kScale_Mask
)
{
to_init
-
>
initialize
<
XScaleMapper
>
(
matrix
offset
)
;
}
else
{
to_init
-
>
initialize
<
TranslationMapper
>
(
matrix
offset
)
;
}
}
}
;
GlyphFindAndPlace
<
ProcessOneGlyph
>
findAndPosition
{
[
&
]
(
typename
GlyphFindAndPlace
<
ProcessOneGlyph
>
:
:
Variants
*
to_init
)
{
if
(
cache
-
>
isSubpixel
(
)
)
{
switch
(
textAlignment
)
{
case
SkPaint
:
:
kLeft_Align
:
InitSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
>
(
to_init
axisAlignment
glyphFinder
)
;
break
;
case
SkPaint
:
:
kCenter_Align
:
InitSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
>
(
to_init
axisAlignment
glyphFinder
)
;
break
;
case
SkPaint
:
:
kRight_Align
:
InitSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
>
(
to_init
axisAlignment
glyphFinder
)
;
break
;
}
}
else
{
switch
(
textAlignment
)
{
case
SkPaint
:
:
kLeft_Align
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kNoKerning
>
>
(
glyphFinder
)
;
break
;
case
SkPaint
:
:
kCenter_Align
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kCenter_Align
kNoKerning
>
>
(
glyphFinder
)
;
break
;
case
SkPaint
:
:
kRight_Align
:
to_init
-
>
template
initialize
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kRight_Align
kNoKerning
>
>
(
glyphFinder
)
;
break
;
}
}
}
}
;
const
char
*
stop
=
text
+
byteLength
;
while
(
text
<
stop
)
{
SkPoint
mappedPoint
=
mapper
-
>
map
(
positionReader
-
>
nextPoint
(
)
)
;
findAndPosition
-
>
findAndPositionGlyph
(
&
text
mappedPoint
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
}
template
<
typename
ProcessOneGlyph
>
inline
void
SkFindAndPlaceGlyph
:
:
ProcessText
(
SkPaint
:
:
TextEncoding
textEncoding
const
char
text
[
]
size_t
byteLength
SkPoint
offset
const
SkMatrix
&
matrix
SkPaint
:
:
Align
textAlignment
SkGlyphCache
*
cache
ProcessOneGlyph
&
&
processOneGlyph
)
{
matrix
.
mapPoints
(
&
offset
1
)
;
LookupGlyph
glyphFinder
(
textEncoding
cache
)
;
if
(
textAlignment
!
=
SkPaint
:
:
kLeft_Align
)
{
SkVector
stop
=
MeasureText
(
glyphFinder
text
byteLength
)
;
if
(
textAlignment
=
=
SkPaint
:
:
kCenter_Align
)
{
stop
*
=
SK_ScalarHalf
;
}
offset
-
=
stop
;
}
GlyphFindAndPlace
<
ProcessOneGlyph
>
findAndPosition
{
[
&
]
(
typename
GlyphFindAndPlace
<
ProcessOneGlyph
>
:
:
Variants
*
to_init
)
{
if
(
cache
-
>
isSubpixel
(
)
)
{
SkAxisAlignment
axisAlignment
=
SkComputeAxisAlignmentForHText
(
matrix
)
;
InitSubpixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
>
(
to_init
axisAlignment
glyphFinder
)
;
}
else
{
to_init
-
>
template
initialize
<
GlyphFindAndPlaceFullPixel
<
ProcessOneGlyph
SkPaint
:
:
kLeft_Align
kUseKerning
>
>
(
glyphFinder
)
;
}
}
}
;
const
char
*
stop
=
text
+
byteLength
;
SkPoint
current
=
offset
;
while
(
text
<
stop
)
{
current
=
findAndPosition
-
>
findAndPositionGlyph
(
&
text
current
std
:
:
forward
<
ProcessOneGlyph
>
(
processOneGlyph
)
)
;
}
}
#
endif
