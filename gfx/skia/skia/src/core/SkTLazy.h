#
ifndef
SkTLazy_DEFINED
#
define
SkTLazy_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
template
<
typename
T
>
class
SkTLazy
{
public
:
SkTLazy
(
)
=
default
;
explicit
SkTLazy
(
const
T
*
src
)
:
fPtr
(
src
?
new
(
&
fStorage
)
T
(
*
src
)
:
nullptr
)
{
}
SkTLazy
(
const
SkTLazy
&
that
)
:
fPtr
(
that
.
fPtr
?
new
(
&
fStorage
)
T
(
*
that
.
fPtr
)
:
nullptr
)
{
}
SkTLazy
(
SkTLazy
&
&
that
)
:
fPtr
(
that
.
fPtr
?
new
(
&
fStorage
)
T
(
std
:
:
move
(
*
that
.
fPtr
)
)
:
nullptr
)
{
}
~
SkTLazy
(
)
{
this
-
>
reset
(
)
;
}
SkTLazy
&
operator
=
(
const
SkTLazy
&
that
)
{
if
(
that
.
isValid
(
)
)
{
this
-
>
set
(
*
that
)
;
}
else
{
this
-
>
reset
(
)
;
}
return
*
this
;
}
SkTLazy
&
operator
=
(
SkTLazy
&
&
that
)
{
if
(
that
.
isValid
(
)
)
{
this
-
>
set
(
std
:
:
move
(
*
that
)
)
;
}
else
{
this
-
>
reset
(
)
;
}
return
*
this
;
}
template
<
typename
.
.
.
Args
>
T
*
init
(
Args
&
&
.
.
.
args
)
{
this
-
>
reset
(
)
;
fPtr
=
new
(
&
fStorage
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
fPtr
;
}
T
*
set
(
const
T
&
src
)
{
if
(
this
-
>
isValid
(
)
)
{
*
fPtr
=
src
;
}
else
{
fPtr
=
new
(
&
fStorage
)
T
(
src
)
;
}
return
fPtr
;
}
T
*
set
(
T
&
&
src
)
{
if
(
this
-
>
isValid
(
)
)
{
*
fPtr
=
std
:
:
move
(
src
)
;
}
else
{
fPtr
=
new
(
&
fStorage
)
T
(
std
:
:
move
(
src
)
)
;
}
return
fPtr
;
}
void
reset
(
)
{
if
(
this
-
>
isValid
(
)
)
{
fPtr
-
>
~
T
(
)
;
fPtr
=
nullptr
;
}
}
bool
isValid
(
)
const
{
return
SkToBool
(
fPtr
)
;
}
T
*
get
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
return
fPtr
;
}
T
*
operator
-
>
(
)
const
{
return
this
-
>
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
this
-
>
get
(
)
;
}
T
*
getMaybeNull
(
)
const
{
return
fPtr
;
}
private
:
typename
std
:
:
aligned_storage
<
sizeof
(
T
)
alignof
(
T
)
>
:
:
type
fStorage
;
T
*
fPtr
{
nullptr
}
;
}
;
template
<
typename
T
>
class
SkTCopyOnFirstWrite
{
public
:
explicit
SkTCopyOnFirstWrite
(
const
T
&
initial
)
:
fObj
(
&
initial
)
{
}
explicit
SkTCopyOnFirstWrite
(
const
T
*
initial
)
:
fObj
(
initial
)
{
}
SkTCopyOnFirstWrite
(
)
:
fObj
(
nullptr
)
{
}
SkTCopyOnFirstWrite
(
const
SkTCopyOnFirstWrite
&
that
)
{
*
this
=
that
;
}
SkTCopyOnFirstWrite
(
SkTCopyOnFirstWrite
&
&
that
)
{
*
this
=
std
:
:
move
(
that
)
;
}
SkTCopyOnFirstWrite
&
operator
=
(
const
SkTCopyOnFirstWrite
&
that
)
{
fLazy
=
that
.
fLazy
;
fObj
=
fLazy
.
isValid
(
)
?
fLazy
.
get
(
)
:
that
.
fObj
;
return
*
this
;
}
SkTCopyOnFirstWrite
&
operator
=
(
SkTCopyOnFirstWrite
&
&
that
)
{
fLazy
=
std
:
:
move
(
that
.
fLazy
)
;
fObj
=
fLazy
.
isValid
(
)
?
fLazy
.
get
(
)
:
that
.
fObj
;
return
*
this
;
}
void
init
(
const
T
&
initial
)
{
SkASSERT
(
nullptr
=
=
fObj
)
;
SkASSERT
(
!
fLazy
.
isValid
(
)
)
;
fObj
=
&
initial
;
}
T
*
writable
(
)
{
SkASSERT
(
fObj
)
;
if
(
!
fLazy
.
isValid
(
)
)
{
fLazy
.
set
(
*
fObj
)
;
fObj
=
fLazy
.
get
(
)
;
}
return
const_cast
<
T
*
>
(
fObj
)
;
}
const
T
*
get
(
)
const
{
return
fObj
;
}
const
T
*
operator
-
>
(
)
const
{
return
fObj
;
}
operator
const
T
*
(
)
const
{
return
fObj
;
}
const
T
&
operator
*
(
)
const
{
return
*
fObj
;
}
private
:
const
T
*
fObj
;
SkTLazy
<
T
>
fLazy
;
}
;
#
endif
