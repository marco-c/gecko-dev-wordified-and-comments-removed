#
ifndef
Sk4px_DEFINED
#
define
Sk4px_DEFINED
#
include
"
SkNx
.
h
"
#
include
"
SkColor
.
h
"
#
include
"
SkColorData
.
h
"
namespace
{
class
Sk4px
:
public
Sk16b
{
public
:
Sk4px
(
const
Sk16b
&
v
)
:
INHERITED
(
v
)
{
}
static
Sk4px
DupPMColor
(
SkPMColor
c
)
{
Sk4u
splat
(
c
)
;
Sk4px
v
;
memcpy
(
&
v
&
splat
16
)
;
return
v
;
}
Sk4px
alphas
(
)
const
;
Sk4px
inv
(
)
const
{
return
Sk16b
(
255
)
-
*
this
;
}
static
Sk4px
Load4
(
const
SkPMColor
px
[
4
]
)
{
Sk4px
v
;
memcpy
(
&
v
px
16
)
;
return
v
;
}
static
Sk4px
Load2
(
const
SkPMColor
px
[
2
]
)
{
Sk4px
v
;
memcpy
(
&
v
px
8
)
;
return
v
;
}
static
Sk4px
Load1
(
const
SkPMColor
px
[
1
]
)
{
Sk4px
v
;
memcpy
(
&
v
px
4
)
;
return
v
;
}
static
Sk4px
Load4Alphas
(
const
SkAlpha
[
4
]
)
;
static
Sk4px
Load2Alphas
(
const
SkAlpha
[
2
]
)
;
void
store4
(
SkPMColor
px
[
4
]
)
const
{
memcpy
(
px
this
16
)
;
}
void
store2
(
SkPMColor
px
[
2
]
)
const
{
memcpy
(
px
this
8
)
;
}
void
store1
(
SkPMColor
px
[
1
]
)
const
{
memcpy
(
px
this
4
)
;
}
class
Wide
:
public
Sk16h
{
public
:
Wide
(
const
Sk16h
&
v
)
:
Sk16h
(
v
)
{
}
Sk4px
addNarrowHi
(
const
Sk16h
&
)
const
;
Sk4px
div255
(
)
const
;
Wide
operator
*
(
const
Wide
&
o
)
const
{
return
INHERITED
:
:
operator
*
(
o
)
;
}
Wide
operator
+
(
const
Wide
&
o
)
const
{
return
INHERITED
:
:
operator
+
(
o
)
;
}
Wide
operator
-
(
const
Wide
&
o
)
const
{
return
INHERITED
:
:
operator
-
(
o
)
;
}
Wide
operator
>
>
(
int
bits
)
const
{
return
INHERITED
:
:
operator
>
>
(
bits
)
;
}
Wide
operator
<
<
(
int
bits
)
const
{
return
INHERITED
:
:
operator
<
<
(
bits
)
;
}
private
:
typedef
Sk16h
INHERITED
;
}
;
Wide
widen
(
)
const
;
Wide
mulWiden
(
const
Sk16b
&
)
const
;
Wide
operator
*
(
const
Sk4px
&
o
)
const
{
return
this
-
>
mulWiden
(
o
)
;
}
Sk4px
operator
+
(
const
Sk4px
&
o
)
const
{
return
INHERITED
:
:
operator
+
(
o
)
;
}
Sk4px
operator
-
(
const
Sk4px
&
o
)
const
{
return
INHERITED
:
:
operator
-
(
o
)
;
}
Sk4px
operator
<
(
const
Sk4px
&
o
)
const
{
return
INHERITED
:
:
operator
<
(
o
)
;
}
Sk4px
thenElse
(
const
Sk4px
&
t
const
Sk4px
&
e
)
const
{
return
INHERITED
:
:
thenElse
(
t
e
)
;
}
Sk4px
approxMulDiv255
(
const
Sk16b
&
o
)
const
{
return
this
-
>
widen
(
)
.
addNarrowHi
(
*
this
*
o
)
;
}
template
<
typename
Fn
>
static
void
MapSrc
(
int
n
SkPMColor
*
dst
const
SkPMColor
*
src
const
Fn
&
fn
)
{
SkASSERT
(
dst
)
;
SkASSERT
(
src
)
;
while
(
n
>
0
)
{
if
(
n
>
=
8
)
{
Sk4px
dst0
=
fn
(
Load4
(
src
+
0
)
)
dst4
=
fn
(
Load4
(
src
+
4
)
)
;
dst0
.
store4
(
dst
+
0
)
;
dst4
.
store4
(
dst
+
4
)
;
dst
+
=
8
;
src
+
=
8
;
n
-
=
8
;
continue
;
}
SkASSERT
(
n
<
=
7
)
;
if
(
n
>
=
4
)
{
fn
(
Load4
(
src
)
)
.
store4
(
dst
)
;
dst
+
=
4
;
src
+
=
4
;
n
-
=
4
;
}
if
(
n
>
=
2
)
{
fn
(
Load2
(
src
)
)
.
store2
(
dst
)
;
dst
+
=
2
;
src
+
=
2
;
n
-
=
2
;
}
if
(
n
>
=
1
)
{
fn
(
Load1
(
src
)
)
.
store1
(
dst
)
;
}
break
;
}
}
template
<
typename
Fn
>
static
void
MapDstSrc
(
int
n
SkPMColor
*
dst
const
SkPMColor
*
src
const
Fn
&
fn
)
{
SkASSERT
(
dst
)
;
SkASSERT
(
src
)
;
while
(
n
>
0
)
{
if
(
n
>
=
8
)
{
Sk4px
dst0
=
fn
(
Load4
(
dst
+
0
)
Load4
(
src
+
0
)
)
dst4
=
fn
(
Load4
(
dst
+
4
)
Load4
(
src
+
4
)
)
;
dst0
.
store4
(
dst
+
0
)
;
dst4
.
store4
(
dst
+
4
)
;
dst
+
=
8
;
src
+
=
8
;
n
-
=
8
;
continue
;
}
SkASSERT
(
n
<
=
7
)
;
if
(
n
>
=
4
)
{
fn
(
Load4
(
dst
)
Load4
(
src
)
)
.
store4
(
dst
)
;
dst
+
=
4
;
src
+
=
4
;
n
-
=
4
;
}
if
(
n
>
=
2
)
{
fn
(
Load2
(
dst
)
Load2
(
src
)
)
.
store2
(
dst
)
;
dst
+
=
2
;
src
+
=
2
;
n
-
=
2
;
}
if
(
n
>
=
1
)
{
fn
(
Load1
(
dst
)
Load1
(
src
)
)
.
store1
(
dst
)
;
}
break
;
}
}
template
<
typename
Fn
>
static
void
MapDstAlpha
(
int
n
SkPMColor
*
dst
const
SkAlpha
*
a
const
Fn
&
fn
)
{
SkASSERT
(
dst
)
;
SkASSERT
(
a
)
;
while
(
n
>
0
)
{
if
(
n
>
=
8
)
{
Sk4px
dst0
=
fn
(
Load4
(
dst
+
0
)
Load4Alphas
(
a
+
0
)
)
dst4
=
fn
(
Load4
(
dst
+
4
)
Load4Alphas
(
a
+
4
)
)
;
dst0
.
store4
(
dst
+
0
)
;
dst4
.
store4
(
dst
+
4
)
;
dst
+
=
8
;
a
+
=
8
;
n
-
=
8
;
continue
;
}
SkASSERT
(
n
<
=
7
)
;
if
(
n
>
=
4
)
{
fn
(
Load4
(
dst
)
Load4Alphas
(
a
)
)
.
store4
(
dst
)
;
dst
+
=
4
;
a
+
=
4
;
n
-
=
4
;
}
if
(
n
>
=
2
)
{
fn
(
Load2
(
dst
)
Load2Alphas
(
a
)
)
.
store2
(
dst
)
;
dst
+
=
2
;
a
+
=
2
;
n
-
=
2
;
}
if
(
n
>
=
1
)
{
fn
(
Load1
(
dst
)
Sk16b
(
*
a
)
)
.
store1
(
dst
)
;
}
break
;
}
}
template
<
typename
Fn
>
static
void
MapDstSrcAlpha
(
int
n
SkPMColor
*
dst
const
SkPMColor
*
src
const
SkAlpha
*
a
const
Fn
&
fn
)
{
SkASSERT
(
dst
)
;
SkASSERT
(
src
)
;
SkASSERT
(
a
)
;
while
(
n
>
0
)
{
if
(
n
>
=
8
)
{
Sk4px
dst0
=
fn
(
Load4
(
dst
+
0
)
Load4
(
src
+
0
)
Load4Alphas
(
a
+
0
)
)
dst4
=
fn
(
Load4
(
dst
+
4
)
Load4
(
src
+
4
)
Load4Alphas
(
a
+
4
)
)
;
dst0
.
store4
(
dst
+
0
)
;
dst4
.
store4
(
dst
+
4
)
;
dst
+
=
8
;
src
+
=
8
;
a
+
=
8
;
n
-
=
8
;
continue
;
}
SkASSERT
(
n
<
=
7
)
;
if
(
n
>
=
4
)
{
fn
(
Load4
(
dst
)
Load4
(
src
)
Load4Alphas
(
a
)
)
.
store4
(
dst
)
;
dst
+
=
4
;
src
+
=
4
;
a
+
=
4
;
n
-
=
4
;
}
if
(
n
>
=
2
)
{
fn
(
Load2
(
dst
)
Load2
(
src
)
Load2Alphas
(
a
)
)
.
store2
(
dst
)
;
dst
+
=
2
;
src
+
=
2
;
a
+
=
2
;
n
-
=
2
;
}
if
(
n
>
=
1
)
{
fn
(
Load1
(
dst
)
Load1
(
src
)
Sk16b
(
*
a
)
)
.
store1
(
dst
)
;
}
break
;
}
}
private
:
Sk4px
(
)
=
default
;
typedef
Sk16b
INHERITED
;
}
;
}
#
ifdef
SKNX_NO_SIMD
#
include
"
.
.
/
opts
/
Sk4px_none
.
h
"
#
else
#
if
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE2
#
include
"
.
.
/
opts
/
Sk4px_SSE2
.
h
"
#
elif
defined
(
SK_ARM_HAS_NEON
)
#
include
"
.
.
/
opts
/
Sk4px_NEON
.
h
"
#
else
#
include
"
.
.
/
opts
/
Sk4px_none
.
h
"
#
endif
#
endif
#
endif
