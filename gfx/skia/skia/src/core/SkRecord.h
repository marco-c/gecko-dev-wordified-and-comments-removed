#
ifndef
SkRecord_DEFINED
#
define
SkRecord_DEFINED
#
include
"
SkRecords
.
h
"
#
include
"
SkTLogic
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkVarAlloc
.
h
"
class
SkRecord
:
public
SkRefCnt
{
public
:
SkRecord
(
)
;
~
SkRecord
(
)
;
int
count
(
)
const
{
return
fCount
;
}
template
<
typename
F
>
auto
visit
(
int
i
F
&
&
f
)
const
-
>
decltype
(
f
(
SkRecords
:
:
NoOp
(
)
)
)
{
return
fRecords
[
i
]
.
visit
(
f
)
;
}
template
<
typename
F
>
auto
mutate
(
int
i
F
&
&
f
)
-
>
decltype
(
f
(
(
SkRecords
:
:
NoOp
*
)
nullptr
)
)
{
return
fRecords
[
i
]
.
mutate
(
f
)
;
}
template
<
typename
T
>
T
*
alloc
(
size_t
count
=
1
)
{
return
(
T
*
)
fAlloc
.
alloc
(
sizeof
(
T
)
*
count
)
;
}
template
<
typename
T
>
T
*
append
(
)
{
if
(
fCount
=
=
fReserved
)
{
this
-
>
grow
(
)
;
}
return
fRecords
[
fCount
+
+
]
.
set
(
this
-
>
allocCommand
<
T
>
(
)
)
;
}
template
<
typename
T
>
T
*
replace
(
int
i
)
{
SkASSERT
(
i
<
this
-
>
count
(
)
)
;
Destroyer
destroyer
;
this
-
>
mutate
(
i
destroyer
)
;
return
fRecords
[
i
]
.
set
(
this
-
>
allocCommand
<
T
>
(
)
)
;
}
template
<
typename
T
typename
Existing
>
T
*
replace
(
int
i
const
SkRecords
:
:
Adopted
<
Existing
>
&
proofOfAdoption
)
{
SkASSERT
(
i
<
this
-
>
count
(
)
)
;
SkASSERT
(
Existing
:
:
kType
=
=
fRecords
[
i
]
.
type
(
)
)
;
SkASSERT
(
proofOfAdoption
=
=
fRecords
[
i
]
.
ptr
(
)
)
;
return
fRecords
[
i
]
.
set
(
this
-
>
allocCommand
<
T
>
(
)
)
;
}
size_t
bytesUsed
(
)
const
;
void
defrag
(
)
;
private
:
struct
Destroyer
{
template
<
typename
T
>
void
operator
(
)
(
T
*
record
)
{
record
-
>
~
T
(
)
;
}
}
;
template
<
typename
T
>
SK_WHEN
(
std
:
:
is_empty
<
T
>
:
:
value
T
*
)
allocCommand
(
)
{
static
T
singleton
=
{
}
;
return
&
singleton
;
}
template
<
typename
T
>
SK_WHEN
(
!
std
:
:
is_empty
<
T
>
:
:
value
T
*
)
allocCommand
(
)
{
return
this
-
>
alloc
<
T
>
(
)
;
}
void
grow
(
)
;
struct
Record
{
uint64_t
fTypeAndPtr
;
static
const
int
kTypeShift
=
sizeof
(
void
*
)
=
=
4
?
32
:
48
;
template
<
typename
T
>
T
*
set
(
T
*
ptr
)
{
fTypeAndPtr
=
(
(
uint64_t
)
T
:
:
kType
)
<
<
kTypeShift
|
(
uintptr_t
)
ptr
;
SkASSERT
(
this
-
>
ptr
(
)
=
=
ptr
&
&
this
-
>
type
(
)
=
=
T
:
:
kType
)
;
return
ptr
;
}
SkRecords
:
:
Type
type
(
)
const
{
return
(
SkRecords
:
:
Type
)
(
fTypeAndPtr
>
>
kTypeShift
)
;
}
void
*
ptr
(
)
const
{
return
(
void
*
)
(
fTypeAndPtr
&
(
(
1ull
<
<
kTypeShift
)
-
1
)
)
;
}
template
<
typename
F
>
auto
visit
(
F
&
&
f
)
const
-
>
decltype
(
f
(
SkRecords
:
:
NoOp
(
)
)
)
{
#
define
CASE
(
T
)
case
SkRecords
:
:
T
#
#
_Type
:
return
f
(
*
(
const
SkRecords
:
:
T
*
)
this
-
>
ptr
(
)
)
;
switch
(
this
-
>
type
(
)
)
{
SK_RECORD_TYPES
(
CASE
)
}
#
undef
CASE
SkDEBUGFAIL
(
"
Unreachable
"
)
;
return
f
(
SkRecords
:
:
NoOp
(
)
)
;
}
template
<
typename
F
>
auto
mutate
(
F
&
&
f
)
-
>
decltype
(
f
(
(
SkRecords
:
:
NoOp
*
)
nullptr
)
)
{
#
define
CASE
(
T
)
case
SkRecords
:
:
T
#
#
_Type
:
return
f
(
(
SkRecords
:
:
T
*
)
this
-
>
ptr
(
)
)
;
switch
(
this
-
>
type
(
)
)
{
SK_RECORD_TYPES
(
CASE
)
}
#
undef
CASE
SkDEBUGFAIL
(
"
Unreachable
"
)
;
return
f
(
(
SkRecords
:
:
NoOp
*
)
nullptr
)
;
}
}
;
int
fCount
fReserved
;
SkAutoTMalloc
<
Record
>
fRecords
;
SkVarAlloc
fAlloc
;
}
;
#
endif
