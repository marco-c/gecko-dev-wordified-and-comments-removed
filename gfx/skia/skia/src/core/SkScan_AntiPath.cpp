#
include
"
SkScanPriv
.
h
"
#
include
"
SkAntiRun
.
h
"
#
include
"
SkBlitter
.
h
"
#
include
"
SkCoverageDelta
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkPathPriv
.
h
"
#
include
"
SkRegion
.
h
"
#
include
"
SkTo
.
h
"
#
define
SHIFT
SK_SUPERSAMPLE_SHIFT
#
define
SCALE
(
1
<
<
SHIFT
)
#
define
MASK
(
SCALE
-
1
)
class
BaseSuperBlitter
:
public
SkBlitter
{
public
:
BaseSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
;
virtual
void
blitAntiH
(
int
x
int
y
const
SkAlpha
antialias
[
]
const
int16_t
runs
[
]
)
override
{
SkDEBUGFAIL
(
"
How
did
I
get
here
?
"
)
;
}
void
blitV
(
int
x
int
y
int
height
SkAlpha
alpha
)
override
{
SkDEBUGFAIL
(
"
How
did
I
get
here
?
"
)
;
}
protected
:
SkBlitter
*
fRealBlitter
;
int
fCurrIY
;
int
fWidth
;
int
fLeft
;
int
fSuperLeft
;
SkDEBUGCODE
(
int
fCurrX
;
)
int
fCurrY
;
int
fTop
;
SkIRect
fSectBounds
;
}
;
BaseSuperBlitter
:
:
BaseSuperBlitter
(
SkBlitter
*
realBlit
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
{
fRealBlitter
=
realBlit
;
SkIRect
sectBounds
;
if
(
isInverse
)
{
sectBounds
=
clipBounds
;
}
else
{
if
(
!
sectBounds
.
intersect
(
ir
clipBounds
)
)
{
sectBounds
.
setEmpty
(
)
;
}
}
const
int
left
=
sectBounds
.
left
(
)
;
const
int
right
=
sectBounds
.
right
(
)
;
fLeft
=
left
;
fSuperLeft
=
SkLeftShift
(
left
SHIFT
)
;
fWidth
=
right
-
left
;
fTop
=
sectBounds
.
top
(
)
;
fCurrIY
=
fTop
-
1
;
fCurrY
=
SkLeftShift
(
fTop
SHIFT
)
-
1
;
SkDEBUGCODE
(
fCurrX
=
-
1
;
)
}
class
SuperBlitter
:
public
BaseSuperBlitter
{
public
:
SuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
;
~
SuperBlitter
(
)
override
{
this
-
>
flush
(
)
;
}
void
flush
(
)
;
void
blitH
(
int
x
int
y
int
width
)
override
;
void
blitRect
(
int
x
int
y
int
width
int
height
)
override
;
private
:
int
fRunsToBuffer
;
void
*
fRunsBuffer
;
int
fCurrentRun
;
SkAlphaRuns
fRuns
;
int
getRunsSz
(
)
const
{
return
(
fWidth
+
1
+
(
fWidth
+
2
)
/
2
)
*
sizeof
(
int16_t
)
;
}
void
advanceRuns
(
)
{
const
size_t
kRunsSz
=
this
-
>
getRunsSz
(
)
;
fCurrentRun
=
(
fCurrentRun
+
1
)
%
fRunsToBuffer
;
fRuns
.
fRuns
=
reinterpret_cast
<
int16_t
*
>
(
reinterpret_cast
<
uint8_t
*
>
(
fRunsBuffer
)
+
fCurrentRun
*
kRunsSz
)
;
fRuns
.
fAlpha
=
reinterpret_cast
<
SkAlpha
*
>
(
fRuns
.
fRuns
+
fWidth
+
1
)
;
fRuns
.
reset
(
fWidth
)
;
}
int
fOffsetX
;
}
;
SuperBlitter
:
:
SuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
:
BaseSuperBlitter
(
realBlitter
ir
clipBounds
isInverse
)
{
fRunsToBuffer
=
realBlitter
-
>
requestRowsPreserved
(
)
;
fRunsBuffer
=
realBlitter
-
>
allocBlitMemory
(
fRunsToBuffer
*
this
-
>
getRunsSz
(
)
)
;
fCurrentRun
=
-
1
;
this
-
>
advanceRuns
(
)
;
fOffsetX
=
0
;
}
void
SuperBlitter
:
:
flush
(
)
{
if
(
fCurrIY
>
=
fTop
)
{
SkASSERT
(
fCurrentRun
<
fRunsToBuffer
)
;
if
(
!
fRuns
.
empty
(
)
)
{
fRealBlitter
-
>
blitAntiH
(
fLeft
fCurrIY
fRuns
.
fAlpha
fRuns
.
fRuns
)
;
this
-
>
advanceRuns
(
)
;
fOffsetX
=
0
;
}
fCurrIY
=
fTop
-
1
;
SkDEBUGCODE
(
fCurrX
=
-
1
;
)
}
}
static
inline
int
coverage_to_partial_alpha
(
int
aa
)
{
aa
<
<
=
8
-
2
*
SHIFT
;
return
aa
;
}
static
inline
int
coverage_to_exact_alpha
(
int
aa
)
{
int
alpha
=
(
256
>
>
SHIFT
)
*
aa
;
return
alpha
-
(
alpha
>
>
8
)
;
}
void
SuperBlitter
:
:
blitH
(
int
x
int
y
int
width
)
{
SkASSERT
(
width
>
0
)
;
int
iy
=
y
>
>
SHIFT
;
SkASSERT
(
iy
>
=
fCurrIY
)
;
x
-
=
fSuperLeft
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
#
ifdef
SK_DEBUG
SkASSERT
(
y
!
=
fCurrY
|
|
x
>
=
fCurrX
)
;
#
endif
SkASSERT
(
y
>
=
fCurrY
)
;
if
(
fCurrY
!
=
y
)
{
fOffsetX
=
0
;
fCurrY
=
y
;
}
if
(
iy
!
=
fCurrIY
)
{
this
-
>
flush
(
)
;
fCurrIY
=
iy
;
}
int
start
=
x
;
int
stop
=
x
+
width
;
SkASSERT
(
start
>
=
0
&
&
stop
>
start
)
;
int
fb
=
start
&
MASK
;
int
fe
=
stop
&
MASK
;
int
n
=
(
stop
>
>
SHIFT
)
-
(
start
>
>
SHIFT
)
-
1
;
if
(
n
<
0
)
{
fb
=
fe
-
fb
;
n
=
0
;
fe
=
0
;
}
else
{
if
(
fb
=
=
0
)
{
n
+
=
1
;
}
else
{
fb
=
SCALE
-
fb
;
}
}
fOffsetX
=
fRuns
.
add
(
x
>
>
SHIFT
coverage_to_partial_alpha
(
fb
)
n
coverage_to_partial_alpha
(
fe
)
(
1
<
<
(
8
-
SHIFT
)
)
-
(
(
(
y
&
MASK
)
+
1
)
>
>
SHIFT
)
fOffsetX
)
;
#
ifdef
SK_DEBUG
fRuns
.
assertValid
(
y
&
MASK
(
1
<
<
(
8
-
SHIFT
)
)
)
;
fCurrX
=
x
+
width
;
#
endif
}
#
if
0
static
void
set_left_rite_runs
(
SkAlphaRuns
&
runs
int
ileft
U8CPU
leftA
int
n
U8CPU
riteA
)
{
SkASSERT
(
leftA
<
=
0xFF
)
;
SkASSERT
(
riteA
<
=
0xFF
)
;
int16_t
*
run
=
runs
.
fRuns
;
uint8_t
*
aa
=
runs
.
fAlpha
;
if
(
ileft
>
0
)
{
run
[
0
]
=
ileft
;
aa
[
0
]
=
0
;
run
+
=
ileft
;
aa
+
=
ileft
;
}
SkASSERT
(
leftA
<
0xFF
)
;
if
(
leftA
>
0
)
{
*
run
+
+
=
1
;
*
aa
+
+
=
leftA
;
}
if
(
n
>
0
)
{
run
[
0
]
=
n
;
aa
[
0
]
=
0xFF
;
run
+
=
n
;
aa
+
=
n
;
}
SkASSERT
(
riteA
<
0xFF
)
;
if
(
riteA
>
0
)
{
*
run
+
+
=
1
;
*
aa
+
+
=
riteA
;
}
run
[
0
]
=
0
;
}
#
endif
void
SuperBlitter
:
:
blitRect
(
int
x
int
y
int
width
int
height
)
{
SkASSERT
(
width
>
0
)
;
SkASSERT
(
height
>
0
)
;
while
(
(
y
&
MASK
)
)
{
this
-
>
blitH
(
x
y
+
+
width
)
;
if
(
-
-
height
<
=
0
)
{
return
;
}
}
SkASSERT
(
height
>
0
)
;
int
start_y
=
y
>
>
SHIFT
;
int
stop_y
=
(
y
+
height
)
>
>
SHIFT
;
int
count
=
stop_y
-
start_y
;
if
(
count
>
0
)
{
y
+
=
count
<
<
SHIFT
;
height
-
=
count
<
<
SHIFT
;
int
origX
=
x
;
x
-
=
fSuperLeft
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
int
ileft
=
x
>
>
SHIFT
;
int
xleft
=
x
&
MASK
;
int
irite
=
(
x
+
width
)
>
>
SHIFT
;
int
xrite
=
(
x
+
width
)
&
MASK
;
if
(
!
xrite
)
{
xrite
=
SCALE
;
irite
-
-
;
}
SkASSERT
(
start_y
>
fCurrIY
)
;
this
-
>
flush
(
)
;
int
n
=
irite
-
ileft
-
1
;
if
(
n
<
0
)
{
xleft
=
xrite
-
xleft
;
SkASSERT
(
xleft
<
=
SCALE
)
;
SkASSERT
(
xleft
>
0
)
;
fRealBlitter
-
>
blitV
(
ileft
+
fLeft
start_y
count
coverage_to_exact_alpha
(
xleft
)
)
;
}
else
{
xleft
=
SCALE
-
xleft
;
const
int
coverageL
=
coverage_to_exact_alpha
(
xleft
)
;
const
int
coverageR
=
coverage_to_exact_alpha
(
xrite
)
;
SkASSERT
(
coverageL
>
0
|
|
n
>
0
|
|
coverageR
>
0
)
;
SkASSERT
(
(
coverageL
!
=
0
)
+
n
+
(
coverageR
!
=
0
)
<
=
fWidth
)
;
fRealBlitter
-
>
blitAntiRect
(
ileft
+
fLeft
start_y
n
count
coverageL
coverageR
)
;
}
fCurrIY
=
stop_y
-
1
;
fOffsetX
=
0
;
fCurrY
=
y
-
1
;
fRuns
.
reset
(
fWidth
)
;
x
=
origX
;
}
SkASSERT
(
height
<
=
MASK
)
;
while
(
-
-
height
>
=
0
)
{
this
-
>
blitH
(
x
y
+
+
width
)
;
}
}
class
MaskSuperBlitter
:
public
BaseSuperBlitter
{
public
:
MaskSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
bool
isInverse
)
;
~
MaskSuperBlitter
(
)
override
{
fRealBlitter
-
>
blitMask
(
fMask
fClipRect
)
;
}
void
blitH
(
int
x
int
y
int
width
)
override
;
static
bool
CanHandleRect
(
const
SkIRect
&
bounds
)
{
#
ifdef
FORCE_RLE
return
false
;
#
endif
int
width
=
bounds
.
width
(
)
;
int64_t
rb
=
SkAlign4
(
width
)
;
int64_t
storage
=
rb
*
bounds
.
height
(
)
;
return
(
width
<
=
MaskSuperBlitter
:
:
kMAX_WIDTH
)
&
&
(
storage
<
=
MaskSuperBlitter
:
:
kMAX_STORAGE
)
;
}
private
:
enum
{
#
ifdef
FORCE_SUPERMASK
kMAX_WIDTH
=
2048
kMAX_STORAGE
=
1024
*
1024
*
2
#
else
kMAX_WIDTH
=
32
kMAX_STORAGE
=
1024
#
endif
}
;
SkMask
fMask
;
SkIRect
fClipRect
;
uint32_t
fStorage
[
(
kMAX_STORAGE
>
>
2
)
+
1
]
;
}
;
MaskSuperBlitter
:
:
MaskSuperBlitter
(
SkBlitter
*
realBlitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
isInverse
)
:
BaseSuperBlitter
(
realBlitter
ir
clipBounds
isInverse
)
{
SkASSERT
(
CanHandleRect
(
ir
)
)
;
SkASSERT
(
!
isInverse
)
;
fMask
.
fImage
=
(
uint8_t
*
)
fStorage
;
fMask
.
fBounds
=
ir
;
fMask
.
fRowBytes
=
ir
.
width
(
)
;
fMask
.
fFormat
=
SkMask
:
:
kA8_Format
;
fClipRect
=
ir
;
if
(
!
fClipRect
.
intersect
(
clipBounds
)
)
{
SkASSERT
(
0
)
;
fClipRect
.
setEmpty
(
)
;
}
memset
(
fStorage
0
fMask
.
fBounds
.
height
(
)
*
fMask
.
fRowBytes
+
1
)
;
}
static
void
add_aa_span
(
uint8_t
*
alpha
U8CPU
startAlpha
)
{
unsigned
tmp
=
*
alpha
+
startAlpha
;
SkASSERT
(
tmp
<
=
256
)
;
*
alpha
=
SkToU8
(
tmp
-
(
tmp
>
>
8
)
)
;
}
static
inline
uint32_t
quadplicate_byte
(
U8CPU
value
)
{
uint32_t
pair
=
(
value
<
<
8
)
|
value
;
return
(
pair
<
<
16
)
|
pair
;
}
static
inline
void
saturated_add
(
uint8_t
*
ptr
U8CPU
add
)
{
unsigned
tmp
=
*
ptr
+
add
;
SkASSERT
(
tmp
<
=
256
)
;
*
ptr
=
SkToU8
(
tmp
-
(
tmp
>
>
8
)
)
;
}
#
define
MIN_COUNT_FOR_QUAD_LOOP
16
static
void
add_aa_span
(
uint8_t
*
alpha
U8CPU
startAlpha
int
middleCount
U8CPU
stopAlpha
U8CPU
maxValue
)
{
SkASSERT
(
middleCount
>
=
0
)
;
saturated_add
(
alpha
startAlpha
)
;
alpha
+
=
1
;
if
(
middleCount
>
=
MIN_COUNT_FOR_QUAD_LOOP
)
{
while
(
reinterpret_cast
<
intptr_t
>
(
alpha
)
&
0x3
)
{
alpha
[
0
]
=
SkToU8
(
alpha
[
0
]
+
maxValue
)
;
alpha
+
=
1
;
middleCount
-
=
1
;
}
int
bigCount
=
middleCount
>
>
2
;
uint32_t
*
qptr
=
reinterpret_cast
<
uint32_t
*
>
(
alpha
)
;
uint32_t
qval
=
quadplicate_byte
(
maxValue
)
;
do
{
*
qptr
+
+
+
=
qval
;
}
while
(
-
-
bigCount
>
0
)
;
middleCount
&
=
3
;
alpha
=
reinterpret_cast
<
uint8_t
*
>
(
qptr
)
;
}
while
(
-
-
middleCount
>
=
0
)
{
alpha
[
0
]
=
SkToU8
(
alpha
[
0
]
+
maxValue
)
;
alpha
+
=
1
;
}
saturated_add
(
alpha
stopAlpha
)
;
}
void
MaskSuperBlitter
:
:
blitH
(
int
x
int
y
int
width
)
{
int
iy
=
(
y
>
>
SHIFT
)
;
SkASSERT
(
iy
>
=
fMask
.
fBounds
.
fTop
&
&
iy
<
fMask
.
fBounds
.
fBottom
)
;
iy
-
=
fMask
.
fBounds
.
fTop
;
if
(
iy
<
0
)
{
return
;
}
#
ifdef
SK_DEBUG
{
int
ix
=
x
>
>
SHIFT
;
SkASSERT
(
ix
>
=
fMask
.
fBounds
.
fLeft
&
&
ix
<
fMask
.
fBounds
.
fRight
)
;
}
#
endif
x
-
=
SkLeftShift
(
fMask
.
fBounds
.
fLeft
SHIFT
)
;
if
(
x
<
0
)
{
width
+
=
x
;
x
=
0
;
}
uint8_t
*
row
=
fMask
.
fImage
+
iy
*
fMask
.
fRowBytes
+
(
x
>
>
SHIFT
)
;
int
start
=
x
;
int
stop
=
x
+
width
;
SkASSERT
(
start
>
=
0
&
&
stop
>
start
)
;
int
fb
=
start
&
MASK
;
int
fe
=
stop
&
MASK
;
int
n
=
(
stop
>
>
SHIFT
)
-
(
start
>
>
SHIFT
)
-
1
;
if
(
n
<
0
)
{
SkASSERT
(
row
>
=
fMask
.
fImage
)
;
SkASSERT
(
row
<
fMask
.
fImage
+
kMAX_STORAGE
+
1
)
;
add_aa_span
(
row
coverage_to_partial_alpha
(
fe
-
fb
)
)
;
}
else
{
fb
=
SCALE
-
fb
;
SkASSERT
(
row
>
=
fMask
.
fImage
)
;
SkASSERT
(
row
+
n
+
1
<
fMask
.
fImage
+
kMAX_STORAGE
+
1
)
;
add_aa_span
(
row
coverage_to_partial_alpha
(
fb
)
n
coverage_to_partial_alpha
(
fe
)
(
1
<
<
(
8
-
SHIFT
)
)
-
(
(
(
y
&
MASK
)
+
1
)
>
>
SHIFT
)
)
;
}
#
ifdef
SK_DEBUG
fCurrX
=
x
+
width
;
#
endif
}
static
SkIRect
safeRoundOut
(
const
SkRect
&
src
)
{
SkIRect
dst
=
src
.
roundOut
(
)
;
const
int32_t
limit
=
SK_MaxS32
>
>
SK_SUPERSAMPLE_SHIFT
;
(
void
)
dst
.
intersect
(
{
-
limit
-
limit
limit
limit
}
)
;
return
dst
;
}
constexpr
int
kSampleSize
=
8
;
#
if
!
defined
(
SK_DISABLE_DAA
)
|
|
!
defined
(
SK_DISABLE_AAA
)
constexpr
SkScalar
kComplexityThreshold
=
0
.
25
;
#
endif
static
void
compute_complexity
(
const
SkPath
&
path
SkScalar
&
avgLength
SkScalar
&
complexity
)
{
int
n
=
path
.
countPoints
(
)
;
if
(
n
<
kSampleSize
|
|
path
.
getBounds
(
)
.
isEmpty
(
)
)
{
avgLength
=
complexity
=
-
1
;
return
;
}
SkScalar
sumLength
=
0
;
SkPoint
lastPoint
=
path
.
getPoint
(
0
)
;
for
(
int
i
=
1
;
i
<
kSampleSize
;
+
+
i
)
{
SkPoint
point
=
path
.
getPoint
(
i
)
;
sumLength
+
=
SkPoint
:
:
Distance
(
lastPoint
point
)
;
lastPoint
=
point
;
}
avgLength
=
sumLength
/
(
kSampleSize
-
1
)
;
auto
sqr
=
[
]
(
SkScalar
x
)
{
return
x
*
x
;
}
;
SkScalar
diagonalSqr
=
sqr
(
path
.
getBounds
(
)
.
width
(
)
)
+
sqr
(
path
.
getBounds
(
)
.
height
(
)
)
;
SkScalar
intersections
=
sk_ieee_float_divide
(
sqr
(
n
)
*
sqr
(
avgLength
)
diagonalSqr
)
;
complexity
=
sk_ieee_float_divide
(
intersections
path
.
getBounds
(
)
.
height
(
)
)
;
if
(
sk_float_isnan
(
complexity
)
)
{
complexity
=
-
1
;
}
}
static
bool
ShouldUseDAA
(
const
SkPath
&
path
SkScalar
avgLength
SkScalar
complexity
)
{
#
if
defined
(
SK_DISABLE_DAA
)
return
false
;
#
else
if
(
gSkForceDeltaAA
)
{
return
true
;
}
if
(
!
gSkUseDeltaAA
|
|
SkPathPriv
:
:
IsBadForDAA
(
path
)
)
{
return
false
;
}
#
ifdef
SK_SUPPORT_LEGACY_AA_CHOICE
const
SkRect
&
bounds
=
path
.
getBounds
(
)
;
return
!
path
.
isConvex
(
)
&
&
path
.
countPoints
(
)
>
=
SkTMax
(
bounds
.
width
(
)
bounds
.
height
(
)
)
/
8
;
#
else
if
(
avgLength
<
0
|
|
complexity
<
0
|
|
path
.
getBounds
(
)
.
isEmpty
(
)
|
|
path
.
isConvex
(
)
)
{
return
false
;
}
if
(
SkCoverageDeltaMask
:
:
CanHandle
(
safeRoundOut
(
path
.
getBounds
(
)
)
)
)
{
return
true
;
}
constexpr
SkScalar
kSmallCubicThreshold
=
16
;
if
(
avgLength
<
kSmallCubicThreshold
)
{
uint8_t
sampleVerbs
[
kSampleSize
]
;
int
verbCount
=
SkTMin
(
kSampleSize
path
.
getVerbs
(
sampleVerbs
kSampleSize
)
)
;
int
cubicCount
=
0
;
for
(
int
i
=
0
;
i
<
verbCount
;
+
+
i
)
{
cubicCount
+
=
(
sampleVerbs
[
i
]
=
=
SkPath
:
:
kCubic_Verb
)
;
}
if
(
cubicCount
*
2
>
=
verbCount
)
{
return
true
;
}
}
return
complexity
>
=
kComplexityThreshold
;
#
endif
#
endif
}
static
bool
ShouldUseAAA
(
const
SkPath
&
path
SkScalar
avgLength
SkScalar
complexity
)
{
#
if
defined
(
SK_DISABLE_AAA
)
return
false
;
#
else
if
(
gSkForceAnalyticAA
)
{
return
true
;
}
if
(
!
gSkUseAnalyticAA
)
{
return
false
;
}
if
(
path
.
isRect
(
nullptr
)
)
{
return
true
;
}
#
ifdef
SK_SUPPORT_LEGACY_AAA_CHOICE
const
SkRect
&
bounds
=
path
.
getBounds
(
)
;
return
path
.
countPoints
(
)
<
SkTMax
(
bounds
.
width
(
)
bounds
.
height
(
)
)
/
2
-
10
;
#
else
if
(
path
.
countPoints
(
)
>
=
path
.
getBounds
(
)
.
height
(
)
)
{
return
false
;
}
return
complexity
<
kComplexityThreshold
;
#
endif
#
endif
}
void
SkScan
:
:
SAAFillPath
(
const
SkPath
&
path
SkBlitter
*
blitter
const
SkIRect
&
ir
const
SkIRect
&
clipBounds
bool
forceRLE
)
{
bool
containedInClip
=
clipBounds
.
contains
(
ir
)
;
bool
isInverse
=
path
.
isInverseFillType
(
)
;
if
(
!
isInverse
&
&
MaskSuperBlitter
:
:
CanHandleRect
(
ir
)
&
&
!
forceRLE
)
{
MaskSuperBlitter
superBlit
(
blitter
ir
clipBounds
isInverse
)
;
SkASSERT
(
SkIntToScalar
(
ir
.
fTop
)
<
=
path
.
getBounds
(
)
.
fTop
)
;
sk_fill_path
(
path
clipBounds
&
superBlit
ir
.
fTop
ir
.
fBottom
SHIFT
containedInClip
)
;
}
else
{
SuperBlitter
superBlit
(
blitter
ir
clipBounds
isInverse
)
;
sk_fill_path
(
path
clipBounds
&
superBlit
ir
.
fTop
ir
.
fBottom
SHIFT
containedInClip
)
;
}
}
static
int
overflows_short_shift
(
int
value
int
shift
)
{
const
int
s
=
16
+
shift
;
return
(
SkLeftShift
(
value
s
)
>
>
s
)
-
value
;
}
static
int
rect_overflows_short_shift
(
SkIRect
rect
int
shift
)
{
SkASSERT
(
!
overflows_short_shift
(
8191
shift
)
)
;
SkASSERT
(
overflows_short_shift
(
8192
shift
)
)
;
SkASSERT
(
!
overflows_short_shift
(
32767
0
)
)
;
SkASSERT
(
overflows_short_shift
(
32768
0
)
)
;
return
overflows_short_shift
(
rect
.
fLeft
shift
)
|
overflows_short_shift
(
rect
.
fRight
shift
)
|
overflows_short_shift
(
rect
.
fTop
shift
)
|
overflows_short_shift
(
rect
.
fBottom
shift
)
;
}
void
SkScan
:
:
AntiFillPath
(
const
SkPath
&
path
const
SkRegion
&
origClip
SkBlitter
*
blitter
bool
forceRLE
SkDAARecord
*
daaRecord
)
{
if
(
origClip
.
isEmpty
(
)
)
{
SkDAARecord
:
:
SetEmpty
(
daaRecord
)
;
return
;
}
const
bool
isInverse
=
path
.
isInverseFillType
(
)
;
SkIRect
ir
=
safeRoundOut
(
path
.
getBounds
(
)
)
;
if
(
ir
.
isEmpty
(
)
)
{
if
(
isInverse
)
{
blitter
-
>
blitRegion
(
origClip
)
;
}
SkDAARecord
:
:
SetEmpty
(
daaRecord
)
;
return
;
}
SkIRect
clippedIR
;
if
(
isInverse
)
{
clippedIR
=
origClip
.
getBounds
(
)
;
}
else
{
if
(
!
clippedIR
.
intersect
(
ir
origClip
.
getBounds
(
)
)
)
{
SkDAARecord
:
:
SetEmpty
(
daaRecord
)
;
return
;
}
}
if
(
!
daaRecord
&
&
rect_overflows_short_shift
(
clippedIR
SHIFT
)
)
{
SkScan
:
:
FillPath
(
path
origClip
blitter
)
;
return
;
}
SkRegion
tmpClipStorage
;
const
SkRegion
*
clipRgn
=
&
origClip
;
{
static
const
int32_t
kMaxClipCoord
=
32767
;
const
SkIRect
&
bounds
=
origClip
.
getBounds
(
)
;
if
(
bounds
.
fRight
>
kMaxClipCoord
|
|
bounds
.
fBottom
>
kMaxClipCoord
)
{
SkIRect
limit
=
{
0
0
kMaxClipCoord
kMaxClipCoord
}
;
tmpClipStorage
.
op
(
origClip
limit
SkRegion
:
:
kIntersect_Op
)
;
clipRgn
=
&
tmpClipStorage
;
}
}
SkScanClipper
clipper
(
blitter
clipRgn
ir
)
;
if
(
clipper
.
getBlitter
(
)
=
=
nullptr
)
{
if
(
isInverse
)
{
blitter
-
>
blitRegion
(
*
clipRgn
)
;
}
SkDAARecord
:
:
SetEmpty
(
daaRecord
)
;
return
;
}
SkASSERT
(
clipper
.
getClipRect
(
)
=
=
nullptr
|
|
*
clipper
.
getClipRect
(
)
=
=
clipRgn
-
>
getBounds
(
)
)
;
blitter
=
clipper
.
getBlitter
(
)
;
if
(
isInverse
)
{
sk_blit_above
(
blitter
ir
*
clipRgn
)
;
}
SkScalar
avgLength
complexity
;
compute_complexity
(
path
avgLength
complexity
)
;
if
(
daaRecord
|
|
ShouldUseDAA
(
path
avgLength
complexity
)
)
{
SkScan
:
:
DAAFillPath
(
path
blitter
ir
clipRgn
-
>
getBounds
(
)
forceRLE
daaRecord
)
;
}
else
if
(
ShouldUseAAA
(
path
avgLength
complexity
)
)
{
SkScan
:
:
AAAFillPath
(
path
blitter
ir
clipRgn
-
>
getBounds
(
)
forceRLE
)
;
}
else
{
SkScan
:
:
SAAFillPath
(
path
blitter
ir
clipRgn
-
>
getBounds
(
)
forceRLE
)
;
}
if
(
isInverse
)
{
sk_blit_below
(
blitter
ir
*
clipRgn
)
;
}
}
#
include
"
SkRasterClip
.
h
"
void
SkScan
:
:
FillPath
(
const
SkPath
&
path
const
SkRasterClip
&
clip
SkBlitter
*
blitter
)
{
if
(
clip
.
isEmpty
(
)
|
|
!
path
.
isFinite
(
)
)
{
return
;
}
if
(
clip
.
isBW
(
)
)
{
FillPath
(
path
clip
.
bwRgn
(
)
blitter
)
;
}
else
{
SkRegion
tmp
;
SkAAClipBlitter
aaBlitter
;
tmp
.
setRect
(
clip
.
getBounds
(
)
)
;
aaBlitter
.
init
(
blitter
&
clip
.
aaRgn
(
)
)
;
SkScan
:
:
FillPath
(
path
tmp
&
aaBlitter
)
;
}
}
void
SkScan
:
:
AntiFillPath
(
const
SkPath
&
path
const
SkRasterClip
&
clip
SkBlitter
*
blitter
SkDAARecord
*
daaRecord
)
{
if
(
clip
.
isEmpty
(
)
|
|
!
path
.
isFinite
(
)
)
{
SkDAARecord
:
:
SetEmpty
(
daaRecord
)
;
return
;
}
if
(
clip
.
isBW
(
)
)
{
AntiFillPath
(
path
clip
.
bwRgn
(
)
blitter
false
daaRecord
)
;
}
else
{
SkRegion
tmp
;
SkAAClipBlitter
aaBlitter
;
tmp
.
setRect
(
clip
.
getBounds
(
)
)
;
aaBlitter
.
init
(
blitter
&
clip
.
aaRgn
(
)
)
;
AntiFillPath
(
path
tmp
&
aaBlitter
true
daaRecord
)
;
}
}
