#
ifndef
SkMask_DEFINED
#
define
SkMask_DEFINED
#
include
"
SkColorPriv
.
h
"
#
include
"
SkMacros
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
<
memory
>
struct
SkMask
{
SkMask
(
)
:
fImage
(
nullptr
)
{
}
enum
Format
{
kBW_Format
kA8_Format
k3D_Format
kARGB32_Format
kLCD16_Format
kSDF_Format
}
;
enum
{
kCountMaskFormats
=
kSDF_Format
+
1
}
;
uint8_t
*
fImage
;
SkIRect
fBounds
;
uint32_t
fRowBytes
;
Format
fFormat
;
bool
isEmpty
(
)
const
{
return
fBounds
.
isEmpty
(
)
;
}
size_t
computeImageSize
(
)
const
;
size_t
computeTotalImageSize
(
)
const
;
uint8_t
*
getAddr1
(
int
x
int
y
)
const
{
SkASSERT
(
kBW_Format
=
=
fFormat
)
;
SkASSERT
(
fBounds
.
contains
(
x
y
)
)
;
SkASSERT
(
fImage
!
=
nullptr
)
;
return
fImage
+
(
(
x
-
fBounds
.
fLeft
)
>
>
3
)
+
(
y
-
fBounds
.
fTop
)
*
fRowBytes
;
}
uint8_t
*
getAddr8
(
int
x
int
y
)
const
{
SkASSERT
(
kA8_Format
=
=
fFormat
|
|
kSDF_Format
=
=
fFormat
)
;
SkASSERT
(
fBounds
.
contains
(
x
y
)
)
;
SkASSERT
(
fImage
!
=
nullptr
)
;
return
fImage
+
x
-
fBounds
.
fLeft
+
(
y
-
fBounds
.
fTop
)
*
fRowBytes
;
}
uint16_t
*
getAddrLCD16
(
int
x
int
y
)
const
{
SkASSERT
(
kLCD16_Format
=
=
fFormat
)
;
SkASSERT
(
fBounds
.
contains
(
x
y
)
)
;
SkASSERT
(
fImage
!
=
nullptr
)
;
uint16_t
*
row
=
(
uint16_t
*
)
(
fImage
+
(
y
-
fBounds
.
fTop
)
*
fRowBytes
)
;
return
row
+
(
x
-
fBounds
.
fLeft
)
;
}
uint32_t
*
getAddr32
(
int
x
int
y
)
const
{
SkASSERT
(
kARGB32_Format
=
=
fFormat
)
;
SkASSERT
(
fBounds
.
contains
(
x
y
)
)
;
SkASSERT
(
fImage
!
=
nullptr
)
;
uint32_t
*
row
=
(
uint32_t
*
)
(
fImage
+
(
y
-
fBounds
.
fTop
)
*
fRowBytes
)
;
return
row
+
(
x
-
fBounds
.
fLeft
)
;
}
void
*
getAddr
(
int
x
int
y
)
const
;
enum
AllocType
{
kUninit_Alloc
kZeroInit_Alloc
}
;
static
uint8_t
*
AllocImage
(
size_t
bytes
AllocType
=
kUninit_Alloc
)
;
static
void
FreeImage
(
void
*
image
)
;
enum
CreateMode
{
kJustComputeBounds_CreateMode
kJustRenderImage_CreateMode
kComputeBoundsAndRenderImage_CreateMode
}
;
template
<
Format
F
>
struct
AlphaIter
;
static
SkMask
PrepareDestination
(
int
radiusX
int
radiusY
const
SkMask
&
src
)
;
}
;
template
<
>
struct
SkMask
:
:
AlphaIter
<
SkMask
:
:
kBW_Format
>
{
AlphaIter
(
const
uint8_t
*
ptr
int
offset
)
:
fPtr
(
ptr
)
fOffset
(
7
-
offset
)
{
}
AlphaIter
(
const
AlphaIter
&
that
)
:
fPtr
(
that
.
fPtr
)
fOffset
(
that
.
fOffset
)
{
}
AlphaIter
&
operator
+
+
(
)
{
if
(
0
<
fOffset
)
{
-
-
fOffset
;
}
else
{
+
+
fPtr
;
fOffset
=
7
;
}
return
*
this
;
}
AlphaIter
&
operator
-
-
(
)
{
if
(
fOffset
<
7
)
{
+
+
fOffset
;
}
else
{
-
-
fPtr
;
fOffset
=
0
;
}
return
*
this
;
}
AlphaIter
&
operator
>
>
=
(
uint32_t
rb
)
{
fPtr
=
SkTAddOffset
<
const
uint8_t
>
(
fPtr
rb
)
;
return
*
this
;
}
uint8_t
operator
*
(
)
const
{
return
(
(
*
fPtr
)
>
>
fOffset
)
&
1
?
0xFF
:
0
;
}
bool
operator
<
(
const
AlphaIter
&
that
)
const
{
return
fPtr
<
that
.
fPtr
|
|
(
fPtr
=
=
that
.
fPtr
&
&
fOffset
>
that
.
fOffset
)
;
}
const
uint8_t
*
fPtr
;
int
fOffset
;
}
;
template
<
>
struct
SkMask
:
:
AlphaIter
<
SkMask
:
:
kA8_Format
>
{
AlphaIter
(
const
uint8_t
*
ptr
)
:
fPtr
(
ptr
)
{
}
AlphaIter
(
const
AlphaIter
&
that
)
:
fPtr
(
that
.
fPtr
)
{
}
AlphaIter
&
operator
+
+
(
)
{
+
+
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
-
-
(
)
{
-
-
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
>
>
=
(
uint32_t
rb
)
{
fPtr
=
SkTAddOffset
<
const
uint8_t
>
(
fPtr
rb
)
;
return
*
this
;
}
uint8_t
operator
*
(
)
const
{
return
*
fPtr
;
}
bool
operator
<
(
const
AlphaIter
&
that
)
const
{
return
fPtr
<
that
.
fPtr
;
}
const
uint8_t
*
fPtr
;
}
;
template
<
>
struct
SkMask
:
:
AlphaIter
<
SkMask
:
:
kARGB32_Format
>
{
AlphaIter
(
const
uint32_t
*
ptr
)
:
fPtr
(
ptr
)
{
}
AlphaIter
(
const
AlphaIter
&
that
)
:
fPtr
(
that
.
fPtr
)
{
}
AlphaIter
&
operator
+
+
(
)
{
+
+
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
-
-
(
)
{
-
-
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
>
>
=
(
uint32_t
rb
)
{
fPtr
=
SkTAddOffset
<
const
uint32_t
>
(
fPtr
rb
)
;
return
*
this
;
}
uint8_t
operator
*
(
)
const
{
return
SkGetPackedA32
(
*
fPtr
)
;
}
bool
operator
<
(
const
AlphaIter
&
that
)
const
{
return
fPtr
<
that
.
fPtr
;
}
const
uint32_t
*
fPtr
;
}
;
template
<
>
struct
SkMask
:
:
AlphaIter
<
SkMask
:
:
kLCD16_Format
>
{
AlphaIter
(
const
uint16_t
*
ptr
)
:
fPtr
(
ptr
)
{
}
AlphaIter
(
const
AlphaIter
&
that
)
:
fPtr
(
that
.
fPtr
)
{
}
AlphaIter
&
operator
+
+
(
)
{
+
+
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
-
-
(
)
{
-
-
fPtr
;
return
*
this
;
}
AlphaIter
&
operator
>
>
=
(
uint32_t
rb
)
{
fPtr
=
SkTAddOffset
<
const
uint16_t
>
(
fPtr
rb
)
;
return
*
this
;
}
uint8_t
operator
*
(
)
const
{
unsigned
packed
=
*
fPtr
;
unsigned
r
=
SkPacked16ToR32
(
packed
)
;
unsigned
g
=
SkPacked16ToG32
(
packed
)
;
unsigned
b
=
SkPacked16ToB32
(
packed
)
;
return
(
r
+
g
+
b
)
/
3
;
}
bool
operator
<
(
const
AlphaIter
&
that
)
const
{
return
fPtr
<
that
.
fPtr
;
}
const
uint16_t
*
fPtr
;
}
;
using
SkAutoMaskFreeImage
=
std
:
:
unique_ptr
<
uint8_t
SkFunctionWrapper
<
void
void
SkMask
:
:
FreeImage
>
>
;
#
define
SkAutoMaskFreeImage
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoMaskFreeImage
)
#
endif
