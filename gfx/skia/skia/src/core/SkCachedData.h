#
ifndef
SkCachedData_DEFINED
#
define
SkCachedData_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkMutex
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
class
SkDiscardableMemory
;
class
SkCachedData
:
:
:
SkNoncopyable
{
public
:
SkCachedData
(
void
*
mallocData
size_t
size
)
;
SkCachedData
(
size_t
size
SkDiscardableMemory
*
)
;
virtual
~
SkCachedData
(
)
;
size_t
size
(
)
const
{
return
fSize
;
}
const
void
*
data
(
)
const
{
return
fData
;
}
void
*
writable_data
(
)
{
return
fData
;
}
void
ref
(
)
const
{
this
-
>
internalRef
(
false
)
;
}
void
unref
(
)
const
{
this
-
>
internalUnref
(
false
)
;
}
int
testing_only_getRefCnt
(
)
const
{
return
fRefCnt
;
}
bool
testing_only_isLocked
(
)
const
{
return
fIsLocked
;
}
bool
testing_only_isInCache
(
)
const
{
return
fInCache
;
}
SkDiscardableMemory
*
diagnostic_only_getDiscardable
(
)
const
{
return
kDiscardableMemory_StorageType
=
=
fStorageType
?
fStorage
.
fDM
:
nullptr
;
}
protected
:
virtual
void
onDataChange
(
void
*
oldData
void
*
newData
)
{
}
private
:
SkMutex
fMutex
;
enum
StorageType
{
kDiscardableMemory_StorageType
kMalloc_StorageType
}
;
union
{
SkDiscardableMemory
*
fDM
;
void
*
fMalloc
;
}
fStorage
;
void
*
fData
;
size_t
fSize
;
int
fRefCnt
;
StorageType
fStorageType
;
bool
fInCache
;
bool
fIsLocked
;
void
internalRef
(
bool
fromCache
)
const
;
void
internalUnref
(
bool
fromCache
)
const
;
void
inMutexRef
(
bool
fromCache
)
;
bool
inMutexUnref
(
bool
fromCache
)
;
void
inMutexLock
(
)
;
void
inMutexUnlock
(
)
;
void
setData
(
void
*
newData
)
{
if
(
newData
!
=
fData
)
{
this
-
>
onDataChange
(
fData
newData
)
;
fData
=
newData
;
}
}
class
AutoMutexWritable
;
public
:
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
void
attachToCacheAndRef
(
)
const
{
this
-
>
internalRef
(
true
)
;
}
void
detachFromCacheAndUnref
(
)
const
{
this
-
>
internalUnref
(
true
)
;
}
}
;
#
endif
