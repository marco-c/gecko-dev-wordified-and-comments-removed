#
ifndef
SkThreadedBMPDevice_DEFINED
#
define
SkThreadedBMPDevice_DEFINED
#
include
"
SkBitmapDevice
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkTaskGroup2D
.
h
"
class
SkThreadedBMPDevice
:
public
SkBitmapDevice
{
public
:
SkThreadedBMPDevice
(
const
SkBitmap
&
bitmap
int
tiles
int
threads
=
0
SkExecutor
*
executor
=
nullptr
)
;
~
SkThreadedBMPDevice
(
)
override
{
fQueue
.
finish
(
)
;
}
protected
:
void
drawPaint
(
const
SkPaint
&
paint
)
override
;
void
drawPoints
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
[
]
const
SkPaint
&
paint
)
override
;
void
drawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
override
;
void
drawRRect
(
const
SkRRect
&
rr
const
SkPaint
&
paint
)
override
;
void
drawPath
(
const
SkPath
&
const
SkPaint
&
const
SkMatrix
*
prePathMatrix
bool
pathIsMutable
)
override
;
void
drawBitmap
(
const
SkBitmap
&
SkScalar
x
SkScalar
y
const
SkPaint
&
)
override
;
void
drawSprite
(
const
SkBitmap
&
int
x
int
y
const
SkPaint
&
)
override
;
void
drawText
(
const
void
*
text
size_t
len
SkScalar
x
SkScalar
y
const
SkPaint
&
)
override
;
void
drawPosText
(
const
void
*
text
size_t
len
const
SkScalar
pos
[
]
int
scalarsPerPos
const
SkPoint
&
offset
const
SkPaint
&
paint
)
override
;
void
drawVertices
(
const
SkVertices
*
SkBlendMode
const
SkPaint
&
)
override
;
void
drawDevice
(
SkBaseDevice
*
int
x
int
y
const
SkPaint
&
)
override
;
void
flush
(
)
override
;
private
:
struct
DrawState
{
SkPixmap
fDst
;
SkMatrix
fMatrix
;
SkRasterClip
fRC
;
DrawState
(
)
{
}
explicit
DrawState
(
SkThreadedBMPDevice
*
dev
)
;
SkDraw
getDraw
(
)
const
;
}
;
class
TileDraw
:
public
SkDraw
{
public
:
TileDraw
(
const
DrawState
&
ds
const
SkIRect
&
tileBounds
)
;
private
:
SkRasterClip
fTileRC
;
}
;
class
DrawElement
{
public
:
using
InitFn
=
std
:
:
function
<
void
(
SkArenaAlloc
*
threadAlloc
DrawElement
*
element
)
>
;
using
DrawFn
=
std
:
:
function
<
void
(
SkArenaAlloc
*
threadAlloc
const
DrawState
&
ds
const
SkIRect
&
tileBounds
)
>
;
DrawElement
(
)
{
}
DrawElement
(
SkThreadedBMPDevice
*
device
DrawFn
&
&
drawFn
const
SkRect
&
rawDrawBounds
)
:
fInitialized
(
true
)
fDrawFn
(
std
:
:
move
(
drawFn
)
)
fDS
(
device
)
fDrawBounds
(
device
-
>
transformDrawBounds
(
rawDrawBounds
)
)
{
}
DrawElement
(
SkThreadedBMPDevice
*
device
InitFn
&
&
initFn
const
SkRect
&
rawDrawBounds
)
:
fInitialized
(
false
)
fNeedInit
(
true
)
fInitFn
(
std
:
:
move
(
initFn
)
)
fDS
(
device
)
fDrawBounds
(
device
-
>
transformDrawBounds
(
rawDrawBounds
)
)
{
}
SK_ALWAYS_INLINE
bool
tryInitOnce
(
SkArenaAlloc
*
alloc
)
{
bool
t
=
true
;
if
(
!
fInitialized
&
&
fNeedInit
&
&
fNeedInit
.
compare_exchange_strong
(
t
false
)
)
{
#
ifdef
SK_DEBUG
fDrawFn
=
0
;
#
endif
fInitFn
(
alloc
this
)
;
fInitialized
=
true
;
SkASSERT
(
fDrawFn
!
=
0
)
;
return
true
;
}
return
false
;
}
SK_ALWAYS_INLINE
bool
tryDraw
(
const
SkIRect
&
tileBounds
SkArenaAlloc
*
alloc
)
{
if
(
!
SkIRect
:
:
Intersects
(
tileBounds
fDrawBounds
)
)
{
return
true
;
}
if
(
fInitialized
)
{
fDrawFn
(
alloc
fDS
tileBounds
)
;
return
true
;
}
return
false
;
}
SkDraw
getDraw
(
)
const
{
return
fDS
.
getDraw
(
)
;
}
void
setDrawFn
(
DrawFn
&
&
fn
)
{
fDrawFn
=
std
:
:
move
(
fn
)
;
}
private
:
std
:
:
atomic
<
bool
>
fInitialized
;
std
:
:
atomic
<
bool
>
fNeedInit
;
InitFn
fInitFn
;
DrawFn
fDrawFn
;
DrawState
fDS
;
SkIRect
fDrawBounds
;
}
;
class
DrawQueue
:
public
SkWorkKernel2D
{
public
:
static
constexpr
int
MAX_QUEUE_SIZE
=
100000
;
DrawQueue
(
SkThreadedBMPDevice
*
device
)
:
fDevice
(
device
)
{
}
void
reset
(
)
;
void
finish
(
)
{
fTasks
-
>
finish
(
)
;
}
template
<
typename
Fn
>
SK_ALWAYS_INLINE
void
push
(
const
SkRect
&
rawDrawBounds
Fn
&
&
fn
)
{
if
(
fSize
=
=
MAX_QUEUE_SIZE
)
{
this
-
>
reset
(
)
;
}
SkASSERT
(
fSize
<
MAX_QUEUE_SIZE
)
;
new
(
&
fElements
[
fSize
+
+
]
)
DrawElement
(
fDevice
std
:
:
move
(
fn
)
rawDrawBounds
)
;
fTasks
-
>
addColumn
(
)
;
}
bool
initColumn
(
int
column
int
thread
)
override
;
bool
work2D
(
int
row
int
column
int
thread
)
override
;
private
:
SkThreadedBMPDevice
*
fDevice
;
std
:
:
unique_ptr
<
SkTaskGroup2D
>
fTasks
;
SkTArray
<
SkSTArenaAlloc
<
8
<
<
10
>
>
fThreadAllocs
;
DrawElement
fElements
[
MAX_QUEUE_SIZE
]
;
int
fSize
;
}
;
SkIRect
transformDrawBounds
(
const
SkRect
&
drawBounds
)
const
;
const
int
fTileCnt
;
const
int
fThreadCnt
;
SkTArray
<
SkIRect
>
fTileBounds
;
SkExecutor
*
fExecutor
=
nullptr
;
std
:
:
unique_ptr
<
SkExecutor
>
fInternalExecutor
;
SkSTArenaAlloc
<
8
<
<
10
>
fAlloc
;
DrawQueue
fQueue
;
friend
struct
SkInitOnceData
;
friend
class
SkDraw
;
typedef
SkBitmapDevice
INHERITED
;
}
;
struct
SkInitOnceData
{
SkArenaAlloc
*
fAlloc
;
SkThreadedBMPDevice
:
:
DrawElement
*
fElement
;
void
setEmptyDrawFn
(
)
{
fElement
-
>
setDrawFn
(
[
]
(
SkArenaAlloc
*
threadAlloc
const
SkThreadedBMPDevice
:
:
DrawState
&
ds
const
SkIRect
&
tileBounds
)
{
}
)
;
}
}
;
#
endif
