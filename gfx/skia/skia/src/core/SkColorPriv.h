#
ifndef
SkColorPriv_DEFINED
#
define
SkColorPriv_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkCPUTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
static
inline
unsigned
SkAlpha255To256
(
U8CPU
alpha
)
{
SkASSERT
(
SkToU8
(
alpha
)
=
=
alpha
)
;
return
alpha
+
1
;
}
#
define
SkAlphaMul
(
value
alpha256
)
(
(
(
value
)
*
(
alpha256
)
)
>
>
8
)
static
inline
U8CPU
SkUnitScalarClampToByte
(
SkScalar
x
)
{
return
static_cast
<
U8CPU
>
(
SkTPin
(
x
0
.
0f
1
.
0f
)
*
255
+
0
.
5
)
;
}
#
define
SK_A32_BITS
8
#
define
SK_R32_BITS
8
#
define
SK_G32_BITS
8
#
define
SK_B32_BITS
8
#
define
SK_A32_MASK
(
(
1
<
<
SK_A32_BITS
)
-
1
)
#
define
SK_R32_MASK
(
(
1
<
<
SK_R32_BITS
)
-
1
)
#
define
SK_G32_MASK
(
(
1
<
<
SK_G32_BITS
)
-
1
)
#
define
SK_B32_MASK
(
(
1
<
<
SK_B32_BITS
)
-
1
)
#
define
SK_RGBA_R32_SHIFT
0
#
define
SK_RGBA_G32_SHIFT
8
#
define
SK_RGBA_B32_SHIFT
16
#
define
SK_RGBA_A32_SHIFT
24
#
define
SK_BGRA_B32_SHIFT
0
#
define
SK_BGRA_G32_SHIFT
8
#
define
SK_BGRA_R32_SHIFT
16
#
define
SK_BGRA_A32_SHIFT
24
#
if
defined
(
SK_PMCOLOR_IS_RGBA
)
|
|
defined
(
SK_PMCOLOR_IS_BGRA
)
#
error
"
Configure
PMCOLOR
by
setting
SK_R32_SHIFT
.
"
#
endif
#
if
(
SK_A32_SHIFT
=
=
SK_RGBA_A32_SHIFT
&
&
\
SK_R32_SHIFT
=
=
SK_RGBA_R32_SHIFT
&
&
\
SK_G32_SHIFT
=
=
SK_RGBA_G32_SHIFT
&
&
\
SK_B32_SHIFT
=
=
SK_RGBA_B32_SHIFT
)
#
define
SK_PMCOLOR_IS_RGBA
#
elif
(
SK_A32_SHIFT
=
=
SK_BGRA_A32_SHIFT
&
&
\
SK_R32_SHIFT
=
=
SK_BGRA_R32_SHIFT
&
&
\
SK_G32_SHIFT
=
=
SK_BGRA_G32_SHIFT
&
&
\
SK_B32_SHIFT
=
=
SK_BGRA_B32_SHIFT
)
#
define
SK_PMCOLOR_IS_BGRA
#
else
#
error
"
need
32bit
packing
to
be
either
RGBA
or
BGRA
"
#
endif
#
define
SkGetPackedA32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_A32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedR32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_R32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedG32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_G32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedB32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_B32_SHIFT
)
)
>
>
24
)
#
define
SkA32Assert
(
a
)
SkASSERT
(
(
unsigned
)
(
a
)
<
=
SK_A32_MASK
)
#
define
SkR32Assert
(
r
)
SkASSERT
(
(
unsigned
)
(
r
)
<
=
SK_R32_MASK
)
#
define
SkG32Assert
(
g
)
SkASSERT
(
(
unsigned
)
(
g
)
<
=
SK_G32_MASK
)
#
define
SkB32Assert
(
b
)
SkASSERT
(
(
unsigned
)
(
b
)
<
=
SK_B32_MASK
)
static
inline
SkPMColor
SkPackARGB32
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
{
SkA32Assert
(
a
)
;
SkR32Assert
(
r
)
;
SkG32Assert
(
g
)
;
SkB32Assert
(
b
)
;
return
(
a
<
<
SK_A32_SHIFT
)
|
(
r
<
<
SK_R32_SHIFT
)
|
(
g
<
<
SK_G32_SHIFT
)
|
(
b
<
<
SK_B32_SHIFT
)
;
}
static
inline
SkPMColor
SkPremultiplyARGBInline
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
{
SkA32Assert
(
a
)
;
SkR32Assert
(
r
)
;
SkG32Assert
(
g
)
;
SkB32Assert
(
b
)
;
if
(
a
!
=
255
)
{
r
=
SkMulDiv255Round
(
r
a
)
;
g
=
SkMulDiv255Round
(
g
a
)
;
b
=
SkMulDiv255Round
(
b
a
)
;
}
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SK_ALWAYS_INLINE
uint32_t
SkAlphaMulQ
(
uint32_t
c
unsigned
scale
)
{
static
constexpr
uint32_t
kMask
=
0x00FF00FF
;
uint32_t
rb
=
(
(
c
&
kMask
)
*
scale
)
>
>
8
;
uint32_t
ag
=
(
(
c
>
>
8
)
&
kMask
)
*
scale
;
return
(
rb
&
kMask
)
|
(
ag
&
~
kMask
)
;
}
static
inline
SkPMColor
SkPMSrcOver
(
SkPMColor
src
SkPMColor
dst
)
{
uint32_t
scale
=
SkAlpha255To256
(
255
-
SkGetPackedA32
(
src
)
)
;
static
constexpr
uint32_t
kMask
=
0x00FF00FF
;
uint32_t
rb
=
(
(
(
dst
&
kMask
)
*
scale
)
>
>
8
)
&
kMask
;
uint32_t
ag
=
(
(
(
dst
>
>
8
)
&
kMask
)
*
scale
)
&
~
kMask
;
rb
+
=
(
src
&
kMask
)
;
ag
+
=
(
src
&
~
kMask
)
;
return
std
:
:
min
(
rb
&
0x000001FF
0x000000FFU
)
|
std
:
:
min
(
ag
&
0x0001FF00
0x0000FF00U
)
|
std
:
:
min
(
rb
&
0x01FF0000
0x00FF0000U
)
|
(
ag
&
0xFF000000
)
;
}
#
endif
