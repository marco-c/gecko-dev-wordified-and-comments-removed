#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkColorSpacePriv
.
h
"
#
include
"
src
/
core
/
SkColorSpaceXformSteps
.
h
"
#
include
"
src
/
core
/
SkCoreBlitters
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
core
/
SkRasterPipeline
.
h
"
#
include
"
src
/
core
/
SkSpriteBlitter
.
h
"
SkSpriteBlitter
:
:
SkSpriteBlitter
(
const
SkPixmap
&
source
)
:
fSource
(
source
)
{
}
void
SkSpriteBlitter
:
:
setup
(
const
SkPixmap
&
dst
int
left
int
top
const
SkPaint
&
paint
)
{
fDst
=
dst
;
fLeft
=
left
;
fTop
=
top
;
fPaint
=
&
paint
;
}
void
SkSpriteBlitter
:
:
blitH
(
int
x
int
y
int
width
)
{
SkDEBUGFAIL
(
"
how
did
we
get
here
?
"
)
;
this
-
>
blitRect
(
x
y
width
1
)
;
}
void
SkSpriteBlitter
:
:
blitAntiH
(
int
x
int
y
const
SkAlpha
antialias
[
]
const
int16_t
runs
[
]
)
{
SkDEBUGFAIL
(
"
how
did
we
get
here
?
"
)
;
}
void
SkSpriteBlitter
:
:
blitV
(
int
x
int
y
int
height
SkAlpha
alpha
)
{
SkDEBUGFAIL
(
"
how
did
we
get
here
?
"
)
;
INHERITED
:
:
blitV
(
x
y
height
alpha
)
;
}
void
SkSpriteBlitter
:
:
blitMask
(
const
SkMask
&
mask
const
SkIRect
&
clip
)
{
SkDEBUGFAIL
(
"
how
did
we
get
here
?
"
)
;
INHERITED
:
:
blitMask
(
mask
clip
)
;
}
class
SkSpriteBlitter_Memcpy
final
:
public
SkSpriteBlitter
{
public
:
static
bool
Supports
(
const
SkPixmap
&
dst
const
SkPixmap
&
src
const
SkPaint
&
paint
)
{
SkASSERT
(
!
SkColorSpaceXformSteps
:
:
Required
(
src
.
colorSpace
(
)
dst
.
colorSpace
(
)
)
)
;
if
(
dst
.
colorType
(
)
!
=
src
.
colorType
(
)
)
{
return
false
;
}
if
(
paint
.
getMaskFilter
(
)
|
|
paint
.
getColorFilter
(
)
|
|
paint
.
getImageFilter
(
)
)
{
return
false
;
}
if
(
0xFF
!
=
paint
.
getAlpha
(
)
)
{
return
false
;
}
SkBlendMode
mode
=
paint
.
getBlendMode
(
)
;
return
SkBlendMode
:
:
kSrc
=
=
mode
|
|
(
SkBlendMode
:
:
kSrcOver
=
=
mode
&
&
src
.
isOpaque
(
)
)
;
}
SkSpriteBlitter_Memcpy
(
const
SkPixmap
&
src
)
:
INHERITED
(
src
)
{
}
void
blitRect
(
int
x
int
y
int
width
int
height
)
override
{
SkASSERT
(
fDst
.
colorType
(
)
=
=
fSource
.
colorType
(
)
)
;
SkASSERT
(
width
>
0
&
&
height
>
0
)
;
char
*
dst
=
(
char
*
)
fDst
.
writable_addr
(
x
y
)
;
const
char
*
src
=
(
const
char
*
)
fSource
.
addr
(
x
-
fLeft
y
-
fTop
)
;
const
size_t
dstRB
=
fDst
.
rowBytes
(
)
;
const
size_t
srcRB
=
fSource
.
rowBytes
(
)
;
const
size_t
bytesToCopy
=
width
<
<
fSource
.
shiftPerPixel
(
)
;
while
(
height
-
-
>
0
)
{
memcpy
(
dst
src
bytesToCopy
)
;
dst
+
=
dstRB
;
src
+
=
srcRB
;
}
}
private
:
typedef
SkSpriteBlitter
INHERITED
;
}
;
class
SkRasterPipelineSpriteBlitter
:
public
SkSpriteBlitter
{
public
:
SkRasterPipelineSpriteBlitter
(
const
SkPixmap
&
src
SkArenaAlloc
*
alloc
)
:
INHERITED
(
src
)
fAlloc
(
alloc
)
fBlitter
(
nullptr
)
fSrcPtr
{
nullptr
0
}
{
}
void
setup
(
const
SkPixmap
&
dst
int
left
int
top
const
SkPaint
&
paint
)
override
{
fDst
=
dst
;
fLeft
=
left
;
fTop
=
top
;
fPaintColor
=
paint
.
getColor4f
(
)
;
SkRasterPipeline
p
(
fAlloc
)
;
p
.
append_load
(
fSource
.
colorType
(
)
&
fSrcPtr
)
;
if
(
fSource
.
colorType
(
)
=
=
kAlpha_8_SkColorType
)
{
p
.
append_set_rgb
(
fAlloc
fPaintColor
)
;
p
.
append
(
SkRasterPipeline
:
:
premul
)
;
}
if
(
auto
dstCS
=
fDst
.
colorSpace
(
)
)
{
auto
srcCS
=
fSource
.
colorSpace
(
)
;
if
(
!
srcCS
|
|
fSource
.
colorType
(
)
=
=
kAlpha_8_SkColorType
)
{
srcCS
=
sk_srgb_singleton
(
)
;
}
auto
srcAT
=
fSource
.
isOpaque
(
)
?
kOpaque_SkAlphaType
:
kPremul_SkAlphaType
;
fAlloc
-
>
make
<
SkColorSpaceXformSteps
>
(
srcCS
srcAT
dstCS
kPremul_SkAlphaType
)
-
>
apply
(
&
p
fSource
.
colorType
(
)
)
;
}
if
(
fPaintColor
.
fA
!
=
1
.
0f
)
{
p
.
append
(
SkRasterPipeline
:
:
scale_1_float
&
fPaintColor
.
fA
)
;
}
bool
is_opaque
=
fSource
.
isOpaque
(
)
&
&
fPaintColor
.
fA
=
=
1
.
0f
;
fBlitter
=
SkCreateRasterPipelineBlitter
(
fDst
paint
p
is_opaque
fAlloc
)
;
}
void
blitRect
(
int
x
int
y
int
width
int
height
)
override
{
fSrcPtr
.
stride
=
fSource
.
rowBytesAsPixels
(
)
;
size_t
bpp
=
fSource
.
info
(
)
.
bytesPerPixel
(
)
;
fSrcPtr
.
pixels
=
(
char
*
)
fSource
.
addr
(
-
fLeft
+
x
-
fTop
+
y
)
-
bpp
*
x
-
bpp
*
y
*
fSrcPtr
.
stride
;
fBlitter
-
>
blitRect
(
x
y
width
height
)
;
}
private
:
SkArenaAlloc
*
fAlloc
;
SkBlitter
*
fBlitter
;
SkRasterPipeline_MemoryCtx
fSrcPtr
;
SkColor4f
fPaintColor
;
typedef
SkSpriteBlitter
INHERITED
;
}
;
SkBlitter
*
SkBlitter
:
:
ChooseSprite
(
const
SkPixmap
&
dst
const
SkPaint
&
paint
const
SkPixmap
&
source
int
left
int
top
SkArenaAlloc
*
allocator
)
{
SkASSERT
(
allocator
!
=
nullptr
)
;
if
(
source
.
alphaType
(
)
=
=
kUnpremul_SkAlphaType
)
{
return
nullptr
;
}
SkSpriteBlitter
*
blitter
=
nullptr
;
if
(
!
SkColorSpaceXformSteps
:
:
Required
(
source
.
colorSpace
(
)
dst
.
colorSpace
(
)
)
)
{
if
(
!
blitter
&
&
SkSpriteBlitter_Memcpy
:
:
Supports
(
dst
source
paint
)
)
{
blitter
=
allocator
-
>
make
<
SkSpriteBlitter_Memcpy
>
(
source
)
;
}
if
(
!
blitter
)
{
switch
(
dst
.
colorType
(
)
)
{
case
kN32_SkColorType
:
blitter
=
SkSpriteBlitter
:
:
ChooseL32
(
source
paint
allocator
)
;
break
;
case
kRGB_565_SkColorType
:
blitter
=
SkSpriteBlitter
:
:
ChooseL565
(
source
paint
allocator
)
;
break
;
case
kAlpha_8_SkColorType
:
blitter
=
SkSpriteBlitter
:
:
ChooseLA8
(
source
paint
allocator
)
;
break
;
default
:
break
;
}
}
}
if
(
!
blitter
&
&
!
paint
.
getMaskFilter
(
)
)
{
blitter
=
allocator
-
>
make
<
SkRasterPipelineSpriteBlitter
>
(
source
allocator
)
;
}
if
(
blitter
)
{
blitter
-
>
setup
(
dst
left
top
paint
)
;
}
return
blitter
;
}
