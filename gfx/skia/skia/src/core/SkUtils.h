#
ifndef
SkUtils_DEFINED
#
define
SkUtils_DEFINED
#
include
"
SkOpts
.
h
"
#
include
"
SkTypeface
.
h
"
#
include
"
.
.
/
utils
/
SkUTF
.
h
"
static
inline
void
sk_memset16
(
uint16_t
buffer
[
]
uint16_t
value
int
count
)
{
SkOpts
:
:
memset16
(
buffer
value
count
)
;
}
static
inline
void
sk_memset32
(
uint32_t
buffer
[
]
uint32_t
value
int
count
)
{
SkOpts
:
:
memset32
(
buffer
value
count
)
;
}
static
inline
void
sk_memset64
(
uint64_t
buffer
[
]
uint64_t
value
int
count
)
{
SkOpts
:
:
memset64
(
buffer
value
count
)
;
}
SkUnichar
SkUTF8_NextUnichar
(
const
char
*
*
)
;
SkUnichar
SkUTF16_NextUnichar
(
const
uint16_t
*
*
)
;
static
inline
bool
SkUTF16_IsLeadingSurrogate
(
uint16_t
c
)
{
return
(
(
c
)
&
0xFC00
)
=
=
0xD800
;
}
static
inline
bool
SkUTF16_IsTrailingSurrogate
(
uint16_t
c
)
{
return
(
(
c
)
&
0xFC00
)
=
=
0xDC00
;
}
static
inline
int
SkUTFN_CountUnichars
(
SkTypeface
:
:
Encoding
enc
const
void
*
utfN
size_t
bytes
)
{
switch
(
enc
)
{
case
SkTypeface
:
:
kUTF8_Encoding
:
return
SkUTF
:
:
CountUTF8
(
(
const
char
*
)
utfN
bytes
)
;
case
SkTypeface
:
:
kUTF16_Encoding
:
return
SkUTF
:
:
CountUTF16
(
(
const
uint16_t
*
)
utfN
bytes
)
;
case
SkTypeface
:
:
kUTF32_Encoding
:
return
SkUTF
:
:
CountUTF32
(
(
const
int32_t
*
)
utfN
bytes
)
;
default
:
SkDEBUGFAIL
(
"
unknown
text
encoding
"
)
;
return
-
1
;
}
}
static
inline
SkUnichar
SkUTFN_Next
(
SkTypeface
:
:
Encoding
enc
const
void
*
*
ptr
const
void
*
stop
)
{
switch
(
enc
)
{
case
SkTypeface
:
:
kUTF8_Encoding
:
return
SkUTF
:
:
NextUTF8
(
(
const
char
*
*
)
ptr
(
const
char
*
)
stop
)
;
case
SkTypeface
:
:
kUTF16_Encoding
:
return
SkUTF
:
:
NextUTF16
(
(
const
uint16_t
*
*
)
ptr
(
const
uint16_t
*
)
stop
)
;
case
SkTypeface
:
:
kUTF32_Encoding
:
return
SkUTF
:
:
NextUTF32
(
(
const
int32_t
*
*
)
ptr
(
const
int32_t
*
)
stop
)
;
default
:
SkDEBUGFAIL
(
"
unknown
text
encoding
"
)
;
return
-
1
;
}
}
namespace
SkHexadecimalDigits
{
extern
const
char
gUpper
[
16
]
;
extern
const
char
gLower
[
16
]
;
}
#
endif
