#
include
"
.
.
/
private
/
SkLeanWindows
.
h
"
#
include
"
.
.
/
private
/
SkSemaphore
.
h
"
#
if
defined
(
SK_BUILD_FOR_MAC
)
|
|
defined
(
SK_BUILD_FOR_IOS
)
#
include
<
mach
/
mach
.
h
>
struct
SkBaseSemaphore
:
:
OSSemaphore
{
semaphore_t
fSemaphore
;
OSSemaphore
(
)
{
semaphore_create
(
mach_task_self
(
)
&
fSemaphore
SYNC_POLICY_LIFO
0
)
;
}
~
OSSemaphore
(
)
{
semaphore_destroy
(
mach_task_self
(
)
fSemaphore
)
;
}
void
signal
(
int
n
)
{
while
(
n
-
-
>
0
)
{
semaphore_signal
(
fSemaphore
)
;
}
}
void
wait
(
)
{
semaphore_wait
(
fSemaphore
)
;
}
}
;
#
elif
defined
(
SK_BUILD_FOR_WIN32
)
struct
SkBaseSemaphore
:
:
OSSemaphore
{
HANDLE
fSemaphore
;
OSSemaphore
(
)
{
fSemaphore
=
CreateSemaphore
(
nullptr
0
MAXLONG
nullptr
)
;
}
~
OSSemaphore
(
)
{
CloseHandle
(
fSemaphore
)
;
}
void
signal
(
int
n
)
{
ReleaseSemaphore
(
fSemaphore
n
nullptr
)
;
}
void
wait
(
)
{
WaitForSingleObject
(
fSemaphore
INFINITE
)
;
}
}
;
#
else
#
include
<
errno
.
h
>
#
include
<
semaphore
.
h
>
struct
SkBaseSemaphore
:
:
OSSemaphore
{
sem_t
fSemaphore
;
OSSemaphore
(
)
{
sem_init
(
&
fSemaphore
0
0
)
;
}
~
OSSemaphore
(
)
{
sem_destroy
(
&
fSemaphore
)
;
}
void
signal
(
int
n
)
{
while
(
n
-
-
>
0
)
{
sem_post
(
&
fSemaphore
)
;
}
}
void
wait
(
)
{
while
(
sem_wait
(
&
fSemaphore
)
=
=
-
1
&
&
errno
=
=
EINTR
)
;
}
}
;
#
endif
void
SkBaseSemaphore
:
:
osSignal
(
int
n
)
{
fOSSemaphoreOnce
(
[
this
]
{
fOSSemaphore
=
new
OSSemaphore
;
}
)
;
fOSSemaphore
-
>
signal
(
n
)
;
}
void
SkBaseSemaphore
:
:
osWait
(
)
{
fOSSemaphoreOnce
(
[
this
]
{
fOSSemaphore
=
new
OSSemaphore
;
}
)
;
fOSSemaphore
-
>
wait
(
)
;
}
void
SkBaseSemaphore
:
:
cleanup
(
)
{
delete
fOSSemaphore
;
}
