#
ifndef
SkPathPriv_DEFINED
#
define
SkPathPriv_DEFINED
#
include
"
SkPath
.
h
"
#
define
SK_TREAT_COLINEAR_DIAGONAL_POINTS_AS_CONCAVE
0
#
if
SK_TREAT_COLINEAR_DIAGONAL_POINTS_AS_CONCAVE
#
define
COLINEAR_DIAGONAL_CONVEXITY
kConcave_Convexity
#
else
#
define
COLINEAR_DIAGONAL_CONVEXITY
kConvex_Convexity
#
endif
class
SkPathPriv
{
public
:
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
static
const
int
kPathRefGenIDBitCnt
=
30
;
#
else
static
const
int
kPathRefGenIDBitCnt
=
32
;
#
endif
enum
FirstDirection
:
int
{
kCW_FirstDirection
kCCW_FirstDirection
kUnknown_FirstDirection
}
;
static
FirstDirection
AsFirstDirection
(
SkPath
:
:
Direction
dir
)
{
return
(
FirstDirection
)
dir
;
}
static
FirstDirection
OppositeFirstDirection
(
FirstDirection
dir
)
{
static
const
FirstDirection
gOppositeDir
[
]
=
{
kCCW_FirstDirection
kCW_FirstDirection
kUnknown_FirstDirection
}
;
return
gOppositeDir
[
dir
]
;
}
static
bool
CheapComputeFirstDirection
(
const
SkPath
&
FirstDirection
*
dir
)
;
static
bool
CheapIsFirstDirection
(
const
SkPath
&
path
FirstDirection
dir
)
{
FirstDirection
computedDir
=
kUnknown_FirstDirection
;
(
void
)
CheapComputeFirstDirection
(
path
&
computedDir
)
;
return
computedDir
=
=
dir
;
}
static
bool
IsClosedSingleContour
(
const
SkPath
&
path
)
{
int
verbCount
=
path
.
countVerbs
(
)
;
if
(
verbCount
=
=
0
)
return
false
;
int
moveCount
=
0
;
auto
verbs
=
path
.
fPathRef
-
>
verbs
(
)
;
for
(
int
i
=
0
;
i
<
verbCount
;
i
+
+
)
{
switch
(
verbs
[
~
i
]
)
{
case
SkPath
:
:
Verb
:
:
kMove_Verb
:
moveCount
+
=
1
;
if
(
moveCount
>
1
)
{
return
false
;
}
break
;
case
SkPath
:
:
Verb
:
:
kClose_Verb
:
if
(
i
=
=
verbCount
-
1
)
{
return
true
;
}
return
false
;
default
:
break
;
}
}
return
false
;
}
static
void
AddGenIDChangeListener
(
const
SkPath
&
path
sk_sp
<
SkPathRef
:
:
GenIDChangeListener
>
listener
)
{
path
.
fPathRef
-
>
addGenIDChangeListener
(
std
:
:
move
(
listener
)
)
;
}
static
bool
IsSimpleClosedRect
(
const
SkPath
&
path
SkRect
*
rect
SkPath
:
:
Direction
*
direction
unsigned
*
start
)
;
static
void
CreateDrawArcPath
(
SkPath
*
path
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
static
bool
DrawArcIsConvex
(
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
struct
Verbs
{
public
:
Verbs
(
const
SkPath
&
path
)
:
fPathRef
(
path
.
fPathRef
.
get
(
)
)
{
}
struct
Iter
{
void
operator
+
+
(
)
{
-
-
fVerb
;
}
bool
operator
!
=
(
const
Iter
&
b
)
{
return
fVerb
!
=
b
.
fVerb
;
}
SkPath
:
:
Verb
operator
*
(
)
{
return
static_cast
<
SkPath
:
:
Verb
>
(
*
fVerb
)
;
}
const
uint8_t
*
fVerb
;
}
;
Iter
begin
(
)
{
return
Iter
{
fPathRef
-
>
verbs
(
)
-
1
}
;
}
Iter
end
(
)
{
return
Iter
{
fPathRef
-
>
verbs
(
)
-
fPathRef
-
>
countVerbs
(
)
-
1
}
;
}
private
:
Verbs
(
const
Verbs
&
)
=
delete
;
Verbs
&
operator
=
(
const
Verbs
&
)
=
delete
;
SkPathRef
*
fPathRef
;
}
;
static
const
uint8_t
*
VerbData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
verbsMemBegin
(
)
;
}
static
const
SkPoint
*
PointData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
points
(
)
;
}
static
int
ConicWeightCnt
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
countWeights
(
)
;
}
static
const
SkScalar
*
ConicWeightData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
conicWeights
(
)
;
}
#
ifndef
SK_LEGACY_PATH_CONVEXITY
static
bool
IsConvex
(
const
SkPoint
pts
[
]
int
count
)
;
#
endif
static
bool
TestingOnly_unique
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
unique
(
)
;
}
static
bool
IsOval
(
const
SkPath
&
path
SkRect
*
rect
SkPath
:
:
Direction
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isOval
(
rect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
}
return
result
;
}
static
bool
IsRRect
(
const
SkPath
&
path
SkRRect
*
rrect
SkPath
:
:
Direction
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isRRect
(
rrect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
}
return
result
;
}
static
bool
IsBadForDAA
(
const
SkPath
&
path
)
{
return
path
.
fIsBadForDAA
;
}
static
void
SetIsBadForDAA
(
SkPath
&
path
bool
isBadForDAA
)
{
path
.
fIsBadForDAA
=
isBadForDAA
;
}
static
bool
TooBigForMath
(
const
SkRect
&
bounds
)
{
constexpr
SkScalar
scale_down_to_allow_for_small_multiplies
=
0
.
25f
;
constexpr
SkScalar
max
=
SK_ScalarMax
*
scale_down_to_allow_for_small_multiplies
;
return
!
(
bounds
.
fLeft
>
=
-
max
&
&
bounds
.
fTop
>
=
-
max
&
&
bounds
.
fRight
<
=
max
&
&
bounds
.
fBottom
<
=
max
)
;
}
static
bool
TooBigForMath
(
const
SkPath
&
path
)
{
return
TooBigForMath
(
path
.
getBounds
(
)
)
;
}
static
int
PtsInIter
(
unsigned
verb
)
{
static
const
uint8_t
gPtsInVerb
[
]
=
{
1
2
3
3
4
0
0
}
;
SkASSERT
(
verb
<
SK_ARRAY_COUNT
(
gPtsInVerb
)
)
;
return
gPtsInVerb
[
verb
]
;
}
static
bool
IsAxisAligned
(
const
SkPath
&
path
)
{
SkRect
tmp
;
return
(
path
.
fPathRef
-
>
fIsRRect
|
path
.
fPathRef
-
>
fIsOval
)
|
|
path
.
isRect
(
&
tmp
)
;
}
}
;
#
endif
