#
ifndef
SkPathPriv_DEFINED
#
define
SkPathPriv_DEFINED
#
include
"
SkPath
.
h
"
class
SkPathPriv
{
public
:
enum
FirstDirection
{
kCW_FirstDirection
kCCW_FirstDirection
kUnknown_FirstDirection
}
;
static
FirstDirection
AsFirstDirection
(
SkPath
:
:
Direction
dir
)
{
return
(
FirstDirection
)
dir
;
}
static
FirstDirection
OppositeFirstDirection
(
FirstDirection
dir
)
{
static
const
FirstDirection
gOppositeDir
[
]
=
{
kCCW_FirstDirection
kCW_FirstDirection
kUnknown_FirstDirection
}
;
return
gOppositeDir
[
dir
]
;
}
static
bool
CheapComputeFirstDirection
(
const
SkPath
&
FirstDirection
*
dir
)
;
static
bool
CheapIsFirstDirection
(
const
SkPath
&
path
FirstDirection
dir
)
{
FirstDirection
computedDir
=
kUnknown_FirstDirection
;
(
void
)
CheapComputeFirstDirection
(
path
&
computedDir
)
;
return
computedDir
=
=
dir
;
}
static
bool
IsClosedSingleContour
(
const
SkPath
&
path
)
{
int
verbCount
=
path
.
countVerbs
(
)
;
if
(
verbCount
=
=
0
)
return
false
;
int
moveCount
=
0
;
auto
verbs
=
path
.
fPathRef
-
>
verbs
(
)
;
for
(
int
i
=
0
;
i
<
verbCount
;
i
+
+
)
{
switch
(
verbs
[
~
i
]
)
{
case
SkPath
:
:
Verb
:
:
kMove_Verb
:
moveCount
+
=
1
;
if
(
moveCount
>
1
)
{
return
false
;
}
break
;
case
SkPath
:
:
Verb
:
:
kClose_Verb
:
if
(
i
=
=
verbCount
-
1
)
{
return
true
;
}
return
false
;
default
:
break
;
}
}
return
false
;
}
static
void
AddGenIDChangeListener
(
const
SkPath
&
path
SkPathRef
:
:
GenIDChangeListener
*
listener
)
{
path
.
fPathRef
-
>
addGenIDChangeListener
(
listener
)
;
}
}
;
#
endif
