#
ifndef
SkPathPriv_DEFINED
#
define
SkPathPriv_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
class
SkPathPriv
{
public
:
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
static
const
int
kPathRefGenIDBitCnt
=
30
;
#
else
static
const
int
kPathRefGenIDBitCnt
=
32
;
#
endif
enum
FirstDirection
:
int
{
kCW_FirstDirection
kCCW_FirstDirection
kUnknown_FirstDirection
}
;
static
FirstDirection
AsFirstDirection
(
SkPath
:
:
Direction
dir
)
{
return
(
FirstDirection
)
dir
;
}
static
FirstDirection
OppositeFirstDirection
(
FirstDirection
dir
)
{
static
const
FirstDirection
gOppositeDir
[
]
=
{
kCCW_FirstDirection
kCW_FirstDirection
kUnknown_FirstDirection
}
;
return
gOppositeDir
[
dir
]
;
}
static
bool
CheapComputeFirstDirection
(
const
SkPath
&
FirstDirection
*
dir
)
;
static
bool
CheapIsFirstDirection
(
const
SkPath
&
path
FirstDirection
dir
)
{
FirstDirection
computedDir
=
kUnknown_FirstDirection
;
(
void
)
CheapComputeFirstDirection
(
path
&
computedDir
)
;
return
computedDir
=
=
dir
;
}
static
bool
IsClosedSingleContour
(
const
SkPath
&
path
)
{
int
verbCount
=
path
.
countVerbs
(
)
;
if
(
verbCount
=
=
0
)
return
false
;
int
moveCount
=
0
;
auto
verbs
=
path
.
fPathRef
-
>
verbsBegin
(
)
;
for
(
int
i
=
0
;
i
<
verbCount
;
i
+
+
)
{
switch
(
verbs
[
i
]
)
{
case
SkPath
:
:
Verb
:
:
kMove_Verb
:
moveCount
+
=
1
;
if
(
moveCount
>
1
)
{
return
false
;
}
break
;
case
SkPath
:
:
Verb
:
:
kClose_Verb
:
if
(
i
=
=
verbCount
-
1
)
{
return
true
;
}
return
false
;
default
:
break
;
}
}
return
false
;
}
static
void
AddGenIDChangeListener
(
const
SkPath
&
path
sk_sp
<
SkPathRef
:
:
GenIDChangeListener
>
listener
)
{
path
.
fPathRef
-
>
addGenIDChangeListener
(
std
:
:
move
(
listener
)
)
;
}
static
bool
IsSimpleClosedRect
(
const
SkPath
&
path
SkRect
*
rect
SkPath
:
:
Direction
*
direction
unsigned
*
start
)
;
static
void
CreateDrawArcPath
(
SkPath
*
path
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
static
bool
DrawArcIsConvex
(
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
struct
Verbs
{
public
:
Verbs
(
const
SkPath
&
path
)
:
fPathRef
(
path
.
fPathRef
.
get
(
)
)
{
}
struct
Iter
{
void
operator
+
+
(
)
{
fVerb
+
+
;
}
bool
operator
!
=
(
const
Iter
&
b
)
{
return
fVerb
!
=
b
.
fVerb
;
}
SkPath
:
:
Verb
operator
*
(
)
{
return
static_cast
<
SkPath
:
:
Verb
>
(
*
fVerb
)
;
}
const
uint8_t
*
fVerb
;
}
;
Iter
begin
(
)
{
return
Iter
{
fPathRef
-
>
verbsBegin
(
)
}
;
}
Iter
end
(
)
{
return
Iter
{
fPathRef
-
>
verbsEnd
(
)
}
;
}
private
:
Verbs
(
const
Verbs
&
)
=
delete
;
Verbs
&
operator
=
(
const
Verbs
&
)
=
delete
;
SkPathRef
*
fPathRef
;
}
;
static
const
uint8_t
*
VerbData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
verbsBegin
(
)
;
}
static
const
SkPoint
*
PointData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
points
(
)
;
}
static
int
ConicWeightCnt
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
countWeights
(
)
;
}
static
const
SkScalar
*
ConicWeightData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
conicWeights
(
)
;
}
#
ifndef
SK_LEGACY_PATH_CONVEXITY
static
bool
IsConvex
(
const
SkPoint
pts
[
]
int
count
)
;
#
endif
static
bool
TestingOnly_unique
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
unique
(
)
;
}
static
bool
IsOval
(
const
SkPath
&
path
SkRect
*
rect
SkPath
:
:
Direction
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isOval
(
rect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
}
return
result
;
}
static
bool
IsRRect
(
const
SkPath
&
path
SkRRect
*
rrect
SkPath
:
:
Direction
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isRRect
(
rrect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPath
:
:
kCCW_Direction
:
SkPath
:
:
kCW_Direction
;
}
return
result
;
}
static
bool
TooBigForMath
(
const
SkRect
&
bounds
)
{
constexpr
SkScalar
scale_down_to_allow_for_small_multiplies
=
0
.
25f
;
constexpr
SkScalar
max
=
SK_ScalarMax
*
scale_down_to_allow_for_small_multiplies
;
return
!
(
bounds
.
fLeft
>
=
-
max
&
&
bounds
.
fTop
>
=
-
max
&
&
bounds
.
fRight
<
=
max
&
&
bounds
.
fBottom
<
=
max
)
;
}
static
bool
TooBigForMath
(
const
SkPath
&
path
)
{
return
TooBigForMath
(
path
.
getBounds
(
)
)
;
}
static
int
PtsInIter
(
unsigned
verb
)
{
static
const
uint8_t
gPtsInVerb
[
]
=
{
1
2
3
3
4
0
0
}
;
SkASSERT
(
verb
<
SK_ARRAY_COUNT
(
gPtsInVerb
)
)
;
return
gPtsInVerb
[
verb
]
;
}
static
bool
IsAxisAligned
(
const
SkPath
&
path
)
{
SkRect
tmp
;
return
(
path
.
fPathRef
-
>
fIsRRect
|
path
.
fPathRef
-
>
fIsOval
)
|
|
path
.
isRect
(
&
tmp
)
;
}
static
bool
AllPointsEq
(
const
SkPoint
pts
[
]
int
count
)
{
for
(
int
i
=
1
;
i
<
count
;
+
+
i
)
{
if
(
pts
[
0
]
!
=
pts
[
i
]
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsRectContour
(
const
SkPath
&
bool
allowPartial
int
*
currVerb
const
SkPoint
*
*
ptsPtr
bool
*
isClosed
SkPath
:
:
Direction
*
direction
SkRect
*
rect
)
;
static
bool
IsNestedFillRects
(
const
SkPath
&
SkRect
rect
[
2
]
SkPath
:
:
Direction
dirs
[
2
]
=
nullptr
)
;
}
;
class
SkPathEdgeIter
{
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbsStop
;
const
SkPoint
*
fPts
;
const
SkPoint
*
fMoveToPtr
;
const
SkScalar
*
fConicWeights
;
SkPoint
fScratch
[
2
]
;
bool
fNeedsCloseLine
;
SkDEBUGCODE
(
bool
fIsConic
)
;
enum
{
kIllegalEdgeValue
=
99
}
;
public
:
SkPathEdgeIter
(
const
SkPath
&
path
)
;
SkScalar
conicWeight
(
)
const
{
SkASSERT
(
fIsConic
)
;
return
*
fConicWeights
;
}
enum
class
Edge
{
kLine
=
SkPath
:
:
kLine_Verb
kQuad
=
SkPath
:
:
kQuad_Verb
kConic
=
SkPath
:
:
kConic_Verb
kCubic
=
SkPath
:
:
kCubic_Verb
}
;
static
SkPath
:
:
Verb
EdgeToVerb
(
Edge
e
)
{
return
SkPath
:
:
Verb
(
e
)
;
}
struct
Result
{
const
SkPoint
*
fPts
;
Edge
fEdge
;
MOZ_IMPLICIT
operator
bool
(
)
{
return
fPts
!
=
nullptr
;
}
}
;
Result
next
(
)
{
auto
closeline
=
[
&
]
(
)
{
fScratch
[
0
]
=
fPts
[
-
1
]
;
fScratch
[
1
]
=
*
fMoveToPtr
;
fNeedsCloseLine
=
false
;
return
Result
{
fScratch
Edge
:
:
kLine
}
;
}
;
for
(
;
;
)
{
SkASSERT
(
fVerbs
<
=
fVerbsStop
)
;
if
(
fVerbs
=
=
fVerbsStop
)
{
return
fNeedsCloseLine
?
closeline
(
)
:
Result
{
nullptr
Edge
(
kIllegalEdgeValue
)
}
;
}
SkDEBUGCODE
(
fIsConic
=
false
;
)
const
auto
v
=
*
fVerbs
+
+
;
switch
(
v
)
{
case
SkPath
:
:
kMove_Verb
:
{
if
(
fNeedsCloseLine
)
{
auto
res
=
closeline
(
)
;
fMoveToPtr
=
fPts
+
+
;
return
res
;
}
fMoveToPtr
=
fPts
+
+
;
}
break
;
case
SkPath
:
:
kClose_Verb
:
if
(
fNeedsCloseLine
)
return
closeline
(
)
;
break
;
default
:
{
const
int
pts_count
=
(
v
+
2
)
/
2
cws_count
=
(
v
&
(
v
-
1
)
)
/
2
;
SkASSERT
(
pts_count
=
=
SkPathPriv
:
:
PtsInIter
(
v
)
-
1
)
;
fNeedsCloseLine
=
true
;
fPts
+
=
pts_count
;
fConicWeights
+
=
cws_count
;
SkDEBUGCODE
(
fIsConic
=
(
v
=
=
SkPath
:
:
kConic_Verb
)
;
)
SkASSERT
(
fIsConic
=
=
(
cws_count
>
0
)
)
;
return
{
&
fPts
[
-
(
pts_count
+
1
)
]
Edge
(
v
)
}
;
}
}
}
}
}
;
#
endif
