#
ifndef
SkPathPriv_DEFINED
#
define
SkPathPriv_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPathBuilder
.
h
"
#
include
"
include
/
core
/
SkPathTypes
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
"
include
/
private
/
SkPathRef
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
src
/
core
/
SkPathEnums
.
h
"
#
include
<
cstdint
>
#
include
<
iterator
>
#
include
<
utility
>
class
SkMatrix
;
class
SkRRect
;
static_assert
(
0
=
=
static_cast
<
int
>
(
SkPathFillType
:
:
kWinding
)
"
fill_type_mismatch
"
)
;
static_assert
(
1
=
=
static_cast
<
int
>
(
SkPathFillType
:
:
kEvenOdd
)
"
fill_type_mismatch
"
)
;
static_assert
(
2
=
=
static_cast
<
int
>
(
SkPathFillType
:
:
kInverseWinding
)
"
fill_type_mismatch
"
)
;
static_assert
(
3
=
=
static_cast
<
int
>
(
SkPathFillType
:
:
kInverseEvenOdd
)
"
fill_type_mismatch
"
)
;
class
SkPathPriv
{
public
:
inline
static
constexpr
SkScalar
kW0PlaneDistance
=
1
.
f
/
(
1
<
<
14
)
;
static
SkPathFirstDirection
AsFirstDirection
(
SkPathDirection
dir
)
{
return
(
SkPathFirstDirection
)
dir
;
}
static
SkPathFirstDirection
OppositeFirstDirection
(
SkPathFirstDirection
dir
)
{
static
const
SkPathFirstDirection
gOppositeDir
[
]
=
{
SkPathFirstDirection
:
:
kCCW
SkPathFirstDirection
:
:
kCW
SkPathFirstDirection
:
:
kUnknown
}
;
return
gOppositeDir
[
(
unsigned
)
dir
]
;
}
static
SkPathFirstDirection
ComputeFirstDirection
(
const
SkPath
&
)
;
static
bool
IsClosedSingleContour
(
const
SkPath
&
path
)
{
int
verbCount
=
path
.
countVerbs
(
)
;
if
(
verbCount
=
=
0
)
return
false
;
int
moveCount
=
0
;
auto
verbs
=
path
.
fPathRef
-
>
verbsBegin
(
)
;
for
(
int
i
=
0
;
i
<
verbCount
;
i
+
+
)
{
switch
(
verbs
[
i
]
)
{
case
SkPath
:
:
Verb
:
:
kMove_Verb
:
moveCount
+
=
1
;
if
(
moveCount
>
1
)
{
return
false
;
}
break
;
case
SkPath
:
:
Verb
:
:
kClose_Verb
:
if
(
i
=
=
verbCount
-
1
)
{
return
true
;
}
return
false
;
default
:
break
;
}
}
return
false
;
}
static
int
LeadingMoveToCount
(
const
SkPath
&
path
)
{
int
verbCount
=
path
.
countVerbs
(
)
;
auto
verbs
=
path
.
fPathRef
-
>
verbsBegin
(
)
;
for
(
int
i
=
0
;
i
<
verbCount
;
i
+
+
)
{
if
(
verbs
[
i
]
!
=
SkPath
:
:
Verb
:
:
kMove_Verb
)
{
return
i
;
}
}
return
verbCount
;
}
static
void
AddGenIDChangeListener
(
const
SkPath
&
path
sk_sp
<
SkIDChangeListener
>
listener
)
{
path
.
fPathRef
-
>
addGenIDChangeListener
(
std
:
:
move
(
listener
)
)
;
}
static
bool
IsSimpleRect
(
const
SkPath
&
path
bool
isSimpleFill
SkRect
*
rect
SkPathDirection
*
direction
unsigned
*
start
)
;
static
void
CreateDrawArcPath
(
SkPath
*
path
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
static
bool
DrawArcIsConvex
(
SkScalar
sweepAngle
bool
useCenter
bool
isFillNoPathEffect
)
;
static
void
ShrinkToFit
(
SkPath
*
path
)
{
path
-
>
shrinkToFit
(
)
;
}
struct
Verbs
{
public
:
Verbs
(
const
SkPath
&
path
)
:
fPathRef
(
path
.
fPathRef
.
get
(
)
)
{
}
struct
Iter
{
void
operator
+
+
(
)
{
fVerb
+
+
;
}
bool
operator
!
=
(
const
Iter
&
b
)
{
return
fVerb
!
=
b
.
fVerb
;
}
SkPath
:
:
Verb
operator
*
(
)
{
return
static_cast
<
SkPath
:
:
Verb
>
(
*
fVerb
)
;
}
const
uint8_t
*
fVerb
;
}
;
Iter
begin
(
)
{
return
Iter
{
fPathRef
-
>
verbsBegin
(
)
}
;
}
Iter
end
(
)
{
return
Iter
{
fPathRef
-
>
verbsEnd
(
)
}
;
}
private
:
Verbs
(
const
Verbs
&
)
=
delete
;
Verbs
&
operator
=
(
const
Verbs
&
)
=
delete
;
SkPathRef
*
fPathRef
;
}
;
using
RangeIter
=
SkPath
:
:
RangeIter
;
struct
Iterate
{
public
:
Iterate
(
const
SkPath
&
path
)
:
Iterate
(
path
.
fPathRef
-
>
verbsBegin
(
)
(
!
path
.
isFinite
(
)
)
?
path
.
fPathRef
-
>
verbsBegin
(
)
:
path
.
fPathRef
-
>
verbsEnd
(
)
path
.
fPathRef
-
>
points
(
)
path
.
fPathRef
-
>
conicWeights
(
)
)
{
}
Iterate
(
const
uint8_t
*
verbsBegin
const
uint8_t
*
verbsEnd
const
SkPoint
*
points
const
SkScalar
*
weights
)
:
fVerbsBegin
(
verbsBegin
)
fVerbsEnd
(
verbsEnd
)
fPoints
(
points
)
fWeights
(
weights
)
{
}
SkPath
:
:
RangeIter
begin
(
)
{
return
{
fVerbsBegin
fPoints
fWeights
}
;
}
SkPath
:
:
RangeIter
end
(
)
{
return
{
fVerbsEnd
nullptr
nullptr
}
;
}
private
:
const
uint8_t
*
fVerbsBegin
;
const
uint8_t
*
fVerbsEnd
;
const
SkPoint
*
fPoints
;
const
SkScalar
*
fWeights
;
}
;
static
const
uint8_t
*
VerbData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
verbsBegin
(
)
;
}
static
const
SkPoint
*
PointData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
points
(
)
;
}
static
int
ConicWeightCnt
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
countWeights
(
)
;
}
static
const
SkScalar
*
ConicWeightData
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
conicWeights
(
)
;
}
static
bool
TestingOnly_unique
(
const
SkPath
&
path
)
{
return
path
.
fPathRef
-
>
unique
(
)
;
}
static
bool
HasComputedBounds
(
const
SkPath
&
path
)
{
return
path
.
hasComputedBounds
(
)
;
}
static
bool
IsOval
(
const
SkPath
&
path
SkRect
*
rect
SkPathDirection
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isOval
(
rect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPathDirection
:
:
kCCW
:
SkPathDirection
:
:
kCW
;
}
return
result
;
}
static
bool
IsRRect
(
const
SkPath
&
path
SkRRect
*
rrect
SkPathDirection
*
dir
unsigned
*
start
)
{
bool
isCCW
=
false
;
bool
result
=
path
.
fPathRef
-
>
isRRect
(
rrect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
SkPathDirection
:
:
kCCW
:
SkPathDirection
:
:
kCW
;
}
return
result
;
}
static
bool
TooBigForMath
(
const
SkRect
&
bounds
)
{
constexpr
SkScalar
scale_down_to_allow_for_small_multiplies
=
0
.
25f
;
constexpr
SkScalar
max
=
SK_ScalarMax
*
scale_down_to_allow_for_small_multiplies
;
return
!
(
bounds
.
fLeft
>
=
-
max
&
&
bounds
.
fTop
>
=
-
max
&
&
bounds
.
fRight
<
=
max
&
&
bounds
.
fBottom
<
=
max
)
;
}
static
bool
TooBigForMath
(
const
SkPath
&
path
)
{
return
TooBigForMath
(
path
.
getBounds
(
)
)
;
}
static
int
PtsInIter
(
unsigned
verb
)
{
static
const
uint8_t
gPtsInVerb
[
]
=
{
1
2
3
3
4
0
0
}
;
SkASSERT
(
verb
<
std
:
:
size
(
gPtsInVerb
)
)
;
return
gPtsInVerb
[
verb
]
;
}
static
int
PtsInVerb
(
unsigned
verb
)
{
static
const
uint8_t
gPtsInVerb
[
]
=
{
1
1
2
2
3
0
0
}
;
SkASSERT
(
verb
<
std
:
:
size
(
gPtsInVerb
)
)
;
return
gPtsInVerb
[
verb
]
;
}
static
bool
IsAxisAligned
(
const
SkPath
&
path
)
;
static
bool
AllPointsEq
(
const
SkPoint
pts
[
]
int
count
)
{
for
(
int
i
=
1
;
i
<
count
;
+
+
i
)
{
if
(
pts
[
0
]
!
=
pts
[
i
]
)
{
return
false
;
}
}
return
true
;
}
static
int
LastMoveToIndex
(
const
SkPath
&
path
)
{
return
path
.
fLastMoveToIndex
;
}
static
bool
IsRectContour
(
const
SkPath
&
bool
allowPartial
int
*
currVerb
const
SkPoint
*
*
ptsPtr
bool
*
isClosed
SkPathDirection
*
direction
SkRect
*
rect
)
;
static
bool
IsNestedFillRects
(
const
SkPath
&
SkRect
rect
[
2
]
SkPathDirection
dirs
[
2
]
=
nullptr
)
;
static
bool
IsInverseFillType
(
SkPathFillType
fill
)
{
return
(
static_cast
<
int
>
(
fill
)
&
2
)
!
=
0
;
}
static
SkPathFillType
ConvertToNonInverseFillType
(
SkPathFillType
fill
)
{
return
(
SkPathFillType
)
(
static_cast
<
int
>
(
fill
)
&
1
)
;
}
static
bool
PerspectiveClip
(
const
SkPath
&
src
const
SkMatrix
&
SkPath
*
result
)
;
static
int
GenIDChangeListenersCount
(
const
SkPath
&
)
;
static
void
UpdatePathPoint
(
SkPath
*
path
int
index
const
SkPoint
&
pt
)
{
SkASSERT
(
index
<
path
-
>
countPoints
(
)
)
;
SkPathRef
:
:
Editor
ed
(
&
path
-
>
fPathRef
)
;
ed
.
writablePoints
(
)
[
index
]
=
pt
;
path
-
>
dirtyAfterEdit
(
)
;
}
static
SkPathConvexity
GetConvexity
(
const
SkPath
&
path
)
{
return
path
.
getConvexity
(
)
;
}
static
SkPathConvexity
GetConvexityOrUnknown
(
const
SkPath
&
path
)
{
return
path
.
getConvexityOrUnknown
(
)
;
}
static
void
SetConvexity
(
const
SkPath
&
path
SkPathConvexity
c
)
{
path
.
setConvexity
(
c
)
;
}
static
void
ForceComputeConvexity
(
const
SkPath
&
path
)
{
path
.
setConvexity
(
SkPathConvexity
:
:
kUnknown
)
;
(
void
)
path
.
isConvex
(
)
;
}
static
void
ReverseAddPath
(
SkPathBuilder
*
builder
const
SkPath
&
reverseMe
)
{
builder
-
>
privateReverseAddPath
(
reverseMe
)
;
}
static
SkPath
MakePath
(
const
SkPathVerbAnalysis
&
analysis
const
SkPoint
points
[
]
const
uint8_t
verbs
[
]
int
verbCount
const
SkScalar
conics
[
]
SkPathFillType
fillType
bool
isVolatile
)
{
return
SkPath
:
:
MakeInternal
(
analysis
points
verbs
verbCount
conics
fillType
isVolatile
)
;
}
}
;
class
SkPathEdgeIter
{
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbsStop
;
const
SkPoint
*
fPts
;
const
SkPoint
*
fMoveToPtr
;
const
SkScalar
*
fConicWeights
;
SkPoint
fScratch
[
2
]
;
bool
fNeedsCloseLine
;
bool
fNextIsNewContour
;
SkDEBUGCODE
(
bool
fIsConic
;
)
enum
{
kIllegalEdgeValue
=
99
}
;
public
:
SkPathEdgeIter
(
const
SkPath
&
path
)
;
SkScalar
conicWeight
(
)
const
{
SkASSERT
(
fIsConic
)
;
return
*
fConicWeights
;
}
enum
class
Edge
{
kLine
=
SkPath
:
:
kLine_Verb
kQuad
=
SkPath
:
:
kQuad_Verb
kConic
=
SkPath
:
:
kConic_Verb
kCubic
=
SkPath
:
:
kCubic_Verb
}
;
static
SkPath
:
:
Verb
EdgeToVerb
(
Edge
e
)
{
return
SkPath
:
:
Verb
(
e
)
;
}
struct
Result
{
const
SkPoint
*
fPts
;
Edge
fEdge
;
bool
fIsNewContour
;
explicit
operator
bool
(
)
{
return
fPts
!
=
nullptr
;
}
}
;
Result
next
(
)
{
auto
closeline
=
[
&
]
(
)
{
fScratch
[
0
]
=
fPts
[
-
1
]
;
fScratch
[
1
]
=
*
fMoveToPtr
;
fNeedsCloseLine
=
false
;
fNextIsNewContour
=
true
;
return
Result
{
fScratch
Edge
:
:
kLine
false
}
;
}
;
for
(
;
;
)
{
SkASSERT
(
fVerbs
<
=
fVerbsStop
)
;
if
(
fVerbs
=
=
fVerbsStop
)
{
return
fNeedsCloseLine
?
closeline
(
)
:
Result
{
nullptr
Edge
(
kIllegalEdgeValue
)
false
}
;
}
SkDEBUGCODE
(
fIsConic
=
false
;
)
const
auto
v
=
*
fVerbs
+
+
;
switch
(
v
)
{
case
SkPath
:
:
kMove_Verb
:
{
if
(
fNeedsCloseLine
)
{
auto
res
=
closeline
(
)
;
fMoveToPtr
=
fPts
+
+
;
return
res
;
}
fMoveToPtr
=
fPts
+
+
;
fNextIsNewContour
=
true
;
}
break
;
case
SkPath
:
:
kClose_Verb
:
if
(
fNeedsCloseLine
)
return
closeline
(
)
;
break
;
default
:
{
const
int
pts_count
=
(
v
+
2
)
/
2
cws_count
=
(
v
&
(
v
-
1
)
)
/
2
;
SkASSERT
(
pts_count
=
=
SkPathPriv
:
:
PtsInIter
(
v
)
-
1
)
;
fNeedsCloseLine
=
true
;
fPts
+
=
pts_count
;
fConicWeights
+
=
cws_count
;
SkDEBUGCODE
(
fIsConic
=
(
v
=
=
SkPath
:
:
kConic_Verb
)
;
)
SkASSERT
(
fIsConic
=
=
(
cws_count
>
0
)
)
;
bool
isNewContour
=
fNextIsNewContour
;
fNextIsNewContour
=
false
;
return
{
&
fPts
[
-
(
pts_count
+
1
)
]
Edge
(
v
)
isNewContour
}
;
}
}
}
}
}
;
#
endif
