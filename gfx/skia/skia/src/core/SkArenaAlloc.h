#
ifndef
SkFixedAlloc_DEFINED
#
define
SkFixedAlloc_DEFINED
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTFitsIn
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
cstddef
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
class
SkArenaAlloc
{
public
:
SkArenaAlloc
(
char
*
block
size_t
size
size_t
extraSize
=
0
)
;
template
<
size_t
kSize
>
SkArenaAlloc
(
char
(
&
block
)
[
kSize
]
size_t
extraSize
=
kSize
)
:
SkArenaAlloc
(
block
kSize
extraSize
)
{
}
SkArenaAlloc
(
size_t
extraSize
)
:
SkArenaAlloc
(
nullptr
0
extraSize
)
{
}
~
SkArenaAlloc
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
T
*
make
(
Args
&
&
.
.
.
args
)
{
uint32_t
size
=
SkTo
<
uint32_t
>
(
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkTo
<
uint32_t
>
(
alignof
(
T
)
)
;
char
*
objStart
;
if
(
skstd
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
size
alignment
)
;
fCursor
=
objStart
+
size
;
}
else
{
objStart
=
this
-
>
allocObjectWithFooter
(
size
+
sizeof
(
Footer
)
alignment
)
;
uint32_t
padding
=
SkTo
<
uint32_t
>
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
size
;
FooterAction
*
releaser
=
[
]
(
char
*
objEnd
)
{
char
*
objStart
=
objEnd
-
(
sizeof
(
T
)
+
sizeof
(
Footer
)
)
;
(
(
T
*
)
objStart
)
-
>
~
T
(
)
;
return
objStart
;
}
;
this
-
>
installFooter
(
releaser
padding
)
;
}
return
new
(
objStart
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
sk_sp
<
T
>
makeSkSp
(
Args
&
&
.
.
.
args
)
{
SkASSERT
(
SkTFitsIn
<
uint32_t
>
(
sizeof
(
T
)
)
)
;
return
sk_sp
<
T
>
(
SkRef
(
this
-
>
make
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
)
;
}
template
<
typename
T
>
T
*
makeArrayDefault
(
size_t
count
)
{
uint32_t
safeCount
=
SkTo
<
uint32_t
>
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
;
}
return
array
;
}
template
<
typename
T
>
T
*
makeArray
(
size_t
count
)
{
uint32_t
safeCount
=
SkTo
<
uint32_t
>
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
(
)
;
}
return
array
;
}
void
reset
(
)
;
private
:
using
Footer
=
int64_t
;
using
FooterAction
=
char
*
(
char
*
)
;
static
char
*
SkipPod
(
char
*
footerEnd
)
;
static
void
RunDtorsOnBlock
(
char
*
footerEnd
)
;
static
char
*
NextBlock
(
char
*
footerEnd
)
;
void
installFooter
(
FooterAction
*
releaser
uint32_t
padding
)
;
void
installUint32Footer
(
FooterAction
*
action
uint32_t
value
uint32_t
padding
)
;
void
installPtrFooter
(
FooterAction
*
action
char
*
ptr
uint32_t
padding
)
;
void
ensureSpace
(
uint32_t
size
uint32_t
alignment
)
;
char
*
allocObject
(
uint32_t
size
uint32_t
alignment
)
;
char
*
allocObjectWithFooter
(
uint32_t
sizeIncludingFooter
uint32_t
alignment
)
;
template
<
typename
T
>
char
*
commonArrayAlloc
(
uint32_t
count
)
{
char
*
objStart
;
uint32_t
arraySize
=
SkTo
<
uint32_t
>
(
count
*
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkTo
<
uint32_t
>
(
alignof
(
T
)
)
;
if
(
skstd
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
arraySize
alignment
)
;
fCursor
=
objStart
+
arraySize
;
}
else
{
uint32_t
totalSize
=
arraySize
+
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
;
objStart
=
this
-
>
allocObjectWithFooter
(
totalSize
alignment
)
;
uint32_t
padding
=
SkTo
<
uint32_t
>
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
arraySize
;
this
-
>
installUint32Footer
(
[
]
(
char
*
footerEnd
)
{
char
*
objEnd
=
footerEnd
-
(
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
)
;
uint32_t
count
;
memmove
(
&
count
objEnd
sizeof
(
uint32_t
)
)
;
char
*
objStart
=
objEnd
-
count
*
sizeof
(
T
)
;
T
*
array
=
(
T
*
)
objStart
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
array
[
i
]
.
~
T
(
)
;
}
return
objStart
;
}
SkTo
<
uint32_t
>
(
count
)
padding
)
;
}
return
objStart
;
}
char
*
fDtorCursor
;
char
*
fCursor
;
char
*
fEnd
;
char
*
const
fFirstBlock
;
const
uint32_t
fFirstSize
;
const
uint32_t
fExtraSize
;
uint32_t
fFib0
{
1
}
fFib1
{
1
}
;
}
;
#
endif
