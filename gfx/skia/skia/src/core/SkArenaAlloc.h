#
ifndef
SkArenaAlloc_DEFINED
#
define
SkArenaAlloc_DEFINED
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTFitsIn
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
cstddef
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
class
SkArenaAlloc
{
public
:
enum
Tracking
{
kDontTrack
kTrack
}
;
SkArenaAlloc
(
char
*
block
size_t
size
size_t
Tracking
tracking
=
kDontTrack
)
;
SkArenaAlloc
(
size_t
extraSize
Tracking
tracking
=
kDontTrack
)
:
SkArenaAlloc
(
nullptr
0
extraSize
tracking
)
{
}
~
SkArenaAlloc
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
T
*
make
(
Args
&
&
.
.
.
args
)
{
uint32_t
size
=
SkTo
<
uint32_t
>
(
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkTo
<
uint32_t
>
(
alignof
(
T
)
)
;
char
*
objStart
;
if
(
skstd
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
size
alignment
)
;
fCursor
=
objStart
+
size
;
}
else
{
objStart
=
this
-
>
allocObjectWithFooter
(
size
+
sizeof
(
Footer
)
alignment
)
;
uint32_t
padding
=
SkTo
<
uint32_t
>
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
size
;
FooterAction
*
releaser
=
[
]
(
char
*
objEnd
)
{
char
*
objStart
=
objEnd
-
(
sizeof
(
T
)
+
sizeof
(
Footer
)
)
;
(
(
T
*
)
objStart
)
-
>
~
T
(
)
;
return
objStart
;
}
;
this
-
>
installFooter
(
releaser
padding
)
;
}
return
new
(
objStart
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
sk_sp
<
T
>
makeSkSp
(
Args
&
&
.
.
.
args
)
{
SkASSERT
(
SkTFitsIn
<
uint32_t
>
(
sizeof
(
T
)
)
)
;
return
sk_sp
<
T
>
(
SkRef
(
this
-
>
make
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
)
;
}
uint32_t
safeU32
(
size_t
n
)
{
SkASSERT_RELEASE
(
SkTFitsIn
<
uint32_t
>
(
n
)
)
;
return
uint32_t
(
n
)
;
}
template
<
typename
T
>
T
*
makeArrayDefault
(
size_t
count
)
{
uint32_t
safeCount
=
safeU32
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
;
}
return
array
;
}
template
<
typename
T
>
T
*
makeArray
(
size_t
count
)
{
uint32_t
safeCount
=
safeU32
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
(
)
;
}
return
array
;
}
void
*
makeBytesAlignedTo
(
size_t
size
size_t
align
)
{
auto
objStart
=
this
-
>
allocObject
(
safeU32
(
size
)
safeU32
(
align
)
)
;
fCursor
=
objStart
+
size
;
return
objStart
;
}
void
reset
(
)
;
private
:
using
Footer
=
int64_t
;
using
FooterAction
=
char
*
(
char
*
)
;
static
char
*
SkipPod
(
char
*
footerEnd
)
;
static
void
RunDtorsOnBlock
(
char
*
footerEnd
)
;
static
char
*
NextBlock
(
char
*
footerEnd
)
;
void
installFooter
(
FooterAction
*
releaser
uint32_t
padding
)
;
void
installUint32Footer
(
FooterAction
*
action
uint32_t
value
uint32_t
padding
)
;
void
installPtrFooter
(
FooterAction
*
action
char
*
ptr
uint32_t
padding
)
;
void
ensureSpace
(
uint32_t
size
uint32_t
alignment
)
;
char
*
allocObject
(
uint32_t
size
uint32_t
alignment
)
{
uintptr_t
mask
=
alignment
-
1
;
uintptr_t
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
uintptr_t
totalSize
=
size
+
alignedOffset
;
if
(
totalSize
<
size
)
{
SK_ABORT
(
"
The
total
size
of
allocation
overflowed
uintptr_t
.
"
)
;
}
if
(
totalSize
>
static_cast
<
uintptr_t
>
(
fEnd
-
fCursor
)
)
{
this
-
>
ensureSpace
(
size
alignment
)
;
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
}
return
fCursor
+
alignedOffset
;
}
char
*
allocObjectWithFooter
(
uint32_t
sizeIncludingFooter
uint32_t
alignment
)
;
template
<
typename
T
>
char
*
commonArrayAlloc
(
uint32_t
count
)
{
char
*
objStart
;
SkASSERT_RELEASE
(
count
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
/
sizeof
(
T
)
)
;
uint32_t
arraySize
=
SkTo
<
uint32_t
>
(
count
*
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkTo
<
uint32_t
>
(
alignof
(
T
)
)
;
if
(
skstd
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
arraySize
alignment
)
;
fCursor
=
objStart
+
arraySize
;
}
else
{
constexpr
uint32_t
overhead
=
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
;
SkASSERT_RELEASE
(
arraySize
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
overhead
)
;
uint32_t
totalSize
=
arraySize
+
overhead
;
objStart
=
this
-
>
allocObjectWithFooter
(
totalSize
alignment
)
;
uint32_t
padding
=
SkTo
<
uint32_t
>
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
arraySize
;
this
-
>
installUint32Footer
(
[
]
(
char
*
footerEnd
)
{
char
*
objEnd
=
footerEnd
-
(
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
)
;
uint32_t
count
;
memmove
(
&
count
objEnd
sizeof
(
uint32_t
)
)
;
char
*
objStart
=
objEnd
-
count
*
sizeof
(
T
)
;
T
*
array
=
(
T
*
)
objStart
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
array
[
i
]
.
~
T
(
)
;
}
return
objStart
;
}
SkTo
<
uint32_t
>
(
count
)
padding
)
;
}
return
objStart
;
}
char
*
fDtorCursor
;
char
*
fCursor
;
char
*
fEnd
;
char
*
const
fFirstBlock
;
const
uint32_t
fFirstSize
;
const
uint32_t
fExtraSize
;
uint32_t
fTotalAlloc
{
0
}
;
int32_t
fTotalSlop
{
-
1
}
;
uint32_t
fFib0
{
1
}
fFib1
{
1
}
;
}
;
template
<
size_t
InlineStorageSize
>
class
SkSTArenaAlloc
:
public
SkArenaAlloc
{
public
:
explicit
SkSTArenaAlloc
(
size_t
extraSize
=
InlineStorageSize
Tracking
tracking
=
kDontTrack
)
:
INHERITED
(
fInlineStorage
InlineStorageSize
extraSize
tracking
)
{
}
private
:
char
fInlineStorage
[
InlineStorageSize
]
;
using
INHERITED
=
SkArenaAlloc
;
}
;
#
endif
