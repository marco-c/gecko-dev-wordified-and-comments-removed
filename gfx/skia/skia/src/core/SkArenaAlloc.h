#
ifndef
SkArenaAlloc_DEFINED
#
define
SkArenaAlloc_DEFINED
#
include
"
include
/
private
/
SkTFitsIn
.
h
"
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
class
SkArenaAlloc
{
public
:
SkArenaAlloc
(
char
*
block
size_t
blockSize
size_t
firstHeapAllocation
)
;
explicit
SkArenaAlloc
(
size_t
firstHeapAllocation
)
:
SkArenaAlloc
(
nullptr
0
firstHeapAllocation
)
{
}
~
SkArenaAlloc
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
T
*
make
(
Args
&
&
.
.
.
args
)
{
uint32_t
size
=
ToU32
(
sizeof
(
T
)
)
;
uint32_t
alignment
=
ToU32
(
alignof
(
T
)
)
;
char
*
objStart
;
if
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
size
alignment
)
;
fCursor
=
objStart
+
size
;
}
else
{
objStart
=
this
-
>
allocObjectWithFooter
(
size
+
sizeof
(
Footer
)
alignment
)
;
uint32_t
padding
=
ToU32
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
size
;
FooterAction
*
releaser
=
[
]
(
char
*
objEnd
)
{
char
*
objStart
=
objEnd
-
(
sizeof
(
T
)
+
sizeof
(
Footer
)
)
;
(
(
T
*
)
objStart
)
-
>
~
T
(
)
;
return
objStart
;
}
;
this
-
>
installFooter
(
releaser
padding
)
;
}
return
new
(
objStart
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
T
*
makeArrayDefault
(
size_t
count
)
{
AssertRelease
(
SkTFitsIn
<
uint32_t
>
(
count
)
)
;
uint32_t
safeCount
=
ToU32
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
;
}
return
array
;
}
template
<
typename
T
>
T
*
makeArray
(
size_t
count
)
{
AssertRelease
(
SkTFitsIn
<
uint32_t
>
(
count
)
)
;
uint32_t
safeCount
=
ToU32
(
count
)
;
T
*
array
=
(
T
*
)
this
-
>
commonArrayAlloc
<
T
>
(
safeCount
)
;
for
(
size_t
i
=
0
;
i
<
safeCount
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
(
)
;
}
return
array
;
}
void
*
makeBytesAlignedTo
(
size_t
size
size_t
align
)
{
AssertRelease
(
SkTFitsIn
<
uint32_t
>
(
size
)
)
;
auto
objStart
=
this
-
>
allocObject
(
ToU32
(
size
)
ToU32
(
align
)
)
;
fCursor
=
objStart
+
size
;
return
objStart
;
}
void
reset
(
)
;
private
:
static
void
AssertRelease
(
bool
cond
)
{
if
(
!
cond
)
{
:
:
abort
(
)
;
}
}
static
uint32_t
ToU32
(
size_t
v
)
{
assert
(
SkTFitsIn
<
uint32_t
>
(
v
)
)
;
return
(
uint32_t
)
v
;
}
using
Footer
=
int64_t
;
using
FooterAction
=
char
*
(
char
*
)
;
static
char
*
SkipPod
(
char
*
footerEnd
)
;
static
void
RunDtorsOnBlock
(
char
*
footerEnd
)
;
static
char
*
NextBlock
(
char
*
footerEnd
)
;
void
installFooter
(
FooterAction
*
releaser
uint32_t
padding
)
;
void
installUint32Footer
(
FooterAction
*
action
uint32_t
value
uint32_t
padding
)
;
void
installPtrFooter
(
FooterAction
*
action
char
*
ptr
uint32_t
padding
)
;
void
ensureSpace
(
uint32_t
size
uint32_t
alignment
)
;
char
*
allocObject
(
uint32_t
size
uint32_t
alignment
)
{
uintptr_t
mask
=
alignment
-
1
;
uintptr_t
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
uintptr_t
totalSize
=
size
+
alignedOffset
;
AssertRelease
(
totalSize
>
=
size
)
;
if
(
totalSize
>
static_cast
<
uintptr_t
>
(
fEnd
-
fCursor
)
)
{
this
-
>
ensureSpace
(
size
alignment
)
;
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
}
return
fCursor
+
alignedOffset
;
}
char
*
allocObjectWithFooter
(
uint32_t
sizeIncludingFooter
uint32_t
alignment
)
;
template
<
typename
T
>
char
*
commonArrayAlloc
(
uint32_t
count
)
{
char
*
objStart
;
AssertRelease
(
count
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
/
sizeof
(
T
)
)
;
uint32_t
arraySize
=
ToU32
(
count
*
sizeof
(
T
)
)
;
uint32_t
alignment
=
ToU32
(
alignof
(
T
)
)
;
if
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
arraySize
alignment
)
;
fCursor
=
objStart
+
arraySize
;
}
else
{
constexpr
uint32_t
overhead
=
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
;
AssertRelease
(
arraySize
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
overhead
)
;
uint32_t
totalSize
=
arraySize
+
overhead
;
objStart
=
this
-
>
allocObjectWithFooter
(
totalSize
alignment
)
;
uint32_t
padding
=
ToU32
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
arraySize
;
this
-
>
installUint32Footer
(
[
]
(
char
*
footerEnd
)
{
char
*
objEnd
=
footerEnd
-
(
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
)
;
uint32_t
count
;
memmove
(
&
count
objEnd
sizeof
(
uint32_t
)
)
;
char
*
objStart
=
objEnd
-
count
*
sizeof
(
T
)
;
T
*
array
=
(
T
*
)
objStart
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
array
[
i
]
.
~
T
(
)
;
}
return
objStart
;
}
ToU32
(
count
)
padding
)
;
}
return
objStart
;
}
char
*
fDtorCursor
;
char
*
fCursor
;
char
*
fEnd
;
char
*
const
fFirstBlock
;
const
uint32_t
fFirstSize
;
const
uint32_t
fFirstHeapAllocationSize
;
uint32_t
fFib0
{
1
}
fFib1
{
1
}
;
}
;
template
<
size_t
InlineStorageSize
>
class
SkSTArenaAlloc
:
public
SkArenaAlloc
{
public
:
explicit
SkSTArenaAlloc
(
size_t
firstHeapAllocation
=
InlineStorageSize
)
:
INHERITED
(
fInlineStorage
InlineStorageSize
firstHeapAllocation
)
{
}
private
:
char
fInlineStorage
[
InlineStorageSize
]
;
using
INHERITED
=
SkArenaAlloc
;
}
;
#
endif
