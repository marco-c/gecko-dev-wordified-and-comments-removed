#
ifndef
SkBitmapProcState_DEFINED
#
define
SkBitmapProcState_DEFINED
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
private
/
SkFixed
.
h
"
#
include
"
include
/
private
/
SkFloatBits
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkBitmapController
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkMipMap
.
h
"
typedef
SkFixed3232
SkFractionalInt
;
#
define
SkScalarToFractionalInt
(
x
)
SkScalarToFixed3232
(
x
)
#
define
SkFractionalIntToFixed
(
x
)
SkFixed3232ToFixed
(
x
)
#
define
SkFixedToFractionalInt
(
x
)
SkFixedToFixed3232
(
x
)
#
define
SkFractionalIntToInt
(
x
)
SkFixed3232ToInt
(
x
)
class
SkPaint
;
struct
SkBitmapProcInfo
{
SkBitmapProcInfo
(
const
SkImage_Base
*
SkTileMode
tmx
SkTileMode
tmy
)
;
~
SkBitmapProcInfo
(
)
;
const
SkImage_Base
*
fImage
;
SkPixmap
fPixmap
;
SkMatrix
fInvMatrix
;
SkMatrix
fRealInvMatrix
;
SkColor
fPaintColor
;
SkTileMode
fTileModeX
;
SkTileMode
fTileModeY
;
SkFilterQuality
fFilterQuality
;
SkMatrix
:
:
TypeMask
fInvType
;
bool
init
(
const
SkMatrix
&
inverse
const
SkPaint
&
)
;
private
:
enum
{
kBMStateSize
=
136
}
;
SkSTArenaAlloc
<
kBMStateSize
>
fAlloc
;
SkBitmapController
:
:
State
*
fBMState
;
}
;
struct
SkBitmapProcState
:
public
SkBitmapProcInfo
{
SkBitmapProcState
(
const
SkImage_Base
*
image
SkTileMode
tmx
SkTileMode
tmy
)
:
SkBitmapProcInfo
(
image
tmx
tmy
)
{
}
bool
setup
(
const
SkMatrix
&
inv
const
SkPaint
&
paint
)
{
return
this
-
>
init
(
inv
paint
)
&
&
this
-
>
chooseProcs
(
)
;
}
typedef
void
(
*
ShaderProc32
)
(
const
void
*
ctx
int
x
int
y
SkPMColor
[
]
int
count
)
;
typedef
void
(
*
MatrixProc
)
(
const
SkBitmapProcState
&
uint32_t
bitmapXY
[
]
int
count
int
x
int
y
)
;
typedef
void
(
*
SampleProc32
)
(
const
SkBitmapProcState
&
const
uint32_t
[
]
int
count
SkPMColor
colors
[
]
)
;
SkMatrixPriv
:
:
MapXYProc
fInvProc
;
SkFractionalInt
fInvSxFractionalInt
;
SkFractionalInt
fInvKyFractionalInt
;
SkFixed
fFilterOneX
;
SkFixed
fFilterOneY
;
SkFixed
fInvSx
;
SkFixed
fInvKy
;
SkPMColor
fPaintPMColor
;
uint16_t
fAlphaScale
;
int
maxCountForBufferSize
(
size_t
bufferSize
)
const
;
ShaderProc32
getShaderProc32
(
)
const
{
return
fShaderProc32
;
}
#
ifdef
SK_DEBUG
MatrixProc
getMatrixProc
(
)
const
;
#
else
MatrixProc
getMatrixProc
(
)
const
{
return
fMatrixProc
;
}
#
endif
SampleProc32
getSampleProc32
(
)
const
{
return
fSampleProc32
;
}
private
:
ShaderProc32
fShaderProc32
;
MatrixProc
fMatrixProc
;
SampleProc32
fSampleProc32
;
MatrixProc
chooseMatrixProc
(
bool
trivial_matrix
)
;
bool
chooseProcs
(
)
;
ShaderProc32
chooseShaderProc32
(
)
;
bool
setupForTranslate
(
)
;
#
ifdef
SK_DEBUG
static
void
DebugMatrixProc
(
const
SkBitmapProcState
&
uint32_t
[
]
int
count
int
x
int
y
)
;
#
endif
}
;
#
ifdef
SK_CPU_BENDIAN
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
<
<
16
|
(
sec
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
else
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
|
(
(
sec
)
<
<
16
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
endif
#
ifdef
SK_DEBUG
static
inline
uint32_t
pack_two_shorts
(
U16CPU
pri
U16CPU
sec
)
{
SkASSERT
(
(
uint16_t
)
pri
=
=
pri
)
;
SkASSERT
(
(
uint16_t
)
sec
=
=
sec
)
;
return
PACK_TWO_SHORTS
(
pri
sec
)
;
}
#
else
#
define
pack_two_shorts
(
pri
sec
)
PACK_TWO_SHORTS
(
pri
sec
)
#
endif
class
SkBitmapProcStateAutoMapper
{
public
:
SkBitmapProcStateAutoMapper
(
const
SkBitmapProcState
&
s
int
x
int
y
SkPoint
*
scalarPoint
=
nullptr
)
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
SkFixed
biasX
biasY
;
if
(
s
.
fFilterQuality
=
=
kNone_SkFilterQuality
)
{
biasX
=
(
s
.
fInvMatrix
.
getScaleX
(
)
>
0
)
;
biasY
=
(
s
.
fInvMatrix
.
getScaleY
(
)
>
0
)
;
}
else
{
biasX
=
s
.
fFilterOneX
>
>
1
;
biasY
=
s
.
fFilterOneY
>
>
1
;
}
fX
=
(
SkFractionalInt
)
(
(
uint64_t
)
SkScalarToFractionalInt
(
pt
.
x
(
)
)
-
(
uint64_t
)
SkFixedToFractionalInt
(
biasX
)
)
;
fY
=
(
SkFractionalInt
)
(
(
uint64_t
)
SkScalarToFractionalInt
(
pt
.
y
(
)
)
-
(
uint64_t
)
SkFixedToFractionalInt
(
biasY
)
)
;
if
(
scalarPoint
)
{
scalarPoint
-
>
set
(
pt
.
x
(
)
-
SkFixedToScalar
(
biasX
)
pt
.
y
(
)
-
SkFixedToScalar
(
biasY
)
)
;
}
}
SkFractionalInt
fractionalIntX
(
)
const
{
return
fX
;
}
SkFractionalInt
fractionalIntY
(
)
const
{
return
fY
;
}
SkFixed
fixedX
(
)
const
{
return
SkFractionalIntToFixed
(
fX
)
;
}
SkFixed
fixedY
(
)
const
{
return
SkFractionalIntToFixed
(
fY
)
;
}
int
intX
(
)
const
{
return
SkFractionalIntToInt
(
fX
)
;
}
int
intY
(
)
const
{
return
SkFractionalIntToInt
(
fY
)
;
}
private
:
SkFractionalInt
fX
fY
;
}
;
#
endif
