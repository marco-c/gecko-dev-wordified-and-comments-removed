#
ifndef
SkBitmapProcState_DEFINED
#
define
SkBitmapProcState_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkCPUTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkFixed
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
class
SkImage_Base
;
enum
class
SkTileMode
;
typedef
SkFixed3232
SkFractionalInt
;
#
define
SkScalarToFractionalInt
(
x
)
SkScalarToFixed3232
(
x
)
#
define
SkFractionalIntToFixed
(
x
)
SkFixed3232ToFixed
(
x
)
#
define
SkFixedToFractionalInt
(
x
)
SkFixedToFixed3232
(
x
)
#
define
SkFractionalIntToInt
(
x
)
SkFixed3232ToInt
(
x
)
struct
SkBitmapProcState
{
SkBitmapProcState
(
const
SkImage_Base
*
image
SkTileMode
tmx
SkTileMode
tmy
)
;
bool
setup
(
const
SkMatrix
&
inv
SkColor
color
const
SkSamplingOptions
&
sampling
)
{
return
this
-
>
init
(
inv
color
sampling
)
&
&
this
-
>
chooseProcs
(
)
;
}
typedef
void
(
*
ShaderProc32
)
(
const
void
*
ctx
int
x
int
y
SkPMColor
[
]
int
count
)
;
typedef
void
(
*
MatrixProc
)
(
const
SkBitmapProcState
&
uint32_t
bitmapXY
[
]
int
count
int
x
int
y
)
;
typedef
void
(
*
SampleProc32
)
(
const
SkBitmapProcState
&
const
uint32_t
[
]
int
count
SkPMColor
colors
[
]
)
;
const
SkImage_Base
*
fImage
;
SkPixmap
fPixmap
;
SkMatrix
fInvMatrix
;
SkAlpha
fPaintAlpha
;
SkTileMode
fTileModeX
;
SkTileMode
fTileModeY
;
bool
fBilerp
;
SkMatrixPriv
:
:
MapXYProc
fInvProc
;
SkFractionalInt
fInvSxFractionalInt
;
SkFractionalInt
fInvKyFractionalInt
;
SkFixed
fFilterOneX
;
SkFixed
fFilterOneY
;
uint16_t
fAlphaScale
;
int
maxCountForBufferSize
(
size_t
bufferSize
)
const
;
ShaderProc32
getShaderProc32
(
)
const
{
return
fShaderProc32
;
}
#
ifdef
SK_DEBUG
MatrixProc
getMatrixProc
(
)
const
;
#
else
MatrixProc
getMatrixProc
(
)
const
{
return
fMatrixProc
;
}
#
endif
SampleProc32
getSampleProc32
(
)
const
{
return
fSampleProc32
;
}
private
:
enum
{
kBMStateSize
=
136
}
;
SkSTArenaAlloc
<
kBMStateSize
>
fAlloc
;
ShaderProc32
fShaderProc32
;
MatrixProc
fMatrixProc
;
SampleProc32
fSampleProc32
;
bool
init
(
const
SkMatrix
&
inverse
SkAlpha
const
SkSamplingOptions
&
)
;
bool
chooseProcs
(
)
;
MatrixProc
chooseMatrixProc
(
bool
trivial_matrix
)
;
ShaderProc32
chooseShaderProc32
(
)
;
bool
setupForTranslate
(
)
;
#
ifdef
SK_DEBUG
static
void
DebugMatrixProc
(
const
SkBitmapProcState
&
uint32_t
[
]
int
count
int
x
int
y
)
;
#
endif
}
;
#
ifdef
SK_CPU_BENDIAN
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
<
<
16
|
(
sec
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
else
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
|
(
(
sec
)
<
<
16
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
endif
#
ifdef
SK_DEBUG
static
inline
uint32_t
pack_two_shorts
(
U16CPU
pri
U16CPU
sec
)
{
SkASSERT
(
(
uint16_t
)
pri
=
=
pri
)
;
SkASSERT
(
(
uint16_t
)
sec
=
=
sec
)
;
return
PACK_TWO_SHORTS
(
pri
sec
)
;
}
#
else
#
define
pack_two_shorts
(
pri
sec
)
PACK_TWO_SHORTS
(
pri
sec
)
#
endif
class
SkBitmapProcStateAutoMapper
{
public
:
SkBitmapProcStateAutoMapper
(
const
SkBitmapProcState
&
s
int
x
int
y
SkPoint
*
scalarPoint
=
nullptr
)
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
SkFixed
biasX
=
0
biasY
=
0
;
if
(
s
.
fBilerp
)
{
biasX
=
s
.
fFilterOneX
>
>
1
;
biasY
=
s
.
fFilterOneY
>
>
1
;
}
else
{
biasX
=
1
;
biasY
=
1
;
}
fX
=
(
SkFractionalInt
)
(
(
uint64_t
)
SkScalarToFractionalInt
(
pt
.
x
(
)
)
-
(
uint64_t
)
SkFixedToFractionalInt
(
biasX
)
)
;
fY
=
(
SkFractionalInt
)
(
(
uint64_t
)
SkScalarToFractionalInt
(
pt
.
y
(
)
)
-
(
uint64_t
)
SkFixedToFractionalInt
(
biasY
)
)
;
if
(
scalarPoint
)
{
scalarPoint
-
>
set
(
pt
.
x
(
)
-
SkFixedToScalar
(
biasX
)
pt
.
y
(
)
-
SkFixedToScalar
(
biasY
)
)
;
}
}
SkFractionalInt
fractionalIntX
(
)
const
{
return
fX
;
}
SkFractionalInt
fractionalIntY
(
)
const
{
return
fY
;
}
SkFixed
fixedX
(
)
const
{
return
SkFractionalIntToFixed
(
fX
)
;
}
SkFixed
fixedY
(
)
const
{
return
SkFractionalIntToFixed
(
fY
)
;
}
int
intX
(
)
const
{
return
SkFractionalIntToInt
(
fX
)
;
}
int
intY
(
)
const
{
return
SkFractionalIntToInt
(
fY
)
;
}
private
:
SkFractionalInt
fX
fY
;
}
;
namespace
sktests
{
uint32_t
pack_clamp
(
SkFixed
f
unsigned
max
)
;
uint32_t
pack_repeat
(
SkFixed
f
unsigned
max
size_t
width
)
;
uint32_t
pack_mirror
(
SkFixed
f
unsigned
max
size_t
width
)
;
}
namespace
SkOpts
{
extern
void
(
*
S32_alpha_D32_filter_DX
)
(
const
SkBitmapProcState
&
const
uint32_t
*
xy
int
count
SkPMColor
*
)
;
extern
void
(
*
S32_alpha_D32_filter_DXDY
)
(
const
SkBitmapProcState
&
const
uint32_t
*
xy
int
count
SkPMColor
*
)
;
void
Init_BitmapProcState
(
)
;
}
#
endif
