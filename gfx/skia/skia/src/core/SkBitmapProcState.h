#
ifndef
SkBitmapProcState_DEFINED
#
define
SkBitmapProcState_DEFINED
#
include
"
SkBitmap
.
h
"
#
include
"
SkBitmapController
.
h
"
#
include
"
SkBitmapFilter
.
h
"
#
include
"
SkBitmapProvider
.
h
"
#
include
"
SkFloatBits
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkTemplates
.
h
"
typedef
SkFixed3232
SkFractionalInt
;
#
define
SkScalarToFractionalInt
(
x
)
SkScalarToFixed3232
(
x
)
#
define
SkFractionalIntToFixed
(
x
)
SkFixed3232ToFixed
(
x
)
#
define
SkFixedToFractionalInt
(
x
)
SkFixedToFixed3232
(
x
)
#
define
SkFractionalIntToInt
(
x
)
SkFixed3232ToInt
(
x
)
class
SkPaint
;
struct
SkBitmapProcInfo
{
SkBitmapProcInfo
(
const
SkBitmapProvider
&
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
SkSourceGammaTreatment
)
;
SkBitmapProcInfo
(
const
SkBitmap
&
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
SkSourceGammaTreatment
)
;
~
SkBitmapProcInfo
(
)
;
const
SkBitmapProvider
fProvider
;
SkPixmap
fPixmap
;
SkMatrix
fInvMatrix
;
SkMatrix
fRealInvMatrix
;
SkColor
fPaintColor
;
SkShader
:
:
TileMode
fTileModeX
;
SkShader
:
:
TileMode
fTileModeY
;
SkFilterQuality
fFilterQuality
;
SkMatrix
:
:
TypeMask
fInvType
;
SkSourceGammaTreatment
fSrcGammaTreatment
;
bool
init
(
const
SkMatrix
&
inverse
const
SkPaint
&
)
;
private
:
enum
{
kBMStateSize
=
136
}
;
SkAlignedSStorage
<
kBMStateSize
>
fBMStateStorage
;
SkBitmapController
:
:
State
*
fBMState
;
}
;
struct
SkBitmapProcState
:
public
SkBitmapProcInfo
{
SkBitmapProcState
(
const
SkBitmapProvider
&
prov
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
SkSourceGammaTreatment
treatment
)
:
SkBitmapProcInfo
(
prov
tmx
tmy
treatment
)
{
}
SkBitmapProcState
(
const
SkBitmap
&
bitmap
SkShader
:
:
TileMode
tmx
SkShader
:
:
TileMode
tmy
SkSourceGammaTreatment
treatment
)
:
SkBitmapProcInfo
(
bitmap
tmx
tmy
treatment
)
{
}
bool
setup
(
const
SkMatrix
&
inv
const
SkPaint
&
paint
)
{
return
this
-
>
init
(
inv
paint
)
&
&
this
-
>
chooseProcs
(
)
;
}
typedef
void
(
*
ShaderProc32
)
(
const
void
*
ctx
int
x
int
y
SkPMColor
[
]
int
count
)
;
typedef
void
(
*
ShaderProc16
)
(
const
void
*
ctx
int
x
int
y
uint16_t
[
]
int
count
)
;
typedef
void
(
*
MatrixProc
)
(
const
SkBitmapProcState
&
uint32_t
bitmapXY
[
]
int
count
int
x
int
y
)
;
typedef
void
(
*
SampleProc32
)
(
const
SkBitmapProcState
&
const
uint32_t
[
]
int
count
SkPMColor
colors
[
]
)
;
typedef
U16CPU
(
*
FixedTileProc
)
(
SkFixed
)
;
typedef
U16CPU
(
*
FixedTileLowBitsProc
)
(
SkFixed
int
)
;
typedef
U16CPU
(
*
IntTileProc
)
(
int
value
int
count
)
;
SkMatrix
:
:
MapXYProc
fInvProc
;
SkFractionalInt
fInvSxFractionalInt
;
SkFractionalInt
fInvKyFractionalInt
;
FixedTileProc
fTileProcX
;
FixedTileProc
fTileProcY
;
FixedTileLowBitsProc
fTileLowBitsProcX
;
FixedTileLowBitsProc
fTileLowBitsProcY
;
IntTileProc
fIntTileProcY
;
SkFixed
fFilterOneX
;
SkFixed
fFilterOneY
;
SkFixed
fInvSx
;
SkFixed
fInvKy
;
SkPMColor
fPaintPMColor
;
uint16_t
fAlphaScale
;
void
platformProcs
(
)
;
int
maxCountForBufferSize
(
size_t
bufferSize
)
const
;
ShaderProc32
getShaderProc32
(
)
const
{
return
fShaderProc32
;
}
ShaderProc16
getShaderProc16
(
)
const
{
return
fShaderProc16
;
}
#
ifdef
SK_DEBUG
MatrixProc
getMatrixProc
(
)
const
;
#
else
MatrixProc
getMatrixProc
(
)
const
{
return
fMatrixProc
;
}
#
endif
SampleProc32
getSampleProc32
(
)
const
{
return
fSampleProc32
;
}
private
:
ShaderProc32
fShaderProc32
;
ShaderProc16
fShaderProc16
;
MatrixProc
fMatrixProc
;
SampleProc32
fSampleProc32
;
MatrixProc
chooseMatrixProc
(
bool
trivial_matrix
)
;
bool
chooseProcs
(
)
;
bool
chooseScanlineProcs
(
bool
trivialMatrix
bool
clampClamp
)
;
ShaderProc32
chooseShaderProc32
(
)
;
bool
setupForTranslate
(
)
;
#
ifdef
SK_DEBUG
static
void
DebugMatrixProc
(
const
SkBitmapProcState
&
uint32_t
[
]
int
count
int
x
int
y
)
;
#
endif
}
;
#
ifdef
SK_CPU_BENDIAN
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
<
<
16
|
(
sec
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
else
#
define
PACK_TWO_SHORTS
(
pri
sec
)
(
(
pri
)
|
(
(
sec
)
<
<
16
)
)
#
define
UNPACK_PRIMARY_SHORT
(
packed
)
(
(
packed
)
&
0xFFFF
)
#
define
UNPACK_SECONDARY_SHORT
(
packed
)
(
(
uint32_t
)
(
packed
)
>
>
16
)
#
endif
#
ifdef
SK_DEBUG
static
inline
uint32_t
pack_two_shorts
(
U16CPU
pri
U16CPU
sec
)
{
SkASSERT
(
(
uint16_t
)
pri
=
=
pri
)
;
SkASSERT
(
(
uint16_t
)
sec
=
=
sec
)
;
return
PACK_TWO_SHORTS
(
pri
sec
)
;
}
#
else
#
define
pack_two_shorts
(
pri
sec
)
PACK_TWO_SHORTS
(
pri
sec
)
#
endif
void
S32_opaque_D32_filter_DX
(
const
SkBitmapProcState
&
s
const
uint32_t
xy
[
]
int
count
SkPMColor
colors
[
]
)
;
void
S32_alpha_D32_filter_DX
(
const
SkBitmapProcState
&
s
const
uint32_t
xy
[
]
int
count
SkPMColor
colors
[
]
)
;
void
S32_opaque_D32_filter_DXDY
(
const
SkBitmapProcState
&
s
const
uint32_t
xy
[
]
int
count
SkPMColor
colors
[
]
)
;
void
S32_alpha_D32_filter_DXDY
(
const
SkBitmapProcState
&
s
const
uint32_t
xy
[
]
int
count
SkPMColor
colors
[
]
)
;
void
ClampX_ClampY_filter_scale
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
;
void
ClampX_ClampY_nofilter_scale
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
;
void
ClampX_ClampY_filter_affine
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
;
void
ClampX_ClampY_nofilter_affine
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
;
class
SkBitmapProcStateAutoMapper
{
public
:
SkBitmapProcStateAutoMapper
(
const
SkBitmapProcState
&
s
int
x
int
y
SkPoint
*
scalarPoint
=
nullptr
)
{
SkPoint
pt
;
s
.
fInvProc
(
s
.
fInvMatrix
SkIntToScalar
(
x
)
+
SK_ScalarHalf
SkIntToScalar
(
y
)
+
SK_ScalarHalf
&
pt
)
;
SkFixed
biasX
biasY
;
if
(
s
.
fFilterQuality
=
=
kNone_SkFilterQuality
)
{
biasX
=
(
s
.
fInvMatrix
.
getScaleX
(
)
>
0
)
;
biasY
=
(
s
.
fInvMatrix
.
getScaleY
(
)
>
0
)
;
}
else
{
biasX
=
s
.
fFilterOneX
>
>
1
;
biasY
=
s
.
fFilterOneY
>
>
1
;
}
fX
=
SkScalarToFractionalInt
(
pt
.
x
(
)
)
-
SkFixedToFractionalInt
(
biasX
)
;
fY
=
SkScalarToFractionalInt
(
pt
.
y
(
)
)
-
SkFixedToFractionalInt
(
biasY
)
;
if
(
scalarPoint
)
{
scalarPoint
-
>
set
(
pt
.
x
(
)
-
SkFixedToScalar
(
biasX
)
pt
.
y
(
)
-
SkFixedToScalar
(
biasY
)
)
;
}
}
SkFractionalInt
fractionalIntX
(
)
const
{
return
fX
;
}
SkFractionalInt
fractionalIntY
(
)
const
{
return
fY
;
}
SkFixed
fixedX
(
)
const
{
return
SkFractionalIntToFixed
(
fX
)
;
}
SkFixed
fixedY
(
)
const
{
return
SkFractionalIntToFixed
(
fY
)
;
}
int
intX
(
)
const
{
return
SkFractionalIntToInt
(
fX
)
;
}
int
intY
(
)
const
{
return
SkFractionalIntToInt
(
fY
)
;
}
private
:
SkFractionalInt
fX
fY
;
}
;
#
endif
