#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkBitmapProcState
.
h
"
#
include
"
src
/
core
/
SkUtils
.
h
"
static
inline
bool
can_truncate_to_fixed_for_decal
(
SkFixed
fx
SkFixed
dx
int
count
unsigned
max
)
{
SkASSERT
(
count
>
0
)
;
if
(
dx
<
=
SK_Fixed1
/
256
)
{
return
false
;
}
if
(
(
unsigned
)
SkFixedFloorToInt
(
fx
)
>
=
max
)
{
return
false
;
}
const
uint64_t
lastFx
=
fx
+
sk_64_mul
(
dx
count
-
1
)
;
return
SkTFitsIn
<
int32_t
>
(
lastFx
)
&
&
(
unsigned
)
SkFixedFloorToInt
(
SkTo
<
int32_t
>
(
lastFx
)
)
<
max
;
}
static
void
decal_nofilter_scale
(
uint32_t
dst
[
]
SkFixed
fx
SkFixed
dx
int
count
)
{
for
(
;
count
>
2
;
count
-
=
2
)
{
*
dst
+
+
=
pack_two_shorts
(
(
fx
+
0
)
>
>
16
(
fx
+
dx
)
>
>
16
)
;
fx
+
=
dx
+
dx
;
}
SkASSERT
(
count
<
=
2
)
;
switch
(
count
)
{
case
2
:
(
(
uint16_t
*
)
dst
)
[
1
]
=
SkToU16
(
(
fx
+
dx
)
>
>
16
)
;
case
1
:
(
(
uint16_t
*
)
dst
)
[
0
]
=
SkToU16
(
(
fx
+
0
)
>
>
16
)
;
}
}
template
<
unsigned
(
*
tile
)
(
SkFixed
int
)
bool
tryDecal
>
static
void
nofilter_scale
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
SkFractionalInt
fx
;
{
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
*
xy
+
+
=
tile
(
mapper
.
fixedY
(
)
s
.
fPixmap
.
height
(
)
-
1
)
;
fx
=
mapper
.
fractionalIntX
(
)
;
}
const
unsigned
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
if
(
0
=
=
maxX
)
{
memset
(
xy
0
count
*
sizeof
(
uint16_t
)
)
;
return
;
}
const
SkFractionalInt
dx
=
s
.
fInvSxFractionalInt
;
if
(
tryDecal
)
{
const
SkFixed
fixedFx
=
SkFractionalIntToFixed
(
fx
)
;
const
SkFixed
fixedDx
=
SkFractionalIntToFixed
(
dx
)
;
if
(
can_truncate_to_fixed_for_decal
(
fixedFx
fixedDx
count
maxX
)
)
{
decal_nofilter_scale
(
xy
fixedFx
fixedDx
count
)
;
return
;
}
}
for
(
;
count
>
=
2
;
count
-
=
2
)
{
*
xy
+
+
=
pack_two_shorts
(
tile
(
SkFractionalIntToFixed
(
fx
)
maxX
)
tile
(
SkFractionalIntToFixed
(
fx
+
dx
)
maxX
)
)
;
fx
+
=
dx
+
dx
;
}
auto
xx
=
(
uint16_t
*
)
xy
;
while
(
count
-
-
>
0
)
{
*
xx
+
+
=
tile
(
SkFractionalIntToFixed
(
fx
)
maxX
)
;
fx
+
=
dx
;
}
}
static
unsigned
extract_low_bits_clamp
(
SkFixed
fx
int
)
{
return
(
fx
>
>
12
)
&
0xf
;
}
static
unsigned
extract_low_bits_repeat_mirror
(
SkFixed
fx
int
max
)
{
return
extract_low_bits_clamp
(
(
fx
&
0xffff
)
*
(
max
+
1
)
max
)
;
}
template
<
unsigned
(
*
tile
)
(
SkFixed
int
)
unsigned
(
*
extract_low_bits
)
(
SkFixed
int
)
bool
tryDecal
>
static
void
filter_scale
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
SkASSERT
(
s
.
fInvKy
=
=
0
)
;
auto
pack
=
[
]
(
SkFixed
f
unsigned
max
SkFixed
one
)
{
unsigned
i
=
tile
(
f
max
)
;
i
=
(
i
<
<
4
)
|
extract_low_bits
(
f
max
)
;
return
(
i
<
<
14
)
|
(
tile
(
(
f
+
one
)
max
)
)
;
}
;
const
unsigned
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
const
SkFractionalInt
dx
=
s
.
fInvSxFractionalInt
;
SkFractionalInt
fx
;
{
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
const
SkFixed
fy
=
mapper
.
fixedY
(
)
;
const
unsigned
maxY
=
s
.
fPixmap
.
height
(
)
-
1
;
*
xy
+
+
=
pack
(
fy
maxY
s
.
fFilterOneY
)
;
fx
=
mapper
.
fractionalIntX
(
)
;
}
if
(
tryDecal
&
&
(
unsigned
)
SkFractionalIntToInt
(
fx
)
<
maxX
&
&
(
unsigned
)
SkFractionalIntToInt
(
fx
+
dx
*
(
count
-
1
)
)
<
maxX
)
{
while
(
count
-
-
>
0
)
{
SkFixed
fixedFx
=
SkFractionalIntToFixed
(
fx
)
;
SkASSERT
(
(
fixedFx
>
>
(
16
+
14
)
)
=
=
0
)
;
*
xy
+
+
=
(
fixedFx
>
>
12
<
<
14
)
|
(
(
fixedFx
>
>
16
)
+
1
)
;
fx
+
=
dx
;
}
return
;
}
while
(
count
-
-
>
0
)
{
SkFixed
fixedFx
=
SkFractionalIntToFixed
(
fx
)
;
*
xy
+
+
=
pack
(
fixedFx
maxX
s
.
fFilterOneX
)
;
fx
+
=
dx
;
}
}
static
inline
unsigned
SK_USHIFT16
(
unsigned
x
)
{
return
x
>
>
16
;
}
static
unsigned
clamp
(
SkFixed
fx
int
max
)
{
return
SkClampMax
(
fx
>
>
16
max
)
;
}
static
unsigned
repeat
(
SkFixed
fx
int
max
)
{
SkASSERT
(
max
<
65535
)
;
return
SK_USHIFT16
(
(
unsigned
)
(
fx
&
0xFFFF
)
*
(
max
+
1
)
)
;
}
static
unsigned
mirror
(
SkFixed
fx
int
max
)
{
SkASSERT
(
max
<
65535
)
;
SkFixed
s
=
SkLeftShift
(
fx
15
)
>
>
31
;
return
SK_USHIFT16
(
(
(
fx
^
s
)
&
0xFFFF
)
*
(
max
+
1
)
)
;
}
static
const
SkBitmapProcState
:
:
MatrixProc
MirrorX_MirrorY_Procs
[
]
=
{
nofilter_scale
<
mirror
false
>
filter_scale
<
mirror
extract_low_bits_repeat_mirror
false
>
}
;
#
if
defined
(
SK_ARM_HAS_NEON
)
#
include
<
arm_neon
.
h
>
static
void
decal_nofilter_scale_neon
(
uint32_t
dst
[
]
SkFixed
fx
SkFixed
dx
int
count
)
{
if
(
count
>
=
8
)
{
SkFixed
dx8
=
dx
*
8
;
int32x4_t
vdx8
=
vdupq_n_s32
(
dx8
)
;
int32x4_t
lbase
hbase
;
lbase
=
vdupq_n_s32
(
fx
)
;
lbase
=
vsetq_lane_s32
(
fx
+
dx
lbase
1
)
;
lbase
=
vsetq_lane_s32
(
fx
+
dx
+
dx
lbase
2
)
;
lbase
=
vsetq_lane_s32
(
fx
+
dx
+
dx
+
dx
lbase
3
)
;
hbase
=
lbase
+
vdupq_n_s32
(
4
*
dx
)
;
do
{
vst1q_u32
(
dst
vreinterpretq_u32_s16
(
vuzpq_s16
(
vreinterpretq_s16_s32
(
lbase
)
vreinterpretq_s16_s32
(
hbase
)
)
.
val
[
1
]
)
)
;
lbase
+
=
vdx8
;
hbase
+
=
vdx8
;
dst
+
=
4
;
count
-
=
8
;
fx
+
=
dx8
;
}
while
(
count
>
=
8
)
;
}
uint16_t
*
xx
=
(
uint16_t
*
)
dst
;
for
(
int
i
=
count
;
i
>
0
;
-
-
i
)
{
*
xx
+
+
=
SkToU16
(
fx
>
>
16
)
;
fx
+
=
dx
;
}
}
static
void
decal_filter_scale_neon
(
uint32_t
dst
[
]
SkFixed
fx
SkFixed
dx
int
count
)
{
if
(
count
>
=
8
)
{
SkFixed
dx8
=
dx
*
8
;
int32x4_t
vdx8
=
vdupq_n_s32
(
dx8
)
;
int32x4_t
wide_fx
wide_fx2
;
wide_fx
=
vdupq_n_s32
(
fx
)
;
wide_fx
=
vsetq_lane_s32
(
fx
+
dx
wide_fx
1
)
;
wide_fx
=
vsetq_lane_s32
(
fx
+
dx
+
dx
wide_fx
2
)
;
wide_fx
=
vsetq_lane_s32
(
fx
+
dx
+
dx
+
dx
wide_fx
3
)
;
wide_fx2
=
vaddq_s32
(
wide_fx
vdupq_n_s32
(
4
*
dx
)
)
;
while
(
count
>
=
8
)
{
int32x4_t
wide_out
;
int32x4_t
wide_out2
;
wide_out
=
vshlq_n_s32
(
vshrq_n_s32
(
wide_fx
12
)
14
)
;
wide_out
=
wide_out
|
(
vshrq_n_s32
(
wide_fx
16
)
+
vdupq_n_s32
(
1
)
)
;
wide_out2
=
vshlq_n_s32
(
vshrq_n_s32
(
wide_fx2
12
)
14
)
;
wide_out2
=
wide_out2
|
(
vshrq_n_s32
(
wide_fx2
16
)
+
vdupq_n_s32
(
1
)
)
;
vst1q_u32
(
dst
vreinterpretq_u32_s32
(
wide_out
)
)
;
vst1q_u32
(
dst
+
4
vreinterpretq_u32_s32
(
wide_out2
)
)
;
dst
+
=
8
;
fx
+
=
dx8
;
wide_fx
+
=
vdx8
;
wide_fx2
+
=
vdx8
;
count
-
=
8
;
}
}
if
(
count
&
1
)
{
SkASSERT
(
(
fx
>
>
(
16
+
14
)
)
=
=
0
)
;
*
dst
+
+
=
(
fx
>
>
12
<
<
14
)
|
(
(
fx
>
>
16
)
+
1
)
;
fx
+
=
dx
;
}
while
(
(
count
-
=
2
)
>
=
0
)
{
SkASSERT
(
(
fx
>
>
(
16
+
14
)
)
=
=
0
)
;
*
dst
+
+
=
(
fx
>
>
12
<
<
14
)
|
(
(
fx
>
>
16
)
+
1
)
;
fx
+
=
dx
;
*
dst
+
+
=
(
fx
>
>
12
<
<
14
)
|
(
(
fx
>
>
16
)
+
1
)
;
fx
+
=
dx
;
}
}
static
inline
int16x8_t
clamp8
(
int32x4_t
low
int32x4_t
high
unsigned
max
)
{
int16x8_t
res
;
res
=
vuzpq_s16
(
vreinterpretq_s16_s32
(
low
)
vreinterpretq_s16_s32
(
high
)
)
.
val
[
1
]
;
res
=
vmaxq_s16
(
res
vdupq_n_s16
(
0
)
)
;
res
=
vminq_s16
(
res
vdupq_n_s16
(
max
)
)
;
return
res
;
}
static
inline
int32x4_t
clamp4
(
int32x4_t
f
unsigned
max
)
{
int32x4_t
res
;
res
=
vshrq_n_s32
(
f
16
)
;
res
=
vmaxq_s32
(
res
vdupq_n_s32
(
0
)
)
;
res
=
vminq_s32
(
res
vdupq_n_s32
(
max
)
)
;
return
res
;
}
static
inline
int32x4_t
extract_low_bits_clamp4
(
int32x4_t
fx
unsigned
)
{
int32x4_t
ret
;
ret
=
vshrq_n_s32
(
fx
12
)
;
return
ret
;
}
static
inline
int16x8_t
repeat8
(
int32x4_t
low
int32x4_t
high
unsigned
max
)
{
uint16x8_t
res
;
uint32x4_t
tmpl
tmph
;
res
=
vuzpq_u16
(
vreinterpretq_u16_s32
(
low
)
vreinterpretq_u16_s32
(
high
)
)
.
val
[
0
]
;
tmpl
=
vmull_u16
(
vget_low_u16
(
res
)
vdup_n_u16
(
max
+
1
)
)
;
tmph
=
vmull_u16
(
vget_high_u16
(
res
)
vdup_n_u16
(
max
+
1
)
)
;
res
=
vuzpq_u16
(
vreinterpretq_u16_u32
(
tmpl
)
vreinterpretq_u16_u32
(
tmph
)
)
.
val
[
1
]
;
return
vreinterpretq_s16_u16
(
res
)
;
}
static
inline
int32x4_t
repeat4
(
int32x4_t
f
unsigned
max
)
{
uint16x4_t
res
;
uint32x4_t
tmp
;
res
=
vmovn_u32
(
vreinterpretq_u32_s32
(
f
)
)
;
tmp
=
vmull_u16
(
res
vdup_n_u16
(
max
+
1
)
)
;
tmp
=
vshrq_n_u32
(
tmp
16
)
;
return
vreinterpretq_s32_u32
(
tmp
)
;
}
static
inline
int32x4_t
extract_low_bits_repeat_mirror4
(
int32x4_t
fx
unsigned
max
)
{
uint16x4_t
res
;
uint32x4_t
tmp
;
int32x4_t
ret
;
res
=
vmovn_u32
(
vreinterpretq_u32_s32
(
fx
)
)
;
tmp
=
vmull_u16
(
res
vdup_n_u16
(
max
+
1
)
)
;
ret
=
vshrq_n_s32
(
vreinterpretq_s32_u32
(
tmp
)
12
)
;
return
ret
;
}
template
<
unsigned
(
*
tile
)
(
SkFixed
int
)
int16x8_t
(
*
tile8
)
(
int32x4_t
int32x4_t
unsigned
)
bool
tryDecal
>
static
void
nofilter_scale_neon
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
const
unsigned
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
SkFractionalInt
fx
;
{
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
const
unsigned
maxY
=
s
.
fPixmap
.
height
(
)
-
1
;
*
xy
+
+
=
tile
(
mapper
.
fixedY
(
)
maxY
)
;
fx
=
mapper
.
fractionalIntX
(
)
;
}
if
(
0
=
=
maxX
)
{
memset
(
xy
0
count
*
sizeof
(
uint16_t
)
)
;
return
;
}
const
SkFractionalInt
dx
=
s
.
fInvSxFractionalInt
;
const
SkFixed
fixedFx
=
SkFractionalIntToFixed
(
fx
)
;
const
SkFixed
fixedDx
=
SkFractionalIntToFixed
(
dx
)
;
if
(
tryDecal
&
&
can_truncate_to_fixed_for_decal
(
fixedFx
fixedDx
count
maxX
)
)
{
decal_nofilter_scale_neon
(
xy
fixedFx
fixedDx
count
)
;
return
;
}
if
(
count
>
=
8
)
{
SkFractionalInt
dx2
=
dx
+
dx
;
SkFractionalInt
dx4
=
dx2
+
dx2
;
SkFractionalInt
dx8
=
dx4
+
dx4
;
SkFractionalInt
fx1
fx2
fx3
;
int32x4_t
lbase
hbase
;
int16_t
*
dst16
=
(
int16_t
*
)
xy
;
fx1
=
fx
+
dx
;
fx2
=
fx1
+
dx
;
fx3
=
fx2
+
dx
;
lbase
=
vdupq_n_s32
(
SkFractionalIntToFixed
(
fx
)
)
;
lbase
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx1
)
lbase
1
)
;
lbase
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx2
)
lbase
2
)
;
lbase
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx3
)
lbase
3
)
;
hbase
=
vaddq_s32
(
lbase
vdupq_n_s32
(
SkFractionalIntToFixed
(
dx4
)
)
)
;
while
(
count
>
=
8
)
{
int16x8_t
fx8
;
fx8
=
tile8
(
lbase
hbase
maxX
)
;
vst1q_s16
(
dst16
fx8
)
;
lbase
=
vaddq_s32
(
lbase
vdupq_n_s32
(
SkFractionalIntToFixed
(
dx8
)
)
)
;
hbase
=
vaddq_s32
(
hbase
vdupq_n_s32
(
SkFractionalIntToFixed
(
dx8
)
)
)
;
dst16
+
=
8
;
count
-
=
8
;
fx
+
=
dx8
;
}
xy
=
(
uint32_t
*
)
dst16
;
}
uint16_t
*
xx
=
(
uint16_t
*
)
xy
;
for
(
int
i
=
count
;
i
>
0
;
-
-
i
)
{
*
xx
+
+
=
tile
(
SkFractionalIntToFixed
(
fx
)
maxX
)
;
fx
+
=
dx
;
}
}
template
<
unsigned
(
*
tile
)
(
SkFixed
int
)
int32x4_t
(
*
tile4
)
(
int32x4_t
unsigned
)
unsigned
(
*
extract_low_bits
)
(
SkFixed
int
)
int32x4_t
(
*
extract_low_bits4
)
(
int32x4_t
unsigned
)
bool
tryDecal
>
static
void
filter_scale_neon
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
=
=
0
)
;
SkASSERT
(
s
.
fInvKy
=
=
0
)
;
auto
pack
=
[
&
]
(
SkFixed
f
unsigned
max
SkFixed
one
)
{
unsigned
i
=
tile
(
f
max
)
;
i
=
(
i
<
<
4
)
|
extract_low_bits
(
f
max
)
;
return
(
i
<
<
14
)
|
(
tile
(
(
f
+
one
)
max
)
)
;
}
;
auto
pack4
=
[
&
]
(
int32x4_t
f
unsigned
max
SkFixed
one
)
{
int32x4_t
ret
res
;
res
=
tile4
(
f
max
)
;
ret
=
extract_low_bits4
(
f
max
)
;
ret
=
vsliq_n_s32
(
ret
res
4
)
;
res
=
tile4
(
f
+
vdupq_n_s32
(
one
)
max
)
;
ret
=
vorrq_s32
(
vshlq_n_s32
(
ret
14
)
res
)
;
return
ret
;
}
;
const
unsigned
maxX
=
s
.
fPixmap
.
width
(
)
-
1
;
const
SkFixed
one
=
s
.
fFilterOneX
;
const
SkFractionalInt
dx
=
s
.
fInvSxFractionalInt
;
SkFractionalInt
fx
;
{
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
const
SkFixed
fy
=
mapper
.
fixedY
(
)
;
const
unsigned
maxY
=
s
.
fPixmap
.
height
(
)
-
1
;
*
xy
+
+
=
pack
(
fy
maxY
s
.
fFilterOneY
)
;
fx
=
mapper
.
fractionalIntX
(
)
;
}
const
SkFixed
fixedFx
=
SkFractionalIntToFixed
(
fx
)
;
const
SkFixed
fixedDx
=
SkFractionalIntToFixed
(
dx
)
;
if
(
tryDecal
&
&
can_truncate_to_fixed_for_decal
(
fixedFx
fixedDx
count
maxX
)
)
{
decal_filter_scale_neon
(
xy
fixedFx
fixedDx
count
)
;
return
;
}
if
(
count
>
=
4
)
{
int32x4_t
wide_fx
;
wide_fx
=
vdupq_n_s32
(
SkFractionalIntToFixed
(
fx
)
)
;
wide_fx
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx
+
dx
)
wide_fx
1
)
;
wide_fx
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx
+
dx
+
dx
)
wide_fx
2
)
;
wide_fx
=
vsetq_lane_s32
(
SkFractionalIntToFixed
(
fx
+
dx
+
dx
+
dx
)
wide_fx
3
)
;
while
(
count
>
=
4
)
{
int32x4_t
res
;
res
=
pack4
(
wide_fx
maxX
one
)
;
vst1q_u32
(
xy
vreinterpretq_u32_s32
(
res
)
)
;
wide_fx
+
=
vdupq_n_s32
(
SkFractionalIntToFixed
(
dx
+
dx
+
dx
+
dx
)
)
;
fx
+
=
dx
+
dx
+
dx
+
dx
;
xy
+
=
4
;
count
-
=
4
;
}
}
while
(
-
-
count
>
=
0
)
{
*
xy
+
+
=
pack
(
SkFractionalIntToFixed
(
fx
)
maxX
one
)
;
fx
+
=
dx
;
}
}
static
const
SkBitmapProcState
:
:
MatrixProc
ClampX_ClampY_Procs
[
]
=
{
nofilter_scale_neon
<
clamp
clamp8
true
>
filter_scale_neon
<
clamp
clamp4
extract_low_bits_clamp
extract_low_bits_clamp4
true
>
}
;
static
const
SkBitmapProcState
:
:
MatrixProc
RepeatX_RepeatY_Procs
[
]
=
{
nofilter_scale_neon
<
repeat
repeat8
false
>
filter_scale_neon
<
repeat
repeat4
extract_low_bits_repeat_mirror
extract_low_bits_repeat_mirror4
false
>
}
;
#
else
static
const
SkBitmapProcState
:
:
MatrixProc
ClampX_ClampY_Procs
[
]
=
{
nofilter_scale
<
clamp
true
>
filter_scale
<
clamp
extract_low_bits_clamp
true
>
}
;
static
const
SkBitmapProcState
:
:
MatrixProc
RepeatX_RepeatY_Procs
[
]
=
{
nofilter_scale
<
repeat
false
>
filter_scale
<
repeat
extract_low_bits_repeat_mirror
false
>
}
;
#
endif
static
inline
U16CPU
int_clamp
(
int
x
int
n
)
{
if
(
x
<
0
)
{
x
=
0
;
}
if
(
x
>
=
n
)
{
x
=
n
-
1
;
}
return
x
;
}
static
inline
int
sk_int_mod
(
int
x
int
n
)
{
SkASSERT
(
n
>
0
)
;
if
(
(
unsigned
)
x
>
=
(
unsigned
)
n
)
{
if
(
x
<
0
)
{
x
=
n
+
~
(
~
x
%
n
)
;
}
else
{
x
=
x
%
n
;
}
}
return
x
;
}
static
inline
U16CPU
int_repeat
(
int
x
int
n
)
{
return
sk_int_mod
(
x
n
)
;
}
static
inline
U16CPU
int_mirror
(
int
x
int
n
)
{
x
=
sk_int_mod
(
x
2
*
n
)
;
if
(
x
>
=
n
)
{
x
=
n
+
~
(
x
-
n
)
;
}
return
x
;
}
static
void
fill_sequential
(
uint16_t
xptr
[
]
int
pos
int
count
)
{
while
(
count
-
-
>
0
)
{
*
xptr
+
+
=
pos
+
+
;
}
}
static
void
fill_backwards
(
uint16_t
xptr
[
]
int
pos
int
count
)
{
while
(
count
-
-
>
0
)
{
SkASSERT
(
pos
>
=
0
)
;
*
xptr
+
+
=
pos
-
-
;
}
}
static
void
clampx_nofilter_trans
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
SkMatrix
:
:
kTranslate_Mask
)
=
=
0
)
;
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
*
xy
+
+
=
int_clamp
(
mapper
.
intY
(
)
s
.
fPixmap
.
height
(
)
)
;
int
xpos
=
mapper
.
intX
(
)
;
const
int
width
=
s
.
fPixmap
.
width
(
)
;
if
(
1
=
=
width
)
{
memset
(
xy
0
count
*
sizeof
(
uint16_t
)
)
;
return
;
}
uint16_t
*
xptr
=
reinterpret_cast
<
uint16_t
*
>
(
xy
)
;
int
n
;
if
(
xpos
<
0
)
{
n
=
-
xpos
;
if
(
n
>
count
)
{
n
=
count
;
}
memset
(
xptr
0
n
*
sizeof
(
uint16_t
)
)
;
count
-
=
n
;
if
(
0
=
=
count
)
{
return
;
}
xptr
+
=
n
;
xpos
=
0
;
}
if
(
xpos
<
width
)
{
n
=
width
-
xpos
;
if
(
n
>
count
)
{
n
=
count
;
}
fill_sequential
(
xptr
xpos
n
)
;
count
-
=
n
;
if
(
0
=
=
count
)
{
return
;
}
xptr
+
=
n
;
}
sk_memset16
(
xptr
width
-
1
count
)
;
}
static
void
repeatx_nofilter_trans
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
SkMatrix
:
:
kTranslate_Mask
)
=
=
0
)
;
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
*
xy
+
+
=
int_repeat
(
mapper
.
intY
(
)
s
.
fPixmap
.
height
(
)
)
;
int
xpos
=
mapper
.
intX
(
)
;
const
int
width
=
s
.
fPixmap
.
width
(
)
;
if
(
1
=
=
width
)
{
memset
(
xy
0
count
*
sizeof
(
uint16_t
)
)
;
return
;
}
uint16_t
*
xptr
=
reinterpret_cast
<
uint16_t
*
>
(
xy
)
;
int
start
=
sk_int_mod
(
xpos
width
)
;
int
n
=
width
-
start
;
if
(
n
>
count
)
{
n
=
count
;
}
fill_sequential
(
xptr
start
n
)
;
xptr
+
=
n
;
count
-
=
n
;
while
(
count
>
=
width
)
{
fill_sequential
(
xptr
0
width
)
;
xptr
+
=
width
;
count
-
=
width
;
}
if
(
count
>
0
)
{
fill_sequential
(
xptr
0
count
)
;
}
}
static
void
mirrorx_nofilter_trans
(
const
SkBitmapProcState
&
s
uint32_t
xy
[
]
int
count
int
x
int
y
)
{
SkASSERT
(
(
s
.
fInvType
&
~
SkMatrix
:
:
kTranslate_Mask
)
=
=
0
)
;
const
SkBitmapProcStateAutoMapper
mapper
(
s
x
y
)
;
*
xy
+
+
=
int_mirror
(
mapper
.
intY
(
)
s
.
fPixmap
.
height
(
)
)
;
int
xpos
=
mapper
.
intX
(
)
;
const
int
width
=
s
.
fPixmap
.
width
(
)
;
if
(
1
=
=
width
)
{
memset
(
xy
0
count
*
sizeof
(
uint16_t
)
)
;
return
;
}
uint16_t
*
xptr
=
reinterpret_cast
<
uint16_t
*
>
(
xy
)
;
bool
forward
;
int
n
;
int
start
=
sk_int_mod
(
xpos
2
*
width
)
;
if
(
start
>
=
width
)
{
start
=
width
+
~
(
start
-
width
)
;
forward
=
false
;
n
=
start
+
1
;
}
else
{
forward
=
true
;
n
=
width
-
start
;
}
if
(
n
>
count
)
{
n
=
count
;
}
if
(
forward
)
{
fill_sequential
(
xptr
start
n
)
;
}
else
{
fill_backwards
(
xptr
start
n
)
;
}
forward
=
!
forward
;
xptr
+
=
n
;
count
-
=
n
;
while
(
count
>
=
width
)
{
if
(
forward
)
{
fill_sequential
(
xptr
0
width
)
;
}
else
{
fill_backwards
(
xptr
width
-
1
width
)
;
}
forward
=
!
forward
;
xptr
+
=
width
;
count
-
=
width
;
}
if
(
count
>
0
)
{
if
(
forward
)
{
fill_sequential
(
xptr
0
count
)
;
}
else
{
fill_backwards
(
xptr
width
-
1
count
)
;
}
}
}
SkBitmapProcState
:
:
MatrixProc
SkBitmapProcState
:
:
chooseMatrixProc
(
bool
translate_only_matrix
)
{
SkASSERT
(
fInvType
<
=
(
SkMatrix
:
:
kTranslate_Mask
|
SkMatrix
:
:
kScale_Mask
)
)
;
SkASSERT
(
fTileModeX
=
=
fTileModeY
)
;
SkASSERT
(
fTileModeX
!
=
SkTileMode
:
:
kDecal
)
;
if
(
translate_only_matrix
&
&
kNone_SkFilterQuality
=
=
fFilterQuality
)
{
switch
(
fTileModeX
)
{
default
:
SkASSERT
(
false
)
;
case
SkTileMode
:
:
kClamp
:
return
clampx_nofilter_trans
;
case
SkTileMode
:
:
kRepeat
:
return
repeatx_nofilter_trans
;
case
SkTileMode
:
:
kMirror
:
return
mirrorx_nofilter_trans
;
}
}
int
index
=
fFilterQuality
>
kNone_SkFilterQuality
?
1
:
0
;
if
(
fTileModeX
=
=
SkTileMode
:
:
kClamp
)
{
fFilterOneX
=
SK_Fixed1
;
fFilterOneY
=
SK_Fixed1
;
return
ClampX_ClampY_Procs
[
index
]
;
}
fFilterOneX
=
SK_Fixed1
/
fPixmap
.
width
(
)
;
fFilterOneY
=
SK_Fixed1
/
fPixmap
.
height
(
)
;
if
(
fTileModeX
=
=
SkTileMode
:
:
kRepeat
)
{
return
RepeatX_RepeatY_Procs
[
index
]
;
}
return
MirrorX_MirrorY_Procs
[
index
]
;
}
