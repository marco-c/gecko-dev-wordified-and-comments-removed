#
ifndef
SkRasterPipelineOpContexts_DEFINED
#
define
SkRasterPipelineOpContexts_DEFINED
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
namespace
SkSL
{
class
TraceHook
;
}
inline
static
constexpr
int
SkRasterPipeline_kMaxStride
=
16
;
inline
static
constexpr
int
SkRasterPipeline_kMaxStride_highp
=
16
;
inline
static
constexpr
size_t
SkRasterPipeline_MaxScratchPerPatch
=
std
:
:
max
(
SkRasterPipeline_kMaxStride_highp
*
16
SkRasterPipeline_kMaxStride
*
4
)
;
struct
SkRasterPipeline_MemoryCtx
{
void
*
pixels
;
int
stride
;
}
;
struct
SkRasterPipeline_MemoryCtxInfo
{
SkRasterPipeline_MemoryCtx
*
context
;
int
bytesPerPixel
;
bool
load
;
bool
store
;
}
;
struct
SkRasterPipeline_MemoryCtxPatch
{
SkRasterPipeline_MemoryCtxInfo
info
;
void
*
backup
;
std
:
:
byte
scratch
[
SkRasterPipeline_MaxScratchPerPatch
]
;
}
;
struct
SkRasterPipeline_GatherCtx
{
const
void
*
pixels
;
int
stride
;
float
width
;
float
height
;
float
weights
[
16
]
;
bool
roundDownAtInteger
=
false
;
}
;
struct
SkRasterPipeline_SamplerCtx
{
float
x
[
SkRasterPipeline_kMaxStride_highp
]
;
float
y
[
SkRasterPipeline_kMaxStride_highp
]
;
float
fx
[
SkRasterPipeline_kMaxStride_highp
]
;
float
fy
[
SkRasterPipeline_kMaxStride_highp
]
;
float
scalex
[
SkRasterPipeline_kMaxStride_highp
]
;
float
scaley
[
SkRasterPipeline_kMaxStride_highp
]
;
float
weights
[
16
]
;
float
wx
[
4
]
[
SkRasterPipeline_kMaxStride_highp
]
;
float
wy
[
4
]
[
SkRasterPipeline_kMaxStride_highp
]
;
}
;
struct
SkRasterPipeline_TileCtx
{
float
scale
;
float
invScale
;
int
mirrorBiasDir
=
-
1
;
}
;
struct
SkRasterPipeline_DecalTileCtx
{
uint32_t
mask
[
SkRasterPipeline_kMaxStride
]
;
float
limit_x
;
float
limit_y
;
float
inclusiveEdge_x
=
0
;
float
inclusiveEdge_y
=
0
;
}
;
enum
class
SkPerlinNoiseShaderType
;
struct
SkRasterPipeline_PerlinNoiseCtx
{
SkPerlinNoiseShaderType
noiseType
;
float
baseFrequencyX
baseFrequencyY
;
float
stitchDataInX
stitchDataInY
;
bool
stitching
;
int
numOctaves
;
const
uint8_t
*
latticeSelector
;
const
uint16_t
*
noiseData
;
}
;
struct
SkRasterPipeline_MipmapCtx
{
float
x
[
SkRasterPipeline_kMaxStride_highp
]
;
float
y
[
SkRasterPipeline_kMaxStride_highp
]
;
float
r
[
SkRasterPipeline_kMaxStride_highp
]
;
float
g
[
SkRasterPipeline_kMaxStride_highp
]
;
float
b
[
SkRasterPipeline_kMaxStride_highp
]
;
float
a
[
SkRasterPipeline_kMaxStride_highp
]
;
float
scaleX
;
float
scaleY
;
float
lowerWeight
;
}
;
struct
SkRasterPipeline_CoordClampCtx
{
float
min_x
min_y
;
float
max_x
max_y
;
}
;
struct
SkRasterPipeline_CallbackCtx
{
void
(
*
fn
)
(
SkRasterPipeline_CallbackCtx
*
self
int
active_pixels
)
;
float
rgba
[
4
*
SkRasterPipeline_kMaxStride_highp
]
;
float
*
read_from
=
rgba
;
}
;
struct
SkRasterPipelineStage
;
struct
SkRasterPipeline_RewindCtx
{
float
r
[
SkRasterPipeline_kMaxStride_highp
]
;
float
g
[
SkRasterPipeline_kMaxStride_highp
]
;
float
b
[
SkRasterPipeline_kMaxStride_highp
]
;
float
a
[
SkRasterPipeline_kMaxStride_highp
]
;
float
dr
[
SkRasterPipeline_kMaxStride_highp
]
;
float
dg
[
SkRasterPipeline_kMaxStride_highp
]
;
float
db
[
SkRasterPipeline_kMaxStride_highp
]
;
float
da
[
SkRasterPipeline_kMaxStride_highp
]
;
std
:
:
byte
*
base
;
SkRasterPipelineStage
*
stage
;
}
;
struct
SkRasterPipeline_GradientCtx
{
size_t
stopCount
;
float
*
fs
[
4
]
;
float
*
bs
[
4
]
;
float
*
ts
;
}
;
struct
SkRasterPipeline_EvenlySpaced2StopGradientCtx
{
float
f
[
4
]
;
float
b
[
4
]
;
}
;
struct
SkRasterPipeline_2PtConicalCtx
{
uint32_t
fMask
[
SkRasterPipeline_kMaxStride_highp
]
;
float
fP0
fP1
;
}
;
struct
SkRasterPipeline_UniformColorCtx
{
float
r
g
b
a
;
uint16_t
rgba
[
4
]
;
}
;
struct
SkRasterPipeline_EmbossCtx
{
SkRasterPipeline_MemoryCtx
mul
add
;
}
;
struct
SkRasterPipeline_TablesCtx
{
const
uint8_t
*
r
*
g
*
b
*
a
;
}
;
using
SkRPOffset
=
uint32_t
;
struct
SkRasterPipeline_InitLaneMasksCtx
{
uint8_t
*
tail
;
}
;
struct
SkRasterPipeline_ConstantCtx
{
int32_t
value
;
SkRPOffset
dst
;
}
;
struct
SkRasterPipeline_UniformCtx
{
int32_t
*
dst
;
const
int32_t
*
src
;
}
;
struct
SkRasterPipeline_BinaryOpCtx
{
SkRPOffset
dst
;
SkRPOffset
src
;
}
;
struct
SkRasterPipeline_TernaryOpCtx
{
SkRPOffset
dst
;
SkRPOffset
delta
;
}
;
struct
SkRasterPipeline_MatrixMultiplyCtx
{
SkRPOffset
dst
;
uint8_t
leftColumns
leftRows
rightColumns
rightRows
;
}
;
struct
SkRasterPipeline_SwizzleCtx
{
static_assert
(
SkRasterPipeline_kMaxStride_highp
<
=
16
)
;
SkRPOffset
dst
;
uint8_t
offsets
[
4
]
;
}
;
struct
SkRasterPipeline_ShuffleCtx
{
int32_t
*
ptr
;
int
count
;
uint16_t
offsets
[
16
]
;
}
;
struct
SkRasterPipeline_SwizzleCopyCtx
{
int32_t
*
dst
;
const
int32_t
*
src
;
uint16_t
offsets
[
4
]
;
}
;
struct
SkRasterPipeline_CopyIndirectCtx
{
int32_t
*
dst
;
const
int32_t
*
src
;
const
uint32_t
*
indirectOffset
;
uint32_t
indirectLimit
;
uint32_t
slots
;
}
;
struct
SkRasterPipeline_SwizzleCopyIndirectCtx
:
public
SkRasterPipeline_CopyIndirectCtx
{
uint16_t
offsets
[
4
]
;
}
;
struct
SkRasterPipeline_BranchCtx
{
int
offset
;
}
;
struct
SkRasterPipeline_BranchIfAllLanesActiveCtx
:
public
SkRasterPipeline_BranchCtx
{
uint8_t
*
tail
=
nullptr
;
}
;
struct
SkRasterPipeline_BranchIfEqualCtx
:
public
SkRasterPipeline_BranchCtx
{
int
value
;
const
int
*
ptr
;
}
;
struct
SkRasterPipeline_CaseOpCtx
{
int
expectedValue
;
SkRPOffset
offset
;
}
;
struct
SkRasterPipeline_TraceFuncCtx
{
const
int
*
traceMask
;
SkSL
:
:
TraceHook
*
traceHook
;
int
funcIdx
;
}
;
struct
SkRasterPipeline_TraceScopeCtx
{
const
int
*
traceMask
;
SkSL
:
:
TraceHook
*
traceHook
;
int
delta
;
}
;
struct
SkRasterPipeline_TraceLineCtx
{
const
int
*
traceMask
;
SkSL
:
:
TraceHook
*
traceHook
;
int
lineNumber
;
}
;
struct
SkRasterPipeline_TraceVarCtx
{
const
int
*
traceMask
;
SkSL
:
:
TraceHook
*
traceHook
;
int
slotIdx
numSlots
;
const
int
*
data
;
const
uint32_t
*
indirectOffset
;
uint32_t
indirectLimit
;
}
;
#
endif
