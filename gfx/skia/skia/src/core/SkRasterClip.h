#
ifndef
SkRasterClip_DEFINED
#
define
SkRasterClip_DEFINED
#
include
"
SkRegion
.
h
"
#
include
"
SkAAClip
.
h
"
class
SkRRect
;
class
SkRasterClip
{
public
:
SkRasterClip
(
bool
forceConservativeRects
=
false
)
;
SkRasterClip
(
const
SkIRect
&
bool
forceConservativeRects
=
false
)
;
SkRasterClip
(
const
SkRasterClip
&
)
;
~
SkRasterClip
(
)
;
bool
isForceConservativeRects
(
)
const
{
return
fForceConservativeRects
;
}
bool
isBW
(
)
const
{
return
fIsBW
;
}
bool
isAA
(
)
const
{
return
!
fIsBW
;
}
const
SkRegion
&
bwRgn
(
)
const
{
SkASSERT
(
fIsBW
)
;
return
fBW
;
}
const
SkAAClip
&
aaRgn
(
)
const
{
SkASSERT
(
!
fIsBW
)
;
return
fAA
;
}
bool
isEmpty
(
)
const
{
SkASSERT
(
this
-
>
computeIsEmpty
(
)
=
=
fIsEmpty
)
;
return
fIsEmpty
;
}
bool
isRect
(
)
const
{
SkASSERT
(
this
-
>
computeIsRect
(
)
=
=
fIsRect
)
;
return
fIsRect
;
}
bool
isComplex
(
)
const
;
const
SkIRect
&
getBounds
(
)
const
;
bool
setEmpty
(
)
;
bool
setRect
(
const
SkIRect
&
)
;
bool
op
(
const
SkIRect
&
SkRegion
:
:
Op
)
;
bool
op
(
const
SkRegion
&
SkRegion
:
:
Op
)
;
bool
op
(
const
SkRect
&
const
SkIRect
&
SkRegion
:
:
Op
bool
doAA
)
;
bool
op
(
const
SkRRect
&
const
SkIRect
&
SkRegion
:
:
Op
bool
doAA
)
;
bool
op
(
const
SkPath
&
const
SkIRect
&
SkRegion
:
:
Op
bool
doAA
)
;
void
translate
(
int
dx
int
dy
SkRasterClip
*
dst
)
const
;
void
translate
(
int
dx
int
dy
)
{
this
-
>
translate
(
dx
dy
this
)
;
}
bool
quickContains
(
const
SkIRect
&
rect
)
const
;
bool
quickContains
(
int
left
int
top
int
right
int
bottom
)
const
{
return
quickContains
(
SkIRect
:
:
MakeLTRB
(
left
top
right
bottom
)
)
;
}
bool
quickReject
(
const
SkIRect
&
rect
)
const
{
return
!
SkIRect
:
:
Intersects
(
this
-
>
getBounds
(
)
rect
)
;
}
const
SkRegion
&
forceGetBW
(
)
;
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
private
:
SkRegion
fBW
;
SkAAClip
fAA
;
bool
fForceConservativeRects
;
bool
fIsBW
;
bool
fIsEmpty
;
bool
fIsRect
;
bool
computeIsEmpty
(
)
const
{
return
fIsBW
?
fBW
.
isEmpty
(
)
:
fAA
.
isEmpty
(
)
;
}
bool
computeIsRect
(
)
const
{
return
fIsBW
?
fBW
.
isRect
(
)
:
fAA
.
isRect
(
)
;
}
bool
updateCacheAndReturnNonEmpty
(
bool
detectAARect
=
true
)
{
fIsEmpty
=
this
-
>
computeIsEmpty
(
)
;
if
(
detectAARect
&
&
!
fIsEmpty
&
&
!
fIsBW
&
&
fAA
.
isRect
(
)
)
{
fBW
.
setRect
(
fAA
.
getBounds
(
)
)
;
fAA
.
setEmpty
(
)
;
fIsBW
=
true
;
}
fIsRect
=
this
-
>
computeIsRect
(
)
;
return
!
fIsEmpty
;
}
void
convertToAA
(
)
;
bool
setPath
(
const
SkPath
&
path
const
SkRegion
&
clip
bool
doAA
)
;
bool
setPath
(
const
SkPath
&
path
const
SkIRect
&
clip
bool
doAA
)
;
bool
op
(
const
SkRasterClip
&
SkRegion
:
:
Op
)
;
bool
setConservativeRect
(
const
SkRect
&
r
const
SkIRect
&
clipR
bool
isInverse
)
;
}
;
class
SkAutoRasterClipValidate
:
SkNoncopyable
{
public
:
SkAutoRasterClipValidate
(
const
SkRasterClip
&
rc
)
:
fRC
(
rc
)
{
fRC
.
validate
(
)
;
}
~
SkAutoRasterClipValidate
(
)
{
fRC
.
validate
(
)
;
}
private
:
const
SkRasterClip
&
fRC
;
}
;
#
define
SkAutoRasterClipValidate
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoRasterClipValidate
)
#
ifdef
SK_DEBUG
#
define
AUTO_RASTERCLIP_VALIDATE
(
rc
)
SkAutoRasterClipValidate
arcv
(
rc
)
#
else
#
define
AUTO_RASTERCLIP_VALIDATE
(
rc
)
#
endif
class
SkAAClipBlitterWrapper
{
public
:
SkAAClipBlitterWrapper
(
)
;
SkAAClipBlitterWrapper
(
const
SkRasterClip
&
SkBlitter
*
)
;
SkAAClipBlitterWrapper
(
const
SkAAClip
*
SkBlitter
*
)
;
void
init
(
const
SkRasterClip
&
SkBlitter
*
)
;
const
SkIRect
&
getBounds
(
)
const
{
SkASSERT
(
fClipRgn
)
;
return
fClipRgn
-
>
getBounds
(
)
;
}
const
SkRegion
&
getRgn
(
)
const
{
SkASSERT
(
fClipRgn
)
;
return
*
fClipRgn
;
}
SkBlitter
*
getBlitter
(
)
{
SkASSERT
(
fBlitter
)
;
return
fBlitter
;
}
private
:
SkRegion
fBWRgn
;
SkAAClipBlitter
fAABlitter
;
const
SkRegion
*
fClipRgn
;
SkBlitter
*
fBlitter
;
}
;
#
endif
