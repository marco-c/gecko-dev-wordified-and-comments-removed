#
ifndef
SkRasterClip_DEFINED
#
define
SkRasterClip_DEFINED
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkRegion
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
src
/
core
/
SkAAClip
.
h
"
class
SkBlitter
;
class
SkMatrix
;
class
SkPath
;
class
SkRRect
;
enum
class
SkClipOp
;
class
SkRasterClip
{
public
:
SkRasterClip
(
)
;
explicit
SkRasterClip
(
const
SkIRect
&
)
;
explicit
SkRasterClip
(
const
SkRegion
&
)
;
explicit
SkRasterClip
(
const
SkRasterClip
&
)
;
SkRasterClip
(
const
SkPath
&
path
const
SkIRect
&
bounds
bool
doAA
)
;
~
SkRasterClip
(
)
;
SkRasterClip
&
operator
=
(
const
SkRasterClip
&
)
;
bool
isBW
(
)
const
{
return
fIsBW
;
}
bool
isAA
(
)
const
{
return
!
fIsBW
;
}
const
SkRegion
&
bwRgn
(
)
const
{
SkASSERT
(
fIsBW
)
;
return
fBW
;
}
const
SkAAClip
&
aaRgn
(
)
const
{
SkASSERT
(
!
fIsBW
)
;
return
fAA
;
}
bool
isEmpty
(
)
const
{
SkASSERT
(
this
-
>
computeIsEmpty
(
)
=
=
fIsEmpty
)
;
return
fIsEmpty
;
}
bool
isRect
(
)
const
{
SkASSERT
(
this
-
>
computeIsRect
(
)
=
=
fIsRect
)
;
return
fIsRect
;
}
bool
isComplex
(
)
const
{
return
fIsBW
?
fBW
.
isComplex
(
)
:
!
fAA
.
isEmpty
(
)
;
}
const
SkIRect
&
getBounds
(
)
const
{
return
fIsBW
?
fBW
.
getBounds
(
)
:
fAA
.
getBounds
(
)
;
}
bool
setEmpty
(
)
;
bool
setRect
(
const
SkIRect
&
)
;
bool
op
(
const
SkIRect
&
SkClipOp
)
;
bool
op
(
const
SkRegion
&
SkClipOp
)
;
bool
op
(
const
SkRect
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
bool
op
(
const
SkRRect
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
bool
op
(
const
SkPath
&
const
SkMatrix
&
matrix
SkClipOp
bool
doAA
)
;
bool
op
(
sk_sp
<
SkShader
>
)
;
void
translate
(
int
dx
int
dy
SkRasterClip
*
dst
)
const
;
bool
quickContains
(
const
SkIRect
&
rect
)
const
{
return
fIsBW
?
fBW
.
quickContains
(
rect
)
:
fAA
.
quickContains
(
rect
)
;
}
bool
quickReject
(
const
SkIRect
&
rect
)
const
{
return
!
SkIRect
:
:
Intersects
(
this
-
>
getBounds
(
)
rect
)
;
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
sk_sp
<
SkShader
>
clipShader
(
)
const
{
return
fShader
;
}
private
:
SkRegion
fBW
;
SkAAClip
fAA
;
bool
fIsBW
;
bool
fIsEmpty
;
bool
fIsRect
;
sk_sp
<
SkShader
>
fShader
;
bool
computeIsEmpty
(
)
const
{
return
fIsBW
?
fBW
.
isEmpty
(
)
:
fAA
.
isEmpty
(
)
;
}
bool
computeIsRect
(
)
const
{
return
fIsBW
?
fBW
.
isRect
(
)
:
fAA
.
isRect
(
)
;
}
bool
updateCacheAndReturnNonEmpty
(
bool
detectAARect
=
true
)
{
fIsEmpty
=
this
-
>
computeIsEmpty
(
)
;
if
(
detectAARect
&
&
!
fIsEmpty
&
&
!
fIsBW
&
&
fAA
.
isRect
(
)
)
{
fBW
.
setRect
(
fAA
.
getBounds
(
)
)
;
fAA
.
setEmpty
(
)
;
fIsBW
=
true
;
}
fIsRect
=
this
-
>
computeIsRect
(
)
;
return
!
fIsEmpty
;
}
void
convertToAA
(
)
;
bool
op
(
const
SkRasterClip
&
SkClipOp
)
;
}
;
class
SkAutoRasterClipValidate
:
SkNoncopyable
{
public
:
SkAutoRasterClipValidate
(
const
SkRasterClip
&
rc
)
:
fRC
(
rc
)
{
fRC
.
validate
(
)
;
}
~
SkAutoRasterClipValidate
(
)
{
fRC
.
validate
(
)
;
}
private
:
const
SkRasterClip
&
fRC
;
}
;
#
ifdef
SK_DEBUG
#
define
AUTO_RASTERCLIP_VALIDATE
(
rc
)
SkAutoRasterClipValidate
arcv
(
rc
)
#
else
#
define
AUTO_RASTERCLIP_VALIDATE
(
rc
)
#
endif
class
SkAAClipBlitterWrapper
{
public
:
SkAAClipBlitterWrapper
(
)
;
SkAAClipBlitterWrapper
(
const
SkRasterClip
&
SkBlitter
*
)
;
SkAAClipBlitterWrapper
(
const
SkAAClip
*
SkBlitter
*
)
;
void
init
(
const
SkRasterClip
&
SkBlitter
*
)
;
const
SkIRect
&
getBounds
(
)
const
{
SkASSERT
(
fClipRgn
)
;
return
fClipRgn
-
>
getBounds
(
)
;
}
const
SkRegion
&
getRgn
(
)
const
{
SkASSERT
(
fClipRgn
)
;
return
*
fClipRgn
;
}
SkBlitter
*
getBlitter
(
)
{
SkASSERT
(
fBlitter
)
;
return
fBlitter
;
}
private
:
SkRegion
fBWRgn
;
SkAAClipBlitter
fAABlitter
;
const
SkRegion
*
fClipRgn
;
SkBlitter
*
fBlitter
;
}
;
#
endif
