#
include
"
include
/
core
/
SkDeferredDisplayListRecorder
.
h
"
#
include
"
include
/
core
/
SkDeferredDisplayList
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
core
/
SkSurfaceCharacterization
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
if
!
defined
(
SK_GANESH
)
SkDeferredDisplayListRecorder
:
:
SkDeferredDisplayListRecorder
(
const
SkSurfaceCharacterization
&
)
{
}
SkDeferredDisplayListRecorder
:
:
~
SkDeferredDisplayListRecorder
(
)
{
}
bool
SkDeferredDisplayListRecorder
:
:
init
(
)
{
return
false
;
}
SkCanvas
*
SkDeferredDisplayListRecorder
:
:
getCanvas
(
)
{
return
nullptr
;
}
sk_sp
<
SkDeferredDisplayList
>
SkDeferredDisplayListRecorder
:
:
detach
(
)
{
return
nullptr
;
}
#
else
#
include
"
include
/
core
/
SkPromiseImageTexture
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
gpu
/
GrYUVABackendTextures
.
h
"
#
include
"
src
/
gpu
/
SkBackingFit
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
image
/
SkImage_Gpu
.
h
"
#
include
"
src
/
image
/
SkImage_GpuYUVA
.
h
"
#
include
"
src
/
image
/
SkSurface_Gpu
.
h
"
SkDeferredDisplayListRecorder
:
:
SkDeferredDisplayListRecorder
(
const
SkSurfaceCharacterization
&
c
)
:
fCharacterization
(
c
)
{
if
(
fCharacterization
.
isValid
(
)
)
{
fContext
=
GrRecordingContextPriv
:
:
MakeDDL
(
fCharacterization
.
refContextInfo
(
)
)
;
}
}
SkDeferredDisplayListRecorder
:
:
~
SkDeferredDisplayListRecorder
(
)
{
if
(
fContext
)
{
auto
proxyProvider
=
fContext
-
>
priv
(
)
.
proxyProvider
(
)
;
proxyProvider
-
>
orphanAllUniqueKeys
(
)
;
}
}
bool
SkDeferredDisplayListRecorder
:
:
init
(
)
{
SkASSERT
(
fContext
)
;
SkASSERT
(
!
fTargetProxy
)
;
SkASSERT
(
!
fLazyProxyData
)
;
SkASSERT
(
!
fSurface
)
;
if
(
!
fCharacterization
.
isValid
(
)
)
{
return
false
;
}
fLazyProxyData
=
sk_sp
<
SkDeferredDisplayList
:
:
LazyProxyData
>
(
new
SkDeferredDisplayList
:
:
LazyProxyData
)
;
auto
proxyProvider
=
fContext
-
>
priv
(
)
.
proxyProvider
(
)
;
const
GrCaps
*
caps
=
fContext
-
>
priv
(
)
.
caps
(
)
;
bool
usesGLFBO0
=
fCharacterization
.
usesGLFBO0
(
)
;
if
(
usesGLFBO0
)
{
if
(
GrBackendApi
:
:
kOpenGL
!
=
fContext
-
>
backend
(
)
|
|
fCharacterization
.
isTextureable
(
)
)
{
return
false
;
}
}
bool
vkRTSupportsInputAttachment
=
fCharacterization
.
vkRTSupportsInputAttachment
(
)
;
if
(
vkRTSupportsInputAttachment
&
&
GrBackendApi
:
:
kVulkan
!
=
fContext
-
>
backend
(
)
)
{
return
false
;
}
if
(
fCharacterization
.
vulkanSecondaryCBCompatible
(
)
)
{
if
(
usesGLFBO0
|
|
vkRTSupportsInputAttachment
|
|
fCharacterization
.
isTextureable
(
)
|
|
fCharacterization
.
origin
(
)
=
=
kBottomLeft_GrSurfaceOrigin
)
{
return
false
;
}
}
GrColorType
grColorType
=
SkColorTypeToGrColorType
(
fCharacterization
.
colorType
(
)
)
;
GrInternalSurfaceFlags
surfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
;
if
(
usesGLFBO0
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kGLRTFBOIDIs0
;
}
else
if
(
fCharacterization
.
sampleCount
(
)
>
1
&
&
!
caps
-
>
msaaResolvesAutomatically
(
)
&
&
fCharacterization
.
isTextureable
(
)
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kRequiresManualMSAAResolve
;
}
if
(
vkRTSupportsInputAttachment
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kVkRTSupportsInputAttachment
;
}
static
constexpr
GrProxyProvider
:
:
TextureInfo
kTextureInfo
{
GrMipmapped
:
:
kNo
GrTextureType
:
:
k2D
}
;
const
GrProxyProvider
:
:
TextureInfo
*
optionalTextureInfo
=
nullptr
;
if
(
fCharacterization
.
isTextureable
(
)
)
{
optionalTextureInfo
=
&
kTextureInfo
;
}
fTargetProxy
=
proxyProvider
-
>
createLazyRenderTargetProxy
(
[
lazyProxyData
=
fLazyProxyData
]
(
GrResourceProvider
*
resourceProvider
const
GrSurfaceProxy
:
:
LazySurfaceDesc
&
)
{
SkASSERT
(
lazyProxyData
-
>
fReplayDest
-
>
peekSurface
(
)
)
;
auto
surface
=
sk_ref_sp
<
GrSurface
>
(
lazyProxyData
-
>
fReplayDest
-
>
peekSurface
(
)
)
;
return
GrSurfaceProxy
:
:
LazyCallbackResult
(
std
:
:
move
(
surface
)
)
;
}
fCharacterization
.
backendFormat
(
)
fCharacterization
.
dimensions
(
)
fCharacterization
.
sampleCount
(
)
surfaceFlags
optionalTextureInfo
GrMipmapStatus
:
:
kNotAllocated
SkBackingFit
:
:
kExact
skgpu
:
:
Budgeted
:
:
kYes
fCharacterization
.
isProtected
(
)
fCharacterization
.
vulkanSecondaryCBCompatible
(
)
GrSurfaceProxy
:
:
UseAllocator
:
:
kYes
)
;
if
(
!
fTargetProxy
)
{
return
false
;
}
fTargetProxy
-
>
priv
(
)
.
setIsDDLTarget
(
)
;
auto
device
=
fContext
-
>
priv
(
)
.
createDevice
(
grColorType
fTargetProxy
fCharacterization
.
refColorSpace
(
)
fCharacterization
.
origin
(
)
fCharacterization
.
surfaceProps
(
)
skgpu
:
:
ganesh
:
:
Device
:
:
InitContents
:
:
kUninit
)
;
if
(
!
device
)
{
return
false
;
}
fSurface
=
sk_make_sp
<
SkSurface_Gpu
>
(
std
:
:
move
(
device
)
)
;
return
SkToBool
(
fSurface
.
get
(
)
)
;
}
SkCanvas
*
SkDeferredDisplayListRecorder
:
:
getCanvas
(
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
if
(
!
fSurface
&
&
!
this
-
>
init
(
)
)
{
return
nullptr
;
}
return
fSurface
-
>
getCanvas
(
)
;
}
sk_sp
<
SkDeferredDisplayList
>
SkDeferredDisplayListRecorder
:
:
detach
(
)
{
if
(
!
fContext
|
|
!
fTargetProxy
)
{
return
nullptr
;
}
if
(
fSurface
)
{
SkCanvas
*
canvas
=
fSurface
-
>
getCanvas
(
)
;
canvas
-
>
restoreToCount
(
0
)
;
}
auto
ddl
=
sk_sp
<
SkDeferredDisplayList
>
(
new
SkDeferredDisplayList
(
fCharacterization
std
:
:
move
(
fTargetProxy
)
std
:
:
move
(
fLazyProxyData
)
)
)
;
fContext
-
>
priv
(
)
.
moveRenderTasksToDDL
(
ddl
.
get
(
)
)
;
fSurface
=
nullptr
;
return
ddl
;
}
#
ifndef
SK_MAKE_PROMISE_TEXTURE_DISABLE_LEGACY_API
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makePromiseTexture
(
const
GrBackendFormat
&
backendFormat
int
width
int
height
GrMipmapped
mipmapped
GrSurfaceOrigin
origin
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureContext
textureContext
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
return
SkImage
:
:
MakePromiseTexture
(
fContext
-
>
threadSafeProxy
(
)
backendFormat
{
width
height
}
mipmapped
origin
colorType
alphaType
std
:
:
move
(
colorSpace
)
textureFulfillProc
textureReleaseProc
textureContext
)
;
}
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makeYUVAPromiseTexture
(
const
GrYUVABackendTextureInfo
&
backendTextureInfo
sk_sp
<
SkColorSpace
>
imageColorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureContext
textureContexts
[
]
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
return
SkImage
:
:
MakePromiseYUVATexture
(
fContext
-
>
threadSafeProxy
(
)
backendTextureInfo
std
:
:
move
(
imageColorSpace
)
textureFulfillProc
textureReleaseProc
textureContexts
)
;
}
#
endif
#
endif
