#
include
"
SkDeferredDisplayListRecorder
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
"
SkDeferredDisplayList
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkSurfaceCharacterization
.
h
"
#
if
!
SK_SUPPORT_GPU
SkDeferredDisplayListRecorder
:
:
SkDeferredDisplayListRecorder
(
const
SkSurfaceCharacterization
&
)
{
}
SkDeferredDisplayListRecorder
:
:
~
SkDeferredDisplayListRecorder
(
)
{
}
bool
SkDeferredDisplayListRecorder
:
:
init
(
)
{
return
false
;
}
SkCanvas
*
SkDeferredDisplayListRecorder
:
:
getCanvas
(
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
SkDeferredDisplayList
>
SkDeferredDisplayListRecorder
:
:
detach
(
)
{
return
nullptr
;
}
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makePromiseTexture
(
const
GrBackendFormat
&
backendFormat
int
width
int
height
GrMipMapped
mipMapped
GrSurfaceOrigin
origin
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureDoneProc
textureDoneProc
PromiseImageTextureContext
textureContext
)
{
return
nullptr
;
}
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makeYUVAPromiseTexture
(
SkYUVColorSpace
yuvColorSpace
const
GrBackendFormat
yuvaFormats
[
]
const
SkISize
yuvaSizes
[
]
const
SkYUVAIndex
yuvaIndices
[
4
]
int
imageWidth
int
imageHeight
GrSurfaceOrigin
imageOrigin
sk_sp
<
SkColorSpace
>
imageColorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureDoneProc
textureDoneProc
PromiseImageTextureContext
textureContexts
[
]
)
{
return
nullptr
;
}
#
else
#
include
"
GrContextPriv
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkImage_Gpu
.
h
"
#
include
"
SkImage_GpuYUVA
.
h
"
#
include
"
SkMakeUnique
.
h
"
#
include
"
SkPromiseImageTexture
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkYUVASizeInfo
.
h
"
SkDeferredDisplayListRecorder
:
:
SkDeferredDisplayListRecorder
(
const
SkSurfaceCharacterization
&
c
)
:
fCharacterization
(
c
)
{
if
(
fCharacterization
.
isValid
(
)
)
{
fContext
=
GrContextPriv
:
:
MakeDDL
(
fCharacterization
.
refContextInfo
(
)
)
;
}
}
SkDeferredDisplayListRecorder
:
:
~
SkDeferredDisplayListRecorder
(
)
{
if
(
fContext
)
{
auto
proxyProvider
=
fContext
-
>
priv
(
)
.
proxyProvider
(
)
;
proxyProvider
-
>
orphanAllUniqueKeys
(
)
;
}
}
bool
SkDeferredDisplayListRecorder
:
:
init
(
)
{
SkASSERT
(
fContext
)
;
SkASSERT
(
!
fLazyProxyData
)
;
SkASSERT
(
!
fSurface
)
;
if
(
!
fCharacterization
.
isValid
(
)
)
{
return
false
;
}
fLazyProxyData
=
sk_sp
<
SkDeferredDisplayList
:
:
LazyProxyData
>
(
new
SkDeferredDisplayList
:
:
LazyProxyData
)
;
auto
proxyProvider
=
fContext
-
>
priv
(
)
.
proxyProvider
(
)
;
bool
usesGLFBO0
=
fCharacterization
.
usesGLFBO0
(
)
;
if
(
usesGLFBO0
)
{
if
(
GrBackendApi
:
:
kOpenGL
!
=
fContext
-
>
backend
(
)
|
|
fCharacterization
.
isTextureable
(
)
)
{
return
false
;
}
}
if
(
fCharacterization
.
vulkanSecondaryCBCompatible
(
)
)
{
if
(
usesGLFBO0
|
|
fCharacterization
.
isTextureable
(
)
|
|
fCharacterization
.
origin
(
)
=
=
kBottomLeft_GrSurfaceOrigin
)
{
return
false
;
}
}
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fWidth
=
fCharacterization
.
width
(
)
;
desc
.
fHeight
=
fCharacterization
.
height
(
)
;
desc
.
fConfig
=
fCharacterization
.
config
(
)
;
desc
.
fSampleCnt
=
fCharacterization
.
stencilCount
(
)
;
sk_sp
<
SkDeferredDisplayList
:
:
LazyProxyData
>
lazyProxyData
=
fLazyProxyData
;
GrInternalSurfaceFlags
surfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
;
if
(
fContext
-
>
priv
(
)
.
caps
(
)
-
>
usesMixedSamples
(
)
&
&
desc
.
fSampleCnt
>
1
&
&
!
usesGLFBO0
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kMixedSampled
;
}
if
(
usesGLFBO0
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kGLRTFBOIDIs0
;
}
static
constexpr
GrProxyProvider
:
:
TextureInfo
kTextureInfo
{
GrMipMapped
:
:
kNo
GrTextureType
:
:
k2D
}
;
const
GrProxyProvider
:
:
TextureInfo
*
optionalTextureInfo
=
nullptr
;
if
(
fCharacterization
.
isTextureable
(
)
)
{
optionalTextureInfo
=
&
kTextureInfo
;
}
const
GrBackendFormat
format
=
fContext
-
>
priv
(
)
.
caps
(
)
-
>
getBackendFormatFromColorType
(
fCharacterization
.
colorType
(
)
)
;
sk_sp
<
GrRenderTargetProxy
>
proxy
=
proxyProvider
-
>
createLazyRenderTargetProxy
(
[
lazyProxyData
]
(
GrResourceProvider
*
resourceProvider
)
{
if
(
!
resourceProvider
)
{
return
sk_sp
<
GrSurface
>
(
)
;
}
SkASSERT
(
lazyProxyData
-
>
fReplayDest
-
>
peekSurface
(
)
)
;
return
sk_ref_sp
<
GrSurface
>
(
lazyProxyData
-
>
fReplayDest
-
>
peekSurface
(
)
)
;
}
format
desc
fCharacterization
.
origin
(
)
surfaceFlags
optionalTextureInfo
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kYes
fCharacterization
.
vulkanSecondaryCBCompatible
(
)
)
;
sk_sp
<
GrSurfaceContext
>
c
=
fContext
-
>
priv
(
)
.
makeWrappedSurfaceContext
(
std
:
:
move
(
proxy
)
fCharacterization
.
refColorSpace
(
)
&
fCharacterization
.
surfaceProps
(
)
)
;
fSurface
=
SkSurface_Gpu
:
:
MakeWrappedRenderTarget
(
fContext
.
get
(
)
sk_ref_sp
(
c
-
>
asRenderTargetContext
(
)
)
)
;
return
SkToBool
(
fSurface
.
get
(
)
)
;
}
SkCanvas
*
SkDeferredDisplayListRecorder
:
:
getCanvas
(
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
if
(
!
fSurface
&
&
!
this
-
>
init
(
)
)
{
return
nullptr
;
}
return
fSurface
-
>
getCanvas
(
)
;
}
std
:
:
unique_ptr
<
SkDeferredDisplayList
>
SkDeferredDisplayListRecorder
:
:
detach
(
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
if
(
fSurface
)
{
SkCanvas
*
canvas
=
fSurface
-
>
getCanvas
(
)
;
canvas
-
>
restoreToCount
(
0
)
;
}
auto
ddl
=
std
:
:
unique_ptr
<
SkDeferredDisplayList
>
(
new
SkDeferredDisplayList
(
fCharacterization
std
:
:
move
(
fLazyProxyData
)
)
)
;
fContext
-
>
priv
(
)
.
moveOpListsToDDL
(
ddl
.
get
(
)
)
;
fSurface
=
nullptr
;
return
ddl
;
}
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makePromiseTexture
(
const
GrBackendFormat
&
backendFormat
int
width
int
height
GrMipMapped
mipMapped
GrSurfaceOrigin
origin
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureDoneProc
textureDoneProc
PromiseImageTextureContext
textureContext
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
return
SkImage_Gpu
:
:
MakePromiseTexture
(
fContext
.
get
(
)
backendFormat
width
height
mipMapped
origin
colorType
alphaType
std
:
:
move
(
colorSpace
)
textureFulfillProc
textureReleaseProc
textureDoneProc
textureContext
)
;
}
sk_sp
<
SkImage
>
SkDeferredDisplayListRecorder
:
:
makeYUVAPromiseTexture
(
SkYUVColorSpace
yuvColorSpace
const
GrBackendFormat
yuvaFormats
[
]
const
SkISize
yuvaSizes
[
]
const
SkYUVAIndex
yuvaIndices
[
4
]
int
imageWidth
int
imageHeight
GrSurfaceOrigin
imageOrigin
sk_sp
<
SkColorSpace
>
imageColorSpace
PromiseImageTextureFulfillProc
textureFulfillProc
PromiseImageTextureReleaseProc
textureReleaseProc
PromiseImageTextureDoneProc
textureDoneProc
PromiseImageTextureContext
textureContexts
[
]
)
{
if
(
!
fContext
)
{
return
nullptr
;
}
return
SkImage_GpuYUVA
:
:
MakePromiseYUVATexture
(
fContext
.
get
(
)
yuvColorSpace
yuvaFormats
yuvaSizes
yuvaIndices
imageWidth
imageHeight
imageOrigin
std
:
:
move
(
imageColorSpace
)
textureFulfillProc
textureReleaseProc
textureDoneProc
textureContexts
)
;
}
#
endif
