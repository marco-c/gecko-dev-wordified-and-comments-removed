#
ifndef
SkMaskFilterBase_DEFINED
#
define
SkMaskFilterBase_DEFINED
#
include
"
include
/
core
/
SkBlurTypes
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkMaskFilter
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
#
include
"
src
/
core
/
SkMask
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
include
/
private
/
GrTypesPriv
.
h
"
#
endif
class
GrClip
;
struct
GrFPArgs
;
class
GrFragmentProcessor
;
class
GrPaint
;
class
GrRecordingContext
;
class
GrRenderTarget
;
class
GrRenderTargetContext
;
class
GrResourceProvider
;
class
GrShape
;
class
GrTexture
;
class
GrTextureProxy
;
class
SkBitmap
;
class
SkBlitter
;
class
SkCachedData
;
class
SkMatrix
;
class
SkPath
;
class
SkRasterClip
;
class
SkRRect
;
class
SkMaskFilterBase
:
public
SkMaskFilter
{
public
:
virtual
SkMask
:
:
Format
getFormat
(
)
const
=
0
;
virtual
bool
filterMask
(
SkMask
*
dst
const
SkMask
&
src
const
SkMatrix
&
SkIPoint
*
margin
)
const
=
0
;
#
if
SK_SUPPORT_GPU
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
GrFPArgs
&
args
)
const
;
bool
hasFragmentProcessor
(
)
const
;
virtual
bool
canFilterMaskGPU
(
const
GrShape
&
const
SkIRect
&
devSpaceShapeBounds
const
SkIRect
&
clipBounds
const
SkMatrix
&
ctm
SkIRect
*
maskRect
)
const
;
virtual
bool
directFilterMaskGPU
(
GrRecordingContext
*
GrRenderTargetContext
*
GrPaint
&
&
paint
const
GrClip
&
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
const
;
virtual
sk_sp
<
GrTextureProxy
>
filterMaskGPU
(
GrRecordingContext
*
sk_sp
<
GrTextureProxy
>
srcProxy
GrColorType
srcColorType
SkAlphaType
srcAlphaType
const
SkMatrix
&
ctm
const
SkIRect
&
maskRect
)
const
;
#
endif
virtual
void
computeFastBounds
(
const
SkRect
&
src
SkRect
*
dest
)
const
;
struct
BlurRec
{
SkScalar
fSigma
;
SkBlurStyle
fStyle
;
}
;
virtual
bool
asABlur
(
BlurRec
*
)
const
;
protected
:
SkMaskFilterBase
(
)
{
}
#
if
SK_SUPPORT_GPU
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
onAsFragmentProcessor
(
const
GrFPArgs
&
)
const
;
virtual
bool
onHasFragmentProcessor
(
)
const
;
#
endif
enum
FilterReturn
{
kFalse_FilterReturn
kTrue_FilterReturn
kUnimplemented_FilterReturn
}
;
class
NinePatch
:
:
:
SkNoncopyable
{
public
:
NinePatch
(
)
:
fCache
(
nullptr
)
{
}
~
NinePatch
(
)
;
SkMask
fMask
;
SkIRect
fOuterRect
;
SkIPoint
fCenter
;
SkCachedData
*
fCache
;
}
;
virtual
FilterReturn
filterRectsToNine
(
const
SkRect
[
]
int
count
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
;
virtual
FilterReturn
filterRRectToNine
(
const
SkRRect
&
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
;
private
:
friend
class
SkDraw
;
bool
filterPath
(
const
SkPath
&
devPath
const
SkMatrix
&
ctm
const
SkRasterClip
&
SkBlitter
*
SkStrokeRec
:
:
InitStyle
)
const
;
bool
filterRRect
(
const
SkRRect
&
devRRect
const
SkMatrix
&
ctm
const
SkRasterClip
&
SkBlitter
*
)
const
;
typedef
SkFlattenable
INHERITED
;
}
;
inline
SkMaskFilterBase
*
as_MFB
(
SkMaskFilter
*
mf
)
{
return
static_cast
<
SkMaskFilterBase
*
>
(
mf
)
;
}
inline
const
SkMaskFilterBase
*
as_MFB
(
const
SkMaskFilter
*
mf
)
{
return
static_cast
<
const
SkMaskFilterBase
*
>
(
mf
)
;
}
inline
const
SkMaskFilterBase
*
as_MFB
(
const
sk_sp
<
SkMaskFilter
>
&
mf
)
{
return
static_cast
<
SkMaskFilterBase
*
>
(
mf
.
get
(
)
)
;
}
#
endif
