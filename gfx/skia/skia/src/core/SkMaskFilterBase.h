#
ifndef
SkMaskFilterBase_DEFINED
#
define
SkMaskFilterBase_DEFINED
#
include
"
include
/
core
/
SkBlurTypes
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkMaskFilter
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
src
/
core
/
SkMask
.
h
"
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
shaders
/
SkShaderBase
.
h
"
#
endif
class
GrClip
;
struct
GrFPArgs
;
class
GrFragmentProcessor
;
class
GrPaint
;
class
GrRecordingContext
;
class
GrRenderTarget
;
namespace
skgpu
{
namespace
ganesh
{
class
SurfaceDrawContext
;
}
}
class
GrResourceProvider
;
class
GrStyledShape
;
class
GrSurfaceProxyView
;
class
GrTexture
;
class
GrTextureProxy
;
class
SkBitmap
;
class
SkBlitter
;
class
SkCachedData
;
class
SkMatrix
;
class
SkPath
;
class
SkRasterClip
;
class
SkRRect
;
class
SkMaskFilterBase
:
public
SkMaskFilter
{
public
:
virtual
SkMask
:
:
Format
getFormat
(
)
const
=
0
;
virtual
bool
filterMask
(
SkMask
*
dst
const
SkMask
&
src
const
SkMatrix
&
SkIPoint
*
margin
)
const
=
0
;
#
if
defined
(
SK_GANESH
)
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
GrFPArgs
&
args
const
SkMatrix
&
ctm
)
const
;
bool
hasFragmentProcessor
(
)
const
;
virtual
bool
canFilterMaskGPU
(
const
GrStyledShape
&
const
SkIRect
&
devSpaceShapeBounds
const
SkIRect
&
clipBounds
const
SkMatrix
&
ctm
SkIRect
*
maskRect
)
const
;
virtual
bool
directFilterMaskGPU
(
GrRecordingContext
*
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
GrPaint
&
&
paint
const
GrClip
*
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
shape
)
const
;
virtual
GrSurfaceProxyView
filterMaskGPU
(
GrRecordingContext
*
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
const
SkMatrix
&
ctm
const
SkIRect
&
maskRect
)
const
;
#
endif
virtual
void
computeFastBounds
(
const
SkRect
&
src
SkRect
*
dest
)
const
;
struct
BlurRec
{
SkScalar
fSigma
;
SkBlurStyle
fStyle
;
}
;
virtual
bool
asABlur
(
BlurRec
*
)
const
;
static
SkFlattenable
:
:
Type
GetFlattenableType
(
)
{
return
kSkMaskFilter_Type
;
}
SkFlattenable
:
:
Type
getFlattenableType
(
)
const
override
{
return
kSkMaskFilter_Type
;
}
protected
:
SkMaskFilterBase
(
)
{
}
#
if
defined
(
SK_GANESH
)
using
MatrixRec
=
SkShaderBase
:
:
MatrixRec
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
onAsFragmentProcessor
(
const
GrFPArgs
&
const
MatrixRec
&
)
const
;
virtual
bool
onHasFragmentProcessor
(
)
const
;
#
endif
enum
FilterReturn
{
kFalse_FilterReturn
kTrue_FilterReturn
kUnimplemented_FilterReturn
}
;
class
NinePatch
:
:
:
SkNoncopyable
{
public
:
NinePatch
(
)
:
fCache
(
nullptr
)
{
}
~
NinePatch
(
)
;
SkMask
fMask
;
SkIRect
fOuterRect
;
SkIPoint
fCenter
;
SkCachedData
*
fCache
;
}
;
virtual
FilterReturn
filterRectsToNine
(
const
SkRect
[
]
int
count
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
;
virtual
FilterReturn
filterRRectToNine
(
const
SkRRect
&
const
SkMatrix
&
const
SkIRect
&
clipBounds
NinePatch
*
)
const
;
private
:
friend
class
SkDraw
;
friend
class
SkDrawBase
;
bool
filterPath
(
const
SkPath
&
devPath
const
SkMatrix
&
ctm
const
SkRasterClip
&
SkBlitter
*
SkStrokeRec
:
:
InitStyle
)
const
;
bool
filterRRect
(
const
SkRRect
&
devRRect
const
SkMatrix
&
ctm
const
SkRasterClip
&
SkBlitter
*
)
const
;
using
INHERITED
=
SkFlattenable
;
}
;
inline
SkMaskFilterBase
*
as_MFB
(
SkMaskFilter
*
mf
)
{
return
static_cast
<
SkMaskFilterBase
*
>
(
mf
)
;
}
inline
const
SkMaskFilterBase
*
as_MFB
(
const
SkMaskFilter
*
mf
)
{
return
static_cast
<
const
SkMaskFilterBase
*
>
(
mf
)
;
}
inline
const
SkMaskFilterBase
*
as_MFB
(
const
sk_sp
<
SkMaskFilter
>
&
mf
)
{
return
static_cast
<
SkMaskFilterBase
*
>
(
mf
.
get
(
)
)
;
}
extern
void
sk_register_blur_maskfilter_createproc
(
)
;
#
endif
