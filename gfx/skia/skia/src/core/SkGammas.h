#
ifndef
SkGammas_DEFINED
#
define
SkGammas_DEFINED
#
include
"
SkColorSpace
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkTemplates
.
h
"
struct
SkGammas
:
SkRefCnt
{
enum
class
Type
{
kNone_Type
kNamed_Type
kValue_Type
kTable_Type
kParam_Type
}
;
struct
Table
{
size_t
fOffset
;
int
fSize
;
const
float
*
table
(
const
SkGammas
*
base
)
const
{
return
SkTAddOffset
<
const
float
>
(
base
sizeof
(
SkGammas
)
+
fOffset
)
;
}
}
;
union
Data
{
Data
(
)
:
fTable
{
0
0
}
{
}
SkGammaNamed
fNamed
;
float
fValue
;
Table
fTable
;
size_t
fParamOffset
;
const
SkColorSpaceTransferFn
&
params
(
const
SkGammas
*
base
)
const
{
return
*
SkTAddOffset
<
const
SkColorSpaceTransferFn
>
(
base
sizeof
(
SkGammas
)
+
fParamOffset
)
;
}
}
;
bool
allChannelsSame
(
)
const
{
Type
type
=
this
-
>
type
(
0
)
;
for
(
int
i
=
1
;
i
<
this
-
>
channels
(
)
;
i
+
+
)
{
if
(
type
!
=
this
-
>
type
(
i
)
)
{
return
false
;
}
}
auto
&
first
=
this
-
>
data
(
0
)
;
for
(
int
i
=
1
;
i
<
this
-
>
channels
(
)
;
i
+
+
)
{
auto
&
data
=
this
-
>
data
(
i
)
;
switch
(
type
)
{
case
Type
:
:
kNone_Type
:
break
;
case
Type
:
:
kNamed_Type
:
if
(
first
.
fNamed
!
=
data
.
fNamed
)
{
return
false
;
}
break
;
case
Type
:
:
kValue_Type
:
if
(
first
.
fValue
!
=
data
.
fValue
)
{
return
false
;
}
break
;
case
Type
:
:
kTable_Type
:
if
(
first
.
fTable
.
fOffset
!
=
data
.
fTable
.
fOffset
)
{
return
false
;
}
if
(
first
.
fTable
.
fSize
!
=
data
.
fTable
.
fSize
)
{
return
false
;
}
break
;
case
Type
:
:
kParam_Type
:
if
(
0
!
=
memcmp
(
&
first
.
params
(
this
)
&
data
.
params
(
this
)
sizeof
(
SkColorSpaceTransferFn
)
)
)
{
return
false
;
}
break
;
}
}
return
true
;
}
bool
isNamed
(
int
i
)
const
{
return
Type
:
:
kNamed_Type
=
=
this
-
>
type
(
i
)
;
}
bool
isValue
(
int
i
)
const
{
return
Type
:
:
kValue_Type
=
=
this
-
>
type
(
i
)
;
}
bool
isTable
(
int
i
)
const
{
return
Type
:
:
kTable_Type
=
=
this
-
>
type
(
i
)
;
}
bool
isParametric
(
int
i
)
const
{
return
Type
:
:
kParam_Type
=
=
this
-
>
type
(
i
)
;
}
const
Data
&
data
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fChannels
)
;
return
fData
[
i
]
;
}
const
float
*
table
(
int
i
)
const
{
SkASSERT
(
this
-
>
isTable
(
i
)
)
;
return
this
-
>
data
(
i
)
.
fTable
.
table
(
this
)
;
}
int
tableSize
(
int
i
)
const
{
SkASSERT
(
this
-
>
isTable
(
i
)
)
;
return
this
-
>
data
(
i
)
.
fTable
.
fSize
;
}
const
SkColorSpaceTransferFn
&
params
(
int
i
)
const
{
SkASSERT
(
this
-
>
isParametric
(
i
)
)
;
return
this
-
>
data
(
i
)
.
params
(
this
)
;
}
Type
type
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fChannels
)
;
return
fType
[
i
]
;
}
int
channels
(
)
const
{
return
fChannels
;
}
SkGammas
(
int
channels
)
:
fChannels
(
channels
)
{
SkASSERT
(
channels
<
=
(
int
)
SK_ARRAY_COUNT
(
fType
)
)
;
for
(
Type
&
t
:
fType
)
{
t
=
Type
:
:
kNone_Type
;
}
}
int
fChannels
;
Data
fData
[
4
]
;
Type
fType
[
4
]
;
void
*
operator
new
(
size_t
size
)
{
return
sk_malloc_throw
(
size
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
p
)
{
sk_free
(
p
)
;
}
}
;
#
endif
