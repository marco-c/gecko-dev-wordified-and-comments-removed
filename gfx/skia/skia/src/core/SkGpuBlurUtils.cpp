#
include
"
src
/
core
/
SkGpuBlurUtils
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrGaussianConvolutionFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrMatrixConvolutionEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
using
Direction
=
GrGaussianConvolutionFragmentProcessor
:
:
Direction
;
static
void
fill_in_2D_gaussian_kernel
(
float
*
kernel
int
width
int
height
SkScalar
sigmaX
SkScalar
sigmaY
)
{
const
float
twoSigmaSqrdX
=
2
.
0f
*
SkScalarToFloat
(
SkScalarSquare
(
sigmaX
)
)
;
const
float
twoSigmaSqrdY
=
2
.
0f
*
SkScalarToFloat
(
SkScalarSquare
(
sigmaY
)
)
;
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigmaX
)
&
&
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigmaY
)
)
;
SkASSERT
(
!
SkScalarNearlyZero
(
twoSigmaSqrdX
)
&
&
!
SkScalarNearlyZero
(
twoSigmaSqrdY
)
)
;
const
float
sigmaXDenom
=
1
.
0f
/
twoSigmaSqrdX
;
const
float
sigmaYDenom
=
1
.
0f
/
twoSigmaSqrdY
;
const
int
xRadius
=
width
/
2
;
const
int
yRadius
=
height
/
2
;
float
sum
=
0
.
0f
;
for
(
int
x
=
0
;
x
<
width
;
x
+
+
)
{
float
xTerm
=
static_cast
<
float
>
(
x
-
xRadius
)
;
xTerm
=
xTerm
*
xTerm
*
sigmaXDenom
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
float
yTerm
=
static_cast
<
float
>
(
y
-
yRadius
)
;
float
xyTerm
=
sk_float_exp
(
-
(
xTerm
+
yTerm
*
yTerm
*
sigmaYDenom
)
)
;
kernel
[
y
*
width
+
x
]
=
xyTerm
;
sum
+
=
xyTerm
;
}
}
float
scale
=
1
.
0f
/
sum
;
for
(
int
i
=
0
;
i
<
width
*
height
;
+
+
i
)
{
kernel
[
i
]
*
=
scale
;
}
}
static
void
convolve_gaussian_1d
(
skgpu
:
:
ganesh
:
:
SurfaceFillContext
*
sfc
GrSurfaceProxyView
srcView
const
SkIRect
srcSubset
SkIVector
dstToSrcOffset
const
SkIRect
&
dstRect
SkAlphaType
srcAlphaType
Direction
direction
int
radius
float
sigma
SkTileMode
mode
)
{
SkASSERT
(
radius
&
&
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
)
)
;
auto
wm
=
SkTileModeToWrapMode
(
mode
)
;
auto
srcRect
=
dstRect
.
makeOffset
(
dstToSrcOffset
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
conv
=
GrGaussianConvolutionFragmentProcessor
:
:
Make
(
std
:
:
move
(
srcView
)
srcAlphaType
direction
radius
sigma
wm
srcSubset
&
srcRect
*
sfc
-
>
caps
(
)
)
;
sfc
-
>
fillRectToRectWithFP
(
srcRect
dstRect
std
:
:
move
(
conv
)
)
;
}
static
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
convolve_gaussian_2d
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
srcView
GrColorType
srcColorType
const
SkIRect
&
srcBounds
const
SkIRect
&
dstBounds
int
radiusX
int
radiusY
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
mode
sk_sp
<
SkColorSpace
>
finalCS
SkBackingFit
dstFit
)
{
SkASSERT
(
radiusX
&
&
radiusY
)
;
SkASSERT
(
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigmaX
)
&
&
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigmaY
)
)
;
auto
sdc
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
Make
(
rContext
srcColorType
std
:
:
move
(
finalCS
)
dstFit
dstBounds
.
size
(
)
SkSurfaceProps
(
)
"
SurfaceDrawContext_ConvolveGaussian2d
"
1
GrMipmapped
:
:
kNo
srcView
.
proxy
(
)
-
>
isProtected
(
)
srcView
.
origin
(
)
)
;
if
(
!
sdc
)
{
return
nullptr
;
}
SkISize
size
=
SkISize
:
:
Make
(
SkGpuBlurUtils
:
:
KernelWidth
(
radiusX
)
SkGpuBlurUtils
:
:
KernelWidth
(
radiusY
)
)
;
SkIPoint
kernelOffset
=
SkIPoint
:
:
Make
(
radiusX
radiusY
)
;
GrPaint
paint
;
auto
wm
=
SkTileModeToWrapMode
(
mode
)
;
SkASSERT
(
size
.
area
(
)
<
=
GrMatrixConvolutionEffect
:
:
kMaxUniformSize
)
;
float
kernel
[
GrMatrixConvolutionEffect
:
:
kMaxUniformSize
]
;
fill_in_2D_gaussian_kernel
(
kernel
size
.
width
(
)
size
.
height
(
)
sigmaX
sigmaY
)
;
auto
conv
=
GrMatrixConvolutionEffect
:
:
Make
(
rContext
std
:
:
move
(
srcView
)
srcBounds
size
kernel
1
.
0f
0
.
0f
kernelOffset
wm
true
*
sdc
-
>
caps
(
)
)
;
paint
.
setColorFragmentProcessor
(
std
:
:
move
(
conv
)
)
;
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
sdc
-
>
fillRectToRect
(
nullptr
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
dstBounds
.
size
(
)
)
SkRect
:
:
Make
(
dstBounds
)
)
;
return
sdc
;
}
static
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
convolve_gaussian
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
SkIRect
srcBounds
SkIRect
dstBounds
Direction
direction
int
radius
float
sigma
SkTileMode
mode
sk_sp
<
SkColorSpace
>
finalCS
SkBackingFit
fit
)
{
using
namespace
SkGpuBlurUtils
;
SkASSERT
(
radius
>
0
&
&
!
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
)
)
;
auto
dstSDC
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
Make
(
rContext
srcColorType
std
:
:
move
(
finalCS
)
fit
dstBounds
.
size
(
)
SkSurfaceProps
(
)
"
SurfaceDrawContext_ConvolveGaussian
"
1
GrMipmapped
:
:
kNo
srcView
.
proxy
(
)
-
>
isProtected
(
)
srcView
.
origin
(
)
)
;
if
(
!
dstSDC
)
{
return
nullptr
;
}
auto
rtcToSrcOffset
=
dstBounds
.
topLeft
(
)
;
auto
srcBackingBounds
=
SkIRect
:
:
MakeSize
(
srcView
.
proxy
(
)
-
>
backingStoreDimensions
(
)
)
;
bool
canSplit
=
mode
=
=
SkTileMode
:
:
kDecal
|
|
mode
=
=
SkTileMode
:
:
kClamp
;
bool
canHWTile
=
srcBounds
.
contains
(
srcBackingBounds
)
&
&
!
rContext
-
>
priv
(
)
.
caps
(
)
-
>
reducedShaderMode
(
)
&
&
!
(
mode
=
=
SkTileMode
:
:
kDecal
&
&
!
rContext
-
>
priv
(
)
.
caps
(
)
-
>
clampToBorderSupport
(
)
)
;
if
(
!
canSplit
|
|
canHWTile
)
{
auto
dstRect
=
SkIRect
:
:
MakeSize
(
dstBounds
.
size
(
)
)
;
convolve_gaussian_1d
(
dstSDC
.
get
(
)
std
:
:
move
(
srcView
)
srcBounds
rtcToSrcOffset
dstRect
srcAlphaType
direction
radius
sigma
mode
)
;
return
dstSDC
;
}
SkIRect
mid
left
right
;
SkIRect
top
bottom
;
if
(
Direction
:
:
kX
=
=
direction
)
{
top
=
{
dstBounds
.
left
(
)
dstBounds
.
top
(
)
dstBounds
.
right
(
)
srcBounds
.
top
(
)
}
;
bottom
=
{
dstBounds
.
left
(
)
srcBounds
.
bottom
(
)
dstBounds
.
right
(
)
dstBounds
.
bottom
(
)
}
;
int
midA
=
std
:
:
max
(
srcBounds
.
top
(
)
dstBounds
.
top
(
)
)
;
int
midB
=
std
:
:
min
(
srcBounds
.
bottom
(
)
dstBounds
.
bottom
(
)
)
;
mid
=
{
srcBounds
.
left
(
)
+
radius
midA
srcBounds
.
right
(
)
-
radius
midB
}
;
if
(
mid
.
isEmpty
(
)
)
{
left
=
{
dstBounds
.
left
(
)
mid
.
top
(
)
dstBounds
.
right
(
)
mid
.
bottom
(
)
}
;
}
else
{
left
=
{
dstBounds
.
left
(
)
mid
.
top
(
)
mid
.
left
(
)
mid
.
bottom
(
)
}
;
right
=
{
mid
.
right
(
)
mid
.
top
(
)
dstBounds
.
right
(
)
mid
.
bottom
(
)
}
;
}
}
else
{
top
=
{
dstBounds
.
left
(
)
dstBounds
.
top
(
)
srcBounds
.
left
(
)
dstBounds
.
bottom
(
)
}
;
bottom
=
{
srcBounds
.
right
(
)
dstBounds
.
top
(
)
dstBounds
.
right
(
)
dstBounds
.
bottom
(
)
}
;
int
midA
=
std
:
:
max
(
srcBounds
.
left
(
)
dstBounds
.
left
(
)
)
;
int
midB
=
std
:
:
min
(
srcBounds
.
right
(
)
dstBounds
.
right
(
)
)
;
mid
=
{
midA
srcBounds
.
top
(
)
+
radius
midB
srcBounds
.
bottom
(
)
-
radius
}
;
if
(
mid
.
isEmpty
(
)
)
{
left
=
{
mid
.
left
(
)
dstBounds
.
top
(
)
mid
.
right
(
)
dstBounds
.
bottom
(
)
}
;
}
else
{
left
=
{
mid
.
left
(
)
dstBounds
.
top
(
)
mid
.
right
(
)
mid
.
top
(
)
}
;
right
=
{
mid
.
left
(
)
mid
.
bottom
(
)
mid
.
right
(
)
dstBounds
.
bottom
(
)
}
;
}
}
auto
convolve
=
[
&
]
(
SkIRect
rect
)
{
rect
.
offset
(
-
rtcToSrcOffset
)
;
convolve_gaussian_1d
(
dstSDC
.
get
(
)
srcView
srcBounds
rtcToSrcOffset
rect
srcAlphaType
direction
radius
sigma
mode
)
;
}
;
auto
clear
=
[
&
]
(
SkIRect
rect
)
{
rect
.
offset
(
-
rtcToSrcOffset
)
;
dstSDC
-
>
clearAtLeast
(
rect
SK_PMColor4fTRANSPARENT
)
;
}
;
if
(
!
mid
.
isEmpty
(
)
&
&
mid
.
width
(
)
*
mid
.
height
(
)
<
256
*
256
)
{
left
.
join
(
mid
)
;
left
.
join
(
right
)
;
mid
=
SkIRect
:
:
MakeEmpty
(
)
;
right
=
SkIRect
:
:
MakeEmpty
(
)
;
if
(
mode
=
=
SkTileMode
:
:
kClamp
)
{
left
.
join
(
top
)
;
left
.
join
(
bottom
)
;
top
=
SkIRect
:
:
MakeEmpty
(
)
;
bottom
=
SkIRect
:
:
MakeEmpty
(
)
;
}
}
if
(
!
top
.
isEmpty
(
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
clear
(
top
)
;
}
else
{
convolve
(
top
)
;
}
}
if
(
!
bottom
.
isEmpty
(
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
clear
(
bottom
)
;
}
else
{
convolve
(
bottom
)
;
}
}
if
(
mid
.
isEmpty
(
)
)
{
convolve
(
left
)
;
}
else
{
convolve
(
left
)
;
convolve
(
right
)
;
convolve
(
mid
)
;
}
return
dstSDC
;
}
static
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
reexpand
(
GrRecordingContext
*
rContext
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceContext
>
src
const
SkRect
&
srcBounds
SkISize
dstSize
sk_sp
<
SkColorSpace
>
colorSpace
SkBackingFit
fit
)
{
GrSurfaceProxyView
srcView
=
src
-
>
readSurfaceView
(
)
;
if
(
!
srcView
.
asTextureProxy
(
)
)
{
return
nullptr
;
}
GrColorType
srcColorType
=
src
-
>
colorInfo
(
)
.
colorType
(
)
;
SkAlphaType
srcAlphaType
=
src
-
>
colorInfo
(
)
.
alphaType
(
)
;
src
.
reset
(
)
;
auto
dstSDC
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
Make
(
rContext
srcColorType
std
:
:
move
(
colorSpace
)
fit
dstSize
SkSurfaceProps
(
)
"
SurfaceDrawContext_Reexpand
"
1
GrMipmapped
:
:
kNo
srcView
.
proxy
(
)
-
>
isProtected
(
)
srcView
.
origin
(
)
)
;
if
(
!
dstSDC
)
{
return
nullptr
;
}
GrPaint
paint
;
auto
fp
=
GrTextureEffect
:
:
MakeSubset
(
std
:
:
move
(
srcView
)
srcAlphaType
SkMatrix
:
:
I
(
)
GrSamplerState
:
:
Filter
:
:
kLinear
srcBounds
srcBounds
*
rContext
-
>
priv
(
)
.
caps
(
)
)
;
paint
.
setColorFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
dstSDC
-
>
fillRectToRect
(
nullptr
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
dstSize
)
srcBounds
)
;
return
dstSDC
;
}
static
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
two_pass_gaussian
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
sk_sp
<
SkColorSpace
>
colorSpace
SkIRect
srcBounds
SkIRect
dstBounds
float
sigmaX
float
sigmaY
int
radiusX
int
radiusY
SkTileMode
mode
SkBackingFit
fit
)
{
SkASSERT
(
radiusX
|
|
radiusY
)
;
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
dstSDC
;
if
(
radiusX
>
0
)
{
SkBackingFit
xFit
=
radiusY
>
0
?
SkBackingFit
:
:
kApprox
:
fit
;
SkIRect
xPassDstBounds
=
dstBounds
;
if
(
radiusY
)
{
xPassDstBounds
.
outset
(
0
radiusY
)
;
if
(
mode
=
=
SkTileMode
:
:
kRepeat
|
|
mode
=
=
SkTileMode
:
:
kMirror
)
{
int
srcH
=
srcBounds
.
height
(
)
;
int
srcTop
=
srcBounds
.
top
(
)
;
if
(
mode
=
=
SkTileMode
:
:
kMirror
)
{
srcTop
-
=
srcH
;
srcH
*
=
2
;
}
float
floatH
=
srcH
;
int
n
=
sk_float_floor2int_no_saturate
(
(
xPassDstBounds
.
top
(
)
-
srcTop
)
/
floatH
)
;
int
topClip
=
srcTop
+
n
*
srcH
;
n
=
sk_float_ceil2int_no_saturate
(
(
xPassDstBounds
.
bottom
(
)
-
srcBounds
.
bottom
(
)
)
/
floatH
)
;
int
bottomClip
=
srcBounds
.
bottom
(
)
+
n
*
srcH
;
xPassDstBounds
.
fTop
=
std
:
:
max
(
xPassDstBounds
.
top
(
)
topClip
)
;
xPassDstBounds
.
fBottom
=
std
:
:
min
(
xPassDstBounds
.
bottom
(
)
bottomClip
)
;
}
else
{
if
(
xPassDstBounds
.
fBottom
<
=
srcBounds
.
top
(
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
return
nullptr
;
}
xPassDstBounds
.
fTop
=
srcBounds
.
top
(
)
;
xPassDstBounds
.
fBottom
=
xPassDstBounds
.
fTop
+
1
;
}
else
if
(
xPassDstBounds
.
fTop
>
=
srcBounds
.
bottom
(
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
return
nullptr
;
}
xPassDstBounds
.
fBottom
=
srcBounds
.
bottom
(
)
;
xPassDstBounds
.
fTop
=
xPassDstBounds
.
fBottom
-
1
;
}
else
{
xPassDstBounds
.
fTop
=
std
:
:
max
(
xPassDstBounds
.
fTop
srcBounds
.
top
(
)
)
;
xPassDstBounds
.
fBottom
=
std
:
:
min
(
xPassDstBounds
.
fBottom
srcBounds
.
bottom
(
)
)
;
}
int
leftSrcEdge
=
srcBounds
.
fLeft
-
radiusX
;
int
rightSrcEdge
=
srcBounds
.
fRight
+
radiusX
;
if
(
mode
=
=
SkTileMode
:
:
kClamp
)
{
leftSrcEdge
+
=
1
;
rightSrcEdge
-
=
1
;
}
if
(
xPassDstBounds
.
fRight
<
=
leftSrcEdge
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
return
nullptr
;
}
xPassDstBounds
.
fLeft
=
xPassDstBounds
.
fRight
-
1
;
}
else
{
xPassDstBounds
.
fLeft
=
std
:
:
max
(
xPassDstBounds
.
fLeft
leftSrcEdge
)
;
}
if
(
xPassDstBounds
.
fLeft
>
=
rightSrcEdge
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
return
nullptr
;
}
xPassDstBounds
.
fRight
=
xPassDstBounds
.
fLeft
+
1
;
}
else
{
xPassDstBounds
.
fRight
=
std
:
:
min
(
xPassDstBounds
.
fRight
rightSrcEdge
)
;
}
}
}
dstSDC
=
convolve_gaussian
(
rContext
std
:
:
move
(
srcView
)
srcColorType
srcAlphaType
srcBounds
xPassDstBounds
Direction
:
:
kX
radiusX
sigmaX
mode
colorSpace
xFit
)
;
if
(
!
dstSDC
)
{
return
nullptr
;
}
srcView
=
dstSDC
-
>
readSurfaceView
(
)
;
SkIVector
newDstBoundsOffset
=
dstBounds
.
topLeft
(
)
-
xPassDstBounds
.
topLeft
(
)
;
dstBounds
=
SkIRect
:
:
MakeSize
(
dstBounds
.
size
(
)
)
.
makeOffset
(
newDstBoundsOffset
)
;
srcBounds
=
SkIRect
:
:
MakeSize
(
xPassDstBounds
.
size
(
)
)
;
}
if
(
!
radiusY
)
{
return
dstSDC
;
}
return
convolve_gaussian
(
rContext
std
:
:
move
(
srcView
)
srcColorType
srcAlphaType
srcBounds
dstBounds
Direction
:
:
kY
radiusY
sigmaY
mode
colorSpace
fit
)
;
}
namespace
SkGpuBlurUtils
{
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
GaussianBlur
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
srcView
GrColorType
srcColorType
SkAlphaType
srcAlphaType
sk_sp
<
SkColorSpace
>
colorSpace
SkIRect
dstBounds
SkIRect
srcBounds
float
sigmaX
float
sigmaY
SkTileMode
mode
SkBackingFit
fit
)
{
SkASSERT
(
rContext
)
;
TRACE_EVENT2
(
"
skia
.
gpu
"
"
GaussianBlur
"
"
sigmaX
"
sigmaX
"
sigmaY
"
sigmaY
)
;
if
(
!
srcView
.
asTextureProxy
(
)
)
{
return
nullptr
;
}
int
maxRenderTargetSize
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
maxRenderTargetSize
(
)
;
if
(
dstBounds
.
width
(
)
>
maxRenderTargetSize
|
|
dstBounds
.
height
(
)
>
maxRenderTargetSize
)
{
return
nullptr
;
}
int
radiusX
=
SigmaRadius
(
sigmaX
)
;
int
radiusY
=
SigmaRadius
(
sigmaY
)
;
if
(
mode
=
=
SkTileMode
:
:
kClamp
|
|
mode
=
=
SkTileMode
:
:
kDecal
)
{
SkIRect
reach
=
dstBounds
.
makeOutset
(
radiusX
radiusY
)
;
SkIRect
intersection
;
if
(
!
intersection
.
intersect
(
reach
srcBounds
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kDecal
)
{
return
nullptr
;
}
else
{
if
(
reach
.
fLeft
>
=
srcBounds
.
fRight
)
{
srcBounds
.
fLeft
=
srcBounds
.
fRight
-
1
;
}
else
if
(
reach
.
fRight
<
=
srcBounds
.
fLeft
)
{
srcBounds
.
fRight
=
srcBounds
.
fLeft
+
1
;
}
if
(
reach
.
fTop
>
=
srcBounds
.
fBottom
)
{
srcBounds
.
fTop
=
srcBounds
.
fBottom
-
1
;
}
else
if
(
reach
.
fBottom
<
=
srcBounds
.
fTop
)
{
srcBounds
.
fBottom
=
srcBounds
.
fTop
+
1
;
}
}
}
else
{
srcBounds
=
intersection
;
}
}
if
(
mode
!
=
SkTileMode
:
:
kDecal
)
{
if
(
srcBounds
.
width
(
)
=
=
1
)
{
sigmaX
=
0
.
f
;
radiusX
=
0
;
}
if
(
srcBounds
.
height
(
)
=
=
1
)
{
sigmaY
=
0
.
f
;
radiusY
=
0
;
}
}
if
(
!
radiusX
&
&
!
radiusY
)
{
auto
result
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
Make
(
rContext
srcColorType
std
:
:
move
(
colorSpace
)
fit
dstBounds
.
size
(
)
SkSurfaceProps
(
)
"
SurfaceDrawContext_GaussianBlur
"
1
GrMipmapped
:
:
kNo
srcView
.
proxy
(
)
-
>
isProtected
(
)
srcView
.
origin
(
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
GrSamplerState
sampler
(
SkTileModeToWrapMode
(
mode
)
GrSamplerState
:
:
Filter
:
:
kNearest
)
;
auto
fp
=
GrTextureEffect
:
:
MakeSubset
(
std
:
:
move
(
srcView
)
srcAlphaType
SkMatrix
:
:
I
(
)
sampler
SkRect
:
:
Make
(
srcBounds
)
SkRect
:
:
Make
(
dstBounds
)
*
rContext
-
>
priv
(
)
.
caps
(
)
)
;
result
-
>
fillRectToRectWithFP
(
dstBounds
SkIRect
:
:
MakeSize
(
dstBounds
.
size
(
)
)
std
:
:
move
(
fp
)
)
;
return
result
;
}
if
(
sigmaX
<
=
kMaxSigma
&
&
sigmaY
<
=
kMaxSigma
)
{
SkASSERT
(
radiusX
<
=
GrGaussianConvolutionFragmentProcessor
:
:
kMaxKernelRadius
)
;
SkASSERT
(
radiusY
<
=
GrGaussianConvolutionFragmentProcessor
:
:
kMaxKernelRadius
)
;
const
int
kernelSize
=
(
2
*
radiusX
+
1
)
*
(
2
*
radiusY
+
1
)
;
if
(
radiusX
>
0
&
&
radiusY
>
0
&
&
kernelSize
<
=
GrMatrixConvolutionEffect
:
:
kMaxUniformSize
&
&
!
rContext
-
>
priv
(
)
.
caps
(
)
-
>
reducedShaderMode
(
)
)
{
return
convolve_gaussian_2d
(
rContext
std
:
:
move
(
srcView
)
srcColorType
srcBounds
dstBounds
radiusX
radiusY
sigmaX
sigmaY
mode
std
:
:
move
(
colorSpace
)
fit
)
;
}
return
two_pass_gaussian
(
rContext
std
:
:
move
(
srcView
)
srcColorType
srcAlphaType
std
:
:
move
(
colorSpace
)
srcBounds
dstBounds
sigmaX
sigmaY
radiusX
radiusY
mode
fit
)
;
}
GrColorInfo
colorInfo
(
srcColorType
srcAlphaType
colorSpace
)
;
auto
srcCtx
=
rContext
-
>
priv
(
)
.
makeSC
(
srcView
colorInfo
)
;
SkASSERT
(
srcCtx
)
;
float
scaleX
=
sigmaX
>
kMaxSigma
?
kMaxSigma
/
sigmaX
:
1
.
f
;
float
scaleY
=
sigmaY
>
kMaxSigma
?
kMaxSigma
/
sigmaY
:
1
.
f
;
SkISize
rescaledSize
=
{
std
:
:
max
(
sk_float_floor2int
(
srcBounds
.
width
(
)
*
scaleX
)
1
)
std
:
:
max
(
sk_float_floor2int
(
srcBounds
.
height
(
)
*
scaleY
)
1
)
}
;
scaleX
=
static_cast
<
float
>
(
rescaledSize
.
width
(
)
)
/
srcBounds
.
width
(
)
;
scaleY
=
static_cast
<
float
>
(
rescaledSize
.
height
(
)
)
/
srcBounds
.
height
(
)
;
sigmaX
*
=
scaleX
;
sigmaY
*
=
scaleY
;
int
padX
=
mode
=
=
SkTileMode
:
:
kClamp
|
|
(
mode
=
=
SkTileMode
:
:
kDecal
&
&
sigmaX
>
kMaxSigma
)
?
1
:
0
;
int
padY
=
mode
=
=
SkTileMode
:
:
kClamp
|
|
(
mode
=
=
SkTileMode
:
:
kDecal
&
&
sigmaY
>
kMaxSigma
)
?
1
:
0
;
auto
rescaledSDC
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
Make
(
srcCtx
-
>
recordingContext
(
)
colorInfo
.
colorType
(
)
colorInfo
.
refColorSpace
(
)
SkBackingFit
:
:
kApprox
{
rescaledSize
.
width
(
)
+
2
*
padX
rescaledSize
.
height
(
)
+
2
*
padY
}
SkSurfaceProps
(
)
"
RescaledSurfaceDrawContext
"
1
GrMipmapped
:
:
kNo
srcCtx
-
>
asSurfaceProxy
(
)
-
>
isProtected
(
)
srcCtx
-
>
origin
(
)
)
;
if
(
!
rescaledSDC
)
{
return
nullptr
;
}
if
(
(
padX
|
|
padY
)
&
&
mode
=
=
SkTileMode
:
:
kDecal
)
{
rescaledSDC
-
>
clear
(
SkPMColor4f
{
0
0
0
0
}
)
;
}
if
(
!
srcCtx
-
>
rescaleInto
(
rescaledSDC
.
get
(
)
SkIRect
:
:
MakeSize
(
rescaledSize
)
.
makeOffset
(
padX
padY
)
srcBounds
SkSurface
:
:
RescaleGamma
:
:
kSrc
SkSurface
:
:
RescaleMode
:
:
kRepeatedLinear
)
)
{
return
nullptr
;
}
if
(
mode
=
=
SkTileMode
:
:
kClamp
)
{
SkASSERT
(
padX
=
=
1
&
&
padY
=
=
1
)
;
auto
cheapDownscale
=
[
&
]
(
SkIRect
dstRect
SkIRect
srcRect
)
{
rescaledSDC
-
>
drawTexture
(
nullptr
srcCtx
-
>
readSurfaceView
(
)
srcAlphaType
GrSamplerState
:
:
Filter
:
:
kLinear
GrSamplerState
:
:
MipmapMode
:
:
kNone
SkBlendMode
:
:
kSrc
SK_PMColor4fWHITE
SkRect
:
:
Make
(
srcRect
)
SkRect
:
:
Make
(
dstRect
)
GrQuadAAFlags
:
:
kNone
SkCanvas
:
:
SrcRectConstraint
:
:
kFast_SrcRectConstraint
SkMatrix
:
:
I
(
)
nullptr
)
;
}
;
auto
[
dw
dh
]
=
rescaledSize
;
float
sLCol
=
srcBounds
.
left
(
)
;
float
sTRow
=
srcBounds
.
top
(
)
;
float
sRCol
=
srcBounds
.
right
(
)
-
1
;
float
sBRow
=
srcBounds
.
bottom
(
)
-
1
;
int
sx
=
srcBounds
.
left
(
)
;
int
sy
=
srcBounds
.
top
(
)
;
int
sw
=
srcBounds
.
width
(
)
;
int
sh
=
srcBounds
.
height
(
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
0
1
1
dh
)
SkIRect
:
:
MakeXYWH
(
sLCol
sy
1
sh
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
1
0
dw
1
)
SkIRect
:
:
MakeXYWH
(
sx
sTRow
sw
1
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
dw
+
1
1
1
dh
)
SkIRect
:
:
MakeXYWH
(
sRCol
sy
1
sh
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
1
dh
+
1
dw
1
)
SkIRect
:
:
MakeXYWH
(
sx
sBRow
sw
1
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
0
0
1
1
)
SkIRect
:
:
MakeXYWH
(
sLCol
sTRow
1
1
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
dw
+
1
0
1
1
)
SkIRect
:
:
MakeXYWH
(
sRCol
sTRow
1
1
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
dw
+
1
dh
+
1
1
1
)
SkIRect
:
:
MakeXYWH
(
sRCol
sBRow
1
1
)
)
;
cheapDownscale
(
SkIRect
:
:
MakeXYWH
(
0
dh
+
1
1
1
)
SkIRect
:
:
MakeXYWH
(
sLCol
sBRow
1
1
)
)
;
}
srcView
=
rescaledSDC
-
>
readSurfaceView
(
)
;
rescaledSDC
.
reset
(
)
;
srcCtx
.
reset
(
)
;
SkRect
scaledDstBounds
=
SkRect
:
:
Make
(
dstBounds
.
makeOffset
(
-
srcBounds
.
topLeft
(
)
)
)
;
scaledDstBounds
.
fLeft
*
=
scaleX
;
scaledDstBounds
.
fTop
*
=
scaleY
;
scaledDstBounds
.
fRight
*
=
scaleX
;
scaledDstBounds
.
fBottom
*
=
scaleY
;
scaledDstBounds
.
offset
(
padX
padY
)
;
auto
scaledDstBoundsI
=
scaledDstBounds
.
roundOut
(
)
;
SkIRect
scaledSrcBounds
=
SkIRect
:
:
MakeSize
(
srcView
.
dimensions
(
)
)
;
auto
sdc
=
GaussianBlur
(
rContext
std
:
:
move
(
srcView
)
srcColorType
srcAlphaType
colorSpace
scaledDstBoundsI
scaledSrcBounds
sigmaX
sigmaY
mode
fit
)
;
if
(
!
sdc
)
{
return
nullptr
;
}
scaledDstBounds
.
offset
(
-
scaledDstBoundsI
.
left
(
)
-
scaledDstBoundsI
.
top
(
)
)
;
return
reexpand
(
rContext
std
:
:
move
(
sdc
)
scaledDstBounds
dstBounds
.
size
(
)
std
:
:
move
(
colorSpace
)
fit
)
;
}
bool
ComputeBlurredRRectParams
(
const
SkRRect
&
srcRRect
const
SkRRect
&
devRRect
SkScalar
sigma
SkScalar
xformedSigma
SkRRect
*
rrectToDraw
SkISize
*
widthHeight
SkScalar
rectXs
[
kBlurRRectMaxDivisions
]
SkScalar
rectYs
[
kBlurRRectMaxDivisions
]
SkScalar
texXs
[
kBlurRRectMaxDivisions
]
SkScalar
texYs
[
kBlurRRectMaxDivisions
]
)
{
unsigned
int
devBlurRadius
=
3
*
SkScalarCeilToInt
(
xformedSigma
-
1
/
6
.
0f
)
;
SkScalar
srcBlurRadius
=
3
.
0f
*
sigma
;
const
SkRect
&
devOrig
=
devRRect
.
getBounds
(
)
;
const
SkVector
&
devRadiiUL
=
devRRect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
;
const
SkVector
&
devRadiiUR
=
devRRect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
;
const
SkVector
&
devRadiiLR
=
devRRect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
;
const
SkVector
&
devRadiiLL
=
devRRect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
;
const
int
devLeft
=
SkScalarCeilToInt
(
std
:
:
max
<
SkScalar
>
(
devRadiiUL
.
fX
devRadiiLL
.
fX
)
)
;
const
int
devTop
=
SkScalarCeilToInt
(
std
:
:
max
<
SkScalar
>
(
devRadiiUL
.
fY
devRadiiUR
.
fY
)
)
;
const
int
devRight
=
SkScalarCeilToInt
(
std
:
:
max
<
SkScalar
>
(
devRadiiUR
.
fX
devRadiiLR
.
fX
)
)
;
const
int
devBot
=
SkScalarCeilToInt
(
std
:
:
max
<
SkScalar
>
(
devRadiiLL
.
fY
devRadiiLR
.
fY
)
)
;
if
(
devOrig
.
fLeft
+
devLeft
+
devBlurRadius
>
=
devOrig
.
fRight
-
devRight
-
devBlurRadius
|
|
devOrig
.
fTop
+
devTop
+
devBlurRadius
>
=
devOrig
.
fBottom
-
devBot
-
devBlurRadius
)
{
return
false
;
}
const
SkVector
&
srcRadiiUL
=
srcRRect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
;
const
SkVector
&
srcRadiiUR
=
srcRRect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
;
const
SkVector
&
srcRadiiLR
=
srcRRect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
;
const
SkVector
&
srcRadiiLL
=
srcRRect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
;
const
SkScalar
srcLeft
=
std
:
:
max
<
SkScalar
>
(
srcRadiiUL
.
fX
srcRadiiLL
.
fX
)
;
const
SkScalar
srcTop
=
std
:
:
max
<
SkScalar
>
(
srcRadiiUL
.
fY
srcRadiiUR
.
fY
)
;
const
SkScalar
srcRight
=
std
:
:
max
<
SkScalar
>
(
srcRadiiUR
.
fX
srcRadiiLR
.
fX
)
;
const
SkScalar
srcBot
=
std
:
:
max
<
SkScalar
>
(
srcRadiiLL
.
fY
srcRadiiLR
.
fY
)
;
int
newRRWidth
=
2
*
devBlurRadius
+
devLeft
+
devRight
+
1
;
int
newRRHeight
=
2
*
devBlurRadius
+
devTop
+
devBot
+
1
;
widthHeight
-
>
fWidth
=
newRRWidth
+
2
*
devBlurRadius
;
widthHeight
-
>
fHeight
=
newRRHeight
+
2
*
devBlurRadius
;
const
SkRect
srcProxyRect
=
srcRRect
.
getBounds
(
)
.
makeOutset
(
srcBlurRadius
srcBlurRadius
)
;
rectXs
[
0
]
=
srcProxyRect
.
fLeft
;
rectXs
[
1
]
=
srcProxyRect
.
fLeft
+
2
*
srcBlurRadius
+
srcLeft
;
rectXs
[
2
]
=
srcProxyRect
.
fRight
-
2
*
srcBlurRadius
-
srcRight
;
rectXs
[
3
]
=
srcProxyRect
.
fRight
;
rectYs
[
0
]
=
srcProxyRect
.
fTop
;
rectYs
[
1
]
=
srcProxyRect
.
fTop
+
2
*
srcBlurRadius
+
srcTop
;
rectYs
[
2
]
=
srcProxyRect
.
fBottom
-
2
*
srcBlurRadius
-
srcBot
;
rectYs
[
3
]
=
srcProxyRect
.
fBottom
;
texXs
[
0
]
=
0
.
0f
;
texXs
[
1
]
=
2
.
0f
*
devBlurRadius
+
devLeft
;
texXs
[
2
]
=
2
.
0f
*
devBlurRadius
+
devLeft
+
1
;
texXs
[
3
]
=
SkIntToScalar
(
widthHeight
-
>
fWidth
)
;
texYs
[
0
]
=
0
.
0f
;
texYs
[
1
]
=
2
.
0f
*
devBlurRadius
+
devTop
;
texYs
[
2
]
=
2
.
0f
*
devBlurRadius
+
devTop
+
1
;
texYs
[
3
]
=
SkIntToScalar
(
widthHeight
-
>
fHeight
)
;
const
SkRect
newRect
=
SkRect
:
:
MakeXYWH
(
SkIntToScalar
(
devBlurRadius
)
SkIntToScalar
(
devBlurRadius
)
SkIntToScalar
(
newRRWidth
)
SkIntToScalar
(
newRRHeight
)
)
;
SkVector
newRadii
[
4
]
;
newRadii
[
0
]
=
{
SkScalarCeilToScalar
(
devRadiiUL
.
fX
)
SkScalarCeilToScalar
(
devRadiiUL
.
fY
)
}
;
newRadii
[
1
]
=
{
SkScalarCeilToScalar
(
devRadiiUR
.
fX
)
SkScalarCeilToScalar
(
devRadiiUR
.
fY
)
}
;
newRadii
[
2
]
=
{
SkScalarCeilToScalar
(
devRadiiLR
.
fX
)
SkScalarCeilToScalar
(
devRadiiLR
.
fY
)
}
;
newRadii
[
3
]
=
{
SkScalarCeilToScalar
(
devRadiiLL
.
fX
)
SkScalarCeilToScalar
(
devRadiiLL
.
fY
)
}
;
rrectToDraw
-
>
setRectRadii
(
newRect
newRadii
)
;
return
true
;
}
int
CreateIntegralTable
(
float
sixSigma
SkBitmap
*
table
)
{
if
(
sk_float_isnan
(
sixSigma
)
)
{
return
0
;
}
if
(
sixSigma
>
SK_MaxS32
/
4
+
1
)
{
return
0
;
}
int
minWidth
=
2
*
(
(
int
)
sk_float_ceil
(
sixSigma
)
)
;
int
width
=
std
:
:
max
(
SkNextPow2
(
minWidth
)
32
)
;
if
(
!
table
)
{
return
width
;
}
if
(
!
table
-
>
tryAllocPixels
(
SkImageInfo
:
:
MakeA8
(
width
1
)
)
)
{
return
0
;
}
*
table
-
>
getAddr8
(
0
0
)
=
255
;
const
float
invWidth
=
1
.
f
/
width
;
for
(
int
i
=
1
;
i
<
width
-
1
;
+
+
i
)
{
float
x
=
(
i
+
0
.
5f
)
*
invWidth
;
x
=
(
-
6
*
x
+
3
)
*
SK_ScalarRoot2Over2
;
float
integral
=
0
.
5f
*
(
std
:
:
erf
(
x
)
+
1
.
f
)
;
*
table
-
>
getAddr8
(
i
0
)
=
SkToU8
(
sk_float_round2int
(
255
.
f
*
integral
)
)
;
}
*
table
-
>
getAddr8
(
width
-
1
0
)
=
0
;
table
-
>
setImmutable
(
)
;
return
table
-
>
width
(
)
;
}
void
Compute1DGaussianKernel
(
float
*
kernel
float
sigma
int
radius
)
{
SkASSERT
(
radius
=
=
SigmaRadius
(
sigma
)
)
;
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
)
)
{
SkASSERT
(
KernelWidth
(
radius
)
=
=
1
)
;
std
:
:
fill_n
(
kernel
1
0
.
f
)
;
kernel
[
0
]
=
1
.
f
;
return
;
}
SkASSERT
(
!
SkScalarNearlyZero
(
2
.
f
*
sigma
*
sigma
)
)
;
const
float
sigmaDenom
=
1
.
0f
/
(
2
.
f
*
sigma
*
sigma
)
;
int
size
=
KernelWidth
(
radius
)
;
float
sum
=
0
.
0f
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
float
term
=
static_cast
<
float
>
(
i
-
radius
)
;
kernel
[
i
]
=
sk_float_exp
(
-
term
*
term
*
sigmaDenom
)
;
sum
+
=
kernel
[
i
]
;
}
float
scale
=
1
.
0f
/
sum
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
kernel
[
i
]
*
=
scale
;
}
}
void
Compute1DLinearGaussianKernel
(
float
*
kernel
float
*
offset
float
sigma
int
radius
)
{
auto
get_new_weight
=
[
]
(
float
*
new_w
float
*
offset
float
wi
float
wj
)
{
*
new_w
=
wi
+
wj
;
*
offset
=
wj
/
(
wi
+
wj
)
;
}
;
int
size
=
KernelWidth
(
radius
)
;
std
:
:
unique_ptr
<
float
[
]
>
temp_kernel
(
new
float
[
size
]
)
;
Compute1DGaussianKernel
(
temp_kernel
.
get
(
)
sigma
radius
)
;
int
halfsize
=
LinearKernelWidth
(
radius
)
;
int
halfradius
=
halfsize
/
2
;
int
low_index
=
halfradius
-
1
;
int
index
=
radius
;
if
(
radius
&
1
)
{
get_new_weight
(
&
kernel
[
halfradius
]
&
offset
[
halfradius
]
temp_kernel
[
index
]
*
0
.
5f
temp_kernel
[
index
+
1
]
)
;
kernel
[
low_index
]
=
kernel
[
halfradius
]
;
offset
[
low_index
]
=
-
offset
[
halfradius
]
;
index
+
+
;
low_index
-
-
;
}
else
{
kernel
[
halfradius
]
=
temp_kernel
[
index
]
;
offset
[
halfradius
]
=
0
.
0f
;
}
index
+
+
;
for
(
int
i
=
halfradius
+
1
;
i
<
halfsize
;
index
+
=
2
i
+
+
low_index
-
-
)
{
get_new_weight
(
&
kernel
[
i
]
&
offset
[
i
]
temp_kernel
[
index
]
temp_kernel
[
index
+
1
]
)
;
offset
[
i
]
+
=
static_cast
<
float
>
(
index
-
radius
)
;
kernel
[
low_index
]
=
kernel
[
i
]
;
offset
[
low_index
]
=
-
offset
[
i
]
;
}
}
}
#
endif
