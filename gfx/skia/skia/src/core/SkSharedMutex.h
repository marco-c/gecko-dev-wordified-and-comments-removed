#
ifndef
SkSharedLock_DEFINED
#
define
SkSharedLock_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
include
/
private
/
base
/
SkSemaphore
.
h
"
#
include
"
include
/
private
/
base
/
SkThreadAnnotations
.
h
"
#
include
<
atomic
>
#
ifdef
SK_DEBUG
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
<
memory
>
#
endif
class
SK_CAPABILITY
(
"
mutex
"
)
SkSharedMutex
{
public
:
SkSharedMutex
(
)
;
~
SkSharedMutex
(
)
;
void
acquire
(
)
SK_ACQUIRE
(
)
;
void
release
(
)
SK_RELEASE_CAPABILITY
(
)
;
void
assertHeld
(
)
const
SK_ASSERT_CAPABILITY
(
this
)
;
void
acquireShared
(
)
SK_ACQUIRE_SHARED
(
)
;
void
releaseShared
(
)
SK_RELEASE_SHARED_CAPABILITY
(
)
;
void
assertHeldShared
(
)
const
SK_ASSERT_SHARED_CAPABILITY
(
this
)
;
private
:
#
ifdef
SK_DEBUG
class
ThreadIDSet
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fCurrentShared
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fWaitingExclusive
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fWaitingShared
;
int
fSharedQueueSelect
{
0
}
;
mutable
SkMutex
fMu
;
SkSemaphore
fSharedQueue
[
2
]
;
SkSemaphore
fExclusiveQueue
;
#
else
std
:
:
atomic
<
int32_t
>
fQueueCounts
;
SkSemaphore
fSharedQueue
;
SkSemaphore
fExclusiveQueue
;
#
endif
}
;
#
ifndef
SK_DEBUG
inline
void
SkSharedMutex
:
:
assertHeld
(
)
const
{
}
inline
void
SkSharedMutex
:
:
assertHeldShared
(
)
const
{
}
#
endif
class
SK_SCOPED_CAPABILITY
SkAutoSharedMutexExclusive
{
public
:
explicit
SkAutoSharedMutexExclusive
(
SkSharedMutex
&
lock
)
SK_ACQUIRE
(
lock
)
:
fLock
(
lock
)
{
lock
.
acquire
(
)
;
}
~
SkAutoSharedMutexExclusive
(
)
SK_RELEASE_CAPABILITY
(
)
{
fLock
.
release
(
)
;
}
private
:
SkSharedMutex
&
fLock
;
}
;
class
SK_SCOPED_CAPABILITY
SkAutoSharedMutexShared
{
public
:
explicit
SkAutoSharedMutexShared
(
SkSharedMutex
&
lock
)
SK_ACQUIRE_SHARED
(
lock
)
:
fLock
(
lock
)
{
lock
.
acquireShared
(
)
;
}
~
SkAutoSharedMutexShared
(
)
SK_RELEASE_CAPABILITY
(
)
{
fLock
.
releaseShared
(
)
;
}
private
:
SkSharedMutex
&
fLock
;
}
;
#
endif
