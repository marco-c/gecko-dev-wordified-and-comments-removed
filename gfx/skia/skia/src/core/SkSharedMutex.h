#
ifndef
SkSharedLock_DEFINED
#
define
SkSharedLock_DEFINED
#
include
"
SkMacros
.
h
"
#
include
"
SkSemaphore
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
atomic
>
#
ifdef
SK_DEBUG
#
include
"
SkMutex
.
h
"
#
include
<
memory
>
#
endif
class
SkSharedMutex
{
public
:
SkSharedMutex
(
)
;
~
SkSharedMutex
(
)
;
void
acquire
(
)
;
void
release
(
)
;
void
assertHeld
(
)
const
;
void
acquireShared
(
)
;
void
releaseShared
(
)
;
void
assertHeldShared
(
)
const
;
private
:
#
ifdef
SK_DEBUG
class
ThreadIDSet
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fCurrentShared
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fWaitingExclusive
;
std
:
:
unique_ptr
<
ThreadIDSet
>
fWaitingShared
;
int
fSharedQueueSelect
{
0
}
;
mutable
SkMutex
fMu
;
SkSemaphore
fSharedQueue
[
2
]
;
SkSemaphore
fExclusiveQueue
;
#
else
std
:
:
atomic
<
int32_t
>
fQueueCounts
;
SkSemaphore
fSharedQueue
;
SkSemaphore
fExclusiveQueue
;
#
endif
}
;
#
ifndef
SK_DEBUG
inline
void
SkSharedMutex
:
:
assertHeld
(
)
const
{
}
;
inline
void
SkSharedMutex
:
:
assertHeldShared
(
)
const
{
}
;
#
endif
class
SkAutoSharedMutexShared
{
public
:
SkAutoSharedMutexShared
(
SkSharedMutex
&
lock
)
:
fLock
(
lock
)
{
lock
.
acquireShared
(
)
;
}
~
SkAutoSharedMutexShared
(
)
{
fLock
.
releaseShared
(
)
;
}
private
:
SkSharedMutex
&
fLock
;
}
;
#
define
SkAutoSharedMutexShared
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoSharedMutexShared
)
#
endif
