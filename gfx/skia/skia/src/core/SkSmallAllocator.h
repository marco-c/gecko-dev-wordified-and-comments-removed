#
ifndef
SkSmallAllocator_DEFINED
#
define
SkSmallAllocator_DEFINED
#
include
"
SkTDArray
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
new
>
template
<
uint32_t
kMaxObjects
size_t
kTotalBytes
>
class
SkSmallAllocator
:
SkNoncopyable
{
public
:
SkSmallAllocator
(
)
:
fStorageUsed
(
0
)
fNumObjects
(
0
)
{
}
~
SkSmallAllocator
(
)
{
while
(
fNumObjects
>
0
)
{
fNumObjects
-
-
;
Rec
*
rec
=
&
fRecs
[
fNumObjects
]
;
rec
-
>
fKillProc
(
rec
-
>
fObj
)
;
sk_free
(
rec
-
>
fHeapStorage
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
T
*
createT
(
const
Args
&
.
.
.
args
)
{
void
*
buf
=
this
-
>
reserveT
<
T
>
(
)
;
if
(
nullptr
=
=
buf
)
{
return
nullptr
;
}
return
new
(
buf
)
T
(
args
.
.
.
)
;
}
template
<
typename
T
>
void
*
reserveT
(
size_t
storageRequired
=
sizeof
(
T
)
)
{
SkASSERT
(
fNumObjects
<
kMaxObjects
)
;
SkASSERT
(
storageRequired
>
=
sizeof
(
T
)
)
;
if
(
kMaxObjects
=
=
fNumObjects
)
{
return
nullptr
;
}
const
size_t
storageRemaining
=
sizeof
(
fStorage
)
-
fStorageUsed
;
Rec
*
rec
=
&
fRecs
[
fNumObjects
]
;
if
(
storageRequired
>
storageRemaining
)
{
SkASSERT
(
false
)
;
rec
-
>
fStorageSize
=
0
;
rec
-
>
fHeapStorage
=
sk_malloc_throw
(
storageRequired
)
;
rec
-
>
fObj
=
static_cast
<
void
*
>
(
rec
-
>
fHeapStorage
)
;
}
else
{
rec
-
>
fStorageSize
=
storageRequired
;
rec
-
>
fHeapStorage
=
nullptr
;
rec
-
>
fObj
=
static_cast
<
void
*
>
(
fStorage
.
fBytes
+
fStorageUsed
)
;
fStorageUsed
+
=
storageRequired
;
}
rec
-
>
fKillProc
=
DestroyT
<
T
>
;
fNumObjects
+
+
;
return
rec
-
>
fObj
;
}
void
freeLast
(
)
{
SkASSERT
(
fNumObjects
>
0
)
;
Rec
*
rec
=
&
fRecs
[
fNumObjects
-
1
]
;
sk_free
(
rec
-
>
fHeapStorage
)
;
fStorageUsed
-
=
rec
-
>
fStorageSize
;
fNumObjects
-
-
;
}
private
:
struct
Rec
{
size_t
fStorageSize
;
void
*
fObj
;
void
*
fHeapStorage
;
void
(
*
fKillProc
)
(
void
*
)
;
}
;
template
<
typename
T
>
static
void
DestroyT
(
void
*
ptr
)
{
static_cast
<
T
*
>
(
ptr
)
-
>
~
T
(
)
;
}
struct
SK_STRUCT_ALIGN
(
16
)
Storage
{
char
fBytes
[
kTotalBytes
+
kMaxObjects
*
15
]
;
}
;
Storage
fStorage
;
size_t
fStorageUsed
;
uint32_t
fNumObjects
;
Rec
fRecs
[
kMaxObjects
]
;
}
;
#
endif
