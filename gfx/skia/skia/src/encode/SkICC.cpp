#
include
"
include
/
encode
/
SkICC
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkFixed
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
modules
/
skcms
/
skcms
.
h
"
#
include
"
src
/
base
/
SkAutoMalloc
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
base
/
SkUtils
.
h
"
#
include
"
src
/
core
/
SkMD5
.
h
"
#
include
"
src
/
encode
/
SkICCPriv
.
h
"
#
include
<
cmath
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
static
constexpr
size_t
kNumChannels
=
3
;
constexpr
float
kD50_x
=
0
.
9642f
;
constexpr
float
kD50_y
=
1
.
0000f
;
constexpr
float
kD50_z
=
0
.
8249f
;
static
SkFixed
float_round_to_fixed
(
float
x
)
{
return
sk_float_saturate2int
(
(
float
)
floor
(
(
double
)
x
*
SK_Fixed1
+
0
.
5
)
)
;
}
static
uint16_t
float_round_to_unorm16
(
float
x
)
{
x
=
x
*
65535
.
f
+
0
.
5
;
if
(
x
>
65535
)
return
65535
;
if
(
x
<
0
)
return
0
;
return
static_cast
<
uint16_t
>
(
x
)
;
}
struct
ICCHeader
{
uint32_t
size
;
uint32_t
cmm_type
=
0
;
uint32_t
version
=
SkEndian_SwapBE32
(
0x04300000
)
;
uint32_t
profile_class
=
SkEndian_SwapBE32
(
kDisplay_Profile
)
;
uint32_t
data_color_space
=
SkEndian_SwapBE32
(
kRGB_ColorSpace
)
;
uint32_t
pcs
=
SkEndian_SwapBE32
(
kXYZ_PCSSpace
)
;
uint16_t
creation_date_year
=
SkEndian_SwapBE16
(
2016
)
;
uint16_t
creation_date_month
=
SkEndian_SwapBE16
(
1
)
;
uint16_t
creation_date_day
=
SkEndian_SwapBE16
(
1
)
;
uint16_t
creation_date_hours
=
0
;
uint16_t
creation_date_minutes
=
0
;
uint16_t
creation_date_seconds
=
0
;
uint32_t
signature
=
SkEndian_SwapBE32
(
kACSP_Signature
)
;
uint32_t
platform
=
0
;
uint32_t
flags
=
0x00000000
;
uint32_t
device_manufacturer
=
0
;
uint32_t
device_model
=
0
;
uint8_t
device_attributes
[
8
]
=
{
0
}
;
uint32_t
rendering_intent
=
SkEndian_SwapBE32
(
1
)
;
uint32_t
illuminant_X
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_x
)
)
;
uint32_t
illuminant_Y
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_y
)
)
;
uint32_t
illuminant_Z
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_z
)
)
;
uint32_t
creator
=
0
;
uint8_t
profile_id
[
16
]
=
{
0
}
;
uint8_t
reserved
[
28
]
=
{
0
}
;
uint32_t
tag_count
=
0
;
}
;
static
sk_sp
<
SkData
>
write_xyz_tag
(
float
x
float
y
float
z
)
{
uint32_t
data
[
]
=
{
SkEndian_SwapBE32
(
kXYZ_PCSSpace
)
0
SkEndian_SwapBE32
(
float_round_to_fixed
(
x
)
)
SkEndian_SwapBE32
(
float_round_to_fixed
(
y
)
)
SkEndian_SwapBE32
(
float_round_to_fixed
(
z
)
)
}
;
return
SkData
:
:
MakeWithCopy
(
data
sizeof
(
data
)
)
;
}
static
bool
nearly_equal
(
float
x
float
y
)
{
static
constexpr
float
kTolerance
=
1
.
0f
/
(
1
<
<
11
)
;
return
:
:
fabsf
(
x
-
y
)
<
=
kTolerance
;
}
static
bool
nearly_equal
(
const
skcms_TransferFunction
&
u
const
skcms_TransferFunction
&
v
)
{
return
nearly_equal
(
u
.
g
v
.
g
)
&
&
nearly_equal
(
u
.
a
v
.
a
)
&
&
nearly_equal
(
u
.
b
v
.
b
)
&
&
nearly_equal
(
u
.
c
v
.
c
)
&
&
nearly_equal
(
u
.
d
v
.
d
)
&
&
nearly_equal
(
u
.
e
v
.
e
)
&
&
nearly_equal
(
u
.
f
v
.
f
)
;
}
static
bool
nearly_equal
(
const
skcms_Matrix3x3
&
u
const
skcms_Matrix3x3
&
v
)
{
for
(
int
r
=
0
;
r
<
3
;
r
+
+
)
{
for
(
int
c
=
0
;
c
<
3
;
c
+
+
)
{
if
(
!
nearly_equal
(
u
.
vals
[
r
]
[
c
]
v
.
vals
[
r
]
[
c
]
)
)
{
return
false
;
}
}
}
return
true
;
}
static
constexpr
uint32_t
kCICPPrimariesSRGB
=
1
;
static
constexpr
uint32_t
kCICPPrimariesP3
=
12
;
static
constexpr
uint32_t
kCICPPrimariesRec2020
=
9
;
static
uint32_t
get_cicp_primaries
(
const
skcms_Matrix3x3
&
toXYZD50
)
{
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kSRGB
)
)
{
return
kCICPPrimariesSRGB
;
}
else
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kDisplayP3
)
)
{
return
kCICPPrimariesP3
;
}
else
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kRec2020
)
)
{
return
kCICPPrimariesRec2020
;
}
return
0
;
}
static
constexpr
uint32_t
kCICPTrfnSRGB
=
1
;
static
constexpr
uint32_t
kCICPTrfn2Dot2
=
4
;
static
constexpr
uint32_t
kCICPTrfnLinear
=
8
;
static
constexpr
uint32_t
kCICPTrfnPQ
=
16
;
static
constexpr
uint32_t
kCICPTrfnHLG
=
18
;
static
uint32_t
get_cicp_trfn
(
const
skcms_TransferFunction
&
fn
)
{
switch
(
skcms_TransferFunction_getType
(
&
fn
)
)
{
case
skcms_TFType_Invalid
:
return
0
;
case
skcms_TFType_sRGBish
:
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
kSRGB
)
)
{
return
kCICPTrfnSRGB
;
}
else
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
k2Dot2
)
)
{
return
kCICPTrfn2Dot2
;
}
else
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
kLinear
)
)
{
return
kCICPTrfnLinear
;
}
break
;
case
skcms_TFType_PQish
:
return
kCICPTrfnPQ
;
case
skcms_TFType_HLGish
:
return
kCICPTrfnHLG
;
case
skcms_TFType_HLGinvish
:
return
0
;
}
return
0
;
}
static
std
:
:
string
get_desc_string
(
const
skcms_TransferFunction
&
fn
const
skcms_Matrix3x3
&
toXYZD50
)
{
const
uint32_t
cicp_trfn
=
get_cicp_trfn
(
fn
)
;
const
uint32_t
cicp_primaries
=
get_cicp_primaries
(
toXYZD50
)
;
if
(
cicp_trfn
=
=
kCICPPrimariesSRGB
&
&
cicp_primaries
=
=
kCICPTrfnSRGB
)
{
return
"
sRGB
"
;
}
if
(
cicp_primaries
&
&
cicp_trfn
)
{
std
:
:
string
result
;
switch
(
cicp_primaries
)
{
case
kCICPPrimariesSRGB
:
result
+
=
"
sRGB
"
;
break
;
case
kCICPPrimariesP3
:
result
+
=
"
Display
P3
"
;
break
;
case
kCICPPrimariesRec2020
:
result
+
=
"
Rec2020
"
;
break
;
default
:
result
+
=
"
Unknown
"
;
break
;
}
result
+
=
"
Gamut
with
"
;
switch
(
cicp_trfn
)
{
case
kCICPTrfnSRGB
:
result
+
=
"
sRGB
"
;
break
;
case
kCICPTrfnLinear
:
result
+
=
"
Linear
"
;
break
;
case
kCICPTrfn2Dot2
:
result
+
=
"
2
.
2
"
;
break
;
case
kCICPTrfnPQ
:
result
+
=
"
PQ
"
;
break
;
case
kCICPTrfnHLG
:
result
+
=
"
HLG
"
;
break
;
default
:
result
+
=
"
Unknown
"
;
break
;
}
result
+
=
"
Transfer
"
;
return
result
;
}
SkMD5
md5
;
md5
.
write
(
&
toXYZD50
sizeof
(
toXYZD50
)
)
;
md5
.
write
(
&
fn
sizeof
(
fn
)
)
;
SkMD5
:
:
Digest
digest
=
md5
.
finish
(
)
;
std
:
:
string
md5_hexstring
(
2
*
sizeof
(
SkMD5
:
:
Digest
)
'
'
)
;
for
(
unsigned
i
=
0
;
i
<
sizeof
(
SkMD5
:
:
Digest
)
;
+
+
i
)
{
uint8_t
byte
=
digest
.
data
[
i
]
;
md5_hexstring
[
2
*
i
+
0
]
=
SkHexadecimalDigits
:
:
gUpper
[
byte
>
>
4
]
;
md5_hexstring
[
2
*
i
+
1
]
=
SkHexadecimalDigits
:
:
gUpper
[
byte
&
0xF
]
;
}
return
"
Google
/
Skia
/
"
+
md5_hexstring
;
}
static
sk_sp
<
SkData
>
write_text_tag
(
const
char
*
text
)
{
uint32_t
text_length
=
strlen
(
text
)
;
uint32_t
header
[
]
=
{
SkEndian_SwapBE32
(
kTAG_TextType
)
0
SkEndian_SwapBE32
(
1
)
SkEndian_SwapBE32
(
12
)
SkEndian_SwapBE32
(
SkSetFourByteTag
(
'
e
'
'
n
'
'
U
'
'
S
'
)
)
SkEndian_SwapBE32
(
2
*
text_length
)
SkEndian_SwapBE32
(
28
)
}
;
SkDynamicMemoryWStream
s
;
s
.
write
(
header
sizeof
(
header
)
)
;
for
(
size_t
i
=
0
;
i
<
text_length
;
i
+
+
)
{
s
.
write8
(
0
)
;
s
.
write8
(
text
[
i
]
)
;
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
static
sk_sp
<
SkData
>
write_cicp_tag
(
const
skcms_CICP
&
cicp
)
{
SkDynamicMemoryWStream
s
;
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_cicp
)
)
;
s
.
write32
(
0
)
;
s
.
write8
(
cicp
.
color_primaries
)
;
s
.
write8
(
cicp
.
transfer_characteristics
)
;
s
.
write8
(
cicp
.
matrix_coefficients
)
;
s
.
write8
(
cicp
.
video_full_range_flag
)
;
return
s
.
detachAsData
(
)
;
}
static
void
skcms_Matrix3x3_apply
(
const
skcms_Matrix3x3
*
m
float
*
x
)
{
float
y0
=
x
[
0
]
*
m
-
>
vals
[
0
]
[
0
]
+
x
[
1
]
*
m
-
>
vals
[
0
]
[
1
]
+
x
[
2
]
*
m
-
>
vals
[
0
]
[
2
]
;
float
y1
=
x
[
0
]
*
m
-
>
vals
[
1
]
[
0
]
+
x
[
1
]
*
m
-
>
vals
[
1
]
[
1
]
+
x
[
2
]
*
m
-
>
vals
[
1
]
[
2
]
;
float
y2
=
x
[
0
]
*
m
-
>
vals
[
2
]
[
0
]
+
x
[
1
]
*
m
-
>
vals
[
2
]
[
1
]
+
x
[
2
]
*
m
-
>
vals
[
2
]
[
2
]
;
x
[
0
]
=
y0
;
x
[
1
]
=
y1
;
x
[
2
]
=
y2
;
}
void
SkICCFloatXYZD50ToGrid16Lab
(
const
float
*
xyz_float
uint8_t
*
grid16_lab
)
{
float
v
[
3
]
=
{
xyz_float
[
0
]
/
kD50_x
xyz_float
[
1
]
/
kD50_y
xyz_float
[
2
]
/
kD50_z
}
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
v
[
i
]
=
v
[
i
]
>
0
.
008856f
?
cbrtf
(
v
[
i
]
)
:
v
[
i
]
*
7
.
787f
+
(
16
/
116
.
0f
)
;
}
const
float
L
=
v
[
1
]
*
116
.
0f
-
16
.
0f
;
const
float
a
=
(
v
[
0
]
-
v
[
1
]
)
*
500
.
0f
;
const
float
b
=
(
v
[
1
]
-
v
[
2
]
)
*
200
.
0f
;
const
float
Lab_unorm
[
3
]
=
{
L
*
(
1
/
100
.
f
)
(
a
+
128
.
0f
)
*
(
1
/
255
.
0f
)
(
b
+
128
.
0f
)
*
(
1
/
255
.
0f
)
}
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
reinterpret_cast
<
uint16_t
*
>
(
grid16_lab
)
[
i
]
=
SkEndian_SwapBE16
(
float_round_to_unorm16
(
Lab_unorm
[
i
]
)
)
;
}
}
void
SkICCFloatToTable16
(
const
float
f
uint8_t
*
table_16
)
{
*
reinterpret_cast
<
uint16_t
*
>
(
table_16
)
=
SkEndian_SwapBE16
(
float_round_to_unorm16
(
f
)
)
;
}
float
compute_tone_map_gain
(
const
skcms_TransferFunction
&
fn
float
L
)
{
if
(
L
<
=
0
.
f
)
{
return
1
.
f
;
}
if
(
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
constexpr
float
kInputMaxLuminance
=
10000
/
203
.
f
;
constexpr
float
kOutputMaxLuminance
=
1
.
0
;
L
*
=
kInputMaxLuminance
;
constexpr
float
kToneMapA
=
kOutputMaxLuminance
/
(
kInputMaxLuminance
*
kInputMaxLuminance
)
;
constexpr
float
kToneMapB
=
1
.
f
/
kOutputMaxLuminance
;
return
kInputMaxLuminance
*
(
1
.
f
+
kToneMapA
*
L
)
/
(
1
.
f
+
kToneMapB
*
L
)
;
}
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
)
{
constexpr
float
Lw
=
203
.
f
;
const
float
gamma
=
1
.
2f
+
0
.
42f
*
std
:
:
log
(
Lw
/
1000
.
f
)
/
std
:
:
log
(
10
.
f
)
;
return
std
:
:
pow
(
L
gamma
-
1
.
f
)
;
}
return
1
.
f
;
}
static
sk_sp
<
SkData
>
write_trc_tag
(
const
skcms_Curve
&
trc
)
{
SkDynamicMemoryWStream
s
;
if
(
trc
.
table_entries
)
{
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_CurveType
)
)
;
s
.
write32
(
0
)
;
s
.
write32
(
SkEndian_SwapBE32
(
trc
.
table_entries
)
)
;
for
(
uint32_t
i
=
0
;
i
<
trc
.
table_entries
;
+
+
i
)
{
uint16_t
value
=
reinterpret_cast
<
const
uint16_t
*
>
(
trc
.
table_16
)
[
i
]
;
s
.
write16
(
value
)
;
}
}
else
{
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_ParaCurveType
)
)
;
s
.
write32
(
0
)
;
const
auto
&
fn
=
trc
.
parametric
;
SkASSERT
(
skcms_TransferFunction_isSRGBish
(
&
fn
)
)
;
if
(
fn
.
a
=
=
1
.
f
&
&
fn
.
b
=
=
0
.
f
&
&
fn
.
c
=
=
0
.
f
&
&
fn
.
d
=
=
0
.
f
&
&
fn
.
e
=
=
0
.
f
&
&
fn
.
f
=
=
0
.
f
)
{
s
.
write32
(
SkEndian_SwapBE16
(
kExponential_ParaCurveType
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
g
)
)
)
;
}
else
{
s
.
write32
(
SkEndian_SwapBE16
(
kGABCDEF_ParaCurveType
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
g
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
a
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
b
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
c
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
d
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
e
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
f
)
)
)
;
}
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
void
compute_lut_entry
(
const
skcms_Matrix3x3
&
src_to_XYZD50
float
rgb
[
3
]
)
{
skcms_Matrix3x3
src_to_rec2020
;
const
skcms_Matrix3x3
rec2020_to_XYZD50
=
SkNamedGamut
:
:
kRec2020
;
{
skcms_Matrix3x3
XYZD50_to_rec2020
;
skcms_Matrix3x3_invert
(
&
rec2020_to_XYZD50
&
XYZD50_to_rec2020
)
;
src_to_rec2020
=
skcms_Matrix3x3_concat
(
&
XYZD50_to_rec2020
&
src_to_XYZD50
)
;
}
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
rgb
[
i
]
=
skcms_TransferFunction_eval
(
&
SkNamedTransferFn
:
:
kPQ
rgb
[
i
]
)
;
}
skcms_Matrix3x3_apply
(
&
src_to_rec2020
rgb
)
;
constexpr
float
kLr
=
0
.
2627f
;
constexpr
float
kLg
=
0
.
6780f
;
constexpr
float
kLb
=
0
.
0593f
;
float
L
=
rgb
[
0
]
*
kLr
+
rgb
[
1
]
*
kLg
+
rgb
[
2
]
*
kLb
;
float
tone_map_gain
=
compute_tone_map_gain
(
SkNamedTransferFn
:
:
kPQ
L
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
rgb
[
i
]
*
=
tone_map_gain
;
}
skcms_Matrix3x3_apply
(
&
rec2020_to_XYZD50
rgb
)
;
}
sk_sp
<
SkData
>
write_clut
(
const
uint8_t
*
grid_points
const
uint8_t
*
grid_16
)
{
SkDynamicMemoryWStream
s
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
s
.
write8
(
i
<
kNumChannels
?
grid_points
[
i
]
:
0
)
;
}
s
.
write8
(
2
)
;
s
.
write8
(
0
)
;
s
.
write8
(
0
)
;
s
.
write8
(
0
)
;
uint32_t
value_count
=
kNumChannels
;
for
(
uint32_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
value_count
*
=
grid_points
[
i
]
;
}
for
(
uint32_t
i
=
0
;
i
<
value_count
;
+
+
i
)
{
uint16_t
value
=
reinterpret_cast
<
const
uint16_t
*
>
(
grid_16
)
[
i
]
;
s
.
write16
(
value
)
;
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
sk_sp
<
SkData
>
write_mAB_or_mBA_tag
(
uint32_t
type
const
skcms_Curve
*
b_curves
const
skcms_Curve
*
a_curves
const
uint8_t
*
grid_points
const
uint8_t
*
grid_16
const
skcms_Curve
*
m_curves
const
skcms_Matrix3x4
*
matrix
)
{
const
size_t
b_curves_offset
=
32
;
sk_sp
<
SkData
>
b_curves_data
[
kNumChannels
]
;
size_t
clut_offset
=
0
;
sk_sp
<
SkData
>
clut
;
size_t
a_curves_offset
=
0
;
sk_sp
<
SkData
>
a_curves_data
[
kNumChannels
]
;
SkASSERT
(
b_curves
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
b_curves_data
[
i
]
=
write_trc_tag
(
b_curves
[
i
]
)
;
SkASSERT
(
b_curves_data
[
i
]
)
;
}
if
(
a_curves
)
{
SkASSERT
(
grid_points
)
;
SkASSERT
(
grid_16
)
;
clut_offset
=
b_curves_offset
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
clut_offset
+
=
b_curves_data
[
i
]
-
>
size
(
)
;
}
clut
=
write_clut
(
grid_points
grid_16
)
;
SkASSERT
(
clut
)
;
a_curves_offset
=
clut_offset
+
clut
-
>
size
(
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
a_curves_data
[
i
]
=
write_trc_tag
(
a_curves
[
i
]
)
;
SkASSERT
(
a_curves_data
[
i
]
)
;
}
}
SkASSERT
(
!
m_curves
)
;
SkASSERT
(
!
matrix
)
;
SkDynamicMemoryWStream
s
;
s
.
write32
(
SkEndian_SwapBE32
(
type
)
)
;
s
.
write32
(
0
)
;
s
.
write8
(
kNumChannels
)
;
s
.
write8
(
kNumChannels
)
;
s
.
write16
(
0
)
;
s
.
write32
(
SkEndian_SwapBE32
(
b_curves_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
0
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
0
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
clut_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
a_curves_offset
)
)
;
SkASSERT
(
s
.
bytesWritten
(
)
=
=
b_curves_offset
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
s
.
write
(
b_curves_data
[
i
]
-
>
data
(
)
b_curves_data
[
i
]
-
>
size
(
)
)
;
}
if
(
a_curves
)
{
SkASSERT
(
s
.
bytesWritten
(
)
=
=
clut_offset
)
;
s
.
write
(
clut
-
>
data
(
)
clut
-
>
size
(
)
)
;
SkASSERT
(
s
.
bytesWritten
(
)
=
=
a_curves_offset
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
s
.
write
(
a_curves_data
[
i
]
-
>
data
(
)
a_curves_data
[
i
]
-
>
size
(
)
)
;
}
}
return
s
.
detachAsData
(
)
;
}
sk_sp
<
SkData
>
SkWriteICCProfile
(
const
skcms_ICCProfile
*
profile
const
char
*
desc
)
{
ICCHeader
header
;
std
:
:
vector
<
std
:
:
pair
<
uint32_t
sk_sp
<
SkData
>
>
>
tags
;
tags
.
emplace_back
(
kTAG_desc
write_text_tag
(
desc
)
)
;
if
(
profile
-
>
has_toXYZD50
)
{
const
auto
&
m
=
profile
-
>
toXYZD50
;
tags
.
emplace_back
(
kTAG_rXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
0
]
m
.
vals
[
1
]
[
0
]
m
.
vals
[
2
]
[
0
]
)
)
;
tags
.
emplace_back
(
kTAG_gXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
1
]
m
.
vals
[
1
]
[
1
]
m
.
vals
[
2
]
[
1
]
)
)
;
tags
.
emplace_back
(
kTAG_bXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
2
]
m
.
vals
[
1
]
[
2
]
m
.
vals
[
2
]
[
2
]
)
)
;
}
tags
.
emplace_back
(
kTAG_wtpt
write_xyz_tag
(
kD50_x
kD50_y
kD50_z
)
)
;
if
(
profile
-
>
has_trc
)
{
tags
.
emplace_back
(
kTAG_rTRC
write_trc_tag
(
profile
-
>
trc
[
0
]
)
)
;
if
(
!
memcmp
(
&
profile
-
>
trc
[
1
]
&
profile
-
>
trc
[
0
]
sizeof
(
profile
-
>
trc
[
0
]
)
)
)
{
tags
.
emplace_back
(
kTAG_gTRC
SkData
:
:
MakeEmpty
(
)
)
;
}
else
{
tags
.
emplace_back
(
kTAG_gTRC
write_trc_tag
(
profile
-
>
trc
[
1
]
)
)
;
}
if
(
!
memcmp
(
&
profile
-
>
trc
[
2
]
&
profile
-
>
trc
[
1
]
sizeof
(
profile
-
>
trc
[
1
]
)
)
)
{
tags
.
emplace_back
(
kTAG_bTRC
SkData
:
:
MakeEmpty
(
)
)
;
}
else
{
tags
.
emplace_back
(
kTAG_bTRC
write_trc_tag
(
profile
-
>
trc
[
2
]
)
)
;
}
}
if
(
profile
-
>
has_CICP
)
{
header
.
version
=
SkEndian_SwapBE32
(
0x04400000
)
;
tags
.
emplace_back
(
kTAG_cicp
write_cicp_tag
(
profile
-
>
CICP
)
)
;
}
if
(
profile
-
>
has_A2B
)
{
const
auto
&
a2b
=
profile
-
>
A2B
;
SkASSERT
(
a2b
.
output_channels
=
=
kNumChannels
)
;
auto
a2b_data
=
write_mAB_or_mBA_tag
(
kTAG_mABType
a2b
.
output_curves
a2b
.
input_channels
?
a2b
.
input_curves
:
nullptr
a2b
.
input_channels
?
a2b
.
grid_points
:
nullptr
a2b
.
input_channels
?
a2b
.
grid_16
:
nullptr
a2b
.
matrix_channels
?
a2b
.
matrix_curves
:
nullptr
a2b
.
matrix_channels
?
&
a2b
.
matrix
:
nullptr
)
;
tags
.
emplace_back
(
kTAG_A2B0
std
:
:
move
(
a2b_data
)
)
;
}
if
(
profile
-
>
has_B2A
)
{
const
auto
&
b2a
=
profile
-
>
B2A
;
SkASSERT
(
b2a
.
input_channels
=
=
kNumChannels
)
;
auto
b2a_data
=
write_mAB_or_mBA_tag
(
kTAG_mBAType
b2a
.
input_curves
b2a
.
output_channels
?
b2a
.
input_curves
:
nullptr
b2a
.
output_channels
?
b2a
.
grid_points
:
nullptr
b2a
.
output_channels
?
b2a
.
grid_16
:
nullptr
b2a
.
matrix_channels
?
b2a
.
matrix_curves
:
nullptr
b2a
.
matrix_channels
?
&
b2a
.
matrix
:
nullptr
)
;
tags
.
emplace_back
(
kTAG_B2A0
std
:
:
move
(
b2a_data
)
)
;
}
tags
.
emplace_back
(
kTAG_cprt
write_text_tag
(
"
Google
Inc
.
2016
"
)
)
;
size_t
tag_data_size
=
0
;
for
(
const
auto
&
tag
:
tags
)
{
tag_data_size
+
=
tag
.
second
-
>
size
(
)
;
}
size_t
tag_table_size
=
kICCTagTableEntrySize
*
tags
.
size
(
)
;
size_t
profile_size
=
kICCHeaderSize
+
tag_table_size
+
tag_data_size
;
header
.
data_color_space
=
SkEndian_SwapBE32
(
profile
-
>
data_color_space
)
;
header
.
pcs
=
SkEndian_SwapBE32
(
profile
-
>
pcs
)
;
header
.
size
=
SkEndian_SwapBE32
(
profile_size
)
;
header
.
tag_count
=
SkEndian_SwapBE32
(
tags
.
size
(
)
)
;
SkAutoMalloc
profile_data
(
profile_size
)
;
uint8_t
*
ptr
=
(
uint8_t
*
)
profile_data
.
get
(
)
;
memcpy
(
ptr
&
header
sizeof
(
header
)
)
;
ptr
+
=
sizeof
(
header
)
;
size_t
last_tag_offset
=
sizeof
(
header
)
+
tag_table_size
;
size_t
last_tag_size
=
0
;
for
(
const
auto
&
tag
:
tags
)
{
if
(
!
tag
.
second
-
>
isEmpty
(
)
)
{
last_tag_offset
=
last_tag_offset
+
last_tag_size
;
last_tag_size
=
tag
.
second
-
>
size
(
)
;
}
uint32_t
tag_table_entry
[
3
]
=
{
SkEndian_SwapBE32
(
tag
.
first
)
SkEndian_SwapBE32
(
last_tag_offset
)
SkEndian_SwapBE32
(
last_tag_size
)
}
;
memcpy
(
ptr
tag_table_entry
sizeof
(
tag_table_entry
)
)
;
ptr
+
=
sizeof
(
tag_table_entry
)
;
}
for
(
const
auto
&
tag
:
tags
)
{
if
(
tag
.
second
-
>
isEmpty
(
)
)
continue
;
memcpy
(
ptr
tag
.
second
-
>
data
(
)
tag
.
second
-
>
size
(
)
)
;
ptr
+
=
tag
.
second
-
>
size
(
)
;
}
SkASSERT
(
profile_size
=
=
static_cast
<
size_t
>
(
ptr
-
(
uint8_t
*
)
profile_data
.
get
(
)
)
)
;
return
SkData
:
:
MakeFromMalloc
(
profile_data
.
release
(
)
profile_size
)
;
}
sk_sp
<
SkData
>
SkWriteICCProfile
(
const
skcms_TransferFunction
&
fn
const
skcms_Matrix3x3
&
toXYZD50
)
{
skcms_ICCProfile
profile
;
memset
(
&
profile
0
sizeof
(
profile
)
)
;
std
:
:
vector
<
uint8_t
>
trc_table
;
std
:
:
vector
<
uint8_t
>
a2b_grid
;
profile
.
data_color_space
=
skcms_Signature_RGB
;
profile
.
pcs
=
skcms_Signature_XYZ
;
{
profile
.
has_toXYZD50
=
true
;
profile
.
toXYZD50
=
toXYZD50
;
}
if
(
!
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
profile
.
has_trc
=
true
;
if
(
skcms_TransferFunction_isSRGBish
(
&
fn
)
)
{
profile
.
trc
[
0
]
.
table_entries
=
0
;
profile
.
trc
[
0
]
.
parametric
=
fn
;
}
else
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
)
{
skcms_TransferFunction
scaled_hlg
=
SkNamedTransferFn
:
:
kHLG
;
scaled_hlg
.
f
=
1
/
12
.
f
-
1
.
f
;
constexpr
uint32_t
kTrcTableSize
=
65
;
trc_table
.
resize
(
kTrcTableSize
*
2
)
;
for
(
uint32_t
i
=
0
;
i
<
kTrcTableSize
;
+
+
i
)
{
float
x
=
i
/
(
kTrcTableSize
-
1
.
f
)
;
float
y
=
skcms_TransferFunction_eval
(
&
scaled_hlg
x
)
;
y
*
=
compute_tone_map_gain
(
scaled_hlg
y
)
;
SkICCFloatToTable16
(
y
&
trc_table
[
2
*
i
]
)
;
}
profile
.
trc
[
0
]
.
table_entries
=
kTrcTableSize
;
profile
.
trc
[
0
]
.
table_16
=
reinterpret_cast
<
uint8_t
*
>
(
trc_table
.
data
(
)
)
;
}
memcpy
(
&
profile
.
trc
[
1
]
&
profile
.
trc
[
0
]
sizeof
(
profile
.
trc
[
0
]
)
)
;
memcpy
(
&
profile
.
trc
[
2
]
&
profile
.
trc
[
0
]
sizeof
(
profile
.
trc
[
0
]
)
)
;
}
if
(
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
profile
.
pcs
=
skcms_Signature_Lab
;
constexpr
uint32_t
kGridSize
=
17
;
profile
.
has_A2B
=
true
;
profile
.
A2B
.
input_channels
=
kNumChannels
;
profile
.
A2B
.
output_channels
=
kNumChannels
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
profile
.
A2B
.
input_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
profile
.
A2B
.
output_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
profile
.
A2B
.
grid_points
[
i
]
=
kGridSize
;
}
a2b_grid
.
resize
(
kGridSize
*
kGridSize
*
kGridSize
*
kNumChannels
*
2
)
;
size_t
a2b_grid_index
=
0
;
for
(
uint32_t
r_index
=
0
;
r_index
<
kGridSize
;
+
+
r_index
)
{
for
(
uint32_t
g_index
=
0
;
g_index
<
kGridSize
;
+
+
g_index
)
{
for
(
uint32_t
b_index
=
0
;
b_index
<
kGridSize
;
+
+
b_index
)
{
float
rgb
[
3
]
=
{
r_index
/
(
kGridSize
-
1
.
f
)
g_index
/
(
kGridSize
-
1
.
f
)
b_index
/
(
kGridSize
-
1
.
f
)
}
;
compute_lut_entry
(
toXYZD50
rgb
)
;
SkICCFloatXYZD50ToGrid16Lab
(
rgb
&
a2b_grid
[
a2b_grid_index
]
)
;
a2b_grid_index
+
=
6
;
}
}
}
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
profile
.
A2B
.
grid_points
[
i
]
=
kGridSize
;
}
profile
.
A2B
.
grid_16
=
reinterpret_cast
<
const
uint8_t
*
>
(
a2b_grid
.
data
(
)
)
;
profile
.
has_B2A
=
true
;
profile
.
B2A
.
input_channels
=
kNumChannels
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
profile
.
B2A
.
input_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
}
}
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
|
|
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
profile
.
has_CICP
=
true
;
profile
.
CICP
.
color_primaries
=
get_cicp_primaries
(
toXYZD50
)
;
profile
.
CICP
.
transfer_characteristics
=
get_cicp_trfn
(
fn
)
;
profile
.
CICP
.
matrix_coefficients
=
0
;
profile
.
CICP
.
video_full_range_flag
=
1
;
SkASSERT
(
profile
.
CICP
.
color_primaries
)
;
SkASSERT
(
profile
.
CICP
.
transfer_characteristics
)
;
}
std
:
:
string
description
=
get_desc_string
(
fn
toXYZD50
)
;
return
SkWriteICCProfile
(
&
profile
description
.
c_str
(
)
)
;
}
