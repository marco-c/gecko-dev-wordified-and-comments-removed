#
include
"
include
/
encode
/
SkICC
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkFixed
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
modules
/
skcms
/
skcms
.
h
"
#
include
"
src
/
base
/
SkAutoMalloc
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
core
/
SkMD5
.
h
"
#
include
"
src
/
encode
/
SkICCPriv
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
namespace
{
constexpr
size_t
kNumChannels
=
3
;
constexpr
float
kD50_x
=
0
.
9642f
;
constexpr
float
kD50_y
=
1
.
0000f
;
constexpr
float
kD50_z
=
0
.
8249f
;
SkFixed
float_round_to_fixed
(
float
x
)
{
return
sk_float_saturate2int
(
(
float
)
floor
(
(
double
)
x
*
SK_Fixed1
+
0
.
5
)
)
;
}
uint16_t
float_to_uInt16Number
(
float
x
uint16_t
one
)
{
x
=
x
*
one
+
0
.
5
;
if
(
x
>
one
)
return
one
;
if
(
x
<
0
)
return
0
;
return
static_cast
<
uint16_t
>
(
x
)
;
}
constexpr
uint16_t
kOne16CurveType
=
0xFFFF
;
constexpr
uint16_t
kOne16XYZ
=
0x8000
;
struct
ICCHeader
{
uint32_t
size
;
uint32_t
cmm_type
=
0
;
uint32_t
version
=
SkEndian_SwapBE32
(
0x04300000
)
;
uint32_t
profile_class
=
SkEndian_SwapBE32
(
kDisplay_Profile
)
;
uint32_t
data_color_space
=
SkEndian_SwapBE32
(
kRGB_ColorSpace
)
;
uint32_t
pcs
=
SkEndian_SwapBE32
(
kXYZ_PCSSpace
)
;
uint16_t
creation_date_year
=
SkEndian_SwapBE16
(
2016
)
;
uint16_t
creation_date_month
=
SkEndian_SwapBE16
(
1
)
;
uint16_t
creation_date_day
=
SkEndian_SwapBE16
(
1
)
;
uint16_t
creation_date_hours
=
0
;
uint16_t
creation_date_minutes
=
0
;
uint16_t
creation_date_seconds
=
0
;
uint32_t
signature
=
SkEndian_SwapBE32
(
kACSP_Signature
)
;
uint32_t
platform
=
0
;
uint32_t
flags
=
0x00000000
;
uint32_t
device_manufacturer
=
0
;
uint32_t
device_model
=
0
;
uint8_t
device_attributes
[
8
]
=
{
0
}
;
uint32_t
rendering_intent
=
SkEndian_SwapBE32
(
1
)
;
uint32_t
illuminant_X
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_x
)
)
;
uint32_t
illuminant_Y
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_y
)
)
;
uint32_t
illuminant_Z
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
kD50_z
)
)
;
uint32_t
creator
=
0
;
uint8_t
profile_id
[
16
]
=
{
0
}
;
uint8_t
reserved
[
28
]
=
{
0
}
;
uint32_t
tag_count
=
0
;
}
;
sk_sp
<
SkData
>
write_xyz_tag
(
float
x
float
y
float
z
)
{
uint32_t
data
[
]
=
{
SkEndian_SwapBE32
(
kXYZ_PCSSpace
)
0
SkEndian_SwapBE32
(
float_round_to_fixed
(
x
)
)
SkEndian_SwapBE32
(
float_round_to_fixed
(
y
)
)
SkEndian_SwapBE32
(
float_round_to_fixed
(
z
)
)
}
;
return
SkData
:
:
MakeWithCopy
(
data
sizeof
(
data
)
)
;
}
sk_sp
<
SkData
>
write_matrix
(
const
skcms_Matrix3x4
*
matrix
)
{
uint32_t
data
[
12
]
;
size_t
k
=
0
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
3
;
+
+
j
)
{
data
[
k
+
+
]
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
matrix
-
>
vals
[
i
]
[
j
]
)
)
;
}
}
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
data
[
k
+
+
]
=
SkEndian_SwapBE32
(
float_round_to_fixed
(
matrix
-
>
vals
[
i
]
[
3
]
)
)
;
}
return
SkData
:
:
MakeWithCopy
(
data
sizeof
(
data
)
)
;
}
bool
nearly_equal
(
float
x
float
y
)
{
static
constexpr
float
kTolerance
=
1
.
0f
/
(
1
<
<
11
)
;
return
:
:
fabsf
(
x
-
y
)
<
=
kTolerance
;
}
bool
nearly_equal
(
const
skcms_TransferFunction
&
u
const
skcms_TransferFunction
&
v
)
{
return
nearly_equal
(
u
.
g
v
.
g
)
&
&
nearly_equal
(
u
.
a
v
.
a
)
&
&
nearly_equal
(
u
.
b
v
.
b
)
&
&
nearly_equal
(
u
.
c
v
.
c
)
&
&
nearly_equal
(
u
.
d
v
.
d
)
&
&
nearly_equal
(
u
.
e
v
.
e
)
&
&
nearly_equal
(
u
.
f
v
.
f
)
;
}
bool
nearly_equal
(
const
skcms_Matrix3x3
&
u
const
skcms_Matrix3x3
&
v
)
{
for
(
int
r
=
0
;
r
<
3
;
r
+
+
)
{
for
(
int
c
=
0
;
c
<
3
;
c
+
+
)
{
if
(
!
nearly_equal
(
u
.
vals
[
r
]
[
c
]
v
.
vals
[
r
]
[
c
]
)
)
{
return
false
;
}
}
}
return
true
;
}
constexpr
uint32_t
kCICPPrimariesSRGB
=
1
;
constexpr
uint32_t
kCICPPrimariesP3
=
12
;
constexpr
uint32_t
kCICPPrimariesRec2020
=
9
;
uint32_t
get_cicp_primaries
(
const
skcms_Matrix3x3
&
toXYZD50
)
{
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kSRGB
)
)
{
return
kCICPPrimariesSRGB
;
}
else
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kDisplayP3
)
)
{
return
kCICPPrimariesP3
;
}
else
if
(
nearly_equal
(
toXYZD50
SkNamedGamut
:
:
kRec2020
)
)
{
return
kCICPPrimariesRec2020
;
}
return
0
;
}
constexpr
uint32_t
kCICPTrfnSRGB
=
1
;
constexpr
uint32_t
kCICPTrfn2Dot2
=
4
;
constexpr
uint32_t
kCICPTrfnLinear
=
8
;
constexpr
uint32_t
kCICPTrfnPQ
=
16
;
constexpr
uint32_t
kCICPTrfnHLG
=
18
;
uint32_t
get_cicp_trfn
(
const
skcms_TransferFunction
&
fn
)
{
switch
(
skcms_TransferFunction_getType
(
&
fn
)
)
{
case
skcms_TFType_Invalid
:
return
0
;
case
skcms_TFType_sRGBish
:
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
kSRGB
)
)
{
return
kCICPTrfnSRGB
;
}
else
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
k2Dot2
)
)
{
return
kCICPTrfn2Dot2
;
}
else
if
(
nearly_equal
(
fn
SkNamedTransferFn
:
:
kLinear
)
)
{
return
kCICPTrfnLinear
;
}
break
;
case
skcms_TFType_PQish
:
return
kCICPTrfnPQ
;
case
skcms_TFType_HLGish
:
return
kCICPTrfnHLG
;
case
skcms_TFType_HLGinvish
:
return
0
;
}
return
0
;
}
std
:
:
string
get_desc_string
(
const
skcms_TransferFunction
&
fn
const
skcms_Matrix3x3
&
toXYZD50
)
{
const
uint32_t
cicp_trfn
=
get_cicp_trfn
(
fn
)
;
const
uint32_t
cicp_primaries
=
get_cicp_primaries
(
toXYZD50
)
;
if
(
cicp_trfn
=
=
kCICPPrimariesSRGB
&
&
cicp_primaries
=
=
kCICPTrfnSRGB
)
{
return
"
sRGB
"
;
}
if
(
cicp_primaries
&
&
cicp_trfn
)
{
std
:
:
string
result
;
switch
(
cicp_primaries
)
{
case
kCICPPrimariesSRGB
:
result
+
=
"
sRGB
"
;
break
;
case
kCICPPrimariesP3
:
result
+
=
"
Display
P3
"
;
break
;
case
kCICPPrimariesRec2020
:
result
+
=
"
Rec2020
"
;
break
;
default
:
result
+
=
"
Unknown
"
;
break
;
}
result
+
=
"
Gamut
with
"
;
switch
(
cicp_trfn
)
{
case
kCICPTrfnSRGB
:
result
+
=
"
sRGB
"
;
break
;
case
kCICPTrfnLinear
:
result
+
=
"
Linear
"
;
break
;
case
kCICPTrfn2Dot2
:
result
+
=
"
2
.
2
"
;
break
;
case
kCICPTrfnPQ
:
result
+
=
"
PQ
"
;
break
;
case
kCICPTrfnHLG
:
result
+
=
"
HLG
"
;
break
;
default
:
result
+
=
"
Unknown
"
;
break
;
}
result
+
=
"
Transfer
"
;
return
result
;
}
SkMD5
md5
;
md5
.
write
(
&
toXYZD50
sizeof
(
toXYZD50
)
)
;
md5
.
write
(
&
fn
sizeof
(
fn
)
)
;
SkMD5
:
:
Digest
digest
=
md5
.
finish
(
)
;
return
std
:
:
string
(
"
Google
/
Skia
/
"
)
+
digest
.
toHexString
(
)
.
c_str
(
)
;
}
sk_sp
<
SkData
>
write_text_tag
(
const
char
*
text
)
{
uint32_t
text_length
=
strlen
(
text
)
;
uint32_t
header
[
]
=
{
SkEndian_SwapBE32
(
kTAG_TextType
)
0
SkEndian_SwapBE32
(
1
)
SkEndian_SwapBE32
(
12
)
SkEndian_SwapBE32
(
SkSetFourByteTag
(
'
e
'
'
n
'
'
U
'
'
S
'
)
)
SkEndian_SwapBE32
(
2
*
text_length
)
SkEndian_SwapBE32
(
28
)
}
;
SkDynamicMemoryWStream
s
;
s
.
write
(
header
sizeof
(
header
)
)
;
for
(
size_t
i
=
0
;
i
<
text_length
;
i
+
+
)
{
s
.
write8
(
0
)
;
s
.
write8
(
text
[
i
]
)
;
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
sk_sp
<
SkData
>
write_cicp_tag
(
const
skcms_CICP
&
cicp
)
{
SkDynamicMemoryWStream
s
;
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_cicp
)
)
;
s
.
write32
(
0
)
;
s
.
write8
(
cicp
.
color_primaries
)
;
s
.
write8
(
cicp
.
transfer_characteristics
)
;
s
.
write8
(
cicp
.
matrix_coefficients
)
;
s
.
write8
(
cicp
.
video_full_range_flag
)
;
return
s
.
detachAsData
(
)
;
}
constexpr
float
kToneMapInputMax
=
1000
.
f
/
203
.
f
;
constexpr
float
kToneMapOutputMax
=
1
.
f
;
float
tone_map_gain
(
float
x
)
{
constexpr
float
kToneMapA
=
kToneMapOutputMax
/
(
kToneMapInputMax
*
kToneMapInputMax
)
;
constexpr
float
kToneMapB
=
1
.
f
/
kToneMapOutputMax
;
return
(
1
.
f
+
kToneMapA
*
x
)
/
(
1
.
f
+
kToneMapB
*
x
)
;
}
float
tone_map_inverse
(
float
y
)
{
constexpr
float
kToneMapA
=
kToneMapOutputMax
/
(
kToneMapInputMax
*
kToneMapInputMax
)
;
constexpr
float
kToneMapB
=
1
.
f
/
kToneMapOutputMax
;
const
float
a
=
kToneMapA
;
const
float
b
=
(
1
-
kToneMapB
*
y
)
;
const
float
c
=
-
y
;
const
float
discriminant
=
b
*
b
-
4
.
f
*
a
*
c
;
if
(
discriminant
<
0
.
f
)
{
return
0
.
f
;
}
return
(
-
b
+
sqrtf
(
discriminant
)
)
/
(
2
.
f
*
a
)
;
}
float
hdr_trfn_eval
(
const
skcms_TransferFunction
&
fn
float
x
)
{
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
)
{
x
=
skcms_TransferFunction_eval
(
&
SkNamedTransferFn
:
:
kHLG
x
)
/
12
.
f
;
x
*
=
std
:
:
pow
(
x
0
.
2
)
;
}
else
if
(
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
x
=
10
.
f
*
skcms_TransferFunction_eval
(
&
SkNamedTransferFn
:
:
kPQ
x
)
;
x
=
std
:
:
min
(
x
1
.
f
)
;
}
x
*
=
kToneMapInputMax
;
return
x
;
}
sk_sp
<
SkData
>
write_trc_tag
(
const
skcms_Curve
&
trc
)
{
SkDynamicMemoryWStream
s
;
if
(
trc
.
table_entries
)
{
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_CurveType
)
)
;
s
.
write32
(
0
)
;
s
.
write32
(
SkEndian_SwapBE32
(
trc
.
table_entries
)
)
;
for
(
uint32_t
i
=
0
;
i
<
trc
.
table_entries
;
+
+
i
)
{
uint16_t
value
=
reinterpret_cast
<
const
uint16_t
*
>
(
trc
.
table_16
)
[
i
]
;
s
.
write16
(
value
)
;
}
}
else
{
s
.
write32
(
SkEndian_SwapBE32
(
kTAG_ParaCurveType
)
)
;
s
.
write32
(
0
)
;
const
auto
&
fn
=
trc
.
parametric
;
SkASSERT
(
skcms_TransferFunction_isSRGBish
(
&
fn
)
)
;
if
(
fn
.
a
=
=
1
.
f
&
&
fn
.
b
=
=
0
.
f
&
&
fn
.
c
=
=
0
.
f
&
&
fn
.
d
=
=
0
.
f
&
&
fn
.
e
=
=
0
.
f
&
&
fn
.
f
=
=
0
.
f
)
{
s
.
write32
(
SkEndian_SwapBE16
(
kExponential_ParaCurveType
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
g
)
)
)
;
}
else
{
s
.
write32
(
SkEndian_SwapBE16
(
kGABCDEF_ParaCurveType
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
g
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
a
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
b
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
c
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
d
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
e
)
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
float_round_to_fixed
(
fn
.
f
)
)
)
;
}
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
sk_sp
<
SkData
>
write_clut
(
const
uint8_t
*
grid_points
const
uint8_t
*
grid_16
)
{
SkDynamicMemoryWStream
s
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
s
.
write8
(
i
<
kNumChannels
?
grid_points
[
i
]
:
0
)
;
}
s
.
write8
(
2
)
;
s
.
write8
(
0
)
;
s
.
write8
(
0
)
;
s
.
write8
(
0
)
;
uint32_t
value_count
=
kNumChannels
;
for
(
uint32_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
value_count
*
=
grid_points
[
i
]
;
}
for
(
uint32_t
i
=
0
;
i
<
value_count
;
+
+
i
)
{
uint16_t
value
=
reinterpret_cast
<
const
uint16_t
*
>
(
grid_16
)
[
i
]
;
s
.
write16
(
value
)
;
}
s
.
padToAlign4
(
)
;
return
s
.
detachAsData
(
)
;
}
sk_sp
<
SkData
>
write_mAB_or_mBA_tag
(
uint32_t
type
const
skcms_Curve
*
b_curves
const
skcms_Curve
*
a_curves
const
uint8_t
*
grid_points
const
uint8_t
*
grid_16
const
skcms_Curve
*
m_curves
const
skcms_Matrix3x4
*
matrix
)
{
size_t
offset
=
32
;
size_t
b_curves_offset
=
offset
;
sk_sp
<
SkData
>
b_curves_data
[
kNumChannels
]
;
SkASSERT
(
b_curves
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
b_curves_data
[
i
]
=
write_trc_tag
(
b_curves
[
i
]
)
;
SkASSERT
(
b_curves_data
[
i
]
)
;
offset
+
=
b_curves_data
[
i
]
-
>
size
(
)
;
}
size_t
clut_offset
=
0
;
sk_sp
<
SkData
>
clut
;
if
(
grid_points
)
{
SkASSERT
(
grid_16
)
;
clut_offset
=
offset
;
clut
=
write_clut
(
grid_points
grid_16
)
;
SkASSERT
(
clut
)
;
offset
+
=
clut
-
>
size
(
)
;
}
size_t
a_curves_offset
=
0
;
sk_sp
<
SkData
>
a_curves_data
[
kNumChannels
]
;
if
(
a_curves
)
{
SkASSERT
(
grid_points
)
;
SkASSERT
(
grid_16
)
;
a_curves_offset
=
offset
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
a_curves_data
[
i
]
=
write_trc_tag
(
a_curves
[
i
]
)
;
SkASSERT
(
a_curves_data
[
i
]
)
;
offset
+
=
a_curves_data
[
i
]
-
>
size
(
)
;
}
}
size_t
matrix_offset
=
0
;
sk_sp
<
SkData
>
matrix_data
;
if
(
matrix
)
{
SkASSERT
(
m_curves
)
;
matrix_offset
=
offset
;
matrix_data
=
write_matrix
(
matrix
)
;
offset
+
=
matrix_data
-
>
size
(
)
;
}
size_t
m_curves_offset
=
0
;
sk_sp
<
SkData
>
m_curves_data
[
kNumChannels
]
;
if
(
m_curves
)
{
SkASSERT
(
matrix
)
;
m_curves_offset
=
offset
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
m_curves_data
[
i
]
=
write_trc_tag
(
m_curves
[
i
]
)
;
SkASSERT
(
a_curves_data
[
i
]
)
;
offset
+
=
m_curves_data
[
i
]
-
>
size
(
)
;
}
}
SkDynamicMemoryWStream
s
;
s
.
write32
(
SkEndian_SwapBE32
(
type
)
)
;
s
.
write32
(
0
)
;
s
.
write8
(
kNumChannels
)
;
s
.
write8
(
kNumChannels
)
;
s
.
write16
(
0
)
;
s
.
write32
(
SkEndian_SwapBE32
(
b_curves_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
matrix_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
m_curves_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
clut_offset
)
)
;
s
.
write32
(
SkEndian_SwapBE32
(
a_curves_offset
)
)
;
SkASSERT
(
s
.
bytesWritten
(
)
=
=
b_curves_offset
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
s
.
write
(
b_curves_data
[
i
]
-
>
data
(
)
b_curves_data
[
i
]
-
>
size
(
)
)
;
}
if
(
clut
)
{
SkASSERT
(
s
.
bytesWritten
(
)
=
=
clut_offset
)
;
s
.
write
(
clut
-
>
data
(
)
clut
-
>
size
(
)
)
;
}
if
(
a_curves
)
{
SkASSERT
(
s
.
bytesWritten
(
)
=
=
a_curves_offset
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
s
.
write
(
a_curves_data
[
i
]
-
>
data
(
)
a_curves_data
[
i
]
-
>
size
(
)
)
;
}
}
if
(
matrix_data
)
{
SkASSERT
(
s
.
bytesWritten
(
)
=
=
matrix_offset
)
;
s
.
write
(
matrix_data
-
>
data
(
)
matrix_data
-
>
size
(
)
)
;
}
if
(
m_curves
)
{
SkASSERT
(
s
.
bytesWritten
(
)
=
=
m_curves_offset
)
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
s
.
write
(
m_curves_data
[
i
]
-
>
data
(
)
m_curves_data
[
i
]
-
>
size
(
)
)
;
}
}
return
s
.
detachAsData
(
)
;
}
}
sk_sp
<
SkData
>
SkWriteICCProfile
(
const
skcms_ICCProfile
*
profile
const
char
*
desc
)
{
ICCHeader
header
;
std
:
:
vector
<
std
:
:
pair
<
uint32_t
sk_sp
<
SkData
>
>
>
tags
;
if
(
profile
-
>
has_toXYZD50
)
{
const
auto
&
m
=
profile
-
>
toXYZD50
;
tags
.
emplace_back
(
kTAG_rXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
0
]
m
.
vals
[
1
]
[
0
]
m
.
vals
[
2
]
[
0
]
)
)
;
tags
.
emplace_back
(
kTAG_gXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
1
]
m
.
vals
[
1
]
[
1
]
m
.
vals
[
2
]
[
1
]
)
)
;
tags
.
emplace_back
(
kTAG_bXYZ
write_xyz_tag
(
m
.
vals
[
0
]
[
2
]
m
.
vals
[
1
]
[
2
]
m
.
vals
[
2
]
[
2
]
)
)
;
}
tags
.
emplace_back
(
kTAG_wtpt
write_xyz_tag
(
kD50_x
kD50_y
kD50_z
)
)
;
if
(
profile
-
>
has_trc
)
{
tags
.
emplace_back
(
kTAG_rTRC
write_trc_tag
(
profile
-
>
trc
[
0
]
)
)
;
if
(
!
memcmp
(
&
profile
-
>
trc
[
1
]
&
profile
-
>
trc
[
0
]
sizeof
(
profile
-
>
trc
[
0
]
)
)
)
{
tags
.
emplace_back
(
kTAG_gTRC
SkData
:
:
MakeEmpty
(
)
)
;
}
else
{
tags
.
emplace_back
(
kTAG_gTRC
write_trc_tag
(
profile
-
>
trc
[
1
]
)
)
;
}
if
(
!
memcmp
(
&
profile
-
>
trc
[
2
]
&
profile
-
>
trc
[
1
]
sizeof
(
profile
-
>
trc
[
1
]
)
)
)
{
tags
.
emplace_back
(
kTAG_bTRC
SkData
:
:
MakeEmpty
(
)
)
;
}
else
{
tags
.
emplace_back
(
kTAG_bTRC
write_trc_tag
(
profile
-
>
trc
[
2
]
)
)
;
}
}
if
(
profile
-
>
has_CICP
)
{
header
.
version
=
SkEndian_SwapBE32
(
0x04400000
)
;
tags
.
emplace_back
(
kTAG_cicp
write_cicp_tag
(
profile
-
>
CICP
)
)
;
}
if
(
profile
-
>
has_A2B
)
{
const
auto
&
a2b
=
profile
-
>
A2B
;
SkASSERT
(
a2b
.
output_channels
=
=
kNumChannels
)
;
auto
a2b_data
=
write_mAB_or_mBA_tag
(
kTAG_mABType
a2b
.
output_curves
a2b
.
input_channels
?
a2b
.
input_curves
:
nullptr
a2b
.
input_channels
?
a2b
.
grid_points
:
nullptr
a2b
.
input_channels
?
a2b
.
grid_16
:
nullptr
a2b
.
matrix_channels
?
a2b
.
matrix_curves
:
nullptr
a2b
.
matrix_channels
?
&
a2b
.
matrix
:
nullptr
)
;
tags
.
emplace_back
(
kTAG_A2B0
std
:
:
move
(
a2b_data
)
)
;
}
if
(
profile
-
>
has_B2A
)
{
const
auto
&
b2a
=
profile
-
>
B2A
;
SkASSERT
(
b2a
.
input_channels
=
=
kNumChannels
)
;
auto
b2a_data
=
write_mAB_or_mBA_tag
(
kTAG_mBAType
b2a
.
input_curves
b2a
.
output_channels
?
b2a
.
input_curves
:
nullptr
b2a
.
output_channels
?
b2a
.
grid_points
:
nullptr
b2a
.
output_channels
?
b2a
.
grid_16
:
nullptr
b2a
.
matrix_channels
?
b2a
.
matrix_curves
:
nullptr
b2a
.
matrix_channels
?
&
b2a
.
matrix
:
nullptr
)
;
tags
.
emplace_back
(
kTAG_B2A0
std
:
:
move
(
b2a_data
)
)
;
}
tags
.
emplace_back
(
kTAG_cprt
write_text_tag
(
"
Google
Inc
.
2016
"
)
)
;
std
:
:
string
generatedDesc
;
if
(
!
desc
|
|
*
desc
=
=
'
\
0
'
)
{
SkMD5
md5
;
for
(
const
auto
&
tag
:
tags
)
{
md5
.
write
(
&
tag
.
first
sizeof
(
tag
.
first
)
)
;
md5
.
write
(
tag
.
second
-
>
bytes
(
)
tag
.
second
-
>
size
(
)
)
;
}
SkMD5
:
:
Digest
digest
=
md5
.
finish
(
)
;
generatedDesc
=
std
:
:
string
(
"
Google
/
Skia
/
"
)
+
digest
.
toHexString
(
)
.
c_str
(
)
;
desc
=
generatedDesc
.
c_str
(
)
;
}
tags
.
emplace
(
tags
.
begin
(
)
kTAG_desc
write_text_tag
(
desc
)
)
;
size_t
tag_data_size
=
0
;
for
(
const
auto
&
tag
:
tags
)
{
tag_data_size
+
=
tag
.
second
-
>
size
(
)
;
}
size_t
tag_table_size
=
kICCTagTableEntrySize
*
tags
.
size
(
)
;
size_t
profile_size
=
kICCHeaderSize
+
tag_table_size
+
tag_data_size
;
header
.
data_color_space
=
SkEndian_SwapBE32
(
profile
-
>
data_color_space
)
;
header
.
pcs
=
SkEndian_SwapBE32
(
profile
-
>
pcs
)
;
header
.
size
=
SkEndian_SwapBE32
(
profile_size
)
;
header
.
tag_count
=
SkEndian_SwapBE32
(
tags
.
size
(
)
)
;
SkAutoMalloc
profile_data
(
profile_size
)
;
uint8_t
*
ptr
=
(
uint8_t
*
)
profile_data
.
get
(
)
;
memcpy
(
ptr
&
header
sizeof
(
header
)
)
;
ptr
+
=
sizeof
(
header
)
;
size_t
last_tag_offset
=
sizeof
(
header
)
+
tag_table_size
;
size_t
last_tag_size
=
0
;
for
(
const
auto
&
tag
:
tags
)
{
if
(
!
tag
.
second
-
>
isEmpty
(
)
)
{
last_tag_offset
=
last_tag_offset
+
last_tag_size
;
last_tag_size
=
tag
.
second
-
>
size
(
)
;
}
uint32_t
tag_table_entry
[
3
]
=
{
SkEndian_SwapBE32
(
tag
.
first
)
SkEndian_SwapBE32
(
last_tag_offset
)
SkEndian_SwapBE32
(
last_tag_size
)
}
;
memcpy
(
ptr
tag_table_entry
sizeof
(
tag_table_entry
)
)
;
ptr
+
=
sizeof
(
tag_table_entry
)
;
}
for
(
const
auto
&
tag
:
tags
)
{
if
(
tag
.
second
-
>
isEmpty
(
)
)
continue
;
memcpy
(
ptr
tag
.
second
-
>
data
(
)
tag
.
second
-
>
size
(
)
)
;
ptr
+
=
tag
.
second
-
>
size
(
)
;
}
SkASSERT
(
profile_size
=
=
static_cast
<
size_t
>
(
ptr
-
(
uint8_t
*
)
profile_data
.
get
(
)
)
)
;
return
SkData
:
:
MakeFromMalloc
(
profile_data
.
release
(
)
profile_size
)
;
}
sk_sp
<
SkData
>
SkWriteICCProfile
(
const
skcms_TransferFunction
&
fn
const
skcms_Matrix3x3
&
toXYZD50
)
{
skcms_ICCProfile
profile
;
memset
(
&
profile
0
sizeof
(
profile
)
)
;
std
:
:
vector
<
uint16_t
>
trc_table
;
std
:
:
vector
<
uint16_t
>
a2b_grid
;
profile
.
data_color_space
=
skcms_Signature_RGB
;
profile
.
pcs
=
skcms_Signature_XYZ
;
{
profile
.
has_toXYZD50
=
true
;
profile
.
toXYZD50
=
toXYZD50
;
}
if
(
skcms_TransferFunction_isSRGBish
(
&
fn
)
)
{
profile
.
has_trc
=
true
;
profile
.
trc
[
0
]
.
table_entries
=
0
;
profile
.
trc
[
0
]
.
parametric
=
fn
;
memcpy
(
&
profile
.
trc
[
1
]
&
profile
.
trc
[
0
]
sizeof
(
profile
.
trc
[
0
]
)
)
;
memcpy
(
&
profile
.
trc
[
2
]
&
profile
.
trc
[
0
]
sizeof
(
profile
.
trc
[
0
]
)
)
;
}
if
(
skcms_TransferFunction_isPQish
(
&
fn
)
|
|
skcms_TransferFunction_isHLGish
(
&
fn
)
)
{
constexpr
uint32_t
kTrcTableSize
=
65
;
trc_table
.
resize
(
kTrcTableSize
)
;
for
(
uint32_t
i
=
0
;
i
<
kTrcTableSize
;
+
+
i
)
{
float
x
=
i
/
(
kTrcTableSize
-
1
.
f
)
;
x
=
hdr_trfn_eval
(
fn
x
)
;
x
*
=
tone_map_gain
(
x
)
;
trc_table
[
i
]
=
SkEndian_SwapBE16
(
float_to_uInt16Number
(
x
kOne16CurveType
)
)
;
}
constexpr
uint32_t
kGridSize
=
11
;
a2b_grid
.
resize
(
kGridSize
*
kGridSize
*
kGridSize
*
kNumChannels
)
;
size_t
a2b_grid_index
=
0
;
for
(
uint32_t
r_index
=
0
;
r_index
<
kGridSize
;
+
+
r_index
)
{
for
(
uint32_t
g_index
=
0
;
g_index
<
kGridSize
;
+
+
g_index
)
{
for
(
uint32_t
b_index
=
0
;
b_index
<
kGridSize
;
+
+
b_index
)
{
float
rgb
[
3
]
=
{
r_index
/
(
kGridSize
-
1
.
f
)
g_index
/
(
kGridSize
-
1
.
f
)
b_index
/
(
kGridSize
-
1
.
f
)
}
;
for
(
auto
&
c
:
rgb
)
{
c
=
tone_map_inverse
(
c
)
;
}
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
)
{
for
(
auto
&
c
:
rgb
)
{
c
/
=
kToneMapInputMax
;
}
for
(
auto
&
c
:
rgb
)
{
c
=
std
:
:
pow
(
c
1
/
1
.
2
)
;
}
float
Y
=
0
.
2627f
*
rgb
[
0
]
+
0
.
6780f
*
rgb
[
1
]
+
0
.
0593f
*
rgb
[
2
]
;
for
(
auto
&
c
:
rgb
)
{
c
*
=
std
:
:
pow
(
Y
0
.
2
)
;
}
for
(
auto
&
c
:
rgb
)
{
c
*
=
kToneMapInputMax
;
}
}
{
float
max_rgb
=
std
:
:
max
(
std
:
:
max
(
rgb
[
0
]
rgb
[
1
]
)
rgb
[
2
]
)
;
for
(
auto
&
c
:
rgb
)
{
c
*
=
tone_map_gain
(
0
.
5
*
(
c
+
max_rgb
)
)
;
c
=
std
:
:
min
(
c
1
.
f
)
;
}
}
for
(
const
auto
&
c
:
rgb
)
{
a2b_grid
[
a2b_grid_index
+
+
]
=
SkEndian_SwapBE16
(
float_to_uInt16Number
(
c
kOne16XYZ
)
)
;
}
}
}
}
profile
.
has_A2B
=
true
;
profile
.
A2B
.
input_channels
=
kNumChannels
;
profile
.
A2B
.
output_channels
=
kNumChannels
;
profile
.
A2B
.
matrix_channels
=
kNumChannels
;
for
(
size_t
i
=
0
;
i
<
kNumChannels
;
+
+
i
)
{
profile
.
A2B
.
grid_points
[
i
]
=
kGridSize
;
profile
.
A2B
.
input_curves
[
i
]
.
table_entries
=
kTrcTableSize
;
profile
.
A2B
.
input_curves
[
i
]
.
table_16
=
reinterpret_cast
<
uint8_t
*
>
(
trc_table
.
data
(
)
)
;
profile
.
A2B
.
output_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
profile
.
A2B
.
matrix_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
for
(
size_t
j
=
0
;
j
<
3
;
+
+
j
)
{
profile
.
A2B
.
matrix
.
vals
[
i
]
[
j
]
=
toXYZD50
.
vals
[
i
]
[
j
]
;
}
profile
.
A2B
.
matrix
.
vals
[
i
]
[
3
]
=
0
.
f
;
}
profile
.
A2B
.
grid_16
=
reinterpret_cast
<
const
uint8_t
*
>
(
a2b_grid
.
data
(
)
)
;
profile
.
has_B2A
=
true
;
profile
.
B2A
.
input_channels
=
kNumChannels
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
profile
.
B2A
.
input_curves
[
i
]
.
parametric
=
SkNamedTransferFn
:
:
kLinear
;
}
}
if
(
skcms_TransferFunction_isHLGish
(
&
fn
)
|
|
skcms_TransferFunction_isPQish
(
&
fn
)
)
{
profile
.
has_CICP
=
true
;
profile
.
CICP
.
color_primaries
=
get_cicp_primaries
(
toXYZD50
)
;
profile
.
CICP
.
transfer_characteristics
=
get_cicp_trfn
(
fn
)
;
profile
.
CICP
.
matrix_coefficients
=
0
;
profile
.
CICP
.
video_full_range_flag
=
1
;
SkASSERT
(
profile
.
CICP
.
color_primaries
)
;
SkASSERT
(
profile
.
CICP
.
transfer_characteristics
)
;
}
std
:
:
string
description
=
get_desc_string
(
fn
toXYZD50
)
;
return
SkWriteICCProfile
(
&
profile
description
.
c_str
(
)
)
;
}
