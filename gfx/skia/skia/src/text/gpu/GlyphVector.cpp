#
include
"
src
/
text
/
gpu
/
GlyphVector
.
h
"
#
include
"
src
/
core
/
SkGlyph
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkStrike
.
h
"
#
include
"
src
/
core
/
SkStrikeCache
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
"
src
/
text
/
StrikeForGPU
.
h
"
#
include
<
optional
>
class
SkStrikeClient
;
using
MaskFormat
=
skgpu
:
:
MaskFormat
;
namespace
sktext
:
:
gpu
{
GlyphVector
:
:
GlyphVector
(
SkStrikePromise
&
&
strikePromise
SkSpan
<
Variant
>
glyphs
)
:
fStrikePromise
{
std
:
:
move
(
strikePromise
)
}
fGlyphs
{
glyphs
}
{
SkASSERT
(
fGlyphs
.
size
(
)
>
0
)
;
}
GlyphVector
GlyphVector
:
:
Make
(
SkStrikePromise
&
&
promise
SkSpan
<
const
SkPackedGlyphID
>
packedIDs
SubRunAllocator
*
alloc
)
{
SkASSERT
(
packedIDs
.
size
(
)
>
0
)
;
auto
packedIDToVariant
=
[
]
(
SkPackedGlyphID
packedID
)
{
return
Variant
{
packedID
}
;
}
;
return
GlyphVector
{
std
:
:
move
(
promise
)
alloc
-
>
makePODArray
<
Variant
>
(
packedIDs
packedIDToVariant
)
}
;
}
std
:
:
optional
<
GlyphVector
>
GlyphVector
:
:
MakeFromBuffer
(
SkReadBuffer
&
buffer
const
SkStrikeClient
*
client
SubRunAllocator
*
alloc
)
{
std
:
:
optional
<
SkStrikePromise
>
promise
=
SkStrikePromise
:
:
MakeFromBuffer
(
buffer
client
SkStrikeCache
:
:
GlobalStrikeCache
(
)
)
;
if
(
!
buffer
.
validate
(
promise
.
has_value
(
)
)
)
{
return
std
:
:
nullopt
;
}
int32_t
glyphCount
=
buffer
.
read32
(
)
;
if
(
!
buffer
.
validate
(
glyphCount
>
0
)
)
{
return
std
:
:
nullopt
;
}
static
constexpr
int
kMaxCount
=
(
int
)
(
INT_MAX
/
sizeof
(
uint32_t
)
)
;
if
(
!
buffer
.
validate
(
glyphCount
<
=
kMaxCount
)
)
{
return
std
:
:
nullopt
;
}
if
(
!
buffer
.
validate
(
glyphCount
*
sizeof
(
uint32_t
)
<
=
buffer
.
available
(
)
)
)
{
return
std
:
:
nullopt
;
}
Variant
*
variants
=
alloc
-
>
makePODArray
<
Variant
>
(
glyphCount
)
;
for
(
int
i
=
0
;
i
<
glyphCount
;
i
+
+
)
{
variants
[
i
]
.
packedGlyphID
=
SkPackedGlyphID
(
buffer
.
readUInt
(
)
)
;
}
return
GlyphVector
{
std
:
:
move
(
promise
.
value
(
)
)
SkSpan
(
variants
glyphCount
)
}
;
}
void
GlyphVector
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
SkASSERT
(
fGlyphs
.
size
(
)
!
=
0
)
;
fStrikePromise
.
flatten
(
buffer
)
;
buffer
.
write32
(
SkTo
<
int32_t
>
(
fGlyphs
.
size
(
)
)
)
;
for
(
Variant
variant
:
fGlyphs
)
{
buffer
.
writeUInt
(
variant
.
packedGlyphID
.
value
(
)
)
;
}
}
SkSpan
<
const
Glyph
*
>
GlyphVector
:
:
glyphs
(
)
const
{
return
SkSpan
(
reinterpret_cast
<
const
Glyph
*
*
>
(
fGlyphs
.
data
(
)
)
fGlyphs
.
size
(
)
)
;
}
void
GlyphVector
:
:
packedGlyphIDToGlyph
(
StrikeCache
*
cache
)
{
if
(
fTextStrike
=
=
nullptr
)
{
SkStrike
*
strike
=
fStrikePromise
.
strike
(
)
;
fTextStrike
=
cache
-
>
findOrCreateStrike
(
strike
-
>
strikeSpec
(
)
)
;
for
(
Variant
&
variant
:
fGlyphs
)
{
variant
.
glyph
=
fTextStrike
-
>
getGlyph
(
variant
.
packedGlyphID
)
;
}
strike
-
>
verifyPinnedStrike
(
)
;
fStrikePromise
.
resetStrike
(
)
;
}
}
}
