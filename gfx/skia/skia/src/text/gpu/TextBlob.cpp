#
include
"
src
/
text
/
gpu
/
TextBlob
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkCPUTypes
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkFontPriv
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
text
/
GlyphRun
.
h
"
#
include
"
src
/
text
/
gpu
/
SDFTControl
.
h
"
#
include
"
src
/
text
/
gpu
/
SlugImpl
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunAllocator
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunContainer
.
h
"
#
include
<
memory
>
#
include
<
utility
>
class
SkMaskFilter
;
using
namespace
sktext
:
:
gpu
;
namespace
{
std
:
:
tuple
<
bool
SkVector
>
can_use_direct
(
const
SkMatrix
&
initialPositionMatrix
const
SkMatrix
&
positionMatrix
)
{
SkVector
translation
=
positionMatrix
.
mapOrigin
(
)
-
initialPositionMatrix
.
mapOrigin
(
)
;
return
{
initialPositionMatrix
.
getScaleX
(
)
=
=
positionMatrix
.
getScaleX
(
)
&
&
initialPositionMatrix
.
getScaleY
(
)
=
=
positionMatrix
.
getScaleY
(
)
&
&
initialPositionMatrix
.
getSkewX
(
)
=
=
positionMatrix
.
getSkewX
(
)
&
&
initialPositionMatrix
.
getSkewY
(
)
=
=
positionMatrix
.
getSkewY
(
)
&
&
SkScalarIsInt
(
translation
.
x
(
)
)
&
&
SkScalarIsInt
(
translation
.
y
(
)
)
translation
}
;
}
static
SkColor
compute_canonical_color
(
const
SkPaint
&
paint
bool
lcd
)
{
SkColor
canonicalColor
=
SkPaintPriv
:
:
ComputeLuminanceColor
(
paint
)
;
if
(
lcd
)
{
return
SK_ColorTRANSPARENT
;
}
else
{
U8CPU
lum
=
SkComputeLuminance
(
SkColorGetR
(
canonicalColor
)
SkColorGetG
(
canonicalColor
)
SkColorGetB
(
canonicalColor
)
)
;
canonicalColor
=
SkMaskGamma
:
:
CanonicalColor
(
SkColorSetRGB
(
lum
lum
lum
)
)
;
}
return
canonicalColor
;
}
}
namespace
sktext
:
:
gpu
{
auto
TextBlob
:
:
Key
:
:
Make
(
const
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
const
SkMatrix
&
drawMatrix
const
SkStrikeDeviceInfo
&
strikeDevice
)
-
>
std
:
:
tuple
<
bool
Key
>
{
SkASSERT
(
strikeDevice
.
fSDFTControl
!
=
nullptr
)
;
SkMaskFilterBase
:
:
BlurRec
blurRec
;
const
SkMaskFilter
*
maskFilter
=
paint
.
getMaskFilter
(
)
;
bool
canCache
=
glyphRunList
.
canCache
(
)
&
&
!
(
paint
.
getPathEffect
(
)
|
|
(
maskFilter
&
&
!
as_MFB
(
maskFilter
)
-
>
asABlur
(
&
blurRec
)
)
)
;
TextBlob
:
:
Key
key
;
if
(
canCache
)
{
bool
hasLCD
=
glyphRunList
.
anyRunsLCD
(
)
;
SkPixelGeometry
pixelGeometry
=
hasLCD
?
strikeDevice
.
fSurfaceProps
.
pixelGeometry
(
)
:
kUnknown_SkPixelGeometry
;
SkColor
canonicalColor
=
compute_canonical_color
(
paint
hasLCD
)
;
key
.
fPixelGeometry
=
pixelGeometry
;
key
.
fUniqueID
=
glyphRunList
.
uniqueID
(
)
;
key
.
fStyle
=
paint
.
getStyle
(
)
;
if
(
key
.
fStyle
!
=
SkPaint
:
:
kFill_Style
)
{
key
.
fFrameWidth
=
paint
.
getStrokeWidth
(
)
;
key
.
fMiterLimit
=
paint
.
getStrokeMiter
(
)
;
key
.
fJoin
=
paint
.
getStrokeJoin
(
)
;
}
key
.
fHasBlur
=
maskFilter
!
=
nullptr
;
if
(
key
.
fHasBlur
)
{
key
.
fBlurRec
=
blurRec
;
}
key
.
fCanonicalColor
=
canonicalColor
;
key
.
fScalerContextFlags
=
SkTo
<
uint32_t
>
(
strikeDevice
.
fScalerContextFlags
)
;
key
.
fHasSomeDirectSubRuns
=
false
;
SkPoint
glyphRunListLocation
=
glyphRunList
.
sourceBoundsWithOrigin
(
)
.
center
(
)
;
for
(
auto
&
run
:
glyphRunList
)
{
SkScalar
approximateDeviceTextSize
=
SkFontPriv
:
:
ApproximateTransformedTextSize
(
run
.
font
(
)
drawMatrix
glyphRunListLocation
)
;
key
.
fHasSomeDirectSubRuns
|
=
strikeDevice
.
fSDFTControl
-
>
isDirect
(
approximateDeviceTextSize
paint
drawMatrix
)
;
}
if
(
key
.
fHasSomeDirectSubRuns
)
{
SkPoint
mappedOrigin
=
drawMatrix
.
mapOrigin
(
)
;
key
.
fPositionMatrix
=
drawMatrix
;
key
.
fPositionMatrix
.
setTranslateX
(
mappedOrigin
.
x
(
)
-
SkScalarFloorToScalar
(
mappedOrigin
.
x
(
)
)
)
;
key
.
fPositionMatrix
.
setTranslateY
(
mappedOrigin
.
y
(
)
-
SkScalarFloorToScalar
(
mappedOrigin
.
y
(
)
)
)
;
}
else
{
key
.
fPositionMatrix
=
SkMatrix
:
:
I
(
)
;
}
}
return
{
canCache
key
}
;
}
bool
TextBlob
:
:
Key
:
:
operator
=
=
(
const
TextBlob
:
:
Key
&
that
)
const
{
if
(
fUniqueID
!
=
that
.
fUniqueID
)
{
return
false
;
}
if
(
fCanonicalColor
!
=
that
.
fCanonicalColor
)
{
return
false
;
}
if
(
fStyle
!
=
that
.
fStyle
)
{
return
false
;
}
if
(
fStyle
!
=
SkPaint
:
:
kFill_Style
)
{
if
(
fFrameWidth
!
=
that
.
fFrameWidth
|
|
fMiterLimit
!
=
that
.
fMiterLimit
|
|
fJoin
!
=
that
.
fJoin
)
{
return
false
;
}
}
if
(
fPixelGeometry
!
=
that
.
fPixelGeometry
)
{
return
false
;
}
if
(
fHasBlur
!
=
that
.
fHasBlur
)
{
return
false
;
}
if
(
fHasBlur
)
{
if
(
fBlurRec
.
fStyle
!
=
that
.
fBlurRec
.
fStyle
|
|
fBlurRec
.
fSigma
!
=
that
.
fBlurRec
.
fSigma
)
{
return
false
;
}
}
if
(
fScalerContextFlags
!
=
that
.
fScalerContextFlags
)
{
return
false
;
}
if
(
fPositionMatrix
.
hasPerspective
(
)
&
&
fHasSomeDirectSubRuns
)
{
return
false
;
}
if
(
fHasSomeDirectSubRuns
!
=
that
.
fHasSomeDirectSubRuns
)
{
return
false
;
}
if
(
fHasSomeDirectSubRuns
)
{
auto
[
compatible
_
]
=
can_use_direct
(
fPositionMatrix
that
.
fPositionMatrix
)
;
return
compatible
;
}
return
true
;
}
void
TextBlob
:
:
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
void
*
TextBlob
:
:
operator
new
(
size_t
)
{
SK_ABORT
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
}
void
*
TextBlob
:
:
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
TextBlob
:
:
~
TextBlob
(
)
=
default
;
sk_sp
<
TextBlob
>
TextBlob
:
:
Make
(
const
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
const
SkMatrix
&
positionMatrix
SkStrikeDeviceInfo
strikeDeviceInfo
StrikeForGPUCacheInterface
*
strikeCache
)
{
size_t
subRunSizeHint
=
SubRunContainer
:
:
EstimateAllocSize
(
glyphRunList
)
;
auto
[
initializer
totalMemoryAllocated
alloc
]
=
SubRunAllocator
:
:
AllocateClassMemoryAndArena
<
TextBlob
>
(
subRunSizeHint
)
;
auto
container
=
SubRunContainer
:
:
MakeInAlloc
(
glyphRunList
positionMatrix
paint
strikeDeviceInfo
strikeCache
&
alloc
SubRunContainer
:
:
kAddSubRuns
"
TextBlob
"
)
;
SkColor
initialLuminance
=
SkPaintPriv
:
:
ComputeLuminanceColor
(
paint
)
;
sk_sp
<
TextBlob
>
blob
=
sk_sp
<
TextBlob
>
(
initializer
.
initialize
(
std
:
:
move
(
alloc
)
std
:
:
move
(
container
)
totalMemoryAllocated
initialLuminance
)
)
;
return
blob
;
}
void
TextBlob
:
:
addKey
(
const
Key
&
key
)
{
fKey
=
key
;
}
bool
TextBlob
:
:
canReuse
(
const
SkPaint
&
paint
const
SkMatrix
&
positionMatrix
)
const
{
if
(
fSubRuns
-
>
isEmpty
(
)
&
&
fSubRuns
-
>
initialPosition
(
)
!
=
positionMatrix
)
{
return
false
;
}
if
(
fKey
.
fCanonicalColor
=
=
SK_ColorTRANSPARENT
&
&
fInitialLuminance
!
=
SkPaintPriv
:
:
ComputeLuminanceColor
(
paint
)
)
{
return
false
;
}
return
fSubRuns
-
>
canReuse
(
paint
positionMatrix
)
;
}
const
TextBlob
:
:
Key
&
TextBlob
:
:
key
(
)
const
{
return
fKey
;
}
void
TextBlob
:
:
draw
(
SkCanvas
*
canvas
SkPoint
drawOrigin
const
SkPaint
&
paint
const
AtlasDrawDelegate
&
atlasDelegate
)
{
fSubRuns
-
>
draw
(
canvas
drawOrigin
paint
this
atlasDelegate
)
;
}
TextBlob
:
:
TextBlob
(
SubRunAllocator
&
&
alloc
SubRunContainerOwner
subRuns
int
totalMemorySize
SkColor
initialLuminance
)
:
fAlloc
{
std
:
:
move
(
alloc
)
}
fSubRuns
{
std
:
:
move
(
subRuns
)
}
fSize
(
totalMemorySize
)
fInitialLuminance
{
initialLuminance
}
{
}
sk_sp
<
Slug
>
MakeSlug
(
const
SkMatrix
&
drawMatrix
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
SkStrikeDeviceInfo
strikeDeviceInfo
sktext
:
:
StrikeForGPUCacheInterface
*
strikeCache
)
{
return
SlugImpl
:
:
Make
(
drawMatrix
glyphRunList
paint
strikeDeviceInfo
strikeCache
)
;
}
}
