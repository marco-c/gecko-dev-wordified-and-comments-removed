#
include
"
src
/
text
/
gpu
/
VertexFiller
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunAllocator
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunContainer
.
h
"
#
include
<
optional
>
using
MaskFormat
=
skgpu
:
:
MaskFormat
;
namespace
sktext
:
:
gpu
{
VertexFiller
:
:
VertexFiller
(
MaskFormat
maskFormat
const
SkMatrix
&
creationMatrix
SkRect
creationBounds
SkSpan
<
const
SkPoint
>
leftTop
bool
canDrawDirect
)
:
fMaskType
{
maskFormat
}
fCanDrawDirect
{
canDrawDirect
}
fCreationMatrix
{
creationMatrix
}
fCreationBounds
{
creationBounds
}
fLeftTop
{
leftTop
}
{
}
VertexFiller
VertexFiller
:
:
Make
(
MaskFormat
maskType
const
SkMatrix
&
creationMatrix
SkRect
creationBounds
SkSpan
<
const
SkPoint
>
positions
SubRunAllocator
*
alloc
FillerType
fillerType
)
{
SkSpan
<
SkPoint
>
leftTop
=
alloc
-
>
makePODSpan
<
SkPoint
>
(
positions
)
;
return
VertexFiller
{
maskType
creationMatrix
creationBounds
leftTop
fillerType
=
=
kIsDirect
}
;
}
std
:
:
optional
<
VertexFiller
>
VertexFiller
:
:
MakeFromBuffer
(
SkReadBuffer
&
buffer
SubRunAllocator
*
alloc
)
{
int
checkingMaskType
=
buffer
.
readInt
(
)
;
if
(
!
buffer
.
validate
(
0
<
=
checkingMaskType
&
&
checkingMaskType
<
skgpu
:
:
kMaskFormatCount
)
)
{
return
std
:
:
nullopt
;
}
MaskFormat
maskType
=
(
MaskFormat
)
checkingMaskType
;
const
bool
canDrawDirect
=
buffer
.
readBool
(
)
;
SkMatrix
creationMatrix
;
buffer
.
readMatrix
(
&
creationMatrix
)
;
SkRect
creationBounds
=
buffer
.
readRect
(
)
;
SkSpan
<
SkPoint
>
leftTop
=
MakePointsFromBuffer
(
buffer
alloc
)
;
if
(
leftTop
.
empty
(
)
)
{
return
std
:
:
nullopt
;
}
SkASSERT
(
buffer
.
isValid
(
)
)
;
return
VertexFiller
{
maskType
creationMatrix
creationBounds
leftTop
canDrawDirect
}
;
}
void
VertexFiller
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeInt
(
static_cast
<
int
>
(
fMaskType
)
)
;
buffer
.
writeBool
(
fCanDrawDirect
)
;
buffer
.
writeMatrix
(
fCreationMatrix
)
;
buffer
.
writeRect
(
fCreationBounds
)
;
buffer
.
writePointArray
(
fLeftTop
)
;
}
SkMatrix
VertexFiller
:
:
viewDifference
(
const
SkMatrix
&
positionMatrix
)
const
{
if
(
SkMatrix
inverse
;
fCreationMatrix
.
invert
(
&
inverse
)
)
{
return
SkMatrix
:
:
Concat
(
positionMatrix
inverse
)
;
}
return
SkMatrix
:
:
I
(
)
;
}
std
:
:
tuple
<
bool
SkVector
>
VertexFiller
:
:
CanUseDirect
(
const
SkMatrix
&
creationMatrix
const
SkMatrix
&
positionMatrix
)
{
SkVector
translation
=
positionMatrix
.
mapOrigin
(
)
-
creationMatrix
.
mapOrigin
(
)
;
return
{
creationMatrix
.
getScaleX
(
)
=
=
positionMatrix
.
getScaleX
(
)
&
&
creationMatrix
.
getScaleY
(
)
=
=
positionMatrix
.
getScaleY
(
)
&
&
creationMatrix
.
getSkewX
(
)
=
=
positionMatrix
.
getSkewX
(
)
&
&
creationMatrix
.
getSkewY
(
)
=
=
positionMatrix
.
getSkewY
(
)
&
&
!
positionMatrix
.
hasPerspective
(
)
&
&
!
creationMatrix
.
hasPerspective
(
)
&
&
SkScalarIsInt
(
translation
.
x
(
)
)
&
&
SkScalarIsInt
(
translation
.
y
(
)
)
translation
}
;
}
bool
VertexFiller
:
:
isLCD
(
)
const
{
return
fMaskType
=
=
MaskFormat
:
:
kA565
;
}
std
:
:
tuple
<
bool
SkRect
>
VertexFiller
:
:
deviceRectAndCheckTransform
(
const
SkMatrix
&
positionMatrix
)
const
{
if
(
fCanDrawDirect
)
{
const
auto
[
directDrawCompatible
offset
]
=
CanUseDirect
(
fCreationMatrix
positionMatrix
)
;
if
(
directDrawCompatible
)
{
return
{
true
fCreationBounds
.
makeOffset
(
offset
)
}
;
}
}
if
(
SkMatrix
inverse
;
fCreationMatrix
.
invert
(
&
inverse
)
)
{
SkMatrix
viewDifference
=
SkMatrix
:
:
Concat
(
positionMatrix
inverse
)
;
return
{
false
viewDifference
.
mapRect
(
fCreationBounds
)
}
;
}
return
{
false
SkRect
:
:
MakeEmpty
(
)
}
;
}
}
