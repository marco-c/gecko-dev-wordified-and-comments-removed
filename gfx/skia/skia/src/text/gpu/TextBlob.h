#
ifndef
sktext_gpu_TextBlob_DEFINED
#
define
sktext_gpu_TextBlob_DEFINED
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
chromium
/
Slug
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunContainer
.
h
"
class
SkMatrixProvider
;
class
SkStrikeClient
;
class
SkSurfaceProps
;
class
SkTextBlob
;
class
SkTextBlobRunIterator
;
namespace
sktext
{
class
GlyphRunList
;
namespace
gpu
{
class
Glyph
;
class
StrikeCache
;
}
}
#
if
defined
(
SK_GANESH
)
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrOp
.
h
"
class
GrAtlasManager
;
class
GrDeferredUploadTarget
;
class
GrMeshDrawTarget
;
namespace
skgpu
:
:
ganesh
{
class
SurfaceDrawContext
;
}
#
endif
namespace
sktext
:
:
gpu
{
class
TextBlob
final
:
public
SkRefCnt
{
public
:
struct
Key
{
static
std
:
:
tuple
<
bool
Key
>
Make
(
const
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
const
SkMatrix
&
drawMatrix
const
SkStrikeDeviceInfo
&
strikeDevice
)
;
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPixelGeometry
fPixelGeometry
;
SkMaskFilterBase
:
:
BlurRec
fBlurRec
;
uint32_t
fScalerContextFlags
;
SkMatrix
fPositionMatrix
;
bool
fHasSomeDirectSubRuns
;
bool
fHasBlur
;
SkPaint
:
:
Style
fStyle
;
SkPaint
:
:
Join
fJoin
;
bool
operator
=
=
(
const
Key
&
other
)
const
;
}
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
TextBlob
)
;
static
sk_sp
<
TextBlob
>
Make
(
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
paint
const
SkMatrix
&
positionMatrix
SkStrikeDeviceInfo
strikeDeviceInfo
StrikeForGPUCacheInterface
*
strikeCache
)
;
TextBlob
(
SubRunAllocator
&
&
alloc
SubRunContainerOwner
subRuns
int
totalMemorySize
SkColor
initialLuminance
)
;
~
TextBlob
(
)
override
;
void
operator
delete
(
void
*
p
)
;
void
*
operator
new
(
size_t
)
;
void
*
operator
new
(
size_t
void
*
p
)
;
const
Key
&
key
(
)
{
return
fKey
;
}
void
addKey
(
const
Key
&
key
)
;
bool
canReuse
(
const
SkPaint
&
paint
const
SkMatrix
&
positionMatrix
)
const
;
const
Key
&
key
(
)
const
;
size_t
size
(
)
const
{
return
SkTo
<
size_t
>
(
fSize
)
;
}
#
if
defined
(
SK_GANESH
)
void
draw
(
SkCanvas
*
const
GrClip
*
clip
const
SkMatrixProvider
&
viewMatrix
SkPoint
drawOrigin
const
SkPaint
&
paint
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
)
;
#
endif
#
if
defined
(
SK_GRAPHITE
)
void
draw
(
SkCanvas
*
SkPoint
drawOrigin
const
SkPaint
&
paint
skgpu
:
:
graphite
:
:
Device
*
device
)
;
#
endif
const
AtlasSubRun
*
testingOnlyFirstSubRun
(
)
const
;
private
:
SubRunAllocator
fAlloc
;
SubRunContainerOwner
fSubRuns
;
const
int
fSize
;
const
SkColor
fInitialLuminance
;
Key
fKey
;
}
;
}
namespace
skgpu
:
:
ganesh
{
sk_sp
<
sktext
:
:
gpu
:
:
Slug
>
MakeSlug
(
const
SkMatrixProvider
&
drawMatrix
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
SkStrikeDeviceInfo
strikeDeviceInfo
sktext
:
:
StrikeForGPUCacheInterface
*
strikeCache
)
;
}
#
endif
