#
include
"
SkJumper
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkRasterPipeline
.
h
"
#
include
"
SkTemplates
.
h
"
SkRasterPipeline
:
:
StartPipelineFn
SkRasterPipeline
:
:
build_pipeline
(
void
*
*
ip
)
const
{
#
ifndef
SK_JUMPER_DISABLE_8BIT
void
*
*
reset_point
=
ip
;
*
-
-
ip
=
(
void
*
)
SkOpts
:
:
just_return_lowp
;
for
(
const
StageList
*
st
=
fStages
;
st
;
st
=
st
-
>
prev
)
{
SkOpts
:
:
StageFn
fn
;
if
(
!
st
-
>
rawFunction
&
&
(
fn
=
SkOpts
:
:
stages_lowp
[
st
-
>
stage
]
)
)
{
if
(
st
-
>
ctx
)
{
*
-
-
ip
=
st
-
>
ctx
;
}
*
-
-
ip
=
(
void
*
)
fn
;
}
else
{
ip
=
reset_point
;
break
;
}
}
if
(
ip
!
=
reset_point
)
{
return
SkOpts
:
:
start_pipeline_lowp
;
}
#
endif
*
-
-
ip
=
(
void
*
)
SkOpts
:
:
just_return_highp
;
for
(
const
StageList
*
st
=
fStages
;
st
;
st
=
st
-
>
prev
)
{
if
(
st
-
>
ctx
)
{
*
-
-
ip
=
st
-
>
ctx
;
}
if
(
st
-
>
rawFunction
)
{
*
-
-
ip
=
(
void
*
)
st
-
>
stage
;
}
else
{
*
-
-
ip
=
(
void
*
)
SkOpts
:
:
stages_highp
[
st
-
>
stage
]
;
}
}
return
SkOpts
:
:
start_pipeline_highp
;
}
void
SkRasterPipeline
:
:
run
(
size_t
x
size_t
y
size_t
w
size_t
h
)
const
{
if
(
this
-
>
empty
(
)
)
{
return
;
}
SkAutoSTMalloc
<
64
void
*
>
program
(
fSlotsNeeded
)
;
auto
start_pipeline
=
this
-
>
build_pipeline
(
program
.
get
(
)
+
fSlotsNeeded
)
;
start_pipeline
(
x
y
x
+
w
y
+
h
program
.
get
(
)
)
;
}
std
:
:
function
<
void
(
size_t
size_t
size_t
size_t
)
>
SkRasterPipeline
:
:
compile
(
)
const
{
if
(
this
-
>
empty
(
)
)
{
return
[
]
(
size_t
size_t
size_t
size_t
)
{
}
;
}
void
*
*
program
=
fAlloc
-
>
makeArray
<
void
*
>
(
fSlotsNeeded
)
;
auto
start_pipeline
=
this
-
>
build_pipeline
(
program
+
fSlotsNeeded
)
;
return
[
=
]
(
size_t
x
size_t
y
size_t
w
size_t
h
)
{
start_pipeline
(
x
y
x
+
w
y
+
h
program
)
;
}
;
}
