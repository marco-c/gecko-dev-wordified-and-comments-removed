#
include
"
SkDiscardableMemoryPool
.
h
"
#
include
"
SkDiscardableMemory
.
h
"
#
include
"
SkMakeUnique
.
h
"
#
include
"
SkMalloc
.
h
"
#
include
"
SkMutex
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
SkTemplates
.
h
"
namespace
{
class
PoolDiscardableMemory
;
class
DiscardableMemoryPool
:
public
SkDiscardableMemoryPool
{
public
:
DiscardableMemoryPool
(
size_t
budget
)
;
~
DiscardableMemoryPool
(
)
override
;
std
:
:
unique_ptr
<
SkDiscardableMemory
>
make
(
size_t
bytes
)
;
SkDiscardableMemory
*
create
(
size_t
bytes
)
override
{
return
this
-
>
make
(
bytes
)
.
release
(
)
;
}
size_t
getRAMUsed
(
)
override
;
void
setRAMBudget
(
size_t
budget
)
override
;
size_t
getRAMBudget
(
)
override
{
return
fBudget
;
}
void
dumpPool
(
)
override
;
#
if
SK_LAZY_CACHE_STATS
int
getCacheHits
(
)
override
{
return
fCacheHits
;
}
int
getCacheMisses
(
)
override
{
return
fCacheMisses
;
}
void
resetCacheHitsAndMisses
(
)
override
{
fCacheHits
=
fCacheMisses
=
0
;
}
int
fCacheHits
;
int
fCacheMisses
;
#
endif
private
:
SkMutex
fMutex
;
size_t
fBudget
;
size_t
fUsed
;
SkTInternalLList
<
PoolDiscardableMemory
>
fList
;
void
dumpDownTo
(
size_t
budget
)
;
void
removeFromPool
(
PoolDiscardableMemory
*
dm
)
;
bool
lock
(
PoolDiscardableMemory
*
dm
)
;
void
unlock
(
PoolDiscardableMemory
*
dm
)
;
friend
class
PoolDiscardableMemory
;
typedef
SkDiscardableMemory
:
:
Factory
INHERITED
;
}
;
class
PoolDiscardableMemory
:
public
SkDiscardableMemory
{
public
:
PoolDiscardableMemory
(
sk_sp
<
DiscardableMemoryPool
>
pool
SkAutoFree
pointer
size_t
bytes
)
;
~
PoolDiscardableMemory
(
)
override
;
bool
lock
(
)
override
;
void
*
data
(
)
override
;
void
unlock
(
)
override
;
friend
class
DiscardableMemoryPool
;
private
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
PoolDiscardableMemory
)
;
sk_sp
<
DiscardableMemoryPool
>
fPool
;
bool
fLocked
;
SkAutoFree
fPointer
;
const
size_t
fBytes
;
}
;
PoolDiscardableMemory
:
:
PoolDiscardableMemory
(
sk_sp
<
DiscardableMemoryPool
>
pool
SkAutoFree
pointer
size_t
bytes
)
:
fPool
(
std
:
:
move
(
pool
)
)
fLocked
(
true
)
fPointer
(
std
:
:
move
(
pointer
)
)
fBytes
(
bytes
)
{
SkASSERT
(
fPool
!
=
nullptr
)
;
SkASSERT
(
fPointer
!
=
nullptr
)
;
SkASSERT
(
fBytes
>
0
)
;
}
PoolDiscardableMemory
:
:
~
PoolDiscardableMemory
(
)
{
SkASSERT
(
!
fLocked
)
;
fPool
-
>
removeFromPool
(
this
)
;
}
bool
PoolDiscardableMemory
:
:
lock
(
)
{
SkASSERT
(
!
fLocked
)
;
return
fPool
-
>
lock
(
this
)
;
}
void
*
PoolDiscardableMemory
:
:
data
(
)
{
SkASSERT
(
fLocked
)
;
return
fPointer
.
get
(
)
;
}
void
PoolDiscardableMemory
:
:
unlock
(
)
{
SkASSERT
(
fLocked
)
;
fPool
-
>
unlock
(
this
)
;
}
DiscardableMemoryPool
:
:
DiscardableMemoryPool
(
size_t
budget
)
:
fBudget
(
budget
)
fUsed
(
0
)
{
#
if
SK_LAZY_CACHE_STATS
fCacheHits
=
0
;
fCacheMisses
=
0
;
#
endif
}
DiscardableMemoryPool
:
:
~
DiscardableMemoryPool
(
)
{
SkASSERT
(
fList
.
isEmpty
(
)
)
;
}
void
DiscardableMemoryPool
:
:
dumpDownTo
(
size_t
budget
)
{
fMutex
.
assertHeld
(
)
;
if
(
fUsed
<
=
budget
)
{
return
;
}
using
Iter
=
SkTInternalLList
<
PoolDiscardableMemory
>
:
:
Iter
;
Iter
iter
;
PoolDiscardableMemory
*
cur
=
iter
.
init
(
fList
Iter
:
:
kTail_IterStart
)
;
while
(
(
fUsed
>
budget
)
&
&
(
cur
)
)
{
if
(
!
cur
-
>
fLocked
)
{
PoolDiscardableMemory
*
dm
=
cur
;
SkASSERT
(
dm
-
>
fPointer
!
=
nullptr
)
;
dm
-
>
fPointer
=
nullptr
;
SkASSERT
(
fUsed
>
=
dm
-
>
fBytes
)
;
fUsed
-
=
dm
-
>
fBytes
;
cur
=
iter
.
prev
(
)
;
fList
.
remove
(
dm
)
;
}
else
{
cur
=
iter
.
prev
(
)
;
}
}
}
std
:
:
unique_ptr
<
SkDiscardableMemory
>
DiscardableMemoryPool
:
:
make
(
size_t
bytes
)
{
SkAutoFree
addr
(
sk_malloc_canfail
(
bytes
)
)
;
if
(
nullptr
=
=
addr
)
{
return
nullptr
;
}
auto
dm
=
skstd
:
:
make_unique
<
PoolDiscardableMemory
>
(
sk_ref_sp
(
this
)
std
:
:
move
(
addr
)
bytes
)
;
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
fList
.
addToHead
(
dm
.
get
(
)
)
;
fUsed
+
=
bytes
;
this
-
>
dumpDownTo
(
fBudget
)
;
return
std
:
:
move
(
dm
)
;
}
void
DiscardableMemoryPool
:
:
removeFromPool
(
PoolDiscardableMemory
*
dm
)
{
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
if
(
dm
-
>
fPointer
!
=
nullptr
)
{
SkASSERT
(
fUsed
>
=
dm
-
>
fBytes
)
;
fUsed
-
=
dm
-
>
fBytes
;
fList
.
remove
(
dm
)
;
}
else
{
SkASSERT
(
!
fList
.
isInList
(
dm
)
)
;
}
}
bool
DiscardableMemoryPool
:
:
lock
(
PoolDiscardableMemory
*
dm
)
{
SkASSERT
(
dm
!
=
nullptr
)
;
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
if
(
nullptr
=
=
dm
-
>
fPointer
)
{
#
if
SK_LAZY_CACHE_STATS
+
+
fCacheMisses
;
#
endif
return
false
;
}
dm
-
>
fLocked
=
true
;
fList
.
remove
(
dm
)
;
fList
.
addToHead
(
dm
)
;
#
if
SK_LAZY_CACHE_STATS
+
+
fCacheHits
;
#
endif
return
true
;
}
void
DiscardableMemoryPool
:
:
unlock
(
PoolDiscardableMemory
*
dm
)
{
SkASSERT
(
dm
!
=
nullptr
)
;
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
dm
-
>
fLocked
=
false
;
this
-
>
dumpDownTo
(
fBudget
)
;
}
size_t
DiscardableMemoryPool
:
:
getRAMUsed
(
)
{
return
fUsed
;
}
void
DiscardableMemoryPool
:
:
setRAMBudget
(
size_t
budget
)
{
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
fBudget
=
budget
;
this
-
>
dumpDownTo
(
fBudget
)
;
}
void
DiscardableMemoryPool
:
:
dumpPool
(
)
{
SkAutoMutexAcquire
autoMutexAcquire
(
fMutex
)
;
this
-
>
dumpDownTo
(
0
)
;
}
}
sk_sp
<
SkDiscardableMemoryPool
>
SkDiscardableMemoryPool
:
:
Make
(
size_t
size
)
{
return
sk_make_sp
<
DiscardableMemoryPool
>
(
size
)
;
}
SkDiscardableMemoryPool
*
SkGetGlobalDiscardableMemoryPool
(
)
{
static
SkDiscardableMemoryPool
*
global
=
new
DiscardableMemoryPool
(
SK_DEFAULT_GLOBAL_DISCARDABLE_MEMORY_POOL_SIZE
)
;
return
global
;
}
