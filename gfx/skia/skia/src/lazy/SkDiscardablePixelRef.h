#
ifndef
SkDiscardablePixelRef_DEFINED
#
define
SkDiscardablePixelRef_DEFINED
#
include
"
SkDiscardableMemory
.
h
"
#
include
"
SkImageGeneratorPriv
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkPixelRef
.
h
"
class
SkDiscardablePixelRef
:
public
SkPixelRef
{
public
:
SkDiscardableMemory
*
diagnostic_only_getDiscardable
(
)
const
override
{
return
fDiscardableMemory
;
}
protected
:
~
SkDiscardablePixelRef
(
)
;
bool
onNewLockPixels
(
LockRec
*
)
override
;
void
onUnlockPixels
(
)
override
;
bool
onLockPixelsAreWritable
(
)
const
override
{
return
false
;
}
SkData
*
onRefEncodedData
(
)
override
{
return
fGenerator
-
>
refEncodedData
(
)
;
}
bool
onIsLazyGenerated
(
)
const
override
{
return
true
;
}
private
:
SkImageGenerator
*
const
fGenerator
;
SkDiscardableMemory
:
:
Factory
*
const
fDMFactory
;
const
size_t
fRowBytes
;
SkDiscardableMemory
*
fDiscardableMemory
;
bool
fDiscardableMemoryIsLocked
;
SkAutoTUnref
<
SkColorTable
>
fCTable
;
SkDiscardablePixelRef
(
const
SkImageInfo
&
SkImageGenerator
*
size_t
rowBytes
SkDiscardableMemory
:
:
Factory
*
factory
)
;
bool
onQueryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
override
{
if
(
fDiscardableMemory
)
{
return
false
;
}
return
fGenerator
-
>
queryYUV8
(
sizeInfo
colorSpace
)
;
}
bool
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
override
{
if
(
fDiscardableMemory
)
{
return
false
;
}
return
fGenerator
-
>
getYUV8Planes
(
sizeInfo
planes
)
;
}
friend
bool
SkDEPRECATED_InstallDiscardablePixelRef
(
SkImageGenerator
*
const
SkIRect
*
SkBitmap
*
SkDiscardableMemory
:
:
Factory
*
)
;
typedef
SkPixelRef
INHERITED
;
}
;
#
endif
