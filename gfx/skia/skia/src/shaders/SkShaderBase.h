#
ifndef
SkShaderBase_DEFINED
#
define
SkShaderBase_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
src
/
base
/
SkTLazy
.
h
"
#
include
"
src
/
core
/
SkEffectPriv
.
h
"
#
include
"
src
/
core
/
SkMask
.
h
"
#
include
"
src
/
core
/
SkVM_fwd
.
h
"
#
include
<
tuple
>
class
GrFragmentProcessor
;
struct
GrFPArgs
;
class
SkArenaAlloc
;
class
SkColorSpace
;
class
SkImage
;
struct
SkImageInfo
;
class
SkPaint
;
class
SkRasterPipeline
;
class
SkRuntimeEffect
;
class
SkStageUpdater
;
class
SkUpdatableShader
;
namespace
skgpu
:
:
graphite
{
class
KeyContext
;
class
PaintParamsKeyBuilder
;
class
PipelineDataGatherer
;
}
#
if
defined
(
SK_GANESH
)
using
GrFPResult
=
std
:
:
tuple
<
bool
std
:
:
unique_ptr
<
GrFragmentProcessor
>
>
;
#
endif
class
SkShaderBase
:
public
SkShader
{
public
:
~
SkShaderBase
(
)
override
;
sk_sp
<
SkShader
>
makeInvertAlpha
(
)
const
;
sk_sp
<
SkShader
>
makeWithCTM
(
const
SkMatrix
&
)
const
;
virtual
bool
isConstant
(
)
const
{
return
false
;
}
enum
class
GradientType
{
kNone
kColor
kLinear
kRadial
kSweep
kConical
}
;
struct
GradientInfo
{
int
fColorCount
=
0
;
SkColor
*
fColors
=
nullptr
;
SkScalar
*
fColorOffsets
=
nullptr
;
SkPoint
fPoint
[
2
]
;
SkScalar
fRadius
[
2
]
;
SkTileMode
fTileMode
;
uint32_t
fGradientFlags
=
0
;
}
;
virtual
GradientType
asGradient
(
GradientInfo
*
info
=
nullptr
SkMatrix
*
localMatrix
=
nullptr
)
const
{
return
GradientType
:
:
kNone
;
}
enum
Flags
{
kOpaqueAlpha_Flag
=
1
<
<
0
kConstInY32_Flag
=
1
<
<
1
kPrefers4f_Flag
=
1
<
<
2
}
;
struct
ContextRec
{
ContextRec
(
const
SkColor4f
&
paintColor
const
SkMatrix
&
matrix
const
SkMatrix
*
localM
SkColorType
dstColorType
SkColorSpace
*
dstColorSpace
SkSurfaceProps
props
)
:
fMatrix
(
&
matrix
)
fLocalMatrix
(
localM
)
fDstColorType
(
dstColorType
)
fDstColorSpace
(
dstColorSpace
)
fProps
(
props
)
{
fPaintAlpha
=
SkColorGetA
(
paintColor
.
toSkColor
(
)
)
;
}
const
SkMatrix
*
fMatrix
;
const
SkMatrix
*
fLocalMatrix
;
SkColorType
fDstColorType
;
SkColorSpace
*
fDstColorSpace
;
SkSurfaceProps
fProps
;
SkAlpha
fPaintAlpha
;
bool
isLegacyCompatible
(
SkColorSpace
*
shadersColorSpace
)
const
;
}
;
class
Context
:
public
:
:
SkNoncopyable
{
public
:
Context
(
const
SkShaderBase
&
shader
const
ContextRec
&
)
;
virtual
~
Context
(
)
;
virtual
uint32_t
getFlags
(
)
const
{
return
0
;
}
virtual
void
shadeSpan
(
int
x
int
y
SkPMColor
[
]
int
count
)
=
0
;
protected
:
const
SkShaderBase
&
fShader
;
uint8_t
getPaintAlpha
(
)
const
{
return
fPaintAlpha
;
}
const
SkMatrix
&
getTotalInverse
(
)
const
{
return
fTotalInverse
;
}
const
SkMatrix
&
getCTM
(
)
const
{
return
fCTM
;
}
private
:
SkMatrix
fCTM
;
SkMatrix
fTotalInverse
;
uint8_t
fPaintAlpha
;
using
INHERITED
=
SkNoncopyable
;
}
;
class
MatrixRec
{
public
:
MatrixRec
(
)
=
default
;
explicit
MatrixRec
(
const
SkMatrix
&
ctm
)
;
MatrixRec
SK_WARN_UNUSED_RESULT
concat
(
const
SkMatrix
&
m
)
const
;
std
:
:
optional
<
MatrixRec
>
SK_WARN_UNUSED_RESULT
apply
(
const
SkStageRec
&
rec
const
SkMatrix
&
postInv
=
{
}
)
const
;
std
:
:
optional
<
MatrixRec
>
SK_WARN_UNUSED_RESULT
apply
(
skvm
:
:
Builder
*
skvm
:
:
Coord
*
local
skvm
:
:
Uniforms
*
const
SkMatrix
&
postInv
=
{
}
)
const
;
#
if
defined
(
SK_GANESH
)
GrFPResult
SK_WARN_UNUSED_RESULT
apply
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
SkMatrix
&
postInv
=
{
}
)
const
;
MatrixRec
applied
(
)
const
;
#
endif
void
markTotalMatrixInvalid
(
)
{
fTotalMatrixIsValid
=
false
;
}
void
markCTMApplied
(
)
{
fCTMApplied
=
true
;
}
bool
totalMatrixIsValid
(
)
const
{
return
fTotalMatrixIsValid
;
}
SkMatrix
totalMatrix
(
)
const
{
return
SkMatrix
:
:
Concat
(
fCTM
fTotalLocalMatrix
)
;
}
bool
SK_WARN_UNUSED_RESULT
totalInverse
(
SkMatrix
*
out
)
const
{
return
this
-
>
totalMatrix
(
)
.
invert
(
out
)
;
}
bool
hasPendingMatrix
(
)
const
{
return
(
!
fCTMApplied
&
&
!
fCTM
.
isIdentity
(
)
)
|
|
!
fPendingLocalMatrix
.
isIdentity
(
)
;
}
bool
rasterPipelineCoordsAreSeeded
(
)
const
{
return
fCTMApplied
;
}
private
:
MatrixRec
(
const
SkMatrix
&
ctm
const
SkMatrix
&
totalLocalMatrix
const
SkMatrix
&
pendingLocalMatrix
bool
totalIsValid
bool
ctmApplied
)
:
fCTM
(
ctm
)
fTotalLocalMatrix
(
totalLocalMatrix
)
fPendingLocalMatrix
(
pendingLocalMatrix
)
fTotalMatrixIsValid
(
totalIsValid
)
fCTMApplied
(
ctmApplied
)
{
}
const
SkMatrix
fCTM
;
const
SkMatrix
fTotalLocalMatrix
;
const
SkMatrix
fPendingLocalMatrix
;
bool
fTotalMatrixIsValid
=
true
;
bool
fCTMApplied
=
false
;
}
;
Context
*
makeContext
(
const
ContextRec
&
SkArenaAlloc
*
)
const
;
#
if
defined
(
SK_GANESH
)
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asRootFragmentProcessor
(
const
GrFPArgs
&
const
SkMatrix
&
ctm
)
const
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
GrFPArgs
&
const
MatrixRec
&
)
const
;
#
endif
bool
asLuminanceColor
(
SkColor
*
)
const
;
SK_WARN_UNUSED_RESULT
bool
appendRootStages
(
const
SkStageRec
&
rec
const
SkMatrix
&
ctm
)
const
;
virtual
bool
appendStages
(
const
SkStageRec
&
const
MatrixRec
&
)
const
;
bool
SK_WARN_UNUSED_RESULT
computeTotalInverse
(
const
SkMatrix
&
ctm
const
SkMatrix
*
localMatrix
SkMatrix
*
totalInverse
)
const
;
virtual
SkImage
*
onIsAImage
(
SkMatrix
*
SkTileMode
[
2
]
)
const
{
return
nullptr
;
}
virtual
SkRuntimeEffect
*
asRuntimeEffect
(
)
const
{
return
nullptr
;
}
static
Type
GetFlattenableType
(
)
{
return
kSkShader_Type
;
}
Type
getFlattenableType
(
)
const
override
{
return
GetFlattenableType
(
)
;
}
static
sk_sp
<
SkShaderBase
>
Deserialize
(
const
void
*
data
size_t
size
const
SkDeserialProcs
*
procs
=
nullptr
)
{
return
sk_sp
<
SkShaderBase
>
(
static_cast
<
SkShaderBase
*
>
(
SkFlattenable
:
:
Deserialize
(
GetFlattenableType
(
)
data
size
procs
)
.
release
(
)
)
)
;
}
static
void
RegisterFlattenables
(
)
;
virtual
sk_sp
<
SkShader
>
makeAsALocalMatrixShader
(
SkMatrix
*
localMatrix
)
const
;
SK_WARN_UNUSED_RESULT
skvm
:
:
Color
rootProgram
(
skvm
:
:
Builder
*
skvm
:
:
Coord
device
skvm
:
:
Color
paint
const
SkMatrix
&
ctm
const
SkColorInfo
&
dst
skvm
:
:
Uniforms
*
uniforms
SkArenaAlloc
*
alloc
)
const
;
virtual
skvm
:
:
Color
program
(
skvm
:
:
Builder
*
skvm
:
:
Coord
device
skvm
:
:
Coord
local
skvm
:
:
Color
paint
const
MatrixRec
&
const
SkColorInfo
&
dst
skvm
:
:
Uniforms
*
SkArenaAlloc
*
)
const
=
0
;
#
if
defined
(
SK_GRAPHITE
)
virtual
void
addToKey
(
const
skgpu
:
:
graphite
:
:
KeyContext
&
keyContext
skgpu
:
:
graphite
:
:
PaintParamsKeyBuilder
*
builder
skgpu
:
:
graphite
:
:
PipelineDataGatherer
*
gatherer
)
const
;
#
endif
static
SkMatrix
ConcatLocalMatrices
(
const
SkMatrix
&
parentLM
const
SkMatrix
&
childLM
)
{
#
if
defined
(
SK_BUILD_FOR_ANDROID_FRAMEWORK
)
return
SkMatrix
:
:
Concat
(
childLM
parentLM
)
;
#
endif
return
SkMatrix
:
:
Concat
(
parentLM
childLM
)
;
}
protected
:
SkShaderBase
(
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
#
ifdef
SK_ENABLE_LEGACY_SHADERCONTEXT
virtual
Context
*
onMakeContext
(
const
ContextRec
&
SkArenaAlloc
*
)
const
{
return
nullptr
;
}
#
endif
virtual
bool
onAsLuminanceColor
(
SkColor
*
)
const
{
return
false
;
}
protected
:
static
skvm
:
:
Coord
ApplyMatrix
(
skvm
:
:
Builder
*
const
SkMatrix
&
skvm
:
:
Coord
skvm
:
:
Uniforms
*
)
;
using
INHERITED
=
SkShader
;
}
;
inline
SkShaderBase
*
as_SB
(
SkShader
*
shader
)
{
return
static_cast
<
SkShaderBase
*
>
(
shader
)
;
}
inline
const
SkShaderBase
*
as_SB
(
const
SkShader
*
shader
)
{
return
static_cast
<
const
SkShaderBase
*
>
(
shader
)
;
}
inline
const
SkShaderBase
*
as_SB
(
const
sk_sp
<
SkShader
>
&
shader
)
{
return
static_cast
<
SkShaderBase
*
>
(
shader
.
get
(
)
)
;
}
void
SkRegisterColor4ShaderFlattenable
(
)
;
void
SkRegisterColorShaderFlattenable
(
)
;
void
SkRegisterComposeShaderFlattenable
(
)
;
void
SkRegisterCoordClampShaderFlattenable
(
)
;
void
SkRegisterEmptyShaderFlattenable
(
)
;
#
endif
