#
ifndef
SkShaderBase_DEFINED
#
define
SkShaderBase_DEFINED
#
include
"
SkFilterQuality
.
h
"
#
include
"
SkMask
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkNoncopyable
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkTLazy
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
GrFPArgs
.
h
"
#
endif
class
GrContext
;
class
GrColorSpaceInfo
;
class
GrFragmentProcessor
;
class
SkArenaAlloc
;
class
SkColorSpace
;
class
SkColorSpaceXformer
;
class
SkImage
;
struct
SkImageInfo
;
class
SkPaint
;
class
SkRasterPipeline
;
class
SkShaderBase
:
public
SkShader
{
public
:
~
SkShaderBase
(
)
override
;
virtual
bool
isConstant
(
)
const
{
return
false
;
}
const
SkMatrix
&
getLocalMatrix
(
)
const
{
return
fLocalMatrix
;
}
enum
Flags
{
kOpaqueAlpha_Flag
=
1
<
<
0
kConstInY32_Flag
=
1
<
<
1
kPrefers4f_Flag
=
1
<
<
2
}
;
struct
ContextRec
{
ContextRec
(
const
SkPaint
&
paint
const
SkMatrix
&
matrix
const
SkMatrix
*
localM
SkColorType
dstColorType
SkColorSpace
*
dstColorSpace
)
:
fPaint
(
&
paint
)
fMatrix
(
&
matrix
)
fLocalMatrix
(
localM
)
fDstColorType
(
dstColorType
)
fDstColorSpace
(
dstColorSpace
)
{
}
const
SkPaint
*
fPaint
;
const
SkMatrix
*
fMatrix
;
const
SkMatrix
*
fLocalMatrix
;
SkColorType
fDstColorType
;
SkColorSpace
*
fDstColorSpace
;
bool
isLegacyCompatible
(
SkColorSpace
*
shadersColorSpace
)
const
;
}
;
class
Context
:
public
:
:
SkNoncopyable
{
public
:
Context
(
const
SkShaderBase
&
shader
const
ContextRec
&
)
;
virtual
~
Context
(
)
;
virtual
uint32_t
getFlags
(
)
const
{
return
0
;
}
virtual
void
shadeSpan
(
int
x
int
y
SkPMColor
[
]
int
count
)
=
0
;
protected
:
const
SkShaderBase
&
fShader
;
uint8_t
getPaintAlpha
(
)
const
{
return
fPaintAlpha
;
}
const
SkMatrix
&
getTotalInverse
(
)
const
{
return
fTotalInverse
;
}
const
SkMatrix
&
getCTM
(
)
const
{
return
fCTM
;
}
private
:
SkMatrix
fCTM
;
SkMatrix
fTotalInverse
;
uint8_t
fPaintAlpha
;
typedef
SkNoncopyable
INHERITED
;
}
;
Context
*
makeContext
(
const
ContextRec
&
SkArenaAlloc
*
)
const
;
#
if
SK_SUPPORT_GPU
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
GrFPArgs
&
)
const
;
#
endif
bool
asLuminanceColor
(
SkColor
*
)
const
;
sk_sp
<
SkShader
>
makeColorSpace
(
SkColorSpaceXformer
*
xformer
)
const
{
return
this
-
>
onMakeColorSpace
(
xformer
)
;
}
struct
StageRec
{
SkRasterPipeline
*
fPipeline
;
SkArenaAlloc
*
fAlloc
;
SkColorType
fDstColorType
;
SkColorSpace
*
fDstCS
;
const
SkPaint
&
fPaint
;
const
SkMatrix
*
fLocalM
;
SkMatrix
fCTM
;
}
;
bool
appendStages
(
const
StageRec
&
)
const
;
bool
SK_WARN_UNUSED_RESULT
computeTotalInverse
(
const
SkMatrix
&
ctm
const
SkMatrix
*
outerLocalMatrix
SkMatrix
*
totalInverse
)
const
;
SkTCopyOnFirstWrite
<
SkMatrix
>
totalLocalMatrix
(
const
SkMatrix
*
preLocalMatrix
const
SkMatrix
*
postLocalMatrix
=
nullptr
)
const
;
virtual
SkImage
*
onIsAImage
(
SkMatrix
*
TileMode
[
2
]
)
const
{
return
nullptr
;
}
static
Type
GetFlattenableType
(
)
{
return
kSkShaderBase_Type
;
}
Type
getFlattenableType
(
)
const
override
{
return
GetFlattenableType
(
)
;
}
static
sk_sp
<
SkShaderBase
>
Deserialize
(
const
void
*
data
size_t
size
const
SkDeserialProcs
*
procs
=
nullptr
)
{
return
sk_sp
<
SkShaderBase
>
(
static_cast
<
SkShaderBase
*
>
(
SkFlattenable
:
:
Deserialize
(
GetFlattenableType
(
)
data
size
procs
)
.
release
(
)
)
)
;
}
static
void
RegisterFlattenables
(
)
;
protected
:
SkShaderBase
(
const
SkMatrix
*
localMatrix
=
nullptr
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
#
ifdef
SK_ENABLE_LEGACY_SHADERCONTEXT
virtual
Context
*
onMakeContext
(
const
ContextRec
&
SkArenaAlloc
*
)
const
{
return
nullptr
;
}
virtual
Context
*
onMakeBurstPipelineContext
(
const
ContextRec
&
SkArenaAlloc
*
)
const
{
return
nullptr
;
}
#
endif
virtual
bool
onAsLuminanceColor
(
SkColor
*
)
const
{
return
false
;
}
virtual
sk_sp
<
SkShader
>
onMakeColorSpace
(
SkColorSpaceXformer
*
)
const
{
return
sk_ref_sp
(
const_cast
<
SkShaderBase
*
>
(
this
)
)
;
}
virtual
bool
onAppendStages
(
const
StageRec
&
)
const
;
private
:
SkMatrix
fLocalMatrix
;
typedef
SkShader
INHERITED
;
}
;
inline
SkShaderBase
*
as_SB
(
SkShader
*
shader
)
{
return
static_cast
<
SkShaderBase
*
>
(
shader
)
;
}
inline
const
SkShaderBase
*
as_SB
(
const
SkShader
*
shader
)
{
return
static_cast
<
const
SkShaderBase
*
>
(
shader
)
;
}
inline
const
SkShaderBase
*
as_SB
(
const
sk_sp
<
SkShader
>
&
shader
)
{
return
static_cast
<
SkShaderBase
*
>
(
shader
.
get
(
)
)
;
}
#
endif
