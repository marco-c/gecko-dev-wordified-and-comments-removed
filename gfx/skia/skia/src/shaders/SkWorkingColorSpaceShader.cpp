#
include
"
src
/
shaders
/
SkWorkingColorSpaceShader
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkColorSpaceXformSteps
.
h
"
#
include
"
src
/
core
/
SkEffectPriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
"
src
/
shaders
/
SkShaderBase
.
h
"
#
include
<
utility
>
sk_sp
<
SkShader
>
SkWorkingColorSpaceShader
:
:
Make
(
sk_sp
<
SkShader
>
shader
sk_sp
<
SkColorSpace
>
inputCS
sk_sp
<
SkColorSpace
>
outputCS
bool
workInUnpremul
)
{
if
(
!
shader
)
{
return
nullptr
;
}
if
(
!
inputCS
&
&
!
outputCS
&
&
!
workInUnpremul
)
{
return
shader
;
}
else
{
return
sk_sp
(
new
SkWorkingColorSpaceShader
(
std
:
:
move
(
shader
)
std
:
:
move
(
inputCS
)
std
:
:
move
(
outputCS
)
workInUnpremul
)
)
;
}
}
bool
SkWorkingColorSpaceShader
:
:
appendStages
(
const
SkStageRec
&
rec
const
SkShaders
:
:
MatrixRec
&
mRec
)
const
{
sk_sp
<
SkColorSpace
>
dstCS
=
sk_ref_sp
(
rec
.
fDstCS
)
;
if
(
!
dstCS
)
{
dstCS
=
SkColorSpace
:
:
MakeSRGB
(
)
;
}
const
SkAlphaType
dstAT
=
kPremul_SkAlphaType
;
auto
[
inputCS
outputCS
workingAT
]
=
this
-
>
workingSpace
(
dstCS
dstAT
)
;
SkColorInfo
dst
=
{
rec
.
fDstColorType
dstAT
dstCS
}
input
=
{
rec
.
fDstColorType
workingAT
inputCS
}
output
=
{
rec
.
fDstColorType
workingAT
outputCS
}
;
const
auto
*
dstToInput
=
rec
.
fAlloc
-
>
make
<
SkColorSpaceXformSteps
>
(
dst
input
)
;
const
auto
*
outputToDst
=
rec
.
fAlloc
-
>
make
<
SkColorSpaceXformSteps
>
(
output
dst
)
;
SkColor4f
paintColorInWorkingSpace
=
rec
.
fPaintColor
.
makeOpaque
(
)
;
dstToInput
-
>
apply
(
paintColorInWorkingSpace
.
vec
(
)
)
;
SkStageRec
workingRec
=
{
rec
.
fPipeline
rec
.
fAlloc
rec
.
fDstColorType
fInputSpace
.
get
(
)
paintColorInWorkingSpace
rec
.
fSurfaceProps
rec
.
fDstBounds
}
;
if
(
!
as_SB
(
fShader
)
-
>
appendStages
(
workingRec
mRec
)
)
{
return
false
;
}
outputToDst
-
>
apply
(
rec
.
fPipeline
)
;
return
true
;
}
void
SkWorkingColorSpaceShader
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeFlattenable
(
fShader
.
get
(
)
)
;
buffer
.
writeBool
(
fWorkInUnpremul
)
;
buffer
.
writeBool
(
SkToBool
(
fInputSpace
)
)
;
if
(
fInputSpace
)
{
buffer
.
writeDataAsByteArray
(
fInputSpace
-
>
serialize
(
)
.
get
(
)
)
;
}
buffer
.
writeBool
(
SkToBool
(
fOutputSpace
)
)
;
if
(
fOutputSpace
)
{
buffer
.
writeDataAsByteArray
(
fOutputSpace
-
>
serialize
(
)
.
get
(
)
)
;
}
}
sk_sp
<
SkFlattenable
>
SkWorkingColorSpaceShader
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
sk_sp
<
SkShader
>
shader
(
buffer
.
readShader
(
)
)
;
const
bool
legacyWorkingCS
=
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kWorkingColorSpaceOutput
)
;
bool
workInUnpremul
=
!
legacyWorkingCS
&
&
buffer
.
readBool
(
)
;
sk_sp
<
SkColorSpace
>
inputSpace
;
if
(
legacyWorkingCS
|
|
buffer
.
readBool
(
)
)
{
auto
data
=
buffer
.
readByteArrayAsData
(
)
;
if
(
!
buffer
.
validate
(
data
!
=
nullptr
)
)
{
return
nullptr
;
}
inputSpace
=
SkColorSpace
:
:
Deserialize
(
data
-
>
data
(
)
data
-
>
size
(
)
)
;
if
(
!
buffer
.
validate
(
inputSpace
!
=
nullptr
)
)
{
return
nullptr
;
}
}
sk_sp
<
SkColorSpace
>
outputSpace
;
if
(
!
legacyWorkingCS
&
&
buffer
.
readBool
(
)
)
{
auto
data
=
buffer
.
readByteArrayAsData
(
)
;
if
(
!
buffer
.
validate
(
data
!
=
nullptr
)
)
{
return
nullptr
;
}
outputSpace
=
SkColorSpace
:
:
Deserialize
(
data
-
>
data
(
)
data
-
>
size
(
)
)
;
if
(
!
buffer
.
validate
(
outputSpace
!
=
nullptr
)
)
{
return
nullptr
;
}
}
return
Make
(
std
:
:
move
(
shader
)
std
:
:
move
(
inputSpace
)
std
:
:
move
(
outputSpace
)
workInUnpremul
)
;
}
void
SkRegisterWorkingColorSpaceShaderFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkWorkingColorSpaceShader
)
;
}
