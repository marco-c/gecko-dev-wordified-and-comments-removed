#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
src
/
shaders
/
gradients
/
Sk4fGradientBase
.
h
"
#
include
<
functional
>
namespace
{
Sk4f
pack_color
(
const
SkColor4f
&
c4f
bool
premul
const
Sk4f
&
component_scale
)
{
Sk4f
pm4f
=
premul
?
Sk4f
:
:
Load
(
c4f
.
premul
(
)
.
vec
(
)
)
:
Sk4f
:
:
Load
(
c4f
.
vec
(
)
)
;
if
(
premul
)
{
pm4f
=
Sk4f
:
:
Max
(
0
Sk4f
:
:
Min
(
pm4f
pm4f
[
3
]
)
)
;
}
return
pm4f
*
component_scale
;
}
class
IntervalIterator
{
public
:
IntervalIterator
(
const
SkGradientShaderBase
&
shader
bool
reverse
)
:
fShader
(
shader
)
fFirstPos
(
reverse
?
SK_Scalar1
:
0
)
fBegin
(
reverse
?
shader
.
fColorCount
-
1
:
0
)
fAdvance
(
reverse
?
-
1
:
1
)
{
SkASSERT
(
shader
.
fColorCount
>
0
)
;
}
void
iterate
(
const
SkColor4f
*
colors
std
:
:
function
<
void
(
const
SkColor4f
&
const
SkColor4f
&
SkScalar
SkScalar
)
>
func
)
const
{
if
(
!
fShader
.
fOrigPos
)
{
this
-
>
iterateImplicitPos
(
colors
func
)
;
return
;
}
const
int
end
=
fBegin
+
fAdvance
*
(
fShader
.
fColorCount
-
1
)
;
int
prev
=
fBegin
;
SkScalar
prevPos
=
fFirstPos
;
do
{
const
int
curr
=
prev
+
fAdvance
;
SkASSERT
(
curr
>
=
0
&
&
curr
<
fShader
.
fColorCount
)
;
const
SkScalar
currPos
=
fShader
.
fOrigPos
[
curr
]
;
if
(
currPos
!
=
prevPos
)
{
SkASSERT
(
(
currPos
-
prevPos
>
0
)
=
=
(
fAdvance
>
0
)
)
;
func
(
colors
[
prev
]
colors
[
curr
]
prevPos
currPos
)
;
}
prev
=
curr
;
prevPos
=
currPos
;
}
while
(
prev
!
=
end
)
;
}
private
:
void
iterateImplicitPos
(
const
SkColor4f
*
colors
std
:
:
function
<
void
(
const
SkColor4f
&
const
SkColor4f
&
SkScalar
SkScalar
)
>
func
)
const
{
const
SkScalar
dt
=
fAdvance
*
SK_Scalar1
/
(
fShader
.
fColorCount
-
1
)
;
const
int
end
=
fBegin
+
fAdvance
*
(
fShader
.
fColorCount
-
2
)
;
int
prev
=
fBegin
;
SkScalar
prevPos
=
fFirstPos
;
while
(
prev
!
=
end
)
{
const
int
curr
=
prev
+
fAdvance
;
SkASSERT
(
curr
>
=
0
&
&
curr
<
fShader
.
fColorCount
)
;
const
SkScalar
currPos
=
prevPos
+
dt
;
func
(
colors
[
prev
]
colors
[
curr
]
prevPos
currPos
)
;
prev
=
curr
;
prevPos
=
currPos
;
}
func
(
colors
[
prev
]
colors
[
prev
+
fAdvance
]
prevPos
1
-
fFirstPos
)
;
}
const
SkGradientShaderBase
&
fShader
;
const
SkScalar
fFirstPos
;
const
int
fBegin
;
const
int
fAdvance
;
}
;
void
addMirrorIntervals
(
const
SkGradientShaderBase
&
shader
const
SkColor4f
*
colors
const
Sk4f
&
componentScale
bool
premulColors
bool
reverse
Sk4fGradientIntervalBuffer
:
:
BufferType
*
buffer
)
{
const
IntervalIterator
iter
(
shader
reverse
)
;
iter
.
iterate
(
colors
[
&
]
(
const
SkColor4f
&
c0
const
SkColor4f
&
c1
SkScalar
t0
SkScalar
t1
)
{
SkASSERT
(
buffer
-
>
empty
(
)
|
|
buffer
-
>
back
(
)
.
fT1
=
=
2
-
t0
)
;
const
auto
mirror_t0
=
2
-
t0
;
const
auto
mirror_t1
=
2
-
t1
;
if
(
mirror_t0
!
=
mirror_t1
)
{
buffer
-
>
emplace_back
(
pack_color
(
c0
premulColors
componentScale
)
mirror_t0
pack_color
(
c1
premulColors
componentScale
)
mirror_t1
)
;
}
}
)
;
}
}
Sk4fGradientInterval
:
:
Sk4fGradientInterval
(
const
Sk4f
&
c0
SkScalar
t0
const
Sk4f
&
c1
SkScalar
t1
)
:
fT0
(
t0
)
fT1
(
t1
)
{
SkASSERT
(
t0
!
=
t1
)
;
SkASSERT
(
SkScalarIsFinite
(
t0
)
|
|
SkScalarIsFinite
(
t1
)
)
;
const
auto
dt
=
t1
-
t0
;
SkASSERT
(
SkScalarIsFinite
(
dt
)
|
|
(
c0
=
=
c1
)
.
allTrue
(
)
)
;
SkASSERT
(
SkScalarIsFinite
(
t0
)
|
|
(
c0
=
=
c1
)
.
allTrue
(
)
)
;
const
Sk4f
dc
=
SkScalarIsFinite
(
dt
)
?
(
c1
-
c0
)
/
dt
:
0
;
const
Sk4f
bias
=
c0
-
(
SkScalarIsFinite
(
t0
)
?
t0
*
dc
:
0
)
;
bias
.
store
(
fCb
.
vec
(
)
)
;
dc
.
store
(
fCg
.
vec
(
)
)
;
}
void
Sk4fGradientIntervalBuffer
:
:
init
(
const
SkGradientShaderBase
&
shader
SkColorSpace
*
dstCS
SkTileMode
tileMode
bool
premulColors
SkScalar
alpha
bool
reverse
)
{
const
auto
count
=
shader
.
fColorCount
;
SkASSERT
(
count
>
0
)
;
fIntervals
.
reset
(
)
;
const
Sk4f
componentScale
=
premulColors
?
Sk4f
(
alpha
)
:
Sk4f
(
1
.
0f
1
.
0f
1
.
0f
alpha
)
;
const
int
first_index
=
reverse
?
count
-
1
:
0
;
const
int
last_index
=
count
-
1
-
first_index
;
const
SkScalar
first_pos
=
reverse
?
SK_Scalar1
:
0
;
const
SkScalar
last_pos
=
SK_Scalar1
-
first_pos
;
SkColor4fXformer
xformedColors
(
shader
.
fOrigColors4f
count
shader
.
fColorSpace
.
get
(
)
dstCS
)
;
if
(
tileMode
=
=
SkTileMode
:
:
kClamp
)
{
const
Sk4f
clamp_color
=
pack_color
(
xformedColors
.
fColors
[
first_index
]
premulColors
componentScale
)
;
const
SkScalar
clamp_pos
=
reverse
?
SK_ScalarInfinity
:
SK_ScalarNegativeInfinity
;
fIntervals
.
emplace_back
(
clamp_color
clamp_pos
clamp_color
first_pos
)
;
}
else
if
(
tileMode
=
=
SkTileMode
:
:
kMirror
&
&
reverse
)
{
addMirrorIntervals
(
shader
xformedColors
.
fColors
componentScale
premulColors
false
&
fIntervals
)
;
}
const
IntervalIterator
iter
(
shader
reverse
)
;
iter
.
iterate
(
xformedColors
.
fColors
[
&
]
(
const
SkColor4f
&
c0
const
SkColor4f
&
c1
SkScalar
t0
SkScalar
t1
)
{
SkASSERT
(
fIntervals
.
empty
(
)
|
|
fIntervals
.
back
(
)
.
fT1
=
=
t0
)
;
fIntervals
.
emplace_back
(
pack_color
(
c0
premulColors
componentScale
)
t0
pack_color
(
c1
premulColors
componentScale
)
t1
)
;
}
)
;
if
(
tileMode
=
=
SkTileMode
:
:
kClamp
)
{
const
Sk4f
clamp_color
=
pack_color
(
xformedColors
.
fColors
[
last_index
]
premulColors
componentScale
)
;
const
SkScalar
clamp_pos
=
reverse
?
SK_ScalarNegativeInfinity
:
SK_ScalarInfinity
;
fIntervals
.
emplace_back
(
clamp_color
last_pos
clamp_color
clamp_pos
)
;
}
else
if
(
tileMode
=
=
SkTileMode
:
:
kMirror
&
&
!
reverse
)
{
addMirrorIntervals
(
shader
xformedColors
.
fColors
componentScale
premulColors
true
&
fIntervals
)
;
}
}
const
Sk4fGradientInterval
*
Sk4fGradientIntervalBuffer
:
:
find
(
SkScalar
t
)
const
{
const
auto
*
i0
=
fIntervals
.
begin
(
)
;
const
auto
*
i1
=
fIntervals
.
end
(
)
-
1
;
while
(
i0
!
=
i1
)
{
SkASSERT
(
i0
<
i1
)
;
SkASSERT
(
t
>
=
i0
-
>
fT0
&
&
t
<
=
i1
-
>
fT1
)
;
const
auto
*
i
=
i0
+
(
(
i1
-
i0
)
>
>
1
)
;
if
(
t
>
i
-
>
fT1
)
{
i0
=
i
+
1
;
}
else
{
i1
=
i
;
}
}
SkASSERT
(
i0
-
>
contains
(
t
)
)
;
return
i0
;
}
const
Sk4fGradientInterval
*
Sk4fGradientIntervalBuffer
:
:
findNext
(
SkScalar
t
const
Sk4fGradientInterval
*
prev
bool
increasing
)
const
{
SkASSERT
(
!
prev
-
>
contains
(
t
)
)
;
SkASSERT
(
prev
>
=
fIntervals
.
begin
(
)
&
&
prev
<
fIntervals
.
end
(
)
)
;
SkASSERT
(
t
>
=
fIntervals
.
front
(
)
.
fT0
&
&
t
<
=
fIntervals
.
back
(
)
.
fT1
)
;
const
auto
*
i
=
prev
;
if
(
increasing
)
{
do
{
i
+
=
1
;
if
(
i
>
=
fIntervals
.
end
(
)
)
{
i
=
fIntervals
.
begin
(
)
;
}
}
while
(
!
i
-
>
contains
(
t
)
)
;
}
else
{
do
{
i
-
=
1
;
if
(
i
<
fIntervals
.
begin
(
)
)
{
i
=
fIntervals
.
end
(
)
-
1
;
}
}
while
(
!
i
-
>
contains
(
t
)
)
;
}
return
i
;
}
SkGradientShaderBase
:
:
GradientShaderBase4fContext
:
:
GradientShaderBase4fContext
(
const
SkGradientShaderBase
&
shader
const
ContextRec
&
rec
)
:
INHERITED
(
shader
rec
)
fFlags
(
this
-
>
INHERITED
:
:
getFlags
(
)
)
fDither
(
rec
.
fPaint
-
>
isDither
(
)
)
{
const
SkMatrix
&
inverse
=
this
-
>
getTotalInverse
(
)
;
fDstToPos
.
setConcat
(
shader
.
fPtsToUnit
inverse
)
;
SkASSERT
(
!
fDstToPos
.
hasPerspective
(
)
)
;
fDstToPosProc
=
SkMatrixPriv
:
:
GetMapXYProc
(
fDstToPos
)
;
if
(
shader
.
fColorsAreOpaque
&
&
this
-
>
getPaintAlpha
(
)
=
=
SK_AlphaOPAQUE
)
{
fFlags
|
=
kOpaqueAlpha_Flag
;
}
fColorsArePremul
=
(
shader
.
fGradFlags
&
SkGradientShader
:
:
kInterpolateColorsInPremul_Flag
)
|
|
shader
.
fColorsAreOpaque
;
}
bool
SkGradientShaderBase
:
:
GradientShaderBase4fContext
:
:
isValid
(
)
const
{
return
fDstToPos
.
isFinite
(
)
;
}
