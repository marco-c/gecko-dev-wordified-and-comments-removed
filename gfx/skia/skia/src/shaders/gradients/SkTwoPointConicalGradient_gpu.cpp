#
include
"
SkTwoPointConicalGradient
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
SkTwoPointConicalGradient_gpu
.
h
"
typedef
GrGLSLProgramDataManager
:
:
UniformHandle
UniformHandle
;
class
TwoPointConicalEffect
:
public
GrGradientEffect
{
public
:
using
Type
=
SkTwoPointConicalGradient
:
:
Type
;
class
DegeneratedGLSLProcessor
;
class
FocalGLSLProcessor
;
struct
Data
{
Type
fType
;
SkScalar
fRadius0
;
SkScalar
fDiffRadius
;
SkTwoPointConicalGradient
:
:
FocalData
fFocalData
;
Data
(
const
SkTwoPointConicalGradient
&
shader
SkMatrix
&
matrix
)
;
bool
operator
=
=
(
const
Data
&
d
)
const
{
if
(
fType
!
=
d
.
fType
)
{
return
false
;
}
switch
(
fType
)
{
case
Type
:
:
kRadial
:
case
Type
:
:
kStrip
:
return
fRadius0
=
=
d
.
fRadius0
&
&
fDiffRadius
=
=
d
.
fDiffRadius
;
case
Type
:
:
kFocal
:
return
fFocalData
.
fR1
=
=
d
.
fFocalData
.
fR1
&
&
fFocalData
.
fFocalX
=
=
d
.
fFocalData
.
fFocalX
&
&
fFocalData
.
fIsSwapped
=
=
d
.
fFocalData
.
fIsSwapped
;
}
SkDEBUGFAIL
(
"
This
return
should
be
unreachable
;
it
'
s
here
just
for
compile
warning
"
)
;
return
false
;
}
}
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
const
CreateArgs
&
args
const
Data
&
data
)
;
SkScalar
diffRadius
(
)
const
{
SkASSERT
(
!
this
-
>
isFocal
(
)
)
;
return
fData
.
fDiffRadius
;
}
SkScalar
r0
(
)
const
{
SkASSERT
(
!
this
-
>
isFocal
(
)
)
;
return
fData
.
fRadius0
;
}
SkScalar
r1
(
)
const
{
SkASSERT
(
this
-
>
isFocal
(
)
)
;
return
fData
.
fFocalData
.
fR1
;
}
SkScalar
focalX
(
)
const
{
SkASSERT
(
this
-
>
isFocal
(
)
)
;
return
fData
.
fFocalData
.
fFocalX
;
}
const
char
*
name
(
)
const
override
{
return
"
Two
-
Point
Conical
Gradient
"
;
}
bool
isFocalOnCircle
(
)
const
{
return
this
-
>
isFocal
(
)
&
&
fData
.
fFocalData
.
isFocalOnCircle
(
)
;
}
bool
isSwapped
(
)
const
{
return
this
-
>
isFocal
(
)
&
&
fData
.
fFocalData
.
isSwapped
(
)
;
}
Type
getType
(
)
const
{
return
fData
.
fType
;
}
bool
isFocal
(
)
const
{
return
fData
.
fType
=
=
Type
:
:
kFocal
;
}
bool
isWellBehaved
(
)
const
{
return
this
-
>
isFocal
(
)
&
&
fData
.
fFocalData
.
isWellBehaved
(
)
;
}
bool
isNativelyFocal
(
)
const
{
return
this
-
>
isFocal
(
)
&
&
fData
.
fFocalData
.
isNativelyFocal
(
)
;
}
bool
isRadiusIncreasing
(
)
const
{
return
this
-
>
isFocal
(
)
?
1
-
fData
.
fFocalData
.
fFocalX
>
0
:
this
-
>
diffRadius
(
)
>
0
;
}
protected
:
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
c
GrProcessorKeyBuilder
*
b
)
const
override
{
INHERITED
:
:
onGetGLSLProcessorKey
(
c
b
)
;
uint32_t
key
=
0
;
key
|
=
static_cast
<
int
>
(
fData
.
fType
)
;
SkASSERT
(
key
<
(
1
<
<
2
)
)
;
key
|
=
(
this
-
>
isFocalOnCircle
(
)
<
<
2
)
;
key
|
=
(
this
-
>
isWellBehaved
(
)
<
<
3
)
;
key
|
=
(
this
-
>
isRadiusIncreasing
(
)
<
<
4
)
;
key
|
=
(
this
-
>
isNativelyFocal
(
)
<
<
5
)
;
key
|
=
(
this
-
>
isSwapped
(
)
<
<
6
)
;
SkASSERT
(
key
<
(
1
<
<
7
)
)
;
b
-
>
add32
(
key
)
;
}
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
TwoPointConicalEffect
(
*
this
)
)
;
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
sBase
)
const
override
{
const
TwoPointConicalEffect
&
s
=
sBase
.
cast
<
TwoPointConicalEffect
>
(
)
;
return
(
INHERITED
:
:
onIsEqual
(
sBase
)
&
&
fData
=
=
s
.
fData
)
;
}
explicit
TwoPointConicalEffect
(
const
CreateArgs
&
args
const
Data
data
)
:
INHERITED
(
kTwoPointConicalEffect_ClassID
args
false
)
fData
(
data
)
{
}
explicit
TwoPointConicalEffect
(
const
TwoPointConicalEffect
&
that
)
:
INHERITED
(
that
)
fData
(
that
.
fData
)
{
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
Data
fData
;
typedef
GrGradientEffect
INHERITED
;
}
;
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
TwoPointConicalEffect
)
;
#
if
GR_TEST_UTILS
std
:
:
unique_ptr
<
GrFragmentProcessor
>
TwoPointConicalEffect
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
SkPoint
center1
=
{
d
-
>
fRandom
-
>
nextUScalar1
(
)
d
-
>
fRandom
-
>
nextUScalar1
(
)
}
;
SkPoint
center2
=
{
d
-
>
fRandom
-
>
nextUScalar1
(
)
d
-
>
fRandom
-
>
nextUScalar1
(
)
}
;
SkScalar
radius1
=
d
-
>
fRandom
-
>
nextUScalar1
(
)
;
SkScalar
radius2
=
d
-
>
fRandom
-
>
nextUScalar1
(
)
;
constexpr
int
kTestTypeMask
=
(
1
<
<
2
)
-
1
kTestNativelyFocalBit
=
(
1
<
<
2
)
kTestFocalOnCircleBit
=
(
1
<
<
3
)
kTestSwappedBit
=
(
1
<
<
4
)
;
int
mask
=
d
-
>
fRandom
-
>
nextU
(
)
;
int
type
=
mask
&
kTestTypeMask
;
if
(
type
=
=
static_cast
<
int
>
(
TwoPointConicalEffect
:
:
Type
:
:
kRadial
)
)
{
center2
=
center1
;
if
(
SkScalarNearlyZero
(
radius1
-
radius2
)
)
{
radius2
+
=
.
1f
;
}
}
else
if
(
type
=
=
static_cast
<
int
>
(
TwoPointConicalEffect
:
:
Type
:
:
kStrip
)
)
{
radius1
=
SkTMax
(
radius1
.
1f
)
;
radius2
=
radius1
;
if
(
SkScalarNearlyZero
(
SkPoint
:
:
Distance
(
center1
center2
)
)
)
{
center2
.
fX
+
=
.
1f
;
}
}
else
{
if
(
SkScalarNearlyZero
(
SkPoint
:
:
Distance
(
center1
center2
)
)
)
{
center2
.
fX
+
=
.
1f
;
}
if
(
kTestNativelyFocalBit
&
mask
)
{
radius1
=
0
;
}
if
(
kTestFocalOnCircleBit
&
mask
)
{
radius2
=
radius1
+
SkPoint
:
:
Distance
(
center1
center2
)
;
}
if
(
kTestSwappedBit
&
mask
)
{
std
:
:
swap
(
radius1
radius2
)
;
radius2
=
0
;
}
if
(
SkScalarNearlyZero
(
radius1
-
radius2
)
)
{
radius2
+
=
.
1f
;
}
}
if
(
SkScalarNearlyZero
(
radius1
-
radius2
)
&
&
SkScalarNearlyZero
(
SkPoint
:
:
Distance
(
center1
center2
)
)
)
{
radius2
+
=
.
1f
;
}
RandomGradientParams
params
(
d
-
>
fRandom
)
;
auto
shader
=
params
.
fUseColors4f
?
SkGradientShader
:
:
MakeTwoPointConical
(
center1
radius1
center2
radius2
params
.
fColors4f
params
.
fColorSpace
params
.
fStops
params
.
fColorCount
params
.
fTileMode
)
:
SkGradientShader
:
:
MakeTwoPointConical
(
center1
radius1
center2
radius2
params
.
fColors
params
.
fStops
params
.
fColorCount
params
.
fTileMode
)
;
GrTest
:
:
TestAsFPArgs
asFPArgs
(
d
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
=
as_SB
(
shader
)
-
>
asFragmentProcessor
(
asFPArgs
.
args
(
)
)
;
GrAlwaysAssert
(
fp
)
;
return
fp
;
}
#
endif
class
TwoPointConicalEffect
:
:
DegeneratedGLSLProcessor
:
public
GrGradientEffect
:
:
GLSLProcessor
{
protected
:
void
emitCode
(
EmitArgs
&
args
)
override
{
const
TwoPointConicalEffect
&
effect
=
args
.
fFp
.
cast
<
TwoPointConicalEffect
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
this
-
>
emitUniforms
(
uniformHandler
effect
)
;
fParamUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kHalf_GrSLType
"
Conical2FSParams
"
)
;
SkString
p0
;
p0
.
appendf
(
"
%
s
"
uniformHandler
-
>
getUniformVariable
(
fParamUni
)
.
getName
(
)
.
c_str
(
)
)
;
const
char
*
tName
=
"
t
"
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
SkString
coords2D
=
fragBuilder
-
>
ensureCoords2D
(
args
.
fTransformedCoords
[
0
]
)
;
const
char
*
p
=
coords2D
.
c_str
(
)
;
if
(
effect
.
getType
(
)
=
=
Type
:
:
kRadial
)
{
char
sign
=
effect
.
diffRadius
(
)
<
0
?
'
-
'
:
'
+
'
;
fragBuilder
-
>
codeAppendf
(
"
half
%
s
=
%
clength
(
%
s
)
-
%
s
;
"
tName
sign
p
p0
.
c_str
(
)
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
"
args
.
fOutputColor
)
;
fragBuilder
-
>
codeAppendf
(
"
half
temp
=
%
s
-
%
s
.
y
*
%
s
.
y
;
"
p0
.
c_str
(
)
p
p
)
;
fragBuilder
-
>
codeAppendf
(
"
if
(
temp
>
=
0
)
{
"
)
;
fragBuilder
-
>
codeAppendf
(
"
half
%
s
=
%
s
.
x
+
sqrt
(
temp
)
;
"
tName
p
)
;
}
this
-
>
emitColor
(
fragBuilder
uniformHandler
args
.
fShaderCaps
effect
tName
args
.
fOutputColor
args
.
fInputColor
args
.
fTexSamplers
)
;
if
(
effect
.
getType
(
)
!
=
Type
:
:
kRadial
)
{
fragBuilder
-
>
codeAppendf
(
"
}
"
)
;
}
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
p
)
override
{
INHERITED
:
:
onSetData
(
pdman
p
)
;
const
TwoPointConicalEffect
&
effect
=
p
.
cast
<
TwoPointConicalEffect
>
(
)
;
SkASSERT
(
effect
.
getType
(
)
=
=
Type
:
:
kStrip
|
|
SkScalarNearlyZero
(
SkTAbs
(
effect
.
diffRadius
(
)
)
-
1
)
)
;
pdman
.
set1f
(
fParamUni
effect
.
getType
(
)
=
=
Type
:
:
kRadial
?
effect
.
r0
(
)
:
effect
.
r0
(
)
*
effect
.
r0
(
)
)
;
}
UniformHandle
fParamUni
;
private
:
typedef
GrGradientEffect
:
:
GLSLProcessor
INHERITED
;
}
;
class
TwoPointConicalEffect
:
:
FocalGLSLProcessor
:
public
GrGradientEffect
:
:
GLSLProcessor
{
protected
:
void
emitCode
(
EmitArgs
&
args
)
override
{
const
TwoPointConicalEffect
&
effect
=
args
.
fFp
.
cast
<
TwoPointConicalEffect
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
this
-
>
emitUniforms
(
uniformHandler
effect
)
;
fParamUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kHalf2_GrSLType
"
Conical2FSParams
"
)
;
SkString
p0
;
SkString
p1
;
p0
.
appendf
(
"
%
s
.
x
"
uniformHandler
-
>
getUniformVariable
(
fParamUni
)
.
getName
(
)
.
c_str
(
)
)
;
p1
.
appendf
(
"
%
s
.
y
"
uniformHandler
-
>
getUniformVariable
(
fParamUni
)
.
getName
(
)
.
c_str
(
)
)
;
const
char
*
tName
=
"
t
"
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
SkString
coords2D
=
fragBuilder
-
>
ensureCoords2D
(
args
.
fTransformedCoords
[
0
]
)
;
const
char
*
p
=
coords2D
.
c_str
(
)
;
if
(
effect
.
isFocalOnCircle
(
)
)
{
fragBuilder
-
>
codeAppendf
(
"
half
x_t
=
dot
(
%
s
%
s
)
/
%
s
.
x
;
"
p
p
p
)
;
}
else
if
(
effect
.
isWellBehaved
(
)
)
{
fragBuilder
-
>
codeAppendf
(
"
half
x_t
=
length
(
%
s
)
-
%
s
.
x
*
%
s
;
"
p
p
p0
.
c_str
(
)
)
;
}
else
{
char
sign
=
(
effect
.
isSwapped
(
)
|
|
!
effect
.
isRadiusIncreasing
(
)
)
?
'
-
'
:
'
'
;
fragBuilder
-
>
codeAppendf
(
"
half
temp
=
%
s
.
x
*
%
s
.
x
-
%
s
.
y
*
%
s
.
y
;
"
p
p
p
p
)
;
fragBuilder
-
>
codeAppendf
(
"
half
x_t
=
-
1
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
if
(
temp
>
=
0
)
{
"
)
;
fragBuilder
-
>
codeAppendf
(
"
x_t
=
(
%
csqrt
(
temp
)
-
%
s
.
x
*
%
s
)
;
"
sign
p
p0
.
c_str
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
}
"
)
;
}
char
sign
=
effect
.
isRadiusIncreasing
(
)
?
'
'
:
'
-
'
;
fragBuilder
-
>
codeAppendf
(
"
half
%
s
=
%
cx_t
+
%
s
;
"
tName
sign
effect
.
isNativelyFocal
(
)
?
"
0
"
:
p1
.
c_str
(
)
)
;
if
(
!
effect
.
isWellBehaved
(
)
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
"
args
.
fOutputColor
)
;
fragBuilder
-
>
codeAppendf
(
"
if
(
x_t
>
0
.
0
)
{
"
)
;
}
if
(
effect
.
isSwapped
(
)
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
1
-
%
s
;
"
tName
tName
)
;
}
this
-
>
emitColor
(
fragBuilder
uniformHandler
args
.
fShaderCaps
effect
tName
args
.
fOutputColor
args
.
fInputColor
args
.
fTexSamplers
)
;
if
(
!
effect
.
isWellBehaved
(
)
)
{
fragBuilder
-
>
codeAppend
(
"
}
;
"
)
;
}
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
p
)
override
{
INHERITED
:
:
onSetData
(
pdman
p
)
;
const
TwoPointConicalEffect
&
effect
=
p
.
cast
<
TwoPointConicalEffect
>
(
)
;
pdman
.
set2f
(
fParamUni
1
/
effect
.
r1
(
)
effect
.
focalX
(
)
)
;
}
UniformHandle
fParamUni
;
private
:
typedef
GrGradientEffect
:
:
GLSLProcessor
INHERITED
;
}
;
GrGLSLFragmentProcessor
*
TwoPointConicalEffect
:
:
onCreateGLSLInstance
(
)
const
{
if
(
fData
.
fType
=
=
Type
:
:
kRadial
|
|
fData
.
fType
=
=
Type
:
:
kStrip
)
{
return
new
DegeneratedGLSLProcessor
;
}
return
new
FocalGLSLProcessor
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
TwoPointConicalEffect
:
:
Make
(
const
GrGradientEffect
:
:
CreateArgs
&
args
const
Data
&
data
)
{
return
GrGradientEffect
:
:
AdjustFP
(
std
:
:
unique_ptr
<
TwoPointConicalEffect
>
(
new
TwoPointConicalEffect
(
args
data
)
)
args
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Gr2PtConicalGradientEffect
:
:
Make
(
const
GrGradientEffect
:
:
CreateArgs
&
args
)
{
const
SkTwoPointConicalGradient
&
shader
=
*
static_cast
<
const
SkTwoPointConicalGradient
*
>
(
args
.
fShader
)
;
SkMatrix
matrix
;
if
(
!
shader
.
getLocalMatrix
(
)
.
invert
(
&
matrix
)
)
{
return
nullptr
;
}
if
(
args
.
fMatrix
)
{
SkMatrix
inv
;
if
(
!
args
.
fMatrix
-
>
invert
(
&
inv
)
)
{
return
nullptr
;
}
matrix
.
postConcat
(
inv
)
;
}
GrGradientEffect
:
:
CreateArgs
newArgs
(
args
.
fContext
args
.
fShader
&
matrix
args
.
fWrapMode
args
.
fDstColorSpace
)
;
TwoPointConicalEffect
:
:
Data
data
(
shader
matrix
)
;
return
TwoPointConicalEffect
:
:
Make
(
newArgs
data
)
;
}
TwoPointConicalEffect
:
:
Data
:
:
Data
(
const
SkTwoPointConicalGradient
&
shader
SkMatrix
&
matrix
)
{
fType
=
shader
.
getType
(
)
;
if
(
fType
=
=
Type
:
:
kRadial
)
{
matrix
.
postTranslate
(
-
shader
.
getStartCenter
(
)
.
fX
-
shader
.
getStartCenter
(
)
.
fY
)
;
SkScalar
dr
=
shader
.
getDiffRadius
(
)
;
matrix
.
postScale
(
1
/
dr
1
/
dr
)
;
fRadius0
=
shader
.
getStartRadius
(
)
/
dr
;
fDiffRadius
=
dr
<
0
?
-
1
:
1
;
}
else
if
(
fType
=
=
Type
:
:
kStrip
)
{
fRadius0
=
shader
.
getStartRadius
(
)
/
shader
.
getCenterX1
(
)
;
fDiffRadius
=
0
;
matrix
.
postConcat
(
shader
.
getGradientMatrix
(
)
)
;
}
else
if
(
fType
=
=
Type
:
:
kFocal
)
{
fFocalData
=
shader
.
getFocalData
(
)
;
matrix
.
postConcat
(
shader
.
getGradientMatrix
(
)
)
;
}
}
#
endif
