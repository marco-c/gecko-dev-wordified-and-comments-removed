#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
src
/
core
/
SkRasterPipeline
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
"
src
/
shaders
/
SkLocalMatrixShader
.
h
"
#
include
"
src
/
shaders
/
gradients
/
SkGradientShaderBase
.
h
"
#
include
<
utility
>
#
if
defined
(
SK_GRAPHITE
)
#
include
"
src
/
gpu
/
graphite
/
KeyContext
.
h
"
#
include
"
src
/
gpu
/
graphite
/
KeyHelpers
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PaintParamsKey
.
h
"
#
endif
class
SkTwoPointConicalGradient
final
:
public
SkGradientShaderBase
{
public
:
struct
FocalData
{
SkScalar
fR1
;
SkScalar
fFocalX
;
bool
fIsSwapped
;
bool
set
(
SkScalar
r0
SkScalar
r1
SkMatrix
*
matrix
)
;
bool
isFocalOnCircle
(
)
const
{
return
SkScalarNearlyZero
(
1
-
fR1
)
;
}
bool
isSwapped
(
)
const
{
return
fIsSwapped
;
}
bool
isWellBehaved
(
)
const
{
return
!
this
-
>
isFocalOnCircle
(
)
&
&
fR1
>
1
;
}
bool
isNativelyFocal
(
)
const
{
return
SkScalarNearlyZero
(
fFocalX
)
;
}
}
;
enum
class
Type
{
kRadial
kStrip
kFocal
}
;
static
sk_sp
<
SkShader
>
Create
(
const
SkPoint
&
start
SkScalar
startRadius
const
SkPoint
&
end
SkScalar
endRadius
const
Descriptor
&
const
SkMatrix
*
localMatrix
)
;
GradientType
asGradient
(
GradientInfo
*
info
SkMatrix
*
localMatrix
)
const
override
;
#
if
defined
(
SK_GANESH
)
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
GrFPArgs
&
const
MatrixRec
&
)
const
override
;
#
endif
#
if
defined
(
SK_GRAPHITE
)
void
addToKey
(
const
skgpu
:
:
graphite
:
:
KeyContext
&
skgpu
:
:
graphite
:
:
PaintParamsKeyBuilder
*
skgpu
:
:
graphite
:
:
PipelineDataGatherer
*
)
const
override
;
#
endif
bool
isOpaque
(
)
const
override
;
SkScalar
getCenterX1
(
)
const
{
return
SkPoint
:
:
Distance
(
fCenter1
fCenter2
)
;
}
SkScalar
getStartRadius
(
)
const
{
return
fRadius1
;
}
SkScalar
getDiffRadius
(
)
const
{
return
fRadius2
-
fRadius1
;
}
const
SkPoint
&
getStartCenter
(
)
const
{
return
fCenter1
;
}
const
SkPoint
&
getEndCenter
(
)
const
{
return
fCenter2
;
}
SkScalar
getEndRadius
(
)
const
{
return
fRadius2
;
}
Type
getType
(
)
const
{
return
fType
;
}
const
FocalData
&
getFocalData
(
)
const
{
return
fFocalData
;
}
SkTwoPointConicalGradient
(
const
SkPoint
&
c0
SkScalar
r0
const
SkPoint
&
c1
SkScalar
r1
const
Descriptor
&
Type
const
SkMatrix
&
const
FocalData
&
)
;
protected
:
void
flatten
(
SkWriteBuffer
&
buffer
)
const
override
;
void
appendGradientStages
(
SkArenaAlloc
*
alloc
SkRasterPipeline
*
tPipeline
SkRasterPipeline
*
postPipeline
)
const
override
;
skvm
:
:
F32
transformT
(
skvm
:
:
Builder
*
skvm
:
:
Uniforms
*
skvm
:
:
Coord
coord
skvm
:
:
I32
*
mask
)
const
final
;
private
:
friend
void
:
:
SkRegisterTwoPointConicalGradientShaderFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkTwoPointConicalGradient
)
SkPoint
fCenter1
;
SkPoint
fCenter2
;
SkScalar
fRadius1
;
SkScalar
fRadius2
;
Type
fType
;
FocalData
fFocalData
;
}
;
bool
SkTwoPointConicalGradient
:
:
FocalData
:
:
set
(
SkScalar
r0
SkScalar
r1
SkMatrix
*
matrix
)
{
fIsSwapped
=
false
;
fFocalX
=
sk_ieee_float_divide
(
r0
(
r0
-
r1
)
)
;
if
(
SkScalarNearlyZero
(
fFocalX
-
1
)
)
{
matrix
-
>
postTranslate
(
-
1
0
)
;
matrix
-
>
postScale
(
-
1
1
)
;
std
:
:
swap
(
r0
r1
)
;
fFocalX
=
0
;
fIsSwapped
=
true
;
}
const
SkPoint
from
[
2
]
=
{
{
fFocalX
0
}
{
1
0
}
}
;
const
SkPoint
to
[
2
]
=
{
{
0
0
}
{
1
0
}
}
;
SkMatrix
focalMatrix
;
if
(
!
focalMatrix
.
setPolyToPoly
(
from
to
2
)
)
{
return
false
;
}
matrix
-
>
postConcat
(
focalMatrix
)
;
fR1
=
r1
/
SkScalarAbs
(
1
-
fFocalX
)
;
if
(
this
-
>
isFocalOnCircle
(
)
)
{
matrix
-
>
postScale
(
0
.
5
0
.
5
)
;
}
else
{
matrix
-
>
postScale
(
fR1
/
(
fR1
*
fR1
-
1
)
1
/
sqrt
(
SkScalarAbs
(
fR1
*
fR1
-
1
)
)
)
;
}
matrix
-
>
postScale
(
SkScalarAbs
(
1
-
fFocalX
)
SkScalarAbs
(
1
-
fFocalX
)
)
;
return
true
;
}
sk_sp
<
SkShader
>
SkTwoPointConicalGradient
:
:
Create
(
const
SkPoint
&
c0
SkScalar
r0
const
SkPoint
&
c1
SkScalar
r1
const
Descriptor
&
desc
const
SkMatrix
*
localMatrix
)
{
SkMatrix
gradientMatrix
;
Type
gradientType
;
if
(
SkScalarNearlyZero
(
(
c0
-
c1
)
.
length
(
)
)
)
{
if
(
SkScalarNearlyZero
(
std
:
:
max
(
r0
r1
)
)
|
|
SkScalarNearlyEqual
(
r0
r1
)
)
{
return
nullptr
;
}
const
SkScalar
scale
=
sk_ieee_float_divide
(
1
std
:
:
max
(
r0
r1
)
)
;
gradientMatrix
=
SkMatrix
:
:
Translate
(
-
c1
.
x
(
)
-
c1
.
y
(
)
)
;
gradientMatrix
.
postScale
(
scale
scale
)
;
gradientType
=
Type
:
:
kRadial
;
}
else
{
const
SkPoint
centers
[
2
]
=
{
c0
c1
}
;
const
SkPoint
unitvec
[
2
]
=
{
{
0
0
}
{
1
0
}
}
;
if
(
!
gradientMatrix
.
setPolyToPoly
(
centers
unitvec
2
)
)
{
return
nullptr
;
}
gradientType
=
SkScalarNearlyZero
(
r1
-
r0
)
?
Type
:
:
kStrip
:
Type
:
:
kFocal
;
}
FocalData
focalData
;
if
(
gradientType
=
=
Type
:
:
kFocal
)
{
const
auto
dCenter
=
(
c0
-
c1
)
.
length
(
)
;
if
(
!
focalData
.
set
(
r0
/
dCenter
r1
/
dCenter
&
gradientMatrix
)
)
{
return
nullptr
;
}
}
return
SkLocalMatrixShader
:
:
MakeWrapped
<
SkTwoPointConicalGradient
>
(
localMatrix
c0
r0
c1
r1
desc
gradientType
gradientMatrix
focalData
)
;
}
SkTwoPointConicalGradient
:
:
SkTwoPointConicalGradient
(
const
SkPoint
&
start
SkScalar
startRadius
const
SkPoint
&
end
SkScalar
endRadius
const
Descriptor
&
desc
Type
type
const
SkMatrix
&
gradientMatrix
const
FocalData
&
data
)
:
SkGradientShaderBase
(
desc
gradientMatrix
)
fCenter1
(
start
)
fCenter2
(
end
)
fRadius1
(
startRadius
)
fRadius2
(
endRadius
)
fType
(
type
)
{
SkASSERT
(
fCenter1
!
=
fCenter2
|
|
fRadius1
!
=
fRadius2
)
;
if
(
type
=
=
Type
:
:
kFocal
)
{
fFocalData
=
data
;
}
}
bool
SkTwoPointConicalGradient
:
:
isOpaque
(
)
const
{
return
false
;
}
SkShaderBase
:
:
GradientType
SkTwoPointConicalGradient
:
:
asGradient
(
GradientInfo
*
info
SkMatrix
*
localMatrix
)
const
{
if
(
info
)
{
commonAsAGradient
(
info
)
;
info
-
>
fPoint
[
0
]
=
fCenter1
;
info
-
>
fPoint
[
1
]
=
fCenter2
;
info
-
>
fRadius
[
0
]
=
fRadius1
;
info
-
>
fRadius
[
1
]
=
fRadius2
;
}
if
(
localMatrix
)
{
*
localMatrix
=
SkMatrix
:
:
I
(
)
;
}
return
GradientType
:
:
kConical
;
}
sk_sp
<
SkFlattenable
>
SkTwoPointConicalGradient
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
DescriptorScope
desc
;
SkMatrix
legacyLocalMatrix
;
if
(
!
desc
.
unflatten
(
buffer
&
legacyLocalMatrix
)
)
{
return
nullptr
;
}
SkPoint
c1
=
buffer
.
readPoint
(
)
;
SkPoint
c2
=
buffer
.
readPoint
(
)
;
SkScalar
r1
=
buffer
.
readScalar
(
)
;
SkScalar
r2
=
buffer
.
readScalar
(
)
;
if
(
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
SkGradientShader
:
:
MakeTwoPointConical
(
c1
r1
c2
r2
desc
.
fColors
std
:
:
move
(
desc
.
fColorSpace
)
desc
.
fPositions
desc
.
fColorCount
desc
.
fTileMode
desc
.
fInterpolation
&
legacyLocalMatrix
)
;
}
void
SkTwoPointConicalGradient
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkGradientShaderBase
:
:
flatten
(
buffer
)
;
buffer
.
writePoint
(
fCenter1
)
;
buffer
.
writePoint
(
fCenter2
)
;
buffer
.
writeScalar
(
fRadius1
)
;
buffer
.
writeScalar
(
fRadius2
)
;
}
void
SkTwoPointConicalGradient
:
:
appendGradientStages
(
SkArenaAlloc
*
alloc
SkRasterPipeline
*
p
SkRasterPipeline
*
postPipeline
)
const
{
const
auto
dRadius
=
fRadius2
-
fRadius1
;
if
(
fType
=
=
Type
:
:
kRadial
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_radius
)
;
auto
scale
=
std
:
:
max
(
fRadius1
fRadius2
)
/
dRadius
;
auto
bias
=
-
fRadius1
/
dRadius
;
p
-
>
append_matrix
(
alloc
SkMatrix
:
:
Translate
(
bias
0
)
*
SkMatrix
:
:
Scale
(
scale
1
)
)
;
return
;
}
if
(
fType
=
=
Type
:
:
kStrip
)
{
auto
*
ctx
=
alloc
-
>
make
<
SkRasterPipeline_2PtConicalCtx
>
(
)
;
SkScalar
scaledR0
=
fRadius1
/
this
-
>
getCenterX1
(
)
;
ctx
-
>
fP0
=
scaledR0
*
scaledR0
;
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_2pt_conical_strip
ctx
)
;
p
-
>
append
(
SkRasterPipelineOp
:
:
mask_2pt_conical_nan
ctx
)
;
postPipeline
-
>
append
(
SkRasterPipelineOp
:
:
apply_vector_mask
&
ctx
-
>
fMask
)
;
return
;
}
auto
*
ctx
=
alloc
-
>
make
<
SkRasterPipeline_2PtConicalCtx
>
(
)
;
ctx
-
>
fP0
=
1
/
fFocalData
.
fR1
;
ctx
-
>
fP1
=
fFocalData
.
fFocalX
;
if
(
fFocalData
.
isFocalOnCircle
(
)
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_2pt_conical_focal_on_circle
)
;
}
else
if
(
fFocalData
.
isWellBehaved
(
)
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_2pt_conical_well_behaved
ctx
)
;
}
else
if
(
fFocalData
.
isSwapped
(
)
|
|
1
-
fFocalData
.
fFocalX
<
0
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_2pt_conical_smaller
ctx
)
;
}
else
{
p
-
>
append
(
SkRasterPipelineOp
:
:
xy_to_2pt_conical_greater
ctx
)
;
}
if
(
!
fFocalData
.
isWellBehaved
(
)
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
mask_2pt_conical_degenerates
ctx
)
;
}
if
(
1
-
fFocalData
.
fFocalX
<
0
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
negate_x
)
;
}
if
(
!
fFocalData
.
isNativelyFocal
(
)
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
alter_2pt_conical_compensate_focal
ctx
)
;
}
if
(
fFocalData
.
isSwapped
(
)
)
{
p
-
>
append
(
SkRasterPipelineOp
:
:
alter_2pt_conical_unswap
)
;
}
if
(
!
fFocalData
.
isWellBehaved
(
)
)
{
postPipeline
-
>
append
(
SkRasterPipelineOp
:
:
apply_vector_mask
&
ctx
-
>
fMask
)
;
}
}
skvm
:
:
F32
SkTwoPointConicalGradient
:
:
transformT
(
skvm
:
:
Builder
*
p
skvm
:
:
Uniforms
*
uniforms
skvm
:
:
Coord
coord
skvm
:
:
I32
*
mask
)
const
{
auto
mag
=
[
]
(
skvm
:
:
F32
x
skvm
:
:
F32
y
)
{
return
sqrt
(
x
*
x
+
y
*
y
)
;
}
;
const
skvm
:
:
F32
x
=
coord
.
x
y
=
coord
.
y
;
if
(
fType
=
=
Type
:
:
kRadial
)
{
float
denom
=
1
.
0f
/
(
fRadius2
-
fRadius1
)
scale
=
std
:
:
max
(
fRadius1
fRadius2
)
*
denom
bias
=
-
fRadius1
*
denom
;
return
mag
(
x
y
)
*
p
-
>
uniformF
(
uniforms
-
>
pushF
(
scale
)
)
+
p
-
>
uniformF
(
uniforms
-
>
pushF
(
bias
)
)
;
}
if
(
fType
=
=
Type
:
:
kStrip
)
{
float
r
=
fRadius1
/
this
-
>
getCenterX1
(
)
;
skvm
:
:
F32
t
=
x
+
sqrt
(
p
-
>
uniformF
(
uniforms
-
>
pushF
(
r
*
r
)
)
-
y
*
y
)
;
*
mask
=
(
t
=
=
t
)
;
return
t
;
}
const
skvm
:
:
F32
invR1
=
p
-
>
uniformF
(
uniforms
-
>
pushF
(
1
/
fFocalData
.
fR1
)
)
;
skvm
:
:
F32
t
;
if
(
fFocalData
.
isFocalOnCircle
(
)
)
{
t
=
(
y
/
x
)
*
y
+
x
;
}
else
if
(
fFocalData
.
isWellBehaved
(
)
)
{
t
=
mag
(
x
y
)
-
x
*
invR1
;
}
else
{
skvm
:
:
F32
k
=
sqrt
(
x
*
x
-
y
*
y
)
;
if
(
fFocalData
.
isSwapped
(
)
|
|
1
-
fFocalData
.
fFocalX
<
0
)
{
k
=
-
k
;
}
t
=
k
-
x
*
invR1
;
}
if
(
!
fFocalData
.
isWellBehaved
(
)
)
{
*
mask
=
(
t
>
0
.
0f
)
;
}
const
skvm
:
:
F32
focalX
=
p
-
>
uniformF
(
uniforms
-
>
pushF
(
fFocalData
.
fFocalX
)
)
;
if
(
1
-
fFocalData
.
fFocalX
<
0
)
{
t
=
-
t
;
}
if
(
!
fFocalData
.
isNativelyFocal
(
)
)
{
t
+
=
focalX
;
}
if
(
fFocalData
.
isSwapped
(
)
)
{
t
=
1
.
0f
-
t
;
}
return
t
;
}
#
if
defined
(
SK_GANESH
)
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrSkSLFP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gradients
/
GrGradientShader
.
h
"
std
:
:
unique_ptr
<
GrFragmentProcessor
>
SkTwoPointConicalGradient
:
:
asFragmentProcessor
(
const
GrFPArgs
&
args
const
MatrixRec
&
mRec
)
const
{
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
;
SkTLazy
<
SkMatrix
>
matrix
;
switch
(
this
-
>
getType
(
)
)
{
case
SkTwoPointConicalGradient
:
:
Type
:
:
kStrip
:
{
static
const
SkRuntimeEffect
*
kEffect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
half
r0_2
;
"
"
half4
main
(
float2
p
)
{
"
"
half
v
=
1
;
"
"
float
t
=
r0_2
-
p
.
y
*
p
.
y
;
"
"
if
(
t
>
=
0
)
{
"
"
t
=
p
.
x
+
sqrt
(
t
)
;
"
"
}
else
{
"
"
v
=
-
1
;
"
"
}
"
"
return
half4
(
half
(
t
)
v
0
0
)
;
"
"
}
"
)
;
float
r0
=
this
-
>
getStartRadius
(
)
/
this
-
>
getCenterX1
(
)
;
fp
=
GrSkSLFP
:
:
Make
(
kEffect
"
TwoPointConicalStripLayout
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
r0_2
"
r0
*
r0
)
;
}
break
;
case
SkTwoPointConicalGradient
:
:
Type
:
:
kRadial
:
{
static
const
SkRuntimeEffect
*
kEffect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
half
r0
;
"
"
uniform
half
lengthScale
;
"
"
half4
main
(
float2
p
)
{
"
"
half
v
=
1
;
"
"
float
t
=
length
(
p
)
*
lengthScale
-
r0
;
"
"
return
half4
(
half
(
t
)
v
0
0
)
;
"
"
}
"
)
;
float
dr
=
this
-
>
getDiffRadius
(
)
;
float
r0
=
this
-
>
getStartRadius
(
)
/
dr
;
bool
isRadiusIncreasing
=
dr
>
=
0
;
fp
=
GrSkSLFP
:
:
Make
(
kEffect
"
TwoPointConicalRadialLayout
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
r0
"
r0
"
lengthScale
"
isRadiusIncreasing
?
1
.
0f
:
-
1
.
0f
)
;
matrix
.
set
(
SkMatrix
:
:
Translate
(
-
this
-
>
getStartCenter
(
)
.
fX
-
this
-
>
getStartCenter
(
)
.
fY
)
)
;
matrix
-
>
postScale
(
1
/
dr
1
/
dr
)
;
}
break
;
case
SkTwoPointConicalGradient
:
:
Type
:
:
kFocal
:
{
static
const
SkRuntimeEffect
*
kEffect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
int
isRadiusIncreasing
;
"
"
uniform
int
isFocalOnCircle
;
"
"
uniform
int
isWellBehaved
;
"
"
uniform
int
isSwapped
;
"
"
uniform
int
isNativelyFocal
;
"
"
uniform
half
invR1
;
"
"
uniform
half
fx
;
"
"
half4
main
(
float2
p
)
{
"
"
float
t
=
-
1
;
"
"
half
v
=
1
;
"
"
float
x_t
=
-
1
;
"
"
if
(
bool
(
isFocalOnCircle
)
)
{
"
"
x_t
=
dot
(
p
p
)
/
p
.
x
;
"
"
}
else
if
(
bool
(
isWellBehaved
)
)
{
"
"
x_t
=
length
(
p
)
-
p
.
x
*
invR1
;
"
"
}
else
{
"
"
float
temp
=
p
.
x
*
p
.
x
-
p
.
y
*
p
.
y
;
"
"
if
(
temp
>
=
0
)
{
"
"
if
(
bool
(
isSwapped
)
|
|
!
bool
(
isRadiusIncreasing
)
)
{
"
"
x_t
=
-
sqrt
(
temp
)
-
p
.
x
*
invR1
;
"
"
}
else
{
"
"
x_t
=
sqrt
(
temp
)
-
p
.
x
*
invR1
;
"
"
}
"
"
}
"
"
}
"
"
if
(
!
bool
(
isWellBehaved
)
)
{
"
"
if
(
x_t
<
=
0
.
0
)
{
"
"
v
=
-
1
;
"
"
}
"
"
}
"
"
if
(
bool
(
isRadiusIncreasing
)
)
{
"
"
if
(
bool
(
isNativelyFocal
)
)
{
"
"
t
=
x_t
;
"
"
}
else
{
"
"
t
=
x_t
+
fx
;
"
"
}
"
"
}
else
{
"
"
if
(
bool
(
isNativelyFocal
)
)
{
"
"
t
=
-
x_t
;
"
"
}
else
{
"
"
t
=
-
x_t
+
fx
;
"
"
}
"
"
}
"
"
if
(
bool
(
isSwapped
)
)
{
"
"
t
=
1
-
t
;
"
"
}
"
"
return
half4
(
half
(
t
)
v
0
0
)
;
"
"
}
"
)
;
const
SkTwoPointConicalGradient
:
:
FocalData
&
focalData
=
this
-
>
getFocalData
(
)
;
bool
isRadiusIncreasing
=
(
1
-
focalData
.
fFocalX
)
>
0
isFocalOnCircle
=
focalData
.
isFocalOnCircle
(
)
isWellBehaved
=
focalData
.
isWellBehaved
(
)
isSwapped
=
focalData
.
isSwapped
(
)
isNativelyFocal
=
focalData
.
isNativelyFocal
(
)
;
fp
=
GrSkSLFP
:
:
Make
(
kEffect
"
TwoPointConicalFocalLayout
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
isRadiusIncreasing
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isRadiusIncreasing
)
"
isFocalOnCircle
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isFocalOnCircle
)
"
isWellBehaved
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isWellBehaved
)
"
isSwapped
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isSwapped
)
"
isNativelyFocal
"
GrSkSLFP
:
:
Specialize
<
int
>
(
isNativelyFocal
)
"
invR1
"
1
.
0f
/
focalData
.
fR1
"
fx
"
focalData
.
fFocalX
)
;
}
break
;
}
return
GrGradientShader
:
:
MakeGradientFP
(
*
this
args
mRec
std
:
:
move
(
fp
)
matrix
.
getMaybeNull
(
)
)
;
}
#
endif
#
if
defined
(
SK_GRAPHITE
)
void
SkTwoPointConicalGradient
:
:
addToKey
(
const
skgpu
:
:
graphite
:
:
KeyContext
&
keyContext
skgpu
:
:
graphite
:
:
PaintParamsKeyBuilder
*
builder
skgpu
:
:
graphite
:
:
PipelineDataGatherer
*
gatherer
)
const
{
using
namespace
skgpu
:
:
graphite
;
SkColor4fXformer
xformedColors
(
this
keyContext
.
dstColorInfo
(
)
.
colorSpace
(
)
)
;
const
SkPMColor4f
*
colors
=
xformedColors
.
fColors
.
begin
(
)
;
GradientShaderBlocks
:
:
GradientData
data
(
GradientType
:
:
kConical
fCenter1
fCenter2
fRadius1
fRadius2
0
.
0f
0
.
0f
fTileMode
fColorCount
colors
fPositions
fInterpolation
)
;
MakeInterpolatedToDst
(
keyContext
builder
gatherer
data
fInterpolation
xformedColors
.
fIntermediateColorSpace
.
get
(
)
)
;
}
#
endif
#
define
EXPAND_1_COLOR
(
count
)
\
SkColor4f
tmp
[
2
]
;
\
do
{
\
if
(
1
=
=
count
)
{
\
tmp
[
0
]
=
tmp
[
1
]
=
colors
[
0
]
;
\
colors
=
tmp
;
\
pos
=
nullptr
;
\
count
=
2
;
\
}
\
}
while
(
0
)
sk_sp
<
SkShader
>
SkGradientShader
:
:
MakeTwoPointConical
(
const
SkPoint
&
start
SkScalar
startRadius
const
SkPoint
&
end
SkScalar
endRadius
const
SkColor4f
colors
[
]
sk_sp
<
SkColorSpace
>
colorSpace
const
SkScalar
pos
[
]
int
colorCount
SkTileMode
mode
const
Interpolation
&
interpolation
const
SkMatrix
*
localMatrix
)
{
if
(
startRadius
<
0
|
|
endRadius
<
0
)
{
return
nullptr
;
}
if
(
!
SkGradientShaderBase
:
:
ValidGradient
(
colors
colorCount
mode
interpolation
)
)
{
return
nullptr
;
}
if
(
SkScalarNearlyZero
(
(
start
-
end
)
.
length
(
)
SkGradientShaderBase
:
:
kDegenerateThreshold
)
)
{
if
(
SkScalarNearlyEqual
(
startRadius
endRadius
SkGradientShaderBase
:
:
kDegenerateThreshold
)
)
{
if
(
mode
=
=
SkTileMode
:
:
kClamp
&
&
endRadius
>
SkGradientShaderBase
:
:
kDegenerateThreshold
)
{
static
constexpr
SkScalar
circlePos
[
3
]
=
{
0
1
1
}
;
SkColor4f
reColors
[
3
]
=
{
colors
[
0
]
colors
[
0
]
colors
[
colorCount
-
1
]
}
;
return
MakeRadial
(
start
endRadius
reColors
std
:
:
move
(
colorSpace
)
circlePos
3
mode
interpolation
localMatrix
)
;
}
else
{
return
SkGradientShaderBase
:
:
MakeDegenerateGradient
(
colors
pos
colorCount
std
:
:
move
(
colorSpace
)
mode
)
;
}
}
else
if
(
SkScalarNearlyZero
(
startRadius
SkGradientShaderBase
:
:
kDegenerateThreshold
)
)
{
return
MakeRadial
(
start
endRadius
colors
std
:
:
move
(
colorSpace
)
pos
colorCount
mode
interpolation
localMatrix
)
;
}
}
if
(
localMatrix
&
&
!
localMatrix
-
>
invert
(
nullptr
)
)
{
return
nullptr
;
}
EXPAND_1_COLOR
(
colorCount
)
;
SkGradientShaderBase
:
:
ColorStopOptimizer
opt
(
colors
pos
colorCount
mode
)
;
SkGradientShaderBase
:
:
Descriptor
desc
(
opt
.
fColors
std
:
:
move
(
colorSpace
)
opt
.
fPos
opt
.
fCount
mode
interpolation
)
;
return
SkTwoPointConicalGradient
:
:
Create
(
start
startRadius
end
endRadius
desc
localMatrix
)
;
}
#
undef
EXPAND_1_COLOR
sk_sp
<
SkShader
>
SkGradientShader
:
:
MakeTwoPointConical
(
const
SkPoint
&
start
SkScalar
startRadius
const
SkPoint
&
end
SkScalar
endRadius
const
SkColor
colors
[
]
const
SkScalar
pos
[
]
int
colorCount
SkTileMode
mode
uint32_t
flags
const
SkMatrix
*
localMatrix
)
{
SkColorConverter
converter
(
colors
colorCount
)
;
return
MakeTwoPointConical
(
start
startRadius
end
endRadius
converter
.
fColors4f
.
begin
(
)
nullptr
pos
colorCount
mode
flags
localMatrix
)
;
}
void
SkRegisterTwoPointConicalGradientShaderFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkTwoPointConicalGradient
)
;
}
