#
ifndef
SkGradientShaderPriv_DEFINED
#
define
SkGradientShaderPriv_DEFINED
#
include
"
SkGradientShader
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkShaderBase
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTemplates
.
h
"
class
SkColorSpace
;
class
SkColorSpaceXformer
;
class
SkRasterPipeline
;
class
SkReadBuffer
;
class
SkWriteBuffer
;
class
SkGradientShaderBase
:
public
SkShaderBase
{
public
:
struct
Descriptor
{
Descriptor
(
)
{
sk_bzero
(
this
sizeof
(
*
this
)
)
;
fTileMode
=
SkShader
:
:
kClamp_TileMode
;
}
const
SkMatrix
*
fLocalMatrix
;
const
SkColor4f
*
fColors
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
const
SkScalar
*
fPos
;
int
fCount
;
SkShader
:
:
TileMode
fTileMode
;
uint32_t
fGradFlags
;
void
flatten
(
SkWriteBuffer
&
)
const
;
}
;
class
DescriptorScope
:
public
Descriptor
{
public
:
DescriptorScope
(
)
{
}
bool
unflatten
(
SkReadBuffer
&
)
;
SkColor4f
*
mutableColors
(
)
{
return
const_cast
<
SkColor4f
*
>
(
fColors
)
;
}
SkScalar
*
mutablePos
(
)
{
return
const_cast
<
SkScalar
*
>
(
fPos
)
;
}
private
:
enum
{
kStorageCount
=
16
}
;
SkColor4f
fColorStorage
[
kStorageCount
]
;
SkScalar
fPosStorage
[
kStorageCount
]
;
SkMatrix
fLocalMatrixStorage
;
SkAutoMalloc
fDynamicStorage
;
}
;
SkGradientShaderBase
(
const
Descriptor
&
desc
const
SkMatrix
&
ptsToUnit
)
;
~
SkGradientShaderBase
(
)
override
;
bool
isOpaque
(
)
const
override
;
enum
class
GradientBitmapType
:
uint8_t
{
kLegacy
kSRGB
kHalfFloat
}
;
void
getGradientTableBitmap
(
SkBitmap
*
GradientBitmapType
bitmapType
)
const
;
uint32_t
getGradFlags
(
)
const
{
return
fGradFlags
;
}
SkColor4f
getXformedColor
(
size_t
index
SkColorSpace
*
)
const
;
protected
:
class
GradientShaderBase4fContext
;
SkGradientShaderBase
(
SkReadBuffer
&
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
SK_TO_STRING_OVERRIDE
(
)
void
commonAsAGradient
(
GradientInfo
*
)
const
;
bool
onAsLuminanceColor
(
SkColor
*
)
const
override
;
void
initLinearBitmap
(
SkBitmap
*
bitmap
GradientBitmapType
)
const
;
bool
onAppendStages
(
const
StageRec
&
)
const
override
;
bool
onIsRasterPipelineOnly
(
const
SkMatrix
&
ctm
)
const
override
;
virtual
void
appendGradientStages
(
SkArenaAlloc
*
alloc
SkRasterPipeline
*
tPipeline
SkRasterPipeline
*
postPipeline
)
const
=
0
;
template
<
typename
T
typename
.
.
.
Args
>
static
Context
*
CheckedMakeContext
(
SkArenaAlloc
*
alloc
Args
&
&
.
.
.
args
)
{
auto
*
ctx
=
alloc
-
>
make
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
ctx
-
>
isValid
(
)
)
{
return
nullptr
;
}
return
ctx
;
}
struct
AutoXformColors
{
AutoXformColors
(
const
SkGradientShaderBase
&
SkColorSpaceXformer
*
)
;
SkAutoSTMalloc
<
8
SkColor
>
fColors
;
}
;
const
SkMatrix
fPtsToUnit
;
TileMode
fTileMode
;
uint8_t
fGradFlags
;
public
:
SkScalar
getPos
(
int
i
)
const
{
SkASSERT
(
i
<
fColorCount
)
;
return
fOrigPos
?
fOrigPos
[
i
]
:
SkIntToScalar
(
i
)
/
(
fColorCount
-
1
)
;
}
SkColor
getLegacyColor
(
int
i
)
const
{
SkASSERT
(
i
<
fColorCount
)
;
return
fOrigColors4f
[
i
]
.
toSkColor
(
)
;
}
SkColor4f
*
fOrigColors4f
;
SkScalar
*
fOrigPos
;
int
fColorCount
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
bool
colorsAreOpaque
(
)
const
{
return
fColorsAreOpaque
;
}
TileMode
getTileMode
(
)
const
{
return
fTileMode
;
}
private
:
static
constexpr
size_t
kInlineStopCount
=
4
;
static
constexpr
size_t
kInlineStorageSize
=
(
sizeof
(
SkColor4f
)
+
sizeof
(
SkScalar
)
)
*
kInlineStopCount
;
SkAutoSTMalloc
<
kInlineStorageSize
uint8_t
>
fStorage
;
bool
fColorsAreOpaque
;
typedef
SkShaderBase
INHERITED
;
}
;
#
if
SK_SUPPORT_GPU
#
include
"
GrColorSpaceInfo
.
h
"
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrInvariantOutput
;
class
GrTextureStripAtlas
;
class
GrGradientEffect
:
public
GrFragmentProcessor
{
public
:
struct
CreateArgs
{
CreateArgs
(
GrContext
*
context
const
SkGradientShaderBase
*
shader
const
SkMatrix
*
matrix
SkShader
:
:
TileMode
tileMode
SkColorSpace
*
dstColorSpace
)
:
fContext
(
context
)
fShader
(
shader
)
fMatrix
(
matrix
)
fDstColorSpace
(
dstColorSpace
)
{
switch
(
tileMode
)
{
case
SkShader
:
:
kClamp_TileMode
:
fWrapMode
=
GrSamplerState
:
:
WrapMode
:
:
kClamp
;
break
;
case
SkShader
:
:
kRepeat_TileMode
:
fWrapMode
=
GrSamplerState
:
:
WrapMode
:
:
kRepeat
;
break
;
case
SkShader
:
:
kMirror_TileMode
:
fWrapMode
=
GrSamplerState
:
:
WrapMode
:
:
kMirrorRepeat
;
break
;
case
SkShader
:
:
kDecal_TileMode
:
fWrapMode
=
GrSamplerState
:
:
WrapMode
:
:
kClamp
;
break
;
}
}
CreateArgs
(
GrContext
*
context
const
SkGradientShaderBase
*
shader
const
SkMatrix
*
matrix
GrSamplerState
:
:
WrapMode
wrapMode
SkColorSpace
*
dstColorSpace
)
:
fContext
(
context
)
fShader
(
shader
)
fMatrix
(
matrix
)
fWrapMode
(
wrapMode
)
fDstColorSpace
(
dstColorSpace
)
{
}
GrContext
*
fContext
;
const
SkGradientShaderBase
*
fShader
;
const
SkMatrix
*
fMatrix
;
GrSamplerState
:
:
WrapMode
fWrapMode
;
SkColorSpace
*
fDstColorSpace
;
}
;
class
GLSLProcessor
;
~
GrGradientEffect
(
)
override
;
bool
useAtlas
(
)
const
{
return
SkToBool
(
-
1
!
=
fRow
)
;
}
enum
class
InterpolationStrategy
:
uint8_t
{
kSingle
kThreshold
kThresholdClamp0
kThresholdClamp1
kTexture
}
;
enum
PremulType
{
kBeforeInterp_PremulType
kAfterInterp_PremulType
}
;
protected
:
GrGradientEffect
(
ClassID
classID
const
CreateArgs
&
bool
isOpaque
)
;
explicit
GrGradientEffect
(
const
GrGradientEffect
&
)
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
AdjustFP
(
std
:
:
unique_ptr
<
GrGradientEffect
>
gradientFP
const
CreateArgs
&
args
)
{
if
(
!
gradientFP
-
>
isValid
(
)
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
;
if
(
gradientFP
-
>
fStrategy
=
=
InterpolationStrategy
:
:
kTexture
)
{
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
gradientFP
)
args
.
fShader
-
>
fColorSpace
.
get
(
)
kRGBA_float_GrPixelConfig
args
.
fDstColorSpace
)
;
}
else
{
fp
=
std
:
:
move
(
gradientFP
)
;
}
return
GrFragmentProcessor
:
:
MulChildByInputAlpha
(
std
:
:
move
(
fp
)
)
;
}
#
if
GR_TEST_UTILS
struct
RandomGradientParams
{
static
constexpr
int
kMaxRandomGradientColors
=
5
;
RandomGradientParams
(
SkRandom
*
r
)
;
bool
fUseColors4f
;
SkColor
fColors
[
kMaxRandomGradientColors
]
;
SkColor4f
fColors4f
[
kMaxRandomGradientColors
]
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
SkScalar
fStopStorage
[
kMaxRandomGradientColors
]
;
SkShader
:
:
TileMode
fTileMode
;
int
fColorCount
;
SkScalar
*
fStops
;
}
;
#
endif
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
GrCoordTransform
&
getCoordTransform
(
)
const
{
return
fCoordTransform
;
}
bool
isValid
(
)
const
{
return
fStrategy
!
=
InterpolationStrategy
:
:
kTexture
|
|
fTextureSampler
.
isInitialized
(
)
;
}
private
:
void
addInterval
(
const
SkGradientShaderBase
&
size_t
idx0
size_t
idx1
SkColorSpace
*
)
;
static
OptimizationFlags
OptFlags
(
bool
isOpaque
)
;
SkSTArray
<
4
GrColor4f
true
>
fIntervals
;
GrSamplerState
:
:
WrapMode
fWrapMode
;
GrCoordTransform
fCoordTransform
;
TextureSampler
fTextureSampler
;
SkScalar
fYCoord
;
GrTextureStripAtlas
*
fAtlas
;
int
fRow
;
bool
fIsOpaque
;
InterpolationStrategy
fStrategy
;
SkScalar
fThreshold
;
PremulType
fPremulType
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
class
GrGradientEffect
:
:
GLSLProcessor
:
public
GrGLSLFragmentProcessor
{
public
:
GLSLProcessor
(
)
{
fCachedYCoord
=
SK_ScalarMax
;
}
static
uint32_t
GenBaseGradientKey
(
const
GrProcessor
&
)
;
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
override
;
void
emitUniforms
(
GrGLSLUniformHandler
*
const
GrGradientEffect
&
)
;
void
emitColor
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
shaderCaps
const
GrGradientEffect
&
const
char
*
gradientTValue
const
char
*
outputColor
const
char
*
inputColor
const
TextureSamplers
&
)
;
private
:
void
emitAnalyticalColor
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
shaderCaps
const
GrGradientEffect
&
const
char
*
gradientTValue
const
char
*
outputColor
const
char
*
inputColor
)
;
SkScalar
fCachedYCoord
;
GrGLSLProgramDataManager
:
:
UniformHandle
fIntervalsUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fThresholdUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fFSYUni
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
#
endif
#
endif
