#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkRasterPipeline
.
h
"
#
include
"
src
/
shaders
/
SkTransformShader
.
h
"
SkTransformShader
:
:
SkTransformShader
(
const
SkShaderBase
&
shader
bool
allowPerspective
)
:
fShader
{
shader
}
fAllowPerspective
{
allowPerspective
}
{
SkMatrix
:
:
I
(
)
.
get9
(
fMatrixStorage
)
;
}
skvm
:
:
Color
SkTransformShader
:
:
program
(
skvm
:
:
Builder
*
b
skvm
:
:
Coord
device
skvm
:
:
Coord
local
skvm
:
:
Color
color
const
MatrixRec
&
mRec
const
SkColorInfo
&
dst
skvm
:
:
Uniforms
*
uniforms
SkArenaAlloc
*
alloc
)
const
{
SkASSERT
(
!
mRec
.
hasPendingMatrix
(
)
)
;
std
:
:
optional
<
MatrixRec
>
childMRec
=
mRec
.
apply
(
b
&
local
uniforms
)
;
if
(
!
childMRec
.
has_value
(
)
)
{
return
{
}
;
}
childMRec
-
>
markTotalMatrixInvalid
(
)
;
auto
matrix
=
uniforms
-
>
pushPtr
(
&
fMatrixStorage
)
;
skvm
:
:
F32
x
=
local
.
x
y
=
local
.
y
;
auto
dot
=
[
&
x
y
]
(
int
row
)
{
return
b
-
>
mad
(
x
b
-
>
arrayF
(
matrix
3
*
row
+
0
)
b
-
>
mad
(
y
b
-
>
arrayF
(
matrix
3
*
row
+
1
)
b
-
>
arrayF
(
matrix
3
*
row
+
2
)
)
)
;
}
;
x
=
dot
(
0
)
;
y
=
dot
(
1
)
;
if
(
fAllowPerspective
)
{
x
=
x
*
(
1
.
0f
/
dot
(
2
)
)
;
y
=
y
*
(
1
.
0f
/
dot
(
2
)
)
;
}
skvm
:
:
Coord
newLocal
=
{
x
y
}
;
return
fShader
.
program
(
b
device
newLocal
color
*
childMRec
dst
uniforms
alloc
)
;
}
bool
SkTransformShader
:
:
update
(
const
SkMatrix
&
matrix
)
{
if
(
SkMatrix
inv
;
matrix
.
invert
(
&
inv
)
)
{
if
(
!
fAllowPerspective
&
&
inv
.
hasPerspective
(
)
)
{
return
false
;
}
inv
.
get9
(
fMatrixStorage
)
;
return
true
;
}
return
false
;
}
bool
SkTransformShader
:
:
appendStages
(
const
SkStageRec
&
rec
const
MatrixRec
&
mRec
)
const
{
SkASSERT
(
!
mRec
.
hasPendingMatrix
(
)
)
;
std
:
:
optional
<
MatrixRec
>
childMRec
=
mRec
.
apply
(
rec
)
;
if
(
!
childMRec
.
has_value
(
)
)
{
return
false
;
}
childMRec
-
>
markTotalMatrixInvalid
(
)
;
auto
type
=
fAllowPerspective
?
SkRasterPipelineOp
:
:
matrix_perspective
:
SkRasterPipelineOp
:
:
matrix_2x3
;
rec
.
fPipeline
-
>
append
(
type
fMatrixStorage
)
;
fShader
.
appendStages
(
rec
*
childMRec
)
;
return
true
;
}
