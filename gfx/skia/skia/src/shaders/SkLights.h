#
ifndef
SkLights_DEFINED
#
define
SkLights_DEFINED
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
class
SkReadBuffer
;
class
SkWriteBuffer
;
class
SK_API
SkLights
:
public
SkRefCnt
{
public
:
class
Light
{
public
:
enum
LightType
{
kDirectional_LightType
kPoint_LightType
}
;
Light
(
const
Light
&
other
)
:
fType
(
other
.
fType
)
fColor
(
other
.
fColor
)
fDirOrPos
(
other
.
fDirOrPos
)
fIntensity
(
other
.
fIntensity
)
{
}
Light
(
Light
&
&
other
)
:
fType
(
other
.
fType
)
fColor
(
other
.
fColor
)
fDirOrPos
(
other
.
fDirOrPos
)
fIntensity
(
other
.
fIntensity
)
{
}
static
Light
MakeDirectional
(
const
SkColor3f
&
color
const
SkVector3
&
dir
)
{
Light
light
(
kDirectional_LightType
color
dir
0
.
0f
)
;
if
(
!
light
.
fDirOrPos
.
normalize
(
)
)
{
light
.
fDirOrPos
.
set
(
0
.
0f
0
.
0f
1
.
0f
)
;
}
return
light
;
}
static
Light
MakePoint
(
const
SkColor3f
&
color
const
SkPoint3
&
pos
SkScalar
intensity
)
{
return
Light
(
kPoint_LightType
color
pos
intensity
)
;
}
LightType
type
(
)
const
{
return
fType
;
}
const
SkColor3f
&
color
(
)
const
{
return
fColor
;
}
const
SkVector3
&
dir
(
)
const
{
SkASSERT
(
kDirectional_LightType
=
=
fType
)
;
return
fDirOrPos
;
}
const
SkPoint3
&
pos
(
)
const
{
SkASSERT
(
kPoint_LightType
=
=
fType
)
;
return
fDirOrPos
;
}
SkScalar
intensity
(
)
const
{
SkASSERT
(
kPoint_LightType
=
=
fType
)
;
return
fIntensity
;
}
Light
&
operator
=
(
const
Light
&
other
)
{
if
(
this
=
=
&
other
)
{
return
*
this
;
}
fType
=
other
.
fType
;
fColor
=
other
.
fColor
;
fDirOrPos
=
other
.
fDirOrPos
;
fIntensity
=
other
.
fIntensity
;
return
*
this
;
}
bool
operator
=
=
(
const
Light
&
other
)
{
return
(
fType
=
=
other
.
fType
)
&
&
(
fColor
=
=
other
.
fColor
)
&
&
(
fDirOrPos
=
=
other
.
fDirOrPos
)
&
&
(
fIntensity
=
=
other
.
fIntensity
)
;
}
bool
operator
!
=
(
const
Light
&
other
)
{
return
!
(
this
-
>
operator
=
=
(
other
)
)
;
}
private
:
friend
class
SkLights
;
Light
(
LightType
type
const
SkColor3f
&
color
const
SkVector3
&
dirOrPos
SkScalar
intensity
)
:
fType
(
type
)
fColor
(
color
)
fDirOrPos
(
dirOrPos
)
fIntensity
(
intensity
)
{
}
LightType
fType
;
SkColor3f
fColor
;
SkVector3
fDirOrPos
;
SkScalar
fIntensity
;
}
;
class
Builder
{
public
:
Builder
(
)
:
fLights
(
new
SkLights
)
{
}
void
add
(
const
Light
&
light
)
{
if
(
fLights
)
{
fLights
-
>
fLights
.
push_back
(
light
)
;
}
}
void
add
(
Light
&
&
light
)
{
if
(
fLights
)
{
fLights
-
>
fLights
.
push_back
(
std
:
:
move
(
light
)
)
;
}
}
void
setAmbientLightColor
(
const
SkColor3f
&
color
)
{
if
(
fLights
)
{
fLights
-
>
fAmbientLightColor
=
color
;
}
}
sk_sp
<
SkLights
>
finish
(
)
{
return
std
:
:
move
(
fLights
)
;
}
private
:
sk_sp
<
SkLights
>
fLights
;
}
;
int
numLights
(
)
const
{
return
fLights
.
count
(
)
;
}
const
Light
&
light
(
int
index
)
const
{
return
fLights
[
index
]
;
}
const
SkColor3f
&
ambientLightColor
(
)
const
{
return
fAmbientLightColor
;
}
static
sk_sp
<
SkLights
>
MakeFromBuffer
(
SkReadBuffer
&
buf
)
;
void
flatten
(
SkWriteBuffer
&
buf
)
const
;
private
:
friend
class
SkLightingShaderImpl
;
SkLights
(
)
:
fAmbientLightColor
(
SkColor3f
:
:
Make
(
0
.
0f
0
.
0f
0
.
0f
)
)
{
}
SkTArray
<
Light
>
fLights
;
SkColor3f
fAmbientLightColor
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
