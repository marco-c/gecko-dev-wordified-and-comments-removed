#
ifndef
SkTLazy_DEFINED
#
define
SkTLazy_DEFINED
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
<
optional
>
#
include
<
utility
>
template
<
typename
T
>
class
SkTLazy
{
public
:
SkTLazy
(
)
=
default
;
explicit
SkTLazy
(
const
T
*
src
)
:
fValue
(
src
?
std
:
:
optional
<
T
>
(
*
src
)
:
std
:
:
nullopt
)
{
}
SkTLazy
(
const
SkTLazy
&
that
)
:
fValue
(
that
.
fValue
)
{
}
SkTLazy
(
SkTLazy
&
&
that
)
:
fValue
(
std
:
:
move
(
that
.
fValue
)
)
{
}
~
SkTLazy
(
)
=
default
;
SkTLazy
&
operator
=
(
const
SkTLazy
&
that
)
{
fValue
=
that
.
fValue
;
return
*
this
;
}
SkTLazy
&
operator
=
(
SkTLazy
&
&
that
)
{
fValue
=
std
:
:
move
(
that
.
fValue
)
;
return
*
this
;
}
template
<
typename
.
.
.
Args
>
T
*
init
(
Args
&
&
.
.
.
args
)
{
fValue
.
emplace
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
this
-
>
get
(
)
;
}
T
*
set
(
const
T
&
src
)
{
fValue
=
src
;
return
this
-
>
get
(
)
;
}
T
*
set
(
T
&
&
src
)
{
fValue
=
std
:
:
move
(
src
)
;
return
this
-
>
get
(
)
;
}
void
reset
(
)
{
fValue
.
reset
(
)
;
}
bool
isValid
(
)
const
{
return
fValue
.
has_value
(
)
;
}
T
*
get
(
)
{
SkASSERT
(
fValue
.
has_value
(
)
)
;
return
&
fValue
.
value
(
)
;
}
const
T
*
get
(
)
const
{
SkASSERT
(
fValue
.
has_value
(
)
)
;
return
&
fValue
.
value
(
)
;
}
T
*
operator
-
>
(
)
{
return
this
-
>
get
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
this
-
>
get
(
)
;
}
T
&
operator
*
(
)
{
SkASSERT
(
fValue
.
has_value
(
)
)
;
return
*
fValue
;
}
const
T
&
operator
*
(
)
const
{
SkASSERT
(
fValue
.
has_value
(
)
)
;
return
*
fValue
;
}
const
T
*
getMaybeNull
(
)
const
{
return
fValue
.
has_value
(
)
?
this
-
>
get
(
)
:
nullptr
;
}
T
*
getMaybeNull
(
)
{
return
fValue
.
has_value
(
)
?
this
-
>
get
(
)
:
nullptr
;
}
private
:
std
:
:
optional
<
T
>
fValue
;
}
;
template
<
typename
T
>
class
SkTCopyOnFirstWrite
{
public
:
explicit
SkTCopyOnFirstWrite
(
const
T
&
initial
)
:
fObj
(
&
initial
)
{
}
explicit
SkTCopyOnFirstWrite
(
const
T
*
initial
)
:
fObj
(
initial
)
{
}
SkTCopyOnFirstWrite
(
)
:
fObj
(
nullptr
)
{
}
SkTCopyOnFirstWrite
(
const
SkTCopyOnFirstWrite
&
that
)
{
*
this
=
that
;
}
SkTCopyOnFirstWrite
(
SkTCopyOnFirstWrite
&
&
that
)
{
*
this
=
std
:
:
move
(
that
)
;
}
SkTCopyOnFirstWrite
&
operator
=
(
const
SkTCopyOnFirstWrite
&
that
)
{
fLazy
=
that
.
fLazy
;
fObj
=
fLazy
.
has_value
(
)
?
&
fLazy
.
value
(
)
:
that
.
fObj
;
return
*
this
;
}
SkTCopyOnFirstWrite
&
operator
=
(
SkTCopyOnFirstWrite
&
&
that
)
{
fLazy
=
std
:
:
move
(
that
.
fLazy
)
;
fObj
=
fLazy
.
has_value
(
)
?
&
fLazy
.
value
(
)
:
that
.
fObj
;
return
*
this
;
}
void
init
(
const
T
&
initial
)
{
SkASSERT
(
!
fObj
)
;
SkASSERT
(
!
fLazy
.
has_value
(
)
)
;
fObj
=
&
initial
;
}
template
<
typename
.
.
.
Args
>
void
initIfNeeded
(
Args
&
&
.
.
.
args
)
{
if
(
!
fObj
)
{
SkASSERT
(
!
fLazy
.
has_value
(
)
)
;
fObj
=
&
fLazy
.
emplace
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
T
*
writable
(
)
{
SkASSERT
(
fObj
)
;
if
(
!
fLazy
.
has_value
(
)
)
{
fLazy
=
*
fObj
;
fObj
=
&
fLazy
.
value
(
)
;
}
return
&
fLazy
.
value
(
)
;
}
const
T
*
get
(
)
const
{
return
fObj
;
}
const
T
*
operator
-
>
(
)
const
{
return
fObj
;
}
operator
const
T
*
(
)
const
{
return
fObj
;
}
const
T
&
operator
*
(
)
const
{
return
*
fObj
;
}
private
:
const
T
*
fObj
;
std
:
:
optional
<
T
>
fLazy
;
}
;
#
endif
