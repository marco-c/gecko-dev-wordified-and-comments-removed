#
ifndef
SkTSort_DEFINED
#
define
SkTSort_DEFINED
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
<
cstddef
>
#
include
<
utility
>
template
<
typename
T
typename
C
>
void
SkTHeapSort_SiftUp
(
T
array
[
]
size_t
root
size_t
bottom
const
C
&
lessThan
)
{
T
x
=
array
[
root
-
1
]
;
size_t
start
=
root
;
size_t
j
=
root
<
<
1
;
while
(
j
<
=
bottom
)
{
if
(
j
<
bottom
&
&
lessThan
(
array
[
j
-
1
]
array
[
j
]
)
)
{
+
+
j
;
}
array
[
root
-
1
]
=
array
[
j
-
1
]
;
root
=
j
;
j
=
root
<
<
1
;
}
j
=
root
>
>
1
;
while
(
j
>
=
start
)
{
if
(
lessThan
(
array
[
j
-
1
]
x
)
)
{
array
[
root
-
1
]
=
array
[
j
-
1
]
;
root
=
j
;
j
=
root
>
>
1
;
}
else
{
break
;
}
}
array
[
root
-
1
]
=
x
;
}
template
<
typename
T
typename
C
>
void
SkTHeapSort_SiftDown
(
T
array
[
]
size_t
root
size_t
bottom
const
C
&
lessThan
)
{
T
x
=
array
[
root
-
1
]
;
size_t
child
=
root
<
<
1
;
while
(
child
<
=
bottom
)
{
if
(
child
<
bottom
&
&
lessThan
(
array
[
child
-
1
]
array
[
child
]
)
)
{
+
+
child
;
}
if
(
lessThan
(
x
array
[
child
-
1
]
)
)
{
array
[
root
-
1
]
=
array
[
child
-
1
]
;
root
=
child
;
child
=
root
<
<
1
;
}
else
{
break
;
}
}
array
[
root
-
1
]
=
x
;
}
template
<
typename
T
typename
C
>
void
SkTHeapSort
(
T
array
[
]
size_t
count
const
C
&
lessThan
)
{
for
(
size_t
i
=
count
>
>
1
;
i
>
0
;
-
-
i
)
{
SkTHeapSort_SiftDown
(
array
i
count
lessThan
)
;
}
for
(
size_t
i
=
count
-
1
;
i
>
0
;
-
-
i
)
{
using
std
:
:
swap
;
swap
(
array
[
0
]
array
[
i
]
)
;
SkTHeapSort_SiftUp
(
array
1
i
lessThan
)
;
}
}
template
<
typename
T
>
void
SkTHeapSort
(
T
array
[
]
size_t
count
)
{
SkTHeapSort
(
array
count
[
]
(
const
T
&
a
const
T
&
b
)
{
return
a
<
b
;
}
)
;
}
template
<
typename
T
typename
C
>
void
SkTInsertionSort
(
T
*
left
int
count
const
C
&
lessThan
)
{
T
*
right
=
left
+
count
-
1
;
for
(
T
*
next
=
left
+
1
;
next
<
=
right
;
+
+
next
)
{
if
(
!
lessThan
(
*
next
*
(
next
-
1
)
)
)
{
continue
;
}
T
insert
=
std
:
:
move
(
*
next
)
;
T
*
hole
=
next
;
do
{
*
hole
=
std
:
:
move
(
*
(
hole
-
1
)
)
;
-
-
hole
;
}
while
(
left
<
hole
&
&
lessThan
(
insert
*
(
hole
-
1
)
)
)
;
*
hole
=
std
:
:
move
(
insert
)
;
}
}
template
<
typename
T
typename
C
>
T
*
SkTQSort_Partition
(
T
*
left
int
count
T
*
pivot
const
C
&
lessThan
)
{
T
*
right
=
left
+
count
-
1
;
using
std
:
:
swap
;
T
pivotValue
=
*
pivot
;
swap
(
*
pivot
*
right
)
;
T
*
newPivot
=
left
;
while
(
left
<
right
)
{
if
(
lessThan
(
*
left
pivotValue
)
)
{
swap
(
*
left
*
newPivot
)
;
newPivot
+
=
1
;
}
left
+
=
1
;
}
swap
(
*
newPivot
*
right
)
;
return
newPivot
;
}
template
<
typename
T
typename
C
>
void
SkTIntroSort
(
int
depth
T
*
left
int
count
const
C
&
lessThan
)
{
for
(
;
;
)
{
if
(
count
<
=
32
)
{
SkTInsertionSort
(
left
count
lessThan
)
;
return
;
}
if
(
depth
=
=
0
)
{
SkTHeapSort
<
T
>
(
left
count
lessThan
)
;
return
;
}
-
-
depth
;
T
*
middle
=
left
+
(
(
count
-
1
)
>
>
1
)
;
T
*
pivot
=
SkTQSort_Partition
(
left
count
middle
lessThan
)
;
int
pivotCount
=
pivot
-
left
;
SkTIntroSort
(
depth
left
pivotCount
lessThan
)
;
left
+
=
pivotCount
+
1
;
count
-
=
pivotCount
+
1
;
}
}
template
<
typename
T
typename
C
>
void
SkTQSort
(
T
*
begin
T
*
end
const
C
&
lessThan
)
{
int
n
=
SkToInt
(
end
-
begin
)
;
if
(
n
<
=
1
)
{
return
;
}
int
depth
=
2
*
SkNextLog2
(
n
-
1
)
;
SkTIntroSort
(
depth
begin
n
lessThan
)
;
}
template
<
typename
T
>
void
SkTQSort
(
T
*
begin
T
*
end
)
{
SkTQSort
(
begin
end
[
]
(
const
T
&
a
const
T
&
b
)
{
return
a
<
b
;
}
)
;
}
template
<
typename
T
>
void
SkTQSort
(
T
*
*
begin
T
*
*
end
)
{
SkTQSort
(
begin
end
[
]
(
const
T
*
a
const
T
*
b
)
{
return
*
a
<
*
b
;
}
)
;
}
#
endif
