#
ifndef
SkAutoMalloc_DEFINED
#
define
SkAutoMalloc_DEFINED
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
class
SkAutoMalloc
:
SkNoncopyable
{
public
:
explicit
SkAutoMalloc
(
size_t
size
=
0
)
:
fPtr
(
size
?
sk_malloc_throw
(
size
)
:
nullptr
)
fSize
(
size
)
{
}
enum
OnShrink
{
kAlloc_OnShrink
kReuse_OnShrink
}
;
void
*
reset
(
size_t
size
=
0
OnShrink
shrink
=
kAlloc_OnShrink
)
{
if
(
size
!
=
fSize
&
&
(
size
>
fSize
|
|
kReuse_OnShrink
!
=
shrink
)
)
{
fPtr
.
reset
(
size
?
sk_malloc_throw
(
size
)
:
nullptr
)
;
fSize
=
size
;
}
return
fPtr
.
get
(
)
;
}
void
*
get
(
)
{
return
fPtr
.
get
(
)
;
}
const
void
*
get
(
)
const
{
return
fPtr
.
get
(
)
;
}
void
*
release
(
)
{
fSize
=
0
;
return
fPtr
.
release
(
)
;
}
private
:
struct
WrapFree
{
void
operator
(
)
(
void
*
p
)
{
sk_free
(
p
)
;
}
}
;
std
:
:
unique_ptr
<
void
WrapFree
>
fPtr
;
size_t
fSize
;
}
;
template
<
size_t
kSizeRequested
>
class
SkAutoSMalloc
:
SkNoncopyable
{
public
:
SkAutoSMalloc
(
)
{
fPtr
=
fStorage
;
fSize
=
kSize
;
}
explicit
SkAutoSMalloc
(
size_t
size
)
{
fPtr
=
fStorage
;
fSize
=
kSize
;
this
-
>
reset
(
size
)
;
}
~
SkAutoSMalloc
(
)
{
if
(
fPtr
!
=
(
void
*
)
fStorage
)
{
sk_free
(
fPtr
)
;
}
}
void
*
get
(
)
const
{
return
fPtr
;
}
void
*
reset
(
size_t
size
SkAutoMalloc
:
:
OnShrink
shrink
=
SkAutoMalloc
:
:
kAlloc_OnShrink
bool
*
didChangeAlloc
=
nullptr
)
{
size
=
(
size
<
kSize
)
?
kSize
:
size
;
bool
alloc
=
size
!
=
fSize
&
&
(
SkAutoMalloc
:
:
kAlloc_OnShrink
=
=
shrink
|
|
size
>
fSize
)
;
if
(
didChangeAlloc
)
{
*
didChangeAlloc
=
alloc
;
}
if
(
alloc
)
{
if
(
fPtr
!
=
(
void
*
)
fStorage
)
{
sk_free
(
fPtr
)
;
}
if
(
size
=
=
kSize
)
{
SkASSERT
(
fPtr
!
=
fStorage
)
;
fPtr
=
fStorage
;
}
else
{
fPtr
=
sk_malloc_throw
(
size
)
;
}
fSize
=
size
;
}
SkASSERT
(
fSize
>
=
size
&
&
fSize
>
=
kSize
)
;
SkASSERT
(
(
fPtr
=
=
fStorage
)
|
|
fSize
>
kSize
)
;
return
fPtr
;
}
private
:
static
const
size_t
kSizeAlign4
=
SkAlign4
(
kSizeRequested
)
;
#
if
defined
(
SK_BUILD_FOR_GOOGLE3
)
static
const
size_t
kMaxBytes
=
4
*
1024
;
static
const
size_t
kSize
=
kSizeRequested
>
kMaxBytes
?
kMaxBytes
:
kSizeAlign4
;
#
else
static
const
size_t
kSize
=
kSizeAlign4
;
#
endif
void
*
fPtr
;
size_t
fSize
;
uint32_t
fStorage
[
kSize
>
>
2
]
;
}
;
#
endif
