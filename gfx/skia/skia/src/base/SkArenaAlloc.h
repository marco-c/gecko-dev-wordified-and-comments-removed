#
ifndef
SkArenaAlloc_DEFINED
#
define
SkArenaAlloc_DEFINED
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkTFitsIn
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkASAN
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
extern
std
:
:
array
<
const
uint32_t
47
>
SkFibonacci47
;
template
<
uint32_t
kMaxSize
>
class
SkFibBlockSizes
{
public
:
SkFibBlockSizes
(
uint32_t
staticBlockSize
uint32_t
firstAllocationSize
)
:
fIndex
{
0
}
{
fBlockUnitSize
=
firstAllocationSize
>
0
?
firstAllocationSize
:
staticBlockSize
>
0
?
staticBlockSize
:
1024
;
SkASSERT_RELEASE
(
0
<
fBlockUnitSize
)
;
SkASSERT_RELEASE
(
fBlockUnitSize
<
std
:
:
min
(
kMaxSize
(
1u
<
<
26
)
-
1
)
)
;
}
uint32_t
nextBlockSize
(
)
{
uint32_t
result
=
SkFibonacci47
[
fIndex
]
*
fBlockUnitSize
;
if
(
SkTo
<
size_t
>
(
fIndex
+
1
)
<
SkFibonacci47
.
size
(
)
&
&
SkFibonacci47
[
fIndex
+
1
]
<
kMaxSize
/
fBlockUnitSize
)
{
fIndex
+
=
1
;
}
return
result
;
}
private
:
uint32_t
fIndex
:
6
;
uint32_t
fBlockUnitSize
:
26
;
}
;
class
SkArenaAlloc
{
public
:
SkArenaAlloc
(
char
*
block
size_t
blockSize
size_t
firstHeapAllocation
)
;
explicit
SkArenaAlloc
(
size_t
firstHeapAllocation
)
:
SkArenaAlloc
(
nullptr
0
firstHeapAllocation
)
{
}
SkArenaAlloc
(
const
SkArenaAlloc
&
)
=
delete
;
SkArenaAlloc
&
operator
=
(
const
SkArenaAlloc
&
)
=
delete
;
SkArenaAlloc
(
SkArenaAlloc
&
&
)
=
delete
;
SkArenaAlloc
&
operator
=
(
SkArenaAlloc
&
&
)
=
delete
;
~
SkArenaAlloc
(
)
;
template
<
typename
Ctor
>
auto
make
(
Ctor
&
&
ctor
)
-
>
decltype
(
ctor
(
nullptr
)
)
{
using
T
=
std
:
:
remove_pointer_t
<
decltype
(
ctor
(
nullptr
)
)
>
;
uint32_t
size
=
SkToU32
(
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkToU32
(
alignof
(
T
)
)
;
char
*
objStart
;
if
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
size
alignment
)
;
fCursor
=
objStart
+
size
;
sk_asan_unpoison_memory_region
(
objStart
size
)
;
}
else
{
objStart
=
this
-
>
allocObjectWithFooter
(
size
+
sizeof
(
Footer
)
alignment
)
;
uint32_t
padding
=
SkToU32
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
size
;
sk_asan_unpoison_memory_region
(
objStart
size
)
;
FooterAction
*
releaser
=
[
]
(
char
*
objEnd
)
{
char
*
objStart
=
objEnd
-
(
sizeof
(
T
)
+
sizeof
(
Footer
)
)
;
(
(
T
*
)
objStart
)
-
>
~
T
(
)
;
return
objStart
;
}
;
this
-
>
installFooter
(
releaser
padding
)
;
}
return
ctor
(
objStart
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
T
*
make
(
Args
&
&
.
.
.
args
)
{
return
this
-
>
make
(
[
&
]
(
void
*
objStart
)
{
return
new
(
objStart
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
)
;
}
template
<
typename
T
>
T
*
make
(
)
{
if
constexpr
(
std
:
:
is_standard_layout
<
T
>
:
:
value
&
&
std
:
:
is_trivial
<
T
>
:
:
value
)
{
return
(
T
*
)
this
-
>
makeBytesAlignedTo
(
sizeof
(
T
)
alignof
(
T
)
)
;
}
else
{
return
this
-
>
make
(
[
&
]
(
void
*
objStart
)
{
return
new
(
objStart
)
T
(
)
;
}
)
;
}
}
template
<
typename
T
>
T
*
makeArrayDefault
(
size_t
count
)
{
T
*
array
=
this
-
>
allocUninitializedArray
<
T
>
(
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
;
}
return
array
;
}
template
<
typename
T
>
T
*
makeArray
(
size_t
count
)
{
T
*
array
=
this
-
>
allocUninitializedArray
<
T
>
(
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
(
)
;
}
return
array
;
}
template
<
typename
T
typename
Initializer
>
T
*
makeInitializedArray
(
size_t
count
Initializer
initializer
)
{
T
*
array
=
this
-
>
allocUninitializedArray
<
T
>
(
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
new
(
&
array
[
i
]
)
T
(
initializer
(
i
)
)
;
}
return
array
;
}
void
*
makeBytesAlignedTo
(
size_t
size
size_t
align
)
{
AssertRelease
(
SkTFitsIn
<
uint32_t
>
(
size
)
)
;
auto
objStart
=
this
-
>
allocObject
(
SkToU32
(
size
)
SkToU32
(
align
)
)
;
fCursor
=
objStart
+
size
;
sk_asan_unpoison_memory_region
(
objStart
size
)
;
return
objStart
;
}
protected
:
using
FooterAction
=
char
*
(
char
*
)
;
struct
Footer
{
uint8_t
unaligned_action
[
sizeof
(
FooterAction
*
)
]
;
uint8_t
padding
;
}
;
char
*
cursor
(
)
{
return
fCursor
;
}
char
*
end
(
)
{
return
fEnd
;
}
private
:
static
void
AssertRelease
(
bool
cond
)
{
if
(
!
cond
)
{
:
:
abort
(
)
;
}
}
static
char
*
SkipPod
(
char
*
footerEnd
)
;
static
void
RunDtorsOnBlock
(
char
*
footerEnd
)
;
static
char
*
NextBlock
(
char
*
footerEnd
)
;
template
<
typename
T
>
void
installRaw
(
const
T
&
val
)
{
sk_asan_unpoison_memory_region
(
fCursor
sizeof
(
val
)
)
;
memcpy
(
fCursor
&
val
sizeof
(
val
)
)
;
fCursor
+
=
sizeof
(
val
)
;
}
void
installFooter
(
FooterAction
*
releaser
uint32_t
padding
)
;
void
ensureSpace
(
uint32_t
size
uint32_t
alignment
)
;
char
*
allocObject
(
uint32_t
size
uint32_t
alignment
)
{
uintptr_t
mask
=
alignment
-
1
;
uintptr_t
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
uintptr_t
totalSize
=
size
+
alignedOffset
;
AssertRelease
(
totalSize
>
=
size
)
;
if
(
totalSize
>
static_cast
<
uintptr_t
>
(
fEnd
-
fCursor
)
)
{
this
-
>
ensureSpace
(
size
alignment
)
;
alignedOffset
=
(
~
reinterpret_cast
<
uintptr_t
>
(
fCursor
)
+
1
)
&
mask
;
}
char
*
object
=
fCursor
+
alignedOffset
;
SkASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
object
)
&
(
alignment
-
1
)
)
=
=
0
)
;
SkASSERT
(
object
+
size
<
=
fEnd
)
;
return
object
;
}
char
*
allocObjectWithFooter
(
uint32_t
sizeIncludingFooter
uint32_t
alignment
)
;
template
<
typename
T
>
T
*
allocUninitializedArray
(
size_t
countZ
)
{
AssertRelease
(
SkTFitsIn
<
uint32_t
>
(
countZ
)
)
;
uint32_t
count
=
SkToU32
(
countZ
)
;
char
*
objStart
;
AssertRelease
(
count
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
/
sizeof
(
T
)
)
;
uint32_t
arraySize
=
SkToU32
(
count
*
sizeof
(
T
)
)
;
uint32_t
alignment
=
SkToU32
(
alignof
(
T
)
)
;
if
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
objStart
=
this
-
>
allocObject
(
arraySize
alignment
)
;
fCursor
=
objStart
+
arraySize
;
sk_asan_unpoison_memory_region
(
objStart
arraySize
)
;
}
else
{
constexpr
uint32_t
overhead
=
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
;
AssertRelease
(
arraySize
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
overhead
)
;
uint32_t
totalSize
=
arraySize
+
overhead
;
objStart
=
this
-
>
allocObjectWithFooter
(
totalSize
alignment
)
;
uint32_t
padding
=
SkToU32
(
objStart
-
fCursor
)
;
fCursor
=
objStart
+
arraySize
;
sk_asan_unpoison_memory_region
(
objStart
arraySize
)
;
this
-
>
installRaw
(
SkToU32
(
count
)
)
;
this
-
>
installFooter
(
[
]
(
char
*
footerEnd
)
{
char
*
objEnd
=
footerEnd
-
(
sizeof
(
Footer
)
+
sizeof
(
uint32_t
)
)
;
uint32_t
count
;
memmove
(
&
count
objEnd
sizeof
(
uint32_t
)
)
;
char
*
objStart
=
objEnd
-
count
*
sizeof
(
T
)
;
T
*
array
=
(
T
*
)
objStart
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
array
[
i
]
.
~
T
(
)
;
}
return
objStart
;
}
padding
)
;
}
return
(
T
*
)
objStart
;
}
char
*
fDtorCursor
;
char
*
fCursor
;
char
*
fEnd
;
SkFibBlockSizes
<
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
>
fFibonacciProgression
;
}
;
class
SkArenaAllocWithReset
:
public
SkArenaAlloc
{
public
:
SkArenaAllocWithReset
(
char
*
block
size_t
blockSize
size_t
firstHeapAllocation
)
;
explicit
SkArenaAllocWithReset
(
size_t
firstHeapAllocation
)
:
SkArenaAllocWithReset
(
nullptr
0
firstHeapAllocation
)
{
}
void
reset
(
)
;
bool
isEmpty
(
)
;
private
:
char
*
const
fFirstBlock
;
const
uint32_t
fFirstSize
;
const
uint32_t
fFirstHeapAllocationSize
;
}
;
template
<
size_t
InlineStorageSize
>
class
SkSTArenaAlloc
:
private
std
:
:
array
<
char
InlineStorageSize
>
public
SkArenaAlloc
{
public
:
explicit
SkSTArenaAlloc
(
size_t
firstHeapAllocation
=
InlineStorageSize
)
:
SkArenaAlloc
{
this
-
>
data
(
)
this
-
>
size
(
)
firstHeapAllocation
}
{
}
~
SkSTArenaAlloc
(
)
{
sk_asan_unpoison_memory_region
(
this
-
>
data
(
)
this
-
>
size
(
)
)
;
}
}
;
template
<
size_t
InlineStorageSize
>
class
SkSTArenaAllocWithReset
:
private
std
:
:
array
<
char
InlineStorageSize
>
public
SkArenaAllocWithReset
{
public
:
explicit
SkSTArenaAllocWithReset
(
size_t
firstHeapAllocation
=
InlineStorageSize
)
:
SkArenaAllocWithReset
{
this
-
>
data
(
)
this
-
>
size
(
)
firstHeapAllocation
}
{
}
~
SkSTArenaAllocWithReset
(
)
{
sk_asan_unpoison_memory_region
(
this
-
>
data
(
)
this
-
>
size
(
)
)
;
}
}
;
#
endif
