#
ifndef
SkTBlockList_DEFINED
#
define
SkTBlockList_DEFINED
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkBlockAllocator
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
type_traits
>
#
include
<
utility
>
using
IndexFn
=
int
(
*
)
(
const
SkBlockAllocator
:
:
Block
*
)
;
using
NextFn
=
int
(
*
)
(
const
SkBlockAllocator
:
:
Block
*
int
)
;
template
<
typename
T
typename
B
>
using
ItemFn
=
T
(
*
)
(
B
*
int
)
;
template
<
typename
T
bool
Forward
bool
Const
IndexFn
Start
IndexFn
End
NextFn
Next
ItemFn
<
T
typename
std
:
:
conditional
<
Const
const
SkBlockAllocator
:
:
Block
SkBlockAllocator
:
:
Block
>
:
:
type
>
Resolve
>
class
BlockIndexIterator
;
template
<
typename
T
int
StartingItems
=
1
>
class
SkTBlockList
{
public
:
SkTBlockList
(
)
:
SkTBlockList
(
SkBlockAllocator
:
:
GrowthPolicy
:
:
kFixed
)
{
}
explicit
SkTBlockList
(
SkBlockAllocator
:
:
GrowthPolicy
policy
)
:
SkTBlockList
(
StartingItems
policy
)
{
}
explicit
SkTBlockList
(
int
itemsPerBlock
SkBlockAllocator
:
:
GrowthPolicy
policy
=
SkBlockAllocator
:
:
GrowthPolicy
:
:
kFixed
)
:
fAllocator
(
policy
SkBlockAllocator
:
:
BlockOverhead
<
alignof
(
T
)
>
(
)
+
sizeof
(
T
)
*
itemsPerBlock
)
{
}
~
SkTBlockList
(
)
{
this
-
>
reset
(
)
;
}
T
&
push_back
(
)
{
return
*
new
(
this
-
>
pushItem
(
)
)
T
;
}
T
&
push_back
(
const
T
&
t
)
{
return
*
new
(
this
-
>
pushItem
(
)
)
T
(
t
)
;
}
T
&
push_back
(
T
&
&
t
)
{
return
*
new
(
this
-
>
pushItem
(
)
)
T
(
std
:
:
move
(
t
)
)
;
}
template
<
typename
.
.
.
Args
>
T
&
emplace_back
(
Args
&
&
.
.
.
args
)
{
return
*
new
(
this
-
>
pushItem
(
)
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
int
SI
>
void
concat
(
SkTBlockList
<
T
SI
>
&
&
other
)
;
void
reserve
(
int
n
)
{
int
avail
=
fAllocator
-
>
currentBlock
(
)
-
>
template
avail
<
alignof
(
T
)
>
(
)
/
sizeof
(
T
)
;
if
(
n
>
avail
)
{
int
reserved
=
n
-
avail
;
fAllocator
-
>
template
reserve
<
alignof
(
T
)
>
(
reserved
*
sizeof
(
T
)
SkBlockAllocator
:
:
kIgnoreExistingBytes_Flag
)
;
}
}
void
pop_back
(
)
{
SkASSERT
(
this
-
>
count
(
)
>
0
)
;
SkBlockAllocator
:
:
Block
*
block
=
fAllocator
-
>
currentBlock
(
)
;
int
releaseIndex
=
Last
(
block
)
;
GetItem
(
block
releaseIndex
)
.
~
T
(
)
;
if
(
releaseIndex
=
=
First
(
block
)
)
{
fAllocator
-
>
releaseBlock
(
block
)
;
}
else
{
SkAssertResult
(
block
-
>
release
(
releaseIndex
releaseIndex
+
sizeof
(
T
)
)
)
;
block
-
>
setMetadata
(
Decrement
(
block
releaseIndex
)
)
;
}
fAllocator
-
>
setMetadata
(
fAllocator
-
>
metadata
(
)
-
1
)
;
}
void
reset
(
)
{
if
constexpr
(
!
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
{
for
(
T
&
t
:
this
-
>
ritems
(
)
)
{
t
.
~
T
(
)
;
}
}
fAllocator
-
>
reset
(
)
;
}
int
count
(
)
const
{
#
ifdef
SK_DEBUG
int
count
=
0
;
for
(
const
auto
*
b
:
fAllocator
-
>
blocks
(
)
)
{
if
(
b
-
>
metadata
(
)
=
=
0
)
{
continue
;
}
count
+
=
(
sizeof
(
T
)
+
Last
(
b
)
-
First
(
b
)
)
/
sizeof
(
T
)
;
}
SkASSERT
(
count
=
=
fAllocator
-
>
metadata
(
)
)
;
#
endif
return
fAllocator
-
>
metadata
(
)
;
}
bool
empty
(
)
const
{
return
this
-
>
count
(
)
=
=
0
;
}
T
&
front
(
)
{
static_assert
(
StartingItems
>
=
1
)
;
SkASSERT
(
this
-
>
count
(
)
>
0
&
&
fAllocator
-
>
headBlock
(
)
-
>
metadata
(
)
>
0
)
;
return
GetItem
(
fAllocator
-
>
headBlock
(
)
First
(
fAllocator
-
>
headBlock
(
)
)
)
;
}
const
T
&
front
(
)
const
{
SkASSERT
(
this
-
>
count
(
)
>
0
&
&
fAllocator
-
>
headBlock
(
)
-
>
metadata
(
)
>
0
)
;
return
GetItem
(
fAllocator
-
>
headBlock
(
)
First
(
fAllocator
-
>
headBlock
(
)
)
)
;
}
T
&
back
(
)
{
SkASSERT
(
this
-
>
count
(
)
>
0
&
&
fAllocator
-
>
currentBlock
(
)
-
>
metadata
(
)
>
0
)
;
return
GetItem
(
fAllocator
-
>
currentBlock
(
)
Last
(
fAllocator
-
>
currentBlock
(
)
)
)
;
}
const
T
&
back
(
)
const
{
SkASSERT
(
this
-
>
count
(
)
>
0
&
&
fAllocator
-
>
currentBlock
(
)
-
>
metadata
(
)
>
0
)
;
return
GetItem
(
fAllocator
-
>
currentBlock
(
)
Last
(
fAllocator
-
>
currentBlock
(
)
)
)
;
}
T
&
item
(
int
i
)
{
SkASSERT
(
i
>
=
0
&
&
i
<
this
-
>
count
(
)
)
;
for
(
auto
*
b
:
fAllocator
-
>
blocks
(
)
)
{
if
(
b
-
>
metadata
(
)
=
=
0
)
{
continue
;
}
int
start
=
First
(
b
)
;
int
end
=
Last
(
b
)
+
sizeof
(
T
)
;
int
index
=
start
+
i
*
sizeof
(
T
)
;
if
(
index
<
end
)
{
return
GetItem
(
b
index
)
;
}
else
{
i
-
=
(
end
-
start
)
/
sizeof
(
T
)
;
}
}
SkUNREACHABLE
;
}
const
T
&
item
(
int
i
)
const
{
return
const_cast
<
SkTBlockList
*
>
(
this
)
-
>
item
(
i
)
;
}
private
:
template
<
typename
S
int
N
>
friend
class
SkTBlockList
;
friend
class
TBlockListTestAccess
;
inline
static
constexpr
size_t
StartingSize
=
SkBlockAllocator
:
:
Overhead
<
alignof
(
T
)
>
(
)
+
StartingItems
*
sizeof
(
T
)
;
static
T
&
GetItem
(
SkBlockAllocator
:
:
Block
*
block
int
index
)
{
return
*
static_cast
<
T
*
>
(
block
-
>
ptr
(
index
)
)
;
}
static
const
T
&
GetItem
(
const
SkBlockAllocator
:
:
Block
*
block
int
index
)
{
return
*
static_cast
<
const
T
*
>
(
block
-
>
ptr
(
index
)
)
;
}
static
int
First
(
const
SkBlockAllocator
:
:
Block
*
b
)
{
return
b
-
>
firstAlignedOffset
<
alignof
(
T
)
>
(
)
;
}
static
int
Last
(
const
SkBlockAllocator
:
:
Block
*
b
)
{
return
b
-
>
metadata
(
)
;
}
static
int
Increment
(
const
SkBlockAllocator
:
:
Block
*
b
int
index
)
{
return
index
+
sizeof
(
T
)
;
}
static
int
Decrement
(
const
SkBlockAllocator
:
:
Block
*
b
int
index
)
{
return
index
-
sizeof
(
T
)
;
}
void
*
pushItem
(
)
{
auto
br
=
fAllocator
-
>
template
allocate
<
alignof
(
T
)
>
(
sizeof
(
T
)
)
;
SkASSERT
(
br
.
fStart
=
=
br
.
fAlignedOffset
|
|
br
.
fAlignedOffset
=
=
First
(
fAllocator
-
>
currentBlock
(
)
)
)
;
br
.
fBlock
-
>
setMetadata
(
br
.
fAlignedOffset
)
;
fAllocator
-
>
setMetadata
(
fAllocator
-
>
metadata
(
)
+
1
)
;
return
br
.
fBlock
-
>
ptr
(
br
.
fAlignedOffset
)
;
}
SkSBlockAllocator
<
StartingSize
>
fAllocator
;
public
:
using
Iter
=
BlockIndexIterator
<
T
&
true
false
&
First
&
Last
&
Increment
&
GetItem
>
;
using
CIter
=
BlockIndexIterator
<
const
T
&
true
true
&
First
&
Last
&
Increment
&
GetItem
>
;
using
RIter
=
BlockIndexIterator
<
T
&
false
false
&
Last
&
First
&
Decrement
&
GetItem
>
;
using
CRIter
=
BlockIndexIterator
<
const
T
&
false
true
&
Last
&
First
&
Decrement
&
GetItem
>
;
Iter
items
(
)
{
return
Iter
(
fAllocator
.
allocator
(
)
)
;
}
CIter
items
(
)
const
{
return
CIter
(
fAllocator
.
allocator
(
)
)
;
}
RIter
ritems
(
)
{
return
RIter
(
fAllocator
.
allocator
(
)
)
;
}
CRIter
ritems
(
)
const
{
return
CRIter
(
fAllocator
.
allocator
(
)
)
;
}
}
;
template
<
typename
T
int
SI1
>
template
<
int
SI2
>
void
SkTBlockList
<
T
SI1
>
:
:
concat
(
SkTBlockList
<
T
SI2
>
&
&
other
)
{
if
(
other
.
empty
(
)
)
{
return
;
}
else
if
(
other
.
count
(
)
=
=
1
)
{
this
-
>
push_back
(
other
.
back
(
)
)
;
other
.
pop_back
(
)
;
return
;
}
int
headItemCount
=
0
;
SkBlockAllocator
:
:
Block
*
headBlock
=
other
.
fAllocator
-
>
headBlock
(
)
;
SkDEBUGCODE
(
int
oldCount
=
this
-
>
count
(
)
;
)
if
(
headBlock
-
>
metadata
(
)
>
0
)
{
int
headStart
=
First
(
headBlock
)
;
int
headEnd
=
Last
(
headBlock
)
+
sizeof
(
T
)
;
headItemCount
=
(
headEnd
-
headStart
)
/
sizeof
(
T
)
;
int
avail
=
fAllocator
-
>
currentBlock
(
)
-
>
template
avail
<
alignof
(
T
)
>
(
)
/
sizeof
(
T
)
;
if
(
headItemCount
>
avail
)
{
fAllocator
-
>
template
reserve
<
alignof
(
T
)
>
(
(
headItemCount
-
avail
)
*
sizeof
(
T
)
SkBlockAllocator
:
:
kIgnoreExistingBytes_Flag
|
SkBlockAllocator
:
:
kIgnoreGrowthPolicy_Flag
)
;
}
if
constexpr
(
std
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
)
{
SkASSERT
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
)
;
auto
copy
=
[
]
(
SkBlockAllocator
:
:
Block
*
src
int
start
SkBlockAllocator
*
dst
int
n
)
{
auto
target
=
dst
-
>
template
allocate
<
alignof
(
T
)
>
(
n
*
sizeof
(
T
)
)
;
memcpy
(
target
.
fBlock
-
>
ptr
(
target
.
fAlignedOffset
)
src
-
>
ptr
(
start
)
n
*
sizeof
(
T
)
)
;
target
.
fBlock
-
>
setMetadata
(
target
.
fAlignedOffset
+
(
n
-
1
)
*
sizeof
(
T
)
)
;
}
;
if
(
avail
>
0
)
{
copy
(
headBlock
headStart
fAllocator
.
allocator
(
)
std
:
:
min
(
headItemCount
avail
)
)
;
}
if
(
headItemCount
>
avail
)
{
copy
(
headBlock
headStart
+
avail
*
sizeof
(
T
)
fAllocator
.
allocator
(
)
headItemCount
-
avail
)
;
}
fAllocator
-
>
setMetadata
(
fAllocator
-
>
metadata
(
)
+
headItemCount
)
;
}
else
{
for
(
int
i
=
headStart
;
i
<
headEnd
;
i
+
=
sizeof
(
T
)
)
{
T
&
toMove
=
GetItem
(
headBlock
i
)
;
this
-
>
push_back
(
std
:
:
move
(
toMove
)
)
;
toMove
.
~
T
(
)
;
}
}
other
.
fAllocator
-
>
releaseBlock
(
headBlock
)
;
}
SkASSERT
(
other
.
fAllocator
-
>
headBlock
(
)
-
>
metadata
(
)
=
=
0
&
&
fAllocator
-
>
metadata
(
)
=
=
oldCount
+
headItemCount
)
;
fAllocator
-
>
stealHeapBlocks
(
other
.
fAllocator
.
allocator
(
)
)
;
fAllocator
-
>
setMetadata
(
fAllocator
-
>
metadata
(
)
+
(
other
.
fAllocator
-
>
metadata
(
)
-
headItemCount
)
)
;
other
.
fAllocator
-
>
setMetadata
(
0
)
;
}
template
<
typename
T
bool
Forward
bool
Const
IndexFn
Start
IndexFn
End
NextFn
Next
ItemFn
<
T
typename
std
:
:
conditional
<
Const
const
SkBlockAllocator
:
:
Block
SkBlockAllocator
:
:
Block
>
:
:
type
>
Resolve
>
class
BlockIndexIterator
{
using
BlockIter
=
typename
SkBlockAllocator
:
:
BlockIter
<
Forward
Const
>
;
public
:
BlockIndexIterator
(
BlockIter
iter
)
:
fBlockIter
(
iter
)
{
}
class
Item
{
public
:
bool
operator
!
=
(
const
Item
&
other
)
const
{
return
other
.
fBlock
!
=
fBlock
|
|
(
SkToBool
(
*
fBlock
)
&
&
other
.
fIndex
!
=
fIndex
)
;
}
T
operator
*
(
)
const
{
SkASSERT
(
*
fBlock
)
;
return
Resolve
(
*
fBlock
fIndex
)
;
}
Item
&
operator
+
+
(
)
{
const
auto
*
block
=
*
fBlock
;
SkASSERT
(
block
&
&
block
-
>
metadata
(
)
>
0
)
;
SkASSERT
(
(
Forward
&
&
Next
(
block
fIndex
)
>
fIndex
)
|
|
(
!
Forward
&
&
Next
(
block
fIndex
)
<
fIndex
)
)
;
fIndex
=
Next
(
block
fIndex
)
;
if
(
(
Forward
&
&
fIndex
>
fEndIndex
)
|
|
(
!
Forward
&
&
fIndex
<
fEndIndex
)
)
{
+
+
fBlock
;
this
-
>
setIndices
(
)
;
}
return
*
this
;
}
private
:
friend
BlockIndexIterator
;
using
BlockItem
=
typename
BlockIter
:
:
Item
;
Item
(
BlockItem
block
)
:
fBlock
(
block
)
{
this
-
>
setIndices
(
)
;
}
void
setIndices
(
)
{
while
(
*
fBlock
&
&
(
*
fBlock
)
-
>
metadata
(
)
=
=
0
)
{
+
+
fBlock
;
}
if
(
*
fBlock
)
{
fIndex
=
Start
(
*
fBlock
)
;
fEndIndex
=
End
(
*
fBlock
)
;
}
else
{
fIndex
=
0
;
fEndIndex
=
0
;
}
SkASSERT
(
(
Forward
&
&
fIndex
<
=
fEndIndex
)
|
|
(
!
Forward
&
&
fIndex
>
=
fEndIndex
)
)
;
}
BlockItem
fBlock
;
int
fIndex
;
int
fEndIndex
;
}
;
Item
begin
(
)
const
{
return
Item
(
fBlockIter
.
begin
(
)
)
;
}
Item
end
(
)
const
{
return
Item
(
fBlockIter
.
end
(
)
)
;
}
private
:
BlockIter
fBlockIter
;
}
;
#
endif
