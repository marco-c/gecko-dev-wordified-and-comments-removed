#
ifndef
SKVX_DEFINED
#
define
SKVX_DEFINED
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
type_traits
>
#
include
<
utility
>
#
if
!
defined
(
SKNX_NO_SIMD
)
#
define
SKVX_USE_SIMD
1
#
else
#
define
SKVX_USE_SIMD
0
#
endif
#
if
SKVX_USE_SIMD
#
if
defined
(
__SSE__
)
|
|
defined
(
__AVX__
)
|
|
defined
(
__AVX2__
)
#
include
<
immintrin
.
h
>
#
elif
defined
(
__ARM_NEON
)
#
include
<
arm_neon
.
h
>
#
elif
defined
(
__wasm_simd128__
)
#
include
<
wasm_simd128
.
h
>
#
endif
#
endif
#
if
defined
(
_MSC_VER
)
#
define
SKVX_ALWAYS_INLINE
__forceinline
#
else
#
define
SKVX_ALWAYS_INLINE
__attribute__
(
(
always_inline
)
)
#
endif
#
define
SI
static
inline
#
define
SIT
template
<
typename
T
>
SI
#
define
SIN
template
<
int
N
>
SI
#
define
SINT
template
<
int
N
typename
T
>
SI
#
define
SINTU
template
<
int
N
typename
T
typename
U
\
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible
<
U
T
>
:
:
value
>
>
SI
namespace
skvx
{
template
<
int
N
typename
T
>
struct
alignas
(
N
*
sizeof
(
T
)
)
Vec
;
template
<
int
.
.
.
Ix
int
N
typename
T
>
SI
Vec
<
sizeof
.
.
.
(
Ix
)
T
>
shuffle
(
const
Vec
<
N
T
>
&
)
;
template
<
typename
D
typename
S
>
SI
D
bit_pun
(
const
S
&
s
)
{
static_assert
(
sizeof
(
D
)
=
=
sizeof
(
S
)
)
;
D
d
;
memcpy
(
&
d
&
s
sizeof
(
D
)
)
;
return
d
;
}
template
<
int
N
typename
T
>
struct
alignas
(
N
*
sizeof
(
T
)
)
VecStorage
{
SKVX_ALWAYS_INLINE
VecStorage
(
)
=
default
;
SKVX_ALWAYS_INLINE
VecStorage
(
T
s
)
:
lo
(
s
)
hi
(
s
)
{
}
Vec
<
N
/
2
T
>
lo
hi
;
}
;
template
<
typename
T
>
struct
VecStorage
<
4
T
>
{
SKVX_ALWAYS_INLINE
VecStorage
(
)
=
default
;
SKVX_ALWAYS_INLINE
VecStorage
(
T
s
)
:
lo
(
s
)
hi
(
s
)
{
}
SKVX_ALWAYS_INLINE
VecStorage
(
T
x
T
y
T
z
T
w
)
:
lo
(
x
y
)
hi
(
z
w
)
{
}
SKVX_ALWAYS_INLINE
VecStorage
(
Vec
<
2
T
>
xy
T
z
T
w
)
:
lo
(
xy
)
hi
(
z
w
)
{
}
SKVX_ALWAYS_INLINE
VecStorage
(
T
x
T
y
Vec
<
2
T
>
zw
)
:
lo
(
x
y
)
hi
(
zw
)
{
}
SKVX_ALWAYS_INLINE
VecStorage
(
Vec
<
2
T
>
xy
Vec
<
2
T
>
zw
)
:
lo
(
xy
)
hi
(
zw
)
{
}
SKVX_ALWAYS_INLINE
Vec
<
2
T
>
&
xy
(
)
{
return
lo
;
}
SKVX_ALWAYS_INLINE
Vec
<
2
T
>
&
zw
(
)
{
return
hi
;
}
SKVX_ALWAYS_INLINE
T
&
x
(
)
{
return
lo
.
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
&
y
(
)
{
return
lo
.
hi
.
val
;
}
SKVX_ALWAYS_INLINE
T
&
z
(
)
{
return
hi
.
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
&
w
(
)
{
return
hi
.
hi
.
val
;
}
SKVX_ALWAYS_INLINE
Vec
<
2
T
>
xy
(
)
const
{
return
lo
;
}
SKVX_ALWAYS_INLINE
Vec
<
2
T
>
zw
(
)
const
{
return
hi
;
}
SKVX_ALWAYS_INLINE
T
x
(
)
const
{
return
lo
.
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
y
(
)
const
{
return
lo
.
hi
.
val
;
}
SKVX_ALWAYS_INLINE
T
z
(
)
const
{
return
hi
.
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
w
(
)
const
{
return
hi
.
hi
.
val
;
}
SKVX_ALWAYS_INLINE
Vec
<
4
T
>
yxwz
(
)
const
{
return
shuffle
<
1
0
3
2
>
(
bit_pun
<
Vec
<
4
T
>
>
(
*
this
)
)
;
}
SKVX_ALWAYS_INLINE
Vec
<
4
T
>
zwxy
(
)
const
{
return
shuffle
<
2
3
0
1
>
(
bit_pun
<
Vec
<
4
T
>
>
(
*
this
)
)
;
}
Vec
<
2
T
>
lo
hi
;
}
;
template
<
typename
T
>
struct
VecStorage
<
2
T
>
{
SKVX_ALWAYS_INLINE
VecStorage
(
)
=
default
;
SKVX_ALWAYS_INLINE
VecStorage
(
T
s
)
:
lo
(
s
)
hi
(
s
)
{
}
SKVX_ALWAYS_INLINE
VecStorage
(
T
x
T
y
)
:
lo
(
x
)
hi
(
y
)
{
}
SKVX_ALWAYS_INLINE
T
&
x
(
)
{
return
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
&
y
(
)
{
return
hi
.
val
;
}
SKVX_ALWAYS_INLINE
T
x
(
)
const
{
return
lo
.
val
;
}
SKVX_ALWAYS_INLINE
T
y
(
)
const
{
return
hi
.
val
;
}
SKVX_ALWAYS_INLINE
Vec
<
2
T
>
yx
(
)
const
{
return
shuffle
<
1
0
>
(
bit_pun
<
Vec
<
2
T
>
>
(
*
this
)
)
;
}
SKVX_ALWAYS_INLINE
Vec
<
4
T
>
xyxy
(
)
const
{
return
Vec
<
4
T
>
(
bit_pun
<
Vec
<
2
T
>
>
(
*
this
)
bit_pun
<
Vec
<
2
T
>
>
(
*
this
)
)
;
}
Vec
<
1
T
>
lo
hi
;
}
;
template
<
typename
T
>
struct
Mask
{
using
type
=
T
;
}
;
template
<
>
struct
Mask
<
float
>
{
using
type
=
int32_t
;
}
;
template
<
>
struct
Mask
<
double
>
{
using
type
=
int64_t
;
}
;
template
<
typename
T
>
using
M
=
typename
Mask
<
T
>
:
:
type
;
template
<
int
N
typename
T
>
struct
NoConversion
{
T
vals
[
N
]
;
}
;
template
<
int
N
typename
T
>
struct
ConvertNative
{
typedef
NoConversion
<
N
T
>
type
;
}
;
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
template
<
>
struct
ConvertNative
<
4
float
>
{
typedef
__m128
type
;
}
;
template
<
>
struct
ConvertNative
<
4
int32_t
>
{
typedef
__m128i
type
;
}
;
template
<
>
struct
ConvertNative
<
4
uint32_t
>
{
typedef
__m128i
type
;
}
;
template
<
>
struct
ConvertNative
<
8
int16_t
>
{
typedef
__m128i
type
;
}
;
template
<
>
struct
ConvertNative
<
8
uint16_t
>
{
typedef
__m128i
type
;
}
;
template
<
>
struct
ConvertNative
<
16
uint8_t
>
{
typedef
__m128i
type
;
}
;
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__AVX__
)
template
<
>
struct
ConvertNative
<
8
float
>
{
typedef
__m256
type
;
}
;
template
<
>
struct
ConvertNative
<
8
int32_t
>
{
typedef
__m256i
type
;
}
;
template
<
>
struct
ConvertNative
<
8
uint32_t
>
{
typedef
__m256i
type
;
}
;
template
<
>
struct
ConvertNative
<
16
int16_t
>
{
typedef
__m256i
type
;
}
;
template
<
>
struct
ConvertNative
<
16
uint16_t
>
{
typedef
__m256i
type
;
}
;
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
template
<
>
struct
ConvertNative
<
4
float
>
{
typedef
float32x4_t
type
;
}
;
template
<
>
struct
ConvertNative
<
4
int32_t
>
{
typedef
int32x4_t
type
;
}
;
template
<
>
struct
ConvertNative
<
4
uint32_t
>
{
typedef
uint32x4_t
type
;
}
;
template
<
>
struct
ConvertNative
<
4
int16_t
>
{
typedef
int16x4_t
type
;
}
;
template
<
>
struct
ConvertNative
<
4
uint16_t
>
{
typedef
uint16x4_t
type
;
}
;
template
<
>
struct
ConvertNative
<
8
int16_t
>
{
typedef
int16x8_t
type
;
}
;
template
<
>
struct
ConvertNative
<
8
uint16_t
>
{
typedef
uint16x8_t
type
;
}
;
template
<
>
struct
ConvertNative
<
8
uint8_t
>
{
typedef
uint8x8_t
type
;
}
;
#
endif
template
<
int
N
typename
T
>
struct
alignas
(
N
*
sizeof
(
T
)
)
Vec
:
public
VecStorage
<
N
T
>
{
typedef
T
elem_type
;
static_assert
(
(
N
&
(
N
-
1
)
)
=
=
0
"
N
must
be
a
power
of
2
.
"
)
;
static_assert
(
sizeof
(
T
)
>
=
alignof
(
T
)
"
What
kind
of
unusual
T
is
this
?
"
)
;
SKVX_ALWAYS_INLINE
Vec
(
)
=
default
;
SKVX_ALWAYS_INLINE
Vec
(
typename
ConvertNative
<
N
T
>
:
:
type
native
)
:
Vec
(
bit_pun
<
Vec
>
(
native
)
)
{
}
using
VecStorage
<
N
T
>
:
:
VecStorage
;
SKVX_ALWAYS_INLINE
Vec
(
std
:
:
initializer_list
<
T
>
xs
)
{
T
vals
[
N
]
=
{
0
}
;
memcpy
(
vals
xs
.
begin
(
)
std
:
:
min
(
xs
.
size
(
)
(
size_t
)
N
)
*
sizeof
(
T
)
)
;
this
-
>
lo
=
Vec
<
N
/
2
T
>
:
:
Load
(
vals
+
0
)
;
this
-
>
hi
=
Vec
<
N
/
2
T
>
:
:
Load
(
vals
+
N
/
2
)
;
}
operator
typename
ConvertNative
<
N
T
>
:
:
type
(
)
const
{
return
bit_pun
<
typename
ConvertNative
<
N
T
>
:
:
type
>
(
*
this
)
;
}
SKVX_ALWAYS_INLINE
T
operator
[
]
(
int
i
)
const
{
return
i
<
N
/
2
?
this
-
>
lo
[
i
]
:
this
-
>
hi
[
i
-
N
/
2
]
;
}
SKVX_ALWAYS_INLINE
T
&
operator
[
]
(
int
i
)
{
return
i
<
N
/
2
?
this
-
>
lo
[
i
]
:
this
-
>
hi
[
i
-
N
/
2
]
;
}
SKVX_ALWAYS_INLINE
static
Vec
Load
(
const
void
*
ptr
)
{
Vec
v
;
memcpy
(
&
v
ptr
sizeof
(
Vec
)
)
;
return
v
;
}
SKVX_ALWAYS_INLINE
void
store
(
void
*
ptr
)
const
{
memcpy
(
ptr
this
sizeof
(
Vec
)
)
;
}
}
;
template
<
typename
T
>
struct
Vec
<
1
T
>
{
typedef
T
elem_type
;
T
val
;
SKVX_ALWAYS_INLINE
Vec
(
)
=
default
;
Vec
(
T
s
)
:
val
(
s
)
{
}
SKVX_ALWAYS_INLINE
Vec
(
std
:
:
initializer_list
<
T
>
xs
)
:
val
(
xs
.
size
(
)
?
*
xs
.
begin
(
)
:
0
)
{
}
SKVX_ALWAYS_INLINE
T
operator
[
]
(
int
)
const
{
return
val
;
}
SKVX_ALWAYS_INLINE
T
&
operator
[
]
(
int
)
{
return
val
;
}
SKVX_ALWAYS_INLINE
static
Vec
Load
(
const
void
*
ptr
)
{
Vec
v
;
memcpy
(
&
v
ptr
sizeof
(
Vec
)
)
;
return
v
;
}
SKVX_ALWAYS_INLINE
void
store
(
void
*
ptr
)
const
{
memcpy
(
ptr
this
sizeof
(
Vec
)
)
;
}
}
;
SINT
Vec
<
2
*
N
T
>
join
(
const
Vec
<
N
T
>
&
lo
const
Vec
<
N
T
>
&
hi
)
{
Vec
<
2
*
N
T
>
v
;
v
.
lo
=
lo
;
v
.
hi
=
hi
;
return
v
;
}
#
if
SKVX_USE_SIMD
&
&
(
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
)
#
if
defined
(
__clang__
)
template
<
int
N
typename
T
>
using
VExt
=
T
__attribute__
(
(
ext_vector_type
(
N
)
)
)
;
#
elif
defined
(
__GNUC__
)
template
<
int
N
typename
T
>
struct
VExtHelper
{
typedef
T
__attribute__
(
(
vector_size
(
N
*
sizeof
(
T
)
)
)
)
type
;
}
;
template
<
int
N
typename
T
>
using
VExt
=
typename
VExtHelper
<
N
T
>
:
:
type
;
SI
Vec
<
4
float
>
to_vec
(
VExt
<
4
float
>
v
)
{
return
bit_pun
<
Vec
<
4
float
>
>
(
v
)
;
}
#
endif
SINT
VExt
<
N
T
>
to_vext
(
const
Vec
<
N
T
>
&
v
)
{
return
bit_pun
<
VExt
<
N
T
>
>
(
v
)
;
}
SINT
Vec
<
N
T
>
to_vec
(
const
VExt
<
N
T
>
&
v
)
{
return
bit_pun
<
Vec
<
N
T
>
>
(
v
)
;
}
SINT
Vec
<
N
T
>
operator
+
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
+
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
-
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
-
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
*
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
*
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
/
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
/
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
^
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
^
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
&
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
&
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
|
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
|
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
&
&
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
&
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
|
|
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
|
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
T
>
operator
!
(
const
Vec
<
N
T
>
&
x
)
{
return
to_vec
<
N
T
>
(
!
to_vext
(
x
)
)
;
}
SINT
Vec
<
N
T
>
operator
-
(
const
Vec
<
N
T
>
&
x
)
{
return
to_vec
<
N
T
>
(
-
to_vext
(
x
)
)
;
}
SINT
Vec
<
N
T
>
operator
~
(
const
Vec
<
N
T
>
&
x
)
{
return
to_vec
<
N
T
>
(
~
to_vext
(
x
)
)
;
}
SINT
Vec
<
N
T
>
operator
<
<
(
const
Vec
<
N
T
>
&
x
int
k
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
<
<
k
)
;
}
SINT
Vec
<
N
T
>
operator
>
>
(
const
Vec
<
N
T
>
&
x
int
k
)
{
return
to_vec
<
N
T
>
(
to_vext
(
x
)
>
>
k
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
=
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
=
=
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
!
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
!
=
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
<
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
<
=
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
>
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
>
=
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
<
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
<
to_vext
(
y
)
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
>
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
to_vext
(
x
)
>
to_vext
(
y
)
)
;
}
#
else
SIT
Vec
<
1
T
>
operator
+
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
+
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
-
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
-
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
*
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
*
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
/
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
/
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
^
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
^
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
&
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
&
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
|
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
|
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
&
&
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
&
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
|
|
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
|
y
.
val
;
}
SIT
Vec
<
1
T
>
operator
!
(
const
Vec
<
1
T
>
&
x
)
{
return
!
x
.
val
;
}
SIT
Vec
<
1
T
>
operator
-
(
const
Vec
<
1
T
>
&
x
)
{
return
-
x
.
val
;
}
SIT
Vec
<
1
T
>
operator
~
(
const
Vec
<
1
T
>
&
x
)
{
return
~
x
.
val
;
}
SIT
Vec
<
1
T
>
operator
<
<
(
const
Vec
<
1
T
>
&
x
int
k
)
{
return
x
.
val
<
<
k
;
}
SIT
Vec
<
1
T
>
operator
>
>
(
const
Vec
<
1
T
>
&
x
int
k
)
{
return
x
.
val
>
>
k
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
=
=
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
=
=
y
.
val
?
~
0
:
0
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
!
=
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
!
=
y
.
val
?
~
0
:
0
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
<
=
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
<
=
y
.
val
?
~
0
:
0
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
>
=
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
>
=
y
.
val
?
~
0
:
0
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
<
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
<
y
.
val
?
~
0
:
0
;
}
SIT
Vec
<
1
M
<
T
>
>
operator
>
(
const
Vec
<
1
T
>
&
x
const
Vec
<
1
T
>
&
y
)
{
return
x
.
val
>
y
.
val
?
~
0
:
0
;
}
SINT
Vec
<
N
T
>
operator
+
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
+
y
.
lo
x
.
hi
+
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
-
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
-
y
.
lo
x
.
hi
-
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
*
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
*
y
.
lo
x
.
hi
*
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
/
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
/
y
.
lo
x
.
hi
/
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
^
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
^
y
.
lo
x
.
hi
^
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
&
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
&
y
.
lo
x
.
hi
&
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
|
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
|
y
.
lo
x
.
hi
|
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
&
&
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
&
y
.
lo
x
.
hi
&
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
|
|
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
|
y
.
lo
x
.
hi
|
y
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
!
(
const
Vec
<
N
T
>
&
x
)
{
return
join
(
!
x
.
lo
!
x
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
-
(
const
Vec
<
N
T
>
&
x
)
{
return
join
(
-
x
.
lo
-
x
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
~
(
const
Vec
<
N
T
>
&
x
)
{
return
join
(
~
x
.
lo
~
x
.
hi
)
;
}
SINT
Vec
<
N
T
>
operator
<
<
(
const
Vec
<
N
T
>
&
x
int
k
)
{
return
join
(
x
.
lo
<
<
k
x
.
hi
<
<
k
)
;
}
SINT
Vec
<
N
T
>
operator
>
>
(
const
Vec
<
N
T
>
&
x
int
k
)
{
return
join
(
x
.
lo
>
>
k
x
.
hi
>
>
k
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
=
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
=
=
y
.
lo
x
.
hi
=
=
y
.
hi
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
!
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
!
=
y
.
lo
x
.
hi
!
=
y
.
hi
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
<
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
<
=
y
.
lo
x
.
hi
<
=
y
.
hi
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
>
=
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
>
=
y
.
lo
x
.
hi
>
=
y
.
hi
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
<
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
<
y
.
lo
x
.
hi
<
y
.
hi
)
;
}
SINT
Vec
<
N
M
<
T
>
>
operator
>
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
join
(
x
.
lo
>
y
.
lo
x
.
hi
>
y
.
hi
)
;
}
#
endif
SINTU
Vec
<
N
T
>
operator
+
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
+
y
;
}
SINTU
Vec
<
N
T
>
operator
-
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
-
y
;
}
SINTU
Vec
<
N
T
>
operator
*
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
*
y
;
}
SINTU
Vec
<
N
T
>
operator
/
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
/
y
;
}
SINTU
Vec
<
N
T
>
operator
^
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
^
y
;
}
SINTU
Vec
<
N
T
>
operator
&
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
&
y
;
}
SINTU
Vec
<
N
T
>
operator
|
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
|
y
;
}
SINTU
Vec
<
N
T
>
operator
&
&
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
&
&
y
;
}
SINTU
Vec
<
N
T
>
operator
|
|
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
|
|
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
=
=
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
=
=
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
!
=
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
!
=
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
<
=
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
<
=
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
>
=
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
>
=
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
<
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
<
y
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
>
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
Vec
<
N
T
>
(
x
)
>
y
;
}
SINTU
Vec
<
N
T
>
operator
+
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
+
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
-
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
-
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
*
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
*
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
/
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
/
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
^
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
^
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
&
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
&
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
|
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
|
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
&
&
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
&
&
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
T
>
operator
|
|
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
|
|
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
=
=
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
=
=
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
!
=
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
!
=
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
<
=
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
<
=
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
>
=
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
>
=
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
<
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
<
Vec
<
N
T
>
(
y
)
;
}
SINTU
Vec
<
N
M
<
T
>
>
operator
>
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
x
>
Vec
<
N
T
>
(
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
+
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
+
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
-
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
-
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
*
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
*
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
/
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
/
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
^
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
^
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
&
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
&
y
)
;
}
SINT
Vec
<
N
T
>
&
operator
|
=
(
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
(
x
=
x
|
y
)
;
}
SINTU
Vec
<
N
T
>
&
operator
+
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
+
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
-
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
-
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
*
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
*
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
/
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
/
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
^
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
^
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
&
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
&
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
&
operator
|
=
(
Vec
<
N
T
>
&
x
U
y
)
{
return
(
x
=
x
|
Vec
<
N
T
>
(
y
)
)
;
}
SINT
Vec
<
N
T
>
&
operator
<
<
=
(
Vec
<
N
T
>
&
x
int
bits
)
{
return
(
x
=
x
<
<
bits
)
;
}
SINT
Vec
<
N
T
>
&
operator
>
>
=
(
Vec
<
N
T
>
&
x
int
bits
)
{
return
(
x
=
x
>
>
bits
)
;
}
SINT
Vec
<
N
T
>
naive_if_then_else
(
const
Vec
<
N
M
<
T
>
>
&
cond
const
Vec
<
N
T
>
&
t
const
Vec
<
N
T
>
&
e
)
{
return
bit_pun
<
Vec
<
N
T
>
>
(
(
cond
&
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
t
)
)
|
(
~
cond
&
bit_pun
<
Vec
<
N
M
<
T
>
>
>
(
e
)
)
)
;
}
SIT
Vec
<
1
T
>
if_then_else
(
const
Vec
<
1
M
<
T
>
>
&
cond
const
Vec
<
1
T
>
&
t
const
Vec
<
1
T
>
&
e
)
{
return
bit_pun
<
Vec
<
1
T
>
>
(
(
cond
&
bit_pun
<
Vec
<
1
M
<
T
>
>
>
(
t
)
)
|
(
~
cond
&
bit_pun
<
Vec
<
1
M
<
T
>
>
>
(
e
)
)
)
;
}
SINT
Vec
<
N
T
>
if_then_else
(
const
Vec
<
N
M
<
T
>
>
&
cond
const
Vec
<
N
T
>
&
t
const
Vec
<
N
T
>
&
e
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__AVX2__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
32
)
{
return
bit_pun
<
Vec
<
N
T
>
>
(
_mm256_blendv_epi8
(
bit_pun
<
__m256i
>
(
e
)
bit_pun
<
__m256i
>
(
t
)
bit_pun
<
__m256i
>
(
cond
)
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE4_1__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
16
)
{
return
bit_pun
<
Vec
<
N
T
>
>
(
_mm_blendv_epi8
(
bit_pun
<
__m128i
>
(
e
)
bit_pun
<
__m128i
>
(
t
)
bit_pun
<
__m128i
>
(
cond
)
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
16
)
{
return
bit_pun
<
Vec
<
N
T
>
>
(
vbslq_u8
(
bit_pun
<
uint8x16_t
>
(
cond
)
bit_pun
<
uint8x16_t
>
(
t
)
bit_pun
<
uint8x16_t
>
(
e
)
)
)
;
}
#
endif
if
constexpr
(
N
*
sizeof
(
T
)
>
16
)
{
return
join
(
if_then_else
(
cond
.
lo
t
.
lo
e
.
lo
)
if_then_else
(
cond
.
hi
t
.
hi
e
.
hi
)
)
;
}
return
naive_if_then_else
(
cond
t
e
)
;
}
SIT
bool
any
(
const
Vec
<
1
T
>
&
x
)
{
return
x
.
val
!
=
0
;
}
SINT
bool
any
(
const
Vec
<
N
T
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__AVX2__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
32
)
{
return
!
_mm256_testz_si256
(
bit_pun
<
__m256i
>
(
x
)
_mm256_set1_epi32
(
-
1
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE_4_1__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
16
)
{
return
!
_mm_testz_si128
(
bit_pun
<
__m128i
>
(
x
)
_mm_set1_epi32
(
-
1
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
16
)
{
return
_mm_movemask_ps
(
_mm_cmpneq_ps
(
bit_pun
<
__m128
>
(
x
)
_mm_set1_ps
(
0
)
)
)
!
=
0b0000
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__aarch64__
)
if
constexpr
(
N
*
sizeof
(
T
)
=
=
8
)
{
return
vmaxv_u8
(
bit_pun
<
uint8x8_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
N
*
sizeof
(
T
)
=
=
16
)
{
return
vmaxvq_u8
(
bit_pun
<
uint8x16_t
>
(
x
)
)
>
0
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__wasm_simd128__
)
if
constexpr
(
N
=
=
4
&
&
sizeof
(
T
)
=
=
4
)
{
return
wasm_i32x4_any_true
(
bit_pun
<
VExt
<
4
int
>
>
(
x
)
)
;
}
#
endif
return
any
(
x
.
lo
)
|
|
any
(
x
.
hi
)
;
}
SIT
bool
all
(
const
Vec
<
1
T
>
&
x
)
{
return
x
.
val
!
=
0
;
}
SINT
bool
all
(
const
Vec
<
N
T
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
if
constexpr
(
N
=
=
4
&
&
sizeof
(
T
)
=
=
4
)
{
return
_mm_movemask_ps
(
_mm_cmpneq_ps
(
bit_pun
<
__m128
>
(
x
)
_mm_set1_ps
(
0
)
)
)
=
=
0b1111
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__aarch64__
)
if
constexpr
(
sizeof
(
T
)
=
=
1
&
&
N
=
=
8
)
{
return
vminv_u8
(
bit_pun
<
uint8x8_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
sizeof
(
T
)
=
=
1
&
&
N
=
=
16
)
{
return
vminvq_u8
(
bit_pun
<
uint8x16_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
sizeof
(
T
)
=
=
2
&
&
N
=
=
4
)
{
return
vminv_u16
(
bit_pun
<
uint16x4_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
sizeof
(
T
)
=
=
2
&
&
N
=
=
8
)
{
return
vminvq_u16
(
bit_pun
<
uint16x8_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
sizeof
(
T
)
=
=
4
&
&
N
=
=
2
)
{
return
vminv_u32
(
bit_pun
<
uint32x2_t
>
(
x
)
)
>
0
;
}
if
constexpr
(
sizeof
(
T
)
=
=
4
&
&
N
=
=
4
)
{
return
vminvq_u32
(
bit_pun
<
uint32x4_t
>
(
x
)
)
>
0
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__wasm_simd128__
)
if
constexpr
(
N
=
=
4
&
&
sizeof
(
T
)
=
=
4
)
{
return
wasm_i32x4_all_true
(
bit_pun
<
VExt
<
4
int
>
>
(
x
)
)
;
}
#
endif
return
all
(
x
.
lo
)
&
&
all
(
x
.
hi
)
;
}
template
<
typename
D
typename
S
>
SI
Vec
<
1
D
>
cast
(
const
Vec
<
1
S
>
&
src
)
{
return
(
D
)
src
.
val
;
}
template
<
typename
D
int
N
typename
S
>
SI
Vec
<
N
D
>
cast
(
const
Vec
<
N
S
>
&
src
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__clang__
)
return
to_vec
(
__builtin_convertvector
(
to_vext
(
src
)
VExt
<
N
D
>
)
)
;
#
else
return
join
(
cast
<
D
>
(
src
.
lo
)
cast
<
D
>
(
src
.
hi
)
)
;
#
endif
}
SIT
T
min
(
const
Vec
<
1
T
>
&
x
)
{
return
x
.
val
;
}
SIT
T
max
(
const
Vec
<
1
T
>
&
x
)
{
return
x
.
val
;
}
SINT
T
min
(
const
Vec
<
N
T
>
&
x
)
{
return
std
:
:
min
(
min
(
x
.
lo
)
min
(
x
.
hi
)
)
;
}
SINT
T
max
(
const
Vec
<
N
T
>
&
x
)
{
return
std
:
:
max
(
max
(
x
.
lo
)
max
(
x
.
hi
)
)
;
}
SINT
Vec
<
N
T
>
min
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
naive_if_then_else
(
y
<
x
y
x
)
;
}
SINT
Vec
<
N
T
>
max
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
return
naive_if_then_else
(
x
<
y
y
x
)
;
}
SINTU
Vec
<
N
T
>
min
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
min
(
x
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
max
(
const
Vec
<
N
T
>
&
x
U
y
)
{
return
max
(
x
Vec
<
N
T
>
(
y
)
)
;
}
SINTU
Vec
<
N
T
>
min
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
min
(
Vec
<
N
T
>
(
x
)
y
)
;
}
SINTU
Vec
<
N
T
>
max
(
U
x
const
Vec
<
N
T
>
&
y
)
{
return
max
(
Vec
<
N
T
>
(
x
)
y
)
;
}
SINT
Vec
<
N
T
>
pin
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
lo
const
Vec
<
N
T
>
&
hi
)
{
return
max
(
lo
min
(
x
hi
)
)
;
}
template
<
int
.
.
.
Ix
int
N
typename
T
>
SI
Vec
<
sizeof
.
.
.
(
Ix
)
T
>
shuffle
(
const
Vec
<
N
T
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__clang__
)
return
to_vec
<
sizeof
.
.
.
(
Ix
)
T
>
(
__builtin_shufflevector
(
to_vext
(
x
)
to_vext
(
x
)
Ix
.
.
.
)
)
;
#
else
return
{
x
[
Ix
]
.
.
.
}
;
#
endif
}
template
<
typename
Fn
typename
.
.
.
Args
size_t
.
.
.
I
>
SI
auto
map
(
std
:
:
index_sequence
<
I
.
.
.
>
Fn
&
&
fn
const
Args
&
.
.
.
args
)
-
>
skvx
:
:
Vec
<
sizeof
.
.
.
(
I
)
decltype
(
fn
(
args
[
0
]
.
.
.
)
)
>
{
auto
lane
=
[
&
]
(
size_t
i
)
#
if
defined
(
__clang__
)
__attribute__
(
(
no_sanitize
(
"
cfi
"
)
)
)
#
endif
{
return
fn
(
args
[
static_cast
<
int
>
(
i
)
]
.
.
.
)
;
}
;
return
{
lane
(
I
)
.
.
.
}
;
}
template
<
typename
Fn
int
N
typename
T
typename
.
.
.
Rest
>
auto
map
(
Fn
&
&
fn
const
Vec
<
N
T
>
&
first
const
Rest
&
.
.
.
rest
)
{
return
map
(
std
:
:
make_index_sequence
<
N
>
{
}
fn
first
rest
.
.
.
)
;
}
SIN
Vec
<
N
float
>
ceil
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
ceilf
x
)
;
}
SIN
Vec
<
N
float
>
floor
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
floorf
x
)
;
}
SIN
Vec
<
N
float
>
trunc
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
truncf
x
)
;
}
SIN
Vec
<
N
float
>
round
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
roundf
x
)
;
}
SIN
Vec
<
N
float
>
sqrt
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
sqrtf
x
)
;
}
SIN
Vec
<
N
float
>
abs
(
const
Vec
<
N
float
>
&
x
)
{
return
map
(
fabsf
x
)
;
}
SIN
Vec
<
N
float
>
fma
(
const
Vec
<
N
float
>
&
x
const
Vec
<
N
float
>
&
y
const
Vec
<
N
float
>
&
z
)
{
auto
fn
=
[
]
(
float
x
float
y
float
z
)
{
return
fmaf
(
x
y
z
)
;
}
;
return
map
(
fn
x
y
z
)
;
}
SI
Vec
<
1
int
>
lrint
(
const
Vec
<
1
float
>
&
x
)
{
return
(
int
)
lrintf
(
x
.
val
)
;
}
SIN
Vec
<
N
int
>
lrint
(
const
Vec
<
N
float
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__AVX__
)
if
constexpr
(
N
=
=
8
)
{
return
bit_pun
<
Vec
<
N
int
>
>
(
_mm256_cvtps_epi32
(
bit_pun
<
__m256
>
(
x
)
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
if
constexpr
(
N
=
=
4
)
{
return
bit_pun
<
Vec
<
N
int
>
>
(
_mm_cvtps_epi32
(
bit_pun
<
__m128
>
(
x
)
)
)
;
}
#
endif
return
join
(
lrint
(
x
.
lo
)
lrint
(
x
.
hi
)
)
;
}
SIN
Vec
<
N
float
>
fract
(
const
Vec
<
N
float
>
&
x
)
{
return
x
-
floor
(
x
)
;
}
SIN
Vec
<
N
uint16_t
>
to_half_finite_ftz
(
const
Vec
<
N
float
>
&
x
)
{
Vec
<
N
uint32_t
>
sem
=
bit_pun
<
Vec
<
N
uint32_t
>
>
(
x
)
s
=
sem
&
0x8000
'
0000
em
=
sem
^
s
is_norm
=
em
>
0x387f
'
d000
norm
=
(
em
>
>
13
)
-
(
(
127
-
15
)
<
<
10
)
;
return
cast
<
uint16_t
>
(
(
s
>
>
16
)
|
(
is_norm
&
norm
)
)
;
}
SIN
Vec
<
N
float
>
from_half_finite_ftz
(
const
Vec
<
N
uint16_t
>
&
x
)
{
Vec
<
N
uint32_t
>
wide
=
cast
<
uint32_t
>
(
x
)
s
=
wide
&
0x8000
em
=
wide
^
s
is_norm
=
em
>
0x3ff
norm
=
(
em
<
<
13
)
+
(
(
127
-
15
)
<
<
23
)
;
return
bit_pun
<
Vec
<
N
float
>
>
(
(
s
<
<
16
)
|
(
is_norm
&
norm
)
)
;
}
SI
Vec
<
1
uint16_t
>
to_half
(
const
Vec
<
1
float
>
&
x
)
{
return
to_half_finite_ftz
(
x
)
;
}
SI
Vec
<
1
float
>
from_half
(
const
Vec
<
1
uint16_t
>
&
x
)
{
return
from_half_finite_ftz
(
x
)
;
}
SIN
Vec
<
N
uint16_t
>
to_half
(
const
Vec
<
N
float
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__F16C__
)
if
constexpr
(
N
=
=
8
)
{
return
bit_pun
<
Vec
<
N
uint16_t
>
>
(
_mm256_cvtps_ph
(
bit_pun
<
__m256
>
(
x
)
_MM_FROUND_TO_NEAREST_INT
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__aarch64__
)
if
constexpr
(
N
=
=
4
)
{
return
bit_pun
<
Vec
<
N
uint16_t
>
>
(
vcvt_f16_f32
(
bit_pun
<
float32x4_t
>
(
x
)
)
)
;
}
#
endif
if
constexpr
(
N
>
4
)
{
return
join
(
to_half
(
x
.
lo
)
to_half
(
x
.
hi
)
)
;
}
return
to_half_finite_ftz
(
x
)
;
}
SIN
Vec
<
N
float
>
from_half
(
const
Vec
<
N
uint16_t
>
&
x
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__F16C__
)
if
constexpr
(
N
=
=
8
)
{
return
bit_pun
<
Vec
<
N
float
>
>
(
_mm256_cvtph_ps
(
bit_pun
<
__m128i
>
(
x
)
)
)
;
}
#
endif
#
if
SKVX_USE_SIMD
&
&
defined
(
__aarch64__
)
if
constexpr
(
N
=
=
4
)
{
return
bit_pun
<
Vec
<
N
float
>
>
(
vcvt_f32_f16
(
bit_pun
<
float16x4_t
>
(
x
)
)
)
;
}
#
endif
if
constexpr
(
N
>
4
)
{
return
join
(
from_half
(
x
.
lo
)
from_half
(
x
.
hi
)
)
;
}
return
from_half_finite_ftz
(
x
)
;
}
SIN
Vec
<
N
uint8_t
>
div255
(
const
Vec
<
N
uint16_t
>
&
x
)
{
return
cast
<
uint8_t
>
(
(
x
+
127
)
/
255
)
;
}
SIN
Vec
<
N
uint8_t
>
approx_scale
(
const
Vec
<
N
uint8_t
>
&
x
const
Vec
<
N
uint8_t
>
&
y
)
{
auto
X
=
cast
<
uint16_t
>
(
x
)
Y
=
cast
<
uint16_t
>
(
y
)
;
return
cast
<
uint8_t
>
(
(
X
*
Y
+
X
)
/
256
)
;
}
SINT
std
:
:
enable_if_t
<
std
:
:
is_unsigned_v
<
T
>
Vec
<
N
T
>
>
saturated_add
(
const
Vec
<
N
T
>
&
x
const
Vec
<
N
T
>
&
y
)
{
#
if
SKVX_USE_SIMD
&
&
(
defined
(
__SSE__
)
|
|
defined
(
__ARM_NEON
)
)
if
constexpr
(
N
=
=
16
&
&
sizeof
(
T
)
=
=
1
)
{
#
if
defined
(
__SSE__
)
return
bit_pun
<
Vec
<
N
T
>
>
(
_mm_adds_epu8
(
bit_pun
<
__m128i
>
(
x
)
bit_pun
<
__m128i
>
(
y
)
)
)
;
#
else
return
bit_pun
<
Vec
<
N
T
>
>
(
vqaddq_u8
(
bit_pun
<
uint8x16_t
>
(
x
)
bit_pun
<
uint8x16_t
>
(
y
)
)
)
;
#
endif
}
else
if
constexpr
(
N
<
16
&
&
sizeof
(
T
)
=
=
1
)
{
return
saturated_add
(
join
(
x
x
)
join
(
y
y
)
)
.
lo
;
}
else
if
constexpr
(
sizeof
(
T
)
=
=
1
)
{
return
join
(
saturated_add
(
x
.
lo
y
.
lo
)
saturated_add
(
x
.
hi
y
.
hi
)
)
;
}
#
endif
auto
sum
=
x
+
y
;
return
if_then_else
(
sum
<
x
Vec
<
N
T
>
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
sum
)
;
}
class
ScaledDividerU32
{
public
:
explicit
ScaledDividerU32
(
uint32_t
divisor
)
:
fDivisorFactor
{
(
uint32_t
)
(
std
:
:
round
(
(
1
.
0
/
divisor
)
*
(
1ull
<
<
32
)
)
)
}
fHalf
{
(
divisor
+
1
)
>
>
1
}
{
assert
(
divisor
>
1
)
;
}
Vec
<
4
uint32_t
>
divide
(
const
Vec
<
4
uint32_t
>
&
numerator
)
const
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
uint64x2_t
hi
=
vmull_n_u32
(
vget_high_u32
(
to_vext
(
numerator
)
)
fDivisorFactor
)
;
uint64x2_t
lo
=
vmull_n_u32
(
vget_low_u32
(
to_vext
(
numerator
)
)
fDivisorFactor
)
;
return
to_vec
<
4
uint32_t
>
(
vcombine_u32
(
vshrn_n_u64
(
lo
32
)
vshrn_n_u64
(
hi
32
)
)
)
;
#
else
return
cast
<
uint32_t
>
(
(
cast
<
uint64_t
>
(
numerator
)
*
fDivisorFactor
)
>
>
32
)
;
#
endif
}
uint32_t
half
(
)
const
{
return
fHalf
;
}
private
:
const
uint32_t
fDivisorFactor
;
const
uint32_t
fHalf
;
}
;
SIN
Vec
<
N
uint16_t
>
mull
(
const
Vec
<
N
uint8_t
>
&
x
const
Vec
<
N
uint8_t
>
&
y
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
if
constexpr
(
N
=
=
8
)
{
return
to_vec
<
8
uint16_t
>
(
vmull_u8
(
to_vext
(
x
)
to_vext
(
y
)
)
)
;
}
else
if
constexpr
(
N
<
8
)
{
return
mull
(
join
(
x
x
)
join
(
y
y
)
)
.
lo
;
}
else
{
return
join
(
mull
(
x
.
lo
y
.
lo
)
mull
(
x
.
hi
y
.
hi
)
)
;
}
#
else
return
cast
<
uint16_t
>
(
x
)
*
cast
<
uint16_t
>
(
y
)
;
#
endif
}
SIN
Vec
<
N
uint32_t
>
mull
(
const
Vec
<
N
uint16_t
>
&
x
const
Vec
<
N
uint16_t
>
&
y
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
if
constexpr
(
N
=
=
4
)
{
return
to_vec
<
4
uint32_t
>
(
vmull_u16
(
to_vext
(
x
)
to_vext
(
y
)
)
)
;
}
else
if
constexpr
(
N
<
4
)
{
return
mull
(
join
(
x
x
)
join
(
y
y
)
)
.
lo
;
}
else
{
return
join
(
mull
(
x
.
lo
y
.
lo
)
mull
(
x
.
hi
y
.
hi
)
)
;
}
#
else
return
cast
<
uint32_t
>
(
x
)
*
cast
<
uint32_t
>
(
y
)
;
#
endif
}
SIN
Vec
<
N
uint16_t
>
mulhi
(
const
Vec
<
N
uint16_t
>
&
x
const
Vec
<
N
uint16_t
>
&
y
)
{
#
if
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
if
constexpr
(
N
=
=
8
)
{
return
bit_pun
<
Vec
<
8
uint16_t
>
>
(
_mm_mulhi_epu16
(
bit_pun
<
__m128i
>
(
x
)
bit_pun
<
__m128i
>
(
y
)
)
)
;
}
else
if
constexpr
(
N
<
8
)
{
return
mulhi
(
join
(
x
x
)
join
(
y
y
)
)
.
lo
;
}
else
{
return
join
(
mulhi
(
x
.
lo
y
.
lo
)
mulhi
(
x
.
hi
y
.
hi
)
)
;
}
#
else
return
skvx
:
:
cast
<
uint16_t
>
(
mull
(
x
y
)
>
>
16
)
;
#
endif
}
SINT
T
dot
(
const
Vec
<
N
T
>
&
a
const
Vec
<
N
T
>
&
b
)
{
auto
ab
=
a
*
b
;
if
constexpr
(
N
=
=
2
)
{
return
ab
[
0
]
+
ab
[
1
]
;
}
else
if
constexpr
(
N
=
=
4
)
{
return
ab
[
0
]
+
ab
[
1
]
+
ab
[
2
]
+
ab
[
3
]
;
}
else
{
T
sum
=
ab
[
0
]
;
for
(
int
i
=
1
;
i
<
N
;
+
+
i
)
{
sum
+
=
ab
[
i
]
;
}
return
sum
;
}
}
SIT
T
cross
(
const
Vec
<
2
T
>
&
a
const
Vec
<
2
T
>
&
b
)
{
auto
x
=
a
*
shuffle
<
1
0
>
(
b
)
;
return
x
[
0
]
-
x
[
1
]
;
}
SIN
float
length
(
const
Vec
<
N
float
>
&
v
)
{
return
std
:
:
sqrt
(
dot
(
v
v
)
)
;
}
SIN
double
length
(
const
Vec
<
N
double
>
&
v
)
{
return
std
:
:
sqrt
(
dot
(
v
v
)
)
;
}
SIN
Vec
<
N
float
>
normalize
(
const
Vec
<
N
float
>
&
v
)
{
return
v
/
length
(
v
)
;
}
SIN
Vec
<
N
double
>
normalize
(
const
Vec
<
N
double
>
&
v
)
{
return
v
/
length
(
v
)
;
}
SINT
bool
isfinite
(
const
Vec
<
N
T
>
&
v
)
{
return
std
:
:
isfinite
(
dot
(
v
Vec
<
N
T
>
(
0
)
)
)
;
}
SIT
void
strided_load4
(
const
T
*
v
Vec
<
1
T
>
&
a
Vec
<
1
T
>
&
b
Vec
<
1
T
>
&
c
Vec
<
1
T
>
&
d
)
{
a
.
val
=
v
[
0
]
;
b
.
val
=
v
[
1
]
;
c
.
val
=
v
[
2
]
;
d
.
val
=
v
[
3
]
;
}
SINT
void
strided_load4
(
const
T
*
v
Vec
<
N
T
>
&
a
Vec
<
N
T
>
&
b
Vec
<
N
T
>
&
c
Vec
<
N
T
>
&
d
)
{
strided_load4
(
v
a
.
lo
b
.
lo
c
.
lo
d
.
lo
)
;
strided_load4
(
v
+
4
*
(
N
/
2
)
a
.
hi
b
.
hi
c
.
hi
d
.
hi
)
;
}
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
#
define
IMPL_LOAD4_TRANSPOSED
(
N
T
VLD
)
\
SI
void
strided_load4
(
const
T
*
v
\
Vec
<
N
T
>
&
a
\
Vec
<
N
T
>
&
b
\
Vec
<
N
T
>
&
c
\
Vec
<
N
T
>
&
d
)
{
\
auto
mat
=
VLD
(
v
)
;
\
a
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
0
]
)
;
\
b
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
1
]
)
;
\
c
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
2
]
)
;
\
d
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
3
]
)
;
\
}
IMPL_LOAD4_TRANSPOSED
(
2
uint32_t
vld4_u32
)
IMPL_LOAD4_TRANSPOSED
(
4
uint16_t
vld4_u16
)
IMPL_LOAD4_TRANSPOSED
(
8
uint8_t
vld4_u8
)
IMPL_LOAD4_TRANSPOSED
(
2
int32_t
vld4_s32
)
IMPL_LOAD4_TRANSPOSED
(
4
int16_t
vld4_s16
)
IMPL_LOAD4_TRANSPOSED
(
8
int8_t
vld4_s8
)
IMPL_LOAD4_TRANSPOSED
(
2
float
vld4_f32
)
IMPL_LOAD4_TRANSPOSED
(
4
uint32_t
vld4q_u32
)
IMPL_LOAD4_TRANSPOSED
(
8
uint16_t
vld4q_u16
)
IMPL_LOAD4_TRANSPOSED
(
16
uint8_t
vld4q_u8
)
IMPL_LOAD4_TRANSPOSED
(
4
int32_t
vld4q_s32
)
IMPL_LOAD4_TRANSPOSED
(
8
int16_t
vld4q_s16
)
IMPL_LOAD4_TRANSPOSED
(
16
int8_t
vld4q_s8
)
IMPL_LOAD4_TRANSPOSED
(
4
float
vld4q_f32
)
#
undef
IMPL_LOAD4_TRANSPOSED
#
elif
SKVX_USE_SIMD
&
&
defined
(
__SSE__
)
SI
void
strided_load4
(
const
float
*
v
Vec
<
4
float
>
&
a
Vec
<
4
float
>
&
b
Vec
<
4
float
>
&
c
Vec
<
4
float
>
&
d
)
{
__m128
a_
=
_mm_loadu_ps
(
v
)
;
__m128
b_
=
_mm_loadu_ps
(
v
+
4
)
;
__m128
c_
=
_mm_loadu_ps
(
v
+
8
)
;
__m128
d_
=
_mm_loadu_ps
(
v
+
12
)
;
_MM_TRANSPOSE4_PS
(
a_
b_
c_
d_
)
;
a
=
bit_pun
<
Vec
<
4
float
>
>
(
a_
)
;
b
=
bit_pun
<
Vec
<
4
float
>
>
(
b_
)
;
c
=
bit_pun
<
Vec
<
4
float
>
>
(
c_
)
;
d
=
bit_pun
<
Vec
<
4
float
>
>
(
d_
)
;
}
#
endif
SIT
void
strided_load2
(
const
T
*
v
Vec
<
1
T
>
&
a
Vec
<
1
T
>
&
b
)
{
a
.
val
=
v
[
0
]
;
b
.
val
=
v
[
1
]
;
}
SINT
void
strided_load2
(
const
T
*
v
Vec
<
N
T
>
&
a
Vec
<
N
T
>
&
b
)
{
strided_load2
(
v
a
.
lo
b
.
lo
)
;
strided_load2
(
v
+
2
*
(
N
/
2
)
a
.
hi
b
.
hi
)
;
}
#
if
SKVX_USE_SIMD
&
&
defined
(
__ARM_NEON
)
#
define
IMPL_LOAD2_TRANSPOSED
(
N
T
VLD
)
\
SI
void
strided_load2
(
const
T
*
v
Vec
<
N
T
>
&
a
Vec
<
N
T
>
&
b
)
{
\
auto
mat
=
VLD
(
v
)
;
\
a
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
0
]
)
;
\
b
=
bit_pun
<
Vec
<
N
T
>
>
(
mat
.
val
[
1
]
)
;
\
}
IMPL_LOAD2_TRANSPOSED
(
2
uint32_t
vld2_u32
)
IMPL_LOAD2_TRANSPOSED
(
4
uint16_t
vld2_u16
)
IMPL_LOAD2_TRANSPOSED
(
8
uint8_t
vld2_u8
)
IMPL_LOAD2_TRANSPOSED
(
2
int32_t
vld2_s32
)
IMPL_LOAD2_TRANSPOSED
(
4
int16_t
vld2_s16
)
IMPL_LOAD2_TRANSPOSED
(
8
int8_t
vld2_s8
)
IMPL_LOAD2_TRANSPOSED
(
2
float
vld2_f32
)
IMPL_LOAD2_TRANSPOSED
(
4
uint32_t
vld2q_u32
)
IMPL_LOAD2_TRANSPOSED
(
8
uint16_t
vld2q_u16
)
IMPL_LOAD2_TRANSPOSED
(
16
uint8_t
vld2q_u8
)
IMPL_LOAD2_TRANSPOSED
(
4
int32_t
vld2q_s32
)
IMPL_LOAD2_TRANSPOSED
(
8
int16_t
vld2q_s16
)
IMPL_LOAD2_TRANSPOSED
(
16
int8_t
vld2q_s8
)
IMPL_LOAD2_TRANSPOSED
(
4
float
vld2q_f32
)
#
undef
IMPL_LOAD2_TRANSPOSED
#
endif
using
float2
=
Vec
<
2
float
>
;
using
float4
=
Vec
<
4
float
>
;
using
float8
=
Vec
<
8
float
>
;
using
double2
=
Vec
<
2
double
>
;
using
double4
=
Vec
<
4
double
>
;
using
double8
=
Vec
<
8
double
>
;
using
byte2
=
Vec
<
2
uint8_t
>
;
using
byte4
=
Vec
<
4
uint8_t
>
;
using
byte8
=
Vec
<
8
uint8_t
>
;
using
byte16
=
Vec
<
16
uint8_t
>
;
using
int2
=
Vec
<
2
int32_t
>
;
using
int4
=
Vec
<
4
int32_t
>
;
using
int8
=
Vec
<
8
int32_t
>
;
using
uint2
=
Vec
<
2
uint32_t
>
;
using
uint4
=
Vec
<
4
uint32_t
>
;
using
uint8
=
Vec
<
8
uint32_t
>
;
using
long2
=
Vec
<
2
int64_t
>
;
using
long4
=
Vec
<
4
int64_t
>
;
using
long8
=
Vec
<
8
int64_t
>
;
using
half2
=
Vec
<
2
uint16_t
>
;
using
half4
=
Vec
<
4
uint16_t
>
;
using
half8
=
Vec
<
8
uint16_t
>
;
}
#
undef
SINTU
#
undef
SINT
#
undef
SIN
#
undef
SIT
#
undef
SI
#
undef
SKVX_ALWAYS_INLINE
#
undef
SKVX_USE_SIMD
#
endif
