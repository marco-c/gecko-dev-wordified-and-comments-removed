#
ifndef
SkBlockAllocator_DEFINED
#
define
SkBlockAllocator_DEFINED
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
src
/
base
/
SkASAN
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
new
>
#
include
<
type_traits
>
class
SkBlockAllocator
final
:
SkNoncopyable
{
public
:
inline
static
constexpr
int
kMaxAllocationSize
=
1
<
<
29
;
enum
class
GrowthPolicy
:
int
{
kFixed
kLinear
kFibonacci
kExponential
kLast
=
kExponential
}
;
inline
static
constexpr
int
kGrowthPolicyCount
=
static_cast
<
int
>
(
GrowthPolicy
:
:
kLast
)
+
1
;
class
Block
final
{
public
:
~
Block
(
)
;
void
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
template
<
size_t
Align
=
1
size_t
Padding
=
0
>
int
avail
(
)
const
{
return
std
:
:
max
(
0
fSize
-
this
-
>
cursor
<
Align
Padding
>
(
)
)
;
}
template
<
size_t
Align
=
1
size_t
Padding
=
0
>
int
firstAlignedOffset
(
)
const
{
return
this
-
>
alignedOffset
<
Align
Padding
>
(
kDataStart
)
;
}
void
*
ptr
(
int
offset
)
{
SkASSERT
(
offset
>
=
kDataStart
&
&
offset
<
fSize
)
;
return
reinterpret_cast
<
char
*
>
(
this
)
+
offset
;
}
const
void
*
ptr
(
int
offset
)
const
{
return
const_cast
<
Block
*
>
(
this
)
-
>
ptr
(
offset
)
;
}
int
metadata
(
)
const
{
return
fMetadata
;
}
void
setMetadata
(
int
value
)
{
fMetadata
=
value
;
}
inline
bool
release
(
int
start
int
end
)
;
inline
bool
resize
(
int
start
int
end
int
deltaBytes
)
;
private
:
friend
class
SkBlockAllocator
;
Block
(
Block
*
prev
int
allocationSize
)
;
void
poisonRange
(
int
start
int
end
)
{
sk_asan_poison_memory_region
(
reinterpret_cast
<
char
*
>
(
this
)
+
start
end
-
start
)
;
}
void
unpoisonRange
(
int
start
int
end
)
{
sk_asan_unpoison_memory_region
(
reinterpret_cast
<
char
*
>
(
this
)
+
start
end
-
start
)
;
}
template
<
size_t
Align
size_t
Padding
>
int
cursor
(
)
const
{
return
this
-
>
alignedOffset
<
Align
Padding
>
(
fCursor
)
;
}
template
<
size_t
Align
size_t
Padding
>
int
alignedOffset
(
int
offset
)
const
;
bool
isScratch
(
)
const
{
return
fCursor
<
0
;
}
void
markAsScratch
(
)
{
fCursor
=
-
1
;
this
-
>
poisonRange
(
kDataStart
fSize
)
;
}
SkDEBUGCODE
(
uint32_t
fSentinel
;
)
Block
*
fNext
;
Block
*
fPrev
;
int
fSize
;
int
fCursor
;
int
fMetadata
;
int
fAllocatorMetadata
;
}
;
struct
ByteRange
{
Block
*
fBlock
;
int
fStart
;
int
fAlignedOffset
;
int
fEnd
;
}
;
SkBlockAllocator
(
GrowthPolicy
policy
size_t
blockIncrementBytes
size_t
additionalPreallocBytes
=
0
)
;
~
SkBlockAllocator
(
)
{
this
-
>
reset
(
)
;
}
void
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
template
<
size_t
Align
=
1
size_t
Padding
=
0
>
static
constexpr
size_t
BlockOverhead
(
)
;
template
<
size_t
Align
=
1
size_t
Padding
=
0
>
static
constexpr
size_t
Overhead
(
)
;
size_t
totalSize
(
)
const
;
size_t
totalUsableSpace
(
)
const
;
size_t
totalSpaceInUse
(
)
const
;
size_t
preallocSize
(
)
const
{
return
sizeof
(
SkBlockAllocator
)
+
fHead
.
fSize
-
BaseHeadBlockSize
(
)
;
}
size_t
preallocUsableSpace
(
)
const
{
return
fHead
.
fSize
-
kDataStart
;
}
int
metadata
(
)
const
{
return
fHead
.
fAllocatorMetadata
;
}
void
setMetadata
(
int
value
)
{
fHead
.
fAllocatorMetadata
=
value
;
}
template
<
size_t
Align
size_t
Padding
=
0
>
ByteRange
allocate
(
size_t
size
)
;
enum
ReserveFlags
:
unsigned
{
kIgnoreGrowthPolicy_Flag
=
0b01
kIgnoreExistingBytes_Flag
=
0b10
kNo_ReserveFlags
=
0b00
}
;
template
<
size_t
Align
=
1
size_t
Padding
=
0
>
void
reserve
(
size_t
size
ReserveFlags
flags
=
kNo_ReserveFlags
)
;
const
Block
*
currentBlock
(
)
const
{
return
fTail
;
}
Block
*
currentBlock
(
)
{
return
fTail
;
}
const
Block
*
headBlock
(
)
const
{
return
&
fHead
;
}
Block
*
headBlock
(
)
{
return
&
fHead
;
}
template
<
size_t
Align
size_t
Padding
=
0
>
Block
*
owningBlock
(
const
void
*
ptr
int
start
)
;
template
<
size_t
Align
size_t
Padding
=
0
>
const
Block
*
owningBlock
(
const
void
*
ptr
int
start
)
const
{
return
const_cast
<
SkBlockAllocator
*
>
(
this
)
-
>
owningBlock
<
Align
Padding
>
(
ptr
start
)
;
}
Block
*
findOwningBlock
(
const
void
*
ptr
)
;
const
Block
*
findOwningBlock
(
const
void
*
ptr
)
const
{
return
const_cast
<
SkBlockAllocator
*
>
(
this
)
-
>
findOwningBlock
(
ptr
)
;
}
void
releaseBlock
(
Block
*
block
)
;
void
stealHeapBlocks
(
SkBlockAllocator
*
other
)
;
void
reset
(
)
;
void
resetScratchSpace
(
)
;
template
<
bool
Forward
bool
Const
>
class
BlockIter
;
inline
BlockIter
<
true
false
>
blocks
(
)
;
inline
BlockIter
<
true
true
>
blocks
(
)
const
;
inline
BlockIter
<
false
false
>
rblocks
(
)
;
inline
BlockIter
<
false
true
>
rblocks
(
)
const
;
#
ifdef
SK_DEBUG
inline
static
constexpr
uint32_t
kAssignedMarker
=
0xBEEFFACE
;
inline
static
constexpr
uint32_t
kFreedMarker
=
0xCAFEBABE
;
void
validate
(
)
const
;
#
endif
private
:
friend
class
BlockAllocatorTestAccess
;
friend
class
TBlockListTestAccess
;
inline
static
constexpr
int
kDataStart
=
sizeof
(
Block
)
;
#
ifdef
SK_FORCE_8_BYTE_ALIGNMENT
inline
static
constexpr
size_t
kAddressAlign
=
8
;
#
else
inline
static
constexpr
size_t
kAddressAlign
=
alignof
(
std
:
:
max_align_t
)
;
#
endif
template
<
size_t
Align
size_t
Padding
>
static
constexpr
size_t
MaxBlockSize
(
)
;
static
constexpr
int
BaseHeadBlockSize
(
)
{
return
sizeof
(
SkBlockAllocator
)
-
offsetof
(
SkBlockAllocator
fHead
)
;
}
void
addBlock
(
int
minSize
int
maxSize
)
;
int
scratchBlockSize
(
)
const
{
return
fHead
.
fPrev
?
fHead
.
fPrev
-
>
fSize
:
0
;
}
Block
*
fTail
;
uint64_t
fBlockIncrement
:
16
;
uint64_t
fGrowthPolicy
:
2
;
uint64_t
fN0
:
23
;
uint64_t
fN1
:
23
;
alignas
(
kAddressAlign
)
Block
fHead
;
static_assert
(
kGrowthPolicyCount
<
=
4
)
;
}
;
template
<
size_t
N
>
class
SkSBlockAllocator
:
SkNoncopyable
{
public
:
using
GrowthPolicy
=
SkBlockAllocator
:
:
GrowthPolicy
;
SkSBlockAllocator
(
)
{
new
(
fStorage
)
SkBlockAllocator
(
GrowthPolicy
:
:
kFixed
N
N
-
sizeof
(
SkBlockAllocator
)
)
;
}
explicit
SkSBlockAllocator
(
GrowthPolicy
policy
)
{
new
(
fStorage
)
SkBlockAllocator
(
policy
N
N
-
sizeof
(
SkBlockAllocator
)
)
;
}
SkSBlockAllocator
(
GrowthPolicy
policy
size_t
blockIncrementBytes
)
{
new
(
fStorage
)
SkBlockAllocator
(
policy
blockIncrementBytes
N
-
sizeof
(
SkBlockAllocator
)
)
;
}
~
SkSBlockAllocator
(
)
{
this
-
>
allocator
(
)
-
>
~
SkBlockAllocator
(
)
;
}
SkBlockAllocator
*
operator
-
>
(
)
{
return
this
-
>
allocator
(
)
;
}
const
SkBlockAllocator
*
operator
-
>
(
)
const
{
return
this
-
>
allocator
(
)
;
}
SkBlockAllocator
*
allocator
(
)
{
return
reinterpret_cast
<
SkBlockAllocator
*
>
(
fStorage
)
;
}
const
SkBlockAllocator
*
allocator
(
)
const
{
return
reinterpret_cast
<
const
SkBlockAllocator
*
>
(
fStorage
)
;
}
private
:
static_assert
(
N
>
=
sizeof
(
SkBlockAllocator
)
)
;
alignas
(
SkBlockAllocator
)
char
fStorage
[
N
]
;
}
;
SK_MAKE_BITFIELD_OPS
(
SkBlockAllocator
:
:
ReserveFlags
)
template
<
size_t
Align
size_t
Padding
>
constexpr
size_t
SkBlockAllocator
:
:
BlockOverhead
(
)
{
static_assert
(
SkAlignTo
(
kDataStart
+
Padding
Align
)
>
=
sizeof
(
Block
)
)
;
return
SkAlignTo
(
kDataStart
+
Padding
Align
)
;
}
template
<
size_t
Align
size_t
Padding
>
constexpr
size_t
SkBlockAllocator
:
:
Overhead
(
)
{
return
std
:
:
max
(
sizeof
(
SkBlockAllocator
)
offsetof
(
SkBlockAllocator
fHead
)
+
BlockOverhead
<
Align
Padding
>
(
)
)
;
}
template
<
size_t
Align
size_t
Padding
>
constexpr
size_t
SkBlockAllocator
:
:
MaxBlockSize
(
)
{
return
BlockOverhead
<
Align
Padding
>
(
)
+
kMaxAllocationSize
;
}
template
<
size_t
Align
size_t
Padding
>
void
SkBlockAllocator
:
:
reserve
(
size_t
size
ReserveFlags
flags
)
{
if
(
size
>
kMaxAllocationSize
)
{
SK_ABORT
(
"
Allocation
too
large
(
%
zu
bytes
requested
)
"
size
)
;
}
int
iSize
=
(
int
)
size
;
if
(
(
flags
&
kIgnoreExistingBytes_Flag
)
|
|
this
-
>
currentBlock
(
)
-
>
avail
<
Align
Padding
>
(
)
<
iSize
)
{
int
blockSize
=
BlockOverhead
<
Align
Padding
>
(
)
+
iSize
;
int
maxSize
=
(
flags
&
kIgnoreGrowthPolicy_Flag
)
?
blockSize
:
MaxBlockSize
<
Align
Padding
>
(
)
;
SkASSERT
(
(
size_t
)
maxSize
<
=
(
MaxBlockSize
<
Align
Padding
>
(
)
)
)
;
SkDEBUGCODE
(
auto
oldTail
=
fTail
;
)
this
-
>
addBlock
(
blockSize
maxSize
)
;
SkASSERT
(
fTail
!
=
oldTail
)
;
this
-
>
releaseBlock
(
fTail
)
;
}
}
template
<
size_t
Align
size_t
Padding
>
SkBlockAllocator
:
:
ByteRange
SkBlockAllocator
:
:
allocate
(
size_t
size
)
{
static
constexpr
int
kBlockOverhead
=
(
int
)
BlockOverhead
<
Align
Padding
>
(
)
;
static_assert
(
(
kMaxAllocationSize
+
SkAlignTo
(
MaxBlockSize
<
Align
Padding
>
(
)
Align
)
)
<
=
(
size_t
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
static_assert
(
kMaxAllocationSize
+
kBlockOverhead
+
(
(
1
<
<
12
)
-
1
)
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
if
(
size
>
kMaxAllocationSize
)
{
SK_ABORT
(
"
Allocation
too
large
(
%
zu
bytes
requested
)
"
size
)
;
}
int
iSize
=
(
int
)
size
;
int
offset
=
fTail
-
>
cursor
<
Align
Padding
>
(
)
;
int
end
=
offset
+
iSize
;
if
(
end
>
fTail
-
>
fSize
)
{
this
-
>
addBlock
(
iSize
+
kBlockOverhead
MaxBlockSize
<
Align
Padding
>
(
)
)
;
offset
=
fTail
-
>
cursor
<
Align
Padding
>
(
)
;
end
=
offset
+
iSize
;
}
SkASSERT
(
end
<
=
fTail
-
>
fSize
)
;
SkASSERT
(
end
-
offset
=
=
iSize
)
;
SkASSERT
(
offset
-
fTail
-
>
fCursor
>
=
(
int
)
Padding
&
&
offset
-
fTail
-
>
fCursor
<
=
(
int
)
(
Padding
+
Align
-
1
)
)
;
SkASSERT
(
reinterpret_cast
<
uintptr_t
>
(
fTail
-
>
ptr
(
offset
)
)
%
Align
=
=
0
)
;
int
start
=
fTail
-
>
fCursor
;
fTail
-
>
fCursor
=
end
;
fTail
-
>
unpoisonRange
(
offset
-
Padding
end
)
;
return
{
fTail
start
offset
end
}
;
}
template
<
size_t
Align
size_t
Padding
>
SkBlockAllocator
:
:
Block
*
SkBlockAllocator
:
:
owningBlock
(
const
void
*
p
int
start
)
{
if
(
Align
<
=
kAddressAlign
)
{
Block
*
block
=
reinterpret_cast
<
Block
*
>
(
(
reinterpret_cast
<
uintptr_t
>
(
p
)
-
start
-
Padding
)
&
~
(
Align
-
1
)
)
;
SkASSERT
(
block
-
>
fSentinel
=
=
kAssignedMarker
)
;
return
block
;
}
else
{
return
this
-
>
findOwningBlock
(
p
)
;
}
}
template
<
size_t
Align
size_t
Padding
>
int
SkBlockAllocator
:
:
Block
:
:
alignedOffset
(
int
offset
)
const
{
static_assert
(
SkIsPow2
(
Align
)
)
;
static_assert
(
MaxBlockSize
<
Align
Padding
>
(
)
+
Padding
+
Align
-
1
<
=
(
size_t
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
if
(
Align
<
=
kAddressAlign
)
{
return
(
offset
+
Padding
+
Align
-
1
)
&
~
(
Align
-
1
)
;
}
else
{
uintptr_t
blockPtr
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
uintptr_t
alignedPtr
=
(
blockPtr
+
offset
+
Padding
+
Align
-
1
)
&
~
(
Align
-
1
)
;
SkASSERT
(
alignedPtr
-
blockPtr
<
=
(
uintptr_t
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
return
(
int
)
(
alignedPtr
-
blockPtr
)
;
}
}
bool
SkBlockAllocator
:
:
Block
:
:
resize
(
int
start
int
end
int
deltaBytes
)
{
SkASSERT
(
fSentinel
=
=
kAssignedMarker
)
;
SkASSERT
(
start
>
=
kDataStart
&
&
end
<
=
fSize
&
&
start
<
end
)
;
if
(
deltaBytes
>
kMaxAllocationSize
|
|
deltaBytes
<
-
kMaxAllocationSize
)
{
return
false
;
}
if
(
fCursor
=
=
end
)
{
int
nextCursor
=
end
+
deltaBytes
;
SkASSERT
(
nextCursor
>
=
start
)
;
if
(
nextCursor
<
=
fSize
&
&
nextCursor
>
=
start
)
{
if
(
nextCursor
<
fCursor
)
{
this
-
>
poisonRange
(
nextCursor
+
1
end
)
;
}
else
{
this
-
>
unpoisonRange
(
end
nextCursor
)
;
}
fCursor
=
nextCursor
;
return
true
;
}
}
return
false
;
}
bool
SkBlockAllocator
:
:
Block
:
:
release
(
int
start
int
end
)
{
SkASSERT
(
fSentinel
=
=
kAssignedMarker
)
;
SkASSERT
(
start
>
=
kDataStart
&
&
end
<
=
fSize
&
&
start
<
end
)
;
this
-
>
poisonRange
(
start
end
)
;
if
(
fCursor
=
=
end
)
{
fCursor
=
start
;
return
true
;
}
else
{
return
false
;
}
}
template
<
bool
Forward
bool
Const
>
class
SkBlockAllocator
:
:
BlockIter
{
private
:
using
BlockT
=
typename
std
:
:
conditional
<
Const
const
Block
Block
>
:
:
type
;
using
AllocatorT
=
typename
std
:
:
conditional
<
Const
const
SkBlockAllocator
SkBlockAllocator
>
:
:
type
;
public
:
BlockIter
(
AllocatorT
*
allocator
)
:
fAllocator
(
allocator
)
{
}
class
Item
{
public
:
bool
operator
!
=
(
const
Item
&
other
)
const
{
return
fBlock
!
=
other
.
fBlock
;
}
BlockT
*
operator
*
(
)
const
{
return
fBlock
;
}
Item
&
operator
+
+
(
)
{
this
-
>
advance
(
fNext
)
;
return
*
this
;
}
private
:
friend
BlockIter
;
Item
(
BlockT
*
block
)
{
this
-
>
advance
(
block
)
;
}
void
advance
(
BlockT
*
block
)
{
fBlock
=
block
;
fNext
=
block
?
(
Forward
?
block
-
>
fNext
:
block
-
>
fPrev
)
:
nullptr
;
if
(
!
Forward
&
&
fNext
&
&
fNext
-
>
isScratch
(
)
)
{
fNext
=
nullptr
;
}
SkASSERT
(
!
fNext
|
|
!
fNext
-
>
isScratch
(
)
)
;
}
BlockT
*
fBlock
;
BlockT
*
fNext
;
}
;
Item
begin
(
)
const
{
return
Item
(
Forward
?
&
fAllocator
-
>
fHead
:
fAllocator
-
>
fTail
)
;
}
Item
end
(
)
const
{
return
Item
(
nullptr
)
;
}
private
:
AllocatorT
*
fAllocator
;
}
;
SkBlockAllocator
:
:
BlockIter
<
true
false
>
SkBlockAllocator
:
:
blocks
(
)
{
return
BlockIter
<
true
false
>
(
this
)
;
}
SkBlockAllocator
:
:
BlockIter
<
true
true
>
SkBlockAllocator
:
:
blocks
(
)
const
{
return
BlockIter
<
true
true
>
(
this
)
;
}
SkBlockAllocator
:
:
BlockIter
<
false
false
>
SkBlockAllocator
:
:
rblocks
(
)
{
return
BlockIter
<
false
false
>
(
this
)
;
}
SkBlockAllocator
:
:
BlockIter
<
false
true
>
SkBlockAllocator
:
:
rblocks
(
)
const
{
return
BlockIter
<
false
true
>
(
this
)
;
}
#
endif
