#
ifndef
SkMathPriv_DEFINED
#
define
SkMathPriv_DEFINED
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkCPUTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
int32_t
SkSqrtBits
(
int32_t
value
int
bitBias
)
;
static
inline
int32_t
SkSqrt32
(
int32_t
n
)
{
return
SkSqrtBits
(
n
15
)
;
}
static
inline
int
SkClampPos
(
int
value
)
{
return
value
&
~
(
value
>
>
31
)
;
}
template
<
typename
In
typename
Out
>
inline
void
SkTDivMod
(
In
numer
In
denom
Out
*
div
Out
*
mod
)
{
*
div
=
static_cast
<
Out
>
(
numer
/
denom
)
;
*
mod
=
static_cast
<
Out
>
(
numer
%
denom
)
;
}
#
define
SkExtractSign
(
n
)
(
(
int32_t
)
(
n
)
>
>
31
)
static
inline
int32_t
SkApplySign
(
int32_t
n
int32_t
sign
)
{
SkASSERT
(
sign
=
=
0
|
|
sign
=
=
-
1
)
;
return
(
n
^
sign
)
-
sign
;
}
static
inline
int32_t
SkCopySign32
(
int32_t
x
int32_t
y
)
{
return
SkApplySign
(
x
SkExtractSign
(
x
^
y
)
)
;
}
static
inline
unsigned
SkClampUMax
(
unsigned
value
unsigned
max
)
{
if
(
value
>
max
)
{
value
=
max
;
}
return
value
;
}
static
inline
size_t
sk_negate_to_size_t
(
int32_t
value
)
{
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4146
)
/
/
Thanks
MSVC
we
know
what
we
'
re
negating
an
unsigned
#
endif
return
-
static_cast
<
size_t
>
(
value
)
;
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
pop
)
#
endif
}
static
inline
U8CPU
SkMulDiv255Trunc
(
U8CPU
a
U8CPU
b
)
{
SkASSERT
(
(
uint8_t
)
a
=
=
a
)
;
SkASSERT
(
(
uint8_t
)
b
=
=
b
)
;
unsigned
prod
=
a
*
b
+
1
;
return
(
prod
+
(
prod
>
>
8
)
)
>
>
8
;
}
static
inline
U8CPU
SkMulDiv255Ceiling
(
U8CPU
a
U8CPU
b
)
{
SkASSERT
(
(
uint8_t
)
a
=
=
a
)
;
SkASSERT
(
(
uint8_t
)
b
=
=
b
)
;
unsigned
prod
=
a
*
b
+
255
;
return
(
prod
+
(
prod
>
>
8
)
)
>
>
8
;
}
static
inline
unsigned
SkDiv255Round
(
unsigned
prod
)
{
prod
+
=
128
;
return
(
prod
+
(
prod
>
>
8
)
)
>
>
8
;
}
#
if
defined
(
_MSC_VER
)
#
include
<
stdlib
.
h
>
static
inline
uint32_t
SkBSwap32
(
uint32_t
v
)
{
return
_byteswap_ulong
(
v
)
;
}
#
else
static
inline
uint32_t
SkBSwap32
(
uint32_t
v
)
{
return
__builtin_bswap32
(
v
)
;
}
#
endif
int
SkPopCount_portable
(
uint32_t
n
)
;
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
static
inline
int
SkPopCount
(
uint32_t
n
)
{
return
__builtin_popcount
(
n
)
;
}
#
else
static
inline
int
SkPopCount
(
uint32_t
n
)
{
return
SkPopCount_portable
(
n
)
;
}
#
endif
int
SkNthSet
(
uint32_t
target
int
n
)
;
constexpr
int
SkCLZ_portable
(
uint32_t
x
)
{
int
n
=
32
;
uint32_t
y
=
x
>
>
16
;
if
(
y
!
=
0
)
{
n
-
=
16
;
x
=
y
;
}
y
=
x
>
>
8
;
if
(
y
!
=
0
)
{
n
-
=
8
;
x
=
y
;
}
y
=
x
>
>
4
;
if
(
y
!
=
0
)
{
n
-
=
4
;
x
=
y
;
}
y
=
x
>
>
2
;
if
(
y
!
=
0
)
{
n
-
=
2
;
x
=
y
;
}
y
=
x
>
>
1
;
if
(
y
!
=
0
)
{
return
n
-
2
;
}
return
n
-
static_cast
<
int
>
(
x
)
;
}
static_assert
(
32
=
=
SkCLZ_portable
(
0
)
)
;
static_assert
(
31
=
=
SkCLZ_portable
(
1
)
)
;
static_assert
(
1
=
=
SkCLZ_portable
(
1
<
<
30
)
)
;
static_assert
(
1
=
=
SkCLZ_portable
(
(
1
<
<
30
)
|
(
1
<
<
24
)
|
1
)
)
;
static_assert
(
0
=
=
SkCLZ_portable
(
~
0U
)
)
;
#
if
defined
(
SK_BUILD_FOR_WIN
)
#
include
<
intrin
.
h
>
static
inline
int
SkCLZ
(
uint32_t
mask
)
{
if
(
mask
)
{
unsigned
long
index
=
0
;
_BitScanReverse
(
&
index
mask
)
;
#
pragma
warning
(
push
)
#
pragma
warning
(
suppress
:
6102
)
/
/
Using
'
index
'
from
failed
function
call
return
static_cast
<
int
>
(
index
^
0x1F
)
;
#
pragma
warning
(
pop
)
}
else
{
return
32
;
}
}
#
elif
defined
(
SK_CPU_ARM32
)
|
|
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
static
inline
int
SkCLZ
(
uint32_t
mask
)
{
return
mask
?
__builtin_clz
(
mask
)
:
32
;
}
#
else
static
inline
int
SkCLZ
(
uint32_t
mask
)
{
return
SkCLZ_portable
(
mask
)
;
}
#
endif
constexpr
int
SkCTZ_portable
(
uint32_t
x
)
{
return
32
-
SkCLZ_portable
(
~
x
&
(
x
-
1
)
)
;
}
static_assert
(
32
=
=
SkCTZ_portable
(
0
)
)
;
static_assert
(
0
=
=
SkCTZ_portable
(
1
)
)
;
static_assert
(
30
=
=
SkCTZ_portable
(
1
<
<
30
)
)
;
static_assert
(
2
=
=
SkCTZ_portable
(
(
1
<
<
30
)
|
(
1
<
<
24
)
|
(
1
<
<
2
)
)
)
;
static_assert
(
0
=
=
SkCTZ_portable
(
~
0U
)
)
;
#
if
defined
(
SK_BUILD_FOR_WIN
)
#
include
<
intrin
.
h
>
static
inline
int
SkCTZ
(
uint32_t
mask
)
{
if
(
mask
)
{
unsigned
long
index
=
0
;
_BitScanForward
(
&
index
mask
)
;
#
pragma
warning
(
push
)
#
pragma
warning
(
suppress
:
6102
)
/
/
Using
'
index
'
from
failed
function
call
return
static_cast
<
int
>
(
index
)
;
#
pragma
warning
(
pop
)
}
else
{
return
32
;
}
}
#
elif
defined
(
SK_CPU_ARM32
)
|
|
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
static
inline
int
SkCTZ
(
uint32_t
mask
)
{
return
mask
?
__builtin_ctz
(
mask
)
:
32
;
}
#
else
static
inline
int
SkCTZ
(
uint32_t
mask
)
{
return
SkCTZ_portable
(
mask
)
;
}
#
endif
static
inline
int
SkNextLog2
(
uint32_t
value
)
{
SkASSERT
(
value
!
=
0
)
;
return
32
-
SkCLZ
(
value
-
1
)
;
}
constexpr
int
SkNextLog2_portable
(
uint32_t
value
)
{
SkASSERT
(
value
!
=
0
)
;
return
32
-
SkCLZ_portable
(
value
-
1
)
;
}
static
inline
int
SkPrevLog2
(
uint32_t
value
)
{
SkASSERT
(
value
!
=
0
)
;
return
32
-
SkCLZ
(
value
>
>
1
)
;
}
constexpr
int
SkPrevLog2_portable
(
uint32_t
value
)
{
SkASSERT
(
value
!
=
0
)
;
return
32
-
SkCLZ_portable
(
value
>
>
1
)
;
}
static
inline
int
SkNextPow2
(
int
value
)
{
SkASSERT
(
value
>
0
)
;
return
1
<
<
SkNextLog2
(
static_cast
<
uint32_t
>
(
value
)
)
;
}
constexpr
int
SkNextPow2_portable
(
int
value
)
{
SkASSERT
(
value
>
0
)
;
return
1
<
<
SkNextLog2_portable
(
static_cast
<
uint32_t
>
(
value
)
)
;
}
static
inline
int
SkPrevPow2
(
int
value
)
{
SkASSERT
(
value
>
0
)
;
return
1
<
<
SkPrevLog2
(
static_cast
<
uint32_t
>
(
value
)
)
;
}
constexpr
int
SkPrevPow2_portable
(
int
value
)
{
SkASSERT
(
value
>
0
)
;
return
1
<
<
SkPrevLog2_portable
(
static_cast
<
uint32_t
>
(
value
)
)
;
}
constexpr
size_t
SkNextSizePow2
(
size_t
n
)
{
constexpr
int
kNumSizeTBits
=
8
*
sizeof
(
size_t
)
;
constexpr
size_t
kHighBitSet
=
size_t
(
1
)
<
<
(
kNumSizeTBits
-
1
)
;
if
(
!
n
)
{
return
1
;
}
else
if
(
n
>
=
kHighBitSet
)
{
return
n
;
}
n
-
-
;
uint32_t
shift
=
1
;
while
(
shift
<
kNumSizeTBits
)
{
n
|
=
n
>
>
shift
;
shift
<
<
=
1
;
}
return
n
+
1
;
}
template
<
typename
T
>
static
inline
bool
SkFitsInFixed
(
T
x
)
{
return
SkTAbs
(
x
)
<
=
32767
.
0f
;
}
#
endif
