#
ifndef
SkNoDestructor_DEFINED
#
define
SkNoDestructor_DEFINED
#
include
<
cstddef
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
template
<
typename
T
>
class
SkNoDestructor
{
public
:
static_assert
(
!
(
std
:
:
is_trivially_constructible_v
<
T
>
&
&
std
:
:
is_trivially_destructible_v
<
T
>
)
"
T
is
trivially
constructible
and
destructible
;
please
use
a
constinit
object
of
"
"
type
T
directly
instead
"
)
;
static_assert
(
!
std
:
:
is_trivially_destructible_v
<
T
>
"
T
is
trivially
destructible
;
please
use
a
function
-
local
static
of
type
T
"
"
directly
instead
"
)
;
template
<
typename
.
.
.
Args
>
explicit
SkNoDestructor
(
Args
&
&
.
.
.
args
)
{
new
(
fStorage
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
explicit
SkNoDestructor
(
const
T
&
x
)
{
new
(
fStorage
)
T
(
x
)
;
}
explicit
SkNoDestructor
(
T
&
&
x
)
{
new
(
fStorage
)
T
(
std
:
:
move
(
x
)
)
;
}
SkNoDestructor
(
const
SkNoDestructor
&
)
=
delete
;
SkNoDestructor
&
operator
=
(
const
SkNoDestructor
&
)
=
delete
;
~
SkNoDestructor
(
)
=
default
;
const
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
&
operator
*
(
)
{
return
*
get
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
{
return
get
(
)
;
}
const
T
*
get
(
)
const
{
return
reinterpret_cast
<
const
T
*
>
(
fStorage
)
;
}
T
*
get
(
)
{
return
reinterpret_cast
<
T
*
>
(
fStorage
)
;
}
private
:
alignas
(
T
)
std
:
:
byte
fStorage
[
sizeof
(
T
)
]
;
#
if
defined
(
__clang__
)
&
&
defined
(
__has_feature
)
#
if
__has_feature
(
leak_sanitizer
)
|
|
__has_feature
(
address_sanitizer
)
T
*
fStoragePtr
=
reinterpret_cast
<
T
*
>
(
fStorage
)
;
#
endif
#
endif
}
;
#
endif
