#
include
"
include
/
private
/
base
/
SkSemaphore
.
h
"
#
include
"
include
/
private
/
base
/
SkFeatures
.
h
"
#
if
defined
(
SK_BUILD_FOR_MAC
)
|
|
defined
(
SK_BUILD_FOR_IOS
)
#
include
<
dispatch
/
dispatch
.
h
>
struct
SkSemaphore
:
:
OSSemaphore
{
dispatch_semaphore_t
fSemaphore
;
OSSemaphore
(
)
{
fSemaphore
=
dispatch_semaphore_create
(
0
)
;
}
~
OSSemaphore
(
)
{
dispatch_release
(
fSemaphore
)
;
}
void
signal
(
int
n
)
{
while
(
n
-
-
>
0
)
{
dispatch_semaphore_signal
(
fSemaphore
)
;
}
}
void
wait
(
)
{
dispatch_semaphore_wait
(
fSemaphore
DISPATCH_TIME_FOREVER
)
;
}
}
;
#
elif
defined
(
SK_BUILD_FOR_WIN
)
#
include
"
src
/
base
/
SkLeanWindows
.
h
"
struct
SkSemaphore
:
:
OSSemaphore
{
HANDLE
fSemaphore
;
OSSemaphore
(
)
{
fSemaphore
=
CreateSemaphore
(
nullptr
0
MAXLONG
nullptr
)
;
}
~
OSSemaphore
(
)
{
CloseHandle
(
fSemaphore
)
;
}
void
signal
(
int
n
)
{
ReleaseSemaphore
(
fSemaphore
n
nullptr
)
;
}
void
wait
(
)
{
WaitForSingleObject
(
fSemaphore
INFINITE
)
;
}
}
;
#
else
#
include
<
errno
.
h
>
#
include
<
semaphore
.
h
>
struct
SkSemaphore
:
:
OSSemaphore
{
sem_t
fSemaphore
;
OSSemaphore
(
)
{
sem_init
(
&
fSemaphore
0
0
)
;
}
~
OSSemaphore
(
)
{
sem_destroy
(
&
fSemaphore
)
;
}
void
signal
(
int
n
)
{
while
(
n
-
-
>
0
)
{
sem_post
(
&
fSemaphore
)
;
}
}
void
wait
(
)
{
while
(
sem_wait
(
&
fSemaphore
)
=
=
-
1
&
&
errno
=
=
EINTR
)
;
}
}
;
#
endif
SkSemaphore
:
:
~
SkSemaphore
(
)
{
delete
fOSSemaphore
;
}
void
SkSemaphore
:
:
osSignal
(
int
n
)
{
fOSSemaphoreOnce
(
[
this
]
{
fOSSemaphore
=
new
OSSemaphore
;
}
)
;
fOSSemaphore
-
>
signal
(
n
)
;
}
void
SkSemaphore
:
:
osWait
(
)
{
fOSSemaphoreOnce
(
[
this
]
{
fOSSemaphore
=
new
OSSemaphore
;
}
)
;
fOSSemaphore
-
>
wait
(
)
;
}
bool
SkSemaphore
:
:
try_wait
(
)
{
int
count
=
fCount
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
count
>
0
)
{
return
fCount
.
compare_exchange_weak
(
count
count
-
1
std
:
:
memory_order_acquire
)
;
}
return
false
;
}
