#
include
"
src
/
base
/
SkQuads
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
<
cmath
>
#
include
<
limits
>
static
int
solve_linear
(
const
double
M
const
double
B
double
solution
[
2
]
)
{
if
(
sk_double_nearly_zero
(
M
)
)
{
solution
[
0
]
=
0
;
if
(
sk_double_nearly_zero
(
B
)
)
{
return
1
;
}
return
0
;
}
solution
[
0
]
=
-
B
/
M
;
if
(
!
std
:
:
isfinite
(
solution
[
0
]
)
)
{
return
0
;
}
return
1
;
}
static
bool
close_to_linear
(
double
A
double
B
)
{
if
(
A
!
=
0
)
{
return
std
:
:
abs
(
B
/
A
)
>
=
1
.
0e
+
16
;
}
return
true
;
}
double
SkQuads
:
:
Discriminant
(
const
double
a
const
double
b
const
double
c
)
{
const
double
b2
=
b
*
b
;
const
double
ac
=
a
*
c
;
const
double
roughDiscriminant
=
b2
-
ac
;
if
(
3
*
std
:
:
abs
(
roughDiscriminant
)
>
=
b2
+
ac
)
{
return
roughDiscriminant
;
}
const
double
b2RoundingError
=
std
:
:
fma
(
b
b
-
b2
)
;
const
double
acRoundingError
=
std
:
:
fma
(
a
c
-
ac
)
;
const
double
discriminant
=
(
b2
-
ac
)
+
(
b2RoundingError
-
acRoundingError
)
;
return
discriminant
;
}
SkQuads
:
:
RootResult
SkQuads
:
:
Roots
(
double
A
double
B
double
C
)
{
const
double
discriminant
=
Discriminant
(
A
B
C
)
;
if
(
A
=
=
0
)
{
double
root
;
if
(
B
=
=
0
)
{
if
(
C
=
=
0
)
{
root
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
else
{
root
=
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
}
else
{
root
=
C
/
(
2
*
B
)
;
}
return
{
discriminant
root
root
}
;
}
SkASSERT
(
A
!
=
0
)
;
if
(
discriminant
=
=
0
)
{
return
{
discriminant
B
/
A
B
/
A
}
;
}
if
(
discriminant
>
0
)
{
const
double
D
=
sqrt
(
discriminant
)
;
const
double
R
=
B
>
0
?
B
+
D
:
B
-
D
;
return
{
discriminant
R
/
A
C
/
R
}
;
}
return
{
discriminant
NAN
NAN
}
;
}
static
double
zero_if_tiny
(
double
x
)
{
return
sk_double_nearly_zero
(
x
)
?
0
:
x
;
}
int
SkQuads
:
:
RootsReal
(
const
double
A
const
double
B
const
double
C
double
solution
[
2
]
)
{
if
(
close_to_linear
(
A
B
)
)
{
return
solve_linear
(
B
C
solution
)
;
}
SkASSERT
(
A
!
=
0
)
;
auto
[
discriminant
root0
root1
]
=
Roots
(
A
-
0
.
5
*
B
C
)
;
if
(
!
std
:
:
isfinite
(
discriminant
)
|
|
discriminant
<
0
)
{
return
0
;
}
int
roots
=
0
;
if
(
const
double
r0
=
zero_if_tiny
(
root0
)
;
std
:
:
isfinite
(
r0
)
)
{
solution
[
roots
+
+
]
=
r0
;
}
if
(
const
double
r1
=
zero_if_tiny
(
root1
)
;
std
:
:
isfinite
(
r1
)
)
{
solution
[
roots
+
+
]
=
r1
;
}
if
(
roots
=
=
2
&
&
sk_doubles_nearly_equal_ulps
(
solution
[
0
]
solution
[
1
]
)
)
{
roots
=
1
;
}
return
roots
;
}
double
SkQuads
:
:
EvalAt
(
double
A
double
B
double
C
double
t
)
{
return
std
:
:
fma
(
std
:
:
fma
(
A
t
B
)
t
C
)
;
}
