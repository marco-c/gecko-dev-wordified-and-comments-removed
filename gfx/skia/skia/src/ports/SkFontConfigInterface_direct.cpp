#
include
"
SkBuffer
.
h
"
#
include
"
SkDataTable
.
h
"
#
include
"
SkFontConfigInterface_direct
.
h
"
#
include
"
SkFontStyle
.
h
"
#
include
"
SkMutex
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkString
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTypeface
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
fontconfig
/
fontconfig
.
h
>
#
include
<
unistd
.
h
>
size_t
SkFontConfigInterface
:
:
FontIdentity
:
:
writeToMemory
(
void
*
addr
)
const
{
size_t
size
=
sizeof
(
fID
)
+
sizeof
(
fTTCIndex
)
;
size
+
=
sizeof
(
int32_t
)
+
sizeof
(
int32_t
)
+
sizeof
(
uint8_t
)
;
size
+
=
sizeof
(
int32_t
)
+
fString
.
size
(
)
;
if
(
addr
)
{
SkWBuffer
buffer
(
addr
size
)
;
buffer
.
write32
(
fID
)
;
buffer
.
write32
(
fTTCIndex
)
;
buffer
.
write32
(
fString
.
size
(
)
)
;
buffer
.
write32
(
fStyle
.
weight
(
)
)
;
buffer
.
write32
(
fStyle
.
width
(
)
)
;
buffer
.
write8
(
fStyle
.
slant
(
)
)
;
buffer
.
write
(
fString
.
c_str
(
)
fString
.
size
(
)
)
;
buffer
.
padToAlign4
(
)
;
SkASSERT
(
buffer
.
pos
(
)
=
=
size
)
;
}
return
size
;
}
size_t
SkFontConfigInterface
:
:
FontIdentity
:
:
readFromMemory
(
const
void
*
addr
size_t
size
)
{
SkRBuffer
buffer
(
addr
size
)
;
(
void
)
buffer
.
readU32
(
&
fID
)
;
(
void
)
buffer
.
readS32
(
&
fTTCIndex
)
;
uint32_t
strLen
weight
width
;
(
void
)
buffer
.
readU32
(
&
strLen
)
;
(
void
)
buffer
.
readU32
(
&
weight
)
;
(
void
)
buffer
.
readU32
(
&
width
)
;
uint8_t
u8
;
(
void
)
buffer
.
readU8
(
&
u8
)
;
SkFontStyle
:
:
Slant
slant
=
(
SkFontStyle
:
:
Slant
)
u8
;
fStyle
=
SkFontStyle
(
weight
width
slant
)
;
fString
.
resize
(
strLen
)
;
(
void
)
buffer
.
read
(
fString
.
writable_str
(
)
strLen
)
;
buffer
.
skipToAlign4
(
)
;
return
buffer
.
pos
(
)
;
}
#
ifdef
SK_DEBUG
static
void
make_iden
(
SkFontConfigInterface
:
:
FontIdentity
*
iden
)
{
iden
-
>
fID
=
10
;
iden
-
>
fTTCIndex
=
2
;
iden
-
>
fString
.
set
(
"
Hello
world
"
)
;
iden
-
>
fStyle
=
SkFontStyle
(
300
6
SkFontStyle
:
:
kItalic_Slant
)
;
}
static
void
test_writeToMemory
(
const
SkFontConfigInterface
:
:
FontIdentity
&
iden0
int
initValue
)
{
SkFontConfigInterface
:
:
FontIdentity
iden1
;
size_t
size0
=
iden0
.
writeToMemory
(
nullptr
)
;
SkAutoMalloc
storage
(
size0
)
;
memset
(
storage
.
get
(
)
initValue
size0
)
;
size_t
size1
=
iden0
.
writeToMemory
(
storage
.
get
(
)
)
;
SkASSERT
(
size0
=
=
size1
)
;
SkASSERT
(
iden0
!
=
iden1
)
;
size_t
size2
=
iden1
.
readFromMemory
(
storage
.
get
(
)
size1
)
;
SkASSERT
(
size2
=
=
size1
)
;
SkASSERT
(
iden0
=
=
iden1
)
;
}
static
void
fontconfiginterface_unittest
(
)
{
SkFontConfigInterface
:
:
FontIdentity
iden0
iden1
;
SkASSERT
(
iden0
=
=
iden1
)
;
make_iden
(
&
iden0
)
;
SkASSERT
(
iden0
!
=
iden1
)
;
make_iden
(
&
iden1
)
;
SkASSERT
(
iden0
=
=
iden1
)
;
test_writeToMemory
(
iden0
0
)
;
test_writeToMemory
(
iden0
0
)
;
}
#
endif
static
const
char
*
get_name
(
FcPattern
*
pattern
const
char
field
[
]
int
index
=
0
)
{
const
char
*
name
;
if
(
FcPatternGetString
(
pattern
field
index
(
FcChar8
*
*
)
&
name
)
!
=
FcResultMatch
)
{
name
=
nullptr
;
}
return
name
;
}
namespace
{
enum
FontEquivClass
{
OTHER
SANS
SERIF
MONO
SYMBOL
PGOTHIC
GOTHIC
PMINCHO
MINCHO
SIMSUN
NSIMSUN
SIMHEI
PMINGLIU
MINGLIU
PMINGLIUHK
MINGLIUHK
CAMBRIA
CALIBRI
}
;
FontEquivClass
GetFontEquivClass
(
const
char
*
fontname
)
{
struct
FontEquivMap
{
FontEquivClass
clazz
;
const
char
name
[
40
]
;
}
;
static
const
FontEquivMap
kFontEquivMap
[
]
=
{
{
SANS
"
Arial
"
}
{
SANS
"
Arimo
"
}
{
SANS
"
Liberation
Sans
"
}
{
SERIF
"
Times
New
Roman
"
}
{
SERIF
"
Tinos
"
}
{
SERIF
"
Liberation
Serif
"
}
{
MONO
"
Courier
New
"
}
{
MONO
"
Cousine
"
}
{
MONO
"
Liberation
Mono
"
}
{
SYMBOL
"
Symbol
"
}
{
SYMBOL
"
Symbol
Neu
"
}
{
PGOTHIC
"
MS
PGothic
"
}
{
PGOTHIC
"
\
xef
\
xbc
\
xad
\
xef
\
xbc
\
xb3
\
xef
\
xbc
\
xb0
"
"
\
xe3
\
x82
\
xb4
\
xe3
\
x82
\
xb7
\
xe3
\
x83
\
x83
\
xe3
\
x82
\
xaf
"
}
{
PGOTHIC
"
Noto
Sans
CJK
JP
"
}
{
PGOTHIC
"
IPAPGothic
"
}
{
PGOTHIC
"
MotoyaG04Gothic
"
}
{
GOTHIC
"
MS
Gothic
"
}
{
GOTHIC
"
\
xef
\
xbc
\
xad
\
xef
\
xbc
\
xb3
"
"
\
xe3
\
x82
\
xb4
\
xe3
\
x82
\
xb7
\
xe3
\
x83
\
x83
\
xe3
\
x82
\
xaf
"
}
{
GOTHIC
"
Noto
Sans
Mono
CJK
JP
"
}
{
GOTHIC
"
IPAGothic
"
}
{
GOTHIC
"
MotoyaG04GothicMono
"
}
{
PMINCHO
"
MS
PMincho
"
}
{
PMINCHO
"
\
xef
\
xbc
\
xad
\
xef
\
xbc
\
xb3
\
xef
\
xbc
\
xb0
"
"
\
xe6
\
x98
\
x8e
\
xe6
\
x9c
\
x9d
"
}
{
PMINCHO
"
IPAPMincho
"
}
{
PMINCHO
"
MotoyaG04Mincho
"
}
{
MINCHO
"
MS
Mincho
"
}
{
MINCHO
"
\
xef
\
xbc
\
xad
\
xef
\
xbc
\
xb3
\
xe6
\
x98
\
x8e
\
xe6
\
x9c
\
x9d
"
}
{
MINCHO
"
IPAMincho
"
}
{
MINCHO
"
MotoyaG04MinchoMono
"
}
{
SIMSUN
"
Simsun
"
}
{
SIMSUN
"
\
xe5
\
xae
\
x8b
\
xe4
\
xbd
\
x93
"
}
{
SIMSUN
"
MSung
GB18030
"
}
{
SIMSUN
"
Song
ASC
"
}
{
NSIMSUN
"
NSimsun
"
}
{
NSIMSUN
"
\
xe6
\
x96
\
xb0
\
xe5
\
xae
\
x8b
\
xe4
\
xbd
\
x93
"
}
{
NSIMSUN
"
MSung
GB18030
"
}
{
NSIMSUN
"
N
Song
ASC
"
}
{
SIMHEI
"
Simhei
"
}
{
SIMHEI
"
\
xe9
\
xbb
\
x91
\
xe4
\
xbd
\
x93
"
}
{
SIMHEI
"
Noto
Sans
CJK
SC
"
}
{
SIMHEI
"
MYingHeiGB18030
"
}
{
SIMHEI
"
MYingHeiB5HK
"
}
{
PMINGLIU
"
PMingLiU
"
}
{
PMINGLIU
"
\
xe6
\
x96
\
xb0
\
xe7
\
xb4
\
xb0
\
xe6
\
x98
\
x8e
\
xe9
\
xab
\
x94
"
}
{
PMINGLIU
"
MSung
B5HK
"
}
{
MINGLIU
"
MingLiU
"
}
{
MINGLIU
"
\
xe7
\
xb4
\
xb0
\
xe6
\
x98
\
x8e
\
xe9
\
xab
\
x94
"
}
{
MINGLIU
"
MSung
B5HK
"
}
{
PMINGLIUHK
"
PMingLiU_HKSCS
"
}
{
PMINGLIUHK
"
\
xe6
\
x96
\
xb0
\
xe7
\
xb4
\
xb0
\
xe6
\
x98
\
x8e
\
xe9
\
xab
\
x94_HKSCS
"
}
{
PMINGLIUHK
"
MSung
B5HK
"
}
{
MINGLIUHK
"
MingLiU_HKSCS
"
}
{
MINGLIUHK
"
\
xe7
\
xb4
\
xb0
\
xe6
\
x98
\
x8e
\
xe9
\
xab
\
x94_HKSCS
"
}
{
MINGLIUHK
"
MSung
B5HK
"
}
{
CAMBRIA
"
Cambria
"
}
{
CAMBRIA
"
Caladea
"
}
{
CALIBRI
"
Calibri
"
}
{
CALIBRI
"
Carlito
"
}
}
;
static
const
size_t
kFontCount
=
sizeof
(
kFontEquivMap
)
/
sizeof
(
kFontEquivMap
[
0
]
)
;
for
(
size_t
i
=
0
;
i
<
kFontCount
;
+
+
i
)
{
if
(
strcasecmp
(
kFontEquivMap
[
i
]
.
name
fontname
)
=
=
0
)
return
kFontEquivMap
[
i
]
.
clazz
;
}
return
OTHER
;
}
bool
IsMetricCompatibleReplacement
(
const
char
*
font_a
const
char
*
font_b
)
{
FontEquivClass
class_a
=
GetFontEquivClass
(
font_a
)
;
FontEquivClass
class_b
=
GetFontEquivClass
(
font_b
)
;
return
class_a
!
=
OTHER
&
&
class_a
=
=
class_b
;
}
bool
IsFallbackFontAllowed
(
const
SkString
&
family
)
{
const
char
*
family_cstr
=
family
.
c_str
(
)
;
return
family
.
isEmpty
(
)
|
|
strcasecmp
(
family_cstr
"
sans
"
)
=
=
0
|
|
strcasecmp
(
family_cstr
"
serif
"
)
=
=
0
|
|
strcasecmp
(
family_cstr
"
monospace
"
)
=
=
0
;
}
SkTypeface
:
:
Style
GetFontStyle
(
FcPattern
*
font
)
{
int
resulting_bold
;
if
(
FcPatternGetInteger
(
font
FC_WEIGHT
0
&
resulting_bold
)
)
resulting_bold
=
FC_WEIGHT_NORMAL
;
int
resulting_italic
;
if
(
FcPatternGetInteger
(
font
FC_SLANT
0
&
resulting_italic
)
)
resulting_italic
=
FC_SLANT_ROMAN
;
FcValue
matrix
;
const
bool
have_matrix
=
FcPatternGet
(
font
FC_MATRIX
0
&
matrix
)
=
=
0
;
FcValue
embolden
;
const
bool
have_embolden
=
FcPatternGet
(
font
FC_EMBOLDEN
0
&
embolden
)
=
=
0
;
int
styleBits
=
0
;
if
(
resulting_bold
>
FC_WEIGHT_MEDIUM
&
&
!
have_embolden
)
{
styleBits
|
=
SkTypeface
:
:
kBold
;
}
if
(
resulting_italic
>
FC_SLANT_ROMAN
&
&
!
have_matrix
)
{
styleBits
|
=
SkTypeface
:
:
kItalic
;
}
return
(
SkTypeface
:
:
Style
)
styleBits
;
}
}
#
define
kMaxFontFamilyLength
2048
SkFontConfigInterfaceDirect
:
:
SkFontConfigInterfaceDirect
(
)
{
SkAutoMutexAcquire
ac
(
mutex_
)
;
FcInit
(
)
;
SkDEBUGCODE
(
fontconfiginterface_unittest
(
)
;
)
}
SkFontConfigInterfaceDirect
:
:
~
SkFontConfigInterfaceDirect
(
)
{
}
bool
SkFontConfigInterfaceDirect
:
:
isAccessible
(
const
char
*
filename
)
{
if
(
access
(
filename
R_OK
)
!
=
0
)
{
return
false
;
}
return
true
;
}
bool
SkFontConfigInterfaceDirect
:
:
isValidPattern
(
FcPattern
*
pattern
)
{
#
ifdef
SK_FONT_CONFIG_ONLY_ALLOW_SCALABLE_FONTS
FcBool
is_scalable
;
if
(
FcPatternGetBool
(
pattern
FC_SCALABLE
0
&
is_scalable
)
!
=
FcResultMatch
|
|
!
is_scalable
)
{
return
false
;
}
#
endif
const
char
*
c_filename
=
get_name
(
pattern
FC_FILE
)
;
if
(
!
c_filename
)
{
return
false
;
}
return
this
-
>
isAccessible
(
c_filename
)
;
}
FcPattern
*
SkFontConfigInterfaceDirect
:
:
MatchFont
(
FcFontSet
*
font_set
const
char
*
post_config_family
const
SkString
&
family
)
{
FcPattern
*
match
=
nullptr
;
for
(
int
i
=
0
;
i
<
font_set
-
>
nfont
;
+
+
i
)
{
FcPattern
*
current
=
font_set
-
>
fonts
[
i
]
;
if
(
this
-
>
isValidPattern
(
current
)
)
{
match
=
current
;
break
;
}
}
if
(
match
&
&
!
IsFallbackFontAllowed
(
family
)
)
{
bool
acceptable_substitute
=
false
;
for
(
int
id
=
0
;
id
<
255
;
+
+
id
)
{
const
char
*
post_match_family
=
get_name
(
match
FC_FAMILY
id
)
;
if
(
!
post_match_family
)
break
;
acceptable_substitute
=
(
strcasecmp
(
post_config_family
post_match_family
)
=
=
0
|
|
strcasecmp
(
family
.
c_str
(
)
post_match_family
)
=
=
0
)
|
|
IsMetricCompatibleReplacement
(
family
.
c_str
(
)
post_match_family
)
;
if
(
acceptable_substitute
)
break
;
}
if
(
!
acceptable_substitute
)
return
nullptr
;
}
return
match
;
}
bool
SkFontConfigInterfaceDirect
:
:
matchFamilyName
(
const
char
familyName
[
]
SkTypeface
:
:
Style
style
FontIdentity
*
outIdentity
SkString
*
outFamilyName
SkTypeface
:
:
Style
*
outStyle
)
{
SkString
familyStr
(
familyName
?
familyName
:
"
"
)
;
if
(
familyStr
.
size
(
)
>
kMaxFontFamilyLength
)
{
return
false
;
}
SkAutoMutexAcquire
ac
(
mutex_
)
;
FcPattern
*
pattern
=
FcPatternCreate
(
)
;
if
(
familyName
)
{
FcPatternAddString
(
pattern
FC_FAMILY
(
FcChar8
*
)
familyName
)
;
}
FcPatternAddInteger
(
pattern
FC_WEIGHT
(
style
&
SkTypeface
:
:
kBold
)
?
FC_WEIGHT_BOLD
:
FC_WEIGHT_NORMAL
)
;
FcPatternAddInteger
(
pattern
FC_SLANT
(
style
&
SkTypeface
:
:
kItalic
)
?
FC_SLANT_ITALIC
:
FC_SLANT_ROMAN
)
;
FcPatternAddBool
(
pattern
FC_SCALABLE
FcTrue
)
;
FcConfigSubstitute
(
nullptr
pattern
FcMatchPattern
)
;
FcDefaultSubstitute
(
pattern
)
;
const
char
*
post_config_family
=
get_name
(
pattern
FC_FAMILY
)
;
if
(
!
post_config_family
)
{
post_config_family
=
"
"
;
}
FcResult
result
;
FcFontSet
*
font_set
=
FcFontSort
(
0
pattern
0
0
&
result
)
;
if
(
!
font_set
)
{
FcPatternDestroy
(
pattern
)
;
return
false
;
}
FcPattern
*
match
=
this
-
>
MatchFont
(
font_set
post_config_family
familyStr
)
;
if
(
!
match
)
{
FcPatternDestroy
(
pattern
)
;
FcFontSetDestroy
(
font_set
)
;
return
false
;
}
FcPatternDestroy
(
pattern
)
;
post_config_family
=
get_name
(
match
FC_FAMILY
)
;
if
(
!
post_config_family
)
{
FcFontSetDestroy
(
font_set
)
;
return
false
;
}
const
char
*
c_filename
=
get_name
(
match
FC_FILE
)
;
if
(
!
c_filename
)
{
FcFontSetDestroy
(
font_set
)
;
return
false
;
}
int
face_index
;
if
(
FcPatternGetInteger
(
match
FC_INDEX
0
&
face_index
)
!
=
FcResultMatch
)
{
FcFontSetDestroy
(
font_set
)
;
return
false
;
}
FcFontSetDestroy
(
font_set
)
;
if
(
outIdentity
)
{
outIdentity
-
>
fTTCIndex
=
face_index
;
outIdentity
-
>
fString
.
set
(
c_filename
)
;
}
if
(
outFamilyName
)
{
outFamilyName
-
>
set
(
post_config_family
)
;
}
if
(
outStyle
)
{
*
outStyle
=
GetFontStyle
(
match
)
;
}
return
true
;
}
SkStreamAsset
*
SkFontConfigInterfaceDirect
:
:
openStream
(
const
FontIdentity
&
identity
)
{
return
SkStream
:
:
NewFromFile
(
identity
.
fString
.
c_str
(
)
)
;
}
static
bool
find_name
(
const
SkTDArray
<
const
char
*
>
&
list
const
char
*
str
)
{
int
count
=
list
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
!
strcmp
(
list
[
i
]
str
)
)
{
return
true
;
}
}
return
false
;
}
SkDataTable
*
SkFontConfigInterfaceDirect
:
:
getFamilyNames
(
)
{
SkAutoMutexAcquire
ac
(
mutex_
)
;
FcPattern
*
pat
=
FcPatternCreate
(
)
;
SkAutoTCallVProc
<
FcPattern
FcPatternDestroy
>
autoDestroyPat
(
pat
)
;
if
(
nullptr
=
=
pat
)
{
return
nullptr
;
}
FcObjectSet
*
os
=
FcObjectSetBuild
(
FC_FAMILY
(
char
*
)
0
)
;
SkAutoTCallVProc
<
FcObjectSet
FcObjectSetDestroy
>
autoDestroyOs
(
os
)
;
if
(
nullptr
=
=
os
)
{
return
nullptr
;
}
FcFontSet
*
fs
=
FcFontList
(
nullptr
pat
os
)
;
SkAutoTCallVProc
<
FcFontSet
FcFontSetDestroy
>
autoDestroyFs
(
fs
)
;
if
(
nullptr
=
=
fs
)
{
return
nullptr
;
}
SkTDArray
<
const
char
*
>
names
;
SkTDArray
<
size_t
>
sizes
;
for
(
int
i
=
0
;
i
<
fs
-
>
nfont
;
+
+
i
)
{
FcPattern
*
match
=
fs
-
>
fonts
[
i
]
;
const
char
*
famName
=
get_name
(
match
FC_FAMILY
)
;
if
(
famName
&
&
!
find_name
(
names
famName
)
)
{
*
names
.
append
(
)
=
famName
;
*
sizes
.
append
(
)
=
strlen
(
famName
)
+
1
;
}
}
return
SkDataTable
:
:
NewCopyArrays
(
(
const
void
*
const
*
)
names
.
begin
(
)
sizes
.
begin
(
)
names
.
count
(
)
)
;
}
