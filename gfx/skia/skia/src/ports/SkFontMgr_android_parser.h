#
ifndef
SkFontMgr_android_parser_DEFINED
#
define
SkFontMgr_android_parser_DEFINED
#
include
"
include
/
core
/
SkFontMgr
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
<
climits
>
#
include
<
limits
>
class
SkLanguage
{
public
:
SkLanguage
(
)
{
}
SkLanguage
(
const
SkString
&
tag
)
:
fTag
(
tag
)
{
}
SkLanguage
(
const
char
*
tag
)
:
fTag
(
tag
)
{
}
SkLanguage
(
const
char
*
tag
size_t
len
)
:
fTag
(
tag
len
)
{
}
SkLanguage
(
const
SkLanguage
&
b
)
:
fTag
(
b
.
fTag
)
{
}
const
SkString
&
getTag
(
)
const
{
return
fTag
;
}
SkLanguage
getParent
(
)
const
;
bool
operator
=
=
(
const
SkLanguage
&
b
)
const
{
return
fTag
=
=
b
.
fTag
;
}
bool
operator
!
=
(
const
SkLanguage
&
b
)
const
{
return
fTag
!
=
b
.
fTag
;
}
SkLanguage
&
operator
=
(
const
SkLanguage
&
b
)
{
fTag
=
b
.
fTag
;
return
*
this
;
}
private
:
SkString
fTag
;
}
;
enum
FontVariants
{
kDefault_FontVariant
=
0x01
kCompact_FontVariant
=
0x02
kElegant_FontVariant
=
0x04
kLast_FontVariant
=
kElegant_FontVariant
}
;
typedef
uint32_t
FontVariant
;
struct
FontFileInfo
{
FontFileInfo
(
)
:
fIndex
(
0
)
fWeight
(
0
)
fStyle
(
Style
:
:
kAuto
)
{
}
SkString
fFileName
;
int
fIndex
;
int
fWeight
;
enum
class
Style
{
kAuto
kNormal
kItalic
}
fStyle
;
SkTArray
<
SkFontArguments
:
:
VariationPosition
:
:
Coordinate
true
>
fVariationDesignPosition
;
}
;
struct
FontFamily
{
FontFamily
(
const
SkString
&
basePath
bool
isFallbackFont
)
:
fVariant
(
kDefault_FontVariant
)
fOrder
(
-
1
)
fIsFallbackFont
(
isFallbackFont
)
fBasePath
(
basePath
)
{
}
SkTArray
<
SkString
true
>
fNames
;
SkTArray
<
FontFileInfo
true
>
fFonts
;
SkTArray
<
SkLanguage
true
>
fLanguages
;
SkTHashMap
<
SkString
std
:
:
unique_ptr
<
FontFamily
>
>
fallbackFamilies
;
FontVariant
fVariant
;
int
fOrder
;
bool
fIsFallbackFont
;
SkString
fFallbackFor
;
const
SkString
fBasePath
;
}
;
namespace
SkFontMgr_Android_Parser
{
void
GetSystemFontFamilies
(
SkTDArray
<
FontFamily
*
>
&
fontFamilies
)
;
void
GetCustomFontFamilies
(
SkTDArray
<
FontFamily
*
>
&
fontFamilies
const
SkString
&
basePath
const
char
*
fontsXml
const
char
*
fallbackFontsXml
const
char
*
langFallbackFontsDir
=
nullptr
)
;
}
template
<
typename
T
>
bool
parse_non_negative_integer
(
const
char
*
s
T
*
value
)
{
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
is_integer
"
T_must_be_integer
"
)
;
if
(
*
s
=
=
'
\
0
'
)
{
return
false
;
}
const
T
nMax
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
/
10
;
const
T
dMax
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
-
(
nMax
*
10
)
;
T
n
=
0
;
for
(
;
*
s
;
+
+
s
)
{
if
(
*
s
<
'
0
'
|
|
'
9
'
<
*
s
)
{
return
false
;
}
T
d
=
*
s
-
'
0
'
;
if
(
n
>
nMax
|
|
(
n
=
=
nMax
&
&
d
>
dMax
)
)
{
return
false
;
}
n
=
(
n
*
10
)
+
d
;
}
*
value
=
n
;
return
true
;
}
template
<
int
N
typename
T
>
bool
parse_fixed
(
const
char
*
s
T
*
value
)
{
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
is_integer
"
T_must_be_integer
"
)
;
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
is_signed
"
T_must_be_signed
"
)
;
static_assert
(
sizeof
(
T
)
*
CHAR_BIT
-
N
>
=
5
"
N_must_leave_four_bits_plus_sign
"
)
;
bool
negate
=
false
;
if
(
*
s
=
=
'
-
'
)
{
+
+
s
;
negate
=
true
;
}
if
(
*
s
=
=
'
\
0
'
)
{
return
false
;
}
const
T
nMax
=
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
>
>
N
)
/
10
;
const
T
dMax
=
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
>
>
N
)
-
(
nMax
*
10
)
;
T
n
=
0
;
T
frac
=
0
;
for
(
;
*
s
;
+
+
s
)
{
if
(
*
s
<
'
0
'
|
|
'
9
'
<
*
s
)
{
if
(
*
s
!
=
'
.
'
|
|
s
[
1
]
=
=
'
\
0
'
)
{
return
false
;
}
for
(
+
+
s
;
*
s
;
+
+
s
)
{
if
(
*
s
<
'
0
'
|
|
'
9
'
<
*
s
)
{
return
false
;
}
}
for
(
-
-
s
;
*
s
!
=
'
.
'
;
-
-
s
)
{
T
d
=
*
s
-
'
0
'
;
frac
=
(
frac
+
(
d
<
<
N
)
)
/
10
;
}
break
;
}
T
d
=
*
s
-
'
0
'
;
if
(
n
>
nMax
|
|
(
n
=
=
nMax
&
&
d
>
dMax
)
)
{
return
false
;
}
n
=
(
n
*
10
)
+
d
;
}
if
(
negate
)
{
n
=
-
n
;
frac
=
-
frac
;
}
*
value
=
SkLeftShift
(
n
N
)
+
frac
;
return
true
;
}
#
endif
