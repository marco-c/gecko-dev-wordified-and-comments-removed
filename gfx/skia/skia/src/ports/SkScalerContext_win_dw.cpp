#
include
"
src
/
utils
/
win
/
SkDWriteNTDDI_VERSION
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
if
defined
(
SK_BUILD_FOR_WIN
)
#
undef
GetGlyphIndices
#
include
"
include
/
codec
/
SkCodec
.
h
"
#
include
"
include
/
codec
/
SkPngDecoder
.
h
"
#
include
"
include
/
core
/
SkBBHFactory
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkDrawable
.
h
"
#
include
"
include
/
core
/
SkFontMetrics
.
h
"
#
include
"
include
/
core
/
SkGraphics
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkOpenTypeSVGDecoder
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPictureRecorder
.
h
"
#
include
"
include
/
effects
/
SkGradientShader
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkEndian
.
h
"
#
include
"
src
/
base
/
SkScopeExit
.
h
"
#
include
"
src
/
base
/
SkSharedMutex
.
h
"
#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkGlyph
.
h
"
#
include
"
src
/
core
/
SkMaskGamma
.
h
"
#
include
"
src
/
core
/
SkRasterClip
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
ports
/
SkScalerContext_win_dw
.
h
"
#
include
"
src
/
ports
/
SkTypeface_win_dw
.
h
"
#
include
"
src
/
sfnt
/
SkOTTable_EBLC
.
h
"
#
include
"
src
/
sfnt
/
SkOTTable_EBSC
.
h
"
#
include
"
src
/
sfnt
/
SkOTTable_gasp
.
h
"
#
include
"
src
/
sfnt
/
SkOTTable_maxp
.
h
"
#
include
"
src
/
utils
/
SkMatrix22
.
h
"
#
include
"
src
/
utils
/
win
/
SkDWrite
.
h
"
#
include
"
src
/
utils
/
win
/
SkDWriteGeometrySink
.
h
"
#
include
"
src
/
utils
/
win
/
SkHRESULT
.
h
"
#
include
"
src
/
utils
/
win
/
SkTScopedComPtr
.
h
"
#
include
<
dwrite
.
h
>
#
include
<
dwrite_1
.
h
>
#
include
<
dwrite_3
.
h
>
namespace
{
static
inline
const
constexpr
bool
kSkShowTextBlitCoverage
=
false
;
static
SkSharedMutex
*
maybe_dw_mutex
(
DWriteFontTypeface
&
typeface
)
{
static
SkSharedMutex
mutex
;
return
typeface
.
fDWriteFontFace4
?
nullptr
:
&
mutex
;
}
class
SK_SCOPED_CAPABILITY
Exclusive
{
public
:
explicit
Exclusive
(
SkSharedMutex
*
maybe_lock
)
SK_ACQUIRE
(
*
maybe_lock
)
:
fLock
(
maybe_lock
)
{
if
(
fLock
)
{
fLock
-
>
acquire
(
)
;
}
}
~
Exclusive
(
)
SK_RELEASE_CAPABILITY
(
)
{
if
(
fLock
)
{
fLock
-
>
release
(
)
;
}
}
private
:
SkSharedMutex
*
fLock
;
}
;
class
SK_SCOPED_CAPABILITY
Shared
{
public
:
explicit
Shared
(
SkSharedMutex
*
maybe_lock
)
SK_ACQUIRE_SHARED
(
*
maybe_lock
)
:
fLock
(
maybe_lock
)
{
if
(
fLock
)
{
fLock
-
>
acquireShared
(
)
;
}
}
~
Shared
(
)
SK_RELEASE_CAPABILITY
(
)
{
if
(
fLock
)
{
fLock
-
>
releaseShared
(
)
;
}
}
private
:
SkSharedMutex
*
fLock
;
}
;
static
bool
isLCD
(
const
SkScalerContextRec
&
rec
)
{
return
SkMask
:
:
kLCD16_Format
=
=
rec
.
fMaskFormat
;
}
static
bool
is_hinted
(
DWriteFontTypeface
*
typeface
)
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
AutoTDWriteTable
<
SkOTTableMaximumProfile
>
maxp
(
typeface
-
>
fDWriteFontFace
.
get
(
)
)
;
if
(
!
maxp
.
fExists
)
{
return
false
;
}
if
(
maxp
.
fSize
<
sizeof
(
SkOTTableMaximumProfile
:
:
Version
:
:
TT
)
)
{
return
false
;
}
if
(
maxp
-
>
version
.
version
!
=
SkOTTableMaximumProfile
:
:
Version
:
:
TT
:
:
VERSION
)
{
return
false
;
}
return
(
0
!
=
maxp
-
>
version
.
tt
.
maxSizeOfInstructions
)
;
}
struct
GaspRange
{
using
Behavior
=
SkOTTableGridAndScanProcedure
:
:
GaspRange
:
:
behavior
;
GaspRange
(
int
min
int
max
int
version
Behavior
flags
)
:
fMin
(
min
)
fMax
(
max
)
fVersion
(
version
)
fFlags
(
flags
)
{
}
int
fMin
;
int
fMax
;
int
fVersion
;
Behavior
fFlags
;
}
;
bool
get_gasp_range
(
DWriteFontTypeface
*
typeface
int
size
GaspRange
*
range
)
{
AutoTDWriteTable
<
SkOTTableGridAndScanProcedure
>
gasp
(
typeface
-
>
fDWriteFontFace
.
get
(
)
)
;
if
(
!
gasp
.
fExists
)
{
return
false
;
}
if
(
gasp
.
fSize
<
sizeof
(
SkOTTableGridAndScanProcedure
)
)
{
return
false
;
}
if
(
gasp
-
>
version
!
=
SkOTTableGridAndScanProcedure
:
:
version0
&
&
gasp
-
>
version
!
=
SkOTTableGridAndScanProcedure
:
:
version1
)
{
return
false
;
}
uint16_t
numRanges
=
SkEndianSwap16
(
gasp
-
>
numRanges
)
;
if
(
numRanges
>
1024
|
|
gasp
.
fSize
<
sizeof
(
SkOTTableGridAndScanProcedure
)
+
sizeof
(
SkOTTableGridAndScanProcedure
:
:
GaspRange
)
*
numRanges
)
{
return
false
;
}
const
SkOTTableGridAndScanProcedure
:
:
GaspRange
*
rangeTable
=
SkTAfter
<
const
SkOTTableGridAndScanProcedure
:
:
GaspRange
>
(
gasp
.
get
(
)
)
;
int
minPPEM
=
-
1
;
for
(
uint16_t
i
=
0
;
i
<
numRanges
;
+
+
i
+
+
rangeTable
)
{
int
maxPPEM
=
SkEndianSwap16
(
rangeTable
-
>
maxPPEM
)
;
if
(
minPPEM
<
size
&
&
size
<
=
maxPPEM
)
{
range
-
>
fMin
=
minPPEM
+
1
;
range
-
>
fMax
=
maxPPEM
;
range
-
>
fVersion
=
SkEndian_SwapBE16
(
gasp
-
>
version
)
;
range
-
>
fFlags
=
rangeTable
-
>
flags
;
return
true
;
}
minPPEM
=
maxPPEM
;
}
return
false
;
}
static
bool
is_gridfit_only
(
GaspRange
:
:
Behavior
flags
)
{
return
flags
.
raw
.
value
=
=
GaspRange
:
:
Behavior
:
:
Raw
:
:
GridfitMask
;
}
static
bool
has_bitmap_strike
(
DWriteFontTypeface
*
typeface
GaspRange
range
)
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
{
AutoTDWriteTable
<
SkOTTableEmbeddedBitmapLocation
>
eblc
(
typeface
-
>
fDWriteFontFace
.
get
(
)
)
;
if
(
!
eblc
.
fExists
)
{
return
false
;
}
if
(
eblc
.
fSize
<
sizeof
(
SkOTTableEmbeddedBitmapLocation
)
)
{
return
false
;
}
if
(
eblc
-
>
version
!
=
SkOTTableEmbeddedBitmapLocation
:
:
version_initial
)
{
return
false
;
}
uint32_t
numSizes
=
SkEndianSwap32
(
eblc
-
>
numSizes
)
;
if
(
numSizes
>
1024
|
|
eblc
.
fSize
<
sizeof
(
SkOTTableEmbeddedBitmapLocation
)
+
sizeof
(
SkOTTableEmbeddedBitmapLocation
:
:
BitmapSizeTable
)
*
numSizes
)
{
return
false
;
}
const
SkOTTableEmbeddedBitmapLocation
:
:
BitmapSizeTable
*
sizeTable
=
SkTAfter
<
const
SkOTTableEmbeddedBitmapLocation
:
:
BitmapSizeTable
>
(
eblc
.
get
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numSizes
;
+
+
i
+
+
sizeTable
)
{
if
(
sizeTable
-
>
ppemX
=
=
sizeTable
-
>
ppemY
&
&
range
.
fMin
<
=
sizeTable
-
>
ppemX
&
&
sizeTable
-
>
ppemX
<
=
range
.
fMax
)
{
if
(
sizeTable
-
>
endGlyphIndex
>
=
sizeTable
-
>
startGlyphIndex
+
3
)
{
return
true
;
}
}
}
}
{
AutoTDWriteTable
<
SkOTTableEmbeddedBitmapScaling
>
ebsc
(
typeface
-
>
fDWriteFontFace
.
get
(
)
)
;
if
(
!
ebsc
.
fExists
)
{
return
false
;
}
if
(
ebsc
.
fSize
<
sizeof
(
SkOTTableEmbeddedBitmapScaling
)
)
{
return
false
;
}
if
(
ebsc
-
>
version
!
=
SkOTTableEmbeddedBitmapScaling
:
:
version_initial
)
{
return
false
;
}
uint32_t
numSizes
=
SkEndianSwap32
(
ebsc
-
>
numSizes
)
;
if
(
numSizes
>
1024
|
|
ebsc
.
fSize
<
sizeof
(
SkOTTableEmbeddedBitmapScaling
)
+
sizeof
(
SkOTTableEmbeddedBitmapScaling
:
:
BitmapScaleTable
)
*
numSizes
)
{
return
false
;
}
const
SkOTTableEmbeddedBitmapScaling
:
:
BitmapScaleTable
*
scaleTable
=
SkTAfter
<
const
SkOTTableEmbeddedBitmapScaling
:
:
BitmapScaleTable
>
(
ebsc
.
get
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numSizes
;
+
+
i
+
+
scaleTable
)
{
if
(
scaleTable
-
>
ppemX
=
=
scaleTable
-
>
ppemY
&
&
range
.
fMin
<
=
scaleTable
-
>
ppemX
&
&
scaleTable
-
>
ppemX
<
=
range
.
fMax
)
{
return
true
;
}
}
}
return
false
;
}
static
bool
both_zero
(
SkScalar
a
SkScalar
b
)
{
return
0
=
=
a
&
&
0
=
=
b
;
}
static
bool
is_axis_aligned
(
const
SkScalerContextRec
&
rec
)
{
return
0
=
=
rec
.
fPreSkewX
&
&
(
both_zero
(
rec
.
fPost2x2
[
0
]
[
1
]
rec
.
fPost2x2
[
1
]
[
0
]
)
|
|
both_zero
(
rec
.
fPost2x2
[
0
]
[
0
]
rec
.
fPost2x2
[
1
]
[
1
]
)
)
;
}
}
SkScalerContext_DW
:
:
SkScalerContext_DW
(
sk_sp
<
DWriteFontTypeface
>
typefaceRef
const
SkScalerContextEffects
&
effects
const
SkDescriptor
*
desc
)
:
SkScalerContext
(
std
:
:
move
(
typefaceRef
)
effects
desc
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
fGlyphCount
=
typeface
-
>
fDWriteFontFace
-
>
GetGlyphCount
(
)
;
fClearTypeLevel
=
int
(
typeface
-
>
GetClearTypeLevel
(
)
*
256
)
;
SkVector
scale
;
fRec
.
computeMatrices
(
SkScalerContextRec
:
:
PreMatrixScale
:
:
kVertical
&
scale
&
fSkXform
)
;
fXform
.
m11
=
SkScalarToFloat
(
fSkXform
.
getScaleX
(
)
)
;
fXform
.
m12
=
SkScalarToFloat
(
fSkXform
.
getSkewY
(
)
)
;
fXform
.
m21
=
SkScalarToFloat
(
fSkXform
.
getSkewX
(
)
)
;
fXform
.
m22
=
SkScalarToFloat
(
fSkXform
.
getScaleY
(
)
)
;
fXform
.
dx
=
0
;
fXform
.
dy
=
0
;
const
SkScalar
realTextSize
=
scale
.
fY
;
SkScalar
gdiTextSize
=
SkScalarRoundToScalar
(
realTextSize
*
64
.
0f
)
/
64
.
0f
;
if
(
gdiTextSize
=
=
0
)
{
gdiTextSize
=
SK_Scalar1
;
}
bool
bitmapRequested
=
SkToBool
(
fRec
.
fFlags
&
SkScalerContext
:
:
kEmbeddedBitmapText_Flag
)
;
bool
treatLikeBitmap
=
false
;
bool
axisAlignedBitmap
=
false
;
if
(
bitmapRequested
)
{
int
bitmapPPEM
=
SkScalarTruncToInt
(
gdiTextSize
)
;
GaspRange
range
(
bitmapPPEM
bitmapPPEM
0
GaspRange
:
:
Behavior
(
)
)
;
if
(
get_gasp_range
(
typeface
bitmapPPEM
&
range
)
)
{
if
(
!
is_gridfit_only
(
range
.
fFlags
)
)
{
range
=
GaspRange
(
bitmapPPEM
bitmapPPEM
0
GaspRange
:
:
Behavior
(
)
)
;
}
}
treatLikeBitmap
=
has_bitmap_strike
(
typeface
range
)
;
axisAlignedBitmap
=
is_axis_aligned
(
fRec
)
;
}
GaspRange
range
(
0
0xFFFF
0
GaspRange
:
:
Behavior
(
)
)
;
if
(
SkMask
:
:
kBW_Format
=
=
fRec
.
fMaskFormat
)
{
fTextSizeRender
=
gdiTextSize
;
fRenderingMode
=
DWRITE_RENDERING_MODE_ALIASED
;
fTextureType
=
DWRITE_TEXTURE_ALIASED_1x1
;
fTextSizeMeasure
=
gdiTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_GDI_CLASSIC
;
}
else
if
(
(
treatLikeBitmap
&
&
axisAlignedBitmap
)
|
|
typeface
-
>
ForceGDI
(
)
)
{
fTextSizeRender
=
gdiTextSize
;
fRenderingMode
=
DWRITE_RENDERING_MODE_GDI_CLASSIC
;
fTextureType
=
DWRITE_TEXTURE_CLEARTYPE_3x1
;
fTextSizeMeasure
=
gdiTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_GDI_CLASSIC
;
}
else
if
(
treatLikeBitmap
)
{
fTextSizeRender
=
gdiTextSize
;
fRenderingMode
=
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
;
fTextureType
=
DWRITE_TEXTURE_CLEARTYPE_3x1
;
fTextSizeMeasure
=
gdiTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_GDI_CLASSIC
;
}
else
if
(
realTextSize
>
SkIntToScalar
(
20
)
|
|
typeface
-
>
GetRenderingMode
(
)
=
=
DWRITE_RENDERING_MODE_NATURAL
|
|
typeface
-
>
GetRenderingMode
(
)
=
=
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
)
{
fTextSizeRender
=
realTextSize
;
fRenderingMode
=
typeface
-
>
GetRenderingMode
(
)
=
=
DWRITE_RENDERING_MODE_NATURAL
?
DWRITE_RENDERING_MODE_NATURAL
:
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
;
fTextureType
=
DWRITE_TEXTURE_CLEARTYPE_3x1
;
fTextSizeMeasure
=
realTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_NATURAL
;
}
else
if
(
get_gasp_range
(
typeface
SkScalarRoundToInt
(
gdiTextSize
)
&
range
)
&
&
range
.
fVersion
>
=
1
)
{
fTextSizeRender
=
realTextSize
;
fRenderingMode
=
!
range
.
fFlags
.
field
.
SymmetricSmoothing
?
DWRITE_RENDERING_MODE_NATURAL
:
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
;
fTextureType
=
DWRITE_TEXTURE_CLEARTYPE_3x1
;
fTextSizeMeasure
=
realTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_NATURAL
;
}
else
{
if
(
is_hinted
(
typeface
)
)
{
fTextSizeRender
=
gdiTextSize
;
fRenderingMode
=
DWRITE_RENDERING_MODE_NATURAL
;
}
else
{
fTextSizeRender
=
realTextSize
;
fRenderingMode
=
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
;
}
fTextureType
=
DWRITE_TEXTURE_CLEARTYPE_3x1
;
fTextSizeMeasure
=
realTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_NATURAL
;
}
fAntiAliasMode
=
DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE
;
if
(
typeface
-
>
fFactory2
&
&
typeface
-
>
fDWriteFontFace2
&
&
SkMask
:
:
kA8_Format
=
=
fRec
.
fMaskFormat
&
&
!
(
fRec
.
fFlags
&
SkScalerContext
:
:
kGenA8FromLCD_Flag
)
)
{
fTextureType
=
DWRITE_TEXTURE_ALIASED_1x1
;
fAntiAliasMode
=
DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE
;
}
fGridFitMode
=
DWRITE_GRID_FIT_MODE_ENABLED
;
if
(
fRec
.
getHinting
(
)
=
=
SkFontHinting
:
:
kNone
)
{
fGridFitMode
=
DWRITE_GRID_FIT_MODE_DISABLED
;
if
(
fRenderingMode
!
=
DWRITE_RENDERING_MODE_ALIASED
)
{
fRenderingMode
=
DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
;
}
}
if
(
this
-
>
isLinearMetrics
(
)
)
{
fTextSizeMeasure
=
realTextSize
;
fMeasuringMode
=
DWRITE_MEASURING_MODE_NATURAL
;
}
if
(
fMeasuringMode
!
=
DWRITE_MEASURING_MODE_NATURAL
)
{
constexpr
UINT32
CBDTTag
=
DWRITE_MAKE_OPENTYPE_TAG
(
'
C
'
'
B
'
'
D
'
'
T
'
)
;
AutoDWriteTable
CBDT
(
typeface
-
>
fDWriteFontFace
.
get
(
)
CBDTTag
)
;
if
(
CBDT
.
fExists
)
{
fMeasuringMode
=
DWRITE_MEASURING_MODE_NATURAL
;
}
}
}
SkScalerContext_DW
:
:
~
SkScalerContext_DW
(
)
{
}
#
if
DWRITE_CORE
|
|
(
defined
(
NTDDI_WIN11_ZN
)
&
&
NTDDI_VERSION
>
=
NTDDI_WIN11_ZN
)
namespace
{
SkColor4f
sk_color_from
(
DWRITE_COLOR_F
const
&
color
)
{
return
SkColor4f
{
color
.
r
color
.
g
color
.
b
color
.
a
}
;
}
DWRITE_COLOR_F
dw_color_from
(
SkColor4f
const
&
color
)
{
DWRITE_COLOR_F
dwColor
;
dwColor
.
r
=
color
.
fR
;
dwColor
.
g
=
color
.
fG
;
dwColor
.
b
=
color
.
fB
;
dwColor
.
a
=
color
.
fA
;
return
dwColor
;
}
SkRect
sk_rect_from
(
D2D_RECT_F
const
&
rect
)
{
return
SkRect
{
rect
.
left
rect
.
top
rect
.
right
rect
.
bottom
}
;
}
constexpr
bool
D2D_RECT_F_is_empty
(
const
D2D_RECT_F
&
r
)
{
return
r
.
right
<
=
r
.
left
|
|
r
.
bottom
<
=
r
.
top
;
}
SkMatrix
sk_matrix_from
(
DWRITE_MATRIX
const
&
m
)
{
return
SkMatrix
:
:
MakeAll
(
m
.
m11
m
.
m21
m
.
dx
m
.
m12
m
.
m22
m
.
dy
0
0
1
)
;
}
SkTileMode
sk_tile_mode_from
(
D2D1_EXTEND_MODE
extendMode
)
{
switch
(
extendMode
)
{
case
D2D1_EXTEND_MODE_CLAMP
:
return
SkTileMode
:
:
kClamp
;
case
D2D1_EXTEND_MODE_WRAP
:
return
SkTileMode
:
:
kRepeat
;
case
D2D1_EXTEND_MODE_MIRROR
:
return
SkTileMode
:
:
kMirror
;
default
:
return
SkTileMode
:
:
kClamp
;
}
}
SkBlendMode
sk_blend_mode_from
(
DWRITE_COLOR_COMPOSITE_MODE
compositeMode
)
{
switch
(
compositeMode
)
{
case
DWRITE_COLOR_COMPOSITE_CLEAR
:
return
SkBlendMode
:
:
kClear
;
case
DWRITE_COLOR_COMPOSITE_SRC
:
return
SkBlendMode
:
:
kSrc
;
case
DWRITE_COLOR_COMPOSITE_DEST
:
return
SkBlendMode
:
:
kDst
;
case
DWRITE_COLOR_COMPOSITE_SRC_OVER
:
return
SkBlendMode
:
:
kSrcOver
;
case
DWRITE_COLOR_COMPOSITE_DEST_OVER
:
return
SkBlendMode
:
:
kDstOver
;
case
DWRITE_COLOR_COMPOSITE_SRC_IN
:
return
SkBlendMode
:
:
kSrcIn
;
case
DWRITE_COLOR_COMPOSITE_DEST_IN
:
return
SkBlendMode
:
:
kDstIn
;
case
DWRITE_COLOR_COMPOSITE_SRC_OUT
:
return
SkBlendMode
:
:
kSrcOut
;
case
DWRITE_COLOR_COMPOSITE_DEST_OUT
:
return
SkBlendMode
:
:
kDstOut
;
case
DWRITE_COLOR_COMPOSITE_SRC_ATOP
:
return
SkBlendMode
:
:
kSrcATop
;
case
DWRITE_COLOR_COMPOSITE_DEST_ATOP
:
return
SkBlendMode
:
:
kDstATop
;
case
DWRITE_COLOR_COMPOSITE_XOR
:
return
SkBlendMode
:
:
kXor
;
case
DWRITE_COLOR_COMPOSITE_PLUS
:
return
SkBlendMode
:
:
kPlus
;
case
DWRITE_COLOR_COMPOSITE_SCREEN
:
return
SkBlendMode
:
:
kScreen
;
case
DWRITE_COLOR_COMPOSITE_OVERLAY
:
return
SkBlendMode
:
:
kOverlay
;
case
DWRITE_COLOR_COMPOSITE_DARKEN
:
return
SkBlendMode
:
:
kDarken
;
case
DWRITE_COLOR_COMPOSITE_LIGHTEN
:
return
SkBlendMode
:
:
kLighten
;
case
DWRITE_COLOR_COMPOSITE_COLOR_DODGE
:
return
SkBlendMode
:
:
kColorDodge
;
case
DWRITE_COLOR_COMPOSITE_COLOR_BURN
:
return
SkBlendMode
:
:
kColorBurn
;
case
DWRITE_COLOR_COMPOSITE_HARD_LIGHT
:
return
SkBlendMode
:
:
kHardLight
;
case
DWRITE_COLOR_COMPOSITE_SOFT_LIGHT
:
return
SkBlendMode
:
:
kSoftLight
;
case
DWRITE_COLOR_COMPOSITE_DIFFERENCE
:
return
SkBlendMode
:
:
kDifference
;
case
DWRITE_COLOR_COMPOSITE_EXCLUSION
:
return
SkBlendMode
:
:
kExclusion
;
case
DWRITE_COLOR_COMPOSITE_MULTIPLY
:
return
SkBlendMode
:
:
kMultiply
;
case
DWRITE_COLOR_COMPOSITE_HSL_HUE
:
return
SkBlendMode
:
:
kHue
;
case
DWRITE_COLOR_COMPOSITE_HSL_SATURATION
:
return
SkBlendMode
:
:
kSaturation
;
case
DWRITE_COLOR_COMPOSITE_HSL_COLOR
:
return
SkBlendMode
:
:
kColor
;
case
DWRITE_COLOR_COMPOSITE_HSL_LUMINOSITY
:
return
SkBlendMode
:
:
kLuminosity
;
default
:
return
SkBlendMode
:
:
kDst
;
}
}
inline
SkPoint
SkVectorProjection
(
SkPoint
a
SkPoint
b
)
{
SkScalar
length
=
b
.
length
(
)
;
if
(
!
length
)
{
return
SkPoint
(
)
;
}
SkPoint
bNormalized
=
b
;
bNormalized
.
normalize
(
)
;
bNormalized
.
scale
(
SkPoint
:
:
DotProduct
(
a
b
)
/
length
)
;
return
bNormalized
;
}
D2D1_COLOR_F
lerpSkColor
(
D2D1_COLOR_F
c0
D2D1_COLOR_F
c1
float
t
)
{
if
(
t
<
0
)
{
return
c0
;
}
if
(
t
>
1
)
{
return
c1
;
}
const
auto
c0_4f
=
skvx
:
:
float4
(
c0
.
r
c0
.
g
c0
.
b
c0
.
a
)
c1_4f
=
skvx
:
:
float4
(
c1
.
r
c1
.
g
c1
.
b
c1
.
a
)
c_4f
=
c0_4f
+
(
c1_4f
-
c0_4f
)
*
t
;
D2D1_COLOR_F
r
;
c_4f
.
store
(
&
r
)
;
return
r
;
}
enum
TruncateStops
{
TruncateStart
TruncateEnd
}
;
void
truncateToStopInterpolating
(
SkScalar
zeroRadiusStop
std
:
:
vector
<
D2D1_GRADIENT_STOP
>
&
stops
TruncateStops
truncateStops
)
{
if
(
stops
.
size
(
)
<
=
1u
|
|
zeroRadiusStop
<
stops
.
front
(
)
.
position
|
|
stops
.
back
(
)
.
position
<
zeroRadiusStop
)
{
return
;
}
auto
lcmp
=
[
]
(
D2D1_GRADIENT_STOP
const
&
stop
SkScalar
position
)
{
return
stop
.
position
<
position
;
}
;
auto
ucmp
=
[
]
(
SkScalar
position
D2D1_GRADIENT_STOP
const
&
stop
)
{
return
position
<
stop
.
position
;
}
;
size_t
afterIndex
=
(
truncateStops
=
=
TruncateStart
)
?
std
:
:
lower_bound
(
stops
.
begin
(
)
stops
.
end
(
)
zeroRadiusStop
lcmp
)
-
stops
.
begin
(
)
:
std
:
:
upper_bound
(
stops
.
begin
(
)
stops
.
end
(
)
zeroRadiusStop
ucmp
)
-
stops
.
begin
(
)
;
const
float
t
=
(
zeroRadiusStop
-
stops
[
afterIndex
-
1
]
.
position
)
/
(
stops
[
afterIndex
]
.
position
-
stops
[
afterIndex
-
1
]
.
position
)
;
D2D1_COLOR_F
lerpColor
=
lerpSkColor
(
stops
[
afterIndex
-
1
]
.
color
stops
[
afterIndex
]
.
color
t
)
;
if
(
truncateStops
=
=
TruncateStart
)
{
stops
.
erase
(
stops
.
begin
(
)
stops
.
begin
(
)
+
afterIndex
)
;
stops
.
insert
(
stops
.
begin
(
)
{
0
lerpColor
}
)
;
}
else
{
stops
.
erase
(
stops
.
begin
(
)
+
afterIndex
stops
.
end
(
)
)
;
stops
.
insert
(
stops
.
end
(
)
{
1
lerpColor
}
)
;
}
}
}
bool
SkScalerContext_DW
:
:
drawColorV1Paint
(
SkCanvas
&
canvas
IDWritePaintReader
&
reader
DWRITE_PAINT_ELEMENT
const
&
element
)
{
auto
drawChildren
=
[
&
]
(
uint32_t
childCount
)
-
>
bool
{
if
(
childCount
!
=
0
)
{
DWRITE_PAINT_ELEMENT
childElement
;
HRB
(
reader
.
MoveToFirstChild
(
&
childElement
)
)
;
this
-
>
drawColorV1Paint
(
canvas
reader
childElement
)
;
for
(
uint32_t
i
=
1
;
i
<
childCount
;
i
+
+
)
{
HRB
(
reader
.
MoveToNextSibling
(
&
childElement
)
)
;
this
-
>
drawColorV1Paint
(
canvas
reader
childElement
)
;
}
HRB
(
reader
.
MoveToParent
(
)
)
;
}
return
true
;
}
;
SkAutoCanvasRestore
restoreCanvas
(
&
canvas
true
)
;
switch
(
element
.
paintType
)
{
case
DWRITE_PAINT_TYPE_NONE
:
return
true
;
case
DWRITE_PAINT_TYPE_LAYERS
:
{
return
drawChildren
(
element
.
paint
.
layers
.
childCount
)
;
}
case
DWRITE_PAINT_TYPE_SOLID_GLYPH
:
{
auto
const
&
solidGlyph
=
element
.
paint
.
solidGlyph
;
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
UINT16
glyphId
=
SkTo
<
UINT16
>
(
solidGlyph
.
glyphIndex
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGlyphRunOutline
(
SkScalarToFloat
(
fTextSizeRender
)
&
glyphId
nullptr
nullptr
1
FALSE
FALSE
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
path
.
transform
(
SkMatrix
:
:
Scale
(
1
.
0f
/
fTextSizeRender
1
.
0f
/
fTextSizeRender
)
)
;
SkPaint
skPaint
;
skPaint
.
setColor4f
(
sk_color_from
(
solidGlyph
.
color
.
value
)
)
;
skPaint
.
setAntiAlias
(
fRenderingMode
!
=
DWRITE_RENDERING_MODE_ALIASED
)
;
canvas
.
drawPath
(
path
skPaint
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_SOLID
:
{
SkPaint
skPaint
;
skPaint
.
setColor4f
(
sk_color_from
(
element
.
paint
.
solid
.
value
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_LINEAR_GRADIENT
:
{
auto
const
&
linearGradient
=
element
.
paint
.
linearGradient
;
if
(
linearGradient
.
gradientStopCount
=
=
0
)
{
return
true
;
}
std
:
:
vector
<
D2D1_GRADIENT_STOP
>
stops
;
stops
.
resize
(
linearGradient
.
gradientStopCount
)
;
HRBM
(
reader
.
GetGradientStops
(
0
stops
.
size
(
)
stops
.
data
(
)
)
"
Could
not
get
linear
gradient
stops
.
"
)
;
SkPaint
skPaint
;
if
(
stops
.
size
(
)
=
=
1
)
{
skPaint
.
setColor4f
(
sk_color_from
(
stops
[
0
]
.
color
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
SkPoint
linePositions
[
2
]
=
{
{
linearGradient
.
x0
linearGradient
.
y0
}
{
linearGradient
.
x1
linearGradient
.
y1
}
}
;
SkPoint
p0
=
linePositions
[
0
]
;
SkPoint
p1
=
linePositions
[
1
]
;
SkPoint
p2
=
SkPoint
:
:
Make
(
linearGradient
.
x2
linearGradient
.
y2
)
;
if
(
p1
=
=
p0
|
|
p2
=
=
p0
|
|
!
SkPoint
:
:
CrossProduct
(
p1
-
p0
p2
-
p0
)
)
{
skPaint
.
setColor4f
(
sk_color_from
(
stops
[
0
]
.
color
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
SkVector
perpendicularToP2P0
=
(
p2
-
p0
)
;
perpendicularToP2P0
=
SkPoint
:
:
Make
(
perpendicularToP2P0
.
y
(
)
-
perpendicularToP2P0
.
x
(
)
)
;
SkVector
p3
=
p0
+
SkVectorProjection
(
(
p1
-
p0
)
perpendicularToP2P0
)
;
linePositions
[
1
]
=
p3
;
SkTileMode
tileMode
=
sk_tile_mode_from
(
SkTo
<
D2D1_EXTEND_MODE
>
(
linearGradient
.
extendMode
)
)
;
SkScalar
colorStopRange
=
stops
.
back
(
)
.
position
-
stops
.
front
(
)
.
position
;
if
(
colorStopRange
=
=
0
.
f
)
{
if
(
tileMode
!
=
SkTileMode
:
:
kClamp
)
{
return
true
;
}
else
{
stops
.
push_back
(
{
stops
.
back
(
)
.
position
+
1
.
0f
stops
.
back
(
)
.
color
}
)
;
colorStopRange
=
1
.
0f
;
}
}
SkASSERT
(
colorStopRange
!
=
0
.
f
)
;
if
(
(
colorStopRange
!
=
1
|
|
stops
.
front
(
)
.
position
!
=
0
.
f
)
)
{
SkVector
p0p3
=
p3
-
p0
;
SkVector
p0Offset
=
p0p3
;
p0Offset
.
scale
(
stops
.
front
(
)
.
position
)
;
SkVector
p1Offset
=
p0p3
;
p1Offset
.
scale
(
stops
.
back
(
)
.
position
)
;
linePositions
[
0
]
=
p0
+
p0Offset
;
linePositions
[
1
]
=
p0
+
p1Offset
;
SkScalar
scaleFactor
=
1
/
colorStopRange
;
SkScalar
startOffset
=
stops
.
front
(
)
.
position
;
for
(
D2D1_GRADIENT_STOP
&
stop
:
stops
)
{
stop
.
position
=
(
stop
.
position
-
startOffset
)
*
scaleFactor
;
}
}
std
:
:
unique_ptr
<
SkColor4f
[
]
>
skColors
(
new
SkColor4f
[
stops
.
size
(
)
]
)
;
std
:
:
unique_ptr
<
SkScalar
[
]
>
skStops
(
new
SkScalar
[
stops
.
size
(
)
]
)
;
for
(
size_t
i
=
0
;
i
<
stops
.
size
(
)
;
+
+
i
)
{
skColors
[
i
]
=
sk_color_from
(
stops
[
i
]
.
color
)
;
skStops
[
i
]
=
stops
[
i
]
.
position
;
}
sk_sp
<
SkShader
>
shader
(
SkGradientShader
:
:
MakeLinear
(
linePositions
skColors
.
get
(
)
SkColorSpace
:
:
MakeSRGB
(
)
skStops
.
get
(
)
stops
.
size
(
)
tileMode
SkGradientShader
:
:
Interpolation
{
SkGradientShader
:
:
Interpolation
:
:
InPremul
:
:
kNo
SkGradientShader
:
:
Interpolation
:
:
ColorSpace
:
:
kSRGB
SkGradientShader
:
:
Interpolation
:
:
HueMethod
:
:
kShorter
}
nullptr
)
)
;
SkASSERT
(
shader
)
;
skPaint
.
setColor
(
SK_ColorBLACK
)
;
skPaint
.
setShader
(
shader
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_RADIAL_GRADIENT
:
{
auto
const
&
radialGradient
=
element
.
paint
.
radialGradient
;
SkPoint
start
=
SkPoint
:
:
Make
(
radialGradient
.
x0
radialGradient
.
y0
)
;
SkScalar
startRadius
=
radialGradient
.
radius0
;
SkPoint
end
=
SkPoint
:
:
Make
(
radialGradient
.
x1
radialGradient
.
y1
)
;
SkScalar
endRadius
=
radialGradient
.
radius1
;
if
(
radialGradient
.
gradientStopCount
=
=
0
)
{
return
true
;
}
std
:
:
vector
<
D2D1_GRADIENT_STOP
>
stops
;
stops
.
resize
(
radialGradient
.
gradientStopCount
)
;
HRBM
(
reader
.
GetGradientStops
(
0
stops
.
size
(
)
stops
.
data
(
)
)
"
Could
not
get
radial
gradient
stops
.
"
)
;
SkPaint
skPaint
;
if
(
stops
.
size
(
)
=
=
1
)
{
skPaint
.
setColor4f
(
sk_color_from
(
stops
[
0
]
.
color
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
SkScalar
colorStopRange
=
stops
.
back
(
)
.
position
-
stops
.
front
(
)
.
position
;
SkTileMode
tileMode
=
sk_tile_mode_from
(
SkTo
<
D2D1_EXTEND_MODE
>
(
radialGradient
.
extendMode
)
)
;
if
(
colorStopRange
=
=
0
.
f
)
{
if
(
tileMode
!
=
SkTileMode
:
:
kClamp
)
{
return
true
;
}
else
{
stops
.
push_back
(
{
stops
.
back
(
)
.
position
+
1
.
0f
stops
.
back
(
)
.
color
}
)
;
colorStopRange
=
1
.
0f
;
}
}
SkASSERT
(
colorStopRange
!
=
0
.
f
)
;
if
(
colorStopRange
!
=
1
|
|
stops
.
front
(
)
.
position
!
=
0
.
f
)
{
SkVector
startToEnd
=
end
-
start
;
SkScalar
radiusDiff
=
endRadius
-
startRadius
;
SkScalar
scaleFactor
=
1
/
colorStopRange
;
SkScalar
stopsStartOffset
=
stops
.
front
(
)
.
position
;
SkVector
startOffset
=
startToEnd
;
startOffset
.
scale
(
stops
.
front
(
)
.
position
)
;
SkVector
endOffset
=
startToEnd
;
endOffset
.
scale
(
stops
.
back
(
)
.
position
)
;
end
=
start
+
endOffset
;
start
=
start
+
startOffset
;
endRadius
=
startRadius
+
radiusDiff
*
stops
.
back
(
)
.
position
;
startRadius
=
startRadius
+
radiusDiff
*
stops
.
front
(
)
.
position
;
for
(
auto
&
stop
:
stops
)
{
stop
.
position
=
(
stop
.
position
-
stopsStartOffset
)
*
scaleFactor
;
}
}
if
(
startRadius
<
0
|
|
endRadius
<
0
)
{
if
(
startRadius
=
=
endRadius
&
&
startRadius
<
0
)
{
return
true
;
}
if
(
tileMode
=
=
SkTileMode
:
:
kClamp
)
{
SkVector
startToEnd
=
end
-
start
;
SkScalar
radiusDiff
=
endRadius
-
startRadius
;
SkScalar
zeroRadiusStop
=
0
.
f
;
TruncateStops
truncateSide
=
TruncateStart
;
if
(
startRadius
<
0
)
{
truncateSide
=
TruncateStart
;
zeroRadiusStop
=
-
startRadius
/
(
endRadius
-
startRadius
)
;
startRadius
=
0
.
f
;
SkVector
startEndDiff
=
end
-
start
;
startEndDiff
.
scale
(
zeroRadiusStop
)
;
start
=
start
+
startEndDiff
;
}
if
(
endRadius
<
0
)
{
truncateSide
=
TruncateEnd
;
zeroRadiusStop
=
-
startRadius
/
(
endRadius
-
startRadius
)
;
endRadius
=
0
.
f
;
SkVector
startEndDiff
=
end
-
start
;
startEndDiff
.
scale
(
1
-
zeroRadiusStop
)
;
end
=
end
-
startEndDiff
;
}
if
(
!
(
startRadius
=
=
0
&
&
endRadius
=
=
0
)
)
{
truncateToStopInterpolating
(
zeroRadiusStop
stops
truncateSide
)
;
}
else
{
if
(
radiusDiff
>
0
)
{
end
=
start
+
startToEnd
;
endRadius
=
radiusDiff
;
stops
.
erase
(
stops
.
begin
(
)
stops
.
end
(
)
-
1
)
;
}
else
{
start
-
=
startToEnd
;
startRadius
=
-
radiusDiff
;
stops
.
erase
(
stops
.
begin
(
)
+
1
stops
.
end
(
)
)
;
}
}
}
else
{
if
(
startRadius
<
0
|
|
endRadius
<
0
)
{
auto
roundIntegerMultiple
=
[
]
(
SkScalar
factorZeroCrossing
SkTileMode
tileMode
)
{
int
roundedMultiple
=
factorZeroCrossing
>
0
?
ceilf
(
factorZeroCrossing
)
:
floorf
(
factorZeroCrossing
)
-
1
;
if
(
tileMode
=
=
SkTileMode
:
:
kMirror
&
&
roundedMultiple
%
2
!
=
0
)
{
roundedMultiple
+
=
roundedMultiple
<
0
?
-
1
:
1
;
}
return
roundedMultiple
;
}
;
SkVector
startToEnd
=
end
-
start
;
SkScalar
radiusDiff
=
endRadius
-
startRadius
;
SkScalar
factorZeroCrossing
=
(
startRadius
/
(
startRadius
-
endRadius
)
)
;
bool
inRange
=
0
.
f
<
=
factorZeroCrossing
&
&
factorZeroCrossing
<
=
1
.
0f
;
SkScalar
direction
=
inRange
&
&
radiusDiff
<
0
?
-
1
.
0f
:
1
.
0f
;
SkScalar
circleProjectionFactor
=
roundIntegerMultiple
(
factorZeroCrossing
*
direction
tileMode
)
;
startToEnd
.
scale
(
circleProjectionFactor
)
;
startRadius
+
=
circleProjectionFactor
*
radiusDiff
;
endRadius
+
=
circleProjectionFactor
*
radiusDiff
;
start
+
=
startToEnd
;
end
+
=
startToEnd
;
}
}
}
std
:
:
unique_ptr
<
SkColor4f
[
]
>
skColors
(
new
SkColor4f
[
stops
.
size
(
)
]
)
;
std
:
:
unique_ptr
<
SkScalar
[
]
>
skStops
(
new
SkScalar
[
stops
.
size
(
)
]
)
;
for
(
size_t
i
=
0
;
i
<
stops
.
size
(
)
;
+
+
i
)
{
skColors
[
i
]
=
sk_color_from
(
stops
[
i
]
.
color
)
;
skStops
[
i
]
=
stops
[
i
]
.
position
;
}
skPaint
.
setColor
(
SK_ColorBLACK
)
;
skPaint
.
setShader
(
SkGradientShader
:
:
MakeTwoPointConical
(
start
startRadius
end
endRadius
skColors
.
get
(
)
SkColorSpace
:
:
MakeSRGB
(
)
skStops
.
get
(
)
stops
.
size
(
)
tileMode
SkGradientShader
:
:
Interpolation
{
SkGradientShader
:
:
Interpolation
:
:
InPremul
:
:
kNo
SkGradientShader
:
:
Interpolation
:
:
ColorSpace
:
:
kSRGB
SkGradientShader
:
:
Interpolation
:
:
HueMethod
:
:
kShorter
}
nullptr
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_SWEEP_GRADIENT
:
{
auto
const
&
sweepGradient
=
element
.
paint
.
sweepGradient
;
if
(
sweepGradient
.
gradientStopCount
=
=
0
)
{
return
true
;
}
std
:
:
vector
<
D2D1_GRADIENT_STOP
>
stops
;
stops
.
resize
(
sweepGradient
.
gradientStopCount
)
;
HRBM
(
reader
.
GetGradientStops
(
0
stops
.
size
(
)
stops
.
data
(
)
)
"
Could
not
get
sweep
gradient
stops
"
)
;
SkPaint
skPaint
;
if
(
stops
.
size
(
)
=
=
1
)
{
skPaint
.
setColor4f
(
sk_color_from
(
stops
[
0
]
.
color
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
SkPoint
center
=
SkPoint
:
:
Make
(
sweepGradient
.
centerX
sweepGradient
.
centerY
)
;
SkScalar
startAngle
=
sweepGradient
.
startAngle
;
SkScalar
endAngle
=
sweepGradient
.
endAngle
;
skPaint
.
setColor
(
SK_ColorBLACK
)
;
SkScalar
sectorAngle
=
endAngle
-
startAngle
;
SkTileMode
tileMode
=
sk_tile_mode_from
(
SkTo
<
D2D1_EXTEND_MODE
>
(
sweepGradient
.
extendMode
)
)
;
if
(
sectorAngle
=
=
0
&
&
tileMode
!
=
SkTileMode
:
:
kClamp
)
{
return
true
;
}
SkScalar
startAngleScaled
=
startAngle
+
sectorAngle
*
stops
.
front
(
)
.
position
;
SkScalar
endAngleScaled
=
startAngle
+
sectorAngle
*
stops
.
back
(
)
.
position
;
float
colorStopRange
=
stops
.
back
(
)
.
position
-
stops
.
front
(
)
.
position
;
if
(
colorStopRange
=
=
0
.
f
)
{
if
(
tileMode
!
=
SkTileMode
:
:
kClamp
)
{
return
true
;
}
else
{
stops
.
push_back
(
{
stops
.
back
(
)
.
position
+
1
.
0f
stops
.
back
(
)
.
color
}
)
;
colorStopRange
=
1
.
0f
;
}
}
SkScalar
scaleFactor
=
1
/
colorStopRange
;
SkScalar
startOffset
=
stops
.
front
(
)
.
position
;
for
(
D2D1_GRADIENT_STOP
&
stop
:
stops
)
{
stop
.
position
=
(
stop
.
position
-
startOffset
)
*
scaleFactor
;
}
startAngleScaled
=
360
.
f
-
startAngleScaled
;
endAngleScaled
=
360
.
f
-
endAngleScaled
;
if
(
startAngleScaled
>
=
endAngleScaled
)
{
std
:
:
swap
(
startAngleScaled
endAngleScaled
)
;
std
:
:
reverse
(
stops
.
begin
(
)
stops
.
end
(
)
)
;
for
(
auto
&
stop
:
stops
)
{
stop
.
position
=
1
.
0f
-
stop
.
position
;
}
}
std
:
:
unique_ptr
<
SkColor4f
[
]
>
skColors
(
new
SkColor4f
[
stops
.
size
(
)
]
)
;
std
:
:
unique_ptr
<
SkScalar
[
]
>
skStops
(
new
SkScalar
[
stops
.
size
(
)
]
)
;
for
(
size_t
i
=
0
;
i
<
stops
.
size
(
)
;
+
+
i
)
{
skColors
[
i
]
=
sk_color_from
(
stops
[
i
]
.
color
)
;
skStops
[
i
]
=
stops
[
i
]
.
position
;
}
skPaint
.
setShader
(
SkGradientShader
:
:
MakeSweep
(
center
.
x
(
)
center
.
y
(
)
skColors
.
get
(
)
SkColorSpace
:
:
MakeSRGB
(
)
skStops
.
get
(
)
stops
.
size
(
)
tileMode
startAngleScaled
endAngleScaled
SkGradientShader
:
:
Interpolation
{
SkGradientShader
:
:
Interpolation
:
:
InPremul
:
:
kNo
SkGradientShader
:
:
Interpolation
:
:
ColorSpace
:
:
kSRGB
SkGradientShader
:
:
Interpolation
:
:
HueMethod
:
:
kShorter
}
nullptr
)
)
;
canvas
.
drawPaint
(
skPaint
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_GLYPH
:
{
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
UINT16
glyphId
=
SkTo
<
UINT16
>
(
element
.
paint
.
glyph
.
glyphIndex
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGlyphRunOutline
(
SkScalarToFloat
(
fTextSizeRender
)
&
glyphId
nullptr
nullptr
1
FALSE
FALSE
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
path
.
transform
(
SkMatrix
:
:
Scale
(
1
.
0f
/
fTextSizeRender
1
.
0f
/
fTextSizeRender
)
)
;
canvas
.
clipPath
(
path
fRenderingMode
!
=
DWRITE_RENDERING_MODE_ALIASED
)
;
drawChildren
(
1
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_COLOR_GLYPH
:
{
auto
const
&
colorGlyph
=
element
.
paint
.
colorGlyph
;
if
(
D2D_RECT_F_is_empty
(
colorGlyph
.
clipBox
)
)
{
}
else
{
SkRect
r
=
sk_rect_from
(
colorGlyph
.
clipBox
)
;
canvas
.
clipRect
(
r
fRenderingMode
!
=
DWRITE_RENDERING_MODE_ALIASED
)
;
}
drawChildren
(
1
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_TRANSFORM
:
{
canvas
.
concat
(
sk_matrix_from
(
element
.
paint
.
transform
)
)
;
drawChildren
(
1
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_COMPOSITE
:
{
SkPaint
blendModePaint
;
blendModePaint
.
setBlendMode
(
sk_blend_mode_from
(
element
.
paint
.
composite
.
mode
)
)
;
SkAutoCanvasRestore
acr
(
&
canvas
false
)
;
DWRITE_PAINT_ELEMENT
sourceElement
;
DWRITE_PAINT_ELEMENT
backdropElement
;
HRBM
(
reader
.
MoveToFirstChild
(
&
sourceElement
)
"
Could
not
move
to
child
.
"
)
;
HRBM
(
reader
.
MoveToNextSibling
(
&
backdropElement
)
"
Could
not
move
to
sibiling
.
"
)
;
canvas
.
saveLayer
(
nullptr
nullptr
)
;
this
-
>
drawColorV1Paint
(
canvas
reader
backdropElement
)
;
HRBM
(
reader
.
MoveToParent
(
)
"
Could
not
move
to
parent
.
"
)
;
HRBM
(
reader
.
MoveToFirstChild
(
&
sourceElement
)
"
Could
not
move
to
child
.
"
)
;
canvas
.
saveLayer
(
nullptr
&
blendModePaint
)
;
this
-
>
drawColorV1Paint
(
canvas
reader
sourceElement
)
;
HRBM
(
reader
.
MoveToParent
(
)
"
Could
not
move
to
parent
.
"
)
;
return
true
;
}
default
:
return
false
;
}
}
bool
SkScalerContext_DW
:
:
drawColorV1Image
(
const
SkGlyph
&
glyph
SkCanvas
&
canvas
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
IDWriteFontFace7
*
fontFace
=
typeface
-
>
fDWriteFontFace7
;
if
(
!
fontFace
)
{
return
false
;
}
UINT32
glyphIndex
=
glyph
.
getGlyphID
(
)
;
SkTScopedComPtr
<
IDWritePaintReader
>
paintReader
;
HRBM
(
fontFace
-
>
CreatePaintReader
(
DWRITE_GLYPH_IMAGE_FORMATS_COLR_PAINT_TREE
DWRITE_PAINT_FEATURE_LEVEL_COLR_V1
&
paintReader
)
"
Could
not
create
paint
reader
.
"
)
;
DWRITE_PAINT_ELEMENT
paintElement
;
D2D_RECT_F
clipBox
;
DWRITE_PAINT_ATTRIBUTES
attributes
;
HRBM
(
paintReader
-
>
SetCurrentGlyph
(
glyphIndex
&
paintElement
&
clipBox
&
attributes
)
"
Could
not
set
current
glyph
.
"
)
;
if
(
paintElement
.
paintType
=
=
DWRITE_PAINT_TYPE_NONE
)
{
return
false
;
}
SkMatrix
matrix
=
fSkXform
;
SkScalar
scale
=
fTextSizeRender
;
matrix
.
preScale
(
scale
scale
)
;
if
(
this
-
>
isSubpixel
(
)
)
{
matrix
.
postTranslate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
canvas
.
concat
(
matrix
)
;
if
(
D2D_RECT_F_is_empty
(
clipBox
)
)
{
}
else
{
canvas
.
clipRect
(
sk_rect_from
(
clipBox
)
)
;
}
paintReader
-
>
SetTextColor
(
dw_color_from
(
SkColor4f
:
:
FromColor
(
fRec
.
fForegroundColor
)
)
)
;
paintReader
-
>
SetCustomColorPalette
(
typeface
-
>
fDWPalette
.
get
(
)
typeface
-
>
fPaletteEntryCount
)
;
return
this
-
>
drawColorV1Paint
(
canvas
*
paintReader
paintElement
)
;
}
bool
SkScalerContext_DW
:
:
generateColorV1Image
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
SkASSERT
(
glyph
.
maskFormat
(
)
=
=
SkMask
:
:
Format
:
:
kARGB32_Format
)
;
SkBitmap
dstBitmap
;
dstBitmap
.
setInfo
(
SkImageInfo
:
:
Make
(
glyph
.
width
(
)
glyph
.
height
(
)
kN32_SkColorType
kPremul_SkAlphaType
)
glyph
.
rowBytes
(
)
)
;
dstBitmap
.
setPixels
(
imageBuffer
)
;
SkCanvas
canvas
(
dstBitmap
)
;
if
constexpr
(
kSkShowTextBlitCoverage
)
{
canvas
.
clear
(
0x33FF0000
)
;
}
else
{
canvas
.
clear
(
SK_ColorTRANSPARENT
)
;
}
canvas
.
translate
(
-
SkIntToScalar
(
glyph
.
left
(
)
)
-
SkIntToScalar
(
glyph
.
top
(
)
)
)
;
return
this
-
>
drawColorV1Image
(
glyph
canvas
)
;
}
bool
SkScalerContext_DW
:
:
generateColorV1PaintBounds
(
SkMatrix
*
ctm
SkRect
*
bounds
IDWritePaintReader
&
reader
DWRITE_PAINT_ELEMENT
const
&
element
)
{
auto
boundChildren
=
[
&
]
(
UINT32
childCount
)
-
>
bool
{
if
(
childCount
=
=
0
)
{
return
true
;
}
DWRITE_PAINT_ELEMENT
childElement
;
HRB
(
reader
.
MoveToFirstChild
(
&
childElement
)
)
;
this
-
>
generateColorV1PaintBounds
(
ctm
bounds
reader
childElement
)
;
for
(
uint32_t
i
=
1
;
i
<
childCount
;
+
+
i
)
{
HRB
(
reader
.
MoveToNextSibling
(
&
childElement
)
)
;
this
-
>
generateColorV1PaintBounds
(
ctm
bounds
reader
childElement
)
;
}
HRB
(
reader
.
MoveToParent
(
)
)
;
return
true
;
}
;
SkMatrix
restoreMatrix
=
*
ctm
;
SK_AT_SCOPE_EXIT
(
*
ctm
=
restoreMatrix
)
;
switch
(
element
.
paintType
)
{
case
DWRITE_PAINT_TYPE_NONE
:
return
false
;
case
DWRITE_PAINT_TYPE_LAYERS
:
{
return
boundChildren
(
element
.
paint
.
layers
.
childCount
)
;
}
case
DWRITE_PAINT_TYPE_SOLID_GLYPH
:
{
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
UINT16
glyphId
=
SkTo
<
UINT16
>
(
element
.
paint
.
solidGlyph
.
glyphIndex
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGlyphRunOutline
(
SkScalarToFloat
(
fTextSizeRender
)
&
glyphId
nullptr
nullptr
1
FALSE
FALSE
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
SkMatrix
t
=
*
ctm
;
t
.
preConcat
(
SkMatrix
:
:
Scale
(
1
.
0f
/
fTextSizeRender
1
.
0f
/
fTextSizeRender
)
)
;
path
.
transform
(
t
)
;
bounds
-
>
join
(
path
.
getBounds
(
)
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_SOLID
:
{
return
true
;
}
case
DWRITE_PAINT_TYPE_LINEAR_GRADIENT
:
{
return
true
;
}
case
DWRITE_PAINT_TYPE_RADIAL_GRADIENT
:
{
return
true
;
}
case
DWRITE_PAINT_TYPE_SWEEP_GRADIENT
:
{
return
true
;
}
case
DWRITE_PAINT_TYPE_GLYPH
:
{
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
UINT16
glyphId
=
SkTo
<
UINT16
>
(
element
.
paint
.
glyph
.
glyphIndex
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGlyphRunOutline
(
SkScalarToFloat
(
fTextSizeRender
)
&
glyphId
nullptr
nullptr
1
FALSE
FALSE
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
SkMatrix
t
=
*
ctm
;
t
.
preConcat
(
SkMatrix
:
:
Scale
(
1
.
0f
/
fTextSizeRender
1
.
0f
/
fTextSizeRender
)
)
;
path
.
transform
(
t
)
;
bounds
-
>
join
(
path
.
getBounds
(
)
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_COLOR_GLYPH
:
{
auto
const
&
colorGlyph
=
element
.
paint
.
colorGlyph
;
if
(
D2D_RECT_F_is_empty
(
colorGlyph
.
clipBox
)
)
{
return
boundChildren
(
1
)
;
}
SkRect
r
=
sk_rect_from
(
colorGlyph
.
clipBox
)
;
ctm
-
>
mapRect
(
r
)
;
bounds
-
>
join
(
r
)
;
return
true
;
}
case
DWRITE_PAINT_TYPE_TRANSFORM
:
{
ctm
-
>
preConcat
(
sk_matrix_from
(
element
.
paint
.
transform
)
)
;
return
boundChildren
(
1
)
;
}
case
DWRITE_PAINT_TYPE_COMPOSITE
:
{
return
boundChildren
(
2
)
;
}
default
:
return
false
;
}
}
bool
SkScalerContext_DW
:
:
generateColorV1Metrics
(
const
SkGlyph
&
glyph
SkRect
*
bounds
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
IDWriteFontFace7
*
fontFace
=
typeface
-
>
fDWriteFontFace7
;
if
(
!
fontFace
)
{
return
false
;
}
UINT32
glyphIndex
=
glyph
.
getGlyphID
(
)
;
SkTScopedComPtr
<
IDWritePaintReader
>
paintReader
;
HRESULT
hr
;
hr
=
fontFace
-
>
CreatePaintReader
(
DWRITE_GLYPH_IMAGE_FORMATS_COLR_PAINT_TREE
DWRITE_PAINT_FEATURE_LEVEL_COLR_V1
&
paintReader
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
DWRITE_PAINT_ELEMENT
paintElement
;
D2D_RECT_F
clipBox
;
DWRITE_PAINT_ATTRIBUTES
attributes
;
HRBM
(
paintReader
-
>
SetCurrentGlyph
(
glyphIndex
&
paintElement
&
clipBox
&
attributes
)
"
Could
not
set
the
current
glyph
.
"
)
;
if
(
paintElement
.
paintType
=
=
DWRITE_PAINT_TYPE_NONE
)
{
return
false
;
}
SkMatrix
matrix
=
fSkXform
;
SkScalar
scale
=
fTextSizeRender
;
matrix
.
preScale
(
scale
scale
)
;
if
(
this
-
>
isSubpixel
(
)
)
{
matrix
.
postTranslate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
SkRect
r
;
if
(
D2D_RECT_F_is_empty
(
clipBox
)
)
{
r
=
SkRect
:
:
MakeEmpty
(
)
;
if
(
!
this
-
>
generateColorV1PaintBounds
(
&
matrix
&
r
*
paintReader
paintElement
)
)
{
return
false
;
}
*
bounds
=
r
;
}
else
{
*
bounds
=
sk_rect_from
(
clipBox
)
;
matrix
.
mapRect
(
bounds
)
;
}
return
true
;
}
#
else
bool
SkScalerContext_DW
:
:
generateColorV1Metrics
(
const
SkGlyph
&
SkRect
*
)
{
return
false
;
}
bool
SkScalerContext_DW
:
:
generateColorV1Image
(
const
SkGlyph
&
void
*
)
{
return
false
;
}
bool
SkScalerContext_DW
:
:
drawColorV1Image
(
const
SkGlyph
&
SkCanvas
&
)
{
return
false
;
}
#
endif
bool
SkScalerContext_DW
:
:
setAdvance
(
const
SkGlyph
&
glyph
SkVector
*
advance
)
{
*
advance
=
{
0
0
}
;
uint16_t
glyphId
=
glyph
.
getGlyphID
(
)
;
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
if
(
fGlyphCount
<
=
glyphId
)
{
return
false
;
}
DWRITE_GLYPH_METRICS
gm
;
if
(
DWRITE_MEASURING_MODE_GDI_CLASSIC
=
=
fMeasuringMode
|
|
DWRITE_MEASURING_MODE_GDI_NATURAL
=
=
fMeasuringMode
)
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
HRBM
(
typeface
-
>
fDWriteFontFace
-
>
GetGdiCompatibleGlyphMetrics
(
fTextSizeMeasure
1
.
0f
nullptr
DWRITE_MEASURING_MODE_GDI_NATURAL
=
=
fMeasuringMode
&
glyphId
1
&
gm
)
"
Could
not
get
gdi
compatible
glyph
metrics
.
"
)
;
}
else
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
HRBM
(
typeface
-
>
fDWriteFontFace
-
>
GetDesignGlyphMetrics
(
&
glyphId
1
&
gm
)
"
Could
not
get
design
metrics
.
"
)
;
}
DWRITE_FONT_METRICS
dwfm
;
{
Shared
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
typeface
-
>
fDWriteFontFace
-
>
GetMetrics
(
&
dwfm
)
;
}
SkScalar
advanceX
=
fTextSizeMeasure
*
gm
.
advanceWidth
/
dwfm
.
designUnitsPerEm
;
*
advance
=
{
advanceX
0
}
;
if
(
DWRITE_MEASURING_MODE_GDI_CLASSIC
=
=
fMeasuringMode
|
|
DWRITE_MEASURING_MODE_GDI_NATURAL
=
=
fMeasuringMode
)
{
advance
-
>
fX
=
SkScalarRoundToScalar
(
advance
-
>
fX
)
;
}
fSkXform
.
mapVectors
(
advance
1
)
;
return
true
;
}
bool
SkScalerContext_DW
:
:
generateDWMetrics
(
const
SkGlyph
&
glyph
DWRITE_RENDERING_MODE
renderingMode
DWRITE_TEXTURE_TYPE
textureType
SkRect
*
bounds
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
fXform
.
dx
=
SkFixedToFloat
(
glyph
.
getSubXFixed
(
)
)
;
fXform
.
dy
=
SkFixedToFloat
(
glyph
.
getSubYFixed
(
)
)
;
FLOAT
advance
=
0
;
UINT16
glyphId
=
glyph
.
getGlyphID
(
)
;
DWRITE_GLYPH_OFFSET
offset
;
offset
.
advanceOffset
=
0
.
0f
;
offset
.
ascenderOffset
=
0
.
0f
;
DWRITE_GLYPH_RUN
run
;
run
.
glyphCount
=
1
;
run
.
glyphAdvances
=
&
advance
;
run
.
fontFace
=
typeface
-
>
fDWriteFontFace
.
get
(
)
;
run
.
fontEmSize
=
SkScalarToFloat
(
fTextSizeRender
)
;
run
.
bidiLevel
=
0
;
run
.
glyphIndices
=
&
glyphId
;
run
.
isSideways
=
FALSE
;
run
.
glyphOffsets
=
&
offset
;
SkTScopedComPtr
<
IDWriteGlyphRunAnalysis
>
glyphRunAnalysis
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
if
(
typeface
-
>
fFactory2
&
&
(
fGridFitMode
=
=
DWRITE_GRID_FIT_MODE_DISABLED
|
|
fAntiAliasMode
=
=
DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE
)
)
{
HRBM
(
typeface
-
>
fFactory2
-
>
CreateGlyphRunAnalysis
(
&
run
&
fXform
renderingMode
fMeasuringMode
fGridFitMode
fAntiAliasMode
0
.
0f
0
.
0f
&
glyphRunAnalysis
)
"
Could
not
create
DW2
glyph
run
analysis
.
"
)
;
}
else
{
HRBM
(
typeface
-
>
fFactory
-
>
CreateGlyphRunAnalysis
(
&
run
1
.
0f
&
fXform
renderingMode
fMeasuringMode
0
.
0f
0
.
0f
&
glyphRunAnalysis
)
"
Could
not
create
glyph
run
analysis
.
"
)
;
}
}
RECT
bbox
;
{
Shared
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
HRBM
(
glyphRunAnalysis
-
>
GetAlphaTextureBounds
(
textureType
&
bbox
)
"
Could
not
get
texture
bounds
.
"
)
;
}
if
(
bbox
.
left
>
=
bbox
.
right
|
|
bbox
.
top
>
=
bbox
.
bottom
)
{
return
false
;
}
*
bounds
=
SkRect
:
:
MakeLTRB
(
bbox
.
left
bbox
.
top
bbox
.
right
bbox
.
bottom
)
;
return
true
;
}
bool
SkScalerContext_DW
:
:
getColorGlyphRun
(
const
SkGlyph
&
glyph
IDWriteColorGlyphRunEnumerator
*
*
colorGlyph
)
{
FLOAT
advance
=
0
;
UINT16
glyphId
=
glyph
.
getGlyphID
(
)
;
DWRITE_GLYPH_OFFSET
offset
;
offset
.
advanceOffset
=
0
.
0f
;
offset
.
ascenderOffset
=
0
.
0f
;
DWRITE_GLYPH_RUN
run
;
run
.
glyphCount
=
1
;
run
.
glyphAdvances
=
&
advance
;
run
.
fontFace
=
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
.
get
(
)
;
run
.
fontEmSize
=
SkScalarToFloat
(
fTextSizeRender
)
;
run
.
bidiLevel
=
0
;
run
.
glyphIndices
=
&
glyphId
;
run
.
isSideways
=
FALSE
;
run
.
glyphOffsets
=
&
offset
;
HRESULT
hr
=
this
-
>
getDWriteTypeface
(
)
-
>
fFactory2
-
>
TranslateColorGlyphRun
(
0
0
&
run
nullptr
fMeasuringMode
&
fXform
0
colorGlyph
)
;
if
(
hr
=
=
DWRITE_E_NOCOLOR
)
{
return
false
;
}
HRBM
(
hr
"
Failed
to
translate
color
glyph
run
"
)
;
return
true
;
}
bool
SkScalerContext_DW
:
:
generateColorMetrics
(
const
SkGlyph
&
glyph
SkRect
*
bounds
)
{
SkTScopedComPtr
<
IDWriteColorGlyphRunEnumerator
>
colorLayers
;
if
(
!
getColorGlyphRun
(
glyph
&
colorLayers
)
)
{
return
false
;
}
SkASSERT
(
colorLayers
.
get
(
)
)
;
*
bounds
=
SkRect
:
:
MakeEmpty
(
)
;
BOOL
hasNextRun
=
FALSE
;
while
(
SUCCEEDED
(
colorLayers
-
>
MoveNext
(
&
hasNextRun
)
)
&
&
hasNextRun
)
{
const
DWRITE_COLOR_GLYPH_RUN
*
colorGlyph
;
HRBM
(
colorLayers
-
>
GetCurrentRun
(
&
colorGlyph
)
"
Could
not
get
current
color
glyph
run
"
)
;
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
colorGlyph
-
>
glyphRun
.
fontFace
-
>
GetGlyphRunOutline
(
colorGlyph
-
>
glyphRun
.
fontEmSize
colorGlyph
-
>
glyphRun
.
glyphIndices
colorGlyph
-
>
glyphRun
.
glyphAdvances
colorGlyph
-
>
glyphRun
.
glyphOffsets
colorGlyph
-
>
glyphRun
.
glyphCount
colorGlyph
-
>
glyphRun
.
isSideways
colorGlyph
-
>
glyphRun
.
bidiLevel
%
2
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
bounds
-
>
join
(
path
.
getBounds
(
)
)
;
}
SkMatrix
matrix
=
fSkXform
;
if
(
this
-
>
isSubpixel
(
)
)
{
matrix
.
postTranslate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
matrix
.
mapRect
(
bounds
)
;
return
true
;
}
#
ifdef
USE_SVG
bool
SkScalerContext_DW
:
:
generateSVGMetrics
(
const
SkGlyph
&
glyph
SkRect
*
bounds
)
{
SkPictureRecorder
recorder
;
SkRect
infiniteRect
=
SkRect
:
:
MakeLTRB
(
-
SK_ScalarInfinity
-
SK_ScalarInfinity
SK_ScalarInfinity
SK_ScalarInfinity
)
;
sk_sp
<
SkBBoxHierarchy
>
bboxh
=
SkRTreeFactory
(
)
(
)
;
SkCanvas
*
recordingCanvas
=
recorder
.
beginRecording
(
infiniteRect
bboxh
)
;
if
(
!
this
-
>
drawSVGImage
(
glyph
*
recordingCanvas
)
)
{
return
false
;
}
sk_sp
<
SkPicture
>
pic
=
recorder
.
finishRecordingAsPicture
(
)
;
*
bounds
=
pic
-
>
cullRect
(
)
;
SkASSERT
(
bounds
-
>
isFinite
(
)
)
;
bounds
-
>
roundOut
(
bounds
)
;
return
true
;
}
#
endif
#
ifdef
USE_PNG
namespace
{
struct
Context
{
SkTScopedComPtr
<
IDWriteFontFace4
>
fontFace4
;
void
*
glyphDataContext
;
Context
(
IDWriteFontFace4
*
face4
void
*
context
)
:
fontFace4
(
SkRefComPtr
(
face4
)
)
glyphDataContext
(
context
)
{
}
}
;
static
void
ReleaseProc
(
const
void
*
ptr
void
*
context
)
{
Context
*
ctx
=
(
Context
*
)
context
;
ctx
-
>
fontFace4
-
>
ReleaseGlyphImageData
(
ctx
-
>
glyphDataContext
)
;
delete
ctx
;
}
}
bool
SkScalerContext_DW
:
:
generatePngMetrics
(
const
SkGlyph
&
glyph
SkRect
*
bounds
)
{
IDWriteFontFace4
*
fontFace4
=
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace4
.
get
(
)
;
if
(
!
fontFace4
)
{
return
false
;
}
DWRITE_GLYPH_IMAGE_FORMATS
imageFormats
;
HRBM
(
fontFace4
-
>
GetGlyphImageFormats
(
glyph
.
getGlyphID
(
)
0
UINT32_MAX
&
imageFormats
)
"
Cannot
get
glyph
image
formats
.
"
)
;
if
(
!
(
imageFormats
&
DWRITE_GLYPH_IMAGE_FORMATS_PNG
)
)
{
return
false
;
}
DWRITE_GLYPH_IMAGE_DATA
glyphData
;
void
*
glyphDataContext
;
HRBM
(
fontFace4
-
>
GetGlyphImageData
(
glyph
.
getGlyphID
(
)
fTextSizeRender
DWRITE_GLYPH_IMAGE_FORMATS_PNG
&
glyphData
&
glyphDataContext
)
"
Glyph
image
data
could
not
be
acquired
.
"
)
;
Context
*
context
=
new
Context
(
fontFace4
glyphDataContext
)
;
sk_sp
<
SkData
>
data
=
SkData
:
:
MakeWithProc
(
glyphData
.
imageData
glyphData
.
imageDataSize
&
ReleaseProc
context
)
;
std
:
:
unique_ptr
<
SkCodec
>
codec
=
SkPngDecoder
:
:
Decode
(
std
:
:
move
(
data
)
nullptr
)
;
if
(
!
codec
)
{
return
false
;
}
SkImageInfo
info
=
codec
-
>
getInfo
(
)
;
*
bounds
=
SkRect
:
:
MakeLTRB
(
SkIntToScalar
(
info
.
bounds
(
)
.
fLeft
)
SkIntToScalar
(
info
.
bounds
(
)
.
fTop
)
SkIntToScalar
(
info
.
bounds
(
)
.
fRight
)
SkIntToScalar
(
info
.
bounds
(
)
.
fBottom
)
)
;
SkMatrix
matrix
=
fSkXform
;
SkScalar
scale
=
fTextSizeRender
/
glyphData
.
pixelsPerEm
;
matrix
.
preScale
(
scale
scale
)
;
matrix
.
preTranslate
(
-
glyphData
.
horizontalLeftOrigin
.
x
-
glyphData
.
horizontalLeftOrigin
.
y
)
;
if
(
this
-
>
isSubpixel
(
)
)
{
matrix
.
postTranslate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
matrix
.
mapRect
(
bounds
)
;
bounds
-
>
roundOut
(
bounds
)
;
return
true
;
}
#
endif
SkScalerContext
:
:
GlyphMetrics
SkScalerContext_DW
:
:
generateMetrics
(
const
SkGlyph
&
glyph
SkArenaAlloc
*
alloc
)
{
GlyphMetrics
mx
(
glyph
.
maskFormat
(
)
)
;
mx
.
extraBits
=
ScalerContextBits
:
:
NONE
;
if
(
!
this
-
>
setAdvance
(
glyph
&
mx
.
advance
)
)
{
return
mx
;
}
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
if
(
typeface
-
>
fIsColorFont
)
{
if
(
generateColorV1Metrics
(
glyph
&
mx
.
bounds
)
)
{
mx
.
maskFormat
=
SkMask
:
:
kARGB32_Format
;
mx
.
extraBits
|
=
ScalerContextBits
:
:
COLRv1
;
mx
.
neverRequestPath
=
true
;
return
mx
;
}
if
(
generateColorMetrics
(
glyph
&
mx
.
bounds
)
)
{
mx
.
maskFormat
=
SkMask
:
:
kARGB32_Format
;
mx
.
extraBits
|
=
ScalerContextBits
:
:
COLR
;
mx
.
neverRequestPath
=
true
;
return
mx
;
}
#
ifdef
USE_SVG
if
(
generateSVGMetrics
(
glyph
&
mx
.
bounds
)
)
{
mx
.
maskFormat
=
SkMask
:
:
kARGB32_Format
;
mx
.
extraBits
|
=
ScalerContextBits
:
:
SVG
;
mx
.
neverRequestPath
=
true
;
return
mx
;
}
#
endif
#
ifdef
USE_PNG
if
(
generatePngMetrics
(
glyph
&
mx
.
bounds
)
)
{
mx
.
maskFormat
=
SkMask
:
:
kARGB32_Format
;
mx
.
extraBits
|
=
ScalerContextBits
:
:
PNG
;
mx
.
neverRequestPath
=
true
;
return
mx
;
}
#
endif
}
if
(
this
-
>
generateDWMetrics
(
glyph
fRenderingMode
fTextureType
&
mx
.
bounds
)
)
{
mx
.
extraBits
=
ScalerContextBits
:
:
DW
;
return
mx
;
}
if
(
DWRITE_TEXTURE_ALIASED_1x1
!
=
fTextureType
|
|
DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE
=
=
fAntiAliasMode
)
{
if
(
this
-
>
generateDWMetrics
(
glyph
DWRITE_RENDERING_MODE_ALIASED
DWRITE_TEXTURE_ALIASED_1x1
&
mx
.
bounds
)
)
{
mx
.
maskFormat
=
SkMask
:
:
kBW_Format
;
mx
.
extraBits
=
ScalerContextBits
:
:
DW_1
;
return
mx
;
}
}
mx
.
computeFromPath
=
true
;
mx
.
extraBits
=
ScalerContextBits
:
:
PATH
;
return
mx
;
}
void
SkScalerContext_DW
:
:
generateFontMetrics
(
SkFontMetrics
*
metrics
)
{
if
(
nullptr
=
=
metrics
)
{
return
;
}
sk_bzero
(
metrics
sizeof
(
*
metrics
)
)
;
DWRITE_FONT_METRICS
dwfm
;
if
(
DWRITE_MEASURING_MODE_GDI_CLASSIC
=
=
fMeasuringMode
|
|
DWRITE_MEASURING_MODE_GDI_NATURAL
=
=
fMeasuringMode
)
{
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGdiCompatibleMetrics
(
fTextSizeRender
1
.
0f
&
fXform
&
dwfm
)
;
}
else
{
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetMetrics
(
&
dwfm
)
;
}
SkScalar
upem
=
SkIntToScalar
(
dwfm
.
designUnitsPerEm
)
;
metrics
-
>
fAscent
=
-
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
ascent
)
/
upem
;
metrics
-
>
fDescent
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
descent
)
/
upem
;
metrics
-
>
fLeading
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
lineGap
)
/
upem
;
metrics
-
>
fXHeight
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
xHeight
)
/
upem
;
metrics
-
>
fCapHeight
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
capHeight
)
/
upem
;
metrics
-
>
fUnderlineThickness
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
underlineThickness
)
/
upem
;
metrics
-
>
fUnderlinePosition
=
-
(
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
underlinePosition
)
/
upem
)
;
metrics
-
>
fStrikeoutThickness
=
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
strikethroughThickness
)
/
upem
;
metrics
-
>
fStrikeoutPosition
=
-
(
fTextSizeRender
*
SkIntToScalar
(
dwfm
.
strikethroughPosition
)
/
upem
)
;
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kUnderlineThicknessIsValid_Flag
;
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kUnderlinePositionIsValid_Flag
;
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kStrikeoutThicknessIsValid_Flag
;
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kStrikeoutPositionIsValid_Flag
;
SkTScopedComPtr
<
IDWriteFontFace5
>
fontFace5
;
if
(
SUCCEEDED
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
QueryInterface
(
&
fontFace5
)
)
)
{
if
(
fontFace5
-
>
HasVariations
(
)
)
{
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kBoundsInvalid_Flag
;
}
}
if
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace1
.
get
(
)
)
{
DWRITE_FONT_METRICS1
dwfm1
;
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace1
-
>
GetMetrics
(
&
dwfm1
)
;
metrics
-
>
fTop
=
-
fTextSizeRender
*
SkIntToScalar
(
dwfm1
.
glyphBoxTop
)
/
upem
;
metrics
-
>
fBottom
=
-
fTextSizeRender
*
SkIntToScalar
(
dwfm1
.
glyphBoxBottom
)
/
upem
;
metrics
-
>
fXMin
=
fTextSizeRender
*
SkIntToScalar
(
dwfm1
.
glyphBoxLeft
)
/
upem
;
metrics
-
>
fXMax
=
fTextSizeRender
*
SkIntToScalar
(
dwfm1
.
glyphBoxRight
)
/
upem
;
metrics
-
>
fMaxCharWidth
=
metrics
-
>
fXMax
-
metrics
-
>
fXMin
;
return
;
}
AutoTDWriteTable
<
SkOTTableHead
>
head
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
.
get
(
)
)
;
if
(
head
.
fExists
&
&
head
.
fSize
>
=
sizeof
(
SkOTTableHead
)
&
&
head
-
>
version
=
=
SkOTTableHead
:
:
version1
)
{
metrics
-
>
fTop
=
-
fTextSizeRender
*
(
int16_t
)
SkEndian_SwapBE16
(
head
-
>
yMax
)
/
upem
;
metrics
-
>
fBottom
=
-
fTextSizeRender
*
(
int16_t
)
SkEndian_SwapBE16
(
head
-
>
yMin
)
/
upem
;
metrics
-
>
fXMin
=
fTextSizeRender
*
(
int16_t
)
SkEndian_SwapBE16
(
head
-
>
xMin
)
/
upem
;
metrics
-
>
fXMax
=
fTextSizeRender
*
(
int16_t
)
SkEndian_SwapBE16
(
head
-
>
xMax
)
/
upem
;
metrics
-
>
fMaxCharWidth
=
metrics
-
>
fXMax
-
metrics
-
>
fXMin
;
return
;
}
metrics
-
>
fFlags
|
=
SkFontMetrics
:
:
kBoundsInvalid_Flag
;
metrics
-
>
fTop
=
metrics
-
>
fAscent
;
metrics
-
>
fBottom
=
metrics
-
>
fDescent
;
}
#
include
"
include
/
private
/
SkColorData
.
h
"
void
SkScalerContext_DW
:
:
BilevelToBW
(
const
uint8_t
*
SK_RESTRICT
src
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
const
int
width
=
glyph
.
width
(
)
;
const
size_t
dstRB
=
(
width
+
7
)
>
>
3
;
uint8_t
*
SK_RESTRICT
dst
=
static_cast
<
uint8_t
*
>
(
imageBuffer
)
;
int
byteCount
=
width
>
>
3
;
int
bitCount
=
width
&
7
;
for
(
int
y
=
0
;
y
<
glyph
.
height
(
)
;
+
+
y
)
{
if
(
byteCount
>
0
)
{
for
(
int
i
=
0
;
i
<
byteCount
;
+
+
i
)
{
unsigned
byte
=
0
;
byte
|
=
src
[
0
]
&
(
1
<
<
7
)
;
byte
|
=
src
[
1
]
&
(
1
<
<
6
)
;
byte
|
=
src
[
2
]
&
(
1
<
<
5
)
;
byte
|
=
src
[
3
]
&
(
1
<
<
4
)
;
byte
|
=
src
[
4
]
&
(
1
<
<
3
)
;
byte
|
=
src
[
5
]
&
(
1
<
<
2
)
;
byte
|
=
src
[
6
]
&
(
1
<
<
1
)
;
byte
|
=
src
[
7
]
&
(
1
<
<
0
)
;
dst
[
i
]
=
byte
;
src
+
=
8
;
}
}
if
(
bitCount
>
0
)
{
unsigned
byte
=
0
;
unsigned
mask
=
0x80
;
for
(
int
i
=
0
;
i
<
bitCount
;
i
+
+
)
{
byte
|
=
(
src
[
i
]
)
&
mask
;
mask
>
>
=
1
;
}
dst
[
byteCount
]
=
byte
;
}
src
+
=
bitCount
;
dst
+
=
dstRB
;
}
if
constexpr
(
kSkShowTextBlitCoverage
)
{
dst
=
static_cast
<
uint8_t
*
>
(
imageBuffer
)
;
for
(
unsigned
y
=
0
;
y
<
(
unsigned
)
glyph
.
height
(
)
;
y
+
=
2
)
{
for
(
unsigned
x
=
(
y
&
0x2
)
;
x
<
(
unsigned
)
glyph
.
width
(
)
;
x
+
=
4
)
{
uint8_t
&
b
=
dst
[
(
dstRB
*
y
)
+
(
x
>
>
3
)
]
;
b
=
b
^
(
1
<
<
(
0x7
-
(
x
&
0x7
)
)
)
;
}
}
}
}
template
<
bool
APPLY_PREBLEND
>
void
SkScalerContext_DW
:
:
GrayscaleToA8
(
const
uint8_t
*
SK_RESTRICT
src
const
SkGlyph
&
glyph
void
*
imageBuffer
const
uint8_t
*
table8
)
{
const
size_t
dstRB
=
glyph
.
rowBytes
(
)
;
const
int
width
=
glyph
.
width
(
)
;
uint8_t
*
SK_RESTRICT
dst
=
static_cast
<
uint8_t
*
>
(
imageBuffer
)
;
for
(
int
y
=
0
;
y
<
glyph
.
height
(
)
;
y
+
+
)
{
for
(
int
i
=
0
;
i
<
width
;
i
+
+
)
{
U8CPU
a
=
*
(
src
+
+
)
;
dst
[
i
]
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
a
table8
)
;
if
constexpr
(
kSkShowTextBlitCoverage
)
{
dst
[
i
]
=
std
:
:
max
<
U8CPU
>
(
0x30
dst
[
i
]
)
;
}
}
dst
=
SkTAddOffset
<
uint8_t
>
(
dst
dstRB
)
;
}
}
template
<
bool
APPLY_PREBLEND
>
void
SkScalerContext_DW
:
:
RGBToA8
(
const
uint8_t
*
SK_RESTRICT
src
const
SkGlyph
&
glyph
void
*
imageBuffer
const
uint8_t
*
table8
)
{
const
size_t
dstRB
=
glyph
.
rowBytes
(
)
;
const
int
width
=
glyph
.
width
(
)
;
uint8_t
*
SK_RESTRICT
dst
=
static_cast
<
uint8_t
*
>
(
imageBuffer
)
;
for
(
int
y
=
0
;
y
<
glyph
.
height
(
)
;
y
+
+
)
{
for
(
int
i
=
0
;
i
<
width
;
i
+
+
)
{
U8CPU
g
=
src
[
1
]
;
src
+
=
3
;
dst
[
i
]
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
g
table8
)
;
if
constexpr
(
kSkShowTextBlitCoverage
)
{
dst
[
i
]
=
std
:
:
max
<
U8CPU
>
(
0x30
dst
[
i
]
)
;
}
}
dst
=
SkTAddOffset
<
uint8_t
>
(
dst
dstRB
)
;
}
}
template
<
bool
APPLY_PREBLEND
bool
RGB
>
void
SkScalerContext_DW
:
:
RGBToLcd16
(
const
uint8_t
*
SK_RESTRICT
src
const
SkGlyph
&
glyph
void
*
imageBuffer
const
uint8_t
*
tableR
const
uint8_t
*
tableG
const
uint8_t
*
tableB
int
clearTypeLevel
)
{
const
size_t
dstRB
=
glyph
.
rowBytes
(
)
;
const
int
width
=
glyph
.
width
(
)
;
uint16_t
*
SK_RESTRICT
dst
=
static_cast
<
uint16_t
*
>
(
imageBuffer
)
;
for
(
int
y
=
0
;
y
<
glyph
.
height
(
)
;
y
+
+
)
{
for
(
int
i
=
0
;
i
<
width
;
i
+
+
)
{
int
r
g
b
;
if
(
RGB
)
{
r
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableR
)
;
g
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableG
)
;
b
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableB
)
;
}
else
{
b
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableB
)
;
g
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableG
)
;
r
=
sk_apply_lut_if
<
APPLY_PREBLEND
>
(
*
(
src
+
+
)
tableR
)
;
}
if
constexpr
(
kSkShowTextBlitCoverage
)
{
r
=
std
:
:
max
<
U8CPU
>
(
0x30
r
)
;
g
=
std
:
:
max
<
U8CPU
>
(
0x30
g
)
;
b
=
std
:
:
max
<
U8CPU
>
(
0x30
b
)
;
}
r
=
g
+
(
(
(
r
-
g
)
*
clearTypeLevel
)
>
>
8
)
;
b
=
g
+
(
(
(
b
-
g
)
*
clearTypeLevel
)
>
>
8
)
;
dst
[
i
]
=
SkPack888ToRGB16
(
r
g
b
)
;
}
dst
=
SkTAddOffset
<
uint16_t
>
(
dst
dstRB
)
;
}
}
const
void
*
SkScalerContext_DW
:
:
getDWMaskBits
(
const
SkGlyph
&
glyph
DWRITE_RENDERING_MODE
renderingMode
DWRITE_TEXTURE_TYPE
textureType
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
int
sizeNeeded
=
glyph
.
width
(
)
*
glyph
.
height
(
)
;
if
(
DWRITE_TEXTURE_CLEARTYPE_3x1
=
=
textureType
)
{
sizeNeeded
*
=
3
;
}
if
(
sizeNeeded
>
fBits
.
size
(
)
)
{
fBits
.
resize
(
sizeNeeded
)
;
}
memset
(
fBits
.
begin
(
)
0
sizeNeeded
)
;
fXform
.
dx
=
SkFixedToFloat
(
glyph
.
getSubXFixed
(
)
)
;
fXform
.
dy
=
SkFixedToFloat
(
glyph
.
getSubYFixed
(
)
)
;
FLOAT
advance
=
0
.
0f
;
UINT16
index
=
glyph
.
getGlyphID
(
)
;
DWRITE_GLYPH_OFFSET
offset
;
offset
.
advanceOffset
=
0
.
0f
;
offset
.
ascenderOffset
=
0
.
0f
;
DWRITE_GLYPH_RUN
run
;
run
.
glyphCount
=
1
;
run
.
glyphAdvances
=
&
advance
;
run
.
fontFace
=
typeface
-
>
fDWriteFontFace
.
get
(
)
;
run
.
fontEmSize
=
SkScalarToFloat
(
fTextSizeRender
)
;
run
.
bidiLevel
=
0
;
run
.
glyphIndices
=
&
index
;
run
.
isSideways
=
FALSE
;
run
.
glyphOffsets
=
&
offset
;
{
SkTScopedComPtr
<
IDWriteGlyphRunAnalysis
>
glyphRunAnalysis
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
if
(
typeface
-
>
fFactory2
&
&
(
fGridFitMode
=
=
DWRITE_GRID_FIT_MODE_DISABLED
|
|
fAntiAliasMode
=
=
DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE
)
)
{
HRNM
(
typeface
-
>
fFactory2
-
>
CreateGlyphRunAnalysis
(
&
run
&
fXform
renderingMode
fMeasuringMode
fGridFitMode
fAntiAliasMode
0
.
0f
0
.
0f
&
glyphRunAnalysis
)
"
Could
not
create
DW2
glyph
run
analysis
.
"
)
;
}
else
{
HRNM
(
typeface
-
>
fFactory
-
>
CreateGlyphRunAnalysis
(
&
run
1
.
0f
&
fXform
renderingMode
fMeasuringMode
0
.
0f
0
.
0f
&
glyphRunAnalysis
)
"
Could
not
create
glyph
run
analysis
.
"
)
;
}
}
RECT
bbox
;
bbox
.
left
=
glyph
.
left
(
)
;
bbox
.
top
=
glyph
.
top
(
)
;
bbox
.
right
=
glyph
.
left
(
)
+
glyph
.
width
(
)
;
bbox
.
bottom
=
glyph
.
top
(
)
+
glyph
.
height
(
)
;
{
Shared
l
(
maybe_dw_mutex
(
*
typeface
)
)
;
HRNM
(
glyphRunAnalysis
-
>
CreateAlphaTexture
(
textureType
&
bbox
fBits
.
begin
(
)
sizeNeeded
)
"
Could
not
draw
mask
.
"
)
;
}
}
return
fBits
.
begin
(
)
;
}
bool
SkScalerContext_DW
:
:
generateDWImage
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
ScalerContextBits
:
:
value_type
format
=
glyph
.
extraBits
(
)
;
DWRITE_RENDERING_MODE
renderingMode
=
fRenderingMode
;
DWRITE_TEXTURE_TYPE
textureType
=
fTextureType
;
if
(
format
=
=
ScalerContextBits
:
:
DW_1
)
{
renderingMode
=
DWRITE_RENDERING_MODE_ALIASED
;
textureType
=
DWRITE_TEXTURE_ALIASED_1x1
;
}
const
void
*
bits
=
this
-
>
getDWMaskBits
(
glyph
renderingMode
textureType
)
;
if
(
!
bits
)
{
sk_bzero
(
imageBuffer
glyph
.
imageSize
(
)
)
;
return
false
;
}
const
uint8_t
*
src
=
(
const
uint8_t
*
)
bits
;
if
(
DWRITE_RENDERING_MODE_ALIASED
=
=
renderingMode
)
{
SkASSERT
(
SkMask
:
:
kBW_Format
=
=
glyph
.
maskFormat
(
)
)
;
SkASSERT
(
DWRITE_TEXTURE_ALIASED_1x1
=
=
textureType
)
;
BilevelToBW
(
src
glyph
imageBuffer
)
;
}
else
if
(
!
isLCD
(
fRec
)
)
{
if
(
textureType
=
=
DWRITE_TEXTURE_ALIASED_1x1
)
{
if
(
fPreBlend
.
isApplicable
(
)
)
{
GrayscaleToA8
<
true
>
(
src
glyph
imageBuffer
fPreBlend
.
fG
)
;
}
else
{
GrayscaleToA8
<
false
>
(
src
glyph
imageBuffer
fPreBlend
.
fG
)
;
}
}
else
{
if
(
fPreBlend
.
isApplicable
(
)
)
{
RGBToA8
<
true
>
(
src
glyph
imageBuffer
fPreBlend
.
fG
)
;
}
else
{
RGBToA8
<
false
>
(
src
glyph
imageBuffer
fPreBlend
.
fG
)
;
}
}
}
else
{
SkASSERT
(
SkMask
:
:
kLCD16_Format
=
=
glyph
.
maskFormat
(
)
)
;
if
(
fPreBlend
.
isApplicable
(
)
)
{
if
(
fRec
.
fFlags
&
SkScalerContext
:
:
kLCD_BGROrder_Flag
)
{
RGBToLcd16
<
true
false
>
(
src
glyph
imageBuffer
fPreBlend
.
fR
fPreBlend
.
fG
fPreBlend
.
fB
fClearTypeLevel
)
;
}
else
{
RGBToLcd16
<
true
true
>
(
src
glyph
imageBuffer
fPreBlend
.
fR
fPreBlend
.
fG
fPreBlend
.
fB
fClearTypeLevel
)
;
}
}
else
{
if
(
fRec
.
fFlags
&
SkScalerContext
:
:
kLCD_BGROrder_Flag
)
{
RGBToLcd16
<
false
false
>
(
src
glyph
imageBuffer
fPreBlend
.
fR
fPreBlend
.
fG
fPreBlend
.
fB
fClearTypeLevel
)
;
}
else
{
RGBToLcd16
<
false
true
>
(
src
glyph
imageBuffer
fPreBlend
.
fR
fPreBlend
.
fG
fPreBlend
.
fB
fClearTypeLevel
)
;
}
}
}
return
true
;
}
bool
SkScalerContext_DW
:
:
drawColorImage
(
const
SkGlyph
&
glyph
SkCanvas
&
canvas
)
{
SkTScopedComPtr
<
IDWriteColorGlyphRunEnumerator
>
colorLayers
;
if
(
!
getColorGlyphRun
(
glyph
&
colorLayers
)
)
{
SkASSERTF
(
false
"
Could
not
get
color
layers
"
)
;
return
false
;
}
SkPaint
paint
;
paint
.
setAntiAlias
(
fRenderingMode
!
=
DWRITE_RENDERING_MODE_ALIASED
)
;
if
(
this
-
>
isSubpixel
(
)
)
{
canvas
.
translate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
canvas
.
concat
(
fSkXform
)
;
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
size_t
paletteEntryCount
=
typeface
-
>
fPaletteEntryCount
;
SkColor
*
palette
=
typeface
-
>
fPalette
.
get
(
)
;
BOOL
hasNextRun
=
FALSE
;
while
(
SUCCEEDED
(
colorLayers
-
>
MoveNext
(
&
hasNextRun
)
)
&
&
hasNextRun
)
{
const
DWRITE_COLOR_GLYPH_RUN
*
colorGlyph
;
HRBM
(
colorLayers
-
>
GetCurrentRun
(
&
colorGlyph
)
"
Could
not
get
current
color
glyph
run
"
)
;
SkColor
color
;
if
(
colorGlyph
-
>
paletteIndex
=
=
0xffff
)
{
color
=
fRec
.
fForegroundColor
;
}
else
if
(
colorGlyph
-
>
paletteIndex
<
paletteEntryCount
)
{
color
=
palette
[
colorGlyph
-
>
paletteIndex
]
;
}
else
{
SK_TRACEHR
(
DWRITE_E_NOCOLOR
"
Invalid
palette
index
.
"
)
;
color
=
SK_ColorBLACK
;
}
paint
.
setColor
(
color
)
;
SkPath
path
;
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
&
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
colorGlyph
-
>
glyphRun
.
fontFace
-
>
GetGlyphRunOutline
(
colorGlyph
-
>
glyphRun
.
fontEmSize
colorGlyph
-
>
glyphRun
.
glyphIndices
colorGlyph
-
>
glyphRun
.
glyphAdvances
colorGlyph
-
>
glyphRun
.
glyphOffsets
colorGlyph
-
>
glyphRun
.
glyphCount
colorGlyph
-
>
glyphRun
.
isSideways
colorGlyph
-
>
glyphRun
.
bidiLevel
%
2
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
canvas
.
drawPath
(
path
paint
)
;
}
return
true
;
}
bool
SkScalerContext_DW
:
:
generateColorImage
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
SkASSERT
(
glyph
.
maskFormat
(
)
=
=
SkMask
:
:
Format
:
:
kARGB32_Format
)
;
SkBitmap
dstBitmap
;
dstBitmap
.
setInfo
(
SkImageInfo
:
:
Make
(
glyph
.
width
(
)
glyph
.
height
(
)
kN32_SkColorType
kPremul_SkAlphaType
)
glyph
.
rowBytes
(
)
)
;
dstBitmap
.
setPixels
(
imageBuffer
)
;
SkCanvas
canvas
(
dstBitmap
)
;
if
constexpr
(
kSkShowTextBlitCoverage
)
{
canvas
.
clear
(
0x33FF0000
)
;
}
else
{
canvas
.
clear
(
SK_ColorTRANSPARENT
)
;
}
canvas
.
translate
(
-
SkIntToScalar
(
glyph
.
left
(
)
)
-
SkIntToScalar
(
glyph
.
top
(
)
)
)
;
return
this
-
>
drawColorImage
(
glyph
canvas
)
;
}
bool
SkScalerContext_DW
:
:
drawSVGImage
(
const
SkGlyph
&
glyph
SkCanvas
&
canvas
)
{
DWriteFontTypeface
*
typeface
=
this
-
>
getDWriteTypeface
(
)
;
IDWriteFontFace4
*
fontFace4
=
typeface
-
>
fDWriteFontFace4
.
get
(
)
;
if
(
!
fontFace4
)
{
return
false
;
}
DWRITE_GLYPH_IMAGE_FORMATS
imageFormats
;
HRBM
(
fontFace4
-
>
GetGlyphImageFormats
(
glyph
.
getGlyphID
(
)
0
UINT32_MAX
&
imageFormats
)
"
Cannot
get
glyph
image
formats
.
"
)
;
if
(
!
(
imageFormats
&
DWRITE_GLYPH_IMAGE_FORMATS_SVG
)
)
{
return
false
;
}
SkGraphics
:
:
OpenTypeSVGDecoderFactory
svgFactory
=
SkGraphics
:
:
GetOpenTypeSVGDecoderFactory
(
)
;
if
(
!
svgFactory
)
{
return
false
;
}
DWRITE_GLYPH_IMAGE_DATA
glyphData
;
void
*
glyphDataContext
;
HRBM
(
fontFace4
-
>
GetGlyphImageData
(
glyph
.
getGlyphID
(
)
fTextSizeRender
DWRITE_GLYPH_IMAGE_FORMATS_SVG
&
glyphData
&
glyphDataContext
)
"
Glyph
SVG
data
could
not
be
acquired
.
"
)
;
auto
svgDecoder
=
svgFactory
(
(
const
uint8_t
*
)
glyphData
.
imageData
glyphData
.
imageDataSize
)
;
fontFace4
-
>
ReleaseGlyphImageData
(
glyphDataContext
)
;
if
(
!
svgDecoder
)
{
return
false
;
}
size_t
paletteEntryCount
=
typeface
-
>
fPaletteEntryCount
;
SkColor
*
palette
=
typeface
-
>
fPalette
.
get
(
)
;
int
upem
=
typeface
-
>
getUnitsPerEm
(
)
;
SkMatrix
matrix
=
fSkXform
;
SkScalar
scale
=
fTextSizeRender
/
upem
;
matrix
.
preScale
(
scale
scale
)
;
matrix
.
preTranslate
(
-
glyphData
.
horizontalLeftOrigin
.
x
-
glyphData
.
horizontalLeftOrigin
.
y
)
;
if
(
this
-
>
isSubpixel
(
)
)
{
matrix
.
postTranslate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
canvas
.
concat
(
matrix
)
;
return
svgDecoder
-
>
render
(
canvas
upem
glyph
.
getGlyphID
(
)
fRec
.
fForegroundColor
SkSpan
(
palette
paletteEntryCount
)
)
;
}
bool
SkScalerContext_DW
:
:
generateSVGImage
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
SkASSERT
(
glyph
.
maskFormat
(
)
=
=
SkMask
:
:
Format
:
:
kARGB32_Format
)
;
SkBitmap
dstBitmap
;
dstBitmap
.
setInfo
(
SkImageInfo
:
:
Make
(
glyph
.
width
(
)
glyph
.
height
(
)
kN32_SkColorType
kPremul_SkAlphaType
)
glyph
.
rowBytes
(
)
)
;
dstBitmap
.
setPixels
(
imageBuffer
)
;
SkCanvas
canvas
(
dstBitmap
)
;
if
constexpr
(
kSkShowTextBlitCoverage
)
{
canvas
.
clear
(
0x33FF0000
)
;
}
else
{
canvas
.
clear
(
SK_ColorTRANSPARENT
)
;
}
canvas
.
translate
(
-
SkIntToScalar
(
glyph
.
left
(
)
)
-
SkIntToScalar
(
glyph
.
top
(
)
)
)
;
return
this
-
>
drawSVGImage
(
glyph
canvas
)
;
}
#
ifdef
USE_PNG
bool
SkScalerContext_DW
:
:
drawPngImage
(
const
SkGlyph
&
glyph
SkCanvas
&
canvas
)
{
IDWriteFontFace4
*
fontFace4
=
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace4
.
get
(
)
;
if
(
!
fontFace4
)
{
return
false
;
}
DWRITE_GLYPH_IMAGE_DATA
glyphData
;
void
*
glyphDataContext
;
HRBM
(
fontFace4
-
>
GetGlyphImageData
(
glyph
.
getGlyphID
(
)
fTextSizeRender
DWRITE_GLYPH_IMAGE_FORMATS_PNG
&
glyphData
&
glyphDataContext
)
"
Glyph
image
data
could
not
be
acquired
.
"
)
;
Context
*
context
=
new
Context
(
fontFace4
glyphDataContext
)
;
sk_sp
<
SkData
>
data
=
SkData
:
:
MakeWithProc
(
glyphData
.
imageData
glyphData
.
imageDataSize
&
ReleaseProc
context
)
;
sk_sp
<
SkImage
>
image
=
SkImages
:
:
DeferredFromEncodedData
(
std
:
:
move
(
data
)
)
;
if
(
!
image
)
{
return
false
;
}
if
(
this
-
>
isSubpixel
(
)
)
{
canvas
.
translate
(
SkFixedToScalar
(
glyph
.
getSubXFixed
(
)
)
SkFixedToScalar
(
glyph
.
getSubYFixed
(
)
)
)
;
}
canvas
.
concat
(
fSkXform
)
;
SkScalar
ratio
=
fTextSizeRender
/
glyphData
.
pixelsPerEm
;
canvas
.
scale
(
ratio
ratio
)
;
canvas
.
translate
(
-
glyphData
.
horizontalLeftOrigin
.
x
-
glyphData
.
horizontalLeftOrigin
.
y
)
;
canvas
.
drawImage
(
image
0
0
)
;
return
true
;
}
bool
SkScalerContext_DW
:
:
generatePngImage
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
SkASSERT
(
glyph
.
maskFormat
(
)
=
=
SkMask
:
:
Format
:
:
kARGB32_Format
)
;
SkBitmap
dstBitmap
;
dstBitmap
.
setInfo
(
SkImageInfo
:
:
Make
(
glyph
.
width
(
)
glyph
.
height
(
)
kN32_SkColorType
kPremul_SkAlphaType
)
glyph
.
rowBytes
(
)
)
;
dstBitmap
.
setPixels
(
imageBuffer
)
;
SkCanvas
canvas
(
dstBitmap
)
;
canvas
.
clear
(
SK_ColorTRANSPARENT
)
;
canvas
.
translate
(
-
glyph
.
left
(
)
-
glyph
.
top
(
)
)
;
return
this
-
>
drawPngImage
(
glyph
canvas
)
;
}
#
endif
void
SkScalerContext_DW
:
:
generateImage
(
const
SkGlyph
&
glyph
void
*
imageBuffer
)
{
ScalerContextBits
:
:
value_type
format
=
glyph
.
extraBits
(
)
;
if
(
format
=
=
ScalerContextBits
:
:
DW
|
|
format
=
=
ScalerContextBits
:
:
DW_1
)
{
this
-
>
generateDWImage
(
glyph
imageBuffer
)
;
}
else
if
(
format
=
=
ScalerContextBits
:
:
COLRv1
)
{
this
-
>
generateColorV1Image
(
glyph
imageBuffer
)
;
}
else
if
(
format
=
=
ScalerContextBits
:
:
COLR
)
{
this
-
>
generateColorImage
(
glyph
imageBuffer
)
;
#
ifdef
USE_SVG
}
else
if
(
format
=
=
ScalerContextBits
:
:
SVG
)
{
this
-
>
generateSVGImage
(
glyph
imageBuffer
)
;
#
endif
#
ifdef
USE_PNG
}
else
if
(
format
=
=
ScalerContextBits
:
:
PNG
)
{
this
-
>
generatePngImage
(
glyph
imageBuffer
)
;
#
endif
}
else
if
(
format
=
=
ScalerContextBits
:
:
PATH
)
{
const
SkPath
*
devPath
=
glyph
.
path
(
)
;
SkASSERT_RELEASE
(
devPath
)
;
SkMaskBuilder
mask
(
static_cast
<
uint8_t
*
>
(
imageBuffer
)
glyph
.
iRect
(
)
glyph
.
rowBytes
(
)
glyph
.
maskFormat
(
)
)
;
SkASSERT
(
SkMask
:
:
kARGB32_Format
!
=
mask
.
fFormat
)
;
const
bool
doBGR
=
SkToBool
(
fRec
.
fFlags
&
SkScalerContext
:
:
kLCD_BGROrder_Flag
)
;
const
bool
doVert
=
SkToBool
(
fRec
.
fFlags
&
SkScalerContext
:
:
kLCD_Vertical_Flag
)
;
const
bool
a8LCD
=
SkToBool
(
fRec
.
fFlags
&
SkScalerContext
:
:
kGenA8FromLCD_Flag
)
;
const
bool
hairline
=
glyph
.
pathIsHairline
(
)
;
GenerateImageFromPath
(
mask
*
devPath
fPreBlend
doBGR
doVert
a8LCD
hairline
)
;
}
else
{
SK_ABORT
(
"
Bad
format
"
)
;
}
}
bool
SkScalerContext_DW
:
:
generatePath
(
const
SkGlyph
&
glyph
SkPath
*
path
)
{
SkASSERT
(
path
)
;
path
-
>
reset
(
)
;
SkGlyphID
glyphID
=
glyph
.
getGlyphID
(
)
;
if
(
fGlyphCount
<
=
glyphID
)
{
return
false
;
}
SkTScopedComPtr
<
IDWriteGeometrySink
>
geometryToPath
;
HRBM
(
SkDWriteGeometrySink
:
:
Create
(
path
&
geometryToPath
)
"
Could
not
create
geometry
to
path
converter
.
"
)
;
UINT16
glyphId
=
SkTo
<
UINT16
>
(
glyphID
)
;
{
Exclusive
l
(
maybe_dw_mutex
(
*
this
-
>
getDWriteTypeface
(
)
)
)
;
HRBM
(
this
-
>
getDWriteTypeface
(
)
-
>
fDWriteFontFace
-
>
GetGlyphRunOutline
(
SkScalarToFloat
(
fTextSizeRender
)
&
glyphId
nullptr
nullptr
1
FALSE
FALSE
geometryToPath
.
get
(
)
)
"
Could
not
create
glyph
outline
.
"
)
;
}
path
-
>
transform
(
fSkXform
)
;
return
true
;
}
sk_sp
<
SkDrawable
>
SkScalerContext_DW
:
:
generateDrawable
(
const
SkGlyph
&
glyph
)
{
struct
GlyphDrawable
:
public
SkDrawable
{
SkScalerContext_DW
*
fSelf
;
SkGlyph
fGlyph
;
GlyphDrawable
(
SkScalerContext_DW
*
self
const
SkGlyph
&
glyph
)
:
fSelf
(
self
)
fGlyph
(
glyph
)
{
}
SkRect
onGetBounds
(
)
override
{
return
fGlyph
.
rect
(
)
;
}
size_t
onApproximateBytesUsed
(
)
override
{
return
sizeof
(
GlyphDrawable
)
;
}
void
maybeShowTextBlitCoverage
(
SkCanvas
*
canvas
)
{
if
constexpr
(
kSkShowTextBlitCoverage
)
{
SkPaint
paint
;
paint
.
setColor
(
0x3300FF00
)
;
paint
.
setStyle
(
SkPaint
:
:
kFill_Style
)
;
canvas
-
>
drawRect
(
this
-
>
onGetBounds
(
)
paint
)
;
}
}
}
;
struct
COLRv1GlyphDrawable
:
public
GlyphDrawable
{
using
GlyphDrawable
:
:
GlyphDrawable
;
void
onDraw
(
SkCanvas
*
canvas
)
override
{
this
-
>
maybeShowTextBlitCoverage
(
canvas
)
;
fSelf
-
>
drawColorV1Image
(
fGlyph
*
canvas
)
;
}
}
;
struct
COLRGlyphDrawable
:
public
GlyphDrawable
{
using
GlyphDrawable
:
:
GlyphDrawable
;
void
onDraw
(
SkCanvas
*
canvas
)
override
{
this
-
>
maybeShowTextBlitCoverage
(
canvas
)
;
fSelf
-
>
drawColorImage
(
fGlyph
*
canvas
)
;
}
}
;
struct
SVGGlyphDrawable
:
public
GlyphDrawable
{
using
GlyphDrawable
:
:
GlyphDrawable
;
void
onDraw
(
SkCanvas
*
canvas
)
override
{
this
-
>
maybeShowTextBlitCoverage
(
canvas
)
;
fSelf
-
>
drawSVGImage
(
fGlyph
*
canvas
)
;
}
}
;
ScalerContextBits
:
:
value_type
format
=
glyph
.
extraBits
(
)
;
if
(
format
=
=
ScalerContextBits
:
:
COLRv1
)
{
return
sk_sp
<
SkDrawable
>
(
new
COLRv1GlyphDrawable
(
this
glyph
)
)
;
}
if
(
format
=
=
ScalerContextBits
:
:
COLR
)
{
return
sk_sp
<
SkDrawable
>
(
new
COLRGlyphDrawable
(
this
glyph
)
)
;
}
if
(
format
=
=
ScalerContextBits
:
:
SVG
)
{
return
sk_sp
<
SkDrawable
>
(
new
SVGGlyphDrawable
(
this
glyph
)
)
;
}
return
nullptr
;
}
#
endif
