#
include
"
SkFixed
.
h
"
#
include
"
SkFontMgr
.
h
"
#
include
"
SkFontMgr_android_parser
.
h
"
#
include
"
SkMalloc
.
h
"
#
include
"
SkOSFile
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTSearch
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTLogic
.
h
"
#
include
<
expat
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
define
LMP_SYSTEM_FONTS_FILE
"
/
system
/
etc
/
fonts
.
xml
"
#
define
OLD_SYSTEM_FONTS_FILE
"
/
system
/
etc
/
system_fonts
.
xml
"
#
define
FALLBACK_FONTS_FILE
"
/
system
/
etc
/
fallback_fonts
.
xml
"
#
define
VENDOR_FONTS_FILE
"
/
vendor
/
etc
/
fallback_fonts
.
xml
"
#
define
LOCALE_FALLBACK_FONTS_SYSTEM_DIR
"
/
system
/
etc
"
#
define
LOCALE_FALLBACK_FONTS_VENDOR_DIR
"
/
vendor
/
etc
"
#
define
LOCALE_FALLBACK_FONTS_PREFIX
"
fallback_fonts
-
"
#
define
LOCALE_FALLBACK_FONTS_SUFFIX
"
.
xml
"
#
ifndef
SK_FONT_FILE_PREFIX
#
define
SK_FONT_FILE_PREFIX
"
/
fonts
/
"
#
endif
struct
FamilyData
;
struct
TagHandler
{
void
(
*
start
)
(
FamilyData
*
data
const
char
*
tag
const
char
*
*
attributes
)
;
void
(
*
end
)
(
FamilyData
*
data
const
char
*
tag
)
;
const
TagHandler
*
(
*
tag
)
(
FamilyData
*
data
const
char
*
tag
const
char
*
*
attributes
)
;
XML_CharacterDataHandler
chars
;
}
;
struct
FamilyData
{
FamilyData
(
XML_Parser
parser
SkTDArray
<
FontFamily
*
>
&
families
const
SkString
&
basePath
bool
isFallback
const
char
*
filename
const
TagHandler
*
topLevelHandler
)
:
fParser
(
parser
)
fFamilies
(
families
)
fCurrentFamily
(
nullptr
)
fCurrentFontInfo
(
nullptr
)
fVersion
(
0
)
fBasePath
(
basePath
)
fIsFallback
(
isFallback
)
fFilename
(
filename
)
fDepth
(
1
)
fSkip
(
0
)
fHandler
(
&
topLevelHandler
1
)
{
}
XML_Parser
fParser
;
SkTDArray
<
FontFamily
*
>
&
fFamilies
;
std
:
:
unique_ptr
<
FontFamily
>
fCurrentFamily
;
FontFileInfo
*
fCurrentFontInfo
;
int
fVersion
;
const
SkString
&
fBasePath
;
const
bool
fIsFallback
;
const
char
*
fFilename
;
int
fDepth
;
int
fSkip
;
SkTDArray
<
const
TagHandler
*
>
fHandler
;
}
;
static
bool
memeq
(
const
char
*
s1
const
char
*
s2
size_t
n1
size_t
n2
)
{
return
n1
=
=
n2
&
&
0
=
=
memcmp
(
s1
s2
n1
)
;
}
#
define
MEMEQ
(
c
s
n
)
memeq
(
c
s
sizeof
(
c
)
-
1
n
)
#
define
ATTS_NON_NULL
(
a
i
)
(
a
[
i
]
!
=
nullptr
&
&
a
[
i
+
1
]
!
=
nullptr
)
#
define
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
[
SkFontMgr
Android
Parser
]
"
#
define
SK_FONTCONFIGPARSER_WARNING
(
message
.
.
.
)
SkDebugf
(
\
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
%
s
:
%
d
:
%
d
:
warning
:
"
message
"
\
n
"
\
self
-
>
fFilename
\
XML_GetCurrentLineNumber
(
self
-
>
fParser
)
\
XML_GetCurrentColumnNumber
(
self
-
>
fParser
)
\
#
#
__VA_ARGS__
)
;
static
bool
is_whitespace
(
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
|
|
c
=
=
'
\
t
'
;
}
static
void
trim_string
(
SkString
*
s
)
{
char
*
str
=
s
-
>
writable_str
(
)
;
const
char
*
start
=
str
;
const
char
*
end
=
start
+
s
-
>
size
(
)
;
while
(
is_whitespace
(
*
start
)
)
{
+
+
start
;
}
if
(
start
!
=
end
)
{
-
-
end
;
while
(
is_whitespace
(
*
end
)
)
{
-
-
end
;
}
+
+
end
;
}
size_t
len
=
end
-
start
;
memmove
(
str
start
len
)
;
s
-
>
resize
(
len
)
;
}
namespace
lmpParser
{
static
const
TagHandler
axisHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
FontFileInfo
&
file
=
*
self
-
>
fCurrentFontInfo
;
SkFourByteTag
axisTag
=
SkSetFourByteTag
(
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
)
;
SkFixed
axisStyleValue
=
0
;
bool
axisTagIsValid
=
false
;
bool
axisStyleValueIsValid
=
false
;
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
const
char
*
value
=
attributes
[
i
+
1
]
;
size_t
nameLen
=
strlen
(
name
)
;
if
(
MEMEQ
(
"
tag
"
name
nameLen
)
)
{
size_t
valueLen
=
strlen
(
value
)
;
if
(
valueLen
=
=
4
)
{
axisTag
=
SkSetFourByteTag
(
value
[
0
]
value
[
1
]
value
[
2
]
value
[
3
]
)
;
axisTagIsValid
=
true
;
for
(
int
j
=
0
;
j
<
file
.
fVariationDesignPosition
.
count
(
)
-
1
;
+
+
j
)
{
if
(
file
.
fVariationDesignPosition
[
j
]
.
axis
=
=
axisTag
)
{
axisTagIsValid
=
false
;
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
c
%
c
%
c
%
c
'
axis
specified
more
than
once
"
(
axisTag
>
>
24
)
&
0xFF
(
axisTag
>
>
16
)
&
0xFF
(
axisTag
>
>
8
)
&
0xFF
(
axisTag
)
&
0xFF
)
;
}
}
}
else
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
axis
tag
"
value
)
;
}
}
else
if
(
MEMEQ
(
"
stylevalue
"
name
nameLen
)
)
{
if
(
parse_fixed
<
16
>
(
value
&
axisStyleValue
)
)
{
axisStyleValueIsValid
=
true
;
}
else
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
axis
stylevalue
"
value
)
;
}
}
}
if
(
axisTagIsValid
&
&
axisStyleValueIsValid
)
{
auto
&
coordinate
=
file
.
fVariationDesignPosition
.
push_back
(
)
;
coordinate
.
axis
=
axisTag
;
coordinate
.
value
=
SkFixedToScalar
(
axisStyleValue
)
;
}
}
nullptr
nullptr
nullptr
}
;
static
const
TagHandler
fontHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
FontFileInfo
&
file
=
self
-
>
fCurrentFamily
-
>
fFonts
.
push_back
(
)
;
self
-
>
fCurrentFontInfo
=
&
file
;
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
const
char
*
value
=
attributes
[
i
+
1
]
;
size_t
nameLen
=
strlen
(
name
)
;
if
(
MEMEQ
(
"
weight
"
name
nameLen
)
)
{
if
(
!
parse_non_negative_integer
(
value
&
file
.
fWeight
)
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
weight
"
value
)
;
}
}
else
if
(
MEMEQ
(
"
style
"
name
nameLen
)
)
{
size_t
valueLen
=
strlen
(
value
)
;
if
(
MEMEQ
(
"
normal
"
value
valueLen
)
)
{
file
.
fStyle
=
FontFileInfo
:
:
Style
:
:
kNormal
;
}
else
if
(
MEMEQ
(
"
italic
"
value
valueLen
)
)
{
file
.
fStyle
=
FontFileInfo
:
:
Style
:
:
kItalic
;
}
}
else
if
(
MEMEQ
(
"
index
"
name
nameLen
)
)
{
if
(
!
parse_non_negative_integer
(
value
&
file
.
fIndex
)
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
index
"
value
)
;
}
}
}
}
[
]
(
FamilyData
*
self
const
char
*
tag
)
{
trim_string
(
&
self
-
>
fCurrentFontInfo
-
>
fFileName
)
;
}
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
axis
"
tag
len
)
)
{
return
&
axisHandler
;
}
return
nullptr
;
}
[
]
(
void
*
data
const
char
*
s
int
len
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
self
-
>
fCurrentFontInfo
-
>
fFileName
.
append
(
s
len
)
;
}
}
;
static
const
TagHandler
familyHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
FontFamily
*
family
=
new
FontFamily
(
self
-
>
fBasePath
true
)
;
self
-
>
fCurrentFamily
.
reset
(
family
)
;
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
const
char
*
value
=
attributes
[
i
+
1
]
;
size_t
nameLen
=
strlen
(
name
)
;
size_t
valueLen
=
strlen
(
value
)
;
if
(
MEMEQ
(
"
name
"
name
nameLen
)
)
{
SkAutoAsciiToLC
tolc
(
value
)
;
family
-
>
fNames
.
push_back
(
)
.
set
(
tolc
.
lc
(
)
)
;
family
-
>
fIsFallbackFont
=
false
;
}
else
if
(
MEMEQ
(
"
lang
"
name
nameLen
)
)
{
family
-
>
fLanguage
=
SkLanguage
(
value
valueLen
)
;
}
else
if
(
MEMEQ
(
"
variant
"
name
nameLen
)
)
{
if
(
MEMEQ
(
"
elegant
"
value
valueLen
)
)
{
family
-
>
fVariant
=
kElegant_FontVariant
;
}
else
if
(
MEMEQ
(
"
compact
"
value
valueLen
)
)
{
family
-
>
fVariant
=
kCompact_FontVariant
;
}
}
}
}
[
]
(
FamilyData
*
self
const
char
*
tag
)
{
*
self
-
>
fFamilies
.
append
(
)
=
self
-
>
fCurrentFamily
.
release
(
)
;
}
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
font
"
tag
len
)
)
{
return
&
fontHandler
;
}
return
nullptr
;
}
nullptr
}
;
static
FontFamily
*
find_family
(
FamilyData
*
self
const
SkString
&
familyName
)
{
for
(
int
i
=
0
;
i
<
self
-
>
fFamilies
.
count
(
)
;
i
+
+
)
{
FontFamily
*
candidate
=
self
-
>
fFamilies
[
i
]
;
for
(
int
j
=
0
;
j
<
candidate
-
>
fNames
.
count
(
)
;
j
+
+
)
{
if
(
candidate
-
>
fNames
[
j
]
=
=
familyName
)
{
return
candidate
;
}
}
}
return
nullptr
;
}
static
const
TagHandler
aliasHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
SkString
aliasName
;
SkString
to
;
int
weight
=
0
;
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
const
char
*
value
=
attributes
[
i
+
1
]
;
size_t
nameLen
=
strlen
(
name
)
;
if
(
MEMEQ
(
"
name
"
name
nameLen
)
)
{
SkAutoAsciiToLC
tolc
(
value
)
;
aliasName
.
set
(
tolc
.
lc
(
)
)
;
}
else
if
(
MEMEQ
(
"
to
"
name
nameLen
)
)
{
to
.
set
(
value
)
;
}
else
if
(
MEMEQ
(
"
weight
"
name
nameLen
)
)
{
if
(
!
parse_non_negative_integer
(
value
&
weight
)
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
weight
"
value
)
;
}
}
}
FontFamily
*
targetFamily
=
find_family
(
self
to
)
;
if
(
!
targetFamily
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
alias
target
not
found
"
to
.
c_str
(
)
)
;
return
;
}
if
(
weight
)
{
FontFamily
*
family
=
new
FontFamily
(
targetFamily
-
>
fBasePath
self
-
>
fIsFallback
)
;
family
-
>
fNames
.
push_back
(
)
.
set
(
aliasName
)
;
for
(
int
i
=
0
;
i
<
targetFamily
-
>
fFonts
.
count
(
)
;
i
+
+
)
{
if
(
targetFamily
-
>
fFonts
[
i
]
.
fWeight
=
=
weight
)
{
family
-
>
fFonts
.
push_back
(
targetFamily
-
>
fFonts
[
i
]
)
;
}
}
*
self
-
>
fFamilies
.
append
(
)
=
family
;
}
else
{
targetFamily
-
>
fNames
.
push_back
(
)
.
set
(
aliasName
)
;
}
}
nullptr
nullptr
nullptr
}
;
static
const
TagHandler
familySetHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
}
nullptr
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
family
"
tag
len
)
)
{
return
&
familyHandler
;
}
else
if
(
MEMEQ
(
"
alias
"
tag
len
)
)
{
return
&
aliasHandler
;
}
return
nullptr
;
}
nullptr
}
;
}
namespace
jbParser
{
static
const
TagHandler
fileHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
FontFamily
&
currentFamily
=
*
self
-
>
fCurrentFamily
.
get
(
)
;
FontFileInfo
&
newFileInfo
=
currentFamily
.
fFonts
.
push_back
(
)
;
if
(
attributes
)
{
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
const
char
*
value
=
attributes
[
i
+
1
]
;
size_t
nameLen
=
strlen
(
name
)
;
size_t
valueLen
=
strlen
(
value
)
;
if
(
MEMEQ
(
"
variant
"
name
nameLen
)
)
{
const
FontVariant
prevVariant
=
currentFamily
.
fVariant
;
if
(
MEMEQ
(
"
elegant
"
value
valueLen
)
)
{
currentFamily
.
fVariant
=
kElegant_FontVariant
;
}
else
if
(
MEMEQ
(
"
compact
"
value
valueLen
)
)
{
currentFamily
.
fVariant
=
kCompact_FontVariant
;
}
if
(
currentFamily
.
fFonts
.
count
(
)
>
1
&
&
currentFamily
.
fVariant
!
=
prevVariant
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
unexpected
variant
found
\
n
"
"
Note
:
Every
font
file
within
a
family
must
have
identical
variants
.
"
value
)
;
}
}
else
if
(
MEMEQ
(
"
lang
"
name
nameLen
)
)
{
SkLanguage
prevLang
=
currentFamily
.
fLanguage
;
currentFamily
.
fLanguage
=
SkLanguage
(
value
valueLen
)
;
if
(
currentFamily
.
fFonts
.
count
(
)
>
1
&
&
currentFamily
.
fLanguage
!
=
prevLang
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
unexpected
language
found
\
n
"
"
Note
:
Every
font
file
within
a
family
must
have
identical
languages
.
"
value
)
;
}
}
else
if
(
MEMEQ
(
"
index
"
name
nameLen
)
)
{
if
(
!
parse_non_negative_integer
(
value
&
newFileInfo
.
fIndex
)
)
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
is
an
invalid
index
"
value
)
;
}
}
}
}
self
-
>
fCurrentFontInfo
=
&
newFileInfo
;
}
nullptr
nullptr
[
]
(
void
*
data
const
char
*
s
int
len
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
self
-
>
fCurrentFontInfo
-
>
fFileName
.
append
(
s
len
)
;
}
}
;
static
const
TagHandler
fileSetHandler
=
{
nullptr
nullptr
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
file
"
tag
len
)
)
{
return
&
fileHandler
;
}
return
nullptr
;
}
nullptr
}
;
static
const
TagHandler
nameHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
self
-
>
fCurrentFamily
-
>
fNames
.
push_back
(
)
;
}
nullptr
nullptr
[
]
(
void
*
data
const
char
*
s
int
len
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
SkAutoAsciiToLC
tolc
(
s
len
)
;
self
-
>
fCurrentFamily
-
>
fNames
.
back
(
)
.
append
(
tolc
.
lc
(
)
len
)
;
}
}
;
static
const
TagHandler
nameSetHandler
=
{
nullptr
nullptr
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
name
"
tag
len
)
)
{
return
&
nameHandler
;
}
return
nullptr
;
}
nullptr
}
;
static
const
TagHandler
familyHandler
=
{
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
{
self
-
>
fCurrentFamily
.
reset
(
new
FontFamily
(
self
-
>
fBasePath
self
-
>
fIsFallback
)
)
;
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
value
=
attributes
[
i
+
1
]
;
parse_non_negative_integer
(
value
&
self
-
>
fCurrentFamily
-
>
fOrder
)
;
}
}
[
]
(
FamilyData
*
self
const
char
*
tag
)
{
*
self
-
>
fFamilies
.
append
(
)
=
self
-
>
fCurrentFamily
.
release
(
)
;
}
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
nameset
"
tag
len
)
)
{
return
&
nameSetHandler
;
}
else
if
(
MEMEQ
(
"
fileset
"
tag
len
)
)
{
return
&
fileSetHandler
;
}
return
nullptr
;
}
nullptr
}
;
static
const
TagHandler
familySetHandler
=
{
nullptr
nullptr
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
family
"
tag
len
)
)
{
return
&
familyHandler
;
}
return
nullptr
;
}
nullptr
}
;
}
static
const
TagHandler
topLevelHandler
=
{
nullptr
nullptr
[
]
(
FamilyData
*
self
const
char
*
tag
const
char
*
*
attributes
)
-
>
const
TagHandler
*
{
size_t
len
=
strlen
(
tag
)
;
if
(
MEMEQ
(
"
familyset
"
tag
len
)
)
{
for
(
size_t
i
=
0
;
ATTS_NON_NULL
(
attributes
i
)
;
i
+
=
2
)
{
const
char
*
name
=
attributes
[
i
]
;
size_t
nameLen
=
strlen
(
name
)
;
if
(
MEMEQ
(
"
version
"
name
nameLen
)
)
{
const
char
*
value
=
attributes
[
i
+
1
]
;
if
(
parse_non_negative_integer
(
value
&
self
-
>
fVersion
)
)
{
if
(
self
-
>
fVersion
>
=
21
)
{
return
&
lmpParser
:
:
familySetHandler
;
}
}
}
}
return
&
jbParser
:
:
familySetHandler
;
}
return
nullptr
;
}
nullptr
}
;
static
void
XMLCALL
start_element_handler
(
void
*
data
const
char
*
tag
const
char
*
*
attributes
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
if
(
!
self
-
>
fSkip
)
{
const
TagHandler
*
parent
=
self
-
>
fHandler
.
top
(
)
;
const
TagHandler
*
child
=
parent
-
>
tag
?
parent
-
>
tag
(
self
tag
attributes
)
:
nullptr
;
if
(
child
)
{
if
(
child
-
>
start
)
{
child
-
>
start
(
self
tag
attributes
)
;
}
self
-
>
fHandler
.
push
(
child
)
;
XML_SetCharacterDataHandler
(
self
-
>
fParser
child
-
>
chars
)
;
}
else
{
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
tag
not
recognized
skipping
"
tag
)
;
XML_SetCharacterDataHandler
(
self
-
>
fParser
nullptr
)
;
self
-
>
fSkip
=
self
-
>
fDepth
;
}
}
+
+
self
-
>
fDepth
;
}
static
void
XMLCALL
end_element_handler
(
void
*
data
const
char
*
tag
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
-
-
self
-
>
fDepth
;
if
(
!
self
-
>
fSkip
)
{
const
TagHandler
*
child
=
self
-
>
fHandler
.
top
(
)
;
if
(
child
-
>
end
)
{
child
-
>
end
(
self
tag
)
;
}
self
-
>
fHandler
.
pop
(
)
;
const
TagHandler
*
parent
=
self
-
>
fHandler
.
top
(
)
;
XML_SetCharacterDataHandler
(
self
-
>
fParser
parent
-
>
chars
)
;
}
if
(
self
-
>
fSkip
=
=
self
-
>
fDepth
)
{
self
-
>
fSkip
=
0
;
const
TagHandler
*
parent
=
self
-
>
fHandler
.
top
(
)
;
XML_SetCharacterDataHandler
(
self
-
>
fParser
parent
-
>
chars
)
;
}
}
static
void
XMLCALL
xml_entity_decl_handler
(
void
*
data
const
XML_Char
*
entityName
int
is_parameter_entity
const
XML_Char
*
value
int
value_length
const
XML_Char
*
base
const
XML_Char
*
systemId
const
XML_Char
*
publicId
const
XML_Char
*
notationName
)
{
FamilyData
*
self
=
static_cast
<
FamilyData
*
>
(
data
)
;
SK_FONTCONFIGPARSER_WARNING
(
"
'
%
s
'
entity
declaration
found
stopping
processing
"
entityName
)
;
XML_StopParser
(
self
-
>
fParser
XML_FALSE
)
;
}
static
const
XML_Memory_Handling_Suite
sk_XML_alloc
=
{
sk_malloc_throw
sk_realloc_throw
sk_free
}
;
static
int
parse_config_file
(
const
char
*
filename
SkTDArray
<
FontFamily
*
>
&
families
const
SkString
&
basePath
bool
isFallback
)
{
SkFILEStream
file
(
filename
)
;
if
(
!
file
.
isValid
(
)
)
{
SkDebugf
(
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
'
%
s
'
could
not
be
opened
\
n
"
filename
)
;
return
-
1
;
}
SkAutoTCallVProc
<
skstd
:
:
remove_pointer_t
<
XML_Parser
>
XML_ParserFree
>
parser
(
XML_ParserCreate_MM
(
nullptr
&
sk_XML_alloc
nullptr
)
)
;
if
(
!
parser
)
{
SkDebugf
(
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
could
not
create
XML
parser
\
n
"
)
;
return
-
1
;
}
FamilyData
self
(
parser
families
basePath
isFallback
filename
&
topLevelHandler
)
;
XML_SetUserData
(
parser
&
self
)
;
XML_SetEntityDeclHandler
(
parser
xml_entity_decl_handler
)
;
XML_SetElementHandler
(
parser
start_element_handler
end_element_handler
)
;
static
const
int
bufferSize
=
512
SkDEBUGCODE
(
-
507
)
;
bool
done
=
false
;
while
(
!
done
)
{
void
*
buffer
=
XML_GetBuffer
(
parser
bufferSize
)
;
if
(
!
buffer
)
{
SkDebugf
(
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
could
not
buffer
enough
to
continue
\
n
"
)
;
return
-
1
;
}
size_t
len
=
file
.
read
(
buffer
bufferSize
)
;
done
=
file
.
isAtEnd
(
)
;
XML_Status
status
=
XML_ParseBuffer
(
parser
len
done
)
;
if
(
XML_STATUS_ERROR
=
=
status
)
{
XML_Error
error
=
XML_GetErrorCode
(
parser
)
;
int
line
=
XML_GetCurrentLineNumber
(
parser
)
;
int
column
=
XML_GetCurrentColumnNumber
(
parser
)
;
const
XML_LChar
*
errorString
=
XML_ErrorString
(
error
)
;
SkDebugf
(
SK_FONTMGR_ANDROID_PARSER_PREFIX
"
%
s
:
%
d
:
%
d
error
%
d
:
%
s
.
\
n
"
filename
line
column
error
errorString
)
;
return
-
1
;
}
}
return
self
.
fVersion
;
}
static
int
append_system_font_families
(
SkTDArray
<
FontFamily
*
>
&
fontFamilies
const
SkString
&
basePath
)
{
int
initialCount
=
fontFamilies
.
count
(
)
;
int
version
=
parse_config_file
(
LMP_SYSTEM_FONTS_FILE
fontFamilies
basePath
false
)
;
if
(
version
<
0
|
|
fontFamilies
.
count
(
)
=
=
initialCount
)
{
version
=
parse_config_file
(
OLD_SYSTEM_FONTS_FILE
fontFamilies
basePath
false
)
;
}
return
version
;
}
static
void
append_fallback_font_families_for_locale
(
SkTDArray
<
FontFamily
*
>
&
fallbackFonts
const
char
*
dir
const
SkString
&
basePath
)
{
SkOSFile
:
:
Iter
iter
(
dir
nullptr
)
;
SkString
fileName
;
while
(
iter
.
next
(
&
fileName
false
)
)
{
static
const
size_t
fixedLen
=
sizeof
(
LOCALE_FALLBACK_FONTS_PREFIX
)
-
1
+
sizeof
(
LOCALE_FALLBACK_FONTS_SUFFIX
)
-
1
;
static
const
size_t
minSize
=
fixedLen
+
2
;
if
(
fileName
.
size
(
)
<
minSize
|
|
!
fileName
.
startsWith
(
LOCALE_FALLBACK_FONTS_PREFIX
)
|
|
!
fileName
.
endsWith
(
LOCALE_FALLBACK_FONTS_SUFFIX
)
)
{
continue
;
}
SkString
locale
(
fileName
.
c_str
(
)
+
sizeof
(
LOCALE_FALLBACK_FONTS_PREFIX
)
-
1
fileName
.
size
(
)
-
fixedLen
)
;
SkString
absoluteFilename
;
absoluteFilename
.
printf
(
"
%
s
/
%
s
"
dir
fileName
.
c_str
(
)
)
;
SkTDArray
<
FontFamily
*
>
langSpecificFonts
;
parse_config_file
(
absoluteFilename
.
c_str
(
)
langSpecificFonts
basePath
true
)
;
for
(
int
i
=
0
;
i
<
langSpecificFonts
.
count
(
)
;
+
+
i
)
{
FontFamily
*
family
=
langSpecificFonts
[
i
]
;
family
-
>
fLanguage
=
SkLanguage
(
locale
)
;
*
fallbackFonts
.
append
(
)
=
family
;
}
}
}
static
void
append_system_fallback_font_families
(
SkTDArray
<
FontFamily
*
>
&
fallbackFonts
const
SkString
&
basePath
)
{
parse_config_file
(
FALLBACK_FONTS_FILE
fallbackFonts
basePath
true
)
;
append_fallback_font_families_for_locale
(
fallbackFonts
LOCALE_FALLBACK_FONTS_SYSTEM_DIR
basePath
)
;
}
static
void
mixin_vendor_fallback_font_families
(
SkTDArray
<
FontFamily
*
>
&
fallbackFonts
const
SkString
&
basePath
)
{
SkTDArray
<
FontFamily
*
>
vendorFonts
;
parse_config_file
(
VENDOR_FONTS_FILE
vendorFonts
basePath
true
)
;
append_fallback_font_families_for_locale
(
vendorFonts
LOCALE_FALLBACK_FONTS_VENDOR_DIR
basePath
)
;
int
currentOrder
=
-
1
;
for
(
int
i
=
0
;
i
<
vendorFonts
.
count
(
)
;
+
+
i
)
{
FontFamily
*
family
=
vendorFonts
[
i
]
;
int
order
=
family
-
>
fOrder
;
if
(
order
<
0
)
{
if
(
currentOrder
<
0
)
{
*
fallbackFonts
.
append
(
)
=
family
;
}
else
{
*
fallbackFonts
.
insert
(
currentOrder
+
+
)
=
family
;
}
}
else
{
*
fallbackFonts
.
insert
(
order
)
=
family
;
currentOrder
=
order
+
1
;
}
}
}
void
SkFontMgr_Android_Parser
:
:
GetSystemFontFamilies
(
SkTDArray
<
FontFamily
*
>
&
fontFamilies
)
{
SkString
basePath
(
getenv
(
"
ANDROID_ROOT
"
)
)
;
basePath
.
append
(
SK_FONT_FILE_PREFIX
sizeof
(
SK_FONT_FILE_PREFIX
)
-
1
)
;
if
(
append_system_font_families
(
fontFamilies
basePath
)
>
=
21
)
{
return
;
}
SkTDArray
<
FontFamily
*
>
fallbackFonts
;
append_system_fallback_font_families
(
fallbackFonts
basePath
)
;
mixin_vendor_fallback_font_families
(
fallbackFonts
basePath
)
;
fontFamilies
.
append
(
fallbackFonts
.
count
(
)
fallbackFonts
.
begin
(
)
)
;
}
void
SkFontMgr_Android_Parser
:
:
GetCustomFontFamilies
(
SkTDArray
<
FontFamily
*
>
&
fontFamilies
const
SkString
&
basePath
const
char
*
fontsXml
const
char
*
fallbackFontsXml
const
char
*
langFallbackFontsDir
)
{
if
(
fontsXml
)
{
parse_config_file
(
fontsXml
fontFamilies
basePath
false
)
;
}
if
(
fallbackFontsXml
)
{
parse_config_file
(
fallbackFontsXml
fontFamilies
basePath
true
)
;
}
if
(
langFallbackFontsDir
)
{
append_fallback_font_families_for_locale
(
fontFamilies
langFallbackFontsDir
basePath
)
;
}
}
SkLanguage
SkLanguage
:
:
getParent
(
)
const
{
SkASSERT
(
!
fTag
.
isEmpty
(
)
)
;
const
char
*
tag
=
fTag
.
c_str
(
)
;
const
char
*
parentTagEnd
=
strrchr
(
tag
'
-
'
)
;
if
(
parentTagEnd
=
=
nullptr
)
{
return
SkLanguage
(
)
;
}
size_t
parentTagLen
=
parentTagEnd
-
tag
;
return
SkLanguage
(
tag
parentTagLen
)
;
}
