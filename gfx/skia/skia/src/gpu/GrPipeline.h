#
ifndef
GrPipeline_DEFINED
#
define
GrPipeline_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
src
/
gpu
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
GrProcessorSet
.
h
"
#
include
"
src
/
gpu
/
GrProgramDesc
.
h
"
#
include
"
src
/
gpu
/
GrScissorState
.
h
"
#
include
"
src
/
gpu
/
GrUserStencilSettings
.
h
"
#
include
"
src
/
gpu
/
GrWindowRectsState
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrDisableColorXP
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
src
/
gpu
/
effects
/
generated
/
GrSimpleTextureEffect
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrRect
.
h
"
class
GrAppliedClip
;
class
GrOp
;
class
GrRenderTargetContext
;
class
GrPipeline
{
public
:
enum
class
InputFlags
:
uint8_t
{
kNone
=
0
kHWAntialias
=
(
1
<
<
0
)
kSnapVerticesToPixelCenters
=
(
1
<
<
1
)
}
;
struct
InitArgs
{
InputFlags
fInputFlags
=
InputFlags
:
:
kNone
;
const
GrUserStencilSettings
*
fUserStencil
=
&
GrUserStencilSettings
:
:
kUnused
;
const
GrCaps
*
fCaps
=
nullptr
;
GrXferProcessor
:
:
DstProxy
fDstProxy
;
GrSwizzle
fOutputSwizzle
;
}
;
struct
FixedDynamicState
{
explicit
FixedDynamicState
(
const
SkIRect
&
scissorRect
)
:
fScissorRect
(
scissorRect
)
{
}
FixedDynamicState
(
)
=
default
;
SkIRect
fScissorRect
=
SkIRect
:
:
EmptyIRect
(
)
;
GrTextureProxy
*
*
fPrimitiveProcessorTextures
=
nullptr
;
}
;
struct
DynamicStateArrays
{
const
SkIRect
*
fScissorRects
=
nullptr
;
GrTextureProxy
*
*
fPrimitiveProcessorTextures
=
nullptr
;
}
;
GrPipeline
(
GrScissorTest
scissor
SkBlendMode
blend
const
GrSwizzle
&
outputSwizzle
InputFlags
flags
=
InputFlags
:
:
kNone
const
GrUserStencilSettings
*
stencil
=
&
GrUserStencilSettings
:
:
kUnused
)
:
GrPipeline
(
scissor
GrPorterDuffXPFactory
:
:
MakeNoCoverageXP
(
blend
)
outputSwizzle
flags
stencil
)
{
}
GrPipeline
(
GrScissorTest
sk_sp
<
const
GrXferProcessor
>
const
GrSwizzle
&
outputSwizzle
InputFlags
=
InputFlags
:
:
kNone
const
GrUserStencilSettings
*
=
&
GrUserStencilSettings
:
:
kUnused
)
;
GrPipeline
(
const
InitArgs
&
GrProcessorSet
&
&
GrAppliedClip
&
&
)
;
GrPipeline
(
const
GrPipeline
&
)
=
delete
;
GrPipeline
&
operator
=
(
const
GrPipeline
&
)
=
delete
;
int
numColorFragmentProcessors
(
)
const
{
return
fNumColorProcessors
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fNumColorProcessors
;
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
;
}
const
GrXferProcessor
&
getXferProcessor
(
)
const
{
if
(
fXferProcessor
)
{
return
*
fXferProcessor
.
get
(
)
;
}
else
{
return
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
;
}
}
GrTextureProxy
*
dstTextureProxy
(
SkIPoint
*
offset
=
nullptr
)
const
{
if
(
offset
)
{
*
offset
=
fDstTextureOffset
;
}
return
fDstTextureProxy
.
get
(
)
;
}
GrTexture
*
peekDstTexture
(
SkIPoint
*
offset
=
nullptr
)
const
{
if
(
GrTextureProxy
*
dstProxy
=
this
-
>
dstTextureProxy
(
offset
)
)
{
return
dstProxy
-
>
peekTexture
(
)
;
}
return
nullptr
;
}
const
GrFragmentProcessor
&
getColorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numColorFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getCoverageFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numCoverageFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
fNumColorProcessors
+
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getFragmentProcessor
(
int
idx
)
const
{
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrUserStencilSettings
*
getUserStencil
(
)
const
{
return
fUserStencilSettings
;
}
bool
isScissorEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kScissorEnabled
)
;
}
const
GrWindowRectsState
&
getWindowRectsState
(
)
const
{
return
fWindowRectsState
;
}
bool
isHWAntialiasState
(
)
const
{
return
SkToBool
(
fFlags
&
InputFlags
:
:
kHWAntialias
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
InputFlags
:
:
kSnapVerticesToPixelCenters
)
;
}
bool
hasStencilClip
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kHasStencilClip
)
;
}
bool
isStencilEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kStencilEnabled
)
;
}
SkDEBUGCODE
(
bool
isBad
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kIsBad
)
;
}
)
GrXferBarrierType
xferBarrierType
(
GrTexture
*
const
GrCaps
&
)
const
;
uint32_t
getBlendInfoKey
(
)
const
;
const
GrSwizzle
&
outputSwizzle
(
)
const
{
return
fOutputSwizzle
;
}
private
:
SkDEBUGCODE
(
void
markAsBad
(
)
{
fFlags
|
=
Flags
:
:
kIsBad
;
}
)
static
constexpr
uint8_t
kLastInputFlag
=
(
uint8_t
)
InputFlags
:
:
kSnapVerticesToPixelCenters
;
enum
class
Flags
:
uint8_t
{
kHasStencilClip
=
(
kLastInputFlag
<
<
1
)
kStencilEnabled
=
(
kLastInputFlag
<
<
2
)
kScissorEnabled
=
(
kLastInputFlag
<
<
3
)
#
ifdef
SK_DEBUG
kIsBad
=
(
kLastInputFlag
<
<
4
)
#
endif
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
Flags
)
;
friend
bool
operator
&
(
Flags
InputFlags
)
;
using
FragmentProcessorArray
=
SkAutoSTArray
<
8
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
>
;
sk_sp
<
GrTextureProxy
>
fDstTextureProxy
;
SkIPoint
fDstTextureOffset
;
GrWindowRectsState
fWindowRectsState
;
const
GrUserStencilSettings
*
fUserStencilSettings
;
Flags
fFlags
;
sk_sp
<
const
GrXferProcessor
>
fXferProcessor
;
FragmentProcessorArray
fFragmentProcessors
;
int
fNumColorProcessors
;
GrSwizzle
fOutputSwizzle
;
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrPipeline
:
:
InputFlags
)
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrPipeline
:
:
Flags
)
;
inline
bool
operator
&
(
GrPipeline
:
:
Flags
flags
GrPipeline
:
:
InputFlags
inputFlag
)
{
return
(
flags
&
(
GrPipeline
:
:
Flags
)
inputFlag
)
;
}
#
endif
