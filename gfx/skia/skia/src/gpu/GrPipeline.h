#
ifndef
GrPipeline_DEFINED
#
define
GrPipeline_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
GrPendingProgramElement
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
GrProcOptInfo
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrScissorState
.
h
"
#
include
"
GrStencilSettings
.
h
"
#
include
"
GrWindowRectsState
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
effects
/
GrDisableColorXP
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
class
GrBatch
;
class
GrDrawContext
;
class
GrDeviceCoordTexture
;
class
GrPipelineBuilder
;
struct
GrBatchToXPOverrides
{
GrBatchToXPOverrides
(
)
:
fUsePLSDstRead
(
false
)
{
}
bool
fUsePLSDstRead
;
}
;
struct
GrPipelineOptimizations
{
GrProcOptInfo
fColorPOI
;
GrProcOptInfo
fCoveragePOI
;
GrBatchToXPOverrides
fOverrides
;
}
;
class
GrPipeline
:
public
GrNonAtomicRef
<
GrPipeline
>
{
public
:
struct
CreateArgs
{
const
GrPipelineBuilder
*
fPipelineBuilder
;
GrDrawContext
*
fDrawContext
;
const
GrCaps
*
fCaps
;
GrPipelineOptimizations
fOpts
;
const
GrScissorState
*
fScissor
;
const
GrWindowRectsState
*
fWindowRectsState
;
bool
fHasStencilClip
;
GrXferProcessor
:
:
DstTexture
fDstTexture
;
}
;
static
GrPipeline
*
CreateAt
(
void
*
memory
const
CreateArgs
&
GrXPOverridesForBatch
*
)
;
static
bool
AreEqual
(
const
GrPipeline
&
a
const
GrPipeline
&
b
)
;
static
bool
CanCombine
(
const
GrPipeline
&
a
const
SkRect
&
aBounds
const
GrPipeline
&
b
const
SkRect
&
bBounds
const
GrCaps
&
caps
)
{
if
(
!
AreEqual
(
a
b
)
)
{
return
false
;
}
if
(
a
.
xferBarrierType
(
caps
)
)
{
return
aBounds
.
fRight
<
=
bBounds
.
fLeft
|
|
aBounds
.
fBottom
<
=
bBounds
.
fTop
|
|
bBounds
.
fRight
<
=
aBounds
.
fLeft
|
|
bBounds
.
fBottom
<
=
aBounds
.
fTop
;
}
return
true
;
}
void
addDependenciesTo
(
GrRenderTarget
*
rt
)
const
;
int
numColorFragmentProcessors
(
)
const
{
return
fNumColorProcessors
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fNumColorProcessors
;
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
;
}
const
GrXferProcessor
&
getXferProcessor
(
)
const
{
if
(
fXferProcessor
.
get
(
)
)
{
return
*
fXferProcessor
.
get
(
)
;
}
else
{
return
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
;
}
}
const
GrFragmentProcessor
&
getColorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numColorFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getCoverageFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numCoverageFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
fNumColorProcessors
+
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getFragmentProcessor
(
int
idx
)
const
{
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
GrRenderTarget
*
getRenderTarget
(
)
const
{
return
fRenderTarget
.
get
(
)
;
}
const
GrStencilSettings
&
getStencil
(
)
const
{
return
fStencilSettings
;
}
const
GrScissorState
&
getScissorState
(
)
const
{
return
fScissorState
;
}
const
GrWindowRectsState
&
getWindowRectsState
(
)
const
{
return
fWindowRectsState
;
}
bool
isHWAntialiasState
(
)
const
{
return
SkToBool
(
fFlags
&
kHWAA_Flag
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
kSnapVertices_Flag
)
;
}
bool
getDisableOutputConversionToSRGB
(
)
const
{
return
SkToBool
(
fFlags
&
kDisableOutputConversionToSRGB_Flag
)
;
}
bool
getAllowSRGBInputs
(
)
const
{
return
SkToBool
(
fFlags
&
kAllowSRGBInputs_Flag
)
;
}
bool
usesDistanceVectorField
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesDistanceVectorField_Flag
)
;
}
bool
hasStencilClip
(
)
const
{
return
SkToBool
(
fFlags
&
kHasStencilClip_Flag
)
;
}
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
caps
)
const
{
return
this
-
>
getXferProcessor
(
)
.
xferBarrierType
(
fRenderTarget
.
get
(
)
caps
)
;
}
GrDrawFace
getDrawFace
(
)
const
{
return
fDrawFace
;
}
bool
ignoresCoverage
(
)
const
{
return
fIgnoresCoverage
;
}
private
:
GrPipeline
(
)
{
}
void
adjustProgramFromOptimizations
(
const
GrPipelineBuilder
&
ds
GrXferProcessor
:
:
OptFlags
const
GrProcOptInfo
&
colorPOI
const
GrProcOptInfo
&
coveragePOI
int
*
firstColorProcessorIdx
int
*
firstCoverageProcessorIdx
)
;
void
setOutputStateInfo
(
const
GrPipelineBuilder
&
ds
GrXferProcessor
:
:
OptFlags
const
GrCaps
&
)
;
enum
Flags
{
kHWAA_Flag
=
0x1
kSnapVertices_Flag
=
0x2
kDisableOutputConversionToSRGB_Flag
=
0x4
kAllowSRGBInputs_Flag
=
0x8
kUsesDistanceVectorField_Flag
=
0x10
kHasStencilClip_Flag
=
0x20
}
;
typedef
GrPendingIOResource
<
GrRenderTarget
kWrite_GrIOType
>
RenderTarget
;
typedef
GrPendingProgramElement
<
const
GrFragmentProcessor
>
PendingFragmentProcessor
;
typedef
SkAutoSTArray
<
8
PendingFragmentProcessor
>
FragmentProcessorArray
;
typedef
GrPendingProgramElement
<
const
GrXferProcessor
>
ProgramXferProcessor
;
RenderTarget
fRenderTarget
;
GrScissorState
fScissorState
;
GrWindowRectsState
fWindowRectsState
;
GrStencilSettings
fStencilSettings
;
GrDrawFace
fDrawFace
;
uint32_t
fFlags
;
ProgramXferProcessor
fXferProcessor
;
FragmentProcessorArray
fFragmentProcessors
;
bool
fIgnoresCoverage
;
int
fNumColorProcessors
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
