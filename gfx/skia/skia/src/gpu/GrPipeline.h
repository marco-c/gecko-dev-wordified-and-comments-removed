#
ifndef
GrPipeline_DEFINED
#
define
GrPipeline_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
GrPendingIOResource
.
h
"
#
include
"
GrProcessorSet
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrRect
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrScissorState
.
h
"
#
include
"
GrUserStencilSettings
.
h
"
#
include
"
GrWindowRectsState
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
effects
/
GrDisableColorXP
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
class
GrAppliedClip
;
class
GrOp
;
class
GrRenderTargetContext
;
class
GrPipeline
{
public
:
enum
Flags
{
kHWAntialias_Flag
=
0x1
kSnapVerticesToPixelCenters_Flag
=
0x2
}
;
struct
InitArgs
{
uint32_t
fFlags
=
0
;
const
GrUserStencilSettings
*
fUserStencil
=
&
GrUserStencilSettings
:
:
kUnused
;
GrRenderTargetProxy
*
fProxy
=
nullptr
;
const
GrCaps
*
fCaps
=
nullptr
;
GrResourceProvider
*
fResourceProvider
=
nullptr
;
GrXferProcessor
:
:
DstProxy
fDstProxy
;
}
;
struct
FixedDynamicState
{
explicit
FixedDynamicState
(
const
SkIRect
&
scissorRect
)
:
fScissorRect
(
scissorRect
)
{
}
FixedDynamicState
(
)
=
default
;
SkIRect
fScissorRect
=
SkIRect
:
:
EmptyIRect
(
)
;
GrTextureProxy
*
*
fPrimitiveProcessorTextures
=
nullptr
;
}
;
struct
DynamicStateArrays
{
const
SkIRect
*
fScissorRects
=
nullptr
;
GrTextureProxy
*
*
fPrimitiveProcessorTextures
=
nullptr
;
}
;
GrPipeline
(
GrRenderTargetProxy
*
GrScissorTest
SkBlendMode
)
;
GrPipeline
(
const
InitArgs
&
GrProcessorSet
&
&
GrAppliedClip
&
&
)
;
GrPipeline
(
const
GrPipeline
&
)
=
delete
;
GrPipeline
&
operator
=
(
const
GrPipeline
&
)
=
delete
;
void
addDependenciesTo
(
GrOpList
*
recipient
const
GrCaps
&
)
const
;
int
numColorFragmentProcessors
(
)
const
{
return
fNumColorProcessors
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fNumColorProcessors
;
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
;
}
const
GrXferProcessor
&
getXferProcessor
(
)
const
{
if
(
fXferProcessor
)
{
return
*
fXferProcessor
.
get
(
)
;
}
else
{
return
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
;
}
}
GrTextureProxy
*
dstTextureProxy
(
SkIPoint
*
offset
=
nullptr
)
const
{
if
(
offset
)
{
*
offset
=
fDstTextureOffset
;
}
return
fDstTextureProxy
.
get
(
)
;
}
GrTexture
*
peekDstTexture
(
SkIPoint
*
offset
=
nullptr
)
const
{
if
(
GrTextureProxy
*
dstProxy
=
this
-
>
dstTextureProxy
(
offset
)
)
{
return
dstProxy
-
>
peekTexture
(
)
;
}
return
nullptr
;
}
const
GrFragmentProcessor
&
getColorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numColorFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getCoverageFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numCoverageFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
fNumColorProcessors
+
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getFragmentProcessor
(
int
idx
)
const
{
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
GrRenderTargetProxy
*
proxy
(
)
const
{
return
fProxy
.
get
(
)
;
}
GrRenderTarget
*
renderTarget
(
)
const
{
return
fProxy
.
get
(
)
-
>
peekRenderTarget
(
)
;
}
const
GrUserStencilSettings
*
getUserStencil
(
)
const
{
return
fUserStencilSettings
;
}
bool
isScissorEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
kScissorEnabled_Flag
)
;
}
const
GrWindowRectsState
&
getWindowRectsState
(
)
const
{
return
fWindowRectsState
;
}
bool
isHWAntialiasState
(
)
const
{
return
SkToBool
(
fFlags
&
kHWAntialias_Flag
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
kSnapVerticesToPixelCenters_Flag
)
;
}
bool
hasStencilClip
(
)
const
{
return
SkToBool
(
fFlags
&
kHasStencilClip_Flag
)
;
}
bool
isStencilEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
kStencilEnabled_Flag
)
;
}
bool
isBad
(
)
const
{
return
SkToBool
(
fFlags
&
kIsBad_Flag
)
;
}
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
caps
)
const
;
static
SkString
DumpFlags
(
uint32_t
flags
)
{
if
(
flags
)
{
SkString
result
;
if
(
flags
&
GrPipeline
:
:
kSnapVerticesToPixelCenters_Flag
)
{
result
.
append
(
"
Snap
vertices
to
pixel
center
.
\
n
"
)
;
}
if
(
flags
&
GrPipeline
:
:
kHWAntialias_Flag
)
{
result
.
append
(
"
HW
Antialiasing
enabled
.
\
n
"
)
;
}
return
result
;
}
return
SkString
(
"
No
pipeline
flags
\
n
"
)
;
}
private
:
void
markAsBad
(
)
{
fFlags
|
=
kIsBad_Flag
;
}
enum
PrivateFlags
{
kHasStencilClip_Flag
=
0x10
kStencilEnabled_Flag
=
0x20
kScissorEnabled_Flag
=
0x40
kIsBad_Flag
=
0x80
}
;
using
RenderTargetProxy
=
GrPendingIOResource
<
GrRenderTargetProxy
kWrite_GrIOType
>
;
using
DstTextureProxy
=
GrPendingIOResource
<
GrTextureProxy
kRead_GrIOType
>
;
using
FragmentProcessorArray
=
SkAutoSTArray
<
8
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
>
;
DstTextureProxy
fDstTextureProxy
;
SkIPoint
fDstTextureOffset
;
RenderTargetProxy
fProxy
;
GrWindowRectsState
fWindowRectsState
;
const
GrUserStencilSettings
*
fUserStencilSettings
;
uint16_t
fFlags
;
sk_sp
<
const
GrXferProcessor
>
fXferProcessor
;
FragmentProcessorArray
fFragmentProcessors
;
int
fNumColorProcessors
;
}
;
#
endif
