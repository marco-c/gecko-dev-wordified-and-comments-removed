#
ifndef
GrPipeline_DEFINED
#
define
GrPipeline_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
GrPendingProgramElement
.
h
"
#
include
"
GrProcessorSet
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrScissorState
.
h
"
#
include
"
GrUserStencilSettings
.
h
"
#
include
"
GrWindowRectsState
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
effects
/
GrDisableColorXP
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
class
GrAppliedClip
;
class
GrDeviceCoordTexture
;
class
GrOp
;
class
GrPipelineBuilder
;
class
GrRenderTargetContext
;
class
GrPipeline
:
public
GrNonAtomicRef
<
GrPipeline
>
{
public
:
enum
Flags
{
kHWAntialias_Flag
=
0x1
kSnapVerticesToPixelCenters_Flag
=
0x2
}
;
struct
InitArgs
{
uint32_t
fFlags
=
0
;
GrDrawFace
fDrawFace
=
GrDrawFace
:
:
kBoth
;
const
GrProcessorSet
*
fProcessors
=
nullptr
;
const
GrUserStencilSettings
*
fUserStencil
=
&
GrUserStencilSettings
:
:
kUnused
;
const
GrAppliedClip
*
fAppliedClip
=
nullptr
;
GrRenderTarget
*
fRenderTarget
=
nullptr
;
const
GrCaps
*
fCaps
=
nullptr
;
GrXferProcessor
:
:
DstTexture
fDstTexture
;
}
;
GrPipeline
(
)
=
default
;
GrPipeline
(
GrRenderTarget
*
SkBlendMode
)
;
void
init
(
const
InitArgs
&
)
;
bool
isInitialized
(
)
const
{
return
SkToBool
(
fRenderTarget
.
get
(
)
)
;
}
static
bool
AreEqual
(
const
GrPipeline
&
a
const
GrPipeline
&
b
)
;
static
bool
CanCombine
(
const
GrPipeline
&
a
const
SkRect
&
aBounds
const
GrPipeline
&
b
const
SkRect
&
bBounds
const
GrCaps
&
caps
)
{
if
(
!
AreEqual
(
a
b
)
)
{
return
false
;
}
if
(
a
.
xferBarrierType
(
caps
)
)
{
return
aBounds
.
fRight
<
=
bBounds
.
fLeft
|
|
aBounds
.
fBottom
<
=
bBounds
.
fTop
|
|
bBounds
.
fRight
<
=
aBounds
.
fLeft
|
|
bBounds
.
fBottom
<
=
aBounds
.
fTop
;
}
return
true
;
}
void
addDependenciesTo
(
GrRenderTarget
*
rt
)
const
;
int
numColorFragmentProcessors
(
)
const
{
return
fNumColorProcessors
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fNumColorProcessors
;
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
;
}
const
GrXferProcessor
&
getXferProcessor
(
)
const
{
if
(
fXferProcessor
)
{
return
*
fXferProcessor
.
get
(
)
;
}
else
{
return
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
;
}
}
GrTexture
*
dstTexture
(
SkIPoint
*
offset
=
nullptr
)
const
{
if
(
offset
)
{
*
offset
=
fDstTextureOffset
;
}
return
fDstTexture
.
get
(
)
;
}
const
GrFragmentProcessor
&
getColorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numColorFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getCoverageFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
this
-
>
numCoverageFragmentProcessors
(
)
)
;
return
*
fFragmentProcessors
[
fNumColorProcessors
+
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
&
getFragmentProcessor
(
int
idx
)
const
{
return
*
fFragmentProcessors
[
idx
]
.
get
(
)
;
}
GrRenderTarget
*
getRenderTarget
(
)
const
{
return
fRenderTarget
.
get
(
)
;
}
const
GrUserStencilSettings
*
getUserStencil
(
)
const
{
return
fUserStencilSettings
;
}
const
GrScissorState
&
getScissorState
(
)
const
{
return
fScissorState
;
}
const
GrWindowRectsState
&
getWindowRectsState
(
)
const
{
return
fWindowRectsState
;
}
bool
isHWAntialiasState
(
)
const
{
return
SkToBool
(
fFlags
&
kHWAntialias_Flag
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
kSnapVerticesToPixelCenters_Flag
)
;
}
bool
getDisableOutputConversionToSRGB
(
)
const
{
return
SkToBool
(
fFlags
&
kDisableOutputConversionToSRGB_Flag
)
;
}
bool
getAllowSRGBInputs
(
)
const
{
return
SkToBool
(
fFlags
&
kAllowSRGBInputs_Flag
)
;
}
bool
usesDistanceVectorField
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesDistanceVectorField_Flag
)
;
}
bool
hasStencilClip
(
)
const
{
return
SkToBool
(
fFlags
&
kHasStencilClip_Flag
)
;
}
bool
isStencilEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
kStencilEnabled_Flag
)
;
}
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
caps
)
const
{
if
(
fDstTexture
.
get
(
)
&
&
fDstTexture
.
get
(
)
=
=
fRenderTarget
.
get
(
)
-
>
asTexture
(
)
)
{
return
kTexture_GrXferBarrierType
;
}
return
this
-
>
getXferProcessor
(
)
.
xferBarrierType
(
caps
)
;
}
GrDrawFace
getDrawFace
(
)
const
{
return
static_cast
<
GrDrawFace
>
(
fDrawFace
)
;
}
private
:
enum
PrivateFlags
{
kDisableOutputConversionToSRGB_Flag
=
0x4
kAllowSRGBInputs_Flag
=
0x8
kUsesDistanceVectorField_Flag
=
0x10
kHasStencilClip_Flag
=
0x20
kStencilEnabled_Flag
=
0x40
}
;
using
RenderTarget
=
GrPendingIOResource
<
GrRenderTarget
kWrite_GrIOType
>
;
using
DstTexture
=
GrPendingIOResource
<
GrTexture
kRead_GrIOType
>
;
using
PendingFragmentProcessor
=
GrPendingProgramElement
<
const
GrFragmentProcessor
>
;
using
FragmentProcessorArray
=
SkAutoSTArray
<
8
PendingFragmentProcessor
>
;
DstTexture
fDstTexture
;
SkIPoint
fDstTextureOffset
;
RenderTarget
fRenderTarget
;
GrScissorState
fScissorState
;
GrWindowRectsState
fWindowRectsState
;
const
GrUserStencilSettings
*
fUserStencilSettings
;
uint16_t
fDrawFace
;
uint16_t
fFlags
;
sk_sp
<
const
GrXferProcessor
>
fXferProcessor
;
FragmentProcessorArray
fFragmentProcessors
;
int
fNumColorProcessors
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
