#
ifndef
GrLayerCache_DEFINED
#
define
GrLayerCache_DEFINED
#
include
"
GrLayerAtlas
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrRect
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
SkImageFilter
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkPicture
.
h
"
#
include
"
SkTDynamicHash
.
h
"
#
define
GR_CACHE_HOISTED_LAYERS
0
struct
GrPictureInfo
{
public
:
static
const
int
kNumPlots
=
4
;
static
const
uint32_t
&
GetKey
(
const
GrPictureInfo
&
pictInfo
)
{
return
pictInfo
.
fPictureID
;
}
static
uint32_t
Hash
(
const
uint32_t
&
key
)
{
return
SkChecksum
:
:
Mix
(
key
)
;
}
GrPictureInfo
(
uint32_t
pictureID
)
:
fPictureID
(
pictureID
)
fPlotUsage
(
kNumPlots
)
{
#
if
!
GR_CACHE_HOISTED_LAYERS
memset
(
fPlotUses
0
sizeof
(
fPlotUses
)
)
;
#
endif
}
#
if
!
GR_CACHE_HOISTED_LAYERS
void
incPlotUsage
(
int
plotID
)
{
SkASSERT
(
plotID
<
kNumPlots
)
;
fPlotUses
[
plotID
]
+
+
;
}
void
decPlotUsage
(
int
plotID
)
{
SkASSERT
(
plotID
<
kNumPlots
)
;
SkASSERT
(
fPlotUses
[
plotID
]
>
0
)
;
fPlotUses
[
plotID
]
-
-
;
}
int
plotUsage
(
int
plotID
)
const
{
SkASSERT
(
plotID
<
kNumPlots
)
;
return
fPlotUses
[
plotID
]
;
}
#
endif
const
uint32_t
fPictureID
;
GrLayerAtlas
:
:
ClientPlotUsage
fPlotUsage
;
#
if
!
GR_CACHE_HOISTED_LAYERS
private
:
int
fPlotUses
[
kNumPlots
]
;
#
endif
}
;
struct
GrCachedLayer
{
public
:
struct
Key
{
Key
(
uint32_t
pictureID
const
SkMatrix
&
initialMat
const
int
*
key
int
keySize
bool
copyKey
=
false
)
:
fKeySize
(
keySize
)
fFreeKey
(
copyKey
)
{
fIDMatrix
.
fPictureID
=
pictureID
;
fIDMatrix
.
fInitialMat
=
initialMat
;
fIDMatrix
.
fInitialMat
.
getType
(
)
;
if
(
copyKey
)
{
int
*
tempKey
=
new
int
[
keySize
]
;
memcpy
(
tempKey
key
keySize
*
sizeof
(
int
)
)
;
fKey
=
tempKey
;
}
else
{
fKey
=
key
;
}
GR_STATIC_ASSERT
(
sizeof
(
IDMatrix
)
=
=
sizeof
(
uint32_t
)
+
9
*
sizeof
(
SkScalar
)
+
sizeof
(
uint32_t
)
)
;
}
~
Key
(
)
{
if
(
fFreeKey
)
{
delete
[
]
fKey
;
}
}
bool
operator
=
=
(
const
Key
&
other
)
const
{
if
(
fKeySize
!
=
other
.
fKeySize
)
{
return
false
;
}
return
fIDMatrix
.
fPictureID
=
=
other
.
fIDMatrix
.
fPictureID
&
&
fIDMatrix
.
fInitialMat
.
cheapEqualTo
(
other
.
fIDMatrix
.
fInitialMat
)
&
&
!
memcmp
(
fKey
other
.
fKey
fKeySize
*
sizeof
(
int
)
)
;
}
uint32_t
pictureID
(
)
const
{
return
fIDMatrix
.
fPictureID
;
}
const
int
*
key
(
)
const
{
SkASSERT
(
fFreeKey
)
;
return
fKey
;
}
int
keySize
(
)
const
{
SkASSERT
(
fFreeKey
)
;
return
fKeySize
;
}
uint32_t
hash
(
)
const
{
uint32_t
hash
=
SkChecksum
:
:
Murmur3
(
reinterpret_cast
<
const
uint32_t
*
>
(
fKey
)
fKeySize
*
sizeof
(
int
)
)
;
return
SkChecksum
:
:
Murmur3
(
reinterpret_cast
<
const
uint32_t
*
>
(
&
fIDMatrix
)
sizeof
(
IDMatrix
)
hash
)
;
}
private
:
struct
IDMatrix
{
uint32_t
fPictureID
;
SkMatrix
fInitialMat
;
}
fIDMatrix
;
const
int
*
fKey
;
const
int
fKeySize
;
bool
fFreeKey
;
}
;
static
const
Key
&
GetKey
(
const
GrCachedLayer
&
layer
)
{
return
layer
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
key
.
hash
(
)
;
}
GrCachedLayer
(
uint32_t
pictureID
int
start
int
stop
const
SkIRect
&
srcIR
const
SkIRect
&
dstIR
const
SkMatrix
&
ctm
const
int
*
key
int
keySize
const
SkPaint
*
paint
)
:
fKey
(
pictureID
ctm
key
keySize
true
)
fStart
(
start
)
fStop
(
stop
)
fSrcIR
(
srcIR
)
fDstIR
(
dstIR
)
fOffset
(
SkIPoint
:
:
Make
(
0
0
)
)
fPaint
(
paint
?
new
SkPaint
(
*
paint
)
:
nullptr
)
fFilter
(
nullptr
)
fTexture
(
nullptr
)
fAtlased
(
false
)
fRect
(
SkIRect
:
:
MakeEmpty
(
)
)
fPlot
(
nullptr
)
fUses
(
0
)
fLocked
(
false
)
{
SkASSERT
(
SK_InvalidGenID
!
=
pictureID
)
;
if
(
fPaint
)
{
if
(
fPaint
-
>
getImageFilter
(
)
)
{
fFilter
=
SkSafeRef
(
fPaint
-
>
getImageFilter
(
)
)
;
fPaint
-
>
setImageFilter
(
nullptr
)
;
}
}
}
~
GrCachedLayer
(
)
{
if
(
!
fAtlased
)
{
SkSafeUnref
(
fTexture
)
;
}
SkSafeUnref
(
fFilter
)
;
delete
fPaint
;
}
uint32_t
pictureID
(
)
const
{
return
fKey
.
pictureID
(
)
;
}
const
int
*
key
(
)
const
{
return
fKey
.
key
(
)
;
}
int
keySize
(
)
const
{
return
fKey
.
keySize
(
)
;
}
int
start
(
)
const
{
return
fStart
;
}
const
SkIRect
&
srcIR
(
)
const
{
return
fSrcIR
;
}
const
SkIRect
&
dstIR
(
)
const
{
return
fDstIR
;
}
int
stop
(
)
const
{
return
fStop
;
}
void
setTexture
(
GrTexture
*
texture
const
SkIRect
&
rect
bool
atlased
)
{
if
(
texture
&
&
!
atlased
)
{
texture
-
>
ref
(
)
;
}
if
(
fTexture
&
&
!
fAtlased
)
{
fTexture
-
>
unref
(
)
;
}
fTexture
=
texture
;
fAtlased
=
atlased
;
fRect
=
rect
;
if
(
!
fTexture
)
{
fLocked
=
false
;
}
}
GrTexture
*
texture
(
)
{
return
fTexture
;
}
const
SkPaint
*
paint
(
)
const
{
return
fPaint
;
}
const
SkImageFilter
*
filter
(
)
const
{
return
fFilter
;
}
const
SkIRect
&
rect
(
)
const
{
return
fRect
;
}
void
setOffset
(
const
SkIPoint
&
offset
)
{
fOffset
=
offset
;
}
const
SkIPoint
&
offset
(
)
const
{
return
fOffset
;
}
void
setPlot
(
GrLayerAtlas
:
:
Plot
*
plot
)
{
SkASSERT
(
nullptr
=
=
plot
|
|
nullptr
=
=
fPlot
)
;
fPlot
=
plot
;
}
GrLayerAtlas
:
:
Plot
*
plot
(
)
{
return
fPlot
;
}
bool
isAtlased
(
)
const
{
SkASSERT
(
fAtlased
=
=
SkToBool
(
fPlot
)
)
;
return
fAtlased
;
}
void
setLocked
(
bool
locked
)
{
fLocked
=
locked
;
}
bool
locked
(
)
const
{
return
fLocked
;
}
SkDEBUGCODE
(
const
GrLayerAtlas
:
:
Plot
*
plot
(
)
const
{
return
fPlot
;
}
)
SkDEBUGCODE
(
void
validate
(
const
GrTexture
*
backingTexture
)
const
;
)
private
:
const
Key
fKey
;
const
int
fStart
;
const
int
fStop
;
const
SkIRect
fSrcIR
;
const
SkIRect
fDstIR
;
SkIPoint
fOffset
;
SkPaint
*
fPaint
;
const
SkImageFilter
*
fFilter
;
GrTexture
*
fTexture
;
bool
fAtlased
;
SkIRect
fRect
;
GrLayerAtlas
:
:
Plot
*
fPlot
;
int
fUses
;
bool
fLocked
;
void
addUse
(
)
{
+
+
fUses
;
}
void
removeUse
(
)
{
SkASSERT
(
fUses
>
0
)
;
-
-
fUses
;
}
int
uses
(
)
const
{
return
fUses
;
}
friend
class
GrLayerCache
;
friend
class
TestingAccess
;
}
;
class
GrLayerCache
{
public
:
GrLayerCache
(
GrContext
*
)
;
~
GrLayerCache
(
)
;
void
freeAll
(
)
;
GrCachedLayer
*
findLayer
(
uint32_t
pictureID
const
SkMatrix
&
ctm
const
int
*
key
int
keySize
)
;
GrCachedLayer
*
findLayerOrCreate
(
uint32_t
pictureID
int
start
int
stop
const
SkIRect
&
srcIR
const
SkIRect
&
dstIR
const
SkMatrix
&
initialMat
const
int
*
key
int
keySize
const
SkPaint
*
paint
)
;
bool
tryToAtlas
(
GrCachedLayer
*
layer
const
GrSurfaceDesc
&
desc
bool
*
needsRendering
)
;
bool
lock
(
GrCachedLayer
*
layer
const
GrSurfaceDesc
&
desc
bool
*
needsRendering
)
;
void
addUse
(
GrCachedLayer
*
layer
)
{
layer
-
>
addUse
(
)
;
}
void
removeUse
(
GrCachedLayer
*
layer
)
{
layer
-
>
removeUse
(
)
;
if
(
layer
-
>
uses
(
)
=
=
0
)
{
this
-
>
unlock
(
layer
)
;
}
}
void
processDeletedPictures
(
)
;
SkDEBUGCODE
(
void
validate
(
)
const
;
)
#
ifdef
SK_DEVELOPER
void
writeLayersToDisk
(
const
SkString
&
dirName
)
;
#
endif
static
bool
PlausiblyAtlasable
(
int
width
int
height
)
{
return
width
<
=
kPlotWidth
&
&
height
<
=
kPlotHeight
;
}
void
begin
(
)
;
void
end
(
)
;
#
if
!
GR_CACHE_HOISTED_LAYERS
void
purgeAll
(
)
;
#
endif
private
:
static
const
int
kAtlasTextureWidth
=
1024
;
static
const
int
kAtlasTextureHeight
=
1024
;
static
const
int
kNumPlotsX
=
2
;
static
const
int
kNumPlotsY
=
2
;
static
const
int
kPlotWidth
=
kAtlasTextureWidth
/
kNumPlotsX
;
static
const
int
kPlotHeight
=
kAtlasTextureHeight
/
kNumPlotsY
;
GrContext
*
fContext
;
SkAutoTDelete
<
GrLayerAtlas
>
fAtlas
;
SkTDynamicHash
<
GrPictureInfo
uint32_t
>
fPictureHash
;
SkTDynamicHash
<
GrCachedLayer
GrCachedLayer
:
:
Key
>
fLayerHash
;
SkMessageBus
<
SkPicture
:
:
DeletionMessage
>
:
:
Inbox
fPictDeletionInbox
;
int
fPlotLocks
[
kNumPlotsX
*
kNumPlotsY
]
;
void
unlock
(
GrCachedLayer
*
layer
)
;
void
initAtlas
(
)
;
GrCachedLayer
*
createLayer
(
uint32_t
pictureID
int
start
int
stop
const
SkIRect
&
srcIR
const
SkIRect
&
dstIR
const
SkMatrix
&
initialMat
const
int
*
key
int
keySize
const
SkPaint
*
paint
)
;
void
purge
(
uint32_t
pictureID
)
;
void
purgePlot
(
GrLayerAtlas
:
:
Plot
*
plot
)
;
bool
purgePlots
(
bool
justOne
)
;
void
incPlotLock
(
int
plotIdx
)
{
+
+
fPlotLocks
[
plotIdx
]
;
}
void
decPlotLock
(
int
plotIdx
)
{
SkASSERT
(
fPlotLocks
[
plotIdx
]
>
0
)
;
-
-
fPlotLocks
[
plotIdx
]
;
}
friend
class
TestingAccess
;
int
numLayers
(
)
const
{
return
fLayerHash
.
count
(
)
;
}
}
;
#
endif
