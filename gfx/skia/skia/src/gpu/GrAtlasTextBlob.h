#
ifndef
GrAtlasTextBlob_DEFINED
#
define
GrAtlasTextBlob_DEFINED
#
include
"
GrBatchAtlas
.
h
"
#
include
"
GrBatchFontCache
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTInternalLList
.
h
"
struct
GrAtlasTextBlob
:
public
SkRefCnt
{
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrAtlasTextBlob
)
;
struct
Run
{
Run
(
)
:
fColor
(
GrColor_ILLEGAL
)
fInitialized
(
false
)
fDrawAsPaths
(
false
)
{
fVertexBounds
.
setLargestInverted
(
)
;
fSubRunInfo
.
push_back
(
)
;
}
struct
SubRunInfo
{
SubRunInfo
(
)
:
fAtlasGeneration
(
GrBatchAtlas
:
:
kInvalidAtlasGeneration
)
fVertexStartIndex
(
0
)
fVertexEndIndex
(
0
)
fGlyphStartIndex
(
0
)
fGlyphEndIndex
(
0
)
fTextRatio
(
1
.
0f
)
fMaskFormat
(
kA8_GrMaskFormat
)
fDrawAsDistanceFields
(
false
)
fUseLCDText
(
false
)
{
}
SubRunInfo
(
const
SubRunInfo
&
that
)
:
fBulkUseToken
(
that
.
fBulkUseToken
)
fStrike
(
SkSafeRef
(
that
.
fStrike
.
get
(
)
)
)
fAtlasGeneration
(
that
.
fAtlasGeneration
)
fVertexStartIndex
(
that
.
fVertexStartIndex
)
fVertexEndIndex
(
that
.
fVertexEndIndex
)
fGlyphStartIndex
(
that
.
fGlyphStartIndex
)
fGlyphEndIndex
(
that
.
fGlyphEndIndex
)
fTextRatio
(
that
.
fTextRatio
)
fMaskFormat
(
that
.
fMaskFormat
)
fDrawAsDistanceFields
(
that
.
fDrawAsDistanceFields
)
fUseLCDText
(
that
.
fUseLCDText
)
{
}
GrBatchAtlas
:
:
BulkUseTokenUpdater
fBulkUseToken
;
SkAutoTUnref
<
GrBatchTextStrike
>
fStrike
;
uint64_t
fAtlasGeneration
;
size_t
fVertexStartIndex
;
size_t
fVertexEndIndex
;
uint32_t
fGlyphStartIndex
;
uint32_t
fGlyphEndIndex
;
SkScalar
fTextRatio
;
GrMaskFormat
fMaskFormat
;
bool
fDrawAsDistanceFields
;
bool
fUseLCDText
;
}
;
SubRunInfo
&
push_back
(
)
{
SubRunInfo
&
newSubRun
=
fSubRunInfo
.
push_back
(
)
;
SubRunInfo
&
prevSubRun
=
fSubRunInfo
.
fromBack
(
1
)
;
newSubRun
.
fGlyphStartIndex
=
prevSubRun
.
fGlyphEndIndex
;
newSubRun
.
fGlyphEndIndex
=
prevSubRun
.
fGlyphEndIndex
;
newSubRun
.
fVertexStartIndex
=
prevSubRun
.
fVertexEndIndex
;
newSubRun
.
fVertexEndIndex
=
prevSubRun
.
fVertexEndIndex
;
return
newSubRun
;
}
static
const
int
kMinSubRuns
=
1
;
SkAutoTUnref
<
SkTypeface
>
fTypeface
;
SkRect
fVertexBounds
;
SkSTArray
<
kMinSubRuns
SubRunInfo
>
fSubRunInfo
;
SkAutoDescriptor
fDescriptor
;
SkAutoTDelete
<
SkAutoDescriptor
>
fOverrideDescriptor
;
GrColor
fColor
;
bool
fInitialized
;
bool
fDrawAsPaths
;
}
;
struct
BigGlyph
{
BigGlyph
(
const
SkPath
&
path
SkScalar
vx
SkScalar
vy
SkScalar
scale
bool
applyVM
)
:
fPath
(
path
)
fVx
(
vx
)
fVy
(
vy
)
fScale
(
scale
)
fApplyVM
(
applyVM
)
{
}
SkPath
fPath
;
SkScalar
fVx
;
SkScalar
fVy
;
SkScalar
fScale
;
bool
fApplyVM
;
}
;
struct
Key
{
Key
(
)
{
sk_bzero
(
this
sizeof
(
Key
)
)
;
}
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkPaint
:
:
Style
fStyle
;
SkPixelGeometry
fPixelGeometry
;
bool
fHasBlur
;
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
0
=
=
memcmp
(
this
&
other
sizeof
(
Key
)
)
;
}
}
;
struct
StrokeInfo
{
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPaint
:
:
Join
fJoin
;
}
;
enum
TextType
{
kHasDistanceField_TextType
=
0x1
kHasBitmap_TextType
=
0x2
}
;
unsigned
char
*
fVertices
;
GrGlyph
*
*
fGlyphs
;
Run
*
fRuns
;
GrMemoryPool
*
fPool
;
SkMaskFilter
:
:
BlurRec
fBlurRec
;
StrokeInfo
fStrokeInfo
;
SkTArray
<
BigGlyph
>
fBigGlyphs
;
Key
fKey
;
SkMatrix
fViewMatrix
;
GrColor
fPaintColor
;
SkScalar
fX
;
SkScalar
fY
;
SkScalar
fMaxMinScale
;
SkScalar
fMinMaxScale
;
int
fRunCount
;
uint8_t
fTextType
;
GrAtlasTextBlob
(
)
:
fMaxMinScale
(
-
SK_ScalarMax
)
fMinMaxScale
(
SK_ScalarMax
)
fTextType
(
0
)
{
}
~
GrAtlasTextBlob
(
)
override
{
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
~
Run
(
)
;
}
}
static
const
Key
&
GetKey
(
const
GrAtlasTextBlob
&
blob
)
{
return
blob
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
SkChecksum
:
:
Murmur3
(
&
key
sizeof
(
Key
)
)
;
}
void
operator
delete
(
void
*
p
)
{
GrAtlasTextBlob
*
blob
=
reinterpret_cast
<
GrAtlasTextBlob
*
>
(
p
)
;
blob
-
>
fPool
-
>
release
(
p
)
;
}
void
*
operator
new
(
size_t
)
{
SkFAIL
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
bool
hasDistanceField
(
)
const
{
return
SkToBool
(
fTextType
&
kHasDistanceField_TextType
)
;
}
bool
hasBitmap
(
)
const
{
return
SkToBool
(
fTextType
&
kHasBitmap_TextType
)
;
}
void
setHasDistanceField
(
)
{
fTextType
|
=
kHasDistanceField_TextType
;
}
void
setHasBitmap
(
)
{
fTextType
|
=
kHasBitmap_TextType
;
}
#
ifdef
CACHE_SANITY_CHECK
static
void
AssertEqual
(
const
GrAtlasTextBlob
&
const
GrAtlasTextBlob
&
)
;
size_t
fSize
;
#
endif
}
;
#
endif
