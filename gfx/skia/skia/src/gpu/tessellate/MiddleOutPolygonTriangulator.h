#
ifndef
skgpu_tessellate_MiddleOutPolygonTriangulator_DEFINED
#
define
skgpu_tessellate_MiddleOutPolygonTriangulator_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
<
tuple
>
namespace
skgpu
:
:
tess
{
class
MiddleOutPolygonTriangulator
{
private
:
struct
StackVertex
{
SkPoint
fPoint
;
int
fVertexIdxDelta
;
}
;
public
:
class
PoppedTriangleStack
{
public
:
PoppedTriangleStack
(
MiddleOutPolygonTriangulator
*
middleOut
SkPoint
lastPoint
StackVertex
*
end
StackVertex
*
newTopVertex
StackVertex
newTopValue
)
:
fMiddleOut
(
middleOut
)
fLastPoint
(
lastPoint
)
fEnd
(
end
)
fNewTopVertex
(
newTopVertex
)
fNewTopValue
(
newTopValue
)
{
}
PoppedTriangleStack
(
PoppedTriangleStack
&
&
that
)
{
memcpy
(
this
&
that
sizeof
(
*
this
)
)
;
that
.
fMiddleOut
=
nullptr
;
}
~
PoppedTriangleStack
(
)
{
if
(
fMiddleOut
)
{
fMiddleOut
-
>
fTop
=
fNewTopVertex
;
*
fNewTopVertex
=
fNewTopValue
;
}
}
struct
Iter
{
bool
operator
!
=
(
const
Iter
&
iter
)
{
return
fVertex
!
=
iter
.
fVertex
;
}
void
operator
+
+
(
)
{
-
-
fVertex
;
}
std
:
:
tuple
<
SkPoint
SkPoint
SkPoint
>
operator
*
(
)
{
return
{
fVertex
[
-
1
]
.
fPoint
fVertex
[
0
]
.
fPoint
fLastPoint
}
;
}
StackVertex
*
fVertex
;
SkPoint
fLastPoint
;
}
;
Iter
begin
(
)
const
{
return
{
fMiddleOut
?
fMiddleOut
-
>
fTop
:
fEnd
fLastPoint
}
;
}
Iter
end
(
)
const
{
return
{
fEnd
fLastPoint
}
;
}
private
:
MiddleOutPolygonTriangulator
*
fMiddleOut
;
SkPoint
fLastPoint
;
StackVertex
*
fEnd
;
StackVertex
*
fNewTopVertex
;
StackVertex
fNewTopValue
;
}
;
MiddleOutPolygonTriangulator
(
int
maxPushVertexCalls
SkPoint
startPoint
=
{
0
0
}
)
{
SkASSERT
(
maxPushVertexCalls
>
=
0
)
;
int
maxStackDepth
=
SkNextLog2
(
maxPushVertexCalls
)
+
1
;
if
(
maxStackDepth
>
kStackPreallocCount
)
{
fVertexStack
.
reset
(
maxStackDepth
)
;
}
SkDEBUGCODE
(
fStackAllocCount
=
maxStackDepth
;
)
fVertexStack
[
0
]
=
{
startPoint
0
}
;
fTop
=
fVertexStack
;
}
SK_WARN_UNUSED_RESULT
PoppedTriangleStack
pushVertex
(
SkPoint
pt
)
{
StackVertex
*
endVertex
=
fTop
;
int
vertexIdxDelta
=
1
;
while
(
endVertex
-
>
fVertexIdxDelta
=
=
vertexIdxDelta
)
{
-
-
endVertex
;
vertexIdxDelta
*
=
2
;
}
StackVertex
*
newTopVertex
=
endVertex
+
1
;
StackVertex
newTopValue
=
{
pt
vertexIdxDelta
}
;
SkASSERT
(
newTopVertex
<
fVertexStack
+
fStackAllocCount
)
;
return
PoppedTriangleStack
(
this
pt
endVertex
newTopVertex
newTopValue
)
;
}
SK_WARN_UNUSED_RESULT
PoppedTriangleStack
closeAndMove
(
SkPoint
newStartPoint
)
{
SkPoint
startPt
=
fVertexStack
[
0
]
.
fPoint
;
StackVertex
*
endVertex
=
std
:
:
min
(
fTop
fVertexStack
+
1
)
;
StackVertex
*
newTopVertex
=
fVertexStack
;
StackVertex
newTopValue
=
{
newStartPoint
0
}
;
return
PoppedTriangleStack
(
this
startPt
endVertex
newTopVertex
newTopValue
)
;
}
SK_WARN_UNUSED_RESULT
PoppedTriangleStack
close
(
)
{
return
this
-
>
closeAndMove
(
fVertexStack
[
0
]
.
fPoint
)
;
}
private
:
constexpr
static
int
kStackPreallocCount
=
32
;
skia_private
:
:
AutoSTMalloc
<
kStackPreallocCount
StackVertex
>
fVertexStack
;
SkDEBUGCODE
(
int
fStackAllocCount
;
)
StackVertex
*
fTop
;
}
;
class
PathMiddleOutFanIter
{
public
:
PathMiddleOutFanIter
(
const
SkPath
&
path
)
:
fMiddleOut
(
path
.
countVerbs
(
)
)
{
SkPathPriv
:
:
Iterate
it
(
path
)
;
fPathIter
=
it
.
begin
(
)
;
fPathEnd
=
it
.
end
(
)
;
}
bool
done
(
)
const
{
return
fDone
;
}
MiddleOutPolygonTriangulator
:
:
PoppedTriangleStack
nextStack
(
)
{
SkASSERT
(
!
fDone
)
;
if
(
fPathIter
=
=
fPathEnd
)
{
fDone
=
true
;
return
fMiddleOut
.
close
(
)
;
}
switch
(
auto
[
verb
pts
w
]
=
*
fPathIter
+
+
;
verb
)
{
SkPoint
pt
;
case
SkPathVerb
:
:
kMove
:
return
fMiddleOut
.
closeAndMove
(
pts
[
0
]
)
;
case
SkPathVerb
:
:
kLine
:
case
SkPathVerb
:
:
kQuad
:
case
SkPathVerb
:
:
kConic
:
case
SkPathVerb
:
:
kCubic
:
pt
=
pts
[
SkPathPriv
:
:
PtsInIter
(
(
unsigned
)
verb
)
-
1
]
;
return
fMiddleOut
.
pushVertex
(
pt
)
;
case
SkPathVerb
:
:
kClose
:
return
fMiddleOut
.
close
(
)
;
}
SkUNREACHABLE
;
}
private
:
MiddleOutPolygonTriangulator
fMiddleOut
;
SkPathPriv
:
:
RangeIter
fPathIter
;
SkPathPriv
:
:
RangeIter
fPathEnd
;
bool
fDone
=
false
;
}
;
}
#
endif
