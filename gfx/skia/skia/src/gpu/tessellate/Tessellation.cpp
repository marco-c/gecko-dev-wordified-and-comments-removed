#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
src
/
base
/
SkUtils
.
h
"
#
include
"
src
/
core
/
SkGeometry
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
CullTest
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
MiddleOutPolygonTriangulator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
namespace
skgpu
:
:
tess
{
namespace
{
using
float2
=
skvx
:
:
float2
;
using
float4
=
skvx
:
:
float4
;
constexpr
static
int
kMaxChopsPerCurve
=
128
*
6
*
6
;
class
PathChopper
{
public
:
PathChopper
(
float
tessellationPrecision
const
SkMatrix
&
matrix
const
SkRect
&
viewport
)
:
fTessellationPrecision
(
tessellationPrecision
)
fCullTest
(
viewport
matrix
)
fVectorXform
(
matrix
)
{
fPath
.
setIsVolatile
(
true
)
;
}
SkPath
path
(
)
const
{
return
fPath
;
}
void
moveTo
(
SkPoint
p
)
{
fPath
.
moveTo
(
p
)
;
}
void
lineTo
(
const
SkPoint
p
[
2
]
)
{
fPath
.
lineTo
(
p
[
1
]
)
;
}
void
close
(
)
{
fPath
.
close
(
)
;
}
void
quadTo
(
const
SkPoint
quad
[
3
]
)
{
SkASSERT
(
fPointStack
.
empty
(
)
)
;
fPointStack
.
push_back_n
(
3
quad
)
;
int
numChops
=
0
;
while
(
!
fPointStack
.
empty
(
)
)
{
const
SkPoint
*
p
=
fPointStack
.
end
(
)
-
3
;
if
(
!
fCullTest
.
areVisible3
(
p
)
)
{
fPath
.
lineTo
(
p
[
2
]
)
;
}
else
{
float
n4
=
wangs_formula
:
:
quadratic_p4
(
fTessellationPrecision
p
fVectorXform
)
;
if
(
n4
>
kMaxSegmentsPerCurve_p4
&
&
numChops
<
kMaxChopsPerCurve
)
{
SkPoint
chops
[
5
]
;
SkChopQuadAtHalf
(
p
chops
)
;
fPointStack
.
pop_back_n
(
3
)
;
fPointStack
.
push_back_n
(
3
chops
+
2
)
;
fPointStack
.
push_back_n
(
3
chops
)
;
+
+
numChops
;
continue
;
}
fPath
.
quadTo
(
p
[
1
]
p
[
2
]
)
;
}
fPointStack
.
pop_back_n
(
3
)
;
}
}
void
conicTo
(
const
SkPoint
conic
[
3
]
float
weight
)
{
SkASSERT
(
fPointStack
.
empty
(
)
)
;
SkASSERT
(
fWeightStack
.
empty
(
)
)
;
fPointStack
.
push_back_n
(
3
conic
)
;
fWeightStack
.
push_back
(
weight
)
;
int
numChops
=
0
;
while
(
!
fPointStack
.
empty
(
)
)
{
const
SkPoint
*
p
=
fPointStack
.
end
(
)
-
3
;
float
w
=
fWeightStack
.
back
(
)
;
if
(
!
fCullTest
.
areVisible3
(
p
)
)
{
fPath
.
lineTo
(
p
[
2
]
)
;
}
else
{
float
n2
=
wangs_formula
:
:
conic_p2
(
fTessellationPrecision
p
w
fVectorXform
)
;
if
(
n2
>
kMaxSegmentsPerCurve_p2
&
&
numChops
<
kMaxChopsPerCurve
)
{
SkConic
chops
[
2
]
;
if
(
!
SkConic
(
p
w
)
.
chopAt
(
.
5
chops
)
)
{
SkPoint
line
[
2
]
=
{
p
[
0
]
p
[
2
]
}
;
this
-
>
lineTo
(
line
)
;
continue
;
}
fPointStack
.
pop_back_n
(
3
)
;
fWeightStack
.
pop_back
(
)
;
fPointStack
.
push_back_n
(
3
chops
[
1
]
.
fPts
)
;
fWeightStack
.
push_back
(
chops
[
1
]
.
fW
)
;
fPointStack
.
push_back_n
(
3
chops
[
0
]
.
fPts
)
;
fWeightStack
.
push_back
(
chops
[
0
]
.
fW
)
;
+
+
numChops
;
continue
;
}
fPath
.
conicTo
(
p
[
1
]
p
[
2
]
w
)
;
}
fPointStack
.
pop_back_n
(
3
)
;
fWeightStack
.
pop_back
(
)
;
}
SkASSERT
(
fWeightStack
.
empty
(
)
)
;
}
void
cubicTo
(
const
SkPoint
cubic
[
4
]
)
{
SkASSERT
(
fPointStack
.
empty
(
)
)
;
fPointStack
.
push_back_n
(
4
cubic
)
;
int
numChops
=
0
;
while
(
!
fPointStack
.
empty
(
)
)
{
SkPoint
*
p
=
fPointStack
.
end
(
)
-
4
;
if
(
!
fCullTest
.
areVisible4
(
p
)
)
{
fPath
.
lineTo
(
p
[
3
]
)
;
}
else
{
float
n4
=
wangs_formula
:
:
cubic_p4
(
fTessellationPrecision
p
fVectorXform
)
;
if
(
n4
>
kMaxSegmentsPerCurve_p4
&
&
numChops
<
kMaxChopsPerCurve
)
{
SkPoint
chops
[
7
]
;
SkChopCubicAtHalf
(
p
chops
)
;
fPointStack
.
pop_back_n
(
4
)
;
fPointStack
.
push_back_n
(
4
chops
+
3
)
;
fPointStack
.
push_back_n
(
4
chops
)
;
+
+
numChops
;
continue
;
}
fPath
.
cubicTo
(
p
[
1
]
p
[
2
]
p
[
3
]
)
;
}
fPointStack
.
pop_back_n
(
4
)
;
}
}
private
:
const
float
fTessellationPrecision
;
const
CullTest
fCullTest
;
const
wangs_formula
:
:
VectorXform
fVectorXform
;
SkPath
fPath
;
SkSTArray
<
8
SkPoint
>
fPointStack
;
SkSTArray
<
2
float
>
fWeightStack
;
}
;
}
SkPath
PreChopPathCurves
(
float
tessellationPrecision
const
SkPath
&
path
const
SkMatrix
&
matrix
const
SkRect
&
viewport
)
{
SkASSERT
(
wangs_formula
:
:
worst_case_cubic
(
tessellationPrecision
viewport
.
width
(
)
viewport
.
height
(
)
)
<
=
kMaxSegmentsPerCurve
)
;
PathChopper
chopper
(
tessellationPrecision
matrix
viewport
)
;
for
(
auto
[
verb
p
w
]
:
SkPathPriv
:
:
Iterate
(
path
)
)
{
switch
(
verb
)
{
case
SkPathVerb
:
:
kMove
:
chopper
.
moveTo
(
p
[
0
]
)
;
break
;
case
SkPathVerb
:
:
kLine
:
chopper
.
lineTo
(
p
)
;
break
;
case
SkPathVerb
:
:
kQuad
:
chopper
.
quadTo
(
p
)
;
break
;
case
SkPathVerb
:
:
kConic
:
chopper
.
conicTo
(
p
*
w
)
;
break
;
case
SkPathVerb
:
:
kCubic
:
chopper
.
cubicTo
(
p
)
;
break
;
case
SkPathVerb
:
:
kClose
:
chopper
.
close
(
)
;
break
;
}
}
return
chopper
.
path
(
)
;
}
int
FindCubicConvex180Chops
(
const
SkPoint
pts
[
]
float
T
[
2
]
bool
*
areCusps
)
{
SkASSERT
(
pts
)
;
SkASSERT
(
T
)
;
SkASSERT
(
areCusps
)
;
constexpr
static
float
kEpsilon
=
1
.
f
/
(
1
<
<
11
)
;
constexpr
static
uint32_t
kIEEE_one_minus_2_epsilon
=
(
127
<
<
23
)
-
2
*
(
1
<
<
(
24
-
11
)
)
;
SkASSERT
(
sk_bit_cast
<
float
>
(
kIEEE_one_minus_2_epsilon
)
=
=
1
-
2
*
kEpsilon
)
;
float2
p0
=
skvx
:
:
bit_pun
<
float2
>
(
pts
[
0
]
)
;
float2
p1
=
skvx
:
:
bit_pun
<
float2
>
(
pts
[
1
]
)
;
float2
p2
=
skvx
:
:
bit_pun
<
float2
>
(
pts
[
2
]
)
;
float2
p3
=
skvx
:
:
bit_pun
<
float2
>
(
pts
[
3
]
)
;
float2
C
=
p1
-
p0
;
float2
D
=
p2
-
p1
;
float2
E
=
p3
-
p0
;
float2
B
=
D
-
C
;
float2
A
=
-
3
*
D
+
E
;
float
a
=
cross
(
A
B
)
;
float
b
=
cross
(
A
C
)
;
float
c
=
cross
(
B
C
)
;
float
b_over_minus_2
=
-
.
5f
*
b
;
float
discr_over_4
=
b_over_minus_2
*
b_over_minus_2
-
a
*
c
;
float
cuspThreshold
=
a
*
(
kEpsilon
/
2
)
;
cuspThreshold
*
=
cuspThreshold
;
if
(
discr_over_4
<
-
cuspThreshold
)
{
*
areCusps
=
false
;
float
root
=
sk_ieee_float_divide
(
c
b_over_minus_2
)
;
if
(
sk_bit_cast
<
uint32_t
>
(
root
-
kEpsilon
)
<
kIEEE_one_minus_2_epsilon
)
{
T
[
0
]
=
root
;
return
1
;
}
return
0
;
}
*
areCusps
=
(
discr_over_4
<
=
cuspThreshold
)
;
if
(
*
areCusps
)
{
if
(
a
!
=
0
|
|
b_over_minus_2
!
=
0
|
|
c
!
=
0
)
{
float
root
=
sk_ieee_float_divide
(
b_over_minus_2
a
)
;
if
(
sk_bit_cast
<
uint32_t
>
(
root
-
kEpsilon
)
<
kIEEE_one_minus_2_epsilon
)
{
T
[
0
]
=
root
;
return
1
;
}
return
0
;
}
float2
tan0
=
skvx
:
:
if_then_else
(
C
!
=
0
C
p2
-
p0
)
;
a
=
dot
(
tan0
A
)
;
b_over_minus_2
=
-
dot
(
tan0
B
)
;
c
=
dot
(
tan0
C
)
;
discr_over_4
=
std
:
:
max
(
b_over_minus_2
*
b_over_minus_2
-
a
*
c
0
.
f
)
;
}
float
q
=
sqrtf
(
discr_over_4
)
;
q
=
copysignf
(
q
b_over_minus_2
)
;
q
=
q
+
b_over_minus_2
;
float2
roots
=
float2
{
q
c
}
/
float2
{
a
q
}
;
auto
inside
=
(
roots
>
kEpsilon
)
&
(
roots
<
(
1
-
kEpsilon
)
)
;
if
(
inside
[
0
]
)
{
if
(
inside
[
1
]
&
&
roots
[
0
]
!
=
roots
[
1
]
)
{
if
(
roots
[
0
]
>
roots
[
1
]
)
{
roots
=
skvx
:
:
shuffle
<
1
0
>
(
roots
)
;
}
roots
.
store
(
T
)
;
return
2
;
}
T
[
0
]
=
roots
[
0
]
;
return
1
;
}
if
(
inside
[
1
]
)
{
T
[
0
]
=
roots
[
1
]
;
return
1
;
}
return
0
;
}
}
