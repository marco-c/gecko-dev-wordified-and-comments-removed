#
ifndef
skgpu_tessellate_Tessellation_DEFINED
#
define
skgpu_tessellate_Tessellation_DEFINED
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
class
SkMatrix
;
class
SkPath
;
struct
SkRect
;
namespace
skgpu
:
:
tess
{
constexpr
static
float
kPrecision
=
4
;
constexpr
static
int
kMaxResolveLevel
=
5
;
constexpr
static
int
kMaxParametricSegments
=
1
<
<
kMaxResolveLevel
;
constexpr
static
int
kMaxParametricSegments_p2
=
kMaxParametricSegments
*
kMaxParametricSegments
;
constexpr
static
int
kMaxParametricSegments_p4
=
kMaxParametricSegments_p2
*
kMaxParametricSegments_p2
;
constexpr
static
float
kMaxSegmentsPerCurve
=
1024
;
constexpr
static
float
kMaxSegmentsPerCurve_p2
=
kMaxSegmentsPerCurve
*
kMaxSegmentsPerCurve
;
constexpr
static
float
kMaxSegmentsPerCurve_p4
=
kMaxSegmentsPerCurve_p2
*
kMaxSegmentsPerCurve_p2
;
SkPath
PreChopPathCurves
(
float
tessellationPrecision
const
SkPath
&
const
SkMatrix
&
const
SkRect
&
viewport
)
;
constexpr
static
int
NumCurveTrianglesAtResolveLevel
(
int
resolveLevel
)
{
return
(
1
<
<
resolveLevel
)
-
1
;
}
enum
class
PatchAttribs
{
kNone
=
0
kJoinControlPoint
=
1
<
<
0
kFanPoint
=
1
<
<
1
kStrokeParams
=
1
<
<
2
kColor
=
1
<
<
3
kPaintDepth
=
1
<
<
4
kExplicitCurveType
=
1
<
<
5
kSsboIndex
=
1
<
<
7
kWideColorIfEnabled
=
1
<
<
6
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
PatchAttribs
)
constexpr
static
float
kCubicCurveType
[
[
maybe_unused
]
]
=
0
;
constexpr
static
float
kConicCurveType
[
[
maybe_unused
]
]
=
1
;
constexpr
static
float
kTriangularConicCurveType
[
[
maybe_unused
]
]
=
2
;
constexpr
size_t
PatchAttribsStride
(
PatchAttribs
attribs
)
{
return
(
attribs
&
PatchAttribs
:
:
kJoinControlPoint
?
sizeof
(
float
)
*
2
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kFanPoint
?
sizeof
(
float
)
*
2
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kStrokeParams
?
sizeof
(
float
)
*
2
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kColor
?
(
attribs
&
PatchAttribs
:
:
kWideColorIfEnabled
?
sizeof
(
float
)
:
sizeof
(
uint8_t
)
)
*
4
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kPaintDepth
?
sizeof
(
float
)
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kExplicitCurveType
?
sizeof
(
float
)
:
0
)
+
(
attribs
&
PatchAttribs
:
:
kSsboIndex
?
(
sizeof
(
int
)
)
:
0
)
;
}
constexpr
size_t
PatchStride
(
PatchAttribs
attribs
)
{
return
4
*
sizeof
(
SkPoint
)
+
PatchAttribsStride
(
attribs
)
;
}
int
FindCubicConvex180Chops
(
const
SkPoint
[
]
float
T
[
2
]
bool
*
areCusps
)
;
inline
bool
ConicHasCusp
(
const
SkPoint
p
[
3
]
)
{
SkVector
a
=
p
[
1
]
-
p
[
0
]
;
SkVector
b
=
p
[
2
]
-
p
[
1
]
;
return
a
.
cross
(
b
)
=
=
0
&
&
a
.
dot
(
b
)
<
0
;
}
inline
float
GetJoinType
(
const
SkStrokeRec
&
stroke
)
{
switch
(
stroke
.
getJoin
(
)
)
{
case
SkPaint
:
:
kRound_Join
:
return
-
1
;
case
SkPaint
:
:
kBevel_Join
:
return
0
;
case
SkPaint
:
:
kMiter_Join
:
SkASSERT
(
stroke
.
getMiter
(
)
>
=
0
)
;
return
stroke
.
getMiter
(
)
;
}
SkUNREACHABLE
;
}
struct
StrokeParams
{
StrokeParams
(
)
=
default
;
StrokeParams
(
float
radius
float
joinType
)
:
fRadius
(
radius
)
fJoinType
(
joinType
)
{
}
StrokeParams
(
const
SkStrokeRec
&
stroke
)
{
this
-
>
set
(
stroke
)
;
}
void
set
(
const
SkStrokeRec
&
stroke
)
{
fRadius
=
stroke
.
getWidth
(
)
*
.
5f
;
fJoinType
=
GetJoinType
(
stroke
)
;
}
float
fRadius
;
float
fJoinType
;
}
;
inline
bool
StrokesHaveEqualParams
(
const
SkStrokeRec
&
a
const
SkStrokeRec
&
b
)
{
return
a
.
getWidth
(
)
=
=
b
.
getWidth
(
)
&
&
a
.
getJoin
(
)
=
=
b
.
getJoin
(
)
&
&
(
a
.
getJoin
(
)
!
=
SkPaint
:
:
kMiter_Join
|
|
a
.
getMiter
(
)
=
=
b
.
getMiter
(
)
)
;
}
constexpr
int
NumFixedEdgesInJoin
(
SkPaint
:
:
Join
joinType
)
{
switch
(
joinType
)
{
case
SkPaint
:
:
kMiter_Join
:
return
4
;
case
SkPaint
:
:
kRound_Join
:
[
[
fallthrough
]
]
;
case
SkPaint
:
:
kBevel_Join
:
return
3
;
}
SkUNREACHABLE
;
}
constexpr
int
NumFixedEdgesInJoin
(
const
StrokeParams
&
strokeParams
)
{
return
strokeParams
.
fJoinType
>
0
.
f
?
4
:
3
;
}
inline
float
CalcNumRadialSegmentsPerRadian
(
float
approxDevStrokeRadius
)
{
float
cosTheta
=
1
.
f
-
(
1
.
f
/
kPrecision
)
/
approxDevStrokeRadius
;
return
.
5f
/
acosf
(
std
:
:
max
(
cosTheta
-
1
.
f
)
)
;
}
}
#
endif
