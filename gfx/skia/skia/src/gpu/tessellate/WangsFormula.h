#
ifndef
skgpu_tessellate_WangsFormula_DEFINED
#
define
skgpu_tessellate_WangsFormula_DEFINED
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
#
define
AI
[
[
maybe_unused
]
]
SK_ALWAYS_INLINE
namespace
skgpu
:
:
wangs_formula
{
template
<
int
Degree
>
constexpr
float
length_term
(
float
precision
)
{
return
(
Degree
*
(
Degree
-
1
)
/
8
.
f
)
*
precision
;
}
template
<
int
Degree
>
constexpr
float
length_term_p2
(
float
precision
)
{
return
(
(
Degree
*
Degree
)
*
(
(
Degree
-
1
)
*
(
Degree
-
1
)
)
/
64
.
f
)
*
(
precision
*
precision
)
;
}
AI
float
root4
(
float
x
)
{
return
sqrtf
(
sqrtf
(
x
)
)
;
}
AI
int
nextlog4
(
float
x
)
{
return
(
sk_float_nextlog2
(
x
)
+
1
)
>
>
1
;
}
AI
int
nextlog16
(
float
x
)
{
return
(
sk_float_nextlog2
(
x
)
+
3
)
>
>
2
;
}
class
VectorXform
{
public
:
AI
VectorXform
(
)
:
fC0
{
1
.
0f
0
.
f
}
fC1
{
0
.
f
1
.
f
}
{
}
AI
explicit
VectorXform
(
const
SkMatrix
&
m
)
{
*
this
=
m
;
}
AI
explicit
VectorXform
(
const
SkM44
&
m
)
{
*
this
=
m
;
}
AI
VectorXform
&
operator
=
(
const
SkMatrix
&
m
)
{
SkASSERT
(
!
m
.
hasPerspective
(
)
)
;
fC0
=
{
m
.
rc
(
0
0
)
m
.
rc
(
1
0
)
}
;
fC1
=
{
m
.
rc
(
0
1
)
m
.
rc
(
1
1
)
}
;
return
*
this
;
}
AI
VectorXform
&
operator
=
(
const
SkM44
&
m
)
{
SkASSERT
(
m
.
rc
(
3
0
)
=
=
0
.
f
&
&
m
.
rc
(
3
1
)
=
=
0
.
f
&
&
m
.
rc
(
3
2
)
=
=
0
.
f
&
&
m
.
rc
(
3
3
)
=
=
1
.
f
)
;
fC0
=
{
m
.
rc
(
0
0
)
m
.
rc
(
1
0
)
}
;
fC1
=
{
m
.
rc
(
0
1
)
m
.
rc
(
1
1
)
}
;
return
*
this
;
}
AI
skvx
:
:
float2
operator
(
)
(
skvx
:
:
float2
vector
)
const
{
return
fC0
*
vector
.
x
(
)
+
fC1
*
vector
.
y
(
)
;
}
AI
skvx
:
:
float4
operator
(
)
(
skvx
:
:
float4
vectors
)
const
{
return
join
(
fC0
*
vectors
.
x
(
)
+
fC1
*
vectors
.
y
(
)
fC0
*
vectors
.
z
(
)
+
fC1
*
vectors
.
w
(
)
)
;
}
private
:
skvx
:
:
float2
fC0
;
skvx
:
:
float2
fC1
;
}
;
AI
float
quadratic_p4
(
float
precision
skvx
:
:
float2
p0
skvx
:
:
float2
p1
skvx
:
:
float2
p2
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
skvx
:
:
float2
v
=
-
2
*
p1
+
p0
+
p2
;
v
=
vectorXform
(
v
)
;
skvx
:
:
float2
vv
=
v
*
v
;
return
(
vv
[
0
]
+
vv
[
1
]
)
*
length_term_p2
<
2
>
(
precision
)
;
}
AI
float
quadratic_p4
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
quadratic_p4
(
precision
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
0
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
1
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
2
]
)
vectorXform
)
;
}
AI
float
quadratic
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
root4
(
quadratic_p4
(
precision
pts
vectorXform
)
)
;
}
AI
int
quadratic_log2
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
nextlog16
(
quadratic_p4
(
precision
pts
vectorXform
)
)
;
}
AI
float
cubic_p4
(
float
precision
skvx
:
:
float2
p0
skvx
:
:
float2
p1
skvx
:
:
float2
p2
skvx
:
:
float2
p3
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
skvx
:
:
float4
p01
{
p0
p1
}
;
skvx
:
:
float4
p12
{
p1
p2
}
;
skvx
:
:
float4
p23
{
p2
p3
}
;
skvx
:
:
float4
v
=
-
2
*
p12
+
p01
+
p23
;
v
=
vectorXform
(
v
)
;
skvx
:
:
float4
vv
=
v
*
v
;
return
std
:
:
max
(
vv
[
0
]
+
vv
[
1
]
vv
[
2
]
+
vv
[
3
]
)
*
length_term_p2
<
3
>
(
precision
)
;
}
AI
float
cubic_p4
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
cubic_p4
(
precision
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
0
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
1
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
2
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
3
]
)
vectorXform
)
;
}
AI
float
cubic
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
root4
(
cubic_p4
(
precision
pts
vectorXform
)
)
;
}
AI
int
cubic_log2
(
float
precision
const
SkPoint
pts
[
]
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
nextlog16
(
cubic_p4
(
precision
pts
vectorXform
)
)
;
}
AI
float
worst_case_cubic_p4
(
float
precision
float
devWidth
float
devHeight
)
{
float
kk
=
length_term_p2
<
3
>
(
precision
)
;
return
4
*
kk
*
(
devWidth
*
devWidth
+
devHeight
*
devHeight
)
;
}
AI
float
worst_case_cubic
(
float
precision
float
devWidth
float
devHeight
)
{
return
root4
(
worst_case_cubic_p4
(
precision
devWidth
devHeight
)
)
;
}
AI
int
worst_case_cubic_log2
(
float
precision
float
devWidth
float
devHeight
)
{
return
nextlog16
(
worst_case_cubic_p4
(
precision
devWidth
devHeight
)
)
;
}
AI
float
conic_p2
(
float
precision
skvx
:
:
float2
p0
skvx
:
:
float2
p1
skvx
:
:
float2
p2
float
w
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
p0
=
vectorXform
(
p0
)
;
p1
=
vectorXform
(
p1
)
;
p2
=
vectorXform
(
p2
)
;
const
skvx
:
:
float2
C
=
0
.
5f
*
(
min
(
min
(
p0
p1
)
p2
)
+
max
(
max
(
p0
p1
)
p2
)
)
;
p0
-
=
C
;
p1
-
=
C
;
p2
-
=
C
;
const
float
max_len
=
sqrtf
(
std
:
:
max
(
dot
(
p0
p0
)
std
:
:
max
(
dot
(
p1
p1
)
dot
(
p2
p2
)
)
)
)
;
const
skvx
:
:
float2
dp
=
-
2
*
w
*
p1
+
p0
+
p2
;
const
float
dw
=
fabsf
(
-
2
*
w
+
2
)
;
const
float
rp_minus_1
=
std
:
:
max
(
0
.
f
max_len
*
precision
-
1
)
;
const
float
numer
=
sqrtf
(
dot
(
dp
dp
)
)
*
precision
+
rp_minus_1
*
dw
;
const
float
denom
=
4
*
std
:
:
min
(
w
1
.
f
)
;
return
numer
/
denom
;
}
AI
float
conic_p2
(
float
precision
const
SkPoint
pts
[
]
float
w
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
conic_p2
(
precision
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
0
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
1
]
)
skvx
:
:
bit_pun
<
skvx
:
:
float2
>
(
pts
[
2
]
)
w
vectorXform
)
;
}
AI
float
conic
(
float
tolerance
const
SkPoint
pts
[
]
float
w
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
sqrtf
(
conic_p2
(
tolerance
pts
w
vectorXform
)
)
;
}
AI
int
conic_log2
(
float
tolerance
const
SkPoint
pts
[
]
float
w
const
VectorXform
&
vectorXform
=
VectorXform
(
)
)
{
return
nextlog4
(
conic_p2
(
tolerance
pts
w
vectorXform
)
)
;
}
}
#
undef
AI
#
endif
