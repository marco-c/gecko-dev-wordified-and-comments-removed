#
ifndef
skgpu_tessellate_CullTest_DEFINED
#
define
skgpu_tessellate_CullTest_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
namespace
skgpu
:
:
tess
{
class
CullTest
{
public
:
CullTest
(
)
=
default
;
CullTest
(
const
SkRect
&
devCullBounds
const
SkMatrix
&
m
)
{
this
-
>
set
(
devCullBounds
m
)
;
}
void
set
(
const
SkRect
&
devCullBounds
const
SkMatrix
&
m
)
{
SkASSERT
(
!
m
.
hasPerspective
(
)
)
;
fMatX
=
{
m
.
getScaleX
(
)
m
.
getSkewY
(
)
-
m
.
getScaleX
(
)
-
m
.
getSkewY
(
)
}
;
fMatY
=
{
m
.
getSkewX
(
)
m
.
getScaleY
(
)
-
m
.
getSkewX
(
)
-
m
.
getScaleY
(
)
}
;
fCullBounds
=
{
devCullBounds
.
fLeft
-
m
.
getTranslateX
(
)
devCullBounds
.
fTop
-
m
.
getTranslateY
(
)
m
.
getTranslateX
(
)
-
devCullBounds
.
fRight
m
.
getTranslateY
(
)
-
devCullBounds
.
fBottom
}
;
}
bool
isVisible
(
SkPoint
p
)
const
{
auto
devPt
=
fMatX
*
p
.
fX
+
fMatY
*
p
.
fY
;
return
all
(
fCullBounds
<
devPt
)
;
}
bool
areVisible3
(
const
SkPoint
p
[
3
]
)
const
{
auto
val0
=
fMatY
*
p
[
0
]
.
fY
;
auto
val1
=
fMatY
*
p
[
1
]
.
fY
;
auto
val2
=
fMatY
*
p
[
2
]
.
fY
;
val0
=
fMatX
*
p
[
0
]
.
fX
+
val0
;
val1
=
fMatX
*
p
[
1
]
.
fX
+
val1
;
val2
=
fMatX
*
p
[
2
]
.
fX
+
val2
;
val0
=
max
(
val0
val1
)
;
val0
=
max
(
val0
val2
)
;
return
all
(
fCullBounds
<
val0
)
;
}
bool
areVisible4
(
const
SkPoint
p
[
4
]
)
const
{
auto
val0
=
fMatY
*
p
[
0
]
.
fY
;
auto
val1
=
fMatY
*
p
[
1
]
.
fY
;
auto
val2
=
fMatY
*
p
[
2
]
.
fY
;
auto
val3
=
fMatY
*
p
[
3
]
.
fY
;
val0
=
fMatX
*
p
[
0
]
.
fX
+
val0
;
val1
=
fMatX
*
p
[
1
]
.
fX
+
val1
;
val2
=
fMatX
*
p
[
2
]
.
fX
+
val2
;
val3
=
fMatX
*
p
[
3
]
.
fX
+
val3
;
val0
=
max
(
val0
val1
)
;
val2
=
max
(
val2
val3
)
;
val0
=
max
(
val0
val2
)
;
return
all
(
fCullBounds
<
val0
)
;
}
private
:
skvx
:
:
float4
fMatX
;
skvx
:
:
float4
fMatY
;
skvx
:
:
float4
fCullBounds
;
}
;
}
#
endif
