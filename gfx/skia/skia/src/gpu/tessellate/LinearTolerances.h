#
ifndef
skgpu_tessellate_LinearTolerances_DEFINED
#
define
skgpu_tessellate_LinearTolerances_DEFINED
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
namespace
skgpu
:
:
tess
{
class
LinearTolerances
{
public
:
float
numParametricSegments_p4
(
)
const
{
return
fNumParametricSegments_p4
;
}
float
numRadialSegmentsPerRadian
(
)
const
{
return
fNumRadialSegmentsPerRadian
;
}
int
numEdgesInJoins
(
)
const
{
return
fEdgesInJoins
;
}
int
requiredResolveLevel
(
)
const
{
return
wangs_formula
:
:
nextlog16
(
fNumParametricSegments_p4
)
;
}
int
requiredStrokeEdges
(
)
const
{
int
maxRadialSegmentsInStroke
=
std
:
:
max
(
SkScalarCeilToInt
(
fNumRadialSegmentsPerRadian
*
SK_ScalarPI
)
1
)
;
int
maxParametricSegmentsInStroke
=
SkScalarCeilToInt
(
wangs_formula
:
:
root4
(
fNumParametricSegments_p4
)
)
;
SkASSERT
(
maxParametricSegmentsInStroke
>
=
1
)
;
int
maxEdgesInStroke
=
maxRadialSegmentsInStroke
+
maxParametricSegmentsInStroke
;
return
fEdgesInJoins
+
maxEdgesInStroke
;
}
void
setParametricSegments
(
float
n4
)
{
SkASSERT
(
n4
>
=
0
.
f
)
;
fNumParametricSegments_p4
=
n4
;
}
void
setStroke
(
const
StrokeParams
&
strokeParams
float
maxScale
)
{
float
approxDeviceStrokeRadius
;
if
(
strokeParams
.
fRadius
=
=
0
.
f
)
{
approxDeviceStrokeRadius
=
0
.
5f
;
}
else
{
approxDeviceStrokeRadius
=
strokeParams
.
fRadius
*
maxScale
;
}
fNumRadialSegmentsPerRadian
=
CalcNumRadialSegmentsPerRadian
(
approxDeviceStrokeRadius
)
;
fEdgesInJoins
=
NumFixedEdgesInJoin
(
strokeParams
)
;
if
(
strokeParams
.
fJoinType
<
0
.
f
&
&
fNumRadialSegmentsPerRadian
>
0
.
f
)
{
fEdgesInJoins
+
=
SkScalarCeilToInt
(
fNumRadialSegmentsPerRadian
*
SK_ScalarPI
)
-
1
;
}
}
void
accumulate
(
const
LinearTolerances
&
tolerances
)
{
if
(
tolerances
.
fNumParametricSegments_p4
>
fNumParametricSegments_p4
)
{
fNumParametricSegments_p4
=
tolerances
.
fNumParametricSegments_p4
;
}
if
(
tolerances
.
fNumRadialSegmentsPerRadian
>
fNumRadialSegmentsPerRadian
)
{
fNumRadialSegmentsPerRadian
=
tolerances
.
fNumRadialSegmentsPerRadian
;
}
if
(
tolerances
.
fEdgesInJoins
>
fEdgesInJoins
)
{
fEdgesInJoins
=
tolerances
.
fEdgesInJoins
;
}
}
private
:
float
fNumParametricSegments_p4
=
1
.
f
;
float
fNumRadialSegmentsPerRadian
=
0
.
f
;
int
fEdgesInJoins
=
0
;
}
;
}
#
endif
