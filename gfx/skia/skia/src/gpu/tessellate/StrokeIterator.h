#
ifndef
skgpu_tessellate_StrokeIterator_DEFINED
#
define
skgpu_tessellate_StrokeIterator_DEFINED
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
<
array
>
namespace
skgpu
:
:
tess
{
class
StrokeIterator
{
public
:
StrokeIterator
(
const
SkPath
&
path
const
SkStrokeRec
*
stroke
const
SkMatrix
*
viewMatrix
)
:
fViewMatrix
(
viewMatrix
)
fStroke
(
stroke
)
{
SkPathPriv
:
:
Iterate
it
(
path
)
;
fIter
=
it
.
begin
(
)
;
fEnd
=
it
.
end
(
)
;
}
enum
class
Verb
{
kLine
=
(
int
)
SkPathVerb
:
:
kLine
kQuad
=
(
int
)
SkPathVerb
:
:
kQuad
kConic
=
(
int
)
SkPathVerb
:
:
kConic
kCubic
=
(
int
)
SkPathVerb
:
:
kCubic
kCircle
kMoveWithinContour
kContourFinished
}
;
constexpr
static
bool
IsVerbGeometric
(
Verb
verb
)
{
return
verb
<
Verb
:
:
kMoveWithinContour
;
}
bool
next
(
)
{
if
(
fQueueCount
)
{
SkASSERT
(
fQueueCount
>
=
2
)
;
this
-
>
popFront
(
)
;
if
(
fQueueCount
>
=
2
)
{
return
true
;
}
SkASSERT
(
fQueueCount
=
=
1
)
;
if
(
this
-
>
atVerb
(
0
)
=
=
Verb
:
:
kContourFinished
)
{
fQueueCount
=
0
;
}
}
for
(
;
fIter
!
=
fEnd
;
+
+
fIter
)
{
SkASSERT
(
fQueueCount
=
=
0
|
|
fQueueCount
=
=
1
)
;
auto
[
verb
pts
w
]
=
*
fIter
;
switch
(
verb
)
{
case
SkPathVerb
:
:
kMove
:
if
(
!
this
-
>
finishOpenContour
(
)
)
{
continue
;
}
break
;
case
SkPathVerb
:
:
kCubic
:
if
(
pts
[
3
]
=
=
pts
[
2
]
)
{
[
[
fallthrough
]
]
;
case
SkPathVerb
:
:
kConic
:
case
SkPathVerb
:
:
kQuad
:
if
(
pts
[
2
]
=
=
pts
[
1
]
)
{
[
[
fallthrough
]
]
;
case
SkPathVerb
:
:
kLine
:
if
(
pts
[
1
]
=
=
pts
[
0
]
)
{
fLastDegenerateStrokePt
=
pts
;
continue
;
}
}
}
this
-
>
enqueue
(
(
Verb
)
verb
pts
w
)
;
if
(
fQueueCount
=
=
1
)
{
fFirstVerbInContour
=
(
Verb
)
verb
;
fFirstPtsInContour
=
pts
;
fFirstWInContour
=
w
;
continue
;
}
break
;
case
SkPathVerb
:
:
kClose
:
if
(
!
fQueueCount
)
{
fLastDegenerateStrokePt
=
pts
;
continue
;
}
if
(
pts
[
0
]
!
=
fFirstPtsInContour
[
0
]
)
{
fClosePts
=
{
pts
[
0
]
fFirstPtsInContour
[
0
]
}
;
this
-
>
enqueue
(
Verb
:
:
kLine
fClosePts
.
data
(
)
nullptr
)
;
}
this
-
>
enqueue
(
fFirstVerbInContour
fFirstPtsInContour
fFirstWInContour
)
;
this
-
>
enqueue
(
Verb
:
:
kContourFinished
nullptr
nullptr
)
;
fLastDegenerateStrokePt
=
nullptr
;
break
;
}
SkASSERT
(
fQueueCount
>
=
2
)
;
+
+
fIter
;
return
true
;
}
return
this
-
>
finishOpenContour
(
)
;
}
Verb
prevVerb
(
)
const
{
return
this
-
>
atVerb
(
0
)
;
}
const
SkPoint
*
prevPts
(
)
const
{
return
this
-
>
atPts
(
0
)
;
}
Verb
verb
(
)
const
{
return
this
-
>
atVerb
(
1
)
;
}
const
SkPoint
*
pts
(
)
const
{
return
this
-
>
atPts
(
1
)
;
}
float
w
(
)
const
{
return
this
-
>
atW
(
1
)
;
}
Verb
firstVerbInContour
(
)
const
{
SkASSERT
(
fQueueCount
>
0
)
;
return
fFirstVerbInContour
;
}
const
SkPoint
*
firstPtsInContour
(
)
const
{
SkASSERT
(
fQueueCount
>
0
)
;
return
fFirstPtsInContour
;
}
private
:
constexpr
static
int
kQueueBufferCount
=
8
;
Verb
atVerb
(
int
i
)
const
{
SkASSERT
(
0
<
=
i
&
&
i
<
fQueueCount
)
;
return
fVerbs
[
(
fQueueFrontIdx
+
i
)
&
(
kQueueBufferCount
-
1
)
]
;
}
Verb
backVerb
(
)
const
{
return
this
-
>
atVerb
(
fQueueCount
-
1
)
;
}
const
SkPoint
*
atPts
(
int
i
)
const
{
SkASSERT
(
0
<
=
i
&
&
i
<
fQueueCount
)
;
return
fPts
[
(
fQueueFrontIdx
+
i
)
&
(
kQueueBufferCount
-
1
)
]
;
}
const
SkPoint
*
backPts
(
)
const
{
return
this
-
>
atPts
(
fQueueCount
-
1
)
;
}
float
atW
(
int
i
)
const
{
SkASSERT
(
0
<
=
i
&
&
i
<
fQueueCount
)
;
const
float
*
w
=
fW
[
(
fQueueFrontIdx
+
i
)
&
(
kQueueBufferCount
-
1
)
]
;
SkASSERT
(
w
)
;
return
*
w
;
}
void
enqueue
(
Verb
verb
const
SkPoint
*
pts
const
float
*
w
)
{
SkASSERT
(
fQueueCount
<
kQueueBufferCount
)
;
int
i
=
(
fQueueFrontIdx
+
fQueueCount
)
&
(
kQueueBufferCount
-
1
)
;
fVerbs
[
i
]
=
verb
;
fPts
[
i
]
=
pts
;
fW
[
i
]
=
w
;
+
+
fQueueCount
;
}
void
popFront
(
)
{
SkASSERT
(
fQueueCount
>
0
)
;
+
+
fQueueFrontIdx
;
-
-
fQueueCount
;
}
bool
finishOpenContour
(
)
{
if
(
fQueueCount
)
{
SkASSERT
(
this
-
>
backVerb
(
)
=
=
Verb
:
:
kLine
|
|
this
-
>
backVerb
(
)
=
=
Verb
:
:
kQuad
|
|
this
-
>
backVerb
(
)
=
=
Verb
:
:
kConic
|
|
this
-
>
backVerb
(
)
=
=
Verb
:
:
kCubic
)
;
switch
(
fStroke
-
>
getCap
(
)
)
{
case
SkPaint
:
:
kButt_Cap
:
this
-
>
enqueue
(
Verb
:
:
kMoveWithinContour
fFirstPtsInContour
fFirstWInContour
)
;
break
;
case
SkPaint
:
:
kRound_Cap
:
{
int
backIdx
=
SkPathPriv
:
:
PtsInIter
(
(
unsigned
)
this
-
>
backVerb
(
)
)
-
1
;
this
-
>
enqueue
(
Verb
:
:
kCircle
this
-
>
backPts
(
)
+
backIdx
nullptr
)
;
this
-
>
enqueue
(
Verb
:
:
kCircle
fFirstPtsInContour
fFirstWInContour
)
;
break
;
}
case
SkPaint
:
:
kSquare_Cap
:
this
-
>
fillSquareCapPoints
(
)
;
this
-
>
enqueue
(
Verb
:
:
kLine
fEndingCapPts
.
data
(
)
nullptr
)
;
this
-
>
enqueue
(
Verb
:
:
kMoveWithinContour
fBeginningCapPts
.
data
(
)
nullptr
)
;
this
-
>
enqueue
(
Verb
:
:
kLine
fBeginningCapPts
.
data
(
)
nullptr
)
;
break
;
}
}
else
if
(
fLastDegenerateStrokePt
)
{
switch
(
fStroke
-
>
getCap
(
)
)
{
case
SkPaint
:
:
kButt_Cap
:
return
false
;
case
SkPaint
:
:
kRound_Cap
:
this
-
>
enqueue
(
Verb
:
:
kCircle
fLastDegenerateStrokePt
nullptr
)
;
fFirstVerbInContour
=
Verb
:
:
kCircle
;
fFirstPtsInContour
=
fLastDegenerateStrokePt
;
fFirstWInContour
=
nullptr
;
break
;
case
SkPaint
:
:
kSquare_Cap
:
{
SkPoint
outset
;
if
(
!
fStroke
-
>
isHairlineStyle
(
)
)
{
outset
=
{
fStroke
-
>
getWidth
(
)
*
.
5f
0
}
;
}
else
{
SkASSERT
(
!
fViewMatrix
-
>
hasPerspective
(
)
)
;
float
a
=
fViewMatrix
-
>
getScaleX
(
)
b
=
fViewMatrix
-
>
getSkewX
(
)
c
=
fViewMatrix
-
>
getSkewY
(
)
d
=
fViewMatrix
-
>
getScaleY
(
)
;
float
det
=
a
*
d
-
b
*
c
;
if
(
det
>
0
)
{
outset
=
SkVector
{
d
-
c
}
*
(
.
5f
/
det
)
;
}
else
{
outset
=
{
1
0
}
;
}
}
fEndingCapPts
=
{
*
fLastDegenerateStrokePt
-
outset
*
fLastDegenerateStrokePt
+
outset
}
;
this
-
>
enqueue
(
Verb
:
:
kLine
fEndingCapPts
.
data
(
)
nullptr
)
;
this
-
>
enqueue
(
Verb
:
:
kMoveWithinContour
fEndingCapPts
.
data
(
)
nullptr
)
;
fFirstVerbInContour
=
Verb
:
:
kLine
;
fFirstPtsInContour
=
fEndingCapPts
.
data
(
)
;
fFirstWInContour
=
nullptr
;
break
;
}
}
}
else
{
return
false
;
}
this
-
>
enqueue
(
fFirstVerbInContour
fFirstPtsInContour
fFirstWInContour
)
;
this
-
>
enqueue
(
Verb
:
:
kContourFinished
nullptr
nullptr
)
;
fLastDegenerateStrokePt
=
nullptr
;
return
true
;
}
void
fillSquareCapPoints
(
)
{
SkVector
lastTangent
;
const
SkPoint
*
lastPts
=
this
-
>
backPts
(
)
;
Verb
lastVerb
=
this
-
>
backVerb
(
)
;
switch
(
lastVerb
)
{
case
Verb
:
:
kCubic
:
lastTangent
=
lastPts
[
3
]
-
lastPts
[
2
]
;
if
(
!
lastTangent
.
isZero
(
)
)
{
break
;
}
[
[
fallthrough
]
]
;
case
Verb
:
:
kConic
:
case
Verb
:
:
kQuad
:
lastTangent
=
lastPts
[
2
]
-
lastPts
[
1
]
;
if
(
!
lastTangent
.
isZero
(
)
)
{
break
;
}
[
[
fallthrough
]
]
;
case
Verb
:
:
kLine
:
lastTangent
=
lastPts
[
1
]
-
lastPts
[
0
]
;
SkASSERT
(
!
lastTangent
.
isZero
(
)
)
;
break
;
default
:
SkUNREACHABLE
;
}
if
(
!
fStroke
-
>
isHairlineStyle
(
)
)
{
lastTangent
*
=
(
.
5f
*
fStroke
-
>
getWidth
(
)
)
/
lastTangent
.
length
(
)
;
}
else
{
lastTangent
*
=
.
5f
/
fViewMatrix
-
>
mapVector
(
lastTangent
.
fX
lastTangent
.
fY
)
.
length
(
)
;
}
SkPoint
lastPoint
=
lastPts
[
SkPathPriv
:
:
PtsInIter
(
(
unsigned
)
lastVerb
)
-
1
]
;
fEndingCapPts
=
{
lastPoint
lastPoint
+
lastTangent
}
;
SkVector
firstTangent
=
fFirstPtsInContour
[
1
]
-
fFirstPtsInContour
[
0
]
;
if
(
firstTangent
.
isZero
(
)
)
{
SkASSERT
(
fFirstVerbInContour
=
=
Verb
:
:
kQuad
|
|
fFirstVerbInContour
=
=
Verb
:
:
kConic
|
|
fFirstVerbInContour
=
=
Verb
:
:
kCubic
)
;
firstTangent
=
fFirstPtsInContour
[
2
]
-
fFirstPtsInContour
[
0
]
;
if
(
firstTangent
.
isZero
(
)
)
{
SkASSERT
(
fFirstVerbInContour
=
=
Verb
:
:
kCubic
)
;
firstTangent
=
fFirstPtsInContour
[
3
]
-
fFirstPtsInContour
[
0
]
;
SkASSERT
(
!
firstTangent
.
isZero
(
)
)
;
}
}
if
(
!
fStroke
-
>
isHairlineStyle
(
)
)
{
firstTangent
*
=
(
-
.
5f
*
fStroke
-
>
getWidth
(
)
)
/
firstTangent
.
length
(
)
;
}
else
{
firstTangent
*
=
-
.
5f
/
fViewMatrix
-
>
mapVector
(
firstTangent
.
fX
firstTangent
.
fY
)
.
length
(
)
;
}
fBeginningCapPts
=
{
fFirstPtsInContour
[
0
]
+
firstTangent
fFirstPtsInContour
[
0
]
}
;
}
const
SkMatrix
*
const
fViewMatrix
;
const
SkStrokeRec
*
const
fStroke
;
SkPathPriv
:
:
RangeIter
fIter
;
SkPathPriv
:
:
RangeIter
fEnd
;
Verb
fFirstVerbInContour
;
const
SkPoint
*
fFirstPtsInContour
;
const
float
*
fFirstWInContour
;
const
SkPoint
*
fLastDegenerateStrokePt
=
nullptr
;
Verb
fVerbs
[
kQueueBufferCount
]
;
const
SkPoint
*
fPts
[
kQueueBufferCount
]
;
const
float
*
fW
[
kQueueBufferCount
]
;
int
fQueueFrontIdx
=
0
;
int
fQueueCount
=
0
;
std
:
:
array
<
SkPoint
2
>
fClosePts
;
std
:
:
array
<
SkPoint
2
>
fEndingCapPts
;
std
:
:
array
<
SkPoint
2
>
fBeginningCapPts
;
}
;
}
#
endif
