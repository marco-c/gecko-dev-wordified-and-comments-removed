#
ifndef
skgpu_tessellate_MidpointContourParser_DEFINED
#
define
skgpu_tessellate_MidpointContourParser_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
namespace
skgpu
:
:
tess
{
class
MidpointContourParser
{
public
:
MidpointContourParser
(
const
SkPath
&
path
)
:
fPath
(
path
)
fVerbs
(
SkPathPriv
:
:
VerbData
(
fPath
)
)
fNumRemainingVerbs
(
fPath
.
countVerbs
(
)
)
fPoints
(
SkPathPriv
:
:
PointData
(
fPath
)
)
fWeights
(
SkPathPriv
:
:
ConicWeightData
(
fPath
)
)
{
}
bool
parseNextContour
(
)
{
bool
hasGeometry
=
false
;
for
(
;
fVerbsIdx
<
fNumRemainingVerbs
;
+
+
fVerbsIdx
)
{
switch
(
fVerbs
[
fVerbsIdx
]
)
{
case
SkPath
:
:
kMove_Verb
:
if
(
!
hasGeometry
)
{
fMidpoint
=
{
0
0
}
;
fMidpointWeight
=
0
;
this
-
>
advance
(
)
;
fPtsIdx
=
1
;
continue
;
}
if
(
fPoints
[
0
]
!
=
fPoints
[
fPtsIdx
-
1
]
)
{
fMidpoint
+
=
fPoints
[
0
]
;
+
+
fMidpointWeight
;
}
return
true
;
default
:
continue
;
case
SkPath
:
:
kLine_Verb
:
+
+
fPtsIdx
;
break
;
case
SkPath
:
:
kConic_Verb
:
+
+
fWtsIdx
;
[
[
fallthrough
]
]
;
case
SkPath
:
:
kQuad_Verb
:
fPtsIdx
+
=
2
;
break
;
case
SkPath
:
:
kCubic_Verb
:
fPtsIdx
+
=
3
;
break
;
}
fMidpoint
+
=
fPoints
[
fPtsIdx
-
1
]
;
+
+
fMidpointWeight
;
hasGeometry
=
true
;
}
if
(
hasGeometry
&
&
fPoints
[
0
]
!
=
fPoints
[
fPtsIdx
-
1
]
)
{
fMidpoint
+
=
fPoints
[
0
]
;
+
+
fMidpointWeight
;
}
return
hasGeometry
;
}
SkPathPriv
:
:
Iterate
currentContour
(
)
{
return
SkPathPriv
:
:
Iterate
(
fVerbs
fVerbs
+
fVerbsIdx
fPoints
fWeights
)
;
}
SkPoint
currentMidpoint
(
)
{
return
fMidpoint
*
(
1
.
f
/
fMidpointWeight
)
;
}
private
:
void
advance
(
)
{
fVerbs
+
=
fVerbsIdx
;
fNumRemainingVerbs
-
=
fVerbsIdx
;
fVerbsIdx
=
0
;
fPoints
+
=
fPtsIdx
;
fPtsIdx
=
0
;
fWeights
+
=
fWtsIdx
;
fWtsIdx
=
0
;
}
const
SkPath
&
fPath
;
const
uint8_t
*
fVerbs
;
int
fNumRemainingVerbs
=
0
;
int
fVerbsIdx
=
0
;
const
SkPoint
*
fPoints
;
int
fPtsIdx
=
0
;
const
float
*
fWeights
;
int
fWtsIdx
=
0
;
SkPoint
fMidpoint
;
int
fMidpointWeight
;
}
;
}
#
endif
