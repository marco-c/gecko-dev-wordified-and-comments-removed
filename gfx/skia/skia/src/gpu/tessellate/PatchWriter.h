#
ifndef
skgpu_tessellate_PatchWriter_DEFINED
#
define
skgpu_tessellate_PatchWriter_DEFINED
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
LinearTolerances
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
MiddleOutPolygonTriangulator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
#
include
<
type_traits
>
#
include
<
variant
>
namespace
skgpu
:
:
tess
{
template
<
PatchAttribs
A
>
struct
Required
{
}
;
template
<
PatchAttribs
A
>
struct
Optional
{
}
;
struct
TrackJoinControlPoints
{
}
;
struct
AddTrianglesWhenChopping
{
}
;
struct
DiscardFlatCurves
{
}
;
struct
ReplicateLineEndPoints
{
}
;
template
<
PatchAttribs
A
typename
T
bool
Required
bool
Optional
>
struct
AttribValue
{
using
DataType
=
std
:
:
conditional_t
<
Required
T
std
:
:
conditional_t
<
Optional
std
:
:
pair
<
T
bool
>
std
:
:
monostate
>
>
;
static
constexpr
bool
kEnabled
=
Required
|
|
Optional
;
explicit
AttribValue
(
PatchAttribs
attribs
)
:
AttribValue
(
attribs
{
}
)
{
}
AttribValue
(
PatchAttribs
attribs
const
T
&
t
)
{
(
void
)
attribs
;
if
constexpr
(
Required
)
{
SkASSERT
(
attribs
&
A
)
;
}
else
if
constexpr
(
Optional
)
{
std
:
:
get
<
1
>
(
fV
)
=
attribs
&
A
;
}
else
{
SkASSERT
(
!
(
attribs
&
A
)
)
;
}
*
this
=
t
;
}
AttribValue
&
operator
=
(
const
T
&
v
)
{
if
constexpr
(
Required
)
{
fV
=
v
;
}
else
if
constexpr
(
Optional
)
{
std
:
:
get
<
0
>
(
fV
)
=
v
;
}
return
*
this
;
}
DataType
fV
;
}
;
template
<
PatchAttribs
A
typename
T
bool
Required
bool
Optional
>
VertexWriter
&
operator
<
<
(
VertexWriter
&
w
const
AttribValue
<
A
T
Required
Optional
>
&
v
)
{
if
constexpr
(
Required
)
{
w
<
<
v
.
fV
;
}
else
if
constexpr
(
Optional
)
{
if
(
std
:
:
get
<
1
>
(
v
.
fV
)
)
{
w
<
<
std
:
:
get
<
0
>
(
v
.
fV
)
;
}
}
return
w
;
}
template
<
size_t
Stride
>
struct
PatchStorage
{
float
fN_p4
=
-
1
.
f
;
bool
fMustDefer
=
true
;
char
fData
[
Stride
]
;
bool
hasPending
(
)
const
{
return
fN_p4
>
=
0
.
f
;
}
void
reset
(
)
{
fN_p4
=
-
1
.
f
;
fMustDefer
=
true
;
}
}
;
struct
NullTriangulator
{
NullTriangulator
(
int
SkPoint
)
{
}
}
;
#
define
AI
SK_ALWAYS_INLINE
#
define
ENABLE_IF
(
cond
)
template
<
typename
Void
=
void
>
std
:
:
enable_if_t
<
cond
Void
>
template
<
typename
PatchAllocator
typename
.
.
.
Traits
>
class
PatchWriter
{
template
<
typename
F
>
struct
has_trait
:
std
:
:
disjunction
<
std
:
:
is_same
<
F
Traits
>
.
.
.
>
{
}
;
template
<
PatchAttribs
A
>
using
req_attrib
=
has_trait
<
Required
<
A
>
>
;
template
<
PatchAttribs
A
>
using
opt_attrib
=
has_trait
<
Optional
<
A
>
>
;
static
constexpr
bool
kTrackJoinControlPoints
=
has_trait
<
TrackJoinControlPoints
>
:
:
value
;
static
constexpr
bool
kAddTrianglesWhenChopping
=
has_trait
<
AddTrianglesWhenChopping
>
:
:
value
;
static
constexpr
bool
kDiscardFlatCurves
=
has_trait
<
DiscardFlatCurves
>
:
:
value
;
static
constexpr
bool
kReplicateLineEndPoints
=
has_trait
<
ReplicateLineEndPoints
>
:
:
value
;
template
<
PatchAttribs
A
typename
T
bool
Req
bool
Opt
>
using
attrib_t
=
AttribValue
<
A
T
Req
Opt
>
;
#
define
DEF_ATTRIB_TYPE
(
name
A
T
)
\
static
constexpr
bool
kRequire
#
#
name
=
req_attrib
<
A
>
:
:
value
;
\
static
constexpr
bool
kOptional
#
#
name
=
opt_attrib
<
A
>
:
:
value
;
\
using
name
=
attrib_t
<
A
T
kRequire
#
#
name
kOptional
#
#
name
>
DEF_ATTRIB_TYPE
(
JoinAttrib
PatchAttribs
:
:
kJoinControlPoint
SkPoint
)
;
DEF_ATTRIB_TYPE
(
FanPointAttrib
PatchAttribs
:
:
kFanPoint
SkPoint
)
;
DEF_ATTRIB_TYPE
(
StrokeAttrib
PatchAttribs
:
:
kStrokeParams
StrokeParams
)
;
static
constexpr
bool
kRequireWideColor
=
req_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
;
static
constexpr
bool
kOptionalWideColor
=
opt_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
;
using
Color
=
std
:
:
conditional_t
<
kRequireWideColor
SkPMColor4f
std
:
:
conditional_t
<
kOptionalWideColor
VertexColor
uint32_t
>
>
;
DEF_ATTRIB_TYPE
(
ColorAttrib
PatchAttribs
:
:
kColor
Color
)
;
DEF_ATTRIB_TYPE
(
DepthAttrib
PatchAttribs
:
:
kPaintDepth
float
)
;
DEF_ATTRIB_TYPE
(
CurveTypeAttrib
PatchAttribs
:
:
kExplicitCurveType
float
)
;
DEF_ATTRIB_TYPE
(
SsboIndexAttrib
PatchAttribs
:
:
kSsboIndex
int
)
;
#
undef
DEF_ATTRIB_TYPE
static
constexpr
size_t
kMaxStride
=
4
*
sizeof
(
SkPoint
)
+
(
JoinAttrib
:
:
kEnabled
?
sizeof
(
SkPoint
)
:
0
)
+
(
FanPointAttrib
:
:
kEnabled
?
sizeof
(
SkPoint
)
:
0
)
+
(
StrokeAttrib
:
:
kEnabled
?
sizeof
(
StrokeParams
)
:
0
)
+
(
ColorAttrib
:
:
kEnabled
?
std
:
:
min
(
sizeof
(
Color
)
sizeof
(
SkPMColor4f
)
)
:
0
)
+
(
DepthAttrib
:
:
kEnabled
?
sizeof
(
float
)
:
0
)
+
(
CurveTypeAttrib
:
:
kEnabled
?
sizeof
(
float
)
:
0
)
+
(
SsboIndexAttrib
:
:
kEnabled
?
sizeof
(
int
)
:
0
)
;
using
DeferredPatch
=
std
:
:
conditional_t
<
kTrackJoinControlPoints
PatchStorage
<
kMaxStride
>
std
:
:
monostate
>
;
using
InnerTriangulator
=
std
:
:
conditional_t
<
kAddTrianglesWhenChopping
MiddleOutPolygonTriangulator
NullTriangulator
>
;
using
float2
=
skvx
:
:
float2
;
using
float4
=
skvx
:
:
float4
;
static_assert
(
!
kTrackJoinControlPoints
|
|
req_attrib
<
PatchAttribs
:
:
kJoinControlPoint
>
:
:
value
"
Deferred
patches
and
auto
-
updating
joins
requires
kJoinControlPoint
attrib
"
)
;
public
:
template
<
typename
.
.
.
Args
>
PatchWriter
(
PatchAttribs
attribs
Args
&
&
.
.
.
allocArgs
)
:
fAttribs
(
attribs
)
fPatchAllocator
(
PatchStride
(
attribs
)
std
:
:
forward
<
Args
>
(
allocArgs
)
.
.
.
)
fJoin
(
attribs
)
fFanPoint
(
attribs
)
fStrokeParams
(
attribs
)
fColor
(
attribs
)
fDepth
(
attribs
)
fSsboIndex
(
attribs
)
{
SkDEBUGCODE
(
(
void
)
CurveTypeAttrib
(
attribs
)
;
)
if
constexpr
(
req_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
)
{
SkASSERT
(
attribs
&
PatchAttribs
:
:
kWideColorIfEnabled
)
;
}
else
if
constexpr
(
!
opt_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
)
{
SkASSERT
(
!
(
attribs
&
PatchAttribs
:
:
kWideColorIfEnabled
)
)
;
}
}
~
PatchWriter
(
)
{
if
constexpr
(
kTrackJoinControlPoints
)
{
this
-
>
writeDeferredStrokePatch
(
)
;
}
}
PatchAttribs
attribs
(
)
const
{
return
fAttribs
;
}
void
setShaderTransform
(
const
wangs_formula
:
:
VectorXform
&
xform
float
maxScale
=
1
.
f
)
{
fApproxTransform
=
xform
;
fMaxScale
=
maxScale
;
}
ENABLE_IF
(
kTrackJoinControlPoints
)
writeDeferredStrokePatch
(
)
{
if
(
fDeferredPatch
.
hasPending
(
)
)
{
SkASSERT
(
!
fDeferredPatch
.
fMustDefer
)
;
memcpy
(
SkTAddOffset
<
void
>
(
fDeferredPatch
.
fData
4
*
sizeof
(
SkPoint
)
)
&
fJoin
sizeof
(
SkPoint
)
)
;
fTolerances
.
setParametricSegments
(
fDeferredPatch
.
fN_p4
)
;
if
(
VertexWriter
vw
=
fPatchAllocator
.
append
(
fTolerances
)
)
{
vw
<
<
VertexWriter
:
:
Array
<
char
>
(
fDeferredPatch
.
fData
PatchStride
(
fAttribs
)
)
;
}
}
fDeferredPatch
.
reset
(
)
;
}
ENABLE_IF
(
JoinAttrib
:
:
kEnabled
)
updateJoinControlPointAttrib
(
SkPoint
lastControlPoint
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kJoinControlPoint
)
;
fJoin
=
lastControlPoint
;
if
constexpr
(
kTrackJoinControlPoints
)
{
fDeferredPatch
.
fMustDefer
=
false
;
}
}
ENABLE_IF
(
FanPointAttrib
:
:
kEnabled
)
updateFanPointAttrib
(
SkPoint
fanPoint
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kFanPoint
)
;
fFanPoint
=
fanPoint
;
}
ENABLE_IF
(
StrokeAttrib
:
:
kEnabled
)
updateStrokeParamsAttrib
(
StrokeParams
strokeParams
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kStrokeParams
)
;
fStrokeParams
=
strokeParams
;
fTolerances
.
setStroke
(
strokeParams
fMaxScale
)
;
}
ENABLE_IF
(
StrokeAttrib
:
:
kEnabled
)
updateUniformStrokeParams
(
StrokeParams
strokeParams
)
{
SkASSERT
(
!
(
fAttribs
&
PatchAttribs
:
:
kStrokeParams
)
)
;
fTolerances
.
setStroke
(
strokeParams
fMaxScale
)
;
}
ENABLE_IF
(
ColorAttrib
:
:
kEnabled
)
updateColorAttrib
(
const
SkPMColor4f
&
color
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kColor
)
;
if
constexpr
(
req_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
)
{
fColor
=
color
;
}
else
if
constexpr
(
opt_attrib
<
PatchAttribs
:
:
kWideColorIfEnabled
>
:
:
value
)
{
fColor
=
VertexColor
(
color
fAttribs
&
PatchAttribs
:
:
kWideColorIfEnabled
)
;
}
else
{
fColor
=
color
.
toBytes_RGBA
(
)
;
}
}
ENABLE_IF
(
DepthAttrib
:
:
kEnabled
)
updatePaintDepthAttrib
(
float
depth
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kPaintDepth
)
;
fDepth
=
depth
;
}
ENABLE_IF
(
SsboIndexAttrib
:
:
kEnabled
)
updateSsboIndexAttrib
(
int
ssboIndex
)
{
SkASSERT
(
fAttribs
&
PatchAttribs
:
:
kSsboIndex
)
;
fSsboIndex
=
ssboIndex
;
}
AI
void
writeCubic
(
float2
p0
float2
p1
float2
p2
float2
p3
)
{
float
n4
=
wangs_formula
:
:
cubic_p4
(
kPrecision
p0
p1
p2
p3
fApproxTransform
)
;
if
constexpr
(
kDiscardFlatCurves
)
{
if
(
n4
<
=
1
.
f
)
{
return
;
}
}
if
(
int
numPatches
=
this
-
>
accountForCurve
(
n4
)
)
{
this
-
>
chopAndWriteCubics
(
p0
p1
p2
p3
numPatches
)
;
}
else
{
this
-
>
writeCubicPatch
(
p0
p1
p2
p3
)
;
}
}
AI
void
writeCubic
(
const
SkPoint
pts
[
4
]
)
{
float4
p0p1
=
float4
:
:
Load
(
pts
)
;
float4
p2p3
=
float4
:
:
Load
(
pts
+
2
)
;
this
-
>
writeCubic
(
p0p1
.
lo
p0p1
.
hi
p2p3
.
lo
p2p3
.
hi
)
;
}
AI
void
writeConic
(
float2
p0
float2
p1
float2
p2
float
w
)
{
float
n2
=
wangs_formula
:
:
conic_p2
(
kPrecision
p0
p1
p2
w
fApproxTransform
)
;
if
constexpr
(
kDiscardFlatCurves
)
{
if
(
n2
<
=
1
.
f
)
{
return
;
}
}
if
(
int
numPatches
=
this
-
>
accountForCurve
(
n2
*
n2
)
)
{
this
-
>
chopAndWriteConics
(
p0
p1
p2
w
numPatches
)
;
}
else
{
this
-
>
writeConicPatch
(
p0
p1
p2
w
)
;
}
}
AI
void
writeConic
(
const
SkPoint
pts
[
3
]
float
w
)
{
this
-
>
writeConic
(
skvx
:
:
bit_pun
<
float2
>
(
pts
[
0
]
)
skvx
:
:
bit_pun
<
float2
>
(
pts
[
1
]
)
skvx
:
:
bit_pun
<
float2
>
(
pts
[
2
]
)
w
)
;
}
AI
void
writeQuadratic
(
float2
p0
float2
p1
float2
p2
)
{
float
n4
=
wangs_formula
:
:
quadratic_p4
(
kPrecision
p0
p1
p2
fApproxTransform
)
;
if
constexpr
(
kDiscardFlatCurves
)
{
if
(
n4
<
=
1
.
f
)
{
return
;
}
}
if
(
int
numPatches
=
this
-
>
accountForCurve
(
n4
)
)
{
this
-
>
chopAndWriteQuads
(
p0
p1
p2
numPatches
)
;
}
else
{
this
-
>
writeQuadPatch
(
p0
p1
p2
)
;
}
}
AI
void
writeQuadratic
(
const
SkPoint
pts
[
3
]
)
{
this
-
>
writeQuadratic
(
skvx
:
:
bit_pun
<
float2
>
(
pts
[
0
]
)
skvx
:
:
bit_pun
<
float2
>
(
pts
[
1
]
)
skvx
:
:
bit_pun
<
float2
>
(
pts
[
2
]
)
)
;
}
AI
void
writeLine
(
float4
p0p1
)
{
fTolerances
.
setParametricSegments
(
1
.
f
)
;
if
constexpr
(
kReplicateLineEndPoints
)
{
this
-
>
writeCubicPatch
(
p0p1
.
lo
p0p1
.
lo
p0p1
.
hi
p0p1
.
hi
)
;
}
else
{
this
-
>
writeCubicPatch
(
p0p1
.
lo
(
p0p1
.
zwxy
(
)
-
p0p1
)
*
(
1
/
3
.
f
)
+
p0p1
p0p1
.
hi
)
;
}
}
AI
void
writeLine
(
float2
p0
float2
p1
)
{
this
-
>
writeLine
(
{
p0
p1
}
)
;
}
AI
void
writeLine
(
SkPoint
p0
SkPoint
p1
)
{
this
-
>
writeLine
(
skvx
:
:
bit_pun
<
float2
>
(
p0
)
skvx
:
:
bit_pun
<
float2
>
(
p1
)
)
;
}
AI
void
writeTriangle
(
float2
p0
float2
p1
float2
p2
)
{
static
constexpr
float
kTriangleSegments_p4
=
2
.
f
*
2
.
f
*
2
.
f
*
2
.
f
;
fTolerances
.
setParametricSegments
(
kTriangleSegments_p4
)
;
this
-
>
writePatch
(
p0
p1
p2
{
SK_FloatInfinity
SK_FloatInfinity
}
kTriangularConicCurveType
)
;
}
AI
void
writeTriangle
(
SkPoint
p0
SkPoint
p1
SkPoint
p2
)
{
this
-
>
writeTriangle
(
skvx
:
:
bit_pun
<
float2
>
(
p0
)
skvx
:
:
bit_pun
<
float2
>
(
p1
)
skvx
:
:
bit_pun
<
float2
>
(
p2
)
)
;
}
AI
void
writeCircle
(
SkPoint
p
)
{
fTolerances
.
setParametricSegments
(
0
.
f
)
;
if
(
VertexWriter
vw
=
fPatchAllocator
.
append
(
fTolerances
)
)
{
vw
<
<
VertexWriter
:
:
Repeat
<
4
>
(
p
)
;
this
-
>
emitPatchAttribs
(
std
:
:
move
(
vw
)
{
fAttribs
p
}
kCubicCurveType
)
;
}
}
private
:
AI
void
emitPatchAttribs
(
VertexWriter
vertexWriter
const
JoinAttrib
&
join
float
explicitCurveType
)
{
vertexWriter
<
<
join
<
<
fFanPoint
<
<
fStrokeParams
<
<
fColor
<
<
fDepth
<
<
CurveTypeAttrib
{
fAttribs
explicitCurveType
}
<
<
fSsboIndex
;
}
AI
VertexWriter
appendPatch
(
)
{
if
constexpr
(
kTrackJoinControlPoints
)
{
if
(
fDeferredPatch
.
fMustDefer
)
{
SkASSERT
(
!
fDeferredPatch
.
hasPending
(
)
)
;
SkASSERT
(
PatchStride
(
fAttribs
)
<
=
kMaxStride
)
;
fDeferredPatch
.
fN_p4
=
fTolerances
.
numParametricSegments_p4
(
)
;
return
{
fDeferredPatch
.
fData
PatchStride
(
fAttribs
)
}
;
}
}
return
fPatchAllocator
.
append
(
fTolerances
)
;
}
AI
void
writePatch
(
float2
p0
float2
p1
float2
p2
float2
p3
float
explicitCurveType
)
{
if
(
VertexWriter
vw
=
this
-
>
appendPatch
(
)
)
{
vw
<
<
p0
<
<
p1
<
<
p2
<
<
p3
;
this
-
>
emitPatchAttribs
(
std
:
:
move
(
vw
)
fJoin
explicitCurveType
)
;
if
constexpr
(
kTrackJoinControlPoints
)
{
if
(
explicitCurveType
=
=
kCubicCurveType
&
&
any
(
p3
!
=
p2
)
)
{
p2
.
store
(
&
fJoin
)
;
}
else
if
(
any
(
p2
!
=
p1
)
)
{
p1
.
store
(
&
fJoin
)
;
}
else
{
p0
.
store
(
&
fJoin
)
;
}
fDeferredPatch
.
fMustDefer
=
false
;
}
}
}
AI
void
writeCubicPatch
(
float2
p0
float2
p1
float2
p2
float2
p3
)
{
this
-
>
writePatch
(
p0
p1
p2
p3
kCubicCurveType
)
;
}
AI
void
writeCubicPatch
(
float2
p0
float4
p1p2
float2
p3
)
{
this
-
>
writeCubicPatch
(
p0
p1p2
.
lo
p1p2
.
hi
p3
)
;
}
AI
void
writeQuadPatch
(
float2
p0
float2
p1
float2
p2
)
{
this
-
>
writeCubicPatch
(
p0
mix
(
float4
(
p0
p2
)
p1
.
xyxy
(
)
2
/
3
.
f
)
p2
)
;
}
AI
void
writeConicPatch
(
float2
p0
float2
p1
float2
p2
float
w
)
{
this
-
>
writePatch
(
p0
p1
p2
{
w
SK_FloatInfinity
}
kConicCurveType
)
;
}
int
accountForCurve
(
float
n4
)
{
if
(
n4
<
=
kMaxParametricSegments_p4
)
{
fTolerances
.
setParametricSegments
(
n4
)
;
return
0
;
}
else
{
fTolerances
.
setParametricSegments
(
kMaxParametricSegments_p4
)
;
return
SkScalarCeilToInt
(
wangs_formula
:
:
root4
(
std
:
:
min
(
n4
kMaxSegmentsPerCurve_p4
)
/
kMaxParametricSegments_p4
)
)
;
}
}
static
AI
float4
mix
(
float4
a
float4
b
float4
T
)
{
SkASSERT
(
all
(
(
0
<
=
T
)
&
(
T
<
1
)
)
)
;
return
(
b
-
a
)
*
T
+
a
;
}
void
chopAndWriteQuads
(
float2
p0
float2
p1
float2
p2
int
numPatches
)
{
InnerTriangulator
triangulator
(
numPatches
skvx
:
:
bit_pun
<
SkPoint
>
(
p0
)
)
;
for
(
;
numPatches
>
=
3
;
numPatches
-
=
2
)
{
float4
T
=
float4
(
1
1
2
2
)
/
numPatches
;
float4
ab
=
mix
(
p0
.
xyxy
(
)
p1
.
xyxy
(
)
T
)
;
float4
bc
=
mix
(
p1
.
xyxy
(
)
p2
.
xyxy
(
)
T
)
;
float4
abc
=
mix
(
ab
bc
T
)
;
float4
middle
=
mix
(
ab
bc
mix
(
T
T
.
zwxy
(
)
2
/
3
.
f
)
)
;
this
-
>
writeQuadPatch
(
p0
ab
.
lo
abc
.
lo
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangle
(
p0
abc
.
lo
abc
.
hi
)
;
}
this
-
>
writeCubicPatch
(
abc
.
lo
middle
abc
.
hi
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
abc
.
hi
)
)
)
;
}
std
:
:
tie
(
p0
p1
)
=
{
abc
.
hi
bc
.
hi
}
;
}
if
(
numPatches
=
=
2
)
{
float2
ab
=
(
p0
+
p1
)
*
.
5f
;
float2
bc
=
(
p1
+
p2
)
*
.
5f
;
float2
abc
=
(
ab
+
bc
)
*
.
5f
;
this
-
>
writeQuadPatch
(
p0
ab
abc
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangle
(
p0
abc
p2
)
;
}
this
-
>
writeQuadPatch
(
abc
bc
p2
)
;
}
else
{
SkASSERT
(
numPatches
=
=
1
)
;
this
-
>
writeQuadPatch
(
p0
p1
p2
)
;
}
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
p2
)
)
)
;
this
-
>
writeTriangleStack
(
triangulator
.
close
(
)
)
;
}
}
void
chopAndWriteConics
(
float2
p0
float2
p1
float2
p2
float
w
int
numPatches
)
{
InnerTriangulator
triangulator
(
numPatches
skvx
:
:
bit_pun
<
SkPoint
>
(
p0
)
)
;
float4
h0
=
float4
(
p0
1
1
)
;
float4
h1
=
float4
(
p1
1
1
)
*
w
;
float4
h2
=
float4
(
p2
1
1
)
;
for
(
;
numPatches
>
=
2
;
-
-
numPatches
)
{
float
T
=
1
.
f
/
numPatches
;
float4
ab
=
mix
(
h0
h1
T
)
;
float4
bc
=
mix
(
h1
h2
T
)
;
float4
abc
=
mix
(
ab
bc
T
)
;
float2
midpoint
=
abc
.
xy
(
)
/
abc
.
w
(
)
;
this
-
>
writeConicPatch
(
h0
.
xy
(
)
/
h0
.
w
(
)
ab
.
xy
(
)
/
ab
.
w
(
)
midpoint
ab
.
w
(
)
/
sqrtf
(
h0
.
w
(
)
*
abc
.
w
(
)
)
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
midpoint
)
)
)
;
}
std
:
:
tie
(
h0
h1
)
=
{
abc
bc
}
;
}
SkASSERT
(
numPatches
=
=
1
)
;
this
-
>
writeConicPatch
(
h0
.
xy
(
)
/
h0
.
w
(
)
h1
.
xy
(
)
/
h1
.
w
(
)
h2
.
xy
(
)
h1
.
w
(
)
/
sqrtf
(
h0
.
w
(
)
)
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
h2
.
xy
(
)
)
)
)
;
this
-
>
writeTriangleStack
(
triangulator
.
close
(
)
)
;
}
}
void
chopAndWriteCubics
(
float2
p0
float2
p1
float2
p2
float2
p3
int
numPatches
)
{
InnerTriangulator
triangulator
(
numPatches
skvx
:
:
bit_pun
<
SkPoint
>
(
p0
)
)
;
for
(
;
numPatches
>
=
3
;
numPatches
-
=
2
)
{
float4
T
=
float4
(
1
1
2
2
)
/
numPatches
;
float4
ab
=
mix
(
p0
.
xyxy
(
)
p1
.
xyxy
(
)
T
)
;
float4
bc
=
mix
(
p1
.
xyxy
(
)
p2
.
xyxy
(
)
T
)
;
float4
cd
=
mix
(
p2
.
xyxy
(
)
p3
.
xyxy
(
)
T
)
;
float4
abc
=
mix
(
ab
bc
T
)
;
float4
bcd
=
mix
(
bc
cd
T
)
;
float4
abcd
=
mix
(
abc
bcd
T
)
;
float4
middle
=
mix
(
abc
bcd
T
.
zwxy
(
)
)
;
this
-
>
writeCubicPatch
(
p0
ab
.
lo
abc
.
lo
abcd
.
lo
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangle
(
p0
abcd
.
lo
abcd
.
hi
)
;
}
this
-
>
writeCubicPatch
(
abcd
.
lo
middle
abcd
.
hi
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
abcd
.
hi
)
)
)
;
}
std
:
:
tie
(
p0
p1
p2
)
=
{
abcd
.
hi
bcd
.
hi
cd
.
hi
}
;
}
if
(
numPatches
=
=
2
)
{
float2
ab
=
(
p0
+
p1
)
*
.
5f
;
float2
bc
=
(
p1
+
p2
)
*
.
5f
;
float2
cd
=
(
p2
+
p3
)
*
.
5f
;
float2
abc
=
(
ab
+
bc
)
*
.
5f
;
float2
bcd
=
(
bc
+
cd
)
*
.
5f
;
float2
abcd
=
(
abc
+
bcd
)
*
.
5f
;
this
-
>
writeCubicPatch
(
p0
ab
abc
abcd
)
;
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangle
(
p0
abcd
p3
)
;
}
this
-
>
writeCubicPatch
(
abcd
bcd
cd
p3
)
;
}
else
{
SkASSERT
(
numPatches
=
=
1
)
;
this
-
>
writeCubicPatch
(
p0
p1
p2
p3
)
;
}
if
constexpr
(
kAddTrianglesWhenChopping
)
{
this
-
>
writeTriangleStack
(
triangulator
.
pushVertex
(
skvx
:
:
bit_pun
<
SkPoint
>
(
p3
)
)
)
;
this
-
>
writeTriangleStack
(
triangulator
.
close
(
)
)
;
}
}
ENABLE_IF
(
kAddTrianglesWhenChopping
)
writeTriangleStack
(
MiddleOutPolygonTriangulator
:
:
PoppedTriangleStack
&
&
stack
)
{
for
(
auto
[
p0
p1
p2
]
:
stack
)
{
this
-
>
writeTriangle
(
p0
p1
p2
)
;
}
}
const
PatchAttribs
fAttribs
;
wangs_formula
:
:
VectorXform
fApproxTransform
=
{
}
;
float
fMaxScale
=
1
.
0f
;
LinearTolerances
fTolerances
;
PatchAllocator
fPatchAllocator
;
DeferredPatch
fDeferredPatch
;
JoinAttrib
fJoin
;
FanPointAttrib
fFanPoint
;
StrokeAttrib
fStrokeParams
;
ColorAttrib
fColor
;
DepthAttrib
fDepth
;
SsboIndexAttrib
fSsboIndex
;
}
;
}
#
undef
ENABLE_IF
#
undef
AI
#
endif
