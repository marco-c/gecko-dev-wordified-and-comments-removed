#
ifndef
GrGeometryProcessor_DEFINED
#
define
GrGeometryProcessor_DEFINED
#
include
"
GrPrimitiveProcessor
.
h
"
class
GrGeometryProcessor
:
public
GrPrimitiveProcessor
{
public
:
GrGeometryProcessor
(
)
:
fWillUseGeoShader
(
false
)
fLocalCoordsType
(
kUnused_LocalCoordsType
)
fSampleShading
(
0
.
0
)
{
}
bool
willUseGeoShader
(
)
const
override
{
return
fWillUseGeoShader
;
}
bool
hasExplicitLocalCoords
(
)
const
override
{
return
kHasExplicit_LocalCoordsType
=
=
fLocalCoordsType
;
}
float
getSampleShading
(
)
const
override
{
return
fSampleShading
;
}
protected
:
const
Attribute
&
addVertexAttrib
(
const
char
*
name
GrVertexAttribType
type
GrSLPrecision
precision
=
kDefault_GrSLPrecision
)
{
precision
=
(
kDefault_GrSLPrecision
=
=
precision
)
?
kMedium_GrSLPrecision
:
precision
;
fAttribs
.
emplace_back
(
name
type
precision
)
;
fVertexStride
+
=
fAttribs
.
back
(
)
.
fOffset
;
return
fAttribs
.
back
(
)
;
}
void
setWillUseGeoShader
(
)
{
fWillUseGeoShader
=
true
;
}
enum
LocalCoordsType
{
kUnused_LocalCoordsType
kHasExplicit_LocalCoordsType
kHasTransformed_LocalCoordsType
}
;
void
setHasExplicitLocalCoords
(
)
{
SkASSERT
(
kUnused_LocalCoordsType
=
=
fLocalCoordsType
)
;
fLocalCoordsType
=
kHasExplicit_LocalCoordsType
;
}
void
setHasTransformedLocalCoords
(
)
{
SkASSERT
(
kUnused_LocalCoordsType
=
=
fLocalCoordsType
)
;
fLocalCoordsType
=
kHasTransformed_LocalCoordsType
;
}
void
setSampleShading
(
float
sampleShading
)
{
fSampleShading
=
sampleShading
;
}
private
:
bool
fWillUseGeoShader
;
LocalCoordsType
fLocalCoordsType
;
float
fSampleShading
;
typedef
GrPrimitiveProcessor
INHERITED
;
}
;
#
endif
