#
ifndef
GrResourceProvider_DEFINED
#
define
GrResourceProvider_DEFINED
#
include
"
GrBuffer
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPathRange
.
h
"
class
GrPath
;
class
GrRenderTarget
;
class
GrSingleOwner
;
class
GrStencilAttachment
;
class
GrStyle
;
class
SkDescriptor
;
class
SkPath
;
class
SkTypeface
;
class
GrResourceProvider
{
public
:
GrResourceProvider
(
GrGpu
*
gpu
GrResourceCache
*
cache
GrSingleOwner
*
owner
)
;
template
<
typename
T
>
T
*
findAndRefTByUniqueKey
(
const
GrUniqueKey
&
key
)
{
return
static_cast
<
T
*
>
(
this
-
>
findAndRefResourceByUniqueKey
(
key
)
)
;
}
sk_sp
<
GrTextureProxy
>
createMipMappedTexture
(
const
GrSurfaceDesc
&
desc
SkBudgeted
budgeted
const
GrMipLevel
*
texels
int
mipLevelCount
uint32_t
flags
=
0
SkDestinationSurfaceColorMode
mipColorMode
=
SkDestinationSurfaceColorMode
:
:
kLegacy
)
;
void
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
key
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
GrUniqueKey
&
key
)
;
GrTexture
*
createApproxTexture
(
const
GrSurfaceDesc
&
uint32_t
flags
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
desc
SkBudgeted
budgeted
uint32_t
flags
=
0
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTextureDesc
&
desc
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
desc
)
;
static
const
int
kMinScratchTextureSize
;
const
GrBuffer
*
findOrCreateInstancedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
{
if
(
GrBuffer
*
buffer
=
this
-
>
findAndRefTByUniqueKey
<
GrBuffer
>
(
key
)
)
{
return
buffer
;
}
return
this
-
>
createInstancedIndexBuffer
(
pattern
patternSize
reps
vertCount
key
)
;
}
const
GrBuffer
*
refQuadIndexBuffer
(
)
{
if
(
GrBuffer
*
buffer
=
this
-
>
findAndRefTByUniqueKey
<
GrBuffer
>
(
fQuadIndexBufferKey
)
)
{
return
buffer
;
}
return
this
-
>
createQuadIndexBuffer
(
)
;
}
GrPath
*
createPath
(
const
SkPath
&
const
GrStyle
&
)
;
GrPathRange
*
createPathRange
(
GrPathRange
:
:
PathGenerator
*
const
GrStyle
&
)
;
GrPathRange
*
createGlyphs
(
const
SkTypeface
*
const
SkScalerContextEffects
&
const
SkDescriptor
*
const
GrStyle
&
)
;
enum
Flags
{
kExact_Flag
=
0x1
kNoPendingIO_Flag
=
0x2
kNoCreate_Flag
=
0x4
kRequireGpuMemory_Flag
=
0x8
}
;
GrBuffer
*
createBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
uint32_t
flags
const
void
*
data
=
nullptr
)
;
GrStencilAttachment
*
attachStencilAttachment
(
GrRenderTarget
*
rt
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTextureDesc
&
desc
)
;
void
assignUniqueKeyToResource
(
const
GrUniqueKey
&
GrGpuResource
*
)
;
GrGpuResource
*
findAndRefResourceByUniqueKey
(
const
GrUniqueKey
&
)
;
sk_sp
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
)
;
void
takeOwnershipOfSemaphore
(
sk_sp
<
GrSemaphore
>
)
;
void
releaseOwnershipOfSemaphore
(
sk_sp
<
GrSemaphore
>
)
;
void
abandon
(
)
{
fCache
=
nullptr
;
fGpu
=
nullptr
;
}
static
bool
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
;
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
private
:
GrTexture
*
findAndRefTextureByUniqueKey
(
const
GrUniqueKey
&
key
)
;
void
assignUniqueKeyToTexture
(
const
GrUniqueKey
&
key
GrTexture
*
texture
)
{
SkASSERT
(
key
.
isValid
(
)
)
;
this
-
>
assignUniqueKeyToResource
(
key
texture
)
;
}
GrTexture
*
refScratchTexture
(
const
GrSurfaceDesc
&
uint32_t
scratchTextureFlags
)
;
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
const
GrBuffer
*
createInstancedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
;
const
GrBuffer
*
createQuadIndexBuffer
(
)
;
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
sk_sp
<
const
GrCaps
>
fCaps
;
GrUniqueKey
fQuadIndexBufferKey
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
#
endif
