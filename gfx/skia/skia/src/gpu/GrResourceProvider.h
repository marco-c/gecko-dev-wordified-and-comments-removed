#
ifndef
GrResourceProvider_DEFINED
#
define
GrResourceProvider_DEFINED
#
include
"
GrBatchAtlas
.
h
"
#
include
"
GrBuffer
.
h
"
#
include
"
GrTextureProvider
.
h
"
#
include
"
GrPathRange
.
h
"
class
GrBatchAtlas
;
class
GrPath
;
class
GrRenderTarget
;
class
GrSingleOwner
;
class
GrStencilAttachment
;
class
GrStrokeInfo
;
class
SkDescriptor
;
class
SkPath
;
class
SkTypeface
;
class
GrResourceProvider
:
protected
GrTextureProvider
{
public
:
GrResourceProvider
(
GrGpu
*
gpu
GrResourceCache
*
cache
GrSingleOwner
*
owner
)
;
template
<
typename
T
>
T
*
findAndRefTByUniqueKey
(
const
GrUniqueKey
&
key
)
{
return
static_cast
<
T
*
>
(
this
-
>
findAndRefResourceByUniqueKey
(
key
)
)
;
}
const
GrBuffer
*
findOrCreateInstancedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
{
if
(
GrBuffer
*
buffer
=
this
-
>
findAndRefTByUniqueKey
<
GrBuffer
>
(
key
)
)
{
return
buffer
;
}
return
this
-
>
createInstancedIndexBuffer
(
pattern
patternSize
reps
vertCount
key
)
;
}
const
GrBuffer
*
refQuadIndexBuffer
(
)
{
if
(
GrBuffer
*
buffer
=
this
-
>
findAndRefTByUniqueKey
<
GrBuffer
>
(
fQuadIndexBufferKey
)
)
{
return
buffer
;
}
return
this
-
>
createQuadIndexBuffer
(
)
;
}
GrPath
*
createPath
(
const
SkPath
&
const
GrStrokeInfo
&
)
;
GrPathRange
*
createPathRange
(
GrPathRange
:
:
PathGenerator
*
const
GrStrokeInfo
&
)
;
GrPathRange
*
createGlyphs
(
const
SkTypeface
*
const
SkDescriptor
*
const
GrStrokeInfo
&
)
;
using
GrTextureProvider
:
:
assignUniqueKeyToResource
;
using
GrTextureProvider
:
:
findAndRefResourceByUniqueKey
;
using
GrTextureProvider
:
:
findAndRefTextureByUniqueKey
;
using
GrTextureProvider
:
:
abandon
;
enum
Flags
{
kNoPendingIO_Flag
=
kNoPendingIO_ScratchTextureFlag
}
;
GrBuffer
*
createBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
uint32_t
flags
)
;
GrTexture
*
createApproxTexture
(
const
GrSurfaceDesc
&
desc
uint32_t
flags
)
{
SkASSERT
(
0
=
=
flags
|
|
kNoPendingIO_Flag
=
=
flags
)
;
return
this
-
>
internalCreateApproxTexture
(
desc
flags
)
;
}
GrBatchAtlas
*
createAtlas
(
GrPixelConfig
int
width
int
height
int
numPlotsX
int
numPlotsY
GrBatchAtlas
:
:
EvictionFunc
func
void
*
data
)
;
GrStencilAttachment
*
attachStencilAttachment
(
GrRenderTarget
*
rt
)
;
const
GrCaps
*
caps
(
)
{
return
this
-
>
gpu
(
)
-
>
caps
(
)
;
}
GrRenderTarget
*
wrapBackendTextureAsRenderTarget
(
const
GrBackendTextureDesc
&
desc
)
;
private
:
const
GrBuffer
*
createInstancedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
;
const
GrBuffer
*
createQuadIndexBuffer
(
)
;
GrUniqueKey
fQuadIndexBufferKey
;
typedef
GrTextureProvider
INHERITED
;
}
;
#
endif
