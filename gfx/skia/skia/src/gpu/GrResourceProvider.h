#
ifndef
GrResourceProvider_DEFINED
#
define
GrResourceProvider_DEFINED
#
include
"
include
/
gpu
/
GrContextOptions
.
h
"
#
include
"
include
/
private
/
SkImageInfoPriv
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
gpu
/
GrGpuBuffer
.
h
"
#
include
"
src
/
gpu
/
GrResourceCache
.
h
"
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBackendTexture
;
class
GrGpu
;
class
GrPath
;
class
GrRenderTarget
;
class
GrResourceProviderPriv
;
class
GrSemaphore
;
class
GrSingleOwner
;
class
GrStencilAttachment
;
class
GrTexture
;
struct
GrVkDrawableInfo
;
class
GrStyle
;
class
SkDescriptor
;
class
SkPath
;
class
SkTypeface
;
class
GrResourceProvider
{
public
:
GrResourceProvider
(
GrGpu
*
GrResourceCache
*
GrSingleOwner
*
)
;
template
<
typename
T
=
GrGpuResource
>
typename
std
:
:
enable_if
<
std
:
:
is_base_of
<
GrGpuResource
T
>
:
:
value
sk_sp
<
T
>
>
:
:
type
findByUniqueKey
(
const
GrUniqueKey
&
key
)
{
return
sk_sp
<
T
>
(
static_cast
<
T
*
>
(
this
-
>
findResourceByUniqueKey
(
key
)
.
release
(
)
)
)
;
}
sk_sp
<
GrTexture
>
createApproxTexture
(
const
GrSurfaceDesc
&
desc
const
GrBackendFormat
&
format
GrRenderable
renderable
int
renderTargetSampleCnt
GrProtected
isProtected
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
desc
const
GrBackendFormat
&
format
GrRenderable
renderable
int
renderTargetSampleCnt
GrMipMapped
mipMapped
SkBudgeted
budgeted
GrProtected
isProtected
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
desc
const
GrBackendFormat
&
format
GrColorType
colorType
GrRenderable
renderable
int
renderTargetSampleCnt
SkBudgeted
budgeted
GrProtected
isProtected
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
desc
const
GrBackendFormat
&
format
GrColorType
srcColorType
GrRenderable
renderable
int
renderTargetSampleCnt
SkBudgeted
budgeted
SkBackingFit
fit
GrProtected
isProtected
const
GrMipLevel
&
mipLevel
)
;
sk_sp
<
GrTexture
>
createCompressedTexture
(
int
width
int
height
const
GrBackendFormat
&
SkImage
:
:
CompressionType
SkBudgeted
SkData
*
data
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTexture
&
tex
GrColorType
GrWrapOwnership
GrWrapCacheable
GrIOType
)
;
sk_sp
<
GrTexture
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
tex
int
sampleCnt
GrColorType
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
GrColorType
colorType
)
;
sk_sp
<
GrRenderTarget
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
static
const
uint32_t
kMinScratchTextureSize
;
sk_sp
<
const
GrGpuBuffer
>
findOrMakeStaticBuffer
(
GrGpuBufferType
intendedType
size_t
size
const
void
*
data
const
GrUniqueKey
&
key
)
;
sk_sp
<
const
GrGpuBuffer
>
findOrCreatePatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
{
if
(
auto
buffer
=
this
-
>
findByUniqueKey
<
const
GrGpuBuffer
>
(
key
)
)
{
return
buffer
;
}
return
this
-
>
createPatternedIndexBuffer
(
pattern
patternSize
reps
vertCount
&
key
)
;
}
sk_sp
<
const
GrGpuBuffer
>
refQuadIndexBuffer
(
)
{
if
(
!
fQuadIndexBuffer
)
{
fQuadIndexBuffer
=
this
-
>
createQuadIndexBuffer
(
)
;
}
return
fQuadIndexBuffer
;
}
static
int
QuadCountOfQuadBuffer
(
)
;
sk_sp
<
GrPath
>
createPath
(
const
SkPath
&
const
GrStyle
&
)
;
sk_sp
<
GrGpuBuffer
>
createBuffer
(
size_t
size
GrGpuBufferType
intendedType
GrAccessPattern
const
void
*
data
=
nullptr
)
;
bool
attachStencilAttachment
(
GrRenderTarget
*
rt
int
numStencilSamples
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
int
sampleCnt
GrColorType
)
;
void
assignUniqueKeyToResource
(
const
GrUniqueKey
&
GrGpuResource
*
)
;
sk_sp
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
bool
isOwned
=
true
)
;
enum
class
SemaphoreWrapType
{
kWillSignal
kWillWait
}
;
sk_sp
<
GrSemaphore
>
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
SemaphoreWrapType
wrapType
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
void
abandon
(
)
{
fCache
=
nullptr
;
fGpu
=
nullptr
;
}
uint32_t
contextUniqueID
(
)
const
{
return
fCache
-
>
contextUniqueID
(
)
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
bool
overBudget
(
)
const
{
return
fCache
-
>
overBudget
(
)
;
}
static
uint32_t
MakeApprox
(
uint32_t
value
)
;
inline
GrResourceProviderPriv
priv
(
)
;
inline
const
GrResourceProviderPriv
priv
(
)
const
;
private
:
sk_sp
<
GrGpuResource
>
findResourceByUniqueKey
(
const
GrUniqueKey
&
)
;
sk_sp
<
GrTexture
>
refScratchTexture
(
const
GrSurfaceDesc
&
const
GrBackendFormat
&
GrRenderable
int
renderTargetSampleCnt
GrMipMapped
GrProtected
)
;
sk_sp
<
GrTexture
>
getExactScratch
(
const
GrSurfaceDesc
&
const
GrBackendFormat
&
GrRenderable
int
renderTargetSampleCnt
SkBudgeted
GrMipMapped
GrProtected
)
;
using
TempLevels
=
SkAutoSTMalloc
<
14
GrMipLevel
>
;
using
TempLevelDatas
=
SkAutoSTArray
<
14
std
:
:
unique_ptr
<
char
[
]
>
>
;
GrColorType
prepareLevels
(
const
GrBackendFormat
&
format
GrColorType
const
SkISize
&
baseSize
const
GrMipLevel
texels
[
]
int
mipLevelCount
TempLevels
*
TempLevelDatas
*
)
const
;
sk_sp
<
GrTexture
>
writePixels
(
sk_sp
<
GrTexture
>
texture
GrColorType
colorType
const
SkISize
&
baseSize
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
const
;
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
friend
class
GrResourceProviderPriv
;
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
sk_sp
<
const
GrGpuBuffer
>
createPatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
*
key
)
;
sk_sp
<
const
GrGpuBuffer
>
createQuadIndexBuffer
(
)
;
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
sk_sp
<
const
GrCaps
>
fCaps
;
sk_sp
<
const
GrGpuBuffer
>
fQuadIndexBuffer
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
#
endif
