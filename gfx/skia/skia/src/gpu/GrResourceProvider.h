#
ifndef
GrResourceProvider_DEFINED
#
define
GrResourceProvider_DEFINED
#
include
"
GrContextOptions
.
h
"
#
include
"
GrGpuBuffer
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
SkImageInfoPriv
.
h
"
#
include
"
SkScalerContext
.
h
"
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBackendTexture
;
class
GrGpu
;
class
GrPath
;
class
GrRenderTarget
;
class
GrResourceProviderPriv
;
class
GrSemaphore
;
class
GrSingleOwner
;
class
GrStencilAttachment
;
class
GrTexture
;
struct
GrVkDrawableInfo
;
class
GrStyle
;
class
SkDescriptor
;
class
SkPath
;
class
SkTypeface
;
class
GrResourceProvider
{
public
:
enum
class
Flags
{
kNone
=
0x0
kNoPendingIO
=
0x1
}
;
GrResourceProvider
(
GrGpu
*
GrResourceCache
*
GrSingleOwner
*
bool
explicitlyAllocateGPUResources
)
;
template
<
typename
T
=
GrGpuResource
>
typename
std
:
:
enable_if
<
std
:
:
is_base_of
<
GrGpuResource
T
>
:
:
value
sk_sp
<
T
>
>
:
:
type
findByUniqueKey
(
const
GrUniqueKey
&
key
)
{
return
sk_sp
<
T
>
(
static_cast
<
T
*
>
(
this
-
>
findResourceByUniqueKey
(
key
)
.
release
(
)
)
)
;
}
sk_sp
<
GrTexture
>
createApproxTexture
(
const
GrSurfaceDesc
&
Flags
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
SkBudgeted
Flags
=
Flags
:
:
kNone
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
SkBudgeted
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
SkBudgeted
SkBackingFit
const
GrMipLevel
&
Flags
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTexture
&
tex
GrWrapOwnership
GrWrapCacheable
GrIOType
)
;
sk_sp
<
GrTexture
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
tex
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
;
sk_sp
<
GrRenderTarget
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
static
const
uint32_t
kMinScratchTextureSize
;
sk_sp
<
const
GrGpuBuffer
>
findOrMakeStaticBuffer
(
GrGpuBufferType
intendedType
size_t
size
const
void
*
data
const
GrUniqueKey
&
key
)
;
sk_sp
<
const
GrGpuBuffer
>
findOrCreatePatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
&
key
)
{
if
(
auto
buffer
=
this
-
>
findByUniqueKey
<
const
GrGpuBuffer
>
(
key
)
)
{
return
buffer
;
}
return
this
-
>
createPatternedIndexBuffer
(
pattern
patternSize
reps
vertCount
&
key
)
;
}
sk_sp
<
const
GrGpuBuffer
>
refQuadIndexBuffer
(
)
{
if
(
!
fQuadIndexBuffer
)
{
fQuadIndexBuffer
=
this
-
>
createQuadIndexBuffer
(
)
;
}
return
fQuadIndexBuffer
;
}
static
int
QuadCountOfQuadBuffer
(
)
;
sk_sp
<
GrPath
>
createPath
(
const
SkPath
&
const
GrStyle
&
)
;
sk_sp
<
GrGpuBuffer
>
createBuffer
(
size_t
size
GrGpuBufferType
intendedType
GrAccessPattern
const
void
*
data
=
nullptr
)
;
bool
attachStencilAttachment
(
GrRenderTarget
*
rt
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
int
sampleCnt
)
;
void
assignUniqueKeyToResource
(
const
GrUniqueKey
&
GrGpuResource
*
)
;
sk_sp
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
bool
isOwned
=
true
)
;
enum
class
SemaphoreWrapType
{
kWillSignal
kWillWait
}
;
sk_sp
<
GrSemaphore
>
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
SemaphoreWrapType
wrapType
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
void
abandon
(
)
{
fCache
=
nullptr
;
fGpu
=
nullptr
;
}
uint32_t
contextUniqueID
(
)
const
{
return
fCache
-
>
contextUniqueID
(
)
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
bool
overBudget
(
)
const
{
return
fCache
-
>
overBudget
(
)
;
}
inline
GrResourceProviderPriv
priv
(
)
;
inline
const
GrResourceProviderPriv
priv
(
)
const
;
bool
explicitlyAllocateGPUResources
(
)
const
{
return
fExplicitlyAllocateGPUResources
;
}
bool
testingOnly_setExplicitlyAllocateGPUResources
(
bool
newValue
)
;
private
:
sk_sp
<
GrGpuResource
>
findResourceByUniqueKey
(
const
GrUniqueKey
&
)
;
sk_sp
<
GrTexture
>
refScratchTexture
(
const
GrSurfaceDesc
&
Flags
)
;
sk_sp
<
GrTexture
>
getExactScratch
(
const
GrSurfaceDesc
&
SkBudgeted
Flags
)
;
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
friend
class
GrResourceProviderPriv
;
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
sk_sp
<
const
GrGpuBuffer
>
createPatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
GrUniqueKey
*
key
)
;
sk_sp
<
const
GrGpuBuffer
>
createQuadIndexBuffer
(
)
;
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
sk_sp
<
const
GrCaps
>
fCaps
;
sk_sp
<
const
GrGpuBuffer
>
fQuadIndexBuffer
;
bool
fExplicitlyAllocateGPUResources
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrResourceProvider
:
:
Flags
)
;
#
endif
