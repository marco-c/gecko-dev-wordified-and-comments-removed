#
ifndef
GrGpuResourceRef_DEFINED
#
define
GrGpuResourceRef_DEFINED
#
include
"
GrGpuResource
.
h
"
#
include
"
SkRefCnt
.
h
"
class
GrGpuResourceRef
:
SkNoncopyable
{
public
:
~
GrGpuResourceRef
(
)
;
GrGpuResource
*
getResource
(
)
const
{
return
fResource
;
}
bool
ownsPendingIO
(
)
const
{
return
fPendingIO
;
}
GrIOType
ioType
(
)
const
{
return
fIOType
;
}
void
reset
(
)
;
protected
:
GrGpuResourceRef
(
)
;
GrGpuResourceRef
(
GrGpuResource
*
GrIOType
)
;
void
setResource
(
GrGpuResource
*
GrIOType
)
;
private
:
void
markPendingIO
(
)
const
;
void
removeRef
(
)
const
;
void
pendingIOComplete
(
)
const
;
friend
class
GrResourceIOProcessor
;
GrGpuResource
*
fResource
;
mutable
bool
fOwnRef
;
mutable
bool
fPendingIO
;
GrIOType
fIOType
;
typedef
SkNoncopyable
INHERITED
;
}
;
template
<
typename
T
>
class
GrTGpuResourceRef
:
public
GrGpuResourceRef
{
public
:
GrTGpuResourceRef
(
)
{
}
GrTGpuResourceRef
(
T
*
resource
GrIOType
ioType
)
:
INHERITED
(
resource
ioType
)
{
}
GrTGpuResourceRef
(
sk_sp
<
T
>
resource
GrIOType
ioType
)
:
INHERITED
(
resource
ioType
)
{
}
T
*
get
(
)
const
{
return
static_cast
<
T
*
>
(
this
-
>
getResource
(
)
)
;
}
void
set
(
T
*
resource
GrIOType
ioType
)
{
this
-
>
setResource
(
resource
ioType
)
;
}
private
:
typedef
GrGpuResourceRef
INHERITED
;
}
;
template
<
typename
T
GrIOType
IO_TYPE
>
class
GrPendingIOResource
:
SkNoncopyable
{
public
:
GrPendingIOResource
(
T
*
resource
=
nullptr
)
:
fResource
(
nullptr
)
{
this
-
>
reset
(
resource
)
;
}
GrPendingIOResource
(
const
GrPendingIOResource
&
that
)
:
GrPendingIOResource
(
that
.
get
(
)
)
{
}
void
reset
(
T
*
resource
=
nullptr
)
{
if
(
resource
)
{
switch
(
IO_TYPE
)
{
case
kRead_GrIOType
:
resource
-
>
addPendingRead
(
)
;
break
;
case
kWrite_GrIOType
:
resource
-
>
addPendingWrite
(
)
;
break
;
case
kRW_GrIOType
:
resource
-
>
addPendingRead
(
)
;
resource
-
>
addPendingWrite
(
)
;
break
;
}
}
this
-
>
release
(
)
;
fResource
=
resource
;
}
~
GrPendingIOResource
(
)
{
this
-
>
release
(
)
;
}
explicit
operator
bool
(
)
const
{
return
SkToBool
(
fResource
)
;
}
bool
operator
=
=
(
const
GrPendingIOResource
&
other
)
const
{
return
fResource
=
=
other
.
fResource
;
}
T
*
get
(
)
const
{
return
fResource
;
}
private
:
void
release
(
)
{
if
(
fResource
)
{
switch
(
IO_TYPE
)
{
case
kRead_GrIOType
:
fResource
-
>
completedRead
(
)
;
break
;
case
kWrite_GrIOType
:
fResource
-
>
completedWrite
(
)
;
break
;
case
kRW_GrIOType
:
fResource
-
>
completedRead
(
)
;
fResource
-
>
completedWrite
(
)
;
break
;
}
}
}
T
*
fResource
;
}
;
#
endif
