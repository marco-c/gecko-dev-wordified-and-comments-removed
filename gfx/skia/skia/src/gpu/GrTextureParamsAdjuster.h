#
ifndef
GrTextureMaker_DEFINED
#
define
GrTextureMaker_DEFINED
#
include
"
GrTextureParams
.
h
"
#
include
"
GrResourceKey
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
SkTLazy
.
h
"
class
GrContext
;
class
GrTextureParams
;
class
GrUniqueKey
;
class
SkBitmap
;
class
GrTextureProducer
:
public
SkNoncopyable
{
public
:
struct
CopyParams
{
GrTextureParams
:
:
FilterMode
fFilter
;
int
fWidth
;
int
fHeight
;
}
;
enum
FilterConstraint
{
kYes_FilterConstraint
kNo_FilterConstraint
}
;
virtual
sk_sp
<
GrFragmentProcessor
>
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
const
GrTextureParams
:
:
FilterMode
*
filterOrNullForBicubic
SkColorSpace
*
dstColorSpace
SkSourceGammaTreatment
)
=
0
;
virtual
~
GrTextureProducer
(
)
{
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
bool
isAlphaOnly
(
)
const
{
return
fIsAlphaOnly
;
}
virtual
SkAlphaType
alphaType
(
)
const
=
0
;
virtual
SkColorSpace
*
getColorSpace
(
)
=
0
;
protected
:
GrTextureProducer
(
int
width
int
height
bool
isAlphaOnly
)
:
fWidth
(
width
)
fHeight
(
height
)
fIsAlphaOnly
(
isAlphaOnly
)
{
}
static
void
MakeCopyKeyFromOrigKey
(
const
GrUniqueKey
&
origKey
const
CopyParams
&
copyParams
GrUniqueKey
*
copyKey
)
{
SkASSERT
(
!
copyKey
-
>
isValid
(
)
)
;
if
(
origKey
.
isValid
(
)
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
copyKey
origKey
kDomain
3
)
;
builder
[
0
]
=
copyParams
.
fFilter
;
builder
[
1
]
=
copyParams
.
fWidth
;
builder
[
2
]
=
copyParams
.
fHeight
;
}
}
virtual
void
makeCopyKey
(
const
CopyParams
&
GrUniqueKey
*
copyKey
)
=
0
;
virtual
void
didCacheCopy
(
const
GrUniqueKey
&
copyKey
)
=
0
;
private
:
const
int
fWidth
;
const
int
fHeight
;
const
bool
fIsAlphaOnly
;
typedef
SkNoncopyable
INHERITED
;
}
;
class
GrTextureAdjuster
:
public
GrTextureProducer
{
public
:
GrTexture
*
refTextureSafeForParams
(
const
GrTextureParams
&
SkSourceGammaTreatment
SkIPoint
*
outOffset
)
;
sk_sp
<
GrFragmentProcessor
>
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
bool
coordsLimitedToConstraintRect
const
GrTextureParams
:
:
FilterMode
*
filterOrNullForBicubic
SkColorSpace
*
dstColorSpace
SkSourceGammaTreatment
)
override
;
GrTextureAdjuster
(
GrTexture
*
SkAlphaType
const
SkIRect
&
area
uint32_t
uniqueID
SkColorSpace
*
)
;
protected
:
SkAlphaType
alphaType
(
)
const
override
{
return
fAlphaType
;
}
SkColorSpace
*
getColorSpace
(
)
override
;
void
makeCopyKey
(
const
CopyParams
&
params
GrUniqueKey
*
copyKey
)
override
;
void
didCacheCopy
(
const
GrUniqueKey
&
copyKey
)
override
;
GrTexture
*
originalTexture
(
)
const
{
return
fOriginal
;
}
const
SkIRect
*
contentAreaOrNull
(
)
{
return
fContentArea
.
getMaybeNull
(
)
;
}
private
:
SkTLazy
<
SkIRect
>
fContentArea
;
GrTexture
*
fOriginal
;
SkAlphaType
fAlphaType
;
SkColorSpace
*
fColorSpace
;
uint32_t
fUniqueID
;
GrTexture
*
refCopy
(
const
CopyParams
&
copyParams
)
;
typedef
GrTextureProducer
INHERITED
;
}
;
class
GrTextureMaker
:
public
GrTextureProducer
{
public
:
GrTexture
*
refTextureForParams
(
const
GrTextureParams
&
SkSourceGammaTreatment
)
;
sk_sp
<
GrFragmentProcessor
>
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
const
GrTextureParams
:
:
FilterMode
*
filterOrNullForBicubic
SkColorSpace
*
dstColorSpace
SkSourceGammaTreatment
)
override
;
protected
:
GrTextureMaker
(
GrContext
*
context
int
width
int
height
bool
isAlphaOnly
)
:
INHERITED
(
width
height
isAlphaOnly
)
fContext
(
context
)
{
}
virtual
GrTexture
*
refOriginalTexture
(
bool
willBeMipped
SkSourceGammaTreatment
)
=
0
;
virtual
GrTexture
*
generateTextureForParams
(
const
CopyParams
&
bool
willBeMipped
SkSourceGammaTreatment
)
;
GrContext
*
context
(
)
const
{
return
fContext
;
}
private
:
GrContext
*
fContext
;
typedef
GrTextureProducer
INHERITED
;
}
;
#
endif
