#
ifndef
GrOpFlushState_DEFINED
#
define
GrOpFlushState_DEFINED
#
include
<
utility
>
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkArenaAllocList
.
h
"
#
include
"
src
/
gpu
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
GrBufferAllocPool
.
h
"
#
include
"
src
/
gpu
/
GrDeferredUpload
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrMeshDrawOp
.
h
"
class
GrGpu
;
class
GrOpsRenderPass
;
class
GrResourceProvider
;
class
GrOpFlushState
final
:
public
GrDeferredUploadTarget
public
GrMeshDrawOp
:
:
Target
{
public
:
GrOpFlushState
(
GrGpu
*
GrResourceProvider
*
GrTokenTracker
*
sk_sp
<
GrBufferAllocPool
:
:
CpuBufferCache
>
=
nullptr
)
;
~
GrOpFlushState
(
)
final
{
this
-
>
reset
(
)
;
}
void
preExecuteDraws
(
)
;
void
doUpload
(
GrDeferredTextureUploadFn
&
bool
shouldPrepareSurfaceForSampling
=
false
)
;
void
executeDrawsAndUploadsForMeshDrawOp
(
const
GrOp
*
op
const
SkRect
&
chainBounds
GrProcessorSet
&
&
GrPipeline
:
:
InputFlags
=
GrPipeline
:
:
InputFlags
:
:
kNone
const
GrUserStencilSettings
*
=
&
GrUserStencilSettings
:
:
kUnused
)
;
GrOpsRenderPass
*
opsRenderPass
(
)
{
return
fOpsRenderPass
;
}
void
setOpsRenderPass
(
GrOpsRenderPass
*
renderPass
)
{
fOpsRenderPass
=
renderPass
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
void
reset
(
)
;
struct
OpArgs
{
explicit
OpArgs
(
GrOp
*
op
GrRenderTargetProxy
*
proxy
GrAppliedClip
*
appliedClip
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
)
:
fOp
(
op
)
fProxy
(
proxy
)
fAppliedClip
(
appliedClip
)
fDstProxy
(
dstProxy
)
{
}
int
numSamples
(
)
const
{
return
fProxy
-
>
numSamples
(
)
;
}
GrSurfaceOrigin
origin
(
)
const
{
return
fProxy
-
>
origin
(
)
;
}
GrSwizzle
outputSwizzle
(
)
const
{
return
fProxy
-
>
outputSwizzle
(
)
;
}
GrOp
*
op
(
)
{
return
fOp
;
}
GrRenderTargetProxy
*
proxy
(
)
const
{
return
fProxy
;
}
GrRenderTarget
*
renderTarget
(
)
const
{
return
fProxy
-
>
peekRenderTarget
(
)
;
}
GrAppliedClip
*
appliedClip
(
)
{
return
fAppliedClip
;
}
const
GrAppliedClip
*
appliedClip
(
)
const
{
return
fAppliedClip
;
}
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
(
)
const
{
return
fDstProxy
;
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
fOp
)
;
SkASSERT
(
fProxy
)
;
}
#
endif
private
:
GrOp
*
fOp
;
GrRenderTargetProxy
*
fProxy
;
GrAppliedClip
*
fAppliedClip
;
GrXferProcessor
:
:
DstProxy
fDstProxy
;
}
;
void
setOpArgs
(
OpArgs
*
opArgs
)
{
fOpArgs
=
opArgs
;
}
const
OpArgs
&
drawOpArgs
(
)
const
{
SkASSERT
(
fOpArgs
)
;
SkDEBUGCODE
(
fOpArgs
-
>
validate
(
)
)
;
return
*
fOpArgs
;
}
void
setSampledProxyArray
(
SkTArray
<
GrTextureProxy
*
true
>
*
sampledProxies
)
{
fSampledProxies
=
sampledProxies
;
}
SkTArray
<
GrTextureProxy
*
true
>
*
sampledProxyArray
(
)
override
{
return
fSampledProxies
;
}
const
GrTokenTracker
*
tokenTracker
(
)
final
{
return
fTokenTracker
;
}
GrDeferredUploadToken
addInlineUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
GrDeferredUploadToken
addASAPUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
void
recordDraw
(
sk_sp
<
const
GrGeometryProcessor
>
const
GrMesh
[
]
int
meshCnt
const
GrPipeline
:
:
FixedDynamicState
*
const
GrPipeline
:
:
DynamicStateArrays
*
)
final
;
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
)
final
;
uint16_t
*
makeIndexSpace
(
int
indexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
)
final
;
void
*
makeVertexSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
int
*
actualVertexCount
)
final
;
uint16_t
*
makeIndexSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
int
*
actualIndexCount
)
final
;
void
putBackIndices
(
int
indexCount
)
final
;
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
final
;
GrRenderTargetProxy
*
proxy
(
)
const
final
{
return
fOpArgs
-
>
proxy
(
)
;
}
const
GrAppliedClip
*
appliedClip
(
)
final
{
return
fOpArgs
-
>
appliedClip
(
)
;
}
GrAppliedClip
detachAppliedClip
(
)
final
;
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
(
)
const
final
{
return
fOpArgs
-
>
dstProxy
(
)
;
}
GrDeferredUploadTarget
*
deferredUploadTarget
(
)
final
{
return
this
;
}
const
GrCaps
&
caps
(
)
const
final
;
GrResourceProvider
*
resourceProvider
(
)
const
final
{
return
fResourceProvider
;
}
GrStrikeCache
*
glyphCache
(
)
const
final
;
GrAtlasManager
*
atlasManager
(
)
const
final
;
SkArenaAlloc
*
allocator
(
)
override
{
return
&
fArena
;
}
private
:
struct
InlineUpload
{
InlineUpload
(
GrDeferredTextureUploadFn
&
&
upload
GrDeferredUploadToken
token
)
:
fUpload
(
std
:
:
move
(
upload
)
)
fUploadBeforeToken
(
token
)
{
}
GrDeferredTextureUploadFn
fUpload
;
GrDeferredUploadToken
fUploadBeforeToken
;
}
;
struct
Draw
{
~
Draw
(
)
;
sk_sp
<
const
GrGeometryProcessor
>
fGeometryProcessor
;
const
GrPipeline
:
:
FixedDynamicState
*
fFixedDynamicState
;
const
GrPipeline
:
:
DynamicStateArrays
*
fDynamicStateArrays
;
const
GrMesh
*
fMeshes
=
nullptr
;
const
GrOp
*
fOp
=
nullptr
;
int
fMeshCnt
=
0
;
}
;
SkArenaAlloc
fArena
{
sizeof
(
GrPipeline
)
*
100
}
;
GrVertexBufferAllocPool
fVertexPool
;
GrIndexBufferAllocPool
fIndexPool
;
SkArenaAllocList
<
GrDeferredTextureUploadFn
>
fASAPUploads
;
SkArenaAllocList
<
InlineUpload
>
fInlineUploads
;
SkArenaAllocList
<
Draw
>
fDraws
;
GrDeferredUploadToken
fBaseDrawToken
=
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
;
OpArgs
*
fOpArgs
=
nullptr
;
SkTArray
<
GrTextureProxy
*
true
>
*
fSampledProxies
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
GrTokenTracker
*
fTokenTracker
;
GrOpsRenderPass
*
fOpsRenderPass
=
nullptr
;
SkArenaAllocList
<
Draw
>
:
:
Iter
fCurrDraw
;
SkArenaAllocList
<
InlineUpload
>
:
:
Iter
fCurrUpload
;
}
;
#
endif
