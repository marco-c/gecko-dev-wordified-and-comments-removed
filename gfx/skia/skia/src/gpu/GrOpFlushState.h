#
ifndef
GrOpFlushState_DEFINED
#
define
GrOpFlushState_DEFINED
#
include
<
utility
>
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrBufferAllocPool
.
h
"
#
include
"
GrDeferredUpload
.
h
"
#
include
"
GrUninstantiateProxyTracker
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkArenaAllocList
.
h
"
#
include
"
ops
/
GrMeshDrawOp
.
h
"
class
GrGpu
;
class
GrGpuCommandBuffer
;
class
GrGpuRTCommandBuffer
;
class
GrResourceProvider
;
class
GrOpFlushState
final
:
public
GrDeferredUploadTarget
public
GrMeshDrawOp
:
:
Target
{
public
:
GrOpFlushState
(
GrGpu
*
GrResourceProvider
*
GrTokenTracker
*
)
;
~
GrOpFlushState
(
)
final
{
this
-
>
reset
(
)
;
}
void
preExecuteDraws
(
)
;
void
doUpload
(
GrDeferredTextureUploadFn
&
)
;
void
executeDrawsAndUploadsForMeshDrawOp
(
uint32_t
opID
const
SkRect
&
opBounds
)
;
GrGpuCommandBuffer
*
commandBuffer
(
)
{
return
fCommandBuffer
;
}
GrGpuRTCommandBuffer
*
rtCommandBuffer
(
)
;
void
setCommandBuffer
(
GrGpuCommandBuffer
*
buffer
)
{
fCommandBuffer
=
buffer
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
void
reset
(
)
;
struct
OpArgs
{
GrRenderTarget
*
renderTarget
(
)
const
{
return
fProxy
-
>
peekRenderTarget
(
)
;
}
GrOp
*
fOp
;
GrRenderTargetProxy
*
fProxy
;
GrAppliedClip
*
fAppliedClip
;
GrXferProcessor
:
:
DstProxy
fDstProxy
;
}
;
void
setOpArgs
(
OpArgs
*
opArgs
)
{
fOpArgs
=
opArgs
;
}
const
OpArgs
&
drawOpArgs
(
)
const
{
SkASSERT
(
fOpArgs
)
;
SkASSERT
(
fOpArgs
-
>
fOp
)
;
return
*
fOpArgs
;
}
const
GrTokenTracker
*
tokenTracker
(
)
final
{
return
fTokenTracker
;
}
GrDeferredUploadToken
addInlineUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
GrDeferredUploadToken
addASAPUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
void
draw
(
sk_sp
<
const
GrGeometryProcessor
>
const
GrPipeline
*
const
GrPipeline
:
:
FixedDynamicState
*
const
GrPipeline
:
:
DynamicStateArrays
*
const
GrMesh
[
]
int
meshCnt
)
final
;
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
const
GrBuffer
*
*
int
*
startVertex
)
final
;
uint16_t
*
makeIndexSpace
(
int
indexCount
const
GrBuffer
*
*
int
*
startIndex
)
final
;
void
*
makeVertexSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
const
GrBuffer
*
*
int
*
startVertex
int
*
actualVertexCount
)
final
;
uint16_t
*
makeIndexSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
const
GrBuffer
*
*
int
*
startIndex
int
*
actualIndexCount
)
final
;
void
putBackIndices
(
int
indexCount
)
final
;
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
final
;
GrRenderTargetProxy
*
proxy
(
)
const
final
{
return
fOpArgs
-
>
fProxy
;
}
GrAppliedClip
detachAppliedClip
(
)
final
;
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
(
)
const
final
{
return
fOpArgs
-
>
fDstProxy
;
}
GrDeferredUploadTarget
*
deferredUploadTarget
(
)
final
{
return
this
;
}
const
GrCaps
&
caps
(
)
const
final
;
GrResourceProvider
*
resourceProvider
(
)
const
final
{
return
fResourceProvider
;
}
GrGlyphCache
*
glyphCache
(
)
const
final
;
GrAtlasManager
*
atlasManager
(
)
const
final
;
GrUninstantiateProxyTracker
*
uninstantiateProxyTracker
(
)
{
return
&
fUninstantiateProxyTracker
;
}
private
:
SkArenaAlloc
*
pipelineArena
(
)
override
{
return
&
fArena
;
}
struct
InlineUpload
{
InlineUpload
(
GrDeferredTextureUploadFn
&
&
upload
GrDeferredUploadToken
token
)
:
fUpload
(
std
:
:
move
(
upload
)
)
fUploadBeforeToken
(
token
)
{
}
GrDeferredTextureUploadFn
fUpload
;
GrDeferredUploadToken
fUploadBeforeToken
;
}
;
struct
Draw
{
~
Draw
(
)
;
sk_sp
<
const
GrGeometryProcessor
>
fGeometryProcessor
;
const
GrPipeline
*
fPipeline
=
nullptr
;
const
GrPipeline
:
:
FixedDynamicState
*
fFixedDynamicState
;
const
GrPipeline
:
:
DynamicStateArrays
*
fDynamicStateArrays
;
const
GrMesh
*
fMeshes
=
nullptr
;
int
fMeshCnt
=
0
;
uint32_t
fOpID
=
SK_InvalidUniqueID
;
}
;
SkArenaAlloc
fArena
{
sizeof
(
GrPipeline
)
*
100
}
;
GrVertexBufferAllocPool
fVertexPool
;
GrIndexBufferAllocPool
fIndexPool
;
SkArenaAllocList
<
GrDeferredTextureUploadFn
>
fASAPUploads
;
SkArenaAllocList
<
InlineUpload
>
fInlineUploads
;
SkArenaAllocList
<
Draw
>
fDraws
;
GrDeferredUploadToken
fBaseDrawToken
=
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
;
OpArgs
*
fOpArgs
=
nullptr
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
GrTokenTracker
*
fTokenTracker
;
GrGpuCommandBuffer
*
fCommandBuffer
=
nullptr
;
SkArenaAllocList
<
Draw
>
:
:
Iter
fCurrDraw
;
SkArenaAllocList
<
InlineUpload
>
:
:
Iter
fCurrUpload
;
GrUninstantiateProxyTracker
fUninstantiateProxyTracker
;
}
;
#
endif
