#
ifndef
GrOp_DEFINED
#
define
GrOp_DEFINED
#
include
"
GrGpuResource
.
h
"
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkString
.
h
"
#
include
<
atomic
>
#
include
<
new
>
class
GrCaps
;
class
GrGpuCommandBuffer
;
class
GrOpFlushState
;
class
GrRenderTargetOpList
;
#
define
GR_OP_SPEW
0
#
if
GR_OP_SPEW
#
define
GrOP_SPEW
(
code
)
code
#
define
GrOP_INFO
(
.
.
.
)
SkDebugf
(
__VA_ARGS__
)
#
else
#
define
GrOP_SPEW
(
code
)
#
define
GrOP_INFO
(
.
.
.
)
#
endif
#
define
GR_FLUSH_TIME_OP_SPEW
0
#
define
DEFINE_OP_CLASS_ID
\
static
uint32_t
ClassID
(
)
{
\
static
uint32_t
kClassID
=
GenOpClassID
(
)
;
\
return
kClassID
;
\
}
class
GrOp
:
private
SkNoncopyable
{
public
:
virtual
~
GrOp
(
)
=
default
;
virtual
const
char
*
name
(
)
const
=
0
;
typedef
std
:
:
function
<
void
(
GrSurfaceProxy
*
)
>
VisitProxyFunc
;
enum
class
VisitorType
:
unsigned
{
kAllocatorGather
kOther
}
;
virtual
void
visitProxies
(
const
VisitProxyFunc
&
VisitorType
=
VisitorType
:
:
kOther
)
const
{
}
enum
class
CombineResult
{
kMerged
kMayChain
kCannotCombine
}
;
CombineResult
combineIfPossible
(
GrOp
*
that
const
GrCaps
&
caps
)
;
const
SkRect
&
bounds
(
)
const
{
SkASSERT
(
kUninitialized_BoundsFlag
!
=
fBoundsFlags
)
;
return
fBounds
;
}
void
setClippedBounds
(
const
SkRect
&
clippedBounds
)
{
fBounds
=
clippedBounds
;
fBoundsFlags
=
0
;
}
bool
hasAABloat
(
)
const
{
SkASSERT
(
fBoundsFlags
!
=
kUninitialized_BoundsFlag
)
;
return
SkToBool
(
fBoundsFlags
&
kAABloat_BoundsFlag
)
;
}
bool
hasZeroArea
(
)
const
{
SkASSERT
(
fBoundsFlags
!
=
kUninitialized_BoundsFlag
)
;
return
SkToBool
(
fBoundsFlags
&
kZeroArea_BoundsFlag
)
;
}
#
ifdef
SK_DEBUG
void
*
operator
new
(
size_t
size
)
;
void
operator
delete
(
void
*
target
)
;
void
*
operator
new
(
size_t
size
void
*
placement
)
{
return
:
:
operator
new
(
size
placement
)
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
#
endif
template
<
typename
T
>
const
T
&
cast
(
)
const
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
template
<
typename
T
>
T
*
cast
(
)
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
uint32_t
classID
(
)
const
{
SkASSERT
(
kIllegalOpID
!
=
fClassID
)
;
return
fClassID
;
}
uint32_t
uniqueID
(
)
const
{
if
(
kIllegalOpID
=
=
fUniqueID
)
{
fUniqueID
=
GenOpID
(
)
;
}
return
fUniqueID
;
}
void
prepare
(
GrOpFlushState
*
state
)
{
this
-
>
onPrepare
(
state
)
;
}
void
execute
(
GrOpFlushState
*
state
const
SkRect
&
chainBounds
)
{
TRACE_EVENT0
(
"
skia
"
name
(
)
)
;
this
-
>
onExecute
(
state
chainBounds
)
;
}
#
ifdef
SK_DEBUG
virtual
SkString
dumpInfo
(
)
const
{
SkString
string
;
string
.
appendf
(
"
OpBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
fBounds
.
fLeft
fBounds
.
fTop
fBounds
.
fRight
fBounds
.
fBottom
)
;
return
string
;
}
#
else
SkString
dumpInfo
(
)
const
{
return
SkString
(
"
<
Op
information
unavailable
>
"
)
;
}
#
endif
template
<
typename
OpSubclass
=
GrOp
>
class
ChainRange
{
private
:
class
Iter
{
public
:
explicit
Iter
(
const
OpSubclass
*
head
)
:
fCurr
(
head
)
{
}
inline
Iter
&
operator
+
+
(
)
{
return
*
this
=
Iter
(
static_cast
<
const
OpSubclass
*
>
(
fCurr
-
>
nextInChain
(
)
)
)
;
}
const
OpSubclass
&
operator
*
(
)
const
{
return
*
fCurr
;
}
bool
operator
!
=
(
const
Iter
&
that
)
const
{
return
fCurr
!
=
that
.
fCurr
;
}
private
:
const
OpSubclass
*
fCurr
;
}
;
const
OpSubclass
*
fHead
;
public
:
explicit
ChainRange
(
const
OpSubclass
*
head
)
:
fHead
(
head
)
{
}
Iter
begin
(
)
{
return
Iter
(
fHead
)
;
}
Iter
end
(
)
{
return
Iter
(
nullptr
)
;
}
}
;
void
chainConcat
(
std
:
:
unique_ptr
<
GrOp
>
)
;
bool
isChainHead
(
)
const
{
return
!
fPrevInChain
;
}
bool
isChainTail
(
)
const
{
return
!
fNextInChain
;
}
GrOp
*
nextInChain
(
)
const
{
return
fNextInChain
.
get
(
)
;
}
GrOp
*
prevInChain
(
)
const
{
return
fPrevInChain
;
}
std
:
:
unique_ptr
<
GrOp
>
cutChain
(
)
;
SkDEBUGCODE
(
void
validateChain
(
GrOp
*
expectedTail
=
nullptr
)
const
)
;
#
ifdef
SK_DEBUG
virtual
void
validate
(
)
const
{
}
#
endif
protected
:
GrOp
(
uint32_t
classID
)
;
enum
class
HasAABloat
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
IsZeroArea
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
setBounds
(
const
SkRect
&
newBounds
HasAABloat
aabloat
IsZeroArea
zeroArea
)
{
fBounds
=
newBounds
;
this
-
>
setBoundsFlags
(
aabloat
zeroArea
)
;
}
void
setTransformedBounds
(
const
SkRect
&
srcBounds
const
SkMatrix
&
m
HasAABloat
aabloat
IsZeroArea
zeroArea
)
{
m
.
mapRect
(
&
fBounds
srcBounds
)
;
this
-
>
setBoundsFlags
(
aabloat
zeroArea
)
;
}
void
makeFullScreen
(
GrSurfaceProxy
*
proxy
)
{
this
-
>
setBounds
(
SkRect
:
:
MakeIWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
HasAABloat
:
:
kNo
IsZeroArea
:
:
kNo
)
;
}
static
uint32_t
GenOpClassID
(
)
{
return
GenID
(
&
gCurrOpClassID
)
;
}
private
:
void
joinBounds
(
const
GrOp
&
that
)
{
if
(
that
.
hasAABloat
(
)
)
{
fBoundsFlags
|
=
kAABloat_BoundsFlag
;
}
if
(
that
.
hasZeroArea
(
)
)
{
fBoundsFlags
|
=
kZeroArea_BoundsFlag
;
}
return
fBounds
.
joinPossiblyEmptyRect
(
that
.
fBounds
)
;
}
virtual
CombineResult
onCombineIfPossible
(
GrOp
*
const
GrCaps
&
)
{
return
CombineResult
:
:
kCannotCombine
;
}
virtual
void
onPrepare
(
GrOpFlushState
*
)
=
0
;
virtual
void
onExecute
(
GrOpFlushState
*
const
SkRect
&
chainBounds
)
=
0
;
static
uint32_t
GenID
(
std
:
:
atomic
<
uint32_t
>
*
idCounter
)
{
uint32_t
id
=
(
*
idCounter
)
+
+
;
if
(
id
=
=
0
)
{
SK_ABORT
(
"
This
should
never
wrap
as
it
should
only
be
called
once
for
each
GrOp
"
"
subclass
.
"
)
;
}
return
id
;
}
void
setBoundsFlags
(
HasAABloat
aabloat
IsZeroArea
zeroArea
)
{
fBoundsFlags
=
0
;
fBoundsFlags
|
=
(
HasAABloat
:
:
kYes
=
=
aabloat
)
?
kAABloat_BoundsFlag
:
0
;
fBoundsFlags
|
=
(
IsZeroArea
:
:
kYes
=
=
zeroArea
)
?
kZeroArea_BoundsFlag
:
0
;
}
enum
{
kIllegalOpID
=
0
}
;
enum
BoundsFlags
{
kAABloat_BoundsFlag
=
0x1
kZeroArea_BoundsFlag
=
0x2
SkDEBUGCODE
(
kUninitialized_BoundsFlag
=
0x4
)
}
;
std
:
:
unique_ptr
<
GrOp
>
fNextInChain
;
GrOp
*
fPrevInChain
=
nullptr
;
const
uint16_t
fClassID
;
uint16_t
fBoundsFlags
;
static
uint32_t
GenOpID
(
)
{
return
GenID
(
&
gCurrOpUniqueID
)
;
}
mutable
uint32_t
fUniqueID
=
SK_InvalidUniqueID
;
SkRect
fBounds
;
static
std
:
:
atomic
<
uint32_t
>
gCurrOpUniqueID
;
static
std
:
:
atomic
<
uint32_t
>
gCurrOpClassID
;
}
;
#
endif
