#
ifndef
GrMeshDrawOp_DEFINED
#
define
GrMeshDrawOp_DEFINED
#
include
"
GrDrawOp
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrPendingProgramElement
.
h
"
#
include
"
SkTLList
.
h
"
class
GrCaps
;
class
GrOpFlushState
;
class
GrMeshDrawOp
:
public
GrDrawOp
{
public
:
class
Target
;
protected
:
GrMeshDrawOp
(
uint32_t
classID
)
;
class
PatternHelper
{
public
:
PatternHelper
(
GrPrimitiveType
primitiveType
)
:
fMesh
(
primitiveType
)
{
}
void
*
init
(
Target
*
size_t
vertexStride
const
GrBuffer
*
int
verticesPerRepetition
int
indicesPerRepetition
int
repeatCount
)
;
void
recordDraw
(
Target
*
const
GrGeometryProcessor
*
const
GrPipeline
*
)
;
private
:
GrMesh
fMesh
;
}
;
static
const
int
kVerticesPerQuad
=
4
;
static
const
int
kIndicesPerQuad
=
6
;
class
QuadHelper
:
private
PatternHelper
{
public
:
QuadHelper
(
)
:
INHERITED
(
GrPrimitiveType
:
:
kTriangles
)
{
}
void
*
init
(
Target
*
size_t
vertexStride
int
quadsToDraw
)
;
using
PatternHelper
:
:
recordDraw
;
private
:
typedef
PatternHelper
INHERITED
;
}
;
private
:
void
onPrepare
(
GrOpFlushState
*
state
)
final
;
void
onExecute
(
GrOpFlushState
*
state
)
final
;
virtual
void
onPrepareDraws
(
Target
*
)
=
0
;
typedef
GrDrawOp
INHERITED
;
}
;
class
GrMeshDrawOp
:
:
Target
{
public
:
virtual
~
Target
(
)
{
}
virtual
void
draw
(
const
GrGeometryProcessor
*
const
GrPipeline
*
const
GrMesh
&
)
=
0
;
virtual
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
const
GrBuffer
*
*
int
*
startVertex
)
=
0
;
virtual
uint16_t
*
makeIndexSpace
(
int
indexCount
const
GrBuffer
*
*
int
*
startIndex
)
=
0
;
virtual
void
*
makeVertexSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
const
GrBuffer
*
*
int
*
startVertex
int
*
actualVertexCount
)
=
0
;
virtual
uint16_t
*
makeIndexSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
const
GrBuffer
*
*
int
*
startIndex
int
*
actualIndexCount
)
=
0
;
virtual
void
putBackIndices
(
int
indices
)
=
0
;
virtual
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
=
0
;
template
<
typename
.
.
.
Args
>
GrPipeline
*
allocPipeline
(
Args
&
&
.
.
.
args
)
{
return
this
-
>
pipelineArena
(
)
-
>
make
<
GrPipeline
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
GrPipeline
*
makePipeline
(
uint32_t
pipelineFlags
GrProcessorSet
&
&
processorSet
GrAppliedClip
&
&
clip
)
{
GrPipeline
:
:
InitArgs
pipelineArgs
;
pipelineArgs
.
fFlags
=
pipelineFlags
;
pipelineArgs
.
fProxy
=
this
-
>
proxy
(
)
;
pipelineArgs
.
fDstProxy
=
this
-
>
dstProxy
(
)
;
pipelineArgs
.
fCaps
=
&
this
-
>
caps
(
)
;
pipelineArgs
.
fResourceProvider
=
this
-
>
resourceProvider
(
)
;
return
this
-
>
allocPipeline
(
pipelineArgs
std
:
:
move
(
processorSet
)
std
:
:
move
(
clip
)
)
;
}
virtual
GrRenderTargetProxy
*
proxy
(
)
const
=
0
;
virtual
GrAppliedClip
detachAppliedClip
(
)
=
0
;
virtual
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
(
)
const
=
0
;
virtual
GrResourceProvider
*
resourceProvider
(
)
const
=
0
;
virtual
const
GrCaps
&
caps
(
)
const
=
0
;
virtual
GrDeferredUploadTarget
*
deferredUploadTarget
(
)
=
0
;
private
:
virtual
SkArenaAlloc
*
pipelineArena
(
)
=
0
;
}
;
#
endif
