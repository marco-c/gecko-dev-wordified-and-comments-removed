#
ifndef
GrMeshDrawOp_DEFINED
#
define
GrMeshDrawOp_DEFINED
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrDrawOp
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrMesh
.
h
"
#
include
<
type_traits
>
class
GrAtlasManager
;
class
GrCaps
;
class
GrStrikeCache
;
class
GrOpFlushState
;
class
GrMeshDrawOp
:
public
GrDrawOp
{
public
:
class
Target
;
protected
:
GrMeshDrawOp
(
uint32_t
classID
)
;
class
PatternHelper
{
public
:
PatternHelper
(
Target
*
GrPrimitiveType
size_t
vertexStride
sk_sp
<
const
GrBuffer
>
indexBuffer
int
verticesPerRepetition
int
indicesPerRepetition
int
repeatCount
)
;
void
recordDraw
(
Target
*
sk_sp
<
const
GrGeometryProcessor
>
)
const
;
void
recordDraw
(
Target
*
sk_sp
<
const
GrGeometryProcessor
>
const
GrPipeline
:
:
FixedDynamicState
*
)
const
;
void
*
vertices
(
)
const
{
return
fVertices
;
}
protected
:
PatternHelper
(
)
=
default
;
void
init
(
Target
*
GrPrimitiveType
size_t
vertexStride
sk_sp
<
const
GrBuffer
>
indexBuffer
int
verticesPerRepetition
int
indicesPerRepetition
int
repeatCount
)
;
private
:
void
*
fVertices
=
nullptr
;
GrMesh
*
fMesh
=
nullptr
;
}
;
static
const
int
kVerticesPerQuad
=
4
;
static
const
int
kIndicesPerQuad
=
6
;
class
QuadHelper
:
private
PatternHelper
{
public
:
QuadHelper
(
)
=
delete
;
QuadHelper
(
Target
*
target
size_t
vertexStride
int
quadsToDraw
)
;
using
PatternHelper
:
:
recordDraw
;
using
PatternHelper
:
:
vertices
;
private
:
typedef
PatternHelper
INHERITED
;
}
;
private
:
void
onPrepare
(
GrOpFlushState
*
state
)
final
;
virtual
void
onPrepareDraws
(
Target
*
)
=
0
;
typedef
GrDrawOp
INHERITED
;
}
;
class
GrMeshDrawOp
:
:
Target
{
public
:
virtual
~
Target
(
)
{
}
virtual
void
recordDraw
(
sk_sp
<
const
GrGeometryProcessor
>
const
GrMesh
[
]
int
meshCnt
const
GrPipeline
:
:
FixedDynamicState
*
const
GrPipeline
:
:
DynamicStateArrays
*
)
=
0
;
void
recordDraw
(
sk_sp
<
const
GrGeometryProcessor
>
gp
const
GrMesh
meshes
[
]
int
meshCnt
=
1
)
{
static
constexpr
int
kZeroPrimProcTextures
=
0
;
auto
fixedDynamicState
=
this
-
>
makeFixedDynamicState
(
kZeroPrimProcTextures
)
;
this
-
>
recordDraw
(
std
:
:
move
(
gp
)
meshes
meshCnt
fixedDynamicState
nullptr
)
;
}
virtual
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
)
=
0
;
virtual
uint16_t
*
makeIndexSpace
(
int
indexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
)
=
0
;
virtual
void
*
makeVertexSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
int
*
actualVertexCount
)
=
0
;
virtual
uint16_t
*
makeIndexSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
int
*
actualIndexCount
)
=
0
;
virtual
void
putBackIndices
(
int
indices
)
=
0
;
virtual
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
=
0
;
GrMesh
*
allocMesh
(
GrPrimitiveType
primitiveType
)
{
return
this
-
>
allocator
(
)
-
>
make
<
GrMesh
>
(
primitiveType
)
;
}
GrMesh
*
allocMeshes
(
int
n
)
{
return
this
-
>
allocator
(
)
-
>
makeArray
<
GrMesh
>
(
n
)
;
}
GrPipeline
:
:
DynamicStateArrays
*
allocDynamicStateArrays
(
int
numMeshes
int
numPrimitiveProcessorTextures
bool
allocScissors
)
;
GrPipeline
:
:
FixedDynamicState
*
makeFixedDynamicState
(
int
numPrimitiveProcessorTextures
)
;
virtual
GrRenderTargetProxy
*
proxy
(
)
const
=
0
;
virtual
const
GrAppliedClip
*
appliedClip
(
)
=
0
;
virtual
GrAppliedClip
detachAppliedClip
(
)
=
0
;
virtual
const
GrXferProcessor
:
:
DstProxy
&
dstProxy
(
)
const
=
0
;
virtual
GrResourceProvider
*
resourceProvider
(
)
const
=
0
;
uint32_t
contextUniqueID
(
)
const
{
return
this
-
>
resourceProvider
(
)
-
>
contextUniqueID
(
)
;
}
virtual
GrStrikeCache
*
glyphCache
(
)
const
=
0
;
virtual
GrAtlasManager
*
atlasManager
(
)
const
=
0
;
virtual
const
GrCaps
&
caps
(
)
const
=
0
;
virtual
GrDeferredUploadTarget
*
deferredUploadTarget
(
)
=
0
;
private
:
virtual
SkArenaAlloc
*
allocator
(
)
=
0
;
}
;
#
endif
