#
ifndef
GrMeshDrawOp_DEFINED
#
define
GrMeshDrawOp_DEFINED
#
include
"
GrDrawOp
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrPendingProgramElement
.
h
"
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
SkTLList
.
h
"
class
GrCaps
;
class
GrOpFlushState
;
class
GrMeshDrawOp
:
public
GrDrawOp
{
public
:
class
Target
;
protected
:
GrMeshDrawOp
(
uint32_t
classID
)
;
class
InstancedHelper
{
public
:
InstancedHelper
(
)
{
}
void
*
init
(
Target
*
GrPrimitiveType
size_t
vertexStride
const
GrBuffer
*
int
verticesPerInstance
int
indicesPerInstance
int
instancesToDraw
)
;
void
recordDraw
(
Target
*
const
GrGeometryProcessor
*
const
GrPipeline
*
)
;
private
:
GrMesh
fMesh
;
}
;
static
const
int
kVerticesPerQuad
=
4
;
static
const
int
kIndicesPerQuad
=
6
;
class
QuadHelper
:
private
InstancedHelper
{
public
:
QuadHelper
(
)
:
INHERITED
(
)
{
}
void
*
init
(
Target
*
size_t
vertexStride
int
quadsToDraw
)
;
using
InstancedHelper
:
:
recordDraw
;
private
:
typedef
InstancedHelper
INHERITED
;
}
;
private
:
void
onPrepare
(
GrOpFlushState
*
state
)
final
override
;
void
onExecute
(
GrOpFlushState
*
state
)
final
override
;
virtual
void
onPrepareDraws
(
Target
*
)
const
=
0
;
struct
QueuedDraw
{
int
fMeshCnt
=
0
;
GrPendingProgramElement
<
const
GrGeometryProcessor
>
fGeometryProcessor
;
const
GrPipeline
*
fPipeline
;
}
;
GrDrawOpUploadToken
fBaseDrawToken
;
SkSTArray
<
4
GrMesh
>
fMeshes
;
SkSTArray
<
4
QueuedDraw
true
>
fQueuedDraws
;
typedef
GrDrawOp
INHERITED
;
}
;
class
GrLegacyMeshDrawOp
:
public
GrMeshDrawOp
{
public
:
GrProcessorSet
:
:
Analysis
analyzeUpdateAndRecordProcessors
(
GrPipelineBuilder
*
pipelineBuilder
const
GrAppliedClip
*
appliedClip
bool
isMixedSamples
const
GrCaps
&
caps
GrColor
*
overrideColor
)
const
{
GrProcessorAnalysisColor
inputColor
;
GrProcessorAnalysisCoverage
inputCoverage
;
this
-
>
getProcessorAnalysisInputs
(
&
inputColor
&
inputCoverage
)
;
return
pipelineBuilder
-
>
finalizeProcessors
(
inputColor
inputCoverage
appliedClip
isMixedSamples
caps
overrideColor
)
;
}
void
initPipeline
(
const
GrPipeline
:
:
InitArgs
&
args
const
GrProcessorSet
:
:
Analysis
&
analysis
GrColor
overrideColor
)
{
fPipeline
.
init
(
args
)
;
this
-
>
applyPipelineOptimizations
(
PipelineOptimizations
(
analysis
overrideColor
)
)
;
}
FixedFunctionFlags
fixedFunctionFlags
(
)
const
override
{
SkFAIL
(
"
This
should
never
be
called
for
legacy
mesh
draw
ops
.
"
)
;
return
FixedFunctionFlags
:
:
kNone
;
}
bool
xpRequiresDstTexture
(
const
GrCaps
&
const
GrAppliedClip
*
)
override
{
SkFAIL
(
"
Should
never
be
called
for
legacy
mesh
draw
ops
.
"
)
;
return
false
;
}
protected
:
GrLegacyMeshDrawOp
(
uint32_t
classID
)
:
INHERITED
(
classID
)
{
}
class
PipelineOptimizations
{
public
:
PipelineOptimizations
(
const
GrProcessorSet
:
:
Analysis
&
analysis
GrColor
overrideColor
)
{
fFlags
=
0
;
if
(
analysis
.
inputColorIsOverridden
(
)
)
{
fFlags
|
=
kUseOverrideColor_Flag
;
fOverrideColor
=
overrideColor
;
}
if
(
analysis
.
usesLocalCoords
(
)
)
{
fFlags
|
=
kReadsLocalCoords_Flag
;
}
if
(
analysis
.
isCompatibleWithCoverageAsAlpha
(
)
)
{
fFlags
|
=
kCanTweakAlphaForCoverage_Flag
;
}
}
bool
readsLocalCoords
(
)
const
{
return
SkToBool
(
kReadsLocalCoords_Flag
&
fFlags
)
;
}
bool
canTweakAlphaForCoverage
(
)
const
{
return
SkToBool
(
kCanTweakAlphaForCoverage_Flag
&
fFlags
)
;
}
bool
getOverrideColorIfSet
(
GrColor
*
overrideColor
)
const
{
if
(
SkToBool
(
kUseOverrideColor_Flag
&
fFlags
)
)
{
if
(
overrideColor
)
{
*
overrideColor
=
fOverrideColor
;
}
return
true
;
}
return
false
;
}
private
:
enum
{
kReadsLocalCoords_Flag
=
0x1
kCanTweakAlphaForCoverage_Flag
=
0x2
kUseOverrideColor_Flag
=
0x4
}
;
uint32_t
fFlags
;
GrColor
fOverrideColor
;
}
;
const
GrPipeline
*
pipeline
(
)
const
{
SkASSERT
(
fPipeline
.
isInitialized
(
)
)
;
return
&
fPipeline
;
}
private
:
virtual
void
getProcessorAnalysisInputs
(
GrProcessorAnalysisColor
*
GrProcessorAnalysisCoverage
*
)
const
=
0
;
virtual
void
applyPipelineOptimizations
(
const
PipelineOptimizations
&
)
=
0
;
GrPipeline
fPipeline
;
typedef
GrMeshDrawOp
INHERITED
;
}
;
#
endif
