#
ifndef
GrQuadPerEdgeAA_DEFINED
#
define
GrQuadPerEdgeAA_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrMeshDrawOp
.
h
"
#
include
"
GrQuad
.
h
"
#
include
"
GrSamplerState
.
h
"
#
include
"
GrTypesPriv
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkPoint3
.
h
"
class
GrColorSpaceXform
;
class
GrShaderCaps
;
namespace
GrQuadPerEdgeAA
{
enum
class
Domain
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
ColorType
{
kNone
kByte
kHalf
kLast
=
kHalf
}
;
static
const
int
kColorTypeCount
=
static_cast
<
int
>
(
ColorType
:
:
kLast
)
+
1
;
struct
VertexSpec
{
public
:
VertexSpec
(
GrQuadType
deviceQuadType
ColorType
colorType
GrQuadType
localQuadType
bool
hasLocalCoords
Domain
domain
GrAAType
aa
bool
alphaAsCoverage
)
:
fDeviceQuadType
(
static_cast
<
unsigned
>
(
deviceQuadType
)
)
fLocalQuadType
(
static_cast
<
unsigned
>
(
localQuadType
)
)
fHasLocalCoords
(
hasLocalCoords
)
fColorType
(
static_cast
<
unsigned
>
(
colorType
)
)
fHasDomain
(
static_cast
<
unsigned
>
(
domain
)
)
fUsesCoverageAA
(
aa
=
=
GrAAType
:
:
kCoverage
)
fCompatibleWithAlphaAsCoverage
(
alphaAsCoverage
)
{
}
GrQuadType
deviceQuadType
(
)
const
{
return
static_cast
<
GrQuadType
>
(
fDeviceQuadType
)
;
}
GrQuadType
localQuadType
(
)
const
{
return
static_cast
<
GrQuadType
>
(
fLocalQuadType
)
;
}
bool
hasLocalCoords
(
)
const
{
return
fHasLocalCoords
;
}
ColorType
colorType
(
)
const
{
return
static_cast
<
ColorType
>
(
fColorType
)
;
}
bool
hasVertexColors
(
)
const
{
return
ColorType
:
:
kNone
!
=
this
-
>
colorType
(
)
;
}
bool
hasDomain
(
)
const
{
return
fHasDomain
;
}
bool
usesCoverageAA
(
)
const
{
return
fUsesCoverageAA
;
}
bool
compatibleWithAlphaAsCoverage
(
)
const
{
return
fCompatibleWithAlphaAsCoverage
;
}
int
deviceDimensionality
(
)
const
;
int
localDimensionality
(
)
const
;
int
verticesPerQuad
(
)
const
{
return
fUsesCoverageAA
?
8
:
4
;
}
private
:
static_assert
(
kGrQuadTypeCount
<
=
4
"
GrQuadType
doesn
'
t
fit
in
2
bits
"
)
;
static_assert
(
kColorTypeCount
<
=
4
"
Color
doesn
'
t
fit
in
2
bits
"
)
;
unsigned
fDeviceQuadType
:
2
;
unsigned
fLocalQuadType
:
2
;
unsigned
fHasLocalCoords
:
1
;
unsigned
fColorType
:
2
;
unsigned
fHasDomain
:
1
;
unsigned
fUsesCoverageAA
:
1
;
unsigned
fCompatibleWithAlphaAsCoverage
:
1
;
}
;
sk_sp
<
GrGeometryProcessor
>
MakeProcessor
(
const
VertexSpec
&
spec
)
;
sk_sp
<
GrGeometryProcessor
>
MakeTexturedProcessor
(
const
VertexSpec
&
spec
const
GrShaderCaps
&
caps
GrTextureType
textureType
GrPixelConfig
textureConfig
const
GrSamplerState
&
samplerState
uint32_t
extraSamplerKey
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
)
;
void
*
Tessellate
(
void
*
vertices
const
VertexSpec
&
spec
const
GrPerspQuad
&
deviceQuad
const
SkPMColor4f
&
color
const
GrPerspQuad
&
localQuad
const
SkRect
&
domain
GrQuadAAFlags
aa
)
;
bool
ConfigureMeshIndices
(
GrMeshDrawOp
:
:
Target
*
target
GrMesh
*
mesh
const
VertexSpec
&
spec
int
quadCount
)
;
static
constexpr
int
kNumAAQuadsInIndexBuffer
=
512
;
}
#
endif
