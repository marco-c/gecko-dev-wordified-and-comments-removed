#
ifndef
GrSimpleMeshDrawOpHelper_DEFINED
#
define
GrSimpleMeshDrawOpHelper_DEFINED
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrPipeline
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrMeshDrawOp
.
h
"
#
include
<
new
>
struct
SkRect
;
class
GrSimpleMeshDrawOpHelper
{
public
:
struct
MakeArgs
;
template
<
typename
Op
typename
.
.
.
OpArgs
>
static
std
:
:
unique_ptr
<
GrDrawOp
>
FactoryHelper
(
GrRecordingContext
*
GrPaint
&
&
OpArgs
.
.
.
)
;
enum
class
InputFlags
:
uint8_t
{
kNone
=
0
kSnapVerticesToPixelCenters
=
(
uint8_t
)
GrPipeline
:
:
InputFlags
:
:
kSnapVerticesToPixelCenters
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
InputFlags
)
;
GrSimpleMeshDrawOpHelper
(
const
MakeArgs
&
GrAAType
InputFlags
=
InputFlags
:
:
kNone
)
;
~
GrSimpleMeshDrawOpHelper
(
)
;
GrSimpleMeshDrawOpHelper
(
)
=
delete
;
GrSimpleMeshDrawOpHelper
(
const
GrSimpleMeshDrawOpHelper
&
)
=
delete
;
GrSimpleMeshDrawOpHelper
&
operator
=
(
const
GrSimpleMeshDrawOpHelper
&
)
=
delete
;
GrDrawOp
:
:
FixedFunctionFlags
fixedFunctionFlags
(
)
const
;
bool
isCompatible
(
const
GrSimpleMeshDrawOpHelper
&
that
const
GrCaps
&
const
SkRect
&
thisBounds
const
SkRect
&
thatBounds
bool
noneAACompatibleWithCoverage
=
false
)
const
;
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
bool
hasMixedSampledCoverage
GrClampType
clampType
GrProcessorAnalysisCoverage
geometryCoverage
GrProcessorAnalysisColor
*
geometryColor
)
{
return
this
-
>
finalizeProcessors
(
caps
clip
&
GrUserStencilSettings
:
:
kUnused
hasMixedSampledCoverage
clampType
geometryCoverage
geometryColor
)
;
}
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
const
GrAppliedClip
*
bool
hasMixedSampledCoverage
GrClampType
GrProcessorAnalysisCoverage
geometryCoverage
SkPMColor4f
*
geometryColor
bool
*
wideColor
)
;
bool
isTrivial
(
)
const
{
return
fProcessors
=
=
nullptr
;
}
bool
usesLocalCoords
(
)
const
{
SkASSERT
(
fDidAnalysis
)
;
return
fUsesLocalCoords
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
struct
MakeArgs
{
private
:
MakeArgs
(
)
=
default
;
GrProcessorSet
*
fProcessorSet
;
friend
class
GrSimpleMeshDrawOpHelper
;
}
;
void
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
func
)
const
{
if
(
fProcessors
)
{
fProcessors
-
>
visitProxies
(
func
)
;
}
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
;
#
endif
GrAAType
aaType
(
)
const
{
return
static_cast
<
GrAAType
>
(
fAAType
)
;
}
void
setAAType
(
GrAAType
aaType
)
{
fAAType
=
static_cast
<
unsigned
>
(
aaType
)
;
}
void
executeDrawsAndUploads
(
const
GrOp
*
GrOpFlushState
*
const
SkRect
&
chainBounds
)
;
protected
:
GrPipeline
:
:
InputFlags
pipelineFlags
(
)
const
{
return
fPipelineFlags
;
}
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
caps
const
GrAppliedClip
*
const
GrUserStencilSettings
*
bool
hasMixedSampledCoverage
GrClampType
GrProcessorAnalysisCoverage
geometryCoverage
GrProcessorAnalysisColor
*
geometryColor
)
;
GrProcessorSet
*
fProcessors
;
GrPipeline
:
:
InputFlags
fPipelineFlags
;
unsigned
fAAType
:
2
;
unsigned
fUsesLocalCoords
:
1
;
unsigned
fCompatibleWithCoverageAsAlpha
:
1
;
SkDEBUGCODE
(
unsigned
fMadePipeline
:
1
;
)
SkDEBUGCODE
(
unsigned
fDidAnalysis
:
1
;
)
}
;
class
GrSimpleMeshDrawOpHelperWithStencil
:
private
GrSimpleMeshDrawOpHelper
{
public
:
using
MakeArgs
=
GrSimpleMeshDrawOpHelper
:
:
MakeArgs
;
using
InputFlags
=
GrSimpleMeshDrawOpHelper
:
:
InputFlags
;
using
GrSimpleMeshDrawOpHelper
:
:
visitProxies
;
template
<
typename
Op
typename
.
.
.
OpArgs
>
static
std
:
:
unique_ptr
<
GrDrawOp
>
FactoryHelper
(
GrRecordingContext
*
context
GrPaint
&
&
paint
OpArgs
.
.
.
opArgs
)
{
return
GrSimpleMeshDrawOpHelper
:
:
FactoryHelper
<
Op
OpArgs
.
.
.
>
(
context
std
:
:
move
(
paint
)
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
;
}
GrSimpleMeshDrawOpHelperWithStencil
(
const
MakeArgs
&
GrAAType
const
GrUserStencilSettings
*
InputFlags
=
InputFlags
:
:
kNone
)
;
GrDrawOp
:
:
FixedFunctionFlags
fixedFunctionFlags
(
)
const
;
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
bool
hasMixedSampledCoverage
GrClampType
clampType
GrProcessorAnalysisCoverage
geometryCoverage
GrProcessorAnalysisColor
*
geometryColor
)
{
return
this
-
>
INHERITED
:
:
finalizeProcessors
(
caps
clip
fStencilSettings
hasMixedSampledCoverage
clampType
geometryCoverage
geometryColor
)
;
}
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
const
GrAppliedClip
*
bool
hasMixedSampledCoverage
GrClampType
GrProcessorAnalysisCoverage
geometryCoverage
SkPMColor4f
*
geometryColor
bool
*
wideColor
)
;
using
GrSimpleMeshDrawOpHelper
:
:
aaType
;
using
GrSimpleMeshDrawOpHelper
:
:
setAAType
;
using
GrSimpleMeshDrawOpHelper
:
:
isTrivial
;
using
GrSimpleMeshDrawOpHelper
:
:
usesLocalCoords
;
using
GrSimpleMeshDrawOpHelper
:
:
compatibleWithCoverageAsAlpha
;
bool
isCompatible
(
const
GrSimpleMeshDrawOpHelperWithStencil
&
that
const
GrCaps
&
const
SkRect
&
thisBounds
const
SkRect
&
thatBounds
bool
noneAACompatibleWithCoverage
=
false
)
const
;
void
executeDrawsAndUploads
(
const
GrOp
*
GrOpFlushState
*
const
SkRect
&
chainBounds
)
;
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
;
#
endif
private
:
const
GrUserStencilSettings
*
fStencilSettings
;
typedef
GrSimpleMeshDrawOpHelper
INHERITED
;
}
;
template
<
typename
Op
typename
.
.
.
OpArgs
>
std
:
:
unique_ptr
<
GrDrawOp
>
GrSimpleMeshDrawOpHelper
:
:
FactoryHelper
(
GrRecordingContext
*
context
GrPaint
&
&
paint
OpArgs
.
.
.
opArgs
)
{
GrOpMemoryPool
*
pool
=
context
-
>
priv
(
)
.
opMemoryPool
(
)
;
MakeArgs
makeArgs
;
if
(
paint
.
isTrivial
(
)
)
{
makeArgs
.
fProcessorSet
=
nullptr
;
return
pool
-
>
allocate
<
Op
>
(
makeArgs
paint
.
getColor4f
(
)
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
;
}
else
{
char
*
mem
=
(
char
*
)
pool
-
>
allocate
(
sizeof
(
Op
)
+
sizeof
(
GrProcessorSet
)
)
;
char
*
setMem
=
mem
+
sizeof
(
Op
)
;
auto
color
=
paint
.
getColor4f
(
)
;
makeArgs
.
fProcessorSet
=
new
(
setMem
)
GrProcessorSet
(
std
:
:
move
(
paint
)
)
;
return
std
:
:
unique_ptr
<
GrDrawOp
>
(
new
(
mem
)
Op
(
makeArgs
color
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
)
;
}
}
GR_MAKE_BITFIELD_CLASS_OPS
(
GrSimpleMeshDrawOpHelper
:
:
InputFlags
)
#
endif
