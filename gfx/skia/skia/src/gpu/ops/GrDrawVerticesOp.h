#
ifndef
GrDrawVerticesOp_DEFINED
#
define
GrDrawVerticesOp_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrMeshDrawOp
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkVertices
.
h
"
class
GrOpFlushState
;
class
SkVertices
;
struct
GrInitInvariantOutput
;
class
GrDrawVerticesOp
final
:
public
GrLegacyMeshDrawOp
{
public
:
DEFINE_OP_CLASS_ID
enum
{
kIgnoreTexCoords_VerticesFlag
=
1
<
<
0
kIgnoreColors_VerticesFlag
=
1
<
<
1
}
;
static
std
:
:
unique_ptr
<
GrLegacyMeshDrawOp
>
Make
(
GrColor
color
GrPrimitiveType
primitiveType
const
SkMatrix
&
viewMatrix
const
SkPoint
*
positions
int
vertexCount
const
uint16_t
*
indices
int
indexCount
const
uint32_t
*
colors
const
SkPoint
*
localCoords
const
SkRect
&
bounds
GrRenderTargetContext
:
:
ColorArrayType
colorArrayType
)
;
static
std
:
:
unique_ptr
<
GrLegacyMeshDrawOp
>
Make
(
GrColor
color
sk_sp
<
SkVertices
>
const
SkMatrix
&
viewMatrix
)
;
const
char
*
name
(
)
const
override
{
return
"
DrawVerticesOp
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
string
;
string
.
appendf
(
"
PrimType
:
%
d
MeshCount
%
d
VCount
:
%
d
ICount
:
%
d
\
n
"
fPrimitiveType
fMeshes
.
count
(
)
fVertexCount
fIndexCount
)
;
string
.
append
(
DumpPipelineInfo
(
*
this
-
>
pipeline
(
)
)
)
;
string
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
string
;
}
private
:
GrDrawVerticesOp
(
sk_sp
<
SkVertices
>
GrPrimitiveType
GrColor
GrRenderTargetContext
:
:
ColorArrayType
const
SkMatrix
&
viewMatrix
uint32_t
flags
=
0
)
;
void
getProcessorAnalysisInputs
(
GrProcessorAnalysisColor
*
color
GrProcessorAnalysisCoverage
*
coverage
)
const
override
;
void
applyPipelineOptimizations
(
const
PipelineOptimizations
&
)
override
;
void
onPrepareDraws
(
Target
*
)
const
override
;
sk_sp
<
GrGeometryProcessor
>
makeGP
(
bool
*
hasColorAttribute
bool
*
hasLocalCoordAttribute
)
const
;
GrPrimitiveType
primitiveType
(
)
const
{
return
fPrimitiveType
;
}
bool
combinablePrimitive
(
)
const
{
return
kTriangles_GrPrimitiveType
=
=
fPrimitiveType
|
|
kLines_GrPrimitiveType
=
=
fPrimitiveType
|
|
kPoints_GrPrimitiveType
=
=
fPrimitiveType
;
}
bool
onCombineIfPossible
(
GrOp
*
t
const
GrCaps
&
)
override
;
struct
Mesh
{
GrColor
fColor
;
sk_sp
<
SkVertices
>
fVertices
;
SkMatrix
fViewMatrix
;
uint32_t
fFlags
;
bool
hasExplicitLocalCoords
(
)
const
{
return
fVertices
-
>
hasTexCoords
(
)
&
&
!
(
kIgnoreTexCoords_VerticesFlag
&
fFlags
)
;
}
bool
hasPerVertexColors
(
)
const
{
return
fVertices
-
>
hasColors
(
)
&
&
!
(
kIgnoreColors_VerticesFlag
&
fFlags
)
;
}
}
;
bool
isIndexed
(
)
const
{
return
fMeshes
[
0
]
.
fVertices
-
>
hasIndices
(
)
;
}
bool
requiresPerVertexColors
(
)
const
{
return
SkToBool
(
kRequiresPerVertexColors_Flag
&
fFlags
)
;
}
bool
anyMeshHasExplicitLocalCoords
(
)
const
{
return
SkToBool
(
kAnyMeshHasExplicitLocalCoords
&
fFlags
)
;
}
bool
pipelineRequiresLocalCoords
(
)
const
{
return
SkToBool
(
kPipelineRequiresLocalCoords_Flag
&
fFlags
)
;
}
bool
hasMultipleViewMatrices
(
)
const
{
return
SkToBool
(
kHasMultipleViewMatrices_Flag
&
fFlags
)
;
}
enum
Flags
{
kRequiresPerVertexColors_Flag
=
0x1
kAnyMeshHasExplicitLocalCoords
=
0x2
kPipelineRequiresLocalCoords_Flag
=
0x4
kHasMultipleViewMatrices_Flag
=
0x8
}
;
GrPrimitiveType
fPrimitiveType
;
uint32_t
fFlags
;
int
fVertexCount
;
int
fIndexCount
;
GrRenderTargetContext
:
:
ColorArrayType
fColorArrayType
;
SkSTArray
<
1
Mesh
true
>
fMeshes
;
typedef
GrLegacyMeshDrawOp
INHERITED
;
}
;
#
endif
