#
ifndef
GrClearOp_DEFINED
#
define
GrClearOp_DEFINED
#
include
"
GrFixedClip
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrOp
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrRenderTarget
.
h
"
class
GrClearOp
final
:
public
GrOp
{
public
:
DEFINE_OP_CLASS_ID
static
std
:
:
unique_ptr
<
GrClearOp
>
Make
(
const
GrFixedClip
&
clip
GrColor
color
GrRenderTargetContext
*
rtc
)
{
const
SkIRect
rtRect
=
SkIRect
:
:
MakeWH
(
rtc
-
>
width
(
)
rtc
-
>
height
(
)
)
;
if
(
clip
.
scissorEnabled
(
)
&
&
!
SkIRect
:
:
Intersects
(
clip
.
scissorRect
(
)
rtRect
)
)
{
return
nullptr
;
}
if
(
!
rtc
-
>
accessRenderTarget
(
)
)
{
return
nullptr
;
}
return
std
:
:
unique_ptr
<
GrClearOp
>
(
new
GrClearOp
(
clip
color
rtc
)
)
;
}
static
std
:
:
unique_ptr
<
GrClearOp
>
Make
(
const
SkIRect
&
rect
GrColor
color
GrRenderTargetContext
*
rtc
bool
fullScreen
)
{
SkASSERT
(
fullScreen
|
|
!
rect
.
isEmpty
(
)
)
;
if
(
!
rtc
-
>
accessRenderTarget
(
)
)
{
return
nullptr
;
}
return
std
:
:
unique_ptr
<
GrClearOp
>
(
new
GrClearOp
(
rect
color
rtc
fullScreen
)
)
;
}
const
char
*
name
(
)
const
override
{
return
"
Clear
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
string
;
string
.
appendf
(
"
rtID
:
%
d
proxyID
:
%
d
Scissor
[
"
fRenderTarget
.
get
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
fProxyUniqueID
.
asUInt
(
)
)
;
if
(
fClip
.
scissorEnabled
(
)
)
{
const
SkIRect
&
r
=
fClip
.
scissorRect
(
)
;
string
.
appendf
(
"
L
:
%
d
T
:
%
d
R
:
%
d
B
:
%
d
"
r
.
fLeft
r
.
fTop
r
.
fRight
r
.
fBottom
)
;
}
else
{
string
.
append
(
"
disabled
"
)
;
}
string
.
appendf
(
"
]
Color
:
0x
%
08x
"
fColor
)
;
string
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
string
;
}
void
setColor
(
GrColor
color
)
{
fColor
=
color
;
}
private
:
GrClearOp
(
const
GrFixedClip
&
clip
GrColor
color
GrRenderTargetContext
*
rtc
)
:
INHERITED
(
ClassID
(
)
)
fClip
(
clip
)
fColor
(
color
)
fProxyUniqueID
(
rtc
-
>
asSurfaceProxy
(
)
-
>
uniqueID
(
)
)
{
GrSurfaceProxy
*
proxy
=
rtc
-
>
asSurfaceProxy
(
)
;
const
SkIRect
rtRect
=
SkIRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
if
(
fClip
.
scissorEnabled
(
)
)
{
if
(
!
fClip
.
intersect
(
rtRect
)
)
{
SkASSERT
(
0
)
;
fClip
=
GrFixedClip
(
SkIRect
:
:
MakeEmpty
(
)
)
;
}
if
(
GrResourceProvider
:
:
IsFunctionallyExact
(
proxy
)
&
&
fClip
.
scissorRect
(
)
=
=
rtRect
)
{
fClip
.
disableScissor
(
)
;
}
}
this
-
>
setBounds
(
SkRect
:
:
Make
(
fClip
.
scissorEnabled
(
)
?
fClip
.
scissorRect
(
)
:
rtRect
)
HasAABloat
:
:
kNo
IsZeroArea
:
:
kNo
)
;
fRenderTarget
.
reset
(
rtc
-
>
accessRenderTarget
(
)
)
;
}
GrClearOp
(
const
SkIRect
&
rect
GrColor
color
GrRenderTargetContext
*
rtc
bool
fullScreen
)
:
INHERITED
(
ClassID
(
)
)
fClip
(
GrFixedClip
(
rect
)
)
fColor
(
color
)
fProxyUniqueID
(
rtc
-
>
asSurfaceProxy
(
)
-
>
uniqueID
(
)
)
{
if
(
fullScreen
)
{
fClip
.
disableScissor
(
)
;
}
this
-
>
setBounds
(
SkRect
:
:
Make
(
rect
)
HasAABloat
:
:
kNo
IsZeroArea
:
:
kNo
)
;
fRenderTarget
.
reset
(
rtc
-
>
accessRenderTarget
(
)
)
;
}
bool
onCombineIfPossible
(
GrOp
*
t
const
GrCaps
&
caps
)
override
{
GrClearOp
*
cb
=
t
-
>
cast
<
GrClearOp
>
(
)
;
SkASSERT
(
cb
-
>
fRenderTarget
=
=
fRenderTarget
)
;
SkASSERT
(
cb
-
>
fProxyUniqueID
=
=
fProxyUniqueID
)
;
if
(
fClip
.
windowRectsState
(
)
!
=
cb
-
>
fClip
.
windowRectsState
(
)
)
{
return
false
;
}
if
(
cb
-
>
contains
(
this
)
)
{
fClip
=
cb
-
>
fClip
;
this
-
>
replaceBounds
(
*
t
)
;
fColor
=
cb
-
>
fColor
;
return
true
;
}
else
if
(
cb
-
>
fColor
=
=
fColor
&
&
this
-
>
contains
(
cb
)
)
{
return
true
;
}
return
false
;
}
bool
contains
(
const
GrClearOp
*
that
)
const
{
return
!
fClip
.
scissorEnabled
(
)
|
|
(
that
-
>
fClip
.
scissorEnabled
(
)
&
&
fClip
.
scissorRect
(
)
.
contains
(
that
-
>
fClip
.
scissorRect
(
)
)
)
;
}
void
onPrepare
(
GrOpFlushState
*
)
override
{
}
void
onExecute
(
GrOpFlushState
*
state
)
override
{
state
-
>
commandBuffer
(
)
-
>
clear
(
fRenderTarget
.
get
(
)
fClip
fColor
)
;
}
GrFixedClip
fClip
;
GrColor
fColor
;
GrSurfaceProxy
:
:
UniqueID
fProxyUniqueID
;
GrPendingIOResource
<
GrRenderTarget
kWrite_GrIOType
>
fRenderTarget
;
typedef
GrOp
INHERITED
;
}
;
#
endif
