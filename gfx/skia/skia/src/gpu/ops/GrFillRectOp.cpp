#
include
"
src
/
gpu
/
ops
/
GrFillRectOp
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
GrPaint
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuadBuffer
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLColorSpaceXformHelper
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVarying
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrMeshDrawOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrQuadPerEdgeAA
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrSimpleMeshDrawOpHelper
.
h
"
namespace
{
using
VertexSpec
=
GrQuadPerEdgeAA
:
:
VertexSpec
;
using
ColorType
=
GrQuadPerEdgeAA
:
:
ColorType
;
#
ifdef
SK_DEBUG
static
SkString
dump_quad_info
(
int
index
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
SkPMColor4f
&
color
GrQuadAAFlags
aaFlags
)
{
SkString
str
;
str
.
appendf
(
"
%
d
:
Color
:
[
%
.
2f
%
.
2f
%
.
2f
%
.
2f
]
Edge
AA
:
l
%
u_t
%
u_r
%
u_b
%
u
\
n
"
"
device
quad
:
[
(
%
.
2f
%
2
.
f
%
.
2f
)
(
%
.
2f
%
.
2f
%
.
2f
)
(
%
.
2f
%
.
2f
%
.
2f
)
"
"
(
%
.
2f
%
.
2f
%
.
2f
)
]
\
n
"
"
local
quad
:
[
(
%
.
2f
%
2
.
f
%
.
2f
)
(
%
.
2f
%
.
2f
%
.
2f
)
(
%
.
2f
%
.
2f
%
.
2f
)
"
"
(
%
.
2f
%
.
2f
%
.
2f
)
]
\
n
"
index
color
.
fR
color
.
fG
color
.
fB
color
.
fA
(
uint32_t
)
(
aaFlags
&
GrQuadAAFlags
:
:
kLeft
)
(
uint32_t
)
(
aaFlags
&
GrQuadAAFlags
:
:
kTop
)
(
uint32_t
)
(
aaFlags
&
GrQuadAAFlags
:
:
kRight
)
(
uint32_t
)
(
aaFlags
&
GrQuadAAFlags
:
:
kBottom
)
deviceQuad
.
x
(
0
)
deviceQuad
.
y
(
0
)
deviceQuad
.
w
(
0
)
deviceQuad
.
x
(
1
)
deviceQuad
.
y
(
1
)
deviceQuad
.
w
(
1
)
deviceQuad
.
x
(
2
)
deviceQuad
.
y
(
2
)
deviceQuad
.
w
(
2
)
deviceQuad
.
x
(
3
)
deviceQuad
.
y
(
3
)
deviceQuad
.
w
(
3
)
localQuad
.
x
(
0
)
localQuad
.
y
(
0
)
localQuad
.
w
(
0
)
localQuad
.
x
(
1
)
localQuad
.
y
(
1
)
localQuad
.
w
(
1
)
localQuad
.
x
(
2
)
localQuad
.
y
(
2
)
localQuad
.
w
(
2
)
localQuad
.
x
(
3
)
localQuad
.
y
(
3
)
localQuad
.
w
(
3
)
)
;
return
str
;
}
#
endif
class
FillRectOp
final
:
public
GrMeshDrawOp
{
private
:
using
Helper
=
GrSimpleMeshDrawOpHelperWithStencil
;
public
:
static
std
:
:
unique_ptr
<
GrDrawOp
>
Make
(
GrRecordingContext
*
context
GrPaint
&
&
paint
GrAAType
aaType
GrQuadAAFlags
edgeAA
const
GrUserStencilSettings
*
stencilSettings
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
)
{
GrQuadUtils
:
:
ResolveAAType
(
aaType
edgeAA
deviceQuad
&
aaType
&
edgeAA
)
;
return
Helper
:
:
FactoryHelper
<
FillRectOp
>
(
context
std
:
:
move
(
paint
)
aaType
edgeAA
stencilSettings
deviceQuad
localQuad
)
;
}
FillRectOp
(
Helper
:
:
MakeArgs
args
SkPMColor4f
paintColor
GrAAType
aaType
GrQuadAAFlags
edgeFlags
const
GrUserStencilSettings
*
stencil
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
)
:
INHERITED
(
ClassID
(
)
)
fHelper
(
args
aaType
stencil
)
fQuads
(
1
!
fHelper
.
isTrivial
(
)
)
{
fQuads
.
append
(
deviceQuad
{
paintColor
edgeFlags
}
fHelper
.
isTrivial
(
)
?
nullptr
:
&
localQuad
)
;
this
-
>
setBounds
(
deviceQuad
.
bounds
(
)
HasAABloat
(
aaType
=
=
GrAAType
:
:
kCoverage
)
IsHairline
:
:
kNo
)
;
}
const
char
*
name
(
)
const
override
{
return
"
FillRectOp
"
;
}
void
visitProxies
(
const
VisitProxyFunc
&
func
)
const
override
{
return
fHelper
.
visitProxies
(
func
)
;
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
#
draws
:
%
u
\
n
"
fQuads
.
count
(
)
)
;
str
.
appendf
(
"
Device
quad
type
:
%
u
local
quad
type
:
%
u
\
n
"
(
uint32_t
)
fQuads
.
deviceQuadType
(
)
(
uint32_t
)
fQuads
.
localQuadType
(
)
)
;
str
+
=
fHelper
.
dumpInfo
(
)
;
int
i
=
0
;
auto
iter
=
fQuads
.
iterator
(
)
;
while
(
iter
.
next
(
)
)
{
const
ColorAndAA
&
info
=
iter
.
metadata
(
)
;
str
+
=
dump_quad_info
(
i
iter
.
deviceQuad
(
)
iter
.
localQuad
(
)
info
.
fColor
info
.
fAAFlags
)
;
i
+
+
;
}
str
+
=
INHERITED
:
:
dumpInfo
(
)
;
return
str
;
}
#
endif
GrProcessorSet
:
:
Analysis
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
bool
hasMixedSampledCoverage
GrClampType
clampType
)
override
{
auto
iter
=
fQuads
.
metadata
(
)
;
SkAssertResult
(
iter
.
next
(
)
)
;
GrProcessorAnalysisColor
quadColors
(
iter
-
>
fColor
)
;
while
(
iter
.
next
(
)
)
{
quadColors
=
GrProcessorAnalysisColor
:
:
Combine
(
quadColors
iter
-
>
fColor
)
;
if
(
quadColors
.
isUnknown
(
)
)
{
break
;
}
}
GrProcessorAnalysisCoverage
coverage
=
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kCoverage
?
GrProcessorAnalysisCoverage
:
:
kSingleChannel
:
GrProcessorAnalysisCoverage
:
:
kNone
;
auto
result
=
fHelper
.
finalizeProcessors
(
caps
clip
hasMixedSampledCoverage
clampType
coverage
&
quadColors
)
;
iter
=
fQuads
.
metadata
(
)
;
SkPMColor4f
colorOverride
;
if
(
quadColors
.
isConstant
(
&
colorOverride
)
)
{
fColorType
=
GrQuadPerEdgeAA
:
:
MinColorType
(
colorOverride
clampType
caps
)
;
while
(
iter
.
next
(
)
)
{
iter
-
>
fColor
=
colorOverride
;
}
}
else
{
fColorType
=
ColorType
:
:
kNone
;
while
(
iter
.
next
(
)
)
{
fColorType
=
SkTMax
(
fColorType
GrQuadPerEdgeAA
:
:
MinColorType
(
iter
-
>
fColor
clampType
caps
)
)
;
}
}
if
(
fColorType
=
=
ColorType
:
:
kNone
&
&
!
result
.
hasColorFragmentProcessor
(
)
)
{
fColorType
=
ColorType
:
:
kByte
;
}
return
result
;
}
FixedFunctionFlags
fixedFunctionFlags
(
)
const
override
{
return
fHelper
.
fixedFunctionFlags
(
)
;
}
DEFINE_OP_CLASS_ID
private
:
friend
std
:
:
unique_ptr
<
GrDrawOp
>
GrFillRectOp
:
:
MakeSet
(
GrRecordingContext
*
GrPaint
&
&
GrAAType
const
SkMatrix
&
viewMatrix
const
GrRenderTargetContext
:
:
QuadSetEntry
quads
[
]
int
quadCount
const
GrUserStencilSettings
*
)
;
void
onPrepareDraws
(
Target
*
target
)
override
{
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
using
Domain
=
GrQuadPerEdgeAA
:
:
Domain
;
static
constexpr
SkRect
kEmptyDomain
=
SkRect
:
:
MakeEmpty
(
)
;
VertexSpec
vertexSpec
(
fQuads
.
deviceQuadType
(
)
fColorType
fQuads
.
localQuadType
(
)
fHelper
.
usesLocalCoords
(
)
Domain
:
:
kNo
fHelper
.
aaType
(
)
fHelper
.
compatibleWithCoverageAsAlpha
(
)
)
;
SkASSERT
(
!
fHelper
.
isTrivial
(
)
|
|
!
fHelper
.
usesLocalCoords
(
)
)
;
sk_sp
<
GrGeometryProcessor
>
gp
=
GrQuadPerEdgeAA
:
:
MakeProcessor
(
vertexSpec
)
;
size_t
vertexSize
=
gp
-
>
vertexStride
(
)
;
sk_sp
<
const
GrBuffer
>
vbuffer
;
int
vertexOffsetInBuffer
=
0
;
void
*
vdata
=
target
-
>
makeVertexSpace
(
vertexSize
fQuads
.
count
(
)
*
vertexSpec
.
verticesPerQuad
(
)
&
vbuffer
&
vertexOffsetInBuffer
)
;
if
(
!
vdata
)
{
SkDebugf
(
"
Could
not
allocate
vertices
\
n
"
)
;
return
;
}
void
*
vertices
=
vdata
;
auto
iter
=
fQuads
.
iterator
(
)
;
while
(
iter
.
next
(
)
)
{
SkASSERT
(
iter
.
isLocalValid
(
)
!
=
fHelper
.
isTrivial
(
)
)
;
auto
info
=
iter
.
metadata
(
)
;
vertices
=
GrQuadPerEdgeAA
:
:
Tessellate
(
vertices
vertexSpec
iter
.
deviceQuad
(
)
info
.
fColor
iter
.
localQuad
(
)
kEmptyDomain
info
.
fAAFlags
)
;
}
GrMesh
*
mesh
=
target
-
>
allocMeshes
(
1
)
;
if
(
!
GrQuadPerEdgeAA
:
:
ConfigureMeshIndices
(
target
mesh
vertexSpec
fQuads
.
count
(
)
)
)
{
SkDebugf
(
"
Could
not
allocate
indices
\
n
"
)
;
return
;
}
mesh
-
>
setVertexData
(
std
:
:
move
(
vbuffer
)
vertexOffsetInBuffer
)
;
target
-
>
recordDraw
(
std
:
:
move
(
gp
)
mesh
)
;
}
void
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
override
{
fHelper
.
executeDrawsAndUploads
(
this
flushState
chainBounds
)
;
}
CombineResult
onCombineIfPossible
(
GrOp
*
t
const
GrCaps
&
caps
)
override
{
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
const
auto
*
that
=
t
-
>
cast
<
FillRectOp
>
(
)
;
if
(
(
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kCoverage
|
|
that
-
>
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kCoverage
)
&
&
fQuads
.
count
(
)
+
that
-
>
fQuads
.
count
(
)
>
GrQuadPerEdgeAA
:
:
kNumAAQuadsInIndexBuffer
)
{
return
CombineResult
:
:
kCannotCombine
;
}
if
(
!
fHelper
.
isCompatible
(
that
-
>
fHelper
caps
this
-
>
bounds
(
)
that
-
>
bounds
(
)
true
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
SkASSERT
(
fHelper
.
isTrivial
(
)
=
=
that
-
>
fHelper
.
isTrivial
(
)
)
;
fColorType
=
SkTMax
(
fColorType
that
-
>
fColorType
)
;
if
(
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kNone
&
&
that
-
>
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kCoverage
)
{
fHelper
.
setAAType
(
GrAAType
:
:
kCoverage
)
;
}
fQuads
.
concat
(
that
-
>
fQuads
)
;
return
CombineResult
:
:
kMerged
;
}
void
addQuad
(
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
SkPMColor4f
&
color
GrQuadAAFlags
edgeAA
GrAAType
aaType
)
{
if
(
aaType
!
=
fHelper
.
aaType
(
)
)
{
if
(
aaType
!
=
GrAAType
:
:
kNone
)
{
SkASSERT
(
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kNone
)
;
fHelper
.
setAAType
(
aaType
)
;
}
}
SkRect
newBounds
=
this
-
>
bounds
(
)
;
newBounds
.
joinPossiblyEmptyRect
(
deviceQuad
.
bounds
(
)
)
;
this
-
>
setBounds
(
newBounds
HasAABloat
(
fHelper
.
aaType
(
)
=
=
GrAAType
:
:
kCoverage
)
IsHairline
:
:
kNo
)
;
fQuads
.
append
(
deviceQuad
{
color
edgeAA
}
fHelper
.
isTrivial
(
)
?
nullptr
:
&
localQuad
)
;
}
struct
ColorAndAA
{
SkPMColor4f
fColor
;
GrQuadAAFlags
fAAFlags
;
}
;
Helper
fHelper
;
GrQuadBuffer
<
ColorAndAA
>
fQuads
;
ColorType
fColorType
;
typedef
GrMeshDrawOp
INHERITED
;
}
;
}
namespace
GrFillRectOp
{
std
:
:
unique_ptr
<
GrDrawOp
>
Make
(
GrRecordingContext
*
context
GrPaint
&
&
paint
GrAAType
aaType
GrQuadAAFlags
aaFlags
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
GrUserStencilSettings
*
stencil
)
{
return
FillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
aaType
aaFlags
stencil
deviceQuad
localQuad
)
;
}
std
:
:
unique_ptr
<
GrDrawOp
>
MakeNonAARect
(
GrRecordingContext
*
context
GrPaint
&
&
paint
const
SkMatrix
&
view
const
SkRect
&
rect
const
GrUserStencilSettings
*
stencil
)
{
return
FillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
GrQuadAAFlags
:
:
kNone
stencil
GrQuad
:
:
MakeFromRect
(
rect
view
)
GrQuad
(
rect
)
)
;
}
std
:
:
unique_ptr
<
GrDrawOp
>
MakeSet
(
GrRecordingContext
*
context
GrPaint
&
&
paint
GrAAType
aaType
const
SkMatrix
&
viewMatrix
const
GrRenderTargetContext
:
:
QuadSetEntry
quads
[
]
int
cnt
const
GrUserStencilSettings
*
stencilSettings
)
{
SkASSERT
(
cnt
>
0
)
;
paint
.
setColor4f
(
quads
[
0
]
.
fColor
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
FillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
aaType
quads
[
0
]
.
fAAFlags
stencilSettings
GrQuad
:
:
MakeFromRect
(
quads
[
0
]
.
fRect
viewMatrix
)
GrQuad
:
:
MakeFromRect
(
quads
[
0
]
.
fRect
quads
[
0
]
.
fLocalMatrix
)
)
;
auto
*
fillRects
=
op
-
>
cast
<
FillRectOp
>
(
)
;
for
(
int
i
=
1
;
i
<
cnt
;
+
+
i
)
{
GrQuad
deviceQuad
=
GrQuad
:
:
MakeFromRect
(
quads
[
i
]
.
fRect
viewMatrix
)
;
GrAAType
resolvedAA
;
GrQuadAAFlags
resolvedEdgeFlags
;
GrQuadUtils
:
:
ResolveAAType
(
aaType
quads
[
i
]
.
fAAFlags
deviceQuad
&
resolvedAA
&
resolvedEdgeFlags
)
;
fillRects
-
>
addQuad
(
deviceQuad
GrQuad
:
:
MakeFromRect
(
quads
[
i
]
.
fRect
quads
[
i
]
.
fLocalMatrix
)
quads
[
i
]
.
fColor
resolvedEdgeFlags
resolvedAA
)
;
}
return
op
;
}
}
#
if
GR_TEST_UTILS
#
include
"
src
/
gpu
/
GrDrawOpTest
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
GR_DRAW_OP_TEST_DEFINE
(
FillRectOp
)
{
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrixInvertible
(
random
)
;
SkRect
rect
=
GrTest
:
:
TestRect
(
random
)
;
GrAAType
aaType
=
GrAAType
:
:
kNone
;
if
(
random
-
>
nextBool
(
)
)
{
aaType
=
(
numSamples
>
1
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kCoverage
;
}
const
GrUserStencilSettings
*
stencil
=
random
-
>
nextBool
(
)
?
nullptr
:
GrGetRandomStencil
(
random
context
)
;
GrQuadAAFlags
aaFlags
=
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kLeft
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kTop
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kRight
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kBottom
:
GrQuadAAFlags
:
:
kNone
;
if
(
random
-
>
nextBool
(
)
)
{
if
(
random
-
>
nextBool
(
)
)
{
if
(
random
-
>
nextBool
(
)
)
{
uint32_t
extraQuadCt
=
random
-
>
nextRangeU
(
1
4
)
;
SkTArray
<
GrRenderTargetContext
:
:
QuadSetEntry
>
quads
(
extraQuadCt
+
1
)
;
quads
.
push_back
(
{
rect
SkPMColor4f
:
:
FromBytes_RGBA
(
SkColorToPremulGrColor
(
random
-
>
nextU
(
)
)
)
GrTest
:
:
TestMatrixInvertible
(
random
)
aaFlags
}
)
;
for
(
uint32_t
i
=
0
;
i
<
extraQuadCt
;
+
+
i
)
{
GrQuadAAFlags
aaFlags
=
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kLeft
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kTop
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kRight
:
GrQuadAAFlags
:
:
kNone
;
aaFlags
|
=
random
-
>
nextBool
(
)
?
GrQuadAAFlags
:
:
kBottom
:
GrQuadAAFlags
:
:
kNone
;
quads
.
push_back
(
{
GrTest
:
:
TestRect
(
random
)
SkPMColor4f
:
:
FromBytes_RGBA
(
SkColorToPremulGrColor
(
random
-
>
nextU
(
)
)
)
GrTest
:
:
TestMatrixInvertible
(
random
)
aaFlags
}
)
;
}
return
GrFillRectOp
:
:
MakeSet
(
context
std
:
:
move
(
paint
)
aaType
viewMatrix
quads
.
begin
(
)
quads
.
count
(
)
stencil
)
;
}
else
{
SkMatrix
localMatrix
=
GrTest
:
:
TestMatrixInvertible
(
random
)
;
return
GrFillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
aaType
aaFlags
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
:
:
MakeFromRect
(
rect
localMatrix
)
stencil
)
;
}
}
else
{
SkRect
localRect
=
GrTest
:
:
TestRect
(
random
)
;
return
GrFillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
aaType
aaFlags
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
(
localRect
)
stencil
)
;
}
}
else
{
return
GrFillRectOp
:
:
Make
(
context
std
:
:
move
(
paint
)
aaType
aaFlags
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
(
rect
)
stencil
)
;
}
}
#
endif
