#
include
"
GrDashLinePathRenderer
.
h
"
#
include
"
GrAuditTrail
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
ops
/
GrDashOp
.
h
"
#
include
"
ops
/
GrMeshDrawOp
.
h
"
bool
GrDashLinePathRenderer
:
:
onCanDrawPath
(
const
CanDrawPathArgs
&
args
)
const
{
SkPoint
pts
[
2
]
;
bool
inverted
;
if
(
args
.
fShape
-
>
style
(
)
.
isDashed
(
)
&
&
args
.
fShape
-
>
asLine
(
pts
&
inverted
)
)
{
if
(
args
.
fAAType
=
=
GrAAType
:
:
kMixedSamples
)
{
return
false
;
}
SkASSERT
(
!
inverted
)
;
return
GrDashOp
:
:
CanDrawDashLine
(
pts
args
.
fShape
-
>
style
(
)
*
args
.
fViewMatrix
)
;
}
return
false
;
}
bool
GrDashLinePathRenderer
:
:
onDrawPath
(
const
DrawPathArgs
&
args
)
{
GR_AUDIT_TRAIL_AUTO_FRAME
(
args
.
fRenderTargetContext
-
>
auditTrail
(
)
"
GrDashLinePathRenderer
:
:
onDrawPath
"
)
;
GrDashOp
:
:
AAMode
aaMode
=
GrDashOp
:
:
AAMode
:
:
kNone
;
switch
(
args
.
fAAType
)
{
case
GrAAType
:
:
kNone
:
break
;
case
GrAAType
:
:
kCoverage
:
case
GrAAType
:
:
kMixedSamples
:
aaMode
=
GrDashOp
:
:
AAMode
:
:
kCoverage
;
break
;
case
GrAAType
:
:
kMSAA
:
aaMode
=
GrDashOp
:
:
AAMode
:
:
kCoverageWithMSAA
;
break
;
}
SkPoint
pts
[
2
]
;
SkAssertResult
(
args
.
fShape
-
>
asLine
(
pts
nullptr
)
)
;
std
:
:
unique_ptr
<
GrLegacyMeshDrawOp
>
op
=
GrDashOp
:
:
MakeDashLineOp
(
args
.
fPaint
.
getColor
(
)
*
args
.
fViewMatrix
pts
aaMode
args
.
fShape
-
>
style
(
)
)
;
if
(
!
op
)
{
return
false
;
}
GrPipelineBuilder
pipelineBuilder
(
std
:
:
move
(
args
.
fPaint
)
args
.
fAAType
)
;
pipelineBuilder
.
setUserStencil
(
args
.
fUserStencilSettings
)
;
args
.
fRenderTargetContext
-
>
addLegacyMeshDrawOp
(
std
:
:
move
(
pipelineBuilder
)
*
args
.
fClip
std
:
:
move
(
op
)
)
;
return
true
;
}
