#
include
"
src
/
gpu
/
ops
/
GrFillRRectOp
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
GrProgramInfo
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVarying
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
static
bool
can_use_hw_derivatives_with_coverage
(
const
GrShaderCaps
&
const
SkMatrix
&
const
SkRRect
&
)
;
std
:
:
unique_ptr
<
GrFillRRectOp
>
GrFillRRectOp
:
:
Make
(
GrRecordingContext
*
ctx
GrAAType
aaType
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrCaps
&
caps
GrPaint
&
&
paint
)
{
if
(
!
caps
.
instanceAttribSupport
(
)
)
{
return
nullptr
;
}
Flags
flags
=
Flags
:
:
kNone
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
if
(
viewMatrix
.
hasPerspective
(
)
)
{
return
nullptr
;
}
if
(
can_use_hw_derivatives_with_coverage
(
*
caps
.
shaderCaps
(
)
viewMatrix
rrect
)
)
{
flags
|
=
Flags
:
:
kUseHWDerivatives
;
}
}
else
{
if
(
GrAAType
:
:
kMSAA
=
=
aaType
)
{
if
(
!
caps
.
sampleLocationsSupport
(
)
|
|
!
caps
.
shaderCaps
(
)
-
>
sampleVariablesSupport
(
)
)
{
return
nullptr
;
}
}
if
(
viewMatrix
.
hasPerspective
(
)
)
{
flags
|
=
Flags
:
:
kUseHWDerivatives
|
Flags
:
:
kHasPerspective
;
}
}
float
l
=
rrect
.
rect
(
)
.
left
(
)
r
=
rrect
.
rect
(
)
.
right
(
)
t
=
rrect
.
rect
(
)
.
top
(
)
b
=
rrect
.
rect
(
)
.
bottom
(
)
;
SkMatrix
m
;
m
.
setScaleTranslate
(
(
r
-
l
)
/
2
(
b
-
t
)
/
2
(
l
+
r
)
/
2
(
t
+
b
)
/
2
)
;
m
.
postConcat
(
viewMatrix
)
;
SkRect
devBounds
;
if
(
!
(
flags
&
Flags
:
:
kHasPerspective
)
)
{
devBounds
=
SkRect
:
:
MakeXYWH
(
m
.
getTranslateX
(
)
m
.
getTranslateY
(
)
0
0
)
;
devBounds
.
outset
(
SkScalarAbs
(
m
.
getScaleX
(
)
)
+
SkScalarAbs
(
m
.
getSkewX
(
)
)
SkScalarAbs
(
m
.
getSkewY
(
)
)
+
SkScalarAbs
(
m
.
getScaleY
(
)
)
)
;
}
else
{
viewMatrix
.
mapRect
(
&
devBounds
rrect
.
rect
(
)
)
;
}
if
(
GrAAType
:
:
kMSAA
=
=
aaType
&
&
caps
.
preferTrianglesOverSampleMask
(
)
)
{
if
(
devBounds
.
height
(
)
*
devBounds
.
width
(
)
>
200
*
200
)
{
return
nullptr
;
}
}
GrOpMemoryPool
*
pool
=
ctx
-
>
priv
(
)
.
opMemoryPool
(
)
;
return
pool
-
>
allocate
<
GrFillRRectOp
>
(
aaType
rrect
flags
m
std
:
:
move
(
paint
)
devBounds
)
;
}
GrFillRRectOp
:
:
GrFillRRectOp
(
GrAAType
aaType
const
SkRRect
&
rrect
Flags
flags
const
SkMatrix
&
totalShapeMatrix
GrPaint
&
&
paint
const
SkRect
&
devBounds
)
:
GrDrawOp
(
ClassID
(
)
)
fAAType
(
aaType
)
fOriginalColor
(
paint
.
getColor4f
(
)
)
fLocalRect
(
rrect
.
rect
(
)
)
fFlags
(
flags
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
SkASSERT
(
(
fFlags
&
Flags
:
:
kHasPerspective
)
=
=
totalShapeMatrix
.
hasPerspective
(
)
)
;
this
-
>
setBounds
(
devBounds
GrOp
:
:
HasAABloat
:
:
kYes
GrOp
:
:
IsHairline
:
:
kNo
)
;
const
SkMatrix
&
m
=
totalShapeMatrix
;
if
(
!
(
fFlags
&
Flags
:
:
kHasPerspective
)
)
{
SkASSERT
(
!
m
.
hasPerspective
(
)
)
;
this
-
>
writeInstanceData
(
m
.
getScaleX
(
)
m
.
getSkewX
(
)
m
.
getSkewY
(
)
m
.
getScaleY
(
)
)
;
this
-
>
writeInstanceData
(
m
.
getTranslateX
(
)
m
.
getTranslateY
(
)
)
;
}
else
{
SkASSERT
(
m
.
hasPerspective
(
)
)
;
m
.
get9
(
this
-
>
appendInstanceData
<
float
>
(
9
)
)
;
}
Sk4f
radiiX
radiiY
;
Sk4f
:
:
Load2
(
SkRRectPriv
:
:
GetRadiiArray
(
rrect
)
&
radiiX
&
radiiY
)
;
(
radiiX
*
(
2
/
rrect
.
width
(
)
)
)
.
store
(
this
-
>
appendInstanceData
<
float
>
(
4
)
)
;
(
radiiY
*
(
2
/
rrect
.
height
(
)
)
)
.
store
(
this
-
>
appendInstanceData
<
float
>
(
4
)
)
;
}
GrProcessorSet
:
:
Analysis
GrFillRRectOp
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
bool
hasMixedSampledCoverage
GrClampType
clampType
)
{
SkASSERT
(
1
=
=
fInstanceCount
)
;
SkPMColor4f
overrideColor
;
const
GrProcessorSet
:
:
Analysis
&
analysis
=
fProcessors
.
finalize
(
fOriginalColor
GrProcessorAnalysisCoverage
:
:
kSingleChannel
clip
&
GrUserStencilSettings
:
:
kUnused
hasMixedSampledCoverage
caps
clampType
&
overrideColor
)
;
SkPMColor4f
finalColor
=
analysis
.
inputColorIsOverridden
(
)
?
overrideColor
:
fOriginalColor
;
if
(
!
SkPMColor4fFitsInBytes
(
finalColor
)
)
{
fFlags
|
=
Flags
:
:
kWideColor
;
uint32_t
halfColor
[
2
]
;
SkFloatToHalf_finite_ftz
(
Sk4f
:
:
Load
(
finalColor
.
vec
(
)
)
)
.
store
(
&
halfColor
)
;
this
-
>
writeInstanceData
(
halfColor
[
0
]
halfColor
[
1
]
)
;
}
else
{
this
-
>
writeInstanceData
(
finalColor
.
toBytes_RGBA
(
)
)
;
}
if
(
analysis
.
usesLocalCoords
(
)
)
{
this
-
>
writeInstanceData
(
fLocalRect
)
;
fFlags
|
=
Flags
:
:
kHasLocalCoords
;
}
fInstanceStride
=
fInstanceData
.
count
(
)
;
return
analysis
;
}
GrDrawOp
:
:
CombineResult
GrFillRRectOp
:
:
onCombineIfPossible
(
GrOp
*
op
const
GrCaps
&
)
{
const
auto
&
that
=
*
op
-
>
cast
<
GrFillRRectOp
>
(
)
;
if
(
fFlags
!
=
that
.
fFlags
|
|
fProcessors
!
=
that
.
fProcessors
|
|
fInstanceData
.
count
(
)
>
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
-
that
.
fInstanceData
.
count
(
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
fInstanceData
.
push_back_n
(
that
.
fInstanceData
.
count
(
)
that
.
fInstanceData
.
begin
(
)
)
;
fInstanceCount
+
=
that
.
fInstanceCount
;
SkASSERT
(
fInstanceStride
=
=
that
.
fInstanceStride
)
;
return
CombineResult
:
:
kMerged
;
}
class
GrFillRRectOp
:
:
Processor
:
public
GrGeometryProcessor
{
public
:
Processor
(
GrAAType
aaType
Flags
flags
)
:
GrGeometryProcessor
(
kGrFillRRectOp_Processor_ClassID
)
fAAType
(
aaType
)
fFlags
(
flags
)
{
int
numVertexAttribs
=
(
GrAAType
:
:
kCoverage
=
=
fAAType
)
?
3
:
2
;
this
-
>
setVertexAttributes
(
kVertexAttribs
numVertexAttribs
)
;
if
(
!
(
flags
&
Flags
:
:
kHasPerspective
)
)
{
fInstanceAttribs
.
emplace_back
(
"
skew
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
)
;
fInstanceAttribs
.
emplace_back
(
"
translate
"
kFloat2_GrVertexAttribType
kFloat2_GrSLType
)
;
}
else
{
fInstanceAttribs
.
emplace_back
(
"
persp_x
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
)
;
fInstanceAttribs
.
emplace_back
(
"
persp_y
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
)
;
fInstanceAttribs
.
emplace_back
(
"
persp_z
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
)
;
}
fInstanceAttribs
.
emplace_back
(
"
radii_x
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
)
;
fInstanceAttribs
.
emplace_back
(
"
radii_y
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
)
;
fColorAttrib
=
&
fInstanceAttribs
.
push_back
(
MakeColorAttribute
(
"
color
"
(
flags
&
Flags
:
:
kWideColor
)
)
)
;
if
(
fFlags
&
Flags
:
:
kHasLocalCoords
)
{
fInstanceAttribs
.
emplace_back
(
"
local_rect
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
)
;
}
this
-
>
setInstanceAttributes
(
fInstanceAttribs
.
begin
(
)
fInstanceAttribs
.
count
(
)
)
;
if
(
GrAAType
:
:
kMSAA
=
=
fAAType
)
{
this
-
>
setWillUseCustomFeature
(
CustomFeatures
:
:
kSampleLocations
)
;
}
}
const
char
*
name
(
)
const
override
{
return
"
GrFillRRectOp
:
:
Processor
"
;
}
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
b
-
>
add32
(
(
(
uint32_t
)
fFlags
<
<
16
)
|
(
uint32_t
)
fAAType
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrShaderCaps
&
)
const
override
;
private
:
static
constexpr
Attribute
kVertexAttribs
[
]
=
{
{
"
radii_selector
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
{
"
corner_and_radius_outsets
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
{
"
aa_bloat_and_coverage
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
}
;
const
GrAAType
fAAType
;
const
Flags
fFlags
;
SkSTArray
<
6
Attribute
>
fInstanceAttribs
;
const
Attribute
*
fColorAttrib
;
class
CoverageImpl
;
class
MSAAImpl
;
}
;
constexpr
GrPrimitiveProcessor
:
:
Attribute
GrFillRRectOp
:
:
Processor
:
:
kVertexAttribs
[
]
;
struct
CoverageVertex
{
std
:
:
array
<
float
4
>
fRadiiSelector
;
std
:
:
array
<
float
2
>
fCorner
;
std
:
:
array
<
float
2
>
fRadiusOutset
;
std
:
:
array
<
float
2
>
fAABloatDirection
;
float
fCoverage
;
float
fIsLinearCoverage
;
}
;
static
constexpr
float
kOctoOffset
=
1
/
(
1
+
SK_ScalarRoot2Over2
)
;
static
constexpr
CoverageVertex
kCoverageVertexData
[
]
=
{
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
{
{
+
1
0
}
}
1
1
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
{
{
+
1
0
}
}
1
1
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
{
{
0
+
1
}
}
1
1
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
{
{
0
+
1
}
}
1
1
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
{
{
-
1
0
}
}
1
1
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
{
{
-
1
0
}
}
1
1
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
{
{
0
-
1
}
}
1
1
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
{
{
0
-
1
}
}
1
1
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
{
{
-
1
0
}
}
0
1
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
{
{
-
1
0
}
}
0
1
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
{
{
0
-
1
}
}
0
1
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
{
{
0
-
1
}
}
0
1
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
{
{
+
1
0
}
}
0
1
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
{
{
+
1
0
}
}
0
1
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
{
{
0
+
1
}
}
0
1
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
{
{
0
+
1
}
}
0
1
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
{
{
-
1
0
}
}
0
0
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
{
{
+
1
0
}
}
1
0
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
{
{
0
+
1
}
}
1
0
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
{
{
0
-
1
}
}
0
0
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
kOctoOffset
0
}
}
{
{
-
1
-
1
}
}
0
0
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
kOctoOffset
}
}
{
{
-
1
-
1
}
}
0
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
{
{
0
-
1
}
}
0
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
{
{
0
+
1
}
}
1
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
{
{
-
1
0
}
}
1
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
{
{
+
1
0
}
}
0
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
kOctoOffset
}
}
{
{
+
1
-
1
}
}
0
0
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
kOctoOffset
0
}
}
{
{
+
1
-
1
}
}
0
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
{
{
+
1
0
}
}
0
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
{
{
-
1
0
}
}
1
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
{
{
0
-
1
}
}
1
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
{
{
0
+
1
}
}
0
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
kOctoOffset
0
}
}
{
{
+
1
+
1
}
}
0
0
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
kOctoOffset
}
}
{
{
+
1
+
1
}
}
0
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
{
{
0
+
1
}
}
0
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
{
{
0
-
1
}
}
1
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
{
{
+
1
0
}
}
1
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
{
{
-
1
0
}
}
0
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
kOctoOffset
}
}
{
{
-
1
+
1
}
}
0
0
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
kOctoOffset
0
}
}
{
{
-
1
+
1
}
}
0
0
}
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gCoverageVertexBufferKey
)
;
static
constexpr
uint16_t
kCoverageIndexData
[
]
=
{
0
1
7
1
2
7
7
2
6
2
3
6
6
3
5
3
4
5
0
1
8
1
9
8
2
3
10
3
11
10
4
5
12
5
13
12
6
7
14
7
15
14
16
17
21
17
21
18
21
18
20
18
20
19
22
23
27
23
27
24
27
24
26
24
26
25
28
29
33
29
33
30
33
30
32
30
32
31
34
35
39
35
39
36
39
36
38
36
38
37
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gCoverageIndexBufferKey
)
;
struct
MSAAVertex
{
std
:
:
array
<
float
4
>
fRadiiSelector
;
std
:
:
array
<
float
2
>
fCorner
;
std
:
:
array
<
float
2
>
fRadiusOutset
;
}
;
static
constexpr
MSAAVertex
kMSAAVertexData
[
]
=
{
{
{
{
0
0
0
-
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
}
{
{
{
-
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
}
{
{
{
-
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
}
{
{
{
0
-
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
}
{
{
{
0
-
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
}
{
{
{
0
0
-
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
}
{
{
{
0
0
-
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
}
{
{
{
0
0
0
-
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
1
}
}
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
0
+
kOctoOffset
}
}
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
1
0
}
}
}
{
{
{
1
0
0
0
}
}
{
{
-
1
-
1
}
}
{
{
+
kOctoOffset
0
}
}
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
1
0
}
}
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
-
kOctoOffset
0
}
}
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
1
}
}
}
{
{
{
0
1
0
0
}
}
{
{
+
1
-
1
}
}
{
{
0
+
kOctoOffset
}
}
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
1
}
}
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
0
-
kOctoOffset
}
}
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
1
0
}
}
}
{
{
{
0
0
1
0
}
}
{
{
+
1
+
1
}
}
{
{
-
kOctoOffset
0
}
}
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
1
0
}
}
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
+
kOctoOffset
0
}
}
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
1
}
}
}
{
{
{
0
0
0
1
}
}
{
{
-
1
+
1
}
}
{
{
0
-
kOctoOffset
}
}
}
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gMSAAVertexBufferKey
)
;
static
constexpr
uint16_t
kMSAAIndexData
[
]
=
{
0
1
2
0
2
3
0
3
6
3
4
5
3
5
6
6
7
0
8
9
10
9
11
10
12
13
14
13
15
14
16
17
18
17
19
18
20
21
22
21
23
22
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gMSAAIndexBufferKey
)
;
void
GrFillRRectOp
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
if
(
void
*
instanceData
=
flushState
-
>
makeVertexSpace
(
fInstanceStride
fInstanceCount
&
fInstanceBuffer
&
fBaseInstance
)
)
{
SkASSERT
(
fInstanceStride
*
fInstanceCount
=
=
fInstanceData
.
count
(
)
)
;
memcpy
(
instanceData
fInstanceData
.
begin
(
)
fInstanceData
.
count
(
)
)
;
}
if
(
GrAAType
:
:
kCoverage
=
=
fAAType
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gCoverageIndexBufferKey
)
;
fIndexBuffer
=
flushState
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kIndex
sizeof
(
kCoverageIndexData
)
kCoverageIndexData
gCoverageIndexBufferKey
)
;
GR_DEFINE_STATIC_UNIQUE_KEY
(
gCoverageVertexBufferKey
)
;
fVertexBuffer
=
flushState
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kVertex
sizeof
(
kCoverageVertexData
)
kCoverageVertexData
gCoverageVertexBufferKey
)
;
fIndexCount
=
SK_ARRAY_COUNT
(
kCoverageIndexData
)
;
}
else
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gMSAAIndexBufferKey
)
;
fIndexBuffer
=
flushState
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kIndex
sizeof
(
kMSAAIndexData
)
kMSAAIndexData
gMSAAIndexBufferKey
)
;
GR_DEFINE_STATIC_UNIQUE_KEY
(
gMSAAVertexBufferKey
)
;
fVertexBuffer
=
flushState
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kVertex
sizeof
(
kMSAAVertexData
)
kMSAAVertexData
gMSAAVertexBufferKey
)
;
fIndexCount
=
SK_ARRAY_COUNT
(
kMSAAIndexData
)
;
}
}
class
GrFillRRectOp
:
:
Processor
:
:
CoverageImpl
:
public
GrGLSLGeometryProcessor
{
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
const
auto
&
proc
=
args
.
fGP
.
cast
<
Processor
>
(
)
;
bool
useHWDerivatives
=
(
proc
.
fFlags
&
Flags
:
:
kUseHWDerivatives
)
;
SkASSERT
(
proc
.
vertexStride
(
)
=
=
sizeof
(
CoverageVertex
)
)
;
GrGLSLVaryingHandler
*
varyings
=
args
.
fVaryingHandler
;
varyings
-
>
emitAttributes
(
proc
)
;
varyings
-
>
addPassThroughAttribute
(
*
proc
.
fColorAttrib
args
.
fOutputColor
GrGLSLVaryingHandler
:
:
Interpolation
:
:
kCanBeFlat
)
;
GrGLSLVertexBuilder
*
v
=
args
.
fVertBuilder
;
v
-
>
codeAppend
(
"
float2
corner
=
corner_and_radius_outsets
.
xy
;
"
)
;
v
-
>
codeAppend
(
"
float2
radius_outset
=
corner_and_radius_outsets
.
zw
;
"
)
;
v
-
>
codeAppend
(
"
float2
aa_bloat_direction
=
aa_bloat_and_coverage
.
xy
;
"
)
;
v
-
>
codeAppend
(
"
float
coverage
=
aa_bloat_and_coverage
.
z
;
"
)
;
v
-
>
codeAppend
(
"
float
is_linear_coverage
=
aa_bloat_and_coverage
.
w
;
"
)
;
v
-
>
codeAppend
(
"
float2
pixellength
=
inversesqrt
(
"
"
float2
(
dot
(
skew
.
xz
skew
.
xz
)
dot
(
skew
.
yw
skew
.
yw
)
)
)
;
"
)
;
v
-
>
codeAppend
(
"
float4
normalized_axis_dirs
=
skew
*
pixellength
.
xyxy
;
"
)
;
v
-
>
codeAppend
(
"
float2
axiswidths
=
(
abs
(
normalized_axis_dirs
.
xy
)
+
"
"
abs
(
normalized_axis_dirs
.
zw
)
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
aa_bloatradius
=
axiswidths
*
pixellength
*
.
5
;
"
)
;
v
-
>
codeAppend
(
"
float4
radii_and_neighbors
=
radii_selector
"
"
*
float4x4
(
radii_x
radii_y
radii_x
.
yxwz
radii_y
.
wzyx
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
radii
=
radii_and_neighbors
.
xy
;
"
)
;
v
-
>
codeAppend
(
"
float2
neighbor_radii
=
radii_and_neighbors
.
zw
;
"
)
;
v
-
>
codeAppend
(
"
if
(
any
(
greaterThan
(
aa_bloatradius
float2
(
1
)
)
)
)
{
"
)
;
v
-
>
codeAppend
(
"
corner
=
max
(
abs
(
corner
)
aa_bloatradius
)
*
sign
(
corner
)
;
"
)
;
v
-
>
codeAppend
(
"
coverage
/
=
max
(
aa_bloatradius
.
x
1
)
*
max
(
aa_bloatradius
.
y
1
)
;
"
)
;
v
-
>
codeAppend
(
"
radii
=
float2
(
0
)
;
"
)
;
v
-
>
codeAppend
(
"
}
"
)
;
v
-
>
codeAppend
(
"
if
(
any
(
lessThan
(
radii
aa_bloatradius
*
1
.
25
)
)
)
{
"
)
;
v
-
>
codeAppend
(
"
radii
=
aa_bloatradius
;
"
)
;
v
-
>
codeAppend
(
"
radius_outset
=
floor
(
abs
(
radius_outset
)
)
*
radius_outset
;
"
)
;
v
-
>
codeAppend
(
"
is_linear_coverage
=
1
;
"
)
;
v
-
>
codeAppend
(
"
}
else
{
"
)
;
v
-
>
codeAppend
(
"
radii
=
clamp
(
radii
pixellength
2
-
pixellength
)
;
"
)
;
v
-
>
codeAppend
(
"
neighbor_radii
=
clamp
(
neighbor_radii
pixellength
2
-
pixellength
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
spacing
=
2
-
radii
-
neighbor_radii
;
"
)
;
v
-
>
codeAppend
(
"
float2
extra_pad
=
max
(
pixellength
*
.
0625
-
spacing
float2
(
0
)
)
;
"
)
;
v
-
>
codeAppend
(
"
radii
-
=
extra_pad
*
.
5
;
"
)
;
v
-
>
codeAppend
(
"
}
"
)
;
v
-
>
codeAppend
(
"
float2
aa_outset
=
aa_bloat_direction
.
xy
*
aa_bloatradius
;
"
)
;
v
-
>
codeAppend
(
"
float2
vertexpos
=
corner
+
radius_outset
*
radii
+
aa_outset
;
"
)
;
GrShaderVar
localCoord
(
"
"
kFloat2_GrSLType
)
;
if
(
proc
.
fFlags
&
Flags
:
:
kHasLocalCoords
)
{
v
-
>
codeAppend
(
"
float2
localcoord
=
(
local_rect
.
xy
*
(
1
-
vertexpos
)
+
"
"
local_rect
.
zw
*
(
1
+
vertexpos
)
)
*
.
5
;
"
)
;
localCoord
.
set
(
kFloat2_GrSLType
"
localcoord
"
)
;
}
this
-
>
emitTransforms
(
v
varyings
args
.
fUniformHandler
localCoord
args
.
fFPCoordTransformHandler
)
;
SkASSERT
(
!
(
proc
.
fFlags
&
Flags
:
:
kHasPerspective
)
)
;
v
-
>
codeAppend
(
"
float2x2
skewmatrix
=
float2x2
(
skew
.
xy
skew
.
zw
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
devcoord
=
vertexpos
*
skewmatrix
+
translate
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
kFloat2_GrSLType
"
devcoord
"
)
;
GrGLSLVarying
arcCoord
(
useHWDerivatives
?
kFloat2_GrSLType
:
kFloat4_GrSLType
)
;
varyings
-
>
addVarying
(
"
arccoord
"
&
arcCoord
)
;
v
-
>
codeAppend
(
"
if
(
0
!
=
is_linear_coverage
)
{
"
)
;
v
-
>
codeAppendf
(
"
%
s
.
xy
=
float2
(
0
coverage
)
;
"
arcCoord
.
vsOut
(
)
)
;
v
-
>
codeAppend
(
"
}
else
{
"
)
;
v
-
>
codeAppend
(
"
float2
arccoord
=
1
-
abs
(
radius_outset
)
+
aa_outset
/
radii
*
corner
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
.
xy
=
float2
(
arccoord
.
x
+
1
arccoord
.
y
)
;
"
arcCoord
.
vsOut
(
)
)
;
if
(
!
useHWDerivatives
)
{
v
-
>
codeAppendf
(
"
float2x2
derivatives
=
inverse
(
skewmatrix
)
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
.
zw
=
derivatives
*
(
arccoord
/
radii
*
2
)
;
"
arcCoord
.
vsOut
(
)
)
;
}
v
-
>
codeAppend
(
"
}
"
)
;
GrGLSLFPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
f
-
>
codeAppendf
(
"
float
x_plus_1
=
%
s
.
x
y
=
%
s
.
y
;
"
arcCoord
.
fsIn
(
)
arcCoord
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
half
coverage
;
"
)
;
f
-
>
codeAppendf
(
"
if
(
0
=
=
x_plus_1
)
{
"
)
;
f
-
>
codeAppendf
(
"
coverage
=
half
(
y
)
;
"
)
;
f
-
>
codeAppendf
(
"
}
else
{
"
)
;
f
-
>
codeAppendf
(
"
float
fn
=
x_plus_1
*
(
x_plus_1
-
2
)
;
"
)
;
f
-
>
codeAppendf
(
"
fn
=
fma
(
y
y
fn
)
;
"
)
;
if
(
useHWDerivatives
)
{
f
-
>
codeAppendf
(
"
float
fnwidth
=
fwidth
(
fn
)
;
"
)
;
}
else
{
f
-
>
codeAppendf
(
"
float
gx
=
%
s
.
z
gy
=
%
s
.
w
;
"
arcCoord
.
fsIn
(
)
arcCoord
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
float
fnwidth
=
abs
(
gx
)
+
abs
(
gy
)
;
"
)
;
}
f
-
>
codeAppendf
(
"
half
d
=
half
(
fn
/
fnwidth
)
;
"
)
;
f
-
>
codeAppendf
(
"
coverage
=
clamp
(
.
5
-
d
0
1
)
;
"
)
;
f
-
>
codeAppendf
(
"
}
"
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
coverage
)
;
"
args
.
fOutputCoverage
)
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
transformIter
)
override
{
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
}
;
class
GrFillRRectOp
:
:
Processor
:
:
MSAAImpl
:
public
GrGLSLGeometryProcessor
{
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
const
auto
&
proc
=
args
.
fGP
.
cast
<
Processor
>
(
)
;
bool
useHWDerivatives
=
(
proc
.
fFlags
&
Flags
:
:
kUseHWDerivatives
)
;
bool
hasPerspective
=
(
proc
.
fFlags
&
Flags
:
:
kHasPerspective
)
;
bool
hasLocalCoords
=
(
proc
.
fFlags
&
Flags
:
:
kHasLocalCoords
)
;
SkASSERT
(
useHWDerivatives
=
=
hasPerspective
)
;
SkASSERT
(
proc
.
vertexStride
(
)
=
=
sizeof
(
MSAAVertex
)
)
;
GrGLSLVertexBuilder
*
v
=
args
.
fVertBuilder
;
GrGLSLVaryingHandler
*
varyings
=
args
.
fVaryingHandler
;
varyings
-
>
emitAttributes
(
proc
)
;
varyings
-
>
addPassThroughAttribute
(
*
proc
.
fColorAttrib
args
.
fOutputColor
GrGLSLVaryingHandler
:
:
Interpolation
:
:
kCanBeFlat
)
;
v
-
>
codeAppendf
(
"
float2
corner
=
corner_and_radius_outsets
.
xy
;
"
)
;
v
-
>
codeAppendf
(
"
float2
radius_outset
=
corner_and_radius_outsets
.
zw
;
"
)
;
v
-
>
codeAppend
(
"
float2
radii
;
"
)
;
v
-
>
codeAppend
(
"
radii
.
x
=
dot
(
radii_selector
radii_x
)
;
"
)
;
v
-
>
codeAppend
(
"
radii
.
y
=
dot
(
radii_selector
radii_y
)
;
"
)
;
v
-
>
codeAppendf
(
"
bool
is_arc_section
=
(
radii
.
x
>
0
)
;
"
)
;
v
-
>
codeAppendf
(
"
radii
=
abs
(
radii
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
vertexpos
=
corner
+
radius_outset
*
radii
;
"
)
;
GrShaderVar
localCoord
(
"
"
kFloat2_GrSLType
)
;
if
(
hasLocalCoords
)
{
v
-
>
codeAppend
(
"
float2
localcoord
=
(
local_rect
.
xy
*
(
1
-
vertexpos
)
+
"
"
local_rect
.
zw
*
(
1
+
vertexpos
)
)
*
.
5
;
"
)
;
localCoord
.
set
(
kFloat2_GrSLType
"
localcoord
"
)
;
}
this
-
>
emitTransforms
(
v
varyings
args
.
fUniformHandler
localCoord
args
.
fFPCoordTransformHandler
)
;
if
(
!
hasPerspective
)
{
v
-
>
codeAppend
(
"
float2x2
skewmatrix
=
float2x2
(
skew
.
xy
skew
.
zw
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
devcoord
=
vertexpos
*
skewmatrix
+
translate
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
kFloat2_GrSLType
"
devcoord
"
)
;
}
else
{
v
-
>
codeAppend
(
"
float3x3
persp_matrix
=
float3x3
(
persp_x
persp_y
persp_z
)
;
"
)
;
v
-
>
codeAppend
(
"
float3
devcoord
=
float3
(
vertexpos
1
)
*
persp_matrix
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
kFloat3_GrSLType
"
devcoord
"
)
;
}
GrGLSLVarying
arcCoord
(
(
useHWDerivatives
)
?
kFloat2_GrSLType
:
kFloat4_GrSLType
)
;
varyings
-
>
addVarying
(
"
arccoord
"
&
arcCoord
)
;
v
-
>
codeAppendf
(
"
if
(
is_arc_section
)
{
"
)
;
v
-
>
codeAppendf
(
"
%
s
.
xy
=
1
-
abs
(
radius_outset
)
;
"
arcCoord
.
vsOut
(
)
)
;
if
(
!
useHWDerivatives
)
{
SkASSERT
(
!
hasPerspective
)
;
v
-
>
codeAppendf
(
"
float2x2
derivatives
=
inverse
(
skewmatrix
)
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
.
zw
=
derivatives
*
(
%
s
.
xy
/
radii
*
corner
*
2
)
;
"
arcCoord
.
vsOut
(
)
arcCoord
.
vsOut
(
)
)
;
}
v
-
>
codeAppendf
(
"
}
else
{
"
)
;
if
(
useHWDerivatives
)
{
v
-
>
codeAppendf
(
"
%
s
=
float2
(
0
)
;
"
arcCoord
.
vsOut
(
)
)
;
}
else
{
v
-
>
codeAppendf
(
"
%
s
=
float4
(
0
)
;
"
arcCoord
.
vsOut
(
)
)
;
}
v
-
>
codeAppendf
(
"
}
"
)
;
GrGLSLFPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
1
)
;
"
args
.
fOutputCoverage
)
;
f
-
>
codeAppendf
(
"
if
(
float2
(
0
)
!
=
%
s
.
xy
)
{
"
arcCoord
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
float
fn
=
dot
(
%
s
.
xy
%
s
.
xy
)
-
1
;
"
arcCoord
.
fsIn
(
)
arcCoord
.
fsIn
(
)
)
;
if
(
GrAAType
:
:
kMSAA
=
=
proc
.
fAAType
)
{
using
ScopeFlags
=
GrGLSLFPFragmentBuilder
:
:
ScopeFlags
;
if
(
!
useHWDerivatives
)
{
f
-
>
codeAppendf
(
"
float2
grad
=
%
s
.
zw
;
"
arcCoord
.
fsIn
(
)
)
;
f
-
>
applyFnToMultisampleMask
(
"
fn
"
"
grad
"
ScopeFlags
:
:
kInsidePerPrimitiveBranch
)
;
}
else
{
f
-
>
applyFnToMultisampleMask
(
"
fn
"
nullptr
ScopeFlags
:
:
kInsidePerPrimitiveBranch
)
;
}
}
else
{
f
-
>
codeAppendf
(
"
if
(
fn
>
0
)
{
"
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
0
)
;
"
args
.
fOutputCoverage
)
;
f
-
>
codeAppendf
(
"
}
"
)
;
}
f
-
>
codeAppendf
(
"
}
"
)
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
transformIter
)
override
{
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
}
;
GrGLSLPrimitiveProcessor
*
GrFillRRectOp
:
:
Processor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
if
(
GrAAType
:
:
kCoverage
!
=
fAAType
)
{
return
new
MSAAImpl
(
)
;
}
return
new
CoverageImpl
(
)
;
}
void
GrFillRRectOp
:
:
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
{
if
(
!
fInstanceBuffer
|
|
!
fIndexBuffer
|
|
!
fVertexBuffer
)
{
return
;
}
Processor
*
proc
=
flushState
-
>
allocator
(
)
-
>
make
<
Processor
>
(
fAAType
fFlags
)
;
SkASSERT
(
proc
-
>
instanceStride
(
)
=
=
(
size_t
)
fInstanceStride
)
;
GrPipeline
:
:
InitArgs
initArgs
;
if
(
GrAAType
:
:
kMSAA
=
=
fAAType
)
{
initArgs
.
fInputFlags
=
GrPipeline
:
:
InputFlags
:
:
kHWAntialias
;
}
initArgs
.
fCaps
=
&
flushState
-
>
caps
(
)
;
initArgs
.
fDstProxy
=
flushState
-
>
drawOpArgs
(
)
.
dstProxy
(
)
;
initArgs
.
fOutputSwizzle
=
flushState
-
>
drawOpArgs
(
)
.
outputSwizzle
(
)
;
auto
clip
=
flushState
-
>
detachAppliedClip
(
)
;
GrPipeline
:
:
FixedDynamicState
*
fixedDynamicState
=
flushState
-
>
allocator
(
)
-
>
make
<
GrPipeline
:
:
FixedDynamicState
>
(
clip
.
scissorState
(
)
.
rect
(
)
)
;
GrPipeline
*
pipeline
=
flushState
-
>
allocator
(
)
-
>
make
<
GrPipeline
>
(
initArgs
std
:
:
move
(
fProcessors
)
std
:
:
move
(
clip
)
)
;
GrProgramInfo
programInfo
(
flushState
-
>
drawOpArgs
(
)
.
numSamples
(
)
flushState
-
>
drawOpArgs
(
)
.
origin
(
)
*
pipeline
*
proc
fixedDynamicState
nullptr
0
)
;
GrMesh
*
mesh
=
flushState
-
>
allocator
(
)
-
>
make
<
GrMesh
>
(
GrPrimitiveType
:
:
kTriangles
)
;
mesh
-
>
setIndexedInstanced
(
std
:
:
move
(
fIndexBuffer
)
fIndexCount
std
:
:
move
(
fInstanceBuffer
)
fInstanceCount
fBaseInstance
GrPrimitiveRestart
:
:
kNo
)
;
mesh
-
>
setVertexData
(
std
:
:
move
(
fVertexBuffer
)
)
;
flushState
-
>
opsRenderPass
(
)
-
>
draw
(
programInfo
mesh
1
this
-
>
bounds
(
)
)
;
fIndexCount
=
0
;
}
static
bool
can_use_hw_derivatives_with_coverage
(
const
Sk2f
&
devScale
const
Sk2f
&
cornerRadii
)
{
Sk2f
devRadii
=
devScale
*
cornerRadii
;
if
(
devRadii
[
1
]
<
devRadii
[
0
]
)
{
devRadii
=
SkNx_shuffle
<
1
0
>
(
devRadii
)
;
}
float
minDevRadius
=
SkTMax
(
devRadii
[
0
]
1
.
f
)
;
return
minDevRadius
*
minDevRadius
*
5
>
devRadii
[
1
]
;
}
static
bool
can_use_hw_derivatives_with_coverage
(
const
Sk2f
&
devScale
const
SkVector
&
cornerRadii
)
{
return
can_use_hw_derivatives_with_coverage
(
devScale
Sk2f
:
:
Load
(
&
cornerRadii
)
)
;
}
static
bool
can_use_hw_derivatives_with_coverage
(
const
GrShaderCaps
&
shaderCaps
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
)
{
if
(
!
shaderCaps
.
shaderDerivativeSupport
(
)
)
{
return
false
;
}
Sk2f
x
=
Sk2f
(
viewMatrix
.
getScaleX
(
)
viewMatrix
.
getSkewX
(
)
)
;
Sk2f
y
=
Sk2f
(
viewMatrix
.
getSkewY
(
)
viewMatrix
.
getScaleY
(
)
)
;
Sk2f
devScale
=
(
x
*
x
+
y
*
y
)
.
sqrt
(
)
;
switch
(
rrect
.
getType
(
)
)
{
case
SkRRect
:
:
kEmpty_Type
:
case
SkRRect
:
:
kRect_Type
:
return
true
;
case
SkRRect
:
:
kOval_Type
:
case
SkRRect
:
:
kSimple_Type
:
return
can_use_hw_derivatives_with_coverage
(
devScale
rrect
.
getSimpleRadii
(
)
)
;
case
SkRRect
:
:
kNinePatch_Type
:
{
Sk2f
r0
=
Sk2f
:
:
Load
(
SkRRectPriv
:
:
GetRadiiArray
(
rrect
)
)
;
Sk2f
r1
=
Sk2f
:
:
Load
(
SkRRectPriv
:
:
GetRadiiArray
(
rrect
)
+
2
)
;
Sk2f
minRadii
=
Sk2f
:
:
Min
(
r0
r1
)
;
Sk2f
maxRadii
=
Sk2f
:
:
Max
(
r0
r1
)
;
return
can_use_hw_derivatives_with_coverage
(
devScale
Sk2f
(
minRadii
[
0
]
maxRadii
[
1
]
)
)
&
&
can_use_hw_derivatives_with_coverage
(
devScale
Sk2f
(
maxRadii
[
0
]
minRadii
[
1
]
)
)
;
}
case
SkRRect
:
:
kComplex_Type
:
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
auto
corner
=
static_cast
<
SkRRect
:
:
Corner
>
(
i
)
;
if
(
!
can_use_hw_derivatives_with_coverage
(
devScale
rrect
.
radii
(
corner
)
)
)
{
return
false
;
}
}
return
true
;
}
}
SK_ABORT
(
"
Invalid
round
rect
type
.
"
)
;
}
