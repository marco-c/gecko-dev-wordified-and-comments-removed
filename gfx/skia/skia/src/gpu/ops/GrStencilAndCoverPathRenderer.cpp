#
include
"
GrStencilAndCoverPathRenderer
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrDrawPathOp
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPath
.
h
"
#
include
"
GrRenderTargetContextPriv
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
GrStencilClip
.
h
"
#
include
"
GrStencilPathOp
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
ops
/
GrRectOpFactory
.
h
"
GrPathRenderer
*
GrStencilAndCoverPathRenderer
:
:
Create
(
GrResourceProvider
*
resourceProvider
const
GrCaps
&
caps
)
{
if
(
caps
.
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
&
&
!
caps
.
avoidStencilBuffers
(
)
)
{
return
new
GrStencilAndCoverPathRenderer
(
resourceProvider
)
;
}
else
{
return
nullptr
;
}
}
GrStencilAndCoverPathRenderer
:
:
GrStencilAndCoverPathRenderer
(
GrResourceProvider
*
resourceProvider
)
:
fResourceProvider
(
resourceProvider
)
{
}
GrPathRenderer
:
:
CanDrawPath
GrStencilAndCoverPathRenderer
:
:
onCanDrawPath
(
const
CanDrawPathArgs
&
args
)
const
{
if
(
args
.
fShape
-
>
style
(
)
.
strokeRec
(
)
.
isHairlineStyle
(
)
|
|
args
.
fShape
-
>
style
(
)
.
hasNonDashPathEffect
(
)
)
{
return
CanDrawPath
:
:
kNo
;
}
if
(
args
.
fHasUserStencilSettings
)
{
return
CanDrawPath
:
:
kNo
;
}
if
(
GrAAType
:
:
kCoverage
=
=
args
.
fAAType
)
{
return
CanDrawPath
:
:
kNo
;
}
return
CanDrawPath
:
:
kYes
;
}
static
sk_sp
<
GrPath
>
get_gr_path
(
GrResourceProvider
*
resourceProvider
const
GrShape
&
shape
)
{
GrUniqueKey
key
;
bool
isVolatile
;
GrPath
:
:
ComputeKey
(
shape
&
key
&
isVolatile
)
;
sk_sp
<
GrPath
>
path
;
if
(
!
isVolatile
)
{
path
=
resourceProvider
-
>
findByUniqueKey
<
GrPath
>
(
key
)
;
}
if
(
!
path
)
{
SkPath
skPath
;
shape
.
asPath
(
&
skPath
)
;
path
=
resourceProvider
-
>
createPath
(
skPath
shape
.
style
(
)
)
;
if
(
!
isVolatile
)
{
resourceProvider
-
>
assignUniqueKeyToResource
(
key
path
.
get
(
)
)
;
}
}
else
{
#
ifdef
SK_DEBUG
SkPath
skPath
;
shape
.
asPath
(
&
skPath
)
;
SkASSERT
(
path
-
>
isEqualTo
(
skPath
shape
.
style
(
)
)
)
;
#
endif
}
return
path
;
}
void
GrStencilAndCoverPathRenderer
:
:
onStencilPath
(
const
StencilPathArgs
&
args
)
{
GR_AUDIT_TRAIL_AUTO_FRAME
(
args
.
fRenderTargetContext
-
>
auditTrail
(
)
"
GrStencilAndCoverPathRenderer
:
:
onStencilPath
"
)
;
sk_sp
<
GrPath
>
p
(
get_gr_path
(
fResourceProvider
*
args
.
fShape
)
)
;
args
.
fRenderTargetContext
-
>
priv
(
)
.
stencilPath
(
*
args
.
fClip
args
.
fAAType
*
args
.
fViewMatrix
p
.
get
(
)
)
;
}
bool
GrStencilAndCoverPathRenderer
:
:
onDrawPath
(
const
DrawPathArgs
&
args
)
{
GR_AUDIT_TRAIL_AUTO_FRAME
(
args
.
fRenderTargetContext
-
>
auditTrail
(
)
"
GrStencilAndCoverPathRenderer
:
:
onDrawPath
"
)
;
SkASSERT
(
!
args
.
fShape
-
>
style
(
)
.
strokeRec
(
)
.
isHairlineStyle
(
)
)
;
const
SkMatrix
&
viewMatrix
=
*
args
.
fViewMatrix
;
sk_sp
<
GrPath
>
path
(
get_gr_path
(
fResourceProvider
*
args
.
fShape
)
)
;
if
(
args
.
fShape
-
>
inverseFilled
(
)
)
{
SkMatrix
vmi
;
if
(
!
viewMatrix
.
invert
(
&
vmi
)
)
{
return
true
;
}
SkRect
devBounds
=
SkRect
:
:
MakeIWH
(
args
.
fRenderTargetContext
-
>
width
(
)
args
.
fRenderTargetContext
-
>
height
(
)
)
;
GrAppliedClip
appliedClip
;
if
(
!
args
.
fClip
-
>
apply
(
args
.
fContext
args
.
fRenderTargetContext
GrAATypeIsHW
(
args
.
fAAType
)
true
&
appliedClip
&
devBounds
)
)
{
return
true
;
}
GrStencilClip
stencilClip
(
appliedClip
.
stencilStackID
(
)
)
;
if
(
appliedClip
.
scissorState
(
)
.
enabled
(
)
)
{
stencilClip
.
fixedClip
(
)
.
setScissor
(
appliedClip
.
scissorState
(
)
.
rect
(
)
)
;
}
if
(
appliedClip
.
windowRectsState
(
)
.
enabled
(
)
)
{
stencilClip
.
fixedClip
(
)
.
setWindowRectangles
(
appliedClip
.
windowRectsState
(
)
.
windows
(
)
appliedClip
.
windowRectsState
(
)
.
mode
(
)
)
;
}
args
.
fRenderTargetContext
-
>
priv
(
)
.
stencilPath
(
stencilClip
args
.
fAAType
viewMatrix
path
.
get
(
)
)
;
{
static
constexpr
GrUserStencilSettings
kInvertedCoverPass
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqualIfInClip
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kZero
0xffff
>
(
)
)
;
SkRect
coverBounds
;
if
(
!
viewMatrix
.
hasPerspective
(
)
)
{
vmi
.
mapRect
(
&
coverBounds
devBounds
)
;
SkScalar
bloat
=
viewMatrix
.
getMaxScale
(
)
*
SK_ScalarHalf
;
coverBounds
.
outset
(
bloat
bloat
)
;
}
else
{
coverBounds
=
devBounds
;
}
const
SkMatrix
&
coverMatrix
=
!
viewMatrix
.
hasPerspective
(
)
?
viewMatrix
:
SkMatrix
:
:
I
(
)
;
const
SkMatrix
&
localMatrix
=
!
viewMatrix
.
hasPerspective
(
)
?
SkMatrix
:
:
I
(
)
:
vmi
;
GrAAType
coverAAType
=
args
.
fAAType
;
if
(
GrAAType
:
:
kMixedSamples
=
=
coverAAType
)
{
coverAAType
=
GrAAType
:
:
kNone
;
}
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrRectOpFactory
:
:
MakeNonAAFillWithLocalMatrix
(
args
.
fContext
std
:
:
move
(
args
.
fPaint
)
coverMatrix
localMatrix
coverBounds
coverAAType
&
kInvertedCoverPass
)
;
args
.
fRenderTargetContext
-
>
addDrawOp
(
*
args
.
fClip
std
:
:
move
(
op
)
)
;
}
}
else
{
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrDrawPathOp
:
:
Make
(
args
.
fContext
viewMatrix
std
:
:
move
(
args
.
fPaint
)
args
.
fAAType
path
.
get
(
)
)
;
args
.
fRenderTargetContext
-
>
addDrawOp
(
*
args
.
fClip
std
:
:
move
(
op
)
)
;
}
return
true
;
}
