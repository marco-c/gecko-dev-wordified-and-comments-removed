#
include
"
src
/
gpu
/
ops
/
GrQuadPerEdgeAA
.
h
"
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
src
/
gpu
/
GrVertexWriter
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLColorSpaceXformHelper
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLPrimitiveProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVarying
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
#
define
AI
SK_ALWAYS_INLINE
namespace
{
using
V4f
=
skvx
:
:
Vec
<
4
float
>
;
using
M4f
=
skvx
:
:
Vec
<
4
int32_t
>
;
struct
Vertices
{
V4f
fX
fY
fW
;
V4f
fU
fV
fR
;
int
fUVRCount
;
}
;
struct
QuadMetadata
{
V4f
fDX
fDY
;
V4f
fInvLengths
;
V4f
fMask
;
}
;
struct
Edges
{
V4f
fA
fB
fC
;
bool
fFlipped
;
}
;
static
constexpr
float
kTolerance
=
1e
-
2f
;
static
constexpr
int32_t
kTrue
=
~
0
;
static
constexpr
int32_t
kFalse
=
0
;
static
AI
V4f
fma
(
const
V4f
&
f
const
V4f
&
m
const
V4f
&
a
)
{
return
mad
(
f
m
a
)
;
}
static
AI
V4f
nextCW
(
const
V4f
&
v
)
{
return
skvx
:
:
shuffle
<
2
0
3
1
>
(
v
)
;
}
static
AI
V4f
nextCCW
(
const
V4f
&
v
)
{
return
skvx
:
:
shuffle
<
1
3
0
2
>
(
v
)
;
}
static
AI
void
correct_bad_edges
(
const
M4f
&
bad
V4f
*
e1
V4f
*
e2
V4f
*
e3
)
{
if
(
any
(
bad
)
)
{
*
e1
=
if_then_else
(
bad
-
skvx
:
:
shuffle
<
3
2
1
0
>
(
*
e1
)
*
e1
)
;
*
e2
=
if_then_else
(
bad
-
skvx
:
:
shuffle
<
3
2
1
0
>
(
*
e2
)
*
e2
)
;
if
(
e3
)
{
*
e3
=
if_then_else
(
bad
-
skvx
:
:
shuffle
<
3
2
1
0
>
(
*
e3
)
*
e3
)
;
}
}
}
static
AI
void
correct_bad_coords
(
const
M4f
&
bad
V4f
*
c1
V4f
*
c2
V4f
*
c3
)
{
if
(
any
(
bad
)
)
{
*
c1
=
if_then_else
(
bad
nextCCW
(
*
c1
)
*
c1
)
;
*
c2
=
if_then_else
(
bad
nextCCW
(
*
c2
)
*
c2
)
;
if
(
c3
)
{
*
c3
=
if_then_else
(
bad
nextCCW
(
*
c3
)
*
c3
)
;
}
}
}
static
AI
QuadMetadata
get_metadata
(
const
Vertices
&
vertices
GrQuadAAFlags
aaFlags
)
{
V4f
dx
=
nextCCW
(
vertices
.
fX
)
-
vertices
.
fX
;
V4f
dy
=
nextCCW
(
vertices
.
fY
)
-
vertices
.
fY
;
V4f
invLengths
=
rsqrt
(
fma
(
dx
dx
dy
*
dy
)
)
;
V4f
mask
=
aaFlags
=
=
GrQuadAAFlags
:
:
kAll
?
V4f
(
1
.
f
)
:
V4f
{
(
GrQuadAAFlags
:
:
kLeft
&
aaFlags
)
?
1
.
f
:
0
.
f
(
GrQuadAAFlags
:
:
kBottom
&
aaFlags
)
?
1
.
f
:
0
.
f
(
GrQuadAAFlags
:
:
kTop
&
aaFlags
)
?
1
.
f
:
0
.
f
(
GrQuadAAFlags
:
:
kRight
&
aaFlags
)
?
1
.
f
:
0
.
f
}
;
return
{
dx
*
invLengths
dy
*
invLengths
invLengths
mask
}
;
}
static
AI
Edges
get_edge_equations
(
const
QuadMetadata
&
metadata
const
Vertices
&
vertices
)
{
V4f
dx
=
metadata
.
fDX
;
V4f
dy
=
metadata
.
fDY
;
correct_bad_edges
(
metadata
.
fInvLengths
>
=
1
.
f
/
kTolerance
&
dx
&
dy
nullptr
)
;
V4f
c
=
fma
(
dx
vertices
.
fY
-
dy
*
vertices
.
fX
)
;
V4f
test
=
fma
(
dy
nextCW
(
vertices
.
fX
)
fma
(
-
dx
nextCW
(
vertices
.
fY
)
c
)
)
;
if
(
any
(
test
<
-
kTolerance
)
)
{
return
{
-
dy
dx
-
c
true
}
;
}
else
{
return
{
dy
-
dx
c
false
}
;
}
}
static
bool
get_optimized_outset
(
const
QuadMetadata
&
metadata
bool
rectilinear
V4f
*
outset
)
{
if
(
rectilinear
)
{
*
outset
=
0
.
5f
;
return
all
(
metadata
.
fInvLengths
<
=
1
.
f
)
;
}
if
(
any
(
metadata
.
fInvLengths
>
=
1
.
f
/
kTolerance
)
)
{
return
false
;
}
V4f
cosTheta
=
fma
(
metadata
.
fDX
nextCW
(
metadata
.
fDX
)
metadata
.
fDY
*
nextCW
(
metadata
.
fDY
)
)
;
if
(
any
(
abs
(
cosTheta
)
>
=
0
.
9f
)
)
{
return
false
;
}
*
outset
=
0
.
5f
*
rsqrt
(
1
.
f
-
cosTheta
*
cosTheta
)
;
V4f
halfTanTheta
=
-
cosTheta
*
(
*
outset
)
;
V4f
edgeAdjust
=
metadata
.
fMask
*
(
halfTanTheta
+
nextCCW
(
halfTanTheta
)
)
+
nextCCW
(
metadata
.
fMask
)
*
nextCCW
(
*
outset
)
+
nextCW
(
metadata
.
fMask
)
*
(
*
outset
)
;
V4f
threshold
=
0
.
1f
-
(
1
.
f
/
metadata
.
fInvLengths
)
;
return
all
(
edgeAdjust
>
threshold
)
&
&
all
(
edgeAdjust
<
-
threshold
)
;
}
static
AI
void
outset_vertices
(
const
V4f
&
outset
const
QuadMetadata
&
metadata
Vertices
*
quad
)
{
auto
maskedOutset
=
-
outset
*
nextCW
(
metadata
.
fMask
)
;
auto
maskedOutsetCW
=
outset
*
metadata
.
fMask
;
quad
-
>
fX
+
=
fma
(
maskedOutsetCW
nextCW
(
metadata
.
fDX
)
maskedOutset
*
metadata
.
fDX
)
;
quad
-
>
fY
+
=
fma
(
maskedOutsetCW
nextCW
(
metadata
.
fDY
)
maskedOutset
*
metadata
.
fDY
)
;
if
(
quad
-
>
fUVRCount
>
0
)
{
maskedOutset
*
=
metadata
.
fInvLengths
;
maskedOutsetCW
*
=
nextCW
(
metadata
.
fInvLengths
)
;
V4f
du
=
nextCCW
(
quad
-
>
fU
)
-
quad
-
>
fU
;
V4f
dv
=
nextCCW
(
quad
-
>
fV
)
-
quad
-
>
fV
;
quad
-
>
fU
+
=
fma
(
maskedOutsetCW
nextCW
(
du
)
maskedOutset
*
du
)
;
quad
-
>
fV
+
=
fma
(
maskedOutsetCW
nextCW
(
dv
)
maskedOutset
*
dv
)
;
if
(
quad
-
>
fUVRCount
=
=
3
)
{
V4f
dr
=
nextCCW
(
quad
-
>
fR
)
-
quad
-
>
fR
;
quad
-
>
fR
+
=
fma
(
maskedOutsetCW
nextCW
(
dr
)
maskedOutset
*
dr
)
;
}
}
}
static
void
outset_projected_vertices
(
const
V4f
&
x2d
const
V4f
&
y2d
GrQuadAAFlags
aaFlags
Vertices
*
quad
)
{
V4f
e1x
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fX
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fX
)
;
V4f
e1y
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fY
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fY
)
;
V4f
e1w
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fW
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fW
)
;
correct_bad_edges
(
fma
(
e1x
e1x
e1y
*
e1y
)
<
kTolerance
*
kTolerance
&
e1x
&
e1y
&
e1w
)
;
V4f
e2x
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fX
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fX
)
;
V4f
e2y
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fY
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fY
)
;
V4f
e2w
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fW
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fW
)
;
correct_bad_edges
(
fma
(
e2x
e2x
e2y
*
e2y
)
<
kTolerance
*
kTolerance
&
e2x
&
e2y
&
e2w
)
;
V4f
c1x
=
e1w
*
x2d
-
e1x
;
V4f
c1y
=
e1w
*
y2d
-
e1y
;
V4f
c2x
=
e2w
*
x2d
-
e2x
;
V4f
c2y
=
e2w
*
y2d
-
e2y
;
V4f
c3x
=
quad
-
>
fW
*
x2d
-
quad
-
>
fX
;
V4f
c3y
=
quad
-
>
fW
*
y2d
-
quad
-
>
fY
;
V4f
a
b
denom
;
if
(
aaFlags
=
=
GrQuadAAFlags
:
:
kAll
)
{
denom
=
c1x
*
c2y
-
c2x
*
c1y
;
a
=
(
c2x
*
c3y
-
c3x
*
c2y
)
/
denom
;
b
=
(
c3x
*
c1y
-
c1x
*
c3y
)
/
denom
;
}
else
{
M4f
aMask
=
M4f
{
(
aaFlags
&
GrQuadAAFlags
:
:
kLeft
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kLeft
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kRight
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kRight
)
?
kTrue
:
kFalse
}
;
M4f
bMask
=
M4f
{
(
aaFlags
&
GrQuadAAFlags
:
:
kTop
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kBottom
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kTop
)
?
kTrue
:
kFalse
(
aaFlags
&
GrQuadAAFlags
:
:
kBottom
)
?
kTrue
:
kFalse
}
;
M4f
useC1x
=
abs
(
c1x
)
>
abs
(
c1y
)
;
M4f
useC2x
=
abs
(
c2x
)
>
abs
(
c2y
)
;
denom
=
if_then_else
(
aMask
if_then_else
(
bMask
c1x
*
c2y
-
c2x
*
c1y
if_then_else
(
useC1x
c1x
c1y
)
)
if_then_else
(
bMask
if_then_else
(
useC2x
c2x
c2y
)
V4f
(
1
.
f
)
)
)
;
a
=
if_then_else
(
aMask
if_then_else
(
bMask
c2x
*
c3y
-
c3x
*
c2y
if_then_else
(
useC1x
-
c3x
-
c3y
)
)
V4f
(
0
.
f
)
)
/
denom
;
b
=
if_then_else
(
bMask
if_then_else
(
aMask
c3x
*
c1y
-
c1x
*
c3y
if_then_else
(
useC2x
-
c3x
-
c3y
)
)
V4f
(
0
.
f
)
)
/
denom
;
}
V4f
newW
=
quad
-
>
fW
+
a
*
e1w
+
b
*
e2w
;
static
const
float
kMinW
=
1e
-
6f
;
if
(
any
(
newW
<
0
.
f
)
)
{
V4f
scale
=
if_then_else
(
newW
<
kMinW
(
kMinW
-
quad
-
>
fW
)
/
(
newW
-
quad
-
>
fW
)
V4f
(
1
.
f
)
)
;
a
*
=
scale
;
b
*
=
scale
;
}
quad
-
>
fX
+
=
a
*
e1x
+
b
*
e2x
;
quad
-
>
fY
+
=
a
*
e1y
+
b
*
e2y
;
quad
-
>
fW
+
=
a
*
e1w
+
b
*
e2w
;
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
quad
-
>
fX
&
quad
-
>
fY
&
quad
-
>
fW
)
;
if
(
quad
-
>
fUVRCount
>
0
)
{
V4f
e1u
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fU
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fU
)
;
V4f
e1v
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fV
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fV
)
;
V4f
e1r
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
quad
-
>
fR
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
quad
-
>
fR
)
;
correct_bad_edges
(
fma
(
e1u
e1u
e1v
*
e1v
)
<
kTolerance
*
kTolerance
&
e1u
&
e1v
&
e1r
)
;
V4f
e2u
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fU
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fU
)
;
V4f
e2v
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fV
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fV
)
;
V4f
e2r
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
quad
-
>
fR
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
quad
-
>
fR
)
;
correct_bad_edges
(
fma
(
e2u
e2u
e2v
*
e2v
)
<
kTolerance
*
kTolerance
&
e2u
&
e2v
&
e2r
)
;
quad
-
>
fU
+
=
a
*
e1u
+
b
*
e2u
;
quad
-
>
fV
+
=
a
*
e1v
+
b
*
e2v
;
if
(
quad
-
>
fUVRCount
=
=
3
)
{
quad
-
>
fR
+
=
a
*
e1r
+
b
*
e2r
;
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
quad
-
>
fU
&
quad
-
>
fV
&
quad
-
>
fR
)
;
}
else
{
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
quad
-
>
fU
&
quad
-
>
fV
nullptr
)
;
}
}
}
static
V4f
degenerate_coverage
(
const
V4f
&
px
const
V4f
&
py
const
Edges
&
edges
)
{
V4f
d0
=
fma
(
edges
.
fA
[
0
]
px
fma
(
edges
.
fB
[
0
]
py
edges
.
fC
[
0
]
)
)
;
V4f
d1
=
fma
(
edges
.
fA
[
1
]
px
fma
(
edges
.
fB
[
1
]
py
edges
.
fC
[
1
]
)
)
;
V4f
d2
=
fma
(
edges
.
fA
[
2
]
px
fma
(
edges
.
fB
[
2
]
py
edges
.
fC
[
2
]
)
)
;
V4f
d3
=
fma
(
edges
.
fA
[
3
]
px
fma
(
edges
.
fB
[
3
]
py
edges
.
fC
[
3
]
)
)
;
V4f
w
=
max
(
0
.
f
min
(
1
.
f
d0
+
d3
)
)
;
V4f
h
=
max
(
0
.
f
min
(
1
.
f
d1
+
d2
)
)
;
return
w
*
h
;
}
static
V4f
compute_degenerate_quad
(
GrQuadAAFlags
aaFlags
const
V4f
&
mask
const
Edges
&
edges
bool
outset
Vertices
*
quad
)
{
V4f
oc
=
edges
.
fC
+
mask
*
(
outset
?
0
.
5f
:
-
0
.
5f
)
;
V4f
denom
=
edges
.
fA
*
nextCW
(
edges
.
fB
)
-
edges
.
fB
*
nextCW
(
edges
.
fA
)
;
V4f
px
=
(
edges
.
fB
*
nextCW
(
oc
)
-
oc
*
nextCW
(
edges
.
fB
)
)
/
denom
;
V4f
py
=
(
oc
*
nextCW
(
edges
.
fA
)
-
edges
.
fA
*
nextCW
(
oc
)
)
/
denom
;
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
px
&
py
nullptr
)
;
V4f
dists1
=
px
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
edges
.
fA
)
+
py
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
edges
.
fB
)
+
skvx
:
:
shuffle
<
3
3
0
0
>
(
oc
)
;
V4f
dists2
=
px
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
edges
.
fA
)
+
py
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
edges
.
fB
)
+
skvx
:
:
shuffle
<
1
2
1
2
>
(
oc
)
;
M4f
d1v0
=
dists1
<
kTolerance
;
M4f
d2v0
=
dists2
<
kTolerance
;
M4f
d1And2
=
d1v0
&
d2v0
;
M4f
d1Or2
=
d1v0
|
d2v0
;
V4f
coverage
;
if
(
!
any
(
d1Or2
)
)
{
coverage
=
1
.
f
;
}
else
if
(
any
(
d1And2
)
)
{
SkPoint
center
=
{
0
.
25f
*
(
quad
-
>
fX
[
0
]
+
quad
-
>
fX
[
1
]
+
quad
-
>
fX
[
2
]
+
quad
-
>
fX
[
3
]
)
0
.
25f
*
(
quad
-
>
fY
[
0
]
+
quad
-
>
fY
[
1
]
+
quad
-
>
fY
[
2
]
+
quad
-
>
fY
[
3
]
)
}
;
px
=
center
.
fX
;
py
=
center
.
fY
;
coverage
=
degenerate_coverage
(
px
py
edges
)
;
}
else
if
(
all
(
d1Or2
)
)
{
if
(
dists1
[
2
]
<
kTolerance
&
&
dists1
[
3
]
<
kTolerance
)
{
px
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
1
>
(
px
)
+
skvx
:
:
shuffle
<
2
3
2
3
>
(
px
)
)
;
py
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
1
>
(
py
)
+
skvx
:
:
shuffle
<
2
3
2
3
>
(
py
)
)
;
}
else
{
px
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
0
2
2
>
(
px
)
+
skvx
:
:
shuffle
<
1
1
3
3
>
(
px
)
)
;
py
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
0
2
2
>
(
py
)
+
skvx
:
:
shuffle
<
1
1
3
3
>
(
py
)
)
;
}
coverage
=
degenerate_coverage
(
px
py
edges
)
;
}
else
{
using
V2f
=
skvx
:
:
Vec
<
2
float
>
;
V2f
eDenom
=
skvx
:
:
shuffle
<
0
1
>
(
edges
.
fA
)
*
skvx
:
:
shuffle
<
3
2
>
(
edges
.
fB
)
-
skvx
:
:
shuffle
<
0
1
>
(
edges
.
fB
)
*
skvx
:
:
shuffle
<
3
2
>
(
edges
.
fA
)
;
V2f
ex
=
(
skvx
:
:
shuffle
<
0
1
>
(
edges
.
fB
)
*
skvx
:
:
shuffle
<
3
2
>
(
oc
)
-
skvx
:
:
shuffle
<
0
1
>
(
oc
)
*
skvx
:
:
shuffle
<
3
2
>
(
edges
.
fB
)
)
/
eDenom
;
V2f
ey
=
(
skvx
:
:
shuffle
<
0
1
>
(
oc
)
*
skvx
:
:
shuffle
<
3
2
>
(
edges
.
fA
)
-
skvx
:
:
shuffle
<
0
1
>
(
edges
.
fA
)
*
skvx
:
:
shuffle
<
3
2
>
(
oc
)
)
/
eDenom
;
if
(
SkScalarAbs
(
eDenom
[
0
]
)
>
kTolerance
)
{
px
=
if_then_else
(
d1v0
V4f
(
ex
[
0
]
)
px
)
;
py
=
if_then_else
(
d1v0
V4f
(
ey
[
0
]
)
py
)
;
}
if
(
SkScalarAbs
(
eDenom
[
1
]
)
>
kTolerance
)
{
px
=
if_then_else
(
d2v0
V4f
(
ex
[
1
]
)
px
)
;
py
=
if_then_else
(
d2v0
V4f
(
ey
[
1
]
)
py
)
;
}
coverage
=
1
.
f
;
}
outset_projected_vertices
(
px
py
aaFlags
quad
)
;
return
coverage
;
}
static
V4f
compute_nested_quad_vertices
(
GrQuadAAFlags
aaFlags
bool
rectilinear
Vertices
*
inner
Vertices
*
outer
SkRect
*
domain
)
{
SkASSERT
(
inner
-
>
fUVRCount
=
=
0
|
|
inner
-
>
fUVRCount
=
=
2
|
|
inner
-
>
fUVRCount
=
=
3
)
;
SkASSERT
(
outer
-
>
fUVRCount
=
=
inner
-
>
fUVRCount
)
;
QuadMetadata
metadata
=
get_metadata
(
*
inner
aaFlags
)
;
if
(
!
rectilinear
)
{
SkASSERT
(
domain
)
;
domain
-
>
fLeft
=
min
(
outer
-
>
fX
)
-
0
.
5f
;
domain
-
>
fRight
=
max
(
outer
-
>
fX
)
+
0
.
5f
;
domain
-
>
fTop
=
min
(
outer
-
>
fY
)
-
0
.
5f
;
domain
-
>
fBottom
=
max
(
outer
-
>
fY
)
+
0
.
5f
;
}
V4f
outset
=
0
.
5f
;
if
(
get_optimized_outset
(
metadata
rectilinear
&
outset
)
)
{
outset_vertices
(
outset
metadata
outer
)
;
outset_vertices
(
-
outset
metadata
inner
)
;
return
1
.
f
;
}
Edges
edges
=
get_edge_equations
(
metadata
*
inner
)
;
compute_degenerate_quad
(
aaFlags
metadata
.
fMask
edges
true
outer
)
;
return
compute_degenerate_quad
(
aaFlags
metadata
.
fMask
edges
false
inner
)
;
}
static
V4f
compute_nested_persp_quad_vertices
(
const
GrQuadAAFlags
aaFlags
Vertices
*
inner
Vertices
*
outer
SkRect
*
domain
)
{
SkASSERT
(
inner
-
>
fUVRCount
=
=
0
|
|
inner
-
>
fUVRCount
=
=
2
|
|
inner
-
>
fUVRCount
=
=
3
)
;
SkASSERT
(
outer
-
>
fUVRCount
=
=
inner
-
>
fUVRCount
)
;
V4f
iw
=
1
.
0f
/
inner
-
>
fW
;
V4f
x2d
=
inner
-
>
fX
*
iw
;
V4f
y2d
=
inner
-
>
fY
*
iw
;
Vertices
inner2D
=
{
x2d
y2d
1
.
f
0
.
f
0
.
f
0
.
f
0
}
;
Vertices
outer2D
=
inner2D
;
V4f
coverage
=
compute_nested_quad_vertices
(
aaFlags
false
&
inner2D
&
outer2D
domain
)
;
outset_projected_vertices
(
inner2D
.
fX
inner2D
.
fY
aaFlags
inner
)
;
outset_projected_vertices
(
outer2D
.
fX
outer2D
.
fY
aaFlags
outer
)
;
return
coverage
;
}
static
void
write_quad
(
GrVertexWriter
*
vb
const
GrQuadPerEdgeAA
:
:
VertexSpec
&
spec
GrQuadPerEdgeAA
:
:
CoverageMode
mode
const
V4f
&
coverage
SkPMColor4f
color4f
const
SkRect
&
geomDomain
const
SkRect
&
texDomain
const
Vertices
&
quad
)
{
static
constexpr
auto
If
=
GrVertexWriter
:
:
If
<
float
>
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
vb
-
>
write
(
quad
.
fX
[
i
]
quad
.
fY
[
i
]
If
(
spec
.
deviceQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
quad
.
fW
[
i
]
)
If
(
mode
=
=
GrQuadPerEdgeAA
:
:
CoverageMode
:
:
kWithPosition
coverage
[
i
]
)
)
;
if
(
spec
.
hasVertexColors
(
)
)
{
bool
wide
=
spec
.
colorType
(
)
=
=
GrQuadPerEdgeAA
:
:
ColorType
:
:
kHalf
;
vb
-
>
write
(
GrVertexColor
(
color4f
*
(
mode
=
=
GrQuadPerEdgeAA
:
:
CoverageMode
:
:
kWithColor
?
coverage
[
i
]
:
1
.
f
)
wide
)
)
;
}
if
(
spec
.
hasLocalCoords
(
)
)
{
vb
-
>
write
(
quad
.
fU
[
i
]
quad
.
fV
[
i
]
If
(
spec
.
localQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
quad
.
fR
[
i
]
)
)
;
}
if
(
spec
.
requiresGeometryDomain
(
)
)
{
vb
-
>
write
(
geomDomain
)
;
}
if
(
spec
.
hasDomain
(
)
)
{
vb
-
>
write
(
texDomain
)
;
}
}
}
GR_DECLARE_STATIC_UNIQUE_KEY
(
gAAFillRectIndexBufferKey
)
;
static
const
int
kVertsPerAAFillRect
=
8
;
static
const
int
kIndicesPerAAFillRect
=
30
;
static
sk_sp
<
const
GrGpuBuffer
>
get_index_buffer
(
GrResourceProvider
*
resourceProvider
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gAAFillRectIndexBufferKey
)
;
static
const
uint16_t
gFillAARectIdx
[
]
=
{
0
1
2
1
3
2
0
4
1
4
5
1
0
6
4
0
2
6
2
3
6
3
7
6
1
5
3
3
5
7
}
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
gFillAARectIdx
)
=
=
kIndicesPerAAFillRect
)
;
return
resourceProvider
-
>
findOrCreatePatternedIndexBuffer
(
gFillAARectIdx
kIndicesPerAAFillRect
GrQuadPerEdgeAA
:
:
kNumAAQuadsInIndexBuffer
kVertsPerAAFillRect
gAAFillRectIndexBufferKey
)
;
}
}
namespace
GrQuadPerEdgeAA
{
ColorType
MinColorType
(
SkPMColor4f
color
GrClampType
clampType
const
GrCaps
&
caps
)
{
if
(
color
=
=
SK_PMColor4fWHITE
)
{
return
ColorType
:
:
kNone
;
}
else
{
return
SkPMColor4fNeedsWideColor
(
color
clampType
caps
)
?
ColorType
:
:
kHalf
:
ColorType
:
:
kByte
;
}
}
void
*
Tessellate
(
void
*
vertices
const
VertexSpec
&
spec
const
GrQuad
&
deviceQuad
const
SkPMColor4f
&
color4f
const
GrQuad
&
localQuad
const
SkRect
&
domain
GrQuadAAFlags
aaFlags
)
{
SkASSERT
(
deviceQuad
.
quadType
(
)
<
=
spec
.
deviceQuadType
(
)
)
;
SkASSERT
(
!
spec
.
hasLocalCoords
(
)
|
|
localQuad
.
quadType
(
)
<
=
spec
.
localQuadType
(
)
)
;
GrQuadPerEdgeAA
:
:
CoverageMode
mode
=
spec
.
coverageMode
(
)
;
Vertices
outer
;
outer
.
fX
=
deviceQuad
.
x4f
(
)
;
outer
.
fY
=
deviceQuad
.
y4f
(
)
;
outer
.
fW
=
deviceQuad
.
w4f
(
)
;
outer
.
fUVRCount
=
spec
.
localDimensionality
(
)
;
if
(
spec
.
hasLocalCoords
(
)
)
{
outer
.
fU
=
localQuad
.
x4f
(
)
;
outer
.
fV
=
localQuad
.
y4f
(
)
;
outer
.
fR
=
localQuad
.
w4f
(
)
;
}
GrVertexWriter
vb
{
vertices
}
;
if
(
spec
.
usesCoverageAA
(
)
)
{
SkASSERT
(
mode
=
=
CoverageMode
:
:
kWithPosition
|
|
mode
=
=
CoverageMode
:
:
kWithColor
)
;
Vertices
inner
=
outer
;
SkRect
geomDomain
;
V4f
maxCoverage
=
1
.
f
;
if
(
spec
.
deviceQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
maxCoverage
=
compute_nested_persp_quad_vertices
(
aaFlags
&
inner
&
outer
&
geomDomain
)
;
}
else
if
(
aaFlags
!
=
GrQuadAAFlags
:
:
kNone
)
{
maxCoverage
=
compute_nested_quad_vertices
(
aaFlags
spec
.
deviceQuadType
(
)
<
=
GrQuad
:
:
Type
:
:
kRectilinear
&
inner
&
outer
&
geomDomain
)
;
}
else
if
(
spec
.
requiresGeometryDomain
(
)
)
{
geomDomain
.
fLeft
=
min
(
outer
.
fX
)
;
geomDomain
.
fRight
=
max
(
outer
.
fX
)
;
geomDomain
.
fTop
=
min
(
outer
.
fY
)
;
geomDomain
.
fBottom
=
max
(
outer
.
fY
)
;
}
write_quad
(
&
vb
spec
mode
maxCoverage
color4f
geomDomain
domain
inner
)
;
write_quad
(
&
vb
spec
mode
0
.
f
color4f
geomDomain
domain
outer
)
;
}
else
{
SkASSERT
(
mode
=
=
CoverageMode
:
:
kNone
&
&
!
spec
.
requiresGeometryDomain
(
)
)
;
write_quad
(
&
vb
spec
mode
1
.
f
color4f
SkRect
:
:
MakeEmpty
(
)
domain
outer
)
;
}
return
vb
.
fPtr
;
}
bool
ConfigureMeshIndices
(
GrMeshDrawOp
:
:
Target
*
target
GrMesh
*
mesh
const
VertexSpec
&
spec
int
quadCount
)
{
if
(
spec
.
usesCoverageAA
(
)
)
{
sk_sp
<
const
GrGpuBuffer
>
ibuffer
=
get_index_buffer
(
target
-
>
resourceProvider
(
)
)
;
if
(
!
ibuffer
)
{
return
false
;
}
mesh
-
>
setPrimitiveType
(
GrPrimitiveType
:
:
kTriangles
)
;
mesh
-
>
setIndexedPatterned
(
std
:
:
move
(
ibuffer
)
kIndicesPerAAFillRect
kVertsPerAAFillRect
quadCount
kNumAAQuadsInIndexBuffer
)
;
}
else
{
if
(
quadCount
>
1
)
{
sk_sp
<
const
GrGpuBuffer
>
ibuffer
=
target
-
>
resourceProvider
(
)
-
>
refQuadIndexBuffer
(
)
;
if
(
!
ibuffer
)
{
return
false
;
}
mesh
-
>
setPrimitiveType
(
GrPrimitiveType
:
:
kTriangles
)
;
mesh
-
>
setIndexedPatterned
(
std
:
:
move
(
ibuffer
)
6
4
quadCount
GrResourceProvider
:
:
QuadCountOfQuadBuffer
(
)
)
;
}
else
{
mesh
-
>
setPrimitiveType
(
GrPrimitiveType
:
:
kTriangleStrip
)
;
mesh
-
>
setNonIndexedNonInstanced
(
4
)
;
}
}
return
true
;
}
int
VertexSpec
:
:
deviceDimensionality
(
)
const
{
return
this
-
>
deviceQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
?
3
:
2
;
}
int
VertexSpec
:
:
localDimensionality
(
)
const
{
return
fHasLocalCoords
?
(
this
-
>
localQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
?
3
:
2
)
:
0
;
}
CoverageMode
VertexSpec
:
:
coverageMode
(
)
const
{
if
(
this
-
>
usesCoverageAA
(
)
)
{
if
(
this
-
>
compatibleWithCoverageAsAlpha
(
)
&
&
this
-
>
hasVertexColors
(
)
&
&
!
this
-
>
requiresGeometryDomain
(
)
)
{
return
CoverageMode
:
:
kWithColor
;
}
else
{
return
CoverageMode
:
:
kWithPosition
;
}
}
else
{
return
CoverageMode
:
:
kNone
;
}
}
size_t
VertexSpec
:
:
vertexSize
(
)
const
{
bool
needsPerspective
=
(
this
-
>
deviceDimensionality
(
)
=
=
3
)
;
CoverageMode
coverageMode
=
this
-
>
coverageMode
(
)
;
size_t
count
=
0
;
if
(
coverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
needsPerspective
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
else
{
count
+
=
GrVertexAttribTypeSize
(
kFloat2_GrVertexAttribType
)
+
GrVertexAttribTypeSize
(
kFloat_GrVertexAttribType
)
;
}
}
else
{
if
(
needsPerspective
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat3_GrVertexAttribType
)
;
}
else
{
count
+
=
GrVertexAttribTypeSize
(
kFloat2_GrVertexAttribType
)
;
}
}
if
(
this
-
>
requiresGeometryDomain
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
count
+
=
this
-
>
localDimensionality
(
)
*
GrVertexAttribTypeSize
(
kFloat_GrVertexAttribType
)
;
if
(
ColorType
:
:
kByte
=
=
this
-
>
colorType
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kUByte4_norm_GrVertexAttribType
)
;
}
else
if
(
ColorType
:
:
kHalf
=
=
this
-
>
colorType
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kHalf4_GrVertexAttribType
)
;
}
if
(
this
-
>
hasDomain
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
return
count
;
}
class
QuadPerEdgeAAGeometryProcessor
:
public
GrGeometryProcessor
{
public
:
using
Saturate
=
GrTextureOp
:
:
Saturate
;
static
sk_sp
<
GrGeometryProcessor
>
Make
(
const
VertexSpec
&
spec
)
{
return
sk_sp
<
QuadPerEdgeAAGeometryProcessor
>
(
new
QuadPerEdgeAAGeometryProcessor
(
spec
)
)
;
}
static
sk_sp
<
GrGeometryProcessor
>
Make
(
const
VertexSpec
&
vertexSpec
const
GrShaderCaps
&
caps
GrTextureType
textureType
const
GrSamplerState
&
samplerState
const
GrSwizzle
&
swizzle
uint32_t
extraSamplerKey
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
{
return
sk_sp
<
QuadPerEdgeAAGeometryProcessor
>
(
new
QuadPerEdgeAAGeometryProcessor
(
vertexSpec
caps
textureType
samplerState
swizzle
extraSamplerKey
std
:
:
move
(
textureColorSpaceXform
)
saturate
)
)
;
}
const
char
*
name
(
)
const
override
{
return
"
QuadPerEdgeAAGeometryProcessor
"
;
}
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
const
override
{
uint32_t
x
=
(
fTexDomain
.
isInitialized
(
)
?
0
:
0x1
)
|
(
fSampler
.
isInitialized
(
)
?
0
:
0x2
)
|
(
fNeedsPerspective
?
0
:
0x4
)
|
(
fSaturate
=
=
Saturate
:
:
kNo
?
0
:
0x8
)
;
if
(
fLocalCoord
.
isInitialized
(
)
)
{
x
|
=
kFloat3_GrVertexAttribType
=
=
fLocalCoord
.
cpuType
(
)
?
0x10
:
0x20
;
}
if
(
fColor
.
isInitialized
(
)
)
{
x
|
=
kUByte4_norm_GrVertexAttribType
=
=
fColor
.
cpuType
(
)
?
0x40
:
0x80
;
}
SkASSERT
(
!
fGeomDomain
.
isInitialized
(
)
|
|
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
;
if
(
fCoverageMode
!
=
CoverageMode
:
:
kNone
)
{
x
|
=
fGeomDomain
.
isInitialized
(
)
?
0x300
:
(
CoverageMode
:
:
kWithPosition
=
=
fCoverageMode
?
0x100
:
0x200
)
;
}
b
-
>
add32
(
GrColorSpaceXform
:
:
XformKey
(
fTextureColorSpaceXform
.
get
(
)
)
)
;
b
-
>
add32
(
x
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrShaderCaps
&
caps
)
const
override
{
class
GLSLProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
proc
FPCoordTransformIter
&
&
transformIter
)
override
{
const
auto
&
gp
=
proc
.
cast
<
QuadPerEdgeAAGeometryProcessor
>
(
)
;
if
(
gp
.
fLocalCoord
.
isInitialized
(
)
)
{
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
fTextureColorSpaceXformHelper
.
setData
(
pdman
gp
.
fTextureColorSpaceXform
.
get
(
)
)
;
}
private
:
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
using
Interpolation
=
GrGLSLVaryingHandler
:
:
Interpolation
;
const
auto
&
gp
=
args
.
fGP
.
cast
<
QuadPerEdgeAAGeometryProcessor
>
(
)
;
fTextureColorSpaceXformHelper
.
emitCode
(
args
.
fUniformHandler
gp
.
fTextureColorSpaceXform
.
get
(
)
)
;
args
.
fVaryingHandler
-
>
emitAttributes
(
gp
)
;
if
(
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
gp
.
fNeedsPerspective
)
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
float3
position
=
%
s
.
xyz
;
"
gp
.
fPosition
.
name
(
)
)
;
}
else
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
float2
position
=
%
s
.
xy
;
"
gp
.
fPosition
.
name
(
)
)
;
}
gpArgs
-
>
fPositionVar
=
{
"
position
"
gp
.
fNeedsPerspective
?
kFloat3_GrSLType
:
kFloat2_GrSLType
GrShaderVar
:
:
kNone_TypeModifier
}
;
}
else
{
gpArgs
-
>
fPositionVar
=
gp
.
fPosition
.
asShaderVar
(
)
;
}
if
(
gp
.
fLocalCoord
.
isInitialized
(
)
)
{
this
-
>
emitTransforms
(
args
.
fVertBuilder
args
.
fVaryingHandler
args
.
fUniformHandler
gp
.
fLocalCoord
.
asShaderVar
(
)
args
.
fFPCoordTransformHandler
)
;
}
if
(
gp
.
fColor
.
isInitialized
(
)
)
{
SkASSERT
(
gp
.
fCoverageMode
!
=
CoverageMode
:
:
kWithColor
|
|
!
gp
.
fNeedsPerspective
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fColor
args
.
fOutputColor
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithColor
?
Interpolation
:
:
kInterpolated
:
Interpolation
:
:
kCanBeFlat
)
;
}
else
{
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
1
)
;
"
args
.
fOutputColor
)
;
}
if
(
gp
.
fSampler
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float2
texCoord
;
"
)
;
if
(
gp
.
fLocalCoord
.
cpuType
(
)
=
=
kFloat3_GrVertexAttribType
)
{
GrGLSLVarying
v
(
gp
.
fLocalCoord
.
gpuType
(
)
)
;
args
.
fVaryingHandler
-
>
addVarying
(
gp
.
fLocalCoord
.
name
(
)
&
v
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
v
.
vsOut
(
)
gp
.
fLocalCoord
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
texCoord
=
%
s
.
xy
/
%
s
.
z
;
"
v
.
fsIn
(
)
v
.
fsIn
(
)
)
;
}
else
{
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fLocalCoord
"
texCoord
"
)
;
}
if
(
gp
.
fTexDomain
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float4
domain
;
"
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fTexDomain
"
domain
"
Interpolation
:
:
kCanBeFlat
)
;
args
.
fFragBuilder
-
>
codeAppend
(
"
texCoord
=
clamp
(
texCoord
domain
.
xy
domain
.
zw
)
;
"
)
;
}
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
"
args
.
fOutputColor
)
;
args
.
fFragBuilder
-
>
appendTextureLookupAndModulate
(
args
.
fOutputColor
args
.
fTexSamplers
[
0
]
"
texCoord
"
kFloat2_GrSLType
&
fTextureColorSpaceXformHelper
)
;
args
.
fFragBuilder
-
>
codeAppend
(
"
;
"
)
;
if
(
gp
.
fSaturate
=
=
Saturate
:
:
kYes
)
{
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
saturate
(
%
s
)
;
"
args
.
fOutputColor
args
.
fOutputColor
)
;
}
}
else
{
SkASSERT
(
gp
.
fSaturate
=
=
Saturate
:
:
kNo
)
;
}
if
(
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
GrGLSLVarying
coverage
(
kFloat_GrSLType
)
;
args
.
fVaryingHandler
-
>
addVarying
(
"
coverage
"
&
coverage
)
;
if
(
gp
.
fNeedsPerspective
)
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
.
w
*
%
s
.
z
;
"
coverage
.
vsOut
(
)
gp
.
fPosition
.
name
(
)
gp
.
fPosition
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
float
coverage
=
%
s
*
sk_FragCoord
.
w
;
"
coverage
.
fsIn
(
)
)
;
}
else
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
coverage
.
vsOut
(
)
gp
.
fCoverage
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
float
coverage
=
%
s
;
"
coverage
.
fsIn
(
)
)
;
}
if
(
gp
.
fGeomDomain
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float4
geoDomain
;
"
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fGeomDomain
"
geoDomain
"
Interpolation
:
:
kCanBeFlat
)
;
args
.
fFragBuilder
-
>
codeAppend
(
"
if
(
coverage
<
0
.
5
)
{
"
"
float4
dists4
=
clamp
(
float4
(
1
1
-
1
-
1
)
*
"
"
(
sk_FragCoord
.
xyxy
-
geoDomain
)
0
1
)
;
"
"
float2
dists2
=
dists4
.
xy
*
dists4
.
zw
;
"
"
coverage
=
min
(
coverage
dists2
.
x
*
dists2
.
y
)
;
"
"
}
"
)
;
}
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
half
(
coverage
)
)
;
"
args
.
fOutputCoverage
)
;
}
else
{
SkASSERT
(
!
gp
.
fGeomDomain
.
isInitialized
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
1
)
;
"
args
.
fOutputCoverage
)
;
}
}
GrGLSLColorSpaceXformHelper
fTextureColorSpaceXformHelper
;
}
;
return
new
GLSLProcessor
;
}
private
:
QuadPerEdgeAAGeometryProcessor
(
const
VertexSpec
&
spec
)
:
INHERITED
(
kQuadPerEdgeAAGeometryProcessor_ClassID
)
fTextureColorSpaceXform
(
nullptr
)
{
SkASSERT
(
!
spec
.
hasDomain
(
)
)
;
this
-
>
initializeAttrs
(
spec
)
;
this
-
>
setTextureSamplerCnt
(
0
)
;
}
QuadPerEdgeAAGeometryProcessor
(
const
VertexSpec
&
spec
const
GrShaderCaps
&
caps
GrTextureType
textureType
const
GrSamplerState
&
samplerState
const
GrSwizzle
&
swizzle
uint32_t
extraSamplerKey
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
:
INHERITED
(
kQuadPerEdgeAAGeometryProcessor_ClassID
)
fSaturate
(
saturate
)
fTextureColorSpaceXform
(
std
:
:
move
(
textureColorSpaceXform
)
)
fSampler
(
textureType
samplerState
swizzle
extraSamplerKey
)
{
SkASSERT
(
spec
.
hasLocalCoords
(
)
)
;
this
-
>
initializeAttrs
(
spec
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
void
initializeAttrs
(
const
VertexSpec
&
spec
)
{
fNeedsPerspective
=
spec
.
deviceDimensionality
(
)
=
=
3
;
fCoverageMode
=
spec
.
coverageMode
(
)
;
if
(
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
fNeedsPerspective
)
{
fPosition
=
{
"
positionWithCoverage
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
;
}
else
{
fPosition
=
{
"
position
"
kFloat2_GrVertexAttribType
kFloat2_GrSLType
}
;
fCoverage
=
{
"
coverage
"
kFloat_GrVertexAttribType
kFloat_GrSLType
}
;
}
}
else
{
if
(
fNeedsPerspective
)
{
fPosition
=
{
"
position
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
}
;
}
else
{
fPosition
=
{
"
position
"
kFloat2_GrVertexAttribType
kFloat2_GrSLType
}
;
}
}
if
(
spec
.
requiresGeometryDomain
(
)
)
{
fGeomDomain
=
{
"
geomDomain
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
;
}
int
localDim
=
spec
.
localDimensionality
(
)
;
if
(
localDim
=
=
3
)
{
fLocalCoord
=
{
"
localCoord
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
}
;
}
else
if
(
localDim
=
=
2
)
{
fLocalCoord
=
{
"
localCoord
"
kFloat2_GrVertexAttribType
kFloat2_GrSLType
}
;
}
if
(
ColorType
:
:
kByte
=
=
spec
.
colorType
(
)
)
{
fColor
=
{
"
color
"
kUByte4_norm_GrVertexAttribType
kHalf4_GrSLType
}
;
}
else
if
(
ColorType
:
:
kHalf
=
=
spec
.
colorType
(
)
)
{
fColor
=
{
"
color
"
kHalf4_GrVertexAttribType
kHalf4_GrSLType
}
;
}
if
(
spec
.
hasDomain
(
)
)
{
fTexDomain
=
{
"
texDomain
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
;
}
this
-
>
setVertexAttributes
(
&
fPosition
6
)
;
}
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fSampler
;
}
Attribute
fPosition
;
Attribute
fCoverage
;
Attribute
fColor
;
Attribute
fLocalCoord
;
Attribute
fGeomDomain
;
Attribute
fTexDomain
;
bool
fNeedsPerspective
;
Saturate
fSaturate
=
Saturate
:
:
kNo
;
CoverageMode
fCoverageMode
;
sk_sp
<
GrColorSpaceXform
>
fTextureColorSpaceXform
;
TextureSampler
fSampler
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
sk_sp
<
GrGeometryProcessor
>
MakeProcessor
(
const
VertexSpec
&
spec
)
{
return
QuadPerEdgeAAGeometryProcessor
:
:
Make
(
spec
)
;
}
sk_sp
<
GrGeometryProcessor
>
MakeTexturedProcessor
(
const
VertexSpec
&
spec
const
GrShaderCaps
&
caps
GrTextureType
textureType
const
GrSamplerState
&
samplerState
const
GrSwizzle
&
swizzle
uint32_t
extraSamplerKey
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
{
return
QuadPerEdgeAAGeometryProcessor
:
:
Make
(
spec
caps
textureType
samplerState
swizzle
extraSamplerKey
std
:
:
move
(
textureColorSpaceXform
)
saturate
)
;
}
}
