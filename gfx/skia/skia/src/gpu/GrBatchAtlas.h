#
ifndef
GrBatchAtlas_DEFINED
#
define
GrBatchAtlas_DEFINED
#
include
"
GrTexture
.
h
"
#
include
"
batches
/
GrDrawBatch
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTInternalLList
.
h
"
class
GrRectanizer
;
struct
GrBatchAtlasConfig
{
int
numPlotsX
(
)
const
{
return
fWidth
/
fPlotWidth
;
}
int
numPlotsY
(
)
const
{
return
fHeight
/
fPlotWidth
;
}
int
fWidth
;
int
fHeight
;
int
fPlotWidth
;
int
fPlotHeight
;
}
;
class
GrBatchAtlas
{
public
:
typedef
uint64_t
AtlasID
;
static
const
uint32_t
kInvalidAtlasID
=
0
;
static
const
uint64_t
kInvalidAtlasGeneration
=
0
;
typedef
void
(
*
EvictionFunc
)
(
GrBatchAtlas
:
:
AtlasID
void
*
)
;
GrBatchAtlas
(
GrTexture
*
int
numPlotsX
int
numPlotsY
)
;
~
GrBatchAtlas
(
)
;
bool
addToAtlas
(
AtlasID
*
GrDrawBatch
:
:
Target
*
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
GrTexture
*
getTexture
(
)
const
{
return
fTexture
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
inline
bool
hasID
(
AtlasID
id
)
{
uint32_t
index
=
GetIndexFromID
(
id
)
;
SkASSERT
(
index
<
fNumPlots
)
;
return
fPlotArray
[
index
]
-
>
genID
(
)
=
=
GetGenerationFromID
(
id
)
;
}
inline
void
setLastUseToken
(
AtlasID
id
GrBatchToken
batchToken
)
{
SkASSERT
(
this
-
>
hasID
(
id
)
)
;
uint32_t
index
=
GetIndexFromID
(
id
)
;
SkASSERT
(
index
<
fNumPlots
)
;
this
-
>
makeMRU
(
fPlotArray
[
index
]
)
;
fPlotArray
[
index
]
-
>
setLastUseToken
(
batchToken
)
;
}
inline
void
registerEvictionCallback
(
EvictionFunc
func
void
*
userData
)
{
EvictionData
*
data
=
fEvictionCallbacks
.
append
(
)
;
data
-
>
fFunc
=
func
;
data
-
>
fData
=
userData
;
}
class
BulkUseTokenUpdater
{
public
:
BulkUseTokenUpdater
(
)
:
fPlotAlreadyUpdated
(
0
)
{
}
BulkUseTokenUpdater
(
const
BulkUseTokenUpdater
&
that
)
:
fPlotsToUpdate
(
that
.
fPlotsToUpdate
)
fPlotAlreadyUpdated
(
that
.
fPlotAlreadyUpdated
)
{
}
void
add
(
AtlasID
id
)
{
int
index
=
GrBatchAtlas
:
:
GetIndexFromID
(
id
)
;
if
(
!
this
-
>
find
(
index
)
)
{
this
-
>
set
(
index
)
;
}
}
void
reset
(
)
{
fPlotsToUpdate
.
reset
(
)
;
fPlotAlreadyUpdated
=
0
;
}
private
:
bool
find
(
int
index
)
const
{
SkASSERT
(
index
<
kMaxPlots
)
;
return
(
fPlotAlreadyUpdated
>
>
index
)
&
1
;
}
void
set
(
int
index
)
{
SkASSERT
(
!
this
-
>
find
(
index
)
)
;
fPlotAlreadyUpdated
=
fPlotAlreadyUpdated
|
(
1
<
<
index
)
;
fPlotsToUpdate
.
push_back
(
index
)
;
}
static
const
int
kMinItems
=
4
;
static
const
int
kMaxPlots
=
32
;
SkSTArray
<
kMinItems
int
true
>
fPlotsToUpdate
;
uint32_t
fPlotAlreadyUpdated
;
friend
class
GrBatchAtlas
;
}
;
void
setLastUseTokenBulk
(
const
BulkUseTokenUpdater
&
updater
GrBatchToken
batchToken
)
{
int
count
=
updater
.
fPlotsToUpdate
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
BatchPlot
*
plot
=
fPlotArray
[
updater
.
fPlotsToUpdate
[
i
]
]
;
this
-
>
makeMRU
(
plot
)
;
plot
-
>
setLastUseToken
(
batchToken
)
;
}
}
static
const
int
kGlyphMaxDim
=
256
;
static
bool
GlyphTooLargeForAtlas
(
int
width
int
height
)
{
return
width
>
kGlyphMaxDim
|
|
height
>
kGlyphMaxDim
;
}
private
:
class
BatchPlot
:
public
SkRefCnt
{
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
BatchPlot
)
;
public
:
uint32_t
index
(
)
const
{
return
fIndex
;
}
uint64_t
genID
(
)
const
{
return
fGenID
;
}
GrBatchAtlas
:
:
AtlasID
id
(
)
const
{
SkASSERT
(
GrBatchAtlas
:
:
kInvalidAtlasID
!
=
fID
)
;
return
fID
;
}
SkDEBUGCODE
(
size_t
bpp
(
)
const
{
return
fBytesPerPixel
;
}
)
bool
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
GrBatchToken
lastUploadToken
(
)
const
{
return
fLastUpload
;
}
GrBatchToken
lastUseToken
(
)
const
{
return
fLastUse
;
}
void
setLastUploadToken
(
GrBatchToken
batchToken
)
{
SkASSERT
(
batchToken
>
=
fLastUpload
)
;
fLastUpload
=
batchToken
;
}
void
setLastUseToken
(
GrBatchToken
batchToken
)
{
SkASSERT
(
batchToken
>
=
fLastUse
)
;
fLastUse
=
batchToken
;
}
void
uploadToTexture
(
GrBatchUploader
:
:
TextureUploader
*
uploader
GrTexture
*
texture
)
;
void
resetRects
(
)
;
private
:
BatchPlot
(
int
index
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
;
~
BatchPlot
(
)
override
;
BatchPlot
*
clone
(
)
const
{
return
new
BatchPlot
(
fIndex
fGenID
+
1
fX
fY
fWidth
fHeight
fConfig
)
;
}
static
GrBatchAtlas
:
:
AtlasID
CreateId
(
uint32_t
index
uint64_t
generation
)
{
SkASSERT
(
index
<
(
1
<
<
16
)
)
;
SkASSERT
(
generation
<
(
(
uint64_t
)
1
<
<
48
)
)
;
return
generation
<
<
16
|
index
;
}
GrBatchToken
fLastUpload
;
GrBatchToken
fLastUse
;
const
uint32_t
fIndex
;
uint64_t
fGenID
;
GrBatchAtlas
:
:
AtlasID
fID
;
unsigned
char
*
fData
;
const
int
fWidth
;
const
int
fHeight
;
const
int
fX
;
const
int
fY
;
GrRectanizer
*
fRects
;
const
SkIPoint16
fOffset
;
const
GrPixelConfig
fConfig
;
const
size_t
fBytesPerPixel
;
SkIRect
fDirtyRect
;
SkDEBUGCODE
(
bool
fDirty
;
)
friend
class
GrBatchAtlas
;
typedef
SkRefCnt
INHERITED
;
}
;
typedef
SkTInternalLList
<
BatchPlot
>
GrBatchPlotList
;
static
uint32_t
GetIndexFromID
(
AtlasID
id
)
{
return
id
&
0xffff
;
}
static
uint64_t
GetGenerationFromID
(
AtlasID
id
)
{
return
(
id
>
>
16
)
&
0xffffffffffff
;
}
inline
void
updatePlot
(
GrDrawBatch
:
:
Target
*
AtlasID
*
BatchPlot
*
)
;
inline
void
makeMRU
(
BatchPlot
*
plot
)
{
if
(
fPlotList
.
head
(
)
=
=
plot
)
{
return
;
}
fPlotList
.
remove
(
plot
)
;
fPlotList
.
addToHead
(
plot
)
;
}
inline
void
processEviction
(
AtlasID
)
;
friend
class
GrPlotUploader
;
GrTexture
*
fTexture
;
SkDEBUGCODE
(
uint32_t
fNumPlots
;
)
uint64_t
fAtlasGeneration
;
struct
EvictionData
{
EvictionFunc
fFunc
;
void
*
fData
;
}
;
SkTDArray
<
EvictionData
>
fEvictionCallbacks
;
SkAutoTUnref
<
BatchPlot
>
*
fPlotArray
;
GrBatchPlotList
fPlotList
;
}
;
#
endif
