#
ifndef
GrGpuCommandBuffer_DEFINED
#
define
GrGpuCommandBuffer_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
ops
/
GrDrawOp
.
h
"
class
GrOpFlushState
;
class
GrFixedClip
;
class
GrGpu
;
class
GrMesh
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrRenderTarget
;
struct
SkIRect
;
struct
SkRect
;
class
GrGpuCommandBuffer
{
public
:
enum
class
LoadOp
{
kLoad
kClear
kDiscard
}
;
enum
class
StoreOp
{
kStore
kDiscard
}
;
struct
LoadAndStoreInfo
{
LoadOp
fLoadOp
;
StoreOp
fStoreOp
;
GrColor
fClearColor
;
}
;
GrGpuCommandBuffer
(
)
{
}
virtual
~
GrGpuCommandBuffer
(
)
{
}
virtual
void
end
(
)
=
0
;
void
submit
(
)
;
bool
draw
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
const
GrMesh
*
int
meshCount
const
SkRect
&
bounds
)
;
virtual
void
inlineUpload
(
GrOpFlushState
*
state
GrDrawOp
:
:
DeferredUploadFn
&
upload
GrRenderTarget
*
rt
)
=
0
;
void
clear
(
GrRenderTarget
*
const
GrFixedClip
&
GrColor
)
;
void
clearStencilClip
(
GrRenderTarget
*
const
GrFixedClip
&
bool
insideStencilMask
)
;
virtual
void
discard
(
GrRenderTarget
*
)
=
0
;
private
:
virtual
GrGpu
*
gpu
(
)
=
0
;
virtual
GrRenderTarget
*
renderTarget
(
)
=
0
;
virtual
void
onSubmit
(
)
=
0
;
virtual
void
onDraw
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
const
GrMesh
*
int
meshCount
const
SkRect
&
bounds
)
=
0
;
virtual
void
onClear
(
GrRenderTarget
*
const
GrFixedClip
&
GrColor
)
=
0
;
virtual
void
onClearStencilClip
(
GrRenderTarget
*
const
GrFixedClip
&
bool
insideStencilMask
)
=
0
;
}
;
#
endif
