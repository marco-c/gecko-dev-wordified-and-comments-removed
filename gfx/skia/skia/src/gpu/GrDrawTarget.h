#
ifndef
GrDrawTarget_DEFINED
#
define
GrDrawTarget_DEFINED
#
include
"
GrClip
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrPathProcessor
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
batches
/
GrDrawBatch
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkStringUtils
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkXfermode
.
h
"
class
GrAuditTrail
;
class
GrBatch
;
class
GrClearBatch
;
class
GrClip
;
class
GrCaps
;
class
GrPath
;
class
GrDrawPathBatchBase
;
class
GrPipelineBuilder
;
class
GrDrawTarget
final
:
public
SkRefCnt
{
public
:
struct
Options
{
Options
(
)
:
fClipBatchToBounds
(
false
)
fDrawBatchBounds
(
false
)
fMaxBatchLookback
(
-
1
)
fMaxBatchLookahead
(
-
1
)
{
}
bool
fClipBatchToBounds
;
bool
fDrawBatchBounds
;
int
fMaxBatchLookback
;
int
fMaxBatchLookahead
;
}
;
GrDrawTarget
(
GrRenderTarget
*
GrGpu
*
GrResourceProvider
*
GrAuditTrail
*
const
Options
&
)
;
~
GrDrawTarget
(
)
override
;
void
makeClosed
(
)
{
fLastFullClearBatch
=
nullptr
;
#
ifdef
ENABLE_MDB
this
-
>
setFlag
(
kClosed_Flag
)
;
#
endif
this
-
>
forwardCombine
(
)
;
}
bool
isClosed
(
)
const
{
return
this
-
>
isSetFlag
(
kClosed_Flag
)
;
}
void
clearRT
(
)
{
fRenderTarget
=
nullptr
;
}
void
addDependency
(
GrSurface
*
dependedOn
)
;
bool
dependsOn
(
GrDrawTarget
*
dependedOn
)
const
{
return
fDependencies
.
find
(
dependedOn
)
>
=
0
;
}
SkDEBUGCODE
(
void
dump
(
)
const
;
)
void
reset
(
)
;
void
prepareBatches
(
GrBatchFlushState
*
flushState
)
;
bool
drawBatches
(
GrBatchFlushState
*
flushState
)
;
const
GrCaps
*
caps
(
)
const
{
return
fGpu
-
>
caps
(
)
;
}
void
drawBatch
(
const
GrPipelineBuilder
&
GrDrawContext
*
const
GrClip
&
GrDrawBatch
*
)
;
void
addBatch
(
sk_sp
<
GrBatch
>
)
;
void
stencilPath
(
GrDrawContext
*
const
GrClip
&
bool
useHWAA
const
SkMatrix
&
viewMatrix
const
GrPath
*
)
;
void
fullClear
(
GrRenderTarget
*
GrColor
color
)
;
void
discard
(
GrRenderTarget
*
)
;
bool
copySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
gr_instanced
:
:
InstancedRendering
*
instancedRendering
(
)
const
{
SkASSERT
(
fInstancedRendering
)
;
return
fInstancedRendering
;
}
private
:
friend
class
GrDrawingManager
;
friend
class
GrDrawContextPriv
;
enum
Flags
{
kClosed_Flag
=
0x01
kWasOutput_Flag
=
0x02
kTempMark_Flag
=
0x04
}
;
void
setFlag
(
uint32_t
flag
)
{
fFlags
|
=
flag
;
}
void
resetFlag
(
uint32_t
flag
)
{
fFlags
&
=
~
flag
;
}
bool
isSetFlag
(
uint32_t
flag
)
const
{
return
SkToBool
(
fFlags
&
flag
)
;
}
struct
TopoSortTraits
{
static
void
Output
(
GrDrawTarget
*
dt
int
)
{
dt
-
>
setFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
static
bool
WasOutput
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
isSetFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
static
void
SetTempMark
(
GrDrawTarget
*
dt
)
{
dt
-
>
setFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
void
ResetTempMark
(
GrDrawTarget
*
dt
)
{
dt
-
>
resetFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
bool
IsTempMarked
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
isSetFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
int
NumDependencies
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
fDependencies
.
count
(
)
;
}
static
GrDrawTarget
*
Dependency
(
GrDrawTarget
*
dt
int
index
)
{
return
dt
-
>
fDependencies
[
index
]
;
}
}
;
GrBatch
*
recordBatch
(
GrBatch
*
const
SkRect
&
clippedBounds
)
;
void
forwardCombine
(
)
;
bool
setupDstReadIfNecessary
(
const
GrPipelineBuilder
&
GrRenderTarget
*
const
GrClip
&
const
GrPipelineOptimizations
&
optimizations
GrXferProcessor
:
:
DstTexture
*
const
SkRect
&
batchBounds
)
;
void
addDependency
(
GrDrawTarget
*
dependedOn
)
;
void
clearStencilClip
(
const
GrFixedClip
&
bool
insideStencilMask
GrRenderTarget
*
)
;
struct
RecordedBatch
{
sk_sp
<
GrBatch
>
fBatch
;
SkRect
fClippedBounds
;
}
;
SkSTArray
<
256
RecordedBatch
true
>
fRecordedBatches
;
GrClearBatch
*
fLastFullClearBatch
;
GrContext
*
fContext
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
GrAuditTrail
*
fAuditTrail
;
SkDEBUGCODE
(
int
fDebugID
;
)
uint32_t
fFlags
;
SkTDArray
<
GrDrawTarget
*
>
fDependencies
;
GrRenderTarget
*
fRenderTarget
;
bool
fClipBatchToBounds
;
bool
fDrawBatchBounds
;
int
fMaxBatchLookback
;
int
fMaxBatchLookahead
;
SkAutoTDelete
<
gr_instanced
:
:
InstancedRendering
>
fInstancedRendering
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
