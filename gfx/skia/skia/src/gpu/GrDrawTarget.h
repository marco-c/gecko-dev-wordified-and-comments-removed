#
ifndef
GrDrawTarget_DEFINED
#
define
GrDrawTarget_DEFINED
#
include
"
GrClip
.
h
"
#
include
"
GrClipMaskManager
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrPathProcessor
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
GrIndexBuffer
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrVertexBuffer
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
batches
/
GrDrawBatch
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkStringUtils
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkXfermode
.
h
"
class
GrAuditTrail
;
class
GrBatch
;
class
GrClip
;
class
GrCaps
;
class
GrPath
;
class
GrDrawPathBatchBase
;
class
GrDrawTarget
final
:
public
SkRefCnt
{
public
:
struct
Options
{
Options
(
)
:
fClipBatchToBounds
(
false
)
fDrawBatchBounds
(
false
)
fMaxBatchLookback
(
-
1
)
{
}
bool
fClipBatchToBounds
;
bool
fDrawBatchBounds
;
int
fMaxBatchLookback
;
}
;
GrDrawTarget
(
GrRenderTarget
*
GrGpu
*
GrResourceProvider
*
GrAuditTrail
*
const
Options
&
)
;
~
GrDrawTarget
(
)
override
;
void
makeClosed
(
)
{
#
ifdef
ENABLE_MDB
this
-
>
setFlag
(
kClosed_Flag
)
;
#
endif
}
bool
isClosed
(
)
const
{
return
this
-
>
isSetFlag
(
kClosed_Flag
)
;
}
void
clearRT
(
)
{
fRenderTarget
=
nullptr
;
}
void
addDependency
(
GrSurface
*
dependedOn
)
;
bool
dependsOn
(
GrDrawTarget
*
dependedOn
)
const
{
return
fDependencies
.
find
(
dependedOn
)
>
=
0
;
}
SkDEBUGCODE
(
void
dump
(
)
const
;
)
void
reset
(
)
;
void
prepareBatches
(
GrBatchFlushState
*
flushState
)
;
void
drawBatches
(
GrBatchFlushState
*
flushState
)
;
const
GrCaps
*
caps
(
)
const
{
return
fGpu
-
>
caps
(
)
;
}
void
drawBatch
(
const
GrPipelineBuilder
&
GrDrawBatch
*
)
;
void
stencilPath
(
const
GrPipelineBuilder
&
const
SkMatrix
&
viewMatrix
const
GrPath
*
GrPathRendering
:
:
FillType
)
;
void
drawPathBatch
(
const
GrPipelineBuilder
&
pipelineBuilder
GrDrawPathBatchBase
*
batch
)
;
void
clear
(
const
SkIRect
*
rect
GrColor
color
bool
canIgnoreRect
GrRenderTarget
*
renderTarget
)
;
void
discard
(
GrRenderTarget
*
)
;
void
copySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
class
CMMAccess
{
public
:
CMMAccess
(
GrDrawTarget
*
drawTarget
)
:
fDrawTarget
(
drawTarget
)
{
}
private
:
void
clearStencilClip
(
const
SkIRect
&
rect
bool
insideClip
GrRenderTarget
*
rt
)
const
{
fDrawTarget
-
>
clearStencilClip
(
rect
insideClip
rt
)
;
}
GrContext
*
context
(
)
const
{
return
fDrawTarget
-
>
fContext
;
}
GrResourceProvider
*
resourceProvider
(
)
const
{
return
fDrawTarget
-
>
fResourceProvider
;
}
GrDrawTarget
*
fDrawTarget
;
friend
class
GrClipMaskManager
;
}
;
const
CMMAccess
cmmAccess
(
)
{
return
CMMAccess
(
this
)
;
}
GrAuditTrail
*
getAuditTrail
(
)
const
{
return
fAuditTrail
;
}
private
:
friend
class
GrDrawingManager
;
enum
Flags
{
kClosed_Flag
=
0x01
kWasOutput_Flag
=
0x02
kTempMark_Flag
=
0x04
}
;
void
setFlag
(
uint32_t
flag
)
{
fFlags
|
=
flag
;
}
void
resetFlag
(
uint32_t
flag
)
{
fFlags
&
=
~
flag
;
}
bool
isSetFlag
(
uint32_t
flag
)
const
{
return
SkToBool
(
fFlags
&
flag
)
;
}
struct
TopoSortTraits
{
static
void
Output
(
GrDrawTarget
*
dt
int
)
{
dt
-
>
setFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
static
bool
WasOutput
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
isSetFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
static
void
SetTempMark
(
GrDrawTarget
*
dt
)
{
dt
-
>
setFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
void
ResetTempMark
(
GrDrawTarget
*
dt
)
{
dt
-
>
resetFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
bool
IsTempMarked
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
isSetFlag
(
GrDrawTarget
:
:
kTempMark_Flag
)
;
}
static
int
NumDependencies
(
const
GrDrawTarget
*
dt
)
{
return
dt
-
>
fDependencies
.
count
(
)
;
}
static
GrDrawTarget
*
Dependency
(
GrDrawTarget
*
dt
int
index
)
{
return
dt
-
>
fDependencies
[
index
]
;
}
}
;
void
recordBatch
(
GrBatch
*
)
;
bool
installPipelineInDrawBatch
(
const
GrPipelineBuilder
*
pipelineBuilder
const
GrScissorState
*
scissor
GrDrawBatch
*
batch
)
;
bool
setupDstReadIfNecessary
(
const
GrPipelineBuilder
&
const
GrPipelineOptimizations
&
optimizations
GrXferProcessor
:
:
DstTexture
*
const
SkRect
&
batchBounds
)
;
void
getPathStencilSettingsForFilltype
(
GrPathRendering
:
:
FillType
const
GrStencilAttachment
*
GrStencilSettings
*
)
;
bool
setupClip
(
const
GrPipelineBuilder
&
GrPipelineBuilder
:
:
AutoRestoreFragmentProcessorState
*
GrPipelineBuilder
:
:
AutoRestoreStencil
*
GrScissorState
*
const
SkRect
*
devBounds
)
;
void
addDependency
(
GrDrawTarget
*
dependedOn
)
;
void
clearStencilClip
(
const
SkIRect
&
bool
insideClip
GrRenderTarget
*
)
;
SkSTArray
<
256
SkAutoTUnref
<
GrBatch
>
true
>
fBatches
;
SkAutoTDelete
<
GrClipMaskManager
>
fClipMaskManager
;
GrContext
*
fContext
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
GrAuditTrail
*
fAuditTrail
;
SkDEBUGCODE
(
int
fDebugID
;
)
uint32_t
fFlags
;
SkTDArray
<
GrDrawTarget
*
>
fDependencies
;
GrRenderTarget
*
fRenderTarget
;
bool
fDrawBatchBounds
;
int
fMaxBatchLookback
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
