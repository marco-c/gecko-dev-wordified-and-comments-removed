#
include
"
include
/
core
/
SkTraceMemoryDump
.
h
"
#
include
"
src
/
gpu
/
GrSemaphore
.
h
"
#
include
"
src
/
gpu
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLGpu
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLTexture
.
h
"
#
define
GPUGL
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
#
define
GL_CALL
(
X
)
GR_GL_CALL
(
GPUGL
-
>
glInterface
(
)
X
)
GrTextureType
GrGLTexture
:
:
TextureTypeFromTarget
(
GrGLenum
target
)
{
switch
(
target
)
{
case
GR_GL_TEXTURE_2D
:
return
GrTextureType
:
:
k2D
;
case
GR_GL_TEXTURE_RECTANGLE
:
return
GrTextureType
:
:
kRectangle
;
case
GR_GL_TEXTURE_EXTERNAL
:
return
GrTextureType
:
:
kExternal
;
}
SK_ABORT
(
"
Unexpected
texture
target
"
)
;
}
static
inline
GrGLenum
target_from_texture_type
(
GrTextureType
type
)
{
switch
(
type
)
{
case
GrTextureType
:
:
k2D
:
return
GR_GL_TEXTURE_2D
;
case
GrTextureType
:
:
kRectangle
:
return
GR_GL_TEXTURE_RECTANGLE
;
case
GrTextureType
:
:
kExternal
:
return
GR_GL_TEXTURE_EXTERNAL
;
default
:
SK_ABORT
(
"
Unexpected
texture
target
"
)
;
}
SK_ABORT
(
"
Unexpected
texture
type
"
)
;
}
GrGLTexture
:
:
GrGLTexture
(
GrGLGpu
*
gpu
SkBudgeted
budgeted
const
Desc
&
desc
GrMipMapsStatus
mipMapsStatus
)
:
GrSurface
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
)
INHERITED
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
TextureTypeFromTarget
(
desc
.
fTarget
)
mipMapsStatus
)
fParameters
(
sk_make_sp
<
GrGLTextureParameters
>
(
)
)
{
this
-
>
init
(
desc
)
;
this
-
>
registerWithCache
(
budgeted
)
;
if
(
GrGLFormatIsCompressed
(
desc
.
fFormat
)
)
{
this
-
>
setReadOnly
(
)
;
}
}
GrGLTexture
:
:
GrGLTexture
(
GrGLGpu
*
gpu
const
Desc
&
desc
GrMipMapsStatus
mipMapsStatus
sk_sp
<
GrGLTextureParameters
>
parameters
GrWrapCacheable
cacheable
GrIOType
ioType
)
:
GrSurface
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
)
INHERITED
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
TextureTypeFromTarget
(
desc
.
fTarget
)
mipMapsStatus
)
fParameters
(
std
:
:
move
(
parameters
)
)
{
SkASSERT
(
fParameters
)
;
this
-
>
init
(
desc
)
;
this
-
>
registerWithCacheWrapped
(
cacheable
)
;
if
(
ioType
=
=
kRead_GrIOType
)
{
this
-
>
setReadOnly
(
)
;
}
}
GrGLTexture
:
:
GrGLTexture
(
GrGLGpu
*
gpu
const
Desc
&
desc
sk_sp
<
GrGLTextureParameters
>
parameters
GrMipMapsStatus
mipMapsStatus
)
:
GrSurface
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
)
INHERITED
(
gpu
desc
.
fSize
desc
.
fConfig
GrProtected
:
:
kNo
TextureTypeFromTarget
(
desc
.
fTarget
)
mipMapsStatus
)
{
SkASSERT
(
parameters
|
|
desc
.
fOwnership
=
=
GrBackendObjectOwnership
:
:
kOwned
)
;
fParameters
=
parameters
?
std
:
:
move
(
parameters
)
:
sk_make_sp
<
GrGLTextureParameters
>
(
)
;
this
-
>
init
(
desc
)
;
}
void
GrGLTexture
:
:
init
(
const
Desc
&
desc
)
{
SkASSERT
(
0
!
=
desc
.
fID
)
;
SkASSERT
(
GrGLFormat
:
:
kUnknown
!
=
desc
.
fFormat
)
;
fID
=
desc
.
fID
;
fFormat
=
desc
.
fFormat
;
fTextureIDOwnership
=
desc
.
fOwnership
;
}
GrGLenum
GrGLTexture
:
:
target
(
)
const
{
return
target_from_texture_type
(
this
-
>
texturePriv
(
)
.
textureType
(
)
)
;
}
void
GrGLTexture
:
:
onRelease
(
)
{
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
if
(
fID
)
{
if
(
GrBackendObjectOwnership
:
:
kBorrowed
!
=
fTextureIDOwnership
)
{
GL_CALL
(
DeleteTextures
(
1
&
fID
)
)
;
}
fID
=
0
;
}
INHERITED
:
:
onRelease
(
)
;
}
void
GrGLTexture
:
:
onAbandon
(
)
{
fID
=
0
;
INHERITED
:
:
onAbandon
(
)
;
}
GrBackendTexture
GrGLTexture
:
:
getBackendTexture
(
)
const
{
GrGLTextureInfo
info
;
info
.
fTarget
=
target_from_texture_type
(
this
-
>
texturePriv
(
)
.
textureType
(
)
)
;
info
.
fID
=
fID
;
info
.
fFormat
=
GrGLFormatToEnum
(
fFormat
)
;
return
GrBackendTexture
(
this
-
>
width
(
)
this
-
>
height
(
)
this
-
>
texturePriv
(
)
.
mipMapped
(
)
info
fParameters
)
;
}
GrBackendFormat
GrGLTexture
:
:
backendFormat
(
)
const
{
return
GrBackendFormat
:
:
MakeGL
(
GrGLFormatToEnum
(
fFormat
)
target_from_texture_type
(
this
-
>
texturePriv
(
)
.
textureType
(
)
)
)
;
}
sk_sp
<
GrGLTexture
>
GrGLTexture
:
:
MakeWrapped
(
GrGLGpu
*
gpu
GrMipMapsStatus
mipMapsStatus
const
Desc
&
desc
sk_sp
<
GrGLTextureParameters
>
parameters
GrWrapCacheable
cacheable
GrIOType
ioType
)
{
return
sk_sp
<
GrGLTexture
>
(
new
GrGLTexture
(
gpu
desc
mipMapsStatus
std
:
:
move
(
parameters
)
cacheable
ioType
)
)
;
}
bool
GrGLTexture
:
:
onStealBackendTexture
(
GrBackendTexture
*
backendTexture
SkImage
:
:
BackendTextureReleaseProc
*
releaseProc
)
{
*
backendTexture
=
this
-
>
getBackendTexture
(
)
;
*
releaseProc
=
[
]
(
GrBackendTexture
)
{
}
;
this
-
>
GrGLTexture
:
:
onAbandon
(
)
;
return
true
;
}
void
GrGLTexture
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
bool
refsWrappedTextureObjects
=
this
-
>
fTextureIDOwnership
=
=
GrBackendObjectOwnership
:
:
kBorrowed
;
if
(
refsWrappedTextureObjects
&
&
!
traceMemoryDump
-
>
shouldDumpWrappedObjects
(
)
)
{
return
;
}
SkString
resourceName
=
this
-
>
getResourceName
(
)
;
resourceName
.
append
(
"
/
texture
"
)
;
this
-
>
dumpMemoryStatisticsPriv
(
traceMemoryDump
resourceName
"
Texture
"
GrGLTexture
:
:
gpuMemorySize
(
)
)
;
SkString
texture_id
;
texture_id
.
appendU32
(
this
-
>
textureID
(
)
)
;
traceMemoryDump
-
>
setMemoryBacking
(
resourceName
.
c_str
(
)
"
gl_texture
"
texture_id
.
c_str
(
)
)
;
}
