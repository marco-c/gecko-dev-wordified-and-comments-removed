#
ifndef
GrGLTexture_DEFINED
#
define
GrGLTexture_DEFINED
#
include
"
GrGpu
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrGLUtil
.
h
"
class
GrGLGpu
;
class
GrGLTexture
:
public
GrTexture
{
public
:
struct
TexParams
{
GrGLenum
fMinFilter
;
GrGLenum
fMagFilter
;
GrGLenum
fWrapS
;
GrGLenum
fWrapT
;
GrGLenum
fMaxMipMapLevel
;
GrGLenum
fSwizzleRGBA
[
4
]
;
GrGLenum
fSRGBDecode
;
void
invalidate
(
)
{
memset
(
this
0xff
sizeof
(
TexParams
)
)
;
}
}
;
struct
IDDesc
{
GrGLTextureInfo
fInfo
;
GrBackendObjectOwnership
fOwnership
;
}
;
GrGLTexture
(
GrGLGpu
*
SkBudgeted
const
GrSurfaceDesc
&
const
IDDesc
&
)
;
GrGLTexture
(
GrGLGpu
*
SkBudgeted
const
GrSurfaceDesc
&
const
IDDesc
&
bool
wasMipMapDataProvided
)
;
GrBackendObject
getTextureHandle
(
)
const
override
;
void
textureParamsModified
(
)
override
{
fTexParams
.
invalidate
(
)
;
}
const
TexParams
&
getCachedTexParams
(
GrGpu
:
:
ResetTimestamp
*
timestamp
)
const
{
*
timestamp
=
fTexParamsTimestamp
;
return
fTexParams
;
}
void
setCachedTexParams
(
const
TexParams
&
texParams
GrGpu
:
:
ResetTimestamp
timestamp
)
{
fTexParams
=
texParams
;
fTexParamsTimestamp
=
timestamp
;
}
GrGLuint
textureID
(
)
const
{
return
fInfo
.
fID
;
}
GrGLenum
target
(
)
const
{
return
fInfo
.
fTarget
;
}
static
sk_sp
<
GrGLTexture
>
MakeWrapped
(
GrGLGpu
*
const
GrSurfaceDesc
&
const
IDDesc
&
)
;
protected
:
GrGLTexture
(
GrGLGpu
*
const
GrSurfaceDesc
&
const
IDDesc
&
bool
wasMipMapDataProvided
)
;
enum
Wrapped
{
kWrapped
}
;
GrGLTexture
(
GrGLGpu
*
Wrapped
const
GrSurfaceDesc
&
const
IDDesc
&
)
;
void
init
(
const
GrSurfaceDesc
&
const
IDDesc
&
)
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
void
setMemoryBacking
(
SkTraceMemoryDump
*
traceMemoryDump
const
SkString
&
dumpName
)
const
override
;
std
:
:
unique_ptr
<
GrExternalTextureData
>
detachBackendTexture
(
)
override
;
private
:
TexParams
fTexParams
;
GrGpu
:
:
ResetTimestamp
fTexParamsTimestamp
;
GrGLTextureInfo
fInfo
;
GrBackendObjectOwnership
fTextureIDOwnership
;
typedef
GrTexture
INHERITED
;
}
;
#
endif
