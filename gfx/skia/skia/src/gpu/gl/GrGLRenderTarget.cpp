#
include
"
include
/
core
/
SkTraceMemoryDump
.
h
"
#
include
"
include
/
gpu
/
GrContext
.
h
"
#
include
"
src
/
gpu
/
GrContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetPriv
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLGpu
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLRenderTarget
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLUtil
.
h
"
#
define
GPUGL
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
#
define
GL_CALL
(
X
)
GR_GL_CALL
(
GPUGL
-
>
glInterface
(
)
X
)
GrGLRenderTarget
:
:
GrGLRenderTarget
(
GrGLGpu
*
gpu
const
SkISize
&
size
GrGLFormat
format
GrPixelConfig
config
int
sampleCount
const
IDs
&
ids
GrGLStencilAttachment
*
stencil
)
:
GrSurface
(
gpu
size
config
GrProtected
:
:
kNo
)
INHERITED
(
gpu
size
config
sampleCount
GrProtected
:
:
kNo
stencil
)
{
this
-
>
setFlags
(
gpu
-
>
glCaps
(
)
ids
)
;
this
-
>
init
(
format
ids
)
;
this
-
>
registerWithCacheWrapped
(
GrWrapCacheable
:
:
kNo
)
;
}
GrGLRenderTarget
:
:
GrGLRenderTarget
(
GrGLGpu
*
gpu
const
SkISize
&
size
GrGLFormat
format
GrPixelConfig
config
int
sampleCount
const
IDs
&
ids
)
:
GrSurface
(
gpu
size
config
GrProtected
:
:
kNo
)
INHERITED
(
gpu
size
config
sampleCount
GrProtected
:
:
kNo
)
{
this
-
>
setFlags
(
gpu
-
>
glCaps
(
)
ids
)
;
this
-
>
init
(
format
ids
)
;
}
inline
void
GrGLRenderTarget
:
:
setFlags
(
const
GrGLCaps
&
glCaps
const
IDs
&
idDesc
)
{
if
(
!
idDesc
.
fRTFBOID
)
{
this
-
>
setGLRTFBOIDIs0
(
)
;
}
}
void
GrGLRenderTarget
:
:
init
(
GrGLFormat
format
const
IDs
&
idDesc
)
{
fRTFBOID
=
idDesc
.
fRTFBOID
;
fTexFBOID
=
idDesc
.
fTexFBOID
;
fMSColorRenderbufferID
=
idDesc
.
fMSColorRenderbufferID
;
fRTFBOOwnership
=
idDesc
.
fRTFBOOwnership
;
fRTFormat
=
format
;
fNumSamplesOwnedPerPixel
=
this
-
>
totalSamples
(
)
;
}
sk_sp
<
GrGLRenderTarget
>
GrGLRenderTarget
:
:
MakeWrapped
(
GrGLGpu
*
gpu
const
SkISize
&
size
GrGLFormat
format
GrPixelConfig
config
int
sampleCount
const
IDs
&
idDesc
int
stencilBits
)
{
GrGLStencilAttachment
*
sb
=
nullptr
;
if
(
stencilBits
)
{
GrGLStencilAttachment
:
:
IDDesc
sbDesc
;
GrGLStencilAttachment
:
:
Format
format
;
format
.
fInternalFormat
=
GrGLStencilAttachment
:
:
kUnknownInternalFormat
;
format
.
fPacked
=
false
;
format
.
fStencilBits
=
stencilBits
;
format
.
fTotalBits
=
stencilBits
;
sb
=
new
GrGLStencilAttachment
(
gpu
sbDesc
size
.
width
(
)
size
.
height
(
)
sampleCount
format
)
;
}
return
sk_sp
<
GrGLRenderTarget
>
(
new
GrGLRenderTarget
(
gpu
size
format
config
sampleCount
idDesc
sb
)
)
;
}
GrBackendRenderTarget
GrGLRenderTarget
:
:
getBackendRenderTarget
(
)
const
{
GrGLFramebufferInfo
fbi
;
fbi
.
fFBOID
=
fRTFBOID
;
fbi
.
fFormat
=
GrGLFormatToEnum
(
this
-
>
format
(
)
)
;
int
numStencilBits
=
0
;
if
(
GrStencilAttachment
*
stencil
=
this
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
)
{
numStencilBits
=
stencil
-
>
bits
(
)
;
}
return
GrBackendRenderTarget
(
this
-
>
width
(
)
this
-
>
height
(
)
this
-
>
numSamples
(
)
numStencilBits
fbi
)
;
}
GrBackendFormat
GrGLRenderTarget
:
:
backendFormat
(
)
const
{
return
GrBackendFormat
:
:
MakeGL
(
GrGLFormatToEnum
(
fRTFormat
)
GR_GL_TEXTURE_2D
)
;
}
size_t
GrGLRenderTarget
:
:
onGpuMemorySize
(
)
const
{
const
GrCaps
&
caps
=
*
this
-
>
getGpu
(
)
-
>
caps
(
)
;
return
GrSurface
:
:
ComputeSize
(
caps
this
-
>
backendFormat
(
)
this
-
>
width
(
)
this
-
>
height
(
)
fNumSamplesOwnedPerPixel
GrMipMapped
:
:
kNo
)
;
}
bool
GrGLRenderTarget
:
:
completeStencilAttachment
(
)
{
GrGLGpu
*
gpu
=
this
-
>
getGLGpu
(
)
;
const
GrGLInterface
*
interface
=
gpu
-
>
glInterface
(
)
;
GrStencilAttachment
*
stencil
=
this
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
if
(
nullptr
=
=
stencil
)
{
GR_GL_CALL
(
interface
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_STENCIL_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
GR_GL_CALL
(
interface
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
#
ifdef
SK_DEBUG
if
(
kChromium_GrGLDriver
!
=
gpu
-
>
glContext
(
)
.
driver
(
)
)
{
GrGLenum
status
;
GR_GL_CALL_RET
(
interface
status
CheckFramebufferStatus
(
GR_GL_FRAMEBUFFER
)
)
;
SkASSERT
(
GR_GL_FRAMEBUFFER_COMPLETE
=
=
status
)
;
}
#
endif
return
true
;
}
else
{
const
GrGLStencilAttachment
*
glStencil
=
static_cast
<
const
GrGLStencilAttachment
*
>
(
stencil
)
;
GrGLuint
rb
=
glStencil
-
>
renderbufferID
(
)
;
gpu
-
>
invalidateBoundRenderTarget
(
)
;
gpu
-
>
bindFramebuffer
(
GR_GL_FRAMEBUFFER
this
-
>
renderFBOID
(
)
)
;
GR_GL_CALL
(
interface
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_STENCIL_ATTACHMENT
GR_GL_RENDERBUFFER
rb
)
)
;
if
(
glStencil
-
>
format
(
)
.
fPacked
)
{
GR_GL_CALL
(
interface
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
rb
)
)
;
}
else
{
GR_GL_CALL
(
interface
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
}
#
ifdef
SK_DEBUG
if
(
kChromium_GrGLDriver
!
=
gpu
-
>
glContext
(
)
.
driver
(
)
)
{
GrGLenum
status
;
GR_GL_CALL_RET
(
interface
status
CheckFramebufferStatus
(
GR_GL_FRAMEBUFFER
)
)
;
SkASSERT
(
GR_GL_FRAMEBUFFER_COMPLETE
=
=
status
)
;
}
#
endif
return
true
;
}
}
void
GrGLRenderTarget
:
:
onRelease
(
)
{
if
(
GrBackendObjectOwnership
:
:
kBorrowed
!
=
fRTFBOOwnership
)
{
GrGLGpu
*
gpu
=
this
-
>
getGLGpu
(
)
;
if
(
fTexFBOID
)
{
gpu
-
>
deleteFramebuffer
(
fTexFBOID
)
;
}
if
(
fRTFBOID
&
&
fRTFBOID
!
=
fTexFBOID
)
{
gpu
-
>
deleteFramebuffer
(
fRTFBOID
)
;
}
if
(
fMSColorRenderbufferID
)
{
GL_CALL
(
DeleteRenderbuffers
(
1
&
fMSColorRenderbufferID
)
)
;
}
}
fRTFBOID
=
0
;
fTexFBOID
=
0
;
fMSColorRenderbufferID
=
0
;
INHERITED
:
:
onRelease
(
)
;
}
void
GrGLRenderTarget
:
:
onAbandon
(
)
{
fRTFBOID
=
0
;
fTexFBOID
=
0
;
fMSColorRenderbufferID
=
0
;
INHERITED
:
:
onAbandon
(
)
;
}
GrGLGpu
*
GrGLRenderTarget
:
:
getGLGpu
(
)
const
{
SkASSERT
(
!
this
-
>
wasDestroyed
(
)
)
;
return
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
;
}
bool
GrGLRenderTarget
:
:
canAttemptStencilAttachment
(
)
const
{
if
(
this
-
>
getGpu
(
)
-
>
getContext
(
)
-
>
priv
(
)
.
caps
(
)
-
>
avoidStencilBuffers
(
)
)
{
return
false
;
}
return
this
-
>
fRTFBOOwnership
=
=
GrBackendObjectOwnership
:
:
kOwned
;
}
void
GrGLRenderTarget
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
bool
refsWrappedRenderTargetObjects
=
this
-
>
fRTFBOOwnership
=
=
GrBackendObjectOwnership
:
:
kBorrowed
;
if
(
refsWrappedRenderTargetObjects
&
&
!
traceMemoryDump
-
>
shouldDumpWrappedObjects
(
)
)
{
return
;
}
if
(
fMSColorRenderbufferID
)
{
const
GrCaps
&
caps
=
*
this
-
>
getGpu
(
)
-
>
caps
(
)
;
size_t
size
=
GrSurface
:
:
ComputeSize
(
caps
this
-
>
backendFormat
(
)
this
-
>
width
(
)
this
-
>
height
(
)
this
-
>
msaaSamples
(
)
GrMipMapped
:
:
kNo
)
;
SkString
resourceName
=
this
-
>
getResourceName
(
)
;
resourceName
.
append
(
"
/
renderbuffer
"
)
;
this
-
>
dumpMemoryStatisticsPriv
(
traceMemoryDump
resourceName
"
RenderTarget
"
size
)
;
SkString
renderbuffer_id
;
renderbuffer_id
.
appendU32
(
fMSColorRenderbufferID
)
;
traceMemoryDump
-
>
setMemoryBacking
(
resourceName
.
c_str
(
)
"
gl_renderbuffer
"
renderbuffer_id
.
c_str
(
)
)
;
}
}
int
GrGLRenderTarget
:
:
msaaSamples
(
)
const
{
if
(
fTexFBOID
=
=
kUnresolvableFBOID
|
|
fTexFBOID
!
=
fRTFBOID
)
{
return
this
-
>
numSamples
(
)
;
}
return
0
;
}
int
GrGLRenderTarget
:
:
totalSamples
(
)
const
{
int
total_samples
=
this
-
>
msaaSamples
(
)
;
if
(
fTexFBOID
!
=
kUnresolvableFBOID
)
{
total_samples
+
=
1
;
}
return
total_samples
;
}
