#
include
"
src
/
gpu
/
gl
/
GrGLGpu
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLPathRendering
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLUtil
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLPath
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLPathRendering
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkTypeface
.
h
"
#
define
GL_CALL
(
X
)
GR_GL_CALL
(
this
-
>
gpu
(
)
-
>
glInterface
(
)
X
)
#
define
GL_CALL_RET
(
RET
X
)
GR_GL_CALL_RET
(
this
-
>
gpu
(
)
-
>
glInterface
(
)
RET
X
)
static
const
GrGLsizei
kPathIDPreallocationAmount
=
65536
;
GR_STATIC_ASSERT
(
0
=
=
GrPathRendering
:
:
kNone_PathTransformType
)
;
GR_STATIC_ASSERT
(
1
=
=
GrPathRendering
:
:
kTranslateX_PathTransformType
)
;
GR_STATIC_ASSERT
(
2
=
=
GrPathRendering
:
:
kTranslateY_PathTransformType
)
;
GR_STATIC_ASSERT
(
3
=
=
GrPathRendering
:
:
kTranslate_PathTransformType
)
;
GR_STATIC_ASSERT
(
4
=
=
GrPathRendering
:
:
kAffine_PathTransformType
)
;
GR_STATIC_ASSERT
(
GrPathRendering
:
:
kAffine_PathTransformType
=
=
GrPathRendering
:
:
kLast_PathTransformType
)
;
#
ifdef
SK_DEBUG
static
void
verify_floats
(
const
float
*
floats
int
count
)
{
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
SkScalarIsNaN
(
SkFloatToScalar
(
floats
[
i
]
)
)
)
;
}
}
#
endif
static
GrGLenum
gr_stencil_op_to_gl_path_rendering_fill_mode
(
GrStencilOp
op
)
{
switch
(
op
)
{
default
:
SK_ABORT
(
"
Unexpected
path
fill
.
"
)
;
case
GrStencilOp
:
:
kIncWrap
:
return
GR_GL_COUNT_UP
;
case
GrStencilOp
:
:
kInvert
:
return
GR_GL_INVERT
;
}
}
GrGLPathRendering
:
:
GrGLPathRendering
(
GrGLGpu
*
gpu
)
:
GrPathRendering
(
gpu
)
fPreallocatedPathCount
(
0
)
{
const
GrGLInterface
*
glInterface
=
gpu
-
>
glInterface
(
)
;
fCaps
.
bindFragmentInputSupport
=
(
bool
)
glInterface
-
>
fFunctions
.
fBindFragmentInputLocation
;
}
GrGLPathRendering
:
:
~
GrGLPathRendering
(
)
{
if
(
fPreallocatedPathCount
>
0
)
{
this
-
>
deletePaths
(
fFirstPreallocatedPathID
fPreallocatedPathCount
)
;
}
}
void
GrGLPathRendering
:
:
disconnect
(
GrGpu
:
:
DisconnectType
type
)
{
if
(
GrGpu
:
:
DisconnectType
:
:
kCleanup
=
=
type
)
{
this
-
>
deletePaths
(
fFirstPreallocatedPathID
fPreallocatedPathCount
)
;
}
fPreallocatedPathCount
=
0
;
}
void
GrGLPathRendering
:
:
resetContext
(
)
{
fHWProjectionMatrixState
.
invalidate
(
)
;
GL_CALL
(
MatrixLoadIdentity
(
GR_GL_PATH_MODELVIEW
)
)
;
fHWPathStencilSettings
.
invalidate
(
)
;
}
sk_sp
<
GrPath
>
GrGLPathRendering
:
:
createPath
(
const
SkPath
&
inPath
const
GrStyle
&
style
)
{
return
sk_make_sp
<
GrGLPath
>
(
this
-
>
gpu
(
)
inPath
style
)
;
}
void
GrGLPathRendering
:
:
onStencilPath
(
const
StencilPathArgs
&
args
const
GrPath
*
path
)
{
GrGLGpu
*
gpu
=
this
-
>
gpu
(
)
;
SkASSERT
(
gpu
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
)
;
gpu
-
>
flushColorWrite
(
false
)
;
GrGLRenderTarget
*
rt
=
static_cast
<
GrGLRenderTarget
*
>
(
args
.
fProxy
-
>
peekRenderTarget
(
)
)
;
SkISize
size
=
SkISize
:
:
Make
(
rt
-
>
width
(
)
rt
-
>
height
(
)
)
;
this
-
>
setProjectionMatrix
(
*
args
.
fViewMatrix
size
args
.
fProxy
-
>
origin
(
)
)
;
gpu
-
>
flushScissor
(
*
args
.
fScissor
rt
-
>
width
(
)
rt
-
>
height
(
)
args
.
fProxy
-
>
origin
(
)
)
;
gpu
-
>
flushHWAAState
(
rt
args
.
fUseHWAA
)
;
gpu
-
>
flushRenderTarget
(
rt
)
;
const
GrGLPath
*
glPath
=
static_cast
<
const
GrGLPath
*
>
(
path
)
;
this
-
>
flushPathStencilSettings
(
*
args
.
fStencil
)
;
GrGLenum
fillMode
=
gr_stencil_op_to_gl_path_rendering_fill_mode
(
fHWPathStencilSettings
.
frontAndBack
(
)
.
fPassOp
)
;
GrGLint
writeMask
=
fHWPathStencilSettings
.
frontAndBack
(
)
.
fWriteMask
;
if
(
glPath
-
>
shouldFill
(
)
)
{
GL_CALL
(
StencilFillPath
(
glPath
-
>
pathID
(
)
fillMode
writeMask
)
)
;
}
if
(
glPath
-
>
shouldStroke
(
)
)
{
GL_CALL
(
StencilStrokePath
(
glPath
-
>
pathID
(
)
0xffff
writeMask
)
)
;
}
}
void
GrGLPathRendering
:
:
onDrawPath
(
GrRenderTarget
*
renderTarget
const
GrProgramInfo
&
programInfo
const
GrStencilSettings
&
stencilPassSettings
const
GrPath
*
path
)
{
if
(
!
this
-
>
gpu
(
)
-
>
flushGLState
(
renderTarget
programInfo
GrPrimitiveType
:
:
kPath
)
)
{
return
;
}
const
GrGLPath
*
glPath
=
static_cast
<
const
GrGLPath
*
>
(
path
)
;
this
-
>
flushPathStencilSettings
(
stencilPassSettings
)
;
GrGLenum
fillMode
=
gr_stencil_op_to_gl_path_rendering_fill_mode
(
fHWPathStencilSettings
.
frontAndBack
(
)
.
fPassOp
)
;
GrGLint
writeMask
=
fHWPathStencilSettings
.
frontAndBack
(
)
.
fWriteMask
;
if
(
glPath
-
>
shouldStroke
(
)
)
{
if
(
glPath
-
>
shouldFill
(
)
)
{
GL_CALL
(
StencilFillPath
(
glPath
-
>
pathID
(
)
fillMode
writeMask
)
)
;
}
GL_CALL
(
StencilThenCoverStrokePath
(
glPath
-
>
pathID
(
)
0xffff
writeMask
GR_GL_BOUNDING_BOX
)
)
;
}
else
{
GL_CALL
(
StencilThenCoverFillPath
(
glPath
-
>
pathID
(
)
fillMode
writeMask
GR_GL_BOUNDING_BOX
)
)
;
}
}
void
GrGLPathRendering
:
:
setProgramPathFragmentInputTransform
(
GrGLuint
program
GrGLint
location
GrGLenum
genMode
GrGLint
components
const
SkMatrix
&
matrix
)
{
float
coefficients
[
3
*
3
]
;
SkASSERT
(
components
>
=
1
&
&
components
<
=
3
)
;
coefficients
[
0
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMScaleX
]
)
;
coefficients
[
1
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMSkewX
]
)
;
coefficients
[
2
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMTransX
]
)
;
if
(
components
>
=
2
)
{
coefficients
[
3
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMSkewY
]
)
;
coefficients
[
4
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMScaleY
]
)
;
coefficients
[
5
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMTransY
]
)
;
}
if
(
components
>
=
3
)
{
coefficients
[
6
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMPersp0
]
)
;
coefficients
[
7
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMPersp1
]
)
;
coefficients
[
8
]
=
SkScalarToFloat
(
matrix
[
SkMatrix
:
:
kMPersp2
]
)
;
}
SkDEBUGCODE
(
verify_floats
(
coefficients
components
*
3
)
)
;
GL_CALL
(
ProgramPathFragmentInputGen
(
program
location
genMode
components
coefficients
)
)
;
}
void
GrGLPathRendering
:
:
setProjectionMatrix
(
const
SkMatrix
&
matrix
const
SkISize
&
renderTargetSize
GrSurfaceOrigin
renderTargetOrigin
)
{
SkASSERT
(
this
-
>
gpu
(
)
-
>
glCaps
(
)
.
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
)
;
if
(
renderTargetOrigin
=
=
fHWProjectionMatrixState
.
fRenderTargetOrigin
&
&
renderTargetSize
=
=
fHWProjectionMatrixState
.
fRenderTargetSize
&
&
matrix
.
cheapEqualTo
(
fHWProjectionMatrixState
.
fViewMatrix
)
)
{
return
;
}
fHWProjectionMatrixState
.
fViewMatrix
=
matrix
;
fHWProjectionMatrixState
.
fRenderTargetSize
=
renderTargetSize
;
fHWProjectionMatrixState
.
fRenderTargetOrigin
=
renderTargetOrigin
;
float
glMatrix
[
4
*
4
]
;
fHWProjectionMatrixState
.
getRTAdjustedGLMatrix
<
4
>
(
glMatrix
)
;
SkDEBUGCODE
(
verify_floats
(
glMatrix
SK_ARRAY_COUNT
(
glMatrix
)
)
)
;
GL_CALL
(
MatrixLoadf
(
GR_GL_PATH_PROJECTION
glMatrix
)
)
;
}
GrGLuint
GrGLPathRendering
:
:
genPaths
(
GrGLsizei
range
)
{
SkASSERT
(
range
>
0
)
;
GrGLuint
firstID
;
if
(
fPreallocatedPathCount
>
=
range
)
{
firstID
=
fFirstPreallocatedPathID
;
fPreallocatedPathCount
-
=
range
;
fFirstPreallocatedPathID
+
=
range
;
return
firstID
;
}
GrGLsizei
allocAmount
=
range
+
(
kPathIDPreallocationAmount
-
fPreallocatedPathCount
)
;
if
(
allocAmount
>
=
range
)
{
GL_CALL_RET
(
firstID
GenPaths
(
allocAmount
)
)
;
if
(
firstID
!
=
0
)
{
if
(
fPreallocatedPathCount
>
0
&
&
firstID
=
=
fFirstPreallocatedPathID
+
fPreallocatedPathCount
)
{
firstID
=
fFirstPreallocatedPathID
;
fPreallocatedPathCount
+
=
allocAmount
-
range
;
fFirstPreallocatedPathID
+
=
range
;
return
firstID
;
}
if
(
allocAmount
>
range
)
{
if
(
fPreallocatedPathCount
>
0
)
{
this
-
>
deletePaths
(
fFirstPreallocatedPathID
fPreallocatedPathCount
)
;
}
fFirstPreallocatedPathID
=
firstID
+
range
;
fPreallocatedPathCount
=
allocAmount
-
range
;
}
return
firstID
;
}
}
if
(
fPreallocatedPathCount
>
0
)
{
this
-
>
deletePaths
(
fFirstPreallocatedPathID
fPreallocatedPathCount
)
;
fPreallocatedPathCount
=
0
;
}
GL_CALL_RET
(
firstID
GenPaths
(
range
)
)
;
if
(
firstID
=
=
0
)
{
SkDebugf
(
"
Warning
:
Failed
to
allocate
path
\
n
"
)
;
}
return
firstID
;
}
void
GrGLPathRendering
:
:
deletePaths
(
GrGLuint
path
GrGLsizei
range
)
{
GL_CALL
(
DeletePaths
(
path
range
)
)
;
}
void
GrGLPathRendering
:
:
flushPathStencilSettings
(
const
GrStencilSettings
&
stencilSettings
)
{
SkASSERT
(
!
stencilSettings
.
isTwoSided
(
)
)
;
if
(
fHWPathStencilSettings
!
=
stencilSettings
)
{
SkASSERT
(
stencilSettings
.
isValid
(
)
)
;
uint16_t
ref
=
stencilSettings
.
frontAndBack
(
)
.
fRef
;
GrStencilTest
test
=
stencilSettings
.
frontAndBack
(
)
.
fTest
;
uint16_t
testMask
=
stencilSettings
.
frontAndBack
(
)
.
fTestMask
;
if
(
!
fHWPathStencilSettings
.
isValid
(
)
|
|
ref
!
=
fHWPathStencilSettings
.
frontAndBack
(
)
.
fRef
|
|
test
!
=
fHWPathStencilSettings
.
frontAndBack
(
)
.
fTest
|
|
testMask
!
=
fHWPathStencilSettings
.
frontAndBack
(
)
.
fTestMask
)
{
GL_CALL
(
PathStencilFunc
(
GrToGLStencilFunc
(
test
)
ref
testMask
)
)
;
}
fHWPathStencilSettings
=
stencilSettings
;
}
}
inline
GrGLGpu
*
GrGLPathRendering
:
:
gpu
(
)
{
return
static_cast
<
GrGLGpu
*
>
(
fGpu
)
;
}
