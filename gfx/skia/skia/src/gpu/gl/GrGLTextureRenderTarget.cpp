#
include
"
GrGLTextureRenderTarget
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrGLGpu
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
SkTraceMemoryDump
.
h
"
GrGLTextureRenderTarget
:
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
SkBudgeted
budgeted
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
GrMipMapsStatus
mipMapsStatus
)
:
GrSurface
(
gpu
desc
)
GrGLTexture
(
gpu
desc
texIDDesc
mipMapsStatus
)
GrGLRenderTarget
(
gpu
desc
rtIDDesc
)
{
this
-
>
registerWithCache
(
budgeted
)
;
}
GrGLTextureRenderTarget
:
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
GrMipMapsStatus
mipMapsStatus
)
:
GrSurface
(
gpu
desc
)
GrGLTexture
(
gpu
desc
texIDDesc
mipMapsStatus
)
GrGLRenderTarget
(
gpu
desc
rtIDDesc
)
{
this
-
>
registerWithCacheWrapped
(
)
;
}
void
GrGLTextureRenderTarget
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
GrGLRenderTarget
:
:
dumpMemoryStatistics
(
traceMemoryDump
)
;
SkString
dumpName
(
"
skia
/
gpu_resources
/
resource_
"
)
;
dumpName
.
appendU32
(
this
-
>
uniqueID
(
)
.
asUInt
(
)
)
;
dumpName
.
append
(
"
/
texture
"
)
;
size_t
size
=
GrGLTexture
:
:
gpuMemorySize
(
)
;
traceMemoryDump
-
>
dumpNumericValue
(
dumpName
.
c_str
(
)
"
size
"
"
bytes
"
size
)
;
if
(
this
-
>
isPurgeable
(
)
)
{
traceMemoryDump
-
>
dumpNumericValue
(
dumpName
.
c_str
(
)
"
purgeable_size
"
"
bytes
"
size
)
;
}
SkString
texture_id
;
texture_id
.
appendU32
(
this
-
>
textureID
(
)
)
;
traceMemoryDump
-
>
setMemoryBacking
(
dumpName
.
c_str
(
)
"
gl_texture
"
texture_id
.
c_str
(
)
)
;
}
bool
GrGLTextureRenderTarget
:
:
canAttemptStencilAttachment
(
)
const
{
return
!
this
-
>
getGpu
(
)
-
>
getContext
(
)
-
>
caps
(
)
-
>
avoidStencilBuffers
(
)
;
}
sk_sp
<
GrGLTextureRenderTarget
>
GrGLTextureRenderTarget
:
:
MakeWrapped
(
GrGLGpu
*
gpu
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
GrMipMapsStatus
mipMapsStatus
)
{
return
sk_sp
<
GrGLTextureRenderTarget
>
(
new
GrGLTextureRenderTarget
(
gpu
desc
texIDDesc
rtIDDesc
mipMapsStatus
)
)
;
}
size_t
GrGLTextureRenderTarget
:
:
onGpuMemorySize
(
)
const
{
return
GrSurface
:
:
ComputeSize
(
this
-
>
config
(
)
this
-
>
width
(
)
this
-
>
height
(
)
this
-
>
numSamplesOwnedPerPixel
(
)
this
-
>
texturePriv
(
)
.
mipMapped
(
)
)
;
}
