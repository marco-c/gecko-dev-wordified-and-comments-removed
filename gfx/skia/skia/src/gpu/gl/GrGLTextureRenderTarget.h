#
ifndef
GrGLTextureRenderTarget_DEFINED
#
define
GrGLTextureRenderTarget_DEFINED
#
include
"
GrGLGpu
.
h
"
#
include
"
GrGLTexture
.
h
"
#
include
"
GrGLRenderTarget
.
h
"
#
include
"
GrTexturePriv
.
h
"
class
GrGLGpu
;
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4250
)
#
endif
class
GrGLTextureRenderTarget
:
public
GrGLTexture
public
GrGLRenderTarget
{
public
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
SkBudgeted
budgeted
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
bool
wasMipMapDataProvided
)
:
GrSurface
(
gpu
desc
)
GrGLTexture
(
gpu
desc
texIDDesc
wasMipMapDataProvided
)
GrGLRenderTarget
(
gpu
desc
rtIDDesc
)
{
this
-
>
registerWithCache
(
budgeted
)
;
}
bool
canAttemptStencilAttachment
(
)
const
override
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
override
;
static
sk_sp
<
GrGLTextureRenderTarget
>
MakeWrapped
(
GrGLGpu
*
gpu
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
)
;
protected
:
void
onAbandon
(
)
override
{
GrGLRenderTarget
:
:
onAbandon
(
)
;
GrGLTexture
:
:
onAbandon
(
)
;
}
void
onRelease
(
)
override
{
GrGLRenderTarget
:
:
onRelease
(
)
;
GrGLTexture
:
:
onRelease
(
)
;
}
private
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
const
GrSurfaceDesc
&
desc
const
GrGLTexture
:
:
IDDesc
&
texIDDesc
const
GrGLRenderTarget
:
:
IDDesc
&
rtIDDesc
bool
wasMipMapDataProvided
)
:
GrSurface
(
gpu
desc
)
GrGLTexture
(
gpu
desc
texIDDesc
wasMipMapDataProvided
)
GrGLRenderTarget
(
gpu
desc
rtIDDesc
)
{
this
-
>
registerWithCacheWrapped
(
)
;
}
size_t
onGpuMemorySize
(
)
const
override
{
return
GrSurface
:
:
ComputeSize
(
fDesc
this
-
>
numSamplesOwnedPerPixel
(
)
this
-
>
texturePriv
(
)
.
hasMipMaps
(
)
)
;
}
}
;
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
pop
)
#
endif
#
endif
