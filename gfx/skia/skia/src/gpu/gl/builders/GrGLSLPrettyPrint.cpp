#
include
"
gl
/
GrGLSLPrettyPrint
.
h
"
namespace
GrGLSLPrettyPrint
{
class
GLSLPrettyPrint
{
public
:
GLSLPrettyPrint
(
)
{
}
SkString
prettify
(
const
char
*
*
strings
int
*
lengths
int
count
bool
countlines
)
{
fCountlines
=
countlines
;
fTabs
=
0
;
fLinecount
=
1
;
fFreshline
=
true
;
fInParseUntilNewline
=
false
;
fInParseUntil
=
false
;
int
parensDepth
=
0
;
this
-
>
lineNumbering
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
fIndex
=
0
;
fLength
=
lengths
[
i
]
;
fInput
=
strings
[
i
]
;
while
(
fLength
>
fIndex
)
{
if
(
fInParseUntilNewline
)
{
this
-
>
parseUntilNewline
(
)
;
}
else
if
(
fInParseUntil
)
{
this
-
>
parseUntil
(
fInParseUntilToken
)
;
}
else
if
(
this
-
>
hasToken
(
"
#
"
)
|
|
this
-
>
hasToken
(
"
/
/
"
)
)
{
this
-
>
parseUntilNewline
(
)
;
}
else
if
(
this
-
>
hasToken
(
"
/
*
"
)
)
{
this
-
>
parseUntil
(
"
*
/
"
)
;
}
else
if
(
'
{
'
=
=
fInput
[
fIndex
]
)
{
this
-
>
newline
(
)
;
this
-
>
appendChar
(
'
{
'
)
;
fTabs
+
+
;
this
-
>
newline
(
)
;
}
else
if
(
'
}
'
=
=
fInput
[
fIndex
]
)
{
fTabs
-
-
;
this
-
>
newline
(
)
;
this
-
>
appendChar
(
'
}
'
)
;
this
-
>
newline
(
)
;
}
else
if
(
this
-
>
hasToken
(
"
)
"
)
)
{
parensDepth
-
-
;
}
else
if
(
this
-
>
hasToken
(
"
(
"
)
)
{
parensDepth
+
+
;
}
else
if
(
!
parensDepth
&
&
this
-
>
hasToken
(
"
;
"
)
)
{
this
-
>
newline
(
)
;
}
else
if
(
'
\
t
'
=
=
fInput
[
fIndex
]
|
|
'
\
n
'
=
=
fInput
[
fIndex
]
|
|
(
fFreshline
&
&
'
'
=
=
fInput
[
fIndex
]
)
)
{
fIndex
+
+
;
}
else
{
this
-
>
appendChar
(
fInput
[
fIndex
]
)
;
}
}
}
return
fPretty
;
}
private
:
void
appendChar
(
char
c
)
{
this
-
>
tabString
(
)
;
fPretty
.
appendf
(
"
%
c
"
fInput
[
fIndex
+
+
]
)
;
fFreshline
=
false
;
}
bool
hasToken
(
const
char
*
token
)
{
size_t
i
=
fIndex
;
for
(
size_t
j
=
0
;
token
[
j
]
&
&
fLength
>
i
;
i
+
+
j
+
+
)
{
if
(
token
[
j
]
!
=
fInput
[
i
]
)
{
return
false
;
}
}
this
-
>
tabString
(
)
;
fIndex
=
i
;
fPretty
.
append
(
token
)
;
fFreshline
=
false
;
return
true
;
}
void
parseUntilNewline
(
)
{
while
(
fLength
>
fIndex
)
{
if
(
'
\
n
'
=
=
fInput
[
fIndex
]
)
{
fIndex
+
+
;
this
-
>
newline
(
)
;
fInParseUntilNewline
=
false
;
break
;
}
fPretty
.
appendf
(
"
%
c
"
fInput
[
fIndex
+
+
]
)
;
fInParseUntilNewline
=
true
;
}
}
void
parseUntil
(
const
char
*
token
)
{
while
(
fLength
>
fIndex
)
{
if
(
'
\
n
'
=
=
fInput
[
fIndex
]
)
{
this
-
>
newline
(
)
;
this
-
>
tabString
(
)
;
fIndex
+
+
;
}
if
(
this
-
>
hasToken
(
token
)
)
{
fInParseUntil
=
false
;
break
;
}
fFreshline
=
false
;
fPretty
.
appendf
(
"
%
c
"
fInput
[
fIndex
+
+
]
)
;
fInParseUntil
=
true
;
fInParseUntilToken
=
token
;
}
}
void
tabString
(
)
{
if
(
fFreshline
)
{
for
(
int
t
=
0
;
t
<
fTabs
;
t
+
+
)
{
fPretty
.
append
(
"
\
t
"
)
;
}
}
}
void
newline
(
)
{
if
(
!
fFreshline
)
{
fFreshline
=
true
;
fPretty
.
append
(
"
\
n
"
)
;
this
-
>
lineNumbering
(
)
;
}
}
void
lineNumbering
(
)
{
if
(
fCountlines
)
{
fPretty
.
appendf
(
"
%
4d
\
t
"
fLinecount
+
+
)
;
}
}
bool
fCountlines
fFreshline
;
int
fTabs
fLinecount
;
size_t
fIndex
fLength
;
const
char
*
fInput
;
SkString
fPretty
;
bool
fInParseUntilNewline
;
bool
fInParseUntil
;
const
char
*
fInParseUntilToken
;
}
;
SkString
PrettyPrintGLSL
(
const
char
*
*
strings
int
*
lengths
int
count
bool
countlines
)
{
GLSLPrettyPrint
pp
;
return
pp
.
prettify
(
strings
lengths
count
countlines
)
;
}
}
