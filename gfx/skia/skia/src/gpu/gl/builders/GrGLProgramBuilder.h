#
ifndef
GrGLProgramBuilder_DEFINED
#
define
GrGLProgramBuilder_DEFINED
#
include
"
GrPipeline
.
h
"
#
include
"
gl
/
GrGLProgramDataManager
.
h
"
#
include
"
gl
/
GrGLVaryingHandler
.
h
"
#
include
"
glsl
/
GrGLSLPrimitiveProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLTextureSampler
.
h
"
#
include
"
glsl
/
GrGLSLXferProcessor
.
h
"
class
GrFragmentProcessor
;
class
GrGLContextInfo
;
class
GrGLSLShaderBuilder
;
class
GrGLSLCaps
;
template
<
class
Proc
>
struct
GrGLInstalledProc
{
SkDEBUGCODE
(
int
fSamplersIdx
;
)
SkAutoTDelete
<
Proc
>
fGLProc
;
}
;
typedef
GrGLInstalledProc
<
GrGLSLPrimitiveProcessor
>
GrGLInstalledGeoProc
;
typedef
GrGLInstalledProc
<
GrGLSLXferProcessor
>
GrGLInstalledXferProc
;
typedef
GrGLInstalledProc
<
GrGLSLFragmentProcessor
>
GrGLInstalledFragProc
;
struct
GrGLInstalledFragProcs
:
public
SkRefCnt
{
virtual
~
GrGLInstalledFragProcs
(
)
;
SkSTArray
<
8
GrGLInstalledFragProc
*
true
>
fProcs
;
}
;
class
GrGLProgramBuilder
:
public
GrGLSLProgramBuilder
{
public
:
static
GrGLProgram
*
CreateProgram
(
const
DrawArgs
&
GrGLGpu
*
)
;
const
GrGLSLShaderVar
&
getUniformVariable
(
UniformHandle
u
)
const
override
{
return
fUniforms
[
u
.
toIndex
(
)
]
.
fVariable
;
}
const
char
*
getUniformCStr
(
UniformHandle
u
)
const
override
{
return
this
-
>
getUniformVariable
(
u
)
.
c_str
(
)
;
}
const
GrGLSLCaps
*
glslCaps
(
)
const
override
;
GrGLGpu
*
gpu
(
)
const
{
return
fGpu
;
}
private
:
typedef
GrGLProgramDataManager
:
:
UniformInfo
UniformInfo
;
typedef
GrGLProgramDataManager
:
:
UniformInfoArray
UniformInfoArray
;
GrGLProgramBuilder
(
GrGLGpu
*
const
DrawArgs
&
)
;
UniformHandle
internalAddUniformArray
(
uint32_t
visibility
GrSLType
type
GrSLPrecision
precision
const
char
*
name
bool
mangleName
int
arrayCount
const
char
*
*
outName
)
override
;
void
nameExpression
(
GrGLSLExpr4
*
const
char
*
baseName
)
;
bool
emitAndInstallProcs
(
GrGLSLExpr4
*
inputColor
GrGLSLExpr4
*
inputCoverage
)
;
void
emitAndInstallFragProcs
(
int
procOffset
int
numProcs
GrGLSLExpr4
*
inOut
)
;
void
emitAndInstallProc
(
const
GrFragmentProcessor
&
int
index
const
GrGLSLExpr4
&
input
GrGLSLExpr4
*
output
)
;
void
emitAndInstallProc
(
const
GrPrimitiveProcessor
&
GrGLSLExpr4
*
outputColor
GrGLSLExpr4
*
outputCoverage
)
;
void
emitAndInstallProc
(
const
GrFragmentProcessor
&
int
index
const
char
*
outColor
const
char
*
inColor
)
;
void
emitAndInstallProc
(
const
GrPrimitiveProcessor
&
const
char
*
outColor
const
char
*
outCoverage
)
;
void
emitAndInstallXferProc
(
const
GrXferProcessor
&
const
GrGLSLExpr4
&
colorIn
const
GrGLSLExpr4
&
coverageIn
bool
ignoresCoverage
)
;
void
verify
(
const
GrPrimitiveProcessor
&
)
;
void
verify
(
const
GrXferProcessor
&
)
;
void
verify
(
const
GrFragmentProcessor
&
)
;
template
<
class
Proc
>
void
emitSamplers
(
const
GrProcessor
&
GrGLSLTextureSampler
:
:
TextureSamplerArray
*
outSamplers
GrGLInstalledProc
<
Proc
>
*
)
;
bool
compileAndAttachShaders
(
GrGLSLShaderBuilder
&
shader
GrGLuint
programId
GrGLenum
type
SkTDArray
<
GrGLuint
>
*
shaderIds
)
;
GrGLProgram
*
finalize
(
)
;
void
bindProgramResourceLocations
(
GrGLuint
programID
)
;
bool
checkLinkStatus
(
GrGLuint
programID
)
;
void
resolveProgramResourceLocations
(
GrGLuint
programID
)
;
void
cleanupProgram
(
GrGLuint
programID
const
SkTDArray
<
GrGLuint
>
&
shaderIDs
)
;
void
cleanupShaders
(
const
SkTDArray
<
GrGLuint
>
&
shaderIDs
)
;
GrGLProgram
*
createProgram
(
GrGLuint
programID
)
;
void
onAppendUniformDecls
(
ShaderVisibility
visibility
SkString
*
out
)
const
override
;
GrGLSLVaryingHandler
*
varyingHandler
(
)
override
{
return
&
fVaryingHandler
;
}
void
reset
(
)
{
this
-
>
addStage
(
)
;
fFS
.
reset
(
)
;
}
void
addStage
(
)
{
fStageIndex
+
+
;
}
class
AutoStageAdvance
{
public
:
AutoStageAdvance
(
GrGLProgramBuilder
*
pb
)
:
fPB
(
pb
)
{
fPB
-
>
reset
(
)
;
fPB
-
>
fFS
.
nextStage
(
)
;
}
~
AutoStageAdvance
(
)
{
}
private
:
GrGLProgramBuilder
*
fPB
;
}
;
GrGLInstalledGeoProc
*
fGeometryProcessor
;
GrGLInstalledXferProc
*
fXferProcessor
;
SkAutoTUnref
<
GrGLInstalledFragProcs
>
fFragmentProcessors
;
GrGLGpu
*
fGpu
;
UniformInfoArray
fUniforms
;
GrGLSLPrimitiveProcessor
:
:
TransformsIn
fCoordTransforms
;
GrGLSLPrimitiveProcessor
:
:
TransformsOut
fOutCoords
;
SkTArray
<
UniformHandle
>
fSamplerUniforms
;
GrGLVaryingHandler
fVaryingHandler
;
friend
class
GrGLVaryingHandler
;
typedef
GrGLSLProgramBuilder
INHERITED
;
}
;
#
endif
