#
ifndef
GrGLPathRendering_DEFINED
#
define
GrGLPathRendering_DEFINED
#
include
"
SkRefCnt
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrStencilSettings
.
h
"
#
include
"
gl
/
GrGLTypes
.
h
"
#
include
"
glsl
/
GrGLSLUtil
.
h
"
class
GrGLNameAllocator
;
class
GrGLGpu
;
class
GrStyle
;
class
GrGLPathRendering
:
public
GrPathRendering
{
public
:
GrGLPathRendering
(
GrGLGpu
*
gpu
)
;
~
GrGLPathRendering
(
)
override
;
sk_sp
<
GrPath
>
createPath
(
const
SkPath
&
const
GrStyle
&
)
override
;
void
resetContext
(
)
;
void
disconnect
(
GrGpu
:
:
DisconnectType
)
;
bool
shouldBindFragmentInputs
(
)
const
{
return
fCaps
.
bindFragmentInputSupport
;
}
void
setProgramPathFragmentInputTransform
(
GrGLuint
program
GrGLint
location
GrGLenum
genMode
GrGLint
components
const
SkMatrix
&
)
;
void
setProjectionMatrix
(
const
SkMatrix
&
matrix
const
SkISize
&
renderTargetSize
GrSurfaceOrigin
renderTargetOrigin
)
;
GrGLuint
genPaths
(
GrGLsizei
range
)
;
GrGLvoid
deletePaths
(
GrGLuint
path
GrGLsizei
range
)
;
protected
:
void
onStencilPath
(
const
StencilPathArgs
&
const
GrPath
*
)
override
;
void
onDrawPath
(
GrRenderTarget
*
GrSurfaceOrigin
const
GrPrimitiveProcessor
&
const
GrPipeline
&
const
GrPipeline
:
:
FixedDynamicState
&
const
GrStencilSettings
&
const
GrPath
*
)
override
;
private
:
struct
Caps
{
bool
bindFragmentInputSupport
:
1
;
}
;
void
flushPathStencilSettings
(
const
GrStencilSettings
&
)
;
struct
MatrixState
{
SkMatrix
fViewMatrix
;
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
MatrixState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fViewMatrix
=
SkMatrix
:
:
InvalidMatrix
(
)
;
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
template
<
int
Size
>
void
getRTAdjustedGLMatrix
(
float
*
destMatrix
)
{
SkMatrix
combined
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
combined
.
setAll
(
SkIntToScalar
(
2
)
/
fRenderTargetSize
.
fWidth
0
-
SK_Scalar1
0
-
SkIntToScalar
(
2
)
/
fRenderTargetSize
.
fHeight
SK_Scalar1
0
0
1
)
;
}
else
{
combined
.
setAll
(
SkIntToScalar
(
2
)
/
fRenderTargetSize
.
fWidth
0
-
SK_Scalar1
0
SkIntToScalar
(
2
)
/
fRenderTargetSize
.
fHeight
-
SK_Scalar1
0
0
1
)
;
}
combined
.
preConcat
(
fViewMatrix
)
;
GrGLSLGetMatrix
<
Size
>
(
destMatrix
combined
)
;
}
}
;
GrGLGpu
*
gpu
(
)
;
GrGLuint
fFirstPreallocatedPathID
;
GrGLsizei
fPreallocatedPathCount
;
MatrixState
fHWProjectionMatrixState
;
GrStencilSettings
fHWPathStencilSettings
;
Caps
fCaps
;
}
;
#
endif
