#
include
"
GrGLPathRange
.
h
"
#
include
"
GrGLPath
.
h
"
#
include
"
GrGLPathRendering
.
h
"
#
include
"
GrGLGpu
.
h
"
GrGLPathRange
:
:
GrGLPathRange
(
GrGLGpu
*
gpu
PathGenerator
*
pathGenerator
const
GrStyle
&
style
)
:
INHERITED
(
gpu
pathGenerator
)
fStyle
(
style
)
fBasePathID
(
gpu
-
>
glPathRendering
(
)
-
>
genPaths
(
this
-
>
getNumPaths
(
)
)
)
fGpuMemorySize
(
0
)
{
this
-
>
init
(
)
;
this
-
>
registerWithCache
(
SkBudgeted
:
:
kYes
)
;
}
GrGLPathRange
:
:
GrGLPathRange
(
GrGLGpu
*
gpu
GrGLuint
basePathID
int
numPaths
size_t
gpuMemorySize
const
GrStyle
&
style
)
:
INHERITED
(
gpu
numPaths
)
fStyle
(
style
)
fBasePathID
(
basePathID
)
fGpuMemorySize
(
gpuMemorySize
)
{
this
-
>
init
(
)
;
this
-
>
registerWithCache
(
SkBudgeted
:
:
kYes
)
;
}
void
GrGLPathRange
:
:
init
(
)
{
const
SkStrokeRec
&
stroke
=
fStyle
.
strokeRec
(
)
;
bool
forceFill
=
fStyle
.
pathEffect
(
)
|
|
(
stroke
.
needToApply
(
)
&
&
stroke
.
getCap
(
)
!
=
SkPaint
:
:
kButt_Cap
)
;
if
(
forceFill
)
{
fShouldStroke
=
false
;
fShouldFill
=
true
;
}
else
{
fShouldStroke
=
stroke
.
needToApply
(
)
;
fShouldFill
=
stroke
.
isFillStyle
(
)
|
|
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
;
}
}
void
GrGLPathRange
:
:
onInitPath
(
int
index
const
SkPath
&
origSkPath
)
const
{
GrGLGpu
*
gpu
=
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
;
if
(
nullptr
=
=
gpu
)
{
return
;
}
SkDEBUGCODE
(
GrGLboolean
isPath
;
GR_GL_CALL_RET
(
gpu
-
>
glInterface
(
)
isPath
IsPath
(
fBasePathID
+
index
)
)
)
;
SkASSERT
(
GR_GL_FALSE
=
=
isPath
)
;
if
(
origSkPath
.
isEmpty
(
)
)
{
GrGLPath
:
:
InitPathObjectEmptyPath
(
gpu
fBasePathID
+
index
)
;
}
else
if
(
fShouldStroke
)
{
GrGLPath
:
:
InitPathObjectPathData
(
gpu
fBasePathID
+
index
origSkPath
)
;
GrGLPath
:
:
InitPathObjectStroke
(
gpu
fBasePathID
+
index
fStyle
.
strokeRec
(
)
)
;
}
else
{
const
SkPath
*
skPath
=
&
origSkPath
;
SkTLazy
<
SkPath
>
tmpPath
;
if
(
!
fStyle
.
isSimpleFill
(
)
)
{
SkStrokeRec
:
:
InitStyle
fill
;
if
(
!
fStyle
.
applyToPath
(
tmpPath
.
init
(
)
&
fill
*
skPath
SK_Scalar1
)
)
{
return
;
}
SkASSERT
(
SkStrokeRec
:
:
kFill_InitStyle
=
=
fill
)
;
skPath
=
tmpPath
.
get
(
)
;
}
GrGLPath
:
:
InitPathObjectPathData
(
gpu
fBasePathID
+
index
*
skPath
)
;
}
fGpuMemorySize
+
=
100
;
}
void
GrGLPathRange
:
:
onRelease
(
)
{
SkASSERT
(
this
-
>
getGpu
(
)
)
;
if
(
0
!
=
fBasePathID
)
{
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
-
>
glPathRendering
(
)
-
>
deletePaths
(
fBasePathID
this
-
>
getNumPaths
(
)
)
;
fBasePathID
=
0
;
}
INHERITED
:
:
onRelease
(
)
;
}
void
GrGLPathRange
:
:
onAbandon
(
)
{
fBasePathID
=
0
;
INHERITED
:
:
onAbandon
(
)
;
}
