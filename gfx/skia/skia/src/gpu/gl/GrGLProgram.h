#
ifndef
GrGLProgram_DEFINED
#
define
GrGLProgram_DEFINED
#
include
"
src
/
gpu
/
gl
/
GrGLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrGLSLFragmentProcessor
;
class
GrGLSLPrimitiveProcessor
;
class
GrGLSLXferProcessor
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrProgramInfo
;
class
GrRenderTarget
;
class
GrTextureProxy
;
class
GrGLProgram
:
public
SkRefCnt
{
public
:
struct
Attribute
{
GrVertexAttribType
fCPUType
;
GrSLType
fGPUType
;
size_t
fOffset
;
GrGLint
fLocation
;
}
;
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
UniformInfoArray
=
GrGLProgramDataManager
:
:
UniformInfoArray
;
using
VaryingInfoArray
=
GrGLProgramDataManager
:
:
VaryingInfoArray
;
GrGLProgram
(
GrGLGpu
*
const
GrGLSLBuiltinUniformHandles
&
GrGLuint
programID
const
UniformInfoArray
&
uniforms
const
UniformInfoArray
&
textureSamplers
const
VaryingInfoArray
&
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
geometryProcessor
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
xferProcessor
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fragmentProcessors
int
fragmentProcessorCnt
std
:
:
unique_ptr
<
Attribute
[
]
>
int
vertexAttributeCnt
int
instanceAttributeCnt
int
vertexStride
int
instanceStride
)
;
~
GrGLProgram
(
)
;
void
abandon
(
)
;
GrGLuint
programID
(
)
const
{
return
fProgramID
;
}
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
void
getRTAdjustmentVec
(
float
*
destVec
)
{
destVec
[
0
]
=
2
.
f
/
fRenderTargetSize
.
fWidth
;
destVec
[
1
]
=
-
1
.
f
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
destVec
[
2
]
=
-
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
1
.
f
;
}
else
{
destVec
[
2
]
=
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
-
1
.
f
;
}
}
}
;
void
updateUniformsAndTextureBindings
(
const
GrRenderTarget
*
const
GrProgramInfo
&
)
;
void
updatePrimitiveProcessorTextureBindings
(
const
GrPrimitiveProcessor
&
const
GrTextureProxy
*
const
[
]
)
;
int
vertexStride
(
)
const
{
return
fVertexStride
;
}
int
instanceStride
(
)
const
{
return
fInstanceStride
;
}
int
numVertexAttributes
(
)
const
{
return
fVertexAttributeCnt
;
}
const
Attribute
&
vertexAttribute
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fVertexAttributeCnt
)
;
return
fAttributes
[
i
]
;
}
int
numInstanceAttributes
(
)
const
{
return
fInstanceAttributeCnt
;
}
const
Attribute
&
instanceAttribute
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fInstanceAttributeCnt
)
;
return
fAttributes
[
i
+
fVertexAttributeCnt
]
;
}
private
:
void
setFragmentData
(
const
GrPipeline
&
int
*
nextTexSamplerIdx
)
;
void
setRenderTargetState
(
const
GrRenderTarget
*
GrSurfaceOrigin
const
GrPrimitiveProcessor
&
)
;
RenderTargetState
fRenderTargetState
;
GrGLSLBuiltinUniformHandles
fBuiltinUniformHandles
;
GrGLuint
fProgramID
;
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
fPrimitiveProcessor
;
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
fXferProcessor
;
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fFragmentProcessors
;
int
fFragmentProcessorCnt
;
std
:
:
unique_ptr
<
Attribute
[
]
>
fAttributes
;
int
fVertexAttributeCnt
;
int
fInstanceAttributeCnt
;
int
fVertexStride
;
int
fInstanceStride
;
GrGLGpu
*
fGpu
;
GrGLProgramDataManager
fProgramDataManager
;
int
fNumTextureSamplers
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
