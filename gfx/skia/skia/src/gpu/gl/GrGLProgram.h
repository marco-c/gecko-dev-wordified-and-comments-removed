#
ifndef
GrGLProgram_DEFINED
#
define
GrGLProgram_DEFINED
#
include
"
GrGLContext
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrGLTexture
.
h
"
#
include
"
GrGLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
SkString
.
h
"
#
include
"
builders
/
GrGLProgramBuilder
.
h
"
class
GrGLInstalledProcessors
;
class
GrGLProgramBuilder
;
class
GrPipeline
;
class
GrGLProgram
:
public
SkRefCnt
{
public
:
typedef
GrGLSLProgramBuilder
:
:
BuiltinUniformHandles
BuiltinUniformHandles
;
~
GrGLProgram
(
)
;
void
abandon
(
)
;
const
GrProgramDesc
&
getDesc
(
)
{
return
fDesc
;
}
GrGLuint
programID
(
)
const
{
return
fProgramID
;
}
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
void
getRTAdjustmentVec
(
float
*
destVec
)
{
destVec
[
0
]
=
2
.
f
/
fRenderTargetSize
.
fWidth
;
destVec
[
1
]
=
-
1
.
f
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
destVec
[
2
]
=
-
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
1
.
f
;
}
else
{
destVec
[
2
]
=
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
-
1
.
f
;
}
}
}
;
void
setData
(
const
GrPrimitiveProcessor
&
const
GrPipeline
&
)
;
void
generateMipmaps
(
const
GrPrimitiveProcessor
&
const
GrPipeline
&
)
;
protected
:
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
UniformInfoArray
=
GrGLProgramDataManager
:
:
UniformInfoArray
;
using
VaryingInfoArray
=
GrGLProgramDataManager
:
:
VaryingInfoArray
;
GrGLProgram
(
GrGLGpu
*
const
GrProgramDesc
&
const
BuiltinUniformHandles
&
GrGLuint
programID
const
UniformInfoArray
&
uniforms
const
UniformInfoArray
&
samplers
const
UniformInfoArray
&
imageStorages
const
VaryingInfoArray
&
GrGLSLPrimitiveProcessor
*
geometryProcessor
GrGLSLXferProcessor
*
xferProcessor
const
GrGLSLFragProcs
&
fragmentProcessors
)
;
void
setFragmentData
(
const
GrPrimitiveProcessor
&
const
GrPipeline
&
int
*
nextSamplerIdx
)
;
void
setRenderTargetState
(
const
GrPrimitiveProcessor
&
const
GrRenderTarget
*
)
;
void
bindTextures
(
const
GrResourceIOProcessor
&
bool
allowSRGBInputs
int
*
nextSamplerIdx
)
;
void
generateMipmaps
(
const
GrResourceIOProcessor
&
bool
allowSRGBInputs
)
;
RenderTargetState
fRenderTargetState
;
BuiltinUniformHandles
fBuiltinUniformHandles
;
GrGLuint
fProgramID
;
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
fGeometryProcessor
;
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
fXferProcessor
;
GrGLSLFragProcs
fFragmentProcessors
;
GrProgramDesc
fDesc
;
GrGLGpu
*
fGpu
;
GrGLProgramDataManager
fProgramDataManager
;
friend
class
GrGLProgramBuilder
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
