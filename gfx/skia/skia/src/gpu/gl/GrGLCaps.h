#
ifndef
GrGLCaps_DEFINED
#
define
GrGLCaps_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
glsl
/
GrGLSL
.
h
"
#
include
"
GrGLStencilAttachment
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
SkTHash
.
h
"
#
include
"
SkTArray
.
h
"
class
GrGLContextInfo
;
class
GrGLSLCaps
;
class
GrGLCaps
:
public
GrCaps
{
public
:
typedef
GrGLStencilAttachment
:
:
Format
StencilFormat
;
enum
MSFBOType
{
kNone_MSFBOType
=
0
kDesktop_ARB_MSFBOType
kDesktop_EXT_MSFBOType
kES_3_0_MSFBOType
kES_Apple_MSFBOType
kES_IMG_MsToTexture_MSFBOType
kES_EXT_MsToTexture_MSFBOType
kMixedSamples_MSFBOType
kLast_MSFBOType
=
kMixedSamples_MSFBOType
}
;
enum
InvalidateFBType
{
kNone_InvalidateFBType
kDiscard_InvalidateFBType
kInvalidate_InvalidateFBType
kLast_InvalidateFBType
=
kInvalidate_InvalidateFBType
}
;
enum
MapBufferType
{
kNone_MapBufferType
kMapBuffer_MapBufferType
kMapBufferRange_MapBufferType
kChromium_MapBufferType
kLast_MapBufferType
=
kChromium_MapBufferType
}
;
GrGLCaps
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
glInterface
)
;
void
markConfigAsValidColorAttachment
(
GrPixelConfig
config
)
{
fVerifiedColorConfigs
.
markVerified
(
config
)
;
}
bool
isConfigVerifiedColorAttachment
(
GrPixelConfig
config
)
const
{
return
fVerifiedColorConfigs
.
isVerified
(
config
)
;
}
MSFBOType
msFBOType
(
)
const
{
return
fMSFBOType
;
}
bool
usesMSAARenderBuffers
(
)
const
{
return
kNone_MSFBOType
!
=
fMSFBOType
&
&
kES_IMG_MsToTexture_MSFBOType
!
=
fMSFBOType
&
&
kES_EXT_MsToTexture_MSFBOType
!
=
fMSFBOType
&
&
kMixedSamples_MSFBOType
!
=
fMSFBOType
;
}
bool
usesImplicitMSAAResolve
(
)
const
{
return
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
|
|
kES_EXT_MsToTexture_MSFBOType
=
=
fMSFBOType
;
}
InvalidateFBType
invalidateFBType
(
)
const
{
return
fInvalidateFBType
;
}
MapBufferType
mapBufferType
(
)
const
{
return
fMapBufferType
;
}
const
SkTArray
<
StencilFormat
true
>
&
stencilFormats
(
)
const
{
return
fStencilFormats
;
}
int
maxFragmentUniformVectors
(
)
const
{
return
fMaxFragmentUniformVectors
;
}
int
maxVertexAttributes
(
)
const
{
return
fMaxVertexAttributes
;
}
int
maxFragmentTextureUnits
(
)
const
{
return
fMaxFragmentTextureUnits
;
}
bool
rgba8RenderbufferSupport
(
)
const
{
return
fRGBA8RenderbufferSupport
;
}
bool
bgraIsInternalFormat
(
)
const
{
return
fBGRAIsInternalFormat
;
}
bool
unpackRowLengthSupport
(
)
const
{
return
fUnpackRowLengthSupport
;
}
bool
unpackFlipYSupport
(
)
const
{
return
fUnpackFlipYSupport
;
}
bool
packRowLengthSupport
(
)
const
{
return
fPackRowLengthSupport
;
}
bool
packFlipYSupport
(
)
const
{
return
fPackFlipYSupport
;
}
bool
textureUsageSupport
(
)
const
{
return
fTextureUsageSupport
;
}
bool
texStorageSupport
(
)
const
{
return
fTexStorageSupport
;
}
bool
textureRedSupport
(
)
const
{
return
fTextureRedSupport
;
}
bool
imagingSupport
(
)
const
{
return
fImagingSupport
;
}
bool
vertexArrayObjectSupport
(
)
const
{
return
fVertexArrayObjectSupport
;
}
bool
instancedDrawingSupport
(
)
const
{
return
fInstancedDrawingSupport
;
}
bool
directStateAccessSupport
(
)
const
{
return
fDirectStateAccessSupport
;
}
bool
debugSupport
(
)
const
{
return
fDebugSupport
;
}
bool
ES2CompatibilitySupport
(
)
const
{
return
fES2CompatibilitySupport
;
}
bool
multisampleDisableSupport
(
)
const
{
return
fMultisampleDisableSupport
;
}
bool
useNonVBOVertexAndIndexDynamicData
(
)
const
{
return
fUseNonVBOVertexAndIndexDynamicData
;
}
bool
readPixelsSupported
(
const
GrGLInterface
*
intf
GrGLenum
format
GrGLenum
type
GrGLenum
currFboFormat
)
const
;
bool
isCoreProfile
(
)
const
{
return
fIsCoreProfile
;
}
bool
bindFragDataLocationSupport
(
)
const
{
return
fBindFragDataLocationSupport
;
}
bool
bindUniformLocationSupport
(
)
const
{
return
fBindUniformLocationSupport
;
}
bool
externalTextureSupport
(
)
const
{
return
fExternalTextureSupport
;
}
bool
srgbWriteControl
(
)
const
{
return
fSRGBWriteControl
;
}
SkString
dump
(
)
const
override
;
enum
LATCAlias
{
kLATC_LATCAlias
kRGTC_LATCAlias
k3DC_LATCAlias
}
;
LATCAlias
latcAlias
(
)
const
{
return
fLATCAlias
;
}
bool
rgba8888PixelsOpsAreSlow
(
)
const
{
return
fRGBA8888PixelsOpsAreSlow
;
}
bool
partialFBOReadIsSlow
(
)
const
{
return
fPartialFBOReadIsSlow
;
}
const
GrGLSLCaps
*
glslCaps
(
)
const
{
return
reinterpret_cast
<
GrGLSLCaps
*
>
(
fShaderCaps
.
get
(
)
)
;
}
private
:
void
init
(
const
GrContextOptions
&
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initGLSL
(
const
GrGLContextInfo
&
)
;
bool
hasPathRenderingSupport
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
onApplyOptionsOverrides
(
const
GrContextOptions
&
options
)
override
;
struct
VerifiedColorConfigs
{
VerifiedColorConfigs
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
for
(
int
i
=
0
;
i
<
kNumUints
;
+
+
i
)
{
fVerifiedColorConfigs
[
i
]
=
0
;
}
}
static
const
int
kNumUints
=
(
kGrPixelConfigCnt
+
31
)
/
32
;
uint32_t
fVerifiedColorConfigs
[
kNumUints
]
;
void
markVerified
(
GrPixelConfig
config
)
{
#
if
!
GR_GL_CHECK_FBO_STATUS_ONCE_PER_FORMAT
return
;
#
endif
int
u32Idx
=
config
/
32
;
int
bitIdx
=
config
%
32
;
fVerifiedColorConfigs
[
u32Idx
]
|
=
1
<
<
bitIdx
;
}
bool
isVerified
(
GrPixelConfig
config
)
const
{
#
if
!
GR_GL_CHECK_FBO_STATUS_ONCE_PER_FORMAT
return
false
;
#
endif
int
u32Idx
=
config
/
32
;
int
bitIdx
=
config
%
32
;
return
SkToBool
(
fVerifiedColorConfigs
[
u32Idx
]
&
(
1
<
<
bitIdx
)
)
;
}
}
;
void
initFSAASupport
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initBlendEqationSupport
(
const
GrGLContextInfo
&
)
;
void
initStencilFormats
(
const
GrGLContextInfo
&
)
;
void
initConfigRenderableTable
(
const
GrGLContextInfo
&
bool
srgbSupport
)
;
void
initConfigTexturableTable
(
const
GrGLContextInfo
&
const
GrGLInterface
*
bool
srgbSupport
)
;
bool
doReadPixelsSupported
(
const
GrGLInterface
*
intf
GrGLenum
format
GrGLenum
type
)
const
;
void
initShaderPrecisionTable
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
intf
GrGLSLCaps
*
glslCaps
)
;
void
initConfigSwizzleTable
(
const
GrGLContextInfo
&
ctxInfo
GrGLSLCaps
*
glslCaps
)
;
VerifiedColorConfigs
fVerifiedColorConfigs
;
SkTArray
<
StencilFormat
true
>
fStencilFormats
;
int
fMaxFragmentUniformVectors
;
int
fMaxVertexAttributes
;
int
fMaxFragmentTextureUnits
;
MSFBOType
fMSFBOType
;
InvalidateFBType
fInvalidateFBType
;
MapBufferType
fMapBufferType
;
LATCAlias
fLATCAlias
;
bool
fRGBA8RenderbufferSupport
:
1
;
bool
fBGRAIsInternalFormat
:
1
;
bool
fUnpackRowLengthSupport
:
1
;
bool
fUnpackFlipYSupport
:
1
;
bool
fPackRowLengthSupport
:
1
;
bool
fPackFlipYSupport
:
1
;
bool
fTextureUsageSupport
:
1
;
bool
fTexStorageSupport
:
1
;
bool
fTextureRedSupport
:
1
;
bool
fImagingSupport
:
1
;
bool
fTwoFormatLimit
:
1
;
bool
fVertexArrayObjectSupport
:
1
;
bool
fInstancedDrawingSupport
:
1
;
bool
fDirectStateAccessSupport
:
1
;
bool
fDebugSupport
:
1
;
bool
fES2CompatibilitySupport
:
1
;
bool
fMultisampleDisableSupport
:
1
;
bool
fUseNonVBOVertexAndIndexDynamicData
:
1
;
bool
fIsCoreProfile
:
1
;
bool
fBindFragDataLocationSupport
:
1
;
bool
fSRGBWriteControl
:
1
;
bool
fRGBA8888PixelsOpsAreSlow
:
1
;
bool
fPartialFBOReadIsSlow
:
1
;
bool
fBindUniformLocationSupport
:
1
;
bool
fExternalTextureSupport
:
1
;
struct
ReadPixelsSupportedFormat
{
GrGLenum
fFormat
;
GrGLenum
fType
;
GrGLenum
fFboFormat
;
bool
operator
=
=
(
const
ReadPixelsSupportedFormat
&
rhs
)
const
{
return
fFormat
=
=
rhs
.
fFormat
&
&
fType
=
=
rhs
.
fType
&
&
fFboFormat
=
=
rhs
.
fFboFormat
;
}
}
;
mutable
SkTHashMap
<
ReadPixelsSupportedFormat
bool
>
fReadPixelsSupportedCache
;
typedef
GrCaps
INHERITED
;
}
;
#
endif
