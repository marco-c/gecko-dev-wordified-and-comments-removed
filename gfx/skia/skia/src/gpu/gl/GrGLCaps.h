#
ifndef
GrGLCaps_DEFINED
#
define
GrGLCaps_DEFINED
#
include
<
functional
>
#
include
"
GrCaps
.
h
"
#
include
"
GrGLStencilAttachment
.
h
"
#
include
"
GrSwizzle
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
SkTHash
.
h
"
#
include
"
SkTArray
.
h
"
class
GrGLContextInfo
;
class
GrGLRenderTarget
;
class
GrGLCaps
:
public
GrCaps
{
public
:
typedef
GrGLStencilAttachment
:
:
Format
StencilFormat
;
enum
MSFBOType
{
kNone_MSFBOType
=
0
kStandard_MSFBOType
kES_Apple_MSFBOType
kES_IMG_MsToTexture_MSFBOType
kES_EXT_MsToTexture_MSFBOType
kMixedSamples_MSFBOType
kLast_MSFBOType
=
kMixedSamples_MSFBOType
}
;
enum
BlitFramebufferFlags
{
kNoSupport_BlitFramebufferFlag
=
1
<
<
0
kNoScalingOrMirroring_BlitFramebufferFlag
=
1
<
<
1
kResolveMustBeFull_BlitFrambufferFlag
=
1
<
<
2
kNoMSAADst_BlitFramebufferFlag
=
1
<
<
3
kNoFormatConversion_BlitFramebufferFlag
=
1
<
<
4
kNoFormatConversionForMSAASrc_BlitFramebufferFlag
=
1
<
<
5
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
=
1
<
<
6
}
;
enum
InvalidateFBType
{
kNone_InvalidateFBType
kDiscard_InvalidateFBType
kInvalidate_InvalidateFBType
kLast_InvalidateFBType
=
kInvalidate_InvalidateFBType
}
;
enum
MapBufferType
{
kNone_MapBufferType
kMapBuffer_MapBufferType
kMapBufferRange_MapBufferType
kChromium_MapBufferType
kLast_MapBufferType
=
kChromium_MapBufferType
}
;
enum
TransferBufferType
{
kNone_TransferBufferType
kPBO_TransferBufferType
kChromium_TransferBufferType
kLast_TransferBufferType
=
kChromium_TransferBufferType
}
;
GrGLCaps
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
glInterface
)
;
bool
isConfigTexturable
(
GrPixelConfig
config
)
const
override
{
return
SkToBool
(
fConfigTable
[
config
]
.
fFlags
&
ConfigInfo
:
:
kTextureable_Flag
)
;
}
int
getRenderTargetSampleCount
(
int
requestedCount
GrPixelConfig
config
)
const
override
;
int
maxRenderTargetSampleCount
(
GrPixelConfig
config
)
const
override
;
bool
isConfigCopyable
(
GrPixelConfig
config
)
const
override
{
return
this
-
>
canConfigBeFBOColorAttachment
(
config
)
;
}
bool
canConfigBeFBOColorAttachment
(
GrPixelConfig
config
)
const
{
return
SkToBool
(
fConfigTable
[
config
]
.
fFlags
&
ConfigInfo
:
:
kFBOColorAttachment_Flag
)
;
}
bool
isConfigTexSupportEnabled
(
GrPixelConfig
config
)
const
{
return
SkToBool
(
fConfigTable
[
config
]
.
fFlags
&
ConfigInfo
:
:
kCanUseTexStorage_Flag
)
;
}
const
GrSwizzle
&
configSwizzle
(
GrPixelConfig
config
)
const
{
return
fConfigTable
[
config
]
.
fSwizzle
;
}
GrGLenum
configSizedInternalFormat
(
GrPixelConfig
config
)
const
{
return
fConfigTable
[
config
]
.
fFormats
.
fSizedInternalFormat
;
}
bool
getTexImageFormats
(
GrPixelConfig
surfaceConfig
GrPixelConfig
externalConfig
GrGLenum
*
internalFormat
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
bool
getReadPixelsFormat
(
GrPixelConfig
surfaceConfig
GrPixelConfig
externalConfig
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
void
getRenderbufferFormat
(
GrPixelConfig
config
GrGLenum
*
internalFormat
)
const
;
void
getSizedInternalFormat
(
GrPixelConfig
config
GrGLenum
*
internalFormat
)
const
;
GrGLenum
getImageFormat
(
GrPixelConfig
config
)
const
{
return
fConfigTable
[
config
]
.
fFormats
.
fSizedInternalFormat
;
}
const
SkTArray
<
StencilFormat
true
>
&
stencilFormats
(
)
const
{
return
fStencilFormats
;
}
bool
hasStencilFormatBeenDeterminedForConfig
(
GrPixelConfig
config
)
const
{
return
fConfigTable
[
config
]
.
fStencilFormatIndex
!
=
ConfigInfo
:
:
kUnknown_StencilIndex
;
}
int
getStencilFormatIndexForConfig
(
GrPixelConfig
config
)
const
{
SkASSERT
(
this
-
>
hasStencilFormatBeenDeterminedForConfig
(
config
)
)
;
return
fConfigTable
[
config
]
.
fStencilFormatIndex
;
}
void
setStencilFormatIndexForConfig
(
GrPixelConfig
config
int
index
)
{
SkASSERT
(
!
this
-
>
hasStencilFormatBeenDeterminedForConfig
(
config
)
)
;
if
(
index
<
0
)
{
fConfigTable
[
config
]
.
fStencilFormatIndex
=
ConfigInfo
:
:
kUnsupported_StencilFormatIndex
;
}
else
{
fConfigTable
[
config
]
.
fStencilFormatIndex
=
index
;
}
}
void
markConfigAsValidColorAttachment
(
GrPixelConfig
config
)
{
fConfigTable
[
config
]
.
fVerifiedColorAttachment
=
true
;
}
bool
isConfigVerifiedColorAttachment
(
GrPixelConfig
config
)
const
{
return
fConfigTable
[
config
]
.
fVerifiedColorAttachment
;
}
MSFBOType
msFBOType
(
)
const
{
return
fMSFBOType
;
}
bool
usesMSAARenderBuffers
(
)
const
{
return
kNone_MSFBOType
!
=
fMSFBOType
&
&
kES_IMG_MsToTexture_MSFBOType
!
=
fMSFBOType
&
&
kES_EXT_MsToTexture_MSFBOType
!
=
fMSFBOType
&
&
kMixedSamples_MSFBOType
!
=
fMSFBOType
;
}
uint32_t
blitFramebufferSupportFlags
(
)
const
{
return
fBlitFramebufferFlags
;
}
bool
usesImplicitMSAAResolve
(
)
const
{
return
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
|
|
kES_EXT_MsToTexture_MSFBOType
=
=
fMSFBOType
;
}
InvalidateFBType
invalidateFBType
(
)
const
{
return
fInvalidateFBType
;
}
MapBufferType
mapBufferType
(
)
const
{
return
fMapBufferType
;
}
TransferBufferType
transferBufferType
(
)
const
{
return
fTransferBufferType
;
}
int
maxFragmentUniformVectors
(
)
const
{
return
fMaxFragmentUniformVectors
;
}
bool
bgraIsInternalFormat
(
)
const
;
bool
unpackRowLengthSupport
(
)
const
{
return
fUnpackRowLengthSupport
;
}
bool
unpackFlipYSupport
(
)
const
{
return
fUnpackFlipYSupport
;
}
bool
packRowLengthSupport
(
)
const
{
return
fPackRowLengthSupport
;
}
bool
packFlipYSupport
(
)
const
{
return
fPackFlipYSupport
;
}
bool
textureUsageSupport
(
)
const
{
return
fTextureUsageSupport
;
}
bool
alpha8IsRenderable
(
)
const
{
return
fAlpha8IsRenderable
;
}
bool
imagingSupport
(
)
const
{
return
fImagingSupport
;
}
bool
vertexArrayObjectSupport
(
)
const
{
return
fVertexArrayObjectSupport
;
}
bool
debugSupport
(
)
const
{
return
fDebugSupport
;
}
bool
ES2CompatibilitySupport
(
)
const
{
return
fES2CompatibilitySupport
;
}
bool
drawInstancedSupport
(
)
const
{
return
fDrawInstancedSupport
;
}
bool
drawIndirectSupport
(
)
const
{
return
fDrawIndirectSupport
;
}
bool
multiDrawIndirectSupport
(
)
const
{
return
fMultiDrawIndirectSupport
;
}
bool
drawRangeElementsSupport
(
)
const
{
return
fDrawRangeElementsSupport
;
}
bool
baseInstanceSupport
(
)
const
{
return
fBaseInstanceSupport
;
}
bool
useNonVBOVertexAndIndexDynamicData
(
)
const
{
return
fUseNonVBOVertexAndIndexDynamicData
;
}
bool
surfaceSupportsWritePixels
(
const
GrSurface
*
)
const
override
;
bool
surfaceSupportsReadPixels
(
const
GrSurface
*
)
const
override
;
GrColorType
supportedReadPixelsColorType
(
GrPixelConfig
GrColorType
)
const
override
;
bool
readPixelsSupported
(
GrPixelConfig
surfaceConfig
GrPixelConfig
readConfig
std
:
:
function
<
void
(
GrGLenum
GrGLint
*
)
>
getIntegerv
std
:
:
function
<
bool
(
)
>
bindRenderTarget
std
:
:
function
<
void
(
)
>
unbindRenderTarget
)
const
;
bool
isCoreProfile
(
)
const
{
return
fIsCoreProfile
;
}
bool
bindFragDataLocationSupport
(
)
const
{
return
fBindFragDataLocationSupport
;
}
bool
bindUniformLocationSupport
(
)
const
{
return
fBindUniformLocationSupport
;
}
bool
rectangleTextureSupport
(
)
const
{
return
fRectangleTextureSupport
;
}
bool
textureSwizzleSupport
(
)
const
{
return
fTextureSwizzleSupport
;
}
bool
mipMapLevelAndLodControlSupport
(
)
const
{
return
fMipMapLevelAndLodControlSupport
;
}
bool
doManualMipmapping
(
)
const
{
return
fDoManualMipmapping
;
}
void
onDumpJSON
(
SkJSONWriter
*
)
const
override
;
bool
rgba8888PixelsOpsAreSlow
(
)
const
{
return
fRGBA8888PixelsOpsAreSlow
;
}
bool
partialFBOReadIsSlow
(
)
const
{
return
fPartialFBOReadIsSlow
;
}
bool
rgbaToBgraReadbackConversionsAreSlow
(
)
const
{
return
fRGBAToBGRAReadbackConversionsAreSlow
;
}
bool
useBufferDataNullHint
(
)
const
{
return
fUseBufferDataNullHint
;
}
bool
clearToBoundaryValuesIsBroken
(
)
const
{
return
fClearToBoundaryValuesIsBroken
;
}
bool
clearTextureSupport
(
)
const
{
return
fClearTextureSupport
;
}
bool
drawArraysBaseVertexIsBroken
(
)
const
{
return
fDrawArraysBaseVertexIsBroken
;
}
bool
useDrawToClearColor
(
)
const
{
return
fUseDrawToClearColor
;
}
bool
useDrawToClearStencilClip
(
)
const
{
return
fUseDrawToClearStencilClip
;
}
bool
disallowTexSubImageForUnormConfigTexturesEverBoundToFBO
(
)
const
{
return
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
;
}
bool
useDrawInsteadOfAllRenderTargetWrites
(
)
const
{
return
fUseDrawInsteadOfAllRenderTargetWrites
;
}
bool
requiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
(
)
const
{
return
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
;
}
bool
requiresFlushBetweenNonAndInstancedDraws
(
)
const
{
return
fRequiresFlushBetweenNonAndInstancedDraws
;
}
bool
detachStencilFromMSAABuffersBeforeReadPixels
(
)
const
{
return
fDetachStencilFromMSAABuffersBeforeReadPixels
;
}
int
maxInstancesPerDrawWithoutCrashing
(
int
pendingInstanceCount
)
const
{
return
(
fMaxInstancesPerDrawWithoutCrashing
)
?
fMaxInstancesPerDrawWithoutCrashing
:
pendingInstanceCount
;
}
bool
canCopyTexSubImage
(
GrPixelConfig
dstConfig
bool
dstHasMSAARenderBuffer
bool
dstIsTextureable
bool
dstIsGLTexture2D
GrSurfaceOrigin
dstOrigin
GrPixelConfig
srcConfig
bool
srcHasMSAARenderBuffer
bool
srcIsTextureable
bool
srcIsGLTexture2D
GrSurfaceOrigin
srcOrigin
)
const
;
bool
canCopyAsBlit
(
GrPixelConfig
dstConfig
int
dstSampleCnt
bool
dstIsTextureable
bool
dstIsGLTexture2D
GrSurfaceOrigin
dstOrigin
GrPixelConfig
srcConfig
int
srcSampleCnt
bool
srcIsTextureable
bool
srcIsGLTexture2D
GrSurfaceOrigin
srcOrigin
const
SkRect
&
srcBounds
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
const
;
bool
canCopyAsDraw
(
GrPixelConfig
dstConfig
bool
srcIsTextureable
)
const
;
bool
canCopySurface
(
const
GrSurfaceProxy
*
dst
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
const
override
;
bool
initDescForDstCopy
(
const
GrRenderTargetProxy
*
src
GrSurfaceDesc
*
desc
GrSurfaceOrigin
*
bool
*
rectsMustMatch
bool
*
disallowSubrect
)
const
override
;
bool
programBinarySupport
(
)
const
{
return
fProgramBinarySupport
;
}
bool
validateBackendTexture
(
const
GrBackendTexture
&
SkColorType
GrPixelConfig
*
)
const
override
;
bool
validateBackendRenderTarget
(
const
GrBackendRenderTarget
&
SkColorType
GrPixelConfig
*
)
const
override
;
bool
getConfigFromBackendFormat
(
const
GrBackendFormat
&
SkColorType
GrPixelConfig
*
)
const
override
;
#
if
GR_TEST_UTILS
GrGLStandard
standard
(
)
const
{
return
fStandard
;
}
#
endif
private
:
enum
ExternalFormatUsage
{
kTexImage_ExternalFormatUsage
kReadPixels_ExternalFormatUsage
kLast_ExternalFormatUsage
=
kReadPixels_ExternalFormatUsage
}
;
static
const
int
kExternalFormatUsageCnt
=
kLast_ExternalFormatUsage
+
1
;
bool
getExternalFormat
(
GrPixelConfig
surfaceConfig
GrPixelConfig
memoryConfig
ExternalFormatUsage
usage
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
void
init
(
const
GrContextOptions
&
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initGLSL
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
bool
hasPathRenderingSupport
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
applyDriverCorrectnessWorkarounds
(
const
GrGLContextInfo
&
const
GrContextOptions
&
GrShaderCaps
*
)
;
void
onApplyOptionsOverrides
(
const
GrContextOptions
&
options
)
override
;
#
ifdef
GR_TEST_UTILS
GrBackendFormat
onCreateFormatFromBackendTexture
(
const
GrBackendTexture
&
)
const
override
;
#
endif
bool
onIsWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
)
const
override
;
void
initFSAASupport
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initBlendEqationSupport
(
const
GrGLContextInfo
&
)
;
void
initStencilSupport
(
const
GrGLContextInfo
&
)
;
void
initConfigTable
(
const
GrContextOptions
&
const
GrGLContextInfo
&
const
GrGLInterface
*
GrShaderCaps
*
)
;
GrGLStandard
fStandard
;
SkTArray
<
StencilFormat
true
>
fStencilFormats
;
int
fMaxFragmentUniformVectors
;
MSFBOType
fMSFBOType
;
InvalidateFBType
fInvalidateFBType
;
MapBufferType
fMapBufferType
;
TransferBufferType
fTransferBufferType
;
bool
fUnpackRowLengthSupport
:
1
;
bool
fUnpackFlipYSupport
:
1
;
bool
fPackRowLengthSupport
:
1
;
bool
fPackFlipYSupport
:
1
;
bool
fTextureUsageSupport
:
1
;
bool
fAlpha8IsRenderable
:
1
;
bool
fImagingSupport
:
1
;
bool
fVertexArrayObjectSupport
:
1
;
bool
fDebugSupport
:
1
;
bool
fES2CompatibilitySupport
:
1
;
bool
fDrawInstancedSupport
:
1
;
bool
fDrawIndirectSupport
:
1
;
bool
fDrawRangeElementsSupport
:
1
;
bool
fMultiDrawIndirectSupport
:
1
;
bool
fBaseInstanceSupport
:
1
;
bool
fUseNonVBOVertexAndIndexDynamicData
:
1
;
bool
fIsCoreProfile
:
1
;
bool
fBindFragDataLocationSupport
:
1
;
bool
fRGBA8888PixelsOpsAreSlow
:
1
;
bool
fPartialFBOReadIsSlow
:
1
;
bool
fBindUniformLocationSupport
:
1
;
bool
fRectangleTextureSupport
:
1
;
bool
fTextureSwizzleSupport
:
1
;
bool
fMipMapLevelAndLodControlSupport
:
1
;
bool
fRGBAToBGRAReadbackConversionsAreSlow
:
1
;
bool
fUseBufferDataNullHint
:
1
;
bool
fClearTextureSupport
:
1
;
bool
fProgramBinarySupport
:
1
;
bool
fDoManualMipmapping
:
1
;
bool
fClearToBoundaryValuesIsBroken
:
1
;
bool
fDrawArraysBaseVertexIsBroken
:
1
;
bool
fUseDrawToClearColor
:
1
;
bool
fUseDrawToClearStencilClip
:
1
;
bool
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
:
1
;
bool
fUseDrawInsteadOfAllRenderTargetWrites
:
1
;
bool
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
:
1
;
bool
fRequiresFlushBetweenNonAndInstancedDraws
:
1
;
bool
fDetachStencilFromMSAABuffersBeforeReadPixels
:
1
;
int
fMaxInstancesPerDrawWithoutCrashing
;
uint32_t
fBlitFramebufferFlags
;
enum
FormatType
{
kNormalizedFixedPoint_FormatType
kFloat_FormatType
}
;
struct
ReadPixelsFormat
{
ReadPixelsFormat
(
)
:
fFormat
(
0
)
fType
(
0
)
{
}
GrGLenum
fFormat
;
GrGLenum
fType
;
}
;
struct
ConfigFormats
{
ConfigFormats
(
)
{
memset
(
this
0xAB
sizeof
(
ConfigFormats
)
)
;
}
GrGLenum
fBaseInternalFormat
;
GrGLenum
fSizedInternalFormat
;
GrGLenum
fExternalFormat
[
kExternalFormatUsageCnt
]
;
GrGLenum
fExternalType
;
GrGLenum
fInternalFormatTexImage
;
GrGLenum
fInternalFormatRenderbuffer
;
}
;
struct
ConfigInfo
{
ConfigInfo
(
)
:
fStencilFormatIndex
(
kUnknown_StencilIndex
)
fFlags
(
0
)
{
}
ConfigFormats
fFormats
;
FormatType
fFormatType
;
ReadPixelsFormat
fSecondReadPixelsFormat
;
enum
{
kUnknown_StencilIndex
=
-
1
kUnsupported_StencilFormatIndex
=
-
2
}
;
int
fStencilFormatIndex
;
SkTDArray
<
int
>
fColorSampleCounts
;
enum
{
kTextureable_Flag
=
0x1
kRenderable_Flag
=
0x2
kRenderableWithMSAA_Flag
=
0x4
kFBOColorAttachment_Flag
=
0x8
kCanUseTexStorage_Flag
=
0x10
}
;
uint32_t
fFlags
;
bool
fVerifiedColorAttachment
=
false
;
GrSwizzle
fSwizzle
;
}
;
ConfigInfo
fConfigTable
[
kGrPixelConfigCnt
]
;
typedef
GrCaps
INHERITED
;
}
;
#
endif
