#
ifndef
GrGLGpuCommandBuffer_DEFINED
#
define
GrGLGpuCommandBuffer_DEFINED
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrGLGpu
.
h
"
#
include
"
GrGLRenderTarget
.
h
"
#
include
"
GrOpFlushState
.
h
"
class
GrGLGpu
;
class
GrGLRenderTarget
;
class
GrGLGpuTextureCommandBuffer
:
public
GrGpuTextureCommandBuffer
{
public
:
GrGLGpuTextureCommandBuffer
(
GrGLGpu
*
gpu
)
:
fGpu
(
gpu
)
{
}
void
copy
(
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
override
{
fGpu
-
>
copySurface
(
fTexture
fOrigin
src
srcOrigin
srcRect
dstPoint
)
;
}
void
insertEventMarker
(
const
char
*
msg
)
override
{
fGpu
-
>
insertEventMarker
(
msg
)
;
}
void
reset
(
)
{
fTexture
=
nullptr
;
}
private
:
GrGLGpu
*
fGpu
;
typedef
GrGpuTextureCommandBuffer
INHERITED
;
}
;
class
GrGLGpuRTCommandBuffer
:
public
GrGpuRTCommandBuffer
{
public
:
GrGLGpuRTCommandBuffer
(
GrGLGpu
*
gpu
)
:
fGpu
(
gpu
)
{
}
void
begin
(
)
override
;
void
end
(
)
override
{
}
void
discard
(
)
override
{
}
void
insertEventMarker
(
const
char
*
msg
)
override
{
fGpu
-
>
insertEventMarker
(
msg
)
;
}
void
inlineUpload
(
GrOpFlushState
*
state
GrDeferredTextureUploadFn
&
upload
)
override
{
state
-
>
doUpload
(
upload
)
;
}
void
copy
(
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
override
{
fGpu
-
>
copySurface
(
fRenderTarget
fOrigin
src
srcOrigin
srcRect
dstPoint
)
;
}
void
set
(
GrRenderTarget
*
GrSurfaceOrigin
const
GrGpuRTCommandBuffer
:
:
LoadAndStoreInfo
&
const
GrGpuRTCommandBuffer
:
:
StencilLoadAndStoreInfo
&
)
;
void
reset
(
)
{
fRenderTarget
=
nullptr
;
}
private
:
GrGpu
*
gpu
(
)
override
{
return
fGpu
;
}
void
onDraw
(
const
GrPrimitiveProcessor
&
primProc
const
GrPipeline
&
pipeline
const
GrPipeline
:
:
FixedDynamicState
*
fixedDynamicState
const
GrPipeline
:
:
DynamicStateArrays
*
dynamicStateArrays
const
GrMesh
mesh
[
]
int
meshCount
const
SkRect
&
bounds
)
override
{
SkASSERT
(
pipeline
.
renderTarget
(
)
=
=
fRenderTarget
)
;
fGpu
-
>
draw
(
primProc
pipeline
fixedDynamicState
dynamicStateArrays
mesh
meshCount
)
;
}
void
onClear
(
const
GrFixedClip
&
clip
GrColor
color
)
override
{
fGpu
-
>
clear
(
clip
color
fRenderTarget
fOrigin
)
;
}
void
onClearStencilClip
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
override
{
fGpu
-
>
clearStencilClip
(
clip
insideStencilMask
fRenderTarget
fOrigin
)
;
}
GrGLGpu
*
fGpu
;
GrGpuRTCommandBuffer
:
:
LoadAndStoreInfo
fColorLoadAndStoreInfo
;
GrGpuRTCommandBuffer
:
:
StencilLoadAndStoreInfo
fStencilLoadAndStoreInfo
;
typedef
GrGpuRTCommandBuffer
INHERITED
;
}
;
#
endif
