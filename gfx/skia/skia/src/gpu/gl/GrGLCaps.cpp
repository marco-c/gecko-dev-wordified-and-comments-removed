#
include
"
GrGLCaps
.
h
"
#
include
"
GrContextOptions
.
h
"
#
include
"
GrGLContext
.
h
"
#
include
"
GrGLRenderTarget
.
h
"
#
include
"
GrGLTexture
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
SkJSONWriter
.
h
"
#
include
"
SkTSearch
.
h
"
#
include
"
SkTSort
.
h
"
GrGLCaps
:
:
GrGLCaps
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
glInterface
)
:
INHERITED
(
contextOptions
)
{
fStandard
=
ctxInfo
.
standard
(
)
;
fStencilFormats
.
reset
(
)
;
fMSFBOType
=
kNone_MSFBOType
;
fInvalidateFBType
=
kNone_InvalidateFBType
;
fMapBufferType
=
kNone_MapBufferType
;
fTransferBufferType
=
kNone_TransferBufferType
;
fMaxFragmentUniformVectors
=
0
;
fUnpackRowLengthSupport
=
false
;
fUnpackFlipYSupport
=
false
;
fPackRowLengthSupport
=
false
;
fPackFlipYSupport
=
false
;
fTextureUsageSupport
=
false
;
fAlpha8IsRenderable
=
false
;
fImagingSupport
=
false
;
fVertexArrayObjectSupport
=
false
;
fDebugSupport
=
false
;
fES2CompatibilitySupport
=
false
;
fDrawIndirectSupport
=
false
;
fMultiDrawIndirectSupport
=
false
;
fBaseInstanceSupport
=
false
;
fIsCoreProfile
=
false
;
fBindFragDataLocationSupport
=
false
;
fRectangleTextureSupport
=
false
;
fTextureSwizzleSupport
=
false
;
fRGBA8888PixelsOpsAreSlow
=
false
;
fPartialFBOReadIsSlow
=
false
;
fMipMapLevelAndLodControlSupport
=
false
;
fRGBAToBGRAReadbackConversionsAreSlow
=
false
;
fDoManualMipmapping
=
false
;
fSRGBDecodeDisableAffectsMipmaps
=
false
;
fClearToBoundaryValuesIsBroken
=
false
;
fClearTextureSupport
=
false
;
fDrawArraysBaseVertexIsBroken
=
false
;
fUseDrawToClearColor
=
false
;
fUseDrawToClearStencilClip
=
false
;
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
false
;
fUseDrawInsteadOfAllRenderTargetWrites
=
false
;
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
=
false
;
fProgramBinarySupport
=
false
;
fBlitFramebufferFlags
=
kNoSupport_BlitFramebufferFlag
;
fMaxInstancesPerDrawArraysWithoutCrashing
=
0
;
fShaderCaps
.
reset
(
new
GrShaderCaps
(
contextOptions
)
)
;
this
-
>
init
(
contextOptions
ctxInfo
glInterface
)
;
}
void
GrGLCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
if
(
kGLES_GrGLStandard
=
=
standard
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_FRAGMENT_UNIFORM_VECTORS
&
fMaxFragmentUniformVectors
)
;
}
else
{
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
GrGLint
max
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
&
max
)
;
fMaxFragmentUniformVectors
=
max
/
4
;
if
(
version
>
=
GR_GL_VER
(
3
2
)
)
{
GrGLint
profileMask
;
GR_GL_GetIntegerv
(
gli
GR_GL_CONTEXT_PROFILE_MASK
&
profileMask
)
;
fIsCoreProfile
=
SkToBool
(
profileMask
&
GR_GL_CONTEXT_CORE_PROFILE_BIT
)
;
}
}
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_VERTEX_ATTRIBS
&
fMaxVertexAttributes
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fUnpackRowLengthSupport
=
true
;
fUnpackFlipYSupport
=
false
;
fPackRowLengthSupport
=
true
;
fPackFlipYSupport
=
false
;
}
else
{
fUnpackRowLengthSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_unpack_subimage
"
)
;
fUnpackFlipYSupport
=
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_flipy
"
)
;
fPackRowLengthSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_pack_subimage
"
)
;
fPackFlipYSupport
=
ctxInfo
.
hasExtension
(
"
GL_ANGLE_pack_reverse_row_order
"
)
;
}
fTextureUsageSupport
=
(
kGLES_GrGLStandard
=
=
standard
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ANGLE_texture_usage
"
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fTextureBarrierSupport
=
version
>
=
GR_GL_VER
(
4
5
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_barrier
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_texture_barrier
"
)
;
}
else
{
fTextureBarrierSupport
=
ctxInfo
.
hasExtension
(
"
GL_NV_texture_barrier
"
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fSampleLocationsSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_multisample
"
)
;
}
else
{
fSampleLocationsSupport
=
version
>
=
GR_GL_VER
(
3
1
)
;
}
fImagingSupport
=
kGL_GrGLStandard
=
=
standard
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_imaging
"
)
;
if
(
(
(
kGL_GrGLStandard
=
=
standard
&
&
version
>
=
GR_GL_VER
(
4
3
)
)
|
|
(
kGLES_GrGLStandard
=
=
standard
&
&
version
>
=
GR_GL_VER
(
3
0
)
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_invalidate_subdata
"
)
)
)
{
fDiscardRenderTargetSupport
=
true
;
fInvalidateFBType
=
kInvalidate_InvalidateFBType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_discard_framebuffer
"
)
)
{
fDiscardRenderTargetSupport
=
true
;
fInvalidateFBType
=
kDiscard_InvalidateFBType
;
}
if
(
kGLES_GrGLStandard
=
=
standard
)
{
if
(
kARM_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fUsePrimitiveRestart
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
}
if
(
kARM_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
|
|
kImagination_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
|
|
kQualcomm_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fPreferFullscreenClears
=
true
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fVertexArrayObjectSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_vertex_array_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_APPLE_vertex_array_object
"
)
;
}
else
{
fVertexArrayObjectSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_vertex_array_object
"
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
&
&
version
>
=
GR_GL_VER
(
4
3
)
)
{
fDebugSupport
=
true
;
}
else
{
fDebugSupport
=
ctxInfo
.
hasExtension
(
"
GL_KHR_debug
"
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fES2CompatibilitySupport
=
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
;
}
else
{
fES2CompatibilitySupport
=
true
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fMultisampleDisableSupport
=
true
;
}
else
{
fMultisampleDisableSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_multisample_compatibility
"
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fInstanceAttribSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_ARB_draw_instanced
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_instanced_arrays
"
)
)
;
}
else
{
fInstanceAttribSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_EXT_draw_instanced
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_instanced_arrays
"
)
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fBindFragDataLocationSupport
=
true
;
}
}
else
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_blend_func_extended
"
)
)
{
fBindFragDataLocationSupport
=
true
;
}
}
fBindUniformLocationSupport
=
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_bind_uniform_location
"
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
1
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rectangle
"
)
)
{
if
(
ctxInfo
.
glslGeneration
(
)
>
=
k140_GrGLSLGeneration
)
{
fRectangleTextureSupport
=
true
;
}
}
}
else
{
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_swizzle
"
)
)
{
fTextureSwizzleSupport
=
true
;
}
}
else
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fTextureSwizzleSupport
=
true
;
}
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fMipMapLevelAndLodControlSupport
=
true
;
}
else
if
(
kGLES_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fMipMapLevelAndLodControlSupport
=
true
;
}
}
#
ifdef
SK_BUILD_FOR_WIN
bool
isANGLE
=
kANGLE_GrGLDriver
=
=
ctxInfo
.
driver
(
)
|
|
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
;
fRGBA8888PixelsOpsAreSlow
=
isANGLE
;
fPartialFBOReadIsSlow
=
isANGLE
;
#
endif
bool
isMESA
=
kMesa_GrGLDriver
=
=
ctxInfo
.
driver
(
)
;
bool
isMAC
=
false
;
#
ifdef
SK_BUILD_FOR_MAC
isMAC
=
true
;
#
endif
fRGBAToBGRAReadbackConversionsAreSlow
=
isMESA
|
|
isMAC
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
4
4
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_clear_texture
"
)
)
{
fClearTextureSupport
=
true
;
}
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_clear_texture
"
)
)
{
fClearTextureSupport
=
true
;
}
this
-
>
initGLSL
(
ctxInfo
gli
)
;
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fPathRenderingSupport
=
this
-
>
hasPathRenderingSupport
(
ctxInfo
gli
)
;
#
if
GR_TEST_UTILS
if
(
contextOptions
.
fSuppressPathRendering
)
{
shaderCaps
-
>
fPathRenderingSupport
=
false
;
}
#
endif
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_blend_func_extended
"
)
)
&
&
GrGLSLSupportsNamedFragmentShaderOutputs
(
ctxInfo
.
glslGeneration
(
)
)
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fGeometryShaderSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
2
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
k150_GrGLSLGeneration
;
if
(
shaderCaps
-
>
fGeometryShaderSupport
)
{
if
(
ctxInfo
.
glslGeneration
(
)
>
=
k400_GrGLSLGeneration
)
{
shaderCaps
-
>
fGSInvocationsSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ARB_gpu_shader5
"
)
)
{
shaderCaps
-
>
fGSInvocationsSupport
=
true
;
shaderCaps
-
>
fGSInvocationsExtensionString
=
"
GL_ARB_gpu_shader5
"
;
}
}
shaderCaps
-
>
fIntegerSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
k130_GrGLSLGeneration
;
}
else
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_blend_func_extended
"
)
;
shaderCaps
-
>
fShaderDerivativeSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_standard_derivatives
"
)
;
if
(
kARM_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
2
)
)
{
shaderCaps
-
>
fGeometryShaderSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_geometry_shader
"
)
)
{
shaderCaps
-
>
fGeometryShaderSupport
=
true
;
shaderCaps
-
>
fGeometryShaderExtensionString
=
"
GL_EXT_geometry_shader
"
;
}
shaderCaps
-
>
fGSInvocationsSupport
=
shaderCaps
-
>
fGeometryShaderSupport
;
}
shaderCaps
-
>
fIntegerSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
k330_GrGLSLGeneration
;
}
static
const
uint8_t
kMaxSaneSamplers
=
32
;
GrGLint
maxSamplers
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
&
maxSamplers
)
;
shaderCaps
-
>
fMaxVertexSamplers
=
SkTMin
<
GrGLint
>
(
kMaxSaneSamplers
maxSamplers
)
;
if
(
shaderCaps
-
>
fGeometryShaderSupport
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
&
maxSamplers
)
;
shaderCaps
-
>
fMaxGeometrySamplers
=
SkTMin
<
GrGLint
>
(
kMaxSaneSamplers
maxSamplers
)
;
}
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_TEXTURE_IMAGE_UNITS
&
maxSamplers
)
;
shaderCaps
-
>
fMaxFragmentSamplers
=
SkTMin
<
GrGLint
>
(
kMaxSaneSamplers
maxSamplers
)
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
&
maxSamplers
)
;
shaderCaps
-
>
fMaxCombinedSamplers
=
SkTMin
<
GrGLint
>
(
kMaxSaneSamplers
maxSamplers
)
;
switch
(
ctxInfo
.
vendor
(
)
)
{
case
kNVIDIA_GrGLVendor
:
fShaderCaps
-
>
fDisableImageMultitexturingDstRectAreaThreshold
=
150
*
150
;
break
;
case
kImagination_GrGLVendor
:
if
(
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fShaderCaps
-
>
fDisableImageMultitexturingDstRectAreaThreshold
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
}
break
;
case
kATI_GrGLVendor
:
fShaderCaps
-
>
fDisableImageMultitexturingDstRectAreaThreshold
=
0
;
break
;
default
:
break
;
}
if
(
!
GR_GL_MUST_USE_VBO
&
&
!
fIsCoreProfile
&
&
(
kARM_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
|
|
kImagination_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
|
|
kQualcomm_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
)
{
fPreferClientSideDynamicBuffers
=
true
;
}
if
(
!
contextOptions
.
fAvoidStencilBuffers
)
{
this
-
>
initFSAASupport
(
contextOptions
ctxInfo
gli
)
;
this
-
>
initStencilSupport
(
ctxInfo
)
;
}
if
(
kGL_GrGLStandard
!
=
ctxInfo
.
standard
(
)
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
fBlitFramebufferFlags
=
kNoFormatConversionForMSAASrc_BlitFramebufferFlag
|
kNoMSAADst_BlitFramebufferFlag
|
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_framebuffer_multisample
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ANGLE_framebuffer_blit
"
)
)
{
fBlitFramebufferFlags
=
kNoScalingOrMirroring_BlitFramebufferFlag
|
kResolveMustBeFull_BlitFrambufferFlag
|
kNoMSAADst_BlitFramebufferFlag
|
kNoFormatConversion_BlitFramebufferFlag
|
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
;
}
}
else
{
if
(
fUsesMixedSamples
|
|
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_blit
"
)
)
{
fBlitFramebufferFlags
=
0
;
}
}
this
-
>
initBlendEqationSupport
(
ctxInfo
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fMapBufferFlags
=
kCanMap_MapFlag
;
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_map_buffer_range
"
)
)
{
fMapBufferFlags
|
=
kSubset_MapFlag
;
fMapBufferType
=
kMapBufferRange_MapBufferType
;
}
else
{
fMapBufferType
=
kMapBuffer_MapBufferType
;
}
}
else
{
fMapBufferFlags
=
kNone_MapBufferType
;
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_map_sub
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fMapBufferType
=
kChromium_MapBufferType
;
}
else
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_map_buffer_range
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fMapBufferType
=
kMapBufferRange_MapBufferType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_mapbuffer
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
;
fMapBufferType
=
kMapBuffer_MapBufferType
;
}
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_pixel_buffer_object
"
)
)
{
fTransferBufferType
=
kPBO_TransferBufferType
;
}
}
else
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_NV_pixel_buffer_object
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_unpack_subimage
"
)
)
)
{
fTransferBufferType
=
kPBO_TransferBufferType
;
}
}
if
(
fBufferMapThreshold
<
0
)
{
#
if
0
fBufferMapThreshold
=
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
?
0
:
SK_MaxS32
;
#
else
fBufferMapThreshold
=
SK_MaxS32
;
#
endif
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fNPOTTextureTileSupport
=
true
;
fMipMapSupport
=
true
;
}
else
{
fNPOTTextureTileSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_texture_npot
"
)
;
fMipMapSupport
=
fNPOTTextureTileSupport
|
|
ctxInfo
.
hasExtension
(
"
GL_IMG_texture_npot
"
)
;
}
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_TEXTURE_SIZE
&
fMaxTextureSize
)
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_RENDERBUFFER_SIZE
&
fMaxRenderTargetSize
)
;
fMaxRenderTargetSize
=
SkTMin
(
fMaxTextureSize
fMaxRenderTargetSize
)
;
fMaxPreferredRenderTargetSize
=
fMaxRenderTargetSize
;
if
(
kARM_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fMaxPreferredRenderTargetSize
=
SkTMin
(
4096
fMaxPreferredRenderTargetSize
)
;
}
fGpuTracingSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_debug_marker
"
)
;
fReuseScratchTextures
=
kARM_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
;
#
if
0
fReuseScratchBuffers
=
kARM_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
&
&
kQualcomm_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
;
#
endif
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_window_rectangles
"
)
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_WINDOW_RECTANGLES
&
fMaxWindowRectangles
)
;
}
#
ifdef
SK_BUILD_FOR_WIN
fPreferVRAMUseOverFlushes
=
!
isANGLE
;
#
endif
if
(
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
)
{
fMustClearUploadedBufferData
=
true
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
)
{
fOversizedStencilSupport
=
true
;
}
else
{
SkASSERT
(
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_object
"
)
)
;
}
}
else
{
fOversizedStencilSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
fDrawIndirectSupport
=
version
>
=
GR_GL_VER
(
4
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_draw_indirect
"
)
;
fBaseInstanceSupport
=
version
>
=
GR_GL_VER
(
4
2
)
;
fMultiDrawIndirectSupport
=
version
>
=
GR_GL_VER
(
4
3
)
|
|
(
fDrawIndirectSupport
&
&
!
fBaseInstanceSupport
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_multi_draw_indirect
"
)
)
;
fDrawRangeElementsSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
else
{
fDrawIndirectSupport
=
version
>
=
GR_GL_VER
(
3
1
)
;
fMultiDrawIndirectSupport
=
fDrawIndirectSupport
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_multi_draw_indirect
"
)
;
fBaseInstanceSupport
=
fDrawIndirectSupport
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_base_instance
"
)
;
fDrawRangeElementsSupport
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
(
version
>
=
GR_GL_VER
(
4
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_sample_shading
"
)
)
)
{
fSampleShadingSupport
=
true
;
}
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_sample_shading
"
)
)
{
fSampleShadingSupport
=
true
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_sync
"
)
)
{
fFenceSyncSupport
=
true
;
}
}
else
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_APPLE_sync
"
)
)
{
fFenceSyncSupport
=
true
;
}
fCrossContextTextureSupport
=
fFenceSyncSupport
;
fSRGBDecodeDisableSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_sRGB_decode
"
)
;
fSRGBDecodeDisableAffectsMipmaps
=
fSRGBDecodeDisableSupport
&
&
kChromium_GrGLDriver
!
=
ctxInfo
.
driver
(
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
4
1
)
)
{
fProgramBinarySupport
=
true
;
}
}
else
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fProgramBinarySupport
=
true
;
}
this
-
>
initConfigTable
(
contextOptions
ctxInfo
gli
shaderCaps
)
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
ctxInfo
contextOptions
shaderCaps
)
;
}
this
-
>
applyOptionsOverrides
(
contextOptions
)
;
shaderCaps
-
>
applyOptionsOverrides
(
contextOptions
)
;
shaderCaps
-
>
fDstReadInShaderSupport
=
shaderCaps
-
>
fFBFetchSupport
;
}
const
char
*
get_glsl_version_decl_string
(
GrGLStandard
standard
GrGLSLGeneration
generation
bool
isCoreProfile
)
{
switch
(
generation
)
{
case
k110_GrGLSLGeneration
:
if
(
kGLES_GrGLStandard
=
=
standard
)
{
return
"
#
version
100
\
n
"
;
}
else
{
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
return
"
#
version
110
\
n
"
;
}
case
k130_GrGLSLGeneration
:
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
return
"
#
version
130
\
n
"
;
case
k140_GrGLSLGeneration
:
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
return
"
#
version
140
\
n
"
;
case
k150_GrGLSLGeneration
:
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
if
(
isCoreProfile
)
{
return
"
#
version
150
\
n
"
;
}
else
{
return
"
#
version
150
compatibility
\
n
"
;
}
case
k330_GrGLSLGeneration
:
if
(
kGLES_GrGLStandard
=
=
standard
)
{
return
"
#
version
300
es
\
n
"
;
}
else
{
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
if
(
isCoreProfile
)
{
return
"
#
version
330
\
n
"
;
}
else
{
return
"
#
version
330
compatibility
\
n
"
;
}
}
case
k400_GrGLSLGeneration
:
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
if
(
isCoreProfile
)
{
return
"
#
version
400
\
n
"
;
}
else
{
return
"
#
version
400
compatibility
\
n
"
;
}
case
k420_GrGLSLGeneration
:
SkASSERT
(
kGL_GrGLStandard
=
=
standard
)
;
if
(
isCoreProfile
)
{
return
"
#
version
420
\
n
"
;
}
else
{
return
"
#
version
420
compatibility
\
n
"
;
}
case
k310es_GrGLSLGeneration
:
SkASSERT
(
kGLES_GrGLStandard
=
=
standard
)
;
return
"
#
version
310
es
\
n
"
;
case
k320es_GrGLSLGeneration
:
SkASSERT
(
kGLES_GrGLStandard
=
=
standard
)
;
return
"
#
version
320
es
\
n
"
;
}
return
"
<
no
version
>
"
;
}
bool
is_float_fp32
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
GrGLenum
precision
)
{
if
(
kGLES_GrGLStandard
!
=
ctxInfo
.
standard
(
)
&
&
ctxInfo
.
version
(
)
<
GR_GL_VER
(
4
1
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
)
{
return
true
;
}
for
(
GrGLenum
shader
:
{
GR_GL_FRAGMENT_SHADER
GR_GL_VERTEX_SHADER
}
)
{
GrGLint
range
[
2
]
;
GrGLint
bits
;
GR_GL_GetShaderPrecisionFormat
(
gli
shader
precision
range
&
bits
)
;
if
(
range
[
0
]
<
127
|
|
range
[
1
]
<
127
|
|
bits
<
23
)
{
return
false
;
}
}
return
true
;
}
void
GrGLCaps
:
:
initGLSL
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fGLSLGeneration
=
ctxInfo
.
glslGeneration
(
)
;
if
(
kGLES_GrGLStandard
=
=
standard
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragData
[
0
]
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_EXT_shader_framebuffer_fetch
"
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
false
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragData
[
0
]
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_NV_shader_framebuffer_fetch
"
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ARM_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
false
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragColorARM
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_ARM_shader_framebuffer_fetch
"
;
}
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fFlatInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k130_GrGLSLGeneration
;
}
else
{
shaderCaps
-
>
fFlatInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k330_GrGLSLGeneration
;
}
shaderCaps
-
>
fPreferFlatInterpolation
=
shaderCaps
-
>
fFlatInterpolationSupport
&
&
kQualcomm_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fNoPerspectiveInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k130_GrGLSLGeneration
;
}
else
{
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_shader_noperspective_interpolation
"
)
)
{
shaderCaps
-
>
fNoPerspectiveInterpolationSupport
=
true
;
shaderCaps
-
>
fNoPerspectiveInterpolationExtensionString
=
"
GL_NV_shader_noperspective_interpolation
"
;
}
}
shaderCaps
-
>
fVersionDeclString
=
get_glsl_version_decl_string
(
standard
shaderCaps
-
>
fGLSLGeneration
fIsCoreProfile
)
;
if
(
kGLES_GrGLStandard
=
=
standard
&
&
k110_GrGLSLGeneration
=
=
shaderCaps
-
>
fGLSLGeneration
)
{
shaderCaps
-
>
fShaderDerivativeExtensionString
=
"
GL_OES_standard_derivatives
"
;
}
if
(
kGLES_GrGLStandard
!
=
standard
&
&
(
ctxInfo
.
glslGeneration
(
)
>
=
k150_GrGLSLGeneration
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_fragment_coord_conventions
"
)
)
)
{
shaderCaps
-
>
fFragCoordConventionsExtensionString
=
"
GL_ARB_fragment_coord_conventions
"
;
}
if
(
kGLES_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fSecondaryOutputExtensionString
=
"
GL_EXT_blend_func_extended
"
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_EGL_image_external
"
)
)
{
if
(
ctxInfo
.
glslGeneration
(
)
=
=
k110_GrGLSLGeneration
)
{
shaderCaps
-
>
fExternalTextureSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_EGL_image_external_essl3
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_EGL_image_external_essl3
"
)
)
{
shaderCaps
-
>
fExternalTextureSupport
=
true
;
}
}
if
(
shaderCaps
-
>
fExternalTextureSupport
)
{
if
(
ctxInfo
.
glslGeneration
(
)
=
=
k110_GrGLSLGeneration
)
{
shaderCaps
-
>
fExternalTextureExtensionString
=
"
GL_OES_EGL_image_external
"
;
}
else
{
shaderCaps
-
>
fExternalTextureExtensionString
=
"
GL_OES_EGL_image_external_essl3
"
;
}
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fTexelFetchSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k130_GrGLSLGeneration
;
}
else
{
shaderCaps
-
>
fTexelFetchSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k330_GrGLSLGeneration
;
}
if
(
shaderCaps
-
>
fTexelFetchSupport
)
{
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fTexelBufferSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
1
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
k330_GrGLSLGeneration
;
}
else
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
2
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
k320es_GrGLSLGeneration
)
{
shaderCaps
-
>
fTexelBufferSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_buffer
"
)
)
{
shaderCaps
-
>
fTexelBufferSupport
=
true
;
shaderCaps
-
>
fTexelBufferExtensionString
=
"
GL_OES_texture_buffer
"
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_buffer
"
)
)
{
shaderCaps
-
>
fTexelBufferSupport
=
true
;
shaderCaps
-
>
fTexelBufferExtensionString
=
"
GL_EXT_texture_buffer
"
;
}
}
}
if
(
kGL_GrGLStandard
=
=
standard
)
{
shaderCaps
-
>
fVertexIDSupport
=
true
;
}
else
{
shaderCaps
-
>
fVertexIDSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
k330_GrGLSLGeneration
;
}
shaderCaps
-
>
fFloatIs32Bits
=
is_float_fp32
(
ctxInfo
gli
GR_GL_HIGH_FLOAT
)
;
shaderCaps
-
>
fHalfIs32Bits
=
is_float_fp32
(
ctxInfo
gli
GR_GL_MEDIUM_FLOAT
)
;
}
bool
GrGLCaps
:
:
hasPathRenderingSupport
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
bool
hasChromiumPathRendering
=
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_path_rendering
"
)
;
if
(
!
(
ctxInfo
.
hasExtension
(
"
GL_NV_path_rendering
"
)
|
|
hasChromiumPathRendering
)
)
{
return
false
;
}
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
)
{
if
(
ctxInfo
.
version
(
)
<
GR_GL_VER
(
4
3
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_ARB_program_interface_query
"
)
)
{
return
false
;
}
}
else
{
if
(
!
hasChromiumPathRendering
&
&
ctxInfo
.
version
(
)
<
GR_GL_VER
(
3
1
)
)
{
return
false
;
}
}
if
(
!
gli
-
>
fFunctions
.
fStencilThenCoverFillPath
|
|
!
gli
-
>
fFunctions
.
fStencilThenCoverStrokePath
|
|
!
gli
-
>
fFunctions
.
fStencilThenCoverFillPathInstanced
|
|
!
gli
-
>
fFunctions
.
fStencilThenCoverStrokePathInstanced
|
|
!
gli
-
>
fFunctions
.
fProgramPathFragmentInputGen
)
{
return
false
;
}
return
true
;
}
bool
GrGLCaps
:
:
readPixelsSupported
(
GrPixelConfig
surfaceConfig
GrPixelConfig
readConfig
std
:
:
function
<
void
(
GrGLenum
GrGLint
*
)
>
getIntegerv
std
:
:
function
<
bool
(
)
>
bindRenderTarget
std
:
:
function
<
void
(
)
>
unbindRenderTarget
)
const
{
if
(
!
this
-
>
canConfigBeFBOColorAttachment
(
surfaceConfig
)
)
{
return
false
;
}
GrGLenum
readFormat
;
GrGLenum
readType
;
if
(
!
this
-
>
getReadPixelsFormat
(
surfaceConfig
readConfig
&
readFormat
&
readType
)
)
{
return
false
;
}
if
(
kGL_GrGLStandard
=
=
fStandard
)
{
if
(
readFormat
!
=
GR_GL_RED
&
&
readFormat
!
=
GR_GL_RG
&
&
readFormat
!
=
GR_GL_RGB
&
&
readFormat
!
=
GR_GL_RGBA
&
&
readFormat
!
=
GR_GL_BGRA
&
&
readFormat
!
=
GR_GL_RGBA_INTEGER
)
{
return
false
;
}
return
true
;
}
switch
(
fConfigTable
[
surfaceConfig
]
.
fFormatType
)
{
case
kNormalizedFixedPoint_FormatType
:
if
(
GR_GL_RGBA
=
=
readFormat
&
&
GR_GL_UNSIGNED_BYTE
=
=
readType
)
{
return
true
;
}
break
;
case
kInteger_FormatType
:
if
(
GR_GL_RGBA_INTEGER
=
=
readFormat
&
&
GR_GL_INT
=
=
readType
)
{
return
true
;
}
break
;
case
kFloat_FormatType
:
if
(
GR_GL_RGBA
=
=
readFormat
&
&
GR_GL_FLOAT
=
=
readType
)
{
return
true
;
}
break
;
}
if
(
0
=
=
fConfigTable
[
surfaceConfig
]
.
fSecondReadPixelsFormat
.
fFormat
)
{
ReadPixelsFormat
*
rpFormat
=
const_cast
<
ReadPixelsFormat
*
>
(
&
fConfigTable
[
surfaceConfig
]
.
fSecondReadPixelsFormat
)
;
GrGLint
format
=
0
type
=
0
;
if
(
!
bindRenderTarget
(
)
)
{
return
false
;
}
getIntegerv
(
GR_GL_IMPLEMENTATION_COLOR_READ_FORMAT
&
format
)
;
getIntegerv
(
GR_GL_IMPLEMENTATION_COLOR_READ_TYPE
&
type
)
;
rpFormat
-
>
fFormat
=
format
;
rpFormat
-
>
fType
=
type
;
unbindRenderTarget
(
)
;
}
return
fConfigTable
[
surfaceConfig
]
.
fSecondReadPixelsFormat
.
fFormat
=
=
readFormat
&
&
fConfigTable
[
surfaceConfig
]
.
fSecondReadPixelsFormat
.
fType
=
=
readType
;
}
void
GrGLCaps
:
:
initFSAASupport
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
if
(
fMultisampleDisableSupport
&
&
this
-
>
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
&
&
this
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
#
if
GR_TEST_UTILS
&
&
(
contextOptions
.
fGpuPathRenderers
&
GpuPathRenderers
:
:
kStencilAndCover
)
#
endif
)
{
fUsesMixedSamples
=
ctxInfo
.
hasExtension
(
"
GL_NV_framebuffer_mixed_samples
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_framebuffer_mixed_samples
"
)
;
}
if
(
kGL_GrGLStandard
!
=
ctxInfo
.
standard
(
)
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
renderer
(
)
!
=
kGalliumLLVM_GrGLRenderer
)
{
fAlpha8IsRenderable
=
true
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_multisampled_render_to_texture
"
)
)
{
fMSFBOType
=
kES_EXT_MsToTexture_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_IMG_multisampled_render_to_texture
"
)
)
{
fMSFBOType
=
kES_IMG_MsToTexture_MSFBOType
;
}
else
if
(
fUsesMixedSamples
)
{
fMSFBOType
=
kMixedSamples_MSFBOType
;
}
else
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ANGLE_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_APPLE_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kES_Apple_MSFBOType
;
}
}
else
{
if
(
fUsesMixedSamples
)
{
fMSFBOType
=
kMixedSamples_MSFBOType
;
}
else
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
if
(
!
fIsCoreProfile
&
&
ctxInfo
.
renderer
(
)
!
=
kOSMesa_GrGLRenderer
)
{
fAlpha8IsRenderable
=
true
;
}
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_multisample
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_blit
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
}
if
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fMSFBOType
=
kNone_MSFBOType
;
}
if
(
fUsesMixedSamples
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_raster_multisample
"
)
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_RASTER_SAMPLES
&
fMaxRasterSamples
)
;
}
}
void
GrGLCaps
:
:
initBlendEqationSupport
(
const
GrGLContextInfo
&
ctxInfo
)
{
GrShaderCaps
*
shaderCaps
=
static_cast
<
GrShaderCaps
*
>
(
fShaderCaps
.
get
(
)
)
;
bool
layoutQualifierSupport
=
false
;
if
(
(
kGL_GrGLStandard
=
=
fStandard
&
&
shaderCaps
-
>
generation
(
)
>
=
k140_GrGLSLGeneration
)
|
|
(
kGLES_GrGLStandard
=
=
fStandard
&
&
shaderCaps
-
>
generation
(
)
>
=
k330_GrGLSLGeneration
)
)
{
layoutQualifierSupport
=
true
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_blend_equation_advanced_coherent
"
)
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_KHR_blend_equation_advanced_coherent
"
)
&
&
layoutQualifierSupport
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kGeneralEnable_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_blend_equation_advanced
"
)
)
{
fBlendEquationSupport
=
kAdvanced_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_KHR_blend_equation_advanced
"
)
&
&
layoutQualifierSupport
)
{
fBlendEquationSupport
=
kAdvanced_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kGeneralEnable_AdvBlendEqInteraction
;
}
}
namespace
{
const
GrGLuint
kUnknownBitCount
=
GrGLStencilAttachment
:
:
kUnknownBitCount
;
}
void
GrGLCaps
:
:
initStencilSupport
(
const
GrGLContextInfo
&
ctxInfo
)
{
static
const
StencilFormat
gS8
=
{
GR_GL_STENCIL_INDEX8
8
8
false
}
gS16
=
{
GR_GL_STENCIL_INDEX16
16
16
false
}
gD24S8
=
{
GR_GL_DEPTH24_STENCIL8
8
32
true
}
gS4
=
{
GR_GL_STENCIL_INDEX4
4
4
false
}
gDS
=
{
GR_GL_DEPTH_STENCIL
kUnknownBitCount
kUnknownBitCount
true
}
;
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
)
{
bool
supportsPackedDS
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_packed_depth_stencil
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
;
fStencilFormats
.
push_back
(
)
=
gS8
;
fStencilFormats
.
push_back
(
)
=
gS16
;
if
(
supportsPackedDS
)
{
fStencilFormats
.
push_back
(
)
=
gD24S8
;
}
fStencilFormats
.
push_back
(
)
=
gS4
;
if
(
supportsPackedDS
)
{
fStencilFormats
.
push_back
(
)
=
gDS
;
}
}
else
{
fStencilFormats
.
push_back
(
)
=
gS8
;
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_packed_depth_stencil
"
)
)
{
fStencilFormats
.
push_back
(
)
=
gD24S8
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_stencil4
"
)
)
{
fStencilFormats
.
push_back
(
)
=
gS4
;
}
}
}
void
GrGLCaps
:
:
onDumpJSON
(
SkJSONWriter
*
writer
)
const
{
writer
-
>
beginObject
(
"
GL
caps
"
)
;
writer
-
>
beginArray
(
"
Stencil
Formats
"
)
;
for
(
int
i
=
0
;
i
<
fStencilFormats
.
count
(
)
;
+
+
i
)
{
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendS32
(
"
stencil
bits
"
fStencilFormats
[
i
]
.
fStencilBits
)
;
writer
-
>
appendS32
(
"
total
bits
"
fStencilFormats
[
i
]
.
fTotalBits
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
static
const
char
*
kMSFBOExtStr
[
]
=
{
"
None
"
"
Standard
"
"
Apple
"
"
IMG
MS
To
Texture
"
"
EXT
MS
To
Texture
"
"
MixedSamples
"
}
;
GR_STATIC_ASSERT
(
0
=
=
kNone_MSFBOType
)
;
GR_STATIC_ASSERT
(
1
=
=
kStandard_MSFBOType
)
;
GR_STATIC_ASSERT
(
2
=
=
kES_Apple_MSFBOType
)
;
GR_STATIC_ASSERT
(
3
=
=
kES_IMG_MsToTexture_MSFBOType
)
;
GR_STATIC_ASSERT
(
4
=
=
kES_EXT_MsToTexture_MSFBOType
)
;
GR_STATIC_ASSERT
(
5
=
=
kMixedSamples_MSFBOType
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
kMSFBOExtStr
)
=
=
kLast_MSFBOType
+
1
)
;
static
const
char
*
kInvalidateFBTypeStr
[
]
=
{
"
None
"
"
Discard
"
"
Invalidate
"
}
;
GR_STATIC_ASSERT
(
0
=
=
kNone_InvalidateFBType
)
;
GR_STATIC_ASSERT
(
1
=
=
kDiscard_InvalidateFBType
)
;
GR_STATIC_ASSERT
(
2
=
=
kInvalidate_InvalidateFBType
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
kInvalidateFBTypeStr
)
=
=
kLast_InvalidateFBType
+
1
)
;
static
const
char
*
kMapBufferTypeStr
[
]
=
{
"
None
"
"
MapBuffer
"
"
MapBufferRange
"
"
Chromium
"
}
;
GR_STATIC_ASSERT
(
0
=
=
kNone_MapBufferType
)
;
GR_STATIC_ASSERT
(
1
=
=
kMapBuffer_MapBufferType
)
;
GR_STATIC_ASSERT
(
2
=
=
kMapBufferRange_MapBufferType
)
;
GR_STATIC_ASSERT
(
3
=
=
kChromium_MapBufferType
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
kMapBufferTypeStr
)
=
=
kLast_MapBufferType
+
1
)
;
writer
-
>
appendBool
(
"
Core
Profile
"
fIsCoreProfile
)
;
writer
-
>
appendString
(
"
MSAA
Type
"
kMSFBOExtStr
[
fMSFBOType
]
)
;
writer
-
>
appendString
(
"
Invalidate
FB
Type
"
kInvalidateFBTypeStr
[
fInvalidateFBType
]
)
;
writer
-
>
appendString
(
"
Map
Buffer
Type
"
kMapBufferTypeStr
[
fMapBufferType
]
)
;
writer
-
>
appendS32
(
"
Max
FS
Uniform
Vectors
"
fMaxFragmentUniformVectors
)
;
writer
-
>
appendBool
(
"
Unpack
Row
length
support
"
fUnpackRowLengthSupport
)
;
writer
-
>
appendBool
(
"
Unpack
Flip
Y
support
"
fUnpackFlipYSupport
)
;
writer
-
>
appendBool
(
"
Pack
Row
length
support
"
fPackRowLengthSupport
)
;
writer
-
>
appendBool
(
"
Pack
Flip
Y
support
"
fPackFlipYSupport
)
;
writer
-
>
appendBool
(
"
Texture
Usage
support
"
fTextureUsageSupport
)
;
writer
-
>
appendBool
(
"
Alpha8
is
renderable
"
fAlpha8IsRenderable
)
;
writer
-
>
appendBool
(
"
GL_ARB_imaging
support
"
fImagingSupport
)
;
writer
-
>
appendBool
(
"
Vertex
array
object
support
"
fVertexArrayObjectSupport
)
;
writer
-
>
appendBool
(
"
Debug
support
"
fDebugSupport
)
;
writer
-
>
appendBool
(
"
Draw
indirect
support
"
fDrawIndirectSupport
)
;
writer
-
>
appendBool
(
"
Multi
draw
indirect
support
"
fMultiDrawIndirectSupport
)
;
writer
-
>
appendBool
(
"
Base
instance
support
"
fBaseInstanceSupport
)
;
writer
-
>
appendBool
(
"
RGBA
8888
pixel
ops
are
slow
"
fRGBA8888PixelsOpsAreSlow
)
;
writer
-
>
appendBool
(
"
Partial
FBO
read
is
slow
"
fPartialFBOReadIsSlow
)
;
writer
-
>
appendBool
(
"
Bind
uniform
location
support
"
fBindUniformLocationSupport
)
;
writer
-
>
appendBool
(
"
Rectangle
texture
support
"
fRectangleTextureSupport
)
;
writer
-
>
appendBool
(
"
Texture
swizzle
support
"
fTextureSwizzleSupport
)
;
writer
-
>
appendBool
(
"
BGRA
to
RGBA
readback
conversions
are
slow
"
fRGBAToBGRAReadbackConversionsAreSlow
)
;
writer
-
>
appendBool
(
"
Draw
To
clear
color
"
fUseDrawToClearColor
)
;
writer
-
>
appendBool
(
"
Draw
To
clear
stencil
clip
"
fUseDrawToClearStencilClip
)
;
writer
-
>
appendBool
(
"
Intermediate
texture
for
partial
updates
of
unorm
textures
ever
bound
to
FBOs
"
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
;
writer
-
>
appendBool
(
"
Intermediate
texture
for
all
updates
of
textures
bound
to
FBOs
"
fUseDrawInsteadOfAllRenderTargetWrites
)
;
writer
-
>
appendBool
(
"
Max
instances
per
glDrawArraysInstanced
without
crashing
(
or
zero
)
"
fMaxInstancesPerDrawArraysWithoutCrashing
)
;
writer
-
>
beginArray
(
"
configs
"
)
;
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendHexU32
(
"
flags
"
fConfigTable
[
i
]
.
fFlags
)
;
writer
-
>
appendHexU32
(
"
b_internal
"
fConfigTable
[
i
]
.
fFormats
.
fBaseInternalFormat
)
;
writer
-
>
appendHexU32
(
"
s_internal
"
fConfigTable
[
i
]
.
fFormats
.
fSizedInternalFormat
)
;
writer
-
>
appendHexU32
(
"
e_format
"
fConfigTable
[
i
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
)
;
writer
-
>
appendHexU32
(
"
e_format_teximage
"
fConfigTable
[
i
]
.
fFormats
.
fExternalFormat
[
kTexImage_ExternalFormatUsage
]
)
;
writer
-
>
appendHexU32
(
"
e_type
"
fConfigTable
[
i
]
.
fFormats
.
fExternalType
)
;
writer
-
>
appendHexU32
(
"
i_for_teximage
"
fConfigTable
[
i
]
.
fFormats
.
fInternalFormatTexImage
)
;
writer
-
>
appendHexU32
(
"
i_for_renderbuffer
"
fConfigTable
[
i
]
.
fFormats
.
fInternalFormatRenderbuffer
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
writer
-
>
endObject
(
)
;
}
bool
GrGLCaps
:
:
bgraIsInternalFormat
(
)
const
{
return
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
=
GR_GL_BGRA
;
}
bool
GrGLCaps
:
:
getTexImageFormats
(
GrPixelConfig
surfaceConfig
GrPixelConfig
externalConfig
GrGLenum
*
internalFormat
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
if
(
!
this
-
>
getExternalFormat
(
surfaceConfig
externalConfig
kTexImage_ExternalFormatUsage
externalFormat
externalType
)
)
{
return
false
;
}
*
internalFormat
=
fConfigTable
[
surfaceConfig
]
.
fFormats
.
fInternalFormatTexImage
;
return
true
;
}
bool
GrGLCaps
:
:
getReadPixelsFormat
(
GrPixelConfig
surfaceConfig
GrPixelConfig
externalConfig
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
if
(
!
this
-
>
getExternalFormat
(
surfaceConfig
externalConfig
kOther_ExternalFormatUsage
externalFormat
externalType
)
)
{
return
false
;
}
return
true
;
}
bool
GrGLCaps
:
:
getRenderbufferFormat
(
GrPixelConfig
config
GrGLenum
*
internalFormat
)
const
{
*
internalFormat
=
fConfigTable
[
config
]
.
fFormats
.
fInternalFormatRenderbuffer
;
return
true
;
}
bool
GrGLCaps
:
:
getExternalFormat
(
GrPixelConfig
surfaceConfig
GrPixelConfig
memoryConfig
ExternalFormatUsage
usage
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
SkASSERT
(
externalFormat
&
&
externalType
)
;
bool
surfaceIsAlphaOnly
=
GrPixelConfigIsAlphaOnly
(
surfaceConfig
)
;
bool
memoryIsAlphaOnly
=
GrPixelConfigIsAlphaOnly
(
memoryConfig
)
;
if
(
surfaceIsAlphaOnly
&
&
!
memoryIsAlphaOnly
)
{
return
false
;
}
*
externalFormat
=
fConfigTable
[
memoryConfig
]
.
fFormats
.
fExternalFormat
[
usage
]
;
*
externalType
=
fConfigTable
[
memoryConfig
]
.
fFormats
.
fExternalType
;
if
(
memoryIsAlphaOnly
&
&
!
surfaceIsAlphaOnly
)
{
if
(
GR_GL_RED
=
=
*
externalFormat
)
{
*
externalFormat
=
GR_GL_ALPHA
;
}
}
return
true
;
}
void
GrGLCaps
:
:
initConfigTable
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
GrShaderCaps
*
shaderCaps
)
{
bool
disableTextureRedForMesa
=
false
;
bool
disableSRGBForX86PowerVR
=
false
;
bool
disableSRGBWriteControlForAdreno4xx
=
false
;
bool
disableR8TexStorageForANGLEGL
=
false
;
bool
disableSRGBRenderWithMSAAForMacAMD
=
false
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
disableTextureRedForMesa
=
kOSMesa_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
;
bool
isX86PowerVR
=
false
;
#
if
defined
(
SK_CPU_X86
)
if
(
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
isX86PowerVR
=
true
;
}
#
endif
disableSRGBForX86PowerVR
=
isX86PowerVR
;
disableSRGBWriteControlForAdreno4xx
=
kAdreno4xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
;
disableR8TexStorageForANGLEGL
=
GrGLANGLEBackend
:
:
kOpenGL
=
=
ctxInfo
.
angleBackend
(
)
;
#
if
defined
(
SK_BUILD_FOR_MAC
)
disableSRGBRenderWithMSAAForMacAMD
=
kATI_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
;
#
endif
}
uint32_t
nonMSAARenderFlags
=
ConfigInfo
:
:
kRenderable_Flag
|
ConfigInfo
:
:
kFBOColorAttachment_Flag
;
uint32_t
allRenderFlags
=
nonMSAARenderFlags
;
if
(
kNone_MSFBOType
!
=
fMSFBOType
)
{
allRenderFlags
|
=
ConfigInfo
:
:
kRenderableWithMSAA_Flag
;
}
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
bool
texStorageSupported
=
false
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
texStorageSupported
=
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_storage
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
else
{
texStorageSupported
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
bool
texelBufferSupport
=
this
-
>
shaderCaps
(
)
-
>
texelBufferSupport
(
)
;
bool
textureRedSupport
=
false
;
if
(
!
disableTextureRedForMesa
)
{
if
(
kGL_GrGLStandard
=
=
standard
)
{
textureRedSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
;
}
else
{
textureRedSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_rg
"
)
;
}
}
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
0
;
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
0
;
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
0
;
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fFormats
.
fExternalType
=
0
;
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
fConfigTable
[
kUnknown_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RGBA
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGBA8
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RGBA
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
else
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_rgb8_rgba8
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARM_rgba8
"
)
)
{
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
}
if
(
texStorageSupported
)
{
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
texelBufferSupport
)
{
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
fConfigTable
[
kRGBA_8888_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_BGRA
;
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
bool
supportsBGRATexStorage
=
false
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RGBA
;
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGBA8
;
if
(
version
>
=
GR_GL_VER
(
1
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_bgra
"
)
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
|
allRenderFlags
;
}
supportsBGRATexStorage
=
true
;
}
else
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_BGRA
;
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_BGRA8
;
if
(
ctxInfo
.
hasExtension
(
"
GL_APPLE_texture_format_BGRA8888
"
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
supportsBGRATexStorage
=
true
;
}
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_format_BGRA8888
"
)
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
|
nonMSAARenderFlags
;
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
)
{
supportsBGRATexStorage
=
true
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_renderbuffer_format_BGRA8888
"
)
&
&
(
this
-
>
usesMSAARenderBuffers
(
)
|
|
this
-
>
fMSFBOType
=
=
kMixedSamples_MSFBOType
)
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kRenderableWithMSAA_Flag
;
}
}
}
if
(
texStorageSupported
&
&
supportsBGRATexStorage
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
fSRGBSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_sRGB
"
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_sRGB
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_sRGB
"
)
)
{
fSRGBSupport
=
true
;
}
}
if
(
fSRGBSupport
)
{
fSRGBWriteControl
=
true
;
}
}
else
{
fSRGBSupport
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_sRGB
"
)
;
if
(
disableSRGBForX86PowerVR
)
{
fSRGBSupport
=
false
;
}
fSRGBWriteControl
=
!
disableSRGBWriteControlForAdreno4xx
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_sRGB_write_control
"
)
;
}
if
(
contextOptions
.
fRequireDecodeDisableForSRGB
&
&
!
fSRGBDecodeDisableSupport
)
{
fSRGBSupport
=
false
;
}
if
(
kSkia8888_GrPixelConfig
=
=
kBGRA_8888_GrPixelConfig
&
&
kGLES_GrGLStandard
=
=
standard
)
{
fSRGBSupport
=
false
;
}
bool
isCommandBufferES2
=
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
&
&
version
<
GR_GL_VER
(
3
0
)
;
uint32_t
srgbRenderFlags
=
allRenderFlags
;
if
(
disableSRGBRenderWithMSAAForMacAMD
)
{
srgbRenderFlags
&
=
~
ConfigInfo
:
:
kRenderableWithMSAA_Flag
;
}
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_SRGB_ALPHA
;
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_SRGB8_ALPHA8
;
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RGBA
;
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
if
(
fSRGBSupport
)
{
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
|
srgbRenderFlags
;
}
if
(
texStorageSupported
&
&
!
isCommandBufferES2
)
{
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_SRGB_ALPHA
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_SRGB8_ALPHA8
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_BGRA
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
if
(
fSRGBSupport
&
&
kGL_GrGLStandard
=
=
standard
)
{
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
|
srgbRenderFlags
;
}
if
(
texStorageSupported
)
{
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RGB
;
if
(
this
-
>
ES2CompatibilitySupport
(
)
)
{
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGB565
;
}
else
{
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGB5
;
}
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RGB
;
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_SHORT_5_6_5
;
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
)
{
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
}
else
{
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
if
(
texStorageSupported
&
&
kGL_GrGLStandard
!
=
standard
)
{
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
fConfigTable
[
kRGB_565_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RGBA
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGBA4
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RGBA
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_SHORT_4_4_4_4
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
4
2
)
)
{
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
}
else
{
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
if
(
texStorageSupported
)
{
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
fConfigTable
[
kRGBA_4444_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
bool
alpha8IsValidForGL
=
kGL_GrGLStandard
=
=
standard
&
&
(
!
fIsCoreProfile
|
|
version
<
=
GR_GL_VER
(
3
0
)
)
;
ConfigInfo
&
alphaInfo
=
fConfigTable
[
kAlpha_8_as_Alpha_GrPixelConfig
]
;
alphaInfo
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
alphaInfo
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
if
(
alpha8IsValidForGL
|
|
(
kGL_GrGLStandard
!
=
standard
&
&
version
<
GR_GL_VER
(
3
0
)
)
)
{
alphaInfo
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
}
alphaInfo
.
fFormats
.
fBaseInternalFormat
=
GR_GL_ALPHA
;
alphaInfo
.
fFormats
.
fSizedInternalFormat
=
GR_GL_ALPHA8
;
alphaInfo
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_ALPHA
;
alphaInfo
.
fSwizzle
=
GrSwizzle
:
:
AAAA
(
)
;
if
(
fAlpha8IsRenderable
&
&
alpha8IsValidForGL
)
{
alphaInfo
.
fFlags
|
=
allRenderFlags
;
}
ConfigInfo
&
redInfo
=
fConfigTable
[
kAlpha_8_as_Red_GrPixelConfig
]
;
redInfo
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
redInfo
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
redInfo
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RED
;
redInfo
.
fFormats
.
fSizedInternalFormat
=
GR_GL_R8
;
redInfo
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RED
;
redInfo
.
fSwizzle
=
GrSwizzle
:
:
RRRR
(
)
;
if
(
texStorageSupported
&
&
!
isCommandBufferES2
)
{
if
(
!
disableR8TexStorageForANGLEGL
)
{
alphaInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
redInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
textureRedSupport
)
{
redInfo
.
fFlags
|
=
ConfigInfo
:
:
kTextureable_Flag
|
allRenderFlags
;
if
(
texelBufferSupport
)
{
redInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
fConfigTable
[
kAlpha_8_GrPixelConfig
]
=
redInfo
;
}
else
{
redInfo
.
fFlags
=
0
;
fConfigTable
[
kAlpha_8_GrPixelConfig
]
=
alphaInfo
;
}
ConfigInfo
&
grayLumInfo
=
fConfigTable
[
kGray_8_as_Lum_GrPixelConfig
]
;
grayLumInfo
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
grayLumInfo
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
grayLumInfo
.
fFormats
.
fBaseInternalFormat
=
GR_GL_LUMINANCE
;
grayLumInfo
.
fFormats
.
fSizedInternalFormat
=
GR_GL_LUMINANCE8
;
grayLumInfo
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_LUMINANCE
;
grayLumInfo
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
if
(
(
standard
=
=
kGL_GrGLStandard
&
&
version
<
=
GR_GL_VER
(
3
0
)
)
|
|
(
standard
=
=
kGLES_GrGLStandard
&
&
version
<
GR_GL_VER
(
3
0
)
)
)
{
grayLumInfo
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
}
ConfigInfo
&
grayRedInfo
=
fConfigTable
[
kGray_8_as_Red_GrPixelConfig
]
;
grayRedInfo
.
fFormats
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
grayRedInfo
.
fFormatType
=
kNormalizedFixedPoint_FormatType
;
grayRedInfo
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RED
;
grayRedInfo
.
fFormats
.
fSizedInternalFormat
=
GR_GL_R8
;
grayRedInfo
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RED
;
grayRedInfo
.
fSwizzle
=
GrSwizzle
:
:
RRRA
(
)
;
grayRedInfo
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
#
if
0
if
(
this
-
>
textureRedSupport
(
)
|
|
(
kDesktop_ARB_MSFBOType
=
=
this
-
>
msFBOType
(
)
&
&
ctxInfo
.
renderer
(
)
!
=
kOSMesa_GrGLRenderer
)
)
{
fConfigTable
[
kGray_8_GrPixelConfig
]
.
fFlags
|
=
allRenderFlags
;
}
#
endif
if
(
texStorageSupported
&
&
!
isCommandBufferES2
)
{
if
(
!
disableR8TexStorageForANGLEGL
)
{
grayLumInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
grayRedInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
textureRedSupport
)
{
if
(
texelBufferSupport
)
{
grayRedInfo
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
fConfigTable
[
kGray_8_GrPixelConfig
]
=
grayRedInfo
;
}
else
{
grayRedInfo
.
fFlags
=
0
;
fConfigTable
[
kGray_8_GrPixelConfig
]
=
grayLumInfo
;
}
bool
hasFPTextures
=
false
;
bool
hasHalfFPTextures
=
false
;
bool
rgIsTexturable
=
false
;
uint32_t
fpRenderFlags
=
(
kGL_GrGLStandard
=
=
standard
)
?
allRenderFlags
:
nonMSAARenderFlags
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
hasFPTextures
=
true
;
hasHalfFPTextures
=
true
;
rgIsTexturable
=
true
;
}
}
else
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
hasFPTextures
=
true
;
hasHalfFPTextures
=
true
;
rgIsTexturable
=
true
;
}
else
{
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_float_linear
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_OES_texture_float
"
)
)
{
hasFPTextures
=
true
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float_linear
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float
"
)
)
{
hasHalfFPTextures
=
true
;
}
}
}
for
(
auto
fpconfig
:
{
kRGBA_float_GrPixelConfig
kRG_float_GrPixelConfig
}
)
{
const
GrGLenum
format
=
kRGBA_float_GrPixelConfig
=
=
fpconfig
?
GR_GL_RGBA
:
GR_GL_RG
;
fConfigTable
[
fpconfig
]
.
fFormats
.
fBaseInternalFormat
=
format
;
fConfigTable
[
fpconfig
]
.
fFormats
.
fSizedInternalFormat
=
kRGBA_float_GrPixelConfig
=
=
fpconfig
?
GR_GL_RGBA32F
:
GR_GL_RG32F
;
fConfigTable
[
fpconfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
format
;
fConfigTable
[
fpconfig
]
.
fFormats
.
fExternalType
=
GR_GL_FLOAT
;
fConfigTable
[
fpconfig
]
.
fFormatType
=
kFloat_FormatType
;
if
(
hasFPTextures
)
{
fConfigTable
[
fpconfig
]
.
fFlags
=
rgIsTexturable
?
ConfigInfo
:
:
kTextureable_Flag
:
0
;
if
(
kGL_GrGLStandard
=
=
standard
)
{
fConfigTable
[
fpconfig
]
.
fFlags
|
=
fpRenderFlags
;
}
}
if
(
texStorageSupported
)
{
fConfigTable
[
fpconfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
texelBufferSupport
)
{
fConfigTable
[
fpconfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
fConfigTable
[
fpconfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
}
GrGLenum
redHalfExternalType
;
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
|
|
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
redHalfExternalType
=
GR_GL_HALF_FLOAT
;
}
else
{
redHalfExternalType
=
GR_GL_HALF_FLOAT_OES
;
}
ConfigInfo
&
redHalf
=
fConfigTable
[
kAlpha_half_as_Red_GrPixelConfig
]
;
redHalf
.
fFormats
.
fExternalType
=
redHalfExternalType
;
redHalf
.
fFormatType
=
kFloat_FormatType
;
redHalf
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RED
;
redHalf
.
fFormats
.
fSizedInternalFormat
=
GR_GL_R16F
;
redHalf
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RED
;
redHalf
.
fSwizzle
=
GrSwizzle
:
:
RRRR
(
)
;
if
(
textureRedSupport
&
&
hasHalfFPTextures
)
{
redHalf
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
if
(
kGL_GrGLStandard
=
=
standard
|
|
version
>
=
GR_GL_VER
(
3
2
)
|
|
(
textureRedSupport
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
)
)
{
redHalf
.
fFlags
|
=
fpRenderFlags
;
}
if
(
texStorageSupported
&
&
!
isCommandBufferES2
)
{
redHalf
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
texelBufferSupport
)
{
redHalf
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
}
fConfigTable
[
kAlpha_half_GrPixelConfig
]
=
redHalf
;
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
GR_GL_RGBA
;
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormats
.
fSizedInternalFormat
=
GR_GL_RGBA16F
;
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
=
GR_GL_RGBA
;
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
|
|
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_HALF_FLOAT
;
}
else
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormats
.
fExternalType
=
GR_GL_HALF_FLOAT_OES
;
}
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFormatType
=
kFloat_FormatType
;
if
(
hasHalfFPTextures
)
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFlags
=
ConfigInfo
:
:
kTextureable_Flag
;
if
(
kGL_GrGLStandard
=
=
standard
|
|
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
)
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFlags
|
=
fpRenderFlags
;
}
}
if
(
texStorageSupported
)
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseTexStorage_Flag
;
}
if
(
texelBufferSupport
)
{
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fFlags
|
=
ConfigInfo
:
:
kCanUseWithTexelBuffer_Flag
;
}
fConfigTable
[
kRGBA_half_GrPixelConfig
]
.
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
bool
useSizedTexFormats
=
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
|
|
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
;
bool
useSizedRbFormats
=
kGLES_GrGLStandard
=
=
ctxInfo
.
standard
(
)
;
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
fConfigTable
[
i
]
.
fFormats
.
fExternalFormat
[
kTexImage_ExternalFormatUsage
]
=
fConfigTable
[
i
]
.
fFormats
.
fExternalFormat
[
kOther_ExternalFormatUsage
]
;
fConfigTable
[
i
]
.
fFormats
.
fInternalFormatTexImage
=
useSizedTexFormats
?
fConfigTable
[
i
]
.
fFormats
.
fSizedInternalFormat
:
fConfigTable
[
i
]
.
fFormats
.
fBaseInternalFormat
;
fConfigTable
[
i
]
.
fFormats
.
fInternalFormatRenderbuffer
=
useSizedRbFormats
?
fConfigTable
[
i
]
.
fFormats
.
fSizedInternalFormat
:
fConfigTable
[
i
]
.
fFormats
.
fBaseInternalFormat
;
}
if
(
useSizedTexFormats
&
&
kGLES_GrGLStandard
=
=
ctxInfo
.
standard
(
)
&
&
!
textureRedSupport
)
{
SkASSERT
(
fConfigTable
[
kAlpha_8_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
=
GR_GL_ALPHA8
)
;
SkASSERT
(
fConfigTable
[
kAlpha_8_as_Alpha_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
=
=
GR_GL_ALPHA8
)
;
fConfigTable
[
kAlpha_8_GrPixelConfig
]
.
fFormats
.
fInternalFormatTexImage
=
fConfigTable
[
kAlpha_8_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
;
fConfigTable
[
kAlpha_8_as_Alpha_GrPixelConfig
]
.
fFormats
.
fInternalFormatTexImage
=
fConfigTable
[
kAlpha_8_as_Alpha_GrPixelConfig
]
.
fFormats
.
fBaseInternalFormat
;
}
if
(
ctxInfo
.
standard
(
)
=
=
kGLES_GrGLStandard
&
&
ctxInfo
.
version
(
)
=
=
GR_GL_VER
(
2
0
)
)
{
fConfigTable
[
kSRGBA_8888_GrPixelConfig
]
.
fFormats
.
fExternalFormat
[
kTexImage_ExternalFormatUsage
]
=
GR_GL_SRGB_ALPHA
;
fConfigTable
[
kSBGRA_8888_GrPixelConfig
]
.
fFlags
=
0
;
}
if
(
useSizedTexFormats
&
&
this
-
>
bgraIsInternalFormat
(
)
)
{
fConfigTable
[
kBGRA_8888_GrPixelConfig
]
.
fFormats
.
fInternalFormatTexImage
=
GR_GL_BGRA
;
}
if
(
!
this
-
>
textureSwizzleSupport
(
)
)
{
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
fConfigTable
[
i
]
.
fSwizzle
;
}
}
if
(
textureRedSupport
)
{
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
GrPixelConfig
config
=
static_cast
<
GrPixelConfig
>
(
i
)
;
if
(
GrPixelConfigIsAlphaOnly
(
config
)
&
&
fConfigTable
[
i
]
.
fFormats
.
fBaseInternalFormat
=
=
GR_GL_RED
)
{
shaderCaps
-
>
fConfigOutputSwizzle
[
i
]
=
GrSwizzle
:
:
AAAA
(
)
;
}
}
}
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
if
(
ConfigInfo
:
:
kRenderableWithMSAA_Flag
&
fConfigTable
[
i
]
.
fFlags
)
{
SkASSERT
(
ConfigInfo
:
:
kRenderable_Flag
&
fConfigTable
[
i
]
.
fFlags
)
;
if
(
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
&
&
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_internalformat_query
"
)
)
)
|
|
(
kGLES_GrGLStandard
=
=
ctxInfo
.
standard
(
)
&
&
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
)
{
int
count
;
GrGLenum
format
=
fConfigTable
[
i
]
.
fFormats
.
fInternalFormatRenderbuffer
;
GR_GL_GetInternalformativ
(
gli
GR_GL_RENDERBUFFER
format
GR_GL_NUM_SAMPLE_COUNTS
1
&
count
)
;
if
(
count
)
{
int
*
temp
=
new
int
[
count
]
;
GR_GL_GetInternalformativ
(
gli
GR_GL_RENDERBUFFER
format
GR_GL_SAMPLES
count
temp
)
;
if
(
count
&
&
temp
[
count
-
1
]
=
=
1
)
{
-
-
count
;
SkASSERT
(
!
count
|
|
temp
[
count
-
1
]
>
1
)
;
}
fConfigTable
[
i
]
.
fColorSampleCounts
.
setCount
(
count
+
1
)
;
fConfigTable
[
i
]
.
fColorSampleCounts
[
0
]
=
1
;
for
(
int
j
=
0
;
j
<
count
;
+
+
j
)
{
fConfigTable
[
i
]
.
fColorSampleCounts
[
j
+
1
]
=
temp
[
count
-
j
-
1
]
;
}
delete
[
]
temp
;
}
}
else
{
int
maxSampleCnt
=
1
;
if
(
GrGLCaps
:
:
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_SAMPLES_IMG
&
maxSampleCnt
)
;
}
else
if
(
GrGLCaps
:
:
kNone_MSFBOType
!
=
fMSFBOType
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_SAMPLES
&
maxSampleCnt
)
;
}
maxSampleCnt
=
SkTMax
(
1
maxSampleCnt
)
;
static
constexpr
int
kDefaultSamples
[
]
=
{
1
2
4
8
}
;
int
count
=
SK_ARRAY_COUNT
(
kDefaultSamples
)
;
for
(
;
count
>
0
;
-
-
count
)
{
if
(
kDefaultSamples
[
count
-
1
]
<
=
maxSampleCnt
)
{
break
;
}
}
if
(
count
>
0
)
{
fConfigTable
[
i
]
.
fColorSampleCounts
.
append
(
count
kDefaultSamples
)
;
}
}
}
else
if
(
ConfigInfo
:
:
kRenderable_Flag
&
fConfigTable
[
i
]
.
fFlags
)
{
fConfigTable
[
i
]
.
fColorSampleCounts
.
setCount
(
1
)
;
fConfigTable
[
i
]
.
fColorSampleCounts
[
0
]
=
1
;
}
}
#
ifdef
SK_DEBUG
ConfigInfo
defaultEntry
;
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
SkASSERT
(
!
(
(
ConfigInfo
:
:
kRenderable_Flag
)
&
&
!
(
ConfigInfo
:
:
kFBOColorAttachment_Flag
)
)
)
;
SkASSERT
(
!
(
(
ConfigInfo
:
:
kRenderableWithMSAA_Flag
)
&
&
!
(
ConfigInfo
:
:
kRenderable_Flag
)
)
)
;
SkASSERT
(
defaultEntry
.
fFormats
.
fBaseInternalFormat
!
=
fConfigTable
[
i
]
.
fFormats
.
fBaseInternalFormat
)
;
SkASSERT
(
defaultEntry
.
fFormats
.
fSizedInternalFormat
!
=
fConfigTable
[
i
]
.
fFormats
.
fSizedInternalFormat
)
;
for
(
int
j
=
0
;
j
<
kExternalFormatUsageCnt
;
+
+
j
)
{
SkASSERT
(
defaultEntry
.
fFormats
.
fExternalFormat
[
j
]
!
=
fConfigTable
[
i
]
.
fFormats
.
fExternalFormat
[
j
]
)
;
}
SkASSERT
(
defaultEntry
.
fFormats
.
fExternalType
!
=
fConfigTable
[
i
]
.
fFormats
.
fExternalType
)
;
}
#
endif
}
bool
GrGLCaps
:
:
initDescForDstCopy
(
const
GrRenderTargetProxy
*
src
GrSurfaceDesc
*
desc
bool
*
rectsMustMatch
bool
*
disallowSubrect
)
const
{
*
rectsMustMatch
=
false
;
*
disallowSubrect
=
false
;
if
(
src
-
>
asTextureProxy
(
)
&
&
!
this
-
>
isConfigRenderable
(
src
-
>
config
(
)
)
)
{
desc
-
>
fOrigin
=
kBottomLeft_GrSurfaceOrigin
;
desc
-
>
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
-
>
fConfig
=
src
-
>
config
(
)
;
return
true
;
}
{
const
GrTexture
*
srcTexture
=
src
-
>
priv
(
)
.
peekTexture
(
)
;
const
GrGLTexture
*
glSrcTexture
=
static_cast
<
const
GrGLTexture
*
>
(
srcTexture
)
;
if
(
glSrcTexture
&
&
glSrcTexture
-
>
target
(
)
!
=
GR_GL_TEXTURE_2D
)
{
return
false
;
}
}
GrSurfaceOrigin
originForBlitFramebuffer
=
kTopLeft_GrSurfaceOrigin
;
bool
rectsMustMatchForBlitFramebuffer
=
false
;
bool
disallowSubrectForBlitFramebuffer
=
false
;
if
(
src
-
>
numColorSamples
(
)
>
1
&
&
(
this
-
>
blitFramebufferSupportFlags
(
)
&
kResolveMustBeFull_BlitFrambufferFlag
)
)
{
rectsMustMatchForBlitFramebuffer
=
true
;
disallowSubrectForBlitFramebuffer
=
true
;
originForBlitFramebuffer
=
src
-
>
origin
(
)
;
}
else
if
(
src
-
>
numColorSamples
(
)
>
1
&
&
(
this
-
>
blitFramebufferSupportFlags
(
)
&
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
)
)
{
rectsMustMatchForBlitFramebuffer
=
true
;
originForBlitFramebuffer
=
src
-
>
origin
(
)
;
}
else
if
(
this
-
>
blitFramebufferSupportFlags
(
)
&
kNoScalingOrMirroring_BlitFramebufferFlag
)
{
originForBlitFramebuffer
=
src
-
>
origin
(
)
;
}
if
(
this
-
>
bgraIsInternalFormat
(
)
&
&
kBGRA_8888_GrPixelConfig
=
=
src
-
>
config
(
)
)
{
if
(
this
-
>
canConfigBeFBOColorAttachment
(
kBGRA_8888_GrPixelConfig
)
)
{
desc
-
>
fOrigin
=
originForBlitFramebuffer
;
desc
-
>
fConfig
=
kBGRA_8888_GrPixelConfig
;
*
rectsMustMatch
=
rectsMustMatchForBlitFramebuffer
;
*
disallowSubrect
=
disallowSubrectForBlitFramebuffer
;
return
true
;
}
return
false
;
}
{
bool
srcIsMSAARenderbuffer
=
GrFSAAType
:
:
kUnifiedMSAA
=
=
src
-
>
fsaaType
(
)
&
&
this
-
>
usesMSAARenderBuffers
(
)
;
if
(
srcIsMSAARenderbuffer
)
{
if
(
this
-
>
canConfigBeFBOColorAttachment
(
src
-
>
config
(
)
)
)
{
desc
-
>
fOrigin
=
originForBlitFramebuffer
;
desc
-
>
fConfig
=
src
-
>
config
(
)
;
*
rectsMustMatch
=
rectsMustMatchForBlitFramebuffer
;
*
disallowSubrect
=
disallowSubrectForBlitFramebuffer
;
return
true
;
}
return
false
;
}
}
desc
-
>
fConfig
=
src
-
>
config
(
)
;
desc
-
>
fOrigin
=
src
-
>
origin
(
)
;
desc
-
>
fFlags
=
kNone_GrSurfaceFlags
;
return
true
;
}
void
GrGLCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
GrGLContextInfo
&
ctxInfo
const
GrContextOptions
&
contextOptions
GrShaderCaps
*
shaderCaps
)
{
if
(
kAdreno4xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fDiscardRenderTargetSupport
=
false
;
fInvalidateFBType
=
kNone_InvalidateFBType
;
}
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
&
&
ctxInfo
.
driver
(
)
=
=
kNVIDIA_GrGLDriver
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
367
57
)
)
{
fClearTextureSupport
=
false
;
}
if
(
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fClearTextureSupport
=
false
;
}
#
ifdef
SK_BUILD_FOR_MAC
if
(
shaderCaps
-
>
fGeometryShaderSupport
)
{
shaderCaps
-
>
fGSInvocationsSupport
=
false
;
}
#
endif
if
(
kQualcomm_GrGLDriver
=
=
ctxInfo
.
driver
(
)
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
127
0
)
)
{
shaderCaps
-
>
fGeometryShaderSupport
=
false
;
}
#
if
defined
(
__has_feature
)
#
if
defined
(
SK_BUILD_FOR_MAC
)
&
&
__has_feature
(
thread_sanitizer
)
fMapBufferType
=
kNone_MapBufferType
;
fMapBufferFlags
=
kNone_MapFlags
;
#
endif
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
kAdreno3xx_GrGLRenderer
&
&
ctxInfo
.
driverVersion
(
)
>
GR_GL_DRIVER_VER
(
127
0
)
)
{
fMapBufferType
=
kNone_MapBufferType
;
fMapBufferFlags
=
kNone_MapFlags
;
}
if
(
kANGLE_GrGLDriver
=
=
ctxInfo
.
driver
(
)
)
{
fTransferBufferType
=
kNone_TransferBufferType
;
}
if
(
kPowerVR54x_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fMipMapSupport
=
false
;
}
if
(
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fMaxClipAnalyticFPs
=
0
;
}
#
ifndef
SK_BUILD_FOR_IOS
if
(
kPowerVR54x_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
|
|
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
|
|
(
kAdreno3xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
&
&
ctxInfo
.
driver
(
)
!
=
kChromium_GrGLDriver
)
)
{
fUseDrawToClearColor
=
true
;
}
#
endif
if
(
kAMDRadeonHD7xxx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
|
|
kAMDRadeonR9M4xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fUseDrawToClearColor
=
true
;
}
#
ifdef
SK_BUILD_FOR_MAC
if
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fUseDrawToClearColor
=
true
;
}
#
endif
if
(
GrGLANGLEBackend
:
:
kD3D11
=
=
ctxInfo
.
angleBackend
(
)
)
{
fUseDrawToClearColor
=
true
;
}
if
(
kAdreno4xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
if
(
ctxInfo
.
driverVersion
(
)
<
=
GR_GL_DRIVER_VER
(
219
0
)
)
{
fUseDrawToClearStencilClip
=
true
;
}
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
true
;
}
if
(
kAdreno3xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
&
&
ctxInfo
.
driverVersion
(
)
>
GR_GL_DRIVER_VER
(
53
0
)
)
{
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
=
true
;
}
if
(
kPowerVRRogue_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fMaxInstancesPerDrawArraysWithoutCrashing
=
0x7fff
;
}
if
(
kTegra3_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
true
;
fUseDrawInsteadOfAllRenderTargetWrites
=
true
;
}
if
(
kGL_GrGLStandard
=
=
ctxInfo
.
standard
(
)
&
&
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fSampleShadingSupport
=
false
;
}
#
ifdef
SK_BUILD_FOR_MAC
static
constexpr
bool
isMAC
=
true
;
#
else
static
constexpr
bool
isMAC
=
false
;
#
endif
if
(
fMipMapLevelAndLodControlSupport
&
&
(
contextOptions
.
fDoManualMipmapping
|
|
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
|
|
(
kNVIDIA_GrGLDriver
=
=
ctxInfo
.
driver
(
)
&
&
isMAC
)
|
|
(
kATI_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
)
)
{
fDoManualMipmapping
=
true
;
}
#
ifdef
SK_BUILD_FOR_MAC
if
(
kIntel6xxx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
fClearToBoundaryValuesIsBroken
=
true
;
}
#
endif
if
(
kQualcomm_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fDrawArraysBaseVertexIsBroken
=
true
;
}
if
(
kANGLE_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
&
&
GrGLANGLERenderer
:
:
kSkylake
=
=
ctxInfo
.
angleRenderer
(
)
)
{
bool
gsSupport
=
fShaderCaps
-
>
geometryShaderSupport
(
)
;
#
if
GR_TEST_UTILS
gsSupport
&
=
!
contextOptions
.
fSuppressGeometryShaders
;
#
endif
fBlacklistCoverageCounting
=
!
gsSupport
;
}
if
(
kAdreno5xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
shaderCaps
-
>
fFBFetchSupport
=
false
;
}
shaderCaps
-
>
fDropsTileOnZeroDivide
=
kQualcomm_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
;
shaderCaps
-
>
fCanUseAnyFunctionInShader
=
kImagination_GrGLVendor
!
=
ctxInfo
.
vendor
(
)
;
if
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
shaderCaps
-
>
fFragCoordConventionsExtensionString
=
nullptr
;
}
if
(
kTegra3_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
shaderCaps
-
>
fCanUseMinAndAbsTogether
=
false
;
shaderCaps
-
>
fCanUseFractForNegativeValues
=
false
;
}
if
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
shaderCaps
-
>
fMustForceNegatedAtanParamToFloat
=
true
;
}
if
(
kIntel_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
shaderCaps
-
>
fMustDoOpBetweenFloorAndAbs
=
true
;
}
if
(
shaderCaps
-
>
fFBFetchSupport
&
&
kQualcomm_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
shaderCaps
-
>
fRequiresLocalOutputColorForFBFetch
=
true
;
}
if
(
kMaliT_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
shaderCaps
-
>
fMustObfuscateUniformColor
=
true
;
}
#
ifdef
SK_BUILD_FOR_WIN
if
(
kANGLE_GrGLDriver
=
=
ctxInfo
.
driver
(
)
|
|
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
)
{
shaderCaps
-
>
fMustGuardDivisionEvenAfterExplicitZeroCheck
=
true
;
}
#
endif
if
(
kAdreno3xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
)
{
shaderCaps
-
>
fCanUseFragCoord
=
false
;
shaderCaps
-
>
fInterpolantsAreInaccurate
=
true
;
}
if
(
kAdreno4xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
|
|
kAdreno5xx_GrGLRenderer
=
=
ctxInfo
.
renderer
(
)
|
|
kIntel_GrGLDriver
=
=
ctxInfo
.
driver
(
)
|
|
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
)
{
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kNotSupported_AdvBlendEqInteraction
;
}
if
(
kNVIDIA_GrGLDriver
=
=
ctxInfo
.
driver
(
)
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
337
00
)
&
&
kAdvanced_BlendEquationSupport
=
=
fBlendEquationSupport
)
{
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kNotSupported_AdvBlendEqInteraction
;
}
if
(
this
-
>
advancedBlendEquationSupport
(
)
)
{
if
(
kNVIDIA_GrGLDriver
=
=
ctxInfo
.
driver
(
)
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
355
00
)
)
{
fAdvBlendEqBlacklist
|
=
(
1
<
<
kColorDodge_GrBlendEquation
)
|
(
1
<
<
kColorBurn_GrBlendEquation
)
;
}
if
(
kARM_GrGLVendor
=
=
ctxInfo
.
vendor
(
)
)
{
fAdvBlendEqBlacklist
|
=
(
1
<
<
kColorBurn_GrBlendEquation
)
;
}
}
if
(
fMultisampleDisableSupport
&
&
this
-
>
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
&
&
this
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
&
&
fUsesMixedSamples
&
&
#
if
GR_TEST_UTILS
(
contextOptions
.
fGpuPathRenderers
&
GpuPathRenderers
:
:
kStencilAndCover
)
&
&
#
endif
(
kNVIDIA_GrGLDriver
=
=
ctxInfo
.
driver
(
)
|
|
kChromium_GrGLDriver
=
=
ctxInfo
.
driver
(
)
)
)
{
fDiscardRenderTargetSupport
=
false
;
fInvalidateFBType
=
kNone_InvalidateFBType
;
}
}
void
GrGLCaps
:
:
onApplyOptionsOverrides
(
const
GrContextOptions
&
options
)
{
if
(
options
.
fDisableDriverCorrectnessWorkarounds
)
{
SkASSERT
(
!
fDoManualMipmapping
)
;
SkASSERT
(
!
fClearToBoundaryValuesIsBroken
)
;
SkASSERT
(
0
=
=
fMaxInstancesPerDrawArraysWithoutCrashing
)
;
SkASSERT
(
!
fDrawArraysBaseVertexIsBroken
)
;
SkASSERT
(
!
fUseDrawToClearColor
)
;
SkASSERT
(
!
fUseDrawToClearStencilClip
)
;
SkASSERT
(
!
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
;
SkASSERT
(
!
fUseDrawInsteadOfAllRenderTargetWrites
)
;
SkASSERT
(
!
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
)
;
}
if
(
GrContextOptions
:
:
Enable
:
:
kNo
=
=
options
.
fUseDrawInsteadOfGLClear
)
{
fUseDrawToClearColor
=
false
;
}
else
if
(
GrContextOptions
:
:
Enable
:
:
kYes
=
=
options
.
fUseDrawInsteadOfGLClear
)
{
fUseDrawToClearColor
=
true
;
}
if
(
options
.
fDoManualMipmapping
)
{
fDoManualMipmapping
=
true
;
}
}
bool
GrGLCaps
:
:
surfaceSupportsWritePixels
(
const
GrSurface
*
surface
)
const
{
if
(
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
{
if
(
auto
tex
=
static_cast
<
const
GrGLTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
if
(
tex
-
>
hasBaseLevelBeenBoundToFBO
(
)
)
{
return
false
;
}
}
}
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
if
(
fUseDrawInsteadOfAllRenderTargetWrites
)
{
return
false
;
}
if
(
rt
-
>
numColorSamples
(
)
>
1
&
&
this
-
>
usesMSAARenderBuffers
(
)
)
{
return
false
;
}
return
SkToBool
(
surface
-
>
asTexture
(
)
)
;
}
return
true
;
}
bool
GrGLCaps
:
:
onIsMixedSamplesSupportedForRT
(
const
GrBackendRenderTarget
&
backendRT
)
const
{
const
GrGLFramebufferInfo
*
fbInfo
=
backendRT
.
getGLFramebufferInfo
(
)
;
SkASSERT
(
fbInfo
)
;
return
fbInfo
-
>
fFBOID
!
=
0
;
}
bool
GrGLCaps
:
:
onIsWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
backendRT
)
const
{
const
GrGLFramebufferInfo
*
fbInfo
=
backendRT
.
getGLFramebufferInfo
(
)
;
SkASSERT
(
fbInfo
)
;
return
fbInfo
-
>
fFBOID
!
=
0
;
}
int
GrGLCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
GrPixelConfig
config
)
const
{
requestedCount
=
SkTMax
(
1
requestedCount
)
;
int
count
=
fConfigTable
[
config
]
.
fColorSampleCounts
.
count
(
)
;
if
(
!
count
)
{
return
0
;
}
if
(
1
=
=
requestedCount
)
{
return
fConfigTable
[
config
]
.
fColorSampleCounts
[
0
]
=
=
1
?
1
:
0
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
fConfigTable
[
config
]
.
fColorSampleCounts
[
i
]
>
=
requestedCount
)
{
return
fConfigTable
[
config
]
.
fColorSampleCounts
[
i
]
;
}
}
return
0
;
}
int
GrGLCaps
:
:
maxRenderTargetSampleCount
(
GrPixelConfig
config
)
const
{
const
auto
&
table
=
fConfigTable
[
config
]
.
fColorSampleCounts
;
if
(
!
table
.
count
(
)
)
{
return
0
;
}
return
table
[
table
.
count
(
)
-
1
]
;
}
bool
validate_sized_format
(
GrGLenum
format
SkColorType
ct
GrPixelConfig
*
config
GrGLStandard
standard
)
{
*
config
=
kUnknown_GrPixelConfig
;
switch
(
ct
)
{
case
kUnknown_SkColorType
:
return
false
;
case
kAlpha_8_SkColorType
:
if
(
GR_GL_ALPHA8
=
=
format
)
{
*
config
=
kAlpha_8_as_Alpha_GrPixelConfig
;
}
else
if
(
GR_GL_R8
=
=
format
)
{
*
config
=
kAlpha_8_as_Red_GrPixelConfig
;
}
break
;
case
kRGB_565_SkColorType
:
if
(
GR_GL_RGB565
=
=
format
)
{
*
config
=
kRGB_565_GrPixelConfig
;
}
break
;
case
kARGB_4444_SkColorType
:
if
(
GR_GL_RGBA4
=
=
format
)
{
*
config
=
kRGBA_4444_GrPixelConfig
;
}
break
;
case
kRGBA_8888_SkColorType
:
if
(
GR_GL_RGBA8
=
=
format
)
{
*
config
=
kRGBA_8888_GrPixelConfig
;
}
else
if
(
GR_GL_SRGB8_ALPHA8
=
=
format
)
{
*
config
=
kSRGBA_8888_GrPixelConfig
;
}
break
;
case
kRGB_888x_SkColorType
:
return
false
;
case
kBGRA_8888_SkColorType
:
if
(
GR_GL_RGBA8
=
=
format
)
{
if
(
kGL_GrGLStandard
=
=
standard
)
{
*
config
=
kBGRA_8888_GrPixelConfig
;
}
}
else
if
(
GR_GL_BGRA8
=
=
format
)
{
if
(
kGLES_GrGLStandard
=
=
standard
)
{
*
config
=
kBGRA_8888_GrPixelConfig
;
}
}
else
if
(
GR_GL_SRGB8_ALPHA8
=
=
format
)
{
*
config
=
kSBGRA_8888_GrPixelConfig
;
}
break
;
case
kRGBA_1010102_SkColorType
:
return
false
;
case
kRGB_101010x_SkColorType
:
return
false
;
case
kGray_8_SkColorType
:
if
(
GR_GL_LUMINANCE8
=
=
format
)
{
*
config
=
kGray_8_as_Lum_GrPixelConfig
;
}
else
if
(
GR_GL_R8
=
=
format
)
{
*
config
=
kGray_8_as_Red_GrPixelConfig
;
}
break
;
case
kRGBA_F16_SkColorType
:
if
(
GR_GL_RGBA16F
=
=
format
)
{
*
config
=
kRGBA_half_GrPixelConfig
;
}
break
;
}
return
kUnknown_GrPixelConfig
!
=
*
config
;
}
bool
GrGLCaps
:
:
validateBackendTexture
(
const
GrBackendTexture
&
tex
SkColorType
ct
GrPixelConfig
*
config
)
const
{
const
GrGLTextureInfo
*
texInfo
=
tex
.
getGLTextureInfo
(
)
;
if
(
!
texInfo
)
{
return
false
;
}
return
validate_sized_format
(
texInfo
-
>
fFormat
ct
config
fStandard
)
;
}
bool
GrGLCaps
:
:
validateBackendRenderTarget
(
const
GrBackendRenderTarget
&
rt
SkColorType
ct
GrPixelConfig
*
config
)
const
{
const
GrGLFramebufferInfo
*
fbInfo
=
rt
.
getGLFramebufferInfo
(
)
;
if
(
!
fbInfo
)
{
return
false
;
}
return
validate_sized_format
(
fbInfo
-
>
fFormat
ct
config
fStandard
)
;
}
bool
GrGLCaps
:
:
getConfigFromBackendFormat
(
const
GrBackendFormat
&
format
SkColorType
ct
GrPixelConfig
*
config
)
const
{
const
GrGLenum
*
glFormat
=
format
.
getGLFormat
(
)
;
if
(
!
glFormat
)
{
return
false
;
}
return
validate_sized_format
(
*
glFormat
ct
config
fStandard
)
;
}
