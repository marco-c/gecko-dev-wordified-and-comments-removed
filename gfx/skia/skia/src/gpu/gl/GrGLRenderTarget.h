#
ifndef
GrGLRenderTarget_DEFINED
#
define
GrGLRenderTarget_DEFINED
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
class
GrGLCaps
;
class
GrGLGpu
;
class
GrGLStencilAttachment
;
class
GrGLRenderTarget
:
public
GrRenderTarget
{
public
:
bool
alwaysClearStencil
(
)
const
override
{
return
0
=
=
fRTFBOID
;
}
enum
{
kUnresolvableFBOID
=
0
}
;
struct
IDs
{
GrGLuint
fRTFBOID
;
GrBackendObjectOwnership
fRTFBOOwnership
;
GrGLuint
fTexFBOID
;
GrGLuint
fMSColorRenderbufferID
;
}
;
static
sk_sp
<
GrGLRenderTarget
>
MakeWrapped
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
GrPixelConfig
int
sampleCount
const
IDs
&
int
stencilBits
)
;
GrGLuint
renderFBOID
(
)
const
{
return
fRTFBOID
;
}
GrGLuint
textureFBOID
(
)
const
{
return
fTexFBOID
;
}
GrBackendRenderTarget
getBackendRenderTarget
(
)
const
override
;
GrBackendFormat
backendFormat
(
)
const
override
;
bool
canAttemptStencilAttachment
(
)
const
override
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
override
;
GrGLFormat
format
(
)
const
{
return
fRTFormat
;
}
protected
:
GrGLRenderTarget
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
GrPixelConfig
int
sampleCount
const
IDs
&
)
;
void
init
(
GrGLFormat
const
IDs
&
)
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
int
numSamplesOwnedPerPixel
(
)
const
{
return
fNumSamplesOwnedPerPixel
;
}
private
:
GrGLRenderTarget
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
GrPixelConfig
int
sampleCount
const
IDs
&
GrGLStencilAttachment
*
)
;
void
setFlags
(
const
GrGLCaps
&
const
IDs
&
)
;
GrGLGpu
*
getGLGpu
(
)
const
;
bool
completeStencilAttachment
(
)
override
;
size_t
onGpuMemorySize
(
)
const
override
;
int
msaaSamples
(
)
const
;
int
totalSamples
(
)
const
;
GrGLuint
fRTFBOID
;
GrGLuint
fTexFBOID
;
GrGLuint
fMSColorRenderbufferID
;
GrGLFormat
fRTFormat
;
GrBackendObjectOwnership
fRTFBOOwnership
;
int
fNumSamplesOwnedPerPixel
;
typedef
GrRenderTarget
INHERITED
;
}
;
#
endif
