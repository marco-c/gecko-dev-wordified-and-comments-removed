#
ifndef
GrGLGpu_DEFINED
#
define
GrGLGpu_DEFINED
#
include
"
GrGLContext
.
h
"
#
include
"
GrGLIRect
.
h
"
#
include
"
GrGLPathRendering
.
h
"
#
include
"
GrGLProgram
.
h
"
#
include
"
GrGLRenderTarget
.
h
"
#
include
"
GrGLStencilAttachment
.
h
"
#
include
"
GrGLTexture
.
h
"
#
include
"
GrGLVertexArray
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTypes
.
h
"
class
GrGLBuffer
;
class
GrPipeline
;
class
GrNonInstancedMesh
;
class
GrSwizzle
;
#
ifdef
SK_DEVELOPER
#
define
PROGRAM_CACHE_STATS
#
endif
class
GrGLGpu
final
:
public
GrGpu
{
public
:
static
GrGpu
*
Create
(
GrBackendContext
backendContext
const
GrContextOptions
&
options
GrContext
*
context
)
;
~
GrGLGpu
(
)
override
;
void
disconnect
(
DisconnectType
)
override
;
const
GrGLContext
&
glContext
(
)
const
{
return
*
fGLContext
;
}
const
GrGLInterface
*
glInterface
(
)
const
{
return
fGLContext
-
>
interface
(
)
;
}
const
GrGLContextInfo
&
ctxInfo
(
)
const
{
return
*
fGLContext
;
}
GrGLStandard
glStandard
(
)
const
{
return
fGLContext
-
>
standard
(
)
;
}
GrGLVersion
glVersion
(
)
const
{
return
fGLContext
-
>
version
(
)
;
}
GrGLSLGeneration
glslGeneration
(
)
const
{
return
fGLContext
-
>
glslGeneration
(
)
;
}
const
GrGLCaps
&
glCaps
(
)
const
{
return
*
fGLContext
-
>
caps
(
)
;
}
GrGLPathRendering
*
glPathRendering
(
)
{
SkASSERT
(
glCaps
(
)
.
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
)
;
return
static_cast
<
GrGLPathRendering
*
>
(
pathRendering
(
)
)
;
}
void
discard
(
GrRenderTarget
*
)
override
;
void
bindTexture
(
int
unitIdx
const
GrTextureParams
&
params
bool
dstConfigAllowsSRGB
GrGLTexture
*
texture
)
;
bool
onGetReadPixelsInfo
(
GrSurface
*
srcSurface
int
readWidth
int
readHeight
size_t
rowBytes
GrPixelConfig
readConfig
DrawPreference
*
ReadPixelTempDrawInfo
*
)
override
;
bool
onGetWritePixelsInfo
(
GrSurface
*
dstSurface
int
width
int
height
GrPixelConfig
srcConfig
DrawPreference
*
WritePixelTempDrawInfo
*
)
override
;
bool
initCopySurfaceDstDesc
(
const
GrSurface
*
src
GrSurfaceDesc
*
desc
)
const
override
;
void
bindVertexArray
(
GrGLuint
id
)
{
fHWVertexArrayState
.
setVertexArrayID
(
this
id
)
;
}
void
notifyVertexArrayDelete
(
GrGLuint
id
)
{
fHWVertexArrayState
.
notifyVertexArrayDelete
(
id
)
;
}
GrGLenum
bindBuffer
(
GrBufferType
type
const
GrGLBuffer
*
)
;
const
GrGLContext
*
glContextForTesting
(
)
const
override
{
return
&
this
-
>
glContext
(
)
;
}
void
clearStencil
(
GrRenderTarget
*
)
override
;
void
invalidateBoundRenderTarget
(
)
{
fHWBoundRenderTargetUniqueID
=
SK_InvalidUniqueID
;
}
GrStencilAttachment
*
createStencilAttachmentForRenderTarget
(
const
GrRenderTarget
*
rt
int
width
int
height
)
override
;
GrBackendObject
createTestingOnlyBackendTexture
(
void
*
pixels
int
w
int
h
GrPixelConfig
config
)
override
;
bool
isTestingOnlyBackendTexture
(
GrBackendObject
)
const
override
;
void
deleteTestingOnlyBackendTexture
(
GrBackendObject
bool
abandonTexture
)
override
;
void
resetShaderCacheForTesting
(
)
const
override
;
void
drawDebugWireRect
(
GrRenderTarget
*
const
SkIRect
&
GrColor
)
override
;
void
finishDrawTarget
(
)
override
;
private
:
GrGLGpu
(
GrGLContext
*
ctx
GrContext
*
context
)
;
void
onResetContext
(
uint32_t
resetBits
)
override
;
void
xferBarrier
(
GrRenderTarget
*
GrXferBarrierType
)
override
;
GrTexture
*
onCreateTexture
(
const
GrSurfaceDesc
&
desc
GrGpuResource
:
:
LifeCycle
lifeCycle
const
SkTArray
<
GrMipLevel
>
&
texels
)
override
;
GrTexture
*
onCreateCompressedTexture
(
const
GrSurfaceDesc
&
desc
GrGpuResource
:
:
LifeCycle
lifeCycle
const
SkTArray
<
GrMipLevel
>
&
texels
)
override
;
GrBuffer
*
onCreateBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
)
override
;
GrTexture
*
onWrapBackendTexture
(
const
GrBackendTextureDesc
&
GrWrapOwnership
)
override
;
GrRenderTarget
*
onWrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
GrWrapOwnership
)
override
;
GrRenderTarget
*
onWrapBackendTextureAsRenderTarget
(
const
GrBackendTextureDesc
&
)
override
;
int
getCompatibleStencilIndex
(
GrPixelConfig
config
)
;
bool
createTextureImpl
(
const
GrSurfaceDesc
&
desc
GrGLTextureInfo
*
info
bool
renderTarget
GrGLTexture
:
:
TexParams
*
initialTexParams
const
SkTArray
<
GrMipLevel
>
&
texels
)
;
bool
createTextureExternalAllocatorImpl
(
const
GrSurfaceDesc
&
desc
GrGLTextureInfo
*
info
const
SkTArray
<
GrMipLevel
>
&
texels
)
;
void
onClear
(
GrRenderTarget
*
const
SkIRect
&
rect
GrColor
color
)
override
;
void
onClearStencilClip
(
GrRenderTarget
*
const
SkIRect
&
rect
bool
insideClip
)
override
;
bool
onMakeCopyForTextureParams
(
GrTexture
*
const
GrTextureParams
&
GrTextureProducer
:
:
CopyParams
*
)
const
override
;
bool
readPixelsSupported
(
GrRenderTarget
*
target
GrPixelConfig
readConfig
)
;
bool
readPixelsSupported
(
GrPixelConfig
renderTargetConfig
GrPixelConfig
readConfig
)
;
bool
readPixelsSupported
(
GrSurface
*
surfaceForConfig
GrPixelConfig
readConfig
)
;
bool
onReadPixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
void
*
buffer
size_t
rowBytes
)
override
;
bool
onWritePixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
SkTArray
<
GrMipLevel
>
&
texels
)
override
;
bool
onTransferPixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
config
GrBuffer
*
transferBuffer
size_t
offset
size_t
rowBytes
)
override
;
void
onResolveRenderTarget
(
GrRenderTarget
*
target
)
override
;
void
onDraw
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
const
GrMesh
*
int
meshCount
)
override
;
bool
onCopySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
override
;
void
onGetMultisampleSpecs
(
GrRenderTarget
*
const
GrStencilSettings
&
int
*
effectiveSampleCnt
SkAutoTDeleteArray
<
SkPoint
>
*
sampleLocations
)
override
;
void
setTextureUnit
(
int
unitIdx
)
;
bool
flushGLState
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
)
;
void
setupGeometry
(
const
GrPrimitiveProcessor
&
const
GrNonInstancedMesh
&
mesh
size_t
*
indexOffsetInBytes
)
;
void
flushBlend
(
const
GrXferProcessor
:
:
BlendInfo
&
blendInfo
const
GrSwizzle
&
)
;
bool
hasExtension
(
const
char
*
ext
)
const
{
return
fGLContext
-
>
hasExtension
(
ext
)
;
}
bool
copySurfaceAsDraw
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
void
copySurfaceAsCopyTexSubImage
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
bool
copySurfaceAsBlitFramebuffer
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
void
stampPLSSetupRect
(
const
SkRect
&
bounds
)
;
void
setupPixelLocalStorage
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
)
;
static
bool
BlendCoeffReferencesConstant
(
GrBlendCoeff
coeff
)
;
class
ProgramCache
:
public
:
:
SkNoncopyable
{
public
:
ProgramCache
(
GrGLGpu
*
gpu
)
;
~
ProgramCache
(
)
;
void
abandon
(
)
;
GrGLProgram
*
refProgram
(
const
GrGLGpu
*
gpu
const
GrPipeline
&
const
GrPrimitiveProcessor
&
)
;
private
:
enum
{
kMaxEntries
=
128
kHashBits
=
6
}
;
struct
Entry
;
struct
ProgDescLess
;
int
search
(
const
GrProgramDesc
&
desc
)
const
;
Entry
*
fEntries
[
kMaxEntries
]
;
Entry
*
fHashTable
[
1
<
<
kHashBits
]
;
int
fCount
;
unsigned
int
fCurrLRUStamp
;
GrGLGpu
*
fGpu
;
#
ifdef
PROGRAM_CACHE_STATS
int
fTotalRequests
;
int
fCacheMisses
;
int
fHashMisses
;
#
endif
}
;
void
flushColorWrite
(
bool
writeColor
)
;
void
flushDrawFace
(
GrPipelineBuilder
:
:
DrawFace
face
)
;
void
flushScissor
(
const
GrScissorState
&
const
GrGLIRect
&
rtViewport
GrSurfaceOrigin
rtOrigin
)
;
void
disableScissor
(
)
;
void
initFSAASupport
(
)
;
void
initStencilFormats
(
)
;
void
setScratchTextureUnit
(
)
;
void
flushRenderTarget
(
GrGLRenderTarget
*
const
SkIRect
*
bounds
bool
disableSRGB
=
false
)
;
void
didWriteToSurface
(
GrSurface
*
const
SkIRect
*
bounds
)
const
;
void
flushViewport
(
const
GrGLIRect
&
)
;
void
flushStencil
(
const
GrStencilSettings
&
)
;
void
flushHWAAState
(
GrRenderTarget
*
rt
bool
useHWAA
bool
stencilEnabled
)
;
void
flushMinSampleShading
(
float
minSampleShading
)
;
enum
UploadType
{
kNewTexture_UploadType
kWrite_UploadType
kTransfer_UploadType
}
;
bool
uploadTexData
(
const
GrSurfaceDesc
&
desc
GrGLenum
target
UploadType
uploadType
int
left
int
top
int
width
int
height
GrPixelConfig
dataConfig
const
SkTArray
<
GrMipLevel
>
&
texels
)
;
bool
uploadCompressedTexData
(
const
GrSurfaceDesc
&
desc
GrGLenum
target
const
SkTArray
<
GrMipLevel
>
&
texels
UploadType
uploadType
=
kNewTexture_UploadType
int
left
=
0
int
top
=
0
int
width
=
-
1
int
height
=
-
1
)
;
bool
createRenderTargetObjects
(
const
GrSurfaceDesc
&
GrGpuResource
:
:
LifeCycle
lifeCycle
const
GrGLTextureInfo
&
texInfo
GrGLRenderTarget
:
:
IDDesc
*
)
;
enum
TempFBOTarget
{
kSrc_TempFBOTarget
kDst_TempFBOTarget
}
;
void
bindSurfaceFBOForCopy
(
GrSurface
*
surface
GrGLenum
fboTarget
GrGLIRect
*
viewport
TempFBOTarget
tempFBOTarget
)
;
void
unbindTextureFBOForCopy
(
GrGLenum
fboTarget
GrSurface
*
surface
)
;
SkAutoTUnref
<
GrGLContext
>
fGLContext
;
bool
createCopyProgram
(
int
progIdx
)
;
bool
createWireRectProgram
(
)
;
bool
createPLSSetupProgram
(
)
;
ProgramCache
*
fProgramCache
;
int
fHWActiveTextureUnitIdx
;
GrGLuint
fHWProgramID
;
enum
TriState
{
kNo_TriState
kYes_TriState
kUnknown_TriState
}
;
GrGLuint
fTempSrcFBOID
;
GrGLuint
fTempDstFBOID
;
GrGLuint
fStencilClearFBOID
;
struct
{
TriState
fEnabled
;
GrGLIRect
fRect
;
void
invalidate
(
)
{
fEnabled
=
kUnknown_TriState
;
fRect
.
invalidate
(
)
;
}
}
fHWScissorSettings
;
GrGLIRect
fHWViewport
;
class
HWVertexArrayState
{
public
:
HWVertexArrayState
(
)
:
fCoreProfileVertexArray
(
nullptr
)
{
this
-
>
invalidate
(
)
;
}
~
HWVertexArrayState
(
)
{
delete
fCoreProfileVertexArray
;
}
void
invalidate
(
)
{
fBoundVertexArrayIDIsValid
=
false
;
fDefaultVertexArrayAttribState
.
invalidate
(
)
;
if
(
fCoreProfileVertexArray
)
{
fCoreProfileVertexArray
-
>
invalidateCachedState
(
)
;
}
}
void
notifyVertexArrayDelete
(
GrGLuint
id
)
{
if
(
fBoundVertexArrayIDIsValid
&
&
fBoundVertexArrayID
=
=
id
)
{
fBoundVertexArrayID
=
0
;
}
}
void
setVertexArrayID
(
GrGLGpu
*
gpu
GrGLuint
arrayID
)
{
if
(
!
gpu
-
>
glCaps
(
)
.
vertexArrayObjectSupport
(
)
)
{
SkASSERT
(
0
=
=
arrayID
)
;
return
;
}
if
(
!
fBoundVertexArrayIDIsValid
|
|
arrayID
!
=
fBoundVertexArrayID
)
{
GR_GL_CALL
(
gpu
-
>
glInterface
(
)
BindVertexArray
(
arrayID
)
)
;
fBoundVertexArrayIDIsValid
=
true
;
fBoundVertexArrayID
=
arrayID
;
}
}
GrGLAttribArrayState
*
bindInternalVertexArray
(
GrGLGpu
*
const
GrGLBuffer
*
ibuff
=
nullptr
)
;
private
:
GrGLuint
fBoundVertexArrayID
;
bool
fBoundVertexArrayIDIsValid
;
GrGLAttribArrayState
fDefaultVertexArrayAttribState
;
GrGLVertexArray
*
fCoreProfileVertexArray
;
}
fHWVertexArrayState
;
struct
{
GrGLenum
fGLTarget
;
uint32_t
fBoundBufferUniqueID
;
bool
fBufferZeroKnownBound
;
void
invalidate
(
)
{
fBoundBufferUniqueID
=
SK_InvalidUniqueID
;
fBufferZeroKnownBound
=
false
;
}
}
fHWBufferState
[
kGrBufferTypeCount
]
;
struct
{
GrBlendEquation
fEquation
;
GrBlendCoeff
fSrcCoeff
;
GrBlendCoeff
fDstCoeff
;
GrColor
fConstColor
;
bool
fConstColorValid
;
TriState
fEnabled
;
void
invalidate
(
)
{
fEquation
=
static_cast
<
GrBlendEquation
>
(
-
1
)
;
fSrcCoeff
=
static_cast
<
GrBlendCoeff
>
(
-
1
)
;
fDstCoeff
=
static_cast
<
GrBlendCoeff
>
(
-
1
)
;
fConstColorValid
=
false
;
fEnabled
=
kUnknown_TriState
;
}
}
fHWBlendState
;
TriState
fMSAAEnabled
;
GrStencilSettings
fHWStencilSettings
;
TriState
fHWStencilTestEnabled
;
GrPipelineBuilder
:
:
DrawFace
fHWDrawFace
;
TriState
fHWWriteToColor
;
uint32_t
fHWBoundRenderTargetUniqueID
;
TriState
fHWSRGBFramebuffer
;
SkTArray
<
uint32_t
true
>
fHWBoundTextureUniqueIDs
;
TriState
fHWRasterMultisampleEnabled
;
int
fHWNumRasterSamples
;
struct
{
GrGLuint
fProgram
;
GrGLint
fTextureUniform
;
GrGLint
fTexCoordXformUniform
;
GrGLint
fPosXformUniform
;
}
fCopyPrograms
[
3
]
;
SkAutoTUnref
<
GrGLBuffer
>
fCopyProgramArrayBuffer
;
struct
{
GrGLuint
fProgram
;
GrGLint
fColorUniform
;
GrGLint
fRectUniform
;
}
fWireRectProgram
;
SkAutoTUnref
<
GrGLBuffer
>
fWireRectArrayBuffer
;
static
int
TextureTargetToCopyProgramIdx
(
GrGLenum
target
)
{
switch
(
target
)
{
case
GR_GL_TEXTURE_2D
:
return
0
;
case
GR_GL_TEXTURE_EXTERNAL
:
return
1
;
case
GR_GL_TEXTURE_RECTANGLE
:
return
2
;
default
:
SkFAIL
(
"
Unexpected
texture
target
type
.
"
)
;
return
0
;
}
}
struct
{
GrGLuint
fProgram
;
GrGLint
fPosXformUniform
;
SkAutoTUnref
<
GrGLBuffer
>
fArrayBuffer
;
}
fPLSSetupProgram
;
bool
fHWPLSEnabled
;
bool
fPLSHasBeenUsed
;
float
fHWMinSampleShading
;
typedef
GrGpu
INHERITED
;
friend
class
GrGLPathRendering
;
}
;
#
endif
