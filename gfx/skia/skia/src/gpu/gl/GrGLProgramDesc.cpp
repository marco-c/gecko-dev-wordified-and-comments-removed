#
include
"
GrGLProgramDesc
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrGLGpu
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
static
bool
swizzle_requires_alpha_remapping
(
const
GrGLSLCaps
&
caps
GrPixelConfig
config
)
{
if
(
!
caps
.
mustSwizzleInShader
(
)
)
{
return
false
;
}
const
char
*
swizzleMap
=
caps
.
getSwizzleMap
(
config
)
;
return
SkToBool
(
memcmp
(
swizzleMap
"
rgba
"
4
)
)
;
}
static
uint32_t
gen_texture_key
(
const
GrProcessor
&
proc
const
GrGLCaps
&
caps
)
{
uint32_t
key
=
0
;
int
numTextures
=
proc
.
numTextures
(
)
;
int
shift
=
0
;
for
(
int
t
=
0
;
t
<
numTextures
;
+
+
t
)
{
const
GrTextureAccess
&
access
=
proc
.
textureAccess
(
t
)
;
if
(
swizzle_requires_alpha_remapping
(
*
caps
.
glslCaps
(
)
access
.
getTexture
(
)
-
>
config
(
)
)
)
{
key
|
=
1
<
<
shift
;
}
if
(
GR_GL_TEXTURE_EXTERNAL
=
=
static_cast
<
GrGLTexture
*
>
(
access
.
getTexture
(
)
)
-
>
target
(
)
)
{
key
|
=
2
<
<
shift
;
}
shift
+
=
2
;
}
return
key
;
}
static
bool
gen_meta_key
(
const
GrProcessor
&
proc
const
GrGLCaps
&
caps
uint32_t
transformKey
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
textureKey
=
gen_texture_key
(
proc
caps
)
;
uint32_t
classID
=
proc
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
SK_MaxU16
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
uint32_t
*
key
=
b
-
>
add32n
(
3
)
;
key
[
0
]
=
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
;
key
[
1
]
=
textureKey
;
key
[
2
]
=
transformKey
;
return
true
;
}
static
bool
gen_frag_proc_and_meta_keys
(
const
GrPrimitiveProcessor
&
primProc
const
GrFragmentProcessor
&
fp
const
GrGLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
{
for
(
int
i
=
0
;
i
<
fp
.
numChildProcessors
(
)
;
+
+
i
)
{
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
.
childProcessor
(
i
)
caps
b
)
)
{
return
false
;
}
}
fp
.
getGLSLProcessorKey
(
*
caps
.
glslCaps
(
)
b
)
;
return
gen_meta_key
(
fp
caps
primProc
.
getTransformKey
(
fp
.
coordTransforms
(
)
fp
.
numTransformsExclChildren
(
)
)
b
)
;
}
bool
GrGLProgramDescBuilder
:
:
Build
(
GrProgramDesc
*
desc
const
GrPrimitiveProcessor
&
primProc
const
GrPipeline
&
pipeline
const
GrGLGpu
*
gpu
)
{
GrGLProgramDesc
*
glDesc
=
(
GrGLProgramDesc
*
)
desc
;
GR_STATIC_ASSERT
(
0
=
=
kProcessorKeysOffset
%
sizeof
(
uint32_t
)
)
;
glDesc
-
>
key
(
)
.
reset
(
)
;
glDesc
-
>
key
(
)
.
push_back_n
(
kProcessorKeysOffset
)
;
GrProcessorKeyBuilder
b
(
&
glDesc
-
>
key
(
)
)
;
primProc
.
getGLSLProcessorKey
(
*
gpu
-
>
glCaps
(
)
.
glslCaps
(
)
&
b
)
;
if
(
!
gen_meta_key
(
primProc
gpu
-
>
glCaps
(
)
0
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
pipeline
.
numFragmentProcessors
(
)
;
+
+
i
)
{
const
GrFragmentProcessor
&
fp
=
pipeline
.
getFragmentProcessor
(
i
)
;
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
gpu
-
>
glCaps
(
)
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
}
const
GrXferProcessor
&
xp
=
*
pipeline
.
getXferProcessor
(
)
;
xp
.
getGLSLProcessorKey
(
*
gpu
-
>
glCaps
(
)
.
glslCaps
(
)
&
b
)
;
if
(
!
gen_meta_key
(
xp
gpu
-
>
glCaps
(
)
0
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
KeyHeader
*
header
=
glDesc
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
memset
(
header
0
kHeaderSize
)
;
if
(
pipeline
.
readsFragPosition
(
)
)
{
header
-
>
fFragPosKey
=
GrGLSLFragmentShaderBuilder
:
:
KeyForFragmentPosition
(
pipeline
.
getRenderTarget
(
)
)
;
}
else
{
header
-
>
fFragPosKey
=
0
;
}
if
(
pipeline
.
ignoresCoverage
(
)
)
{
header
-
>
fIgnoresCoverage
=
1
;
}
else
{
header
-
>
fIgnoresCoverage
=
0
;
}
header
-
>
fSnapVerticesToPixelCenters
=
pipeline
.
snapVerticesToPixelCenters
(
)
;
header
-
>
fColorEffectCnt
=
pipeline
.
numColorFragmentProcessors
(
)
;
header
-
>
fCoverageEffectCnt
=
pipeline
.
numCoverageFragmentProcessors
(
)
;
glDesc
-
>
finalize
(
)
;
return
true
;
}
