#
include
"
GrGLProgramDesc
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
gl
/
GrGLDefines
.
h
"
#
include
"
gl
/
GrGLTexture
.
h
"
#
include
"
gl
/
GrGLTypes
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLCaps
.
h
"
static
uint8_t
texture_target_key
(
GrGLenum
target
)
{
switch
(
target
)
{
case
GR_GL_TEXTURE_2D
:
return
0
;
case
GR_GL_TEXTURE_EXTERNAL
:
return
1
;
case
GR_GL_TEXTURE_RECTANGLE
:
return
2
;
default
:
SkFAIL
(
"
Unexpected
texture
target
.
"
)
;
return
0
;
}
}
static
void
add_texture_key
(
GrProcessorKeyBuilder
*
b
const
GrProcessor
&
proc
const
GrGLSLCaps
&
caps
)
{
int
numTextures
=
proc
.
numTextures
(
)
;
int
word32Count
=
(
proc
.
numTextures
(
)
+
1
)
/
2
;
if
(
0
=
=
word32Count
)
{
return
;
}
uint16_t
*
k16
=
SkTCast
<
uint16_t
*
>
(
b
-
>
add32n
(
word32Count
)
)
;
for
(
int
i
=
0
;
i
<
numTextures
;
+
+
i
)
{
const
GrTextureAccess
&
access
=
proc
.
textureAccess
(
i
)
;
GrGLTexture
*
texture
=
static_cast
<
GrGLTexture
*
>
(
access
.
getTexture
(
)
)
;
k16
[
i
]
=
SkToU16
(
caps
.
configTextureSwizzle
(
texture
-
>
config
(
)
)
.
asKey
(
)
|
(
texture_target_key
(
texture
-
>
target
(
)
)
<
<
8
)
)
;
}
if
(
numTextures
&
0x1
)
{
k16
[
numTextures
]
=
0
;
}
}
static
bool
gen_meta_key
(
const
GrProcessor
&
proc
const
GrGLSLCaps
&
glslCaps
uint32_t
transformKey
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
classID
=
proc
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
SK_MaxU16
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
add_texture_key
(
b
proc
glslCaps
)
;
uint32_t
*
key
=
b
-
>
add32n
(
2
)
;
key
[
0
]
=
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
;
key
[
1
]
=
transformKey
;
return
true
;
}
static
bool
gen_frag_proc_and_meta_keys
(
const
GrPrimitiveProcessor
&
primProc
const
GrFragmentProcessor
&
fp
const
GrGLSLCaps
&
glslCaps
GrProcessorKeyBuilder
*
b
)
{
for
(
int
i
=
0
;
i
<
fp
.
numChildProcessors
(
)
;
+
+
i
)
{
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
.
childProcessor
(
i
)
glslCaps
b
)
)
{
return
false
;
}
}
fp
.
getGLSLProcessorKey
(
glslCaps
b
)
;
return
gen_meta_key
(
fp
glslCaps
primProc
.
getTransformKey
(
fp
.
coordTransforms
(
)
fp
.
numTransformsExclChildren
(
)
)
b
)
;
}
bool
GrGLProgramDescBuilder
:
:
Build
(
GrProgramDesc
*
desc
const
GrPrimitiveProcessor
&
primProc
const
GrPipeline
&
pipeline
const
GrGLSLCaps
&
glslCaps
)
{
GrGLProgramDesc
*
glDesc
=
(
GrGLProgramDesc
*
)
desc
;
GR_STATIC_ASSERT
(
0
=
=
kProcessorKeysOffset
%
sizeof
(
uint32_t
)
)
;
glDesc
-
>
key
(
)
.
reset
(
)
;
glDesc
-
>
key
(
)
.
push_back_n
(
kProcessorKeysOffset
)
;
GrProcessorKeyBuilder
b
(
&
glDesc
-
>
key
(
)
)
;
primProc
.
getGLSLProcessorKey
(
glslCaps
&
b
)
;
if
(
!
gen_meta_key
(
primProc
glslCaps
0
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
GrProcessor
:
:
RequiredFeatures
requiredFeatures
=
primProc
.
requiredFeatures
(
)
;
for
(
int
i
=
0
;
i
<
pipeline
.
numFragmentProcessors
(
)
;
+
+
i
)
{
const
GrFragmentProcessor
&
fp
=
pipeline
.
getFragmentProcessor
(
i
)
;
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
glslCaps
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
requiredFeatures
|
=
fp
.
requiredFeatures
(
)
;
}
const
GrXferProcessor
&
xp
=
pipeline
.
getXferProcessor
(
)
;
xp
.
getGLSLProcessorKey
(
glslCaps
&
b
)
;
if
(
!
gen_meta_key
(
xp
glslCaps
0
&
b
)
)
{
glDesc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
requiredFeatures
|
=
xp
.
requiredFeatures
(
)
;
KeyHeader
*
header
=
glDesc
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
memset
(
header
0
kHeaderSize
)
;
GrRenderTarget
*
rt
=
pipeline
.
getRenderTarget
(
)
;
if
(
requiredFeatures
&
(
GrProcessor
:
:
kFragmentPosition_RequiredFeature
|
GrProcessor
:
:
kSampleLocations_RequiredFeature
)
)
{
header
-
>
fSurfaceOriginKey
=
GrGLSLFragmentShaderBuilder
:
:
KeyForSurfaceOrigin
(
rt
-
>
origin
(
)
)
;
}
else
{
header
-
>
fSurfaceOriginKey
=
0
;
}
if
(
requiredFeatures
&
GrProcessor
:
:
kSampleLocations_RequiredFeature
)
{
SkASSERT
(
pipeline
.
isHWAntialiasState
(
)
)
;
header
-
>
fSamplePatternKey
=
rt
-
>
renderTargetPriv
(
)
.
getMultisampleSpecs
(
pipeline
.
getStencil
(
)
)
.
fUniqueID
;
}
else
{
header
-
>
fSamplePatternKey
=
0
;
}
header
-
>
fOutputSwizzle
=
glslCaps
.
configOutputSwizzle
(
rt
-
>
config
(
)
)
.
asKey
(
)
;
if
(
pipeline
.
ignoresCoverage
(
)
)
{
header
-
>
fIgnoresCoverage
=
1
;
}
else
{
header
-
>
fIgnoresCoverage
=
0
;
}
header
-
>
fSnapVerticesToPixelCenters
=
pipeline
.
snapVerticesToPixelCenters
(
)
;
header
-
>
fColorEffectCnt
=
pipeline
.
numColorFragmentProcessors
(
)
;
header
-
>
fCoverageEffectCnt
=
pipeline
.
numCoverageFragmentProcessors
(
)
;
glDesc
-
>
finalize
(
)
;
return
true
;
}
