#
include
"
gl
/
GrGLUniformHandler
.
h
"
#
include
"
gl
/
GrGLCaps
.
h
"
#
include
"
gl
/
GrGLGpu
.
h
"
#
include
"
gl
/
builders
/
GrGLProgramBuilder
.
h
"
#
define
GL_CALL
(
X
)
GR_GL_CALL
(
this
-
>
glGpu
(
)
-
>
glInterface
(
)
X
)
#
define
GL_CALL_RET
(
R
X
)
GR_GL_CALL_RET
(
this
-
>
glGpu
(
)
-
>
glInterface
(
)
R
X
)
GrGLSLUniformHandler
:
:
UniformHandle
GrGLUniformHandler
:
:
internalAddUniformArray
(
uint32_t
visibility
GrSLType
type
GrSLPrecision
precision
const
char
*
name
bool
mangleName
int
arrayCount
const
char
*
*
outName
)
{
SkASSERT
(
name
&
&
strlen
(
name
)
)
;
SkDEBUGCODE
(
static
const
uint32_t
kVisibilityMask
=
kVertex_Visibility
|
kFragment_Visibility
)
;
SkASSERT
(
0
=
=
(
~
kVisibilityMask
&
visibility
)
)
;
SkASSERT
(
0
!
=
visibility
)
;
SkASSERT
(
kDefault_GrSLPrecision
=
=
precision
|
|
GrSLTypeIsFloatType
(
type
)
)
;
UniformInfo
&
uni
=
fUniforms
.
push_back
(
)
;
uni
.
fVariable
.
setType
(
type
)
;
uni
.
fVariable
.
setTypeModifier
(
GrGLSLShaderVar
:
:
kUniform_TypeModifier
)
;
char
prefix
=
'
u
'
;
if
(
'
u
'
=
=
name
[
0
]
)
{
prefix
=
'
\
0
'
;
}
fProgramBuilder
-
>
nameVariable
(
uni
.
fVariable
.
accessName
(
)
prefix
name
mangleName
)
;
uni
.
fVariable
.
setArrayCount
(
arrayCount
)
;
uni
.
fVisibility
=
visibility
;
uni
.
fVariable
.
setPrecision
(
precision
)
;
if
(
outName
)
{
*
outName
=
uni
.
fVariable
.
c_str
(
)
;
}
return
GrGLSLUniformHandler
:
:
UniformHandle
(
fUniforms
.
count
(
)
-
1
)
;
}
void
GrGLUniformHandler
:
:
appendUniformDecls
(
ShaderVisibility
visibility
SkString
*
out
)
const
{
for
(
int
i
=
0
;
i
<
fUniforms
.
count
(
)
;
+
+
i
)
{
if
(
fUniforms
[
i
]
.
fVisibility
&
visibility
)
{
fUniforms
[
i
]
.
fVariable
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
out
)
;
out
-
>
append
(
"
;
\
n
"
)
;
}
}
}
void
GrGLUniformHandler
:
:
bindUniformLocations
(
GrGLuint
programID
const
GrGLCaps
&
caps
)
{
if
(
caps
.
bindUniformLocationSupport
(
)
)
{
int
count
=
fUniforms
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
GL_CALL
(
BindUniformLocation
(
programID
i
fUniforms
[
i
]
.
fVariable
.
c_str
(
)
)
)
;
fUniforms
[
i
]
.
fLocation
=
i
;
}
}
}
void
GrGLUniformHandler
:
:
getUniformLocations
(
GrGLuint
programID
const
GrGLCaps
&
caps
)
{
if
(
!
caps
.
bindUniformLocationSupport
(
)
)
{
int
count
=
fUniforms
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
GrGLint
location
;
GL_CALL_RET
(
location
GetUniformLocation
(
programID
fUniforms
[
i
]
.
fVariable
.
c_str
(
)
)
)
;
fUniforms
[
i
]
.
fLocation
=
location
;
}
}
}
const
GrGLGpu
*
GrGLUniformHandler
:
:
glGpu
(
)
const
{
GrGLProgramBuilder
*
glPB
=
(
GrGLProgramBuilder
*
)
fProgramBuilder
;
return
glPB
-
>
gpu
(
)
;
}
