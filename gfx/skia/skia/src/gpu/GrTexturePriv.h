#
ifndef
GrTexturePriv_DEFINED
#
define
GrTexturePriv_DEFINED
#
include
"
GrTexture
.
h
"
class
GrTexturePriv
{
public
:
void
setFlag
(
GrSurfaceFlags
flags
)
{
fTexture
-
>
fDesc
.
fFlags
=
fTexture
-
>
fDesc
.
fFlags
|
flags
;
}
void
resetFlag
(
GrSurfaceFlags
flags
)
{
fTexture
-
>
fDesc
.
fFlags
=
fTexture
-
>
fDesc
.
fFlags
&
~
flags
;
}
bool
isSetFlag
(
GrSurfaceFlags
flags
)
const
{
return
0
!
=
(
fTexture
-
>
fDesc
.
fFlags
&
flags
)
;
}
void
dirtyMipMaps
(
bool
mipMapsDirty
)
{
fTexture
-
>
dirtyMipMaps
(
mipMapsDirty
)
;
}
bool
mipMapsAreDirty
(
)
const
{
return
GrTexture
:
:
kValid_MipMapsStatus
!
=
fTexture
-
>
fMipMapsStatus
;
}
bool
hasMipMaps
(
)
const
{
return
GrTexture
:
:
kNotAllocated_MipMapsStatus
!
=
fTexture
-
>
fMipMapsStatus
;
}
void
setMaxMipMapLevel
(
int
maxMipMapLevel
)
const
{
fTexture
-
>
fMaxMipMapLevel
=
maxMipMapLevel
;
}
int
maxMipMapLevel
(
)
const
{
return
fTexture
-
>
fMaxMipMapLevel
;
}
void
setGammaTreatment
(
SkSourceGammaTreatment
gammaTreatment
)
const
{
fTexture
-
>
fGammaTreatment
=
gammaTreatment
;
}
SkSourceGammaTreatment
gammaTreatment
(
)
const
{
return
fTexture
-
>
fGammaTreatment
;
}
static
void
ComputeScratchKey
(
const
GrSurfaceDesc
&
GrScratchKey
*
)
;
private
:
GrTexturePriv
(
GrTexture
*
texture
)
:
fTexture
(
texture
)
{
}
GrTexturePriv
(
const
GrTexturePriv
&
that
)
:
fTexture
(
that
.
fTexture
)
{
}
GrTexturePriv
&
operator
=
(
const
GrTexturePriv
&
)
;
const
GrTexturePriv
*
operator
&
(
)
const
;
GrTexturePriv
*
operator
&
(
)
;
GrTexture
*
fTexture
;
friend
class
GrTexture
;
}
;
inline
GrTexturePriv
GrTexture
:
:
texturePriv
(
)
{
return
GrTexturePriv
(
this
)
;
}
inline
const
GrTexturePriv
GrTexture
:
:
texturePriv
(
)
const
{
return
GrTexturePriv
(
const_cast
<
GrTexture
*
>
(
this
)
)
;
}
#
endif
