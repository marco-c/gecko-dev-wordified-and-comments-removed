#
ifndef
GrTexturePriv_DEFINED
#
define
GrTexturePriv_DEFINED
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
GrSamplerState
.
h
"
class
GrTexturePriv
{
public
:
void
markMipMapsDirty
(
)
{
fTexture
-
>
markMipMapsDirty
(
)
;
}
void
markMipMapsClean
(
)
{
fTexture
-
>
markMipMapsClean
(
)
;
}
GrMipMapsStatus
mipMapsStatus
(
)
const
{
return
fTexture
-
>
fMipMapsStatus
;
}
bool
mipMapsAreDirty
(
)
const
{
return
GrMipMapsStatus
:
:
kValid
!
=
this
-
>
mipMapsStatus
(
)
;
}
GrMipMapped
mipMapped
(
)
const
{
if
(
GrMipMapsStatus
:
:
kNotAllocated
!
=
this
-
>
mipMapsStatus
(
)
)
{
return
GrMipMapped
:
:
kYes
;
}
return
GrMipMapped
:
:
kNo
;
}
int
maxMipMapLevel
(
)
const
{
return
fTexture
-
>
fMaxMipMapLevel
;
}
GrTextureType
textureType
(
)
const
{
return
fTexture
-
>
fTextureType
;
}
bool
hasRestrictedSampling
(
)
const
{
return
GrTextureTypeHasRestrictedSampling
(
this
-
>
textureType
(
)
)
;
}
GrSamplerState
:
:
Filter
highestFilterMode
(
)
const
{
return
this
-
>
hasRestrictedSampling
(
)
?
GrSamplerState
:
:
Filter
:
:
kBilerp
:
GrSamplerState
:
:
Filter
:
:
kMipMap
;
}
static
void
ComputeScratchKey
(
GrPixelConfig
config
int
width
int
height
GrRenderable
int
sampleCnt
GrMipMapped
GrProtected
GrScratchKey
*
key
)
;
private
:
GrTexturePriv
(
GrTexture
*
texture
)
:
fTexture
(
texture
)
{
}
GrTexturePriv
(
const
GrTexturePriv
&
that
)
:
fTexture
(
that
.
fTexture
)
{
}
GrTexturePriv
&
operator
=
(
const
GrTexturePriv
&
)
;
const
GrTexturePriv
*
operator
&
(
)
const
;
GrTexturePriv
*
operator
&
(
)
;
GrTexture
*
fTexture
;
friend
class
GrTexture
;
}
;
inline
GrTexturePriv
GrTexture
:
:
texturePriv
(
)
{
return
GrTexturePriv
(
this
)
;
}
inline
const
GrTexturePriv
GrTexture
:
:
texturePriv
(
)
const
{
return
GrTexturePriv
(
const_cast
<
GrTexture
*
>
(
this
)
)
;
}
#
endif
