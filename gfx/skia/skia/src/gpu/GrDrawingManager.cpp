#
include
"
src
/
gpu
/
GrDrawingManager
.
h
"
#
include
"
include
/
gpu
/
GrBackendSemaphore
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
SkDeferredDisplayList
.
h
"
#
include
"
src
/
core
/
SkTTopoSort
.
h
"
#
include
"
src
/
gpu
/
GrAuditTrail
.
h
"
#
include
"
src
/
gpu
/
GrClientMappedBufferManager
.
h
"
#
include
"
src
/
gpu
/
GrContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrCopyRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetContext
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
GrRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrSoftwarePathRenderer
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
GrTextureContext
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxyPriv
.
h
"
#
include
"
src
/
gpu
/
GrTextureResolveRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrTracing
.
h
"
#
include
"
src
/
gpu
/
GrTransferFromRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrWaitRenderTask
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCoverageCountingPathRenderer
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextContext
.
h
"
#
include
"
src
/
image
/
SkSurface_Gpu
.
h
"
GrDrawingManager
:
:
RenderTaskDAG
:
:
RenderTaskDAG
(
bool
sortRenderTasks
)
:
fSortRenderTasks
(
sortRenderTasks
)
{
}
GrDrawingManager
:
:
RenderTaskDAG
:
:
~
RenderTaskDAG
(
)
{
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
gatherIDs
(
SkSTArray
<
8
uint32_t
true
>
*
idArray
)
const
{
idArray
-
>
reset
(
fRenderTasks
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
if
(
fRenderTasks
[
i
]
)
{
(
*
idArray
)
[
i
]
=
fRenderTasks
[
i
]
-
>
uniqueID
(
)
;
}
}
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
reset
(
)
{
fRenderTasks
.
reset
(
)
;
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
removeRenderTask
(
int
index
)
{
if
(
!
fRenderTasks
[
index
]
-
>
unique
(
)
)
{
fRenderTasks
[
index
]
-
>
endFlush
(
)
;
}
fRenderTasks
[
index
]
=
nullptr
;
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
removeRenderTasks
(
int
startIndex
int
stopIndex
)
{
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
if
(
!
fRenderTasks
[
i
]
)
{
continue
;
}
this
-
>
removeRenderTask
(
i
)
;
}
}
bool
GrDrawingManager
:
:
RenderTaskDAG
:
:
isUsed
(
GrSurfaceProxy
*
proxy
)
const
{
for
(
int
i
=
0
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
if
(
fRenderTasks
[
i
]
&
&
fRenderTasks
[
i
]
-
>
isUsed
(
proxy
)
)
{
return
true
;
}
}
return
false
;
}
GrRenderTask
*
GrDrawingManager
:
:
RenderTaskDAG
:
:
add
(
sk_sp
<
GrRenderTask
>
renderTask
)
{
if
(
renderTask
)
{
return
fRenderTasks
.
emplace_back
(
std
:
:
move
(
renderTask
)
)
.
get
(
)
;
}
return
nullptr
;
}
GrRenderTask
*
GrDrawingManager
:
:
RenderTaskDAG
:
:
addBeforeLast
(
sk_sp
<
GrRenderTask
>
renderTask
)
{
SkASSERT
(
!
fRenderTasks
.
empty
(
)
)
;
if
(
renderTask
)
{
fRenderTasks
.
emplace_back
(
fRenderTasks
.
back
(
)
.
release
(
)
)
;
return
(
fRenderTasks
[
fRenderTasks
.
count
(
)
-
2
]
=
std
:
:
move
(
renderTask
)
)
.
get
(
)
;
}
return
nullptr
;
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
add
(
const
SkTArray
<
sk_sp
<
GrRenderTask
>
>
&
renderTasks
)
{
fRenderTasks
.
push_back_n
(
renderTasks
.
count
(
)
renderTasks
.
begin
(
)
)
;
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
swap
(
SkTArray
<
sk_sp
<
GrRenderTask
>
>
*
renderTasks
)
{
SkASSERT
(
renderTasks
-
>
empty
(
)
)
;
renderTasks
-
>
swap
(
fRenderTasks
)
;
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
prepForFlush
(
)
{
if
(
fSortRenderTasks
)
{
SkDEBUGCODE
(
bool
result
=
)
SkTTopoSort
<
GrRenderTask
GrRenderTask
:
:
TopoSortTraits
>
(
&
fRenderTasks
)
;
SkASSERT
(
result
)
;
}
#
ifdef
SK_DEBUG
if
(
fRenderTasks
.
count
(
)
)
{
GrOpsTask
*
prevOpsTask
=
fRenderTasks
[
0
]
-
>
asOpsTask
(
)
;
for
(
int
i
=
1
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
GrOpsTask
*
curOpsTask
=
fRenderTasks
[
i
]
-
>
asOpsTask
(
)
;
if
(
prevOpsTask
&
&
curOpsTask
)
{
SkASSERT
(
prevOpsTask
-
>
fTarget
.
get
(
)
!
=
curOpsTask
-
>
fTarget
.
get
(
)
)
;
}
prevOpsTask
=
curOpsTask
;
}
}
#
endif
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
closeAll
(
const
GrCaps
*
caps
)
{
for
(
int
i
=
0
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
if
(
fRenderTasks
[
i
]
)
{
fRenderTasks
[
i
]
-
>
makeClosed
(
*
caps
)
;
}
}
}
void
GrDrawingManager
:
:
RenderTaskDAG
:
:
cleanup
(
const
GrCaps
*
caps
)
{
for
(
int
i
=
0
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
if
(
!
fRenderTasks
[
i
]
)
{
continue
;
}
fRenderTasks
[
i
]
-
>
makeClosed
(
*
caps
)
;
if
(
!
fRenderTasks
[
i
]
-
>
unique
(
)
)
{
fRenderTasks
[
i
]
-
>
endFlush
(
)
;
}
}
fRenderTasks
.
reset
(
)
;
}
GrDrawingManager
:
:
GrDrawingManager
(
GrRecordingContext
*
context
const
GrPathRendererChain
:
:
Options
&
optionsForPathRendererChain
const
GrTextContext
:
:
Options
&
optionsForTextContext
bool
sortRenderTasks
bool
reduceOpsTaskSplitting
)
:
fContext
(
context
)
fOptionsForPathRendererChain
(
optionsForPathRendererChain
)
fOptionsForTextContext
(
optionsForTextContext
)
fDAG
(
sortRenderTasks
)
fTextContext
(
nullptr
)
fPathRendererChain
(
nullptr
)
fSoftwarePathRenderer
(
nullptr
)
fFlushing
(
false
)
fReduceOpsTaskSplitting
(
reduceOpsTaskSplitting
)
{
}
void
GrDrawingManager
:
:
cleanup
(
)
{
fDAG
.
cleanup
(
fContext
-
>
priv
(
)
.
caps
(
)
)
;
fPathRendererChain
=
nullptr
;
fSoftwarePathRenderer
=
nullptr
;
fOnFlushCBObjects
.
reset
(
)
;
}
GrDrawingManager
:
:
~
GrDrawingManager
(
)
{
this
-
>
cleanup
(
)
;
}
bool
GrDrawingManager
:
:
wasAbandoned
(
)
const
{
return
fContext
-
>
priv
(
)
.
abandoned
(
)
;
}
void
GrDrawingManager
:
:
freeGpuResources
(
)
{
for
(
int
i
=
fOnFlushCBObjects
.
count
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
fOnFlushCBObjects
[
i
]
-
>
retainOnFreeGpuResources
(
)
)
{
fOnFlushCBObjects
.
removeShuffle
(
i
)
;
}
}
fPathRendererChain
=
nullptr
;
fSoftwarePathRenderer
=
nullptr
;
}
GrSemaphoresSubmitted
GrDrawingManager
:
:
flush
(
GrSurfaceProxy
*
proxies
[
]
int
numProxies
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
const
GrPrepareForExternalIORequests
&
externalRequests
)
{
SkASSERT
(
numProxies
>
=
0
)
;
SkASSERT
(
!
numProxies
|
|
proxies
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrDrawingManager
"
"
flush
"
fContext
)
;
if
(
fFlushing
|
|
this
-
>
wasAbandoned
(
)
)
{
if
(
info
.
fFinishedProc
)
{
info
.
fFinishedProc
(
info
.
fFinishedContext
)
;
}
return
GrSemaphoresSubmitted
:
:
kNo
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
if
(
kNone_GrFlushFlags
=
=
info
.
fFlags
&
&
!
info
.
fNumSemaphores
&
&
!
info
.
fFinishedProc
&
&
!
externalRequests
.
hasRequests
(
)
)
{
bool
canSkip
=
numProxies
>
0
;
for
(
int
i
=
0
;
i
<
numProxies
&
&
canSkip
;
+
+
i
)
{
canSkip
=
!
fDAG
.
isUsed
(
proxies
[
i
]
)
&
&
!
this
-
>
isDDLTarget
(
proxies
[
i
]
)
;
}
if
(
canSkip
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
}
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
if
(
info
.
fFinishedProc
)
{
info
.
fFinishedProc
(
info
.
fFinishedContext
)
;
}
return
GrSemaphoresSubmitted
:
:
kNo
;
}
direct
-
>
priv
(
)
.
clientMappedBufferManager
(
)
-
>
process
(
)
;
GrGpu
*
gpu
=
direct
-
>
priv
(
)
.
getGpu
(
)
;
if
(
!
gpu
)
{
if
(
info
.
fFinishedProc
)
{
info
.
fFinishedProc
(
info
.
fFinishedContext
)
;
}
return
GrSemaphoresSubmitted
:
:
kNo
;
}
fFlushing
=
true
;
auto
resourceProvider
=
direct
-
>
priv
(
)
.
resourceProvider
(
)
;
auto
resourceCache
=
direct
-
>
priv
(
)
.
getResourceCache
(
)
;
fDAG
.
closeAll
(
fContext
-
>
priv
(
)
.
caps
(
)
)
;
fActiveOpsTask
=
nullptr
;
fDAG
.
prepForFlush
(
)
;
if
(
!
fCpuBufferCache
)
{
int
maxCachedBuffers
=
fContext
-
>
priv
(
)
.
caps
(
)
-
>
preferClientSideDynamicBuffers
(
)
?
2
:
6
;
fCpuBufferCache
=
GrBufferAllocPool
:
:
CpuBufferCache
:
:
Make
(
maxCachedBuffers
)
;
}
GrOpFlushState
flushState
(
gpu
resourceProvider
&
fTokenTracker
fCpuBufferCache
)
;
GrOnFlushResourceProvider
onFlushProvider
(
this
)
;
if
(
!
fOnFlushCBObjects
.
empty
(
)
)
{
fDAG
.
gatherIDs
(
&
fFlushingRenderTaskIDs
)
;
for
(
GrOnFlushCallbackObject
*
onFlushCBObject
:
fOnFlushCBObjects
)
{
onFlushCBObject
-
>
preFlush
(
&
onFlushProvider
fFlushingRenderTaskIDs
.
begin
(
)
fFlushingRenderTaskIDs
.
count
(
)
)
;
}
for
(
const
auto
&
onFlushRenderTask
:
fOnFlushRenderTasks
)
{
onFlushRenderTask
-
>
makeClosed
(
*
fContext
-
>
priv
(
)
.
caps
(
)
)
;
#
ifdef
SK_DEBUG
onFlushRenderTask
-
>
visitTargetAndSrcProxies_debugOnly
(
[
]
(
GrSurfaceProxy
*
p
GrMipMapped
mipMapped
)
{
SkASSERT
(
!
p
-
>
asTextureProxy
(
)
|
|
!
p
-
>
asTextureProxy
(
)
-
>
texPriv
(
)
.
isDeferred
(
)
)
;
SkASSERT
(
!
p
-
>
isLazy
(
)
)
;
if
(
p
-
>
requiresManualMSAAResolve
(
)
)
{
SkASSERT
(
p
-
>
asRenderTargetProxy
(
)
&
&
!
p
-
>
asRenderTargetProxy
(
)
-
>
isMSAADirty
(
)
)
;
}
if
(
GrMipMapped
:
:
kYes
=
=
mipMapped
)
{
SkASSERT
(
p
-
>
asTextureProxy
(
)
&
&
!
p
-
>
asTextureProxy
(
)
-
>
mipMapsAreDirty
(
)
)
;
}
}
)
;
#
endif
onFlushRenderTask
-
>
prepare
(
&
flushState
)
;
}
}
#
if
0
SkDEBUGCODE
(
SkDebugf
(
"
onFlush
renderTasks
:
"
)
)
;
for
(
const
auto
&
onFlushRenderTask
:
fOnFlushRenderTasks
)
{
SkDEBUGCODE
(
onFlushRenderTask
-
>
dump
(
)
;
)
}
SkDEBUGCODE
(
SkDebugf
(
"
Normal
renderTasks
:
"
)
)
;
for
(
int
i
=
0
;
i
<
fRenderTasks
.
count
(
)
;
+
+
i
)
{
SkDEBUGCODE
(
fRenderTasks
[
i
]
-
>
dump
(
)
;
)
}
#
endif
int
startIndex
stopIndex
;
bool
flushed
=
false
;
{
GrResourceAllocator
alloc
(
resourceProvider
SkDEBUGCODE
(
fDAG
.
numRenderTasks
(
)
)
)
;
for
(
int
i
=
0
;
i
<
fDAG
.
numRenderTasks
(
)
;
+
+
i
)
{
if
(
fDAG
.
renderTask
(
i
)
)
{
fDAG
.
renderTask
(
i
)
-
>
gatherProxyIntervals
(
&
alloc
)
;
}
alloc
.
markEndOfOpsTask
(
i
)
;
}
alloc
.
determineRecyclability
(
)
;
GrResourceAllocator
:
:
AssignError
error
=
GrResourceAllocator
:
:
AssignError
:
:
kNoError
;
int
numRenderTasksExecuted
=
0
;
while
(
alloc
.
assign
(
&
startIndex
&
stopIndex
&
error
)
)
{
if
(
GrResourceAllocator
:
:
AssignError
:
:
kFailedProxyInstantiation
=
=
error
)
{
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
GrRenderTask
*
renderTask
=
fDAG
.
renderTask
(
i
)
;
if
(
!
renderTask
)
{
continue
;
}
if
(
!
renderTask
-
>
isInstantiated
(
)
)
{
continue
;
}
renderTask
-
>
handleInternalAllocationFailure
(
)
;
}
}
if
(
this
-
>
executeRenderTasks
(
startIndex
stopIndex
&
flushState
&
numRenderTasksExecuted
)
)
{
flushed
=
true
;
}
}
}
#
ifdef
SK_DEBUG
for
(
int
i
=
0
;
i
<
fDAG
.
numRenderTasks
(
)
;
+
+
i
)
{
SkASSERT
(
!
fDAG
.
renderTask
(
i
)
|
|
fDAG
.
renderTask
(
i
)
-
>
unique
(
)
)
;
}
#
endif
fDAG
.
reset
(
)
;
this
-
>
clearDDLTargets
(
)
;
#
ifdef
SK_DEBUG
GrOpMemoryPool
*
opMemoryPool
=
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
;
opMemoryPool
-
>
isEmpty
(
)
;
#
endif
GrSemaphoresSubmitted
result
=
gpu
-
>
finishFlush
(
proxies
numProxies
access
info
externalRequests
)
;
if
(
flushed
)
{
resourceCache
-
>
purgeAsNeeded
(
)
;
flushed
=
false
;
}
for
(
GrOnFlushCallbackObject
*
onFlushCBObject
:
fOnFlushCBObjects
)
{
onFlushCBObject
-
>
postFlush
(
fTokenTracker
.
nextTokenToFlush
(
)
fFlushingRenderTaskIDs
.
begin
(
)
fFlushingRenderTaskIDs
.
count
(
)
)
;
flushed
=
true
;
}
if
(
flushed
)
{
resourceCache
-
>
purgeAsNeeded
(
)
;
}
fFlushingRenderTaskIDs
.
reset
(
)
;
fFlushing
=
false
;
return
result
;
}
bool
GrDrawingManager
:
:
executeRenderTasks
(
int
startIndex
int
stopIndex
GrOpFlushState
*
flushState
int
*
numRenderTasksExecuted
)
{
SkASSERT
(
startIndex
<
=
stopIndex
&
&
stopIndex
<
=
fDAG
.
numRenderTasks
(
)
)
;
#
if
GR_FLUSH_TIME_OP_SPEW
SkDebugf
(
"
Flushing
opsTask
:
%
d
to
%
d
out
of
[
%
d
%
d
]
\
n
"
startIndex
stopIndex
0
fDAG
.
numRenderTasks
(
)
)
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
if
(
fDAG
.
renderTask
(
i
)
)
{
fDAG
.
renderTask
(
i
)
-
>
dump
(
true
)
;
}
}
#
endif
bool
anyRenderTasksExecuted
=
false
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
GrRenderTask
*
renderTask
=
fDAG
.
renderTask
(
i
)
;
if
(
!
renderTask
|
|
!
renderTask
-
>
isInstantiated
(
)
)
{
continue
;
}
SkASSERT
(
renderTask
-
>
deferredProxiesAreInstantiated
(
)
)
;
renderTask
-
>
prepare
(
flushState
)
;
}
flushState
-
>
preExecuteDraws
(
)
;
static
constexpr
int
kMaxRenderTasksBeforeFlush
=
100
;
for
(
sk_sp
<
GrRenderTask
>
&
onFlushRenderTask
:
fOnFlushRenderTasks
)
{
if
(
!
onFlushRenderTask
-
>
execute
(
flushState
)
)
{
SkDebugf
(
"
WARNING
:
onFlushRenderTask
failed
to
execute
.
\
n
"
)
;
}
SkASSERT
(
onFlushRenderTask
-
>
unique
(
)
)
;
onFlushRenderTask
=
nullptr
;
(
*
numRenderTasksExecuted
)
+
+
;
if
(
*
numRenderTasksExecuted
>
=
kMaxRenderTasksBeforeFlush
)
{
flushState
-
>
gpu
(
)
-
>
finishFlush
(
nullptr
0
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
GrFlushInfo
(
)
GrPrepareForExternalIORequests
(
)
)
;
*
numRenderTasksExecuted
=
0
;
}
}
fOnFlushRenderTasks
.
reset
(
)
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
GrRenderTask
*
renderTask
=
fDAG
.
renderTask
(
i
)
;
if
(
!
renderTask
|
|
!
renderTask
-
>
isInstantiated
(
)
)
{
continue
;
}
if
(
renderTask
-
>
execute
(
flushState
)
)
{
anyRenderTasksExecuted
=
true
;
}
(
*
numRenderTasksExecuted
)
+
+
;
if
(
*
numRenderTasksExecuted
>
=
kMaxRenderTasksBeforeFlush
)
{
flushState
-
>
gpu
(
)
-
>
finishFlush
(
nullptr
0
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
GrFlushInfo
(
)
GrPrepareForExternalIORequests
(
)
)
;
*
numRenderTasksExecuted
=
0
;
}
}
SkASSERT
(
!
flushState
-
>
opsRenderPass
(
)
)
;
SkASSERT
(
fTokenTracker
.
nextDrawToken
(
)
=
=
fTokenTracker
.
nextTokenToFlush
(
)
)
;
flushState
-
>
reset
(
)
;
fDAG
.
removeRenderTasks
(
startIndex
stopIndex
)
;
return
anyRenderTasksExecuted
;
}
GrSemaphoresSubmitted
GrDrawingManager
:
:
flushSurfaces
(
GrSurfaceProxy
*
proxies
[
]
int
numProxies
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
{
if
(
this
-
>
wasAbandoned
(
)
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
numProxies
>
=
0
)
;
SkASSERT
(
!
numProxies
|
|
proxies
)
;
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
GrGpu
*
gpu
=
direct
-
>
priv
(
)
.
getGpu
(
)
;
if
(
!
gpu
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
GrSemaphoresSubmitted
result
=
this
-
>
flush
(
proxies
numProxies
access
info
GrPrepareForExternalIORequests
(
)
)
;
for
(
int
i
=
0
;
i
<
numProxies
;
+
+
i
)
{
GrSurfaceProxy
*
proxy
=
proxies
[
i
]
;
if
(
!
proxy
-
>
isInstantiated
(
)
)
{
return
result
;
}
if
(
proxy
-
>
requiresManualMSAAResolve
(
)
)
{
auto
*
rtProxy
=
proxy
-
>
asRenderTargetProxy
(
)
;
SkASSERT
(
rtProxy
)
;
if
(
rtProxy
-
>
isMSAADirty
(
)
)
{
SkASSERT
(
rtProxy
-
>
peekRenderTarget
(
)
)
;
gpu
-
>
resolveRenderTarget
(
rtProxy
-
>
peekRenderTarget
(
)
rtProxy
-
>
msaaDirtyRect
(
)
rtProxy
-
>
origin
(
)
GrGpu
:
:
ForExternalIO
:
:
kYes
)
;
rtProxy
-
>
markMSAAResolved
(
)
;
}
}
if
(
auto
*
textureProxy
=
proxy
-
>
asTextureProxy
(
)
)
{
if
(
textureProxy
-
>
mipMapsAreDirty
(
)
)
{
SkASSERT
(
textureProxy
-
>
peekTexture
(
)
)
;
gpu
-
>
regenerateMipMapLevels
(
textureProxy
-
>
peekTexture
(
)
)
;
textureProxy
-
>
markMipMapsClean
(
)
;
}
}
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
return
result
;
}
void
GrDrawingManager
:
:
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
onFlushCBObject
)
{
fOnFlushCBObjects
.
push_back
(
onFlushCBObject
)
;
}
#
if
GR_TEST_UTILS
void
GrDrawingManager
:
:
testingOnly_removeOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
cb
)
{
int
n
=
std
:
:
find
(
fOnFlushCBObjects
.
begin
(
)
fOnFlushCBObjects
.
end
(
)
cb
)
-
fOnFlushCBObjects
.
begin
(
)
;
SkASSERT
(
n
<
fOnFlushCBObjects
.
count
(
)
)
;
fOnFlushCBObjects
.
removeShuffle
(
n
)
;
}
#
endif
void
GrDrawingManager
:
:
moveRenderTasksToDDL
(
SkDeferredDisplayList
*
ddl
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
fDAG
.
closeAll
(
fContext
-
>
priv
(
)
.
caps
(
)
)
;
fActiveOpsTask
=
nullptr
;
fDAG
.
swap
(
&
ddl
-
>
fRenderTasks
)
;
for
(
auto
renderTask
:
ddl
-
>
fRenderTasks
)
{
renderTask
-
>
prePrepare
(
fContext
)
;
}
if
(
fPathRendererChain
)
{
if
(
auto
ccpr
=
fPathRendererChain
-
>
getCoverageCountingPathRenderer
(
)
)
{
ddl
-
>
fPendingPaths
=
ccpr
-
>
detachPendingPaths
(
)
;
}
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrDrawingManager
:
:
copyRenderTasksFromDDL
(
const
SkDeferredDisplayList
*
ddl
GrRenderTargetProxy
*
newDest
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
if
(
fActiveOpsTask
)
{
fActiveOpsTask
-
>
makeClosed
(
*
fContext
-
>
priv
(
)
.
caps
(
)
)
;
fActiveOpsTask
=
nullptr
;
}
this
-
>
addDDLTarget
(
newDest
)
;
ddl
-
>
fLazyProxyData
-
>
fReplayDest
=
newDest
;
if
(
ddl
-
>
fPendingPaths
.
size
(
)
)
{
GrCoverageCountingPathRenderer
*
ccpr
=
this
-
>
getCoverageCountingPathRenderer
(
)
;
ccpr
-
>
mergePendingPaths
(
ddl
-
>
fPendingPaths
)
;
}
fDAG
.
add
(
ddl
-
>
fRenderTasks
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
#
ifdef
SK_DEBUG
void
GrDrawingManager
:
:
validate
(
)
const
{
if
(
fDAG
.
sortingRenderTasks
(
)
&
&
fReduceOpsTaskSplitting
)
{
SkASSERT
(
!
fActiveOpsTask
)
;
}
else
{
if
(
fActiveOpsTask
)
{
SkASSERT
(
!
fDAG
.
empty
(
)
)
;
SkASSERT
(
!
fActiveOpsTask
-
>
isClosed
(
)
)
;
SkASSERT
(
fActiveOpsTask
=
=
fDAG
.
back
(
)
)
;
}
for
(
int
i
=
0
;
i
<
fDAG
.
numRenderTasks
(
)
;
+
+
i
)
{
if
(
fActiveOpsTask
!
=
fDAG
.
renderTask
(
i
)
)
{
bool
isActiveResolveTask
=
fActiveOpsTask
&
&
fActiveOpsTask
-
>
fTextureResolveTask
=
=
fDAG
.
renderTask
(
i
)
;
SkASSERT
(
isActiveResolveTask
|
|
fDAG
.
renderTask
(
i
)
-
>
isClosed
(
)
)
;
}
}
if
(
!
fDAG
.
empty
(
)
&
&
!
fDAG
.
back
(
)
-
>
isClosed
(
)
)
{
SkASSERT
(
fActiveOpsTask
=
=
fDAG
.
back
(
)
)
;
}
}
}
#
endif
void
GrDrawingManager
:
:
closeRenderTasksForNewRenderTask
(
GrSurfaceProxy
*
target
)
{
if
(
target
&
&
fDAG
.
sortingRenderTasks
(
)
&
&
fReduceOpsTaskSplitting
)
{
if
(
GrRenderTask
*
lastRenderTask
=
target
-
>
getLastRenderTask
(
)
)
{
lastRenderTask
-
>
closeThoseWhoDependOnMe
(
*
fContext
-
>
priv
(
)
.
caps
(
)
)
;
}
}
else
if
(
fActiveOpsTask
)
{
fActiveOpsTask
-
>
makeClosed
(
*
fContext
-
>
priv
(
)
.
caps
(
)
)
;
fActiveOpsTask
=
nullptr
;
}
}
sk_sp
<
GrOpsTask
>
GrDrawingManager
:
:
newOpsTask
(
sk_sp
<
GrRenderTargetProxy
>
rtp
bool
managedOpsTask
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
fContext
)
;
this
-
>
closeRenderTasksForNewRenderTask
(
rtp
.
get
(
)
)
;
sk_sp
<
GrOpsTask
>
opsTask
(
new
GrOpsTask
(
fContext
-
>
priv
(
)
.
refOpMemoryPool
(
)
rtp
fContext
-
>
priv
(
)
.
auditTrail
(
)
)
)
;
SkASSERT
(
rtp
-
>
getLastRenderTask
(
)
=
=
opsTask
.
get
(
)
)
;
if
(
managedOpsTask
)
{
fDAG
.
add
(
opsTask
)
;
if
(
!
fDAG
.
sortingRenderTasks
(
)
|
|
!
fReduceOpsTaskSplitting
)
{
fActiveOpsTask
=
opsTask
.
get
(
)
;
}
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
return
opsTask
;
}
GrTextureResolveRenderTask
*
GrDrawingManager
:
:
newTextureResolveRenderTask
(
const
GrCaps
&
caps
)
{
return
static_cast
<
GrTextureResolveRenderTask
*
>
(
fDAG
.
addBeforeLast
(
sk_make_sp
<
GrTextureResolveRenderTask
>
(
)
)
)
;
}
void
GrDrawingManager
:
:
newWaitRenderTask
(
sk_sp
<
GrSurfaceProxy
>
proxy
std
:
:
unique_ptr
<
sk_sp
<
GrSemaphore
>
[
]
>
semaphores
int
numSemaphores
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
fContext
)
;
const
GrCaps
&
caps
=
*
fContext
-
>
priv
(
)
.
caps
(
)
;
sk_sp
<
GrWaitRenderTask
>
waitTask
=
sk_make_sp
<
GrWaitRenderTask
>
(
proxy
std
:
:
move
(
semaphores
)
numSemaphores
)
;
if
(
fReduceOpsTaskSplitting
)
{
GrRenderTask
*
lastTask
=
proxy
-
>
getLastRenderTask
(
)
;
if
(
lastTask
&
&
!
lastTask
-
>
isClosed
(
)
)
{
waitTask
-
>
addDependenciesFromOtherTask
(
lastTask
)
;
lastTask
-
>
addDependency
(
waitTask
.
get
(
)
)
;
}
else
{
if
(
lastTask
)
{
waitTask
-
>
addDependency
(
lastTask
)
;
}
proxy
-
>
setLastRenderTask
(
waitTask
.
get
(
)
)
;
}
fDAG
.
add
(
waitTask
)
;
}
else
{
if
(
fActiveOpsTask
&
&
(
fActiveOpsTask
-
>
fTarget
=
=
proxy
)
)
{
SkASSERT
(
proxy
-
>
getLastRenderTask
(
)
=
=
fActiveOpsTask
)
;
fDAG
.
addBeforeLast
(
waitTask
)
;
waitTask
-
>
addDependenciesFromOtherTask
(
fActiveOpsTask
)
;
fActiveOpsTask
-
>
addDependency
(
waitTask
.
get
(
)
)
;
}
else
{
if
(
GrRenderTask
*
lastTask
=
proxy
-
>
getLastRenderTask
(
)
)
{
waitTask
-
>
addDependency
(
lastTask
)
;
}
proxy
-
>
setLastRenderTask
(
waitTask
.
get
(
)
)
;
this
-
>
closeRenderTasksForNewRenderTask
(
proxy
.
get
(
)
)
;
fDAG
.
add
(
waitTask
)
;
}
}
waitTask
-
>
makeClosed
(
caps
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrDrawingManager
:
:
newTransferFromRenderTask
(
sk_sp
<
GrSurfaceProxy
>
srcProxy
const
SkIRect
&
srcRect
GrColorType
surfaceColorType
GrColorType
dstColorType
sk_sp
<
GrGpuBuffer
>
dstBuffer
size_t
dstOffset
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
fContext
)
;
this
-
>
closeRenderTasksForNewRenderTask
(
nullptr
)
;
GrRenderTask
*
task
=
fDAG
.
add
(
sk_make_sp
<
GrTransferFromRenderTask
>
(
srcProxy
srcRect
surfaceColorType
dstColorType
std
:
:
move
(
dstBuffer
)
dstOffset
)
)
;
const
GrCaps
&
caps
=
*
fContext
-
>
priv
(
)
.
caps
(
)
;
task
-
>
addDependency
(
srcProxy
.
get
(
)
GrMipMapped
:
:
kNo
GrTextureResolveManager
(
this
)
caps
)
;
task
-
>
makeClosed
(
caps
)
;
SkASSERT
(
!
fActiveOpsTask
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
bool
GrDrawingManager
:
:
newCopyRenderTask
(
sk_sp
<
GrSurfaceProxy
>
srcProxy
const
SkIRect
&
srcRect
sk_sp
<
GrSurfaceProxy
>
dstProxy
const
SkIPoint
&
dstPoint
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
fContext
)
;
this
-
>
closeRenderTasksForNewRenderTask
(
dstProxy
.
get
(
)
)
;
const
GrCaps
&
caps
=
*
fContext
-
>
priv
(
)
.
caps
(
)
;
GrRenderTask
*
task
=
fDAG
.
add
(
GrCopyRenderTask
:
:
Make
(
srcProxy
srcRect
dstProxy
dstPoint
&
caps
)
)
;
if
(
!
task
)
{
return
false
;
}
task
-
>
addDependency
(
srcProxy
.
get
(
)
GrMipMapped
:
:
kNo
GrTextureResolveManager
(
this
)
caps
)
;
task
-
>
makeClosed
(
caps
)
;
SkASSERT
(
!
fActiveOpsTask
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
return
true
;
}
GrTextContext
*
GrDrawingManager
:
:
getTextContext
(
)
{
if
(
!
fTextContext
)
{
fTextContext
=
GrTextContext
:
:
Make
(
fOptionsForTextContext
)
;
}
return
fTextContext
.
get
(
)
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
.
reset
(
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
)
;
}
GrPathRenderer
*
pr
=
fPathRendererChain
-
>
getPathRenderer
(
args
drawType
stencilSupport
)
;
if
(
!
pr
&
&
allowSW
)
{
auto
swPR
=
this
-
>
getSoftwarePathRenderer
(
)
;
if
(
GrPathRenderer
:
:
CanDrawPath
:
:
kNo
!
=
swPR
-
>
canDrawPath
(
args
)
)
{
pr
=
swPR
;
}
}
return
pr
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getSoftwarePathRenderer
(
)
{
if
(
!
fSoftwarePathRenderer
)
{
fSoftwarePathRenderer
.
reset
(
new
GrSoftwarePathRenderer
(
fContext
-
>
priv
(
)
.
proxyProvider
(
)
fOptionsForPathRendererChain
.
fAllowPathMaskCaching
)
)
;
}
return
fSoftwarePathRenderer
.
get
(
)
;
}
GrCoverageCountingPathRenderer
*
GrDrawingManager
:
:
getCoverageCountingPathRenderer
(
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
.
reset
(
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
)
;
}
return
fPathRendererChain
-
>
getCoverageCountingPathRenderer
(
)
;
}
void
GrDrawingManager
:
:
flushIfNecessary
(
)
{
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
return
;
}
auto
resourceCache
=
direct
-
>
priv
(
)
.
getResourceCache
(
)
;
if
(
resourceCache
&
&
resourceCache
-
>
requestsFlush
(
)
)
{
this
-
>
flush
(
nullptr
0
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
GrFlushInfo
(
)
GrPrepareForExternalIORequests
(
)
)
;
resourceCache
-
>
purgeAsNeeded
(
)
;
}
}
std
:
:
unique_ptr
<
GrRenderTargetContext
>
GrDrawingManager
:
:
makeRenderTargetContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
bool
managedOpsTask
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asRenderTargetProxy
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrRenderTargetProxy
>
renderTargetProxy
(
sk_ref_sp
(
sProxy
-
>
asRenderTargetProxy
(
)
)
)
;
return
std
:
:
unique_ptr
<
GrRenderTargetContext
>
(
new
GrRenderTargetContext
(
fContext
std
:
:
move
(
renderTargetProxy
)
colorType
std
:
:
move
(
colorSpace
)
surfaceProps
managedOpsTask
)
)
;
}
std
:
:
unique_ptr
<
GrTextureContext
>
GrDrawingManager
:
:
makeTextureContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
GrColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asTextureProxy
(
)
)
{
return
nullptr
;
}
SkASSERT
(
!
sProxy
-
>
asRenderTargetProxy
(
)
)
;
sk_sp
<
GrTextureProxy
>
textureProxy
(
sk_ref_sp
(
sProxy
-
>
asTextureProxy
(
)
)
)
;
return
std
:
:
unique_ptr
<
GrTextureContext
>
(
new
GrTextureContext
(
fContext
std
:
:
move
(
textureProxy
)
colorType
alphaType
std
:
:
move
(
colorSpace
)
)
)
;
}
