#
include
"
GrDrawContext
.
h
"
#
include
"
GrDrawingManager
.
h
"
#
include
"
GrDrawTarget
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSoftwarePathRenderer
.
h
"
#
include
"
SkTTopoSort
.
h
"
#
include
"
text
/
GrAtlasTextContext
.
h
"
#
include
"
text
/
GrStencilAndCoverTextContext
.
h
"
void
GrDrawingManager
:
:
cleanup
(
)
{
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
makeClosed
(
)
;
fDrawTargets
[
i
]
-
>
clearRT
(
)
;
fDrawTargets
[
i
]
-
>
reset
(
)
;
fDrawTargets
[
i
]
-
>
unref
(
)
;
}
fDrawTargets
.
reset
(
)
;
delete
fNVPRTextContext
;
fNVPRTextContext
=
nullptr
;
for
(
int
i
=
0
;
i
<
kNumPixelGeometries
;
+
+
i
)
{
delete
fTextContexts
[
i
]
[
0
]
;
fTextContexts
[
i
]
[
0
]
=
nullptr
;
delete
fTextContexts
[
i
]
[
1
]
;
fTextContexts
[
i
]
[
1
]
=
nullptr
;
}
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
}
GrDrawingManager
:
:
~
GrDrawingManager
(
)
{
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
abandon
(
)
{
fAbandoned
=
true
;
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
freeGpuResources
(
)
{
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
}
void
GrDrawingManager
:
:
reset
(
)
{
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
reset
(
)
;
}
fFlushState
.
reset
(
)
;
}
void
GrDrawingManager
:
:
flush
(
)
{
if
(
fFlushing
)
{
return
;
}
fFlushing
=
true
;
SkDEBUGCODE
(
bool
result
=
)
SkTTopoSort
<
GrDrawTarget
GrDrawTarget
:
:
TopoSortTraits
>
(
&
fDrawTargets
)
;
SkASSERT
(
result
)
;
#
if
0
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
SkDEBUGCODE
(
fDrawTargets
[
i
]
-
>
dump
(
)
;
)
}
#
endif
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
prepareBatches
(
&
fFlushState
)
;
}
fFlushState
.
preIssueDraws
(
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
drawBatches
(
&
fFlushState
)
;
}
SkASSERT
(
fFlushState
.
lastFlushedToken
(
)
=
=
fFlushState
.
currentToken
(
)
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
reset
(
)
;
#
ifdef
ENABLE_MDB
fDrawTargets
[
i
]
-
>
unref
(
)
;
#
endif
}
#
ifndef
ENABLE_MDB
if
(
fDrawTargets
.
count
(
)
)
{
SkASSERT
(
fDrawTargets
.
count
(
)
=
=
1
)
;
fDrawTargets
[
0
]
-
>
resetFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
#
else
fDrawTargets
.
reset
(
)
;
#
endif
fFlushState
.
reset
(
)
;
fFlushing
=
false
;
}
GrTextContext
*
GrDrawingManager
:
:
textContext
(
const
SkSurfaceProps
&
props
GrRenderTarget
*
rt
)
{
if
(
this
-
>
abandoned
(
)
)
{
return
nullptr
;
}
SkASSERT
(
props
.
pixelGeometry
(
)
<
kNumPixelGeometries
)
;
bool
useDIF
=
props
.
isUseDeviceIndependentFonts
(
)
;
if
(
useDIF
&
&
fContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
&
&
rt
-
>
isStencilBufferMultisampled
(
)
)
{
GrStencilAttachment
*
sb
=
fContext
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
)
;
if
(
sb
)
{
if
(
!
fNVPRTextContext
)
{
fNVPRTextContext
=
GrStencilAndCoverTextContext
:
:
Create
(
fContext
props
)
;
}
return
fNVPRTextContext
;
}
}
if
(
!
fTextContexts
[
props
.
pixelGeometry
(
)
]
[
useDIF
]
)
{
fTextContexts
[
props
.
pixelGeometry
(
)
]
[
useDIF
]
=
GrAtlasTextContext
:
:
Create
(
fContext
props
)
;
}
return
fTextContexts
[
props
.
pixelGeometry
(
)
]
[
useDIF
]
;
}
GrDrawTarget
*
GrDrawingManager
:
:
newDrawTarget
(
GrRenderTarget
*
rt
)
{
SkASSERT
(
fContext
)
;
#
ifndef
ENABLE_MDB
if
(
fDrawTargets
.
count
(
)
)
{
SkASSERT
(
fDrawTargets
.
count
(
)
=
=
1
)
;
rt
-
>
setLastDrawTarget
(
fDrawTargets
[
0
]
)
;
return
SkRef
(
fDrawTargets
[
0
]
)
;
}
#
endif
GrDrawTarget
*
dt
=
new
GrDrawTarget
(
rt
fContext
-
>
getGpu
(
)
fContext
-
>
resourceProvider
(
)
fContext
-
>
getAuditTrail
(
)
fOptionsForDrawTargets
)
;
*
fDrawTargets
.
append
(
)
=
dt
;
return
SkRef
(
dt
)
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
=
new
GrPathRendererChain
(
fContext
)
;
}
GrPathRenderer
*
pr
=
fPathRendererChain
-
>
getPathRenderer
(
args
drawType
stencilSupport
)
;
if
(
!
pr
&
&
allowSW
)
{
if
(
!
fSoftwarePathRenderer
)
{
fSoftwarePathRenderer
=
new
GrSoftwarePathRenderer
(
fContext
)
;
}
pr
=
fSoftwarePathRenderer
;
}
return
pr
;
}
GrDrawContext
*
GrDrawingManager
:
:
drawContext
(
GrRenderTarget
*
rt
const
SkSurfaceProps
*
surfaceProps
)
{
if
(
this
-
>
abandoned
(
)
)
{
return
nullptr
;
}
return
new
GrDrawContext
(
this
rt
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
;
}
