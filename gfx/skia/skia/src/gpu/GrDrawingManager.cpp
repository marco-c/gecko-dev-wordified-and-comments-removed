#
include
"
GrDrawingManager
.
h
"
#
include
"
GrBackendSemaphore
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrOnFlushResourceProvider
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrResourceAllocator
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSoftwarePathRenderer
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTextureContext
.
h
"
#
include
"
GrTextureOpList
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTextureProxyPriv
.
h
"
#
include
"
SkDeferredDisplayList
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkTTopoSort
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
text
/
GrAtlasTextContext
.
h
"
#
ifndef
SK_DISABLE_RENDER_TARGET_SORTING
#
define
SK_DISABLE_RENDER_TARGET_SORTING
#
endif
#
ifdef
SK_DISABLE_RENDER_TARGET_SORTING
static
const
bool
kDefaultSortRenderTargets
=
false
;
#
else
static
const
bool
kDefaultSortRenderTargets
=
true
;
#
endif
GrDrawingManager
:
:
GrDrawingManager
(
GrContext
*
context
const
GrPathRendererChain
:
:
Options
&
optionsForPathRendererChain
const
GrAtlasTextContext
:
:
Options
&
optionsForAtlasTextContext
GrSingleOwner
*
singleOwner
GrContextOptions
:
:
Enable
sortRenderTargets
)
:
fContext
(
context
)
fOptionsForPathRendererChain
(
optionsForPathRendererChain
)
fOptionsForAtlasTextContext
(
optionsForAtlasTextContext
)
fSingleOwner
(
singleOwner
)
fAbandoned
(
false
)
fAtlasTextContext
(
nullptr
)
fPathRendererChain
(
nullptr
)
fSoftwarePathRenderer
(
nullptr
)
fFlushing
(
false
)
{
if
(
GrContextOptions
:
:
Enable
:
:
kNo
=
=
sortRenderTargets
)
{
fSortRenderTargets
=
false
;
}
else
if
(
GrContextOptions
:
:
Enable
:
:
kYes
=
=
sortRenderTargets
)
{
fSortRenderTargets
=
true
;
}
else
{
fSortRenderTargets
=
kDefaultSortRenderTargets
;
}
}
void
GrDrawingManager
:
:
cleanup
(
)
{
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
if
(
!
fOpLists
[
i
]
-
>
unique
(
)
)
{
fOpLists
[
i
]
-
>
endFlush
(
)
;
}
}
fOpLists
.
reset
(
)
;
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
fOnFlushCBObjects
.
reset
(
)
;
}
GrDrawingManager
:
:
~
GrDrawingManager
(
)
{
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
abandon
(
)
{
fAbandoned
=
true
;
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
freeGpuResources
(
)
{
for
(
int
i
=
fOnFlushCBObjects
.
count
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
fOnFlushCBObjects
[
i
]
-
>
retainOnFreeGpuResources
(
)
)
{
fOnFlushCBObjects
.
removeShuffle
(
i
)
;
}
}
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
}
GrSemaphoresSubmitted
GrDrawingManager
:
:
internalFlush
(
GrSurfaceProxy
*
GrResourceCache
:
:
FlushType
type
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrDrawingManager
"
"
internalFlush
"
fContext
)
;
if
(
fFlushing
|
|
this
-
>
wasAbandoned
(
)
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
fFlushing
=
true
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
}
#
ifdef
SK_DEBUG
if
(
fOpLists
.
count
(
)
)
{
GrRenderTargetOpList
*
prevOpList
=
fOpLists
[
0
]
-
>
asRenderTargetOpList
(
)
;
for
(
int
i
=
1
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
GrRenderTargetOpList
*
curOpList
=
fOpLists
[
i
]
-
>
asRenderTargetOpList
(
)
;
if
(
prevOpList
&
&
curOpList
)
{
SkASSERT
(
prevOpList
-
>
fTarget
.
get
(
)
!
=
curOpList
-
>
fTarget
.
get
(
)
)
;
}
prevOpList
=
curOpList
;
}
}
#
endif
if
(
fSortRenderTargets
)
{
SkDEBUGCODE
(
bool
result
=
)
SkTTopoSort
<
GrOpList
GrOpList
:
:
TopoSortTraits
>
(
&
fOpLists
)
;
SkASSERT
(
result
)
;
}
GrGpu
*
gpu
=
fContext
-
>
contextPriv
(
)
.
getGpu
(
)
;
GrOpFlushState
flushState
(
gpu
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
&
fTokenTracker
)
;
GrOnFlushResourceProvider
onFlushProvider
(
this
)
;
if
(
!
fOnFlushCBObjects
.
empty
(
)
)
{
fFlushingOpListIDs
.
reset
(
fOpLists
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fFlushingOpListIDs
[
i
]
=
fOpLists
[
i
]
-
>
uniqueID
(
)
;
}
SkSTArray
<
4
sk_sp
<
GrRenderTargetContext
>
>
renderTargetContexts
;
for
(
GrOnFlushCallbackObject
*
onFlushCBObject
:
fOnFlushCBObjects
)
{
onFlushCBObject
-
>
preFlush
(
&
onFlushProvider
fFlushingOpListIDs
.
begin
(
)
fFlushingOpListIDs
.
count
(
)
&
renderTargetContexts
)
;
for
(
const
sk_sp
<
GrRenderTargetContext
>
&
rtc
:
renderTargetContexts
)
{
sk_sp
<
GrRenderTargetOpList
>
onFlushOpList
=
sk_ref_sp
(
rtc
-
>
getRTOpList
(
)
)
;
if
(
!
onFlushOpList
)
{
continue
;
}
#
ifdef
SK_DEBUG
onFlushOpList
-
>
visitProxies_debugOnly
(
[
]
(
GrSurfaceProxy
*
p
)
{
SkASSERT
(
!
p
-
>
asTextureProxy
(
)
|
|
!
p
-
>
asTextureProxy
(
)
-
>
texPriv
(
)
.
isDeferred
(
)
)
;
SkASSERT
(
GrSurfaceProxy
:
:
LazyState
:
:
kNot
=
=
p
-
>
lazyInstantiationState
(
)
)
;
}
)
;
#
endif
onFlushOpList
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
onFlushOpList
-
>
prepare
(
&
flushState
)
;
fOnFlushCBOpLists
.
push_back
(
std
:
:
move
(
onFlushOpList
)
)
;
}
renderTargetContexts
.
reset
(
)
;
}
}
#
if
0
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
SkDEBUGCODE
(
fOpLists
[
i
]
-
>
dump
(
)
;
)
}
#
endif
int
startIndex
stopIndex
;
bool
flushed
=
false
;
{
GrResourceAllocator
alloc
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
gatherProxyIntervals
(
&
alloc
)
;
alloc
.
markEndOfOpList
(
i
)
;
}
GrResourceAllocator
:
:
AssignError
error
=
GrResourceAllocator
:
:
AssignError
:
:
kNoError
;
while
(
alloc
.
assign
(
&
startIndex
&
stopIndex
&
error
)
)
{
if
(
GrResourceAllocator
:
:
AssignError
:
:
kFailedProxyInstantiation
=
=
error
)
{
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
fOpLists
[
i
]
-
>
purgeOpsWithUninstantiatedProxies
(
)
;
}
}
if
(
this
-
>
executeOpLists
(
startIndex
stopIndex
&
flushState
)
)
{
flushed
=
true
;
}
}
}
fOpLists
.
reset
(
)
;
GrSemaphoresSubmitted
result
=
gpu
-
>
finishFlush
(
numSemaphores
backendSemaphores
)
;
if
(
flushed
|
|
type
=
=
GrResourceCache
:
:
FlushType
:
:
kCacheRequested
)
{
fContext
-
>
contextPriv
(
)
.
getResourceCache
(
)
-
>
notifyFlushOccurred
(
type
)
;
}
for
(
GrOnFlushCallbackObject
*
onFlushCBObject
:
fOnFlushCBObjects
)
{
onFlushCBObject
-
>
postFlush
(
fTokenTracker
.
nextTokenToFlush
(
)
fFlushingOpListIDs
.
begin
(
)
fFlushingOpListIDs
.
count
(
)
)
;
}
fFlushingOpListIDs
.
reset
(
)
;
fFlushing
=
false
;
return
result
;
}
bool
GrDrawingManager
:
:
executeOpLists
(
int
startIndex
int
stopIndex
GrOpFlushState
*
flushState
)
{
SkASSERT
(
startIndex
<
=
stopIndex
&
&
stopIndex
<
=
fOpLists
.
count
(
)
)
;
GrResourceProvider
*
resourceProvider
=
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
;
bool
anyOpListsExecuted
=
false
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
if
(
!
fOpLists
[
i
]
)
{
continue
;
}
if
(
resourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
if
(
!
fOpLists
[
i
]
-
>
isInstantiated
(
)
)
{
fOpLists
[
i
]
=
nullptr
;
continue
;
}
}
else
{
if
(
!
fOpLists
[
i
]
-
>
instantiate
(
resourceProvider
)
)
{
SkDebugf
(
"
OpList
failed
to
instantiate
.
\
n
"
)
;
fOpLists
[
i
]
=
nullptr
;
continue
;
}
}
fOpLists
[
i
]
-
>
instantiateDeferredProxies
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
;
fOpLists
[
i
]
-
>
prepare
(
flushState
)
;
}
flushState
-
>
preExecuteDraws
(
)
;
for
(
sk_sp
<
GrOpList
>
&
onFlushOpList
:
fOnFlushCBOpLists
)
{
if
(
!
onFlushOpList
-
>
execute
(
flushState
)
)
{
SkDebugf
(
"
WARNING
:
onFlushOpList
failed
to
execute
.
\
n
"
)
;
}
SkASSERT
(
onFlushOpList
-
>
unique
(
)
)
;
onFlushOpList
=
nullptr
;
}
fOnFlushCBOpLists
.
reset
(
)
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
if
(
!
fOpLists
[
i
]
)
{
continue
;
}
if
(
fOpLists
[
i
]
-
>
execute
(
flushState
)
)
{
anyOpListsExecuted
=
true
;
}
}
SkASSERT
(
!
flushState
-
>
commandBuffer
(
)
)
;
SkASSERT
(
fTokenTracker
.
nextDrawToken
(
)
=
=
fTokenTracker
.
nextTokenToFlush
(
)
)
;
flushState
-
>
reset
(
)
;
for
(
int
i
=
startIndex
;
i
<
stopIndex
;
+
+
i
)
{
if
(
!
fOpLists
[
i
]
)
{
continue
;
}
if
(
!
fOpLists
[
i
]
-
>
unique
(
)
)
{
fOpLists
[
i
]
-
>
endFlush
(
)
;
}
fOpLists
[
i
]
=
nullptr
;
}
return
anyOpListsExecuted
;
}
GrSemaphoresSubmitted
GrDrawingManager
:
:
prepareSurfaceForExternalIO
(
GrSurfaceProxy
*
proxy
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
{
if
(
this
-
>
wasAbandoned
(
)
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
SkASSERT
(
proxy
)
;
GrSemaphoresSubmitted
result
=
GrSemaphoresSubmitted
:
:
kNo
;
if
(
proxy
-
>
priv
(
)
.
hasPendingIO
(
)
|
|
numSemaphores
)
{
result
=
this
-
>
flush
(
proxy
numSemaphores
backendSemaphores
)
;
}
if
(
!
proxy
-
>
instantiate
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
)
{
return
result
;
}
GrGpu
*
gpu
=
fContext
-
>
contextPriv
(
)
.
getGpu
(
)
;
GrSurface
*
surface
=
proxy
-
>
priv
(
)
.
peekSurface
(
)
;
if
(
gpu
&
&
surface
-
>
asRenderTarget
(
)
)
{
gpu
-
>
resolveRenderTarget
(
surface
-
>
asRenderTarget
(
)
)
;
}
return
result
;
}
void
GrDrawingManager
:
:
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
onFlushCBObject
)
{
fOnFlushCBObjects
.
push_back
(
onFlushCBObject
)
;
}
void
GrDrawingManager
:
:
moveOpListsToDDL
(
SkDeferredDisplayList
*
ddl
)
{
#
ifndef
SK_RASTER_RECORDER_IMPLEMENTATION
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
}
ddl
-
>
fOpLists
=
std
:
:
move
(
fOpLists
)
;
#
endif
}
void
GrDrawingManager
:
:
copyOpListsFromDDL
(
const
SkDeferredDisplayList
*
ddl
GrRenderTargetProxy
*
newDest
)
{
#
ifndef
SK_RASTER_RECORDER_IMPLEMENTATION
ddl
-
>
fLazyProxyData
-
>
fReplayDest
=
newDest
;
fOpLists
.
push_back_n
(
ddl
-
>
fOpLists
.
count
(
)
ddl
-
>
fOpLists
.
begin
(
)
)
;
#
endif
}
sk_sp
<
GrRenderTargetOpList
>
GrDrawingManager
:
:
newRTOpList
(
GrRenderTargetProxy
*
rtp
bool
managedOpList
)
{
SkASSERT
(
fContext
)
;
if
(
!
fOpLists
.
empty
(
)
)
{
fOpLists
.
back
(
)
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
}
auto
resourceProvider
=
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
;
sk_sp
<
GrRenderTargetOpList
>
opList
(
new
GrRenderTargetOpList
(
rtp
resourceProvider
fContext
-
>
getAuditTrail
(
)
)
)
;
SkASSERT
(
rtp
-
>
getLastOpList
(
)
=
=
opList
.
get
(
)
)
;
if
(
managedOpList
)
{
fOpLists
.
push_back
(
)
=
opList
;
}
return
opList
;
}
sk_sp
<
GrTextureOpList
>
GrDrawingManager
:
:
newTextureOpList
(
GrTextureProxy
*
textureProxy
)
{
SkASSERT
(
fContext
)
;
if
(
!
fOpLists
.
empty
(
)
)
{
fOpLists
.
back
(
)
-
>
makeClosed
(
*
fContext
-
>
caps
(
)
)
;
}
sk_sp
<
GrTextureOpList
>
opList
(
new
GrTextureOpList
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
textureProxy
fContext
-
>
getAuditTrail
(
)
)
)
;
SkASSERT
(
textureProxy
-
>
getLastOpList
(
)
=
=
opList
.
get
(
)
)
;
fOpLists
.
push_back
(
)
=
opList
;
return
opList
;
}
GrAtlasTextContext
*
GrDrawingManager
:
:
getAtlasTextContext
(
)
{
if
(
!
fAtlasTextContext
)
{
fAtlasTextContext
=
GrAtlasTextContext
:
:
Make
(
fOptionsForAtlasTextContext
)
;
}
return
fAtlasTextContext
.
get
(
)
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
=
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
;
}
GrPathRenderer
*
pr
=
fPathRendererChain
-
>
getPathRenderer
(
args
drawType
stencilSupport
)
;
if
(
!
pr
&
&
allowSW
)
{
if
(
!
fSoftwarePathRenderer
)
{
fSoftwarePathRenderer
=
new
GrSoftwarePathRenderer
(
fContext
-
>
contextPriv
(
)
.
proxyProvider
(
)
fOptionsForPathRendererChain
.
fAllowPathMaskCaching
)
;
}
if
(
GrPathRenderer
:
:
CanDrawPath
:
:
kNo
!
=
fSoftwarePathRenderer
-
>
canDrawPath
(
args
)
)
{
pr
=
fSoftwarePathRenderer
;
}
}
return
pr
;
}
GrCoverageCountingPathRenderer
*
GrDrawingManager
:
:
getCoverageCountingPathRenderer
(
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
=
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
;
}
return
fPathRendererChain
-
>
getCoverageCountingPathRenderer
(
)
;
}
sk_sp
<
GrRenderTargetContext
>
GrDrawingManager
:
:
makeRenderTargetContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
bool
managedOpList
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asRenderTargetProxy
(
)
)
{
return
nullptr
;
}
if
(
!
SkSurface_Gpu
:
:
Valid
(
fContext
sProxy
-
>
config
(
)
colorSpace
.
get
(
)
)
)
{
SkDEBUGFAIL
(
"
Invalid
config
and
colorspace
combination
"
)
;
return
nullptr
;
}
sk_sp
<
GrRenderTargetProxy
>
rtp
(
sk_ref_sp
(
sProxy
-
>
asRenderTargetProxy
(
)
)
)
;
return
sk_sp
<
GrRenderTargetContext
>
(
new
GrRenderTargetContext
(
fContext
this
std
:
:
move
(
rtp
)
std
:
:
move
(
colorSpace
)
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
managedOpList
)
)
;
}
sk_sp
<
GrTextureContext
>
GrDrawingManager
:
:
makeTextureContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
sk_sp
<
SkColorSpace
>
colorSpace
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asTextureProxy
(
)
)
{
return
nullptr
;
}
if
(
!
SkSurface_Gpu
:
:
Valid
(
fContext
sProxy
-
>
config
(
)
colorSpace
.
get
(
)
)
)
{
SkDEBUGFAIL
(
"
Invalid
config
and
colorspace
combination
"
)
;
return
nullptr
;
}
SkASSERT
(
!
sProxy
-
>
asRenderTargetProxy
(
)
)
;
sk_sp
<
GrTextureProxy
>
textureProxy
(
sk_ref_sp
(
sProxy
-
>
asTextureProxy
(
)
)
)
;
return
sk_sp
<
GrTextureContext
>
(
new
GrTextureContext
(
fContext
this
std
:
:
move
(
textureProxy
)
std
:
:
move
(
colorSpace
)
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
