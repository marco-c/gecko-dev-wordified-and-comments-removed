#
include
"
GrDrawingManager
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrDrawTarget
.
h
"
#
include
"
GrPathRenderingDrawContext
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSoftwarePathRenderer
.
h
"
#
include
"
GrSurfacePriv
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkTTopoSort
.
h
"
#
include
"
instanced
/
InstancedRendering
.
h
"
#
include
"
text
/
GrAtlasTextContext
.
h
"
#
include
"
text
/
GrStencilAndCoverTextContext
.
h
"
using
gr_instanced
:
:
InstancedRendering
;
void
GrDrawingManager
:
:
cleanup
(
)
{
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
makeClosed
(
)
;
fDrawTargets
[
i
]
-
>
clearRT
(
)
;
fDrawTargets
[
i
]
-
>
reset
(
)
;
fDrawTargets
[
i
]
-
>
unref
(
)
;
}
fDrawTargets
.
reset
(
)
;
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
}
GrDrawingManager
:
:
~
GrDrawingManager
(
)
{
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
abandon
(
)
{
fAbandoned
=
true
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
if
(
GrCaps
:
:
InstancedSupport
:
:
kNone
!
=
fContext
-
>
caps
(
)
-
>
instancedSupport
(
)
)
{
InstancedRendering
*
ir
=
fDrawTargets
[
i
]
-
>
instancedRendering
(
)
;
ir
-
>
resetGpuResources
(
InstancedRendering
:
:
ResetType
:
:
kAbandon
)
;
}
}
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
freeGpuResources
(
)
{
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
if
(
GrCaps
:
:
InstancedSupport
:
:
kNone
!
=
fContext
-
>
caps
(
)
-
>
instancedSupport
(
)
)
{
InstancedRendering
*
ir
=
fDrawTargets
[
i
]
-
>
instancedRendering
(
)
;
ir
-
>
resetGpuResources
(
InstancedRendering
:
:
ResetType
:
:
kDestroy
)
;
}
}
}
void
GrDrawingManager
:
:
reset
(
)
{
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
reset
(
)
;
}
fFlushState
.
reset
(
)
;
}
void
GrDrawingManager
:
:
internalFlush
(
GrResourceCache
:
:
FlushType
type
)
{
if
(
fFlushing
|
|
this
-
>
wasAbandoned
(
)
)
{
return
;
}
fFlushing
=
true
;
bool
flushed
=
false
;
SkDEBUGCODE
(
bool
result
=
)
SkTTopoSort
<
GrDrawTarget
GrDrawTarget
:
:
TopoSortTraits
>
(
&
fDrawTargets
)
;
SkASSERT
(
result
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
prepareBatches
(
&
fFlushState
)
;
}
#
if
0
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
SkDEBUGCODE
(
fDrawTargets
[
i
]
-
>
dump
(
)
;
)
}
#
endif
fFlushState
.
preIssueDraws
(
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
if
(
fDrawTargets
[
i
]
-
>
drawBatches
(
&
fFlushState
)
)
{
flushed
=
true
;
}
}
SkASSERT
(
fFlushState
.
nextDrawToken
(
)
=
=
fFlushState
.
nextTokenToFlush
(
)
)
;
for
(
int
i
=
0
;
i
<
fDrawTargets
.
count
(
)
;
+
+
i
)
{
fDrawTargets
[
i
]
-
>
reset
(
)
;
#
ifdef
ENABLE_MDB
fDrawTargets
[
i
]
-
>
unref
(
)
;
#
endif
}
#
ifndef
ENABLE_MDB
if
(
fDrawTargets
.
count
(
)
)
{
SkASSERT
(
fDrawTargets
.
count
(
)
=
=
1
)
;
fDrawTargets
[
0
]
-
>
resetFlag
(
GrDrawTarget
:
:
kWasOutput_Flag
)
;
}
#
else
fDrawTargets
.
reset
(
)
;
#
endif
fFlushState
.
reset
(
)
;
if
(
flushed
|
|
type
=
=
GrResourceCache
:
:
FlushType
:
:
kCacheRequested
)
{
fContext
-
>
getResourceCache
(
)
-
>
notifyFlushOccurred
(
type
)
;
}
fFlushing
=
false
;
}
void
GrDrawingManager
:
:
prepareSurfaceForExternalIO
(
GrSurface
*
surface
)
{
if
(
this
-
>
wasAbandoned
(
)
)
{
return
;
}
SkASSERT
(
surface
)
;
SkASSERT
(
surface
-
>
getContext
(
)
=
=
fContext
)
;
if
(
surface
-
>
surfacePriv
(
)
.
hasPendingIO
(
)
)
{
this
-
>
flush
(
)
;
}
GrRenderTarget
*
rt
=
surface
-
>
asRenderTarget
(
)
;
if
(
fContext
-
>
getGpu
(
)
&
&
rt
)
{
fContext
-
>
getGpu
(
)
-
>
resolveRenderTarget
(
rt
)
;
}
}
GrDrawTarget
*
GrDrawingManager
:
:
newDrawTarget
(
GrRenderTarget
*
rt
)
{
SkASSERT
(
fContext
)
;
#
ifndef
ENABLE_MDB
if
(
fDrawTargets
.
count
(
)
)
{
SkASSERT
(
fDrawTargets
.
count
(
)
=
=
1
)
;
rt
-
>
setLastDrawTarget
(
fDrawTargets
[
0
]
)
;
return
SkRef
(
fDrawTargets
[
0
]
)
;
}
#
endif
GrDrawTarget
*
dt
=
new
GrDrawTarget
(
rt
fContext
-
>
getGpu
(
)
fContext
-
>
resourceProvider
(
)
fContext
-
>
getAuditTrail
(
)
fOptionsForDrawTargets
)
;
*
fDrawTargets
.
append
(
)
=
dt
;
return
SkRef
(
dt
)
;
}
GrAtlasTextContext
*
GrDrawingManager
:
:
getAtlasTextContext
(
)
{
if
(
!
fAtlasTextContext
)
{
fAtlasTextContext
.
reset
(
GrAtlasTextContext
:
:
Create
(
)
)
;
}
return
fAtlasTextContext
.
get
(
)
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
=
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
;
}
GrPathRenderer
*
pr
=
fPathRendererChain
-
>
getPathRenderer
(
args
drawType
stencilSupport
)
;
if
(
!
pr
&
&
allowSW
)
{
if
(
!
fSoftwarePathRenderer
)
{
fSoftwarePathRenderer
=
new
GrSoftwarePathRenderer
(
fContext
-
>
textureProvider
(
)
fOptionsForPathRendererChain
.
fAllowPathMaskCaching
)
;
}
pr
=
fSoftwarePathRenderer
;
}
return
pr
;
}
sk_sp
<
GrDrawContext
>
GrDrawingManager
:
:
makeDrawContext
(
sk_sp
<
GrRenderTarget
>
rt
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
)
{
if
(
this
-
>
wasAbandoned
(
)
)
{
return
nullptr
;
}
if
(
colorSpace
&
&
!
SkSurface_Gpu
:
:
Valid
(
fContext
rt
-
>
config
(
)
colorSpace
.
get
(
)
)
)
{
SkDEBUGFAIL
(
"
Invalid
config
and
colorspace
combination
"
)
;
return
nullptr
;
}
bool
useDIF
=
false
;
if
(
surfaceProps
)
{
useDIF
=
surfaceProps
-
>
isUseDeviceIndependentFonts
(
)
;
}
if
(
useDIF
&
&
fContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
&
&
rt
-
>
isStencilBufferMultisampled
(
)
)
{
GrStencilAttachment
*
sb
=
fContext
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
.
get
(
)
)
;
if
(
sb
)
{
return
sk_sp
<
GrDrawContext
>
(
new
GrPathRenderingDrawContext
(
fContext
this
std
:
:
move
(
rt
)
std
:
:
move
(
colorSpace
)
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
}
return
sk_sp
<
GrDrawContext
>
(
new
GrDrawContext
(
fContext
this
std
:
:
move
(
rt
)
std
:
:
move
(
colorSpace
)
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
