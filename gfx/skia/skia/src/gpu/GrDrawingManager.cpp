#
include
"
GrDrawingManager
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrPathRenderingRenderTargetContext
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSoftwarePathRenderer
.
h
"
#
include
"
GrSurfacePriv
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTextureContext
.
h
"
#
include
"
GrTextureOpList
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkTTopoSort
.
h
"
#
include
"
text
/
GrAtlasTextContext
.
h
"
#
include
"
text
/
GrStencilAndCoverTextContext
.
h
"
void
GrDrawingManager
:
:
cleanup
(
)
{
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
makeClosed
(
)
;
fOpLists
[
i
]
-
>
clearTarget
(
)
;
fOpLists
[
i
]
-
>
reset
(
)
;
fOpLists
[
i
]
-
>
unref
(
)
;
}
fOpLists
.
reset
(
)
;
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
}
GrDrawingManager
:
:
~
GrDrawingManager
(
)
{
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
abandon
(
)
{
fAbandoned
=
true
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
abandonGpuResources
(
)
;
}
this
-
>
cleanup
(
)
;
}
void
GrDrawingManager
:
:
freeGpuResources
(
)
{
delete
fPathRendererChain
;
fPathRendererChain
=
nullptr
;
SkSafeSetNull
(
fSoftwarePathRenderer
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
freeGpuResources
(
)
;
}
}
void
GrDrawingManager
:
:
reset
(
)
{
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
reset
(
)
;
}
fFlushState
.
reset
(
)
;
}
void
GrDrawingManager
:
:
internalFlush
(
GrSurfaceProxy
*
GrResourceCache
:
:
FlushType
type
)
{
if
(
fFlushing
|
|
this
-
>
wasAbandoned
(
)
)
{
return
;
}
fFlushing
=
true
;
bool
flushed
=
false
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
makeClosed
(
)
;
}
SkDEBUGCODE
(
bool
result
=
)
SkTTopoSort
<
GrOpList
GrOpList
:
:
TopoSortTraits
>
(
&
fOpLists
)
;
SkASSERT
(
result
)
;
GrPreFlushResourceProvider
preFlushProvider
(
this
)
;
if
(
fPreFlushCBObjects
.
count
(
)
)
{
SkAutoSTArray
<
1
uint32_t
>
opListIds
(
fOpLists
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
opListIds
[
i
]
=
fOpLists
[
i
]
-
>
uniqueID
(
)
;
}
SkSTArray
<
1
sk_sp
<
GrRenderTargetContext
>
>
renderTargetContexts
;
for
(
int
i
=
0
;
i
<
fPreFlushCBObjects
.
count
(
)
;
+
+
i
)
{
fPreFlushCBObjects
[
i
]
-
>
preFlush
(
&
preFlushProvider
opListIds
.
get
(
)
opListIds
.
count
(
)
&
renderTargetContexts
)
;
if
(
!
renderTargetContexts
.
count
(
)
)
{
continue
;
}
for
(
int
j
=
0
;
j
<
renderTargetContexts
.
count
(
)
;
+
+
j
)
{
GrRenderTargetOpList
*
opList
=
renderTargetContexts
[
j
]
-
>
getOpList
(
)
;
if
(
!
opList
)
{
continue
;
}
SkDEBUGCODE
(
opList
-
>
validateTargetsSingleRenderTarget
(
)
)
;
opList
-
>
prepareOps
(
&
fFlushState
)
;
if
(
!
opList
-
>
executeOps
(
&
fFlushState
)
)
{
continue
;
}
}
renderTargetContexts
.
reset
(
)
;
}
}
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
prepareOps
(
&
fFlushState
)
;
}
#
if
0
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
SkDEBUGCODE
(
fOpLists
[
i
]
-
>
dump
(
)
;
)
}
#
endif
fFlushState
.
preIssueDraws
(
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
if
(
fOpLists
[
i
]
-
>
executeOps
(
&
fFlushState
)
)
{
flushed
=
true
;
}
}
SkASSERT
(
fFlushState
.
nextDrawToken
(
)
=
=
fFlushState
.
nextTokenToFlush
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpLists
.
count
(
)
;
+
+
i
)
{
fOpLists
[
i
]
-
>
reset
(
)
;
#
ifdef
ENABLE_MDB
fOpLists
[
i
]
-
>
unref
(
)
;
#
endif
}
#
ifndef
ENABLE_MDB
if
(
fOpLists
.
count
(
)
)
{
SkASSERT
(
fOpLists
.
count
(
)
=
=
1
)
;
fOpLists
[
0
]
-
>
resetFlag
(
GrOpList
:
:
kWasOutput_Flag
)
;
}
#
else
fOpLists
.
reset
(
)
;
#
endif
fFlushState
.
reset
(
)
;
if
(
flushed
|
|
type
=
=
GrResourceCache
:
:
FlushType
:
:
kCacheRequested
)
{
fContext
-
>
getResourceCache
(
)
-
>
notifyFlushOccurred
(
type
)
;
}
fFlushing
=
false
;
}
void
GrDrawingManager
:
:
prepareSurfaceForExternalIO
(
GrSurfaceProxy
*
proxy
)
{
if
(
this
-
>
wasAbandoned
(
)
)
{
return
;
}
SkASSERT
(
proxy
)
;
if
(
proxy
-
>
priv
(
)
.
hasPendingIO
(
)
)
{
this
-
>
flush
(
proxy
)
;
}
GrSurface
*
surface
=
proxy
-
>
instantiate
(
fContext
-
>
resourceProvider
(
)
)
;
if
(
!
surface
)
{
return
;
}
if
(
fContext
-
>
getGpu
(
)
&
&
surface
-
>
asRenderTarget
(
)
)
{
fContext
-
>
getGpu
(
)
-
>
resolveRenderTarget
(
surface
-
>
asRenderTarget
(
)
)
;
}
}
void
GrDrawingManager
:
:
addPreFlushCallbackObject
(
sk_sp
<
GrPreFlushCallbackObject
>
preFlushCBObject
)
{
fPreFlushCBObjects
.
push_back
(
preFlushCBObject
)
;
}
GrRenderTargetOpList
*
GrDrawingManager
:
:
newOpList
(
GrRenderTargetProxy
*
rtp
)
{
SkASSERT
(
fContext
)
;
#
ifndef
ENABLE_MDB
if
(
fOpLists
.
count
(
)
)
{
SkASSERT
(
fOpLists
.
count
(
)
=
=
1
)
;
rtp
-
>
setLastOpList
(
fOpLists
[
0
]
)
;
return
SkRef
(
(
GrRenderTargetOpList
*
)
fOpLists
[
0
]
)
;
}
#
endif
GrRenderTargetOpList
*
opList
=
new
GrRenderTargetOpList
(
rtp
fContext
-
>
getGpu
(
)
fContext
-
>
resourceProvider
(
)
fContext
-
>
getAuditTrail
(
)
fOptionsForOpLists
)
;
*
fOpLists
.
append
(
)
=
opList
;
return
SkRef
(
opList
)
;
}
GrTextureOpList
*
GrDrawingManager
:
:
newOpList
(
GrTextureProxy
*
textureProxy
)
{
SkASSERT
(
fContext
)
;
GrTextureOpList
*
opList
=
new
GrTextureOpList
(
textureProxy
fContext
-
>
getGpu
(
)
fContext
-
>
getAuditTrail
(
)
)
;
#
ifndef
ENABLE_MDB
return
opList
;
#
else
*
fOpLists
.
append
(
)
=
opList
;
return
SkRef
(
opList
)
;
#
endif
}
GrAtlasTextContext
*
GrDrawingManager
:
:
getAtlasTextContext
(
)
{
if
(
!
fAtlasTextContext
)
{
fAtlasTextContext
.
reset
(
GrAtlasTextContext
:
:
Create
(
)
)
;
}
return
fAtlasTextContext
.
get
(
)
;
}
GrPathRenderer
*
GrDrawingManager
:
:
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
)
{
if
(
!
fPathRendererChain
)
{
fPathRendererChain
=
new
GrPathRendererChain
(
fContext
fOptionsForPathRendererChain
)
;
}
GrPathRenderer
*
pr
=
fPathRendererChain
-
>
getPathRenderer
(
args
drawType
stencilSupport
)
;
if
(
!
pr
&
&
allowSW
)
{
if
(
!
fSoftwarePathRenderer
)
{
fSoftwarePathRenderer
=
new
GrSoftwarePathRenderer
(
fContext
-
>
resourceProvider
(
)
fOptionsForPathRendererChain
.
fAllowPathMaskCaching
)
;
}
if
(
fSoftwarePathRenderer
-
>
canDrawPath
(
args
)
)
{
pr
=
fSoftwarePathRenderer
;
}
}
return
pr
;
}
sk_sp
<
GrRenderTargetContext
>
GrDrawingManager
:
:
makeRenderTargetContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asRenderTargetProxy
(
)
)
{
return
nullptr
;
}
if
(
colorSpace
&
&
!
SkSurface_Gpu
:
:
Valid
(
fContext
sProxy
-
>
config
(
)
colorSpace
.
get
(
)
)
)
{
SkDEBUGFAIL
(
"
Invalid
config
and
colorspace
combination
"
)
;
return
nullptr
;
}
sk_sp
<
GrRenderTargetProxy
>
rtp
(
sk_ref_sp
(
sProxy
-
>
asRenderTargetProxy
(
)
)
)
;
bool
useDIF
=
false
;
if
(
surfaceProps
)
{
useDIF
=
surfaceProps
-
>
isUseDeviceIndependentFonts
(
)
;
}
if
(
useDIF
&
&
fContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
&
&
rtp
-
>
isStencilBufferMultisampled
(
)
)
{
sk_sp
<
GrRenderTarget
>
rt
(
sk_ref_sp
(
rtp
-
>
instantiate
(
fContext
-
>
resourceProvider
(
)
)
)
)
;
if
(
!
rt
)
{
return
nullptr
;
}
GrStencilAttachment
*
sb
=
fContext
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
.
get
(
)
)
;
if
(
sb
)
{
return
sk_sp
<
GrRenderTargetContext
>
(
new
GrPathRenderingRenderTargetContext
(
fContext
this
std
:
:
move
(
rtp
)
std
:
:
move
(
colorSpace
)
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
}
return
sk_sp
<
GrRenderTargetContext
>
(
new
GrRenderTargetContext
(
fContext
this
std
:
:
move
(
rtp
)
std
:
:
move
(
colorSpace
)
surfaceProps
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
sk_sp
<
GrTextureContext
>
GrDrawingManager
:
:
makeTextureContext
(
sk_sp
<
GrSurfaceProxy
>
sProxy
sk_sp
<
SkColorSpace
>
colorSpace
)
{
if
(
this
-
>
wasAbandoned
(
)
|
|
!
sProxy
-
>
asTextureProxy
(
)
)
{
return
nullptr
;
}
if
(
colorSpace
&
&
!
SkSurface_Gpu
:
:
Valid
(
fContext
sProxy
-
>
config
(
)
colorSpace
.
get
(
)
)
)
{
SkDEBUGFAIL
(
"
Invalid
config
and
colorspace
combination
"
)
;
return
nullptr
;
}
SkASSERT
(
!
sProxy
-
>
asRenderTargetProxy
(
)
)
;
sk_sp
<
GrTextureProxy
>
textureProxy
(
sk_ref_sp
(
sProxy
-
>
asTextureProxy
(
)
)
)
;
return
sk_sp
<
GrTextureContext
>
(
new
GrTextureContext
(
fContext
this
std
:
:
move
(
textureProxy
)
std
:
:
move
(
colorSpace
)
fContext
-
>
getAuditTrail
(
)
fSingleOwner
)
)
;
}
