#
include
"
InstanceProcessor
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
glsl
/
GrGLSLVarying
.
h
"
namespace
gr_instanced
{
GrCaps
:
:
InstancedSupport
InstanceProcessor
:
:
CheckSupport
(
const
GrShaderCaps
&
shaderCaps
const
GrCaps
&
caps
)
{
if
(
!
shaderCaps
.
canUseAnyFunctionInShader
(
)
|
|
!
shaderCaps
.
flatInterpolationSupport
(
)
|
|
!
shaderCaps
.
integerSupport
(
)
|
|
0
=
=
shaderCaps
.
maxVertexSamplers
(
)
|
|
!
caps
.
shaderCaps
(
)
-
>
texelBufferSupport
(
)
|
|
caps
.
maxVertexAttributes
(
)
<
kNumAttribs
)
{
return
GrCaps
:
:
InstancedSupport
:
:
kNone
;
}
if
(
!
caps
.
sampleLocationsSupport
(
)
|
|
!
shaderCaps
.
sampleVariablesSupport
(
)
|
|
!
shaderCaps
.
shaderDerivativeSupport
(
)
)
{
return
GrCaps
:
:
InstancedSupport
:
:
kBasic
;
}
if
(
0
=
=
caps
.
maxRasterSamples
(
)
|
|
!
shaderCaps
.
sampleMaskOverrideCoverageSupport
(
)
)
{
return
GrCaps
:
:
InstancedSupport
:
:
kMultisampled
;
}
return
GrCaps
:
:
InstancedSupport
:
:
kMixedSampled
;
}
InstanceProcessor
:
:
InstanceProcessor
(
OpInfo
opInfo
GrBuffer
*
paramsBuffer
)
:
fOpInfo
(
opInfo
)
{
this
-
>
initClassID
<
InstanceProcessor
>
(
)
;
this
-
>
addVertexAttrib
(
"
shapeCoords
"
kVec2f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
this
-
>
addVertexAttrib
(
"
vertexAttrs
"
kInt_GrVertexAttribType
)
;
this
-
>
addVertexAttrib
(
"
instanceInfo
"
kUint_GrVertexAttribType
)
;
this
-
>
addVertexAttrib
(
"
shapeMatrixX
"
kVec3f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
this
-
>
addVertexAttrib
(
"
shapeMatrixY
"
kVec3f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
this
-
>
addVertexAttrib
(
"
color
"
kVec4f_GrVertexAttribType
kLow_GrSLPrecision
)
;
this
-
>
addVertexAttrib
(
"
localRect
"
kVec4f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
GR_STATIC_ASSERT
(
0
=
=
(
int
)
Attrib
:
:
kShapeCoords
)
;
GR_STATIC_ASSERT
(
1
=
=
(
int
)
Attrib
:
:
kVertexAttrs
)
;
GR_STATIC_ASSERT
(
2
=
=
(
int
)
Attrib
:
:
kInstanceInfo
)
;
GR_STATIC_ASSERT
(
3
=
=
(
int
)
Attrib
:
:
kShapeMatrixX
)
;
GR_STATIC_ASSERT
(
4
=
=
(
int
)
Attrib
:
:
kShapeMatrixY
)
;
GR_STATIC_ASSERT
(
5
=
=
(
int
)
Attrib
:
:
kColor
)
;
GR_STATIC_ASSERT
(
6
=
=
(
int
)
Attrib
:
:
kLocalRect
)
;
GR_STATIC_ASSERT
(
7
=
=
kNumAttribs
)
;
if
(
fOpInfo
.
fHasParams
)
{
SkASSERT
(
paramsBuffer
)
;
fParamsAccess
.
reset
(
kRGBA_float_GrPixelConfig
paramsBuffer
kVertex_GrShaderFlag
)
;
this
-
>
addBufferAccess
(
&
fParamsAccess
)
;
}
if
(
GrAATypeIsHW
(
fOpInfo
.
aaType
(
)
)
)
{
if
(
!
fOpInfo
.
isSimpleRects
(
)
|
|
GrAAType
:
:
kMixedSamples
=
=
fOpInfo
.
aaType
(
)
)
{
this
-
>
setWillUseSampleLocations
(
)
;
}
}
}
class
GLSLInstanceProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
;
private
:
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
transformIter
)
override
{
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
class
VertexInputs
;
class
Backend
;
class
BackendNonAA
;
class
BackendCoverage
;
class
BackendMultisample
;
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
GrGLSLPrimitiveProcessor
*
InstanceProcessor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
return
new
GLSLInstanceProcessor
(
)
;
}
class
GLSLInstanceProcessor
:
:
VertexInputs
{
public
:
VertexInputs
(
const
InstanceProcessor
&
instProc
GrGLSLVertexBuilder
*
vertexBuilder
)
:
fInstProc
(
instProc
)
fVertexBuilder
(
vertexBuilder
)
{
}
void
initParams
(
const
SamplerHandle
paramsBuffer
)
{
fParamsBuffer
=
paramsBuffer
;
fVertexBuilder
-
>
codeAppendf
(
"
highp
int
paramsIdx
=
int
(
%
s
&
0x
%
x
)
;
"
this
-
>
attr
(
Attrib
:
:
kInstanceInfo
)
kParamsIdx_InfoMask
)
;
}
const
char
*
attr
(
Attrib
attr
)
const
{
return
fInstProc
.
getAttrib
(
(
int
)
attr
)
.
fName
;
}
void
fetchNextParam
(
GrSLType
type
=
kVec4f_GrSLType
)
const
{
SkASSERT
(
fParamsBuffer
.
isValid
(
)
)
;
switch
(
type
)
{
case
kVec2f_GrSLType
:
case
kVec3f_GrSLType
:
case
kVec4f_GrSLType
:
break
;
default
:
fVertexBuilder
-
>
codeAppendf
(
"
%
s
(
"
GrGLSLTypeString
(
type
)
)
;
}
fVertexBuilder
-
>
appendTexelFetch
(
fParamsBuffer
"
paramsIdx
+
+
"
)
;
switch
(
type
)
{
case
kVec2f_GrSLType
:
fVertexBuilder
-
>
codeAppend
(
"
.
xy
"
)
;
break
;
case
kVec3f_GrSLType
:
fVertexBuilder
-
>
codeAppend
(
"
.
xyz
"
)
;
break
;
case
kVec4f_GrSLType
:
break
;
default
:
fVertexBuilder
-
>
codeAppend
(
"
)
"
)
;
}
}
void
skipParams
(
unsigned
n
)
const
{
SkASSERT
(
fParamsBuffer
.
isValid
(
)
)
;
fVertexBuilder
-
>
codeAppendf
(
"
paramsIdx
+
=
%
u
;
"
n
)
;
}
private
:
const
InstanceProcessor
&
fInstProc
;
GrGLSLVertexBuilder
*
fVertexBuilder
;
SamplerHandle
fParamsBuffer
;
}
;
class
GLSLInstanceProcessor
:
:
Backend
{
public
:
static
Backend
*
SK_WARN_UNUSED_RESULT
Create
(
const
GrPipeline
&
OpInfo
const
VertexInputs
&
)
;
virtual
~
Backend
(
)
{
}
void
init
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
;
virtual
void
setupRect
(
GrGLSLVertexBuilder
*
)
=
0
;
virtual
void
setupOval
(
GrGLSLVertexBuilder
*
)
=
0
;
void
setupRRect
(
GrGLSLVertexBuilder
*
int
*
usedShapeDefinitions
)
;
void
initInnerShape
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
;
virtual
void
setupInnerRect
(
GrGLSLVertexBuilder
*
)
=
0
;
virtual
void
setupInnerOval
(
GrGLSLVertexBuilder
*
)
=
0
;
void
setupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
)
;
const
char
*
outShapeCoords
(
)
{
return
fModifiedShapeCoords
?
fModifiedShapeCoords
:
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
;
}
void
emitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
const
char
*
outColor
)
;
protected
:
Backend
(
OpInfo
opInfo
const
VertexInputs
&
inputs
)
:
fOpInfo
(
opInfo
)
fInputs
(
inputs
)
fModifiesCoverage
(
false
)
fModifiesColor
(
false
)
fNeedsNeighborRadii
(
false
)
fColor
(
kVec4f_GrSLType
)
fTriangleIsArc
(
kInt_GrSLType
)
fArcCoords
(
kVec2f_GrSLType
)
fInnerShapeCoords
(
kVec2f_GrSLType
)
fInnerRRect
(
kVec4f_GrSLType
)
fModifiedShapeCoords
(
nullptr
)
{
if
(
fOpInfo
.
fShapeTypes
&
kRRect_ShapesMask
)
{
fModifiedShapeCoords
=
"
adjustedShapeCoords
"
;
}
}
virtual
void
onInit
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
=
0
;
virtual
void
adjustRRectVertices
(
GrGLSLVertexBuilder
*
)
;
virtual
void
onSetupRRect
(
GrGLSLVertexBuilder
*
)
{
}
virtual
void
onInitInnerShape
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
=
0
;
virtual
void
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
)
=
0
;
virtual
void
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
const
char
*
outColor
)
=
0
;
void
setupSimpleRadii
(
GrGLSLVertexBuilder
*
)
;
void
setupNinePatchRadii
(
GrGLSLVertexBuilder
*
)
;
void
setupComplexRadii
(
GrGLSLVertexBuilder
*
)
;
const
OpInfo
fOpInfo
;
const
VertexInputs
&
fInputs
;
bool
fModifiesCoverage
;
bool
fModifiesColor
;
bool
fNeedsNeighborRadii
;
GrGLSLVertToFrag
fColor
;
GrGLSLVertToFrag
fTriangleIsArc
;
GrGLSLVertToFrag
fArcCoords
;
GrGLSLVertToFrag
fInnerShapeCoords
;
GrGLSLVertToFrag
fInnerRRect
;
const
char
*
fModifiedShapeCoords
;
}
;
void
GLSLInstanceProcessor
:
:
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
{
const
GrPipeline
&
pipeline
=
args
.
fVertBuilder
-
>
getProgramBuilder
(
)
-
>
pipeline
(
)
;
const
InstanceProcessor
&
ip
=
args
.
fGP
.
cast
<
InstanceProcessor
>
(
)
;
GrGLSLUniformHandler
*
uniHandler
=
args
.
fUniformHandler
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
GrGLSLVertexBuilder
*
v
=
args
.
fVertBuilder
;
GrGLSLPPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
varyingHandler
-
>
emitAttributes
(
ip
)
;
VertexInputs
inputs
(
ip
v
)
;
if
(
ip
.
opInfo
(
)
.
fHasParams
)
{
SkASSERT
(
1
=
=
ip
.
numBuffers
(
)
)
;
inputs
.
initParams
(
args
.
fBufferSamplers
[
0
]
)
;
}
if
(
!
ip
.
opInfo
(
)
.
fHasPerspective
)
{
v
-
>
codeAppendf
(
"
mat2x3
shapeMatrix
=
mat2x3
(
%
s
%
s
)
;
"
inputs
.
attr
(
Attrib
:
:
kShapeMatrixX
)
inputs
.
attr
(
Attrib
:
:
kShapeMatrixY
)
)
;
}
else
{
v
-
>
defineConstantf
(
"
int
"
"
PERSPECTIVE_FLAG
"
"
0x
%
x
"
kPerspective_InfoFlag
)
;
v
-
>
codeAppendf
(
"
mat3
shapeMatrix
=
mat3
(
%
s
%
s
vec3
(
0
0
1
)
)
;
"
inputs
.
attr
(
Attrib
:
:
kShapeMatrixX
)
inputs
.
attr
(
Attrib
:
:
kShapeMatrixY
)
)
;
v
-
>
codeAppendf
(
"
if
(
0
!
=
(
%
s
&
PERSPECTIVE_FLAG
)
)
{
"
inputs
.
attr
(
Attrib
:
:
kInstanceInfo
)
)
;
v
-
>
codeAppend
(
"
shapeMatrix
[
2
]
=
"
)
;
inputs
.
fetchNextParam
(
kVec3f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
bool
hasSingleShapeType
=
SkIsPow2
(
ip
.
opInfo
(
)
.
fShapeTypes
)
;
if
(
!
hasSingleShapeType
)
{
v
-
>
defineConstant
(
"
SHAPE_TYPE_BIT
"
kShapeType_InfoBit
)
;
v
-
>
codeAppendf
(
"
uint
shapeType
=
%
s
>
>
SHAPE_TYPE_BIT
;
"
inputs
.
attr
(
Attrib
:
:
kInstanceInfo
)
)
;
}
std
:
:
unique_ptr
<
Backend
>
backend
(
Backend
:
:
Create
(
pipeline
ip
.
opInfo
(
)
inputs
)
)
;
backend
-
>
init
(
varyingHandler
v
)
;
int
usedShapeDefinitions
=
0
;
if
(
hasSingleShapeType
|
|
!
(
ip
.
opInfo
(
)
.
fShapeTypes
&
~
kRRect_ShapesMask
)
)
{
if
(
kRect_ShapeFlag
=
=
ip
.
opInfo
(
)
.
fShapeTypes
)
{
backend
-
>
setupRect
(
v
)
;
}
else
if
(
kOval_ShapeFlag
=
=
ip
.
opInfo
(
)
.
fShapeTypes
)
{
backend
-
>
setupOval
(
v
)
;
}
else
{
backend
-
>
setupRRect
(
v
&
usedShapeDefinitions
)
;
}
}
else
{
if
(
ip
.
opInfo
(
)
.
fShapeTypes
&
kRRect_ShapesMask
)
{
v
-
>
codeAppend
(
"
if
(
shapeType
>
=
SIMPLE_R_RECT_SHAPE_TYPE
)
{
"
)
;
backend
-
>
setupRRect
(
v
&
usedShapeDefinitions
)
;
v
-
>
codeAppend
(
"
}
"
)
;
usedShapeDefinitions
|
=
kSimpleRRect_ShapeFlag
;
}
if
(
ip
.
opInfo
(
)
.
fShapeTypes
&
kOval_ShapeFlag
)
{
if
(
ip
.
opInfo
(
)
.
fShapeTypes
&
kRect_ShapeFlag
)
{
if
(
ip
.
opInfo
(
)
.
fShapeTypes
&
kRRect_ShapesMask
)
{
v
-
>
codeAppend
(
"
else
"
)
;
}
v
-
>
codeAppend
(
"
if
(
OVAL_SHAPE_TYPE
=
=
shapeType
)
{
"
)
;
usedShapeDefinitions
|
=
kOval_ShapeFlag
;
}
else
{
v
-
>
codeAppend
(
"
else
{
"
)
;
}
backend
-
>
setupOval
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
if
(
ip
.
opInfo
(
)
.
fShapeTypes
&
kRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
else
{
"
)
;
backend
-
>
setupRect
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
}
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
)
{
bool
hasSingleInnerShapeType
=
SkIsPow2
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
)
;
if
(
!
hasSingleInnerShapeType
)
{
v
-
>
defineConstantf
(
"
int
"
"
INNER_SHAPE_TYPE_MASK
"
"
0x
%
x
"
kInnerShapeType_InfoMask
)
;
v
-
>
defineConstant
(
"
INNER_SHAPE_TYPE_BIT
"
kInnerShapeType_InfoBit
)
;
v
-
>
codeAppendf
(
"
uint
innerShapeType
=
(
(
%
s
&
INNER_SHAPE_TYPE_MASK
)
>
>
"
"
INNER_SHAPE_TYPE_BIT
)
;
"
inputs
.
attr
(
Attrib
:
:
kInstanceInfo
)
)
;
}
v
-
>
codeAppendf
(
"
vec4
outer
=
%
s
;
"
inputs
.
attr
(
Attrib
:
:
kLocalRect
)
)
;
v
-
>
codeAppend
(
"
vec4
inner
=
"
)
;
inputs
.
fetchNextParam
(
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
vec4
outer2Inner
=
vec4
(
outer
.
zw
-
outer
.
xy
"
"
outer
.
xy
+
outer
.
zw
-
inner
.
xy
-
inner
.
zw
)
/
"
"
(
inner
.
zw
-
inner
.
xy
)
.
xyxy
;
"
)
;
v
-
>
codeAppendf
(
"
vec2
innerShapeCoords
=
%
s
*
outer2Inner
.
xy
+
outer2Inner
.
zw
;
"
backend
-
>
outShapeCoords
(
)
)
;
backend
-
>
initInnerShape
(
varyingHandler
v
)
;
SkASSERT
(
0
=
=
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kRRect_ShapesMask
)
|
|
kSimpleRRect_ShapeFlag
=
=
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kRRect_ShapesMask
)
)
;
if
(
hasSingleInnerShapeType
)
{
if
(
kRect_ShapeFlag
=
=
ip
.
opInfo
(
)
.
fInnerShapeTypes
)
{
backend
-
>
setupInnerRect
(
v
)
;
}
else
if
(
kOval_ShapeFlag
=
=
ip
.
opInfo
(
)
.
fInnerShapeTypes
)
{
backend
-
>
setupInnerOval
(
v
)
;
}
else
{
backend
-
>
setupInnerSimpleRRect
(
v
)
;
}
}
else
{
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kSimpleRRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
if
(
SIMPLE_R_RECT_SHAPE_TYPE
=
=
innerShapeType
)
{
"
)
;
backend
-
>
setupInnerSimpleRRect
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
usedShapeDefinitions
|
=
kSimpleRRect_ShapeFlag
;
}
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kOval_ShapeFlag
)
{
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kRect_ShapeFlag
)
{
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kSimpleRRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
else
"
)
;
}
v
-
>
codeAppend
(
"
if
(
OVAL_SHAPE_TYPE
=
=
innerShapeType
)
{
"
)
;
usedShapeDefinitions
|
=
kOval_ShapeFlag
;
}
else
{
v
-
>
codeAppend
(
"
else
{
"
)
;
}
backend
-
>
setupInnerOval
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
if
(
ip
.
opInfo
(
)
.
fInnerShapeTypes
&
kRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
else
{
"
)
;
backend
-
>
setupInnerRect
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
}
}
if
(
usedShapeDefinitions
&
kOval_ShapeFlag
)
{
v
-
>
defineConstant
(
"
OVAL_SHAPE_TYPE
"
(
int
)
ShapeType
:
:
kOval
)
;
}
if
(
usedShapeDefinitions
&
kSimpleRRect_ShapeFlag
)
{
v
-
>
defineConstant
(
"
SIMPLE_R_RECT_SHAPE_TYPE
"
(
int
)
ShapeType
:
:
kSimpleRRect
)
;
}
if
(
usedShapeDefinitions
&
kNinePatch_ShapeFlag
)
{
v
-
>
defineConstant
(
"
NINE_PATCH_SHAPE_TYPE
"
(
int
)
ShapeType
:
:
kNinePatch
)
;
}
SkASSERT
(
!
(
usedShapeDefinitions
&
(
kRect_ShapeFlag
|
kComplexRRect_ShapeFlag
)
)
)
;
backend
-
>
emitCode
(
v
f
args
.
fOutputCoverage
args
.
fOutputColor
)
;
const
char
*
localCoords
=
nullptr
;
if
(
ip
.
opInfo
(
)
.
fUsesLocalCoords
)
{
localCoords
=
"
localCoords
"
;
v
-
>
codeAppendf
(
"
vec2
t
=
0
.
5
*
(
%
s
+
vec2
(
1
)
)
;
"
backend
-
>
outShapeCoords
(
)
)
;
v
-
>
codeAppendf
(
"
vec2
localCoords
=
(
1
.
0
-
t
)
*
%
s
.
xy
+
t
*
%
s
.
zw
;
"
inputs
.
attr
(
Attrib
:
:
kLocalRect
)
inputs
.
attr
(
Attrib
:
:
kLocalRect
)
)
;
}
if
(
ip
.
opInfo
(
)
.
fHasLocalMatrix
&
&
ip
.
opInfo
(
)
.
fHasParams
)
{
v
-
>
defineConstantf
(
"
int
"
"
LOCAL_MATRIX_FLAG
"
"
0x
%
x
"
kLocalMatrix_InfoFlag
)
;
v
-
>
codeAppendf
(
"
if
(
0
!
=
(
%
s
&
LOCAL_MATRIX_FLAG
)
)
{
"
inputs
.
attr
(
Attrib
:
:
kInstanceInfo
)
)
;
if
(
!
ip
.
opInfo
(
)
.
fUsesLocalCoords
)
{
inputs
.
skipParams
(
2
)
;
}
else
{
v
-
>
codeAppendf
(
"
mat2x3
localMatrix
;
"
)
;
v
-
>
codeAppend
(
"
localMatrix
[
0
]
=
"
)
;
inputs
.
fetchNextParam
(
kVec3f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
localMatrix
[
1
]
=
"
)
;
inputs
.
fetchNextParam
(
kVec3f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
localCoords
=
(
vec3
(
localCoords
1
)
*
localMatrix
)
.
xy
;
"
)
;
}
v
-
>
codeAppend
(
"
}
"
)
;
}
GrSLType
positionType
=
ip
.
opInfo
(
)
.
fHasPerspective
?
kVec3f_GrSLType
:
kVec2f_GrSLType
;
v
-
>
codeAppendf
(
"
%
s
deviceCoords
=
vec3
(
%
s
1
)
*
shapeMatrix
;
"
GrGLSLTypeString
(
positionType
)
backend
-
>
outShapeCoords
(
)
)
;
gpArgs
-
>
fPositionVar
.
set
(
positionType
"
deviceCoords
"
)
;
this
-
>
emitTransforms
(
v
varyingHandler
uniHandler
gpArgs
-
>
fPositionVar
localCoords
args
.
fFPCoordTransformHandler
)
;
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
init
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
if
(
fModifiedShapeCoords
)
{
v
-
>
codeAppendf
(
"
vec2
%
s
=
%
s
;
"
fModifiedShapeCoords
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
}
this
-
>
onInit
(
varyingHandler
v
)
;
if
(
!
fColor
.
vsOut
(
)
)
{
varyingHandler
-
>
addFlatVarying
(
"
color
"
&
fColor
kLow_GrSLPrecision
)
;
v
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
fColor
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kColor
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
setupRRect
(
GrGLSLVertexBuilder
*
v
int
*
usedShapeDefinitions
)
{
v
-
>
codeAppendf
(
"
uvec2
corner
=
uvec2
(
%
s
&
1
(
%
s
>
>
1
)
&
1
)
;
"
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
v
-
>
codeAppend
(
"
vec2
cornerSign
=
vec2
(
corner
)
*
2
.
0
-
1
.
0
;
"
)
;
v
-
>
codeAppendf
(
"
vec2
radii
%
s
;
"
fNeedsNeighborRadii
?
"
neighborRadii
"
:
"
"
)
;
v
-
>
codeAppend
(
"
mat2
p
=
"
)
;
fInputs
.
fetchNextParam
(
kMat22f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
uint8_t
types
=
fOpInfo
.
fShapeTypes
&
kRRect_ShapesMask
;
if
(
0
=
=
(
types
&
(
types
-
1
)
)
)
{
if
(
kSimpleRRect_ShapeFlag
=
=
types
)
{
this
-
>
setupSimpleRadii
(
v
)
;
}
else
if
(
kNinePatch_ShapeFlag
=
=
types
)
{
this
-
>
setupNinePatchRadii
(
v
)
;
}
else
if
(
kComplexRRect_ShapeFlag
=
=
types
)
{
this
-
>
setupComplexRadii
(
v
)
;
}
}
else
{
if
(
types
&
kSimpleRRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
if
(
SIMPLE_R_RECT_SHAPE_TYPE
=
=
shapeType
)
{
"
)
;
this
-
>
setupSimpleRadii
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
*
usedShapeDefinitions
|
=
kSimpleRRect_ShapeFlag
;
}
if
(
types
&
kNinePatch_ShapeFlag
)
{
if
(
types
&
kComplexRRect_ShapeFlag
)
{
if
(
types
&
kSimpleRRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
else
"
)
;
}
v
-
>
codeAppend
(
"
if
(
NINE_PATCH_SHAPE_TYPE
=
=
shapeType
)
{
"
)
;
*
usedShapeDefinitions
|
=
kNinePatch_ShapeFlag
;
}
else
{
v
-
>
codeAppend
(
"
else
{
"
)
;
}
this
-
>
setupNinePatchRadii
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
if
(
types
&
kComplexRRect_ShapeFlag
)
{
v
-
>
codeAppend
(
"
else
{
"
)
;
this
-
>
setupComplexRadii
(
v
)
;
v
-
>
codeAppend
(
"
}
"
)
;
}
}
this
-
>
adjustRRectVertices
(
v
)
;
if
(
fArcCoords
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
(
cornerSign
*
%
s
+
radii
-
vec2
(
1
)
)
/
radii
;
"
fArcCoords
.
vsOut
(
)
fModifiedShapeCoords
)
;
}
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
int
(
all
(
equal
(
vec2
(
1
)
abs
(
%
s
)
)
)
)
;
"
fTriangleIsArc
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
}
this
-
>
onSetupRRect
(
v
)
;
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
setupSimpleRadii
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fNeedsNeighborRadii
)
{
v
-
>
codeAppend
(
"
neighborRadii
=
"
)
;
}
v
-
>
codeAppend
(
"
radii
=
p
[
0
]
*
2
.
0
/
p
[
1
]
;
"
)
;
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
setupNinePatchRadii
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
radii
=
vec2
(
p
[
0
]
[
corner
.
x
]
p
[
1
]
[
corner
.
y
]
)
;
"
)
;
if
(
fNeedsNeighborRadii
)
{
v
-
>
codeAppend
(
"
neighborRadii
=
vec2
(
p
[
0
]
[
1u
-
corner
.
x
]
p
[
1
]
[
1u
-
corner
.
y
]
)
;
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
setupComplexRadii
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
mat2
p2
=
"
)
;
fInputs
.
fetchNextParam
(
kMat22f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
radii
=
vec2
(
p
[
corner
.
x
]
[
corner
.
y
]
p2
[
corner
.
y
]
[
corner
.
x
]
)
;
"
)
;
if
(
fNeedsNeighborRadii
)
{
v
-
>
codeAppend
(
"
neighborRadii
=
vec2
(
p
[
1u
-
corner
.
x
]
[
corner
.
y
]
"
"
p2
[
1u
-
corner
.
y
]
[
corner
.
x
]
)
;
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
adjustRRectVertices
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
x
)
=
=
0
.
5
)
"
"
%
s
.
x
=
cornerSign
.
x
*
(
1
.
0
-
radii
.
x
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
fModifiedShapeCoords
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
y
)
=
=
0
.
5
)
"
"
%
s
.
y
=
cornerSign
.
y
*
(
1
.
0
-
radii
.
y
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
fModifiedShapeCoords
)
;
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
initInnerShape
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
SkASSERT
(
!
(
fOpInfo
.
fInnerShapeTypes
&
(
kNinePatch_ShapeFlag
|
kComplexRRect_ShapeFlag
)
)
)
;
this
-
>
onInitInnerShape
(
varyingHandler
v
)
;
if
(
fInnerShapeCoords
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
innerShapeCoords
;
"
fInnerShapeCoords
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
setupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
mat2
innerP
=
"
)
;
fInputs
.
fetchNextParam
(
kMat22f_GrSLType
)
;
v
-
>
codeAppend
(
"
;
"
)
;
v
-
>
codeAppend
(
"
vec2
innerRadii
=
innerP
[
0
]
*
2
.
0
/
innerP
[
1
]
;
"
)
;
this
-
>
onSetupInnerSimpleRRect
(
v
)
;
}
void
GLSLInstanceProcessor
:
:
Backend
:
:
emitCode
(
GrGLSLVertexBuilder
*
v
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
const
char
*
outColor
)
{
SkASSERT
(
!
fModifiesCoverage
|
|
outCoverage
)
;
this
-
>
onEmitCode
(
v
f
fModifiesCoverage
?
outCoverage
:
nullptr
fModifiesColor
?
outColor
:
nullptr
)
;
if
(
outCoverage
&
&
!
fModifiesCoverage
)
{
f
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
)
;
"
outCoverage
)
;
}
if
(
!
fModifiesColor
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outColor
fColor
.
fsIn
(
)
)
;
}
}
class
GLSLInstanceProcessor
:
:
BackendNonAA
:
public
Backend
{
public
:
BackendNonAA
(
OpInfo
opInfo
const
VertexInputs
&
inputs
)
:
INHERITED
(
opInfo
inputs
)
{
if
(
fOpInfo
.
fCannotDiscard
&
&
!
fOpInfo
.
isSimpleRects
(
)
)
{
fModifiesColor
=
!
fOpInfo
.
fCannotTweakAlphaForCoverage
;
fModifiesCoverage
=
!
fModifiesColor
;
}
}
private
:
void
onInit
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupOval
(
GrGLSLVertexBuilder
*
)
override
;
void
onInitInnerShape
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerOval
(
GrGLSLVertexBuilder
*
)
override
;
void
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
)
override
;
void
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
const
char
*
const
char
*
)
override
;
typedef
Backend
INHERITED
;
}
;
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
onInit
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
)
{
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fShapeTypes
)
{
varyingHandler
-
>
addFlatVarying
(
"
triangleIsArc
"
&
fTriangleIsArc
kLow_GrSLPrecision
)
;
varyingHandler
-
>
addVarying
(
"
arcCoords
"
&
fArcCoords
kMedium_GrSLPrecision
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
setupRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
;
"
fTriangleIsArc
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
setupOval
(
GrGLSLVertexBuilder
*
v
)
{
SkASSERT
(
fArcCoords
.
vsOut
(
)
)
;
SkASSERT
(
fTriangleIsArc
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
fArcCoords
.
vsOut
(
)
this
-
>
outShapeCoords
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
%
s
&
1
;
"
fTriangleIsArc
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
onInitInnerShape
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
)
{
varyingHandler
-
>
addVarying
(
"
innerShapeCoords
"
&
fInnerShapeCoords
kMedium_GrSLPrecision
)
;
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fInnerShapeTypes
&
&
kOval_ShapeFlag
!
=
fOpInfo
.
fInnerShapeTypes
)
{
varyingHandler
-
>
addFlatVarying
(
"
innerRRect
"
&
fInnerRRect
kMedium_GrSLPrecision
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
setupInnerRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
setupInnerOval
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
0
0
1
1
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
-
innerRadii
1
.
0
/
innerRadii
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendNonAA
:
:
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
const
char
*
outColor
)
{
const
char
*
dropFragment
=
nullptr
;
if
(
!
fOpInfo
.
fCannotDiscard
)
{
dropFragment
=
"
discard
"
;
}
else
if
(
fModifiesCoverage
)
{
f
-
>
codeAppend
(
"
lowp
float
covered
=
1
.
0
;
"
)
;
dropFragment
=
"
covered
=
0
.
0
"
;
}
else
if
(
fModifiesColor
)
{
f
-
>
codeAppendf
(
"
lowp
vec4
color
=
%
s
;
"
fColor
.
fsIn
(
)
)
;
dropFragment
=
"
color
=
vec4
(
0
)
"
;
}
if
(
fTriangleIsArc
.
fsIn
(
)
)
{
SkASSERT
(
dropFragment
)
;
f
-
>
codeAppendf
(
"
if
(
%
s
!
=
0
&
&
dot
(
%
s
%
s
)
>
1
.
0
)
%
s
;
"
fTriangleIsArc
.
fsIn
(
)
fArcCoords
.
fsIn
(
)
fArcCoords
.
fsIn
(
)
dropFragment
)
;
}
if
(
fOpInfo
.
fInnerShapeTypes
)
{
SkASSERT
(
dropFragment
)
;
f
-
>
codeAppendf
(
"
/
/
Inner
shape
.
\
n
"
)
;
if
(
kRect_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
f
-
>
codeAppendf
(
"
if
(
all
(
lessThanEqual
(
abs
(
%
s
)
vec2
(
1
)
)
)
)
%
s
;
"
fInnerShapeCoords
.
fsIn
(
)
dropFragment
)
;
}
else
if
(
kOval_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
f
-
>
codeAppendf
(
"
if
(
(
dot
(
%
s
%
s
)
<
=
1
.
0
)
)
%
s
;
"
fInnerShapeCoords
.
fsIn
(
)
fInnerShapeCoords
.
fsIn
(
)
dropFragment
)
;
}
else
{
f
-
>
codeAppendf
(
"
if
(
all
(
lessThan
(
abs
(
%
s
)
vec2
(
1
)
)
)
)
{
"
fInnerShapeCoords
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
vec2
distanceToArcEdge
=
abs
(
%
s
)
-
%
s
.
xy
;
"
fInnerShapeCoords
.
fsIn
(
)
fInnerRRect
.
fsIn
(
)
)
;
f
-
>
codeAppend
(
"
if
(
any
(
lessThan
(
distanceToArcEdge
vec2
(
0
)
)
)
)
{
"
)
;
f
-
>
codeAppendf
(
"
%
s
;
"
dropFragment
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
f
-
>
codeAppendf
(
"
vec2
rrectCoords
=
distanceToArcEdge
*
%
s
.
zw
;
"
fInnerRRect
.
fsIn
(
)
)
;
f
-
>
codeAppend
(
"
if
(
dot
(
rrectCoords
rrectCoords
)
<
=
1
.
0
)
{
"
)
;
f
-
>
codeAppendf
(
"
%
s
;
"
dropFragment
)
;
f
-
>
codeAppend
(
"
}
"
)
;
f
-
>
codeAppend
(
"
}
"
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
}
if
(
fModifiesCoverage
)
{
f
-
>
codeAppendf
(
"
%
s
=
vec4
(
covered
)
;
"
outCoverage
)
;
}
else
if
(
fModifiesColor
)
{
f
-
>
codeAppendf
(
"
%
s
=
color
;
"
outColor
)
;
}
}
class
GLSLInstanceProcessor
:
:
BackendCoverage
:
public
Backend
{
public
:
BackendCoverage
(
OpInfo
opInfo
const
VertexInputs
&
inputs
)
:
INHERITED
(
opInfo
inputs
)
fColorTimesRectCoverage
(
kVec4f_GrSLType
)
fRectCoverage
(
kFloat_GrSLType
)
fEllipseCoords
(
kVec2f_GrSLType
)
fEllipseName
(
kVec2f_GrSLType
)
fBloatedRadius
(
kFloat_GrSLType
)
fDistanceToInnerEdge
(
kVec2f_GrSLType
)
fInnerShapeBloatedHalfSize
(
kVec2f_GrSLType
)
fInnerEllipseCoords
(
kVec2f_GrSLType
)
fInnerEllipseName
(
kVec2f_GrSLType
)
{
fShapeIsCircle
=
!
fOpInfo
.
fNonSquare
&
&
!
(
fOpInfo
.
fShapeTypes
&
kRRect_ShapesMask
)
;
fTweakAlphaForCoverage
=
!
fOpInfo
.
fCannotTweakAlphaForCoverage
&
&
!
fOpInfo
.
fInnerShapeTypes
;
fModifiesCoverage
=
!
fTweakAlphaForCoverage
;
fModifiesColor
=
fTweakAlphaForCoverage
;
fModifiedShapeCoords
=
"
bloatedShapeCoords
"
;
}
private
:
void
onInit
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupOval
(
GrGLSLVertexBuilder
*
)
override
;
void
adjustRRectVertices
(
GrGLSLVertexBuilder
*
)
override
;
void
onSetupRRect
(
GrGLSLVertexBuilder
*
)
override
;
void
onInitInnerShape
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerOval
(
GrGLSLVertexBuilder
*
)
override
;
void
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
)
override
;
void
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
const
char
*
outColor
)
override
;
void
emitRect
(
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
const
char
*
outColor
)
;
void
emitCircle
(
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
)
;
void
emitArc
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
ellipseCoords
const
char
*
ellipseName
bool
ellipseCoordsNeedClamp
bool
ellipseCoordsMayBeNegative
const
char
*
outCoverage
)
;
void
emitInnerRect
(
GrGLSLPPFragmentBuilder
*
const
char
*
outCoverage
)
;
GrGLSLVertToFrag
fColorTimesRectCoverage
;
GrGLSLVertToFrag
fRectCoverage
;
GrGLSLVertToFrag
fEllipseCoords
;
GrGLSLVertToFrag
fEllipseName
;
GrGLSLVertToFrag
fBloatedRadius
;
GrGLSLVertToFrag
fDistanceToInnerEdge
;
GrGLSLVertToFrag
fInnerShapeBloatedHalfSize
;
GrGLSLVertToFrag
fInnerEllipseCoords
;
GrGLSLVertToFrag
fInnerEllipseName
;
bool
fShapeIsCircle
;
bool
fTweakAlphaForCoverage
;
typedef
Backend
INHERITED
;
}
;
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
onInit
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
mat2
shapeTransposeMatrix
=
transpose
(
mat2
(
shapeMatrix
)
)
;
"
)
;
v
-
>
codeAppend
(
"
vec2
shapeHalfSize
=
vec2
(
length
(
shapeTransposeMatrix
[
0
]
)
"
"
length
(
shapeTransposeMatrix
[
1
]
)
)
;
"
)
;
v
-
>
codeAppend
(
"
vec2
bloat
=
0
.
5
/
shapeHalfSize
;
"
)
;
v
-
>
codeAppendf
(
"
bloatedShapeCoords
=
%
s
*
(
1
.
0
+
bloat
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
if
(
kOval_ShapeFlag
!
=
fOpInfo
.
fShapeTypes
)
{
if
(
fTweakAlphaForCoverage
)
{
varyingHandler
-
>
addVarying
(
"
colorTimesRectCoverage
"
&
fColorTimesRectCoverage
kLow_GrSLPrecision
)
;
if
(
kRect_ShapeFlag
=
=
fOpInfo
.
fShapeTypes
)
{
fColor
=
fColorTimesRectCoverage
;
}
}
else
{
varyingHandler
-
>
addVarying
(
"
rectCoverage
"
&
fRectCoverage
kLow_GrSLPrecision
)
;
}
v
-
>
codeAppend
(
"
float
rectCoverage
=
0
.
0
;
"
)
;
}
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fShapeTypes
)
{
varyingHandler
-
>
addFlatVarying
(
"
triangleIsArc
"
&
fTriangleIsArc
kLow_GrSLPrecision
)
;
if
(
!
fShapeIsCircle
)
{
varyingHandler
-
>
addVarying
(
"
ellipseCoords
"
&
fEllipseCoords
kMedium_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
ellipseName
"
&
fEllipseName
kHigh_GrSLPrecision
)
;
}
else
{
varyingHandler
-
>
addVarying
(
"
circleCoords
"
&
fEllipseCoords
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
bloatedRadius
"
&
fBloatedRadius
kHigh_GrSLPrecision
)
;
}
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
setupRect
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
vec2
rectBloat
=
(
%
s
!
=
0
)
?
bloat
:
-
bloat
;
"
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
v
-
>
codeAppendf
(
"
bloatedShapeCoords
=
%
s
*
abs
(
vec2
(
1
.
0
+
rectBloat
)
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
v
-
>
codeAppend
(
"
float
maxCoverage
=
4
.
0
*
min
(
0
.
5
shapeHalfSize
.
x
)
*
"
"
min
(
0
.
5
shapeHalfSize
.
y
)
;
"
)
;
v
-
>
codeAppendf
(
"
rectCoverage
=
(
%
s
!
=
0
)
?
0
.
0
:
maxCoverage
;
"
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
;
"
fTriangleIsArc
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
setupOval
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
vec2
ovalBloat
=
(
%
s
!
=
0
)
?
bloat
:
-
bloat
;
"
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
v
-
>
codeAppendf
(
"
bloatedShapeCoords
=
%
s
*
max
(
vec2
(
1
.
0
+
ovalBloat
)
vec2
(
0
)
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
bloatedShapeCoords
*
shapeHalfSize
;
"
fEllipseCoords
.
vsOut
(
)
)
;
if
(
fEllipseName
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
1
.
0
/
(
shapeHalfSize
*
shapeHalfSize
)
;
"
fEllipseName
.
vsOut
(
)
)
;
}
if
(
fBloatedRadius
.
vsOut
(
)
)
{
SkASSERT
(
fShapeIsCircle
)
;
v
-
>
codeAppendf
(
"
%
s
=
shapeHalfSize
.
x
+
0
.
5
;
"
fBloatedRadius
.
vsOut
(
)
)
;
}
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
int
(
%
s
!
=
0
)
;
"
fTriangleIsArc
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
}
if
(
fColorTimesRectCoverage
.
vsOut
(
)
|
|
fRectCoverage
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
rectCoverage
=
1
.
0
;
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
adjustRRectVertices
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
vec2
innerEdge
=
max
(
1
.
0
-
bloat
vec2
(
0
)
)
;
"
)
;
v
-
>
codeAppend
(
"
vec2
borderEdge
=
cornerSign
*
clamp
(
1
.
0
-
radii
-
innerEdge
innerEdge
)
;
"
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
x
)
=
=
0
.
5
)
"
"
bloatedShapeCoords
.
x
=
borderEdge
.
x
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
y
)
=
=
0
.
5
)
"
"
bloatedShapeCoords
.
y
=
borderEdge
.
y
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
x
)
=
=
0
.
75
)
"
"
bloatedShapeCoords
.
x
=
cornerSign
.
x
*
innerEdge
.
x
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
y
)
=
=
0
.
75
)
"
"
bloatedShapeCoords
.
y
=
cornerSign
.
y
*
innerEdge
.
y
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
onSetupRRect
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
vec2
d
=
shapeHalfSize
+
0
.
5
-
abs
(
bloatedShapeCoords
)
*
shapeHalfSize
;
"
)
;
v
-
>
codeAppend
(
"
rectCoverage
=
min
(
d
.
x
d
.
y
)
;
"
)
;
SkASSERT
(
!
fShapeIsCircle
)
;
v
-
>
codeAppendf
(
"
vec2
clampedRadii
=
max
(
radii
bloat
)
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
=
(
cornerSign
*
bloatedShapeCoords
+
clampedRadii
-
vec2
(
1
)
)
*
"
"
shapeHalfSize
;
"
fEllipseCoords
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
1
.
0
/
(
clampedRadii
*
clampedRadii
*
shapeHalfSize
*
shapeHalfSize
)
;
"
fEllipseName
.
vsOut
(
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
onInitInnerShape
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
vec2
innerShapeHalfSize
=
shapeHalfSize
/
outer2Inner
.
xy
;
"
)
;
if
(
kOval_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
varyingHandler
-
>
addVarying
(
"
innerEllipseCoords
"
&
fInnerEllipseCoords
kMedium_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
innerEllipseName
"
&
fInnerEllipseName
kHigh_GrSLPrecision
)
;
}
else
{
varyingHandler
-
>
addVarying
(
"
distanceToInnerEdge
"
&
fDistanceToInnerEdge
kMedium_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
innerShapeBloatedHalfSize
"
&
fInnerShapeBloatedHalfSize
kMedium_GrSLPrecision
)
;
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fInnerShapeTypes
)
{
varyingHandler
-
>
addVarying
(
"
innerShapeCoords
"
&
fInnerShapeCoords
kMedium_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
innerEllipseName
"
&
fInnerEllipseName
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
innerRRect
"
&
fInnerRRect
kMedium_GrSLPrecision
)
;
}
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
setupInnerRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
.
xy
=
abs
(
outer2Inner
.
xy
)
*
(
1
.
0
+
bloat
)
+
abs
(
outer2Inner
.
zw
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
setupInnerOval
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
%
s
=
1
.
0
/
(
innerShapeHalfSize
*
innerShapeHalfSize
)
;
"
fInnerEllipseName
.
vsOut
(
)
)
;
if
(
fInnerEllipseCoords
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
innerShapeCoords
*
innerShapeHalfSize
;
"
fInnerEllipseCoords
.
vsOut
(
)
)
;
}
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
0
0
innerShapeHalfSize
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppend
(
"
innerRadii
=
max
(
innerRadii
bloat
)
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
=
1
.
0
/
(
innerRadii
*
innerRadii
*
innerShapeHalfSize
*
"
"
innerShapeHalfSize
)
;
"
fInnerEllipseName
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
-
innerRadii
innerShapeHalfSize
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
onEmitCode
(
GrGLSLVertexBuilder
*
v
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
const
char
*
outColor
)
{
if
(
fColorTimesRectCoverage
.
vsOut
(
)
)
{
SkASSERT
(
!
fRectCoverage
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
%
s
*
rectCoverage
;
"
fColorTimesRectCoverage
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kColor
)
)
;
}
if
(
fRectCoverage
.
vsOut
(
)
)
{
SkASSERT
(
!
fColorTimesRectCoverage
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
rectCoverage
;
"
fRectCoverage
.
vsOut
(
)
)
;
}
SkString
coverage
(
"
lowp
float
coverage
"
)
;
if
(
fOpInfo
.
fInnerShapeTypes
|
|
(
!
fTweakAlphaForCoverage
&
&
fTriangleIsArc
.
fsIn
(
)
)
)
{
f
-
>
codeAppendf
(
"
%
s
;
"
coverage
.
c_str
(
)
)
;
coverage
=
"
coverage
"
;
}
if
(
fTriangleIsArc
.
fsIn
(
)
)
{
f
-
>
codeAppendf
(
"
if
(
%
s
=
=
0
)
{
"
fTriangleIsArc
.
fsIn
(
)
)
;
this
-
>
emitRect
(
f
coverage
.
c_str
(
)
outColor
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
if
(
fShapeIsCircle
)
{
this
-
>
emitCircle
(
f
coverage
.
c_str
(
)
)
;
}
else
{
bool
ellipseCoordsMayBeNegative
=
SkToBool
(
fOpInfo
.
fShapeTypes
&
kOval_ShapeFlag
)
;
this
-
>
emitArc
(
f
fEllipseCoords
.
fsIn
(
)
fEllipseName
.
fsIn
(
)
true
ellipseCoordsMayBeNegative
coverage
.
c_str
(
)
)
;
}
if
(
fTweakAlphaForCoverage
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
*
coverage
;
"
outColor
fColor
.
fsIn
(
)
)
;
}
f
-
>
codeAppend
(
"
}
"
)
;
}
else
{
this
-
>
emitRect
(
f
coverage
.
c_str
(
)
outColor
)
;
}
if
(
fOpInfo
.
fInnerShapeTypes
)
{
f
-
>
codeAppendf
(
"
/
/
Inner
shape
.
\
n
"
)
;
SkString
innerCoverageDecl
(
"
lowp
float
innerCoverage
"
)
;
if
(
kOval_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
this
-
>
emitArc
(
f
fInnerEllipseCoords
.
fsIn
(
)
fInnerEllipseName
.
fsIn
(
)
true
true
innerCoverageDecl
.
c_str
(
)
)
;
}
else
{
v
-
>
codeAppendf
(
"
%
s
=
innerShapeCoords
*
innerShapeHalfSize
;
"
fDistanceToInnerEdge
.
vsOut
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
innerShapeHalfSize
+
0
.
5
;
"
fInnerShapeBloatedHalfSize
.
vsOut
(
)
)
;
if
(
kRect_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
this
-
>
emitInnerRect
(
f
innerCoverageDecl
.
c_str
(
)
)
;
}
else
{
f
-
>
codeAppendf
(
"
%
s
=
0
.
0
;
"
innerCoverageDecl
.
c_str
(
)
)
;
f
-
>
codeAppendf
(
"
mediump
vec2
distanceToArcEdge
=
abs
(
%
s
)
-
%
s
.
xy
;
"
fInnerShapeCoords
.
fsIn
(
)
fInnerRRect
.
fsIn
(
)
)
;
f
-
>
codeAppend
(
"
if
(
any
(
lessThan
(
distanceToArcEdge
vec2
(
1e
-
5
)
)
)
)
{
"
)
;
this
-
>
emitInnerRect
(
f
"
innerCoverage
"
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
f
-
>
codeAppendf
(
"
mediump
vec2
ellipseCoords
=
distanceToArcEdge
*
%
s
.
zw
;
"
fInnerRRect
.
fsIn
(
)
)
;
this
-
>
emitArc
(
f
"
ellipseCoords
"
fInnerEllipseName
.
fsIn
(
)
false
false
"
innerCoverage
"
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
}
f
-
>
codeAppendf
(
"
%
s
=
vec4
(
max
(
coverage
-
innerCoverage
0
.
0
)
)
;
"
outCoverage
)
;
}
else
if
(
!
fTweakAlphaForCoverage
)
{
f
-
>
codeAppendf
(
"
%
s
=
vec4
(
coverage
)
;
"
outCoverage
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
emitRect
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
const
char
*
outColor
)
{
if
(
fColorTimesRectCoverage
.
fsIn
(
)
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outColor
fColorTimesRectCoverage
.
fsIn
(
)
)
;
}
else
if
(
fTweakAlphaForCoverage
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outColor
fColor
.
fsIn
(
)
)
;
}
else
if
(
fRectCoverage
.
fsIn
(
)
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outCoverage
fRectCoverage
.
fsIn
(
)
)
;
}
else
{
f
-
>
codeAppendf
(
"
%
s
=
1
.
0
;
"
outCoverage
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
emitCircle
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
)
{
SkASSERT
(
!
(
kRRect_ShapesMask
&
fOpInfo
.
fShapeTypes
)
)
;
f
-
>
codeAppendf
(
"
mediump
float
distanceToEdge
=
%
s
-
length
(
%
s
)
;
"
fBloatedRadius
.
fsIn
(
)
fEllipseCoords
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
%
s
=
clamp
(
distanceToEdge
0
.
0
1
.
0
)
;
"
outCoverage
)
;
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
emitArc
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
ellipseCoords
const
char
*
ellipseName
bool
ellipseCoordsNeedClamp
bool
ellipseCoordsMayBeNegative
const
char
*
outCoverage
)
{
SkASSERT
(
!
ellipseCoordsMayBeNegative
|
|
ellipseCoordsNeedClamp
)
;
if
(
ellipseCoordsNeedClamp
)
{
if
(
ellipseCoordsMayBeNegative
)
{
f
-
>
codeAppendf
(
"
mediump
vec2
ellipseClampedCoords
=
max
(
abs
(
%
s
)
vec2
(
1e
-
4
)
)
;
"
ellipseCoords
)
;
}
else
{
f
-
>
codeAppendf
(
"
mediump
vec2
ellipseClampedCoords
=
max
(
%
s
vec2
(
1e
-
4
)
)
;
"
ellipseCoords
)
;
}
ellipseCoords
=
"
ellipseClampedCoords
"
;
}
f
-
>
codeAppendf
(
"
highp
vec2
Z
=
%
s
*
%
s
;
"
ellipseCoords
ellipseName
)
;
f
-
>
codeAppendf
(
"
highp
float
implicit
=
dot
(
Z
%
s
)
-
1
.
0
;
"
ellipseCoords
)
;
f
-
>
codeAppendf
(
"
highp
float
gradDot
=
4
.
0
*
dot
(
Z
Z
)
;
"
)
;
f
-
>
codeAppend
(
"
mediump
float
approxDist
=
implicit
*
inversesqrt
(
gradDot
)
;
"
)
;
f
-
>
codeAppendf
(
"
%
s
=
clamp
(
0
.
5
-
approxDist
0
.
0
1
.
0
)
;
"
outCoverage
)
;
}
void
GLSLInstanceProcessor
:
:
BackendCoverage
:
:
emitInnerRect
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
outCoverage
)
{
f
-
>
codeAppendf
(
"
lowp
vec2
c
=
%
s
-
abs
(
%
s
)
;
"
fInnerShapeBloatedHalfSize
.
fsIn
(
)
fDistanceToInnerEdge
.
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
%
s
=
clamp
(
min
(
c
.
x
c
.
y
)
0
.
0
1
.
0
)
;
"
outCoverage
)
;
}
class
GLSLInstanceProcessor
:
:
BackendMultisample
:
public
Backend
{
public
:
BackendMultisample
(
OpInfo
opInfo
const
VertexInputs
&
inputs
int
effectiveSampleCnt
)
:
INHERITED
(
opInfo
inputs
)
fEffectiveSampleCnt
(
effectiveSampleCnt
)
fShapeCoords
(
kVec2f_GrSLType
)
fShapeInverseMatrix
(
kMat22f_GrSLType
)
fFragShapeHalfSpan
(
kVec2f_GrSLType
)
fArcTest
(
kVec2f_GrSLType
)
fArcInverseMatrix
(
kMat22f_GrSLType
)
fFragArcHalfSpan
(
kVec2f_GrSLType
)
fEarlyAccept
(
kInt_GrSLType
)
fInnerShapeInverseMatrix
(
kMat22f_GrSLType
)
fFragInnerShapeHalfSpan
(
kVec2f_GrSLType
)
{
fRectTrianglesMaySplit
=
fOpInfo
.
fHasPerspective
;
fNeedsNeighborRadii
=
this
-
>
isMixedSampled
(
)
&
&
!
fOpInfo
.
fHasPerspective
;
}
private
:
bool
isMixedSampled
(
)
const
{
return
GrAAType
:
:
kMixedSamples
=
=
fOpInfo
.
aaType
(
)
;
}
void
onInit
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupOval
(
GrGLSLVertexBuilder
*
)
override
;
void
adjustRRectVertices
(
GrGLSLVertexBuilder
*
)
override
;
void
onSetupRRect
(
GrGLSLVertexBuilder
*
)
override
;
void
onInitInnerShape
(
GrGLSLVaryingHandler
*
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerRect
(
GrGLSLVertexBuilder
*
)
override
;
void
setupInnerOval
(
GrGLSLVertexBuilder
*
)
override
;
void
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
)
override
;
void
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
const
char
*
const
char
*
)
override
;
struct
EmitShapeCoords
{
const
GrGLSLVarying
*
fVarying
;
const
char
*
fInverseMatrix
;
const
char
*
fFragHalfSpan
;
}
;
struct
EmitShapeOpts
{
bool
fIsTightGeometry
;
bool
fResolveMixedSamples
;
bool
fInvertCoverage
;
}
;
void
emitRect
(
GrGLSLPPFragmentBuilder
*
const
EmitShapeCoords
&
const
EmitShapeOpts
&
)
;
void
emitArc
(
GrGLSLPPFragmentBuilder
*
const
EmitShapeCoords
&
bool
coordsMayBeNegative
bool
clampCoords
const
EmitShapeOpts
&
)
;
void
emitSimpleRRect
(
GrGLSLPPFragmentBuilder
*
const
EmitShapeCoords
&
const
char
*
rrect
const
EmitShapeOpts
&
)
;
void
interpolateAtSample
(
GrGLSLPPFragmentBuilder
*
const
GrGLSLVarying
&
const
char
*
sampleIdx
const
char
*
interpolationMatrix
)
;
void
acceptOrRejectWholeFragment
(
GrGLSLPPFragmentBuilder
*
bool
inside
const
EmitShapeOpts
&
)
;
void
acceptCoverageMask
(
GrGLSLPPFragmentBuilder
*
const
char
*
shapeMask
const
EmitShapeOpts
&
bool
maybeSharedEdge
=
true
)
;
int
fEffectiveSampleCnt
;
bool
fRectTrianglesMaySplit
;
GrGLSLVertToFrag
fShapeCoords
;
GrGLSLVertToFrag
fShapeInverseMatrix
;
GrGLSLVertToFrag
fFragShapeHalfSpan
;
GrGLSLVertToFrag
fArcTest
;
GrGLSLVertToFrag
fArcInverseMatrix
;
GrGLSLVertToFrag
fFragArcHalfSpan
;
GrGLSLVertToFrag
fEarlyAccept
;
GrGLSLVertToFrag
fInnerShapeInverseMatrix
;
GrGLSLVertToFrag
fFragInnerShapeHalfSpan
;
SkString
fSquareFun
;
typedef
Backend
INHERITED
;
}
;
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
onInit
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
if
(
!
this
-
>
isMixedSampled
(
)
)
{
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fShapeTypes
)
{
varyingHandler
-
>
addFlatVarying
(
"
triangleIsArc
"
&
fTriangleIsArc
kLow_GrSLPrecision
)
;
varyingHandler
-
>
addVarying
(
"
arcCoords
"
&
fArcCoords
kHigh_GrSLPrecision
)
;
if
(
!
fOpInfo
.
fHasPerspective
)
{
varyingHandler
-
>
addFlatVarying
(
"
arcInverseMatrix
"
&
fArcInverseMatrix
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
fragArcHalfSpan
"
&
fFragArcHalfSpan
kHigh_GrSLPrecision
)
;
}
}
else
if
(
!
fOpInfo
.
fInnerShapeTypes
)
{
return
;
}
}
else
{
varyingHandler
-
>
addVarying
(
"
shapeCoords
"
&
fShapeCoords
kHigh_GrSLPrecision
)
;
if
(
!
fOpInfo
.
fHasPerspective
)
{
varyingHandler
-
>
addFlatVarying
(
"
shapeInverseMatrix
"
&
fShapeInverseMatrix
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
fragShapeHalfSpan
"
&
fFragShapeHalfSpan
kHigh_GrSLPrecision
)
;
}
if
(
fOpInfo
.
fShapeTypes
&
kRRect_ShapesMask
)
{
varyingHandler
-
>
addVarying
(
"
arcCoords
"
&
fArcCoords
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addVarying
(
"
arcTest
"
&
fArcTest
kHigh_GrSLPrecision
)
;
if
(
!
fOpInfo
.
fHasPerspective
)
{
varyingHandler
-
>
addFlatVarying
(
"
arcInverseMatrix
"
&
fArcInverseMatrix
kHigh_GrSLPrecision
)
;
varyingHandler
-
>
addFlatVarying
(
"
fragArcHalfSpan
"
&
fFragArcHalfSpan
kHigh_GrSLPrecision
)
;
}
}
else
if
(
fOpInfo
.
fShapeTypes
&
kOval_ShapeFlag
)
{
fArcCoords
=
fShapeCoords
;
fArcInverseMatrix
=
fShapeInverseMatrix
;
fFragArcHalfSpan
=
fFragShapeHalfSpan
;
if
(
fOpInfo
.
fShapeTypes
&
kRect_ShapeFlag
)
{
varyingHandler
-
>
addFlatVarying
(
"
triangleIsArc
"
&
fTriangleIsArc
kLow_GrSLPrecision
)
;
}
}
if
(
kRect_ShapeFlag
!
=
fOpInfo
.
fShapeTypes
)
{
v
-
>
defineConstantf
(
"
int
"
"
SAMPLE_MASK_ALL
"
"
0x
%
x
"
(
1
<
<
fEffectiveSampleCnt
)
-
1
)
;
varyingHandler
-
>
addFlatVarying
(
"
earlyAccept
"
&
fEarlyAccept
kHigh_GrSLPrecision
)
;
}
}
if
(
!
fOpInfo
.
fHasPerspective
)
{
v
-
>
codeAppend
(
"
mat2
shapeInverseMatrix
=
inverse
(
mat2
(
shapeMatrix
)
)
;
"
)
;
v
-
>
codeAppend
(
"
vec2
fragShapeSpan
=
abs
(
vec4
(
shapeInverseMatrix
)
.
xz
)
+
"
"
abs
(
vec4
(
shapeInverseMatrix
)
.
yw
)
;
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
setupRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fShapeCoords
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
fShapeCoords
.
vsOut
(
)
this
-
>
outShapeCoords
(
)
)
;
}
if
(
fShapeInverseMatrix
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
shapeInverseMatrix
;
"
fShapeInverseMatrix
.
vsOut
(
)
)
;
}
if
(
fFragShapeHalfSpan
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
.
5
*
fragShapeSpan
;
"
fFragShapeHalfSpan
.
vsOut
(
)
)
;
}
if
(
fArcTest
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec2
(
0
)
;
"
fArcTest
.
vsOut
(
)
)
;
}
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
;
"
fTriangleIsArc
.
vsOut
(
)
)
;
}
if
(
fEarlyAccept
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
SAMPLE_MASK_ALL
;
"
fEarlyAccept
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
setupOval
(
GrGLSLVertexBuilder
*
v
)
{
v
-
>
codeAppendf
(
"
%
s
=
abs
(
%
s
)
;
"
fArcCoords
.
vsOut
(
)
this
-
>
outShapeCoords
(
)
)
;
if
(
fArcInverseMatrix
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
vec2
s
=
sign
(
%
s
)
;
"
this
-
>
outShapeCoords
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
shapeInverseMatrix
*
mat2
(
s
.
x
0
0
s
.
y
)
;
"
fArcInverseMatrix
.
vsOut
(
)
)
;
}
if
(
fFragArcHalfSpan
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
.
5
*
fragShapeSpan
;
"
fFragArcHalfSpan
.
vsOut
(
)
)
;
}
if
(
fArcTest
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec2
(
1
)
;
"
fArcTest
.
vsOut
(
)
)
;
}
if
(
fTriangleIsArc
.
vsOut
(
)
)
{
if
(
!
this
-
>
isMixedSampled
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
%
s
&
1
;
"
fTriangleIsArc
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
}
else
{
v
-
>
codeAppendf
(
"
%
s
=
1
;
"
fTriangleIsArc
.
vsOut
(
)
)
;
}
}
if
(
fEarlyAccept
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
~
%
s
&
SAMPLE_MASK_ALL
;
"
fEarlyAccept
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kVertexAttrs
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
adjustRRectVertices
(
GrGLSLVertexBuilder
*
v
)
{
if
(
!
this
-
>
isMixedSampled
(
)
)
{
INHERITED
:
:
adjustRRectVertices
(
v
)
;
return
;
}
if
(
!
fOpInfo
.
fHasPerspective
)
{
v
-
>
codeAppend
(
"
vec2
midpt
=
0
.
5
*
(
neighborRadii
-
radii
)
;
"
)
;
v
-
>
codeAppend
(
"
vec2
cornerSize
=
any
(
lessThan
(
radii
fragShapeSpan
)
)
?
"
"
vec2
(
0
)
:
min
(
radii
+
0
.
5
*
fragShapeSpan
1
.
0
-
midpt
)
;
"
)
;
}
else
{
v
-
>
codeAppend
(
"
vec2
cornerSize
=
any
(
lessThan
(
radii
vec2
(
1e
-
3
)
)
)
?
vec2
(
0
)
:
radii
;
"
)
;
}
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
x
)
=
=
0
.
5
)
"
"
%
s
.
x
=
cornerSign
.
x
*
(
1
.
0
-
cornerSize
.
x
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
fModifiedShapeCoords
)
;
v
-
>
codeAppendf
(
"
if
(
abs
(
%
s
.
y
)
=
=
0
.
5
)
"
"
%
s
.
y
=
cornerSign
.
y
*
(
1
.
0
-
cornerSize
.
y
)
;
"
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
fModifiedShapeCoords
)
;
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
onSetupRRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fShapeCoords
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
fShapeCoords
.
vsOut
(
)
this
-
>
outShapeCoords
(
)
)
;
}
if
(
fShapeInverseMatrix
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
shapeInverseMatrix
;
"
fShapeInverseMatrix
.
vsOut
(
)
)
;
}
if
(
fFragShapeHalfSpan
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
.
5
*
fragShapeSpan
;
"
fFragShapeHalfSpan
.
vsOut
(
)
)
;
}
if
(
fArcInverseMatrix
.
vsOut
(
)
)
{
v
-
>
codeAppend
(
"
vec2
s
=
cornerSign
/
radii
;
"
)
;
v
-
>
codeAppendf
(
"
%
s
=
shapeInverseMatrix
*
mat2
(
s
.
x
0
0
s
.
y
)
;
"
fArcInverseMatrix
.
vsOut
(
)
)
;
}
if
(
fFragArcHalfSpan
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
0
.
5
*
(
abs
(
vec4
(
%
s
)
.
xz
)
+
abs
(
vec4
(
%
s
)
.
yw
)
)
;
"
fFragArcHalfSpan
.
vsOut
(
)
fArcInverseMatrix
.
vsOut
(
)
fArcInverseMatrix
.
vsOut
(
)
)
;
}
if
(
fArcTest
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
(
cornerSize
=
=
vec2
(
0
)
)
?
vec2
(
0
)
:
"
"
cornerSign
*
%
s
*
mat2
(
1
cornerSize
.
x
-
1
.
0
cornerSize
.
y
-
1
.
0
1
)
;
"
fArcTest
.
vsOut
(
)
fModifiedShapeCoords
)
;
if
(
!
fOpInfo
.
fHasPerspective
)
{
v
-
>
codeAppendf
(
"
%
s
-
=
0
.
5
*
(
fragShapeSpan
.
yx
*
abs
(
radii
-
1
.
0
)
+
fragShapeSpan
)
;
"
fArcTest
.
vsOut
(
)
)
;
}
}
if
(
fEarlyAccept
.
vsOut
(
)
)
{
SkASSERT
(
this
-
>
isMixedSampled
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
=
all
(
equal
(
vec2
(
1
)
abs
(
%
s
)
)
)
?
0
:
SAMPLE_MASK_ALL
;
"
fEarlyAccept
.
vsOut
(
)
fInputs
.
attr
(
Attrib
:
:
kShapeCoords
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
onInitInnerShape
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVertexBuilder
*
v
)
{
varyingHandler
-
>
addVarying
(
"
innerShapeCoords
"
&
fInnerShapeCoords
kHigh_GrSLPrecision
)
;
if
(
kOval_ShapeFlag
!
=
fOpInfo
.
fInnerShapeTypes
&
&
kRect_ShapeFlag
!
=
fOpInfo
.
fInnerShapeTypes
)
{
varyingHandler
-
>
addFlatVarying
(
"
innerRRect
"
&
fInnerRRect
kHigh_GrSLPrecision
)
;
}
if
(
!
fOpInfo
.
fHasPerspective
)
{
varyingHandler
-
>
addFlatVarying
(
"
innerShapeInverseMatrix
"
&
fInnerShapeInverseMatrix
kHigh_GrSLPrecision
)
;
v
-
>
codeAppendf
(
"
%
s
=
shapeInverseMatrix
*
mat2
(
outer2Inner
.
x
0
0
outer2Inner
.
y
)
;
"
fInnerShapeInverseMatrix
.
vsOut
(
)
)
;
varyingHandler
-
>
addFlatVarying
(
"
fragInnerShapeHalfSpan
"
&
fFragInnerShapeHalfSpan
kHigh_GrSLPrecision
)
;
v
-
>
codeAppendf
(
"
%
s
=
0
.
5
*
fragShapeSpan
*
outer2Inner
.
xy
;
"
fFragInnerShapeHalfSpan
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
setupInnerRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
2
.
0
*
(
inner
.
zw
-
inner
.
xy
)
/
(
outer
.
zw
-
outer
.
xy
)
vec2
(
0
)
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
setupInnerOval
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fInnerRRect
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
0
0
1
1
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
onSetupInnerSimpleRRect
(
GrGLSLVertexBuilder
*
v
)
{
if
(
fFragInnerShapeHalfSpan
.
vsOut
(
)
)
{
v
-
>
codeAppendf
(
"
innerRadii
=
max
(
innerRadii
2e
-
1
*
%
s
)
;
"
fFragInnerShapeHalfSpan
.
vsOut
(
)
)
;
}
else
{
v
-
>
codeAppend
(
"
innerRadii
=
max
(
innerRadii
vec2
(
1e
-
4
)
)
;
"
)
;
}
v
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
-
innerRadii
1
.
0
/
innerRadii
)
;
"
fInnerRRect
.
vsOut
(
)
)
;
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
onEmitCode
(
GrGLSLVertexBuilder
*
GrGLSLPPFragmentBuilder
*
f
const
char
*
const
char
*
)
{
f
-
>
defineConstant
(
"
SAMPLE_COUNT
"
fEffectiveSampleCnt
)
;
if
(
this
-
>
isMixedSampled
(
)
)
{
f
-
>
defineConstantf
(
"
int
"
"
SAMPLE_MASK_ALL
"
"
0x
%
x
"
(
1
<
<
fEffectiveSampleCnt
)
-
1
)
;
f
-
>
defineConstantf
(
"
int
"
"
SAMPLE_MASK_MSB
"
"
0x
%
x
"
1
<
<
(
fEffectiveSampleCnt
-
1
)
)
;
}
if
(
kRect_ShapeFlag
!
=
(
fOpInfo
.
fShapeTypes
|
fOpInfo
.
fInnerShapeTypes
)
)
{
GrShaderVar
x
(
"
x
"
kVec2f_GrSLType
GrShaderVar
:
:
kNonArray
kHigh_GrSLPrecision
)
;
f
-
>
emitFunction
(
kFloat_GrSLType
"
square
"
1
&
x
"
return
dot
(
x
x
)
;
"
&
fSquareFun
)
;
}
EmitShapeCoords
shapeCoords
;
shapeCoords
.
fVarying
=
&
fShapeCoords
;
shapeCoords
.
fInverseMatrix
=
fShapeInverseMatrix
.
fsIn
(
)
;
shapeCoords
.
fFragHalfSpan
=
fFragShapeHalfSpan
.
fsIn
(
)
;
EmitShapeCoords
arcCoords
;
arcCoords
.
fVarying
=
&
fArcCoords
;
arcCoords
.
fInverseMatrix
=
fArcInverseMatrix
.
fsIn
(
)
;
arcCoords
.
fFragHalfSpan
=
fFragArcHalfSpan
.
fsIn
(
)
;
bool
clampArcCoords
=
this
-
>
isMixedSampled
(
)
&
&
(
fOpInfo
.
fShapeTypes
&
kRRect_ShapesMask
)
;
EmitShapeOpts
opts
;
opts
.
fIsTightGeometry
=
true
;
opts
.
fResolveMixedSamples
=
this
-
>
isMixedSampled
(
)
;
opts
.
fInvertCoverage
=
false
;
if
(
fOpInfo
.
fHasPerspective
&
&
fOpInfo
.
fInnerShapeTypes
)
{
f
-
>
codeAppendf
(
"
highp
vec2
fragInnerShapeApproxHalfSpan
=
0
.
5
*
fwidth
(
%
s
)
;
"
fInnerShapeCoords
.
fsIn
(
)
)
;
}
if
(
!
this
-
>
isMixedSampled
(
)
)
{
SkASSERT
(
!
fArcTest
.
fsIn
(
)
)
;
if
(
fTriangleIsArc
.
fsIn
(
)
)
{
f
-
>
codeAppendf
(
"
if
(
%
s
!
=
0
)
{
"
fTriangleIsArc
.
fsIn
(
)
)
;
this
-
>
emitArc
(
f
arcCoords
false
clampArcCoords
opts
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
}
else
{
const
char
*
arcTest
=
fArcTest
.
fsIn
(
)
;
if
(
arcTest
&
&
fOpInfo
.
fHasPerspective
)
{
f
-
>
codeAppendf
(
"
highp
vec2
arcTest
=
%
s
-
0
.
5
*
fwidth
(
%
s
)
;
"
fArcTest
.
fsIn
(
)
fArcTest
.
fsIn
(
)
)
;
arcTest
=
"
arcTest
"
;
}
const
char
*
earlyAccept
=
fEarlyAccept
.
fsIn
(
)
?
fEarlyAccept
.
fsIn
(
)
:
"
SAMPLE_MASK_ALL
"
;
f
-
>
codeAppendf
(
"
if
(
gl_SampleMaskIn
[
0
]
=
=
%
s
)
{
"
earlyAccept
)
;
f
-
>
overrideSampleCoverage
(
earlyAccept
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
if
(
arcTest
)
{
f
-
>
codeAppendf
(
"
if
(
gl_SampleMaskIn
[
0
]
=
=
SAMPLE_MASK_ALL
|
|
"
"
all
(
greaterThan
(
%
s
vec2
(
0
)
)
)
)
{
"
arcTest
)
;
this
-
>
emitArc
(
f
arcCoords
false
clampArcCoords
opts
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
this
-
>
emitRect
(
f
shapeCoords
opts
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
else
if
(
fTriangleIsArc
.
fsIn
(
)
)
{
f
-
>
codeAppendf
(
"
if
(
%
s
=
=
0
)
{
"
fTriangleIsArc
.
fsIn
(
)
)
;
this
-
>
emitRect
(
f
shapeCoords
opts
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
this
-
>
emitArc
(
f
arcCoords
false
clampArcCoords
opts
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
else
if
(
fOpInfo
.
fShapeTypes
=
=
kOval_ShapeFlag
)
{
this
-
>
emitArc
(
f
arcCoords
false
clampArcCoords
opts
)
;
}
else
{
SkASSERT
(
fOpInfo
.
fShapeTypes
=
=
kRect_ShapeFlag
)
;
this
-
>
emitRect
(
f
shapeCoords
opts
)
;
}
f
-
>
codeAppend
(
"
}
"
)
;
}
if
(
fOpInfo
.
fInnerShapeTypes
)
{
f
-
>
codeAppendf
(
"
/
/
Inner
shape
.
\
n
"
)
;
EmitShapeCoords
innerShapeCoords
;
innerShapeCoords
.
fVarying
=
&
fInnerShapeCoords
;
if
(
!
fOpInfo
.
fHasPerspective
)
{
innerShapeCoords
.
fInverseMatrix
=
fInnerShapeInverseMatrix
.
fsIn
(
)
;
innerShapeCoords
.
fFragHalfSpan
=
fFragInnerShapeHalfSpan
.
fsIn
(
)
;
}
EmitShapeOpts
innerOpts
;
innerOpts
.
fIsTightGeometry
=
false
;
innerOpts
.
fResolveMixedSamples
=
false
;
innerOpts
.
fInvertCoverage
=
true
;
if
(
kOval_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
this
-
>
emitArc
(
f
innerShapeCoords
true
false
innerOpts
)
;
}
else
{
f
-
>
codeAppendf
(
"
if
(
all
(
lessThan
(
abs
(
%
s
)
1
.
0
+
%
s
)
)
)
{
"
fInnerShapeCoords
.
fsIn
(
)
!
fOpInfo
.
fHasPerspective
?
innerShapeCoords
.
fFragHalfSpan
:
"
fragInnerShapeApproxHalfSpan
"
)
;
if
(
kRect_ShapeFlag
=
=
fOpInfo
.
fInnerShapeTypes
)
{
this
-
>
emitRect
(
f
innerShapeCoords
innerOpts
)
;
}
else
{
this
-
>
emitSimpleRRect
(
f
innerShapeCoords
fInnerRRect
.
fsIn
(
)
innerOpts
)
;
}
f
-
>
codeAppend
(
"
}
"
)
;
}
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
emitRect
(
GrGLSLPPFragmentBuilder
*
f
const
EmitShapeCoords
&
coords
const
EmitShapeOpts
&
opts
)
{
SkASSERT
(
!
opts
.
fIsTightGeometry
|
|
opts
.
fResolveMixedSamples
)
;
if
(
coords
.
fFragHalfSpan
)
{
f
-
>
codeAppendf
(
"
if
(
all
(
lessThanEqual
(
abs
(
%
s
)
1
.
0
-
%
s
)
)
)
{
"
coords
.
fVarying
-
>
fsIn
(
)
coords
.
fFragHalfSpan
)
;
this
-
>
acceptOrRejectWholeFragment
(
f
true
opts
)
;
f
-
>
codeAppend
(
"
}
else
"
)
;
if
(
opts
.
fIsTightGeometry
&
&
!
fRectTrianglesMaySplit
)
{
f
-
>
codeAppendf
(
"
if
(
any
(
lessThan
(
abs
(
%
s
)
1
.
0
-
%
s
)
)
)
{
"
coords
.
fVarying
-
>
fsIn
(
)
coords
.
fFragHalfSpan
)
;
this
-
>
acceptCoverageMask
(
f
"
gl_SampleMaskIn
[
0
]
"
opts
false
)
;
f
-
>
codeAppend
(
"
}
else
"
)
;
}
f
-
>
codeAppend
(
"
{
"
)
;
}
f
-
>
codeAppend
(
"
int
rectMask
=
0
;
"
)
;
f
-
>
codeAppend
(
"
for
(
int
i
=
0
;
i
<
SAMPLE_COUNT
;
i
+
+
)
{
"
)
;
f
-
>
codeAppend
(
"
highp
vec2
pt
=
"
)
;
this
-
>
interpolateAtSample
(
f
*
coords
.
fVarying
"
i
"
coords
.
fInverseMatrix
)
;
f
-
>
codeAppend
(
"
;
"
)
;
f
-
>
codeAppend
(
"
if
(
all
(
lessThan
(
abs
(
pt
)
vec2
(
1
)
)
)
)
rectMask
|
=
(
1
<
<
i
)
;
"
)
;
f
-
>
codeAppend
(
"
}
"
)
;
this
-
>
acceptCoverageMask
(
f
"
rectMask
"
opts
)
;
if
(
coords
.
fFragHalfSpan
)
{
f
-
>
codeAppend
(
"
}
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
emitArc
(
GrGLSLPPFragmentBuilder
*
f
const
EmitShapeCoords
&
coords
bool
coordsMayBeNegative
bool
clampCoords
const
EmitShapeOpts
&
opts
)
{
if
(
coords
.
fFragHalfSpan
)
{
SkString
absArcCoords
;
absArcCoords
.
printf
(
coordsMayBeNegative
?
"
abs
(
%
s
)
"
:
"
%
s
"
coords
.
fVarying
-
>
fsIn
(
)
)
;
if
(
clampCoords
)
{
f
-
>
codeAppendf
(
"
if
(
%
s
(
max
(
%
s
+
%
s
vec2
(
0
)
)
)
<
1
.
0
)
{
"
fSquareFun
.
c_str
(
)
absArcCoords
.
c_str
(
)
coords
.
fFragHalfSpan
)
;
}
else
{
f
-
>
codeAppendf
(
"
if
(
%
s
(
%
s
+
%
s
)
<
1
.
0
)
{
"
fSquareFun
.
c_str
(
)
absArcCoords
.
c_str
(
)
coords
.
fFragHalfSpan
)
;
}
this
-
>
acceptOrRejectWholeFragment
(
f
true
opts
)
;
f
-
>
codeAppendf
(
"
}
else
if
(
%
s
(
max
(
%
s
-
%
s
vec2
(
0
)
)
)
>
=
1
.
0
)
{
"
fSquareFun
.
c_str
(
)
absArcCoords
.
c_str
(
)
coords
.
fFragHalfSpan
)
;
this
-
>
acceptOrRejectWholeFragment
(
f
false
opts
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
}
f
-
>
codeAppend
(
"
int
arcMask
=
0
;
"
)
;
f
-
>
codeAppend
(
"
for
(
int
i
=
0
;
i
<
SAMPLE_COUNT
;
i
+
+
)
{
"
)
;
f
-
>
codeAppend
(
"
highp
vec2
pt
=
"
)
;
this
-
>
interpolateAtSample
(
f
*
coords
.
fVarying
"
i
"
coords
.
fInverseMatrix
)
;
f
-
>
codeAppend
(
"
;
"
)
;
if
(
clampCoords
)
{
SkASSERT
(
!
coordsMayBeNegative
)
;
f
-
>
codeAppend
(
"
pt
=
max
(
pt
vec2
(
0
)
)
;
"
)
;
}
f
-
>
codeAppendf
(
"
if
(
%
s
(
pt
)
<
1
.
0
)
arcMask
|
=
(
1
<
<
i
)
;
"
fSquareFun
.
c_str
(
)
)
;
f
-
>
codeAppend
(
"
}
"
)
;
this
-
>
acceptCoverageMask
(
f
"
arcMask
"
opts
)
;
if
(
coords
.
fFragHalfSpan
)
{
f
-
>
codeAppend
(
"
}
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
emitSimpleRRect
(
GrGLSLPPFragmentBuilder
*
f
const
EmitShapeCoords
&
coords
const
char
*
rrect
const
EmitShapeOpts
&
opts
)
{
f
-
>
codeAppendf
(
"
highp
vec2
distanceToArcEdge
=
abs
(
%
s
)
-
%
s
.
xy
;
"
coords
.
fVarying
-
>
fsIn
(
)
rrect
)
;
f
-
>
codeAppend
(
"
if
(
any
(
lessThan
(
distanceToArcEdge
vec2
(
0
)
)
)
)
{
"
)
;
this
-
>
emitRect
(
f
coords
opts
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
if
(
coords
.
fInverseMatrix
&
&
coords
.
fFragHalfSpan
)
{
f
-
>
codeAppendf
(
"
highp
vec2
rrectCoords
=
distanceToArcEdge
*
%
s
.
zw
;
"
rrect
)
;
f
-
>
codeAppendf
(
"
highp
vec2
fragRRectHalfSpan
=
%
s
*
%
s
.
zw
;
"
coords
.
fFragHalfSpan
rrect
)
;
f
-
>
codeAppendf
(
"
if
(
%
s
(
rrectCoords
+
fragRRectHalfSpan
)
<
=
1
.
0
)
{
"
fSquareFun
.
c_str
(
)
)
;
this
-
>
acceptOrRejectWholeFragment
(
f
true
opts
)
;
f
-
>
codeAppendf
(
"
}
else
if
(
%
s
(
max
(
rrectCoords
-
fragRRectHalfSpan
vec2
(
0
)
)
)
>
=
1
.
0
)
{
"
fSquareFun
.
c_str
(
)
)
;
this
-
>
acceptOrRejectWholeFragment
(
f
false
opts
)
;
f
-
>
codeAppend
(
"
}
else
{
"
)
;
f
-
>
codeAppendf
(
"
highp
vec2
s
=
%
s
.
zw
*
sign
(
%
s
)
;
"
rrect
coords
.
fVarying
-
>
fsIn
(
)
)
;
f
-
>
codeAppendf
(
"
highp
mat2
innerRRectInverseMatrix
=
%
s
*
mat2
(
s
.
x
0
0
s
.
y
)
;
"
coords
.
fInverseMatrix
)
;
f
-
>
codeAppend
(
"
highp
int
rrectMask
=
0
;
"
)
;
f
-
>
codeAppend
(
"
for
(
int
i
=
0
;
i
<
SAMPLE_COUNT
;
i
+
+
)
{
"
)
;
f
-
>
codeAppend
(
"
highp
vec2
pt
=
rrectCoords
+
"
)
;
f
-
>
appendOffsetToSample
(
"
i
"
GrGLSLFPFragmentBuilder
:
:
kSkiaDevice_Coordinates
)
;
f
-
>
codeAppend
(
"
*
innerRRectInverseMatrix
;
"
)
;
f
-
>
codeAppendf
(
"
if
(
%
s
(
max
(
pt
vec2
(
0
)
)
)
<
1
.
0
)
rrectMask
|
=
(
1
<
<
i
)
;
"
fSquareFun
.
c_str
(
)
)
;
f
-
>
codeAppend
(
"
}
"
)
;
this
-
>
acceptCoverageMask
(
f
"
rrectMask
"
opts
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
else
{
f
-
>
codeAppend
(
"
int
rrectMask
=
0
;
"
)
;
f
-
>
codeAppend
(
"
for
(
int
i
=
0
;
i
<
SAMPLE_COUNT
;
i
+
+
)
{
"
)
;
f
-
>
codeAppend
(
"
highp
vec2
shapePt
=
"
)
;
this
-
>
interpolateAtSample
(
f
*
coords
.
fVarying
"
i
"
nullptr
)
;
f
-
>
codeAppend
(
"
;
"
)
;
f
-
>
codeAppendf
(
"
highp
vec2
rrectPt
=
max
(
abs
(
shapePt
)
-
%
s
.
xy
vec2
(
0
)
)
*
%
s
.
zw
;
"
rrect
rrect
)
;
f
-
>
codeAppendf
(
"
if
(
%
s
(
rrectPt
)
<
1
.
0
)
rrectMask
|
=
(
1
<
<
i
)
;
"
fSquareFun
.
c_str
(
)
)
;
f
-
>
codeAppend
(
"
}
"
)
;
this
-
>
acceptCoverageMask
(
f
"
rrectMask
"
opts
)
;
}
f
-
>
codeAppend
(
"
}
"
)
;
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
interpolateAtSample
(
GrGLSLPPFragmentBuilder
*
f
const
GrGLSLVarying
&
varying
const
char
*
sampleIdx
const
char
*
interpolationMatrix
)
{
if
(
interpolationMatrix
)
{
f
-
>
codeAppendf
(
"
(
%
s
+
"
varying
.
fsIn
(
)
)
;
f
-
>
appendOffsetToSample
(
sampleIdx
GrGLSLFPFragmentBuilder
:
:
kSkiaDevice_Coordinates
)
;
f
-
>
codeAppendf
(
"
*
%
s
)
"
interpolationMatrix
)
;
}
else
{
SkAssertResult
(
f
-
>
enableFeature
(
GrGLSLFragmentBuilder
:
:
kMultisampleInterpolation_GLSLFeature
)
)
;
f
-
>
codeAppendf
(
"
interpolateAtOffset
(
%
s
"
varying
.
fsIn
(
)
)
;
f
-
>
appendOffsetToSample
(
sampleIdx
GrGLSLFPFragmentBuilder
:
:
kGLSLWindow_Coordinates
)
;
f
-
>
codeAppend
(
"
)
"
)
;
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
acceptOrRejectWholeFragment
(
GrGLSLPPFragmentBuilder
*
f
bool
inside
const
EmitShapeOpts
&
opts
)
{
if
(
inside
!
=
opts
.
fInvertCoverage
)
{
if
(
opts
.
fResolveMixedSamples
)
{
f
-
>
codeAppend
(
"
if
(
(
gl_SampleMaskIn
[
0
]
&
SAMPLE_MASK_MSB
)
=
=
0
)
{
"
)
;
if
(
!
fOpInfo
.
fCannotDiscard
)
{
f
-
>
codeAppend
(
"
discard
;
"
)
;
}
else
{
f
-
>
overrideSampleCoverage
(
"
0
"
)
;
}
f
-
>
codeAppend
(
"
}
else
{
"
)
;
f
-
>
overrideSampleCoverage
(
"
-
1
"
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
}
else
{
if
(
!
fOpInfo
.
fCannotDiscard
)
{
f
-
>
codeAppend
(
"
discard
;
"
)
;
}
else
if
(
opts
.
fResolveMixedSamples
)
{
f
-
>
overrideSampleCoverage
(
"
0
"
)
;
}
else
{
f
-
>
maskSampleCoverage
(
"
0
"
)
;
}
}
}
void
GLSLInstanceProcessor
:
:
BackendMultisample
:
:
acceptCoverageMask
(
GrGLSLPPFragmentBuilder
*
f
const
char
*
shapeMask
const
EmitShapeOpts
&
opts
bool
maybeSharedEdge
)
{
if
(
opts
.
fResolveMixedSamples
)
{
if
(
maybeSharedEdge
)
{
SkASSERT
(
!
opts
.
fInvertCoverage
)
;
f
-
>
codeAppendf
(
"
if
(
(
gl_SampleMaskIn
[
0
]
&
(
1
<
<
findMSB
(
%
s
)
)
)
=
=
0
)
{
"
shapeMask
)
;
if
(
!
fOpInfo
.
fCannotDiscard
)
{
f
-
>
codeAppend
(
"
discard
;
"
)
;
}
else
{
f
-
>
overrideSampleCoverage
(
"
0
"
)
;
}
f
-
>
codeAppend
(
"
}
else
{
"
)
;
f
-
>
overrideSampleCoverage
(
shapeMask
)
;
f
-
>
codeAppend
(
"
}
"
)
;
}
else
{
f
-
>
overrideSampleCoverage
(
shapeMask
)
;
}
}
else
{
f
-
>
maskSampleCoverage
(
shapeMask
opts
.
fInvertCoverage
)
;
}
}
GLSLInstanceProcessor
:
:
Backend
*
GLSLInstanceProcessor
:
:
Backend
:
:
Create
(
const
GrPipeline
&
pipeline
OpInfo
opInfo
const
VertexInputs
&
inputs
)
{
switch
(
opInfo
.
aaType
(
)
)
{
default
:
SkFAIL
(
"
Unexpected
antialias
mode
.
"
)
;
case
GrAAType
:
:
kNone
:
return
new
BackendNonAA
(
opInfo
inputs
)
;
case
GrAAType
:
:
kCoverage
:
return
new
BackendCoverage
(
opInfo
inputs
)
;
case
GrAAType
:
:
kMSAA
:
case
GrAAType
:
:
kMixedSamples
:
{
const
GrRenderTargetPriv
&
rtp
=
pipeline
.
getRenderTarget
(
)
-
>
renderTargetPriv
(
)
;
const
GrGpu
:
:
MultisampleSpecs
&
specs
=
rtp
.
getMultisampleSpecs
(
pipeline
)
;
return
new
BackendMultisample
(
opInfo
inputs
specs
.
fEffectiveSampleCnt
)
;
}
}
}
const
ShapeVertex
kVertexData
[
]
=
{
{
+
1
+
1
~
0
}
{
-
1
+
1
~
0
}
{
-
1
-
1
~
0
}
{
+
1
-
1
~
0
}
{
+
1
+
1
0
}
{
-
1
+
1
0
}
{
-
1
-
1
0
}
{
+
1
-
1
0
}
{
+
1
.
000000f
0
.
000000f
0
}
{
+
1
.
000000f
+
0
.
414214f
~
0
}
{
+
0
.
707106f
+
0
.
707106f
0
}
{
+
0
.
414214f
+
1
.
000000f
~
0
}
{
0
.
000000f
+
1
.
000000f
0
}
{
-
0
.
414214f
+
1
.
000000f
~
0
}
{
-
0
.
707106f
+
0
.
707106f
0
}
{
-
1
.
000000f
+
0
.
414214f
~
0
}
{
-
1
.
000000f
0
.
000000f
0
}
{
-
1
.
000000f
-
0
.
414214f
~
0
}
{
-
0
.
707106f
-
0
.
707106f
0
}
{
-
0
.
414214f
-
1
.
000000f
~
0
}
{
0
.
000000f
-
1
.
000000f
0
}
{
+
0
.
414214f
-
1
.
000000f
~
0
}
{
+
0
.
707106f
-
0
.
707106f
0
}
{
+
1
.
000000f
-
0
.
414214f
~
0
}
{
0
.
000000f
0
.
000000f
~
0
}
{
+
1
.
0
+
0
.
5
0x3
}
{
+
1
.
0
+
1
.
0
0x3
}
{
+
0
.
5
+
1
.
0
0x3
}
{
-
0
.
5
+
1
.
0
0x2
}
{
-
1
.
0
+
1
.
0
0x2
}
{
-
1
.
0
+
0
.
5
0x2
}
{
-
1
.
0
-
0
.
5
0x0
}
{
-
1
.
0
-
1
.
0
0x0
}
{
-
0
.
5
-
1
.
0
0x0
}
{
+
0
.
5
-
1
.
0
0x1
}
{
+
1
.
0
-
1
.
0
0x1
}
{
+
1
.
0
-
0
.
5
0x1
}
{
0
.
0
0
.
0
0x3
}
{
0
.
0
0
.
0
0x2
}
{
0
.
0
0
.
0
0x0
}
{
0
.
0
0
.
0
0x1
}
{
+
0
.
75
+
0
.
50
0x3
}
{
+
0
.
50
+
0
.
75
0x3
}
{
-
0
.
50
+
0
.
75
0x2
}
{
-
0
.
75
+
0
.
50
0x2
}
{
-
0
.
75
-
0
.
50
0x0
}
{
-
0
.
50
-
0
.
75
0x0
}
{
+
0
.
50
-
0
.
75
0x1
}
{
+
0
.
75
-
0
.
50
0x1
}
{
+
1
.
000000f
+
0
.
000000f
0
}
{
+
1
.
000000f
+
0
.
198913f
~
0
}
{
+
0
.
923879f
+
0
.
382683f
0
}
{
+
0
.
847760f
+
0
.
566455f
~
0
}
{
+
0
.
707106f
+
0
.
707106f
0
}
{
+
0
.
566455f
+
0
.
847760f
~
0
}
{
+
0
.
382683f
+
0
.
923879f
0
}
{
+
0
.
198913f
+
1
.
000000f
~
0
}
{
+
0
.
000000f
+
1
.
000000f
0
}
{
-
0
.
198913f
+
1
.
000000f
~
0
}
{
-
0
.
382683f
+
0
.
923879f
0
}
{
-
0
.
566455f
+
0
.
847760f
~
0
}
{
-
0
.
707106f
+
0
.
707106f
0
}
{
-
0
.
847760f
+
0
.
566455f
~
0
}
{
-
0
.
923879f
+
0
.
382683f
0
}
{
-
1
.
000000f
+
0
.
198913f
~
0
}
{
-
1
.
000000f
+
0
.
000000f
0
}
{
-
1
.
000000f
-
0
.
198913f
~
0
}
{
-
0
.
923879f
-
0
.
382683f
0
}
{
-
0
.
847760f
-
0
.
566455f
~
0
}
{
-
0
.
707106f
-
0
.
707106f
0
}
{
-
0
.
566455f
-
0
.
847760f
~
0
}
{
-
0
.
382683f
-
0
.
923879f
0
}
{
-
0
.
198913f
-
1
.
000000f
~
0
}
{
-
0
.
000000f
-
1
.
000000f
0
}
{
+
0
.
198913f
-
1
.
000000f
~
0
}
{
+
0
.
382683f
-
0
.
923879f
0
}
{
+
0
.
566455f
-
0
.
847760f
~
0
}
{
+
0
.
707106f
-
0
.
707106f
0
}
{
+
0
.
847760f
-
0
.
566455f
~
0
}
{
+
0
.
923879f
-
0
.
382683f
0
}
{
+
1
.
000000f
-
0
.
198913f
~
0
}
}
;
const
uint8_t
kIndexData
[
]
=
{
0
1
2
0
2
3
0
1
5
5
4
0
1
2
6
6
5
1
2
3
7
7
6
2
3
0
4
4
7
3
4
5
6
6
7
4
10
8
9
12
10
11
14
12
13
16
14
15
18
16
17
20
18
19
22
20
21
8
22
23
8
10
12
12
14
16
16
18
20
20
22
8
8
12
16
16
20
8
10
8
9
12
10
11
14
12
13
16
14
15
18
16
17
20
18
19
22
20
21
8
22
23
24
8
10
12
24
10
24
12
14
16
24
14
24
16
18
20
24
18
24
20
22
8
24
22
8
22
23
9
8
23
10
8
9
11
10
9
12
10
11
13
12
11
14
12
13
15
14
13
16
14
15
17
16
15
18
16
17
19
18
17
20
18
19
21
20
19
22
20
21
23
22
21
22
8
10
10
12
14
14
16
18
18
20
22
22
10
14
14
18
22
27
25
26
30
28
29
33
31
32
36
34
35
25
27
28
28
30
31
31
33
34
34
36
25
25
28
31
31
34
25
27
25
26
30
28
29
33
31
32
36
34
35
27
37
25
28
37
27
30
38
28
31
38
30
33
39
31
34
39
33
36
40
34
25
40
36
41
25
26
42
41
26
27
42
26
43
28
29
44
43
29
30
44
29
45
31
32
46
45
32
33
46
32
47
34
35
48
47
35
36
48
35
27
28
42
42
28
43
30
31
44
44
31
45
33
34
46
46
34
47
36
25
48
48
25
41
41
42
43
43
44
45
45
46
47
47
48
41
41
43
45
45
47
41
49
79
80
50
49
80
51
49
50
52
51
50
53
51
52
54
53
52
55
53
54
56
55
54
57
55
56
58
57
56
59
57
58
60
59
58
61
59
60
62
61
60
63
61
62
64
63
62
65
63
64
66
65
64
67
65
66
68
67
66
69
67
68
70
69
68
71
69
70
72
71
70
73
71
72
74
73
72
75
73
74
76
75
74
77
75
76
78
77
76
79
77
78
80
79
78
49
51
53
53
55
57
57
59
61
61
63
65
65
67
69
69
71
73
73
75
77
77
79
49
49
53
57
57
61
65
65
69
73
73
77
49
49
57
65
65
73
49
}
;
enum
{
kRect_FirstIndex
=
0
kRect_TriCount
=
2
kFramedRect_FirstIndex
=
6
kFramedRect_TriCount
=
10
kOctagons_FirstIndex
=
36
kOctagons_TriCount
=
14
kOctagonsFanned_FirstIndex
=
78
kOctagonsFanned_TriCount
=
16
kDisjointOctagons_FirstIndex
=
126
kDisjointOctagons_TriCount
=
22
kCorneredRect_FirstIndex
=
192
kCorneredRect_TriCount
=
10
kCorneredRectFanned_FirstIndex
=
222
kCorneredRectFanned_TriCount
=
12
kCorneredFramedRect_FirstIndex
=
258
kCorneredFramedRect_TriCount
=
26
kDisjoint16Gons_FirstIndex
=
336
kDisjoint16Gons_TriCount
=
46
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gShapeVertexBufferKey
)
;
const
GrBuffer
*
InstanceProcessor
:
:
FindOrCreateVertexBuffer
(
GrGpu
*
gpu
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gShapeVertexBufferKey
)
;
GrResourceCache
*
cache
=
gpu
-
>
getContext
(
)
-
>
getResourceCache
(
)
;
if
(
GrGpuResource
*
cached
=
cache
-
>
findAndRefUniqueResource
(
gShapeVertexBufferKey
)
)
{
return
static_cast
<
GrBuffer
*
>
(
cached
)
;
}
if
(
GrBuffer
*
buffer
=
gpu
-
>
createBuffer
(
sizeof
(
kVertexData
)
kVertex_GrBufferType
kStatic_GrAccessPattern
kVertexData
)
)
{
buffer
-
>
resourcePriv
(
)
.
setUniqueKey
(
gShapeVertexBufferKey
)
;
return
buffer
;
}
return
nullptr
;
}
GR_DECLARE_STATIC_UNIQUE_KEY
(
gShapeIndexBufferKey
)
;
const
GrBuffer
*
InstanceProcessor
:
:
FindOrCreateIndex8Buffer
(
GrGpu
*
gpu
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gShapeIndexBufferKey
)
;
GrResourceCache
*
cache
=
gpu
-
>
getContext
(
)
-
>
getResourceCache
(
)
;
if
(
GrGpuResource
*
cached
=
cache
-
>
findAndRefUniqueResource
(
gShapeIndexBufferKey
)
)
{
return
static_cast
<
GrBuffer
*
>
(
cached
)
;
}
if
(
GrBuffer
*
buffer
=
gpu
-
>
createBuffer
(
sizeof
(
kIndexData
)
kIndex_GrBufferType
kStatic_GrAccessPattern
kIndexData
)
)
{
buffer
-
>
resourcePriv
(
)
.
setUniqueKey
(
gShapeIndexBufferKey
)
;
return
buffer
;
}
return
nullptr
;
}
IndexRange
InstanceProcessor
:
:
GetIndexRangeForRect
(
GrAAType
aaType
)
{
switch
(
aaType
)
{
case
GrAAType
:
:
kCoverage
:
return
{
kFramedRect_FirstIndex
3
*
kFramedRect_TriCount
}
;
case
GrAAType
:
:
kNone
:
case
GrAAType
:
:
kMSAA
:
case
GrAAType
:
:
kMixedSamples
:
return
{
kRect_FirstIndex
3
*
kRect_TriCount
}
;
}
SkFAIL
(
"
Unexpected
aa
type
!
"
)
;
return
{
0
0
}
;
}
IndexRange
InstanceProcessor
:
:
GetIndexRangeForOval
(
GrAAType
aaType
const
SkRect
&
devBounds
)
{
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
devBounds
.
height
(
)
*
devBounds
.
width
(
)
>
=
256
*
256
)
{
return
{
kDisjoint16Gons_FirstIndex
3
*
kDisjoint16Gons_TriCount
}
;
}
switch
(
aaType
)
{
case
GrAAType
:
:
kNone
:
case
GrAAType
:
:
kMSAA
:
return
{
kOctagons_FirstIndex
3
*
kOctagons_TriCount
}
;
case
GrAAType
:
:
kCoverage
:
return
{
kDisjointOctagons_FirstIndex
3
*
kDisjointOctagons_TriCount
}
;
case
GrAAType
:
:
kMixedSamples
:
return
{
kOctagonsFanned_FirstIndex
3
*
kOctagonsFanned_TriCount
}
;
}
SkFAIL
(
"
Unexpected
aa
type
!
"
)
;
return
{
0
0
}
;
}
IndexRange
InstanceProcessor
:
:
GetIndexRangeForRRect
(
GrAAType
aaType
)
{
switch
(
aaType
)
{
case
GrAAType
:
:
kNone
:
case
GrAAType
:
:
kMSAA
:
return
{
kCorneredRect_FirstIndex
3
*
kCorneredRect_TriCount
}
;
case
GrAAType
:
:
kCoverage
:
return
{
kCorneredFramedRect_FirstIndex
3
*
kCorneredFramedRect_TriCount
}
;
case
GrAAType
:
:
kMixedSamples
:
return
{
kCorneredRectFanned_FirstIndex
3
*
kCorneredRectFanned_TriCount
}
;
}
SkFAIL
(
"
Unexpected
aa
type
!
"
)
;
return
{
0
0
}
;
}
const
char
*
InstanceProcessor
:
:
GetNameOfIndexRange
(
IndexRange
range
)
{
switch
(
range
.
fStart
)
{
case
kRect_FirstIndex
:
return
"
basic_rect
"
;
case
kFramedRect_FirstIndex
:
return
"
coverage_rect
"
;
case
kOctagons_FirstIndex
:
return
"
basic_oval
"
;
case
kDisjointOctagons_FirstIndex
:
return
"
coverage_oval
"
;
case
kDisjoint16Gons_FirstIndex
:
return
"
coverage_large_oval
"
;
case
kOctagonsFanned_FirstIndex
:
return
"
mixed_samples_oval
"
;
case
kCorneredRect_FirstIndex
:
return
"
basic_round_rect
"
;
case
kCorneredFramedRect_FirstIndex
:
return
"
coverage_round_rect
"
;
case
kCorneredRectFanned_FirstIndex
:
return
"
mixed_samples_round_rect
"
;
default
:
return
"
unknown
"
;
}
}
}
