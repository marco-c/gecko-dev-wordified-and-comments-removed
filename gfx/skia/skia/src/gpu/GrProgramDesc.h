#
ifndef
GrProgramDesc_DEFINED
#
define
GrProgramDesc_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrTypesPriv
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkTArray
.
h
"
class
GrGLSLCaps
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrProgramDesc
{
public
:
GrProgramDesc
(
)
{
}
static
bool
Build
(
GrProgramDesc
*
const
GrPrimitiveProcessor
&
bool
hasPointSize
const
GrPipeline
&
const
GrGLSLCaps
&
)
;
const
uint32_t
*
asKey
(
)
const
{
return
reinterpret_cast
<
const
uint32_t
*
>
(
fKey
.
begin
(
)
)
;
}
uint32_t
keyLength
(
)
const
{
return
*
this
-
>
atOffset
<
uint32_t
kLengthOffset
>
(
)
;
}
uint32_t
getChecksum
(
)
const
{
return
*
this
-
>
atOffset
<
uint32_t
kChecksumOffset
>
(
)
;
}
GrProgramDesc
&
operator
=
(
const
GrProgramDesc
&
other
)
{
uint32_t
keyLength
=
other
.
keyLength
(
)
;
fKey
.
reset
(
SkToInt
(
keyLength
)
)
;
memcpy
(
fKey
.
begin
(
)
other
.
fKey
.
begin
(
)
keyLength
)
;
return
*
this
;
}
bool
operator
=
=
(
const
GrProgramDesc
&
that
)
const
{
SkASSERT
(
SkIsAlign4
(
this
-
>
keyLength
(
)
)
)
;
int
l
=
this
-
>
keyLength
(
)
>
>
2
;
const
uint32_t
*
aKey
=
this
-
>
asKey
(
)
;
const
uint32_t
*
bKey
=
that
.
asKey
(
)
;
for
(
int
i
=
0
;
i
<
l
;
+
+
i
)
{
if
(
aKey
[
i
]
!
=
bKey
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
GrProgramDesc
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
static
bool
Less
(
const
GrProgramDesc
&
a
const
GrProgramDesc
&
b
)
{
SkASSERT
(
SkIsAlign4
(
a
.
keyLength
(
)
)
)
;
int
l
=
a
.
keyLength
(
)
>
>
2
;
const
uint32_t
*
aKey
=
a
.
asKey
(
)
;
const
uint32_t
*
bKey
=
b
.
asKey
(
)
;
for
(
int
i
=
0
;
i
<
l
;
+
+
i
)
{
if
(
aKey
[
i
]
!
=
bKey
[
i
]
)
{
return
aKey
[
i
]
<
bKey
[
i
]
?
true
:
false
;
}
}
return
false
;
}
struct
KeyHeader
{
uint8_t
fSamplePatternKey
;
uint8_t
fOutputSwizzle
;
uint8_t
fColorFragmentProcessorCnt
:
4
;
uint8_t
fCoverageFragmentProcessorCnt
:
4
;
uint8_t
fSurfaceOriginKey
:
2
;
uint8_t
fIgnoresCoverage
:
1
;
uint8_t
fSnapVerticesToPixelCenters
:
1
;
uint8_t
fHasPointSize
:
1
;
uint8_t
fPad
:
3
;
}
;
GR_STATIC_ASSERT
(
sizeof
(
KeyHeader
)
=
=
4
)
;
const
KeyHeader
&
header
(
)
const
{
return
*
this
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
}
void
finalize
(
)
{
int
keyLength
=
fKey
.
count
(
)
;
SkASSERT
(
0
=
=
(
keyLength
%
4
)
)
;
*
(
this
-
>
atOffset
<
uint32_t
GrProgramDesc
:
:
kLengthOffset
>
(
)
)
=
SkToU32
(
keyLength
)
;
uint32_t
*
checksum
=
this
-
>
atOffset
<
uint32_t
GrProgramDesc
:
:
kChecksumOffset
>
(
)
;
*
checksum
=
0
;
*
checksum
=
SkOpts
:
:
hash
(
fKey
.
begin
(
)
keyLength
)
;
}
protected
:
template
<
typename
T
size_t
OFFSET
>
T
*
atOffset
(
)
{
return
reinterpret_cast
<
T
*
>
(
reinterpret_cast
<
intptr_t
>
(
fKey
.
begin
(
)
)
+
OFFSET
)
;
}
template
<
typename
T
size_t
OFFSET
>
const
T
*
atOffset
(
)
const
{
return
reinterpret_cast
<
const
T
*
>
(
reinterpret_cast
<
intptr_t
>
(
fKey
.
begin
(
)
)
+
OFFSET
)
;
}
enum
KeyOffsets
{
kLengthOffset
=
0
kChecksumOffset
=
kLengthOffset
+
sizeof
(
uint32_t
)
kHeaderOffset
=
kChecksumOffset
+
sizeof
(
uint32_t
)
kHeaderSize
=
SkAlign4
(
sizeof
(
KeyHeader
)
)
kProcessorKeysOffset
=
kHeaderOffset
+
kHeaderSize
}
;
enum
{
kMaxPreallocProcessors
=
8
kIntsPerProcessor
=
4
kPreAllocSize
=
kHeaderOffset
+
kHeaderSize
+
kMaxPreallocProcessors
*
sizeof
(
uint32_t
)
*
kIntsPerProcessor
}
;
SkSTArray
<
kPreAllocSize
uint8_t
true
>
&
key
(
)
{
return
fKey
;
}
const
SkSTArray
<
kPreAllocSize
uint8_t
true
>
&
key
(
)
const
{
return
fKey
;
}
private
:
SkSTArray
<
kPreAllocSize
uint8_t
true
>
fKey
;
}
;
#
endif
