#
ifndef
GrProgramDesc_DEFINED
#
define
GrProgramDesc_DEFINED
#
include
"
include
/
private
/
GrTypesPriv
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
gpu
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
class
GrProgramInfo
;
class
GrShaderCaps
;
class
GrProgramDesc
{
public
:
GrProgramDesc
(
)
{
}
static
bool
Build
(
GrProgramDesc
*
const
GrRenderTarget
*
const
GrProgramInfo
&
GrPrimitiveType
GrGpu
*
)
;
static
bool
BuildFromData
(
GrProgramDesc
*
desc
const
void
*
keyData
size_t
keyLength
)
{
if
(
!
SkTFitsIn
<
int
>
(
keyLength
)
)
{
return
false
;
}
desc
-
>
fKey
.
reset
(
SkToInt
(
keyLength
)
)
;
memcpy
(
desc
-
>
fKey
.
begin
(
)
keyData
keyLength
)
;
return
true
;
}
const
uint32_t
*
asKey
(
)
const
{
return
reinterpret_cast
<
const
uint32_t
*
>
(
fKey
.
begin
(
)
)
;
}
uint32_t
keyLength
(
)
const
{
SkASSERT
(
0
=
=
(
fKey
.
count
(
)
%
4
)
)
;
return
fKey
.
count
(
)
;
}
GrProgramDesc
&
operator
=
(
const
GrProgramDesc
&
other
)
{
uint32_t
keyLength
=
other
.
keyLength
(
)
;
fKey
.
reset
(
SkToInt
(
keyLength
)
)
;
memcpy
(
fKey
.
begin
(
)
other
.
fKey
.
begin
(
)
keyLength
)
;
return
*
this
;
}
bool
operator
=
=
(
const
GrProgramDesc
&
that
)
const
{
if
(
this
-
>
keyLength
(
)
!
=
that
.
keyLength
(
)
)
{
return
false
;
}
SkASSERT
(
SkIsAlign4
(
this
-
>
keyLength
(
)
)
)
;
int
l
=
this
-
>
keyLength
(
)
>
>
2
;
const
uint32_t
*
aKey
=
this
-
>
asKey
(
)
;
const
uint32_t
*
bKey
=
that
.
asKey
(
)
;
for
(
int
i
=
0
;
i
<
l
;
+
+
i
)
{
if
(
aKey
[
i
]
!
=
bKey
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
GrProgramDesc
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
hasPointSize
(
)
const
{
return
this
-
>
header
(
)
.
fHasPointSize
;
}
protected
:
struct
KeyHeader
{
uint16_t
fOutputSwizzle
;
uint8_t
fColorFragmentProcessorCnt
;
uint8_t
fCoverageFragmentProcessorCnt
;
uint8_t
fSurfaceOriginKey
:
2
;
uint8_t
fProcessorFeatures
:
1
;
bool
fSnapVerticesToPixelCenters
:
1
;
bool
fHasPointSize
:
1
;
uint8_t
fPad
:
3
;
}
;
GR_STATIC_ASSERT
(
sizeof
(
KeyHeader
)
=
=
6
)
;
const
KeyHeader
&
header
(
)
const
{
return
*
this
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
}
template
<
typename
T
size_t
OFFSET
>
T
*
atOffset
(
)
{
return
reinterpret_cast
<
T
*
>
(
reinterpret_cast
<
intptr_t
>
(
fKey
.
begin
(
)
)
+
OFFSET
)
;
}
template
<
typename
T
size_t
OFFSET
>
const
T
*
atOffset
(
)
const
{
return
reinterpret_cast
<
const
T
*
>
(
reinterpret_cast
<
intptr_t
>
(
fKey
.
begin
(
)
)
+
OFFSET
)
;
}
enum
KeyOffsets
{
kHeaderOffset
=
0
kHeaderSize
=
SkAlign4
(
sizeof
(
KeyHeader
)
)
kProcessorKeysOffset
=
kHeaderOffset
+
kHeaderSize
}
;
enum
{
kMaxPreallocProcessors
=
8
kIntsPerProcessor
=
4
kPreAllocSize
=
kHeaderOffset
+
kHeaderSize
+
kMaxPreallocProcessors
*
sizeof
(
uint32_t
)
*
kIntsPerProcessor
}
;
SkSTArray
<
kPreAllocSize
uint8_t
true
>
&
key
(
)
{
return
fKey
;
}
const
SkSTArray
<
kPreAllocSize
uint8_t
true
>
&
key
(
)
const
{
return
fKey
;
}
private
:
SkSTArray
<
kPreAllocSize
uint8_t
true
>
fKey
;
}
;
#
endif
