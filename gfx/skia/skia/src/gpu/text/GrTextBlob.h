#
ifndef
GrTextBlob_DEFINED
#
define
GrTextBlob_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrStrikeCache
.
h
"
#
include
"
GrTextTarget
.
h
"
#
include
"
text
/
GrTextContext
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkPoint3
.
h
"
#
include
"
SkRectPriv
.
h
"
#
include
"
SkStrikeCache
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTInternalLList
.
h
"
class
GrAtlasManager
;
struct
GrDistanceFieldAdjustTable
;
struct
GrGlyph
;
class
SkTextBlob
;
class
SkTextBlobRunIterator
;
#
define
CACHE_SANITY_CHECK
0
class
GrTextBlob
:
public
SkNVRefCnt
<
GrTextBlob
>
{
struct
Run
;
public
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrTextBlob
)
;
class
VertexRegenerator
;
void
generateFromGlyphRunList
(
const
GrShaderCaps
&
shaderCaps
const
GrTextContext
:
:
Options
&
options
const
SkPaint
&
paint
SkScalerContextFlags
scalerContextFlags
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
SkGlyphRunList
&
glyphRunList
SkGlyphRunListPainter
*
glyphPainter
)
;
static
sk_sp
<
GrTextBlob
>
Make
(
int
glyphCount
int
runCount
GrColor
color
GrStrikeCache
*
strikeCache
)
;
struct
Key
{
Key
(
)
{
sk_bzero
(
this
sizeof
(
Key
)
)
;
}
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkPaint
:
:
Style
fStyle
;
SkPixelGeometry
fPixelGeometry
;
bool
fHasBlur
;
uint32_t
fScalerContextFlags
;
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
0
=
=
memcmp
(
this
&
other
sizeof
(
Key
)
)
;
}
}
;
void
setupKey
(
const
GrTextBlob
:
:
Key
&
key
const
SkMaskFilterBase
:
:
BlurRec
&
blurRec
const
SkPaint
&
paint
)
{
fKey
=
key
;
if
(
key
.
fHasBlur
)
{
fBlurRec
=
blurRec
;
}
if
(
key
.
fStyle
!
=
SkPaint
:
:
kFill_Style
)
{
fStrokeInfo
.
fFrameWidth
=
paint
.
getStrokeWidth
(
)
;
fStrokeInfo
.
fMiterLimit
=
paint
.
getStrokeMiter
(
)
;
fStrokeInfo
.
fJoin
=
paint
.
getStrokeJoin
(
)
;
}
}
static
const
Key
&
GetKey
(
const
GrTextBlob
&
blob
)
{
return
blob
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
SkOpts
:
:
hash
(
&
key
sizeof
(
Key
)
)
;
}
void
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
void
*
operator
new
(
size_t
)
{
SK_ABORT
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
bool
hasDistanceField
(
)
const
{
return
SkToBool
(
fTextType
&
kHasDistanceField_TextType
)
;
}
bool
hasBitmap
(
)
const
{
return
SkToBool
(
fTextType
&
kHasBitmap_TextType
)
;
}
void
setHasDistanceField
(
)
{
fTextType
|
=
kHasDistanceField_TextType
;
}
void
setHasBitmap
(
)
{
fTextType
|
=
kHasBitmap_TextType
;
}
int
runCountLimit
(
)
const
{
return
fRunCountLimit
;
}
Run
*
pushBackRun
(
)
{
SkASSERT
(
fRunCount
<
fRunCountLimit
)
;
if
(
fRunCount
>
0
)
{
SubRun
&
newRun
=
fRuns
[
fRunCount
]
.
fSubRunInfo
.
back
(
)
;
SubRun
&
lastRun
=
fRuns
[
fRunCount
-
1
]
.
fSubRunInfo
.
back
(
)
;
newRun
.
setAsSuccessor
(
lastRun
)
;
}
fRunCount
+
+
;
return
this
-
>
currentRun
(
)
;
}
void
setMinAndMaxScale
(
SkScalar
scaledMin
SkScalar
scaledMax
)
{
fMaxMinScale
=
SkMaxScalar
(
scaledMin
fMaxMinScale
)
;
fMinMaxScale
=
SkMinScalar
(
scaledMax
fMinMaxScale
)
;
}
static
size_t
GetVertexStride
(
GrMaskFormat
maskFormat
bool
hasWCoord
)
{
switch
(
maskFormat
)
{
case
kA8_GrMaskFormat
:
return
hasWCoord
?
kGrayTextDFPerspectiveVASize
:
kGrayTextVASize
;
case
kARGB_GrMaskFormat
:
return
hasWCoord
?
kColorTextPerspectiveVASize
:
kColorTextVASize
;
default
:
SkASSERT
(
!
hasWCoord
)
;
return
kLCDTextVASize
;
}
}
bool
mustRegenerate
(
const
SkPaint
&
bool
const
SkMaskFilterBase
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
;
void
flush
(
GrTextTarget
*
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
;
void
computeSubRunBounds
(
SkRect
*
outBounds
int
runIndex
int
subRunIndex
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
bool
needsGlyphTransform
)
{
const
Run
&
run
=
fRuns
[
runIndex
]
;
const
SubRun
&
subRun
=
run
.
fSubRunInfo
[
subRunIndex
]
;
*
outBounds
=
subRun
.
vertexBounds
(
)
;
if
(
needsGlyphTransform
)
{
outBounds
-
>
offset
(
x
-
fInitialX
y
-
fInitialY
)
;
viewMatrix
.
mapRect
(
outBounds
)
;
}
else
{
SkMatrix
boundsMatrix
=
fInitialViewMatrixInverse
;
boundsMatrix
.
postTranslate
(
-
fInitialX
-
fInitialY
)
;
boundsMatrix
.
postTranslate
(
x
y
)
;
boundsMatrix
.
postConcat
(
viewMatrix
)
;
boundsMatrix
.
mapRect
(
outBounds
)
;
outBounds
-
>
roundOut
(
outBounds
)
;
}
}
static
const
size_t
kColorTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kColorTextPerspectiveVASize
=
sizeof
(
SkPoint3
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextDFPerspectiveVASize
=
sizeof
(
SkPoint3
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kLCDTextVASize
=
kGrayTextVASize
;
static
const
size_t
kMaxVASize
=
kGrayTextDFPerspectiveVASize
;
static
const
int
kVerticesPerGlyph
=
4
;
static
void
AssertEqual
(
const
GrTextBlob
&
const
GrTextBlob
&
)
;
void
initReusableBlob
(
SkColor
luminanceColor
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fLuminanceColor
=
luminanceColor
;
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
void
initThrowawayBlob
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
const
Key
&
key
(
)
const
{
return
fKey
;
}
size_t
size
(
)
const
{
return
fSize
;
}
~
GrTextBlob
(
)
{
for
(
int
i
=
0
;
i
<
fRunCountLimit
;
i
+
+
)
{
fRuns
[
i
]
.
~
Run
(
)
;
}
}
std
:
:
unique_ptr
<
GrDrawOp
>
test_makeOp
(
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
SkSurfaceProps
&
const
GrDistanceFieldAdjustTable
*
GrTextTarget
*
)
;
private
:
GrTextBlob
(
GrStrikeCache
*
strikeCache
)
:
fStrikeCache
{
strikeCache
}
{
}
void
setupViewMatrix
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fInitialViewMatrix
=
viewMatrix
;
if
(
!
viewMatrix
.
invert
(
&
fInitialViewMatrixInverse
)
)
{
fInitialViewMatrixInverse
=
SkMatrix
:
:
I
(
)
;
}
fInitialX
=
x
;
fInitialY
=
y
;
for
(
int
i
=
0
;
i
<
fRunCountLimit
;
i
+
+
)
{
fRuns
[
i
]
.
fSubRunInfo
[
0
]
.
init
(
fInitialViewMatrix
x
y
)
;
}
}
class
SubRun
{
public
:
SubRun
(
Run
*
run
const
SkAutoDescriptor
&
desc
GrColor
color
)
:
fColor
{
color
}
fRun
{
run
}
fDesc
{
desc
}
{
}
void
appendGlyph
(
GrGlyph
*
glyph
SkRect
dstRect
)
;
void
resetBulkUseToken
(
)
{
fBulkUseToken
.
reset
(
)
;
}
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
bulkUseToken
(
)
{
return
&
fBulkUseToken
;
}
void
setStrike
(
sk_sp
<
GrTextStrike
>
strike
)
{
fStrike
=
std
:
:
move
(
strike
)
;
}
GrTextStrike
*
strike
(
)
const
{
return
fStrike
.
get
(
)
;
}
sk_sp
<
GrTextStrike
>
refStrike
(
)
const
{
return
fStrike
;
}
void
setAtlasGeneration
(
uint64_t
atlasGeneration
)
{
fAtlasGeneration
=
atlasGeneration
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
size_t
byteCount
(
)
const
{
return
fVertexEndIndex
-
fVertexStartIndex
;
}
size_t
vertexStartIndex
(
)
const
{
return
fVertexStartIndex
;
}
size_t
vertexEndIndex
(
)
const
{
return
fVertexEndIndex
;
}
uint32_t
glyphCount
(
)
const
{
return
fGlyphEndIndex
-
fGlyphStartIndex
;
}
uint32_t
glyphStartIndex
(
)
const
{
return
fGlyphStartIndex
;
}
uint32_t
glyphEndIndex
(
)
const
{
return
fGlyphEndIndex
;
}
void
setColor
(
GrColor
color
)
{
fColor
=
color
;
}
GrColor
color
(
)
const
{
return
fColor
;
}
void
setMaskFormat
(
GrMaskFormat
format
)
{
fMaskFormat
=
format
;
}
GrMaskFormat
maskFormat
(
)
const
{
return
fMaskFormat
;
}
void
setAsSuccessor
(
const
SubRun
&
prev
)
{
fGlyphStartIndex
=
prev
.
glyphEndIndex
(
)
;
fGlyphEndIndex
=
fGlyphStartIndex
;
fVertexStartIndex
=
prev
.
vertexEndIndex
(
)
;
fVertexEndIndex
=
fVertexStartIndex
;
this
-
>
init
(
prev
.
fCurrentViewMatrix
prev
.
fX
prev
.
fY
)
;
}
const
SkRect
&
vertexBounds
(
)
const
{
return
fVertexBounds
;
}
void
joinGlyphBounds
(
const
SkRect
&
glyphBounds
)
{
fVertexBounds
.
joinNonEmptyArg
(
glyphBounds
)
;
}
void
init
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fCurrentViewMatrix
=
viewMatrix
;
fX
=
x
;
fY
=
y
;
}
void
computeTranslation
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
SkScalar
*
transX
SkScalar
*
transY
)
;
void
setDrawAsDistanceFields
(
)
{
fFlags
.
drawAsSdf
=
true
;
}
bool
drawAsDistanceFields
(
)
const
{
return
fFlags
.
drawAsSdf
;
}
void
setUseLCDText
(
bool
useLCDText
)
{
fFlags
.
useLCDText
=
useLCDText
;
}
bool
hasUseLCDText
(
)
const
{
return
fFlags
.
useLCDText
;
}
void
setAntiAliased
(
bool
antiAliased
)
{
fFlags
.
antiAliased
=
antiAliased
;
}
bool
isAntiAliased
(
)
const
{
return
fFlags
.
antiAliased
;
}
void
setHasWCoord
(
bool
hasW
)
{
fFlags
.
hasWCoord
=
hasW
;
}
bool
hasWCoord
(
)
const
{
return
fFlags
.
hasWCoord
;
}
void
setNeedsTransform
(
bool
needsTransform
)
{
fFlags
.
needsTransform
=
needsTransform
;
}
bool
needsTransform
(
)
const
{
return
fFlags
.
needsTransform
;
}
void
setFallback
(
)
{
fFlags
.
argbFallback
=
true
;
}
bool
isFallback
(
)
{
return
fFlags
.
argbFallback
;
}
const
SkDescriptor
*
desc
(
)
const
{
return
fDesc
.
getDesc
(
)
;
}
private
:
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
fBulkUseToken
;
sk_sp
<
GrTextStrike
>
fStrike
;
SkMatrix
fCurrentViewMatrix
;
SkRect
fVertexBounds
=
SkRectPriv
:
:
MakeLargestInverted
(
)
;
uint64_t
fAtlasGeneration
{
GrDrawOpAtlas
:
:
kInvalidAtlasGeneration
}
;
size_t
fVertexStartIndex
{
0
}
;
size_t
fVertexEndIndex
{
0
}
;
uint32_t
fGlyphStartIndex
{
0
}
;
uint32_t
fGlyphEndIndex
{
0
}
;
SkScalar
fX
;
SkScalar
fY
;
GrColor
fColor
{
GrColor_ILLEGAL
}
;
GrMaskFormat
fMaskFormat
{
kA8_GrMaskFormat
}
;
struct
{
bool
drawAsSdf
:
1
;
bool
useLCDText
:
1
;
bool
antiAliased
:
1
;
bool
hasWCoord
:
1
;
bool
needsTransform
:
1
;
bool
argbFallback
:
1
;
}
fFlags
{
false
false
false
false
false
false
}
;
Run
*
const
fRun
;
const
SkAutoDescriptor
&
fDesc
;
}
;
struct
Run
{
explicit
Run
(
GrTextBlob
*
blob
GrColor
color
)
:
fBlob
{
blob
}
fColor
{
color
}
{
fSubRunInfo
.
emplace_back
(
this
fDescriptor
color
)
;
}
void
setSubRunHasW
(
bool
hasWCoord
)
{
SubRun
&
subRun
=
this
-
>
fSubRunInfo
.
back
(
)
;
subRun
.
setHasWCoord
(
hasWCoord
)
;
}
SubRun
*
initARGBFallback
(
)
{
fARGBFallbackDescriptor
.
reset
(
new
SkAutoDescriptor
{
}
)
;
SubRun
*
subRun
=
this
-
>
pushBackSubRun
(
*
fARGBFallbackDescriptor
fColor
)
;
subRun
-
>
setMaskFormat
(
kARGB_GrMaskFormat
)
;
subRun
-
>
setFallback
(
)
;
return
subRun
;
}
void
appendPathGlyph
(
const
SkPath
&
path
SkPoint
position
SkScalar
scale
bool
preTransformed
)
;
void
switchSubRunIfNeededAndAppendGlyph
(
GrGlyph
*
glyph
const
sk_sp
<
GrTextStrike
>
&
strike
const
SkRect
&
destRect
bool
needsTransform
)
;
void
appendDeviceSpaceGlyph
(
const
sk_sp
<
GrTextStrike
>
&
strike
const
SkGlyph
&
skGlyph
SkPoint
origin
)
;
void
appendSourceSpaceGlyph
(
const
sk_sp
<
GrTextStrike
>
&
strike
const
SkGlyph
&
skGlyph
SkPoint
origin
SkScalar
textScale
)
;
void
setupFont
(
const
SkStrikeSpec
&
strikeSpec
)
;
void
setRunFontAntiAlias
(
bool
aa
)
{
fAntiAlias
=
aa
;
}
void
setSubRunHasDistanceFields
(
bool
hasLCD
bool
isAntiAlias
bool
hasWCoord
)
{
SubRun
&
subRun
=
fSubRunInfo
.
back
(
)
;
subRun
.
setUseLCDText
(
hasLCD
)
;
subRun
.
setAntiAliased
(
isAntiAlias
)
;
subRun
.
setDrawAsDistanceFields
(
)
;
subRun
.
setHasWCoord
(
hasWCoord
)
;
}
SubRun
*
pushBackSubRun
(
const
SkAutoDescriptor
&
desc
GrColor
color
)
{
SubRun
&
newSubRun
=
fSubRunInfo
.
emplace_back
(
this
desc
color
)
;
const
SubRun
&
prevSubRun
=
fSubRunInfo
.
fromBack
(
1
)
;
newSubRun
.
setAsSuccessor
(
prevSubRun
)
;
return
&
newSubRun
;
}
struct
PathGlyph
{
PathGlyph
(
const
SkPath
&
path
SkScalar
x
SkScalar
y
SkScalar
scale
bool
preXformed
)
:
fPath
(
path
)
fX
(
x
)
fY
(
y
)
fScale
(
scale
)
fPreTransformed
(
preXformed
)
{
}
SkPath
fPath
;
SkScalar
fX
;
SkScalar
fY
;
SkScalar
fScale
;
bool
fPreTransformed
;
}
;
sk_sp
<
SkTypeface
>
fTypeface
;
SkSTArray
<
1
SubRun
>
fSubRunInfo
;
SkAutoDescriptor
fDescriptor
;
sk_sp
<
SkPathEffect
>
fPathEffect
;
sk_sp
<
SkMaskFilter
>
fMaskFilter
;
std
:
:
unique_ptr
<
SkAutoDescriptor
>
fARGBFallbackDescriptor
;
SkTArray
<
PathGlyph
>
fPathGlyphs
;
bool
fAntiAlias
{
false
}
;
bool
fInitialized
{
false
}
;
GrTextBlob
*
const
fBlob
;
GrColor
fColor
;
}
;
std
:
:
unique_ptr
<
GrAtlasTextOp
>
makeOp
(
const
SubRun
&
info
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkIRect
&
clipRect
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
SkSurfaceProps
&
const
GrDistanceFieldAdjustTable
*
GrTextTarget
*
)
;
Run
*
currentRun
(
)
;
void
startRun
(
const
SkGlyphRun
&
glyphRun
bool
useSDFT
)
;
void
processMasksDevice
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
masks
SkStrikeInterface
*
strike
)
;
void
processPathsSource
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
paths
SkStrikeInterface
*
strike
SkScalar
textScale
)
;
void
processPathsDevice
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
paths
)
;
void
processSDFTSource
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
masks
SkStrikeInterface
*
strike
const
SkFont
&
runFont
SkScalar
textScale
SkScalar
minScale
SkScalar
maxScale
bool
hasWCoord
)
;
void
processFallbackSource
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
masks
SkStrikeInterface
*
strike
SkScalar
strikeToSourceRatio
bool
hasW
)
;
void
processFallbackDevice
(
SkSpan
<
const
SkGlyphRunListPainter
:
:
GlyphAndPos
>
masks
SkStrikeInterface
*
strike
)
;
struct
StrokeInfo
{
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPaint
:
:
Join
fJoin
;
}
;
enum
TextType
{
kHasDistanceField_TextType
=
0x1
kHasBitmap_TextType
=
0x2
}
;
char
*
fVertices
;
GrGlyph
*
*
fGlyphs
;
Run
*
fRuns
;
GrStrikeCache
*
const
fStrikeCache
;
SkMaskFilterBase
:
:
BlurRec
fBlurRec
;
StrokeInfo
fStrokeInfo
;
Key
fKey
;
SkMatrix
fInitialViewMatrix
;
SkMatrix
fInitialViewMatrixInverse
;
size_t
fSize
;
SkColor
fLuminanceColor
;
SkScalar
fInitialX
;
SkScalar
fInitialY
;
SkScalar
fMaxMinScale
{
-
SK_ScalarMax
}
;
SkScalar
fMinMaxScale
{
SK_ScalarMax
}
;
int
fRunCount
{
0
}
;
int
fRunCountLimit
;
uint8_t
fTextType
{
0
}
;
}
;
class
GrTextBlob
:
:
VertexRegenerator
{
public
:
VertexRegenerator
(
GrResourceProvider
*
GrTextBlob
*
int
runIdx
int
subRunIdx
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
GrColor
color
GrDeferredUploadTarget
*
GrStrikeCache
*
GrAtlasManager
*
SkExclusiveStrikePtr
*
)
;
struct
Result
{
bool
fFinished
=
true
;
int
fGlyphsRegenerated
=
0
;
const
char
*
fFirstVertex
;
}
;
bool
regenerate
(
Result
*
)
;
private
:
bool
doRegen
(
Result
*
bool
regenPos
bool
regenCol
bool
regenTexCoords
bool
regenGlyphs
)
;
GrResourceProvider
*
fResourceProvider
;
const
SkMatrix
&
fViewMatrix
;
GrTextBlob
*
fBlob
;
GrDeferredUploadTarget
*
fUploadTarget
;
GrStrikeCache
*
fGlyphCache
;
GrAtlasManager
*
fFullAtlasManager
;
SkExclusiveStrikePtr
*
fLazyCache
;
Run
*
fRun
;
SubRun
*
fSubRun
;
GrColor
fColor
;
SkScalar
fTransX
;
SkScalar
fTransY
;
uint32_t
fRegenFlags
=
0
;
int
fCurrGlyph
=
0
;
bool
fBrokenRun
=
false
;
}
;
#
endif
