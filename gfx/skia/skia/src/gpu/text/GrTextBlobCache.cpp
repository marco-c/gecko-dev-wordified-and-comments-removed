#
include
"
GrTextBlobCache
.
h
"
DECLARE_SKMESSAGEBUS_MESSAGE
(
GrTextBlobCache
:
:
PurgeBlobMessage
)
GrTextBlobCache
:
:
~
GrTextBlobCache
(
)
{
this
-
>
freeAll
(
)
;
delete
fPool
;
}
void
GrTextBlobCache
:
:
freeAll
(
)
{
fBlobIDCache
.
foreach
(
[
this
]
(
uint32_t
BlobIDCacheEntry
*
entry
)
{
for
(
const
auto
&
blob
:
entry
-
>
fBlobs
)
{
fBlobList
.
remove
(
blob
.
get
(
)
)
;
}
}
)
;
fBlobIDCache
.
reset
(
)
;
SkASSERT
(
!
fPool
|
|
fPool
-
>
isEmpty
(
)
)
;
SkASSERT
(
fBlobList
.
isEmpty
(
)
)
;
}
void
GrTextBlobCache
:
:
PostPurgeBlobMessage
(
uint32_t
blobID
uint32_t
cacheID
)
{
SkASSERT
(
blobID
!
=
SK_InvalidGenID
)
;
SkMessageBus
<
PurgeBlobMessage
>
:
:
Post
(
PurgeBlobMessage
(
{
blobID
}
)
cacheID
)
;
}
void
GrTextBlobCache
:
:
purgeStaleBlobs
(
)
{
SkTArray
<
PurgeBlobMessage
>
msgs
;
fPurgeBlobInbox
.
poll
(
&
msgs
)
;
for
(
const
auto
&
msg
:
msgs
)
{
auto
*
idEntry
=
fBlobIDCache
.
find
(
msg
.
fID
)
;
if
(
!
idEntry
)
{
continue
;
}
for
(
const
auto
&
blob
:
idEntry
-
>
fBlobs
)
{
fBlobList
.
remove
(
blob
.
get
(
)
)
;
}
fBlobIDCache
.
remove
(
msg
.
fID
)
;
}
}
bool
GrTextBlobCache
:
:
overBudget
(
)
const
{
if
(
fPool
)
{
return
fPool
-
>
size
(
)
>
fBudget
;
}
return
false
;
}
void
GrTextBlobCache
:
:
checkPurge
(
GrAtlasTextBlob
*
blob
)
{
this
-
>
purgeStaleBlobs
(
)
;
if
(
this
-
>
overBudget
(
)
)
{
BitmapBlobList
:
:
Iter
iter
;
iter
.
init
(
fBlobList
BitmapBlobList
:
:
Iter
:
:
kTail_IterStart
)
;
GrAtlasTextBlob
*
lruBlob
=
nullptr
;
while
(
this
-
>
overBudget
(
)
&
&
(
lruBlob
=
iter
.
get
(
)
)
&
&
lruBlob
!
=
blob
)
{
iter
.
prev
(
)
;
this
-
>
remove
(
lruBlob
)
;
}
if
(
blob
&
&
lruBlob
=
=
blob
)
{
(
*
fCallback
)
(
fData
)
;
}
#
ifdef
SPEW_BUDGET_MESSAGE
if
(
this
-
>
overBudget
(
)
)
{
SkDebugf
(
"
Single
textblob
is
larger
than
our
whole
budget
"
)
;
}
#
endif
}
}
