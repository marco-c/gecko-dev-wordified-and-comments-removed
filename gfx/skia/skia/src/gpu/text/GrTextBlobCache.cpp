#
include
"
src
/
gpu
/
text
/
GrTextBlobCache
.
h
"
DECLARE_SKMESSAGEBUS_MESSAGE
(
GrTextBlobCache
:
:
PurgeBlobMessage
)
static
inline
bool
SkShouldPostMessageToBus
(
const
GrTextBlobCache
:
:
PurgeBlobMessage
&
msg
uint32_t
msgBusUniqueID
)
{
return
msg
.
fContextID
=
=
msgBusUniqueID
;
}
GrTextBlobCache
:
:
~
GrTextBlobCache
(
)
{
this
-
>
freeAll
(
)
;
}
void
GrTextBlobCache
:
:
freeAll
(
)
{
fBlobIDCache
.
foreach
(
[
this
]
(
uint32_t
BlobIDCacheEntry
*
entry
)
{
for
(
const
auto
&
blob
:
entry
-
>
fBlobs
)
{
fBlobList
.
remove
(
blob
.
get
(
)
)
;
}
}
)
;
fBlobIDCache
.
reset
(
)
;
fCurrentSize
=
0
;
SkASSERT
(
fBlobList
.
isEmpty
(
)
)
;
}
void
GrTextBlobCache
:
:
PostPurgeBlobMessage
(
uint32_t
blobID
uint32_t
cacheID
)
{
SkASSERT
(
blobID
!
=
SK_InvalidGenID
)
;
SkMessageBus
<
PurgeBlobMessage
>
:
:
Post
(
PurgeBlobMessage
(
blobID
cacheID
)
)
;
}
void
GrTextBlobCache
:
:
purgeStaleBlobs
(
)
{
SkTArray
<
PurgeBlobMessage
>
msgs
;
fPurgeBlobInbox
.
poll
(
&
msgs
)
;
for
(
const
auto
&
msg
:
msgs
)
{
auto
*
idEntry
=
fBlobIDCache
.
find
(
msg
.
fBlobID
)
;
if
(
!
idEntry
)
{
continue
;
}
for
(
const
auto
&
blob
:
idEntry
-
>
fBlobs
)
{
fCurrentSize
-
=
blob
-
>
size
(
)
;
fBlobList
.
remove
(
blob
.
get
(
)
)
;
}
fBlobIDCache
.
remove
(
msg
.
fBlobID
)
;
}
}
void
GrTextBlobCache
:
:
checkPurge
(
GrTextBlob
*
blob
)
{
this
-
>
purgeStaleBlobs
(
)
;
if
(
fCurrentSize
>
fSizeBudget
)
{
BitmapBlobList
:
:
Iter
iter
;
iter
.
init
(
fBlobList
BitmapBlobList
:
:
Iter
:
:
kTail_IterStart
)
;
GrTextBlob
*
lruBlob
=
nullptr
;
while
(
fCurrentSize
>
fSizeBudget
&
&
(
lruBlob
=
iter
.
get
(
)
)
&
&
lruBlob
!
=
blob
)
{
iter
.
prev
(
)
;
this
-
>
remove
(
lruBlob
)
;
}
if
(
blob
&
&
lruBlob
=
=
blob
)
{
(
*
fCallback
)
(
fData
)
;
}
#
ifdef
SPEW_BUDGET_MESSAGE
if
(
fCurrentSize
>
fSizeBudget
)
{
SkDebugf
(
"
Single
textblob
is
larger
than
our
whole
budget
"
)
;
}
#
endif
}
}
