#
ifndef
GrAtlasGlyphCache_DEFINED
#
define
GrAtlasGlyphCache_DEFINED
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrGlyph
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkMasks
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrGlyphCache
;
class
GrAtlasManager
;
class
GrGpu
;
class
GrTextStrike
:
public
SkNVRefCnt
<
GrTextStrike
>
{
public
:
GrTextStrike
(
const
SkDescriptor
&
fontScalerKey
)
;
~
GrTextStrike
(
)
;
inline
GrGlyph
*
getGlyph
(
const
SkGlyph
&
skGlyph
GrGlyph
:
:
PackedID
packed
SkGlyphCache
*
cache
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
packed
)
;
if
(
!
glyph
)
{
glyph
=
this
-
>
generateGlyph
(
skGlyph
packed
cache
)
;
}
return
glyph
;
}
inline
GrGlyph
*
getGlyph
(
GrGlyph
:
:
PackedID
packed
GrMaskFormat
expectedMaskFormat
SkGlyphCache
*
cache
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
packed
)
;
if
(
!
glyph
)
{
const
SkGlyph
&
skGlyph
=
GrToSkGlyph
(
cache
packed
)
;
glyph
=
this
-
>
generateGlyph
(
skGlyph
packed
cache
)
;
glyph
-
>
fMaskFormat
=
expectedMaskFormat
;
}
return
glyph
;
}
GrDrawOpAtlas
:
:
ErrorCode
addGlyphToAtlas
(
GrResourceProvider
*
GrDeferredUploadTarget
*
GrGlyphCache
*
GrAtlasManager
*
GrGlyph
*
SkGlyphCache
*
GrMaskFormat
expectedMaskFormat
bool
isScaledGlyph
)
;
int
countGlyphs
(
)
const
{
return
fCache
.
count
(
)
;
}
void
removeID
(
GrDrawOpAtlas
:
:
AtlasID
)
;
bool
isAbandoned
(
)
const
{
return
fIsAbandoned
;
}
static
const
SkDescriptor
&
GetKey
(
const
GrTextStrike
&
strike
)
{
return
*
strike
.
fFontScalerKey
.
getDesc
(
)
;
}
static
uint32_t
Hash
(
const
SkDescriptor
&
desc
)
{
return
desc
.
getChecksum
(
)
;
}
private
:
SkTDynamicHash
<
GrGlyph
GrGlyph
:
:
PackedID
>
fCache
;
SkAutoDescriptor
fFontScalerKey
;
SkArenaAlloc
fPool
{
512
}
;
int
fAtlasedGlyphs
;
bool
fIsAbandoned
;
static
const
SkGlyph
&
GrToSkGlyph
(
SkGlyphCache
*
cache
GrGlyph
:
:
PackedID
id
)
{
return
cache
-
>
getGlyphIDMetrics
(
GrGlyph
:
:
UnpackID
(
id
)
GrGlyph
:
:
UnpackFixedX
(
id
)
GrGlyph
:
:
UnpackFixedY
(
id
)
)
;
}
GrGlyph
*
generateGlyph
(
const
SkGlyph
&
GrGlyph
:
:
PackedID
SkGlyphCache
*
)
;
friend
class
GrGlyphCache
;
}
;
class
GrGlyphCache
{
public
:
GrGlyphCache
(
const
GrCaps
*
caps
size_t
maxTextureBytes
)
;
~
GrGlyphCache
(
)
;
void
setStrikeToPreserve
(
GrTextStrike
*
strike
)
{
fPreserveStrike
=
strike
;
}
inline
sk_sp
<
GrTextStrike
>
getStrike
(
const
SkGlyphCache
*
cache
)
{
sk_sp
<
GrTextStrike
>
strike
=
sk_ref_sp
(
fCache
.
find
(
cache
-
>
getDescriptor
(
)
)
)
;
if
(
!
strike
)
{
strike
=
this
-
>
generateStrike
(
cache
)
;
}
return
strike
;
}
const
SkMasks
&
getMasks
(
)
const
{
return
*
f565Masks
;
}
void
freeAll
(
)
;
static
void
HandleEviction
(
GrDrawOpAtlas
:
:
AtlasID
void
*
)
;
private
:
sk_sp
<
GrTextStrike
>
generateStrike
(
const
SkGlyphCache
*
cache
)
{
sk_sp
<
GrTextStrike
>
strike
=
sk_ref_sp
(
new
GrTextStrike
(
cache
-
>
getDescriptor
(
)
)
)
;
fCache
.
add
(
strike
.
get
(
)
)
;
return
strike
;
}
using
StrikeHash
=
SkTDynamicHash
<
GrTextStrike
SkDescriptor
>
;
StrikeHash
fCache
;
GrTextStrike
*
fPreserveStrike
;
std
:
:
unique_ptr
<
const
SkMasks
>
f565Masks
;
}
;
#
endif
