#
include
"
include
/
core
/
SkColorFilter
.
h
"
#
include
"
include
/
gpu
/
GrContext
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
gpu
/
GrBlurUtils
.
h
"
#
include
"
src
/
gpu
/
GrClip
.
h
"
#
include
"
src
/
gpu
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrShape
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrAtlasTextOp
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextBlob
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextTarget
.
h
"
#
include
<
new
>
template
<
size_t
N
>
static
size_t
sk_align
(
size_t
s
)
{
return
(
(
s
+
(
N
-
1
)
)
/
N
)
*
N
;
}
sk_sp
<
GrTextBlob
>
GrTextBlob
:
:
Make
(
int
glyphCount
int
runCount
GrColor
color
GrStrikeCache
*
strikeCache
)
{
size_t
verticesCount
=
glyphCount
*
kVerticesPerGlyph
*
kMaxVASize
;
size_t
blobStart
=
0
;
size_t
vertex
=
sk_align
<
alignof
(
char
)
>
(
blobStart
+
sizeof
(
GrTextBlob
)
*
1
)
;
size_t
glyphs
=
sk_align
<
alignof
(
GrGlyph
*
)
>
(
vertex
+
sizeof
(
char
)
*
verticesCount
)
;
size_t
runs
=
sk_align
<
alignof
(
GrTextBlob
:
:
Run
)
>
(
glyphs
+
sizeof
(
GrGlyph
*
)
*
glyphCount
)
;
size_t
size
=
(
runs
+
sizeof
(
GrTextBlob
:
:
Run
)
*
runCount
)
;
void
*
allocation
=
:
:
operator
new
(
size
)
;
if
(
CACHE_SANITY_CHECK
)
{
sk_bzero
(
allocation
size
)
;
}
sk_sp
<
GrTextBlob
>
blob
{
new
(
allocation
)
GrTextBlob
{
strikeCache
}
}
;
blob
-
>
fSize
=
size
;
blob
-
>
fVertices
=
SkTAddOffset
<
char
>
(
blob
.
get
(
)
vertex
)
;
blob
-
>
fGlyphs
=
SkTAddOffset
<
GrGlyph
*
>
(
blob
.
get
(
)
glyphs
)
;
blob
-
>
fRuns
=
SkTAddOffset
<
GrTextBlob
:
:
Run
>
(
blob
.
get
(
)
runs
)
;
for
(
int
i
=
0
;
i
<
runCount
;
i
+
+
)
{
new
(
&
blob
-
>
fRuns
[
i
]
)
GrTextBlob
:
:
Run
{
blob
.
get
(
)
color
}
;
}
blob
-
>
fRunCountLimit
=
runCount
;
return
blob
;
}
void
GrTextBlob
:
:
Run
:
:
setupFont
(
const
SkStrikeSpec
&
strikeSpec
)
{
if
(
fFallbackStrikeSpec
!
=
nullptr
)
{
*
fFallbackStrikeSpec
=
strikeSpec
;
}
else
{
fStrikeSpec
=
strikeSpec
;
}
}
void
GrTextBlob
:
:
Run
:
:
appendPathGlyph
(
const
SkPath
&
path
SkPoint
position
SkScalar
scale
bool
preTransformed
)
{
fPathGlyphs
.
push_back
(
PathGlyph
(
path
position
.
x
(
)
position
.
y
(
)
scale
preTransformed
)
)
;
}
bool
GrTextBlob
:
:
mustRegenerate
(
const
SkPaint
&
paint
bool
anyRunHasSubpixelPosition
const
SkMaskFilterBase
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
if
(
fKey
.
fCanonicalColor
=
=
SK_ColorTRANSPARENT
&
&
fLuminanceColor
!
=
SkPaintPriv
:
:
ComputeLuminanceColor
(
paint
)
)
{
return
true
;
}
if
(
fInitialViewMatrix
.
hasPerspective
(
)
!
=
viewMatrix
.
hasPerspective
(
)
)
{
return
true
;
}
if
(
fInitialViewMatrix
.
hasPerspective
(
)
&
&
!
fInitialViewMatrix
.
cheapEqualTo
(
viewMatrix
)
)
{
return
true
;
}
if
(
fKey
.
fHasBlur
&
&
(
fBlurRec
.
fSigma
!
=
blurRec
.
fSigma
|
|
fBlurRec
.
fStyle
!
=
blurRec
.
fStyle
)
)
{
return
true
;
}
if
(
fKey
.
fStyle
!
=
SkPaint
:
:
kFill_Style
&
&
(
fStrokeInfo
.
fFrameWidth
!
=
paint
.
getStrokeWidth
(
)
|
|
fStrokeInfo
.
fMiterLimit
!
=
paint
.
getStrokeMiter
(
)
|
|
fStrokeInfo
.
fJoin
!
=
paint
.
getStrokeJoin
(
)
)
)
{
return
true
;
}
if
(
this
-
>
hasBitmap
(
)
&
&
this
-
>
hasDistanceField
(
)
)
{
if
(
fInitialViewMatrix
.
cheapEqualTo
(
viewMatrix
)
&
&
x
=
=
fInitialX
&
&
y
=
=
fInitialY
)
{
return
false
;
}
return
true
;
}
if
(
this
-
>
hasBitmap
(
)
)
{
if
(
fInitialViewMatrix
.
getScaleX
(
)
!
=
viewMatrix
.
getScaleX
(
)
|
|
fInitialViewMatrix
.
getScaleY
(
)
!
=
viewMatrix
.
getScaleY
(
)
|
|
fInitialViewMatrix
.
getSkewX
(
)
!
=
viewMatrix
.
getSkewX
(
)
|
|
fInitialViewMatrix
.
getSkewY
(
)
!
=
viewMatrix
.
getSkewY
(
)
)
{
return
true
;
}
SkScalar
transX
=
viewMatrix
.
getTranslateX
(
)
+
viewMatrix
.
getScaleX
(
)
*
(
x
-
fInitialX
)
+
viewMatrix
.
getSkewX
(
)
*
(
y
-
fInitialY
)
-
fInitialViewMatrix
.
getTranslateX
(
)
;
SkScalar
transY
=
viewMatrix
.
getTranslateY
(
)
+
viewMatrix
.
getSkewY
(
)
*
(
x
-
fInitialX
)
+
viewMatrix
.
getScaleY
(
)
*
(
y
-
fInitialY
)
-
fInitialViewMatrix
.
getTranslateY
(
)
;
if
(
!
SkScalarIsInt
(
transX
)
|
|
!
SkScalarIsInt
(
transY
)
)
{
return
true
;
}
}
else
if
(
this
-
>
hasDistanceField
(
)
)
{
SkScalar
newMaxScale
=
viewMatrix
.
getMaxScale
(
)
;
SkScalar
oldMaxScale
=
fInitialViewMatrix
.
getMaxScale
(
)
;
SkScalar
scaleAdjust
=
newMaxScale
/
oldMaxScale
;
if
(
scaleAdjust
<
fMaxMinScale
|
|
scaleAdjust
>
fMinMaxScale
)
{
return
true
;
}
}
return
false
;
}
inline
std
:
:
unique_ptr
<
GrAtlasTextOp
>
GrTextBlob
:
:
makeOp
(
const
SubRun
&
info
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkIRect
&
clipRect
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrTextTarget
*
target
)
{
GrMaskFormat
format
=
info
.
maskFormat
(
)
;
GrPaint
grPaint
;
target
-
>
makeGrPaint
(
info
.
maskFormat
(
)
paint
viewMatrix
&
grPaint
)
;
std
:
:
unique_ptr
<
GrAtlasTextOp
>
op
;
if
(
info
.
drawAsDistanceFields
(
)
)
{
op
=
GrAtlasTextOp
:
:
MakeDistanceField
(
target
-
>
getContext
(
)
std
:
:
move
(
grPaint
)
glyphCount
distanceAdjustTable
target
-
>
colorInfo
(
)
.
isLinearlyBlended
(
)
SkPaintPriv
:
:
ComputeLuminanceColor
(
paint
)
props
info
.
isAntiAliased
(
)
info
.
hasUseLCDText
(
)
)
;
}
else
{
op
=
GrAtlasTextOp
:
:
MakeBitmap
(
target
-
>
getContext
(
)
std
:
:
move
(
grPaint
)
format
glyphCount
info
.
needsTransform
(
)
)
;
}
GrAtlasTextOp
:
:
Geometry
&
geometry
=
op
-
>
geometry
(
)
;
geometry
.
fViewMatrix
=
viewMatrix
;
geometry
.
fClipRect
=
clipRect
;
geometry
.
fBlob
=
SkRef
(
this
)
;
geometry
.
fRun
=
run
;
geometry
.
fSubRun
=
subRun
;
geometry
.
fColor
=
info
.
maskFormat
(
)
=
=
kARGB_GrMaskFormat
?
SK_PMColor4fWHITE
:
filteredColor
;
geometry
.
fX
=
x
;
geometry
.
fY
=
y
;
op
-
>
init
(
)
;
return
op
;
}
static
void
calculate_translation
(
bool
applyVM
const
SkMatrix
&
newViewMatrix
SkScalar
newX
SkScalar
newY
const
SkMatrix
&
currentViewMatrix
SkScalar
currentX
SkScalar
currentY
SkScalar
*
transX
SkScalar
*
transY
)
{
if
(
applyVM
)
{
*
transX
=
newViewMatrix
.
getTranslateX
(
)
+
newViewMatrix
.
getScaleX
(
)
*
(
newX
-
currentX
)
+
newViewMatrix
.
getSkewX
(
)
*
(
newY
-
currentY
)
-
currentViewMatrix
.
getTranslateX
(
)
;
*
transY
=
newViewMatrix
.
getTranslateY
(
)
+
newViewMatrix
.
getSkewY
(
)
*
(
newX
-
currentX
)
+
newViewMatrix
.
getScaleY
(
)
*
(
newY
-
currentY
)
-
currentViewMatrix
.
getTranslateY
(
)
;
}
else
{
*
transX
=
newX
-
currentX
;
*
transY
=
newY
-
currentY
;
}
}
void
GrTextBlob
:
:
flush
(
GrTextTarget
*
target
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
int
lastRun
=
SkTMin
(
fRunCountLimit
(
1
<
<
16
)
)
-
1
;
for
(
int
runIndex
=
0
;
runIndex
<
=
lastRun
;
runIndex
+
+
)
{
Run
&
run
=
fRuns
[
runIndex
]
;
if
(
run
.
fPathGlyphs
.
count
(
)
)
{
SkPaint
runPaint
{
paint
}
;
runPaint
.
setAntiAlias
(
run
.
fAntiAlias
)
;
for
(
int
i
=
0
;
i
<
run
.
fPathGlyphs
.
count
(
)
;
i
+
+
)
{
GrTextBlob
:
:
Run
:
:
PathGlyph
&
pathGlyph
=
run
.
fPathGlyphs
[
i
]
;
SkMatrix
ctm
;
const
SkPath
*
path
=
&
pathGlyph
.
fPath
;
SkTLazy
<
SkPath
>
tmpPath
;
if
(
!
pathGlyph
.
fPreTransformed
)
{
ctm
=
viewMatrix
;
SkMatrix
pathMatrix
=
SkMatrix
:
:
MakeScale
(
pathGlyph
.
fScale
pathGlyph
.
fScale
)
;
SkVector
originShift
=
SkPoint
{
x
y
}
-
SkPoint
{
fInitialX
fInitialY
}
;
pathMatrix
.
postTranslate
(
originShift
.
x
(
)
+
pathGlyph
.
fX
originShift
.
y
(
)
+
pathGlyph
.
fY
)
;
GrStyle
style
(
runPaint
)
;
bool
scalePath
=
runPaint
.
getShader
(
)
|
|
style
.
applies
(
)
|
|
runPaint
.
getMaskFilter
(
)
;
if
(
!
scalePath
)
{
ctm
.
preConcat
(
pathMatrix
)
;
}
else
{
SkPath
*
sourceOutline
=
tmpPath
.
init
(
)
;
path
-
>
transform
(
pathMatrix
sourceOutline
)
;
sourceOutline
-
>
setIsVolatile
(
true
)
;
path
=
sourceOutline
;
}
}
else
{
SkPoint
originalOrigin
=
{
fInitialX
fInitialY
}
;
fInitialViewMatrix
.
mapPoints
(
&
originalOrigin
1
)
;
SkPoint
newOrigin
=
{
x
y
}
;
viewMatrix
.
mapPoints
(
&
newOrigin
1
)
;
SkPoint
originShift
=
newOrigin
-
originalOrigin
;
ctm
=
SkMatrix
:
:
MakeTrans
(
originShift
.
x
(
)
+
pathGlyph
.
fX
originShift
.
y
(
)
+
pathGlyph
.
fY
)
;
}
GrShape
shape
(
*
path
paint
)
;
target
-
>
drawShape
(
clip
runPaint
ctm
shape
)
;
}
}
if
(
!
run
.
fInitialized
)
{
continue
;
}
int
lastSubRun
=
SkTMin
(
run
.
fSubRunInfo
.
count
(
)
1
<
<
16
)
-
1
;
for
(
int
subRun
=
0
;
subRun
<
=
lastSubRun
;
subRun
+
+
)
{
const
SubRun
&
info
=
run
.
fSubRunInfo
[
subRun
]
;
int
glyphCount
=
info
.
glyphCount
(
)
;
if
(
0
=
=
glyphCount
)
{
continue
;
}
bool
skipClip
=
false
;
bool
submitOp
=
true
;
SkIRect
clipRect
=
SkIRect
:
:
MakeEmpty
(
)
;
SkRect
rtBounds
=
SkRect
:
:
MakeWH
(
target
-
>
width
(
)
target
-
>
height
(
)
)
;
SkRRect
clipRRect
;
GrAA
aa
;
if
(
!
info
.
drawAsDistanceFields
(
)
&
&
!
info
.
needsTransform
(
)
&
&
clip
.
isRRect
(
rtBounds
&
clipRRect
&
aa
)
&
&
clipRRect
.
isRect
(
)
&
&
GrAA
:
:
kNo
=
=
aa
)
{
skipClip
=
true
;
SkRect
subRunBounds
;
this
-
>
computeSubRunBounds
(
&
subRunBounds
runIndex
subRun
viewMatrix
x
y
false
)
;
if
(
!
clipRRect
.
getBounds
(
)
.
contains
(
subRunBounds
)
)
{
if
(
!
clipRRect
.
getBounds
(
)
.
intersects
(
subRunBounds
)
)
{
submitOp
=
false
;
}
else
{
clipRRect
.
getBounds
(
)
.
round
(
&
clipRect
)
;
}
}
}
if
(
submitOp
)
{
auto
op
=
this
-
>
makeOp
(
info
glyphCount
runIndex
subRun
viewMatrix
x
y
clipRect
paint
filteredColor
props
distanceAdjustTable
target
)
;
if
(
op
)
{
if
(
skipClip
)
{
target
-
>
addDrawOp
(
GrNoClip
(
)
std
:
:
move
(
op
)
)
;
}
else
{
target
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
}
}
}
}
std
:
:
unique_ptr
<
GrDrawOp
>
GrTextBlob
:
:
test_makeOp
(
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
const
SkPMColor4f
&
filteredColor
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrTextTarget
*
target
)
{
const
GrTextBlob
:
:
SubRun
&
info
=
fRuns
[
run
]
.
fSubRunInfo
[
subRun
]
;
SkIRect
emptyRect
=
SkIRect
:
:
MakeEmpty
(
)
;
return
this
-
>
makeOp
(
info
glyphCount
run
subRun
viewMatrix
x
y
emptyRect
paint
filteredColor
props
distanceAdjustTable
target
)
;
}
void
GrTextBlob
:
:
AssertEqual
(
const
GrTextBlob
&
l
const
GrTextBlob
&
r
)
{
SkASSERT_RELEASE
(
l
.
fSize
=
=
r
.
fSize
)
;
SkASSERT_RELEASE
(
l
.
fBlurRec
.
fSigma
=
=
r
.
fBlurRec
.
fSigma
)
;
SkASSERT_RELEASE
(
l
.
fBlurRec
.
fStyle
=
=
r
.
fBlurRec
.
fStyle
)
;
SkASSERT_RELEASE
(
l
.
fStrokeInfo
.
fFrameWidth
=
=
r
.
fStrokeInfo
.
fFrameWidth
)
;
SkASSERT_RELEASE
(
l
.
fStrokeInfo
.
fMiterLimit
=
=
r
.
fStrokeInfo
.
fMiterLimit
)
;
SkASSERT_RELEASE
(
l
.
fStrokeInfo
.
fJoin
=
=
r
.
fStrokeInfo
.
fJoin
)
;
SkASSERT_RELEASE
(
l
.
fKey
=
=
r
.
fKey
)
;
SkASSERT_RELEASE
(
l
.
fMaxMinScale
=
=
r
.
fMaxMinScale
)
;
SkASSERT_RELEASE
(
l
.
fMinMaxScale
=
=
r
.
fMinMaxScale
)
;
SkASSERT_RELEASE
(
l
.
fTextType
=
=
r
.
fTextType
)
;
SkASSERT_RELEASE
(
l
.
fRunCountLimit
=
=
r
.
fRunCountLimit
)
;
for
(
int
i
=
0
;
i
<
l
.
fRunCountLimit
;
i
+
+
)
{
const
Run
&
lRun
=
l
.
fRuns
[
i
]
;
const
Run
&
rRun
=
r
.
fRuns
[
i
]
;
SkASSERT_RELEASE
(
lRun
.
fStrikeSpec
.
descriptor
(
)
=
=
rRun
.
fStrikeSpec
.
descriptor
(
)
)
;
SkASSERT_RELEASE
(
lRun
.
fInitialized
=
=
rRun
.
fInitialized
)
;
SkASSERT_RELEASE
(
lRun
.
fSubRunInfo
.
count
(
)
=
=
rRun
.
fSubRunInfo
.
count
(
)
)
;
for
(
int
j
=
0
;
j
<
lRun
.
fSubRunInfo
.
count
(
)
;
j
+
+
)
{
const
SubRun
&
lSubRun
=
lRun
.
fSubRunInfo
[
j
]
;
const
SubRun
&
rSubRun
=
rRun
.
fSubRunInfo
[
j
]
;
if
(
lSubRun
.
strike
(
)
)
{
SkASSERT_RELEASE
(
rSubRun
.
strike
(
)
)
;
SkASSERT_RELEASE
(
GrTextStrike
:
:
GetKey
(
*
lSubRun
.
strike
(
)
)
=
=
GrTextStrike
:
:
GetKey
(
*
rSubRun
.
strike
(
)
)
)
;
}
else
{
SkASSERT_RELEASE
(
!
rSubRun
.
strike
(
)
)
;
}
SkASSERT_RELEASE
(
lSubRun
.
vertexStartIndex
(
)
=
=
rSubRun
.
vertexStartIndex
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
vertexEndIndex
(
)
=
=
rSubRun
.
vertexEndIndex
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
glyphStartIndex
(
)
=
=
rSubRun
.
glyphStartIndex
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
glyphEndIndex
(
)
=
=
rSubRun
.
glyphEndIndex
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
maskFormat
(
)
=
=
rSubRun
.
maskFormat
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
drawAsDistanceFields
(
)
=
=
rSubRun
.
drawAsDistanceFields
(
)
)
;
SkASSERT_RELEASE
(
lSubRun
.
hasUseLCDText
(
)
=
=
rSubRun
.
hasUseLCDText
(
)
)
;
}
SkASSERT_RELEASE
(
lRun
.
fPathGlyphs
.
count
(
)
=
=
rRun
.
fPathGlyphs
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
lRun
.
fPathGlyphs
.
count
(
)
;
i
+
+
)
{
const
Run
:
:
PathGlyph
&
lPathGlyph
=
lRun
.
fPathGlyphs
[
i
]
;
const
Run
:
:
PathGlyph
&
rPathGlyph
=
rRun
.
fPathGlyphs
[
i
]
;
SkASSERT_RELEASE
(
lPathGlyph
.
fPath
=
=
rPathGlyph
.
fPath
)
;
}
}
}
void
GrTextBlob
:
:
SubRun
:
:
computeTranslation
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
SkScalar
*
transX
SkScalar
*
transY
)
{
calculate_translation
(
!
this
-
>
drawAsDistanceFields
(
)
&
&
!
this
-
>
isFallback
(
)
viewMatrix
x
y
fCurrentViewMatrix
fX
fY
transX
transY
)
;
fCurrentViewMatrix
=
viewMatrix
;
fX
=
x
;
fY
=
y
;
}
