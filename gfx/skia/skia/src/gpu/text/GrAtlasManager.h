#
ifndef
GrAtlasManager_DEFINED
#
define
GrAtlasManager_DEFINED
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrDrawOpAtlas
.
h
"
#
include
"
src
/
gpu
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
struct
GrGlyph
;
class
GrTextStrike
;
class
GrAtlasManager
:
public
GrOnFlushCallbackObject
{
public
:
GrAtlasManager
(
GrProxyProvider
*
GrStrikeCache
*
size_t
maxTextureBytes
GrDrawOpAtlas
:
:
AllowMultitexturing
)
;
~
GrAtlasManager
(
)
override
;
GrMaskFormat
resolveMaskFormat
(
GrMaskFormat
format
)
const
{
if
(
kA565_GrMaskFormat
=
=
format
&
&
!
fProxyProvider
-
>
caps
(
)
-
>
getDefaultBackendFormat
(
GrColorType
:
:
kBGR_565
GrRenderable
:
:
kNo
)
.
isValid
(
)
)
{
format
=
kARGB_GrMaskFormat
;
}
return
format
;
}
const
sk_sp
<
GrTextureProxy
>
*
getProxies
(
GrMaskFormat
format
unsigned
int
*
numActiveProxies
)
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
if
(
this
-
>
initAtlas
(
format
)
)
{
*
numActiveProxies
=
this
-
>
getAtlas
(
format
)
-
>
numActivePages
(
)
;
return
this
-
>
getAtlas
(
format
)
-
>
getProxies
(
)
;
}
*
numActiveProxies
=
0
;
return
nullptr
;
}
void
freeAll
(
)
;
bool
hasGlyph
(
GrGlyph
*
glyph
)
;
void
addGlyphToBulkAndSetUseToken
(
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
GrGlyph
*
GrDeferredUploadToken
)
;
void
setUseTokenBulk
(
const
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
&
updater
GrDeferredUploadToken
token
GrMaskFormat
format
)
{
this
-
>
getAtlas
(
format
)
-
>
setLastUseTokenBulk
(
updater
token
)
;
}
GrDrawOpAtlas
:
:
ErrorCode
addToAtlas
(
GrResourceProvider
*
GrStrikeCache
*
GrTextStrike
*
GrDrawOpAtlas
:
:
AtlasID
*
GrDeferredUploadTarget
*
GrMaskFormat
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
uint64_t
atlasGeneration
(
GrMaskFormat
format
)
const
{
return
this
-
>
getAtlas
(
format
)
-
>
atlasGeneration
(
)
;
}
void
preFlush
(
GrOnFlushResourceProvider
*
onFlushRP
const
uint32_t
*
int
)
override
{
for
(
int
i
=
0
;
i
<
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
instantiate
(
onFlushRP
)
;
}
}
}
void
postFlush
(
GrDeferredUploadToken
startTokenForNextFlush
const
uint32_t
*
opsTaskIDs
int
numOpsTaskIDs
)
override
{
for
(
int
i
=
0
;
i
<
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
compact
(
startTokenForNextFlush
)
;
}
}
}
bool
retainOnFreeGpuResources
(
)
override
{
return
true
;
}
#
ifdef
SK_DEBUG
void
dump
(
GrContext
*
context
)
const
;
#
endif
void
setAtlasSizesToMinimum_ForTesting
(
)
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
bool
initAtlas
(
GrMaskFormat
)
;
static
int
MaskFormatToAtlasIndex
(
GrMaskFormat
format
)
{
return
static_cast
<
int
>
(
format
)
;
}
static
GrMaskFormat
AtlasIndexToMaskFormat
(
int
idx
)
{
return
static_cast
<
GrMaskFormat
>
(
idx
)
;
}
GrDrawOpAtlas
*
getAtlas
(
GrMaskFormat
format
)
const
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
int
atlasIndex
=
MaskFormatToAtlasIndex
(
format
)
;
SkASSERT
(
fAtlases
[
atlasIndex
]
)
;
return
fAtlases
[
atlasIndex
]
.
get
(
)
;
}
GrDrawOpAtlas
:
:
AllowMultitexturing
fAllowMultitexturing
;
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
fAtlases
[
kMaskFormatCount
]
;
GrProxyProvider
*
fProxyProvider
;
sk_sp
<
const
GrCaps
>
fCaps
;
GrStrikeCache
*
fGlyphCache
;
GrDrawOpAtlasConfig
fAtlasConfig
;
typedef
GrOnFlushCallbackObject
INHERITED
;
}
;
#
endif
