#
ifndef
GrAtlasManager_DEFINED
#
define
GrAtlasManager_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrOnFlushResourceProvider
.
h
"
#
include
"
GrProxyProvider
.
h
"
struct
GrGlyph
;
class
GrTextStrike
;
class
GrAtlasManager
:
public
GrOnFlushCallbackObject
{
public
:
GrAtlasManager
(
GrProxyProvider
*
GrStrikeCache
*
size_t
maxTextureBytes
GrDrawOpAtlas
:
:
AllowMultitexturing
)
;
~
GrAtlasManager
(
)
override
;
GrMaskFormat
resolveMaskFormat
(
GrMaskFormat
format
)
const
{
if
(
kA565_GrMaskFormat
=
=
format
&
&
!
fProxyProvider
-
>
caps
(
)
-
>
isConfigTexturable
(
kRGB_565_GrPixelConfig
)
)
{
format
=
kARGB_GrMaskFormat
;
}
return
format
;
}
const
sk_sp
<
GrTextureProxy
>
*
getProxies
(
GrMaskFormat
format
unsigned
int
*
numActiveProxies
)
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
if
(
this
-
>
initAtlas
(
format
)
)
{
*
numActiveProxies
=
this
-
>
getAtlas
(
format
)
-
>
numActivePages
(
)
;
return
this
-
>
getAtlas
(
format
)
-
>
getProxies
(
)
;
}
*
numActiveProxies
=
0
;
return
nullptr
;
}
void
freeAll
(
)
;
bool
hasGlyph
(
GrGlyph
*
glyph
)
;
void
addGlyphToBulkAndSetUseToken
(
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
GrGlyph
*
GrDeferredUploadToken
)
;
void
setUseTokenBulk
(
const
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
&
updater
GrDeferredUploadToken
token
GrMaskFormat
format
)
{
this
-
>
getAtlas
(
format
)
-
>
setLastUseTokenBulk
(
updater
token
)
;
}
GrDrawOpAtlas
:
:
ErrorCode
addToAtlas
(
GrResourceProvider
*
GrStrikeCache
*
GrTextStrike
*
GrDrawOpAtlas
:
:
AtlasID
*
GrDeferredUploadTarget
*
GrMaskFormat
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
uint64_t
atlasGeneration
(
GrMaskFormat
format
)
const
{
return
this
-
>
getAtlas
(
format
)
-
>
atlasGeneration
(
)
;
}
void
preFlush
(
GrOnFlushResourceProvider
*
onFlushResourceProvider
const
uint32_t
*
int
SkTArray
<
sk_sp
<
GrRenderTargetContext
>
>
*
)
override
{
for
(
int
i
=
0
;
i
<
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
instantiate
(
onFlushResourceProvider
)
;
}
}
}
void
postFlush
(
GrDeferredUploadToken
startTokenForNextFlush
const
uint32_t
*
opListIDs
int
numOpListIDs
)
override
{
for
(
int
i
=
0
;
i
<
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
compact
(
startTokenForNextFlush
)
;
}
}
}
bool
retainOnFreeGpuResources
(
)
override
{
return
true
;
}
#
ifdef
SK_DEBUG
void
dump
(
GrContext
*
context
)
const
;
#
endif
void
setAtlasSizesToMinimum_ForTesting
(
)
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
bool
initAtlas
(
GrMaskFormat
)
;
static
int
MaskFormatToAtlasIndex
(
GrMaskFormat
format
)
{
static
const
int
sAtlasIndices
[
]
=
{
kA8_GrMaskFormat
kA565_GrMaskFormat
kARGB_GrMaskFormat
}
;
static_assert
(
SK_ARRAY_COUNT
(
sAtlasIndices
)
=
=
kMaskFormatCount
"
array_size_mismatch
"
)
;
SkASSERT
(
sAtlasIndices
[
format
]
<
kMaskFormatCount
)
;
return
sAtlasIndices
[
format
]
;
}
GrDrawOpAtlas
*
getAtlas
(
GrMaskFormat
format
)
const
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
int
atlasIndex
=
MaskFormatToAtlasIndex
(
format
)
;
SkASSERT
(
fAtlases
[
atlasIndex
]
)
;
return
fAtlases
[
atlasIndex
]
.
get
(
)
;
}
GrDrawOpAtlas
:
:
AllowMultitexturing
fAllowMultitexturing
;
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
fAtlases
[
kMaskFormatCount
]
;
GrProxyProvider
*
fProxyProvider
;
sk_sp
<
const
GrCaps
>
fCaps
;
GrStrikeCache
*
fGlyphCache
;
GrDrawOpAtlasConfig
fAtlasConfig
;
typedef
GrOnFlushCallbackObject
INHERITED
;
}
;
#
endif
