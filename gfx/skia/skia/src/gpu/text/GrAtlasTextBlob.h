#
ifndef
GrAtlasTextBlob_DEFINED
#
define
GrAtlasTextBlob_DEFINED
#
include
"
GrAtlasGlyphCache
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrTextUtils
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkPoint3
.
h
"
#
include
"
SkRectPriv
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTInternalLList
.
h
"
struct
GrDistanceFieldAdjustTable
;
class
GrMemoryPool
;
class
SkDrawFilter
;
class
SkTextBlob
;
class
SkTextBlobRunIterator
;
#
define
CACHE_SANITY_CHECK
0
class
GrAtlasTextBlob
:
public
SkNVRefCnt
<
GrAtlasTextBlob
>
{
public
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrAtlasTextBlob
)
;
class
VertexRegenerator
;
static
sk_sp
<
GrAtlasTextBlob
>
Make
(
GrMemoryPool
*
int
glyphCount
int
runCount
)
;
struct
Key
{
Key
(
)
{
sk_bzero
(
this
sizeof
(
Key
)
)
;
}
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkPaint
:
:
Style
fStyle
;
SkPixelGeometry
fPixelGeometry
;
bool
fHasBlur
;
uint32_t
fScalerContextFlags
;
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
0
=
=
memcmp
(
this
&
other
sizeof
(
Key
)
)
;
}
}
;
void
setupKey
(
const
GrAtlasTextBlob
:
:
Key
&
key
const
SkMaskFilterBase
:
:
BlurRec
&
blurRec
const
SkPaint
&
paint
)
{
fKey
=
key
;
if
(
key
.
fHasBlur
)
{
fBlurRec
=
blurRec
;
}
if
(
key
.
fStyle
!
=
SkPaint
:
:
kFill_Style
)
{
fStrokeInfo
.
fFrameWidth
=
paint
.
getStrokeWidth
(
)
;
fStrokeInfo
.
fMiterLimit
=
paint
.
getStrokeMiter
(
)
;
fStrokeInfo
.
fJoin
=
paint
.
getStrokeJoin
(
)
;
}
}
static
const
Key
&
GetKey
(
const
GrAtlasTextBlob
&
blob
)
{
return
blob
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
SkOpts
:
:
hash
(
&
key
sizeof
(
Key
)
)
;
}
void
operator
delete
(
void
*
p
)
{
GrAtlasTextBlob
*
blob
=
reinterpret_cast
<
GrAtlasTextBlob
*
>
(
p
)
;
if
(
blob
-
>
fPool
)
{
blob
-
>
fPool
-
>
release
(
p
)
;
}
else
{
:
:
operator
delete
(
p
)
;
}
}
void
*
operator
new
(
size_t
)
{
SK_ABORT
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
bool
hasDistanceField
(
)
const
{
return
SkToBool
(
fTextType
&
kHasDistanceField_TextType
)
;
}
bool
hasBitmap
(
)
const
{
return
SkToBool
(
fTextType
&
kHasBitmap_TextType
)
;
}
void
setHasDistanceField
(
)
{
fTextType
|
=
kHasDistanceField_TextType
;
}
void
setHasBitmap
(
)
{
fTextType
|
=
kHasBitmap_TextType
;
}
int
runCount
(
)
const
{
return
fRunCount
;
}
void
push_back_run
(
int
currRun
)
{
SkASSERT
(
currRun
<
fRunCount
)
;
if
(
currRun
>
0
)
{
Run
:
:
SubRunInfo
&
newRun
=
fRuns
[
currRun
]
.
fSubRunInfo
.
back
(
)
;
Run
:
:
SubRunInfo
&
lastRun
=
fRuns
[
currRun
-
1
]
.
fSubRunInfo
.
back
(
)
;
newRun
.
setAsSuccessor
(
lastRun
)
;
}
}
void
setSubRunHasDistanceFields
(
int
runIndex
bool
hasLCD
bool
isAntiAlias
bool
hasWCoord
)
{
Run
&
run
=
fRuns
[
runIndex
]
;
Run
:
:
SubRunInfo
&
subRun
=
run
.
fSubRunInfo
.
back
(
)
;
subRun
.
setUseLCDText
(
hasLCD
)
;
subRun
.
setAntiAliased
(
isAntiAlias
)
;
subRun
.
setDrawAsDistanceFields
(
)
;
subRun
.
setHasWCoord
(
hasWCoord
)
;
}
void
setRunPaintFlags
(
int
runIndex
uint16_t
paintFlags
)
{
fRuns
[
runIndex
]
.
fPaintFlags
=
paintFlags
&
Run
:
:
kPaintFlagsMask
;
}
void
setMinAndMaxScale
(
SkScalar
scaledMax
SkScalar
scaledMin
)
{
fMaxMinScale
=
SkMaxScalar
(
scaledMax
fMaxMinScale
)
;
fMinMaxScale
=
SkMinScalar
(
scaledMin
fMinMaxScale
)
;
}
void
initOverride
(
int
runIndex
)
{
Run
&
run
=
fRuns
[
runIndex
]
;
run
.
push_back
(
)
;
run
.
fOverrideDescriptor
.
reset
(
new
SkAutoDescriptor
)
;
}
SkGlyphCache
*
setupCache
(
int
runIndex
const
SkSurfaceProps
&
props
SkScalerContextFlags
scalerContextFlags
const
SkPaint
&
skPaint
const
SkMatrix
*
viewMatrix
)
;
void
appendGlyph
(
int
runIndex
const
SkRect
&
positions
GrColor
color
GrAtlasTextStrike
*
strike
GrGlyph
*
glyph
SkGlyphCache
*
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
preTransformed
)
;
void
appendPathGlyph
(
int
runIndex
const
SkPath
&
path
SkScalar
x
SkScalar
y
SkScalar
scale
bool
preTransformed
)
;
static
size_t
GetVertexStride
(
GrMaskFormat
maskFormat
bool
isDistanceFieldWithWCoord
)
{
switch
(
maskFormat
)
{
case
kA8_GrMaskFormat
:
return
isDistanceFieldWithWCoord
?
kGrayTextDFPerspectiveVASize
:
kGrayTextVASize
;
case
kARGB_GrMaskFormat
:
SkASSERT
(
!
isDistanceFieldWithWCoord
)
;
return
kColorTextVASize
;
default
:
SkASSERT
(
!
isDistanceFieldWithWCoord
)
;
return
kLCDTextVASize
;
}
}
bool
mustRegenerate
(
const
GrTextUtils
:
:
Paint
&
const
SkMaskFilterBase
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
;
void
flush
(
GrAtlasGlyphCache
*
GrTextUtils
:
:
Target
*
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
GrTextUtils
:
:
Paint
&
paint
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
;
void
computeSubRunBounds
(
SkRect
*
outBounds
int
runIndex
int
subRunIndex
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
const
Run
&
run
=
fRuns
[
runIndex
]
;
const
Run
:
:
SubRunInfo
&
subRun
=
run
.
fSubRunInfo
[
subRunIndex
]
;
*
outBounds
=
subRun
.
vertexBounds
(
)
;
if
(
subRun
.
drawAsDistanceFields
(
)
)
{
outBounds
-
>
offset
(
x
-
fInitialX
y
-
fInitialY
)
;
viewMatrix
.
mapRect
(
outBounds
)
;
}
else
{
SkMatrix
boundsMatrix
=
fInitialViewMatrixInverse
;
boundsMatrix
.
postTranslate
(
-
fInitialX
-
fInitialY
)
;
boundsMatrix
.
postTranslate
(
x
y
)
;
boundsMatrix
.
postConcat
(
viewMatrix
)
;
boundsMatrix
.
mapRect
(
outBounds
)
;
outBounds
-
>
roundOut
(
outBounds
)
;
}
}
static
const
size_t
kColorTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextDFPerspectiveVASize
=
sizeof
(
SkPoint3
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kLCDTextVASize
=
kGrayTextVASize
;
static
const
size_t
kMaxVASize
=
kGrayTextDFPerspectiveVASize
;
static
const
int
kVerticesPerGlyph
=
4
;
static
void
AssertEqual
(
const
GrAtlasTextBlob
&
const
GrAtlasTextBlob
&
)
;
void
initReusableBlob
(
SkColor
luminanceColor
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fLuminanceColor
=
luminanceColor
;
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
void
initThrowawayBlob
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
const
Key
&
key
(
)
const
{
return
fKey
;
}
~
GrAtlasTextBlob
(
)
{
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
~
Run
(
)
;
}
}
std
:
:
unique_ptr
<
GrDrawOp
>
test_makeOp
(
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
GrTextUtils
:
:
Paint
&
const
SkSurfaceProps
&
const
GrDistanceFieldAdjustTable
*
GrAtlasGlyphCache
*
GrTextUtils
:
:
Target
*
)
;
private
:
GrAtlasTextBlob
(
)
:
fMaxMinScale
(
-
SK_ScalarMax
)
fMinMaxScale
(
SK_ScalarMax
)
fTextType
(
0
)
{
}
void
setupViewMatrix
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fInitialViewMatrix
=
viewMatrix
;
if
(
!
viewMatrix
.
invert
(
&
fInitialViewMatrixInverse
)
)
{
fInitialViewMatrixInverse
=
SkMatrix
:
:
I
(
)
;
SkDebugf
(
"
Could
not
invert
viewmatrix
\
n
"
)
;
}
fInitialX
=
x
;
fInitialY
=
y
;
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
fSubRunInfo
[
0
]
.
init
(
fInitialViewMatrix
x
y
)
;
}
}
struct
Run
{
Run
(
)
:
fPaintFlags
(
0
)
fInitialized
(
false
)
{
fSubRunInfo
.
push_back
(
)
;
}
struct
SubRunInfo
{
SubRunInfo
(
)
:
fAtlasGeneration
(
GrDrawOpAtlas
:
:
kInvalidAtlasGeneration
)
fVertexStartIndex
(
0
)
fVertexEndIndex
(
0
)
fGlyphStartIndex
(
0
)
fGlyphEndIndex
(
0
)
fColor
(
GrColor_ILLEGAL
)
fMaskFormat
(
kA8_GrMaskFormat
)
fFlags
(
0
)
{
fVertexBounds
=
SkRectPriv
:
:
MakeLargestInverted
(
)
;
}
SubRunInfo
(
const
SubRunInfo
&
that
)
:
fBulkUseToken
(
that
.
fBulkUseToken
)
fStrike
(
SkSafeRef
(
that
.
fStrike
.
get
(
)
)
)
fCurrentViewMatrix
(
that
.
fCurrentViewMatrix
)
fVertexBounds
(
that
.
fVertexBounds
)
fAtlasGeneration
(
that
.
fAtlasGeneration
)
fVertexStartIndex
(
that
.
fVertexStartIndex
)
fVertexEndIndex
(
that
.
fVertexEndIndex
)
fGlyphStartIndex
(
that
.
fGlyphStartIndex
)
fGlyphEndIndex
(
that
.
fGlyphEndIndex
)
fX
(
that
.
fX
)
fY
(
that
.
fY
)
fColor
(
that
.
fColor
)
fMaskFormat
(
that
.
fMaskFormat
)
fFlags
(
that
.
fFlags
)
{
}
void
resetBulkUseToken
(
)
{
fBulkUseToken
.
reset
(
)
;
}
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
bulkUseToken
(
)
{
return
&
fBulkUseToken
;
}
void
setStrike
(
GrAtlasTextStrike
*
strike
)
{
fStrike
.
reset
(
SkRef
(
strike
)
)
;
}
GrAtlasTextStrike
*
strike
(
)
const
{
return
fStrike
.
get
(
)
;
}
void
setAtlasGeneration
(
uint64_t
atlasGeneration
)
{
fAtlasGeneration
=
atlasGeneration
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
size_t
byteCount
(
)
const
{
return
fVertexEndIndex
-
fVertexStartIndex
;
}
size_t
vertexStartIndex
(
)
const
{
return
fVertexStartIndex
;
}
size_t
vertexEndIndex
(
)
const
{
return
fVertexEndIndex
;
}
void
appendVertices
(
size_t
vertexStride
)
{
fVertexEndIndex
+
=
vertexStride
*
kVerticesPerGlyph
;
}
uint32_t
glyphCount
(
)
const
{
return
fGlyphEndIndex
-
fGlyphStartIndex
;
}
uint32_t
glyphStartIndex
(
)
const
{
return
fGlyphStartIndex
;
}
uint32_t
glyphEndIndex
(
)
const
{
return
fGlyphEndIndex
;
}
void
glyphAppended
(
)
{
fGlyphEndIndex
+
+
;
}
void
setColor
(
GrColor
color
)
{
fColor
=
color
;
}
GrColor
color
(
)
const
{
return
fColor
;
}
void
setMaskFormat
(
GrMaskFormat
format
)
{
fMaskFormat
=
format
;
}
GrMaskFormat
maskFormat
(
)
const
{
return
fMaskFormat
;
}
void
setAsSuccessor
(
const
SubRunInfo
&
prev
)
{
fGlyphStartIndex
=
prev
.
glyphEndIndex
(
)
;
fGlyphEndIndex
=
prev
.
glyphEndIndex
(
)
;
fVertexStartIndex
=
prev
.
vertexEndIndex
(
)
;
fVertexEndIndex
=
prev
.
vertexEndIndex
(
)
;
this
-
>
init
(
prev
.
fCurrentViewMatrix
prev
.
fX
prev
.
fY
)
;
}
const
SkRect
&
vertexBounds
(
)
const
{
return
fVertexBounds
;
}
void
joinGlyphBounds
(
const
SkRect
&
glyphBounds
)
{
fVertexBounds
.
joinNonEmptyArg
(
glyphBounds
)
;
}
void
init
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fCurrentViewMatrix
=
viewMatrix
;
fX
=
x
;
fY
=
y
;
}
void
computeTranslation
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
SkScalar
*
transX
SkScalar
*
transY
)
;
void
setDrawAsDistanceFields
(
)
{
fFlags
|
=
kDrawAsSDF_Flag
;
}
bool
drawAsDistanceFields
(
)
const
{
return
SkToBool
(
fFlags
&
kDrawAsSDF_Flag
)
;
}
void
setUseLCDText
(
bool
useLCDText
)
{
fFlags
=
useLCDText
?
fFlags
|
kUseLCDText_Flag
:
fFlags
&
~
kUseLCDText_Flag
;
}
bool
hasUseLCDText
(
)
const
{
return
SkToBool
(
fFlags
&
kUseLCDText_Flag
)
;
}
void
setAntiAliased
(
bool
antiAliased
)
{
fFlags
=
antiAliased
?
fFlags
|
kAntiAliased_Flag
:
fFlags
&
~
kAntiAliased_Flag
;
}
bool
isAntiAliased
(
)
const
{
return
SkToBool
(
fFlags
&
kAntiAliased_Flag
)
;
}
void
setHasWCoord
(
bool
hasW
)
{
fFlags
=
hasW
?
(
fFlags
|
kHasWCoord_Flag
)
:
fFlags
&
~
kHasWCoord_Flag
;
}
bool
hasWCoord
(
)
const
{
return
SkToBool
(
fFlags
&
kHasWCoord_Flag
)
;
}
private
:
enum
Flag
{
kDrawAsSDF_Flag
=
0x1
kUseLCDText_Flag
=
0x2
kAntiAliased_Flag
=
0x4
kHasWCoord_Flag
=
0x8
}
;
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
fBulkUseToken
;
sk_sp
<
GrAtlasTextStrike
>
fStrike
;
SkMatrix
fCurrentViewMatrix
;
SkRect
fVertexBounds
;
uint64_t
fAtlasGeneration
;
size_t
fVertexStartIndex
;
size_t
fVertexEndIndex
;
uint32_t
fGlyphStartIndex
;
uint32_t
fGlyphEndIndex
;
SkScalar
fX
;
SkScalar
fY
;
GrColor
fColor
;
GrMaskFormat
fMaskFormat
;
uint32_t
fFlags
;
}
;
SubRunInfo
&
push_back
(
)
{
SubRunInfo
&
newSubRun
=
fSubRunInfo
.
push_back
(
)
;
const
SubRunInfo
&
prevSubRun
=
fSubRunInfo
.
fromBack
(
1
)
;
newSubRun
.
setAsSuccessor
(
prevSubRun
)
;
return
newSubRun
;
}
static
const
int
kMinSubRuns
=
1
;
sk_sp
<
SkTypeface
>
fTypeface
;
SkSTArray
<
kMinSubRuns
SubRunInfo
>
fSubRunInfo
;
SkAutoDescriptor
fDescriptor
;
sk_sp
<
SkPathEffect
>
fPathEffect
;
sk_sp
<
SkMaskFilter
>
fMaskFilter
;
std
:
:
unique_ptr
<
SkAutoDescriptor
>
fOverrideDescriptor
;
struct
PathGlyph
{
PathGlyph
(
const
SkPath
&
path
SkScalar
x
SkScalar
y
SkScalar
scale
bool
preXformed
)
:
fPath
(
path
)
fX
(
x
)
fY
(
y
)
fScale
(
scale
)
fPreTransformed
(
preXformed
)
{
}
SkPath
fPath
;
SkScalar
fX
;
SkScalar
fY
;
SkScalar
fScale
;
bool
fPreTransformed
;
}
;
SkTArray
<
PathGlyph
>
fPathGlyphs
;
struct
{
unsigned
fPaintFlags
:
16
;
bool
fInitialized
:
1
;
}
;
static
constexpr
auto
kPaintFlagsMask
=
SkPaint
:
:
kAntiAlias_Flag
;
}
;
inline
std
:
:
unique_ptr
<
GrAtlasTextOp
>
makeOp
(
const
Run
:
:
SubRunInfo
&
info
int
glyphCount
uint16_t
run
uint16_t
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkIRect
&
clipRect
const
GrTextUtils
:
:
Paint
&
paint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrAtlasGlyphCache
*
cache
GrTextUtils
:
:
Target
*
)
;
struct
StrokeInfo
{
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPaint
:
:
Join
fJoin
;
}
;
enum
TextType
{
kHasDistanceField_TextType
=
0x1
kHasBitmap_TextType
=
0x2
}
;
char
*
fVertices
;
GrGlyph
*
*
fGlyphs
;
Run
*
fRuns
;
GrMemoryPool
*
fPool
;
SkMaskFilterBase
:
:
BlurRec
fBlurRec
;
StrokeInfo
fStrokeInfo
;
Key
fKey
;
SkMatrix
fInitialViewMatrix
;
SkMatrix
fInitialViewMatrixInverse
;
size_t
fSize
;
SkColor
fLuminanceColor
;
SkScalar
fInitialX
;
SkScalar
fInitialY
;
SkScalar
fMaxMinScale
;
SkScalar
fMinMaxScale
;
int
fRunCount
;
uint8_t
fTextType
;
}
;
class
GrAtlasTextBlob
:
:
VertexRegenerator
{
public
:
VertexRegenerator
(
GrAtlasTextBlob
*
blob
int
runIdx
int
subRunIdx
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
GrColor
color
GrDeferredUploadTarget
*
GrAtlasGlyphCache
*
SkAutoGlyphCache
*
)
;
struct
Result
{
bool
fFinished
=
true
;
int
fGlyphsRegenerated
=
0
;
const
char
*
fFirstVertex
;
}
;
Result
regenerate
(
)
;
private
:
template
<
bool
regenPos
bool
regenCol
bool
regenTexCoords
bool
regenGlyphs
>
Result
doRegen
(
)
;
const
SkMatrix
&
fViewMatrix
;
GrAtlasTextBlob
*
fBlob
;
GrDeferredUploadTarget
*
fUploadTarget
;
GrAtlasGlyphCache
*
fGlyphCache
;
SkAutoGlyphCache
*
fLazyCache
;
Run
*
fRun
;
Run
:
:
SubRunInfo
*
fSubRun
;
GrColor
fColor
;
SkScalar
fTransX
;
SkScalar
fTransY
;
uint32_t
fRegenFlags
=
0
;
int
fCurrGlyph
=
0
;
bool
fBrokenRun
=
false
;
}
;
#
endif
