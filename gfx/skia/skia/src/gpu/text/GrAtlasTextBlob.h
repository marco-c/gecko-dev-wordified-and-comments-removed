#
ifndef
GrAtlasTextBlob_DEFINED
#
define
GrAtlasTextBlob_DEFINED
#
include
"
GrBatchAtlas
.
h
"
#
include
"
GrBatchFontCache
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTInternalLList
.
h
"
struct
GrDistanceFieldAdjustTable
;
class
GrTextContext
;
class
SkDrawFilter
;
class
SkTextBlob
;
class
SkTextBlobRunIterator
;
class
GrAtlasTextBlob
:
public
SkNVRefCnt
<
GrAtlasTextBlob
>
{
public
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrAtlasTextBlob
)
;
struct
Run
{
Run
(
)
:
fInitialized
(
false
)
fDrawAsPaths
(
false
)
{
fVertexBounds
.
setLargestInverted
(
)
;
fSubRunInfo
.
push_back
(
)
;
}
struct
SubRunInfo
{
SubRunInfo
(
)
:
fAtlasGeneration
(
GrBatchAtlas
:
:
kInvalidAtlasGeneration
)
fVertexStartIndex
(
0
)
fVertexEndIndex
(
0
)
fGlyphStartIndex
(
0
)
fGlyphEndIndex
(
0
)
fColor
(
GrColor_ILLEGAL
)
fMaskFormat
(
kA8_GrMaskFormat
)
fDrawAsDistanceFields
(
false
)
fUseLCDText
(
false
)
{
}
SubRunInfo
(
const
SubRunInfo
&
that
)
:
fBulkUseToken
(
that
.
fBulkUseToken
)
fStrike
(
SkSafeRef
(
that
.
fStrike
.
get
(
)
)
)
fAtlasGeneration
(
that
.
fAtlasGeneration
)
fVertexStartIndex
(
that
.
fVertexStartIndex
)
fVertexEndIndex
(
that
.
fVertexEndIndex
)
fGlyphStartIndex
(
that
.
fGlyphStartIndex
)
fGlyphEndIndex
(
that
.
fGlyphEndIndex
)
fColor
(
that
.
fColor
)
fMaskFormat
(
that
.
fMaskFormat
)
fDrawAsDistanceFields
(
that
.
fDrawAsDistanceFields
)
fUseLCDText
(
that
.
fUseLCDText
)
{
}
void
resetBulkUseToken
(
)
{
fBulkUseToken
.
reset
(
)
;
}
GrBatchAtlas
:
:
BulkUseTokenUpdater
*
bulkUseToken
(
)
{
return
&
fBulkUseToken
;
}
void
setStrike
(
GrBatchTextStrike
*
strike
)
{
fStrike
.
reset
(
SkRef
(
strike
)
)
;
}
GrBatchTextStrike
*
strike
(
)
const
{
return
fStrike
.
get
(
)
;
}
void
setAtlasGeneration
(
uint64_t
atlasGeneration
)
{
fAtlasGeneration
=
atlasGeneration
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
size_t
byteCount
(
)
const
{
return
fVertexEndIndex
-
fVertexStartIndex
;
}
size_t
vertexStartIndex
(
)
const
{
return
fVertexStartIndex
;
}
size_t
vertexEndIndex
(
)
const
{
return
fVertexEndIndex
;
}
void
appendVertices
(
size_t
vertexStride
)
{
fVertexEndIndex
+
=
vertexStride
*
kVerticesPerGlyph
;
}
uint32_t
glyphCount
(
)
const
{
return
fGlyphEndIndex
-
fGlyphStartIndex
;
}
uint32_t
glyphStartIndex
(
)
const
{
return
fGlyphStartIndex
;
}
uint32_t
glyphEndIndex
(
)
const
{
return
fGlyphEndIndex
;
}
void
glyphAppended
(
)
{
fGlyphEndIndex
+
+
;
}
void
setColor
(
GrColor
color
)
{
fColor
=
color
;
}
GrColor
color
(
)
const
{
return
fColor
;
}
void
setMaskFormat
(
GrMaskFormat
format
)
{
fMaskFormat
=
format
;
}
GrMaskFormat
maskFormat
(
)
const
{
return
fMaskFormat
;
}
void
setAsSuccessor
(
const
SubRunInfo
&
prev
)
{
fGlyphStartIndex
=
prev
.
glyphEndIndex
(
)
;
fGlyphEndIndex
=
prev
.
glyphEndIndex
(
)
;
fVertexStartIndex
=
prev
.
vertexEndIndex
(
)
;
fVertexEndIndex
=
prev
.
vertexEndIndex
(
)
;
}
void
setUseLCDText
(
bool
useLCDText
)
{
fUseLCDText
=
useLCDText
;
}
bool
hasUseLCDText
(
)
const
{
return
fUseLCDText
;
}
void
setDrawAsDistanceFields
(
)
{
fDrawAsDistanceFields
=
true
;
}
bool
drawAsDistanceFields
(
)
const
{
return
fDrawAsDistanceFields
;
}
private
:
GrBatchAtlas
:
:
BulkUseTokenUpdater
fBulkUseToken
;
SkAutoTUnref
<
GrBatchTextStrike
>
fStrike
;
uint64_t
fAtlasGeneration
;
size_t
fVertexStartIndex
;
size_t
fVertexEndIndex
;
uint32_t
fGlyphStartIndex
;
uint32_t
fGlyphEndIndex
;
GrColor
fColor
;
GrMaskFormat
fMaskFormat
;
bool
fDrawAsDistanceFields
;
bool
fUseLCDText
;
}
;
SubRunInfo
&
push_back
(
)
{
SubRunInfo
&
newSubRun
=
fSubRunInfo
.
push_back
(
)
;
const
SubRunInfo
&
prevSubRun
=
fSubRunInfo
.
fromBack
(
1
)
;
newSubRun
.
setAsSuccessor
(
prevSubRun
)
;
return
newSubRun
;
}
static
const
int
kMinSubRuns
=
1
;
SkAutoTUnref
<
SkTypeface
>
fTypeface
;
SkRect
fVertexBounds
;
SkSTArray
<
kMinSubRuns
SubRunInfo
>
fSubRunInfo
;
SkAutoDescriptor
fDescriptor
;
SkAutoTDelete
<
SkAutoDescriptor
>
fOverrideDescriptor
;
bool
fInitialized
;
bool
fDrawAsPaths
;
}
;
struct
BigGlyph
{
BigGlyph
(
const
SkPath
&
path
SkScalar
vx
SkScalar
vy
SkScalar
scale
bool
applyVM
)
:
fPath
(
path
)
fVx
(
vx
)
fVy
(
vy
)
fScale
(
scale
)
fApplyVM
(
applyVM
)
{
}
SkPath
fPath
;
SkScalar
fVx
;
SkScalar
fVy
;
SkScalar
fScale
;
bool
fApplyVM
;
}
;
struct
Key
{
Key
(
)
{
sk_bzero
(
this
sizeof
(
Key
)
)
;
}
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkPaint
:
:
Style
fStyle
;
SkPixelGeometry
fPixelGeometry
;
bool
fHasBlur
;
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
0
=
=
memcmp
(
this
&
other
sizeof
(
Key
)
)
;
}
}
;
struct
StrokeInfo
{
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPaint
:
:
Join
fJoin
;
}
;
enum
TextType
{
kHasDistanceField_TextType
=
0x1
kHasBitmap_TextType
=
0x2
}
;
unsigned
char
*
fVertices
;
GrGlyph
*
*
fGlyphs
;
Run
*
fRuns
;
GrMemoryPool
*
fPool
;
SkMaskFilter
:
:
BlurRec
fBlurRec
;
StrokeInfo
fStrokeInfo
;
SkTArray
<
BigGlyph
>
fBigGlyphs
;
Key
fKey
;
SkMatrix
fViewMatrix
;
GrColor
fPaintColor
;
SkScalar
fX
;
SkScalar
fY
;
SkScalar
fMaxMinScale
;
SkScalar
fMinMaxScale
;
int
fRunCount
;
uint8_t
fTextType
;
GrAtlasTextBlob
(
)
:
fMaxMinScale
(
-
SK_ScalarMax
)
fMinMaxScale
(
SK_ScalarMax
)
fTextType
(
0
)
{
}
~
GrAtlasTextBlob
(
)
{
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
~
Run
(
)
;
}
}
static
const
Key
&
GetKey
(
const
GrAtlasTextBlob
&
blob
)
{
return
blob
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
SkChecksum
:
:
Murmur3
(
&
key
sizeof
(
Key
)
)
;
}
void
operator
delete
(
void
*
p
)
{
GrAtlasTextBlob
*
blob
=
reinterpret_cast
<
GrAtlasTextBlob
*
>
(
p
)
;
blob
-
>
fPool
-
>
release
(
p
)
;
}
void
*
operator
new
(
size_t
)
{
SkFAIL
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
bool
hasDistanceField
(
)
const
{
return
SkToBool
(
fTextType
&
kHasDistanceField_TextType
)
;
}
bool
hasBitmap
(
)
const
{
return
SkToBool
(
fTextType
&
kHasBitmap_TextType
)
;
}
void
setHasDistanceField
(
)
{
fTextType
|
=
kHasDistanceField_TextType
;
}
void
setHasBitmap
(
)
{
fTextType
|
=
kHasBitmap_TextType
;
}
void
push_back_run
(
int
currRun
)
{
SkASSERT
(
currRun
<
fRunCount
)
;
if
(
currRun
>
0
)
{
Run
:
:
SubRunInfo
&
newRun
=
fRuns
[
currRun
]
.
fSubRunInfo
.
back
(
)
;
Run
:
:
SubRunInfo
&
lastRun
=
fRuns
[
currRun
-
1
]
.
fSubRunInfo
.
back
(
)
;
newRun
.
setAsSuccessor
(
lastRun
)
;
}
}
SkGlyphCache
*
setupCache
(
int
runIndex
const
SkSurfaceProps
&
props
const
SkPaint
&
skPaint
const
SkMatrix
*
viewMatrix
bool
noGamma
)
;
void
appendGlyph
(
int
runIndex
const
SkRect
&
positions
GrColor
color
GrBatchTextStrike
*
strike
GrGlyph
*
glyph
GrFontScaler
*
scaler
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
applyVM
)
;
static
size_t
GetVertexStride
(
GrMaskFormat
maskFormat
)
{
switch
(
maskFormat
)
{
case
kA8_GrMaskFormat
:
return
kGrayTextVASize
;
case
kARGB_GrMaskFormat
:
return
kColorTextVASize
;
default
:
return
kLCDTextVASize
;
}
}
bool
mustRegenerate
(
SkScalar
*
outTransX
SkScalar
*
outTransY
const
SkPaint
&
paint
GrColor
color
const
SkMaskFilter
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
;
void
flushCached
(
GrContext
*
context
GrDrawContext
*
dc
const
SkTextBlob
*
blob
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
SkPaint
&
skPaint
const
GrPaint
&
grPaint
SkDrawFilter
*
drawFilter
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
SkScalar
transX
SkScalar
transY
)
;
void
flushThrowaway
(
GrContext
*
context
GrDrawContext
*
dc
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
SkPaint
&
skPaint
const
GrPaint
&
grPaint
const
GrClip
&
clip
const
SkIRect
&
clipBounds
)
;
static
const
size_t
kColorTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kLCDTextVASize
=
kGrayTextVASize
;
static
const
int
kVerticesPerGlyph
=
4
;
#
ifdef
CACHE_SANITY_CHECK
static
void
AssertEqual
(
const
GrAtlasTextBlob
&
const
GrAtlasTextBlob
&
)
;
size_t
fSize
;
#
endif
GrDrawBatch
*
createBatch
(
const
Run
:
:
SubRunInfo
&
info
int
glyphCount
int
run
int
subRun
GrColor
color
SkScalar
transX
SkScalar
transY
const
SkPaint
&
skPaint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrBatchFontCache
*
cache
)
;
private
:
void
appendLargeGlyph
(
GrGlyph
*
glyph
GrFontScaler
*
scaler
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
applyVM
)
;
inline
void
flushRun
(
GrDrawContext
*
dc
GrPipelineBuilder
*
pipelineBuilder
int
run
GrColor
color
SkScalar
transX
SkScalar
transY
const
SkPaint
&
skPaint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrBatchFontCache
*
cache
)
;
void
flushBigGlyphs
(
GrContext
*
context
GrDrawContext
*
dc
const
GrClip
&
clip
const
SkPaint
&
skPaint
SkScalar
transX
SkScalar
transY
const
SkIRect
&
clipBounds
)
;
void
flushRunAsPaths
(
GrContext
*
context
GrDrawContext
*
dc
const
SkSurfaceProps
&
props
const
SkTextBlobRunIterator
&
it
const
GrClip
&
clip
const
SkPaint
&
skPaint
SkDrawFilter
*
drawFilter
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
;
}
;
#
endif
