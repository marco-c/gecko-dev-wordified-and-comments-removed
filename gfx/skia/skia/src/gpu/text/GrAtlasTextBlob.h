#
ifndef
GrAtlasTextBlob_DEFINED
#
define
GrAtlasTextBlob_DEFINED
#
include
"
GrAtlasGlyphCache
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrTextUtils
.
h
"
#
include
"
SkDescriptor
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkRasterizer
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
SkTInternalLList
.
h
"
class
GrBlobRegenHelper
;
struct
GrDistanceFieldAdjustTable
;
class
GrMemoryPool
;
class
GrLegacyMeshDrawOp
;
class
SkDrawFilter
;
class
SkTextBlob
;
class
SkTextBlobRunIterator
;
#
define
CACHE_SANITY_CHECK
0
class
GrAtlasTextBlob
:
public
SkNVRefCnt
<
GrAtlasTextBlob
>
{
public
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrAtlasTextBlob
)
;
static
sk_sp
<
GrAtlasTextBlob
>
Make
(
GrMemoryPool
*
pool
int
glyphCount
int
runCount
)
;
struct
Key
{
Key
(
)
{
sk_bzero
(
this
sizeof
(
Key
)
)
;
}
uint32_t
fUniqueID
;
SkColor
fCanonicalColor
;
SkPaint
:
:
Style
fStyle
;
SkPixelGeometry
fPixelGeometry
;
bool
fHasBlur
;
uint32_t
fScalerContextFlags
;
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
0
=
=
memcmp
(
this
&
other
sizeof
(
Key
)
)
;
}
}
;
void
setupKey
(
const
GrAtlasTextBlob
:
:
Key
&
key
const
SkMaskFilter
:
:
BlurRec
&
blurRec
const
SkPaint
&
paint
)
{
fKey
=
key
;
if
(
key
.
fHasBlur
)
{
fBlurRec
=
blurRec
;
}
if
(
key
.
fStyle
!
=
SkPaint
:
:
kFill_Style
)
{
fStrokeInfo
.
fFrameWidth
=
paint
.
getStrokeWidth
(
)
;
fStrokeInfo
.
fMiterLimit
=
paint
.
getStrokeMiter
(
)
;
fStrokeInfo
.
fJoin
=
paint
.
getStrokeJoin
(
)
;
}
}
static
const
Key
&
GetKey
(
const
GrAtlasTextBlob
&
blob
)
{
return
blob
.
fKey
;
}
static
uint32_t
Hash
(
const
Key
&
key
)
{
return
SkOpts
:
:
hash
(
&
key
sizeof
(
Key
)
)
;
}
void
operator
delete
(
void
*
p
)
{
GrAtlasTextBlob
*
blob
=
reinterpret_cast
<
GrAtlasTextBlob
*
>
(
p
)
;
blob
-
>
fPool
-
>
release
(
p
)
;
}
void
*
operator
new
(
size_t
)
{
SkFAIL
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
bool
hasDistanceField
(
)
const
{
return
SkToBool
(
fTextType
&
kHasDistanceField_TextType
)
;
}
bool
hasBitmap
(
)
const
{
return
SkToBool
(
fTextType
&
kHasBitmap_TextType
)
;
}
void
setHasDistanceField
(
)
{
fTextType
|
=
kHasDistanceField_TextType
;
}
void
setHasBitmap
(
)
{
fTextType
|
=
kHasBitmap_TextType
;
}
int
runCount
(
)
const
{
return
fRunCount
;
}
void
push_back_run
(
int
currRun
)
{
SkASSERT
(
currRun
<
fRunCount
)
;
if
(
currRun
>
0
)
{
Run
:
:
SubRunInfo
&
newRun
=
fRuns
[
currRun
]
.
fSubRunInfo
.
back
(
)
;
Run
:
:
SubRunInfo
&
lastRun
=
fRuns
[
currRun
-
1
]
.
fSubRunInfo
.
back
(
)
;
newRun
.
setAsSuccessor
(
lastRun
)
;
}
}
void
setSubRunHasDistanceFields
(
int
runIndex
bool
hasLCD
)
{
Run
&
run
=
fRuns
[
runIndex
]
;
Run
:
:
SubRunInfo
&
subRun
=
run
.
fSubRunInfo
.
back
(
)
;
subRun
.
setUseLCDText
(
hasLCD
)
;
subRun
.
setDrawAsDistanceFields
(
)
;
}
void
setRunDrawAsPaths
(
int
runIndex
)
{
fRuns
[
runIndex
]
.
fDrawAsPaths
=
true
;
}
void
setMinAndMaxScale
(
SkScalar
scaledMax
SkScalar
scaledMin
)
{
fMaxMinScale
=
SkMaxScalar
(
scaledMax
fMaxMinScale
)
;
fMinMaxScale
=
SkMinScalar
(
scaledMin
fMinMaxScale
)
;
}
void
initOverride
(
int
runIndex
)
{
Run
&
run
=
fRuns
[
runIndex
]
;
run
.
push_back
(
)
;
run
.
fOverrideDescriptor
.
reset
(
new
SkAutoDescriptor
)
;
}
SkGlyphCache
*
setupCache
(
int
runIndex
const
SkSurfaceProps
&
props
uint32_t
scalerContextFlags
const
SkPaint
&
skPaint
const
SkMatrix
*
viewMatrix
)
;
void
appendGlyph
(
int
runIndex
const
SkRect
&
positions
GrColor
color
GrAtlasTextStrike
*
strike
GrGlyph
*
glyph
SkGlyphCache
*
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
treatAsBMP
)
;
static
size_t
GetVertexStride
(
GrMaskFormat
maskFormat
)
{
switch
(
maskFormat
)
{
case
kA8_GrMaskFormat
:
return
kGrayTextVASize
;
case
kARGB_GrMaskFormat
:
return
kColorTextVASize
;
default
:
return
kLCDTextVASize
;
}
}
bool
mustRegenerate
(
const
GrTextUtils
:
:
Paint
&
const
SkMaskFilter
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
;
void
flushCached
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkTextBlob
*
blob
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
GrTextUtils
:
:
Paint
&
SkDrawFilter
*
drawFilter
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
;
void
flushThrowaway
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
const
GrTextUtils
:
:
Paint
&
paint
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
;
void
computeSubRunBounds
(
SkRect
*
outBounds
int
runIndex
int
subRunIndex
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
const
Run
&
run
=
fRuns
[
runIndex
]
;
const
Run
:
:
SubRunInfo
&
subRun
=
run
.
fSubRunInfo
[
subRunIndex
]
;
*
outBounds
=
subRun
.
vertexBounds
(
)
;
if
(
subRun
.
drawAsDistanceFields
(
)
)
{
outBounds
-
>
offset
(
x
-
fInitialX
y
-
fInitialY
)
;
viewMatrix
.
mapRect
(
outBounds
)
;
}
else
{
SkMatrix
boundsMatrix
=
fInitialViewMatrixInverse
;
boundsMatrix
.
postTranslate
(
-
fInitialX
-
fInitialY
)
;
boundsMatrix
.
postTranslate
(
x
y
)
;
boundsMatrix
.
postConcat
(
viewMatrix
)
;
boundsMatrix
.
mapRect
(
outBounds
)
;
outBounds
-
>
roundOut
(
outBounds
)
;
}
}
static
const
size_t
kColorTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kGrayTextVASize
=
sizeof
(
SkPoint
)
+
sizeof
(
GrColor
)
+
sizeof
(
SkIPoint16
)
;
static
const
size_t
kLCDTextVASize
=
kGrayTextVASize
;
static
const
size_t
kMaxVASize
=
kGrayTextVASize
;
static
const
int
kVerticesPerGlyph
=
4
;
static
void
AssertEqual
(
const
GrAtlasTextBlob
&
const
GrAtlasTextBlob
&
)
;
void
initReusableBlob
(
SkColor
filteredColor
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fFilteredPaintColor
=
filteredColor
;
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
void
initThrowawayBlob
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
this
-
>
setupViewMatrix
(
viewMatrix
x
y
)
;
}
void
regenInOp
(
GrDrawOp
:
:
Target
*
target
GrAtlasGlyphCache
*
fontCache
GrBlobRegenHelper
*
helper
int
run
int
subRun
SkAutoGlyphCache
*
size_t
vertexStride
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
GrColor
color
void
*
*
vertices
size_t
*
byteCount
int
*
glyphCount
)
;
const
Key
&
key
(
)
const
{
return
fKey
;
}
~
GrAtlasTextBlob
(
)
{
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
~
Run
(
)
;
}
}
std
:
:
unique_ptr
<
GrLegacyMeshDrawOp
>
test_makeOp
(
int
glyphCount
int
run
int
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
GrTextUtils
:
:
Paint
&
paint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrAtlasGlyphCache
*
cache
)
;
private
:
GrAtlasTextBlob
(
)
:
fMaxMinScale
(
-
SK_ScalarMax
)
fMinMaxScale
(
SK_ScalarMax
)
fTextType
(
0
)
{
}
void
appendLargeGlyph
(
GrGlyph
*
glyph
SkGlyphCache
*
cache
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
treatAsBMP
)
;
inline
void
flushRun
(
GrRenderTargetContext
*
rtc
const
GrClip
&
int
run
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
GrTextUtils
:
:
Paint
&
paint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
GrAtlasGlyphCache
*
cache
)
;
void
flushBigGlyphs
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
GrClip
&
clip
const
SkPaint
&
paint
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
SkIRect
&
clipBounds
)
;
void
flushRunAsPaths
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkSurfaceProps
&
props
const
SkTextBlobRunIterator
&
it
const
GrClip
&
clip
const
GrTextUtils
:
:
Paint
&
paint
SkDrawFilter
*
drawFilter
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
;
void
setupViewMatrix
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fInitialViewMatrix
=
viewMatrix
;
if
(
!
viewMatrix
.
invert
(
&
fInitialViewMatrixInverse
)
)
{
fInitialViewMatrixInverse
=
SkMatrix
:
:
I
(
)
;
SkDebugf
(
"
Could
not
invert
viewmatrix
\
n
"
)
;
}
fInitialX
=
x
;
fInitialY
=
y
;
for
(
int
i
=
0
;
i
<
fRunCount
;
i
+
+
)
{
fRuns
[
i
]
.
fSubRunInfo
[
0
]
.
init
(
fInitialViewMatrix
x
y
)
;
}
}
struct
Run
{
Run
(
)
:
fInitialized
(
false
)
fDrawAsPaths
(
false
)
{
fSubRunInfo
.
push_back
(
)
;
}
struct
SubRunInfo
{
SubRunInfo
(
)
:
fAtlasGeneration
(
GrDrawOpAtlas
:
:
kInvalidAtlasGeneration
)
fVertexStartIndex
(
0
)
fVertexEndIndex
(
0
)
fGlyphStartIndex
(
0
)
fGlyphEndIndex
(
0
)
fColor
(
GrColor_ILLEGAL
)
fMaskFormat
(
kA8_GrMaskFormat
)
fDrawAsDistanceFields
(
false
)
fUseLCDText
(
false
)
{
fVertexBounds
.
setLargestInverted
(
)
;
}
SubRunInfo
(
const
SubRunInfo
&
that
)
:
fBulkUseToken
(
that
.
fBulkUseToken
)
fStrike
(
SkSafeRef
(
that
.
fStrike
.
get
(
)
)
)
fCurrentViewMatrix
(
that
.
fCurrentViewMatrix
)
fVertexBounds
(
that
.
fVertexBounds
)
fAtlasGeneration
(
that
.
fAtlasGeneration
)
fVertexStartIndex
(
that
.
fVertexStartIndex
)
fVertexEndIndex
(
that
.
fVertexEndIndex
)
fGlyphStartIndex
(
that
.
fGlyphStartIndex
)
fGlyphEndIndex
(
that
.
fGlyphEndIndex
)
fX
(
that
.
fX
)
fY
(
that
.
fY
)
fColor
(
that
.
fColor
)
fMaskFormat
(
that
.
fMaskFormat
)
fDrawAsDistanceFields
(
that
.
fDrawAsDistanceFields
)
fUseLCDText
(
that
.
fUseLCDText
)
{
}
void
resetBulkUseToken
(
)
{
fBulkUseToken
.
reset
(
)
;
}
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
bulkUseToken
(
)
{
return
&
fBulkUseToken
;
}
void
setStrike
(
GrAtlasTextStrike
*
strike
)
{
fStrike
.
reset
(
SkRef
(
strike
)
)
;
}
GrAtlasTextStrike
*
strike
(
)
const
{
return
fStrike
.
get
(
)
;
}
void
setAtlasGeneration
(
uint64_t
atlasGeneration
)
{
fAtlasGeneration
=
atlasGeneration
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
size_t
byteCount
(
)
const
{
return
fVertexEndIndex
-
fVertexStartIndex
;
}
size_t
vertexStartIndex
(
)
const
{
return
fVertexStartIndex
;
}
size_t
vertexEndIndex
(
)
const
{
return
fVertexEndIndex
;
}
void
appendVertices
(
size_t
vertexStride
)
{
fVertexEndIndex
+
=
vertexStride
*
kVerticesPerGlyph
;
}
uint32_t
glyphCount
(
)
const
{
return
fGlyphEndIndex
-
fGlyphStartIndex
;
}
uint32_t
glyphStartIndex
(
)
const
{
return
fGlyphStartIndex
;
}
uint32_t
glyphEndIndex
(
)
const
{
return
fGlyphEndIndex
;
}
void
glyphAppended
(
)
{
fGlyphEndIndex
+
+
;
}
void
setColor
(
GrColor
color
)
{
fColor
=
color
;
}
GrColor
color
(
)
const
{
return
fColor
;
}
void
setMaskFormat
(
GrMaskFormat
format
)
{
fMaskFormat
=
format
;
}
GrMaskFormat
maskFormat
(
)
const
{
return
fMaskFormat
;
}
void
setAsSuccessor
(
const
SubRunInfo
&
prev
)
{
fGlyphStartIndex
=
prev
.
glyphEndIndex
(
)
;
fGlyphEndIndex
=
prev
.
glyphEndIndex
(
)
;
fVertexStartIndex
=
prev
.
vertexEndIndex
(
)
;
fVertexEndIndex
=
prev
.
vertexEndIndex
(
)
;
this
-
>
init
(
prev
.
fCurrentViewMatrix
prev
.
fX
prev
.
fY
)
;
}
const
SkRect
&
vertexBounds
(
)
const
{
return
fVertexBounds
;
}
void
joinGlyphBounds
(
const
SkRect
&
glyphBounds
)
{
fVertexBounds
.
joinNonEmptyArg
(
glyphBounds
)
;
}
void
init
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
fCurrentViewMatrix
=
viewMatrix
;
fX
=
x
;
fY
=
y
;
}
void
computeTranslation
(
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
SkScalar
*
transX
SkScalar
*
transY
)
;
void
setUseLCDText
(
bool
useLCDText
)
{
fUseLCDText
=
useLCDText
;
}
bool
hasUseLCDText
(
)
const
{
return
fUseLCDText
;
}
void
setDrawAsDistanceFields
(
)
{
fDrawAsDistanceFields
=
true
;
}
bool
drawAsDistanceFields
(
)
const
{
return
fDrawAsDistanceFields
;
}
private
:
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
fBulkUseToken
;
sk_sp
<
GrAtlasTextStrike
>
fStrike
;
SkMatrix
fCurrentViewMatrix
;
SkRect
fVertexBounds
;
uint64_t
fAtlasGeneration
;
size_t
fVertexStartIndex
;
size_t
fVertexEndIndex
;
uint32_t
fGlyphStartIndex
;
uint32_t
fGlyphEndIndex
;
SkScalar
fX
;
SkScalar
fY
;
GrColor
fColor
;
GrMaskFormat
fMaskFormat
;
bool
fDrawAsDistanceFields
;
bool
fUseLCDText
;
}
;
SubRunInfo
&
push_back
(
)
{
SubRunInfo
&
newSubRun
=
fSubRunInfo
.
push_back
(
)
;
const
SubRunInfo
&
prevSubRun
=
fSubRunInfo
.
fromBack
(
1
)
;
newSubRun
.
setAsSuccessor
(
prevSubRun
)
;
return
newSubRun
;
}
static
const
int
kMinSubRuns
=
1
;
sk_sp
<
SkTypeface
>
fTypeface
;
SkSTArray
<
kMinSubRuns
SubRunInfo
>
fSubRunInfo
;
SkAutoDescriptor
fDescriptor
;
sk_sp
<
SkPathEffect
>
fPathEffect
;
sk_sp
<
SkRasterizer
>
fRasterizer
;
sk_sp
<
SkMaskFilter
>
fMaskFilter
;
std
:
:
unique_ptr
<
SkAutoDescriptor
>
fOverrideDescriptor
;
bool
fInitialized
;
bool
fDrawAsPaths
;
}
;
template
<
bool
regenPos
bool
regenCol
bool
regenTexCoords
bool
regenGlyphs
>
void
regenInOp
(
GrDrawOp
:
:
Target
*
target
GrAtlasGlyphCache
*
fontCache
GrBlobRegenHelper
*
helper
Run
*
run
Run
:
:
SubRunInfo
*
info
SkAutoGlyphCache
*
int
glyphCount
size_t
vertexStride
GrColor
color
SkScalar
transX
SkScalar
transY
)
const
;
inline
std
:
:
unique_ptr
<
GrLegacyMeshDrawOp
>
makeOp
(
const
Run
:
:
SubRunInfo
&
info
int
glyphCount
int
run
int
subRun
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
const
GrTextUtils
:
:
Paint
&
paint
const
SkSurfaceProps
&
props
const
GrDistanceFieldAdjustTable
*
distanceAdjustTable
bool
useGammaCorrectDistanceTable
GrAtlasGlyphCache
*
cache
)
;
struct
BigGlyph
{
BigGlyph
(
const
SkPath
&
path
SkScalar
vx
SkScalar
vy
SkScalar
scale
bool
treatAsBMP
)
:
fPath
(
path
)
fScale
(
scale
)
fX
(
vx
)
fY
(
vy
)
fTreatAsBMP
(
treatAsBMP
)
{
}
SkPath
fPath
;
SkScalar
fScale
;
SkScalar
fX
;
SkScalar
fY
;
bool
fTreatAsBMP
;
}
;
struct
StrokeInfo
{
SkScalar
fFrameWidth
;
SkScalar
fMiterLimit
;
SkPaint
:
:
Join
fJoin
;
}
;
enum
TextType
{
kHasDistanceField_TextType
=
0x1
kHasBitmap_TextType
=
0x2
}
;
unsigned
char
*
fVertices
;
GrGlyph
*
*
fGlyphs
;
Run
*
fRuns
;
GrMemoryPool
*
fPool
;
SkMaskFilter
:
:
BlurRec
fBlurRec
;
StrokeInfo
fStrokeInfo
;
SkTArray
<
BigGlyph
>
fBigGlyphs
;
Key
fKey
;
SkMatrix
fInitialViewMatrix
;
SkMatrix
fInitialViewMatrixInverse
;
size_t
fSize
;
SkColor
fFilteredPaintColor
;
SkScalar
fInitialX
;
SkScalar
fInitialY
;
SkScalar
fMaxMinScale
;
SkScalar
fMinMaxScale
;
int
fRunCount
;
uint8_t
fTextType
;
}
;
#
endif
