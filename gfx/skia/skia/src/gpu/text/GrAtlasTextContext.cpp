#
include
"
GrAtlasTextContext
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrTextBlobCache
.
h
"
#
include
"
GrTextUtils
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkDrawFilter
.
h
"
#
include
"
SkGrPriv
.
h
"
GrAtlasTextContext
:
:
GrAtlasTextContext
(
)
:
fDistanceAdjustTable
(
new
GrDistanceFieldAdjustTable
)
{
}
GrAtlasTextContext
*
GrAtlasTextContext
:
:
Create
(
)
{
return
new
GrAtlasTextContext
(
)
;
}
bool
GrAtlasTextContext
:
:
canDraw
(
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
GrShaderCaps
&
shaderCaps
)
{
return
GrTextUtils
:
:
CanDrawAsDistanceFields
(
skPaint
viewMatrix
props
shaderCaps
)
|
|
!
SkDraw
:
:
ShouldDrawTextAsPaths
(
skPaint
viewMatrix
)
;
}
GrColor
GrAtlasTextContext
:
:
ComputeCanonicalColor
(
const
SkPaint
&
paint
bool
lcd
)
{
GrColor
canonicalColor
=
paint
.
computeLuminanceColor
(
)
;
if
(
lcd
)
{
SkASSERT
(
false
)
;
}
else
{
U8CPU
lum
=
SkComputeLuminance
(
SkColorGetR
(
canonicalColor
)
SkColorGetG
(
canonicalColor
)
SkColorGetB
(
canonicalColor
)
)
;
canonicalColor
=
SkMaskGamma
:
:
CanonicalColor
(
SkColorSetRGB
(
lum
lum
lum
)
)
;
}
return
canonicalColor
;
}
uint32_t
GrAtlasTextContext
:
:
ComputeScalerContextFlags
(
GrDrawContext
*
dc
)
{
if
(
dc
-
>
isGammaCorrect
(
)
)
{
return
SkPaint
:
:
kBoostContrast_ScalerContextFlag
;
}
else
{
return
SkPaint
:
:
kFakeGammaAndBoostContrast_ScalerContextFlags
;
}
}
bool
GrAtlasTextContext
:
:
HasLCD
(
const
SkTextBlob
*
blob
)
{
SkTextBlobRunIterator
it
(
blob
)
;
for
(
;
!
it
.
done
(
)
;
it
.
next
(
)
)
{
if
(
it
.
isLCD
(
)
)
{
return
true
;
}
}
return
false
;
}
void
GrAtlasTextContext
:
:
drawTextBlob
(
GrContext
*
context
GrDrawContext
*
dc
const
GrClip
&
clip
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
SkDrawFilter
*
drawFilter
const
SkIRect
&
clipBounds
)
{
if
(
context
-
>
abandoned
(
)
)
{
return
;
}
SkAutoTUnref
<
GrAtlasTextBlob
>
cacheBlob
;
SkMaskFilter
:
:
BlurRec
blurRec
;
GrAtlasTextBlob
:
:
Key
key
;
const
SkMaskFilter
*
mf
=
skPaint
.
getMaskFilter
(
)
;
bool
canCache
=
!
(
skPaint
.
getPathEffect
(
)
|
|
(
mf
&
&
!
mf
-
>
asABlur
(
&
blurRec
)
)
|
|
drawFilter
)
;
uint32_t
scalerContextFlags
=
ComputeScalerContextFlags
(
dc
)
;
GrTextBlobCache
*
cache
=
context
-
>
getTextBlobCache
(
)
;
if
(
canCache
)
{
bool
hasLCD
=
HasLCD
(
blob
)
;
SkPixelGeometry
pixelGeometry
=
hasLCD
?
props
.
pixelGeometry
(
)
:
kUnknown_SkPixelGeometry
;
GrColor
canonicalColor
=
hasLCD
?
SK_ColorTRANSPARENT
:
ComputeCanonicalColor
(
skPaint
hasLCD
)
;
key
.
fPixelGeometry
=
pixelGeometry
;
key
.
fUniqueID
=
blob
-
>
uniqueID
(
)
;
key
.
fStyle
=
skPaint
.
getStyle
(
)
;
key
.
fHasBlur
=
SkToBool
(
mf
)
;
key
.
fCanonicalColor
=
canonicalColor
;
key
.
fScalerContextFlags
=
scalerContextFlags
;
cacheBlob
.
reset
(
SkSafeRef
(
cache
-
>
find
(
key
)
)
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
context
dc
skPaint
viewMatrix
&
grPaint
)
)
{
return
;
}
if
(
cacheBlob
)
{
if
(
cacheBlob
-
>
mustRegenerate
(
skPaint
grPaint
.
getColor
(
)
blurRec
viewMatrix
x
y
)
)
{
cache
-
>
remove
(
cacheBlob
)
;
cacheBlob
.
reset
(
SkRef
(
cache
-
>
createCachedBlob
(
blob
key
blurRec
skPaint
)
)
)
;
RegenerateTextBlob
(
cacheBlob
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
skPaint
grPaint
.
getColor
(
)
scalerContextFlags
viewMatrix
props
blob
x
y
drawFilter
)
;
}
else
{
cache
-
>
makeMRU
(
cacheBlob
)
;
if
(
CACHE_SANITY_CHECK
)
{
int
glyphCount
=
0
;
int
runCount
=
0
;
GrTextBlobCache
:
:
BlobGlyphCount
(
&
glyphCount
&
runCount
blob
)
;
SkAutoTUnref
<
GrAtlasTextBlob
>
sanityBlob
(
cache
-
>
createBlob
(
glyphCount
runCount
)
)
;
sanityBlob
-
>
setupKey
(
key
blurRec
skPaint
)
;
RegenerateTextBlob
(
sanityBlob
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
skPaint
grPaint
.
getColor
(
)
scalerContextFlags
viewMatrix
props
blob
x
y
drawFilter
)
;
GrAtlasTextBlob
:
:
AssertEqual
(
*
sanityBlob
*
cacheBlob
)
;
}
}
}
else
{
if
(
canCache
)
{
cacheBlob
.
reset
(
SkRef
(
cache
-
>
createCachedBlob
(
blob
key
blurRec
skPaint
)
)
)
;
}
else
{
cacheBlob
.
reset
(
cache
-
>
createBlob
(
blob
)
)
;
}
RegenerateTextBlob
(
cacheBlob
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
skPaint
grPaint
.
getColor
(
)
scalerContextFlags
viewMatrix
props
blob
x
y
drawFilter
)
;
}
cacheBlob
-
>
flushCached
(
context
dc
blob
props
fDistanceAdjustTable
skPaint
grPaint
drawFilter
clip
viewMatrix
clipBounds
x
y
)
;
}
void
GrAtlasTextContext
:
:
RegenerateTextBlob
(
GrAtlasTextBlob
*
cacheBlob
GrBatchFontCache
*
fontCache
const
GrShaderCaps
&
shaderCaps
const
SkPaint
&
skPaint
GrColor
color
uint32_t
scalerContextFlags
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
SkDrawFilter
*
drawFilter
)
{
cacheBlob
-
>
initReusableBlob
(
color
viewMatrix
x
y
)
;
SkPaint
runPaint
=
skPaint
;
SkTextBlobRunIterator
it
(
blob
)
;
for
(
int
run
=
0
;
!
it
.
done
(
)
;
it
.
next
(
)
run
+
+
)
{
int
glyphCount
=
it
.
glyphCount
(
)
;
size_t
textLen
=
glyphCount
*
sizeof
(
uint16_t
)
;
const
SkPoint
&
offset
=
it
.
offset
(
)
;
it
.
applyFontToPaint
(
&
runPaint
)
;
if
(
drawFilter
&
&
!
drawFilter
-
>
filter
(
&
runPaint
SkDrawFilter
:
:
kText_Type
)
)
{
runPaint
=
skPaint
;
continue
;
}
runPaint
.
setFlags
(
GrTextUtils
:
:
FilterTextFlags
(
props
runPaint
)
)
;
cacheBlob
-
>
push_back_run
(
run
)
;
if
(
GrTextUtils
:
:
CanDrawAsDistanceFields
(
runPaint
viewMatrix
props
shaderCaps
)
)
{
switch
(
it
.
positioning
(
)
)
{
case
SkTextBlob
:
:
kDefault_Positioning
:
{
GrTextUtils
:
:
DrawDFText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
x
+
offset
.
x
(
)
y
+
offset
.
y
(
)
)
;
break
;
}
case
SkTextBlob
:
:
kHorizontal_Positioning
:
{
SkPoint
dfOffset
=
SkPoint
:
:
Make
(
x
y
+
offset
.
y
(
)
)
;
GrTextUtils
:
:
DrawDFPosText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
1
dfOffset
)
;
break
;
}
case
SkTextBlob
:
:
kFull_Positioning
:
{
SkPoint
dfOffset
=
SkPoint
:
:
Make
(
x
y
)
;
GrTextUtils
:
:
DrawDFPosText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
2
dfOffset
)
;
break
;
}
}
}
else
if
(
SkDraw
:
:
ShouldDrawTextAsPaths
(
runPaint
viewMatrix
)
)
{
cacheBlob
-
>
setRunDrawAsPaths
(
run
)
;
}
else
{
switch
(
it
.
positioning
(
)
)
{
case
SkTextBlob
:
:
kDefault_Positioning
:
GrTextUtils
:
:
DrawBmpText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
x
+
offset
.
x
(
)
y
+
offset
.
y
(
)
)
;
break
;
case
SkTextBlob
:
:
kHorizontal_Positioning
:
GrTextUtils
:
:
DrawBmpPosText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
1
SkPoint
:
:
Make
(
x
y
+
offset
.
y
(
)
)
)
;
break
;
case
SkTextBlob
:
:
kFull_Positioning
:
GrTextUtils
:
:
DrawBmpPosText
(
cacheBlob
run
fontCache
props
runPaint
color
scalerContextFlags
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
2
SkPoint
:
:
Make
(
x
y
)
)
;
break
;
}
}
if
(
drawFilter
)
{
runPaint
=
skPaint
;
}
}
}
inline
GrAtlasTextBlob
*
GrAtlasTextContext
:
:
CreateDrawTextBlob
(
GrTextBlobCache
*
blobCache
GrBatchFontCache
*
fontCache
const
GrShaderCaps
&
shaderCaps
const
GrPaint
&
paint
const
SkPaint
&
skPaint
uint32_t
scalerContextFlags
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
)
{
int
glyphCount
=
skPaint
.
countText
(
text
byteLength
)
;
GrAtlasTextBlob
*
blob
=
blobCache
-
>
createBlob
(
glyphCount
1
)
;
blob
-
>
initThrowawayBlob
(
viewMatrix
x
y
)
;
if
(
GrTextUtils
:
:
CanDrawAsDistanceFields
(
skPaint
viewMatrix
props
shaderCaps
)
)
{
GrTextUtils
:
:
DrawDFText
(
blob
0
fontCache
props
skPaint
paint
.
getColor
(
)
scalerContextFlags
viewMatrix
text
byteLength
x
y
)
;
}
else
{
GrTextUtils
:
:
DrawBmpText
(
blob
0
fontCache
props
skPaint
paint
.
getColor
(
)
scalerContextFlags
viewMatrix
text
byteLength
x
y
)
;
}
return
blob
;
}
inline
GrAtlasTextBlob
*
GrAtlasTextContext
:
:
CreateDrawPosTextBlob
(
GrTextBlobCache
*
blobCache
GrBatchFontCache
*
fontCache
const
GrShaderCaps
&
shaderCaps
const
GrPaint
&
paint
const
SkPaint
&
skPaint
uint32_t
scalerContextFlags
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
)
{
int
glyphCount
=
skPaint
.
countText
(
text
byteLength
)
;
GrAtlasTextBlob
*
blob
=
blobCache
-
>
createBlob
(
glyphCount
1
)
;
blob
-
>
initThrowawayBlob
(
viewMatrix
offset
.
x
(
)
offset
.
y
(
)
)
;
if
(
GrTextUtils
:
:
CanDrawAsDistanceFields
(
skPaint
viewMatrix
props
shaderCaps
)
)
{
GrTextUtils
:
:
DrawDFPosText
(
blob
0
fontCache
props
skPaint
paint
.
getColor
(
)
scalerContextFlags
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
)
;
}
else
{
GrTextUtils
:
:
DrawBmpPosText
(
blob
0
fontCache
props
skPaint
paint
.
getColor
(
)
scalerContextFlags
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
)
;
}
return
blob
;
}
void
GrAtlasTextContext
:
:
drawText
(
GrContext
*
context
GrDrawContext
*
dc
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
const
SkIRect
&
regionClipBounds
)
{
if
(
context
-
>
abandoned
(
)
)
{
return
;
}
else
if
(
this
-
>
canDraw
(
skPaint
viewMatrix
props
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
)
)
{
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
CreateDrawTextBlob
(
context
-
>
getTextBlobCache
(
)
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
paint
skPaint
ComputeScalerContextFlags
(
dc
)
viewMatrix
props
text
byteLength
x
y
)
)
;
blob
-
>
flushThrowaway
(
context
dc
props
fDistanceAdjustTable
skPaint
paint
clip
viewMatrix
regionClipBounds
x
y
)
;
return
;
}
GrTextUtils
:
:
DrawTextAsPath
(
context
dc
clip
skPaint
viewMatrix
text
byteLength
x
y
regionClipBounds
)
;
}
void
GrAtlasTextContext
:
:
drawPosText
(
GrContext
*
context
GrDrawContext
*
dc
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkSurfaceProps
&
props
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
const
SkIRect
&
regionClipBounds
)
{
if
(
context
-
>
abandoned
(
)
)
{
return
;
}
else
if
(
this
-
>
canDraw
(
skPaint
viewMatrix
props
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
)
)
{
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
CreateDrawPosTextBlob
(
context
-
>
getTextBlobCache
(
)
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
paint
skPaint
ComputeScalerContextFlags
(
dc
)
viewMatrix
props
text
byteLength
pos
scalarsPerPosition
offset
)
)
;
blob
-
>
flushThrowaway
(
context
dc
props
fDistanceAdjustTable
skPaint
paint
clip
viewMatrix
regionClipBounds
offset
.
fX
offset
.
fY
)
;
return
;
}
GrTextUtils
:
:
DrawPosTextAsPath
(
context
dc
props
clip
skPaint
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
regionClipBounds
)
;
}
#
ifdef
GR_TEST_UTILS
DRAW_BATCH_TEST_DEFINE
(
TextBlobBatch
)
{
static
uint32_t
gContextID
=
SK_InvalidGenID
;
static
GrAtlasTextContext
*
gTextContext
=
nullptr
;
static
SkSurfaceProps
gSurfaceProps
(
SkSurfaceProps
:
:
kLegacyFontHost_InitType
)
;
if
(
context
-
>
uniqueID
(
)
!
=
gContextID
)
{
gContextID
=
context
-
>
uniqueID
(
)
;
delete
gTextContext
;
gTextContext
=
GrAtlasTextContext
:
:
Create
(
)
;
}
sk_sp
<
GrDrawContext
>
drawContext
(
context
-
>
makeDrawContext
(
SkBackingFit
:
:
kApprox
1024
1024
kSkia8888_GrPixelConfig
nullptr
)
)
;
GrColor
color
=
GrRandomColor
(
random
)
;
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrixInvertible
(
random
)
;
SkPaint
skPaint
;
skPaint
.
setColor
(
color
)
;
skPaint
.
setLCDRenderText
(
random
-
>
nextBool
(
)
)
;
skPaint
.
setAntiAlias
(
skPaint
.
isLCDRenderText
(
)
?
true
:
random
-
>
nextBool
(
)
)
;
skPaint
.
setSubpixelText
(
random
-
>
nextBool
(
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
context
drawContext
.
get
(
)
skPaint
viewMatrix
&
grPaint
)
)
{
SkFAIL
(
"
couldn
'
t
convert
paint
\
n
"
)
;
}
const
char
*
text
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
.
"
;
int
textLen
=
(
int
)
strlen
(
text
)
;
static
const
int
kMaxTrans
=
1024
;
int
xPos
=
(
random
-
>
nextU
(
)
%
2
)
*
2
-
1
;
int
yPos
=
(
random
-
>
nextU
(
)
%
2
)
*
2
-
1
;
int
xInt
=
(
random
-
>
nextU
(
)
%
kMaxTrans
)
*
xPos
;
int
yInt
=
(
random
-
>
nextU
(
)
%
kMaxTrans
)
*
yPos
;
SkScalar
x
=
SkIntToScalar
(
xInt
)
;
SkScalar
y
=
SkIntToScalar
(
yInt
)
;
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
GrAtlasTextContext
:
:
CreateDrawTextBlob
(
context
-
>
getTextBlobCache
(
)
context
-
>
getBatchFontCache
(
)
*
context
-
>
caps
(
)
-
>
shaderCaps
(
)
grPaint
skPaint
GrAtlasTextContext
:
:
kTextBlobBatchScalerContextFlags
viewMatrix
gSurfaceProps
text
static_cast
<
size_t
>
(
textLen
)
x
y
)
)
;
return
blob
-
>
test_createBatch
(
textLen
0
0
viewMatrix
x
y
color
skPaint
gSurfaceProps
gTextContext
-
>
dfAdjustTable
(
)
context
-
>
getBatchFontCache
(
)
)
;
}
#
endif
