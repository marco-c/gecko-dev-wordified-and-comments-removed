#
ifndef
GrStrikeCache_DEFINED
#
define
GrStrikeCache_DEFINED
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrGlyph
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkMasks
.
h
"
#
include
"
SkStrike
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrAtlasManager
;
class
GrGpu
;
class
GrStrikeCache
;
class
GrTextStrike
:
public
SkNVRefCnt
<
GrTextStrike
>
{
public
:
GrTextStrike
(
const
SkDescriptor
&
fontScalerKey
)
;
GrGlyph
*
getGlyph
(
const
SkGlyph
&
skGlyph
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
skGlyph
.
getPackedID
(
)
)
;
if
(
!
glyph
)
{
glyph
=
this
-
>
generateGlyph
(
skGlyph
)
;
}
return
glyph
;
}
GrGlyph
*
getGlyph
(
SkPackedGlyphID
packed
SkStrike
*
cache
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
packed
)
;
if
(
!
glyph
)
{
const
SkGlyph
&
skGlyph
=
GrToSkGlyph
(
cache
packed
)
;
glyph
=
this
-
>
generateGlyph
(
skGlyph
)
;
}
return
glyph
;
}
GrDrawOpAtlas
:
:
ErrorCode
addGlyphToAtlas
(
GrResourceProvider
*
GrDeferredUploadTarget
*
GrStrikeCache
*
GrAtlasManager
*
GrGlyph
*
SkStrike
*
GrMaskFormat
expectedMaskFormat
bool
isScaledGlyph
)
;
int
countGlyphs
(
)
const
{
return
fCache
.
count
(
)
;
}
void
removeID
(
GrDrawOpAtlas
:
:
AtlasID
)
;
bool
isAbandoned
(
)
const
{
return
fIsAbandoned
;
}
static
const
SkDescriptor
&
GetKey
(
const
GrTextStrike
&
strike
)
{
return
*
strike
.
fFontScalerKey
.
getDesc
(
)
;
}
static
uint32_t
Hash
(
const
SkDescriptor
&
desc
)
{
return
desc
.
getChecksum
(
)
;
}
private
:
SkTDynamicHash
<
GrGlyph
SkPackedGlyphID
>
fCache
;
SkAutoDescriptor
fFontScalerKey
;
SkArenaAlloc
fAlloc
{
512
}
;
int
fAtlasedGlyphs
{
0
}
;
bool
fIsAbandoned
{
false
}
;
static
const
SkGlyph
&
GrToSkGlyph
(
SkStrike
*
cache
SkPackedGlyphID
id
)
{
return
cache
-
>
getGlyphIDMetrics
(
id
.
code
(
)
id
.
getSubXFixed
(
)
id
.
getSubYFixed
(
)
)
;
}
GrGlyph
*
generateGlyph
(
const
SkGlyph
&
)
;
friend
class
GrStrikeCache
;
}
;
class
GrStrikeCache
{
public
:
GrStrikeCache
(
const
GrCaps
*
caps
size_t
maxTextureBytes
)
;
~
GrStrikeCache
(
)
;
void
setStrikeToPreserve
(
GrTextStrike
*
strike
)
{
fPreserveStrike
=
strike
;
}
sk_sp
<
GrTextStrike
>
getStrike
(
const
SkDescriptor
&
desc
)
{
sk_sp
<
GrTextStrike
>
strike
=
sk_ref_sp
(
fCache
.
find
(
desc
)
)
;
if
(
!
strike
)
{
strike
=
this
-
>
generateStrike
(
desc
)
;
}
return
strike
;
}
const
SkMasks
&
getMasks
(
)
const
{
return
*
f565Masks
;
}
void
freeAll
(
)
;
static
void
HandleEviction
(
GrDrawOpAtlas
:
:
AtlasID
void
*
)
;
private
:
sk_sp
<
GrTextStrike
>
generateStrike
(
const
SkDescriptor
&
desc
)
{
sk_sp
<
GrTextStrike
>
strike
=
sk_ref_sp
(
new
GrTextStrike
(
desc
)
)
;
fCache
.
add
(
strike
.
get
(
)
)
;
return
strike
;
}
using
StrikeHash
=
SkTDynamicHash
<
GrTextStrike
SkDescriptor
>
;
StrikeHash
fCache
;
GrTextStrike
*
fPreserveStrike
;
std
:
:
unique_ptr
<
const
SkMasks
>
f565Masks
;
}
;
#
endif
