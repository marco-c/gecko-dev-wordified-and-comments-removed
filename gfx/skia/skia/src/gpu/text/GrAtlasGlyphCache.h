#
ifndef
GrAtlasGlyphCache_DEFINED
#
define
GrAtlasGlyphCache_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrGlyph
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkTDynamicHash
.
h
"
#
include
"
SkVarAlloc
.
h
"
class
GrAtlasGlyphCache
;
class
GrGpu
;
class
GrAtlasTextStrike
:
public
SkNVRefCnt
<
GrAtlasTextStrike
>
{
public
:
GrAtlasTextStrike
(
GrAtlasGlyphCache
*
owner
const
SkDescriptor
&
fontScalerKey
)
;
~
GrAtlasTextStrike
(
)
;
inline
GrGlyph
*
getGlyph
(
const
SkGlyph
&
skGlyph
GrGlyph
:
:
PackedID
packed
SkGlyphCache
*
cache
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
packed
)
;
if
(
nullptr
=
=
glyph
)
{
glyph
=
this
-
>
generateGlyph
(
skGlyph
packed
cache
)
;
}
return
glyph
;
}
inline
GrGlyph
*
getGlyph
(
GrGlyph
:
:
PackedID
packed
GrMaskFormat
expectedMaskFormat
SkGlyphCache
*
cache
)
{
GrGlyph
*
glyph
=
fCache
.
find
(
packed
)
;
if
(
nullptr
=
=
glyph
)
{
const
SkGlyph
&
skGlyph
=
GrToSkGlyph
(
cache
packed
)
;
glyph
=
this
-
>
generateGlyph
(
skGlyph
packed
cache
)
;
glyph
-
>
fMaskFormat
=
expectedMaskFormat
;
}
return
glyph
;
}
bool
addGlyphToAtlas
(
GrDrawOp
:
:
Target
*
GrGlyph
*
SkGlyphCache
*
GrMaskFormat
expectedMaskFormat
)
;
int
countGlyphs
(
)
const
{
return
fCache
.
count
(
)
;
}
void
removeID
(
GrDrawOpAtlas
:
:
AtlasID
)
;
bool
isAbandoned
(
)
const
{
return
fIsAbandoned
;
}
static
const
SkDescriptor
&
GetKey
(
const
GrAtlasTextStrike
&
ts
)
{
return
*
ts
.
fFontScalerKey
.
getDesc
(
)
;
}
static
uint32_t
Hash
(
const
SkDescriptor
&
desc
)
{
return
desc
.
getChecksum
(
)
;
}
private
:
SkTDynamicHash
<
GrGlyph
GrGlyph
:
:
PackedID
>
fCache
;
SkAutoDescriptor
fFontScalerKey
;
SkVarAlloc
fPool
;
GrAtlasGlyphCache
*
fAtlasGlyphCache
;
int
fAtlasedGlyphs
;
bool
fIsAbandoned
;
static
const
SkGlyph
&
GrToSkGlyph
(
SkGlyphCache
*
cache
GrGlyph
:
:
PackedID
id
)
{
return
cache
-
>
getGlyphIDMetrics
(
GrGlyph
:
:
UnpackID
(
id
)
GrGlyph
:
:
UnpackFixedX
(
id
)
GrGlyph
:
:
UnpackFixedY
(
id
)
)
;
}
GrGlyph
*
generateGlyph
(
const
SkGlyph
&
GrGlyph
:
:
PackedID
SkGlyphCache
*
)
;
friend
class
GrAtlasGlyphCache
;
}
;
class
GrAtlasGlyphCache
{
public
:
GrAtlasGlyphCache
(
GrContext
*
)
;
~
GrAtlasGlyphCache
(
)
;
inline
GrAtlasTextStrike
*
getStrike
(
const
SkGlyphCache
*
cache
)
{
GrAtlasTextStrike
*
strike
=
fCache
.
find
(
cache
-
>
getDescriptor
(
)
)
;
if
(
nullptr
=
=
strike
)
{
strike
=
this
-
>
generateStrike
(
cache
)
;
}
return
strike
;
}
void
freeAll
(
)
;
sk_sp
<
GrTextureProxy
>
getProxy
(
GrMaskFormat
format
)
{
if
(
this
-
>
initAtlas
(
format
)
)
{
return
this
-
>
getAtlas
(
format
)
-
>
getProxy
(
)
;
}
return
nullptr
;
}
bool
hasGlyph
(
GrGlyph
*
glyph
)
{
SkASSERT
(
glyph
)
;
return
this
-
>
getAtlas
(
glyph
-
>
fMaskFormat
)
-
>
hasID
(
glyph
-
>
fID
)
;
}
void
addGlyphToBulkAndSetUseToken
(
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
*
updater
GrGlyph
*
glyph
GrDrawOpUploadToken
token
)
{
SkASSERT
(
glyph
)
;
updater
-
>
add
(
glyph
-
>
fID
)
;
this
-
>
getAtlas
(
glyph
-
>
fMaskFormat
)
-
>
setLastUseToken
(
glyph
-
>
fID
token
)
;
}
void
setUseTokenBulk
(
const
GrDrawOpAtlas
:
:
BulkUseTokenUpdater
&
updater
GrDrawOpUploadToken
token
GrMaskFormat
format
)
{
this
-
>
getAtlas
(
format
)
-
>
setLastUseTokenBulk
(
updater
token
)
;
}
bool
addToAtlas
(
GrAtlasTextStrike
*
strike
GrDrawOpAtlas
:
:
AtlasID
*
id
GrDrawOp
:
:
Target
*
target
GrMaskFormat
format
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
fPreserveStrike
=
strike
;
return
this
-
>
getAtlas
(
format
)
-
>
addToAtlas
(
id
target
width
height
image
loc
)
;
}
uint64_t
atlasGeneration
(
GrMaskFormat
format
)
const
{
return
this
-
>
getAtlas
(
format
)
-
>
atlasGeneration
(
)
;
}
int
log2Width
(
GrMaskFormat
format
)
{
return
fAtlasConfigs
[
format
]
.
fLog2Width
;
}
int
log2Height
(
GrMaskFormat
format
)
{
return
fAtlasConfigs
[
format
]
.
fLog2Height
;
}
#
ifdef
SK_DEBUG
void
dump
(
)
const
;
#
endif
void
setAtlasSizes_ForTesting
(
const
GrDrawOpAtlasConfig
configs
[
3
]
)
;
GrContext
*
context
(
)
const
{
return
fContext
;
}
private
:
static
GrPixelConfig
MaskFormatToPixelConfig
(
GrMaskFormat
format
const
GrCaps
&
caps
)
{
switch
(
format
)
{
case
kA8_GrMaskFormat
:
return
kAlpha_8_GrPixelConfig
;
case
kA565_GrMaskFormat
:
return
kRGB_565_GrPixelConfig
;
case
kARGB_GrMaskFormat
:
return
caps
.
srgbSupport
(
)
?
kSRGBA_8888_GrPixelConfig
:
kRGBA_8888_GrPixelConfig
;
default
:
SkDEBUGFAIL
(
"
unsupported
GrMaskFormat
"
)
;
return
kAlpha_8_GrPixelConfig
;
}
}
static
int
MaskFormatToAtlasIndex
(
GrMaskFormat
format
)
{
static
const
int
sAtlasIndices
[
]
=
{
kA8_GrMaskFormat
kA565_GrMaskFormat
kARGB_GrMaskFormat
}
;
static_assert
(
SK_ARRAY_COUNT
(
sAtlasIndices
)
=
=
kMaskFormatCount
"
array_size_mismatch
"
)
;
SkASSERT
(
sAtlasIndices
[
format
]
<
kMaskFormatCount
)
;
return
sAtlasIndices
[
format
]
;
}
bool
initAtlas
(
GrMaskFormat
)
;
GrAtlasTextStrike
*
generateStrike
(
const
SkGlyphCache
*
cache
)
{
GrAtlasTextStrike
*
strike
=
new
GrAtlasTextStrike
(
this
cache
-
>
getDescriptor
(
)
)
;
fCache
.
add
(
strike
)
;
return
strike
;
}
GrDrawOpAtlas
*
getAtlas
(
GrMaskFormat
format
)
const
{
int
atlasIndex
=
MaskFormatToAtlasIndex
(
format
)
;
SkASSERT
(
fAtlases
[
atlasIndex
]
)
;
return
fAtlases
[
atlasIndex
]
.
get
(
)
;
}
static
void
HandleEviction
(
GrDrawOpAtlas
:
:
AtlasID
void
*
)
;
using
StrikeHash
=
SkTDynamicHash
<
GrAtlasTextStrike
SkDescriptor
>
;
GrContext
*
fContext
;
StrikeHash
fCache
;
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
fAtlases
[
kMaskFormatCount
]
;
GrAtlasTextStrike
*
fPreserveStrike
;
GrDrawOpAtlasConfig
fAtlasConfigs
[
kMaskFormatCount
]
;
}
;
#
endif
