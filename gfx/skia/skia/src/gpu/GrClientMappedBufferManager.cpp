#
include
"
src
/
gpu
/
GrClientMappedBufferManager
.
h
"
#
include
<
algorithm
>
GrClientMappedBufferManager
:
:
GrClientMappedBufferManager
(
uint32_t
contextID
)
:
fFinishedBufferInbox
(
contextID
)
{
}
GrClientMappedBufferManager
:
:
~
GrClientMappedBufferManager
(
)
{
this
-
>
process
(
)
;
if
(
!
fAbandoned
)
{
for
(
auto
&
b
:
fClientHeldBuffers
)
{
b
-
>
unmap
(
)
;
}
}
}
void
GrClientMappedBufferManager
:
:
insert
(
sk_sp
<
GrGpuBuffer
>
b
)
{
SkDEBUGCODE
(
auto
end
=
fClientHeldBuffers
.
end
(
)
)
;
SkASSERT
(
std
:
:
find
(
fClientHeldBuffers
.
begin
(
)
end
b
)
=
=
end
)
;
fClientHeldBuffers
.
emplace_front
(
std
:
:
move
(
b
)
)
;
}
void
GrClientMappedBufferManager
:
:
process
(
)
{
SkSTArray
<
4
BufferFinishedMessage
>
messages
;
fFinishedBufferInbox
.
poll
(
&
messages
)
;
if
(
!
fAbandoned
)
{
for
(
auto
&
m
:
messages
)
{
this
-
>
remove
(
m
.
fBuffer
)
;
m
.
fBuffer
-
>
unmap
(
)
;
}
}
}
void
GrClientMappedBufferManager
:
:
abandon
(
)
{
fAbandoned
=
true
;
fClientHeldBuffers
.
clear
(
)
;
}
void
GrClientMappedBufferManager
:
:
remove
(
const
sk_sp
<
GrGpuBuffer
>
&
b
)
{
auto
prev
=
fClientHeldBuffers
.
before_begin
(
)
;
auto
end
=
fClientHeldBuffers
.
end
(
)
;
SkASSERT
(
std
:
:
find
(
fClientHeldBuffers
.
begin
(
)
end
b
)
!
=
end
)
;
for
(
auto
cur
=
fClientHeldBuffers
.
begin
(
)
;
cur
!
=
end
;
prev
=
cur
+
+
)
{
if
(
*
cur
=
=
b
)
{
fClientHeldBuffers
.
erase_after
(
prev
)
;
break
;
}
}
SkASSERT
(
std
:
:
find
(
fClientHeldBuffers
.
begin
(
)
end
b
)
=
=
end
)
;
}
DECLARE_SKMESSAGEBUS_MESSAGE
(
GrClientMappedBufferManager
:
:
BufferFinishedMessage
)
bool
SkShouldPostMessageToBus
(
const
GrClientMappedBufferManager
:
:
BufferFinishedMessage
&
m
uint32_t
msgBusUniqueID
)
{
return
m
.
fInboxID
=
=
msgBusUniqueID
;
}
