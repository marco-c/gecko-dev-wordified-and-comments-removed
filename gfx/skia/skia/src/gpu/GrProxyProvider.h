#
ifndef
GrProxyProvider_DEFINED
#
define
GrProxyProvider_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
GrResourceKey
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxy
.
h
"
class
GrImageContext
;
class
GrBackendRenderTarget
;
class
SkBitmap
;
class
SkImage
;
class
GrProxyProvider
{
public
:
using
UseAllocator
=
GrSurfaceProxy
:
:
UseAllocator
;
GrProxyProvider
(
GrImageContext
*
)
;
~
GrProxyProvider
(
)
;
bool
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
void
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
)
;
void
removeUniqueKeyFromProxy
(
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
findOrCreateProxyByUniqueKey
(
const
GrUniqueKey
&
GrColorType
colorType
GrSurfaceOrigin
UseAllocator
=
UseAllocator
:
:
kYes
)
;
sk_sp
<
GrTextureProxy
>
createTextureProxy
(
sk_sp
<
SkImage
>
srcImage
int
sampleCnt
SkBudgeted
SkBackingFit
GrInternalSurfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
)
;
sk_sp
<
GrTextureProxy
>
createProxyFromBitmap
(
const
SkBitmap
&
bitmap
GrMipMapped
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrRenderable
int
renderTargetSampleCnt
GrSurfaceOrigin
GrMipMapped
SkBackingFit
SkBudgeted
GrProtected
GrInternalSurfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
UseAllocator
useAllocator
=
UseAllocator
:
:
kYes
)
;
sk_sp
<
GrTextureProxy
>
createCompressedTextureProxy
(
int
width
int
height
SkBudgeted
budgeted
SkImage
:
:
CompressionType
compressionType
sk_sp
<
SkData
>
data
)
;
typedef
void
*
ReleaseContext
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseContext
)
;
sk_sp
<
GrTextureProxy
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrColorType
GrSurfaceOrigin
GrWrapOwnership
GrWrapCacheable
GrIOType
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrTextureProxy
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
int
sampleCnt
GrColorType
GrWrapOwnership
GrWrapCacheable
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
GrColorType
GrSurfaceOrigin
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
GrColorType
GrSurfaceOrigin
int
sampleCnt
)
;
sk_sp
<
GrRenderTargetProxy
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
using
LazyInstantiationKeyMode
=
GrSurfaceProxy
:
:
LazyInstantiationKeyMode
;
using
LazyCallbackResult
=
GrSurfaceProxy
:
:
LazyCallbackResult
;
using
LazyInstantiateCallback
=
GrSurfaceProxy
:
:
LazyInstantiateCallback
;
struct
TextureInfo
{
GrMipMapped
fMipMapped
;
GrTextureType
fTextureType
;
}
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrRenderable
int
renderTargetSampleCnt
GrSurfaceOrigin
GrMipMapped
GrMipMapsStatus
GrInternalSurfaceFlags
SkBackingFit
SkBudgeted
GrProtected
UseAllocator
)
;
sk_sp
<
GrRenderTargetProxy
>
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
int
renderTargetSampleCnt
GrSurfaceOrigin
origin
GrInternalSurfaceFlags
const
TextureInfo
*
GrMipMapsStatus
SkBackingFit
SkBudgeted
GrProtected
bool
wrapsVkSecondaryCB
UseAllocator
useAllocator
)
;
static
sk_sp
<
GrTextureProxy
>
MakeFullyLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
GrRenderable
int
renderTargetSampleCnt
GrProtected
GrSurfaceOrigin
GrPixelConfig
const
GrCaps
&
UseAllocator
)
;
static
bool
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
;
enum
class
InvalidateGPUResource
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
processInvalidUniqueKey
(
const
GrUniqueKey
&
GrTextureProxy
*
InvalidateGPUResource
)
;
uint32_t
contextID
(
)
const
;
const
GrCaps
*
caps
(
)
const
;
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
;
int
numUniqueKeyProxies_TestOnly
(
)
const
;
void
orphanAllUniqueKeys
(
)
;
void
removeAllUniqueKeys
(
)
;
bool
renderingDirectly
(
)
const
;
#
if
GR_TEST_UTILS
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
const
SkISize
&
size
GrColorType
colorType
const
GrBackendFormat
&
format
GrRenderable
renderable
int
renderTargetSampleCnt
GrSurfaceOrigin
origin
SkBackingFit
fit
SkBudgeted
budgeted
GrProtected
isProtected
)
;
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
const
SkISize
&
size
GrColorType
colorType
GrRenderable
renderable
int
renderTargetSampleCnt
GrSurfaceOrigin
origin
SkBackingFit
fit
SkBudgeted
budgeted
GrProtected
isProtected
)
;
sk_sp
<
GrTextureProxy
>
testingOnly_createWrapped
(
sk_sp
<
GrTexture
>
GrColorType
GrSurfaceOrigin
)
;
#
endif
private
:
friend
class
GrAHardwareBufferImageGenerator
;
friend
class
GrResourceProvider
;
bool
isAbandoned
(
)
const
;
sk_sp
<
GrTextureProxy
>
createWrapped
(
sk_sp
<
GrTexture
>
tex
GrColorType
GrSurfaceOrigin
origin
UseAllocator
useAllocator
)
;
struct
UniquelyKeyedProxyHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrTextureProxy
&
p
)
{
return
p
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrTextureProxy
GrUniqueKey
UniquelyKeyedProxyHashTraits
>
UniquelyKeyedProxyHash
;
UniquelyKeyedProxyHash
fUniquelyKeyedProxies
;
GrImageContext
*
fImageContext
;
}
;
#
endif
