#
ifndef
GrProxyProvider_DEFINED
#
define
GrProxyProvider_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrResourceKey
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrResourceProvider
;
class
GrSingleOwner
;
class
GrBackendRenderTarget
;
class
SkBitmap
;
class
SkImage
;
class
GrProxyProvider
{
public
:
GrProxyProvider
(
GrResourceProvider
*
GrResourceCache
*
sk_sp
<
const
GrCaps
>
GrSingleOwner
*
)
;
GrProxyProvider
(
uint32_t
contextUniqueID
sk_sp
<
const
GrCaps
>
GrSingleOwner
*
)
;
~
GrProxyProvider
(
)
;
bool
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
void
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
)
;
void
removeUniqueKeyFromProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
findOrCreateProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
createTextureProxy
(
sk_sp
<
SkImage
>
srcImage
GrSurfaceDescFlags
int
sampleCnt
SkBudgeted
SkBackingFit
GrInternalSurfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxy
(
const
GrSurfaceDesc
&
GrSurfaceOrigin
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxyFromBitmap
(
const
SkBitmap
&
bitmap
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
SkBackingFit
SkBudgeted
GrInternalSurfaceFlags
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
SkBackingFit
fit
SkBudgeted
budgeted
GrInternalSurfaceFlags
surfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
)
{
return
this
-
>
createProxy
(
desc
origin
GrMipMapped
:
:
kNo
fit
budgeted
surfaceFlags
)
;
}
typedef
void
*
ReleaseContext
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseContext
)
;
sk_sp
<
GrTextureProxy
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
GrWrapOwnership
=
kBorrow_GrWrapOwnership
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrTextureProxy
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
int
sampleCnt
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
GrSurfaceOrigin
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
backendTex
GrSurfaceOrigin
origin
int
sampleCnt
)
;
using
LazyInstantiateCallback
=
std
:
:
function
<
sk_sp
<
GrSurface
>
(
GrResourceProvider
*
)
>
;
enum
class
Renderable
:
bool
{
kNo
=
false
kYes
=
true
}
;
struct
TextureInfo
{
GrMipMapped
fMipMapped
;
GrTextureType
fTextureType
;
}
;
using
LazyInstantiationType
=
GrSurfaceProxy
:
:
LazyInstantiationType
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
GrTextureType
GrInternalSurfaceFlags
SkBackingFit
SkBudgeted
LazyInstantiationType
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
GrTextureType
GrInternalSurfaceFlags
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
GrTextureType
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrRenderTargetProxy
>
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
origin
GrInternalSurfaceFlags
const
TextureInfo
*
SkBackingFit
SkBudgeted
)
;
static
sk_sp
<
GrTextureProxy
>
MakeFullyLazyProxy
(
LazyInstantiateCallback
&
&
Renderable
GrSurfaceOrigin
GrPixelConfig
const
GrCaps
&
)
;
static
bool
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
;
void
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
)
;
void
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
GrTextureProxy
*
bool
invalidateSurface
)
;
uint32_t
contextUniqueID
(
)
const
{
return
fContextUniqueID
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
{
return
fCaps
;
}
void
abandon
(
)
{
fResourceCache
=
nullptr
;
fResourceProvider
=
nullptr
;
fAbandoned
=
true
;
}
bool
isAbandoned
(
)
const
{
#
ifdef
SK_DEBUG
if
(
fAbandoned
)
{
SkASSERT
(
!
fResourceCache
&
&
!
fResourceProvider
)
;
}
#
endif
return
fAbandoned
;
}
int
numUniqueKeyProxies_TestOnly
(
)
const
;
void
orphanAllUniqueKeys
(
)
;
void
removeAllUniqueKeys
(
)
;
bool
recordingDDL
(
)
const
{
return
!
SkToBool
(
fResourceProvider
)
;
}
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
const
GrSurfaceDesc
&
GrSurfaceOrigin
SkBackingFit
SkBudgeted
)
;
private
:
friend
class
GrAHardwareBufferImageGenerator
;
friend
class
GrResourceProvider
;
sk_sp
<
GrTextureProxy
>
createWrapped
(
sk_sp
<
GrTexture
>
tex
GrSurfaceOrigin
origin
)
;
struct
UniquelyKeyedProxyHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrTextureProxy
&
p
)
{
return
p
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrTextureProxy
GrUniqueKey
UniquelyKeyedProxyHashTraits
>
UniquelyKeyedProxyHash
;
UniquelyKeyedProxyHash
fUniquelyKeyedProxies
;
GrResourceProvider
*
fResourceProvider
;
GrResourceCache
*
fResourceCache
;
bool
fAbandoned
;
sk_sp
<
const
GrCaps
>
fCaps
;
uint32_t
fContextUniqueID
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
#
endif
