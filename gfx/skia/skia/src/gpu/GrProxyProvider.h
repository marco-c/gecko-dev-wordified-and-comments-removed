#
ifndef
GrProxyProvider_DEFINED
#
define
GrProxyProvider_DEFINED
#
include
"
GrResourceKey
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrCaps
;
class
GrResourceProvider
;
class
GrSingleOwner
;
class
GrBackendRenderTarget
;
class
SkBitmap
;
class
SkImage
;
class
GrProxyProvider
{
public
:
GrProxyProvider
(
GrResourceProvider
*
GrResourceCache
*
sk_sp
<
const
GrCaps
>
GrSingleOwner
*
)
;
~
GrProxyProvider
(
)
;
bool
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
void
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
)
;
void
removeUniqueKeyFromProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
findOrCreateProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
createInstantiatedProxy
(
const
GrSurfaceDesc
&
SkBackingFit
SkBudgeted
uint32_t
flags
=
0
)
;
sk_sp
<
GrTextureProxy
>
createTextureProxy
(
const
GrSurfaceDesc
&
SkBudgeted
const
void
*
srcData
size_t
rowBytes
)
;
sk_sp
<
GrTextureProxy
>
createTextureProxy
(
sk_sp
<
SkImage
>
srcImage
GrSurfaceFlags
flags
GrSurfaceOrigin
origin
int
sampleCnt
SkBudgeted
budgeted
SkBackingFit
fit
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxy
(
const
GrSurfaceDesc
&
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxyFromBitmap
(
const
SkBitmap
&
bitmap
SkColorSpace
*
dstColorSpace
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrSurfaceDesc
&
GrMipMapped
SkBackingFit
SkBudgeted
uint32_t
flags
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrSurfaceDesc
&
desc
SkBackingFit
fit
SkBudgeted
budgeted
uint32_t
flags
=
0
)
{
return
this
-
>
createProxy
(
desc
GrMipMapped
:
:
kNo
fit
budgeted
flags
)
;
}
typedef
void
*
ReleaseContext
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseContext
)
;
sk_sp
<
GrTextureProxy
>
createWrappedTextureProxy
(
const
GrBackendTexture
&
GrSurfaceOrigin
GrWrapOwnership
=
kBorrow_GrWrapOwnership
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrTextureProxy
>
createWrappedTextureProxy
(
const
GrBackendTexture
&
GrSurfaceOrigin
int
sampleCnt
)
;
sk_sp
<
GrSurfaceProxy
>
createWrappedRenderTargetProxy
(
const
GrBackendRenderTarget
&
GrSurfaceOrigin
)
;
sk_sp
<
GrSurfaceProxy
>
createWrappedRenderTargetProxy
(
const
GrBackendTexture
&
tex
GrSurfaceOrigin
origin
int
sampleCnt
)
;
using
LazyInstantiateCallback
=
std
:
:
function
<
sk_sp
<
GrSurface
>
(
GrResourceProvider
*
)
>
;
enum
class
Textureable
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
Renderable
:
bool
{
kNo
=
false
kYes
=
true
}
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrMipMapped
GrRenderTargetFlags
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrMipMapped
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createFullyLazyProxy
(
LazyInstantiateCallback
&
&
Renderable
GrSurfaceOrigin
GrPixelConfig
)
;
sk_sp
<
GrRenderTargetProxy
>
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrSurfaceDesc
&
GrRenderTargetFlags
Textureable
GrMipMapped
SkBackingFit
SkBudgeted
)
;
static
bool
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
;
void
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
)
;
void
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
GrTextureProxy
*
bool
invalidateSurface
)
;
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
void
abandon
(
)
{
fResourceCache
=
nullptr
;
fResourceProvider
=
nullptr
;
fAbandoned
=
true
;
}
bool
isAbandoned
(
)
const
{
#
ifdef
SK_DEBUG
if
(
fAbandoned
)
{
SkASSERT
(
!
fResourceCache
&
&
!
fResourceProvider
)
;
}
#
endif
return
fAbandoned
;
}
int
numUniqueKeyProxies_TestOnly
(
)
const
;
void
removeAllUniqueKeys
(
)
;
bool
mutableBitmapsNeedCopy
(
)
const
{
return
!
SkToBool
(
fResourceProvider
)
;
}
private
:
friend
class
GrAHardwareBufferImageGenerator
;
sk_sp
<
GrTextureProxy
>
createWrapped
(
sk_sp
<
GrTexture
>
tex
GrSurfaceOrigin
origin
)
;
struct
UniquelyKeyedProxyHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrTextureProxy
&
p
)
{
return
p
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrTextureProxy
GrUniqueKey
UniquelyKeyedProxyHashTraits
>
UniquelyKeyedProxyHash
;
UniquelyKeyedProxyHash
fUniquelyKeyedProxies
;
GrResourceProvider
*
fResourceProvider
;
GrResourceCache
*
fResourceCache
;
bool
fAbandoned
;
sk_sp
<
const
GrCaps
>
fCaps
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
#
endif
