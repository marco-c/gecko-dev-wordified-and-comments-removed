#
ifndef
GrProxyProvider_DEFINED
#
define
GrProxyProvider_DEFINED
#
include
"
GrResourceKey
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrImageContext
;
class
GrBackendRenderTarget
;
class
SkBitmap
;
class
SkImage
;
class
GrProxyProvider
{
public
:
GrProxyProvider
(
GrImageContext
*
)
;
~
GrProxyProvider
(
)
;
bool
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
GrTextureProxy
*
)
;
void
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
)
;
void
removeUniqueKeyFromProxy
(
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
findOrCreateProxyByUniqueKey
(
const
GrUniqueKey
&
GrSurfaceOrigin
)
;
sk_sp
<
GrTextureProxy
>
createTextureProxy
(
sk_sp
<
SkImage
>
srcImage
GrSurfaceDescFlags
int
sampleCnt
SkBudgeted
SkBackingFit
GrInternalSurfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxy
(
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createMipMapProxyFromBitmap
(
const
SkBitmap
&
bitmap
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
SkBackingFit
SkBudgeted
GrInternalSurfaceFlags
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrBackendFormat
&
format
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
SkBackingFit
fit
SkBudgeted
budgeted
GrInternalSurfaceFlags
surfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
)
{
return
this
-
>
createProxy
(
format
desc
origin
GrMipMapped
:
:
kNo
fit
budgeted
surfaceFlags
)
;
}
sk_sp
<
GrTextureProxy
>
createProxy
(
sk_sp
<
SkData
>
const
GrSurfaceDesc
&
desc
)
;
typedef
void
*
ReleaseContext
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseContext
)
;
sk_sp
<
GrTextureProxy
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
GrWrapOwnership
GrWrapCacheable
GrIOType
ReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
sk_sp
<
GrTextureProxy
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
ReleaseProc
ReleaseContext
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
GrSurfaceOrigin
ReleaseProc
ReleaseContext
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
backendTex
GrSurfaceOrigin
origin
int
sampleCnt
)
;
sk_sp
<
GrRenderTargetProxy
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
using
LazyInstantiateCallback
=
std
:
:
function
<
sk_sp
<
GrSurface
>
(
GrResourceProvider
*
)
>
;
enum
class
Renderable
:
bool
{
kNo
=
false
kYes
=
true
}
;
struct
TextureInfo
{
GrMipMapped
fMipMapped
;
GrTextureType
fTextureType
;
}
;
using
LazyInstantiationType
=
GrSurfaceProxy
:
:
LazyInstantiationType
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
GrInternalSurfaceFlags
SkBackingFit
SkBudgeted
LazyInstantiationType
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
GrInternalSurfaceFlags
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
GrMipMapped
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrRenderTargetProxy
>
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrSurfaceOrigin
origin
GrInternalSurfaceFlags
const
TextureInfo
*
SkBackingFit
SkBudgeted
bool
wrapsVkSecondaryCB
)
;
static
sk_sp
<
GrTextureProxy
>
MakeFullyLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
Renderable
GrSurfaceOrigin
GrPixelConfig
const
GrCaps
&
)
;
static
bool
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
;
enum
class
InvalidateGPUResource
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
processInvalidUniqueKey
(
const
GrUniqueKey
&
GrTextureProxy
*
InvalidateGPUResource
)
;
uint32_t
contextID
(
)
const
;
const
GrCaps
*
caps
(
)
const
;
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
;
int
numUniqueKeyProxies_TestOnly
(
)
const
;
void
orphanAllUniqueKeys
(
)
;
void
removeAllUniqueKeys
(
)
;
bool
renderingDirectly
(
)
const
;
#
if
GR_TEST_UTILS
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
const
GrSurfaceDesc
&
GrSurfaceOrigin
SkBackingFit
SkBudgeted
)
;
sk_sp
<
GrTextureProxy
>
testingOnly_createWrapped
(
sk_sp
<
GrTexture
>
GrSurfaceOrigin
)
;
#
endif
private
:
friend
class
GrAHardwareBufferImageGenerator
;
friend
class
GrResourceProvider
;
bool
isAbandoned
(
)
const
;
sk_sp
<
GrTextureProxy
>
createWrapped
(
sk_sp
<
GrTexture
>
tex
GrSurfaceOrigin
origin
)
;
struct
UniquelyKeyedProxyHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrTextureProxy
&
p
)
{
return
p
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrTextureProxy
GrUniqueKey
UniquelyKeyedProxyHashTraits
>
UniquelyKeyedProxyHash
;
UniquelyKeyedProxyHash
fUniquelyKeyedProxies
;
GrImageContext
*
fImageContext
;
}
;
#
endif
