#
ifndef
GrRenderTask_DEFINED
#
define
GrRenderTask_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkTDArray
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
GrTextureResolveManager
.
h
"
class
GrOpFlushState
;
class
GrOpsTask
;
class
GrResourceAllocator
;
class
GrTextureResolveRenderTask
;
class
GrRenderTask
:
public
SkRefCnt
{
public
:
GrRenderTask
(
sk_sp
<
GrSurfaceProxy
>
target
)
;
~
GrRenderTask
(
)
override
;
void
makeClosed
(
const
GrCaps
&
)
;
void
prePrepare
(
GrRecordingContext
*
context
)
{
this
-
>
onPrePrepare
(
context
)
;
}
void
prepare
(
GrOpFlushState
*
flushState
)
;
bool
execute
(
GrOpFlushState
*
flushState
)
{
return
this
-
>
onExecute
(
flushState
)
;
}
virtual
void
endFlush
(
)
{
}
bool
isClosed
(
)
const
{
return
this
-
>
isSetFlag
(
kClosed_Flag
)
;
}
void
addDependency
(
GrSurfaceProxy
*
dependedOn
GrMipMapped
GrTextureResolveManager
const
GrCaps
&
caps
)
;
void
addDependenciesFromOtherTask
(
GrRenderTask
*
otherTask
)
;
bool
dependsOn
(
const
GrRenderTask
*
dependedOn
)
const
;
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
virtual
GrOpsTask
*
asOpsTask
(
)
{
return
nullptr
;
}
#
ifdef
SK_DEBUG
virtual
void
dump
(
bool
printDependencies
)
const
;
virtual
int
numClips
(
)
const
{
return
0
;
}
using
VisitSurfaceProxyFunc
=
std
:
:
function
<
void
(
GrSurfaceProxy
*
GrMipMapped
)
>
;
virtual
void
visitProxies_debugOnly
(
const
VisitSurfaceProxyFunc
&
)
const
=
0
;
void
visitTargetAndSrcProxies_debugOnly
(
const
VisitSurfaceProxyFunc
&
fn
)
const
{
this
-
>
visitProxies_debugOnly
(
fn
)
;
if
(
fTarget
)
{
fn
(
fTarget
.
get
(
)
GrMipMapped
:
:
kNo
)
;
}
}
#
endif
protected
:
bool
isInstantiated
(
)
const
;
SkDEBUGCODE
(
bool
deferredProxiesAreInstantiated
(
)
const
;
)
enum
class
ExpectedOutcome
:
bool
{
kTargetUnchanged
kTargetDirty
}
;
virtual
ExpectedOutcome
onMakeClosed
(
const
GrCaps
&
SkIRect
*
targetUpdateBounds
)
=
0
;
sk_sp
<
GrSurfaceProxy
>
fTarget
;
SkTArray
<
GrTextureProxy
*
true
>
fDeferredProxies
;
private
:
friend
class
GrDrawingManager
;
virtual
void
handleInternalAllocationFailure
(
)
=
0
;
virtual
bool
onIsUsed
(
GrSurfaceProxy
*
)
const
=
0
;
bool
isUsed
(
GrSurfaceProxy
*
proxy
)
const
{
if
(
proxy
=
=
fTarget
.
get
(
)
)
{
return
true
;
}
return
this
-
>
onIsUsed
(
proxy
)
;
}
void
addDependency
(
GrRenderTask
*
dependedOn
)
;
void
addDependent
(
GrRenderTask
*
dependent
)
;
SkDEBUGCODE
(
bool
isDependedent
(
const
GrRenderTask
*
dependent
)
const
;
)
SkDEBUGCODE
(
void
validate
(
)
const
;
)
void
closeThoseWhoDependOnMe
(
const
GrCaps
&
)
;
virtual
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
=
0
;
static
uint32_t
CreateUniqueID
(
)
;
enum
Flags
{
kClosed_Flag
=
0x01
kWasOutput_Flag
=
0x02
kTempMark_Flag
=
0x04
}
;
void
setFlag
(
uint32_t
flag
)
{
fFlags
|
=
flag
;
}
void
resetFlag
(
uint32_t
flag
)
{
fFlags
&
=
~
flag
;
}
bool
isSetFlag
(
uint32_t
flag
)
const
{
return
SkToBool
(
fFlags
&
flag
)
;
}
struct
TopoSortTraits
{
static
void
Output
(
GrRenderTask
*
renderTask
int
)
{
renderTask
-
>
setFlag
(
kWasOutput_Flag
)
;
}
static
bool
WasOutput
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
isSetFlag
(
kWasOutput_Flag
)
;
}
static
void
SetTempMark
(
GrRenderTask
*
renderTask
)
{
renderTask
-
>
setFlag
(
kTempMark_Flag
)
;
}
static
void
ResetTempMark
(
GrRenderTask
*
renderTask
)
{
renderTask
-
>
resetFlag
(
kTempMark_Flag
)
;
}
static
bool
IsTempMarked
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
isSetFlag
(
kTempMark_Flag
)
;
}
static
int
NumDependencies
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
fDependencies
.
count
(
)
;
}
static
GrRenderTask
*
Dependency
(
GrRenderTask
*
renderTask
int
index
)
{
return
renderTask
-
>
fDependencies
[
index
]
;
}
}
;
virtual
void
onPrePrepare
(
GrRecordingContext
*
)
{
}
virtual
void
onPrepare
(
GrOpFlushState
*
)
{
}
virtual
bool
onExecute
(
GrOpFlushState
*
flushState
)
=
0
;
const
uint32_t
fUniqueID
;
uint32_t
fFlags
;
SkSTArray
<
1
GrRenderTask
*
true
>
fDependencies
;
SkSTArray
<
1
GrRenderTask
*
true
>
fDependents
;
GrTextureResolveRenderTask
*
fTextureResolveTask
=
nullptr
;
}
;
#
endif
