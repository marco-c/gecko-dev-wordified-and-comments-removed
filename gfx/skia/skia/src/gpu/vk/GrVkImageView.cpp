#
include
"
src
/
gpu
/
vk
/
GrVkGpu
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkImageView
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkSamplerYcbcrConversion
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkUtil
.
h
"
const
GrVkImageView
*
GrVkImageView
:
:
Create
(
GrVkGpu
*
gpu
VkImage
image
VkFormat
format
Type
viewType
uint32_t
miplevels
const
GrVkYcbcrConversionInfo
&
ycbcrInfo
)
{
void
*
pNext
=
nullptr
;
VkSamplerYcbcrConversionInfo
conversionInfo
;
GrVkSamplerYcbcrConversion
*
ycbcrConversion
=
nullptr
;
if
(
ycbcrInfo
.
isValid
(
)
)
{
SkASSERT
(
gpu
-
>
vkCaps
(
)
.
supportsYcbcrConversion
(
)
&
&
format
=
=
ycbcrInfo
.
fFormat
)
;
ycbcrConversion
=
gpu
-
>
resourceProvider
(
)
.
findOrCreateCompatibleSamplerYcbcrConversion
(
ycbcrInfo
)
;
if
(
!
ycbcrConversion
)
{
return
nullptr
;
}
conversionInfo
.
sType
=
VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
;
conversionInfo
.
pNext
=
nullptr
;
conversionInfo
.
conversion
=
ycbcrConversion
-
>
ycbcrConversion
(
)
;
pNext
=
&
conversionInfo
;
}
VkImageView
imageView
;
VkImageViewCreateInfo
viewInfo
=
{
VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
pNext
0
image
VK_IMAGE_VIEW_TYPE_2D
format
{
VK_COMPONENT_SWIZZLE_IDENTITY
VK_COMPONENT_SWIZZLE_IDENTITY
VK_COMPONENT_SWIZZLE_IDENTITY
VK_COMPONENT_SWIZZLE_IDENTITY
}
{
VK_IMAGE_ASPECT_COLOR_BIT
0
miplevels
0
1
}
}
;
if
(
kStencil_Type
=
=
viewType
)
{
viewInfo
.
subresourceRange
.
aspectMask
=
VK_IMAGE_ASPECT_STENCIL_BIT
;
}
VkResult
err
=
GR_VK_CALL
(
gpu
-
>
vkInterface
(
)
CreateImageView
(
gpu
-
>
device
(
)
&
viewInfo
nullptr
&
imageView
)
)
;
if
(
err
)
{
return
nullptr
;
}
return
new
GrVkImageView
(
imageView
ycbcrConversion
)
;
}
void
GrVkImageView
:
:
freeGPUData
(
GrVkGpu
*
gpu
)
const
{
GR_VK_CALL
(
gpu
-
>
vkInterface
(
)
DestroyImageView
(
gpu
-
>
device
(
)
fImageView
nullptr
)
)
;
if
(
fYcbcrConversion
)
{
fYcbcrConversion
-
>
unref
(
gpu
)
;
}
}
void
GrVkImageView
:
:
abandonGPUData
(
)
const
{
if
(
fYcbcrConversion
)
{
fYcbcrConversion
-
>
unrefAndAbandon
(
)
;
}
}
