#
include
"
SkAutoMalloc
.
h
"
#
include
"
vk
/
GrVkBackendContext
.
h
"
#
include
"
vk
/
GrVkExtensions
.
h
"
#
include
"
vk
/
GrVkInterface
.
h
"
#
include
"
vk
/
GrVkUtil
.
h
"
#
ifdef
SK_ENABLE_VK_LAYERS
const
char
*
kDebugLayerNames
[
]
=
{
"
VK_LAYER_GOOGLE_threading
"
"
VK_LAYER_LUNARG_parameter_validation
"
"
VK_LAYER_LUNARG_object_tracker
"
"
VK_LAYER_LUNARG_image
"
"
VK_LAYER_LUNARG_core_validation
"
"
VK_LAYER_LUNARG_swapchain
"
"
VK_LAYER_GOOGLE_unique_objects
"
}
;
#
endif
#
ifdef
SK_BUILD_FOR_ANDROID
const
uint32_t
kGrVkMinimumVersion
=
VK_MAKE_VERSION
(
1
0
3
)
;
#
else
const
uint32_t
kGrVkMinimumVersion
=
VK_MAKE_VERSION
(
1
0
8
)
;
#
endif
#
define
ACQUIRE_VK_PROC
(
name
instance
device
)
\
PFN_vk
#
#
name
grVk
#
#
name
=
\
reinterpret_cast
<
PFN_vk
#
#
name
>
(
getProc
(
"
vk
"
#
name
instance
device
)
)
;
\
if
(
grVk
#
#
name
=
=
nullptr
)
{
\
SkDebugf
(
"
Function
ptr
for
vk
%
s
could
not
be
acquired
\
n
"
#
name
)
;
\
return
nullptr
;
\
}
const
GrVkBackendContext
*
GrVkBackendContext
:
:
Create
(
uint32_t
*
presentQueueIndexPtr
CanPresentFn
canPresent
GrVkInterface
:
:
GetProc
getProc
)
{
#
ifdef
SK_LINK_WITH_VULKAN
if
(
getProc
=
=
nullptr
)
{
getProc
=
[
]
(
const
char
*
proc_name
VkInstance
instance
VkDevice
device
)
{
if
(
device
!
=
VK_NULL_HANDLE
)
{
return
vkGetDeviceProcAddr
(
device
proc_name
)
;
}
return
vkGetInstanceProcAddr
(
instance
proc_name
)
;
}
;
}
#
else
SkASSERT
(
getProc
!
=
nullptr
)
;
#
endif
VkPhysicalDevice
physDev
;
VkDevice
device
;
VkInstance
inst
;
VkResult
err
;
const
VkApplicationInfo
app_info
=
{
VK_STRUCTURE_TYPE_APPLICATION_INFO
nullptr
"
vktest
"
0
"
vktest
"
0
kGrVkMinimumVersion
}
;
GrVkExtensions
extensions
(
getProc
)
;
extensions
.
initInstance
(
kGrVkMinimumVersion
)
;
SkTArray
<
const
char
*
>
instanceLayerNames
;
SkTArray
<
const
char
*
>
instanceExtensionNames
;
uint32_t
extensionFlags
=
0
;
#
ifdef
SK_ENABLE_VK_LAYERS
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
kDebugLayerNames
)
;
+
+
i
)
{
if
(
extensions
.
hasInstanceLayer
(
kDebugLayerNames
[
i
]
)
)
{
instanceLayerNames
.
push_back
(
kDebugLayerNames
[
i
]
)
;
}
}
if
(
extensions
.
hasInstanceExtension
(
VK_EXT_DEBUG_REPORT_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_EXT_DEBUG_REPORT_EXTENSION_NAME
)
;
extensionFlags
|
=
kEXT_debug_report_GrVkExtensionFlag
;
}
#
endif
if
(
extensions
.
hasInstanceExtension
(
VK_KHR_SURFACE_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_KHR_SURFACE_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_surface_GrVkExtensionFlag
;
}
if
(
extensions
.
hasInstanceExtension
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_swapchain_GrVkExtensionFlag
;
}
#
ifdef
SK_BUILD_FOR_WIN
if
(
extensions
.
hasInstanceExtension
(
VK_KHR_WIN32_SURFACE_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_KHR_WIN32_SURFACE_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_win32_surface_GrVkExtensionFlag
;
}
#
elif
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
extensions
.
hasInstanceExtension
(
VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_android_surface_GrVkExtensionFlag
;
}
#
elif
defined
(
SK_BUILD_FOR_UNIX
)
&
&
!
defined
(
__Fuchsia__
)
if
(
extensions
.
hasInstanceExtension
(
VK_KHR_XCB_SURFACE_EXTENSION_NAME
)
)
{
instanceExtensionNames
.
push_back
(
VK_KHR_XCB_SURFACE_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_xcb_surface_GrVkExtensionFlag
;
}
#
endif
const
VkInstanceCreateInfo
instance_create
=
{
VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
nullptr
0
&
app_info
(
uint32_t
)
instanceLayerNames
.
count
(
)
instanceLayerNames
.
begin
(
)
(
uint32_t
)
instanceExtensionNames
.
count
(
)
instanceExtensionNames
.
begin
(
)
}
;
ACQUIRE_VK_PROC
(
CreateInstance
VK_NULL_HANDLE
VK_NULL_HANDLE
)
;
err
=
grVkCreateInstance
(
&
instance_create
nullptr
&
inst
)
;
if
(
err
<
0
)
{
SkDebugf
(
"
vkCreateInstance
failed
:
%
d
\
n
"
err
)
;
return
nullptr
;
}
ACQUIRE_VK_PROC
(
DestroyInstance
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
EnumeratePhysicalDevices
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
GetPhysicalDeviceQueueFamilyProperties
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
GetPhysicalDeviceFeatures
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
CreateDevice
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
GetDeviceQueue
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
DeviceWaitIdle
inst
VK_NULL_HANDLE
)
;
ACQUIRE_VK_PROC
(
DestroyDevice
inst
VK_NULL_HANDLE
)
;
uint32_t
gpuCount
;
err
=
grVkEnumeratePhysicalDevices
(
inst
&
gpuCount
nullptr
)
;
if
(
err
)
{
SkDebugf
(
"
vkEnumeratePhysicalDevices
failed
:
%
d
\
n
"
err
)
;
grVkDestroyInstance
(
inst
nullptr
)
;
return
nullptr
;
}
SkASSERT
(
gpuCount
>
0
)
;
gpuCount
=
1
;
err
=
grVkEnumeratePhysicalDevices
(
inst
&
gpuCount
&
physDev
)
;
if
(
err
)
{
SkDebugf
(
"
vkEnumeratePhysicalDevices
failed
:
%
d
\
n
"
err
)
;
grVkDestroyInstance
(
inst
nullptr
)
;
return
nullptr
;
}
uint32_t
queueCount
;
grVkGetPhysicalDeviceQueueFamilyProperties
(
physDev
&
queueCount
nullptr
)
;
SkASSERT
(
queueCount
>
=
1
)
;
SkAutoMalloc
queuePropsAlloc
(
queueCount
*
sizeof
(
VkQueueFamilyProperties
)
)
;
VkQueueFamilyProperties
*
queueProps
=
(
VkQueueFamilyProperties
*
)
queuePropsAlloc
.
get
(
)
;
grVkGetPhysicalDeviceQueueFamilyProperties
(
physDev
&
queueCount
queueProps
)
;
uint32_t
graphicsQueueIndex
=
queueCount
;
for
(
uint32_t
i
=
0
;
i
<
queueCount
;
i
+
+
)
{
if
(
queueProps
[
i
]
.
queueFlags
&
VK_QUEUE_GRAPHICS_BIT
)
{
graphicsQueueIndex
=
i
;
break
;
}
}
SkASSERT
(
graphicsQueueIndex
<
queueCount
)
;
uint32_t
presentQueueIndex
=
graphicsQueueIndex
;
if
(
presentQueueIndexPtr
&
&
canPresent
)
{
for
(
uint32_t
i
=
0
;
i
<
queueCount
;
i
+
+
)
{
if
(
canPresent
(
inst
physDev
i
)
)
{
presentQueueIndex
=
i
;
break
;
}
}
SkASSERT
(
presentQueueIndex
<
queueCount
)
;
*
presentQueueIndexPtr
=
presentQueueIndex
;
}
extensions
.
initDevice
(
kGrVkMinimumVersion
inst
physDev
)
;
SkTArray
<
const
char
*
>
deviceLayerNames
;
SkTArray
<
const
char
*
>
deviceExtensionNames
;
#
ifdef
SK_ENABLE_VK_LAYERS
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
kDebugLayerNames
)
;
+
+
i
)
{
if
(
extensions
.
hasDeviceLayer
(
kDebugLayerNames
[
i
]
)
)
{
deviceLayerNames
.
push_back
(
kDebugLayerNames
[
i
]
)
;
}
}
#
endif
if
(
extensions
.
hasDeviceExtension
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
)
)
{
deviceExtensionNames
.
push_back
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
)
;
extensionFlags
|
=
kKHR_swapchain_GrVkExtensionFlag
;
}
if
(
extensions
.
hasDeviceExtension
(
"
VK_NV_glsl_shader
"
)
)
{
deviceExtensionNames
.
push_back
(
"
VK_NV_glsl_shader
"
)
;
extensionFlags
|
=
kNV_glsl_shader_GrVkExtensionFlag
;
}
VkPhysicalDeviceFeatures
deviceFeatures
;
grVkGetPhysicalDeviceFeatures
(
physDev
&
deviceFeatures
)
;
deviceFeatures
.
robustBufferAccess
=
VK_FALSE
;
uint32_t
featureFlags
=
0
;
if
(
deviceFeatures
.
geometryShader
)
{
featureFlags
|
=
kGeometryShader_GrVkFeatureFlag
;
}
if
(
deviceFeatures
.
dualSrcBlend
)
{
featureFlags
|
=
kDualSrcBlend_GrVkFeatureFlag
;
}
if
(
deviceFeatures
.
sampleRateShading
)
{
featureFlags
|
=
kSampleRateShading_GrVkFeatureFlag
;
}
float
queuePriorities
[
1
]
=
{
0
.
0
}
;
const
VkDeviceQueueCreateInfo
queueInfo
[
2
]
=
{
{
VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
nullptr
0
graphicsQueueIndex
1
queuePriorities
}
{
VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
nullptr
0
presentQueueIndex
1
queuePriorities
}
}
;
uint32_t
queueInfoCount
=
(
presentQueueIndex
!
=
graphicsQueueIndex
)
?
2
:
1
;
const
VkDeviceCreateInfo
deviceInfo
=
{
VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
nullptr
0
queueInfoCount
queueInfo
(
uint32_t
)
deviceLayerNames
.
count
(
)
deviceLayerNames
.
begin
(
)
(
uint32_t
)
deviceExtensionNames
.
count
(
)
deviceExtensionNames
.
begin
(
)
&
deviceFeatures
}
;
err
=
grVkCreateDevice
(
physDev
&
deviceInfo
nullptr
&
device
)
;
if
(
err
)
{
SkDebugf
(
"
CreateDevice
failed
:
%
d
\
n
"
err
)
;
grVkDestroyInstance
(
inst
nullptr
)
;
return
nullptr
;
}
auto
interface
=
sk_make_sp
<
GrVkInterface
>
(
getProc
inst
device
extensionFlags
)
;
if
(
!
interface
-
>
validate
(
extensionFlags
)
)
{
SkDebugf
(
"
Vulkan
interface
validation
failed
\
n
"
)
;
grVkDeviceWaitIdle
(
device
)
;
grVkDestroyDevice
(
device
nullptr
)
;
grVkDestroyInstance
(
inst
nullptr
)
;
return
nullptr
;
}
VkQueue
queue
;
grVkGetDeviceQueue
(
device
graphicsQueueIndex
0
&
queue
)
;
GrVkBackendContext
*
ctx
=
new
GrVkBackendContext
(
)
;
ctx
-
>
fInstance
=
inst
;
ctx
-
>
fPhysicalDevice
=
physDev
;
ctx
-
>
fDevice
=
device
;
ctx
-
>
fQueue
=
queue
;
ctx
-
>
fGraphicsQueueIndex
=
graphicsQueueIndex
;
ctx
-
>
fMinAPIVersion
=
kGrVkMinimumVersion
;
ctx
-
>
fExtensions
=
extensionFlags
;
ctx
-
>
fFeatures
=
featureFlags
;
ctx
-
>
fInterface
.
reset
(
interface
.
release
(
)
)
;
return
ctx
;
}
GrVkBackendContext
:
:
~
GrVkBackendContext
(
)
{
if
(
fInterface
=
=
nullptr
)
{
return
;
}
fInterface
-
>
fFunctions
.
fDeviceWaitIdle
(
fDevice
)
;
fInterface
-
>
fFunctions
.
fDestroyDevice
(
fDevice
nullptr
)
;
fDevice
=
VK_NULL_HANDLE
;
fInterface
-
>
fFunctions
.
fDestroyInstance
(
fInstance
nullptr
)
;
fInstance
=
VK_NULL_HANDLE
;
}
