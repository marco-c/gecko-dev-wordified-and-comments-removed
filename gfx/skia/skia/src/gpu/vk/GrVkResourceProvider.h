#
ifndef
GrVkResourceProvider_DEFINED
#
define
GrVkResourceProvider_DEFINED
#
include
"
GrGpu
.
h
"
#
include
"
GrVkDescriptorPool
.
h
"
#
include
"
GrVkPipelineState
.
h
"
#
include
"
GrVkResource
.
h
"
#
include
"
GrVkUtil
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTDynamicHash
.
h
"
#
include
"
SkTHash
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
vk
/
GrVkDefines
.
h
"
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrTextureParams
;
class
GrVkCommandBuffer
;
class
GrVkGpu
;
class
GrVkPipeline
;
class
GrVkRenderPass
;
class
GrVkRenderTarget
;
class
GrVkSampler
;
class
GrVkResourceProvider
{
public
:
GrVkResourceProvider
(
GrVkGpu
*
gpu
)
;
~
GrVkResourceProvider
(
)
;
void
init
(
)
;
GrVkPipeline
*
createPipeline
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
VkPipelineShaderStageCreateInfo
*
shaderStageInfo
int
shaderStageCount
GrPrimitiveType
primitiveType
const
GrVkRenderPass
&
renderPass
VkPipelineLayout
layout
)
;
const
GrVkRenderPass
*
findOrCreateCompatibleRenderPass
(
const
GrVkRenderTarget
&
target
)
;
GrVkCommandBuffer
*
createCommandBuffer
(
)
;
void
checkCommandBuffers
(
)
;
GrVkDescriptorPool
*
findOrCreateCompatibleDescriptorPool
(
VkDescriptorType
type
uint32_t
count
)
;
GrVkSampler
*
findOrCreateCompatibleSampler
(
const
GrTextureParams
&
)
;
sk_sp
<
GrVkPipelineState
>
findOrCreateCompatiblePipelineState
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
GrPrimitiveType
const
GrVkRenderPass
&
renderPass
)
;
void
destroyResources
(
)
;
void
abandonResources
(
)
;
private
:
#
ifdef
SK_DEVELOPER
#
define
GR_PIPELINE_STATE_CACHE_STATS
#
endif
class
PipelineStateCache
:
public
:
:
SkNoncopyable
{
public
:
PipelineStateCache
(
GrVkGpu
*
gpu
)
;
~
PipelineStateCache
(
)
;
void
abandon
(
)
;
void
release
(
)
;
sk_sp
<
GrVkPipelineState
>
refPipelineState
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
GrPrimitiveType
const
GrVkRenderPass
&
renderPass
)
;
private
:
enum
{
kMaxEntries
=
128
}
;
struct
Entry
;
void
reset
(
)
;
int
fCount
;
SkTHashTable
<
Entry
*
const
GrVkPipelineState
:
:
Desc
&
Entry
>
fHashTable
;
SkTInternalLList
<
Entry
>
fLRUList
;
GrVkGpu
*
fGpu
;
#
ifdef
GR_PIPELINE_STATE_CACHE_STATS
int
fTotalRequests
;
int
fCacheMisses
;
#
endif
}
;
GrVkGpu
*
fGpu
;
VkPipelineCache
fPipelineCache
;
SkSTArray
<
4
GrVkRenderPass
*
>
fSimpleRenderPasses
;
SkSTArray
<
4
GrVkCommandBuffer
*
>
fActiveCommandBuffers
;
SkTDynamicHash
<
GrVkSampler
uint8_t
>
fSamplers
;
PipelineStateCache
*
fPipelineStateCache
;
}
;
#
endif
