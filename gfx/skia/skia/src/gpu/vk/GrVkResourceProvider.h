#
ifndef
GrVkResourceProvider_DEFINED
#
define
GrVkResourceProvider_DEFINED
#
include
"
GrGpu
.
h
"
#
include
"
GrResourceHandle
.
h
"
#
include
"
GrVkDescriptorPool
.
h
"
#
include
"
GrVkDescriptorSetManager
.
h
"
#
include
"
GrVkPipelineState
.
h
"
#
include
"
GrVkRenderPass
.
h
"
#
include
"
GrVkResource
.
h
"
#
include
"
GrVkUtil
.
h
"
#
include
"
SkLRUCache
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTDynamicHash
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
vk
/
GrVkDefines
.
h
"
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrSamplerParams
;
class
GrVkCopyPipeline
;
class
GrVkGpu
;
class
GrVkPipeline
;
class
GrVkPrimaryCommandBuffer
;
class
GrVkRenderTarget
;
class
GrVkSampler
;
class
GrVkSecondaryCommandBuffer
;
class
GrVkUniformHandler
;
class
GrVkResourceProvider
{
public
:
GrVkResourceProvider
(
GrVkGpu
*
gpu
)
;
~
GrVkResourceProvider
(
)
;
void
init
(
)
;
GrVkPipeline
*
createPipeline
(
const
GrPipeline
&
pipeline
const
GrStencilSettings
&
stencil
const
GrPrimitiveProcessor
&
primProc
VkPipelineShaderStageCreateInfo
*
shaderStageInfo
int
shaderStageCount
GrPrimitiveType
primitiveType
const
GrVkRenderPass
&
renderPass
VkPipelineLayout
layout
)
;
GrVkCopyPipeline
*
findOrCreateCopyPipeline
(
const
GrVkRenderTarget
*
dst
VkPipelineShaderStageCreateInfo
*
VkPipelineLayout
)
;
GR_DEFINE_RESOURCE_HANDLE_CLASS
(
CompatibleRPHandle
)
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
const
GrVkRenderTarget
&
target
CompatibleRPHandle
*
compatibleHandle
=
nullptr
)
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
const
CompatibleRPHandle
&
compatibleHandle
)
;
const
GrVkRenderPass
*
findRenderPass
(
const
GrVkRenderTarget
&
target
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
CompatibleRPHandle
*
compatibleHandle
=
nullptr
)
;
const
GrVkRenderPass
*
findRenderPass
(
const
CompatibleRPHandle
&
compatibleHandle
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
GrVkPrimaryCommandBuffer
*
findOrCreatePrimaryCommandBuffer
(
)
;
void
checkCommandBuffers
(
)
;
GrVkSecondaryCommandBuffer
*
findOrCreateSecondaryCommandBuffer
(
)
;
void
recycleSecondaryCommandBuffer
(
GrVkSecondaryCommandBuffer
*
cb
)
;
GrVkDescriptorPool
*
findOrCreateCompatibleDescriptorPool
(
VkDescriptorType
type
uint32_t
count
)
;
GrVkSampler
*
findOrCreateCompatibleSampler
(
const
GrSamplerParams
&
uint32_t
mipLevels
)
;
sk_sp
<
GrVkPipelineState
>
findOrCreateCompatiblePipelineState
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
GrPrimitiveType
const
GrVkRenderPass
&
renderPass
)
;
void
getSamplerDescriptorSetHandle
(
const
GrVkUniformHandler
&
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
void
getSamplerDescriptorSetHandle
(
const
SkTArray
<
uint32_t
>
&
visibilities
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
VkDescriptorSetLayout
getUniformDSLayout
(
)
const
;
VkDescriptorSetLayout
getSamplerDSLayout
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
const
;
const
GrVkDescriptorSet
*
getUniformDescriptorSet
(
)
;
const
GrVkDescriptorSet
*
getSamplerDescriptorSet
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
void
recycleDescriptorSet
(
const
GrVkDescriptorSet
*
descSet
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
const
GrVkResource
*
findOrCreateStandardUniformBufferResource
(
)
;
void
recycleStandardUniformBufferResource
(
const
GrVkResource
*
)
;
void
destroyResources
(
bool
deviceLost
)
;
void
abandonResources
(
)
;
private
:
#
ifdef
SK_DEBUG
#
define
GR_PIPELINE_STATE_CACHE_STATS
#
endif
class
PipelineStateCache
:
public
:
:
SkNoncopyable
{
public
:
PipelineStateCache
(
GrVkGpu
*
gpu
)
;
~
PipelineStateCache
(
)
;
void
abandon
(
)
;
void
release
(
)
;
sk_sp
<
GrVkPipelineState
>
refPipelineState
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
GrPrimitiveType
const
GrVkRenderPass
&
renderPass
)
;
private
:
enum
{
kMaxEntries
=
128
}
;
struct
Entry
;
struct
DescHash
{
uint32_t
operator
(
)
(
const
GrProgramDesc
&
desc
)
const
{
return
SkOpts
:
:
hash_fn
(
desc
.
asKey
(
)
desc
.
keyLength
(
)
0
)
;
}
}
;
SkLRUCache
<
const
GrVkPipelineState
:
:
Desc
std
:
:
unique_ptr
<
Entry
>
DescHash
>
fMap
;
GrVkGpu
*
fGpu
;
#
ifdef
GR_PIPELINE_STATE_CACHE_STATS
int
fTotalRequests
;
int
fCacheMisses
;
#
endif
}
;
class
CompatibleRenderPassSet
{
public
:
CompatibleRenderPassSet
(
const
GrVkGpu
*
gpu
const
GrVkRenderTarget
&
target
)
;
bool
isCompatible
(
const
GrVkRenderTarget
&
target
)
const
;
GrVkRenderPass
*
getCompatibleRenderPass
(
)
const
{
SkASSERT
(
fRenderPasses
[
0
]
)
;
return
fRenderPasses
[
0
]
;
}
GrVkRenderPass
*
getRenderPass
(
const
GrVkGpu
*
gpu
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
void
releaseResources
(
const
GrVkGpu
*
gpu
)
;
void
abandonResources
(
)
;
private
:
SkSTArray
<
4
GrVkRenderPass
*
>
fRenderPasses
;
int
fLastReturnedIndex
;
}
;
GrVkGpu
*
fGpu
;
VkPipelineCache
fPipelineCache
;
SkTArray
<
GrVkCopyPipeline
*
>
fCopyPipelines
;
SkSTArray
<
4
CompatibleRenderPassSet
>
fRenderPassArray
;
SkSTArray
<
4
GrVkPrimaryCommandBuffer
*
true
>
fActiveCommandBuffers
;
SkSTArray
<
4
GrVkPrimaryCommandBuffer
*
true
>
fAvailableCommandBuffers
;
SkSTArray
<
16
GrVkSecondaryCommandBuffer
*
true
>
fAvailableSecondaryCommandBuffers
;
SkSTArray
<
16
const
GrVkResource
*
true
>
fAvailableUniformBufferResources
;
SkTDynamicHash
<
GrVkSampler
uint16_t
>
fSamplers
;
PipelineStateCache
*
fPipelineStateCache
;
SkSTArray
<
4
GrVkDescriptorSetManager
true
>
fDescriptorSetManagers
;
GrVkDescriptorSetManager
:
:
Handle
fUniformDSHandle
;
}
;
#
endif
