#
ifndef
GrVkResourceProvider_DEFINED
#
define
GrVkResourceProvider_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
core
/
SkTInternalLList
.
h
"
#
include
"
src
/
gpu
/
GrResourceHandle
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkDescriptorPool
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkDescriptorSetManager
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkPipelineStateBuilder
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkRenderPass
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkResource
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkSampler
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkSamplerYcbcrConversion
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkUtil
.
h
"
#
include
<
mutex
>
#
include
<
thread
>
class
GrVkCommandPool
;
class
GrVkGpu
;
class
GrVkPipeline
;
class
GrVkPipelineState
;
class
GrVkPrimaryCommandBuffer
;
class
GrVkRenderTarget
;
class
GrVkSecondaryCommandBuffer
;
class
GrVkUniformHandler
;
class
GrVkResourceProvider
{
public
:
GrVkResourceProvider
(
GrVkGpu
*
gpu
)
;
~
GrVkResourceProvider
(
)
;
void
init
(
)
;
GrVkPipeline
*
createPipeline
(
const
GrProgramInfo
&
const
GrStencilSettings
&
stencil
VkPipelineShaderStageCreateInfo
*
shaderStageInfo
int
shaderStageCount
GrPrimitiveType
primitiveType
VkRenderPass
compatibleRenderPass
VkPipelineLayout
layout
)
;
GR_DEFINE_RESOURCE_HANDLE_CLASS
(
CompatibleRPHandle
)
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
const
GrVkRenderTarget
&
target
CompatibleRPHandle
*
compatibleHandle
=
nullptr
)
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
const
CompatibleRPHandle
&
compatibleHandle
)
;
const
GrVkRenderPass
*
findCompatibleExternalRenderPass
(
VkRenderPass
uint32_t
colorAttachmentIndex
)
;
const
GrVkRenderPass
*
findRenderPass
(
const
GrVkRenderTarget
&
target
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
CompatibleRPHandle
*
compatibleHandle
=
nullptr
)
;
const
GrVkRenderPass
*
findRenderPass
(
const
CompatibleRPHandle
&
compatibleHandle
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
GrVkCommandPool
*
findOrCreateCommandPool
(
)
;
void
checkCommandBuffers
(
)
;
void
addFinishedProcToActiveCommandBuffers
(
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
GrVkDescriptorPool
*
findOrCreateCompatibleDescriptorPool
(
VkDescriptorType
type
uint32_t
count
)
;
GrVkSampler
*
findOrCreateCompatibleSampler
(
const
GrSamplerState
&
const
GrVkYcbcrConversionInfo
&
ycbcrInfo
)
;
GrVkSamplerYcbcrConversion
*
findOrCreateCompatibleSamplerYcbcrConversion
(
const
GrVkYcbcrConversionInfo
&
ycbcrInfo
)
;
GrVkPipelineState
*
findOrCreateCompatiblePipelineState
(
GrRenderTarget
*
const
GrProgramInfo
&
GrPrimitiveType
VkRenderPass
compatibleRenderPass
)
;
void
getSamplerDescriptorSetHandle
(
VkDescriptorType
type
const
GrVkUniformHandler
&
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
void
getSamplerDescriptorSetHandle
(
VkDescriptorType
type
const
SkTArray
<
uint32_t
>
&
visibilities
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
VkDescriptorSetLayout
getUniformDSLayout
(
)
const
;
VkDescriptorSetLayout
getSamplerDSLayout
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
const
;
const
GrVkDescriptorSet
*
getUniformDescriptorSet
(
)
;
const
GrVkDescriptorSet
*
getSamplerDescriptorSet
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
void
recycleDescriptorSet
(
const
GrVkDescriptorSet
*
descSet
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
const
GrVkResource
*
findOrCreateStandardUniformBufferResource
(
)
;
void
recycleStandardUniformBufferResource
(
const
GrVkResource
*
)
;
void
storePipelineCacheData
(
)
;
void
destroyResources
(
bool
deviceLost
)
;
void
abandonResources
(
)
;
void
backgroundReset
(
GrVkCommandPool
*
pool
)
;
void
reset
(
GrVkCommandPool
*
pool
)
;
#
if
GR_TEST_UTILS
void
resetShaderCacheForTesting
(
)
const
{
fPipelineStateCache
-
>
release
(
)
;
}
#
endif
private
:
#
ifdef
SK_DEBUG
#
define
GR_PIPELINE_STATE_CACHE_STATS
#
endif
class
PipelineStateCache
:
public
:
:
SkNoncopyable
{
public
:
PipelineStateCache
(
GrVkGpu
*
gpu
)
;
~
PipelineStateCache
(
)
;
void
abandon
(
)
;
void
release
(
)
;
GrVkPipelineState
*
refPipelineState
(
GrRenderTarget
*
const
GrProgramInfo
&
GrPrimitiveType
VkRenderPass
compatibleRenderPass
)
;
private
:
struct
Entry
;
struct
DescHash
{
uint32_t
operator
(
)
(
const
GrProgramDesc
&
desc
)
const
{
return
SkOpts
:
:
hash_fn
(
desc
.
asKey
(
)
desc
.
keyLength
(
)
0
)
;
}
}
;
SkLRUCache
<
const
GrVkPipelineStateBuilder
:
:
Desc
std
:
:
unique_ptr
<
Entry
>
DescHash
>
fMap
;
GrVkGpu
*
fGpu
;
#
ifdef
GR_PIPELINE_STATE_CACHE_STATS
int
fTotalRequests
;
int
fCacheMisses
;
#
endif
}
;
class
CompatibleRenderPassSet
{
public
:
CompatibleRenderPassSet
(
const
GrVkGpu
*
gpu
const
GrVkRenderTarget
&
target
)
;
bool
isCompatible
(
const
GrVkRenderTarget
&
target
)
const
;
GrVkRenderPass
*
getCompatibleRenderPass
(
)
const
{
SkASSERT
(
fRenderPasses
[
0
]
)
;
return
fRenderPasses
[
0
]
;
}
GrVkRenderPass
*
getRenderPass
(
const
GrVkGpu
*
gpu
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
void
releaseResources
(
GrVkGpu
*
gpu
)
;
void
abandonResources
(
)
;
private
:
SkSTArray
<
4
GrVkRenderPass
*
>
fRenderPasses
;
int
fLastReturnedIndex
;
}
;
VkPipelineCache
pipelineCache
(
)
;
GrVkGpu
*
fGpu
;
VkPipelineCache
fPipelineCache
;
SkSTArray
<
4
CompatibleRenderPassSet
>
fRenderPassArray
;
SkTArray
<
const
GrVkRenderPass
*
>
fExternalRenderPasses
;
SkSTArray
<
4
GrVkCommandPool
*
true
>
fActiveCommandPools
;
SkSTArray
<
4
GrVkCommandPool
*
true
>
fAvailableCommandPools
;
SkSTArray
<
16
const
GrVkResource
*
true
>
fAvailableUniformBufferResources
;
SkTDynamicHash
<
GrVkSampler
GrVkSampler
:
:
Key
>
fSamplers
;
SkTDynamicHash
<
GrVkSamplerYcbcrConversion
GrVkSamplerYcbcrConversion
:
:
Key
>
fYcbcrConversions
;
PipelineStateCache
*
fPipelineStateCache
;
SkSTArray
<
4
std
:
:
unique_ptr
<
GrVkDescriptorSetManager
>
>
fDescriptorSetManagers
;
GrVkDescriptorSetManager
:
:
Handle
fUniformDSHandle
;
std
:
:
recursive_mutex
fBackgroundMutex
;
}
;
#
endif
