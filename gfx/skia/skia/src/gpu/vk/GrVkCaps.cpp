#
include
"
GrVkCaps
.
h
"
#
include
"
GrBackendSurface
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
GrVkInterface
.
h
"
#
include
"
GrVkUtil
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
vk
/
GrVkBackendContext
.
h
"
#
include
"
vk
/
GrVkExtensions
.
h
"
GrVkCaps
:
:
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
instanceVersion
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
extensions
)
:
INHERITED
(
contextOptions
)
{
fMipMapSupport
=
true
;
fSRGBSupport
=
true
;
fNPOTTextureTileSupport
=
true
;
fDiscardRenderTargetSupport
=
true
;
fReuseScratchTextures
=
true
;
fGpuTracingSupport
=
false
;
fCompressedTexSubImageSupport
=
true
;
fOversizedStencilSupport
=
false
;
fInstanceAttribSupport
=
true
;
fFenceSyncSupport
=
true
;
fCrossContextTextureSupport
=
true
;
fHalfFloatVertexAttributeSupport
=
true
;
fMapBufferFlags
=
kNone_MapFlags
;
fBufferMapThreshold
=
SK_MaxS32
;
fMaxRenderTargetSize
=
4096
;
fMaxTextureSize
=
4096
;
fDynamicStateArrayGeometryProcessorTextureSupport
=
true
;
fShaderCaps
.
reset
(
new
GrShaderCaps
(
contextOptions
)
)
;
this
-
>
init
(
contextOptions
vkInterface
physDev
features
physicalDeviceVersion
extensions
)
;
}
bool
GrVkCaps
:
:
initDescForDstCopy
(
const
GrRenderTargetProxy
*
src
GrSurfaceDesc
*
desc
GrSurfaceOrigin
*
origin
bool
*
rectsMustMatch
bool
*
disallowSubrect
)
const
{
*
rectsMustMatch
=
false
;
*
disallowSubrect
=
false
;
*
origin
=
src
-
>
origin
(
)
;
desc
-
>
fConfig
=
src
-
>
config
(
)
;
if
(
src
-
>
numColorSamples
(
)
>
1
|
|
src
-
>
asTextureProxy
(
)
)
{
desc
-
>
fFlags
=
kRenderTarget_GrSurfaceFlag
;
}
else
{
desc
-
>
fFlags
=
kNone_GrSurfaceFlags
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyImage
(
GrPixelConfig
dstConfig
int
dstSampleCnt
GrSurfaceOrigin
dstOrigin
GrPixelConfig
srcConfig
int
srcSampleCnt
GrSurfaceOrigin
srcOrigin
)
const
{
if
(
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
&
&
dstSampleCnt
!
=
srcSampleCnt
)
{
return
false
;
}
if
(
srcOrigin
!
=
dstOrigin
|
|
GrBytesPerPixel
(
srcConfig
)
!
=
GrBytesPerPixel
(
dstConfig
)
)
{
return
false
;
}
if
(
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
srcConfig
)
!
=
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
dstConfig
)
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyAsBlit
(
GrPixelConfig
dstConfig
int
dstSampleCnt
bool
dstIsLinear
GrPixelConfig
srcConfig
int
srcSampleCnt
bool
srcIsLinear
)
const
{
if
(
!
this
-
>
configCanBeDstofBlit
(
dstConfig
dstIsLinear
)
|
|
!
this
-
>
configCanBeSrcofBlit
(
srcConfig
srcIsLinear
)
)
{
return
false
;
}
if
(
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
srcConfig
)
!
=
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
dstConfig
)
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyAsResolve
(
GrPixelConfig
dstConfig
int
dstSampleCnt
GrSurfaceOrigin
dstOrigin
GrPixelConfig
srcConfig
int
srcSampleCnt
GrSurfaceOrigin
srcOrigin
)
const
{
if
(
srcSampleCnt
<
=
1
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
)
{
return
false
;
}
if
(
dstConfig
!
=
srcConfig
)
{
return
false
;
}
if
(
srcOrigin
!
=
dstOrigin
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyAsDraw
(
GrPixelConfig
dstConfig
bool
dstIsRenderable
GrPixelConfig
srcConfig
bool
srcIsTextureable
)
const
{
if
(
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
srcConfig
)
!
=
this
-
>
shaderCaps
(
)
-
>
configOutputSwizzle
(
dstConfig
)
)
{
return
false
;
}
if
(
!
dstIsRenderable
|
|
!
srcIsTextureable
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
const
{
GrSurfaceOrigin
dstOrigin
=
dst
-
>
origin
(
)
;
GrSurfaceOrigin
srcOrigin
=
src
-
>
origin
(
)
;
GrPixelConfig
dstConfig
=
dst
-
>
config
(
)
;
GrPixelConfig
srcConfig
=
src
-
>
config
(
)
;
bool
srcIsLinear
=
false
;
bool
dstIsLinear
=
false
;
int
dstSampleCnt
=
0
;
int
srcSampleCnt
=
0
;
if
(
const
GrRenderTargetProxy
*
rtProxy
=
dst
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
dstSampleCnt
=
rtProxy
-
>
numColorSamples
(
)
;
}
if
(
const
GrRenderTargetProxy
*
rtProxy
=
src
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
srcSampleCnt
=
rtProxy
-
>
numColorSamples
(
)
;
}
SkASSERT
(
(
dstSampleCnt
>
0
)
=
=
SkToBool
(
dst
-
>
asRenderTargetProxy
(
)
)
)
;
SkASSERT
(
(
srcSampleCnt
>
0
)
=
=
SkToBool
(
src
-
>
asRenderTargetProxy
(
)
)
)
;
return
this
-
>
canCopyImage
(
dstConfig
dstSampleCnt
dstOrigin
srcConfig
srcSampleCnt
srcOrigin
)
|
|
this
-
>
canCopyAsBlit
(
dstConfig
dstSampleCnt
dstIsLinear
srcConfig
srcSampleCnt
srcIsLinear
)
|
|
this
-
>
canCopyAsResolve
(
dstConfig
dstSampleCnt
dstOrigin
srcConfig
srcSampleCnt
srcOrigin
)
|
|
this
-
>
canCopyAsDraw
(
dstConfig
dstSampleCnt
>
0
srcConfig
SkToBool
(
src
-
>
asTextureProxy
(
)
)
)
;
}
template
<
typename
T
>
T
*
get_extension_feature_struct
(
const
VkPhysicalDeviceFeatures2
&
features
VkStructureType
type
)
{
struct
CommonVulkanHeader
{
VkStructureType
sType
;
void
*
pNext
;
}
;
void
*
pNext
=
features
.
pNext
;
while
(
pNext
)
{
CommonVulkanHeader
*
header
=
static_cast
<
CommonVulkanHeader
*
>
(
pNext
)
;
if
(
header
-
>
sType
=
=
type
)
{
return
static_cast
<
T
*
>
(
pNext
)
;
}
pNext
=
header
-
>
pNext
;
}
return
nullptr
;
}
void
GrVkCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
extensions
)
{
VkPhysicalDeviceProperties
properties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties
(
physDev
&
properties
)
)
;
VkPhysicalDeviceMemoryProperties
memoryProperties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceMemoryProperties
(
physDev
&
memoryProperties
)
)
;
SkASSERT
(
physicalDeviceVersion
<
=
properties
.
apiVersion
)
;
if
(
extensions
.
hasExtension
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
1
)
)
{
fSupportsSwapchain
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
1
)
)
{
fSupportsPhysicalDeviceProperties2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
1
)
)
{
fSupportsMemoryRequirements2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
1
)
)
{
fSupportsBindMemory2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE1_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance1
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE2_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE3_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance3
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
)
)
{
fSupportsDedicatedAllocation
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
1
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
&
&
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
1
)
&
&
this
-
>
supportsDedicatedAllocation
(
)
)
)
{
fSupportsExternalMemory
=
true
;
}
#
ifdef
SK_BUILD_FOR_ANDROID
if
(
extensions
.
hasExtension
(
VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
2
)
&
&
this
-
>
supportsExternalMemory
(
)
&
&
this
-
>
supportsBindMemory2
(
)
)
{
fSupportsAndroidHWBExternalMemory
=
true
;
fSupportsAHardwareBufferImages
=
true
;
}
#
endif
auto
ycbcrFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceSamplerYcbcrConversionFeatures
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
)
;
if
(
ycbcrFeatures
&
&
ycbcrFeatures
-
>
samplerYcbcrConversion
&
&
fSupportsAndroidHWBExternalMemory
&
&
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMaintenance1
(
)
&
&
this
-
>
supportsBindMemory2
(
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
)
)
{
fSupportsYcbcrConversion
=
true
;
}
fYcbcrInfos
.
push_back
(
GrVkYcbcrConversionInfo
(
)
)
;
this
-
>
initGrCaps
(
vkInterface
physDev
properties
memoryProperties
features
extensions
)
;
this
-
>
initShaderCaps
(
properties
features
)
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
#
if
defined
(
SK_CPU_X86
)
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fSRGBSupport
=
false
;
}
#
endif
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fPreferFullscreenClears
=
true
;
}
this
-
>
initConfigTable
(
vkInterface
physDev
properties
)
;
this
-
>
initStencilFormat
(
vkInterface
physDev
)
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
properties
)
;
}
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
this
-
>
applyOptionsOverrides
(
contextOptions
)
;
fShaderCaps
-
>
applyOptionsOverrides
(
contextOptions
)
;
}
void
GrVkCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
properties
)
{
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fMustDoCopiesFromOrigin
=
true
;
}
#
if
defined
(
SK_BUILD_FOR_WIN
)
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
|
|
kIntel_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
elif
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
endif
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fNewCBOnPipelineChange
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fInstanceAttribSupport
=
false
;
fAvoidWritePixelsFastPath
=
true
;
}
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMaxVertexAttributes
=
SkTMin
(
fMaxVertexAttributes
32
)
;
}
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fShaderCaps
-
>
fAtan2ImplementedAsAtanYOverX
=
true
;
}
}
int
get_max_sample_count
(
VkSampleCountFlags
flags
)
{
SkASSERT
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
;
if
(
!
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
)
{
return
0
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
)
{
return
2
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
)
{
return
4
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
)
{
return
8
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_32_BIT
)
)
{
return
16
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_64_BIT
)
)
{
return
32
;
}
return
64
;
}
void
GrVkCaps
:
:
initGrCaps
(
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceMemoryProperties
&
memoryProperties
const
VkPhysicalDeviceFeatures2
&
features
const
GrVkExtensions
&
extensions
)
{
static
const
uint32_t
kMaxVertexAttributes
=
64
;
fMaxVertexAttributes
=
SkTMin
(
properties
.
limits
.
maxVertexInputAttributes
kMaxVertexAttributes
)
;
fMaxRenderTargetSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
fMaxTextureSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
if
(
fDriverBugWorkarounds
.
max_texture_size_limit_4096
)
{
fMaxTextureSize
=
SkTMin
(
fMaxTextureSize
4096
)
;
}
fMaxRenderTargetSize
=
SkTMin
(
fMaxTextureSize
fMaxRenderTargetSize
)
;
fMaxPreferredRenderTargetSize
=
fMaxRenderTargetSize
;
fBufferMapThreshold
=
0
;
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fOversizedStencilSupport
=
true
;
if
(
extensions
.
hasExtension
(
VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
2
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
{
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
blendProps
;
blendProps
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
;
blendProps
.
pNext
=
nullptr
;
VkPhysicalDeviceProperties2
props
;
props
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
;
props
.
pNext
=
&
blendProps
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties2
(
physDev
&
props
)
)
;
if
(
blendProps
.
advancedBlendAllOperations
=
=
VK_TRUE
)
{
fShaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
auto
blendFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
)
;
if
(
blendFeatures
&
&
blendFeatures
-
>
advancedBlendCoherentOperations
=
=
VK_TRUE
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
}
else
{
}
}
}
}
void
GrVkCaps
:
:
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceFeatures2
&
features
)
{
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fVersionDeclString
=
"
#
version
330
\
n
"
;
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
GrPixelConfig
config
=
static_cast
<
GrPixelConfig
>
(
i
)
;
if
(
GrPixelConfigIsAlphaOnly
(
config
)
&
&
kAlpha_8_as_Alpha_GrPixelConfig
!
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RRRR
(
)
;
shaderCaps
-
>
fConfigOutputSwizzle
[
i
]
=
GrSwizzle
:
:
AAAA
(
)
;
}
else
{
if
(
kGray_8_GrPixelConfig
=
=
config
|
|
kGray_8_as_Red_GrPixelConfig
=
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RRRA
(
)
;
}
else
if
(
kRGBA_4444_GrPixelConfig
=
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
BGRA
(
)
;
shaderCaps
-
>
fConfigOutputSwizzle
[
i
]
=
GrSwizzle
:
:
BGRA
(
)
;
}
else
if
(
kRGB_888X_GrPixelConfig
=
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RGB1
(
)
;
}
else
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RGBA
(
)
;
}
}
}
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
shaderCaps
-
>
fFlatInterpolationSupport
=
true
;
shaderCaps
-
>
fPreferFlatInterpolation
=
kQualcomm_VkVendor
!
=
properties
.
vendorID
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fDualSourceBlendingSupport
=
features
.
features
.
dualSrcBlend
;
shaderCaps
-
>
fIntegerSupport
=
true
;
shaderCaps
-
>
fVertexIDSupport
=
true
;
shaderCaps
-
>
fFPManipulationSupport
=
true
;
shaderCaps
-
>
fFloatIs32Bits
=
true
;
shaderCaps
-
>
fHalfIs32Bits
=
false
;
shaderCaps
-
>
fUnsignedSupport
=
true
;
shaderCaps
-
>
fMaxFragmentSamplers
=
SkTMin
(
SkTMin
(
properties
.
limits
.
maxPerStageDescriptorSampledImages
properties
.
limits
.
maxPerStageDescriptorSamplers
)
(
uint32_t
)
INT_MAX
)
;
}
bool
stencil_format_supported
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
return
SkToBool
(
VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
&
props
.
optimalTilingFeatures
)
;
}
void
GrVkCaps
:
:
initStencilFormat
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
)
{
static
const
StencilFormat
gS8
=
{
VK_FORMAT_S8_UINT
8
8
false
}
gD24S8
=
{
VK_FORMAT_D24_UNORM_S8_UINT
8
32
true
}
gD32S8
=
{
VK_FORMAT_D32_SFLOAT_S8_UINT
8
64
true
}
;
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_S8_UINT
)
)
{
fPreferredStencilFormat
=
gS8
;
}
else
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D24_UNORM_S8_UINT
)
)
{
fPreferredStencilFormat
=
gD24S8
;
}
else
{
SkASSERT
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D32_SFLOAT_S8_UINT
)
)
;
fPreferredStencilFormat
=
gD32S8
;
}
}
void
GrVkCaps
:
:
initConfigTable
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
)
{
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
VkFormat
format
;
if
(
GrPixelConfigToVkFormat
(
static_cast
<
GrPixelConfig
>
(
i
)
&
format
)
)
{
if
(
!
GrPixelConfigIsSRGB
(
static_cast
<
GrPixelConfig
>
(
i
)
)
|
|
fSRGBSupport
)
{
bool
disableRendering
=
false
;
if
(
static_cast
<
GrPixelConfig
>
(
i
)
=
=
kRGB_888X_GrPixelConfig
)
{
disableRendering
=
true
;
}
fConfigTable
[
i
]
.
init
(
interface
physDev
properties
format
disableRendering
)
;
}
}
}
}
void
GrVkCaps
:
:
ConfigInfo
:
:
InitConfigFlags
(
VkFormatFeatureFlags
vkFlags
uint16_t
*
flags
bool
disableRendering
)
{
if
(
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
&
vkFlags
)
&
&
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kTextureable_Flag
;
if
(
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
vkFlags
)
&
!
disableRendering
)
{
*
flags
=
*
flags
|
kRenderable_Flag
;
}
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_SRC_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitSrc_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_DST_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitDst_Flag
;
}
}
void
GrVkCaps
:
:
ConfigInfo
:
:
initSampleCounts
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
physProps
VkFormat
format
)
{
VkImageUsageFlags
usage
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
|
VK_IMAGE_USAGE_SAMPLED_BIT
|
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
VkImageFormatProperties
properties
;
GR_VK_CALL
(
interface
GetPhysicalDeviceImageFormatProperties
(
physDev
format
VK_IMAGE_TYPE_2D
VK_IMAGE_TILING_OPTIMAL
usage
0
&
properties
)
)
;
VkSampleCountFlags
flags
=
properties
.
sampleCounts
;
if
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
{
fColorSampleCounts
.
push_back
(
1
)
;
}
if
(
kImagination_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
{
fColorSampleCounts
.
push_back
(
2
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
{
fColorSampleCounts
.
push_back
(
4
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
{
fColorSampleCounts
.
push_back
(
8
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
{
fColorSampleCounts
.
push_back
(
16
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_32_BIT
)
{
fColorSampleCounts
.
push_back
(
32
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_64_BIT
)
{
fColorSampleCounts
.
push_back
(
64
)
;
}
}
void
GrVkCaps
:
:
ConfigInfo
:
:
init
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
VkFormat
format
bool
disableRendering
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
InitConfigFlags
(
props
.
linearTilingFeatures
&
fLinearFlags
disableRendering
)
;
InitConfigFlags
(
props
.
optimalTilingFeatures
&
fOptimalFlags
disableRendering
)
;
if
(
fOptimalFlags
&
kRenderable_Flag
)
{
this
-
>
initSampleCounts
(
interface
physDev
properties
format
)
;
}
}
int
GrVkCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
GrPixelConfig
config
)
const
{
requestedCount
=
SkTMax
(
1
requestedCount
)
;
int
count
=
fConfigTable
[
config
]
.
fColorSampleCounts
.
count
(
)
;
if
(
!
count
)
{
return
0
;
}
if
(
1
=
=
requestedCount
)
{
SkASSERT
(
fConfigTable
[
config
]
.
fColorSampleCounts
.
count
(
)
&
&
fConfigTable
[
config
]
.
fColorSampleCounts
[
0
]
=
=
1
)
;
return
1
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
fConfigTable
[
config
]
.
fColorSampleCounts
[
i
]
>
=
requestedCount
)
{
return
fConfigTable
[
config
]
.
fColorSampleCounts
[
i
]
;
}
}
return
0
;
}
int
GrVkCaps
:
:
maxRenderTargetSampleCount
(
GrPixelConfig
config
)
const
{
const
auto
&
table
=
fConfigTable
[
config
]
.
fColorSampleCounts
;
if
(
!
table
.
count
(
)
)
{
return
0
;
}
return
table
[
table
.
count
(
)
-
1
]
;
}
bool
GrVkCaps
:
:
onSurfaceSupportsWritePixels
(
const
GrSurface
*
surface
)
const
{
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
return
rt
-
>
numColorSamples
(
)
<
=
1
&
&
SkToBool
(
surface
-
>
asTexture
(
)
)
;
}
return
true
;
}
static
GrPixelConfig
validate_image_info
(
VkFormat
format
SkColorType
ct
bool
hasYcbcrConversion
)
{
if
(
format
=
=
VK_FORMAT_UNDEFINED
)
{
if
(
hasYcbcrConversion
)
{
return
kRGBA_8888_GrPixelConfig
;
}
else
{
return
kUnknown_GrPixelConfig
;
}
}
if
(
hasYcbcrConversion
)
{
return
kUnknown_GrPixelConfig
;
}
switch
(
ct
)
{
case
kUnknown_SkColorType
:
break
;
case
kAlpha_8_SkColorType
:
if
(
VK_FORMAT_R8_UNORM
=
=
format
)
{
return
kAlpha_8_as_Red_GrPixelConfig
;
}
break
;
case
kRGB_565_SkColorType
:
if
(
VK_FORMAT_R5G6B5_UNORM_PACK16
=
=
format
)
{
return
kRGB_565_GrPixelConfig
;
}
break
;
case
kARGB_4444_SkColorType
:
if
(
VK_FORMAT_B4G4R4A4_UNORM_PACK16
=
=
format
)
{
return
kRGBA_4444_GrPixelConfig
;
}
break
;
case
kRGBA_8888_SkColorType
:
if
(
VK_FORMAT_R8G8B8A8_UNORM
=
=
format
)
{
return
kRGBA_8888_GrPixelConfig
;
}
else
if
(
VK_FORMAT_R8G8B8A8_SRGB
=
=
format
)
{
return
kSRGBA_8888_GrPixelConfig
;
}
break
;
case
kRGB_888x_SkColorType
:
if
(
VK_FORMAT_R8G8B8_UNORM
=
=
format
)
{
return
kRGB_888_GrPixelConfig
;
}
if
(
VK_FORMAT_R8G8B8A8_UNORM
=
=
format
)
{
return
kRGB_888X_GrPixelConfig
;
}
break
;
case
kBGRA_8888_SkColorType
:
if
(
VK_FORMAT_B8G8R8A8_UNORM
=
=
format
)
{
return
kBGRA_8888_GrPixelConfig
;
}
else
if
(
VK_FORMAT_B8G8R8A8_SRGB
=
=
format
)
{
return
kSBGRA_8888_GrPixelConfig
;
}
break
;
case
kRGBA_1010102_SkColorType
:
if
(
VK_FORMAT_A2B10G10R10_UNORM_PACK32
=
=
format
)
{
return
kRGBA_1010102_GrPixelConfig
;
}
break
;
case
kRGB_101010x_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kGray_8_SkColorType
:
if
(
VK_FORMAT_R8_UNORM
=
=
format
)
{
return
kGray_8_as_Red_GrPixelConfig
;
}
break
;
case
kRGBA_F16Norm_SkColorType
:
if
(
VK_FORMAT_R16G16B16A16_SFLOAT
=
=
format
)
{
return
kRGBA_half_GrPixelConfig
;
}
break
;
case
kRGBA_F16_SkColorType
:
if
(
VK_FORMAT_R16G16B16A16_SFLOAT
=
=
format
)
{
return
kRGBA_half_GrPixelConfig
;
}
break
;
case
kRGBA_F32_SkColorType
:
if
(
VK_FORMAT_R32G32B32A32_SFLOAT
=
=
format
)
{
return
kRGBA_float_GrPixelConfig
;
}
break
;
}
return
kUnknown_GrPixelConfig
;
}
GrPixelConfig
GrVkCaps
:
:
validateBackendRenderTarget
(
const
GrBackendRenderTarget
&
rt
SkColorType
ct
)
const
{
GrVkImageInfo
imageInfo
;
if
(
!
rt
.
getVkImageInfo
(
&
imageInfo
)
)
{
return
kUnknown_GrPixelConfig
;
}
return
validate_image_info
(
imageInfo
.
fFormat
ct
imageInfo
.
fYcbcrConversionInfo
.
isValid
(
)
)
;
}
GrPixelConfig
GrVkCaps
:
:
getConfigFromBackendFormat
(
const
GrBackendFormat
&
format
SkColorType
ct
)
const
{
const
VkFormat
*
vkFormat
=
format
.
getVkFormat
(
)
;
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
if
(
!
vkFormat
|
|
!
ycbcrInfo
)
{
return
kUnknown_GrPixelConfig
;
}
return
validate_image_info
(
*
vkFormat
ct
ycbcrInfo
-
>
isValid
(
)
)
;
}
static
GrPixelConfig
get_yuva_config
(
VkFormat
vkFormat
)
{
switch
(
vkFormat
)
{
case
VK_FORMAT_R8_UNORM
:
return
kAlpha_8_as_Red_GrPixelConfig
;
case
VK_FORMAT_R8G8B8A8_UNORM
:
return
kRGBA_8888_GrPixelConfig
;
case
VK_FORMAT_R8G8B8_UNORM
:
return
kRGB_888_GrPixelConfig
;
case
VK_FORMAT_R8G8_UNORM
:
return
kRG_88_GrPixelConfig
;
case
VK_FORMAT_B8G8R8A8_UNORM
:
return
kBGRA_8888_GrPixelConfig
;
default
:
return
kUnknown_GrPixelConfig
;
}
}
GrPixelConfig
GrVkCaps
:
:
getYUVAConfigFromBackendFormat
(
const
GrBackendFormat
&
format
)
const
{
const
VkFormat
*
vkFormat
=
format
.
getVkFormat
(
)
;
if
(
!
vkFormat
)
{
return
kUnknown_GrPixelConfig
;
}
return
get_yuva_config
(
*
vkFormat
)
;
}
GrBackendFormat
GrVkCaps
:
:
getBackendFormatFromGrColorType
(
GrColorType
ct
GrSRGBEncoded
srgbEncoded
)
const
{
GrPixelConfig
config
=
GrColorTypeToPixelConfig
(
ct
srgbEncoded
)
;
if
(
config
=
=
kUnknown_GrPixelConfig
)
{
return
GrBackendFormat
(
)
;
}
VkFormat
format
;
if
(
!
GrPixelConfigToVkFormat
(
config
&
format
)
)
{
return
GrBackendFormat
(
)
;
}
return
GrBackendFormat
:
:
MakeVk
(
format
)
;
}
