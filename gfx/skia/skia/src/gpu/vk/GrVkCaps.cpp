#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkBackendContext
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkExtensions
.
h
"
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
GrUtil
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkCaps
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkInterface
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkTexture
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkUniformHandler
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkUtil
.
h
"
#
ifdef
SK_BUILD_FOR_ANDROID
#
include
<
sys
/
system_properties
.
h
>
#
endif
GrVkCaps
:
:
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
instanceVersion
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
extensions
GrProtected
isProtected
)
:
INHERITED
(
contextOptions
)
{
fMipMapSupport
=
true
;
fNPOTTextureTileSupport
=
true
;
fReuseScratchTextures
=
true
;
fGpuTracingSupport
=
false
;
fOversizedStencilSupport
=
false
;
fInstanceAttribSupport
=
true
;
fSemaphoreSupport
=
true
;
fFenceSyncSupport
=
true
;
fCrossContextTextureSupport
=
true
;
fHalfFloatVertexAttributeSupport
=
true
;
fReadPixelsRowBytesSupport
=
true
;
fWritePixelsRowBytesSupport
=
true
;
fTransferBufferSupport
=
true
;
fMaxRenderTargetSize
=
4096
;
fMaxTextureSize
=
4096
;
fDynamicStateArrayGeometryProcessorTextureSupport
=
true
;
fShaderCaps
.
reset
(
new
GrShaderCaps
(
contextOptions
)
)
;
this
-
>
init
(
contextOptions
vkInterface
physDev
features
physicalDeviceVersion
extensions
isProtected
)
;
}
namespace
{
enum
class
FormatCompatibilityClass
{
k8_1_1
k16_2_1
k24_3_1
k32_4_1
k64_8_1
kETC2_RGB_8_16
}
;
}
static
FormatCompatibilityClass
format_compatibility_class
(
VkFormat
format
)
{
switch
(
format
)
{
case
VK_FORMAT_B8G8R8A8_UNORM
:
case
VK_FORMAT_R8G8B8A8_UNORM
:
case
VK_FORMAT_A2B10G10R10_UNORM_PACK32
:
case
VK_FORMAT_R8G8B8A8_SRGB
:
case
VK_FORMAT_R16G16_UNORM
:
case
VK_FORMAT_R16G16_SFLOAT
:
return
FormatCompatibilityClass
:
:
k32_4_1
;
case
VK_FORMAT_R8_UNORM
:
return
FormatCompatibilityClass
:
:
k8_1_1
;
case
VK_FORMAT_R5G6B5_UNORM_PACK16
:
case
VK_FORMAT_R16_SFLOAT
:
case
VK_FORMAT_R8G8_UNORM
:
case
VK_FORMAT_B4G4R4A4_UNORM_PACK16
:
case
VK_FORMAT_R4G4B4A4_UNORM_PACK16
:
case
VK_FORMAT_R16_UNORM
:
return
FormatCompatibilityClass
:
:
k16_2_1
;
case
VK_FORMAT_R16G16B16A16_SFLOAT
:
case
VK_FORMAT_R16G16B16A16_UNORM
:
return
FormatCompatibilityClass
:
:
k64_8_1
;
case
VK_FORMAT_R8G8B8_UNORM
:
return
FormatCompatibilityClass
:
:
k24_3_1
;
case
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
:
return
FormatCompatibilityClass
:
:
kETC2_RGB_8_16
;
default
:
SK_ABORT
(
"
Unsupported
VkFormat
"
)
;
}
}
bool
GrVkCaps
:
:
canCopyImage
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcHasYcbcr
)
const
{
if
(
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
&
&
dstSampleCnt
!
=
srcSampleCnt
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
format_compatibility_class
(
srcFormat
)
=
=
format_compatibility_class
(
dstFormat
)
;
}
bool
GrVkCaps
:
:
canCopyAsBlit
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstIsLinear
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcIsLinear
bool
srcHasYcbcr
)
const
{
if
(
!
this
-
>
formatCanBeDstofBlit
(
dstFormat
dstIsLinear
)
|
|
!
this
-
>
formatCanBeSrcofBlit
(
srcFormat
srcIsLinear
)
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyAsResolve
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcHasYcbcr
)
const
{
if
(
srcSampleCnt
<
=
1
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
)
{
return
false
;
}
if
(
srcFormat
!
=
dstFormat
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
const
{
if
(
src
-
>
isProtected
(
)
&
&
!
dst
-
>
isProtected
(
)
)
{
return
false
;
}
bool
srcIsLinear
=
false
;
bool
dstIsLinear
=
false
;
int
dstSampleCnt
=
0
;
int
srcSampleCnt
=
0
;
if
(
const
GrRenderTargetProxy
*
rtProxy
=
dst
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
dstSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
if
(
const
GrRenderTargetProxy
*
rtProxy
=
src
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
srcSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
SkASSERT
(
(
dstSampleCnt
>
0
)
=
=
SkToBool
(
dst
-
>
asRenderTargetProxy
(
)
)
)
;
SkASSERT
(
(
srcSampleCnt
>
0
)
=
=
SkToBool
(
src
-
>
asRenderTargetProxy
(
)
)
)
;
bool
dstHasYcbcr
=
false
;
if
(
auto
ycbcr
=
dst
-
>
backendFormat
(
)
.
getVkYcbcrConversionInfo
(
)
)
{
if
(
ycbcr
-
>
isValid
(
)
)
{
dstHasYcbcr
=
true
;
}
}
bool
srcHasYcbcr
=
false
;
if
(
auto
ycbcr
=
src
-
>
backendFormat
(
)
.
getVkYcbcrConversionInfo
(
)
)
{
if
(
ycbcr
-
>
isValid
(
)
)
{
srcHasYcbcr
=
true
;
}
}
VkFormat
dstFormat
srcFormat
;
SkAssertResult
(
dst
-
>
backendFormat
(
)
.
asVkFormat
(
&
dstFormat
)
)
;
SkAssertResult
(
src
-
>
backendFormat
(
)
.
asVkFormat
(
&
srcFormat
)
)
;
return
this
-
>
canCopyImage
(
dstFormat
dstSampleCnt
dstHasYcbcr
srcFormat
srcSampleCnt
srcHasYcbcr
)
|
|
this
-
>
canCopyAsBlit
(
dstFormat
dstSampleCnt
dstIsLinear
dstHasYcbcr
srcFormat
srcSampleCnt
srcIsLinear
srcHasYcbcr
)
|
|
this
-
>
canCopyAsResolve
(
dstFormat
dstSampleCnt
dstHasYcbcr
srcFormat
srcSampleCnt
srcHasYcbcr
)
;
}
template
<
typename
T
>
T
*
get_extension_feature_struct
(
const
VkPhysicalDeviceFeatures2
&
features
VkStructureType
type
)
{
struct
CommonVulkanHeader
{
VkStructureType
sType
;
void
*
pNext
;
}
;
void
*
pNext
=
features
.
pNext
;
while
(
pNext
)
{
CommonVulkanHeader
*
header
=
static_cast
<
CommonVulkanHeader
*
>
(
pNext
)
;
if
(
header
-
>
sType
=
=
type
)
{
return
static_cast
<
T
*
>
(
pNext
)
;
}
pNext
=
header
-
>
pNext
;
}
return
nullptr
;
}
void
GrVkCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
extensions
GrProtected
isProtected
)
{
VkPhysicalDeviceProperties
properties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties
(
physDev
&
properties
)
)
;
VkPhysicalDeviceMemoryProperties
memoryProperties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceMemoryProperties
(
physDev
&
memoryProperties
)
)
;
SkASSERT
(
physicalDeviceVersion
<
=
properties
.
apiVersion
)
;
if
(
extensions
.
hasExtension
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
1
)
)
{
fSupportsSwapchain
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
1
)
)
{
fSupportsPhysicalDeviceProperties2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
1
)
)
{
fSupportsMemoryRequirements2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
1
)
)
{
fSupportsBindMemory2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE1_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance1
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE2_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE3_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance3
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
)
)
{
fSupportsDedicatedAllocation
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
1
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
&
&
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
1
)
&
&
this
-
>
supportsDedicatedAllocation
(
)
)
)
{
fSupportsExternalMemory
=
true
;
}
#
ifdef
SK_BUILD_FOR_ANDROID
if
(
extensions
.
hasExtension
(
VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
2
)
&
&
this
-
>
supportsExternalMemory
(
)
&
&
this
-
>
supportsBindMemory2
(
)
)
{
fSupportsAndroidHWBExternalMemory
=
true
;
fSupportsAHardwareBufferImages
=
true
;
}
#
endif
auto
ycbcrFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceSamplerYcbcrConversionFeatures
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
)
;
if
(
ycbcrFeatures
&
&
ycbcrFeatures
-
>
samplerYcbcrConversion
&
&
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMaintenance1
(
)
&
&
this
-
>
supportsBindMemory2
(
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
)
)
{
fSupportsYcbcrConversion
=
true
;
}
fYcbcrInfos
.
push_back
(
GrVkYcbcrConversionInfo
(
)
)
;
if
(
(
isProtected
=
=
GrProtected
:
:
kYes
)
&
&
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
)
)
{
fSupportsProtectedMemory
=
true
;
fAvoidUpdateBuffers
=
true
;
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
this
-
>
initGrCaps
(
vkInterface
physDev
properties
memoryProperties
features
extensions
)
;
this
-
>
initShaderCaps
(
properties
features
)
;
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fPreferFullscreenClears
=
true
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
|
|
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fBufferMapThreshold
=
SK_MaxS32
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fAvoidUpdateBuffers
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fPreferTrianglesOverSampleMask
=
true
;
}
this
-
>
initFormatTable
(
vkInterface
physDev
properties
)
;
this
-
>
initStencilFormat
(
vkInterface
physDev
)
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
properties
)
;
}
this
-
>
applyOptionsOverrides
(
contextOptions
)
;
fShaderCaps
-
>
applyOptionsOverrides
(
contextOptions
)
;
}
void
GrVkCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
properties
)
{
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fMustDoCopiesFromOrigin
=
true
;
fTransferBufferSupport
=
false
;
}
#
if
defined
(
SK_BUILD_FOR_WIN
)
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
|
|
kIntel_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
elif
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
endif
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
fSupportsProtectedMemory
&
&
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
)
{
char
androidAPIVersion
[
PROP_VALUE_MAX
]
;
int
strLength
=
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
androidAPIVersion
)
;
if
(
strLength
=
=
0
|
|
atoi
(
androidAPIVersion
)
<
=
28
)
{
fSupportsProtectedMemory
=
false
;
}
}
#
endif
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fPreferPrimaryOverSecondaryCommandBuffers
=
false
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
|
|
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fInstanceAttribSupport
=
false
;
fAvoidWritePixelsFastPath
=
true
;
}
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMaxVertexAttributes
=
SkTMin
(
fMaxVertexAttributes
32
)
;
}
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fShaderCaps
-
>
fAtan2ImplementedAsAtanYOverX
=
true
;
}
}
int
get_max_sample_count
(
VkSampleCountFlags
flags
)
{
SkASSERT
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
;
if
(
!
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
)
{
return
0
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
)
{
return
2
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
)
{
return
4
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
)
{
return
8
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_32_BIT
)
)
{
return
16
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_64_BIT
)
)
{
return
32
;
}
return
64
;
}
void
GrVkCaps
:
:
initGrCaps
(
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceMemoryProperties
&
memoryProperties
const
VkPhysicalDeviceFeatures2
&
features
const
GrVkExtensions
&
extensions
)
{
static
const
uint32_t
kMaxVertexAttributes
=
64
;
fMaxVertexAttributes
=
SkTMin
(
properties
.
limits
.
maxVertexInputAttributes
kMaxVertexAttributes
)
;
fMaxRenderTargetSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
fMaxTextureSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
if
(
fDriverBugWorkarounds
.
max_texture_size_limit_4096
)
{
fMaxTextureSize
=
SkTMin
(
fMaxTextureSize
4096
)
;
}
fMaxRenderTargetSize
=
SkTMin
(
fMaxTextureSize
fMaxRenderTargetSize
)
;
fMaxPreferredRenderTargetSize
=
fMaxRenderTargetSize
;
fBufferMapThreshold
=
0
;
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
|
kAsyncRead_MapFlag
;
fOversizedStencilSupport
=
true
;
if
(
extensions
.
hasExtension
(
VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
2
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
{
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
blendProps
;
blendProps
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
;
blendProps
.
pNext
=
nullptr
;
VkPhysicalDeviceProperties2
props
;
props
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
;
props
.
pNext
=
&
blendProps
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties2
(
physDev
&
props
)
)
;
if
(
blendProps
.
advancedBlendAllOperations
=
=
VK_TRUE
)
{
fShaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
auto
blendFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
)
;
if
(
blendFeatures
&
&
blendFeatures
-
>
advancedBlendCoherentOperations
=
=
VK_TRUE
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
}
else
{
}
}
}
}
void
GrVkCaps
:
:
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceFeatures2
&
features
)
{
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fVersionDeclString
=
"
#
version
330
\
n
"
;
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
shaderCaps
-
>
fFlatInterpolationSupport
=
true
;
shaderCaps
-
>
fPreferFlatInterpolation
=
kQualcomm_VkVendor
!
=
properties
.
vendorID
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fDualSourceBlendingSupport
=
features
.
features
.
dualSrcBlend
;
shaderCaps
-
>
fIntegerSupport
=
true
;
shaderCaps
-
>
fVertexIDSupport
=
true
;
shaderCaps
-
>
fFPManipulationSupport
=
true
;
shaderCaps
-
>
fFloatIs32Bits
=
true
;
shaderCaps
-
>
fHalfIs32Bits
=
false
;
shaderCaps
-
>
fMaxFragmentSamplers
=
SkTMin
(
SkTMin
(
properties
.
limits
.
maxPerStageDescriptorSampledImages
properties
.
limits
.
maxPerStageDescriptorSamplers
)
(
uint32_t
)
INT_MAX
)
;
}
bool
stencil_format_supported
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
return
SkToBool
(
VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
&
props
.
optimalTilingFeatures
)
;
}
void
GrVkCaps
:
:
initStencilFormat
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
)
{
static
const
StencilFormat
gS8
=
{
VK_FORMAT_S8_UINT
8
8
false
}
gD24S8
=
{
VK_FORMAT_D24_UNORM_S8_UINT
8
32
true
}
gD32S8
=
{
VK_FORMAT_D32_SFLOAT_S8_UINT
8
64
true
}
;
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_S8_UINT
)
)
{
fPreferredStencilFormat
=
gS8
;
}
else
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D24_UNORM_S8_UINT
)
)
{
fPreferredStencilFormat
=
gD24S8
;
}
else
{
SkASSERT
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D32_SFLOAT_S8_UINT
)
)
;
fPreferredStencilFormat
=
gD32S8
;
}
}
static
bool
format_is_srgb
(
VkFormat
format
)
{
SkASSERT
(
GrVkFormatIsSupported
(
format
)
)
;
switch
(
format
)
{
case
VK_FORMAT_R8G8B8A8_SRGB
:
return
true
;
default
:
return
false
;
}
}
static
constexpr
VkFormat
kVkFormats
[
]
=
{
VK_FORMAT_R8G8B8A8_UNORM
VK_FORMAT_R8_UNORM
VK_FORMAT_B8G8R8A8_UNORM
VK_FORMAT_R5G6B5_UNORM_PACK16
VK_FORMAT_R16G16B16A16_SFLOAT
VK_FORMAT_R16_SFLOAT
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8_UNORM
VK_FORMAT_A2B10G10R10_UNORM_PACK32
VK_FORMAT_B4G4R4A4_UNORM_PACK16
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_R8G8B8A8_SRGB
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
VK_FORMAT_R16_UNORM
VK_FORMAT_R16G16_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
VK_FORMAT_R16G16B16A16_UNORM
VK_FORMAT_R16G16_SFLOAT
}
;
void
GrVkCaps
:
:
setColorType
(
GrColorType
colorType
std
:
:
initializer_list
<
VkFormat
>
formats
)
{
#
ifdef
SK_DEBUG
for
(
size_t
i
=
0
;
i
<
kNumVkFormats
;
+
+
i
)
{
const
auto
&
formatInfo
=
fFormatTable
[
i
]
;
for
(
int
j
=
0
;
j
<
formatInfo
.
fColorTypeInfoCount
;
+
+
j
)
{
const
auto
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
j
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
&
&
!
SkToBool
(
ctInfo
.
fFlags
&
ColorTypeInfo
:
:
kWrappedOnly_Flag
)
)
{
bool
found
=
false
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
if
(
kVkFormats
[
i
]
=
=
*
it
)
{
found
=
true
;
}
}
SkASSERT
(
found
)
;
}
}
}
#
endif
int
idx
=
static_cast
<
int
>
(
colorType
)
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
*
it
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
fColorTypeToFormatTable
[
idx
]
=
*
it
;
return
;
}
}
}
}
const
GrVkCaps
:
:
FormatInfo
&
GrVkCaps
:
:
getFormatInfo
(
VkFormat
format
)
const
{
GrVkCaps
*
nonConstThis
=
const_cast
<
GrVkCaps
*
>
(
this
)
;
return
nonConstThis
-
>
getFormatInfo
(
format
)
;
}
GrVkCaps
:
:
FormatInfo
&
GrVkCaps
:
:
getFormatInfo
(
VkFormat
format
)
{
static_assert
(
SK_ARRAY_COUNT
(
kVkFormats
)
=
=
GrVkCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
kVkFormats
)
;
+
+
i
)
{
if
(
kVkFormats
[
i
]
=
=
format
)
{
return
fFormatTable
[
i
]
;
}
}
static
FormatInfo
kInvalidFormat
;
return
kInvalidFormat
;
}
void
GrVkCaps
:
:
initFormatTable
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
)
{
static_assert
(
SK_ARRAY_COUNT
(
kVkFormats
)
=
=
GrVkCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
std
:
:
fill_n
(
fColorTypeToFormatTable
kGrColorTypeCnt
VK_FORMAT_UNDEFINED
)
;
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_8888
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
:
:
RGB1
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
1
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_8
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
:
:
RRRR
(
)
;
ctInfo
.
fOutputSwizzle
=
GrSwizzle
:
:
AAAA
(
)
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kGray_8
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
(
"
rrr1
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B8G8R8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kBGRA_8888
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R5G6B5_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kBGR_565
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
8
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_F16_Clamped
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
:
:
RRRR
(
)
;
ctInfo
.
fOutputSwizzle
=
GrSwizzle
:
:
AAAA
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
3
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_88
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_A2B10G10R10_UNORM_PACK32
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_1010102
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B4G4R4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kABGR_4444
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
:
:
BGRA
(
)
;
ctInfo
.
fOutputSwizzle
=
GrSwizzle
:
:
BGRA
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R4G4B4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kABGR_4444
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_SRGB
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_8888_SRGB
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
2
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fTextureSwizzle
=
GrSwizzle
:
:
RRRR
(
)
;
ctInfo
.
fOutputSwizzle
=
GrSwizzle
:
:
AAAA
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_1616
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
8
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_16161616
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
4
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
fBytesPerPixel
=
3
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
interface
physDev
properties
format
)
;
}
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kWrappedOnly_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
fBytesPerPixel
=
3
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
interface
physDev
properties
format
)
;
}
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
.
reset
(
new
ColorTypeInfo
[
info
.
fColorTypeInfoCount
]
(
)
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kWrappedOnly_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
info
.
fBytesPerPixel
=
0
;
}
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_8
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kBGR_565
{
VK_FORMAT_R5G6B5_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kABGR_4444
{
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_B4G4R4A4_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_8888
{
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_8888_SRGB
{
VK_FORMAT_R8G8B8A8_SRGB
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGB_888x
{
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_88
{
VK_FORMAT_R8G8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kBGRA_8888
{
VK_FORMAT_B8G8R8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_1010102
{
VK_FORMAT_A2B10G10R10_UNORM_PACK32
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kGray_8
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_F16
{
VK_FORMAT_R16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_F16
{
VK_FORMAT_R16G16B16A16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_F16_Clamped
{
VK_FORMAT_R16G16B16A16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_16
{
VK_FORMAT_R16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_1616
{
VK_FORMAT_R16G16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_16161616
{
VK_FORMAT_R16G16B16A16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_F16
{
VK_FORMAT_R16G16_SFLOAT
}
)
;
}
void
GrVkCaps
:
:
FormatInfo
:
:
InitFormatFlags
(
VkFormatFeatureFlags
vkFlags
uint16_t
*
flags
)
{
if
(
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
&
vkFlags
)
&
&
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kTexturable_Flag
;
if
(
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kRenderable_Flag
;
}
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_SRC_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitSrc_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_DST_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitDst_Flag
;
}
}
void
GrVkCaps
:
:
FormatInfo
:
:
initSampleCounts
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
physProps
VkFormat
format
)
{
VkImageUsageFlags
usage
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
|
VK_IMAGE_USAGE_SAMPLED_BIT
|
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
VkImageFormatProperties
properties
;
GR_VK_CALL
(
interface
GetPhysicalDeviceImageFormatProperties
(
physDev
format
VK_IMAGE_TYPE_2D
VK_IMAGE_TILING_OPTIMAL
usage
0
&
properties
)
)
;
VkSampleCountFlags
flags
=
properties
.
sampleCounts
;
if
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
{
fColorSampleCounts
.
push_back
(
1
)
;
}
if
(
kImagination_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
kIntel_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
{
fColorSampleCounts
.
push_back
(
2
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
{
fColorSampleCounts
.
push_back
(
4
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
{
fColorSampleCounts
.
push_back
(
8
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
{
fColorSampleCounts
.
push_back
(
16
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_32_BIT
)
{
fColorSampleCounts
.
push_back
(
32
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_64_BIT
)
{
fColorSampleCounts
.
push_back
(
64
)
;
}
}
void
GrVkCaps
:
:
FormatInfo
:
:
init
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
InitFormatFlags
(
props
.
linearTilingFeatures
&
fLinearFlags
)
;
InitFormatFlags
(
props
.
optimalTilingFeatures
&
fOptimalFlags
)
;
if
(
fOptimalFlags
&
kRenderable_Flag
)
{
this
-
>
initSampleCounts
(
interface
physDev
properties
format
)
;
}
}
static
bool
backend_format_is_external
(
const
GrBackendFormat
&
format
)
{
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
if
(
ycbcrInfo
-
>
isValid
(
)
&
&
ycbcrInfo
-
>
fExternalFormat
!
=
0
)
{
#
ifdef
SK_DEBUG
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
SkASSERT
(
vkFormat
=
=
VK_NULL_HANDLE
)
;
#
endif
return
true
;
}
return
false
;
}
bool
GrVkCaps
:
:
isFormatSRGB
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
if
(
backend_format_is_external
(
format
)
)
{
return
false
;
}
return
format_is_srgb
(
vkFormat
)
;
}
bool
GrVkCaps
:
:
isFormatCompressed
(
const
GrBackendFormat
&
format
SkImage
:
:
CompressionType
*
compressionType
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
SkImage
:
:
CompressionType
dummyType
;
SkImage
:
:
CompressionType
*
compressionTypePtr
=
compressionType
?
compressionType
:
&
dummyType
;
switch
(
vkFormat
)
{
case
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
:
*
compressionTypePtr
=
SkImage
:
:
kETC1_CompressionType
;
return
true
;
default
:
return
false
;
}
}
bool
GrVkCaps
:
:
isFormatTexturableAndUploadable
(
GrColorType
ct
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
uint32_t
ctFlags
=
this
-
>
getFormatInfo
(
vkFormat
)
.
colorTypeFlags
(
ct
)
;
return
this
-
>
isVkFormatTexturable
(
vkFormat
)
&
&
SkToBool
(
ctFlags
&
ColorTypeInfo
:
:
kUploadData_Flag
)
;
}
bool
GrVkCaps
:
:
isFormatTexturable
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
if
(
backend_format_is_external
(
format
)
)
{
return
true
;
}
return
this
-
>
isVkFormatTexturable
(
vkFormat
)
;
}
bool
GrVkCaps
:
:
isVkFormatTexturable
(
VkFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
return
SkToBool
(
FormatInfo
:
:
kTexturable_Flag
&
info
.
fOptimalFlags
)
;
}
bool
GrVkCaps
:
:
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
if
(
!
this
-
>
isFormatRenderable
(
format
sampleCount
)
)
{
return
false
;
}
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
if
(
!
SkToBool
(
info
.
colorTypeFlags
(
ct
)
&
ColorTypeInfo
:
:
kRenderable_Flag
)
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
return
this
-
>
isFormatRenderable
(
vkFormat
sampleCount
)
;
}
bool
GrVkCaps
:
:
isFormatRenderable
(
VkFormat
format
int
sampleCount
)
const
{
return
sampleCount
<
=
this
-
>
maxRenderTargetSampleCount
(
format
)
;
}
int
GrVkCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
0
;
}
return
this
-
>
getRenderTargetSampleCount
(
requestedCount
vkFormat
)
;
}
int
GrVkCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
VkFormat
format
)
const
{
requestedCount
=
SkTMax
(
1
requestedCount
)
;
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
int
count
=
info
.
fColorSampleCounts
.
count
(
)
;
if
(
!
count
)
{
return
0
;
}
if
(
1
=
=
requestedCount
)
{
SkASSERT
(
info
.
fColorSampleCounts
.
count
(
)
&
&
info
.
fColorSampleCounts
[
0
]
=
=
1
)
;
return
1
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
info
.
fColorSampleCounts
[
i
]
>
=
requestedCount
)
{
return
info
.
fColorSampleCounts
[
i
]
;
}
}
return
0
;
}
int
GrVkCaps
:
:
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
0
;
}
return
this
-
>
maxRenderTargetSampleCount
(
vkFormat
)
;
}
int
GrVkCaps
:
:
maxRenderTargetSampleCount
(
VkFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
auto
&
table
=
info
.
fColorSampleCounts
;
if
(
!
table
.
count
(
)
)
{
return
0
;
}
return
table
[
table
.
count
(
)
-
1
]
;
}
size_t
GrVkCaps
:
:
bytesPerPixel
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
0
;
}
return
this
-
>
bytesPerPixel
(
vkFormat
)
;
}
size_t
GrVkCaps
:
:
bytesPerPixel
(
VkFormat
format
)
const
{
return
this
-
>
getFormatInfo
(
format
)
.
fBytesPerPixel
;
}
static
inline
size_t
align_to_4
(
size_t
v
)
{
switch
(
v
&
0b11
)
{
case
0
:
return
v
;
case
2
:
return
2
*
v
;
default
:
return
4
*
v
;
}
}
GrCaps
:
:
SupportedWrite
GrVkCaps
:
:
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
{
VkFormat
vkFormat
;
if
(
!
surfaceFormat
.
asVkFormat
(
&
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
if
(
backend_format_is_external
(
surfaceFormat
)
|
|
GrVkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
size_t
offsetAlignment
=
align_to_4
(
this
-
>
bytesPerPixel
(
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
surfaceColorType
)
{
return
{
surfaceColorType
offsetAlignment
}
;
}
}
return
{
GrColorType
:
:
kUnknown
0
}
;
}
GrCaps
:
:
SurfaceReadPixelsSupport
GrVkCaps
:
:
surfaceSupportsReadPixels
(
const
GrSurface
*
surface
)
const
{
if
(
surface
-
>
isProtected
(
)
)
{
return
SurfaceReadPixelsSupport
:
:
kUnsupported
;
}
if
(
auto
tex
=
static_cast
<
const
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
if
(
tex
-
>
ycbcrConversionInfo
(
)
.
isValid
(
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
SkImage
:
:
CompressionType
compressionType
;
if
(
GrVkFormatToCompressionType
(
tex
-
>
imageFormat
(
)
&
compressionType
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
}
return
SurfaceReadPixelsSupport
:
:
kSupported
;
}
bool
GrVkCaps
:
:
onSurfaceSupportsWritePixels
(
const
GrSurface
*
surface
)
const
{
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
return
rt
-
>
numSamples
(
)
<
=
1
&
&
SkToBool
(
surface
-
>
asTexture
(
)
)
;
}
if
(
auto
tex
=
static_cast
<
const
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
if
(
tex
-
>
ycbcrConversionInfo
(
)
.
isValid
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
GrVkCaps
:
:
onAreColorTypeAndFormatCompatible
(
GrColorType
ct
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
if
(
ycbcrInfo
-
>
isValid
(
)
&
&
!
GrVkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
if
(
VK_FORMAT_UNDEFINED
=
=
vkFormat
&
&
ycbcrInfo
-
>
fExternalFormat
!
=
0
)
{
return
true
;
}
return
false
;
}
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
ct
)
{
return
true
;
}
}
return
false
;
}
static
GrPixelConfig
validate_image_info
(
VkFormat
format
GrColorType
ct
bool
hasYcbcrConversion
)
{
if
(
hasYcbcrConversion
)
{
if
(
GrVkFormatNeedsYcbcrSampler
(
format
)
)
{
return
kRGB_888X_GrPixelConfig
;
}
if
(
VK_FORMAT_UNDEFINED
=
=
format
)
{
return
kRGBA_8888_GrPixelConfig
;
}
return
kUnknown_GrPixelConfig
;
}
if
(
VK_FORMAT_UNDEFINED
=
=
format
)
{
return
kUnknown_GrPixelConfig
;
}
switch
(
ct
)
{
case
GrColorType
:
:
kUnknown
:
break
;
case
GrColorType
:
:
kAlpha_8
:
if
(
VK_FORMAT_R8_UNORM
=
=
format
)
{
return
kAlpha_8_as_Red_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kBGR_565
:
if
(
VK_FORMAT_R5G6B5_UNORM_PACK16
=
=
format
)
{
return
kRGB_565_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kABGR_4444
:
if
(
VK_FORMAT_B4G4R4A4_UNORM_PACK16
=
=
format
|
|
VK_FORMAT_R4G4B4A4_UNORM_PACK16
=
=
format
)
{
return
kRGBA_4444_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_8888
:
if
(
VK_FORMAT_R8G8B8A8_UNORM
=
=
format
)
{
return
kRGBA_8888_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_8888_SRGB
:
if
(
VK_FORMAT_R8G8B8A8_SRGB
=
=
format
)
{
return
kSRGBA_8888_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGB_888x
:
if
(
VK_FORMAT_R8G8B8_UNORM
=
=
format
)
{
return
kRGB_888_GrPixelConfig
;
}
else
if
(
VK_FORMAT_R8G8B8A8_UNORM
=
=
format
)
{
return
kRGB_888X_GrPixelConfig
;
}
else
if
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
=
=
format
)
{
return
kRGB_ETC1_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRG_88
:
if
(
VK_FORMAT_R8G8_UNORM
=
=
format
)
{
return
kRG_88_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kBGRA_8888
:
if
(
VK_FORMAT_B8G8R8A8_UNORM
=
=
format
)
{
return
kBGRA_8888_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_1010102
:
if
(
VK_FORMAT_A2B10G10R10_UNORM_PACK32
=
=
format
)
{
return
kRGBA_1010102_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kGray_8
:
if
(
VK_FORMAT_R8_UNORM
=
=
format
)
{
return
kGray_8_as_Red_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kAlpha_F16
:
if
(
VK_FORMAT_R16_SFLOAT
=
=
format
)
{
return
kAlpha_half_as_Red_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_F16
:
if
(
VK_FORMAT_R16G16B16A16_SFLOAT
=
=
format
)
{
return
kRGBA_half_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_F16_Clamped
:
if
(
VK_FORMAT_R16G16B16A16_SFLOAT
=
=
format
)
{
return
kRGBA_half_Clamped_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kAlpha_16
:
if
(
VK_FORMAT_R16_UNORM
=
=
format
)
{
return
kAlpha_16_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRG_1616
:
if
(
VK_FORMAT_R16G16_UNORM
=
=
format
)
{
return
kRG_1616_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_16161616
:
if
(
VK_FORMAT_R16G16B16A16_UNORM
=
=
format
)
{
return
kRGBA_16161616_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRG_F16
:
if
(
VK_FORMAT_R16G16_SFLOAT
=
=
format
)
{
return
kRG_half_GrPixelConfig
;
}
break
;
case
GrColorType
:
:
kRGBA_F32
:
case
GrColorType
:
:
kAlpha_8xxx
:
case
GrColorType
:
:
kAlpha_F32xxx
:
case
GrColorType
:
:
kGray_8xxx
:
break
;
}
return
kUnknown_GrPixelConfig
;
}
GrPixelConfig
GrVkCaps
:
:
onGetConfigFromBackendFormat
(
const
GrBackendFormat
&
format
GrColorType
ct
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
kUnknown_GrPixelConfig
;
}
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
return
validate_image_info
(
vkFormat
ct
ycbcrInfo
-
>
isValid
(
)
)
;
}
GrColorType
GrVkCaps
:
:
getYUVAColorTypeFromBackendFormat
(
const
GrBackendFormat
&
format
bool
isAlphaChannel
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
GrColorType
:
:
kUnknown
;
}
switch
(
vkFormat
)
{
case
VK_FORMAT_R8_UNORM
:
return
isAlphaChannel
?
GrColorType
:
:
kAlpha_8
:
GrColorType
:
:
kGray_8
;
case
VK_FORMAT_R8G8B8A8_UNORM
:
return
GrColorType
:
:
kRGBA_8888
;
case
VK_FORMAT_R8G8B8_UNORM
:
return
GrColorType
:
:
kRGB_888x
;
case
VK_FORMAT_R8G8_UNORM
:
return
GrColorType
:
:
kRG_88
;
case
VK_FORMAT_B8G8R8A8_UNORM
:
return
GrColorType
:
:
kBGRA_8888
;
case
VK_FORMAT_A2B10G10R10_UNORM_PACK32
:
return
GrColorType
:
:
kRGBA_1010102
;
case
VK_FORMAT_R16_UNORM
:
return
GrColorType
:
:
kAlpha_16
;
case
VK_FORMAT_R16_SFLOAT
:
return
GrColorType
:
:
kAlpha_F16
;
case
VK_FORMAT_R16G16_UNORM
:
return
GrColorType
:
:
kRG_1616
;
case
VK_FORMAT_R16G16B16A16_UNORM
:
return
GrColorType
:
:
kRGBA_16161616
;
case
VK_FORMAT_R16G16_SFLOAT
:
return
GrColorType
:
:
kRG_F16
;
default
:
return
GrColorType
:
:
kUnknown
;
}
SkUNREACHABLE
;
}
GrBackendFormat
GrVkCaps
:
:
onGetDefaultBackendFormat
(
GrColorType
ct
GrRenderable
renderable
)
const
{
VkFormat
format
=
this
-
>
getFormatFromColorType
(
ct
)
;
if
(
format
=
=
VK_FORMAT_UNDEFINED
)
{
return
GrBackendFormat
(
)
;
}
return
GrBackendFormat
:
:
MakeVk
(
format
)
;
}
GrBackendFormat
GrVkCaps
:
:
getBackendFormatFromCompressionType
(
SkImage
:
:
CompressionType
compressionType
)
const
{
switch
(
compressionType
)
{
case
SkImage
:
:
kETC1_CompressionType
:
return
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
)
;
}
SK_ABORT
(
"
Invalid
compression
type
"
)
;
}
GrSwizzle
GrVkCaps
:
:
getTextureSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fTextureSwizzle
;
}
}
return
GrSwizzle
:
:
RGBA
(
)
;
}
GrSwizzle
GrVkCaps
:
:
getOutputSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fOutputSwizzle
;
}
}
return
GrSwizzle
:
:
RGBA
(
)
;
}
GrCaps
:
:
SupportedRead
GrVkCaps
:
:
onSupportedReadPixelsColorType
(
GrColorType
srcColorType
const
GrBackendFormat
&
srcBackendFormat
GrColorType
dstColorType
)
const
{
VkFormat
vkFormat
;
if
(
!
srcBackendFormat
.
asVkFormat
(
&
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
if
(
GrVkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
size_t
offsetAlignment
=
align_to_4
(
this
-
>
bytesPerPixel
(
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
srcColorType
)
{
return
{
srcColorType
offsetAlignment
}
;
}
}
return
{
GrColorType
:
:
kUnknown
0
}
;
}
int
GrVkCaps
:
:
getFragmentUniformBinding
(
)
const
{
return
GrVkUniformHandler
:
:
kUniformBinding
;
}
int
GrVkCaps
:
:
getFragmentUniformSet
(
)
const
{
return
GrVkUniformHandler
:
:
kUniformBufferDescSet
;
}
#
if
GR_TEST_UTILS
std
:
:
vector
<
GrCaps
:
:
TestFormatColorTypeCombination
>
GrVkCaps
:
:
getTestingCombinations
(
)
const
{
std
:
:
vector
<
GrCaps
:
:
TestFormatColorTypeCombination
>
combos
=
{
{
GrColorType
:
:
kAlpha_8
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8_UNORM
)
}
{
GrColorType
:
:
kBGR_565
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R5G6B5_UNORM_PACK16
)
}
{
GrColorType
:
:
kABGR_4444
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R4G4B4A4_UNORM_PACK16
)
}
{
GrColorType
:
:
kABGR_4444
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_B4G4R4A4_UNORM_PACK16
)
}
{
GrColorType
:
:
kRGBA_8888
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_UNORM
)
}
{
GrColorType
:
:
kRGBA_8888_SRGB
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_SRGB
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_UNORM
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8_UNORM
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
)
}
{
GrColorType
:
:
kRG_88
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8_UNORM
)
}
{
GrColorType
:
:
kBGRA_8888
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_B8G8R8A8_UNORM
)
}
{
GrColorType
:
:
kRGBA_1010102
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_A2B10G10R10_UNORM_PACK32
)
}
{
GrColorType
:
:
kGray_8
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8_UNORM
)
}
{
GrColorType
:
:
kAlpha_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16_SFLOAT
)
}
{
GrColorType
:
:
kRGBA_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_SFLOAT
)
}
{
GrColorType
:
:
kRGBA_F16_Clamped
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_SFLOAT
)
}
{
GrColorType
:
:
kAlpha_16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16_UNORM
)
}
{
GrColorType
:
:
kRG_1616
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16_UNORM
)
}
{
GrColorType
:
:
kRGBA_16161616
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_UNORM
)
}
{
GrColorType
:
:
kRG_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16_SFLOAT
)
}
}
;
return
combos
;
}
#
endif
