#
include
"
GrVkCaps
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
GrVkUtil
.
h
"
#
include
"
vk
/
GrVkBackendContext
.
h
"
#
include
"
vk
/
GrVkInterface
.
h
"
GrVkCaps
:
:
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
uint32_t
featureFlags
uint32_t
extensionFlags
)
:
INHERITED
(
contextOptions
)
{
fCanUseGLSLForShaderModule
=
false
;
fMustDoCopiesFromOrigin
=
false
;
fSupportsCopiesAsDraws
=
false
;
fMustSubmitCommandsBeforeCopyOp
=
false
;
fMustSleepOnTearDown
=
false
;
fNewSecondaryCBOnPipelineChange
=
false
;
fMipMapSupport
=
true
;
fSRGBSupport
=
true
;
fNPOTTextureTileSupport
=
true
;
fTwoSidedStencilSupport
=
true
;
fStencilWrapOpsSupport
=
true
;
fDiscardRenderTargetSupport
=
true
;
fReuseScratchTextures
=
true
;
fGpuTracingSupport
=
false
;
fCompressedTexSubImageSupport
=
false
;
fOversizedStencilSupport
=
false
;
fUseDrawInsteadOfClear
=
false
;
fFenceSyncSupport
=
true
;
fCrossContextTextureSupport
=
false
;
fMapBufferFlags
=
kNone_MapFlags
;
fBufferMapThreshold
=
SK_MaxS32
;
fMaxRenderTargetSize
=
4096
;
fMaxTextureSize
=
4096
;
fMaxColorSampleCount
=
4
;
fMaxStencilSampleCount
=
4
;
fShaderCaps
.
reset
(
new
GrShaderCaps
(
contextOptions
)
)
;
this
-
>
init
(
contextOptions
vkInterface
physDev
featureFlags
extensionFlags
)
;
}
bool
GrVkCaps
:
:
initDescForDstCopy
(
const
GrRenderTargetProxy
*
src
GrSurfaceDesc
*
desc
bool
*
rectsMustMatch
bool
*
disallowSubrect
)
const
{
*
rectsMustMatch
=
false
;
*
disallowSubrect
=
false
;
desc
-
>
fOrigin
=
src
-
>
origin
(
)
;
desc
-
>
fConfig
=
src
-
>
config
(
)
;
if
(
src
-
>
numColorSamples
(
)
>
1
|
|
(
src
-
>
asTextureProxy
(
)
&
&
this
-
>
supportsCopiesAsDraws
(
)
)
)
{
desc
-
>
fFlags
=
kRenderTarget_GrSurfaceFlag
;
}
else
{
desc
-
>
fFlags
=
kNone_GrSurfaceFlags
;
}
return
true
;
}
void
GrVkCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
uint32_t
featureFlags
uint32_t
extensionFlags
)
{
VkPhysicalDeviceProperties
properties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties
(
physDev
&
properties
)
)
;
VkPhysicalDeviceMemoryProperties
memoryProperties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceMemoryProperties
(
physDev
&
memoryProperties
)
)
;
this
-
>
initGrCaps
(
properties
memoryProperties
featureFlags
)
;
this
-
>
initShaderCaps
(
properties
featureFlags
)
;
this
-
>
initConfigTable
(
vkInterface
physDev
)
;
this
-
>
initStencilFormat
(
vkInterface
physDev
)
;
if
(
SkToBool
(
extensionFlags
&
kNV_glsl_shader_GrVkExtensionFlag
)
)
{
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fMustDoCopiesFromOrigin
=
true
;
}
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
)
{
fSupportsCopiesAsDraws
=
true
;
fMustSubmitCommandsBeforeCopyOp
=
true
;
}
#
if
defined
(
SK_BUILD_FOR_WIN
)
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
elif
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fMustSleepOnTearDown
=
true
;
}
#
endif
this
-
>
applyOptionsOverrides
(
contextOptions
)
;
fShaderCaps
-
>
applyOptionsOverrides
(
contextOptions
)
;
}
int
get_max_sample_count
(
VkSampleCountFlags
flags
)
{
SkASSERT
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
;
if
(
!
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
)
{
return
0
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
)
{
return
2
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
)
{
return
4
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
)
{
return
8
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_32_BIT
)
)
{
return
16
;
}
if
(
!
(
flags
&
VK_SAMPLE_COUNT_64_BIT
)
)
{
return
32
;
}
return
64
;
}
void
GrVkCaps
:
:
initSampleCount
(
const
VkPhysicalDeviceProperties
&
properties
)
{
VkSampleCountFlags
colorSamples
=
properties
.
limits
.
framebufferColorSampleCounts
;
VkSampleCountFlags
stencilSamples
=
properties
.
limits
.
framebufferStencilSampleCounts
;
fMaxColorSampleCount
=
get_max_sample_count
(
colorSamples
)
;
fMaxStencilSampleCount
=
get_max_sample_count
(
stencilSamples
)
;
}
void
GrVkCaps
:
:
initGrCaps
(
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceMemoryProperties
&
memoryProperties
uint32_t
featureFlags
)
{
static
const
uint32_t
kMaxVertexAttributes
=
64
;
fMaxVertexAttributes
=
SkTMin
(
properties
.
limits
.
maxVertexInputAttributes
kMaxVertexAttributes
)
;
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMaxVertexAttributes
=
SkTMin
(
fMaxVertexAttributes
32
)
;
}
fMaxRenderTargetSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
fMaxTextureSize
=
SkTMin
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
this
-
>
initSampleCount
(
properties
)
;
fBufferMapThreshold
=
0
;
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fStencilWrapOpsSupport
=
true
;
fOversizedStencilSupport
=
true
;
fSampleShadingSupport
=
SkToBool
(
featureFlags
&
kSampleRateShading_GrVkFeatureFlag
)
;
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fNewSecondaryCBOnPipelineChange
=
true
;
}
}
void
GrVkCaps
:
:
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
properties
uint32_t
featureFlags
)
{
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fVersionDeclString
=
"
#
version
330
\
n
"
;
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
GrPixelConfig
config
=
static_cast
<
GrPixelConfig
>
(
i
)
;
if
(
GrPixelConfigIsAlphaOnly
(
config
)
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RRRR
(
)
;
shaderCaps
-
>
fConfigOutputSwizzle
[
i
]
=
GrSwizzle
:
:
AAAA
(
)
;
}
else
{
if
(
kGray_8_GrPixelConfig
=
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RRRA
(
)
;
}
else
if
(
kRGBA_4444_GrPixelConfig
=
=
config
)
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
BGRA
(
)
;
shaderCaps
-
>
fConfigOutputSwizzle
[
i
]
=
GrSwizzle
:
:
BGRA
(
)
;
}
else
{
shaderCaps
-
>
fConfigTextureSwizzle
[
i
]
=
GrSwizzle
:
:
RGBA
(
)
;
}
}
}
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
shaderCaps
-
>
fAtan2ImplementedAsAtanYOverX
=
true
;
}
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
shaderCaps
-
>
fFlatInterpolationSupport
=
true
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fGeometryShaderSupport
=
SkToBool
(
featureFlags
&
kGeometryShader_GrVkFeatureFlag
)
;
shaderCaps
-
>
fDualSourceBlendingSupport
=
SkToBool
(
featureFlags
&
kDualSrcBlend_GrVkFeatureFlag
)
;
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
false
;
}
shaderCaps
-
>
fIntegerSupport
=
true
;
shaderCaps
-
>
fShaderPrecisionVaries
=
true
;
for
(
int
s
=
0
;
s
<
kGrShaderTypeCount
;
+
+
s
)
{
auto
&
highp
=
shaderCaps
-
>
fFloatPrecisions
[
s
]
[
kHigh_GrSLPrecision
]
;
highp
.
fLogRangeLow
=
highp
.
fLogRangeHigh
=
127
;
highp
.
fBits
=
23
;
auto
&
mediump
=
shaderCaps
-
>
fFloatPrecisions
[
s
]
[
kMedium_GrSLPrecision
]
;
mediump
.
fLogRangeLow
=
mediump
.
fLogRangeHigh
=
14
;
mediump
.
fBits
=
10
;
shaderCaps
-
>
fFloatPrecisions
[
s
]
[
kLow_GrSLPrecision
]
=
mediump
;
}
shaderCaps
-
>
initSamplerPrecisionTable
(
)
;
shaderCaps
-
>
fMaxVertexSamplers
=
shaderCaps
-
>
fMaxGeometrySamplers
=
shaderCaps
-
>
fMaxFragmentSamplers
=
SkTMin
(
SkTMin
(
properties
.
limits
.
maxPerStageDescriptorSampledImages
properties
.
limits
.
maxPerStageDescriptorSamplers
)
(
uint32_t
)
INT_MAX
)
;
shaderCaps
-
>
fMaxCombinedSamplers
=
SkTMin
(
SkTMin
(
properties
.
limits
.
maxDescriptorSetSampledImages
properties
.
limits
.
maxDescriptorSetSamplers
)
(
uint32_t
)
INT_MAX
)
;
}
bool
stencil_format_supported
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
return
SkToBool
(
VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
&
props
.
optimalTilingFeatures
)
;
}
void
GrVkCaps
:
:
initStencilFormat
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
)
{
static
const
StencilFormat
gS8
=
{
VK_FORMAT_S8_UINT
8
8
false
}
gD24S8
=
{
VK_FORMAT_D24_UNORM_S8_UINT
8
32
true
}
gD32S8
=
{
VK_FORMAT_D32_SFLOAT_S8_UINT
8
64
true
}
;
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_S8_UINT
)
)
{
fPreferedStencilFormat
=
gS8
;
}
else
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D24_UNORM_S8_UINT
)
)
{
fPreferedStencilFormat
=
gD24S8
;
}
else
{
SkASSERT
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D32_SFLOAT_S8_UINT
)
)
;
fPreferedStencilFormat
=
gD32S8
;
}
}
void
GrVkCaps
:
:
initConfigTable
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
)
{
for
(
int
i
=
0
;
i
<
kGrPixelConfigCnt
;
+
+
i
)
{
VkFormat
format
;
if
(
GrPixelConfigToVkFormat
(
static_cast
<
GrPixelConfig
>
(
i
)
&
format
)
)
{
fConfigTable
[
i
]
.
init
(
interface
physDev
format
)
;
}
}
const
uint16_t
kFlagsToRemove
=
ConfigInfo
:
:
kTextureable_Flag
|
ConfigInfo
:
:
kRenderable_Flag
;
fConfigTable
[
kETC1_GrPixelConfig
]
.
fOptimalFlags
&
=
~
kFlagsToRemove
;
fConfigTable
[
kETC1_GrPixelConfig
]
.
fLinearFlags
&
=
~
kFlagsToRemove
;
}
void
GrVkCaps
:
:
ConfigInfo
:
:
InitConfigFlags
(
VkFormatFeatureFlags
vkFlags
uint16_t
*
flags
)
{
if
(
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
&
vkFlags
)
&
&
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kTextureable_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kRenderable_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_SRC_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitSrc_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_DST_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitDst_Flag
;
}
}
void
GrVkCaps
:
:
ConfigInfo
:
:
init
(
const
GrVkInterface
*
interface
VkPhysicalDevice
physDev
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
InitConfigFlags
(
props
.
linearTilingFeatures
&
fLinearFlags
)
;
InitConfigFlags
(
props
.
optimalTilingFeatures
&
fOptimalFlags
)
;
}
