#
include
"
GrVkCopyPipeline
.
h
"
#
include
"
GrVkGpu
.
h
"
#
include
"
GrVkUtil
.
h
"
#
include
"
SkOnce
.
h
"
static
void
setup_multisample_state
(
int
numSamples
VkPipelineMultisampleStateCreateInfo
*
multisampleInfo
)
{
memset
(
multisampleInfo
0
sizeof
(
VkPipelineMultisampleStateCreateInfo
)
)
;
multisampleInfo
-
>
sType
=
VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
;
multisampleInfo
-
>
pNext
=
nullptr
;
multisampleInfo
-
>
flags
=
0
;
SkAssertResult
(
GrSampleCountToVkSampleCount
(
numSamples
&
multisampleInfo
-
>
rasterizationSamples
)
)
;
multisampleInfo
-
>
sampleShadingEnable
=
VK_FALSE
;
multisampleInfo
-
>
minSampleShading
=
0
.
0f
;
multisampleInfo
-
>
pSampleMask
=
nullptr
;
multisampleInfo
-
>
alphaToCoverageEnable
=
VK_FALSE
;
multisampleInfo
-
>
alphaToOneEnable
=
VK_FALSE
;
}
GrVkCopyPipeline
*
GrVkCopyPipeline
:
:
Create
(
GrVkGpu
*
gpu
VkPipelineShaderStageCreateInfo
*
shaderStageInfo
VkPipelineLayout
pipelineLayout
int
numSamples
const
GrVkRenderPass
&
renderPass
VkPipelineCache
cache
)
{
static
const
VkVertexInputAttributeDescription
attributeDesc
=
{
0
0
VK_FORMAT_R32G32_SFLOAT
0
}
;
static
const
VkVertexInputBindingDescription
bindingDesc
=
{
0
2
*
sizeof
(
float
)
VK_VERTEX_INPUT_RATE_VERTEX
}
;
static
const
VkPipelineVertexInputStateCreateInfo
vertexInputInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
nullptr
0
1
&
bindingDesc
1
&
attributeDesc
}
;
static
const
VkPipelineInputAssemblyStateCreateInfo
inputAssemblyInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
nullptr
0
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP
VK_FALSE
}
;
static
const
VkStencilOpState
dummyStencilState
=
{
VK_STENCIL_OP_KEEP
VK_STENCIL_OP_KEEP
VK_STENCIL_OP_KEEP
VK_COMPARE_OP_NEVER
0
0
0
}
;
static
const
VkPipelineDepthStencilStateCreateInfo
stencilInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
nullptr
0
VK_FALSE
VK_FALSE
VK_COMPARE_OP_ALWAYS
VK_FALSE
VK_FALSE
dummyStencilState
dummyStencilState
0
.
0f
1
.
0f
}
;
static
const
VkPipelineViewportStateCreateInfo
viewportInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
nullptr
0
1
nullptr
1
nullptr
}
;
static
const
VkPipelineColorBlendAttachmentState
attachmentState
=
{
VK_TRUE
VK_BLEND_FACTOR_ONE
VK_BLEND_FACTOR_ZERO
VK_BLEND_OP_ADD
VK_BLEND_FACTOR_ONE
VK_BLEND_FACTOR_ZERO
VK_BLEND_OP_ADD
VK_COLOR_COMPONENT_R_BIT
|
VK_COLOR_COMPONENT_G_BIT
|
VK_COLOR_COMPONENT_B_BIT
|
VK_COLOR_COMPONENT_A_BIT
}
;
static
const
VkPipelineColorBlendStateCreateInfo
colorBlendInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
nullptr
0
VK_FALSE
VK_LOGIC_OP_CLEAR
1
&
attachmentState
{
0
.
f
0
.
f
0
.
f
0
.
f
}
}
;
static
const
VkPipelineRasterizationStateCreateInfo
rasterInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
nullptr
0
VK_FALSE
VK_FALSE
VK_POLYGON_MODE_FILL
VK_CULL_MODE_NONE
VK_FRONT_FACE_COUNTER_CLOCKWISE
VK_FALSE
0
.
0f
0
.
0f
0
.
0f
1
.
0f
}
;
static
const
VkDynamicState
dynamicStates
[
2
]
=
{
VK_DYNAMIC_STATE_VIEWPORT
VK_DYNAMIC_STATE_SCISSOR
}
;
static
const
VkPipelineDynamicStateCreateInfo
dynamicInfo
=
{
VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
nullptr
0
2
dynamicStates
}
;
VkPipelineMultisampleStateCreateInfo
multisampleInfo
;
setup_multisample_state
(
numSamples
&
multisampleInfo
)
;
VkGraphicsPipelineCreateInfo
pipelineCreateInfo
;
memset
(
&
pipelineCreateInfo
0
sizeof
(
VkGraphicsPipelineCreateInfo
)
)
;
pipelineCreateInfo
.
sType
=
VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
;
pipelineCreateInfo
.
pNext
=
nullptr
;
pipelineCreateInfo
.
flags
=
0
;
pipelineCreateInfo
.
stageCount
=
2
;
pipelineCreateInfo
.
pStages
=
shaderStageInfo
;
pipelineCreateInfo
.
pVertexInputState
=
&
vertexInputInfo
;
pipelineCreateInfo
.
pInputAssemblyState
=
&
inputAssemblyInfo
;
pipelineCreateInfo
.
pTessellationState
=
nullptr
;
pipelineCreateInfo
.
pViewportState
=
&
viewportInfo
;
pipelineCreateInfo
.
pRasterizationState
=
&
rasterInfo
;
pipelineCreateInfo
.
pMultisampleState
=
&
multisampleInfo
;
pipelineCreateInfo
.
pDepthStencilState
=
&
stencilInfo
;
pipelineCreateInfo
.
pColorBlendState
=
&
colorBlendInfo
;
pipelineCreateInfo
.
pDynamicState
=
&
dynamicInfo
;
pipelineCreateInfo
.
layout
=
pipelineLayout
;
pipelineCreateInfo
.
renderPass
=
renderPass
.
vkRenderPass
(
)
;
pipelineCreateInfo
.
subpass
=
0
;
pipelineCreateInfo
.
basePipelineHandle
=
VK_NULL_HANDLE
;
pipelineCreateInfo
.
basePipelineIndex
=
-
1
;
VkPipeline
vkPipeline
;
VkResult
err
=
GR_VK_CALL
(
gpu
-
>
vkInterface
(
)
CreateGraphicsPipelines
(
gpu
-
>
device
(
)
cache
1
&
pipelineCreateInfo
nullptr
&
vkPipeline
)
)
;
if
(
err
)
{
SkDebugf
(
"
Failed
to
create
copy
pipeline
.
Error
:
%
d
\
n
"
err
)
;
return
nullptr
;
}
return
new
GrVkCopyPipeline
(
vkPipeline
&
renderPass
)
;
}
bool
GrVkCopyPipeline
:
:
isCompatible
(
const
GrVkRenderPass
&
rp
)
const
{
return
rp
.
isCompatible
(
*
fRenderPass
)
;
}
