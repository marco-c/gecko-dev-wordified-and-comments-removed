#
include
"
GrVkGpuCommandBuffer
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
GrVkCommandBuffer
.
h
"
#
include
"
GrVkGpu
.
h
"
#
include
"
GrVkPipeline
.
h
"
#
include
"
GrVkRenderPass
.
h
"
#
include
"
GrVkRenderTarget
.
h
"
#
include
"
GrVkResourceProvider
.
h
"
#
include
"
GrVkTexture
.
h
"
#
include
"
SkRect
.
h
"
void
GrVkGpuTextureCommandBuffer
:
:
copy
(
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
fCopies
.
emplace_back
(
src
srcOrigin
srcRect
dstPoint
)
;
}
void
GrVkGpuTextureCommandBuffer
:
:
insertEventMarker
(
const
char
*
msg
)
{
}
void
GrVkGpuTextureCommandBuffer
:
:
submit
(
)
{
for
(
int
i
=
0
;
i
<
fCopies
.
count
(
)
;
+
+
i
)
{
CopyInfo
&
copyInfo
=
fCopies
[
i
]
;
fGpu
-
>
copySurface
(
fTexture
fOrigin
copyInfo
.
fSrc
copyInfo
.
fSrcOrigin
copyInfo
.
fSrcRect
copyInfo
.
fDstPoint
)
;
}
}
GrVkGpuTextureCommandBuffer
:
:
~
GrVkGpuTextureCommandBuffer
(
)
{
}
void
get_vk_load_store_ops
(
GrLoadOp
loadOpIn
GrStoreOp
storeOpIn
VkAttachmentLoadOp
*
loadOp
VkAttachmentStoreOp
*
storeOp
)
{
switch
(
loadOpIn
)
{
case
GrLoadOp
:
:
kLoad
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_LOAD
;
break
;
case
GrLoadOp
:
:
kClear
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_CLEAR
;
break
;
case
GrLoadOp
:
:
kDiscard
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_DONT_CARE
;
break
;
default
:
SK_ABORT
(
"
Invalid
LoadOp
"
)
;
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_LOAD
;
}
switch
(
storeOpIn
)
{
case
GrStoreOp
:
:
kStore
:
*
storeOp
=
VK_ATTACHMENT_STORE_OP_STORE
;
break
;
case
GrStoreOp
:
:
kDiscard
:
*
storeOp
=
VK_ATTACHMENT_STORE_OP_DONT_CARE
;
break
;
default
:
SK_ABORT
(
"
Invalid
StoreOp
"
)
;
*
storeOp
=
VK_ATTACHMENT_STORE_OP_STORE
;
}
}
GrVkGpuRTCommandBuffer
:
:
GrVkGpuRTCommandBuffer
(
GrVkGpu
*
gpu
GrRenderTarget
*
rt
GrSurfaceOrigin
origin
const
LoadAndStoreInfo
&
colorInfo
const
StencilLoadAndStoreInfo
&
stencilInfo
)
:
INHERITED
(
rt
origin
)
fGpu
(
gpu
)
fClearColor
(
GrColor4f
:
:
FromGrColor
(
colorInfo
.
fClearColor
)
)
fLastPipelineState
(
nullptr
)
{
get_vk_load_store_ops
(
colorInfo
.
fLoadOp
colorInfo
.
fStoreOp
&
fVkColorLoadOp
&
fVkColorStoreOp
)
;
get_vk_load_store_ops
(
stencilInfo
.
fLoadOp
stencilInfo
.
fStoreOp
&
fVkStencilLoadOp
&
fVkStencilStoreOp
)
;
fCurrentCmdInfo
=
-
1
;
this
-
>
init
(
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
init
(
)
{
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
fVkColorLoadOp
fVkColorStoreOp
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
fVkStencilLoadOp
fVkStencilStoreOp
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
.
push_back
(
)
;
SkASSERT
(
fCommandBufferInfos
.
count
(
)
=
=
1
)
;
fCurrentCmdInfo
=
0
;
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
vkRT
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
vkRT
vkColorOps
vkStencilOps
)
;
}
cbInfo
.
fColorClearValue
.
color
.
float32
[
0
]
=
fClearColor
.
fRGBA
[
0
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
1
]
=
fClearColor
.
fRGBA
[
1
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
2
]
=
fClearColor
.
fRGBA
[
2
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
3
]
=
fClearColor
.
fRGBA
[
3
]
;
if
(
VK_ATTACHMENT_LOAD_OP_CLEAR
=
=
fVkColorLoadOp
)
{
cbInfo
.
fBounds
=
SkRect
:
:
MakeWH
(
vkRT
-
>
width
(
)
vkRT
-
>
height
(
)
)
;
}
else
{
cbInfo
.
fBounds
.
setEmpty
(
)
;
}
cbInfo
.
fIsEmpty
=
true
;
cbInfo
.
fStartsWithClear
=
false
;
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
vkRT
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
GrVkGpuRTCommandBuffer
:
:
~
GrVkGpuRTCommandBuffer
(
)
{
for
(
int
i
=
0
;
i
<
fCommandBufferInfos
.
count
(
)
;
+
+
i
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
cbInfo
.
fCommandBuffers
.
count
(
)
;
+
+
j
)
{
cbInfo
.
fCommandBuffers
[
j
]
-
>
unref
(
fGpu
)
;
}
cbInfo
.
fRenderPass
-
>
unref
(
fGpu
)
;
}
}
GrGpu
*
GrVkGpuRTCommandBuffer
:
:
gpu
(
)
{
return
fGpu
;
}
void
GrVkGpuRTCommandBuffer
:
:
end
(
)
{
if
(
fCurrentCmdInfo
>
=
0
)
{
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
}
}
void
GrVkGpuRTCommandBuffer
:
:
submit
(
)
{
if
(
!
fRenderTarget
)
{
return
;
}
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
GrVkImage
*
targetImage
=
vkRT
-
>
msaaImage
(
)
?
vkRT
-
>
msaaImage
(
)
:
vkRT
;
GrStencilAttachment
*
stencil
=
fRenderTarget
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
for
(
int
i
=
0
;
i
<
fCommandBufferInfos
.
count
(
)
;
+
+
i
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
cbInfo
.
fPreDrawUploads
.
count
(
)
;
+
+
j
)
{
InlineUploadInfo
&
iuInfo
=
cbInfo
.
fPreDrawUploads
[
j
]
;
iuInfo
.
fFlushState
-
>
doUpload
(
iuInfo
.
fUpload
)
;
}
for
(
int
j
=
0
;
j
<
cbInfo
.
fPreCopies
.
count
(
)
;
+
+
j
)
{
CopyInfo
&
copyInfo
=
cbInfo
.
fPreCopies
[
j
]
;
fGpu
-
>
copySurface
(
fRenderTarget
fOrigin
copyInfo
.
fSrc
copyInfo
.
fSrcOrigin
copyInfo
.
fSrcRect
copyInfo
.
fDstPoint
)
;
}
targetImage
-
>
setImageLayout
(
fGpu
VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
if
(
stencil
)
{
GrVkStencilAttachment
*
vkStencil
=
(
GrVkStencilAttachment
*
)
stencil
;
vkStencil
-
>
setImageLayout
(
fGpu
VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
|
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
}
#
if
0
if
(
cbInfo
.
fIsEmpty
&
&
!
cbInfo
.
fStartsWithClear
)
{
continue
;
}
#
endif
if
(
cbInfo
.
fBounds
.
intersect
(
0
0
SkIntToScalar
(
fRenderTarget
-
>
width
(
)
)
SkIntToScalar
(
fRenderTarget
-
>
height
(
)
)
)
)
{
SkIRect
iBounds
;
cbInfo
.
fBounds
.
roundOut
(
&
iBounds
)
;
fGpu
-
>
submitSecondaryCommandBuffer
(
cbInfo
.
fCommandBuffers
cbInfo
.
fRenderPass
&
cbInfo
.
fColorClearValue
vkRT
fOrigin
iBounds
)
;
}
}
}
void
GrVkGpuRTCommandBuffer
:
:
discard
(
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
if
(
cbInfo
.
fIsEmpty
)
{
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_DONT_CARE
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
VK_ATTACHMENT_LOAD_OP_DONT_CARE
VK_ATTACHMENT_STORE_OP_STORE
)
;
const
GrVkRenderPass
*
oldRP
=
cbInfo
.
fRenderPass
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
vkRT
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
vkRT
vkColorOps
vkStencilOps
)
;
}
SkASSERT
(
cbInfo
.
fRenderPass
-
>
isCompatible
(
*
oldRP
)
)
;
oldRP
-
>
unref
(
fGpu
)
;
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
cbInfo
.
fStartsWithClear
=
false
;
}
}
void
GrVkGpuRTCommandBuffer
:
:
insertEventMarker
(
const
char
*
msg
)
{
}
void
GrVkGpuRTCommandBuffer
:
:
onClearStencilClip
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
SkASSERT
(
!
clip
.
hasWindowRectangles
(
)
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
GrStencilAttachment
*
sb
=
fRenderTarget
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
SkASSERT
(
sb
)
;
int
stencilBitCount
=
sb
-
>
bits
(
)
;
VkClearDepthStencilValue
vkStencilColor
;
memset
(
&
vkStencilColor
0
sizeof
(
VkClearDepthStencilValue
)
)
;
if
(
insideStencilMask
)
{
vkStencilColor
.
stencil
=
(
1
<
<
(
stencilBitCount
-
1
)
)
;
}
else
{
vkStencilColor
.
stencil
=
0
;
}
VkClearRect
clearRect
;
SkIRect
vkRect
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
vkRect
.
setXYWH
(
0
0
fRenderTarget
-
>
width
(
)
fRenderTarget
-
>
height
(
)
)
;
}
else
if
(
kBottomLeft_GrSurfaceOrigin
!
=
fOrigin
)
{
vkRect
=
clip
.
scissorRect
(
)
;
}
else
{
const
SkIRect
&
scissor
=
clip
.
scissorRect
(
)
;
vkRect
.
setLTRB
(
scissor
.
fLeft
fRenderTarget
-
>
height
(
)
-
scissor
.
fBottom
scissor
.
fRight
fRenderTarget
-
>
height
(
)
-
scissor
.
fTop
)
;
}
clearRect
.
rect
.
offset
=
{
vkRect
.
fLeft
vkRect
.
fTop
}
;
clearRect
.
rect
.
extent
=
{
(
uint32_t
)
vkRect
.
width
(
)
(
uint32_t
)
vkRect
.
height
(
)
}
;
clearRect
.
baseArrayLayer
=
0
;
clearRect
.
layerCount
=
1
;
uint32_t
stencilIndex
;
SkAssertResult
(
cbInfo
.
fRenderPass
-
>
stencilAttachmentIndex
(
&
stencilIndex
)
)
;
VkClearAttachment
attachment
;
attachment
.
aspectMask
=
VK_IMAGE_ASPECT_STENCIL_BIT
;
attachment
.
colorAttachment
=
0
;
attachment
.
clearValue
.
depthStencil
=
vkStencilColor
;
cbInfo
.
currentCmdBuf
(
)
-
>
clearAttachments
(
fGpu
1
&
attachment
1
&
clearRect
)
;
cbInfo
.
fIsEmpty
=
false
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
}
else
{
cbInfo
.
fBounds
.
join
(
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
)
;
}
}
void
GrVkGpuRTCommandBuffer
:
:
onClear
(
const
GrFixedClip
&
clip
GrColor
color
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
SkASSERT
(
!
clip
.
hasWindowRectangles
(
)
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
VkClearColorValue
vkColor
;
GrColorToRGBAFloat
(
color
vkColor
.
float32
)
;
if
(
cbInfo
.
fIsEmpty
&
&
!
clip
.
scissorEnabled
(
)
)
{
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_CLEAR
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
fVkStencilLoadOp
fVkStencilStoreOp
)
;
const
GrVkRenderPass
*
oldRP
=
cbInfo
.
fRenderPass
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
vkRT
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
vkRT
vkColorOps
vkStencilOps
)
;
}
SkASSERT
(
cbInfo
.
fRenderPass
-
>
isCompatible
(
*
oldRP
)
)
;
oldRP
-
>
unref
(
fGpu
)
;
GrColorToRGBAFloat
(
color
cbInfo
.
fColorClearValue
.
color
.
float32
)
;
cbInfo
.
fStartsWithClear
=
true
;
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
return
;
}
VkClearRect
clearRect
;
SkIRect
vkRect
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
vkRect
.
setXYWH
(
0
0
fRenderTarget
-
>
width
(
)
fRenderTarget
-
>
height
(
)
)
;
}
else
if
(
kBottomLeft_GrSurfaceOrigin
!
=
fOrigin
)
{
vkRect
=
clip
.
scissorRect
(
)
;
}
else
{
const
SkIRect
&
scissor
=
clip
.
scissorRect
(
)
;
vkRect
.
setLTRB
(
scissor
.
fLeft
fRenderTarget
-
>
height
(
)
-
scissor
.
fBottom
scissor
.
fRight
fRenderTarget
-
>
height
(
)
-
scissor
.
fTop
)
;
}
clearRect
.
rect
.
offset
=
{
vkRect
.
fLeft
vkRect
.
fTop
}
;
clearRect
.
rect
.
extent
=
{
(
uint32_t
)
vkRect
.
width
(
)
(
uint32_t
)
vkRect
.
height
(
)
}
;
clearRect
.
baseArrayLayer
=
0
;
clearRect
.
layerCount
=
1
;
uint32_t
colorIndex
;
SkAssertResult
(
cbInfo
.
fRenderPass
-
>
colorAttachmentIndex
(
&
colorIndex
)
)
;
VkClearAttachment
attachment
;
attachment
.
aspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
attachment
.
colorAttachment
=
colorIndex
;
attachment
.
clearValue
.
color
=
vkColor
;
cbInfo
.
currentCmdBuf
(
)
-
>
clearAttachments
(
fGpu
1
&
attachment
1
&
clearRect
)
;
cbInfo
.
fIsEmpty
=
false
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
}
else
{
cbInfo
.
fBounds
.
join
(
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
)
;
}
return
;
}
void
GrVkGpuRTCommandBuffer
:
:
addAdditionalCommandBuffer
(
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
cbInfo
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
vkRT
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
addAdditionalRenderPass
(
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
fRenderTarget
)
;
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
.
push_back
(
)
;
fCurrentCmdInfo
+
+
;
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_LOAD
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
VK_ATTACHMENT_LOAD_OP_LOAD
VK_ATTACHMENT_STORE_OP_STORE
)
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
vkRT
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
vkRT
vkColorOps
vkStencilOps
)
;
}
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
memset
(
&
cbInfo
.
fColorClearValue
0
sizeof
(
VkClearValue
)
)
;
cbInfo
.
fBounds
.
setEmpty
(
)
;
cbInfo
.
fIsEmpty
=
true
;
cbInfo
.
fStartsWithClear
=
false
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
vkRT
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
inlineUpload
(
GrOpFlushState
*
state
GrDeferredTextureUploadFn
&
upload
)
{
if
(
!
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fIsEmpty
)
{
this
-
>
addAdditionalRenderPass
(
)
;
}
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fPreDrawUploads
.
emplace_back
(
state
upload
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
copy
(
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
if
(
!
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fIsEmpty
|
|
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fStartsWithClear
)
{
this
-
>
addAdditionalRenderPass
(
)
;
}
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fPreCopies
.
emplace_back
(
src
srcOrigin
srcRect
dstPoint
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
bindGeometry
(
const
GrPrimitiveProcessor
&
primProc
const
GrBuffer
*
indexBuffer
const
GrBuffer
*
vertexBuffer
const
GrBuffer
*
instanceBuffer
)
{
GrVkSecondaryCommandBuffer
*
currCmdBuf
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
currentCmdBuf
(
)
;
uint32_t
binding
=
0
;
if
(
primProc
.
hasVertexAttribs
(
)
)
{
SkASSERT
(
vertexBuffer
)
;
SkASSERT
(
!
vertexBuffer
-
>
isCPUBacked
(
)
)
;
SkASSERT
(
!
vertexBuffer
-
>
isMapped
(
)
)
;
currCmdBuf
-
>
bindInputBuffer
(
fGpu
binding
+
+
static_cast
<
const
GrVkVertexBuffer
*
>
(
vertexBuffer
)
)
;
}
if
(
primProc
.
hasInstanceAttribs
(
)
)
{
SkASSERT
(
instanceBuffer
)
;
SkASSERT
(
!
instanceBuffer
-
>
isCPUBacked
(
)
)
;
SkASSERT
(
!
instanceBuffer
-
>
isMapped
(
)
)
;
currCmdBuf
-
>
bindInputBuffer
(
fGpu
binding
+
+
static_cast
<
const
GrVkVertexBuffer
*
>
(
instanceBuffer
)
)
;
}
if
(
indexBuffer
)
{
SkASSERT
(
indexBuffer
)
;
SkASSERT
(
!
indexBuffer
-
>
isMapped
(
)
)
;
SkASSERT
(
!
indexBuffer
-
>
isCPUBacked
(
)
)
;
currCmdBuf
-
>
bindIndexBuffer
(
fGpu
static_cast
<
const
GrVkIndexBuffer
*
>
(
indexBuffer
)
)
;
}
}
GrVkPipelineState
*
GrVkGpuRTCommandBuffer
:
:
prepareDrawState
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
GrPrimitiveType
primitiveType
bool
hasDynamicState
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
SkASSERT
(
cbInfo
.
fRenderPass
)
;
GrVkPipelineState
*
pipelineState
=
fGpu
-
>
resourceProvider
(
)
.
findOrCreateCompatiblePipelineState
(
pipeline
primProc
primitiveType
*
cbInfo
.
fRenderPass
)
;
if
(
!
pipelineState
)
{
return
pipelineState
;
}
if
(
!
cbInfo
.
fIsEmpty
&
&
fLastPipelineState
&
&
fLastPipelineState
!
=
pipelineState
&
&
fGpu
-
>
vkCaps
(
)
.
newCBOnPipelineChange
(
)
)
{
this
-
>
addAdditionalCommandBuffer
(
)
;
}
fLastPipelineState
=
pipelineState
;
pipelineState
-
>
setData
(
fGpu
primProc
pipeline
)
;
pipelineState
-
>
bind
(
fGpu
cbInfo
.
currentCmdBuf
(
)
)
;
GrRenderTarget
*
rt
=
pipeline
.
renderTarget
(
)
;
if
(
!
pipeline
.
getScissorState
(
)
.
enabled
(
)
)
{
GrVkPipeline
:
:
SetDynamicScissorRectState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
rt
pipeline
.
proxy
(
)
-
>
origin
(
)
SkIRect
:
:
MakeWH
(
rt
-
>
width
(
)
rt
-
>
height
(
)
)
)
;
}
else
if
(
!
hasDynamicState
)
{
GrVkPipeline
:
:
SetDynamicScissorRectState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
rt
pipeline
.
proxy
(
)
-
>
origin
(
)
pipeline
.
getScissorState
(
)
.
rect
(
)
)
;
}
GrVkPipeline
:
:
SetDynamicViewportState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
rt
)
;
GrVkPipeline
:
:
SetDynamicBlendConstantState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
rt
-
>
config
(
)
pipeline
.
getXferProcessor
(
)
)
;
return
pipelineState
;
}
static
void
set_texture_layout
(
GrVkTexture
*
vkTexture
GrVkGpu
*
gpu
)
{
vkTexture
-
>
setImageLayout
(
gpu
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
VK_ACCESS_SHADER_READ_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
}
static
void
prepare_sampled_images
(
const
GrResourceIOProcessor
&
processor
GrVkGpu
*
gpu
)
{
for
(
int
i
=
0
;
i
<
processor
.
numTextureSamplers
(
)
;
+
+
i
)
{
const
GrResourceIOProcessor
:
:
TextureSampler
&
sampler
=
processor
.
textureSampler
(
i
)
;
GrVkTexture
*
vkTexture
=
static_cast
<
GrVkTexture
*
>
(
sampler
.
peekTexture
(
)
)
;
GrVkRenderTarget
*
texRT
=
static_cast
<
GrVkRenderTarget
*
>
(
vkTexture
-
>
asRenderTarget
(
)
)
;
if
(
texRT
)
{
gpu
-
>
onResolveRenderTarget
(
texRT
)
;
}
if
(
GrSamplerState
:
:
Filter
:
:
kMipMap
=
=
sampler
.
samplerState
(
)
.
filter
(
)
)
{
if
(
vkTexture
-
>
texturePriv
(
)
.
mipMapsAreDirty
(
)
)
{
gpu
-
>
generateMipmap
(
vkTexture
sampler
.
proxy
(
)
-
>
origin
(
)
)
;
vkTexture
-
>
texturePriv
(
)
.
markMipMapsClean
(
)
;
}
}
set_texture_layout
(
vkTexture
gpu
)
;
}
}
void
GrVkGpuRTCommandBuffer
:
:
onDraw
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
const
GrMesh
meshes
[
]
const
GrPipeline
:
:
DynamicState
dynamicStates
[
]
int
meshCount
const
SkRect
&
bounds
)
{
SkASSERT
(
pipeline
.
renderTarget
(
)
=
=
fRenderTarget
)
;
if
(
!
meshCount
)
{
return
;
}
prepare_sampled_images
(
primProc
fGpu
)
;
GrFragmentProcessor
:
:
Iter
iter
(
pipeline
)
;
while
(
const
GrFragmentProcessor
*
fp
=
iter
.
next
(
)
)
{
prepare_sampled_images
(
*
fp
fGpu
)
;
}
if
(
GrTexture
*
dstTexture
=
pipeline
.
peekDstTexture
(
)
)
{
set_texture_layout
(
static_cast
<
GrVkTexture
*
>
(
dstTexture
)
fGpu
)
;
}
GrPrimitiveType
primitiveType
=
meshes
[
0
]
.
primitiveType
(
)
;
GrVkPipelineState
*
pipelineState
=
this
-
>
prepareDrawState
(
pipeline
primProc
primitiveType
SkToBool
(
dynamicStates
)
)
;
if
(
!
pipelineState
)
{
return
;
}
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
for
(
int
i
=
0
;
i
<
meshCount
;
+
+
i
)
{
const
GrMesh
&
mesh
=
meshes
[
i
]
;
if
(
mesh
.
primitiveType
(
)
!
=
primitiveType
)
{
pipelineState
-
>
freeTempResources
(
fGpu
)
;
SkDEBUGCODE
(
pipelineState
=
nullptr
)
;
primitiveType
=
mesh
.
primitiveType
(
)
;
pipelineState
=
this
-
>
prepareDrawState
(
pipeline
primProc
primitiveType
SkToBool
(
dynamicStates
)
)
;
if
(
!
pipelineState
)
{
return
;
}
}
if
(
dynamicStates
)
{
if
(
pipeline
.
getScissorState
(
)
.
enabled
(
)
)
{
GrVkPipeline
:
:
SetDynamicScissorRectState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
fRenderTarget
pipeline
.
proxy
(
)
-
>
origin
(
)
dynamicStates
[
i
]
.
fScissorRect
)
;
}
}
SkASSERT
(
pipelineState
)
;
mesh
.
sendToGpu
(
primProc
this
)
;
}
cbInfo
.
fBounds
.
join
(
bounds
)
;
cbInfo
.
fIsEmpty
=
false
;
pipelineState
-
>
freeTempResources
(
fGpu
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
sendInstancedMeshToGpu
(
const
GrPrimitiveProcessor
&
primProc
GrPrimitiveType
const
GrBuffer
*
vertexBuffer
int
vertexCount
int
baseVertex
const
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
this
-
>
bindGeometry
(
primProc
nullptr
vertexBuffer
instanceBuffer
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
draw
(
fGpu
vertexCount
instanceCount
baseVertex
baseInstance
)
;
fGpu
-
>
stats
(
)
-
>
incNumDraws
(
)
;
}
void
GrVkGpuRTCommandBuffer
:
:
sendIndexedInstancedMeshToGpu
(
const
GrPrimitiveProcessor
&
primProc
GrPrimitiveType
const
GrBuffer
*
indexBuffer
int
indexCount
int
baseIndex
const
GrBuffer
*
vertexBuffer
int
baseVertex
const
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
this
-
>
bindGeometry
(
primProc
indexBuffer
vertexBuffer
instanceBuffer
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
drawIndexed
(
fGpu
indexCount
instanceCount
baseIndex
baseVertex
baseInstance
)
;
fGpu
-
>
stats
(
)
-
>
incNumDraws
(
)
;
}
