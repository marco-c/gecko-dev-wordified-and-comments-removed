#
include
"
GrVkGpuCommandBuffer
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
GrVkCommandBuffer
.
h
"
#
include
"
GrVkGpu
.
h
"
#
include
"
GrVkPipeline
.
h
"
#
include
"
GrVkRenderPass
.
h
"
#
include
"
GrVkRenderTarget
.
h
"
#
include
"
GrVkResourceProvider
.
h
"
#
include
"
GrVkTexture
.
h
"
#
include
"
SkRect
.
h
"
void
get_vk_load_store_ops
(
const
GrGpuCommandBuffer
:
:
LoadAndStoreInfo
&
info
VkAttachmentLoadOp
*
loadOp
VkAttachmentStoreOp
*
storeOp
)
{
switch
(
info
.
fLoadOp
)
{
case
GrGpuCommandBuffer
:
:
LoadOp
:
:
kLoad
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_LOAD
;
break
;
case
GrGpuCommandBuffer
:
:
LoadOp
:
:
kClear
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_CLEAR
;
break
;
case
GrGpuCommandBuffer
:
:
LoadOp
:
:
kDiscard
:
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_DONT_CARE
;
break
;
default
:
SK_ABORT
(
"
Invalid
LoadOp
"
)
;
*
loadOp
=
VK_ATTACHMENT_LOAD_OP_LOAD
;
}
switch
(
info
.
fStoreOp
)
{
case
GrGpuCommandBuffer
:
:
StoreOp
:
:
kStore
:
*
storeOp
=
VK_ATTACHMENT_STORE_OP_STORE
;
break
;
case
GrGpuCommandBuffer
:
:
StoreOp
:
:
kDiscard
:
*
storeOp
=
VK_ATTACHMENT_STORE_OP_DONT_CARE
;
break
;
default
:
SK_ABORT
(
"
Invalid
StoreOp
"
)
;
*
storeOp
=
VK_ATTACHMENT_STORE_OP_STORE
;
}
}
GrVkGpuCommandBuffer
:
:
GrVkGpuCommandBuffer
(
GrVkGpu
*
gpu
const
LoadAndStoreInfo
&
colorInfo
const
LoadAndStoreInfo
&
stencilInfo
)
:
fGpu
(
gpu
)
fRenderTarget
(
nullptr
)
fClearColor
(
GrColor4f
:
:
FromGrColor
(
colorInfo
.
fClearColor
)
)
fLastPipelineState
(
nullptr
)
{
get_vk_load_store_ops
(
colorInfo
&
fVkColorLoadOp
&
fVkColorStoreOp
)
;
get_vk_load_store_ops
(
stencilInfo
&
fVkStencilLoadOp
&
fVkStencilStoreOp
)
;
fCurrentCmdInfo
=
-
1
;
}
void
GrVkGpuCommandBuffer
:
:
init
(
GrVkRenderTarget
*
target
)
{
SkASSERT
(
!
fRenderTarget
)
;
fRenderTarget
=
target
;
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
fVkColorLoadOp
fVkColorStoreOp
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
fVkStencilLoadOp
fVkStencilStoreOp
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
.
push_back
(
)
;
SkASSERT
(
fCommandBufferInfos
.
count
(
)
=
=
1
)
;
fCurrentCmdInfo
=
0
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
target
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
target
vkColorOps
vkStencilOps
)
;
}
cbInfo
.
fColorClearValue
.
color
.
float32
[
0
]
=
fClearColor
.
fRGBA
[
0
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
1
]
=
fClearColor
.
fRGBA
[
1
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
2
]
=
fClearColor
.
fRGBA
[
2
]
;
cbInfo
.
fColorClearValue
.
color
.
float32
[
3
]
=
fClearColor
.
fRGBA
[
3
]
;
cbInfo
.
fBounds
.
setEmpty
(
)
;
cbInfo
.
fIsEmpty
=
true
;
cbInfo
.
fStartsWithClear
=
false
;
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
target
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
GrVkGpuCommandBuffer
:
:
~
GrVkGpuCommandBuffer
(
)
{
for
(
int
i
=
0
;
i
<
fCommandBufferInfos
.
count
(
)
;
+
+
i
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
cbInfo
.
fCommandBuffers
.
count
(
)
;
+
+
j
)
{
cbInfo
.
fCommandBuffers
[
j
]
-
>
unref
(
fGpu
)
;
}
cbInfo
.
fRenderPass
-
>
unref
(
fGpu
)
;
}
}
GrGpu
*
GrVkGpuCommandBuffer
:
:
gpu
(
)
{
return
fGpu
;
}
GrRenderTarget
*
GrVkGpuCommandBuffer
:
:
renderTarget
(
)
{
return
fRenderTarget
;
}
void
GrVkGpuCommandBuffer
:
:
end
(
)
{
if
(
fCurrentCmdInfo
>
=
0
)
{
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
}
}
void
GrVkGpuCommandBuffer
:
:
onSubmit
(
)
{
if
(
!
fRenderTarget
)
{
return
;
}
GrVkImage
*
targetImage
=
fRenderTarget
-
>
msaaImage
(
)
?
fRenderTarget
-
>
msaaImage
(
)
:
fRenderTarget
;
targetImage
-
>
setImageLayout
(
fGpu
VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
if
(
GrStencilAttachment
*
stencil
=
fRenderTarget
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
)
{
GrVkStencilAttachment
*
vkStencil
=
(
GrVkStencilAttachment
*
)
stencil
;
vkStencil
-
>
setImageLayout
(
fGpu
VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
|
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
}
for
(
int
i
=
0
;
i
<
fCommandBufferInfos
.
count
(
)
;
+
+
i
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
cbInfo
.
fPreDrawUploads
.
count
(
)
;
+
+
j
)
{
InlineUploadInfo
&
iuInfo
=
cbInfo
.
fPreDrawUploads
[
j
]
;
iuInfo
.
fFlushState
-
>
doUpload
(
iuInfo
.
fUpload
)
;
}
#
if
0
if
(
cbInfo
.
fIsEmpty
&
&
!
cbInfo
.
fStartsWithClear
)
{
continue
;
}
#
endif
if
(
cbInfo
.
fBounds
.
intersect
(
0
0
SkIntToScalar
(
fRenderTarget
-
>
width
(
)
)
SkIntToScalar
(
fRenderTarget
-
>
height
(
)
)
)
)
{
SkIRect
iBounds
;
cbInfo
.
fBounds
.
roundOut
(
&
iBounds
)
;
fGpu
-
>
submitSecondaryCommandBuffer
(
cbInfo
.
fCommandBuffers
cbInfo
.
fRenderPass
&
cbInfo
.
fColorClearValue
fRenderTarget
iBounds
)
;
}
}
}
void
GrVkGpuCommandBuffer
:
:
discard
(
GrRenderTarget
*
rt
)
{
GrVkRenderTarget
*
target
=
static_cast
<
GrVkRenderTarget
*
>
(
rt
)
;
if
(
!
fRenderTarget
)
{
this
-
>
init
(
target
)
;
}
SkASSERT
(
target
=
=
fRenderTarget
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
if
(
cbInfo
.
fIsEmpty
)
{
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_DONT_CARE
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
VK_ATTACHMENT_LOAD_OP_DONT_CARE
VK_ATTACHMENT_STORE_OP_STORE
)
;
const
GrVkRenderPass
*
oldRP
=
cbInfo
.
fRenderPass
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
fRenderTarget
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
fRenderTarget
vkColorOps
vkStencilOps
)
;
}
SkASSERT
(
cbInfo
.
fRenderPass
-
>
isCompatible
(
*
oldRP
)
)
;
oldRP
-
>
unref
(
fGpu
)
;
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
cbInfo
.
fStartsWithClear
=
false
;
}
}
void
GrVkGpuCommandBuffer
:
:
onClearStencilClip
(
GrRenderTarget
*
rt
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
SkASSERT
(
!
clip
.
hasWindowRectangles
(
)
)
;
GrVkRenderTarget
*
target
=
static_cast
<
GrVkRenderTarget
*
>
(
rt
)
;
if
(
!
fRenderTarget
)
{
this
-
>
init
(
target
)
;
}
SkASSERT
(
target
=
=
fRenderTarget
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
GrStencilAttachment
*
sb
=
fRenderTarget
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
SkASSERT
(
sb
)
;
int
stencilBitCount
=
sb
-
>
bits
(
)
;
VkClearDepthStencilValue
vkStencilColor
;
memset
(
&
vkStencilColor
0
sizeof
(
VkClearDepthStencilValue
)
)
;
if
(
insideStencilMask
)
{
vkStencilColor
.
stencil
=
(
1
<
<
(
stencilBitCount
-
1
)
)
;
}
else
{
vkStencilColor
.
stencil
=
0
;
}
VkClearRect
clearRect
;
SkIRect
vkRect
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
vkRect
.
setXYWH
(
0
0
fRenderTarget
-
>
width
(
)
fRenderTarget
-
>
height
(
)
)
;
}
else
if
(
kBottomLeft_GrSurfaceOrigin
!
=
fRenderTarget
-
>
origin
(
)
)
{
vkRect
=
clip
.
scissorRect
(
)
;
}
else
{
const
SkIRect
&
scissor
=
clip
.
scissorRect
(
)
;
vkRect
.
setLTRB
(
scissor
.
fLeft
fRenderTarget
-
>
height
(
)
-
scissor
.
fBottom
scissor
.
fRight
fRenderTarget
-
>
height
(
)
-
scissor
.
fTop
)
;
}
clearRect
.
rect
.
offset
=
{
vkRect
.
fLeft
vkRect
.
fTop
}
;
clearRect
.
rect
.
extent
=
{
(
uint32_t
)
vkRect
.
width
(
)
(
uint32_t
)
vkRect
.
height
(
)
}
;
clearRect
.
baseArrayLayer
=
0
;
clearRect
.
layerCount
=
1
;
uint32_t
stencilIndex
;
SkAssertResult
(
cbInfo
.
fRenderPass
-
>
stencilAttachmentIndex
(
&
stencilIndex
)
)
;
VkClearAttachment
attachment
;
attachment
.
aspectMask
=
VK_IMAGE_ASPECT_STENCIL_BIT
;
attachment
.
colorAttachment
=
0
;
attachment
.
clearValue
.
depthStencil
=
vkStencilColor
;
cbInfo
.
currentCmdBuf
(
)
-
>
clearAttachments
(
fGpu
1
&
attachment
1
&
clearRect
)
;
cbInfo
.
fIsEmpty
=
false
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
}
else
{
cbInfo
.
fBounds
.
join
(
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
)
;
}
}
void
GrVkGpuCommandBuffer
:
:
onClear
(
GrRenderTarget
*
rt
const
GrFixedClip
&
clip
GrColor
color
)
{
SkASSERT
(
!
clip
.
hasWindowRectangles
(
)
)
;
GrVkRenderTarget
*
target
=
static_cast
<
GrVkRenderTarget
*
>
(
rt
)
;
if
(
!
fRenderTarget
)
{
this
-
>
init
(
target
)
;
}
SkASSERT
(
target
=
=
fRenderTarget
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
VkClearColorValue
vkColor
;
GrColorToRGBAFloat
(
color
vkColor
.
float32
)
;
if
(
cbInfo
.
fIsEmpty
&
&
!
clip
.
scissorEnabled
(
)
)
{
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_CLEAR
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
VK_ATTACHMENT_LOAD_OP_LOAD
VK_ATTACHMENT_STORE_OP_STORE
)
;
const
GrVkRenderPass
*
oldRP
=
cbInfo
.
fRenderPass
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
fRenderTarget
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
fRenderTarget
vkColorOps
vkStencilOps
)
;
}
SkASSERT
(
cbInfo
.
fRenderPass
-
>
isCompatible
(
*
oldRP
)
)
;
oldRP
-
>
unref
(
fGpu
)
;
GrColorToRGBAFloat
(
color
cbInfo
.
fColorClearValue
.
color
.
float32
)
;
cbInfo
.
fStartsWithClear
=
true
;
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
return
;
}
VkClearRect
clearRect
;
SkIRect
vkRect
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
vkRect
.
setXYWH
(
0
0
fRenderTarget
-
>
width
(
)
fRenderTarget
-
>
height
(
)
)
;
}
else
if
(
kBottomLeft_GrSurfaceOrigin
!
=
fRenderTarget
-
>
origin
(
)
)
{
vkRect
=
clip
.
scissorRect
(
)
;
}
else
{
const
SkIRect
&
scissor
=
clip
.
scissorRect
(
)
;
vkRect
.
setLTRB
(
scissor
.
fLeft
fRenderTarget
-
>
height
(
)
-
scissor
.
fBottom
scissor
.
fRight
fRenderTarget
-
>
height
(
)
-
scissor
.
fTop
)
;
}
clearRect
.
rect
.
offset
=
{
vkRect
.
fLeft
vkRect
.
fTop
}
;
clearRect
.
rect
.
extent
=
{
(
uint32_t
)
vkRect
.
width
(
)
(
uint32_t
)
vkRect
.
height
(
)
}
;
clearRect
.
baseArrayLayer
=
0
;
clearRect
.
layerCount
=
1
;
uint32_t
colorIndex
;
SkAssertResult
(
cbInfo
.
fRenderPass
-
>
colorAttachmentIndex
(
&
colorIndex
)
)
;
VkClearAttachment
attachment
;
attachment
.
aspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
attachment
.
colorAttachment
=
colorIndex
;
attachment
.
clearValue
.
color
=
vkColor
;
cbInfo
.
currentCmdBuf
(
)
-
>
clearAttachments
(
fGpu
1
&
attachment
1
&
clearRect
)
;
cbInfo
.
fIsEmpty
=
false
;
if
(
!
clip
.
scissorEnabled
(
)
)
{
cbInfo
.
fBounds
.
join
(
fRenderTarget
-
>
getBoundsRect
(
)
)
;
}
else
{
cbInfo
.
fBounds
.
join
(
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
)
;
}
return
;
}
void
GrVkGpuCommandBuffer
:
:
addAdditionalCommandBuffer
(
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
cbInfo
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
fRenderTarget
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
void
GrVkGpuCommandBuffer
:
:
addAdditionalRenderPass
(
)
{
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
currentCmdBuf
(
)
-
>
end
(
fGpu
)
;
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
.
push_back
(
)
;
fCurrentCmdInfo
+
+
;
GrVkRenderPass
:
:
LoadStoreOps
vkColorOps
(
VK_ATTACHMENT_LOAD_OP_LOAD
VK_ATTACHMENT_STORE_OP_STORE
)
;
GrVkRenderPass
:
:
LoadStoreOps
vkStencilOps
(
VK_ATTACHMENT_LOAD_OP_LOAD
VK_ATTACHMENT_STORE_OP_STORE
)
;
const
GrVkResourceProvider
:
:
CompatibleRPHandle
&
rpHandle
=
fRenderTarget
-
>
compatibleRenderPassHandle
(
)
;
if
(
rpHandle
.
isValid
(
)
)
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
rpHandle
vkColorOps
vkStencilOps
)
;
}
else
{
cbInfo
.
fRenderPass
=
fGpu
-
>
resourceProvider
(
)
.
findRenderPass
(
*
fRenderTarget
vkColorOps
vkStencilOps
)
;
}
cbInfo
.
fCommandBuffers
.
push_back
(
fGpu
-
>
resourceProvider
(
)
.
findOrCreateSecondaryCommandBuffer
(
)
)
;
memset
(
&
cbInfo
.
fColorClearValue
0
sizeof
(
VkClearValue
)
)
;
cbInfo
.
fBounds
.
setEmpty
(
)
;
cbInfo
.
fIsEmpty
=
true
;
cbInfo
.
fStartsWithClear
=
false
;
cbInfo
.
currentCmdBuf
(
)
-
>
begin
(
fGpu
fRenderTarget
-
>
framebuffer
(
)
cbInfo
.
fRenderPass
)
;
}
void
GrVkGpuCommandBuffer
:
:
inlineUpload
(
GrOpFlushState
*
state
GrDrawOp
:
:
DeferredUploadFn
&
upload
GrRenderTarget
*
rt
)
{
GrVkRenderTarget
*
target
=
static_cast
<
GrVkRenderTarget
*
>
(
rt
)
;
if
(
!
fRenderTarget
)
{
this
-
>
init
(
target
)
;
}
if
(
!
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fIsEmpty
)
{
this
-
>
addAdditionalRenderPass
(
)
;
}
fCommandBufferInfos
[
fCurrentCmdInfo
]
.
fPreDrawUploads
.
emplace_back
(
state
upload
)
;
}
void
GrVkGpuCommandBuffer
:
:
bindGeometry
(
const
GrPrimitiveProcessor
&
primProc
const
GrNonInstancedMesh
&
mesh
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
SkASSERT
(
!
mesh
.
vertexBuffer
(
)
-
>
isCPUBacked
(
)
)
;
GrVkVertexBuffer
*
vbuf
;
vbuf
=
(
GrVkVertexBuffer
*
)
mesh
.
vertexBuffer
(
)
;
SkASSERT
(
vbuf
)
;
SkASSERT
(
!
vbuf
-
>
isMapped
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
bindVertexBuffer
(
fGpu
vbuf
)
;
if
(
mesh
.
isIndexed
(
)
)
{
SkASSERT
(
!
mesh
.
indexBuffer
(
)
-
>
isCPUBacked
(
)
)
;
GrVkIndexBuffer
*
ibuf
=
(
GrVkIndexBuffer
*
)
mesh
.
indexBuffer
(
)
;
SkASSERT
(
ibuf
)
;
SkASSERT
(
!
ibuf
-
>
isMapped
(
)
)
;
cbInfo
.
currentCmdBuf
(
)
-
>
bindIndexBuffer
(
fGpu
ibuf
)
;
}
}
sk_sp
<
GrVkPipelineState
>
GrVkGpuCommandBuffer
:
:
prepareDrawState
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
GrPrimitiveType
primitiveType
)
{
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
SkASSERT
(
cbInfo
.
fRenderPass
)
;
sk_sp
<
GrVkPipelineState
>
pipelineState
=
fGpu
-
>
resourceProvider
(
)
.
findOrCreateCompatiblePipelineState
(
pipeline
primProc
primitiveType
*
cbInfo
.
fRenderPass
)
;
if
(
!
pipelineState
)
{
return
pipelineState
;
}
if
(
!
cbInfo
.
fIsEmpty
&
&
fLastPipelineState
&
&
fLastPipelineState
!
=
pipelineState
.
get
(
)
&
&
fGpu
-
>
vkCaps
(
)
.
newSecondaryCBOnPipelineChange
(
)
)
{
this
-
>
addAdditionalCommandBuffer
(
)
;
}
fLastPipelineState
=
pipelineState
.
get
(
)
;
pipelineState
-
>
setData
(
fGpu
primProc
pipeline
)
;
pipelineState
-
>
bind
(
fGpu
cbInfo
.
currentCmdBuf
(
)
)
;
GrVkPipeline
:
:
SetDynamicState
(
fGpu
cbInfo
.
currentCmdBuf
(
)
pipeline
)
;
return
pipelineState
;
}
static
void
set_texture_layout
(
GrVkTexture
*
vkTexture
GrVkGpu
*
gpu
)
{
vkTexture
-
>
setImageLayout
(
gpu
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
VK_ACCESS_SHADER_READ_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
}
static
void
prepare_sampled_images
(
const
GrResourceIOProcessor
&
processor
GrVkGpu
*
gpu
)
{
for
(
int
i
=
0
;
i
<
processor
.
numTextureSamplers
(
)
;
+
+
i
)
{
const
GrResourceIOProcessor
:
:
TextureSampler
&
sampler
=
processor
.
textureSampler
(
i
)
;
GrVkTexture
*
vkTexture
=
static_cast
<
GrVkTexture
*
>
(
sampler
.
texture
(
)
)
;
SkASSERT
(
vkTexture
)
;
GrVkRenderTarget
*
texRT
=
static_cast
<
GrVkRenderTarget
*
>
(
vkTexture
-
>
asRenderTarget
(
)
)
;
if
(
texRT
)
{
gpu
-
>
onResolveRenderTarget
(
texRT
)
;
}
const
GrSamplerParams
&
params
=
sampler
.
params
(
)
;
if
(
GrSamplerParams
:
:
kMipMap_FilterMode
=
=
params
.
filterMode
(
)
)
{
if
(
vkTexture
-
>
texturePriv
(
)
.
mipMapsAreDirty
(
)
)
{
gpu
-
>
generateMipmap
(
vkTexture
)
;
vkTexture
-
>
texturePriv
(
)
.
dirtyMipMaps
(
false
)
;
}
}
set_texture_layout
(
vkTexture
gpu
)
;
}
}
void
GrVkGpuCommandBuffer
:
:
onDraw
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
const
GrMesh
*
meshes
int
meshCount
const
SkRect
&
bounds
)
{
GrVkRenderTarget
*
target
=
static_cast
<
GrVkRenderTarget
*
>
(
pipeline
.
getRenderTarget
(
)
)
;
if
(
!
fRenderTarget
)
{
this
-
>
init
(
target
)
;
}
SkASSERT
(
target
=
=
fRenderTarget
)
;
if
(
!
meshCount
)
{
return
;
}
prepare_sampled_images
(
primProc
fGpu
)
;
GrFragmentProcessor
:
:
Iter
iter
(
pipeline
)
;
while
(
const
GrFragmentProcessor
*
fp
=
iter
.
next
(
)
)
{
prepare_sampled_images
(
*
fp
fGpu
)
;
}
if
(
GrVkTexture
*
dstTexture
=
static_cast
<
GrVkTexture
*
>
(
pipeline
.
dstTexture
(
)
)
)
{
set_texture_layout
(
dstTexture
fGpu
)
;
}
GrPrimitiveType
primitiveType
=
meshes
[
0
]
.
primitiveType
(
)
;
sk_sp
<
GrVkPipelineState
>
pipelineState
=
this
-
>
prepareDrawState
(
pipeline
primProc
primitiveType
)
;
if
(
!
pipelineState
)
{
return
;
}
CommandBufferInfo
&
cbInfo
=
fCommandBufferInfos
[
fCurrentCmdInfo
]
;
for
(
int
i
=
0
;
i
<
meshCount
;
+
+
i
)
{
const
GrMesh
&
mesh
=
meshes
[
i
]
;
GrMesh
:
:
Iterator
iter
;
const
GrNonInstancedMesh
*
nonIdxMesh
=
iter
.
init
(
mesh
)
;
do
{
if
(
nonIdxMesh
-
>
primitiveType
(
)
!
=
primitiveType
)
{
pipelineState
-
>
freeTempResources
(
fGpu
)
;
SkDEBUGCODE
(
pipelineState
=
nullptr
)
;
primitiveType
=
nonIdxMesh
-
>
primitiveType
(
)
;
pipelineState
=
this
-
>
prepareDrawState
(
pipeline
primProc
primitiveType
)
;
if
(
!
pipelineState
)
{
return
;
}
}
SkASSERT
(
pipelineState
)
;
this
-
>
bindGeometry
(
primProc
*
nonIdxMesh
)
;
if
(
nonIdxMesh
-
>
isIndexed
(
)
)
{
cbInfo
.
currentCmdBuf
(
)
-
>
drawIndexed
(
fGpu
nonIdxMesh
-
>
indexCount
(
)
1
nonIdxMesh
-
>
startIndex
(
)
nonIdxMesh
-
>
startVertex
(
)
0
)
;
}
else
{
cbInfo
.
currentCmdBuf
(
)
-
>
draw
(
fGpu
nonIdxMesh
-
>
vertexCount
(
)
1
nonIdxMesh
-
>
startVertex
(
)
0
)
;
}
cbInfo
.
fIsEmpty
=
false
;
fGpu
-
>
stats
(
)
-
>
incNumDraws
(
)
;
}
while
(
(
nonIdxMesh
=
iter
.
next
(
)
)
)
;
}
cbInfo
.
fBounds
.
join
(
bounds
)
;
pipelineState
-
>
freeTempResources
(
fGpu
)
;
}
