#
include
"
GrVkGpu
.
h
"
#
include
"
GrBackendSemaphore
.
h
"
#
include
"
GrBackendSurface
.
h
"
#
include
"
GrContextOptions
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrGpuResourceCacheAccess
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
GrVkCommandBuffer
.
h
"
#
include
"
GrVkGpuCommandBuffer
.
h
"
#
include
"
GrVkImage
.
h
"
#
include
"
GrVkIndexBuffer
.
h
"
#
include
"
GrVkMemory
.
h
"
#
include
"
GrVkPipeline
.
h
"
#
include
"
GrVkPipelineState
.
h
"
#
include
"
GrVkRenderPass
.
h
"
#
include
"
GrVkResourceProvider
.
h
"
#
include
"
GrVkSemaphore
.
h
"
#
include
"
GrVkTexelBuffer
.
h
"
#
include
"
GrVkTexture
.
h
"
#
include
"
GrVkTextureRenderTarget
.
h
"
#
include
"
GrVkTransferBuffer
.
h
"
#
include
"
GrVkVertexBuffer
.
h
"
#
include
"
SkConvertPixels
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
vk
/
GrVkInterface
.
h
"
#
include
"
vk
/
GrVkTypes
.
h
"
#
include
"
SkSLCompiler
.
h
"
#
if
!
defined
(
SK_BUILD_FOR_WIN
)
#
include
<
unistd
.
h
>
#
endif
#
define
VK_CALL
(
X
)
GR_VK_CALL
(
this
-
>
vkInterface
(
)
X
)
#
define
VK_CALL_RET
(
RET
X
)
GR_VK_CALL_RET
(
this
-
>
vkInterface
(
)
RET
X
)
#
define
VK_CALL_ERRCHECK
(
X
)
GR_VK_CALL_ERRCHECK
(
this
-
>
vkInterface
(
)
X
)
#
ifdef
SK_ENABLE_VK_LAYERS
VKAPI_ATTR
VkBool32
VKAPI_CALL
DebugReportCallback
(
VkDebugReportFlagsEXT
flags
VkDebugReportObjectTypeEXT
objectType
uint64_t
object
size_t
location
int32_t
messageCode
const
char
*
pLayerPrefix
const
char
*
pMessage
void
*
pUserData
)
{
if
(
flags
&
VK_DEBUG_REPORT_ERROR_BIT_EXT
)
{
SkDebugf
(
"
Vulkan
error
[
%
s
]
:
code
:
%
d
:
%
s
\
n
"
pLayerPrefix
messageCode
pMessage
)
;
return
VK_TRUE
;
}
else
if
(
flags
&
VK_DEBUG_REPORT_WARNING_BIT_EXT
)
{
SkDebugf
(
"
Vulkan
warning
[
%
s
]
:
code
:
%
d
:
%
s
\
n
"
pLayerPrefix
messageCode
pMessage
)
;
}
else
if
(
flags
&
VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT
)
{
SkDebugf
(
"
Vulkan
perf
warning
[
%
s
]
:
code
:
%
d
:
%
s
\
n
"
pLayerPrefix
messageCode
pMessage
)
;
}
else
{
SkDebugf
(
"
Vulkan
info
/
debug
[
%
s
]
:
code
:
%
d
:
%
s
\
n
"
pLayerPrefix
messageCode
pMessage
)
;
}
return
VK_FALSE
;
}
#
endif
sk_sp
<
GrGpu
>
GrVkGpu
:
:
Make
(
GrBackendContext
backendContext
const
GrContextOptions
&
options
GrContext
*
context
)
{
const
auto
*
backend
=
reinterpret_cast
<
const
GrVkBackendContext
*
>
(
backendContext
)
;
return
Make
(
sk_ref_sp
(
backend
)
options
context
)
;
}
sk_sp
<
GrGpu
>
GrVkGpu
:
:
Make
(
sk_sp
<
const
GrVkBackendContext
>
backendContext
const
GrContextOptions
&
options
GrContext
*
context
)
{
if
(
!
backendContext
)
{
return
nullptr
;
}
if
(
!
backendContext
-
>
fInterface
-
>
validate
(
backendContext
-
>
fExtensions
)
)
{
return
nullptr
;
}
return
sk_sp
<
GrGpu
>
(
new
GrVkGpu
(
context
options
std
:
:
move
(
backendContext
)
)
)
;
}
GrVkGpu
:
:
GrVkGpu
(
GrContext
*
context
const
GrContextOptions
&
options
sk_sp
<
const
GrVkBackendContext
>
backendCtx
)
:
INHERITED
(
context
)
fBackendContext
(
std
:
:
move
(
backendCtx
)
)
fDevice
(
fBackendContext
-
>
fDevice
)
fQueue
(
fBackendContext
-
>
fQueue
)
fResourceProvider
(
this
)
fDisconnected
(
false
)
{
#
ifdef
SK_ENABLE_VK_LAYERS
fCallback
=
VK_NULL_HANDLE
;
if
(
fBackendContext
-
>
fExtensions
&
kEXT_debug_report_GrVkExtensionFlag
)
{
VkDebugReportCallbackCreateInfoEXT
callbackCreateInfo
;
callbackCreateInfo
.
sType
=
VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
;
callbackCreateInfo
.
pNext
=
nullptr
;
callbackCreateInfo
.
flags
=
VK_DEBUG_REPORT_ERROR_BIT_EXT
|
VK_DEBUG_REPORT_WARNING_BIT_EXT
|
VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT
;
callbackCreateInfo
.
pfnCallback
=
&
DebugReportCallback
;
callbackCreateInfo
.
pUserData
=
nullptr
;
GR_VK_CALL_ERRCHECK
(
this
-
>
vkInterface
(
)
CreateDebugReportCallbackEXT
(
fBackendContext
-
>
fInstance
&
callbackCreateInfo
nullptr
&
fCallback
)
)
;
}
#
endif
fCompiler
=
new
SkSL
:
:
Compiler
(
)
;
fVkCaps
.
reset
(
new
GrVkCaps
(
options
this
-
>
vkInterface
(
)
fBackendContext
-
>
fPhysicalDevice
fBackendContext
-
>
fFeatures
fBackendContext
-
>
fExtensions
)
)
;
fCaps
.
reset
(
SkRef
(
fVkCaps
.
get
(
)
)
)
;
VK_CALL
(
GetPhysicalDeviceProperties
(
fBackendContext
-
>
fPhysicalDevice
&
fPhysDevProps
)
)
;
VK_CALL
(
GetPhysicalDeviceMemoryProperties
(
fBackendContext
-
>
fPhysicalDevice
&
fPhysDevMemProps
)
)
;
const
VkCommandPoolCreateInfo
cmdPoolInfo
=
{
VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
nullptr
VK_COMMAND_POOL_CREATE_TRANSIENT_BIT
|
VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
fBackendContext
-
>
fGraphicsQueueIndex
}
;
GR_VK_CALL_ERRCHECK
(
this
-
>
vkInterface
(
)
CreateCommandPool
(
fDevice
&
cmdPoolInfo
nullptr
&
fCmdPool
)
)
;
fResourceProvider
.
init
(
)
;
fCurrentCmdBuffer
=
fResourceProvider
.
findOrCreatePrimaryCommandBuffer
(
)
;
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
begin
(
this
)
;
fHeaps
[
kLinearImage_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSubAlloc_Strategy
16
*
1024
*
1024
)
)
;
fHeaps
[
kOptimalImage_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSubAlloc_Strategy
64
*
1024
*
1024
)
)
;
fHeaps
[
kSmallOptimalImage_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSubAlloc_Strategy
2
*
1024
*
1024
)
)
;
fHeaps
[
kVertexBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSingleAlloc_Strategy
0
)
)
;
fHeaps
[
kIndexBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSingleAlloc_Strategy
0
)
)
;
fHeaps
[
kUniformBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSubAlloc_Strategy
256
*
1024
)
)
;
fHeaps
[
kTexelBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSingleAlloc_Strategy
0
)
)
;
fHeaps
[
kCopyReadBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSingleAlloc_Strategy
0
)
)
;
fHeaps
[
kCopyWriteBuffer_Heap
]
.
reset
(
new
GrVkHeap
(
this
GrVkHeap
:
:
kSubAlloc_Strategy
16
*
1024
*
1024
)
)
;
}
void
GrVkGpu
:
:
destroyResources
(
)
{
if
(
fCurrentCmdBuffer
)
{
fCurrentCmdBuffer
-
>
end
(
this
)
;
fCurrentCmdBuffer
-
>
unref
(
this
)
;
}
fResourceProvider
.
checkCommandBuffers
(
)
;
VkResult
res
=
VK_CALL
(
QueueWaitIdle
(
fQueue
)
)
;
#
ifdef
SK_DEBUG
if
(
this
-
>
vkCaps
(
)
.
mustSleepOnTearDown
(
)
)
{
#
if
defined
(
SK_BUILD_FOR_WIN
)
Sleep
(
10
)
;
#
else
sleep
(
1
)
;
#
endif
}
#
endif
#
ifdef
SK_DEBUG
SkASSERT
(
VK_SUCCESS
=
=
res
|
|
VK_ERROR_DEVICE_LOST
=
=
res
)
;
#
endif
for
(
int
i
=
0
;
i
<
fSemaphoresToWaitOn
.
count
(
)
;
+
+
i
)
{
fSemaphoresToWaitOn
[
i
]
-
>
unref
(
this
)
;
}
fSemaphoresToWaitOn
.
reset
(
)
;
for
(
int
i
=
0
;
i
<
fSemaphoresToSignal
.
count
(
)
;
+
+
i
)
{
fSemaphoresToSignal
[
i
]
-
>
unref
(
this
)
;
}
fSemaphoresToSignal
.
reset
(
)
;
fCopyManager
.
destroyResources
(
this
)
;
fResourceProvider
.
destroyResources
(
VK_ERROR_DEVICE_LOST
=
=
res
)
;
if
(
fCmdPool
!
=
VK_NULL_HANDLE
)
{
VK_CALL
(
DestroyCommandPool
(
fDevice
fCmdPool
nullptr
)
)
;
}
#
ifdef
SK_ENABLE_VK_LAYERS
if
(
fCallback
)
{
VK_CALL
(
DestroyDebugReportCallbackEXT
(
fBackendContext
-
>
fInstance
fCallback
nullptr
)
)
;
}
#
endif
}
GrVkGpu
:
:
~
GrVkGpu
(
)
{
if
(
!
fDisconnected
)
{
this
-
>
destroyResources
(
)
;
}
delete
fCompiler
;
}
void
GrVkGpu
:
:
disconnect
(
DisconnectType
type
)
{
INHERITED
:
:
disconnect
(
type
)
;
if
(
!
fDisconnected
)
{
if
(
DisconnectType
:
:
kCleanup
=
=
type
)
{
this
-
>
destroyResources
(
)
;
}
else
{
fCurrentCmdBuffer
-
>
unrefAndAbandon
(
)
;
for
(
int
i
=
0
;
i
<
fSemaphoresToWaitOn
.
count
(
)
;
+
+
i
)
{
fSemaphoresToWaitOn
[
i
]
-
>
unrefAndAbandon
(
)
;
}
for
(
int
i
=
0
;
i
<
fSemaphoresToSignal
.
count
(
)
;
+
+
i
)
{
fSemaphoresToSignal
[
i
]
-
>
unrefAndAbandon
(
)
;
}
fCopyManager
.
abandonResources
(
)
;
fResourceProvider
.
abandonResources
(
)
;
}
fSemaphoresToWaitOn
.
reset
(
)
;
fSemaphoresToSignal
.
reset
(
)
;
#
ifdef
SK_ENABLE_VK_LAYERS
fCallback
=
VK_NULL_HANDLE
;
#
endif
fCurrentCmdBuffer
=
nullptr
;
fCmdPool
=
VK_NULL_HANDLE
;
fDisconnected
=
true
;
}
}
GrGpuRTCommandBuffer
*
GrVkGpu
:
:
createCommandBuffer
(
GrRenderTarget
*
rt
GrSurfaceOrigin
origin
const
GrGpuRTCommandBuffer
:
:
LoadAndStoreInfo
&
colorInfo
const
GrGpuRTCommandBuffer
:
:
StencilLoadAndStoreInfo
&
stencilInfo
)
{
return
new
GrVkGpuRTCommandBuffer
(
this
rt
origin
colorInfo
stencilInfo
)
;
}
GrGpuTextureCommandBuffer
*
GrVkGpu
:
:
createCommandBuffer
(
GrTexture
*
texture
GrSurfaceOrigin
origin
)
{
return
new
GrVkGpuTextureCommandBuffer
(
this
texture
origin
)
;
}
void
GrVkGpu
:
:
submitCommandBuffer
(
SyncQueue
sync
)
{
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
end
(
this
)
;
fCurrentCmdBuffer
-
>
submitToQueue
(
this
fQueue
sync
fSemaphoresToSignal
fSemaphoresToWaitOn
)
;
for
(
int
i
=
0
;
i
<
fSemaphoresToWaitOn
.
count
(
)
;
+
+
i
)
{
fSemaphoresToWaitOn
[
i
]
-
>
unref
(
this
)
;
}
fSemaphoresToWaitOn
.
reset
(
)
;
for
(
int
i
=
0
;
i
<
fSemaphoresToSignal
.
count
(
)
;
+
+
i
)
{
fSemaphoresToSignal
[
i
]
-
>
unref
(
this
)
;
}
fSemaphoresToSignal
.
reset
(
)
;
fResourceProvider
.
checkCommandBuffers
(
)
;
fCurrentCmdBuffer
-
>
unref
(
this
)
;
fCurrentCmdBuffer
=
fResourceProvider
.
findOrCreatePrimaryCommandBuffer
(
)
;
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
begin
(
this
)
;
}
GrBuffer
*
GrVkGpu
:
:
onCreateBuffer
(
size_t
size
GrBufferType
type
GrAccessPattern
accessPattern
const
void
*
data
)
{
GrBuffer
*
buff
;
switch
(
type
)
{
case
kVertex_GrBufferType
:
SkASSERT
(
kDynamic_GrAccessPattern
=
=
accessPattern
|
|
kStatic_GrAccessPattern
=
=
accessPattern
)
;
buff
=
GrVkVertexBuffer
:
:
Create
(
this
size
kDynamic_GrAccessPattern
=
=
accessPattern
)
;
break
;
case
kIndex_GrBufferType
:
SkASSERT
(
kDynamic_GrAccessPattern
=
=
accessPattern
|
|
kStatic_GrAccessPattern
=
=
accessPattern
)
;
buff
=
GrVkIndexBuffer
:
:
Create
(
this
size
kDynamic_GrAccessPattern
=
=
accessPattern
)
;
break
;
case
kXferCpuToGpu_GrBufferType
:
SkASSERT
(
kDynamic_GrAccessPattern
=
=
accessPattern
|
|
kStream_GrAccessPattern
=
=
accessPattern
)
;
buff
=
GrVkTransferBuffer
:
:
Create
(
this
size
GrVkBuffer
:
:
kCopyRead_Type
)
;
break
;
case
kXferGpuToCpu_GrBufferType
:
SkASSERT
(
kDynamic_GrAccessPattern
=
=
accessPattern
|
|
kStream_GrAccessPattern
=
=
accessPattern
)
;
buff
=
GrVkTransferBuffer
:
:
Create
(
this
size
GrVkBuffer
:
:
kCopyWrite_Type
)
;
break
;
case
kTexel_GrBufferType
:
SkASSERT
(
kDynamic_GrAccessPattern
=
=
accessPattern
|
|
kStatic_GrAccessPattern
=
=
accessPattern
)
;
buff
=
GrVkTexelBuffer
:
:
Create
(
this
size
kDynamic_GrAccessPattern
=
=
accessPattern
)
;
break
;
case
kDrawIndirect_GrBufferType
:
SK_ABORT
(
"
DrawIndirect
Buffers
not
supported
in
vulkan
backend
.
"
)
;
return
nullptr
;
default
:
SK_ABORT
(
"
Unknown
buffer
type
.
"
)
;
return
nullptr
;
}
if
(
data
&
&
buff
)
{
buff
-
>
updateData
(
data
size
)
;
}
return
buff
;
}
bool
GrVkGpu
:
:
onGetWritePixelsInfo
(
GrSurface
*
dstSurface
GrSurfaceOrigin
dstOrigin
int
width
int
height
GrColorType
srcColorType
DrawPreference
*
drawPreference
WritePixelTempDrawInfo
*
tempDrawInfo
)
{
auto
srcConfigSRGBEncoded
=
GrPixelConfigIsSRGBEncoded
(
dstSurface
-
>
config
(
)
)
;
if
(
*
drawPreference
!
=
kNoDraw_DrawPreference
)
{
SkASSERT
(
tempDrawInfo
-
>
fWriteColorType
=
=
srcColorType
)
;
SkASSERT
(
GrPixelConfigToColorType
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
=
=
srcColorType
)
;
SkASSERT
(
tempDrawInfo
-
>
fSwizzle
=
=
GrSwizzle
:
:
RGBA
(
)
)
;
srcConfigSRGBEncoded
=
GrPixelConfigIsSRGBEncoded
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
;
}
if
(
GrColorTypeIsAlphaOnly
(
srcColorType
)
)
{
srcConfigSRGBEncoded
=
GrSRGBEncoded
:
:
kNo
;
}
GrRenderTarget
*
renderTarget
=
dstSurface
-
>
asRenderTarget
(
)
;
if
(
GrPixelConfigToColorType
(
dstSurface
-
>
config
(
)
)
=
=
srcColorType
)
{
if
(
!
dstSurface
-
>
asTexture
(
)
)
{
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
}
if
(
renderTarget
&
&
renderTarget
-
>
numColorSamples
(
)
>
1
)
{
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
}
return
true
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
auto
srcAsConfig
=
GrColorTypeToPixelConfig
(
srcColorType
srcConfigSRGBEncoded
)
;
SkASSERT
(
srcAsConfig
!
=
kUnknown_GrPixelConfig
)
;
bool
configsAreRBSwaps
=
GrPixelConfigSwapRAndB
(
srcAsConfig
)
=
=
dstSurface
-
>
config
(
)
;
if
(
!
this
-
>
vkCaps
(
)
.
isConfigTexturable
(
srcAsConfig
)
&
&
configsAreRBSwaps
)
{
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
=
dstSurface
-
>
config
(
)
;
tempDrawInfo
-
>
fSwizzle
=
GrSwizzle
:
:
BGRA
(
)
;
tempDrawInfo
-
>
fWriteColorType
=
GrPixelConfigToColorType
(
dstSurface
-
>
config
(
)
)
;
}
return
true
;
}
bool
GrVkGpu
:
:
onWritePixels
(
GrSurface
*
surface
GrSurfaceOrigin
origin
int
left
int
top
int
width
int
height
GrColorType
srcColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
{
GrVkTexture
*
vkTex
=
static_cast
<
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
;
if
(
!
vkTex
)
{
return
false
;
}
if
(
!
mipLevelCount
|
|
!
texels
[
0
]
.
fPixels
)
{
return
false
;
}
bool
success
=
false
;
bool
linearTiling
=
vkTex
-
>
isLinearTiled
(
)
;
if
(
linearTiling
)
{
if
(
mipLevelCount
>
1
)
{
SkDebugf
(
"
Can
'
t
upload
mipmap
data
to
linear
tiled
texture
"
)
;
return
false
;
}
if
(
VK_IMAGE_LAYOUT_PREINITIALIZED
!
=
vkTex
-
>
currentLayout
(
)
)
{
vkTex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_GENERAL
VK_ACCESS_HOST_WRITE_BIT
VK_PIPELINE_STAGE_HOST_BIT
false
)
;
this
-
>
submitCommandBuffer
(
kForce_SyncQueue
)
;
}
success
=
this
-
>
uploadTexDataLinear
(
vkTex
origin
left
top
width
height
srcColorType
texels
[
0
]
.
fPixels
texels
[
0
]
.
fRowBytes
)
;
}
else
{
int
currentMipLevels
=
vkTex
-
>
texturePriv
(
)
.
maxMipMapLevel
(
)
+
1
;
if
(
mipLevelCount
>
currentMipLevels
)
{
if
(
!
vkTex
-
>
reallocForMipmap
(
this
mipLevelCount
)
)
{
return
false
;
}
}
success
=
this
-
>
uploadTexDataOptimal
(
vkTex
origin
left
top
width
height
srcColorType
texels
mipLevelCount
)
;
}
return
success
;
}
bool
GrVkGpu
:
:
onTransferPixels
(
GrTexture
*
texture
int
left
int
top
int
width
int
height
GrColorType
bufferColorType
GrBuffer
*
transferBuffer
size_t
bufferOffset
size_t
rowBytes
)
{
if
(
SkToBool
(
bufferOffset
&
0x2
)
)
{
return
false
;
}
GrVkTexture
*
vkTex
=
static_cast
<
GrVkTexture
*
>
(
texture
)
;
if
(
!
vkTex
)
{
return
false
;
}
GrVkTransferBuffer
*
vkBuffer
=
static_cast
<
GrVkTransferBuffer
*
>
(
transferBuffer
)
;
if
(
!
vkBuffer
)
{
return
false
;
}
SkDEBUGCODE
(
SkIRect
subRect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
;
SkASSERT
(
bounds
.
contains
(
subRect
)
)
;
)
int
bpp
=
GrColorTypeBytesPerPixel
(
bufferColorType
)
;
if
(
rowBytes
=
=
0
)
{
rowBytes
=
bpp
*
width
;
}
VkBufferImageCopy
region
;
memset
(
&
region
0
sizeof
(
VkBufferImageCopy
)
)
;
region
.
bufferOffset
=
bufferOffset
;
region
.
bufferRowLength
=
(
uint32_t
)
(
rowBytes
/
bpp
)
;
region
.
bufferImageHeight
=
0
;
region
.
imageSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
region
.
imageOffset
=
{
left
top
0
}
;
region
.
imageExtent
=
{
(
uint32_t
)
width
(
uint32_t
)
height
1
}
;
vkTex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
fCurrentCmdBuffer
-
>
copyBufferToImage
(
this
vkBuffer
vkTex
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
1
&
region
)
;
vkTex
-
>
texturePriv
(
)
.
markMipMapsDirty
(
)
;
return
true
;
}
void
GrVkGpu
:
:
resolveImage
(
GrSurface
*
dst
GrVkRenderTarget
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
SkASSERT
(
dst
)
;
SkASSERT
(
src
&
&
src
-
>
numColorSamples
(
)
>
1
&
&
src
-
>
msaaImage
(
)
)
;
if
(
this
-
>
vkCaps
(
)
.
mustSubmitCommandsBeforeCopyOp
(
)
)
{
this
-
>
submitCommandBuffer
(
GrVkGpu
:
:
kSkip_SyncQueue
)
;
}
VkImageResolve
resolveInfo
;
resolveInfo
.
srcSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
resolveInfo
.
srcOffset
=
{
srcRect
.
fLeft
srcRect
.
fTop
0
}
;
resolveInfo
.
dstSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
resolveInfo
.
dstOffset
=
{
dstPoint
.
fX
dstPoint
.
fY
0
}
;
resolveInfo
.
extent
=
{
(
uint32_t
)
srcRect
.
width
(
)
(
uint32_t
)
srcRect
.
height
(
)
1
}
;
GrVkImage
*
dstImage
;
GrRenderTarget
*
dstRT
=
dst
-
>
asRenderTarget
(
)
;
if
(
dstRT
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
dstRT
)
;
dstImage
=
vkRT
;
}
else
{
SkASSERT
(
dst
-
>
asTexture
(
)
)
;
dstImage
=
static_cast
<
GrVkTexture
*
>
(
dst
-
>
asTexture
(
)
)
;
}
dstImage
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
src
-
>
msaaImage
(
)
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
fCurrentCmdBuffer
-
>
resolveImage
(
this
*
src
-
>
msaaImage
(
)
*
dstImage
1
&
resolveInfo
)
;
}
void
GrVkGpu
:
:
internalResolveRenderTarget
(
GrRenderTarget
*
target
bool
requiresSubmit
)
{
if
(
target
-
>
needsResolve
(
)
)
{
SkASSERT
(
target
-
>
numColorSamples
(
)
>
1
)
;
GrVkRenderTarget
*
rt
=
static_cast
<
GrVkRenderTarget
*
>
(
target
)
;
SkASSERT
(
rt
-
>
msaaImage
(
)
)
;
const
SkIRect
&
srcRect
=
rt
-
>
getResolveRect
(
)
;
this
-
>
resolveImage
(
target
rt
srcRect
SkIPoint
:
:
Make
(
srcRect
.
fLeft
srcRect
.
fTop
)
)
;
rt
-
>
flagAsResolved
(
)
;
if
(
requiresSubmit
)
{
this
-
>
submitCommandBuffer
(
kSkip_SyncQueue
)
;
}
}
}
bool
GrVkGpu
:
:
uploadTexDataLinear
(
GrVkTexture
*
tex
GrSurfaceOrigin
texOrigin
int
left
int
top
int
width
int
height
GrColorType
dataColorType
const
void
*
data
size_t
rowBytes
)
{
SkASSERT
(
data
)
;
SkASSERT
(
tex
-
>
isLinearTiled
(
)
)
;
SkDEBUGCODE
(
SkIRect
subRect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
tex
-
>
width
(
)
tex
-
>
height
(
)
)
;
SkASSERT
(
bounds
.
contains
(
subRect
)
)
;
)
int
bpp
=
GrColorTypeBytesPerPixel
(
dataColorType
)
;
size_t
trimRowBytes
=
width
*
bpp
;
if
(
!
rowBytes
)
{
rowBytes
=
trimRowBytes
;
}
SkASSERT
(
VK_IMAGE_LAYOUT_PREINITIALIZED
=
=
tex
-
>
currentLayout
(
)
|
|
VK_IMAGE_LAYOUT_GENERAL
=
=
tex
-
>
currentLayout
(
)
)
;
const
VkImageSubresource
subres
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
}
;
VkSubresourceLayout
layout
;
VkResult
err
;
const
GrVkInterface
*
interface
=
this
-
>
vkInterface
(
)
;
GR_VK_CALL
(
interface
GetImageSubresourceLayout
(
fDevice
tex
-
>
image
(
)
&
subres
&
layout
)
)
;
int
texTop
=
kBottomLeft_GrSurfaceOrigin
=
=
texOrigin
?
tex
-
>
height
(
)
-
top
-
height
:
top
;
const
GrVkAlloc
&
alloc
=
tex
-
>
alloc
(
)
;
VkDeviceSize
offset
=
alloc
.
fOffset
+
texTop
*
layout
.
rowPitch
+
left
*
bpp
;
VkDeviceSize
offsetDiff
=
0
;
VkDeviceSize
size
=
height
*
layout
.
rowPitch
;
if
(
SkToBool
(
alloc
.
fFlags
&
GrVkAlloc
:
:
kNoncoherent_Flag
)
)
{
VkDeviceSize
alignment
=
this
-
>
physicalDeviceProperties
(
)
.
limits
.
nonCoherentAtomSize
;
offsetDiff
=
offset
&
(
alignment
-
1
)
;
offset
=
offset
-
offsetDiff
;
size
=
(
size
+
alignment
-
1
)
&
~
(
alignment
-
1
)
;
}
SkASSERT
(
offset
>
=
alloc
.
fOffset
)
;
SkASSERT
(
size
<
=
alloc
.
fOffset
+
alloc
.
fSize
)
;
void
*
mapPtr
;
err
=
GR_VK_CALL
(
interface
MapMemory
(
fDevice
alloc
.
fMemory
offset
size
0
&
mapPtr
)
)
;
if
(
err
)
{
return
false
;
}
mapPtr
=
reinterpret_cast
<
char
*
>
(
mapPtr
)
+
offsetDiff
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
texOrigin
)
{
const
char
*
srcRow
=
reinterpret_cast
<
const
char
*
>
(
data
)
;
char
*
dstRow
=
reinterpret_cast
<
char
*
>
(
mapPtr
)
+
(
height
-
1
)
*
layout
.
rowPitch
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
memcpy
(
dstRow
srcRow
trimRowBytes
)
;
srcRow
+
=
rowBytes
;
dstRow
-
=
layout
.
rowPitch
;
}
}
else
{
SkRectMemcpy
(
mapPtr
static_cast
<
size_t
>
(
layout
.
rowPitch
)
data
rowBytes
trimRowBytes
height
)
;
}
GrVkMemory
:
:
FlushMappedAlloc
(
this
alloc
size
)
;
GR_VK_CALL
(
interface
UnmapMemory
(
fDevice
alloc
.
fMemory
)
)
;
return
true
;
}
bool
GrVkGpu
:
:
uploadTexDataOptimal
(
GrVkTexture
*
tex
GrSurfaceOrigin
texOrigin
int
left
int
top
int
width
int
height
GrColorType
dataColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
{
SkASSERT
(
!
tex
-
>
isLinearTiled
(
)
)
;
SkASSERT
(
1
=
=
mipLevelCount
|
|
(
0
=
=
left
&
&
0
=
=
top
&
&
width
=
=
tex
-
>
width
(
)
&
&
height
=
=
tex
-
>
height
(
)
)
)
;
SkASSERT
(
1
=
=
mipLevelCount
|
|
mipLevelCount
=
=
(
tex
-
>
texturePriv
(
)
.
maxMipMapLevel
(
)
+
1
)
)
;
if
(
width
=
=
0
|
|
height
=
=
0
)
{
return
false
;
}
SkASSERT
(
this
-
>
caps
(
)
-
>
isConfigTexturable
(
tex
-
>
config
(
)
)
)
;
int
bpp
=
GrColorTypeBytesPerPixel
(
dataColorType
)
;
SkAutoTMalloc
<
GrMipLevel
>
texelsShallowCopy
;
if
(
mipLevelCount
)
{
texelsShallowCopy
.
reset
(
mipLevelCount
)
;
memcpy
(
texelsShallowCopy
.
get
(
)
texels
mipLevelCount
*
sizeof
(
GrMipLevel
)
)
;
}
bool
flipY
=
(
kBottomLeft_GrSurfaceOrigin
=
=
texOrigin
&
&
mipLevelCount
)
;
SkTArray
<
size_t
>
individualMipOffsets
(
mipLevelCount
)
;
individualMipOffsets
.
push_back
(
0
)
;
size_t
combinedBufferSize
=
width
*
bpp
*
height
;
int
currentWidth
=
width
;
int
currentHeight
=
height
;
if
(
mipLevelCount
>
0
&
&
!
texelsShallowCopy
[
0
]
.
fPixels
)
{
combinedBufferSize
=
0
;
}
SkASSERT
(
(
bpp
&
(
bpp
-
1
)
)
=
=
0
)
;
const
size_t
alignmentMask
=
0x3
|
(
bpp
-
1
)
;
for
(
int
currentMipLevel
=
1
;
currentMipLevel
<
mipLevelCount
;
currentMipLevel
+
+
)
{
currentWidth
=
SkTMax
(
1
currentWidth
/
2
)
;
currentHeight
=
SkTMax
(
1
currentHeight
/
2
)
;
if
(
texelsShallowCopy
[
currentMipLevel
]
.
fPixels
)
{
const
size_t
trimmedSize
=
currentWidth
*
bpp
*
currentHeight
;
const
size_t
alignmentDiff
=
combinedBufferSize
&
alignmentMask
;
if
(
alignmentDiff
!
=
0
)
{
combinedBufferSize
+
=
alignmentMask
-
alignmentDiff
+
1
;
}
individualMipOffsets
.
push_back
(
combinedBufferSize
)
;
combinedBufferSize
+
=
trimmedSize
;
}
else
{
individualMipOffsets
.
push_back
(
0
)
;
}
}
if
(
0
=
=
combinedBufferSize
)
{
return
true
;
}
GrVkTransferBuffer
*
transferBuffer
=
GrVkTransferBuffer
:
:
Create
(
this
combinedBufferSize
GrVkBuffer
:
:
kCopyRead_Type
)
;
if
(
!
transferBuffer
)
{
return
false
;
}
char
*
buffer
=
(
char
*
)
transferBuffer
-
>
map
(
)
;
SkTArray
<
VkBufferImageCopy
>
regions
(
mipLevelCount
)
;
currentWidth
=
width
;
currentHeight
=
height
;
int
layerHeight
=
tex
-
>
height
(
)
;
for
(
int
currentMipLevel
=
0
;
currentMipLevel
<
mipLevelCount
;
currentMipLevel
+
+
)
{
if
(
texelsShallowCopy
[
currentMipLevel
]
.
fPixels
)
{
SkASSERT
(
1
=
=
mipLevelCount
|
|
currentHeight
=
=
layerHeight
)
;
const
size_t
trimRowBytes
=
currentWidth
*
bpp
;
const
size_t
rowBytes
=
texelsShallowCopy
[
currentMipLevel
]
.
fRowBytes
?
texelsShallowCopy
[
currentMipLevel
]
.
fRowBytes
:
trimRowBytes
;
char
*
dst
=
buffer
+
individualMipOffsets
[
currentMipLevel
]
;
const
char
*
src
=
(
const
char
*
)
texelsShallowCopy
[
currentMipLevel
]
.
fPixels
;
if
(
flipY
)
{
src
+
=
(
currentHeight
-
1
)
*
rowBytes
;
for
(
int
y
=
0
;
y
<
currentHeight
;
y
+
+
)
{
memcpy
(
dst
src
trimRowBytes
)
;
src
-
=
rowBytes
;
dst
+
=
trimRowBytes
;
}
}
else
{
SkRectMemcpy
(
dst
trimRowBytes
src
rowBytes
trimRowBytes
currentHeight
)
;
}
VkBufferImageCopy
&
region
=
regions
.
push_back
(
)
;
memset
(
&
region
0
sizeof
(
VkBufferImageCopy
)
)
;
region
.
bufferOffset
=
transferBuffer
-
>
offset
(
)
+
individualMipOffsets
[
currentMipLevel
]
;
region
.
bufferRowLength
=
currentWidth
;
region
.
bufferImageHeight
=
currentHeight
;
region
.
imageSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
SkToU32
(
currentMipLevel
)
0
1
}
;
region
.
imageOffset
=
{
left
flipY
?
layerHeight
-
top
-
currentHeight
:
top
0
}
;
region
.
imageExtent
=
{
(
uint32_t
)
currentWidth
(
uint32_t
)
currentHeight
1
}
;
}
currentWidth
=
SkTMax
(
1
currentWidth
/
2
)
;
currentHeight
=
SkTMax
(
1
currentHeight
/
2
)
;
layerHeight
=
currentHeight
;
}
transferBuffer
-
>
unmap
(
)
;
tex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
fCurrentCmdBuffer
-
>
copyBufferToImage
(
this
transferBuffer
tex
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
regions
.
count
(
)
regions
.
begin
(
)
)
;
transferBuffer
-
>
unref
(
)
;
if
(
1
=
=
mipLevelCount
)
{
tex
-
>
texturePriv
(
)
.
markMipMapsDirty
(
)
;
}
return
true
;
}
sk_sp
<
GrTexture
>
GrVkGpu
:
:
onCreateTexture
(
const
GrSurfaceDesc
&
desc
SkBudgeted
budgeted
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
{
bool
renderTarget
=
SkToBool
(
desc
.
fFlags
&
kRenderTarget_GrSurfaceFlag
)
;
VkFormat
pixelFormat
;
SkAssertResult
(
GrPixelConfigToVkFormat
(
desc
.
fConfig
&
pixelFormat
)
)
;
VkImageUsageFlags
usageFlags
=
VK_IMAGE_USAGE_SAMPLED_BIT
;
if
(
renderTarget
)
{
usageFlags
|
=
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
}
usageFlags
|
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
;
int
mipLevels
=
!
mipLevelCount
?
1
:
mipLevelCount
;
GrVkImage
:
:
ImageDesc
imageDesc
;
imageDesc
.
fImageType
=
VK_IMAGE_TYPE_2D
;
imageDesc
.
fFormat
=
pixelFormat
;
imageDesc
.
fWidth
=
desc
.
fWidth
;
imageDesc
.
fHeight
=
desc
.
fHeight
;
imageDesc
.
fLevels
=
mipLevels
;
imageDesc
.
fSamples
=
1
;
imageDesc
.
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
imageDesc
.
fUsageFlags
=
usageFlags
;
imageDesc
.
fMemProps
=
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
;
GrMipMapsStatus
mipMapsStatus
=
GrMipMapsStatus
:
:
kNotAllocated
;
if
(
mipLevels
>
1
)
{
mipMapsStatus
=
GrMipMapsStatus
:
:
kValid
;
for
(
int
i
=
0
;
i
<
mipLevels
;
+
+
i
)
{
if
(
!
texels
[
i
]
.
fPixels
)
{
mipMapsStatus
=
GrMipMapsStatus
:
:
kDirty
;
break
;
}
}
}
sk_sp
<
GrVkTexture
>
tex
;
if
(
renderTarget
)
{
tex
=
GrVkTextureRenderTarget
:
:
CreateNewTextureRenderTarget
(
this
budgeted
desc
imageDesc
mipMapsStatus
)
;
}
else
{
tex
=
GrVkTexture
:
:
CreateNewTexture
(
this
budgeted
desc
imageDesc
mipMapsStatus
)
;
}
if
(
!
tex
)
{
return
nullptr
;
}
auto
colorType
=
GrPixelConfigToColorType
(
desc
.
fConfig
)
;
if
(
mipLevelCount
)
{
if
(
!
this
-
>
uploadTexDataOptimal
(
tex
.
get
(
)
desc
.
fOrigin
0
0
desc
.
fWidth
desc
.
fHeight
colorType
texels
mipLevelCount
)
)
{
tex
-
>
unref
(
)
;
return
nullptr
;
}
}
if
(
desc
.
fFlags
&
kPerformInitialClear_GrSurfaceFlag
)
{
VkClearColorValue
zeroClearColor
;
memset
(
&
zeroClearColor
0
sizeof
(
zeroClearColor
)
)
;
VkImageSubresourceRange
range
;
range
.
aspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
range
.
baseArrayLayer
=
0
;
range
.
baseMipLevel
=
0
;
range
.
layerCount
=
1
;
range
.
levelCount
=
1
;
tex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
this
-
>
currentCommandBuffer
(
)
-
>
clearColorImage
(
this
tex
.
get
(
)
&
zeroClearColor
1
&
range
)
;
}
return
tex
;
}
void
GrVkGpu
:
:
copyBuffer
(
GrVkBuffer
*
srcBuffer
GrVkBuffer
*
dstBuffer
VkDeviceSize
srcOffset
VkDeviceSize
dstOffset
VkDeviceSize
size
)
{
VkBufferCopy
copyRegion
;
copyRegion
.
srcOffset
=
srcOffset
;
copyRegion
.
dstOffset
=
dstOffset
;
copyRegion
.
size
=
size
;
fCurrentCmdBuffer
-
>
copyBuffer
(
this
srcBuffer
dstBuffer
1
&
copyRegion
)
;
}
bool
GrVkGpu
:
:
updateBuffer
(
GrVkBuffer
*
buffer
const
void
*
src
VkDeviceSize
offset
VkDeviceSize
size
)
{
fCurrentCmdBuffer
-
>
updateBuffer
(
this
buffer
offset
size
src
)
;
return
true
;
}
static
bool
check_backend_texture
(
const
GrBackendTexture
&
backendTex
GrPixelConfig
config
)
{
const
GrVkImageInfo
*
info
=
backendTex
.
getVkImageInfo
(
)
;
if
(
!
info
)
{
return
false
;
}
if
(
VK_NULL_HANDLE
=
=
info
-
>
fImage
|
|
VK_NULL_HANDLE
=
=
info
-
>
fAlloc
.
fMemory
)
{
return
false
;
}
SkASSERT
(
GrVkFormatPixelConfigPairIsValid
(
info
-
>
fFormat
config
)
)
;
return
true
;
}
sk_sp
<
GrTexture
>
GrVkGpu
:
:
onWrapBackendTexture
(
const
GrBackendTexture
&
backendTex
GrWrapOwnership
ownership
)
{
if
(
!
check_backend_texture
(
backendTex
backendTex
.
config
(
)
)
)
{
return
nullptr
;
}
GrSurfaceDesc
surfDesc
;
surfDesc
.
fFlags
=
kNone_GrSurfaceFlags
;
surfDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
surfDesc
.
fWidth
=
backendTex
.
width
(
)
;
surfDesc
.
fHeight
=
backendTex
.
height
(
)
;
surfDesc
.
fConfig
=
backendTex
.
config
(
)
;
surfDesc
.
fSampleCnt
=
1
;
return
GrVkTexture
:
:
MakeWrappedTexture
(
this
surfDesc
ownership
backendTex
.
getVkImageInfo
(
)
)
;
}
sk_sp
<
GrTexture
>
GrVkGpu
:
:
onWrapRenderableBackendTexture
(
const
GrBackendTexture
&
backendTex
int
sampleCnt
GrWrapOwnership
ownership
)
{
if
(
!
check_backend_texture
(
backendTex
backendTex
.
config
(
)
)
)
{
return
nullptr
;
}
GrSurfaceDesc
surfDesc
;
surfDesc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
surfDesc
.
fOrigin
=
kBottomLeft_GrSurfaceOrigin
;
surfDesc
.
fWidth
=
backendTex
.
width
(
)
;
surfDesc
.
fHeight
=
backendTex
.
height
(
)
;
surfDesc
.
fConfig
=
backendTex
.
config
(
)
;
surfDesc
.
fSampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
backendTex
.
config
(
)
)
;
return
GrVkTextureRenderTarget
:
:
MakeWrappedTextureRenderTarget
(
this
surfDesc
ownership
backendTex
.
getVkImageInfo
(
)
)
;
}
sk_sp
<
GrRenderTarget
>
GrVkGpu
:
:
onWrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
backendRT
)
{
if
(
backendRT
.
sampleCnt
(
)
>
1
)
{
return
nullptr
;
}
const
GrVkImageInfo
*
info
=
backendRT
.
getVkImageInfo
(
)
;
if
(
!
info
)
{
return
nullptr
;
}
if
(
VK_NULL_HANDLE
=
=
info
-
>
fImage
)
{
return
nullptr
;
}
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fOrigin
=
kBottomLeft_GrSurfaceOrigin
;
desc
.
fWidth
=
backendRT
.
width
(
)
;
desc
.
fHeight
=
backendRT
.
height
(
)
;
desc
.
fConfig
=
backendRT
.
config
(
)
;
desc
.
fSampleCnt
=
1
;
sk_sp
<
GrVkRenderTarget
>
tgt
=
GrVkRenderTarget
:
:
MakeWrappedRenderTarget
(
this
desc
info
)
;
if
(
tgt
&
&
backendRT
.
stencilBits
(
)
)
{
if
(
!
createStencilAttachmentForRenderTarget
(
tgt
.
get
(
)
desc
.
fWidth
desc
.
fHeight
)
)
{
return
nullptr
;
}
}
return
tgt
;
}
sk_sp
<
GrRenderTarget
>
GrVkGpu
:
:
onWrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
tex
int
sampleCnt
)
{
const
GrVkImageInfo
*
info
=
tex
.
getVkImageInfo
(
)
;
if
(
!
info
)
{
return
nullptr
;
}
if
(
VK_NULL_HANDLE
=
=
info
-
>
fImage
)
{
return
nullptr
;
}
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fOrigin
=
kBottomLeft_GrSurfaceOrigin
;
desc
.
fWidth
=
tex
.
width
(
)
;
desc
.
fHeight
=
tex
.
height
(
)
;
desc
.
fConfig
=
tex
.
config
(
)
;
desc
.
fSampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
tex
.
config
(
)
)
;
if
(
!
desc
.
fSampleCnt
)
{
return
nullptr
;
}
sk_sp
<
GrVkRenderTarget
>
tgt
=
GrVkRenderTarget
:
:
MakeWrappedRenderTarget
(
this
desc
info
)
;
return
tgt
;
}
void
GrVkGpu
:
:
generateMipmap
(
GrVkTexture
*
tex
GrSurfaceOrigin
texOrigin
)
{
if
(
tex
-
>
isLinearTiled
(
)
)
{
SkDebugf
(
"
Trying
to
create
mipmap
for
linear
tiled
texture
"
)
;
return
;
}
const
GrVkCaps
&
caps
=
this
-
>
vkCaps
(
)
;
if
(
!
caps
.
configCanBeDstofBlit
(
tex
-
>
config
(
)
false
)
|
|
!
caps
.
configCanBeSrcofBlit
(
tex
-
>
config
(
)
false
)
|
|
!
caps
.
mipMapSupport
(
)
)
{
return
;
}
if
(
this
-
>
vkCaps
(
)
.
mustSubmitCommandsBeforeCopyOp
(
)
)
{
this
-
>
submitCommandBuffer
(
kSkip_SyncQueue
)
;
}
GrVkRenderTarget
*
texRT
=
static_cast
<
GrVkRenderTarget
*
>
(
tex
-
>
asRenderTarget
(
)
)
;
if
(
texRT
)
{
this
-
>
internalResolveRenderTarget
(
texRT
false
)
;
}
int
width
=
tex
-
>
width
(
)
;
int
height
=
tex
-
>
height
(
)
;
VkImageBlit
blitRegion
;
memset
(
&
blitRegion
0
sizeof
(
VkImageBlit
)
)
;
uint32_t
levelCount
=
SkMipMap
:
:
ComputeLevelCount
(
tex
-
>
width
(
)
tex
-
>
height
(
)
)
+
1
;
if
(
levelCount
!
=
tex
-
>
mipLevels
(
)
)
{
const
GrVkResource
*
oldResource
=
tex
-
>
resource
(
)
;
oldResource
-
>
ref
(
)
;
VkImage
oldImage
=
tex
-
>
image
(
)
;
tex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
if
(
!
tex
-
>
reallocForMipmap
(
this
levelCount
)
)
{
oldResource
-
>
unref
(
this
)
;
return
;
}
tex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_GENERAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
blitRegion
.
srcSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
blitRegion
.
srcOffsets
[
0
]
=
{
0
0
0
}
;
blitRegion
.
srcOffsets
[
1
]
=
{
width
height
1
}
;
blitRegion
.
dstSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
blitRegion
.
dstOffsets
[
0
]
=
{
0
0
0
}
;
blitRegion
.
dstOffsets
[
1
]
=
{
width
height
1
}
;
fCurrentCmdBuffer
-
>
blitImage
(
this
oldResource
oldImage
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
tex
-
>
resource
(
)
tex
-
>
image
(
)
VK_IMAGE_LAYOUT_GENERAL
1
&
blitRegion
VK_FILTER_LINEAR
)
;
oldResource
-
>
unref
(
this
)
;
}
else
{
tex
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_GENERAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
}
SkASSERT
(
GrVkFormatIsSupported
(
tex
-
>
imageFormat
(
)
)
)
;
VkImageAspectFlags
aspectFlags
=
VK_IMAGE_ASPECT_COLOR_BIT
;
VkImageMemoryBarrier
imageMemoryBarrier
=
{
VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
nullptr
VK_ACCESS_TRANSFER_WRITE_BIT
VK_ACCESS_TRANSFER_READ_BIT
VK_IMAGE_LAYOUT_GENERAL
VK_IMAGE_LAYOUT_GENERAL
VK_QUEUE_FAMILY_IGNORED
VK_QUEUE_FAMILY_IGNORED
tex
-
>
image
(
)
{
aspectFlags
0
1
0
1
}
}
;
uint32_t
mipLevel
=
1
;
while
(
mipLevel
<
levelCount
)
{
int
prevWidth
=
width
;
int
prevHeight
=
height
;
width
=
SkTMax
(
1
width
/
2
)
;
height
=
SkTMax
(
1
height
/
2
)
;
imageMemoryBarrier
.
subresourceRange
.
baseMipLevel
=
mipLevel
-
1
;
this
-
>
addImageMemoryBarrier
(
VK_PIPELINE_STAGE_TRANSFER_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
&
imageMemoryBarrier
)
;
blitRegion
.
srcSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
mipLevel
-
1
0
1
}
;
blitRegion
.
srcOffsets
[
0
]
=
{
0
0
0
}
;
blitRegion
.
srcOffsets
[
1
]
=
{
prevWidth
prevHeight
1
}
;
blitRegion
.
dstSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
mipLevel
0
1
}
;
blitRegion
.
dstOffsets
[
0
]
=
{
0
0
0
}
;
blitRegion
.
dstOffsets
[
1
]
=
{
width
height
1
}
;
fCurrentCmdBuffer
-
>
blitImage
(
this
*
tex
*
tex
1
&
blitRegion
VK_FILTER_LINEAR
)
;
+
+
mipLevel
;
}
}
GrStencilAttachment
*
GrVkGpu
:
:
createStencilAttachmentForRenderTarget
(
const
GrRenderTarget
*
rt
int
width
int
height
)
{
SkASSERT
(
width
>
=
rt
-
>
width
(
)
)
;
SkASSERT
(
height
>
=
rt
-
>
height
(
)
)
;
int
samples
=
rt
-
>
numStencilSamples
(
)
;
const
GrVkCaps
:
:
StencilFormat
&
sFmt
=
this
-
>
vkCaps
(
)
.
preferedStencilFormat
(
)
;
GrVkStencilAttachment
*
stencil
(
GrVkStencilAttachment
:
:
Create
(
this
width
height
samples
sFmt
)
)
;
fStats
.
incStencilAttachmentCreates
(
)
;
return
stencil
;
}
bool
copy_testing_data
(
GrVkGpu
*
gpu
void
*
srcData
const
GrVkAlloc
&
alloc
size_t
bufferOffset
size_t
srcRowBytes
size_t
dstRowBytes
int
h
)
{
VkDeviceSize
mapSize
=
dstRowBytes
*
h
;
VkDeviceSize
mapOffset
=
alloc
.
fOffset
+
bufferOffset
;
VkDeviceSize
offsetDiff
=
0
;
if
(
SkToBool
(
alloc
.
fFlags
&
GrVkAlloc
:
:
kNoncoherent_Flag
)
)
{
VkDeviceSize
alignment
=
gpu
-
>
physicalDeviceProperties
(
)
.
limits
.
nonCoherentAtomSize
;
offsetDiff
=
mapOffset
&
(
alignment
-
1
)
;
mapOffset
=
mapOffset
-
offsetDiff
;
mapSize
=
(
mapSize
+
alignment
-
1
)
&
~
(
alignment
-
1
)
;
}
SkASSERT
(
mapOffset
>
=
alloc
.
fOffset
)
;
SkASSERT
(
mapSize
+
mapOffset
<
=
alloc
.
fOffset
+
alloc
.
fSize
)
;
void
*
mapPtr
;
VkResult
err
=
GR_VK_CALL
(
gpu
-
>
vkInterface
(
)
MapMemory
(
gpu
-
>
device
(
)
alloc
.
fMemory
mapOffset
mapSize
0
&
mapPtr
)
)
;
mapPtr
=
reinterpret_cast
<
char
*
>
(
mapPtr
)
+
offsetDiff
;
if
(
err
)
{
return
false
;
}
if
(
srcData
)
{
SkRectMemcpy
(
mapPtr
static_cast
<
size_t
>
(
dstRowBytes
)
srcData
srcRowBytes
srcRowBytes
h
)
;
}
else
{
if
(
srcRowBytes
=
=
static_cast
<
size_t
>
(
dstRowBytes
)
)
{
memset
(
mapPtr
0
srcRowBytes
*
h
)
;
}
else
{
for
(
int
i
=
0
;
i
<
h
;
+
+
i
)
{
memset
(
mapPtr
0
srcRowBytes
)
;
mapPtr
=
SkTAddOffset
<
void
>
(
mapPtr
static_cast
<
size_t
>
(
dstRowBytes
)
)
;
}
}
}
GrVkMemory
:
:
FlushMappedAlloc
(
gpu
alloc
mapSize
)
;
GR_VK_CALL
(
gpu
-
>
vkInterface
(
)
UnmapMemory
(
gpu
-
>
device
(
)
alloc
.
fMemory
)
)
;
return
true
;
}
GrBackendTexture
GrVkGpu
:
:
createTestingOnlyBackendTexture
(
void
*
srcData
int
w
int
h
GrPixelConfig
config
bool
isRenderTarget
GrMipMapped
mipMapped
)
{
VkFormat
pixelFormat
;
if
(
!
GrPixelConfigToVkFormat
(
config
&
pixelFormat
)
)
{
return
GrBackendTexture
(
)
;
}
bool
linearTiling
=
false
;
if
(
!
fVkCaps
-
>
isConfigTexturable
(
config
)
)
{
return
GrBackendTexture
(
)
;
}
if
(
isRenderTarget
&
&
!
fVkCaps
-
>
isConfigRenderable
(
config
)
)
{
return
GrBackendTexture
(
)
;
}
if
(
srcData
&
&
GrMipMapped
:
:
kYes
=
=
mipMapped
)
{
return
GrBackendTexture
(
)
;
}
if
(
fVkCaps
-
>
isConfigTexturableLinearly
(
config
)
&
&
(
!
isRenderTarget
|
|
fVkCaps
-
>
isConfigRenderableLinearly
(
config
false
)
)
&
&
GrMipMapped
:
:
kNo
=
=
mipMapped
)
{
linearTiling
=
true
;
}
VkImageUsageFlags
usageFlags
=
VK_IMAGE_USAGE_SAMPLED_BIT
;
usageFlags
|
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
;
usageFlags
|
=
VK_IMAGE_USAGE_TRANSFER_DST_BIT
;
if
(
isRenderTarget
)
{
usageFlags
|
=
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
}
VkImage
image
=
VK_NULL_HANDLE
;
GrVkAlloc
alloc
;
VkImageTiling
imageTiling
=
linearTiling
?
VK_IMAGE_TILING_LINEAR
:
VK_IMAGE_TILING_OPTIMAL
;
VkImageLayout
initialLayout
=
(
VK_IMAGE_TILING_LINEAR
=
=
imageTiling
)
?
VK_IMAGE_LAYOUT_PREINITIALIZED
:
VK_IMAGE_LAYOUT_UNDEFINED
;
VkSampleCountFlagBits
vkSamples
;
if
(
!
GrSampleCountToVkSampleCount
(
1
&
vkSamples
)
)
{
return
GrBackendTexture
(
)
;
}
uint32_t
mipLevels
=
1
;
if
(
GrMipMapped
:
:
kYes
=
=
mipMapped
)
{
mipLevels
=
SkMipMap
:
:
ComputeLevelCount
(
w
h
)
+
1
;
}
const
VkImageCreateInfo
imageCreateInfo
=
{
VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
nullptr
0
VK_IMAGE_TYPE_2D
pixelFormat
{
(
uint32_t
)
w
(
uint32_t
)
h
1
}
mipLevels
1
vkSamples
imageTiling
usageFlags
VK_SHARING_MODE_EXCLUSIVE
0
0
initialLayout
}
;
GR_VK_CALL_ERRCHECK
(
this
-
>
vkInterface
(
)
CreateImage
(
this
-
>
device
(
)
&
imageCreateInfo
nullptr
&
image
)
)
;
if
(
!
GrVkMemory
:
:
AllocAndBindImageMemory
(
this
image
linearTiling
&
alloc
)
)
{
VK_CALL
(
DestroyImage
(
this
-
>
device
(
)
image
nullptr
)
)
;
return
GrBackendTexture
(
)
;
}
GrVkAlloc
bufferAlloc
;
VkBuffer
buffer
=
VK_NULL_HANDLE
;
VkResult
err
;
const
VkCommandBufferAllocateInfo
cmdInfo
=
{
VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
nullptr
fCmdPool
VK_COMMAND_BUFFER_LEVEL_PRIMARY
1
}
;
VkCommandBuffer
cmdBuffer
;
err
=
VK_CALL
(
AllocateCommandBuffers
(
fDevice
&
cmdInfo
&
cmdBuffer
)
)
;
if
(
err
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
false
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
return
GrBackendTexture
(
)
;
}
VkCommandBufferBeginInfo
cmdBufferBeginInfo
;
memset
(
&
cmdBufferBeginInfo
0
sizeof
(
VkCommandBufferBeginInfo
)
)
;
cmdBufferBeginInfo
.
sType
=
VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
;
cmdBufferBeginInfo
.
pNext
=
nullptr
;
cmdBufferBeginInfo
.
flags
=
VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
;
cmdBufferBeginInfo
.
pInheritanceInfo
=
nullptr
;
err
=
VK_CALL
(
BeginCommandBuffer
(
cmdBuffer
&
cmdBufferBeginInfo
)
)
;
SkASSERT
(
!
err
)
;
size_t
bpp
=
GrBytesPerPixel
(
config
)
;
size_t
rowCopyBytes
=
bpp
*
w
;
if
(
linearTiling
)
{
const
VkImageSubresource
subres
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
}
;
VkSubresourceLayout
layout
;
VK_CALL
(
GetImageSubresourceLayout
(
fDevice
image
&
subres
&
layout
)
)
;
if
(
!
copy_testing_data
(
this
srcData
alloc
0
rowCopyBytes
static_cast
<
size_t
>
(
layout
.
rowPitch
)
h
)
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
true
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
VK_CALL
(
EndCommandBuffer
(
cmdBuffer
)
)
;
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
return
GrBackendTexture
(
)
;
}
}
else
{
SkASSERT
(
w
&
&
h
)
;
SkTArray
<
size_t
>
individualMipOffsets
(
mipLevels
)
;
individualMipOffsets
.
push_back
(
0
)
;
size_t
combinedBufferSize
=
w
*
bpp
*
h
;
int
currentWidth
=
w
;
int
currentHeight
=
h
;
SkASSERT
(
(
bpp
&
(
bpp
-
1
)
)
=
=
0
)
;
const
size_t
alignmentMask
=
0x3
|
(
bpp
-
1
)
;
for
(
uint32_t
currentMipLevel
=
1
;
currentMipLevel
<
mipLevels
;
currentMipLevel
+
+
)
{
currentWidth
=
SkTMax
(
1
currentWidth
/
2
)
;
currentHeight
=
SkTMax
(
1
currentHeight
/
2
)
;
const
size_t
trimmedSize
=
currentWidth
*
bpp
*
currentHeight
;
const
size_t
alignmentDiff
=
combinedBufferSize
&
alignmentMask
;
if
(
alignmentDiff
!
=
0
)
{
combinedBufferSize
+
=
alignmentMask
-
alignmentDiff
+
1
;
}
individualMipOffsets
.
push_back
(
combinedBufferSize
)
;
combinedBufferSize
+
=
trimmedSize
;
}
VkBufferCreateInfo
bufInfo
;
memset
(
&
bufInfo
0
sizeof
(
VkBufferCreateInfo
)
)
;
bufInfo
.
sType
=
VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
;
bufInfo
.
flags
=
0
;
bufInfo
.
size
=
combinedBufferSize
;
bufInfo
.
usage
=
VK_BUFFER_USAGE_TRANSFER_SRC_BIT
;
bufInfo
.
sharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
bufInfo
.
queueFamilyIndexCount
=
0
;
bufInfo
.
pQueueFamilyIndices
=
nullptr
;
err
=
VK_CALL
(
CreateBuffer
(
fDevice
&
bufInfo
nullptr
&
buffer
)
)
;
if
(
err
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
false
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
VK_CALL
(
EndCommandBuffer
(
cmdBuffer
)
)
;
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
return
GrBackendTexture
(
)
;
}
if
(
!
GrVkMemory
:
:
AllocAndBindBufferMemory
(
this
buffer
GrVkBuffer
:
:
kCopyRead_Type
true
&
bufferAlloc
)
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
false
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
VK_CALL
(
DestroyBuffer
(
fDevice
buffer
nullptr
)
)
;
VK_CALL
(
EndCommandBuffer
(
cmdBuffer
)
)
;
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
return
GrBackendTexture
(
)
;
}
currentWidth
=
w
;
currentHeight
=
h
;
for
(
uint32_t
currentMipLevel
=
0
;
currentMipLevel
<
mipLevels
;
currentMipLevel
+
+
)
{
SkASSERT
(
0
=
=
currentMipLevel
|
|
!
srcData
)
;
size_t
currentRowBytes
=
bpp
*
currentWidth
;
size_t
bufferOffset
=
individualMipOffsets
[
currentMipLevel
]
;
if
(
!
copy_testing_data
(
this
srcData
bufferAlloc
bufferOffset
currentRowBytes
currentRowBytes
currentHeight
)
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
false
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
GrVkMemory
:
:
FreeBufferMemory
(
this
GrVkBuffer
:
:
kCopyRead_Type
bufferAlloc
)
;
VK_CALL
(
DestroyBuffer
(
fDevice
buffer
nullptr
)
)
;
VK_CALL
(
EndCommandBuffer
(
cmdBuffer
)
)
;
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
return
GrBackendTexture
(
)
;
}
currentWidth
=
SkTMax
(
1
currentWidth
/
2
)
;
currentHeight
=
SkTMax
(
1
currentHeight
/
2
)
;
}
VkImageMemoryBarrier
barrier
;
memset
(
&
barrier
0
sizeof
(
VkImageMemoryBarrier
)
)
;
barrier
.
sType
=
VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
;
barrier
.
pNext
=
nullptr
;
barrier
.
srcAccessMask
=
GrVkMemory
:
:
LayoutToSrcAccessMask
(
initialLayout
)
;
barrier
.
dstAccessMask
=
VK_ACCESS_TRANSFER_WRITE_BIT
;
barrier
.
oldLayout
=
initialLayout
;
barrier
.
newLayout
=
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
;
barrier
.
srcQueueFamilyIndex
=
VK_QUEUE_FAMILY_IGNORED
;
barrier
.
dstQueueFamilyIndex
=
VK_QUEUE_FAMILY_IGNORED
;
barrier
.
image
=
image
;
barrier
.
subresourceRange
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
mipLevels
0
1
}
;
VK_CALL
(
CmdPipelineBarrier
(
cmdBuffer
GrVkMemory
:
:
LayoutToPipelineStageFlags
(
initialLayout
)
VK_PIPELINE_STAGE_TRANSFER_BIT
0
0
nullptr
0
nullptr
1
&
barrier
)
)
;
initialLayout
=
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
;
SkTArray
<
VkBufferImageCopy
>
regions
(
mipLevels
)
;
currentWidth
=
w
;
currentHeight
=
h
;
for
(
uint32_t
currentMipLevel
=
0
;
currentMipLevel
<
mipLevels
;
currentMipLevel
+
+
)
{
VkBufferImageCopy
&
region
=
regions
.
push_back
(
)
;
memset
(
&
region
0
sizeof
(
VkBufferImageCopy
)
)
;
region
.
bufferOffset
=
individualMipOffsets
[
currentMipLevel
]
;
region
.
bufferRowLength
=
currentWidth
;
region
.
bufferImageHeight
=
currentHeight
;
region
.
imageSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
region
.
imageOffset
=
{
0
0
0
}
;
region
.
imageExtent
=
{
(
uint32_t
)
currentWidth
(
uint32_t
)
currentHeight
1
}
;
currentWidth
=
SkTMax
(
1
currentWidth
/
2
)
;
currentHeight
=
SkTMax
(
1
currentHeight
/
2
)
;
}
VK_CALL
(
CmdCopyBufferToImage
(
cmdBuffer
buffer
image
initialLayout
regions
.
count
(
)
regions
.
begin
(
)
)
)
;
}
VkImageMemoryBarrier
barrier
;
memset
(
&
barrier
0
sizeof
(
VkImageMemoryBarrier
)
)
;
barrier
.
sType
=
VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
;
barrier
.
pNext
=
nullptr
;
barrier
.
srcAccessMask
=
GrVkMemory
:
:
LayoutToSrcAccessMask
(
initialLayout
)
;
barrier
.
dstAccessMask
=
VK_ACCESS_SHADER_READ_BIT
;
barrier
.
oldLayout
=
initialLayout
;
barrier
.
newLayout
=
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
;
barrier
.
srcQueueFamilyIndex
=
VK_QUEUE_FAMILY_IGNORED
;
barrier
.
dstQueueFamilyIndex
=
VK_QUEUE_FAMILY_IGNORED
;
barrier
.
image
=
image
;
barrier
.
subresourceRange
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
mipLevels
0
1
}
;
VK_CALL
(
CmdPipelineBarrier
(
cmdBuffer
GrVkMemory
:
:
LayoutToPipelineStageFlags
(
initialLayout
)
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
0
0
nullptr
0
nullptr
1
&
barrier
)
)
;
err
=
VK_CALL
(
EndCommandBuffer
(
cmdBuffer
)
)
;
SkASSERT
(
!
err
)
;
VkFence
fence
;
VkFenceCreateInfo
fenceInfo
;
memset
(
&
fenceInfo
0
sizeof
(
VkFenceCreateInfo
)
)
;
fenceInfo
.
sType
=
VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
;
err
=
VK_CALL
(
CreateFence
(
fDevice
&
fenceInfo
nullptr
&
fence
)
)
;
SkASSERT
(
!
err
)
;
VkSubmitInfo
submitInfo
;
memset
(
&
submitInfo
0
sizeof
(
VkSubmitInfo
)
)
;
submitInfo
.
sType
=
VK_STRUCTURE_TYPE_SUBMIT_INFO
;
submitInfo
.
pNext
=
nullptr
;
submitInfo
.
waitSemaphoreCount
=
0
;
submitInfo
.
pWaitSemaphores
=
nullptr
;
submitInfo
.
pWaitDstStageMask
=
0
;
submitInfo
.
commandBufferCount
=
1
;
submitInfo
.
pCommandBuffers
=
&
cmdBuffer
;
submitInfo
.
signalSemaphoreCount
=
0
;
submitInfo
.
pSignalSemaphores
=
nullptr
;
err
=
VK_CALL
(
QueueSubmit
(
this
-
>
queue
(
)
1
&
submitInfo
fence
)
)
;
SkASSERT
(
!
err
)
;
err
=
VK_CALL
(
WaitForFences
(
fDevice
1
&
fence
true
UINT64_MAX
)
)
;
if
(
VK_TIMEOUT
=
=
err
)
{
GrVkMemory
:
:
FreeImageMemory
(
this
false
alloc
)
;
VK_CALL
(
DestroyImage
(
fDevice
image
nullptr
)
)
;
GrVkMemory
:
:
FreeBufferMemory
(
this
GrVkBuffer
:
:
kCopyRead_Type
bufferAlloc
)
;
VK_CALL
(
DestroyBuffer
(
fDevice
buffer
nullptr
)
)
;
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
VK_CALL
(
DestroyFence
(
fDevice
fence
nullptr
)
)
;
SkDebugf
(
"
Fence
failed
to
signal
:
%
d
\
n
"
err
)
;
SK_ABORT
(
"
failing
"
)
;
}
SkASSERT
(
!
err
)
;
if
(
buffer
!
=
VK_NULL_HANDLE
)
{
GrVkMemory
:
:
FreeBufferMemory
(
this
GrVkBuffer
:
:
kCopyRead_Type
bufferAlloc
)
;
VK_CALL
(
DestroyBuffer
(
fDevice
buffer
nullptr
)
)
;
}
VK_CALL
(
FreeCommandBuffers
(
fDevice
fCmdPool
1
&
cmdBuffer
)
)
;
VK_CALL
(
DestroyFence
(
fDevice
fence
nullptr
)
)
;
GrVkImageInfo
info
;
info
.
fImage
=
image
;
info
.
fAlloc
=
alloc
;
info
.
fImageTiling
=
imageTiling
;
info
.
fImageLayout
=
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
;
info
.
fFormat
=
pixelFormat
;
info
.
fLevelCount
=
mipLevels
;
return
GrBackendTexture
(
w
h
info
)
;
}
bool
GrVkGpu
:
:
isTestingOnlyBackendTexture
(
const
GrBackendTexture
&
tex
)
const
{
SkASSERT
(
kVulkan_GrBackend
=
=
tex
.
fBackend
)
;
const
GrVkImageInfo
*
backend
=
tex
.
getVkImageInfo
(
)
;
if
(
backend
&
&
backend
-
>
fImage
&
&
backend
-
>
fAlloc
.
fMemory
)
{
VkMemoryRequirements
req
;
memset
(
&
req
0
sizeof
(
req
)
)
;
GR_VK_CALL
(
this
-
>
vkInterface
(
)
GetImageMemoryRequirements
(
fDevice
backend
-
>
fImage
&
req
)
)
;
return
(
req
.
size
>
0
)
&
&
(
req
.
size
<
=
8192
*
8192
)
;
}
return
false
;
}
void
GrVkGpu
:
:
deleteTestingOnlyBackendTexture
(
GrBackendTexture
*
tex
bool
abandon
)
{
SkASSERT
(
kVulkan_GrBackend
=
=
tex
-
>
fBackend
)
;
const
GrVkImageInfo
*
info
=
tex
-
>
getVkImageInfo
(
)
;
if
(
info
&
&
!
abandon
)
{
this
-
>
submitCommandBuffer
(
kForce_SyncQueue
)
;
GrVkImage
:
:
DestroyImageInfo
(
this
const_cast
<
GrVkImageInfo
*
>
(
info
)
)
;
}
}
void
GrVkGpu
:
:
addMemoryBarrier
(
VkPipelineStageFlags
srcStageMask
VkPipelineStageFlags
dstStageMask
bool
byRegion
VkMemoryBarrier
*
barrier
)
const
{
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
pipelineBarrier
(
this
srcStageMask
dstStageMask
byRegion
GrVkCommandBuffer
:
:
kMemory_BarrierType
barrier
)
;
}
void
GrVkGpu
:
:
addBufferMemoryBarrier
(
VkPipelineStageFlags
srcStageMask
VkPipelineStageFlags
dstStageMask
bool
byRegion
VkBufferMemoryBarrier
*
barrier
)
const
{
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
pipelineBarrier
(
this
srcStageMask
dstStageMask
byRegion
GrVkCommandBuffer
:
:
kBufferMemory_BarrierType
barrier
)
;
}
void
GrVkGpu
:
:
addImageMemoryBarrier
(
VkPipelineStageFlags
srcStageMask
VkPipelineStageFlags
dstStageMask
bool
byRegion
VkImageMemoryBarrier
*
barrier
)
const
{
SkASSERT
(
fCurrentCmdBuffer
)
;
fCurrentCmdBuffer
-
>
pipelineBarrier
(
this
srcStageMask
dstStageMask
byRegion
GrVkCommandBuffer
:
:
kImageMemory_BarrierType
barrier
)
;
}
void
GrVkGpu
:
:
onFinishFlush
(
bool
insertedSemaphore
)
{
this
-
>
submitCommandBuffer
(
kSkip_SyncQueue
)
;
}
void
GrVkGpu
:
:
clearStencil
(
GrRenderTarget
*
target
int
clearValue
)
{
if
(
!
target
)
{
return
;
}
GrStencilAttachment
*
stencil
=
target
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
GrVkStencilAttachment
*
vkStencil
=
(
GrVkStencilAttachment
*
)
stencil
;
VkClearDepthStencilValue
vkStencilColor
;
vkStencilColor
.
depth
=
0
.
0f
;
vkStencilColor
.
stencil
=
clearValue
;
vkStencil
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
VkImageSubresourceRange
subRange
;
memset
(
&
subRange
0
sizeof
(
VkImageSubresourceRange
)
)
;
subRange
.
aspectMask
=
VK_IMAGE_ASPECT_STENCIL_BIT
;
subRange
.
baseMipLevel
=
0
;
subRange
.
levelCount
=
1
;
subRange
.
baseArrayLayer
=
0
;
subRange
.
layerCount
=
1
;
fCurrentCmdBuffer
-
>
clearDepthStencilImage
(
this
vkStencil
&
vkStencilColor
1
&
subRange
)
;
}
inline
bool
can_copy_image
(
const
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
const
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
GrVkGpu
*
gpu
)
{
const
GrRenderTarget
*
dstRT
=
dst
-
>
asRenderTarget
(
)
;
const
GrRenderTarget
*
srcRT
=
src
-
>
asRenderTarget
(
)
;
if
(
dstRT
&
&
srcRT
)
{
if
(
srcRT
-
>
numColorSamples
(
)
!
=
dstRT
-
>
numColorSamples
(
)
)
{
return
false
;
}
}
else
if
(
dstRT
)
{
if
(
dstRT
-
>
numColorSamples
(
)
>
1
)
{
return
false
;
}
}
else
if
(
srcRT
)
{
if
(
srcRT
-
>
numColorSamples
(
)
>
1
)
{
return
false
;
}
}
if
(
srcOrigin
=
=
dstOrigin
&
&
GrBytesPerPixel
(
src
-
>
config
(
)
)
=
=
GrBytesPerPixel
(
dst
-
>
config
(
)
)
)
{
return
true
;
}
return
false
;
}
void
GrVkGpu
:
:
copySurfaceAsCopyImage
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
GrVkImage
*
dstImage
GrVkImage
*
srcImage
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
SkASSERT
(
can_copy_image
(
dst
dstOrigin
src
srcOrigin
this
)
)
;
dstImage
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
srcImage
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
SkIRect
srcVkRect
=
srcRect
;
int32_t
dstY
=
dstPoint
.
fY
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
srcOrigin
)
{
SkASSERT
(
kBottomLeft_GrSurfaceOrigin
=
=
dstOrigin
)
;
srcVkRect
.
fTop
=
src
-
>
height
(
)
-
srcRect
.
fBottom
;
srcVkRect
.
fBottom
=
src
-
>
height
(
)
-
srcRect
.
fTop
;
dstY
=
dst
-
>
height
(
)
-
dstPoint
.
fY
-
srcVkRect
.
height
(
)
;
}
VkImageCopy
copyRegion
;
memset
(
&
copyRegion
0
sizeof
(
VkImageCopy
)
)
;
copyRegion
.
srcSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
copyRegion
.
srcOffset
=
{
srcVkRect
.
fLeft
srcVkRect
.
fTop
0
}
;
copyRegion
.
dstSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
copyRegion
.
dstOffset
=
{
dstPoint
.
fX
dstY
0
}
;
copyRegion
.
extent
=
{
(
uint32_t
)
srcVkRect
.
width
(
)
(
uint32_t
)
srcVkRect
.
height
(
)
1
}
;
fCurrentCmdBuffer
-
>
copyImage
(
this
srcImage
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
dstImage
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
1
&
copyRegion
)
;
SkIRect
dstRect
=
SkIRect
:
:
MakeXYWH
(
dstPoint
.
fX
dstPoint
.
fY
srcRect
.
width
(
)
srcRect
.
height
(
)
)
;
this
-
>
didWriteToSurface
(
dst
dstOrigin
&
dstRect
)
;
}
inline
bool
can_copy_as_blit
(
const
GrSurface
*
dst
const
GrSurface
*
src
const
GrVkImage
*
dstImage
const
GrVkImage
*
srcImage
const
GrVkGpu
*
gpu
)
{
const
GrVkCaps
&
caps
=
gpu
-
>
vkCaps
(
)
;
if
(
!
caps
.
configCanBeDstofBlit
(
dst
-
>
config
(
)
dstImage
-
>
isLinearTiled
(
)
)
|
|
!
caps
.
configCanBeSrcofBlit
(
src
-
>
config
(
)
srcImage
-
>
isLinearTiled
(
)
)
)
{
return
false
;
}
if
(
(
dst
-
>
asRenderTarget
(
)
&
&
dst
-
>
asRenderTarget
(
)
-
>
numColorSamples
(
)
>
1
)
|
|
(
src
-
>
asRenderTarget
(
)
&
&
src
-
>
asRenderTarget
(
)
-
>
numColorSamples
(
)
>
1
)
)
{
return
false
;
}
return
true
;
}
void
GrVkGpu
:
:
copySurfaceAsBlit
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
GrVkImage
*
dstImage
GrVkImage
*
srcImage
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
SkASSERT
(
can_copy_as_blit
(
dst
src
dstImage
srcImage
this
)
)
;
dstImage
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
srcImage
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
SkIRect
srcVkRect
;
srcVkRect
.
fLeft
=
srcRect
.
fLeft
;
srcVkRect
.
fRight
=
srcRect
.
fRight
;
SkIRect
dstRect
;
dstRect
.
fLeft
=
dstPoint
.
fX
;
dstRect
.
fRight
=
dstPoint
.
fX
+
srcRect
.
width
(
)
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
srcOrigin
)
{
srcVkRect
.
fTop
=
src
-
>
height
(
)
-
srcRect
.
fBottom
;
srcVkRect
.
fBottom
=
src
-
>
height
(
)
-
srcRect
.
fTop
;
}
else
{
srcVkRect
.
fTop
=
srcRect
.
fTop
;
srcVkRect
.
fBottom
=
srcRect
.
fBottom
;
}
if
(
kBottomLeft_GrSurfaceOrigin
=
=
dstOrigin
)
{
dstRect
.
fTop
=
dst
-
>
height
(
)
-
dstPoint
.
fY
-
srcVkRect
.
height
(
)
;
}
else
{
dstRect
.
fTop
=
dstPoint
.
fY
;
}
dstRect
.
fBottom
=
dstRect
.
fTop
+
srcVkRect
.
height
(
)
;
if
(
srcOrigin
!
=
dstOrigin
)
{
SkTSwap
(
dstRect
.
fTop
dstRect
.
fBottom
)
;
}
VkImageBlit
blitRegion
;
memset
(
&
blitRegion
0
sizeof
(
VkImageBlit
)
)
;
blitRegion
.
srcSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
blitRegion
.
srcOffsets
[
0
]
=
{
srcVkRect
.
fLeft
srcVkRect
.
fTop
0
}
;
blitRegion
.
srcOffsets
[
1
]
=
{
srcVkRect
.
fRight
srcVkRect
.
fBottom
1
}
;
blitRegion
.
dstSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
blitRegion
.
dstOffsets
[
0
]
=
{
dstRect
.
fLeft
dstRect
.
fTop
0
}
;
blitRegion
.
dstOffsets
[
1
]
=
{
dstRect
.
fRight
dstRect
.
fBottom
1
}
;
fCurrentCmdBuffer
-
>
blitImage
(
this
*
srcImage
*
dstImage
1
&
blitRegion
VK_FILTER_NEAREST
)
;
this
-
>
didWriteToSurface
(
dst
dstOrigin
&
dstRect
)
;
}
inline
bool
can_copy_as_resolve
(
const
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
const
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
GrVkGpu
*
gpu
)
{
if
(
!
src
-
>
asRenderTarget
(
)
|
|
1
=
=
src
-
>
asRenderTarget
(
)
-
>
numColorSamples
(
)
)
{
return
false
;
}
if
(
dst
-
>
asRenderTarget
(
)
&
&
dst
-
>
asRenderTarget
(
)
-
>
numColorSamples
(
)
>
1
&
&
dst
!
=
src
)
{
return
false
;
}
if
(
srcOrigin
!
=
dstOrigin
)
{
return
false
;
}
return
true
;
}
void
GrVkGpu
:
:
copySurfaceAsResolve
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
origSrcRect
const
SkIPoint
&
origDstPoint
)
{
GrVkRenderTarget
*
srcRT
=
static_cast
<
GrVkRenderTarget
*
>
(
src
-
>
asRenderTarget
(
)
)
;
SkIRect
srcRect
=
origSrcRect
;
SkIPoint
dstPoint
=
origDstPoint
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
srcOrigin
)
{
SkASSERT
(
kBottomLeft_GrSurfaceOrigin
=
=
dstOrigin
)
;
srcRect
=
{
origSrcRect
.
fLeft
src
-
>
height
(
)
-
origSrcRect
.
fBottom
origSrcRect
.
fRight
src
-
>
height
(
)
-
origSrcRect
.
fTop
}
;
dstPoint
.
fY
=
dst
-
>
height
(
)
-
dstPoint
.
fY
-
srcRect
.
height
(
)
;
}
this
-
>
resolveImage
(
dst
srcRT
srcRect
dstPoint
)
;
}
bool
GrVkGpu
:
:
onCopySurface
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
if
(
can_copy_as_resolve
(
dst
dstOrigin
src
srcOrigin
this
)
)
{
this
-
>
copySurfaceAsResolve
(
dst
dstOrigin
src
srcOrigin
srcRect
dstPoint
)
;
return
true
;
}
if
(
this
-
>
vkCaps
(
)
.
mustSubmitCommandsBeforeCopyOp
(
)
)
{
this
-
>
submitCommandBuffer
(
GrVkGpu
:
:
kSkip_SyncQueue
)
;
}
if
(
fCopyManager
.
copySurfaceAsDraw
(
this
dst
dstOrigin
src
srcOrigin
srcRect
dstPoint
)
)
{
auto
dstRect
=
srcRect
.
makeOffset
(
dstPoint
.
fX
dstPoint
.
fY
)
;
this
-
>
didWriteToSurface
(
dst
dstOrigin
&
dstRect
)
;
return
true
;
}
GrVkImage
*
dstImage
;
GrVkImage
*
srcImage
;
GrRenderTarget
*
dstRT
=
dst
-
>
asRenderTarget
(
)
;
if
(
dstRT
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
dstRT
)
;
dstImage
=
vkRT
-
>
numColorSamples
(
)
>
1
?
vkRT
-
>
msaaImage
(
)
:
vkRT
;
}
else
{
SkASSERT
(
dst
-
>
asTexture
(
)
)
;
dstImage
=
static_cast
<
GrVkTexture
*
>
(
dst
-
>
asTexture
(
)
)
;
}
GrRenderTarget
*
srcRT
=
src
-
>
asRenderTarget
(
)
;
if
(
srcRT
)
{
GrVkRenderTarget
*
vkRT
=
static_cast
<
GrVkRenderTarget
*
>
(
srcRT
)
;
srcImage
=
vkRT
-
>
numColorSamples
(
)
>
1
?
vkRT
-
>
msaaImage
(
)
:
vkRT
;
}
else
{
SkASSERT
(
src
-
>
asTexture
(
)
)
;
srcImage
=
static_cast
<
GrVkTexture
*
>
(
src
-
>
asTexture
(
)
)
;
}
if
(
srcImage
-
>
isBorrowed
(
)
)
{
return
false
;
}
if
(
can_copy_image
(
dst
dstOrigin
src
srcOrigin
this
)
)
{
this
-
>
copySurfaceAsCopyImage
(
dst
dstOrigin
src
srcOrigin
dstImage
srcImage
srcRect
dstPoint
)
;
return
true
;
}
if
(
can_copy_as_blit
(
dst
src
dstImage
srcImage
this
)
)
{
this
-
>
copySurfaceAsBlit
(
dst
dstOrigin
src
srcOrigin
dstImage
srcImage
srcRect
dstPoint
)
;
return
true
;
}
return
false
;
}
bool
GrVkGpu
:
:
onGetReadPixelsInfo
(
GrSurface
*
srcSurface
GrSurfaceOrigin
srcOrigin
int
width
int
height
size_t
rowBytes
GrColorType
dstColorType
DrawPreference
*
drawPreference
ReadPixelTempDrawInfo
*
tempDrawInfo
)
{
auto
dstConfigSRGBEncoded
=
GrPixelConfigIsSRGBEncoded
(
srcSurface
-
>
config
(
)
)
;
if
(
*
drawPreference
!
=
kNoDraw_DrawPreference
)
{
SkASSERT
(
tempDrawInfo
-
>
fReadColorType
=
=
dstColorType
)
;
SkASSERT
(
GrPixelConfigToColorType
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
=
=
dstColorType
)
;
SkASSERT
(
tempDrawInfo
-
>
fSwizzle
=
=
GrSwizzle
:
:
RGBA
(
)
)
;
dstConfigSRGBEncoded
=
GrPixelConfigIsSRGBEncoded
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
;
}
if
(
GrColorTypeIsAlphaOnly
(
dstColorType
)
)
{
dstConfigSRGBEncoded
=
GrSRGBEncoded
:
:
kNo
;
}
if
(
GrPixelConfigToColorType
(
srcSurface
-
>
config
(
)
)
=
=
dstColorType
)
{
return
true
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
=
GrColorTypeToPixelConfig
(
dstColorType
dstConfigSRGBEncoded
)
;
tempDrawInfo
-
>
fReadColorType
=
dstColorType
;
return
kUnknown_GrPixelConfig
!
=
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
;
}
bool
GrVkGpu
:
:
onReadPixels
(
GrSurface
*
surface
GrSurfaceOrigin
origin
int
left
int
top
int
width
int
height
GrColorType
dstColorType
void
*
buffer
size_t
rowBytes
)
{
if
(
GrPixelConfigToColorType
(
surface
-
>
config
(
)
)
!
=
dstColorType
)
{
return
false
;
}
GrVkImage
*
image
=
nullptr
;
GrVkRenderTarget
*
rt
=
static_cast
<
GrVkRenderTarget
*
>
(
surface
-
>
asRenderTarget
(
)
)
;
if
(
rt
)
{
switch
(
rt
-
>
getResolveType
(
)
)
{
case
GrVkRenderTarget
:
:
kCantResolve_ResolveType
:
return
false
;
case
GrVkRenderTarget
:
:
kAutoResolves_ResolveType
:
break
;
case
GrVkRenderTarget
:
:
kCanResolve_ResolveType
:
this
-
>
internalResolveRenderTarget
(
rt
false
)
;
break
;
default
:
SK_ABORT
(
"
Unknown
resolve
type
"
)
;
}
image
=
rt
;
}
else
{
image
=
static_cast
<
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
;
}
if
(
!
image
)
{
return
false
;
}
image
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
false
)
;
int
bpp
=
GrColorTypeBytesPerPixel
(
dstColorType
)
;
size_t
tightRowBytes
=
bpp
*
width
;
bool
flipY
=
kBottomLeft_GrSurfaceOrigin
=
=
origin
;
VkBufferImageCopy
region
;
memset
(
&
region
0
sizeof
(
VkBufferImageCopy
)
)
;
bool
copyFromOrigin
=
this
-
>
vkCaps
(
)
.
mustDoCopiesFromOrigin
(
)
;
if
(
copyFromOrigin
)
{
region
.
imageOffset
=
{
0
0
0
}
;
region
.
imageExtent
=
{
(
uint32_t
)
(
left
+
width
)
(
uint32_t
)
(
flipY
?
surface
-
>
height
(
)
-
top
:
top
+
height
)
1
}
;
}
else
{
VkOffset3D
offset
=
{
left
flipY
?
surface
-
>
height
(
)
-
top
-
height
:
top
0
}
;
region
.
imageOffset
=
offset
;
region
.
imageExtent
=
{
(
uint32_t
)
width
(
uint32_t
)
height
1
}
;
}
size_t
transBufferRowBytes
=
bpp
*
region
.
imageExtent
.
width
;
size_t
imageRows
=
bpp
*
region
.
imageExtent
.
height
;
GrVkTransferBuffer
*
transferBuffer
=
static_cast
<
GrVkTransferBuffer
*
>
(
this
-
>
createBuffer
(
transBufferRowBytes
*
imageRows
kXferGpuToCpu_GrBufferType
kStream_GrAccessPattern
)
)
;
region
.
bufferOffset
=
transferBuffer
-
>
offset
(
)
;
region
.
bufferRowLength
=
0
;
region
.
bufferImageHeight
=
0
;
region
.
imageSubresource
=
{
VK_IMAGE_ASPECT_COLOR_BIT
0
0
1
}
;
fCurrentCmdBuffer
-
>
copyImageToBuffer
(
this
image
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
transferBuffer
1
&
region
)
;
transferBuffer
-
>
addMemoryBarrier
(
this
VK_ACCESS_TRANSFER_WRITE_BIT
VK_ACCESS_HOST_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
VK_PIPELINE_STAGE_HOST_BIT
false
)
;
this
-
>
submitCommandBuffer
(
kForce_SyncQueue
)
;
void
*
mappedMemory
=
transferBuffer
-
>
map
(
)
;
GrVkMemory
:
:
InvalidateMappedAlloc
(
this
transferBuffer
-
>
alloc
(
)
)
;
if
(
copyFromOrigin
)
{
uint32_t
skipRows
=
region
.
imageExtent
.
height
-
height
;
mappedMemory
=
(
char
*
)
mappedMemory
+
transBufferRowBytes
*
skipRows
+
bpp
*
left
;
}
if
(
flipY
)
{
const
char
*
srcRow
=
reinterpret_cast
<
const
char
*
>
(
mappedMemory
)
;
char
*
dstRow
=
reinterpret_cast
<
char
*
>
(
buffer
)
+
(
height
-
1
)
*
rowBytes
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
memcpy
(
dstRow
srcRow
tightRowBytes
)
;
srcRow
+
=
transBufferRowBytes
;
dstRow
-
=
rowBytes
;
}
}
else
{
SkRectMemcpy
(
buffer
rowBytes
mappedMemory
transBufferRowBytes
tightRowBytes
height
)
;
}
transferBuffer
-
>
unmap
(
)
;
transferBuffer
-
>
unref
(
)
;
return
true
;
}
void
adjust_bounds_to_granularity
(
SkIRect
*
dstBounds
const
SkIRect
&
srcBounds
const
VkExtent2D
&
granularity
int
maxWidth
int
maxHeight
)
{
if
(
(
0
!
=
granularity
.
width
&
&
1
!
=
granularity
.
width
)
)
{
int
rightAdj
=
srcBounds
.
fRight
%
granularity
.
width
;
if
(
rightAdj
!
=
0
)
{
rightAdj
=
granularity
.
width
-
rightAdj
;
}
dstBounds
-
>
fRight
=
srcBounds
.
fRight
+
rightAdj
;
if
(
dstBounds
-
>
fRight
>
maxWidth
)
{
dstBounds
-
>
fRight
=
maxWidth
;
dstBounds
-
>
fLeft
=
0
;
}
else
{
dstBounds
-
>
fLeft
=
srcBounds
.
fLeft
-
srcBounds
.
fLeft
%
granularity
.
width
;
}
}
else
{
dstBounds
-
>
fLeft
=
srcBounds
.
fLeft
;
dstBounds
-
>
fRight
=
srcBounds
.
fRight
;
}
if
(
(
0
!
=
granularity
.
height
&
&
1
!
=
granularity
.
height
)
)
{
int
bottomAdj
=
srcBounds
.
fBottom
%
granularity
.
height
;
if
(
bottomAdj
!
=
0
)
{
bottomAdj
=
granularity
.
height
-
bottomAdj
;
}
dstBounds
-
>
fBottom
=
srcBounds
.
fBottom
+
bottomAdj
;
if
(
dstBounds
-
>
fBottom
>
maxHeight
)
{
dstBounds
-
>
fBottom
=
maxHeight
;
dstBounds
-
>
fTop
=
0
;
}
else
{
dstBounds
-
>
fTop
=
srcBounds
.
fTop
-
srcBounds
.
fTop
%
granularity
.
height
;
}
}
else
{
dstBounds
-
>
fTop
=
srcBounds
.
fTop
;
dstBounds
-
>
fBottom
=
srcBounds
.
fBottom
;
}
}
void
GrVkGpu
:
:
submitSecondaryCommandBuffer
(
const
SkTArray
<
GrVkSecondaryCommandBuffer
*
>
&
buffers
const
GrVkRenderPass
*
renderPass
const
VkClearValue
*
colorClear
GrVkRenderTarget
*
target
GrSurfaceOrigin
origin
const
SkIRect
&
bounds
)
{
const
SkIRect
*
pBounds
=
&
bounds
;
SkIRect
flippedBounds
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
origin
)
{
flippedBounds
=
bounds
;
flippedBounds
.
fTop
=
target
-
>
height
(
)
-
bounds
.
fBottom
;
flippedBounds
.
fBottom
=
target
-
>
height
(
)
-
bounds
.
fTop
;
pBounds
=
&
flippedBounds
;
}
const
VkExtent2D
&
granularity
=
renderPass
-
>
granularity
(
)
;
SkIRect
adjustedBounds
;
if
(
(
0
!
=
granularity
.
width
&
&
1
!
=
granularity
.
width
)
|
|
(
0
!
=
granularity
.
height
&
&
1
!
=
granularity
.
height
)
)
{
adjust_bounds_to_granularity
(
&
adjustedBounds
*
pBounds
granularity
target
-
>
width
(
)
target
-
>
height
(
)
)
;
pBounds
=
&
adjustedBounds
;
}
#
ifdef
SK_DEBUG
uint32_t
index
;
bool
result
=
renderPass
-
>
colorAttachmentIndex
(
&
index
)
;
SkASSERT
(
result
&
&
0
=
=
index
)
;
result
=
renderPass
-
>
stencilAttachmentIndex
(
&
index
)
;
if
(
result
)
{
SkASSERT
(
1
=
=
index
)
;
}
#
endif
VkClearValue
clears
[
2
]
;
clears
[
0
]
.
color
=
colorClear
-
>
color
;
clears
[
1
]
.
depthStencil
.
depth
=
0
.
0f
;
clears
[
1
]
.
depthStencil
.
stencil
=
0
;
fCurrentCmdBuffer
-
>
beginRenderPass
(
this
renderPass
clears
*
target
*
pBounds
true
)
;
for
(
int
i
=
0
;
i
<
buffers
.
count
(
)
;
+
+
i
)
{
fCurrentCmdBuffer
-
>
executeCommands
(
this
buffers
[
i
]
)
;
}
fCurrentCmdBuffer
-
>
endRenderPass
(
this
)
;
this
-
>
didWriteToSurface
(
target
origin
&
bounds
)
;
}
GrFence
SK_WARN_UNUSED_RESULT
GrVkGpu
:
:
insertFence
(
)
{
VkFenceCreateInfo
createInfo
;
memset
(
&
createInfo
0
sizeof
(
VkFenceCreateInfo
)
)
;
createInfo
.
sType
=
VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
;
createInfo
.
pNext
=
nullptr
;
createInfo
.
flags
=
0
;
VkFence
fence
=
VK_NULL_HANDLE
;
VK_CALL_ERRCHECK
(
CreateFence
(
this
-
>
device
(
)
&
createInfo
nullptr
&
fence
)
)
;
VK_CALL
(
QueueSubmit
(
this
-
>
queue
(
)
0
nullptr
fence
)
)
;
GR_STATIC_ASSERT
(
sizeof
(
GrFence
)
>
=
sizeof
(
VkFence
)
)
;
return
(
GrFence
)
fence
;
}
bool
GrVkGpu
:
:
waitFence
(
GrFence
fence
uint64_t
timeout
)
{
SkASSERT
(
VK_NULL_HANDLE
!
=
(
VkFence
)
fence
)
;
VkResult
result
=
VK_CALL
(
WaitForFences
(
this
-
>
device
(
)
1
(
VkFence
*
)
&
fence
VK_TRUE
timeout
)
)
;
return
(
VK_SUCCESS
=
=
result
)
;
}
void
GrVkGpu
:
:
deleteFence
(
GrFence
fence
)
const
{
VK_CALL
(
DestroyFence
(
this
-
>
device
(
)
(
VkFence
)
fence
nullptr
)
)
;
}
sk_sp
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
GrVkGpu
:
:
makeSemaphore
(
bool
isOwned
)
{
return
GrVkSemaphore
:
:
Make
(
this
isOwned
)
;
}
sk_sp
<
GrSemaphore
>
GrVkGpu
:
:
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
semaphore
GrResourceProvider
:
:
SemaphoreWrapType
wrapType
GrWrapOwnership
ownership
)
{
return
GrVkSemaphore
:
:
MakeWrapped
(
this
semaphore
.
vkSemaphore
(
)
wrapType
ownership
)
;
}
void
GrVkGpu
:
:
insertSemaphore
(
sk_sp
<
GrSemaphore
>
semaphore
bool
flush
)
{
GrVkSemaphore
*
vkSem
=
static_cast
<
GrVkSemaphore
*
>
(
semaphore
.
get
(
)
)
;
GrVkSemaphore
:
:
Resource
*
resource
=
vkSem
-
>
getResource
(
)
;
if
(
resource
-
>
shouldSignal
(
)
)
{
resource
-
>
ref
(
)
;
fSemaphoresToSignal
.
push_back
(
resource
)
;
}
if
(
flush
)
{
this
-
>
submitCommandBuffer
(
kSkip_SyncQueue
)
;
}
}
void
GrVkGpu
:
:
waitSemaphore
(
sk_sp
<
GrSemaphore
>
semaphore
)
{
GrVkSemaphore
*
vkSem
=
static_cast
<
GrVkSemaphore
*
>
(
semaphore
.
get
(
)
)
;
GrVkSemaphore
:
:
Resource
*
resource
=
vkSem
-
>
getResource
(
)
;
if
(
resource
-
>
shouldWait
(
)
)
{
resource
-
>
ref
(
)
;
fSemaphoresToWaitOn
.
push_back
(
resource
)
;
}
}
sk_sp
<
GrSemaphore
>
GrVkGpu
:
:
prepareTextureForCrossContextUsage
(
GrTexture
*
texture
)
{
SkASSERT
(
texture
)
;
GrVkTexture
*
vkTexture
=
static_cast
<
GrVkTexture
*
>
(
texture
)
;
vkTexture
-
>
setImageLayout
(
this
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
VK_ACCESS_SHADER_READ_BIT
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
false
)
;
this
-
>
submitCommandBuffer
(
kSkip_SyncQueue
)
;
return
nullptr
;
}
