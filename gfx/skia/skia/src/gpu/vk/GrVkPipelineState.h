#
ifndef
GrVkPipelineState_DEFINED
#
define
GrVkPipelineState_DEFINED
#
include
"
GrVkImage
.
h
"
#
include
"
GrVkProgramDesc
.
h
"
#
include
"
GrVkPipelineStateDataManager
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
vk
/
GrVkDefines
.
h
"
class
GrPipeline
;
class
GrVkCommandBuffer
;
class
GrVkDescriptorPool
;
class
GrVkGpu
;
class
GrVkImageView
;
class
GrVkPipeline
;
class
GrVkSampler
;
class
GrVkUniformBuffer
;
class
GrVkPipelineState
:
public
SkRefCnt
{
public
:
typedef
GrGLSLProgramBuilder
:
:
BuiltinUniformHandles
BuiltinUniformHandles
;
~
GrVkPipelineState
(
)
;
GrVkPipeline
*
vkPipeline
(
)
const
{
return
fPipeline
;
}
void
setData
(
GrVkGpu
*
const
GrPrimitiveProcessor
&
const
GrPipeline
&
)
;
void
bind
(
const
GrVkGpu
*
gpu
GrVkCommandBuffer
*
commandBuffer
)
;
void
addUniformResources
(
GrVkCommandBuffer
&
)
;
void
freeGPUResources
(
const
GrVkGpu
*
gpu
)
;
void
freeTempResources
(
const
GrVkGpu
*
gpu
)
;
void
abandonGPUResources
(
)
;
enum
StateKeyOffsets
{
kLength_StateKeyOffset
=
0
kData_StateKeyOffset
=
kLength_StateKeyOffset
+
sizeof
(
uint32_t
)
}
;
static
void
BuildStateKey
(
const
GrPipeline
&
GrPrimitiveType
primitiveType
SkTArray
<
unsigned
char
true
>
*
key
)
;
struct
Desc
{
uint32_t
fChecksum
;
GrVkProgramDesc
fProgramDesc
;
enum
{
kRenderPassKeyAlloc
=
12
kStencilKeyAlloc
=
sizeof
(
GrStencilSettings
)
kDrawFaceKeyAlloc
=
4
kBlendingKeyAlloc
=
4
kPrimitiveTypeKeyAlloc
=
4
kPreAllocSize
=
kData_StateKeyOffset
+
kRenderPassKeyAlloc
+
kStencilKeyAlloc
+
kDrawFaceKeyAlloc
+
kBlendingKeyAlloc
+
kPrimitiveTypeKeyAlloc
}
;
SkSTArray
<
kPreAllocSize
uint8_t
true
>
fStateKey
;
bool
operator
=
=
(
const
Desc
&
that
)
const
{
if
(
fChecksum
!
=
that
.
fChecksum
|
|
fProgramDesc
!
=
that
.
fProgramDesc
)
{
return
false
;
}
int
keyLength
=
fStateKey
.
count
(
)
;
SkASSERT
(
SkIsAlign4
(
keyLength
)
)
;
int
l
=
keyLength
>
>
2
;
const
uint32_t
*
aKey
=
reinterpret_cast
<
const
uint32_t
*
>
(
fStateKey
.
begin
(
)
)
;
const
uint32_t
*
bKey
=
reinterpret_cast
<
const
uint32_t
*
>
(
that
.
fStateKey
.
begin
(
)
)
;
for
(
int
i
=
0
;
i
<
l
;
+
+
i
)
{
if
(
aKey
[
i
]
!
=
bKey
[
i
]
)
{
return
false
;
}
}
return
true
;
}
static
bool
Less
(
const
Desc
&
a
const
Desc
&
b
)
{
if
(
a
.
fChecksum
!
=
b
.
fChecksum
)
{
return
a
.
fChecksum
<
b
.
fChecksum
?
true
:
false
;
}
bool
progDescLess
=
GrProgramDesc
:
:
Less
(
a
.
fProgramDesc
b
.
fProgramDesc
)
;
if
(
progDescLess
|
|
a
.
fProgramDesc
!
=
b
.
fProgramDesc
)
{
return
progDescLess
;
}
int
keyLength
=
a
.
fStateKey
.
count
(
)
;
SkASSERT
(
SkIsAlign4
(
keyLength
)
)
;
int
l
=
keyLength
>
>
2
;
const
uint32_t
*
aKey
=
reinterpret_cast
<
const
uint32_t
*
>
(
a
.
fStateKey
.
begin
(
)
)
;
const
uint32_t
*
bKey
=
reinterpret_cast
<
const
uint32_t
*
>
(
b
.
fStateKey
.
begin
(
)
)
;
for
(
int
i
=
0
;
i
<
l
;
+
+
i
)
{
if
(
aKey
[
i
]
!
=
bKey
[
i
]
)
{
return
aKey
[
i
]
<
bKey
[
i
]
?
true
:
false
;
}
}
return
false
;
}
}
;
const
Desc
&
getDesc
(
)
{
return
fDesc
;
}
private
:
typedef
GrVkPipelineStateDataManager
:
:
UniformInfoArray
UniformInfoArray
;
typedef
GrGLSLProgramDataManager
:
:
UniformHandle
UniformHandle
;
GrVkPipelineState
(
GrVkGpu
*
gpu
const
GrVkPipelineState
:
:
Desc
&
GrVkPipeline
*
pipeline
VkPipelineLayout
layout
VkDescriptorSetLayout
dsLayout
[
2
]
const
BuiltinUniformHandles
&
builtinUniformHandles
const
UniformInfoArray
&
uniforms
uint32_t
vertexUniformSize
uint32_t
fragmentUniformSize
uint32_t
numSamplers
GrGLSLPrimitiveProcessor
*
geometryProcessor
GrGLSLXferProcessor
*
xferProcessor
const
GrGLSLFragProcs
&
fragmentProcessors
)
;
struct
DescriptorPoolManager
{
DescriptorPoolManager
(
VkDescriptorSetLayout
layout
VkDescriptorType
type
uint32_t
descCount
GrVkGpu
*
gpu
)
:
fDescLayout
(
layout
)
fDescType
(
type
)
fCurrentDescriptorSet
(
0
)
fPool
(
nullptr
)
{
SkASSERT
(
descCount
<
(
kMaxDescSetLimit
>
>
2
)
)
;
fMaxDescriptorSets
=
descCount
<
<
2
;
this
-
>
getNewPool
(
gpu
)
;
}
~
DescriptorPoolManager
(
)
{
SkASSERT
(
!
fDescLayout
)
;
SkASSERT
(
!
fPool
)
;
}
void
getNewDescriptorSet
(
GrVkGpu
*
gpu
VkDescriptorSet
*
ds
)
;
void
freeGPUResources
(
const
GrVkGpu
*
gpu
)
;
void
abandonGPUResources
(
)
;
VkDescriptorSetLayout
fDescLayout
;
VkDescriptorType
fDescType
;
uint32_t
fMaxDescriptorSets
;
uint32_t
fCurrentDescriptorSet
;
GrVkDescriptorPool
*
fPool
;
private
:
static
const
uint32_t
kMaxDescSetLimit
=
1
<
<
10
;
void
getNewPool
(
GrVkGpu
*
gpu
)
;
}
;
void
writeUniformBuffers
(
const
GrVkGpu
*
gpu
)
;
void
writeSamplers
(
GrVkGpu
*
gpu
const
SkTArray
<
const
GrTextureAccess
*
>
&
textureBindings
)
;
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
void
getRTAdjustmentVec
(
float
*
destVec
)
{
destVec
[
0
]
=
2
.
f
/
fRenderTargetSize
.
fWidth
;
destVec
[
1
]
=
-
1
.
f
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
destVec
[
2
]
=
-
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
1
.
f
;
}
else
{
destVec
[
2
]
=
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
-
1
.
f
;
}
}
}
;
void
setRenderTargetState
(
const
GrPipeline
&
)
;
GrVkPipeline
*
fPipeline
;
VkPipelineLayout
fPipelineLayout
;
VkDescriptorSet
fDescriptorSets
[
2
]
;
int
fStartDS
;
int
fDSCount
;
SkAutoTDelete
<
GrVkUniformBuffer
>
fVertexUniformBuffer
;
SkAutoTDelete
<
GrVkUniformBuffer
>
fFragmentUniformBuffer
;
SkTDArray
<
GrVkSampler
*
>
fSamplers
;
SkTDArray
<
const
GrVkImageView
*
>
fTextureViews
;
SkTDArray
<
const
GrVkImage
:
:
Resource
*
>
fTextures
;
RenderTargetState
fRenderTargetState
;
BuiltinUniformHandles
fBuiltinUniformHandles
;
SkAutoTDelete
<
GrGLSLPrimitiveProcessor
>
fGeometryProcessor
;
SkAutoTDelete
<
GrGLSLXferProcessor
>
fXferProcessor
;
GrGLSLFragProcs
fFragmentProcessors
;
Desc
fDesc
;
GrVkPipelineStateDataManager
fDataManager
;
DescriptorPoolManager
fSamplerPoolManager
;
DescriptorPoolManager
fUniformPoolManager
;
int
fNumSamplers
;
friend
class
GrVkPipelineStateBuilder
;
}
;
#
endif
