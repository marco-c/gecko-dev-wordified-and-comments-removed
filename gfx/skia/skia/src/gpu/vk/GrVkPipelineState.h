#
ifndef
GrVkPipelineState_DEFINED
#
define
GrVkPipelineState_DEFINED
#
include
"
GrVkDescriptorSetManager
.
h
"
#
include
"
GrVkPipelineStateDataManager
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
vk
/
GrVkDefines
.
h
"
class
GrPipeline
;
class
GrStencilSettings
;
class
GrVkBufferView
;
class
GrVkCommandBuffer
;
class
GrVkDescriptorPool
;
class
GrVkDescriptorSet
;
class
GrVkGpu
;
class
GrVkImageView
;
class
GrVkPipeline
;
class
GrVkPipelineLayout
;
class
GrVkSampler
;
class
GrVkTexture
;
class
GrVkUniformBuffer
;
class
GrVkPipelineState
:
public
SkRefCnt
{
public
:
using
UniformInfoArray
=
GrVkPipelineStateDataManager
:
:
UniformInfoArray
;
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
GrVkPipelineState
(
GrVkGpu
*
gpu
GrVkPipeline
*
pipeline
VkPipelineLayout
layout
const
GrVkDescriptorSetManager
:
:
Handle
&
samplerDSHandle
const
GrGLSLBuiltinUniformHandles
&
builtinUniformHandles
const
UniformInfoArray
&
uniforms
uint32_t
geometryUniformSize
uint32_t
fragmentUniformSize
uint32_t
numSamplers
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
geometryProcessor
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
xferProcessor
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fragmentProcessors
int
fFragmentProcessorCnt
)
;
~
GrVkPipelineState
(
)
;
void
setAndBindUniforms
(
GrVkGpu
*
const
GrPrimitiveProcessor
&
const
GrPipeline
&
GrVkCommandBuffer
*
)
;
void
setAndBindTextures
(
GrVkGpu
*
const
GrPrimitiveProcessor
&
const
GrPipeline
&
const
GrTextureProxy
*
const
primitiveProcessorTextures
[
]
GrVkCommandBuffer
*
)
;
void
bindPipeline
(
const
GrVkGpu
*
gpu
GrVkCommandBuffer
*
commandBuffer
)
;
void
addUniformResources
(
GrVkCommandBuffer
&
GrVkSampler
*
[
]
GrVkTexture
*
[
]
int
numTextures
)
;
void
freeGPUResources
(
const
GrVkGpu
*
gpu
)
;
void
abandonGPUResources
(
)
;
private
:
void
writeUniformBuffers
(
const
GrVkGpu
*
gpu
)
;
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
void
getRTAdjustmentVec
(
float
*
destVec
)
{
destVec
[
0
]
=
2
.
f
/
fRenderTargetSize
.
fWidth
;
destVec
[
1
]
=
-
1
.
f
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
destVec
[
2
]
=
-
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
1
.
f
;
}
else
{
destVec
[
2
]
=
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
-
1
.
f
;
}
}
}
;
void
setRenderTargetState
(
const
GrRenderTargetProxy
*
)
;
GrVkPipeline
*
fPipeline
;
GrVkPipelineLayout
*
fPipelineLayout
;
VkDescriptorSet
fDescriptorSets
[
3
]
;
const
GrVkDescriptorSet
*
fUniformDescriptorSet
;
const
GrVkDescriptorSet
*
fSamplerDescriptorSet
;
const
GrVkDescriptorSetManager
:
:
Handle
fSamplerDSHandle
;
std
:
:
unique_ptr
<
GrVkUniformBuffer
>
fGeometryUniformBuffer
;
std
:
:
unique_ptr
<
GrVkUniformBuffer
>
fFragmentUniformBuffer
;
RenderTargetState
fRenderTargetState
;
GrGLSLBuiltinUniformHandles
fBuiltinUniformHandles
;
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
fGeometryProcessor
;
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
fXferProcessor
;
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fFragmentProcessors
;
int
fFragmentProcessorCnt
;
GrVkPipelineStateDataManager
fDataManager
;
int
fNumSamplers
;
}
;
#
endif
