#
ifndef
GrVkOpsRenderPass_DEFINED
#
define
GrVkOpsRenderPass_DEFINED
#
include
"
src
/
gpu
/
GrOpsRenderPass
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
src
/
gpu
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
GrMesh
.
h
"
#
include
"
src
/
gpu
/
GrTRecorder
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkPipelineState
.
h
"
class
GrVkGpu
;
class
GrVkImage
;
class
GrVkRenderPass
;
class
GrVkRenderTarget
;
class
GrVkSecondaryCommandBuffer
;
class
GrVkOpsRenderPass
:
public
GrOpsRenderPass
private
GrMesh
:
:
SendToGpuImpl
{
public
:
GrVkOpsRenderPass
(
GrVkGpu
*
)
;
~
GrVkOpsRenderPass
(
)
override
;
void
begin
(
)
override
{
}
void
end
(
)
override
;
void
insertEventMarker
(
const
char
*
)
override
;
void
inlineUpload
(
GrOpFlushState
*
state
GrDeferredTextureUploadFn
&
upload
)
override
;
void
executeDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
)
override
;
void
set
(
GrRenderTarget
*
GrSurfaceOrigin
const
SkIRect
&
bounds
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
&
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
&
const
SkTArray
<
GrTextureProxy
*
true
>
&
sampledProxies
)
;
void
reset
(
)
;
void
submit
(
)
;
#
ifdef
SK_DEBUG
bool
isActive
(
)
const
{
return
fIsActive
;
}
#
endif
private
:
void
init
(
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
&
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
&
const
SkPMColor4f
&
clearColor
)
;
void
initWrapped
(
)
;
bool
wrapsSecondaryCommandBuffer
(
)
const
;
GrGpu
*
gpu
(
)
override
;
GrVkCommandBuffer
*
currentCommandBuffer
(
)
;
void
bindGeometry
(
const
GrGpuBuffer
*
indexBuffer
const
GrGpuBuffer
*
vertexBuffer
const
GrGpuBuffer
*
instanceBuffer
)
;
GrVkPipelineState
*
prepareDrawState
(
const
GrProgramInfo
&
GrPrimitiveType
const
SkIRect
&
renderPassScissorRect
)
;
void
onDraw
(
const
GrProgramInfo
&
const
GrMesh
[
]
int
meshCount
const
SkRect
&
bounds
)
override
;
void
sendMeshToGpu
(
GrPrimitiveType
primType
const
GrBuffer
*
vertexBuffer
int
vertexCount
int
baseVertex
)
final
{
this
-
>
sendInstancedMeshToGpu
(
primType
vertexBuffer
vertexCount
baseVertex
nullptr
1
0
)
;
}
void
sendIndexedMeshToGpu
(
GrPrimitiveType
primType
const
GrBuffer
*
indexBuffer
int
indexCount
int
baseIndex
uint16_t
uint16_t
const
GrBuffer
*
vertexBuffer
int
baseVertex
GrPrimitiveRestart
restart
)
final
{
SkASSERT
(
restart
=
=
GrPrimitiveRestart
:
:
kNo
)
;
this
-
>
sendIndexedInstancedMeshToGpu
(
primType
indexBuffer
indexCount
baseIndex
vertexBuffer
baseVertex
nullptr
1
0
GrPrimitiveRestart
:
:
kNo
)
;
}
void
sendInstancedMeshToGpu
(
GrPrimitiveType
const
GrBuffer
*
vertexBuffer
int
vertexCount
int
baseVertex
const
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
)
final
;
void
sendIndexedInstancedMeshToGpu
(
GrPrimitiveType
const
GrBuffer
*
indexBuffer
int
indexCount
int
baseIndex
const
GrBuffer
*
vertexBuffer
int
baseVertex
const
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
GrPrimitiveRestart
)
final
;
void
onClear
(
const
GrFixedClip
&
const
SkPMColor4f
&
color
)
override
;
void
onClearStencilClip
(
const
GrFixedClip
&
bool
insideStencilMask
)
override
;
void
addAdditionalRenderPass
(
bool
mustUseSecondaryCommandBuffer
)
;
std
:
:
unique_ptr
<
GrVkSecondaryCommandBuffer
>
fCurrentSecondaryCommandBuffer
;
const
GrVkRenderPass
*
fCurrentRenderPass
;
bool
fCurrentCBIsEmpty
=
true
;
SkIRect
fBounds
;
GrVkGpu
*
fGpu
;
#
ifdef
SK_DEBUG
bool
fIsActive
=
false
;
#
endif
typedef
GrOpsRenderPass
INHERITED
;
}
;
#
endif
