#
ifndef
GrVkTexture_DEFINED
#
define
GrVkTexture_DEFINED
#
include
"
GrTexture
.
h
"
#
include
"
GrVkImage
.
h
"
#
include
"
vk
/
GrVkTypes
.
h
"
class
GrVkGpu
;
class
GrVkImageView
;
struct
GrVkImageInfo
;
class
GrVkTexture
:
public
GrTexture
public
virtual
GrVkImage
{
public
:
static
sk_sp
<
GrVkTexture
>
MakeNewTexture
(
GrVkGpu
*
SkBudgeted
budgeted
const
GrSurfaceDesc
&
const
GrVkImage
:
:
ImageDesc
&
GrMipMapsStatus
)
;
static
sk_sp
<
GrVkTexture
>
MakeWrappedTexture
(
GrVkGpu
*
const
GrSurfaceDesc
&
GrWrapOwnership
GrWrapCacheable
GrIOType
const
GrVkImageInfo
&
sk_sp
<
GrVkImageLayout
>
)
;
~
GrVkTexture
(
)
override
;
GrBackendTexture
getBackendTexture
(
)
const
override
;
GrBackendFormat
backendFormat
(
)
const
override
{
return
this
-
>
getBackendFormat
(
)
;
}
void
textureParamsModified
(
)
override
{
}
const
GrVkImageView
*
textureView
(
)
;
void
addIdleProc
(
sk_sp
<
GrRefCntedCallback
>
IdleState
)
override
;
void
callIdleProcsOnBehalfOfResource
(
)
;
protected
:
GrVkTexture
(
GrVkGpu
*
const
GrSurfaceDesc
&
const
GrVkImageInfo
&
sk_sp
<
GrVkImageLayout
>
const
GrVkImageView
*
GrMipMapsStatus
GrBackendObjectOwnership
)
;
GrVkGpu
*
getVkGpu
(
)
const
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
bool
onStealBackendTexture
(
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
override
{
return
false
;
}
void
willRemoveLastRefOrPendingIO
(
)
override
;
private
:
GrVkTexture
(
GrVkGpu
*
SkBudgeted
const
GrSurfaceDesc
&
const
GrVkImageInfo
&
sk_sp
<
GrVkImageLayout
>
layout
const
GrVkImageView
*
imageView
GrMipMapsStatus
)
;
GrVkTexture
(
GrVkGpu
*
const
GrSurfaceDesc
&
const
GrVkImageInfo
&
sk_sp
<
GrVkImageLayout
>
const
GrVkImageView
*
GrMipMapsStatus
GrBackendObjectOwnership
GrWrapCacheable
GrIOType
)
;
void
onSetRelease
(
sk_sp
<
GrRefCntedCallback
>
releaseHelper
)
override
{
this
-
>
setResourceRelease
(
std
:
:
move
(
releaseHelper
)
)
;
}
void
removeFinishIdleProcs
(
)
;
const
GrVkImageView
*
fTextureView
;
typedef
GrTexture
INHERITED
;
}
;
#
endif
