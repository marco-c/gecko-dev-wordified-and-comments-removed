#
ifndef
GrVkResource_DEFINED
#
define
GrVkResource_DEFINED
#
include
"
include
/
private
/
SkTHash
.
h
"
#
include
"
include
/
utils
/
SkRandom
.
h
"
#
include
<
atomic
>
class
GrVkGpu
;
#
ifdef
SK_DEBUG
#
define
SK_TRACE_VK_RESOURCES
#
endif
class
GrVkResource
:
SkNoncopyable
{
public
:
#
ifdef
SK_TRACE_VK_RESOURCES
struct
Hash
{
uint32_t
operator
(
)
(
const
GrVkResource
*
const
&
r
)
const
{
SkASSERT
(
r
)
;
return
r
-
>
fKey
;
}
}
;
class
Trace
{
public
:
~
Trace
(
)
{
fHashSet
.
foreach
(
[
]
(
const
GrVkResource
*
r
)
{
r
-
>
dumpInfo
(
)
;
}
)
;
SkASSERT
(
0
=
=
fHashSet
.
count
(
)
)
;
}
void
add
(
const
GrVkResource
*
r
)
{
fHashSet
.
add
(
r
)
;
}
void
remove
(
const
GrVkResource
*
r
)
{
fHashSet
.
remove
(
r
)
;
}
private
:
SkTHashSet
<
const
GrVkResource
*
GrVkResource
:
:
Hash
>
fHashSet
;
}
;
static
std
:
:
atomic
<
uint32_t
>
fKeyCounter
;
#
endif
GrVkResource
(
)
:
fRefCnt
(
1
)
{
#
ifdef
SK_TRACE_VK_RESOURCES
fKey
=
fKeyCounter
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
GetTrace
(
)
-
>
add
(
this
)
;
#
endif
}
virtual
~
GrVkResource
(
)
{
#
ifdef
SK_DEBUG
auto
count
=
this
-
>
getRefCnt
(
)
;
SkASSERTF
(
count
=
=
1
"
fRefCnt
was
%
d
"
count
)
;
fRefCnt
.
store
(
0
)
;
#
endif
}
#
ifdef
SK_DEBUG
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
.
load
(
)
;
}
#
endif
bool
unique
(
)
const
{
return
1
=
=
fRefCnt
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
ref
(
)
const
{
SkDEBUGCODE
(
int
newRefCount
=
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
SkASSERT
(
newRefCount
>
=
1
)
;
}
void
unref
(
GrVkGpu
*
gpu
)
const
{
SkASSERT
(
gpu
)
;
int
newRefCount
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
;
SkASSERT
(
newRefCount
>
=
0
)
;
if
(
newRefCount
=
=
1
)
{
this
-
>
internal_dispose
(
gpu
)
;
}
}
void
unrefAndAbandon
(
)
const
{
SkASSERT
(
this
-
>
getRefCnt
(
)
>
0
)
;
int
newRefCount
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
;
SkASSERT
(
newRefCount
>
=
0
)
;
if
(
newRefCount
=
=
1
)
{
this
-
>
internal_dispose
(
)
;
}
}
virtual
void
notifyAddedToCommandBuffer
(
)
const
{
}
virtual
void
notifyRemovedFromCommandBuffer
(
)
const
{
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
this
-
>
getRefCnt
(
)
>
0
)
;
}
#
endif
#
ifdef
SK_TRACE_VK_RESOURCES
virtual
void
dumpInfo
(
)
const
=
0
;
#
endif
private
:
#
ifdef
SK_TRACE_VK_RESOURCES
static
Trace
*
GetTrace
(
)
{
static
Trace
kTrace
;
return
&
kTrace
;
}
#
endif
virtual
void
freeGPUData
(
GrVkGpu
*
gpu
)
const
=
0
;
virtual
void
abandonGPUData
(
)
const
{
}
void
internal_dispose
(
GrVkGpu
*
gpu
)
const
{
this
-
>
freeGPUData
(
gpu
)
;
#
ifdef
SK_TRACE_VK_RESOURCES
GetTrace
(
)
-
>
remove
(
this
)
;
#
endif
#
ifdef
SK_DEBUG
SkASSERT
(
0
=
=
this
-
>
getRefCnt
(
)
)
;
fRefCnt
.
store
(
1
)
;
#
endif
delete
this
;
}
void
internal_dispose
(
)
const
{
this
-
>
abandonGPUData
(
)
;
#
ifdef
SK_TRACE_VK_RESOURCES
GetTrace
(
)
-
>
remove
(
this
)
;
#
endif
#
ifdef
SK_DEBUG
SkASSERT
(
0
=
=
this
-
>
getRefCnt
(
)
)
;
fRefCnt
.
store
(
1
)
;
#
endif
delete
this
;
}
mutable
std
:
:
atomic
<
int32_t
>
fRefCnt
;
#
ifdef
SK_TRACE_VK_RESOURCES
uint32_t
fKey
;
#
endif
typedef
SkNoncopyable
INHERITED
;
}
;
class
GrVkRecycledResource
:
public
GrVkResource
{
public
:
void
recycle
(
GrVkGpu
*
gpu
)
const
{
if
(
this
-
>
unique
(
)
)
{
this
-
>
onRecycle
(
gpu
)
;
}
else
{
this
-
>
unref
(
gpu
)
;
}
}
private
:
virtual
void
onRecycle
(
GrVkGpu
*
gpu
)
const
=
0
;
}
;
#
endif
