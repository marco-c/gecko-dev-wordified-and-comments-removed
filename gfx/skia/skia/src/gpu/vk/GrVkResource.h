#
ifndef
GrVkResource_DEFINED
#
define
GrVkResource_DEFINED
#
include
"
SkAtomics
.
h
"
#
include
"
SkRandom
.
h
"
#
include
"
SkTHash
.
h
"
class
GrVkGpu
;
#
ifdef
SK_DEBUG
#
define
SK_TRACE_VK_RESOURCES
#
endif
class
GrVkResource
:
SkNoncopyable
{
public
:
#
ifdef
SK_TRACE_VK_RESOURCES
struct
Hash
{
uint32_t
operator
(
)
(
const
GrVkResource
*
const
&
r
)
const
{
SkASSERT
(
r
)
;
return
r
-
>
fKey
;
}
}
;
class
Trace
{
public
:
~
Trace
(
)
{
fHashSet
.
foreach
(
[
]
(
const
GrVkResource
*
r
)
{
r
-
>
dumpInfo
(
)
;
}
)
;
SkASSERT
(
0
=
=
fHashSet
.
count
(
)
)
;
}
void
add
(
const
GrVkResource
*
r
)
{
fHashSet
.
add
(
r
)
;
}
void
remove
(
const
GrVkResource
*
r
)
{
fHashSet
.
remove
(
r
)
;
}
private
:
SkTHashSet
<
const
GrVkResource
*
GrVkResource
:
:
Hash
>
fHashSet
;
}
;
static
uint32_t
fKeyCounter
;
#
endif
GrVkResource
(
)
:
fRefCnt
(
1
)
{
#
ifdef
SK_TRACE_VK_RESOURCES
fKey
=
sk_atomic_fetch_add
(
&
fKeyCounter
1u
sk_memory_order_relaxed
)
;
GetTrace
(
)
-
>
add
(
this
)
;
#
endif
}
virtual
~
GrVkResource
(
)
{
#
ifdef
SK_DEBUG
SkASSERTF
(
fRefCnt
=
=
1
"
fRefCnt
was
%
d
"
fRefCnt
)
;
fRefCnt
=
0
;
#
endif
}
#
ifdef
SK_DEBUG
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
;
}
#
endif
bool
unique
(
)
const
{
if
(
1
=
=
sk_atomic_load
(
&
fRefCnt
sk_memory_order_acquire
)
)
{
return
true
;
}
return
false
;
}
void
ref
(
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
(
void
)
sk_atomic_fetch_add
(
&
fRefCnt
+
1
sk_memory_order_relaxed
)
;
}
void
unref
(
const
GrVkGpu
*
gpu
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
SkASSERT
(
gpu
)
;
if
(
1
=
=
sk_atomic_fetch_add
(
&
fRefCnt
-
1
sk_memory_order_acq_rel
)
)
{
this
-
>
internal_dispose
(
gpu
)
;
}
}
void
unrefAndAbandon
(
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
if
(
1
=
=
sk_atomic_fetch_add
(
&
fRefCnt
-
1
sk_memory_order_acq_rel
)
)
{
this
-
>
internal_dispose
(
)
;
}
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
}
#
endif
#
ifdef
SK_TRACE_VK_RESOURCES
virtual
void
dumpInfo
(
)
const
=
0
;
#
endif
private
:
#
ifdef
SK_TRACE_VK_RESOURCES
static
Trace
*
GetTrace
(
)
{
static
Trace
kTrace
;
return
&
kTrace
;
}
#
endif
virtual
void
freeGPUData
(
const
GrVkGpu
*
gpu
)
const
=
0
;
virtual
void
abandonGPUData
(
)
const
{
}
void
internal_dispose
(
const
GrVkGpu
*
gpu
)
const
{
this
-
>
freeGPUData
(
gpu
)
;
#
ifdef
SK_TRACE_VK_RESOURCES
GetTrace
(
)
-
>
remove
(
this
)
;
#
endif
SkASSERT
(
0
=
=
fRefCnt
)
;
fRefCnt
=
1
;
delete
this
;
}
void
internal_dispose
(
)
const
{
this
-
>
abandonGPUData
(
)
;
#
ifdef
SK_TRACE_VK_RESOURCES
GetTrace
(
)
-
>
remove
(
this
)
;
#
endif
SkASSERT
(
0
=
=
fRefCnt
)
;
fRefCnt
=
1
;
delete
this
;
}
mutable
int32_t
fRefCnt
;
#
ifdef
SK_TRACE_VK_RESOURCES
uint32_t
fKey
;
#
endif
typedef
SkNoncopyable
INHERITED
;
}
;
class
GrVkRecycledResource
:
public
GrVkResource
{
public
:
void
recycle
(
GrVkGpu
*
gpu
)
const
{
if
(
this
-
>
unique
(
)
)
{
this
-
>
onRecycle
(
gpu
)
;
}
else
{
this
-
>
unref
(
gpu
)
;
}
}
private
:
virtual
void
onRecycle
(
GrVkGpu
*
gpu
)
const
=
0
;
}
;
#
endif
