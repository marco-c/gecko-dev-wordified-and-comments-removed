#
include
"
GrVkUniformHandler
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
uint32_t
grsltype_to_alignment_mask
(
GrSLType
type
)
{
switch
(
type
)
{
case
kByte_GrSLType
:
case
kUByte_GrSLType
:
return
0x0
;
case
kByte2_GrSLType
:
case
kUByte2_GrSLType
:
return
0x1
;
case
kByte3_GrSLType
:
case
kByte4_GrSLType
:
case
kUByte3_GrSLType
:
case
kUByte4_GrSLType
:
return
0x3
;
case
kShort_GrSLType
:
case
kUShort_GrSLType
:
return
0x1
;
case
kShort2_GrSLType
:
case
kUShort2_GrSLType
:
return
0x3
;
case
kShort3_GrSLType
:
case
kShort4_GrSLType
:
case
kUShort3_GrSLType
:
case
kUShort4_GrSLType
:
return
0x7
;
case
kInt_GrSLType
:
case
kUint_GrSLType
:
return
0x3
;
case
kHalf_GrSLType
:
case
kFloat_GrSLType
:
return
0x3
;
case
kHalf2_GrSLType
:
case
kFloat2_GrSLType
:
return
0x7
;
case
kHalf3_GrSLType
:
case
kFloat3_GrSLType
:
return
0xF
;
case
kHalf4_GrSLType
:
case
kFloat4_GrSLType
:
return
0xF
;
case
kUint2_GrSLType
:
return
0x7
;
case
kInt2_GrSLType
:
return
0x7
;
case
kInt3_GrSLType
:
return
0xF
;
case
kInt4_GrSLType
:
return
0xF
;
case
kHalf2x2_GrSLType
:
case
kFloat2x2_GrSLType
:
return
0x7
;
case
kHalf3x3_GrSLType
:
case
kFloat3x3_GrSLType
:
return
0xF
;
case
kHalf4x4_GrSLType
:
case
kFloat4x4_GrSLType
:
return
0xF
;
case
kVoid_GrSLType
:
case
kBool_GrSLType
:
case
kTexture2DSampler_GrSLType
:
case
kTextureExternalSampler_GrSLType
:
case
kTexture2DRectSampler_GrSLType
:
break
;
}
SK_ABORT
(
"
Unexpected
type
"
)
;
return
0
;
}
static
inline
uint32_t
grsltype_to_vk_size
(
GrSLType
type
)
{
switch
(
type
)
{
case
kByte_GrSLType
:
return
sizeof
(
int8_t
)
;
case
kByte2_GrSLType
:
return
2
*
sizeof
(
int8_t
)
;
case
kByte3_GrSLType
:
return
3
*
sizeof
(
int8_t
)
;
case
kByte4_GrSLType
:
return
4
*
sizeof
(
int8_t
)
;
case
kUByte_GrSLType
:
return
sizeof
(
uint8_t
)
;
case
kUByte2_GrSLType
:
return
2
*
sizeof
(
uint8_t
)
;
case
kUByte3_GrSLType
:
return
3
*
sizeof
(
uint8_t
)
;
case
kUByte4_GrSLType
:
return
4
*
sizeof
(
uint8_t
)
;
case
kShort_GrSLType
:
return
sizeof
(
int16_t
)
;
case
kShort2_GrSLType
:
return
2
*
sizeof
(
int16_t
)
;
case
kShort3_GrSLType
:
return
3
*
sizeof
(
int16_t
)
;
case
kShort4_GrSLType
:
return
4
*
sizeof
(
int16_t
)
;
case
kUShort_GrSLType
:
return
sizeof
(
uint16_t
)
;
case
kUShort2_GrSLType
:
return
2
*
sizeof
(
uint16_t
)
;
case
kUShort3_GrSLType
:
return
3
*
sizeof
(
uint16_t
)
;
case
kUShort4_GrSLType
:
return
4
*
sizeof
(
uint16_t
)
;
case
kInt_GrSLType
:
return
sizeof
(
int32_t
)
;
case
kUint_GrSLType
:
return
sizeof
(
int32_t
)
;
case
kHalf_GrSLType
:
case
kFloat_GrSLType
:
return
sizeof
(
float
)
;
case
kHalf2_GrSLType
:
case
kFloat2_GrSLType
:
return
2
*
sizeof
(
float
)
;
case
kHalf3_GrSLType
:
case
kFloat3_GrSLType
:
return
3
*
sizeof
(
float
)
;
case
kHalf4_GrSLType
:
case
kFloat4_GrSLType
:
return
4
*
sizeof
(
float
)
;
case
kUint2_GrSLType
:
return
2
*
sizeof
(
uint32_t
)
;
case
kInt2_GrSLType
:
return
2
*
sizeof
(
int32_t
)
;
case
kInt3_GrSLType
:
return
3
*
sizeof
(
int32_t
)
;
case
kInt4_GrSLType
:
return
4
*
sizeof
(
int32_t
)
;
case
kHalf2x2_GrSLType
:
case
kFloat2x2_GrSLType
:
return
8
*
sizeof
(
float
)
;
case
kHalf3x3_GrSLType
:
case
kFloat3x3_GrSLType
:
return
12
*
sizeof
(
float
)
;
case
kHalf4x4_GrSLType
:
case
kFloat4x4_GrSLType
:
return
16
*
sizeof
(
float
)
;
case
kVoid_GrSLType
:
case
kBool_GrSLType
:
case
kTexture2DSampler_GrSLType
:
case
kTextureExternalSampler_GrSLType
:
case
kTexture2DRectSampler_GrSLType
:
break
;
}
SK_ABORT
(
"
Unexpected
type
"
)
;
return
0
;
}
void
get_ubo_aligned_offset
(
uint32_t
*
uniformOffset
uint32_t
*
currentOffset
GrSLType
type
int
arrayCount
)
{
uint32_t
alignmentMask
=
grsltype_to_alignment_mask
(
type
)
;
if
(
arrayCount
|
|
type
=
=
kFloat2x2_GrSLType
)
{
alignmentMask
=
0xF
;
}
uint32_t
offsetDiff
=
*
currentOffset
&
alignmentMask
;
if
(
offsetDiff
!
=
0
)
{
offsetDiff
=
alignmentMask
-
offsetDiff
+
1
;
}
*
uniformOffset
=
*
currentOffset
+
offsetDiff
;
SkASSERT
(
sizeof
(
float
)
=
=
4
)
;
if
(
arrayCount
)
{
uint32_t
elementSize
=
SkTMax
<
uint32_t
>
(
16
grsltype_to_vk_size
(
type
)
)
;
SkASSERT
(
0
=
=
(
elementSize
&
0xF
)
)
;
*
currentOffset
=
*
uniformOffset
+
elementSize
*
arrayCount
;
}
else
{
*
currentOffset
=
*
uniformOffset
+
grsltype_to_vk_size
(
type
)
;
}
}
GrGLSLUniformHandler
:
:
UniformHandle
GrVkUniformHandler
:
:
internalAddUniformArray
(
uint32_t
visibility
GrSLType
type
GrSLPrecision
precision
const
char
*
name
bool
mangleName
int
arrayCount
const
char
*
*
outName
)
{
SkASSERT
(
name
&
&
strlen
(
name
)
)
;
SkASSERT
(
kVertex_GrShaderFlag
=
=
visibility
|
|
kGeometry_GrShaderFlag
=
=
visibility
|
|
(
kVertex_GrShaderFlag
|
kGeometry_GrShaderFlag
)
=
=
visibility
|
|
kFragment_GrShaderFlag
=
=
visibility
)
;
SkASSERT
(
kDefault_GrSLPrecision
=
=
precision
|
|
GrSLTypeIsFloatType
(
type
)
)
;
GrSLTypeIsFloatType
(
type
)
;
UniformInfo
&
uni
=
fUniforms
.
push_back
(
)
;
uni
.
fVariable
.
setType
(
type
)
;
char
prefix
=
'
u
'
;
if
(
'
u
'
=
=
name
[
0
]
|
|
!
strncmp
(
name
GR_NO_MANGLE_PREFIX
strlen
(
GR_NO_MANGLE_PREFIX
)
)
)
{
prefix
=
'
\
0
'
;
}
fProgramBuilder
-
>
nameVariable
(
uni
.
fVariable
.
accessName
(
)
prefix
name
mangleName
)
;
uni
.
fVariable
.
setArrayCount
(
arrayCount
)
;
uni
.
fVisibility
=
visibility
;
uni
.
fVariable
.
setPrecision
(
precision
)
;
uni
.
fVariable
.
setTypeModifier
(
GrShaderVar
:
:
kNone_TypeModifier
)
;
uint32_t
*
currentOffset
;
uint32_t
geomStages
=
kVertex_GrShaderFlag
|
kGeometry_GrShaderFlag
;
if
(
geomStages
&
visibility
)
{
currentOffset
=
&
fCurrentGeometryUBOOffset
;
}
else
{
SkASSERT
(
kFragment_GrShaderFlag
=
=
visibility
)
;
currentOffset
=
&
fCurrentFragmentUBOOffset
;
}
get_ubo_aligned_offset
(
&
uni
.
fUBOffset
currentOffset
type
arrayCount
)
;
SkString
layoutQualifier
;
layoutQualifier
.
appendf
(
"
offset
=
%
d
"
uni
.
fUBOffset
)
;
uni
.
fVariable
.
addLayoutQualifier
(
layoutQualifier
.
c_str
(
)
)
;
if
(
outName
)
{
*
outName
=
uni
.
fVariable
.
c_str
(
)
;
}
return
GrGLSLUniformHandler
:
:
UniformHandle
(
fUniforms
.
count
(
)
-
1
)
;
}
GrGLSLUniformHandler
:
:
SamplerHandle
GrVkUniformHandler
:
:
addSampler
(
GrSwizzle
swizzle
GrTextureType
type
GrSLPrecision
precision
const
char
*
name
)
{
SkASSERT
(
name
&
&
strlen
(
name
)
)
;
SkString
mangleName
;
char
prefix
=
'
u
'
;
fProgramBuilder
-
>
nameVariable
(
&
mangleName
prefix
name
true
)
;
UniformInfo
&
info
=
fSamplers
.
push_back
(
)
;
info
.
fVariable
.
setType
(
GrSLCombinedSamplerTypeForTextureType
(
type
)
)
;
info
.
fVariable
.
setTypeModifier
(
GrShaderVar
:
:
kUniform_TypeModifier
)
;
info
.
fVariable
.
setPrecision
(
precision
)
;
info
.
fVariable
.
setName
(
mangleName
)
;
SkString
layoutQualifier
;
layoutQualifier
.
appendf
(
"
set
=
%
d
binding
=
%
d
"
kSamplerDescSet
fSamplers
.
count
(
)
-
1
)
;
info
.
fVariable
.
addLayoutQualifier
(
layoutQualifier
.
c_str
(
)
)
;
info
.
fVisibility
=
kFragment_GrShaderFlag
;
info
.
fUBOffset
=
0
;
fSamplerSwizzles
.
push_back
(
swizzle
)
;
SkASSERT
(
fSamplerSwizzles
.
count
(
)
=
=
fSamplers
.
count
(
)
)
;
return
GrGLSLUniformHandler
:
:
SamplerHandle
(
fSamplers
.
count
(
)
-
1
)
;
}
void
GrVkUniformHandler
:
:
appendUniformDecls
(
GrShaderFlags
visibility
SkString
*
out
)
const
{
SkASSERT
(
kVertex_GrShaderFlag
=
=
visibility
|
|
kGeometry_GrShaderFlag
=
=
visibility
|
|
kFragment_GrShaderFlag
=
=
visibility
)
;
for
(
int
i
=
0
;
i
<
fSamplers
.
count
(
)
;
+
+
i
)
{
const
UniformInfo
&
sampler
=
fSamplers
[
i
]
;
SkASSERT
(
sampler
.
fVariable
.
getType
(
)
=
=
kTexture2DSampler_GrSLType
)
;
if
(
visibility
=
=
sampler
.
fVisibility
)
{
sampler
.
fVariable
.
appendDecl
(
fProgramBuilder
-
>
shaderCaps
(
)
out
)
;
out
-
>
append
(
"
;
\
n
"
)
;
}
}
#
ifdef
SK_DEBUG
bool
firstGeomOffsetCheck
=
false
;
bool
firstFragOffsetCheck
=
false
;
for
(
int
i
=
0
;
i
<
fUniforms
.
count
(
)
;
+
+
i
)
{
const
UniformInfo
&
localUniform
=
fUniforms
[
i
]
;
if
(
kVertex_GrShaderFlag
=
=
localUniform
.
fVisibility
|
|
kGeometry_GrShaderFlag
=
=
localUniform
.
fVisibility
|
|
(
kVertex_GrShaderFlag
|
kGeometry_GrShaderFlag
)
=
=
localUniform
.
fVisibility
)
{
if
(
!
firstGeomOffsetCheck
)
{
SkASSERT
(
0
=
=
localUniform
.
fUBOffset
)
;
firstGeomOffsetCheck
=
true
;
}
}
else
{
SkASSERT
(
kFragment_GrShaderFlag
=
=
localUniform
.
fVisibility
)
;
if
(
!
firstFragOffsetCheck
)
{
SkASSERT
(
0
=
=
localUniform
.
fUBOffset
)
;
firstFragOffsetCheck
=
true
;
}
}
}
#
endif
SkString
uniformsString
;
for
(
int
i
=
0
;
i
<
fUniforms
.
count
(
)
;
+
+
i
)
{
const
UniformInfo
&
localUniform
=
fUniforms
[
i
]
;
if
(
visibility
&
localUniform
.
fVisibility
)
{
if
(
GrSLTypeIsFloatType
(
localUniform
.
fVariable
.
getType
(
)
)
)
{
localUniform
.
fVariable
.
appendDecl
(
fProgramBuilder
-
>
shaderCaps
(
)
&
uniformsString
)
;
uniformsString
.
append
(
"
;
\
n
"
)
;
}
}
}
if
(
!
uniformsString
.
isEmpty
(
)
)
{
uint32_t
uniformBinding
;
const
char
*
stage
;
if
(
kVertex_GrShaderFlag
=
=
visibility
)
{
uniformBinding
=
kGeometryBinding
;
stage
=
"
vertex
"
;
}
else
if
(
kGeometry_GrShaderFlag
=
=
visibility
)
{
uniformBinding
=
kGeometryBinding
;
stage
=
"
geometry
"
;
}
else
{
SkASSERT
(
kFragment_GrShaderFlag
=
=
visibility
)
;
uniformBinding
=
kFragBinding
;
stage
=
"
fragment
"
;
}
out
-
>
appendf
(
"
layout
(
set
=
%
d
binding
=
%
d
)
uniform
%
sUniformBuffer
\
n
{
\
n
"
kUniformBufferDescSet
uniformBinding
stage
)
;
out
-
>
appendf
(
"
%
s
\
n
}
;
\
n
"
uniformsString
.
c_str
(
)
)
;
}
}
