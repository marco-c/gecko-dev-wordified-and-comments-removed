#
include
"
GrVkUniformHandler
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
uint32_t
grsltype_to_alignment_mask
(
GrSLType
type
)
{
SkASSERT
(
GrSLTypeIsFloatType
(
type
)
)
;
static
const
uint32_t
kAlignmentMask
[
]
=
{
0x0
0x3
0x7
0xF
0xF
0x7
0xF
0xF
0x0
0x0
0x0
0x0
0x0
0x7
0x7
0x0
0x0
}
;
GR_STATIC_ASSERT
(
0
=
=
kVoid_GrSLType
)
;
GR_STATIC_ASSERT
(
1
=
=
kFloat_GrSLType
)
;
GR_STATIC_ASSERT
(
2
=
=
kVec2f_GrSLType
)
;
GR_STATIC_ASSERT
(
3
=
=
kVec3f_GrSLType
)
;
GR_STATIC_ASSERT
(
4
=
=
kVec4f_GrSLType
)
;
GR_STATIC_ASSERT
(
5
=
=
kMat22f_GrSLType
)
;
GR_STATIC_ASSERT
(
6
=
=
kMat33f_GrSLType
)
;
GR_STATIC_ASSERT
(
7
=
=
kMat44f_GrSLType
)
;
GR_STATIC_ASSERT
(
8
=
=
kTexture2DSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
9
=
=
kTextureExternalSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
10
=
=
kTexture2DRectSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
11
=
=
kTextureBufferSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
12
=
=
kBool_GrSLType
)
;
GR_STATIC_ASSERT
(
13
=
=
kInt_GrSLType
)
;
GR_STATIC_ASSERT
(
14
=
=
kUint_GrSLType
)
;
GR_STATIC_ASSERT
(
15
=
=
kTexture2D_GrSLType
)
;
GR_STATIC_ASSERT
(
16
=
=
kSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
kAlignmentMask
)
=
=
kGrSLTypeCount
)
;
return
kAlignmentMask
[
type
]
;
}
static
inline
uint32_t
grsltype_to_vk_size
(
GrSLType
type
)
{
SkASSERT
(
GrSLTypeIsFloatType
(
type
)
)
;
static
const
uint32_t
kSizes
[
]
=
{
0
sizeof
(
float
)
2
*
sizeof
(
float
)
3
*
sizeof
(
float
)
4
*
sizeof
(
float
)
8
*
sizeof
(
float
)
12
*
sizeof
(
float
)
16
*
sizeof
(
float
)
0
0
0
0
1
4
4
0
0
}
;
return
kSizes
[
type
]
;
GR_STATIC_ASSERT
(
0
=
=
kVoid_GrSLType
)
;
GR_STATIC_ASSERT
(
1
=
=
kFloat_GrSLType
)
;
GR_STATIC_ASSERT
(
2
=
=
kVec2f_GrSLType
)
;
GR_STATIC_ASSERT
(
3
=
=
kVec3f_GrSLType
)
;
GR_STATIC_ASSERT
(
4
=
=
kVec4f_GrSLType
)
;
GR_STATIC_ASSERT
(
5
=
=
kMat22f_GrSLType
)
;
GR_STATIC_ASSERT
(
6
=
=
kMat33f_GrSLType
)
;
GR_STATIC_ASSERT
(
7
=
=
kMat44f_GrSLType
)
;
GR_STATIC_ASSERT
(
8
=
=
kTexture2DSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
9
=
=
kTextureExternalSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
10
=
=
kTexture2DRectSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
11
=
=
kTextureBufferSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
12
=
=
kBool_GrSLType
)
;
GR_STATIC_ASSERT
(
13
=
=
kInt_GrSLType
)
;
GR_STATIC_ASSERT
(
14
=
=
kUint_GrSLType
)
;
GR_STATIC_ASSERT
(
15
=
=
kTexture2D_GrSLType
)
;
GR_STATIC_ASSERT
(
16
=
=
kSampler_GrSLType
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
kSizes
)
=
=
kGrSLTypeCount
)
;
}
void
get_ubo_aligned_offset
(
uint32_t
*
uniformOffset
uint32_t
*
currentOffset
GrSLType
type
int
arrayCount
)
{
uint32_t
alignmentMask
=
grsltype_to_alignment_mask
(
type
)
;
if
(
arrayCount
|
|
type
=
=
kMat22f_GrSLType
)
{
alignmentMask
=
0xF
;
}
uint32_t
offsetDiff
=
*
currentOffset
&
alignmentMask
;
if
(
offsetDiff
!
=
0
)
{
offsetDiff
=
alignmentMask
-
offsetDiff
+
1
;
}
*
uniformOffset
=
*
currentOffset
+
offsetDiff
;
SkASSERT
(
sizeof
(
float
)
=
=
4
)
;
if
(
arrayCount
)
{
uint32_t
elementSize
=
SkTMax
<
uint32_t
>
(
16
grsltype_to_vk_size
(
type
)
)
;
SkASSERT
(
0
=
=
(
elementSize
&
0xF
)
)
;
*
currentOffset
=
*
uniformOffset
+
elementSize
*
arrayCount
;
}
else
{
*
currentOffset
=
*
uniformOffset
+
grsltype_to_vk_size
(
type
)
;
}
}
GrGLSLUniformHandler
:
:
UniformHandle
GrVkUniformHandler
:
:
internalAddUniformArray
(
uint32_t
visibility
GrSLType
type
GrSLPrecision
precision
const
char
*
name
bool
mangleName
int
arrayCount
const
char
*
*
outName
)
{
SkASSERT
(
name
&
&
strlen
(
name
)
)
;
SkDEBUGCODE
(
static
const
uint32_t
kVisibilityMask
=
kVertex_GrShaderFlag
|
kFragment_GrShaderFlag
)
;
SkASSERT
(
0
=
=
(
~
kVisibilityMask
&
visibility
)
)
;
SkASSERT
(
0
!
=
visibility
)
;
SkASSERT
(
kDefault_GrSLPrecision
=
=
precision
|
|
GrSLTypeIsFloatType
(
type
)
)
;
GrSLTypeIsFloatType
(
type
)
;
UniformInfo
&
uni
=
fUniforms
.
push_back
(
)
;
uni
.
fVariable
.
setType
(
type
)
;
char
prefix
=
'
u
'
;
if
(
'
u
'
=
=
name
[
0
]
)
{
prefix
=
'
\
0
'
;
}
fProgramBuilder
-
>
nameVariable
(
uni
.
fVariable
.
accessName
(
)
prefix
name
mangleName
)
;
uni
.
fVariable
.
setArrayCount
(
arrayCount
)
;
SkASSERT
(
kVertex_GrShaderFlag
=
=
visibility
|
|
kFragment_GrShaderFlag
=
=
visibility
)
;
uni
.
fVisibility
=
visibility
;
uni
.
fVariable
.
setPrecision
(
precision
)
;
uni
.
fVariable
.
setTypeModifier
(
GrGLSLShaderVar
:
:
kNone_TypeModifier
)
;
uint32_t
*
currentOffset
=
kVertex_GrShaderFlag
=
=
visibility
?
&
fCurrentVertexUBOOffset
:
&
fCurrentFragmentUBOOffset
;
get_ubo_aligned_offset
(
&
uni
.
fUBOffset
currentOffset
type
arrayCount
)
;
if
(
outName
)
{
*
outName
=
uni
.
fVariable
.
c_str
(
)
;
}
return
GrGLSLUniformHandler
:
:
UniformHandle
(
fUniforms
.
count
(
)
-
1
)
;
}
GrGLSLUniformHandler
:
:
SamplerHandle
GrVkUniformHandler
:
:
internalAddSampler
(
uint32_t
visibility
GrPixelConfig
config
GrSLType
type
GrSLPrecision
precision
const
char
*
name
)
{
SkASSERT
(
name
&
&
strlen
(
name
)
)
;
SkDEBUGCODE
(
static
const
uint32_t
kVisMask
=
kVertex_GrShaderFlag
|
kFragment_GrShaderFlag
)
;
SkASSERT
(
0
=
=
(
~
kVisMask
&
visibility
)
)
;
SkASSERT
(
0
!
=
visibility
)
;
SkString
mangleName
;
char
prefix
=
'
u
'
;
fProgramBuilder
-
>
nameVariable
(
&
mangleName
prefix
name
true
)
;
fSamplers
.
emplace_back
(
visibility
config
type
precision
mangleName
.
c_str
(
)
(
uint32_t
)
fSamplers
.
count
(
)
kSamplerDescSet
)
;
return
GrGLSLUniformHandler
:
:
SamplerHandle
(
fSamplers
.
count
(
)
-
1
)
;
}
void
GrVkUniformHandler
:
:
appendUniformDecls
(
GrShaderFlags
visibility
SkString
*
out
)
const
{
SkASSERT
(
kVertex_GrShaderFlag
=
=
visibility
|
|
kFragment_GrShaderFlag
=
=
visibility
)
;
for
(
int
i
=
0
;
i
<
fSamplers
.
count
(
)
;
+
+
i
)
{
const
GrVkGLSLSampler
&
sampler
=
fSamplers
[
i
]
;
SkASSERT
(
sampler
.
type
(
)
=
=
kTexture2DSampler_GrSLType
)
;
if
(
visibility
=
=
sampler
.
visibility
(
)
)
{
sampler
.
fShaderVar
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
out
)
;
out
-
>
append
(
"
;
\
n
"
)
;
}
}
SkString
uniformsString
;
for
(
int
i
=
0
;
i
<
fUniforms
.
count
(
)
;
+
+
i
)
{
const
UniformInfo
&
localUniform
=
fUniforms
[
i
]
;
if
(
visibility
=
=
localUniform
.
fVisibility
)
{
if
(
GrSLTypeIsFloatType
(
localUniform
.
fVariable
.
getType
(
)
)
)
{
localUniform
.
fVariable
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
&
uniformsString
)
;
uniformsString
.
append
(
"
;
\
n
"
)
;
}
}
}
if
(
!
uniformsString
.
isEmpty
(
)
)
{
uint32_t
uniformBinding
=
(
visibility
=
=
kVertex_GrShaderFlag
)
?
kVertexBinding
:
kFragBinding
;
const
char
*
stage
=
(
visibility
=
=
kVertex_GrShaderFlag
)
?
"
vertex
"
:
"
fragment
"
;
out
-
>
appendf
(
"
layout
(
set
=
%
d
binding
=
%
d
)
uniform
%
sUniformBuffer
\
n
{
\
n
"
kUniformBufferDescSet
uniformBinding
stage
)
;
out
-
>
appendf
(
"
%
s
\
n
}
;
\
n
"
uniformsString
.
c_str
(
)
)
;
}
}
