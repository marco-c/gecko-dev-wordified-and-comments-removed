#
ifndef
GrVkCaps_DEFINED
#
define
GrVkCaps_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
vk
/
GrVkStencilAttachment
.
h
"
class
GrShaderCaps
;
class
GrVkExtensions
;
struct
GrVkInterface
;
class
GrVkCaps
:
public
GrCaps
{
public
:
typedef
GrVkStencilAttachment
:
:
Format
StencilFormat
;
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
device
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
instanceVersion
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
extensions
GrProtected
isProtected
=
GrProtected
:
:
kNo
)
;
bool
isFormatSRGB
(
const
GrBackendFormat
&
)
const
override
;
bool
isFormatCompressed
(
const
GrBackendFormat
&
SkImage
:
:
CompressionType
*
compressionType
=
nullptr
)
const
override
;
bool
isFormatTexturableAndUploadable
(
GrColorType
const
GrBackendFormat
&
)
const
override
;
bool
isFormatTexturable
(
const
GrBackendFormat
&
)
const
override
;
bool
isVkFormatTexturable
(
VkFormat
)
const
;
bool
isFormatCopyable
(
const
GrBackendFormat
&
)
const
override
{
return
true
;
}
bool
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
=
1
)
const
override
;
bool
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
override
;
bool
isFormatRenderable
(
VkFormat
int
sampleCount
)
const
;
int
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
)
const
override
;
int
getRenderTargetSampleCount
(
int
requestedCount
VkFormat
)
const
;
int
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
)
const
override
;
int
maxRenderTargetSampleCount
(
VkFormat
format
)
const
;
size_t
bytesPerPixel
(
const
GrBackendFormat
&
)
const
override
;
size_t
bytesPerPixel
(
VkFormat
format
)
const
;
SupportedWrite
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
override
;
SurfaceReadPixelsSupport
surfaceSupportsReadPixels
(
const
GrSurface
*
)
const
override
;
bool
isVkFormatTexturableLinearly
(
VkFormat
format
)
const
{
return
SkToBool
(
FormatInfo
:
:
kTexturable_Flag
&
this
-
>
getFormatInfo
(
format
)
.
fLinearFlags
)
;
}
bool
formatCanBeDstofBlit
(
VkFormat
format
bool
linearTiled
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
uint16_t
&
flags
=
linearTiled
?
info
.
fLinearFlags
:
info
.
fOptimalFlags
;
return
SkToBool
(
FormatInfo
:
:
kBlitDst_Flag
&
flags
)
;
}
bool
formatCanBeSrcofBlit
(
VkFormat
format
bool
linearTiled
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
uint16_t
&
flags
=
linearTiled
?
info
.
fLinearFlags
:
info
.
fOptimalFlags
;
return
SkToBool
(
FormatInfo
:
:
kBlitSrc_Flag
&
flags
)
;
}
bool
mustDoCopiesFromOrigin
(
)
const
{
return
fMustDoCopiesFromOrigin
;
}
bool
mustSleepOnTearDown
(
)
const
{
return
fMustSleepOnTearDown
;
}
bool
shouldAlwaysUseDedicatedImageMemory
(
)
const
{
return
fShouldAlwaysUseDedicatedImageMemory
;
}
bool
avoidUpdateBuffers
(
)
const
{
return
fAvoidUpdateBuffers
;
}
const
StencilFormat
&
preferredStencilFormat
(
)
const
{
return
fPreferredStencilFormat
;
}
bool
supportsSwapchain
(
)
const
{
return
fSupportsSwapchain
;
}
bool
supportsPhysicalDeviceProperties2
(
)
const
{
return
fSupportsPhysicalDeviceProperties2
;
}
bool
supportsMemoryRequirements2
(
)
const
{
return
fSupportsMemoryRequirements2
;
}
bool
supportsBindMemory2
(
)
const
{
return
fSupportsBindMemory2
;
}
bool
supportsMaintenance1
(
)
const
{
return
fSupportsMaintenance1
;
}
bool
supportsMaintenance2
(
)
const
{
return
fSupportsMaintenance2
;
}
bool
supportsMaintenance3
(
)
const
{
return
fSupportsMaintenance3
;
}
bool
supportsDedicatedAllocation
(
)
const
{
return
fSupportsDedicatedAllocation
;
}
bool
supportsExternalMemory
(
)
const
{
return
fSupportsExternalMemory
;
}
bool
supportsAndroidHWBExternalMemory
(
)
const
{
return
fSupportsAndroidHWBExternalMemory
;
}
bool
supportsYcbcrConversion
(
)
const
{
return
fSupportsYcbcrConversion
;
}
bool
supportsProtectedMemory
(
)
const
{
return
fSupportsProtectedMemory
;
}
bool
preferPrimaryOverSecondaryCommandBuffers
(
)
const
{
return
fPreferPrimaryOverSecondaryCommandBuffers
;
}
bool
mustInvalidatePrimaryCmdBufferStateAfterClearAttachments
(
)
const
{
return
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
;
}
bool
canCopyImage
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSamplecnt
bool
srcHasYcbcr
)
const
;
bool
canCopyAsBlit
(
VkFormat
dstConfig
int
dstSampleCnt
bool
dstIsLinear
bool
dstHasYcbcr
VkFormat
srcConfig
int
srcSampleCnt
bool
srcIsLinear
bool
srcHasYcbcr
)
const
;
bool
canCopyAsResolve
(
VkFormat
dstConfig
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcConfig
int
srcSamplecnt
bool
srcHasYcbcr
)
const
;
GrColorType
getYUVAColorTypeFromBackendFormat
(
const
GrBackendFormat
&
bool
isAlphaChannel
)
const
override
;
GrBackendFormat
getBackendFormatFromCompressionType
(
SkImage
:
:
CompressionType
)
const
override
;
VkFormat
getFormatFromColorType
(
GrColorType
colorType
)
const
{
int
idx
=
static_cast
<
int
>
(
colorType
)
;
return
fColorTypeToFormatTable
[
idx
]
;
}
GrSwizzle
getTextureSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
GrSwizzle
getOutputSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
int
getFragmentUniformBinding
(
)
const
;
int
getFragmentUniformSet
(
)
const
;
#
if
GR_TEST_UTILS
std
:
:
vector
<
TestFormatColorTypeCombination
>
getTestingCombinations
(
)
const
override
;
#
endif
private
:
enum
VkVendor
{
kAMD_VkVendor
=
4098
kARM_VkVendor
=
5045
kImagination_VkVendor
=
4112
kIntel_VkVendor
=
32902
kNvidia_VkVendor
=
4318
kQualcomm_VkVendor
=
20803
}
;
void
init
(
const
GrContextOptions
&
contextOptions
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
device
const
VkPhysicalDeviceFeatures2
&
uint32_t
physicalDeviceVersion
const
GrVkExtensions
&
GrProtected
isProtected
)
;
void
initGrCaps
(
const
GrVkInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
const
VkPhysicalDeviceMemoryProperties
&
const
VkPhysicalDeviceFeatures2
&
const
GrVkExtensions
&
)
;
void
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
const
VkPhysicalDeviceFeatures2
&
)
;
void
initFormatTable
(
const
GrVkInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
)
;
void
initStencilFormat
(
const
GrVkInterface
*
iface
VkPhysicalDevice
physDev
)
;
void
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
)
;
bool
onSurfaceSupportsWritePixels
(
const
GrSurface
*
)
const
override
;
bool
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
const
override
;
GrBackendFormat
onGetDefaultBackendFormat
(
GrColorType
GrRenderable
)
const
override
;
GrPixelConfig
onGetConfigFromBackendFormat
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
bool
onAreColorTypeAndFormatCompatible
(
GrColorType
const
GrBackendFormat
&
)
const
override
;
SupportedRead
onSupportedReadPixelsColorType
(
GrColorType
const
GrBackendFormat
&
GrColorType
)
const
override
;
struct
ColorTypeInfo
{
GrColorType
fColorType
=
GrColorType
:
:
kUnknown
;
enum
{
kUploadData_Flag
=
0x1
kRenderable_Flag
=
0x2
kWrappedOnly_Flag
=
0x4
}
;
uint32_t
fFlags
=
0
;
GrSwizzle
fTextureSwizzle
;
GrSwizzle
fOutputSwizzle
;
}
;
struct
FormatInfo
{
uint32_t
colorTypeFlags
(
GrColorType
colorType
)
const
{
for
(
int
i
=
0
;
i
<
fColorTypeInfoCount
;
+
+
i
)
{
if
(
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
return
fColorTypeInfos
[
i
]
.
fFlags
;
}
}
return
0
;
}
void
init
(
const
GrVkInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
VkFormat
)
;
static
void
InitFormatFlags
(
VkFormatFeatureFlags
uint16_t
*
flags
)
;
void
initSampleCounts
(
const
GrVkInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
VkFormat
)
;
enum
{
kTexturable_Flag
=
0x1
kRenderable_Flag
=
0x2
kBlitSrc_Flag
=
0x4
kBlitDst_Flag
=
0x8
}
;
uint16_t
fOptimalFlags
=
0
;
uint16_t
fLinearFlags
=
0
;
SkTDArray
<
int
>
fColorSampleCounts
;
size_t
fBytesPerPixel
=
0
;
std
:
:
unique_ptr
<
ColorTypeInfo
[
]
>
fColorTypeInfos
;
int
fColorTypeInfoCount
=
0
;
}
;
static
const
size_t
kNumVkFormats
=
19
;
FormatInfo
fFormatTable
[
kNumVkFormats
]
;
FormatInfo
&
getFormatInfo
(
VkFormat
)
;
const
FormatInfo
&
getFormatInfo
(
VkFormat
)
const
;
VkFormat
fColorTypeToFormatTable
[
kGrColorTypeCnt
]
;
void
setColorType
(
GrColorType
std
:
:
initializer_list
<
VkFormat
>
formats
)
;
StencilFormat
fPreferredStencilFormat
;
SkSTArray
<
1
GrVkYcbcrConversionInfo
>
fYcbcrInfos
;
bool
fMustDoCopiesFromOrigin
=
false
;
bool
fMustSleepOnTearDown
=
false
;
bool
fShouldAlwaysUseDedicatedImageMemory
=
false
;
bool
fAvoidUpdateBuffers
=
false
;
bool
fSupportsSwapchain
=
false
;
bool
fSupportsPhysicalDeviceProperties2
=
false
;
bool
fSupportsMemoryRequirements2
=
false
;
bool
fSupportsBindMemory2
=
false
;
bool
fSupportsMaintenance1
=
false
;
bool
fSupportsMaintenance2
=
false
;
bool
fSupportsMaintenance3
=
false
;
bool
fSupportsDedicatedAllocation
=
false
;
bool
fSupportsExternalMemory
=
false
;
bool
fSupportsAndroidHWBExternalMemory
=
false
;
bool
fSupportsYcbcrConversion
=
false
;
bool
fSupportsProtectedMemory
=
false
;
bool
fPreferPrimaryOverSecondaryCommandBuffers
=
true
;
bool
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
=
false
;
typedef
GrCaps
INHERITED
;
}
;
#
endif
