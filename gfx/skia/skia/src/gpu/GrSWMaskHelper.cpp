#
include
"
GrSWMaskHelper
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
batches
/
GrDrawBatch
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
SkDistanceFieldGen
.
h
"
#
include
"
batches
/
GrRectBatchFactory
.
h
"
static
SkBlendMode
op_to_mode
(
SkRegion
:
:
Op
op
)
{
static
const
SkBlendMode
modeMap
[
]
=
{
SkBlendMode
:
:
kDstOut
SkBlendMode
:
:
kModulate
SkBlendMode
:
:
kSrcOver
SkBlendMode
:
:
kXor
SkBlendMode
:
:
kClear
SkBlendMode
:
:
kSrc
}
;
return
modeMap
[
op
]
;
}
void
GrSWMaskHelper
:
:
drawRect
(
const
SkRect
&
rect
SkRegion
:
:
Op
op
bool
antiAlias
uint8_t
alpha
)
{
SkPaint
paint
;
paint
.
setBlendMode
(
op_to_mode
(
op
)
)
;
paint
.
setAntiAlias
(
antiAlias
)
;
paint
.
setColor
(
SkColorSetARGB
(
alpha
alpha
alpha
alpha
)
)
;
fDraw
.
drawRect
(
rect
paint
)
;
}
void
GrSWMaskHelper
:
:
drawShape
(
const
GrShape
&
shape
SkRegion
:
:
Op
op
bool
antiAlias
uint8_t
alpha
)
{
SkPaint
paint
;
paint
.
setPathEffect
(
sk_ref_sp
(
shape
.
style
(
)
.
pathEffect
(
)
)
)
;
shape
.
style
(
)
.
strokeRec
(
)
.
applyToPaint
(
&
paint
)
;
paint
.
setAntiAlias
(
antiAlias
)
;
SkPath
path
;
shape
.
asPath
(
&
path
)
;
if
(
SkRegion
:
:
kReplace_Op
=
=
op
&
&
0xFF
=
=
alpha
)
{
SkASSERT
(
0xFF
=
=
paint
.
getAlpha
(
)
)
;
fDraw
.
drawPathCoverage
(
path
paint
)
;
}
else
{
paint
.
setBlendMode
(
op_to_mode
(
op
)
)
;
paint
.
setColor
(
SkColorSetARGB
(
alpha
alpha
alpha
alpha
)
)
;
fDraw
.
drawPath
(
path
paint
)
;
}
}
bool
GrSWMaskHelper
:
:
init
(
const
SkIRect
&
resultBounds
const
SkMatrix
*
matrix
)
{
if
(
matrix
)
{
fMatrix
=
*
matrix
;
}
else
{
fMatrix
.
setIdentity
(
)
;
}
fMatrix
.
postTranslate
(
-
SkIntToScalar
(
resultBounds
.
fLeft
)
-
SkIntToScalar
(
resultBounds
.
fTop
)
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
resultBounds
.
width
(
)
resultBounds
.
height
(
)
)
;
const
SkImageInfo
bmImageInfo
=
SkImageInfo
:
:
MakeA8
(
bounds
.
width
(
)
bounds
.
height
(
)
)
;
if
(
!
fPixels
.
tryAlloc
(
bmImageInfo
)
)
{
return
false
;
}
fPixels
.
erase
(
0
)
;
sk_bzero
(
&
fDraw
sizeof
(
fDraw
)
)
;
fDraw
.
fDst
=
fPixels
;
fRasterClip
.
setRect
(
bounds
)
;
fDraw
.
fRC
=
&
fRasterClip
;
fDraw
.
fMatrix
=
&
fMatrix
;
return
true
;
}
GrTexture
*
GrSWMaskHelper
:
:
createTexture
(
TextureType
textureType
)
{
GrSurfaceDesc
desc
;
desc
.
fWidth
=
fPixels
.
width
(
)
;
desc
.
fHeight
=
fPixels
.
height
(
)
;
desc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
if
(
TextureType
:
:
kApproximateFit
=
=
textureType
)
{
return
fTexProvider
-
>
createApproxTexture
(
desc
)
;
}
else
{
return
fTexProvider
-
>
createTexture
(
desc
SkBudgeted
:
:
kYes
)
;
}
}
void
GrSWMaskHelper
:
:
toTexture
(
GrTexture
*
texture
)
{
SkASSERT
(
!
texture
-
>
asRenderTarget
(
)
)
;
texture
-
>
writePixels
(
0
0
fPixels
.
width
(
)
fPixels
.
height
(
)
texture
-
>
config
(
)
fPixels
.
addr
(
)
fPixels
.
rowBytes
(
)
)
;
}
void
GrSWMaskHelper
:
:
toSDF
(
unsigned
char
*
sdf
)
{
SkGenerateDistanceFieldFromA8Image
(
sdf
(
const
unsigned
char
*
)
fPixels
.
addr
(
)
fPixels
.
width
(
)
fPixels
.
height
(
)
fPixels
.
rowBytes
(
)
)
;
}
GrTexture
*
GrSWMaskHelper
:
:
DrawShapeMaskToTexture
(
GrTextureProvider
*
texProvider
const
GrShape
&
shape
const
SkIRect
&
resultBounds
bool
antiAlias
TextureType
textureType
const
SkMatrix
*
matrix
)
{
GrSWMaskHelper
helper
(
texProvider
)
;
if
(
!
helper
.
init
(
resultBounds
matrix
)
)
{
return
nullptr
;
}
helper
.
drawShape
(
shape
SkRegion
:
:
kReplace_Op
antiAlias
0xFF
)
;
GrTexture
*
texture
(
helper
.
createTexture
(
textureType
)
)
;
if
(
!
texture
)
{
return
nullptr
;
}
helper
.
toTexture
(
texture
)
;
return
texture
;
}
void
GrSWMaskHelper
:
:
DrawToTargetWithShapeMask
(
GrTexture
*
texture
GrDrawContext
*
drawContext
const
GrPaint
&
paint
const
GrUserStencilSettings
&
userStencilSettings
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIPoint
&
textureOriginInDeviceSpace
const
SkIRect
&
deviceSpaceRectToDraw
)
{
SkMatrix
invert
;
if
(
!
viewMatrix
.
invert
(
&
invert
)
)
{
return
;
}
SkRect
dstRect
=
SkRect
:
:
Make
(
deviceSpaceRectToDraw
)
;
SkMatrix
maskMatrix
;
maskMatrix
.
setIDiv
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
;
maskMatrix
.
preTranslate
(
SkIntToScalar
(
-
textureOriginInDeviceSpace
.
fX
)
SkIntToScalar
(
-
textureOriginInDeviceSpace
.
fY
)
)
;
maskMatrix
.
preConcat
(
viewMatrix
)
;
GrPipelineBuilder
pipelineBuilder
(
paint
drawContext
-
>
mustUseHWAA
(
paint
)
)
;
pipelineBuilder
.
setUserStencil
(
&
userStencilSettings
)
;
pipelineBuilder
.
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
texture
nullptr
maskMatrix
GrTextureParams
:
:
kNone_FilterMode
)
)
;
SkAutoTUnref
<
GrDrawBatch
>
batch
(
GrRectBatchFactory
:
:
CreateNonAAFill
(
paint
.
getColor
(
)
SkMatrix
:
:
I
(
)
dstRect
nullptr
&
invert
)
)
;
drawContext
-
>
drawBatch
(
pipelineBuilder
clip
batch
)
;
}
