#
include
"
GrClipMaskManager
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrDrawingManager
.
h
"
#
include
"
GrDrawContextPriv
.
h
"
#
include
"
GrDrawTarget
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrStencilAttachment
.
h
"
#
include
"
GrSWMaskHelper
.
h
"
#
include
"
SkRasterClip
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
batches
/
GrRectBatchFactory
.
h
"
#
include
"
effects
/
GrConvexPolyEffect
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrRRectEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
typedef
SkClipStack
:
:
Element
Element
;
static
const
GrFragmentProcessor
*
create_fp_for_mask
(
GrTexture
*
result
const
SkIRect
&
devBound
)
{
SkMatrix
mat
;
mat
.
setIDiv
(
result
-
>
width
(
)
result
-
>
height
(
)
)
;
mat
.
preTranslate
(
SkIntToScalar
(
-
devBound
.
fLeft
)
SkIntToScalar
(
-
devBound
.
fTop
)
)
;
SkIRect
domainTexels
=
SkIRect
:
:
MakeWH
(
devBound
.
width
(
)
devBound
.
height
(
)
)
;
return
GrTextureDomainEffect
:
:
Create
(
result
mat
GrTextureDomain
:
:
MakeTexelDomain
(
result
domainTexels
)
GrTextureDomain
:
:
kDecal_Mode
GrTextureParams
:
:
kNone_FilterMode
kDevice_GrCoordSet
)
;
}
static
void
draw_non_aa_rect
(
GrDrawTarget
*
drawTarget
const
GrPipelineBuilder
&
pipelineBuilder
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
{
SkAutoTUnref
<
GrDrawBatch
>
batch
(
GrRectBatchFactory
:
:
CreateNonAAFill
(
color
viewMatrix
rect
nullptr
nullptr
)
)
;
drawTarget
-
>
drawBatch
(
pipelineBuilder
batch
)
;
}
bool
GrClipMaskManager
:
:
PathNeedsSWRenderer
(
GrContext
*
context
bool
isStencilDisabled
const
GrRenderTarget
*
rt
const
SkMatrix
&
viewMatrix
const
Element
*
element
GrPathRenderer
*
*
prOut
bool
needsStencil
)
{
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
if
(
prOut
)
{
*
prOut
=
nullptr
;
}
return
false
;
}
else
{
SkASSERT
(
Element
:
:
kEmpty_Type
!
=
element
-
>
getType
(
)
)
;
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
GrStrokeInfo
stroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
GrPathRendererChain
:
:
DrawType
type
;
if
(
needsStencil
)
{
type
=
element
-
>
isAA
(
)
?
GrPathRendererChain
:
:
kStencilAndColorAntiAlias_DrawType
:
GrPathRendererChain
:
:
kStencilAndColor_DrawType
;
}
else
{
type
=
element
-
>
isAA
(
)
?
GrPathRendererChain
:
:
kColorAntiAlias_DrawType
:
GrPathRendererChain
:
:
kColor_DrawType
;
}
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fShaderCaps
=
context
-
>
caps
(
)
-
>
shaderCaps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fPath
=
&
path
;
canDrawArgs
.
fStroke
=
&
stroke
;
canDrawArgs
.
fAntiAlias
=
element
-
>
isAA
(
)
;
canDrawArgs
.
fIsStencilDisabled
=
isStencilDisabled
;
canDrawArgs
.
fIsStencilBufferMSAA
=
rt
-
>
isStencilBufferMultisampled
(
)
;
GrPathRenderer
*
pr
=
context
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
type
)
;
if
(
prOut
)
{
*
prOut
=
pr
;
}
return
SkToBool
(
!
pr
)
;
}
}
GrPathRenderer
*
GrClipMaskManager
:
:
GetPathRenderer
(
GrContext
*
context
GrTexture
*
texture
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
{
GrPathRenderer
*
pr
;
static
const
bool
kNeedsStencil
=
true
;
static
const
bool
kStencilIsDisabled
=
true
;
PathNeedsSWRenderer
(
context
kStencilIsDisabled
texture
-
>
asRenderTarget
(
)
viewMatrix
element
&
pr
kNeedsStencil
)
;
return
pr
;
}
GrClipMaskManager
:
:
GrClipMaskManager
(
GrDrawTarget
*
drawTarget
bool
debugClipBatchToBounds
)
:
fDrawTarget
(
drawTarget
)
fClipMode
(
kIgnoreClip_StencilClipMode
)
fDebugClipBatchToBounds
(
debugClipBatchToBounds
)
{
}
GrContext
*
GrClipMaskManager
:
:
getContext
(
)
{
return
fDrawTarget
-
>
cmmAccess
(
)
.
context
(
)
;
}
const
GrCaps
*
GrClipMaskManager
:
:
caps
(
)
const
{
return
fDrawTarget
-
>
caps
(
)
;
}
GrResourceProvider
*
GrClipMaskManager
:
:
resourceProvider
(
)
{
return
fDrawTarget
-
>
cmmAccess
(
)
.
resourceProvider
(
)
;
}
bool
GrClipMaskManager
:
:
UseSWOnlyPath
(
GrContext
*
context
const
GrPipelineBuilder
&
pipelineBuilder
const
GrRenderTarget
*
rt
const
SkVector
&
clipToMaskOffset
const
GrReducedClip
:
:
ElementList
&
elements
)
{
const
SkMatrix
translate
=
SkMatrix
:
:
MakeTrans
(
clipToMaskOffset
.
fX
clipToMaskOffset
.
fY
)
;
for
(
GrReducedClip
:
:
ElementList
:
:
Iter
iter
(
elements
.
headIter
(
)
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkRegion
:
:
Op
op
=
element
-
>
getOp
(
)
;
bool
invert
=
element
-
>
isInverseFilled
(
)
;
bool
needsStencil
=
invert
|
|
SkRegion
:
:
kIntersect_Op
=
=
op
|
|
SkRegion
:
:
kReverseDifference_Op
=
=
op
;
if
(
PathNeedsSWRenderer
(
context
pipelineBuilder
.
getStencil
(
)
.
isDisabled
(
)
rt
translate
element
nullptr
needsStencil
)
)
{
return
true
;
}
}
return
false
;
}
bool
GrClipMaskManager
:
:
getAnalyticClipProcessor
(
const
GrReducedClip
:
:
ElementList
&
elements
bool
abortIfAA
SkVector
&
clipToRTOffset
const
SkRect
*
drawBounds
const
GrFragmentProcessor
*
*
resultFP
)
{
SkRect
boundsInClipSpace
;
if
(
drawBounds
)
{
boundsInClipSpace
=
*
drawBounds
;
boundsInClipSpace
.
offset
(
-
clipToRTOffset
.
fX
-
clipToRTOffset
.
fY
)
;
}
SkASSERT
(
elements
.
count
(
)
<
=
kMaxAnalyticElements
)
;
const
GrFragmentProcessor
*
fps
[
kMaxAnalyticElements
]
;
for
(
int
i
=
0
;
i
<
kMaxAnalyticElements
;
+
+
i
)
{
fps
[
i
]
=
nullptr
;
}
int
fpCnt
=
0
;
GrReducedClip
:
:
ElementList
:
:
Iter
iter
(
elements
)
;
bool
failed
=
false
;
while
(
iter
.
get
(
)
)
{
SkRegion
:
:
Op
op
=
iter
.
get
(
)
-
>
getOp
(
)
;
bool
invert
;
bool
skip
=
false
;
switch
(
op
)
{
case
SkRegion
:
:
kReplace_Op
:
SkASSERT
(
iter
.
get
(
)
=
=
elements
.
head
(
)
)
;
case
SkRegion
:
:
kIntersect_Op
:
invert
=
false
;
if
(
drawBounds
&
&
iter
.
get
(
)
-
>
contains
(
boundsInClipSpace
)
)
{
skip
=
true
;
}
break
;
case
SkRegion
:
:
kDifference_Op
:
invert
=
true
;
break
;
default
:
failed
=
true
;
break
;
}
if
(
failed
)
{
break
;
}
if
(
!
skip
)
{
GrPrimitiveEdgeType
edgeType
;
if
(
iter
.
get
(
)
-
>
isAA
(
)
)
{
if
(
abortIfAA
)
{
failed
=
true
;
break
;
}
edgeType
=
invert
?
kInverseFillAA_GrProcessorEdgeType
:
kFillAA_GrProcessorEdgeType
;
}
else
{
edgeType
=
invert
?
kInverseFillBW_GrProcessorEdgeType
:
kFillBW_GrProcessorEdgeType
;
}
switch
(
iter
.
get
(
)
-
>
getType
(
)
)
{
case
SkClipStack
:
:
Element
:
:
kPath_Type
:
fps
[
fpCnt
]
=
GrConvexPolyEffect
:
:
Create
(
edgeType
iter
.
get
(
)
-
>
getPath
(
)
&
clipToRTOffset
)
;
break
;
case
SkClipStack
:
:
Element
:
:
kRRect_Type
:
{
SkRRect
rrect
=
iter
.
get
(
)
-
>
getRRect
(
)
;
rrect
.
offset
(
clipToRTOffset
.
fX
clipToRTOffset
.
fY
)
;
fps
[
fpCnt
]
=
GrRRectEffect
:
:
Create
(
edgeType
rrect
)
;
break
;
}
case
SkClipStack
:
:
Element
:
:
kRect_Type
:
{
SkRect
rect
=
iter
.
get
(
)
-
>
getRect
(
)
;
rect
.
offset
(
clipToRTOffset
.
fX
clipToRTOffset
.
fY
)
;
fps
[
fpCnt
]
=
GrConvexPolyEffect
:
:
Create
(
edgeType
rect
)
;
break
;
}
default
:
break
;
}
if
(
!
fps
[
fpCnt
]
)
{
failed
=
true
;
break
;
}
fpCnt
+
+
;
}
iter
.
next
(
)
;
}
*
resultFP
=
nullptr
;
if
(
!
failed
&
&
fpCnt
)
{
*
resultFP
=
GrFragmentProcessor
:
:
RunInSeries
(
fps
fpCnt
)
;
}
for
(
int
i
=
0
;
i
<
fpCnt
;
+
+
i
)
{
fps
[
i
]
-
>
unref
(
)
;
}
return
!
failed
;
}
static
void
add_rect_to_clip
(
const
GrClip
&
clip
const
SkRect
&
devRect
GrClip
*
out
)
{
switch
(
clip
.
clipType
(
)
)
{
case
GrClip
:
:
kClipStack_ClipType
:
{
SkClipStack
*
stack
=
new
SkClipStack
;
*
stack
=
*
clip
.
clipStack
(
)
;
SkRect
clipRect
=
devRect
;
SkPoint
origin
=
{
SkIntToScalar
(
clip
.
origin
(
)
.
fX
)
SkIntToScalar
(
clip
.
origin
(
)
.
fY
)
}
;
clipRect
.
offset
(
origin
)
;
SkIRect
iclipRect
;
clipRect
.
roundOut
(
&
iclipRect
)
;
clipRect
=
SkRect
:
:
Make
(
iclipRect
)
;
stack
-
>
clipDevRect
(
clipRect
SkRegion
:
:
kIntersect_Op
false
)
;
out
-
>
setClipStack
(
stack
&
clip
.
origin
(
)
)
;
break
;
}
case
GrClip
:
:
kWideOpen_ClipType
:
*
out
=
GrClip
(
devRect
)
;
break
;
case
GrClip
:
:
kIRect_ClipType
:
{
SkIRect
intersect
;
devRect
.
roundOut
(
&
intersect
)
;
if
(
intersect
.
intersect
(
clip
.
irect
(
)
)
)
{
*
out
=
GrClip
(
intersect
)
;
}
else
{
*
out
=
clip
;
}
break
;
}
}
}
bool
GrClipMaskManager
:
:
setupScissorClip
(
const
GrPipelineBuilder
&
pipelineBuilder
GrPipelineBuilder
:
:
AutoRestoreStencil
*
ars
const
SkIRect
&
clipScissor
const
SkRect
*
devBounds
GrAppliedClip
*
out
)
{
if
(
kRespectClip_StencilClipMode
=
=
fClipMode
)
{
fClipMode
=
kIgnoreClip_StencilClipMode
;
}
GrRenderTarget
*
rt
=
pipelineBuilder
.
getRenderTarget
(
)
;
SkIRect
clipSpaceRTIBounds
=
SkIRect
:
:
MakeWH
(
rt
-
>
width
(
)
rt
-
>
height
(
)
)
;
SkIRect
devBoundsScissor
;
const
SkIRect
*
scissor
=
&
clipScissor
;
bool
doDevBoundsClip
=
fDebugClipBatchToBounds
&
&
devBounds
;
if
(
doDevBoundsClip
)
{
devBounds
-
>
roundOut
(
&
devBoundsScissor
)
;
if
(
devBoundsScissor
.
intersect
(
clipScissor
)
)
{
scissor
=
&
devBoundsScissor
;
}
}
if
(
scissor
-
>
contains
(
clipSpaceRTIBounds
)
)
{
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
if
(
clipSpaceRTIBounds
.
intersect
(
*
scissor
)
)
{
out
-
>
fScissorState
.
set
(
clipSpaceRTIBounds
)
;
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
return
false
;
}
bool
GrClipMaskManager
:
:
setupClipping
(
const
GrPipelineBuilder
&
pipelineBuilder
GrPipelineBuilder
:
:
AutoRestoreStencil
*
ars
const
SkRect
*
devBounds
GrAppliedClip
*
out
)
{
if
(
kRespectClip_StencilClipMode
=
=
fClipMode
)
{
fClipMode
=
kIgnoreClip_StencilClipMode
;
}
GrReducedClip
:
:
ElementList
elements
;
int32_t
genID
=
0
;
GrReducedClip
:
:
InitialState
initialState
=
GrReducedClip
:
:
kAllIn_InitialState
;
SkIRect
clipSpaceIBounds
;
bool
requiresAA
=
false
;
GrRenderTarget
*
rt
=
pipelineBuilder
.
getRenderTarget
(
)
;
SkASSERT
(
rt
)
;
SkIRect
clipSpaceRTIBounds
=
SkIRect
:
:
MakeWH
(
rt
-
>
width
(
)
rt
-
>
height
(
)
)
;
GrClip
devBoundsClip
;
bool
doDevBoundsClip
=
fDebugClipBatchToBounds
&
&
devBounds
;
if
(
doDevBoundsClip
)
{
add_rect_to_clip
(
pipelineBuilder
.
clip
(
)
*
devBounds
&
devBoundsClip
)
;
}
const
GrClip
&
clip
=
doDevBoundsClip
?
devBoundsClip
:
pipelineBuilder
.
clip
(
)
;
if
(
clip
.
isWideOpen
(
clipSpaceRTIBounds
)
)
{
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
switch
(
clip
.
clipType
(
)
)
{
case
GrClip
:
:
kWideOpen_ClipType
:
SkFAIL
(
"
Should
have
caught
this
with
clip
.
isWideOpen
(
)
"
)
;
return
true
;
case
GrClip
:
:
kIRect_ClipType
:
{
SkIRect
scissor
=
clip
.
irect
(
)
;
if
(
scissor
.
intersect
(
clipSpaceRTIBounds
)
)
{
out
-
>
fScissorState
.
set
(
scissor
)
;
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
return
false
;
}
case
GrClip
:
:
kClipStack_ClipType
:
{
clipSpaceRTIBounds
.
offset
(
clip
.
origin
(
)
)
;
SkIRect
clipSpaceReduceQueryBounds
;
#
define
DISABLE_DEV_BOUNDS_FOR_CLIP_REDUCTION
0
if
(
devBounds
&
&
!
DISABLE_DEV_BOUNDS_FOR_CLIP_REDUCTION
)
{
SkIRect
devIBounds
=
devBounds
-
>
roundOut
(
)
;
devIBounds
.
offset
(
clip
.
origin
(
)
)
;
if
(
!
clipSpaceReduceQueryBounds
.
intersect
(
clipSpaceRTIBounds
devIBounds
)
)
{
return
false
;
}
}
else
{
clipSpaceReduceQueryBounds
=
clipSpaceRTIBounds
;
}
GrReducedClip
:
:
ReduceClipStack
(
*
clip
.
clipStack
(
)
clipSpaceReduceQueryBounds
&
elements
&
genID
&
initialState
&
clipSpaceIBounds
&
requiresAA
)
;
if
(
elements
.
isEmpty
(
)
)
{
if
(
GrReducedClip
:
:
kAllIn_InitialState
=
=
initialState
)
{
if
(
clipSpaceIBounds
=
=
clipSpaceRTIBounds
)
{
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
}
else
{
return
false
;
}
}
}
break
;
}
if
(
elements
.
count
(
)
<
=
kMaxAnalyticElements
)
{
SkVector
clipToRTOffset
=
{
SkIntToScalar
(
-
clip
.
origin
(
)
.
fX
)
SkIntToScalar
(
-
clip
.
origin
(
)
.
fY
)
}
;
bool
disallowAnalyticAA
=
rt
-
>
isUnifiedMultisampled
(
)
|
|
pipelineBuilder
.
hasMixedSamples
(
)
;
const
GrFragmentProcessor
*
clipFP
=
nullptr
;
if
(
elements
.
isEmpty
(
)
|
|
(
requiresAA
&
&
this
-
>
getAnalyticClipProcessor
(
elements
disallowAnalyticAA
clipToRTOffset
devBounds
&
clipFP
)
)
)
{
SkIRect
scissorSpaceIBounds
(
clipSpaceIBounds
)
;
scissorSpaceIBounds
.
offset
(
-
clip
.
origin
(
)
)
;
if
(
nullptr
=
=
devBounds
|
|
!
SkRect
:
:
Make
(
scissorSpaceIBounds
)
.
contains
(
*
devBounds
)
)
{
out
-
>
fScissorState
.
set
(
scissorSpaceIBounds
)
;
}
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
out
-
>
fClipCoverageFP
.
reset
(
clipFP
)
;
return
true
;
}
}
if
(
!
rt
-
>
isStencilBufferMultisampled
(
)
&
&
requiresAA
)
{
SkAutoTUnref
<
GrTexture
>
result
;
SkVector
clipToMaskOffset
=
{
SkIntToScalar
(
-
clipSpaceIBounds
.
fLeft
)
SkIntToScalar
(
-
clipSpaceIBounds
.
fTop
)
}
;
if
(
UseSWOnlyPath
(
this
-
>
getContext
(
)
pipelineBuilder
rt
clipToMaskOffset
elements
)
)
{
result
.
reset
(
CreateSoftwareClipMask
(
this
-
>
getContext
(
)
genID
initialState
elements
clipToMaskOffset
clipSpaceIBounds
)
)
;
}
else
{
result
.
reset
(
CreateAlphaClipMask
(
this
-
>
getContext
(
)
genID
initialState
elements
clipToMaskOffset
clipSpaceIBounds
)
)
;
SkASSERT
(
result
)
;
}
if
(
result
)
{
SkIRect
rtSpaceMaskBounds
=
clipSpaceIBounds
;
rtSpaceMaskBounds
.
offset
(
-
clip
.
origin
(
)
)
;
out
-
>
fClipCoverageFP
.
reset
(
create_fp_for_mask
(
result
rtSpaceMaskBounds
)
)
;
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
}
SkIPoint
clipSpaceToStencilSpaceOffset
=
-
clip
.
origin
(
)
;
this
-
>
createStencilClipMask
(
rt
genID
initialState
elements
clipSpaceIBounds
clipSpaceToStencilSpaceOffset
)
;
SkIRect
scissorSpaceIBounds
(
clipSpaceIBounds
)
;
scissorSpaceIBounds
.
offset
(
clipSpaceToStencilSpaceOffset
)
;
out
-
>
fScissorState
.
set
(
scissorSpaceIBounds
)
;
this
-
>
setPipelineBuilderStencil
(
pipelineBuilder
ars
)
;
return
true
;
}
static
bool
stencil_element
(
GrDrawContext
*
dc
const
SkIRect
*
scissorRect
const
GrStencilSettings
&
ss
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
{
switch
(
element
-
>
getType
(
)
)
{
case
Element
:
:
kEmpty_Type
:
SkDEBUGFAIL
(
"
Should
never
get
here
with
an
empty
element
.
"
)
;
break
;
case
Element
:
:
kRect_Type
:
return
dc
-
>
drawContextPriv
(
)
.
drawAndStencilRect
(
scissorRect
ss
element
-
>
getOp
(
)
element
-
>
isInverseFilled
(
)
element
-
>
isAA
(
)
viewMatrix
element
-
>
getRect
(
)
)
;
break
;
default
:
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
return
dc
-
>
drawContextPriv
(
)
.
drawAndStencilPath
(
scissorRect
ss
element
-
>
getOp
(
)
element
-
>
isInverseFilled
(
)
element
-
>
isAA
(
)
viewMatrix
path
)
;
break
;
}
}
return
false
;
}
static
void
draw_element
(
GrDrawContext
*
dc
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
{
switch
(
element
-
>
getType
(
)
)
{
case
Element
:
:
kEmpty_Type
:
SkDEBUGFAIL
(
"
Should
never
get
here
with
an
empty
element
.
"
)
;
break
;
case
Element
:
:
kRect_Type
:
dc
-
>
drawRect
(
clip
paint
viewMatrix
element
-
>
getRect
(
)
)
;
break
;
default
:
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
dc
-
>
drawPath
(
clip
paint
viewMatrix
path
GrStrokeInfo
:
:
FillInfo
(
)
)
;
break
;
}
}
}
static
void
GetClipMaskKey
(
int32_t
clipGenID
const
SkIRect
&
bounds
GrUniqueKey
*
key
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kDomain
3
)
;
builder
[
0
]
=
clipGenID
;
builder
[
1
]
=
SkToU16
(
bounds
.
fLeft
)
|
(
SkToU16
(
bounds
.
fRight
)
<
<
16
)
;
builder
[
2
]
=
SkToU16
(
bounds
.
fTop
)
|
(
SkToU16
(
bounds
.
fBottom
)
<
<
16
)
;
}
GrTexture
*
GrClipMaskManager
:
:
CreateAlphaClipMask
(
GrContext
*
context
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkVector
&
clipToMaskOffset
const
SkIRect
&
clipSpaceIBounds
)
{
GrResourceProvider
*
resourceProvider
=
context
-
>
resourceProvider
(
)
;
GrUniqueKey
key
;
GetClipMaskKey
(
elementsGenID
clipSpaceIBounds
&
key
)
;
if
(
GrTexture
*
texture
=
resourceProvider
-
>
findAndRefTextureByUniqueKey
(
key
)
)
{
return
texture
;
}
GrSurfaceDesc
desc
;
desc
.
fWidth
=
clipSpaceIBounds
.
width
(
)
;
desc
.
fHeight
=
clipSpaceIBounds
.
height
(
)
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
if
(
context
-
>
caps
(
)
-
>
isConfigRenderable
(
kAlpha_8_GrPixelConfig
false
)
)
{
desc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
}
else
{
desc
.
fConfig
=
kRGBA_8888_GrPixelConfig
;
}
SkAutoTUnref
<
GrTexture
>
texture
(
resourceProvider
-
>
createApproxTexture
(
desc
0
)
)
;
if
(
!
texture
)
{
return
nullptr
;
}
texture
-
>
resourcePriv
(
)
.
setUniqueKey
(
key
)
;
SkAutoTUnref
<
GrDrawContext
>
dc
(
context
-
>
drawContext
(
texture
-
>
asRenderTarget
(
)
)
)
;
if
(
!
dc
)
{
return
nullptr
;
}
SkIRect
maskSpaceIBounds
=
SkIRect
:
:
MakeWH
(
clipSpaceIBounds
.
width
(
)
clipSpaceIBounds
.
height
(
)
)
;
dc
-
>
clear
(
&
maskSpaceIBounds
GrReducedClip
:
:
kAllIn_InitialState
=
=
initialState
?
0xffffffff
:
0x00000000
true
)
;
const
SkMatrix
translate
=
SkMatrix
:
:
MakeTrans
(
clipToMaskOffset
.
fX
clipToMaskOffset
.
fY
)
;
for
(
GrReducedClip
:
:
ElementList
:
:
Iter
iter
=
elements
.
headIter
(
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkRegion
:
:
Op
op
=
element
-
>
getOp
(
)
;
bool
invert
=
element
-
>
isInverseFilled
(
)
;
if
(
invert
|
|
SkRegion
:
:
kIntersect_Op
=
=
op
|
|
SkRegion
:
:
kReverseDifference_Op
=
=
op
)
{
#
ifdef
SK_DEBUG
GrPathRenderer
*
pr
=
GetPathRenderer
(
context
texture
translate
element
)
;
if
(
Element
:
:
kRect_Type
!
=
element
-
>
getType
(
)
&
&
!
pr
)
{
SkASSERT
(
0
)
;
}
#
endif
GR_STATIC_CONST_SAME_STENCIL
(
kStencilInElement
kReplace_StencilOp
kReplace_StencilOp
kAlways_StencilFunc
0xffff
0xffff
0xffff
)
if
(
!
stencil_element
(
dc
&
maskSpaceIBounds
kStencilInElement
translate
element
)
)
{
texture
-
>
resourcePriv
(
)
.
removeUniqueKey
(
)
;
return
nullptr
;
}
GR_STATIC_CONST_SAME_STENCIL
(
kDrawOutsideElement
kZero_StencilOp
kZero_StencilOp
kEqual_StencilFunc
0xffff
0x0000
0xffff
)
;
if
(
!
dc
-
>
drawContextPriv
(
)
.
drawAndStencilRect
(
&
maskSpaceIBounds
kDrawOutsideElement
op
!
invert
false
translate
SkRect
:
:
Make
(
clipSpaceIBounds
)
)
)
{
texture
-
>
resourcePriv
(
)
.
removeUniqueKey
(
)
;
return
nullptr
;
}
}
else
{
GrPaint
paint
;
paint
.
setAntiAlias
(
element
-
>
isAA
(
)
)
;
paint
.
setCoverageSetOpXPFactory
(
op
false
)
;
draw_element
(
dc
GrClip
:
:
WideOpen
(
)
paint
translate
element
)
;
}
}
return
texture
.
release
(
)
;
}
bool
GrClipMaskManager
:
:
createStencilClipMask
(
GrRenderTarget
*
rt
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkIRect
&
clipSpaceIBounds
const
SkIPoint
&
clipSpaceToStencilOffset
)
{
SkASSERT
(
rt
)
;
GrStencilAttachment
*
stencilAttachment
=
this
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
)
;
if
(
nullptr
=
=
stencilAttachment
)
{
return
false
;
}
if
(
stencilAttachment
-
>
mustRenderClip
(
elementsGenID
clipSpaceIBounds
clipSpaceToStencilOffset
)
)
{
stencilAttachment
-
>
setLastClip
(
elementsGenID
clipSpaceIBounds
clipSpaceToStencilOffset
)
;
SkVector
translate
=
{
SkIntToScalar
(
clipSpaceToStencilOffset
.
fX
)
SkIntToScalar
(
clipSpaceToStencilOffset
.
fY
)
}
;
SkMatrix
viewMatrix
;
viewMatrix
.
setTranslate
(
translate
)
;
SkIRect
stencilSpaceIBounds
(
clipSpaceIBounds
)
;
stencilSpaceIBounds
.
offset
(
clipSpaceToStencilOffset
)
;
GrClip
clip
(
stencilSpaceIBounds
)
;
int
clipBit
=
stencilAttachment
-
>
bits
(
)
;
SkASSERT
(
(
clipBit
<
=
16
)
&
&
"
Ganesh
only
handles
16b
or
smaller
stencil
buffers
"
)
;
clipBit
=
(
1
<
<
(
clipBit
-
1
)
)
;
fDrawTarget
-
>
cmmAccess
(
)
.
clearStencilClip
(
stencilSpaceIBounds
GrReducedClip
:
:
kAllIn_InitialState
=
=
initialState
rt
)
;
for
(
GrReducedClip
:
:
ElementList
:
:
Iter
iter
(
elements
.
headIter
(
)
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
GrPipelineBuilder
pipelineBuilder
;
pipelineBuilder
.
setClip
(
clip
)
;
pipelineBuilder
.
setRenderTarget
(
rt
)
;
pipelineBuilder
.
setDisableColorXPFactory
(
)
;
if
(
rt
-
>
isStencilBufferMultisampled
(
)
)
{
pipelineBuilder
.
setState
(
GrPipelineBuilder
:
:
kHWAntialias_Flag
element
-
>
isAA
(
)
)
;
}
bool
fillInverted
=
false
;
fClipMode
=
kIgnoreClip_StencilClipMode
;
GrPathRenderer
:
:
StencilSupport
stencilSupport
;
GrStrokeInfo
stroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
SkRegion
:
:
Op
op
=
element
-
>
getOp
(
)
;
GrPathRenderer
*
pr
=
nullptr
;
SkPath
clipPath
;
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
stencilSupport
=
GrPathRenderer
:
:
kNoRestriction_StencilSupport
;
fillInverted
=
false
;
}
else
{
element
-
>
asPath
(
&
clipPath
)
;
fillInverted
=
clipPath
.
isInverseFillType
(
)
;
if
(
fillInverted
)
{
clipPath
.
toggleInverseFillType
(
)
;
}
SkASSERT
(
pipelineBuilder
.
getStencil
(
)
.
isDisabled
(
)
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fShaderCaps
=
this
-
>
getContext
(
)
-
>
caps
(
)
-
>
shaderCaps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fPath
=
&
clipPath
;
canDrawArgs
.
fStroke
=
&
stroke
;
canDrawArgs
.
fAntiAlias
=
false
;
canDrawArgs
.
fIsStencilDisabled
=
pipelineBuilder
.
getStencil
(
)
.
isDisabled
(
)
;
canDrawArgs
.
fIsStencilBufferMSAA
=
rt
-
>
isStencilBufferMultisampled
(
)
;
pr
=
this
-
>
getContext
(
)
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
GrPathRendererChain
:
:
kStencilOnly_DrawType
&
stencilSupport
)
;
if
(
nullptr
=
=
pr
)
{
return
false
;
}
}
int
passes
;
GrStencilSettings
stencilSettings
[
GrStencilSettings
:
:
kMaxStencilClipPasses
]
;
bool
canRenderDirectToStencil
=
GrPathRenderer
:
:
kNoRestriction_StencilSupport
=
=
stencilSupport
;
bool
canDrawDirectToClip
;
canDrawDirectToClip
=
GrStencilSettings
:
:
GetClipPasses
(
op
canRenderDirectToStencil
clipBit
fillInverted
&
passes
stencilSettings
)
;
if
(
!
canDrawDirectToClip
)
{
GR_STATIC_CONST_SAME_STENCIL
(
gDrawToStencil
kIncClamp_StencilOp
kIncClamp_StencilOp
kAlways_StencilFunc
0xffff
0x0000
0xffff
)
;
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
*
pipelineBuilder
.
stencil
(
)
=
gDrawToStencil
;
draw_non_aa_rect
(
fDrawTarget
pipelineBuilder
GrColor_WHITE
viewMatrix
element
-
>
getRect
(
)
)
;
}
else
{
if
(
!
clipPath
.
isEmpty
(
)
)
{
if
(
canRenderDirectToStencil
)
{
*
pipelineBuilder
.
stencil
(
)
=
gDrawToStencil
;
GrPathRenderer
:
:
DrawPathArgs
args
;
args
.
fTarget
=
fDrawTarget
;
args
.
fResourceProvider
=
this
-
>
getContext
(
)
-
>
resourceProvider
(
)
;
args
.
fPipelineBuilder
=
&
pipelineBuilder
;
args
.
fColor
=
GrColor_WHITE
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fPath
=
&
clipPath
;
args
.
fStroke
=
&
stroke
;
args
.
fAntiAlias
=
false
;
pr
-
>
drawPath
(
args
)
;
}
else
{
GrPathRenderer
:
:
StencilPathArgs
args
;
args
.
fTarget
=
fDrawTarget
;
args
.
fResourceProvider
=
this
-
>
getContext
(
)
-
>
resourceProvider
(
)
;
args
.
fPipelineBuilder
=
&
pipelineBuilder
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fPath
=
&
clipPath
;
args
.
fStroke
=
&
stroke
;
pr
-
>
stencilPath
(
args
)
;
}
}
}
}
fClipMode
=
kModifyClip_StencilClipMode
;
for
(
int
p
=
0
;
p
<
passes
;
+
+
p
)
{
*
pipelineBuilder
.
stencil
(
)
=
stencilSettings
[
p
]
;
if
(
canDrawDirectToClip
)
{
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
draw_non_aa_rect
(
fDrawTarget
pipelineBuilder
GrColor_WHITE
viewMatrix
element
-
>
getRect
(
)
)
;
}
else
{
GrPathRenderer
:
:
DrawPathArgs
args
;
args
.
fTarget
=
fDrawTarget
;
args
.
fResourceProvider
=
this
-
>
getContext
(
)
-
>
resourceProvider
(
)
;
args
.
fPipelineBuilder
=
&
pipelineBuilder
;
args
.
fColor
=
GrColor_WHITE
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fPath
=
&
clipPath
;
args
.
fStroke
=
&
stroke
;
args
.
fAntiAlias
=
false
;
pr
-
>
drawPath
(
args
)
;
}
}
else
{
draw_non_aa_rect
(
fDrawTarget
pipelineBuilder
GrColor_WHITE
viewMatrix
SkRect
:
:
Make
(
clipSpaceIBounds
)
)
;
}
}
}
}
fClipMode
=
kRespectClip_StencilClipMode
;
return
true
;
}
static
const
GrStencilFunc
gSpecialToBasicStencilFunc
[
2
]
[
kClipStencilFuncCount
]
=
{
{
kAlways_StencilFunc
kEqual_StencilFunc
kLess_StencilFunc
kLEqual_StencilFunc
kNotEqual_StencilFunc
}
{
kEqual_StencilFunc
kEqual_StencilFunc
kLess_StencilFunc
kLEqual_StencilFunc
kLess_StencilFunc
}
}
;
namespace
{
const
GrStencilSettings
&
basic_apply_stencil_clip_settings
(
)
{
GR_STATIC_CONST_SAME_STENCIL_STRUCT
(
gSettings
kKeep_StencilOp
kKeep_StencilOp
kAlwaysIfInClip_StencilFunc
0x0000
0x0000
0x0000
)
;
return
*
GR_CONST_STENCIL_SETTINGS_PTR_FROM_STRUCT_PTR
(
&
gSettings
)
;
}
}
void
GrClipMaskManager
:
:
setPipelineBuilderStencil
(
const
GrPipelineBuilder
&
pipelineBuilder
GrPipelineBuilder
:
:
AutoRestoreStencil
*
ars
)
{
GrStencilSettings
settings
;
if
(
pipelineBuilder
.
getStencil
(
)
.
isDisabled
(
)
)
{
if
(
GrClipMaskManager
:
:
kRespectClip_StencilClipMode
=
=
fClipMode
)
{
settings
=
basic_apply_stencil_clip_settings
(
)
;
}
else
{
return
;
}
}
else
{
settings
=
pipelineBuilder
.
getStencil
(
)
;
}
int
stencilBits
=
0
;
GrRenderTarget
*
rt
=
pipelineBuilder
.
getRenderTarget
(
)
;
GrStencilAttachment
*
stencilAttachment
=
this
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
)
;
if
(
stencilAttachment
)
{
stencilBits
=
stencilAttachment
-
>
bits
(
)
;
}
SkASSERT
(
this
-
>
caps
(
)
-
>
stencilWrapOpsSupport
(
)
|
|
!
settings
.
usesWrapOp
(
)
)
;
SkASSERT
(
this
-
>
caps
(
)
-
>
twoSidedStencilSupport
(
)
|
|
!
settings
.
isTwoSided
(
)
)
;
this
-
>
adjustStencilParams
(
&
settings
fClipMode
stencilBits
)
;
ars
-
>
set
(
&
pipelineBuilder
)
;
ars
-
>
setStencil
(
settings
)
;
}
void
GrClipMaskManager
:
:
adjustStencilParams
(
GrStencilSettings
*
settings
StencilClipMode
mode
int
stencilBitCnt
)
{
SkASSERT
(
stencilBitCnt
>
0
)
;
if
(
kModifyClip_StencilClipMode
=
=
mode
)
{
return
;
}
unsigned
int
clipBit
=
(
1
<
<
(
stencilBitCnt
-
1
)
)
;
unsigned
int
userBits
=
clipBit
-
1
;
GrStencilSettings
:
:
Face
face
=
GrStencilSettings
:
:
kFront_Face
;
bool
twoSided
=
this
-
>
caps
(
)
-
>
twoSidedStencilSupport
(
)
;
bool
finished
=
false
;
while
(
!
finished
)
{
GrStencilFunc
func
=
settings
-
>
func
(
face
)
;
uint16_t
writeMask
=
settings
-
>
writeMask
(
face
)
;
uint16_t
funcMask
=
settings
-
>
funcMask
(
face
)
;
uint16_t
funcRef
=
settings
-
>
funcRef
(
face
)
;
SkASSERT
(
(
unsigned
)
func
<
kStencilFuncCount
)
;
writeMask
&
=
userBits
;
if
(
func
>
=
kBasicStencilFuncCount
)
{
int
respectClip
=
kRespectClip_StencilClipMode
=
=
mode
;
if
(
respectClip
)
{
switch
(
func
)
{
case
kAlwaysIfInClip_StencilFunc
:
funcMask
=
clipBit
;
funcRef
=
clipBit
;
break
;
case
kEqualIfInClip_StencilFunc
:
case
kLessIfInClip_StencilFunc
:
case
kLEqualIfInClip_StencilFunc
:
funcMask
=
(
funcMask
&
userBits
)
|
clipBit
;
funcRef
=
(
funcRef
&
userBits
)
|
clipBit
;
break
;
case
kNonZeroIfInClip_StencilFunc
:
funcMask
=
(
funcMask
&
userBits
)
|
clipBit
;
funcRef
=
clipBit
;
break
;
default
:
SkFAIL
(
"
Unknown
stencil
func
"
)
;
}
}
else
{
funcMask
&
=
userBits
;
funcRef
&
=
userBits
;
}
const
GrStencilFunc
*
table
=
gSpecialToBasicStencilFunc
[
respectClip
]
;
func
=
table
[
func
-
kBasicStencilFuncCount
]
;
SkASSERT
(
func
>
=
0
&
&
func
<
kBasicStencilFuncCount
)
;
}
else
{
funcMask
&
=
userBits
;
funcRef
&
=
userBits
;
}
settings
-
>
setFunc
(
face
func
)
;
settings
-
>
setWriteMask
(
face
writeMask
)
;
settings
-
>
setFuncMask
(
face
funcMask
)
;
settings
-
>
setFuncRef
(
face
funcRef
)
;
if
(
GrStencilSettings
:
:
kFront_Face
=
=
face
)
{
face
=
GrStencilSettings
:
:
kBack_Face
;
finished
=
!
twoSided
;
}
else
{
finished
=
true
;
}
}
if
(
!
twoSided
)
{
settings
-
>
copyFrontSettingsToBack
(
)
;
}
}
GrTexture
*
GrClipMaskManager
:
:
CreateSoftwareClipMask
(
GrContext
*
context
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkVector
&
clipToMaskOffset
const
SkIRect
&
clipSpaceIBounds
)
{
GrUniqueKey
key
;
GetClipMaskKey
(
elementsGenID
clipSpaceIBounds
&
key
)
;
GrResourceProvider
*
resourceProvider
=
context
-
>
resourceProvider
(
)
;
if
(
GrTexture
*
texture
=
resourceProvider
-
>
findAndRefTextureByUniqueKey
(
key
)
)
{
return
texture
;
}
SkIRect
maskSpaceIBounds
=
SkIRect
:
:
MakeWH
(
clipSpaceIBounds
.
width
(
)
clipSpaceIBounds
.
height
(
)
)
;
GrSWMaskHelper
helper
(
context
)
;
SkMatrix
translate
;
translate
.
setTranslate
(
clipToMaskOffset
)
;
helper
.
init
(
maskSpaceIBounds
&
translate
false
)
;
helper
.
clear
(
GrReducedClip
:
:
kAllIn_InitialState
=
=
initialState
?
0xFF
:
0x00
)
;
SkStrokeRec
stroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
for
(
GrReducedClip
:
:
ElementList
:
:
Iter
iter
(
elements
.
headIter
(
)
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkRegion
:
:
Op
op
=
element
-
>
getOp
(
)
;
if
(
SkRegion
:
:
kIntersect_Op
=
=
op
|
|
SkRegion
:
:
kReverseDifference_Op
=
=
op
)
{
if
(
SkRegion
:
:
kReverseDifference_Op
=
=
op
)
{
SkRect
temp
=
SkRect
:
:
Make
(
clipSpaceIBounds
)
;
helper
.
draw
(
temp
SkRegion
:
:
kXOR_Op
false
0xFF
)
;
}
SkPath
clipPath
;
element
-
>
asPath
(
&
clipPath
)
;
clipPath
.
toggleInverseFillType
(
)
;
helper
.
draw
(
clipPath
stroke
SkRegion
:
:
kReplace_Op
element
-
>
isAA
(
)
0x00
)
;
continue
;
}
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
helper
.
draw
(
element
-
>
getRect
(
)
op
element
-
>
isAA
(
)
0xFF
)
;
}
else
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
helper
.
draw
(
path
stroke
op
element
-
>
isAA
(
)
0xFF
)
;
}
}
GrSurfaceDesc
desc
;
desc
.
fWidth
=
clipSpaceIBounds
.
width
(
)
;
desc
.
fHeight
=
clipSpaceIBounds
.
height
(
)
;
desc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
GrTexture
*
result
=
context
-
>
resourceProvider
(
)
-
>
createApproxTexture
(
desc
0
)
;
if
(
!
result
)
{
return
nullptr
;
}
result
-
>
resourcePriv
(
)
.
setUniqueKey
(
key
)
;
helper
.
toTexture
(
result
)
;
return
result
;
}
void
GrClipMaskManager
:
:
adjustPathStencilParams
(
const
GrStencilAttachment
*
stencilAttachment
GrStencilSettings
*
settings
)
{
if
(
stencilAttachment
)
{
int
stencilBits
=
stencilAttachment
-
>
bits
(
)
;
this
-
>
adjustStencilParams
(
settings
fClipMode
stencilBits
)
;
}
}
