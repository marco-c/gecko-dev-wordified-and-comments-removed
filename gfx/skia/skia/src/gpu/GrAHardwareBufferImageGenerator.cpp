#
include
"
SkTypes
.
h
"
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
#
define
GL_GLEXT_PROTOTYPES
#
define
EGL_EGLEXT_PROTOTYPES
#
include
"
GrAHardwareBufferImageGenerator
.
h
"
#
include
<
android
/
hardware_buffer
.
h
>
#
include
"
GrBackendSurface
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
<
EGL
/
egl
.
h
>
#
include
<
EGL
/
eglext
.
h
>
#
include
<
GLES
/
gl
.
h
>
#
include
<
GLES
/
glext
.
h
>
class
BufferCleanupHelper
{
public
:
BufferCleanupHelper
(
EGLImageKHR
image
EGLDisplay
display
)
:
fImage
(
image
)
fDisplay
(
display
)
{
}
~
BufferCleanupHelper
(
)
{
eglDestroyImageKHR
(
fDisplay
fImage
)
;
}
private
:
EGLImageKHR
fImage
;
EGLDisplay
fDisplay
;
}
;
std
:
:
unique_ptr
<
SkImageGenerator
>
GrAHardwareBufferImageGenerator
:
:
Make
(
AHardwareBuffer
*
graphicBuffer
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
)
{
AHardwareBuffer_Desc
bufferDesc
;
AHardwareBuffer_describe
(
graphicBuffer
&
bufferDesc
)
;
SkColorType
colorType
;
switch
(
bufferDesc
.
format
)
{
case
AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM
:
colorType
=
kRGBA_8888_SkColorType
;
break
;
case
AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT
:
colorType
=
kRGBA_F16_SkColorType
;
break
;
case
AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM
:
colorType
=
kRGB_565_SkColorType
;
break
;
default
:
return
nullptr
;
}
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
bufferDesc
.
width
bufferDesc
.
height
colorType
alphaType
std
:
:
move
(
colorSpace
)
)
;
return
std
:
:
unique_ptr
<
SkImageGenerator
>
(
new
GrAHardwareBufferImageGenerator
(
info
graphicBuffer
alphaType
)
)
;
}
GrAHardwareBufferImageGenerator
:
:
GrAHardwareBufferImageGenerator
(
const
SkImageInfo
&
info
AHardwareBuffer
*
graphicBuffer
SkAlphaType
alphaType
)
:
INHERITED
(
info
)
fGraphicBuffer
(
graphicBuffer
)
{
AHardwareBuffer_acquire
(
fGraphicBuffer
)
;
}
GrAHardwareBufferImageGenerator
:
:
~
GrAHardwareBufferImageGenerator
(
)
{
AHardwareBuffer_release
(
fGraphicBuffer
)
;
this
-
>
clear
(
)
;
}
void
GrAHardwareBufferImageGenerator
:
:
clear
(
)
{
if
(
fOriginalTexture
)
{
GrGpuResourceFreedMessage
msg
{
fOriginalTexture
fOwningContextID
}
;
SkMessageBus
<
GrGpuResourceFreedMessage
>
:
:
Post
(
msg
)
;
fOriginalTexture
=
nullptr
;
}
}
void
GrAHardwareBufferImageGenerator
:
:
deleteImageTexture
(
void
*
context
)
{
BufferCleanupHelper
*
cleanupHelper
=
static_cast
<
BufferCleanupHelper
*
>
(
context
)
;
delete
cleanupHelper
;
}
#
if
SK_SUPPORT_GPU
sk_sp
<
GrTextureProxy
>
GrAHardwareBufferImageGenerator
:
:
onGenerateTexture
(
GrContext
*
context
const
SkImageInfo
&
info
const
SkIPoint
&
origin
SkTransferFunctionBehavior
bool
willNeedMipMaps
)
{
auto
proxy
=
this
-
>
makeProxy
(
context
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
bool
makingASubset
=
true
;
if
(
0
=
=
origin
.
fX
&
&
0
=
=
origin
.
fY
&
&
info
.
width
(
)
=
=
getInfo
(
)
.
width
(
)
&
&
info
.
height
(
)
=
=
getInfo
(
)
.
height
(
)
)
{
makingASubset
=
false
;
if
(
!
willNeedMipMaps
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
{
return
proxy
;
}
}
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
origin
.
fX
origin
.
fY
info
.
width
(
)
info
.
height
(
)
)
;
GrMipMapped
mipMapped
=
willNeedMipMaps
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
;
sk_sp
<
GrTextureProxy
>
texProxy
=
GrSurfaceProxy
:
:
Copy
(
context
proxy
.
get
(
)
mipMapped
subset
SkBudgeted
:
:
kYes
)
;
if
(
!
makingASubset
&
&
texProxy
)
{
SkASSERT
(
willNeedMipMaps
)
;
SkASSERT
(
GrMipMapped
:
:
kYes
=
=
texProxy
-
>
mipMapped
(
)
)
;
SkASSERT
(
context
-
>
uniqueID
(
)
=
=
fOwningContextID
)
;
this
-
>
clear
(
)
;
texProxy
-
>
instantiate
(
context
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
;
GrTexture
*
texture
=
texProxy
-
>
priv
(
)
.
peekTexture
(
)
;
SkASSERT
(
texture
)
;
fOriginalTexture
=
texture
;
}
return
texProxy
;
}
#
endif
sk_sp
<
GrTextureProxy
>
GrAHardwareBufferImageGenerator
:
:
makeProxy
(
GrContext
*
context
)
{
if
(
context
-
>
abandoned
(
)
|
|
kOpenGL_GrBackend
!
=
context
-
>
contextPriv
(
)
.
getBackend
(
)
)
{
return
nullptr
;
}
auto
proxyProvider
=
context
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
if
(
fOriginalTexture
&
&
fOwningContextID
=
=
context
-
>
uniqueID
(
)
)
{
return
proxyProvider
-
>
createWrapped
(
sk_ref_sp
(
fOriginalTexture
)
kTopLeft_GrSurfaceOrigin
)
;
}
while
(
GL_NO_ERROR
!
=
glGetError
(
)
)
{
}
EGLClientBuffer
clientBuffer
=
eglGetNativeClientBufferANDROID
(
fGraphicBuffer
)
;
EGLint
attribs
[
]
=
{
EGL_IMAGE_PRESERVED_KHR
EGL_TRUE
EGL_NONE
}
;
EGLDisplay
display
=
eglGetCurrentDisplay
(
)
;
EGLImageKHR
image
=
eglCreateImageKHR
(
display
EGL_NO_CONTEXT
EGL_NATIVE_BUFFER_ANDROID
clientBuffer
attribs
)
;
if
(
EGL_NO_IMAGE_KHR
=
=
image
)
{
SkDebugf
(
"
Could
not
create
EGL
image
err
=
(
%
#
x
)
"
(
int
)
eglGetError
(
)
)
;
return
nullptr
;
}
GrGLuint
texID
;
glGenTextures
(
1
&
texID
)
;
if
(
!
texID
)
{
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
glBindTexture
(
GL_TEXTURE_EXTERNAL_OES
texID
)
;
GLenum
status
=
GL_NO_ERROR
;
if
(
(
status
=
glGetError
(
)
)
!
=
GL_NO_ERROR
)
{
SkDebugf
(
"
glBindTexture
failed
(
%
#
x
)
"
(
int
)
status
)
;
glDeleteTextures
(
1
&
texID
)
;
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
glEGLImageTargetTexture2DOES
(
GL_TEXTURE_EXTERNAL_OES
image
)
;
if
(
(
status
=
glGetError
(
)
)
!
=
GL_NO_ERROR
)
{
SkDebugf
(
"
glEGLImageTargetTexture2DOES
failed
(
%
#
x
)
"
(
int
)
status
)
;
glDeleteTextures
(
1
&
texID
)
;
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
context
-
>
resetContext
(
kTextureBinding_GrGLBackendState
)
;
GrGLTextureInfo
textureInfo
;
textureInfo
.
fTarget
=
GL_TEXTURE_EXTERNAL_OES
;
textureInfo
.
fID
=
texID
;
GrPixelConfig
pixelConfig
;
switch
(
getInfo
(
)
.
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
pixelConfig
=
kRGBA_8888_GrPixelConfig
;
break
;
case
kRGBA_F16_SkColorType
:
pixelConfig
=
kRGBA_half_GrPixelConfig
;
break
;
case
kRGB_565_SkColorType
:
pixelConfig
=
kRGB_565_GrPixelConfig
;
break
;
default
:
glDeleteTextures
(
1
&
texID
)
;
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
GrBackendTexture
backendTex
(
getInfo
(
)
.
width
(
)
getInfo
(
)
.
height
(
)
pixelConfig
textureInfo
)
;
if
(
backendTex
.
width
(
)
<
=
0
|
|
backendTex
.
height
(
)
<
=
0
)
{
glDeleteTextures
(
1
&
texID
)
;
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
sk_sp
<
GrTexture
>
tex
=
context
-
>
contextPriv
(
)
.
resourceProvider
(
)
-
>
wrapBackendTexture
(
backendTex
kAdopt_GrWrapOwnership
)
;
if
(
!
tex
)
{
glDeleteTextures
(
1
&
texID
)
;
eglDestroyImageKHR
(
display
image
)
;
return
nullptr
;
}
sk_sp
<
GrReleaseProcHelper
>
releaseHelper
(
new
GrReleaseProcHelper
(
deleteImageTexture
new
BufferCleanupHelper
(
image
display
)
)
)
;
tex
-
>
setRelease
(
std
:
:
move
(
releaseHelper
)
)
;
SkASSERT
(
!
fOriginalTexture
)
;
this
-
>
clear
(
)
;
fOriginalTexture
=
tex
.
get
(
)
;
fOwningContextID
=
context
-
>
uniqueID
(
)
;
context
-
>
contextPriv
(
)
.
getResourceCache
(
)
-
>
insertCrossContextGpuResource
(
fOriginalTexture
)
;
return
proxyProvider
-
>
createWrapped
(
std
:
:
move
(
tex
)
kTopLeft_GrSurfaceOrigin
)
;
}
bool
GrAHardwareBufferImageGenerator
:
:
onIsValid
(
GrContext
*
context
)
const
{
if
(
nullptr
=
=
context
)
{
return
false
;
}
return
kOpenGL_GrBackend
=
=
context
-
>
contextPriv
(
)
.
getBackend
(
)
;
}
#
endif
