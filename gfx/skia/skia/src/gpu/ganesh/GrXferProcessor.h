#
ifndef
GrXferProcessor_DEFINED
#
define
GrXferProcessor_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
src
/
gpu
/
Blend
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessorAnalysis
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrGLSLXPFragmentBuilder
;
class
GrGLSLProgramDataManager
;
struct
GrShaderCaps
;
namespace
skgpu
{
class
KeyBuilder
;
}
enum
GrXferBarrierType
{
kNone_GrXferBarrierType
=
0
kTexture_GrXferBarrierType
kBlend_GrXferBarrierType
}
;
static_assert
(
SkToBool
(
kNone_GrXferBarrierType
)
=
=
false
)
;
enum
class
GrXferBarrierFlags
{
kNone
=
0
kTexture
=
1
<
<
0
kBlend
=
1
<
<
1
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrXferBarrierFlags
)
class
GrXferProcessor
:
public
GrProcessor
public
GrNonAtomicRef
<
GrXferProcessor
>
{
public
:
class
ProgramImpl
;
void
addToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
const
GrSurfaceOrigin
*
originIfDstTexture
bool
usesInputAttachmentForDstRead
)
const
;
virtual
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
)
const
=
0
;
virtual
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
caps
)
const
{
return
kNone_GrXferBarrierType
;
}
inline
skgpu
:
:
BlendInfo
getBlendInfo
(
)
const
{
skgpu
:
:
BlendInfo
blendInfo
;
if
(
!
this
-
>
willReadDstColor
(
)
)
{
this
-
>
onGetBlendInfo
(
&
blendInfo
)
;
}
return
blendInfo
;
}
bool
willReadDstColor
(
)
const
{
return
fWillReadDstColor
;
}
bool
hasSecondaryOutput
(
)
const
;
bool
isLCD
(
)
const
{
return
fIsLCD
;
}
bool
isEqual
(
const
GrXferProcessor
&
that
)
const
{
if
(
this
-
>
classID
(
)
!
=
that
.
classID
(
)
)
{
return
false
;
}
if
(
this
-
>
fWillReadDstColor
!
=
that
.
fWillReadDstColor
)
{
return
false
;
}
if
(
fIsLCD
!
=
that
.
fIsLCD
)
{
return
false
;
}
return
this
-
>
onIsEqual
(
that
)
;
}
protected
:
GrXferProcessor
(
ClassID
classID
)
;
GrXferProcessor
(
ClassID
classID
bool
willReadDstColor
GrProcessorAnalysisCoverage
)
;
private
:
virtual
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
=
0
;
virtual
bool
onHasSecondaryOutput
(
)
const
{
return
false
;
}
virtual
void
onGetBlendInfo
(
skgpu
:
:
BlendInfo
*
)
const
{
}
virtual
bool
onIsEqual
(
const
GrXferProcessor
&
)
const
=
0
;
bool
fWillReadDstColor
;
bool
fIsLCD
;
using
INHERITED
=
GrProcessor
;
}
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wnon
-
virtual
-
dtor
"
#
endif
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wnon
-
virtual
-
dtor
"
#
endif
class
GrXPFactory
{
public
:
enum
class
AnalysisProperties
:
unsigned
{
kNone
=
0x0
kReadsDstInShader
=
0x1
kCompatibleWithCoverageAsAlpha
=
0x2
kIgnoresInputColor
=
0x4
kRequiresDstTexture
=
0x10
kRequiresNonOverlappingDraws
=
0x20
kUsesNonCoherentHWBlending
=
0x40
kUnaffectedByDstValue
=
0x80
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
AnalysisProperties
)
;
static
sk_sp
<
const
GrXferProcessor
>
MakeXferProcessor
(
const
GrXPFactory
*
const
GrProcessorAnalysisColor
&
GrProcessorAnalysisCoverage
const
GrCaps
&
caps
GrClampType
)
;
static
AnalysisProperties
GetAnalysisProperties
(
const
GrXPFactory
*
const
GrProcessorAnalysisColor
&
const
GrProcessorAnalysisCoverage
&
const
GrCaps
&
GrClampType
)
;
protected
:
constexpr
GrXPFactory
(
)
{
}
private
:
virtual
sk_sp
<
const
GrXferProcessor
>
makeXferProcessor
(
const
GrProcessorAnalysisColor
&
GrProcessorAnalysisCoverage
const
GrCaps
&
GrClampType
)
const
=
0
;
virtual
AnalysisProperties
analysisProperties
(
const
GrProcessorAnalysisColor
&
const
GrProcessorAnalysisCoverage
&
const
GrCaps
&
GrClampType
)
const
=
0
;
}
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
pop
#
endif
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
GR_MAKE_BITFIELD_CLASS_OPS
(
GrXPFactory
:
:
AnalysisProperties
)
class
GrXferProcessor
:
:
ProgramImpl
{
public
:
virtual
~
ProgramImpl
(
)
=
default
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLXPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrXferProcessor
&
xp
const
char
*
inputColor
const
char
*
inputCoverage
const
char
*
outputPrimary
const
char
*
outputSecondary
const
SamplerHandle
dstTextureSamplerHandle
GrSurfaceOrigin
dstTextureOrigin
const
skgpu
:
:
Swizzle
&
writeSwizzle
)
:
fXPFragBuilder
(
fragBuilder
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fXP
(
xp
)
fInputColor
(
inputColor
?
inputColor
:
"
half4
(
1
.
0
)
"
)
fInputCoverage
(
inputCoverage
)
fOutputPrimary
(
outputPrimary
)
fOutputSecondary
(
outputSecondary
)
fDstTextureSamplerHandle
(
dstTextureSamplerHandle
)
fDstTextureOrigin
(
dstTextureOrigin
)
fWriteSwizzle
(
writeSwizzle
)
{
}
GrGLSLXPFragmentBuilder
*
fXPFragBuilder
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrXferProcessor
&
fXP
;
const
char
*
fInputColor
;
const
char
*
fInputCoverage
;
const
char
*
fOutputPrimary
;
const
char
*
fOutputSecondary
;
const
SamplerHandle
fDstTextureSamplerHandle
;
GrSurfaceOrigin
fDstTextureOrigin
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
}
;
void
emitCode
(
const
EmitArgs
&
)
;
void
setData
(
const
GrGLSLProgramDataManager
&
pdm
const
GrXferProcessor
&
xp
)
;
protected
:
ProgramImpl
(
)
=
default
;
static
void
DefaultCoverageModulation
(
GrGLSLXPFragmentBuilder
*
fragBuilder
const
char
*
srcCoverage
const
char
*
dstColor
const
char
*
outColor
const
char
*
outColorSecondary
const
GrXferProcessor
&
proc
)
;
private
:
virtual
void
emitOutputsForBlendState
(
const
EmitArgs
&
)
{
SK_ABORT
(
"
emitOutputsForBlendState
not
implemented
.
"
)
;
}
virtual
void
emitBlendCodeForDstRead
(
GrGLSLXPFragmentBuilder
*
GrGLSLUniformHandler
*
const
char
*
srcColor
const
char
*
srcCoverage
const
char
*
dstColor
const
char
*
outColor
const
char
*
outColorSecondary
const
GrXferProcessor
&
)
{
SK_ABORT
(
"
emitBlendCodeForDstRead
not
implemented
.
"
)
;
}
virtual
void
emitWriteSwizzle
(
GrGLSLXPFragmentBuilder
*
const
skgpu
:
:
Swizzle
&
const
char
*
outColor
const
char
*
outColorSecondary
)
const
;
virtual
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrXferProcessor
&
)
{
}
}
;
#
endif
