#
ifndef
GrGpu_DEFINED
#
define
GrGpu_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
gpu
/
RefCntedCallback
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAttachment
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrPixmap
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrXferProcessor
.
h
"
class
GrAttachment
;
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
struct
GrContextOptions
;
class
GrDirectContext
;
class
GrGLContext
;
class
GrPipeline
;
class
GrGeometryProcessor
;
class
GrRenderTarget
;
class
GrRingBuffer
;
class
GrSemaphore
;
class
GrStagingBufferManager
;
class
GrStencilSettings
;
class
GrSurface
;
class
GrTexture
;
class
GrThreadSafePipelineBuilder
;
struct
GrVkDrawableInfo
;
class
SkJSONWriter
;
enum
class
SkTextureCompressionType
;
namespace
SkSL
{
class
Compiler
;
}
class
GrGpu
:
public
SkRefCnt
{
public
:
GrGpu
(
GrDirectContext
*
direct
)
;
~
GrGpu
(
)
override
;
GrDirectContext
*
getContext
(
)
{
return
fContext
;
}
const
GrDirectContext
*
getContext
(
)
const
{
return
fContext
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
{
return
fCaps
;
}
virtual
GrStagingBufferManager
*
stagingBufferManager
(
)
{
return
nullptr
;
}
virtual
GrRingBuffer
*
uniformsRingBuffer
(
)
{
return
nullptr
;
}
SkSL
:
:
Compiler
*
shaderCompiler
(
)
const
{
return
fCompiler
.
get
(
)
;
}
enum
class
DisconnectType
{
kAbandon
kCleanup
}
;
virtual
void
disconnect
(
DisconnectType
)
;
virtual
GrThreadSafePipelineBuilder
*
pipelineBuilder
(
)
=
0
;
virtual
sk_sp
<
GrThreadSafePipelineBuilder
>
refPipelineBuilder
(
)
=
0
;
virtual
bool
isDeviceLost
(
)
const
{
return
false
;
}
void
markContextDirty
(
uint32_t
state
=
kAll_GrBackendState
)
{
fResetBits
|
=
state
;
}
sk_sp
<
GrTexture
>
createTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrTextureType
textureType
GrRenderable
renderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
GrColorType
textureColorType
GrColorType
srcColorType
const
GrMipLevel
texels
[
]
int
texelLevelCount
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrTextureType
textureType
GrRenderable
renderable
int
renderTargetSampleCnt
GrMipmapped
mipmapped
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createCompressedTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
skgpu
:
:
Budgeted
budgeted
GrMipmapped
mipmapped
GrProtected
isProtected
const
void
*
data
size_t
dataSize
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
GrIOType
)
;
sk_sp
<
GrTexture
>
wrapCompressedBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrTexture
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
;
sk_sp
<
GrRenderTarget
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
sk_sp
<
GrGpuBuffer
>
createBuffer
(
size_t
size
GrGpuBufferType
intendedType
GrAccessPattern
accessPattern
)
;
void
resolveRenderTarget
(
GrRenderTarget
*
const
SkIRect
&
resolveRect
)
;
bool
regenerateMipMapLevels
(
GrTexture
*
)
;
void
resetTextureBindings
(
)
;
bool
readPixels
(
GrSurface
*
surface
SkIRect
rect
GrColorType
surfaceColorType
GrColorType
dstColorType
void
*
buffer
size_t
rowBytes
)
;
bool
writePixels
(
GrSurface
*
surface
SkIRect
rect
GrColorType
surfaceColorType
GrColorType
srcColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
bool
prepForTexSampling
=
false
)
;
bool
writePixels
(
GrSurface
*
surface
SkIRect
rect
GrColorType
surfaceColorType
GrColorType
srcColorType
const
void
*
buffer
size_t
rowBytes
bool
prepForTexSampling
=
false
)
{
GrMipLevel
mipLevel
=
{
buffer
rowBytes
nullptr
}
;
return
this
-
>
writePixels
(
surface
rect
surfaceColorType
srcColorType
&
mipLevel
1
prepForTexSampling
)
;
}
bool
transferFromBufferToBuffer
(
sk_sp
<
GrGpuBuffer
>
src
size_t
srcOffset
sk_sp
<
GrGpuBuffer
>
dst
size_t
dstOffset
size_t
size
)
;
bool
transferPixelsTo
(
GrTexture
*
texture
SkIRect
rect
GrColorType
textureColorType
GrColorType
bufferColorType
sk_sp
<
GrGpuBuffer
>
transferBuffer
size_t
offset
size_t
rowBytes
)
;
bool
transferPixelsFrom
(
GrSurface
*
surface
SkIRect
rect
GrColorType
surfaceColorType
GrColorType
bufferColorType
sk_sp
<
GrGpuBuffer
>
transferBuffer
size_t
offset
)
;
bool
copySurface
(
GrSurface
*
dst
const
SkIRect
&
dstRect
GrSurface
*
src
const
SkIRect
&
srcRect
GrSamplerState
:
:
Filter
filter
)
;
GrOpsRenderPass
*
getOpsRenderPass
(
GrRenderTarget
*
renderTarget
bool
useMSAASurface
GrAttachment
*
stencil
GrSurfaceOrigin
const
SkIRect
&
bounds
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
&
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
&
const
SkTArray
<
GrSurfaceProxy
*
true
>
&
sampledProxies
GrXferBarrierFlags
renderPassXferBarriers
)
;
void
executeFlushInfo
(
SkSpan
<
GrSurfaceProxy
*
>
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
const
skgpu
:
:
MutableTextureState
*
newState
)
;
virtual
void
willExecute
(
)
{
}
bool
submitToGpu
(
bool
syncCpu
)
;
virtual
void
submit
(
GrOpsRenderPass
*
)
=
0
;
virtual
GrFence
SK_WARN_UNUSED_RESULT
insertFence
(
)
=
0
;
virtual
bool
waitFence
(
GrFence
)
=
0
;
virtual
void
deleteFence
(
GrFence
)
=
0
;
virtual
std
:
:
unique_ptr
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
bool
isOwned
=
true
)
=
0
;
virtual
std
:
:
unique_ptr
<
GrSemaphore
>
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
GrSemaphoreWrapType
GrWrapOwnership
)
=
0
;
virtual
void
insertSemaphore
(
GrSemaphore
*
semaphore
)
=
0
;
virtual
void
waitSemaphore
(
GrSemaphore
*
semaphore
)
=
0
;
virtual
void
addFinishedProc
(
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
=
0
;
virtual
void
checkFinishProcs
(
)
=
0
;
virtual
void
finishOutstandingGpuWork
(
)
=
0
;
virtual
void
takeOwnershipOfBuffer
(
sk_sp
<
GrGpuBuffer
>
)
{
}
bool
checkAndResetOOMed
(
)
;
virtual
std
:
:
unique_ptr
<
GrSemaphore
>
prepareTextureForCrossContextUsage
(
GrTexture
*
)
=
0
;
virtual
void
releaseUnlockedBackendObjects
(
)
{
}
class
Stats
{
public
:
#
if
GR_GPU_STATS
Stats
(
)
=
default
;
void
reset
(
)
{
*
this
=
{
}
;
}
int
textureCreates
(
)
const
{
return
fTextureCreates
;
}
void
incTextureCreates
(
)
{
fTextureCreates
+
+
;
}
int
textureUploads
(
)
const
{
return
fTextureUploads
;
}
void
incTextureUploads
(
)
{
fTextureUploads
+
+
;
}
int
transfersToTexture
(
)
const
{
return
fTransfersToTexture
;
}
void
incTransfersToTexture
(
)
{
fTransfersToTexture
+
+
;
}
int
transfersFromSurface
(
)
const
{
return
fTransfersFromSurface
;
}
void
incTransfersFromSurface
(
)
{
fTransfersFromSurface
+
+
;
}
void
incBufferTransfers
(
)
{
fBufferTransfers
+
+
;
}
int
bufferTransfers
(
)
const
{
return
fBufferTransfers
;
}
int
stencilAttachmentCreates
(
)
const
{
return
fStencilAttachmentCreates
;
}
void
incStencilAttachmentCreates
(
)
{
fStencilAttachmentCreates
+
+
;
}
int
msaaAttachmentCreates
(
)
const
{
return
fMSAAAttachmentCreates
;
}
void
incMSAAAttachmentCreates
(
)
{
fMSAAAttachmentCreates
+
+
;
}
int
numDraws
(
)
const
{
return
fNumDraws
;
}
void
incNumDraws
(
)
{
fNumDraws
+
+
;
}
int
numFailedDraws
(
)
const
{
return
fNumFailedDraws
;
}
void
incNumFailedDraws
(
)
{
+
+
fNumFailedDraws
;
}
int
numSubmitToGpus
(
)
const
{
return
fNumSubmitToGpus
;
}
void
incNumSubmitToGpus
(
)
{
+
+
fNumSubmitToGpus
;
}
int
numScratchTexturesReused
(
)
const
{
return
fNumScratchTexturesReused
;
}
void
incNumScratchTexturesReused
(
)
{
+
+
fNumScratchTexturesReused
;
}
int
numScratchMSAAAttachmentsReused
(
)
const
{
return
fNumScratchMSAAAttachmentsReused
;
}
void
incNumScratchMSAAAttachmentsReused
(
)
{
+
+
fNumScratchMSAAAttachmentsReused
;
}
int
renderPasses
(
)
const
{
return
fRenderPasses
;
}
void
incRenderPasses
(
)
{
fRenderPasses
+
+
;
}
int
numReorderedDAGsOverBudget
(
)
const
{
return
fNumReorderedDAGsOverBudget
;
}
void
incNumReorderedDAGsOverBudget
(
)
{
fNumReorderedDAGsOverBudget
+
+
;
}
#
if
GR_TEST_UTILS
void
dump
(
SkString
*
)
;
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
;
#
endif
private
:
int
fTextureCreates
=
0
;
int
fTextureUploads
=
0
;
int
fTransfersToTexture
=
0
;
int
fTransfersFromSurface
=
0
;
int
fBufferTransfers
=
0
;
int
fStencilAttachmentCreates
=
0
;
int
fMSAAAttachmentCreates
=
0
;
int
fNumDraws
=
0
;
int
fNumFailedDraws
=
0
;
int
fNumSubmitToGpus
=
0
;
int
fNumScratchTexturesReused
=
0
;
int
fNumScratchMSAAAttachmentsReused
=
0
;
int
fRenderPasses
=
0
;
int
fNumReorderedDAGsOverBudget
=
0
;
#
else
#
if
GR_TEST_UTILS
void
dump
(
SkString
*
)
{
}
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
SkTArray
<
double
>
*
)
{
}
#
endif
void
incTextureCreates
(
)
{
}
void
incTextureUploads
(
)
{
}
void
incTransfersToTexture
(
)
{
}
void
incBufferTransfers
(
)
{
}
void
incTransfersFromSurface
(
)
{
}
void
incStencilAttachmentCreates
(
)
{
}
void
incMSAAAttachmentCreates
(
)
{
}
void
incNumDraws
(
)
{
}
void
incNumFailedDraws
(
)
{
}
void
incNumSubmitToGpus
(
)
{
}
void
incNumScratchTexturesReused
(
)
{
}
void
incNumScratchMSAAAttachmentsReused
(
)
{
}
void
incRenderPasses
(
)
{
}
void
incNumReorderedDAGsOverBudget
(
)
{
}
#
endif
}
;
Stats
*
stats
(
)
{
return
&
fStats
;
}
void
dumpJSON
(
SkJSONWriter
*
)
const
;
GrBackendTexture
createBackendTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrRenderable
GrMipmapped
GrProtected
std
:
:
string_view
label
)
;
bool
clearBackendTexture
(
const
GrBackendTexture
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
std
:
:
array
<
float
4
>
color
)
;
GrBackendTexture
createCompressedBackendTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrMipmapped
GrProtected
)
;
bool
updateCompressedBackendTexture
(
const
GrBackendTexture
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
const
void
*
data
size_t
length
)
;
virtual
bool
setBackendTextureState
(
const
GrBackendTexture
&
const
skgpu
:
:
MutableTextureState
&
skgpu
:
:
MutableTextureState
*
previousState
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
)
{
return
false
;
}
virtual
bool
setBackendRenderTargetState
(
const
GrBackendRenderTarget
&
const
skgpu
:
:
MutableTextureState
&
skgpu
:
:
MutableTextureState
*
previousState
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
)
{
return
false
;
}
virtual
void
deleteBackendTexture
(
const
GrBackendTexture
&
)
=
0
;
virtual
bool
compile
(
const
GrProgramDesc
&
const
GrProgramInfo
&
)
=
0
;
virtual
bool
precompileShader
(
const
SkData
&
key
const
SkData
&
data
)
{
return
false
;
}
#
if
GR_TEST_UTILS
virtual
bool
isTestingOnlyBackendTexture
(
const
GrBackendTexture
&
)
const
=
0
;
virtual
GrBackendRenderTarget
createTestingOnlyBackendRenderTarget
(
SkISize
dimensions
GrColorType
int
sampleCount
=
1
GrProtected
=
GrProtected
:
:
kNo
)
=
0
;
virtual
void
deleteTestingOnlyBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
=
0
;
virtual
const
GrGLContext
*
glContextForTesting
(
)
const
{
return
nullptr
;
}
virtual
void
resetShaderCacheForTesting
(
)
const
{
}
virtual
void
testingOnly_startCapture
(
)
{
}
virtual
void
testingOnly_stopCapture
(
)
{
}
#
endif
virtual
sk_sp
<
GrAttachment
>
makeStencilAttachment
(
const
GrBackendFormat
&
colorFormat
SkISize
dimensions
int
numStencilSamples
)
=
0
;
virtual
GrBackendFormat
getPreferredStencilFormat
(
const
GrBackendFormat
&
)
=
0
;
virtual
sk_sp
<
GrAttachment
>
makeMSAAAttachment
(
SkISize
dimensions
const
GrBackendFormat
&
format
int
numSamples
GrProtected
isProtected
GrMemoryless
isMemoryless
)
=
0
;
void
handleDirtyContext
(
)
{
if
(
fResetBits
)
{
this
-
>
resetContext
(
)
;
}
}
virtual
void
storeVkPipelineCacheData
(
)
{
}
virtual
void
xferBarrier
(
GrRenderTarget
*
GrXferBarrierType
)
=
0
;
protected
:
static
bool
CompressedDataIsCorrect
(
SkISize
dimensions
SkTextureCompressionType
GrMipmapped
const
void
*
data
size_t
length
)
;
void
didWriteToSurface
(
GrSurface
*
surface
GrSurfaceOrigin
origin
const
SkIRect
*
bounds
uint32_t
mipLevels
=
1
)
const
;
void
setOOMed
(
)
{
fOOMed
=
true
;
}
Stats
fStats
;
void
initCapsAndCompiler
(
sk_sp
<
const
GrCaps
>
caps
)
;
private
:
virtual
GrBackendTexture
onCreateBackendTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrRenderable
GrMipmapped
GrProtected
std
:
:
string_view
label
)
=
0
;
virtual
GrBackendTexture
onCreateCompressedBackendTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrMipmapped
GrProtected
)
=
0
;
virtual
bool
onClearBackendTexture
(
const
GrBackendTexture
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
std
:
:
array
<
float
4
>
color
)
=
0
;
virtual
bool
onUpdateCompressedBackendTexture
(
const
GrBackendTexture
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
const
void
*
data
size_t
length
)
=
0
;
virtual
void
onResetContext
(
uint32_t
resetBits
)
{
}
virtual
void
onResetTextureBindings
(
)
{
}
virtual
sk_sp
<
GrTexture
>
onCreateTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrRenderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
GrProtected
int
mipLevelCoont
uint32_t
levelClearMask
std
:
:
string_view
label
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onCreateCompressedTexture
(
SkISize
dimensions
const
GrBackendFormat
&
skgpu
:
:
Budgeted
GrMipmapped
GrProtected
const
void
*
data
size_t
dataSize
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onWrapBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
GrIOType
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onWrapCompressedBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onWrapRenderableBackendTexture
(
const
GrBackendTexture
&
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
)
=
0
;
virtual
sk_sp
<
GrRenderTarget
>
onWrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
=
0
;
virtual
sk_sp
<
GrRenderTarget
>
onWrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
virtual
sk_sp
<
GrGpuBuffer
>
onCreateBuffer
(
size_t
size
GrGpuBufferType
intendedType
GrAccessPattern
)
=
0
;
virtual
bool
onReadPixels
(
GrSurface
*
SkIRect
GrColorType
surfaceColorType
GrColorType
dstColorType
void
*
size_t
rowBytes
)
=
0
;
virtual
bool
onWritePixels
(
GrSurface
*
SkIRect
GrColorType
surfaceColorType
GrColorType
srcColorType
const
GrMipLevel
[
]
int
mipLevelCount
bool
prepForTexSampling
)
=
0
;
virtual
bool
onTransferFromBufferToBuffer
(
sk_sp
<
GrGpuBuffer
>
src
size_t
srcOffset
sk_sp
<
GrGpuBuffer
>
dst
size_t
dstOffset
size_t
size
)
=
0
;
virtual
bool
onTransferPixelsTo
(
GrTexture
*
SkIRect
GrColorType
textureColorType
GrColorType
bufferColorType
sk_sp
<
GrGpuBuffer
>
transferBuffer
size_t
offset
size_t
rowBytes
)
=
0
;
virtual
bool
onTransferPixelsFrom
(
GrSurface
*
SkIRect
GrColorType
surfaceColorType
GrColorType
bufferColorType
sk_sp
<
GrGpuBuffer
>
transferBuffer
size_t
offset
)
=
0
;
virtual
void
onResolveRenderTarget
(
GrRenderTarget
*
target
const
SkIRect
&
resolveRect
)
=
0
;
virtual
bool
onRegenerateMipMapLevels
(
GrTexture
*
)
=
0
;
virtual
bool
onCopySurface
(
GrSurface
*
dst
const
SkIRect
&
dstRect
GrSurface
*
src
const
SkIRect
&
srcRect
GrSamplerState
:
:
Filter
)
=
0
;
virtual
GrOpsRenderPass
*
onGetOpsRenderPass
(
GrRenderTarget
*
renderTarget
bool
useMSAASurface
GrAttachment
*
stencil
GrSurfaceOrigin
const
SkIRect
&
bounds
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
&
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
&
const
SkTArray
<
GrSurfaceProxy
*
true
>
&
sampledProxies
GrXferBarrierFlags
renderPassXferBarriers
)
=
0
;
virtual
void
prepareSurfacesForBackendAccessAndStateUpdates
(
SkSpan
<
GrSurfaceProxy
*
>
proxies
SkSurface
:
:
BackendSurfaceAccess
access
const
skgpu
:
:
MutableTextureState
*
newState
)
{
}
virtual
bool
onSubmitToGpu
(
bool
syncCpu
)
=
0
;
void
reportSubmitHistograms
(
)
;
virtual
void
onReportSubmitHistograms
(
)
{
}
#
ifdef
SK_ENABLE_DUMP_GPU
virtual
void
onDumpJSON
(
SkJSONWriter
*
)
const
{
}
#
endif
sk_sp
<
GrTexture
>
createTextureCommon
(
SkISize
const
GrBackendFormat
&
GrTextureType
textureType
GrRenderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
GrProtected
int
mipLevelCnt
uint32_t
levelClearMask
std
:
:
string_view
label
)
;
void
resetContext
(
)
{
this
-
>
onResetContext
(
fResetBits
)
;
fResetBits
=
0
;
}
void
callSubmittedProcs
(
bool
success
)
;
sk_sp
<
const
GrCaps
>
fCaps
;
std
:
:
unique_ptr
<
SkSL
:
:
Compiler
>
fCompiler
;
uint32_t
fResetBits
;
GrDirectContext
*
fContext
;
struct
SubmittedProc
{
SubmittedProc
(
GrGpuSubmittedProc
proc
GrGpuSubmittedContext
context
)
:
fProc
(
proc
)
fContext
(
context
)
{
}
GrGpuSubmittedProc
fProc
;
GrGpuSubmittedContext
fContext
;
}
;
SkSTArray
<
4
SubmittedProc
>
fSubmittedProcs
;
bool
fOOMed
=
false
;
#
if
SK_HISTOGRAMS_ENABLED
int
fCurrentSubmitRenderPassCount
=
0
;
#
endif
using
INHERITED
=
SkRefCnt
;
}
;
#
endif
