#
ifndef
GrAATriangulator_DEFINED
#
define
GrAATriangulator_DEFINED
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrTriangulator
.
h
"
class
GrAATriangulator
:
private
GrTriangulator
{
public
:
static
int
PathToAATriangles
(
const
SkPath
&
path
SkScalar
tolerance
const
SkRect
&
clipBounds
GrEagerVertexAllocator
*
vertexAllocator
)
{
SkArenaAlloc
alloc
(
kArenaDefaultChunkSize
)
;
GrAATriangulator
aaTriangulator
(
path
&
alloc
)
;
aaTriangulator
.
fRoundVerticesToQuarterPixel
=
true
;
aaTriangulator
.
fEmitCoverage
=
true
;
bool
isLinear
;
auto
[
polys
success
]
=
aaTriangulator
.
pathToPolys
(
tolerance
clipBounds
&
isLinear
)
;
if
(
!
success
)
{
return
0
;
}
return
aaTriangulator
.
polysToAATriangles
(
polys
vertexAllocator
)
;
}
struct
SSEdge
;
struct
EventList
;
struct
Event
{
Event
(
SSEdge
*
edge
const
SkPoint
&
point
uint8_t
alpha
)
:
fEdge
(
edge
)
fPoint
(
point
)
fAlpha
(
alpha
)
{
}
SSEdge
*
fEdge
;
SkPoint
fPoint
;
uint8_t
fAlpha
;
void
apply
(
VertexList
*
mesh
const
Comparator
&
EventList
*
events
GrAATriangulator
*
)
;
}
;
struct
EventComparator
{
enum
class
Op
{
kLessThan
kGreaterThan
}
;
EventComparator
(
Op
op
)
:
fOp
(
op
)
{
}
bool
operator
(
)
(
Event
*
const
&
e1
Event
*
const
&
e2
)
{
return
fOp
=
=
Op
:
:
kLessThan
?
e1
-
>
fAlpha
<
e2
-
>
fAlpha
:
e1
-
>
fAlpha
>
e2
-
>
fAlpha
;
}
Op
fOp
;
}
;
private
:
GrAATriangulator
(
const
SkPath
&
path
SkArenaAlloc
*
alloc
)
:
GrTriangulator
(
path
alloc
)
{
}
void
extractBoundary
(
EdgeList
*
boundary
Edge
*
e
)
const
;
void
extractBoundaries
(
const
VertexList
&
inMesh
VertexList
*
innerVertices
const
Comparator
&
)
;
void
simplifyBoundary
(
EdgeList
*
boundary
const
Comparator
&
)
;
void
strokeBoundary
(
EdgeList
*
boundary
VertexList
*
innerMesh
const
Comparator
&
)
;
std
:
:
tuple
<
Poly
*
bool
>
tessellate
(
const
VertexList
&
mesh
const
Comparator
&
)
override
;
int
polysToAATriangles
(
Poly
*
GrEagerVertexAllocator
*
)
const
;
void
makeEvent
(
SSEdge
*
EventList
*
events
)
const
;
void
makeEvent
(
SSEdge
*
Vertex
*
v
SSEdge
*
other
Vertex
*
dest
EventList
*
events
const
Comparator
&
)
const
;
void
connectPartners
(
VertexList
*
mesh
const
Comparator
&
)
;
void
removeNonBoundaryEdges
(
const
VertexList
&
mesh
)
const
;
void
connectSSEdge
(
Vertex
*
v
Vertex
*
dest
const
Comparator
&
)
;
bool
collapseOverlapRegions
(
VertexList
*
mesh
const
Comparator
&
EventComparator
comp
)
;
mutable
VertexList
fOuterMesh
;
}
;
#
endif
#
endif
