#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuad
.
h
"
#
include
<
cmath
>
using
float4
=
skvx
:
:
float4
;
using
mask4
=
skvx
:
:
int4
;
#
define
AI
SK_ALWAYS_INLINE
static
constexpr
float
kTolerance
=
1e
-
9f
;
static
constexpr
float
kDistTolerance
=
1e
-
2f
;
static
constexpr
float
kDist2Tolerance
=
kDistTolerance
*
kDistTolerance
;
static
constexpr
float
kInvDistTolerance
=
1
.
f
/
kDistTolerance
;
template
<
typename
T
>
static
AI
skvx
:
:
Vec
<
4
T
>
next_cw
(
const
skvx
:
:
Vec
<
4
T
>
&
v
)
{
return
skvx
:
:
shuffle
<
2
0
3
1
>
(
v
)
;
}
template
<
typename
T
>
static
AI
skvx
:
:
Vec
<
4
T
>
next_ccw
(
const
skvx
:
:
Vec
<
4
T
>
&
v
)
{
return
skvx
:
:
shuffle
<
1
3
0
2
>
(
v
)
;
}
static
AI
float4
next_diag
(
const
float4
&
v
)
{
return
skvx
:
:
shuffle
<
3
2
1
0
>
(
v
)
;
}
static
AI
void
correct_bad_edges
(
const
mask4
&
bad
float4
*
e1
float4
*
e2
float4
*
e3
)
{
if
(
any
(
bad
)
)
{
*
e1
=
if_then_else
(
bad
-
next_diag
(
*
e1
)
*
e1
)
;
*
e2
=
if_then_else
(
bad
-
next_diag
(
*
e2
)
*
e2
)
;
if
(
e3
)
{
*
e3
=
if_then_else
(
bad
-
next_diag
(
*
e3
)
*
e3
)
;
}
}
}
static
AI
void
correct_bad_coords
(
const
mask4
&
bad
float4
*
c1
float4
*
c2
float4
*
c3
)
{
if
(
any
(
bad
)
)
{
*
c1
=
if_then_else
(
bad
next_ccw
(
*
c1
)
*
c1
)
;
*
c2
=
if_then_else
(
bad
next_ccw
(
*
c2
)
*
c2
)
;
if
(
c3
)
{
*
c3
=
if_then_else
(
bad
next_ccw
(
*
c3
)
*
c3
)
;
}
}
}
static
void
interpolate_local
(
float
alpha
int
v0
int
v1
int
v2
int
v3
float
lx
[
4
]
float
ly
[
4
]
float
lw
[
4
]
)
{
SkASSERT
(
v0
>
=
0
&
&
v0
<
4
)
;
SkASSERT
(
v1
>
=
0
&
&
v1
<
4
)
;
SkASSERT
(
v2
>
=
0
&
&
v2
<
4
)
;
SkASSERT
(
v3
>
=
0
&
&
v3
<
4
)
;
float
beta
=
1
.
f
-
alpha
;
lx
[
v0
]
=
alpha
*
lx
[
v0
]
+
beta
*
lx
[
v2
]
;
ly
[
v0
]
=
alpha
*
ly
[
v0
]
+
beta
*
ly
[
v2
]
;
lw
[
v0
]
=
alpha
*
lw
[
v0
]
+
beta
*
lw
[
v2
]
;
lx
[
v1
]
=
alpha
*
lx
[
v1
]
+
beta
*
lx
[
v3
]
;
ly
[
v1
]
=
alpha
*
ly
[
v1
]
+
beta
*
ly
[
v3
]
;
lw
[
v1
]
=
alpha
*
lw
[
v1
]
+
beta
*
lw
[
v3
]
;
}
static
bool
crop_rect_edge
(
const
SkRect
&
clipDevRect
int
v0
int
v1
int
v2
int
v3
float
x
[
4
]
float
y
[
4
]
float
lx
[
4
]
float
ly
[
4
]
float
lw
[
4
]
)
{
SkASSERT
(
v0
>
=
0
&
&
v0
<
4
)
;
SkASSERT
(
v1
>
=
0
&
&
v1
<
4
)
;
SkASSERT
(
v2
>
=
0
&
&
v2
<
4
)
;
SkASSERT
(
v3
>
=
0
&
&
v3
<
4
)
;
if
(
SkScalarNearlyEqual
(
x
[
v0
]
x
[
v1
]
)
)
{
if
(
x
[
v0
]
<
clipDevRect
.
fLeft
&
&
x
[
v2
]
>
=
clipDevRect
.
fLeft
)
{
if
(
lx
)
{
float
alpha
=
(
x
[
v2
]
-
clipDevRect
.
fLeft
)
/
(
x
[
v2
]
-
x
[
v0
]
)
;
interpolate_local
(
alpha
v0
v1
v2
v3
lx
ly
lw
)
;
}
x
[
v0
]
=
clipDevRect
.
fLeft
;
x
[
v1
]
=
clipDevRect
.
fLeft
;
return
true
;
}
else
if
(
x
[
v0
]
>
clipDevRect
.
fRight
&
&
x
[
v2
]
<
=
clipDevRect
.
fRight
)
{
if
(
lx
)
{
float
alpha
=
(
clipDevRect
.
fRight
-
x
[
v2
]
)
/
(
x
[
v0
]
-
x
[
v2
]
)
;
interpolate_local
(
alpha
v0
v1
v2
v3
lx
ly
lw
)
;
}
x
[
v0
]
=
clipDevRect
.
fRight
;
x
[
v1
]
=
clipDevRect
.
fRight
;
return
true
;
}
}
else
{
SkASSERT
(
SkScalarNearlyEqual
(
y
[
v0
]
y
[
v1
]
)
)
;
if
(
y
[
v0
]
<
clipDevRect
.
fTop
&
&
y
[
v2
]
>
=
clipDevRect
.
fTop
)
{
if
(
lx
)
{
float
alpha
=
(
y
[
v2
]
-
clipDevRect
.
fTop
)
/
(
y
[
v2
]
-
y
[
v0
]
)
;
interpolate_local
(
alpha
v0
v1
v2
v3
lx
ly
lw
)
;
}
y
[
v0
]
=
clipDevRect
.
fTop
;
y
[
v1
]
=
clipDevRect
.
fTop
;
return
true
;
}
else
if
(
y
[
v0
]
>
clipDevRect
.
fBottom
&
&
y
[
v2
]
<
=
clipDevRect
.
fBottom
)
{
if
(
lx
)
{
float
alpha
=
(
clipDevRect
.
fBottom
-
y
[
v2
]
)
/
(
y
[
v0
]
-
y
[
v2
]
)
;
interpolate_local
(
alpha
v0
v1
v2
v3
lx
ly
lw
)
;
}
y
[
v0
]
=
clipDevRect
.
fBottom
;
y
[
v1
]
=
clipDevRect
.
fBottom
;
return
true
;
}
}
return
false
;
}
static
GrQuadAAFlags
crop_rect
(
const
SkRect
&
clipDevRect
float
x
[
4
]
float
y
[
4
]
float
lx
[
4
]
float
ly
[
4
]
float
lw
[
4
]
)
{
GrQuadAAFlags
clipEdgeFlags
=
GrQuadAAFlags
:
:
kNone
;
if
(
crop_rect_edge
(
clipDevRect
0
1
2
3
x
y
lx
ly
lw
)
)
{
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kLeft
;
}
if
(
crop_rect_edge
(
clipDevRect
0
2
1
3
x
y
lx
ly
lw
)
)
{
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kTop
;
}
if
(
crop_rect_edge
(
clipDevRect
2
3
0
1
x
y
lx
ly
lw
)
)
{
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kRight
;
}
if
(
crop_rect_edge
(
clipDevRect
1
3
0
2
x
y
lx
ly
lw
)
)
{
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kBottom
;
}
return
clipEdgeFlags
;
}
static
GrQuadAAFlags
crop_simple_rect
(
const
SkRect
&
clipDevRect
float
x
[
4
]
float
y
[
4
]
float
lx
[
4
]
float
ly
[
4
]
)
{
GrQuadAAFlags
clipEdgeFlags
=
GrQuadAAFlags
:
:
kNone
;
const
SkScalar
dx
=
lx
?
(
lx
[
2
]
-
lx
[
0
]
)
/
(
x
[
2
]
-
x
[
0
]
)
:
0
.
f
;
const
SkScalar
dy
=
ly
?
(
ly
[
1
]
-
ly
[
0
]
)
/
(
y
[
1
]
-
y
[
0
]
)
:
0
.
f
;
if
(
clipDevRect
.
fLeft
>
x
[
0
]
)
{
if
(
lx
)
{
lx
[
0
]
+
=
(
clipDevRect
.
fLeft
-
x
[
0
]
)
*
dx
;
lx
[
1
]
=
lx
[
0
]
;
}
x
[
0
]
=
clipDevRect
.
fLeft
;
x
[
1
]
=
clipDevRect
.
fLeft
;
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kLeft
;
}
if
(
clipDevRect
.
fTop
>
y
[
0
]
)
{
if
(
ly
)
{
ly
[
0
]
+
=
(
clipDevRect
.
fTop
-
y
[
0
]
)
*
dy
;
ly
[
2
]
=
ly
[
0
]
;
}
y
[
0
]
=
clipDevRect
.
fTop
;
y
[
2
]
=
clipDevRect
.
fTop
;
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kTop
;
}
if
(
clipDevRect
.
fRight
<
x
[
2
]
)
{
if
(
lx
)
{
lx
[
2
]
-
=
(
x
[
2
]
-
clipDevRect
.
fRight
)
*
dx
;
lx
[
3
]
=
lx
[
2
]
;
}
x
[
2
]
=
clipDevRect
.
fRight
;
x
[
3
]
=
clipDevRect
.
fRight
;
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kRight
;
}
if
(
clipDevRect
.
fBottom
<
y
[
1
]
)
{
if
(
ly
)
{
ly
[
1
]
-
=
(
y
[
1
]
-
clipDevRect
.
fBottom
)
*
dy
;
ly
[
3
]
=
ly
[
1
]
;
}
y
[
1
]
=
clipDevRect
.
fBottom
;
y
[
3
]
=
clipDevRect
.
fBottom
;
clipEdgeFlags
|
=
GrQuadAAFlags
:
:
kBottom
;
}
return
clipEdgeFlags
;
}
static
bool
is_simple_rect
(
const
GrQuad
&
quad
)
{
if
(
quad
.
quadType
(
)
!
=
GrQuad
:
:
Type
:
:
kAxisAligned
)
{
return
false
;
}
return
(
(
quad
.
x
(
0
)
+
SK_ScalarNearlyZero
)
<
quad
.
x
(
2
)
)
&
&
(
(
quad
.
y
(
0
)
+
SK_ScalarNearlyZero
)
<
quad
.
y
(
1
)
)
;
}
static
bool
barycentric_coords
(
float
x0
float
y0
float
x1
float
y1
float
x2
float
y2
const
float4
&
testX
const
float4
&
testY
float4
*
u
float4
*
v
float4
*
w
)
{
static
constexpr
float
kCoordLimit
=
1e7f
;
float
scaleX
=
std
:
:
max
(
std
:
:
max
(
x0
x1
)
x2
)
-
std
:
:
min
(
std
:
:
min
(
x0
x1
)
x2
)
;
float
scaleY
=
std
:
:
max
(
std
:
:
max
(
y0
y1
)
y2
)
-
std
:
:
min
(
std
:
:
min
(
y0
y1
)
y2
)
;
if
(
scaleX
>
kCoordLimit
)
{
scaleX
=
kCoordLimit
/
scaleX
;
x0
*
=
scaleX
;
x1
*
=
scaleX
;
x2
*
=
scaleX
;
}
else
{
scaleX
=
1
.
f
;
}
if
(
scaleY
>
kCoordLimit
)
{
scaleY
=
kCoordLimit
/
scaleY
;
y0
*
=
scaleY
;
y1
*
=
scaleY
;
y2
*
=
scaleY
;
}
else
{
scaleY
=
1
.
f
;
}
float
v0x
=
x2
-
x0
;
float
v0y
=
y2
-
y0
;
float
v1x
=
x1
-
x0
;
float
v1y
=
y1
-
y0
;
float
dot00
=
v0x
*
v0x
+
v0y
*
v0y
;
float
dot01
=
v0x
*
v1x
+
v0y
*
v1y
;
float
dot11
=
v1x
*
v1x
+
v1y
*
v1y
;
float
invDenom
=
dot00
*
dot11
-
dot01
*
dot01
;
static
constexpr
SkScalar
kEmptyTriTolerance
=
SK_Scalar1
/
(
1
<
<
5
)
;
if
(
SkScalarNearlyZero
(
invDenom
kEmptyTriTolerance
)
)
{
return
false
;
}
else
{
invDenom
=
sk_ieee_float_divide
(
1
.
f
invDenom
)
;
}
float4
v2x
=
(
scaleX
*
testX
)
-
x0
;
float4
v2y
=
(
scaleY
*
testY
)
-
y0
;
float4
dot02
=
v0x
*
v2x
+
v0y
*
v2y
;
float4
dot12
=
v1x
*
v2x
+
v1y
*
v2y
;
*
u
=
(
dot11
*
dot02
-
dot01
*
dot12
)
*
invDenom
;
*
v
=
(
dot00
*
dot12
-
dot01
*
dot02
)
*
invDenom
;
*
w
=
1
.
f
-
*
u
-
*
v
;
return
true
;
}
static
mask4
inside_triangle
(
const
float4
&
u
const
float4
&
v
const
float4
&
w
)
{
return
(
(
u
>
=
0
.
f
)
&
(
u
<
=
1
.
f
)
)
&
(
(
v
>
=
0
.
f
)
&
(
v
<
=
1
.
f
)
)
&
(
(
w
>
=
0
.
f
)
&
(
w
<
=
1
.
f
)
)
;
}
SkRect
GrQuad
:
:
projectedBounds
(
)
const
{
float4
xs
=
this
-
>
x4f
(
)
;
float4
ys
=
this
-
>
y4f
(
)
;
float4
ws
=
this
-
>
w4f
(
)
;
mask4
clipW
=
ws
<
SkPathPriv
:
:
kW0PlaneDistance
;
if
(
any
(
clipW
)
)
{
float4
x2d
=
xs
/
ws
;
float4
y2d
=
ys
/
ws
;
SkRect
frontBounds
=
{
min
(
if_then_else
(
clipW
float4
(
SK_ScalarInfinity
)
x2d
)
)
min
(
if_then_else
(
clipW
float4
(
SK_ScalarInfinity
)
y2d
)
)
max
(
if_then_else
(
clipW
float4
(
SK_ScalarNegativeInfinity
)
x2d
)
)
max
(
if_then_else
(
clipW
float4
(
SK_ScalarNegativeInfinity
)
y2d
)
)
}
;
float4
t
=
(
SkPathPriv
:
:
kW0PlaneDistance
-
ws
)
/
(
next_ccw
(
ws
)
-
ws
)
;
x2d
=
(
t
*
next_ccw
(
xs
)
+
(
1
.
f
-
t
)
*
xs
)
/
SkPathPriv
:
:
kW0PlaneDistance
;
y2d
=
(
t
*
next_ccw
(
ys
)
+
(
1
.
f
-
t
)
*
ys
)
/
SkPathPriv
:
:
kW0PlaneDistance
;
clipW
=
clipW
^
(
next_ccw
(
ws
)
<
SkPathPriv
:
:
kW0PlaneDistance
)
;
return
{
min
(
if_then_else
(
clipW
x2d
float4
(
frontBounds
.
fLeft
)
)
)
min
(
if_then_else
(
clipW
y2d
float4
(
frontBounds
.
fTop
)
)
)
max
(
if_then_else
(
clipW
x2d
float4
(
frontBounds
.
fRight
)
)
)
max
(
if_then_else
(
clipW
y2d
float4
(
frontBounds
.
fBottom
)
)
)
}
;
}
else
{
ws
=
1
.
f
/
ws
;
float4
x2d
=
xs
*
ws
;
float4
y2d
=
ys
*
ws
;
return
{
min
(
x2d
)
min
(
y2d
)
max
(
x2d
)
max
(
y2d
)
}
;
}
}
namespace
GrQuadUtils
{
void
ResolveAAType
(
GrAAType
requestedAAType
GrQuadAAFlags
requestedEdgeFlags
const
GrQuad
&
quad
GrAAType
*
outAAType
GrQuadAAFlags
*
outEdgeFlags
)
{
*
outAAType
=
requestedAAType
;
*
outEdgeFlags
=
requestedEdgeFlags
;
switch
(
requestedAAType
)
{
case
GrAAType
:
:
kCoverage
:
if
(
requestedEdgeFlags
=
=
GrQuadAAFlags
:
:
kNone
)
{
*
outAAType
=
GrAAType
:
:
kNone
;
}
else
if
(
quad
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
&
&
!
quad
.
aaHasEffectOnRect
(
requestedEdgeFlags
)
)
{
*
outAAType
=
GrAAType
:
:
kNone
;
*
outEdgeFlags
=
GrQuadAAFlags
:
:
kNone
;
}
break
;
case
GrAAType
:
:
kNone
:
*
outEdgeFlags
=
GrQuadAAFlags
:
:
kNone
;
break
;
case
GrAAType
:
:
kMSAA
:
*
outEdgeFlags
=
GrQuadAAFlags
:
:
kAll
;
break
;
}
}
int
ClipToW0
(
DrawQuad
*
quad
DrawQuad
*
extraVertices
)
{
using
Vertices
=
TessellationHelper
:
:
Vertices
;
SkASSERT
(
quad
&
&
extraVertices
)
;
if
(
quad
-
>
fDevice
.
quadType
(
)
<
GrQuad
:
:
Type
:
:
kPerspective
)
{
return
1
;
}
mask4
validW
=
quad
-
>
fDevice
.
w4f
(
)
>
=
SkPathPriv
:
:
kW0PlaneDistance
;
if
(
all
(
validW
)
)
{
return
1
;
}
else
if
(
!
any
(
validW
)
)
{
return
0
;
}
GrQuad
:
:
Type
localType
=
quad
-
>
fLocal
.
quadType
(
)
;
if
(
localType
<
GrQuad
:
:
Type
:
:
kGeneral
)
{
localType
=
GrQuad
:
:
Type
:
:
kGeneral
;
}
Vertices
v
;
v
.
reset
(
quad
-
>
fDevice
&
quad
-
>
fLocal
)
;
int
clipCount
=
(
validW
[
0
]
?
0
:
1
)
+
(
validW
[
1
]
?
0
:
1
)
+
(
validW
[
2
]
?
0
:
1
)
+
(
validW
[
3
]
?
0
:
1
)
;
SkASSERT
(
clipCount
>
=
1
&
&
clipCount
<
=
3
)
;
float4
t
=
(
SkPathPriv
:
:
kW0PlaneDistance
-
v
.
fW
)
/
(
next_ccw
(
v
.
fW
)
-
v
.
fW
)
;
Vertices
clip
;
clip
.
fX
=
(
t
*
next_ccw
(
v
.
fX
)
+
(
1
.
f
-
t
)
*
v
.
fX
)
;
clip
.
fY
=
(
t
*
next_ccw
(
v
.
fY
)
+
(
1
.
f
-
t
)
*
v
.
fY
)
;
clip
.
fW
=
SkPathPriv
:
:
kW0PlaneDistance
;
clip
.
fU
=
(
t
*
next_ccw
(
v
.
fU
)
+
(
1
.
f
-
t
)
*
v
.
fU
)
;
clip
.
fV
=
(
t
*
next_ccw
(
v
.
fV
)
+
(
1
.
f
-
t
)
*
v
.
fV
)
;
clip
.
fR
=
(
t
*
next_ccw
(
v
.
fR
)
+
(
1
.
f
-
t
)
*
v
.
fR
)
;
mask4
ccwValid
=
next_ccw
(
v
.
fW
)
>
=
SkPathPriv
:
:
kW0PlaneDistance
;
mask4
cwValid
=
next_cw
(
v
.
fW
)
>
=
SkPathPriv
:
:
kW0PlaneDistance
;
if
(
clipCount
!
=
1
)
{
SkASSERT
(
clipCount
=
=
2
|
|
clipCount
=
=
3
)
;
v
.
fX
=
if_then_else
(
validW
v
.
fX
if_then_else
(
(
!
ccwValid
)
&
(
!
cwValid
)
next_ccw
(
clip
.
fX
)
if_then_else
(
ccwValid
clip
.
fX
next_cw
(
clip
.
fX
)
)
)
)
;
v
.
fY
=
if_then_else
(
validW
v
.
fY
if_then_else
(
(
!
ccwValid
)
&
(
!
cwValid
)
next_ccw
(
clip
.
fY
)
if_then_else
(
ccwValid
clip
.
fY
next_cw
(
clip
.
fY
)
)
)
)
;
v
.
fW
=
if_then_else
(
validW
v
.
fW
clip
.
fW
)
;
v
.
fU
=
if_then_else
(
validW
v
.
fU
if_then_else
(
(
!
ccwValid
)
&
(
!
cwValid
)
next_ccw
(
clip
.
fU
)
if_then_else
(
ccwValid
clip
.
fU
next_cw
(
clip
.
fU
)
)
)
)
;
v
.
fV
=
if_then_else
(
validW
v
.
fV
if_then_else
(
(
!
ccwValid
)
&
(
!
cwValid
)
next_ccw
(
clip
.
fV
)
if_then_else
(
ccwValid
clip
.
fV
next_cw
(
clip
.
fV
)
)
)
)
;
v
.
fR
=
if_then_else
(
validW
v
.
fR
if_then_else
(
(
!
ccwValid
)
&
(
!
cwValid
)
next_ccw
(
clip
.
fR
)
if_then_else
(
ccwValid
clip
.
fR
next_cw
(
clip
.
fR
)
)
)
)
;
v
.
asGrQuads
(
&
quad
-
>
fDevice
GrQuad
:
:
Type
:
:
kPerspective
&
quad
-
>
fLocal
localType
)
;
return
1
;
}
else
{
Vertices
mid
;
mid
.
fX
=
0
.
5f
*
(
v
.
fX
+
next_ccw
(
v
.
fX
)
)
;
mid
.
fY
=
0
.
5f
*
(
v
.
fY
+
next_ccw
(
v
.
fY
)
)
;
mid
.
fW
=
0
.
5f
*
(
v
.
fW
+
next_ccw
(
v
.
fW
)
)
;
mid
.
fU
=
0
.
5f
*
(
v
.
fU
+
next_ccw
(
v
.
fU
)
)
;
mid
.
fV
=
0
.
5f
*
(
v
.
fV
+
next_ccw
(
v
.
fV
)
)
;
mid
.
fR
=
0
.
5f
*
(
v
.
fR
+
next_ccw
(
v
.
fR
)
)
;
Vertices
v2
;
v2
.
fUVRCount
=
v
.
fUVRCount
;
v2
.
fX
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fX
if_then_else
(
cwValid
next_cw
(
mid
.
fX
)
v
.
fX
)
)
;
v2
.
fY
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fY
if_then_else
(
cwValid
next_cw
(
mid
.
fY
)
v
.
fY
)
)
;
v2
.
fW
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fW
if_then_else
(
cwValid
next_cw
(
mid
.
fW
)
v
.
fW
)
)
;
v2
.
fU
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fU
if_then_else
(
cwValid
next_cw
(
mid
.
fU
)
v
.
fU
)
)
;
v2
.
fV
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fV
if_then_else
(
cwValid
next_cw
(
mid
.
fV
)
v
.
fV
)
)
;
v2
.
fR
=
if_then_else
(
(
!
validW
)
|
(
!
ccwValid
)
clip
.
fR
if_then_else
(
cwValid
next_cw
(
mid
.
fR
)
v
.
fR
)
)
;
GrQuadAAFlags
v2EdgeFlag
=
(
!
validW
[
0
]
?
GrQuadAAFlags
:
:
kRight
:
(
!
validW
[
1
]
?
GrQuadAAFlags
:
:
kTop
:
(
!
validW
[
2
]
?
GrQuadAAFlags
:
:
kBottom
:
GrQuadAAFlags
:
:
kLeft
)
)
)
;
extraVertices
-
>
fEdgeFlags
=
quad
-
>
fEdgeFlags
&
~
v2EdgeFlag
;
v
.
fX
=
if_then_else
(
!
validW
next_cw
(
clip
.
fX
)
if_then_else
(
!
cwValid
mid
.
fX
v
.
fX
)
)
;
v
.
fY
=
if_then_else
(
!
validW
next_cw
(
clip
.
fY
)
if_then_else
(
!
cwValid
mid
.
fY
v
.
fY
)
)
;
v
.
fW
=
if_then_else
(
!
validW
clip
.
fW
if_then_else
(
!
cwValid
mid
.
fW
v
.
fW
)
)
;
v
.
fU
=
if_then_else
(
!
validW
next_cw
(
clip
.
fU
)
if_then_else
(
!
cwValid
mid
.
fU
v
.
fU
)
)
;
v
.
fV
=
if_then_else
(
!
validW
next_cw
(
clip
.
fV
)
if_then_else
(
!
cwValid
mid
.
fV
v
.
fV
)
)
;
v
.
fR
=
if_then_else
(
!
validW
next_cw
(
clip
.
fR
)
if_then_else
(
!
cwValid
mid
.
fR
v
.
fR
)
)
;
GrQuadAAFlags
v1EdgeFlag
=
(
!
validW
[
0
]
?
GrQuadAAFlags
:
:
kLeft
:
(
!
validW
[
1
]
?
GrQuadAAFlags
:
:
kBottom
:
(
!
validW
[
2
]
?
GrQuadAAFlags
:
:
kTop
:
GrQuadAAFlags
:
:
kRight
)
)
)
;
v
.
asGrQuads
(
&
quad
-
>
fDevice
GrQuad
:
:
Type
:
:
kPerspective
&
quad
-
>
fLocal
localType
)
;
quad
-
>
fEdgeFlags
&
=
~
v1EdgeFlag
;
v2
.
asGrQuads
(
&
extraVertices
-
>
fDevice
GrQuad
:
:
Type
:
:
kPerspective
&
extraVertices
-
>
fLocal
localType
)
;
return
2
;
}
}
bool
CropToRect
(
const
SkRect
&
cropRect
GrAA
cropAA
DrawQuad
*
quad
bool
computeLocal
)
{
SkASSERT
(
quad
-
>
fDevice
.
isFinite
(
)
)
;
if
(
quad
-
>
fDevice
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
)
{
GrQuadAAFlags
clippedEdges
;
if
(
computeLocal
)
{
if
(
is_simple_rect
(
quad
-
>
fDevice
)
&
&
is_simple_rect
(
quad
-
>
fLocal
)
)
{
clippedEdges
=
crop_simple_rect
(
cropRect
quad
-
>
fDevice
.
xs
(
)
quad
-
>
fDevice
.
ys
(
)
quad
-
>
fLocal
.
xs
(
)
quad
-
>
fLocal
.
ys
(
)
)
;
}
else
{
clippedEdges
=
crop_rect
(
cropRect
quad
-
>
fDevice
.
xs
(
)
quad
-
>
fDevice
.
ys
(
)
quad
-
>
fLocal
.
xs
(
)
quad
-
>
fLocal
.
ys
(
)
quad
-
>
fLocal
.
ws
(
)
)
;
}
}
else
{
if
(
is_simple_rect
(
quad
-
>
fDevice
)
)
{
clippedEdges
=
crop_simple_rect
(
cropRect
quad
-
>
fDevice
.
xs
(
)
quad
-
>
fDevice
.
ys
(
)
nullptr
nullptr
)
;
}
else
{
clippedEdges
=
crop_rect
(
cropRect
quad
-
>
fDevice
.
xs
(
)
quad
-
>
fDevice
.
ys
(
)
nullptr
nullptr
nullptr
)
;
}
}
if
(
cropAA
=
=
GrAA
:
:
kYes
)
{
quad
-
>
fEdgeFlags
|
=
clippedEdges
;
}
else
{
quad
-
>
fEdgeFlags
&
=
~
clippedEdges
;
}
return
true
;
}
if
(
computeLocal
|
|
quad
-
>
fDevice
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
return
false
;
}
float4
devX
=
quad
-
>
fDevice
.
x4f
(
)
;
float4
devY
=
quad
-
>
fDevice
.
y4f
(
)
;
float4
clipX
=
{
cropRect
.
fLeft
cropRect
.
fLeft
cropRect
.
fRight
cropRect
.
fRight
}
;
float4
clipY
=
{
cropRect
.
fTop
cropRect
.
fBottom
cropRect
.
fTop
cropRect
.
fBottom
}
;
float4
u1
v1
w1
;
float4
u2
v2
w2
;
if
(
!
barycentric_coords
(
devX
[
0
]
devY
[
0
]
devX
[
1
]
devY
[
1
]
devX
[
2
]
devY
[
2
]
clipX
clipY
&
u1
&
v1
&
w1
)
|
|
!
barycentric_coords
(
devX
[
1
]
devY
[
1
]
devX
[
3
]
devY
[
3
]
devX
[
2
]
devY
[
2
]
clipX
clipY
&
u2
&
v2
&
w2
)
)
{
return
false
;
}
mask4
inTri1
=
inside_triangle
(
u1
v1
w1
)
;
mask4
inTri2
=
inside_triangle
(
u2
v2
w2
)
;
if
(
all
(
inTri1
|
inTri2
)
)
{
clipX
.
store
(
quad
-
>
fDevice
.
xs
(
)
)
;
clipY
.
store
(
quad
-
>
fDevice
.
ys
(
)
)
;
quad
-
>
fDevice
.
setQuadType
(
GrQuad
:
:
Type
:
:
kAxisAligned
)
;
quad
-
>
fEdgeFlags
=
cropAA
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
;
return
true
;
}
return
false
;
}
bool
WillUseHairline
(
const
GrQuad
&
quad
GrAAType
aaType
GrQuadAAFlags
edgeFlags
)
{
if
(
aaType
!
=
GrAAType
:
:
kCoverage
|
|
edgeFlags
!
=
GrQuadAAFlags
:
:
kAll
)
{
return
false
;
}
if
(
quad
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
)
{
float
d
=
std
:
:
min
(
std
:
:
abs
(
quad
.
x
(
3
)
-
quad
.
x
(
0
)
)
std
:
:
abs
(
quad
.
y
(
3
)
-
quad
.
y
(
0
)
)
)
;
return
d
<
1
.
f
;
}
else
{
TessellationHelper
helper
;
helper
.
reset
(
quad
nullptr
)
;
return
helper
.
isSubpixel
(
)
;
}
}
void
TessellationHelper
:
:
EdgeVectors
:
:
reset
(
const
skvx
:
:
Vec
<
4
float
>
&
xs
const
skvx
:
:
Vec
<
4
float
>
&
ys
const
skvx
:
:
Vec
<
4
float
>
&
ws
GrQuad
:
:
Type
quadType
)
{
if
(
quadType
=
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
float4
iw
=
1
.
f
/
ws
;
fX2D
=
xs
*
iw
;
fY2D
=
ys
*
iw
;
}
else
{
fX2D
=
xs
;
fY2D
=
ys
;
}
fDX
=
next_ccw
(
fX2D
)
-
fX2D
;
fDY
=
next_ccw
(
fY2D
)
-
fY2D
;
fInvLengths
=
1
.
f
/
sqrt
(
fDX
*
fDX
+
fDY
*
fDY
)
;
fDX
*
=
fInvLengths
;
fDY
*
=
fInvLengths
;
if
(
quadType
<
=
GrQuad
:
:
Type
:
:
kRectilinear
)
{
fCosTheta
=
0
.
f
;
fInvSinTheta
=
1
.
f
;
}
else
{
fCosTheta
=
fDX
*
next_cw
(
fDX
)
+
fDY
*
next_cw
(
fDY
)
;
fInvSinTheta
=
1
.
f
/
sqrt
(
1
.
f
-
fCosTheta
*
fCosTheta
)
;
}
}
void
TessellationHelper
:
:
EdgeEquations
:
:
reset
(
const
EdgeVectors
&
edgeVectors
)
{
float4
dx
=
edgeVectors
.
fDX
;
float4
dy
=
edgeVectors
.
fDY
;
correct_bad_edges
(
edgeVectors
.
fInvLengths
>
=
kInvDistTolerance
&
dx
&
dy
nullptr
)
;
float4
c
=
dx
*
edgeVectors
.
fY2D
-
dy
*
edgeVectors
.
fX2D
;
float4
test
=
dy
*
next_cw
(
edgeVectors
.
fX2D
)
+
(
-
dx
*
next_cw
(
edgeVectors
.
fY2D
)
+
c
)
;
if
(
any
(
test
<
-
kDistTolerance
)
)
{
fA
=
-
dy
;
fB
=
dx
;
fC
=
-
c
;
}
else
{
fA
=
dy
;
fB
=
-
dx
;
fC
=
c
;
}
}
float4
TessellationHelper
:
:
EdgeEquations
:
:
estimateCoverage
(
const
float4
&
x2d
const
float4
&
y2d
)
const
{
float4
d0
=
fA
[
0
]
*
x2d
+
(
fB
[
0
]
*
y2d
+
fC
[
0
]
)
;
float4
d1
=
fA
[
1
]
*
x2d
+
(
fB
[
1
]
*
y2d
+
fC
[
1
]
)
;
float4
d2
=
fA
[
2
]
*
x2d
+
(
fB
[
2
]
*
y2d
+
fC
[
2
]
)
;
float4
d3
=
fA
[
3
]
*
x2d
+
(
fB
[
3
]
*
y2d
+
fC
[
3
]
)
;
float4
w
=
max
(
0
.
f
min
(
1
.
f
d0
+
d3
)
)
;
float4
h
=
max
(
0
.
f
min
(
1
.
f
d1
+
d2
)
)
;
return
w
*
h
;
}
bool
TessellationHelper
:
:
EdgeEquations
:
:
isSubpixel
(
const
float4
&
x2d
const
float4
&
y2d
)
const
{
float4
d
=
min
(
x2d
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
fA
)
+
y2d
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
fB
)
+
skvx
:
:
shuffle
<
1
2
1
2
>
(
fC
)
x2d
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
fA
)
+
y2d
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
fB
)
+
skvx
:
:
shuffle
<
3
3
0
0
>
(
fC
)
)
;
return
all
(
d
<
1
.
f
)
;
}
int
TessellationHelper
:
:
EdgeEquations
:
:
computeDegenerateQuad
(
const
float4
&
signedEdgeDistances
float4
*
x2d
float4
*
y2d
mask4
*
aaMask
)
const
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
float4
d
=
(
*
x2d
)
*
fA
[
i
]
+
(
*
y2d
)
*
fB
[
i
]
+
fC
[
i
]
;
if
(
all
(
abs
(
d
)
<
kDistTolerance
)
)
{
*
aaMask
=
mask4
(
0
)
;
return
4
;
}
}
*
aaMask
=
signedEdgeDistances
!
=
0
.
f
;
float4
oc
=
fC
+
signedEdgeDistances
;
float4
denom
=
fA
*
next_cw
(
fB
)
-
fB
*
next_cw
(
fA
)
;
float4
px
=
(
fB
*
next_cw
(
oc
)
-
oc
*
next_cw
(
fB
)
)
/
denom
;
float4
py
=
(
oc
*
next_cw
(
fA
)
-
fA
*
next_cw
(
oc
)
)
/
denom
;
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
px
&
py
nullptr
)
;
float4
dists1
=
px
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
fA
)
+
py
*
skvx
:
:
shuffle
<
3
3
0
0
>
(
fB
)
+
skvx
:
:
shuffle
<
3
3
0
0
>
(
oc
)
;
float4
dists2
=
px
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
fA
)
+
py
*
skvx
:
:
shuffle
<
1
2
1
2
>
(
fB
)
+
skvx
:
:
shuffle
<
1
2
1
2
>
(
oc
)
;
mask4
d1v0
=
dists1
<
kDistTolerance
;
mask4
d2v0
=
dists2
<
kDistTolerance
;
mask4
d1And2
=
d1v0
&
d2v0
;
mask4
d1Or2
=
d1v0
|
d2v0
;
if
(
!
any
(
d1Or2
)
)
{
*
x2d
=
px
;
*
y2d
=
py
;
return
4
;
}
else
if
(
any
(
d1And2
)
)
{
SkPoint
center
=
{
0
.
25f
*
(
(
*
x2d
)
[
0
]
+
(
*
x2d
)
[
1
]
+
(
*
x2d
)
[
2
]
+
(
*
x2d
)
[
3
]
)
0
.
25f
*
(
(
*
y2d
)
[
0
]
+
(
*
y2d
)
[
1
]
+
(
*
y2d
)
[
2
]
+
(
*
y2d
)
[
3
]
)
}
;
*
x2d
=
center
.
fX
;
*
y2d
=
center
.
fY
;
*
aaMask
=
any
(
*
aaMask
)
;
return
1
;
}
else
if
(
all
(
d1Or2
)
)
{
if
(
dists1
[
2
]
<
kDistTolerance
&
&
dists1
[
3
]
<
kDistTolerance
)
{
*
x2d
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
1
>
(
px
)
+
skvx
:
:
shuffle
<
2
3
2
3
>
(
px
)
)
;
*
y2d
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
1
>
(
py
)
+
skvx
:
:
shuffle
<
2
3
2
3
>
(
py
)
)
;
*
aaMask
=
*
aaMask
|
mask4
(
{
1
0
0
1
}
)
;
}
else
{
*
x2d
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
0
2
2
>
(
px
)
+
skvx
:
:
shuffle
<
1
1
3
3
>
(
px
)
)
;
*
y2d
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
0
2
2
>
(
py
)
+
skvx
:
:
shuffle
<
1
1
3
3
>
(
py
)
)
;
*
aaMask
=
*
aaMask
|
mask4
(
{
0
1
1
0
}
)
;
}
return
2
;
}
else
{
using
V2f
=
skvx
:
:
Vec
<
2
float
>
;
V2f
eDenom
=
skvx
:
:
shuffle
<
0
1
>
(
fA
)
*
skvx
:
:
shuffle
<
3
2
>
(
fB
)
-
skvx
:
:
shuffle
<
0
1
>
(
fB
)
*
skvx
:
:
shuffle
<
3
2
>
(
fA
)
;
V2f
ex
=
(
skvx
:
:
shuffle
<
0
1
>
(
fB
)
*
skvx
:
:
shuffle
<
3
2
>
(
oc
)
-
skvx
:
:
shuffle
<
0
1
>
(
oc
)
*
skvx
:
:
shuffle
<
3
2
>
(
fB
)
)
/
eDenom
;
V2f
ey
=
(
skvx
:
:
shuffle
<
0
1
>
(
oc
)
*
skvx
:
:
shuffle
<
3
2
>
(
fA
)
-
skvx
:
:
shuffle
<
0
1
>
(
fA
)
*
skvx
:
:
shuffle
<
3
2
>
(
oc
)
)
/
eDenom
;
float4
avgX
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
2
>
(
px
)
+
skvx
:
:
shuffle
<
2
3
1
3
>
(
px
)
)
;
float4
avgY
=
0
.
5f
*
(
skvx
:
:
shuffle
<
0
1
0
2
>
(
py
)
+
skvx
:
:
shuffle
<
2
3
1
3
>
(
py
)
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
dists1
[
i
]
<
-
kDistTolerance
&
&
std
:
:
abs
(
eDenom
[
0
]
)
>
kTolerance
)
{
px
[
i
]
=
ex
[
0
]
;
py
[
i
]
=
ey
[
0
]
;
}
else
if
(
d1v0
[
i
]
)
{
px
[
i
]
=
avgX
[
i
%
2
]
;
py
[
i
]
=
avgY
[
i
%
2
]
;
}
else
if
(
dists2
[
i
]
<
-
kDistTolerance
&
&
std
:
:
abs
(
eDenom
[
1
]
)
>
kTolerance
)
{
px
[
i
]
=
ex
[
1
]
;
py
[
i
]
=
ey
[
1
]
;
}
else
if
(
d2v0
[
i
]
)
{
px
[
i
]
=
avgX
[
i
/
2
+
2
]
;
py
[
i
]
=
avgY
[
i
/
2
+
2
]
;
}
}
*
aaMask
=
*
aaMask
|
(
d1Or2
&
next_cw
(
*
aaMask
)
)
|
(
next_ccw
(
d1Or2
)
&
next_ccw
(
*
aaMask
)
)
;
*
x2d
=
px
;
*
y2d
=
py
;
return
3
;
}
}
void
TessellationHelper
:
:
OutsetRequest
:
:
reset
(
const
EdgeVectors
&
edgeVectors
GrQuad
:
:
Type
quadType
const
skvx
:
:
Vec
<
4
float
>
&
edgeDistances
)
{
fEdgeDistances
=
edgeDistances
;
if
(
quadType
<
=
GrQuad
:
:
Type
:
:
kRectilinear
)
{
fOutsetDegenerate
=
false
;
float
widthChange
=
edgeDistances
[
0
]
+
edgeDistances
[
3
]
;
float
heightChange
=
edgeDistances
[
1
]
+
edgeDistances
[
2
]
;
fInsetDegenerate
=
(
widthChange
>
0
.
f
&
&
edgeVectors
.
fInvLengths
[
1
]
>
1
.
f
/
widthChange
)
|
|
(
heightChange
>
0
.
f
&
&
edgeVectors
.
fInvLengths
[
0
]
>
1
.
f
/
heightChange
)
;
}
else
if
(
any
(
edgeVectors
.
fInvLengths
>
=
kInvDistTolerance
)
)
{
fOutsetDegenerate
=
true
;
fInsetDegenerate
=
true
;
}
else
{
if
(
any
(
abs
(
edgeVectors
.
fCosTheta
)
>
=
0
.
9f
)
)
{
fOutsetDegenerate
=
true
;
fInsetDegenerate
=
true
;
}
else
{
float4
halfTanTheta
=
-
edgeVectors
.
fCosTheta
*
edgeVectors
.
fInvSinTheta
;
float4
edgeAdjust
=
edgeDistances
*
(
halfTanTheta
+
next_ccw
(
halfTanTheta
)
)
+
next_ccw
(
edgeDistances
)
*
next_ccw
(
edgeVectors
.
fInvSinTheta
)
+
next_cw
(
edgeDistances
)
*
edgeVectors
.
fInvSinTheta
;
float4
threshold
=
0
.
1f
-
(
1
.
f
/
edgeVectors
.
fInvLengths
)
;
fOutsetDegenerate
=
any
(
edgeAdjust
<
threshold
)
;
fInsetDegenerate
=
any
(
edgeAdjust
>
-
threshold
)
;
}
}
}
void
TessellationHelper
:
:
Vertices
:
:
reset
(
const
GrQuad
&
deviceQuad
const
GrQuad
*
localQuad
)
{
fX
=
deviceQuad
.
x4f
(
)
;
fY
=
deviceQuad
.
y4f
(
)
;
fW
=
deviceQuad
.
w4f
(
)
;
if
(
localQuad
)
{
fU
=
localQuad
-
>
x4f
(
)
;
fV
=
localQuad
-
>
y4f
(
)
;
fR
=
localQuad
-
>
w4f
(
)
;
fUVRCount
=
localQuad
-
>
hasPerspective
(
)
?
3
:
2
;
}
else
{
fUVRCount
=
0
;
}
}
void
TessellationHelper
:
:
Vertices
:
:
asGrQuads
(
GrQuad
*
deviceOut
GrQuad
:
:
Type
deviceType
GrQuad
*
localOut
GrQuad
:
:
Type
localType
)
const
{
SkASSERT
(
deviceOut
)
;
SkASSERT
(
fUVRCount
=
=
0
|
|
localOut
)
;
fX
.
store
(
deviceOut
-
>
xs
(
)
)
;
fY
.
store
(
deviceOut
-
>
ys
(
)
)
;
if
(
deviceType
=
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
fW
.
store
(
deviceOut
-
>
ws
(
)
)
;
}
deviceOut
-
>
setQuadType
(
deviceType
)
;
if
(
fUVRCount
>
0
)
{
fU
.
store
(
localOut
-
>
xs
(
)
)
;
fV
.
store
(
localOut
-
>
ys
(
)
)
;
if
(
fUVRCount
=
=
3
)
{
fR
.
store
(
localOut
-
>
ws
(
)
)
;
}
localOut
-
>
setQuadType
(
localType
)
;
}
}
void
TessellationHelper
:
:
Vertices
:
:
moveAlong
(
const
EdgeVectors
&
edgeVectors
const
float4
&
signedEdgeDistances
)
{
SkASSERT
(
all
(
abs
(
edgeVectors
.
fCosTheta
)
<
0
.
9f
)
|
|
any
(
edgeVectors
.
fCosTheta
!
=
edgeVectors
.
fCosTheta
)
)
;
float4
signedOutsets
=
-
edgeVectors
.
fInvSinTheta
*
next_cw
(
signedEdgeDistances
)
;
float4
signedOutsetsCW
=
edgeVectors
.
fInvSinTheta
*
signedEdgeDistances
;
fX
+
=
signedOutsetsCW
*
next_cw
(
edgeVectors
.
fDX
)
+
signedOutsets
*
edgeVectors
.
fDX
;
fY
+
=
signedOutsetsCW
*
next_cw
(
edgeVectors
.
fDY
)
+
signedOutsets
*
edgeVectors
.
fDY
;
if
(
fUVRCount
>
0
)
{
signedOutsets
*
=
edgeVectors
.
fInvLengths
;
signedOutsetsCW
*
=
next_cw
(
edgeVectors
.
fInvLengths
)
;
float4
du
=
next_ccw
(
fU
)
-
fU
;
float4
dv
=
next_ccw
(
fV
)
-
fV
;
fU
+
=
signedOutsetsCW
*
next_cw
(
du
)
+
signedOutsets
*
du
;
fV
+
=
signedOutsetsCW
*
next_cw
(
dv
)
+
signedOutsets
*
dv
;
if
(
fUVRCount
=
=
3
)
{
float4
dr
=
next_ccw
(
fR
)
-
fR
;
fR
+
=
signedOutsetsCW
*
next_cw
(
dr
)
+
signedOutsets
*
dr
;
}
}
}
void
TessellationHelper
:
:
Vertices
:
:
moveTo
(
const
float4
&
x2d
const
float4
&
y2d
const
mask4
&
mask
)
{
float4
e1x
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fX
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fX
)
;
float4
e1y
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fY
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fY
)
;
float4
e1w
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fW
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fW
)
;
mask4
e1Bad
=
e1x
*
e1x
+
e1y
*
e1y
<
kDist2Tolerance
;
correct_bad_edges
(
e1Bad
&
e1x
&
e1y
&
e1w
)
;
float4
e2x
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fX
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fX
)
;
float4
e2y
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fY
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fY
)
;
float4
e2w
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fW
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fW
)
;
mask4
e2Bad
=
e2x
*
e2x
+
e2y
*
e2y
<
kDist2Tolerance
;
correct_bad_edges
(
e2Bad
&
e2x
&
e2y
&
e2w
)
;
float4
c1x
=
e1w
*
x2d
-
e1x
;
float4
c1y
=
e1w
*
y2d
-
e1y
;
float4
c2x
=
e2w
*
x2d
-
e2x
;
float4
c2y
=
e2w
*
y2d
-
e2y
;
float4
c3x
=
fW
*
x2d
-
fX
;
float4
c3y
=
fW
*
y2d
-
fY
;
float4
a
b
denom
;
if
(
all
(
mask
)
)
{
denom
=
c1x
*
c2y
-
c2x
*
c1y
;
a
=
(
c2x
*
c3y
-
c3x
*
c2y
)
/
denom
;
b
=
(
c3x
*
c1y
-
c1x
*
c3y
)
/
denom
;
}
else
{
mask4
aMask
=
skvx
:
:
shuffle
<
0
0
3
3
>
(
mask
)
;
mask4
bMask
=
skvx
:
:
shuffle
<
2
1
2
1
>
(
mask
)
;
mask4
useC1x
=
abs
(
c1x
)
>
abs
(
c1y
)
;
mask4
useC2x
=
abs
(
c2x
)
>
abs
(
c2y
)
;
denom
=
if_then_else
(
aMask
if_then_else
(
bMask
c1x
*
c2y
-
c2x
*
c1y
if_then_else
(
useC1x
c1x
c1y
)
)
if_then_else
(
bMask
if_then_else
(
useC2x
c2x
c2y
)
float4
(
1
.
f
)
)
)
;
a
=
if_then_else
(
aMask
if_then_else
(
bMask
c2x
*
c3y
-
c3x
*
c2y
if_then_else
(
useC1x
-
c3x
-
c3y
)
)
float4
(
0
.
f
)
)
/
denom
;
b
=
if_then_else
(
bMask
if_then_else
(
aMask
c3x
*
c1y
-
c1x
*
c3y
if_then_else
(
useC2x
-
c3x
-
c3y
)
)
float4
(
0
.
f
)
)
/
denom
;
}
fX
+
=
a
*
e1x
+
b
*
e2x
;
fY
+
=
a
*
e1y
+
b
*
e2y
;
fW
+
=
a
*
e1w
+
b
*
e2w
;
if
(
any
(
fW
<
0
.
f
)
)
{
float4
scale
=
if_then_else
(
fW
<
0
.
f
float4
(
-
1
.
f
)
float4
(
1
.
f
)
)
;
fX
*
=
scale
;
fY
*
=
scale
;
fW
*
=
scale
;
}
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
fX
&
fY
&
fW
)
;
if
(
fUVRCount
>
0
)
{
float4
e1u
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fU
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fU
)
;
float4
e1v
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fV
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fV
)
;
float4
e1r
=
skvx
:
:
shuffle
<
2
3
2
3
>
(
fR
)
-
skvx
:
:
shuffle
<
0
1
0
1
>
(
fR
)
;
correct_bad_edges
(
e1Bad
&
e1u
&
e1v
&
e1r
)
;
float4
e2u
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fU
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fU
)
;
float4
e2v
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fV
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fV
)
;
float4
e2r
=
skvx
:
:
shuffle
<
1
1
3
3
>
(
fR
)
-
skvx
:
:
shuffle
<
0
0
2
2
>
(
fR
)
;
correct_bad_edges
(
e2Bad
&
e2u
&
e2v
&
e2r
)
;
fU
+
=
a
*
e1u
+
b
*
e2u
;
fV
+
=
a
*
e1v
+
b
*
e2v
;
if
(
fUVRCount
=
=
3
)
{
fR
+
=
a
*
e1r
+
b
*
e2r
;
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
fU
&
fV
&
fR
)
;
}
else
{
correct_bad_coords
(
abs
(
denom
)
<
kTolerance
&
fU
&
fV
nullptr
)
;
}
}
}
void
TessellationHelper
:
:
reset
(
const
GrQuad
&
deviceQuad
const
GrQuad
*
localQuad
)
{
fDeviceType
=
deviceQuad
.
quadType
(
)
;
fLocalType
=
localQuad
?
localQuad
-
>
quadType
(
)
:
GrQuad
:
:
Type
:
:
kAxisAligned
;
fOutsetRequestValid
=
false
;
fEdgeEquationsValid
=
false
;
fOriginal
.
reset
(
deviceQuad
localQuad
)
;
fEdgeVectors
.
reset
(
fOriginal
.
fX
fOriginal
.
fY
fOriginal
.
fW
fDeviceType
)
;
fVerticesValid
=
true
;
}
float4
TessellationHelper
:
:
inset
(
const
skvx
:
:
Vec
<
4
float
>
&
edgeDistances
GrQuad
*
deviceInset
GrQuad
*
localInset
)
{
SkASSERT
(
fVerticesValid
)
;
Vertices
inset
=
fOriginal
;
const
OutsetRequest
&
request
=
this
-
>
getOutsetRequest
(
edgeDistances
)
;
int
vertexCount
;
if
(
request
.
fInsetDegenerate
)
{
vertexCount
=
this
-
>
adjustDegenerateVertices
(
-
request
.
fEdgeDistances
&
inset
)
;
}
else
{
this
-
>
adjustVertices
(
-
request
.
fEdgeDistances
&
inset
)
;
vertexCount
=
4
;
}
inset
.
asGrQuads
(
deviceInset
fDeviceType
localInset
fLocalType
)
;
if
(
vertexCount
<
3
)
{
return
this
-
>
getEdgeEquations
(
)
.
estimateCoverage
(
inset
.
fX
/
inset
.
fW
inset
.
fY
/
inset
.
fW
)
;
}
else
{
return
1
.
f
;
}
}
void
TessellationHelper
:
:
outset
(
const
skvx
:
:
Vec
<
4
float
>
&
edgeDistances
GrQuad
*
deviceOutset
GrQuad
*
localOutset
)
{
SkASSERT
(
fVerticesValid
)
;
Vertices
outset
=
fOriginal
;
const
OutsetRequest
&
request
=
this
-
>
getOutsetRequest
(
edgeDistances
)
;
if
(
request
.
fOutsetDegenerate
)
{
this
-
>
adjustDegenerateVertices
(
request
.
fEdgeDistances
&
outset
)
;
}
else
{
this
-
>
adjustVertices
(
request
.
fEdgeDistances
&
outset
)
;
}
outset
.
asGrQuads
(
deviceOutset
fDeviceType
localOutset
fLocalType
)
;
}
void
TessellationHelper
:
:
getEdgeEquations
(
skvx
:
:
Vec
<
4
float
>
*
a
skvx
:
:
Vec
<
4
float
>
*
b
skvx
:
:
Vec
<
4
float
>
*
c
)
{
SkASSERT
(
a
&
&
b
&
&
c
)
;
SkASSERT
(
fVerticesValid
)
;
const
EdgeEquations
&
eq
=
this
-
>
getEdgeEquations
(
)
;
*
a
=
eq
.
fA
;
*
b
=
eq
.
fB
;
*
c
=
eq
.
fC
;
}
skvx
:
:
Vec
<
4
float
>
TessellationHelper
:
:
getEdgeLengths
(
)
{
SkASSERT
(
fVerticesValid
)
;
return
1
.
f
/
fEdgeVectors
.
fInvLengths
;
}
const
TessellationHelper
:
:
OutsetRequest
&
TessellationHelper
:
:
getOutsetRequest
(
const
skvx
:
:
Vec
<
4
float
>
&
edgeDistances
)
{
SkASSERT
(
all
(
edgeDistances
>
=
0
.
f
)
)
;
if
(
!
fOutsetRequestValid
|
|
any
(
edgeDistances
!
=
fOutsetRequest
.
fEdgeDistances
)
)
{
fOutsetRequest
.
reset
(
fEdgeVectors
fDeviceType
edgeDistances
)
;
fOutsetRequestValid
=
true
;
}
return
fOutsetRequest
;
}
bool
TessellationHelper
:
:
isSubpixel
(
)
{
SkASSERT
(
fVerticesValid
)
;
if
(
fDeviceType
<
=
GrQuad
:
:
Type
:
:
kRectilinear
)
{
return
any
(
fEdgeVectors
.
fInvLengths
>
1
.
f
)
;
}
else
{
return
this
-
>
getEdgeEquations
(
)
.
isSubpixel
(
fEdgeVectors
.
fX2D
fEdgeVectors
.
fY2D
)
;
}
}
const
TessellationHelper
:
:
EdgeEquations
&
TessellationHelper
:
:
getEdgeEquations
(
)
{
if
(
!
fEdgeEquationsValid
)
{
fEdgeEquations
.
reset
(
fEdgeVectors
)
;
fEdgeEquationsValid
=
true
;
}
return
fEdgeEquations
;
}
void
TessellationHelper
:
:
adjustVertices
(
const
skvx
:
:
Vec
<
4
float
>
&
signedEdgeDistances
Vertices
*
vertices
)
{
SkASSERT
(
vertices
)
;
SkASSERT
(
vertices
-
>
fUVRCount
=
=
0
|
|
vertices
-
>
fUVRCount
=
=
2
|
|
vertices
-
>
fUVRCount
=
=
3
)
;
if
(
fDeviceType
<
GrQuad
:
:
Type
:
:
kPerspective
)
{
vertices
-
>
moveAlong
(
fEdgeVectors
signedEdgeDistances
)
;
}
else
{
Vertices
projected
=
{
fEdgeVectors
.
fX2D
fEdgeVectors
.
fY2D
1
.
f
0
.
f
0
.
f
0
.
f
0
}
;
projected
.
moveAlong
(
fEdgeVectors
signedEdgeDistances
)
;
vertices
-
>
moveTo
(
projected
.
fX
projected
.
fY
signedEdgeDistances
!
=
0
.
f
)
;
}
}
int
TessellationHelper
:
:
adjustDegenerateVertices
(
const
skvx
:
:
Vec
<
4
float
>
&
signedEdgeDistances
Vertices
*
vertices
)
{
SkASSERT
(
vertices
)
;
SkASSERT
(
vertices
-
>
fUVRCount
=
=
0
|
|
vertices
-
>
fUVRCount
=
=
2
|
|
vertices
-
>
fUVRCount
=
=
3
)
;
if
(
fDeviceType
<
=
GrQuad
:
:
Type
:
:
kRectilinear
)
{
SkASSERT
(
all
(
signedEdgeDistances
<
=
0
.
f
)
)
;
float4
halfLengths
=
-
0
.
5f
/
next_cw
(
fEdgeVectors
.
fInvLengths
)
;
mask4
crossedEdges
=
halfLengths
>
signedEdgeDistances
;
float4
safeInsets
=
if_then_else
(
crossedEdges
halfLengths
signedEdgeDistances
)
;
vertices
-
>
moveAlong
(
fEdgeVectors
safeInsets
)
;
return
all
(
crossedEdges
)
?
1
:
2
;
}
else
{
float4
x2d
=
fEdgeVectors
.
fX2D
;
float4
y2d
=
fEdgeVectors
.
fY2D
;
mask4
aaMask
;
int
vertexCount
=
this
-
>
getEdgeEquations
(
)
.
computeDegenerateQuad
(
signedEdgeDistances
&
x2d
&
y2d
&
aaMask
)
;
vertices
-
>
moveTo
(
x2d
y2d
aaMask
)
;
return
vertexCount
;
}
}
}
