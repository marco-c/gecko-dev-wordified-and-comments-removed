#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
<
utility
>
GrStyledShape
&
GrStyledShape
:
:
operator
=
(
const
GrStyledShape
&
that
)
{
fShape
=
that
.
fShape
;
fStyle
=
that
.
fStyle
;
fGenID
=
that
.
fGenID
;
fSimplified
=
that
.
fSimplified
;
fInheritedKey
.
reset
(
that
.
fInheritedKey
.
count
(
)
)
;
sk_careful_memcpy
(
fInheritedKey
.
get
(
)
that
.
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
if
(
that
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
that
.
fInheritedPathForListeners
)
;
}
else
{
fInheritedPathForListeners
.
reset
(
)
;
}
return
*
this
;
}
static
bool
is_inverted
(
bool
originalIsInverted
GrStyledShape
:
:
FillInversion
inversion
)
{
switch
(
inversion
)
{
case
GrStyledShape
:
:
FillInversion
:
:
kPreserve
:
return
originalIsInverted
;
case
GrStyledShape
:
:
FillInversion
:
:
kFlip
:
return
!
originalIsInverted
;
case
GrStyledShape
:
:
FillInversion
:
:
kForceInverted
:
return
true
;
case
GrStyledShape
:
:
FillInversion
:
:
kForceNoninverted
:
return
false
;
}
return
false
;
}
GrStyledShape
GrStyledShape
:
:
MakeFilled
(
const
GrStyledShape
&
original
FillInversion
inversion
)
{
bool
newIsInverted
=
is_inverted
(
original
.
fShape
.
inverted
(
)
inversion
)
;
if
(
original
.
style
(
)
.
isSimpleFill
(
)
&
&
newIsInverted
=
=
original
.
fShape
.
inverted
(
)
)
{
return
original
;
}
GrStyledShape
result
;
SkASSERT
(
result
.
fStyle
.
isSimpleFill
(
)
)
;
if
(
original
.
fInheritedPathForListeners
.
isValid
(
)
)
{
result
.
fInheritedPathForListeners
.
set
(
*
original
.
fInheritedPathForListeners
)
;
}
result
.
fShape
=
original
.
fShape
;
result
.
fGenID
=
original
.
fGenID
;
result
.
fShape
.
setInverted
(
newIsInverted
)
;
if
(
!
original
.
style
(
)
.
isSimpleFill
(
)
)
{
result
.
simplify
(
)
;
result
.
fSimplified
=
true
;
}
SkASSERT
(
(
!
original
.
fShape
.
isLine
(
)
&
&
!
original
.
fShape
.
isPoint
(
)
)
|
|
result
.
fShape
.
isEmpty
(
)
)
;
return
result
;
}
SkRect
GrStyledShape
:
:
styledBounds
(
)
const
{
if
(
this
-
>
isEmpty
(
)
&
&
!
fStyle
.
hasNonDashPathEffect
(
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
SkRect
bounds
;
fStyle
.
adjustBounds
(
&
bounds
this
-
>
bounds
(
)
)
;
return
bounds
;
}
static
int
path_key_from_data_size
(
const
SkPath
&
path
)
{
const
int
verbCnt
=
path
.
countVerbs
(
)
;
if
(
verbCnt
>
GrStyledShape
:
:
kMaxKeyFromDataVerbCnt
)
{
return
-
1
;
}
const
int
pointCnt
=
path
.
countPoints
(
)
;
const
int
conicWeightCnt
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
static_assert
(
sizeof
(
SkPoint
)
=
=
2
*
sizeof
(
uint32_t
)
)
;
static_assert
(
sizeof
(
SkScalar
)
=
=
sizeof
(
uint32_t
)
)
;
return
1
+
(
SkAlign4
(
verbCnt
)
>
>
2
)
+
2
*
pointCnt
+
conicWeightCnt
;
}
static
void
write_path_key_from_data
(
const
SkPath
&
path
uint32_t
*
origKey
)
{
uint32_t
*
key
=
origKey
;
const
int
verbCnt
=
path
.
countVerbs
(
)
;
const
int
pointCnt
=
path
.
countPoints
(
)
;
const
int
conicWeightCnt
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
SkASSERT
(
verbCnt
<
=
GrStyledShape
:
:
kMaxKeyFromDataVerbCnt
)
;
SkASSERT
(
pointCnt
&
&
verbCnt
)
;
*
key
+
+
=
verbCnt
;
memcpy
(
key
SkPathPriv
:
:
VerbData
(
path
)
verbCnt
*
sizeof
(
uint8_t
)
)
;
int
verbKeySize
=
SkAlign4
(
verbCnt
)
;
uint8_t
*
pad
=
reinterpret_cast
<
uint8_t
*
>
(
key
)
+
verbCnt
;
memset
(
pad
0xDE
verbKeySize
-
verbCnt
)
;
key
+
=
verbKeySize
>
>
2
;
memcpy
(
key
SkPathPriv
:
:
PointData
(
path
)
sizeof
(
SkPoint
)
*
pointCnt
)
;
static_assert
(
sizeof
(
SkPoint
)
=
=
2
*
sizeof
(
uint32_t
)
)
;
key
+
=
2
*
pointCnt
;
sk_careful_memcpy
(
key
SkPathPriv
:
:
ConicWeightData
(
path
)
sizeof
(
SkScalar
)
*
conicWeightCnt
)
;
static_assert
(
sizeof
(
SkScalar
)
=
=
sizeof
(
uint32_t
)
)
;
SkDEBUGCODE
(
key
+
=
conicWeightCnt
)
;
SkASSERT
(
key
-
origKey
=
=
path_key_from_data_size
(
path
)
)
;
}
int
GrStyledShape
:
:
unstyledKeySize
(
)
const
{
if
(
fInheritedKey
.
count
(
)
)
{
return
fInheritedKey
.
count
(
)
;
}
int
count
=
1
;
switch
(
fShape
.
type
(
)
)
{
case
GrShape
:
:
Type
:
:
kPoint
:
static_assert
(
0
=
=
sizeof
(
SkPoint
)
%
sizeof
(
uint32_t
)
)
;
count
+
=
sizeof
(
SkPoint
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kRect
:
static_assert
(
0
=
=
sizeof
(
SkRect
)
%
sizeof
(
uint32_t
)
)
;
count
+
=
sizeof
(
SkRect
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kRRect
:
static_assert
(
0
=
=
SkRRect
:
:
kSizeInMemory
%
sizeof
(
uint32_t
)
)
;
count
+
=
SkRRect
:
:
kSizeInMemory
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kArc
:
static_assert
(
0
=
=
sizeof
(
GrArc
)
%
sizeof
(
uint32_t
)
)
;
count
+
=
sizeof
(
GrArc
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kLine
:
static_assert
(
0
=
=
sizeof
(
GrLineSegment
)
%
sizeof
(
uint32_t
)
)
;
count
+
=
sizeof
(
GrLineSegment
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kPath
:
{
if
(
0
=
=
fGenID
)
{
return
-
1
;
}
int
dataKeySize
=
path_key_from_data_size
(
fShape
.
path
(
)
)
;
if
(
dataKeySize
>
=
0
)
{
count
+
=
dataKeySize
;
}
else
{
count
+
+
;
}
break
;
}
default
:
SkASSERT
(
fShape
.
isEmpty
(
)
)
;
}
return
count
;
}
void
GrStyledShape
:
:
writeUnstyledKey
(
uint32_t
*
key
)
const
{
SkASSERT
(
this
-
>
unstyledKeySize
(
)
)
;
SkDEBUGCODE
(
uint32_t
*
origKey
=
key
;
)
if
(
fInheritedKey
.
count
(
)
)
{
memcpy
(
key
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
SkDEBUGCODE
(
key
+
=
fInheritedKey
.
count
(
)
;
)
}
else
{
SkASSERT
(
(
fShape
.
isRect
(
)
|
|
fShape
.
isRRect
(
)
)
|
|
(
fShape
.
dir
(
)
=
=
GrShape
:
:
kDefaultDir
&
&
fShape
.
startIndex
(
)
=
=
GrShape
:
:
kDefaultStart
)
)
;
*
key
+
+
=
fShape
.
stateKey
(
)
;
switch
(
fShape
.
type
(
)
)
{
case
GrShape
:
:
Type
:
:
kPath
:
{
SkASSERT
(
fGenID
!
=
0
)
;
SkASSERT
(
fShape
.
inverted
(
)
=
=
fShape
.
path
(
)
.
isInverseFillType
(
)
)
;
int
dataKeySize
=
path_key_from_data_size
(
fShape
.
path
(
)
)
;
if
(
dataKeySize
>
=
0
)
{
write_path_key_from_data
(
fShape
.
path
(
)
key
)
;
return
;
}
else
{
*
key
+
+
=
fGenID
;
}
break
;
}
case
GrShape
:
:
Type
:
:
kPoint
:
memcpy
(
key
&
fShape
.
point
(
)
sizeof
(
SkPoint
)
)
;
key
+
=
sizeof
(
SkPoint
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kRect
:
memcpy
(
key
&
fShape
.
rect
(
)
sizeof
(
SkRect
)
)
;
key
+
=
sizeof
(
SkRect
)
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kRRect
:
fShape
.
rrect
(
)
.
writeToMemory
(
key
)
;
key
+
=
SkRRect
:
:
kSizeInMemory
/
sizeof
(
uint32_t
)
;
break
;
case
GrShape
:
:
Type
:
:
kArc
:
memcpy
(
key
&
fShape
.
arc
(
)
sizeof
(
SkRect
)
+
2
*
sizeof
(
float
)
)
;
key
+
=
(
sizeof
(
GrArc
)
/
sizeof
(
uint32_t
)
-
1
)
;
*
key
+
+
=
fShape
.
arc
(
)
.
fUseCenter
?
1
:
0
;
break
;
case
GrShape
:
:
Type
:
:
kLine
:
memcpy
(
key
&
fShape
.
line
(
)
sizeof
(
GrLineSegment
)
)
;
key
+
=
sizeof
(
GrLineSegment
)
/
sizeof
(
uint32_t
)
;
break
;
default
:
SkASSERT
(
fShape
.
isEmpty
(
)
)
;
}
}
SkASSERT
(
key
-
origKey
=
=
this
-
>
unstyledKeySize
(
)
)
;
}
void
GrStyledShape
:
:
setInheritedKey
(
const
GrStyledShape
&
parent
GrStyle
:
:
Apply
apply
SkScalar
scale
)
{
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
if
(
fShape
.
isPath
(
)
)
{
int
parentCnt
=
parent
.
fInheritedKey
.
count
(
)
;
bool
useParentGeoKey
=
!
parentCnt
;
if
(
useParentGeoKey
)
{
parentCnt
=
parent
.
unstyledKeySize
(
)
;
if
(
parentCnt
<
0
)
{
fGenID
=
0
;
return
;
}
}
uint32_t
styleKeyFlags
=
0
;
if
(
parent
.
knownToBeClosed
(
)
)
{
styleKeyFlags
|
=
GrStyle
:
:
kClosed_KeyFlag
;
}
if
(
parent
.
asLine
(
nullptr
nullptr
)
)
{
styleKeyFlags
|
=
GrStyle
:
:
kNoJoins_KeyFlag
;
}
int
styleCnt
=
GrStyle
:
:
KeySize
(
parent
.
fStyle
apply
styleKeyFlags
)
;
if
(
styleCnt
<
0
)
{
fGenID
=
0
;
return
;
}
fInheritedKey
.
reset
(
parentCnt
+
styleCnt
)
;
if
(
useParentGeoKey
)
{
parent
.
writeUnstyledKey
(
fInheritedKey
.
get
(
)
)
;
}
else
{
memcpy
(
fInheritedKey
.
get
(
)
parent
.
fInheritedKey
.
get
(
)
parentCnt
*
sizeof
(
uint32_t
)
)
;
}
GrStyle
:
:
WriteKey
(
fInheritedKey
.
get
(
)
+
parentCnt
parent
.
fStyle
apply
scale
styleKeyFlags
)
;
}
}
const
SkPath
*
GrStyledShape
:
:
originalPathForListeners
(
)
const
{
if
(
fInheritedPathForListeners
.
isValid
(
)
)
{
return
fInheritedPathForListeners
.
get
(
)
;
}
else
if
(
fShape
.
isPath
(
)
&
&
!
fShape
.
path
(
)
.
isVolatile
(
)
)
{
return
&
fShape
.
path
(
)
;
}
return
nullptr
;
}
void
GrStyledShape
:
:
addGenIDChangeListener
(
sk_sp
<
SkIDChangeListener
>
listener
)
const
{
if
(
const
auto
*
lp
=
this
-
>
originalPathForListeners
(
)
)
{
SkPathPriv
:
:
AddGenIDChangeListener
(
*
lp
std
:
:
move
(
listener
)
)
;
}
}
GrStyledShape
GrStyledShape
:
:
MakeArc
(
const
SkRect
&
oval
SkScalar
startAngleDegrees
SkScalar
sweepAngleDegrees
bool
useCenter
const
GrStyle
&
style
DoSimplify
doSimplify
)
{
GrStyledShape
result
;
result
.
fShape
.
setArc
(
{
oval
.
makeSorted
(
)
startAngleDegrees
sweepAngleDegrees
useCenter
}
)
;
result
.
fStyle
=
style
;
if
(
doSimplify
=
=
DoSimplify
:
:
kYes
)
{
result
.
simplify
(
)
;
}
return
result
;
}
GrStyledShape
:
:
GrStyledShape
(
const
GrStyledShape
&
that
)
:
fShape
(
that
.
fShape
)
fStyle
(
that
.
fStyle
)
fGenID
(
that
.
fGenID
)
fSimplified
(
that
.
fSimplified
)
{
fInheritedKey
.
reset
(
that
.
fInheritedKey
.
count
(
)
)
;
sk_careful_memcpy
(
fInheritedKey
.
get
(
)
that
.
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
if
(
that
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
that
.
fInheritedPathForListeners
)
;
}
}
GrStyledShape
:
:
GrStyledShape
(
const
GrStyledShape
&
parent
GrStyle
:
:
Apply
apply
SkScalar
scale
)
{
if
(
!
parent
.
style
(
)
.
applies
(
)
|
|
(
GrStyle
:
:
Apply
:
:
kPathEffectOnly
=
=
apply
&
&
!
parent
.
style
(
)
.
pathEffect
(
)
)
)
{
*
this
=
parent
;
return
;
}
SkPathEffect
*
pe
=
parent
.
fStyle
.
pathEffect
(
)
;
SkTLazy
<
SkPath
>
tmpPath
;
const
GrStyledShape
*
parentForKey
=
&
parent
;
SkTLazy
<
GrStyledShape
>
tmpParent
;
fShape
.
setPath
(
SkPath
(
)
)
;
if
(
pe
)
{
const
SkPath
*
srcForPathEffect
;
if
(
parent
.
fShape
.
isPath
(
)
)
{
srcForPathEffect
=
&
parent
.
fShape
.
path
(
)
;
}
else
{
srcForPathEffect
=
tmpPath
.
init
(
)
;
parent
.
asPath
(
tmpPath
.
get
(
)
)
;
}
SkStrokeRec
strokeRec
=
parent
.
fStyle
.
strokeRec
(
)
;
if
(
!
parent
.
fStyle
.
applyPathEffectToPath
(
&
fShape
.
path
(
)
&
strokeRec
*
srcForPathEffect
scale
)
)
{
tmpParent
.
init
(
*
srcForPathEffect
GrStyle
(
strokeRec
nullptr
)
)
;
*
this
=
tmpParent
-
>
applyStyle
(
apply
scale
)
;
return
;
}
SkASSERT
(
scale
=
=
strokeRec
.
getResScale
(
)
)
;
if
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
=
=
apply
&
&
strokeRec
.
needToApply
(
)
)
{
tmpParent
.
init
(
fShape
.
path
(
)
GrStyle
(
strokeRec
nullptr
)
)
;
tmpParent
-
>
setInheritedKey
(
parent
GrStyle
:
:
Apply
:
:
kPathEffectOnly
scale
)
;
if
(
!
tmpPath
.
isValid
(
)
)
{
tmpPath
.
init
(
)
;
}
tmpParent
-
>
asPath
(
tmpPath
.
get
(
)
)
;
SkStrokeRec
:
:
InitStyle
fillOrHairline
;
if
(
tmpParent
-
>
style
(
)
.
applies
(
)
)
{
SkAssertResult
(
tmpParent
.
get
(
)
-
>
style
(
)
.
applyToPath
(
&
fShape
.
path
(
)
&
fillOrHairline
*
tmpPath
.
get
(
)
scale
)
)
;
}
else
if
(
tmpParent
-
>
style
(
)
.
isSimpleFill
(
)
)
{
fillOrHairline
=
SkStrokeRec
:
:
kFill_InitStyle
;
}
else
{
SkASSERT
(
tmpParent
.
get
(
)
-
>
style
(
)
.
isSimpleHairline
(
)
)
;
fillOrHairline
=
SkStrokeRec
:
:
kHairline_InitStyle
;
}
fStyle
.
resetToInitStyle
(
fillOrHairline
)
;
parentForKey
=
tmpParent
.
get
(
)
;
}
else
{
fStyle
=
GrStyle
(
strokeRec
nullptr
)
;
}
}
else
{
const
SkPath
*
srcForParentStyle
;
if
(
parent
.
fShape
.
isPath
(
)
)
{
srcForParentStyle
=
&
parent
.
fShape
.
path
(
)
;
}
else
{
srcForParentStyle
=
tmpPath
.
init
(
)
;
parent
.
asPath
(
tmpPath
.
get
(
)
)
;
}
SkStrokeRec
:
:
InitStyle
fillOrHairline
;
SkASSERT
(
parent
.
fStyle
.
applies
(
)
)
;
SkASSERT
(
!
parent
.
fStyle
.
pathEffect
(
)
)
;
SkAssertResult
(
parent
.
fStyle
.
applyToPath
(
&
fShape
.
path
(
)
&
fillOrHairline
*
srcForParentStyle
scale
)
)
;
fStyle
.
resetToInitStyle
(
fillOrHairline
)
;
}
if
(
parent
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
parent
.
fInheritedPathForListeners
)
;
}
else
if
(
parent
.
fShape
.
isPath
(
)
&
&
!
parent
.
fShape
.
path
(
)
.
isVolatile
(
)
)
{
fInheritedPathForListeners
.
set
(
parent
.
fShape
.
path
(
)
)
;
}
this
-
>
simplify
(
)
;
this
-
>
setInheritedKey
(
*
parentForKey
apply
scale
)
;
}
bool
GrStyledShape
:
:
asRRect
(
SkRRect
*
rrect
SkPathDirection
*
dir
unsigned
*
start
bool
*
inverted
)
const
{
if
(
!
fShape
.
isRRect
(
)
&
&
!
fShape
.
isRect
(
)
)
{
return
false
;
}
SkASSERT
(
fStyle
.
hasPathEffect
(
)
|
|
(
fShape
.
dir
(
)
=
=
GrShape
:
:
kDefaultDir
&
&
fShape
.
startIndex
(
)
=
=
GrShape
:
:
kDefaultStart
)
)
;
if
(
fShape
.
isRect
(
)
)
{
if
(
rrect
)
{
*
rrect
=
SkRRect
:
:
MakeRect
(
fShape
.
rect
(
)
)
;
}
if
(
!
fStyle
.
hasPathEffect
(
)
)
{
if
(
dir
)
{
*
dir
=
GrShape
:
:
kDefaultDir
;
}
if
(
start
)
{
*
start
=
GrShape
:
:
kDefaultStart
;
}
}
else
{
SkPathDirection
rectDir
=
fShape
.
dir
(
)
;
unsigned
rectStart
=
fShape
.
startIndex
(
)
;
if
(
fShape
.
rect
(
)
.
fLeft
>
fShape
.
rect
(
)
.
fRight
)
{
static
const
unsigned
kMapping
[
]
=
{
1
0
3
2
}
;
rectDir
=
rectDir
=
=
SkPathDirection
:
:
kCCW
?
SkPathDirection
:
:
kCW
:
SkPathDirection
:
:
kCCW
;
rectStart
=
kMapping
[
rectStart
]
;
}
if
(
fShape
.
rect
(
)
.
fTop
>
fShape
.
rect
(
)
.
fBottom
)
{
rectDir
=
rectDir
=
=
SkPathDirection
:
:
kCCW
?
SkPathDirection
:
:
kCW
:
SkPathDirection
:
:
kCCW
;
rectStart
=
3
-
rectStart
;
}
if
(
dir
)
{
*
dir
=
rectDir
;
}
if
(
start
)
{
*
start
=
2
*
rectStart
;
}
}
}
else
{
if
(
rrect
)
{
*
rrect
=
fShape
.
rrect
(
)
;
}
if
(
dir
)
{
*
dir
=
fShape
.
dir
(
)
;
}
if
(
start
)
{
*
start
=
fShape
.
startIndex
(
)
;
if
(
fShape
.
rrect
(
)
.
isOval
(
)
)
{
*
start
&
=
0b110
;
}
}
}
if
(
inverted
)
{
*
inverted
=
fShape
.
inverted
(
)
;
}
return
true
;
}
bool
GrStyledShape
:
:
asLine
(
SkPoint
pts
[
2
]
bool
*
inverted
)
const
{
if
(
!
fShape
.
isLine
(
)
)
{
return
false
;
}
if
(
pts
)
{
pts
[
0
]
=
fShape
.
line
(
)
.
fP1
;
pts
[
1
]
=
fShape
.
line
(
)
.
fP2
;
}
if
(
inverted
)
{
*
inverted
=
fShape
.
inverted
(
)
;
}
return
true
;
}
bool
GrStyledShape
:
:
asNestedRects
(
SkRect
rects
[
2
]
)
const
{
if
(
!
fShape
.
isPath
(
)
)
{
return
false
;
}
if
(
fShape
.
path
(
)
.
isInverseFillType
(
)
)
{
return
false
;
}
SkPathDirection
dirs
[
2
]
;
if
(
!
SkPathPriv
:
:
IsNestedFillRects
(
fShape
.
path
(
)
rects
dirs
)
)
{
return
false
;
}
if
(
SkPathFillType
:
:
kWinding
=
=
fShape
.
path
(
)
.
getFillType
(
)
&
&
dirs
[
0
]
=
=
dirs
[
1
]
)
{
return
false
;
}
const
SkScalar
*
outer
=
rects
[
0
]
.
asScalars
(
)
;
const
SkScalar
*
inner
=
rects
[
1
]
.
asScalars
(
)
;
bool
allEq
=
true
;
SkScalar
margin
=
SkScalarAbs
(
outer
[
0
]
-
inner
[
0
]
)
;
bool
allGoE1
=
margin
>
=
SK_Scalar1
;
for
(
int
i
=
1
;
i
<
4
;
+
+
i
)
{
SkScalar
temp
=
SkScalarAbs
(
outer
[
i
]
-
inner
[
i
]
)
;
if
(
temp
<
SK_Scalar1
)
{
allGoE1
=
false
;
}
if
(
!
SkScalarNearlyEqual
(
margin
temp
)
)
{
allEq
=
false
;
}
}
return
allEq
|
|
allGoE1
;
}
class
AutoRestoreInverseness
{
public
:
AutoRestoreInverseness
(
GrShape
*
shape
const
GrStyle
&
style
)
:
fShape
(
shape
)
fInverted
(
!
style
.
isDashed
(
)
&
&
fShape
-
>
inverted
(
)
)
{
}
~
AutoRestoreInverseness
(
)
{
fShape
-
>
setInverted
(
fInverted
)
;
SkASSERT
(
!
fShape
-
>
isPath
(
)
|
|
fInverted
=
=
fShape
-
>
path
(
)
.
isInverseFillType
(
)
)
;
}
private
:
GrShape
*
fShape
;
bool
fInverted
;
}
;
void
GrStyledShape
:
:
simplify
(
)
{
AutoRestoreInverseness
ari
(
&
fShape
fStyle
)
;
unsigned
simplifyFlags
=
0
;
if
(
fStyle
.
isSimpleFill
(
)
)
{
simplifyFlags
=
GrShape
:
:
kAll_Flags
;
}
else
if
(
!
fStyle
.
hasPathEffect
(
)
)
{
if
(
!
fShape
.
isArc
(
)
|
|
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kButt_Cap
)
{
simplifyFlags
|
=
GrShape
:
:
kIgnoreWinding_Flag
;
}
simplifyFlags
|
=
GrShape
:
:
kMakeCanonical_Flag
;
}
GrShape
:
:
Type
oldType
=
fShape
.
type
(
)
;
fClosed
=
fShape
.
simplify
(
simplifyFlags
)
;
fSimplified
=
oldType
!
=
fShape
.
type
(
)
;
if
(
fShape
.
isPath
(
)
)
{
if
(
fInheritedKey
.
count
(
)
|
|
fShape
.
path
(
)
.
isVolatile
(
)
)
{
fGenID
=
0
;
}
else
{
fGenID
=
fShape
.
path
(
)
.
getGenerationID
(
)
;
}
if
(
!
fStyle
.
hasNonDashPathEffect
(
)
&
&
(
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kHairline_Style
|
|
fShape
.
path
(
)
.
isConvex
(
)
)
)
{
fShape
.
path
(
)
.
setFillType
(
GrShape
:
:
kDefaultFillType
)
;
}
}
else
{
fInheritedKey
.
reset
(
0
)
;
fInheritedPathForListeners
.
reset
(
)
;
this
-
>
simplifyStroke
(
)
;
}
}
void
GrStyledShape
:
:
simplifyStroke
(
)
{
AutoRestoreInverseness
ari
(
&
fShape
fStyle
)
;
if
(
!
fStyle
.
hasPathEffect
(
)
&
&
fShape
.
isRect
(
)
&
&
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
{
if
(
fStyle
.
strokeRec
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kBevel_Join
|
|
(
fStyle
.
strokeRec
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kMiter_Join
&
&
fStyle
.
strokeRec
(
)
.
getMiter
(
)
<
SK_ScalarSqrt2
)
)
{
return
;
}
SkScalar
r
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
;
fShape
.
rect
(
)
.
outset
(
r
r
)
;
if
(
fStyle
.
strokeRec
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kRound_Join
)
{
fShape
.
setRRect
(
SkRRect
:
:
MakeRectXY
(
fShape
.
rect
(
)
r
r
)
)
;
}
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
fSimplified
=
true
;
return
;
}
if
(
(
!
fShape
.
isPoint
(
)
&
&
!
fShape
.
isLine
(
)
)
|
|
fStyle
.
hasNonDashPathEffect
(
)
|
|
fStyle
.
strokeRec
(
)
.
isHairlineStyle
(
)
)
{
return
;
}
bool
styleSimplified
=
false
;
if
(
fStyle
.
isDashed
(
)
)
{
bool
dropDash
=
false
;
if
(
fShape
.
isPoint
(
)
)
{
dropDash
=
fStyle
.
dashIntervalCnt
(
)
>
0
&
&
SkToBool
(
fStyle
.
dashIntervals
(
)
[
0
]
)
;
}
else
{
dropDash
=
true
;
for
(
int
i
=
1
;
i
<
fStyle
.
dashIntervalCnt
(
)
;
i
+
=
2
)
{
if
(
SkToBool
(
fStyle
.
dashIntervals
(
)
[
i
]
)
)
{
dropDash
=
false
;
break
;
}
}
}
if
(
!
dropDash
)
{
return
;
}
fStyle
=
GrStyle
(
fStyle
.
strokeRec
(
)
nullptr
)
;
fClosed
=
false
;
styleSimplified
=
true
;
}
if
(
fStyle
.
isSimpleFill
(
)
)
{
fShape
.
reset
(
)
;
fSimplified
=
true
;
return
;
}
else
if
(
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
{
SkStrokeRec
rec
=
fStyle
.
strokeRec
(
)
;
rec
.
setStrokeStyle
(
fStyle
.
strokeRec
(
)
.
getWidth
(
)
false
)
;
fStyle
=
GrStyle
(
rec
nullptr
)
;
styleSimplified
=
true
;
}
if
(
fClosed
)
{
SkPaint
:
:
Cap
cap
;
if
(
fShape
.
isLine
(
)
&
&
fStyle
.
strokeRec
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kRound_Join
)
{
cap
=
SkPaint
:
:
kRound_Cap
;
}
else
{
cap
=
SkPaint
:
:
kButt_Cap
;
}
if
(
cap
!
=
fStyle
.
strokeRec
(
)
.
getCap
(
)
|
|
SkPaint
:
:
kDefault_Join
!
=
fStyle
.
strokeRec
(
)
.
getJoin
(
)
)
{
SkStrokeRec
rec
=
fStyle
.
strokeRec
(
)
;
rec
.
setStrokeParams
(
cap
SkPaint
:
:
kDefault_Join
fStyle
.
strokeRec
(
)
.
getMiter
(
)
)
;
fStyle
=
GrStyle
(
rec
nullptr
)
;
styleSimplified
=
true
;
}
}
if
(
fShape
.
isPoint
(
)
)
{
if
(
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kButt_Cap
)
{
fShape
.
reset
(
)
;
}
else
{
SkScalar
w
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
.
f
;
SkRect
r
=
{
fShape
.
point
(
)
.
fX
fShape
.
point
(
)
.
fY
fShape
.
point
(
)
.
fX
fShape
.
point
(
)
.
fY
}
;
r
.
outset
(
w
w
)
;
if
(
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kRound_Cap
)
{
fShape
.
setRRect
(
SkRRect
:
:
MakeOval
(
r
)
)
;
}
else
{
fShape
.
setRect
(
r
)
;
}
}
}
else
{
SkRect
rect
;
SkVector
outset
;
if
(
fShape
.
line
(
)
.
fP1
.
fY
=
=
fShape
.
line
(
)
.
fP2
.
fY
)
{
rect
.
fLeft
=
std
:
:
min
(
fShape
.
line
(
)
.
fP1
.
fX
fShape
.
line
(
)
.
fP2
.
fX
)
;
rect
.
fRight
=
std
:
:
max
(
fShape
.
line
(
)
.
fP1
.
fX
fShape
.
line
(
)
.
fP2
.
fX
)
;
rect
.
fTop
=
rect
.
fBottom
=
fShape
.
line
(
)
.
fP1
.
fY
;
outset
.
fY
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
.
f
;
outset
.
fX
=
SkPaint
:
:
kButt_Cap
=
=
fStyle
.
strokeRec
(
)
.
getCap
(
)
?
0
.
f
:
outset
.
fY
;
}
else
if
(
fShape
.
line
(
)
.
fP1
.
fX
=
=
fShape
.
line
(
)
.
fP2
.
fX
)
{
rect
.
fTop
=
std
:
:
min
(
fShape
.
line
(
)
.
fP1
.
fY
fShape
.
line
(
)
.
fP2
.
fY
)
;
rect
.
fBottom
=
std
:
:
max
(
fShape
.
line
(
)
.
fP1
.
fY
fShape
.
line
(
)
.
fP2
.
fY
)
;
rect
.
fLeft
=
rect
.
fRight
=
fShape
.
line
(
)
.
fP1
.
fX
;
outset
.
fX
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
.
f
;
outset
.
fY
=
SkPaint
:
:
kButt_Cap
=
=
fStyle
.
strokeRec
(
)
.
getCap
(
)
?
0
.
f
:
outset
.
fX
;
}
else
{
fSimplified
|
=
styleSimplified
;
return
;
}
rect
.
outset
(
outset
.
fX
outset
.
fY
)
;
if
(
rect
.
isEmpty
(
)
)
{
fShape
.
reset
(
)
;
}
else
if
(
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kRound_Cap
)
{
SkASSERT
(
outset
.
fX
=
=
outset
.
fY
)
;
fShape
.
setRRect
(
SkRRect
:
:
MakeRectXY
(
rect
outset
.
fX
outset
.
fY
)
)
;
}
else
{
fShape
.
setRect
(
rect
)
;
}
}
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
fSimplified
=
true
;
return
;
}
