#
ifndef
GrTriangulator_DEFINED
#
define
GrTriangulator_DEFINED
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
class
GrEagerVertexAllocator
;
struct
SkRect
;
#
define
TRIANGULATOR_LOGGING
0
#
define
TRIANGULATOR_WIREFRAME
0
class
GrTriangulator
{
public
:
constexpr
static
int
kArenaDefaultChunkSize
=
16
*
1024
;
static
int
PathToTriangles
(
const
SkPath
&
path
SkScalar
tolerance
const
SkRect
&
clipBounds
GrEagerVertexAllocator
*
vertexAllocator
bool
*
isLinear
)
{
if
(
!
path
.
isFinite
(
)
)
{
return
0
;
}
SkArenaAlloc
alloc
(
kArenaDefaultChunkSize
)
;
GrTriangulator
triangulator
(
path
&
alloc
)
;
auto
[
polys
success
]
=
triangulator
.
pathToPolys
(
tolerance
clipBounds
isLinear
)
;
if
(
!
success
)
{
return
0
;
}
int
count
=
triangulator
.
polysToTriangles
(
polys
vertexAllocator
)
;
return
count
;
}
typedef
enum
{
kLeft_Side
kRight_Side
}
Side
;
enum
class
EdgeType
{
kInner
kOuter
kConnector
}
;
struct
Vertex
;
struct
VertexList
;
struct
Line
;
struct
Edge
;
struct
EdgeList
;
struct
MonotonePoly
;
struct
Poly
;
struct
Comparator
;
protected
:
GrTriangulator
(
const
SkPath
&
path
SkArenaAlloc
*
alloc
)
:
fPath
(
path
)
fAlloc
(
alloc
)
{
}
virtual
~
GrTriangulator
(
)
{
}
void
pathToContours
(
float
tolerance
const
SkRect
&
clipBounds
VertexList
*
contours
bool
*
isLinear
)
const
;
void
contoursToMesh
(
VertexList
*
contours
int
contourCnt
VertexList
*
mesh
const
Comparator
&
)
;
static
void
SortedMerge
(
VertexList
*
front
VertexList
*
back
VertexList
*
result
const
Comparator
&
)
;
static
void
SortMesh
(
VertexList
*
vertices
const
Comparator
&
)
;
enum
class
SimplifyResult
{
kFailed
kAlreadySimple
kFoundSelfIntersection
}
;
SimplifyResult
SK_WARN_UNUSED_RESULT
simplify
(
VertexList
*
mesh
const
Comparator
&
)
;
virtual
std
:
:
tuple
<
Poly
*
bool
>
tessellate
(
const
VertexList
&
vertices
const
Comparator
&
)
;
skgpu
:
:
VertexWriter
polysToTriangles
(
Poly
*
polys
SkPathFillType
overrideFillType
skgpu
:
:
VertexWriter
data
)
const
;
skgpu
:
:
VertexWriter
emitMonotonePoly
(
const
MonotonePoly
*
skgpu
:
:
VertexWriter
data
)
const
;
skgpu
:
:
VertexWriter
emitTriangle
(
Vertex
*
prev
Vertex
*
curr
Vertex
*
next
int
winding
skgpu
:
:
VertexWriter
data
)
const
;
skgpu
:
:
VertexWriter
emitPoly
(
const
Poly
*
skgpu
:
:
VertexWriter
data
)
const
;
Poly
*
makePoly
(
Poly
*
*
head
Vertex
*
v
int
winding
)
const
;
void
appendPointToContour
(
const
SkPoint
&
p
VertexList
*
contour
)
const
;
void
appendQuadraticToContour
(
const
SkPoint
[
3
]
SkScalar
toleranceSqd
VertexList
*
contour
)
const
;
void
generateCubicPoints
(
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
SkScalar
tolSqd
VertexList
*
contour
int
pointsLeft
)
const
;
bool
applyFillType
(
int
winding
)
const
;
MonotonePoly
*
allocateMonotonePoly
(
Edge
*
edge
Side
side
int
winding
)
;
Edge
*
allocateEdge
(
Vertex
*
top
Vertex
*
bottom
int
winding
EdgeType
type
)
;
Edge
*
makeEdge
(
Vertex
*
prev
Vertex
*
next
EdgeType
type
const
Comparator
&
)
;
void
setTop
(
Edge
*
edge
Vertex
*
v
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
const
;
void
setBottom
(
Edge
*
edge
Vertex
*
v
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
const
;
void
mergeEdgesAbove
(
Edge
*
edge
Edge
*
other
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
const
;
void
mergeEdgesBelow
(
Edge
*
edge
Edge
*
other
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
const
;
Edge
*
makeConnectingEdge
(
Vertex
*
prev
Vertex
*
next
EdgeType
const
Comparator
&
int
windingScale
=
1
)
;
void
mergeVertices
(
Vertex
*
src
Vertex
*
dst
VertexList
*
mesh
const
Comparator
&
)
const
;
static
void
FindEnclosingEdges
(
Vertex
*
v
EdgeList
*
edges
Edge
*
*
left
Edge
*
*
right
)
;
void
mergeCollinearEdges
(
Edge
*
edge
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
const
;
bool
splitEdge
(
Edge
*
edge
Vertex
*
v
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
;
bool
intersectEdgePair
(
Edge
*
left
Edge
*
right
EdgeList
*
activeEdges
Vertex
*
*
current
const
Comparator
&
)
;
Vertex
*
makeSortedVertex
(
const
SkPoint
&
uint8_t
alpha
VertexList
*
mesh
Vertex
*
reference
const
Comparator
&
)
const
;
void
computeBisector
(
Edge
*
edge1
Edge
*
edge2
Vertex
*
)
const
;
bool
checkForIntersection
(
Edge
*
left
Edge
*
right
EdgeList
*
activeEdges
Vertex
*
*
current
VertexList
*
mesh
const
Comparator
&
)
;
void
sanitizeContours
(
VertexList
*
contours
int
contourCnt
)
const
;
bool
mergeCoincidentVertices
(
VertexList
*
mesh
const
Comparator
&
)
const
;
void
buildEdges
(
VertexList
*
contours
int
contourCnt
VertexList
*
mesh
const
Comparator
&
)
;
std
:
:
tuple
<
Poly
*
bool
>
contoursToPolys
(
VertexList
*
contours
int
contourCnt
)
;
std
:
:
tuple
<
Poly
*
bool
>
pathToPolys
(
float
tolerance
const
SkRect
&
clipBounds
bool
*
isLinear
)
;
static
int64_t
CountPoints
(
Poly
*
polys
SkPathFillType
overrideFillType
)
;
int
polysToTriangles
(
Poly
*
GrEagerVertexAllocator
*
)
const
;
const
SkPath
fPath
;
SkArenaAlloc
*
const
fAlloc
;
int
fNumMonotonePolys
=
0
;
int
fNumEdges
=
0
;
bool
fRoundVerticesToQuarterPixel
=
false
;
bool
fEmitCoverage
=
false
;
bool
fPreserveCollinearVertices
=
false
;
bool
fCollectBreadcrumbTriangles
=
false
;
class
BreadcrumbTriangleList
{
public
:
struct
Node
{
Node
(
SkPoint
a
SkPoint
b
SkPoint
c
)
:
fPts
{
a
b
c
}
{
}
SkPoint
fPts
[
3
]
;
Node
*
fNext
=
nullptr
;
}
;
const
Node
*
head
(
)
const
{
return
fHead
;
}
int
count
(
)
const
{
return
fCount
;
}
void
append
(
SkArenaAlloc
*
alloc
SkPoint
a
SkPoint
b
SkPoint
c
int
winding
)
{
if
(
a
=
=
b
|
|
a
=
=
c
|
|
b
=
=
c
|
|
winding
=
=
0
)
{
return
;
}
if
(
winding
<
0
)
{
std
:
:
swap
(
a
b
)
;
winding
=
-
winding
;
}
for
(
int
i
=
0
;
i
<
winding
;
+
+
i
)
{
SkASSERT
(
fTail
&
&
!
(
*
fTail
)
)
;
*
fTail
=
alloc
-
>
make
<
Node
>
(
a
b
c
)
;
fTail
=
&
(
*
fTail
)
-
>
fNext
;
}
fCount
+
=
winding
;
}
void
concat
(
BreadcrumbTriangleList
&
&
list
)
{
SkASSERT
(
fTail
&
&
!
(
*
fTail
)
)
;
if
(
list
.
fHead
)
{
*
fTail
=
list
.
fHead
;
fTail
=
list
.
fTail
;
fCount
+
=
list
.
fCount
;
list
.
fHead
=
nullptr
;
list
.
fTail
=
&
list
.
fHead
;
list
.
fCount
=
0
;
}
}
private
:
Node
*
fHead
=
nullptr
;
Node
*
*
fTail
=
&
fHead
;
int
fCount
=
0
;
}
;
mutable
BreadcrumbTriangleList
fBreadcrumbList
;
}
;
struct
GrTriangulator
:
:
Vertex
{
Vertex
(
const
SkPoint
&
point
uint8_t
alpha
)
:
fPoint
(
point
)
fPrev
(
nullptr
)
fNext
(
nullptr
)
fFirstEdgeAbove
(
nullptr
)
fLastEdgeAbove
(
nullptr
)
fFirstEdgeBelow
(
nullptr
)
fLastEdgeBelow
(
nullptr
)
fLeftEnclosingEdge
(
nullptr
)
fRightEnclosingEdge
(
nullptr
)
fPartner
(
nullptr
)
fAlpha
(
alpha
)
fSynthetic
(
false
)
#
if
TRIANGULATOR_LOGGING
fID
(
-
1
.
0f
)
#
endif
{
}
SkPoint
fPoint
;
Vertex
*
fPrev
;
Vertex
*
fNext
;
Edge
*
fFirstEdgeAbove
;
Edge
*
fLastEdgeAbove
;
Edge
*
fFirstEdgeBelow
;
Edge
*
fLastEdgeBelow
;
Edge
*
fLeftEnclosingEdge
;
Edge
*
fRightEnclosingEdge
;
Vertex
*
fPartner
;
uint8_t
fAlpha
;
bool
fSynthetic
;
#
if
TRIANGULATOR_LOGGING
float
fID
;
#
endif
bool
isConnected
(
)
const
{
return
this
-
>
fFirstEdgeAbove
|
|
this
-
>
fFirstEdgeBelow
;
}
}
;
struct
GrTriangulator
:
:
VertexList
{
VertexList
(
)
:
fHead
(
nullptr
)
fTail
(
nullptr
)
{
}
VertexList
(
Vertex
*
head
Vertex
*
tail
)
:
fHead
(
head
)
fTail
(
tail
)
{
}
Vertex
*
fHead
;
Vertex
*
fTail
;
void
insert
(
Vertex
*
v
Vertex
*
prev
Vertex
*
next
)
;
void
append
(
Vertex
*
v
)
{
insert
(
v
fTail
nullptr
)
;
}
void
append
(
const
VertexList
&
list
)
{
if
(
!
list
.
fHead
)
{
return
;
}
if
(
fTail
)
{
fTail
-
>
fNext
=
list
.
fHead
;
list
.
fHead
-
>
fPrev
=
fTail
;
}
else
{
fHead
=
list
.
fHead
;
}
fTail
=
list
.
fTail
;
}
void
prepend
(
Vertex
*
v
)
{
insert
(
v
nullptr
fHead
)
;
}
void
remove
(
Vertex
*
v
)
;
void
close
(
)
{
if
(
fHead
&
&
fTail
)
{
fTail
-
>
fNext
=
fHead
;
fHead
-
>
fPrev
=
fTail
;
}
}
#
if
TRIANGULATOR_LOGGING
void
dump
(
)
const
;
#
endif
}
;
struct
GrTriangulator
:
:
Line
{
Line
(
double
a
double
b
double
c
)
:
fA
(
a
)
fB
(
b
)
fC
(
c
)
{
}
Line
(
Vertex
*
p
Vertex
*
q
)
:
Line
(
p
-
>
fPoint
q
-
>
fPoint
)
{
}
Line
(
const
SkPoint
&
p
const
SkPoint
&
q
)
:
fA
(
static_cast
<
double
>
(
q
.
fY
)
-
p
.
fY
)
fB
(
static_cast
<
double
>
(
p
.
fX
)
-
q
.
fX
)
fC
(
static_cast
<
double
>
(
p
.
fY
)
*
q
.
fX
-
static_cast
<
double
>
(
p
.
fX
)
*
q
.
fY
)
{
}
double
dist
(
const
SkPoint
&
p
)
const
{
return
fA
*
p
.
fX
+
fB
*
p
.
fY
+
fC
;
}
Line
operator
*
(
double
v
)
const
{
return
Line
(
fA
*
v
fB
*
v
fC
*
v
)
;
}
double
magSq
(
)
const
{
return
fA
*
fA
+
fB
*
fB
;
}
void
normalize
(
)
{
double
len
=
sqrt
(
this
-
>
magSq
(
)
)
;
if
(
len
=
=
0
.
0
)
{
return
;
}
double
scale
=
1
.
0f
/
len
;
fA
*
=
scale
;
fB
*
=
scale
;
fC
*
=
scale
;
}
bool
nearParallel
(
const
Line
&
o
)
const
{
return
fabs
(
o
.
fA
-
fA
)
<
0
.
00001
&
&
fabs
(
o
.
fB
-
fB
)
<
0
.
00001
;
}
bool
intersect
(
const
Line
&
other
SkPoint
*
point
)
const
;
double
fA
fB
fC
;
}
;
struct
GrTriangulator
:
:
Edge
{
Edge
(
Vertex
*
top
Vertex
*
bottom
int
winding
EdgeType
type
)
:
fWinding
(
winding
)
fTop
(
top
)
fBottom
(
bottom
)
fType
(
type
)
fLeft
(
nullptr
)
fRight
(
nullptr
)
fPrevEdgeAbove
(
nullptr
)
fNextEdgeAbove
(
nullptr
)
fPrevEdgeBelow
(
nullptr
)
fNextEdgeBelow
(
nullptr
)
fLeftPoly
(
nullptr
)
fRightPoly
(
nullptr
)
fLeftPolyPrev
(
nullptr
)
fLeftPolyNext
(
nullptr
)
fRightPolyPrev
(
nullptr
)
fRightPolyNext
(
nullptr
)
fUsedInLeftPoly
(
false
)
fUsedInRightPoly
(
false
)
fLine
(
top
bottom
)
{
}
int
fWinding
;
Vertex
*
fTop
;
Vertex
*
fBottom
;
EdgeType
fType
;
Edge
*
fLeft
;
Edge
*
fRight
;
Edge
*
fPrevEdgeAbove
;
Edge
*
fNextEdgeAbove
;
Edge
*
fPrevEdgeBelow
;
Edge
*
fNextEdgeBelow
;
Poly
*
fLeftPoly
;
Poly
*
fRightPoly
;
Edge
*
fLeftPolyPrev
;
Edge
*
fLeftPolyNext
;
Edge
*
fRightPolyPrev
;
Edge
*
fRightPolyNext
;
bool
fUsedInLeftPoly
;
bool
fUsedInRightPoly
;
Line
fLine
;
double
dist
(
const
SkPoint
&
p
)
const
{
return
(
p
=
=
fTop
-
>
fPoint
|
|
p
=
=
fBottom
-
>
fPoint
)
?
0
.
0
:
fLine
.
dist
(
p
)
;
}
bool
isRightOf
(
Vertex
*
v
)
const
{
return
this
-
>
dist
(
v
-
>
fPoint
)
<
0
.
0
;
}
bool
isLeftOf
(
Vertex
*
v
)
const
{
return
this
-
>
dist
(
v
-
>
fPoint
)
>
0
.
0
;
}
void
recompute
(
)
{
fLine
=
Line
(
fTop
fBottom
)
;
}
void
insertAbove
(
Vertex
*
const
Comparator
&
)
;
void
insertBelow
(
Vertex
*
const
Comparator
&
)
;
void
disconnect
(
)
;
bool
intersect
(
const
Edge
&
other
SkPoint
*
p
uint8_t
*
alpha
=
nullptr
)
const
;
}
;
struct
GrTriangulator
:
:
EdgeList
{
EdgeList
(
)
:
fHead
(
nullptr
)
fTail
(
nullptr
)
{
}
Edge
*
fHead
;
Edge
*
fTail
;
void
insert
(
Edge
*
edge
Edge
*
prev
Edge
*
next
)
;
void
insert
(
Edge
*
edge
Edge
*
prev
)
;
void
append
(
Edge
*
e
)
{
insert
(
e
fTail
nullptr
)
;
}
void
remove
(
Edge
*
edge
)
;
void
removeAll
(
)
{
while
(
fHead
)
{
this
-
>
remove
(
fHead
)
;
}
}
void
close
(
)
{
if
(
fHead
&
&
fTail
)
{
fTail
-
>
fRight
=
fHead
;
fHead
-
>
fLeft
=
fTail
;
}
}
bool
contains
(
Edge
*
edge
)
const
{
return
edge
-
>
fLeft
|
|
edge
-
>
fRight
|
|
fHead
=
=
edge
;
}
}
;
struct
GrTriangulator
:
:
MonotonePoly
{
MonotonePoly
(
Edge
*
edge
Side
side
int
winding
)
:
fSide
(
side
)
fFirstEdge
(
nullptr
)
fLastEdge
(
nullptr
)
fPrev
(
nullptr
)
fNext
(
nullptr
)
fWinding
(
winding
)
{
this
-
>
addEdge
(
edge
)
;
}
Side
fSide
;
Edge
*
fFirstEdge
;
Edge
*
fLastEdge
;
MonotonePoly
*
fPrev
;
MonotonePoly
*
fNext
;
int
fWinding
;
void
addEdge
(
Edge
*
)
;
}
;
struct
GrTriangulator
:
:
Poly
{
Poly
(
Vertex
*
v
int
winding
)
;
Poly
*
addEdge
(
Edge
*
e
Side
side
GrTriangulator
*
)
;
Vertex
*
lastVertex
(
)
const
{
return
fTail
?
fTail
-
>
fLastEdge
-
>
fBottom
:
fFirstVertex
;
}
Vertex
*
fFirstVertex
;
int
fWinding
;
MonotonePoly
*
fHead
;
MonotonePoly
*
fTail
;
Poly
*
fNext
;
Poly
*
fPartner
;
int
fCount
;
#
if
TRIANGULATOR_LOGGING
int
fID
;
#
endif
}
;
struct
GrTriangulator
:
:
Comparator
{
enum
class
Direction
{
kVertical
kHorizontal
}
;
Comparator
(
Direction
direction
)
:
fDirection
(
direction
)
{
}
bool
sweep_lt
(
const
SkPoint
&
a
const
SkPoint
&
b
)
const
;
Direction
fDirection
;
}
;
#
endif
#
endif
