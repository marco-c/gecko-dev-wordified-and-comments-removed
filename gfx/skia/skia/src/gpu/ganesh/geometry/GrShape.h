#
ifndef
GrShape_DEFINED
#
define
GrShape_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
struct
GrArc
{
SkRect
fOval
;
SkScalar
fStartAngle
;
SkScalar
fSweepAngle
;
bool
fUseCenter
;
}
;
struct
GrLineSegment
{
SkPoint
fP1
;
SkPoint
fP2
;
}
;
class
GrShape
{
public
:
enum
class
Type
:
uint8_t
{
kEmpty
kPoint
kRect
kRRect
kPath
kArc
kLine
}
;
inline
static
constexpr
int
kTypeCount
=
static_cast
<
int
>
(
Type
:
:
kLine
)
+
1
;
inline
static
constexpr
SkPathDirection
kDefaultDir
=
SkPathDirection
:
:
kCW
;
inline
static
constexpr
unsigned
kDefaultStart
=
0
;
inline
static
constexpr
SkPathFillType
kDefaultFillType
=
SkPathFillType
:
:
kEvenOdd
;
GrShape
(
)
{
}
explicit
GrShape
(
const
SkPoint
&
point
)
{
this
-
>
setPoint
(
point
)
;
}
explicit
GrShape
(
const
SkRect
&
rect
)
{
this
-
>
setRect
(
rect
)
;
}
explicit
GrShape
(
const
SkRRect
&
rrect
)
{
this
-
>
setRRect
(
rrect
)
;
}
explicit
GrShape
(
const
SkPath
&
path
)
{
this
-
>
setPath
(
path
)
;
}
explicit
GrShape
(
const
GrArc
&
arc
)
{
this
-
>
setArc
(
arc
)
;
}
explicit
GrShape
(
const
GrLineSegment
&
line
)
{
this
-
>
setLine
(
line
)
;
}
GrShape
(
const
GrShape
&
shape
)
{
*
this
=
shape
;
}
~
GrShape
(
)
{
this
-
>
reset
(
)
;
}
GrShape
&
operator
=
(
const
GrShape
&
shape
)
;
bool
isEmpty
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kEmpty
;
}
bool
isPoint
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kPoint
;
}
bool
isRect
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kRect
;
}
bool
isRRect
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kRRect
;
}
bool
isPath
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kPath
;
}
bool
isArc
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kArc
;
}
bool
isLine
(
)
const
{
return
this
-
>
type
(
)
=
=
Type
:
:
kLine
;
}
Type
type
(
)
const
{
return
fType
;
}
uint32_t
stateKey
(
)
const
;
bool
inverted
(
)
const
{
return
this
-
>
isPath
(
)
?
fPath
.
isInverseFillType
(
)
:
SkToBool
(
fInverted
)
;
}
SkPathDirection
dir
(
)
const
{
return
fCW
?
SkPathDirection
:
:
kCW
:
SkPathDirection
:
:
kCCW
;
}
unsigned
startIndex
(
)
const
{
return
fStart
;
}
void
setPathWindingParams
(
SkPathDirection
dir
unsigned
start
)
{
SkASSERT
(
(
this
-
>
isRect
(
)
&
&
start
<
4
)
|
|
(
this
-
>
isRRect
(
)
&
&
start
<
8
)
|
|
(
dir
=
=
kDefaultDir
&
&
start
=
=
kDefaultStart
)
)
;
fCW
=
dir
=
=
SkPathDirection
:
:
kCW
;
fStart
=
static_cast
<
uint8_t
>
(
start
)
;
}
void
setInverted
(
bool
inverted
)
{
if
(
this
-
>
isPath
(
)
)
{
if
(
inverted
!
=
fPath
.
isInverseFillType
(
)
)
{
fPath
.
toggleInverseFillType
(
)
;
}
}
else
{
fInverted
=
inverted
;
}
}
SkPoint
&
point
(
)
{
SkASSERT
(
this
-
>
isPoint
(
)
)
;
return
fPoint
;
}
const
SkPoint
&
point
(
)
const
{
SkASSERT
(
this
-
>
isPoint
(
)
)
;
return
fPoint
;
}
SkRect
&
rect
(
)
{
SkASSERT
(
this
-
>
isRect
(
)
)
;
return
fRect
;
}
const
SkRect
&
rect
(
)
const
{
SkASSERT
(
this
-
>
isRect
(
)
)
;
return
fRect
;
}
SkRRect
&
rrect
(
)
{
SkASSERT
(
this
-
>
isRRect
(
)
)
;
return
fRRect
;
}
const
SkRRect
&
rrect
(
)
const
{
SkASSERT
(
this
-
>
isRRect
(
)
)
;
return
fRRect
;
}
SkPath
&
path
(
)
{
SkASSERT
(
this
-
>
isPath
(
)
)
;
return
fPath
;
}
const
SkPath
&
path
(
)
const
{
SkASSERT
(
this
-
>
isPath
(
)
)
;
return
fPath
;
}
GrArc
&
arc
(
)
{
SkASSERT
(
this
-
>
isArc
(
)
)
;
return
fArc
;
}
const
GrArc
&
arc
(
)
const
{
SkASSERT
(
this
-
>
isArc
(
)
)
;
return
fArc
;
}
GrLineSegment
&
line
(
)
{
SkASSERT
(
this
-
>
isLine
(
)
)
;
return
fLine
;
}
const
GrLineSegment
&
line
(
)
const
{
SkASSERT
(
this
-
>
isLine
(
)
)
;
return
fLine
;
}
void
setPoint
(
const
SkPoint
&
point
)
{
this
-
>
reset
(
Type
:
:
kPoint
)
;
fPoint
=
point
;
}
void
setRect
(
const
SkRect
&
rect
)
{
this
-
>
reset
(
Type
:
:
kRect
)
;
fRect
=
rect
;
}
void
setRRect
(
const
SkRRect
&
rrect
)
{
this
-
>
reset
(
Type
:
:
kRRect
)
;
fRRect
=
rrect
;
}
void
setArc
(
const
GrArc
&
arc
)
{
this
-
>
reset
(
Type
:
:
kArc
)
;
fArc
=
arc
;
}
void
setLine
(
const
GrLineSegment
&
line
)
{
this
-
>
reset
(
Type
:
:
kLine
)
;
fLine
=
line
;
}
void
setPath
(
const
SkPath
&
path
)
{
if
(
this
-
>
isPath
(
)
)
{
fPath
=
path
;
}
else
{
this
-
>
setType
(
Type
:
:
kPath
)
;
new
(
&
fPath
)
SkPath
(
path
)
;
}
this
-
>
setPathWindingParams
(
kDefaultDir
kDefaultStart
)
;
fInverted
=
path
.
isInverseFillType
(
)
;
}
void
reset
(
)
{
this
-
>
reset
(
Type
:
:
kEmpty
)
;
}
enum
SimplifyFlags
:
unsigned
{
kSimpleFill_Flag
=
0b001
kIgnoreWinding_Flag
=
0b010
kMakeCanonical_Flag
=
0b100
kAll_Flags
=
0b111
}
;
bool
simplify
(
unsigned
flags
=
kAll_Flags
)
;
bool
conservativeContains
(
const
SkRect
&
rect
)
const
;
bool
conservativeContains
(
const
SkPoint
&
point
)
const
;
bool
closed
(
)
const
;
bool
convex
(
bool
simpleFill
=
true
)
const
;
SkRect
bounds
(
)
const
;
uint32_t
segmentMask
(
)
const
;
void
asPath
(
SkPath
*
out
bool
simpleFill
=
true
)
const
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
private
:
void
setType
(
Type
type
)
{
if
(
this
-
>
isPath
(
)
&
&
type
!
=
Type
:
:
kPath
)
{
fInverted
=
fPath
.
isInverseFillType
(
)
;
fPath
.
~
SkPath
(
)
;
}
fType
=
type
;
}
void
reset
(
Type
type
)
{
this
-
>
setType
(
type
)
;
this
-
>
setPathWindingParams
(
kDefaultDir
kDefaultStart
)
;
this
-
>
setInverted
(
false
)
;
}
bool
simplifyPath
(
unsigned
flags
)
;
bool
simplifyArc
(
unsigned
flags
)
;
void
simplifyLine
(
const
SkPoint
&
p1
const
SkPoint
&
p2
unsigned
flags
)
;
void
simplifyPoint
(
const
SkPoint
&
point
unsigned
flags
)
;
void
simplifyRRect
(
const
SkRRect
&
rrect
SkPathDirection
dir
unsigned
start
unsigned
flags
)
;
void
simplifyRect
(
const
SkRect
&
rect
SkPathDirection
dir
unsigned
start
unsigned
flags
)
;
union
{
SkPoint
fPoint
;
SkRect
fRect
;
SkRRect
fRRect
;
SkPath
fPath
;
GrArc
fArc
;
GrLineSegment
fLine
;
}
;
Type
fType
=
Type
:
:
kEmpty
;
uint8_t
fStart
;
bool
fCW
;
bool
fInverted
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fPoint
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fRect
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fRRect
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fPath
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fArc
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fLine
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fType
)
>
:
:
value
)
;
}
;
#
endif
