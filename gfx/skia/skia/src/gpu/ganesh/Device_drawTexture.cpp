#
include
"
src
/
gpu
/
ganesh
/
Device_v1
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkImagePriv
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkSamplingPriv
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBlurUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorSpaceXform
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFPArgs
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpsTypes
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBicubicEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBlendFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrRect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
src
/
image
/
SkImage_Base
.
h
"
#
include
"
src
/
image
/
SkImage_Gpu
.
h
"
using
namespace
skia_private
;
namespace
{
inline
bool
use_shader
(
bool
textureIsAlphaOnly
const
SkPaint
&
paint
)
{
return
textureIsAlphaOnly
&
&
paint
.
getShader
(
)
;
}
static
const
SkScalar
kColorBleedTolerance
=
0
.
001f
;
bool
has_aligned_samples
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
)
{
if
(
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
left
(
)
)
-
transformedRect
.
left
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
top
(
)
)
-
transformedRect
.
top
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
width
(
)
-
srcRect
.
width
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
height
(
)
-
srcRect
.
height
(
)
)
<
kColorBleedTolerance
)
{
return
true
;
}
return
false
;
}
bool
may_color_bleed
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
const
SkMatrix
&
m
int
numSamples
)
{
SkASSERT
(
!
has_aligned_samples
(
srcRect
transformedRect
)
)
;
SkRect
innerSrcRect
(
srcRect
)
innerTransformedRect
outerTransformedRect
(
transformedRect
)
;
if
(
numSamples
>
1
)
{
innerSrcRect
.
inset
(
SK_Scalar1
SK_Scalar1
)
;
}
else
{
innerSrcRect
.
inset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
m
.
mapRect
(
&
innerTransformedRect
innerSrcRect
)
;
outerTransformedRect
.
inset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
innerTransformedRect
.
outset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
SkIRect
outer
inner
;
outerTransformedRect
.
round
(
&
outer
)
;
innerTransformedRect
.
round
(
&
inner
)
;
return
inner
!
=
outer
;
}
bool
can_ignore_linear_filtering_subset
(
const
SkRect
&
srcSubset
const
SkMatrix
&
srcRectToDeviceSpace
int
numSamples
)
{
if
(
srcRectToDeviceSpace
.
rectStaysRect
(
)
)
{
SkRect
transformedRect
;
srcRectToDeviceSpace
.
mapRect
(
&
transformedRect
srcSubset
)
;
if
(
has_aligned_samples
(
srcSubset
transformedRect
)
|
|
!
may_color_bleed
(
srcSubset
transformedRect
srcRectToDeviceSpace
numSamples
)
)
{
return
true
;
}
}
return
false
;
}
static
const
int
kBmpSmallTileSize
=
1
<
<
10
;
inline
size_t
get_tile_count
(
const
SkIRect
&
srcRect
int
tileSize
)
{
int
tilesX
=
(
srcRect
.
fRight
/
tileSize
)
-
(
srcRect
.
fLeft
/
tileSize
)
+
1
;
int
tilesY
=
(
srcRect
.
fBottom
/
tileSize
)
-
(
srcRect
.
fTop
/
tileSize
)
+
1
;
return
SkSafeMath
:
:
Mul
(
tilesX
tilesY
)
;
}
int
determine_tile_size
(
const
SkIRect
&
src
int
maxTileSize
)
{
if
(
maxTileSize
<
=
kBmpSmallTileSize
)
{
return
maxTileSize
;
}
size_t
maxTileTotalTileSize
=
get_tile_count
(
src
maxTileSize
)
;
size_t
smallTotalTileSize
=
get_tile_count
(
src
kBmpSmallTileSize
)
;
maxTileTotalTileSize
*
=
maxTileSize
*
maxTileSize
;
smallTotalTileSize
*
=
kBmpSmallTileSize
*
kBmpSmallTileSize
;
if
(
maxTileTotalTileSize
>
2
*
smallTotalTileSize
)
{
return
kBmpSmallTileSize
;
}
else
{
return
maxTileSize
;
}
}
SkIRect
determine_clipped_src_rect
(
int
width
int
height
const
GrClip
*
clip
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstRect
const
SkISize
&
imageDimensions
const
SkRect
*
srcRectPtr
)
{
SkIRect
clippedSrcIRect
=
clip
?
clip
-
>
getConservativeBounds
(
)
:
SkIRect
:
:
MakeWH
(
width
height
)
;
SkMatrix
inv
=
SkMatrix
:
:
Concat
(
viewMatrix
srcToDstRect
)
;
if
(
!
inv
.
invert
(
&
inv
)
)
{
return
SkIRect
:
:
MakeEmpty
(
)
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
clippedSrcIRect
)
;
inv
.
mapRect
(
&
clippedSrcRect
)
;
if
(
srcRectPtr
)
{
if
(
!
clippedSrcRect
.
intersect
(
*
srcRectPtr
)
)
{
return
SkIRect
:
:
MakeEmpty
(
)
;
}
}
clippedSrcRect
.
roundOut
(
&
clippedSrcIRect
)
;
SkIRect
bmpBounds
=
SkIRect
:
:
MakeSize
(
imageDimensions
)
;
if
(
!
clippedSrcIRect
.
intersect
(
bmpBounds
)
)
{
return
SkIRect
:
:
MakeEmpty
(
)
;
}
return
clippedSrcIRect
;
}
bool
should_tile_image_id
(
GrRecordingContext
*
context
SkISize
rtSize
const
GrClip
*
clip
uint32_t
imageID
const
SkISize
&
imageSize
const
SkMatrix
&
ctm
const
SkMatrix
&
srcToDst
const
SkRect
*
src
int
maxTileSize
int
*
tileSize
SkIRect
*
clippedSubset
)
{
if
(
imageSize
.
width
(
)
>
maxTileSize
|
|
imageSize
.
height
(
)
>
maxTileSize
)
{
*
clippedSubset
=
determine_clipped_src_rect
(
rtSize
.
width
(
)
rtSize
.
height
(
)
clip
ctm
srcToDst
imageSize
src
)
;
*
tileSize
=
determine_tile_size
(
*
clippedSubset
maxTileSize
)
;
return
true
;
}
const
size_t
area
=
imageSize
.
width
(
)
*
imageSize
.
height
(
)
;
if
(
area
<
4
*
kBmpSmallTileSize
*
kBmpSmallTileSize
)
{
return
false
;
}
auto
direct
=
context
-
>
asDirectContext
(
)
;
if
(
!
direct
)
{
return
false
;
}
size_t
bmpSize
=
area
*
sizeof
(
SkPMColor
)
;
size_t
cacheSize
=
direct
-
>
getResourceCacheLimit
(
)
;
if
(
bmpSize
<
cacheSize
/
2
)
{
return
false
;
}
*
clippedSubset
=
determine_clipped_src_rect
(
rtSize
.
width
(
)
rtSize
.
height
(
)
clip
ctm
srcToDst
imageSize
src
)
;
*
tileSize
=
kBmpSmallTileSize
;
size_t
usedTileBytes
=
get_tile_count
(
*
clippedSubset
kBmpSmallTileSize
)
*
kBmpSmallTileSize
*
kBmpSmallTileSize
*
sizeof
(
SkPMColor
)
;
return
usedTileBytes
*
2
<
bmpSize
;
}
inline
void
clamped_outset_with_offset
(
SkIRect
*
iRect
int
outset
SkPoint
*
offset
const
SkIRect
&
clamp
)
{
iRect
-
>
outset
(
outset
outset
)
;
int
leftClampDelta
=
clamp
.
fLeft
-
iRect
-
>
fLeft
;
if
(
leftClampDelta
>
0
)
{
offset
-
>
fX
-
=
outset
-
leftClampDelta
;
iRect
-
>
fLeft
=
clamp
.
fLeft
;
}
else
{
offset
-
>
fX
-
=
outset
;
}
int
topClampDelta
=
clamp
.
fTop
-
iRect
-
>
fTop
;
if
(
topClampDelta
>
0
)
{
offset
-
>
fY
-
=
outset
-
topClampDelta
;
iRect
-
>
fTop
=
clamp
.
fTop
;
}
else
{
offset
-
>
fY
-
=
outset
;
}
if
(
iRect
-
>
fRight
>
clamp
.
fRight
)
{
iRect
-
>
fRight
=
clamp
.
fRight
;
}
if
(
iRect
-
>
fBottom
>
clamp
.
fBottom
)
{
iRect
-
>
fBottom
=
clamp
.
fBottom
;
}
}
enum
class
ImageDrawMode
{
kOptimized
kDecal
kSkip
}
;
ImageDrawMode
optimize_sample_area
(
const
SkISize
&
image
const
SkRect
*
origSrcRect
const
SkRect
*
origDstRect
const
SkPoint
dstClip
[
4
]
SkRect
*
outSrcRect
SkRect
*
outDstRect
SkMatrix
*
srcToDst
)
{
SkRect
srcBounds
=
SkRect
:
:
MakeIWH
(
image
.
fWidth
image
.
fHeight
)
;
SkRect
src
=
origSrcRect
?
*
origSrcRect
:
srcBounds
;
SkRect
dst
=
origDstRect
?
*
origDstRect
:
src
;
if
(
src
.
isEmpty
(
)
|
|
dst
.
isEmpty
(
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
if
(
outDstRect
)
{
*
srcToDst
=
SkMatrix
:
:
RectToRect
(
src
dst
)
;
}
else
{
srcToDst
-
>
setIdentity
(
)
;
}
if
(
origSrcRect
&
&
!
srcBounds
.
contains
(
src
)
)
{
if
(
!
src
.
intersect
(
srcBounds
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
srcToDst
-
>
mapRect
(
&
dst
src
)
;
if
(
dstClip
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
!
dst
.
contains
(
dstClip
[
i
]
.
fX
dstClip
[
i
]
.
fY
)
)
{
*
outSrcRect
=
src
;
*
outDstRect
=
(
origDstRect
?
*
origDstRect
:
(
origSrcRect
?
*
origSrcRect
:
srcBounds
)
)
;
return
ImageDrawMode
:
:
kDecal
;
}
}
}
}
*
outSrcRect
=
src
;
*
outDstRect
=
dst
;
return
ImageDrawMode
:
:
kOptimized
;
}
bool
can_use_draw_texture
(
const
SkPaint
&
paint
const
SkSamplingOptions
&
sampling
)
{
return
(
!
paint
.
getColorFilter
(
)
&
&
!
paint
.
getShader
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
&
&
!
paint
.
getBlender
(
)
&
&
!
sampling
.
isAniso
(
)
&
&
!
sampling
.
useCubic
&
&
sampling
.
mipmap
=
=
SkMipmapMode
:
:
kNone
)
;
}
SkPMColor4f
texture_color
(
SkColor4f
paintColor
float
entryAlpha
GrColorType
srcColorType
const
GrColorInfo
&
dstColorInfo
)
{
paintColor
.
fA
*
=
entryAlpha
;
if
(
GrColorTypeIsAlphaOnly
(
srcColorType
)
)
{
return
SkColor4fPrepForDst
(
paintColor
dstColorInfo
)
.
premul
(
)
;
}
else
{
float
paintAlpha
=
SkTPin
(
paintColor
.
fA
0
.
f
1
.
f
)
;
return
{
paintAlpha
paintAlpha
paintAlpha
paintAlpha
}
;
}
}
void
draw_texture
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
SkMatrix
&
ctm
const
SkPaint
&
paint
GrSamplerState
:
:
Filter
filter
const
SkRect
&
srcRect
const
SkRect
&
dstRect
const
SkPoint
dstClip
[
4
]
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
GrSurfaceProxyView
view
const
GrColorInfo
&
srcColorInfo
)
{
if
(
GrColorTypeIsAlphaOnly
(
srcColorInfo
.
colorType
(
)
)
)
{
view
.
concatSwizzle
(
skgpu
:
:
Swizzle
(
"
aaaa
"
)
)
;
}
const
GrColorInfo
&
dstInfo
=
sdc
-
>
colorInfo
(
)
;
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
srcColorInfo
sdc
-
>
colorInfo
(
)
)
;
GrSurfaceProxy
*
proxy
=
view
.
proxy
(
)
;
if
(
constraint
!
=
SkCanvas
:
:
kStrict_SrcRectConstraint
&
&
!
proxy
-
>
isFunctionallyExact
(
)
)
{
float
buffer
=
0
.
5f
*
(
aaFlags
!
=
GrQuadAAFlags
:
:
kNone
)
+
0
.
5f
*
(
filter
=
=
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
SkRect
safeBounds
=
proxy
-
>
getBoundsRect
(
)
;
safeBounds
.
inset
(
buffer
buffer
)
;
if
(
!
safeBounds
.
contains
(
srcRect
)
)
{
constraint
=
SkCanvas
:
:
kStrict_SrcRectConstraint
;
}
}
SkPMColor4f
color
=
texture_color
(
paint
.
getColor4f
(
)
1
.
f
srcColorInfo
.
colorType
(
)
dstInfo
)
;
if
(
dstClip
)
{
SkPoint
srcQuad
[
4
]
;
GrMapRectPoints
(
dstRect
srcRect
dstClip
srcQuad
4
)
;
sdc
-
>
drawTextureQuad
(
clip
std
:
:
move
(
view
)
srcColorInfo
.
colorType
(
)
srcColorInfo
.
alphaType
(
)
filter
GrSamplerState
:
:
MipmapMode
:
:
kNone
paint
.
getBlendMode_or
(
SkBlendMode
:
:
kSrcOver
)
color
srcQuad
dstClip
aaFlags
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
ctm
std
:
:
move
(
textureXform
)
)
;
}
else
{
sdc
-
>
drawTexture
(
clip
std
:
:
move
(
view
)
srcColorInfo
.
alphaType
(
)
filter
GrSamplerState
:
:
MipmapMode
:
:
kNone
paint
.
getBlendMode_or
(
SkBlendMode
:
:
kSrcOver
)
color
srcRect
dstRect
aaFlags
constraint
ctm
std
:
:
move
(
textureXform
)
)
;
}
}
void
draw_image
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
SkMatrixProvider
&
matrixProvider
const
SkPaint
&
paint
const
SkImage_Base
&
image
const
SkRect
&
src
const
SkRect
&
dst
const
SkPoint
dstClip
[
4
]
const
SkMatrix
&
srcToDst
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
SkSamplingOptions
sampling
SkTileMode
tm
=
SkTileMode
:
:
kClamp
)
{
const
SkMatrix
&
ctm
(
matrixProvider
.
localToDevice
(
)
)
;
if
(
tm
=
=
SkTileMode
:
:
kClamp
&
&
!
image
.
isYUVA
(
)
&
&
can_use_draw_texture
(
paint
sampling
)
)
{
auto
[
view
ct
]
=
image
.
asView
(
rContext
GrMipmapped
:
:
kNo
)
;
if
(
!
view
)
{
return
;
}
GrColorInfo
info
(
image
.
imageInfo
(
)
.
colorInfo
(
)
)
;
info
=
info
.
makeColorType
(
ct
)
;
draw_texture
(
sdc
clip
ctm
paint
sampling
.
filter
src
dst
dstClip
aaFlags
constraint
std
:
:
move
(
view
)
info
)
;
return
;
}
const
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
bool
canUseTextureCoordsAsLocalCoords
=
!
use_shader
(
image
.
isAlphaOnly
(
)
paint
)
&
&
!
mf
;
if
(
mf
&
&
as_MFB
(
mf
)
-
>
hasFragmentProcessor
(
)
)
{
mf
=
nullptr
;
}
bool
restrictToSubset
=
SkCanvas
:
:
kStrict_SrcRectConstraint
=
=
constraint
;
bool
coordsAllInsideSrcRect
=
aaFlags
=
=
GrQuadAAFlags
:
:
kNone
&
&
!
mf
;
if
(
sampling
.
isAniso
(
)
&
&
!
sampling
.
useCubic
&
&
sampling
.
filter
=
=
SkFilterMode
:
:
kLinear
&
&
restrictToSubset
&
&
sampling
.
mipmap
=
=
SkMipmapMode
:
:
kNone
&
&
coordsAllInsideSrcRect
&
&
!
image
.
isYUVA
(
)
)
{
SkMatrix
combinedMatrix
;
combinedMatrix
.
setConcat
(
ctm
srcToDst
)
;
if
(
can_ignore_linear_filtering_subset
(
src
combinedMatrix
sdc
-
>
numSamples
(
)
)
)
{
restrictToSubset
=
false
;
}
}
SkMatrix
textureMatrix
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
textureMatrix
=
SkMatrix
:
:
I
(
)
;
}
else
{
if
(
!
srcToDst
.
invert
(
&
textureMatrix
)
)
{
return
;
}
}
const
SkRect
*
subset
=
restrictToSubset
?
&
src
:
nullptr
;
const
SkRect
*
domain
=
coordsAllInsideSrcRect
?
&
src
:
nullptr
;
SkTileMode
tileModes
[
]
=
{
tm
tm
}
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
=
image
.
asFragmentProcessor
(
rContext
sampling
tileModes
textureMatrix
subset
domain
)
;
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
image
.
imageInfo
(
)
.
colorInfo
(
)
sdc
-
>
colorInfo
(
)
)
;
if
(
image
.
isAlphaOnly
(
)
)
{
if
(
const
auto
*
shader
=
as_SB
(
paint
.
getShader
(
)
)
)
{
auto
shaderFP
=
shader
-
>
asRootFragmentProcessor
(
GrFPArgs
(
rContext
&
sdc
-
>
colorInfo
(
)
sdc
-
>
surfaceProps
(
)
)
matrixProvider
.
localToDevice
(
)
)
;
if
(
!
shaderFP
)
{
return
;
}
fp
=
GrBlendFragmentProcessor
:
:
Make
<
SkBlendMode
:
:
kDstIn
>
(
std
:
:
move
(
fp
)
std
:
:
move
(
shaderFP
)
)
;
}
else
{
fp
=
GrFragmentProcessor
:
:
MulInputByChildAlpha
(
std
:
:
move
(
fp
)
)
;
}
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintReplaceShader
(
rContext
sdc
-
>
colorInfo
(
)
paint
ctm
std
:
:
move
(
fp
)
sdc
-
>
surfaceProps
(
)
&
grPaint
)
)
{
return
;
}
if
(
!
mf
)
{
if
(
dstClip
)
{
SkPoint
srcClipPoints
[
4
]
;
SkPoint
*
srcClip
=
nullptr
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
GrMapRectPoints
(
dst
src
dstClip
srcClipPoints
4
)
;
srcClip
=
srcClipPoints
;
}
sdc
-
>
fillQuadWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aaFlags
ctm
dstClip
srcClip
)
;
}
else
{
sdc
-
>
fillRectWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aaFlags
ctm
dst
canUseTextureCoordsAsLocalCoords
?
&
src
:
nullptr
)
;
}
}
else
{
GrStyledShape
shape
;
if
(
dstClip
)
{
SkPath
path
;
path
.
addPoly
(
dstClip
4
true
)
;
shape
=
GrStyledShape
(
path
)
;
}
else
{
shape
=
GrStyledShape
(
dst
)
;
}
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
rContext
sdc
clip
shape
std
:
:
move
(
grPaint
)
ctm
mf
)
;
}
}
void
draw_tiled_bitmap
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
SkBitmap
&
bitmap
int
tileSize
const
SkMatrixProvider
&
matrixProvider
const
SkMatrix
&
srcToDst
const
SkRect
&
srcRect
const
SkIRect
&
clippedSrcIRect
const
SkPaint
&
paint
GrQuadAAFlags
origAAFlags
SkCanvas
:
:
SrcRectConstraint
constraint
SkSamplingOptions
sampling
SkTileMode
tileMode
)
{
if
(
sampling
.
isAniso
(
)
)
{
sampling
=
SkSamplingPriv
:
:
AnisoFallback
(
false
)
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
clippedSrcIRect
)
;
int
nx
=
bitmap
.
width
(
)
/
tileSize
;
int
ny
=
bitmap
.
height
(
)
/
tileSize
;
for
(
int
x
=
0
;
x
<
=
nx
;
x
+
+
)
{
for
(
int
y
=
0
;
y
<
=
ny
;
y
+
+
)
{
SkRect
tileR
;
tileR
.
setLTRB
(
SkIntToScalar
(
x
*
tileSize
)
SkIntToScalar
(
y
*
tileSize
)
SkIntToScalar
(
(
x
+
1
)
*
tileSize
)
SkIntToScalar
(
(
y
+
1
)
*
tileSize
)
)
;
if
(
!
SkRect
:
:
Intersects
(
tileR
clippedSrcRect
)
)
{
continue
;
}
if
(
!
tileR
.
intersect
(
srcRect
)
)
{
continue
;
}
SkIRect
iTileR
;
tileR
.
roundOut
(
&
iTileR
)
;
SkVector
offset
=
SkPoint
:
:
Make
(
SkIntToScalar
(
iTileR
.
fLeft
)
SkIntToScalar
(
iTileR
.
fTop
)
)
;
SkRect
rectToDraw
=
tileR
;
srcToDst
.
mapRect
(
&
rectToDraw
)
;
if
(
sampling
.
filter
!
=
SkFilterMode
:
:
kNearest
|
|
sampling
.
useCubic
)
{
SkIRect
iClampRect
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
iClampRect
=
SkIRect
:
:
MakeWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
}
else
{
srcRect
.
roundOut
(
&
iClampRect
)
;
}
int
outset
=
sampling
.
useCubic
?
GrBicubicEffect
:
:
kFilterTexelPad
:
1
;
clamped_outset_with_offset
(
&
iTileR
outset
&
offset
iClampRect
)
;
}
if
(
SkBitmap
subsetBmp
;
bitmap
.
extractSubset
(
&
subsetBmp
iTileR
)
)
{
auto
image
=
SkMakeImageFromRasterBitmap
(
subsetBmp
kNever_SkCopyPixelsMode
)
;
SkASSERT
(
image
-
>
width
(
)
<
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
maxTextureSize
(
)
&
&
image
-
>
height
(
)
<
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
maxTextureSize
(
)
)
;
GrQuadAAFlags
aaFlags
=
GrQuadAAFlags
:
:
kNone
;
if
(
tileR
.
fLeft
<
=
srcRect
.
fLeft
&
&
(
origAAFlags
&
GrQuadAAFlags
:
:
kLeft
)
)
{
aaFlags
|
=
GrQuadAAFlags
:
:
kLeft
;
}
if
(
tileR
.
fRight
>
=
srcRect
.
fRight
&
&
(
origAAFlags
&
GrQuadAAFlags
:
:
kRight
)
)
{
aaFlags
|
=
GrQuadAAFlags
:
:
kRight
;
}
if
(
tileR
.
fTop
<
=
srcRect
.
fTop
&
&
(
origAAFlags
&
GrQuadAAFlags
:
:
kTop
)
)
{
aaFlags
|
=
GrQuadAAFlags
:
:
kTop
;
}
if
(
tileR
.
fBottom
>
=
srcRect
.
fBottom
&
&
(
origAAFlags
&
GrQuadAAFlags
:
:
kBottom
)
)
{
aaFlags
|
=
GrQuadAAFlags
:
:
kBottom
;
}
tileR
.
offset
(
-
offset
.
fX
-
offset
.
fY
)
;
SkMatrix
offsetSrcToDst
=
srcToDst
;
offsetSrcToDst
.
preTranslate
(
offset
.
fX
offset
.
fY
)
;
draw_image
(
rContext
sdc
clip
matrixProvider
paint
*
as_IB
(
image
.
get
(
)
)
tileR
rectToDraw
nullptr
offsetSrcToDst
aaFlags
constraint
sampling
tileMode
)
;
}
}
}
}
SkFilterMode
downgrade_to_filter
(
const
SkSamplingOptions
&
sampling
)
{
SkFilterMode
filter
=
sampling
.
filter
;
if
(
sampling
.
isAniso
(
)
|
|
sampling
.
useCubic
|
|
sampling
.
mipmap
!
=
SkMipmapMode
:
:
kNone
)
{
filter
=
SkFilterMode
:
:
kLinear
;
}
return
filter
;
}
bool
can_disable_mipmap
(
const
SkMatrix
&
viewM
const
SkMatrix
&
localM
)
{
SkMatrix
matrix
;
matrix
.
setConcat
(
viewM
localM
)
;
return
matrix
.
getMinScale
(
)
>
=
SK_ScalarRoot2Over2
;
}
}
namespace
skgpu
:
:
ganesh
{
void
Device
:
:
drawSpecial
(
SkSpecialImage
*
special
const
SkMatrix
&
localToDevice
const
SkSamplingOptions
&
origSampling
const
SkPaint
&
paint
)
{
SkASSERT
(
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
)
;
SkASSERT
(
special
-
>
isTextureBacked
(
)
)
;
SkRect
src
=
SkRect
:
:
Make
(
special
-
>
subset
(
)
)
;
SkRect
dst
=
SkRect
:
:
MakeWH
(
special
-
>
width
(
)
special
-
>
height
(
)
)
;
SkMatrix
srcToDst
=
SkMatrix
:
:
RectToRect
(
src
dst
)
;
SkSamplingOptions
sampling
=
SkSamplingOptions
(
downgrade_to_filter
(
origSampling
)
)
;
GrAA
aa
=
fSurfaceDrawContext
-
>
chooseAA
(
paint
)
;
GrQuadAAFlags
aaFlags
=
(
aa
=
=
GrAA
:
:
kYes
)
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
;
GrSurfaceProxyView
view
=
special
-
>
view
(
this
-
>
recordingContext
(
)
)
;
SkImage_Gpu
image
(
sk_ref_sp
(
special
-
>
getContext
(
)
)
special
-
>
uniqueID
(
)
std
:
:
move
(
view
)
special
-
>
colorInfo
(
)
)
;
SkMatrixProvider
matrixProvider
(
localToDevice
)
;
draw_image
(
fContext
.
get
(
)
fSurfaceDrawContext
.
get
(
)
this
-
>
clip
(
)
matrixProvider
paint
image
src
dst
nullptr
srcToDst
aaFlags
SkCanvas
:
:
kStrict_SrcRectConstraint
sampling
)
;
}
void
Device
:
:
drawImageQuad
(
const
SkImage
*
image
const
SkRect
*
srcRect
const
SkRect
*
dstRect
const
SkPoint
dstClip
[
4
]
GrQuadAAFlags
aaFlags
const
SkMatrix
*
preViewMatrix
const
SkSamplingOptions
&
origSampling
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkRect
src
;
SkRect
dst
;
SkMatrix
srcToDst
;
ImageDrawMode
mode
=
optimize_sample_area
(
SkISize
:
:
Make
(
image
-
>
width
(
)
image
-
>
height
(
)
)
srcRect
dstRect
dstClip
&
src
&
dst
&
srcToDst
)
;
if
(
mode
=
=
ImageDrawMode
:
:
kSkip
)
{
return
;
}
if
(
src
.
contains
(
image
-
>
bounds
(
)
)
)
{
constraint
=
SkCanvas
:
:
kFast_SrcRectConstraint
;
}
SkTileMode
tileMode
=
mode
=
=
ImageDrawMode
:
:
kDecal
?
SkTileMode
:
:
kDecal
:
SkTileMode
:
:
kClamp
;
SkPreConcatMatrixProvider
matrixProvider
(
this
-
>
asMatrixProvider
(
)
preViewMatrix
?
*
preViewMatrix
:
SkMatrix
:
:
I
(
)
)
;
const
SkMatrix
&
ctm
(
matrixProvider
.
localToDevice
(
)
)
;
SkSamplingOptions
sampling
=
origSampling
;
if
(
sampling
.
mipmap
!
=
SkMipmapMode
:
:
kNone
&
&
can_disable_mipmap
(
ctm
srcToDst
)
)
{
sampling
=
SkSamplingOptions
(
sampling
.
filter
)
;
}
auto
clip
=
this
-
>
clip
(
)
;
if
(
!
image
-
>
isTextureBacked
(
)
&
&
!
as_IB
(
image
)
-
>
isPinnedOnContext
(
fContext
.
get
(
)
)
)
{
int
tileFilterPad
;
if
(
sampling
.
useCubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
sampling
.
filter
=
=
SkFilterMode
:
:
kLinear
|
|
sampling
.
isAniso
(
)
)
{
tileFilterPad
=
1
;
}
else
{
tileFilterPad
=
0
;
}
int
maxTileSize
=
fContext
-
>
priv
(
)
.
caps
(
)
-
>
maxTextureSize
(
)
-
2
*
tileFilterPad
;
int
tileSize
;
SkIRect
clippedSubset
;
if
(
should_tile_image_id
(
fContext
.
get
(
)
fSurfaceDrawContext
-
>
dimensions
(
)
clip
image
-
>
unique
(
)
image
-
>
dimensions
(
)
ctm
srcToDst
&
src
maxTileSize
&
tileSize
&
clippedSubset
)
)
{
if
(
SkBitmap
bm
;
as_IB
(
image
)
-
>
getROPixels
(
nullptr
&
bm
)
)
{
draw_tiled_bitmap
(
fContext
.
get
(
)
fSurfaceDrawContext
.
get
(
)
clip
bm
tileSize
matrixProvider
srcToDst
src
clippedSubset
paint
aaFlags
constraint
sampling
tileMode
)
;
return
;
}
}
}
draw_image
(
fContext
.
get
(
)
fSurfaceDrawContext
.
get
(
)
clip
matrixProvider
paint
*
as_IB
(
image
)
src
dst
dstClip
srcToDst
aaFlags
constraint
sampling
)
;
return
;
}
void
Device
:
:
drawEdgeAAImageSet
(
const
SkCanvas
:
:
ImageSetEntry
set
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkASSERT
(
count
>
0
)
;
if
(
!
can_use_draw_texture
(
paint
sampling
)
)
{
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
set
[
i
]
.
fHasClip
|
|
dstClips
)
;
SkASSERT
(
set
[
i
]
.
fMatrixIndex
<
0
|
|
preViewMatrices
)
;
SkTCopyOnFirstWrite
<
SkPaint
>
entryPaint
(
paint
)
;
if
(
set
[
i
]
.
fAlpha
!
=
1
.
f
)
{
auto
paintAlpha
=
paint
.
getAlphaf
(
)
;
entryPaint
.
writable
(
)
-
>
setAlphaf
(
paintAlpha
*
set
[
i
]
.
fAlpha
)
;
}
this
-
>
drawImageQuad
(
set
[
i
]
.
fImage
.
get
(
)
&
set
[
i
]
.
fSrcRect
&
set
[
i
]
.
fDstRect
set
[
i
]
.
fHasClip
?
dstClips
+
dstClipIndex
:
nullptr
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
sampling
*
entryPaint
constraint
)
;
dstClipIndex
+
=
4
*
set
[
i
]
.
fHasClip
;
}
return
;
}
GrSamplerState
:
:
Filter
filter
=
sampling
.
filter
=
=
SkFilterMode
:
:
kNearest
?
GrSamplerState
:
:
Filter
:
:
kNearest
:
GrSamplerState
:
:
Filter
:
:
kLinear
;
SkBlendMode
mode
=
paint
.
getBlendMode_or
(
SkBlendMode
:
:
kSrcOver
)
;
AutoTArray
<
GrTextureSetEntry
>
textures
(
count
)
;
int
base
=
0
n
=
0
p
=
0
;
auto
draw
=
[
&
]
(
int
nextBase
)
{
if
(
n
>
0
)
{
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
set
[
base
]
.
fImage
-
>
imageInfo
(
)
.
colorInfo
(
)
fSurfaceDrawContext
-
>
colorInfo
(
)
)
;
fSurfaceDrawContext
-
>
drawTextureSet
(
this
-
>
clip
(
)
textures
.
get
(
)
+
base
n
p
filter
GrSamplerState
:
:
MipmapMode
:
:
kNone
mode
constraint
this
-
>
localToDevice
(
)
std
:
:
move
(
textureXform
)
)
;
}
base
=
nextBase
;
n
=
0
;
p
=
0
;
}
;
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
set
[
i
]
.
fHasClip
|
|
dstClips
)
;
SkASSERT
(
set
[
i
]
.
fMatrixIndex
<
0
|
|
preViewMatrices
)
;
const
SkPoint
*
clip
=
set
[
i
]
.
fHasClip
?
dstClips
+
dstClipIndex
:
nullptr
;
dstClipIndex
+
=
4
*
set
[
i
]
.
fHasClip
;
if
(
!
set
[
i
]
.
fSrcRect
.
isSorted
(
)
)
{
draw
(
i
+
1
)
;
continue
;
}
GrSurfaceProxyView
view
;
const
SkImage_Base
*
image
=
as_IB
(
set
[
i
]
.
fImage
.
get
(
)
)
;
if
(
!
image
-
>
isYUVA
(
)
)
{
std
:
:
tie
(
view
std
:
:
ignore
)
=
image
-
>
asView
(
this
-
>
recordingContext
(
)
GrMipmapped
:
:
kNo
)
;
if
(
image
-
>
isAlphaOnly
(
)
)
{
skgpu
:
:
Swizzle
swizzle
=
skgpu
:
:
Swizzle
:
:
Concat
(
view
.
swizzle
(
)
skgpu
:
:
Swizzle
(
"
aaaa
"
)
)
;
view
=
{
view
.
detachProxy
(
)
view
.
origin
(
)
swizzle
}
;
}
}
if
(
!
view
)
{
draw
(
i
+
1
)
;
SkTCopyOnFirstWrite
<
SkPaint
>
entryPaint
(
paint
)
;
if
(
set
[
i
]
.
fAlpha
!
=
1
.
f
)
{
auto
paintAlpha
=
paint
.
getAlphaf
(
)
;
entryPaint
.
writable
(
)
-
>
setAlphaf
(
paintAlpha
*
set
[
i
]
.
fAlpha
)
;
}
this
-
>
drawImageQuad
(
image
&
set
[
i
]
.
fSrcRect
&
set
[
i
]
.
fDstRect
clip
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
sampling
*
entryPaint
constraint
)
;
continue
;
}
textures
[
i
]
.
fProxyView
=
std
:
:
move
(
view
)
;
textures
[
i
]
.
fSrcAlphaType
=
image
-
>
alphaType
(
)
;
textures
[
i
]
.
fSrcRect
=
set
[
i
]
.
fSrcRect
;
textures
[
i
]
.
fDstRect
=
set
[
i
]
.
fDstRect
;
textures
[
i
]
.
fDstClipQuad
=
clip
;
textures
[
i
]
.
fPreViewMatrix
=
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
;
textures
[
i
]
.
fColor
=
texture_color
(
paint
.
getColor4f
(
)
set
[
i
]
.
fAlpha
SkColorTypeToGrColorType
(
image
-
>
colorType
(
)
)
fSurfaceDrawContext
-
>
colorInfo
(
)
)
;
textures
[
i
]
.
fAAFlags
=
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
;
if
(
n
>
0
&
&
(
!
GrTextureProxy
:
:
ProxiesAreCompatibleAsDynamicState
(
textures
[
i
]
.
fProxyView
.
proxy
(
)
textures
[
base
]
.
fProxyView
.
proxy
(
)
)
|
|
textures
[
i
]
.
fProxyView
.
swizzle
(
)
!
=
textures
[
base
]
.
fProxyView
.
swizzle
(
)
|
|
set
[
i
]
.
fImage
-
>
alphaType
(
)
!
=
set
[
base
]
.
fImage
-
>
alphaType
(
)
|
|
!
SkColorSpace
:
:
Equals
(
set
[
i
]
.
fImage
-
>
colorSpace
(
)
set
[
base
]
.
fImage
-
>
colorSpace
(
)
)
)
)
{
draw
(
i
)
;
}
+
+
n
;
if
(
n
=
=
1
|
|
textures
[
i
-
1
]
.
fProxyView
.
proxy
(
)
!
=
textures
[
i
]
.
fProxyView
.
proxy
(
)
)
{
+
+
p
;
}
}
draw
(
count
)
;
}
}
