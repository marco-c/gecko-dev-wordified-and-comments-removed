#
ifndef
GrAtlasManager_DEFINED
#
define
GrAtlasManager_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDrawOpAtlas
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
namespace
sktext
:
:
gpu
{
class
Glyph
;
}
class
GrResourceProvider
;
class
SkGlyph
;
class
GrTextStrike
;
class
GrAtlasManager
:
public
GrOnFlushCallbackObject
public
skgpu
:
:
AtlasGenerationCounter
{
public
:
GrAtlasManager
(
GrProxyProvider
*
size_t
maxTextureBytes
GrDrawOpAtlas
:
:
AllowMultitexturing
bool
supportBilerpAtlas
)
;
~
GrAtlasManager
(
)
override
;
const
GrSurfaceProxyView
*
getViews
(
skgpu
:
:
MaskFormat
format
unsigned
int
*
numActiveProxies
)
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
if
(
this
-
>
initAtlas
(
format
)
)
{
*
numActiveProxies
=
this
-
>
getAtlas
(
format
)
-
>
numActivePages
(
)
;
return
this
-
>
getAtlas
(
format
)
-
>
getViews
(
)
;
}
*
numActiveProxies
=
0
;
return
nullptr
;
}
void
freeAll
(
)
;
bool
hasGlyph
(
skgpu
:
:
MaskFormat
sktext
:
:
gpu
:
:
Glyph
*
)
;
GrDrawOpAtlas
:
:
ErrorCode
addGlyphToAtlas
(
const
SkGlyph
&
sktext
:
:
gpu
:
:
Glyph
*
int
srcPadding
GrResourceProvider
*
GrDeferredUploadTarget
*
)
;
void
addGlyphToBulkAndSetUseToken
(
skgpu
:
:
BulkUsePlotUpdater
*
skgpu
:
:
MaskFormat
sktext
:
:
gpu
:
:
Glyph
*
skgpu
:
:
AtlasToken
)
;
void
setUseTokenBulk
(
const
skgpu
:
:
BulkUsePlotUpdater
&
updater
skgpu
:
:
AtlasToken
token
skgpu
:
:
MaskFormat
format
)
{
this
-
>
getAtlas
(
format
)
-
>
setLastUseTokenBulk
(
updater
token
)
;
}
GrDrawOpAtlas
:
:
ErrorCode
addToAtlas
(
GrResourceProvider
*
GrDeferredUploadTarget
*
skgpu
:
:
MaskFormat
int
width
int
height
const
void
*
image
skgpu
:
:
AtlasLocator
*
)
;
uint64_t
atlasGeneration
(
skgpu
:
:
MaskFormat
format
)
const
{
return
this
-
>
getAtlas
(
format
)
-
>
atlasGeneration
(
)
;
}
bool
preFlush
(
GrOnFlushResourceProvider
*
onFlushRP
)
override
{
#
if
GR_TEST_UTILS
if
(
onFlushRP
-
>
failFlushTimeCallbacks
(
)
)
{
return
false
;
}
#
endif
for
(
int
i
=
0
;
i
<
skgpu
:
:
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
instantiate
(
onFlushRP
)
;
}
}
return
true
;
}
void
postFlush
(
skgpu
:
:
AtlasToken
startTokenForNextFlush
)
override
{
for
(
int
i
=
0
;
i
<
skgpu
:
:
kMaskFormatCount
;
+
+
i
)
{
if
(
fAtlases
[
i
]
)
{
fAtlases
[
i
]
-
>
compact
(
startTokenForNextFlush
)
;
}
}
}
bool
retainOnFreeGpuResources
(
)
override
{
return
true
;
}
#
ifdef
SK_DEBUG
void
dump
(
GrDirectContext
*
)
const
;
#
endif
void
setAtlasDimensionsToMinimum_ForTesting
(
)
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
bool
initAtlas
(
skgpu
:
:
MaskFormat
)
;
skgpu
:
:
MaskFormat
resolveMaskFormat
(
skgpu
:
:
MaskFormat
format
)
const
{
if
(
skgpu
:
:
MaskFormat
:
:
kA565
=
=
format
&
&
!
fProxyProvider
-
>
caps
(
)
-
>
getDefaultBackendFormat
(
GrColorType
:
:
kBGR_565
GrRenderable
:
:
kNo
)
.
isValid
(
)
)
{
format
=
skgpu
:
:
MaskFormat
:
:
kARGB
;
}
return
format
;
}
static
int
MaskFormatToAtlasIndex
(
skgpu
:
:
MaskFormat
format
)
{
return
static_cast
<
int
>
(
format
)
;
}
static
skgpu
:
:
MaskFormat
AtlasIndexToMaskFormat
(
int
idx
)
{
return
static_cast
<
skgpu
:
:
MaskFormat
>
(
idx
)
;
}
GrDrawOpAtlas
*
getAtlas
(
skgpu
:
:
MaskFormat
format
)
const
{
format
=
this
-
>
resolveMaskFormat
(
format
)
;
int
atlasIndex
=
MaskFormatToAtlasIndex
(
format
)
;
SkASSERT
(
fAtlases
[
atlasIndex
]
)
;
return
fAtlases
[
atlasIndex
]
.
get
(
)
;
}
GrDrawOpAtlas
:
:
AllowMultitexturing
fAllowMultitexturing
;
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
fAtlases
[
skgpu
:
:
kMaskFormatCount
]
;
static_assert
(
skgpu
:
:
kMaskFormatCount
=
=
3
)
;
bool
fSupportBilerpAtlas
;
GrProxyProvider
*
fProxyProvider
;
sk_sp
<
const
GrCaps
>
fCaps
;
GrDrawOpAtlasConfig
fAtlasConfig
;
using
INHERITED
=
GrOnFlushCallbackObject
;
}
;
#
endif
