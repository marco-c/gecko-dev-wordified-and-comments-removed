#
ifndef
GrDrawingManager_DEFINED
#
define
GrDrawingManager_DEFINED
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBufferAllocPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDeferredUpload
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrHashMapWithCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
PathRenderer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
PathRendererChain
.
h
"
#
define
GR_PATH_RENDERER_SPEW
0
class
GrArenas
;
class
GrGpuBuffer
;
class
GrOnFlushCallbackObject
;
class
GrOpFlushState
;
class
GrRecordingContext
;
class
GrRenderTargetProxy
;
class
GrRenderTask
;
class
GrResourceAllocator
;
class
GrSemaphore
;
class
GrSurfaceProxyView
;
class
GrTextureResolveRenderTask
;
class
SkDeferredDisplayList
;
namespace
skgpu
{
namespace
ganesh
{
class
OpsTask
;
class
SoftwarePathRenderer
;
}
}
class
GrDrawingManager
{
public
:
~
GrDrawingManager
(
)
;
void
freeGpuResources
(
)
;
sk_sp
<
skgpu
:
:
ganesh
:
:
OpsTask
>
newOpsTask
(
GrSurfaceProxyView
sk_sp
<
GrArenas
>
arenas
)
;
void
addAtlasTask
(
sk_sp
<
GrRenderTask
>
atlasTask
GrRenderTask
*
previousAtlasTask
)
;
GrTextureResolveRenderTask
*
newTextureResolveRenderTaskBefore
(
const
GrCaps
&
)
;
void
newTextureResolveRenderTask
(
sk_sp
<
GrSurfaceProxy
>
proxy
GrSurfaceProxy
:
:
ResolveFlags
const
GrCaps
&
)
;
void
newWaitRenderTask
(
sk_sp
<
GrSurfaceProxy
>
proxy
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrSemaphore
>
[
]
>
int
numSemaphores
)
;
void
newTransferFromRenderTask
(
sk_sp
<
GrSurfaceProxy
>
srcProxy
const
SkIRect
&
srcRect
GrColorType
surfaceColorType
GrColorType
dstColorType
sk_sp
<
GrGpuBuffer
>
dstBuffer
size_t
dstOffset
)
;
sk_sp
<
GrRenderTask
>
newCopyRenderTask
(
sk_sp
<
GrSurfaceProxy
>
dst
SkIRect
dstRect
sk_sp
<
GrSurfaceProxy
>
src
SkIRect
srcRect
GrSamplerState
:
:
Filter
filter
GrSurfaceOrigin
)
;
void
newBufferTransferTask
(
sk_sp
<
GrGpuBuffer
>
src
size_t
srcOffset
sk_sp
<
GrGpuBuffer
>
dst
size_t
dstOffset
size_t
size
)
;
void
newBufferUpdateTask
(
sk_sp
<
SkData
>
src
sk_sp
<
GrGpuBuffer
>
dst
size_t
dstOffset
)
;
bool
newWritePixelsTask
(
sk_sp
<
GrSurfaceProxy
>
dst
SkIRect
rect
GrColorType
srcColorType
GrColorType
dstColorType
const
GrMipLevel
[
]
int
levelCount
)
;
GrRecordingContext
*
getContext
(
)
{
return
fContext
;
}
using
PathRenderer
=
skgpu
:
:
ganesh
:
:
PathRenderer
;
using
PathRendererChain
=
skgpu
:
:
ganesh
:
:
PathRendererChain
;
PathRenderer
*
getPathRenderer
(
const
PathRenderer
:
:
CanDrawPathArgs
&
bool
allowSW
PathRendererChain
:
:
DrawType
PathRenderer
:
:
StencilSupport
*
=
nullptr
)
;
PathRenderer
*
getSoftwarePathRenderer
(
)
;
skgpu
:
:
ganesh
:
:
AtlasPathRenderer
*
getAtlasPathRenderer
(
)
;
PathRenderer
*
getTessellationPathRenderer
(
)
;
void
flushIfNecessary
(
)
;
static
bool
ProgramUnitTest
(
GrDirectContext
*
int
maxStages
int
maxLevels
)
;
GrSemaphoresSubmitted
flushSurfaces
(
SkSpan
<
GrSurfaceProxy
*
>
SkSurface
:
:
BackendSurfaceAccess
const
GrFlushInfo
&
const
skgpu
:
:
MutableTextureState
*
newState
)
;
void
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
if
GR_TEST_UTILS
void
testingOnly_removeOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
PathRendererChain
:
:
Options
testingOnly_getOptionsForPathRendererChain
(
)
{
return
fOptionsForPathRendererChain
;
}
#
endif
GrRenderTask
*
getLastRenderTask
(
const
GrSurfaceProxy
*
)
const
;
skgpu
:
:
ganesh
:
:
OpsTask
*
getLastOpsTask
(
const
GrSurfaceProxy
*
)
const
;
void
setLastRenderTask
(
const
GrSurfaceProxy
*
GrRenderTask
*
)
;
void
moveRenderTasksToDDL
(
SkDeferredDisplayList
*
ddl
)
;
void
createDDLTask
(
sk_sp
<
const
SkDeferredDisplayList
>
sk_sp
<
GrRenderTargetProxy
>
newDest
SkIPoint
offset
)
;
bool
flush
(
SkSpan
<
GrSurfaceProxy
*
>
proxies
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
const
skgpu
:
:
MutableTextureState
*
newState
)
;
private
:
GrDrawingManager
(
GrRecordingContext
*
const
PathRendererChain
:
:
Options
&
bool
reduceOpsTaskSplitting
)
;
bool
wasAbandoned
(
)
const
;
void
closeActiveOpsTask
(
)
;
bool
executeRenderTasks
(
GrOpFlushState
*
)
;
void
removeRenderTasks
(
)
;
void
sortTasks
(
)
;
bool
reorderTasks
(
GrResourceAllocator
*
)
;
void
closeAllTasks
(
)
;
GrRenderTask
*
appendTask
(
sk_sp
<
GrRenderTask
>
)
;
GrRenderTask
*
insertTaskBeforeLast
(
sk_sp
<
GrRenderTask
>
)
;
bool
submitToGpu
(
bool
syncToCpu
)
;
SkDEBUGCODE
(
void
validate
(
)
const
)
;
friend
class
GrDirectContext
;
friend
class
GrOnFlushResourceProvider
;
friend
class
GrRecordingContext
;
static
const
int
kNumPixelGeometries
=
5
;
static
const
int
kNumDFTOptions
=
2
;
GrRecordingContext
*
fContext
;
sk_sp
<
GrBufferAllocPool
:
:
CpuBufferCache
>
fCpuBufferCache
;
SkTArray
<
sk_sp
<
GrRenderTask
>
>
fDAG
;
std
:
:
vector
<
int
>
fReorderBlockerTaskIndices
;
skgpu
:
:
ganesh
:
:
OpsTask
*
fActiveOpsTask
=
nullptr
;
PathRendererChain
:
:
Options
fOptionsForPathRendererChain
;
std
:
:
unique_ptr
<
PathRendererChain
>
fPathRendererChain
;
sk_sp
<
skgpu
:
:
ganesh
:
:
SoftwarePathRenderer
>
fSoftwarePathRenderer
;
skgpu
:
:
TokenTracker
fTokenTracker
;
bool
fFlushing
=
false
;
const
bool
fReduceOpsTaskSplitting
;
SkTArray
<
GrOnFlushCallbackObject
*
>
fOnFlushCBObjects
;
struct
SurfaceIDKeyTraits
{
static
uint32_t
GetInvalidKey
(
)
{
return
GrSurfaceProxy
:
:
UniqueID
:
:
InvalidID
(
)
.
asUInt
(
)
;
}
}
;
GrHashMapWithCache
<
uint32_t
GrRenderTask
*
SurfaceIDKeyTraits
GrCheapHash
>
fLastRenderTasks
;
}
;
#
endif
