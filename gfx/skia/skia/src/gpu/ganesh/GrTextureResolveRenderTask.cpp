#
include
"
src
/
gpu
/
ganesh
/
GrTextureResolveRenderTask
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
void
GrTextureResolveRenderTask
:
:
addProxy
(
GrDrawingManager
*
drawingMgr
sk_sp
<
GrSurfaceProxy
>
proxyRef
GrSurfaceProxy
:
:
ResolveFlags
flags
const
GrCaps
&
caps
)
{
GrSurfaceProxy
:
:
ResolveFlags
newFlags
=
flags
;
GrSurfaceProxy
*
proxy
=
proxyRef
.
get
(
)
;
Resolve
*
resolve
;
bool
newProxy
=
false
;
if
(
auto
found
=
std
:
:
find
(
fTargets
.
begin
(
)
fTargets
.
end
(
)
proxyRef
)
;
found
!
=
fTargets
.
end
(
)
)
{
size_t
index
=
found
-
fTargets
.
begin
(
)
;
resolve
=
&
fResolves
[
index
]
;
newFlags
=
~
resolve
-
>
fFlags
&
flags
;
resolve
-
>
fFlags
|
=
flags
;
}
else
{
SkASSERT
(
!
drawingMgr
-
>
getLastRenderTask
(
proxy
)
|
|
drawingMgr
-
>
getLastRenderTask
(
proxy
)
-
>
isClosed
(
)
)
;
SkASSERT
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kNone
!
=
flags
)
;
resolve
=
&
fResolves
.
emplace_back
(
flags
)
;
newProxy
=
true
;
}
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMSAA
&
newFlags
)
{
GrRenderTargetProxy
*
renderTargetProxy
=
proxy
-
>
asRenderTargetProxy
(
)
;
SkASSERT
(
renderTargetProxy
)
;
SkASSERT
(
renderTargetProxy
-
>
isMSAADirty
(
)
)
;
resolve
-
>
fMSAAResolveRect
=
renderTargetProxy
-
>
msaaDirtyRect
(
)
;
renderTargetProxy
-
>
markMSAAResolved
(
)
;
}
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMipMaps
&
newFlags
)
{
GrTextureProxy
*
textureProxy
=
proxy
-
>
asTextureProxy
(
)
;
SkASSERT
(
GrMipmapped
:
:
kYes
=
=
textureProxy
-
>
mipmapped
(
)
)
;
SkASSERT
(
textureProxy
-
>
mipmapsAreDirty
(
)
)
;
textureProxy
-
>
markMipmapsClean
(
)
;
}
if
(
newProxy
)
{
this
-
>
addDependency
(
drawingMgr
proxy
GrMipmapped
:
:
kNo
GrTextureResolveManager
(
nullptr
)
caps
)
;
this
-
>
addTarget
(
drawingMgr
GrSurfaceProxyView
(
std
:
:
move
(
proxyRef
)
)
)
;
}
}
void
GrTextureResolveRenderTask
:
:
gatherProxyIntervals
(
GrResourceAllocator
*
alloc
)
const
{
auto
fakeOp
=
alloc
-
>
curOp
(
)
;
SkASSERT
(
fResolves
.
size
(
)
=
=
this
-
>
numTargets
(
)
)
;
for
(
const
sk_sp
<
GrSurfaceProxy
>
&
target
:
fTargets
)
{
alloc
-
>
addInterval
(
target
.
get
(
)
fakeOp
fakeOp
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
}
alloc
-
>
incOps
(
)
;
}
bool
GrTextureResolveRenderTask
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
SkASSERT
(
fResolves
.
size
(
)
=
=
this
-
>
numTargets
(
)
)
;
for
(
int
i
=
0
;
i
<
fResolves
.
size
(
)
;
+
+
i
)
{
const
Resolve
&
resolve
=
fResolves
[
i
]
;
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMSAA
&
resolve
.
fFlags
)
{
GrSurfaceProxy
*
proxy
=
this
-
>
target
(
i
)
;
if
(
GrRenderTarget
*
renderTarget
=
proxy
-
>
peekRenderTarget
(
)
)
{
flushState
-
>
gpu
(
)
-
>
resolveRenderTarget
(
renderTarget
resolve
.
fMSAAResolveRect
)
;
}
}
}
for
(
int
i
=
0
;
i
<
fResolves
.
size
(
)
;
+
+
i
)
{
const
Resolve
&
resolve
=
fResolves
[
i
]
;
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMipMaps
&
resolve
.
fFlags
)
{
GrTexture
*
texture
=
this
-
>
target
(
i
)
-
>
peekTexture
(
)
;
if
(
texture
&
&
texture
-
>
mipmapsAreDirty
(
)
)
{
flushState
-
>
gpu
(
)
-
>
regenerateMipMapLevels
(
texture
)
;
SkASSERT
(
!
texture
-
>
mipmapsAreDirty
(
)
)
;
}
}
}
return
true
;
}
#
ifdef
SK_DEBUG
void
GrTextureResolveRenderTask
:
:
visitProxies_debugOnly
(
const
GrVisitProxyFunc
&
)
const
{
}
#
endif
#
if
GR_TEST_UTILS
GrSurfaceProxy
:
:
ResolveFlags
GrTextureResolveRenderTask
:
:
flagsForProxy
(
sk_sp
<
GrSurfaceProxy
>
proxy
)
const
{
if
(
auto
found
=
std
:
:
find
(
fTargets
.
begin
(
)
fTargets
.
end
(
)
proxy
)
;
found
!
=
fTargets
.
end
(
)
)
{
return
fResolves
[
found
-
fTargets
.
begin
(
)
]
.
fFlags
;
}
return
GrSurfaceProxy
:
:
ResolveFlags
:
:
kNone
;
}
#
endif
