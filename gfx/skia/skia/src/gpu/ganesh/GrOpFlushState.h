#
ifndef
GrOpFlushState_DEFINED
#
define
GrOpFlushState_DEFINED
#
include
<
utility
>
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
base
/
SkArenaAllocList
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBufferAllocPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDeferredUpload
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMeshDrawTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramInfo
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
class
GrGpu
;
class
GrOpsRenderPass
;
class
GrResourceProvider
;
class
GrOpFlushState
final
:
public
GrDeferredUploadTarget
public
GrMeshDrawTarget
{
public
:
GrOpFlushState
(
GrGpu
*
GrResourceProvider
*
skgpu
:
:
TokenTracker
*
sk_sp
<
GrBufferAllocPool
:
:
CpuBufferCache
>
=
nullptr
)
;
~
GrOpFlushState
(
)
final
{
this
-
>
reset
(
)
;
}
void
preExecuteDraws
(
)
;
void
doUpload
(
GrDeferredTextureUploadFn
&
bool
shouldPrepareSurfaceForSampling
=
false
)
;
void
executeDrawsAndUploadsForMeshDrawOp
(
const
GrOp
*
op
const
SkRect
&
chainBounds
const
GrPipeline
*
const
GrUserStencilSettings
*
)
;
GrOpsRenderPass
*
opsRenderPass
(
)
{
return
fOpsRenderPass
;
}
void
setOpsRenderPass
(
GrOpsRenderPass
*
renderPass
)
{
fOpsRenderPass
=
renderPass
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
void
reset
(
)
;
struct
OpArgs
{
explicit
OpArgs
(
GrOp
*
op
const
GrSurfaceProxyView
&
surfaceView
bool
usesMSAASurface
GrAppliedClip
*
appliedClip
const
GrDstProxyView
&
dstProxyView
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
:
fOp
(
op
)
fSurfaceView
(
surfaceView
)
fRenderTargetProxy
(
surfaceView
.
asRenderTargetProxy
(
)
)
fUsesMSAASurface
(
usesMSAASurface
)
fAppliedClip
(
appliedClip
)
fDstProxyView
(
dstProxyView
)
fRenderPassXferBarriers
(
renderPassXferBarriers
)
fColorLoadOp
(
colorLoadOp
)
{
SkASSERT
(
surfaceView
.
asRenderTargetProxy
(
)
)
;
}
GrOp
*
op
(
)
{
return
fOp
;
}
const
GrSurfaceProxyView
&
writeView
(
)
const
{
return
fSurfaceView
;
}
GrRenderTargetProxy
*
rtProxy
(
)
const
{
return
fRenderTargetProxy
;
}
bool
usesMSAASurface
(
)
const
{
return
fUsesMSAASurface
;
}
GrAppliedClip
*
appliedClip
(
)
{
return
fAppliedClip
;
}
const
GrAppliedClip
*
appliedClip
(
)
const
{
return
fAppliedClip
;
}
const
GrDstProxyView
&
dstProxyView
(
)
const
{
return
fDstProxyView
;
}
GrXferBarrierFlags
renderPassBarriers
(
)
const
{
return
fRenderPassXferBarriers
;
}
GrLoadOp
colorLoadOp
(
)
const
{
return
fColorLoadOp
;
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
fOp
)
;
SkASSERT
(
fSurfaceView
)
;
}
#
endif
private
:
GrOp
*
fOp
;
const
GrSurfaceProxyView
&
fSurfaceView
;
GrRenderTargetProxy
*
fRenderTargetProxy
;
bool
fUsesMSAASurface
;
GrAppliedClip
*
fAppliedClip
;
GrDstProxyView
fDstProxyView
;
GrXferBarrierFlags
fRenderPassXferBarriers
;
GrLoadOp
fColorLoadOp
;
}
;
void
setOpArgs
(
OpArgs
*
opArgs
)
{
fOpArgs
=
opArgs
;
}
const
OpArgs
&
drawOpArgs
(
)
const
{
SkASSERT
(
fOpArgs
)
;
SkDEBUGCODE
(
fOpArgs
-
>
validate
(
)
)
;
return
*
fOpArgs
;
}
void
setSampledProxyArray
(
SkTArray
<
GrSurfaceProxy
*
true
>
*
sampledProxies
)
{
fSampledProxies
=
sampledProxies
;
}
SkTArray
<
GrSurfaceProxy
*
true
>
*
sampledProxyArray
(
)
override
{
return
fSampledProxies
;
}
const
skgpu
:
:
TokenTracker
*
tokenTracker
(
)
final
{
return
fTokenTracker
;
}
skgpu
:
:
AtlasToken
addInlineUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
skgpu
:
:
AtlasToken
addASAPUpload
(
GrDeferredTextureUploadFn
&
&
)
final
;
void
recordDraw
(
const
GrGeometryProcessor
*
const
GrSimpleMesh
[
]
int
meshCnt
const
GrSurfaceProxy
*
const
primProcProxies
[
]
GrPrimitiveType
)
final
;
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
)
final
;
uint16_t
*
makeIndexSpace
(
int
indexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
)
final
;
void
*
makeVertexSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startVertex
int
*
actualVertexCount
)
final
;
uint16_t
*
makeIndexSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
sk_sp
<
const
GrBuffer
>
*
int
*
startIndex
int
*
actualIndexCount
)
final
;
GrDrawIndirectWriter
makeDrawIndirectSpace
(
int
drawCount
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
)
override
{
return
fDrawIndirectPool
.
makeSpace
(
drawCount
buffer
offset
)
;
}
GrDrawIndexedIndirectWriter
makeDrawIndexedIndirectSpace
(
int
drawCount
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
)
override
{
return
fDrawIndirectPool
.
makeIndexedSpace
(
drawCount
buffer
offset
)
;
}
void
putBackIndices
(
int
indexCount
)
final
;
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
final
;
void
putBackIndirectDraws
(
int
drawCount
)
final
{
fDrawIndirectPool
.
putBack
(
drawCount
)
;
}
void
putBackIndexedIndirectDraws
(
int
drawCount
)
final
{
fDrawIndirectPool
.
putBackIndexed
(
drawCount
)
;
}
const
GrSurfaceProxyView
&
writeView
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
writeView
(
)
;
}
GrRenderTargetProxy
*
rtProxy
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
rtProxy
(
)
;
}
bool
usesMSAASurface
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
usesMSAASurface
(
)
;
}
const
GrAppliedClip
*
appliedClip
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
appliedClip
(
)
;
}
const
GrAppliedHardClip
&
appliedHardClip
(
)
const
{
return
(
fOpArgs
-
>
appliedClip
(
)
)
?
fOpArgs
-
>
appliedClip
(
)
-
>
hardClip
(
)
:
GrAppliedHardClip
:
:
Disabled
(
)
;
}
GrAppliedClip
detachAppliedClip
(
)
final
;
const
GrDstProxyView
&
dstProxyView
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
dstProxyView
(
)
;
}
GrXferBarrierFlags
renderPassBarriers
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
renderPassBarriers
(
)
;
}
GrLoadOp
colorLoadOp
(
)
const
final
{
return
this
-
>
drawOpArgs
(
)
.
colorLoadOp
(
)
;
}
GrDeferredUploadTarget
*
deferredUploadTarget
(
)
final
{
return
this
;
}
const
GrCaps
&
caps
(
)
const
final
;
GrThreadSafeCache
*
threadSafeCache
(
)
const
final
;
GrResourceProvider
*
resourceProvider
(
)
const
final
{
return
fResourceProvider
;
}
sktext
:
:
gpu
:
:
StrikeCache
*
strikeCache
(
)
const
final
;
GrAtlasManager
*
atlasManager
(
)
const
final
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
skgpu
:
:
ganesh
:
:
SmallPathAtlasMgr
*
smallPathAtlasManager
(
)
const
final
;
#
endif
SkArenaAlloc
*
allocator
(
)
override
{
return
&
fArena
;
}
void
bindPipelineAndScissorClip
(
const
GrProgramInfo
&
programInfo
const
SkRect
&
drawBounds
)
{
SkASSERT
(
(
programInfo
.
pipeline
(
)
.
isScissorTestEnabled
(
)
)
=
=
(
this
-
>
appliedClip
(
)
&
&
this
-
>
appliedClip
(
)
-
>
scissorState
(
)
.
enabled
(
)
)
)
;
this
-
>
bindPipeline
(
programInfo
drawBounds
)
;
if
(
programInfo
.
pipeline
(
)
.
isScissorTestEnabled
(
)
)
{
this
-
>
setScissorRect
(
this
-
>
appliedClip
(
)
-
>
scissorState
(
)
.
rect
(
)
)
;
}
}
void
bindTextures
(
const
GrGeometryProcessor
&
geomProc
const
GrSurfaceProxy
&
singleGeomProcTexture
const
GrPipeline
&
pipeline
)
{
SkASSERT
(
geomProc
.
numTextureSamplers
(
)
=
=
1
)
;
const
GrSurfaceProxy
*
ptr
=
&
singleGeomProcTexture
;
this
-
>
bindTextures
(
geomProc
&
ptr
pipeline
)
;
}
void
drawMesh
(
const
GrSimpleMesh
&
mesh
)
;
void
bindPipeline
(
const
GrProgramInfo
&
programInfo
const
SkRect
&
drawBounds
)
{
fOpsRenderPass
-
>
bindPipeline
(
programInfo
drawBounds
)
;
}
void
setScissorRect
(
const
SkIRect
&
scissorRect
)
{
fOpsRenderPass
-
>
setScissorRect
(
scissorRect
)
;
}
void
bindTextures
(
const
GrGeometryProcessor
&
geomProc
const
GrSurfaceProxy
*
const
geomProcTextures
[
]
const
GrPipeline
&
pipeline
)
{
fOpsRenderPass
-
>
bindTextures
(
geomProc
geomProcTextures
pipeline
)
;
}
void
bindBuffers
(
sk_sp
<
const
GrBuffer
>
indexBuffer
sk_sp
<
const
GrBuffer
>
instanceBuffer
sk_sp
<
const
GrBuffer
>
vertexBuffer
GrPrimitiveRestart
primitiveRestart
=
GrPrimitiveRestart
:
:
kNo
)
{
fOpsRenderPass
-
>
bindBuffers
(
std
:
:
move
(
indexBuffer
)
std
:
:
move
(
instanceBuffer
)
std
:
:
move
(
vertexBuffer
)
primitiveRestart
)
;
}
void
draw
(
int
vertexCount
int
baseVertex
)
{
fOpsRenderPass
-
>
draw
(
vertexCount
baseVertex
)
;
}
void
drawIndexed
(
int
indexCount
int
baseIndex
uint16_t
minIndexValue
uint16_t
maxIndexValue
int
baseVertex
)
{
fOpsRenderPass
-
>
drawIndexed
(
indexCount
baseIndex
minIndexValue
maxIndexValue
baseVertex
)
;
}
void
drawInstanced
(
int
instanceCount
int
baseInstance
int
vertexCount
int
baseVertex
)
{
fOpsRenderPass
-
>
drawInstanced
(
instanceCount
baseInstance
vertexCount
baseVertex
)
;
}
void
drawIndexedInstanced
(
int
indexCount
int
baseIndex
int
instanceCount
int
baseInstance
int
baseVertex
)
{
fOpsRenderPass
-
>
drawIndexedInstanced
(
indexCount
baseIndex
instanceCount
baseInstance
baseVertex
)
;
}
void
drawIndirect
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
{
fOpsRenderPass
-
>
drawIndirect
(
drawIndirectBuffer
offset
drawCount
)
;
}
void
drawIndexedIndirect
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
{
fOpsRenderPass
-
>
drawIndexedIndirect
(
drawIndirectBuffer
offset
drawCount
)
;
}
void
drawIndexPattern
(
int
patternIndexCount
int
patternRepeatCount
int
maxPatternRepetitionsInIndexBuffer
int
patternVertexCount
int
baseVertex
)
{
fOpsRenderPass
-
>
drawIndexPattern
(
patternIndexCount
patternRepeatCount
maxPatternRepetitionsInIndexBuffer
patternVertexCount
baseVertex
)
;
}
private
:
struct
InlineUpload
{
InlineUpload
(
GrDeferredTextureUploadFn
&
&
upload
skgpu
:
:
AtlasToken
token
)
:
fUpload
(
std
:
:
move
(
upload
)
)
fUploadBeforeToken
(
token
)
{
}
GrDeferredTextureUploadFn
fUpload
;
skgpu
:
:
AtlasToken
fUploadBeforeToken
;
}
;
struct
Draw
{
~
Draw
(
)
;
const
GrGeometryProcessor
*
fGeometryProcessor
=
nullptr
;
const
GrSurfaceProxy
*
const
*
fGeomProcProxies
=
nullptr
;
const
GrSimpleMesh
*
fMeshes
=
nullptr
;
const
GrOp
*
fOp
=
nullptr
;
int
fMeshCnt
=
0
;
GrPrimitiveType
fPrimitiveType
;
}
;
SkArenaAllocWithReset
fArena
{
sizeof
(
GrPipeline
)
*
100
}
;
GrVertexBufferAllocPool
fVertexPool
;
GrIndexBufferAllocPool
fIndexPool
;
GrDrawIndirectBufferAllocPool
fDrawIndirectPool
;
SkArenaAllocList
<
GrDeferredTextureUploadFn
>
fASAPUploads
;
SkArenaAllocList
<
InlineUpload
>
fInlineUploads
;
SkArenaAllocList
<
Draw
>
fDraws
;
skgpu
:
:
AtlasToken
fBaseDrawToken
=
skgpu
:
:
AtlasToken
:
:
InvalidToken
(
)
;
OpArgs
*
fOpArgs
=
nullptr
;
SkTArray
<
GrSurfaceProxy
*
true
>
*
fSampledProxies
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
skgpu
:
:
TokenTracker
*
fTokenTracker
;
GrOpsRenderPass
*
fOpsRenderPass
=
nullptr
;
SkArenaAllocList
<
Draw
>
:
:
Iter
fCurrDraw
;
SkArenaAllocList
<
InlineUpload
>
:
:
Iter
fCurrUpload
;
}
;
#
endif
