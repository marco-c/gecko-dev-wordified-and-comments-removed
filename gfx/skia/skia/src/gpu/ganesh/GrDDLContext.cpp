#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrContextThreadSafeProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramDesc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramInfo
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrSkSLFP
.
h
"
class
GrDDLContext
final
:
public
GrRecordingContext
{
public
:
GrDDLContext
(
sk_sp
<
GrContextThreadSafeProxy
>
proxy
)
:
INHERITED
(
std
:
:
move
(
proxy
)
true
)
{
}
~
GrDDLContext
(
)
override
{
}
void
abandonContext
(
)
override
{
SkASSERT
(
0
)
;
INHERITED
:
:
abandonContext
(
)
;
}
private
:
void
recordProgramInfo
(
const
GrProgramInfo
*
programInfo
)
final
{
if
(
!
programInfo
)
{
return
;
}
const
GrCaps
*
caps
=
this
-
>
caps
(
)
;
if
(
this
-
>
backend
(
)
=
=
GrBackendApi
:
:
kMetal
|
|
this
-
>
backend
(
)
=
=
GrBackendApi
:
:
kDirect3D
|
|
this
-
>
backend
(
)
=
=
GrBackendApi
:
:
kDawn
)
{
return
;
}
GrProgramDesc
desc
=
caps
-
>
makeDesc
(
nullptr
*
programInfo
)
;
if
(
!
desc
.
isValid
(
)
)
{
return
;
}
fProgramInfoMap
.
add
(
desc
programInfo
)
;
}
void
detachProgramData
(
SkTArray
<
ProgramData
>
*
dst
)
final
{
SkASSERT
(
dst
-
>
empty
(
)
)
;
fProgramInfoMap
.
toArray
(
dst
)
;
}
private
:
class
ProgramInfoMap
:
public
:
:
SkNoncopyable
{
typedef
const
GrProgramDesc
CacheKey
;
typedef
const
GrProgramInfo
*
CacheValue
;
public
:
ProgramInfoMap
(
)
:
fMap
(
10
)
{
}
~
ProgramInfoMap
(
)
{
}
void
add
(
CacheKey
&
desc
const
GrProgramInfo
*
programInfo
)
{
SkASSERT
(
desc
.
isValid
(
)
)
;
const
CacheValue
*
preExisting
=
fMap
.
find
(
desc
)
;
if
(
preExisting
)
{
return
;
}
fMap
.
insert
(
desc
programInfo
)
;
}
void
toArray
(
SkTArray
<
ProgramData
>
*
dst
)
{
fMap
.
foreach
(
[
dst
]
(
CacheKey
*
programDesc
CacheValue
*
programInfo
)
{
dst
-
>
emplace_back
(
std
:
:
make_unique
<
const
GrProgramDesc
>
(
*
programDesc
)
*
programInfo
)
;
}
)
;
}
private
:
struct
DescHash
{
uint32_t
operator
(
)
(
CacheKey
&
desc
)
const
{
return
SkOpts
:
:
hash_fn
(
desc
.
asKey
(
)
desc
.
keyLength
(
)
0
)
;
}
}
;
SkLRUCache
<
CacheKey
CacheValue
DescHash
>
fMap
;
}
;
ProgramInfoMap
fProgramInfoMap
;
using
INHERITED
=
GrRecordingContext
;
}
;
sk_sp
<
GrRecordingContext
>
GrRecordingContextPriv
:
:
MakeDDL
(
sk_sp
<
GrContextThreadSafeProxy
>
proxy
)
{
sk_sp
<
GrRecordingContext
>
context
(
new
GrDDLContext
(
std
:
:
move
(
proxy
)
)
)
;
if
(
!
context
-
>
init
(
)
)
{
return
nullptr
;
}
return
context
;
}
