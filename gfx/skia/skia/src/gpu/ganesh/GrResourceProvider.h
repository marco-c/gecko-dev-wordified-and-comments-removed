#
ifndef
GrResourceProvider_DEFINED
#
define
GrResourceProvider_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceCache
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string_view
>
#
include
<
type_traits
>
class
GrAttachment
;
class
GrBackendFormat
;
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBackendTexture
;
class
GrGpu
;
class
GrRenderTarget
;
class
GrResourceProviderPriv
;
class
GrSemaphore
;
class
GrTexture
;
class
SkData
;
enum
class
SkBackingFit
;
struct
GrVkDrawableInfo
;
struct
SkImageInfo
;
namespace
skgpu
{
class
ScratchKey
;
class
SingleOwner
;
class
UniqueKey
;
enum
class
Budgeted
:
bool
;
enum
class
Mipmapped
:
bool
;
enum
class
Protected
:
bool
;
enum
class
Renderable
:
bool
;
}
class
GrResourceProvider
{
public
:
GrResourceProvider
(
GrGpu
*
GrResourceCache
*
skgpu
:
:
SingleOwner
*
)
;
template
<
typename
T
=
GrGpuResource
>
typename
std
:
:
enable_if
<
std
:
:
is_base_of
<
GrGpuResource
T
>
:
:
value
sk_sp
<
T
>
>
:
:
type
findByUniqueKey
(
const
skgpu
:
:
UniqueKey
&
key
)
{
return
sk_sp
<
T
>
(
static_cast
<
T
*
>
(
this
-
>
findResourceByUniqueKey
(
key
)
.
release
(
)
)
)
;
}
sk_sp
<
GrTexture
>
createApproxTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrTextureType
textureType
skgpu
:
:
Renderable
renderable
int
renderTargetSampleCnt
skgpu
:
:
Protected
isProtected
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrTextureType
textureType
skgpu
:
:
Renderable
renderable
int
renderTargetSampleCnt
skgpu
:
:
Mipmapped
mipmapped
skgpu
:
:
Budgeted
budgeted
skgpu
:
:
Protected
isProtected
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createTexture
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrTextureType
textureType
GrColorType
colorType
skgpu
:
:
Renderable
renderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
budgeted
skgpu
:
:
Mipmapped
mipmapped
skgpu
:
:
Protected
isProtected
const
GrMipLevel
texels
[
]
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrTextureType
textureType
GrColorType
srcColorType
skgpu
:
:
Renderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
SkBackingFit
skgpu
:
:
Protected
const
GrMipLevel
&
mipLevel
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
findAndRefScratchTexture
(
const
skgpu
:
:
ScratchKey
&
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
findAndRefScratchTexture
(
SkISize
dimensions
const
GrBackendFormat
&
GrTextureType
textureType
skgpu
:
:
Renderable
int
renderTargetSampleCnt
skgpu
:
:
Mipmapped
skgpu
:
:
Protected
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
createCompressedTexture
(
SkISize
dimensions
const
GrBackendFormat
&
skgpu
:
:
Budgeted
skgpu
:
:
Mipmapped
skgpu
:
:
Protected
SkData
*
data
std
:
:
string_view
label
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTexture
&
tex
GrWrapOwnership
GrWrapCacheable
GrIOType
)
;
sk_sp
<
GrTexture
>
wrapCompressedBackendTexture
(
const
GrBackendTexture
&
tex
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrTexture
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
tex
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
;
sk_sp
<
GrRenderTarget
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
static
const
int
kMinScratchTextureSize
;
using
InitializeBufferFn
=
void
(
*
)
(
skgpu
:
:
VertexWriter
size_t
bufferSize
)
;
sk_sp
<
const
GrGpuBuffer
>
findOrMakeStaticBuffer
(
GrGpuBufferType
intendedType
size_t
size
const
skgpu
:
:
UniqueKey
&
key
InitializeBufferFn
)
;
sk_sp
<
const
GrGpuBuffer
>
findOrMakeStaticBuffer
(
GrGpuBufferType
intendedType
size_t
size
const
void
*
staticData
const
skgpu
:
:
UniqueKey
&
key
)
;
sk_sp
<
const
GrGpuBuffer
>
findOrCreatePatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
skgpu
:
:
UniqueKey
&
key
)
{
if
(
auto
buffer
=
this
-
>
findByUniqueKey
<
const
GrGpuBuffer
>
(
key
)
)
{
return
buffer
;
}
return
this
-
>
createPatternedIndexBuffer
(
pattern
patternSize
reps
vertCount
&
key
)
;
}
sk_sp
<
const
GrGpuBuffer
>
refNonAAQuadIndexBuffer
(
)
{
if
(
!
fNonAAQuadIndexBuffer
)
{
fNonAAQuadIndexBuffer
=
this
-
>
createNonAAQuadIndexBuffer
(
)
;
}
return
fNonAAQuadIndexBuffer
;
}
static
int
MaxNumNonAAQuads
(
)
;
static
int
NumVertsPerNonAAQuad
(
)
;
static
int
NumIndicesPerNonAAQuad
(
)
;
sk_sp
<
const
GrGpuBuffer
>
refAAQuadIndexBuffer
(
)
{
if
(
!
fAAQuadIndexBuffer
)
{
fAAQuadIndexBuffer
=
this
-
>
createAAQuadIndexBuffer
(
)
;
}
return
fAAQuadIndexBuffer
;
}
static
int
MaxNumAAQuads
(
)
;
static
int
NumVertsPerAAQuad
(
)
;
static
int
NumIndicesPerAAQuad
(
)
;
enum
class
ZeroInit
:
bool
{
kNo
=
false
kYes
=
true
}
;
sk_sp
<
GrGpuBuffer
>
createBuffer
(
size_t
size
GrGpuBufferType
GrAccessPattern
ZeroInit
)
;
sk_sp
<
GrGpuBuffer
>
createBuffer
(
const
void
*
data
size_t
size
GrGpuBufferType
type
GrAccessPattern
pattern
)
;
bool
attachStencilAttachment
(
GrRenderTarget
*
rt
bool
useMSAASurface
)
;
sk_sp
<
GrAttachment
>
makeMSAAAttachment
(
SkISize
dimensions
const
GrBackendFormat
&
format
int
sampleCnt
skgpu
:
:
Protected
isProtected
GrMemoryless
isMemoryless
)
;
sk_sp
<
GrAttachment
>
getDiscardableMSAAAttachment
(
SkISize
dimensions
const
GrBackendFormat
&
format
int
sampleCnt
skgpu
:
:
Protected
isProtected
GrMemoryless
memoryless
)
;
void
assignUniqueKeyToResource
(
const
skgpu
:
:
UniqueKey
&
GrGpuResource
*
)
;
std
:
:
unique_ptr
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
bool
isOwned
=
true
)
;
std
:
:
unique_ptr
<
GrSemaphore
>
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
GrSemaphoreWrapType
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
void
abandon
(
)
{
fCache
=
nullptr
;
fGpu
=
nullptr
;
}
uint32_t
contextUniqueID
(
)
const
{
return
fCache
-
>
contextUniqueID
(
)
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
bool
overBudget
(
)
const
{
return
fCache
-
>
overBudget
(
)
;
}
static
SkISize
MakeApprox
(
SkISize
)
;
inline
GrResourceProviderPriv
priv
(
)
;
inline
const
GrResourceProviderPriv
priv
(
)
const
;
private
:
sk_sp
<
GrGpuResource
>
findResourceByUniqueKey
(
const
skgpu
:
:
UniqueKey
&
)
;
sk_sp
<
GrTexture
>
getExactScratch
(
SkISize
dimensions
const
GrBackendFormat
&
GrTextureType
skgpu
:
:
Renderable
int
renderTargetSampleCnt
skgpu
:
:
Budgeted
skgpu
:
:
Mipmapped
skgpu
:
:
Protected
std
:
:
string_view
label
)
;
sk_sp
<
GrAttachment
>
refScratchMSAAAttachment
(
SkISize
dimensions
const
GrBackendFormat
&
int
sampleCnt
skgpu
:
:
Protected
GrMemoryless
memoryless
std
:
:
string_view
label
)
;
using
TempLevels
=
skia_private
:
:
AutoSTArray
<
14
GrMipLevel
>
;
using
TempLevelDatas
=
skia_private
:
:
AutoSTArray
<
14
std
:
:
unique_ptr
<
char
[
]
>
>
;
GrColorType
prepareLevels
(
const
GrBackendFormat
&
format
GrColorType
SkISize
baseSize
const
GrMipLevel
texels
[
]
int
mipLevelCount
TempLevels
*
TempLevelDatas
*
)
const
;
sk_sp
<
GrTexture
>
writePixels
(
sk_sp
<
GrTexture
>
texture
GrColorType
colorType
SkISize
baseSize
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
const
;
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
friend
class
GrResourceProviderPriv
;
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
sk_sp
<
const
GrGpuBuffer
>
createPatternedIndexBuffer
(
const
uint16_t
*
pattern
int
patternSize
int
reps
int
vertCount
const
skgpu
:
:
UniqueKey
*
key
)
;
sk_sp
<
const
GrGpuBuffer
>
createNonAAQuadIndexBuffer
(
)
;
sk_sp
<
const
GrGpuBuffer
>
createAAQuadIndexBuffer
(
)
;
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
sk_sp
<
const
GrCaps
>
fCaps
;
sk_sp
<
const
GrGpuBuffer
>
fNonAAQuadIndexBuffer
;
sk_sp
<
const
GrGpuBuffer
>
fAAQuadIndexBuffer
;
SkDEBUGCODE
(
mutable
skgpu
:
:
SingleOwner
*
fSingleOwner
;
)
}
;
#
endif
