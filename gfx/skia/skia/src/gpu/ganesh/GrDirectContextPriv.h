#
ifndef
GrDirectContextPriv_DEFINED
#
define
GrDirectContextPriv_DEFINED
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
Device_v1
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
class
GrAtlasManager
;
class
GrBackendFormat
;
class
GrBackendRenderTarget
;
class
GrImageInfo
;
class
GrMemoryPool
;
class
GrOnFlushCallbackObject
;
class
GrRenderTargetProxy
;
class
GrSemaphore
;
class
GrSurfaceProxy
;
class
SkDeferredDisplayList
;
class
SkTaskGroup
;
class
GrDirectContextPriv
:
public
GrRecordingContextPriv
{
public
:
GrDirectContext
*
context
(
)
{
return
static_cast
<
GrDirectContext
*
>
(
fContext
)
;
}
const
GrDirectContext
*
context
(
)
const
{
return
static_cast
<
const
GrDirectContext
*
>
(
fContext
)
;
}
sktext
:
:
gpu
:
:
StrikeCache
*
getStrikeCache
(
)
{
return
this
-
>
context
(
)
-
>
fStrikeCache
.
get
(
)
;
}
GrSemaphoresSubmitted
flushSurfaces
(
SkSpan
<
GrSurfaceProxy
*
>
SkSurface
:
:
BackendSurfaceAccess
=
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
const
GrFlushInfo
&
=
{
}
const
skgpu
:
:
MutableTextureState
*
newState
=
nullptr
)
;
GrSemaphoresSubmitted
flushSurface
(
GrSurfaceProxy
*
proxy
SkSurface
:
:
BackendSurfaceAccess
access
=
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
const
GrFlushInfo
&
info
=
{
}
const
skgpu
:
:
MutableTextureState
*
newState
=
nullptr
)
{
size_t
size
=
proxy
?
1
:
0
;
return
this
-
>
flushSurfaces
(
{
&
proxy
size
}
access
info
newState
)
;
}
bool
validPMUPMConversionExists
(
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
createPMToUPMEffect
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
createUPMToPMEffect
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
SkTaskGroup
*
getTaskGroup
(
)
{
return
this
-
>
context
(
)
-
>
fTaskGroup
.
get
(
)
;
}
GrResourceProvider
*
resourceProvider
(
)
{
return
this
-
>
context
(
)
-
>
fResourceProvider
.
get
(
)
;
}
const
GrResourceProvider
*
resourceProvider
(
)
const
{
return
this
-
>
context
(
)
-
>
fResourceProvider
.
get
(
)
;
}
GrResourceCache
*
getResourceCache
(
)
{
return
this
-
>
context
(
)
-
>
fResourceCache
.
get
(
)
;
}
GrGpu
*
getGpu
(
)
{
return
this
-
>
context
(
)
-
>
fGpu
.
get
(
)
;
}
const
GrGpu
*
getGpu
(
)
const
{
return
this
-
>
context
(
)
-
>
fGpu
.
get
(
)
;
}
GrAtlasManager
*
getAtlasManager
(
)
{
return
this
-
>
context
(
)
-
>
onGetAtlasManager
(
)
;
}
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
skgpu
:
:
ganesh
:
:
SmallPathAtlasMgr
*
getSmallPathAtlasMgr
(
)
{
return
this
-
>
context
(
)
-
>
onGetSmallPathAtlasMgr
(
)
;
}
#
endif
void
createDDLTask
(
sk_sp
<
const
SkDeferredDisplayList
>
sk_sp
<
GrRenderTargetProxy
>
newDest
SkIPoint
offset
)
;
bool
compile
(
const
GrProgramDesc
&
const
GrProgramInfo
&
)
;
GrContextOptions
:
:
PersistentCache
*
getPersistentCache
(
)
{
return
this
-
>
context
(
)
-
>
fPersistentCache
;
}
GrClientMappedBufferManager
*
clientMappedBufferManager
(
)
{
return
this
-
>
context
(
)
-
>
fMappedBufferManager
.
get
(
)
;
}
void
setInsideReleaseProc
(
bool
inside
)
{
if
(
inside
)
{
this
-
>
context
(
)
-
>
fInsideReleaseProcCnt
+
+
;
}
else
{
SkASSERT
(
this
-
>
context
(
)
-
>
fInsideReleaseProcCnt
>
0
)
;
this
-
>
context
(
)
-
>
fInsideReleaseProcCnt
-
-
;
}
}
#
if
GR_TEST_UTILS
void
resetGpuStats
(
)
const
;
void
dumpCacheStats
(
SkString
*
)
const
;
void
dumpCacheStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
printCacheStats
(
)
const
;
void
dumpGpuStats
(
SkString
*
)
const
;
void
dumpGpuStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
printGpuStats
(
)
const
;
void
resetContextStats
(
)
;
void
dumpContextStats
(
SkString
*
)
const
;
void
dumpContextStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
printContextStats
(
)
const
;
sk_sp
<
SkImage
>
testingOnly_getFontAtlasImage
(
skgpu
:
:
MaskFormat
format
unsigned
int
index
=
0
)
;
void
testingOnly_flushAndRemoveOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
endif
private
:
explicit
GrDirectContextPriv
(
GrDirectContext
*
dContext
)
:
GrRecordingContextPriv
(
dContext
)
{
}
GrDirectContextPriv
&
operator
=
(
const
GrDirectContextPriv
&
)
=
delete
;
const
GrDirectContextPriv
*
operator
&
(
)
const
;
GrDirectContextPriv
*
operator
&
(
)
;
friend
class
GrDirectContext
;
using
INHERITED
=
GrRecordingContextPriv
;
}
;
inline
GrDirectContextPriv
GrDirectContext
:
:
priv
(
)
{
return
GrDirectContextPriv
(
this
)
;
}
inline
const
GrDirectContextPriv
GrDirectContext
:
:
priv
(
)
const
{
return
GrDirectContextPriv
(
const_cast
<
GrDirectContext
*
>
(
this
)
)
;
}
#
endif
