#
ifndef
GrGeometryProcessor_DEFINED
#
define
GrGeometryProcessor_DEFINED
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderVar
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVarying
.
h
"
#
include
<
unordered_map
>
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLVaryingHandler
;
class
GrGLSLUniformHandler
;
class
GrGLSLVertexBuilder
;
class
GrGeometryProcessor
:
public
GrProcessor
{
public
:
class
ProgramImpl
;
class
TextureSampler
;
class
Attribute
{
public
:
static
constexpr
size_t
AlignOffset
(
size_t
offset
)
{
return
SkAlign4
(
offset
)
;
}
constexpr
Attribute
(
)
=
default
;
constexpr
Attribute
(
const
char
*
name
GrVertexAttribType
cpuType
SkSLType
gpuType
)
:
fName
(
name
)
fCPUType
(
cpuType
)
fGPUType
(
gpuType
)
{
SkASSERT
(
name
&
&
gpuType
!
=
SkSLType
:
:
kVoid
)
;
}
constexpr
Attribute
(
const
char
*
name
GrVertexAttribType
cpuType
SkSLType
gpuType
size_t
offset
)
:
fName
(
name
)
fCPUType
(
cpuType
)
fGPUType
(
gpuType
)
fOffset
(
SkToU32
(
offset
)
)
{
SkASSERT
(
AlignOffset
(
offset
)
=
=
offset
)
;
SkASSERT
(
name
&
&
gpuType
!
=
SkSLType
:
:
kVoid
)
;
}
constexpr
Attribute
(
const
Attribute
&
)
=
default
;
Attribute
&
operator
=
(
const
Attribute
&
)
=
default
;
constexpr
bool
isInitialized
(
)
const
{
return
fGPUType
!
=
SkSLType
:
:
kVoid
;
}
constexpr
const
char
*
name
(
)
const
{
return
fName
;
}
constexpr
GrVertexAttribType
cpuType
(
)
const
{
return
fCPUType
;
}
constexpr
SkSLType
gpuType
(
)
const
{
return
fGPUType
;
}
std
:
:
optional
<
size_t
>
offset
(
)
const
{
if
(
fOffset
!
=
kImplicitOffset
)
{
SkASSERT
(
AlignOffset
(
fOffset
)
=
=
fOffset
)
;
return
{
fOffset
}
;
}
return
std
:
:
nullopt
;
}
inline
constexpr
size_t
size
(
)
const
;
GrShaderVar
asShaderVar
(
)
const
{
return
{
fName
fGPUType
GrShaderVar
:
:
TypeModifier
:
:
In
}
;
}
private
:
static
constexpr
uint32_t
kImplicitOffset
=
1
;
const
char
*
fName
=
nullptr
;
GrVertexAttribType
fCPUType
=
kFloat_GrVertexAttribType
;
SkSLType
fGPUType
=
SkSLType
:
:
kVoid
;
uint32_t
fOffset
=
kImplicitOffset
;
}
;
class
AttributeSet
{
class
Iter
{
public
:
Iter
(
)
=
default
;
Iter
(
const
Iter
&
iter
)
=
default
;
Iter
&
operator
=
(
const
Iter
&
iter
)
=
default
;
Iter
(
const
Attribute
*
attrs
int
count
)
:
fCurr
(
attrs
)
fRemaining
(
count
)
{
this
-
>
skipUninitialized
(
)
;
}
bool
operator
!
=
(
const
Iter
&
that
)
const
{
return
fCurr
!
=
that
.
fCurr
;
}
Attribute
operator
*
(
)
const
;
void
operator
+
+
(
)
;
private
:
void
skipUninitialized
(
)
;
const
Attribute
*
fCurr
=
nullptr
;
int
fRemaining
=
0
;
size_t
fImplicitOffset
=
0
;
}
;
public
:
Iter
begin
(
)
const
;
Iter
end
(
)
const
;
int
count
(
)
const
{
return
fCount
;
}
size_t
stride
(
)
const
{
return
fStride
;
}
void
initImplicit
(
const
Attribute
*
attrs
int
count
)
;
void
initExplicit
(
const
Attribute
*
attrs
int
count
size_t
stride
)
;
void
addToKey
(
skgpu
:
:
KeyBuilder
*
b
)
const
;
private
:
const
Attribute
*
fAttributes
=
nullptr
;
int
fRawCount
=
0
;
int
fCount
=
0
;
size_t
fStride
=
0
;
}
;
GrGeometryProcessor
(
ClassID
)
;
int
numTextureSamplers
(
)
const
{
return
fTextureSamplerCnt
;
}
const
TextureSampler
&
textureSampler
(
int
index
)
const
;
int
numVertexAttributes
(
)
const
{
return
fVertexAttributes
.
count
(
)
;
}
const
AttributeSet
&
vertexAttributes
(
)
const
{
return
fVertexAttributes
;
}
int
numInstanceAttributes
(
)
const
{
return
fInstanceAttributes
.
count
(
)
;
}
const
AttributeSet
&
instanceAttributes
(
)
const
{
return
fInstanceAttributes
;
}
bool
hasVertexAttributes
(
)
const
{
return
SkToBool
(
fVertexAttributes
.
count
(
)
)
;
}
bool
hasInstanceAttributes
(
)
const
{
return
SkToBool
(
fInstanceAttributes
.
count
(
)
)
;
}
size_t
vertexStride
(
)
const
{
return
fVertexAttributes
.
stride
(
)
;
}
size_t
instanceStride
(
)
const
{
return
fInstanceAttributes
.
stride
(
)
;
}
static
uint32_t
ComputeCoordTransformsKey
(
const
GrFragmentProcessor
&
fp
)
;
inline
static
constexpr
int
kCoordTransformKeyBits
=
4
;
virtual
void
addToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
=
0
;
void
getAttributeKey
(
skgpu
:
:
KeyBuilder
*
b
)
const
;
virtual
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
const
GrShaderCaps
&
)
const
=
0
;
protected
:
static
Attribute
MakeColorAttribute
(
const
char
*
name
bool
wideColor
)
{
return
{
name
wideColor
?
kFloat4_GrVertexAttribType
:
kUByte4_norm_GrVertexAttribType
SkSLType
:
:
kHalf4
}
;
}
void
setVertexAttributes
(
const
Attribute
*
attrs
int
attrCount
size_t
stride
)
{
fVertexAttributes
.
initExplicit
(
attrs
attrCount
stride
)
;
}
void
setInstanceAttributes
(
const
Attribute
*
attrs
int
attrCount
size_t
stride
)
{
SkASSERT
(
attrCount
>
=
0
)
;
fInstanceAttributes
.
initExplicit
(
attrs
attrCount
stride
)
;
}
void
setVertexAttributesWithImplicitOffsets
(
const
Attribute
*
attrs
int
attrCount
)
{
fVertexAttributes
.
initImplicit
(
attrs
attrCount
)
;
}
void
setInstanceAttributesWithImplicitOffsets
(
const
Attribute
*
attrs
int
attrCount
)
{
SkASSERT
(
attrCount
>
=
0
)
;
fInstanceAttributes
.
initImplicit
(
attrs
attrCount
)
;
}
void
setTextureSamplerCnt
(
int
cnt
)
{
SkASSERT
(
cnt
>
=
0
)
;
fTextureSamplerCnt
=
cnt
;
}
template
<
typename
.
.
.
Args
>
static
const
TextureSampler
&
IthTextureSampler
(
int
i
const
TextureSampler
&
samp0
const
Args
&
.
.
.
samps
)
{
return
(
0
=
=
i
)
?
samp0
:
IthTextureSampler
(
i
-
1
samps
.
.
.
)
;
}
inline
static
const
TextureSampler
&
IthTextureSampler
(
int
i
)
;
private
:
virtual
const
TextureSampler
&
onTextureSampler
(
int
)
const
{
return
IthTextureSampler
(
0
)
;
}
AttributeSet
fVertexAttributes
;
AttributeSet
fInstanceAttributes
;
int
fTextureSamplerCnt
=
0
;
using
INHERITED
=
GrProcessor
;
}
;
class
GrGeometryProcessor
:
:
ProgramImpl
{
public
:
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
struct
FPCoords
{
GrShaderVar
coordsVarying
;
bool
hasCoordsParam
;
}
;
using
FPCoordsMap
=
std
:
:
unordered_map
<
const
GrFragmentProcessor
*
FPCoords
>
;
virtual
~
ProgramImpl
(
)
=
default
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLVertexBuilder
*
vertBuilder
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrGeometryProcessor
&
geomProc
const
char
*
outputColor
const
char
*
outputCoverage
const
SamplerHandle
*
texSamplers
)
:
fVertBuilder
(
vertBuilder
)
fFragBuilder
(
fragBuilder
)
fVaryingHandler
(
varyingHandler
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fGeomProc
(
geomProc
)
fOutputColor
(
outputColor
)
fOutputCoverage
(
outputCoverage
)
fTexSamplers
(
texSamplers
)
{
}
GrGLSLVertexBuilder
*
fVertBuilder
;
GrGLSLFPFragmentBuilder
*
fFragBuilder
;
GrGLSLVaryingHandler
*
fVaryingHandler
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrGeometryProcessor
&
fGeomProc
;
const
char
*
fOutputColor
;
const
char
*
fOutputCoverage
;
const
SamplerHandle
*
fTexSamplers
;
}
;
std
:
:
tuple
<
FPCoordsMap
GrShaderVar
>
emitCode
(
EmitArgs
&
const
GrPipeline
&
pipeline
)
;
void
emitTransformCode
(
GrGLSLVertexBuilder
*
vb
GrGLSLUniformHandler
*
uniformHandler
)
;
virtual
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrShaderCaps
&
const
GrGeometryProcessor
&
)
=
0
;
static
uint32_t
ComputeMatrixKey
(
const
GrShaderCaps
&
caps
const
SkMatrix
&
mat
)
{
if
(
!
caps
.
fReducedShaderMode
)
{
if
(
mat
.
isIdentity
(
)
)
{
return
0b00
;
}
if
(
mat
.
isScaleTranslate
(
)
)
{
return
0b01
;
}
}
if
(
!
mat
.
hasPerspective
(
)
)
{
return
0b10
;
}
return
0b11
;
}
static
uint32_t
ComputeMatrixKeys
(
const
GrShaderCaps
&
shaderCaps
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
localMatrix
)
{
return
(
ComputeMatrixKey
(
shaderCaps
viewMatrix
)
<
<
kMatrixKeyBits
)
|
ComputeMatrixKey
(
shaderCaps
localMatrix
)
;
}
static
uint32_t
AddMatrixKeys
(
const
GrShaderCaps
&
shaderCaps
uint32_t
flags
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
localMatrix
)
{
SkASSERT
(
(
(
flags
<
<
(
2
*
kMatrixKeyBits
)
)
>
>
(
2
*
kMatrixKeyBits
)
)
=
=
flags
)
;
return
(
flags
<
<
(
2
*
kMatrixKeyBits
)
)
|
ComputeMatrixKeys
(
shaderCaps
viewMatrix
localMatrix
)
;
}
inline
static
constexpr
int
kMatrixKeyBits
=
2
;
protected
:
void
setupUniformColor
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
char
*
outputName
UniformHandle
*
colorUniform
)
;
static
void
SetTransform
(
const
GrGLSLProgramDataManager
&
const
GrShaderCaps
&
const
UniformHandle
&
uniform
const
SkMatrix
&
matrix
SkMatrix
*
state
=
nullptr
)
;
struct
GrGPArgs
{
GrShaderVar
fPositionVar
;
GrShaderVar
fLocalCoordVar
;
GrShaderType
fLocalCoordShader
=
kVertex_GrShaderType
;
}
;
static
void
WriteOutputPosition
(
GrGLSLVertexBuilder
*
GrGPArgs
*
const
char
*
posName
)
;
static
void
WriteOutputPosition
(
GrGLSLVertexBuilder
*
GrGLSLUniformHandler
*
const
GrShaderCaps
&
GrGPArgs
*
const
char
*
posName
const
SkMatrix
&
viewMatrix
UniformHandle
*
viewMatrixUniform
)
;
static
void
WriteLocalCoord
(
GrGLSLVertexBuilder
*
GrGLSLUniformHandler
*
const
GrShaderCaps
&
GrGPArgs
*
GrShaderVar
localVar
const
SkMatrix
&
localMatrix
UniformHandle
*
localMatrixUniform
)
;
private
:
virtual
void
onEmitCode
(
EmitArgs
&
GrGPArgs
*
)
=
0
;
FPCoordsMap
collectTransforms
(
GrGLSLVertexBuilder
*
vb
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
GrShaderType
localCoordsShader
const
GrShaderVar
&
localCoordsVar
const
GrShaderVar
&
positionVar
const
GrPipeline
&
pipeline
)
;
struct
TransformInfo
{
GrGLSLVarying
varying
;
GrShaderVar
inputCoords
;
int
traversalOrder
;
}
;
std
:
:
unordered_map
<
const
GrFragmentProcessor
*
TransformInfo
>
fTransformVaryingsMap
;
}
;
class
GrGeometryProcessor
:
:
TextureSampler
{
public
:
TextureSampler
(
)
=
default
;
TextureSampler
(
GrSamplerState
const
GrBackendFormat
&
const
skgpu
:
:
Swizzle
&
)
;
TextureSampler
(
const
TextureSampler
&
)
=
delete
;
TextureSampler
&
operator
=
(
const
TextureSampler
&
)
=
delete
;
void
reset
(
GrSamplerState
const
GrBackendFormat
&
const
skgpu
:
:
Swizzle
&
)
;
const
GrBackendFormat
&
backendFormat
(
)
const
{
return
fBackendFormat
;
}
GrTextureType
textureType
(
)
const
{
return
fBackendFormat
.
textureType
(
)
;
}
GrSamplerState
samplerState
(
)
const
{
return
fSamplerState
;
}
const
skgpu
:
:
Swizzle
&
swizzle
(
)
const
{
return
fSwizzle
;
}
bool
isInitialized
(
)
const
{
return
fIsInitialized
;
}
private
:
GrSamplerState
fSamplerState
;
GrBackendFormat
fBackendFormat
;
skgpu
:
:
Swizzle
fSwizzle
;
bool
fIsInitialized
=
false
;
}
;
const
GrGeometryProcessor
:
:
TextureSampler
&
GrGeometryProcessor
:
:
IthTextureSampler
(
int
i
)
{
SK_ABORT
(
"
Illegal
texture
sampler
index
"
)
;
static
const
TextureSampler
kBogus
;
return
kBogus
;
}
static
constexpr
inline
size_t
GrVertexAttribTypeSize
(
GrVertexAttribType
type
)
{
switch
(
type
)
{
case
kFloat_GrVertexAttribType
:
return
sizeof
(
float
)
;
case
kFloat2_GrVertexAttribType
:
return
2
*
sizeof
(
float
)
;
case
kFloat3_GrVertexAttribType
:
return
3
*
sizeof
(
float
)
;
case
kFloat4_GrVertexAttribType
:
return
4
*
sizeof
(
float
)
;
case
kHalf_GrVertexAttribType
:
return
sizeof
(
uint16_t
)
;
case
kHalf2_GrVertexAttribType
:
return
2
*
sizeof
(
uint16_t
)
;
case
kHalf4_GrVertexAttribType
:
return
4
*
sizeof
(
uint16_t
)
;
case
kInt2_GrVertexAttribType
:
return
2
*
sizeof
(
int32_t
)
;
case
kInt3_GrVertexAttribType
:
return
3
*
sizeof
(
int32_t
)
;
case
kInt4_GrVertexAttribType
:
return
4
*
sizeof
(
int32_t
)
;
case
kByte_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kByte2_GrVertexAttribType
:
return
2
*
sizeof
(
char
)
;
case
kByte4_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kUByte_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kUByte2_GrVertexAttribType
:
return
2
*
sizeof
(
char
)
;
case
kUByte4_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kUByte_norm_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kUByte4_norm_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kShort2_GrVertexAttribType
:
return
2
*
sizeof
(
int16_t
)
;
case
kShort4_GrVertexAttribType
:
return
4
*
sizeof
(
int16_t
)
;
case
kUShort2_GrVertexAttribType
:
case
kUShort2_norm_GrVertexAttribType
:
return
2
*
sizeof
(
uint16_t
)
;
case
kInt_GrVertexAttribType
:
return
sizeof
(
int32_t
)
;
case
kUInt_GrVertexAttribType
:
return
sizeof
(
uint32_t
)
;
case
kUShort_norm_GrVertexAttribType
:
return
sizeof
(
uint16_t
)
;
case
kUShort4_norm_GrVertexAttribType
:
return
4
*
sizeof
(
uint16_t
)
;
}
#
if
defined
(
__clang__
)
|
|
!
defined
(
__GNUC__
)
SK_ABORT
(
"
Unsupported
type
conversion
"
)
;
#
endif
return
0
;
}
constexpr
size_t
GrGeometryProcessor
:
:
Attribute
:
:
size
(
)
const
{
return
GrVertexAttribTypeSize
(
fCPUType
)
;
}
#
endif
