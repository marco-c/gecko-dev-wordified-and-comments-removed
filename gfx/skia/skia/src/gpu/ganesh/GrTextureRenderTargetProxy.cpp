#
include
"
src
/
gpu
/
ganesh
/
GrTextureRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxyPriv
.
h
"
#
ifdef
SK_DEBUG
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
endif
GrTextureRenderTargetProxy
:
:
GrTextureRenderTargetProxy
(
const
GrCaps
&
caps
const
GrBackendFormat
&
format
SkISize
dimensions
int
sampleCnt
GrMipmapped
mipmapped
GrMipmapStatus
mipmapStatus
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
GrInternalSurfaceFlags
surfaceFlags
UseAllocator
useAllocator
GrDDLProvider
creatingProvider
std
:
:
string_view
label
)
:
GrSurfaceProxy
(
format
dimensions
fit
budgeted
isProtected
surfaceFlags
useAllocator
label
)
GrRenderTargetProxy
(
caps
format
dimensions
sampleCnt
fit
budgeted
isProtected
surfaceFlags
useAllocator
label
)
GrTextureProxy
(
format
dimensions
mipmapped
mipmapStatus
fit
budgeted
isProtected
surfaceFlags
useAllocator
creatingProvider
label
)
{
this
-
>
initSurfaceFlags
(
caps
)
;
}
GrTextureRenderTargetProxy
:
:
GrTextureRenderTargetProxy
(
const
GrCaps
&
caps
LazyInstantiateCallback
&
&
callback
const
GrBackendFormat
&
format
SkISize
dimensions
int
sampleCnt
GrMipmapped
mipmapped
GrMipmapStatus
mipmapStatus
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
GrInternalSurfaceFlags
surfaceFlags
UseAllocator
useAllocator
GrDDLProvider
creatingProvider
std
:
:
string_view
label
)
:
GrSurfaceProxy
(
std
:
:
move
(
callback
)
format
dimensions
fit
budgeted
isProtected
surfaceFlags
useAllocator
label
)
GrRenderTargetProxy
(
LazyInstantiateCallback
(
)
format
dimensions
sampleCnt
fit
budgeted
isProtected
surfaceFlags
useAllocator
WrapsVkSecondaryCB
:
:
kNo
label
)
GrTextureProxy
(
LazyInstantiateCallback
(
)
format
dimensions
mipmapped
mipmapStatus
fit
budgeted
isProtected
surfaceFlags
useAllocator
creatingProvider
label
)
{
this
-
>
initSurfaceFlags
(
caps
)
;
}
GrTextureRenderTargetProxy
:
:
GrTextureRenderTargetProxy
(
sk_sp
<
GrSurface
>
surf
UseAllocator
useAllocator
GrDDLProvider
creatingProvider
)
:
GrSurfaceProxy
(
surf
SkBackingFit
:
:
kExact
useAllocator
)
GrRenderTargetProxy
(
surf
useAllocator
)
GrTextureProxy
(
surf
useAllocator
creatingProvider
)
{
SkASSERT
(
surf
-
>
asTexture
(
)
)
;
SkASSERT
(
surf
-
>
asRenderTarget
(
)
)
;
SkASSERT
(
fSurfaceFlags
=
=
fTarget
-
>
flags
(
)
)
;
SkASSERT
(
(
this
-
>
numSamples
(
)
<
=
1
|
|
fTarget
-
>
getContext
(
)
-
>
priv
(
)
.
caps
(
)
-
>
msaaResolvesAutomatically
(
)
)
!
=
this
-
>
requiresManualMSAAResolve
(
)
)
;
}
void
GrTextureRenderTargetProxy
:
:
initSurfaceFlags
(
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
glRTFBOIDIs0
(
)
)
;
if
(
this
-
>
numSamples
(
)
>
1
&
&
!
caps
.
msaaResolvesAutomatically
(
)
)
{
fSurfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kRequiresManualMSAAResolve
;
}
}
size_t
GrTextureRenderTargetProxy
:
:
onUninstantiatedGpuMemorySize
(
)
const
{
int
colorSamplesPerPixel
=
this
-
>
numSamples
(
)
;
if
(
colorSamplesPerPixel
>
1
)
{
+
+
colorSamplesPerPixel
;
}
return
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
colorSamplesPerPixel
this
-
>
proxyMipmapped
(
)
!
this
-
>
priv
(
)
.
isExact
(
)
)
;
}
bool
GrTextureRenderTargetProxy
:
:
instantiate
(
GrResourceProvider
*
resourceProvider
)
{
if
(
this
-
>
isLazy
(
)
)
{
return
false
;
}
const
skgpu
:
:
UniqueKey
&
key
=
this
-
>
getUniqueKey
(
)
;
if
(
!
this
-
>
instantiateImpl
(
resourceProvider
this
-
>
numSamples
(
)
GrRenderable
:
:
kYes
this
-
>
mipmapped
(
)
key
.
isValid
(
)
?
&
key
:
nullptr
)
)
{
return
false
;
}
if
(
key
.
isValid
(
)
)
{
SkASSERT
(
key
=
=
this
-
>
getUniqueKey
(
)
)
;
}
SkASSERT
(
this
-
>
peekRenderTarget
(
)
)
;
SkASSERT
(
this
-
>
peekTexture
(
)
)
;
return
true
;
}
sk_sp
<
GrSurface
>
GrTextureRenderTargetProxy
:
:
createSurface
(
GrResourceProvider
*
resourceProvider
)
const
{
sk_sp
<
GrSurface
>
surface
=
this
-
>
createSurfaceImpl
(
resourceProvider
this
-
>
numSamples
(
)
GrRenderable
:
:
kYes
this
-
>
mipmapped
(
)
)
;
if
(
!
surface
)
{
return
nullptr
;
}
SkASSERT
(
surface
-
>
asRenderTarget
(
)
)
;
SkASSERT
(
surface
-
>
asTexture
(
)
)
;
return
surface
;
}
GrSurfaceProxy
:
:
LazySurfaceDesc
GrTextureRenderTargetProxy
:
:
callbackDesc
(
)
const
{
SkISize
dims
;
SkBackingFit
fit
;
if
(
this
-
>
isFullyLazy
(
)
)
{
fit
=
SkBackingFit
:
:
kApprox
;
dims
=
{
-
1
-
1
}
;
}
else
{
fit
=
this
-
>
isFunctionallyExact
(
)
?
SkBackingFit
:
:
kExact
:
SkBackingFit
:
:
kApprox
;
dims
=
this
-
>
dimensions
(
)
;
}
return
{
dims
fit
GrRenderable
:
:
kYes
this
-
>
mipmapped
(
)
this
-
>
numSamples
(
)
this
-
>
backendFormat
(
)
this
-
>
textureType
(
)
this
-
>
isProtected
(
)
this
-
>
isBudgeted
(
)
this
-
>
getLabel
(
)
}
;
}
#
ifdef
SK_DEBUG
void
GrTextureRenderTargetProxy
:
:
onValidateSurface
(
const
GrSurface
*
surface
)
{
SkASSERT
(
surface
-
>
asTexture
(
)
)
;
SkASSERT
(
GrMipmapped
:
:
kNo
=
=
this
-
>
proxyMipmapped
(
)
|
|
GrMipmapped
:
:
kYes
=
=
surface
-
>
asTexture
(
)
-
>
mipmapped
(
)
)
;
SkASSERT
(
surface
-
>
asRenderTarget
(
)
)
;
SkASSERT
(
surface
-
>
asRenderTarget
(
)
-
>
numSamples
(
)
=
=
this
-
>
numSamples
(
)
)
;
SkASSERT
(
surface
-
>
asTexture
(
)
-
>
textureType
(
)
=
=
this
-
>
textureType
(
)
)
;
GrInternalSurfaceFlags
proxyFlags
=
fSurfaceFlags
;
GrInternalSurfaceFlags
surfaceFlags
=
surface
-
>
flags
(
)
;
SkASSERT
(
!
(
proxyFlags
&
GrInternalSurfaceFlags
:
:
kReadOnly
)
)
;
SkASSERT
(
!
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kReadOnly
)
)
;
SkASSERT
(
(
(
int
)
proxyFlags
&
kGrInternalTextureRenderTargetFlagsMask
)
=
=
(
(
int
)
surfaceFlags
&
kGrInternalTextureRenderTargetFlagsMask
)
)
;
if
(
proxyFlags
&
GrInternalSurfaceFlags
:
:
kVkRTSupportsInputAttachment
)
{
SkASSERT
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kVkRTSupportsInputAttachment
)
;
}
}
#
endif
