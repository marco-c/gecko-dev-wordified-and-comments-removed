#
ifndef
GrTextureProxy_DEFINED
#
define
GrTextureProxy_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
string_view
>
class
GrBackendFormat
;
class
GrDeferredProxyUploader
;
class
GrProxyProvider
;
class
GrResourceProvider
;
class
GrTextureProxyPriv
;
enum
class
SkBackingFit
;
struct
SkISize
;
class
GrTextureProxy
:
virtual
public
GrSurfaceProxy
{
public
:
GrTextureProxy
*
asTextureProxy
(
)
override
{
return
this
;
}
const
GrTextureProxy
*
asTextureProxy
(
)
const
override
{
return
this
;
}
bool
instantiate
(
GrResourceProvider
*
)
override
;
skgpu
:
:
Mipmapped
mipmapped
(
)
const
;
bool
mipmapsAreDirty
(
)
const
{
SkASSERT
(
(
skgpu
:
:
Mipmapped
:
:
kNo
=
=
fMipmapped
)
=
=
(
GrMipmapStatus
:
:
kNotAllocated
=
=
fMipmapStatus
)
)
;
return
skgpu
:
:
Mipmapped
:
:
kYes
=
=
fMipmapped
&
&
GrMipmapStatus
:
:
kValid
!
=
fMipmapStatus
;
}
void
markMipmapsDirty
(
)
{
SkASSERT
(
skgpu
:
:
Mipmapped
:
:
kYes
=
=
fMipmapped
)
;
fMipmapStatus
=
GrMipmapStatus
:
:
kDirty
;
}
void
markMipmapsClean
(
)
{
SkASSERT
(
skgpu
:
:
Mipmapped
:
:
kYes
=
=
fMipmapped
)
;
fMipmapStatus
=
GrMipmapStatus
:
:
kValid
;
}
skgpu
:
:
Mipmapped
proxyMipmapped
(
)
const
{
return
fMipmapped
;
}
GrTextureType
textureType
(
)
const
;
bool
hasRestrictedSampling
(
)
const
{
return
GrTextureTypeHasRestrictedSampling
(
this
-
>
textureType
(
)
)
;
}
static
bool
ProxiesAreCompatibleAsDynamicState
(
const
GrSurfaceProxy
*
first
const
GrSurfaceProxy
*
second
)
;
const
skgpu
:
:
UniqueKey
&
getUniqueKey
(
)
const
override
{
#
ifdef
SK_DEBUG
if
(
this
-
>
isInstantiated
(
)
&
&
fUniqueKey
.
isValid
(
)
&
&
fSyncTargetKey
&
&
fCreatingProvider
=
=
GrDDLProvider
:
:
kNo
)
{
GrSurface
*
surface
=
this
-
>
peekSurface
(
)
;
SkASSERT
(
surface
)
;
SkASSERT
(
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
SkASSERT
(
fUniqueKey
=
=
surface
-
>
getUniqueKey
(
)
)
;
}
#
endif
return
fUniqueKey
;
}
class
CacheAccess
;
inline
CacheAccess
cacheAccess
(
)
;
inline
const
CacheAccess
cacheAccess
(
)
const
;
GrTextureProxyPriv
texPriv
(
)
;
const
GrTextureProxyPriv
texPriv
(
)
const
;
SkDEBUGCODE
(
GrDDLProvider
creatingProvider
(
)
const
{
return
fCreatingProvider
;
}
)
protected
:
friend
class
GrSurfaceProxy
;
friend
class
GrProxyProvider
;
friend
class
GrTextureProxyPriv
;
friend
class
GrSurfaceProxyPriv
;
GrTextureProxy
(
const
GrBackendFormat
&
SkISize
skgpu
:
:
Mipmapped
GrMipmapStatus
SkBackingFit
skgpu
:
:
Budgeted
skgpu
:
:
Protected
GrInternalSurfaceFlags
UseAllocator
GrDDLProvider
creatingProvider
std
:
:
string_view
label
)
;
GrTextureProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
skgpu
:
:
Mipmapped
GrMipmapStatus
SkBackingFit
skgpu
:
:
Budgeted
skgpu
:
:
Protected
GrInternalSurfaceFlags
UseAllocator
GrDDLProvider
creatingProvider
std
:
:
string_view
label
)
;
GrTextureProxy
(
sk_sp
<
GrSurface
>
UseAllocator
GrDDLProvider
creatingProvider
)
;
~
GrTextureProxy
(
)
override
;
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
override
;
void
setTargetKeySync
(
bool
sync
)
{
fSyncTargetKey
=
sync
;
}
private
:
skgpu
:
:
Mipmapped
fMipmapped
;
GrMipmapStatus
fMipmapStatus
;
SkDEBUGCODE
(
const
GrMipmapStatus
fInitialMipmapStatus
;
)
bool
fSyncTargetKey
=
true
;
GrDDLProvider
fCreatingProvider
=
GrDDLProvider
:
:
kNo
;
skgpu
:
:
UniqueKey
fUniqueKey
;
GrProxyProvider
*
fProxyProvider
;
LazySurfaceDesc
callbackDesc
(
)
const
override
;
std
:
:
unique_ptr
<
GrDeferredProxyUploader
>
fDeferredUploader
;
size_t
onUninstantiatedGpuMemorySize
(
)
const
override
;
void
setUniqueKey
(
GrProxyProvider
*
const
skgpu
:
:
UniqueKey
&
)
;
void
clearUniqueKey
(
)
;
SkDEBUGCODE
(
void
onValidateSurface
(
const
GrSurface
*
)
override
;
)
using
INHERITED
=
GrSurfaceProxy
;
}
;
#
endif
