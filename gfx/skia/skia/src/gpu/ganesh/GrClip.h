#
ifndef
GrClip_DEFINED
#
define
GrClip_DEFINED
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAppliedClip
.
h
"
class
GrDrawOp
;
namespace
skgpu
{
namespace
ganesh
{
class
SurfaceDrawContext
;
}
}
class
GrClip
{
public
:
enum
class
Effect
{
kClipped
kUnclipped
kClippedOut
}
;
struct
PreClipResult
{
Effect
fEffect
;
SkRRect
fRRect
;
GrAA
fAA
;
bool
fIsRRect
;
PreClipResult
(
Effect
effect
)
:
fEffect
(
effect
)
fIsRRect
(
false
)
{
}
PreClipResult
(
SkRect
rect
GrAA
aa
)
:
PreClipResult
(
SkRRect
:
:
MakeRect
(
rect
)
aa
)
{
}
PreClipResult
(
SkRRect
rrect
GrAA
aa
)
:
fEffect
(
Effect
:
:
kClipped
)
fRRect
(
rrect
)
fAA
(
aa
)
fIsRRect
(
true
)
{
}
}
;
virtual
~
GrClip
(
)
{
}
virtual
SkIRect
getConservativeBounds
(
)
const
=
0
;
virtual
Effect
apply
(
GrRecordingContext
*
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
GrDrawOp
*
GrAAType
GrAppliedClip
*
SkRect
*
bounds
)
const
=
0
;
virtual
PreClipResult
preApply
(
const
SkRect
&
drawBounds
GrAA
aa
)
const
{
SkIRect
pixelBounds
=
GetPixelIBounds
(
drawBounds
aa
)
;
bool
outside
=
!
SkIRect
:
:
Intersects
(
pixelBounds
this
-
>
getConservativeBounds
(
)
)
;
return
outside
?
Effect
:
:
kClippedOut
:
Effect
:
:
kClipped
;
}
constexpr
static
SkScalar
kBoundsTolerance
=
1e
-
3f
;
constexpr
static
SkScalar
kHalfPixelRoundingTolerance
=
5e
-
2f
;
static
bool
IsInsideClip
(
const
SkIRect
&
innerClipBounds
const
SkRect
&
drawBounds
GrAA
aa
)
{
return
innerClipBounds
.
contains
(
GetPixelIBounds
(
drawBounds
aa
)
)
;
}
static
bool
IsOutsideClip
(
const
SkIRect
&
outerClipBounds
const
SkRect
&
drawBounds
GrAA
aa
)
{
return
!
SkIRect
:
:
Intersects
(
outerClipBounds
GetPixelIBounds
(
drawBounds
aa
)
)
;
}
enum
class
BoundsType
{
kExterior
kInterior
}
;
static
SkIRect
GetPixelIBounds
(
const
SkRect
&
bounds
GrAA
aa
BoundsType
mode
=
BoundsType
:
:
kExterior
)
{
auto
roundLow
=
[
aa
]
(
float
v
)
{
v
+
=
kBoundsTolerance
;
return
aa
=
=
GrAA
:
:
kNo
?
SkScalarRoundToInt
(
v
-
kHalfPixelRoundingTolerance
)
:
SkScalarFloorToInt
(
v
)
;
}
;
auto
roundHigh
=
[
aa
]
(
float
v
)
{
v
-
=
kBoundsTolerance
;
return
aa
=
=
GrAA
:
:
kNo
?
SkScalarRoundToInt
(
v
+
kHalfPixelRoundingTolerance
)
:
SkScalarCeilToInt
(
v
)
;
}
;
if
(
bounds
.
isEmpty
(
)
)
{
return
SkIRect
:
:
MakeEmpty
(
)
;
}
if
(
mode
=
=
BoundsType
:
:
kExterior
)
{
return
SkIRect
:
:
MakeLTRB
(
roundLow
(
bounds
.
fLeft
)
roundLow
(
bounds
.
fTop
)
roundHigh
(
bounds
.
fRight
)
roundHigh
(
bounds
.
fBottom
)
)
;
}
else
{
return
SkIRect
:
:
MakeLTRB
(
roundHigh
(
bounds
.
fLeft
)
roundHigh
(
bounds
.
fTop
)
roundLow
(
bounds
.
fRight
)
roundLow
(
bounds
.
fBottom
)
)
;
}
}
static
bool
IsPixelAligned
(
const
SkRect
&
rect
)
{
return
SkScalarAbs
(
SkScalarRoundToScalar
(
rect
.
fLeft
)
-
rect
.
fLeft
)
<
=
kBoundsTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
rect
.
fTop
)
-
rect
.
fTop
)
<
=
kBoundsTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
rect
.
fRight
)
-
rect
.
fRight
)
<
=
kBoundsTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
rect
.
fBottom
)
-
rect
.
fBottom
)
<
=
kBoundsTolerance
;
}
}
;
class
GrHardClip
:
public
GrClip
{
public
:
virtual
Effect
apply
(
GrAppliedHardClip
*
out
SkIRect
*
bounds
)
const
=
0
;
private
:
Effect
apply
(
GrRecordingContext
*
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
GrDrawOp
*
GrAAType
aa
GrAppliedClip
*
out
SkRect
*
bounds
)
const
final
{
SkIRect
pixelBounds
=
GetPixelIBounds
(
*
bounds
GrAA
(
aa
!
=
GrAAType
:
:
kNone
)
)
;
Effect
effect
=
this
-
>
apply
(
&
out
-
>
hardClip
(
)
&
pixelBounds
)
;
bounds
-
>
intersect
(
SkRect
:
:
Make
(
pixelBounds
)
)
;
return
effect
;
}
}
;
#
endif
