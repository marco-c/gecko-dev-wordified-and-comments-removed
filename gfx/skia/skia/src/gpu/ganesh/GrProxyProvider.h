#
ifndef
GrProxyProvider_DEFINED
#
define
GrProxyProvider_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
class
GrBackendRenderTarget
;
class
GrContextThreadSafeProxy
;
class
GrImageContext
;
class
GrSurfaceProxyView
;
class
SkBitmap
;
class
SkImage
;
enum
class
SkTextureCompressionType
;
struct
GrVkDrawableInfo
;
class
GrProxyProvider
{
public
:
using
UseAllocator
=
GrSurfaceProxy
:
:
UseAllocator
;
GrProxyProvider
(
GrImageContext
*
)
;
~
GrProxyProvider
(
)
;
bool
assignUniqueKeyToProxy
(
const
skgpu
:
:
UniqueKey
&
GrTextureProxy
*
)
;
void
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
)
;
void
removeUniqueKeyFromProxy
(
GrTextureProxy
*
)
;
sk_sp
<
GrTextureProxy
>
findProxyByUniqueKey
(
const
skgpu
:
:
UniqueKey
&
)
;
sk_sp
<
GrTextureProxy
>
findOrCreateProxyByUniqueKey
(
const
skgpu
:
:
UniqueKey
&
UseAllocator
=
UseAllocator
:
:
kYes
)
;
GrSurfaceProxyView
findCachedProxyWithColorTypeFallback
(
const
skgpu
:
:
UniqueKey
&
GrSurfaceOrigin
GrColorType
int
sampleCnt
)
;
sk_sp
<
GrTextureProxy
>
createProxyFromBitmap
(
const
SkBitmap
&
GrMipmapped
SkBackingFit
skgpu
:
:
Budgeted
)
;
sk_sp
<
GrTextureProxy
>
createProxy
(
const
GrBackendFormat
&
SkISize
dimensions
GrRenderable
int
renderTargetSampleCnt
GrMipmapped
SkBackingFit
skgpu
:
:
Budgeted
GrProtected
std
:
:
string_view
label
GrInternalSurfaceFlags
=
GrInternalSurfaceFlags
:
:
kNone
UseAllocator
useAllocator
=
UseAllocator
:
:
kYes
)
;
sk_sp
<
GrTextureProxy
>
createCompressedTextureProxy
(
SkISize
dimensions
skgpu
:
:
Budgeted
GrMipmapped
GrProtected
SkTextureCompressionType
sk_sp
<
SkData
>
data
)
;
typedef
void
*
ReleaseContext
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseContext
)
;
sk_sp
<
GrTextureProxy
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
GrIOType
sk_sp
<
skgpu
:
:
RefCntedCallback
>
=
nullptr
)
;
sk_sp
<
GrTextureProxy
>
wrapCompressedBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
GrWrapCacheable
sk_sp
<
skgpu
:
:
RefCntedCallback
>
)
;
sk_sp
<
GrTextureProxy
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
sk_sp
<
skgpu
:
:
RefCntedCallback
>
releaseHelper
)
;
sk_sp
<
GrSurfaceProxy
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
releaseHelper
)
;
sk_sp
<
GrRenderTargetProxy
>
wrapVulkanSecondaryCBAsRenderTarget
(
const
SkImageInfo
&
const
GrVkDrawableInfo
&
)
;
using
LazyInstantiationKeyMode
=
GrSurfaceProxy
:
:
LazyInstantiationKeyMode
;
using
LazySurfaceDesc
=
GrSurfaceProxy
:
:
LazySurfaceDesc
;
using
LazyCallbackResult
=
GrSurfaceProxy
:
:
LazyCallbackResult
;
using
LazyInstantiateCallback
=
GrSurfaceProxy
:
:
LazyInstantiateCallback
;
struct
TextureInfo
{
GrMipmapped
fMipmapped
;
GrTextureType
fTextureType
;
}
;
static
sk_sp
<
GrTextureProxy
>
CreatePromiseProxy
(
GrContextThreadSafeProxy
*
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
dimensions
GrMipmapped
)
;
sk_sp
<
GrTextureProxy
>
createLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
dimensions
GrMipmapped
GrMipmapStatus
GrInternalSurfaceFlags
SkBackingFit
skgpu
:
:
Budgeted
GrProtected
UseAllocator
std
:
:
string_view
label
)
;
sk_sp
<
GrRenderTargetProxy
>
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
dimensions
int
renderTargetSampleCnt
GrInternalSurfaceFlags
const
TextureInfo
*
GrMipmapStatus
SkBackingFit
skgpu
:
:
Budgeted
GrProtected
bool
wrapsVkSecondaryCB
UseAllocator
useAllocator
)
;
static
sk_sp
<
GrTextureProxy
>
MakeFullyLazyProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
GrRenderable
int
renderTargetSampleCnt
GrProtected
const
GrCaps
&
UseAllocator
)
;
enum
class
InvalidateGPUResource
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
processInvalidUniqueKey
(
const
skgpu
:
:
UniqueKey
&
GrTextureProxy
*
InvalidateGPUResource
)
;
GrDDLProvider
isDDLProvider
(
)
const
;
uint32_t
contextID
(
)
const
;
const
GrCaps
*
caps
(
)
const
;
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
;
int
numUniqueKeyProxies_TestOnly
(
)
const
;
void
orphanAllUniqueKeys
(
)
;
void
removeAllUniqueKeys
(
)
;
bool
renderingDirectly
(
)
const
;
#
if
GR_TEST_UTILS
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
SkISize
dimensions
const
GrBackendFormat
&
format
GrRenderable
renderable
int
renderTargetSampleCnt
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
)
;
sk_sp
<
GrTextureProxy
>
testingOnly_createInstantiatedProxy
(
SkISize
dimensions
GrColorType
colorType
GrRenderable
renderable
int
renderTargetSampleCnt
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
)
;
sk_sp
<
GrTextureProxy
>
testingOnly_createWrapped
(
sk_sp
<
GrTexture
>
)
;
#
endif
private
:
friend
class
GrAHardwareBufferImageGenerator
;
friend
class
GrResourceProvider
;
enum
class
RemoveTableEntry
{
kNo
kYes
}
;
void
processInvalidUniqueKeyImpl
(
const
skgpu
:
:
UniqueKey
&
GrTextureProxy
*
InvalidateGPUResource
RemoveTableEntry
)
;
bool
isAbandoned
(
)
const
;
sk_sp
<
GrTextureProxy
>
createNonMippedProxyFromBitmap
(
const
SkBitmap
&
SkBackingFit
skgpu
:
:
Budgeted
)
;
sk_sp
<
GrTextureProxy
>
createMippedProxyFromBitmap
(
const
SkBitmap
&
skgpu
:
:
Budgeted
)
;
sk_sp
<
GrTextureProxy
>
createWrapped
(
sk_sp
<
GrTexture
>
tex
UseAllocator
useAllocator
)
;
struct
UniquelyKeyedProxyHashTraits
{
static
const
skgpu
:
:
UniqueKey
&
GetKey
(
const
GrTextureProxy
&
p
)
{
return
p
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
skgpu
:
:
UniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrTextureProxy
skgpu
:
:
UniqueKey
UniquelyKeyedProxyHashTraits
>
UniquelyKeyedProxyHash
;
UniquelyKeyedProxyHash
fUniquelyKeyedProxies
;
GrImageContext
*
fImageContext
;
}
;
#
endif
