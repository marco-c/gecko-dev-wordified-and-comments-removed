#
ifndef
SurfaceDrawContext_v1_DEFINED
#
define
SurfaceDrawContext_v1_DEFINED
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkDrawable
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrPaint
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrXferProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceFillContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
OpsTask
.
h
"
class
GrBackendSemaphore
;
class
GrClip
;
class
GrColorSpaceXform
;
class
GrDrawOp
;
class
GrDstProxyView
;
class
GrHardClip
;
class
GrOp
;
struct
GrQuadSetEntry
;
class
GrRenderTarget
;
class
GrStyledShape
;
class
GrStyle
;
class
GrTextureProxy
;
struct
GrTextureSetEntry
;
struct
GrUserStencilSettings
;
struct
SkDrawShadowRec
;
struct
SkIPoint
;
struct
SkIRect
;
class
SkLatticeIter
;
class
SkMatrixProvider
;
class
SkMatrix
;
class
SkPaint
;
class
SkPath
;
struct
SkPoint
;
struct
SkRect
;
class
SkRegion
;
class
SkRRect
;
struct
SkRSXform
;
class
SkTextBlob
;
class
SkVertices
;
namespace
sktext
{
class
GlyphRunList
;
}
namespace
skgpu
:
:
ganesh
{
class
SurfaceDrawContext
final
:
public
SurfaceFillContext
{
public
:
static
std
:
:
unique_ptr
<
SurfaceDrawContext
>
Make
(
GrRecordingContext
*
GrColorType
sk_sp
<
GrSurfaceProxy
>
sk_sp
<
SkColorSpace
>
GrSurfaceOrigin
const
SkSurfaceProps
&
)
;
static
std
:
:
unique_ptr
<
SurfaceDrawContext
>
Make
(
GrRecordingContext
*
GrColorType
sk_sp
<
SkColorSpace
>
SkBackingFit
SkISize
dimensions
const
SkSurfaceProps
&
std
:
:
string_view
label
int
sampleCnt
=
1
skgpu
:
:
Mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
skgpu
:
:
Protected
=
skgpu
:
:
Protected
:
:
kNo
GrSurfaceOrigin
=
kBottomLeft_GrSurfaceOrigin
skgpu
:
:
Budgeted
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
static
std
:
:
unique_ptr
<
SurfaceDrawContext
>
Make
(
GrRecordingContext
*
sk_sp
<
SkColorSpace
>
SkBackingFit
SkISize
dimensions
const
GrBackendFormat
&
int
sampleCnt
skgpu
:
:
Mipmapped
skgpu
:
:
Protected
skgpu
:
:
Swizzle
readSwizzle
skgpu
:
:
Swizzle
writeSwizzle
GrSurfaceOrigin
skgpu
:
:
Budgeted
const
SkSurfaceProps
&
std
:
:
string_view
label
)
;
static
std
:
:
unique_ptr
<
SurfaceDrawContext
>
MakeWithFallback
(
GrRecordingContext
*
GrColorType
sk_sp
<
SkColorSpace
>
SkBackingFit
SkISize
dimensions
const
SkSurfaceProps
&
int
sampleCnt
=
1
skgpu
:
:
Mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
skgpu
:
:
Protected
=
skgpu
:
:
Protected
:
:
kNo
GrSurfaceOrigin
=
kBottomLeft_GrSurfaceOrigin
skgpu
:
:
Budgeted
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
static
std
:
:
unique_ptr
<
SurfaceDrawContext
>
MakeFromBackendTexture
(
GrRecordingContext
*
GrColorType
sk_sp
<
SkColorSpace
>
const
GrBackendTexture
&
int
sampleCnt
GrSurfaceOrigin
const
SkSurfaceProps
&
sk_sp
<
skgpu
:
:
RefCntedCallback
>
releaseHelper
)
;
SurfaceDrawContext
(
GrRecordingContext
*
GrSurfaceProxyView
readView
GrSurfaceProxyView
writeView
GrColorType
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
&
)
;
~
SurfaceDrawContext
(
)
override
;
void
drawPaint
(
const
GrClip
*
GrPaint
&
&
const
SkMatrix
&
viewMatrix
)
;
void
drawRect
(
const
GrClip
*
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
const
GrStyle
*
style
=
nullptr
)
;
void
fillRectToRect
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
const
SkRect
&
rectToDraw
const
SkRect
&
localRect
)
;
void
fillPixelsWithLocalMatrix
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkIRect
&
bounds
const
SkMatrix
&
localMatrix
)
{
SkRect
rect
=
SkRect
:
:
Make
(
bounds
)
;
DrawQuad
quad
{
GrQuad
:
:
MakeFromRect
(
rect
SkMatrix
:
:
I
(
)
)
GrQuad
:
:
MakeFromRect
(
rect
localMatrix
)
GrQuadAAFlags
:
:
kNone
}
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
&
quad
)
;
}
void
fillRectWithEdgeAA
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkRect
*
optionalLocalRect
=
nullptr
)
{
if
(
edgeAA
=
=
GrQuadAAFlags
:
:
kAll
)
{
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kYes
viewMatrix
rect
(
optionalLocalRect
)
?
*
optionalLocalRect
:
rect
)
;
return
;
}
const
SkRect
&
localRect
=
optionalLocalRect
?
*
optionalLocalRect
:
rect
;
DrawQuad
quad
{
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
(
localRect
)
edgeAA
}
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
&
quad
)
;
}
void
fillQuadWithEdgeAA
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkPoint
points
[
4
]
const
SkPoint
optionalLocalPoints
[
4
]
)
{
const
SkPoint
*
localPoints
=
optionalLocalPoints
?
optionalLocalPoints
:
points
;
DrawQuad
quad
{
GrQuad
:
:
MakeFromSkQuad
(
points
viewMatrix
)
GrQuad
:
:
MakeFromSkQuad
(
localPoints
SkMatrix
:
:
I
(
)
)
edgeAA
}
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
&
quad
)
;
}
void
drawQuadSet
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
GrQuadSetEntry
[
]
int
cnt
)
;
void
drawTexture
(
const
GrClip
*
GrSurfaceProxyView
SkAlphaType
GrSamplerState
:
:
Filter
GrSamplerState
:
:
MipmapMode
SkBlendMode
const
SkPMColor4f
&
const
SkRect
&
srcRect
const
SkRect
&
dstRect
GrQuadAAFlags
SkCanvas
:
:
SrcRectConstraint
const
SkMatrix
&
sk_sp
<
GrColorSpaceXform
>
)
;
void
drawTextureQuad
(
const
GrClip
*
clip
GrSurfaceProxyView
view
GrColorType
srcColorType
SkAlphaType
srcAlphaType
GrSamplerState
:
:
Filter
filter
GrSamplerState
:
:
MipmapMode
mm
SkBlendMode
mode
const
SkPMColor4f
&
color
const
SkPoint
srcQuad
[
4
]
const
SkPoint
dstQuad
[
4
]
GrQuadAAFlags
edgeAA
const
SkRect
*
subset
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
DrawQuad
quad
{
GrQuad
:
:
MakeFromSkQuad
(
dstQuad
viewMatrix
)
GrQuad
:
:
MakeFromSkQuad
(
srcQuad
SkMatrix
:
:
I
(
)
)
edgeAA
}
;
this
-
>
drawTexturedQuad
(
clip
std
:
:
move
(
view
)
srcAlphaType
std
:
:
move
(
texXform
)
filter
mm
color
mode
&
quad
subset
)
;
}
void
drawTextureSet
(
const
GrClip
*
GrTextureSetEntry
[
]
int
cnt
int
proxyRunCnt
GrSamplerState
:
:
Filter
GrSamplerState
:
:
MipmapMode
SkBlendMode
mode
SkCanvas
:
:
SrcRectConstraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
;
void
drawRRect
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
;
bool
drawFastShadow
(
const
GrClip
*
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
;
void
drawPath
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
const
GrStyle
&
)
;
void
drawShape
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
GrStyledShape
&
&
)
;
void
drawVertices
(
const
GrClip
*
GrPaint
&
&
paint
const
SkMatrixProvider
&
matrixProvider
sk_sp
<
SkVertices
>
vertices
GrPrimitiveType
*
overridePrimType
=
nullptr
bool
skipColorXform
=
false
)
;
void
drawMesh
(
const
GrClip
*
GrPaint
&
&
paint
const
SkMatrixProvider
&
matrixProvider
const
SkMesh
&
mesh
)
;
void
drawAtlas
(
const
GrClip
*
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
;
void
drawRegion
(
const
GrClip
*
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
void
drawOval
(
const
GrClip
*
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
;
void
drawArc
(
const
GrClip
*
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
;
void
drawImageLattice
(
const
GrClip
*
GrPaint
&
&
const
SkMatrix
&
viewMatrix
GrSurfaceProxyView
SkAlphaType
alphaType
sk_sp
<
GrColorSpaceXform
>
GrSamplerState
:
:
Filter
std
:
:
unique_ptr
<
SkLatticeIter
>
const
SkRect
&
dst
)
;
void
drawGlyphRunList
(
SkCanvas
*
const
GrClip
*
const
SkMatrixProvider
&
viewMatrix
const
sktext
:
:
GlyphRunList
&
glyphRunList
SkStrikeDeviceInfo
strikeDeviceInfo
const
SkPaint
&
paint
)
;
void
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
const
SkRect
&
bounds
)
;
void
setLastClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticElements
)
;
bool
mustRenderClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticElements
)
;
void
clearStencilClip
(
const
SkIRect
&
scissor
bool
insideStencilMask
)
{
this
-
>
internalStencilClear
(
&
scissor
insideStencilMask
)
;
}
void
stencilRect
(
const
GrClip
*
clip
const
GrUserStencilSettings
*
ss
GrPaint
&
&
paint
GrAA
doStencilMSAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkMatrix
*
localMatrix
=
nullptr
)
{
DrawQuad
quad
{
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
localMatrix
?
GrQuad
:
:
MakeFromRect
(
rect
*
localMatrix
)
:
GrQuad
(
rect
)
doStencilMSAA
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
}
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
&
quad
ss
)
;
}
bool
stencilPath
(
const
GrHardClip
*
GrAA
doStencilMSAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
)
;
bool
drawAndStencilPath
(
const
GrHardClip
*
const
GrUserStencilSettings
*
SkRegion
:
:
Op
op
bool
invert
GrAA
doStencilMSAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
)
;
skgpu
:
:
Budgeted
isBudgeted
(
)
const
;
int
maxWindowRectangles
(
)
const
;
GrSurfaceProxy
:
:
UniqueID
uniqueID
(
)
const
{
return
this
-
>
asSurfaceProxy
(
)
-
>
uniqueID
(
)
;
}
using
WillAddOpFn
=
void
(
GrOp
*
uint32_t
opsTaskID
)
;
void
addDrawOp
(
const
GrClip
*
GrOp
:
:
Owner
const
std
:
:
function
<
WillAddOpFn
>
&
=
std
:
:
function
<
WillAddOpFn
>
(
)
)
;
void
addDrawOp
(
GrOp
:
:
Owner
op
)
{
this
-
>
addDrawOp
(
nullptr
std
:
:
move
(
op
)
)
;
}
bool
refsWrappedObjects
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
refsWrappedObjects
(
)
;
}
bool
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
bool
deleteSemaphoresAfterWait
)
;
int
numSamples
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
numSamples
(
)
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
bool
canUseDynamicMSAA
(
)
const
{
return
fCanUseDynamicMSAA
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
wrapsVkSecondaryCB
(
)
;
}
bool
alwaysAntialias
(
)
const
{
return
fSurfaceProps
.
flags
(
)
&
SkSurfaceProps
:
:
kDynamicMSAA_Flag
;
}
GrAA
chooseAA
(
const
SkPaint
&
paint
)
{
return
GrAA
(
paint
.
isAntiAlias
(
)
|
|
this
-
>
alwaysAntialias
(
)
)
;
}
GrAAType
chooseAAType
(
GrAA
aa
)
{
if
(
this
-
>
numSamples
(
)
>
1
|
|
fCanUseDynamicMSAA
)
{
return
GrAAType
:
:
kMSAA
;
}
return
(
aa
=
=
GrAA
:
:
kYes
)
?
GrAAType
:
:
kCoverage
:
GrAAType
:
:
kNone
;
}
GrRenderTarget
*
accessRenderTarget
(
)
{
return
this
-
>
asSurfaceProxy
(
)
-
>
peekRenderTarget
(
)
;
}
#
if
GR_TEST_UTILS
void
testingOnly_SetPreserveOpsOnFullClear
(
)
{
fPreserveOpsOnFullClear_TestingOnly
=
true
;
}
#
endif
void
drawStrokedLine
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
const
SkPoint
[
2
]
const
SkStrokeRec
&
)
;
private
:
enum
class
QuadOptimization
;
void
willReplaceOpsTask
(
OpsTask
*
prevTask
OpsTask
*
nextTask
)
override
;
OpsTask
:
:
CanDiscardPreviousOps
canDiscardPreviousOpsOnFullClear
(
)
const
override
;
void
setNeedsStencil
(
)
;
void
internalStencilClear
(
const
SkIRect
*
scissor
bool
insideStencilMask
)
;
QuadOptimization
attemptQuadOptimization
(
const
GrClip
*
clip
const
GrUserStencilSettings
*
stencilSettings
DrawQuad
*
quad
GrPaint
*
paint
)
;
void
drawFilledQuad
(
const
GrClip
*
clip
GrPaint
&
&
paint
DrawQuad
*
quad
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
void
drawTexturedQuad
(
const
GrClip
*
clip
GrSurfaceProxyView
proxyView
SkAlphaType
alphaType
sk_sp
<
GrColorSpaceXform
>
textureXform
GrSamplerState
:
:
Filter
filter
GrSamplerState
:
:
MipmapMode
const
SkPMColor4f
&
color
SkBlendMode
blendMode
DrawQuad
*
quad
const
SkRect
*
subset
=
nullptr
)
;
bool
drawSimpleShape
(
const
GrClip
*
GrPaint
*
GrAA
const
SkMatrix
&
const
GrStyledShape
&
)
;
void
drawShapeUsingPathRenderer
(
const
GrClip
*
GrPaint
&
&
GrAA
const
SkMatrix
&
GrStyledShape
&
&
bool
attemptDrawSimple
=
false
)
;
bool
SK_WARN_UNUSED_RESULT
setupDstProxyView
(
const
SkRect
&
opBounds
bool
opRequiresMSAA
GrDstProxyView
*
result
)
;
OpsTask
*
replaceOpsTaskIfModifiesColor
(
)
;
const
SkSurfaceProps
fSurfaceProps
;
const
bool
fCanUseDynamicMSAA
;
bool
fNeedsStencil
=
false
;
#
if
GR_TEST_UTILS
bool
fPreserveOpsOnFullClear_TestingOnly
=
false
;
#
endif
}
;
}
#
endif
