#
ifndef
GrFragmentProcessor_DEFINED
#
define
GrFragmentProcessor_DEFINED
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkSLSampleUsage
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
<
tuple
>
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLProgramDataManager
;
class
GrPaint
;
class
GrPipeline
;
struct
GrShaderCaps
;
class
GrTextureEffect
;
namespace
skgpu
{
class
KeyBuilder
;
class
Swizzle
;
}
class
GrFragmentProcessor
;
using
GrFPResult
=
std
:
:
tuple
<
bool
std
:
:
unique_ptr
<
GrFragmentProcessor
>
>
;
class
GrFragmentProcessor
:
public
GrProcessor
{
public
:
class
ProgramImpl
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeColor
(
SkPMColor4f
color
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MulInputByChildAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
ApplyPaintAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
ModulateRGBA
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
const
SkPMColor4f
&
color
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
OverrideInput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
SkPMColor4f
&
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
DisableCoverageAsAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
DestColor
(
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
SwizzleOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
skgpu
:
:
Swizzle
&
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
ClampOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Compose
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
f
std
:
:
unique_ptr
<
GrFragmentProcessor
>
g
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
ColorMatrix
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
const
float
matrix
[
20
]
bool
unpremulInput
bool
clampRGBOutput
bool
premulOutput
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
SurfaceColor
(
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
DeviceSpace
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Rect
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrClipEdgeType
SkRect
)
;
static
GrFPResult
Circle
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrClipEdgeType
SkPoint
center
float
radius
)
;
static
GrFPResult
Ellipse
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrClipEdgeType
SkPoint
center
SkPoint
radii
const
GrShaderCaps
&
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
HighPrecision
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
=
0
;
const
GrFragmentProcessor
*
parent
(
)
const
{
return
fParent
;
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
)
const
;
void
addToKey
(
const
GrShaderCaps
&
caps
skgpu
:
:
KeyBuilder
*
b
)
const
{
this
-
>
onAddToKey
(
caps
b
)
;
for
(
const
auto
&
child
:
fChildProcessors
)
{
if
(
child
)
{
child
-
>
addToKey
(
caps
b
)
;
}
}
}
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
size
(
)
;
}
int
numNonNullChildProcessors
(
)
const
;
GrFragmentProcessor
*
childProcessor
(
int
index
)
{
return
fChildProcessors
[
index
]
.
get
(
)
;
}
const
GrFragmentProcessor
*
childProcessor
(
int
index
)
const
{
return
fChildProcessors
[
index
]
.
get
(
)
;
}
SkDEBUGCODE
(
bool
isInstantiated
(
)
const
;
)
bool
willReadDstColor
(
)
const
{
return
SkToBool
(
fFlags
&
kWillReadDstColor_Flag
)
;
}
bool
isBlendFunction
(
)
const
{
return
SkToBool
(
fFlags
&
kIsBlendFunction_Flag
)
;
}
bool
usesSampleCoordsDirectly
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesSampleCoordsDirectly_Flag
)
;
}
bool
usesSampleCoords
(
)
const
{
return
SkToBool
(
fFlags
&
(
kUsesSampleCoordsDirectly_Flag
|
kUsesSampleCoordsIndirectly_Flag
)
)
;
}
const
SkSL
:
:
SampleUsage
&
sampleUsage
(
)
const
{
return
fUsage
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
SkToBool
(
fFlags
&
kCompatibleWithCoverageAsAlpha_OptimizationFlag
)
;
}
bool
preservesOpaqueInput
(
)
const
{
return
SkToBool
(
fFlags
&
kPreservesOpaqueInput_OptimizationFlag
)
;
}
bool
hasConstantOutputForConstantInput
(
SkPMColor4f
inputColor
SkPMColor4f
*
outputColor
)
const
{
if
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
{
*
outputColor
=
this
-
>
constantOutputForConstantInput
(
inputColor
)
;
return
true
;
}
return
false
;
}
bool
hasConstantOutputForConstantInput
(
)
const
{
return
SkToBool
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
;
}
bool
isEqual
(
const
GrFragmentProcessor
&
that
)
const
;
void
visitProxies
(
const
GrVisitProxyFunc
&
)
const
;
void
visitTextureEffects
(
const
std
:
:
function
<
void
(
const
GrTextureEffect
&
)
>
&
)
const
;
void
visitWithImpls
(
const
std
:
:
function
<
void
(
const
GrFragmentProcessor
&
ProgramImpl
&
)
>
&
ProgramImpl
&
)
const
;
GrTextureEffect
*
asTextureEffect
(
)
;
const
GrTextureEffect
*
asTextureEffect
(
)
const
;
#
if
GR_TEST_UTILS
SkString
dumpTreeInfo
(
)
const
;
#
endif
protected
:
enum
OptimizationFlags
:
uint32_t
{
kNone_OptimizationFlags
kCompatibleWithCoverageAsAlpha_OptimizationFlag
=
0x1
kPreservesOpaqueInput_OptimizationFlag
=
0x2
kConstantOutputForConstantInput_OptimizationFlag
=
0x4
kAll_OptimizationFlags
=
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
|
kConstantOutputForConstantInput_OptimizationFlag
}
;
SK_DECL_BITFIELD_OPS_FRIENDS
(
OptimizationFlags
)
static
OptimizationFlags
ModulateForSamplerOptFlags
(
SkAlphaType
alphaType
bool
samplingDecal
)
{
if
(
samplingDecal
)
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
;
}
else
{
return
ModulateForClampedSamplerOptFlags
(
alphaType
)
;
}
}
static
OptimizationFlags
ModulateForClampedSamplerOptFlags
(
SkAlphaType
alphaType
)
{
if
(
alphaType
=
=
kOpaque_SkAlphaType
)
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
;
}
else
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
;
}
}
GrFragmentProcessor
(
ClassID
classID
OptimizationFlags
optimizationFlags
)
:
INHERITED
(
classID
)
fFlags
(
optimizationFlags
)
{
SkASSERT
(
(
optimizationFlags
&
~
kAll_OptimizationFlags
)
=
=
0
)
;
}
explicit
GrFragmentProcessor
(
const
GrFragmentProcessor
&
src
)
:
INHERITED
(
src
.
classID
(
)
)
fFlags
(
src
.
fFlags
)
{
this
-
>
cloneAndRegisterAllChildProcessors
(
src
)
;
}
OptimizationFlags
optimizationFlags
(
)
const
{
return
static_cast
<
OptimizationFlags
>
(
kAll_OptimizationFlags
&
fFlags
)
;
}
static
OptimizationFlags
ProcessorOptimizationFlags
(
const
GrFragmentProcessor
*
fp
)
{
return
fp
?
fp
-
>
optimizationFlags
(
)
:
kAll_OptimizationFlags
;
}
static
SkPMColor4f
ConstantOutputForConstantInput
(
const
GrFragmentProcessor
*
fp
const
SkPMColor4f
&
input
)
{
if
(
fp
)
{
SkASSERT
(
fp
-
>
hasConstantOutputForConstantInput
(
)
)
;
return
fp
-
>
constantOutputForConstantInput
(
input
)
;
}
else
{
return
input
;
}
}
void
registerChild
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
SkSL
:
:
SampleUsage
sampleUsage
=
SkSL
:
:
SampleUsage
:
:
PassThrough
(
)
)
;
void
cloneAndRegisterAllChildProcessors
(
const
GrFragmentProcessor
&
src
)
;
void
setUsesSampleCoordsDirectly
(
)
{
fFlags
|
=
kUsesSampleCoordsDirectly_Flag
;
}
void
setWillReadDstColor
(
)
{
fFlags
|
=
kWillReadDstColor_Flag
;
}
void
setIsBlendFunction
(
)
{
fFlags
|
=
kIsBlendFunction_Flag
;
}
void
mergeOptimizationFlags
(
OptimizationFlags
flags
)
{
SkASSERT
(
(
flags
&
~
kAll_OptimizationFlags
)
=
=
0
)
;
fFlags
&
=
(
flags
|
~
kAll_OptimizationFlags
)
;
}
private
:
virtual
SkPMColor4f
constantOutputForConstantInput
(
const
SkPMColor4f
&
)
const
{
SK_ABORT
(
"
Subclass
must
override
this
if
advertising
this
optimization
.
"
)
;
}
virtual
std
:
:
unique_ptr
<
ProgramImpl
>
onMakeProgramImpl
(
)
const
=
0
;
virtual
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
=
0
;
virtual
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
=
0
;
enum
PrivateFlags
{
kFirstPrivateFlag
=
kAll_OptimizationFlags
+
1
kUsesSampleCoordsIndirectly_Flag
=
kFirstPrivateFlag
kUsesSampleCoordsDirectly_Flag
=
kFirstPrivateFlag
<
<
1
kIsBlendFunction_Flag
=
kFirstPrivateFlag
<
<
2
kWillReadDstColor_Flag
=
kFirstPrivateFlag
<
<
3
}
;
SkSTArray
<
1
std
:
:
unique_ptr
<
GrFragmentProcessor
>
true
>
fChildProcessors
;
const
GrFragmentProcessor
*
fParent
=
nullptr
;
uint32_t
fFlags
=
0
;
SkSL
:
:
SampleUsage
fUsage
;
using
INHERITED
=
GrProcessor
;
}
;
class
GrFragmentProcessor
:
:
ProgramImpl
{
public
:
ProgramImpl
(
)
=
default
;
virtual
~
ProgramImpl
(
)
=
default
;
using
UniformHandle
=
GrGLSLUniformHandler
:
:
UniformHandle
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrFragmentProcessor
&
fp
const
char
*
inputColor
const
char
*
destColor
const
char
*
sampleCoord
)
:
fFragBuilder
(
fragBuilder
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fFp
(
fp
)
fInputColor
(
inputColor
?
inputColor
:
"
half4
(
1
.
0
)
"
)
fDestColor
(
destColor
)
fSampleCoord
(
sampleCoord
)
{
}
GrGLSLFPFragmentBuilder
*
fFragBuilder
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrFragmentProcessor
&
fFp
;
const
char
*
fInputColor
;
const
char
*
fDestColor
;
const
char
*
fSampleCoord
;
}
;
virtual
void
emitCode
(
EmitArgs
&
)
=
0
;
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
processor
)
;
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
size
(
)
;
}
ProgramImpl
*
childProcessor
(
int
index
)
const
{
return
fChildProcessors
[
index
]
.
get
(
)
;
}
void
setFunctionName
(
SkString
name
)
{
SkASSERT
(
fFunctionName
.
isEmpty
(
)
)
;
fFunctionName
=
std
:
:
move
(
name
)
;
}
const
char
*
functionName
(
)
const
{
SkASSERT
(
!
fFunctionName
.
isEmpty
(
)
)
;
return
fFunctionName
.
c_str
(
)
;
}
inline
SkString
invokeChild
(
int
childIndex
EmitArgs
&
parentArgs
std
:
:
string_view
skslCoords
=
{
}
)
{
return
this
-
>
invokeChild
(
childIndex
nullptr
nullptr
parentArgs
skslCoords
)
;
}
inline
SkString
invokeChildWithMatrix
(
int
childIndex
EmitArgs
&
parentArgs
)
{
return
this
-
>
invokeChildWithMatrix
(
childIndex
nullptr
nullptr
parentArgs
)
;
}
inline
SkString
invokeChild
(
int
childIndex
const
char
*
inputColor
EmitArgs
&
parentArgs
std
:
:
string_view
skslCoords
=
{
}
)
{
return
this
-
>
invokeChild
(
childIndex
inputColor
nullptr
parentArgs
skslCoords
)
;
}
inline
SkString
invokeChildWithMatrix
(
int
childIndex
const
char
*
inputColor
EmitArgs
&
parentArgs
)
{
return
this
-
>
invokeChildWithMatrix
(
childIndex
inputColor
nullptr
parentArgs
)
;
}
SkString
invokeChild
(
int
childIndex
const
char
*
inputColor
const
char
*
destColor
EmitArgs
&
parentArgs
std
:
:
string_view
skslCoords
=
{
}
)
;
SkString
invokeChildWithMatrix
(
int
childIndex
const
char
*
inputColor
const
char
*
destColor
EmitArgs
&
parentArgs
)
;
class
Iter
{
public
:
Iter
(
std
:
:
unique_ptr
<
ProgramImpl
>
fps
[
]
int
cnt
)
;
Iter
(
ProgramImpl
&
fp
)
{
fFPStack
.
push_back
(
&
fp
)
;
}
ProgramImpl
&
operator
*
(
)
const
;
ProgramImpl
*
operator
-
>
(
)
const
;
Iter
&
operator
+
+
(
)
;
explicit
operator
bool
(
)
const
{
return
!
fFPStack
.
empty
(
)
;
}
Iter
(
const
Iter
&
)
=
delete
;
Iter
&
operator
=
(
const
Iter
&
)
=
delete
;
private
:
SkSTArray
<
4
ProgramImpl
*
true
>
fFPStack
;
}
;
private
:
virtual
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
{
}
SkString
fFunctionName
;
SkTArray
<
std
:
:
unique_ptr
<
ProgramImpl
>
true
>
fChildProcessors
;
friend
class
GrFragmentProcessor
;
}
;
SK_MAKE_BITFIELD_OPS
(
GrFragmentProcessor
:
:
OptimizationFlags
)
static
inline
GrFPResult
GrFPFailure
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
return
{
false
std
:
:
move
(
fp
)
}
;
}
static
inline
GrFPResult
GrFPSuccess
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
SkASSERT
(
fp
)
;
return
{
true
std
:
:
move
(
fp
)
}
;
}
static
inline
GrFPResult
GrFPNullableSuccess
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
return
{
true
std
:
:
move
(
fp
)
}
;
}
#
endif
