#
ifndef
GrDawnBuffer_DEFINED
#
define
GrDawnBuffer_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrGpuBuffer
.
h
"
#
include
"
webgpu
/
webgpu_cpp
.
h
"
#
include
<
functional
>
class
GrDawnGpu
;
class
GrDawnBuffer
:
public
GrGpuBuffer
{
public
:
static
sk_sp
<
GrDawnBuffer
>
Make
(
GrDawnGpu
*
gpu
size_t
sizeInBytes
GrGpuBufferType
type
GrAccessPattern
pattern
std
:
:
string_view
label
)
;
~
GrDawnBuffer
(
)
override
=
default
;
void
onMap
(
MapType
)
override
;
void
onUnmap
(
MapType
)
override
;
bool
onClearToZero
(
)
override
;
void
onRelease
(
)
override
;
bool
onUpdateData
(
const
void
*
src
size_t
offset
size_t
size
bool
preserve
)
override
;
GrDawnGpu
*
getDawnGpu
(
)
const
;
wgpu
:
:
Buffer
get
(
)
const
{
return
fBuffer
;
}
using
MapAsyncCallback
=
std
:
:
function
<
void
(
bool
success
)
>
;
void
mapAsync
(
MapAsyncCallback
callback
)
;
private
:
enum
class
Mappable
{
kNot
kReadOnly
kWriteOnly
}
;
GrDawnBuffer
(
GrDawnGpu
*
gpu
size_t
sizeInBytes
GrGpuBufferType
type
GrAccessPattern
pattern
std
:
:
string_view
label
Mappable
mappable
wgpu
:
:
Buffer
buffer
void
*
mapPtr
)
;
void
*
internalMap
(
MapType
type
size_t
offset
size_t
size
)
;
void
internalUnmap
(
MapType
type
size_t
offset
size_t
size
)
;
void
mapAsyncDone
(
WGPUBufferMapAsyncStatus
status
)
;
void
*
blockingMap
(
size_t
offset
size_t
size
)
;
wgpu
:
:
Buffer
fBuffer
;
Mappable
fMappable
=
Mappable
:
:
kNot
;
bool
fUnmapped
;
MapAsyncCallback
fMapAsyncCallback
;
wgpu
:
:
Buffer
fStagingBuffer
;
size_t
fStagingOffset
=
0
;
using
INHERITED
=
GrGpuBuffer
;
}
;
#
endif
