#
ifndef
GrDrawOpAtlas_DEFINED
#
define
GrDrawOpAtlas_DEFINED
#
include
<
cmath
>
#
include
<
vector
>
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
src
/
core
/
SkIPoint16
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
gpu
/
RectanizerSkyline
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDeferredUpload
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
class
GrOnFlushResourceProvider
;
class
GrProxyProvider
;
class
GrResourceProvider
;
class
GrTextureProxy
;
class
GrDrawOpAtlas
{
public
:
enum
class
AllowMultitexturing
:
bool
{
kNo
kYes
}
;
static
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
Make
(
GrProxyProvider
*
proxyProvider
const
GrBackendFormat
&
format
SkColorType
ct
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
skgpu
:
:
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
skgpu
:
:
PlotEvictionCallback
*
evictor
std
:
:
string_view
label
)
;
enum
class
ErrorCode
{
kError
kSucceeded
kTryAgain
}
;
ErrorCode
addToAtlas
(
GrResourceProvider
*
GrDeferredUploadTarget
*
int
width
int
height
const
void
*
image
skgpu
:
:
AtlasLocator
*
)
;
const
GrSurfaceProxyView
*
getViews
(
)
const
{
return
fViews
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
bool
hasID
(
const
skgpu
:
:
PlotLocator
&
plotLocator
)
{
if
(
!
plotLocator
.
isValid
(
)
)
{
return
false
;
}
uint32_t
plot
=
plotLocator
.
plotIndex
(
)
;
uint32_t
page
=
plotLocator
.
pageIndex
(
)
;
uint64_t
plotGeneration
=
fPages
[
page
]
.
fPlotArray
[
plot
]
-
>
genID
(
)
;
uint64_t
locatorGeneration
=
plotLocator
.
genID
(
)
;
return
plot
<
fNumPlots
&
&
page
<
fNumActivePages
&
&
plotGeneration
=
=
locatorGeneration
;
}
void
setLastUseToken
(
const
skgpu
:
:
AtlasLocator
&
atlasLocator
skgpu
:
:
AtlasToken
token
)
{
SkASSERT
(
this
-
>
hasID
(
atlasLocator
.
plotLocator
(
)
)
)
;
uint32_t
plotIdx
=
atlasLocator
.
plotIndex
(
)
;
SkASSERT
(
plotIdx
<
fNumPlots
)
;
uint32_t
pageIdx
=
atlasLocator
.
pageIndex
(
)
;
SkASSERT
(
pageIdx
<
fNumActivePages
)
;
skgpu
:
:
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotArray
[
plotIdx
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
uint32_t
numActivePages
(
)
{
return
fNumActivePages
;
}
void
setLastUseTokenBulk
(
const
skgpu
:
:
BulkUsePlotUpdater
&
updater
skgpu
:
:
AtlasToken
token
)
{
int
count
=
updater
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
skgpu
:
:
BulkUsePlotUpdater
:
:
PlotData
&
pd
=
updater
.
plotData
(
i
)
;
if
(
pd
.
fPageIndex
<
fNumActivePages
)
{
skgpu
:
:
Plot
*
plot
=
fPages
[
pd
.
fPageIndex
]
.
fPlotArray
[
pd
.
fPlotIndex
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pd
.
fPageIndex
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
}
}
void
compact
(
skgpu
:
:
AtlasToken
startTokenForNextFlush
)
;
void
instantiate
(
GrOnFlushResourceProvider
*
)
;
uint32_t
maxPages
(
)
const
{
return
fMaxPages
;
}
int
numAllocated_TestingOnly
(
)
const
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
GrDrawOpAtlas
(
GrProxyProvider
*
const
GrBackendFormat
&
format
SkColorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
skgpu
:
:
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
std
:
:
string_view
label
)
;
inline
bool
updatePlot
(
GrDeferredUploadTarget
*
skgpu
:
:
AtlasLocator
*
skgpu
:
:
Plot
*
)
;
inline
void
makeMRU
(
skgpu
:
:
Plot
*
plot
int
pageIdx
)
{
if
(
fPages
[
pageIdx
]
.
fPlotList
.
head
(
)
=
=
plot
)
{
return
;
}
fPages
[
pageIdx
]
.
fPlotList
.
remove
(
plot
)
;
fPages
[
pageIdx
]
.
fPlotList
.
addToHead
(
plot
)
;
}
bool
uploadToPage
(
unsigned
int
pageIdx
GrDeferredUploadTarget
*
int
width
int
height
const
void
*
image
skgpu
:
:
AtlasLocator
*
)
;
void
uploadPlotToTexture
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
GrTextureProxy
*
proxy
skgpu
:
:
Plot
*
plot
)
;
bool
createPages
(
GrProxyProvider
*
skgpu
:
:
AtlasGenerationCounter
*
)
;
bool
activateNewPage
(
GrResourceProvider
*
)
;
void
deactivateLastPage
(
)
;
void
processEviction
(
skgpu
:
:
PlotLocator
)
;
inline
void
processEvictionAndResetRects
(
skgpu
:
:
Plot
*
plot
)
{
this
-
>
processEviction
(
plot
-
>
plotLocator
(
)
)
;
plot
-
>
resetRects
(
)
;
}
GrBackendFormat
fFormat
;
SkColorType
fColorType
;
size_t
fBytesPerPixel
;
int
fTextureWidth
;
int
fTextureHeight
;
int
fPlotWidth
;
int
fPlotHeight
;
unsigned
int
fNumPlots
;
const
std
:
:
string
fLabel
;
skgpu
:
:
AtlasGenerationCounter
*
const
fGenerationCounter
;
uint64_t
fAtlasGeneration
;
skgpu
:
:
AtlasToken
fPrevFlushToken
;
int
fFlushesSinceLastUse
;
std
:
:
vector
<
skgpu
:
:
PlotEvictionCallback
*
>
fEvictionCallbacks
;
struct
Page
{
std
:
:
unique_ptr
<
sk_sp
<
skgpu
:
:
Plot
>
[
]
>
fPlotArray
;
skgpu
:
:
PlotList
fPlotList
;
}
;
GrSurfaceProxyView
fViews
[
skgpu
:
:
PlotLocator
:
:
kMaxMultitexturePages
]
;
Page
fPages
[
skgpu
:
:
PlotLocator
:
:
kMaxMultitexturePages
]
;
uint32_t
fMaxPages
;
uint32_t
fNumActivePages
;
SkDEBUGCODE
(
void
validate
(
const
skgpu
:
:
AtlasLocator
&
atlasLocator
)
const
;
)
}
;
class
GrDrawOpAtlasConfig
{
public
:
GrDrawOpAtlasConfig
(
int
maxTextureSize
size_t
maxBytes
)
;
GrDrawOpAtlasConfig
(
)
:
GrDrawOpAtlasConfig
(
kMaxAtlasDim
0
)
{
}
SkISize
atlasDimensions
(
skgpu
:
:
MaskFormat
type
)
const
;
SkISize
plotDimensions
(
skgpu
:
:
MaskFormat
type
)
const
;
private
:
inline
static
constexpr
int
kMaxAtlasDim
=
2048
;
SkISize
fARGBDimensions
;
int
fMaxTextureSize
;
}
;
#
endif
