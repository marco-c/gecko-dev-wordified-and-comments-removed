#
ifndef
GrGpuResourcePriv_DEFINED
#
define
GrGpuResourcePriv_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
class
GrGpuResource
:
:
ResourcePriv
{
public
:
void
setUniqueKey
(
const
skgpu
:
:
UniqueKey
&
key
)
{
fResource
-
>
setUniqueKey
(
key
)
;
}
void
removeUniqueKey
(
)
{
fResource
-
>
removeUniqueKey
(
)
;
}
void
makeBudgeted
(
)
{
fResource
-
>
makeBudgeted
(
)
;
}
void
makeUnbudgeted
(
)
{
fResource
-
>
makeUnbudgeted
(
)
;
}
GrBudgetedType
budgetedType
(
)
const
{
SkASSERT
(
GrBudgetedType
:
:
kBudgeted
=
=
fResource
-
>
fBudgetedType
|
|
!
fResource
-
>
getUniqueKey
(
)
.
isValid
(
)
|
|
fResource
-
>
fRefsWrappedObjects
)
;
return
fResource
-
>
fBudgetedType
;
}
bool
refsWrappedObjects
(
)
const
{
return
fResource
-
>
fRefsWrappedObjects
;
}
const
skgpu
:
:
ScratchKey
&
getScratchKey
(
)
const
{
return
fResource
-
>
fScratchKey
;
}
void
removeScratchKey
(
)
const
{
fResource
-
>
removeScratchKey
(
)
;
}
bool
isPurgeable
(
)
const
{
return
fResource
-
>
isPurgeable
(
)
;
}
bool
hasRefOrCommandBufferUsage
(
)
const
{
return
fResource
-
>
hasRef
(
)
|
|
!
fResource
-
>
hasNoCommandBufferUsages
(
)
;
}
protected
:
ResourcePriv
(
GrGpuResource
*
resource
)
:
fResource
(
resource
)
{
}
ResourcePriv
(
const
ResourcePriv
&
that
)
:
fResource
(
that
.
fResource
)
{
}
ResourcePriv
&
operator
=
(
const
CacheAccess
&
)
=
delete
;
const
ResourcePriv
*
operator
&
(
)
const
;
ResourcePriv
*
operator
&
(
)
;
GrGpuResource
*
fResource
;
friend
class
GrGpuResource
;
}
;
inline
GrGpuResource
:
:
ResourcePriv
GrGpuResource
:
:
resourcePriv
(
)
{
return
ResourcePriv
(
this
)
;
}
inline
const
GrGpuResource
:
:
ResourcePriv
GrGpuResource
:
:
resourcePriv
(
)
const
{
return
ResourcePriv
(
const_cast
<
GrGpuResource
*
>
(
this
)
)
;
}
#
endif
