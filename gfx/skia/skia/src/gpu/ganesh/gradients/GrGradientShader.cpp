#
include
"
src
/
gpu
/
ganesh
/
gradients
/
GrGradientShader
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkColorSpacePriv
.
h
"
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorInfo
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorSpaceXform
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrMatrixEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrSkSLFP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gradients
/
GrGradientBitmapCache
.
h
"
using
Vec4
=
skvx
:
:
Vec
<
4
float
>
;
static
const
SkScalar
kLowPrecisionIntervalLimit
=
0
.
01f
;
static
const
int
kMaxNumCachedGradientBitmaps
=
32
;
static
const
int
kGradientTextureSize
=
256
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_textured_colorizer
(
const
SkPMColor4f
*
colors
const
SkScalar
*
positions
int
count
bool
premul
const
GrFPArgs
&
args
)
{
static
GrGradientBitmapCache
gCache
(
kMaxNumCachedGradientBitmaps
kGradientTextureSize
)
;
SkColorType
colorType
=
kRGBA_8888_SkColorType
;
if
(
GrColorTypeIsWiderThan
(
args
.
fDstColorInfo
-
>
colorType
(
)
8
)
)
{
auto
f16Format
=
args
.
fContext
-
>
priv
(
)
.
caps
(
)
-
>
getDefaultBackendFormat
(
GrColorType
:
:
kRGBA_F16
GrRenderable
:
:
kNo
)
;
if
(
f16Format
.
isValid
(
)
)
{
colorType
=
kRGBA_F16_SkColorType
;
}
}
SkAlphaType
alphaType
=
premul
?
kPremul_SkAlphaType
:
kUnpremul_SkAlphaType
;
SkBitmap
bitmap
;
gCache
.
getGradient
(
colors
positions
count
colorType
alphaType
&
bitmap
)
;
SkASSERT
(
1
=
=
bitmap
.
height
(
)
&
&
SkIsPow2
(
bitmap
.
width
(
)
)
)
;
SkASSERT
(
bitmap
.
isImmutable
(
)
)
;
auto
view
=
std
:
:
get
<
0
>
(
GrMakeCachedBitmapProxyView
(
args
.
fContext
bitmap
"
MakeTexturedColorizer
"
GrMipmapped
:
:
kNo
)
)
;
if
(
!
view
)
{
SkDebugf
(
"
Gradient
won
'
t
draw
.
Could
not
create
texture
.
"
)
;
return
nullptr
;
}
auto
m
=
SkMatrix
:
:
Scale
(
view
.
width
(
)
1
.
f
)
;
return
GrTextureEffect
:
:
Make
(
std
:
:
move
(
view
)
alphaType
m
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_single_interval_colorizer
(
const
SkPMColor4f
&
start
const
SkPMColor4f
&
end
)
{
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
half4
start
;
"
"
uniform
half4
end
;
"
"
half4
main
(
float2
coord
)
{
"
"
return
mix
(
start
end
half
(
coord
.
x
)
)
;
"
"
}
"
)
;
return
GrSkSLFP
:
:
Make
(
effect
"
SingleIntervalColorizer
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
start
"
start
"
end
"
end
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_dual_interval_colorizer
(
const
SkPMColor4f
&
c0
const
SkPMColor4f
&
c1
const
SkPMColor4f
&
c2
const
SkPMColor4f
&
c3
float
threshold
)
{
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
float4
scale
[
2
]
;
"
"
uniform
float4
bias
[
2
]
;
"
"
uniform
half
threshold
;
"
"
half4
main
(
float2
coord
)
{
"
"
half
t
=
half
(
coord
.
x
)
;
"
"
float4
s
b
;
"
"
if
(
t
<
threshold
)
{
"
"
s
=
scale
[
0
]
;
"
"
b
=
bias
[
0
]
;
"
"
}
else
{
"
"
s
=
scale
[
1
]
;
"
"
b
=
bias
[
1
]
;
"
"
}
"
"
return
half4
(
t
*
s
+
b
)
;
"
"
}
"
)
;
Vec4
vc0
=
Vec4
:
:
Load
(
c0
.
vec
(
)
)
;
Vec4
vc1
=
Vec4
:
:
Load
(
c1
.
vec
(
)
)
;
Vec4
vc2
=
Vec4
:
:
Load
(
c2
.
vec
(
)
)
;
Vec4
vc3
=
Vec4
:
:
Load
(
c3
.
vec
(
)
)
;
const
Vec4
scale
[
2
]
=
{
(
vc1
-
vc0
)
/
threshold
(
vc3
-
vc2
)
/
(
1
-
threshold
)
}
;
const
Vec4
bias
[
2
]
=
{
vc0
vc2
-
threshold
*
scale
[
1
]
}
;
return
GrSkSLFP
:
:
Make
(
effect
"
DualIntervalColorizer
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
scale
"
SkSpan
(
scale
)
"
bias
"
SkSpan
(
bias
)
"
threshold
"
threshold
)
;
}
static
constexpr
int
kMaxUnrolledColorCount
=
16
;
static
constexpr
int
kMaxUnrolledIntervalCount
=
kMaxUnrolledColorCount
/
2
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_unrolled_colorizer
(
int
intervalCount
const
SkPMColor4f
*
scale
const
SkPMColor4f
*
bias
SkRect
thresholds1_7
SkRect
thresholds9_13
)
{
SkASSERT
(
intervalCount
>
=
1
&
&
intervalCount
<
=
8
)
;
static
SkOnce
once
[
kMaxUnrolledIntervalCount
]
;
static
const
SkRuntimeEffect
*
effects
[
kMaxUnrolledIntervalCount
]
;
once
[
intervalCount
-
1
]
(
[
intervalCount
]
{
SkString
sksl
;
sksl
.
append
(
"
uniform
half4
thresholds1_7
thresholds9_13
;
"
)
;
sksl
.
appendf
(
"
uniform
float4
scale
[
%
d
]
;
"
intervalCount
)
;
sksl
.
appendf
(
"
uniform
float4
bias
[
%
d
]
;
"
intervalCount
)
;
sksl
.
appendf
(
"
half4
main
(
float2
coord
)
{
"
"
half
t
=
half
(
coord
.
x
)
;
"
"
float4
s
b
;
"
"
if
(
%
d
<
=
4
|
|
t
<
thresholds1_7
.
w
)
{
"
"
if
(
%
d
<
=
2
|
|
t
<
thresholds1_7
.
y
)
{
"
"
if
(
%
d
<
=
1
|
|
t
<
thresholds1_7
.
x
)
{
"
"
%
s
"
"
}
else
{
"
"
%
s
"
"
}
"
"
}
else
{
"
"
if
(
%
d
<
=
3
|
|
t
<
thresholds1_7
.
z
)
{
"
"
%
s
"
"
}
else
{
"
"
%
s
"
"
}
"
"
}
"
"
}
else
{
"
"
if
(
%
d
<
=
6
|
|
t
<
thresholds9_13
.
y
)
{
"
"
if
(
%
d
<
=
5
|
|
t
<
thresholds9_13
.
x
)
{
"
"
%
s
"
"
}
else
{
"
"
%
s
"
"
}
"
"
}
else
{
"
"
if
(
%
d
<
=
7
|
|
t
<
thresholds9_13
.
z
)
{
"
"
%
s
"
"
}
else
{
"
"
%
s
"
"
}
"
"
}
"
"
}
"
"
return
t
*
s
+
b
;
"
"
}
"
intervalCount
intervalCount
intervalCount
(
intervalCount
<
=
0
)
?
"
"
:
"
s
=
scale
[
0
]
;
b
=
bias
[
0
]
;
"
(
intervalCount
<
=
1
)
?
"
"
:
"
s
=
scale
[
1
]
;
b
=
bias
[
1
]
;
"
intervalCount
(
intervalCount
<
=
2
)
?
"
"
:
"
s
=
scale
[
2
]
;
b
=
bias
[
2
]
;
"
(
intervalCount
<
=
3
)
?
"
"
:
"
s
=
scale
[
3
]
;
b
=
bias
[
3
]
;
"
intervalCount
intervalCount
(
intervalCount
<
=
4
)
?
"
"
:
"
s
=
scale
[
4
]
;
b
=
bias
[
4
]
;
"
(
intervalCount
<
=
5
)
?
"
"
:
"
s
=
scale
[
5
]
;
b
=
bias
[
5
]
;
"
intervalCount
(
intervalCount
<
=
6
)
?
"
"
:
"
s
=
scale
[
6
]
;
b
=
bias
[
6
]
;
"
(
intervalCount
<
=
7
)
?
"
"
:
"
s
=
scale
[
7
]
;
b
=
bias
[
7
]
;
"
)
;
auto
result
=
SkRuntimeEffect
:
:
MakeForShader
(
std
:
:
move
(
sksl
)
)
;
SkASSERTF
(
result
.
effect
"
%
s
"
result
.
errorText
.
c_str
(
)
)
;
effects
[
intervalCount
-
1
]
=
result
.
effect
.
release
(
)
;
}
)
;
return
GrSkSLFP
:
:
Make
(
effects
[
intervalCount
-
1
]
"
UnrolledBinaryColorizer
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
thresholds1_7
"
thresholds1_7
"
thresholds9_13
"
thresholds9_13
"
scale
"
SkSpan
(
scale
intervalCount
)
"
bias
"
SkSpan
(
bias
intervalCount
)
)
;
}
static
constexpr
int
kMaxLoopingColorCount
=
128
;
static
constexpr
int
kMaxLoopingIntervalCount
=
kMaxLoopingColorCount
/
2
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_looping_colorizer
(
int
intervalCount
const
SkPMColor4f
*
scale
const
SkPMColor4f
*
bias
const
SkScalar
*
thresholds
)
{
SkASSERT
(
intervalCount
>
=
1
&
&
intervalCount
<
=
kMaxLoopingIntervalCount
)
;
SkASSERT
(
(
intervalCount
&
3
)
=
=
0
)
;
int
intervalChunks
=
intervalCount
/
4
;
int
cacheIndex
=
(
size_t
)
intervalChunks
-
1
;
struct
EffectCacheEntry
{
SkOnce
once
;
const
SkRuntimeEffect
*
effect
;
}
;
static
EffectCacheEntry
effectCache
[
kMaxLoopingIntervalCount
/
4
]
;
SkASSERT
(
cacheIndex
>
=
0
&
&
cacheIndex
<
(
int
)
std
:
:
size
(
effectCache
)
)
;
EffectCacheEntry
*
cacheEntry
=
&
effectCache
[
cacheIndex
]
;
cacheEntry
-
>
once
(
[
intervalCount
intervalChunks
cacheEntry
]
{
SkString
sksl
;
int
loopCount
=
SkNextLog2
(
intervalChunks
)
;
sksl
.
appendf
(
"
#
version
300
\
n
"
"
uniform
half4
thresholds
[
%
d
]
;
"
"
uniform
float4
scale
[
%
d
]
;
"
"
uniform
float4
bias
[
%
d
]
;
"
"
half4
main
(
float2
coord
)
{
"
"
half
t
=
half
(
coord
.
x
)
;
"
"
int
low
=
0
;
"
"
int
high
=
%
d
;
"
"
int
chunk
=
%
d
;
"
"
for
(
int
loop
=
0
;
loop
<
%
d
;
+
+
loop
)
{
"
"
if
(
t
<
thresholds
[
chunk
]
.
w
)
{
"
"
high
=
chunk
;
"
"
}
else
{
"
"
low
=
chunk
+
1
;
"
"
}
"
"
chunk
=
(
low
+
high
)
/
2
;
"
"
}
"
"
int
pos
;
"
"
if
(
t
<
thresholds
[
chunk
]
.
y
)
{
"
"
pos
=
(
t
<
thresholds
[
chunk
]
.
x
)
?
0
:
1
;
"
"
}
else
{
"
"
pos
=
(
t
<
thresholds
[
chunk
]
.
z
)
?
2
:
3
;
"
"
}
"
"
if
(
%
d
>
0
)
{
"
"
pos
+
=
4
*
chunk
;
"
"
}
"
"
return
t
*
scale
[
pos
]
+
bias
[
pos
]
;
"
"
}
"
intervalChunks
intervalCount
intervalCount
intervalChunks
-
1
(
intervalChunks
-
1
)
/
2
loopCount
loopCount
)
;
auto
result
=
SkRuntimeEffect
:
:
MakeForShader
(
std
:
:
move
(
sksl
)
)
;
SkASSERTF
(
result
.
effect
"
%
s
"
result
.
errorText
.
c_str
(
)
)
;
cacheEntry
-
>
effect
=
result
.
effect
.
release
(
)
;
}
)
;
return
GrSkSLFP
:
:
Make
(
cacheEntry
-
>
effect
"
LoopingBinaryColorizer
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kNone
"
thresholds
"
SkSpan
(
(
const
SkV4
*
)
thresholds
intervalChunks
)
"
scale
"
SkSpan
(
scale
intervalCount
)
"
bias
"
SkSpan
(
bias
intervalCount
)
)
;
}
int
build_intervals
(
int
inputLength
const
SkPMColor4f
*
inColors
const
SkScalar
*
inPositions
int
outputLength
SkPMColor4f
*
outScales
SkPMColor4f
*
outBiases
SkScalar
*
outThresholds
)
{
int
intervalCount
=
0
;
for
(
int
i
=
0
;
i
<
inputLength
-
1
;
i
+
+
)
{
if
(
intervalCount
>
=
outputLength
)
{
return
0
;
}
SkScalar
t0
=
inPositions
[
i
]
;
SkScalar
t1
=
inPositions
[
i
+
1
]
;
SkScalar
dt
=
t1
-
t0
;
if
(
SkScalarNearlyZero
(
dt
)
)
{
continue
;
}
Vec4
c0
=
Vec4
:
:
Load
(
inColors
[
i
]
.
vec
(
)
)
;
Vec4
c1
=
Vec4
:
:
Load
(
inColors
[
i
+
1
]
.
vec
(
)
)
;
Vec4
scale
=
(
c1
-
c0
)
/
dt
;
Vec4
bias
=
c0
-
t0
*
scale
;
scale
.
store
(
outScales
+
intervalCount
)
;
bias
.
store
(
outBiases
+
intervalCount
)
;
outThresholds
[
intervalCount
]
=
t1
;
intervalCount
+
+
;
}
return
intervalCount
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_unrolled_binary_colorizer
(
const
SkPMColor4f
*
colors
const
SkScalar
*
positions
int
count
)
{
if
(
count
>
kMaxUnrolledColorCount
)
{
return
nullptr
;
}
SkPMColor4f
scales
[
kMaxUnrolledIntervalCount
]
;
SkPMColor4f
biases
[
kMaxUnrolledIntervalCount
]
;
SkScalar
thresholds
[
kMaxUnrolledIntervalCount
]
=
{
}
;
int
intervalCount
=
build_intervals
(
count
colors
positions
kMaxUnrolledIntervalCount
scales
biases
thresholds
)
;
if
(
intervalCount
<
=
0
)
{
return
nullptr
;
}
SkRect
thresholds1_7
=
{
thresholds
[
0
]
thresholds
[
1
]
thresholds
[
2
]
thresholds
[
3
]
}
thresholds9_13
=
{
thresholds
[
4
]
thresholds
[
5
]
thresholds
[
6
]
0
.
0
}
;
return
make_unrolled_colorizer
(
intervalCount
scales
biases
thresholds1_7
thresholds9_13
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_looping_binary_colorizer
(
const
SkPMColor4f
*
colors
const
SkScalar
*
positions
int
count
)
{
if
(
count
>
kMaxLoopingColorCount
)
{
return
nullptr
;
}
SkPMColor4f
scales
[
kMaxLoopingIntervalCount
]
;
SkPMColor4f
biases
[
kMaxLoopingIntervalCount
]
;
SkScalar
thresholds
[
kMaxLoopingIntervalCount
]
=
{
}
;
int
intervalCount
=
build_intervals
(
count
colors
positions
kMaxLoopingIntervalCount
scales
biases
thresholds
)
;
if
(
intervalCount
<
=
0
)
{
return
nullptr
;
}
int
roundedSize
=
std
:
:
max
(
4
SkNextPow2
(
intervalCount
)
)
;
SkASSERT
(
roundedSize
<
=
kMaxLoopingIntervalCount
)
;
for
(
;
intervalCount
<
roundedSize
;
+
+
intervalCount
)
{
thresholds
[
intervalCount
]
=
thresholds
[
intervalCount
-
1
]
;
scales
[
intervalCount
]
=
scales
[
intervalCount
-
1
]
;
biases
[
intervalCount
]
=
biases
[
intervalCount
-
1
]
;
}
return
make_looping_colorizer
(
intervalCount
scales
biases
thresholds
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_colorizer
(
const
SkPMColor4f
*
colors
const
SkScalar
*
positions
int
count
bool
premul
const
GrFPArgs
&
args
)
{
bool
bottomHardStop
=
SkScalarNearlyEqual
(
positions
[
0
]
positions
[
1
]
)
;
bool
topHardStop
=
SkScalarNearlyEqual
(
positions
[
count
-
2
]
positions
[
count
-
1
]
)
;
if
(
bottomHardStop
)
{
colors
+
+
;
positions
+
+
;
count
-
-
;
}
if
(
topHardStop
)
{
count
-
-
;
}
if
(
count
=
=
2
)
{
return
make_single_interval_colorizer
(
colors
[
0
]
colors
[
1
]
)
;
}
const
GrShaderCaps
*
caps
=
args
.
fContext
-
>
priv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
;
auto
intervalsExceedPrecisionLimit
=
[
&
]
(
)
-
>
bool
{
if
(
!
caps
-
>
fFloatIs32Bits
)
{
for
(
int
i
=
0
;
i
<
count
-
1
;
i
+
+
)
{
SkScalar
dt
=
SkScalarAbs
(
positions
[
i
]
-
positions
[
i
+
1
]
)
;
if
(
dt
<
=
kLowPrecisionIntervalLimit
&
&
dt
>
SK_ScalarNearlyZero
)
{
return
true
;
}
}
}
return
false
;
}
;
auto
makeDualIntervalColorizer
=
[
&
]
(
)
-
>
std
:
:
unique_ptr
<
GrFragmentProcessor
>
{
if
(
count
=
=
3
)
{
return
make_dual_interval_colorizer
(
colors
[
0
]
colors
[
1
]
colors
[
1
]
colors
[
2
]
positions
[
1
]
)
;
}
if
(
count
=
=
4
&
&
SkScalarNearlyEqual
(
positions
[
1
]
positions
[
2
]
)
)
{
return
make_dual_interval_colorizer
(
colors
[
0
]
colors
[
1
]
colors
[
2
]
colors
[
3
]
positions
[
1
]
)
;
}
return
nullptr
;
}
;
int
binaryColorizerLimit
=
caps
-
>
fNonconstantArrayIndexSupport
?
kMaxLoopingColorCount
:
kMaxUnrolledColorCount
;
if
(
(
count
<
=
binaryColorizerLimit
)
&
&
!
intervalsExceedPrecisionLimit
(
)
)
{
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorizer
=
makeDualIntervalColorizer
(
)
;
if
(
colorizer
)
{
return
colorizer
;
}
colorizer
=
caps
-
>
fNonconstantArrayIndexSupport
?
make_looping_binary_colorizer
(
colors
positions
count
)
:
make_unrolled_binary_colorizer
(
colors
positions
count
)
;
if
(
colorizer
)
{
return
colorizer
;
}
}
return
make_textured_colorizer
(
colors
positions
count
premul
args
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_clamped_gradient
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorizer
std
:
:
unique_ptr
<
GrFragmentProcessor
>
gradLayout
SkPMColor4f
leftBorderColor
SkPMColor4f
rightBorderColor
bool
colorsAreOpaque
)
{
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
shader
colorizer
;
"
"
uniform
shader
gradLayout
;
"
"
uniform
half4
leftBorderColor
;
"
"
uniform
half4
rightBorderColor
;
"
"
uniform
int
layoutPreservesOpacity
;
"
"
half4
main
(
float2
coord
)
{
"
"
half4
t
=
gradLayout
.
eval
(
coord
)
;
"
"
half4
outColor
;
"
"
if
(
!
bool
(
layoutPreservesOpacity
)
&
&
t
.
y
<
0
)
{
"
"
outColor
=
half4
(
0
)
;
"
"
}
else
if
(
t
.
x
<
0
)
{
"
"
outColor
=
leftBorderColor
;
"
"
}
else
if
(
t
.
x
>
1
.
0
)
{
"
"
outColor
=
rightBorderColor
;
"
"
}
else
{
"
"
outColor
=
colorizer
.
eval
(
t
.
x0
)
;
"
"
}
"
"
return
outColor
;
"
"
}
"
)
;
bool
layoutPreservesOpacity
=
gradLayout
-
>
preservesOpaqueInput
(
)
;
GrSkSLFP
:
:
OptFlags
optFlags
=
GrSkSLFP
:
:
OptFlags
:
:
kCompatibleWithCoverageAsAlpha
;
if
(
colorsAreOpaque
&
&
layoutPreservesOpacity
)
{
optFlags
|
=
GrSkSLFP
:
:
OptFlags
:
:
kPreservesOpaqueInput
;
}
return
GrSkSLFP
:
:
Make
(
effect
"
ClampedGradient
"
nullptr
optFlags
"
colorizer
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
colorizer
)
)
"
gradLayout
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
gradLayout
)
)
"
leftBorderColor
"
leftBorderColor
"
rightBorderColor
"
rightBorderColor
"
layoutPreservesOpacity
"
GrSkSLFP
:
:
Specialize
<
int
>
(
layoutPreservesOpacity
)
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_tiled_gradient
(
const
GrFPArgs
&
args
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorizer
std
:
:
unique_ptr
<
GrFragmentProcessor
>
gradLayout
bool
mirror
bool
colorsAreOpaque
)
{
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
shader
colorizer
;
"
"
uniform
shader
gradLayout
;
"
"
uniform
int
mirror
;
"
"
uniform
int
layoutPreservesOpacity
;
"
"
uniform
int
useFloorAbsWorkaround
;
"
"
half4
main
(
float2
coord
)
{
"
"
half4
t
=
gradLayout
.
eval
(
coord
)
;
"
"
if
(
!
bool
(
layoutPreservesOpacity
)
&
&
t
.
y
<
0
)
{
"
"
return
half4
(
0
)
;
"
"
}
else
{
"
"
if
(
bool
(
mirror
)
)
{
"
"
half
t_1
=
t
.
x
-
1
;
"
"
half
tiled_t
=
t_1
-
2
*
floor
(
t_1
*
0
.
5
)
-
1
;
"
"
if
(
bool
(
useFloorAbsWorkaround
)
)
{
"
"
tiled_t
=
clamp
(
tiled_t
-
1
1
)
;
"
"
}
"
"
t
.
x
=
abs
(
tiled_t
)
;
"
"
}
else
{
"
"
t
.
x
=
fract
(
t
.
x
)
;
"
"
}
"
"
half4
outColor
=
colorizer
.
eval
(
t
.
x0
)
;
"
"
return
outColor
;
"
"
}
"
"
}
"
)
;
bool
layoutPreservesOpacity
=
gradLayout
-
>
preservesOpaqueInput
(
)
;
GrSkSLFP
:
:
OptFlags
optFlags
=
GrSkSLFP
:
:
OptFlags
:
:
kCompatibleWithCoverageAsAlpha
;
if
(
colorsAreOpaque
&
&
layoutPreservesOpacity
)
{
optFlags
|
=
GrSkSLFP
:
:
OptFlags
:
:
kPreservesOpaqueInput
;
}
const
bool
useFloorAbsWorkaround
=
args
.
fContext
-
>
priv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
-
>
fMustDoOpBetweenFloorAndAbs
;
return
GrSkSLFP
:
:
Make
(
effect
"
TiledGradient
"
nullptr
optFlags
"
colorizer
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
colorizer
)
)
"
gradLayout
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
gradLayout
)
)
"
mirror
"
GrSkSLFP
:
:
Specialize
<
int
>
(
mirror
)
"
layoutPreservesOpacity
"
GrSkSLFP
:
:
Specialize
<
int
>
(
layoutPreservesOpacity
)
"
useFloorAbsWorkaround
"
GrSkSLFP
:
:
Specialize
<
int
>
(
useFloorAbsWorkaround
)
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_interpolated_to_dst
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
gradient
const
SkGradientShader
:
:
Interpolation
&
interpolation
SkColorSpace
*
intermediateColorSpace
const
GrColorInfo
&
dstInfo
bool
allOpaque
)
{
using
ColorSpace
=
SkGradientShader
:
:
Interpolation
:
:
ColorSpace
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kDestination
)
=
=
0
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kSRGBLinear
)
=
=
1
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kLab
)
=
=
2
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kOKLab
)
=
=
3
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kLCH
)
=
=
4
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kOKLCH
)
=
=
5
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kSRGB
)
=
=
6
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kHSL
)
=
=
7
)
;
static_assert
(
static_cast
<
int
>
(
ColorSpace
:
:
kHWB
)
=
=
8
)
;
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForColorFilter
"
uniform
int
colorSpace
;
"
"
uniform
int
do_unpremul
;
"
"
half4
main
(
half4
color
)
{
"
"
return
interpolated_to_rgb_unpremul
(
color
colorSpace
do_unpremul
)
;
"
"
}
"
)
;
bool
inputPremul
=
static_cast
<
bool
>
(
interpolation
.
fInPremul
)
;
switch
(
interpolation
.
fColorSpace
)
{
case
ColorSpace
:
:
kLab
:
case
ColorSpace
:
:
kOKLab
:
case
ColorSpace
:
:
kLCH
:
case
ColorSpace
:
:
kOKLCH
:
case
ColorSpace
:
:
kHSL
:
case
ColorSpace
:
:
kHWB
:
gradient
=
GrSkSLFP
:
:
Make
(
effect
"
GradientCS
"
std
:
:
move
(
gradient
)
GrSkSLFP
:
:
OptFlags
:
:
kAll
"
colorSpace
"
GrSkSLFP
:
:
Specialize
<
int
>
(
static_cast
<
int
>
(
interpolation
.
fColorSpace
)
)
"
do_unpremul
"
GrSkSLFP
:
:
Specialize
<
int
>
(
inputPremul
&
&
!
allOpaque
)
)
;
inputPremul
=
false
;
break
;
default
:
break
;
}
SkColorSpace
*
dstColorSpace
=
dstInfo
.
colorSpace
(
)
?
dstInfo
.
colorSpace
(
)
:
sk_srgb_singleton
(
)
;
SkAlphaType
intermediateAlphaType
=
inputPremul
?
kPremul_SkAlphaType
:
kUnpremul_SkAlphaType
;
SkAlphaType
dstAlphaType
=
kPremul_SkAlphaType
;
if
(
allOpaque
)
{
intermediateAlphaType
=
dstAlphaType
=
kUnpremul_SkAlphaType
;
}
return
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
gradient
)
intermediateColorSpace
intermediateAlphaType
dstColorSpace
dstAlphaType
)
;
}
namespace
GrGradientShader
{
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeGradientFP
(
const
SkGradientShaderBase
&
shader
const
GrFPArgs
&
args
const
SkShaderBase
:
:
MatrixRec
&
mRec
std
:
:
unique_ptr
<
GrFragmentProcessor
>
layout
const
SkMatrix
*
overrideMatrix
)
{
if
(
layout
=
=
nullptr
)
{
return
nullptr
;
}
if
(
!
overrideMatrix
)
{
overrideMatrix
=
&
shader
.
getGradientMatrix
(
)
;
}
bool
success
;
std
:
:
tie
(
success
layout
)
=
mRec
.
apply
(
std
:
:
move
(
layout
)
*
overrideMatrix
)
;
if
(
!
success
)
{
return
nullptr
;
}
bool
inputPremul
=
shader
.
interpolateInPremul
(
)
;
bool
allOpaque
=
true
;
SkColor4fXformer
xformedColors
(
&
shader
args
.
fDstColorInfo
-
>
colorSpace
(
)
)
;
const
SkPMColor4f
*
colors
=
xformedColors
.
fColors
.
begin
(
)
;
for
(
int
i
=
0
;
i
<
shader
.
fColorCount
;
i
+
+
)
{
if
(
allOpaque
&
&
!
SkScalarNearlyEqual
(
colors
[
i
]
.
fA
1
.
0
)
)
{
allOpaque
=
false
;
}
}
SkTArray
<
SkScalar
true
>
implicitPos
;
SkScalar
*
positions
;
if
(
shader
.
fPositions
)
{
positions
=
shader
.
fPositions
;
}
else
{
implicitPos
.
reserve_back
(
shader
.
fColorCount
)
;
SkScalar
posScale
=
SK_Scalar1
/
(
shader
.
fColorCount
-
1
)
;
for
(
int
i
=
0
;
i
<
shader
.
fColorCount
;
i
+
+
)
{
implicitPos
.
push_back
(
SkIntToScalar
(
i
)
*
posScale
)
;
}
positions
=
implicitPos
.
begin
(
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorizer
=
make_colorizer
(
colors
positions
shader
.
fColorCount
inputPremul
args
)
;
if
(
colorizer
=
=
nullptr
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
gradient
;
switch
(
shader
.
getTileMode
(
)
)
{
case
SkTileMode
:
:
kRepeat
:
gradient
=
make_tiled_gradient
(
args
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
false
allOpaque
)
;
break
;
case
SkTileMode
:
:
kMirror
:
gradient
=
make_tiled_gradient
(
args
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
true
allOpaque
)
;
break
;
case
SkTileMode
:
:
kClamp
:
gradient
=
make_clamped_gradient
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
colors
[
0
]
colors
[
shader
.
fColorCount
-
1
]
allOpaque
)
;
break
;
case
SkTileMode
:
:
kDecal
:
gradient
=
make_clamped_gradient
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
SK_PMColor4fTRANSPARENT
SK_PMColor4fTRANSPARENT
false
)
;
break
;
}
return
make_interpolated_to_dst
(
std
:
:
move
(
gradient
)
shader
.
fInterpolation
xformedColors
.
fIntermediateColorSpace
.
get
(
)
*
args
.
fDstColorInfo
allOpaque
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeLinear
(
const
SkLinearGradient
&
shader
const
GrFPArgs
&
args
const
SkShaderBase
:
:
MatrixRec
&
mRec
)
{
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
half4
main
(
float2
coord
)
{
"
"
return
half4
(
half
(
coord
.
x
)
+
0
.
00001
1
0
0
)
;
"
"
}
"
)
;
auto
fp
=
GrSkSLFP
:
:
Make
(
effect
"
LinearLayout
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kPreservesOpaqueInput
)
;
return
MakeGradientFP
(
shader
args
mRec
std
:
:
move
(
fp
)
)
;
}
#
if
GR_TEST_UTILS
RandomParams
:
:
RandomParams
(
SkRandom
*
random
)
{
fColorCount
=
random
-
>
nextRangeU
(
2
kMaxRandomGradientColors
)
;
fUseColors4f
=
random
-
>
nextBool
(
)
;
if
(
fColorCount
=
=
1
|
|
(
fColorCount
>
=
2
&
&
random
-
>
nextBool
(
)
)
)
{
fStops
=
nullptr
;
}
else
{
fStops
=
fStopStorage
;
}
if
(
fUseColors4f
)
{
fColorSpace
=
GrTest
:
:
TestColorSpace
(
random
)
;
}
SkScalar
stop
=
0
.
f
;
for
(
int
i
=
0
;
i
<
fColorCount
;
+
+
i
)
{
if
(
fUseColors4f
)
{
fColors4f
[
i
]
.
fR
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fG
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fB
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fA
=
random
-
>
nextUScalar1
(
)
;
}
else
{
fColors
[
i
]
=
random
-
>
nextU
(
)
;
}
if
(
fStops
)
{
fStops
[
i
]
=
stop
;
stop
=
i
<
fColorCount
-
1
?
stop
+
random
-
>
nextUScalar1
(
)
*
(
1
.
f
-
stop
)
:
1
.
f
;
}
}
fTileMode
=
static_cast
<
SkTileMode
>
(
random
-
>
nextULessThan
(
kSkTileModeCount
)
)
;
}
#
endif
}
