#
ifndef
GrCaps_DEFINED
#
define
GrCaps_DEFINED
#
include
"
include
/
core
/
SkCapabilities
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrDriverBugWorkarounds
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
Blend
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
vector
>
class
GrBackendFormat
;
class
GrBackendRenderTarget
;
class
GrProgramDesc
;
class
GrProgramInfo
;
class
GrRenderTarget
;
class
GrRenderTargetProxy
;
class
GrSurface
;
class
SkJSONWriter
;
struct
GrContextOptions
;
struct
SkIRect
;
struct
SkISize
;
enum
class
SkTextureCompressionType
;
namespace
skgpu
{
class
KeyBuilder
;
}
namespace
GrTest
{
struct
TestFormatColorTypeCombination
;
}
class
GrCaps
:
public
SkCapabilities
{
public
:
GrCaps
(
const
GrContextOptions
&
)
;
void
dumpJSON
(
SkJSONWriter
*
)
const
;
const
GrShaderCaps
*
shaderCaps
(
)
const
{
return
fShaderCaps
.
get
(
)
;
}
bool
npotTextureTileSupport
(
)
const
{
return
fNPOTTextureTileSupport
;
}
bool
mipmapSupport
(
)
const
{
return
fMipmapSupport
;
}
bool
anisoSupport
(
)
const
{
return
fAnisoSupport
;
}
bool
gpuTracingSupport
(
)
const
{
return
fGpuTracingSupport
;
}
bool
oversizedStencilSupport
(
)
const
{
return
fOversizedStencilSupport
;
}
bool
textureBarrierSupport
(
)
const
{
return
fTextureBarrierSupport
;
}
bool
sampleLocationsSupport
(
)
const
{
return
fSampleLocationsSupport
;
}
bool
drawInstancedSupport
(
)
const
{
return
fDrawInstancedSupport
;
}
bool
nativeDrawIndirectSupport
(
)
const
{
return
fNativeDrawIndirectSupport
;
}
bool
useClientSideIndirectBuffers
(
)
const
{
#
ifdef
SK_DEBUG
if
(
!
fNativeDrawIndirectSupport
|
|
fNativeDrawIndexedIndirectIsBroken
)
{
SkASSERT
(
fUseClientSideIndirectBuffers
)
;
}
#
endif
return
fUseClientSideIndirectBuffers
;
}
bool
conservativeRasterSupport
(
)
const
{
return
fConservativeRasterSupport
;
}
bool
wireframeSupport
(
)
const
{
return
fWireframeSupport
;
}
bool
msaaResolvesAutomatically
(
)
const
{
return
fMSAAResolvesAutomatically
;
}
bool
preferDiscardableMSAAAttachment
(
)
const
{
return
fPreferDiscardableMSAAAttachment
;
}
bool
halfFloatVertexAttributeSupport
(
)
const
{
return
fHalfFloatVertexAttributeSupport
;
}
bool
usePrimitiveRestart
(
)
const
{
return
fUsePrimitiveRestart
;
}
bool
preferClientSideDynamicBuffers
(
)
const
{
return
fPreferClientSideDynamicBuffers
;
}
bool
preferFullscreenClears
(
)
const
{
return
fPreferFullscreenClears
;
}
bool
discardStencilValuesAfterRenderPass
(
)
const
{
return
false
;
#
if
0
return
this
-
>
preferFullscreenClears
(
)
;
#
endif
}
bool
twoSidedStencilRefsAndMasksMustMatch
(
)
const
{
return
fTwoSidedStencilRefsAndMasksMustMatch
;
}
bool
preferVRAMUseOverFlushes
(
)
const
{
return
fPreferVRAMUseOverFlushes
;
}
bool
avoidStencilBuffers
(
)
const
{
return
fAvoidStencilBuffers
;
}
bool
avoidWritePixelsFastPath
(
)
const
{
return
fAvoidWritePixelsFastPath
;
}
bool
nativeDrawIndexedIndirectIsBroken
(
)
const
{
return
fNativeDrawIndexedIndirectIsBroken
;
}
enum
BlendEquationSupport
{
kBasic_BlendEquationSupport
kAdvanced_BlendEquationSupport
kAdvancedCoherent_BlendEquationSupport
kLast_BlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
}
;
BlendEquationSupport
blendEquationSupport
(
)
const
{
return
fBlendEquationSupport
;
}
bool
advancedBlendEquationSupport
(
)
const
{
return
fBlendEquationSupport
>
=
kAdvanced_BlendEquationSupport
;
}
bool
advancedCoherentBlendEquationSupport
(
)
const
{
return
kAdvancedCoherent_BlendEquationSupport
=
=
fBlendEquationSupport
;
}
bool
isAdvancedBlendEquationDisabled
(
skgpu
:
:
BlendEquation
equation
)
const
{
SkASSERT
(
skgpu
:
:
BlendEquationIsAdvanced
(
equation
)
)
;
SkASSERT
(
this
-
>
advancedBlendEquationSupport
(
)
)
;
return
SkToBool
(
fAdvBlendEqDisableFlags
&
(
1
<
<
static_cast
<
int
>
(
equation
)
)
)
;
}
bool
shouldCollapseSrcOverToSrcWhenAble
(
)
const
{
return
fShouldCollapseSrcOverToSrcWhenAble
;
}
bool
mustSyncGpuDuringAbandon
(
)
const
{
return
fMustSyncGpuDuringAbandon
;
}
bool
reducedShaderMode
(
)
const
{
return
this
-
>
shaderCaps
(
)
-
>
fReducedShaderMode
;
}
enum
MapFlags
{
kNone_MapFlags
=
0x0
kCanMap_MapFlag
=
0x1
kSubset_MapFlag
=
0x2
kAsyncRead_MapFlag
=
0x4
}
;
uint32_t
mapBufferFlags
(
)
const
{
return
fMapBufferFlags
;
}
bool
reuseScratchTextures
(
)
const
{
return
fReuseScratchTextures
;
}
bool
reuseScratchBuffers
(
)
const
{
return
fReuseScratchBuffers
;
}
int
maxVertexAttributes
(
)
const
{
return
fMaxVertexAttributes
;
}
int
maxRenderTargetSize
(
)
const
{
return
fMaxRenderTargetSize
;
}
int
maxPreferredRenderTargetSize
(
)
const
{
return
fMaxPreferredRenderTargetSize
;
}
int
maxTextureSize
(
)
const
{
return
fMaxTextureSize
;
}
int
maxWindowRectangles
(
)
const
{
return
fMaxWindowRectangles
;
}
bool
isWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
rt
)
const
{
return
this
-
>
maxWindowRectangles
(
)
>
0
&
&
this
-
>
onIsWindowRectanglesSupportedForRT
(
rt
)
;
}
uint32_t
maxPushConstantsSize
(
)
const
{
return
fMaxPushConstantsSize
;
}
size_t
transferBufferRowBytesAlignment
(
)
const
{
return
fTransferBufferRowBytesAlignment
;
}
size_t
transferFromBufferToBufferAlignment
(
)
const
{
return
fTransferFromBufferToBufferAlignment
;
}
size_t
bufferUpdateDataPreserveAlignment
(
)
const
{
return
fBufferUpdateDataPreserveAlignment
;
}
virtual
bool
isFormatSRGB
(
const
GrBackendFormat
&
)
const
=
0
;
bool
isFormatCompressed
(
const
GrBackendFormat
&
format
)
const
;
virtual
bool
isFormatTexturable
(
const
GrBackendFormat
&
GrTextureType
)
const
=
0
;
virtual
bool
isFormatCopyable
(
const
GrBackendFormat
&
)
const
=
0
;
virtual
int
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
)
const
=
0
;
int
internalMultisampleCount
(
const
GrBackendFormat
&
format
)
const
{
return
std
:
:
min
(
fInternalMultisampleCount
this
-
>
maxRenderTargetSampleCount
(
format
)
)
;
}
virtual
bool
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
=
1
)
const
=
0
;
virtual
bool
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
=
0
;
virtual
int
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
)
const
=
0
;
bool
surfaceSupportsWritePixels
(
const
GrSurface
*
)
const
;
enum
class
SurfaceReadPixelsSupport
{
kSupported
kCopyToTexture2D
kUnsupported
}
;
virtual
SurfaceReadPixelsSupport
surfaceSupportsReadPixels
(
const
GrSurface
*
)
const
=
0
;
struct
SupportedWrite
{
GrColorType
fColorType
;
size_t
fOffsetAlignmentForTransferBuffer
;
}
;
virtual
SupportedWrite
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
=
0
;
struct
SupportedRead
{
GrColorType
fColorType
;
size_t
fOffsetAlignmentForTransferBuffer
;
}
;
SupportedRead
supportedReadPixelsColorType
(
GrColorType
srcColorType
const
GrBackendFormat
&
srcFormat
GrColorType
dstColorType
)
const
;
bool
writePixelsRowBytesSupport
(
)
const
{
return
fWritePixelsRowBytesSupport
;
}
bool
transferPixelsToRowBytesSupport
(
)
const
{
return
fTransferPixelsToRowBytesSupport
;
}
bool
readPixelsRowBytesSupport
(
)
const
{
return
fReadPixelsRowBytesSupport
;
}
bool
transferFromSurfaceToBufferSupport
(
)
const
{
return
fTransferFromSurfaceToBufferSupport
;
}
bool
transferFromBufferToTextureSupport
(
)
const
{
return
fTransferFromBufferToTextureSupport
;
}
bool
transferFromBufferToBufferSupport
(
)
const
{
return
fTransferFromBufferToBufferSupport
;
}
bool
suppressPrints
(
)
const
{
return
fSuppressPrints
;
}
size_t
bufferMapThreshold
(
)
const
{
SkASSERT
(
fBufferMapThreshold
>
=
0
)
;
return
static_cast
<
size_t
>
(
fBufferMapThreshold
)
;
}
bool
mustClearUploadedBufferData
(
)
const
{
return
fMustClearUploadedBufferData
;
}
bool
shouldInitializeTextures
(
)
const
{
return
fShouldInitializeTextures
;
}
bool
buffersAreInitiallyZero
(
)
const
{
return
fBuffersAreInitiallyZero
;
}
bool
supportsAHardwareBufferImages
(
)
const
{
return
fSupportsAHardwareBufferImages
;
}
bool
wireframeMode
(
)
const
{
return
fWireframeMode
;
}
bool
fenceSyncSupport
(
)
const
{
return
fFenceSyncSupport
;
}
bool
semaphoreSupport
(
)
const
{
return
fSemaphoreSupport
;
}
bool
crossContextTextureSupport
(
)
const
{
return
fCrossContextTextureSupport
;
}
bool
canCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
;
bool
dynamicStateArrayGeometryProcessorTextureSupport
(
)
const
{
return
fDynamicStateArrayGeometryProcessorTextureSupport
;
}
bool
performPartialClearsAsDraws
(
)
const
{
return
fPerformColorClearsAsDraws
|
|
fPerformPartialClearsAsDraws
;
}
bool
performColorClearsAsDraws
(
)
const
{
return
fPerformColorClearsAsDraws
;
}
bool
avoidLargeIndexBufferDraws
(
)
const
{
return
fAvoidLargeIndexBufferDraws
;
}
bool
performStencilClearsAsDraws
(
)
const
{
return
fPerformStencilClearsAsDraws
;
}
bool
disableTessellationPathRenderer
(
)
const
{
return
fDisableTessellationPathRenderer
;
}
GrDstSampleFlags
getDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
bool
drawUsesMSAA
)
const
;
struct
DstCopyRestrictions
{
GrSurfaceProxy
:
:
RectsMustMatch
fRectsMustMatch
=
GrSurfaceProxy
:
:
RectsMustMatch
:
:
kNo
;
bool
fMustCopyWholeSrc
=
false
;
}
;
virtual
DstCopyRestrictions
getDstCopyRestrictions
(
const
GrRenderTargetProxy
*
src
GrColorType
ct
)
const
{
return
{
}
;
}
bool
validateSurfaceParams
(
const
SkISize
&
const
GrBackendFormat
&
GrRenderable
renderable
int
renderTargetSampleCnt
GrMipmapped
GrTextureType
)
const
;
bool
areColorTypeAndFormatCompatible
(
GrColorType
grCT
const
GrBackendFormat
&
format
)
const
;
GrBackendFormat
getDefaultBackendFormat
(
GrColorType
GrRenderable
)
const
;
virtual
GrBackendFormat
getBackendFormatFromCompressionType
(
SkTextureCompressionType
)
const
=
0
;
bool
clampToBorderSupport
(
)
const
{
return
fClampToBorderSupport
;
}
skgpu
:
:
Swizzle
getReadSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
;
virtual
skgpu
:
:
Swizzle
getWriteSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
=
0
;
virtual
uint64_t
computeFormatKey
(
const
GrBackendFormat
&
)
const
=
0
;
const
GrDriverBugWorkarounds
&
workarounds
(
)
const
{
return
fDriverBugWorkarounds
;
}
virtual
void
addExtraSamplerKey
(
skgpu
:
:
KeyBuilder
*
GrSamplerState
const
GrBackendFormat
&
)
const
{
}
enum
class
ProgramDescOverrideFlags
{
kNone
=
0
kVulkanHasResolveLoadSubpass
=
0x1
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
ProgramDescOverrideFlags
)
;
virtual
GrProgramDesc
makeDesc
(
GrRenderTarget
*
const
GrProgramInfo
&
ProgramDescOverrideFlags
overrideFlags
=
ProgramDescOverrideFlags
:
:
kNone
)
const
=
0
;
virtual
GrInternalSurfaceFlags
getExtraSurfaceFlagsForDeferredRT
(
)
const
{
return
GrInternalSurfaceFlags
:
:
kNone
;
}
bool
supportsDynamicMSAA
(
const
GrRenderTargetProxy
*
)
const
;
virtual
bool
dmsaaResolveCanBeUsedAsTextureInSameRenderPass
(
)
const
{
return
true
;
}
bool
avoidReorderingRenderTasks
(
)
const
{
return
fAvoidReorderingRenderTasks
;
}
bool
avoidDithering
(
)
const
{
return
fAvoidDithering
;
}
bool
disablePerspectiveSDFText
(
)
const
{
return
fDisablePerspectiveSDFText
;
}
std
:
:
tuple
<
GrColorType
GrBackendFormat
>
getFallbackColorTypeAndFormat
(
GrColorType
int
sampleCount
)
const
;
#
if
GR_TEST_UTILS
virtual
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
getTestingCombinations
(
)
const
=
0
;
#
endif
protected
:
void
finishInitialization
(
const
GrContextOptions
&
options
)
;
virtual
bool
onSupportsDynamicMSAA
(
const
GrRenderTargetProxy
*
)
const
{
return
false
;
}
std
:
:
unique_ptr
<
GrShaderCaps
>
fShaderCaps
;
bool
fNPOTTextureTileSupport
:
1
;
bool
fMipmapSupport
:
1
;
bool
fAnisoSupport
:
1
;
bool
fReuseScratchTextures
:
1
;
bool
fReuseScratchBuffers
:
1
;
bool
fGpuTracingSupport
:
1
;
bool
fOversizedStencilSupport
:
1
;
bool
fTextureBarrierSupport
:
1
;
bool
fSampleLocationsSupport
:
1
;
bool
fDrawInstancedSupport
:
1
;
bool
fNativeDrawIndirectSupport
:
1
;
bool
fUseClientSideIndirectBuffers
:
1
;
bool
fConservativeRasterSupport
:
1
;
bool
fWireframeSupport
:
1
;
bool
fMSAAResolvesAutomatically
:
1
;
bool
fPreferDiscardableMSAAAttachment
:
1
;
bool
fUsePrimitiveRestart
:
1
;
bool
fPreferClientSideDynamicBuffers
:
1
;
bool
fPreferFullscreenClears
:
1
;
bool
fTwoSidedStencilRefsAndMasksMustMatch
:
1
;
bool
fMustClearUploadedBufferData
:
1
;
bool
fBuffersAreInitiallyZero
:
1
;
bool
fShouldInitializeTextures
:
1
;
bool
fSupportsAHardwareBufferImages
:
1
;
bool
fHalfFloatVertexAttributeSupport
:
1
;
bool
fClampToBorderSupport
:
1
;
bool
fPerformPartialClearsAsDraws
:
1
;
bool
fPerformColorClearsAsDraws
:
1
;
bool
fAvoidLargeIndexBufferDraws
:
1
;
bool
fPerformStencilClearsAsDraws
:
1
;
bool
fTransferFromBufferToTextureSupport
:
1
;
bool
fTransferFromSurfaceToBufferSupport
:
1
;
bool
fTransferFromBufferToBufferSupport
:
1
;
bool
fWritePixelsRowBytesSupport
:
1
;
bool
fTransferPixelsToRowBytesSupport
:
1
;
bool
fReadPixelsRowBytesSupport
:
1
;
bool
fShouldCollapseSrcOverToSrcWhenAble
:
1
;
bool
fMustSyncGpuDuringAbandon
:
1
;
bool
fDisableTessellationPathRenderer
:
1
;
bool
fAvoidStencilBuffers
:
1
;
bool
fAvoidWritePixelsFastPath
:
1
;
bool
fNativeDrawIndexedIndirectIsBroken
:
1
;
bool
fAvoidReorderingRenderTasks
:
1
;
bool
fAvoidDithering
:
1
;
bool
fDisablePerspectiveSDFText
:
1
;
bool
fPreferVRAMUseOverFlushes
:
1
;
bool
fFenceSyncSupport
:
1
;
bool
fSemaphoreSupport
:
1
;
bool
fCrossContextTextureSupport
:
1
;
bool
fDynamicStateArrayGeometryProcessorTextureSupport
:
1
;
BlendEquationSupport
fBlendEquationSupport
;
uint32_t
fAdvBlendEqDisableFlags
;
static_assert
(
static_cast
<
int
>
(
skgpu
:
:
BlendEquation
:
:
kLast
)
<
32
)
;
uint32_t
fMapBufferFlags
;
int
fBufferMapThreshold
;
int
fMaxRenderTargetSize
;
int
fMaxPreferredRenderTargetSize
;
int
fMaxVertexAttributes
;
int
fMaxTextureSize
;
int
fMaxWindowRectangles
;
int
fInternalMultisampleCount
;
uint32_t
fMaxPushConstantsSize
=
0
;
size_t
fTransferBufferRowBytesAlignment
=
1
;
size_t
fTransferFromBufferToBufferAlignment
=
1
;
size_t
fBufferUpdateDataPreserveAlignment
=
1
;
GrDriverBugWorkarounds
fDriverBugWorkarounds
;
private
:
void
applyOptionsOverrides
(
const
GrContextOptions
&
options
)
;
virtual
void
onApplyOptionsOverrides
(
const
GrContextOptions
&
)
{
}
virtual
void
onDumpJSON
(
SkJSONWriter
*
)
const
{
}
virtual
bool
onSurfaceSupportsWritePixels
(
const
GrSurface
*
)
const
=
0
;
virtual
bool
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
=
0
;
virtual
GrBackendFormat
onGetDefaultBackendFormat
(
GrColorType
)
const
=
0
;
virtual
bool
onIsWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
)
const
{
return
true
;
}
virtual
bool
onAreColorTypeAndFormatCompatible
(
GrColorType
const
GrBackendFormat
&
)
const
=
0
;
virtual
SupportedRead
onSupportedReadPixelsColorType
(
GrColorType
srcColorType
const
GrBackendFormat
&
srcFormat
GrColorType
dstColorType
)
const
=
0
;
virtual
skgpu
:
:
Swizzle
onGetReadSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
=
0
;
virtual
GrDstSampleFlags
onGetDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
)
const
{
return
GrDstSampleFlags
:
:
kNone
;
}
bool
fSuppressPrints
:
1
;
bool
fWireframeMode
:
1
;
using
INHERITED
=
SkRefCnt
;
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrCaps
:
:
ProgramDescOverrideFlags
)
#
endif
