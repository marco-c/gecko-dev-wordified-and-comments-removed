#
ifndef
GrGpuBuffer_DEFINED
#
define
GrGpuBuffer_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
class
GrGpu
;
class
GrGpuBuffer
:
public
GrGpuResource
public
GrBuffer
{
public
:
static
void
ComputeScratchKeyForDynamicBuffer
(
size_t
size
GrGpuBufferType
skgpu
:
:
ScratchKey
*
)
;
GrAccessPattern
accessPattern
(
)
const
{
return
fAccessPattern
;
}
size_t
size
(
)
const
final
{
return
fSizeInBytes
;
}
void
ref
(
)
const
final
{
GrGpuResource
:
:
ref
(
)
;
}
void
unref
(
)
const
final
{
GrGpuResource
:
:
unref
(
)
;
}
void
*
map
(
)
;
void
unmap
(
)
;
bool
isMapped
(
)
const
;
bool
isCpuBuffer
(
)
const
final
{
return
false
;
}
bool
clearToZero
(
)
;
bool
updateData
(
const
void
*
src
size_t
offset
size_t
size
bool
preserve
)
;
GrGpuBufferType
intendedType
(
)
const
{
return
fIntendedType
;
}
protected
:
GrGpuBuffer
(
GrGpu
*
size_t
sizeInBytes
GrGpuBufferType
GrAccessPattern
std
:
:
string_view
label
)
;
enum
class
MapType
{
kRead
kWriteDiscard
}
;
void
*
fMapPtr
;
private
:
MapType
mapType
(
)
const
{
return
this
-
>
intendedType
(
)
=
=
GrGpuBufferType
:
:
kXferGpuToCpu
?
MapType
:
:
kRead
:
MapType
:
:
kWriteDiscard
;
}
virtual
void
onMap
(
MapType
)
=
0
;
virtual
void
onUnmap
(
MapType
)
=
0
;
virtual
bool
onClearToZero
(
)
=
0
;
virtual
bool
onUpdateData
(
const
void
*
src
size_t
offset
size_t
size
bool
preserve
)
=
0
;
size_t
onGpuMemorySize
(
)
const
override
{
return
fSizeInBytes
;
}
void
onSetLabel
(
)
override
{
}
const
char
*
getResourceType
(
)
const
override
{
return
"
Buffer
Object
"
;
}
void
computeScratchKey
(
skgpu
:
:
ScratchKey
*
key
)
const
override
;
size_t
fSizeInBytes
;
GrAccessPattern
fAccessPattern
;
GrGpuBufferType
fIntendedType
;
}
;
#
endif
