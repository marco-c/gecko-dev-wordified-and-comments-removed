#
ifndef
GrGLSLVarying_DEFINED
#
define
GrGLSLVarying_DEFINED
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderVar
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrGeometryProcessor
;
class
GrGLSLProgramBuilder
;
#
ifdef
SK_DEBUG
static
bool
is_matrix
(
SkSLType
type
)
{
switch
(
type
)
{
case
SkSLType
:
:
kFloat2x2
:
case
SkSLType
:
:
kFloat3x3
:
case
SkSLType
:
:
kFloat4x4
:
case
SkSLType
:
:
kHalf2x2
:
case
SkSLType
:
:
kHalf3x3
:
case
SkSLType
:
:
kHalf4x4
:
return
true
;
default
:
return
false
;
}
}
#
endif
class
GrGLSLVarying
{
public
:
enum
class
Scope
{
kVertToFrag
kVertToGeo
kGeoToFrag
}
;
GrGLSLVarying
(
)
=
default
;
GrGLSLVarying
(
SkSLType
type
Scope
scope
=
Scope
:
:
kVertToFrag
)
:
fType
(
type
)
fScope
(
scope
)
{
SkASSERT
(
!
is_matrix
(
type
)
)
;
}
void
reset
(
SkSLType
type
Scope
scope
=
Scope
:
:
kVertToFrag
)
{
SkASSERT
(
!
is_matrix
(
type
)
)
;
*
this
=
GrGLSLVarying
(
)
;
fType
=
type
;
fScope
=
scope
;
}
SkSLType
type
(
)
const
{
return
fType
;
}
Scope
scope
(
)
const
{
return
fScope
;
}
bool
isInVertexShader
(
)
const
{
return
Scope
:
:
kGeoToFrag
!
=
fScope
;
}
bool
isInFragmentShader
(
)
const
{
return
Scope
:
:
kVertToGeo
!
=
fScope
;
}
const
char
*
vsOut
(
)
const
{
SkASSERT
(
this
-
>
isInVertexShader
(
)
)
;
return
fVsOut
;
}
const
char
*
fsIn
(
)
const
{
SkASSERT
(
this
-
>
isInFragmentShader
(
)
)
;
return
fFsIn
;
}
GrShaderVar
vsOutVar
(
)
const
{
SkASSERT
(
this
-
>
isInVertexShader
(
)
)
;
return
GrShaderVar
(
this
-
>
vsOut
(
)
fType
GrShaderVar
:
:
TypeModifier
:
:
Out
)
;
}
GrShaderVar
fsInVar
(
)
const
{
SkASSERT
(
this
-
>
isInFragmentShader
(
)
)
;
return
GrShaderVar
(
this
-
>
fsIn
(
)
fType
GrShaderVar
:
:
TypeModifier
:
:
In
)
;
}
private
:
SkSLType
fType
=
SkSLType
:
:
kVoid
;
Scope
fScope
=
Scope
:
:
kVertToFrag
;
const
char
*
fVsOut
=
nullptr
;
const
char
*
fFsIn
=
nullptr
;
friend
class
GrGLSLVaryingHandler
;
}
;
static
const
int
kVaryingsPerBlock
=
8
;
class
GrGLSLVaryingHandler
{
public
:
explicit
GrGLSLVaryingHandler
(
GrGLSLProgramBuilder
*
program
)
:
fVaryings
(
kVaryingsPerBlock
)
fVertexInputs
(
kVaryingsPerBlock
)
fVertexOutputs
(
kVaryingsPerBlock
)
fFragInputs
(
kVaryingsPerBlock
)
fFragOutputs
(
kVaryingsPerBlock
)
fProgramBuilder
(
program
)
fDefaultInterpolationModifier
(
nullptr
)
{
}
virtual
~
GrGLSLVaryingHandler
(
)
{
}
void
setNoPerspective
(
)
;
enum
class
Interpolation
{
kInterpolated
kCanBeFlat
kMustBeFlat
}
;
void
addVarying
(
const
char
*
name
GrGLSLVarying
*
varying
Interpolation
=
Interpolation
:
:
kInterpolated
)
;
void
addPassThroughAttribute
(
const
GrShaderVar
&
vsVar
const
char
*
output
Interpolation
=
Interpolation
:
:
kInterpolated
)
;
void
emitAttributes
(
const
GrGeometryProcessor
&
)
;
void
finalize
(
)
;
void
getVertexDecls
(
SkString
*
inputDecls
SkString
*
outputDecls
)
const
;
void
getFragDecls
(
SkString
*
inputDecls
SkString
*
outputDecls
)
const
;
protected
:
struct
VaryingInfo
{
SkSLType
fType
;
bool
fIsFlat
;
SkString
fVsOut
;
GrShaderFlags
fVisibility
;
}
;
typedef
SkTBlockList
<
VaryingInfo
>
VaryingList
;
typedef
SkTBlockList
<
GrShaderVar
>
VarArray
;
VaryingList
fVaryings
;
VarArray
fVertexInputs
;
VarArray
fVertexOutputs
;
VarArray
fFragInputs
;
VarArray
fFragOutputs
;
GrGLSLProgramBuilder
*
fProgramBuilder
;
private
:
void
addAttribute
(
const
GrShaderVar
&
var
)
;
virtual
void
onFinalize
(
)
=
0
;
void
appendDecls
(
const
VarArray
&
vars
SkString
*
out
)
const
;
const
char
*
fDefaultInterpolationModifier
;
friend
class
GrGLSLProgramBuilder
;
}
;
#
endif
