#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorFilter
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPixelRef
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
core
/
SkBlendModePriv
.
h
"
#
include
"
src
/
core
/
SkBlenderBase
.
h
"
#
include
"
src
/
core
/
SkColorFilterBase
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
gpu
/
DitherUtils
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorInfo
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorSpaceXform
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFPArgs
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrPaint
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrSkSLFP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
shaders
/
SkShaderBase
.
h
"
#
include
<
optional
>
#
include
<
utility
>
class
SkBlender
;
class
SkColorSpace
;
enum
SkColorType
:
int
;
void
GrMakeKeyFromImageID
(
skgpu
:
:
UniqueKey
*
key
uint32_t
imageID
const
SkIRect
&
imageBounds
)
{
SkASSERT
(
key
)
;
SkASSERT
(
imageID
)
;
SkASSERT
(
!
imageBounds
.
isEmpty
(
)
)
;
static
const
skgpu
:
:
UniqueKey
:
:
Domain
kImageIDDomain
=
skgpu
:
:
UniqueKey
:
:
GenerateDomain
(
)
;
skgpu
:
:
UniqueKey
:
:
Builder
builder
(
key
kImageIDDomain
5
"
Image
"
)
;
builder
[
0
]
=
imageID
;
builder
[
1
]
=
imageBounds
.
fLeft
;
builder
[
2
]
=
imageBounds
.
fTop
;
builder
[
3
]
=
imageBounds
.
fRight
;
builder
[
4
]
=
imageBounds
.
fBottom
;
}
sk_sp
<
SkIDChangeListener
>
GrMakeUniqueKeyInvalidationListener
(
skgpu
:
:
UniqueKey
*
key
uint32_t
contextID
)
{
class
Listener
:
public
SkIDChangeListener
{
public
:
Listener
(
const
skgpu
:
:
UniqueKey
&
key
uint32_t
contextUniqueID
)
:
fMsg
(
key
contextUniqueID
)
{
}
void
changed
(
)
override
{
SkMessageBus
<
skgpu
:
:
UniqueKeyInvalidatedMessage
uint32_t
>
:
:
Post
(
fMsg
)
;
}
private
:
skgpu
:
:
UniqueKeyInvalidatedMessage
fMsg
;
}
;
auto
listener
=
sk_make_sp
<
Listener
>
(
*
key
contextID
)
;
auto
invalidateListener
=
[
]
(
const
void
*
ptr
void
*
)
{
auto
listener
=
reinterpret_cast
<
const
sk_sp
<
Listener
>
*
>
(
ptr
)
;
(
*
listener
)
-
>
markShouldDeregister
(
)
;
delete
listener
;
}
;
auto
data
=
SkData
:
:
MakeWithProc
(
new
sk_sp
<
Listener
>
(
listener
)
sizeof
(
sk_sp
<
Listener
>
)
invalidateListener
nullptr
)
;
SkASSERT
(
!
key
-
>
getCustomData
(
)
)
;
key
-
>
setCustomData
(
std
:
:
move
(
data
)
)
;
return
std
:
:
move
(
listener
)
;
}
sk_sp
<
GrSurfaceProxy
>
GrCopyBaseMipMapToTextureProxy
(
GrRecordingContext
*
ctx
sk_sp
<
GrSurfaceProxy
>
baseProxy
GrSurfaceOrigin
origin
std
:
:
string_view
label
skgpu
:
:
Budgeted
budgeted
)
{
SkASSERT
(
baseProxy
)
;
if
(
baseProxy
-
>
isPromiseProxy
(
)
)
{
return
nullptr
;
}
if
(
!
ctx
-
>
priv
(
)
.
caps
(
)
-
>
isFormatCopyable
(
baseProxy
-
>
backendFormat
(
)
)
)
{
return
nullptr
;
}
auto
copy
=
GrSurfaceProxy
:
:
Copy
(
ctx
std
:
:
move
(
baseProxy
)
origin
GrMipmapped
:
:
kYes
SkBackingFit
:
:
kExact
budgeted
label
)
;
if
(
!
copy
)
{
return
nullptr
;
}
SkASSERT
(
copy
-
>
asTextureProxy
(
)
)
;
return
copy
;
}
GrSurfaceProxyView
GrCopyBaseMipMapToView
(
GrRecordingContext
*
context
GrSurfaceProxyView
src
skgpu
:
:
Budgeted
budgeted
)
{
auto
origin
=
src
.
origin
(
)
;
auto
swizzle
=
src
.
swizzle
(
)
;
auto
proxy
=
src
.
refProxy
(
)
;
return
{
GrCopyBaseMipMapToTextureProxy
(
context
proxy
origin
"
CopyBaseMipMapToView
"
budgeted
)
origin
swizzle
}
;
}
static
GrMipmapped
adjust_mipmapped
(
GrMipmapped
mipmapped
const
SkBitmap
&
bitmap
const
GrCaps
*
caps
)
{
if
(
!
caps
-
>
mipmapSupport
(
)
|
|
bitmap
.
dimensions
(
)
.
area
(
)
<
=
1
)
{
return
GrMipmapped
:
:
kNo
;
}
return
mipmapped
;
}
static
GrColorType
choose_bmp_texture_colortype
(
const
GrCaps
*
caps
const
SkBitmap
&
bitmap
)
{
GrColorType
ct
=
SkColorTypeToGrColorType
(
bitmap
.
info
(
)
.
colorType
(
)
)
;
if
(
caps
-
>
getDefaultBackendFormat
(
ct
GrRenderable
:
:
kNo
)
.
isValid
(
)
)
{
return
ct
;
}
return
GrColorType
:
:
kRGBA_8888
;
}
static
sk_sp
<
GrTextureProxy
>
make_bmp_proxy
(
GrProxyProvider
*
proxyProvider
const
SkBitmap
&
bitmap
GrColorType
ct
GrMipmapped
mipmapped
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
)
{
SkBitmap
bmpToUpload
;
if
(
ct
!
=
SkColorTypeToGrColorType
(
bitmap
.
info
(
)
.
colorType
(
)
)
)
{
SkColorType
skCT
=
GrColorTypeToSkColorType
(
ct
)
;
if
(
!
bmpToUpload
.
tryAllocPixels
(
bitmap
.
info
(
)
.
makeColorType
(
skCT
)
)
|
|
!
bitmap
.
readPixels
(
bmpToUpload
.
pixmap
(
)
)
)
{
return
{
}
;
}
bmpToUpload
.
setImmutable
(
)
;
}
else
{
bmpToUpload
=
bitmap
;
}
auto
proxy
=
proxyProvider
-
>
createProxyFromBitmap
(
bmpToUpload
mipmapped
fit
budgeted
)
;
SkASSERT
(
!
proxy
|
|
mipmapped
=
=
GrMipmapped
:
:
kNo
|
|
proxy
-
>
mipmapped
(
)
=
=
GrMipmapped
:
:
kYes
)
;
return
proxy
;
}
std
:
:
tuple
<
GrSurfaceProxyView
GrColorType
>
GrMakeCachedBitmapProxyView
(
GrRecordingContext
*
rContext
const
SkBitmap
&
bitmap
std
:
:
string_view
label
GrMipmapped
mipmapped
)
{
if
(
!
bitmap
.
peekPixels
(
nullptr
)
)
{
return
{
}
;
}
GrProxyProvider
*
proxyProvider
=
rContext
-
>
priv
(
)
.
proxyProvider
(
)
;
const
GrCaps
*
caps
=
rContext
-
>
priv
(
)
.
caps
(
)
;
skgpu
:
:
UniqueKey
key
;
SkIPoint
origin
=
bitmap
.
pixelRefOrigin
(
)
;
SkIRect
subset
=
SkIRect
:
:
MakePtSize
(
origin
bitmap
.
dimensions
(
)
)
;
GrMakeKeyFromImageID
(
&
key
bitmap
.
pixelRef
(
)
-
>
getGenerationID
(
)
subset
)
;
mipmapped
=
adjust_mipmapped
(
mipmapped
bitmap
caps
)
;
GrColorType
ct
=
choose_bmp_texture_colortype
(
caps
bitmap
)
;
auto
installKey
=
[
&
]
(
GrTextureProxy
*
proxy
)
{
auto
listener
=
GrMakeUniqueKeyInvalidationListener
(
&
key
proxyProvider
-
>
contextID
(
)
)
;
bitmap
.
pixelRef
(
)
-
>
addGenIDChangeListener
(
std
:
:
move
(
listener
)
)
;
proxyProvider
-
>
assignUniqueKeyToProxy
(
key
proxy
)
;
}
;
sk_sp
<
GrTextureProxy
>
proxy
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
key
)
;
if
(
!
proxy
)
{
proxy
=
make_bmp_proxy
(
proxyProvider
bitmap
ct
mipmapped
SkBackingFit
:
:
kExact
skgpu
:
:
Budgeted
:
:
kYes
)
;
if
(
!
proxy
)
{
return
{
}
;
}
SkASSERT
(
mipmapped
=
=
GrMipmapped
:
:
kNo
|
|
proxy
-
>
mipmapped
(
)
=
=
GrMipmapped
:
:
kYes
)
;
installKey
(
proxy
.
get
(
)
)
;
}
skgpu
:
:
Swizzle
swizzle
=
caps
-
>
getReadSwizzle
(
proxy
-
>
backendFormat
(
)
ct
)
;
if
(
mipmapped
=
=
GrMipmapped
:
:
kNo
|
|
proxy
-
>
mipmapped
(
)
=
=
GrMipmapped
:
:
kYes
)
{
return
{
{
std
:
:
move
(
proxy
)
kTopLeft_GrSurfaceOrigin
swizzle
}
ct
}
;
}
auto
mippedProxy
=
GrCopyBaseMipMapToTextureProxy
(
rContext
proxy
kTopLeft_GrSurfaceOrigin
"
MakeCachedBitmapProxyView
"
)
;
if
(
!
mippedProxy
)
{
return
{
{
std
:
:
move
(
proxy
)
kTopLeft_GrSurfaceOrigin
swizzle
}
ct
}
;
}
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
=
=
key
)
;
proxyProvider
-
>
removeUniqueKeyFromProxy
(
proxy
.
get
(
)
)
;
installKey
(
mippedProxy
-
>
asTextureProxy
(
)
)
;
return
{
{
std
:
:
move
(
mippedProxy
)
kTopLeft_GrSurfaceOrigin
swizzle
}
ct
}
;
}
std
:
:
tuple
<
GrSurfaceProxyView
GrColorType
>
GrMakeUncachedBitmapProxyView
(
GrRecordingContext
*
rContext
const
SkBitmap
&
bitmap
GrMipmapped
mipmapped
SkBackingFit
fit
skgpu
:
:
Budgeted
budgeted
)
{
GrProxyProvider
*
proxyProvider
=
rContext
-
>
priv
(
)
.
proxyProvider
(
)
;
const
GrCaps
*
caps
=
rContext
-
>
priv
(
)
.
caps
(
)
;
mipmapped
=
adjust_mipmapped
(
mipmapped
bitmap
caps
)
;
GrColorType
ct
=
choose_bmp_texture_colortype
(
caps
bitmap
)
;
if
(
auto
proxy
=
make_bmp_proxy
(
proxyProvider
bitmap
ct
mipmapped
fit
budgeted
)
)
{
skgpu
:
:
Swizzle
swizzle
=
caps
-
>
getReadSwizzle
(
proxy
-
>
backendFormat
(
)
ct
)
;
SkASSERT
(
mipmapped
=
=
GrMipmapped
:
:
kNo
|
|
proxy
-
>
mipmapped
(
)
=
=
GrMipmapped
:
:
kYes
)
;
return
{
{
std
:
:
move
(
proxy
)
kTopLeft_GrSurfaceOrigin
swizzle
}
ct
}
;
}
return
{
}
;
}
SkPMColor4f
SkColorToPMColor4f
(
SkColor
c
const
GrColorInfo
&
colorInfo
)
{
SkColor4f
color
=
SkColor4f
:
:
FromColor
(
c
)
;
if
(
auto
*
xform
=
colorInfo
.
colorSpaceXformFromSRGB
(
)
)
{
color
=
xform
-
>
apply
(
color
)
;
}
return
color
.
premul
(
)
;
}
SkColor4f
SkColor4fPrepForDst
(
SkColor4f
color
const
GrColorInfo
&
colorInfo
)
{
if
(
auto
*
xform
=
colorInfo
.
colorSpaceXformFromSRGB
(
)
)
{
color
=
xform
-
>
apply
(
color
)
;
}
return
color
;
}
static
inline
bool
blender_requires_shader
(
const
SkBlender
*
blender
)
{
SkASSERT
(
blender
)
;
std
:
:
optional
<
SkBlendMode
>
mode
=
as_BB
(
blender
)
-
>
asBlendMode
(
)
;
return
!
mode
.
has_value
(
)
|
|
*
mode
!
=
SkBlendMode
:
:
kDst
;
}
#
ifndef
SK_IGNORE_GPU_DITHER
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_dither_effect
(
GrRecordingContext
*
rContext
std
:
:
unique_ptr
<
GrFragmentProcessor
>
inputFP
float
range
const
GrCaps
*
caps
)
{
if
(
range
=
=
0
|
|
inputFP
=
=
nullptr
)
{
return
inputFP
;
}
if
(
caps
-
>
avoidDithering
(
)
)
{
return
inputFP
;
}
static
const
SkBitmap
gLUT
=
skgpu
:
:
MakeDitherLUT
(
)
;
auto
[
tex
ct
]
=
GrMakeCachedBitmapProxyView
(
rContext
gLUT
"
MakeDitherEffect
"
GrMipmapped
:
:
kNo
)
;
if
(
!
tex
)
{
return
inputFP
;
}
SkASSERT
(
ct
=
=
GrColorType
:
:
kAlpha_8
)
;
GrSamplerState
sampler
(
GrSamplerState
:
:
WrapMode
:
:
kRepeat
SkFilterMode
:
:
kNearest
)
;
auto
te
=
GrTextureEffect
:
:
Make
(
std
:
:
move
(
tex
)
kPremul_SkAlphaType
SkMatrix
:
:
I
(
)
sampler
*
caps
)
;
static
const
SkRuntimeEffect
*
effect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
"
uniform
half
range
;
"
"
uniform
shader
inputFP
;
"
"
uniform
shader
table
;
"
"
half4
main
(
float2
xy
)
{
"
"
half4
color
=
inputFP
.
eval
(
xy
)
;
"
"
half
value
=
table
.
eval
(
sk_FragCoord
.
xy
)
.
a
-
0
.
5
;
"
"
return
half4
(
clamp
(
color
.
rgb
+
value
*
range
0
.
0
color
.
a
)
color
.
a
)
;
"
"
}
"
)
;
return
GrSkSLFP
:
:
Make
(
effect
"
Dither
"
nullptr
GrSkSLFP
:
:
OptFlags
:
:
kPreservesOpaqueInput
"
range
"
range
"
inputFP
"
std
:
:
move
(
inputFP
)
"
table
"
GrSkSLFP
:
:
IgnoreOptFlags
(
std
:
:
move
(
te
)
)
)
;
}
#
endif
static
inline
bool
skpaint_to_grpaint_impl
(
GrRecordingContext
*
context
const
GrColorInfo
&
dstColorInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
ctm
std
:
:
optional
<
std
:
:
unique_ptr
<
GrFragmentProcessor
>
>
shaderFP
SkBlender
*
primColorBlender
const
SkSurfaceProps
&
surfaceProps
GrPaint
*
grPaint
)
{
SkColor4f
origColor
=
SkColor4fPrepForDst
(
skPaint
.
getColor4f
(
)
dstColorInfo
)
;
GrFPArgs
fpArgs
(
context
&
dstColorInfo
surfaceProps
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
paintFP
;
const
bool
gpProvidesShader
=
shaderFP
.
has_value
(
)
&
&
!
*
shaderFP
;
if
(
!
primColorBlender
|
|
blender_requires_shader
(
primColorBlender
)
)
{
if
(
shaderFP
.
has_value
(
)
)
{
paintFP
=
std
:
:
move
(
*
shaderFP
)
;
}
else
{
if
(
const
SkShaderBase
*
shader
=
as_SB
(
skPaint
.
getShader
(
)
)
)
{
paintFP
=
shader
-
>
asFragmentProcessor
(
fpArgs
SkShaderBase
:
:
MatrixRec
(
ctm
)
)
;
if
(
paintFP
=
=
nullptr
)
{
return
false
;
}
}
}
}
bool
applyColorFilterToPaintColor
=
false
;
if
(
paintFP
)
{
if
(
primColorBlender
)
{
SkPMColor4f
shaderInput
=
origColor
.
makeOpaque
(
)
.
premul
(
)
;
paintFP
=
GrFragmentProcessor
:
:
OverrideInput
(
std
:
:
move
(
paintFP
)
shaderInput
)
;
paintFP
=
as_BB
(
primColorBlender
)
-
>
asFragmentProcessor
(
std
:
:
move
(
paintFP
)
nullptr
fpArgs
)
;
if
(
!
paintFP
)
{
return
false
;
}
float
paintAlpha
=
skPaint
.
getColor4f
(
)
.
fA
;
if
(
1
.
0f
!
=
paintAlpha
)
{
paintFP
=
GrFragmentProcessor
:
:
ModulateRGBA
(
std
:
:
move
(
paintFP
)
{
paintAlpha
paintAlpha
paintAlpha
paintAlpha
}
)
;
}
}
else
{
float
paintAlpha
=
skPaint
.
getColor4f
(
)
.
fA
;
if
(
paintAlpha
!
=
1
.
0f
)
{
paintFP
=
GrFragmentProcessor
:
:
ApplyPaintAlpha
(
std
:
:
move
(
paintFP
)
)
;
grPaint
-
>
setColor4f
(
{
origColor
.
fR
origColor
.
fG
origColor
.
fB
origColor
.
fA
}
)
;
}
else
{
paintFP
=
GrFragmentProcessor
:
:
DisableCoverageAsAlpha
(
std
:
:
move
(
paintFP
)
)
;
grPaint
-
>
setColor4f
(
origColor
.
premul
(
)
)
;
}
}
}
else
{
if
(
primColorBlender
)
{
grPaint
-
>
setColor4f
(
SK_PMColor4fWHITE
)
;
if
(
blender_requires_shader
(
primColorBlender
)
)
{
paintFP
=
GrFragmentProcessor
:
:
MakeColor
(
origColor
.
makeOpaque
(
)
.
premul
(
)
)
;
paintFP
=
as_BB
(
primColorBlender
)
-
>
asFragmentProcessor
(
std
:
:
move
(
paintFP
)
nullptr
fpArgs
)
;
if
(
!
paintFP
)
{
return
false
;
}
}
float
paintAlpha
=
skPaint
.
getColor4f
(
)
.
fA
;
if
(
paintAlpha
!
=
1
.
0f
)
{
paintFP
=
GrFragmentProcessor
:
:
ModulateRGBA
(
std
:
:
move
(
paintFP
)
{
paintAlpha
paintAlpha
paintAlpha
paintAlpha
}
)
;
}
}
else
{
grPaint
-
>
setColor4f
(
origColor
.
premul
(
)
)
;
applyColorFilterToPaintColor
=
!
gpProvidesShader
;
}
}
SkColorFilter
*
colorFilter
=
skPaint
.
getColorFilter
(
)
;
if
(
colorFilter
)
{
if
(
applyColorFilterToPaintColor
)
{
SkColorSpace
*
dstCS
=
dstColorInfo
.
colorSpace
(
)
;
grPaint
-
>
setColor4f
(
colorFilter
-
>
filterColor4f
(
origColor
dstCS
dstCS
)
.
premul
(
)
)
;
}
else
{
auto
[
success
fp
]
=
as_CFB
(
colorFilter
)
-
>
asFragmentProcessor
(
std
:
:
move
(
paintFP
)
context
dstColorInfo
surfaceProps
)
;
if
(
!
success
)
{
return
false
;
}
paintFP
=
std
:
:
move
(
fp
)
;
}
}
SkMaskFilterBase
*
maskFilter
=
as_MFB
(
skPaint
.
getMaskFilter
(
)
)
;
if
(
maskFilter
)
{
if
(
auto
mfFP
=
maskFilter
-
>
asFragmentProcessor
(
fpArgs
ctm
)
)
{
grPaint
-
>
setCoverageFragmentProcessor
(
std
:
:
move
(
mfFP
)
)
;
}
}
#
ifndef
SK_IGNORE_GPU_DITHER
SkColorType
ct
=
GrColorTypeToSkColorType
(
dstColorInfo
.
colorType
(
)
)
;
if
(
SkPaintPriv
:
:
ShouldDither
(
skPaint
ct
)
&
&
paintFP
!
=
nullptr
)
{
float
ditherRange
=
skgpu
:
:
DitherRangeForConfig
(
ct
)
;
paintFP
=
make_dither_effect
(
context
std
:
:
move
(
paintFP
)
ditherRange
context
-
>
priv
(
)
.
caps
(
)
)
;
}
#
endif
if
(
auto
bm
=
skPaint
.
asBlendMode
(
)
)
{
SkASSERT
(
!
grPaint
-
>
getXPFactory
(
)
)
;
if
(
bm
.
value
(
)
!
=
SkBlendMode
:
:
kSrcOver
)
{
grPaint
-
>
setXPFactory
(
SkBlendMode_AsXPFactory
(
bm
.
value
(
)
)
)
;
}
}
else
{
paintFP
=
as_BB
(
skPaint
.
getBlender
(
)
)
-
>
asFragmentProcessor
(
std
:
:
move
(
paintFP
)
GrFragmentProcessor
:
:
SurfaceColor
(
)
fpArgs
)
;
if
(
!
paintFP
)
{
return
false
;
}
grPaint
-
>
setXPFactory
(
SkBlendMode_AsXPFactory
(
SkBlendMode
:
:
kSrc
)
)
;
}
if
(
GrColorTypeClampType
(
dstColorInfo
.
colorType
(
)
)
=
=
GrClampType
:
:
kManual
)
{
if
(
paintFP
!
=
nullptr
)
{
paintFP
=
GrFragmentProcessor
:
:
ClampOutput
(
std
:
:
move
(
paintFP
)
)
;
}
else
{
auto
color
=
grPaint
-
>
getColor4f
(
)
;
grPaint
-
>
setColor4f
(
{
SkTPin
(
color
.
fR
0
.
f
1
.
f
)
SkTPin
(
color
.
fG
0
.
f
1
.
f
)
SkTPin
(
color
.
fB
0
.
f
1
.
f
)
SkTPin
(
color
.
fA
0
.
f
1
.
f
)
}
)
;
}
}
if
(
paintFP
)
{
grPaint
-
>
setColorFragmentProcessor
(
std
:
:
move
(
paintFP
)
)
;
}
return
true
;
}
bool
SkPaintToGrPaint
(
GrRecordingContext
*
context
const
GrColorInfo
&
dstColorInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
ctm
const
SkSurfaceProps
&
surfaceProps
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
dstColorInfo
skPaint
ctm
std
:
:
nullopt
nullptr
surfaceProps
grPaint
)
;
}
bool
SkPaintToGrPaintReplaceShader
(
GrRecordingContext
*
context
const
GrColorInfo
&
dstColorInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
ctm
std
:
:
unique_ptr
<
GrFragmentProcessor
>
shaderFP
const
SkSurfaceProps
&
surfaceProps
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
dstColorInfo
skPaint
ctm
std
:
:
move
(
shaderFP
)
nullptr
surfaceProps
grPaint
)
;
}
bool
SkPaintToGrPaintWithBlend
(
GrRecordingContext
*
context
const
GrColorInfo
&
dstColorInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
ctm
SkBlender
*
primColorBlender
const
SkSurfaceProps
&
surfaceProps
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
dstColorInfo
skPaint
ctm
std
:
:
nullopt
primColorBlender
surfaceProps
grPaint
)
;
}
