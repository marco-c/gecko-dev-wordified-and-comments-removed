#
ifndef
ClipStack_DEFINED
#
define
ClipStack_DEFINED
#
include
"
include
/
core
/
SkClipOp
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrShape
.
h
"
class
GrAppliedClip
;
class
GrProxyProvider
;
class
GrRecordingContext
;
namespace
skgpu
{
namespace
ganesh
{
class
SurfaceDrawContext
;
}
}
class
GrSWMaskHelper
;
class
SkMatrixProvider
;
namespace
skgpu
:
:
ganesh
{
class
ClipStack
final
:
public
GrClip
{
public
:
enum
class
ClipState
:
uint8_t
{
kEmpty
kWideOpen
kDeviceRect
kDeviceRRect
kComplex
}
;
struct
Element
{
GrShape
fShape
;
SkMatrix
fLocalToDevice
;
SkClipOp
fOp
;
GrAA
fAA
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fShape
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fLocalToDevice
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fOp
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fAA
)
>
:
:
value
)
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
}
;
ClipStack
(
const
SkIRect
&
deviceBounds
const
SkMatrixProvider
*
matrixProvider
bool
forceAA
)
;
~
ClipStack
(
)
override
;
ClipStack
(
const
ClipStack
&
)
=
delete
;
ClipStack
&
operator
=
(
const
ClipStack
&
)
=
delete
;
ClipState
clipState
(
)
const
{
return
this
-
>
currentSaveRecord
(
)
.
state
(
)
;
}
class
ElementIter
;
inline
ElementIter
begin
(
)
const
;
inline
ElementIter
end
(
)
const
;
void
save
(
)
;
void
restore
(
)
;
void
clipRect
(
const
SkMatrix
&
ctm
const
SkRect
&
rect
GrAA
aa
SkClipOp
op
)
{
this
-
>
clip
(
{
ctm
GrShape
(
rect
)
aa
op
}
)
;
}
void
clipRRect
(
const
SkMatrix
&
ctm
const
SkRRect
&
rrect
GrAA
aa
SkClipOp
op
)
{
this
-
>
clip
(
{
ctm
GrShape
(
rrect
)
aa
op
}
)
;
}
void
clipPath
(
const
SkMatrix
&
ctm
const
SkPath
&
path
GrAA
aa
SkClipOp
op
)
{
this
-
>
clip
(
{
ctm
GrShape
(
path
)
aa
op
}
)
;
}
void
clipShader
(
sk_sp
<
SkShader
>
shader
)
;
void
replaceClip
(
const
SkIRect
&
rect
)
;
GrClip
:
:
Effect
apply
(
GrRecordingContext
*
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
GrDrawOp
*
GrAAType
GrAppliedClip
*
SkRect
*
bounds
)
const
override
;
GrClip
:
:
PreClipResult
preApply
(
const
SkRect
&
drawBounds
GrAA
aa
)
const
override
;
SkIRect
getConservativeBounds
(
)
const
override
;
#
if
GR_TEST_UTILS
UniqueKey
testingOnly_getLastSWMaskKey
(
)
const
{
return
fMasks
.
empty
(
)
?
UniqueKey
(
)
:
fMasks
.
back
(
)
.
key
(
)
;
}
#
endif
private
:
class
SaveRecord
;
class
Mask
;
class
Draw
;
class
RawElement
:
private
Element
{
public
:
using
Stack
=
SkTBlockList
<
RawElement
1
>
;
RawElement
(
const
SkMatrix
&
localToDevice
const
GrShape
&
shape
GrAA
aa
SkClipOp
op
)
;
SkClipOp
op
(
)
const
{
return
fOp
;
}
const
SkIRect
&
outerBounds
(
)
const
{
return
fOuterBounds
;
}
bool
contains
(
const
SaveRecord
&
s
)
const
;
bool
contains
(
const
Draw
&
d
)
const
;
bool
contains
(
const
RawElement
&
e
)
const
;
const
Element
&
asElement
(
)
const
{
return
*
this
;
}
const
GrShape
&
shape
(
)
const
{
return
fShape
;
}
const
SkMatrix
&
localToDevice
(
)
const
{
return
fLocalToDevice
;
}
const
SkIRect
&
innerBounds
(
)
const
{
return
fInnerBounds
;
}
GrAA
aa
(
)
const
{
return
fAA
;
}
ClipState
clipType
(
)
const
;
bool
isInvalid
(
)
const
{
return
fInvalidatedByIndex
>
=
0
;
}
void
markInvalid
(
const
SaveRecord
&
current
)
;
void
restoreValid
(
const
SaveRecord
&
current
)
;
void
updateForElement
(
RawElement
*
added
const
SaveRecord
&
current
)
;
void
simplify
(
const
SkIRect
&
deviceBounds
bool
forceAA
)
;
private
:
bool
combine
(
const
RawElement
&
other
const
SaveRecord
&
current
)
;
SkMatrix
fDeviceToLocal
;
SkIRect
fInnerBounds
;
SkIRect
fOuterBounds
;
int
fInvalidatedByIndex
;
}
;
class
Mask
{
public
:
using
Stack
=
SkTBlockList
<
Mask
1
>
;
Mask
(
const
SaveRecord
&
current
const
SkIRect
&
bounds
)
;
~
Mask
(
)
{
SkASSERT
(
!
fKey
.
isValid
(
)
)
;
}
const
UniqueKey
&
key
(
)
const
{
return
fKey
;
}
const
SkIRect
&
bounds
(
)
const
{
return
fBounds
;
}
uint32_t
genID
(
)
const
{
return
fGenID
;
}
bool
appliesToDraw
(
const
SaveRecord
&
current
const
SkIRect
&
drawBounds
)
const
;
void
invalidate
(
GrProxyProvider
*
proxyProvider
)
;
SkDEBUGCODE
(
const
SaveRecord
*
owner
(
)
const
{
return
fOwner
;
}
)
private
:
UniqueKey
fKey
;
SkIRect
fBounds
;
uint32_t
fGenID
;
SkDEBUGCODE
(
const
SaveRecord
*
fOwner
;
)
}
;
class
SaveRecord
{
public
:
using
Stack
=
SkTBlockList
<
SaveRecord
2
>
;
explicit
SaveRecord
(
const
SkIRect
&
deviceBounds
)
;
SaveRecord
(
const
SaveRecord
&
prior
int
startingMaskIndex
int
startingElementIndex
)
;
SkClipOp
op
(
)
const
{
return
fStackOp
;
}
const
SkIRect
&
outerBounds
(
)
const
{
return
fOuterBounds
;
}
bool
contains
(
const
Draw
&
d
)
const
;
bool
contains
(
const
RawElement
&
e
)
const
;
const
SkShader
*
shader
(
)
const
{
return
fShader
.
get
(
)
;
}
const
SkIRect
&
innerBounds
(
)
const
{
return
fInnerBounds
;
}
int
firstActiveElementIndex
(
)
const
{
return
fStartingElementIndex
;
}
int
oldestElementIndex
(
)
const
{
return
fOldestValidIndex
;
}
bool
canBeUpdated
(
)
const
{
return
(
fDeferredSaveCount
=
=
0
)
;
}
ClipState
state
(
)
const
;
uint32_t
genID
(
)
const
;
void
pushSave
(
)
{
SkASSERT
(
fDeferredSaveCount
>
=
0
)
;
fDeferredSaveCount
+
+
;
}
bool
popSave
(
)
{
fDeferredSaveCount
-
-
;
SkASSERT
(
fDeferredSaveCount
>
=
-
1
)
;
return
fDeferredSaveCount
>
=
0
;
}
bool
addElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
)
;
void
addShader
(
sk_sp
<
SkShader
>
shader
)
;
void
reset
(
const
SkIRect
&
bounds
)
;
void
removeElements
(
RawElement
:
:
Stack
*
elements
)
;
void
restoreElements
(
RawElement
:
:
Stack
*
elements
)
;
void
invalidateMasks
(
GrProxyProvider
*
proxyProvider
Mask
:
:
Stack
*
masks
)
;
private
:
bool
appendElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
)
;
void
replaceWithElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
)
;
SkIRect
fInnerBounds
;
SkIRect
fOuterBounds
;
sk_sp
<
SkShader
>
fShader
;
const
int
fStartingMaskIndex
;
const
int
fStartingElementIndex
;
int
fOldestValidIndex
;
int
fDeferredSaveCount
;
SkClipOp
fStackOp
;
ClipState
fState
;
uint32_t
fGenID
;
}
;
void
clip
(
RawElement
&
&
element
)
;
const
SaveRecord
&
currentSaveRecord
(
)
const
{
SkASSERT
(
!
fSaves
.
empty
(
)
)
;
return
fSaves
.
back
(
)
;
}
SaveRecord
&
writableSaveRecord
(
bool
*
wasDeferred
)
;
static
GrFPResult
GetSWMaskFP
(
GrRecordingContext
*
context
Mask
:
:
Stack
*
masks
const
SaveRecord
&
current
const
SkIRect
&
bounds
const
Element
*
*
elements
int
count
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clipFP
)
;
RawElement
:
:
Stack
fElements
;
SaveRecord
:
:
Stack
fSaves
;
mutable
Mask
:
:
Stack
fMasks
;
mutable
GrProxyProvider
*
fProxyProvider
;
const
SkIRect
fDeviceBounds
;
const
SkMatrixProvider
*
fMatrixProvider
;
bool
fForceAA
;
}
;
class
ClipStack
:
:
ElementIter
{
public
:
bool
operator
!
=
(
const
ElementIter
&
o
)
const
{
return
o
.
fItem
!
=
fItem
&
&
o
.
fRemaining
!
=
fRemaining
;
}
const
Element
&
operator
*
(
)
const
{
return
(
*
fItem
)
.
asElement
(
)
;
}
ElementIter
&
operator
+
+
(
)
{
do
{
fRemaining
-
-
;
+
+
fItem
;
}
while
(
fRemaining
>
0
&
&
(
*
fItem
)
.
isInvalid
(
)
)
;
return
*
this
;
}
ElementIter
(
RawElement
:
:
Stack
:
:
CRIter
:
:
Item
item
int
r
)
:
fItem
(
item
)
fRemaining
(
r
)
{
}
RawElement
:
:
Stack
:
:
CRIter
:
:
Item
fItem
;
int
fRemaining
;
friend
class
ClipStack
;
}
;
ClipStack
:
:
ElementIter
ClipStack
:
:
begin
(
)
const
{
if
(
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kEmpty
|
|
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kWideOpen
)
{
return
this
-
>
end
(
)
;
}
int
count
=
fElements
.
count
(
)
-
this
-
>
currentSaveRecord
(
)
.
oldestElementIndex
(
)
;
return
ElementIter
(
fElements
.
ritems
(
)
.
begin
(
)
count
)
;
}
ClipStack
:
:
ElementIter
ClipStack
:
:
end
(
)
const
{
return
ElementIter
(
fElements
.
ritems
(
)
.
end
(
)
0
)
;
}
}
#
endif
