#
ifndef
GrRenderTask_DEFINED
#
define
GrRenderTask_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureResolveManager
.
h
"
class
GrMockRenderTask
;
class
GrOpFlushState
;
class
GrResourceAllocator
;
class
GrTextureResolveRenderTask
;
namespace
skgpu
{
namespace
ganesh
{
class
OpsTask
;
}
}
class
GrRenderTask
:
public
SkRefCnt
{
public
:
GrRenderTask
(
)
;
SkDEBUGCODE
(
~
GrRenderTask
(
)
override
)
;
void
makeClosed
(
GrRecordingContext
*
)
;
void
prePrepare
(
GrRecordingContext
*
context
)
{
this
-
>
onPrePrepare
(
context
)
;
}
void
prepare
(
GrOpFlushState
*
flushState
)
;
bool
execute
(
GrOpFlushState
*
flushState
)
{
return
this
-
>
onExecute
(
flushState
)
;
}
virtual
bool
requiresExplicitCleanup
(
)
const
{
return
false
;
}
virtual
void
endFlush
(
GrDrawingManager
*
)
{
}
virtual
void
disown
(
GrDrawingManager
*
)
;
bool
isClosed
(
)
const
{
return
this
-
>
isSetFlag
(
kClosed_Flag
)
;
}
void
makeSkippable
(
)
;
bool
isSkippable
(
)
const
{
return
this
-
>
isSetFlag
(
kSkippable_Flag
)
;
}
bool
blocksReordering
(
)
const
{
return
this
-
>
isSetFlag
(
kBlocksReordering_Flag
)
;
}
void
addDependency
(
GrDrawingManager
*
GrSurfaceProxy
*
dependedOn
GrMipmapped
GrTextureResolveManager
const
GrCaps
&
caps
)
;
void
addDependenciesFromOtherTask
(
GrRenderTask
*
otherTask
)
;
SkSpan
<
GrRenderTask
*
>
dependencies
(
)
{
return
SkSpan
(
fDependencies
)
;
}
SkSpan
<
GrRenderTask
*
>
dependents
(
)
{
return
SkSpan
(
fDependents
)
;
}
void
replaceDependency
(
const
GrRenderTask
*
toReplace
GrRenderTask
*
replaceWith
)
;
void
replaceDependent
(
const
GrRenderTask
*
toReplace
GrRenderTask
*
replaceWith
)
;
bool
dependsOn
(
const
GrRenderTask
*
dependedOn
)
const
;
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
int
numTargets
(
)
const
{
return
fTargets
.
size
(
)
;
}
GrSurfaceProxy
*
target
(
int
i
)
const
{
return
fTargets
[
i
]
.
get
(
)
;
}
virtual
skgpu
:
:
ganesh
:
:
OpsTask
*
asOpsTask
(
)
{
return
nullptr
;
}
#
if
GR_TEST_UTILS
virtual
void
dump
(
const
SkString
&
label
SkString
indent
bool
printDependencies
bool
close
)
const
;
virtual
const
char
*
name
(
)
const
=
0
;
#
endif
#
ifdef
SK_DEBUG
virtual
int
numClips
(
)
const
{
return
0
;
}
virtual
void
visitProxies_debugOnly
(
const
GrVisitProxyFunc
&
)
const
=
0
;
void
visitTargetAndSrcProxies_debugOnly
(
const
GrVisitProxyFunc
&
func
)
const
{
this
-
>
visitProxies_debugOnly
(
func
)
;
for
(
const
sk_sp
<
GrSurfaceProxy
>
&
target
:
fTargets
)
{
func
(
target
.
get
(
)
GrMipmapped
:
:
kNo
)
;
}
}
#
endif
bool
isUsed
(
GrSurfaceProxy
*
proxy
)
const
{
for
(
const
sk_sp
<
GrSurfaceProxy
>
&
target
:
fTargets
)
{
if
(
target
.
get
(
)
=
=
proxy
)
{
return
true
;
}
}
return
this
-
>
onIsUsed
(
proxy
)
;
}
virtual
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
=
0
;
bool
isInstantiated
(
)
const
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrRenderTask
)
;
#
if
GR_TEST_UTILS
const
GrTextureResolveRenderTask
*
resolveTask
(
)
const
{
return
fTextureResolveTask
;
}
#
endif
protected
:
SkDEBUGCODE
(
bool
deferredProxiesAreInstantiated
(
)
const
;
)
void
addTarget
(
GrDrawingManager
*
sk_sp
<
GrSurfaceProxy
>
)
;
void
addTarget
(
GrDrawingManager
*
dm
const
GrSurfaceProxyView
&
view
)
{
this
-
>
addTarget
(
dm
view
.
refProxy
(
)
)
;
}
enum
class
ExpectedOutcome
:
bool
{
kTargetUnchanged
kTargetDirty
}
;
virtual
ExpectedOutcome
onMakeClosed
(
GrRecordingContext
*
SkIRect
*
targetUpdateBounds
)
=
0
;
SkSTArray
<
1
sk_sp
<
GrSurfaceProxy
>
>
fTargets
;
SkTArray
<
GrTextureProxy
*
true
>
fDeferredProxies
;
enum
Flags
{
kClosed_Flag
=
0x01
kDisowned_Flag
=
0x02
kSkippable_Flag
=
0x04
kAtlas_Flag
=
0x08
kBlocksReordering_Flag
=
0x10
kWasOutput_Flag
=
0x20
kTempMark_Flag
=
0x40
}
;
void
setFlag
(
uint32_t
flag
)
{
fFlags
|
=
flag
;
}
void
resetFlag
(
uint32_t
flag
)
{
fFlags
&
=
~
flag
;
}
bool
isSetFlag
(
uint32_t
flag
)
const
{
return
SkToBool
(
fFlags
&
flag
)
;
}
void
setIndex
(
uint32_t
index
)
{
SkASSERT
(
!
this
-
>
isSetFlag
(
kWasOutput_Flag
)
)
;
SkASSERT
(
index
<
(
1
<
<
25
)
)
;
fFlags
|
=
index
<
<
7
;
}
uint32_t
getIndex
(
)
const
{
SkASSERT
(
this
-
>
isSetFlag
(
kWasOutput_Flag
)
)
;
return
fFlags
>
>
7
;
}
private
:
friend
class
GrDrawingManager
;
friend
class
GrMockRenderTask
;
virtual
bool
onIsUsed
(
GrSurfaceProxy
*
)
const
=
0
;
void
addDependency
(
GrRenderTask
*
dependedOn
)
;
void
addDependent
(
GrRenderTask
*
dependent
)
;
SkDEBUGCODE
(
bool
isDependent
(
const
GrRenderTask
*
dependent
)
const
;
)
SkDEBUGCODE
(
void
validate
(
)
const
;
)
static
uint32_t
CreateUniqueID
(
)
;
struct
TopoSortTraits
{
static
uint32_t
GetIndex
(
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
getIndex
(
)
;
}
static
void
Output
(
GrRenderTask
*
renderTask
uint32_t
index
)
{
renderTask
-
>
setIndex
(
index
)
;
renderTask
-
>
setFlag
(
kWasOutput_Flag
)
;
}
static
bool
WasOutput
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
isSetFlag
(
kWasOutput_Flag
)
;
}
static
void
SetTempMark
(
GrRenderTask
*
renderTask
)
{
renderTask
-
>
setFlag
(
kTempMark_Flag
)
;
}
static
void
ResetTempMark
(
GrRenderTask
*
renderTask
)
{
renderTask
-
>
resetFlag
(
kTempMark_Flag
)
;
}
static
bool
IsTempMarked
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
isSetFlag
(
kTempMark_Flag
)
;
}
static
int
NumDependencies
(
const
GrRenderTask
*
renderTask
)
{
return
renderTask
-
>
fDependencies
.
size
(
)
;
}
static
GrRenderTask
*
Dependency
(
GrRenderTask
*
renderTask
int
index
)
{
return
renderTask
-
>
fDependencies
[
index
]
;
}
}
;
virtual
void
onMakeSkippable
(
)
{
}
virtual
void
onPrePrepare
(
GrRecordingContext
*
)
{
}
virtual
void
onPrepare
(
GrOpFlushState
*
)
{
}
virtual
bool
onExecute
(
GrOpFlushState
*
flushState
)
=
0
;
const
uint32_t
fUniqueID
;
uint32_t
fFlags
;
SkSTArray
<
1
GrRenderTask
*
true
>
fDependencies
;
SkSTArray
<
1
GrRenderTask
*
true
>
fDependents
;
GrTextureResolveRenderTask
*
fTextureResolveTask
=
nullptr
;
SkDEBUGCODE
(
GrDrawingManager
*
fDrawingMgr
=
nullptr
;
)
}
;
#
endif
