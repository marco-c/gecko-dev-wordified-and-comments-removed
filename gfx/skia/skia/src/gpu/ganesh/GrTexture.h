#
ifndef
GrTexture_DEFINED
#
define
GrTexture_DEFINED
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
class
GrTexture
:
virtual
public
GrSurface
{
public
:
GrTexture
*
asTexture
(
)
override
{
return
this
;
}
const
GrTexture
*
asTexture
(
)
const
override
{
return
this
;
}
virtual
GrBackendTexture
getBackendTexture
(
)
const
=
0
;
virtual
void
textureParamsModified
(
)
=
0
;
static
bool
StealBackendTexture
(
sk_sp
<
GrTexture
>
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
;
GrTextureType
textureType
(
)
const
{
return
fTextureType
;
}
bool
hasRestrictedSampling
(
)
const
{
return
GrTextureTypeHasRestrictedSampling
(
this
-
>
textureType
(
)
)
;
}
void
markMipmapsDirty
(
)
;
void
markMipmapsClean
(
)
;
GrMipmapped
mipmapped
(
)
const
{
return
GrMipmapped
(
fMipmapStatus
!
=
GrMipmapStatus
:
:
kNotAllocated
)
;
}
bool
mipmapsAreDirty
(
)
const
{
return
fMipmapStatus
!
=
GrMipmapStatus
:
:
kValid
;
}
GrMipmapStatus
mipmapStatus
(
)
const
{
return
fMipmapStatus
;
}
int
maxMipmapLevel
(
)
const
{
return
fMaxMipmapLevel
;
}
static
void
ComputeScratchKey
(
const
GrCaps
&
caps
const
GrBackendFormat
&
format
SkISize
dimensions
GrRenderable
int
sampleCnt
GrMipmapped
GrProtected
skgpu
:
:
ScratchKey
*
key
)
;
protected
:
GrTexture
(
GrGpu
*
const
SkISize
&
GrProtected
GrTextureType
GrMipmapStatus
std
:
:
string_view
label
)
;
virtual
bool
onStealBackendTexture
(
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
=
0
;
void
computeScratchKey
(
skgpu
:
:
ScratchKey
*
)
const
override
;
private
:
size_t
onGpuMemorySize
(
)
const
override
;
GrTextureType
fTextureType
;
GrMipmapStatus
fMipmapStatus
;
int
fMaxMipmapLevel
;
friend
class
GrTextureResource
;
using
INHERITED
=
GrSurface
;
}
;
#
endif
