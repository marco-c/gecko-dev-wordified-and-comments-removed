#
ifndef
GrBufferAllocPool_DEFINED
#
define
GrBufferAllocPool_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCpuBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDrawIndirectCommand
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrNonAtomicRef
.
h
"
class
GrGpu
;
class
GrBufferAllocPool
:
SkNoncopyable
{
public
:
inline
static
constexpr
size_t
kDefaultBufferSize
=
1
<
<
15
;
class
CpuBufferCache
:
public
GrNonAtomicRef
<
CpuBufferCache
>
{
public
:
static
sk_sp
<
CpuBufferCache
>
Make
(
int
maxBuffersToCache
)
;
sk_sp
<
GrCpuBuffer
>
makeBuffer
(
size_t
size
bool
mustBeInitialized
)
;
void
releaseAll
(
)
;
private
:
CpuBufferCache
(
int
maxBuffersToCache
)
;
struct
Buffer
{
sk_sp
<
GrCpuBuffer
>
fBuffer
;
bool
fCleared
=
false
;
}
;
std
:
:
unique_ptr
<
Buffer
[
]
>
fBuffers
;
int
fMaxBuffersToCache
=
0
;
}
;
void
unmap
(
)
;
void
reset
(
)
;
void
putBack
(
size_t
bytes
)
;
protected
:
GrBufferAllocPool
(
GrGpu
*
gpu
GrGpuBufferType
bufferType
sk_sp
<
CpuBufferCache
>
cpuBufferCache
)
;
virtual
~
GrBufferAllocPool
(
)
;
void
*
makeSpace
(
size_t
size
size_t
alignment
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
)
;
void
*
makeSpaceAtLeast
(
size_t
minSize
size_t
fallbackSize
size_t
alignment
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
size_t
*
actualSize
)
;
sk_sp
<
GrBuffer
>
getBuffer
(
size_t
size
)
;
private
:
struct
BufferBlock
{
size_t
fBytesFree
;
sk_sp
<
GrBuffer
>
fBuffer
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fBuffer
)
>
:
:
value
)
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
}
;
bool
createBlock
(
size_t
requestSize
)
;
void
destroyBlock
(
)
;
void
deleteBlocks
(
)
;
void
flushCpuData
(
const
BufferBlock
&
block
size_t
flushSize
)
;
void
resetCpuData
(
size_t
newSize
)
;
#
ifdef
SK_DEBUG
void
validate
(
bool
unusedBlockAllowed
=
false
)
const
;
#
endif
size_t
fBytesInUse
=
0
;
SkTArray
<
BufferBlock
>
fBlocks
;
sk_sp
<
CpuBufferCache
>
fCpuBufferCache
;
sk_sp
<
GrCpuBuffer
>
fCpuStagingBuffer
;
GrGpu
*
fGpu
;
GrGpuBufferType
fBufferType
;
void
*
fBufferPtr
=
nullptr
;
}
;
class
GrVertexBufferAllocPool
:
public
GrBufferAllocPool
{
public
:
GrVertexBufferAllocPool
(
GrGpu
*
gpu
sk_sp
<
CpuBufferCache
>
cpuBufferCache
)
;
void
*
makeSpace
(
size_t
vertexSize
int
vertexCount
sk_sp
<
const
GrBuffer
>
*
buffer
int
*
startVertex
)
;
void
*
makeSpaceAtLeast
(
size_t
vertexSize
int
minVertexCount
int
fallbackVertexCount
sk_sp
<
const
GrBuffer
>
*
buffer
int
*
startVertex
int
*
actualVertexCount
)
;
private
:
using
INHERITED
=
GrBufferAllocPool
;
}
;
class
GrIndexBufferAllocPool
:
public
GrBufferAllocPool
{
public
:
GrIndexBufferAllocPool
(
GrGpu
*
gpu
sk_sp
<
CpuBufferCache
>
cpuBufferCache
)
;
void
*
makeSpace
(
int
indexCount
sk_sp
<
const
GrBuffer
>
*
buffer
int
*
startIndex
)
;
void
*
makeSpaceAtLeast
(
int
minIndexCount
int
fallbackIndexCount
sk_sp
<
const
GrBuffer
>
*
buffer
int
*
startIndex
int
*
actualIndexCount
)
;
private
:
using
INHERITED
=
GrBufferAllocPool
;
}
;
class
GrDrawIndirectBufferAllocPool
:
private
GrBufferAllocPool
{
public
:
GrDrawIndirectBufferAllocPool
(
GrGpu
*
gpu
sk_sp
<
CpuBufferCache
>
cpuBufferCache
)
:
GrBufferAllocPool
(
gpu
GrGpuBufferType
:
:
kDrawIndirect
std
:
:
move
(
cpuBufferCache
)
)
{
}
GrDrawIndirectWriter
makeSpace
(
int
drawCount
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
)
{
return
this
-
>
GrBufferAllocPool
:
:
makeSpace
(
drawCount
*
sizeof
(
GrDrawIndirectCommand
)
4
buffer
offset
)
;
}
void
putBack
(
int
drawCount
)
{
this
-
>
GrBufferAllocPool
:
:
putBack
(
drawCount
*
sizeof
(
GrDrawIndirectCommand
)
)
;
}
GrDrawIndexedIndirectWriter
makeIndexedSpace
(
int
drawCount
sk_sp
<
const
GrBuffer
>
*
buffer
size_t
*
offset
)
{
return
this
-
>
GrBufferAllocPool
:
:
makeSpace
(
drawCount
*
sizeof
(
GrDrawIndexedIndirectCommand
)
4
buffer
offset
)
;
}
void
putBackIndexed
(
int
drawCount
)
{
this
-
>
GrBufferAllocPool
:
:
putBack
(
drawCount
*
sizeof
(
GrDrawIndexedIndirectCommand
)
)
;
}
using
GrBufferAllocPool
:
:
unmap
;
using
GrBufferAllocPool
:
:
reset
;
}
;
#
endif
