#
ifndef
GrSurfaceProxy_DEFINED
#
define
GrSurfaceProxy_DEFINED
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
utility
>
class
GrCaps
;
class
GrContext_Base
;
class
GrRecordingContext
;
class
GrRenderTarget
;
class
GrRenderTargetProxy
;
class
GrRenderTask
;
class
GrResourceProvider
;
class
GrSurfaceProxyPriv
;
class
GrTexture
;
class
GrTextureProxy
;
enum
class
SkBackingFit
;
namespace
skgpu
{
enum
class
Budgeted
:
bool
;
}
class
GrSurfaceProxy
:
public
SkNVRefCnt
<
GrSurfaceProxy
>
{
public
:
virtual
~
GrSurfaceProxy
(
)
;
enum
class
ResolveFlags
{
kNone
=
0
kMSAA
=
1
<
<
0
kMipMaps
=
1
<
<
1
}
;
enum
class
LazyInstantiationKeyMode
{
kUnsynced
kSynced
}
;
struct
LazySurfaceDesc
{
SkISize
fDimensions
;
SkBackingFit
fFit
;
GrRenderable
fRenderable
;
GrMipmapped
fMipmapped
;
int
fSampleCnt
;
const
GrBackendFormat
&
fFormat
;
GrTextureType
fTextureType
;
GrProtected
fProtected
;
skgpu
:
:
Budgeted
fBudgeted
;
std
:
:
string_view
fLabel
;
}
;
struct
LazyCallbackResult
{
LazyCallbackResult
(
)
=
default
;
LazyCallbackResult
(
const
LazyCallbackResult
&
)
=
default
;
LazyCallbackResult
(
LazyCallbackResult
&
&
that
)
=
default
;
LazyCallbackResult
(
sk_sp
<
GrSurface
>
surf
bool
releaseCallback
=
true
LazyInstantiationKeyMode
mode
=
LazyInstantiationKeyMode
:
:
kSynced
)
;
LazyCallbackResult
(
sk_sp
<
GrTexture
>
tex
)
;
LazyCallbackResult
&
operator
=
(
const
LazyCallbackResult
&
)
=
default
;
LazyCallbackResult
&
operator
=
(
LazyCallbackResult
&
&
)
=
default
;
sk_sp
<
GrSurface
>
fSurface
;
LazyInstantiationKeyMode
fKeyMode
=
LazyInstantiationKeyMode
:
:
kSynced
;
bool
fReleaseCallback
=
true
;
}
;
using
LazyInstantiateCallback
=
std
:
:
function
<
LazyCallbackResult
(
GrResourceProvider
*
const
LazySurfaceDesc
&
)
>
;
enum
class
UseAllocator
{
kNo
=
false
kYes
=
true
}
;
bool
isLazy
(
)
const
{
return
!
this
-
>
isInstantiated
(
)
&
&
SkToBool
(
fLazyInstantiateCallback
)
;
}
bool
isFullyLazy
(
)
const
{
bool
result
=
fDimensions
.
width
(
)
<
0
;
SkASSERT
(
result
=
=
(
fDimensions
.
height
(
)
<
0
)
)
;
SkASSERT
(
!
result
|
|
this
-
>
isLazy
(
)
)
;
return
result
;
}
SkISize
dimensions
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
return
fDimensions
;
}
int
width
(
)
const
{
return
this
-
>
dimensions
(
)
.
width
(
)
;
}
int
height
(
)
const
{
return
this
-
>
dimensions
(
)
.
height
(
)
;
}
SkISize
backingStoreDimensions
(
)
const
;
SkRect
getBoundsRect
(
)
const
{
return
SkRect
:
:
Make
(
this
-
>
dimensions
(
)
)
;
}
bool
isFunctionallyExact
(
)
const
;
SkRect
backingStoreBoundsRect
(
)
const
{
return
SkRect
:
:
Make
(
this
-
>
backingStoreDimensions
(
)
)
;
}
SkIRect
backingStoreBoundsIRect
(
)
const
{
return
SkIRect
:
:
MakeSize
(
this
-
>
backingStoreDimensions
(
)
)
;
}
const
GrBackendFormat
&
backendFormat
(
)
const
{
return
fFormat
;
}
bool
isFormatCompressed
(
const
GrCaps
*
)
const
;
class
UniqueID
{
public
:
static
UniqueID
InvalidID
(
)
{
return
UniqueID
(
uint32_t
(
SK_InvalidUniqueID
)
)
;
}
explicit
UniqueID
(
const
GrGpuResource
:
:
UniqueID
&
id
)
:
fID
(
id
.
asUInt
(
)
)
{
}
UniqueID
(
)
:
fID
(
GrGpuResource
:
:
CreateUniqueID
(
)
)
{
}
uint32_t
asUInt
(
)
const
{
return
fID
;
}
bool
operator
=
=
(
const
UniqueID
&
other
)
const
{
return
fID
=
=
other
.
fID
;
}
bool
operator
!
=
(
const
UniqueID
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isInvalid
(
)
const
{
return
SK_InvalidUniqueID
=
=
fID
;
}
private
:
explicit
UniqueID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
fID
;
}
;
UniqueID
uniqueID
(
)
const
{
return
fUniqueID
;
}
UniqueID
underlyingUniqueID
(
)
const
{
if
(
fTarget
)
{
return
UniqueID
(
fTarget
-
>
uniqueID
(
)
)
;
}
return
fUniqueID
;
}
virtual
bool
instantiate
(
GrResourceProvider
*
)
=
0
;
void
deinstantiate
(
)
;
bool
canSkipResourceAllocator
(
)
const
;
virtual
GrTextureProxy
*
asTextureProxy
(
)
{
return
nullptr
;
}
virtual
const
GrTextureProxy
*
asTextureProxy
(
)
const
{
return
nullptr
;
}
virtual
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
{
return
nullptr
;
}
virtual
const
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
const
{
return
nullptr
;
}
virtual
const
skgpu
:
:
UniqueKey
&
getUniqueKey
(
)
const
{
static
const
skgpu
:
:
UniqueKey
kInvalidKey
;
return
kInvalidKey
;
}
bool
isInstantiated
(
)
const
{
return
SkToBool
(
fTarget
)
;
}
void
isUsedAsTaskTarget
(
)
{
+
+
fTaskTargetCount
;
}
int
getTaskTargetCount
(
)
const
{
return
fTaskTargetCount
;
}
GrSurface
*
peekSurface
(
)
const
{
return
fTarget
.
get
(
)
;
}
GrTexture
*
peekTexture
(
)
const
{
return
fTarget
?
fTarget
-
>
asTexture
(
)
:
nullptr
;
}
GrRenderTarget
*
peekRenderTarget
(
)
const
{
return
fTarget
?
fTarget
-
>
asRenderTarget
(
)
:
nullptr
;
}
skgpu
:
:
Budgeted
isBudgeted
(
)
const
{
return
fBudgeted
;
}
bool
readOnly
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kReadOnly
;
}
bool
framebufferOnly
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kFramebufferOnly
;
}
bool
requiresManualMSAAResolve
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kRequiresManualMSAAResolve
;
}
size_t
gpuMemorySize
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
if
(
kInvalidGpuMemorySize
=
=
fGpuMemorySize
)
{
fGpuMemorySize
=
this
-
>
onUninstantiatedGpuMemorySize
(
)
;
SkASSERT
(
kInvalidGpuMemorySize
!
=
fGpuMemorySize
)
;
}
return
fGpuMemorySize
;
}
std
:
:
string_view
getLabel
(
)
const
{
return
fLabel
;
}
enum
class
RectsMustMatch
:
bool
{
kNo
=
false
kYes
=
true
}
;
static
sk_sp
<
GrSurfaceProxy
>
Copy
(
GrRecordingContext
*
sk_sp
<
GrSurfaceProxy
>
src
GrSurfaceOrigin
GrMipmapped
SkIRect
srcRect
SkBackingFit
skgpu
:
:
Budgeted
std
:
:
string_view
label
RectsMustMatch
=
RectsMustMatch
:
:
kNo
sk_sp
<
GrRenderTask
>
*
outTask
=
nullptr
)
;
static
sk_sp
<
GrSurfaceProxy
>
Copy
(
GrRecordingContext
*
sk_sp
<
GrSurfaceProxy
>
src
GrSurfaceOrigin
GrMipmapped
SkBackingFit
skgpu
:
:
Budgeted
std
:
:
string_view
label
sk_sp
<
GrRenderTask
>
*
outTask
=
nullptr
)
;
#
if
GR_TEST_UTILS
int32_t
testingOnly_getBackingRefCnt
(
)
const
;
GrInternalSurfaceFlags
testingOnly_getFlags
(
)
const
;
SkString
dump
(
)
const
;
#
endif
#
ifdef
SK_DEBUG
void
validate
(
GrContext_Base
*
)
const
;
SkString
getDebugName
(
)
{
return
fDebugName
.
isEmpty
(
)
?
SkStringPrintf
(
"
%
d
"
this
-
>
uniqueID
(
)
.
asUInt
(
)
)
:
fDebugName
;
}
void
setDebugName
(
SkString
name
)
{
fDebugName
=
std
:
:
move
(
name
)
;
}
#
endif
inline
GrSurfaceProxyPriv
priv
(
)
;
inline
const
GrSurfaceProxyPriv
priv
(
)
const
;
bool
isDDLTarget
(
)
const
{
return
fIsDDLTarget
;
}
GrProtected
isProtected
(
)
const
{
return
fIsProtected
;
}
bool
isPromiseProxy
(
)
{
return
fIsPromiseProxy
;
}
protected
:
GrSurfaceProxy
(
const
GrBackendFormat
&
SkISize
SkBackingFit
skgpu
:
:
Budgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
std
:
:
string_view
label
)
;
GrSurfaceProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
SkBackingFit
skgpu
:
:
Budgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
std
:
:
string_view
label
)
;
GrSurfaceProxy
(
sk_sp
<
GrSurface
>
SkBackingFit
UseAllocator
)
;
friend
class
GrSurfaceProxyPriv
;
bool
ignoredByResourceAllocator
(
)
const
{
return
fIgnoredByResourceAllocator
;
}
void
setIgnoredByResourceAllocator
(
)
{
fIgnoredByResourceAllocator
=
true
;
}
void
computeScratchKey
(
const
GrCaps
&
skgpu
:
:
ScratchKey
*
)
const
;
virtual
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
=
0
;
void
assign
(
sk_sp
<
GrSurface
>
surface
)
;
sk_sp
<
GrSurface
>
createSurfaceImpl
(
GrResourceProvider
*
int
sampleCnt
GrRenderable
GrMipmapped
)
const
;
void
setLazyDimensions
(
SkISize
dimensions
)
{
SkASSERT
(
this
-
>
isFullyLazy
(
)
)
;
SkASSERT
(
!
dimensions
.
isEmpty
(
)
)
;
fDimensions
=
dimensions
;
}
bool
instantiateImpl
(
GrResourceProvider
*
resourceProvider
int
sampleCnt
GrRenderable
GrMipmapped
const
skgpu
:
:
UniqueKey
*
)
;
sk_sp
<
GrSurface
>
fTarget
;
GrInternalSurfaceFlags
fSurfaceFlags
;
private
:
const
GrBackendFormat
fFormat
;
SkISize
fDimensions
;
SkBackingFit
fFit
;
mutable
skgpu
:
:
Budgeted
fBudgeted
;
UseAllocator
fUseAllocator
;
const
UniqueID
fUniqueID
;
LazyInstantiateCallback
fLazyInstantiateCallback
;
SkDEBUGCODE
(
void
validateSurface
(
const
GrSurface
*
)
;
)
SkDEBUGCODE
(
virtual
void
onValidateSurface
(
const
GrSurface
*
)
=
0
;
)
static
const
size_t
kInvalidGpuMemorySize
=
~
static_cast
<
size_t
>
(
0
)
;
SkDEBUGCODE
(
size_t
getRawGpuMemorySize_debugOnly
(
)
const
{
return
fGpuMemorySize
;
}
)
virtual
size_t
onUninstantiatedGpuMemorySize
(
)
const
=
0
;
virtual
LazySurfaceDesc
callbackDesc
(
)
const
=
0
;
bool
fIgnoredByResourceAllocator
=
false
;
bool
fIsDDLTarget
=
false
;
bool
fIsPromiseProxy
=
false
;
GrProtected
fIsProtected
;
int
fTaskTargetCount
=
0
;
const
std
:
:
string
fLabel
;
mutable
std
:
:
atomic
<
size_t
>
fGpuMemorySize
{
kInvalidGpuMemorySize
}
;
SkDEBUGCODE
(
SkString
fDebugName
;
)
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrSurfaceProxy
:
:
ResolveFlags
)
#
endif
