#
ifndef
GrTTopoSort_DEFINED
#
define
GrTTopoSort_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
ifdef
SK_DEBUG
template
<
typename
T
typename
Traits
=
T
>
void
GrTTopoSort_CheckAllUnmarked
(
SkSpan
<
const
sk_sp
<
T
>
>
graph
)
{
for
(
const
auto
&
node
:
graph
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
node
.
get
(
)
)
)
;
SkASSERT
(
!
Traits
:
:
WasOutput
(
node
.
get
(
)
)
)
;
}
}
template
<
typename
T
typename
Traits
=
T
>
void
GrTTopoSort_CleanExit
(
SkSpan
<
const
sk_sp
<
T
>
>
graph
uint32_t
offset
)
{
for
(
size_t
i
=
0
;
i
<
graph
.
size
(
)
;
+
+
i
)
{
SkASSERT
(
!
Traits
:
:
IsTempMarked
(
graph
[
i
]
.
get
(
)
)
)
;
SkASSERT
(
Traits
:
:
WasOutput
(
graph
[
i
]
.
get
(
)
)
)
;
SkASSERT
(
Traits
:
:
GetIndex
(
graph
[
i
]
.
get
(
)
)
-
offset
=
=
(
uint32_t
)
i
)
;
}
}
#
endif
template
<
typename
T
typename
Traits
=
T
>
bool
GrTTopoSort_Visit
(
T
*
node
uint32_t
*
counter
)
{
if
(
Traits
:
:
IsTempMarked
(
node
)
)
{
return
false
;
}
if
(
Traits
:
:
WasOutput
(
node
)
)
{
return
true
;
}
bool
succeeded
=
true
;
Traits
:
:
SetTempMark
(
node
)
;
for
(
int
i
=
0
;
i
<
Traits
:
:
NumDependencies
(
node
)
;
+
+
i
)
{
if
(
!
GrTTopoSort_Visit
<
T
Traits
>
(
Traits
:
:
Dependency
(
node
i
)
counter
)
)
{
succeeded
=
false
;
}
}
Traits
:
:
Output
(
node
*
counter
)
;
+
+
(
*
counter
)
;
Traits
:
:
ResetTempMark
(
node
)
;
return
succeeded
;
}
template
<
typename
T
typename
Traits
=
T
>
bool
GrTTopoSort
(
SkSpan
<
sk_sp
<
T
>
>
graph
uint32_t
offset
=
0
)
{
uint32_t
counter
=
offset
;
#
ifdef
SK_DEBUG
GrTTopoSort_CheckAllUnmarked
<
T
Traits
>
(
graph
)
;
#
endif
bool
succeeded
=
true
;
for
(
size_t
i
=
0
;
i
<
graph
.
size
(
)
;
+
+
i
)
{
if
(
Traits
:
:
WasOutput
(
graph
[
i
]
.
get
(
)
)
)
{
continue
;
}
if
(
!
GrTTopoSort_Visit
<
T
Traits
>
(
graph
[
i
]
.
get
(
)
&
counter
)
)
{
succeeded
=
false
;
}
}
SkASSERT
(
counter
-
offset
=
=
(
uint32_t
)
graph
.
size
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
(
uint32_t
)
graph
.
size
(
)
;
+
+
i
)
{
for
(
uint32_t
correctIndex
=
Traits
:
:
GetIndex
(
graph
[
i
]
.
get
(
)
)
-
offset
;
correctIndex
!
=
i
;
correctIndex
=
Traits
:
:
GetIndex
(
graph
[
i
]
.
get
(
)
)
-
offset
)
{
graph
[
i
]
.
swap
(
graph
[
correctIndex
]
)
;
}
}
#
ifdef
SK_DEBUG
GrTTopoSort_CleanExit
<
T
Traits
>
(
graph
offset
)
;
#
endif
return
succeeded
;
}
#
endif
