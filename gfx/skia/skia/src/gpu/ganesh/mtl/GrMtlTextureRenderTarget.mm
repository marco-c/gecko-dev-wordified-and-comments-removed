#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
mtl
/
GrMtlGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
mtl
/
GrMtlTextureRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
mtl
/
GrMtlUtil
.
h
"
#
if
!
__has_feature
(
objc_arc
)
#
error
This
file
must
be
compiled
with
Arc
.
Use
-
fobjc
-
arc
flag
#
endif
GR_NORETAIN_BEGIN
GrMtlTextureRenderTarget
:
:
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
sk_sp
<
GrMtlAttachment
>
texture
sk_sp
<
GrMtlAttachment
>
colorAttachment
sk_sp
<
GrMtlAttachment
>
resolveAttachment
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
GrProtected
:
:
kNo
label
)
GrMtlTexture
(
gpu
dimensions
std
:
:
move
(
texture
)
mipmapStatus
label
)
GrMtlRenderTarget
(
gpu
dimensions
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
label
)
{
this
-
>
registerWithCache
(
budgeted
)
;
}
GrMtlTextureRenderTarget
:
:
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
SkISize
dimensions
sk_sp
<
GrMtlAttachment
>
texture
sk_sp
<
GrMtlAttachment
>
colorAttachment
sk_sp
<
GrMtlAttachment
>
resolveAttachment
GrMipmapStatus
mipmapStatus
GrWrapCacheable
cacheable
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
GrProtected
:
:
kNo
label
)
GrMtlTexture
(
gpu
dimensions
std
:
:
move
(
texture
)
mipmapStatus
label
)
GrMtlRenderTarget
(
gpu
dimensions
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
label
)
{
this
-
>
registerWithCacheWrapped
(
cacheable
)
;
}
bool
create_rt_attachments
(
GrMtlGpu
*
gpu
SkISize
dimensions
MTLPixelFormat
format
int
sampleCnt
sk_sp
<
GrMtlAttachment
>
texture
sk_sp
<
GrMtlAttachment
>
*
colorAttachment
sk_sp
<
GrMtlAttachment
>
*
resolveAttachment
)
{
if
(
sampleCnt
>
1
)
{
auto
rp
=
gpu
-
>
getContext
(
)
-
>
priv
(
)
.
resourceProvider
(
)
;
sk_sp
<
GrAttachment
>
msaaAttachment
=
rp
-
>
makeMSAAAttachment
(
dimensions
GrBackendFormat
:
:
MakeMtl
(
format
)
sampleCnt
GrProtected
:
:
kNo
GrMemoryless
:
:
kNo
)
;
if
(
!
msaaAttachment
)
{
return
false
;
}
*
colorAttachment
=
sk_sp
<
GrMtlAttachment
>
(
static_cast
<
GrMtlAttachment
*
>
(
msaaAttachment
.
release
(
)
)
)
;
*
resolveAttachment
=
std
:
:
move
(
texture
)
;
}
else
{
*
colorAttachment
=
std
:
:
move
(
texture
)
;
}
return
true
;
}
sk_sp
<
GrMtlTextureRenderTarget
>
GrMtlTextureRenderTarget
:
:
MakeNewTextureRenderTarget
(
GrMtlGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
int
sampleCnt
MTLPixelFormat
format
uint32_t
mipLevels
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
{
sk_sp
<
GrMtlAttachment
>
textureAttachment
=
GrMtlAttachment
:
:
MakeTexture
(
gpu
dimensions
format
mipLevels
GrRenderable
:
:
kYes
1
budgeted
)
;
if
(
!
textureAttachment
)
{
return
nullptr
;
}
if
(
available
(
macOS
10
.
11
iOS
9
.
0
*
)
)
{
SkASSERT
(
(
MTLTextureUsageShaderRead
|
MTLTextureUsageRenderTarget
)
&
textureAttachment
-
>
mtlTexture
(
)
.
usage
)
;
}
sk_sp
<
GrMtlAttachment
>
colorAttachment
;
sk_sp
<
GrMtlAttachment
>
resolveAttachment
;
if
(
!
create_rt_attachments
(
gpu
dimensions
format
sampleCnt
textureAttachment
&
colorAttachment
&
resolveAttachment
)
)
{
return
nullptr
;
}
SkASSERT
(
colorAttachment
)
;
SkASSERT
(
sampleCnt
=
=
1
|
|
resolveAttachment
)
;
return
sk_sp
<
GrMtlTextureRenderTarget
>
(
new
GrMtlTextureRenderTarget
(
gpu
budgeted
dimensions
std
:
:
move
(
textureAttachment
)
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
mipmapStatus
label
)
)
;
}
sk_sp
<
GrMtlTextureRenderTarget
>
GrMtlTextureRenderTarget
:
:
MakeWrappedTextureRenderTarget
(
GrMtlGpu
*
gpu
SkISize
dimensions
int
sampleCnt
id
<
MTLTexture
>
texture
GrWrapCacheable
cacheable
)
{
SkASSERT
(
nil
!
=
texture
)
;
if
(
available
(
macOS
10
.
11
iOS
9
.
0
*
)
)
{
SkASSERT
(
(
MTLTextureUsageShaderRead
|
MTLTextureUsageRenderTarget
)
&
texture
.
usage
)
;
}
GrMipmapStatus
mipmapStatus
=
texture
.
mipmapLevelCount
>
1
?
GrMipmapStatus
:
:
kDirty
:
GrMipmapStatus
:
:
kNotAllocated
;
GrAttachment
:
:
UsageFlags
textureUsageFlags
=
GrAttachment
:
:
UsageFlags
:
:
kTexture
|
GrAttachment
:
:
UsageFlags
:
:
kColorAttachment
;
sk_sp
<
GrMtlAttachment
>
textureAttachment
=
GrMtlAttachment
:
:
MakeWrapped
(
gpu
dimensions
texture
textureUsageFlags
cacheable
"
MtlAttachment_TextureAttachment
"
)
;
if
(
!
textureAttachment
)
{
return
nullptr
;
}
sk_sp
<
GrMtlAttachment
>
colorAttachment
;
sk_sp
<
GrMtlAttachment
>
resolveAttachment
;
if
(
!
create_rt_attachments
(
gpu
dimensions
texture
.
pixelFormat
sampleCnt
textureAttachment
&
colorAttachment
&
resolveAttachment
)
)
{
return
nullptr
;
}
SkASSERT
(
colorAttachment
)
;
SkASSERT
(
sampleCnt
=
=
1
|
|
resolveAttachment
)
;
return
sk_sp
<
GrMtlTextureRenderTarget
>
(
new
GrMtlTextureRenderTarget
(
gpu
dimensions
std
:
:
move
(
textureAttachment
)
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
mipmapStatus
cacheable
"
MtlWrappedTextureRenderTarget
"
)
)
;
}
size_t
GrMtlTextureRenderTarget
:
:
onGpuMemorySize
(
)
const
{
#
ifdef
SK_DEBUG
SkASSERT
(
this
-
>
nonMSAAAttachment
(
)
-
>
gpuMemorySize
(
)
=
=
0
)
;
if
(
this
-
>
numSamples
(
)
>
1
)
{
SkASSERT
(
this
-
>
colorAttachment
(
)
-
>
gpuMemorySize
(
)
=
=
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
this
-
>
numSamples
(
)
GrMipmapped
:
:
kNo
)
)
;
}
#
endif
return
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
1
this
-
>
mipmapped
(
)
)
;
}
void
GrMtlTextureRenderTarget
:
:
onSetLabel
(
)
{
GrMtlRenderTarget
:
:
onSetLabel
(
)
;
GrMtlTexture
:
:
onSetLabel
(
)
;
}
GR_NORETAIN_END
