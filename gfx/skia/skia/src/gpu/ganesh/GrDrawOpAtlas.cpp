#
include
"
src
/
gpu
/
ganesh
/
GrDrawOpAtlas
.
h
"
#
include
<
memory
>
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBackendUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProviderPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTracing
.
h
"
using
AtlasLocator
=
skgpu
:
:
AtlasLocator
;
using
AtlasToken
=
skgpu
:
:
AtlasToken
;
using
EvictionCallback
=
skgpu
:
:
PlotEvictionCallback
;
using
GenerationCounter
=
skgpu
:
:
AtlasGenerationCounter
;
using
MaskFormat
=
skgpu
:
:
MaskFormat
;
using
Plot
=
skgpu
:
:
Plot
;
using
PlotList
=
skgpu
:
:
PlotList
;
using
PlotLocator
=
skgpu
:
:
PlotLocator
;
#
if
defined
(
DUMP_ATLAS_DATA
)
static
const
constexpr
bool
kDumpAtlasData
=
true
;
#
else
static
const
constexpr
bool
kDumpAtlasData
=
false
;
#
endif
#
ifdef
SK_DEBUG
void
GrDrawOpAtlas
:
:
validate
(
const
AtlasLocator
&
atlasLocator
)
const
{
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
int
plotIndex
=
atlasLocator
.
plotIndex
(
)
;
auto
topLeft
=
atlasLocator
.
topLeft
(
)
;
int
plotX
=
topLeft
.
x
(
)
/
fPlotWidth
;
int
plotY
=
topLeft
.
y
(
)
/
fPlotHeight
;
SkASSERT
(
plotIndex
=
=
(
numPlotsY
-
plotY
-
1
)
*
numPlotsX
+
(
numPlotsX
-
plotX
-
1
)
)
;
}
#
endif
void
GrDrawOpAtlas
:
:
instantiate
(
GrOnFlushResourceProvider
*
onFlushResourceProvider
)
{
for
(
uint32_t
i
=
0
;
i
<
fNumActivePages
;
+
+
i
)
{
SkASSERT
(
fViews
[
i
]
.
proxy
(
)
&
&
fViews
[
i
]
.
proxy
(
)
-
>
isInstantiated
(
)
)
;
}
}
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
GrDrawOpAtlas
:
:
Make
(
GrProxyProvider
*
proxyProvider
const
GrBackendFormat
&
format
SkColorType
colorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
GenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
EvictionCallback
*
evictor
std
:
:
string_view
label
)
{
if
(
!
format
.
isValid
(
)
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
atlas
(
new
GrDrawOpAtlas
(
proxyProvider
format
colorType
bpp
width
height
plotWidth
plotHeight
generationCounter
allowMultitexturing
label
)
)
;
if
(
!
atlas
-
>
getViews
(
)
[
0
]
.
proxy
(
)
)
{
return
nullptr
;
}
if
(
evictor
!
=
nullptr
)
{
atlas
-
>
fEvictionCallbacks
.
emplace_back
(
evictor
)
;
}
return
atlas
;
}
GrDrawOpAtlas
:
:
GrDrawOpAtlas
(
GrProxyProvider
*
proxyProvider
const
GrBackendFormat
&
format
SkColorType
colorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
GenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
std
:
:
string_view
label
)
:
fFormat
(
format
)
fColorType
(
colorType
)
fBytesPerPixel
(
bpp
)
fTextureWidth
(
width
)
fTextureHeight
(
height
)
fPlotWidth
(
plotWidth
)
fPlotHeight
(
plotHeight
)
fLabel
(
label
)
fGenerationCounter
(
generationCounter
)
fAtlasGeneration
(
fGenerationCounter
-
>
next
(
)
)
fPrevFlushToken
(
AtlasToken
:
:
InvalidToken
(
)
)
fFlushesSinceLastUse
(
0
)
fMaxPages
(
AllowMultitexturing
:
:
kYes
=
=
allowMultitexturing
?
PlotLocator
:
:
kMaxMultitexturePages
:
1
)
fNumActivePages
(
0
)
{
int
numPlotsX
=
width
/
plotWidth
;
int
numPlotsY
=
height
/
plotHeight
;
SkASSERT
(
numPlotsX
*
numPlotsY
<
=
PlotLocator
:
:
kMaxPlots
)
;
SkASSERT
(
fPlotWidth
*
numPlotsX
=
=
fTextureWidth
)
;
SkASSERT
(
fPlotHeight
*
numPlotsY
=
=
fTextureHeight
)
;
fNumPlots
=
numPlotsX
*
numPlotsY
;
this
-
>
createPages
(
proxyProvider
generationCounter
)
;
}
inline
void
GrDrawOpAtlas
:
:
processEviction
(
PlotLocator
plotLocator
)
{
for
(
EvictionCallback
*
evictor
:
fEvictionCallbacks
)
{
evictor
-
>
evict
(
plotLocator
)
;
}
fAtlasGeneration
=
fGenerationCounter
-
>
next
(
)
;
}
void
GrDrawOpAtlas
:
:
uploadPlotToTexture
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
GrTextureProxy
*
proxy
Plot
*
plot
)
{
SkASSERT
(
proxy
&
&
proxy
-
>
peekTexture
(
)
)
;
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
const
void
*
dataPtr
;
SkIRect
rect
;
std
:
:
tie
(
dataPtr
rect
)
=
plot
-
>
prepareForUpload
(
false
)
;
writePixels
(
proxy
rect
SkColorTypeToGrColorType
(
fColorType
)
dataPtr
fBytesPerPixel
*
fPlotWidth
)
;
}
inline
bool
GrDrawOpAtlas
:
:
updatePlot
(
GrDeferredUploadTarget
*
target
AtlasLocator
*
atlasLocator
Plot
*
plot
)
{
int
pageIdx
=
plot
-
>
pageIndex
(
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
if
(
plot
-
>
lastUploadToken
(
)
<
target
-
>
tokenTracker
(
)
-
>
nextFlushToken
(
)
)
{
sk_sp
<
Plot
>
plotsp
(
SkRef
(
plot
)
)
;
GrTextureProxy
*
proxy
=
fViews
[
pageIdx
]
.
asTextureProxy
(
)
;
SkASSERT
(
proxy
&
&
proxy
-
>
isInstantiated
(
)
)
;
AtlasToken
lastUploadToken
=
target
-
>
addASAPUpload
(
[
this
plotsp
proxy
]
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
)
{
this
-
>
uploadPlotToTexture
(
writePixels
proxy
plotsp
.
get
(
)
)
;
}
)
;
plot
-
>
setLastUploadToken
(
lastUploadToken
)
;
}
atlasLocator
-
>
updatePlotLocator
(
plot
-
>
plotLocator
(
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
*
atlasLocator
)
;
)
return
true
;
}
bool
GrDrawOpAtlas
:
:
uploadToPage
(
unsigned
int
pageIdx
GrDeferredUploadTarget
*
target
int
width
int
height
const
void
*
image
AtlasLocator
*
atlasLocator
)
{
SkASSERT
(
fViews
[
pageIdx
]
.
proxy
(
)
&
&
fViews
[
pageIdx
]
.
proxy
(
)
-
>
isInstantiated
(
)
)
;
PlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPages
[
pageIdx
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
for
(
Plot
*
plot
=
plotIter
.
get
(
)
;
plot
;
plot
=
plotIter
.
next
(
)
)
{
SkASSERT
(
GrBackendFormatBytesPerPixel
(
fViews
[
pageIdx
]
.
proxy
(
)
-
>
backendFormat
(
)
)
=
=
plot
-
>
bpp
(
)
)
;
if
(
plot
-
>
addSubImage
(
width
height
image
atlasLocator
)
)
{
return
this
-
>
updatePlot
(
target
atlasLocator
plot
)
;
}
}
return
false
;
}
static
constexpr
auto
kPlotRecentlyUsedCount
=
32
;
static
constexpr
auto
kAtlasRecentlyUsedCount
=
128
;
GrDrawOpAtlas
:
:
ErrorCode
GrDrawOpAtlas
:
:
addToAtlas
(
GrResourceProvider
*
resourceProvider
GrDeferredUploadTarget
*
target
int
width
int
height
const
void
*
image
AtlasLocator
*
atlasLocator
)
{
if
(
width
>
fPlotWidth
|
|
height
>
fPlotHeight
)
{
return
ErrorCode
:
:
kError
;
}
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumActivePages
;
+
+
pageIdx
)
{
if
(
this
-
>
uploadToPage
(
pageIdx
target
width
height
image
atlasLocator
)
)
{
return
ErrorCode
:
:
kSucceeded
;
}
}
if
(
fNumActivePages
=
=
this
-
>
maxPages
(
)
)
{
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumActivePages
;
+
+
pageIdx
)
{
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotList
.
tail
(
)
;
SkASSERT
(
plot
)
;
if
(
plot
-
>
lastUseToken
(
)
<
target
-
>
tokenTracker
(
)
-
>
nextFlushToken
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
SkASSERT
(
GrBackendFormatBytesPerPixel
(
fViews
[
pageIdx
]
.
proxy
(
)
-
>
backendFormat
(
)
)
=
=
plot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
plot
-
>
addSubImage
(
width
height
image
atlasLocator
)
;
SkASSERT
(
verify
)
;
if
(
!
this
-
>
updatePlot
(
target
atlasLocator
plot
)
)
{
return
ErrorCode
:
:
kError
;
}
return
ErrorCode
:
:
kSucceeded
;
}
}
}
else
{
if
(
!
this
-
>
activateNewPage
(
resourceProvider
)
)
{
return
ErrorCode
:
:
kError
;
}
if
(
this
-
>
uploadToPage
(
fNumActivePages
-
1
target
width
height
image
atlasLocator
)
)
{
return
ErrorCode
:
:
kSucceeded
;
}
else
{
return
ErrorCode
:
:
kError
;
}
}
if
(
!
fNumActivePages
)
{
return
ErrorCode
:
:
kError
;
}
Plot
*
plot
=
nullptr
;
for
(
int
pageIdx
=
(
(
int
)
fNumActivePages
)
-
1
;
pageIdx
>
=
0
;
-
-
pageIdx
)
{
Plot
*
currentPlot
=
fPages
[
pageIdx
]
.
fPlotList
.
tail
(
)
;
if
(
currentPlot
-
>
lastUseToken
(
)
!
=
target
-
>
tokenTracker
(
)
-
>
nextDrawToken
(
)
)
{
plot
=
currentPlot
;
break
;
}
}
if
(
!
plot
)
{
return
ErrorCode
:
:
kTryAgain
;
}
this
-
>
processEviction
(
plot
-
>
plotLocator
(
)
)
;
int
pageIdx
=
plot
-
>
pageIndex
(
)
;
fPages
[
pageIdx
]
.
fPlotList
.
remove
(
plot
)
;
sk_sp
<
Plot
>
&
newPlot
=
fPages
[
pageIdx
]
.
fPlotArray
[
plot
-
>
plotIndex
(
)
]
;
newPlot
=
plot
-
>
clone
(
)
;
fPages
[
pageIdx
]
.
fPlotList
.
addToHead
(
newPlot
.
get
(
)
)
;
SkASSERT
(
GrBackendFormatBytesPerPixel
(
fViews
[
pageIdx
]
.
proxy
(
)
-
>
backendFormat
(
)
)
=
=
newPlot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
newPlot
-
>
addSubImage
(
width
height
image
atlasLocator
)
;
SkASSERT
(
verify
)
;
sk_sp
<
Plot
>
plotsp
(
SkRef
(
newPlot
.
get
(
)
)
)
;
GrTextureProxy
*
proxy
=
fViews
[
pageIdx
]
.
asTextureProxy
(
)
;
SkASSERT
(
proxy
&
&
proxy
-
>
isInstantiated
(
)
)
;
AtlasToken
lastUploadToken
=
target
-
>
addInlineUpload
(
[
this
plotsp
proxy
]
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
)
{
this
-
>
uploadPlotToTexture
(
writePixels
proxy
plotsp
.
get
(
)
)
;
}
)
;
newPlot
-
>
setLastUploadToken
(
lastUploadToken
)
;
atlasLocator
-
>
updatePlotLocator
(
newPlot
-
>
plotLocator
(
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
*
atlasLocator
)
;
)
return
ErrorCode
:
:
kSucceeded
;
}
void
GrDrawOpAtlas
:
:
compact
(
AtlasToken
startTokenForNextFlush
)
{
if
(
fNumActivePages
<
1
)
{
fPrevFlushToken
=
startTokenForNextFlush
;
return
;
}
PlotList
:
:
Iter
plotIter
;
bool
atlasUsedThisFlush
=
false
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
fNumActivePages
;
+
+
pageIndex
)
{
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
resetFlushesSinceLastUsed
(
)
;
atlasUsedThisFlush
=
true
;
}
plotIter
.
next
(
)
;
}
}
if
(
atlasUsedThisFlush
)
{
fFlushesSinceLastUse
=
0
;
}
else
{
+
+
fFlushesSinceLastUse
;
}
if
(
atlasUsedThisFlush
|
|
fFlushesSinceLastUse
>
kAtlasRecentlyUsedCount
)
{
SkTArray
<
Plot
*
>
availablePlots
;
uint32_t
lastPageIndex
=
fNumActivePages
-
1
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
lastPageIndex
;
+
+
pageIndex
)
{
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
pageIndex
)
;
}
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
if
(
plot
-
>
flushesSinceLastUsed
(
)
>
kPlotRecentlyUsedCount
)
{
availablePlots
.
push_back
(
)
=
plot
;
}
plotIter
.
next
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
}
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
unsigned
int
usedPlots
=
0
;
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
lastPageIndex
)
;
}
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kPlotRecentlyUsedCount
)
{
usedPlots
+
+
;
}
else
if
(
plot
-
>
lastUseToken
(
)
!
=
AtlasToken
:
:
InvalidToken
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
}
plotIter
.
next
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
if
(
availablePlots
.
size
(
)
&
&
usedPlots
&
&
usedPlots
<
=
fNumPlots
/
4
)
{
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kPlotRecentlyUsedCount
)
{
if
(
availablePlots
.
size
(
)
>
0
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
this
-
>
processEvictionAndResetRects
(
availablePlots
.
back
(
)
)
;
availablePlots
.
pop_back
(
)
;
-
-
usedPlots
;
}
if
(
!
usedPlots
|
|
!
availablePlots
.
size
(
)
)
{
break
;
}
}
plotIter
.
next
(
)
;
}
}
if
(
!
usedPlots
)
{
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
delete
%
d
\
n
"
fNumActivePages
-
1
)
;
}
this
-
>
deactivateLastPage
(
)
;
fFlushesSinceLastUse
=
0
;
}
}
fPrevFlushToken
=
startTokenForNextFlush
;
}
bool
GrDrawOpAtlas
:
:
createPages
(
GrProxyProvider
*
proxyProvider
GenerationCounter
*
generationCounter
)
{
SkASSERT
(
SkIsPow2
(
fTextureWidth
)
&
&
SkIsPow2
(
fTextureHeight
)
)
;
SkISize
dims
=
{
fTextureWidth
fTextureHeight
}
;
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
GrColorType
grColorType
=
SkColorTypeToGrColorType
(
fColorType
)
;
for
(
uint32_t
i
=
0
;
i
<
this
-
>
maxPages
(
)
;
+
+
i
)
{
skgpu
:
:
Swizzle
swizzle
=
proxyProvider
-
>
caps
(
)
-
>
getReadSwizzle
(
fFormat
grColorType
)
;
if
(
GrColorTypeIsAlphaOnly
(
grColorType
)
)
{
swizzle
=
skgpu
:
:
Swizzle
:
:
Concat
(
swizzle
skgpu
:
:
Swizzle
(
"
aaaa
"
)
)
;
}
sk_sp
<
GrSurfaceProxy
>
proxy
=
proxyProvider
-
>
createProxy
(
fFormat
dims
GrRenderable
:
:
kNo
1
GrMipmapped
:
:
kNo
SkBackingFit
:
:
kExact
skgpu
:
:
Budgeted
:
:
kYes
GrProtected
:
:
kNo
fLabel
GrInternalSurfaceFlags
:
:
kNone
GrSurfaceProxy
:
:
UseAllocator
:
:
kNo
)
;
if
(
!
proxy
)
{
return
false
;
}
fViews
[
i
]
=
GrSurfaceProxyView
(
std
:
:
move
(
proxy
)
kTopLeft_GrSurfaceOrigin
swizzle
)
;
fPages
[
i
]
.
fPlotArray
=
std
:
:
make_unique
<
sk_sp
<
Plot
>
[
]
>
(
numPlotsX
*
numPlotsY
)
;
sk_sp
<
Plot
>
*
currPlot
=
fPages
[
i
]
.
fPlotArray
.
get
(
)
;
for
(
int
y
=
numPlotsY
-
1
r
=
0
;
y
>
=
0
;
-
-
y
+
+
r
)
{
for
(
int
x
=
numPlotsX
-
1
c
=
0
;
x
>
=
0
;
-
-
x
+
+
c
)
{
uint32_t
plotIndex
=
r
*
numPlotsX
+
c
;
currPlot
-
>
reset
(
new
Plot
(
i
plotIndex
generationCounter
x
y
fPlotWidth
fPlotHeight
fColorType
fBytesPerPixel
)
)
;
fPages
[
i
]
.
fPlotList
.
addToHead
(
currPlot
-
>
get
(
)
)
;
+
+
currPlot
;
}
}
}
return
true
;
}
bool
GrDrawOpAtlas
:
:
activateNewPage
(
GrResourceProvider
*
resourceProvider
)
{
SkASSERT
(
fNumActivePages
<
this
-
>
maxPages
(
)
)
;
if
(
!
fViews
[
fNumActivePages
]
.
proxy
(
)
-
>
instantiate
(
resourceProvider
)
)
{
return
false
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
activated
page
#
:
%
d
\
n
"
fNumActivePages
)
;
}
+
+
fNumActivePages
;
return
true
;
}
inline
void
GrDrawOpAtlas
:
:
deactivateLastPage
(
)
{
SkASSERT
(
fNumActivePages
)
;
uint32_t
lastPageIndex
=
fNumActivePages
-
1
;
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
fPages
[
lastPageIndex
]
.
fPlotList
.
reset
(
)
;
for
(
int
r
=
0
;
r
<
numPlotsY
;
+
+
r
)
{
for
(
int
c
=
0
;
c
<
numPlotsX
;
+
+
c
)
{
uint32_t
plotIndex
=
r
*
numPlotsX
+
c
;
Plot
*
currPlot
=
fPages
[
lastPageIndex
]
.
fPlotArray
[
plotIndex
]
.
get
(
)
;
currPlot
-
>
resetRects
(
)
;
currPlot
-
>
resetFlushesSinceLastUsed
(
)
;
SkDEBUGCODE
(
currPlot
-
>
resetListPtrs
(
)
)
;
fPages
[
lastPageIndex
]
.
fPlotList
.
addToHead
(
currPlot
)
;
}
}
fViews
[
lastPageIndex
]
.
proxy
(
)
-
>
deinstantiate
(
)
;
-
-
fNumActivePages
;
}
GrDrawOpAtlasConfig
:
:
GrDrawOpAtlasConfig
(
int
maxTextureSize
size_t
maxBytes
)
{
static
const
SkISize
kARGBDimensions
[
]
=
{
{
256
256
}
{
512
256
}
{
512
512
}
{
1024
512
}
{
1024
1024
}
{
2048
1024
}
}
;
maxBytes
>
>
=
18
;
int
index
=
maxBytes
>
0
?
SkTPin
<
int
>
(
SkPrevLog2
(
maxBytes
)
0
std
:
:
size
(
kARGBDimensions
)
-
1
)
:
0
;
SkASSERT
(
kARGBDimensions
[
index
]
.
width
(
)
<
=
kMaxAtlasDim
)
;
SkASSERT
(
kARGBDimensions
[
index
]
.
height
(
)
<
=
kMaxAtlasDim
)
;
fARGBDimensions
.
set
(
std
:
:
min
<
int
>
(
kARGBDimensions
[
index
]
.
width
(
)
maxTextureSize
)
std
:
:
min
<
int
>
(
kARGBDimensions
[
index
]
.
height
(
)
maxTextureSize
)
)
;
fMaxTextureSize
=
std
:
:
min
<
int
>
(
maxTextureSize
kMaxAtlasDim
)
;
}
SkISize
GrDrawOpAtlasConfig
:
:
atlasDimensions
(
MaskFormat
type
)
const
{
if
(
MaskFormat
:
:
kA8
=
=
type
)
{
return
{
std
:
:
min
<
int
>
(
2
*
fARGBDimensions
.
width
(
)
fMaxTextureSize
)
std
:
:
min
<
int
>
(
2
*
fARGBDimensions
.
height
(
)
fMaxTextureSize
)
}
;
}
else
{
return
fARGBDimensions
;
}
}
SkISize
GrDrawOpAtlasConfig
:
:
plotDimensions
(
MaskFormat
type
)
const
{
if
(
MaskFormat
:
:
kA8
=
=
type
)
{
SkISize
atlasDimensions
=
this
-
>
atlasDimensions
(
type
)
;
int
plotWidth
=
atlasDimensions
.
width
(
)
>
=
2048
?
512
:
256
;
int
plotHeight
=
atlasDimensions
.
height
(
)
>
=
2048
?
512
:
256
;
return
{
plotWidth
plotHeight
}
;
}
else
{
return
{
256
256
}
;
}
}
