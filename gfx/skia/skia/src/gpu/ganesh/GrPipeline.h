#
ifndef
GrPipeline_DEFINED
#
define
GrPipeline_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDstProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessorSet
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrScissorState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrUserStencilSettings
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrWindowRectsState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrPorterDuffXferProcessor
.
h
"
class
GrAppliedClip
;
class
GrAppliedHardClip
;
struct
GrGLSLBuiltinUniformHandles
;
class
GrGLSLProgramDataManager
;
class
GrOp
;
class
GrTextureEffect
;
class
GrPipeline
{
public
:
enum
class
InputFlags
:
uint8_t
{
kNone
=
0
kConservativeRaster
=
(
1
<
<
1
)
kWireframe
=
(
1
<
<
2
)
kSnapVerticesToPixelCenters
=
(
1
<
<
3
)
}
;
struct
InitArgs
{
InputFlags
fInputFlags
=
InputFlags
:
:
kNone
;
const
GrCaps
*
fCaps
=
nullptr
;
GrDstProxyView
fDstProxyView
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
}
;
GrPipeline
(
GrScissorTest
scissor
SkBlendMode
blend
const
skgpu
:
:
Swizzle
&
writeSwizzle
InputFlags
flags
=
InputFlags
:
:
kNone
)
:
GrPipeline
(
scissor
GrPorterDuffXPFactory
:
:
MakeNoCoverageXP
(
blend
)
writeSwizzle
flags
)
{
}
GrPipeline
(
GrScissorTest
sk_sp
<
const
GrXferProcessor
>
const
skgpu
:
:
Swizzle
&
writeSwizzle
InputFlags
=
InputFlags
:
:
kNone
)
;
GrPipeline
(
const
InitArgs
&
args
sk_sp
<
const
GrXferProcessor
>
const
GrAppliedHardClip
&
)
;
GrPipeline
(
const
InitArgs
&
GrProcessorSet
&
&
GrAppliedClip
&
&
)
;
GrPipeline
(
const
GrPipeline
&
)
=
delete
;
GrPipeline
&
operator
=
(
const
GrPipeline
&
)
=
delete
;
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
;
}
int
numColorFragmentProcessors
(
)
const
{
return
fNumColorProcessors
;
}
bool
isColorFragmentProcessor
(
int
idx
)
const
{
return
idx
<
fNumColorProcessors
;
}
bool
isCoverageFragmentProcessor
(
int
idx
)
const
{
return
idx
>
=
fNumColorProcessors
;
}
bool
usesLocalCoords
(
)
const
{
for
(
const
auto
&
fp
:
fFragmentProcessors
)
{
if
(
fp
-
>
usesSampleCoords
(
)
)
{
return
true
;
}
}
return
false
;
}
void
visitTextureEffects
(
const
std
:
:
function
<
void
(
const
GrTextureEffect
&
)
>
&
)
const
;
const
GrXferProcessor
&
getXferProcessor
(
)
const
{
if
(
fXferProcessor
)
{
return
*
fXferProcessor
;
}
else
{
return
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
;
}
}
bool
usesDstTexture
(
)
const
{
return
this
-
>
dstProxyView
(
)
&
&
!
this
-
>
usesDstInputAttachment
(
)
;
}
bool
usesDstInputAttachment
(
)
const
{
return
this
-
>
dstSampleFlags
(
)
&
GrDstSampleFlags
:
:
kAsInputAttachment
;
}
const
GrSurfaceProxyView
&
dstProxyView
(
)
const
{
return
fDstProxy
.
proxyView
(
)
;
}
SkIPoint
dstTextureOffset
(
)
const
{
return
fDstProxy
.
offset
(
)
;
}
GrDstSampleFlags
dstSampleFlags
(
)
const
{
return
fDstProxy
.
dstSampleFlags
(
)
;
}
GrTexture
*
peekDstTexture
(
)
const
{
if
(
!
this
-
>
usesDstTexture
(
)
)
{
return
nullptr
;
}
if
(
GrTextureProxy
*
dstProxy
=
this
-
>
dstProxyView
(
)
.
asTextureProxy
(
)
)
{
return
dstProxy
-
>
peekTexture
(
)
;
}
return
nullptr
;
}
const
GrFragmentProcessor
&
getFragmentProcessor
(
int
idx
)
const
{
return
*
fFragmentProcessors
[
idx
]
;
}
bool
isScissorTestEnabled
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kScissorTestEnabled
)
;
}
const
GrWindowRectsState
&
getWindowRectsState
(
)
const
{
return
fWindowRectsState
;
}
bool
usesConservativeRaster
(
)
const
{
return
fFlags
&
InputFlags
:
:
kConservativeRaster
;
}
bool
isWireframe
(
)
const
{
return
fFlags
&
InputFlags
:
:
kWireframe
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
fFlags
&
InputFlags
:
:
kSnapVerticesToPixelCenters
;
}
bool
hasStencilClip
(
)
const
{
return
SkToBool
(
fFlags
&
Flags
:
:
kHasStencilClip
)
;
}
#
ifdef
SK_DEBUG
bool
allProxiesInstantiated
(
)
const
{
for
(
int
i
=
0
;
i
<
fFragmentProcessors
.
count
(
)
;
+
+
i
)
{
if
(
!
fFragmentProcessors
[
i
]
-
>
isInstantiated
(
)
)
{
return
false
;
}
}
if
(
this
-
>
dstProxyView
(
)
.
proxy
(
)
)
{
return
this
-
>
dstProxyView
(
)
.
proxy
(
)
-
>
isInstantiated
(
)
;
}
return
true
;
}
#
endif
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
)
const
;
void
genKey
(
skgpu
:
:
KeyBuilder
*
const
GrCaps
&
)
const
;
const
skgpu
:
:
Swizzle
&
writeSwizzle
(
)
const
{
return
fWriteSwizzle
;
}
void
visitProxies
(
const
GrVisitProxyFunc
&
)
const
;
void
setDstTextureUniforms
(
const
GrGLSLProgramDataManager
&
pdm
GrGLSLBuiltinUniformHandles
*
fBuiltinUniformHandles
)
const
;
private
:
inline
static
constexpr
uint8_t
kLastInputFlag
=
(
uint8_t
)
InputFlags
:
:
kSnapVerticesToPixelCenters
;
enum
class
Flags
:
uint8_t
{
kHasStencilClip
=
(
kLastInputFlag
<
<
1
)
kScissorTestEnabled
=
(
kLastInputFlag
<
<
2
)
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
Flags
)
;
friend
bool
operator
&
(
Flags
InputFlags
)
;
using
FragmentProcessorArray
=
skia_private
:
:
AutoSTArray
<
3
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
>
;
GrDstProxyView
fDstProxy
;
GrWindowRectsState
fWindowRectsState
;
Flags
fFlags
;
sk_sp
<
const
GrXferProcessor
>
fXferProcessor
;
FragmentProcessorArray
fFragmentProcessors
;
int
fNumColorProcessors
=
0
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrPipeline
:
:
InputFlags
)
GR_MAKE_BITFIELD_CLASS_OPS
(
GrPipeline
:
:
Flags
)
inline
bool
operator
&
(
GrPipeline
:
:
Flags
flags
GrPipeline
:
:
InputFlags
inputFlag
)
{
return
(
flags
&
(
GrPipeline
:
:
Flags
)
inputFlag
)
;
}
#
endif
