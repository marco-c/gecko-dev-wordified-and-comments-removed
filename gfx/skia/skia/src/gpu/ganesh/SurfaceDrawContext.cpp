#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkDrawable
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
core
/
SkVertices
.
h
"
#
include
"
include
/
gpu
/
GrBackendSemaphore
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
SkShadowFlags
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrImageContext
.
h
"
#
include
"
include
/
utils
/
SkShadowUtils
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkAutoPixmapStorage
.
h
"
#
include
"
src
/
core
/
SkBlendModePriv
.
h
"
#
include
"
src
/
core
/
SkConvertPixels
.
h
"
#
include
"
src
/
core
/
SkDrawProcs
.
h
"
#
include
"
src
/
core
/
SkDrawShadowInfo
.
h
"
#
include
"
src
/
core
/
SkLatticeIter
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkMeshPriv
.
h
"
#
include
"
src
/
core
/
SkPointPriv
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
core
/
SkStrikeCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAttachment
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColorSpaceXform
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDataUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDrawingManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrImageContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrImageInfo
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSemaphore
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStencilSettings
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTracing
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
PathRenderer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBicubicEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBlendFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrDisableColorXP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
ClearOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
DrawAtlasOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
DrawMeshOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
DrawableOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
FillRRectOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
FillRectOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrDrawOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrOvalOpFactory
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
LatticeOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
RegionOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
ShadowRRectOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
StrokeRectOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
TextureOp
.
h
"
#
include
"
src
/
text
/
gpu
/
SDFTControl
.
h
"
#
include
"
src
/
text
/
gpu
/
TextBlobRedrawCoordinator
.
h
"
#
define
ASSERT_OWNED_RESOURCE
(
R
)
SkASSERT
(
!
(
R
)
|
|
(
R
)
-
>
getContext
(
)
=
=
this
-
>
drawingManager
(
)
-
>
getContext
(
)
)
#
define
ASSERT_SINGLE_OWNER
SKGPU_ASSERT_SINGLE_OWNER
(
this
-
>
singleOwner
(
)
)
#
define
RETURN_IF_ABANDONED
if
(
fContext
-
>
abandoned
(
)
)
{
return
;
}
#
define
RETURN_FALSE_IF_ABANDONED
if
(
fContext
-
>
abandoned
(
)
)
{
return
false
;
}
namespace
{
void
op_bounds
(
SkRect
*
bounds
const
GrOp
*
op
)
{
*
bounds
=
op
-
>
bounds
(
)
;
if
(
op
-
>
hasZeroArea
(
)
)
{
if
(
op
-
>
hasAABloat
(
)
)
{
bounds
-
>
outset
(
0
.
5f
0
.
5f
)
;
}
else
{
SkRect
before
=
*
bounds
;
bounds
-
>
roundOut
(
bounds
)
;
if
(
bounds
-
>
fLeft
=
=
before
.
fLeft
)
{
bounds
-
>
fLeft
-
=
1
;
}
if
(
bounds
-
>
fTop
=
=
before
.
fTop
)
{
bounds
-
>
fTop
-
=
1
;
}
if
(
bounds
-
>
fRight
=
=
before
.
fRight
)
{
bounds
-
>
fRight
+
=
1
;
}
if
(
bounds
-
>
fBottom
=
=
before
.
fBottom
)
{
bounds
-
>
fBottom
+
=
1
;
}
}
}
}
}
namespace
skgpu
:
:
ganesh
{
using
DoSimplify
=
GrStyledShape
:
:
DoSimplify
;
class
AutoCheckFlush
{
public
:
AutoCheckFlush
(
GrDrawingManager
*
drawingManager
)
:
fDrawingManager
(
drawingManager
)
{
SkASSERT
(
fDrawingManager
)
;
}
~
AutoCheckFlush
(
)
{
fDrawingManager
-
>
flushIfNecessary
(
)
;
}
private
:
GrDrawingManager
*
fDrawingManager
;
}
;
std
:
:
unique_ptr
<
SurfaceDrawContext
>
SurfaceDrawContext
:
:
Make
(
GrRecordingContext
*
rContext
GrColorType
colorType
sk_sp
<
GrSurfaceProxy
>
proxy
sk_sp
<
SkColorSpace
>
colorSpace
GrSurfaceOrigin
origin
const
SkSurfaceProps
&
surfaceProps
)
{
if
(
!
rContext
|
|
!
proxy
|
|
colorType
=
=
GrColorType
:
:
kUnknown
)
{
return
nullptr
;
}
const
GrBackendFormat
&
format
=
proxy
-
>
backendFormat
(
)
;
skgpu
:
:
Swizzle
readSwizzle
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
getReadSwizzle
(
format
colorType
)
;
skgpu
:
:
Swizzle
writeSwizzle
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
getWriteSwizzle
(
format
colorType
)
;
GrSurfaceProxyView
readView
(
proxy
origin
readSwizzle
)
;
GrSurfaceProxyView
writeView
(
std
:
:
move
(
proxy
)
origin
writeSwizzle
)
;
return
std
:
:
make_unique
<
SurfaceDrawContext
>
(
rContext
std
:
:
move
(
readView
)
std
:
:
move
(
writeView
)
colorType
std
:
:
move
(
colorSpace
)
surfaceProps
)
;
}
std
:
:
unique_ptr
<
SurfaceDrawContext
>
SurfaceDrawContext
:
:
Make
(
GrRecordingContext
*
rContext
sk_sp
<
SkColorSpace
>
colorSpace
SkBackingFit
fit
SkISize
dimensions
const
GrBackendFormat
&
format
int
sampleCnt
GrMipmapped
mipmapped
GrProtected
isProtected
skgpu
:
:
Swizzle
readSwizzle
skgpu
:
:
Swizzle
writeSwizzle
GrSurfaceOrigin
origin
skgpu
:
:
Budgeted
budgeted
const
SkSurfaceProps
&
surfaceProps
std
:
:
string_view
label
)
{
if
(
rContext
-
>
abandoned
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
proxy
=
rContext
-
>
priv
(
)
.
proxyProvider
(
)
-
>
createProxy
(
format
dimensions
GrRenderable
:
:
kYes
sampleCnt
mipmapped
fit
budgeted
isProtected
label
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
GrSurfaceProxyView
readView
(
proxy
origin
readSwizzle
)
;
GrSurfaceProxyView
writeView
(
std
:
:
move
(
proxy
)
origin
writeSwizzle
)
;
auto
sdc
=
std
:
:
make_unique
<
SurfaceDrawContext
>
(
rContext
std
:
:
move
(
readView
)
std
:
:
move
(
writeView
)
GrColorType
:
:
kUnknown
std
:
:
move
(
colorSpace
)
surfaceProps
)
;
sdc
-
>
discard
(
)
;
return
sdc
;
}
std
:
:
unique_ptr
<
SurfaceDrawContext
>
SurfaceDrawContext
:
:
Make
(
GrRecordingContext
*
rContext
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
SkBackingFit
fit
SkISize
dimensions
const
SkSurfaceProps
&
surfaceProps
std
:
:
string_view
label
int
sampleCnt
GrMipmapped
mipmapped
GrProtected
isProtected
GrSurfaceOrigin
origin
skgpu
:
:
Budgeted
budgeted
)
{
if
(
!
rContext
)
{
return
nullptr
;
}
auto
format
=
rContext
-
>
priv
(
)
.
caps
(
)
-
>
getDefaultBackendFormat
(
colorType
GrRenderable
:
:
kYes
)
;
if
(
!
format
.
isValid
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
proxy
=
rContext
-
>
priv
(
)
.
proxyProvider
(
)
-
>
createProxy
(
format
dimensions
GrRenderable
:
:
kYes
sampleCnt
mipmapped
fit
budgeted
isProtected
label
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
return
SurfaceDrawContext
:
:
Make
(
rContext
colorType
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpace
)
origin
surfaceProps
)
;
}
std
:
:
unique_ptr
<
SurfaceDrawContext
>
SurfaceDrawContext
:
:
MakeWithFallback
(
GrRecordingContext
*
rContext
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
SkBackingFit
fit
SkISize
dimensions
const
SkSurfaceProps
&
surfaceProps
int
sampleCnt
GrMipmapped
mipmapped
GrProtected
isProtected
GrSurfaceOrigin
origin
skgpu
:
:
Budgeted
budgeted
)
{
const
GrCaps
*
caps
=
rContext
-
>
priv
(
)
.
caps
(
)
;
auto
[
ct
_
]
=
caps
-
>
getFallbackColorTypeAndFormat
(
colorType
sampleCnt
)
;
if
(
ct
=
=
GrColorType
:
:
kUnknown
)
{
return
nullptr
;
}
return
SurfaceDrawContext
:
:
Make
(
rContext
ct
colorSpace
fit
dimensions
surfaceProps
"
MakeSurfaceDrawContextWithFallback
"
sampleCnt
mipmapped
isProtected
origin
budgeted
)
;
}
std
:
:
unique_ptr
<
SurfaceDrawContext
>
SurfaceDrawContext
:
:
MakeFromBackendTexture
(
GrRecordingContext
*
rContext
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
GrBackendTexture
&
tex
int
sampleCnt
GrSurfaceOrigin
origin
const
SkSurfaceProps
&
surfaceProps
sk_sp
<
skgpu
:
:
RefCntedCallback
>
releaseHelper
)
{
SkASSERT
(
sampleCnt
>
0
)
;
sk_sp
<
GrTextureProxy
>
proxy
(
rContext
-
>
priv
(
)
.
proxyProvider
(
)
-
>
wrapRenderableBackendTexture
(
tex
sampleCnt
kBorrow_GrWrapOwnership
GrWrapCacheable
:
:
kNo
std
:
:
move
(
releaseHelper
)
)
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
return
SurfaceDrawContext
:
:
Make
(
rContext
colorType
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpace
)
origin
surfaceProps
)
;
}
SurfaceDrawContext
:
:
SurfaceDrawContext
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
readView
GrSurfaceProxyView
writeView
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
&
surfaceProps
)
:
SurfaceFillContext
(
rContext
std
:
:
move
(
readView
)
std
:
:
move
(
writeView
)
{
colorType
kPremul_SkAlphaType
std
:
:
move
(
colorSpace
)
}
)
fSurfaceProps
(
surfaceProps
)
fCanUseDynamicMSAA
(
(
fSurfaceProps
.
flags
(
)
&
SkSurfaceProps
:
:
kDynamicMSAA_Flag
)
&
&
rContext
-
>
priv
(
)
.
caps
(
)
-
>
supportsDynamicMSAA
(
this
-
>
asRenderTargetProxy
(
)
)
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SurfaceDrawContext
:
:
~
SurfaceDrawContext
(
)
{
ASSERT_SINGLE_OWNER
}
void
SurfaceDrawContext
:
:
willReplaceOpsTask
(
OpsTask
*
prevTask
OpsTask
*
nextTask
)
{
if
(
prevTask
&
&
fNeedsStencil
)
{
prevTask
-
>
setMustPreserveStencil
(
)
;
nextTask
-
>
setInitialStencilContent
(
OpsTask
:
:
StencilContent
:
:
kPreserved
)
;
}
#
if
GR_GPU_STATS
&
&
GR_TEST_UTILS
if
(
fCanUseDynamicMSAA
)
{
fContext
-
>
priv
(
)
.
dmsaaStats
(
)
.
fNumRenderPasses
+
+
;
}
#
endif
}
void
SurfaceDrawContext
:
:
drawGlyphRunList
(
SkCanvas
*
canvas
const
GrClip
*
clip
const
SkMatrixProvider
&
viewMatrix
const
sktext
:
:
GlyphRunList
&
glyphRunList
SkStrikeDeviceInfo
strikeDeviceInfo
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawGlyphRunList
"
fContext
)
;
if
(
this
-
>
wrapsVkSecondaryCB
(
)
)
{
return
;
}
sktext
:
:
gpu
:
:
TextBlobRedrawCoordinator
*
textBlobCache
=
fContext
-
>
priv
(
)
.
getTextBlobCache
(
)
;
textBlobCache
-
>
drawGlyphRunList
(
canvas
clip
viewMatrix
glyphRunList
paint
strikeDeviceInfo
this
)
;
}
void
SurfaceDrawContext
:
:
drawPaint
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
)
{
if
(
!
paint
.
numTotalFragmentProcessors
(
)
)
{
SkRect
r
=
this
-
>
asSurfaceProxy
(
)
-
>
getBoundsRect
(
)
;
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
r
)
;
}
else
{
SkMatrix
localMatrix
;
if
(
!
viewMatrix
.
invert
(
&
localMatrix
)
)
{
return
;
}
SkIRect
bounds
=
SkIRect
:
:
MakeSize
(
this
-
>
asSurfaceProxy
(
)
-
>
dimensions
(
)
)
;
this
-
>
fillPixelsWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
bounds
localMatrix
)
;
}
}
enum
class
SurfaceDrawContext
:
:
QuadOptimization
{
kDiscarded
kSubmitted
kClipApplied
kCropped
}
;
SurfaceDrawContext
:
:
QuadOptimization
SurfaceDrawContext
:
:
attemptQuadOptimization
(
const
GrClip
*
clip
const
GrUserStencilSettings
*
stencilSettings
DrawQuad
*
quad
GrPaint
*
paint
)
{
const
SkPMColor4f
*
constColor
=
nullptr
;
SkPMColor4f
paintColor
;
if
(
!
stencilSettings
&
&
paint
&
&
!
paint
-
>
hasCoverageFragmentProcessor
(
)
&
&
paint
-
>
isConstantBlendedColor
(
&
paintColor
)
)
{
constColor
=
&
paintColor
;
}
GrQuadAAFlags
oldFlags
=
quad
-
>
fEdgeFlags
;
SkRect
rtRect
=
this
-
>
asSurfaceProxy
(
)
-
>
getBoundsRect
(
)
;
SkRect
drawBounds
=
quad
-
>
fDevice
.
bounds
(
)
;
if
(
!
quad
-
>
fDevice
.
isFinite
(
)
|
|
drawBounds
.
isEmpty
(
)
|
|
GrClip
:
:
IsOutsideClip
(
SkIRect
:
:
MakeSize
(
this
-
>
dimensions
(
)
)
drawBounds
GrAA
:
:
kYes
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
else
if
(
GrQuadUtils
:
:
WillUseHairline
(
quad
-
>
fDevice
GrAAType
:
:
kCoverage
quad
-
>
fEdgeFlags
)
)
{
return
QuadOptimization
:
:
kCropped
;
}
GrAA
drawUsesAA
{
quad
-
>
fEdgeFlags
!
=
GrQuadAAFlags
:
:
kNone
}
;
auto
conservativeCrop
=
[
&
]
(
)
{
static
constexpr
int
kLargeDrawLimit
=
15000
;
if
(
drawBounds
.
width
(
)
>
kLargeDrawLimit
|
|
drawBounds
.
height
(
)
>
kLargeDrawLimit
)
{
GrQuadUtils
:
:
CropToRect
(
rtRect
drawUsesAA
quad
!
constColor
)
;
}
}
;
bool
simpleColor
=
!
stencilSettings
&
&
constColor
;
GrClip
:
:
PreClipResult
result
=
clip
?
clip
-
>
preApply
(
drawBounds
drawUsesAA
)
:
GrClip
:
:
PreClipResult
(
GrClip
:
:
Effect
:
:
kUnclipped
)
;
switch
(
result
.
fEffect
)
{
case
GrClip
:
:
Effect
:
:
kClippedOut
:
return
QuadOptimization
:
:
kDiscarded
;
case
GrClip
:
:
Effect
:
:
kUnclipped
:
if
(
!
simpleColor
)
{
conservativeCrop
(
)
;
return
QuadOptimization
:
:
kClipApplied
;
}
else
{
result
=
GrClip
:
:
PreClipResult
(
SkRRect
:
:
MakeRect
(
rtRect
)
drawUsesAA
)
;
}
break
;
case
GrClip
:
:
Effect
:
:
kClipped
:
if
(
!
result
.
fIsRRect
|
|
(
stencilSettings
&
&
result
.
fAA
!
=
drawUsesAA
)
|
|
(
!
result
.
fRRect
.
isRect
(
)
&
&
!
simpleColor
)
)
{
conservativeCrop
(
)
;
return
QuadOptimization
:
:
kCropped
;
}
break
;
default
:
SkUNREACHABLE
;
}
SkASSERT
(
result
.
fEffect
=
=
GrClip
:
:
Effect
:
:
kClipped
&
&
result
.
fIsRRect
)
;
SkRect
clippedBounds
=
result
.
fRRect
.
getBounds
(
)
;
clippedBounds
.
intersect
(
rtRect
)
;
if
(
!
drawBounds
.
intersect
(
clippedBounds
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
if
(
drawBounds
.
width
(
)
<
1
.
f
|
|
drawBounds
.
height
(
)
<
1
.
f
)
{
return
QuadOptimization
:
:
kCropped
;
}
if
(
result
.
fRRect
.
isRect
(
)
)
{
if
(
GrQuadUtils
:
:
CropToRect
(
clippedBounds
result
.
fAA
quad
!
constColor
)
)
{
if
(
simpleColor
&
&
quad
-
>
fDevice
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
)
{
drawBounds
=
quad
-
>
fDevice
.
bounds
(
)
;
if
(
drawBounds
.
contains
(
rtRect
)
)
{
this
-
>
clear
(
*
constColor
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
else
if
(
GrClip
:
:
IsPixelAligned
(
drawBounds
)
&
&
drawBounds
.
width
(
)
>
256
&
&
drawBounds
.
height
(
)
>
256
)
{
SkIRect
scissorRect
;
drawBounds
.
round
(
&
scissorRect
)
;
this
-
>
clear
(
scissorRect
*
constColor
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
}
return
QuadOptimization
:
:
kClipApplied
;
}
}
else
{
SkASSERT
(
simpleColor
)
;
if
(
GrQuadUtils
:
:
CropToRect
(
clippedBounds
result
.
fAA
quad
false
)
&
&
quad
-
>
fDevice
.
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
&
&
quad
-
>
fDevice
.
bounds
(
)
.
contains
(
clippedBounds
)
)
{
this
-
>
drawRRect
(
nullptr
std
:
:
move
(
*
paint
)
result
.
fAA
SkMatrix
:
:
I
(
)
result
.
fRRect
GrStyle
:
:
SimpleFill
(
)
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
}
quad
-
>
fEdgeFlags
=
oldFlags
;
return
QuadOptimization
:
:
kCropped
;
}
void
SurfaceDrawContext
:
:
drawFilledQuad
(
const
GrClip
*
clip
GrPaint
&
&
paint
DrawQuad
*
quad
const
GrUserStencilSettings
*
ss
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawFilledQuad
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
QuadOptimization
opt
=
this
-
>
attemptQuadOptimization
(
clip
ss
quad
&
paint
)
;
if
(
opt
>
=
QuadOptimization
:
:
kClipApplied
)
{
const
GrClip
*
finalClip
=
opt
=
=
QuadOptimization
:
:
kClipApplied
?
nullptr
:
clip
;
GrAA
aa
{
quad
-
>
fEdgeFlags
!
=
GrQuadAAFlags
:
:
kNone
}
;
GrAAType
aaType
;
if
(
ss
)
{
aaType
=
(
aa
=
=
GrAA
:
:
kYes
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
}
else
if
(
fCanUseDynamicMSAA
&
&
aa
=
=
GrAA
:
:
kNo
)
{
aaType
=
GrAAType
:
:
kNone
;
}
else
{
aaType
=
this
-
>
chooseAAType
(
aa
)
;
}
this
-
>
addDrawOp
(
finalClip
FillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
quad
ss
)
)
;
}
}
void
SurfaceDrawContext
:
:
drawTexture
(
const
GrClip
*
clip
GrSurfaceProxyView
view
SkAlphaType
srcAlphaType
GrSamplerState
:
:
Filter
filter
GrSamplerState
:
:
MipmapMode
mm
SkBlendMode
blendMode
const
SkPMColor4f
&
color
const
SkRect
&
srcRect
const
SkRect
&
dstRect
GrQuadAAFlags
edgeAA
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
)
{
if
(
(
this
-
>
alwaysAntialias
(
)
|
|
this
-
>
caps
(
)
-
>
reducedShaderMode
(
)
)
&
&
edgeAA
!
=
GrQuadAAFlags
:
:
kNone
)
{
GrPaint
paint
;
paint
.
setColor4f
(
color
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
;
if
(
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
)
{
fp
=
GrTextureEffect
:
:
MakeSubset
(
view
srcAlphaType
SkMatrix
:
:
I
(
)
GrSamplerState
(
filter
mm
)
srcRect
*
this
-
>
caps
(
)
)
;
}
else
{
fp
=
GrTextureEffect
:
:
Make
(
view
srcAlphaType
SkMatrix
:
:
I
(
)
filter
mm
)
;
}
if
(
colorSpaceXform
)
{
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
std
:
:
move
(
colorSpaceXform
)
)
;
}
fp
=
GrBlendFragmentProcessor
:
:
Make
<
SkBlendMode
:
:
kModulate
>
(
std
:
:
move
(
fp
)
nullptr
)
;
paint
.
setColorFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
if
(
blendMode
!
=
SkBlendMode
:
:
kSrcOver
)
{
paint
.
setXPFactory
(
SkBlendMode_AsXPFactory
(
blendMode
)
)
;
}
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kYes
viewMatrix
dstRect
srcRect
)
;
return
;
}
const
SkRect
*
subset
=
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
;
DrawQuad
quad
{
GrQuad
:
:
MakeFromRect
(
dstRect
viewMatrix
)
GrQuad
(
srcRect
)
edgeAA
}
;
this
-
>
drawTexturedQuad
(
clip
std
:
:
move
(
view
)
srcAlphaType
std
:
:
move
(
colorSpaceXform
)
filter
mm
color
blendMode
&
quad
subset
)
;
}
void
SurfaceDrawContext
:
:
drawTexturedQuad
(
const
GrClip
*
clip
GrSurfaceProxyView
proxyView
SkAlphaType
srcAlphaType
sk_sp
<
GrColorSpaceXform
>
textureXform
GrSamplerState
:
:
Filter
filter
GrSamplerState
:
:
MipmapMode
mm
const
SkPMColor4f
&
color
SkBlendMode
blendMode
DrawQuad
*
quad
const
SkRect
*
subset
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
proxyView
.
asTextureProxy
(
)
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawTexturedQuad
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
QuadOptimization
opt
=
this
-
>
attemptQuadOptimization
(
clip
nullptr
quad
nullptr
)
;
SkASSERT
(
opt
!
=
QuadOptimization
:
:
kSubmitted
)
;
if
(
opt
!
=
QuadOptimization
:
:
kDiscarded
)
{
const
GrClip
*
finalClip
=
opt
=
=
QuadOptimization
:
:
kClipApplied
?
nullptr
:
clip
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
{
quad
-
>
fEdgeFlags
!
=
GrQuadAAFlags
:
:
kNone
}
)
;
auto
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
auto
saturate
=
clampType
=
=
GrClampType
:
:
kManual
?
ganesh
:
:
TextureOp
:
:
Saturate
:
:
kYes
:
ganesh
:
:
TextureOp
:
:
Saturate
:
:
kNo
;
this
-
>
addDrawOp
(
finalClip
ganesh
:
:
TextureOp
:
:
Make
(
fContext
std
:
:
move
(
proxyView
)
srcAlphaType
std
:
:
move
(
textureXform
)
filter
mm
color
saturate
blendMode
aaType
quad
subset
)
)
;
}
}
void
SurfaceDrawContext
:
:
drawRect
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
GrStyle
*
style
)
{
if
(
!
style
)
{
style
=
&
GrStyle
:
:
SimpleFill
(
)
;
}
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawRect
"
fContext
)
;
SkASSERT
(
!
style
-
>
pathEffect
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
const
SkStrokeRec
&
stroke
=
style
-
>
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rect
rect
)
;
return
;
}
else
if
(
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kHairline_Style
)
&
&
rect
.
width
(
)
&
&
rect
.
height
(
)
&
&
!
this
-
>
caps
(
)
-
>
reducedShaderMode
(
)
)
{
GrAAType
aaType
=
(
fCanUseDynamicMSAA
&
&
stroke
.
getJoin
(
)
=
=
SkPaint
:
:
kMiter_Join
&
&
stroke
.
getMiter
(
)
>
=
SK_ScalarSqrt2
)
?
GrAAType
:
:
kCoverage
:
this
-
>
chooseAAType
(
aa
)
;
GrOp
:
:
Owner
op
=
ganesh
:
:
StrokeRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
rect
stroke
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrStyledShape
(
rect
*
style
DoSimplify
:
:
kNo
)
)
;
}
void
SurfaceDrawContext
:
:
fillRectToRect
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rectToDraw
const
SkRect
&
localRect
)
{
DrawQuad
quad
{
GrQuad
:
:
MakeFromRect
(
rectToDraw
viewMatrix
)
GrQuad
(
localRect
)
aa
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
}
;
if
(
(
fContext
-
>
priv
(
)
.
caps
(
)
-
>
reducedShaderMode
(
)
|
|
this
-
>
alwaysAntialias
(
)
)
&
&
this
-
>
caps
(
)
-
>
drawInstancedSupport
(
)
&
&
aa
=
=
GrAA
:
:
kYes
)
{
QuadOptimization
opt
=
this
-
>
attemptQuadOptimization
(
clip
nullptr
&
quad
&
paint
)
;
if
(
opt
<
QuadOptimization
:
:
kClipApplied
)
{
return
;
}
SkRect
croppedRect
croppedLocal
{
}
;
const
GrClip
*
optimizedClip
=
clip
;
if
(
clip
&
&
viewMatrix
.
isScaleTranslate
(
)
&
&
quad
.
fDevice
.
asRect
(
&
croppedRect
)
&
&
(
!
paint
.
usesLocalCoords
(
)
|
|
quad
.
fLocal
.
asRect
(
&
croppedLocal
)
)
)
{
SkMatrix
inverse
;
if
(
!
viewMatrix
.
invert
(
&
inverse
)
)
{
return
;
}
SkASSERT
(
inverse
.
rectStaysRect
(
)
)
;
inverse
.
mapRect
(
&
croppedRect
)
;
if
(
opt
=
=
QuadOptimization
:
:
kClipApplied
)
{
optimizedClip
=
nullptr
;
}
}
else
{
croppedRect
=
rectToDraw
;
croppedLocal
=
localRect
;
}
if
(
auto
op
=
FillRRectOp
:
:
Make
(
fContext
this
-
>
arenaAlloc
(
)
std
:
:
move
(
paint
)
viewMatrix
SkRRect
:
:
MakeRect
(
croppedRect
)
croppedLocal
GrAA
:
:
kYes
)
)
{
this
-
>
addDrawOp
(
optimizedClip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
&
quad
)
;
}
void
SurfaceDrawContext
:
:
drawQuadSet
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
GrQuadSetEntry
quads
[
]
int
cnt
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kYes
)
;
FillRectOp
:
:
AddFillRectOps
(
this
clip
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
quads
cnt
)
;
}
int
SurfaceDrawContext
:
:
maxWindowRectangles
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
maxWindowRectangles
(
*
this
-
>
caps
(
)
)
;
}
OpsTask
:
:
CanDiscardPreviousOps
SurfaceDrawContext
:
:
canDiscardPreviousOpsOnFullClear
(
)
const
{
#
if
GR_TEST_UTILS
if
(
fPreserveOpsOnFullClear_TestingOnly
)
{
return
OpsTask
:
:
CanDiscardPreviousOps
:
:
kNo
;
}
#
endif
return
OpsTask
:
:
CanDiscardPreviousOps
(
!
fNeedsStencil
)
;
}
void
SurfaceDrawContext
:
:
setNeedsStencil
(
)
{
bool
hasInitializedStencil
=
fNeedsStencil
;
fNeedsStencil
=
true
;
if
(
!
hasInitializedStencil
)
{
this
-
>
asRenderTargetProxy
(
)
-
>
setNeedsStencil
(
)
;
if
(
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
)
{
this
-
>
internalStencilClear
(
nullptr
false
)
;
}
else
{
this
-
>
getOpsTask
(
)
-
>
setInitialStencilContent
(
OpsTask
:
:
StencilContent
:
:
kUserBitsCleared
)
;
}
}
}
void
SurfaceDrawContext
:
:
internalStencilClear
(
const
SkIRect
*
scissor
bool
insideStencilMask
)
{
this
-
>
setNeedsStencil
(
)
;
GrScissorState
scissorState
(
this
-
>
asSurfaceProxy
(
)
-
>
backingStoreDimensions
(
)
)
;
if
(
scissor
&
&
!
scissorState
.
set
(
*
scissor
)
)
{
return
;
}
bool
clearWithDraw
=
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
|
|
(
scissorState
.
enabled
(
)
&
&
this
-
>
caps
(
)
-
>
performPartialClearsAsDraws
(
)
)
;
if
(
clearWithDraw
)
{
const
GrUserStencilSettings
*
ss
=
GrStencilSettings
:
:
SetClipBitSettings
(
insideStencilMask
)
;
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
this
-
>
addDrawOp
(
nullptr
FillRectOp
:
:
MakeNonAARect
(
fContext
std
:
:
move
(
paint
)
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
scissorState
.
rect
(
)
)
ss
)
)
;
}
else
{
this
-
>
addOp
(
ClearOp
:
:
MakeStencilClip
(
fContext
scissorState
insideStencilMask
)
)
;
}
}
bool
SurfaceDrawContext
:
:
stencilPath
(
const
GrHardClip
*
clip
GrAA
doStencilMSAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
)
{
SkIRect
clipBounds
=
clip
?
clip
-
>
getConservativeBounds
(
)
:
SkIRect
:
:
MakeSize
(
this
-
>
dimensions
(
)
)
;
GrStyledShape
shape
(
path
GrStyledShape
:
:
DoSimplify
:
:
kNo
)
;
PathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
fContext
-
>
priv
(
)
.
caps
(
)
;
canDrawArgs
.
fProxy
=
this
-
>
asRenderTargetProxy
(
)
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipBounds
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fPaint
=
nullptr
;
canDrawArgs
.
fSurfaceProps
=
&
fSurfaceProps
;
canDrawArgs
.
fAAType
=
(
doStencilMSAA
=
=
GrAA
:
:
kYes
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
auto
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
PathRendererChain
:
:
DrawType
:
:
kStencil
)
;
if
(
!
pr
)
{
SkDebugf
(
"
WARNING
:
No
path
renderer
to
stencil
path
.
\
n
"
)
;
return
false
;
}
PathRenderer
:
:
StencilPathArgs
args
;
args
.
fContext
=
fContext
;
args
.
fSurfaceDrawContext
=
this
;
args
.
fClip
=
clip
;
args
.
fClipConservativeBounds
=
&
clipBounds
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fShape
=
&
shape
;
args
.
fDoStencilMSAA
=
doStencilMSAA
;
pr
-
>
stencilPath
(
args
)
;
return
true
;
}
void
SurfaceDrawContext
:
:
drawTextureSet
(
const
GrClip
*
clip
GrTextureSetEntry
set
[
]
int
cnt
int
proxyRunCnt
GrSamplerState
:
:
Filter
filter
GrSamplerState
:
:
MipmapMode
mm
SkBlendMode
mode
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawTextureSet
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kYes
)
;
auto
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
auto
saturate
=
clampType
=
=
GrClampType
:
:
kManual
?
ganesh
:
:
TextureOp
:
:
Saturate
:
:
kYes
:
ganesh
:
:
TextureOp
:
:
Saturate
:
:
kNo
;
ganesh
:
:
TextureOp
:
:
AddTextureSetOps
(
this
clip
fContext
set
cnt
proxyRunCnt
filter
mm
saturate
mode
aaType
constraint
viewMatrix
std
:
:
move
(
texXform
)
)
;
}
void
SurfaceDrawContext
:
:
drawVertices
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrixProvider
&
matrixProvider
sk_sp
<
SkVertices
>
vertices
GrPrimitiveType
*
overridePrimType
bool
skipColorXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawVertices
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkASSERT
(
vertices
)
;
auto
xform
=
skipColorXform
?
nullptr
:
this
-
>
colorInfo
(
)
.
refColorSpaceXformFromSRGB
(
)
;
GrAAType
aaType
=
fCanUseDynamicMSAA
?
GrAAType
:
:
kMSAA
:
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
GrOp
:
:
Owner
op
=
DrawMeshOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
std
:
:
move
(
vertices
)
overridePrimType
matrixProvider
aaType
std
:
:
move
(
xform
)
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
drawMesh
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrixProvider
&
matrixProvider
const
SkMesh
&
mesh
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawMesh
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkASSERT
(
mesh
.
isValid
(
)
)
;
auto
xform
=
GrColorSpaceXform
:
:
Make
(
SkMeshSpecificationPriv
:
:
ColorSpace
(
*
mesh
.
spec
(
)
)
SkMeshSpecificationPriv
:
:
AlphaType
(
*
mesh
.
spec
(
)
)
this
-
>
colorInfo
(
)
.
colorSpace
(
)
this
-
>
colorInfo
(
)
.
alphaType
(
)
)
;
GrAAType
aaType
=
fCanUseDynamicMSAA
?
GrAAType
:
:
kMSAA
:
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
GrOp
:
:
Owner
op
=
DrawMeshOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
mesh
matrixProvider
aaType
std
:
:
move
(
xform
)
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
drawAtlas
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawAtlas
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
GrOp
:
:
Owner
op
=
DrawAtlasOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
aaType
spriteCount
xform
texRect
colors
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
drawRRect
(
const
GrClip
*
origClip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawRRect
"
fContext
)
;
SkASSERT
(
!
style
.
pathEffect
(
)
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
&
&
rrect
.
isEmpty
(
)
)
{
return
;
}
const
GrClip
*
clip
=
origClip
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkRRect
devRRect
;
if
(
clip
&
&
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
&
&
rrect
.
transform
(
viewMatrix
&
devRRect
)
)
{
GrClip
:
:
PreClipResult
result
=
clip
-
>
preApply
(
devRRect
.
getBounds
(
)
aa
)
;
switch
(
result
.
fEffect
)
{
case
GrClip
:
:
Effect
:
:
kClippedOut
:
return
;
case
GrClip
:
:
Effect
:
:
kUnclipped
:
clip
=
nullptr
;
break
;
case
GrClip
:
:
Effect
:
:
kClipped
:
if
(
result
.
fIsRRect
&
&
result
.
fRRect
=
=
devRRect
)
{
if
(
result
.
fAA
=
=
aa
|
|
(
result
.
fAA
=
=
GrAA
:
:
kNo
&
&
aa
=
=
GrAA
:
:
kYes
)
)
{
clip
=
nullptr
;
}
}
break
;
default
:
SkUNREACHABLE
;
}
}
#
endif
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
GrOp
:
:
Owner
op
;
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
if
(
aaType
=
=
GrAAType
:
:
kCoverage
&
&
!
fCanUseDynamicMSAA
&
&
!
this
-
>
caps
(
)
-
>
reducedShaderMode
(
)
&
&
rrect
.
isSimple
(
)
&
&
rrect
.
getSimpleRadii
(
)
.
fX
=
=
rrect
.
getSimpleRadii
(
)
.
fY
&
&
viewMatrix
.
rectStaysRect
(
)
&
&
viewMatrix
.
isSimilarity
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeCircularRRectOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rrect
stroke
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
#
endif
if
(
!
op
&
&
style
.
isSimpleFill
(
)
)
{
assert_alive
(
paint
)
;
op
=
FillRRectOp
:
:
Make
(
fContext
this
-
>
arenaAlloc
(
)
std
:
:
move
(
paint
)
viewMatrix
rrect
rrect
.
rect
(
)
GrAA
(
aaType
!
=
GrAAType
:
:
kNone
)
)
;
}
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
if
(
!
op
&
&
(
aaType
=
=
GrAAType
:
:
kCoverage
|
|
fCanUseDynamicMSAA
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeRRectOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rrect
stroke
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
#
endif
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrStyledShape
(
rrect
style
DoSimplify
:
:
kNo
)
)
;
}
bool
SurfaceDrawContext
:
:
drawFastShadow
(
const
GrClip
*
clip
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
abandoned
(
)
)
{
return
true
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawFastShadow
"
fContext
)
;
bool
tiltZPlane
=
SkToBool
(
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fX
)
|
|
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fY
)
)
;
bool
skipAnalytic
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kGeometricOnly_ShadowFlag
)
;
if
(
tiltZPlane
|
|
skipAnalytic
|
|
!
viewMatrix
.
rectStaysRect
(
)
|
|
!
viewMatrix
.
isSimilarity
(
)
)
{
return
false
;
}
SkRRect
rrect
;
SkRect
rect
;
bool
isRRect
=
path
.
isRRect
(
&
rrect
)
&
&
SkRRectPriv
:
:
IsNearlySimpleCircular
(
rrect
)
&
&
rrect
.
getSimpleRadii
(
)
.
fX
>
SK_ScalarNearlyZero
;
if
(
!
isRRect
&
&
path
.
isOval
(
&
rect
)
&
&
SkScalarNearlyEqual
(
rect
.
width
(
)
rect
.
height
(
)
)
&
&
rect
.
width
(
)
>
SK_ScalarNearlyZero
)
{
rrect
.
setOval
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
&
&
path
.
isRect
(
&
rect
)
)
{
rrect
.
setRect
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
)
{
return
false
;
}
if
(
rrect
.
isEmpty
(
)
)
{
return
true
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkPoint3
devLightPos
=
rec
.
fLightPos
;
bool
directional
=
SkToBool
(
rec
.
fFlags
&
kDirectionalLight_ShadowFlag
)
;
if
(
!
directional
)
{
viewMatrix
.
mapPoints
(
(
SkPoint
*
)
&
devLightPos
.
fX
1
)
;
}
SkScalar
devToSrcScale
=
viewMatrix
.
isScaleTranslate
(
)
?
SkScalarInvert
(
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
)
)
:
sk_float_rsqrt
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
*
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
+
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
*
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
)
;
SkScalar
occluderHeight
=
rec
.
fZPlaneParams
.
fZ
;
bool
transparent
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kTransparentOccluder_ShadowFlag
)
;
if
(
SkColorGetA
(
rec
.
fAmbientColor
)
>
0
)
{
SkScalar
devSpaceInsetWidth
=
SkDrawShadowMetrics
:
:
AmbientBlurRadius
(
occluderHeight
)
;
const
SkScalar
umbraRecipAlpha
=
SkDrawShadowMetrics
:
:
AmbientRecipAlpha
(
occluderHeight
)
;
const
SkScalar
devSpaceAmbientBlur
=
devSpaceInsetWidth
*
umbraRecipAlpha
;
SkScalar
ambientPathOutset
=
devSpaceInsetWidth
*
devToSrcScale
;
SkRRect
ambientRRect
;
SkRect
outsetRect
=
rrect
.
rect
(
)
.
makeOutset
(
ambientPathOutset
ambientPathOutset
)
;
if
(
rrect
.
isOval
(
)
)
{
ambientRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
+
ambientPathOutset
;
ambientRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
ambientColor
=
SkColorToPMColor4f
(
rec
.
fAmbientColor
colorInfo
(
)
)
.
toBytes_RGBA
(
)
;
if
(
transparent
)
{
devSpaceInsetWidth
=
ambientRRect
.
width
(
)
;
}
GrOp
:
:
Owner
op
=
ShadowRRectOp
:
:
Make
(
fContext
ambientColor
viewMatrix
ambientRRect
devSpaceAmbientBlur
devSpaceInsetWidth
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
if
(
SkColorGetA
(
rec
.
fSpotColor
)
>
0
)
{
SkScalar
devSpaceSpotBlur
;
SkScalar
spotScale
;
SkVector
spotOffset
;
if
(
directional
)
{
SkDrawShadowMetrics
:
:
GetDirectionalParams
(
occluderHeight
devLightPos
.
fX
devLightPos
.
fY
devLightPos
.
fZ
rec
.
fLightRadius
&
devSpaceSpotBlur
&
spotScale
&
spotOffset
)
;
}
else
{
SkDrawShadowMetrics
:
:
GetSpotParams
(
occluderHeight
devLightPos
.
fX
devLightPos
.
fY
devLightPos
.
fZ
rec
.
fLightRadius
&
devSpaceSpotBlur
&
spotScale
&
spotOffset
)
;
}
const
SkScalar
srcSpaceSpotBlur
=
devSpaceSpotBlur
*
devToSrcScale
;
spotOffset
.
fX
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransX
]
;
spotOffset
.
fY
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransY
]
;
SkMatrix
ctmInverse
;
if
(
viewMatrix
.
invert
(
&
ctmInverse
)
)
{
ctmInverse
.
mapPoints
(
&
spotOffset
1
)
;
}
else
{
SkDebugf
(
"
Matrix
is
degenerate
.
Will
not
render
spot
shadow
correctly
!
\
n
"
)
;
SkASSERT
(
false
)
;
}
SkRRect
spotShadowRRect
;
SkMatrix
shadowTransform
;
shadowTransform
.
setScaleTranslate
(
spotScale
spotScale
spotOffset
.
fX
spotOffset
.
fY
)
;
rrect
.
transform
(
shadowTransform
&
spotShadowRRect
)
;
SkScalar
spotRadius
=
spotShadowRRect
.
getSimpleRadii
(
)
.
fX
;
SkScalar
blurOutset
=
srcSpaceSpotBlur
;
SkScalar
insetWidth
=
blurOutset
;
if
(
transparent
)
{
insetWidth
+
=
spotShadowRRect
.
width
(
)
;
}
else
{
SkScalar
maxOffset
;
if
(
rrect
.
isRect
(
)
)
{
maxOffset
=
std
:
:
max
(
std
:
:
max
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
)
)
std
:
:
max
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
)
)
)
;
}
else
{
SkScalar
dr
=
spotRadius
-
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
;
SkPoint
upperLeftOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
+
dr
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
+
dr
)
;
SkPoint
lowerRightOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
-
dr
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
-
dr
)
;
maxOffset
=
SkScalarSqrt
(
std
:
:
max
(
SkPointPriv
:
:
LengthSqd
(
upperLeftOffset
)
SkPointPriv
:
:
LengthSqd
(
lowerRightOffset
)
)
)
+
dr
;
}
insetWidth
+
=
std
:
:
max
(
blurOutset
maxOffset
)
;
}
SkRect
outsetRect
=
spotShadowRRect
.
rect
(
)
.
makeOutset
(
blurOutset
blurOutset
)
;
if
(
spotShadowRRect
.
isOval
(
)
)
{
spotShadowRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
spotRadius
+
blurOutset
;
spotShadowRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
spotColor
=
SkColorToPMColor4f
(
rec
.
fSpotColor
colorInfo
(
)
)
.
toBytes_RGBA
(
)
;
GrOp
:
:
Owner
op
=
ShadowRRectOp
:
:
Make
(
fContext
spotColor
viewMatrix
spotShadowRRect
2
.
0f
*
devSpaceSpotBlur
insetWidth
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
return
true
;
}
void
SurfaceDrawContext
:
:
drawRegion
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawRegion
"
fContext
)
;
if
(
GrAA
:
:
kYes
=
=
aa
)
{
if
(
!
SkToBool
(
viewMatrix
.
getType
(
)
&
~
(
SkMatrix
:
:
kTranslate_Mask
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateX
(
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateY
(
)
)
)
{
aa
=
GrAA
:
:
kNo
;
}
}
bool
complexStyle
=
!
style
.
isSimpleFill
(
)
;
if
(
complexStyle
|
|
GrAA
:
:
kYes
=
=
aa
)
{
SkPath
path
;
region
.
getBoundaryPath
(
&
path
)
;
path
.
setIsVolatile
(
true
)
;
return
this
-
>
drawPath
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
path
style
)
;
}
GrAAType
aaType
=
(
this
-
>
numSamples
(
)
>
1
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
GrOp
:
:
Owner
op
=
RegionOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
region
aaType
ss
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
drawOval
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawOval
"
fContext
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
oval
.
isEmpty
(
)
&
&
!
style
.
pathEffect
(
)
)
{
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
return
;
}
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
oval
&
style
)
;
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
GrOp
:
:
Owner
op
;
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
if
(
aaType
=
=
GrAAType
:
:
kCoverage
&
&
!
fCanUseDynamicMSAA
&
&
!
this
-
>
caps
(
)
-
>
reducedShaderMode
(
)
&
&
oval
.
width
(
)
>
SK_ScalarNearlyZero
&
&
oval
.
width
(
)
=
=
oval
.
height
(
)
&
&
viewMatrix
.
isSimilarity
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeCircleOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
style
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
#
endif
if
(
!
op
&
&
style
.
isSimpleFill
(
)
)
{
assert_alive
(
paint
)
;
op
=
FillRRectOp
:
:
Make
(
fContext
this
-
>
arenaAlloc
(
)
std
:
:
move
(
paint
)
viewMatrix
SkRRect
:
:
MakeOval
(
oval
)
oval
GrAA
(
aaType
!
=
GrAAType
:
:
kNone
)
)
;
}
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
if
(
!
op
&
&
(
aaType
=
=
GrAAType
:
:
kCoverage
|
|
fCanUseDynamicMSAA
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeOvalOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
style
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
#
endif
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrStyledShape
(
SkRRect
:
:
MakeOval
(
oval
)
SkPathDirection
:
:
kCW
2
false
style
DoSimplify
:
:
kNo
)
)
;
}
void
SurfaceDrawContext
:
:
drawArc
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawArc
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
if
(
aaType
=
=
GrAAType
:
:
kCoverage
)
{
const
GrShaderCaps
*
shaderCaps
=
this
-
>
caps
(
)
-
>
shaderCaps
(
)
;
GrOp
:
:
Owner
op
=
GrOvalOpFactory
:
:
MakeArcOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
startAngle
sweepAngle
useCenter
style
shaderCaps
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
}
#
endif
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrStyledShape
:
:
MakeArc
(
oval
startAngle
sweepAngle
useCenter
style
DoSimplify
:
:
kNo
)
)
;
}
void
SurfaceDrawContext
:
:
drawImageLattice
(
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
GrSurfaceProxyView
view
SkAlphaType
alphaType
sk_sp
<
GrColorSpaceXform
>
csxf
GrSamplerState
:
:
Filter
filter
std
:
:
unique_ptr
<
SkLatticeIter
>
iter
const
SkRect
&
dst
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawImageLattice
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrOp
:
:
Owner
op
=
LatticeOp
:
:
MakeNonAA
(
fContext
std
:
:
move
(
paint
)
viewMatrix
std
:
:
move
(
view
)
alphaType
std
:
:
move
(
csxf
)
filter
std
:
:
move
(
iter
)
dst
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
drawable
const
SkRect
&
bounds
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawDrawable
"
fContext
)
;
GrOp
:
:
Owner
op
(
DrawableOp
:
:
Make
(
fContext
std
:
:
move
(
drawable
)
bounds
)
)
;
SkASSERT
(
op
)
;
this
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
void
SurfaceDrawContext
:
:
setLastClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticElements
)
{
auto
opsTask
=
this
-
>
getOpsTask
(
)
;
opsTask
-
>
fLastClipStackGenID
=
clipStackGenID
;
opsTask
-
>
fLastDevClipBounds
=
devClipBounds
;
opsTask
-
>
fLastClipNumAnalyticElements
=
numClipAnalyticElements
;
}
bool
SurfaceDrawContext
:
:
mustRenderClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticElements
)
{
auto
opsTask
=
this
-
>
getOpsTask
(
)
;
return
opsTask
-
>
fLastClipStackGenID
!
=
clipStackGenID
|
|
!
opsTask
-
>
fLastDevClipBounds
.
contains
(
devClipBounds
)
|
|
opsTask
-
>
fLastClipNumAnalyticElements
!
=
numClipAnalyticElements
;
}
bool
SurfaceDrawContext
:
:
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
bool
deleteSemaphoresAfterWait
)
{
ASSERT_SINGLE_OWNER
RETURN_FALSE_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
waitOnSemaphores
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
numSemaphores
&
&
!
this
-
>
caps
(
)
-
>
semaphoreSupport
(
)
)
{
return
false
;
}
auto
direct
=
fContext
-
>
asDirectContext
(
)
;
if
(
!
direct
)
{
return
false
;
}
auto
resourceProvider
=
direct
-
>
priv
(
)
.
resourceProvider
(
)
;
GrWrapOwnership
ownership
=
deleteSemaphoresAfterWait
?
kAdopt_GrWrapOwnership
:
kBorrow_GrWrapOwnership
;
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrSemaphore
>
[
]
>
grSemaphores
(
new
std
:
:
unique_ptr
<
GrSemaphore
>
[
numSemaphores
]
)
;
for
(
int
i
=
0
;
i
<
numSemaphores
;
+
+
i
)
{
grSemaphores
[
i
]
=
resourceProvider
-
>
wrapBackendSemaphore
(
waitSemaphores
[
i
]
GrSemaphoreWrapType
:
:
kWillWait
ownership
)
;
}
this
-
>
drawingManager
(
)
-
>
newWaitRenderTask
(
this
-
>
asSurfaceProxyRef
(
)
std
:
:
move
(
grSemaphores
)
numSemaphores
)
;
return
true
;
}
void
SurfaceDrawContext
:
:
drawPath
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawPath
"
fContext
)
;
GrStyledShape
shape
(
path
style
DoSimplify
:
:
kNo
)
;
this
-
>
drawShape
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
std
:
:
move
(
shape
)
)
;
}
void
SurfaceDrawContext
:
:
drawShape
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
GrStyledShape
&
&
shape
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawShape
"
fContext
)
;
if
(
shape
.
isEmpty
(
)
)
{
if
(
shape
.
inverseFilled
(
)
)
{
this
-
>
drawPaint
(
clip
std
:
:
move
(
paint
)
viewMatrix
)
;
}
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
std
:
:
move
(
shape
)
true
)
;
}
static
SkIRect
get_clip_bounds
(
const
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
)
{
return
clip
?
clip
-
>
getConservativeBounds
(
)
:
SkIRect
:
:
MakeWH
(
sdc
-
>
width
(
)
sdc
-
>
height
(
)
)
;
}
bool
SurfaceDrawContext
:
:
drawAndStencilPath
(
const
GrHardClip
*
clip
const
GrUserStencilSettings
*
ss
SkRegion
:
:
Op
op
bool
invert
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
)
{
ASSERT_SINGLE_OWNER
RETURN_FALSE_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
drawAndStencilPath
"
fContext
)
;
if
(
path
.
isEmpty
(
)
&
&
path
.
isInverseFillType
(
)
)
{
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
this
-
>
stencilRect
(
clip
ss
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
this
-
>
dimensions
(
)
)
)
;
return
true
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
bool
hasUserStencilSettings
=
!
ss
-
>
isUnused
(
)
;
SkIRect
clipConservativeBounds
=
get_clip_bounds
(
this
clip
)
;
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
GrStyledShape
shape
(
path
GrStyle
:
:
SimpleFill
(
)
)
;
PathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
this
-
>
caps
(
)
;
canDrawArgs
.
fProxy
=
this
-
>
asRenderTargetProxy
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fPaint
=
&
paint
;
canDrawArgs
.
fSurfaceProps
=
&
fSurfaceProps
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fAAType
=
aaType
;
canDrawArgs
.
fHasUserStencilSettings
=
hasUserStencilSettings
;
using
DrawType
=
PathRendererChain
:
:
DrawType
;
auto
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
DrawType
:
:
kStencilAndColor
)
;
if
(
!
pr
)
{
return
false
;
}
PathRenderer
:
:
DrawPathArgs
args
{
this
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
ss
this
clip
&
clipConservativeBounds
&
viewMatrix
&
shape
aaType
this
-
>
colorInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
return
true
;
}
skgpu
:
:
Budgeted
SurfaceDrawContext
:
:
isBudgeted
(
)
const
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
abandoned
(
)
)
{
return
skgpu
:
:
Budgeted
:
:
kNo
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
this
-
>
asSurfaceProxy
(
)
-
>
isBudgeted
(
)
;
}
void
SurfaceDrawContext
:
:
drawStrokedLine
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPoint
points
[
2
]
const
SkStrokeRec
&
stroke
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
)
;
SkASSERT
(
stroke
.
getWidth
(
)
>
0
)
;
SkASSERT
(
SkPaint
:
:
kRound_Cap
!
=
stroke
.
getCap
(
)
)
;
const
SkScalar
halfWidth
=
0
.
5f
*
stroke
.
getWidth
(
)
;
if
(
halfWidth
<
=
0
.
f
)
{
return
;
}
SkVector
parallel
=
points
[
1
]
-
points
[
0
]
;
if
(
!
SkPoint
:
:
Normalize
(
&
parallel
)
)
{
parallel
.
fX
=
1
.
0f
;
parallel
.
fY
=
0
.
0f
;
}
parallel
*
=
halfWidth
;
SkVector
ortho
=
{
parallel
.
fY
-
parallel
.
fX
}
;
SkPoint
p0
=
points
[
0
]
p1
=
points
[
1
]
;
if
(
stroke
.
getCap
(
)
=
=
SkPaint
:
:
kSquare_Cap
)
{
p0
-
=
parallel
;
p1
+
=
parallel
;
}
if
(
this
-
>
caps
(
)
-
>
drawInstancedSupport
(
)
&
&
(
this
-
>
alwaysAntialias
(
)
|
|
(
fContext
-
>
priv
(
)
.
caps
(
)
-
>
reducedShaderMode
(
)
&
&
aa
=
=
GrAA
:
:
kYes
)
)
)
{
SkMatrix
localMatrix
=
SkMatrix
:
:
MakeAll
(
p1
.
fX
-
p0
.
fX
ortho
.
fX
p0
.
fX
p1
.
fY
-
p0
.
fY
ortho
.
fY
p0
.
fY
0
0
1
)
;
if
(
auto
op
=
FillRRectOp
:
:
Make
(
fContext
this
-
>
arenaAlloc
(
)
std
:
:
move
(
paint
)
SkMatrix
:
:
Concat
(
viewMatrix
localMatrix
)
SkRRect
:
:
MakeRect
(
{
0
-
1
1
1
}
)
localMatrix
GrAA
:
:
kYes
)
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
SkPoint
corners
[
4
]
=
{
p0
-
ortho
p0
+
ortho
p1
+
ortho
p1
-
ortho
}
;
GrQuadAAFlags
edgeAA
=
(
aa
=
=
GrAA
:
:
kYes
)
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
;
assert_alive
(
paint
)
;
this
-
>
fillQuadWithEdgeAA
(
clip
std
:
:
move
(
paint
)
edgeAA
viewMatrix
corners
nullptr
)
;
}
bool
SurfaceDrawContext
:
:
drawSimpleShape
(
const
GrClip
*
clip
GrPaint
*
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
shape
)
{
if
(
!
shape
.
style
(
)
.
hasPathEffect
(
)
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
SkPoint
linePts
[
2
]
;
SkRRect
rrect
;
bool
inverted
;
if
(
shape
.
asLine
(
linePts
&
inverted
)
&
&
!
inverted
&
&
shape
.
style
(
)
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
&
&
shape
.
style
(
)
.
strokeRec
(
)
.
getCap
(
)
!
=
SkPaint
:
:
kRound_Cap
)
{
SkScalar
coverage
;
if
(
aaType
=
=
GrAAType
:
:
kCoverage
|
|
!
SkDrawTreatAAStrokeAsHairline
(
shape
.
style
(
)
.
strokeRec
(
)
.
getWidth
(
)
viewMatrix
&
coverage
)
)
{
this
-
>
drawStrokedLine
(
clip
std
:
:
move
(
*
paint
)
aa
viewMatrix
linePts
shape
.
style
(
)
.
strokeRec
(
)
)
;
return
true
;
}
}
else
if
(
shape
.
asRRect
(
&
rrect
nullptr
nullptr
&
inverted
)
&
&
!
inverted
)
{
if
(
rrect
.
isRect
(
)
)
{
this
-
>
drawRect
(
clip
std
:
:
move
(
*
paint
)
aa
viewMatrix
rrect
.
rect
(
)
&
shape
.
style
(
)
)
;
return
true
;
}
else
if
(
rrect
.
isOval
(
)
)
{
this
-
>
drawOval
(
clip
std
:
:
move
(
*
paint
)
aa
viewMatrix
rrect
.
rect
(
)
shape
.
style
(
)
)
;
return
true
;
}
this
-
>
drawRRect
(
clip
std
:
:
move
(
*
paint
)
aa
viewMatrix
rrect
shape
.
style
(
)
)
;
return
true
;
}
else
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
shape
.
style
(
)
.
isSimpleFill
(
)
&
&
viewMatrix
.
rectStaysRect
(
)
&
&
!
this
-
>
caps
(
)
-
>
reducedShaderMode
(
)
)
{
SkRect
rects
[
2
]
;
if
(
shape
.
asNestedRects
(
rects
)
)
{
GrOp
:
:
Owner
op
=
ganesh
:
:
StrokeRectOp
:
:
MakeNested
(
fContext
std
:
:
move
(
*
paint
)
viewMatrix
rects
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
true
;
}
}
}
}
return
false
;
}
void
SurfaceDrawContext
:
:
drawShapeUsingPathRenderer
(
const
GrClip
*
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
GrStyledShape
&
&
shape
bool
attemptDrawSimple
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
internalDrawPath
"
fContext
)
;
if
(
!
viewMatrix
.
isFinite
(
)
|
|
!
shape
.
bounds
(
)
.
isFinite
(
)
)
{
return
;
}
SkIRect
clipConservativeBounds
=
get_clip_bounds
(
this
clip
)
;
GrAAType
aaType
=
fCanUseDynamicMSAA
?
GrAAType
:
:
kMSAA
:
this
-
>
chooseAAType
(
aa
)
;
PathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
this
-
>
caps
(
)
;
canDrawArgs
.
fProxy
=
this
-
>
asRenderTargetProxy
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fPaint
=
&
paint
;
canDrawArgs
.
fSurfaceProps
=
&
fSurfaceProps
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
canDrawArgs
.
fAAType
=
aaType
;
constexpr
static
bool
kDisallowSWPathRenderer
=
false
;
constexpr
static
bool
kAllowSWPathRenderer
=
true
;
using
DrawType
=
PathRendererChain
:
:
DrawType
;
PathRenderer
*
pr
=
nullptr
;
if
(
!
shape
.
style
(
)
.
strokeRec
(
)
.
isFillStyle
(
)
&
&
!
shape
.
isEmpty
(
)
)
{
PathRenderer
*
tess
=
this
-
>
drawingManager
(
)
-
>
getTessellationPathRenderer
(
)
;
if
(
tess
&
&
tess
-
>
canDrawPath
(
canDrawArgs
)
=
=
PathRenderer
:
:
CanDrawPath
:
:
kYes
)
{
pr
=
tess
;
}
}
if
(
!
pr
)
{
shape
.
simplify
(
)
;
if
(
shape
.
isEmpty
(
)
&
&
!
shape
.
inverseFilled
(
)
)
{
return
;
}
if
(
attemptDrawSimple
|
|
shape
.
simplified
(
)
)
{
if
(
this
-
>
drawSimpleShape
(
clip
&
paint
aa
viewMatrix
shape
)
)
{
return
;
}
}
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
kDisallowSWPathRenderer
DrawType
:
:
kColor
)
;
}
SkScalar
styleScale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
styleScale
=
=
0
.
0f
)
{
return
;
}
if
(
!
pr
&
&
shape
.
style
(
)
.
pathEffect
(
)
)
{
shape
=
shape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectOnly
styleScale
)
;
if
(
shape
.
isEmpty
(
)
)
{
return
;
}
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
kDisallowSWPathRenderer
DrawType
:
:
kColor
)
;
}
if
(
!
pr
)
{
if
(
shape
.
style
(
)
.
applies
(
)
)
{
shape
=
shape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
styleScale
)
;
if
(
shape
.
isEmpty
(
)
)
{
return
;
}
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
kAllowSWPathRenderer
DrawType
:
:
kColor
)
;
}
else
{
pr
=
this
-
>
drawingManager
(
)
-
>
getSoftwarePathRenderer
(
)
;
#
if
GR_PATH_RENDERER_SPEW
SkDebugf
(
"
falling
back
to
:
%
s
\
n
"
pr
-
>
name
(
)
)
;
#
endif
}
}
if
(
!
pr
)
{
#
ifdef
SK_DEBUG
SkDebugf
(
"
Unable
to
find
path
renderer
compatible
with
path
.
\
n
"
)
;
#
endif
return
;
}
PathRenderer
:
:
DrawPathArgs
args
{
this
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
&
GrUserStencilSettings
:
:
kUnused
this
clip
&
clipConservativeBounds
&
viewMatrix
canDrawArgs
.
fShape
aaType
this
-
>
colorInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
}
void
SurfaceDrawContext
:
:
addDrawOp
(
const
GrClip
*
clip
GrOp
:
:
Owner
op
const
std
:
:
function
<
WillAddOpFn
>
&
willAddFn
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
abandoned
(
)
)
{
return
;
}
GrDrawOp
*
drawOp
=
(
GrDrawOp
*
)
op
.
get
(
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkDEBUGCODE
(
drawOp
-
>
fAddDrawOpCalled
=
true
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SurfaceDrawContext
"
"
addDrawOp
"
fContext
)
;
SkRect
bounds
;
op_bounds
(
&
bounds
op
.
get
(
)
)
;
GrAppliedClip
appliedClip
(
this
-
>
dimensions
(
)
this
-
>
asSurfaceProxy
(
)
-
>
backingStoreDimensions
(
)
)
;
const
bool
opUsesMSAA
=
drawOp
-
>
usesMSAA
(
)
;
bool
skipDraw
=
false
;
if
(
clip
)
{
GrAAType
aaType
;
if
(
opUsesMSAA
)
{
aaType
=
GrAAType
:
:
kMSAA
;
}
else
{
aaType
=
op
-
>
hasAABloat
(
)
?
GrAAType
:
:
kCoverage
:
GrAAType
:
:
kNone
;
}
skipDraw
=
clip
-
>
apply
(
fContext
this
drawOp
aaType
&
appliedClip
&
bounds
)
=
=
GrClip
:
:
Effect
:
:
kClippedOut
;
}
else
{
skipDraw
=
!
bounds
.
intersect
(
this
-
>
asSurfaceProxy
(
)
-
>
getBoundsRect
(
)
)
;
}
if
(
skipDraw
)
{
return
;
}
GrClampType
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
GrProcessorSet
:
:
Analysis
analysis
=
drawOp
-
>
finalize
(
*
this
-
>
caps
(
)
&
appliedClip
clampType
)
;
const
bool
opUsesStencil
=
drawOp
-
>
usesStencil
(
)
;
const
bool
drawNeedsMSAA
=
opUsesMSAA
|
|
(
fCanUseDynamicMSAA
&
&
opUsesStencil
)
;
op
-
>
setClippedBounds
(
bounds
)
;
bool
usesAttachmentIfDMSAA
=
fCanUseDynamicMSAA
&
&
(
!
this
-
>
caps
(
)
-
>
msaaResolvesAutomatically
(
)
|
|
!
this
-
>
asTextureProxy
(
)
)
;
bool
opRequiresDMSAAAttachment
=
usesAttachmentIfDMSAA
&
&
drawNeedsMSAA
;
bool
opTriggersDMSAAAttachment
=
opRequiresDMSAAAttachment
&
&
!
this
-
>
getOpsTask
(
)
-
>
usesMSAASurface
(
)
;
if
(
opTriggersDMSAAAttachment
)
{
if
(
this
-
>
getOpsTask
(
)
-
>
renderPassXferBarriers
(
)
&
GrXferBarrierFlags
:
:
kTexture
)
{
SkASSERT
(
!
this
-
>
getOpsTask
(
)
-
>
isColorNoOp
(
)
)
;
this
-
>
replaceOpsTask
(
)
-
>
setCannotMergeBackward
(
)
;
}
}
GrDstProxyView
dstProxyView
;
if
(
analysis
.
requiresDstTexture
(
)
)
{
if
(
!
this
-
>
setupDstProxyView
(
drawOp
-
>
bounds
(
)
drawNeedsMSAA
&
dstProxyView
)
)
{
return
;
}
#
ifdef
SK_DEBUG
if
(
fCanUseDynamicMSAA
&
&
drawNeedsMSAA
&
&
!
this
-
>
caps
(
)
-
>
msaaResolvesAutomatically
(
)
)
{
SkASSERT
(
this
-
>
getOpsTask
(
)
-
>
isEmpty
(
)
)
;
}
#
endif
}
auto
opsTask
=
this
-
>
getOpsTask
(
)
;
if
(
willAddFn
)
{
willAddFn
(
op
.
get
(
)
opsTask
-
>
uniqueID
(
)
)
;
}
if
(
opUsesStencil
)
{
this
-
>
setNeedsStencil
(
)
;
}
#
if
GR_GPU_STATS
&
&
GR_TEST_UTILS
if
(
fCanUseDynamicMSAA
&
&
drawNeedsMSAA
)
{
if
(
!
opsTask
-
>
usesMSAASurface
(
)
)
{
fContext
-
>
priv
(
)
.
dmsaaStats
(
)
.
fNumMultisampleRenderPasses
+
+
;
}
fContext
-
>
priv
(
)
.
dmsaaStats
(
)
.
fTriggerCounts
[
op
-
>
name
(
)
]
+
+
;
}
#
endif
opsTask
-
>
addDrawOp
(
this
-
>
drawingManager
(
)
std
:
:
move
(
op
)
drawNeedsMSAA
analysis
std
:
:
move
(
appliedClip
)
dstProxyView
GrTextureResolveManager
(
this
-
>
drawingManager
(
)
)
*
this
-
>
caps
(
)
)
;
#
ifdef
SK_DEBUG
if
(
fCanUseDynamicMSAA
&
&
drawNeedsMSAA
)
{
SkASSERT
(
opsTask
-
>
usesMSAASurface
(
)
)
;
}
#
endif
}
bool
SurfaceDrawContext
:
:
setupDstProxyView
(
const
SkRect
&
opBounds
bool
opRequiresMSAA
GrDstProxyView
*
dstProxyView
)
{
if
(
this
-
>
asRenderTargetProxy
(
)
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
auto
dstSampleFlags
=
this
-
>
caps
(
)
-
>
getDstSampleFlagsForProxy
(
this
-
>
asRenderTargetProxy
(
)
this
-
>
getOpsTask
(
)
-
>
usesMSAASurface
(
)
|
|
opRequiresMSAA
)
;
if
(
!
(
dstSampleFlags
&
GrDstSampleFlags
:
:
kRequiresTextureBarrier
)
&
&
fCanUseDynamicMSAA
&
&
this
-
>
getOpsTask
(
)
-
>
usesMSAASurface
(
)
&
&
!
opRequiresMSAA
)
{
auto
newFlags
=
this
-
>
caps
(
)
-
>
getDstSampleFlagsForProxy
(
this
-
>
asRenderTargetProxy
(
)
false
)
;
if
(
newFlags
&
GrDstSampleFlags
:
:
kRequiresTextureBarrier
)
{
SkASSERT
(
!
this
-
>
getOpsTask
(
)
-
>
isColorNoOp
(
)
)
;
this
-
>
replaceOpsTask
(
)
-
>
setCannotMergeBackward
(
)
;
dstSampleFlags
=
newFlags
;
}
}
if
(
dstSampleFlags
&
GrDstSampleFlags
:
:
kRequiresTextureBarrier
)
{
dstProxyView
-
>
setProxyView
(
this
-
>
readSurfaceView
(
)
)
;
dstProxyView
-
>
setOffset
(
0
0
)
;
dstProxyView
-
>
setDstSampleFlags
(
dstSampleFlags
)
;
return
true
;
}
SkASSERT
(
dstSampleFlags
=
=
GrDstSampleFlags
:
:
kNone
)
;
if
(
fCanUseDynamicMSAA
&
&
opRequiresMSAA
&
&
this
-
>
asTextureProxy
(
)
&
&
!
this
-
>
caps
(
)
-
>
msaaResolvesAutomatically
(
)
&
&
this
-
>
caps
(
)
-
>
dmsaaResolveCanBeUsedAsTextureInSameRenderPass
(
)
)
{
this
-
>
replaceOpsTaskIfModifiesColor
(
)
-
>
setCannotMergeBackward
(
)
;
dstProxyView
-
>
setProxyView
(
this
-
>
readSurfaceView
(
)
)
;
dstProxyView
-
>
setOffset
(
0
0
)
;
dstProxyView
-
>
setDstSampleFlags
(
dstSampleFlags
)
;
return
true
;
}
GrColorType
colorType
=
this
-
>
colorInfo
(
)
.
colorType
(
)
;
GrCaps
:
:
DstCopyRestrictions
restrictions
=
this
-
>
caps
(
)
-
>
getDstCopyRestrictions
(
this
-
>
asRenderTargetProxy
(
)
colorType
)
;
SkIRect
copyRect
=
SkIRect
:
:
MakeSize
(
this
-
>
asSurfaceProxy
(
)
-
>
backingStoreDimensions
(
)
)
;
if
(
!
restrictions
.
fMustCopyWholeSrc
)
{
SkIRect
conservativeDrawBounds
=
opBounds
.
roundOut
(
)
;
conservativeDrawBounds
.
outset
(
1
1
)
;
SkAssertResult
(
copyRect
.
intersect
(
conservativeDrawBounds
)
)
;
}
SkIPoint
dstOffset
;
SkBackingFit
fit
;
if
(
restrictions
.
fRectsMustMatch
=
=
GrSurfaceProxy
:
:
RectsMustMatch
:
:
kYes
)
{
dstOffset
=
{
0
0
}
;
fit
=
SkBackingFit
:
:
kExact
;
}
else
{
dstOffset
=
{
copyRect
.
fLeft
copyRect
.
fTop
}
;
fit
=
SkBackingFit
:
:
kApprox
;
}
auto
copy
=
GrSurfaceProxy
:
:
Copy
(
fContext
this
-
>
asSurfaceProxyRef
(
)
this
-
>
origin
(
)
GrMipmapped
:
:
kNo
copyRect
fit
skgpu
:
:
Budgeted
:
:
kYes
{
}
restrictions
.
fRectsMustMatch
)
;
SkASSERT
(
copy
)
;
dstProxyView
-
>
setProxyView
(
{
std
:
:
move
(
copy
)
this
-
>
origin
(
)
this
-
>
readSwizzle
(
)
}
)
;
dstProxyView
-
>
setOffset
(
dstOffset
)
;
dstProxyView
-
>
setDstSampleFlags
(
dstSampleFlags
)
;
return
true
;
}
OpsTask
*
SurfaceDrawContext
:
:
replaceOpsTaskIfModifiesColor
(
)
{
if
(
!
this
-
>
getOpsTask
(
)
-
>
isColorNoOp
(
)
)
{
this
-
>
replaceOpsTask
(
)
;
}
return
this
-
>
getOpsTask
(
)
;
}
}
