#
ifndef
GrD3DPipelineStateBuilder_DEFINED
#
define
GrD3DPipelineStateBuilder_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrPipeline
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSPIRVUniformHandler
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSPIRVVaryingHandler
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
d3d
/
GrD3DPipelineState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
class
GrProgramDesc
;
class
GrD3DGpu
;
class
GrVkRenderPass
;
class
GrD3DPipelineStateBuilder
:
public
GrGLSLProgramBuilder
{
public
:
static
std
:
:
unique_ptr
<
GrD3DPipelineState
>
MakePipelineState
(
GrD3DGpu
*
GrD3DRenderTarget
*
const
GrProgramDesc
&
const
GrProgramInfo
&
)
;
static
sk_sp
<
GrD3DPipeline
>
MakeComputePipeline
(
GrD3DGpu
*
GrD3DRootSignature
*
const
char
*
shader
)
;
const
GrCaps
*
caps
(
)
const
override
;
GrD3DGpu
*
gpu
(
)
const
{
return
fGpu
;
}
SkSL
:
:
Compiler
*
shaderCompiler
(
)
const
override
;
void
finalizeFragmentSecondaryColor
(
GrShaderVar
&
outputColor
)
override
;
private
:
GrD3DPipelineStateBuilder
(
GrD3DGpu
*
GrD3DRenderTarget
*
const
GrProgramDesc
&
const
GrProgramInfo
&
)
;
std
:
:
unique_ptr
<
GrD3DPipelineState
>
finalize
(
)
;
bool
loadHLSLFromCache
(
SkReadBuffer
*
reader
gr_cp
<
ID3DBlob
>
shaders
[
]
)
;
gr_cp
<
ID3DBlob
>
compileD3DProgram
(
SkSL
:
:
ProgramKind
kind
const
std
:
:
string
&
sksl
const
SkSL
:
:
ProgramSettings
&
settings
SkSL
:
:
Program
:
:
Inputs
*
outInputs
std
:
:
string
*
outHLSL
)
;
GrGLSLUniformHandler
*
uniformHandler
(
)
override
{
return
&
fUniformHandler
;
}
const
GrGLSLUniformHandler
*
uniformHandler
(
)
const
override
{
return
&
fUniformHandler
;
}
GrGLSLVaryingHandler
*
varyingHandler
(
)
override
{
return
&
fVaryingHandler
;
}
GrD3DGpu
*
fGpu
;
GrSPIRVVaryingHandler
fVaryingHandler
;
GrSPIRVUniformHandler
fUniformHandler
;
GrD3DRenderTarget
*
fRenderTarget
;
using
INHERITED
=
GrGLSLProgramBuilder
;
}
;
#
endif
