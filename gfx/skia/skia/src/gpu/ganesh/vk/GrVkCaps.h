#
ifndef
GrVkCaps_DEFINED
#
define
GrVkCaps_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
class
GrVkRenderTarget
;
enum
class
SkTextureCompressionType
;
namespace
skgpu
{
class
VulkanExtensions
;
struct
VulkanInterface
;
}
class
GrVkCaps
:
public
GrCaps
{
public
:
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
device
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
instanceVersion
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
&
extensions
skgpu
:
:
Protected
isProtected
=
skgpu
:
:
Protected
:
:
kNo
)
;
bool
isFormatSRGB
(
const
GrBackendFormat
&
)
const
override
;
bool
isFormatTexturable
(
const
GrBackendFormat
&
GrTextureType
)
const
override
;
bool
isVkFormatTexturable
(
VkFormat
)
const
;
bool
isFormatCopyable
(
const
GrBackendFormat
&
)
const
override
{
return
true
;
}
bool
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
=
1
)
const
override
;
bool
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
override
;
bool
isFormatRenderable
(
VkFormat
int
sampleCount
)
const
;
int
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
)
const
override
;
int
getRenderTargetSampleCount
(
int
requestedCount
VkFormat
)
const
;
int
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
)
const
override
;
int
maxRenderTargetSampleCount
(
VkFormat
format
)
const
;
SupportedWrite
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
override
;
SurfaceReadPixelsSupport
surfaceSupportsReadPixels
(
const
GrSurface
*
)
const
override
;
bool
isVkFormatTexturableLinearly
(
VkFormat
format
)
const
{
return
SkToBool
(
FormatInfo
:
:
kTexturable_Flag
&
this
-
>
getFormatInfo
(
format
)
.
fLinearFlags
)
;
}
bool
formatCanBeDstofBlit
(
VkFormat
format
bool
linearTiled
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
uint16_t
&
flags
=
linearTiled
?
info
.
fLinearFlags
:
info
.
fOptimalFlags
;
return
SkToBool
(
FormatInfo
:
:
kBlitDst_Flag
&
flags
)
;
}
bool
formatCanBeSrcofBlit
(
VkFormat
format
bool
linearTiled
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
uint16_t
&
flags
=
linearTiled
?
info
.
fLinearFlags
:
info
.
fOptimalFlags
;
return
SkToBool
(
FormatInfo
:
:
kBlitSrc_Flag
&
flags
)
;
}
GrColorType
transferColorType
(
VkFormat
GrColorType
surfaceColorType
)
const
;
bool
mustSyncCommandBuffersWithQueue
(
)
const
{
return
fMustSyncCommandBuffersWithQueue
;
}
bool
shouldAlwaysUseDedicatedImageMemory
(
)
const
{
return
fShouldAlwaysUseDedicatedImageMemory
;
}
bool
avoidUpdateBuffers
(
)
const
{
return
fAvoidUpdateBuffers
;
}
VkFormat
preferredStencilFormat
(
)
const
{
return
fPreferredStencilFormat
;
}
static
int
GetStencilFormatTotalBitCount
(
VkFormat
format
)
{
switch
(
format
)
{
case
VK_FORMAT_S8_UINT
:
return
8
;
case
VK_FORMAT_D24_UNORM_S8_UINT
:
return
32
;
case
VK_FORMAT_D32_SFLOAT_S8_UINT
:
return
64
;
default
:
SkASSERT
(
false
)
;
return
0
;
}
}
bool
supportsSwapchain
(
)
const
{
return
fSupportsSwapchain
;
}
bool
supportsPhysicalDeviceProperties2
(
)
const
{
return
fSupportsPhysicalDeviceProperties2
;
}
bool
supportsMemoryRequirements2
(
)
const
{
return
fSupportsMemoryRequirements2
;
}
bool
supportsBindMemory2
(
)
const
{
return
fSupportsBindMemory2
;
}
bool
supportsMaintenance1
(
)
const
{
return
fSupportsMaintenance1
;
}
bool
supportsMaintenance2
(
)
const
{
return
fSupportsMaintenance2
;
}
bool
supportsMaintenance3
(
)
const
{
return
fSupportsMaintenance3
;
}
bool
supportsDedicatedAllocation
(
)
const
{
return
fSupportsDedicatedAllocation
;
}
bool
supportsExternalMemory
(
)
const
{
return
fSupportsExternalMemory
;
}
bool
supportsAndroidHWBExternalMemory
(
)
const
{
return
fSupportsAndroidHWBExternalMemory
;
}
bool
supportsYcbcrConversion
(
)
const
{
return
fSupportsYcbcrConversion
;
}
uint32_t
ycbcrCombinedImageSamplerDescriptorCount
(
)
const
{
return
3
;
}
bool
supportsProtectedMemory
(
)
const
{
return
fSupportsProtectedMemory
;
}
bool
supportsDRMFormatModifiers
(
)
const
{
return
fSupportsDRMFormatModifiers
;
}
bool
preferPrimaryOverSecondaryCommandBuffers
(
)
const
{
return
fPreferPrimaryOverSecondaryCommandBuffers
;
}
int
maxPerPoolCachedSecondaryCommandBuffers
(
)
const
{
return
fMaxPerPoolCachedSecondaryCommandBuffers
;
}
uint32_t
maxInputAttachmentDescriptors
(
)
const
{
return
fMaxInputAttachmentDescriptors
;
}
float
maxSamplerAnisotropy
(
)
const
{
return
fMaxSamplerAnisotropy
;
}
bool
mustInvalidatePrimaryCmdBufferStateAfterClearAttachments
(
)
const
{
return
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
;
}
bool
mustUseCoherentHostVisibleMemory
(
)
const
{
return
fMustUseCoherentHostVisibleMemory
;
}
bool
gpuOnlyBuffersMorePerformant
(
)
const
{
return
fGpuOnlyBuffersMorePerformant
;
}
bool
shouldPersistentlyMapCpuToGpuBuffers
(
)
const
{
return
fShouldPersistentlyMapCpuToGpuBuffers
;
}
uint32_t
maxDrawIndirectDrawCount
(
)
const
{
return
fMaxDrawIndirectDrawCount
;
}
bool
canCopyImage
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSamplecnt
bool
srcHasYcbcr
)
const
;
bool
canCopyAsBlit
(
VkFormat
dstConfig
int
dstSampleCnt
bool
dstIsLinear
bool
dstHasYcbcr
VkFormat
srcConfig
int
srcSampleCnt
bool
srcIsLinear
bool
srcHasYcbcr
)
const
;
bool
canCopyAsResolve
(
VkFormat
dstConfig
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcConfig
int
srcSamplecnt
bool
srcHasYcbcr
)
const
;
GrBackendFormat
getBackendFormatFromCompressionType
(
SkTextureCompressionType
)
const
override
;
VkFormat
getFormatFromColorType
(
GrColorType
colorType
)
const
{
int
idx
=
static_cast
<
int
>
(
colorType
)
;
return
fColorTypeToFormatTable
[
idx
]
;
}
skgpu
:
:
Swizzle
getWriteSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
uint64_t
computeFormatKey
(
const
GrBackendFormat
&
)
const
override
;
int
getFragmentUniformBinding
(
)
const
;
int
getFragmentUniformSet
(
)
const
;
void
addExtraSamplerKey
(
skgpu
:
:
KeyBuilder
*
GrSamplerState
const
GrBackendFormat
&
)
const
override
;
GrProgramDesc
makeDesc
(
GrRenderTarget
*
const
GrProgramInfo
&
ProgramDescOverrideFlags
)
const
override
;
GrInternalSurfaceFlags
getExtraSurfaceFlagsForDeferredRT
(
)
const
override
;
VkShaderStageFlags
getPushConstantStageFlags
(
)
const
;
bool
mustLoadFullImageWithDiscardableMSAA
(
)
const
{
return
fMustLoadFullImageWithDiscardableMSAA
;
}
bool
supportsDiscardableMSAAForDMSAA
(
)
const
{
return
fSupportsDiscardableMSAAForDMSAA
;
}
bool
renderTargetSupportsDiscardableMSAA
(
const
GrVkRenderTarget
*
)
const
;
bool
programInfoWillUseDiscardableMSAA
(
const
GrProgramInfo
&
)
const
;
bool
dmsaaResolveCanBeUsedAsTextureInSameRenderPass
(
)
const
override
{
return
false
;
}
bool
supportsMemorylessAttachments
(
)
const
{
return
fSupportsMemorylessAttachments
;
}
#
if
GR_TEST_UTILS
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
getTestingCombinations
(
)
const
override
;
#
endif
private
:
enum
VkVendor
{
kAMD_VkVendor
=
4098
kARM_VkVendor
=
5045
kImagination_VkVendor
=
4112
kIntel_VkVendor
=
32902
kNvidia_VkVendor
=
4318
kQualcomm_VkVendor
=
20803
}
;
enum
class
IntelGPUType
{
kSkyLake
kIceLake
kRocketLake
kTigerLake
kAlderLake
kOther
}
;
static
IntelGPUType
GetIntelGPUType
(
uint32_t
deviceID
)
;
static
int
GetIntelGen
(
IntelGPUType
type
)
{
switch
(
type
)
{
case
IntelGPUType
:
:
kSkyLake
:
return
9
;
case
IntelGPUType
:
:
kIceLake
:
return
11
;
case
IntelGPUType
:
:
kRocketLake
:
case
IntelGPUType
:
:
kTigerLake
:
case
IntelGPUType
:
:
kAlderLake
:
return
12
;
case
IntelGPUType
:
:
kOther
:
return
0
;
}
SkUNREACHABLE
;
}
void
init
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
device
const
VkPhysicalDeviceFeatures2
&
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
&
GrProtected
isProtected
)
;
void
initGrCaps
(
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
const
VkPhysicalDeviceMemoryProperties
&
const
VkPhysicalDeviceFeatures2
&
const
skgpu
:
:
VulkanExtensions
&
)
;
void
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
const
VkPhysicalDeviceFeatures2
&
)
;
void
initFormatTable
(
const
GrContextOptions
&
const
skgpu
:
:
VulkanInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
)
;
void
initStencilFormat
(
const
skgpu
:
:
VulkanInterface
*
iface
VkPhysicalDevice
physDev
)
;
void
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
)
;
bool
onSurfaceSupportsWritePixels
(
const
GrSurface
*
)
const
override
;
bool
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
override
;
GrBackendFormat
onGetDefaultBackendFormat
(
GrColorType
)
const
override
;
bool
onAreColorTypeAndFormatCompatible
(
GrColorType
const
GrBackendFormat
&
)
const
override
;
SupportedRead
onSupportedReadPixelsColorType
(
GrColorType
const
GrBackendFormat
&
GrColorType
)
const
override
;
skgpu
:
:
Swizzle
onGetReadSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
GrDstSampleFlags
onGetDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
)
const
override
;
bool
onSupportsDynamicMSAA
(
const
GrRenderTargetProxy
*
)
const
override
;
struct
ColorTypeInfo
{
GrColorType
fColorType
=
GrColorType
:
:
kUnknown
;
GrColorType
fTransferColorType
=
GrColorType
:
:
kUnknown
;
enum
{
kUploadData_Flag
=
0x1
kRenderable_Flag
=
0x2
kWrappedOnly_Flag
=
0x4
}
;
uint32_t
fFlags
=
0
;
skgpu
:
:
Swizzle
fReadSwizzle
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
}
;
struct
FormatInfo
{
uint32_t
colorTypeFlags
(
GrColorType
colorType
)
const
{
for
(
int
i
=
0
;
i
<
fColorTypeInfoCount
;
+
+
i
)
{
if
(
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
return
fColorTypeInfos
[
i
]
.
fFlags
;
}
}
return
0
;
}
void
init
(
const
GrContextOptions
&
const
skgpu
:
:
VulkanInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
VkFormat
)
;
static
void
InitFormatFlags
(
VkFormatFeatureFlags
uint16_t
*
flags
)
;
void
initSampleCounts
(
const
GrContextOptions
&
const
skgpu
:
:
VulkanInterface
*
VkPhysicalDevice
const
VkPhysicalDeviceProperties
&
VkFormat
)
;
enum
{
kTexturable_Flag
=
0x1
kRenderable_Flag
=
0x2
kBlitSrc_Flag
=
0x4
kBlitDst_Flag
=
0x8
}
;
uint16_t
fOptimalFlags
=
0
;
uint16_t
fLinearFlags
=
0
;
SkTDArray
<
int
>
fColorSampleCounts
;
std
:
:
unique_ptr
<
ColorTypeInfo
[
]
>
fColorTypeInfos
;
int
fColorTypeInfoCount
=
0
;
}
;
static
const
size_t
kNumVkFormats
=
22
;
FormatInfo
fFormatTable
[
kNumVkFormats
]
;
FormatInfo
&
getFormatInfo
(
VkFormat
)
;
const
FormatInfo
&
getFormatInfo
(
VkFormat
)
const
;
VkFormat
fColorTypeToFormatTable
[
kGrColorTypeCnt
]
;
void
setColorType
(
GrColorType
std
:
:
initializer_list
<
VkFormat
>
formats
)
;
VkFormat
fPreferredStencilFormat
;
SkSTArray
<
1
GrVkYcbcrConversionInfo
>
fYcbcrInfos
;
bool
fMustSyncCommandBuffersWithQueue
=
false
;
bool
fShouldAlwaysUseDedicatedImageMemory
=
false
;
bool
fAvoidUpdateBuffers
=
false
;
bool
fSupportsSwapchain
=
false
;
bool
fSupportsPhysicalDeviceProperties2
=
false
;
bool
fSupportsMemoryRequirements2
=
false
;
bool
fSupportsBindMemory2
=
false
;
bool
fSupportsMaintenance1
=
false
;
bool
fSupportsMaintenance2
=
false
;
bool
fSupportsMaintenance3
=
false
;
bool
fSupportsDedicatedAllocation
=
false
;
bool
fSupportsExternalMemory
=
false
;
bool
fSupportsAndroidHWBExternalMemory
=
false
;
bool
fSupportsYcbcrConversion
=
false
;
bool
fSupportsProtectedMemory
=
false
;
bool
fSupportsDRMFormatModifiers
=
false
;
bool
fPreferPrimaryOverSecondaryCommandBuffers
=
true
;
bool
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
=
false
;
bool
fMustUseCoherentHostVisibleMemory
=
false
;
bool
fGpuOnlyBuffersMorePerformant
=
false
;
bool
fShouldPersistentlyMapCpuToGpuBuffers
=
true
;
int
fMaxPerPoolCachedSecondaryCommandBuffers
=
100
;
uint32_t
fMaxInputAttachmentDescriptors
=
0
;
float
fMaxSamplerAnisotropy
=
1
.
f
;
bool
fMustLoadFullImageWithDiscardableMSAA
=
false
;
bool
fSupportsDiscardableMSAAForDMSAA
=
true
;
bool
fSupportsMemorylessAttachments
=
false
;
uint32_t
fMaxDrawIndirectDrawCount
=
0
;
using
INHERITED
=
GrCaps
;
}
;
#
endif
