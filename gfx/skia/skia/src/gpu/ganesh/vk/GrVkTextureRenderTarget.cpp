#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkTextureRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkImage
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkImageView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkUtil
.
h
"
#
include
"
src
/
core
/
SkMipmap
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
define
VK_CALL
(
GPU
X
)
GR_VK_CALL
(
GPU
-
>
vkInterface
(
)
X
)
GrVkTextureRenderTarget
:
:
GrVkTextureRenderTarget
(
GrVkGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
sk_sp
<
GrVkImage
>
texture
sk_sp
<
GrVkImage
>
colorAttachment
sk_sp
<
GrVkImage
>
resolveAttachment
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
texture
-
>
isProtected
(
)
?
GrProtected
:
:
kYes
:
GrProtected
:
:
kNo
label
)
GrVkTexture
(
gpu
dimensions
std
:
:
move
(
texture
)
mipmapStatus
label
)
GrVkRenderTarget
(
gpu
dimensions
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
CreateType
:
:
kFromTextureRT
label
)
{
this
-
>
registerWithCache
(
budgeted
)
;
}
GrVkTextureRenderTarget
:
:
GrVkTextureRenderTarget
(
GrVkGpu
*
gpu
SkISize
dimensions
sk_sp
<
GrVkImage
>
texture
sk_sp
<
GrVkImage
>
colorAttachment
sk_sp
<
GrVkImage
>
resolveAttachment
GrMipmapStatus
mipmapStatus
GrWrapCacheable
cacheable
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
texture
-
>
isProtected
(
)
?
GrProtected
:
:
kYes
:
GrProtected
:
:
kNo
label
)
GrVkTexture
(
gpu
dimensions
std
:
:
move
(
texture
)
mipmapStatus
label
)
GrVkRenderTarget
(
gpu
dimensions
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
CreateType
:
:
kFromTextureRT
label
)
{
this
-
>
registerWithCacheWrapped
(
cacheable
)
;
}
bool
create_rt_attachments
(
GrVkGpu
*
gpu
SkISize
dimensions
VkFormat
format
int
sampleCnt
GrProtected
isProtected
sk_sp
<
GrVkImage
>
texture
sk_sp
<
GrVkImage
>
*
colorAttachment
sk_sp
<
GrVkImage
>
*
resolveAttachment
)
{
if
(
sampleCnt
>
1
)
{
auto
rp
=
gpu
-
>
getContext
(
)
-
>
priv
(
)
.
resourceProvider
(
)
;
sk_sp
<
GrAttachment
>
msaaAttachment
=
rp
-
>
makeMSAAAttachment
(
dimensions
GrBackendFormat
:
:
MakeVk
(
format
)
sampleCnt
isProtected
GrMemoryless
:
:
kNo
)
;
if
(
!
msaaAttachment
)
{
return
false
;
}
*
colorAttachment
=
sk_sp
<
GrVkImage
>
(
static_cast
<
GrVkImage
*
>
(
msaaAttachment
.
release
(
)
)
)
;
*
resolveAttachment
=
std
:
:
move
(
texture
)
;
}
else
{
*
colorAttachment
=
std
:
:
move
(
texture
)
;
}
return
true
;
}
sk_sp
<
GrVkTextureRenderTarget
>
GrVkTextureRenderTarget
:
:
MakeNewTextureRenderTarget
(
GrVkGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
VkFormat
format
uint32_t
mipLevels
int
sampleCnt
GrMipmapStatus
mipmapStatus
GrProtected
isProtected
std
:
:
string_view
label
)
{
sk_sp
<
GrVkImage
>
texture
=
GrVkImage
:
:
MakeTexture
(
gpu
dimensions
format
mipLevels
GrRenderable
:
:
kYes
1
budgeted
isProtected
)
;
if
(
!
texture
)
{
return
nullptr
;
}
sk_sp
<
GrVkImage
>
colorAttachment
;
sk_sp
<
GrVkImage
>
resolveAttachment
;
if
(
!
create_rt_attachments
(
gpu
dimensions
format
sampleCnt
isProtected
texture
&
colorAttachment
&
resolveAttachment
)
)
{
return
nullptr
;
}
SkASSERT
(
colorAttachment
)
;
SkASSERT
(
sampleCnt
=
=
1
|
|
resolveAttachment
)
;
return
sk_sp
<
GrVkTextureRenderTarget
>
(
new
GrVkTextureRenderTarget
(
gpu
budgeted
dimensions
std
:
:
move
(
texture
)
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
mipmapStatus
label
)
)
;
}
sk_sp
<
GrVkTextureRenderTarget
>
GrVkTextureRenderTarget
:
:
MakeWrappedTextureRenderTarget
(
GrVkGpu
*
gpu
SkISize
dimensions
int
sampleCnt
GrWrapOwnership
wrapOwnership
GrWrapCacheable
cacheable
const
GrVkImageInfo
&
info
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
mutableState
)
{
SkASSERT
(
VK_NULL_HANDLE
!
=
info
.
fImage
&
&
(
kBorrow_GrWrapOwnership
=
=
wrapOwnership
|
|
VK_NULL_HANDLE
!
=
info
.
fAlloc
.
fMemory
)
)
;
GrAttachment
:
:
UsageFlags
textureUsageFlags
=
GrAttachment
:
:
UsageFlags
:
:
kTexture
;
if
(
info
.
fImageUsageFlags
&
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
)
{
textureUsageFlags
|
=
GrAttachment
:
:
UsageFlags
:
:
kColorAttachment
;
}
sk_sp
<
GrVkImage
>
texture
=
GrVkImage
:
:
MakeWrapped
(
gpu
dimensions
info
std
:
:
move
(
mutableState
)
textureUsageFlags
wrapOwnership
cacheable
"
VkImage_MakeWrappedTextureRenderTarget
"
)
;
if
(
!
texture
)
{
return
nullptr
;
}
sk_sp
<
GrVkImage
>
colorAttachment
;
sk_sp
<
GrVkImage
>
resolveAttachment
;
if
(
!
create_rt_attachments
(
gpu
dimensions
info
.
fFormat
sampleCnt
info
.
fProtected
texture
&
colorAttachment
&
resolveAttachment
)
)
{
return
nullptr
;
}
SkASSERT
(
colorAttachment
)
;
SkASSERT
(
sampleCnt
=
=
1
|
|
resolveAttachment
)
;
GrMipmapStatus
mipmapStatus
=
info
.
fLevelCount
>
1
?
GrMipmapStatus
:
:
kDirty
:
GrMipmapStatus
:
:
kNotAllocated
;
return
sk_sp
<
GrVkTextureRenderTarget
>
(
new
GrVkTextureRenderTarget
(
gpu
dimensions
std
:
:
move
(
texture
)
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
mipmapStatus
cacheable
"
Vk_MakeWrappedTextureRenderTarget
"
)
)
;
}
size_t
GrVkTextureRenderTarget
:
:
onGpuMemorySize
(
)
const
{
#
ifdef
SK_DEBUG
SkASSERT
(
this
-
>
nonMSAAAttachment
(
)
-
>
gpuMemorySize
(
)
=
=
0
)
;
if
(
this
-
>
numSamples
(
)
>
1
)
{
SkASSERT
(
this
-
>
colorAttachment
(
)
-
>
gpuMemorySize
(
)
=
=
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
this
-
>
numSamples
(
)
GrMipmapped
:
:
kNo
)
)
;
}
#
endif
return
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
1
this
-
>
mipmapped
(
)
)
;
}
