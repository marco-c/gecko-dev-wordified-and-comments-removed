#
ifndef
GrVkRenderTarget_DEFINED
#
define
GrVkRenderTarget_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkImage
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkRenderPass
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkResourceProvider
.
h
"
class
GrVkCaps
;
class
GrVkFramebuffer
;
class
GrVkGpu
;
class
GrVkImageView
;
struct
GrVkImageInfo
;
class
GrVkRenderTarget
:
public
GrRenderTarget
{
public
:
static
sk_sp
<
GrVkRenderTarget
>
MakeWrappedRenderTarget
(
GrVkGpu
*
SkISize
int
sampleCnt
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
)
;
static
sk_sp
<
GrVkRenderTarget
>
MakeSecondaryCBRenderTarget
(
GrVkGpu
*
SkISize
const
GrVkDrawableInfo
&
vkInfo
)
;
~
GrVkRenderTarget
(
)
override
;
GrBackendFormat
backendFormat
(
)
const
override
;
using
SelfDependencyFlags
=
GrVkRenderPass
:
:
SelfDependencyFlags
;
using
LoadFromResolve
=
GrVkRenderPass
:
:
LoadFromResolve
;
const
GrVkFramebuffer
*
getFramebuffer
(
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
const
GrVkFramebuffer
*
getFramebuffer
(
const
GrVkRenderPass
&
renderPass
)
{
return
this
-
>
getFramebuffer
(
renderPass
.
hasResolveAttachment
(
)
renderPass
.
hasStencilAttachment
(
)
renderPass
.
selfDependencyFlags
(
)
renderPass
.
loadFromResolve
(
)
)
;
}
GrVkImage
*
colorAttachment
(
)
const
{
SkASSERT
(
!
this
-
>
wrapsSecondaryCommandBuffer
(
)
)
;
return
fColorAttachment
.
get
(
)
;
}
const
GrVkImageView
*
colorAttachmentView
(
)
const
{
SkASSERT
(
!
this
-
>
wrapsSecondaryCommandBuffer
(
)
)
;
return
this
-
>
colorAttachment
(
)
-
>
framebufferView
(
)
;
}
GrVkImage
*
resolveAttachment
(
)
const
{
SkASSERT
(
!
this
-
>
wrapsSecondaryCommandBuffer
(
)
)
;
return
fResolveAttachment
.
get
(
)
;
}
const
GrVkImageView
*
resolveAttachmentView
(
)
const
{
SkASSERT
(
!
this
-
>
wrapsSecondaryCommandBuffer
(
)
)
;
return
fResolveAttachment
-
>
framebufferView
(
)
;
}
GrVkImage
*
nonMSAAAttachment
(
)
const
;
GrVkImage
*
externalAttachment
(
)
const
{
return
fResolveAttachment
?
fResolveAttachment
.
get
(
)
:
fColorAttachment
.
get
(
)
;
}
const
GrVkRenderPass
*
getSimpleRenderPass
(
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
GrVkResourceProvider
:
:
CompatibleRPHandle
compatibleRenderPassHandle
(
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
bool
wrapsSecondaryCommandBuffer
(
)
const
{
return
SkToBool
(
fExternalFramebuffer
)
;
}
sk_sp
<
GrVkFramebuffer
>
externalFramebuffer
(
)
const
;
bool
canAttemptStencilAttachment
(
bool
useMSAASurface
)
const
override
;
GrBackendRenderTarget
getBackendRenderTarget
(
)
const
override
;
bool
getAttachmentsDescriptor
(
GrVkRenderPass
:
:
AttachmentsDescriptor
*
desc
GrVkRenderPass
:
:
AttachmentFlags
*
flags
bool
withResolve
bool
withStencil
)
;
static
void
ReconstructAttachmentsDescriptor
(
const
GrVkCaps
&
vkCaps
const
GrProgramInfo
&
programInfo
GrVkRenderPass
:
:
AttachmentsDescriptor
*
desc
GrVkRenderPass
:
:
AttachmentFlags
*
flags
)
;
protected
:
enum
class
CreateType
{
kDirectlyWrapped
kFromTextureRT
}
;
GrVkRenderTarget
(
GrVkGpu
*
gpu
SkISize
dimensions
sk_sp
<
GrVkImage
>
colorAttachment
sk_sp
<
GrVkImage
>
resolveImage
CreateType
createType
std
:
:
string_view
label
)
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
size_t
onGpuMemorySize
(
)
const
override
{
return
0
;
}
void
onSetLabel
(
)
override
{
}
private
:
GrVkRenderTarget
(
GrVkGpu
*
gpu
SkISize
dimensions
sk_sp
<
GrVkFramebuffer
>
externalFramebuffer
std
:
:
string_view
label
)
;
void
setFlags
(
)
;
GrVkGpu
*
getVkGpu
(
)
const
;
GrVkImage
*
dynamicMSAAAttachment
(
)
;
GrVkImage
*
msaaAttachment
(
)
;
std
:
:
pair
<
const
GrVkRenderPass
*
GrVkResourceProvider
:
:
CompatibleRPHandle
>
createSimpleRenderPass
(
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
void
createFramebuffer
(
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
bool
completeStencilAttachment
(
GrAttachment
*
stencil
bool
useMSAASurface
)
override
;
void
onSetRelease
(
sk_sp
<
RefCntedReleaseProc
>
releaseHelper
)
override
{
GrVkImage
*
attachment
=
fResolveAttachment
?
fResolveAttachment
.
get
(
)
:
fColorAttachment
.
get
(
)
;
attachment
-
>
setResourceRelease
(
std
:
:
move
(
releaseHelper
)
)
;
}
void
releaseInternalObjects
(
)
;
sk_sp
<
GrVkImage
>
fColorAttachment
;
sk_sp
<
GrVkImage
>
fResolveAttachment
;
sk_sp
<
GrVkImage
>
fDynamicMSAAAttachment
;
static
constexpr
int
kNumCachedFramebuffers
=
32
;
sk_sp
<
const
GrVkFramebuffer
>
fCachedFramebuffers
[
kNumCachedFramebuffers
]
;
const
GrVkDescriptorSet
*
fCachedInputDescriptorSet
=
nullptr
;
sk_sp
<
GrVkFramebuffer
>
fExternalFramebuffer
;
}
;
#
endif
