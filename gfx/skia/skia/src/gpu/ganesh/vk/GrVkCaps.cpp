#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkCaps
.
h
"
#
include
<
memory
>
#
include
"
include
/
core
/
SkTextureCompressionType
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrContextOptions
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkBackendContext
.
h
"
#
include
"
include
/
gpu
/
vk
/
VulkanExtensions
.
h
"
#
include
"
src
/
core
/
SkCompressedDataUtils
.
h
"
#
include
"
src
/
gpu
/
KeyBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBackendUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramDesc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStencilSettings
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrUtil
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
TestFormatColorTypeCombination
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkImage
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkUniformHandler
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkUtil
.
h
"
#
include
"
src
/
gpu
/
vk
/
VulkanInterface
.
h
"
#
include
"
src
/
gpu
/
vk
/
VulkanUtilsPriv
.
h
"
#
ifdef
SK_BUILD_FOR_ANDROID
#
include
<
sys
/
system_properties
.
h
>
#
endif
GrVkCaps
:
:
GrVkCaps
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
instanceVersion
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
&
extensions
GrProtected
isProtected
)
:
INHERITED
(
contextOptions
)
{
fMipmapSupport
=
true
;
fAnisoSupport
=
true
;
fNPOTTextureTileSupport
=
true
;
fReuseScratchTextures
=
true
;
fGpuTracingSupport
=
false
;
fOversizedStencilSupport
=
false
;
fDrawInstancedSupport
=
true
;
fSemaphoreSupport
=
true
;
fFenceSyncSupport
=
true
;
fCrossContextTextureSupport
=
true
;
fHalfFloatVertexAttributeSupport
=
true
;
fReadPixelsRowBytesSupport
=
true
;
fWritePixelsRowBytesSupport
=
true
;
fTransferFromBufferToTextureSupport
=
true
;
fTransferFromSurfaceToBufferSupport
=
true
;
fTransferFromBufferToBufferSupport
=
true
;
fMaxRenderTargetSize
=
4096
;
fMaxTextureSize
=
4096
;
fDynamicStateArrayGeometryProcessorTextureSupport
=
true
;
fTextureBarrierSupport
=
true
;
fShaderCaps
=
std
:
:
make_unique
<
GrShaderCaps
>
(
)
;
this
-
>
init
(
contextOptions
vkInterface
physDev
features
physicalDeviceVersion
extensions
isProtected
)
;
}
namespace
{
enum
class
FormatCompatibilityClass
{
k8_1_1
k16_2_1
k24_3_1
k32_4_1
k64_8_1
kBC1_RGB_8_16_1
kBC1_RGBA_8_16
kETC2_RGB_8_16
}
;
}
static
FormatCompatibilityClass
format_compatibility_class
(
VkFormat
format
)
{
switch
(
format
)
{
case
VK_FORMAT_B8G8R8A8_UNORM
:
case
VK_FORMAT_R8G8B8A8_UNORM
:
case
VK_FORMAT_A2B10G10R10_UNORM_PACK32
:
case
VK_FORMAT_A2R10G10B10_UNORM_PACK32
:
case
VK_FORMAT_R8G8B8A8_SRGB
:
case
VK_FORMAT_R16G16_UNORM
:
case
VK_FORMAT_R16G16_SFLOAT
:
return
FormatCompatibilityClass
:
:
k32_4_1
;
case
VK_FORMAT_R8_UNORM
:
return
FormatCompatibilityClass
:
:
k8_1_1
;
case
VK_FORMAT_R5G6B5_UNORM_PACK16
:
case
VK_FORMAT_R16_SFLOAT
:
case
VK_FORMAT_R8G8_UNORM
:
case
VK_FORMAT_B4G4R4A4_UNORM_PACK16
:
case
VK_FORMAT_R4G4B4A4_UNORM_PACK16
:
case
VK_FORMAT_R16_UNORM
:
return
FormatCompatibilityClass
:
:
k16_2_1
;
case
VK_FORMAT_R16G16B16A16_SFLOAT
:
case
VK_FORMAT_R16G16B16A16_UNORM
:
return
FormatCompatibilityClass
:
:
k64_8_1
;
case
VK_FORMAT_R8G8B8_UNORM
:
return
FormatCompatibilityClass
:
:
k24_3_1
;
case
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
:
return
FormatCompatibilityClass
:
:
kETC2_RGB_8_16
;
case
VK_FORMAT_BC1_RGB_UNORM_BLOCK
:
return
FormatCompatibilityClass
:
:
kBC1_RGB_8_16_1
;
case
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
:
return
FormatCompatibilityClass
:
:
kBC1_RGBA_8_16
;
default
:
SK_ABORT
(
"
Unsupported
VkFormat
"
)
;
}
}
bool
GrVkCaps
:
:
canCopyImage
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcHasYcbcr
)
const
{
if
(
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
&
&
dstSampleCnt
!
=
srcSampleCnt
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
format_compatibility_class
(
srcFormat
)
=
=
format_compatibility_class
(
dstFormat
)
;
}
bool
GrVkCaps
:
:
canCopyAsBlit
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstIsLinear
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcIsLinear
bool
srcHasYcbcr
)
const
{
if
(
!
this
-
>
formatCanBeDstofBlit
(
dstFormat
dstIsLinear
)
|
|
!
this
-
>
formatCanBeSrcofBlit
(
srcFormat
srcIsLinear
)
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
|
|
srcSampleCnt
>
1
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
canCopyAsResolve
(
VkFormat
dstFormat
int
dstSampleCnt
bool
dstHasYcbcr
VkFormat
srcFormat
int
srcSampleCnt
bool
srcHasYcbcr
)
const
{
if
(
srcSampleCnt
<
=
1
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
)
{
return
false
;
}
if
(
srcFormat
!
=
dstFormat
)
{
return
false
;
}
if
(
dstHasYcbcr
|
|
srcHasYcbcr
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
{
if
(
src
-
>
isProtected
(
)
=
=
GrProtected
:
:
kYes
&
&
dst
-
>
isProtected
(
)
!
=
GrProtected
:
:
kYes
)
{
return
false
;
}
bool
srcIsLinear
=
false
;
bool
dstIsLinear
=
false
;
int
dstSampleCnt
=
0
;
int
srcSampleCnt
=
0
;
if
(
const
GrRenderTargetProxy
*
rtProxy
=
dst
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
if
(
this
-
>
preferDiscardableMSAAAttachment
(
)
&
&
dst
-
>
asTextureProxy
(
)
&
&
rtProxy
-
>
supportsVkInputAttachment
(
)
)
{
dstSampleCnt
=
1
;
}
else
{
dstSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
}
if
(
const
GrRenderTargetProxy
*
rtProxy
=
src
-
>
asRenderTargetProxy
(
)
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
if
(
this
-
>
preferDiscardableMSAAAttachment
(
)
&
&
src
-
>
asTextureProxy
(
)
&
&
rtProxy
-
>
supportsVkInputAttachment
(
)
)
{
srcSampleCnt
=
1
;
}
else
{
srcSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
}
SkASSERT
(
(
dstSampleCnt
>
0
)
=
=
SkToBool
(
dst
-
>
asRenderTargetProxy
(
)
)
)
;
SkASSERT
(
(
srcSampleCnt
>
0
)
=
=
SkToBool
(
src
-
>
asRenderTargetProxy
(
)
)
)
;
bool
dstHasYcbcr
=
false
;
if
(
auto
ycbcr
=
dst
-
>
backendFormat
(
)
.
getVkYcbcrConversionInfo
(
)
)
{
if
(
ycbcr
-
>
isValid
(
)
)
{
dstHasYcbcr
=
true
;
}
}
bool
srcHasYcbcr
=
false
;
if
(
auto
ycbcr
=
src
-
>
backendFormat
(
)
.
getVkYcbcrConversionInfo
(
)
)
{
if
(
ycbcr
-
>
isValid
(
)
)
{
srcHasYcbcr
=
true
;
}
}
VkFormat
dstFormat
srcFormat
;
SkAssertResult
(
dst
-
>
backendFormat
(
)
.
asVkFormat
(
&
dstFormat
)
)
;
SkAssertResult
(
src
-
>
backendFormat
(
)
.
asVkFormat
(
&
srcFormat
)
)
;
const
bool
copyScales
=
srcRect
.
size
(
)
!
=
dstRect
.
size
(
)
;
if
(
!
copyScales
&
&
(
this
-
>
canCopyImage
(
dstFormat
dstSampleCnt
dstHasYcbcr
srcFormat
srcSampleCnt
srcHasYcbcr
)
|
|
this
-
>
canCopyAsResolve
(
dstFormat
dstSampleCnt
dstHasYcbcr
srcFormat
srcSampleCnt
srcHasYcbcr
)
)
)
{
return
true
;
}
return
this
-
>
canCopyAsBlit
(
dstFormat
dstSampleCnt
dstIsLinear
dstHasYcbcr
srcFormat
srcSampleCnt
srcIsLinear
srcHasYcbcr
)
;
}
template
<
typename
T
>
T
*
get_extension_feature_struct
(
const
VkPhysicalDeviceFeatures2
&
features
VkStructureType
type
)
{
struct
CommonVulkanHeader
{
VkStructureType
sType
;
void
*
pNext
;
}
;
void
*
pNext
=
features
.
pNext
;
while
(
pNext
)
{
CommonVulkanHeader
*
header
=
static_cast
<
CommonVulkanHeader
*
>
(
pNext
)
;
if
(
header
-
>
sType
=
=
type
)
{
return
static_cast
<
T
*
>
(
pNext
)
;
}
pNext
=
header
-
>
pNext
;
}
return
nullptr
;
}
void
GrVkCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceFeatures2
&
features
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
&
extensions
GrProtected
isProtected
)
{
VkPhysicalDeviceProperties
properties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties
(
physDev
&
properties
)
)
;
VkPhysicalDeviceMemoryProperties
memoryProperties
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceMemoryProperties
(
physDev
&
memoryProperties
)
)
;
SkASSERT
(
physicalDeviceVersion
<
=
properties
.
apiVersion
)
;
if
(
extensions
.
hasExtension
(
VK_KHR_SWAPCHAIN_EXTENSION_NAME
1
)
)
{
fSupportsSwapchain
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
1
)
)
{
fSupportsPhysicalDeviceProperties2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
1
)
)
{
fSupportsMemoryRequirements2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
1
)
)
{
fSupportsBindMemory2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE1_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance1
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE2_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance2
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
extensions
.
hasExtension
(
VK_KHR_MAINTENANCE3_EXTENSION_NAME
1
)
)
{
fSupportsMaintenance3
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
)
)
{
fSupportsDedicatedAllocation
=
true
;
}
if
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
1
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
&
&
extensions
.
hasExtension
(
VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
1
)
&
&
this
-
>
supportsDedicatedAllocation
(
)
)
)
{
fSupportsExternalMemory
=
true
;
}
#
ifdef
SK_BUILD_FOR_ANDROID
if
(
extensions
.
hasExtension
(
VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
2
)
&
&
this
-
>
supportsExternalMemory
(
)
&
&
this
-
>
supportsBindMemory2
(
)
)
{
fSupportsAndroidHWBExternalMemory
=
true
;
fSupportsAHardwareBufferImages
=
true
;
}
#
endif
auto
ycbcrFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceSamplerYcbcrConversionFeatures
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
)
;
if
(
ycbcrFeatures
&
&
ycbcrFeatures
-
>
samplerYcbcrConversion
&
&
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
|
|
(
extensions
.
hasExtension
(
VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
1
)
&
&
this
-
>
supportsMaintenance1
(
)
&
&
this
-
>
supportsBindMemory2
(
)
&
&
this
-
>
supportsMemoryRequirements2
(
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
)
)
{
fSupportsYcbcrConversion
=
true
;
}
fYcbcrInfos
.
push_back
(
GrVkYcbcrConversionInfo
(
)
)
;
if
(
(
isProtected
=
=
GrProtected
:
:
kYes
)
&
&
(
physicalDeviceVersion
>
=
VK_MAKE_VERSION
(
1
1
0
)
)
)
{
fSupportsProtectedMemory
=
true
;
fAvoidUpdateBuffers
=
true
;
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
if
(
extensions
.
hasExtension
(
VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
1
)
)
{
fSupportsDRMFormatModifiers
=
true
;
}
fMaxInputAttachmentDescriptors
=
properties
.
limits
.
maxDescriptorSetInputAttachments
;
fMaxSamplerAnisotropy
=
properties
.
limits
.
maxSamplerAnisotropy
;
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fPreferDiscardableMSAAAttachment
=
true
;
fSupportsMemorylessAttachments
=
true
;
}
this
-
>
initGrCaps
(
vkInterface
physDev
properties
memoryProperties
features
extensions
)
;
this
-
>
initShaderCaps
(
properties
features
)
;
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fPreferFullscreenClears
=
true
;
}
if
(
properties
.
vendorID
=
=
kNvidia_VkVendor
|
|
properties
.
vendorID
=
=
kAMD_VkVendor
)
{
fGpuOnlyBuffersMorePerformant
=
true
;
fShouldPersistentlyMapCpuToGpuBuffers
=
false
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fAvoidUpdateBuffers
=
true
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fMaxPushConstantsSize
=
0
;
}
fNativeDrawIndirectSupport
=
features
.
features
.
drawIndirectFirstInstance
;
if
(
properties
.
vendorID
=
=
kQualcomm_VkVendor
)
{
fNativeDrawIndirectSupport
=
false
;
}
if
(
fNativeDrawIndirectSupport
)
{
fMaxDrawIndirectDrawCount
=
properties
.
limits
.
maxDrawIndirectCount
;
SkASSERT
(
fMaxDrawIndirectDrawCount
=
=
1
|
|
features
.
features
.
multiDrawIndirect
)
;
}
#
ifdef
SK_BUILD_FOR_UNIX
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
#
endif
this
-
>
initFormatTable
(
contextOptions
vkInterface
physDev
properties
)
;
this
-
>
initStencilFormat
(
vkInterface
physDev
)
;
if
(
contextOptions
.
fMaxCachedVulkanSecondaryCommandBuffers
>
=
0
)
{
fMaxPerPoolCachedSecondaryCommandBuffers
=
contextOptions
.
fMaxCachedVulkanSecondaryCommandBuffers
;
}
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
properties
)
;
}
this
-
>
finishInitialization
(
contextOptions
)
;
}
void
GrVkCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
properties
)
{
#
if
defined
(
SK_BUILD_FOR_WIN
)
if
(
kNvidia_VkVendor
=
=
properties
.
vendorID
|
|
kIntel_VkVendor
=
=
properties
.
vendorID
)
{
fMustSyncCommandBuffersWithQueue
=
true
;
}
#
elif
defined
(
SK_BUILD_FOR_ANDROID
)
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fMustSyncCommandBuffersWithQueue
=
true
;
}
#
endif
int
androidAPIVersion
=
0
;
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
char
androidAPIVersionStr
[
PROP_VALUE_MAX
]
;
int
strLength
=
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
androidAPIVersionStr
)
;
androidAPIVersion
=
(
strLength
=
=
0
)
?
0
:
atoi
(
androidAPIVersionStr
)
;
#
endif
if
(
fSupportsProtectedMemory
&
&
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
)
{
if
(
androidAPIVersion
<
=
28
)
{
fSupportsProtectedMemory
=
false
;
}
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
&
&
androidAPIVersion
<
=
28
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
&
&
androidAPIVersion
<
=
28
)
{
fPreferPrimaryOverSecondaryCommandBuffers
=
false
;
fTextureBarrierSupport
=
false
;
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
}
if
(
properties
.
vendorID
=
=
kQualcomm_VkVendor
&
&
androidAPIVersion
<
=
28
)
{
fPreferDiscardableMSAAAttachment
=
false
;
fSupportsDiscardableMSAAForDMSAA
=
false
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fShaderCaps
-
>
fColorSpaceMathNeedsFloat
=
true
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
|
|
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMustInvalidatePrimaryCmdBufferStateAfterClearAttachments
=
true
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
|
|
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fMustLoadFullImageWithDiscardableMSAA
=
true
;
}
#
ifdef
SK_BUILD_FOR_UNIX
if
(
kIntel_VkVendor
=
=
properties
.
vendorID
)
{
fMustUseCoherentHostVisibleMemory
=
true
;
}
#
endif
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fAvoidWritePixelsFastPath
=
true
;
}
if
(
kAMD_VkVendor
=
=
properties
.
vendorID
)
{
fMaxVertexAttributes
=
std
:
:
min
(
fMaxVertexAttributes
32
)
;
}
if
(
kQualcomm_VkVendor
=
=
properties
.
vendorID
)
{
fTextureBarrierSupport
=
false
;
}
#
ifdef
SK_BUILD_FOR_WIN
if
(
kIntel_VkVendor
=
=
properties
.
vendorID
&
&
GetIntelGen
(
GetIntelGPUType
(
properties
.
deviceID
)
)
>
=
9
)
{
fTextureBarrierSupport
=
false
;
}
#
endif
if
(
properties
.
vendorID
=
=
kARM_VkVendor
&
&
androidAPIVersion
<
=
28
)
{
fNativeDrawIndirectSupport
=
false
;
}
if
(
kImagination_VkVendor
=
=
properties
.
vendorID
)
{
fShaderCaps
-
>
fAtan2ImplementedAsAtanYOverX
=
true
;
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fShaderCaps
-
>
fRewriteMatrixVectorMultiply
=
true
;
}
}
void
GrVkCaps
:
:
initGrCaps
(
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceMemoryProperties
&
memoryProperties
const
VkPhysicalDeviceFeatures2
&
features
const
skgpu
:
:
VulkanExtensions
&
extensions
)
{
static
const
uint32_t
kMaxVertexAttributes
=
64
;
fMaxVertexAttributes
=
std
:
:
min
(
properties
.
limits
.
maxVertexInputAttributes
kMaxVertexAttributes
)
;
if
(
properties
.
limits
.
standardSampleLocations
)
{
fSampleLocationsSupport
=
true
;
}
if
(
extensions
.
hasExtension
(
VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
1
)
)
{
fConservativeRasterSupport
=
true
;
}
fWireframeSupport
=
true
;
fMaxRenderTargetSize
=
std
:
:
min
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
fMaxTextureSize
=
std
:
:
min
(
properties
.
limits
.
maxImageDimension2D
(
uint32_t
)
INT_MAX
)
;
fMaxPreferredRenderTargetSize
=
fMaxRenderTargetSize
;
fMaxPushConstantsSize
=
std
:
:
min
(
properties
.
limits
.
maxPushConstantsSize
(
uint32_t
)
INT_MAX
)
;
fBufferMapThreshold
=
0
;
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
|
kAsyncRead_MapFlag
;
fOversizedStencilSupport
=
true
;
if
(
extensions
.
hasExtension
(
VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
2
)
&
&
this
-
>
supportsPhysicalDeviceProperties2
(
)
)
{
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
blendProps
;
blendProps
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
;
blendProps
.
pNext
=
nullptr
;
VkPhysicalDeviceProperties2
props
;
props
.
sType
=
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
;
props
.
pNext
=
&
blendProps
;
GR_VK_CALL
(
vkInterface
GetPhysicalDeviceProperties2
(
physDev
&
props
)
)
;
if
(
blendProps
.
advancedBlendAllOperations
=
=
VK_TRUE
)
{
fShaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
auto
blendFeatures
=
get_extension_feature_struct
<
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
>
(
features
VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
)
;
if
(
blendFeatures
&
&
blendFeatures
-
>
advancedBlendCoherentOperations
=
=
VK_TRUE
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
}
else
{
fBlendEquationSupport
=
kAdvanced_BlendEquationSupport
;
}
}
}
if
(
kARM_VkVendor
=
=
properties
.
vendorID
)
{
fShouldCollapseSrcOverToSrcWhenAble
=
true
;
}
}
void
GrVkCaps
:
:
initShaderCaps
(
const
VkPhysicalDeviceProperties
&
properties
const
VkPhysicalDeviceFeatures2
&
features
)
{
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fVersionDeclString
=
"
#
version
330
\
n
"
;
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
shaderCaps
-
>
fFlatInterpolationSupport
=
true
;
shaderCaps
-
>
fPreferFlatInterpolation
=
kQualcomm_VkVendor
!
=
properties
.
vendorID
;
shaderCaps
-
>
fSampleMaskSupport
=
true
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fExplicitTextureLodSupport
=
true
;
shaderCaps
-
>
fDualSourceBlendingSupport
=
features
.
features
.
dualSrcBlend
;
shaderCaps
-
>
fIntegerSupport
=
true
;
shaderCaps
-
>
fNonsquareMatrixSupport
=
true
;
shaderCaps
-
>
fInverseHyperbolicSupport
=
true
;
shaderCaps
-
>
fVertexIDSupport
=
true
;
shaderCaps
-
>
fInfinitySupport
=
true
;
shaderCaps
-
>
fNonconstantArrayIndexSupport
=
true
;
shaderCaps
-
>
fBitManipulationSupport
=
true
;
shaderCaps
-
>
fFloatIs32Bits
=
true
;
shaderCaps
-
>
fHalfIs32Bits
=
false
;
shaderCaps
-
>
fMaxFragmentSamplers
=
std
:
:
min
(
std
:
:
min
(
properties
.
limits
.
maxPerStageDescriptorSampledImages
properties
.
limits
.
maxPerStageDescriptorSamplers
)
(
uint32_t
)
INT_MAX
)
;
}
bool
stencil_format_supported
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
return
SkToBool
(
VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
&
props
.
optimalTilingFeatures
)
;
}
void
GrVkCaps
:
:
initStencilFormat
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
)
{
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_S8_UINT
)
)
{
fPreferredStencilFormat
=
VK_FORMAT_S8_UINT
;
}
else
if
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D24_UNORM_S8_UINT
)
)
{
fPreferredStencilFormat
=
VK_FORMAT_D24_UNORM_S8_UINT
;
}
else
{
SkASSERT
(
stencil_format_supported
(
interface
physDev
VK_FORMAT_D32_SFLOAT_S8_UINT
)
)
;
fPreferredStencilFormat
=
VK_FORMAT_D32_SFLOAT_S8_UINT
;
}
}
static
bool
format_is_srgb
(
VkFormat
format
)
{
SkASSERT
(
GrVkFormatIsSupported
(
format
)
)
;
switch
(
format
)
{
case
VK_FORMAT_R8G8B8A8_SRGB
:
return
true
;
default
:
return
false
;
}
}
static
constexpr
VkFormat
kVkFormats
[
]
=
{
VK_FORMAT_R8G8B8A8_UNORM
VK_FORMAT_R8_UNORM
VK_FORMAT_B8G8R8A8_UNORM
VK_FORMAT_R5G6B5_UNORM_PACK16
VK_FORMAT_R16G16B16A16_SFLOAT
VK_FORMAT_R16_SFLOAT
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8_UNORM
VK_FORMAT_A2B10G10R10_UNORM_PACK32
VK_FORMAT_A2R10G10B10_UNORM_PACK32
VK_FORMAT_B4G4R4A4_UNORM_PACK16
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_R8G8B8A8_SRGB
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
VK_FORMAT_BC1_RGB_UNORM_BLOCK
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
VK_FORMAT_R16_UNORM
VK_FORMAT_R16G16_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
VK_FORMAT_R16G16B16A16_UNORM
VK_FORMAT_R16G16_SFLOAT
}
;
void
GrVkCaps
:
:
setColorType
(
GrColorType
colorType
std
:
:
initializer_list
<
VkFormat
>
formats
)
{
#
ifdef
SK_DEBUG
for
(
size_t
i
=
0
;
i
<
kNumVkFormats
;
+
+
i
)
{
const
auto
&
formatInfo
=
fFormatTable
[
i
]
;
for
(
int
j
=
0
;
j
<
formatInfo
.
fColorTypeInfoCount
;
+
+
j
)
{
const
auto
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
j
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
&
&
!
SkToBool
(
ctInfo
.
fFlags
&
ColorTypeInfo
:
:
kWrappedOnly_Flag
)
)
{
bool
found
=
false
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
if
(
kVkFormats
[
i
]
=
=
*
it
)
{
found
=
true
;
}
}
SkASSERT
(
found
)
;
}
}
}
#
endif
int
idx
=
static_cast
<
int
>
(
colorType
)
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
*
it
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
fColorTypeToFormatTable
[
idx
]
=
*
it
;
return
;
}
}
}
}
const
GrVkCaps
:
:
FormatInfo
&
GrVkCaps
:
:
getFormatInfo
(
VkFormat
format
)
const
{
GrVkCaps
*
nonConstThis
=
const_cast
<
GrVkCaps
*
>
(
this
)
;
return
nonConstThis
-
>
getFormatInfo
(
format
)
;
}
GrVkCaps
:
:
FormatInfo
&
GrVkCaps
:
:
getFormatInfo
(
VkFormat
format
)
{
static_assert
(
std
:
:
size
(
kVkFormats
)
=
=
GrVkCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
kVkFormats
)
;
+
+
i
)
{
if
(
kVkFormats
[
i
]
=
=
format
)
{
return
fFormatTable
[
i
]
;
}
}
static
FormatInfo
kInvalidFormat
;
return
kInvalidFormat
;
}
void
GrVkCaps
:
:
initFormatTable
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
)
{
static_assert
(
std
:
:
size
(
kVkFormats
)
=
=
GrVkCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
std
:
:
fill_n
(
fColorTypeToFormatTable
kGrColorTypeCnt
VK_FORMAT_UNDEFINED
)
;
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_8888
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
:
:
RGB1
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
3
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kR_8
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_8
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kGray_8
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
rrr1
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B8G8R8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kBGRA_8888
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R5G6B5_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kBGR_565
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_F16_Clamped
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
GrColorType
:
:
kRGB_888
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_88
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_A2B10G10R10_UNORM_PACK32
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_1010102
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_A2R10G10B10_UNORM_PACK32
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kBGRA_1010102
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B4G4R4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kABGR_4444
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
:
:
BGRA
(
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
:
:
BGRA
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R4G4B4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kABGR_4444
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_SRGB
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_8888_SRGB
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kAlpha_16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_1616
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGBA_16161616
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRG_F16
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
}
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kWrappedOnly_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
}
if
(
SkToBool
(
info
.
fOptimalFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
GrColorType
ct
=
GrColorType
:
:
kRGB_888x
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kWrappedOnly_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_BC1_RGB_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
contextOptions
interface
physDev
properties
format
)
;
}
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_8
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kBGR_565
{
VK_FORMAT_R5G6B5_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kABGR_4444
{
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_B4G4R4A4_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_8888
{
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_8888_SRGB
{
VK_FORMAT_R8G8B8A8_SRGB
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGB_888x
{
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_88
{
VK_FORMAT_R8G8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kBGRA_8888
{
VK_FORMAT_B8G8R8A8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_1010102
{
VK_FORMAT_A2B10G10R10_UNORM_PACK32
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kBGRA_1010102
{
VK_FORMAT_A2R10G10B10_UNORM_PACK32
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kGray_8
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_F16
{
VK_FORMAT_R16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_F16
{
VK_FORMAT_R16G16B16A16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_F16_Clamped
{
VK_FORMAT_R16G16B16A16_SFLOAT
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kAlpha_16
{
VK_FORMAT_R16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_1616
{
VK_FORMAT_R16G16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRGBA_16161616
{
VK_FORMAT_R16G16B16A16_UNORM
}
)
;
this
-
>
setColorType
(
GrColorType
:
:
kRG_F16
{
VK_FORMAT_R16G16_SFLOAT
}
)
;
}
void
GrVkCaps
:
:
FormatInfo
:
:
InitFormatFlags
(
VkFormatFeatureFlags
vkFlags
uint16_t
*
flags
)
{
if
(
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
&
vkFlags
)
&
&
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kTexturable_Flag
;
if
(
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kRenderable_Flag
;
}
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_SRC_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitSrc_Flag
;
}
if
(
SkToBool
(
VK_FORMAT_FEATURE_BLIT_DST_BIT
&
vkFlags
)
)
{
*
flags
=
*
flags
|
kBlitDst_Flag
;
}
}
void
GrVkCaps
:
:
FormatInfo
:
:
initSampleCounts
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
physProps
VkFormat
format
)
{
VkImageUsageFlags
usage
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
|
VK_IMAGE_USAGE_SAMPLED_BIT
|
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
VkImageFormatProperties
properties
;
GR_VK_CALL
(
interface
GetPhysicalDeviceImageFormatProperties
(
physDev
format
VK_IMAGE_TYPE_2D
VK_IMAGE_TILING_OPTIMAL
usage
0
&
properties
)
)
;
VkSampleCountFlags
flags
=
properties
.
sampleCounts
;
if
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
{
fColorSampleCounts
.
push_back
(
1
)
;
}
if
(
kImagination_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
kIntel_VkVendor
=
=
physProps
.
vendorID
)
{
if
(
GetIntelGen
(
GetIntelGPUType
(
physProps
.
deviceID
)
)
<
12
|
|
!
contextOptions
.
fAllowMSAAOnNewIntel
)
{
return
;
}
}
if
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
{
fColorSampleCounts
.
push_back
(
2
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
{
fColorSampleCounts
.
push_back
(
4
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
{
fColorSampleCounts
.
push_back
(
8
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
{
fColorSampleCounts
.
push_back
(
16
)
;
}
}
void
GrVkCaps
:
:
FormatInfo
:
:
init
(
const
GrContextOptions
&
contextOptions
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
VkFormat
format
)
{
VkFormatProperties
props
;
memset
(
&
props
0
sizeof
(
VkFormatProperties
)
)
;
GR_VK_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
props
)
)
;
InitFormatFlags
(
props
.
linearTilingFeatures
&
fLinearFlags
)
;
InitFormatFlags
(
props
.
optimalTilingFeatures
&
fOptimalFlags
)
;
if
(
fOptimalFlags
&
kRenderable_Flag
)
{
this
-
>
initSampleCounts
(
contextOptions
interface
physDev
properties
format
)
;
}
}
static
bool
backend_format_is_external
(
const
GrBackendFormat
&
format
)
{
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
if
(
ycbcrInfo
-
>
isValid
(
)
&
&
ycbcrInfo
-
>
fExternalFormat
!
=
0
)
{
#
ifdef
SK_DEBUG
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
SkASSERT
(
vkFormat
=
=
VK_FORMAT_UNDEFINED
)
;
#
endif
return
true
;
}
return
false
;
}
bool
GrVkCaps
:
:
isFormatSRGB
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
if
(
backend_format_is_external
(
format
)
)
{
return
false
;
}
return
format_is_srgb
(
vkFormat
)
;
}
bool
GrVkCaps
:
:
isFormatTexturable
(
const
GrBackendFormat
&
format
GrTextureType
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
if
(
backend_format_is_external
(
format
)
)
{
return
true
;
}
return
this
-
>
isVkFormatTexturable
(
vkFormat
)
;
}
bool
GrVkCaps
:
:
isVkFormatTexturable
(
VkFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
return
SkToBool
(
FormatInfo
:
:
kTexturable_Flag
&
info
.
fOptimalFlags
)
;
}
bool
GrVkCaps
:
:
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
if
(
!
this
-
>
isFormatRenderable
(
format
sampleCount
)
)
{
return
false
;
}
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
if
(
!
SkToBool
(
info
.
colorTypeFlags
(
ct
)
&
ColorTypeInfo
:
:
kRenderable_Flag
)
)
{
return
false
;
}
return
true
;
}
bool
GrVkCaps
:
:
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
return
this
-
>
isFormatRenderable
(
vkFormat
sampleCount
)
;
}
bool
GrVkCaps
:
:
isFormatRenderable
(
VkFormat
format
int
sampleCount
)
const
{
return
sampleCount
<
=
this
-
>
maxRenderTargetSampleCount
(
format
)
;
}
int
GrVkCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
0
;
}
return
this
-
>
getRenderTargetSampleCount
(
requestedCount
vkFormat
)
;
}
int
GrVkCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
VkFormat
format
)
const
{
requestedCount
=
std
:
:
max
(
1
requestedCount
)
;
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
int
count
=
info
.
fColorSampleCounts
.
size
(
)
;
if
(
!
count
)
{
return
0
;
}
if
(
1
=
=
requestedCount
)
{
SkASSERT
(
info
.
fColorSampleCounts
.
size
(
)
&
&
info
.
fColorSampleCounts
[
0
]
=
=
1
)
;
return
1
;
}
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
info
.
fColorSampleCounts
[
i
]
>
=
requestedCount
)
{
return
info
.
fColorSampleCounts
[
i
]
;
}
}
return
0
;
}
int
GrVkCaps
:
:
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
0
;
}
return
this
-
>
maxRenderTargetSampleCount
(
vkFormat
)
;
}
int
GrVkCaps
:
:
maxRenderTargetSampleCount
(
VkFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
auto
&
table
=
info
.
fColorSampleCounts
;
if
(
!
table
.
size
(
)
)
{
return
0
;
}
return
table
[
table
.
size
(
)
-
1
]
;
}
static
inline
size_t
align_to_4
(
size_t
v
)
{
switch
(
v
&
0b11
)
{
case
0
:
return
v
;
case
2
:
return
2
*
v
;
default
:
return
4
*
v
;
}
}
GrCaps
:
:
SupportedWrite
GrVkCaps
:
:
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
{
VkFormat
vkFormat
;
if
(
!
surfaceFormat
.
asVkFormat
(
&
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
if
(
backend_format_is_external
(
surfaceFormat
)
|
|
skgpu
:
:
VkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
size_t
offsetAlignment
=
align_to_4
(
skgpu
:
:
VkFormatBytesPerBlock
(
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
surfaceColorType
)
{
return
{
ctInfo
.
fTransferColorType
offsetAlignment
}
;
}
}
return
{
GrColorType
:
:
kUnknown
0
}
;
}
GrCaps
:
:
SurfaceReadPixelsSupport
GrVkCaps
:
:
surfaceSupportsReadPixels
(
const
GrSurface
*
surface
)
const
{
if
(
surface
-
>
isProtected
(
)
)
{
return
SurfaceReadPixelsSupport
:
:
kUnsupported
;
}
if
(
auto
tex
=
static_cast
<
const
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
auto
texImage
=
tex
-
>
textureImage
(
)
;
if
(
!
texImage
)
{
return
SurfaceReadPixelsSupport
:
:
kUnsupported
;
}
if
(
texImage
-
>
ycbcrConversionInfo
(
)
.
isValid
(
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
if
(
skgpu
:
:
VkFormatIsCompressed
(
texImage
-
>
imageFormat
(
)
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
return
SurfaceReadPixelsSupport
:
:
kSupported
;
}
else
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
if
(
rt
-
>
numSamples
(
)
>
1
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
return
SurfaceReadPixelsSupport
:
:
kSupported
;
}
return
SurfaceReadPixelsSupport
:
:
kUnsupported
;
}
GrColorType
GrVkCaps
:
:
transferColorType
(
VkFormat
vkFormat
GrColorType
surfaceColorType
)
const
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
surfaceColorType
)
{
return
info
.
fColorTypeInfos
[
i
]
.
fTransferColorType
;
}
}
return
GrColorType
:
:
kUnknown
;
}
bool
GrVkCaps
:
:
onSurfaceSupportsWritePixels
(
const
GrSurface
*
surface
)
const
{
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
return
rt
-
>
numSamples
(
)
<
=
1
&
&
SkToBool
(
surface
-
>
asTexture
(
)
)
;
}
if
(
auto
tex
=
static_cast
<
const
GrVkTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
auto
texImage
=
tex
-
>
textureImage
(
)
;
if
(
!
texImage
)
{
return
false
;
}
if
(
texImage
-
>
ycbcrConversionInfo
(
)
.
isValid
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
GrVkCaps
:
:
onAreColorTypeAndFormatCompatible
(
GrColorType
ct
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
if
(
!
format
.
asVkFormat
(
&
vkFormat
)
)
{
return
false
;
}
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
if
(
ycbcrInfo
-
>
isValid
(
)
&
&
!
skgpu
:
:
VkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
if
(
VK_FORMAT_UNDEFINED
=
=
vkFormat
&
&
ycbcrInfo
-
>
fExternalFormat
!
=
0
)
{
return
true
;
}
return
false
;
}
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
ct
)
{
return
true
;
}
}
return
false
;
}
GrBackendFormat
GrVkCaps
:
:
onGetDefaultBackendFormat
(
GrColorType
ct
)
const
{
VkFormat
format
=
this
-
>
getFormatFromColorType
(
ct
)
;
if
(
format
=
=
VK_FORMAT_UNDEFINED
)
{
return
{
}
;
}
return
GrBackendFormat
:
:
MakeVk
(
format
)
;
}
bool
GrVkCaps
:
:
onSupportsDynamicMSAA
(
const
GrRenderTargetProxy
*
rtProxy
)
const
{
return
this
-
>
supportsDiscardableMSAAForDMSAA
(
)
&
&
rtProxy
-
>
supportsVkInputAttachment
(
)
&
&
rtProxy
-
>
numSamples
(
)
=
=
1
;
}
bool
GrVkCaps
:
:
renderTargetSupportsDiscardableMSAA
(
const
GrVkRenderTarget
*
rt
)
const
{
return
rt
-
>
resolveAttachment
(
)
&
&
rt
-
>
resolveAttachment
(
)
-
>
supportsInputAttachmentUsage
(
)
&
&
(
(
rt
-
>
numSamples
(
)
>
1
&
&
this
-
>
preferDiscardableMSAAAttachment
(
)
)
|
|
(
rt
-
>
numSamples
(
)
=
=
1
&
&
this
-
>
supportsDiscardableMSAAForDMSAA
(
)
)
)
;
}
bool
GrVkCaps
:
:
programInfoWillUseDiscardableMSAA
(
const
GrProgramInfo
&
programInfo
)
const
{
return
programInfo
.
targetHasVkResolveAttachmentWithInput
(
)
&
&
programInfo
.
numSamples
(
)
>
1
&
&
(
(
programInfo
.
targetsNumSamples
(
)
>
1
&
&
this
-
>
preferDiscardableMSAAAttachment
(
)
)
|
|
(
programInfo
.
targetsNumSamples
(
)
=
=
1
&
&
this
-
>
supportsDiscardableMSAAForDMSAA
(
)
)
)
;
}
GrBackendFormat
GrVkCaps
:
:
getBackendFormatFromCompressionType
(
SkTextureCompressionType
compressionType
)
const
{
switch
(
compressionType
)
{
case
SkTextureCompressionType
:
:
kNone
:
return
{
}
;
case
SkTextureCompressionType
:
:
kETC2_RGB8_UNORM
:
if
(
this
-
>
isVkFormatTexturable
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
)
)
{
return
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
)
;
}
return
{
}
;
case
SkTextureCompressionType
:
:
kBC1_RGB8_UNORM
:
if
(
this
-
>
isVkFormatTexturable
(
VK_FORMAT_BC1_RGB_UNORM_BLOCK
)
)
{
return
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_BC1_RGB_UNORM_BLOCK
)
;
}
return
{
}
;
case
SkTextureCompressionType
:
:
kBC1_RGBA8_UNORM
:
if
(
this
-
>
isVkFormatTexturable
(
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
)
)
{
return
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
)
;
}
return
{
}
;
}
SkUNREACHABLE
;
}
skgpu
:
:
Swizzle
GrVkCaps
:
:
onGetReadSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
const
auto
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
if
(
ycbcrInfo
-
>
isValid
(
)
&
&
ycbcrInfo
-
>
fExternalFormat
!
=
0
)
{
return
skgpu
:
:
Swizzle
{
"
rgba
"
}
;
}
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fReadSwizzle
;
}
}
SkDEBUGFAILF
(
"
Illegal
color
type
(
%
d
)
and
format
(
%
d
)
combination
.
"
(
int
)
colorType
(
int
)
vkFormat
)
;
return
{
}
;
}
skgpu
:
:
Swizzle
GrVkCaps
:
:
getWriteSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fWriteSwizzle
;
}
}
SkDEBUGFAILF
(
"
Illegal
color
type
(
%
d
)
and
format
(
%
d
)
combination
.
"
(
int
)
colorType
(
int
)
vkFormat
)
;
return
{
}
;
}
GrDstSampleFlags
GrVkCaps
:
:
onGetDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
rt
)
const
{
bool
isMSAAWithResolve
=
rt
-
>
numSamples
(
)
>
1
&
&
rt
-
>
asTextureProxy
(
)
;
if
(
!
isMSAAWithResolve
&
&
rt
-
>
supportsVkInputAttachment
(
)
)
{
return
GrDstSampleFlags
:
:
kRequiresTextureBarrier
|
GrDstSampleFlags
:
:
kAsInputAttachment
;
}
return
GrDstSampleFlags
:
:
kNone
;
}
uint64_t
GrVkCaps
:
:
computeFormatKey
(
const
GrBackendFormat
&
format
)
const
{
VkFormat
vkFormat
;
SkAssertResult
(
format
.
asVkFormat
(
&
vkFormat
)
)
;
#
ifdef
SK_DEBUG
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
SkASSERT
(
ycbcrInfo
)
;
SkASSERT
(
!
ycbcrInfo
-
>
isValid
(
)
|
|
ycbcrInfo
-
>
fExternalFormat
=
=
0
)
;
#
endif
return
(
uint64_t
)
vkFormat
;
}
GrCaps
:
:
SupportedRead
GrVkCaps
:
:
onSupportedReadPixelsColorType
(
GrColorType
srcColorType
const
GrBackendFormat
&
srcBackendFormat
GrColorType
dstColorType
)
const
{
VkFormat
vkFormat
;
if
(
!
srcBackendFormat
.
asVkFormat
(
&
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
if
(
skgpu
:
:
VkFormatNeedsYcbcrSampler
(
vkFormat
)
)
{
return
{
GrColorType
:
:
kUnknown
0
}
;
}
SkTextureCompressionType
compression
=
GrBackendFormatToCompressionType
(
srcBackendFormat
)
;
if
(
compression
!
=
SkTextureCompressionType
:
:
kNone
)
{
return
{
SkTextureCompressionTypeIsOpaque
(
compression
)
?
GrColorType
:
:
kRGB_888x
:
GrColorType
:
:
kRGBA_8888
0
}
;
}
size_t
offsetAlignment
=
align_to_4
(
skgpu
:
:
VkFormatBytesPerBlock
(
vkFormat
)
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
vkFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
srcColorType
)
{
return
{
ctInfo
.
fTransferColorType
offsetAlignment
}
;
}
}
return
{
GrColorType
:
:
kUnknown
0
}
;
}
int
GrVkCaps
:
:
getFragmentUniformBinding
(
)
const
{
return
GrVkUniformHandler
:
:
kUniformBinding
;
}
int
GrVkCaps
:
:
getFragmentUniformSet
(
)
const
{
return
GrVkUniformHandler
:
:
kUniformBufferDescSet
;
}
void
GrVkCaps
:
:
addExtraSamplerKey
(
skgpu
:
:
KeyBuilder
*
b
GrSamplerState
samplerState
const
GrBackendFormat
&
format
)
const
{
const
GrVkYcbcrConversionInfo
*
ycbcrInfo
=
format
.
getVkYcbcrConversionInfo
(
)
;
if
(
!
ycbcrInfo
)
{
return
;
}
GrVkSampler
:
:
Key
key
=
GrVkSampler
:
:
GenerateKey
(
samplerState
*
ycbcrInfo
)
;
constexpr
size_t
numInts
=
(
sizeof
(
key
)
+
3
)
/
4
;
uint32_t
tmp
[
numInts
]
;
memcpy
(
tmp
&
key
sizeof
(
key
)
)
;
for
(
size_t
i
=
0
;
i
<
numInts
;
+
+
i
)
{
b
-
>
add32
(
tmp
[
i
]
)
;
}
}
GrProgramDesc
GrVkCaps
:
:
makeDesc
(
GrRenderTarget
*
rt
const
GrProgramInfo
&
programInfo
ProgramDescOverrideFlags
overrideFlags
)
const
{
GrProgramDesc
desc
;
GrProgramDesc
:
:
Build
(
&
desc
programInfo
*
this
)
;
skgpu
:
:
KeyBuilder
b
(
desc
.
key
(
)
)
;
b
.
add32
(
GrVkGpu
:
:
kShader_PersistentCacheKeyType
)
;
GrVkRenderPass
:
:
SelfDependencyFlags
selfDepFlags
=
GrVkRenderPass
:
:
SelfDependencyFlags
:
:
kNone
;
if
(
programInfo
.
renderPassBarriers
(
)
&
GrXferBarrierFlags
:
:
kBlend
)
{
selfDepFlags
|
=
GrVkRenderPass
:
:
SelfDependencyFlags
:
:
kForNonCoherentAdvBlend
;
}
if
(
programInfo
.
renderPassBarriers
(
)
&
GrXferBarrierFlags
:
:
kTexture
)
{
selfDepFlags
|
=
GrVkRenderPass
:
:
SelfDependencyFlags
:
:
kForInputAttachment
;
}
bool
needsResolve
=
this
-
>
programInfoWillUseDiscardableMSAA
(
programInfo
)
;
bool
forceLoadFromResolve
=
overrideFlags
&
GrCaps
:
:
ProgramDescOverrideFlags
:
:
kVulkanHasResolveLoadSubpass
;
SkASSERT
(
!
forceLoadFromResolve
|
|
needsResolve
)
;
GrVkRenderPass
:
:
LoadFromResolve
loadFromResolve
=
GrVkRenderPass
:
:
LoadFromResolve
:
:
kNo
;
if
(
needsResolve
&
&
(
programInfo
.
colorLoadOp
(
)
=
=
GrLoadOp
:
:
kLoad
|
|
forceLoadFromResolve
)
)
{
loadFromResolve
=
GrVkRenderPass
:
:
LoadFromResolve
:
:
kLoad
;
}
if
(
rt
)
{
GrVkRenderTarget
*
vkRT
=
(
GrVkRenderTarget
*
)
rt
;
SkASSERT
(
!
needsResolve
|
|
(
vkRT
-
>
resolveAttachment
(
)
&
&
vkRT
-
>
resolveAttachment
(
)
-
>
supportsInputAttachmentUsage
(
)
)
)
;
bool
needsStencil
=
programInfo
.
needsStencil
(
)
|
|
programInfo
.
isStencilEnabled
(
)
;
auto
rp
=
vkRT
-
>
getSimpleRenderPass
(
needsResolve
needsStencil
selfDepFlags
loadFromResolve
)
;
SkASSERT
(
rp
)
;
rp
-
>
genKey
(
&
b
)
;
#
ifdef
SK_DEBUG
if
(
!
rp
-
>
isExternal
(
)
)
{
GrVkRenderPass
:
:
AttachmentsDescriptor
attachmentsDescriptor
;
GrVkRenderPass
:
:
AttachmentFlags
attachmentFlags
;
GrVkRenderTarget
:
:
ReconstructAttachmentsDescriptor
(
*
this
programInfo
&
attachmentsDescriptor
&
attachmentFlags
)
;
SkASSERT
(
rp
-
>
isCompatible
(
attachmentsDescriptor
attachmentFlags
selfDepFlags
loadFromResolve
)
)
;
}
#
endif
}
else
{
GrVkRenderPass
:
:
AttachmentsDescriptor
attachmentsDescriptor
;
GrVkRenderPass
:
:
AttachmentFlags
attachmentFlags
;
GrVkRenderTarget
:
:
ReconstructAttachmentsDescriptor
(
*
this
programInfo
&
attachmentsDescriptor
&
attachmentFlags
)
;
GrVkRenderPass
:
:
GenKey
(
&
b
attachmentFlags
attachmentsDescriptor
selfDepFlags
loadFromResolve
0
)
;
}
GrStencilSettings
stencil
=
programInfo
.
nonGLStencilSettings
(
)
;
stencil
.
genKey
(
&
b
true
)
;
programInfo
.
pipeline
(
)
.
genKey
(
&
b
*
this
)
;
b
.
add32
(
programInfo
.
numSamples
(
)
)
;
b
.
add32
(
programInfo
.
primitiveTypeKey
(
)
)
;
b
.
flush
(
)
;
return
desc
;
}
GrInternalSurfaceFlags
GrVkCaps
:
:
getExtraSurfaceFlagsForDeferredRT
(
)
const
{
return
GrInternalSurfaceFlags
:
:
kVkRTSupportsInputAttachment
;
}
VkShaderStageFlags
GrVkCaps
:
:
getPushConstantStageFlags
(
)
const
{
VkShaderStageFlags
stageFlags
=
VK_SHADER_STAGE_VERTEX_BIT
|
VK_SHADER_STAGE_FRAGMENT_BIT
;
return
stageFlags
;
}
template
<
size_t
N
>
static
bool
intel_deviceID_present
(
const
std
:
:
array
<
uint32_t
N
>
&
array
uint32_t
deviceID
)
{
return
std
:
:
find
(
array
.
begin
(
)
array
.
end
(
)
deviceID
)
!
=
array
.
end
(
)
;
}
GrVkCaps
:
:
IntelGPUType
GrVkCaps
:
:
GetIntelGPUType
(
uint32_t
deviceID
)
{
static
constexpr
std
:
:
array
<
uint32_t
25
>
kSkyLakeIDs
=
{
{
0x1902
0x1906
0x190A
0x190B
0x190E
0x1912
0x1913
0x1915
0x1916
0x1917
0x191A
0x191B
0x191D
0x191E
0x1921
0x1923
0x1926
0x1927
0x192A
0x192B
0x192D
0x1932
0x193A
0x193B
0x193D
}
}
;
static
constexpr
std
:
:
array
<
uint32_t
14
>
kIceLakeIDs
=
{
{
0x8A50
0x8A51
0x8A52
0x8A53
0x8A54
0x8A56
0x8A57
0x8A58
0x8A59
0x8A5A
0x8A5B
0x8A5C
0x8A5D
0x8A71
}
}
;
static
constexpr
std
:
:
array
<
uint32_t
5
>
kRocketLakeIDs
=
{
{
0x4c8a
0x4c8b
0x4c8c
0x4c90
0x4c9a
}
}
;
static
constexpr
std
:
:
array
<
uint32_t
11
>
kTigerLakeIDs
=
{
{
0x9A40
0x9A49
0x9A59
0x9A60
0x9A68
0x9A70
0x9A78
0x9AC0
0x9AC9
0x9AD9
0x9AF8
}
}
;
static
constexpr
std
:
:
array
<
uint32_t
10
>
kAlderLakeIDs
=
{
{
0x4680
0x4681
0x4682
0x4683
0x4690
0x4691
0x4692
0x4693
0x4698
0x4699
}
}
;
if
(
intel_deviceID_present
(
kSkyLakeIDs
deviceID
)
)
{
return
IntelGPUType
:
:
kSkyLake
;
}
if
(
intel_deviceID_present
(
kIceLakeIDs
deviceID
)
)
{
return
IntelGPUType
:
:
kIceLake
;
}
if
(
intel_deviceID_present
(
kRocketLakeIDs
deviceID
)
)
{
return
IntelGPUType
:
:
kRocketLake
;
}
if
(
intel_deviceID_present
(
kTigerLakeIDs
deviceID
)
)
{
return
IntelGPUType
:
:
kTigerLake
;
}
if
(
intel_deviceID_present
(
kAlderLakeIDs
deviceID
)
)
{
return
IntelGPUType
:
:
kAlderLake
;
}
return
IntelGPUType
:
:
kOther
;
}
#
if
GR_TEST_UTILS
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
GrVkCaps
:
:
getTestingCombinations
(
)
const
{
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
combos
=
{
{
GrColorType
:
:
kAlpha_8
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8_UNORM
)
}
{
GrColorType
:
:
kBGR_565
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R5G6B5_UNORM_PACK16
)
}
{
GrColorType
:
:
kABGR_4444
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R4G4B4A4_UNORM_PACK16
)
}
{
GrColorType
:
:
kABGR_4444
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_B4G4R4A4_UNORM_PACK16
)
}
{
GrColorType
:
:
kRGBA_8888
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_UNORM
)
}
{
GrColorType
:
:
kRGBA_8888_SRGB
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_SRGB
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8A8_UNORM
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8B8_UNORM
)
}
{
GrColorType
:
:
kRG_88
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8G8_UNORM
)
}
{
GrColorType
:
:
kBGRA_8888
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_B8G8R8A8_UNORM
)
}
{
GrColorType
:
:
kRGBA_1010102
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_A2B10G10R10_UNORM_PACK32
)
}
{
GrColorType
:
:
kBGRA_1010102
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_A2R10G10B10_UNORM_PACK32
)
}
{
GrColorType
:
:
kGray_8
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R8_UNORM
)
}
{
GrColorType
:
:
kAlpha_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16_SFLOAT
)
}
{
GrColorType
:
:
kRGBA_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_SFLOAT
)
}
{
GrColorType
:
:
kRGBA_F16_Clamped
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_SFLOAT
)
}
{
GrColorType
:
:
kAlpha_16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16_UNORM
)
}
{
GrColorType
:
:
kRG_1616
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16_UNORM
)
}
{
GrColorType
:
:
kRGBA_16161616
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16B16A16_UNORM
)
}
{
GrColorType
:
:
kRG_F16
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_R16G16_SFLOAT
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_BC1_RGB_UNORM_BLOCK
)
}
{
GrColorType
:
:
kRGBA_8888
GrBackendFormat
:
:
MakeVk
(
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
)
}
}
;
return
combos
;
}
#
endif
