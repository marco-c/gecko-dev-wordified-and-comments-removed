#
ifndef
GrVkCommandPool_DEFINED
#
define
GrVkCommandPool_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkManagedResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkResourceProvider
.
h
"
#
include
"
src
/
gpu
/
vk
/
VulkanInterface
.
h
"
#
include
<
cinttypes
>
class
GrVkPrimaryCommandBuffer
;
class
GrVkSecondaryCommandBuffer
;
class
GrVkGpu
;
class
GrVkCommandPool
:
public
GrVkManagedResource
{
public
:
static
GrVkCommandPool
*
Create
(
GrVkGpu
*
gpu
)
;
VkCommandPool
vkCommandPool
(
)
const
{
return
fCommandPool
;
}
void
reset
(
GrVkGpu
*
gpu
)
;
GrVkPrimaryCommandBuffer
*
getPrimaryCommandBuffer
(
)
{
return
fPrimaryCommandBuffer
.
get
(
)
;
}
std
:
:
unique_ptr
<
GrVkSecondaryCommandBuffer
>
findOrCreateSecondaryCommandBuffer
(
GrVkGpu
*
gpu
)
;
void
recycleSecondaryCommandBuffer
(
GrVkSecondaryCommandBuffer
*
buffer
)
;
void
close
(
)
;
bool
isOpen
(
)
const
{
return
fOpen
;
}
#
ifdef
SK_TRACE_MANAGED_RESOURCES
void
dumpInfo
(
)
const
override
{
SkDebugf
(
"
GrVkCommandPool
:
%
"
PRIdPTR
"
(
%
d
refs
)
\
n
"
(
intptr_t
)
fCommandPool
this
-
>
getRefCnt
(
)
)
;
}
#
endif
private
:
GrVkCommandPool
(
)
=
delete
;
GrVkCommandPool
(
GrVkGpu
*
gpu
VkCommandPool
commandPool
GrVkPrimaryCommandBuffer
*
)
;
void
releaseResources
(
)
;
void
freeGPUData
(
)
const
override
;
bool
fOpen
=
true
;
VkCommandPool
fCommandPool
;
std
:
:
unique_ptr
<
GrVkPrimaryCommandBuffer
>
fPrimaryCommandBuffer
;
SkSTArray
<
4
std
:
:
unique_ptr
<
GrVkSecondaryCommandBuffer
>
true
>
fAvailableSecondaryBuffers
;
int
fMaxCachedSecondaryCommandBuffers
;
}
;
#
endif
