#
ifndef
GrVkTextureRenderTarget_DEFINED
#
define
GrVkTextureRenderTarget_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkTexture
.
h
"
class
GrVkGpu
;
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4250
)
#
endif
class
GrVkImageView
;
struct
GrVkImageInfo
;
class
GrVkTextureRenderTarget
:
public
GrVkTexture
public
GrVkRenderTarget
{
public
:
static
sk_sp
<
GrVkTextureRenderTarget
>
MakeNewTextureRenderTarget
(
GrVkGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
VkFormat
format
uint32_t
mipLevels
int
sampleCnt
GrMipmapStatus
mipmapStatus
GrProtected
isProtected
std
:
:
string_view
label
)
;
static
sk_sp
<
GrVkTextureRenderTarget
>
MakeWrappedTextureRenderTarget
(
GrVkGpu
*
SkISize
dimensions
int
sampleCnt
GrWrapOwnership
GrWrapCacheable
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
)
;
GrBackendFormat
backendFormat
(
)
const
override
{
return
GrVkTexture
:
:
backendFormat
(
)
;
}
protected
:
void
onAbandon
(
)
override
{
GrVkTexture
:
:
onAbandon
(
)
;
GrVkRenderTarget
:
:
onAbandon
(
)
;
}
void
onRelease
(
)
override
{
GrVkTexture
:
:
onRelease
(
)
;
GrVkRenderTarget
:
:
onRelease
(
)
;
}
private
:
GrVkTextureRenderTarget
(
GrVkGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
sk_sp
<
GrVkImage
>
texture
sk_sp
<
GrVkImage
>
colorAttachment
sk_sp
<
GrVkImage
>
resolveAttachment
GrMipmapStatus
std
:
:
string_view
label
)
;
GrVkTextureRenderTarget
(
GrVkGpu
*
gpu
SkISize
dimensions
sk_sp
<
GrVkImage
>
texture
sk_sp
<
GrVkImage
>
colorAttachment
sk_sp
<
GrVkImage
>
resolveAttachment
GrMipmapStatus
GrWrapCacheable
std
:
:
string_view
label
)
;
size_t
onGpuMemorySize
(
)
const
override
;
void
onSetLabel
(
)
override
{
}
void
onSetRelease
(
sk_sp
<
RefCntedReleaseProc
>
releaseHelper
)
override
{
GrVkTexture
:
:
onSetRelease
(
std
:
:
move
(
releaseHelper
)
)
;
}
}
;
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
pop
)
#
endif
#
endif
