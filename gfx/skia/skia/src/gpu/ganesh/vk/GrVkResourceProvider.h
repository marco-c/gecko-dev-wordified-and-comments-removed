#
ifndef
GrVkResourceProvider_DEFINED
#
define
GrVkResourceProvider_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrManagedResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramDesc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceHandle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrThreadSafePipelineBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkDescriptorPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkDescriptorSetManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkPipelineStateBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkRenderPass
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkSampler
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkSamplerYcbcrConversion
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkUtil
.
h
"
class
GrVkCommandPool
;
class
GrVkGpu
;
class
GrVkPipeline
;
class
GrVkPipelineState
;
class
GrVkPrimaryCommandBuffer
;
class
GrVkRenderTarget
;
class
GrVkSecondaryCommandBuffer
;
class
GrVkUniformHandler
;
class
GrVkResourceProvider
{
public
:
GrVkResourceProvider
(
GrVkGpu
*
gpu
)
;
~
GrVkResourceProvider
(
)
;
GrThreadSafePipelineBuilder
*
pipelineStateCache
(
)
{
return
fPipelineStateCache
.
get
(
)
;
}
sk_sp
<
GrThreadSafePipelineBuilder
>
refPipelineStateCache
(
)
{
return
fPipelineStateCache
;
}
void
init
(
)
;
sk_sp
<
const
GrVkPipeline
>
makePipeline
(
const
GrProgramInfo
&
VkPipelineShaderStageCreateInfo
*
shaderStageInfo
int
shaderStageCount
VkRenderPass
compatibleRenderPass
VkPipelineLayout
layout
uint32_t
subpass
)
;
GR_DEFINE_RESOURCE_HANDLE_CLASS
(
CompatibleRPHandle
)
;
using
SelfDependencyFlags
=
GrVkRenderPass
:
:
SelfDependencyFlags
;
using
LoadFromResolve
=
GrVkRenderPass
:
:
LoadFromResolve
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
GrVkRenderTarget
*
target
CompatibleRPHandle
*
compatibleHandle
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
const
GrVkRenderPass
*
findCompatibleRenderPass
(
GrVkRenderPass
:
:
AttachmentsDescriptor
*
GrVkRenderPass
:
:
AttachmentFlags
SelfDependencyFlags
selfDepFlags
LoadFromResolve
CompatibleRPHandle
*
compatibleHandle
=
nullptr
)
;
const
GrVkRenderPass
*
findCompatibleExternalRenderPass
(
VkRenderPass
uint32_t
colorAttachmentIndex
)
;
const
GrVkRenderPass
*
findRenderPass
(
GrVkRenderTarget
*
target
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
resolveOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
CompatibleRPHandle
*
compatibleHandle
bool
withResolve
bool
withStencil
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
;
const
GrVkRenderPass
*
findRenderPass
(
const
CompatibleRPHandle
&
compatibleHandle
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
resolveOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
GrVkCommandPool
*
findOrCreateCommandPool
(
)
;
void
checkCommandBuffers
(
)
;
void
forceSyncAllCommandBuffers
(
)
;
void
addFinishedProcToActiveCommandBuffers
(
sk_sp
<
skgpu
:
:
RefCntedCallback
>
finishedCallback
)
;
GrVkDescriptorPool
*
findOrCreateCompatibleDescriptorPool
(
VkDescriptorType
type
uint32_t
count
)
;
GrVkSampler
*
findOrCreateCompatibleSampler
(
GrSamplerState
const
GrVkYcbcrConversionInfo
&
ycbcrInfo
)
;
GrVkSamplerYcbcrConversion
*
findOrCreateCompatibleSamplerYcbcrConversion
(
const
GrVkYcbcrConversionInfo
&
ycbcrInfo
)
;
GrVkPipelineState
*
findOrCreateCompatiblePipelineState
(
GrRenderTarget
*
const
GrProgramInfo
&
VkRenderPass
compatibleRenderPass
bool
overrideSubpassForResolveLoad
)
;
GrVkPipelineState
*
findOrCreateCompatiblePipelineState
(
const
GrProgramDesc
&
const
GrProgramInfo
&
VkRenderPass
compatibleRenderPass
GrThreadSafePipelineBuilder
:
:
Stats
:
:
ProgramCacheResult
*
stat
)
;
sk_sp
<
const
GrVkPipeline
>
findOrCreateMSAALoadPipeline
(
const
GrVkRenderPass
&
renderPass
int
numSamples
VkPipelineShaderStageCreateInfo
*
VkPipelineLayout
)
;
void
getSamplerDescriptorSetHandle
(
VkDescriptorType
type
const
GrVkUniformHandler
&
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
void
getZeroSamplerDescriptorSetHandle
(
GrVkDescriptorSetManager
:
:
Handle
*
handle
)
;
VkDescriptorSetLayout
getUniformDSLayout
(
)
const
;
VkDescriptorSetLayout
getInputDSLayout
(
)
const
;
VkDescriptorSetLayout
getSamplerDSLayout
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
const
;
const
GrVkDescriptorSet
*
getUniformDescriptorSet
(
)
;
const
GrVkDescriptorSet
*
getSamplerDescriptorSet
(
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
const
GrVkDescriptorSet
*
getInputDescriptorSet
(
)
;
void
recycleDescriptorSet
(
const
GrVkDescriptorSet
*
descSet
const
GrVkDescriptorSetManager
:
:
Handle
&
)
;
void
storePipelineCacheData
(
)
;
void
destroyResources
(
)
;
void
releaseUnlockedBackendObjects
(
)
;
#
if
GR_TEST_UTILS
void
resetShaderCacheForTesting
(
)
const
{
fPipelineStateCache
-
>
release
(
)
;
}
#
endif
private
:
class
PipelineStateCache
:
public
GrThreadSafePipelineBuilder
{
public
:
PipelineStateCache
(
GrVkGpu
*
gpu
)
;
~
PipelineStateCache
(
)
override
;
void
release
(
)
;
GrVkPipelineState
*
findOrCreatePipelineState
(
GrRenderTarget
*
const
GrProgramInfo
&
VkRenderPass
compatibleRenderPass
bool
overrideSubpassForResolveLoad
)
;
GrVkPipelineState
*
findOrCreatePipelineState
(
const
GrProgramDesc
&
desc
const
GrProgramInfo
&
programInfo
VkRenderPass
compatibleRenderPass
Stats
:
:
ProgramCacheResult
*
stat
)
{
return
this
-
>
findOrCreatePipelineStateImpl
(
desc
programInfo
compatibleRenderPass
false
stat
)
;
}
private
:
struct
Entry
;
GrVkPipelineState
*
findOrCreatePipelineStateImpl
(
const
GrProgramDesc
&
const
GrProgramInfo
&
VkRenderPass
compatibleRenderPass
bool
overrideSubpassForResolveLoad
Stats
:
:
ProgramCacheResult
*
)
;
struct
DescHash
{
uint32_t
operator
(
)
(
const
GrProgramDesc
&
desc
)
const
{
return
SkOpts
:
:
hash_fn
(
desc
.
asKey
(
)
desc
.
keyLength
(
)
0
)
;
}
}
;
SkLRUCache
<
const
GrProgramDesc
std
:
:
unique_ptr
<
Entry
>
DescHash
>
fMap
;
GrVkGpu
*
fGpu
;
}
;
class
CompatibleRenderPassSet
{
public
:
CompatibleRenderPassSet
(
GrVkRenderPass
*
renderPass
)
;
bool
isCompatible
(
const
GrVkRenderPass
:
:
AttachmentsDescriptor
&
GrVkRenderPass
:
:
AttachmentFlags
SelfDependencyFlags
selfDepFlags
LoadFromResolve
)
const
;
const
GrVkRenderPass
*
getCompatibleRenderPass
(
)
const
{
SkASSERT
(
fRenderPasses
[
0
]
)
;
return
fRenderPasses
[
0
]
;
}
GrVkRenderPass
*
getRenderPass
(
GrVkGpu
*
gpu
const
GrVkRenderPass
:
:
LoadStoreOps
&
colorOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
resolveOps
const
GrVkRenderPass
:
:
LoadStoreOps
&
stencilOps
)
;
void
releaseResources
(
)
;
private
:
SkSTArray
<
4
GrVkRenderPass
*
>
fRenderPasses
;
int
fLastReturnedIndex
;
}
;
VkPipelineCache
pipelineCache
(
)
;
GrVkGpu
*
fGpu
;
VkPipelineCache
fPipelineCache
;
struct
MSAALoadPipeline
{
sk_sp
<
const
GrVkPipeline
>
fPipeline
;
const
GrVkRenderPass
*
fRenderPass
;
}
;
SkTArray
<
MSAALoadPipeline
>
fMSAALoadPipelines
;
SkSTArray
<
4
CompatibleRenderPassSet
>
fRenderPassArray
;
SkTArray
<
const
GrVkRenderPass
*
>
fExternalRenderPasses
;
SkSTArray
<
4
GrVkCommandPool
*
true
>
fActiveCommandPools
;
SkSTArray
<
4
GrVkCommandPool
*
true
>
fAvailableCommandPools
;
SkTDynamicHash
<
GrVkSampler
GrVkSampler
:
:
Key
>
fSamplers
;
SkTDynamicHash
<
GrVkSamplerYcbcrConversion
GrVkSamplerYcbcrConversion
:
:
Key
>
fYcbcrConversions
;
sk_sp
<
PipelineStateCache
>
fPipelineStateCache
;
SkSTArray
<
4
std
:
:
unique_ptr
<
GrVkDescriptorSetManager
>
>
fDescriptorSetManagers
;
GrVkDescriptorSetManager
:
:
Handle
fUniformDSHandle
;
GrVkDescriptorSetManager
:
:
Handle
fInputDSHandle
;
}
;
#
endif
