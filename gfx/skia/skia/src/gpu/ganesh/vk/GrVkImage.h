#
ifndef
GrVkImage_DEFINED
#
define
GrVkImage_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrVkTypesPriv
.
h
"
#
include
"
src
/
gpu
/
MutableTextureStateRef
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAttachment
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrManagedResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRefCnt
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkDescriptorSet
.
h
"
#
include
<
cinttypes
>
class
GrVkGpu
;
class
GrVkImageView
;
class
GrVkImage
:
public
GrAttachment
{
private
:
class
Resource
;
public
:
static
sk_sp
<
GrVkImage
>
MakeStencil
(
GrVkGpu
*
gpu
SkISize
dimensions
int
sampleCnt
VkFormat
format
)
;
static
sk_sp
<
GrVkImage
>
MakeMSAA
(
GrVkGpu
*
gpu
SkISize
dimensions
int
numSamples
VkFormat
format
GrProtected
isProtected
GrMemoryless
memoryless
)
;
static
sk_sp
<
GrVkImage
>
MakeTexture
(
GrVkGpu
*
gpu
SkISize
dimensions
VkFormat
format
uint32_t
mipLevels
GrRenderable
renderable
int
numSamples
skgpu
:
:
Budgeted
budgeted
GrProtected
isProtected
)
;
static
sk_sp
<
GrVkImage
>
MakeWrapped
(
GrVkGpu
*
gpu
SkISize
dimensions
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
UsageFlags
attachmentUsages
GrWrapOwnership
GrWrapCacheable
std
:
:
string_view
label
bool
forSecondaryCB
=
false
)
;
~
GrVkImage
(
)
override
;
VkImage
image
(
)
const
{
SkASSERT
(
fResource
)
;
return
fInfo
.
fImage
;
}
const
skgpu
:
:
VulkanAlloc
&
alloc
(
)
const
{
SkASSERT
(
fResource
)
;
return
fInfo
.
fAlloc
;
}
const
GrVkImageInfo
&
vkImageInfo
(
)
const
{
return
fInfo
;
}
VkFormat
imageFormat
(
)
const
{
return
fInfo
.
fFormat
;
}
GrBackendFormat
backendFormat
(
)
const
override
{
bool
usesDRMModifier
=
this
-
>
vkImageInfo
(
)
.
fImageTiling
=
=
VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
;
if
(
fResource
&
&
this
-
>
ycbcrConversionInfo
(
)
.
isValid
(
)
)
{
SkASSERT
(
this
-
>
imageFormat
(
)
=
=
this
-
>
ycbcrConversionInfo
(
)
.
fFormat
)
;
return
GrBackendFormat
:
:
MakeVk
(
this
-
>
ycbcrConversionInfo
(
)
usesDRMModifier
)
;
}
SkASSERT
(
this
-
>
imageFormat
(
)
!
=
VK_FORMAT_UNDEFINED
)
;
return
GrBackendFormat
:
:
MakeVk
(
this
-
>
imageFormat
(
)
usesDRMModifier
)
;
}
uint32_t
mipLevels
(
)
const
{
return
fInfo
.
fLevelCount
;
}
const
GrVkYcbcrConversionInfo
&
ycbcrConversionInfo
(
)
const
{
SkASSERT
(
fResource
)
;
return
fInfo
.
fYcbcrConversionInfo
;
}
VkImageUsageFlags
vkUsageFlags
(
)
{
return
fInfo
.
fImageUsageFlags
;
}
bool
supportsInputAttachmentUsage
(
)
const
{
return
fInfo
.
fImageUsageFlags
&
VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
;
}
const
GrVkImageView
*
framebufferView
(
)
const
{
return
fFramebufferView
.
get
(
)
;
}
const
GrVkImageView
*
textureView
(
)
const
{
return
fTextureView
.
get
(
)
;
}
gr_rp
<
const
GrVkDescriptorSet
>
inputDescSetForBlending
(
GrVkGpu
*
gpu
)
;
gr_rp
<
const
GrVkDescriptorSet
>
inputDescSetForMSAALoad
(
GrVkGpu
*
gpu
)
;
const
Resource
*
resource
(
)
const
{
SkASSERT
(
fResource
)
;
return
fResource
;
}
bool
isLinearTiled
(
)
const
{
SkASSERT
(
fResource
)
;
return
SkToBool
(
VK_IMAGE_TILING_LINEAR
=
=
fInfo
.
fImageTiling
)
;
}
bool
isBorrowed
(
)
const
{
return
fIsBorrowed
;
}
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
getMutableState
(
)
const
{
return
fMutableState
;
}
VkImageLayout
currentLayout
(
)
const
{
return
fMutableState
-
>
getImageLayout
(
)
;
}
void
setImageLayoutAndQueueIndex
(
const
GrVkGpu
*
gpu
VkImageLayout
newLayout
VkAccessFlags
dstAccessMask
VkPipelineStageFlags
dstStageMask
bool
byRegion
uint32_t
newQueueFamilyIndex
)
;
void
setImageLayout
(
const
GrVkGpu
*
gpu
VkImageLayout
newLayout
VkAccessFlags
dstAccessMask
VkPipelineStageFlags
dstStageMask
bool
byRegion
)
{
this
-
>
setImageLayoutAndQueueIndex
(
gpu
newLayout
dstAccessMask
dstStageMask
byRegion
VK_QUEUE_FAMILY_IGNORED
)
;
}
uint32_t
currentQueueFamilyIndex
(
)
const
{
return
fMutableState
-
>
getQueueFamilyIndex
(
)
;
}
void
setQueueFamilyIndex
(
uint32_t
queueFamilyIndex
)
{
fMutableState
-
>
setQueueFamilyIndex
(
queueFamilyIndex
)
;
}
void
prepareForPresent
(
GrVkGpu
*
gpu
)
;
void
prepareForExternal
(
GrVkGpu
*
gpu
)
;
void
updateImageLayout
(
VkImageLayout
newLayout
)
{
SkASSERT
(
fResource
)
;
fMutableState
-
>
setImageLayout
(
newLayout
)
;
}
struct
ImageDesc
{
VkImageType
fImageType
;
VkFormat
fFormat
;
uint32_t
fWidth
;
uint32_t
fHeight
;
uint32_t
fLevels
;
uint32_t
fSamples
;
VkImageTiling
fImageTiling
;
VkImageUsageFlags
fUsageFlags
;
VkFlags
fMemProps
;
GrProtected
fIsProtected
;
ImageDesc
(
)
:
fImageType
(
VK_IMAGE_TYPE_2D
)
fFormat
(
VK_FORMAT_UNDEFINED
)
fWidth
(
0
)
fHeight
(
0
)
fLevels
(
1
)
fSamples
(
1
)
fImageTiling
(
VK_IMAGE_TILING_OPTIMAL
)
fUsageFlags
(
0
)
fMemProps
(
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
)
fIsProtected
(
GrProtected
:
:
kNo
)
{
}
}
;
static
bool
InitImageInfo
(
GrVkGpu
*
gpu
const
ImageDesc
&
imageDesc
GrVkImageInfo
*
)
;
static
void
DestroyImageInfo
(
const
GrVkGpu
*
gpu
GrVkImageInfo
*
)
;
typedef
void
*
ReleaseCtx
;
typedef
void
(
*
ReleaseProc
)
(
ReleaseCtx
)
;
void
setResourceRelease
(
sk_sp
<
RefCntedReleaseProc
>
releaseHelper
)
;
static
VkPipelineStageFlags
LayoutToPipelineSrcStageFlags
(
const
VkImageLayout
layout
)
;
static
VkAccessFlags
LayoutToSrcAccessMask
(
const
VkImageLayout
layout
)
;
#
if
GR_TEST_UTILS
void
setCurrentQueueFamilyToGraphicsQueue
(
GrVkGpu
*
gpu
)
;
#
endif
private
:
static
sk_sp
<
GrVkImage
>
Make
(
GrVkGpu
*
gpu
SkISize
dimensions
UsageFlags
attachmentUsages
int
sampleCnt
VkFormat
format
uint32_t
mipLevels
VkImageUsageFlags
vkUsageFlags
GrProtected
isProtected
GrMemoryless
skgpu
:
:
Budgeted
)
;
GrVkImage
(
GrVkGpu
*
gpu
SkISize
dimensions
UsageFlags
supportedUsages
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
mutableState
sk_sp
<
const
GrVkImageView
>
framebufferView
sk_sp
<
const
GrVkImageView
>
textureView
skgpu
:
:
Budgeted
std
:
:
string_view
label
)
;
GrVkImage
(
GrVkGpu
*
gpu
SkISize
dimensions
UsageFlags
supportedUsages
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
mutableState
sk_sp
<
const
GrVkImageView
>
framebufferView
sk_sp
<
const
GrVkImageView
>
textureView
GrBackendObjectOwnership
GrWrapCacheable
bool
forSecondaryCB
std
:
:
string_view
label
)
;
void
init
(
GrVkGpu
*
bool
forSecondaryCB
)
;
void
onRelease
(
)
override
;
void
onAbandon
(
)
override
;
void
releaseImage
(
)
;
bool
hasResource
(
)
const
{
return
fResource
;
}
GrVkGpu
*
getVkGpu
(
)
const
;
GrVkImageInfo
fInfo
;
uint32_t
fInitialQueueFamily
;
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
fMutableState
;
sk_sp
<
const
GrVkImageView
>
fFramebufferView
;
sk_sp
<
const
GrVkImageView
>
fTextureView
;
bool
fIsBorrowed
;
gr_rp
<
const
GrVkDescriptorSet
>
fCachedBlendingInputDescSet
;
gr_rp
<
const
GrVkDescriptorSet
>
fCachedMSAALoadInputDescSet
;
class
Resource
:
public
GrTextureResource
{
public
:
explicit
Resource
(
const
GrVkGpu
*
gpu
)
:
fGpu
(
gpu
)
fImage
(
VK_NULL_HANDLE
)
{
fAlloc
.
fMemory
=
VK_NULL_HANDLE
;
fAlloc
.
fOffset
=
0
;
}
Resource
(
const
GrVkGpu
*
gpu
VkImage
image
const
skgpu
:
:
VulkanAlloc
&
alloc
VkImageTiling
tiling
)
:
fGpu
(
gpu
)
fImage
(
image
)
fAlloc
(
alloc
)
{
}
~
Resource
(
)
override
{
}
#
ifdef
SK_TRACE_MANAGED_RESOURCES
void
dumpInfo
(
)
const
override
{
SkDebugf
(
"
GrVkImage
:
%
"
PRIdPTR
"
(
%
d
refs
)
\
n
"
(
intptr_t
)
fImage
this
-
>
getRefCnt
(
)
)
;
}
#
endif
#
ifdef
SK_DEBUG
const
GrManagedResource
*
asVkImageResource
(
)
const
override
{
return
this
;
}
#
endif
private
:
void
freeGPUData
(
)
const
override
;
const
GrVkGpu
*
fGpu
;
VkImage
fImage
;
skgpu
:
:
VulkanAlloc
fAlloc
;
using
INHERITED
=
GrTextureResource
;
}
;
class
BorrowedResource
:
public
Resource
{
public
:
BorrowedResource
(
const
GrVkGpu
*
gpu
VkImage
image
const
skgpu
:
:
VulkanAlloc
&
alloc
VkImageTiling
tiling
)
:
Resource
(
gpu
image
alloc
tiling
)
{
}
private
:
void
freeGPUData
(
)
const
override
;
}
;
Resource
*
fResource
;
friend
class
GrVkRenderTarget
;
}
;
#
endif
