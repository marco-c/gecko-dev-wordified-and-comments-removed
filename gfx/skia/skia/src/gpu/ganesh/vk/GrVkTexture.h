#
ifndef
GrVkTexture_DEFINED
#
define
GrVkTexture_DEFINED
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
vk
/
GrVkImage
.
h
"
class
GrVkDescriptorSet
;
class
GrVkGpu
;
class
GrVkImageView
;
struct
GrVkImageInfo
;
class
GrVkTexture
:
public
GrTexture
{
public
:
static
sk_sp
<
GrVkTexture
>
MakeNewTexture
(
GrVkGpu
*
skgpu
:
:
Budgeted
budgeted
SkISize
dimensions
VkFormat
format
uint32_t
mipLevels
GrProtected
GrMipmapStatus
std
:
:
string_view
label
)
;
static
sk_sp
<
GrVkTexture
>
MakeWrappedTexture
(
GrVkGpu
*
SkISize
dimensions
GrWrapOwnership
GrWrapCacheable
GrIOType
const
GrVkImageInfo
&
sk_sp
<
skgpu
:
:
MutableTextureStateRef
>
)
;
~
GrVkTexture
(
)
override
;
GrBackendTexture
getBackendTexture
(
)
const
override
;
GrBackendFormat
backendFormat
(
)
const
override
{
return
fTexture
-
>
backendFormat
(
)
;
}
void
textureParamsModified
(
)
override
{
}
GrVkImage
*
textureImage
(
)
const
{
return
fTexture
.
get
(
)
;
}
const
GrVkImageView
*
textureView
(
)
;
const
GrVkDescriptorSet
*
cachedSingleDescSet
(
GrSamplerState
)
;
void
addDescriptorSetToCache
(
const
GrVkDescriptorSet
*
GrSamplerState
)
;
protected
:
GrVkTexture
(
GrVkGpu
*
SkISize
dimensions
sk_sp
<
GrVkImage
>
texture
GrMipmapStatus
std
:
:
string_view
label
)
;
GrVkGpu
*
getVkGpu
(
)
const
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
bool
onStealBackendTexture
(
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
override
{
return
false
;
}
void
onSetRelease
(
sk_sp
<
RefCntedReleaseProc
>
releaseHelper
)
override
{
fTexture
-
>
setResourceRelease
(
std
:
:
move
(
releaseHelper
)
)
;
}
private
:
GrVkTexture
(
GrVkGpu
*
skgpu
:
:
Budgeted
SkISize
sk_sp
<
GrVkImage
>
texture
GrMipmapStatus
std
:
:
string_view
label
)
;
GrVkTexture
(
GrVkGpu
*
SkISize
sk_sp
<
GrVkImage
>
texture
GrMipmapStatus
GrWrapCacheable
GrIOType
bool
isExternal
std
:
:
string_view
label
)
;
void
onSetLabel
(
)
override
{
}
sk_sp
<
GrVkImage
>
fTexture
;
struct
SamplerHash
{
uint32_t
operator
(
)
(
GrSamplerState
state
)
const
{
return
state
.
asKey
(
true
)
;
}
}
;
struct
DescriptorCacheEntry
;
SkLRUCache
<
const
GrSamplerState
std
:
:
unique_ptr
<
DescriptorCacheEntry
>
SamplerHash
>
fDescSetCache
;
static
constexpr
int
kMaxCachedDescSets
=
8
;
}
;
#
endif
