#
ifndef
GrBackendTextureImageGenerator_DEFINED
#
define
GrBackendTextureImageGenerator_DEFINED
#
include
"
include
/
core
/
SkImageGenerator
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
class
GrSemaphore
;
class
GrBackendTextureImageGenerator
:
public
SkImageGenerator
{
public
:
static
std
:
:
unique_ptr
<
SkImageGenerator
>
Make
(
sk_sp
<
GrTexture
>
GrSurfaceOrigin
std
:
:
unique_ptr
<
GrSemaphore
>
SkColorType
SkAlphaType
sk_sp
<
SkColorSpace
>
)
;
~
GrBackendTextureImageGenerator
(
)
override
;
protected
:
bool
onIsValid
(
GrRecordingContext
*
context
)
const
override
{
if
(
context
&
&
context
-
>
abandoned
(
)
)
{
return
false
;
}
return
true
;
}
GrSurfaceProxyView
onGenerateTexture
(
GrRecordingContext
*
const
SkImageInfo
&
GrMipmapped
mipmapped
GrImageTexGenPolicy
)
override
;
private
:
GrBackendTextureImageGenerator
(
const
SkColorInfo
&
sk_sp
<
GrTexture
>
GrSurfaceOrigin
GrDirectContext
:
:
DirectContextID
owningContextID
std
:
:
unique_ptr
<
GrSemaphore
>
)
;
static
void
ReleaseRefHelper_TextureReleaseProc
(
void
*
ctx
)
;
class
RefHelper
:
public
SkNVRefCnt
<
RefHelper
>
{
public
:
RefHelper
(
sk_sp
<
GrTexture
>
GrDirectContext
:
:
DirectContextID
owningContextID
std
:
:
unique_ptr
<
GrSemaphore
>
)
;
~
RefHelper
(
)
;
sk_sp
<
GrTexture
>
fOriginalTexture
;
GrDirectContext
:
:
DirectContextID
fOwningContextID
;
skgpu
:
:
UniqueKey
fBorrowedTextureKey
;
skgpu
:
:
RefCntedCallback
*
fBorrowingContextReleaseProc
;
GrDirectContext
:
:
DirectContextID
fBorrowingContextID
;
std
:
:
unique_ptr
<
GrSemaphore
>
fSemaphore
;
}
;
RefHelper
*
fRefHelper
;
SkMutex
fBorrowingMutex
;
GrBackendTexture
fBackendTexture
;
GrSurfaceOrigin
fSurfaceOrigin
;
using
INHERITED
=
SkImageGenerator
;
}
;
#
endif
