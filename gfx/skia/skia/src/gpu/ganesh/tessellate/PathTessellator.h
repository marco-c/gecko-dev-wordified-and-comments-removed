#
ifndef
PathTessellator_DEFINED
#
define
PathTessellator_DEFINED
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrVertexChunkArray
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrInnerFanTriangulator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
FixedCountBufferUtils
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
class
GrMeshDrawTarget
;
class
GrOpFlushState
;
class
SkPath
;
namespace
skgpu
:
:
ganesh
{
class
PathTessellator
{
public
:
using
PatchAttribs
=
tess
:
:
PatchAttribs
;
struct
PathDrawList
{
PathDrawList
(
const
SkMatrix
&
pathMatrix
const
SkPath
&
path
const
SkPMColor4f
&
color
PathDrawList
*
next
=
nullptr
)
:
fPathMatrix
(
pathMatrix
)
fPath
(
path
)
fColor
(
color
)
fNext
(
next
)
{
}
SkMatrix
fPathMatrix
;
SkPath
fPath
;
SkPMColor4f
fColor
;
PathDrawList
*
fNext
;
struct
Iter
{
void
operator
+
+
(
)
{
fHead
=
fHead
-
>
fNext
;
}
bool
operator
!
=
(
const
Iter
&
b
)
const
{
return
fHead
!
=
b
.
fHead
;
}
std
:
:
tuple
<
const
SkMatrix
&
const
SkPath
&
const
SkPMColor4f
&
>
operator
*
(
)
const
{
return
{
fHead
-
>
fPathMatrix
fHead
-
>
fPath
fHead
-
>
fColor
}
;
}
const
PathDrawList
*
fHead
;
}
;
Iter
begin
(
)
const
{
return
{
this
}
;
}
Iter
end
(
)
const
{
return
{
nullptr
}
;
}
}
;
virtual
~
PathTessellator
(
)
{
}
PatchAttribs
patchAttribs
(
)
const
{
return
fAttribs
;
}
virtual
void
prepare
(
GrMeshDrawTarget
*
target
const
SkMatrix
&
shaderMatrix
const
PathDrawList
&
pathDrawList
int
totalCombinedPathVerbCnt
)
=
0
;
virtual
void
draw
(
GrOpFlushState
*
flushState
)
const
=
0
;
protected
:
PathTessellator
(
bool
infinitySupport
PatchAttribs
attribs
)
:
fAttribs
(
attribs
)
{
if
(
!
infinitySupport
)
{
fAttribs
|
=
PatchAttribs
:
:
kExplicitCurveType
;
}
}
PatchAttribs
fAttribs
;
GrVertexChunkArray
fVertexChunkArray
;
int
fMaxVertexCount
=
0
;
sk_sp
<
const
GrGpuBuffer
>
fFixedVertexBuffer
;
sk_sp
<
const
GrGpuBuffer
>
fFixedIndexBuffer
;
}
;
class
PathCurveTessellator
final
:
public
PathTessellator
{
public
:
static
PathCurveTessellator
*
Make
(
SkArenaAlloc
*
arena
bool
infinitySupport
PatchAttribs
attribs
=
PatchAttribs
:
:
kNone
)
{
return
arena
-
>
make
<
PathCurveTessellator
>
(
infinitySupport
attribs
)
;
}
PathCurveTessellator
(
bool
infinitySupport
PatchAttribs
attribs
=
PatchAttribs
:
:
kNone
)
:
PathTessellator
(
infinitySupport
attribs
)
{
}
void
prepareWithTriangles
(
GrMeshDrawTarget
*
target
const
SkMatrix
&
shaderMatrix
GrInnerFanTriangulator
:
:
BreadcrumbTriangleList
*
extraTriangles
const
PathDrawList
&
pathDrawList
int
totalCombinedPathVerbCnt
)
;
void
prepare
(
GrMeshDrawTarget
*
target
const
SkMatrix
&
shaderMatrix
const
PathDrawList
&
pathDrawList
int
totalCombinedPathVerbCnt
)
final
{
this
-
>
prepareWithTriangles
(
target
shaderMatrix
nullptr
pathDrawList
totalCombinedPathVerbCnt
)
;
}
void
draw
(
GrOpFlushState
*
)
const
final
;
void
drawHullInstances
(
GrOpFlushState
*
sk_sp
<
const
GrGpuBuffer
>
vertexBufferIfNeeded
)
const
;
}
;
class
PathWedgeTessellator
final
:
public
PathTessellator
{
public
:
static
PathWedgeTessellator
*
Make
(
SkArenaAlloc
*
arena
bool
infinitySupport
PatchAttribs
attribs
=
PatchAttribs
:
:
kNone
)
{
return
arena
-
>
make
<
PathWedgeTessellator
>
(
infinitySupport
attribs
)
;
}
PathWedgeTessellator
(
bool
infinitySupport
PatchAttribs
attribs
=
PatchAttribs
:
:
kNone
)
:
PathTessellator
(
infinitySupport
attribs
)
{
fAttribs
|
=
PatchAttribs
:
:
kFanPoint
;
}
void
prepare
(
GrMeshDrawTarget
*
target
const
SkMatrix
&
shaderMatrix
const
PathDrawList
&
pathDrawList
int
totalCombinedPathVerbCnt
)
final
;
void
draw
(
GrOpFlushState
*
)
const
final
;
}
;
}
#
endif
