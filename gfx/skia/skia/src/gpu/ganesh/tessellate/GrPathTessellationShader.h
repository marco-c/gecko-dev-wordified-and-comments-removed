#
ifndef
GrPathTessellationShader_DEFINED
#
define
GrPathTessellationShader_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrTessellationShader
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
class
GrPathTessellationShader
:
public
GrTessellationShader
{
protected
:
using
PatchAttribs
=
skgpu
:
:
tess
:
:
PatchAttribs
;
public
:
static
GrPathTessellationShader
*
MakeSimpleTriangleShader
(
SkArenaAlloc
*
const
SkMatrix
&
viewMatrix
const
SkPMColor4f
&
)
;
static
GrPathTessellationShader
*
Make
(
const
GrShaderCaps
&
SkArenaAlloc
*
const
SkMatrix
&
viewMatrix
const
SkPMColor4f
&
PatchAttribs
)
;
static
const
GrUserStencilSettings
*
StencilPathSettings
(
GrFillRule
fillRule
)
{
constexpr
static
GrUserStencilSettings
kIncrDecrStencil
(
GrUserStencilSettings
:
:
StaticInitSeparate
<
0x0000
0x0000
GrUserStencilTest
:
:
kAlwaysIfInClip
GrUserStencilTest
:
:
kAlwaysIfInClip
0xffff
0xffff
GrUserStencilOp
:
:
kIncWrap
GrUserStencilOp
:
:
kDecWrap
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kKeep
0xffff
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kInvertStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlwaysIfInClip
0xffff
GrUserStencilOp
:
:
kInvert
GrUserStencilOp
:
:
kKeep
0x0001
>
(
)
)
;
return
(
fillRule
=
=
GrFillRule
:
:
kNonzero
)
?
&
kIncrDecrStencil
:
&
kInvertStencil
;
}
static
const
GrUserStencilSettings
*
TestAndResetStencilSettings
(
bool
isInverseFill
=
false
)
{
constexpr
static
GrUserStencilSettings
kTestAndResetStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kTestAndResetStencilInverted
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kZero
0xffff
>
(
)
)
;
return
isInverseFill
?
&
kTestAndResetStencilInverted
:
&
kTestAndResetStencil
;
}
static
const
GrPipeline
*
MakeStencilOnlyPipeline
(
const
ProgramArgs
&
GrAAType
const
GrAppliedHardClip
&
GrPipeline
:
:
InputFlags
=
GrPipeline
:
:
InputFlags
:
:
kNone
)
;
protected
:
constexpr
static
size_t
kMiddleOutVertexStride
=
2
*
sizeof
(
float
)
;
GrPathTessellationShader
(
ClassID
classID
GrPrimitiveType
primitiveType
const
SkMatrix
&
viewMatrix
const
SkPMColor4f
&
color
PatchAttribs
attribs
)
:
GrTessellationShader
(
classID
primitiveType
viewMatrix
color
)
fAttribs
(
attribs
)
{
}
class
Impl
:
public
ProgramImpl
{
public
:
void
onEmitCode
(
EmitArgs
&
GrGPArgs
*
)
final
;
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrShaderCaps
&
const
GrGeometryProcessor
&
)
override
;
protected
:
static
const
char
*
kEvalRationalCubicFn
;
virtual
void
emitVertexCode
(
const
GrShaderCaps
&
const
GrPathTessellationShader
&
GrGLSLVertexBuilder
*
GrGLSLVaryingHandler
*
GrGPArgs
*
)
=
0
;
GrGLSLUniformHandler
:
:
UniformHandle
fAffineMatrixUniform
;
GrGLSLUniformHandler
:
:
UniformHandle
fTranslateUniform
;
GrGLSLUniformHandler
:
:
UniformHandle
fColorUniform
;
SkString
fVaryingColorName
;
}
;
const
PatchAttribs
fAttribs
;
}
;
#
endif
