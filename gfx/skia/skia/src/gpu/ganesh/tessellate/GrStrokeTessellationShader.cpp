#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrStrokeTessellationShader
.
h
"
#
include
"
src
/
gpu
/
KeyBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVarying
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
FixedCountBufferUtils
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
namespace
{
static
const
char
*
kRobustNormalizeDiffFn
=
"
float2
robust_normalize_diff
(
float2
a
float2
b
)
{
"
"
float2
diff
=
a
-
b
;
"
"
if
(
diff
=
=
float2
(
0
.
0
)
)
{
"
"
return
float2
(
0
.
0
)
;
"
"
}
else
{
"
"
float
invMag
=
1
.
0
/
max
(
abs
(
diff
.
x
)
abs
(
diff
.
y
)
)
;
"
"
return
normalize
(
invMag
*
diff
)
;
"
"
}
"
"
}
"
;
static
const
char
*
kCosineBetweenUnitVectorsFn
=
"
float
cosine_between_unit_vectors
(
float2
a
float2
b
)
{
"
"
return
clamp
(
dot
(
a
b
)
-
1
.
0
1
.
0
)
;
"
"
}
"
;
static
const
char
*
kMiterExtentFn
=
"
float
miter_extent
(
float
cosTheta
float
miterLimit
)
{
"
"
float
x
=
fma
(
cosTheta
.
5
.
5
)
;
"
"
return
(
x
*
miterLimit
*
miterLimit
>
=
1
.
0
)
?
inversesqrt
(
x
)
:
sqrt
(
x
)
;
"
"
}
"
;
static
const
char
*
kNumRadialSegmentsPerRadianFn
=
"
float
num_radial_segments_per_radian
(
float
approxDevStrokeRadius
)
{
"
"
return
.
5
/
acos
(
max
(
1
.
0
-
(
1
.
0
/
PRECISION
)
/
approxDevStrokeRadius
-
1
.
0
)
)
;
"
"
}
"
;
static
const
char
*
kUncheckedMixFn
=
"
float
unchecked_mix
(
float
a
float
b
float
T
)
{
"
"
return
fma
(
b
-
a
T
a
)
;
"
"
}
"
"
float2
unchecked_mix
(
float2
a
float2
b
float
T
)
{
"
"
return
fma
(
b
-
a
float2
(
T
)
a
)
;
"
"
}
"
"
float4
unchecked_mix
(
float4
a
float4
b
float4
T
)
{
"
"
return
fma
(
b
-
a
T
a
)
;
"
"
}
"
;
using
skgpu
:
:
tess
:
:
FixedCountStrokes
;
}
GrStrokeTessellationShader
:
:
GrStrokeTessellationShader
(
const
GrShaderCaps
&
shaderCaps
PatchAttribs
attribs
const
SkMatrix
&
viewMatrix
const
SkStrokeRec
&
stroke
SkPMColor4f
color
)
:
GrTessellationShader
(
kTessellate_GrStrokeTessellationShader_ClassID
GrPrimitiveType
:
:
kTriangleStrip
viewMatrix
color
)
fPatchAttribs
(
attribs
|
PatchAttribs
:
:
kJoinControlPoint
)
fStroke
(
stroke
)
{
SkASSERT
(
shaderCaps
.
fInfinitySupport
!
=
(
attribs
&
PatchAttribs
:
:
kExplicitCurveType
)
)
;
fAttribs
.
emplace_back
(
"
pts01Attr
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
)
;
fAttribs
.
emplace_back
(
"
pts23Attr
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
)
;
fAttribs
.
emplace_back
(
"
argsAttr
"
kFloat2_GrVertexAttribType
SkSLType
:
:
kFloat2
)
;
if
(
fPatchAttribs
&
PatchAttribs
:
:
kStrokeParams
)
{
fAttribs
.
emplace_back
(
"
dynamicStrokeAttr
"
kFloat2_GrVertexAttribType
SkSLType
:
:
kFloat2
)
;
}
if
(
fPatchAttribs
&
PatchAttribs
:
:
kColor
)
{
fAttribs
.
emplace_back
(
"
dynamicColorAttr
"
(
fPatchAttribs
&
PatchAttribs
:
:
kWideColorIfEnabled
)
?
kFloat4_GrVertexAttribType
:
kUByte4_norm_GrVertexAttribType
SkSLType
:
:
kHalf4
)
;
}
if
(
fPatchAttribs
&
PatchAttribs
:
:
kExplicitCurveType
)
{
fAttribs
.
emplace_back
(
"
curveTypeAttr
"
kFloat_GrVertexAttribType
SkSLType
:
:
kFloat
)
;
}
this
-
>
setInstanceAttributesWithImplicitOffsets
(
fAttribs
.
data
(
)
fAttribs
.
size
(
)
)
;
SkASSERT
(
this
-
>
instanceStride
(
)
=
=
sizeof
(
SkPoint
)
*
4
+
PatchAttribsStride
(
fPatchAttribs
)
)
;
if
(
!
shaderCaps
.
fVertexIDSupport
)
{
constexpr
static
Attribute
kVertexAttrib
(
"
edgeID
"
kFloat_GrVertexAttribType
SkSLType
:
:
kFloat
)
;
this
-
>
setVertexAttributesWithImplicitOffsets
(
&
kVertexAttrib
1
)
;
}
SkASSERT
(
fAttribs
.
size
(
)
<
=
kMaxAttribCount
)
;
}
class
GrStrokeTessellationShader
:
:
Impl
:
public
ProgramImpl
{
void
onEmitCode
(
EmitArgs
&
GrGPArgs
*
)
override
;
void
emitTessellationCode
(
const
GrStrokeTessellationShader
&
shader
SkString
*
code
GrGPArgs
*
gpArgs
const
GrShaderCaps
&
shaderCaps
)
const
;
void
emitFragmentCode
(
const
GrStrokeTessellationShader
&
const
EmitArgs
&
)
;
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrShaderCaps
&
const
GrGeometryProcessor
&
)
final
;
GrGLSLUniformHandler
:
:
UniformHandle
fTessControlArgsUniform
;
GrGLSLUniformHandler
:
:
UniformHandle
fTranslateUniform
;
GrGLSLUniformHandler
:
:
UniformHandle
fAffineMatrixUniform
;
GrGLSLUniformHandler
:
:
UniformHandle
fColorUniform
;
SkString
fDynamicColorName
;
}
;
void
GrStrokeTessellationShader
:
:
Impl
:
:
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
{
const
auto
&
shader
=
args
.
fGeomProc
.
cast
<
GrStrokeTessellationShader
>
(
)
;
SkPaint
:
:
Join
joinType
=
shader
.
stroke
(
)
.
getJoin
(
)
;
args
.
fVaryingHandler
-
>
emitAttributes
(
shader
)
;
args
.
fVertBuilder
-
>
defineConstant
(
"
float
"
"
PI
"
"
3
.
141592653589793238
"
)
;
args
.
fVertBuilder
-
>
defineConstant
(
"
PRECISION
"
skgpu
:
:
tess
:
:
kPrecision
)
;
float
maxEdges
=
args
.
fShaderCaps
-
>
fVertexIDSupport
?
FixedCountStrokes
:
:
kMaxEdges
:
FixedCountStrokes
:
:
kMaxEdgesNoVertexIDs
;
args
.
fVertBuilder
-
>
defineConstant
(
"
NUM_TOTAL_EDGES
"
maxEdges
)
;
if
(
shader
.
hasDynamicStroke
(
)
)
{
args
.
fVertBuilder
-
>
insertFunction
(
kNumRadialSegmentsPerRadianFn
)
;
}
args
.
fVertBuilder
-
>
insertFunction
(
kRobustNormalizeDiffFn
)
;
args
.
fVertBuilder
-
>
insertFunction
(
kCosineBetweenUnitVectorsFn
)
;
args
.
fVertBuilder
-
>
insertFunction
(
kMiterExtentFn
)
;
args
.
fVertBuilder
-
>
insertFunction
(
kUncheckedMixFn
)
;
args
.
fVertBuilder
-
>
insertFunction
(
GrTessellationShader
:
:
WangsFormulaSkSL
(
)
)
;
if
(
!
shader
.
hasDynamicStroke
(
)
)
{
const
char
*
tessArgsName
;
fTessControlArgsUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kVertex_GrShaderFlag
SkSLType
:
:
kFloat3
"
tessControlArgs
"
&
tessArgsName
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
float
NUM_RADIAL_SEGMENTS_PER_RADIAN
=
%
s
.
x
;
"
"
float
JOIN_TYPE
=
%
s
.
y
;
"
"
float
STROKE_RADIUS
=
%
s
.
z
;
"
tessArgsName
tessArgsName
tessArgsName
)
;
}
else
{
SkASSERT
(
!
shader
.
stroke
(
)
.
isHairlineStyle
(
)
)
;
const
char
*
maxScaleName
;
fTessControlArgsUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kVertex_GrShaderFlag
SkSLType
:
:
kFloat
"
maxScale
"
&
maxScaleName
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
float
STROKE_RADIUS
=
dynamicStrokeAttr
.
x
;
"
"
float
JOIN_TYPE
=
dynamicStrokeAttr
.
y
;
"
"
float
NUM_RADIAL_SEGMENTS_PER_RADIAN
=
num_radial_segments_per_radian
(
"
"
%
s
*
STROKE_RADIUS
)
;
"
maxScaleName
)
;
}
if
(
shader
.
hasDynamicColor
(
)
)
{
GrGLSLVarying
dynamicColor
{
SkSLType
:
:
kHalf4
}
;
args
.
fVaryingHandler
-
>
addVarying
(
"
dynamicColor
"
&
dynamicColor
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
dynamicColorAttr
;
"
dynamicColor
.
vsOut
(
)
)
;
fDynamicColorName
=
dynamicColor
.
fsIn
(
)
;
}
const
char
*
translateName
*
affineMatrixName
;
fAffineMatrixUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kVertex_GrShaderFlag
SkSLType
:
:
kFloat4
"
affineMatrix
"
&
affineMatrixName
)
;
fTranslateUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kVertex_GrShaderFlag
SkSLType
:
:
kFloat2
"
translate
"
&
translateName
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
float2x2
AFFINE_MATRIX
=
float2x2
(
%
s
.
xy
%
s
.
zw
)
;
\
n
"
affineMatrixName
affineMatrixName
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
float2
TRANSLATE
=
%
s
;
\
n
"
translateName
)
;
if
(
shader
.
hasExplicitCurveType
(
)
)
{
args
.
fVertBuilder
-
>
insertFunction
(
SkStringPrintf
(
"
bool
is_conic_curve
(
)
{
return
curveTypeAttr
!
=
%
g
;
}
"
skgpu
:
:
tess
:
:
kCubicCurveType
)
.
c_str
(
)
)
;
}
else
{
args
.
fVertBuilder
-
>
insertFunction
(
"
bool
is_conic_curve
(
)
{
return
isinf
(
pts23Attr
.
w
)
;
}
"
)
;
}
args
.
fVertBuilder
-
>
codeAppend
(
"
float2
p0
=
pts01Attr
.
xy
p1
=
pts01Attr
.
zw
p2
=
pts23Attr
.
xy
p3
=
pts23Attr
.
zw
;
"
"
float2
lastControlPoint
=
argsAttr
.
xy
;
"
"
float
w
=
-
1
;
"
"
if
(
is_conic_curve
(
)
)
{
"
"
w
=
p3
.
x
;
"
"
p3
=
p2
;
"
"
}
"
)
;
args
.
fVertBuilder
-
>
codeAppend
(
"
float
numParametricSegments
;
"
"
if
(
w
<
0
)
{
"
"
if
(
p0
=
=
p1
&
&
p2
=
=
p3
)
{
"
"
numParametricSegments
=
1
;
"
"
}
else
{
"
"
numParametricSegments
=
wangs_formula_cubic
(
PRECISION
p0
p1
p2
p3
AFFINE_MATRIX
)
;
"
"
}
"
"
}
else
{
"
"
numParametricSegments
=
wangs_formula_conic
(
PRECISION
"
"
AFFINE_MATRIX
*
p0
"
"
AFFINE_MATRIX
*
p1
"
"
AFFINE_MATRIX
*
p2
w
)
;
"
"
}
"
)
;
if
(
shader
.
stroke
(
)
.
isHairlineStyle
(
)
)
{
args
.
fVertBuilder
-
>
codeAppend
(
"
p0
=
AFFINE_MATRIX
*
p0
;
"
"
p1
=
AFFINE_MATRIX
*
p1
;
"
"
p2
=
AFFINE_MATRIX
*
p2
;
"
"
p3
=
AFFINE_MATRIX
*
p3
;
"
"
lastControlPoint
=
AFFINE_MATRIX
*
lastControlPoint
;
"
)
;
}
args
.
fVertBuilder
-
>
codeAppend
(
"
float2
tan0
=
robust_normalize_diff
(
(
p0
=
=
p1
)
?
(
(
p1
=
=
p2
)
?
p3
:
p2
)
:
p1
p0
)
;
"
"
float2
tan1
=
robust_normalize_diff
(
p3
(
p3
=
=
p2
)
?
(
(
p2
=
=
p1
)
?
p0
:
p1
)
:
p2
)
;
"
"
if
(
tan0
=
=
float2
(
0
)
)
{
"
"
tan0
=
float2
(
1
0
)
;
"
"
tan1
=
float2
(
-
1
0
)
;
"
"
}
"
)
;
if
(
args
.
fShaderCaps
-
>
fVertexIDSupport
)
{
args
.
fVertBuilder
-
>
codeAppend
(
"
float
edgeID
=
float
(
sk_VertexID
>
>
1
)
;
"
"
if
(
(
sk_VertexID
&
1
)
!
=
0
)
{
"
"
edgeID
=
-
edgeID
;
"
"
}
"
)
;
}
if
(
shader
.
stroke
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kRound_Join
|
|
shader
.
hasDynamicStroke
(
)
)
{
args
.
fVertBuilder
-
>
codeAppend
(
"
float2
prevTan
=
robust_normalize_diff
(
p0
lastControlPoint
)
;
"
"
float
joinRads
=
acos
(
cosine_between_unit_vectors
(
prevTan
tan0
)
)
;
"
"
float
numRadialSegmentsInJoin
=
max
(
ceil
(
joinRads
*
NUM_RADIAL_SEGMENTS_PER_RADIAN
)
1
)
;
"
"
float
numEdgesInJoin
=
numRadialSegmentsInJoin
+
2
;
"
"
numEdgesInJoin
=
min
(
numEdgesInJoin
NUM_TOTAL_EDGES
-
2
)
;
"
)
;
if
(
shader
.
hasDynamicStroke
(
)
)
{
args
.
fVertBuilder
-
>
codeAppend
(
"
if
(
JOIN_TYPE
>
=
0
)
{
"
"
numEdgesInJoin
=
sign
(
JOIN_TYPE
)
+
1
+
2
;
"
"
}
"
)
;
}
}
else
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
float
numEdgesInJoin
=
%
i
;
"
skgpu
:
:
tess
:
:
NumFixedEdgesInJoin
(
joinType
)
)
;
}
args
.
fVertBuilder
-
>
codeAppend
(
"
float
turn
=
cross_length_2d
(
p2
-
p0
p3
-
p1
)
;
"
"
float
combinedEdgeID
=
abs
(
edgeID
)
-
numEdgesInJoin
;
"
"
if
(
combinedEdgeID
<
0
)
{
"
"
tan1
=
tan0
;
"
"
if
(
lastControlPoint
!
=
p0
)
{
"
"
tan0
=
robust_normalize_diff
(
p0
lastControlPoint
)
;
"
"
}
"
"
turn
=
cross_length_2d
(
tan0
tan1
)
;
"
"
}
"
"
float
cosTheta
=
cosine_between_unit_vectors
(
tan0
tan1
)
;
"
"
float
rotation
=
acos
(
cosTheta
)
;
"
"
if
(
turn
<
0
)
{
"
"
rotation
=
-
rotation
;
"
"
}
"
"
float
numRadialSegments
;
"
"
float
strokeOutset
=
sign
(
edgeID
)
;
"
"
if
(
combinedEdgeID
<
0
)
{
"
"
numRadialSegments
=
numEdgesInJoin
-
2
;
"
"
numParametricSegments
=
1
;
"
"
p3
=
p2
=
p1
=
p0
;
"
"
combinedEdgeID
+
=
numRadialSegments
+
1
;
"
"
float
sinEpsilon
=
1e
-
2
;
"
"
bool
tangentsNearlyParallel
=
"
"
(
abs
(
turn
)
*
inversesqrt
(
dot
(
tan0
tan0
)
*
dot
(
tan1
tan1
)
)
)
<
sinEpsilon
;
"
"
if
(
!
tangentsNearlyParallel
|
|
dot
(
tan0
tan1
)
<
0
)
{
"
"
if
(
combinedEdgeID
>
=
0
)
{
"
"
strokeOutset
=
(
turn
<
0
)
?
min
(
strokeOutset
0
)
:
max
(
strokeOutset
0
)
;
"
"
}
"
"
}
"
"
combinedEdgeID
=
max
(
combinedEdgeID
0
)
;
"
"
}
else
{
"
"
float
maxCombinedSegments
=
NUM_TOTAL_EDGES
-
numEdgesInJoin
-
1
;
"
"
numRadialSegments
=
max
(
ceil
(
abs
(
rotation
)
*
NUM_RADIAL_SEGMENTS_PER_RADIAN
)
1
)
;
"
"
numRadialSegments
=
min
(
numRadialSegments
maxCombinedSegments
)
;
"
"
numParametricSegments
=
min
(
numParametricSegments
"
"
maxCombinedSegments
-
numRadialSegments
+
1
)
;
"
"
}
"
"
float
radsPerSegment
=
rotation
/
numRadialSegments
;
"
"
float
numCombinedSegments
=
numParametricSegments
+
numRadialSegments
-
1
;
"
"
bool
isFinalEdge
=
(
combinedEdgeID
>
=
numCombinedSegments
)
;
"
"
if
(
combinedEdgeID
>
numCombinedSegments
)
{
"
"
strokeOutset
=
0
;
"
"
}
"
)
;
if
(
joinType
=
=
SkPaint
:
:
kMiter_Join
|
|
shader
.
hasDynamicStroke
(
)
)
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
if
(
abs
(
edgeID
)
=
=
2
&
&
%
s
)
{
"
"
strokeOutset
*
=
miter_extent
(
cosTheta
JOIN_TYPE
)
;
"
"
}
"
shader
.
hasDynamicStroke
(
)
?
"
JOIN_TYPE
>
0
"
:
"
true
"
)
;
}
this
-
>
emitTessellationCode
(
shader
&
args
.
fVertBuilder
-
>
code
(
)
gpArgs
*
args
.
fShaderCaps
)
;
this
-
>
emitFragmentCode
(
shader
args
)
;
}
void
GrStrokeTessellationShader
:
:
Impl
:
:
emitTessellationCode
(
const
GrStrokeTessellationShader
&
shader
SkString
*
code
GrGPArgs
*
gpArgs
const
GrShaderCaps
&
shaderCaps
)
const
{
code
-
>
appendf
(
"
float2
tangent
strokeCoord
;
"
"
if
(
combinedEdgeID
!
=
0
&
&
!
isFinalEdge
)
{
"
"
float2
A
B
C
=
p1
-
p0
;
"
"
float2
D
=
p3
-
p0
;
"
"
if
(
w
>
=
0
.
0
)
{
"
"
C
*
=
w
;
"
"
B
=
.
5
*
D
-
C
;
"
"
A
=
(
w
-
1
.
0
)
*
D
;
"
"
p1
*
=
w
;
"
"
}
else
{
"
"
float2
E
=
p2
-
p1
;
"
"
B
=
E
-
C
;
"
"
A
=
fma
(
float2
(
-
3
)
E
D
)
;
"
"
}
"
"
float2
B_
=
B
*
(
numParametricSegments
*
2
.
0
)
;
"
"
float2
C_
=
C
*
(
numParametricSegments
*
numParametricSegments
)
;
"
"
float
lastParametricEdgeID
=
0
.
0
;
"
"
float
maxParametricEdgeID
=
min
(
numParametricSegments
-
1
.
0
combinedEdgeID
)
;
"
"
float
negAbsRadsPerSegment
=
-
abs
(
radsPerSegment
)
;
"
"
float
maxRotation0
=
(
1
.
0
+
combinedEdgeID
)
*
abs
(
radsPerSegment
)
;
"
"
for
(
int
exp
=
%
i
-
1
;
exp
>
=
0
;
-
-
exp
)
{
"
"
float
testParametricID
=
lastParametricEdgeID
+
exp2
(
float
(
exp
)
)
;
"
"
if
(
testParametricID
<
=
maxParametricEdgeID
)
{
"
"
float2
testTan
=
fma
(
float2
(
testParametricID
)
A
B_
)
;
"
"
testTan
=
fma
(
float2
(
testParametricID
)
testTan
C_
)
;
"
"
float
cosRotation
=
dot
(
normalize
(
testTan
)
tan0
)
;
"
"
float
maxRotation
=
fma
(
testParametricID
negAbsRadsPerSegment
maxRotation0
)
;
"
"
maxRotation
=
min
(
maxRotation
PI
)
;
"
"
if
(
cosRotation
>
=
cos
(
maxRotation
)
)
{
"
"
lastParametricEdgeID
=
testParametricID
;
"
"
}
"
"
}
"
"
}
"
"
float
parametricT
=
lastParametricEdgeID
/
numParametricSegments
;
"
"
float
lastRadialEdgeID
=
combinedEdgeID
-
lastParametricEdgeID
;
"
"
float
angle0
=
acos
(
clamp
(
tan0
.
x
-
1
.
0
1
.
0
)
)
;
"
"
angle0
=
tan0
.
y
>
=
0
.
0
?
angle0
:
-
angle0
;
"
"
float
radialAngle
=
fma
(
lastRadialEdgeID
radsPerSegment
angle0
)
;
"
"
tangent
=
float2
(
cos
(
radialAngle
)
sin
(
radialAngle
)
)
;
"
"
float2
norm
=
float2
(
-
tangent
.
y
tangent
.
x
)
;
"
"
float
a
=
dot
(
norm
A
)
b_over_2
=
dot
(
norm
B
)
c
=
dot
(
norm
C
)
;
"
"
float
discr_over_4
=
max
(
b_over_2
*
b_over_2
-
a
*
c
0
.
0
)
;
"
"
float
q
=
sqrt
(
discr_over_4
)
;
"
"
if
(
b_over_2
>
0
.
0
)
{
"
"
q
=
-
q
;
"
"
}
"
"
q
-
=
b_over_2
;
"
"
float
_5qa
=
-
.
5
*
q
*
a
;
"
"
float2
root
=
(
abs
(
fma
(
q
q
_5qa
)
)
<
abs
(
fma
(
a
c
_5qa
)
)
)
?
float2
(
q
a
)
:
float2
(
c
q
)
;
"
"
float
radialT
=
(
root
.
t
!
=
0
.
0
)
?
root
.
s
/
root
.
t
:
0
.
0
;
"
"
radialT
=
clamp
(
radialT
0
.
0
1
.
0
)
;
"
"
if
(
lastRadialEdgeID
=
=
0
.
0
)
{
"
"
radialT
=
0
.
0
;
"
"
}
"
"
float
T
=
max
(
parametricT
radialT
)
;
"
"
float2
ab
=
unchecked_mix
(
p0
p1
T
)
;
"
"
float2
bc
=
unchecked_mix
(
p1
p2
T
)
;
"
"
float2
cd
=
unchecked_mix
(
p2
p3
T
)
;
"
"
float2
abc
=
unchecked_mix
(
ab
bc
T
)
;
"
"
float2
bcd
=
unchecked_mix
(
bc
cd
T
)
;
"
"
float2
abcd
=
unchecked_mix
(
abc
bcd
T
)
;
"
"
float
u
=
unchecked_mix
(
1
.
0
w
T
)
;
"
"
float
v
=
w
+
1
-
u
;
"
"
float
uv
=
unchecked_mix
(
u
v
T
)
;
"
"
if
(
T
!
=
radialT
)
{
"
"
tangent
=
w
>
=
0
.
0
?
robust_normalize_diff
(
bc
*
u
ab
*
v
)
"
"
:
robust_normalize_diff
(
bcd
abc
)
;
"
"
}
"
"
strokeCoord
=
(
w
>
=
0
.
0
)
?
abc
/
uv
:
abcd
;
"
"
}
else
{
"
"
tangent
=
(
combinedEdgeID
=
=
0
)
?
tan0
:
tan1
;
"
"
strokeCoord
=
(
combinedEdgeID
=
=
0
)
?
p0
:
p3
;
"
"
}
"
skgpu
:
:
tess
:
:
kMaxResolveLevel
)
;
code
-
>
append
(
"
float2
ortho
=
float2
(
tangent
.
y
-
tangent
.
x
)
;
"
"
strokeCoord
+
=
ortho
*
(
STROKE_RADIUS
*
strokeOutset
)
;
"
)
;
if
(
!
shader
.
stroke
(
)
.
isHairlineStyle
(
)
)
{
code
-
>
append
(
"
float2
devCoord
=
AFFINE_MATRIX
*
strokeCoord
+
TRANSLATE
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
SkSLType
:
:
kFloat2
"
devCoord
"
)
;
gpArgs
-
>
fLocalCoordVar
.
set
(
SkSLType
:
:
kFloat2
"
strokeCoord
"
)
;
}
else
{
code
-
>
append
(
"
float2
devCoord
=
strokeCoord
+
TRANSLATE
;
"
"
float2
localCoord
=
inverse
(
AFFINE_MATRIX
)
*
strokeCoord
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
SkSLType
:
:
kFloat2
"
devCoord
"
)
;
gpArgs
-
>
fLocalCoordVar
.
set
(
SkSLType
:
:
kFloat2
"
localCoord
"
)
;
}
}
void
GrStrokeTessellationShader
:
:
Impl
:
:
emitFragmentCode
(
const
GrStrokeTessellationShader
&
shader
const
EmitArgs
&
args
)
{
if
(
!
shader
.
hasDynamicColor
(
)
)
{
const
char
*
colorUniformName
;
fColorUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kFragment_GrShaderFlag
SkSLType
:
:
kHalf4
"
color
"
&
colorUniformName
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
half4
%
s
=
%
s
;
"
args
.
fOutputColor
colorUniformName
)
;
}
else
{
args
.
fFragBuilder
-
>
codeAppendf
(
"
half4
%
s
=
%
s
;
"
args
.
fOutputColor
fDynamicColorName
.
c_str
(
)
)
;
}
args
.
fFragBuilder
-
>
codeAppendf
(
"
const
half4
%
s
=
half4
(
1
)
;
"
args
.
fOutputCoverage
)
;
}
void
GrStrokeTessellationShader
:
:
Impl
:
:
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrShaderCaps
&
const
GrGeometryProcessor
&
geomProc
)
{
const
auto
&
shader
=
geomProc
.
cast
<
GrStrokeTessellationShader
>
(
)
;
const
auto
&
stroke
=
shader
.
stroke
(
)
;
const
float
maxScale
=
std
:
:
abs
(
shader
.
viewMatrix
(
)
.
getMaxScale
(
)
)
;
if
(
!
shader
.
hasDynamicStroke
(
)
)
{
const
float
strokeRadius
=
0
.
5f
*
(
stroke
.
isHairlineStyle
(
)
?
1
.
f
:
stroke
.
getWidth
(
)
)
;
float
numRadialSegmentsPerRadian
=
skgpu
:
:
tess
:
:
CalcNumRadialSegmentsPerRadian
(
(
stroke
.
isHairlineStyle
(
)
?
1
.
f
:
maxScale
)
*
strokeRadius
)
;
pdman
.
set3f
(
fTessControlArgsUniform
numRadialSegmentsPerRadian
skgpu
:
:
tess
:
:
GetJoinType
(
stroke
)
strokeRadius
)
;
}
else
{
SkASSERT
(
!
stroke
.
isHairlineStyle
(
)
)
;
pdman
.
set1f
(
fTessControlArgsUniform
maxScale
)
;
}
const
SkMatrix
&
m
=
shader
.
viewMatrix
(
)
;
pdman
.
set2f
(
fTranslateUniform
m
.
getTranslateX
(
)
m
.
getTranslateY
(
)
)
;
pdman
.
set4f
(
fAffineMatrixUniform
m
.
getScaleX
(
)
m
.
getSkewY
(
)
m
.
getSkewX
(
)
m
.
getScaleY
(
)
)
;
if
(
!
shader
.
hasDynamicColor
(
)
)
{
pdman
.
set4fv
(
fColorUniform
1
shader
.
color
(
)
.
vec
(
)
)
;
}
}
void
GrStrokeTessellationShader
:
:
addToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
b
)
const
{
bool
keyNeedsJoin
=
!
(
fPatchAttribs
&
PatchAttribs
:
:
kStrokeParams
)
;
SkASSERT
(
fStroke
.
getJoin
(
)
>
>
2
=
=
0
)
;
uint32_t
key
=
(
uint32_t
)
(
fPatchAttribs
&
~
PatchAttribs
:
:
kColor
)
;
key
=
(
key
<
<
2
)
|
(
(
keyNeedsJoin
)
?
fStroke
.
getJoin
(
)
:
0
)
;
key
=
(
key
<
<
1
)
|
(
uint32_t
)
fStroke
.
isHairlineStyle
(
)
;
b
-
>
add32
(
key
)
;
}
std
:
:
unique_ptr
<
GrGeometryProcessor
:
:
ProgramImpl
>
GrStrokeTessellationShader
:
:
makeProgramImpl
(
const
GrShaderCaps
&
)
const
{
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
