#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
StrokeTessellator
.
h
"
#
include
"
src
/
core
/
SkGeometry
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMeshDrawTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
VertexChunkPatchAllocator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
PatchWriter
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
StrokeIterator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
namespace
skgpu
:
:
ganesh
{
namespace
{
using
namespace
skgpu
:
:
tess
;
using
StrokeWriter
=
PatchWriter
<
VertexChunkPatchAllocator
Required
<
PatchAttribs
:
:
kJoinControlPoint
>
Optional
<
PatchAttribs
:
:
kStrokeParams
>
Optional
<
PatchAttribs
:
:
kColor
>
Optional
<
PatchAttribs
:
:
kWideColorIfEnabled
>
Optional
<
PatchAttribs
:
:
kExplicitCurveType
>
ReplicateLineEndPoints
TrackJoinControlPoints
>
;
void
write_fixed_count_patches
(
StrokeWriter
&
&
patchWriter
const
SkMatrix
&
shaderMatrix
StrokeTessellator
:
:
PathStrokeList
*
pathStrokeList
)
{
patchWriter
.
setShaderTransform
(
wangs_formula
:
:
VectorXform
{
shaderMatrix
}
std
:
:
abs
(
shaderMatrix
.
getMaxScale
(
)
)
)
;
if
(
!
(
patchWriter
.
attribs
(
)
&
PatchAttribs
:
:
kStrokeParams
)
)
{
patchWriter
.
updateUniformStrokeParams
(
pathStrokeList
-
>
fStroke
)
;
}
for
(
auto
*
pathStroke
=
pathStrokeList
;
pathStroke
;
pathStroke
=
pathStroke
-
>
fNext
)
{
const
SkStrokeRec
&
stroke
=
pathStroke
-
>
fStroke
;
if
(
patchWriter
.
attribs
(
)
&
PatchAttribs
:
:
kStrokeParams
)
{
patchWriter
.
updateStrokeParamsAttrib
(
stroke
)
;
}
if
(
patchWriter
.
attribs
(
)
&
PatchAttribs
:
:
kColor
)
{
patchWriter
.
updateColorAttrib
(
pathStroke
-
>
fColor
)
;
}
StrokeIterator
strokeIter
(
pathStroke
-
>
fPath
&
pathStroke
-
>
fStroke
&
shaderMatrix
)
;
while
(
strokeIter
.
next
(
)
)
{
using
Verb
=
StrokeIterator
:
:
Verb
;
const
SkPoint
*
p
=
strokeIter
.
pts
(
)
;
int
numChops
;
switch
(
strokeIter
.
verb
(
)
)
{
case
Verb
:
:
kContourFinished
:
patchWriter
.
writeDeferredStrokePatch
(
)
;
break
;
case
Verb
:
:
kCircle
:
patchWriter
.
writeCircle
(
p
[
0
]
)
;
[
[
fallthrough
]
]
;
case
Verb
:
:
kMoveWithinContour
:
patchWriter
.
updateJoinControlPointAttrib
(
p
[
0
]
)
;
break
;
case
Verb
:
:
kLine
:
patchWriter
.
writeLine
(
p
[
0
]
p
[
1
]
)
;
break
;
case
Verb
:
:
kQuad
:
if
(
ConicHasCusp
(
p
)
)
{
SkPoint
cusp
=
SkEvalQuadAt
(
p
SkFindQuadMidTangent
(
p
)
)
;
patchWriter
.
writeCircle
(
cusp
)
;
patchWriter
.
writeLine
(
p
[
0
]
cusp
)
;
patchWriter
.
writeLine
(
cusp
p
[
2
]
)
;
}
else
{
patchWriter
.
writeQuadratic
(
p
)
;
}
break
;
case
Verb
:
:
kConic
:
if
(
ConicHasCusp
(
p
)
)
{
SkConic
conic
(
p
strokeIter
.
w
(
)
)
;
SkPoint
cusp
=
conic
.
evalAt
(
conic
.
findMidTangent
(
)
)
;
patchWriter
.
writeCircle
(
cusp
)
;
patchWriter
.
writeLine
(
p
[
0
]
cusp
)
;
patchWriter
.
writeLine
(
cusp
p
[
2
]
)
;
}
else
{
patchWriter
.
writeConic
(
p
strokeIter
.
w
(
)
)
;
}
break
;
case
Verb
:
:
kCubic
:
SkPoint
chops
[
10
]
;
float
T
[
2
]
;
bool
areCusps
;
numChops
=
FindCubicConvex180Chops
(
p
T
&
areCusps
)
;
if
(
numChops
=
=
0
)
{
patchWriter
.
writeCubic
(
p
)
;
}
else
if
(
numChops
=
=
1
)
{
SkChopCubicAt
(
p
chops
T
[
0
]
)
;
if
(
areCusps
)
{
patchWriter
.
writeCircle
(
chops
[
3
]
)
;
chops
[
2
]
=
chops
[
4
]
=
chops
[
3
]
;
}
patchWriter
.
writeCubic
(
chops
)
;
patchWriter
.
writeCubic
(
chops
+
3
)
;
}
else
{
SkASSERT
(
numChops
=
=
2
)
;
SkChopCubicAt
(
p
chops
T
[
0
]
T
[
1
]
)
;
if
(
areCusps
)
{
patchWriter
.
writeCircle
(
chops
[
3
]
)
;
patchWriter
.
writeCircle
(
chops
[
6
]
)
;
patchWriter
.
writeLine
(
chops
[
0
]
chops
[
3
]
)
;
patchWriter
.
writeLine
(
chops
[
3
]
chops
[
6
]
)
;
patchWriter
.
writeLine
(
chops
[
6
]
chops
[
9
]
)
;
}
else
{
patchWriter
.
writeCubic
(
chops
)
;
patchWriter
.
writeCubic
(
chops
+
3
)
;
patchWriter
.
writeCubic
(
chops
+
6
)
;
}
}
break
;
}
}
}
}
}
SKGPU_DECLARE_STATIC_UNIQUE_KEY
(
gVertexIDFallbackBufferKey
)
;
void
StrokeTessellator
:
:
prepare
(
GrMeshDrawTarget
*
target
const
SkMatrix
&
shaderMatrix
PathStrokeList
*
pathStrokeList
int
totalCombinedStrokeVerbCnt
)
{
LinearTolerances
worstCase
;
const
int
preallocCount
=
FixedCountStrokes
:
:
PreallocCount
(
totalCombinedStrokeVerbCnt
)
;
StrokeWriter
patchWriter
{
fAttribs
&
worstCase
target
&
fVertexChunkArray
preallocCount
}
;
write_fixed_count_patches
(
std
:
:
move
(
patchWriter
)
shaderMatrix
pathStrokeList
)
;
fVertexCount
=
FixedCountStrokes
:
:
VertexCount
(
worstCase
)
;
if
(
!
target
-
>
caps
(
)
.
shaderCaps
(
)
-
>
fVertexIDSupport
)
{
fVertexCount
=
std
:
:
min
(
fVertexCount
2
*
FixedCountStrokes
:
:
kMaxEdgesNoVertexIDs
)
;
SKGPU_DEFINE_STATIC_UNIQUE_KEY
(
gVertexIDFallbackBufferKey
)
;
fVertexBufferIfNoIDSupport
=
target
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kVertex
FixedCountStrokes
:
:
VertexBufferSize
(
)
gVertexIDFallbackBufferKey
FixedCountStrokes
:
:
WriteVertexBuffer
)
;
}
}
void
StrokeTessellator
:
:
draw
(
GrOpFlushState
*
flushState
)
const
{
if
(
fVertexChunkArray
.
empty
(
)
|
|
fVertexCount
<
=
0
)
{
return
;
}
if
(
!
flushState
-
>
caps
(
)
.
shaderCaps
(
)
-
>
fVertexIDSupport
&
&
!
fVertexBufferIfNoIDSupport
)
{
return
;
}
for
(
const
auto
&
instanceChunk
:
fVertexChunkArray
)
{
flushState
-
>
bindBuffers
(
nullptr
instanceChunk
.
fBuffer
fVertexBufferIfNoIDSupport
)
;
flushState
-
>
drawInstanced
(
instanceChunk
.
fCount
instanceChunk
.
fBase
fVertexCount
0
)
;
}
}
}
