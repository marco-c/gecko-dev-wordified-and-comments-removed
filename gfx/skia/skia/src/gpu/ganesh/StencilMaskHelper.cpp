#
include
"
src
/
gpu
/
ganesh
/
StencilMaskHelper
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStencilSettings
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrDisableColorXP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrShape
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
namespace
{
static
constexpr
GrUserStencilSettings
gUserToClipReplace
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kSetClipAndReplaceUserBits
GrUserStencilOp
:
:
kZeroClipAndUserBits
0xffff
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gInvUserToClipReplace
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kSetClipAndReplaceUserBits
GrUserStencilOp
:
:
kZeroClipAndUserBits
0xffff
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUserToClipIsect
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kLessIfInClip
0xffff
GrUserStencilOp
:
:
kSetClipAndReplaceUserBits
GrUserStencilOp
:
:
kZeroClipAndUserBits
0xffff
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUserToClipDiff
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqualIfInClip
0xffff
GrUserStencilOp
:
:
kSetClipAndReplaceUserBits
GrUserStencilOp
:
:
kZeroClipAndUserBits
0xffff
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUserToClipUnion
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kSetClipAndReplaceUserBits
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gInvUserToClipUnionPass0
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kSetClipBit
GrUserStencilOp
:
:
kKeep
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUserToClipXorPass0
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kInvertClipBit
GrUserStencilOp
:
:
kKeep
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gInvUserToClipXorPass0
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kInvertClipBit
GrUserStencilOp
:
:
kKeep
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUserToClipRDiffPass0
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kInvertClipBit
GrUserStencilOp
:
:
kZeroClipBit
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gInvUserToClipRDiffPass0
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kInvertClipBit
GrUserStencilOp
:
:
kZeroClipBit
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gZeroUserBits
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
static
constexpr
const
GrUserStencilSettings
*
gUserToClipTable
[
2
]
[
1
+
SkRegion
:
:
kLastOp
]
[
3
]
=
{
{
{
&
gUserToClipDiff
nullptr
nullptr
}
{
&
gUserToClipIsect
nullptr
nullptr
}
{
&
gUserToClipUnion
nullptr
nullptr
}
{
&
gUserToClipXorPass0
&
gZeroUserBits
nullptr
}
{
&
gUserToClipRDiffPass0
&
gZeroUserBits
nullptr
}
{
&
gUserToClipReplace
nullptr
nullptr
}
}
{
{
&
gUserToClipIsect
nullptr
nullptr
}
{
&
gUserToClipDiff
nullptr
nullptr
}
{
&
gInvUserToClipUnionPass0
&
gZeroUserBits
nullptr
}
{
&
gInvUserToClipXorPass0
&
gZeroUserBits
nullptr
}
{
&
gInvUserToClipRDiffPass0
&
gZeroUserBits
nullptr
}
{
&
gInvUserToClipReplace
nullptr
nullptr
}
}
}
;
static
constexpr
GrUserStencilSettings
gReplaceClip
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kSetClipBit
GrUserStencilOp
:
:
kSetClipBit
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gUnionClip
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlwaysIfInClip
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kSetClipBit
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gXorClip
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kInvertClipBit
GrUserStencilOp
:
:
kInvertClipBit
0x0000
>
(
)
)
;
static
constexpr
GrUserStencilSettings
gDiffClip
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlwaysIfInClip
0xffff
GrUserStencilOp
:
:
kZeroClipBit
GrUserStencilOp
:
:
kKeep
0x0000
>
(
)
)
;
static
constexpr
const
GrUserStencilSettings
*
gDirectDrawTable
[
1
+
SkRegion
:
:
kLastOp
]
[
2
]
=
{
{
&
gDiffClip
nullptr
}
{
nullptr
nullptr
}
{
&
gUnionClip
nullptr
}
{
&
gXorClip
nullptr
}
{
nullptr
nullptr
}
{
&
gReplaceClip
nullptr
}
}
;
static_assert
(
0
=
=
SkRegion
:
:
kDifference_Op
)
;
static_assert
(
1
=
=
SkRegion
:
:
kIntersect_Op
)
;
static_assert
(
2
=
=
SkRegion
:
:
kUnion_Op
)
;
static_assert
(
3
=
=
SkRegion
:
:
kXOR_Op
)
;
static_assert
(
4
=
=
SkRegion
:
:
kReverseDifference_Op
)
;
static_assert
(
5
=
=
SkRegion
:
:
kReplace_Op
)
;
static
constexpr
GrUserStencilSettings
gDrawToStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kIncMaybeClamp
GrUserStencilOp
:
:
kIncMaybeClamp
0xffff
>
(
)
)
;
GrUserStencilSettings
const
*
const
*
get_stencil_passes
(
SkRegion
:
:
Op
op
skgpu
:
:
ganesh
:
:
PathRenderer
:
:
StencilSupport
stencilSupport
bool
fillInverted
bool
*
drawDirectToClip
)
{
bool
canRenderDirectToStencil
=
skgpu
:
:
ganesh
:
:
PathRenderer
:
:
kNoRestriction_StencilSupport
=
=
stencilSupport
;
SkASSERT
(
(
unsigned
)
op
<
=
SkRegion
:
:
kLastOp
)
;
if
(
canRenderDirectToStencil
&
&
!
fillInverted
)
{
GrUserStencilSettings
const
*
const
*
directPass
=
gDirectDrawTable
[
op
]
;
if
(
directPass
[
0
]
)
{
*
drawDirectToClip
=
true
;
return
directPass
;
}
}
*
drawDirectToClip
=
false
;
return
gUserToClipTable
[
fillInverted
]
[
op
]
;
}
void
draw_stencil_rect
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrHardClip
&
clip
const
GrUserStencilSettings
*
ss
const
SkMatrix
&
matrix
const
SkRect
&
rect
GrAA
aa
)
{
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
sdc
-
>
stencilRect
(
&
clip
ss
std
:
:
move
(
paint
)
aa
matrix
rect
)
;
}
void
draw_path
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
skgpu
:
:
ganesh
:
:
PathRenderer
*
pr
const
GrHardClip
&
clip
const
SkIRect
&
bounds
const
GrUserStencilSettings
*
ss
const
SkMatrix
&
matrix
const
GrStyledShape
&
shape
GrAA
aa
)
{
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
GrAAType
pathAAType
=
aa
=
=
GrAA
:
:
kYes
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
skgpu
:
:
ganesh
:
:
PathRenderer
:
:
DrawPathArgs
args
{
rContext
std
:
:
move
(
paint
)
ss
sdc
&
clip
&
bounds
&
matrix
&
shape
pathAAType
false
}
;
pr
-
>
drawPath
(
args
)
;
}
void
stencil_path
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
skgpu
:
:
ganesh
:
:
PathRenderer
*
pr
const
GrFixedClip
&
clip
const
SkMatrix
&
matrix
const
GrStyledShape
&
shape
GrAA
aa
)
{
skgpu
:
:
ganesh
:
:
PathRenderer
:
:
StencilPathArgs
args
;
args
.
fContext
=
rContext
;
args
.
fSurfaceDrawContext
=
sdc
;
args
.
fClip
=
&
clip
;
args
.
fClipConservativeBounds
=
&
clip
.
scissorRect
(
)
;
args
.
fViewMatrix
=
&
matrix
;
args
.
fShape
=
&
shape
;
args
.
fDoStencilMSAA
=
aa
;
pr
-
>
stencilPath
(
args
)
;
}
GrAA
supported_aa
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
GrAA
aa
)
{
return
GrAA
(
sdc
-
>
numSamples
(
)
>
1
|
|
sdc
-
>
canUseDynamicMSAA
(
)
)
;
}
}
namespace
skgpu
:
:
ganesh
{
StencilMaskHelper
:
:
StencilMaskHelper
(
GrRecordingContext
*
rContext
SurfaceDrawContext
*
sdc
)
:
fContext
(
rContext
)
fSDC
(
sdc
)
fClip
(
sdc
-
>
dimensions
(
)
)
{
}
bool
StencilMaskHelper
:
:
init
(
const
SkIRect
&
bounds
uint32_t
genID
const
GrWindowRectangles
&
windowRects
int
numFPs
)
{
if
(
!
fSDC
-
>
mustRenderClip
(
genID
bounds
numFPs
)
)
{
return
false
;
}
fClip
.
setStencilClip
(
genID
)
;
SkAssertResult
(
fClip
.
fixedClip
(
)
.
setScissor
(
bounds
)
)
;
if
(
!
windowRects
.
empty
(
)
)
{
fClip
.
fixedClip
(
)
.
setWindowRectangles
(
windowRects
GrWindowRectsState
:
:
Mode
:
:
kExclusive
)
;
}
fNumFPs
=
numFPs
;
return
true
;
}
void
StencilMaskHelper
:
:
drawRect
(
const
SkRect
&
rect
const
SkMatrix
&
matrix
SkRegion
:
:
Op
op
GrAA
aa
)
{
if
(
rect
.
isEmpty
(
)
)
{
return
;
}
bool
drawDirectToClip
;
auto
passes
=
get_stencil_passes
(
op
PathRenderer
:
:
kNoRestriction_StencilSupport
false
&
drawDirectToClip
)
;
aa
=
supported_aa
(
fSDC
aa
)
;
if
(
!
drawDirectToClip
)
{
draw_stencil_rect
(
fSDC
fClip
.
fixedClip
(
)
&
gDrawToStencil
matrix
rect
aa
)
;
}
for
(
GrUserStencilSettings
const
*
const
*
pass
=
passes
;
*
pass
;
+
+
pass
)
{
if
(
drawDirectToClip
)
{
draw_stencil_rect
(
fSDC
fClip
*
pass
matrix
rect
aa
)
;
}
else
{
draw_stencil_rect
(
fSDC
fClip
*
pass
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
fClip
.
fixedClip
(
)
.
scissorRect
(
)
)
aa
)
;
}
}
}
bool
StencilMaskHelper
:
:
drawPath
(
const
SkPath
&
path
const
SkMatrix
&
matrix
SkRegion
:
:
Op
op
GrAA
aa
)
{
if
(
path
.
isEmpty
(
)
)
{
return
true
;
}
aa
=
supported_aa
(
fSDC
aa
)
;
GrAAType
pathAAType
=
aa
=
=
GrAA
:
:
kYes
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
PathRenderer
:
:
StencilSupport
stencilSupport
;
bool
fillInverted
=
path
.
isInverseFillType
(
)
;
SkTCopyOnFirstWrite
<
SkPath
>
clipPath
(
path
)
;
if
(
fillInverted
)
{
clipPath
.
writable
(
)
-
>
toggleInverseFillType
(
)
;
}
GrStyledShape
shape
(
*
clipPath
GrStyle
:
:
SimpleFill
(
)
)
;
SkASSERT
(
!
shape
.
inverseFilled
(
)
)
;
PathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
fContext
-
>
priv
(
)
.
caps
(
)
;
canDrawArgs
.
fProxy
=
fSDC
-
>
asRenderTargetProxy
(
)
;
canDrawArgs
.
fClipConservativeBounds
=
&
fClip
.
fixedClip
(
)
.
scissorRect
(
)
;
canDrawArgs
.
fViewMatrix
=
&
matrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fPaint
=
nullptr
;
canDrawArgs
.
fSurfaceProps
=
&
fSDC
-
>
surfaceProps
(
)
;
canDrawArgs
.
fAAType
=
pathAAType
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
auto
pr
=
fContext
-
>
priv
(
)
.
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
PathRendererChain
:
:
DrawType
:
:
kStencil
&
stencilSupport
)
;
if
(
!
pr
)
{
return
false
;
}
bool
drawDirectToClip
;
auto
passes
=
get_stencil_passes
(
op
stencilSupport
fillInverted
&
drawDirectToClip
)
;
if
(
!
drawDirectToClip
)
{
if
(
stencilSupport
=
=
PathRenderer
:
:
kNoRestriction_StencilSupport
)
{
draw_path
(
fContext
fSDC
pr
fClip
.
fixedClip
(
)
fClip
.
fixedClip
(
)
.
scissorRect
(
)
&
gDrawToStencil
matrix
shape
aa
)
;
}
else
{
stencil_path
(
fContext
fSDC
pr
fClip
.
fixedClip
(
)
matrix
shape
aa
)
;
}
}
for
(
GrUserStencilSettings
const
*
const
*
pass
=
passes
;
*
pass
;
+
+
pass
)
{
if
(
drawDirectToClip
)
{
draw_path
(
fContext
fSDC
pr
fClip
fClip
.
fixedClip
(
)
.
scissorRect
(
)
*
pass
matrix
shape
aa
)
;
}
else
{
draw_stencil_rect
(
fSDC
fClip
*
pass
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
fClip
.
fixedClip
(
)
.
scissorRect
(
)
)
aa
)
;
}
}
return
true
;
}
bool
StencilMaskHelper
:
:
drawShape
(
const
GrShape
&
shape
const
SkMatrix
&
matrix
SkRegion
:
:
Op
op
GrAA
aa
)
{
if
(
shape
.
isRect
(
)
&
&
!
shape
.
inverted
(
)
)
{
this
-
>
drawRect
(
shape
.
rect
(
)
matrix
op
aa
)
;
return
true
;
}
else
{
SkPath
p
;
shape
.
asPath
(
&
p
)
;
return
this
-
>
drawPath
(
p
matrix
op
aa
)
;
}
}
void
StencilMaskHelper
:
:
clear
(
bool
insideStencil
)
{
if
(
fClip
.
fixedClip
(
)
.
hasWindowRectangles
(
)
)
{
draw_stencil_rect
(
fSDC
fClip
.
fixedClip
(
)
GrStencilSettings
:
:
SetClipBitSettings
(
insideStencil
)
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
fClip
.
fixedClip
(
)
.
scissorRect
(
)
)
GrAA
:
:
kNo
)
;
}
else
{
fSDC
-
>
clearStencilClip
(
fClip
.
fixedClip
(
)
.
scissorRect
(
)
insideStencil
)
;
}
}
void
StencilMaskHelper
:
:
finish
(
)
{
fSDC
-
>
setLastClip
(
fClip
.
stencilStackID
(
)
fClip
.
fixedClip
(
)
.
scissorRect
(
)
fNumFPs
)
;
}
}
