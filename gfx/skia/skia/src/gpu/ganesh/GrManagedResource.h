#
ifndef
GrManagedResource_DEFINED
#
define
GrManagedResource_DEFINED
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
src
/
base
/
SkRandom
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
#
include
<
atomic
>
class
GrTexture
;
#
ifdef
SK_DEBUG
#
define
SK_TRACE_MANAGED_RESOURCES
#
endif
class
GrManagedResource
:
SkNoncopyable
{
public
:
#
ifdef
SK_TRACE_MANAGED_RESOURCES
struct
Hash
{
uint32_t
operator
(
)
(
const
GrManagedResource
*
const
&
r
)
const
{
SkASSERT
(
r
)
;
return
r
-
>
fKey
;
}
}
;
class
Trace
{
public
:
~
Trace
(
)
{
fHashSet
.
foreach
(
[
]
(
const
GrManagedResource
*
r
)
{
r
-
>
dumpInfo
(
)
;
}
)
;
SkASSERT
(
0
=
=
fHashSet
.
count
(
)
)
;
}
void
add
(
const
GrManagedResource
*
r
)
{
SkAutoMutexExclusive
locked
(
fLock
)
;
fHashSet
.
add
(
r
)
;
}
void
remove
(
const
GrManagedResource
*
r
)
{
SkAutoMutexExclusive
locked
(
fLock
)
;
fHashSet
.
remove
(
r
)
;
}
private
:
SkMutex
fLock
;
SkTHashSet
<
const
GrManagedResource
*
GrManagedResource
:
:
Hash
>
fHashSet
SK_GUARDED_BY
(
fLock
)
;
}
;
static
std
:
:
atomic
<
uint32_t
>
fKeyCounter
;
#
endif
GrManagedResource
(
)
:
fRefCnt
(
1
)
{
#
ifdef
SK_TRACE_MANAGED_RESOURCES
fKey
=
fKeyCounter
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
GetTrace
(
)
-
>
add
(
this
)
;
#
endif
}
virtual
~
GrManagedResource
(
)
{
#
ifdef
SK_DEBUG
auto
count
=
this
-
>
getRefCnt
(
)
;
SkASSERTF
(
count
=
=
1
"
fRefCnt
was
%
d
"
count
)
;
fRefCnt
.
store
(
0
)
;
#
endif
}
#
ifdef
SK_DEBUG
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
.
load
(
)
;
}
#
endif
bool
unique
(
)
const
{
return
1
=
=
fRefCnt
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
ref
(
)
const
{
SkDEBUGCODE
(
int
newRefCount
=
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
SkASSERT
(
newRefCount
>
=
1
)
;
}
void
unref
(
)
const
{
int
newRefCount
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
;
SkASSERT
(
newRefCount
>
=
0
)
;
if
(
newRefCount
=
=
1
)
{
this
-
>
internal_dispose
(
)
;
}
}
#
ifdef
SK_DEBUG
virtual
const
GrManagedResource
*
asVkImageResource
(
)
const
{
return
nullptr
;
}
#
endif
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
this
-
>
getRefCnt
(
)
>
0
)
;
}
#
endif
#
ifdef
SK_TRACE_MANAGED_RESOURCES
virtual
void
dumpInfo
(
)
const
=
0
;
#
endif
private
:
#
ifdef
SK_TRACE_MANAGED_RESOURCES
static
Trace
*
GetTrace
(
)
{
static
Trace
kTrace
;
return
&
kTrace
;
}
#
endif
virtual
void
freeGPUData
(
)
const
=
0
;
void
internal_dispose
(
)
const
{
this
-
>
freeGPUData
(
)
;
#
ifdef
SK_TRACE_MANAGED_RESOURCES
GetTrace
(
)
-
>
remove
(
this
)
;
#
endif
#
ifdef
SK_DEBUG
SkASSERT
(
0
=
=
this
-
>
getRefCnt
(
)
)
;
fRefCnt
.
store
(
1
)
;
#
endif
delete
this
;
}
mutable
std
:
:
atomic
<
int32_t
>
fRefCnt
;
#
ifdef
SK_TRACE_MANAGED_RESOURCES
uint32_t
fKey
;
#
endif
using
INHERITED
=
SkNoncopyable
;
}
;
class
GrRecycledResource
:
public
GrManagedResource
{
public
:
void
recycle
(
)
const
{
if
(
this
-
>
unique
(
)
)
{
this
-
>
onRecycle
(
)
;
}
else
{
this
-
>
unref
(
)
;
}
}
private
:
virtual
void
onRecycle
(
)
const
=
0
;
}
;
class
GrTextureResource
:
public
GrManagedResource
{
public
:
GrTextureResource
(
)
{
}
~
GrTextureResource
(
)
override
{
SkASSERT
(
!
fReleaseHelper
)
;
}
void
setRelease
(
sk_sp
<
GrSurface
:
:
RefCntedReleaseProc
>
releaseHelper
)
{
fReleaseHelper
=
std
:
:
move
(
releaseHelper
)
;
}
protected
:
mutable
sk_sp
<
GrSurface
:
:
RefCntedReleaseProc
>
fReleaseHelper
;
void
invokeReleaseProc
(
)
const
{
if
(
fReleaseHelper
)
{
fReleaseHelper
.
reset
(
)
;
}
}
private
:
using
INHERITED
=
GrManagedResource
;
}
;
#
endif
