#
ifndef
GrEagerVertexAllocator_DEFINED
#
define
GrEagerVertexAllocator_DEFINED
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrThreadSafeCache
.
h
"
class
GrMeshDrawTarget
;
class
GrEagerVertexAllocator
{
public
:
virtual
void
*
lock
(
size_t
stride
int
eagerCount
)
=
0
;
virtual
void
unlock
(
int
actualCount
)
=
0
;
virtual
~
GrEagerVertexAllocator
(
)
{
}
skgpu
:
:
VertexWriter
lockWriter
(
size_t
stride
int
eagerCount
)
{
void
*
p
=
this
-
>
lock
(
stride
eagerCount
)
;
return
p
?
skgpu
:
:
VertexWriter
{
p
stride
*
eagerCount
}
:
skgpu
:
:
VertexWriter
{
}
;
}
}
;
class
GrEagerDynamicVertexAllocator
:
public
GrEagerVertexAllocator
{
public
:
GrEagerDynamicVertexAllocator
(
GrMeshDrawTarget
*
target
sk_sp
<
const
GrBuffer
>
*
vertexBuffer
int
*
baseVertex
)
:
fTarget
(
target
)
fVertexBuffer
(
vertexBuffer
)
fBaseVertex
(
baseVertex
)
{
}
#
ifdef
SK_DEBUG
~
GrEagerDynamicVertexAllocator
(
)
override
{
SkASSERT
(
!
fLockCount
)
;
}
#
endif
void
*
lock
(
size_t
stride
int
eagerCount
)
final
;
void
unlock
(
int
actualCount
)
final
;
private
:
GrMeshDrawTarget
*
const
fTarget
;
sk_sp
<
const
GrBuffer
>
*
const
fVertexBuffer
;
int
*
const
fBaseVertex
;
size_t
fLockStride
;
int
fLockCount
=
0
;
}
;
class
GrCpuVertexAllocator
:
public
GrEagerVertexAllocator
{
public
:
GrCpuVertexAllocator
(
)
=
default
;
#
ifdef
SK_DEBUG
~
GrCpuVertexAllocator
(
)
override
{
SkASSERT
(
!
fLockStride
&
&
!
fVertices
&
&
!
fVertexData
)
;
}
#
endif
void
*
lock
(
size_t
stride
int
eagerCount
)
override
;
void
unlock
(
int
actualCount
)
override
;
sk_sp
<
GrThreadSafeCache
:
:
VertexData
>
detachVertexData
(
)
;
private
:
sk_sp
<
GrThreadSafeCache
:
:
VertexData
>
fVertexData
;
void
*
fVertices
=
nullptr
;
size_t
fLockStride
=
0
;
}
;
#
endif
