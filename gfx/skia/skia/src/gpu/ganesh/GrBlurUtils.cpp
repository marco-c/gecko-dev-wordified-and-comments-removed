#
include
"
src
/
gpu
/
ganesh
/
GrBlurUtils
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
base
/
SkTLazy
.
h
"
#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFixedClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrThreadSafeCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrUtil
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrTextureEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
static
bool
clip_bounds_quick_reject
(
const
SkIRect
&
clipBounds
const
SkIRect
&
rect
)
{
return
clipBounds
.
isEmpty
(
)
|
|
rect
.
isEmpty
(
)
|
|
!
SkIRect
:
:
Intersects
(
clipBounds
rect
)
;
}
static
constexpr
auto
kMaskOrigin
=
kTopLeft_GrSurfaceOrigin
;
static
bool
draw_mask
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
maskBounds
GrPaint
&
&
paint
GrSurfaceProxyView
mask
)
{
SkMatrix
inverse
;
if
(
!
viewMatrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
mask
.
concatSwizzle
(
skgpu
:
:
Swizzle
(
"
aaaa
"
)
)
;
SkMatrix
matrix
=
SkMatrix
:
:
Translate
(
-
SkIntToScalar
(
maskBounds
.
fLeft
)
-
SkIntToScalar
(
maskBounds
.
fTop
)
)
;
matrix
.
preConcat
(
viewMatrix
)
;
paint
.
setCoverageFragmentProcessor
(
GrTextureEffect
:
:
Make
(
std
:
:
move
(
mask
)
kUnknown_SkAlphaType
matrix
)
)
;
sdc
-
>
fillPixelsWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
maskBounds
inverse
)
;
return
true
;
}
static
void
mask_release_proc
(
void
*
addr
void
*
)
{
SkMask
:
:
FreeImage
(
addr
)
;
}
struct
DrawRectData
{
SkIVector
fOffset
;
SkISize
fSize
;
}
;
static
sk_sp
<
SkData
>
create_data
(
const
SkIRect
&
drawRect
const
SkIRect
&
origDevBounds
)
{
DrawRectData
drawRectData
{
{
drawRect
.
fLeft
-
origDevBounds
.
fLeft
drawRect
.
fTop
-
origDevBounds
.
fTop
}
drawRect
.
size
(
)
}
;
return
SkData
:
:
MakeWithCopy
(
&
drawRectData
sizeof
(
drawRectData
)
)
;
}
static
SkIRect
extract_draw_rect_from_data
(
SkData
*
data
const
SkIRect
&
origDevBounds
)
{
auto
drawRectData
=
static_cast
<
const
DrawRectData
*
>
(
data
-
>
data
(
)
)
;
return
SkIRect
:
:
MakeXYWH
(
origDevBounds
.
fLeft
+
drawRectData
-
>
fOffset
.
fX
origDevBounds
.
fTop
+
drawRectData
-
>
fOffset
.
fY
drawRectData
-
>
fSize
.
fWidth
drawRectData
-
>
fSize
.
fHeight
)
;
}
static
GrSurfaceProxyView
sw_create_filtered_mask
(
GrRecordingContext
*
rContext
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
shape
const
SkMaskFilter
*
filter
const
SkIRect
&
unclippedDevShapeBounds
const
SkIRect
&
clipBounds
SkIRect
*
drawRect
skgpu
:
:
UniqueKey
*
key
)
{
SkASSERT
(
filter
)
;
SkASSERT
(
!
shape
.
style
(
)
.
applies
(
)
)
;
auto
threadSafeCache
=
rContext
-
>
priv
(
)
.
threadSafeCache
(
)
;
GrSurfaceProxyView
filteredMaskView
;
sk_sp
<
SkData
>
data
;
if
(
key
-
>
isValid
(
)
)
{
std
:
:
tie
(
filteredMaskView
data
)
=
threadSafeCache
-
>
findWithData
(
*
key
)
;
}
if
(
filteredMaskView
)
{
SkASSERT
(
data
)
;
SkASSERT
(
kMaskOrigin
=
=
filteredMaskView
.
origin
(
)
)
;
*
drawRect
=
extract_draw_rect_from_data
(
data
.
get
(
)
unclippedDevShapeBounds
)
;
}
else
{
SkStrokeRec
:
:
InitStyle
fillOrHairline
=
shape
.
style
(
)
.
isSimpleHairline
(
)
?
SkStrokeRec
:
:
kHairline_InitStyle
:
SkStrokeRec
:
:
kFill_InitStyle
;
SkPath
devPath
;
shape
.
asPath
(
&
devPath
)
;
devPath
.
transform
(
viewMatrix
)
;
SkMask
srcM
dstM
;
if
(
!
SkDraw
:
:
DrawToMask
(
devPath
clipBounds
filter
&
viewMatrix
&
srcM
SkMask
:
:
kComputeBoundsAndRenderImage_CreateMode
fillOrHairline
)
)
{
return
{
}
;
}
SkAutoMaskFreeImage
autoSrc
(
srcM
.
fImage
)
;
SkASSERT
(
SkMask
:
:
kA8_Format
=
=
srcM
.
fFormat
)
;
if
(
!
as_MFB
(
filter
)
-
>
filterMask
(
&
dstM
srcM
viewMatrix
nullptr
)
)
{
return
{
}
;
}
SkAutoMaskFreeImage
autoDst
(
dstM
.
fImage
)
;
if
(
clip_bounds_quick_reject
(
clipBounds
dstM
.
fBounds
)
)
{
return
{
}
;
}
SkBitmap
bm
;
if
(
!
bm
.
installPixels
(
SkImageInfo
:
:
MakeA8
(
dstM
.
fBounds
.
width
(
)
dstM
.
fBounds
.
height
(
)
)
autoDst
.
release
(
)
dstM
.
fRowBytes
mask_release_proc
nullptr
)
)
{
return
{
}
;
}
bm
.
setImmutable
(
)
;
std
:
:
tie
(
filteredMaskView
std
:
:
ignore
)
=
GrMakeUncachedBitmapProxyView
(
rContext
bm
GrMipmapped
:
:
kNo
SkBackingFit
:
:
kApprox
)
;
if
(
!
filteredMaskView
)
{
return
{
}
;
}
SkASSERT
(
kMaskOrigin
=
=
filteredMaskView
.
origin
(
)
)
;
*
drawRect
=
dstM
.
fBounds
;
if
(
key
-
>
isValid
(
)
)
{
key
-
>
setCustomData
(
create_data
(
*
drawRect
unclippedDevShapeBounds
)
)
;
std
:
:
tie
(
filteredMaskView
data
)
=
threadSafeCache
-
>
addWithData
(
*
key
filteredMaskView
)
;
*
drawRect
=
extract_draw_rect_from_data
(
data
.
get
(
)
unclippedDevShapeBounds
)
;
}
}
return
filteredMaskView
;
}
static
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
create_mask_GPU
(
GrRecordingContext
*
rContext
const
SkIRect
&
maskRect
const
SkMatrix
&
origViewMatrix
const
GrStyledShape
&
shape
int
sampleCnt
)
{
SkSurfaceProps
defaultSurfaceProps
;
auto
approxSize
=
GrResourceProvider
:
:
MakeApprox
(
maskRect
.
size
(
)
)
;
auto
sdc
=
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
:
:
MakeWithFallback
(
rContext
GrColorType
:
:
kAlpha_8
nullptr
SkBackingFit
:
:
kExact
approxSize
defaultSurfaceProps
sampleCnt
GrMipmapped
:
:
kNo
GrProtected
:
:
kNo
kMaskOrigin
)
;
if
(
!
sdc
)
{
return
nullptr
;
}
sdc
-
>
clear
(
SK_PMColor4fTRANSPARENT
)
;
GrPaint
maskPaint
;
maskPaint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kReplace_Op
)
;
GrFixedClip
clip
(
sdc
-
>
dimensions
(
)
SkIRect
:
:
MakeWH
(
maskRect
.
width
(
)
maskRect
.
height
(
)
)
)
;
SkMatrix
viewMatrix
=
origViewMatrix
;
viewMatrix
.
postTranslate
(
-
SkIntToScalar
(
maskRect
.
fLeft
)
-
SkIntToScalar
(
maskRect
.
fTop
)
)
;
sdc
-
>
drawShape
(
&
clip
std
:
:
move
(
maskPaint
)
GrAA
:
:
kYes
viewMatrix
GrStyledShape
(
shape
)
)
;
return
sdc
;
}
static
bool
get_unclipped_shape_dev_bounds
(
const
GrStyledShape
&
shape
const
SkMatrix
&
matrix
SkIRect
*
devBounds
)
{
SkRect
shapeDevBounds
;
if
(
shape
.
inverseFilled
(
)
)
{
shapeDevBounds
=
{
SK_ScalarNegativeInfinity
SK_ScalarNegativeInfinity
SK_ScalarInfinity
SK_ScalarInfinity
}
;
}
else
{
SkRect
shapeBounds
=
shape
.
styledBounds
(
)
;
if
(
shapeBounds
.
isEmpty
(
)
)
{
return
false
;
}
matrix
.
mapRect
(
&
shapeDevBounds
shapeBounds
)
;
}
static
constexpr
int32_t
kMaxInt
=
2147483520
;
if
(
!
shapeDevBounds
.
intersect
(
SkRect
:
:
MakeLTRB
(
INT32_MIN
INT32_MIN
kMaxInt
kMaxInt
)
)
)
{
return
false
;
}
if
(
SkScalarRoundToInt
(
shapeDevBounds
.
width
(
)
)
>
kMaxInt
|
|
SkScalarRoundToInt
(
shapeDevBounds
.
height
(
)
)
>
kMaxInt
)
{
return
false
;
}
shapeDevBounds
.
roundOut
(
devBounds
)
;
return
true
;
}
static
bool
get_shape_and_clip_bounds
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
GrStyledShape
&
shape
const
SkMatrix
&
matrix
SkIRect
*
unclippedDevShapeBounds
SkIRect
*
devClipBounds
)
{
*
devClipBounds
=
clip
?
clip
-
>
getConservativeBounds
(
)
:
SkIRect
:
:
MakeWH
(
sdc
-
>
width
(
)
sdc
-
>
height
(
)
)
;
if
(
!
get_unclipped_shape_dev_bounds
(
shape
matrix
unclippedDevShapeBounds
)
)
{
*
unclippedDevShapeBounds
=
SkIRect
:
:
MakeEmpty
(
)
;
return
false
;
}
return
true
;
}
static
bool
compute_key_and_clip_bounds
(
skgpu
:
:
UniqueKey
*
maskKey
SkIRect
*
boundsForClip
const
GrCaps
*
caps
const
SkMatrix
&
viewMatrix
bool
inverseFilled
const
SkMaskFilterBase
*
maskFilter
const
GrStyledShape
&
shape
const
SkIRect
&
unclippedDevShapeBounds
const
SkIRect
&
devClipBounds
)
{
*
boundsForClip
=
devClipBounds
;
#
ifndef
SK_DISABLE_MASKFILTERED_MASK_CACHING
bool
useCache
=
!
inverseFilled
&
&
viewMatrix
.
preservesAxisAlignment
(
)
&
&
shape
.
hasUnstyledKey
(
)
&
&
as_MFB
(
maskFilter
)
-
>
asABlur
(
nullptr
)
;
if
(
useCache
)
{
SkIRect
clippedMaskRect
unClippedMaskRect
;
maskFilter
-
>
canFilterMaskGPU
(
shape
unclippedDevShapeBounds
devClipBounds
viewMatrix
&
clippedMaskRect
)
;
maskFilter
-
>
canFilterMaskGPU
(
shape
unclippedDevShapeBounds
unclippedDevShapeBounds
viewMatrix
&
unClippedMaskRect
)
;
if
(
clippedMaskRect
.
isEmpty
(
)
)
{
return
false
;
}
int
unclippedWidth
=
unClippedMaskRect
.
width
(
)
;
int
unclippedHeight
=
unClippedMaskRect
.
height
(
)
;
int64_t
unclippedArea
=
sk_64_mul
(
unclippedWidth
unclippedHeight
)
;
int64_t
clippedArea
=
sk_64_mul
(
clippedMaskRect
.
width
(
)
clippedMaskRect
.
height
(
)
)
;
int
maxTextureSize
=
caps
-
>
maxTextureSize
(
)
;
if
(
unclippedArea
>
2
*
clippedArea
|
|
unclippedWidth
>
maxTextureSize
|
|
unclippedHeight
>
maxTextureSize
)
{
useCache
=
false
;
}
else
{
*
boundsForClip
=
unclippedDevShapeBounds
;
}
}
if
(
useCache
)
{
static
const
skgpu
:
:
UniqueKey
:
:
Domain
kDomain
=
skgpu
:
:
UniqueKey
:
:
GenerateDomain
(
)
;
skgpu
:
:
UniqueKey
:
:
Builder
builder
(
maskKey
kDomain
5
+
2
+
shape
.
unstyledKeySize
(
)
"
Mask
Filtered
Masks
"
)
;
SkScalar
sx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMScaleX
)
;
SkScalar
sy
=
viewMatrix
.
get
(
SkMatrix
:
:
kMScaleY
)
;
SkScalar
kx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMSkewX
)
;
SkScalar
ky
=
viewMatrix
.
get
(
SkMatrix
:
:
kMSkewY
)
;
SkScalar
tx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMTransX
)
;
SkScalar
ty
=
viewMatrix
.
get
(
SkMatrix
:
:
kMTransY
)
;
SkFixed
fracX
=
SkScalarToFixed
(
SkScalarFraction
(
tx
)
)
&
0x0000FF00
;
SkFixed
fracY
=
SkScalarToFixed
(
SkScalarFraction
(
ty
)
)
&
0x0000FF00
;
builder
[
0
]
=
SkFloat2Bits
(
sx
)
;
builder
[
1
]
=
SkFloat2Bits
(
sy
)
;
builder
[
2
]
=
SkFloat2Bits
(
kx
)
;
builder
[
3
]
=
SkFloat2Bits
(
ky
)
;
uint32_t
styleBits
=
shape
.
style
(
)
.
isSimpleHairline
(
)
?
(
(
shape
.
style
(
)
.
strokeRec
(
)
.
getCap
(
)
<
<
1
)
|
1
)
:
0
;
builder
[
4
]
=
fracX
|
(
fracY
>
>
8
)
|
(
styleBits
<
<
16
)
;
SkMaskFilterBase
:
:
BlurRec
rec
;
SkAssertResult
(
as_MFB
(
maskFilter
)
-
>
asABlur
(
&
rec
)
)
;
builder
[
5
]
=
rec
.
fStyle
;
builder
[
6
]
=
SkFloat2Bits
(
rec
.
fSigma
)
;
shape
.
writeUnstyledKey
(
&
builder
[
7
]
)
;
}
#
endif
return
true
;
}
static
GrSurfaceProxyView
hw_create_filtered_mask
(
GrDirectContext
*
dContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
SkMatrix
&
viewMatrix
const
GrStyledShape
&
shape
const
SkMaskFilterBase
*
filter
const
SkIRect
&
unclippedDevShapeBounds
const
SkIRect
&
clipBounds
SkIRect
*
maskRect
skgpu
:
:
UniqueKey
*
key
)
{
if
(
!
filter
-
>
canFilterMaskGPU
(
shape
unclippedDevShapeBounds
clipBounds
viewMatrix
maskRect
)
)
{
return
{
}
;
}
if
(
clip_bounds_quick_reject
(
clipBounds
*
maskRect
)
)
{
return
{
}
;
}
auto
threadSafeCache
=
dContext
-
>
priv
(
)
.
threadSafeCache
(
)
;
GrSurfaceProxyView
lazyView
;
sk_sp
<
GrThreadSafeCache
:
:
Trampoline
>
trampoline
;
if
(
key
-
>
isValid
(
)
)
{
std
:
:
tie
(
lazyView
trampoline
)
=
GrThreadSafeCache
:
:
CreateLazyView
(
dContext
GrColorType
:
:
kAlpha_8
maskRect
-
>
size
(
)
kMaskOrigin
SkBackingFit
:
:
kApprox
)
;
if
(
!
lazyView
)
{
return
{
}
;
}
key
-
>
setCustomData
(
create_data
(
*
maskRect
unclippedDevShapeBounds
)
)
;
auto
[
cachedView
data
]
=
threadSafeCache
-
>
findOrAddWithData
(
*
key
lazyView
)
;
if
(
cachedView
!
=
lazyView
)
{
SkASSERT
(
data
)
;
SkASSERT
(
cachedView
.
asTextureProxy
(
)
)
;
SkASSERT
(
cachedView
.
origin
(
)
=
=
kMaskOrigin
)
;
*
maskRect
=
extract_draw_rect_from_data
(
data
.
get
(
)
unclippedDevShapeBounds
)
;
return
cachedView
;
}
}
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
>
maskSDC
(
create_mask_GPU
(
dContext
*
maskRect
viewMatrix
shape
sdc
-
>
numSamples
(
)
)
)
;
if
(
!
maskSDC
)
{
if
(
key
-
>
isValid
(
)
)
{
threadSafeCache
-
>
remove
(
*
key
)
;
}
return
{
}
;
}
auto
filteredMaskView
=
filter
-
>
filterMaskGPU
(
dContext
maskSDC
-
>
readSurfaceView
(
)
maskSDC
-
>
colorInfo
(
)
.
colorType
(
)
maskSDC
-
>
colorInfo
(
)
.
alphaType
(
)
viewMatrix
*
maskRect
)
;
if
(
!
filteredMaskView
)
{
if
(
key
-
>
isValid
(
)
)
{
threadSafeCache
-
>
remove
(
*
key
)
;
}
return
{
}
;
}
if
(
key
-
>
isValid
(
)
)
{
SkASSERT
(
filteredMaskView
.
dimensions
(
)
=
=
lazyView
.
dimensions
(
)
)
;
SkASSERT
(
filteredMaskView
.
swizzle
(
)
=
=
lazyView
.
swizzle
(
)
)
;
SkASSERT
(
filteredMaskView
.
origin
(
)
=
=
lazyView
.
origin
(
)
)
;
trampoline
-
>
fProxy
=
filteredMaskView
.
asTextureProxyRef
(
)
;
return
lazyView
;
}
return
filteredMaskView
;
}
static
void
draw_shape_with_mask_filter
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
SkMaskFilterBase
*
maskFilter
const
GrStyledShape
&
origShape
)
{
SkASSERT
(
maskFilter
)
;
const
GrStyledShape
*
shape
=
&
origShape
;
SkTLazy
<
GrStyledShape
>
tmpShape
;
if
(
origShape
.
style
(
)
.
applies
(
)
)
{
SkScalar
styleScale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
styleScale
=
=
0
)
{
return
;
}
tmpShape
.
init
(
origShape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
styleScale
)
)
;
if
(
tmpShape
-
>
isEmpty
(
)
)
{
return
;
}
shape
=
tmpShape
.
get
(
)
;
}
if
(
maskFilter
-
>
directFilterMaskGPU
(
rContext
sdc
std
:
:
move
(
paint
)
clip
viewMatrix
*
shape
)
)
{
return
;
}
assert_alive
(
paint
)
;
bool
inverseFilled
=
shape
-
>
inverseFilled
(
)
&
&
!
GrIsStrokeHairlineOrEquivalent
(
shape
-
>
style
(
)
viewMatrix
nullptr
)
;
SkIRect
unclippedDevShapeBounds
devClipBounds
;
if
(
!
get_shape_and_clip_bounds
(
sdc
clip
*
shape
viewMatrix
&
unclippedDevShapeBounds
&
devClipBounds
)
)
{
if
(
!
inverseFilled
)
{
return
;
}
}
skgpu
:
:
UniqueKey
maskKey
;
SkIRect
boundsForClip
;
if
(
!
compute_key_and_clip_bounds
(
&
maskKey
&
boundsForClip
sdc
-
>
caps
(
)
viewMatrix
inverseFilled
maskFilter
*
shape
unclippedDevShapeBounds
devClipBounds
)
)
{
return
;
}
GrSurfaceProxyView
filteredMaskView
;
SkIRect
maskRect
;
if
(
auto
dContext
=
rContext
-
>
asDirectContext
(
)
)
{
filteredMaskView
=
hw_create_filtered_mask
(
dContext
sdc
viewMatrix
*
shape
maskFilter
unclippedDevShapeBounds
boundsForClip
&
maskRect
&
maskKey
)
;
if
(
filteredMaskView
)
{
if
(
draw_mask
(
sdc
clip
viewMatrix
maskRect
std
:
:
move
(
paint
)
std
:
:
move
(
filteredMaskView
)
)
)
{
return
;
}
assert_alive
(
paint
)
;
}
}
filteredMaskView
=
sw_create_filtered_mask
(
rContext
viewMatrix
*
shape
maskFilter
unclippedDevShapeBounds
boundsForClip
&
maskRect
&
maskKey
)
;
if
(
filteredMaskView
)
{
if
(
draw_mask
(
sdc
clip
viewMatrix
maskRect
std
:
:
move
(
paint
)
std
:
:
move
(
filteredMaskView
)
)
)
{
return
;
}
assert_alive
(
paint
)
;
}
}
void
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
GrStyledShape
&
shape
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
SkMaskFilter
*
mf
)
{
draw_shape_with_mask_filter
(
rContext
sdc
clip
std
:
:
move
(
paint
)
viewMatrix
as_MFB
(
mf
)
shape
)
;
}
void
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
GrRecordingContext
*
rContext
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
GrClip
*
clip
const
SkPaint
&
paint
const
SkMatrixProvider
&
matrixProvider
const
GrStyledShape
&
shape
)
{
if
(
rContext
-
>
abandoned
(
)
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
rContext
sdc
-
>
colorInfo
(
)
paint
matrixProvider
.
localToDevice
(
)
sdc
-
>
surfaceProps
(
)
&
grPaint
)
)
{
return
;
}
const
SkMatrix
&
viewMatrix
(
matrixProvider
.
localToDevice
(
)
)
;
SkMaskFilterBase
*
mf
=
as_MFB
(
paint
.
getMaskFilter
(
)
)
;
if
(
mf
&
&
!
mf
-
>
hasFragmentProcessor
(
)
)
{
draw_shape_with_mask_filter
(
rContext
sdc
clip
std
:
:
move
(
grPaint
)
viewMatrix
mf
shape
)
;
}
else
{
sdc
-
>
drawShape
(
clip
std
:
:
move
(
grPaint
)
sdc
-
>
chooseAA
(
paint
)
viewMatrix
GrStyledShape
(
shape
)
)
;
}
}
