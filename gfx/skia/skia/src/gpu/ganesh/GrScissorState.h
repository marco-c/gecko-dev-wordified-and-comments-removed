#
ifndef
GrScissorState_DEFINED
#
define
GrScissorState_DEFINED
#
include
"
include
/
core
/
SkRect
.
h
"
class
GrScissorState
{
public
:
explicit
GrScissorState
(
const
SkISize
&
rtDims
)
:
fRTSize
(
rtDims
)
fRect
(
SkIRect
:
:
MakeSize
(
rtDims
)
)
{
}
void
setDisabled
(
)
{
fRect
=
SkIRect
:
:
MakeSize
(
fRTSize
)
;
}
bool
set
(
const
SkIRect
&
rect
)
{
this
-
>
setDisabled
(
)
;
return
this
-
>
intersect
(
rect
)
;
}
bool
SK_WARN_UNUSED_RESULT
intersect
(
const
SkIRect
&
rect
)
{
if
(
!
fRect
.
intersect
(
rect
)
)
{
fRect
.
setEmpty
(
)
;
return
false
;
}
else
{
return
true
;
}
}
bool
relaxTest
(
const
SkISize
&
logicalDimensions
)
{
SkASSERT
(
logicalDimensions
.
fWidth
<
=
fRTSize
.
fWidth
&
&
logicalDimensions
.
fHeight
<
=
fRTSize
.
fHeight
)
;
if
(
fRect
.
fLeft
=
=
0
&
&
fRect
.
fTop
=
=
0
&
&
fRect
.
fRight
>
=
logicalDimensions
.
fWidth
&
&
fRect
.
fBottom
>
=
logicalDimensions
.
fHeight
)
{
this
-
>
setDisabled
(
)
;
return
true
;
}
else
{
return
false
;
}
}
bool
operator
=
=
(
const
GrScissorState
&
other
)
const
{
return
fRTSize
=
=
other
.
fRTSize
&
&
fRect
=
=
other
.
fRect
;
}
bool
operator
!
=
(
const
GrScissorState
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
enabled
(
)
const
{
SkASSERT
(
fRect
.
isEmpty
(
)
|
|
SkIRect
:
:
MakeSize
(
fRTSize
)
.
contains
(
fRect
)
)
;
return
fRect
.
fLeft
>
0
|
|
fRect
.
fTop
>
0
|
|
fRect
.
fRight
<
fRTSize
.
fWidth
|
|
fRect
.
fBottom
<
fRTSize
.
fHeight
;
}
const
SkIRect
&
rect
(
)
const
{
SkASSERT
(
fRect
.
isEmpty
(
)
|
|
SkIRect
:
:
MakeSize
(
fRTSize
)
.
contains
(
fRect
)
)
;
return
fRect
;
}
private
:
SkISize
fRTSize
;
SkIRect
fRect
;
}
;
#
endif
