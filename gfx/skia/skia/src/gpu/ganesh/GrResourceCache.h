#
ifndef
GrResourceCache_DEFINED
#
define
GrResourceCache_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkTDPQueue
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourceCacheAccess
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourcePriv
.
h
"
class
GrCaps
;
class
GrProxyProvider
;
class
SkString
;
class
SkTraceMemoryDump
;
class
GrTexture
;
class
GrThreadSafeCache
;
namespace
skgpu
{
class
SingleOwner
;
}
class
GrResourceCache
{
public
:
GrResourceCache
(
skgpu
:
:
SingleOwner
*
owner
GrDirectContext
:
:
DirectContextID
owningContextID
uint32_t
familyID
)
;
~
GrResourceCache
(
)
;
template
<
typename
T
>
static
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
GrGpuResource
T
>
void
>
ReturnResourceFromThread
(
sk_sp
<
T
>
&
&
resource
GrDirectContext
:
:
DirectContextID
id
)
{
UnrefResourceMessage
msg
(
std
:
:
move
(
resource
)
id
)
;
UnrefResourceMessage
:
:
Bus
:
:
Post
(
std
:
:
move
(
msg
)
)
;
}
static
const
size_t
kDefaultMaxSize
=
256
*
(
1
<
<
20
)
;
class
ResourceAccess
;
ResourceAccess
resourceAccess
(
)
;
uint32_t
contextUniqueID
(
)
const
{
return
fContextUniqueID
;
}
void
setLimit
(
size_t
bytes
)
;
int
getResourceCount
(
)
const
{
return
fPurgeableQueue
.
count
(
)
+
fNonpurgeableResources
.
size
(
)
;
}
int
getBudgetedResourceCount
(
)
const
{
return
fBudgetedCount
;
}
size_t
getResourceBytes
(
)
const
{
return
fBytes
;
}
size_t
getPurgeableBytes
(
)
const
{
return
fPurgeableBytes
;
}
size_t
getBudgetedResourceBytes
(
)
const
{
return
fBudgetedBytes
;
}
size_t
getMaxResourceBytes
(
)
const
{
return
fMaxBytes
;
}
void
abandonAll
(
)
;
void
releaseAll
(
)
;
GrGpuResource
*
findAndRefScratchResource
(
const
skgpu
:
:
ScratchKey
&
scratchKey
)
;
#
ifdef
SK_DEBUG
int
countScratchEntriesForKey
(
const
skgpu
:
:
ScratchKey
&
scratchKey
)
const
{
return
fScratchMap
.
countForKey
(
scratchKey
)
;
}
#
endif
GrGpuResource
*
findAndRefUniqueResource
(
const
skgpu
:
:
UniqueKey
&
key
)
{
GrGpuResource
*
resource
=
fUniqueHash
.
find
(
key
)
;
if
(
resource
)
{
this
-
>
refAndMakeResourceMRU
(
resource
)
;
}
return
resource
;
}
bool
hasUniqueKey
(
const
skgpu
:
:
UniqueKey
&
key
)
const
{
return
SkToBool
(
fUniqueHash
.
find
(
key
)
)
;
}
void
purgeAsNeeded
(
)
;
void
purgeUnlockedResources
(
bool
scratchResourcesOnly
=
false
)
{
this
-
>
purgeUnlockedResources
(
nullptr
scratchResourcesOnly
)
;
}
void
purgeResourcesNotUsedSince
(
GrStdSteadyClock
:
:
time_point
purgeTime
bool
scratchResourcesOnly
=
false
)
{
this
-
>
purgeUnlockedResources
(
&
purgeTime
scratchResourcesOnly
)
;
}
bool
purgeToMakeHeadroom
(
size_t
desiredHeadroomBytes
)
;
bool
overBudget
(
)
const
{
return
fBudgetedBytes
>
fMaxBytes
;
}
void
purgeUnlockedResources
(
size_t
bytesToPurge
bool
preferScratchResources
)
;
bool
requestsFlush
(
)
const
;
#
if
GR_CACHE_STATS
struct
Stats
{
int
fTotal
;
int
fNumPurgeable
;
int
fNumNonPurgeable
;
int
fScratch
;
int
fWrapped
;
size_t
fUnbudgetedSize
;
Stats
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fTotal
=
0
;
fNumPurgeable
=
0
;
fNumNonPurgeable
=
0
;
fScratch
=
0
;
fWrapped
=
0
;
fUnbudgetedSize
=
0
;
}
void
update
(
GrGpuResource
*
resource
)
{
if
(
resource
-
>
cacheAccess
(
)
.
isScratch
(
)
)
{
+
+
fScratch
;
}
if
(
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
{
+
+
fWrapped
;
}
if
(
GrBudgetedType
:
:
kBudgeted
!
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
fUnbudgetedSize
+
=
resource
-
>
gpuMemorySize
(
)
;
}
}
}
;
void
getStats
(
Stats
*
)
const
;
#
if
GR_TEST_UTILS
void
dumpStats
(
SkString
*
)
const
;
void
dumpStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
value
)
const
;
#
endif
#
endif
#
if
GR_TEST_UTILS
int
countUniqueKeysWithTag
(
const
char
*
tag
)
const
;
void
changeTimestamp
(
uint32_t
newTimestamp
)
;
#
endif
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
void
setProxyProvider
(
GrProxyProvider
*
proxyProvider
)
{
fProxyProvider
=
proxyProvider
;
}
void
setThreadSafeCache
(
GrThreadSafeCache
*
threadSafeCache
)
{
fThreadSafeCache
=
threadSafeCache
;
}
class
UnrefResourceMessage
{
public
:
GrDirectContext
:
:
DirectContextID
recipient
(
)
const
{
return
fRecipient
;
}
UnrefResourceMessage
(
UnrefResourceMessage
&
&
)
=
default
;
UnrefResourceMessage
&
operator
=
(
UnrefResourceMessage
&
&
)
=
default
;
private
:
friend
class
GrResourceCache
;
using
Bus
=
SkMessageBus
<
UnrefResourceMessage
GrDirectContext
:
:
DirectContextID
false
>
;
UnrefResourceMessage
(
sk_sp
<
GrGpuResource
>
&
&
resource
GrDirectContext
:
:
DirectContextID
recipient
)
:
fResource
(
std
:
:
move
(
resource
)
)
fRecipient
(
recipient
)
{
}
UnrefResourceMessage
(
const
UnrefResourceMessage
&
)
=
delete
;
UnrefResourceMessage
&
operator
=
(
const
UnrefResourceMessage
&
)
=
delete
;
sk_sp
<
GrGpuResource
>
fResource
;
GrDirectContext
:
:
DirectContextID
fRecipient
;
}
;
private
:
void
insertResource
(
GrGpuResource
*
)
;
void
removeResource
(
GrGpuResource
*
)
;
void
notifyARefCntReachedZero
(
GrGpuResource
*
GrGpuResource
:
:
LastRemovedRef
)
;
void
changeUniqueKey
(
GrGpuResource
*
const
skgpu
:
:
UniqueKey
&
)
;
void
removeUniqueKey
(
GrGpuResource
*
)
;
void
willRemoveScratchKey
(
const
GrGpuResource
*
)
;
void
didChangeBudgetStatus
(
GrGpuResource
*
)
;
void
refResource
(
GrGpuResource
*
resource
)
;
void
refAndMakeResourceMRU
(
GrGpuResource
*
)
;
void
processFreedGpuResources
(
)
;
void
addToNonpurgeableArray
(
GrGpuResource
*
)
;
void
removeFromNonpurgeableArray
(
GrGpuResource
*
)
;
bool
wouldFit
(
size_t
bytes
)
const
{
return
fBudgetedBytes
+
bytes
<
=
fMaxBytes
;
}
uint32_t
getNextTimestamp
(
)
;
void
purgeUnlockedResources
(
const
GrStdSteadyClock
:
:
time_point
*
purgeTime
bool
scratchResourcesOnly
)
;
#
ifdef
SK_DEBUG
bool
isInCache
(
const
GrGpuResource
*
r
)
const
;
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
class
AutoValidate
;
struct
ScratchMapTraits
{
static
const
skgpu
:
:
ScratchKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
resourcePriv
(
)
.
getScratchKey
(
)
;
}
static
uint32_t
Hash
(
const
skgpu
:
:
ScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
static
void
OnFree
(
GrGpuResource
*
)
{
}
}
;
typedef
SkTMultiMap
<
GrGpuResource
skgpu
:
:
ScratchKey
ScratchMapTraits
>
ScratchMap
;
struct
UniqueHashTraits
{
static
const
skgpu
:
:
UniqueKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
skgpu
:
:
UniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrGpuResource
skgpu
:
:
UniqueKey
UniqueHashTraits
>
UniqueHash
;
static
bool
CompareTimestamp
(
GrGpuResource
*
const
&
a
GrGpuResource
*
const
&
b
)
{
return
a
-
>
cacheAccess
(
)
.
timestamp
(
)
<
b
-
>
cacheAccess
(
)
.
timestamp
(
)
;
}
static
int
*
AccessResourceIndex
(
GrGpuResource
*
const
&
res
)
{
return
res
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
;
}
typedef
SkMessageBus
<
skgpu
:
:
UniqueKeyInvalidatedMessage
uint32_t
>
:
:
Inbox
InvalidUniqueKeyInbox
;
typedef
SkTDPQueue
<
GrGpuResource
*
CompareTimestamp
AccessResourceIndex
>
PurgeableQueue
;
typedef
SkTDArray
<
GrGpuResource
*
>
ResourceArray
;
GrProxyProvider
*
fProxyProvider
=
nullptr
;
GrThreadSafeCache
*
fThreadSafeCache
=
nullptr
;
uint32_t
fTimestamp
=
0
;
PurgeableQueue
fPurgeableQueue
;
ResourceArray
fNonpurgeableResources
;
ScratchMap
fScratchMap
;
UniqueHash
fUniqueHash
;
size_t
fMaxBytes
=
kDefaultMaxSize
;
#
if
GR_CACHE_STATS
int
fHighWaterCount
=
0
;
size_t
fHighWaterBytes
=
0
;
int
fBudgetedHighWaterCount
=
0
;
size_t
fBudgetedHighWaterBytes
=
0
;
#
endif
SkDEBUGCODE
(
int
fCount
=
0
;
)
size_t
fBytes
=
0
;
int
fBudgetedCount
=
0
;
size_t
fBudgetedBytes
=
0
;
size_t
fPurgeableBytes
=
0
;
int
fNumBudgetedResourcesFlushWillMakePurgeable
=
0
;
InvalidUniqueKeyInbox
fInvalidUniqueKeyInbox
;
UnrefResourceMessage
:
:
Bus
:
:
Inbox
fUnrefResourceInbox
;
GrDirectContext
:
:
DirectContextID
fOwningContextID
;
uint32_t
fContextUniqueID
=
SK_InvalidUniqueID
;
skgpu
:
:
SingleOwner
*
fSingleOwner
=
nullptr
;
SkDEBUGCODE
(
GrGpuResource
*
fNewlyPurgeableResourceForValidation
=
nullptr
;
)
}
;
class
GrResourceCache
:
:
ResourceAccess
{
private
:
ResourceAccess
(
GrResourceCache
*
cache
)
:
fCache
(
cache
)
{
}
ResourceAccess
(
const
ResourceAccess
&
that
)
:
fCache
(
that
.
fCache
)
{
}
ResourceAccess
&
operator
=
(
const
ResourceAccess
&
)
=
delete
;
void
insertResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
insertResource
(
resource
)
;
}
void
removeResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeResource
(
resource
)
;
}
void
refResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
refResource
(
resource
)
;
}
enum
RefNotificationFlags
{
kAllCntsReachedZero_RefNotificationFlag
=
0x1
kRefCntReachedZero_RefNotificationFlag
=
0x2
}
;
void
notifyARefCntReachedZero
(
GrGpuResource
*
resource
GrGpuResource
:
:
LastRemovedRef
removedRef
)
{
fCache
-
>
notifyARefCntReachedZero
(
resource
removedRef
)
;
}
void
changeUniqueKey
(
GrGpuResource
*
resource
const
skgpu
:
:
UniqueKey
&
newKey
)
{
fCache
-
>
changeUniqueKey
(
resource
newKey
)
;
}
void
removeUniqueKey
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeUniqueKey
(
resource
)
;
}
void
willRemoveScratchKey
(
const
GrGpuResource
*
resource
)
{
fCache
-
>
willRemoveScratchKey
(
resource
)
;
}
void
didChangeBudgetStatus
(
GrGpuResource
*
resource
)
{
fCache
-
>
didChangeBudgetStatus
(
resource
)
;
}
const
ResourceAccess
*
operator
&
(
)
const
;
ResourceAccess
*
operator
&
(
)
;
GrResourceCache
*
fCache
;
friend
class
GrGpuResource
;
friend
class
GrResourceCache
;
}
;
static
inline
bool
SkShouldPostMessageToBus
(
const
GrResourceCache
:
:
UnrefResourceMessage
&
msg
GrDirectContext
:
:
DirectContextID
potentialRecipient
)
{
return
potentialRecipient
=
=
msg
.
recipient
(
)
;
}
inline
GrResourceCache
:
:
ResourceAccess
GrResourceCache
:
:
resourceAccess
(
)
{
return
ResourceAccess
(
this
)
;
}
#
endif
