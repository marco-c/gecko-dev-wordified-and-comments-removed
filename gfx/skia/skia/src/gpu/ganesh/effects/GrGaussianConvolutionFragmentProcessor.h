#
ifndef
GrGaussianConvolutionFragmentProcessor_DEFINED
#
define
GrGaussianConvolutionFragmentProcessor_DEFINED
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessorUnitTest
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
class
GrSurfaceProxyView
;
class
GrGaussianConvolutionFragmentProcessor
:
public
GrFragmentProcessor
{
public
:
enum
class
Direction
{
kX
kY
}
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
GrSurfaceProxyView
SkAlphaType
Direction
int
halfWidth
float
gaussianSigma
GrSamplerState
:
:
WrapMode
const
SkIRect
&
subset
const
SkIRect
*
pixelDomain
const
GrCaps
&
)
;
const
char
*
name
(
)
const
override
{
return
"
GaussianConvolution
"
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrGaussianConvolutionFragmentProcessor
(
*
this
)
)
;
}
inline
static
constexpr
int
kMaxKernelRadius
=
12
;
private
:
class
Impl
;
GrGaussianConvolutionFragmentProcessor
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Direction
int
halfWidth
float
gaussianSigma
)
;
explicit
GrGaussianConvolutionFragmentProcessor
(
const
GrGaussianConvolutionFragmentProcessor
&
)
;
#
if
GR_TEST_UTILS
SkString
onDumpInfo
(
)
const
override
{
return
SkStringPrintf
(
"
(
dir
=
%
s
radius
=
%
d
)
"
Direction
:
:
kX
=
=
fDirection
?
"
X
"
:
"
Y
"
fRadius
)
;
}
#
endif
std
:
:
unique_ptr
<
ProgramImpl
>
onMakeProgramImpl
(
)
const
override
;
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
inline
static
const
constexpr
int
kMaxKernelWidth
=
kMaxKernelRadius
+
1
;
SkV2
fOffsetsAndKernel
[
kMaxKernelWidth
]
;
int
fRadius
;
Direction
fDirection
;
using
INHERITED
=
GrFragmentProcessor
;
}
;
#
endif
