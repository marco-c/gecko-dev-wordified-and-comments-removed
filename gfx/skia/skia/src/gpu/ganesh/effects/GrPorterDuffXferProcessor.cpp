#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
gpu
/
Blend
.
h
"
#
include
"
src
/
gpu
/
KeyBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrPipeline
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessorAnalysis
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrXferProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLBlend
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
class
BlendFormula
{
public
:
enum
OutputType
{
kNone_OutputType
kCoverage_OutputType
kModulate_OutputType
kSAModulate_OutputType
kISAModulate_OutputType
kISCModulate_OutputType
kLast_OutputType
=
kISCModulate_OutputType
}
;
constexpr
BlendFormula
(
OutputType
primaryOut
OutputType
secondaryOut
skgpu
:
:
BlendEquation
equation
skgpu
:
:
BlendCoeff
srcCoeff
skgpu
:
:
BlendCoeff
dstCoeff
)
:
fPrimaryOutputType
(
primaryOut
)
fSecondaryOutputType
(
secondaryOut
)
fBlendEquation
(
SkTo
<
uint8_t
>
(
equation
)
)
fSrcCoeff
(
SkTo
<
uint8_t
>
(
srcCoeff
)
)
fDstCoeff
(
SkTo
<
uint8_t
>
(
dstCoeff
)
)
fProps
(
GetProperties
(
primaryOut
secondaryOut
equation
srcCoeff
dstCoeff
)
)
{
}
BlendFormula
(
const
BlendFormula
&
)
=
default
;
BlendFormula
&
operator
=
(
const
BlendFormula
&
)
=
default
;
bool
operator
=
=
(
const
BlendFormula
&
that
)
const
{
return
fPrimaryOutputType
=
=
that
.
fPrimaryOutputType
&
&
fSecondaryOutputType
=
=
that
.
fSecondaryOutputType
&
&
fBlendEquation
=
=
that
.
fBlendEquation
&
&
fSrcCoeff
=
=
that
.
fSrcCoeff
&
&
fDstCoeff
=
=
that
.
fDstCoeff
&
&
fProps
=
=
that
.
fProps
;
}
bool
hasSecondaryOutput
(
)
const
{
return
kNone_OutputType
!
=
fSecondaryOutputType
;
}
bool
modifiesDst
(
)
const
{
return
SkToBool
(
fProps
&
kModifiesDst_Property
)
;
}
bool
unaffectedByDst
(
)
const
{
return
SkToBool
(
fProps
&
kUnaffectedByDst_Property
)
;
}
bool
unaffectedByDstIfOpaque
(
)
const
{
return
SkToBool
(
fProps
&
kUnaffectedByDstIfOpaque_Property
)
;
}
bool
usesInputColor
(
)
const
{
return
SkToBool
(
fProps
&
kUsesInputColor_Property
)
;
}
bool
canTweakAlphaForCoverage
(
)
const
{
return
SkToBool
(
fProps
&
kCanTweakAlphaForCoverage_Property
)
;
}
skgpu
:
:
BlendEquation
equation
(
)
const
{
return
static_cast
<
skgpu
:
:
BlendEquation
>
(
fBlendEquation
)
;
}
skgpu
:
:
BlendCoeff
srcCoeff
(
)
const
{
return
static_cast
<
skgpu
:
:
BlendCoeff
>
(
fSrcCoeff
)
;
}
skgpu
:
:
BlendCoeff
dstCoeff
(
)
const
{
return
static_cast
<
skgpu
:
:
BlendCoeff
>
(
fDstCoeff
)
;
}
OutputType
primaryOutput
(
)
const
{
return
fPrimaryOutputType
;
}
OutputType
secondaryOutput
(
)
const
{
return
fSecondaryOutputType
;
}
private
:
enum
Properties
{
kModifiesDst_Property
=
1
<
<
0
kUnaffectedByDst_Property
=
1
<
<
1
kUnaffectedByDstIfOpaque_Property
=
1
<
<
2
kUsesInputColor_Property
=
1
<
<
3
kCanTweakAlphaForCoverage_Property
=
1
<
<
4
kLast_Property
=
kCanTweakAlphaForCoverage_Property
}
;
SK_DECL_BITFIELD_OPS_FRIENDS
(
Properties
)
static
constexpr
Properties
GetProperties
(
OutputType
PrimaryOut
OutputType
SecondaryOut
skgpu
:
:
BlendEquation
BlendEquation
skgpu
:
:
BlendCoeff
SrcCoeff
skgpu
:
:
BlendCoeff
DstCoeff
)
;
struct
{
OutputType
fPrimaryOutputType
:
4
;
OutputType
fSecondaryOutputType
:
4
;
uint32_t
fBlendEquation
:
6
;
uint32_t
fSrcCoeff
:
6
;
uint32_t
fDstCoeff
:
6
;
Properties
fProps
:
32
-
(
4
+
4
+
6
+
6
+
6
)
;
}
;
static_assert
(
kLast_OutputType
<
(
1
<
<
3
)
)
;
static_assert
(
static_cast
<
int
>
(
skgpu
:
:
BlendEquation
:
:
kLast
)
<
(
1
<
<
5
)
)
;
static_assert
(
static_cast
<
int
>
(
skgpu
:
:
BlendCoeff
:
:
kLast
)
<
(
1
<
<
5
)
)
;
static_assert
(
kLast_Property
<
(
1
<
<
6
)
)
;
}
;
static_assert
(
4
=
=
sizeof
(
BlendFormula
)
)
;
SK_MAKE_BITFIELD_OPS
(
BlendFormula
:
:
Properties
)
constexpr
BlendFormula
:
:
Properties
BlendFormula
:
:
GetProperties
(
OutputType
PrimaryOut
OutputType
SecondaryOut
skgpu
:
:
BlendEquation
BlendEquation
skgpu
:
:
BlendCoeff
SrcCoeff
skgpu
:
:
BlendCoeff
DstCoeff
)
{
return
SkASSERT
(
(
kNone_OutputType
=
=
PrimaryOut
)
=
=
!
skgpu
:
:
BlendCoeffsUseSrcColor
(
SrcCoeff
DstCoeff
)
)
SkASSERT
(
!
skgpu
:
:
BlendCoeffRefsSrc2
(
SrcCoeff
)
)
SkASSERT
(
(
kNone_OutputType
=
=
SecondaryOut
)
=
=
!
skgpu
:
:
BlendCoeffRefsSrc2
(
DstCoeff
)
)
SkASSERT
(
PrimaryOut
!
=
SecondaryOut
|
|
kNone_OutputType
=
=
PrimaryOut
)
SkASSERT
(
kNone_OutputType
!
=
PrimaryOut
|
|
kNone_OutputType
=
=
SecondaryOut
)
static_cast
<
Properties
>
(
(
skgpu
:
:
BlendModifiesDst
(
BlendEquation
SrcCoeff
DstCoeff
)
?
kModifiesDst_Property
:
0
)
|
(
!
skgpu
:
:
BlendCoeffsUseDstColor
(
SrcCoeff
DstCoeff
false
)
?
kUnaffectedByDst_Property
:
0
)
|
(
!
skgpu
:
:
BlendCoeffsUseDstColor
(
SrcCoeff
DstCoeff
true
)
?
kUnaffectedByDstIfOpaque_Property
:
0
)
|
(
(
PrimaryOut
>
=
kModulate_OutputType
&
&
skgpu
:
:
BlendCoeffsUseSrcColor
(
SrcCoeff
DstCoeff
)
)
|
|
(
SecondaryOut
>
=
kModulate_OutputType
&
&
skgpu
:
:
BlendCoeffRefsSrc2
(
DstCoeff
)
)
?
kUsesInputColor_Property
:
0
)
|
(
(
kModulate_OutputType
=
=
PrimaryOut
|
|
kNone_OutputType
=
=
PrimaryOut
)
&
&
kNone_OutputType
=
=
SecondaryOut
&
&
skgpu
:
:
BlendAllowsCoverageAsAlpha
(
BlendEquation
SrcCoeff
DstCoeff
)
?
kCanTweakAlphaForCoverage_Property
:
0
)
)
;
}
static
constexpr
BlendFormula
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
srcCoeff
skgpu
:
:
BlendCoeff
dstCoeff
)
{
return
(
skgpu
:
:
BlendCoeff
:
:
kZero
=
=
srcCoeff
&
&
(
skgpu
:
:
BlendCoeff
:
:
kZero
=
=
dstCoeff
|
|
skgpu
:
:
BlendCoeff
:
:
kOne
=
=
dstCoeff
)
)
?
BlendFormula
(
BlendFormula
:
:
kNone_OutputType
BlendFormula
:
:
kNone_OutputType
skgpu
:
:
BlendEquation
:
:
kAdd
skgpu
:
:
BlendCoeff
:
:
kZero
dstCoeff
)
:
BlendFormula
(
BlendFormula
:
:
kModulate_OutputType
BlendFormula
:
:
kNone_OutputType
skgpu
:
:
BlendEquation
:
:
kAdd
srcCoeff
dstCoeff
)
;
}
static
constexpr
BlendFormula
MakeSAModulateFormula
(
skgpu
:
:
BlendCoeff
srcCoeff
skgpu
:
:
BlendCoeff
dstCoeff
)
{
return
BlendFormula
(
BlendFormula
:
:
kSAModulate_OutputType
BlendFormula
:
:
kNone_OutputType
skgpu
:
:
BlendEquation
:
:
kAdd
srcCoeff
dstCoeff
)
;
}
static
constexpr
BlendFormula
MakeCoverageFormula
(
BlendFormula
:
:
OutputType
oneMinusDstCoeffModulateOutput
skgpu
:
:
BlendCoeff
srcCoeff
)
{
return
BlendFormula
(
BlendFormula
:
:
kModulate_OutputType
oneMinusDstCoeffModulateOutput
skgpu
:
:
BlendEquation
:
:
kAdd
srcCoeff
skgpu
:
:
BlendCoeff
:
:
kIS2C
)
;
}
static
constexpr
BlendFormula
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
OutputType
oneMinusDstCoeffModulateOutput
)
{
return
BlendFormula
(
oneMinusDstCoeffModulateOutput
BlendFormula
:
:
kNone_OutputType
skgpu
:
:
BlendEquation
:
:
kReverseSubtract
skgpu
:
:
BlendCoeff
:
:
kDC
skgpu
:
:
BlendCoeff
:
:
kOne
)
;
}
static
constexpr
BlendFormula
MakeCoverageDstCoeffZeroFormula
(
skgpu
:
:
BlendCoeff
srcCoeff
)
{
return
BlendFormula
(
BlendFormula
:
:
kModulate_OutputType
BlendFormula
:
:
kCoverage_OutputType
skgpu
:
:
BlendEquation
:
:
kAdd
srcCoeff
skgpu
:
:
BlendCoeff
:
:
kIS2A
)
;
}
static
constexpr
BlendFormula
gBlendTable
[
2
]
[
2
]
[
(
int
)
SkBlendMode
:
:
kLastCoeffMode
+
1
]
=
{
{
{
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kSA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kSA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kSC
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISC
)
}
{
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kCoverage_OutputType
)
MakeCoverageDstCoeffZeroFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageDstCoeffZeroFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kISAModulate_OutputType
)
MakeCoverageDstCoeffZeroFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoverageFormula
(
BlendFormula
:
:
kISAModulate_OutputType
skgpu
:
:
BlendCoeff
:
:
kIDA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kISCModulate_OutputType
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISC
)
}
}
{
{
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kZero
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kSC
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISC
)
}
{
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kCoverage_OutputType
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kCoverage_OutputType
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kISA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kISCModulate_OutputType
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISC
)
}
}
}
;
static
constexpr
BlendFormula
gLCDBlendTable
[
(
int
)
SkBlendMode
:
:
kLastCoeffMode
+
1
]
=
{
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kCoverage_OutputType
)
MakeCoverageFormula
(
BlendFormula
:
:
kCoverage_OutputType
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageFormula
(
BlendFormula
:
:
kSAModulate_OutputType
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kIDA
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageFormula
(
BlendFormula
:
:
kCoverage_OutputType
skgpu
:
:
BlendCoeff
:
:
kDA
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kISAModulate_OutputType
)
MakeCoverageFormula
(
BlendFormula
:
:
kCoverage_OutputType
skgpu
:
:
BlendCoeff
:
:
kIDA
)
MakeSAModulateFormula
(
skgpu
:
:
BlendCoeff
:
:
kZero
skgpu
:
:
BlendCoeff
:
:
kISC
)
MakeCoverageFormula
(
BlendFormula
:
:
kSAModulate_OutputType
skgpu
:
:
BlendCoeff
:
:
kDA
)
MakeCoverageFormula
(
BlendFormula
:
:
kISAModulate_OutputType
skgpu
:
:
BlendCoeff
:
:
kIDA
)
MakeCoverageFormula
(
BlendFormula
:
:
kSAModulate_OutputType
skgpu
:
:
BlendCoeff
:
:
kIDA
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kOne
)
MakeCoverageSrcCoeffZeroFormula
(
BlendFormula
:
:
kISCModulate_OutputType
)
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISC
)
}
;
static
BlendFormula
get_blend_formula
(
bool
isOpaque
bool
hasCoverage
SkBlendMode
xfermode
)
{
SkASSERT
(
(
unsigned
)
xfermode
<
=
(
unsigned
)
SkBlendMode
:
:
kLastCoeffMode
)
;
return
gBlendTable
[
isOpaque
]
[
hasCoverage
]
[
(
int
)
xfermode
]
;
}
static
BlendFormula
get_lcd_blend_formula
(
SkBlendMode
xfermode
)
{
SkASSERT
(
(
unsigned
)
xfermode
<
=
(
unsigned
)
SkBlendMode
:
:
kLastCoeffMode
)
;
return
gLCDBlendTable
[
(
int
)
xfermode
]
;
}
class
PorterDuffXferProcessor
:
public
GrXferProcessor
{
public
:
PorterDuffXferProcessor
(
BlendFormula
blendFormula
GrProcessorAnalysisCoverage
coverage
)
:
INHERITED
(
kPorterDuffXferProcessor_ClassID
false
coverage
)
fBlendFormula
(
blendFormula
)
{
}
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
"
;
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
)
const
override
;
BlendFormula
getBlendFormula
(
)
const
{
return
fBlendFormula
;
}
private
:
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
override
;
bool
onHasSecondaryOutput
(
)
const
override
{
return
fBlendFormula
.
hasSecondaryOutput
(
)
;
}
void
onGetBlendInfo
(
skgpu
:
:
BlendInfo
*
blendInfo
)
const
override
{
blendInfo
-
>
fEquation
=
fBlendFormula
.
equation
(
)
;
blendInfo
-
>
fSrcBlend
=
fBlendFormula
.
srcCoeff
(
)
;
blendInfo
-
>
fDstBlend
=
fBlendFormula
.
dstCoeff
(
)
;
blendInfo
-
>
fWritesColor
=
fBlendFormula
.
modifiesDst
(
)
;
}
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
PorterDuffXferProcessor
&
xp
=
xpBase
.
cast
<
PorterDuffXferProcessor
>
(
)
;
return
fBlendFormula
=
=
xp
.
fBlendFormula
;
}
const
BlendFormula
fBlendFormula
;
using
INHERITED
=
GrXferProcessor
;
}
;
static
void
append_color_output
(
const
PorterDuffXferProcessor
&
xp
GrGLSLXPFragmentBuilder
*
fragBuilder
BlendFormula
:
:
OutputType
outputType
const
char
*
output
const
char
*
inColor
const
char
*
inCoverage
)
{
SkASSERT
(
inCoverage
)
;
SkASSERT
(
inColor
)
;
switch
(
outputType
)
{
case
BlendFormula
:
:
kNone_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
half4
(
0
.
0
)
;
"
output
)
;
break
;
case
BlendFormula
:
:
kCoverage_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
output
inCoverage
)
;
break
;
case
BlendFormula
:
:
kModulate_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
;
"
output
inColor
inCoverage
)
;
break
;
case
BlendFormula
:
:
kSAModulate_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
.
a
*
%
s
;
"
output
inColor
inCoverage
)
;
break
;
case
BlendFormula
:
:
kISAModulate_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
(
1
.
0
-
%
s
.
a
)
*
%
s
;
"
output
inColor
inCoverage
)
;
break
;
case
BlendFormula
:
:
kISCModulate_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
(
half4
(
1
.
0
)
-
%
s
)
*
%
s
;
"
output
inColor
inCoverage
)
;
break
;
default
:
SK_ABORT
(
"
Unsupported
output
type
.
"
)
;
break
;
}
}
void
PorterDuffXferProcessor
:
:
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
b
)
const
{
b
-
>
add32
(
fBlendFormula
.
primaryOutput
(
)
|
(
fBlendFormula
.
secondaryOutput
(
)
<
<
3
)
)
;
static_assert
(
BlendFormula
:
:
kLast_OutputType
<
8
)
;
}
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
PorterDuffXferProcessor
:
:
makeProgramImpl
(
)
const
{
class
Impl
:
public
ProgramImpl
{
private
:
void
emitOutputsForBlendState
(
const
EmitArgs
&
args
)
override
{
const
PorterDuffXferProcessor
&
xp
=
args
.
fXP
.
cast
<
PorterDuffXferProcessor
>
(
)
;
GrGLSLXPFragmentBuilder
*
fragBuilder
=
args
.
fXPFragBuilder
;
const
BlendFormula
&
blendFormula
=
xp
.
fBlendFormula
;
if
(
blendFormula
.
hasSecondaryOutput
(
)
)
{
append_color_output
(
xp
fragBuilder
blendFormula
.
secondaryOutput
(
)
args
.
fOutputSecondary
args
.
fInputColor
args
.
fInputCoverage
)
;
}
append_color_output
(
xp
fragBuilder
blendFormula
.
primaryOutput
(
)
args
.
fOutputPrimary
args
.
fInputColor
args
.
fInputCoverage
)
;
}
}
;
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
class
ShaderPDXferProcessor
:
public
GrXferProcessor
{
public
:
ShaderPDXferProcessor
(
SkBlendMode
xfermode
GrProcessorAnalysisCoverage
coverage
)
:
INHERITED
(
kShaderPDXferProcessor_ClassID
true
coverage
)
fXfermode
(
xfermode
)
{
}
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
Shader
"
;
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
)
const
override
;
private
:
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
ShaderPDXferProcessor
&
xp
=
xpBase
.
cast
<
ShaderPDXferProcessor
>
(
)
;
return
fXfermode
=
=
xp
.
fXfermode
;
}
const
SkBlendMode
fXfermode
;
using
INHERITED
=
GrXferProcessor
;
}
;
void
ShaderPDXferProcessor
:
:
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
b
)
const
{
b
-
>
add32
(
GrGLSLBlend
:
:
BlendKey
(
fXfermode
)
)
;
}
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
ShaderPDXferProcessor
:
:
makeProgramImpl
(
)
const
{
class
Impl
:
public
ProgramImpl
{
private
:
void
emitBlendCodeForDstRead
(
GrGLSLXPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
char
*
srcColor
const
char
*
srcCoverage
const
char
*
dstColor
const
char
*
outColor
const
char
*
outColorSecondary
const
GrXferProcessor
&
proc
)
override
{
const
ShaderPDXferProcessor
&
xp
=
proc
.
cast
<
ShaderPDXferProcessor
>
(
)
;
std
:
:
string
blendExpr
=
GrGLSLBlend
:
:
BlendExpression
(
&
xp
uniformHandler
&
fBlendUniform
srcColor
dstColor
xp
.
fXfermode
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outColor
blendExpr
.
c_str
(
)
)
;
DefaultCoverageModulation
(
fragBuilder
srcCoverage
dstColor
outColor
outColorSecondary
xp
)
;
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrXferProcessor
&
proc
)
override
{
if
(
fBlendUniform
.
isValid
(
)
)
{
const
ShaderPDXferProcessor
&
xp
=
proc
.
cast
<
ShaderPDXferProcessor
>
(
)
;
GrGLSLBlend
:
:
SetBlendModeUniformData
(
pdman
fBlendUniform
xp
.
fXfermode
)
;
}
}
GrGLSLUniformHandler
:
:
UniformHandle
fBlendUniform
;
}
;
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
class
PDLCDXferProcessor
:
public
GrXferProcessor
{
public
:
static
sk_sp
<
const
GrXferProcessor
>
Make
(
SkBlendMode
mode
const
GrProcessorAnalysisColor
&
inputColor
)
;
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
LCD
"
;
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
)
const
override
;
private
:
PDLCDXferProcessor
(
const
SkPMColor4f
&
blendConstant
float
alpha
)
;
void
onAddToKey
(
const
GrShaderCaps
&
skgpu
:
:
KeyBuilder
*
)
const
override
{
}
void
onGetBlendInfo
(
skgpu
:
:
BlendInfo
*
blendInfo
)
const
override
{
blendInfo
-
>
fSrcBlend
=
skgpu
:
:
BlendCoeff
:
:
kConstC
;
blendInfo
-
>
fDstBlend
=
skgpu
:
:
BlendCoeff
:
:
kISC
;
blendInfo
-
>
fBlendConstant
=
fBlendConstant
;
}
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
PDLCDXferProcessor
&
xp
=
xpBase
.
cast
<
PDLCDXferProcessor
>
(
)
;
if
(
fBlendConstant
!
=
xp
.
fBlendConstant
|
|
fAlpha
!
=
xp
.
fAlpha
)
{
return
false
;
}
return
true
;
}
SkPMColor4f
fBlendConstant
;
float
fAlpha
;
using
INHERITED
=
GrXferProcessor
;
}
;
PDLCDXferProcessor
:
:
PDLCDXferProcessor
(
const
SkPMColor4f
&
blendConstant
float
alpha
)
:
INHERITED
(
kPDLCDXferProcessor_ClassID
false
GrProcessorAnalysisCoverage
:
:
kLCD
)
fBlendConstant
(
blendConstant
)
fAlpha
(
alpha
)
{
}
sk_sp
<
const
GrXferProcessor
>
PDLCDXferProcessor
:
:
Make
(
SkBlendMode
mode
const
GrProcessorAnalysisColor
&
color
)
{
if
(
SkBlendMode
:
:
kSrcOver
!
=
mode
)
{
return
nullptr
;
}
SkPMColor4f
blendConstantPM
;
if
(
!
color
.
isConstant
(
&
blendConstantPM
)
)
{
return
nullptr
;
}
SkColor4f
blendConstantUPM
=
blendConstantPM
.
unpremul
(
)
;
float
alpha
=
blendConstantUPM
.
fA
;
blendConstantPM
=
{
blendConstantUPM
.
fR
blendConstantUPM
.
fG
blendConstantUPM
.
fB
1
}
;
return
sk_sp
<
GrXferProcessor
>
(
new
PDLCDXferProcessor
(
blendConstantPM
alpha
)
)
;
}
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
PDLCDXferProcessor
:
:
makeProgramImpl
(
)
const
{
class
Impl
:
public
ProgramImpl
{
private
:
void
emitOutputsForBlendState
(
const
EmitArgs
&
args
)
override
{
const
char
*
alpha
;
fAlphaUniform
=
args
.
fUniformHandler
-
>
addUniform
(
nullptr
kFragment_GrShaderFlag
SkSLType
:
:
kHalf
"
alpha
"
&
alpha
)
;
GrGLSLXPFragmentBuilder
*
fragBuilder
=
args
.
fXPFragBuilder
;
SkASSERT
(
args
.
fInputCoverage
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
;
"
args
.
fOutputPrimary
alpha
args
.
fInputCoverage
)
;
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
pdm
const
GrXferProcessor
&
xp
)
override
{
float
alpha
=
xp
.
cast
<
PDLCDXferProcessor
>
(
)
.
fAlpha
;
if
(
fLastAlpha
!
=
alpha
)
{
pdm
.
set1f
(
fAlphaUniform
alpha
)
;
fLastAlpha
=
alpha
;
}
}
GrGLSLUniformHandler
:
:
UniformHandle
fAlphaUniform
;
float
fLastAlpha
=
SK_FloatNaN
;
}
;
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
constexpr
GrPorterDuffXPFactory
:
:
GrPorterDuffXPFactory
(
SkBlendMode
xfermode
)
:
fBlendMode
(
xfermode
)
{
}
const
GrXPFactory
*
GrPorterDuffXPFactory
:
:
Get
(
SkBlendMode
blendMode
)
{
SkASSERT
(
(
unsigned
)
blendMode
<
=
(
unsigned
)
SkBlendMode
:
:
kLastCoeffMode
)
;
static
constexpr
const
GrPorterDuffXPFactory
gClearPDXPF
(
SkBlendMode
:
:
kClear
)
;
static
constexpr
const
GrPorterDuffXPFactory
gSrcPDXPF
(
SkBlendMode
:
:
kSrc
)
;
static
constexpr
const
GrPorterDuffXPFactory
gDstPDXPF
(
SkBlendMode
:
:
kDst
)
;
static
constexpr
const
GrPorterDuffXPFactory
gSrcOverPDXPF
(
SkBlendMode
:
:
kSrcOver
)
;
static
constexpr
const
GrPorterDuffXPFactory
gDstOverPDXPF
(
SkBlendMode
:
:
kDstOver
)
;
static
constexpr
const
GrPorterDuffXPFactory
gSrcInPDXPF
(
SkBlendMode
:
:
kSrcIn
)
;
static
constexpr
const
GrPorterDuffXPFactory
gDstInPDXPF
(
SkBlendMode
:
:
kDstIn
)
;
static
constexpr
const
GrPorterDuffXPFactory
gSrcOutPDXPF
(
SkBlendMode
:
:
kSrcOut
)
;
static
constexpr
const
GrPorterDuffXPFactory
gDstOutPDXPF
(
SkBlendMode
:
:
kDstOut
)
;
static
constexpr
const
GrPorterDuffXPFactory
gSrcATopPDXPF
(
SkBlendMode
:
:
kSrcATop
)
;
static
constexpr
const
GrPorterDuffXPFactory
gDstATopPDXPF
(
SkBlendMode
:
:
kDstATop
)
;
static
constexpr
const
GrPorterDuffXPFactory
gXorPDXPF
(
SkBlendMode
:
:
kXor
)
;
static
constexpr
const
GrPorterDuffXPFactory
gPlusPDXPF
(
SkBlendMode
:
:
kPlus
)
;
static
constexpr
const
GrPorterDuffXPFactory
gModulatePDXPF
(
SkBlendMode
:
:
kModulate
)
;
static
constexpr
const
GrPorterDuffXPFactory
gScreenPDXPF
(
SkBlendMode
:
:
kScreen
)
;
switch
(
blendMode
)
{
case
SkBlendMode
:
:
kClear
:
return
&
gClearPDXPF
;
case
SkBlendMode
:
:
kSrc
:
return
&
gSrcPDXPF
;
case
SkBlendMode
:
:
kDst
:
return
&
gDstPDXPF
;
case
SkBlendMode
:
:
kSrcOver
:
return
&
gSrcOverPDXPF
;
case
SkBlendMode
:
:
kDstOver
:
return
&
gDstOverPDXPF
;
case
SkBlendMode
:
:
kSrcIn
:
return
&
gSrcInPDXPF
;
case
SkBlendMode
:
:
kDstIn
:
return
&
gDstInPDXPF
;
case
SkBlendMode
:
:
kSrcOut
:
return
&
gSrcOutPDXPF
;
case
SkBlendMode
:
:
kDstOut
:
return
&
gDstOutPDXPF
;
case
SkBlendMode
:
:
kSrcATop
:
return
&
gSrcATopPDXPF
;
case
SkBlendMode
:
:
kDstATop
:
return
&
gDstATopPDXPF
;
case
SkBlendMode
:
:
kXor
:
return
&
gXorPDXPF
;
case
SkBlendMode
:
:
kPlus
:
return
&
gPlusPDXPF
;
case
SkBlendMode
:
:
kModulate
:
return
&
gModulatePDXPF
;
case
SkBlendMode
:
:
kScreen
:
return
&
gScreenPDXPF
;
default
:
SK_ABORT
(
"
Unexpected
blend
mode
.
"
)
;
}
}
sk_sp
<
const
GrXferProcessor
>
GrPorterDuffXPFactory
:
:
makeXferProcessor
(
const
GrProcessorAnalysisColor
&
color
GrProcessorAnalysisCoverage
coverage
const
GrCaps
&
caps
GrClampType
clampType
)
const
{
bool
isLCD
=
coverage
=
=
GrProcessorAnalysisCoverage
:
:
kLCD
;
if
(
isLCD
&
&
SkBlendMode
:
:
kSrcOver
=
=
fBlendMode
&
&
color
.
isConstant
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
&
&
!
caps
.
shaderCaps
(
)
-
>
fDstReadInShaderSupport
)
{
return
PDLCDXferProcessor
:
:
Make
(
fBlendMode
color
)
;
}
BlendFormula
blendFormula
=
[
&
]
(
)
{
if
(
isLCD
)
{
return
get_lcd_blend_formula
(
fBlendMode
)
;
}
if
(
fBlendMode
=
=
SkBlendMode
:
:
kSrcOver
&
&
color
.
isOpaque
(
)
&
&
coverage
=
=
GrProcessorAnalysisCoverage
:
:
kNone
&
&
caps
.
shouldCollapseSrcOverToSrcWhenAble
(
)
)
{
return
get_blend_formula
(
true
false
SkBlendMode
:
:
kSrc
)
;
}
return
get_blend_formula
(
color
.
isOpaque
(
)
GrProcessorAnalysisCoverage
:
:
kNone
!
=
coverage
fBlendMode
)
;
}
(
)
;
if
(
(
blendFormula
.
hasSecondaryOutput
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
)
|
|
(
isLCD
&
&
(
SkBlendMode
:
:
kSrcOver
!
=
fBlendMode
)
)
|
|
(
GrClampType
:
:
kAuto
!
=
clampType
&
&
SkBlendMode
:
:
kPlus
=
=
fBlendMode
)
)
{
return
sk_sp
<
const
GrXferProcessor
>
(
new
ShaderPDXferProcessor
(
fBlendMode
coverage
)
)
;
}
return
sk_sp
<
const
GrXferProcessor
>
(
new
PorterDuffXferProcessor
(
blendFormula
coverage
)
)
;
}
static
inline
GrXPFactory
:
:
AnalysisProperties
analysis_properties
(
const
GrProcessorAnalysisColor
&
color
const
GrProcessorAnalysisCoverage
&
coverage
const
GrCaps
&
caps
GrClampType
clampType
SkBlendMode
mode
)
{
using
AnalysisProperties
=
GrXPFactory
:
:
AnalysisProperties
;
AnalysisProperties
props
=
AnalysisProperties
:
:
kNone
;
bool
hasCoverage
=
GrProcessorAnalysisCoverage
:
:
kNone
!
=
coverage
;
bool
isLCD
=
GrProcessorAnalysisCoverage
:
:
kLCD
=
=
coverage
;
BlendFormula
formula
=
[
&
]
(
)
{
if
(
isLCD
)
{
return
gLCDBlendTable
[
(
int
)
mode
]
;
}
return
get_blend_formula
(
color
.
isOpaque
(
)
hasCoverage
mode
)
;
}
(
)
;
if
(
formula
.
canTweakAlphaForCoverage
(
)
&
&
!
isLCD
)
{
props
|
=
AnalysisProperties
:
:
kCompatibleWithCoverageAsAlpha
;
}
if
(
isLCD
)
{
if
(
SkBlendMode
:
:
kSrcOver
=
=
mode
&
&
color
.
isConstant
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
&
&
!
caps
.
shaderCaps
(
)
-
>
fDstReadInShaderSupport
)
{
props
|
=
AnalysisProperties
:
:
kIgnoresInputColor
;
}
else
{
if
(
SkBlendMode
:
:
kSrcOver
!
=
mode
|
|
(
formula
.
hasSecondaryOutput
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
)
)
{
props
|
=
AnalysisProperties
:
:
kReadsDstInShader
;
}
}
}
else
{
if
(
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
)
{
if
(
formula
.
hasSecondaryOutput
(
)
)
{
props
|
=
AnalysisProperties
:
:
kReadsDstInShader
;
}
}
}
if
(
GrClampType
:
:
kAuto
!
=
clampType
&
&
SkBlendMode
:
:
kPlus
=
=
mode
)
{
props
|
=
AnalysisProperties
:
:
kReadsDstInShader
;
}
if
(
!
formula
.
modifiesDst
(
)
|
|
!
formula
.
usesInputColor
(
)
)
{
props
|
=
AnalysisProperties
:
:
kIgnoresInputColor
;
}
if
(
formula
.
unaffectedByDst
(
)
|
|
(
formula
.
unaffectedByDstIfOpaque
(
)
&
&
color
.
isOpaque
(
)
&
&
!
hasCoverage
)
)
{
props
|
=
AnalysisProperties
:
:
kUnaffectedByDstValue
;
}
return
props
;
}
GrXPFactory
:
:
AnalysisProperties
GrPorterDuffXPFactory
:
:
analysisProperties
(
const
GrProcessorAnalysisColor
&
color
const
GrProcessorAnalysisCoverage
&
coverage
const
GrCaps
&
caps
GrClampType
clampType
)
const
{
return
analysis_properties
(
color
coverage
caps
clampType
fBlendMode
)
;
}
GR_DEFINE_XP_FACTORY_TEST
(
GrPorterDuffXPFactory
)
#
if
GR_TEST_UTILS
const
GrXPFactory
*
GrPorterDuffXPFactory
:
:
TestGet
(
GrProcessorTestData
*
d
)
{
SkBlendMode
mode
=
SkBlendMode
(
d
-
>
fRandom
-
>
nextULessThan
(
(
int
)
SkBlendMode
:
:
kLastCoeffMode
)
)
;
return
GrPorterDuffXPFactory
:
:
Get
(
mode
)
;
}
#
endif
void
GrPorterDuffXPFactory
:
:
TestGetXPOutputTypes
(
const
GrXferProcessor
*
xp
int
*
outPrimary
int
*
outSecondary
)
{
if
(
!
!
strcmp
(
xp
-
>
name
(
)
"
Porter
Duff
"
)
)
{
*
outPrimary
=
*
outSecondary
=
-
1
;
return
;
}
BlendFormula
blendFormula
=
static_cast
<
const
PorterDuffXferProcessor
*
>
(
xp
)
-
>
getBlendFormula
(
)
;
*
outPrimary
=
blendFormula
.
primaryOutput
(
)
;
*
outSecondary
=
blendFormula
.
secondaryOutput
(
)
;
}
const
GrXferProcessor
&
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
{
static
BlendFormula
gSrcOverBlendFormula
=
MakeCoeffFormula
(
skgpu
:
:
BlendCoeff
:
:
kOne
skgpu
:
:
BlendCoeff
:
:
kISA
)
;
static
PorterDuffXferProcessor
gSrcOverXP
(
gSrcOverBlendFormula
GrProcessorAnalysisCoverage
:
:
kSingleChannel
)
;
return
gSrcOverXP
;
}
sk_sp
<
const
GrXferProcessor
>
GrPorterDuffXPFactory
:
:
MakeSrcOverXferProcessor
(
const
GrProcessorAnalysisColor
&
color
GrProcessorAnalysisCoverage
coverage
const
GrCaps
&
caps
)
{
if
(
coverage
!
=
GrProcessorAnalysisCoverage
:
:
kLCD
)
{
if
(
color
.
isOpaque
(
)
&
&
coverage
=
=
GrProcessorAnalysisCoverage
:
:
kNone
&
&
caps
.
shouldCollapseSrcOverToSrcWhenAble
(
)
)
{
BlendFormula
blendFormula
=
get_blend_formula
(
true
false
SkBlendMode
:
:
kSrc
)
;
return
sk_sp
<
GrXferProcessor
>
(
new
PorterDuffXferProcessor
(
blendFormula
coverage
)
)
;
}
return
nullptr
;
}
if
(
color
.
isConstant
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
&
&
!
caps
.
shaderCaps
(
)
-
>
fDstReadInShaderSupport
)
{
return
PDLCDXferProcessor
:
:
Make
(
SkBlendMode
:
:
kSrcOver
color
)
;
}
BlendFormula
blendFormula
=
get_lcd_blend_formula
(
SkBlendMode
:
:
kSrcOver
)
;
if
(
(
blendFormula
.
hasSecondaryOutput
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
fDualSourceBlendingSupport
)
)
{
return
sk_sp
<
GrXferProcessor
>
(
new
ShaderPDXferProcessor
(
SkBlendMode
:
:
kSrcOver
coverage
)
)
;
}
return
sk_sp
<
GrXferProcessor
>
(
new
PorterDuffXferProcessor
(
blendFormula
coverage
)
)
;
}
sk_sp
<
const
GrXferProcessor
>
GrPorterDuffXPFactory
:
:
MakeNoCoverageXP
(
SkBlendMode
blendmode
)
{
BlendFormula
formula
=
get_blend_formula
(
false
false
blendmode
)
;
return
sk_make_sp
<
PorterDuffXferProcessor
>
(
formula
GrProcessorAnalysisCoverage
:
:
kNone
)
;
}
GrXPFactory
:
:
AnalysisProperties
GrPorterDuffXPFactory
:
:
SrcOverAnalysisProperties
(
const
GrProcessorAnalysisColor
&
color
const
GrProcessorAnalysisCoverage
&
coverage
const
GrCaps
&
caps
GrClampType
clampType
)
{
return
analysis_properties
(
color
coverage
caps
clampType
SkBlendMode
:
:
kSrcOver
)
;
}
