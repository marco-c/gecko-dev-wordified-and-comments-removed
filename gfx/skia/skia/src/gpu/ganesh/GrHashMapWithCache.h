#
ifndef
GrHashMapWithCache_DEFINED
#
define
GrHashMapWithCache_DEFINED
#
include
"
include
/
private
/
SkChecksum
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
struct
GrCheapHash
{
uint32_t
operator
(
)
(
uint32_t
val
)
{
return
SkChecksum
:
:
CheapMix
(
val
)
;
}
}
;
template
<
typename
K
typename
V
typename
KeyTraits
typename
HashT
=
SkGoodHash
>
class
GrHashMapWithCache
:
public
SkNoncopyable
{
public
:
int
count
(
)
const
{
return
fMap
.
count
(
)
;
}
size_t
approxBytesUsed
(
)
const
{
return
fMap
.
approxBytesUsed
(
)
;
}
const
V
*
find
(
const
K
&
key
)
const
{
if
(
key
!
=
fLastKey
)
{
fLastKey
=
key
;
fLastValue
=
fMap
.
find
(
key
)
;
}
return
fLastValue
;
}
const
V
*
set
(
K
key
V
val
)
{
if
(
fLastValue
&
&
key
=
=
fLastKey
)
{
*
fLastValue
=
std
:
:
move
(
val
)
;
}
else
{
fLastKey
=
key
;
fLastValue
=
fMap
.
set
(
std
:
:
move
(
key
)
std
:
:
move
(
val
)
)
;
}
return
fLastValue
;
}
void
remove
(
K
key
)
{
SkASSERT
(
fMap
.
find
(
fLastKey
)
)
;
fLastKey
=
std
:
:
move
(
key
)
;
fLastValue
=
nullptr
;
fMap
.
remove
(
fLastKey
)
;
}
void
reset
(
)
{
fLastKey
=
KeyTraits
:
:
GetInvalidKey
(
)
;
fLastValue
=
nullptr
;
fMap
.
reset
(
)
;
}
private
:
SkTHashMap
<
K
V
HashT
>
fMap
;
mutable
K
fLastKey
=
KeyTraits
:
:
GetInvalidKey
(
)
;
mutable
V
*
fLastValue
=
nullptr
;
}
;
#
endif
