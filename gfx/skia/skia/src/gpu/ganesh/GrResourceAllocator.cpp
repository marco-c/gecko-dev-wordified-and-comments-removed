#
include
"
src
/
gpu
/
ganesh
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
ifdef
SK_DEBUG
#
include
<
atomic
>
uint32_t
GrResourceAllocator
:
:
Interval
:
:
CreateUniqueID
(
)
{
static
std
:
:
atomic
<
uint32_t
>
nextID
{
1
}
;
uint32_t
id
;
do
{
id
=
nextID
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
uint32_t
GrResourceAllocator
:
:
Register
:
:
CreateUniqueID
(
)
{
static
std
:
:
atomic
<
uint32_t
>
nextID
{
1
}
;
uint32_t
id
;
do
{
id
=
nextID
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
#
endif
GrResourceAllocator
:
:
~
GrResourceAllocator
(
)
{
SkASSERT
(
fFailedInstantiation
|
|
fIntvlList
.
empty
(
)
)
;
SkASSERT
(
fActiveIntvls
.
empty
(
)
)
;
SkASSERT
(
!
fIntvlHash
.
count
(
)
)
;
}
void
GrResourceAllocator
:
:
addInterval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
ActualUse
actualUse
SkDEBUGCODE
(
bool
isDirectDstRead
)
)
{
SkASSERT
(
start
<
=
end
)
;
SkASSERT
(
!
fAssigned
)
;
if
(
proxy
-
>
canSkipResourceAllocator
(
)
)
{
return
;
}
if
(
proxy
-
>
readOnly
(
)
)
{
auto
resourceProvider
=
fDContext
-
>
priv
(
)
.
resourceProvider
(
)
;
if
(
proxy
-
>
isLazy
(
)
&
&
!
proxy
-
>
priv
(
)
.
doLazyInstantiation
(
resourceProvider
)
)
{
fFailedInstantiation
=
true
;
}
else
{
SkASSERT
(
proxy
-
>
isInstantiated
(
)
)
;
}
return
;
}
uint32_t
proxyID
=
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
;
if
(
Interval
*
*
intvlPtr
=
fIntvlHash
.
find
(
proxyID
)
)
{
Interval
*
intvl
=
*
intvlPtr
;
#
ifdef
SK_DEBUG
if
(
0
=
=
start
&
&
0
=
=
end
)
{
SkASSERT
(
0
=
=
intvl
-
>
start
(
)
)
;
}
else
if
(
isDirectDstRead
)
{
SkASSERT
(
intvl
-
>
start
(
)
<
=
start
&
&
intvl
-
>
end
(
)
>
=
end
)
;
}
else
{
SkASSERT
(
intvl
-
>
end
(
)
<
=
start
&
&
intvl
-
>
end
(
)
<
=
end
)
;
}
#
endif
if
(
ActualUse
:
:
kYes
=
=
actualUse
)
{
intvl
-
>
addUse
(
)
;
}
intvl
-
>
extendEnd
(
end
)
;
return
;
}
Interval
*
newIntvl
=
fInternalAllocator
.
make
<
Interval
>
(
proxy
start
end
)
;
if
(
ActualUse
:
:
kYes
=
=
actualUse
)
{
newIntvl
-
>
addUse
(
)
;
}
fIntvlList
.
insertByIncreasingStart
(
newIntvl
)
;
fIntvlHash
.
set
(
proxyID
newIntvl
)
;
}
static
bool
can_proxy_use_scratch
(
const
GrCaps
&
caps
GrSurfaceProxy
*
proxy
)
{
return
caps
.
reuseScratchTextures
(
)
|
|
proxy
-
>
asRenderTargetProxy
(
)
;
}
GrResourceAllocator
:
:
Register
:
:
Register
(
GrSurfaceProxy
*
originatingProxy
skgpu
:
:
ScratchKey
scratchKey
GrResourceProvider
*
provider
)
:
fOriginatingProxy
(
originatingProxy
)
fScratchKey
(
std
:
:
move
(
scratchKey
)
)
{
SkASSERT
(
originatingProxy
)
;
SkASSERT
(
!
originatingProxy
-
>
isInstantiated
(
)
)
;
SkASSERT
(
!
originatingProxy
-
>
isLazy
(
)
)
;
SkDEBUGCODE
(
fUniqueID
=
CreateUniqueID
(
)
;
)
if
(
fScratchKey
.
isValid
(
)
)
{
if
(
can_proxy_use_scratch
(
*
provider
-
>
caps
(
)
originatingProxy
)
)
{
fExistingSurface
=
provider
-
>
findAndRefScratchTexture
(
fScratchKey
"
ResourceAllocatorRegister
"
)
;
}
}
else
{
SkASSERT
(
this
-
>
uniqueKey
(
)
.
isValid
(
)
)
;
fExistingSurface
=
provider
-
>
findByUniqueKey
<
GrSurface
>
(
this
-
>
uniqueKey
(
)
)
;
}
}
bool
GrResourceAllocator
:
:
Register
:
:
isRecyclable
(
const
GrCaps
&
caps
GrSurfaceProxy
*
proxy
int
knownUseCount
)
const
{
if
(
!
can_proxy_use_scratch
(
caps
proxy
)
)
{
return
false
;
}
if
(
!
this
-
>
scratchKey
(
)
.
isValid
(
)
)
{
return
false
;
}
if
(
this
-
>
uniqueKey
(
)
.
isValid
(
)
)
{
return
false
;
}
return
!
proxy
-
>
refCntGreaterThan
(
knownUseCount
)
;
}
bool
GrResourceAllocator
:
:
Register
:
:
instantiateSurface
(
GrSurfaceProxy
*
proxy
GrResourceProvider
*
resourceProvider
)
{
SkASSERT
(
!
proxy
-
>
peekSurface
(
)
)
;
sk_sp
<
GrSurface
>
newSurface
;
if
(
!
fExistingSurface
)
{
if
(
proxy
=
=
fOriginatingProxy
)
{
newSurface
=
proxy
-
>
priv
(
)
.
createSurface
(
resourceProvider
)
;
}
else
{
newSurface
=
sk_ref_sp
(
fOriginatingProxy
-
>
peekSurface
(
)
)
;
}
}
if
(
!
fExistingSurface
&
&
!
newSurface
)
{
return
false
;
}
GrSurface
*
surface
=
newSurface
?
newSurface
.
get
(
)
:
fExistingSurface
.
get
(
)
;
if
(
skgpu
:
:
Budgeted
:
:
kYes
=
=
proxy
-
>
isBudgeted
(
)
&
&
GrBudgetedType
:
:
kBudgeted
!
=
surface
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
surface
-
>
resourcePriv
(
)
.
makeBudgeted
(
)
;
}
if
(
const
auto
&
uniqueKey
=
proxy
-
>
getUniqueKey
(
)
;
uniqueKey
.
isValid
(
)
)
{
if
(
!
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
resourceProvider
-
>
assignUniqueKeyToResource
(
uniqueKey
surface
)
;
}
SkASSERT
(
surface
-
>
getUniqueKey
(
)
=
=
uniqueKey
)
;
}
proxy
-
>
priv
(
)
.
assign
(
fExistingSurface
?
fExistingSurface
:
std
:
:
move
(
newSurface
)
)
;
return
true
;
}
GrResourceAllocator
:
:
Interval
*
GrResourceAllocator
:
:
IntervalList
:
:
popHead
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
Interval
*
temp
=
fHead
;
if
(
temp
)
{
fHead
=
temp
-
>
next
(
)
;
if
(
!
fHead
)
{
fTail
=
nullptr
;
}
temp
-
>
setNext
(
nullptr
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
return
temp
;
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingStart
(
Interval
*
intvl
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
!
intvl
-
>
next
(
)
)
;
if
(
!
fHead
)
{
fHead
=
fTail
=
intvl
;
}
else
if
(
intvl
-
>
start
(
)
<
=
fHead
-
>
start
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
if
(
fTail
-
>
start
(
)
<
=
intvl
-
>
start
(
)
)
{
fTail
-
>
setNext
(
intvl
)
;
fTail
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
intvl
-
>
start
(
)
>
next
-
>
start
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
SkASSERT
(
next
)
;
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingEnd
(
Interval
*
intvl
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
!
intvl
-
>
next
(
)
)
;
if
(
!
fHead
)
{
fHead
=
fTail
=
intvl
;
}
else
if
(
intvl
-
>
end
(
)
<
=
fHead
-
>
end
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
if
(
fTail
-
>
end
(
)
<
=
intvl
-
>
end
(
)
)
{
fTail
-
>
setNext
(
intvl
)
;
fTail
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
intvl
-
>
end
(
)
>
next
-
>
end
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
SkASSERT
(
next
)
;
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
#
ifdef
SK_DEBUG
void
GrResourceAllocator
:
:
IntervalList
:
:
validate
(
)
const
{
SkASSERT
(
SkToBool
(
fHead
)
=
=
SkToBool
(
fTail
)
)
;
Interval
*
prev
=
nullptr
;
for
(
Interval
*
cur
=
fHead
;
cur
;
prev
=
cur
cur
=
cur
-
>
next
(
)
)
{
}
SkASSERT
(
fTail
=
=
prev
)
;
}
#
endif
GrResourceAllocator
:
:
Register
*
GrResourceAllocator
:
:
findOrCreateRegisterFor
(
GrSurfaceProxy
*
proxy
)
{
auto
resourceProvider
=
fDContext
-
>
priv
(
)
.
resourceProvider
(
)
;
if
(
const
auto
&
uniqueKey
=
proxy
-
>
getUniqueKey
(
)
;
uniqueKey
.
isValid
(
)
)
{
if
(
auto
p
=
fUniqueKeyRegisters
.
find
(
uniqueKey
)
)
{
return
*
p
;
}
Register
*
r
=
fInternalAllocator
.
make
<
Register
>
(
proxy
skgpu
:
:
ScratchKey
(
)
resourceProvider
)
;
fUniqueKeyRegisters
.
set
(
uniqueKey
r
)
;
return
r
;
}
skgpu
:
:
ScratchKey
scratchKey
;
proxy
-
>
priv
(
)
.
computeScratchKey
(
*
fDContext
-
>
priv
(
)
.
caps
(
)
&
scratchKey
)
;
auto
filter
=
[
]
(
const
Register
*
r
)
{
return
true
;
}
;
if
(
Register
*
r
=
fFreePool
.
findAndRemove
(
scratchKey
filter
)
)
{
return
r
;
}
return
fInternalAllocator
.
make
<
Register
>
(
proxy
std
:
:
move
(
scratchKey
)
resourceProvider
)
;
}
void
GrResourceAllocator
:
:
expire
(
unsigned
int
curIndex
)
{
while
(
!
fActiveIntvls
.
empty
(
)
&
&
fActiveIntvls
.
peekHead
(
)
-
>
end
(
)
<
curIndex
)
{
Interval
*
intvl
=
fActiveIntvls
.
popHead
(
)
;
SkASSERT
(
!
intvl
-
>
next
(
)
)
;
Register
*
r
=
intvl
-
>
getRegister
(
)
;
if
(
r
&
&
r
-
>
isRecyclable
(
*
fDContext
-
>
priv
(
)
.
caps
(
)
intvl
-
>
proxy
(
)
intvl
-
>
uses
(
)
)
)
{
#
if
GR_ALLOCATION_SPEW
SkDebugf
(
"
putting
register
%
d
back
into
pool
\
n
"
r
-
>
uniqueID
(
)
)
;
#
endif
fFreePool
.
insert
(
r
-
>
scratchKey
(
)
r
)
;
}
fFinishedIntvls
.
insertByIncreasingStart
(
intvl
)
;
}
}
bool
GrResourceAllocator
:
:
planAssignment
(
)
{
fIntvlHash
.
reset
(
)
;
SkASSERT
(
!
fPlanned
&
&
!
fAssigned
)
;
SkDEBUGCODE
(
fPlanned
=
true
;
)
#
if
GR_ALLOCATION_SPEW
SkDebugf
(
"
assigning
%
d
ops
\
n
"
fNumOps
)
;
this
-
>
dumpIntervals
(
)
;
#
endif
auto
resourceProvider
=
fDContext
-
>
priv
(
)
.
resourceProvider
(
)
;
while
(
Interval
*
cur
=
fIntvlList
.
popHead
(
)
)
{
this
-
>
expire
(
cur
-
>
start
(
)
)
;
fActiveIntvls
.
insertByIncreasingEnd
(
cur
)
;
if
(
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
)
{
continue
;
}
if
(
cur
-
>
proxy
(
)
-
>
isLazy
(
)
)
{
if
(
cur
-
>
proxy
(
)
-
>
isFullyLazy
(
)
)
{
fFailedInstantiation
=
!
cur
-
>
proxy
(
)
-
>
priv
(
)
.
doLazyInstantiation
(
resourceProvider
)
;
if
(
fFailedInstantiation
)
{
break
;
}
}
continue
;
}
Register
*
r
=
this
-
>
findOrCreateRegisterFor
(
cur
-
>
proxy
(
)
)
;
#
if
GR_ALLOCATION_SPEW
SkDebugf
(
"
Assigning
register
%
d
to
%
d
\
n
"
r
-
>
uniqueID
(
)
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
)
;
#
endif
SkASSERT
(
!
cur
-
>
proxy
(
)
-
>
peekSurface
(
)
)
;
cur
-
>
setRegister
(
r
)
;
}
this
-
>
expire
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
)
;
return
!
fFailedInstantiation
;
}
bool
GrResourceAllocator
:
:
makeBudgetHeadroom
(
)
{
SkASSERT
(
fPlanned
)
;
SkASSERT
(
!
fFailedInstantiation
)
;
size_t
additionalBytesNeeded
=
0
;
for
(
Interval
*
cur
=
fFinishedIntvls
.
peekHead
(
)
;
cur
;
cur
=
cur
-
>
next
(
)
)
{
GrSurfaceProxy
*
proxy
=
cur
-
>
proxy
(
)
;
if
(
skgpu
:
:
Budgeted
:
:
kNo
=
=
proxy
-
>
isBudgeted
(
)
|
|
proxy
-
>
isInstantiated
(
)
)
{
continue
;
}
if
(
proxy
-
>
isLazy
(
)
)
{
additionalBytesNeeded
+
=
proxy
-
>
gpuMemorySize
(
)
;
}
else
{
Register
*
r
=
cur
-
>
getRegister
(
)
;
SkASSERT
(
r
)
;
if
(
!
r
-
>
accountedForInBudget
(
)
&
&
!
r
-
>
existingSurface
(
)
)
{
additionalBytesNeeded
+
=
proxy
-
>
gpuMemorySize
(
)
;
}
r
-
>
setAccountedForInBudget
(
)
;
}
}
return
fDContext
-
>
priv
(
)
.
getResourceCache
(
)
-
>
purgeToMakeHeadroom
(
additionalBytesNeeded
)
;
}
void
GrResourceAllocator
:
:
reset
(
)
{
SkDEBUGCODE
(
fPlanned
=
false
;
)
SkDEBUGCODE
(
fAssigned
=
false
;
)
SkASSERT
(
fActiveIntvls
.
empty
(
)
)
;
fFinishedIntvls
=
IntervalList
(
)
;
fIntvlList
=
IntervalList
(
)
;
fIntvlHash
.
reset
(
)
;
fUniqueKeyRegisters
.
reset
(
)
;
fFreePool
.
reset
(
)
;
fInternalAllocator
.
reset
(
)
;
}
bool
GrResourceAllocator
:
:
assign
(
)
{
if
(
fFailedInstantiation
)
{
return
false
;
}
SkASSERT
(
fPlanned
&
&
!
fAssigned
)
;
SkDEBUGCODE
(
fAssigned
=
true
;
)
auto
resourceProvider
=
fDContext
-
>
priv
(
)
.
resourceProvider
(
)
;
while
(
Interval
*
cur
=
fFinishedIntvls
.
popHead
(
)
)
{
if
(
fFailedInstantiation
)
{
break
;
}
if
(
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
)
{
continue
;
}
if
(
cur
-
>
proxy
(
)
-
>
isLazy
(
)
)
{
fFailedInstantiation
=
!
cur
-
>
proxy
(
)
-
>
priv
(
)
.
doLazyInstantiation
(
resourceProvider
)
;
continue
;
}
Register
*
r
=
cur
-
>
getRegister
(
)
;
SkASSERT
(
r
)
;
fFailedInstantiation
=
!
r
-
>
instantiateSurface
(
cur
-
>
proxy
(
)
resourceProvider
)
;
}
return
!
fFailedInstantiation
;
}
#
if
GR_ALLOCATION_SPEW
void
GrResourceAllocator
:
:
dumpIntervals
(
)
{
SkDebugf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
unsigned
int
min
=
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
;
unsigned
int
max
=
0
;
for
(
const
Interval
*
cur
=
fIntvlList
.
peekHead
(
)
;
cur
;
cur
=
cur
-
>
next
(
)
)
{
SkDebugf
(
"
{
%
3d
%
3d
}
:
[
%
2d
%
2d
]
-
refProxys
:
%
d
surfaceRefs
:
%
d
\
n
"
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
?
cur
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
.
asUInt
(
)
:
-
1
cur
-
>
start
(
)
cur
-
>
end
(
)
cur
-
>
proxy
(
)
-
>
priv
(
)
.
getProxyRefCnt
(
)
cur
-
>
proxy
(
)
-
>
testingOnly_getBackingRefCnt
(
)
)
;
min
=
std
:
:
min
(
min
cur
-
>
start
(
)
)
;
max
=
std
:
:
max
(
max
cur
-
>
end
(
)
)
;
}
for
(
const
Interval
*
cur
=
fIntvlList
.
peekHead
(
)
;
cur
;
cur
=
cur
-
>
next
(
)
)
{
SkDebugf
(
"
{
%
3d
%
3d
}
:
"
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
?
cur
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
.
asUInt
(
)
:
-
1
)
;
for
(
unsigned
int
i
=
min
;
i
<
=
max
;
+
+
i
)
{
if
(
i
>
=
cur
-
>
start
(
)
&
&
i
<
=
cur
-
>
end
(
)
)
{
SkDebugf
(
"
x
"
)
;
}
else
{
SkDebugf
(
"
"
)
;
}
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
