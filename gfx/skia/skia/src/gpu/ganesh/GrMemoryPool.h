#
ifndef
GrMemoryPool_DEFINED
#
define
GrMemoryPool_DEFINED
#
include
"
src
/
base
/
SkBlockAllocator
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
type_traits
>
#
ifdef
SK_DEBUG
#
include
"
src
/
core
/
SkTHash
.
h
"
#
endif
class
GrMemoryPool
{
public
:
#
ifdef
SK_FORCE_8_BYTE_ALIGNMENT
inline
static
constexpr
size_t
kAlignment
=
8
;
#
else
inline
static
constexpr
size_t
kAlignment
=
alignof
(
std
:
:
max_align_t
)
;
#
endif
inline
static
constexpr
size_t
kMinAllocationSize
=
1
<
<
10
;
static
std
:
:
unique_ptr
<
GrMemoryPool
>
Make
(
size_t
preallocSize
size_t
minAllocSize
)
;
~
GrMemoryPool
(
)
;
void
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
void
*
allocate
(
size_t
size
)
;
void
release
(
void
*
p
)
;
bool
isEmpty
(
)
const
{
return
fAllocator
.
currentBlock
(
)
=
=
fAllocator
.
headBlock
(
)
&
&
fAllocator
.
currentBlock
(
)
-
>
metadata
(
)
=
=
0
;
}
void
reportLeaks
(
)
const
;
size_t
size
(
)
const
{
return
fAllocator
.
totalSize
(
)
-
fAllocator
.
preallocSize
(
)
;
}
size_t
preallocSize
(
)
const
{
static_assert
(
std
:
:
is_standard_layout
<
GrMemoryPool
>
:
:
value
"
"
)
;
return
offsetof
(
GrMemoryPool
fAllocator
)
+
fAllocator
.
preallocSize
(
)
;
}
void
resetScratchSpace
(
)
{
fAllocator
.
resetScratchSpace
(
)
;
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
#
endif
private
:
struct
Header
{
int
fStart
;
int
fEnd
;
#
if
defined
(
SK_DEBUG
)
int
fID
;
#
endif
#
if
defined
(
SK_DEBUG
)
|
|
defined
(
SK_SANITIZE_ADDRESS
)
uint32_t
fSentinel
;
#
endif
}
;
GrMemoryPool
(
size_t
preallocSize
size_t
minAllocSize
)
;
#
ifdef
SK_DEBUG
struct
Debug
{
SkTHashSet
<
int
>
fAllocatedIDs
;
int
fAllocationCount
;
}
;
Debug
*
fDebug
{
nullptr
}
;
#
endif
SkBlockAllocator
fAllocator
;
}
;
#
endif
