#
ifndef
GrThreadSafeCache_DEFINED
#
define
GrThreadSafeCache_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkSpinlock
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
base
/
SkTInternalLList
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
class
GrThreadSafeCache
{
public
:
GrThreadSafeCache
(
)
;
~
GrThreadSafeCache
(
)
;
#
if
GR_TEST_UTILS
int
numEntries
(
)
const
SK_EXCLUDES
(
fSpinLock
)
;
size_t
approxBytesUsedForHash
(
)
const
SK_EXCLUDES
(
fSpinLock
)
;
#
endif
void
dropAllRefs
(
)
SK_EXCLUDES
(
fSpinLock
)
;
void
dropUniqueRefs
(
GrResourceCache
*
resourceCache
)
SK_EXCLUDES
(
fSpinLock
)
;
void
dropUniqueRefsOlderThan
(
GrStdSteadyClock
:
:
time_point
purgeTime
)
SK_EXCLUDES
(
fSpinLock
)
;
SkDEBUGCODE
(
bool
has
(
const
skgpu
:
:
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
)
GrSurfaceProxyView
find
(
const
skgpu
:
:
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
SkData
>
>
findWithData
(
const
skgpu
:
:
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
GrSurfaceProxyView
add
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_EXCLUDES
(
fSpinLock
)
;
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
SkData
>
>
addWithData
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_EXCLUDES
(
fSpinLock
)
;
GrSurfaceProxyView
findOrAdd
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_EXCLUDES
(
fSpinLock
)
;
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
SkData
>
>
findOrAddWithData
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_EXCLUDES
(
fSpinLock
)
;
class
VertexData
:
public
SkNVRefCnt
<
VertexData
>
{
public
:
~
VertexData
(
)
;
const
void
*
vertices
(
)
const
{
return
fVertices
;
}
size_t
size
(
)
const
{
return
fNumVertices
*
fVertexSize
;
}
int
numVertices
(
)
const
{
return
fNumVertices
;
}
size_t
vertexSize
(
)
const
{
return
fVertexSize
;
}
GrGpuBuffer
*
gpuBuffer
(
)
{
return
fGpuBuffer
.
get
(
)
;
}
sk_sp
<
GrGpuBuffer
>
refGpuBuffer
(
)
{
return
fGpuBuffer
;
}
void
setGpuBuffer
(
sk_sp
<
GrGpuBuffer
>
gpuBuffer
)
{
SkASSERT
(
!
fGpuBuffer
)
;
fGpuBuffer
=
gpuBuffer
;
}
void
reset
(
)
{
sk_free
(
const_cast
<
void
*
>
(
fVertices
)
)
;
fVertices
=
nullptr
;
fNumVertices
=
0
;
fVertexSize
=
0
;
fGpuBuffer
.
reset
(
)
;
}
private
:
friend
class
GrThreadSafeCache
;
VertexData
(
const
void
*
vertices
int
numVertices
size_t
vertexSize
)
:
fVertices
(
vertices
)
fNumVertices
(
numVertices
)
fVertexSize
(
vertexSize
)
{
}
VertexData
(
sk_sp
<
GrGpuBuffer
>
gpuBuffer
int
numVertices
size_t
vertexSize
)
:
fVertices
(
nullptr
)
fNumVertices
(
numVertices
)
fVertexSize
(
vertexSize
)
fGpuBuffer
(
std
:
:
move
(
gpuBuffer
)
)
{
}
const
void
*
fVertices
;
int
fNumVertices
;
size_t
fVertexSize
;
sk_sp
<
GrGpuBuffer
>
fGpuBuffer
;
}
;
static
sk_sp
<
VertexData
>
MakeVertexData
(
const
void
*
vertices
int
vertexCount
size_t
vertexSize
)
;
static
sk_sp
<
VertexData
>
MakeVertexData
(
sk_sp
<
GrGpuBuffer
>
buffer
int
vertexCount
size_t
vertexSize
)
;
std
:
:
tuple
<
sk_sp
<
VertexData
>
sk_sp
<
SkData
>
>
findVertsWithData
(
const
skgpu
:
:
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
typedef
bool
(
*
IsNewerBetter
)
(
SkData
*
incumbent
SkData
*
challenger
)
;
std
:
:
tuple
<
sk_sp
<
VertexData
>
sk_sp
<
SkData
>
>
addVertsWithData
(
const
skgpu
:
:
UniqueKey
&
sk_sp
<
VertexData
>
IsNewerBetter
)
SK_EXCLUDES
(
fSpinLock
)
;
void
remove
(
const
skgpu
:
:
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
class
Trampoline
:
public
SkRefCnt
{
public
:
sk_sp
<
GrTextureProxy
>
fProxy
;
}
;
static
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
Trampoline
>
>
CreateLazyView
(
GrDirectContext
*
GrColorType
SkISize
dimensions
GrSurfaceOrigin
SkBackingFit
)
;
private
:
struct
Entry
{
Entry
(
const
skgpu
:
:
UniqueKey
&
key
const
GrSurfaceProxyView
&
view
)
:
fKey
(
key
)
fView
(
view
)
fTag
(
Entry
:
:
kView
)
{
}
Entry
(
const
skgpu
:
:
UniqueKey
&
key
sk_sp
<
VertexData
>
vertData
)
:
fKey
(
key
)
fVertData
(
std
:
:
move
(
vertData
)
)
fTag
(
Entry
:
:
kVertData
)
{
}
~
Entry
(
)
{
this
-
>
makeEmpty
(
)
;
}
bool
uniquelyHeld
(
)
const
{
SkASSERT
(
fTag
!
=
kEmpty
)
;
if
(
fTag
=
=
kView
&
&
fView
.
proxy
(
)
-
>
unique
(
)
)
{
return
true
;
}
else
if
(
fTag
=
=
kVertData
&
&
fVertData
-
>
unique
(
)
)
{
return
true
;
}
return
false
;
}
const
skgpu
:
:
UniqueKey
&
key
(
)
const
{
SkASSERT
(
fTag
!
=
kEmpty
)
;
return
fKey
;
}
SkData
*
getCustomData
(
)
const
{
SkASSERT
(
fTag
!
=
kEmpty
)
;
return
fKey
.
getCustomData
(
)
;
}
sk_sp
<
SkData
>
refCustomData
(
)
const
{
SkASSERT
(
fTag
!
=
kEmpty
)
;
return
fKey
.
refCustomData
(
)
;
}
GrSurfaceProxyView
view
(
)
{
SkASSERT
(
fTag
=
=
kView
)
;
return
fView
;
}
sk_sp
<
VertexData
>
vertexData
(
)
{
SkASSERT
(
fTag
=
=
kVertData
)
;
return
fVertData
;
}
void
set
(
const
skgpu
:
:
UniqueKey
&
key
const
GrSurfaceProxyView
&
view
)
{
SkASSERT
(
fTag
=
=
kEmpty
)
;
fKey
=
key
;
fView
=
view
;
fTag
=
kView
;
}
void
makeEmpty
(
)
{
fKey
.
reset
(
)
;
if
(
fTag
=
=
kView
)
{
fView
.
reset
(
)
;
}
else
if
(
fTag
=
=
kVertData
)
{
fVertData
.
reset
(
)
;
}
fTag
=
kEmpty
;
}
void
set
(
const
skgpu
:
:
UniqueKey
&
key
sk_sp
<
VertexData
>
vertData
)
{
SkASSERT
(
fTag
=
=
kEmpty
|
|
fTag
=
=
kVertData
)
;
fKey
=
key
;
fVertData
=
vertData
;
fTag
=
kVertData
;
}
GrStdSteadyClock
:
:
time_point
fLastAccess
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
Entry
)
;
static
const
skgpu
:
:
UniqueKey
&
GetKey
(
const
Entry
&
e
)
{
SkASSERT
(
e
.
fTag
!
=
kEmpty
)
;
return
e
.
fKey
;
}
static
uint32_t
Hash
(
const
skgpu
:
:
UniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
private
:
skgpu
:
:
UniqueKey
fKey
;
union
{
GrSurfaceProxyView
fView
;
sk_sp
<
VertexData
>
fVertData
;
}
;
enum
{
kEmpty
kView
kVertData
}
fTag
{
kEmpty
}
;
}
;
void
makeExistingEntryMRU
(
Entry
*
)
SK_REQUIRES
(
fSpinLock
)
;
Entry
*
makeNewEntryMRU
(
Entry
*
)
SK_REQUIRES
(
fSpinLock
)
;
Entry
*
getEntry
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_REQUIRES
(
fSpinLock
)
;
Entry
*
getEntry
(
const
skgpu
:
:
UniqueKey
&
sk_sp
<
VertexData
>
)
SK_REQUIRES
(
fSpinLock
)
;
void
recycleEntry
(
Entry
*
)
SK_REQUIRES
(
fSpinLock
)
;
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
SkData
>
>
internalFind
(
const
skgpu
:
:
UniqueKey
&
)
SK_REQUIRES
(
fSpinLock
)
;
std
:
:
tuple
<
GrSurfaceProxyView
sk_sp
<
SkData
>
>
internalAdd
(
const
skgpu
:
:
UniqueKey
&
const
GrSurfaceProxyView
&
)
SK_REQUIRES
(
fSpinLock
)
;
std
:
:
tuple
<
sk_sp
<
VertexData
>
sk_sp
<
SkData
>
>
internalFindVerts
(
const
skgpu
:
:
UniqueKey
&
)
SK_REQUIRES
(
fSpinLock
)
;
std
:
:
tuple
<
sk_sp
<
VertexData
>
sk_sp
<
SkData
>
>
internalAddVerts
(
const
skgpu
:
:
UniqueKey
&
sk_sp
<
VertexData
>
IsNewerBetter
)
SK_REQUIRES
(
fSpinLock
)
;
mutable
SkSpinlock
fSpinLock
;
SkTDynamicHash
<
Entry
skgpu
:
:
UniqueKey
>
fUniquelyKeyedEntryMap
SK_GUARDED_BY
(
fSpinLock
)
;
SkTInternalLList
<
Entry
>
fUniquelyKeyedEntryList
SK_GUARDED_BY
(
fSpinLock
)
;
static
const
int
kInitialArenaSize
=
64
*
sizeof
(
Entry
)
;
char
fStorage
[
kInitialArenaSize
]
;
SkArenaAlloc
fEntryAllocator
{
fStorage
kInitialArenaSize
kInitialArenaSize
}
;
Entry
*
fFreeEntryList
SK_GUARDED_BY
(
fSpinLock
)
;
}
;
#
endif
