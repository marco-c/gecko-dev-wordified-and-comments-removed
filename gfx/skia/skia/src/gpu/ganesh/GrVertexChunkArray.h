#
ifndef
GrVertexChunkArray_DEFINED
#
define
GrVertexChunkArray_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBuffer
.
h
"
class
GrMeshDrawTarget
;
struct
GrVertexChunk
{
sk_sp
<
const
GrBuffer
>
fBuffer
;
int
fCount
=
0
;
int
fBase
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fBuffer
)
>
:
:
value
)
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
}
;
using
GrVertexChunkArray
=
SkSTArray
<
1
GrVertexChunk
>
;
class
GrVertexChunkBuilder
:
SkNoncopyable
{
public
:
GrVertexChunkBuilder
(
GrMeshDrawTarget
*
target
GrVertexChunkArray
*
chunks
size_t
stride
int
minVerticesPerChunk
)
:
fTarget
(
target
)
fChunks
(
chunks
)
fStride
(
stride
)
fMinVerticesPerChunk
(
minVerticesPerChunk
)
{
SkASSERT
(
fMinVerticesPerChunk
>
0
)
;
}
~
GrVertexChunkBuilder
(
)
;
size_t
stride
(
)
const
{
return
fStride
;
}
SK_ALWAYS_INLINE
skgpu
:
:
VertexWriter
appendVertices
(
int
count
)
{
SkASSERT
(
count
>
0
)
;
if
(
fCurrChunkVertexCount
+
count
>
fCurrChunkVertexCapacity
&
&
!
this
-
>
allocChunk
(
count
)
)
{
SkDEBUGCODE
(
fLastAppendAmount
=
0
;
)
return
{
}
;
}
SkASSERT
(
fCurrChunkVertexCount
+
count
<
=
fCurrChunkVertexCapacity
)
;
fCurrChunkVertexCount
+
=
count
;
SkDEBUGCODE
(
fLastAppendAmount
=
count
;
)
return
std
:
:
exchange
(
fCurrChunkVertexWriter
fCurrChunkVertexWriter
.
makeOffset
(
fStride
*
count
)
)
;
}
void
popVertices
(
int
count
)
{
SkASSERT
(
count
<
=
fLastAppendAmount
)
;
SkASSERT
(
fLastAppendAmount
<
=
fCurrChunkVertexCount
)
;
SkASSERT
(
count
>
=
0
)
;
fCurrChunkVertexCount
-
=
count
;
fCurrChunkVertexWriter
=
fCurrChunkVertexWriter
.
makeOffset
(
fStride
*
-
count
)
;
SkDEBUGCODE
(
fLastAppendAmount
-
=
count
;
)
}
private
:
bool
allocChunk
(
int
minCount
)
;
GrMeshDrawTarget
*
const
fTarget
;
GrVertexChunkArray
*
const
fChunks
;
const
size_t
fStride
;
int
fMinVerticesPerChunk
;
skgpu
:
:
VertexWriter
fCurrChunkVertexWriter
;
int
fCurrChunkVertexCount
=
0
;
int
fCurrChunkVertexCapacity
=
0
;
SkDEBUGCODE
(
int
fLastAppendAmount
=
0
;
)
}
;
#
endif
