#
include
"
src
/
gpu
/
ganesh
/
ops
/
TessellationPathRenderer
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrDisableColorXP
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
PathInnerTriangulateOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
PathStencilCoverOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
PathTessellateOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
StrokeTessellateOp
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
Tessellation
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
WangsFormula
.
h
"
namespace
{
using
namespace
skgpu
:
:
tess
;
GrOp
:
:
Owner
make_non_convex_fill_op
(
GrRecordingContext
*
rContext
SkArenaAlloc
*
arena
skgpu
:
:
ganesh
:
:
FillPathFlags
fillPathFlags
GrAAType
aaType
const
SkRect
&
drawBounds
const
SkIRect
&
clipBounds
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
GrPaint
&
&
paint
)
{
SkASSERT
(
!
path
.
isConvex
(
)
|
|
path
.
isInverseFillType
(
)
)
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
int
numVerbs
=
path
.
countVerbs
(
)
;
if
(
numVerbs
>
0
&
&
!
path
.
isInverseFillType
(
)
)
{
SkRect
clippedDrawBounds
=
SkRect
:
:
Make
(
clipBounds
)
;
if
(
clippedDrawBounds
.
intersect
(
drawBounds
)
)
{
float
gpuFragmentWork
=
clippedDrawBounds
.
height
(
)
*
clippedDrawBounds
.
width
(
)
;
float
cpuTessellationWork
=
numVerbs
*
SkNextLog2
(
numVerbs
)
;
constexpr
static
float
kCpuWeight
=
512
;
constexpr
static
float
kMinNumPixelsToTriangulate
=
256
*
256
;
if
(
cpuTessellationWork
*
kCpuWeight
+
kMinNumPixelsToTriangulate
<
gpuFragmentWork
)
{
return
GrOp
:
:
Make
<
skgpu
:
:
ganesh
:
:
PathInnerTriangulateOp
>
(
rContext
viewMatrix
path
std
:
:
move
(
paint
)
aaType
fillPathFlags
drawBounds
)
;
}
}
}
#
endif
return
GrOp
:
:
Make
<
skgpu
:
:
ganesh
:
:
PathStencilCoverOp
>
(
rContext
arena
viewMatrix
path
std
:
:
move
(
paint
)
aaType
fillPathFlags
drawBounds
)
;
}
}
namespace
skgpu
:
:
ganesh
{
bool
TessellationPathRenderer
:
:
IsSupported
(
const
GrCaps
&
caps
)
{
return
!
caps
.
avoidStencilBuffers
(
)
&
&
caps
.
drawInstancedSupport
(
)
&
&
!
caps
.
disableTessellationPathRenderer
(
)
;
}
PathRenderer
:
:
StencilSupport
TessellationPathRenderer
:
:
onGetStencilSupport
(
const
GrStyledShape
&
shape
)
const
{
if
(
!
shape
.
style
(
)
.
isSimpleFill
(
)
|
|
shape
.
inverseFilled
(
)
)
{
return
kNoSupport_StencilSupport
;
}
return
shape
.
knownToBeConvex
(
)
?
kNoRestriction_StencilSupport
:
kStencilOnly_StencilSupport
;
}
PathRenderer
:
:
CanDrawPath
TessellationPathRenderer
:
:
onCanDrawPath
(
const
CanDrawPathArgs
&
args
)
const
{
const
GrStyledShape
&
shape
=
*
args
.
fShape
;
if
(
args
.
fAAType
=
=
GrAAType
:
:
kCoverage
|
|
shape
.
style
(
)
.
hasPathEffect
(
)
|
|
args
.
fViewMatrix
-
>
hasPerspective
(
)
|
|
shape
.
style
(
)
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
|
|
!
args
.
fProxy
-
>
canUseStencil
(
*
args
.
fCaps
)
)
{
return
CanDrawPath
:
:
kNo
;
}
if
(
!
shape
.
style
(
)
.
isSimpleFill
(
)
)
{
if
(
shape
.
inverseFilled
(
)
)
{
return
CanDrawPath
:
:
kNo
;
}
if
(
shape
.
style
(
)
.
strokeRec
(
)
.
getWidth
(
)
*
args
.
fViewMatrix
-
>
getMaxScale
(
)
>
10000
)
{
return
CanDrawPath
:
:
kNo
;
}
}
if
(
args
.
fHasUserStencilSettings
)
{
if
(
!
shape
.
style
(
)
.
isSimpleFill
(
)
|
|
!
shape
.
knownToBeConvex
(
)
|
|
shape
.
inverseFilled
(
)
)
{
return
CanDrawPath
:
:
kNo
;
}
}
return
CanDrawPath
:
:
kYes
;
}
bool
TessellationPathRenderer
:
:
onDrawPath
(
const
DrawPathArgs
&
args
)
{
auto
sdc
=
args
.
fSurfaceDrawContext
;
SkPath
path
;
args
.
fShape
-
>
asPath
(
&
path
)
;
const
SkRect
pathDevBounds
=
args
.
fViewMatrix
-
>
mapRect
(
args
.
fShape
-
>
bounds
(
)
)
;
float
n4
=
wangs_formula
:
:
worst_case_cubic_p4
(
tess
:
:
kPrecision
pathDevBounds
.
width
(
)
pathDevBounds
.
height
(
)
)
;
if
(
n4
>
tess
:
:
kMaxSegmentsPerCurve_p4
)
{
SkRect
viewport
=
SkRect
:
:
Make
(
*
args
.
fClipConservativeBounds
)
;
if
(
!
args
.
fShape
-
>
style
(
)
.
isSimpleFill
(
)
)
{
const
SkStrokeRec
&
stroke
=
args
.
fShape
-
>
style
(
)
.
strokeRec
(
)
;
float
inflationRadius
;
if
(
stroke
.
isHairlineStyle
(
)
)
{
inflationRadius
=
SkStrokeRec
:
:
GetInflationRadius
(
stroke
.
getJoin
(
)
stroke
.
getMiter
(
)
stroke
.
getCap
(
)
1
)
;
}
else
{
inflationRadius
=
stroke
.
getInflationRadius
(
)
*
args
.
fViewMatrix
-
>
getMaxScale
(
)
;
}
viewport
.
outset
(
inflationRadius
inflationRadius
)
;
}
path
=
PreChopPathCurves
(
tess
:
:
kPrecision
path
*
args
.
fViewMatrix
viewport
)
;
}
if
(
!
args
.
fShape
-
>
style
(
)
.
isSimpleFill
(
)
)
{
SkASSERT
(
!
path
.
isInverseFillType
(
)
)
;
SkASSERT
(
args
.
fUserStencilSettings
-
>
isUnused
(
)
)
;
const
SkStrokeRec
&
stroke
=
args
.
fShape
-
>
style
(
)
.
strokeRec
(
)
;
SkASSERT
(
stroke
.
getStyle
(
)
!
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
;
auto
op
=
GrOp
:
:
Make
<
StrokeTessellateOp
>
(
args
.
fContext
args
.
fAAType
*
args
.
fViewMatrix
path
stroke
std
:
:
move
(
args
.
fPaint
)
)
;
sdc
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
return
true
;
}
if
(
pathDevBounds
.
isEmpty
(
)
)
{
if
(
path
.
isInverseFillType
(
)
)
{
args
.
fSurfaceDrawContext
-
>
drawPaint
(
args
.
fClip
std
:
:
move
(
args
.
fPaint
)
*
args
.
fViewMatrix
)
;
}
return
true
;
}
if
(
path
.
isConvex
(
)
&
&
!
path
.
isInverseFillType
(
)
)
{
auto
op
=
GrOp
:
:
Make
<
PathTessellateOp
>
(
args
.
fContext
args
.
fSurfaceDrawContext
-
>
arenaAlloc
(
)
args
.
fAAType
args
.
fUserStencilSettings
*
args
.
fViewMatrix
path
std
:
:
move
(
args
.
fPaint
)
pathDevBounds
)
;
sdc
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
return
true
;
}
SkASSERT
(
args
.
fUserStencilSettings
-
>
isUnused
(
)
)
;
const
SkRect
&
drawBounds
=
path
.
isInverseFillType
(
)
?
args
.
fSurfaceDrawContext
-
>
asSurfaceProxy
(
)
-
>
backingStoreBoundsRect
(
)
:
pathDevBounds
;
auto
op
=
make_non_convex_fill_op
(
args
.
fContext
args
.
fSurfaceDrawContext
-
>
arenaAlloc
(
)
FillPathFlags
:
:
kNone
args
.
fAAType
drawBounds
*
args
.
fClipConservativeBounds
*
args
.
fViewMatrix
path
std
:
:
move
(
args
.
fPaint
)
)
;
sdc
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
return
true
;
}
void
TessellationPathRenderer
:
:
onStencilPath
(
const
StencilPathArgs
&
args
)
{
SkASSERT
(
args
.
fShape
-
>
style
(
)
.
isSimpleFill
(
)
)
;
SkASSERT
(
!
args
.
fShape
-
>
inverseFilled
(
)
)
;
auto
sdc
=
args
.
fSurfaceDrawContext
;
GrAAType
aaType
=
(
GrAA
:
:
kYes
=
=
args
.
fDoStencilMSAA
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
;
SkRect
pathDevBounds
;
args
.
fViewMatrix
-
>
mapRect
(
&
pathDevBounds
args
.
fShape
-
>
bounds
(
)
)
;
SkPath
path
;
args
.
fShape
-
>
asPath
(
&
path
)
;
float
n4
=
wangs_formula
:
:
worst_case_cubic_p4
(
tess
:
:
kPrecision
pathDevBounds
.
width
(
)
pathDevBounds
.
height
(
)
)
;
if
(
n4
>
tess
:
:
kMaxSegmentsPerCurve_p4
)
{
SkRect
viewport
=
SkRect
:
:
Make
(
*
args
.
fClipConservativeBounds
)
;
path
=
PreChopPathCurves
(
tess
:
:
kPrecision
path
*
args
.
fViewMatrix
viewport
)
;
}
if
(
path
.
isConvex
(
)
)
{
constexpr
static
GrUserStencilSettings
kMarkStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0001
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kReplace
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
GrPaint
stencilPaint
;
stencilPaint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
auto
op
=
GrOp
:
:
Make
<
PathTessellateOp
>
(
args
.
fContext
args
.
fSurfaceDrawContext
-
>
arenaAlloc
(
)
aaType
&
kMarkStencil
*
args
.
fViewMatrix
path
std
:
:
move
(
stencilPaint
)
pathDevBounds
)
;
sdc
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
return
;
}
auto
op
=
make_non_convex_fill_op
(
args
.
fContext
args
.
fSurfaceDrawContext
-
>
arenaAlloc
(
)
FillPathFlags
:
:
kStencilOnly
aaType
pathDevBounds
*
args
.
fClipConservativeBounds
*
args
.
fViewMatrix
path
GrPaint
(
)
)
;
sdc
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
}
}
