#
ifndef
GrSimpleMeshDrawOpHelper_DEFINED
#
define
GrSimpleMeshDrawOpHelper_DEFINED
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrPipeline
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrMeshDrawOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrOp
.
h
"
#
include
<
new
>
struct
SkRect
;
class
GrSimpleMeshDrawOpHelper
{
public
:
template
<
typename
Op
typename
.
.
.
OpArgs
>
static
GrOp
:
:
Owner
FactoryHelper
(
GrRecordingContext
*
GrPaint
&
&
OpArgs
&
&
.
.
.
)
;
enum
class
InputFlags
:
uint8_t
{
kNone
=
0
kSnapVerticesToPixelCenters
=
(
uint8_t
)
GrPipeline
:
:
InputFlags
:
:
kSnapVerticesToPixelCenters
kConservativeRaster
=
(
uint8_t
)
GrPipeline
:
:
InputFlags
:
:
kConservativeRaster
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
InputFlags
)
;
GrSimpleMeshDrawOpHelper
(
GrProcessorSet
*
GrAAType
InputFlags
=
InputFlags
:
:
kNone
)
;
~
GrSimpleMeshDrawOpHelper
(
)
;
GrSimpleMeshDrawOpHelper
(
)
=
delete
;
GrSimpleMeshDrawOpHelper
(
const
GrSimpleMeshDrawOpHelper
&
)
=
delete
;
GrSimpleMeshDrawOpHelper
&
operator
=
(
const
GrSimpleMeshDrawOpHelper
&
)
=
delete
;
GrDrawOp
:
:
FixedFunctionFlags
fixedFunctionFlags
(
)
const
;
bool
isCompatible
(
const
GrSimpleMeshDrawOpHelper
&
that
const
GrCaps
&
const
SkRect
&
thisBounds
const
SkRect
&
thatBounds
bool
ignoreAAType
=
false
)
const
;
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrClampType
clampType
GrProcessorAnalysisCoverage
geometryCoverage
GrProcessorAnalysisColor
*
geometryColor
)
{
return
this
-
>
finalizeProcessors
(
caps
clip
&
GrUserStencilSettings
:
:
kUnused
clampType
geometryCoverage
geometryColor
)
;
}
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
const
GrAppliedClip
*
GrClampType
GrProcessorAnalysisCoverage
geometryCoverage
SkPMColor4f
*
geometryColor
bool
*
wideColor
)
;
bool
isTrivial
(
)
const
{
return
fProcessors
=
=
nullptr
;
}
bool
usesLocalCoords
(
)
const
{
SkASSERT
(
fDidAnalysis
)
;
return
fUsesLocalCoords
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
void
visitProxies
(
const
GrVisitProxyFunc
&
func
)
const
{
if
(
fProcessors
)
{
fProcessors
-
>
visitProxies
(
func
)
;
}
}
#
if
GR_TEST_UTILS
SkString
dumpInfo
(
)
const
;
#
endif
GrAAType
aaType
(
)
const
{
return
static_cast
<
GrAAType
>
(
fAAType
)
;
}
void
setAAType
(
GrAAType
aaType
)
{
fAAType
=
static_cast
<
unsigned
>
(
aaType
)
;
}
static
const
GrPipeline
*
CreatePipeline
(
const
GrCaps
*
SkArenaAlloc
*
skgpu
:
:
Swizzle
writeViewSwizzle
GrAppliedClip
&
&
const
GrDstProxyView
&
GrProcessorSet
&
&
GrPipeline
:
:
InputFlags
pipelineFlags
)
;
static
const
GrPipeline
*
CreatePipeline
(
GrOpFlushState
*
GrProcessorSet
&
&
GrPipeline
:
:
InputFlags
pipelineFlags
)
;
const
GrPipeline
*
createPipeline
(
GrOpFlushState
*
flushState
)
;
const
GrPipeline
*
createPipeline
(
const
GrCaps
*
SkArenaAlloc
*
skgpu
:
:
Swizzle
writeViewSwizzle
GrAppliedClip
&
&
const
GrDstProxyView
&
)
;
static
GrProgramInfo
*
CreateProgramInfo
(
const
GrCaps
*
SkArenaAlloc
*
const
GrPipeline
*
const
GrSurfaceProxyView
&
writeView
bool
usesMSAASurface
GrGeometryProcessor
*
GrPrimitiveType
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
const
GrUserStencilSettings
*
=
&
GrUserStencilSettings
:
:
kUnused
)
;
static
GrProgramInfo
*
CreateProgramInfo
(
const
GrCaps
*
SkArenaAlloc
*
const
GrSurfaceProxyView
&
writeView
bool
usesMSAASurface
GrAppliedClip
&
&
const
GrDstProxyView
&
GrGeometryProcessor
*
GrProcessorSet
&
&
GrPrimitiveType
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
GrPipeline
:
:
InputFlags
pipelineFlags
=
GrPipeline
:
:
InputFlags
:
:
kNone
const
GrUserStencilSettings
*
=
&
GrUserStencilSettings
:
:
kUnused
)
;
GrProgramInfo
*
createProgramInfo
(
const
GrCaps
*
SkArenaAlloc
*
const
GrSurfaceProxyView
&
writeView
bool
usesMSAASurface
GrAppliedClip
&
&
const
GrDstProxyView
&
GrGeometryProcessor
*
GrPrimitiveType
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
;
GrProcessorSet
detachProcessorSet
(
)
{
return
fProcessors
?
std
:
:
move
(
*
fProcessors
)
:
GrProcessorSet
:
:
MakeEmptySet
(
)
;
}
GrPipeline
:
:
InputFlags
pipelineFlags
(
)
const
{
return
fPipelineFlags
;
}
protected
:
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrCaps
&
caps
const
GrAppliedClip
*
const
GrUserStencilSettings
*
GrClampType
GrProcessorAnalysisCoverage
geometryCoverage
GrProcessorAnalysisColor
*
geometryColor
)
;
GrProcessorSet
*
fProcessors
;
GrPipeline
:
:
InputFlags
fPipelineFlags
;
unsigned
fAAType
:
2
;
unsigned
fUsesLocalCoords
:
1
;
unsigned
fCompatibleWithCoverageAsAlpha
:
1
;
SkDEBUGCODE
(
unsigned
fMadePipeline
:
1
;
)
SkDEBUGCODE
(
unsigned
fDidAnalysis
:
1
;
)
}
;
template
<
typename
Op
typename
.
.
.
Args
>
GrOp
:
:
Owner
GrOp
:
:
MakeWithProcessorSet
(
GrRecordingContext
*
context
const
SkPMColor4f
&
color
GrPaint
&
&
paint
Args
&
&
.
.
.
args
)
{
char
*
bytes
=
(
char
*
)
:
:
operator
new
(
sizeof
(
Op
)
+
sizeof
(
GrProcessorSet
)
)
;
char
*
setMem
=
bytes
+
sizeof
(
Op
)
;
GrProcessorSet
*
processorSet
=
new
(
setMem
)
GrProcessorSet
{
std
:
:
move
(
paint
)
}
;
return
Owner
{
new
(
bytes
)
Op
(
processorSet
color
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
}
;
}
template
<
typename
Op
typename
.
.
.
OpArgs
>
GrOp
:
:
Owner
GrSimpleMeshDrawOpHelper
:
:
FactoryHelper
(
GrRecordingContext
*
context
GrPaint
&
&
paint
OpArgs
&
&
.
.
.
opArgs
)
{
auto
color
=
paint
.
getColor4f
(
)
;
if
(
paint
.
isTrivial
(
)
)
{
return
GrOp
:
:
Make
<
Op
>
(
context
nullptr
color
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
;
}
else
{
return
GrOp
:
:
MakeWithProcessorSet
<
Op
>
(
context
color
std
:
:
move
(
paint
)
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
;
}
}
GR_MAKE_BITFIELD_CLASS_OPS
(
GrSimpleMeshDrawOpHelper
:
:
InputFlags
)
#
endif
