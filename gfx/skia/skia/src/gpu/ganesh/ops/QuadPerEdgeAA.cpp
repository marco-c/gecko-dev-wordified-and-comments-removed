#
include
"
src
/
gpu
/
ganesh
/
ops
/
QuadPerEdgeAA
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
gpu
/
KeyBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMeshDrawTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLColorSpaceXformHelper
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVarying
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kLeft
=
=
SkCanvas
:
:
kLeft_QuadAAFlag
)
;
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kTop
=
=
SkCanvas
:
:
kTop_QuadAAFlag
)
;
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kRight
=
=
SkCanvas
:
:
kRight_QuadAAFlag
)
;
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kBottom
=
=
SkCanvas
:
:
kBottom_QuadAAFlag
)
;
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kNone
=
=
SkCanvas
:
:
kNone_QuadAAFlags
)
;
static_assert
(
(
int
)
GrQuadAAFlags
:
:
kAll
=
=
SkCanvas
:
:
kAll_QuadAAFlags
)
;
namespace
skgpu
:
:
ganesh
:
:
QuadPerEdgeAA
{
namespace
{
using
VertexSpec
=
skgpu
:
:
ganesh
:
:
QuadPerEdgeAA
:
:
VertexSpec
;
using
CoverageMode
=
skgpu
:
:
ganesh
:
:
QuadPerEdgeAA
:
:
CoverageMode
;
using
ColorType
=
skgpu
:
:
ganesh
:
:
QuadPerEdgeAA
:
:
ColorType
;
void
write_quad_generic
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
static
constexpr
auto
If
=
VertexWriter
:
:
If
<
float
>
;
SkASSERT
(
!
spec
.
hasLocalCoords
(
)
|
|
localQuad
)
;
CoverageMode
mode
=
spec
.
coverageMode
(
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
If
(
spec
.
deviceQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
deviceQuad
-
>
w
(
i
)
)
<
<
If
(
mode
=
=
CoverageMode
:
:
kWithPosition
coverage
[
i
]
)
;
if
(
spec
.
hasVertexColors
(
)
)
{
bool
wide
=
spec
.
colorType
(
)
=
=
ColorType
:
:
kFloat
;
*
vb
<
<
VertexColor
(
color
*
(
mode
=
=
CoverageMode
:
:
kWithColor
?
coverage
[
i
]
:
1
)
wide
)
;
}
if
(
spec
.
hasLocalCoords
(
)
)
{
*
vb
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
<
<
If
(
spec
.
localQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
localQuad
-
>
w
(
i
)
)
;
}
if
(
spec
.
requiresGeometrySubset
(
)
)
{
*
vb
<
<
geomSubset
;
}
if
(
spec
.
hasSubset
(
)
)
{
*
vb
<
<
texSubset
;
}
}
}
void
write_2d_color
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
!
spec
.
hasLocalCoords
(
)
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
|
|
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
)
;
SkASSERT
(
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
!
spec
.
hasSubset
(
)
)
;
bool
wide
=
spec
.
colorType
(
)
=
=
ColorType
:
:
kFloat
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
|
|
coverage
[
i
]
=
=
1
.
f
)
;
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
VertexColor
(
color
*
coverage
[
i
]
wide
)
;
}
}
void
write_2d_uv
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
)
;
SkASSERT
(
!
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
!
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
;
}
}
void
write_2d_color_uv
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
|
|
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
)
;
SkASSERT
(
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
!
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
bool
wide
=
spec
.
colorType
(
)
=
=
ColorType
:
:
kFloat
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
|
|
coverage
[
i
]
=
=
1
.
f
)
;
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
VertexColor
(
color
*
coverage
[
i
]
wide
)
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
;
}
}
void
write_2d_cov_uv
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithPosition
)
;
SkASSERT
(
!
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
!
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
coverage
[
i
]
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
;
}
}
void
write_2d_uv_strict
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
)
;
SkASSERT
(
!
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
<
<
texSubset
;
}
}
void
write_2d_color_uv_strict
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
|
|
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
)
;
SkASSERT
(
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
bool
wide
=
spec
.
colorType
(
)
=
=
ColorType
:
:
kFloat
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
|
|
coverage
[
i
]
=
=
1
.
f
)
;
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
VertexColor
(
color
*
coverage
[
i
]
wide
)
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
<
<
texSubset
;
}
}
void
write_2d_cov_uv_strict
(
VertexWriter
*
vb
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
{
SkASSERT
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
;
SkASSERT
(
spec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithPosition
)
;
SkASSERT
(
!
spec
.
hasVertexColors
(
)
)
;
SkASSERT
(
!
spec
.
requiresGeometrySubset
(
)
)
;
SkASSERT
(
spec
.
hasSubset
(
)
)
;
SkASSERT
(
localQuad
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
*
vb
<
<
deviceQuad
-
>
x
(
i
)
<
<
deviceQuad
-
>
y
(
i
)
<
<
coverage
[
i
]
<
<
localQuad
-
>
x
(
i
)
<
<
localQuad
-
>
y
(
i
)
<
<
texSubset
;
}
}
}
IndexBufferOption
CalcIndexBufferOption
(
GrAAType
aa
int
numQuads
)
{
if
(
aa
=
=
GrAAType
:
:
kCoverage
)
{
return
IndexBufferOption
:
:
kPictureFramed
;
}
else
if
(
numQuads
>
1
)
{
return
IndexBufferOption
:
:
kIndexedRects
;
}
else
{
return
IndexBufferOption
:
:
kTriStrips
;
}
}
ColorType
MinColorType
(
SkPMColor4f
color
)
{
if
(
color
=
=
SK_PMColor4fWHITE
)
{
return
ColorType
:
:
kNone
;
}
else
{
return
color
.
fitsInBytes
(
)
?
ColorType
:
:
kByte
:
ColorType
:
:
kFloat
;
}
}
Tessellator
:
:
WriteQuadProc
Tessellator
:
:
GetWriteQuadProc
(
const
VertexSpec
&
spec
)
{
if
(
spec
.
deviceQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
&
&
!
spec
.
requiresGeometrySubset
(
)
)
{
CoverageMode
mode
=
spec
.
coverageMode
(
)
;
if
(
spec
.
hasVertexColors
(
)
)
{
if
(
mode
!
=
CoverageMode
:
:
kWithPosition
)
{
if
(
!
spec
.
hasLocalCoords
(
)
)
{
return
write_2d_color
;
}
else
if
(
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
return
spec
.
hasSubset
(
)
?
write_2d_color_uv_strict
:
write_2d_color_uv
;
}
}
}
else
if
(
spec
.
hasLocalCoords
(
)
&
&
spec
.
localQuadType
(
)
!
=
GrQuad
:
:
Type
:
:
kPerspective
)
{
if
(
mode
=
=
CoverageMode
:
:
kWithPosition
)
{
return
spec
.
hasSubset
(
)
?
write_2d_cov_uv_strict
:
write_2d_cov_uv
;
}
else
{
SkASSERT
(
mode
=
=
CoverageMode
:
:
kNone
)
;
return
spec
.
hasSubset
(
)
?
write_2d_uv_strict
:
write_2d_uv
;
}
}
}
return
write_quad_generic
;
}
Tessellator
:
:
Tessellator
(
const
VertexSpec
&
spec
char
*
vertices
)
:
fVertexSpec
(
spec
)
fVertexWriter
{
vertices
}
fWriteProc
(
Tessellator
:
:
GetWriteQuadProc
(
spec
)
)
{
}
void
Tessellator
:
:
append
(
GrQuad
*
deviceQuad
GrQuad
*
localQuad
const
SkPMColor4f
&
color
const
SkRect
&
uvSubset
GrQuadAAFlags
aaFlags
)
{
SkASSERT
(
fVertexWriter
)
;
SkASSERT
(
deviceQuad
-
>
quadType
(
)
<
=
fVertexSpec
.
deviceQuadType
(
)
)
;
SkASSERT
(
localQuad
|
|
!
fVertexSpec
.
hasLocalCoords
(
)
)
;
SkASSERT
(
!
fVertexSpec
.
hasLocalCoords
(
)
|
|
localQuad
-
>
quadType
(
)
<
=
fVertexSpec
.
localQuadType
(
)
)
;
static
const
float
kFullCoverage
[
4
]
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
static
const
float
kZeroCoverage
[
4
]
=
{
0
.
f
0
.
f
0
.
f
0
.
f
}
;
static
const
SkRect
kIgnoredSubset
=
SkRect
:
:
MakeEmpty
(
)
;
if
(
fVertexSpec
.
usesCoverageAA
(
)
)
{
SkASSERT
(
fVertexSpec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithColor
|
|
fVertexSpec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kWithPosition
)
;
SkRect
geomSubset
;
if
(
fVertexSpec
.
requiresGeometrySubset
(
)
)
{
#
ifdef
SK_USE_LEGACY_AA_QUAD_SUBSET
geomSubset
=
deviceQuad
-
>
bounds
(
)
;
geomSubset
.
outset
(
0
.
5f
0
.
5f
)
;
#
else
float
outset
=
aaFlags
=
=
GrQuadAAFlags
:
:
kAll
?
0
.
5f
:
1
.
f
;
geomSubset
=
deviceQuad
-
>
bounds
(
)
.
makeOutset
(
outset
outset
)
;
#
endif
}
if
(
aaFlags
=
=
GrQuadAAFlags
:
:
kNone
)
{
fWriteProc
(
&
fVertexWriter
fVertexSpec
deviceQuad
localQuad
kFullCoverage
color
geomSubset
uvSubset
)
;
fWriteProc
(
&
fVertexWriter
fVertexSpec
deviceQuad
localQuad
kZeroCoverage
color
geomSubset
uvSubset
)
;
}
else
{
fAAHelper
.
reset
(
*
deviceQuad
localQuad
)
;
skvx
:
:
Vec
<
4
float
>
edgeDistances
;
if
(
aaFlags
=
=
GrQuadAAFlags
:
:
kAll
)
{
edgeDistances
=
0
.
5f
;
}
else
{
edgeDistances
=
{
(
aaFlags
&
GrQuadAAFlags
:
:
kLeft
)
?
0
.
5f
:
0
.
f
(
aaFlags
&
GrQuadAAFlags
:
:
kBottom
)
?
0
.
5f
:
0
.
f
(
aaFlags
&
GrQuadAAFlags
:
:
kTop
)
?
0
.
5f
:
0
.
f
(
aaFlags
&
GrQuadAAFlags
:
:
kRight
)
?
0
.
5f
:
0
.
f
}
;
}
float
coverage
[
4
]
;
fAAHelper
.
inset
(
edgeDistances
deviceQuad
localQuad
)
.
store
(
coverage
)
;
fWriteProc
(
&
fVertexWriter
fVertexSpec
deviceQuad
localQuad
coverage
color
geomSubset
uvSubset
)
;
const
bool
hairline
=
aaFlags
=
=
GrQuadAAFlags
:
:
kAll
&
&
coverage
[
0
]
<
1
.
f
&
&
coverage
[
1
]
<
1
.
f
&
&
coverage
[
2
]
<
1
.
f
&
&
coverage
[
3
]
<
1
.
f
;
if
(
hairline
)
{
skvx
:
:
Vec
<
4
float
>
len
=
fAAHelper
.
getEdgeLengths
(
)
;
skvx
:
:
Vec
<
4
float
>
maxWH
=
max
(
skvx
:
:
shuffle
<
1
0
3
2
>
(
len
)
skvx
:
:
shuffle
<
2
3
0
1
>
(
len
)
)
;
edgeDistances
*
=
max
(
1
.
f
2
.
f
-
maxWH
)
;
}
fAAHelper
.
outset
(
edgeDistances
deviceQuad
localQuad
)
;
fWriteProc
(
&
fVertexWriter
fVertexSpec
deviceQuad
localQuad
kZeroCoverage
color
geomSubset
uvSubset
)
;
}
}
else
{
SkASSERT
(
fVertexSpec
.
coverageMode
(
)
=
=
CoverageMode
:
:
kNone
&
&
!
fVertexSpec
.
requiresGeometrySubset
(
)
)
;
fWriteProc
(
&
fVertexWriter
fVertexSpec
deviceQuad
localQuad
kFullCoverage
color
kIgnoredSubset
uvSubset
)
;
}
}
sk_sp
<
const
GrBuffer
>
GetIndexBuffer
(
GrMeshDrawTarget
*
target
IndexBufferOption
indexBufferOption
)
{
auto
resourceProvider
=
target
-
>
resourceProvider
(
)
;
switch
(
indexBufferOption
)
{
case
IndexBufferOption
:
:
kPictureFramed
:
return
resourceProvider
-
>
refAAQuadIndexBuffer
(
)
;
case
IndexBufferOption
:
:
kIndexedRects
:
return
resourceProvider
-
>
refNonAAQuadIndexBuffer
(
)
;
case
IndexBufferOption
:
:
kTriStrips
:
default
:
return
nullptr
;
}
}
int
QuadLimit
(
IndexBufferOption
option
)
{
switch
(
option
)
{
case
IndexBufferOption
:
:
kPictureFramed
:
return
GrResourceProvider
:
:
MaxNumAAQuads
(
)
;
case
IndexBufferOption
:
:
kIndexedRects
:
return
GrResourceProvider
:
:
MaxNumNonAAQuads
(
)
;
case
IndexBufferOption
:
:
kTriStrips
:
return
SK_MaxS32
;
}
SkUNREACHABLE
;
}
void
IssueDraw
(
const
GrCaps
&
caps
GrOpsRenderPass
*
renderPass
const
VertexSpec
&
spec
int
runningQuadCount
int
quadsInDraw
int
maxVerts
int
absVertBufferOffset
)
{
if
(
spec
.
indexBufferOption
(
)
=
=
IndexBufferOption
:
:
kTriStrips
)
{
int
offset
=
absVertBufferOffset
+
runningQuadCount
*
GrResourceProvider
:
:
NumVertsPerNonAAQuad
(
)
;
renderPass
-
>
draw
(
4
offset
)
;
return
;
}
SkASSERT
(
spec
.
indexBufferOption
(
)
=
=
IndexBufferOption
:
:
kPictureFramed
|
|
spec
.
indexBufferOption
(
)
=
=
IndexBufferOption
:
:
kIndexedRects
)
;
int
maxNumQuads
numIndicesPerQuad
numVertsPerQuad
;
if
(
spec
.
indexBufferOption
(
)
=
=
IndexBufferOption
:
:
kPictureFramed
)
{
maxNumQuads
=
GrResourceProvider
:
:
MaxNumAAQuads
(
)
;
numIndicesPerQuad
=
GrResourceProvider
:
:
NumIndicesPerAAQuad
(
)
;
numVertsPerQuad
=
GrResourceProvider
:
:
NumVertsPerAAQuad
(
)
;
}
else
{
maxNumQuads
=
GrResourceProvider
:
:
MaxNumNonAAQuads
(
)
;
numIndicesPerQuad
=
GrResourceProvider
:
:
NumIndicesPerNonAAQuad
(
)
;
numVertsPerQuad
=
GrResourceProvider
:
:
NumVertsPerNonAAQuad
(
)
;
}
SkASSERT
(
runningQuadCount
+
quadsInDraw
<
=
maxNumQuads
)
;
if
(
caps
.
avoidLargeIndexBufferDraws
(
)
)
{
int
offset
=
absVertBufferOffset
+
runningQuadCount
*
numVertsPerQuad
;
renderPass
-
>
drawIndexPattern
(
numIndicesPerQuad
quadsInDraw
maxNumQuads
numVertsPerQuad
offset
)
;
}
else
{
int
baseIndex
=
runningQuadCount
*
numIndicesPerQuad
;
int
numIndicesToDraw
=
quadsInDraw
*
numIndicesPerQuad
;
int
minVertex
=
runningQuadCount
*
numVertsPerQuad
;
int
maxVertex
=
(
runningQuadCount
+
quadsInDraw
)
*
numVertsPerQuad
-
1
;
renderPass
-
>
drawIndexed
(
numIndicesToDraw
baseIndex
minVertex
maxVertex
absVertBufferOffset
)
;
}
}
int
VertexSpec
:
:
deviceDimensionality
(
)
const
{
return
this
-
>
deviceQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
?
3
:
2
;
}
int
VertexSpec
:
:
localDimensionality
(
)
const
{
return
fHasLocalCoords
?
(
this
-
>
localQuadType
(
)
=
=
GrQuad
:
:
Type
:
:
kPerspective
?
3
:
2
)
:
0
;
}
CoverageMode
VertexSpec
:
:
coverageMode
(
)
const
{
if
(
this
-
>
usesCoverageAA
(
)
)
{
if
(
this
-
>
compatibleWithCoverageAsAlpha
(
)
&
&
this
-
>
hasVertexColors
(
)
&
&
!
this
-
>
requiresGeometrySubset
(
)
)
{
return
CoverageMode
:
:
kWithColor
;
}
else
{
return
CoverageMode
:
:
kWithPosition
;
}
}
else
{
return
CoverageMode
:
:
kNone
;
}
}
size_t
VertexSpec
:
:
vertexSize
(
)
const
{
bool
needsPerspective
=
(
this
-
>
deviceDimensionality
(
)
=
=
3
)
;
CoverageMode
coverageMode
=
this
-
>
coverageMode
(
)
;
size_t
count
=
0
;
if
(
coverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
needsPerspective
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
else
{
count
+
=
GrVertexAttribTypeSize
(
kFloat2_GrVertexAttribType
)
+
GrVertexAttribTypeSize
(
kFloat_GrVertexAttribType
)
;
}
}
else
{
if
(
needsPerspective
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat3_GrVertexAttribType
)
;
}
else
{
count
+
=
GrVertexAttribTypeSize
(
kFloat2_GrVertexAttribType
)
;
}
}
if
(
this
-
>
requiresGeometrySubset
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
count
+
=
this
-
>
localDimensionality
(
)
*
GrVertexAttribTypeSize
(
kFloat_GrVertexAttribType
)
;
if
(
ColorType
:
:
kByte
=
=
this
-
>
colorType
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kUByte4_norm_GrVertexAttribType
)
;
}
else
if
(
ColorType
:
:
kFloat
=
=
this
-
>
colorType
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
if
(
this
-
>
hasSubset
(
)
)
{
count
+
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
;
}
return
count
;
}
class
QuadPerEdgeAAGeometryProcessor
:
public
GrGeometryProcessor
{
public
:
static
GrGeometryProcessor
*
Make
(
SkArenaAlloc
*
arena
const
VertexSpec
&
spec
)
{
return
arena
-
>
make
(
[
&
]
(
void
*
ptr
)
{
return
new
(
ptr
)
QuadPerEdgeAAGeometryProcessor
(
spec
)
;
}
)
;
}
static
GrGeometryProcessor
*
Make
(
SkArenaAlloc
*
arena
const
VertexSpec
&
vertexSpec
const
GrShaderCaps
&
caps
const
GrBackendFormat
&
backendFormat
GrSamplerState
samplerState
const
skgpu
:
:
Swizzle
&
swizzle
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
{
return
arena
-
>
make
(
[
&
]
(
void
*
ptr
)
{
return
new
(
ptr
)
QuadPerEdgeAAGeometryProcessor
(
vertexSpec
caps
backendFormat
samplerState
swizzle
std
:
:
move
(
textureColorSpaceXform
)
saturate
)
;
}
)
;
}
const
char
*
name
(
)
const
override
{
return
"
QuadPerEdgeAAGeometryProcessor
"
;
}
void
addToKey
(
const
GrShaderCaps
&
KeyBuilder
*
b
)
const
override
{
b
-
>
addBool
(
fTexSubset
.
isInitialized
(
)
"
subset
"
)
;
b
-
>
addBool
(
fSampler
.
isInitialized
(
)
"
textured
"
)
;
b
-
>
addBool
(
fNeedsPerspective
"
perspective
"
)
;
b
-
>
addBool
(
(
fSaturate
=
=
Saturate
:
:
kYes
)
"
saturate
"
)
;
b
-
>
addBool
(
fLocalCoord
.
isInitialized
(
)
"
hasLocalCoords
"
)
;
if
(
fLocalCoord
.
isInitialized
(
)
)
{
b
-
>
addBits
(
1
(
kFloat3_GrVertexAttribType
=
=
fLocalCoord
.
cpuType
(
)
)
"
localCoordsType
"
)
;
}
b
-
>
addBool
(
fColor
.
isInitialized
(
)
"
hasColor
"
)
;
if
(
fColor
.
isInitialized
(
)
)
{
b
-
>
addBits
(
1
(
kFloat4_GrVertexAttribType
=
=
fColor
.
cpuType
(
)
)
"
colorType
"
)
;
}
uint32_t
coverageKey
=
0
;
SkASSERT
(
!
fGeomSubset
.
isInitialized
(
)
|
|
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
;
if
(
fCoverageMode
!
=
CoverageMode
:
:
kNone
)
{
coverageKey
=
fGeomSubset
.
isInitialized
(
)
?
0x3
:
(
CoverageMode
:
:
kWithPosition
=
=
fCoverageMode
?
0x1
:
0x2
)
;
}
b
-
>
addBits
(
2
coverageKey
"
coverageMode
"
)
;
b
-
>
add32
(
GrColorSpaceXform
:
:
XformKey
(
fTextureColorSpaceXform
.
get
(
)
)
"
colorSpaceXform
"
)
;
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
const
GrShaderCaps
&
)
const
override
{
class
Impl
:
public
ProgramImpl
{
public
:
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrShaderCaps
&
const
GrGeometryProcessor
&
geomProc
)
override
{
const
auto
&
gp
=
geomProc
.
cast
<
QuadPerEdgeAAGeometryProcessor
>
(
)
;
fTextureColorSpaceXformHelper
.
setData
(
pdman
gp
.
fTextureColorSpaceXform
.
get
(
)
)
;
}
private
:
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
using
Interpolation
=
GrGLSLVaryingHandler
:
:
Interpolation
;
const
auto
&
gp
=
args
.
fGeomProc
.
cast
<
QuadPerEdgeAAGeometryProcessor
>
(
)
;
fTextureColorSpaceXformHelper
.
emitCode
(
args
.
fUniformHandler
gp
.
fTextureColorSpaceXform
.
get
(
)
)
;
args
.
fVaryingHandler
-
>
emitAttributes
(
gp
)
;
if
(
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
gp
.
fNeedsPerspective
)
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
float3
position
=
%
s
.
xyz
;
"
gp
.
fPosition
.
name
(
)
)
;
}
else
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
float2
position
=
%
s
.
xy
;
"
gp
.
fPosition
.
name
(
)
)
;
}
gpArgs
-
>
fPositionVar
=
{
"
position
"
gp
.
fNeedsPerspective
?
SkSLType
:
:
kFloat3
:
SkSLType
:
:
kFloat2
GrShaderVar
:
:
TypeModifier
:
:
None
}
;
}
else
{
gpArgs
-
>
fPositionVar
=
gp
.
fPosition
.
asShaderVar
(
)
;
}
gpArgs
-
>
fLocalCoordVar
=
gp
.
fLocalCoord
.
asShaderVar
(
)
;
const
char
*
blendDst
;
if
(
gp
.
fColor
.
isInitialized
(
)
)
{
SkASSERT
(
gp
.
fCoverageMode
!
=
CoverageMode
:
:
kWithColor
|
|
!
gp
.
fNeedsPerspective
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
half4
%
s
;
"
args
.
fOutputColor
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fColor
.
asShaderVar
(
)
args
.
fOutputColor
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithColor
?
Interpolation
:
:
kInterpolated
:
Interpolation
:
:
kCanBeFlat
)
;
blendDst
=
args
.
fOutputColor
;
}
else
{
args
.
fFragBuilder
-
>
codeAppendf
(
"
half4
%
s
=
half4
(
1
)
;
"
args
.
fOutputColor
)
;
blendDst
=
nullptr
;
}
if
(
gp
.
fSampler
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float2
texCoord
;
"
)
;
if
(
gp
.
fLocalCoord
.
cpuType
(
)
=
=
kFloat3_GrVertexAttribType
)
{
GrGLSLVarying
v
(
gp
.
fLocalCoord
.
gpuType
(
)
)
;
args
.
fVaryingHandler
-
>
addVarying
(
gp
.
fLocalCoord
.
name
(
)
&
v
)
;
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
v
.
vsOut
(
)
gp
.
fLocalCoord
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
texCoord
=
%
s
.
xy
/
%
s
.
z
;
"
v
.
fsIn
(
)
v
.
fsIn
(
)
)
;
}
else
{
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fLocalCoord
.
asShaderVar
(
)
"
texCoord
"
)
;
}
if
(
gp
.
fTexSubset
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float4
subset
;
"
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fTexSubset
.
asShaderVar
(
)
"
subset
"
Interpolation
:
:
kCanBeFlat
)
;
args
.
fFragBuilder
-
>
codeAppend
(
"
texCoord
=
clamp
(
texCoord
subset
.
LT
subset
.
RB
)
;
"
)
;
}
args
.
fFragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
(
"
args
.
fOutputColor
(
gp
.
fSaturate
=
=
Saturate
:
:
kYes
)
?
"
saturate
"
:
"
"
)
;
args
.
fFragBuilder
-
>
appendTextureLookupAndBlend
(
blendDst
SkBlendMode
:
:
kModulate
args
.
fTexSamplers
[
0
]
"
texCoord
"
&
fTextureColorSpaceXformHelper
)
;
args
.
fFragBuilder
-
>
codeAppend
(
"
)
;
"
)
;
}
else
{
SkASSERT
(
gp
.
fSaturate
=
=
Saturate
:
:
kNo
)
;
}
if
(
gp
.
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
GrGLSLVarying
coverage
(
SkSLType
:
:
kFloat
)
;
args
.
fVaryingHandler
-
>
addVarying
(
"
coverage
"
&
coverage
)
;
if
(
gp
.
fNeedsPerspective
)
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
.
w
*
%
s
.
z
;
"
coverage
.
vsOut
(
)
gp
.
fPosition
.
name
(
)
gp
.
fPosition
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
float
coverage
=
%
s
*
sk_FragCoord
.
w
;
"
coverage
.
fsIn
(
)
)
;
}
else
{
args
.
fVertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
coverage
.
vsOut
(
)
gp
.
fCoverage
.
name
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
float
coverage
=
%
s
;
"
coverage
.
fsIn
(
)
)
;
}
if
(
gp
.
fGeomSubset
.
isInitialized
(
)
)
{
args
.
fFragBuilder
-
>
codeAppend
(
"
float4
geoSubset
;
"
)
;
args
.
fVaryingHandler
-
>
addPassThroughAttribute
(
gp
.
fGeomSubset
.
asShaderVar
(
)
"
geoSubset
"
Interpolation
:
:
kCanBeFlat
)
;
#
ifdef
SK_USE_LEGACY_AA_QUAD_SUBSET
args
.
fFragBuilder
-
>
codeAppend
(
"
if
(
coverage
<
0
.
5
)
{
"
"
float4
dists4
=
clamp
(
float4
(
1
1
-
1
-
1
)
*
"
"
(
sk_FragCoord
.
xyxy
-
geoSubset
)
0
1
)
;
"
"
float2
dists2
=
dists4
.
xy
*
dists4
.
zw
;
"
"
coverage
=
min
(
coverage
dists2
.
x
*
dists2
.
y
)
;
"
"
}
"
)
;
#
else
args
.
fFragBuilder
-
>
codeAppend
(
"
half4
dists4
=
clamp
(
half4
(
1
1
-
1
-
1
)
*
"
"
half4
(
sk_FragCoord
.
xyxy
-
geoSubset
)
0
1
)
;
\
n
"
"
half2
dists2
=
dists4
.
xy
+
dists4
.
zw
-
1
;
\
n
"
"
half
subsetCoverage
=
dists2
.
x
*
dists2
.
y
;
\
n
"
"
coverage
=
min
(
coverage
subsetCoverage
)
;
"
)
;
#
endif
}
args
.
fFragBuilder
-
>
codeAppendf
(
"
half4
%
s
=
half4
(
half
(
coverage
)
)
;
"
args
.
fOutputCoverage
)
;
}
else
{
SkASSERT
(
!
gp
.
fGeomSubset
.
isInitialized
(
)
)
;
args
.
fFragBuilder
-
>
codeAppendf
(
"
const
half4
%
s
=
half4
(
1
)
;
"
args
.
fOutputCoverage
)
;
}
}
GrGLSLColorSpaceXformHelper
fTextureColorSpaceXformHelper
;
}
;
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
private
:
using
Saturate
=
skgpu
:
:
ganesh
:
:
TextureOp
:
:
Saturate
;
QuadPerEdgeAAGeometryProcessor
(
const
VertexSpec
&
spec
)
:
INHERITED
(
kQuadPerEdgeAAGeometryProcessor_ClassID
)
fTextureColorSpaceXform
(
nullptr
)
{
SkASSERT
(
!
spec
.
hasSubset
(
)
)
;
this
-
>
initializeAttrs
(
spec
)
;
this
-
>
setTextureSamplerCnt
(
0
)
;
}
QuadPerEdgeAAGeometryProcessor
(
const
VertexSpec
&
spec
const
GrShaderCaps
&
caps
const
GrBackendFormat
&
backendFormat
GrSamplerState
samplerState
const
skgpu
:
:
Swizzle
&
swizzle
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
:
INHERITED
(
kQuadPerEdgeAAGeometryProcessor_ClassID
)
fSaturate
(
saturate
)
fTextureColorSpaceXform
(
std
:
:
move
(
textureColorSpaceXform
)
)
fSampler
(
samplerState
backendFormat
swizzle
)
{
SkASSERT
(
spec
.
hasLocalCoords
(
)
)
;
this
-
>
initializeAttrs
(
spec
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
void
initializeAttrs
(
const
VertexSpec
&
spec
)
{
fNeedsPerspective
=
spec
.
deviceDimensionality
(
)
=
=
3
;
fCoverageMode
=
spec
.
coverageMode
(
)
;
if
(
fCoverageMode
=
=
CoverageMode
:
:
kWithPosition
)
{
if
(
fNeedsPerspective
)
{
fPosition
=
{
"
positionWithCoverage
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
}
;
}
else
{
fPosition
=
{
"
position
"
kFloat2_GrVertexAttribType
SkSLType
:
:
kFloat2
}
;
fCoverage
=
{
"
coverage
"
kFloat_GrVertexAttribType
SkSLType
:
:
kFloat
}
;
}
}
else
{
if
(
fNeedsPerspective
)
{
fPosition
=
{
"
position
"
kFloat3_GrVertexAttribType
SkSLType
:
:
kFloat3
}
;
}
else
{
fPosition
=
{
"
position
"
kFloat2_GrVertexAttribType
SkSLType
:
:
kFloat2
}
;
}
}
if
(
spec
.
requiresGeometrySubset
(
)
)
{
fGeomSubset
=
{
"
geomSubset
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
}
;
}
int
localDim
=
spec
.
localDimensionality
(
)
;
if
(
localDim
=
=
3
)
{
fLocalCoord
=
{
"
localCoord
"
kFloat3_GrVertexAttribType
SkSLType
:
:
kFloat3
}
;
}
else
if
(
localDim
=
=
2
)
{
fLocalCoord
=
{
"
localCoord
"
kFloat2_GrVertexAttribType
SkSLType
:
:
kFloat2
}
;
}
if
(
spec
.
hasVertexColors
(
)
)
{
fColor
=
MakeColorAttribute
(
"
color
"
ColorType
:
:
kFloat
=
=
spec
.
colorType
(
)
)
;
}
if
(
spec
.
hasSubset
(
)
)
{
fTexSubset
=
{
"
texSubset
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
}
;
}
this
-
>
setVertexAttributesWithImplicitOffsets
(
&
fPosition
6
)
;
}
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fSampler
;
}
Attribute
fPosition
;
Attribute
fCoverage
;
Attribute
fColor
;
Attribute
fLocalCoord
;
Attribute
fGeomSubset
;
Attribute
fTexSubset
;
bool
fNeedsPerspective
;
Saturate
fSaturate
=
Saturate
:
:
kNo
;
CoverageMode
fCoverageMode
;
sk_sp
<
GrColorSpaceXform
>
fTextureColorSpaceXform
;
TextureSampler
fSampler
;
using
INHERITED
=
GrGeometryProcessor
;
}
;
GrGeometryProcessor
*
MakeProcessor
(
SkArenaAlloc
*
arena
const
VertexSpec
&
spec
)
{
return
QuadPerEdgeAAGeometryProcessor
:
:
Make
(
arena
spec
)
;
}
GrGeometryProcessor
*
MakeTexturedProcessor
(
SkArenaAlloc
*
arena
const
VertexSpec
&
spec
const
GrShaderCaps
&
caps
const
GrBackendFormat
&
backendFormat
GrSamplerState
samplerState
const
skgpu
:
:
Swizzle
&
swizzle
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
saturate
)
{
return
QuadPerEdgeAAGeometryProcessor
:
:
Make
(
arena
spec
caps
backendFormat
samplerState
swizzle
std
:
:
move
(
textureColorSpaceXform
)
saturate
)
;
}
}
