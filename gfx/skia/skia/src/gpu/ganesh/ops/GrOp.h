#
ifndef
GrOp_DEFINED
#
define
GrOp_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTracing
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrXferProcessor
.
h
"
#
include
<
atomic
>
#
include
<
new
>
class
GrAppliedClip
;
class
GrCaps
;
class
GrDstProxyView
;
class
GrOpFlushState
;
class
GrOpsRenderPass
;
class
GrPaint
;
class
GrRecordingContext
;
class
GrSurfaceProxyView
;
#
define
GR_OP_SPEW
0
#
if
GR_OP_SPEW
#
define
GrOP_SPEW
(
code
)
code
#
define
GrOP_INFO
(
.
.
.
)
SkDebugf
(
__VA_ARGS__
)
#
else
#
define
GrOP_SPEW
(
code
)
#
define
GrOP_INFO
(
.
.
.
)
#
endif
#
define
GR_FLUSH_TIME_OP_SPEW
0
#
define
DEFINE_OP_CLASS_ID
\
static
uint32_t
ClassID
(
)
{
\
static
uint32_t
kClassID
=
GenOpClassID
(
)
;
\
return
kClassID
;
\
}
class
GrOp
:
private
SkNoncopyable
{
public
:
using
Owner
=
std
:
:
unique_ptr
<
GrOp
>
;
template
<
typename
Op
typename
.
.
.
Args
>
static
Owner
Make
(
GrRecordingContext
*
context
Args
&
&
.
.
.
args
)
{
return
Owner
{
new
Op
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
}
;
}
template
<
typename
Op
typename
.
.
.
Args
>
static
Owner
MakeWithProcessorSet
(
GrRecordingContext
*
context
const
SkPMColor4f
&
color
GrPaint
&
&
paint
Args
&
&
.
.
.
args
)
;
template
<
typename
Op
typename
.
.
.
Args
>
static
Owner
MakeWithExtraMemory
(
GrRecordingContext
*
context
size_t
extraSize
Args
&
&
.
.
.
args
)
{
void
*
bytes
=
:
:
operator
new
(
sizeof
(
Op
)
+
extraSize
)
;
return
Owner
{
new
(
bytes
)
Op
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
}
;
}
virtual
~
GrOp
(
)
=
default
;
virtual
const
char
*
name
(
)
const
=
0
;
virtual
void
visitProxies
(
const
GrVisitProxyFunc
&
)
const
{
}
enum
class
CombineResult
{
kMerged
kMayChain
kCannotCombine
}
;
CombineResult
combineIfPossible
(
GrOp
*
that
SkArenaAlloc
*
alloc
const
GrCaps
&
caps
)
;
const
SkRect
&
bounds
(
)
const
{
SkASSERT
(
kUninitialized_BoundsFlag
!
=
fBoundsFlags
)
;
return
fBounds
;
}
void
setClippedBounds
(
const
SkRect
&
clippedBounds
)
{
fBounds
=
clippedBounds
;
fBoundsFlags
=
0
;
}
bool
hasAABloat
(
)
const
{
SkASSERT
(
fBoundsFlags
!
=
kUninitialized_BoundsFlag
)
;
return
SkToBool
(
fBoundsFlags
&
kAABloat_BoundsFlag
)
;
}
bool
hasZeroArea
(
)
const
{
SkASSERT
(
fBoundsFlags
!
=
kUninitialized_BoundsFlag
)
;
return
SkToBool
(
fBoundsFlags
&
kZeroArea_BoundsFlag
)
;
}
void
operator
delete
(
void
*
p
)
{
:
:
operator
delete
(
p
)
;
}
template
<
typename
T
>
const
T
&
cast
(
)
const
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
template
<
typename
T
>
T
*
cast
(
)
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
uint32_t
classID
(
)
const
{
SkASSERT
(
kIllegalOpID
!
=
fClassID
)
;
return
fClassID
;
}
uint32_t
uniqueID
(
)
const
{
if
(
kIllegalOpID
=
=
fUniqueID
)
{
fUniqueID
=
GenOpID
(
)
;
}
return
fUniqueID
;
}
void
prePrepare
(
GrRecordingContext
*
context
const
GrSurfaceProxyView
&
dstView
GrAppliedClip
*
clip
const
GrDstProxyView
&
dstProxyView
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
{
TRACE_EVENT0_ALWAYS
(
"
skia
.
gpu
"
TRACE_STR_STATIC
(
name
(
)
)
)
;
this
-
>
onPrePrepare
(
context
dstView
clip
dstProxyView
renderPassXferBarriers
colorLoadOp
)
;
}
void
prepare
(
GrOpFlushState
*
state
)
{
TRACE_EVENT0_ALWAYS
(
"
skia
.
gpu
"
TRACE_STR_STATIC
(
name
(
)
)
)
;
this
-
>
onPrepare
(
state
)
;
}
void
execute
(
GrOpFlushState
*
state
const
SkRect
&
chainBounds
)
{
TRACE_EVENT0_ALWAYS
(
"
skia
.
gpu
"
TRACE_STR_STATIC
(
name
(
)
)
)
;
this
-
>
onExecute
(
state
chainBounds
)
;
}
#
if
GR_TEST_UTILS
virtual
SkString
dumpInfo
(
)
const
final
{
return
SkStringPrintf
(
"
%
s
\
nOpBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
this
-
>
onDumpInfo
(
)
.
c_str
(
)
fBounds
.
fLeft
fBounds
.
fTop
fBounds
.
fRight
fBounds
.
fBottom
)
;
}
#
endif
template
<
typename
OpSubclass
=
GrOp
>
class
ChainRange
{
private
:
class
Iter
{
public
:
explicit
Iter
(
const
OpSubclass
*
head
)
:
fCurr
(
head
)
{
}
inline
Iter
&
operator
+
+
(
)
{
return
*
this
=
Iter
(
static_cast
<
const
OpSubclass
*
>
(
fCurr
-
>
nextInChain
(
)
)
)
;
}
const
OpSubclass
&
operator
*
(
)
const
{
return
*
fCurr
;
}
bool
operator
!
=
(
const
Iter
&
that
)
const
{
return
fCurr
!
=
that
.
fCurr
;
}
private
:
const
OpSubclass
*
fCurr
;
}
;
const
OpSubclass
*
fHead
;
public
:
explicit
ChainRange
(
const
OpSubclass
*
head
)
:
fHead
(
head
)
{
}
Iter
begin
(
)
{
return
Iter
(
fHead
)
;
}
Iter
end
(
)
{
return
Iter
(
nullptr
)
;
}
}
;
void
chainConcat
(
GrOp
:
:
Owner
)
;
bool
isChainHead
(
)
const
{
return
!
fPrevInChain
;
}
bool
isChainTail
(
)
const
{
return
!
fNextInChain
;
}
GrOp
*
nextInChain
(
)
const
{
return
fNextInChain
.
get
(
)
;
}
GrOp
*
prevInChain
(
)
const
{
return
fPrevInChain
;
}
GrOp
:
:
Owner
cutChain
(
)
;
SkDEBUGCODE
(
void
validateChain
(
GrOp
*
expectedTail
=
nullptr
)
const
)
;
#
ifdef
SK_DEBUG
virtual
void
validate
(
)
const
{
}
#
endif
protected
:
GrOp
(
uint32_t
classID
)
;
enum
class
HasAABloat
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
IsHairline
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
setBounds
(
const
SkRect
&
newBounds
HasAABloat
aabloat
IsHairline
zeroArea
)
{
fBounds
=
newBounds
;
this
-
>
setBoundsFlags
(
aabloat
zeroArea
)
;
}
void
setTransformedBounds
(
const
SkRect
&
srcBounds
const
SkMatrix
&
m
HasAABloat
aabloat
IsHairline
zeroArea
)
{
m
.
mapRect
(
&
fBounds
srcBounds
)
;
this
-
>
setBoundsFlags
(
aabloat
zeroArea
)
;
}
void
makeFullScreen
(
GrSurfaceProxy
*
proxy
)
{
this
-
>
setBounds
(
proxy
-
>
getBoundsRect
(
)
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
}
static
uint32_t
GenOpClassID
(
)
{
return
GenID
(
&
gCurrOpClassID
)
;
}
private
:
void
joinBounds
(
const
GrOp
&
that
)
{
if
(
that
.
hasAABloat
(
)
)
{
fBoundsFlags
|
=
kAABloat_BoundsFlag
;
}
if
(
that
.
hasZeroArea
(
)
)
{
fBoundsFlags
|
=
kZeroArea_BoundsFlag
;
}
return
fBounds
.
joinPossiblyEmptyRect
(
that
.
fBounds
)
;
}
virtual
CombineResult
onCombineIfPossible
(
GrOp
*
SkArenaAlloc
*
const
GrCaps
&
)
{
return
CombineResult
:
:
kCannotCombine
;
}
virtual
void
onPrePrepare
(
GrRecordingContext
*
const
GrSurfaceProxyView
&
writeView
GrAppliedClip
*
const
GrDstProxyView
&
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
=
0
;
virtual
void
onPrepare
(
GrOpFlushState
*
)
=
0
;
virtual
void
onExecute
(
GrOpFlushState
*
const
SkRect
&
chainBounds
)
=
0
;
#
if
GR_TEST_UTILS
virtual
SkString
onDumpInfo
(
)
const
{
return
SkString
(
)
;
}
#
endif
static
uint32_t
GenID
(
std
:
:
atomic
<
uint32_t
>
*
idCounter
)
{
uint32_t
id
=
idCounter
-
>
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
if
(
id
=
=
0
)
{
SK_ABORT
(
"
This
should
never
wrap
as
it
should
only
be
called
once
for
each
GrOp
"
"
subclass
.
"
)
;
}
return
id
;
}
void
setBoundsFlags
(
HasAABloat
aabloat
IsHairline
zeroArea
)
{
fBoundsFlags
=
0
;
fBoundsFlags
|
=
(
HasAABloat
:
:
kYes
=
=
aabloat
)
?
kAABloat_BoundsFlag
:
0
;
fBoundsFlags
|
=
(
IsHairline
:
:
kYes
=
=
zeroArea
)
?
kZeroArea_BoundsFlag
:
0
;
}
enum
{
kIllegalOpID
=
0
}
;
enum
BoundsFlags
{
kAABloat_BoundsFlag
=
0x1
kZeroArea_BoundsFlag
=
0x2
SkDEBUGCODE
(
kUninitialized_BoundsFlag
=
0x4
)
}
;
Owner
fNextInChain
{
nullptr
}
;
GrOp
*
fPrevInChain
=
nullptr
;
const
uint16_t
fClassID
;
uint16_t
fBoundsFlags
;
static
uint32_t
GenOpID
(
)
{
return
GenID
(
&
gCurrOpUniqueID
)
;
}
mutable
uint32_t
fUniqueID
=
SK_InvalidUniqueID
;
SkRect
fBounds
;
static
std
:
:
atomic
<
uint32_t
>
gCurrOpUniqueID
;
static
std
:
:
atomic
<
uint32_t
>
gCurrOpClassID
;
}
;
#
endif
