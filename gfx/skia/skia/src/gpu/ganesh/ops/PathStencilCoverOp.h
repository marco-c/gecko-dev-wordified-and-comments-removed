#
ifndef
PathStencilCoverOp_DEFINED
#
define
PathStencilCoverOp_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
ops
/
FillPathFlags
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrDrawOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrTessellationShader
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
PathTessellator
.
h
"
namespace
skgpu
:
:
ganesh
{
class
PathStencilCoverOp
final
:
public
GrDrawOp
{
private
:
DEFINE_OP_CLASS_ID
using
PathDrawList
=
PathTessellator
:
:
PathDrawList
;
PathStencilCoverOp
(
SkArenaAlloc
*
arena
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
GrPaint
&
&
paint
GrAAType
aaType
FillPathFlags
pathFlags
const
SkRect
&
drawBounds
)
:
GrDrawOp
(
ClassID
(
)
)
fPathDrawList
(
arena
-
>
make
<
PathDrawList
>
(
viewMatrix
path
SK_PMColor4fTRANSPARENT
)
)
fTotalCombinedPathVerbCnt
(
path
.
countVerbs
(
)
)
fPathCount
(
1
)
fPathFlags
(
pathFlags
)
fAAType
(
aaType
)
fColor
(
paint
.
getColor4f
(
)
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
this
-
>
setBounds
(
drawBounds
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
SkDEBUGCODE
(
fOriginalDrawBounds
=
drawBounds
;
)
}
PathStencilCoverOp
(
const
PathDrawList
*
pathDrawList
int
totalCombinedVerbCnt
int
pathCount
GrPaint
&
&
paint
GrAAType
aaType
FillPathFlags
pathFlags
const
SkRect
&
drawBounds
)
:
GrDrawOp
(
ClassID
(
)
)
fPathDrawList
(
pathDrawList
)
fTotalCombinedPathVerbCnt
(
totalCombinedVerbCnt
)
fPathCount
(
pathCount
)
fPathFlags
(
pathFlags
)
fAAType
(
aaType
)
fColor
(
paint
.
getColor4f
(
)
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
this
-
>
setBounds
(
drawBounds
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
SkDEBUGCODE
(
fOriginalDrawBounds
=
drawBounds
;
)
}
const
char
*
name
(
)
const
override
{
return
"
PathStencilCoverOp
"
;
}
void
visitProxies
(
const
GrVisitProxyFunc
&
)
const
override
;
FixedFunctionFlags
fixedFunctionFlags
(
)
const
override
;
GrProcessorSet
:
:
Analysis
finalize
(
const
GrCaps
&
const
GrAppliedClip
*
GrClampType
)
override
;
SkPathFillType
pathFillType
(
)
const
{
return
fPathDrawList
-
>
fPath
.
getFillType
(
)
;
}
void
prePreparePrograms
(
const
GrTessellationShader
:
:
ProgramArgs
&
GrAppliedClip
&
&
clip
)
;
void
onPrePrepare
(
GrRecordingContext
*
const
GrSurfaceProxyView
&
GrAppliedClip
*
const
GrDstProxyView
&
GrXferBarrierFlags
GrLoadOp
colorLoadOp
)
override
;
void
onPrepare
(
GrOpFlushState
*
)
override
;
void
onExecute
(
GrOpFlushState
*
const
SkRect
&
chainBounds
)
override
;
const
PathDrawList
*
fPathDrawList
;
const
int
fTotalCombinedPathVerbCnt
;
const
int
fPathCount
;
const
FillPathFlags
fPathFlags
;
const
GrAAType
fAAType
;
SkPMColor4f
fColor
;
GrProcessorSet
fProcessors
;
SkDEBUGCODE
(
SkRect
fOriginalDrawBounds
;
)
PathTessellator
*
fTessellator
=
nullptr
;
const
GrProgramInfo
*
fStencilFanProgram
=
nullptr
;
const
GrProgramInfo
*
fStencilPathProgram
=
nullptr
;
const
GrProgramInfo
*
fCoverBBoxProgram
=
nullptr
;
sk_sp
<
const
GrBuffer
>
fFanBuffer
;
int
fFanBaseVertex
=
0
;
int
fFanVertexCount
=
0
;
sk_sp
<
const
GrBuffer
>
fBBoxBuffer
;
int
fBBoxBaseInstance
=
0
;
sk_sp
<
const
GrGpuBuffer
>
fBBoxVertexBufferIfNoIDSupport
;
friend
class
GrOp
;
}
;
}
#
endif
