#
ifndef
QuadPerEdgeAA_DEFINED
#
define
QuadPerEdgeAA_DEFINED
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBuffer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSamplerState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
TextureOp
.
h
"
class
GrCaps
;
class
GrColorSpaceXform
;
class
GrMeshDrawTarget
;
struct
GrShaderCaps
;
struct
VertexWriter
;
namespace
skgpu
:
:
ganesh
:
:
QuadPerEdgeAA
{
using
Saturate
=
skgpu
:
:
ganesh
:
:
TextureOp
:
:
Saturate
;
enum
class
CoverageMode
{
kNone
kWithPosition
kWithColor
}
;
enum
class
Subset
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
ColorType
{
kNone
kByte
kFloat
kLast
=
kFloat
}
;
static
const
int
kColorTypeCount
=
static_cast
<
int
>
(
ColorType
:
:
kLast
)
+
1
;
enum
class
IndexBufferOption
{
kPictureFramed
kIndexedRects
kTriStrips
kLast
=
kTriStrips
}
;
static
const
int
kIndexBufferOptionCount
=
static_cast
<
int
>
(
IndexBufferOption
:
:
kLast
)
+
1
;
IndexBufferOption
CalcIndexBufferOption
(
GrAAType
aa
int
numQuads
)
;
ColorType
MinColorType
(
SkPMColor4f
)
;
struct
VertexSpec
{
public
:
VertexSpec
(
)
:
fDeviceQuadType
(
0
)
fLocalQuadType
(
0
)
fIndexBufferOption
(
0
)
fHasLocalCoords
(
false
)
fColorType
(
0
)
fHasSubset
(
false
)
fUsesCoverageAA
(
false
)
fCompatibleWithCoverageAsAlpha
(
false
)
fRequiresGeometrySubset
(
false
)
{
}
VertexSpec
(
GrQuad
:
:
Type
deviceQuadType
ColorType
colorType
GrQuad
:
:
Type
localQuadType
bool
hasLocalCoords
Subset
subset
GrAAType
aa
bool
coverageAsAlpha
IndexBufferOption
indexBufferOption
)
:
fDeviceQuadType
(
static_cast
<
unsigned
>
(
deviceQuadType
)
)
fLocalQuadType
(
static_cast
<
unsigned
>
(
localQuadType
)
)
fIndexBufferOption
(
static_cast
<
unsigned
>
(
indexBufferOption
)
)
fHasLocalCoords
(
hasLocalCoords
)
fColorType
(
static_cast
<
unsigned
>
(
colorType
)
)
fHasSubset
(
static_cast
<
unsigned
>
(
subset
)
)
fUsesCoverageAA
(
aa
=
=
GrAAType
:
:
kCoverage
)
fCompatibleWithCoverageAsAlpha
(
coverageAsAlpha
)
fRequiresGeometrySubset
(
aa
=
=
GrAAType
:
:
kCoverage
&
&
deviceQuadType
>
GrQuad
:
:
Type
:
:
kRectilinear
)
{
}
GrQuad
:
:
Type
deviceQuadType
(
)
const
{
return
static_cast
<
GrQuad
:
:
Type
>
(
fDeviceQuadType
)
;
}
GrQuad
:
:
Type
localQuadType
(
)
const
{
return
static_cast
<
GrQuad
:
:
Type
>
(
fLocalQuadType
)
;
}
IndexBufferOption
indexBufferOption
(
)
const
{
return
static_cast
<
IndexBufferOption
>
(
fIndexBufferOption
)
;
}
bool
hasLocalCoords
(
)
const
{
return
fHasLocalCoords
;
}
ColorType
colorType
(
)
const
{
return
static_cast
<
ColorType
>
(
fColorType
)
;
}
bool
hasVertexColors
(
)
const
{
return
ColorType
:
:
kNone
!
=
this
-
>
colorType
(
)
;
}
bool
hasSubset
(
)
const
{
return
fHasSubset
;
}
bool
usesCoverageAA
(
)
const
{
return
fUsesCoverageAA
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
bool
requiresGeometrySubset
(
)
const
{
return
fRequiresGeometrySubset
;
}
int
deviceDimensionality
(
)
const
;
int
localDimensionality
(
)
const
;
int
verticesPerQuad
(
)
const
{
return
fUsesCoverageAA
?
8
:
4
;
}
CoverageMode
coverageMode
(
)
const
;
size_t
vertexSize
(
)
const
;
bool
needsIndexBuffer
(
)
const
{
return
this
-
>
indexBufferOption
(
)
!
=
IndexBufferOption
:
:
kTriStrips
;
}
GrPrimitiveType
primitiveType
(
)
const
{
switch
(
this
-
>
indexBufferOption
(
)
)
{
case
IndexBufferOption
:
:
kPictureFramed
:
return
GrPrimitiveType
:
:
kTriangles
;
case
IndexBufferOption
:
:
kIndexedRects
:
return
GrPrimitiveType
:
:
kTriangles
;
case
IndexBufferOption
:
:
kTriStrips
:
return
GrPrimitiveType
:
:
kTriangleStrip
;
}
SkUNREACHABLE
;
}
private
:
static_assert
(
GrQuad
:
:
kTypeCount
<
=
4
"
GrQuad
:
:
Type
doesn
'
t
fit
in
2
bits
"
)
;
static_assert
(
kColorTypeCount
<
=
4
"
Color
doesn
'
t
fit
in
2
bits
"
)
;
static_assert
(
kIndexBufferOptionCount
<
=
4
"
IndexBufferOption
doesn
'
t
fit
in
2
bits
"
)
;
unsigned
fDeviceQuadType
:
2
;
unsigned
fLocalQuadType
:
2
;
unsigned
fIndexBufferOption
:
2
;
unsigned
fHasLocalCoords
:
1
;
unsigned
fColorType
:
2
;
unsigned
fHasSubset
:
1
;
unsigned
fUsesCoverageAA
:
1
;
unsigned
fCompatibleWithCoverageAsAlpha
:
1
;
unsigned
fRequiresGeometrySubset
:
1
;
}
;
class
Tessellator
{
public
:
explicit
Tessellator
(
const
VertexSpec
&
spec
char
*
vertices
)
;
void
append
(
GrQuad
*
deviceQuad
GrQuad
*
localQuad
const
SkPMColor4f
&
color
const
SkRect
&
uvSubset
GrQuadAAFlags
aaFlags
)
;
SkDEBUGCODE
(
skgpu
:
:
BufferWriter
:
:
Mark
vertexMark
(
)
const
{
return
fVertexWriter
.
mark
(
)
;
}
)
private
:
typedef
void
(
*
WriteQuadProc
)
(
VertexWriter
*
vertices
const
VertexSpec
&
spec
const
GrQuad
*
deviceQuad
const
GrQuad
*
localQuad
const
float
coverage
[
4
]
const
SkPMColor4f
&
color
const
SkRect
&
geomSubset
const
SkRect
&
texSubset
)
;
static
WriteQuadProc
GetWriteQuadProc
(
const
VertexSpec
&
spec
)
;
GrQuadUtils
:
:
TessellationHelper
fAAHelper
;
VertexSpec
fVertexSpec
;
VertexWriter
fVertexWriter
;
WriteQuadProc
fWriteProc
;
}
;
GrGeometryProcessor
*
MakeProcessor
(
SkArenaAlloc
*
const
VertexSpec
&
)
;
GrGeometryProcessor
*
MakeTexturedProcessor
(
SkArenaAlloc
*
const
VertexSpec
&
const
GrShaderCaps
&
const
GrBackendFormat
&
GrSamplerState
const
skgpu
:
:
Swizzle
&
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
Saturate
)
;
sk_sp
<
const
GrBuffer
>
GetIndexBuffer
(
GrMeshDrawTarget
*
IndexBufferOption
)
;
int
QuadLimit
(
IndexBufferOption
)
;
void
IssueDraw
(
const
GrCaps
&
GrOpsRenderPass
*
const
VertexSpec
&
int
runningQuadCount
int
quadCount
int
maxVerts
int
absVertBufferOffset
)
;
}
#
endif
