#
ifndef
AtlasRenderTask_DEFINED
#
define
AtlasRenderTask_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDynamicAtlas
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
OpsTask
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
PathTessellator
.
h
"
struct
SkIPoint16
;
namespace
skgpu
:
:
ganesh
{
class
AtlasRenderTask
final
:
public
OpsTask
{
public
:
AtlasRenderTask
(
GrRecordingContext
*
sk_sp
<
GrArenas
>
std
:
:
unique_ptr
<
GrDynamicAtlas
>
)
;
const
GrTextureProxy
*
atlasProxy
(
)
const
{
return
fDynamicAtlas
-
>
textureProxy
(
)
;
}
GrSurfaceProxyView
readView
(
const
GrCaps
&
caps
)
const
{
return
fDynamicAtlas
-
>
readView
(
caps
)
;
}
bool
addPath
(
const
SkMatrix
&
const
SkPath
&
SkIPoint
pathDevTopLeft
int
widthInAtlas
int
heightInAtlas
bool
transposedInAtlas
SkIPoint16
*
locationInAtlas
)
;
bool
SK_WARN_UNUSED_RESULT
instantiate
(
GrOnFlushResourceProvider
*
onFlushRP
sk_sp
<
GrTexture
>
backingTexture
=
nullptr
)
{
SkASSERT
(
this
-
>
isClosed
(
)
)
;
return
fDynamicAtlas
-
>
instantiate
(
onFlushRP
std
:
:
move
(
backingTexture
)
)
;
}
private
:
ExpectedOutcome
onMakeClosed
(
GrRecordingContext
*
SkIRect
*
targetUpdateBounds
)
override
;
void
stencilAtlasRect
(
GrRecordingContext
*
const
SkRect
&
const
SkPMColor4f
&
const
GrUserStencilSettings
*
)
;
void
addAtlasDrawOp
(
GrOp
:
:
Owner
const
GrCaps
&
)
;
bool
onExecute
(
GrOpFlushState
*
flushState
)
override
;
const
std
:
:
unique_ptr
<
GrDynamicAtlas
>
fDynamicAtlas
;
using
PathDrawList
=
PathTessellator
:
:
PathDrawList
;
using
PathDrawAllocator
=
SkTBlockList
<
PathDrawList
16
>
;
PathDrawAllocator
fPathDrawAllocator
{
64
SkBlockAllocator
:
:
GrowthPolicy
:
:
kFibonacci
}
;
class
AtlasPathList
:
SkNoncopyable
{
public
:
void
add
(
PathDrawAllocator
*
alloc
const
SkMatrix
&
pathMatrix
const
SkPath
&
path
)
{
fPathDrawList
=
&
alloc
-
>
emplace_back
(
pathMatrix
path
SK_PMColor4fTRANSPARENT
fPathDrawList
)
;
if
(
path
.
isInverseFillType
(
)
)
{
fPathDrawList
-
>
fPath
.
toggleInverseFillType
(
)
;
}
fTotalCombinedPathVerbCnt
+
=
path
.
countVerbs
(
)
;
+
+
fPathCount
;
}
const
PathDrawList
*
pathDrawList
(
)
const
{
return
fPathDrawList
;
}
int
totalCombinedPathVerbCnt
(
)
const
{
return
fTotalCombinedPathVerbCnt
;
}
int
pathCount
(
)
const
{
return
fPathCount
;
}
private
:
PathDrawList
*
fPathDrawList
=
nullptr
;
int
fTotalCombinedPathVerbCnt
=
0
;
int
fPathCount
=
0
;
}
;
AtlasPathList
fWindingPathList
;
AtlasPathList
fEvenOddPathList
;
}
;
}
#
endif
