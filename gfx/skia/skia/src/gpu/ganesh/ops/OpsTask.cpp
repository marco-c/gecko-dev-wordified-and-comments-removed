#
include
"
src
/
gpu
/
ganesh
/
ops
/
OpsTask
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
base
/
SkScopeExit
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAttachment
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAuditTrail
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrNativeRect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrRect
.
h
"
namespace
{
static
const
int
kMaxOpMergeDistance
=
10
;
static
const
int
kMaxOpChainDistance
=
10
;
inline
bool
can_reorder
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
!
GrRectsOverlap
(
a
b
)
;
}
GrOpsRenderPass
*
create_render_pass
(
GrGpu
*
gpu
GrRenderTarget
*
rt
bool
useMSAASurface
GrAttachment
*
stencil
GrSurfaceOrigin
origin
const
SkIRect
&
bounds
GrLoadOp
colorLoadOp
const
std
:
:
array
<
float
4
>
&
loadClearColor
GrLoadOp
stencilLoadOp
GrStoreOp
stencilStoreOp
const
SkTArray
<
GrSurfaceProxy
*
true
>
&
sampledProxies
GrXferBarrierFlags
renderPassXferBarriers
)
{
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
kColorLoadStoreInfo
{
colorLoadOp
GrStoreOp
:
:
kStore
loadClearColor
}
;
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
stencilLoadAndStoreInfo
{
stencilLoadOp
stencilStoreOp
}
;
return
gpu
-
>
getOpsRenderPass
(
rt
useMSAASurface
stencil
origin
bounds
kColorLoadStoreInfo
stencilLoadAndStoreInfo
sampledProxies
renderPassXferBarriers
)
;
}
}
namespace
skgpu
:
:
ganesh
{
inline
OpsTask
:
:
OpChain
:
:
List
:
:
List
(
GrOp
:
:
Owner
op
)
:
fHead
(
std
:
:
move
(
op
)
)
fTail
(
fHead
.
get
(
)
)
{
this
-
>
validate
(
)
;
}
inline
OpsTask
:
:
OpChain
:
:
List
:
:
List
(
List
&
&
that
)
{
*
this
=
std
:
:
move
(
that
)
;
}
inline
OpsTask
:
:
OpChain
:
:
List
&
OpsTask
:
:
OpChain
:
:
List
:
:
operator
=
(
List
&
&
that
)
{
fHead
=
std
:
:
move
(
that
.
fHead
)
;
fTail
=
that
.
fTail
;
that
.
fTail
=
nullptr
;
this
-
>
validate
(
)
;
return
*
this
;
}
inline
GrOp
:
:
Owner
OpsTask
:
:
OpChain
:
:
List
:
:
popHead
(
)
{
SkASSERT
(
fHead
)
;
auto
temp
=
fHead
-
>
cutChain
(
)
;
std
:
:
swap
(
temp
fHead
)
;
if
(
!
fHead
)
{
SkASSERT
(
fTail
=
=
temp
.
get
(
)
)
;
fTail
=
nullptr
;
}
return
temp
;
}
inline
GrOp
:
:
Owner
OpsTask
:
:
OpChain
:
:
List
:
:
removeOp
(
GrOp
*
op
)
{
#
ifdef
SK_DEBUG
auto
head
=
op
;
while
(
head
-
>
prevInChain
(
)
)
{
head
=
head
-
>
prevInChain
(
)
;
}
SkASSERT
(
head
=
=
fHead
.
get
(
)
)
;
#
endif
auto
prev
=
op
-
>
prevInChain
(
)
;
if
(
!
prev
)
{
SkASSERT
(
op
=
=
fHead
.
get
(
)
)
;
return
this
-
>
popHead
(
)
;
}
auto
temp
=
prev
-
>
cutChain
(
)
;
if
(
auto
next
=
temp
-
>
cutChain
(
)
)
{
prev
-
>
chainConcat
(
std
:
:
move
(
next
)
)
;
}
else
{
SkASSERT
(
fTail
=
=
op
)
;
fTail
=
prev
;
}
this
-
>
validate
(
)
;
return
temp
;
}
inline
void
OpsTask
:
:
OpChain
:
:
List
:
:
pushHead
(
GrOp
:
:
Owner
op
)
{
SkASSERT
(
op
)
;
SkASSERT
(
op
-
>
isChainHead
(
)
)
;
SkASSERT
(
op
-
>
isChainTail
(
)
)
;
if
(
fHead
)
{
op
-
>
chainConcat
(
std
:
:
move
(
fHead
)
)
;
fHead
=
std
:
:
move
(
op
)
;
}
else
{
fHead
=
std
:
:
move
(
op
)
;
fTail
=
fHead
.
get
(
)
;
}
}
inline
void
OpsTask
:
:
OpChain
:
:
List
:
:
pushTail
(
GrOp
:
:
Owner
op
)
{
SkASSERT
(
op
-
>
isChainTail
(
)
)
;
fTail
-
>
chainConcat
(
std
:
:
move
(
op
)
)
;
fTail
=
fTail
-
>
nextInChain
(
)
;
}
inline
void
OpsTask
:
:
OpChain
:
:
List
:
:
validate
(
)
const
{
#
ifdef
SK_DEBUG
if
(
fHead
)
{
SkASSERT
(
fTail
)
;
fHead
-
>
validateChain
(
fTail
)
;
}
#
endif
}
OpsTask
:
:
OpChain
:
:
OpChain
(
GrOp
:
:
Owner
op
GrProcessorSet
:
:
Analysis
processorAnalysis
GrAppliedClip
*
appliedClip
const
GrDstProxyView
*
dstProxyView
)
:
fList
{
std
:
:
move
(
op
)
}
fProcessorAnalysis
(
processorAnalysis
)
fAppliedClip
(
appliedClip
)
{
if
(
fProcessorAnalysis
.
requiresDstTexture
(
)
)
{
SkASSERT
(
dstProxyView
&
&
dstProxyView
-
>
proxy
(
)
)
;
fDstProxyView
=
*
dstProxyView
;
}
fBounds
=
fList
.
head
(
)
-
>
bounds
(
)
;
}
void
OpsTask
:
:
OpChain
:
:
visitProxies
(
const
GrVisitProxyFunc
&
func
)
const
{
if
(
fList
.
empty
(
)
)
{
return
;
}
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fList
.
head
(
)
)
)
{
op
.
visitProxies
(
func
)
;
}
if
(
fDstProxyView
.
proxy
(
)
)
{
func
(
fDstProxyView
.
proxy
(
)
GrMipmapped
:
:
kNo
)
;
}
if
(
fAppliedClip
)
{
fAppliedClip
-
>
visitProxies
(
func
)
;
}
}
void
OpsTask
:
:
OpChain
:
:
deleteOps
(
)
{
while
(
!
fList
.
empty
(
)
)
{
fList
.
popHead
(
)
;
}
}
OpsTask
:
:
OpChain
:
:
List
OpsTask
:
:
OpChain
:
:
DoConcat
(
List
chainA
List
chainB
const
GrCaps
&
caps
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
auditTrail
)
{
GrOp
*
origATail
=
chainA
.
tail
(
)
;
SkRect
skipBounds
=
SkRectPriv
:
:
MakeLargestInverted
(
)
;
do
{
int
numMergeChecks
=
0
;
bool
merged
=
false
;
bool
noSkip
=
(
origATail
=
=
chainA
.
tail
(
)
)
;
SkASSERT
(
noSkip
=
=
(
skipBounds
=
=
SkRectPriv
:
:
MakeLargestInverted
(
)
)
)
;
bool
canBackwardMerge
=
noSkip
|
|
can_reorder
(
chainB
.
head
(
)
-
>
bounds
(
)
skipBounds
)
;
SkRect
forwardMergeBounds
=
skipBounds
;
GrOp
*
a
=
origATail
;
while
(
a
)
{
bool
canForwardMerge
=
(
a
=
=
chainA
.
tail
(
)
)
|
|
can_reorder
(
a
-
>
bounds
(
)
forwardMergeBounds
)
;
if
(
canForwardMerge
|
|
canBackwardMerge
)
{
auto
result
=
a
-
>
combineIfPossible
(
chainB
.
head
(
)
opsTaskArena
caps
)
;
SkASSERT
(
result
!
=
GrOp
:
:
CombineResult
:
:
kCannotCombine
)
;
merged
=
(
result
=
=
GrOp
:
:
CombineResult
:
:
kMerged
)
;
GrOP_INFO
(
"
\
t
\
t
:
(
%
s
opID
:
%
u
)
-
>
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
chainB
.
head
(
)
-
>
name
(
)
chainB
.
head
(
)
-
>
uniqueID
(
)
a
-
>
name
(
)
a
-
>
uniqueID
(
)
)
;
}
if
(
merged
)
{
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
auditTrail
a
chainB
.
head
(
)
)
;
if
(
canBackwardMerge
)
{
chainB
.
popHead
(
)
;
}
else
{
SkASSERT
(
canForwardMerge
)
;
if
(
a
=
=
origATail
)
{
origATail
=
a
-
>
prevInChain
(
)
;
}
GrOp
:
:
Owner
detachedA
=
chainA
.
removeOp
(
a
)
;
chainB
.
popHead
(
)
;
chainB
.
pushHead
(
std
:
:
move
(
detachedA
)
)
;
if
(
chainA
.
empty
(
)
)
{
return
chainB
;
}
}
break
;
}
else
{
if
(
+
+
numMergeChecks
=
=
kMaxOpMergeDistance
)
{
break
;
}
forwardMergeBounds
.
joinNonEmptyArg
(
a
-
>
bounds
(
)
)
;
canBackwardMerge
=
canBackwardMerge
&
&
can_reorder
(
chainB
.
head
(
)
-
>
bounds
(
)
a
-
>
bounds
(
)
)
;
a
=
a
-
>
prevInChain
(
)
;
}
}
if
(
!
merged
)
{
chainA
.
pushTail
(
chainB
.
popHead
(
)
)
;
skipBounds
.
joinNonEmptyArg
(
chainA
.
tail
(
)
-
>
bounds
(
)
)
;
}
}
while
(
!
chainB
.
empty
(
)
)
;
return
chainA
;
}
bool
OpsTask
:
:
OpChain
:
:
tryConcat
(
List
*
list
GrProcessorSet
:
:
Analysis
processorAnalysis
const
GrDstProxyView
&
dstProxyView
const
GrAppliedClip
*
appliedClip
const
SkRect
&
bounds
const
GrCaps
&
caps
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
auditTrail
)
{
SkASSERT
(
!
fList
.
empty
(
)
)
;
SkASSERT
(
!
list
-
>
empty
(
)
)
;
SkASSERT
(
fProcessorAnalysis
.
requiresDstTexture
(
)
=
=
SkToBool
(
fDstProxyView
.
proxy
(
)
)
)
;
SkASSERT
(
processorAnalysis
.
requiresDstTexture
(
)
=
=
SkToBool
(
dstProxyView
.
proxy
(
)
)
)
;
if
(
fList
.
head
(
)
-
>
classID
(
)
!
=
list
-
>
head
(
)
-
>
classID
(
)
|
|
SkToBool
(
fAppliedClip
)
!
=
SkToBool
(
appliedClip
)
|
|
(
fAppliedClip
&
&
*
fAppliedClip
!
=
*
appliedClip
)
|
|
(
fProcessorAnalysis
.
requiresNonOverlappingDraws
(
)
!
=
processorAnalysis
.
requiresNonOverlappingDraws
(
)
)
|
|
(
fProcessorAnalysis
.
requiresNonOverlappingDraws
(
)
&
&
GrRectsTouchOrOverlap
(
fBounds
bounds
)
)
|
|
(
fProcessorAnalysis
.
requiresDstTexture
(
)
!
=
processorAnalysis
.
requiresDstTexture
(
)
)
|
|
(
fProcessorAnalysis
.
requiresDstTexture
(
)
&
&
fDstProxyView
!
=
dstProxyView
)
)
{
return
false
;
}
SkDEBUGCODE
(
bool
first
=
true
;
)
do
{
switch
(
fList
.
tail
(
)
-
>
combineIfPossible
(
list
-
>
head
(
)
opsTaskArena
caps
)
)
{
case
GrOp
:
:
CombineResult
:
:
kCannotCombine
:
SkASSERT
(
first
)
;
return
false
;
case
GrOp
:
:
CombineResult
:
:
kMayChain
:
fList
=
DoConcat
(
std
:
:
move
(
fList
)
std
:
:
exchange
(
*
list
List
(
)
)
caps
opsTaskArena
auditTrail
)
;
SkASSERT
(
list
-
>
empty
(
)
)
;
break
;
case
GrOp
:
:
CombineResult
:
:
kMerged
:
{
GrOP_INFO
(
"
\
t
\
t
:
(
%
s
opID
:
%
u
)
-
>
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
list
-
>
tail
(
)
-
>
name
(
)
list
-
>
tail
(
)
-
>
uniqueID
(
)
list
-
>
head
(
)
-
>
name
(
)
list
-
>
head
(
)
-
>
uniqueID
(
)
)
;
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
auditTrail
fList
.
tail
(
)
list
-
>
head
(
)
)
;
list
-
>
popHead
(
)
;
break
;
}
}
SkDEBUGCODE
(
first
=
false
)
;
}
while
(
!
list
-
>
empty
(
)
)
;
fBounds
.
joinPossiblyEmptyRect
(
bounds
)
;
return
true
;
}
bool
OpsTask
:
:
OpChain
:
:
prependChain
(
OpChain
*
that
const
GrCaps
&
caps
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
auditTrail
)
{
if
(
!
that
-
>
tryConcat
(
&
fList
fProcessorAnalysis
fDstProxyView
fAppliedClip
fBounds
caps
opsTaskArena
auditTrail
)
)
{
this
-
>
validate
(
)
;
return
false
;
}
SkASSERT
(
fList
.
empty
(
)
)
;
fList
=
std
:
:
move
(
that
-
>
fList
)
;
fBounds
=
that
-
>
fBounds
;
that
-
>
fDstProxyView
.
setProxyView
(
{
}
)
;
if
(
that
-
>
fAppliedClip
&
&
that
-
>
fAppliedClip
-
>
hasCoverageFragmentProcessor
(
)
)
{
that
-
>
fAppliedClip
-
>
detachCoverageFragmentProcessor
(
)
;
}
this
-
>
validate
(
)
;
return
true
;
}
GrOp
:
:
Owner
OpsTask
:
:
OpChain
:
:
appendOp
(
GrOp
:
:
Owner
op
GrProcessorSet
:
:
Analysis
processorAnalysis
const
GrDstProxyView
*
dstProxyView
const
GrAppliedClip
*
appliedClip
const
GrCaps
&
caps
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
auditTrail
)
{
const
GrDstProxyView
noDstProxyView
;
if
(
!
dstProxyView
)
{
dstProxyView
=
&
noDstProxyView
;
}
SkASSERT
(
op
-
>
isChainHead
(
)
&
&
op
-
>
isChainTail
(
)
)
;
SkRect
opBounds
=
op
-
>
bounds
(
)
;
List
chain
(
std
:
:
move
(
op
)
)
;
if
(
!
this
-
>
tryConcat
(
&
chain
processorAnalysis
*
dstProxyView
appliedClip
opBounds
caps
opsTaskArena
auditTrail
)
)
{
this
-
>
validate
(
)
;
return
chain
.
popHead
(
)
;
}
SkASSERT
(
chain
.
empty
(
)
)
;
this
-
>
validate
(
)
;
return
nullptr
;
}
inline
void
OpsTask
:
:
OpChain
:
:
validate
(
)
const
{
#
ifdef
SK_DEBUG
fList
.
validate
(
)
;
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fList
.
head
(
)
)
)
{
SkASSERT
(
fBounds
.
fLeft
<
=
op
.
bounds
(
)
.
fLeft
&
&
fBounds
.
fTop
<
=
op
.
bounds
(
)
.
fTop
&
&
fBounds
.
fRight
>
=
op
.
bounds
(
)
.
fRight
&
&
fBounds
.
fBottom
>
=
op
.
bounds
(
)
.
fBottom
)
;
}
#
endif
}
OpsTask
:
:
OpsTask
(
GrDrawingManager
*
drawingMgr
GrSurfaceProxyView
view
GrAuditTrail
*
auditTrail
sk_sp
<
GrArenas
>
arenas
)
:
GrRenderTask
(
)
fAuditTrail
(
auditTrail
)
fUsesMSAASurface
(
view
.
asRenderTargetProxy
(
)
-
>
numSamples
(
)
>
1
)
fTargetSwizzle
(
view
.
swizzle
(
)
)
fTargetOrigin
(
view
.
origin
(
)
)
fArenas
{
std
:
:
move
(
arenas
)
}
SkDEBUGCODE
(
fNumClips
(
0
)
)
{
this
-
>
addTarget
(
drawingMgr
view
.
detachProxy
(
)
)
;
}
void
OpsTask
:
:
deleteOps
(
)
{
for
(
auto
&
chain
:
fOpChains
)
{
chain
.
deleteOps
(
)
;
}
fOpChains
.
clear
(
)
;
}
OpsTask
:
:
~
OpsTask
(
)
{
this
-
>
deleteOps
(
)
;
}
void
OpsTask
:
:
addOp
(
GrDrawingManager
*
drawingMgr
GrOp
:
:
Owner
op
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
&
]
(
GrSurfaceProxy
*
p
GrMipmapped
mipmapped
)
{
this
-
>
addDependency
(
drawingMgr
p
mipmapped
textureResolveManager
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
this
-
>
recordOp
(
std
:
:
move
(
op
)
false
GrProcessorSet
:
:
EmptySetAnalysis
(
)
nullptr
nullptr
caps
)
;
}
void
OpsTask
:
:
addDrawOp
(
GrDrawingManager
*
drawingMgr
GrOp
:
:
Owner
op
bool
usesMSAA
const
GrProcessorSet
:
:
Analysis
&
processorAnalysis
GrAppliedClip
&
&
clip
const
GrDstProxyView
&
dstProxyView
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
&
]
(
GrSurfaceProxy
*
p
GrMipmapped
mipmapped
)
{
this
-
>
addSampledTexture
(
p
)
;
this
-
>
addDependency
(
drawingMgr
p
mipmapped
textureResolveManager
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
clip
.
visitProxies
(
addDependency
)
;
if
(
dstProxyView
.
proxy
(
)
)
{
if
(
!
(
dstProxyView
.
dstSampleFlags
(
)
&
GrDstSampleFlags
:
:
kAsInputAttachment
)
)
{
this
-
>
addSampledTexture
(
dstProxyView
.
proxy
(
)
)
;
}
if
(
dstProxyView
.
dstSampleFlags
(
)
&
GrDstSampleFlags
:
:
kRequiresTextureBarrier
)
{
fRenderPassXferBarriers
|
=
GrXferBarrierFlags
:
:
kTexture
;
}
addDependency
(
dstProxyView
.
proxy
(
)
GrMipmapped
:
:
kNo
)
;
SkASSERT
(
!
(
dstProxyView
.
dstSampleFlags
(
)
&
GrDstSampleFlags
:
:
kAsInputAttachment
)
|
|
dstProxyView
.
offset
(
)
.
isZero
(
)
)
;
}
if
(
processorAnalysis
.
usesNonCoherentHWBlending
(
)
)
{
fRenderPassXferBarriers
|
=
GrXferBarrierFlags
:
:
kBlend
;
}
this
-
>
recordOp
(
std
:
:
move
(
op
)
usesMSAA
processorAnalysis
clip
.
doesClip
(
)
?
&
clip
:
nullptr
&
dstProxyView
caps
)
;
}
void
OpsTask
:
:
endFlush
(
GrDrawingManager
*
drawingMgr
)
{
fLastClipStackGenID
=
SK_InvalidUniqueID
;
this
-
>
deleteOps
(
)
;
fDeferredProxies
.
clear
(
)
;
fSampledProxies
.
clear
(
)
;
fAuditTrail
=
nullptr
;
GrRenderTask
:
:
endFlush
(
drawingMgr
)
;
}
void
OpsTask
:
:
onPrePrepare
(
GrRecordingContext
*
context
)
{
SkASSERT
(
this
-
>
isClosed
(
)
)
;
if
(
this
-
>
isColorNoOp
(
)
|
|
(
fClippedContentBounds
.
isEmpty
(
)
&
&
fColorLoadOp
!
=
GrLoadOp
:
:
kDiscard
)
)
{
return
;
}
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
GrSurfaceProxyView
dstView
(
sk_ref_sp
(
this
-
>
target
(
0
)
)
fTargetOrigin
fTargetSwizzle
)
;
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
chain
.
shouldExecute
(
)
)
{
chain
.
head
(
)
-
>
prePrepare
(
context
dstView
chain
.
appliedClip
(
)
chain
.
dstProxyView
(
)
fRenderPassXferBarriers
fColorLoadOp
)
;
}
}
}
void
OpsTask
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
SkASSERT
(
this
-
>
target
(
0
)
-
>
peekRenderTarget
(
)
)
;
SkASSERT
(
this
-
>
isClosed
(
)
)
;
if
(
this
-
>
isColorNoOp
(
)
|
|
(
fClippedContentBounds
.
isEmpty
(
)
&
&
fColorLoadOp
!
=
GrLoadOp
:
:
kDiscard
)
)
{
return
;
}
TRACE_EVENT0_ALWAYS
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
flushState
-
>
setSampledProxyArray
(
&
fSampledProxies
)
;
GrSurfaceProxyView
dstView
(
sk_ref_sp
(
this
-
>
target
(
0
)
)
fTargetOrigin
fTargetSwizzle
)
;
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
chain
.
shouldExecute
(
)
)
{
GrOpFlushState
:
:
OpArgs
opArgs
(
chain
.
head
(
)
dstView
fUsesMSAASurface
chain
.
appliedClip
(
)
chain
.
dstProxyView
(
)
fRenderPassXferBarriers
fColorLoadOp
)
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
chain
.
head
(
)
-
>
prepare
(
flushState
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
}
flushState
-
>
setSampledProxyArray
(
nullptr
)
;
}
bool
OpsTask
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
SkASSERT
(
this
-
>
numTargets
(
)
=
=
1
)
;
GrRenderTargetProxy
*
proxy
=
this
-
>
target
(
0
)
-
>
asRenderTargetProxy
(
)
;
SkASSERT
(
proxy
)
;
SK_AT_SCOPE_EXIT
(
proxy
-
>
clearArenas
(
)
)
;
if
(
this
-
>
isColorNoOp
(
)
|
|
fClippedContentBounds
.
isEmpty
(
)
)
{
return
false
;
}
TRACE_EVENT0_ALWAYS
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
SkASSERT
(
fColorLoadOp
!
=
GrLoadOp
:
:
kClear
|
|
!
flushState
-
>
gpu
(
)
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
;
const
GrCaps
&
caps
=
*
flushState
-
>
gpu
(
)
-
>
caps
(
)
;
GrRenderTarget
*
renderTarget
=
proxy
-
>
peekRenderTarget
(
)
;
SkASSERT
(
renderTarget
)
;
GrAttachment
*
stencil
=
nullptr
;
if
(
proxy
-
>
needsStencil
(
)
)
{
SkASSERT
(
proxy
-
>
canUseStencil
(
caps
)
)
;
if
(
!
flushState
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
renderTarget
fUsesMSAASurface
)
)
{
SkDebugf
(
"
WARNING
:
failed
to
attach
a
stencil
buffer
.
Rendering
will
be
skipped
.
\
n
"
)
;
return
false
;
}
stencil
=
renderTarget
-
>
getStencilAttachment
(
fUsesMSAASurface
)
;
}
GrLoadOp
stencilLoadOp
;
switch
(
fInitialStencilContent
)
{
case
StencilContent
:
:
kDontCare
:
stencilLoadOp
=
GrLoadOp
:
:
kDiscard
;
break
;
case
StencilContent
:
:
kUserBitsCleared
:
SkASSERT
(
!
caps
.
performStencilClearsAsDraws
(
)
)
;
SkASSERT
(
stencil
)
;
if
(
caps
.
discardStencilValuesAfterRenderPass
(
)
)
{
stencilLoadOp
=
GrLoadOp
:
:
kClear
;
break
;
}
if
(
!
stencil
-
>
hasPerformedInitialClear
(
)
)
{
stencilLoadOp
=
GrLoadOp
:
:
kClear
;
stencil
-
>
markHasPerformedInitialClear
(
)
;
break
;
}
[
[
fallthrough
]
]
;
case
StencilContent
:
:
kPreserved
:
SkASSERT
(
stencil
)
;
stencilLoadOp
=
GrLoadOp
:
:
kLoad
;
break
;
}
GrStoreOp
stencilStoreOp
=
(
caps
.
discardStencilValuesAfterRenderPass
(
)
&
&
!
fMustPreserveStencil
)
?
GrStoreOp
:
:
kDiscard
:
GrStoreOp
:
:
kStore
;
GrOpsRenderPass
*
renderPass
=
create_render_pass
(
flushState
-
>
gpu
(
)
proxy
-
>
peekRenderTarget
(
)
fUsesMSAASurface
stencil
fTargetOrigin
fClippedContentBounds
fColorLoadOp
fLoadClearColor
stencilLoadOp
stencilStoreOp
fSampledProxies
fRenderPassXferBarriers
)
;
if
(
!
renderPass
)
{
return
false
;
}
flushState
-
>
setOpsRenderPass
(
renderPass
)
;
renderPass
-
>
begin
(
)
;
GrSurfaceProxyView
dstView
(
sk_ref_sp
(
this
-
>
target
(
0
)
)
fTargetOrigin
fTargetSwizzle
)
;
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
!
chain
.
shouldExecute
(
)
)
{
continue
;
}
GrOpFlushState
:
:
OpArgs
opArgs
(
chain
.
head
(
)
dstView
fUsesMSAASurface
chain
.
appliedClip
(
)
chain
.
dstProxyView
(
)
fRenderPassXferBarriers
fColorLoadOp
)
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
chain
.
head
(
)
-
>
execute
(
flushState
chain
.
bounds
(
)
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
renderPass
-
>
end
(
)
;
flushState
-
>
gpu
(
)
-
>
submit
(
renderPass
)
;
flushState
-
>
setOpsRenderPass
(
nullptr
)
;
return
true
;
}
void
OpsTask
:
:
setColorLoadOp
(
GrLoadOp
op
std
:
:
array
<
float
4
>
color
)
{
fColorLoadOp
=
op
;
fLoadClearColor
=
color
;
if
(
GrLoadOp
:
:
kClear
=
=
fColorLoadOp
)
{
GrSurfaceProxy
*
proxy
=
this
-
>
target
(
0
)
;
SkASSERT
(
proxy
)
;
fTotalBounds
=
proxy
-
>
backingStoreBoundsRect
(
)
;
}
}
void
OpsTask
:
:
reset
(
)
{
fDeferredProxies
.
clear
(
)
;
fSampledProxies
.
clear
(
)
;
fClippedContentBounds
=
SkIRect
:
:
MakeEmpty
(
)
;
fTotalBounds
=
SkRect
:
:
MakeEmpty
(
)
;
this
-
>
deleteOps
(
)
;
fRenderPassXferBarriers
=
GrXferBarrierFlags
:
:
kNone
;
}
bool
OpsTask
:
:
canMerge
(
const
OpsTask
*
opsTask
)
const
{
return
this
-
>
target
(
0
)
=
=
opsTask
-
>
target
(
0
)
&
&
fArenas
=
=
opsTask
-
>
fArenas
&
&
!
opsTask
-
>
fCannotMergeBackward
;
}
int
OpsTask
:
:
mergeFrom
(
SkSpan
<
const
sk_sp
<
GrRenderTask
>
>
tasks
)
{
int
mergedCount
=
0
;
for
(
const
sk_sp
<
GrRenderTask
>
&
task
:
tasks
)
{
auto
opsTask
=
task
-
>
asOpsTask
(
)
;
if
(
!
opsTask
|
|
!
this
-
>
canMerge
(
opsTask
)
)
{
break
;
}
SkASSERT
(
fTargetSwizzle
=
=
opsTask
-
>
fTargetSwizzle
)
;
SkASSERT
(
fTargetOrigin
=
=
opsTask
-
>
fTargetOrigin
)
;
if
(
GrLoadOp
:
:
kClear
=
=
opsTask
-
>
fColorLoadOp
)
{
return
0
;
}
mergedCount
+
=
1
;
}
if
(
0
=
=
mergedCount
)
{
return
0
;
}
SkSpan
<
const
sk_sp
<
OpsTask
>
>
mergingNodes
(
reinterpret_cast
<
const
sk_sp
<
OpsTask
>
*
>
(
tasks
.
data
(
)
)
SkToSizeT
(
mergedCount
)
)
;
int
addlDeferredProxyCount
=
0
;
int
addlProxyCount
=
0
;
int
addlOpChainCount
=
0
;
for
(
const
auto
&
toMerge
:
mergingNodes
)
{
addlDeferredProxyCount
+
=
toMerge
-
>
fDeferredProxies
.
size
(
)
;
addlProxyCount
+
=
toMerge
-
>
fSampledProxies
.
size
(
)
;
addlOpChainCount
+
=
toMerge
-
>
fOpChains
.
size
(
)
;
fClippedContentBounds
.
join
(
toMerge
-
>
fClippedContentBounds
)
;
fTotalBounds
.
join
(
toMerge
-
>
fTotalBounds
)
;
fRenderPassXferBarriers
|
=
toMerge
-
>
fRenderPassXferBarriers
;
if
(
fInitialStencilContent
=
=
StencilContent
:
:
kDontCare
)
{
fInitialStencilContent
=
toMerge
-
>
fInitialStencilContent
;
}
fUsesMSAASurface
|
=
toMerge
-
>
fUsesMSAASurface
;
SkDEBUGCODE
(
fNumClips
+
=
toMerge
-
>
fNumClips
)
;
}
fLastClipStackGenID
=
SK_InvalidUniqueID
;
fDeferredProxies
.
reserve_back
(
addlDeferredProxyCount
)
;
fSampledProxies
.
reserve_back
(
addlProxyCount
)
;
fOpChains
.
reserve_back
(
addlOpChainCount
)
;
for
(
const
auto
&
toMerge
:
mergingNodes
)
{
for
(
GrRenderTask
*
renderTask
:
toMerge
-
>
dependents
(
)
)
{
renderTask
-
>
replaceDependency
(
toMerge
.
get
(
)
this
)
;
}
for
(
GrRenderTask
*
renderTask
:
toMerge
-
>
dependencies
(
)
)
{
renderTask
-
>
replaceDependent
(
toMerge
.
get
(
)
this
)
;
}
fDeferredProxies
.
move_back_n
(
toMerge
-
>
fDeferredProxies
.
size
(
)
toMerge
-
>
fDeferredProxies
.
data
(
)
)
;
fSampledProxies
.
move_back_n
(
toMerge
-
>
fSampledProxies
.
size
(
)
toMerge
-
>
fSampledProxies
.
data
(
)
)
;
fOpChains
.
move_back_n
(
toMerge
-
>
fOpChains
.
size
(
)
toMerge
-
>
fOpChains
.
data
(
)
)
;
toMerge
-
>
fDeferredProxies
.
clear
(
)
;
toMerge
-
>
fSampledProxies
.
clear
(
)
;
toMerge
-
>
fOpChains
.
clear
(
)
;
}
fMustPreserveStencil
=
mergingNodes
.
back
(
)
-
>
fMustPreserveStencil
;
return
mergedCount
;
}
bool
OpsTask
:
:
resetForFullscreenClear
(
CanDiscardPreviousOps
canDiscardPreviousOps
)
{
if
(
CanDiscardPreviousOps
:
:
kYes
=
=
canDiscardPreviousOps
|
|
this
-
>
isEmpty
(
)
)
{
this
-
>
deleteOps
(
)
;
fDeferredProxies
.
clear
(
)
;
fSampledProxies
.
clear
(
)
;
return
!
this
-
>
target
(
0
)
-
>
asRenderTargetProxy
(
)
-
>
wrapsVkSecondaryCB
(
)
;
}
return
false
;
}
void
OpsTask
:
:
discard
(
)
{
if
(
this
-
>
isEmpty
(
)
)
{
fColorLoadOp
=
GrLoadOp
:
:
kDiscard
;
fInitialStencilContent
=
StencilContent
:
:
kDontCare
;
fTotalBounds
.
setEmpty
(
)
;
}
}
#
if
GR_TEST_UTILS
void
OpsTask
:
:
dump
(
const
SkString
&
label
SkString
indent
bool
printDependencies
bool
close
)
const
{
GrRenderTask
:
:
dump
(
label
indent
printDependencies
false
)
;
SkDebugf
(
"
%
sfColorLoadOp
:
"
indent
.
c_str
(
)
)
;
switch
(
fColorLoadOp
)
{
case
GrLoadOp
:
:
kLoad
:
SkDebugf
(
"
kLoad
\
n
"
)
;
break
;
case
GrLoadOp
:
:
kClear
:
SkDebugf
(
"
kClear
{
%
g
%
g
%
g
%
g
}
\
n
"
fLoadClearColor
[
0
]
fLoadClearColor
[
1
]
fLoadClearColor
[
2
]
fLoadClearColor
[
3
]
)
;
break
;
case
GrLoadOp
:
:
kDiscard
:
SkDebugf
(
"
kDiscard
\
n
"
)
;
break
;
}
SkDebugf
(
"
%
sfInitialStencilContent
:
"
indent
.
c_str
(
)
)
;
switch
(
fInitialStencilContent
)
{
case
StencilContent
:
:
kDontCare
:
SkDebugf
(
"
kDontCare
\
n
"
)
;
break
;
case
StencilContent
:
:
kUserBitsCleared
:
SkDebugf
(
"
kUserBitsCleared
\
n
"
)
;
break
;
case
StencilContent
:
:
kPreserved
:
SkDebugf
(
"
kPreserved
\
n
"
)
;
break
;
}
SkDebugf
(
"
%
s
%
d
ops
:
\
n
"
indent
.
c_str
(
)
fOpChains
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpChains
.
size
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
s
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
indent
.
c_str
(
)
)
;
if
(
!
fOpChains
[
i
]
.
head
(
)
)
{
SkDebugf
(
"
%
s
%
d
:
<
combined
forward
or
failed
instantiation
>
\
n
"
indent
.
c_str
(
)
i
)
;
}
else
{
SkDebugf
(
"
%
s
%
d
:
%
s
\
n
"
indent
.
c_str
(
)
i
fOpChains
[
i
]
.
head
(
)
-
>
name
(
)
)
;
SkRect
bounds
=
fOpChains
[
i
]
.
bounds
(
)
;
SkDebugf
(
"
%
sClippedBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
indent
.
c_str
(
)
bounds
.
fLeft
bounds
.
fTop
bounds
.
fRight
bounds
.
fBottom
)
;
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fOpChains
[
i
]
.
head
(
)
)
)
{
SkString
info
=
SkTabString
(
op
.
dumpInfo
(
)
1
)
;
SkDebugf
(
"
%
s
%
s
\
n
"
indent
.
c_str
(
)
info
.
c_str
(
)
)
;
bounds
=
op
.
bounds
(
)
;
SkDebugf
(
"
%
s
\
tClippedBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
indent
.
c_str
(
)
bounds
.
fLeft
bounds
.
fTop
bounds
.
fRight
bounds
.
fBottom
)
;
}
}
}
if
(
close
)
{
SkDebugf
(
"
%
s
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
\
n
"
indent
.
c_str
(
)
)
;
}
}
#
endif
#
ifdef
SK_DEBUG
void
OpsTask
:
:
visitProxies_debugOnly
(
const
GrVisitProxyFunc
&
func
)
const
{
auto
textureFunc
=
[
func
]
(
GrSurfaceProxy
*
tex
GrMipmapped
mipmapped
)
{
func
(
tex
mipmapped
)
;
}
;
for
(
const
OpChain
&
chain
:
fOpChains
)
{
chain
.
visitProxies
(
textureFunc
)
;
}
}
#
endif
void
OpsTask
:
:
onMakeSkippable
(
)
{
this
-
>
deleteOps
(
)
;
fDeferredProxies
.
clear
(
)
;
fColorLoadOp
=
GrLoadOp
:
:
kLoad
;
SkASSERT
(
this
-
>
isColorNoOp
(
)
)
;
}
bool
OpsTask
:
:
onIsUsed
(
GrSurfaceProxy
*
proxyToCheck
)
const
{
bool
used
=
false
;
for
(
GrSurfaceProxy
*
proxy
:
fSampledProxies
)
{
if
(
proxy
=
=
proxyToCheck
)
{
used
=
true
;
break
;
}
}
#
ifdef
SK_DEBUG
bool
usedSlow
=
false
;
auto
visit
=
[
proxyToCheck
&
usedSlow
]
(
GrSurfaceProxy
*
p
GrMipmapped
)
{
if
(
p
=
=
proxyToCheck
)
{
usedSlow
=
true
;
}
}
;
this
-
>
visitProxies_debugOnly
(
visit
)
;
SkASSERT
(
used
=
=
usedSlow
)
;
#
endif
return
used
;
}
void
OpsTask
:
:
gatherProxyIntervals
(
GrResourceAllocator
*
alloc
)
const
{
SkASSERT
(
this
-
>
isClosed
(
)
)
;
if
(
this
-
>
isColorNoOp
(
)
)
{
return
;
}
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
size
(
)
;
+
+
i
)
{
SkASSERT
(
!
fDeferredProxies
[
i
]
-
>
isInstantiated
(
)
)
;
alloc
-
>
addInterval
(
fDeferredProxies
[
i
]
0
0
GrResourceAllocator
:
:
ActualUse
:
:
kNo
)
;
}
GrSurfaceProxy
*
targetProxy
=
this
-
>
target
(
0
)
;
if
(
fOpChains
.
size
(
)
)
{
unsigned
int
cur
=
alloc
-
>
curOp
(
)
;
alloc
-
>
addInterval
(
targetProxy
cur
cur
+
fOpChains
.
size
(
)
-
1
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
}
else
{
alloc
-
>
addInterval
(
targetProxy
alloc
-
>
curOp
(
)
alloc
-
>
curOp
(
)
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
alloc
-
>
incOps
(
)
;
}
auto
gather
=
[
alloc
SkDEBUGCODE
(
this
)
]
(
GrSurfaceProxy
*
p
GrMipmapped
)
{
alloc
-
>
addInterval
(
p
alloc
-
>
curOp
(
)
alloc
-
>
curOp
(
)
GrResourceAllocator
:
:
ActualUse
:
:
kYes
SkDEBUGCODE
(
this
-
>
target
(
0
)
=
=
p
)
)
;
}
;
for
(
const
OpChain
&
recordedOp
:
fOpChains
)
{
recordedOp
.
visitProxies
(
gather
)
;
alloc
-
>
incOps
(
)
;
}
}
void
OpsTask
:
:
recordOp
(
GrOp
:
:
Owner
op
bool
usesMSAA
GrProcessorSet
:
:
Analysis
processorAnalysis
GrAppliedClip
*
clip
const
GrDstProxyView
*
dstProxyView
const
GrCaps
&
caps
)
{
GrSurfaceProxy
*
proxy
=
this
-
>
target
(
0
)
;
#
ifdef
SK_DEBUG
op
-
>
validate
(
)
;
SkASSERT
(
processorAnalysis
.
requiresDstTexture
(
)
=
=
(
dstProxyView
&
&
dstProxyView
-
>
proxy
(
)
)
)
;
SkASSERT
(
proxy
)
;
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
if
(
proxy
-
>
asRenderTargetProxy
(
)
-
>
numSamples
(
)
=
=
1
&
&
usesMSAA
)
{
SkASSERT
(
caps
.
supportsDynamicMSAA
(
proxy
-
>
asRenderTargetProxy
(
)
)
)
;
}
#
endif
if
(
!
op
-
>
bounds
(
)
.
isFinite
(
)
)
{
return
;
}
fUsesMSAASurface
|
=
usesMSAA
;
fTotalBounds
.
join
(
op
-
>
bounds
(
)
)
;
GR_AUDIT_TRAIL_ADD_OP
(
fAuditTrail
op
.
get
(
)
proxy
-
>
uniqueID
(
)
)
;
GrOP_INFO
(
"
opsTask
:
%
d
Recording
(
%
s
opID
:
%
u
)
\
n
"
"
\
tBounds
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
this
-
>
uniqueID
(
)
op
-
>
name
(
)
op
-
>
uniqueID
(
)
op
-
>
bounds
(
)
.
fLeft
op
-
>
bounds
(
)
.
fTop
op
-
>
bounds
(
)
.
fRight
op
-
>
bounds
(
)
.
fBottom
)
;
GrOP_INFO
(
SkTabString
(
op
-
>
dumpInfo
(
)
1
)
.
c_str
(
)
)
;
GrOP_INFO
(
"
\
tOutcome
:
\
n
"
)
;
int
maxCandidates
=
std
:
:
min
(
kMaxOpChainDistance
fOpChains
.
size
(
)
)
;
if
(
maxCandidates
)
{
int
i
=
0
;
while
(
true
)
{
OpChain
&
candidate
=
fOpChains
.
fromBack
(
i
)
;
op
=
candidate
.
appendOp
(
std
:
:
move
(
op
)
processorAnalysis
dstProxyView
clip
caps
fArenas
-
>
arenaAlloc
(
)
fAuditTrail
)
;
if
(
!
op
)
{
return
;
}
if
(
!
can_reorder
(
candidate
.
bounds
(
)
op
-
>
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Intersects
with
chain
(
%
s
head
opID
:
%
u
)
\
n
"
candidate
.
head
(
)
-
>
name
(
)
candidate
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
if
(
+
+
i
=
=
maxCandidates
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Reached
max
lookback
or
beginning
of
op
array
%
d
\
n
"
i
)
;
break
;
}
}
}
else
{
GrOP_INFO
(
"
\
t
\
tBackward
:
FirstOp
\
n
"
)
;
}
if
(
clip
)
{
clip
=
fArenas
-
>
arenaAlloc
(
)
-
>
make
<
GrAppliedClip
>
(
std
:
:
move
(
*
clip
)
)
;
SkDEBUGCODE
(
fNumClips
+
+
;
)
}
fOpChains
.
emplace_back
(
std
:
:
move
(
op
)
processorAnalysis
clip
dstProxyView
)
;
}
void
OpsTask
:
:
forwardCombine
(
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrOP_INFO
(
"
opsTask
:
%
d
ForwardCombine
%
d
ops
:
\
n
"
this
-
>
uniqueID
(
)
fOpChains
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpChains
.
size
(
)
-
1
;
+
+
i
)
{
OpChain
&
chain
=
fOpChains
[
i
]
;
int
maxCandidateIdx
=
std
:
:
min
(
i
+
kMaxOpChainDistance
fOpChains
.
size
(
)
-
1
)
;
int
j
=
i
+
1
;
while
(
true
)
{
OpChain
&
candidate
=
fOpChains
[
j
]
;
if
(
candidate
.
prependChain
(
&
chain
caps
fArenas
-
>
arenaAlloc
(
)
fAuditTrail
)
)
{
break
;
}
if
(
!
can_reorder
(
chain
.
bounds
(
)
candidate
.
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
chain
(
%
s
head
opID
:
%
u
)
-
>
"
"
Intersects
with
chain
(
%
s
head
opID
:
%
u
)
\
n
"
i
chain
.
head
(
)
-
>
name
(
)
chain
.
head
(
)
-
>
uniqueID
(
)
candidate
.
head
(
)
-
>
name
(
)
candidate
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
if
(
+
+
j
>
maxCandidateIdx
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
chain
(
%
s
opID
:
%
u
)
-
>
Reached
max
lookahead
or
end
of
array
\
n
"
i
chain
.
head
(
)
-
>
name
(
)
chain
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
}
}
}
GrRenderTask
:
:
ExpectedOutcome
OpsTask
:
:
onMakeClosed
(
GrRecordingContext
*
rContext
SkIRect
*
targetUpdateBounds
)
{
this
-
>
forwardCombine
(
*
rContext
-
>
priv
(
)
.
caps
(
)
)
;
if
(
!
this
-
>
isColorNoOp
(
)
)
{
GrSurfaceProxy
*
proxy
=
this
-
>
target
(
0
)
;
SkRect
clippedContentBounds
=
proxy
-
>
backingStoreBoundsRect
(
)
;
if
(
clippedContentBounds
.
intersect
(
fTotalBounds
)
)
{
clippedContentBounds
.
roundOut
(
&
fClippedContentBounds
)
;
*
targetUpdateBounds
=
GrNativeRect
:
:
MakeIRectRelativeTo
(
fTargetOrigin
this
-
>
target
(
0
)
-
>
backingStoreDimensions
(
)
.
height
(
)
fClippedContentBounds
)
;
return
ExpectedOutcome
:
:
kTargetDirty
;
}
}
return
ExpectedOutcome
:
:
kTargetUnchanged
;
}
}
