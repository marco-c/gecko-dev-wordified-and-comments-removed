#
ifndef
SmallPathShapeData_DEFINED
#
define
SmallPathShapeData_DEFINED
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDrawOpAtlas
.
h
"
class
GrStyledShape
;
namespace
skgpu
:
:
ganesh
{
class
SmallPathShapeDataKey
{
public
:
SmallPathShapeDataKey
(
const
SmallPathShapeDataKey
&
that
)
{
fKey
.
reset
(
that
.
fKey
.
count
(
)
)
;
memcpy
(
fKey
.
get
(
)
that
.
fKey
.
get
(
)
fKey
.
count
(
)
*
sizeof
(
uint32_t
)
)
;
}
SmallPathShapeDataKey
&
operator
=
(
const
SmallPathShapeDataKey
&
)
=
delete
;
SmallPathShapeDataKey
(
const
GrStyledShape
&
uint32_t
dim
)
;
SmallPathShapeDataKey
(
const
GrStyledShape
&
const
SkMatrix
&
ctm
)
;
bool
operator
=
=
(
const
SmallPathShapeDataKey
&
that
)
const
{
return
fKey
.
count
(
)
=
=
that
.
fKey
.
count
(
)
&
&
0
=
=
memcmp
(
fKey
.
get
(
)
that
.
fKey
.
get
(
)
sizeof
(
uint32_t
)
*
fKey
.
count
(
)
)
;
}
int
count32
(
)
const
{
return
fKey
.
count
(
)
;
}
const
uint32_t
*
data
(
)
const
{
return
fKey
.
get
(
)
;
}
private
:
skia_private
:
:
AutoSTArray
<
24
uint32_t
>
fKey
;
}
;
class
SmallPathShapeData
{
public
:
SmallPathShapeData
(
const
SmallPathShapeDataKey
&
key
)
:
fKey
(
key
)
{
}
const
SmallPathShapeDataKey
fKey
;
SkRect
fBounds
;
skgpu
:
:
AtlasLocator
fAtlasLocator
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
SmallPathShapeData
)
;
static
inline
const
SmallPathShapeDataKey
&
GetKey
(
const
SmallPathShapeData
&
data
)
{
return
data
.
fKey
;
}
static
inline
uint32_t
Hash
(
const
SmallPathShapeDataKey
&
key
)
{
return
SkOpts
:
:
hash
(
key
.
data
(
)
sizeof
(
uint32_t
)
*
key
.
count32
(
)
)
;
}
}
;
}
#
endif
#
endif
