#
ifndef
OpsTask_DEFINED
#
define
OpsTask_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
base
/
SkTLazy
.
h
"
#
include
"
src
/
core
/
SkClipStack
.
h
"
#
include
"
src
/
core
/
SkStringUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDstProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProcessorSet
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTask
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrOp
.
h
"
class
GrAuditTrail
;
class
GrCaps
;
class
GrClearOp
;
class
GrGpuBuffer
;
class
GrRenderTargetProxy
;
class
OpsTaskTestingAccess
;
namespace
skgpu
:
:
ganesh
{
class
SurfaceDrawContext
;
class
OpsTask
:
public
GrRenderTask
{
public
:
OpsTask
(
GrDrawingManager
*
GrSurfaceProxyView
GrAuditTrail
*
sk_sp
<
GrArenas
>
)
;
~
OpsTask
(
)
override
;
OpsTask
*
asOpsTask
(
)
override
{
return
this
;
}
bool
isEmpty
(
)
const
{
return
fOpChains
.
empty
(
)
;
}
bool
usesMSAASurface
(
)
const
{
return
fUsesMSAASurface
;
}
GrXferBarrierFlags
renderPassXferBarriers
(
)
const
{
return
fRenderPassXferBarriers
;
}
void
endFlush
(
GrDrawingManager
*
)
override
;
void
onPrePrepare
(
GrRecordingContext
*
)
override
;
void
onPrepare
(
GrOpFlushState
*
flushState
)
override
;
bool
onExecute
(
GrOpFlushState
*
flushState
)
override
;
void
addSampledTexture
(
GrSurfaceProxy
*
proxy
)
{
SkASSERT
(
proxy
-
>
asTextureProxy
(
)
)
;
fSampledProxies
.
push_back
(
proxy
)
;
}
void
addOp
(
GrDrawingManager
*
GrOp
:
:
Owner
GrTextureResolveManager
const
GrCaps
&
)
;
void
addDrawOp
(
GrDrawingManager
*
GrOp
:
:
Owner
bool
usesMSAA
const
GrProcessorSet
:
:
Analysis
&
GrAppliedClip
&
&
const
GrDstProxyView
&
GrTextureResolveManager
const
GrCaps
&
)
;
void
discard
(
)
;
enum
class
CanDiscardPreviousOps
:
bool
{
kYes
=
true
kNo
=
false
}
;
bool
resetForFullscreenClear
(
CanDiscardPreviousOps
)
;
void
setColorLoadOp
(
GrLoadOp
op
std
:
:
array
<
float
4
>
color
=
{
0
0
0
0
}
)
;
bool
canMerge
(
const
OpsTask
*
)
const
;
int
mergeFrom
(
SkSpan
<
const
sk_sp
<
GrRenderTask
>
>
tasks
)
;
#
ifdef
SK_DEBUG
int
numClips
(
)
const
override
{
return
fNumClips
;
}
void
visitProxies_debugOnly
(
const
GrVisitProxyFunc
&
)
const
override
;
#
endif
#
if
GR_TEST_UTILS
void
dump
(
const
SkString
&
label
SkString
indent
bool
printDependencies
bool
close
)
const
override
;
const
char
*
name
(
)
const
final
{
return
"
Ops
"
;
}
int
numOpChains
(
)
const
{
return
fOpChains
.
size
(
)
;
}
const
GrOp
*
getChain
(
int
index
)
const
{
return
fOpChains
[
index
]
.
head
(
)
;
}
#
endif
protected
:
enum
class
StencilContent
{
kDontCare
kUserBitsCleared
kPreserved
}
;
void
setInitialStencilContent
(
StencilContent
initialContent
)
{
fInitialStencilContent
=
initialContent
;
}
void
recordOp
(
GrOp
:
:
Owner
bool
usesMSAA
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
GrDstProxyView
*
const
GrCaps
&
)
;
ExpectedOutcome
onMakeClosed
(
GrRecordingContext
*
SkIRect
*
targetUpdateBounds
)
override
;
private
:
bool
isColorNoOp
(
)
const
{
return
fOpChains
.
empty
(
)
&
&
GrLoadOp
:
:
kLoad
=
=
fColorLoadOp
;
}
void
deleteOps
(
)
;
void
setMustPreserveStencil
(
)
{
fMustPreserveStencil
=
true
;
}
void
setCannotMergeBackward
(
)
{
fCannotMergeBackward
=
true
;
}
class
OpChain
{
public
:
OpChain
(
GrOp
:
:
Owner
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
GrDstProxyView
*
)
;
~
OpChain
(
)
{
SkASSERT
(
fList
.
empty
(
)
)
;
}
OpChain
(
const
OpChain
&
)
=
delete
;
OpChain
&
operator
=
(
const
OpChain
&
)
=
delete
;
OpChain
(
OpChain
&
&
)
=
default
;
OpChain
&
operator
=
(
OpChain
&
&
)
=
default
;
void
visitProxies
(
const
GrVisitProxyFunc
&
)
const
;
GrOp
*
head
(
)
const
{
return
fList
.
head
(
)
;
}
GrAppliedClip
*
appliedClip
(
)
const
{
return
fAppliedClip
;
}
const
GrDstProxyView
&
dstProxyView
(
)
const
{
return
fDstProxyView
;
}
const
SkRect
&
bounds
(
)
const
{
return
fBounds
;
}
void
deleteOps
(
)
;
bool
prependChain
(
OpChain
*
const
GrCaps
&
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
)
;
GrOp
:
:
Owner
appendOp
(
GrOp
:
:
Owner
op
GrProcessorSet
:
:
Analysis
const
GrDstProxyView
*
const
GrAppliedClip
*
const
GrCaps
&
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
)
;
bool
shouldExecute
(
)
const
{
return
SkToBool
(
this
-
>
head
(
)
)
;
}
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
private
:
class
List
{
public
:
List
(
)
=
default
;
List
(
GrOp
:
:
Owner
)
;
List
(
List
&
&
)
;
List
&
operator
=
(
List
&
&
that
)
;
bool
empty
(
)
const
{
return
!
SkToBool
(
fHead
)
;
}
GrOp
*
head
(
)
const
{
return
fHead
.
get
(
)
;
}
GrOp
*
tail
(
)
const
{
return
fTail
;
}
GrOp
:
:
Owner
popHead
(
)
;
GrOp
:
:
Owner
removeOp
(
GrOp
*
op
)
;
void
pushHead
(
GrOp
:
:
Owner
op
)
;
void
pushTail
(
GrOp
:
:
Owner
)
;
void
validate
(
)
const
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
private
:
GrOp
:
:
Owner
fHead
{
nullptr
}
;
GrOp
*
fTail
{
nullptr
}
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fHead
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fTail
)
>
:
:
value
)
;
}
;
void
validate
(
)
const
;
bool
tryConcat
(
List
*
GrProcessorSet
:
:
Analysis
const
GrDstProxyView
&
const
GrAppliedClip
*
const
SkRect
&
bounds
const
GrCaps
&
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
)
;
static
List
DoConcat
(
List
List
const
GrCaps
&
SkArenaAlloc
*
opsTaskArena
GrAuditTrail
*
)
;
List
fList
;
GrProcessorSet
:
:
Analysis
fProcessorAnalysis
;
GrDstProxyView
fDstProxyView
;
GrAppliedClip
*
fAppliedClip
;
SkRect
fBounds
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fProcessorAnalysis
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fDstProxyView
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fAppliedClip
)
>
:
:
value
)
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fBounds
)
>
:
:
value
)
;
}
;
void
onMakeSkippable
(
)
override
;
bool
onIsUsed
(
GrSurfaceProxy
*
)
const
override
;
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
override
;
void
forwardCombine
(
const
GrCaps
&
)
;
void
reset
(
)
;
friend
class
:
:
OpsTaskTestingAccess
;
friend
class
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
;
GrAuditTrail
*
fAuditTrail
;
bool
fUsesMSAASurface
;
skgpu
:
:
Swizzle
fTargetSwizzle
;
GrSurfaceOrigin
fTargetOrigin
;
GrLoadOp
fColorLoadOp
=
GrLoadOp
:
:
kLoad
;
std
:
:
array
<
float
4
>
fLoadClearColor
=
{
0
0
0
0
}
;
StencilContent
fInitialStencilContent
=
StencilContent
:
:
kDontCare
;
bool
fMustPreserveStencil
=
false
;
bool
fCannotMergeBackward
=
false
;
uint32_t
fLastClipStackGenID
=
SK_InvalidUniqueID
;
SkIRect
fLastDevClipBounds
;
int
fLastClipNumAnalyticElements
;
GrXferBarrierFlags
fRenderPassXferBarriers
=
GrXferBarrierFlags
:
:
kNone
;
SkSTArray
<
25
OpChain
>
fOpChains
;
sk_sp
<
GrArenas
>
fArenas
;
SkDEBUGCODE
(
int
fNumClips
;
)
SkTArray
<
GrSurfaceProxy
*
true
>
fSampledProxies
;
SkRect
fTotalBounds
=
SkRect
:
:
MakeEmpty
(
)
;
SkIRect
fClippedContentBounds
=
SkIRect
:
:
MakeEmpty
(
)
;
}
;
}
#
endif
