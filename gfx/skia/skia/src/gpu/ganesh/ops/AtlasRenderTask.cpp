#
include
"
src
/
gpu
/
ganesh
/
ops
/
AtlasRenderTask
.
h
"
#
include
"
src
/
core
/
SkBlendModePriv
.
h
"
#
include
"
src
/
core
/
SkIPoint16
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrNativeRect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpsTypes
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
FillRectOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
PathStencilCoverOp
.
h
"
namespace
skgpu
:
:
ganesh
{
AtlasRenderTask
:
:
AtlasRenderTask
(
GrRecordingContext
*
rContext
sk_sp
<
GrArenas
>
arenas
std
:
:
unique_ptr
<
GrDynamicAtlas
>
dynamicAtlas
)
:
OpsTask
(
rContext
-
>
priv
(
)
.
drawingManager
(
)
dynamicAtlas
-
>
writeView
(
*
rContext
-
>
priv
(
)
.
caps
(
)
)
rContext
-
>
priv
(
)
.
auditTrail
(
)
std
:
:
move
(
arenas
)
)
fDynamicAtlas
(
std
:
:
move
(
dynamicAtlas
)
)
{
}
bool
AtlasRenderTask
:
:
addPath
(
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
SkIPoint
pathDevTopLeft
int
widthInAtlas
int
heightInAtlas
bool
transposedInAtlas
SkIPoint16
*
locationInAtlas
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
SkASSERT
(
this
-
>
isEmpty
(
)
)
;
SkASSERT
(
!
fDynamicAtlas
-
>
isInstantiated
(
)
)
;
if
(
!
fDynamicAtlas
-
>
addRect
(
widthInAtlas
heightInAtlas
locationInAtlas
)
)
{
return
false
;
}
SkMatrix
pathToAtlasMatrix
=
viewMatrix
;
if
(
transposedInAtlas
)
{
std
:
:
swap
(
pathToAtlasMatrix
[
0
]
pathToAtlasMatrix
[
3
]
)
;
std
:
:
swap
(
pathToAtlasMatrix
[
1
]
pathToAtlasMatrix
[
4
]
)
;
float
tx
=
pathToAtlasMatrix
.
getTranslateX
(
)
ty
=
pathToAtlasMatrix
.
getTranslateY
(
)
;
pathToAtlasMatrix
.
setTranslateX
(
ty
-
pathDevTopLeft
.
y
(
)
+
locationInAtlas
-
>
x
(
)
)
;
pathToAtlasMatrix
.
setTranslateY
(
tx
-
pathDevTopLeft
.
x
(
)
+
locationInAtlas
-
>
y
(
)
)
;
}
else
{
pathToAtlasMatrix
.
postTranslate
(
locationInAtlas
-
>
x
(
)
-
pathDevTopLeft
.
x
(
)
locationInAtlas
-
>
y
(
)
-
pathDevTopLeft
.
y
(
)
)
;
}
if
(
GrFillRuleForSkPath
(
path
)
=
=
GrFillRule
:
:
kNonzero
)
{
fWindingPathList
.
add
(
&
fPathDrawAllocator
pathToAtlasMatrix
path
)
;
}
else
{
fEvenOddPathList
.
add
(
&
fPathDrawAllocator
pathToAtlasMatrix
path
)
;
}
return
true
;
}
GrRenderTask
:
:
ExpectedOutcome
AtlasRenderTask
:
:
onMakeClosed
(
GrRecordingContext
*
rContext
SkIRect
*
targetUpdateBounds
)
{
SkASSERT
(
this
-
>
isEmpty
(
)
)
;
SkASSERT
(
!
fDynamicAtlas
-
>
isInstantiated
(
)
)
;
const
GrCaps
&
caps
=
*
rContext
-
>
priv
(
)
.
caps
(
)
;
this
-
>
target
(
0
)
-
>
priv
(
)
.
setLazyDimensions
(
fDynamicAtlas
-
>
drawBounds
(
)
)
;
this
-
>
target
(
0
)
-
>
asRenderTargetProxy
(
)
-
>
setNeedsStencil
(
)
;
SkRect
drawRect
=
target
(
0
)
-
>
getBoundsRect
(
)
;
if
(
caps
.
performColorClearsAsDraws
(
)
|
|
caps
.
performStencilClearsAsDraws
(
)
)
{
this
-
>
setColorLoadOp
(
GrLoadOp
:
:
kDiscard
)
;
this
-
>
setInitialStencilContent
(
StencilContent
:
:
kDontCare
)
;
constexpr
static
GrUserStencilSettings
kClearStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kReplace
GrUserStencilOp
:
:
kReplace
0xffff
>
(
)
)
;
this
-
>
stencilAtlasRect
(
rContext
drawRect
SK_PMColor4fTRANSPARENT
&
kClearStencil
)
;
}
else
{
this
-
>
setColorLoadOp
(
GrLoadOp
:
:
kClear
)
;
this
-
>
setInitialStencilContent
(
StencilContent
:
:
kUserBitsCleared
)
;
}
for
(
const
auto
*
pathList
:
{
&
fWindingPathList
&
fEvenOddPathList
}
)
{
if
(
pathList
-
>
pathCount
(
)
>
0
)
{
auto
op
=
GrOp
:
:
Make
<
PathStencilCoverOp
>
(
rContext
pathList
-
>
pathDrawList
(
)
pathList
-
>
totalCombinedPathVerbCnt
(
)
pathList
-
>
pathCount
(
)
GrPaint
(
)
GrAAType
:
:
kMSAA
FillPathFlags
:
:
kStencilOnly
drawRect
)
;
this
-
>
addAtlasDrawOp
(
std
:
:
move
(
op
)
caps
)
;
}
}
const
GrUserStencilSettings
*
stencil
;
if
(
caps
.
discardStencilValuesAfterRenderPass
(
)
)
{
constexpr
static
GrUserStencilSettings
kTestStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
stencil
=
&
kTestStencil
;
}
else
{
constexpr
static
GrUserStencilSettings
kTestAndResetStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
drawRect
.
outset
(
1
1
)
;
stencil
=
&
kTestAndResetStencil
;
}
this
-
>
stencilAtlasRect
(
rContext
drawRect
SK_PMColor4fWHITE
stencil
)
;
this
-
>
OpsTask
:
:
onMakeClosed
(
rContext
targetUpdateBounds
)
;
return
ExpectedOutcome
:
:
kTargetUnchanged
;
}
void
AtlasRenderTask
:
:
stencilAtlasRect
(
GrRecordingContext
*
rContext
const
SkRect
&
rect
const
SkPMColor4f
&
color
const
GrUserStencilSettings
*
stencil
)
{
GrPaint
paint
;
paint
.
setColor4f
(
color
)
;
paint
.
setXPFactory
(
SkBlendMode_AsXPFactory
(
SkBlendMode
:
:
kSrc
)
)
;
GrQuad
quad
(
rect
)
;
DrawQuad
drawQuad
{
quad
quad
GrQuadAAFlags
:
:
kAll
}
;
auto
op
=
FillRectOp
:
:
Make
(
rContext
std
:
:
move
(
paint
)
GrAAType
:
:
kMSAA
&
drawQuad
stencil
)
;
this
-
>
addAtlasDrawOp
(
std
:
:
move
(
op
)
*
rContext
-
>
priv
(
)
.
caps
(
)
)
;
}
void
AtlasRenderTask
:
:
addAtlasDrawOp
(
GrOp
:
:
Owner
op
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
auto
drawOp
=
static_cast
<
GrDrawOp
*
>
(
op
.
get
(
)
)
;
SkDEBUGCODE
(
drawOp
-
>
fAddDrawOpCalled
=
true
;
)
auto
processorAnalysis
=
drawOp
-
>
finalize
(
caps
nullptr
GrColorTypeClampType
(
fDynamicAtlas
-
>
colorType
(
)
)
)
;
SkASSERT
(
!
processorAnalysis
.
requiresDstTexture
(
)
)
;
SkASSERT
(
!
processorAnalysis
.
usesNonCoherentHWBlending
(
)
)
;
drawOp
-
>
setClippedBounds
(
drawOp
-
>
bounds
(
)
)
;
this
-
>
recordOp
(
std
:
:
move
(
op
)
true
processorAnalysis
nullptr
nullptr
caps
)
;
}
bool
AtlasRenderTask
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
if
(
!
this
-
>
OpsTask
:
:
onExecute
(
flushState
)
)
{
return
false
;
}
if
(
this
-
>
target
(
0
)
-
>
requiresManualMSAAResolve
(
)
)
{
auto
nativeRect
=
GrNativeRect
:
:
MakeIRectRelativeTo
(
GrDynamicAtlas
:
:
kTextureOrigin
this
-
>
target
(
0
)
-
>
backingStoreDimensions
(
)
.
height
(
)
SkIRect
:
:
MakeSize
(
fDynamicAtlas
-
>
drawBounds
(
)
)
)
;
flushState
-
>
gpu
(
)
-
>
resolveRenderTarget
(
this
-
>
target
(
0
)
-
>
peekRenderTarget
(
)
nativeRect
)
;
}
return
true
;
}
}
