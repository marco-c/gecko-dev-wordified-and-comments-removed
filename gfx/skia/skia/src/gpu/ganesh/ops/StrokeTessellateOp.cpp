#
include
"
src
/
gpu
/
ganesh
/
ops
/
StrokeTessellateOp
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrStrokeTessellationShader
.
h
"
namespace
skgpu
:
:
ganesh
{
StrokeTessellateOp
:
:
StrokeTessellateOp
(
GrAAType
aaType
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkStrokeRec
&
stroke
GrPaint
&
&
paint
)
:
GrDrawOp
(
ClassID
(
)
)
fAAType
(
aaType
)
fViewMatrix
(
viewMatrix
)
fPathStrokeList
(
path
stroke
paint
.
getColor4f
(
)
)
fTotalCombinedVerbCnt
(
path
.
countVerbs
(
)
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
if
(
!
this
-
>
headColor
(
)
.
fitsInBytes
(
)
)
{
fPatchAttribs
|
=
PatchAttribs
:
:
kWideColorIfEnabled
;
}
SkRect
devBounds
=
path
.
getBounds
(
)
;
if
(
!
this
-
>
headStroke
(
)
.
isHairlineStyle
(
)
)
{
float
r
=
stroke
.
getInflationRadius
(
)
;
devBounds
.
outset
(
r
r
)
;
}
viewMatrix
.
mapRect
(
&
devBounds
devBounds
)
;
if
(
this
-
>
headStroke
(
)
.
isHairlineStyle
(
)
)
{
float
r
=
SkStrokeRec
:
:
GetInflationRadius
(
stroke
.
getJoin
(
)
stroke
.
getMiter
(
)
stroke
.
getCap
(
)
1
)
;
devBounds
.
outset
(
r
r
)
;
}
this
-
>
setBounds
(
devBounds
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
}
void
StrokeTessellateOp
:
:
visitProxies
(
const
GrVisitProxyFunc
&
func
)
const
{
if
(
fFillProgram
)
{
fFillProgram
-
>
visitFPProxies
(
func
)
;
}
else
if
(
fStencilProgram
)
{
fStencilProgram
-
>
visitFPProxies
(
func
)
;
}
else
{
fProcessors
.
visitProxies
(
func
)
;
}
}
GrProcessorSet
:
:
Analysis
StrokeTessellateOp
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrClampType
clampType
)
{
SkASSERT
(
fPathStrokeList
.
fNext
=
=
nullptr
)
;
if
(
!
caps
.
shaderCaps
(
)
-
>
fInfinitySupport
)
{
fPatchAttribs
|
=
PatchAttribs
:
:
kExplicitCurveType
;
}
const
GrProcessorSet
:
:
Analysis
&
analysis
=
fProcessors
.
finalize
(
this
-
>
headColor
(
)
GrProcessorAnalysisCoverage
:
:
kNone
clip
&
GrUserStencilSettings
:
:
kUnused
caps
clampType
&
this
-
>
headColor
(
)
)
;
fNeedsStencil
=
!
analysis
.
unaffectedByDstValue
(
)
;
return
analysis
;
}
GrOp
:
:
CombineResult
StrokeTessellateOp
:
:
onCombineIfPossible
(
GrOp
*
grOp
SkArenaAlloc
*
alloc
const
GrCaps
&
caps
)
{
SkASSERT
(
grOp
-
>
classID
(
)
=
=
this
-
>
classID
(
)
)
;
auto
*
op
=
static_cast
<
StrokeTessellateOp
*
>
(
grOp
)
;
SkASSERT
(
fProcessors
.
isFinalized
(
)
)
;
SkASSERT
(
op
-
>
fProcessors
.
isFinalized
(
)
)
;
if
(
fNeedsStencil
|
|
op
-
>
fNeedsStencil
|
|
fViewMatrix
!
=
op
-
>
fViewMatrix
|
|
fAAType
!
=
op
-
>
fAAType
|
|
fProcessors
!
=
op
-
>
fProcessors
|
|
this
-
>
headStroke
(
)
.
isHairlineStyle
(
)
!
=
op
-
>
headStroke
(
)
.
isHairlineStyle
(
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
auto
combinedAttribs
=
fPatchAttribs
|
op
-
>
fPatchAttribs
;
if
(
!
(
combinedAttribs
&
PatchAttribs
:
:
kStrokeParams
)
&
&
!
tess
:
:
StrokesHaveEqualParams
(
this
-
>
headStroke
(
)
op
-
>
headStroke
(
)
)
)
{
if
(
this
-
>
headStroke
(
)
.
isHairlineStyle
(
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
combinedAttribs
|
=
PatchAttribs
:
:
kStrokeParams
;
}
if
(
!
(
combinedAttribs
&
PatchAttribs
:
:
kColor
)
&
&
this
-
>
headColor
(
)
!
=
op
-
>
headColor
(
)
)
{
combinedAttribs
|
=
PatchAttribs
:
:
kColor
;
}
constexpr
static
GrTFlagsMask
<
PatchAttribs
>
kDynamicStatesMask
(
PatchAttribs
:
:
kStrokeParams
|
PatchAttribs
:
:
kColor
)
;
PatchAttribs
neededDynamicStates
=
combinedAttribs
&
kDynamicStatesMask
;
if
(
neededDynamicStates
!
=
PatchAttribs
:
:
kNone
)
{
if
(
!
this
-
>
shouldUseDynamicStates
(
neededDynamicStates
)
|
|
!
op
-
>
shouldUseDynamicStates
(
neededDynamicStates
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
}
fPatchAttribs
=
combinedAttribs
;
auto
*
headCopy
=
alloc
-
>
make
<
PathStrokeList
>
(
std
:
:
move
(
op
-
>
fPathStrokeList
)
)
;
*
fPathStrokeTail
=
headCopy
;
fPathStrokeTail
=
(
op
-
>
fPathStrokeTail
=
=
&
op
-
>
fPathStrokeList
.
fNext
)
?
&
headCopy
-
>
fNext
:
op
-
>
fPathStrokeTail
;
fTotalCombinedVerbCnt
+
=
op
-
>
fTotalCombinedVerbCnt
;
return
CombineResult
:
:
kMerged
;
}
constexpr
static
GrUserStencilSettings
kMarkStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0001
GrUserStencilTest
:
:
kLessIfInClip
0x0000
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kReplace
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kTestAndResetStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kLessIfInClip
0x0001
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kReplace
0xffff
>
(
)
)
;
void
StrokeTessellateOp
:
:
prePrepareTessellator
(
GrTessellationShader
:
:
ProgramArgs
&
&
args
GrAppliedClip
&
&
clip
)
{
SkASSERT
(
!
fTessellator
)
;
SkASSERT
(
!
fFillProgram
)
;
SkASSERT
(
!
fStencilProgram
)
;
SkASSERT
(
SkRect
:
:
MakeIWH
(
args
.
fWriteView
.
width
(
)
args
.
fWriteView
.
height
(
)
)
.
contains
(
this
-
>
bounds
(
)
)
)
;
const
GrCaps
&
caps
=
*
args
.
fCaps
;
SkArenaAlloc
*
arena
=
args
.
fArena
;
auto
*
pipeline
=
GrTessellationShader
:
:
MakePipeline
(
args
fAAType
std
:
:
move
(
clip
)
std
:
:
move
(
fProcessors
)
)
;
fTessellator
=
arena
-
>
make
<
StrokeTessellator
>
(
fPatchAttribs
)
;
fTessellationShader
=
args
.
fArena
-
>
make
<
GrStrokeTessellationShader
>
(
*
caps
.
shaderCaps
(
)
fPatchAttribs
fViewMatrix
this
-
>
headStroke
(
)
this
-
>
headColor
(
)
)
;
auto
fillStencil
=
&
GrUserStencilSettings
:
:
kUnused
;
if
(
fNeedsStencil
)
{
fStencilProgram
=
GrTessellationShader
:
:
MakeProgram
(
args
fTessellationShader
pipeline
&
kMarkStencil
)
;
fillStencil
=
&
kTestAndResetStencil
;
}
fFillProgram
=
GrTessellationShader
:
:
MakeProgram
(
args
fTessellationShader
pipeline
fillStencil
)
;
}
void
StrokeTessellateOp
:
:
onPrePrepare
(
GrRecordingContext
*
context
const
GrSurfaceProxyView
&
writeView
GrAppliedClip
*
clip
const
GrDstProxyView
&
dstProxyView
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
{
bool
usesMSAASurface
=
writeView
.
asRenderTargetProxy
(
)
-
>
numSamples
(
)
>
1
;
this
-
>
prePrepareTessellator
(
{
context
-
>
priv
(
)
.
recordTimeAllocator
(
)
writeView
usesMSAASurface
&
dstProxyView
renderPassXferBarriers
colorLoadOp
context
-
>
priv
(
)
.
caps
(
)
}
(
clip
)
?
std
:
:
move
(
*
clip
)
:
GrAppliedClip
:
:
Disabled
(
)
)
;
if
(
fStencilProgram
)
{
context
-
>
priv
(
)
.
recordProgramInfo
(
fStencilProgram
)
;
}
if
(
fFillProgram
)
{
context
-
>
priv
(
)
.
recordProgramInfo
(
fFillProgram
)
;
}
}
void
StrokeTessellateOp
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
if
(
!
fTessellator
)
{
this
-
>
prePrepareTessellator
(
{
flushState
-
>
allocator
(
)
flushState
-
>
writeView
(
)
flushState
-
>
usesMSAASurface
(
)
&
flushState
-
>
dstProxyView
(
)
flushState
-
>
renderPassBarriers
(
)
flushState
-
>
colorLoadOp
(
)
&
flushState
-
>
caps
(
)
}
flushState
-
>
detachAppliedClip
(
)
)
;
}
SkASSERT
(
fTessellator
)
;
fTessellator
-
>
prepare
(
flushState
fViewMatrix
&
fPathStrokeList
fTotalCombinedVerbCnt
)
;
}
void
StrokeTessellateOp
:
:
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
{
if
(
fStencilProgram
)
{
flushState
-
>
bindPipelineAndScissorClip
(
*
fStencilProgram
chainBounds
)
;
flushState
-
>
bindTextures
(
fStencilProgram
-
>
geomProc
(
)
nullptr
fStencilProgram
-
>
pipeline
(
)
)
;
fTessellator
-
>
draw
(
flushState
)
;
}
if
(
fFillProgram
)
{
flushState
-
>
bindPipelineAndScissorClip
(
*
fFillProgram
chainBounds
)
;
flushState
-
>
bindTextures
(
fFillProgram
-
>
geomProc
(
)
nullptr
fFillProgram
-
>
pipeline
(
)
)
;
fTessellator
-
>
draw
(
flushState
)
;
}
}
}
