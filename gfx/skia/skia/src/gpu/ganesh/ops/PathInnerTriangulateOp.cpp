#
include
"
src
/
gpu
/
ganesh
/
ops
/
PathInnerTriangulateOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrEagerVertexAllocator
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrPathTessellationShader
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
PathTessellator
.
h
"
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
namespace
skgpu
:
:
ganesh
{
namespace
{
class
HullShader
:
public
GrPathTessellationShader
{
public
:
HullShader
(
const
SkMatrix
&
viewMatrix
SkPMColor4f
color
const
GrShaderCaps
&
shaderCaps
)
:
GrPathTessellationShader
(
kTessellate_HullShader_ClassID
GrPrimitiveType
:
:
kTriangleStrip
viewMatrix
color
PatchAttribs
:
:
kNone
)
{
fInstanceAttribs
.
emplace_back
(
"
p01
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
)
;
fInstanceAttribs
.
emplace_back
(
"
p23
"
kFloat4_GrVertexAttribType
SkSLType
:
:
kFloat4
)
;
if
(
!
shaderCaps
.
fInfinitySupport
)
{
fInstanceAttribs
.
emplace_back
(
"
curveType
"
kFloat_GrVertexAttribType
SkSLType
:
:
kFloat
)
;
}
this
-
>
setInstanceAttributesWithImplicitOffsets
(
fInstanceAttribs
.
data
(
)
fInstanceAttribs
.
size
(
)
)
;
SkASSERT
(
fInstanceAttribs
.
size
(
)
<
=
kMaxInstanceAttribCount
)
;
if
(
!
shaderCaps
.
fVertexIDSupport
)
{
constexpr
static
Attribute
kVertexIdxAttrib
(
"
vertexidx
"
kFloat_GrVertexAttribType
SkSLType
:
:
kFloat
)
;
this
-
>
setVertexAttributesWithImplicitOffsets
(
&
kVertexIdxAttrib
1
)
;
}
}
private
:
const
char
*
name
(
)
const
final
{
return
"
tessellate_HullShader
"
;
}
void
addToKey
(
const
GrShaderCaps
&
KeyBuilder
*
)
const
final
{
}
std
:
:
unique_ptr
<
ProgramImpl
>
makeProgramImpl
(
const
GrShaderCaps
&
)
const
final
;
constexpr
static
int
kMaxInstanceAttribCount
=
3
;
SkSTArray
<
kMaxInstanceAttribCount
Attribute
>
fInstanceAttribs
;
}
;
std
:
:
unique_ptr
<
GrGeometryProcessor
:
:
ProgramImpl
>
HullShader
:
:
makeProgramImpl
(
const
GrShaderCaps
&
)
const
{
class
Impl
:
public
GrPathTessellationShader
:
:
Impl
{
void
emitVertexCode
(
const
GrShaderCaps
&
shaderCaps
const
GrPathTessellationShader
&
GrGLSLVertexBuilder
*
v
GrGLSLVaryingHandler
*
GrGPArgs
*
gpArgs
)
override
{
if
(
shaderCaps
.
fInfinitySupport
)
{
v
-
>
insertFunction
(
"
bool
is_conic_curve
(
)
{
return
isinf
(
p23
.
w
)
;
}
"
"
bool
is_non_triangular_conic_curve
(
)
{
"
"
return
isinf
(
p23
.
z
)
=
=
false
;
"
"
}
"
)
;
}
else
{
v
-
>
insertFunction
(
SkStringPrintf
(
"
bool
is_conic_curve
(
)
{
return
curveType
!
=
%
g
;
}
"
tess
:
:
kCubicCurveType
)
.
c_str
(
)
)
;
v
-
>
insertFunction
(
SkStringPrintf
(
"
bool
is_non_triangular_conic_curve
(
)
{
"
"
return
curveType
=
=
%
g
;
"
"
}
"
tess
:
:
kConicCurveType
)
.
c_str
(
)
)
;
}
v
-
>
codeAppend
(
"
float2
p0
=
p01
.
xy
p1
=
p01
.
zw
p2
=
p23
.
xy
p3
=
p23
.
zw
;
"
"
if
(
is_conic_curve
(
)
)
{
"
"
float
w
=
p3
.
x
;
"
"
p3
=
p2
;
"
"
if
(
is_non_triangular_conic_curve
(
)
)
{
"
"
float2
p1w
=
p1
*
w
;
"
"
float
T
=
.
51
;
"
"
float2
c1
=
mix
(
p0
p1w
T
)
;
"
"
float2
c2
=
mix
(
p2
p1w
T
)
;
"
"
float
iw
=
1
/
mix
(
1
w
T
)
;
"
"
p2
=
c2
*
iw
;
"
"
p1
=
c1
*
iw
;
"
"
}
"
"
}
"
"
float2
v1
=
p1
-
p0
;
"
"
float2
v2
=
p2
-
p0
;
"
"
float2
v3
=
p3
-
p0
;
"
"
if
(
sign
(
cross_length_2d
(
v2
v1
)
)
=
=
sign
(
cross_length_2d
(
v2
v3
)
)
)
{
"
"
float2
tmp
=
p2
;
"
"
if
(
sign
(
cross_length_2d
(
v1
v2
)
)
!
=
sign
(
cross_length_2d
(
v1
v3
)
)
)
{
"
"
p2
=
p1
;
"
"
p1
=
tmp
;
"
"
}
else
{
"
"
p2
=
p3
;
"
"
p3
=
tmp
;
"
"
}
"
"
}
"
)
;
if
(
shaderCaps
.
fVertexIDSupport
)
{
v
-
>
codeAppend
(
"
int
vertexidx
=
sk_VertexID
;
"
"
vertexidx
^
=
vertexidx
>
>
1
;
"
)
;
}
v
-
>
codeAppend
(
"
float
vertexdir
=
0
;
"
"
float
netdir
=
0
;
"
"
float2
prev
next
;
"
"
float
dir
;
"
"
float2
localcoord
;
"
"
float2
nextcoord
;
"
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
v
-
>
codeAppendf
(
"
prev
=
p
%
i
-
p
%
i
;
"
i
(
i
+
3
)
%
4
)
;
v
-
>
codeAppendf
(
"
next
=
p
%
i
-
p
%
i
;
"
(
i
+
1
)
%
4
i
)
;
v
-
>
codeAppendf
(
"
dir
=
sign
(
cross_length_2d
(
prev
next
)
)
;
"
"
if
(
vertexidx
=
=
%
i
)
{
"
"
vertexdir
=
dir
;
"
"
localcoord
=
p
%
i
;
"
"
nextcoord
=
p
%
i
;
"
"
}
"
"
netdir
+
=
dir
;
"
i
i
(
i
+
1
)
%
4
)
;
}
v
-
>
codeAppend
(
"
if
(
vertexdir
!
=
sign
(
netdir
)
)
{
"
"
localcoord
=
nextcoord
;
"
"
}
"
"
float2
vertexpos
=
AFFINE_MATRIX
*
localcoord
+
TRANSLATE
;
"
)
;
gpArgs
-
>
fLocalCoordVar
.
set
(
SkSLType
:
:
kFloat2
"
localcoord
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
SkSLType
:
:
kFloat2
"
vertexpos
"
)
;
}
}
;
return
std
:
:
make_unique
<
Impl
>
(
)
;
}
}
void
PathInnerTriangulateOp
:
:
visitProxies
(
const
GrVisitProxyFunc
&
func
)
const
{
if
(
fPipelineForFills
)
{
fPipelineForFills
-
>
visitProxies
(
func
)
;
}
else
{
fProcessors
.
visitProxies
(
func
)
;
}
}
GrDrawOp
:
:
FixedFunctionFlags
PathInnerTriangulateOp
:
:
fixedFunctionFlags
(
)
const
{
auto
flags
=
FixedFunctionFlags
:
:
kUsesStencil
;
if
(
GrAAType
:
:
kNone
!
=
fAAType
)
{
flags
|
=
FixedFunctionFlags
:
:
kUsesHWAA
;
}
return
flags
;
}
GrProcessorSet
:
:
Analysis
PathInnerTriangulateOp
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrClampType
clampType
)
{
return
fProcessors
.
finalize
(
fColor
GrProcessorAnalysisCoverage
:
:
kNone
clip
nullptr
caps
clampType
&
fColor
)
;
}
void
PathInnerTriangulateOp
:
:
pushFanStencilProgram
(
const
GrTessellationShader
:
:
ProgramArgs
&
args
const
GrPipeline
*
pipelineForStencils
const
GrUserStencilSettings
*
stencil
)
{
SkASSERT
(
pipelineForStencils
)
;
auto
shader
=
GrPathTessellationShader
:
:
MakeSimpleTriangleShader
(
args
.
fArena
fViewMatrix
SK_PMColor4fTRANSPARENT
)
;
fFanPrograms
.
push_back
(
GrTessellationShader
:
:
MakeProgram
(
args
shader
pipelineForStencils
stencil
)
)
;
}
void
PathInnerTriangulateOp
:
:
pushFanFillProgram
(
const
GrTessellationShader
:
:
ProgramArgs
&
args
const
GrUserStencilSettings
*
stencil
)
{
SkASSERT
(
fPipelineForFills
)
;
auto
shader
=
GrPathTessellationShader
:
:
MakeSimpleTriangleShader
(
args
.
fArena
fViewMatrix
fColor
)
;
fFanPrograms
.
push_back
(
GrTessellationShader
:
:
MakeProgram
(
args
shader
fPipelineForFills
stencil
)
)
;
}
void
PathInnerTriangulateOp
:
:
prePreparePrograms
(
const
GrTessellationShader
:
:
ProgramArgs
&
args
GrAppliedClip
&
&
appliedClip
)
{
SkASSERT
(
!
fFanTriangulator
)
;
SkASSERT
(
!
fFanPolys
)
;
SkASSERT
(
!
fPipelineForFills
)
;
SkASSERT
(
!
fTessellator
)
;
SkASSERT
(
!
fStencilCurvesProgram
)
;
SkASSERT
(
fFanPrograms
.
empty
(
)
)
;
SkASSERT
(
!
fCoverHullsProgram
)
;
if
(
fPath
.
countVerbs
(
)
<
=
0
)
{
return
;
}
bool
forceRedbookStencilPass
=
(
fPathFlags
&
(
FillPathFlags
:
:
kStencilOnly
|
FillPathFlags
:
:
kWireframe
)
)
;
bool
doFill
=
!
(
fPathFlags
&
FillPathFlags
:
:
kStencilOnly
)
;
bool
isLinear
;
fFanTriangulator
=
args
.
fArena
-
>
make
<
GrInnerFanTriangulator
>
(
fPath
args
.
fArena
)
;
fFanPolys
=
fFanTriangulator
-
>
pathToPolys
(
&
fFanBreadcrumbs
&
isLinear
)
;
const
GrPipeline
*
pipelineForStencils
=
nullptr
;
if
(
forceRedbookStencilPass
|
|
!
isLinear
)
{
auto
pipelineFlags
=
(
fPathFlags
&
FillPathFlags
:
:
kWireframe
)
?
GrPipeline
:
:
InputFlags
:
:
kWireframe
:
GrPipeline
:
:
InputFlags
:
:
kNone
;
pipelineForStencils
=
GrPathTessellationShader
:
:
MakeStencilOnlyPipeline
(
args
fAAType
appliedClip
.
hardClip
(
)
pipelineFlags
)
;
}
if
(
doFill
)
{
fPipelineForFills
=
GrTessellationShader
:
:
MakePipeline
(
args
fAAType
std
:
:
move
(
appliedClip
)
std
:
:
move
(
fProcessors
)
)
;
}
if
(
!
isLinear
)
{
fTessellator
=
PathCurveTessellator
:
:
Make
(
args
.
fArena
args
.
fCaps
-
>
shaderCaps
(
)
-
>
fInfinitySupport
)
;
auto
*
tessShader
=
GrPathTessellationShader
:
:
Make
(
*
args
.
fCaps
-
>
shaderCaps
(
)
args
.
fArena
fViewMatrix
SK_PMColor4fTRANSPARENT
fTessellator
-
>
patchAttribs
(
)
)
;
const
GrUserStencilSettings
*
stencilPathSettings
=
GrPathTessellationShader
:
:
StencilPathSettings
(
GrFillRuleForSkPath
(
fPath
)
)
;
fStencilCurvesProgram
=
GrTessellationShader
:
:
MakeProgram
(
args
tessShader
pipelineForStencils
stencilPathSettings
)
;
}
if
(
fFanPolys
)
{
if
(
forceRedbookStencilPass
)
{
const
GrUserStencilSettings
*
stencilPathSettings
=
GrPathTessellationShader
:
:
StencilPathSettings
(
GrFillRuleForSkPath
(
fPath
)
)
;
this
-
>
pushFanStencilProgram
(
args
pipelineForStencils
stencilPathSettings
)
;
if
(
doFill
)
{
this
-
>
pushFanFillProgram
(
args
GrPathTessellationShader
:
:
TestAndResetStencilSettings
(
)
)
;
}
}
else
if
(
isLinear
)
{
SkASSERT
(
!
pipelineForStencils
)
;
this
-
>
pushFanFillProgram
(
args
&
GrUserStencilSettings
:
:
kUnused
)
;
}
else
if
(
!
fPipelineForFills
-
>
hasStencilClip
(
)
)
{
constexpr
static
GrUserStencilSettings
kFillOrIncrDecrStencil
(
GrUserStencilSettings
:
:
StaticInitSeparate
<
0x0000
0x0000
GrUserStencilTest
:
:
kEqual
GrUserStencilTest
:
:
kEqual
0xffff
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kIncWrap
GrUserStencilOp
:
:
kDecWrap
0xffff
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kFillOrInvertStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kZero
0xffff
>
(
)
)
;
auto
*
stencil
=
(
fPath
.
getFillType
(
)
=
=
SkPathFillType
:
:
kWinding
)
?
&
kFillOrIncrDecrStencil
:
&
kFillOrInvertStencil
;
this
-
>
pushFanFillProgram
(
args
stencil
)
;
}
else
{
constexpr
static
GrUserStencilSettings
kFillIfZeroAndInClip
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqualIfInClip
0xffff
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kIncrDecrStencilIfNonzero
(
GrUserStencilSettings
:
:
StaticInitSeparate
<
0x0000
0x0000
GrUserStencilTest
:
:
kNotEqual
GrUserStencilTest
:
:
kNotEqual
0xffff
0xffff
GrUserStencilOp
:
:
kIncWrap
GrUserStencilOp
:
:
kDecWrap
GrUserStencilOp
:
:
kKeep
GrUserStencilOp
:
:
kKeep
0xffff
0xffff
>
(
)
)
;
constexpr
static
GrUserStencilSettings
kInvertStencilIfNonZero
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kNotEqual
0xffff
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kKeep
0xffff
>
(
)
)
;
this
-
>
pushFanFillProgram
(
args
&
kFillIfZeroAndInClip
)
;
auto
*
stencil
=
(
fPath
.
getFillType
(
)
=
=
SkPathFillType
:
:
kWinding
)
?
&
kIncrDecrStencilIfNonzero
:
&
kInvertStencilIfNonZero
;
this
-
>
pushFanStencilProgram
(
args
pipelineForStencils
stencil
)
;
}
}
if
(
doFill
&
&
!
isLinear
)
{
SkASSERT
(
fTessellator
)
;
auto
*
hullShader
=
args
.
fArena
-
>
make
<
HullShader
>
(
fViewMatrix
fColor
*
args
.
fCaps
-
>
shaderCaps
(
)
)
;
fCoverHullsProgram
=
GrTessellationShader
:
:
MakeProgram
(
args
hullShader
fPipelineForFills
GrPathTessellationShader
:
:
TestAndResetStencilSettings
(
)
)
;
}
}
void
PathInnerTriangulateOp
:
:
onPrePrepare
(
GrRecordingContext
*
context
const
GrSurfaceProxyView
&
writeView
GrAppliedClip
*
clip
const
GrDstProxyView
&
dstProxyView
GrXferBarrierFlags
renderPassXferBarriers
GrLoadOp
colorLoadOp
)
{
bool
usesMSAASurface
=
writeView
.
asRenderTargetProxy
(
)
-
>
numSamples
(
)
>
1
;
this
-
>
prePreparePrograms
(
{
context
-
>
priv
(
)
.
recordTimeAllocator
(
)
writeView
usesMSAASurface
&
dstProxyView
renderPassXferBarriers
colorLoadOp
context
-
>
priv
(
)
.
caps
(
)
}
(
clip
)
?
std
:
:
move
(
*
clip
)
:
GrAppliedClip
:
:
Disabled
(
)
)
;
if
(
fStencilCurvesProgram
)
{
context
-
>
priv
(
)
.
recordProgramInfo
(
fStencilCurvesProgram
)
;
}
for
(
const
GrProgramInfo
*
fanProgram
:
fFanPrograms
)
{
context
-
>
priv
(
)
.
recordProgramInfo
(
fanProgram
)
;
}
if
(
fCoverHullsProgram
)
{
context
-
>
priv
(
)
.
recordProgramInfo
(
fCoverHullsProgram
)
;
}
}
SKGPU_DECLARE_STATIC_UNIQUE_KEY
(
gHullVertexBufferKey
)
;
void
PathInnerTriangulateOp
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
const
GrCaps
&
caps
=
flushState
-
>
caps
(
)
;
if
(
!
fFanTriangulator
)
{
this
-
>
prePreparePrograms
(
{
flushState
-
>
allocator
(
)
flushState
-
>
writeView
(
)
flushState
-
>
usesMSAASurface
(
)
&
flushState
-
>
dstProxyView
(
)
flushState
-
>
renderPassBarriers
(
)
flushState
-
>
colorLoadOp
(
)
&
caps
}
flushState
-
>
detachAppliedClip
(
)
)
;
if
(
!
fFanTriangulator
)
{
return
;
}
}
if
(
fFanPolys
)
{
GrEagerDynamicVertexAllocator
alloc
(
flushState
&
fFanBuffer
&
fBaseFanVertex
)
;
fFanVertexCount
=
fFanTriangulator
-
>
polysToTriangles
(
fFanPolys
&
alloc
&
fFanBreadcrumbs
)
;
}
if
(
fTessellator
)
{
auto
tessShader
=
&
fStencilCurvesProgram
-
>
geomProc
(
)
.
cast
<
GrPathTessellationShader
>
(
)
;
fTessellator
-
>
prepareWithTriangles
(
flushState
tessShader
-
>
viewMatrix
(
)
&
fFanBreadcrumbs
{
SkMatrix
:
:
I
(
)
fPath
SK_PMColor4fTRANSPARENT
}
fPath
.
countVerbs
(
)
)
;
}
if
(
!
caps
.
shaderCaps
(
)
-
>
fVertexIDSupport
)
{
constexpr
static
float
kStripOrderIDs
[
4
]
=
{
0
1
3
2
}
;
SKGPU_DEFINE_STATIC_UNIQUE_KEY
(
gHullVertexBufferKey
)
;
fHullVertexBufferIfNoIDSupport
=
flushState
-
>
resourceProvider
(
)
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kVertex
sizeof
(
kStripOrderIDs
)
kStripOrderIDs
gHullVertexBufferKey
)
;
}
}
void
PathInnerTriangulateOp
:
:
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
{
if
(
fCoverHullsProgram
&
&
fCoverHullsProgram
-
>
geomProc
(
)
.
hasVertexAttributes
(
)
&
&
!
fHullVertexBufferIfNoIDSupport
)
{
return
;
}
if
(
fStencilCurvesProgram
)
{
SkASSERT
(
fTessellator
)
;
flushState
-
>
bindPipelineAndScissorClip
(
*
fStencilCurvesProgram
this
-
>
bounds
(
)
)
;
fTessellator
-
>
draw
(
flushState
)
;
}
if
(
fFanBuffer
)
{
for
(
const
GrProgramInfo
*
fanProgram
:
fFanPrograms
)
{
flushState
-
>
bindPipelineAndScissorClip
(
*
fanProgram
this
-
>
bounds
(
)
)
;
flushState
-
>
bindTextures
(
fanProgram
-
>
geomProc
(
)
nullptr
fanProgram
-
>
pipeline
(
)
)
;
flushState
-
>
bindBuffers
(
nullptr
nullptr
fFanBuffer
)
;
flushState
-
>
draw
(
fFanVertexCount
fBaseFanVertex
)
;
}
}
if
(
fCoverHullsProgram
)
{
SkASSERT
(
fTessellator
)
;
flushState
-
>
bindPipelineAndScissorClip
(
*
fCoverHullsProgram
this
-
>
bounds
(
)
)
;
flushState
-
>
bindTextures
(
fCoverHullsProgram
-
>
geomProc
(
)
nullptr
*
fPipelineForFills
)
;
fTessellator
-
>
drawHullInstances
(
flushState
fHullVertexBufferIfNoIDSupport
)
;
}
}
}
#
endif
