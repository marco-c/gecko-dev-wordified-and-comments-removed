#
include
"
src
/
gpu
/
ganesh
/
ops
/
AtlasTextOp
.
h
"
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkStrikeCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrBitmapTextGeoProc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrDistanceFieldGeoProc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
GrSimpleMeshDrawOpHelper
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
text
/
GrAtlasManager
.
h
"
#
include
"
src
/
text
/
GlyphRun
.
h
"
#
include
"
src
/
text
/
gpu
/
DistanceFieldAdjustTable
.
h
"
#
include
<
new
>
#
include
<
utility
>
#
if
GR_TEST_UTILS
#
include
"
src
/
gpu
/
ganesh
/
GrDrawOpTest
.
h
"
#
endif
using
MaskFormat
=
skgpu
:
:
MaskFormat
;
namespace
skgpu
:
:
ganesh
{
inline
static
constexpr
int
kVerticesPerGlyph
=
4
;
inline
static
constexpr
int
kIndicesPerGlyph
=
6
;
static
thread_local
void
*
gCache
=
nullptr
;
void
*
AtlasTextOp
:
:
operator
new
(
size_t
s
)
{
if
(
gCache
!
=
nullptr
)
{
return
std
:
:
exchange
(
gCache
nullptr
)
;
}
return
:
:
operator
new
(
s
)
;
}
void
AtlasTextOp
:
:
operator
delete
(
void
*
bytes
)
noexcept
{
if
(
gCache
=
=
nullptr
)
{
gCache
=
bytes
;
return
;
}
:
:
operator
delete
(
bytes
)
;
}
void
AtlasTextOp
:
:
ClearCache
(
)
{
:
:
operator
delete
(
gCache
)
;
gCache
=
nullptr
;
}
AtlasTextOp
:
:
AtlasTextOp
(
MaskType
maskType
bool
needsTransform
int
glyphCount
SkRect
deviceRect
Geometry
*
geo
GrPaint
&
&
paint
)
:
INHERITED
{
ClassID
(
)
}
fProcessors
(
std
:
:
move
(
paint
)
)
fNumGlyphs
(
glyphCount
)
fDFGPFlags
(
0
)
fMaskType
(
static_cast
<
uint32_t
>
(
maskType
)
)
fUsesLocalCoords
(
false
)
fNeedsGlyphTransform
(
needsTransform
)
fHasPerspective
(
needsTransform
&
&
geo
-
>
fDrawMatrix
.
hasPerspective
(
)
)
fUseGammaCorrectDistanceTable
(
false
)
fHead
{
geo
}
fTail
{
&
fHead
-
>
fNext
}
{
this
-
>
setBounds
(
deviceRect
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
}
AtlasTextOp
:
:
AtlasTextOp
(
MaskType
maskType
bool
needsTransform
int
glyphCount
SkRect
deviceRect
SkColor
luminanceColor
bool
useGammaCorrectDistanceTable
uint32_t
DFGPFlags
Geometry
*
geo
GrPaint
&
&
paint
)
:
INHERITED
{
ClassID
(
)
}
fProcessors
(
std
:
:
move
(
paint
)
)
fNumGlyphs
(
glyphCount
)
fDFGPFlags
(
DFGPFlags
)
fMaskType
(
static_cast
<
uint32_t
>
(
maskType
)
)
fUsesLocalCoords
(
false
)
fNeedsGlyphTransform
(
needsTransform
)
fHasPerspective
(
needsTransform
&
&
geo
-
>
fDrawMatrix
.
hasPerspective
(
)
)
fUseGammaCorrectDistanceTable
(
useGammaCorrectDistanceTable
)
fLuminanceColor
(
luminanceColor
)
fHead
{
geo
}
fTail
{
&
fHead
-
>
fNext
}
{
this
-
>
setBounds
(
deviceRect
HasAABloat
:
:
kNo
IsHairline
:
:
kNo
)
;
}
auto
AtlasTextOp
:
:
Geometry
:
:
Make
(
const
sktext
:
:
gpu
:
:
AtlasSubRun
&
subRun
const
SkMatrix
&
drawMatrix
SkPoint
drawOrigin
SkIRect
clipRect
sk_sp
<
SkRefCnt
>
&
&
supportData
const
SkPMColor4f
&
color
SkArenaAlloc
*
alloc
)
-
>
Geometry
*
{
void
*
geo
=
alloc
-
>
makeBytesAlignedTo
(
sizeof
(
Geometry
)
alignof
(
Geometry
)
)
;
return
new
(
geo
)
Geometry
{
subRun
drawMatrix
drawOrigin
clipRect
std
:
:
move
(
supportData
)
color
}
;
}
void
AtlasTextOp
:
:
Geometry
:
:
fillVertexData
(
void
*
dst
int
offset
int
count
)
const
{
fSubRun
.
fillVertexData
(
dst
offset
count
fColor
.
toBytes_RGBA
(
)
fDrawMatrix
fDrawOrigin
fClipRect
)
;
}
void
AtlasTextOp
:
:
visitProxies
(
const
GrVisitProxyFunc
&
func
)
const
{
fProcessors
.
visitProxies
(
func
)
;
}
#
if
GR_TEST_UTILS
SkString
AtlasTextOp
:
:
onDumpInfo
(
)
const
{
SkString
str
;
int
i
=
0
;
for
(
Geometry
*
geom
=
fHead
;
geom
!
=
nullptr
;
geom
=
geom
-
>
fNext
)
{
str
.
appendf
(
"
%
d
:
Color
:
0x
%
08x
Trans
:
%
.
2f
%
.
2f
\
n
"
i
+
+
geom
-
>
fColor
.
toBytes_RGBA
(
)
geom
-
>
fDrawOrigin
.
x
(
)
geom
-
>
fDrawOrigin
.
y
(
)
)
;
}
str
+
=
fProcessors
.
dumpProcessors
(
)
;
return
str
;
}
#
endif
GrDrawOp
:
:
FixedFunctionFlags
AtlasTextOp
:
:
fixedFunctionFlags
(
)
const
{
return
FixedFunctionFlags
:
:
kNone
;
}
GrProcessorSet
:
:
Analysis
AtlasTextOp
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrClampType
clampType
)
{
GrProcessorAnalysisCoverage
coverage
;
GrProcessorAnalysisColor
color
;
if
(
this
-
>
maskType
(
)
=
=
MaskType
:
:
kColorBitmap
)
{
color
.
setToUnknown
(
)
;
}
else
{
color
.
setToConstant
(
fHead
-
>
fColor
)
;
}
switch
(
this
-
>
maskType
(
)
)
{
case
MaskType
:
:
kGrayscaleCoverage
:
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
case
MaskType
:
:
kAliasedDistanceField
:
case
MaskType
:
:
kGrayscaleDistanceField
:
#
endif
coverage
=
GrProcessorAnalysisCoverage
:
:
kSingleChannel
;
break
;
case
MaskType
:
:
kLCDCoverage
:
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
case
MaskType
:
:
kLCDDistanceField
:
case
MaskType
:
:
kLCDBGRDistanceField
:
#
endif
coverage
=
GrProcessorAnalysisCoverage
:
:
kLCD
;
break
;
case
MaskType
:
:
kColorBitmap
:
coverage
=
GrProcessorAnalysisCoverage
:
:
kNone
;
break
;
}
auto
analysis
=
fProcessors
.
finalize
(
color
coverage
clip
&
GrUserStencilSettings
:
:
kUnused
caps
clampType
&
fHead
-
>
fColor
)
;
fUsesLocalCoords
=
analysis
.
usesLocalCoords
(
)
;
return
analysis
;
}
void
AtlasTextOp
:
:
onPrepareDraws
(
GrMeshDrawTarget
*
target
)
{
auto
resourceProvider
=
target
-
>
resourceProvider
(
)
;
SkMatrix
localMatrix
=
SkMatrix
:
:
I
(
)
;
if
(
fUsesLocalCoords
&
&
!
fHead
-
>
fDrawMatrix
.
invert
(
&
localMatrix
)
)
{
return
;
}
GrAtlasManager
*
atlasManager
=
target
-
>
atlasManager
(
)
;
MaskFormat
maskFormat
=
this
-
>
maskFormat
(
)
;
unsigned
int
numActiveViews
;
const
GrSurfaceProxyView
*
views
=
atlasManager
-
>
getViews
(
maskFormat
&
numActiveViews
)
;
if
(
!
views
)
{
SkDebugf
(
"
Could
not
allocate
backing
texture
for
atlas
\
n
"
)
;
return
;
}
SkASSERT
(
views
[
0
]
.
proxy
(
)
)
;
static
constexpr
int
kMaxTextures
=
GrBitmapTextGeoProc
:
:
kMaxTextures
;
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
static_assert
(
GrDistanceFieldA8TextGeoProc
:
:
kMaxTextures
=
=
kMaxTextures
)
;
static_assert
(
GrDistanceFieldLCDTextGeoProc
:
:
kMaxTextures
=
=
kMaxTextures
)
;
#
endif
auto
primProcProxies
=
target
-
>
allocPrimProcProxyPtrs
(
kMaxTextures
)
;
for
(
unsigned
i
=
0
;
i
<
numActiveViews
;
+
+
i
)
{
primProcProxies
[
i
]
=
views
[
i
]
.
proxy
(
)
;
target
-
>
sampledProxyArray
(
)
-
>
push_back
(
views
[
i
]
.
proxy
(
)
)
;
}
FlushInfo
flushInfo
;
flushInfo
.
fPrimProcProxies
=
primProcProxies
;
flushInfo
.
fIndexBuffer
=
resourceProvider
-
>
refNonAAQuadIndexBuffer
(
)
;
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
if
(
this
-
>
usesDistanceFields
(
)
)
{
flushInfo
.
fGeometryProcessor
=
this
-
>
setupDfProcessor
(
target
-
>
allocator
(
)
*
target
-
>
caps
(
)
.
shaderCaps
(
)
localMatrix
views
numActiveViews
)
;
}
else
#
endif
{
auto
filter
=
fNeedsGlyphTransform
?
GrSamplerState
:
:
Filter
:
:
kLinear
:
GrSamplerState
:
:
Filter
:
:
kNearest
;
flushInfo
.
fGeometryProcessor
=
GrBitmapTextGeoProc
:
:
Make
(
target
-
>
allocator
(
)
*
target
-
>
caps
(
)
.
shaderCaps
(
)
fHead
-
>
fColor
false
views
numActiveViews
filter
maskFormat
localMatrix
fHasPerspective
)
;
}
const
int
vertexStride
=
(
int
)
flushInfo
.
fGeometryProcessor
-
>
vertexStride
(
)
;
static
const
int
kMaxVertexBytes
=
GrBufferAllocPool
:
:
kDefaultBufferSize
;
const
int
quadSize
=
vertexStride
*
kVerticesPerGlyph
;
const
int
maxQuadsPerBuffer
=
kMaxVertexBytes
/
quadSize
;
int
allGlyphsCursor
=
0
;
const
int
allGlyphsEnd
=
fNumGlyphs
;
int
quadCursor
;
int
quadEnd
;
char
*
vertices
;
auto
resetVertexBuffer
=
[
&
]
{
quadCursor
=
0
;
quadEnd
=
std
:
:
min
(
maxQuadsPerBuffer
allGlyphsEnd
-
allGlyphsCursor
)
;
vertices
=
(
char
*
)
target
-
>
makeVertexSpace
(
vertexStride
kVerticesPerGlyph
*
quadEnd
&
flushInfo
.
fVertexBuffer
&
flushInfo
.
fVertexOffset
)
;
if
(
!
vertices
|
|
!
flushInfo
.
fVertexBuffer
)
{
SkDebugf
(
"
Could
not
allocate
vertices
\
n
"
)
;
return
false
;
}
return
true
;
}
;
if
(
!
resetVertexBuffer
(
)
)
{
return
;
}
for
(
const
Geometry
*
geo
=
fHead
;
geo
!
=
nullptr
;
geo
=
geo
-
>
fNext
)
{
const
sktext
:
:
gpu
:
:
AtlasSubRun
&
subRun
=
geo
-
>
fSubRun
;
SkASSERTF
(
(
int
)
subRun
.
vertexStride
(
geo
-
>
fDrawMatrix
)
=
=
vertexStride
"
subRun
stride
:
%
d
vertex
buffer
stride
:
%
d
\
n
"
(
int
)
subRun
.
vertexStride
(
geo
-
>
fDrawMatrix
)
vertexStride
)
;
const
int
subRunEnd
=
subRun
.
glyphCount
(
)
;
for
(
int
subRunCursor
=
0
;
subRunCursor
<
subRunEnd
;
)
{
int
regenEnd
=
subRunCursor
+
std
:
:
min
(
subRunEnd
-
subRunCursor
quadEnd
-
quadCursor
)
;
auto
[
ok
glyphsRegenerated
]
=
subRun
.
regenerateAtlas
(
subRunCursor
regenEnd
target
)
;
if
(
!
ok
)
{
return
;
}
geo
-
>
fillVertexData
(
vertices
+
quadCursor
*
quadSize
subRunCursor
glyphsRegenerated
)
;
subRunCursor
+
=
glyphsRegenerated
;
quadCursor
+
=
glyphsRegenerated
;
allGlyphsCursor
+
=
glyphsRegenerated
;
flushInfo
.
fGlyphsToFlush
+
=
glyphsRegenerated
;
if
(
quadCursor
=
=
quadEnd
|
|
subRunCursor
<
subRunEnd
)
{
if
(
subRunCursor
<
subRunEnd
)
{
ATRACE_ANDROID_FRAMEWORK_ALWAYS
(
"
Atlas
full
"
)
;
}
this
-
>
createDrawForGeneratedGlyphs
(
target
&
flushInfo
)
;
if
(
quadCursor
=
=
quadEnd
&
&
allGlyphsCursor
<
allGlyphsEnd
)
{
if
(
!
resetVertexBuffer
(
)
)
{
return
;
}
}
}
}
}
}
void
AtlasTextOp
:
:
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
{
auto
pipeline
=
GrSimpleMeshDrawOpHelper
:
:
CreatePipeline
(
flushState
std
:
:
move
(
fProcessors
)
GrPipeline
:
:
InputFlags
:
:
kNone
)
;
flushState
-
>
executeDrawsAndUploadsForMeshDrawOp
(
this
chainBounds
pipeline
&
GrUserStencilSettings
:
:
kUnused
)
;
}
void
AtlasTextOp
:
:
createDrawForGeneratedGlyphs
(
GrMeshDrawTarget
*
target
FlushInfo
*
flushInfo
)
const
{
if
(
!
flushInfo
-
>
fGlyphsToFlush
)
{
return
;
}
auto
atlasManager
=
target
-
>
atlasManager
(
)
;
GrGeometryProcessor
*
gp
=
flushInfo
-
>
fGeometryProcessor
;
MaskFormat
maskFormat
=
this
-
>
maskFormat
(
)
;
unsigned
int
numActiveViews
;
const
GrSurfaceProxyView
*
views
=
atlasManager
-
>
getViews
(
maskFormat
&
numActiveViews
)
;
SkASSERT
(
views
)
;
if
(
!
views
|
|
0
=
=
numActiveViews
)
{
return
;
}
if
(
gp
-
>
numTextureSamplers
(
)
!
=
(
int
)
numActiveViews
)
{
for
(
unsigned
i
=
gp
-
>
numTextureSamplers
(
)
;
i
<
numActiveViews
;
+
+
i
)
{
flushInfo
-
>
fPrimProcProxies
[
i
]
=
views
[
i
]
.
proxy
(
)
;
target
-
>
sampledProxyArray
(
)
-
>
push_back
(
views
[
i
]
.
proxy
(
)
)
;
for
(
int
d
=
0
;
d
<
flushInfo
-
>
fNumDraws
;
+
+
d
)
{
flushInfo
-
>
fPrimProcProxies
[
i
]
-
>
ref
(
)
;
}
}
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
if
(
this
-
>
usesDistanceFields
(
)
)
{
if
(
this
-
>
isLCD
(
)
)
{
reinterpret_cast
<
GrDistanceFieldLCDTextGeoProc
*
>
(
gp
)
-
>
addNewViews
(
views
numActiveViews
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
}
else
{
reinterpret_cast
<
GrDistanceFieldA8TextGeoProc
*
>
(
gp
)
-
>
addNewViews
(
views
numActiveViews
GrSamplerState
:
:
Filter
:
:
kLinear
)
;
}
}
else
#
endif
{
auto
filter
=
fNeedsGlyphTransform
?
GrSamplerState
:
:
Filter
:
:
kLinear
:
GrSamplerState
:
:
Filter
:
:
kNearest
;
reinterpret_cast
<
GrBitmapTextGeoProc
*
>
(
gp
)
-
>
addNewViews
(
views
numActiveViews
filter
)
;
}
}
int
maxGlyphsPerDraw
=
static_cast
<
int
>
(
flushInfo
-
>
fIndexBuffer
-
>
size
(
)
/
sizeof
(
uint16_t
)
/
6
)
;
GrSimpleMesh
*
mesh
=
target
-
>
allocMesh
(
)
;
mesh
-
>
setIndexedPatterned
(
flushInfo
-
>
fIndexBuffer
kIndicesPerGlyph
flushInfo
-
>
fGlyphsToFlush
maxGlyphsPerDraw
flushInfo
-
>
fVertexBuffer
kVerticesPerGlyph
flushInfo
-
>
fVertexOffset
)
;
target
-
>
recordDraw
(
flushInfo
-
>
fGeometryProcessor
mesh
1
flushInfo
-
>
fPrimProcProxies
GrPrimitiveType
:
:
kTriangles
)
;
flushInfo
-
>
fVertexOffset
+
=
kVerticesPerGlyph
*
flushInfo
-
>
fGlyphsToFlush
;
flushInfo
-
>
fGlyphsToFlush
=
0
;
+
+
flushInfo
-
>
fNumDraws
;
}
GrOp
:
:
CombineResult
AtlasTextOp
:
:
onCombineIfPossible
(
GrOp
*
t
SkArenaAlloc
*
const
GrCaps
&
caps
)
{
auto
that
=
t
-
>
cast
<
AtlasTextOp
>
(
)
;
if
(
fDFGPFlags
!
=
that
-
>
fDFGPFlags
|
|
fMaskType
!
=
that
-
>
fMaskType
|
|
fUsesLocalCoords
!
=
that
-
>
fUsesLocalCoords
|
|
fNeedsGlyphTransform
!
=
that
-
>
fNeedsGlyphTransform
|
|
fHasPerspective
!
=
that
-
>
fHasPerspective
|
|
fUseGammaCorrectDistanceTable
!
=
that
-
>
fUseGammaCorrectDistanceTable
)
{
return
CombineResult
:
:
kCannotCombine
;
}
if
(
fProcessors
!
=
that
-
>
fProcessors
)
{
return
CombineResult
:
:
kCannotCombine
;
}
if
(
fUsesLocalCoords
)
{
const
SkMatrix
&
thisFirstMatrix
=
fHead
-
>
fDrawMatrix
;
const
SkMatrix
&
thatFirstMatrix
=
that
-
>
fHead
-
>
fDrawMatrix
;
if
(
!
SkMatrixPriv
:
:
CheapEqual
(
thisFirstMatrix
thatFirstMatrix
)
)
{
return
CombineResult
:
:
kCannotCombine
;
}
}
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
if
(
this
-
>
usesDistanceFields
(
)
)
{
SkASSERT
(
that
-
>
usesDistanceFields
(
)
)
;
if
(
fLuminanceColor
!
=
that
-
>
fLuminanceColor
)
{
return
CombineResult
:
:
kCannotCombine
;
}
}
else
#
endif
{
if
(
this
-
>
maskType
(
)
=
=
MaskType
:
:
kColorBitmap
&
&
fHead
-
>
fColor
!
=
that
-
>
fHead
-
>
fColor
)
{
return
CombineResult
:
:
kCannotCombine
;
}
}
fNumGlyphs
+
=
that
-
>
fNumGlyphs
;
this
-
>
addGeometry
(
that
-
>
fHead
)
;
that
-
>
fHead
=
nullptr
;
return
CombineResult
:
:
kMerged
;
}
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
GrGeometryProcessor
*
AtlasTextOp
:
:
setupDfProcessor
(
SkArenaAlloc
*
arena
const
GrShaderCaps
&
caps
const
SkMatrix
&
localMatrix
const
GrSurfaceProxyView
*
views
unsigned
int
numActiveViews
)
const
{
static
constexpr
int
kDistanceAdjustLumShift
=
5
;
auto
dfAdjustTable
=
sktext
:
:
gpu
:
:
DistanceFieldAdjustTable
:
:
Get
(
)
;
if
(
this
-
>
isLCD
(
)
)
{
float
redCorrection
=
dfAdjustTable
-
>
getAdjustment
(
SkColorGetR
(
fLuminanceColor
)
>
>
kDistanceAdjustLumShift
fUseGammaCorrectDistanceTable
)
;
float
greenCorrection
=
dfAdjustTable
-
>
getAdjustment
(
SkColorGetG
(
fLuminanceColor
)
>
>
kDistanceAdjustLumShift
fUseGammaCorrectDistanceTable
)
;
float
blueCorrection
=
dfAdjustTable
-
>
getAdjustment
(
SkColorGetB
(
fLuminanceColor
)
>
>
kDistanceAdjustLumShift
fUseGammaCorrectDistanceTable
)
;
GrDistanceFieldLCDTextGeoProc
:
:
DistanceAdjust
widthAdjust
=
GrDistanceFieldLCDTextGeoProc
:
:
DistanceAdjust
:
:
Make
(
redCorrection
greenCorrection
blueCorrection
)
;
return
GrDistanceFieldLCDTextGeoProc
:
:
Make
(
arena
caps
views
numActiveViews
GrSamplerState
:
:
Filter
:
:
kLinear
widthAdjust
fDFGPFlags
localMatrix
)
;
}
else
{
#
ifdef
SK_GAMMA_APPLY_TO_A8
float
correction
=
0
;
if
(
this
-
>
maskType
(
)
!
=
MaskType
:
:
kAliasedDistanceField
)
{
U8CPU
lum
=
SkColorSpaceLuminance
:
:
computeLuminance
(
SK_GAMMA_EXPONENT
fLuminanceColor
)
;
correction
=
dfAdjustTable
-
>
getAdjustment
(
lum
>
>
kDistanceAdjustLumShift
fUseGammaCorrectDistanceTable
)
;
}
return
GrDistanceFieldA8TextGeoProc
:
:
Make
(
arena
caps
views
numActiveViews
GrSamplerState
:
:
Filter
:
:
kLinear
correction
fDFGPFlags
localMatrix
)
;
#
else
return
GrDistanceFieldA8TextGeoProc
:
:
Make
(
arena
caps
views
numActiveViews
GrSamplerState
:
:
Filter
:
:
kLinear
fDFGPFlags
localMatrix
)
;
#
endif
}
}
#
endif
#
if
GR_TEST_UTILS
GrOp
:
:
Owner
AtlasTextOp
:
:
CreateOpTestingOnly
(
skgpu
:
:
ganesh
:
:
SurfaceDrawContext
*
sdc
const
SkPaint
&
skPaint
const
SkFont
&
font
const
SkMatrixProvider
&
mtxProvider
const
char
*
text
int
x
int
y
)
{
size_t
textLen
=
(
int
)
strlen
(
text
)
;
SkMatrix
drawMatrix
(
mtxProvider
.
localToDevice
(
)
)
;
drawMatrix
.
preTranslate
(
x
y
)
;
auto
drawOrigin
=
SkPoint
:
:
Make
(
x
y
)
;
sktext
:
:
GlyphRunBuilder
builder
;
auto
glyphRunList
=
builder
.
textToGlyphRunList
(
font
skPaint
text
textLen
drawOrigin
)
;
if
(
glyphRunList
.
empty
(
)
)
{
return
nullptr
;
}
auto
rContext
=
sdc
-
>
recordingContext
(
)
;
sktext
:
:
gpu
:
:
SDFTControl
control
=
rContext
-
>
priv
(
)
.
getSDFTControl
(
sdc
-
>
surfaceProps
(
)
.
isUseDeviceIndependentFonts
(
)
)
;
SkStrikeDeviceInfo
strikeDeviceInfo
{
sdc
-
>
surfaceProps
(
)
SkScalerContextFlags
:
:
kBoostContrast
&
control
}
;
sk_sp
<
sktext
:
:
gpu
:
:
TextBlob
>
blob
=
sktext
:
:
gpu
:
:
TextBlob
:
:
Make
(
glyphRunList
skPaint
drawMatrix
strikeDeviceInfo
SkStrikeCache
:
:
GlobalStrikeCache
(
)
)
;
const
sktext
:
:
gpu
:
:
AtlasSubRun
*
subRun
=
blob
-
>
testingOnlyFirstSubRun
(
)
;
if
(
!
subRun
)
{
return
nullptr
;
}
GrOp
:
:
Owner
op
;
std
:
:
tie
(
std
:
:
ignore
op
)
=
subRun
-
>
makeAtlasTextOp
(
nullptr
mtxProvider
glyphRunList
.
origin
(
)
skPaint
blob
sdc
)
;
return
op
;
}
#
endif
}
#
if
GR_TEST_UTILS
GR_DRAW_OP_TEST_DEFINE
(
AtlasTextOp
)
{
SkMatrixProvider
matrixProvider
(
GrTest
:
:
TestMatrixInvertible
(
random
)
)
;
SkPaint
skPaint
;
skPaint
.
setColor
(
random
-
>
nextU
(
)
)
;
SkFont
font
;
if
(
random
-
>
nextBool
(
)
)
{
font
.
setEdging
(
SkFont
:
:
Edging
:
:
kSubpixelAntiAlias
)
;
}
else
{
font
.
setEdging
(
random
-
>
nextBool
(
)
?
SkFont
:
:
Edging
:
:
kAntiAlias
:
SkFont
:
:
Edging
:
:
kAlias
)
;
}
font
.
setSubpixel
(
random
-
>
nextBool
(
)
)
;
const
char
*
text
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
.
"
;
static
const
int
kMaxTrans
=
1024
;
int
xPos
=
(
random
-
>
nextU
(
)
%
2
)
*
2
-
1
;
int
yPos
=
(
random
-
>
nextU
(
)
%
2
)
*
2
-
1
;
int
xInt
=
(
random
-
>
nextU
(
)
%
kMaxTrans
)
*
xPos
;
int
yInt
=
(
random
-
>
nextU
(
)
%
kMaxTrans
)
*
yPos
;
return
skgpu
:
:
ganesh
:
:
AtlasTextOp
:
:
CreateOpTestingOnly
(
sdc
skPaint
font
matrixProvider
text
xInt
yInt
)
;
}
#
endif
