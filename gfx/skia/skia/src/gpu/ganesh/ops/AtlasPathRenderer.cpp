#
include
"
src
/
gpu
/
ganesh
/
ops
/
AtlasPathRenderer
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkIPoint16
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrClip
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
effects
/
GrModulateAtlasCoverageEffect
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
geometry
/
GrStyledShape
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
AtlasRenderTask
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
DrawAtlasPathOp
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
TessellationPathRenderer
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
tessellate
/
GrTessellationShader
.
h
"
namespace
{
std
:
:
pair
<
skvx
:
:
float2
skvx
:
:
float2
>
round_out
(
const
SkRect
&
r
)
{
return
{
floor
(
skvx
:
:
float2
:
:
Load
(
&
r
.
fLeft
)
)
ceil
(
skvx
:
:
float2
:
:
Load
(
&
r
.
fRight
)
)
}
;
}
template
<
typename
T
>
bool
refs_atlas
(
const
T
*
proxyOwner
const
GrSurfaceProxy
*
atlasProxy
)
{
bool
refsAtlas
=
false
;
auto
checkForAtlasRef
=
[
atlasProxy
&
refsAtlas
]
(
GrSurfaceProxy
*
proxy
GrMipmapped
)
{
if
(
proxy
=
=
atlasProxy
)
{
refsAtlas
=
true
;
}
}
;
if
(
proxyOwner
)
{
proxyOwner
-
>
visitProxies
(
checkForAtlasRef
)
;
}
return
refsAtlas
;
}
bool
is_visible
(
const
SkRect
&
pathDevBounds
const
SkIRect
&
clipBounds
)
{
auto
pathTopLeft
=
skvx
:
:
float2
:
:
Load
(
&
pathDevBounds
.
fLeft
)
;
auto
pathBotRight
=
skvx
:
:
float2
:
:
Load
(
&
pathDevBounds
.
fRight
)
;
if
(
!
all
(
pathTopLeft
<
pathBotRight
)
)
{
return
false
;
}
auto
clipTopLeft
=
skvx
:
:
cast
<
float
>
(
skvx
:
:
int2
:
:
Load
(
&
clipBounds
.
fLeft
)
)
;
auto
clipBotRight
=
skvx
:
:
cast
<
float
>
(
skvx
:
:
int2
:
:
Load
(
&
clipBounds
.
fRight
)
)
;
static_assert
(
sizeof
(
clipBounds
)
=
=
sizeof
(
clipTopLeft
)
+
sizeof
(
clipBotRight
)
)
;
return
all
(
pathTopLeft
<
clipBotRight
)
&
&
all
(
pathBotRight
>
clipTopLeft
)
;
}
#
ifdef
SK_DEBUG
void
validate_atlas_dependencies
(
const
SkTArray
<
sk_sp
<
skgpu
:
:
ganesh
:
:
AtlasRenderTask
>
>
&
atlasTasks
)
{
for
(
int
i
=
atlasTasks
.
size
(
)
-
1
;
i
>
=
1
;
-
-
i
)
{
auto
atlasTask
=
atlasTasks
[
i
]
.
get
(
)
;
auto
previousAtlasTask
=
atlasTasks
[
i
-
1
]
.
get
(
)
;
for
(
GrRenderTask
*
previousAtlasUser
:
previousAtlasTask
-
>
dependents
(
)
)
{
SkASSERT
(
atlasTask
-
>
dependsOn
(
previousAtlasUser
)
)
;
}
}
}
#
endif
}
namespace
skgpu
:
:
ganesh
{
constexpr
static
auto
kAtlasAlpha8Type
=
GrColorType
:
:
kAlpha_8
;
constexpr
static
int
kAtlasInitialSize
=
512
;
constexpr
static
auto
kAtlasAlgorithm
=
GrDynamicAtlas
:
:
RectanizerAlgorithm
:
:
kPow2
;
constexpr
static
int
kAtlasMaxPathHeight
=
256
;
constexpr
static
int
kAtlasMaxPathHeightWithMSAAFallback
=
128
;
constexpr
static
int
kAtlasMaxPathWidth
=
1024
;
bool
AtlasPathRenderer
:
:
IsSupported
(
GrRecordingContext
*
rContext
)
{
#
ifdef
SK_BUILD_FOR_IOS
if
(
rContext
-
>
backend
(
)
=
=
GrBackendApi
:
:
kOpenGL
)
{
return
false
;
}
#
endif
#
ifdef
SK_BUILD_FOR_WIN
if
(
rContext
-
>
backend
(
)
=
=
GrBackendApi
:
:
kDirect3D
)
{
return
false
;
}
#
endif
const
GrCaps
&
caps
=
*
rContext
-
>
priv
(
)
.
caps
(
)
;
auto
atlasFormat
=
caps
.
getDefaultBackendFormat
(
kAtlasAlpha8Type
GrRenderable
:
:
kYes
)
;
return
rContext
-
>
asDirectContext
(
)
&
&
caps
.
internalMultisampleCount
(
atlasFormat
)
>
1
&
&
TessellationPathRenderer
:
:
IsSupported
(
caps
)
;
}
sk_sp
<
AtlasPathRenderer
>
AtlasPathRenderer
:
:
Make
(
GrRecordingContext
*
rContext
)
{
return
IsSupported
(
rContext
)
?
sk_sp
<
AtlasPathRenderer
>
(
new
AtlasPathRenderer
(
rContext
-
>
asDirectContext
(
)
)
)
:
nullptr
;
}
AtlasPathRenderer
:
:
AtlasPathRenderer
(
GrDirectContext
*
dContext
)
{
SkASSERT
(
IsSupported
(
dContext
)
)
;
const
GrCaps
&
caps
=
*
dContext
-
>
priv
(
)
.
caps
(
)
;
#
if
GR_TEST_UTILS
fAtlasMaxSize
=
dContext
-
>
priv
(
)
.
options
(
)
.
fMaxTextureAtlasSize
;
#
else
fAtlasMaxSize
=
2048
;
#
endif
fAtlasMaxSize
=
SkPrevPow2
(
std
:
:
min
(
fAtlasMaxSize
(
float
)
caps
.
maxPreferredRenderTargetSize
(
)
)
)
;
fAtlasMaxPathWidth
=
std
:
:
min
(
(
float
)
kAtlasMaxPathWidth
fAtlasMaxSize
)
;
fAtlasInitialSize
=
SkNextPow2
(
std
:
:
min
(
kAtlasInitialSize
(
int
)
fAtlasMaxSize
)
)
;
}
bool
AtlasPathRenderer
:
:
pathFitsInAtlas
(
const
SkRect
&
pathDevBounds
GrAAType
fallbackAAType
)
const
{
SkASSERT
(
fallbackAAType
!
=
GrAAType
:
:
kNone
)
;
float
atlasMaxPathHeight_p2
=
(
fallbackAAType
=
=
GrAAType
:
:
kMSAA
)
?
kAtlasMaxPathHeightWithMSAAFallback
*
kAtlasMaxPathHeightWithMSAAFallback
:
kAtlasMaxPathHeight
*
kAtlasMaxPathHeight
;
auto
[
topLeftFloor
botRightCeil
]
=
round_out
(
pathDevBounds
)
;
auto
size
=
botRightCeil
-
topLeftFloor
;
return
all
(
size
<
=
fAtlasMaxPathWidth
)
&
&
size
[
0
]
*
size
[
1
]
<
=
atlasMaxPathHeight_p2
;
}
void
AtlasPathRenderer
:
:
AtlasPathKey
:
:
set
(
const
SkMatrix
&
m
const
SkPath
&
path
)
{
fPathGenID
=
path
.
getGenerationID
(
)
;
fAffineMatrix
[
0
]
=
m
.
getScaleX
(
)
;
fAffineMatrix
[
1
]
=
m
.
getSkewX
(
)
;
fAffineMatrix
[
2
]
=
m
.
getTranslateX
(
)
;
fAffineMatrix
[
3
]
=
m
.
getSkewY
(
)
;
fAffineMatrix
[
4
]
=
m
.
getScaleY
(
)
;
fAffineMatrix
[
5
]
=
m
.
getTranslateY
(
)
;
fFillRule
=
(
uint32_t
)
GrFillRuleForSkPath
(
path
)
;
}
bool
AtlasPathRenderer
:
:
addPathToAtlas
(
GrRecordingContext
*
rContext
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkRect
&
pathDevBounds
SkIRect
*
devIBounds
SkIPoint16
*
locationInAtlas
bool
*
transposedInAtlas
const
DrawRefsAtlasCallback
&
drawRefsAtlasCallback
)
{
SkASSERT
(
!
viewMatrix
.
hasPerspective
(
)
)
;
pathDevBounds
.
roundOut
(
devIBounds
)
;
#
ifdef
SK_DEBUG
auto
[
topLeftFloor
botRightCeil
]
=
round_out
(
pathDevBounds
)
;
SkASSERT
(
all
(
skvx
:
:
cast
<
float
>
(
skvx
:
:
int2
:
:
Load
(
&
devIBounds
-
>
fLeft
)
)
=
=
topLeftFloor
)
)
;
SkASSERT
(
all
(
skvx
:
:
cast
<
float
>
(
skvx
:
:
int2
:
:
Load
(
&
devIBounds
-
>
fRight
)
)
=
=
botRightCeil
)
)
;
#
endif
int
widthInAtlas
=
devIBounds
-
>
width
(
)
;
int
heightInAtlas
=
devIBounds
-
>
height
(
)
;
SkASSERT
(
widthInAtlas
>
0
&
&
heightInAtlas
>
0
)
;
if
(
SkNextPow2
(
widthInAtlas
)
=
=
SkNextPow2
(
heightInAtlas
)
)
{
*
transposedInAtlas
=
widthInAtlas
>
heightInAtlas
;
}
else
{
*
transposedInAtlas
=
heightInAtlas
>
widthInAtlas
;
}
if
(
*
transposedInAtlas
)
{
std
:
:
swap
(
heightInAtlas
widthInAtlas
)
;
}
SkASSERT
(
widthInAtlas
<
=
(
int
)
fAtlasMaxPathWidth
)
;
SkASSERT
(
heightInAtlas
<
=
kAtlasMaxPathHeight
)
;
AtlasPathKey
atlasPathKey
;
if
(
!
path
.
isVolatile
(
)
)
{
atlasPathKey
.
set
(
viewMatrix
path
)
;
if
(
const
SkIPoint16
*
existingLocation
=
fAtlasPathCache
.
find
(
atlasPathKey
)
)
{
*
locationInAtlas
=
*
existingLocation
;
return
true
;
}
}
if
(
fAtlasRenderTasks
.
empty
(
)
|
|
!
fAtlasRenderTasks
.
back
(
)
-
>
addPath
(
viewMatrix
path
devIBounds
-
>
topLeft
(
)
widthInAtlas
heightInAtlas
*
transposedInAtlas
locationInAtlas
)
)
{
auto
currentAtlasTask
=
(
!
fAtlasRenderTasks
.
empty
(
)
)
?
fAtlasRenderTasks
.
back
(
)
.
get
(
)
:
nullptr
;
if
(
currentAtlasTask
&
&
drawRefsAtlasCallback
&
&
drawRefsAtlasCallback
(
currentAtlasTask
-
>
atlasProxy
(
)
)
)
{
return
false
;
}
auto
dynamicAtlas
=
std
:
:
make_unique
<
GrDynamicAtlas
>
(
kAtlasAlpha8Type
GrDynamicAtlas
:
:
InternalMultisample
:
:
kYes
SkISize
{
fAtlasInitialSize
fAtlasInitialSize
}
fAtlasMaxSize
*
rContext
-
>
priv
(
)
.
caps
(
)
kAtlasAlgorithm
)
;
auto
newAtlasTask
=
sk_make_sp
<
AtlasRenderTask
>
(
rContext
sk_make_sp
<
GrArenas
>
(
)
std
:
:
move
(
dynamicAtlas
)
)
;
rContext
-
>
priv
(
)
.
drawingManager
(
)
-
>
addAtlasTask
(
newAtlasTask
currentAtlasTask
)
;
SkAssertResult
(
newAtlasTask
-
>
addPath
(
viewMatrix
path
devIBounds
-
>
topLeft
(
)
widthInAtlas
heightInAtlas
*
transposedInAtlas
locationInAtlas
)
)
;
fAtlasRenderTasks
.
push_back
(
std
:
:
move
(
newAtlasTask
)
)
;
fAtlasPathCache
.
reset
(
)
;
}
if
(
!
path
.
isVolatile
(
)
)
{
fAtlasPathCache
.
set
(
atlasPathKey
*
locationInAtlas
)
;
}
return
true
;
}
PathRenderer
:
:
CanDrawPath
AtlasPathRenderer
:
:
onCanDrawPath
(
const
CanDrawPathArgs
&
args
)
const
{
#
ifdef
SK_DEBUG
if
(
!
fAtlasRenderTasks
.
empty
(
)
)
{
const
GrSurfaceProxy
*
atlasProxy
=
fAtlasRenderTasks
.
back
(
)
-
>
atlasProxy
(
)
;
SkASSERT
(
!
refs_atlas
(
args
.
fPaint
-
>
getColorFragmentProcessor
(
)
atlasProxy
)
)
;
SkASSERT
(
!
refs_atlas
(
args
.
fPaint
-
>
getCoverageFragmentProcessor
(
)
atlasProxy
)
)
;
}
SkASSERT
(
!
args
.
fHasUserStencilSettings
)
;
#
endif
bool
canDrawPath
=
args
.
fShape
-
>
style
(
)
.
isSimpleFill
(
)
&
&
#
ifdef
SK_DISABLE_ATLAS_PATH_RENDERER_WITH_COVERAGE_AA
args
.
fAAType
=
=
GrAAType
:
:
kMSAA
&
&
#
else
args
.
fAAType
!
=
GrAAType
:
:
kNone
&
&
#
endif
(
args
.
fProxy
-
>
numSamples
(
)
=
=
1
|
|
!
args
.
fShape
-
>
knownToBeConvex
(
)
)
&
&
!
args
.
fShape
-
>
style
(
)
.
hasPathEffect
(
)
&
&
!
args
.
fViewMatrix
-
>
hasPerspective
(
)
&
&
this
-
>
pathFitsInAtlas
(
args
.
fViewMatrix
-
>
mapRect
(
args
.
fShape
-
>
bounds
(
)
)
args
.
fAAType
)
;
return
canDrawPath
?
CanDrawPath
:
:
kYes
:
CanDrawPath
:
:
kNo
;
}
bool
AtlasPathRenderer
:
:
onDrawPath
(
const
DrawPathArgs
&
args
)
{
SkPath
path
;
args
.
fShape
-
>
asPath
(
&
path
)
;
const
SkRect
pathDevBounds
=
args
.
fViewMatrix
-
>
mapRect
(
args
.
fShape
-
>
bounds
(
)
)
;
SkASSERT
(
this
-
>
pathFitsInAtlas
(
pathDevBounds
args
.
fAAType
)
)
;
if
(
!
is_visible
(
pathDevBounds
args
.
fClip
-
>
getConservativeBounds
(
)
)
)
{
if
(
path
.
isInverseFillType
(
)
)
{
args
.
fSurfaceDrawContext
-
>
drawPaint
(
args
.
fClip
std
:
:
move
(
args
.
fPaint
)
*
args
.
fViewMatrix
)
;
}
return
true
;
}
SkIRect
devIBounds
;
SkIPoint16
locationInAtlas
;
bool
transposedInAtlas
;
SkAssertResult
(
this
-
>
addPathToAtlas
(
args
.
fContext
*
args
.
fViewMatrix
path
pathDevBounds
&
devIBounds
&
locationInAtlas
&
transposedInAtlas
nullptr
)
)
;
const
SkIRect
&
fillBounds
=
args
.
fShape
-
>
inverseFilled
(
)
?
(
args
.
fClip
?
args
.
fClip
-
>
getConservativeBounds
(
)
:
args
.
fSurfaceDrawContext
-
>
asSurfaceProxy
(
)
-
>
backingStoreBoundsIRect
(
)
)
:
devIBounds
;
const
GrCaps
&
caps
=
*
args
.
fSurfaceDrawContext
-
>
caps
(
)
;
auto
op
=
GrOp
:
:
Make
<
DrawAtlasPathOp
>
(
args
.
fContext
args
.
fSurfaceDrawContext
-
>
arenaAlloc
(
)
fillBounds
*
args
.
fViewMatrix
std
:
:
move
(
args
.
fPaint
)
locationInAtlas
devIBounds
transposedInAtlas
fAtlasRenderTasks
.
back
(
)
-
>
readView
(
caps
)
args
.
fShape
-
>
inverseFilled
(
)
)
;
args
.
fSurfaceDrawContext
-
>
addDrawOp
(
args
.
fClip
std
:
:
move
(
op
)
)
;
return
true
;
}
GrFPResult
AtlasPathRenderer
:
:
makeAtlasClipEffect
(
const
SurfaceDrawContext
*
sdc
const
GrOp
*
opBeingClipped
std
:
:
unique_ptr
<
GrFragmentProcessor
>
inputFP
const
SkIRect
&
drawBounds
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
)
{
if
(
viewMatrix
.
hasPerspective
(
)
)
{
return
GrFPFailure
(
std
:
:
move
(
inputFP
)
)
;
}
const
SkRect
pathDevBounds
=
viewMatrix
.
mapRect
(
path
.
getBounds
(
)
)
;
if
(
!
is_visible
(
pathDevBounds
drawBounds
)
)
{
return
path
.
isInverseFillType
(
)
?
GrFPNullableSuccess
(
std
:
:
move
(
inputFP
)
)
:
GrFPFailure
(
std
:
:
move
(
inputFP
)
)
;
}
auto
fallbackAAType
=
(
sdc
-
>
numSamples
(
)
>
1
|
|
sdc
-
>
canUseDynamicMSAA
(
)
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kCoverage
;
if
(
!
this
-
>
pathFitsInAtlas
(
pathDevBounds
fallbackAAType
)
)
{
return
GrFPFailure
(
std
:
:
move
(
inputFP
)
)
;
}
SkIRect
devIBounds
;
SkIPoint16
locationInAtlas
;
bool
transposedInAtlas
;
auto
drawRefsAtlasCallback
=
[
opBeingClipped
&
inputFP
]
(
const
GrSurfaceProxy
*
atlasProxy
)
{
return
refs_atlas
(
opBeingClipped
atlasProxy
)
|
|
refs_atlas
(
inputFP
.
get
(
)
atlasProxy
)
;
}
;
if
(
!
this
-
>
addPathToAtlas
(
sdc
-
>
recordingContext
(
)
viewMatrix
path
pathDevBounds
&
devIBounds
&
locationInAtlas
&
transposedInAtlas
drawRefsAtlasCallback
)
)
{
return
GrFPFailure
(
std
:
:
move
(
inputFP
)
)
;
}
SkMatrix
atlasMatrix
;
auto
[
atlasX
atlasY
]
=
locationInAtlas
;
if
(
!
transposedInAtlas
)
{
atlasMatrix
=
SkMatrix
:
:
Translate
(
atlasX
-
devIBounds
.
left
(
)
atlasY
-
devIBounds
.
top
(
)
)
;
}
else
{
atlasMatrix
.
setAll
(
0
1
atlasX
-
devIBounds
.
top
(
)
1
0
atlasY
-
devIBounds
.
left
(
)
0
0
1
)
;
}
auto
flags
=
GrModulateAtlasCoverageEffect
:
:
Flags
:
:
kNone
;
if
(
path
.
isInverseFillType
(
)
)
{
flags
|
=
GrModulateAtlasCoverageEffect
:
:
Flags
:
:
kInvertCoverage
;
}
if
(
!
devIBounds
.
contains
(
drawBounds
)
)
{
flags
|
=
GrModulateAtlasCoverageEffect
:
:
Flags
:
:
kCheckBounds
;
SkASSERT
(
path
.
isInverseFillType
(
)
)
;
}
GrSurfaceProxyView
atlasView
=
fAtlasRenderTasks
.
back
(
)
-
>
readView
(
*
sdc
-
>
caps
(
)
)
;
return
GrFPSuccess
(
std
:
:
make_unique
<
GrModulateAtlasCoverageEffect
>
(
flags
std
:
:
move
(
inputFP
)
std
:
:
move
(
atlasView
)
atlasMatrix
devIBounds
)
)
;
}
bool
AtlasPathRenderer
:
:
preFlush
(
GrOnFlushResourceProvider
*
onFlushRP
)
{
if
(
fAtlasRenderTasks
.
empty
(
)
)
{
SkASSERT
(
fAtlasPathCache
.
count
(
)
=
=
0
)
;
return
true
;
}
SkDEBUGCODE
(
validate_atlas_dependencies
(
fAtlasRenderTasks
)
;
)
bool
successful
;
#
if
GR_TEST_UTILS
if
(
onFlushRP
-
>
failFlushTimeCallbacks
(
)
)
{
successful
=
false
;
}
else
#
endif
{
successful
=
fAtlasRenderTasks
[
0
]
-
>
instantiate
(
onFlushRP
)
;
GrTexture
*
firstAtlas
=
fAtlasRenderTasks
[
0
]
-
>
atlasProxy
(
)
-
>
peekTexture
(
)
;
SkASSERT
(
firstAtlas
)
;
for
(
int
i
=
1
;
successful
&
&
i
<
fAtlasRenderTasks
.
size
(
)
;
+
+
i
)
{
auto
atlasTask
=
fAtlasRenderTasks
[
i
]
.
get
(
)
;
if
(
atlasTask
-
>
atlasProxy
(
)
-
>
backingStoreDimensions
(
)
=
=
firstAtlas
-
>
dimensions
(
)
)
{
successful
&
=
atlasTask
-
>
instantiate
(
onFlushRP
sk_ref_sp
(
firstAtlas
)
)
;
}
else
{
SkASSERT
(
i
=
=
fAtlasRenderTasks
.
size
(
)
-
1
)
;
SkASSERT
(
atlasTask
-
>
atlasProxy
(
)
-
>
backingStoreDimensions
(
)
.
area
(
)
<
firstAtlas
-
>
dimensions
(
)
.
area
(
)
)
;
successful
&
=
atlasTask
-
>
instantiate
(
onFlushRP
)
;
}
}
}
fAtlasRenderTasks
.
clear
(
)
;
fAtlasPathCache
.
reset
(
)
;
return
successful
;
}
}
