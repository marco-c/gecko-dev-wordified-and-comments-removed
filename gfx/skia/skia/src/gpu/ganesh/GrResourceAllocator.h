#
ifndef
GrResourceAllocator_DEFINED
#
define
GrResourceAllocator_DEFINED
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrHashMapWithCache
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurface
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
class
GrDirectContext
;
#
define
GR_ALLOCATION_SPEW
0
#
define
GR_TRACK_INTERVAL_CREATION
0
class
GrResourceAllocator
{
public
:
GrResourceAllocator
(
GrDirectContext
*
dContext
)
:
fDContext
(
dContext
)
{
}
~
GrResourceAllocator
(
)
;
unsigned
int
curOp
(
)
const
{
return
fNumOps
;
}
void
incOps
(
)
{
fNumOps
+
+
;
}
enum
class
ActualUse
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
addInterval
(
GrSurfaceProxy
*
unsigned
int
start
unsigned
int
end
ActualUse
actualUse
SkDEBUGCODE
(
bool
isDirectDstRead
=
false
)
)
;
bool
failedInstantiation
(
)
const
{
return
fFailedInstantiation
;
}
bool
planAssignment
(
)
;
bool
makeBudgetHeadroom
(
)
;
void
reset
(
)
;
bool
assign
(
)
;
#
if
GR_ALLOCATION_SPEW
void
dumpIntervals
(
)
;
#
endif
private
:
class
Interval
;
class
Register
;
void
expire
(
unsigned
int
curIndex
)
;
void
recycleRegister
(
Register
*
r
)
;
Register
*
findOrCreateRegisterFor
(
GrSurfaceProxy
*
proxy
)
;
struct
FreePoolTraits
{
static
const
skgpu
:
:
ScratchKey
&
GetKey
(
const
Register
&
r
)
{
return
r
.
scratchKey
(
)
;
}
static
uint32_t
Hash
(
const
skgpu
:
:
ScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
static
void
OnFree
(
Register
*
r
)
{
}
}
;
typedef
SkTMultiMap
<
Register
skgpu
:
:
ScratchKey
FreePoolTraits
>
FreePoolMultiMap
;
typedef
SkTHashMap
<
uint32_t
Interval
*
GrCheapHash
>
IntvlHash
;
struct
UniqueKeyHash
{
uint32_t
operator
(
)
(
const
skgpu
:
:
UniqueKey
&
key
)
const
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTHashMap
<
skgpu
:
:
UniqueKey
Register
*
UniqueKeyHash
>
UniqueKeyRegisterHash
;
class
Register
{
public
:
Register
(
GrSurfaceProxy
*
originatingProxy
skgpu
:
:
ScratchKey
GrResourceProvider
*
)
;
const
skgpu
:
:
ScratchKey
&
scratchKey
(
)
const
{
return
fScratchKey
;
}
const
skgpu
:
:
UniqueKey
&
uniqueKey
(
)
const
{
return
fOriginatingProxy
-
>
getUniqueKey
(
)
;
}
bool
accountedForInBudget
(
)
const
{
return
fAccountedForInBudget
;
}
void
setAccountedForInBudget
(
)
{
fAccountedForInBudget
=
true
;
}
GrSurface
*
existingSurface
(
)
const
{
return
fExistingSurface
.
get
(
)
;
}
bool
isRecyclable
(
const
GrCaps
&
GrSurfaceProxy
*
proxy
int
knownUseCount
)
const
;
bool
instantiateSurface
(
GrSurfaceProxy
*
GrResourceProvider
*
)
;
SkDEBUGCODE
(
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
)
private
:
GrSurfaceProxy
*
fOriginatingProxy
;
skgpu
:
:
ScratchKey
fScratchKey
;
sk_sp
<
GrSurface
>
fExistingSurface
;
bool
fAccountedForInBudget
=
false
;
#
ifdef
SK_DEBUG
uint32_t
fUniqueID
;
static
uint32_t
CreateUniqueID
(
)
;
#
endif
}
;
class
Interval
{
public
:
Interval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
)
:
fProxy
(
proxy
)
fStart
(
start
)
fEnd
(
end
)
{
SkASSERT
(
proxy
)
;
SkDEBUGCODE
(
fUniqueID
=
CreateUniqueID
(
)
)
;
#
if
GR_TRACK_INTERVAL_CREATION
SkString
proxyStr
=
proxy
-
>
dump
(
)
;
SkDebugf
(
"
New
intvl
%
d
:
%
s
[
%
d
%
d
]
\
n
"
fUniqueID
proxyStr
.
c_str
(
)
start
end
)
;
#
endif
}
const
GrSurfaceProxy
*
proxy
(
)
const
{
return
fProxy
;
}
GrSurfaceProxy
*
proxy
(
)
{
return
fProxy
;
}
unsigned
int
start
(
)
const
{
return
fStart
;
}
unsigned
int
end
(
)
const
{
return
fEnd
;
}
void
setNext
(
Interval
*
next
)
{
fNext
=
next
;
}
const
Interval
*
next
(
)
const
{
return
fNext
;
}
Interval
*
next
(
)
{
return
fNext
;
}
Register
*
getRegister
(
)
const
{
return
fRegister
;
}
void
setRegister
(
Register
*
r
)
{
fRegister
=
r
;
}
void
addUse
(
)
{
fUses
+
+
;
}
int
uses
(
)
const
{
return
fUses
;
}
void
extendEnd
(
unsigned
int
newEnd
)
{
if
(
newEnd
>
fEnd
)
{
fEnd
=
newEnd
;
#
if
GR_TRACK_INTERVAL_CREATION
SkDebugf
(
"
intvl
%
d
:
extending
from
%
d
to
%
d
\
n
"
fUniqueID
fEnd
newEnd
)
;
#
endif
}
}
SkDEBUGCODE
(
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
)
private
:
GrSurfaceProxy
*
fProxy
;
unsigned
int
fStart
;
unsigned
int
fEnd
;
Interval
*
fNext
=
nullptr
;
unsigned
int
fUses
=
0
;
Register
*
fRegister
=
nullptr
;
#
ifdef
SK_DEBUG
uint32_t
fUniqueID
;
static
uint32_t
CreateUniqueID
(
)
;
#
endif
}
;
class
IntervalList
{
public
:
IntervalList
(
)
=
default
;
bool
empty
(
)
const
{
SkASSERT
(
SkToBool
(
fHead
)
=
=
SkToBool
(
fTail
)
)
;
return
!
SkToBool
(
fHead
)
;
}
const
Interval
*
peekHead
(
)
const
{
return
fHead
;
}
Interval
*
peekHead
(
)
{
return
fHead
;
}
Interval
*
popHead
(
)
;
void
insertByIncreasingStart
(
Interval
*
)
;
void
insertByIncreasingEnd
(
Interval
*
)
;
private
:
SkDEBUGCODE
(
void
validate
(
)
const
;
)
Interval
*
fHead
=
nullptr
;
Interval
*
fTail
=
nullptr
;
}
;
static
const
int
kInitialArenaSize
=
128
*
sizeof
(
Interval
)
;
GrDirectContext
*
fDContext
;
FreePoolMultiMap
fFreePool
;
IntvlHash
fIntvlHash
;
IntervalList
fIntvlList
;
IntervalList
fActiveIntvls
;
IntervalList
fFinishedIntvls
;
UniqueKeyRegisterHash
fUniqueKeyRegisters
;
unsigned
int
fNumOps
=
0
;
SkDEBUGCODE
(
bool
fPlanned
=
false
;
)
SkDEBUGCODE
(
bool
fAssigned
=
false
;
)
SkSTArenaAllocWithReset
<
kInitialArenaSize
>
fInternalAllocator
;
bool
fFailedInstantiation
=
false
;
}
;
#
endif
