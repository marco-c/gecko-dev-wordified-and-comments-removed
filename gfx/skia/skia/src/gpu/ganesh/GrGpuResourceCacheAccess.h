#
ifndef
GrGpuResourceCacheAccess_DEFINED
#
define
GrGpuResourceCacheAccess_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResource
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourcePriv
.
h
"
namespace
skiatest
{
class
Reporter
;
}
class
GrGpuResource
:
:
CacheAccess
{
private
:
void
ref
(
)
{
fResource
-
>
addInitialRef
(
)
;
}
bool
isScratch
(
)
const
{
return
!
fResource
-
>
getUniqueKey
(
)
.
isValid
(
)
&
&
fResource
-
>
fScratchKey
.
isValid
(
)
&
&
GrBudgetedType
:
:
kBudgeted
=
=
fResource
-
>
resourcePriv
(
)
.
budgetedType
(
)
;
}
bool
isUsableAsScratch
(
)
const
{
return
this
-
>
isScratch
(
)
&
&
!
fResource
-
>
internalHasRef
(
)
;
}
void
release
(
)
{
fResource
-
>
release
(
)
;
if
(
!
fResource
-
>
hasRef
(
)
&
&
fResource
-
>
hasNoCommandBufferUsages
(
)
)
{
delete
fResource
;
}
}
void
abandon
(
)
{
fResource
-
>
abandon
(
)
;
if
(
!
fResource
-
>
hasRef
(
)
&
&
fResource
-
>
hasNoCommandBufferUsages
(
)
)
{
delete
fResource
;
}
}
void
setUniqueKey
(
const
skgpu
:
:
UniqueKey
&
key
)
{
fResource
-
>
fUniqueKey
=
key
;
}
bool
hasRef
(
)
const
{
return
fResource
-
>
hasRef
(
)
;
}
bool
hasRefOrCommandBufferUsage
(
)
const
{
return
this
-
>
hasRef
(
)
|
|
!
fResource
-
>
hasNoCommandBufferUsages
(
)
;
}
void
removeUniqueKey
(
)
{
fResource
-
>
fUniqueKey
.
reset
(
)
;
}
uint32_t
timestamp
(
)
const
{
return
fResource
-
>
fTimestamp
;
}
void
setTimestamp
(
uint32_t
ts
)
{
fResource
-
>
fTimestamp
=
ts
;
}
void
setTimeWhenResourceBecomePurgeable
(
)
{
SkASSERT
(
fResource
-
>
isPurgeable
(
)
)
;
fResource
-
>
fTimeWhenBecamePurgeable
=
GrStdSteadyClock
:
:
now
(
)
;
}
GrStdSteadyClock
:
:
time_point
timeWhenResourceBecamePurgeable
(
)
{
SkASSERT
(
fResource
-
>
isPurgeable
(
)
)
;
return
fResource
-
>
fTimeWhenBecamePurgeable
;
}
int
*
accessCacheIndex
(
)
const
{
return
&
fResource
-
>
fCacheArrayIndex
;
}
CacheAccess
(
GrGpuResource
*
resource
)
:
fResource
(
resource
)
{
}
CacheAccess
(
const
CacheAccess
&
that
)
:
fResource
(
that
.
fResource
)
{
}
CacheAccess
&
operator
=
(
const
CacheAccess
&
)
=
delete
;
const
CacheAccess
*
operator
&
(
)
const
=
delete
;
CacheAccess
*
operator
&
(
)
=
delete
;
GrGpuResource
*
fResource
;
friend
class
GrGpuResource
;
friend
class
GrResourceCache
;
friend
void
test_unbudgeted_to_scratch
(
skiatest
:
:
Reporter
*
reporter
)
;
}
;
inline
GrGpuResource
:
:
CacheAccess
GrGpuResource
:
:
cacheAccess
(
)
{
return
CacheAccess
(
this
)
;
}
inline
const
GrGpuResource
:
:
CacheAccess
GrGpuResource
:
:
cacheAccess
(
)
const
{
return
CacheAccess
(
const_cast
<
GrGpuResource
*
>
(
this
)
)
;
}
#
endif
