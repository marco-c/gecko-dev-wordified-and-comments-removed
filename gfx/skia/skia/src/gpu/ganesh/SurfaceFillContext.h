#
ifndef
SurfaceFillContext_DEFINED
#
define
SurfaceFillContext_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
SurfaceContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
ops
/
OpsTask
.
h
"
namespace
skgpu
:
:
ganesh
{
class
SurfaceFillContext
:
public
SurfaceContext
{
public
:
SurfaceFillContext
(
GrRecordingContext
*
rContext
GrSurfaceProxyView
readView
GrSurfaceProxyView
writeView
const
GrColorInfo
&
colorInfo
)
;
SurfaceFillContext
*
asFillContext
(
)
override
{
return
this
;
}
OpsTask
*
getOpsTask
(
)
;
#
if
GR_TEST_UTILS
OpsTask
*
testingOnly_PeekLastOpsTask
(
)
{
return
fOpsTask
.
get
(
)
;
}
#
endif
void
discard
(
)
;
void
resolveMSAA
(
)
;
template
<
SkAlphaType
AlphaType
>
void
clear
(
const
SkIRect
&
rect
const
SkRGBA4f
<
AlphaType
>
&
color
)
{
this
-
>
internalClear
(
&
rect
this
-
>
adjustColorAlphaType
(
color
)
)
;
}
template
<
SkAlphaType
AlphaType
>
void
clear
(
const
SkRGBA4f
<
AlphaType
>
&
color
)
{
this
-
>
internalClear
(
nullptr
this
-
>
adjustColorAlphaType
(
color
)
)
;
}
template
<
SkAlphaType
AlphaType
>
void
clearAtLeast
(
const
SkIRect
&
scissor
const
SkRGBA4f
<
AlphaType
>
&
color
)
{
this
-
>
internalClear
(
&
scissor
this
-
>
adjustColorAlphaType
(
color
)
true
)
;
}
void
fillRectWithFP
(
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
void
fillRectWithFP
(
const
SkIRect
&
dstRect
const
SkMatrix
&
localMatrix
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
void
fillRectToRectWithFP
(
const
SkRect
&
srcRect
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
SkMatrix
lm
=
SkMatrix
:
:
RectToRect
(
SkRect
:
:
Make
(
dstRect
)
srcRect
)
;
this
-
>
fillRectWithFP
(
dstRect
lm
std
:
:
move
(
fp
)
)
;
}
void
fillRectToRectWithFP
(
const
SkIRect
&
srcRect
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
this
-
>
fillRectToRectWithFP
(
SkRect
:
:
Make
(
srcRect
)
dstRect
std
:
:
move
(
fp
)
)
;
}
void
fillWithFP
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
)
{
this
-
>
fillRectWithFP
(
SkIRect
:
:
MakeSize
(
fWriteView
.
proxy
(
)
-
>
dimensions
(
)
)
std
:
:
move
(
fp
)
)
;
}
bool
blitTexture
(
GrSurfaceProxyView
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
sk_sp
<
GrRenderTask
>
refRenderTask
(
)
;
int
numSamples
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
numSamples
(
)
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
this
-
>
asRenderTargetProxy
(
)
-
>
wrapsVkSecondaryCB
(
)
;
}
SkArenaAlloc
*
arenaAlloc
(
)
{
return
this
-
>
arenas
(
)
-
>
arenaAlloc
(
)
;
}
sktext
:
:
gpu
:
:
SubRunAllocator
*
subRunAlloc
(
)
{
return
this
-
>
arenas
(
)
-
>
subRunAlloc
(
)
;
}
const
GrSurfaceProxyView
&
writeSurfaceView
(
)
const
{
return
fWriteView
;
}
protected
:
OpsTask
*
replaceOpsTask
(
)
;
static
void
ClearToGrPaint
(
std
:
:
array
<
float
4
>
color
GrPaint
*
paint
)
;
void
addOp
(
GrOp
:
:
Owner
)
;
template
<
SkAlphaType
AlphaType
>
static
std
:
:
array
<
float
4
>
ConvertColor
(
SkRGBA4f
<
AlphaType
>
color
)
;
template
<
SkAlphaType
AlphaType
>
std
:
:
array
<
float
4
>
adjustColorAlphaType
(
SkRGBA4f
<
AlphaType
>
color
)
const
;
GrSurfaceProxyView
fWriteView
;
private
:
sk_sp
<
GrArenas
>
arenas
(
)
{
return
fWriteView
.
proxy
(
)
-
>
asRenderTargetProxy
(
)
-
>
arenas
(
)
;
}
void
addDrawOp
(
GrOp
:
:
Owner
)
;
virtual
void
willReplaceOpsTask
(
OpsTask
*
prevTask
OpsTask
*
nextTask
)
{
}
virtual
OpsTask
:
:
CanDiscardPreviousOps
canDiscardPreviousOpsOnFullClear
(
)
const
{
return
OpsTask
:
:
CanDiscardPreviousOps
:
:
kYes
;
}
void
internalClear
(
const
SkIRect
*
scissor
std
:
:
array
<
float
4
>
color
bool
upgradePartialToFull
=
false
)
;
SkDEBUGCODE
(
void
onValidate
(
)
const
override
;
)
sk_sp
<
OpsTask
>
fOpsTask
;
using
INHERITED
=
SurfaceContext
;
}
;
template
<
>
inline
std
:
:
array
<
float
4
>
SurfaceFillContext
:
:
ConvertColor
<
kPremul_SkAlphaType
>
(
SkPMColor4f
color
)
{
return
color
.
unpremul
(
)
.
array
(
)
;
}
template
<
>
inline
std
:
:
array
<
float
4
>
SurfaceFillContext
:
:
ConvertColor
<
kUnpremul_SkAlphaType
>
(
SkColor4f
color
)
{
return
color
.
premul
(
)
.
array
(
)
;
}
template
<
SkAlphaType
AlphaType
>
std
:
:
array
<
float
4
>
SurfaceFillContext
:
:
adjustColorAlphaType
(
SkRGBA4f
<
AlphaType
>
color
)
const
{
if
(
AlphaType
=
=
kUnknown_SkAlphaType
|
|
this
-
>
colorInfo
(
)
.
alphaType
(
)
=
=
kUnknown_SkAlphaType
)
{
return
color
.
array
(
)
;
}
return
(
AlphaType
=
=
this
-
>
colorInfo
(
)
.
alphaType
(
)
)
?
color
.
array
(
)
:
ConvertColor
(
color
)
;
}
}
#
endif
