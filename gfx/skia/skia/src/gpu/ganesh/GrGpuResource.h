#
ifndef
GrGpuResource_DEFINED
#
define
GrGpuResource_DEFINED
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkNoncopyable
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
class
GrDirectContext
;
class
GrGpu
;
class
GrResourceCache
;
class
SkTraceMemoryDump
;
template
<
typename
DERIVED
>
class
GrIORef
:
public
SkNoncopyable
{
public
:
bool
unique
(
)
const
{
return
fRefCnt
=
=
1
;
}
void
ref
(
)
const
{
SkASSERT
(
this
-
>
getRefCnt
(
)
>
0
)
;
(
void
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
}
enum
class
LastRemovedRef
{
kMainRef
kCommandBufferUsage
}
;
void
unref
(
)
const
{
SkASSERT
(
this
-
>
getRefCnt
(
)
>
0
)
;
if
(
1
=
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
)
{
this
-
>
notifyWillBeZero
(
LastRemovedRef
:
:
kMainRef
)
;
}
}
void
addCommandBufferUsage
(
)
const
{
(
void
)
fCommandBufferUsageCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
}
void
removeCommandBufferUsage
(
)
const
{
SkASSERT
(
!
this
-
>
hasNoCommandBufferUsages
(
)
)
;
if
(
1
=
=
fCommandBufferUsageCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
)
{
this
-
>
notifyWillBeZero
(
LastRemovedRef
:
:
kCommandBufferUsage
)
;
}
}
#
if
GR_TEST_UTILS
int32_t
testingOnly_getRefCnt
(
)
const
{
return
this
-
>
getRefCnt
(
)
;
}
#
endif
protected
:
GrIORef
(
)
:
fRefCnt
(
1
)
fCommandBufferUsageCnt
(
0
)
{
}
bool
internalHasRef
(
)
const
{
return
SkToBool
(
this
-
>
getRefCnt
(
)
)
;
}
bool
internalHasNoCommandBufferUsages
(
)
const
{
return
SkToBool
(
this
-
>
hasNoCommandBufferUsages
(
)
)
;
}
void
addInitialRef
(
)
const
{
SkASSERT
(
fRefCnt
>
=
0
)
;
(
void
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
}
private
:
void
notifyWillBeZero
(
LastRemovedRef
removedRef
)
const
{
static_cast
<
const
DERIVED
*
>
(
this
)
-
>
notifyARefCntIsZero
(
removedRef
)
;
}
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
.
load
(
std
:
:
memory_order_relaxed
)
;
}
bool
hasNoCommandBufferUsages
(
)
const
{
if
(
0
=
=
fCommandBufferUsageCnt
.
load
(
std
:
:
memory_order_acquire
)
)
{
return
true
;
}
return
false
;
}
mutable
std
:
:
atomic
<
int32_t
>
fRefCnt
;
mutable
std
:
:
atomic
<
int32_t
>
fCommandBufferUsageCnt
;
using
INHERITED
=
SkNoncopyable
;
}
;
class
GrGpuResource
:
public
GrIORef
<
GrGpuResource
>
{
public
:
bool
wasDestroyed
(
)
const
{
return
nullptr
=
=
fGpu
;
}
const
GrDirectContext
*
getContext
(
)
const
;
GrDirectContext
*
getContext
(
)
;
size_t
gpuMemorySize
(
)
const
{
if
(
kInvalidGpuMemorySize
=
=
fGpuMemorySize
)
{
fGpuMemorySize
=
this
-
>
onGpuMemorySize
(
)
;
SkASSERT
(
kInvalidGpuMemorySize
!
=
fGpuMemorySize
)
;
}
return
fGpuMemorySize
;
}
class
UniqueID
{
public
:
UniqueID
(
)
=
default
;
explicit
UniqueID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
asUInt
(
)
const
{
return
fID
;
}
bool
operator
=
=
(
const
UniqueID
&
other
)
const
{
return
fID
=
=
other
.
fID
;
}
bool
operator
!
=
(
const
UniqueID
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isInvalid
(
)
const
{
return
fID
=
=
SK_InvalidUniqueID
;
}
protected
:
uint32_t
fID
=
SK_InvalidUniqueID
;
}
;
UniqueID
uniqueID
(
)
const
{
return
fUniqueID
;
}
const
skgpu
:
:
UniqueKey
&
getUniqueKey
(
)
const
{
return
fUniqueKey
;
}
std
:
:
string
getLabel
(
)
const
{
return
fLabel
;
}
void
setLabel
(
std
:
:
string_view
label
)
{
fLabel
=
label
;
this
-
>
onSetLabel
(
)
;
}
class
CacheAccess
;
inline
CacheAccess
cacheAccess
(
)
;
inline
const
CacheAccess
cacheAccess
(
)
const
;
class
ProxyAccess
;
inline
ProxyAccess
proxyAccess
(
)
;
class
ResourcePriv
;
inline
ResourcePriv
resourcePriv
(
)
;
inline
const
ResourcePriv
resourcePriv
(
)
const
;
virtual
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
virtual
const
char
*
getResourceType
(
)
const
=
0
;
static
uint32_t
CreateUniqueID
(
)
;
protected
:
void
registerWithCache
(
skgpu
:
:
Budgeted
)
;
void
registerWithCacheWrapped
(
GrWrapCacheable
)
;
GrGpuResource
(
GrGpu
*
std
:
:
string_view
label
)
;
virtual
~
GrGpuResource
(
)
;
GrGpu
*
getGpu
(
)
const
{
return
fGpu
;
}
virtual
void
onRelease
(
)
{
}
virtual
void
onAbandon
(
)
{
}
virtual
void
setMemoryBacking
(
SkTraceMemoryDump
*
const
SkString
&
)
const
{
}
SkString
getResourceName
(
)
const
;
void
dumpMemoryStatisticsPriv
(
SkTraceMemoryDump
*
traceMemoryDump
const
SkString
&
resourceName
const
char
*
type
size_t
size
)
const
;
private
:
bool
isPurgeable
(
)
const
;
bool
hasRef
(
)
const
;
bool
hasNoCommandBufferUsages
(
)
const
;
virtual
void
computeScratchKey
(
skgpu
:
:
ScratchKey
*
)
const
{
}
void
abandon
(
)
;
void
release
(
)
;
virtual
size_t
onGpuMemorySize
(
)
const
=
0
;
virtual
void
onSetLabel
(
)
=
0
;
void
setUniqueKey
(
const
skgpu
:
:
UniqueKey
&
)
;
void
removeUniqueKey
(
)
;
void
notifyARefCntIsZero
(
LastRemovedRef
removedRef
)
const
;
void
removeScratchKey
(
)
;
void
makeBudgeted
(
)
;
void
makeUnbudgeted
(
)
;
#
ifdef
SK_DEBUG
friend
class
GrGpu
;
#
endif
int
fCacheArrayIndex
;
uint32_t
fTimestamp
;
GrStdSteadyClock
:
:
time_point
fTimeWhenBecamePurgeable
;
static
const
size_t
kInvalidGpuMemorySize
=
~
static_cast
<
size_t
>
(
0
)
;
skgpu
:
:
ScratchKey
fScratchKey
;
skgpu
:
:
UniqueKey
fUniqueKey
;
GrGpu
*
fGpu
;
mutable
size_t
fGpuMemorySize
=
kInvalidGpuMemorySize
;
GrBudgetedType
fBudgetedType
=
GrBudgetedType
:
:
kUnbudgetedUncacheable
;
bool
fRefsWrappedObjects
=
false
;
const
UniqueID
fUniqueID
;
std
:
:
string
fLabel
;
using
INHERITED
=
GrIORef
<
GrGpuResource
>
;
friend
class
GrIORef
<
GrGpuResource
>
;
}
;
class
GrGpuResource
:
:
ProxyAccess
{
private
:
ProxyAccess
(
GrGpuResource
*
resource
)
:
fResource
(
resource
)
{
}
void
ref
(
GrResourceCache
*
cache
)
;
const
CacheAccess
*
operator
&
(
)
const
=
delete
;
CacheAccess
*
operator
&
(
)
=
delete
;
GrGpuResource
*
fResource
;
friend
class
GrGpuResource
;
friend
class
GrSurfaceProxy
;
}
;
inline
GrGpuResource
:
:
ProxyAccess
GrGpuResource
:
:
proxyAccess
(
)
{
return
ProxyAccess
(
this
)
;
}
#
endif
