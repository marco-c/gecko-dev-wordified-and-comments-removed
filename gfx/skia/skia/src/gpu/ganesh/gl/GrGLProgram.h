#
ifndef
GrGLProgram_DEFINED
#
define
GrGLProgram_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrXferProcessor
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
<
vector
>
class
GrPipeline
;
class
GrGeometryProcessor
;
class
GrProgramInfo
;
class
GrRenderTarget
;
class
GrTextureProxy
;
class
GrGLProgram
:
public
SkRefCnt
{
public
:
struct
Attribute
{
GrVertexAttribType
fCPUType
;
SkSLType
fGPUType
;
size_t
fOffset
;
GrGLint
fLocation
;
}
;
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
UniformInfoArray
=
GrGLProgramDataManager
:
:
UniformInfoArray
;
using
VaryingInfoArray
=
GrGLProgramDataManager
:
:
VaryingInfoArray
;
static
sk_sp
<
GrGLProgram
>
Make
(
GrGLGpu
*
const
GrGLSLBuiltinUniformHandles
&
GrGLuint
programID
const
UniformInfoArray
&
uniforms
const
UniformInfoArray
&
textureSamplers
std
:
:
unique_ptr
<
GrGeometryProcessor
:
:
ProgramImpl
>
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
std
:
:
vector
<
std
:
:
unique_ptr
<
GrFragmentProcessor
:
:
ProgramImpl
>
>
fps
std
:
:
unique_ptr
<
Attribute
[
]
>
int
vertexAttributeCnt
int
instanceAttributeCnt
int
vertexStride
int
instanceStride
)
;
~
GrGLProgram
(
)
override
;
void
abandon
(
)
;
GrGLuint
programID
(
)
const
{
return
fProgramID
;
}
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
}
;
void
updateUniforms
(
const
GrRenderTarget
*
const
GrProgramInfo
&
)
;
void
bindTextures
(
const
GrGeometryProcessor
&
const
GrSurfaceProxy
*
const
geomProcTextures
[
]
const
GrPipeline
&
)
;
int
vertexStride
(
)
const
{
return
fVertexStride
;
}
int
instanceStride
(
)
const
{
return
fInstanceStride
;
}
int
numVertexAttributes
(
)
const
{
return
fVertexAttributeCnt
;
}
const
Attribute
&
vertexAttribute
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fVertexAttributeCnt
)
;
return
fAttributes
[
i
]
;
}
int
numInstanceAttributes
(
)
const
{
return
fInstanceAttributeCnt
;
}
const
Attribute
&
instanceAttribute
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
fInstanceAttributeCnt
)
;
return
fAttributes
[
i
+
fVertexAttributeCnt
]
;
}
private
:
GrGLProgram
(
GrGLGpu
*
const
GrGLSLBuiltinUniformHandles
&
GrGLuint
programID
const
UniformInfoArray
&
uniforms
const
UniformInfoArray
&
textureSamplers
std
:
:
unique_ptr
<
GrGeometryProcessor
:
:
ProgramImpl
>
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
std
:
:
vector
<
std
:
:
unique_ptr
<
GrFragmentProcessor
:
:
ProgramImpl
>
>
fpImpls
std
:
:
unique_ptr
<
Attribute
[
]
>
int
vertexAttributeCnt
int
instanceAttributeCnt
int
vertexStride
int
instanceStride
)
;
void
setRenderTargetState
(
const
GrRenderTarget
*
GrSurfaceOrigin
const
GrGeometryProcessor
&
)
;
RenderTargetState
fRenderTargetState
;
GrGLSLBuiltinUniformHandles
fBuiltinUniformHandles
;
GrGLuint
fProgramID
;
std
:
:
unique_ptr
<
GrGeometryProcessor
:
:
ProgramImpl
>
fGPImpl
;
std
:
:
unique_ptr
<
GrXferProcessor
:
:
ProgramImpl
>
fXPImpl
;
std
:
:
vector
<
std
:
:
unique_ptr
<
GrFragmentProcessor
:
:
ProgramImpl
>
>
fFPImpls
;
std
:
:
unique_ptr
<
Attribute
[
]
>
fAttributes
;
int
fVertexAttributeCnt
;
int
fInstanceAttributeCnt
;
int
fVertexStride
;
int
fInstanceStride
;
GrGLGpu
*
fGpu
;
GrGLProgramDataManager
fProgramDataManager
;
int
fNumTextureSamplers
;
using
INHERITED
=
SkRefCnt
;
}
;
#
endif
