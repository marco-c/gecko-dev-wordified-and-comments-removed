#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLCaps
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
"
include
/
core
/
SkTextureCompressionType
.
h
"
#
include
"
include
/
gpu
/
GrContextOptions
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
base
/
SkTSearch
.
h
"
#
include
"
src
/
core
/
SkCompressedDataUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBackendUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrProgramDesc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTextureProxyPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
TestFormatColorTypeCombination
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLTexture
.
h
"
#
if
defined
(
SK_BUILD_FOR_IOS
)
#
include
<
TargetConditionals
.
h
>
#
endif
GrGLCaps
:
:
GrGLCaps
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
glInterface
)
:
INHERITED
(
contextOptions
)
{
fStandard
=
ctxInfo
.
standard
(
)
;
fPackFlipYSupport
=
false
;
fTextureUsageSupport
=
false
;
fImagingSupport
=
false
;
fVertexArrayObjectSupport
=
false
;
fDebugSupport
=
false
;
fES2CompatibilitySupport
=
false
;
fDrawRangeElementsSupport
=
false
;
fBaseVertexBaseInstanceSupport
=
false
;
fIsCoreProfile
=
false
;
fBindFragDataLocationSupport
=
false
;
fRectangleTextureSupport
=
false
;
fBindUniformLocationSupport
=
false
;
fMipmapLevelControlSupport
=
false
;
fMipmapLodControlSupport
=
false
;
fDoManualMipmapping
=
false
;
fClearToBoundaryValuesIsBroken
=
false
;
fClearTextureSupport
=
false
;
fDrawArraysBaseVertexIsBroken
=
false
;
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
false
;
fUseDrawInsteadOfAllRenderTargetWrites
=
false
;
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
=
false
;
fDontSetBaseOrMaxLevelForExternalTextures
=
false
;
fNeverDisableColorWrites
=
false
;
fMustSetAnyTexParameterToEnableMipmapping
=
false
;
fAllowBGRA8CopyTexSubImage
=
false
;
fDisallowDynamicMSAA
=
false
;
fMustResetBlendFuncBetweenDualSourceAndDisable
=
false
;
fBindTexture0WhenChangingTextureFBOMultisampleCount
=
false
;
fRebindColorAttachmentAfterCheckFramebufferStatus
=
false
;
fFlushBeforeWritePixels
=
false
;
fDisableScalingCopyAsDraws
=
false
;
fProgramBinarySupport
=
false
;
fProgramParameterSupport
=
false
;
fSamplerObjectSupport
=
false
;
fUseSamplerObjects
=
false
;
fTextureSwizzleSupport
=
false
;
fTiledRenderingSupport
=
false
;
fFBFetchRequiresEnablePerSample
=
false
;
fSRGBWriteControl
=
false
;
fSkipErrorChecks
=
false
;
fSupportsProtected
=
false
;
fShaderCaps
=
std
:
:
make_unique
<
GrShaderCaps
>
(
)
;
this
-
>
init
(
contextOptions
ctxInfo
glInterface
)
;
}
static
bool
angle_backend_is_d3d
(
GrGLANGLEBackend
backend
)
{
return
backend
=
=
GrGLANGLEBackend
:
:
kD3D9
|
|
backend
=
=
GrGLANGLEBackend
:
:
kD3D11
;
}
static
bool
angle_backend_is_metal
(
GrGLANGLEBackend
backend
)
{
return
backend
=
=
GrGLANGLEBackend
:
:
kMetal
;
}
void
GrGLCaps
:
:
init
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
sk_ignore_unused_variable
(
standard
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
GrGLint
max
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
&
max
)
;
fMaxFragmentUniformVectors
=
max
/
4
;
if
(
version
>
=
GR_GL_VER
(
3
2
)
)
{
GrGLint
profileMask
;
GR_GL_GetIntegerv
(
gli
GR_GL_CONTEXT_PROFILE_MASK
&
profileMask
)
;
fIsCoreProfile
=
SkToBool
(
profileMask
&
GR_GL_CONTEXT_CORE_PROFILE_BIT
)
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_FRAGMENT_UNIFORM_VECTORS
&
fMaxFragmentUniformVectors
)
;
}
if
(
fDriverBugWorkarounds
.
max_fragment_uniform_vectors_32
)
{
fMaxFragmentUniformVectors
=
std
:
:
min
(
fMaxFragmentUniformVectors
32
)
;
}
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_VERTEX_ATTRIBS
&
fMaxVertexAttributes
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
fWritePixelsRowBytesSupport
=
true
;
fReadPixelsRowBytesSupport
=
true
;
fPackFlipYSupport
=
false
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fWritePixelsRowBytesSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_unpack_subimage
"
)
;
fReadPixelsRowBytesSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_pack_subimage
"
)
;
fPackFlipYSupport
=
ctxInfo
.
hasExtension
(
"
GL_ANGLE_pack_reverse_row_order
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fWritePixelsRowBytesSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
fReadPixelsRowBytesSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
fTransferPixelsToRowBytesSupport
=
fWritePixelsRowBytesSupport
;
if
(
fDriverBugWorkarounds
.
pack_parameters_workaround_with_pack_buffer
)
{
fReadPixelsRowBytesSupport
=
false
;
}
fTextureUsageSupport
=
GR_IS_GR_GL_ES
(
standard
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ANGLE_texture_usage
"
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
fTextureBarrierSupport
=
version
>
=
GR_GL_VER
(
4
5
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_barrier
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_texture_barrier
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fTextureBarrierSupport
=
ctxInfo
.
hasExtension
(
"
GL_NV_texture_barrier
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fTextureBarrierSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fSampleLocationsSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_multisample
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fSampleLocationsSupport
=
version
>
=
GR_GL_VER
(
3
1
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fSampleLocationsSupport
=
false
;
}
fImagingSupport
=
GR_IS_GR_GL
(
standard
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_imaging
"
)
;
if
(
(
(
GR_IS_GR_GL
(
standard
)
&
&
version
>
=
GR_GL_VER
(
4
3
)
)
|
|
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
>
=
GR_GL_VER
(
3
0
)
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_invalidate_subdata
"
)
)
)
{
fInvalidateFBType
=
kInvalidate_InvalidateFBType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_discard_framebuffer
"
)
)
{
fInvalidateFBType
=
kDiscard_InvalidateFBType
;
}
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
fUsePrimitiveRestart
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kImagination
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
{
fPreferFullscreenClears
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fVertexArrayObjectSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_vertex_array_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_APPLE_vertex_array_object
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fVertexArrayObjectSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_vertex_array_object
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fVertexArrayObjectSupport
=
version
>
=
GR_GL_VER
(
2
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_vertex_array_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_vertex_array_object
"
)
;
}
if
(
GR_IS_GR_GL
(
standard
)
&
&
version
>
=
GR_GL_VER
(
4
3
)
)
{
fDebugSupport
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fDebugSupport
=
ctxInfo
.
hasExtension
(
"
GL_KHR_debug
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fDebugSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fES2CompatibilitySupport
=
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fES2CompatibilitySupport
=
true
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fES2CompatibilitySupport
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fClientCanDisableMultisample
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fClientCanDisableMultisample
=
ctxInfo
.
hasExtension
(
"
GL_EXT_multisample_compatibility
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fClientCanDisableMultisample
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fDrawInstancedSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_ARB_draw_instanced
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_instanced_arrays
"
)
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fDrawInstancedSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_EXT_draw_instanced
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_instanced_arrays
"
)
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ANGLE_instanced_arrays
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fDrawInstancedSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fBindFragDataLocationSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_blend_func_extended
"
)
)
{
fBindFragDataLocationSupport
=
true
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fBindFragDataLocationSupport
=
false
;
}
fBindUniformLocationSupport
=
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_bind_uniform_location
"
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
1
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rectangle
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ANGLE_texture_rectangle
"
)
)
{
fRectangleTextureSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fRectangleTextureSupport
=
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rectangle
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ANGLE_texture_rectangle
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fRectangleTextureSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
<
GR_GL_VER
(
1
3
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_border_clamp
"
)
)
{
fClampToBorderSupport
=
false
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
<
GR_GL_VER
(
3
2
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_border_clamp
"
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_NV_texture_border_clamp
"
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_OES_texture_border_clamp
"
)
)
{
fClampToBorderSupport
=
false
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fClampToBorderSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_swizzle
"
)
)
{
fTextureSwizzleSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fTextureSwizzleSupport
=
true
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fTextureSwizzleSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fMipmapLevelControlSupport
=
true
;
fMipmapLodControlSupport
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
fMipmapLevelControlSupport
=
true
;
fMipmapLodControlSupport
=
true
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fMipmapLevelControlSupport
=
false
;
fMipmapLodControlSupport
=
false
;
}
if
(
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_GL
(
standard
)
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_invalidate_subdata
"
)
)
{
fInvalidateBufferType
=
InvalidateBufferType
:
:
kInvalidate
;
}
else
if
(
!
GR_IS_GR_WEBGL
(
standard
)
&
&
!
ctxInfo
.
isOverCommandBuffer
(
)
)
{
fInvalidateBufferType
=
InvalidateBufferType
:
:
kNullData
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fClearTextureSupport
=
(
version
>
=
GR_GL_VER
(
4
4
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_clear_texture
"
)
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fClearTextureSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_clear_texture
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fClearTextureSupport
=
false
;
}
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
fSupportsAHardwareBufferImages
=
true
;
#
endif
if
(
GR_IS_GR_GL
(
standard
)
)
{
fSRGBWriteControl
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_sRGB
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_sRGB
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fSRGBWriteControl
=
ctxInfo
.
hasExtension
(
"
GL_EXT_sRGB_write_control
"
)
;
}
fSkipErrorChecks
=
ctxInfo
.
isOverCommandBuffer
(
)
;
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fSkipErrorChecks
=
true
;
}
fMustSyncGpuDuringAbandon
=
false
;
fSupportsProtected
=
[
&
]
(
)
{
if
(
!
ctxInfo
.
hasExtension
(
"
GL_EXT_protected_textures
"
)
)
{
return
false
;
}
GrGLint
contextFlags
;
GR_GL_GetIntegerv
(
gli
GR_GL_CONTEXT_FLAGS
&
contextFlags
)
;
return
SkToBool
(
contextFlags
&
GR_GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT
)
;
}
(
)
;
this
-
>
initGLSL
(
ctxInfo
gli
)
;
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
(
version
>
=
GR_GL_VER
(
3
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_blend_func_extended
"
)
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
shaderCaps
-
>
fShaderDerivativeSupport
=
true
;
shaderCaps
-
>
fExplicitTextureLodSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
shaderCaps
-
>
fIntegerSupport
=
version
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
shaderCaps
-
>
fNonsquareMatrixSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
shaderCaps
-
>
fInverseHyperbolicSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_blend_func_extended
"
)
;
shaderCaps
-
>
fShaderDerivativeSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_standard_derivatives
"
)
;
shaderCaps
-
>
fExplicitTextureLodSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
shaderCaps
-
>
fIntegerSupport
=
version
>
=
GR_GL_VER
(
3
0
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
shaderCaps
-
>
fNonsquareMatrixSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
shaderCaps
-
>
fInverseHyperbolicSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fShaderDerivativeSupport
=
version
>
=
GR_GL_VER
(
2
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_standard_derivatives
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_standard_derivatives
"
)
;
shaderCaps
-
>
fExplicitTextureLodSupport
=
version
>
=
GR_GL_VER
(
2
0
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
shaderCaps
-
>
fIntegerSupport
=
(
version
>
=
GR_GL_VER
(
2
0
)
)
;
shaderCaps
-
>
fNonsquareMatrixSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
shaderCaps
-
>
fInverseHyperbolicSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_conservative_raster
"
)
)
{
fConservativeRasterSupport
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fWireframeSupport
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fRewriteSwitchStatements
=
ctxInfo
.
glslGeneration
(
)
<
SkSL
:
:
GLSLGeneration
:
:
k130
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
shaderCaps
-
>
fRewriteSwitchStatements
=
ctxInfo
.
glslGeneration
(
)
<
SkSL
:
:
GLSLGeneration
:
:
k300es
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fRewriteSwitchStatements
=
version
<
GR_GL_VER
(
2
0
)
;
}
static
const
uint8_t
kMaxSaneSamplers
=
32
;
GrGLint
maxSamplers
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_TEXTURE_IMAGE_UNITS
&
maxSamplers
)
;
shaderCaps
-
>
fMaxFragmentSamplers
=
std
:
:
min
<
GrGLint
>
(
kMaxSaneSamplers
maxSamplers
)
;
if
(
GR_IS_GR_GL
(
standard
)
|
|
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kUnknown
&
&
!
ctxInfo
.
isOverCommandBuffer
(
)
&
&
!
fIsCoreProfile
&
&
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kImagination
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
)
{
fPreferClientSideDynamicBuffers
=
true
;
}
}
if
(
!
contextOptions
.
fAvoidStencilBuffers
)
{
this
-
>
initFSAASupport
(
contextOptions
ctxInfo
gli
)
;
this
-
>
initStencilSupport
(
ctxInfo
)
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_blit
"
)
)
{
fBlitFramebufferFlags
=
0
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_framebuffer_blit
"
)
)
{
fBlitFramebufferFlags
=
kNoFormatConversionForMSAASrc_BlitFramebufferFlag
|
kNoMSAADst_BlitFramebufferFlag
|
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_framebuffer_multisample
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ANGLE_framebuffer_blit
"
)
)
{
fBlitFramebufferFlags
=
kNoScalingOrMirroring_BlitFramebufferFlag
|
kResolveMustBeFull_BlitFrambufferFlag
|
kNoMSAADst_BlitFramebufferFlag
|
kNoFormatConversion_BlitFramebufferFlag
|
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
;
}
}
this
-
>
initBlendEqationSupport
(
ctxInfo
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
;
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_map_buffer_range
"
)
)
{
fMapBufferFlags
|
=
kSubset_MapFlag
;
fMapBufferType
=
kMapBufferRange_MapBufferType
;
}
else
{
fMapBufferType
=
kMapBuffer_MapBufferType
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fMapBufferFlags
=
kNone_MapFlags
;
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_map_sub
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fMapBufferType
=
kChromium_MapBufferType
;
}
else
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_map_buffer_range
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
|
kSubset_MapFlag
;
fMapBufferType
=
kMapBufferRange_MapBufferType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_mapbuffer
"
)
)
{
fMapBufferFlags
=
kCanMap_MapFlag
;
fMapBufferType
=
kMapBuffer_MapBufferType
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fMapBufferFlags
=
kNone_MapFlags
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
2
1
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_pixel_buffer_object
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_pixel_buffer_object
"
)
)
{
fTransferFromBufferToTextureSupport
=
true
;
fTransferFromSurfaceToBufferSupport
=
true
;
fTransferBufferType
=
TransferBufferType
:
:
kARB_PBO
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
(
ctxInfo
.
hasExtension
(
"
GL_NV_pixel_buffer_object
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_unpack_subimage
"
)
)
)
{
fTransferFromBufferToTextureSupport
=
true
;
fTransferFromSurfaceToBufferSupport
=
true
;
if
(
version
<
GR_GL_VER
(
3
0
)
)
{
fTransferBufferType
=
TransferBufferType
:
:
kNV_PBO
;
}
else
{
fTransferBufferType
=
TransferBufferType
:
:
kARB_PBO
;
}
}
}
if
(
GR_IS_GR_GL
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
3
1
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_copy_buffer
"
)
)
)
{
fTransferFromBufferToBufferSupport
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_NV_copy_buffer
"
)
)
)
{
fTransferFromBufferToBufferSupport
=
true
;
}
if
(
fBufferMapThreshold
<
0
)
{
#
if
0
fBufferMapThreshold
=
ctxInfo
.
isOverCommandBuffer
(
)
?
0
:
SK_MaxS32
;
#
else
fBufferMapThreshold
=
SK_MaxS32
;
#
endif
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fNPOTTextureTileSupport
=
true
;
fMipmapSupport
=
true
;
fAnisoSupport
=
version
>
=
GR_GL_VER
(
4
6
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_filter_anisotropic
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_filter_anisotropic
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fNPOTTextureTileSupport
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_texture_npot
"
)
;
fMipmapSupport
=
fNPOTTextureTileSupport
|
|
ctxInfo
.
hasExtension
(
"
GL_IMG_texture_npot
"
)
;
fAnisoSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_filter_anisotropic
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fNPOTTextureTileSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
fMipmapSupport
=
fNPOTTextureTileSupport
;
fAnisoSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_filter_anisotropic
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_texture_filter_anisotropic
"
)
;
}
if
(
fAnisoSupport
)
{
GR_GL_GetFloatv
(
gli
GR_GL_MAX_TEXTURE_MAX_ANISOTROPY
&
fMaxTextureMaxAnisotropy
)
;
}
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_TEXTURE_SIZE
&
fMaxTextureSize
)
;
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_RENDERBUFFER_SIZE
&
fMaxRenderTargetSize
)
;
fMaxPreferredRenderTargetSize
=
fMaxRenderTargetSize
;
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
fMaxPreferredRenderTargetSize
=
std
:
:
min
(
4096
fMaxPreferredRenderTargetSize
)
;
}
fGpuTracingSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_debug_marker
"
)
;
fReuseScratchTextures
=
(
ctxInfo
.
vendor
(
)
!
=
GrGLVendor
:
:
kARM
)
;
#
if
0
fReuseScratchBuffers
=
ctxInfo
.
vendor
(
)
!
=
GrGLVendor
:
:
kARM
ctxInfo
.
vendor
(
)
!
=
GrGLVendor
:
:
kQualcomm
;
#
endif
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_window_rectangles
"
)
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_WINDOW_RECTANGLES
&
fMaxWindowRectangles
)
;
}
#
ifdef
SK_BUILD_FOR_WIN
bool
isD3DANGLE
=
angle_backend_is_d3d
(
ctxInfo
.
angleBackend
(
)
)
|
|
ctxInfo
.
isOverCommandBuffer
(
)
;
fPreferVRAMUseOverFlushes
=
!
isD3DANGLE
;
#
endif
if
(
ctxInfo
.
isOverCommandBuffer
(
)
)
{
fMustClearUploadedBufferData
=
true
;
}
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fShouldInitializeTextures
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
)
{
fOversizedStencilSupport
=
true
;
}
else
{
SkASSERT
(
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_object
"
)
)
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fOversizedStencilSupport
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fOversizedStencilSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fBaseVertexBaseInstanceSupport
=
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_base_instance
"
)
;
if
(
fBaseVertexBaseInstanceSupport
)
{
fNativeDrawIndirectSupport
=
version
>
=
GR_GL_VER
(
4
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_draw_indirect
"
)
;
if
(
version
>
=
GR_GL_VER
(
4
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_multi_draw_indirect
"
)
)
{
fMultiDrawType
=
MultiDrawType
:
:
kMultiDrawIndirect
;
}
}
fDrawRangeElementsSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_ANGLE_base_vertex_base_instance
"
)
)
{
fBaseVertexBaseInstanceSupport
=
true
;
fNativeDrawIndirectSupport
=
true
;
fMultiDrawType
=
MultiDrawType
:
:
kANGLEOrWebGL
;
fUseClientSideIndirectBuffers
=
true
;
}
else
{
fBaseVertexBaseInstanceSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_base_instance
"
)
;
}
fDrawRangeElementsSupport
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fBaseVertexBaseInstanceSupport
=
ctxInfo
.
hasExtension
(
"
WEBGL_draw_instanced_base_vertex_base_instance
"
)
;
if
(
fBaseVertexBaseInstanceSupport
&
&
ctxInfo
.
hasExtension
(
"
GL_WEBGL_multi_draw_instanced_base_vertex_base_instance
"
)
)
{
fNativeDrawIndirectSupport
=
true
;
fMultiDrawType
=
MultiDrawType
:
:
kANGLEOrWebGL
;
}
fUseClientSideIndirectBuffers
=
true
;
fDrawRangeElementsSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D11
)
{
fBaseVertexBaseInstanceSupport
=
false
;
fNativeDrawIndirectSupport
=
false
;
fMultiDrawType
=
MultiDrawType
:
:
kNone
;
}
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fSemaphoreSupport
=
fFenceSyncSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
fFenceType
=
FenceType
:
:
kSyncObject
;
}
else
if
(
GR_IS_GR_GL
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_sync
"
)
)
)
{
fSemaphoreSupport
=
fFenceSyncSupport
=
true
;
fFenceType
=
FenceType
:
:
kSyncObject
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_APPLE_sync
"
)
)
)
{
fSemaphoreSupport
=
fFenceSyncSupport
=
true
;
fFenceType
=
FenceType
:
:
kSyncObject
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_fence
"
)
)
{
fFenceSyncSupport
=
true
;
fFenceType
=
FenceType
:
:
kNVFence
;
}
fCrossContextTextureSupport
=
fSemaphoreSupport
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
fHalfFloatVertexAttributeSupport
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fHalfFloatVertexAttributeSupport
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fHalfFloatVertexAttributeSupport
=
(
version
>
=
GR_GL_VER
(
2
0
)
)
;
}
fDynamicStateArrayGeometryProcessorTextureSupport
=
true
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
fProgramBinarySupport
=
(
version
>
=
GR_GL_VER
(
4
1
)
)
;
fProgramParameterSupport
=
(
version
>
=
GR_GL_VER
(
4
1
)
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fProgramBinarySupport
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_get_program_binary
"
)
;
fProgramParameterSupport
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
}
if
(
fProgramBinarySupport
)
{
GrGLint
count
;
GR_GL_GetIntegerv
(
gli
GR_GL_NUM_PROGRAM_BINARY_FORMATS
&
count
)
;
if
(
count
>
0
)
{
fProgramBinaryFormats
.
resize_back
(
count
)
;
GR_GL_GetIntegerv
(
gli
GR_GL_PROGRAM_BINARY_FORMATS
reinterpret_cast
<
GrGLint
*
>
(
fProgramBinaryFormats
.
data
(
)
)
)
;
}
else
{
fProgramBinarySupport
=
false
;
}
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
fSamplerObjectSupport
=
version
>
=
GR_GL_VER
(
3
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_sampler_objects
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fSamplerObjectSupport
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
fSamplerObjectSupport
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
fUseSamplerObjects
=
fSamplerObjectSupport
;
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
fTiledRenderingSupport
=
ctxInfo
.
hasExtension
(
"
GL_QCOM_tiled_rendering
"
)
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
fShouldCollapseSrcOverToSrcWhenAble
=
true
;
}
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fAvoidDithering
=
true
;
}
#
endif
FormatWorkarounds
formatWorkarounds
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
ctxInfo
contextOptions
gli
shaderCaps
&
formatWorkarounds
)
;
}
this
-
>
initFormatTable
(
ctxInfo
gli
formatWorkarounds
)
;
this
-
>
finishInitialization
(
contextOptions
)
;
shaderCaps
-
>
fDstReadInShaderSupport
=
shaderCaps
-
>
fFBFetchSupport
;
}
const
char
*
get_glsl_version_decl_string
(
GrGLStandard
standard
SkSL
:
:
GLSLGeneration
generation
bool
isCoreProfile
)
{
if
(
GR_IS_GR_GL
(
standard
)
)
{
switch
(
generation
)
{
case
SkSL
:
:
GLSLGeneration
:
:
k110
:
return
"
#
version
110
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k130
:
return
"
#
version
130
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k140
:
return
"
#
version
140
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k150
:
if
(
isCoreProfile
)
{
return
"
#
version
150
\
n
"
;
}
else
{
return
"
#
version
150
compatibility
\
n
"
;
}
case
SkSL
:
:
GLSLGeneration
:
:
k330
:
if
(
isCoreProfile
)
{
return
"
#
version
330
\
n
"
;
}
else
{
return
"
#
version
330
compatibility
\
n
"
;
}
case
SkSL
:
:
GLSLGeneration
:
:
k400
:
if
(
isCoreProfile
)
{
return
"
#
version
400
\
n
"
;
}
else
{
return
"
#
version
400
compatibility
\
n
"
;
}
case
SkSL
:
:
GLSLGeneration
:
:
k420
:
if
(
isCoreProfile
)
{
return
"
#
version
420
\
n
"
;
}
else
{
return
"
#
version
420
compatibility
\
n
"
;
}
default
:
break
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
switch
(
generation
)
{
case
SkSL
:
:
GLSLGeneration
:
:
k100es
:
return
"
#
version
100
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k300es
:
return
"
#
version
300
es
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k310es
:
return
"
#
version
310
es
\
n
"
;
case
SkSL
:
:
GLSLGeneration
:
:
k320es
:
return
"
#
version
320
es
\
n
"
;
default
:
break
;
}
}
return
"
<
no
version
>
"
;
}
bool
is_float_fp32
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
GrGLenum
precision
)
{
if
(
GR_IS_GR_GL
(
ctxInfo
.
standard
(
)
)
&
&
ctxInfo
.
version
(
)
<
GR_GL_VER
(
4
1
)
&
&
!
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
)
{
return
true
;
}
for
(
GrGLenum
shader
:
{
GR_GL_FRAGMENT_SHADER
GR_GL_VERTEX_SHADER
}
)
{
GrGLint
range
[
2
]
;
GrGLint
bits
;
GR_GL_GetShaderPrecisionFormat
(
gli
shader
precision
range
&
bits
)
;
if
(
range
[
0
]
<
127
|
|
range
[
1
]
<
127
|
|
bits
<
23
)
{
return
false
;
}
}
return
true
;
}
void
GrGLCaps
:
:
initGLSL
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
GrShaderCaps
*
shaderCaps
=
fShaderCaps
.
get
(
)
;
shaderCaps
-
>
fGLSLGeneration
=
ctxInfo
.
glslGeneration
(
)
;
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragData
[
0
]
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_EXT_shader_framebuffer_fetch
"
;
fFBFetchRequiresEnablePerSample
=
false
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
false
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragData
[
0
]
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_NV_shader_framebuffer_fetch
"
;
fFBFetchRequiresEnablePerSample
=
false
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ARM_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
false
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragColorARM
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_ARM_shader_framebuffer_fetch
"
;
fFBFetchRequiresEnablePerSample
=
true
;
}
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
}
else
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_shader_framebuffer_fetch
"
)
)
{
shaderCaps
-
>
fFBFetchNeedsCustomOutput
=
(
version
>
=
GR_GL_VER
(
3
0
)
)
;
shaderCaps
-
>
fFBFetchSupport
=
true
;
shaderCaps
-
>
fFBFetchColorName
=
"
gl_LastFragData
[
0
]
"
;
shaderCaps
-
>
fFBFetchExtensionString
=
"
GL_EXT_shader_framebuffer_fetch
"
;
fFBFetchRequiresEnablePerSample
=
false
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fUsesPrecisionModifiers
=
true
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fFlatInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fFlatInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
}
shaderCaps
-
>
fPreferFlatInterpolation
=
shaderCaps
-
>
fFlatInterpolationSupport
&
&
ctxInfo
.
vendor
(
)
!
=
GrGLVendor
:
:
kQualcomm
&
&
!
angle_backend_is_d3d
(
ctxInfo
.
angleBackend
(
)
)
&
&
!
angle_backend_is_metal
(
ctxInfo
.
angleBackend
(
)
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fNoPerspectiveInterpolationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k130
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_shader_noperspective_interpolation
"
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
)
{
shaderCaps
-
>
fNoPerspectiveInterpolationSupport
=
true
;
shaderCaps
-
>
fNoPerspectiveInterpolationExtensionString
=
"
GL_NV_shader_noperspective_interpolation
"
;
}
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fSampleMaskSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k400
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k320es
)
{
shaderCaps
-
>
fSampleMaskSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_sample_variables
"
)
)
{
shaderCaps
-
>
fSampleMaskSupport
=
true
;
shaderCaps
-
>
fSampleVariablesExtensionString
=
"
GL_OES_sample_variables
"
;
}
}
shaderCaps
-
>
fVersionDeclString
=
get_glsl_version_decl_string
(
standard
shaderCaps
-
>
fGLSLGeneration
fIsCoreProfile
)
;
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
if
(
SkSL
:
:
GLSLGeneration
:
:
k100es
=
=
shaderCaps
-
>
fGLSLGeneration
)
{
shaderCaps
-
>
fShaderDerivativeExtensionString
=
"
GL_OES_standard_derivatives
"
;
}
}
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
shaderCaps
-
>
fSecondaryOutputExtensionString
=
"
GL_EXT_blend_func_extended
"
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_EGL_image_external
"
)
)
{
if
(
ctxInfo
.
glslGeneration
(
)
=
=
SkSL
:
:
GLSLGeneration
:
:
k100es
)
{
shaderCaps
-
>
fExternalTextureSupport
=
true
;
shaderCaps
-
>
fExternalTextureExtensionString
=
"
GL_OES_EGL_image_external
"
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_EGL_image_external_essl3
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_EGL_image_external_essl3
"
)
)
{
shaderCaps
-
>
fExternalTextureSupport
=
true
;
shaderCaps
-
>
fExternalTextureExtensionString
=
"
GL_OES_EGL_image_external_essl3
"
;
}
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fVertexIDSupport
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fVertexIDSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
;
}
shaderCaps
-
>
fInfinitySupport
=
(
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k330
)
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fNonconstantArrayIndexSupport
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fNonconstantArrayIndexSupport
=
(
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
)
;
}
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fBitManipulationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k400
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
|
|
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fBitManipulationSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k310es
;
}
shaderCaps
-
>
fFloatIs32Bits
=
is_float_fp32
(
ctxInfo
gli
GR_GL_HIGH_FLOAT
)
;
shaderCaps
-
>
fHalfIs32Bits
=
is_float_fp32
(
ctxInfo
gli
GR_GL_MEDIUM_FLOAT
)
;
shaderCaps
-
>
fHasLowFragmentPrecision
=
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
shaderCaps
-
>
fBuiltinFMASupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k400
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
shaderCaps
-
>
fBuiltinFMASupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k320es
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
shaderCaps
-
>
fBuiltinFMASupport
=
false
;
}
shaderCaps
-
>
fBuiltinDeterminantSupport
=
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k150
;
}
void
GrGLCaps
:
:
initFSAASupport
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
if
(
GR_IS_GR_GL
(
ctxInfo
.
standard
(
)
)
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_multisample
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_blit
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
ctxInfo
.
standard
(
)
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_multisampled_render_to_texture
"
)
)
{
fMSFBOType
=
kES_EXT_MsToTexture_MSFBOType
;
fMSAAResolvesAutomatically
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_IMG_multisampled_render_to_texture
"
)
)
{
fMSFBOType
=
kES_IMG_MsToTexture_MSFBOType
;
fMSAAResolvesAutomatically
=
true
;
}
else
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_CHROMIUM_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ANGLE_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_APPLE_framebuffer_multisample
"
)
)
{
fMSFBOType
=
kES_Apple_MSFBOType
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
ctxInfo
.
standard
(
)
)
)
{
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
2
0
)
)
{
fMSFBOType
=
kStandard_MSFBOType
;
}
else
{
fMSFBOType
=
kNone_MSFBOType
;
}
}
}
void
GrGLCaps
:
:
initBlendEqationSupport
(
const
GrGLContextInfo
&
ctxInfo
)
{
GrShaderCaps
*
shaderCaps
=
static_cast
<
GrShaderCaps
*
>
(
fShaderCaps
.
get
(
)
)
;
bool
layoutQualifierSupport
=
false
;
if
(
(
GR_IS_GR_GL
(
fStandard
)
&
&
shaderCaps
-
>
fGLSLGeneration
>
=
SkSL
:
:
GLSLGeneration
:
:
k140
)
|
|
(
GR_IS_GR_GL_ES
(
fStandard
)
&
&
shaderCaps
-
>
fGLSLGeneration
>
=
SkSL
:
:
GLSLGeneration
:
:
k300es
)
)
{
layoutQualifierSupport
=
true
;
}
else
if
(
GR_IS_GR_WEBGL
(
fStandard
)
)
{
return
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_blend_equation_advanced_coherent
"
)
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_KHR_blend_equation_advanced_coherent
"
)
&
&
layoutQualifierSupport
)
{
fBlendEquationSupport
=
kAdvancedCoherent_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kGeneralEnable_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_NV_blend_equation_advanced
"
)
)
{
fBlendEquationSupport
=
kAdvanced_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kAutomatic_AdvBlendEqInteraction
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_KHR_blend_equation_advanced
"
)
&
&
layoutQualifierSupport
)
{
fBlendEquationSupport
=
kAdvanced_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kGeneralEnable_AdvBlendEqInteraction
;
}
}
void
GrGLCaps
:
:
initStencilSupport
(
const
GrGLContextInfo
&
ctxInfo
)
{
if
(
GR_IS_GR_GL
(
ctxInfo
.
standard
(
)
)
)
{
bool
supportsPackedDS
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_packed_depth_stencil
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
;
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kSTENCIL_INDEX8
;
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kSTENCIL_INDEX16
;
if
(
supportsPackedDS
)
{
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kDEPTH24_STENCIL8
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
ctxInfo
.
standard
(
)
)
)
{
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kSTENCIL_INDEX8
;
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_packed_depth_stencil
"
)
)
{
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kDEPTH24_STENCIL8
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
ctxInfo
.
standard
(
)
)
)
{
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kSTENCIL_INDEX8
;
if
(
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
2
0
)
)
{
fStencilFormats
.
push_back
(
)
=
GrGLFormat
:
:
kDEPTH24_STENCIL8
;
}
}
}
#
ifdef
SK_ENABLE_DUMP_GPU
#
include
"
src
/
utils
/
SkJSONWriter
.
h
"
static
const
char
*
multi_draw_type_name
(
GrGLCaps
:
:
MultiDrawType
multiDrawType
)
{
switch
(
multiDrawType
)
{
case
GrGLCaps
:
:
MultiDrawType
:
:
kNone
:
return
"
kNone
"
;
case
GrGLCaps
:
:
MultiDrawType
:
:
kMultiDrawIndirect
:
return
"
kMultiDrawIndirect
"
;
case
GrGLCaps
:
:
MultiDrawType
:
:
kANGLEOrWebGL
:
return
"
kMultiDrawIndirect
"
;
}
SkUNREACHABLE
;
}
void
GrGLCaps
:
:
onDumpJSON
(
SkJSONWriter
*
writer
)
const
{
writer
-
>
beginObject
(
"
GL
caps
"
)
;
writer
-
>
beginArray
(
"
Stencil
Formats
"
)
;
for
(
int
i
=
0
;
i
<
fStencilFormats
.
size
(
)
;
+
+
i
)
{
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendS32
(
"
stencil
bits
"
GrGLFormatStencilBits
(
fStencilFormats
[
i
]
)
)
;
writer
-
>
appendS32
(
"
total
bytes
"
GrGLFormatBytesPerBlock
(
fStencilFormats
[
i
]
)
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
auto
msfboStr
=
[
&
]
{
switch
(
fMSFBOType
)
{
case
kNone_MSFBOType
:
return
"
None
"
;
case
kStandard_MSFBOType
:
return
"
Standard
"
;
case
kES_Apple_MSFBOType
:
return
"
Apple
"
;
case
kES_IMG_MsToTexture_MSFBOType
:
return
"
IMG
MS
To
Texture
"
;
case
kES_EXT_MsToTexture_MSFBOType
:
return
"
EXT
MS
To
Texture
"
;
}
SkUNREACHABLE
;
}
;
auto
invalidateFBTypeStr
=
[
&
]
{
switch
(
fInvalidateFBType
)
{
case
kNone_InvalidateFBType
:
return
"
None
"
;
case
kDiscard_InvalidateFBType
:
return
"
Discard
"
;
case
kInvalidate_InvalidateFBType
:
return
"
Invalidate
"
;
}
SkUNREACHABLE
;
}
;
auto
invalidateBufferTypeStr
=
[
&
]
{
switch
(
fInvalidateBufferType
)
{
case
InvalidateBufferType
:
:
kNone
:
return
"
None
"
;
case
InvalidateBufferType
:
:
kNullData
:
return
"
Null
data
hint
"
;
case
InvalidateBufferType
:
:
kInvalidate
:
return
"
Invalidate
"
;
}
SkUNREACHABLE
;
}
;
auto
mapBufferTypeStr
=
[
&
]
{
switch
(
fMapBufferType
)
{
case
kNone_MapBufferType
:
return
"
None
"
;
case
kMapBuffer_MapBufferType
:
return
"
MapBuffer
"
;
case
kMapBufferRange_MapBufferType
:
return
"
MapBufferRange
"
;
case
kChromium_MapBufferType
:
return
"
Chromium
"
;
}
SkUNREACHABLE
;
}
;
writer
-
>
appendBool
(
"
Core
Profile
"
fIsCoreProfile
)
;
writer
-
>
appendCString
(
"
MSAA
Type
"
msfboStr
(
)
)
;
writer
-
>
appendCString
(
"
Invalidate
FB
Type
"
invalidateFBTypeStr
(
)
)
;
writer
-
>
appendCString
(
"
Invalidate
Buffer
Type
"
invalidateBufferTypeStr
(
)
)
;
writer
-
>
appendCString
(
"
Map
Buffer
Type
"
mapBufferTypeStr
(
)
)
;
writer
-
>
appendCString
(
"
Multi
Draw
Type
"
multi_draw_type_name
(
fMultiDrawType
)
)
;
writer
-
>
appendS32
(
"
Max
FS
Uniform
Vectors
"
fMaxFragmentUniformVectors
)
;
writer
-
>
appendBool
(
"
Pack
Flip
Y
support
"
fPackFlipYSupport
)
;
writer
-
>
appendBool
(
"
Texture
Usage
support
"
fTextureUsageSupport
)
;
writer
-
>
appendBool
(
"
GL_ARB_imaging
support
"
fImagingSupport
)
;
writer
-
>
appendBool
(
"
Vertex
array
object
support
"
fVertexArrayObjectSupport
)
;
writer
-
>
appendBool
(
"
Debug
support
"
fDebugSupport
)
;
writer
-
>
appendBool
(
"
ES2
compatibility
support
"
fES2CompatibilitySupport
)
;
writer
-
>
appendBool
(
"
drawRangeElements
support
"
fDrawRangeElementsSupport
)
;
writer
-
>
appendBool
(
"
Base
(
vertex
base
)
instance
support
"
fBaseVertexBaseInstanceSupport
)
;
writer
-
>
appendBool
(
"
Bind
uniform
location
support
"
fBindUniformLocationSupport
)
;
writer
-
>
appendBool
(
"
Rectangle
texture
support
"
fRectangleTextureSupport
)
;
writer
-
>
appendBool
(
"
Mipmap
LOD
control
support
"
fMipmapLodControlSupport
)
;
writer
-
>
appendBool
(
"
Mipmap
level
control
support
"
fMipmapLevelControlSupport
)
;
writer
-
>
appendBool
(
"
Clear
texture
support
"
fClearTextureSupport
)
;
writer
-
>
appendBool
(
"
Program
binary
support
"
fProgramBinarySupport
)
;
writer
-
>
appendBool
(
"
Program
parameters
support
"
fProgramParameterSupport
)
;
writer
-
>
appendBool
(
"
Sampler
object
support
"
fSamplerObjectSupport
)
;
writer
-
>
appendBool
(
"
Using
sampler
objects
"
fUseSamplerObjects
)
;
writer
-
>
appendBool
(
"
Texture
swizzle
support
"
fTextureSwizzleSupport
)
;
writer
-
>
appendBool
(
"
Tiled
rendering
support
"
fTiledRenderingSupport
)
;
writer
-
>
appendBool
(
"
FB
fetch
requires
enable
per
sample
"
fFBFetchRequiresEnablePerSample
)
;
writer
-
>
appendBool
(
"
sRGB
Write
Control
"
fSRGBWriteControl
)
;
writer
-
>
appendBool
(
"
Intermediate
texture
for
partial
updates
of
unorm
textures
ever
bound
to
FBOs
"
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
;
writer
-
>
appendBool
(
"
Intermediate
texture
for
all
updates
of
textures
bound
to
FBOs
"
fUseDrawInsteadOfAllRenderTargetWrites
)
;
writer
-
>
appendBool
(
"
Max
instances
per
draw
without
crashing
(
or
zero
)
"
fMaxInstancesPerDrawWithoutCrashing
)
;
writer
-
>
beginArray
(
"
formats
"
)
;
for
(
int
i
=
0
;
i
<
kGrGLColorFormatCount
;
+
+
i
)
{
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendHexU32
(
"
flags
"
fFormatTable
[
i
]
.
fFlags
)
;
writer
-
>
appendHexU32
(
"
f_type
"
(
uint32_t
)
fFormatTable
[
i
]
.
fFormatType
)
;
writer
-
>
appendHexU32
(
"
c_internal
"
fFormatTable
[
i
]
.
fCompressedInternalFormat
)
;
writer
-
>
appendHexU32
(
"
i_for_teximage
"
fFormatTable
[
i
]
.
fInternalFormatForTexImageOrStorage
)
;
writer
-
>
appendHexU32
(
"
i_for_renderbuffer
"
fFormatTable
[
i
]
.
fInternalFormatForRenderbuffer
)
;
writer
-
>
appendHexU32
(
"
default_ex_format
"
fFormatTable
[
i
]
.
fDefaultExternalFormat
)
;
writer
-
>
appendHexU32
(
"
default_ex_type
"
fFormatTable
[
i
]
.
fDefaultExternalType
)
;
writer
-
>
appendHexU32
(
"
default_color_type
"
(
uint32_t
)
fFormatTable
[
i
]
.
fDefaultColorType
)
;
writer
-
>
beginArray
(
"
surface
color
types
"
)
;
for
(
int
j
=
0
;
j
<
fFormatTable
[
i
]
.
fColorTypeInfoCount
;
+
+
j
)
{
const
auto
&
ctInfo
=
fFormatTable
[
i
]
.
fColorTypeInfos
[
j
]
;
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendHexU32
(
"
colorType
"
(
uint32_t
)
ctInfo
.
fColorType
)
;
writer
-
>
appendHexU32
(
"
flags
"
ctInfo
.
fFlags
)
;
writer
-
>
beginArray
(
"
data
color
types
"
)
;
for
(
int
k
=
0
;
k
<
ctInfo
.
fExternalIOFormatCount
;
+
+
k
)
{
const
auto
&
ioInfo
=
ctInfo
.
fExternalIOFormats
[
k
]
;
writer
-
>
beginObject
(
nullptr
false
)
;
writer
-
>
appendHexU32
(
"
colorType
"
(
uint32_t
)
ioInfo
.
fColorType
)
;
writer
-
>
appendHexU32
(
"
ex_type
"
ioInfo
.
fExternalType
)
;
writer
-
>
appendHexU32
(
"
ex_teximage
"
ioInfo
.
fExternalTexImageFormat
)
;
writer
-
>
appendHexU32
(
"
ex_read
"
ioInfo
.
fExternalReadFormat
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
writer
-
>
endObject
(
)
;
}
writer
-
>
endArray
(
)
;
writer
-
>
endObject
(
)
;
}
#
else
void
GrGLCaps
:
:
onDumpJSON
(
SkJSONWriter
*
writer
)
const
{
}
#
endif
void
GrGLCaps
:
:
getTexImageExternalFormatAndType
(
GrGLFormat
surfaceFormat
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
surfaceFormat
)
;
*
externalType
=
info
.
fDefaultExternalType
;
*
externalFormat
=
info
.
fDefaultExternalFormat
;
}
void
GrGLCaps
:
:
getTexSubImageDefaultFormatTypeAndColorType
(
GrGLFormat
format
GrGLenum
*
externalFormat
GrGLenum
*
externalType
GrColorType
*
colorType
)
const
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
*
externalType
=
info
.
fDefaultExternalType
;
*
externalFormat
=
info
.
fDefaultExternalFormat
;
*
colorType
=
info
.
fDefaultColorType
;
}
void
GrGLCaps
:
:
getTexSubImageExternalFormatAndType
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
this
-
>
getExternalFormat
(
surfaceFormat
surfaceColorType
memoryColorType
kTexImage_ExternalFormatUsage
externalFormat
externalType
)
;
}
void
GrGLCaps
:
:
getReadPixelsFormat
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
this
-
>
getExternalFormat
(
surfaceFormat
surfaceColorType
memoryColorType
kReadPixels_ExternalFormatUsage
externalFormat
externalType
)
;
}
void
GrGLCaps
:
:
getExternalFormat
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
ExternalFormatUsage
usage
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
{
SkASSERT
(
externalFormat
&
&
externalType
)
;
*
externalFormat
=
this
-
>
getFormatInfo
(
surfaceFormat
)
.
externalFormat
(
surfaceColorType
memoryColorType
usage
)
;
*
externalType
=
this
-
>
getFormatInfo
(
surfaceFormat
)
.
externalType
(
surfaceColorType
memoryColorType
)
;
}
void
GrGLCaps
:
:
setStencilFormatIndexForFormat
(
GrGLFormat
format
int
index
)
{
SkASSERT
(
!
this
-
>
hasStencilFormatBeenDeterminedForFormat
(
format
)
)
;
this
-
>
getFormatInfo
(
format
)
.
fStencilFormatIndex
=
index
<
0
?
FormatInfo
:
:
kUnsupported_StencilFormatIndex
:
index
;
}
void
GrGLCaps
:
:
setColorTypeFormat
(
GrColorType
colorType
GrGLFormat
format
)
{
int
idx
=
static_cast
<
int
>
(
colorType
)
;
SkASSERT
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
;
fColorTypeToFormatTable
[
idx
]
=
format
;
}
void
GrGLCaps
:
:
initFormatTable
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
const
FormatWorkarounds
&
formatWorkarounds
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
sk_ignore_unused_variable
(
standard
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
uint32_t
nonMSAARenderFlags
=
FormatInfo
:
:
kFBOColorAttachment_Flag
;
uint32_t
msaaRenderFlags
=
nonMSAARenderFlags
;
if
(
kNone_MSFBOType
!
=
fMSFBOType
)
{
msaaRenderFlags
|
=
FormatInfo
:
:
kFBOColorAttachmentWithMSAA_Flag
;
}
bool
texStorageSupported
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
texStorageSupported
=
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_storage
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
texStorageSupported
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
texStorageSupported
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
fDriverBugWorkarounds
.
disable_texture_storage
)
{
texStorageSupported
=
false
;
}
if
(
formatWorkarounds
.
fDisableTexStorage
)
{
texStorageSupported
=
false
;
}
bool
texImageSupportsSizedInternalFormat
=
(
GR_IS_GR_GL
(
standard
)
|
|
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
>
=
GR_GL_VER
(
3
0
)
)
)
;
uint32_t
fpRenderFlags
=
(
GR_IS_GR_GL
(
standard
)
)
?
msaaRenderFlags
:
nonMSAARenderFlags
;
for
(
int
i
=
0
;
i
<
kGrColorTypeCnt
;
+
+
i
)
{
fColorTypeToFormatTable
[
i
]
=
GrGLFormat
:
:
kUnknown
;
}
GrGLenum
halfFloatType
=
GR_GL_HALF_FLOAT
;
if
(
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
<
GR_GL_VER
(
3
0
)
)
|
|
(
GR_IS_GR_WEBGL
(
standard
)
&
&
version
<
GR_GL_VER
(
2
0
)
)
)
{
halfFloatType
=
GR_GL_HALF_FLOAT_OES
;
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGBA8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBA8
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGBA_8888
;
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_rgb8_rgba8
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARM_rgba8
"
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGBA8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGBA8
:
GR_GL_RGBA
;
}
bool
supportsBGRAColorType
=
GR_IS_GR_GL
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
1
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_bgra
"
)
)
;
info
.
fColorTypeInfoCount
=
supportsBGRAColorType
?
3
:
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_8888
GrGLFormat
:
:
kRGBA8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kBGRA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
formatWorkarounds
.
fDisallowBGRA8ReadPixels
?
0
:
GR_GL_BGRA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
}
if
(
supportsBGRAColorType
)
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kBGRA_8888
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kBGRA_8888
GrGLFormat
:
:
kRGBA8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kBGRA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_BGRA
;
ioFormat
.
fExternalReadFormat
=
formatWorkarounds
.
fDisallowBGRA8ReadPixels
?
0
:
GR_GL_BGRA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGB_888x
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
:
:
RGB1
(
)
;
ctInfo
.
fExternalIOFormatCount
=
1
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGB_888x
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kR8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_R8
;
info
.
fDefaultExternalFormat
=
GR_GL_RED
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kR_8
;
bool
r8Support
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
r8Support
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
r8Support
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
r8Support
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
formatWorkarounds
.
fDisallowR8ForPowerVRSGX54x
)
{
r8Support
=
false
;
}
if
(
r8Support
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_R8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_R8
:
GR_GL_RED
;
}
if
(
r8Support
)
{
info
.
fColorTypeInfoCount
=
3
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kR_8
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kR_8
GrGLFormat
:
:
kR8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kR_8
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RED
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RED
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kR_8xxx
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kAlpha_8
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kAlpha_8
GrGLFormat
:
:
kR8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_8
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RED
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RED
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_8xxx
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kGray_8
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
rrr1
"
)
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kGray_8
GrGLFormat
:
:
kR8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kGray_8
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RED
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RED
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kGray_8xxx
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
bool
alpha8IsValidForGL
=
GR_IS_GR_GL
(
standard
)
&
&
(
!
fIsCoreProfile
|
|
version
<
=
GR_GL_VER
(
3
0
)
)
;
bool
alpha8IsValidForGLES
=
GR_IS_GR_GL_ES
(
standard
)
;
bool
alpha8IsValidForWebGL
=
GR_IS_GR_WEBGL
(
standard
)
;
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kALPHA8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
bool
alpha8SizedEnumSupported
=
alpha8IsValidForGL
|
|
(
alpha8IsValidForGLES
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
)
;
bool
alpha8TexStorageSupported
=
alpha8SizedEnumSupported
&
&
texStorageSupported
;
bool
alpha8IsRenderable
=
false
;
if
(
alpha8IsValidForGL
)
{
alpha8IsRenderable
=
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_object
"
)
;
}
info
.
fInternalFormatForRenderbuffer
=
GR_GL_ALPHA8
;
info
.
fDefaultExternalFormat
=
GR_GL_ALPHA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kAlpha_8
;
if
(
alpha8IsValidForGL
|
|
alpha8IsValidForGLES
|
|
alpha8IsValidForWebGL
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
}
if
(
alpha8IsRenderable
&
&
alpha8IsValidForGL
)
{
SkASSERT
(
alpha8SizedEnumSupported
)
;
info
.
fFlags
|
=
msaaRenderFlags
;
}
if
(
alpha8TexStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_ALPHA8
;
}
else
{
if
(
!
GR_IS_GR_GL_ES
(
standard
)
&
&
texImageSupportsSizedInternalFormat
&
&
alpha8SizedEnumSupported
)
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_ALPHA8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_ALPHA
;
}
}
if
(
alpha8IsValidForGL
|
|
alpha8IsValidForGLES
|
|
alpha8IsValidForWebGL
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
if
(
alpha8IsValidForGL
|
|
alpha8IsValidForGLES
|
|
alpha8IsValidForWebGL
)
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kAlpha_8
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
int
idx
=
static_cast
<
int
>
(
GrColorType
:
:
kAlpha_8
)
;
if
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
{
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kAlpha_8
GrGLFormat
:
:
kALPHA8
)
;
}
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_8
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_ALPHA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_ALPHA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kLUMINANCE8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_LUMINANCE8
;
info
.
fDefaultExternalFormat
=
GR_GL_LUMINANCE
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kGray_8
;
bool
lum8Supported
=
false
;
bool
lum8SizedFormatSupported
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
&
&
!
fIsCoreProfile
)
{
lum8Supported
=
true
;
lum8SizedFormatSupported
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
lum8Supported
=
true
;
lum8SizedFormatSupported
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
lum8Supported
=
true
;
}
if
(
lum8Supported
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
}
if
(
texStorageSupported
&
&
lum8SizedFormatSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE8
;
}
else
if
(
texImageSupportsSizedInternalFormat
&
&
lum8SizedFormatSupported
)
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE
;
}
if
(
lum8Supported
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kGray_8
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
int
idx
=
static_cast
<
int
>
(
GrColorType
:
:
kGray_8
)
;
if
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
{
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kGray_8
GrGLFormat
:
:
kLUMINANCE8
)
;
}
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kGray_8
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_LUMINANCE
;
ioFormat
.
fExternalReadFormat
=
0
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kLUMINANCE8_ALPHA8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_LUMINANCE8_ALPHA8
;
info
.
fDefaultExternalFormat
=
GR_GL_LUMINANCE_ALPHA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kGrayAlpha_88
;
bool
la8Supported
=
false
;
bool
la8SizedFormatSupported
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
&
&
!
fIsCoreProfile
)
{
la8Supported
=
true
;
la8SizedFormatSupported
=
true
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
la8Supported
=
true
;
la8SizedFormatSupported
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
la8Supported
=
true
;
}
if
(
la8Supported
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
}
if
(
texStorageSupported
&
&
la8SizedFormatSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE8_ALPHA8
;
}
else
if
(
texImageSupportsSizedInternalFormat
&
&
la8SizedFormatSupported
)
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE8_ALPHA8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE_ALPHA
;
}
if
(
la8Supported
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kGrayAlpha_88
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
int
idx
=
static_cast
<
int
>
(
GrColorType
:
:
kGrayAlpha_88
)
;
if
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
{
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kGrayAlpha_88
GrGLFormat
:
:
kLUMINANCE8_ALPHA8
)
;
}
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kGrayAlpha_88
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_LUMINANCE_ALPHA
;
ioFormat
.
fExternalReadFormat
=
0
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kBGRA8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fDefaultExternalFormat
=
GR_GL_BGRA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kBGRA_8888
;
GrGLenum
bgraTexImageFormat
;
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_format_BGRA8888
"
)
)
{
bgraTexImageFormat
=
GR_GL_BGRA
;
}
else
{
bgraTexImageFormat
=
GR_GL_RGBA
;
}
bool
supportsBGRATexStorage
=
false
;
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_format_BGRA8888
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
ctxInfo
.
angleBackend
(
)
!
=
GrGLANGLEBackend
:
:
kUnknown
&
&
ctxInfo
.
angleDriver
(
)
!
=
GrGLDriver
:
:
kMesa
)
{
info
.
fInternalFormatForRenderbuffer
=
GR_GL_BGRA8
;
info
.
fFlags
|
=
msaaRenderFlags
;
}
else
{
info
.
fInternalFormatForRenderbuffer
=
GR_GL_BGRA
;
info
.
fFlags
|
=
nonMSAARenderFlags
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
&
&
!
formatWorkarounds
.
fDisableBGRATextureStorageForIntelWindowsES
)
{
supportsBGRATexStorage
=
true
;
}
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_APPLE_texture_format_BGRA8888
"
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBA8
;
supportsBGRATexStorage
=
true
;
}
}
}
if
(
texStorageSupported
&
&
supportsBGRATexStorage
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_BGRA8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
bgraTexImageFormat
;
}
if
(
SkToBool
(
info
.
fFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kBGRA_8888
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kBGRA_8888
GrGLFormat
:
:
kBGRA8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kBGRA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_BGRA
;
ioFormat
.
fExternalReadFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
formatWorkarounds
.
fDisallowBGRA8ReadPixels
?
0
:
GR_GL_BGRA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGB565
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGB565
;
info
.
fDefaultExternalFormat
=
GR_GL_RGB
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_SHORT_5_6_5
;
info
.
fDefaultColorType
=
GrColorType
:
:
kBGR_565
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_ES2_compatibility
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
}
if
(
texStorageSupported
&
&
GR_IS_GR_GL_ES
(
standard
)
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGB565
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGB565
:
GR_GL_RGB
;
}
if
(
SkToBool
(
info
.
fFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kBGR_565
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kBGR_565
GrGLFormat
:
:
kRGB565
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kBGR_565
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_SHORT_5_6_5
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGB
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGB
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGBA16F
)
;
info
.
fFormatType
=
FormatType
:
:
kFloat
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBA16F
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
info
.
fDefaultExternalType
=
halfFloatType
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGBA_F16
;
bool
rgba16FTextureSupport
=
false
;
bool
rgba16FRenderTargetSupport
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
rgba16FTextureSupport
=
true
;
rgba16FRenderTargetSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_float
"
)
)
{
rgba16FTextureSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
rgba16FTextureSupport
=
true
;
rgba16FRenderTargetSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float_linear
"
)
)
{
rgba16FTextureSupport
=
true
;
rgba16FRenderTargetSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
2
0
)
)
{
rgba16FTextureSupport
=
true
;
rgba16FRenderTargetSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_float
"
)
;
}
else
if
(
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_texture_half_float
"
)
)
&
&
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float_linear
"
)
|
|
ctxInfo
.
hasExtension
(
"
OES_texture_half_float_linear
"
)
)
)
{
rgba16FTextureSupport
=
true
;
rgba16FRenderTargetSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_half_float
"
)
;
}
}
if
(
rgba16FTextureSupport
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
rgba16FRenderTargetSupport
)
{
info
.
fFlags
|
=
fpRenderFlags
;
}
}
if
(
texStorageSupported
&
&
!
formatWorkarounds
.
fDisableRGBA16FTexStorageForCrBug1008003
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGBA16F
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGBA16F
:
GR_GL_RGBA
;
}
if
(
rgba16FTextureSupport
)
{
uint32_t
flags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_F16
;
ctInfo
.
fFlags
=
flags
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_F16
GrGLFormat
:
:
kRGBA16F
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F16
;
ioFormat
.
fExternalType
=
halfFloatType
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F32
;
ioFormat
.
fExternalType
=
GR_GL_FLOAT
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_F16_Clamped
;
ctInfo
.
fFlags
=
flags
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_F16_Clamped
GrGLFormat
:
:
kRGBA16F
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F16_Clamped
;
ioFormat
.
fExternalType
=
halfFloatType
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F32
;
ioFormat
.
fExternalType
=
GR_GL_FLOAT
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kR16F
)
;
info
.
fFormatType
=
FormatType
:
:
kFloat
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_R16F
;
info
.
fDefaultExternalFormat
=
GR_GL_RED
;
info
.
fDefaultExternalType
=
halfFloatType
;
info
.
fDefaultColorType
=
GrColorType
:
:
kR_F16
;
bool
r16FTextureSupport
=
false
;
bool
r16FRenderTargetSupport
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
)
{
r16FTextureSupport
=
true
;
r16FRenderTargetSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
r16FTextureSupport
=
true
;
r16FRenderTargetSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
2
0
)
)
{
r16FTextureSupport
=
true
;
r16FRenderTargetSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_float
"
)
;
}
}
if
(
r16FTextureSupport
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
r16FRenderTargetSupport
)
{
info
.
fFlags
|
=
fpRenderFlags
;
}
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_R16F
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_R16F
:
GR_GL_RED
;
}
if
(
r16FTextureSupport
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kAlpha_F16
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kAlpha_F16
GrGLFormat
:
:
kR16F
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_F16
;
ioFormat
.
fExternalType
=
halfFloatType
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RED
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RED
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_F32xxx
;
ioFormat
.
fExternalType
=
GR_GL_FLOAT
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
bool
lum16FSupported
=
false
;
bool
lum16FSizedFormatSupported
=
false
;
GrGLenum
lumHalfFloatType
=
halfFloatType
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
!
fIsCoreProfile
&
&
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_float
"
)
)
{
lum16FSupported
=
true
;
lum16FSizedFormatSupported
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float_linear
"
)
&
&
ctxInfo
.
hasExtension
(
"
GL_OES_texture_half_float
"
)
)
{
lum16FSupported
=
true
;
lumHalfFloatType
=
GR_GL_HALF_FLOAT_OES
;
lum16FSizedFormatSupported
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_storage
"
)
;
}
}
if
(
formatWorkarounds
.
fDisableLuminance16F
)
{
lum16FSupported
=
false
;
}
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kLUMINANCE16F
)
;
info
.
fFormatType
=
FormatType
:
:
kFloat
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_LUMINANCE16F
;
info
.
fDefaultExternalFormat
=
GR_GL_LUMINANCE
;
info
.
fDefaultExternalType
=
lumHalfFloatType
;
info
.
fDefaultColorType
=
GrColorType
:
:
kGray_F16
;
if
(
lum16FSupported
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
texStorageSupported
&
&
lum16FSizedFormatSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE16F
;
}
else
if
(
texImageSupportsSizedInternalFormat
&
&
lum16FSizedFormatSupported
)
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE16F
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_LUMINANCE
;
}
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kAlpha_F16
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
aaa0
"
)
;
int
idx
=
static_cast
<
int
>
(
GrColorType
:
:
kAlpha_F16
)
;
if
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
{
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kAlpha_F16
GrGLFormat
:
:
kLUMINANCE16F
)
;
}
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_F16
;
ioFormat
.
fExternalType
=
lumHalfFloatType
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_LUMINANCE
;
ioFormat
.
fExternalReadFormat
=
0
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F32
;
ioFormat
.
fExternalType
=
GR_GL_FLOAT
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGBX8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBX8
;
info
.
fDefaultExternalFormat
=
GR_GL_RGB
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGB_888
;
bool
supportsSizedRGBX
=
false
;
if
(
GR_IS_GR_GL_ES
(
standard
)
&
&
ctxInfo
.
hasExtension
(
"
GL_ANGLE_rgbx_internal_format
"
)
&
&
(
texStorageSupported
|
|
texImageSupportsSizedInternalFormat
)
)
{
supportsSizedRGBX
=
true
;
}
if
(
supportsSizedRGBX
)
{
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGBX8
;
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
}
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGB_888x
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGB_888x
GrGLFormat
:
:
kRGBX8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGB_888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGB
;
ioFormat
.
fExternalReadFormat
=
0
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGB_888x
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBX8
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGB8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGB8
;
info
.
fDefaultExternalFormat
=
GR_GL_RGB
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGB_888
;
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
info
.
fFlags
|
=
nonMSAARenderFlags
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_rgb8_rgba8
"
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGB8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGB8
:
GR_GL_RGB
;
}
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGB_888x
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
int
idx
=
static_cast
<
int
>
(
GrColorType
:
:
kRGB_888x
)
;
if
(
fColorTypeToFormatTable
[
idx
]
=
=
GrGLFormat
:
:
kUnknown
)
{
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGB_888x
GrGLFormat
:
:
kRGB8
)
;
}
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGB_888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGB
;
ioFormat
.
fExternalReadFormat
=
0
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRG8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RG8
;
info
.
fDefaultExternalFormat
=
GR_GL_RG
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRG_88
;
bool
rg8Support
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
rg8Support
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
rg8Support
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
rg8Support
=
version
>
=
GR_GL_VER
(
2
0
)
;
}
if
(
rg8Support
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RG8
;
}
}
if
(
!
(
info
.
fFlags
&
FormatInfo
:
:
kUseTexStorage_Flag
)
)
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RG8
:
GR_GL_RG
;
}
if
(
rg8Support
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRG_88
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRG_88
GrGLFormat
:
:
kRG8
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRG_88
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RG
;
ioFormat
.
fExternalReadFormat
=
0
;
if
(
GR_IS_GR_GL
(
standard
)
&
&
!
formatWorkarounds
.
fDisallowDirectRG8ReadPixels
)
{
ioFormat
.
fExternalReadFormat
=
GR_GL_RG
;
}
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGB10_A2
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGB10_A2
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_INT_2_10_10_10_REV
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGBA_1010102
;
if
(
GR_IS_GR_GL
(
standard
)
|
|
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
>
=
GR_GL_VER
(
3
0
)
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
|
msaaRenderFlags
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
&
&
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_type_2_10_10_10_REV
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGB10_A2
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGB10_A2
:
GR_GL_RGBA
;
}
if
(
SkToBool
(
info
.
fFlags
&
FormatInfo
:
:
kTexturable_Flag
)
)
{
bool
supportsBGRAColorType
=
GR_IS_GR_GL
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
1
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_bgra
"
)
)
;
info
.
fColorTypeInfoCount
=
supportsBGRAColorType
?
2
:
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_1010102
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_1010102
GrGLFormat
:
:
kRGB10_A2
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_1010102
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_INT_2_10_10_10_REV
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
if
(
supportsBGRAColorType
)
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kBGRA_1010102
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kBGRA_1010102
GrGLFormat
:
:
kRGB10_A2
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kBGRA_1010102
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_INT_2_10_10_10_REV
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_BGRA
;
ioFormat
.
fExternalReadFormat
=
formatWorkarounds
.
fDisallowBGRA8ReadPixels
?
0
:
GR_GL_BGRA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGBA4
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBA4
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_SHORT_4_4_4_4
;
info
.
fDefaultColorType
=
GrColorType
:
:
kABGR_4444
;
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
4
2
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
info
.
fFlags
|
=
msaaRenderFlags
;
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGBA4
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGBA4
:
GR_GL_RGBA
;
}
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kABGR_4444
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kABGR_4444
GrGLFormat
:
:
kRGBA4
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kABGR_4444
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_SHORT_4_4_4_4
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kSRGB8_ALPHA8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_SRGB8_ALPHA8
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_BYTE
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGBA_8888_SRGB
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
bool
srgb8Alpha8TexStorageSupported
=
texStorageSupported
;
bool
srgb8Alpha8TextureSupport
=
false
;
bool
srgb8Alpha8RenderTargetSupport
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
srgb8Alpha8TextureSupport
=
true
;
srgb8Alpha8RenderTargetSupport
=
true
;
}
else
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_sRGB
"
)
)
{
srgb8Alpha8TextureSupport
=
true
;
if
(
ctxInfo
.
hasExtension
(
"
GL_ARB_framebuffer_sRGB
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_framebuffer_sRGB
"
)
)
{
srgb8Alpha8RenderTargetSupport
=
true
;
}
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_sRGB
"
)
)
{
srgb8Alpha8TextureSupport
=
true
;
srgb8Alpha8RenderTargetSupport
=
true
;
}
if
(
version
<
GR_GL_VER
(
3
0
)
)
{
info
.
fDefaultExternalFormat
=
GR_GL_SRGB_ALPHA
;
srgb8Alpha8TexStorageSupported
=
false
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
2
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_sRGB
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_sRGB
"
)
)
{
srgb8Alpha8TextureSupport
=
true
;
srgb8Alpha8RenderTargetSupport
=
true
;
}
if
(
version
<
GR_GL_VER
(
2
0
)
)
{
info
.
fDefaultExternalFormat
=
GR_GL_SRGB_ALPHA
;
SkASSERT
(
!
srgb8Alpha8TexStorageSupported
)
;
}
}
if
(
srgb8Alpha8TextureSupport
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
srgb8Alpha8RenderTargetSupport
)
{
info
.
fFlags
|
=
formatWorkarounds
.
fDisableSRGBRenderWithMSAAForMacAMD
?
nonMSAARenderFlags
:
msaaRenderFlags
;
}
}
if
(
srgb8Alpha8TexStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_SRGB8_ALPHA8
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_SRGB8_ALPHA8
:
GR_GL_SRGB_ALPHA
;
}
if
(
srgb8Alpha8TextureSupport
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_8888_SRGB
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_8888_SRGB
GrGLFormat
:
:
kSRGB8_ALPHA8
)
;
ctInfo
.
fExternalIOFormatCount
=
1
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
GrGLenum
texImageExternalFormat
=
GR_GL_RGBA
;
if
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
=
=
GR_GL_VER
(
2
0
)
)
{
texImageExternalFormat
=
GR_GL_SRGB_ALPHA
;
}
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888_SRGB
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
texImageExternalFormat
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kCOMPRESSED_RGB8_BC1
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_COMPRESSED_RGB_S3TC_DXT1_EXT
;
if
(
GR_IS_GR_GL
(
standard
)
|
|
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_compression_s3tc
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kCOMPRESSED_RGBA8_BC1
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
;
if
(
GR_IS_GR_GL
(
standard
)
|
|
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_compression_s3tc
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kCOMPRESSED_RGB8_ETC2
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_COMPRESSED_RGB8_ETC2
;
if
(
!
formatWorkarounds
.
fDisallowETC2Compression
)
{
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
4
3
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_ES3_compatibility
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_OES_compressed_ETC2_RGB8_texture
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kCOMPRESSED_ETC1_RGB8
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_COMPRESSED_ETC1_RGB8
;
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_compressed_ETC1_RGB8_texture
"
)
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
;
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kR16
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_R16
;
info
.
fDefaultExternalFormat
=
GR_GL_RED
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_SHORT
;
info
.
fDefaultColorType
=
GrColorType
:
:
kR_16
;
bool
r16Supported
=
false
;
if
(
!
formatWorkarounds
.
fDisallowTextureUnorm16
)
{
if
(
GR_IS_GR_GL
(
standard
)
)
{
r16Supported
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
r16Supported
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_norm16
"
)
;
}
}
if
(
r16Supported
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
msaaRenderFlags
;
if
(
!
formatWorkarounds
.
fDisallowUnorm16Transfers
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTransfers_Flag
;
}
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_R16
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_R16
:
GR_GL_RED
;
}
if
(
r16Supported
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kAlpha_16
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kAlpha_16
GrGLFormat
:
:
kR16
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_16
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_SHORT
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RED
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RED
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kAlpha_8xxx
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRG16
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RG16
:
GR_GL_RG
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RG16
;
info
.
fDefaultExternalFormat
=
GR_GL_RG
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_SHORT
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRG_1616
;
bool
rg16Supported
=
false
;
if
(
!
formatWorkarounds
.
fDisallowTextureUnorm16
)
{
if
(
GR_IS_GR_GL
(
standard
)
)
{
rg16Supported
=
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_rg
"
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
rg16Supported
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_norm16
"
)
;
}
}
if
(
rg16Supported
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
msaaRenderFlags
;
if
(
!
formatWorkarounds
.
fDisallowUnorm16Transfers
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTransfers_Flag
;
}
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RG16
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RG16
:
GR_GL_RG
;
}
if
(
rg16Supported
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRG_1616
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRG_1616
GrGLFormat
:
:
kRG16
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRG_1616
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_SHORT
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RG
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RG
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
bool
rgba16Support
=
false
;
if
(
!
formatWorkarounds
.
fDisallowTextureUnorm16
)
{
if
(
GR_IS_GR_GL
(
standard
)
)
{
rgba16Support
=
version
>
=
GR_GL_VER
(
3
0
)
;
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
rgba16Support
=
ctxInfo
.
hasExtension
(
"
GL_EXT_texture_norm16
"
)
;
}
}
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRGBA16
)
;
info
.
fFormatType
=
FormatType
:
:
kNormalizedFixedPoint
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RGBA16
;
info
.
fDefaultExternalFormat
=
GR_GL_RGBA
;
info
.
fDefaultExternalType
=
GR_GL_UNSIGNED_SHORT
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRGBA_16161616
;
if
(
rgba16Support
)
{
info
.
fFlags
=
FormatInfo
:
:
kTexturable_Flag
|
msaaRenderFlags
;
if
(
!
formatWorkarounds
.
fDisallowUnorm16Transfers
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTransfers_Flag
;
}
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RGBA16
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RGBA16
:
GR_GL_RGBA
;
}
if
(
rgba16Support
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRGBA_16161616
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRGBA_16161616
GrGLFormat
:
:
kRGBA16
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_16161616
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_SHORT
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RGBA
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_8888
;
ioFormat
.
fExternalType
=
GR_GL_UNSIGNED_BYTE
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
{
bool
rg16FTextureSupport
=
false
;
bool
rg16FRenderTargetSupport
=
false
;
if
(
GR_IS_GR_GL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_texture_float
"
)
)
{
rg16FTextureSupport
=
true
;
rg16FRenderTargetSupport
=
true
;
}
}
else
if
(
GR_IS_GR_GL_ES
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
3
0
)
)
{
rg16FTextureSupport
=
true
;
rg16FRenderTargetSupport
=
version
>
=
GR_GL_VER
(
3
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
;
}
}
else
if
(
GR_IS_GR_WEBGL
(
standard
)
)
{
if
(
version
>
=
GR_GL_VER
(
2
0
)
)
{
rg16FTextureSupport
=
true
;
rg16FRenderTargetSupport
=
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_half_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
GL_EXT_color_buffer_float
"
)
|
|
ctxInfo
.
hasExtension
(
"
EXT_color_buffer_float
"
)
;
}
}
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
GrGLFormat
:
:
kRG16F
)
;
info
.
fFormatType
=
FormatType
:
:
kFloat
;
info
.
fInternalFormatForRenderbuffer
=
GR_GL_RG16F
;
info
.
fDefaultExternalFormat
=
GR_GL_RG
;
info
.
fDefaultExternalType
=
halfFloatType
;
info
.
fDefaultColorType
=
GrColorType
:
:
kRG_F16
;
if
(
rg16FTextureSupport
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kTexturable_Flag
|
FormatInfo
:
:
kTransfers_Flag
;
if
(
rg16FRenderTargetSupport
)
{
info
.
fFlags
|
=
fpRenderFlags
;
}
}
if
(
texStorageSupported
)
{
info
.
fFlags
|
=
FormatInfo
:
:
kUseTexStorage_Flag
;
info
.
fInternalFormatForTexImageOrStorage
=
GR_GL_RG16F
;
}
else
{
info
.
fInternalFormatForTexImageOrStorage
=
texImageSupportsSizedInternalFormat
?
GR_GL_RG16F
:
GR_GL_RG
;
}
if
(
rg16FTextureSupport
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
GrColorType
:
:
kRG_F16
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
this
-
>
setColorTypeFormat
(
GrColorType
:
:
kRG_F16
GrGLFormat
:
:
kRG16F
)
;
ctInfo
.
fExternalIOFormatCount
=
2
;
ctInfo
.
fExternalIOFormats
=
std
:
:
make_unique
<
ColorTypeInfo
:
:
ExternalIOFormats
[
]
>
(
ctInfo
.
fExternalIOFormatCount
)
;
int
ioIdx
=
0
;
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRG_F16
;
ioFormat
.
fExternalType
=
halfFloatType
;
ioFormat
.
fExternalTexImageFormat
=
GR_GL_RG
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RG
;
ioFormat
.
fRequiresImplementationReadQuery
=
!
GR_IS_GR_GL
(
standard
)
;
}
{
auto
&
ioFormat
=
ctInfo
.
fExternalIOFormats
[
ioIdx
+
+
]
;
ioFormat
.
fColorType
=
GrColorType
:
:
kRGBA_F32
;
ioFormat
.
fExternalType
=
GR_GL_FLOAT
;
ioFormat
.
fExternalTexImageFormat
=
0
;
ioFormat
.
fExternalReadFormat
=
GR_GL_RGBA
;
}
}
}
}
this
-
>
setupSampleCounts
(
ctxInfo
gli
)
;
#
ifdef
SK_DEBUG
for
(
int
i
=
0
;
i
<
kGrGLColorFormatCount
;
+
+
i
)
{
if
(
GrGLFormat
:
:
kUnknown
=
=
static_cast
<
GrGLFormat
>
(
i
)
)
{
continue
;
}
const
auto
&
formatInfo
=
fFormatTable
[
i
]
;
SkASSERT
(
!
(
(
formatInfo
.
fFlags
&
FormatInfo
:
:
kFBOColorAttachmentWithMSAA_Flag
)
&
&
!
(
formatInfo
.
fFlags
&
FormatInfo
:
:
kFBOColorAttachment_Flag
)
)
)
;
SkASSERT
(
formatInfo
.
fFormatType
!
=
FormatType
:
:
kUnknown
)
;
for
(
int
j
=
0
;
j
<
formatInfo
.
fColorTypeInfoCount
;
+
+
j
)
{
const
auto
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
j
]
;
SkASSERT
(
ctInfo
.
fColorType
!
=
GrColorType
:
:
kUnknown
)
;
SkASSERT
(
ctInfo
.
fFlags
)
;
for
(
int
k
=
0
;
k
<
ctInfo
.
fExternalIOFormatCount
;
+
+
k
)
{
const
auto
&
ioInfo
=
ctInfo
.
fExternalIOFormats
[
k
]
;
SkASSERT
(
ioInfo
.
fColorType
!
=
GrColorType
:
:
kUnknown
)
;
}
}
}
#
endif
}
void
GrGLCaps
:
:
setupSampleCounts
(
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
gli
)
{
GrGLStandard
standard
=
ctxInfo
.
standard
(
)
;
sk_ignore_unused_variable
(
standard
)
;
GrGLVersion
version
=
ctxInfo
.
version
(
)
;
int
maxSampleCnt
=
1
;
if
(
GrGLCaps
:
:
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_SAMPLES_IMG
&
maxSampleCnt
)
;
}
else
if
(
GrGLCaps
:
:
kNone_MSFBOType
!
=
fMSFBOType
)
{
GR_GL_GetIntegerv
(
gli
GR_GL_MAX_SAMPLES
&
maxSampleCnt
)
;
}
maxSampleCnt
=
std
:
:
max
(
1
maxSampleCnt
)
;
for
(
int
i
=
0
;
i
<
kGrGLColorFormatCount
;
+
+
i
)
{
if
(
FormatInfo
:
:
kFBOColorAttachmentWithMSAA_Flag
&
fFormatTable
[
i
]
.
fFlags
)
{
SkASSERT
(
FormatInfo
:
:
kFBOColorAttachment_Flag
&
fFormatTable
[
i
]
.
fFlags
)
;
if
(
(
GR_IS_GR_GL
(
standard
)
&
&
(
version
>
=
GR_GL_VER
(
4
2
)
|
|
ctxInfo
.
hasExtension
(
"
GL_ARB_internalformat_query
"
)
)
)
|
|
(
GR_IS_GR_GL_ES
(
standard
)
&
&
version
>
=
GR_GL_VER
(
3
0
)
)
)
{
const
bool
multisampleIsImplicit
=
GrGLCaps
:
:
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
|
|
GrGLCaps
:
:
kES_EXT_MsToTexture_MSFBOType
=
=
fMSFBOType
;
int
count
;
GrGLFormat
grGLFormat
=
static_cast
<
GrGLFormat
>
(
i
)
;
GrGLenum
glFormat
=
this
-
>
getRenderbufferInternalFormat
(
grGLFormat
)
;
GR_GL_GetInternalformativ
(
gli
GR_GL_RENDERBUFFER
glFormat
GR_GL_NUM_SAMPLE_COUNTS
1
&
count
)
;
if
(
count
)
{
std
:
:
unique_ptr
<
int
[
]
>
temp
(
new
int
[
count
]
)
;
GR_GL_GetInternalformativ
(
gli
GR_GL_RENDERBUFFER
glFormat
GR_GL_SAMPLES
count
temp
.
get
(
)
)
;
if
(
count
&
&
temp
[
count
-
1
]
=
=
1
)
{
-
-
count
;
SkASSERT
(
!
count
|
|
temp
[
count
-
1
]
>
1
)
;
}
fFormatTable
[
i
]
.
fColorSampleCounts
.
reserve
(
count
+
1
)
;
fFormatTable
[
i
]
.
fColorSampleCounts
.
push_back
(
1
)
;
for
(
int
j
=
0
;
j
<
count
;
+
+
j
)
{
#
if
defined
(
SK_BUILD_FOR_IOS
)
&
&
TARGET_OS_SIMULATOR
int
sampleCnt
=
SkPrevPow2
(
temp
[
count
-
j
-
1
]
)
;
#
else
int
sampleCnt
=
temp
[
count
-
j
-
1
]
;
#
endif
if
(
multisampleIsImplicit
&
&
sampleCnt
>
maxSampleCnt
)
{
break
;
}
fFormatTable
[
i
]
.
fColorSampleCounts
.
push_back
(
sampleCnt
)
;
}
}
}
else
{
static
constexpr
int
kDefaultSamples
[
]
=
{
1
2
4
8
}
;
int
count
=
std
:
:
size
(
kDefaultSamples
)
;
for
(
;
count
>
0
;
-
-
count
)
{
if
(
kDefaultSamples
[
count
-
1
]
<
=
maxSampleCnt
)
{
break
;
}
}
if
(
count
>
0
)
{
fFormatTable
[
i
]
.
fColorSampleCounts
.
append
(
count
kDefaultSamples
)
;
}
}
}
else
if
(
FormatInfo
:
:
kFBOColorAttachment_Flag
&
fFormatTable
[
i
]
.
fFlags
)
{
fFormatTable
[
i
]
.
fColorSampleCounts
.
resize
(
1
)
;
fFormatTable
[
i
]
.
fColorSampleCounts
[
0
]
=
1
;
}
}
}
bool
GrGLCaps
:
:
canCopyTexSubImage
(
GrGLFormat
dstFormat
bool
dstHasMSAARenderBuffer
const
GrTextureType
*
dstTypeIfTexture
GrGLFormat
srcFormat
bool
srcHasMSAARenderBuffer
const
GrTextureType
*
srcTypeIfTexture
)
const
{
if
(
this
-
>
getFormatDefaultExternalType
(
dstFormat
)
!
=
this
-
>
getFormatDefaultExternalType
(
srcFormat
)
)
{
return
false
;
}
if
(
GrGLFormatIsSRGB
(
dstFormat
)
!
=
GrGLFormatIsSRGB
(
srcFormat
)
)
{
return
false
;
}
if
(
GR_IS_GR_GL_ES
(
fStandard
)
)
{
if
(
(
dstFormat
=
=
GrGLFormat
:
:
kBGRA8
|
|
srcFormat
=
=
GrGLFormat
:
:
kBGRA8
)
&
&
!
fAllowBGRA8CopyTexSubImage
)
{
return
false
;
}
uint32_t
dstChannels
=
GrGLFormatChannels
(
dstFormat
)
;
uint32_t
srcChannels
=
GrGLFormatChannels
(
srcFormat
)
;
if
(
!
dstChannels
|
|
!
srcChannels
)
{
return
false
;
}
if
(
(
dstChannels
&
srcChannels
)
!
=
srcChannels
)
{
if
(
dstChannels
=
=
kGray_SkColorChannelFlag
|
|
dstChannels
=
=
kGrayAlpha_SkColorChannelFlags
)
{
if
(
srcChannels
=
=
kAlpha_SkColorChannelFlag
)
{
return
false
;
}
}
else
{
return
false
;
}
}
}
if
(
dstHasMSAARenderBuffer
|
|
srcHasMSAARenderBuffer
)
{
return
false
;
}
if
(
!
dstTypeIfTexture
)
{
return
false
;
}
return
this
-
>
canFormatBeFBOColorAttachment
(
srcFormat
)
&
&
(
!
srcTypeIfTexture
|
|
*
srcTypeIfTexture
!
=
GrTextureType
:
:
kExternal
)
&
&
*
dstTypeIfTexture
!
=
GrTextureType
:
:
kExternal
;
}
bool
GrGLCaps
:
:
canCopyAsBlit
(
GrGLFormat
dstFormat
int
dstSampleCnt
const
GrTextureType
*
dstTypeIfTexture
GrGLFormat
srcFormat
int
srcSampleCnt
const
GrTextureType
*
srcTypeIfTexture
const
SkRect
&
srcBounds
bool
srcBoundsExact
const
SkIRect
&
srcRect
const
SkIRect
&
dstRect
)
const
{
auto
blitFramebufferFlags
=
fBlitFramebufferFlags
;
if
(
!
this
-
>
canFormatBeFBOColorAttachment
(
dstFormat
)
|
|
!
this
-
>
canFormatBeFBOColorAttachment
(
srcFormat
)
)
{
return
false
;
}
if
(
dstTypeIfTexture
&
&
*
dstTypeIfTexture
=
=
GrTextureType
:
:
kExternal
)
{
return
false
;
}
if
(
srcTypeIfTexture
&
&
*
srcTypeIfTexture
=
=
GrTextureType
:
:
kExternal
)
{
return
false
;
}
if
(
GrGLCaps
:
:
kNoSupport_BlitFramebufferFlag
&
blitFramebufferFlags
)
{
return
false
;
}
if
(
dstSampleCnt
>
1
&
&
dstSampleCnt
!
=
srcSampleCnt
)
{
return
false
;
}
if
(
srcRect
.
width
(
)
!
=
dstRect
.
width
(
)
|
|
srcRect
.
height
(
)
!
=
dstRect
.
height
(
)
)
{
if
(
(
GrGLCaps
:
:
kNoScalingOrMirroring_BlitFramebufferFlag
&
blitFramebufferFlags
)
|
|
this
-
>
useDrawInsteadOfAllRenderTargetWrites
(
)
|
|
srcSampleCnt
>
1
)
{
return
false
;
}
}
if
(
GrGLCaps
:
:
kResolveMustBeFull_BlitFrambufferFlag
&
blitFramebufferFlags
)
{
if
(
srcSampleCnt
>
1
)
{
if
(
1
=
=
dstSampleCnt
)
{
return
false
;
}
if
(
SkRect
:
:
Make
(
srcRect
)
!
=
srcBounds
|
|
!
srcBoundsExact
)
{
return
false
;
}
}
}
if
(
GrGLCaps
:
:
kNoMSAADst_BlitFramebufferFlag
&
blitFramebufferFlags
)
{
if
(
dstSampleCnt
>
1
)
{
return
false
;
}
}
if
(
GrGLCaps
:
:
kNoFormatConversion_BlitFramebufferFlag
&
blitFramebufferFlags
)
{
if
(
srcFormat
!
=
dstFormat
)
{
return
false
;
}
}
else
if
(
GrGLCaps
:
:
kNoFormatConversionForMSAASrc_BlitFramebufferFlag
&
blitFramebufferFlags
)
{
if
(
srcSampleCnt
>
1
&
&
srcFormat
!
=
dstFormat
)
{
return
false
;
}
}
if
(
GrGLCaps
:
:
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
&
blitFramebufferFlags
)
{
if
(
srcSampleCnt
>
1
)
{
if
(
dstRect
!
=
srcRect
)
{
return
false
;
}
}
}
return
true
;
}
bool
GrGLCaps
:
:
canCopyAsDraw
(
GrGLFormat
dstFormat
bool
srcIsTexturable
bool
scalingCopy
)
const
{
return
this
-
>
isFormatRenderable
(
dstFormat
1
)
&
&
srcIsTexturable
&
&
!
(
fDisableScalingCopyAsDraws
&
&
scalingCopy
)
;
}
static
bool
has_msaa_render_buffer
(
const
GrSurfaceProxy
*
surf
const
GrGLCaps
&
glCaps
)
{
const
GrRenderTargetProxy
*
rt
=
surf
-
>
asRenderTargetProxy
(
)
;
if
(
!
rt
)
{
return
false
;
}
return
rt
-
>
numSamples
(
)
>
1
&
&
glCaps
.
usesMSAARenderBuffers
(
)
&
&
!
rt
-
>
glRTFBOIDIs0
(
)
;
}
bool
GrGLCaps
:
:
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
{
int
dstSampleCnt
=
0
;
int
srcSampleCnt
=
0
;
if
(
const
GrRenderTargetProxy
*
rtProxy
=
dst
-
>
asRenderTargetProxy
(
)
)
{
dstSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
if
(
const
GrRenderTargetProxy
*
rtProxy
=
src
-
>
asRenderTargetProxy
(
)
)
{
srcSampleCnt
=
rtProxy
-
>
numSamples
(
)
;
}
SkASSERT
(
(
dstSampleCnt
>
0
)
=
=
SkToBool
(
dst
-
>
asRenderTargetProxy
(
)
)
)
;
SkASSERT
(
(
srcSampleCnt
>
0
)
=
=
SkToBool
(
src
-
>
asRenderTargetProxy
(
)
)
)
;
const
GrTextureProxy
*
dstTex
=
dst
-
>
asTextureProxy
(
)
;
const
GrTextureProxy
*
srcTex
=
src
-
>
asTextureProxy
(
)
;
GrTextureType
dstTexType
;
GrTextureType
*
dstTexTypePtr
=
nullptr
;
GrTextureType
srcTexType
;
GrTextureType
*
srcTexTypePtr
=
nullptr
;
if
(
dstTex
)
{
dstTexType
=
dstTex
-
>
textureType
(
)
;
dstTexTypePtr
=
&
dstTexType
;
}
if
(
srcTex
)
{
srcTexType
=
srcTex
-
>
textureType
(
)
;
srcTexTypePtr
=
&
srcTexType
;
}
auto
dstFormat
=
dst
-
>
backendFormat
(
)
.
asGLFormat
(
)
;
auto
srcFormat
=
src
-
>
backendFormat
(
)
.
asGLFormat
(
)
;
const
bool
scalingCopy
=
srcRect
.
size
(
)
!
=
dstRect
.
size
(
)
;
if
(
!
scalingCopy
&
&
this
-
>
canCopyTexSubImage
(
dstFormat
has_msaa_render_buffer
(
dst
*
this
)
dstTexTypePtr
srcFormat
has_msaa_render_buffer
(
src
*
this
)
srcTexTypePtr
)
)
{
return
true
;
}
return
this
-
>
canCopyAsBlit
(
dstFormat
dstSampleCnt
dstTexTypePtr
srcFormat
srcSampleCnt
srcTexTypePtr
src
-
>
getBoundsRect
(
)
src
-
>
priv
(
)
.
isExact
(
)
srcRect
dstRect
)
|
|
this
-
>
canCopyAsDraw
(
dstFormat
SkToBool
(
srcTex
)
scalingCopy
)
;
}
GrCaps
:
:
DstCopyRestrictions
GrGLCaps
:
:
getDstCopyRestrictions
(
const
GrRenderTargetProxy
*
src
GrColorType
colorType
)
const
{
if
(
src
-
>
asTextureProxy
(
)
&
&
!
this
-
>
isFormatAsColorTypeRenderable
(
colorType
src
-
>
backendFormat
(
)
)
)
{
return
{
}
;
}
if
(
const
auto
*
texProxy
=
src
-
>
asTextureProxy
(
)
)
{
if
(
texProxy
-
>
textureType
(
)
=
=
GrTextureType
:
:
kExternal
)
{
return
{
}
;
}
}
DstCopyRestrictions
blitFramebufferRestrictions
=
{
}
;
if
(
src
-
>
numSamples
(
)
>
1
&
&
(
fBlitFramebufferFlags
&
kResolveMustBeFull_BlitFrambufferFlag
)
)
{
blitFramebufferRestrictions
.
fRectsMustMatch
=
GrSurfaceProxy
:
:
RectsMustMatch
:
:
kYes
;
blitFramebufferRestrictions
.
fMustCopyWholeSrc
=
true
;
}
else
if
(
src
-
>
numSamples
(
)
>
1
&
&
(
fBlitFramebufferFlags
&
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
)
)
{
blitFramebufferRestrictions
.
fRectsMustMatch
=
GrSurfaceProxy
:
:
RectsMustMatch
:
:
kYes
;
}
auto
srcFormat
=
src
-
>
backendFormat
(
)
.
asGLFormat
(
)
;
if
(
srcFormat
=
=
GrGLFormat
:
:
kBGRA8
)
{
if
(
this
-
>
canFormatBeFBOColorAttachment
(
srcFormat
)
)
{
return
blitFramebufferRestrictions
;
}
return
{
}
;
}
{
bool
srcIsMSAARenderbuffer
=
src
-
>
numSamples
(
)
>
1
&
&
this
-
>
usesMSAARenderBuffers
(
)
;
if
(
srcIsMSAARenderbuffer
)
{
if
(
this
-
>
canFormatBeFBOColorAttachment
(
srcFormat
)
)
{
return
blitFramebufferRestrictions
;
}
return
{
}
;
}
}
return
{
}
;
}
void
GrGLCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
GrGLContextInfo
&
ctxInfo
const
GrContextOptions
&
contextOptions
const
GrGLInterface
*
glInterface
GrShaderCaps
*
shaderCaps
FormatWorkarounds
*
formatWorkarounds
)
{
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno430
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
|
|
fDriverBugWorkarounds
.
disable_discard_framebuffer
)
{
fInvalidateFBType
=
kNone_InvalidateFBType
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kIntelCherryView
)
{
fTextureBarrierSupport
=
false
;
}
if
(
GR_IS_GR_GL
(
ctxInfo
.
standard
(
)
)
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kNVIDIA
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
367
57
0
)
)
{
fClearTextureSupport
=
false
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kTegra_PreK1
)
{
fAllowBGRA8CopyTexSubImage
=
true
;
}
if
(
fMSFBOType
=
=
kES_EXT_MsToTexture_MSFBOType
&
&
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D11
)
{
if
(
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
|
|
ctxInfo
.
angleVendor
(
)
=
=
GrGLVendor
:
:
kIntel
)
&
&
ctxInfo
.
renderer
(
)
>
=
GrGLRenderer
:
:
kIntelIceLake
)
{
fMSFBOType
=
kStandard_MSFBOType
;
fMSAAResolvesAutomatically
=
false
;
}
else
{
fDisallowDynamicMSAA
=
true
;
}
}
if
(
GR_IS_GR_WEBGL
(
ctxInfo
.
standard
(
)
)
)
{
fDisallowDynamicMSAA
=
true
;
}
#
if
defined
(
__has_feature
)
#
if
defined
(
SK_BUILD_FOR_MAC
)
&
&
__has_feature
(
thread_sanitizer
)
fMapBufferType
=
kNone_MapBufferType
;
fMapBufferFlags
=
kNone_MapFlags
;
fTransferFromBufferToTextureSupport
=
false
;
fTransferFromSurfaceToBufferSupport
=
false
;
fTransferFromBufferToBufferSupport
=
false
;
fTransferBufferType
=
TransferBufferType
:
:
kNone
;
#
endif
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
&
&
ctxInfo
.
driverVersion
(
)
>
GR_GL_DRIVER_VER
(
127
0
0
)
)
{
fMapBufferType
=
kNone_MapBufferType
;
fMapBufferFlags
=
kNone_MapFlags
;
fTransferFromBufferToTextureSupport
=
false
;
fTransferFromSurfaceToBufferSupport
=
false
;
fTransferFromBufferToBufferSupport
=
false
;
fTransferBufferType
=
TransferBufferType
:
:
kNone
;
}
if
(
angle_backend_is_d3d
(
ctxInfo
.
angleBackend
(
)
)
)
{
fTransferPixelsToRowBytesSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVR54x
)
{
fMipmapSupport
=
false
;
}
#
ifdef
SK_BUILD_FOR_ANDROID
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVR54x
)
{
formatWorkarounds
-
>
fDisallowR8ForPowerVRSGX54x
=
true
;
}
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kIntelSandyBridge
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kIntel
)
{
fMapBufferType
=
kNone_MapBufferType
;
fMapBufferFlags
=
kNone_MapFlags
;
fShaderCaps
-
>
fNonsquareMatrixSupport
=
false
;
}
if
(
ctxInfo
.
isOverCommandBuffer
(
)
&
&
ctxInfo
.
version
(
)
>
=
GR_GL_VER
(
3
0
)
)
{
formatWorkarounds
-
>
fDisallowTextureUnorm16
=
true
;
formatWorkarounds
-
>
fDisallowETC2Compression
=
true
;
fTransferFromSurfaceToBufferSupport
=
false
;
fMapBufferFlags
=
kNone_MapFlags
;
fMapBufferType
=
kNone_MapBufferType
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno615
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno620
)
{
fMSFBOType
=
kNone_MSFBOType
;
fMSAAResolvesAutomatically
=
false
;
}
#
ifndef
SK_BUILD_FOR_IOS
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVR54x
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
|
|
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
&
&
!
ctxInfo
.
isOverCommandBuffer
(
)
)
)
{
fPerformColorClearsAsDraws
=
true
;
}
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAMDRadeonHD7xxx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAMDRadeonR9M4xx
)
{
fPerformColorClearsAsDraws
=
true
;
}
#
ifdef
SK_BUILD_FOR_MAC
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
&
&
(
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
10
30
12
)
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kIntelBroadwell
)
)
{
fPerformColorClearsAsDraws
=
true
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kNVIDIA
)
{
fPerformColorClearsAsDraws
=
true
;
}
#
endif
if
(
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D11
)
{
fPerformColorClearsAsDraws
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno430
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
)
{
if
(
ctxInfo
.
driverVersion
(
)
<
=
GR_GL_DRIVER_VER
(
219
0
0
)
)
{
fPerformStencilClearsAsDraws
=
true
;
}
if
(
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
145
0
0
)
)
{
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
true
;
}
}
if
(
fDriverBugWorkarounds
.
gl_clear_broken
)
{
fPerformColorClearsAsDraws
=
true
;
fPerformStencilClearsAsDraws
=
true
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
{
fAvoidLargeIndexBufferDraws
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
|
|
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kWebGL
&
&
ctxInfo
.
webglRenderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
)
)
{
fDisablePerspectiveSDFText
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
&
&
ctxInfo
.
driverVersion
(
)
>
GR_GL_DRIVER_VER
(
53
0
0
)
)
{
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fMaxInstancesPerDrawWithoutCrashing
=
999
;
}
else
if
(
fDriverBugWorkarounds
.
disallow_large_instanced_draw
)
{
fMaxInstancesPerDrawWithoutCrashing
=
0x4000000
;
}
#
ifndef
SK_BUILD_FOR_IOS
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fMustSetAnyTexParameterToEnableMipmapping
=
true
;
fWritePixelsRowBytesSupport
=
false
;
fTransferPixelsToRowBytesSupport
=
false
;
}
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kTegra_PreK1
)
{
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
=
true
;
fUseDrawInsteadOfAllRenderTargetWrites
=
true
;
}
#
ifdef
SK_BUILD_FOR_MAC
static
constexpr
bool
isMAC
=
true
;
#
else
static
constexpr
bool
isMAC
=
false
;
#
endif
#
ifdef
SK_BUILD_FOR_ANDROID
fDontSetBaseOrMaxLevelForExternalTextures
=
true
;
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kImagination
)
{
fMipmapLevelControlSupport
=
false
;
}
#
endif
if
(
fMipmapLevelControlSupport
&
&
!
ctxInfo
.
isOverCommandBuffer
(
)
&
&
(
contextOptions
.
fDoManualMipmapping
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
|
|
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kNVIDIA
&
&
isMAC
)
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kATI
)
)
{
fDoManualMipmapping
=
true
;
}
#
ifdef
SK_BUILD_FOR_MAC
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kIntelBroadwell
)
{
fClearToBoundaryValuesIsBroken
=
true
;
}
#
endif
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
{
fDrawArraysBaseVertexIsBroken
=
true
;
}
if
(
ctxInfo
.
isRunningOverVirgl
(
)
)
{
fDrawInstancedSupport
=
false
;
}
if
(
fBaseVertexBaseInstanceSupport
&
&
!
fDrawInstancedSupport
)
{
fBaseVertexBaseInstanceSupport
=
false
;
fNativeDrawIndirectSupport
=
false
;
fMultiDrawType
=
MultiDrawType
:
:
kNone
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno530
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno5xx_other
)
{
shaderCaps
-
>
fFBFetchSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kTegra_PreK1
)
{
shaderCaps
-
>
fCanUseMinAndAbsTogether
=
false
;
shaderCaps
-
>
fCanUseFractForNegativeValues
=
false
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
)
{
shaderCaps
-
>
fMustForceNegatedAtanParamToFloat
=
true
;
}
#
if
defined
(
SK_BUILD_FOR_MAC
)
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kATI
)
{
shaderCaps
-
>
fMustForceNegatedLdexpParamToMultiply
=
true
;
}
#
endif
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
)
{
shaderCaps
-
>
fMustDoOpBetweenFloorAndAbs
=
true
;
}
if
(
shaderCaps
-
>
fFBFetchSupport
&
&
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
{
shaderCaps
-
>
fRequiresLocalOutputColorForFBFetch
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliT
)
{
shaderCaps
-
>
fMustObfuscateUniformColor
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliG
)
{
fShaderCaps
-
>
fColorSpaceMathNeedsFloat
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
)
{
fShaderCaps
-
>
fAvoidDfDxForGradientsWhenPossible
=
true
;
}
#
ifdef
SK_BUILD_FOR_WIN
if
(
angle_backend_is_d3d
(
ctxInfo
.
angleBackend
(
)
)
|
|
ctxInfo
.
isOverCommandBuffer
(
)
)
{
shaderCaps
-
>
fMustGuardDivisionEvenAfterExplicitZeroCheck
=
true
;
}
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno530
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno5xx_other
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno615
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno620
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno630
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno640
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno6xx_other
)
{
shaderCaps
-
>
fRewriteMatrixComparisons
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
)
{
shaderCaps
-
>
fCanUseFragCoord
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kTegra_PreK1
)
{
shaderCaps
-
>
fCanUseFragCoord
=
false
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
shaderCaps
-
>
fIncompleteShortIntPrecision
=
true
;
}
if
(
fDriverBugWorkarounds
.
add_and_true_to_loop_condition
)
{
shaderCaps
-
>
fAddAndTrueToLoopCondition
=
true
;
}
if
(
fDriverBugWorkarounds
.
unfold_short_circuit_as_ternary_operation
)
{
shaderCaps
-
>
fUnfoldShortCircuitAsTernary
=
true
;
}
if
(
fDriverBugWorkarounds
.
emulate_abs_int_function
)
{
shaderCaps
-
>
fEmulateAbsIntFunction
=
true
;
}
if
(
fDriverBugWorkarounds
.
rewrite_do_while_loops
)
{
shaderCaps
-
>
fRewriteDoWhileLoops
=
true
;
}
if
(
fDriverBugWorkarounds
.
remove_pow_with_constant_exponent
)
{
shaderCaps
-
>
fRemovePowWithConstantExponent
=
true
;
}
if
(
fDriverBugWorkarounds
.
disable_dual_source_blending_support
)
{
shaderCaps
-
>
fDualSourceBlendingSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
)
{
shaderCaps
-
>
fMustWriteToFragColor
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno430
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno530
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno5xx_other
|
|
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kIntel
|
|
ctxInfo
.
isOverCommandBuffer
(
)
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kNotSupported_AdvBlendEqInteraction
;
}
if
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kNVIDIA
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
337
00
0
)
&
&
kAdvanced_BlendEquationSupport
=
=
fBlendEquationSupport
)
{
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kNotSupported_AdvBlendEqInteraction
;
}
if
(
fDriverBugWorkarounds
.
disable_blend_equation_advanced
)
{
fBlendEquationSupport
=
kBasic_BlendEquationSupport
;
shaderCaps
-
>
fAdvBlendEqInteraction
=
GrShaderCaps
:
:
kNotSupported_AdvBlendEqInteraction
;
}
if
(
this
-
>
advancedBlendEquationSupport
(
)
)
{
if
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kNVIDIA
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
355
00
0
)
)
{
fAdvBlendEqDisableFlags
|
=
(
1
<
<
static_cast
<
int
>
(
skgpu
:
:
BlendEquation
:
:
kColorDodge
)
)
|
(
1
<
<
static_cast
<
int
>
(
skgpu
:
:
BlendEquation
:
:
kColorBurn
)
)
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
)
{
fAdvBlendEqDisableFlags
|
=
(
1
<
<
static_cast
<
int
>
(
skgpu
:
:
BlendEquation
:
:
kColorBurn
)
)
;
}
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno530
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno5xx_other
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno620
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno640
)
{
fMustResetBlendFuncBetweenDualSourceAndDisable
=
true
;
}
if
(
ctxInfo
.
hasExtension
(
"
GL_OES_EGL_image_external
"
)
&
&
ctxInfo
.
glslGeneration
(
)
>
=
SkSL
:
:
GLSLGeneration
:
:
k330
&
&
!
shaderCaps
-
>
fExternalTextureSupport
)
{
shaderCaps
-
>
fExternalTextureSupport
=
true
;
shaderCaps
-
>
fExternalTextureExtensionString
=
"
GL_OES_EGL_image_external
"
;
shaderCaps
-
>
fSecondExternalTextureExtensionString
=
"
GL_OES_EGL_image_external_essl3
"
;
}
#
ifdef
SK_BUILD_FOR_IOS
fWritePixelsRowBytesSupport
=
false
;
fTransferPixelsToRowBytesSupport
=
false
;
#
endif
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliT
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno430
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
|
|
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D9
)
{
fDisableTessellationPathRenderer
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
1
15
0
)
)
{
fDisableTessellationPathRenderer
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fTransferFromBufferToBufferSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fShaderCaps
-
>
fRemoveConstFromFunctionParameters
=
true
;
}
#
ifdef
SK_BUILD_FOR_WIN
if
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kIntel
|
|
(
ctxInfo
.
angleVendor
(
)
=
=
GrGLVendor
:
:
kIntel
&
&
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kOpenGL
)
)
{
fNativeDrawIndexedIndirectIsBroken
=
true
;
fUseClientSideIndirectBuffers
=
true
;
}
#
endif
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
)
{
fNeverDisableColorWrites
=
true
;
shaderCaps
-
>
fMustWriteToFragColor
=
true
;
}
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
&
&
SkSL
:
:
GLSLGeneration
:
:
k320es
!
=
ctxInfo
.
glslGeneration
(
)
)
{
shaderCaps
-
>
fNoPerspectiveInterpolationSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno430
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
)
{
fSRGBWriteControl
=
false
;
}
#
if
defined
(
SK_BUILD_FOR_MAC
)
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kATI
)
{
formatWorkarounds
-
>
fDisableSRGBRenderWithMSAAForMacAMD
=
true
;
}
#
endif
formatWorkarounds
-
>
fDisableRGBA16FTexStorageForCrBug1008003
=
ctxInfo
.
isOverCommandBuffer
(
)
&
&
ctxInfo
.
version
(
)
<
GR_GL_VER
(
3
0
)
;
#
if
defined
(
SK_BUILD_FOR_WIN
)
formatWorkarounds
-
>
fDisableBGRATextureStorageForIntelWindowsES
=
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kIntel
&
&
GR_IS_GR_GL_ES
(
ctxInfo
.
standard
(
)
)
;
#
endif
formatWorkarounds
-
>
fDisableLuminance16F
=
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kIntelBroadwell
|
|
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kQualcomm
)
&
&
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kUnknown
;
#
ifdef
SK_BUILD_FOR_MAC
formatWorkarounds
-
>
fDisallowDirectRG8ReadPixels
=
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAMDRadeonR9M3xx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAMDRadeonPro5xxx
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAMDRadeonProVegaxx
;
#
endif
#
ifdef
SK_BUILD_FOR_ANDROID
if
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kARM
&
&
!
contextOptions
.
fAlwaysUseTexStorageWhenAvailable
)
{
formatWorkarounds
-
>
fDisableTexStorage
=
true
;
}
#
endif
if
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kAndroidEmulator
)
{
shaderCaps
-
>
fNoDefaultPrecisionForExternalSamplers
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
)
{
fTiledRenderingSupport
=
false
;
}
if
(
fTiledRenderingSupport
&
&
(
!
glInterface
-
>
fFunctions
.
fStartTiling
|
|
!
glInterface
-
>
fFunctions
.
fEndTiling
)
)
{
fTiledRenderingSupport
=
false
;
}
if
(
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D9
)
{
formatWorkarounds
-
>
fDisallowBGRA8ReadPixels
=
true
;
}
if
(
(
ctxInfo
.
vendor
(
)
=
=
GrGLVendor
:
:
kIntel
|
|
ctxInfo
.
angleVendor
(
)
=
=
GrGLVendor
:
:
kIntel
)
&
&
(
ctxInfo
.
renderer
(
)
<
GrGLRenderer
:
:
kIntelIceLake
|
|
!
contextOptions
.
fAllowMSAAOnNewIntel
)
)
{
fMSFBOType
=
kNone_MSFBOType
;
}
if
(
ctxInfo
.
angleBackend
(
)
=
=
GrGLANGLEBackend
:
:
kD3D9
&
&
ctxInfo
.
angleVendor
(
)
=
=
GrGLVendor
:
:
kATI
)
{
fProgramBinarySupport
=
false
;
}
if
(
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
{
fReuseScratchTextures
=
false
;
}
if
(
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno620
|
|
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno640
)
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
571
0
0
)
)
{
fAvoidReorderingRenderTasks
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kPowerVRRogue
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kImagination
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
1
16
0
)
)
{
fShaderCaps
-
>
fShaderDerivativeSupport
=
false
;
}
if
(
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kFreedreno
)
{
formatWorkarounds
-
>
fDisallowUnorm16Transfers
=
true
;
}
if
(
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kAdreno3xx
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kQualcomm
)
|
|
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliG
)
)
{
fBindTexture0WhenChangingTextureFBOMultisampleCount
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliT
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kARM
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
1
26
0
)
)
{
fRebindColorAttachmentAfterCheckFramebufferStatus
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMaliG
&
&
ctxInfo
.
driver
(
)
=
=
GrGLDriver
:
:
kARM
&
&
ctxInfo
.
driverVersion
(
)
<
GR_GL_DRIVER_VER
(
1
19
0
)
)
{
fAnisoSupport
=
false
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kWebGL
&
&
(
ctxInfo
.
webglRenderer
(
)
=
=
GrGLRenderer
:
:
kAdreno4xx_other
|
|
ctxInfo
.
webglRenderer
(
)
=
=
GrGLRenderer
:
:
kAdreno630
)
)
{
fFlushBeforeWritePixels
=
true
;
}
if
(
ctxInfo
.
renderer
(
)
=
=
GrGLRenderer
:
:
kMali4xx
&
&
ctxInfo
.
driverVersion
(
)
>
=
GR_GL_DRIVER_VER
(
2
1
19900
)
)
{
fDisableScalingCopyAsDraws
=
true
;
}
}
void
GrGLCaps
:
:
onApplyOptionsOverrides
(
const
GrContextOptions
&
options
)
{
if
(
options
.
fDisableDriverCorrectnessWorkarounds
)
{
SkASSERT
(
!
fDoManualMipmapping
)
;
SkASSERT
(
!
fClearToBoundaryValuesIsBroken
)
;
SkASSERT
(
0
=
=
fMaxInstancesPerDrawWithoutCrashing
)
;
SkASSERT
(
!
fDrawArraysBaseVertexIsBroken
)
;
SkASSERT
(
!
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
;
SkASSERT
(
!
fUseDrawInsteadOfAllRenderTargetWrites
)
;
SkASSERT
(
!
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
)
;
SkASSERT
(
!
fDontSetBaseOrMaxLevelForExternalTextures
)
;
SkASSERT
(
!
fNeverDisableColorWrites
)
;
}
if
(
options
.
fShaderCacheStrategy
<
GrContextOptions
:
:
ShaderCacheStrategy
:
:
kBackendBinary
)
{
fProgramBinarySupport
=
false
;
}
switch
(
options
.
fSkipGLErrorChecks
)
{
case
GrContextOptions
:
:
Enable
:
:
kNo
:
fSkipErrorChecks
=
false
;
break
;
case
GrContextOptions
:
:
Enable
:
:
kYes
:
fSkipErrorChecks
=
true
;
break
;
case
GrContextOptions
:
:
Enable
:
:
kDefault
:
break
;
}
}
bool
GrGLCaps
:
:
onSurfaceSupportsWritePixels
(
const
GrSurface
*
surface
)
const
{
if
(
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
)
{
if
(
auto
tex
=
static_cast
<
const
GrGLTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
if
(
tex
-
>
hasBaseLevelBeenBoundToFBO
(
)
)
{
return
false
;
}
}
}
if
(
auto
rt
=
surface
-
>
asRenderTarget
(
)
)
{
if
(
fUseDrawInsteadOfAllRenderTargetWrites
)
{
return
false
;
}
if
(
rt
-
>
numSamples
(
)
>
1
&
&
this
-
>
usesMSAARenderBuffers
(
)
)
{
return
false
;
}
return
SkToBool
(
surface
-
>
asTexture
(
)
)
;
}
return
true
;
}
GrCaps
:
:
SurfaceReadPixelsSupport
GrGLCaps
:
:
surfaceSupportsReadPixels
(
const
GrSurface
*
surface
)
const
{
if
(
auto
tex
=
static_cast
<
const
GrGLTexture
*
>
(
surface
-
>
asTexture
(
)
)
)
{
if
(
tex
-
>
target
(
)
=
=
GR_GL_TEXTURE_EXTERNAL
|
|
GrGLFormatIsCompressed
(
tex
-
>
format
(
)
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
}
else
if
(
auto
rt
=
static_cast
<
const
GrGLRenderTarget
*
>
(
surface
-
>
asRenderTarget
(
)
)
)
{
if
(
rt
-
>
numSamples
(
)
>
1
&
&
!
rt
-
>
asTexture
(
)
)
{
return
SurfaceReadPixelsSupport
:
:
kCopyToTexture2D
;
}
}
return
SurfaceReadPixelsSupport
:
:
kSupported
;
}
size_t
offset_alignment_for_transfer_buffer
(
GrGLenum
externalType
)
{
switch
(
externalType
)
{
case
GR_GL_UNSIGNED_BYTE
:
return
sizeof
(
GrGLubyte
)
;
case
GR_GL_BYTE
:
return
sizeof
(
GrGLbyte
)
;
case
GR_GL_UNSIGNED_SHORT
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_SHORT
:
return
sizeof
(
GrGLshort
)
;
case
GR_GL_UNSIGNED_INT
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_INT
:
return
sizeof
(
GrGLint
)
;
case
GR_GL_HALF_FLOAT
:
return
sizeof
(
GrGLhalf
)
;
case
GR_GL_HALF_FLOAT_OES
:
return
sizeof
(
GrGLhalf
)
;
case
GR_GL_FLOAT
:
return
sizeof
(
GrGLfloat
)
;
case
GR_GL_UNSIGNED_SHORT_5_6_5
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_SHORT_4_4_4_4
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_SHORT_5_5_5_1
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_INT_2_10_10_10_REV
:
return
sizeof
(
GrGLuint
)
;
#
if
0
case
GR_GL_UNSIGNED_BYTE_3_3_2
:
return
sizeof
(
GrGLubyte
)
;
case
GR_GL_UNSIGNED_BYTE_2_3_3_REV
:
return
sizeof
(
GrGLubyte
)
;
case
GR_GL_UNSIGNED_SHORT_5_6_5_REV
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_SHORT_4_4_4_4_REV
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_SHORT_1_5_5_5_REV
:
return
sizeof
(
GrGLushort
)
;
case
GR_GL_UNSIGNED_INT_8_8_8_8
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_UNSIGNED_INT_8_8_8_8_REV
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_UNSIGNED_INT_10_10_10_2
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_UNSIGNED_INT_24_8
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_UNSIGNED_INT_10F_11F_11F_REV
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_UNSIGNED_INT_5_9_9_9_REV
:
return
sizeof
(
GrGLuint
)
;
case
GR_GL_FLOAT_32_UNSIGNED_INT_24_8_REV
:
return
4
;
#
endif
default
:
return
0
;
}
}
GrCaps
:
:
SupportedRead
GrGLCaps
:
:
onSupportedReadPixelsColorType
(
GrColorType
srcColorType
const
GrBackendFormat
&
srcBackendFormat
GrColorType
dstColorType
)
const
{
SkTextureCompressionType
compression
=
GrBackendFormatToCompressionType
(
srcBackendFormat
)
;
if
(
compression
!
=
SkTextureCompressionType
:
:
kNone
)
{
return
{
SkTextureCompressionTypeIsOpaque
(
compression
)
?
GrColorType
:
:
kRGB_888x
:
GrColorType
:
:
kRGBA_8888
0
}
;
}
GrCaps
:
:
SupportedRead
fallbackRead
=
{
GrColorType
:
:
kUnknown
0
}
;
const
auto
&
formatInfo
=
this
-
>
getFormatInfo
(
srcBackendFormat
.
asGLFormat
(
)
)
;
bool
foundSrcCT
=
false
;
for
(
int
i
=
0
;
!
foundSrcCT
&
&
i
<
formatInfo
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
formatInfo
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
srcColorType
)
{
const
ColorTypeInfo
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
i
]
;
foundSrcCT
=
true
;
for
(
int
j
=
0
;
j
<
ctInfo
.
fExternalIOFormatCount
;
+
+
j
)
{
const
auto
&
ioInfo
=
ctInfo
.
fExternalIOFormats
[
j
]
;
if
(
ioInfo
.
fExternalReadFormat
!
=
0
)
{
if
(
formatInfo
.
fHaveQueriedImplementationReadSupport
|
|
!
ioInfo
.
fRequiresImplementationReadQuery
)
{
GrGLenum
transferOffsetAlignment
=
0
;
if
(
formatInfo
.
fFlags
&
FormatInfo
:
:
kTransfers_Flag
)
{
transferOffsetAlignment
=
offset_alignment_for_transfer_buffer
(
ioInfo
.
fExternalType
)
;
}
if
(
ioInfo
.
fColorType
=
=
dstColorType
)
{
return
{
dstColorType
transferOffsetAlignment
}
;
}
if
(
fallbackRead
.
fColorType
=
=
GrColorType
:
:
kUnknown
)
{
fallbackRead
=
{
ioInfo
.
fColorType
transferOffsetAlignment
}
;
}
}
}
}
}
}
return
fallbackRead
;
}
GrCaps
:
:
SupportedWrite
GrGLCaps
:
:
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
{
GrColorType
fallbackCT
=
GrColorType
:
:
kUnknown
;
const
auto
&
formatInfo
=
this
-
>
getFormatInfo
(
surfaceFormat
.
asGLFormat
(
)
)
;
bool
foundSurfaceCT
=
false
;
size_t
transferOffsetAlignment
=
0
;
if
(
formatInfo
.
fFlags
&
FormatInfo
:
:
kTransfers_Flag
)
{
transferOffsetAlignment
=
1
;
}
for
(
int
i
=
0
;
!
foundSurfaceCT
&
&
i
<
formatInfo
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
formatInfo
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
surfaceColorType
)
{
const
ColorTypeInfo
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
i
]
;
foundSurfaceCT
=
true
;
for
(
int
j
=
0
;
j
<
ctInfo
.
fExternalIOFormatCount
;
+
+
j
)
{
const
auto
&
ioInfo
=
ctInfo
.
fExternalIOFormats
[
j
]
;
if
(
ioInfo
.
fExternalTexImageFormat
!
=
0
)
{
if
(
ioInfo
.
fColorType
=
=
srcColorType
)
{
return
{
srcColorType
transferOffsetAlignment
}
;
}
if
(
fallbackCT
=
=
GrColorType
:
:
kUnknown
)
{
fallbackCT
=
ioInfo
.
fColorType
;
}
}
}
}
}
return
{
fallbackCT
transferOffsetAlignment
}
;
}
bool
GrGLCaps
:
:
programBinaryFormatIsValid
(
GrGLenum
binaryFormat
)
const
{
return
std
:
:
find
(
fProgramBinaryFormats
.
begin
(
)
fProgramBinaryFormats
.
end
(
)
binaryFormat
)
!
=
fProgramBinaryFormats
.
end
(
)
;
}
bool
GrGLCaps
:
:
onIsWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
backendRT
)
const
{
GrGLFramebufferInfo
fbInfo
;
SkAssertResult
(
backendRT
.
getGLFramebufferInfo
(
&
fbInfo
)
)
;
return
fbInfo
.
fFBOID
!
=
0
;
}
bool
GrGLCaps
:
:
isFormatSRGB
(
const
GrBackendFormat
&
format
)
const
{
return
format
.
asGLFormat
(
)
=
=
GrGLFormat
:
:
kSRGB8_ALPHA8
;
}
bool
GrGLCaps
:
:
isFormatTexturable
(
const
GrBackendFormat
&
format
GrTextureType
textureType
)
const
{
if
(
textureType
=
=
GrTextureType
:
:
kRectangle
&
&
!
this
-
>
rectangleTextureSupport
(
)
)
{
return
false
;
}
return
this
-
>
isFormatTexturable
(
format
.
asGLFormat
(
)
)
;
}
bool
GrGLCaps
:
:
isFormatTexturable
(
GrGLFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
return
SkToBool
(
info
.
fFlags
&
FormatInfo
:
:
kTexturable_Flag
)
;
}
bool
GrGLCaps
:
:
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
if
(
format
.
textureType
(
)
=
=
GrTextureType
:
:
kRectangle
&
&
!
this
-
>
rectangleTextureSupport
(
)
)
{
return
false
;
}
if
(
format
.
textureType
(
)
=
=
GrTextureType
:
:
kExternal
)
{
return
false
;
}
auto
f
=
format
.
asGLFormat
(
)
;
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
f
)
;
if
(
!
SkToBool
(
info
.
colorTypeFlags
(
ct
)
&
ColorTypeInfo
:
:
kRenderable_Flag
)
)
{
return
false
;
}
return
this
-
>
isFormatRenderable
(
f
sampleCount
)
;
}
bool
GrGLCaps
:
:
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
{
if
(
format
.
textureType
(
)
=
=
GrTextureType
:
:
kRectangle
&
&
!
this
-
>
rectangleTextureSupport
(
)
)
{
return
false
;
}
if
(
format
.
textureType
(
)
=
=
GrTextureType
:
:
kExternal
)
{
return
false
;
}
return
this
-
>
isFormatRenderable
(
format
.
asGLFormat
(
)
sampleCount
)
;
}
int
GrGLCaps
:
:
getRenderTargetSampleCount
(
int
requestedCount
GrGLFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
int
count
=
info
.
fColorSampleCounts
.
size
(
)
;
if
(
!
count
)
{
return
0
;
}
requestedCount
=
std
:
:
max
(
1
requestedCount
)
;
if
(
1
=
=
requestedCount
)
{
return
info
.
fColorSampleCounts
[
0
]
=
=
1
?
1
:
0
;
}
for
(
int
sampleCount
:
info
.
fColorSampleCounts
)
{
if
(
sampleCount
>
=
requestedCount
)
{
if
(
fDriverBugWorkarounds
.
max_msaa_sample_count_4
)
{
sampleCount
=
std
:
:
min
(
sampleCount
4
)
;
}
return
sampleCount
;
}
}
return
0
;
}
int
GrGLCaps
:
:
maxRenderTargetSampleCount
(
GrGLFormat
format
)
const
{
const
FormatInfo
&
info
=
this
-
>
getFormatInfo
(
format
)
;
const
auto
&
table
=
info
.
fColorSampleCounts
;
if
(
table
.
empty
(
)
)
{
return
0
;
}
int
count
=
table
[
table
.
size
(
)
-
1
]
;
if
(
fDriverBugWorkarounds
.
max_msaa_sample_count_4
)
{
count
=
std
:
:
min
(
count
4
)
;
}
return
count
;
}
bool
GrGLCaps
:
:
canFormatBeFBOColorAttachment
(
GrGLFormat
format
)
const
{
return
SkToBool
(
this
-
>
getFormatInfo
(
format
)
.
fFlags
&
FormatInfo
:
:
kFBOColorAttachment_Flag
)
;
}
bool
GrGLCaps
:
:
isFormatCopyable
(
const
GrBackendFormat
&
format
)
const
{
return
this
-
>
canFormatBeFBOColorAttachment
(
format
.
asGLFormat
(
)
)
;
}
bool
GrGLCaps
:
:
formatSupportsTexStorage
(
GrGLFormat
format
)
const
{
return
SkToBool
(
this
-
>
getFormatInfo
(
format
)
.
fFlags
&
FormatInfo
:
:
kUseTexStorage_Flag
)
;
}
bool
GrGLCaps
:
:
shouldQueryImplementationReadSupport
(
GrGLFormat
format
)
const
{
const
auto
&
formatInfo
=
const_cast
<
GrGLCaps
*
>
(
this
)
-
>
getFormatInfo
(
format
)
;
if
(
!
formatInfo
.
fHaveQueriedImplementationReadSupport
)
{
bool
needQuery
=
false
;
for
(
int
i
=
0
;
i
<
formatInfo
.
fColorTypeInfoCount
&
&
!
needQuery
;
+
+
i
)
{
const
auto
&
surfCTInfo
=
formatInfo
.
fColorTypeInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
surfCTInfo
.
fExternalIOFormatCount
;
+
+
j
)
{
if
(
surfCTInfo
.
fExternalIOFormats
[
j
]
.
fRequiresImplementationReadQuery
)
{
needQuery
=
true
;
break
;
}
}
}
if
(
!
needQuery
)
{
const_cast
<
FormatInfo
&
>
(
formatInfo
)
.
fHaveQueriedImplementationReadSupport
=
true
;
}
}
return
!
formatInfo
.
fHaveQueriedImplementationReadSupport
;
}
void
GrGLCaps
:
:
didQueryImplementationReadSupport
(
GrGLFormat
format
GrGLenum
readFormat
GrGLenum
readType
)
const
{
auto
&
formatInfo
=
const_cast
<
GrGLCaps
*
>
(
this
)
-
>
getFormatInfo
(
format
)
;
for
(
int
i
=
0
;
i
<
formatInfo
.
fColorTypeInfoCount
;
+
+
i
)
{
auto
&
surfCTInfo
=
formatInfo
.
fColorTypeInfos
[
i
]
;
for
(
int
j
=
0
;
j
<
surfCTInfo
.
fExternalIOFormatCount
;
+
+
j
)
{
auto
&
readCTInfo
=
surfCTInfo
.
fExternalIOFormats
[
j
]
;
if
(
readCTInfo
.
fRequiresImplementationReadQuery
)
{
if
(
readCTInfo
.
fExternalReadFormat
!
=
readFormat
|
|
readCTInfo
.
fExternalType
!
=
readType
)
{
readCTInfo
.
fExternalReadFormat
=
0
;
}
}
}
}
formatInfo
.
fHaveQueriedImplementationReadSupport
=
true
;
}
bool
GrGLCaps
:
:
onAreColorTypeAndFormatCompatible
(
GrColorType
ct
const
GrBackendFormat
&
format
)
const
{
GrGLFormat
glFormat
=
format
.
asGLFormat
(
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
glFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
ct
)
{
return
true
;
}
}
return
false
;
}
GrBackendFormat
GrGLCaps
:
:
onGetDefaultBackendFormat
(
GrColorType
ct
)
const
{
auto
format
=
this
-
>
getFormatFromColorType
(
ct
)
;
if
(
format
=
=
GrGLFormat
:
:
kUnknown
)
{
return
{
}
;
}
return
GrBackendFormat
:
:
MakeGL
(
GrGLFormatToEnum
(
format
)
GR_GL_TEXTURE_2D
)
;
}
GrBackendFormat
GrGLCaps
:
:
getBackendFormatFromCompressionType
(
SkTextureCompressionType
compressionType
)
const
{
switch
(
compressionType
)
{
case
SkTextureCompressionType
:
:
kNone
:
return
{
}
;
case
SkTextureCompressionType
:
:
kETC2_RGB8_UNORM
:
if
(
this
-
>
isFormatTexturable
(
GrGLFormat
:
:
kCOMPRESSED_RGB8_ETC2
)
)
{
return
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGB8_ETC2
GR_GL_TEXTURE_2D
)
;
}
if
(
this
-
>
isFormatTexturable
(
GrGLFormat
:
:
kCOMPRESSED_ETC1_RGB8
)
)
{
return
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_ETC1_RGB8
GR_GL_TEXTURE_2D
)
;
}
return
{
}
;
case
SkTextureCompressionType
:
:
kBC1_RGB8_UNORM
:
if
(
this
-
>
isFormatTexturable
(
GrGLFormat
:
:
kCOMPRESSED_RGB8_BC1
)
)
{
return
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGB_S3TC_DXT1_EXT
GR_GL_TEXTURE_2D
)
;
}
return
{
}
;
case
SkTextureCompressionType
:
:
kBC1_RGBA8_UNORM
:
if
(
this
-
>
isFormatTexturable
(
GrGLFormat
:
:
kCOMPRESSED_RGBA8_BC1
)
)
{
return
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
GR_GL_TEXTURE_2D
)
;
}
return
{
}
;
}
SkUNREACHABLE
;
}
skgpu
:
:
Swizzle
GrGLCaps
:
:
onGetReadSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
GrGLFormat
glFormat
=
format
.
asGLFormat
(
)
;
const
auto
&
info
=
this
-
>
getFormatInfo
(
glFormat
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fReadSwizzle
;
}
}
SkDEBUGFAILF
(
"
Illegal
color
type
(
%
d
)
and
format
(
%
d
)
combination
.
"
(
int
)
colorType
(
int
)
glFormat
)
;
return
{
}
;
}
skgpu
:
:
Swizzle
GrGLCaps
:
:
getWriteSwizzle
(
const
GrBackendFormat
&
format
GrColorType
colorType
)
const
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
format
.
asGLFormat
(
)
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
const
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
i
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
)
{
return
ctInfo
.
fWriteSwizzle
;
}
}
SkDEBUGFAILF
(
"
Illegal
color
type
(
%
d
)
and
format
(
%
d
)
combination
.
"
(
int
)
colorType
(
int
)
format
.
asGLFormat
(
)
)
;
return
{
}
;
}
GrDstSampleFlags
GrGLCaps
:
:
onGetDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
rt
)
const
{
if
(
rt
-
>
asTextureProxy
(
)
)
{
return
GrDstSampleFlags
:
:
kRequiresTextureBarrier
;
}
return
GrDstSampleFlags
:
:
kNone
;
}
bool
GrGLCaps
:
:
onSupportsDynamicMSAA
(
const
GrRenderTargetProxy
*
rtProxy
)
const
{
return
!
fDisallowDynamicMSAA
;
}
uint64_t
GrGLCaps
:
:
computeFormatKey
(
const
GrBackendFormat
&
format
)
const
{
auto
glFormat
=
format
.
asGLFormat
(
)
;
return
(
uint64_t
)
(
glFormat
)
;
}
GrProgramDesc
GrGLCaps
:
:
makeDesc
(
GrRenderTarget
*
const
GrProgramInfo
&
programInfo
ProgramDescOverrideFlags
overrideFlags
)
const
{
SkASSERT
(
overrideFlags
=
=
ProgramDescOverrideFlags
:
:
kNone
)
;
GrProgramDesc
desc
;
GrProgramDesc
:
:
Build
(
&
desc
programInfo
*
this
)
;
return
desc
;
}
#
if
GR_TEST_UTILS
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
GrGLCaps
:
:
getTestingCombinations
(
)
const
{
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
combos
=
{
{
GrColorType
:
:
kAlpha_8
GrBackendFormat
:
:
MakeGL
(
GR_GL_ALPHA8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kAlpha_8
GrBackendFormat
:
:
MakeGL
(
GR_GL_R8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kBGR_565
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGB565
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kABGR_4444
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA4
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_8888
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_8888_SRGB
GrBackendFormat
:
:
MakeGL
(
GR_GL_SRGB8_ALPHA8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGB8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGB8_ETC2
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_ETC1_RGB8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGB_888x
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGB_S3TC_DXT1_EXT
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_8888
GrBackendFormat
:
:
MakeGL
(
GR_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRG_88
GrBackendFormat
:
:
MakeGL
(
GR_GL_RG8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_1010102
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGB10_A2
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kGray_8
GrBackendFormat
:
:
MakeGL
(
GR_GL_LUMINANCE8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kGray_8
GrBackendFormat
:
:
MakeGL
(
GR_GL_R8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kGrayAlpha_88
GrBackendFormat
:
:
MakeGL
(
GR_GL_LUMINANCE8_ALPHA8
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kAlpha_F16
GrBackendFormat
:
:
MakeGL
(
GR_GL_R16F
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kAlpha_F16
GrBackendFormat
:
:
MakeGL
(
GR_GL_LUMINANCE16F
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_F16
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA16F
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_F16_Clamped
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA16F
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kAlpha_16
GrBackendFormat
:
:
MakeGL
(
GR_GL_R16
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRG_1616
GrBackendFormat
:
:
MakeGL
(
GR_GL_RG16
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRGBA_16161616
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA16
GR_GL_TEXTURE_2D
)
}
{
GrColorType
:
:
kRG_F16
GrBackendFormat
:
:
MakeGL
(
GR_GL_RG16F
GR_GL_TEXTURE_2D
)
}
}
;
if
(
GR_IS_GR_GL
(
fStandard
)
)
{
combos
.
push_back
(
{
GrColorType
:
:
kBGRA_8888
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGBA8
GR_GL_TEXTURE_2D
)
}
)
;
combos
.
push_back
(
{
GrColorType
:
:
kBGRA_1010102
GrBackendFormat
:
:
MakeGL
(
GR_GL_RGB10_A2
GR_GL_TEXTURE_2D
)
}
)
;
}
else
{
SkASSERT
(
GR_IS_GR_GL_ES
(
fStandard
)
|
|
GR_IS_GR_WEBGL
(
fStandard
)
)
;
combos
.
push_back
(
{
GrColorType
:
:
kBGRA_8888
GrBackendFormat
:
:
MakeGL
(
GR_GL_BGRA8
GR_GL_TEXTURE_2D
)
}
)
;
}
if
(
this
-
>
rectangleTextureSupport
(
)
)
{
size_t
count2D
=
combos
.
size
(
)
;
for
(
size_t
i
=
0
;
i
<
count2D
;
+
+
i
)
{
auto
combo2D
=
combos
[
i
]
;
GrGLenum
formatEnum
=
GrGLFormatToEnum
(
combo2D
.
fFormat
.
asGLFormat
(
)
)
;
combos
.
push_back
(
{
combo2D
.
fColorType
GrBackendFormat
:
:
MakeGL
(
formatEnum
GR_GL_TEXTURE_RECTANGLE
)
}
)
;
}
}
return
combos
;
}
#
endif
