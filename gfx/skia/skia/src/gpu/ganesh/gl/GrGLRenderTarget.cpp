#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLRenderTarget
.
h
"
#
include
"
include
/
core
/
SkTraceMemoryDump
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrBackendUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLUtil
.
h
"
#
define
GPUGL
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
#
define
GL_CALL
(
X
)
GR_GL_CALL
(
GPUGL
-
>
glInterface
(
)
X
)
#
define
GL_CALL_RET
(
RET
X
)
GR_GL_CALL_RET
(
GPUGL
-
>
glInterface
(
)
RET
X
)
GrGLRenderTarget
:
:
GrGLRenderTarget
(
GrGLGpu
*
gpu
const
SkISize
&
dimensions
GrGLFormat
format
int
sampleCount
const
IDs
&
ids
sk_sp
<
GrGLAttachment
>
stencil
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
GrProtected
:
:
kNo
label
)
INHERITED
(
gpu
dimensions
sampleCount
GrProtected
:
:
kNo
label
std
:
:
move
(
stencil
)
)
{
this
-
>
init
(
format
ids
)
;
this
-
>
setFlags
(
gpu
-
>
glCaps
(
)
ids
)
;
this
-
>
registerWithCacheWrapped
(
GrWrapCacheable
:
:
kNo
)
;
}
GrGLRenderTarget
:
:
GrGLRenderTarget
(
GrGLGpu
*
gpu
const
SkISize
&
dimensions
GrGLFormat
format
int
sampleCount
const
IDs
&
ids
std
:
:
string_view
label
)
:
GrSurface
(
gpu
dimensions
GrProtected
:
:
kNo
label
)
INHERITED
(
gpu
dimensions
sampleCount
GrProtected
:
:
kNo
label
)
{
this
-
>
init
(
format
ids
)
;
this
-
>
setFlags
(
gpu
-
>
glCaps
(
)
ids
)
;
}
inline
void
GrGLRenderTarget
:
:
setFlags
(
const
GrGLCaps
&
glCaps
const
IDs
&
idDesc
)
{
if
(
(
fMultisampleFBOID
|
fSingleSampleFBOID
)
=
=
0
)
{
this
-
>
setGLRTFBOIDIs0
(
)
;
}
}
void
GrGLRenderTarget
:
:
init
(
GrGLFormat
format
const
IDs
&
idDesc
)
{
fMultisampleFBOID
=
idDesc
.
fMultisampleFBOID
;
fSingleSampleFBOID
=
idDesc
.
fSingleSampleFBOID
;
fMSColorRenderbufferID
=
idDesc
.
fMSColorRenderbufferID
;
fRTFBOOwnership
=
idDesc
.
fRTFBOOwnership
;
fRTFormat
=
format
;
fTotalMemorySamplesPerPixel
=
idDesc
.
fTotalMemorySamplesPerPixel
;
}
GrGLFormat
stencil_bits_to_format
(
int
stencilBits
)
{
SkASSERT
(
stencilBits
)
;
switch
(
stencilBits
)
{
case
8
:
return
GrGLFormat
:
:
kDEPTH24_STENCIL8
;
case
16
:
return
GrGLFormat
:
:
kSTENCIL_INDEX16
;
default
:
SkASSERT
(
false
)
;
return
GrGLFormat
:
:
kUnknown
;
}
}
sk_sp
<
GrGLRenderTarget
>
GrGLRenderTarget
:
:
MakeWrapped
(
GrGLGpu
*
gpu
const
SkISize
&
dimensions
GrGLFormat
format
int
sampleCount
const
IDs
&
idDesc
int
stencilBits
std
:
:
string_view
label
)
{
sk_sp
<
GrGLAttachment
>
sb
;
if
(
stencilBits
)
{
GrGLFormat
sFmt
=
stencil_bits_to_format
(
stencilBits
)
;
sb
=
GrGLAttachment
:
:
MakeWrappedRenderBuffer
(
gpu
0
dimensions
GrAttachment
:
:
UsageFlags
:
:
kStencilAttachment
sampleCount
sFmt
)
;
}
return
sk_sp
<
GrGLRenderTarget
>
(
new
GrGLRenderTarget
(
gpu
dimensions
format
sampleCount
idDesc
std
:
:
move
(
sb
)
label
)
)
;
}
GrBackendRenderTarget
GrGLRenderTarget
:
:
getBackendRenderTarget
(
)
const
{
bool
useMultisampleFBO
=
(
this
-
>
numSamples
(
)
>
1
)
;
GrGLFramebufferInfo
fbi
;
fbi
.
fFBOID
=
(
useMultisampleFBO
)
?
fMultisampleFBOID
:
fSingleSampleFBOID
;
fbi
.
fFormat
=
GrGLFormatToEnum
(
this
-
>
format
(
)
)
;
int
numStencilBits
=
0
;
if
(
GrAttachment
*
stencil
=
this
-
>
getStencilAttachment
(
useMultisampleFBO
)
)
{
numStencilBits
=
GrBackendFormatStencilBits
(
stencil
-
>
backendFormat
(
)
)
;
}
return
GrBackendRenderTarget
(
this
-
>
width
(
)
this
-
>
height
(
)
this
-
>
numSamples
(
)
numStencilBits
fbi
)
;
}
GrBackendFormat
GrGLRenderTarget
:
:
backendFormat
(
)
const
{
return
GrBackendFormat
:
:
MakeGL
(
GrGLFormatToEnum
(
fRTFormat
)
GR_GL_TEXTURE_2D
)
;
}
size_t
GrGLRenderTarget
:
:
onGpuMemorySize
(
)
const
{
return
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
fTotalMemorySamplesPerPixel
GrMipmapped
:
:
kNo
)
;
}
void
GrGLRenderTarget
:
:
onSetLabel
(
)
{
SkASSERT
(
fMSColorRenderbufferID
)
;
SkASSERT
(
fRTFBOOwnership
=
=
GrBackendObjectOwnership
:
:
kOwned
)
;
}
bool
GrGLRenderTarget
:
:
completeStencilAttachment
(
GrAttachment
*
stencil
bool
useMultisampleFBO
)
{
if
(
this
-
>
getStencilAttachment
(
useMultisampleFBO
)
!
=
stencil
)
{
fNeedsStencilAttachmentBind
[
useMultisampleFBO
]
=
true
;
}
return
true
;
}
bool
GrGLRenderTarget
:
:
ensureDynamicMSAAAttachment
(
)
{
SkASSERT
(
this
-
>
numSamples
(
)
=
=
1
)
;
if
(
fMultisampleFBOID
)
{
return
true
;
}
SkASSERT
(
!
fDynamicMSAAAttachment
)
;
GrResourceProvider
*
resourceProvider
=
this
-
>
getContext
(
)
-
>
priv
(
)
.
resourceProvider
(
)
;
const
GrCaps
&
caps
=
*
this
-
>
getGpu
(
)
-
>
caps
(
)
;
int
internalSampleCount
=
caps
.
internalMultisampleCount
(
this
-
>
backendFormat
(
)
)
;
if
(
internalSampleCount
<
=
1
)
{
return
false
;
}
if
(
resourceProvider
-
>
caps
(
)
-
>
msaaResolvesAutomatically
(
)
&
&
this
-
>
asTexture
(
)
)
{
fMultisampleFBOID
=
fSingleSampleFBOID
;
return
true
;
}
GL_CALL
(
GenFramebuffers
(
1
&
fMultisampleFBOID
)
)
;
if
(
!
fMultisampleFBOID
)
{
return
false
;
}
this
-
>
getGLGpu
(
)
-
>
bindFramebuffer
(
GR_GL_FRAMEBUFFER
fMultisampleFBOID
)
;
fDynamicMSAAAttachment
.
reset
(
static_cast
<
GrGLAttachment
*
>
(
resourceProvider
-
>
getDiscardableMSAAAttachment
(
this
-
>
dimensions
(
)
this
-
>
backendFormat
(
)
internalSampleCount
GrProtected
(
this
-
>
isProtected
(
)
)
GrMemoryless
:
:
kNo
)
.
release
(
)
)
)
;
if
(
!
fDynamicMSAAAttachment
)
{
return
false
;
}
GL_CALL
(
FramebufferRenderbuffer
(
GR_GL_FRAMEBUFFER
GR_GL_COLOR_ATTACHMENT0
GR_GL_RENDERBUFFER
fDynamicMSAAAttachment
-
>
renderbufferID
(
)
)
)
;
return
true
;
}
void
GrGLRenderTarget
:
:
bindInternal
(
GrGLenum
fboTarget
bool
useMultisampleFBO
)
{
GrGLuint
fboId
=
useMultisampleFBO
?
fMultisampleFBOID
:
fSingleSampleFBOID
;
this
-
>
getGLGpu
(
)
-
>
bindFramebuffer
(
fboTarget
fboId
)
;
if
(
fSingleSampleFBOID
!
=
0
&
&
fSingleSampleFBOID
=
=
fMultisampleFBOID
&
&
useMultisampleFBO
!
=
fDMSAARenderToTextureFBOIsMultisample
)
{
auto
*
glTex
=
static_cast
<
GrGLTexture
*
>
(
this
-
>
asTexture
(
)
)
;
if
(
this
-
>
getGLGpu
(
)
-
>
glCaps
(
)
.
bindTexture0WhenChangingTextureFBOMultisampleCount
(
)
)
{
GL_CALL
(
FramebufferTexture2D
(
fboTarget
GR_GL_COLOR_ATTACHMENT0
GR_GL_TEXTURE_2D
0
0
)
)
;
}
if
(
useMultisampleFBO
)
{
int
sampleCount
=
this
-
>
numSamples
(
)
>
1
?
this
-
>
numSamples
(
)
:
this
-
>
getGpu
(
)
-
>
caps
(
)
-
>
internalMultisampleCount
(
this
-
>
backendFormat
(
)
)
;
GL_CALL
(
FramebufferTexture2DMultisample
(
fboTarget
GR_GL_COLOR_ATTACHMENT0
glTex
-
>
target
(
)
glTex
-
>
textureID
(
)
0
sampleCount
)
)
;
}
else
{
GL_CALL
(
FramebufferTexture2D
(
fboTarget
GR_GL_COLOR_ATTACHMENT0
glTex
-
>
target
(
)
glTex
-
>
textureID
(
)
0
)
)
;
}
fDMSAARenderToTextureFBOIsMultisample
=
useMultisampleFBO
;
fNeedsStencilAttachmentBind
[
useMultisampleFBO
]
=
true
;
}
if
(
fNeedsStencilAttachmentBind
[
useMultisampleFBO
]
)
{
if
(
auto
stencil
=
this
-
>
getStencilAttachment
(
useMultisampleFBO
)
)
{
const
GrGLAttachment
*
glStencil
=
static_cast
<
const
GrGLAttachment
*
>
(
stencil
)
;
GL_CALL
(
FramebufferRenderbuffer
(
fboTarget
GR_GL_STENCIL_ATTACHMENT
GR_GL_RENDERBUFFER
glStencil
-
>
renderbufferID
(
)
)
)
;
if
(
GrGLFormatIsPackedDepthStencil
(
glStencil
-
>
format
(
)
)
)
{
GL_CALL
(
FramebufferRenderbuffer
(
fboTarget
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
glStencil
-
>
renderbufferID
(
)
)
)
;
}
else
{
GL_CALL
(
FramebufferRenderbuffer
(
fboTarget
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
}
}
else
{
GL_CALL
(
FramebufferRenderbuffer
(
fboTarget
GR_GL_STENCIL_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
GL_CALL
(
FramebufferRenderbuffer
(
fboTarget
GR_GL_DEPTH_ATTACHMENT
GR_GL_RENDERBUFFER
0
)
)
;
}
#
ifdef
SK_DEBUG
if
(
!
this
-
>
getGLGpu
(
)
-
>
glCaps
(
)
.
skipErrorChecks
(
)
&
&
!
this
-
>
getGLGpu
(
)
-
>
glCaps
(
)
.
rebindColorAttachmentAfterCheckFramebufferStatus
(
)
)
{
GrGLenum
status
;
GL_CALL_RET
(
status
CheckFramebufferStatus
(
fboTarget
)
)
;
if
(
status
!
=
GR_GL_FRAMEBUFFER_COMPLETE
)
{
SkDebugf
(
"
WARNING
:
failed
to
attach
stencil
.
\
n
"
)
;
}
}
#
endif
fNeedsStencilAttachmentBind
[
useMultisampleFBO
]
=
false
;
}
}
void
GrGLRenderTarget
:
:
bindForResolve
(
GrGLGpu
:
:
ResolveDirection
resolveDirection
)
{
SkASSERT
(
fMultisampleFBOID
!
=
0
)
;
SkASSERT
(
!
this
-
>
isMultisampledRenderToTexture
(
)
)
;
if
(
resolveDirection
=
=
GrGLGpu
:
:
ResolveDirection
:
:
kMSAAToSingle
)
{
this
-
>
bindInternal
(
GR_GL_READ_FRAMEBUFFER
true
)
;
this
-
>
bindInternal
(
GR_GL_DRAW_FRAMEBUFFER
false
)
;
}
else
{
SkASSERT
(
resolveDirection
=
=
GrGLGpu
:
:
ResolveDirection
:
:
kSingleToMSAA
)
;
SkASSERT
(
this
-
>
getGLGpu
(
)
-
>
glCaps
(
)
.
canResolveSingleToMSAA
(
)
)
;
this
-
>
bindInternal
(
GR_GL_READ_FRAMEBUFFER
false
)
;
this
-
>
bindInternal
(
GR_GL_DRAW_FRAMEBUFFER
true
)
;
}
}
void
GrGLRenderTarget
:
:
onRelease
(
)
{
if
(
GrBackendObjectOwnership
:
:
kBorrowed
!
=
fRTFBOOwnership
)
{
GrGLGpu
*
gpu
=
this
-
>
getGLGpu
(
)
;
if
(
fSingleSampleFBOID
)
{
gpu
-
>
deleteFramebuffer
(
fSingleSampleFBOID
)
;
}
if
(
fMultisampleFBOID
&
&
fMultisampleFBOID
!
=
fSingleSampleFBOID
)
{
gpu
-
>
deleteFramebuffer
(
fMultisampleFBOID
)
;
}
if
(
fMSColorRenderbufferID
)
{
GL_CALL
(
DeleteRenderbuffers
(
1
&
fMSColorRenderbufferID
)
)
;
}
}
fMultisampleFBOID
=
0
;
fSingleSampleFBOID
=
0
;
fMSColorRenderbufferID
=
0
;
INHERITED
:
:
onRelease
(
)
;
}
void
GrGLRenderTarget
:
:
onAbandon
(
)
{
fMultisampleFBOID
=
0
;
fSingleSampleFBOID
=
0
;
fMSColorRenderbufferID
=
0
;
INHERITED
:
:
onAbandon
(
)
;
}
GrGLGpu
*
GrGLRenderTarget
:
:
getGLGpu
(
)
const
{
SkASSERT
(
!
this
-
>
wasDestroyed
(
)
)
;
return
static_cast
<
GrGLGpu
*
>
(
this
-
>
getGpu
(
)
)
;
}
bool
GrGLRenderTarget
:
:
canAttemptStencilAttachment
(
bool
useMultisampleFBO
)
const
{
SkASSERT
(
!
this
-
>
getGpu
(
)
-
>
getContext
(
)
-
>
priv
(
)
.
caps
(
)
-
>
avoidStencilBuffers
(
)
)
;
return
this
-
>
fRTFBOOwnership
=
=
GrBackendObjectOwnership
:
:
kOwned
|
|
(
this
-
>
numSamples
(
)
=
=
1
&
&
useMultisampleFBO
)
;
}
void
GrGLRenderTarget
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
bool
refsWrappedRenderTargetObjects
=
this
-
>
fRTFBOOwnership
=
=
GrBackendObjectOwnership
:
:
kBorrowed
;
if
(
refsWrappedRenderTargetObjects
&
&
!
traceMemoryDump
-
>
shouldDumpWrappedObjects
(
)
)
{
return
;
}
int
numSamplesNotInTexture
=
fTotalMemorySamplesPerPixel
;
if
(
this
-
>
asTexture
(
)
)
{
-
-
numSamplesNotInTexture
;
}
if
(
numSamplesNotInTexture
>
=
1
)
{
size_t
size
=
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
numSamplesNotInTexture
GrMipmapped
:
:
kNo
)
;
SkString
resourceName
=
this
-
>
getResourceName
(
)
;
resourceName
.
append
(
"
/
renderbuffer
"
)
;
this
-
>
dumpMemoryStatisticsPriv
(
traceMemoryDump
resourceName
"
RenderTarget
"
size
)
;
SkString
renderbuffer_id
;
renderbuffer_id
.
appendU32
(
fMSColorRenderbufferID
)
;
traceMemoryDump
-
>
setMemoryBacking
(
resourceName
.
c_str
(
)
"
gl_renderbuffer
"
renderbuffer_id
.
c_str
(
)
)
;
}
}
