#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLTextureRenderTarget
.
h
"
#
include
"
include
/
core
/
SkTraceMemoryDump
.
h
"
#
include
"
include
/
gpu
/
GrDirectContext
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrDirectContextPriv
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLGpu
.
h
"
GrGLTextureRenderTarget
:
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
skgpu
:
:
Budgeted
budgeted
int
sampleCount
const
GrGLTexture
:
:
Desc
&
texDesc
const
GrGLRenderTarget
:
:
IDs
&
rtIDs
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
:
GrSurface
(
gpu
texDesc
.
fSize
GrProtected
:
:
kNo
label
)
GrGLTexture
(
gpu
texDesc
nullptr
mipmapStatus
label
)
GrGLRenderTarget
(
gpu
texDesc
.
fSize
texDesc
.
fFormat
sampleCount
rtIDs
label
)
{
this
-
>
registerWithCache
(
budgeted
)
;
}
GrGLTextureRenderTarget
:
:
GrGLTextureRenderTarget
(
GrGLGpu
*
gpu
int
sampleCount
const
GrGLTexture
:
:
Desc
&
texDesc
sk_sp
<
GrGLTextureParameters
>
parameters
const
GrGLRenderTarget
:
:
IDs
&
rtIDs
GrWrapCacheable
cacheable
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
:
GrSurface
(
gpu
texDesc
.
fSize
GrProtected
:
:
kNo
label
)
GrGLTexture
(
gpu
texDesc
std
:
:
move
(
parameters
)
mipmapStatus
label
)
GrGLRenderTarget
(
gpu
texDesc
.
fSize
texDesc
.
fFormat
sampleCount
rtIDs
label
)
{
this
-
>
registerWithCacheWrapped
(
cacheable
)
;
}
void
GrGLTextureRenderTarget
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
#
ifndef
SK_BUILD_FOR_ANDROID_FRAMEWORK
GrGLRenderTarget
:
:
dumpMemoryStatistics
(
traceMemoryDump
)
;
GrGLTexture
:
:
dumpMemoryStatistics
(
traceMemoryDump
)
;
#
else
SkString
resourceName
=
this
-
>
getResourceName
(
)
;
resourceName
.
append
(
"
/
texture_renderbuffer
"
)
;
this
-
>
dumpMemoryStatisticsPriv
(
traceMemoryDump
resourceName
"
RenderTarget
"
this
-
>
gpuMemorySize
(
)
)
;
#
endif
}
bool
GrGLTextureRenderTarget
:
:
canAttemptStencilAttachment
(
bool
useMultisampleFBO
)
const
{
SkASSERT
(
!
this
-
>
getGpu
(
)
-
>
getContext
(
)
-
>
priv
(
)
.
caps
(
)
-
>
avoidStencilBuffers
(
)
)
;
return
true
;
}
sk_sp
<
GrGLTextureRenderTarget
>
GrGLTextureRenderTarget
:
:
MakeWrapped
(
GrGLGpu
*
gpu
int
sampleCount
const
GrGLTexture
:
:
Desc
&
texDesc
sk_sp
<
GrGLTextureParameters
>
parameters
const
GrGLRenderTarget
:
:
IDs
&
rtIDs
GrWrapCacheable
cacheable
GrMipmapStatus
mipmapStatus
std
:
:
string_view
label
)
{
return
sk_sp
<
GrGLTextureRenderTarget
>
(
new
GrGLTextureRenderTarget
(
gpu
sampleCount
texDesc
std
:
:
move
(
parameters
)
rtIDs
cacheable
mipmapStatus
label
)
)
;
}
size_t
GrGLTextureRenderTarget
:
:
onGpuMemorySize
(
)
const
{
return
GrSurface
:
:
ComputeSize
(
this
-
>
backendFormat
(
)
this
-
>
dimensions
(
)
this
-
>
totalMemorySamplesPerPixel
(
)
this
-
>
mipmapped
(
)
)
;
}
void
GrGLTextureRenderTarget
:
:
onSetLabel
(
)
{
GrGLTexture
:
:
onSetLabel
(
)
;
}
