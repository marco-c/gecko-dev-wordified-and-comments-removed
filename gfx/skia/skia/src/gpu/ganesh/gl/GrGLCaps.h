#
ifndef
GrGLCaps_DEFINED
#
define
GrGLCaps_DEFINED
#
include
<
functional
>
#
include
"
include
/
private
/
SkChecksum
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrGLTypesPriv
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLAttachment
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLUtil
.
h
"
class
GrGLContextInfo
;
class
GrGLRenderTarget
;
enum
class
SkTextureCompressionType
;
class
GrGLCaps
:
public
GrCaps
{
public
:
enum
MSFBOType
{
kNone_MSFBOType
=
0
kStandard_MSFBOType
kES_Apple_MSFBOType
kES_IMG_MsToTexture_MSFBOType
kES_EXT_MsToTexture_MSFBOType
}
;
enum
BlitFramebufferFlags
{
kNoSupport_BlitFramebufferFlag
=
1
<
<
0
kNoScalingOrMirroring_BlitFramebufferFlag
=
1
<
<
1
kResolveMustBeFull_BlitFrambufferFlag
=
1
<
<
2
kNoMSAADst_BlitFramebufferFlag
=
1
<
<
3
kNoFormatConversion_BlitFramebufferFlag
=
1
<
<
4
kNoFormatConversionForMSAASrc_BlitFramebufferFlag
=
1
<
<
5
kRectsMustMatchForMSAASrc_BlitFramebufferFlag
=
1
<
<
6
}
;
enum
InvalidateFBType
{
kNone_InvalidateFBType
kDiscard_InvalidateFBType
kInvalidate_InvalidateFBType
}
;
enum
class
InvalidateBufferType
{
kNone
kNullData
kInvalidate
}
;
enum
MapBufferType
{
kNone_MapBufferType
kMapBuffer_MapBufferType
kMapBufferRange_MapBufferType
kChromium_MapBufferType
}
;
enum
class
TransferBufferType
{
kNone
kNV_PBO
kARB_PBO
kChromium
}
;
enum
class
FenceType
{
kNone
kSyncObject
kNVFence
}
;
enum
class
MultiDrawType
{
kNone
kMultiDrawIndirect
kANGLEOrWebGL
}
;
GrGLCaps
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
ctxInfo
const
GrGLInterface
*
glInterface
)
;
bool
isFormatSRGB
(
const
GrBackendFormat
&
)
const
override
;
bool
isFormatTexturable
(
const
GrBackendFormat
&
GrTextureType
)
const
override
;
bool
isFormatTexturable
(
GrGLFormat
)
const
;
bool
isFormatAsColorTypeRenderable
(
GrColorType
ct
const
GrBackendFormat
&
format
int
sampleCount
=
1
)
const
override
;
bool
isFormatRenderable
(
const
GrBackendFormat
&
format
int
sampleCount
)
const
override
;
bool
isFormatRenderable
(
GrGLFormat
format
int
sampleCount
)
const
{
return
sampleCount
<
=
this
-
>
maxRenderTargetSampleCount
(
format
)
;
}
int
getRenderTargetSampleCount
(
int
requestedCount
const
GrBackendFormat
&
format
)
const
override
{
return
this
-
>
getRenderTargetSampleCount
(
requestedCount
format
.
asGLFormat
(
)
)
;
}
int
getRenderTargetSampleCount
(
int
requestedCount
GrGLFormat
)
const
;
int
maxRenderTargetSampleCount
(
const
GrBackendFormat
&
format
)
const
override
{
return
this
-
>
maxRenderTargetSampleCount
(
format
.
asGLFormat
(
)
)
;
}
int
maxRenderTargetSampleCount
(
GrGLFormat
)
const
;
float
maxTextureMaxAnisotropy
(
)
const
{
return
fMaxTextureMaxAnisotropy
;
}
bool
isFormatCopyable
(
const
GrBackendFormat
&
)
const
override
;
bool
canFormatBeFBOColorAttachment
(
GrGLFormat
)
const
;
GrGLFormat
getFormatFromColorType
(
GrColorType
colorType
)
const
{
int
idx
=
static_cast
<
int
>
(
colorType
)
;
return
fColorTypeToFormatTable
[
idx
]
;
}
GrGLenum
getTexImageOrStorageInternalFormat
(
GrGLFormat
format
)
const
{
return
this
-
>
getFormatInfo
(
format
)
.
fInternalFormatForTexImageOrStorage
;
}
void
getTexImageExternalFormatAndType
(
GrGLFormat
surfaceFormat
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
void
getTexSubImageExternalFormatAndType
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
void
getTexSubImageDefaultFormatTypeAndColorType
(
GrGLFormat
format
GrGLenum
*
externalFormat
GrGLenum
*
externalType
GrColorType
*
colorType
)
const
;
void
getReadPixelsFormat
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
const
SkTArray
<
GrGLFormat
true
>
&
stencilFormats
(
)
const
{
return
fStencilFormats
;
}
bool
formatSupportsTexStorage
(
GrGLFormat
)
const
;
bool
shouldQueryImplementationReadSupport
(
GrGLFormat
format
)
const
;
void
didQueryImplementationReadSupport
(
GrGLFormat
format
GrGLenum
readFormat
GrGLenum
readType
)
const
;
GrGLenum
getRenderbufferInternalFormat
(
GrGLFormat
format
)
const
{
return
this
-
>
getFormatInfo
(
format
)
.
fInternalFormatForRenderbuffer
;
}
GrGLenum
getFormatDefaultExternalType
(
GrGLFormat
format
)
const
{
return
this
-
>
getFormatInfo
(
format
)
.
fDefaultExternalType
;
}
bool
hasStencilFormatBeenDeterminedForFormat
(
GrGLFormat
format
)
const
{
return
this
-
>
getFormatInfo
(
format
)
.
fStencilFormatIndex
!
=
FormatInfo
:
:
kUnknown_StencilIndex
;
}
int
getStencilFormatIndexForFormat
(
GrGLFormat
format
)
const
{
SkASSERT
(
this
-
>
hasStencilFormatBeenDeterminedForFormat
(
format
)
)
;
return
this
-
>
getFormatInfo
(
format
)
.
fStencilFormatIndex
;
}
void
setStencilFormatIndexForFormat
(
GrGLFormat
int
index
)
;
MSFBOType
msFBOType
(
)
const
{
return
fMSFBOType
;
}
bool
usesMSAARenderBuffers
(
)
const
{
return
kNone_MSFBOType
!
=
fMSFBOType
&
&
kES_IMG_MsToTexture_MSFBOType
!
=
fMSFBOType
&
&
kES_EXT_MsToTexture_MSFBOType
!
=
fMSFBOType
;
}
bool
framebufferResolvesMustBeFullSize
(
)
const
{
SkASSERT
(
fMSFBOType
!
=
kNone_MSFBOType
)
;
return
fMSFBOType
=
=
kES_Apple_MSFBOType
|
|
(
fBlitFramebufferFlags
&
kResolveMustBeFull_BlitFrambufferFlag
)
;
}
bool
canResolveSingleToMSAA
(
)
const
{
SkASSERT
(
fMSFBOType
!
=
kNone_MSFBOType
)
;
return
fMSFBOType
!
=
kES_Apple_MSFBOType
&
&
!
(
fBlitFramebufferFlags
&
GrGLCaps
:
:
kNoMSAADst_BlitFramebufferFlag
)
;
}
bool
usesImplicitMSAAResolve
(
)
const
{
return
kES_IMG_MsToTexture_MSFBOType
=
=
fMSFBOType
|
|
kES_EXT_MsToTexture_MSFBOType
=
=
fMSFBOType
;
}
InvalidateFBType
invalidateFBType
(
)
const
{
return
fInvalidateFBType
;
}
MapBufferType
mapBufferType
(
)
const
{
return
fMapBufferType
;
}
TransferBufferType
transferBufferType
(
)
const
{
return
fTransferBufferType
;
}
FenceType
fenceType
(
)
const
{
return
fFenceType
;
}
MultiDrawType
multiDrawType
(
)
const
{
return
fMultiDrawType
;
}
int
maxFragmentUniformVectors
(
)
const
{
return
fMaxFragmentUniformVectors
;
}
bool
packFlipYSupport
(
)
const
{
return
fPackFlipYSupport
;
}
bool
textureUsageSupport
(
)
const
{
return
fTextureUsageSupport
;
}
bool
imagingSupport
(
)
const
{
return
fImagingSupport
;
}
bool
vertexArrayObjectSupport
(
)
const
{
return
fVertexArrayObjectSupport
;
}
bool
debugSupport
(
)
const
{
return
fDebugSupport
;
}
bool
ES2CompatibilitySupport
(
)
const
{
return
fES2CompatibilitySupport
;
}
bool
drawRangeElementsSupport
(
)
const
{
return
fDrawRangeElementsSupport
;
}
bool
baseVertexBaseInstanceSupport
(
)
const
{
return
fBaseVertexBaseInstanceSupport
;
}
SurfaceReadPixelsSupport
surfaceSupportsReadPixels
(
const
GrSurface
*
)
const
override
;
SupportedWrite
supportedWritePixelsColorType
(
GrColorType
surfaceColorType
const
GrBackendFormat
&
surfaceFormat
GrColorType
srcColorType
)
const
override
;
bool
isCoreProfile
(
)
const
{
return
fIsCoreProfile
;
}
bool
bindFragDataLocationSupport
(
)
const
{
return
fBindFragDataLocationSupport
;
}
bool
bindUniformLocationSupport
(
)
const
{
return
fBindUniformLocationSupport
;
}
bool
rectangleTextureSupport
(
)
const
{
return
fRectangleTextureSupport
;
}
bool
mipmapLevelControlSupport
(
)
const
{
return
fMipmapLevelControlSupport
;
}
bool
mipmapLodControlSupport
(
)
const
{
return
fMipmapLodControlSupport
;
}
bool
doManualMipmapping
(
)
const
{
return
fDoManualMipmapping
;
}
void
onDumpJSON
(
SkJSONWriter
*
)
const
override
;
InvalidateBufferType
invalidateBufferType
(
)
const
{
return
fInvalidateBufferType
;
}
bool
clearToBoundaryValuesIsBroken
(
)
const
{
return
fClearToBoundaryValuesIsBroken
;
}
bool
clearTextureSupport
(
)
const
{
return
fClearTextureSupport
;
}
bool
drawArraysBaseVertexIsBroken
(
)
const
{
return
fDrawArraysBaseVertexIsBroken
;
}
bool
disallowTexSubImageForUnormConfigTexturesEverBoundToFBO
(
)
const
{
return
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
;
}
bool
useDrawInsteadOfAllRenderTargetWrites
(
)
const
{
return
fUseDrawInsteadOfAllRenderTargetWrites
;
}
bool
requiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
(
)
const
{
return
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
;
}
bool
dontSetBaseOrMaxLevelForExternalTextures
(
)
const
{
return
fDontSetBaseOrMaxLevelForExternalTextures
;
}
bool
neverDisableColorWrites
(
)
const
{
return
fNeverDisableColorWrites
;
}
bool
mustSetAnyTexParameterToEnableMipmapping
(
)
const
{
return
fMustSetAnyTexParameterToEnableMipmapping
;
}
bool
mustResetBlendFuncBetweenDualSourceAndDisable
(
)
const
{
return
fMustResetBlendFuncBetweenDualSourceAndDisable
;
}
bool
bindTexture0WhenChangingTextureFBOMultisampleCount
(
)
const
{
return
fBindTexture0WhenChangingTextureFBOMultisampleCount
;
}
bool
rebindColorAttachmentAfterCheckFramebufferStatus
(
)
const
{
return
fRebindColorAttachmentAfterCheckFramebufferStatus
;
}
bool
flushBeforeWritePixels
(
)
const
{
return
fFlushBeforeWritePixels
;
}
int
maxInstancesPerDrawWithoutCrashing
(
int
pendingInstanceCount
)
const
{
return
(
fMaxInstancesPerDrawWithoutCrashing
)
?
fMaxInstancesPerDrawWithoutCrashing
:
pendingInstanceCount
;
}
bool
canCopyTexSubImage
(
GrGLFormat
dstFormat
bool
dstHasMSAARenderBuffer
const
GrTextureType
*
dstTypeIfTexture
GrGLFormat
srcFormat
bool
srcHasMSAARenderBuffer
const
GrTextureType
*
srcTypeIfTexture
)
const
;
bool
canCopyAsBlit
(
GrGLFormat
dstFormat
int
dstSampleCnt
const
GrTextureType
*
dstTypeIfTexture
GrGLFormat
srcFormat
int
srcSampleCnt
const
GrTextureType
*
srcTypeIfTexture
const
SkRect
&
srcBounds
bool
srcBoundsExact
const
SkIRect
&
srcRect
const
SkIRect
&
dstRect
)
const
;
bool
canCopyAsDraw
(
GrGLFormat
dstFormat
bool
srcIsTexturable
bool
scalingCopy
)
const
;
DstCopyRestrictions
getDstCopyRestrictions
(
const
GrRenderTargetProxy
*
src
GrColorType
)
const
override
;
bool
programBinarySupport
(
)
const
{
return
fProgramBinarySupport
;
}
bool
programParameterSupport
(
)
const
{
return
fProgramParameterSupport
;
}
bool
programBinaryFormatIsValid
(
GrGLenum
binaryFormat
)
const
;
bool
samplerObjectSupport
(
)
const
{
return
fSamplerObjectSupport
;
}
bool
useSamplerObjects
(
)
const
{
return
fUseSamplerObjects
;
}
bool
textureSwizzleSupport
(
)
const
{
return
fTextureSwizzleSupport
;
}
bool
tiledRenderingSupport
(
)
const
{
return
fTiledRenderingSupport
;
}
bool
fbFetchRequiresEnablePerSample
(
)
const
{
return
fFBFetchRequiresEnablePerSample
;
}
bool
srgbWriteControl
(
)
const
{
return
fSRGBWriteControl
;
}
bool
skipErrorChecks
(
)
const
{
return
fSkipErrorChecks
;
}
bool
supportsProtected
(
)
const
{
return
fSupportsProtected
;
}
bool
clientCanDisableMultisample
(
)
const
{
return
fClientCanDisableMultisample
;
}
GrBackendFormat
getBackendFormatFromCompressionType
(
SkTextureCompressionType
)
const
override
;
skgpu
:
:
Swizzle
getWriteSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
uint64_t
computeFormatKey
(
const
GrBackendFormat
&
)
const
override
;
GrProgramDesc
makeDesc
(
GrRenderTarget
*
const
GrProgramInfo
&
ProgramDescOverrideFlags
)
const
override
;
#
if
GR_TEST_UTILS
GrGLStandard
standard
(
)
const
{
return
fStandard
;
}
std
:
:
vector
<
GrTest
:
:
TestFormatColorTypeCombination
>
getTestingCombinations
(
)
const
override
;
#
endif
private
:
enum
ExternalFormatUsage
{
kTexImage_ExternalFormatUsage
kReadPixels_ExternalFormatUsage
}
;
void
getExternalFormat
(
GrGLFormat
surfaceFormat
GrColorType
surfaceColorType
GrColorType
memoryColorType
ExternalFormatUsage
usage
GrGLenum
*
externalFormat
GrGLenum
*
externalType
)
const
;
void
init
(
const
GrContextOptions
&
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initGLSL
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
struct
FormatWorkarounds
{
bool
fDisableSRGBRenderWithMSAAForMacAMD
=
false
;
bool
fDisableRGBA16FTexStorageForCrBug1008003
=
false
;
bool
fDisableBGRATextureStorageForIntelWindowsES
=
false
;
bool
fDisableLuminance16F
=
false
;
bool
fDisableTexStorage
=
false
;
bool
fDisallowDirectRG8ReadPixels
=
false
;
bool
fDisallowBGRA8ReadPixels
=
false
;
bool
fDisallowR8ForPowerVRSGX54x
=
false
;
bool
fDisallowUnorm16Transfers
=
false
;
bool
fDisallowTextureUnorm16
=
false
;
bool
fDisallowETC2Compression
=
false
;
}
;
void
applyDriverCorrectnessWorkarounds
(
const
GrGLContextInfo
&
const
GrContextOptions
&
const
GrGLInterface
*
GrShaderCaps
*
FormatWorkarounds
*
)
;
void
onApplyOptionsOverrides
(
const
GrContextOptions
&
options
)
override
;
bool
onIsWindowRectanglesSupportedForRT
(
const
GrBackendRenderTarget
&
)
const
override
;
void
initFSAASupport
(
const
GrContextOptions
&
contextOptions
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
void
initBlendEqationSupport
(
const
GrGLContextInfo
&
)
;
void
initStencilSupport
(
const
GrGLContextInfo
&
)
;
void
initFormatTable
(
const
GrGLContextInfo
&
const
GrGLInterface
*
const
FormatWorkarounds
&
)
;
void
setupSampleCounts
(
const
GrGLContextInfo
&
const
GrGLInterface
*
)
;
bool
onSurfaceSupportsWritePixels
(
const
GrSurface
*
)
const
override
;
bool
onCanCopySurface
(
const
GrSurfaceProxy
*
dst
const
SkIRect
&
dstRect
const
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
)
const
override
;
GrBackendFormat
onGetDefaultBackendFormat
(
GrColorType
)
const
override
;
bool
onAreColorTypeAndFormatCompatible
(
GrColorType
const
GrBackendFormat
&
)
const
override
;
SupportedRead
onSupportedReadPixelsColorType
(
GrColorType
const
GrBackendFormat
&
GrColorType
)
const
override
;
skgpu
:
:
Swizzle
onGetReadSwizzle
(
const
GrBackendFormat
&
GrColorType
)
const
override
;
GrDstSampleFlags
onGetDstSampleFlagsForProxy
(
const
GrRenderTargetProxy
*
)
const
override
;
bool
onSupportsDynamicMSAA
(
const
GrRenderTargetProxy
*
)
const
override
;
GrGLStandard
fStandard
=
kNone_GrGLStandard
;
SkTArray
<
GrGLFormat
true
>
fStencilFormats
;
SkTArray
<
GrGLenum
true
>
fProgramBinaryFormats
;
int
fMaxFragmentUniformVectors
=
0
;
float
fMaxTextureMaxAnisotropy
=
1
.
f
;
MSFBOType
fMSFBOType
=
kNone_MSFBOType
;
InvalidateFBType
fInvalidateFBType
=
kNone_InvalidateFBType
;
InvalidateBufferType
fInvalidateBufferType
=
InvalidateBufferType
:
:
kNone
;
MapBufferType
fMapBufferType
=
kNone_MapBufferType
;
TransferBufferType
fTransferBufferType
=
TransferBufferType
:
:
kNone
;
FenceType
fFenceType
=
FenceType
:
:
kNone
;
MultiDrawType
fMultiDrawType
=
MultiDrawType
:
:
kNone
;
bool
fPackFlipYSupport
:
1
;
bool
fTextureUsageSupport
:
1
;
bool
fImagingSupport
:
1
;
bool
fVertexArrayObjectSupport
:
1
;
bool
fDebugSupport
:
1
;
bool
fES2CompatibilitySupport
:
1
;
bool
fDrawRangeElementsSupport
:
1
;
bool
fBaseVertexBaseInstanceSupport
:
1
;
bool
fIsCoreProfile
:
1
;
bool
fBindFragDataLocationSupport
:
1
;
bool
fBindUniformLocationSupport
:
1
;
bool
fRectangleTextureSupport
:
1
;
bool
fMipmapLevelControlSupport
:
1
;
bool
fMipmapLodControlSupport
:
1
;
bool
fClearTextureSupport
:
1
;
bool
fProgramBinarySupport
:
1
;
bool
fProgramParameterSupport
:
1
;
bool
fSamplerObjectSupport
:
1
;
bool
fUseSamplerObjects
:
1
;
bool
fTextureSwizzleSupport
:
1
;
bool
fTiledRenderingSupport
:
1
;
bool
fFBFetchRequiresEnablePerSample
:
1
;
bool
fSRGBWriteControl
:
1
;
bool
fSkipErrorChecks
:
1
;
bool
fClientCanDisableMultisample
:
1
;
bool
fSupportsProtected
:
1
;
bool
fDoManualMipmapping
:
1
;
bool
fClearToBoundaryValuesIsBroken
:
1
;
bool
fDrawArraysBaseVertexIsBroken
:
1
;
bool
fDisallowTexSubImageForUnormConfigTexturesEverBoundToFBO
:
1
;
bool
fUseDrawInsteadOfAllRenderTargetWrites
:
1
;
bool
fRequiresCullFaceEnableDisableWhenDrawingLinesAfterNonLines
:
1
;
bool
fDontSetBaseOrMaxLevelForExternalTextures
:
1
;
bool
fNeverDisableColorWrites
:
1
;
bool
fMustSetAnyTexParameterToEnableMipmapping
:
1
;
bool
fAllowBGRA8CopyTexSubImage
:
1
;
bool
fDisallowDynamicMSAA
:
1
;
bool
fMustResetBlendFuncBetweenDualSourceAndDisable
:
1
;
bool
fBindTexture0WhenChangingTextureFBOMultisampleCount
:
1
;
bool
fRebindColorAttachmentAfterCheckFramebufferStatus
:
1
;
bool
fFlushBeforeWritePixels
:
1
;
bool
fDisableScalingCopyAsDraws
:
1
;
int
fMaxInstancesPerDrawWithoutCrashing
=
0
;
uint32_t
fBlitFramebufferFlags
=
kNoSupport_BlitFramebufferFlag
;
struct
ReadPixelsFormat
{
ReadPixelsFormat
(
)
:
fFormat
(
0
)
fType
(
0
)
{
}
GrGLenum
fFormat
;
GrGLenum
fType
;
}
;
enum
class
FormatType
{
kUnknown
kNormalizedFixedPoint
kFloat
}
;
struct
ColorTypeInfo
{
GrColorType
fColorType
=
GrColorType
:
:
kUnknown
;
enum
{
kUploadData_Flag
=
0x1
kRenderable_Flag
=
0x2
}
;
uint32_t
fFlags
=
0
;
skgpu
:
:
Swizzle
fReadSwizzle
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
struct
ExternalIOFormats
{
GrColorType
fColorType
=
GrColorType
:
:
kUnknown
;
GrGLenum
fExternalType
=
0
;
GrGLenum
fExternalTexImageFormat
=
0
;
GrGLenum
fExternalReadFormat
=
0
;
bool
fRequiresImplementationReadQuery
=
false
;
}
;
GrGLenum
externalFormat
(
GrColorType
externalColorType
ExternalFormatUsage
usage
bool
haveQueriedImplementationReadFormat
)
const
{
for
(
int
i
=
0
;
i
<
fExternalIOFormatCount
;
+
+
i
)
{
if
(
fExternalIOFormats
[
i
]
.
fColorType
=
=
externalColorType
)
{
if
(
usage
=
=
kTexImage_ExternalFormatUsage
)
{
return
fExternalIOFormats
[
i
]
.
fExternalTexImageFormat
;
}
else
{
SkASSERT
(
usage
=
=
kReadPixels_ExternalFormatUsage
)
;
if
(
!
haveQueriedImplementationReadFormat
&
&
fExternalIOFormats
[
i
]
.
fRequiresImplementationReadQuery
)
{
return
0
;
}
return
fExternalIOFormats
[
i
]
.
fExternalReadFormat
;
}
}
}
return
0
;
}
GrGLenum
externalType
(
GrColorType
externalColorType
)
const
{
for
(
int
i
=
0
;
i
<
fExternalIOFormatCount
;
+
+
i
)
{
if
(
fExternalIOFormats
[
i
]
.
fColorType
=
=
externalColorType
)
{
return
fExternalIOFormats
[
i
]
.
fExternalType
;
}
}
return
0
;
}
std
:
:
unique_ptr
<
ExternalIOFormats
[
]
>
fExternalIOFormats
;
int
fExternalIOFormatCount
=
0
;
}
;
struct
FormatInfo
{
uint32_t
colorTypeFlags
(
GrColorType
colorType
)
const
{
for
(
int
i
=
0
;
i
<
fColorTypeInfoCount
;
+
+
i
)
{
if
(
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
return
fColorTypeInfos
[
i
]
.
fFlags
;
}
}
return
0
;
}
GrGLenum
externalFormat
(
GrColorType
surfaceColorType
GrColorType
externalColorType
ExternalFormatUsage
usage
)
const
{
for
(
int
i
=
0
;
i
<
fColorTypeInfoCount
;
+
+
i
)
{
if
(
fColorTypeInfos
[
i
]
.
fColorType
=
=
surfaceColorType
)
{
return
fColorTypeInfos
[
i
]
.
externalFormat
(
externalColorType
usage
fHaveQueriedImplementationReadSupport
)
;
}
}
return
0
;
}
GrGLenum
externalType
(
GrColorType
surfaceColorType
GrColorType
externalColorType
)
const
{
for
(
int
i
=
0
;
i
<
fColorTypeInfoCount
;
+
+
i
)
{
if
(
fColorTypeInfos
[
i
]
.
fColorType
=
=
surfaceColorType
)
{
return
fColorTypeInfos
[
i
]
.
externalType
(
externalColorType
)
;
}
}
return
0
;
}
enum
{
kTexturable_Flag
=
0x01
kFBOColorAttachment_Flag
=
0x02
kFBOColorAttachmentWithMSAA_Flag
=
0x04
kUseTexStorage_Flag
=
0x08
kTransfers_Flag
=
0x10
}
;
uint32_t
fFlags
=
0
;
FormatType
fFormatType
=
FormatType
:
:
kUnknown
;
GrGLenum
fCompressedInternalFormat
=
0
;
GrGLenum
fInternalFormatForTexImageOrStorage
=
0
;
GrGLenum
fInternalFormatForRenderbuffer
=
0
;
GrGLenum
fDefaultExternalFormat
=
0
;
GrGLenum
fDefaultExternalType
=
0
;
GrColorType
fDefaultColorType
=
GrColorType
:
:
kUnknown
;
bool
fHaveQueriedImplementationReadSupport
=
false
;
enum
{
kUnknown_StencilIndex
=
-
1
kUnsupported_StencilFormatIndex
=
-
2
}
;
int
fStencilFormatIndex
=
kUnknown_StencilIndex
;
SkTDArray
<
int
>
fColorSampleCounts
;
std
:
:
unique_ptr
<
ColorTypeInfo
[
]
>
fColorTypeInfos
;
int
fColorTypeInfoCount
=
0
;
}
;
FormatInfo
fFormatTable
[
kGrGLColorFormatCount
]
;
FormatInfo
&
getFormatInfo
(
GrGLFormat
format
)
{
return
fFormatTable
[
static_cast
<
int
>
(
format
)
]
;
}
const
FormatInfo
&
getFormatInfo
(
GrGLFormat
format
)
const
{
return
fFormatTable
[
static_cast
<
int
>
(
format
)
]
;
}
GrGLFormat
fColorTypeToFormatTable
[
kGrColorTypeCnt
]
;
void
setColorTypeFormat
(
GrColorType
GrGLFormat
)
;
using
INHERITED
=
GrCaps
;
}
;
#
endif
