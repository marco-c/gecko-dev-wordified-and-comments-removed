#
ifndef
GrGLRenderTarget_DEFINED
#
define
GrGLRenderTarget_DEFINED
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLDefines_impl
.
h
"
class
GrGLCaps
;
class
GrGLGpu
;
class
GrGLAttachment
;
class
GrGLRenderTarget
:
public
GrRenderTarget
{
public
:
using
GrSurface
:
:
glRTFBOIDis0
;
bool
alwaysClearStencil
(
)
const
override
{
return
this
-
>
glRTFBOIDis0
(
)
;
}
enum
{
kUnresolvableFBOID
=
0
}
;
struct
IDs
{
GrGLuint
fMultisampleFBOID
;
GrBackendObjectOwnership
fRTFBOOwnership
;
GrGLuint
fSingleSampleFBOID
;
GrGLuint
fMSColorRenderbufferID
;
int
fTotalMemorySamplesPerPixel
;
}
;
static
sk_sp
<
GrGLRenderTarget
>
MakeWrapped
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
int
sampleCount
const
IDs
&
int
stencilBits
std
:
:
string_view
label
)
;
bool
isFBO0
(
bool
multisample
)
const
{
return
(
multisample
?
fMultisampleFBOID
:
fSingleSampleFBOID
)
=
=
0
;
}
bool
isMultisampledRenderToTexture
(
)
const
{
return
fMultisampleFBOID
!
=
0
&
&
fMultisampleFBOID
=
=
fSingleSampleFBOID
;
}
GrBackendRenderTarget
getBackendRenderTarget
(
)
const
override
;
GrBackendFormat
backendFormat
(
)
const
override
;
bool
canAttemptStencilAttachment
(
bool
useMultisampleFBO
)
const
override
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
override
;
GrGLFormat
format
(
)
const
{
return
fRTFormat
;
}
bool
hasDynamicMSAAAttachment
(
)
const
{
return
SkToBool
(
fDynamicMSAAAttachment
)
;
}
bool
ensureDynamicMSAAAttachment
(
)
;
void
bind
(
bool
useMultisampleFBO
)
{
this
-
>
bindInternal
(
GR_GL_FRAMEBUFFER
useMultisampleFBO
)
;
}
bool
mustRebind
(
bool
useMultisampleFBO
)
const
{
return
fNeedsStencilAttachmentBind
[
useMultisampleFBO
]
;
}
void
bindForPixelOps
(
GrGLenum
fboTarget
)
{
this
-
>
bindInternal
(
fboTarget
this
-
>
numSamples
(
)
>
1
&
&
!
this
-
>
isMultisampledRenderToTexture
(
)
)
;
}
enum
class
ResolveDirection
:
bool
{
kSingleToMSAA
kMSAAToSingle
}
;
void
bindForResolve
(
ResolveDirection
)
;
protected
:
GrGLRenderTarget
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
int
sampleCount
const
IDs
&
std
:
:
string_view
label
)
;
void
init
(
GrGLFormat
const
IDs
&
)
;
void
bindInternal
(
GrGLenum
fboTarget
bool
useMultisampleFBO
)
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
int
totalMemorySamplesPerPixel
(
)
const
{
return
fTotalMemorySamplesPerPixel
;
}
private
:
GrGLRenderTarget
(
GrGLGpu
*
const
SkISize
&
GrGLFormat
int
sampleCount
const
IDs
&
sk_sp
<
GrGLAttachment
>
stencil
std
:
:
string_view
label
)
;
void
setFlags
(
const
GrGLCaps
&
const
IDs
&
)
;
GrGLGpu
*
getGLGpu
(
)
const
;
bool
completeStencilAttachment
(
GrAttachment
*
stencil
bool
useMultisampleFBO
)
override
;
size_t
onGpuMemorySize
(
)
const
override
;
void
onSetLabel
(
)
override
;
sk_sp
<
GrGLAttachment
>
fDynamicMSAAAttachment
;
GrGLuint
fMultisampleFBOID
;
GrGLuint
fSingleSampleFBOID
;
GrGLuint
fMSColorRenderbufferID
;
GrGLFormat
fRTFormat
;
bool
fNeedsStencilAttachmentBind
[
2
]
=
{
false
false
}
;
bool
fDMSAARenderToTextureFBOIsMultisample
=
false
;
GrBackendObjectOwnership
fRTFBOOwnership
;
int
fTotalMemorySamplesPerPixel
;
using
INHERITED
=
GrRenderTarget
;
}
;
#
endif
