#
ifndef
GrGLOpsRenderPass_DEFINED
#
define
GrGLOpsRenderPass_DEFINED
#
include
"
src
/
gpu
/
ganesh
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLGpu
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
gl
/
GrGLRenderTarget
.
h
"
class
GrGLGpu
;
class
GrGLRenderTarget
;
class
GrGLOpsRenderPass
:
public
GrOpsRenderPass
{
public
:
GrGLOpsRenderPass
(
GrGLGpu
*
gpu
)
:
fGpu
(
gpu
)
{
}
void
inlineUpload
(
GrOpFlushState
*
state
GrDeferredTextureUploadFn
&
upload
)
override
{
state
-
>
doUpload
(
upload
)
;
}
void
set
(
GrRenderTarget
*
bool
useMSAASurface
const
SkIRect
&
contentBounds
GrSurfaceOrigin
const
LoadAndStoreInfo
&
const
StencilLoadAndStoreInfo
&
)
;
void
reset
(
)
{
fRenderTarget
=
nullptr
;
}
private
:
GrGpu
*
gpu
(
)
override
{
return
fGpu
;
}
void
bindInstanceBuffer
(
const
GrBuffer
*
int
baseInstance
)
;
void
bindVertexBuffer
(
const
GrBuffer
*
int
baseVertex
)
;
const
void
*
offsetForBaseIndex
(
int
baseIndex
)
const
{
if
(
!
fIndexPointer
)
{
return
(
void
*
)
(
baseIndex
*
sizeof
(
uint16_t
)
)
;
}
return
fIndexPointer
+
baseIndex
;
}
GrNativeRect
dmsaaLoadStoreBounds
(
)
const
;
void
onBegin
(
)
override
;
void
onEnd
(
)
override
;
bool
onBindPipeline
(
const
GrProgramInfo
&
programInfo
const
SkRect
&
drawBounds
)
override
;
void
onSetScissorRect
(
const
SkIRect
&
scissor
)
override
;
bool
onBindTextures
(
const
GrGeometryProcessor
&
const
GrSurfaceProxy
*
const
geomProcTextures
[
]
const
GrPipeline
&
)
override
;
void
onBindBuffers
(
sk_sp
<
const
GrBuffer
>
indexBuffer
sk_sp
<
const
GrBuffer
>
instanceBuffer
sk_sp
<
const
GrBuffer
>
vertexBuffer
GrPrimitiveRestart
)
override
;
void
onDraw
(
int
vertexCount
int
baseVertex
)
override
;
void
onDrawIndexed
(
int
indexCount
int
baseIndex
uint16_t
minIndexValue
uint16_t
maxIndexValue
int
baseVertex
)
override
;
void
onDrawInstanced
(
int
instanceCount
int
baseInstance
int
vertexCount
int
baseVertex
)
override
;
void
onDrawIndexedInstanced
(
int
indexCount
int
baseIndex
int
instanceCount
int
baseInstance
int
baseVertex
)
override
;
void
onDrawIndirect
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
override
;
void
multiDrawArraysANGLEOrWebGL
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
;
void
onDrawIndexedIndirect
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
override
;
void
multiDrawElementsANGLEOrWebGL
(
const
GrBuffer
*
drawIndirectBuffer
size_t
offset
int
drawCount
)
;
void
onClear
(
const
GrScissorState
&
scissor
std
:
:
array
<
float
4
>
color
)
override
;
void
onClearStencilClip
(
const
GrScissorState
&
scissor
bool
insideStencilMask
)
override
;
GrGLGpu
*
const
fGpu
;
bool
fUseMultisampleFBO
;
SkIRect
fContentBounds
;
LoadAndStoreInfo
fColorLoadAndStoreInfo
;
StencilLoadAndStoreInfo
fStencilLoadAndStoreInfo
;
GrPrimitiveType
fPrimitiveType
;
GrGLAttribArrayState
*
fAttribArrayState
=
nullptr
;
const
uint16_t
*
fIndexPointer
;
SkDEBUGCODE
(
bool
fDidBindVertexBuffer
=
false
;
)
SkDEBUGCODE
(
bool
fDidBindInstanceBuffer
=
false
;
)
using
INHERITED
=
GrOpsRenderPass
;
}
;
#
endif
