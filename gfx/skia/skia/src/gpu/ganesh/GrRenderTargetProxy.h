#
ifndef
GrRenderTargetProxy_DEFINED
#
define
GrRenderTargetProxy_DEFINED
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyPriv
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunAllocator
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string_view
>
class
GrBackendFormat
;
class
GrCaps
;
class
GrResourceProvider
;
class
GrSurface
;
enum
class
SkBackingFit
;
struct
SkISize
;
namespace
skgpu
{
enum
class
Budgeted
:
bool
;
enum
class
Protected
:
bool
;
}
class
GrArenas
:
public
SkNVRefCnt
<
GrArenas
>
{
public
:
SkArenaAlloc
*
arenaAlloc
(
)
{
SkDEBUGCODE
(
if
(
fIsFlushed
)
SK_ABORT
(
"
Using
a
flushed
arena
"
)
;
)
return
&
fArenaAlloc
;
}
void
flush
(
)
{
SkDEBUGCODE
(
fIsFlushed
=
true
;
)
}
sktext
:
:
gpu
:
:
SubRunAllocator
*
subRunAlloc
(
)
{
return
&
fSubRunAllocator
;
}
private
:
SkArenaAlloc
fArenaAlloc
{
1024
}
;
sktext
:
:
gpu
:
:
SubRunAllocator
fSubRunAllocator
{
1024
}
;
SkDEBUGCODE
(
bool
fIsFlushed
=
false
;
)
}
;
class
GrRenderTargetProxy
:
virtual
public
GrSurfaceProxy
{
public
:
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
override
{
return
this
;
}
const
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
const
override
{
return
this
;
}
bool
instantiate
(
GrResourceProvider
*
)
override
;
bool
canUseStencil
(
const
GrCaps
&
caps
)
const
;
void
setNeedsStencil
(
)
{
fNeedsStencil
=
true
;
}
int
needsStencil
(
)
const
{
return
fNeedsStencil
;
}
int
numSamples
(
)
const
{
return
fSampleCnt
;
}
int
maxWindowRectangles
(
const
GrCaps
&
caps
)
const
;
bool
glRTFBOIDIs0
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kGLRTFBOIDIs0
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
fWrapsVkSecondaryCB
=
=
WrapsVkSecondaryCB
:
:
kYes
;
}
bool
supportsVkInputAttachment
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kVkRTSupportsInputAttachment
;
}
void
markMSAADirty
(
SkIRect
dirtyRect
)
{
SkASSERT
(
SkIRect
:
:
MakeSize
(
this
-
>
backingStoreDimensions
(
)
)
.
contains
(
dirtyRect
)
)
;
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
fMSAADirtyRect
.
join
(
dirtyRect
)
;
}
void
markMSAAResolved
(
)
{
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
fMSAADirtyRect
.
setEmpty
(
)
;
}
bool
isMSAADirty
(
)
const
{
SkASSERT
(
fMSAADirtyRect
.
isEmpty
(
)
|
|
this
-
>
requiresManualMSAAResolve
(
)
)
;
return
this
-
>
requiresManualMSAAResolve
(
)
&
&
!
fMSAADirtyRect
.
isEmpty
(
)
;
}
const
SkIRect
&
msaaDirtyRect
(
)
const
{
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
return
fMSAADirtyRect
;
}
bool
refsWrappedObjects
(
)
const
;
sk_sp
<
GrArenas
>
arenas
(
)
{
if
(
fArenas
=
=
nullptr
)
{
fArenas
=
sk_make_sp
<
GrArenas
>
(
)
;
}
return
fArenas
;
}
void
clearArenas
(
)
{
if
(
fArenas
!
=
nullptr
)
{
fArenas
-
>
flush
(
)
;
}
fArenas
=
nullptr
;
}
protected
:
friend
class
GrProxyProvider
;
friend
class
GrRenderTargetProxyPriv
;
GrRenderTargetProxy
(
const
GrCaps
&
const
GrBackendFormat
&
SkISize
int
sampleCount
SkBackingFit
skgpu
:
:
Budgeted
skgpu
:
:
Protected
GrInternalSurfaceFlags
UseAllocator
std
:
:
string_view
label
)
;
enum
class
WrapsVkSecondaryCB
:
bool
{
kNo
=
false
kYes
=
true
}
;
GrRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
SkISize
int
sampleCount
SkBackingFit
skgpu
:
:
Budgeted
skgpu
:
:
Protected
GrInternalSurfaceFlags
UseAllocator
WrapsVkSecondaryCB
std
:
:
string_view
label
)
;
GrRenderTargetProxy
(
sk_sp
<
GrSurface
>
UseAllocator
WrapsVkSecondaryCB
=
WrapsVkSecondaryCB
:
:
kNo
)
;
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
override
;
private
:
size_t
onUninstantiatedGpuMemorySize
(
)
const
override
;
SkDEBUGCODE
(
void
onValidateSurface
(
const
GrSurface
*
)
override
;
)
LazySurfaceDesc
callbackDesc
(
)
const
override
;
int8_t
fSampleCnt
;
int8_t
fNeedsStencil
=
false
;
WrapsVkSecondaryCB
fWrapsVkSecondaryCB
;
SkIRect
fMSAADirtyRect
=
SkIRect
:
:
MakeEmpty
(
)
;
sk_sp
<
GrArenas
>
fArenas
{
nullptr
}
;
char
fPadding
[
4
]
;
using
INHERITED
=
GrSurfaceProxy
;
}
;
#
endif
