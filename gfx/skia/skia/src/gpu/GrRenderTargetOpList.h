#
ifndef
GrRenderTargetOpList_DEFINED
#
define
GrRenderTargetOpList_DEFINED
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
ops
/
GrOp
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkStringUtils
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkTypes
.
h
"
class
GrAuditTrail
;
class
GrClearOp
;
class
GrCaps
;
class
GrRenderTargetProxy
;
class
GrRenderTargetOpList
final
:
public
GrOpList
{
private
:
using
DstProxy
=
GrXferProcessor
:
:
DstProxy
;
public
:
GrRenderTargetOpList
(
GrResourceProvider
*
sk_sp
<
GrOpMemoryPool
>
GrRenderTargetProxy
*
GrAuditTrail
*
)
;
~
GrRenderTargetOpList
(
)
override
;
void
makeClosed
(
const
GrCaps
&
caps
)
override
{
if
(
this
-
>
isClosed
(
)
)
{
return
;
}
this
-
>
forwardCombine
(
caps
)
;
INHERITED
:
:
makeClosed
(
caps
)
;
}
bool
isEmpty
(
)
const
{
return
fRecordedOps
.
empty
(
)
;
}
void
endFlush
(
)
override
;
void
onPrepare
(
GrOpFlushState
*
flushState
)
override
;
bool
onExecute
(
GrOpFlushState
*
flushState
)
override
;
uint32_t
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
&
caps
this
]
(
GrSurfaceProxy
*
p
)
{
this
-
>
addDependency
(
p
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
return
this
-
>
recordOp
(
std
:
:
move
(
op
)
caps
)
;
}
uint32_t
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
const
GrCaps
&
caps
GrAppliedClip
&
&
clip
const
DstProxy
&
dstProxy
)
{
auto
addDependency
=
[
&
caps
this
]
(
GrSurfaceProxy
*
p
)
{
this
-
>
addDependency
(
p
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
clip
.
visitProxies
(
addDependency
)
;
if
(
dstProxy
.
proxy
(
)
)
{
addDependency
(
dstProxy
.
proxy
(
)
)
;
}
return
this
-
>
recordOp
(
std
:
:
move
(
op
)
caps
clip
.
doesClip
(
)
?
&
clip
:
nullptr
&
dstProxy
)
;
}
void
discard
(
)
;
void
fullClear
(
GrContext
*
GrColor
color
)
;
bool
copySurface
(
GrContext
*
GrSurfaceProxy
*
dst
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
override
;
GrRenderTargetOpList
*
asRenderTargetOpList
(
)
override
{
return
this
;
}
SkDEBUGCODE
(
void
dump
(
bool
printDependencies
)
const
override
;
)
SkDEBUGCODE
(
int
numOps
(
)
const
override
{
return
fRecordedOps
.
count
(
)
;
}
)
SkDEBUGCODE
(
int
numClips
(
)
const
override
{
return
fNumClips
;
}
)
SkDEBUGCODE
(
void
visitProxies_debugOnly
(
const
GrOp
:
:
VisitProxyFunc
&
)
const
;
)
private
:
friend
class
GrRenderTargetContextPriv
;
void
deleteOps
(
)
;
struct
RecordedOp
{
RecordedOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrAppliedClip
*
appliedClip
const
DstProxy
*
dstProxy
)
:
fOp
(
std
:
:
move
(
op
)
)
fAppliedClip
(
appliedClip
)
{
if
(
dstProxy
)
{
fDstProxy
=
*
dstProxy
;
}
}
~
RecordedOp
(
)
{
SkASSERT
(
!
fOp
)
;
}
void
deleteOp
(
GrOpMemoryPool
*
opMemoryPool
)
;
void
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
func
)
const
{
if
(
fOp
)
{
fOp
-
>
visitProxies
(
func
)
;
}
if
(
fDstProxy
.
proxy
(
)
)
{
func
(
fDstProxy
.
proxy
(
)
)
;
}
if
(
fAppliedClip
)
{
fAppliedClip
-
>
visitProxies
(
func
)
;
}
}
std
:
:
unique_ptr
<
GrOp
>
fOp
;
DstProxy
fDstProxy
;
GrAppliedClip
*
fAppliedClip
;
}
;
void
purgeOpsWithUninstantiatedProxies
(
)
override
;
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
override
;
uint32_t
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
const
GrCaps
&
caps
GrAppliedClip
*
=
nullptr
const
DstProxy
*
=
nullptr
)
;
void
forwardCombine
(
const
GrCaps
&
)
;
GrOp
:
:
CombineResult
combineIfPossible
(
const
RecordedOp
&
a
GrOp
*
b
const
GrAppliedClip
*
bClip
const
DstProxy
*
bDstTexture
const
GrCaps
&
)
;
uint32_t
fLastClipStackGenID
;
SkIRect
fLastDevClipBounds
;
int
fLastClipNumAnalyticFPs
;
SkSTArray
<
25
RecordedOp
true
>
fRecordedOps
;
SkArenaAlloc
fClipAllocator
{
4096
}
;
SkDEBUGCODE
(
int
fNumClips
;
)
typedef
GrOpList
INHERITED
;
}
;
#
endif
