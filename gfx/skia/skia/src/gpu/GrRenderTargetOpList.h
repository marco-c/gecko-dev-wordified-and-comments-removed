#
ifndef
GrRenderTargetOpList_DEFINED
#
define
GrRenderTargetOpList_DEFINED
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
ops
/
GrOp
.
h
"
#
include
"
ops
/
GrDrawOp
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkStringUtils
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkTypes
.
h
"
class
GrAuditTrail
;
class
GrClearOp
;
class
GrCaps
;
class
GrRenderTargetProxy
;
class
GrRenderTargetOpList
final
:
public
GrOpList
{
private
:
using
DstProxy
=
GrXferProcessor
:
:
DstProxy
;
public
:
GrRenderTargetOpList
(
GrResourceProvider
*
sk_sp
<
GrOpMemoryPool
>
GrRenderTargetProxy
*
GrAuditTrail
*
)
;
~
GrRenderTargetOpList
(
)
override
;
void
makeClosed
(
const
GrCaps
&
caps
)
override
{
if
(
this
-
>
isClosed
(
)
)
{
return
;
}
this
-
>
forwardCombine
(
caps
)
;
INHERITED
:
:
makeClosed
(
caps
)
;
}
bool
isEmpty
(
)
const
{
return
fOpChains
.
empty
(
)
;
}
void
endFlush
(
)
override
;
void
onPrepare
(
GrOpFlushState
*
flushState
)
override
;
bool
onExecute
(
GrOpFlushState
*
flushState
)
override
;
void
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
&
caps
this
]
(
GrSurfaceProxy
*
p
)
{
this
-
>
addDependency
(
p
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
this
-
>
recordOp
(
std
:
:
move
(
op
)
GrProcessorSet
:
:
EmptySetAnalysis
(
)
nullptr
nullptr
caps
)
;
}
void
addWaitOp
(
std
:
:
unique_ptr
<
GrOp
>
op
const
GrCaps
&
caps
)
{
fHasWaitOp
=
true
;
this
-
>
addOp
(
std
:
:
move
(
op
)
caps
)
;
}
void
addDrawOp
(
std
:
:
unique_ptr
<
GrDrawOp
>
op
const
GrProcessorSet
:
:
Analysis
&
processorAnalysis
GrAppliedClip
&
&
clip
const
DstProxy
&
dstProxy
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
&
caps
this
]
(
GrSurfaceProxy
*
p
)
{
this
-
>
addDependency
(
p
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
clip
.
visitProxies
(
addDependency
)
;
if
(
dstProxy
.
proxy
(
)
)
{
addDependency
(
dstProxy
.
proxy
(
)
)
;
}
this
-
>
recordOp
(
std
:
:
move
(
op
)
processorAnalysis
clip
.
doesClip
(
)
?
&
clip
:
nullptr
&
dstProxy
caps
)
;
}
void
discard
(
)
;
bool
copySurface
(
GrRecordingContext
*
GrSurfaceProxy
*
dst
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
override
;
GrRenderTargetOpList
*
asRenderTargetOpList
(
)
override
{
return
this
;
}
SkDEBUGCODE
(
void
dump
(
bool
printDependencies
)
const
override
;
)
SkDEBUGCODE
(
int
numClips
(
)
const
override
{
return
fNumClips
;
}
)
SkDEBUGCODE
(
void
visitProxies_debugOnly
(
const
GrOp
:
:
VisitProxyFunc
&
)
const
;
)
private
:
friend
class
GrRenderTargetContextPriv
;
friend
class
GrRenderTargetContext
;
void
setStencilLoadOp
(
GrLoadOp
op
)
;
void
setColorLoadOp
(
GrLoadOp
op
const
SkPMColor4f
&
color
)
;
void
setColorLoadOp
(
GrLoadOp
op
)
{
static
const
SkPMColor4f
kDefaultClearColor
=
{
0
.
f
0
.
f
0
.
f
0
.
f
}
;
this
-
>
setColorLoadOp
(
op
kDefaultClearColor
)
;
}
bool
resetForFullscreenClear
(
)
;
void
deleteOps
(
)
;
class
OpChain
{
public
:
OpChain
(
const
OpChain
&
)
=
delete
;
OpChain
&
operator
=
(
const
OpChain
&
)
=
delete
;
OpChain
(
std
:
:
unique_ptr
<
GrOp
>
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
DstProxy
*
)
;
~
OpChain
(
)
{
SkASSERT
(
fList
.
empty
(
)
)
;
}
void
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
GrOp
:
:
VisitorType
)
const
;
GrOp
*
head
(
)
const
{
return
fList
.
head
(
)
;
}
GrAppliedClip
*
appliedClip
(
)
const
{
return
fAppliedClip
;
}
const
DstProxy
&
dstProxy
(
)
const
{
return
fDstProxy
;
}
const
SkRect
&
bounds
(
)
const
{
return
fBounds
;
}
void
deleteOps
(
GrOpMemoryPool
*
pool
)
;
bool
prependChain
(
OpChain
*
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
std
:
:
unique_ptr
<
GrOp
>
appendOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrProcessorSet
:
:
Analysis
const
DstProxy
*
const
GrAppliedClip
*
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
private
:
class
List
{
public
:
List
(
)
=
default
;
List
(
std
:
:
unique_ptr
<
GrOp
>
)
;
List
(
List
&
&
)
;
List
&
operator
=
(
List
&
&
that
)
;
bool
empty
(
)
const
{
return
!
SkToBool
(
fHead
)
;
}
GrOp
*
head
(
)
const
{
return
fHead
.
get
(
)
;
}
GrOp
*
tail
(
)
const
{
return
fTail
;
}
std
:
:
unique_ptr
<
GrOp
>
popHead
(
)
;
std
:
:
unique_ptr
<
GrOp
>
removeOp
(
GrOp
*
op
)
;
void
pushHead
(
std
:
:
unique_ptr
<
GrOp
>
op
)
;
void
pushTail
(
std
:
:
unique_ptr
<
GrOp
>
)
;
void
validate
(
)
const
;
private
:
std
:
:
unique_ptr
<
GrOp
>
fHead
;
GrOp
*
fTail
=
nullptr
;
}
;
void
validate
(
)
const
;
bool
tryConcat
(
List
*
GrProcessorSet
:
:
Analysis
const
DstProxy
&
const
GrAppliedClip
*
const
SkRect
&
bounds
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
static
List
DoConcat
(
List
List
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
List
fList
;
GrProcessorSet
:
:
Analysis
fProcessorAnalysis
;
DstProxy
fDstProxy
;
GrAppliedClip
*
fAppliedClip
;
SkRect
fBounds
;
}
;
void
purgeOpsWithUninstantiatedProxies
(
)
override
;
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
override
;
void
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
DstProxy
*
const
GrCaps
&
caps
)
;
void
forwardCombine
(
const
GrCaps
&
)
;
uint32_t
fLastClipStackGenID
;
SkIRect
fLastDevClipBounds
;
int
fLastClipNumAnalyticFPs
;
bool
fHasWaitOp
=
false
;
;
SkSTArray
<
25
OpChain
true
>
fOpChains
;
SkArenaAlloc
fClipAllocator
{
4096
}
;
SkDEBUGCODE
(
int
fNumClips
;
)
typedef
GrOpList
INHERITED
;
}
;
#
endif
