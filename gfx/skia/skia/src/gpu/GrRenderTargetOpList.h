#
ifndef
GrRenderTargetOpList_DEFINED
#
define
GrRenderTargetOpList_DEFINED
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkStringUtils
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkTypes
.
h
"
class
GrAuditTrail
;
class
GrClearOp
;
class
GrCaps
;
class
GrOp
;
class
GrPipelineBuilder
;
class
GrRenderTargetProxy
;
class
GrRenderTargetOpList
final
:
public
GrOpList
{
private
:
using
DstTexture
=
GrXferProcessor
:
:
DstTexture
;
public
:
struct
Options
{
int
fMaxOpCombineLookback
=
-
1
;
int
fMaxOpCombineLookahead
=
-
1
;
}
;
GrRenderTargetOpList
(
GrRenderTargetProxy
*
GrGpu
*
GrResourceProvider
*
GrAuditTrail
*
const
Options
&
)
;
~
GrRenderTargetOpList
(
)
override
;
void
makeClosed
(
)
override
{
INHERITED
:
:
makeClosed
(
)
;
fLastFullClearOp
=
nullptr
;
this
-
>
forwardCombine
(
)
;
}
void
reset
(
)
override
;
void
abandonGpuResources
(
)
override
;
void
freeGpuResources
(
)
override
;
void
prepareOps
(
GrOpFlushState
*
flushState
)
override
;
bool
executeOps
(
GrOpFlushState
*
flushState
)
override
;
const
GrCaps
*
caps
(
)
const
{
return
fGpu
-
>
caps
(
)
;
}
uint32_t
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrRenderTargetContext
*
renderTargetContext
)
{
this
-
>
recordOp
(
std
:
:
move
(
op
)
renderTargetContext
nullptr
nullptr
)
;
return
this
-
>
uniqueID
(
)
;
}
uint32_t
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrRenderTargetContext
*
renderTargetContext
GrAppliedClip
&
&
clip
const
DstTexture
&
dstTexture
)
{
this
-
>
recordOp
(
std
:
:
move
(
op
)
renderTargetContext
clip
.
doesClip
(
)
?
&
clip
:
nullptr
&
dstTexture
)
;
return
this
-
>
uniqueID
(
)
;
}
void
fullClear
(
GrRenderTargetContext
*
GrColor
color
)
;
void
discard
(
GrRenderTargetContext
*
)
;
bool
copySurface
(
GrResourceProvider
*
resourceProvider
GrSurfaceProxy
*
dst
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
gr_instanced
:
:
InstancedRendering
*
instancedRendering
(
)
const
{
SkASSERT
(
fInstancedRendering
)
;
return
fInstancedRendering
.
get
(
)
;
}
GrRenderTargetOpList
*
asRenderTargetOpList
(
)
override
{
return
this
;
}
SkDEBUGCODE
(
void
dump
(
)
const
override
;
)
SkDEBUGCODE
(
void
validateTargetsSingleRenderTarget
(
)
const
;
)
private
:
friend
class
GrRenderTargetContextPriv
;
struct
RecordedOp
{
RecordedOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrRenderTarget
*
rt
const
GrAppliedClip
*
appliedClip
const
DstTexture
*
dstTexture
)
:
fOp
(
std
:
:
move
(
op
)
)
fRenderTarget
(
rt
)
fAppliedClip
(
appliedClip
)
{
if
(
dstTexture
)
{
fDstTexture
=
*
dstTexture
;
}
}
std
:
:
unique_ptr
<
GrOp
>
fOp
;
GrPendingIOResource
<
GrRenderTarget
kWrite_GrIOType
>
fRenderTarget
;
DstTexture
fDstTexture
;
const
GrAppliedClip
*
fAppliedClip
;
}
;
GrOp
*
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
GrRenderTargetContext
*
GrAppliedClip
*
=
nullptr
const
DstTexture
*
=
nullptr
)
;
void
forwardCombine
(
)
;
bool
combineIfPossible
(
const
RecordedOp
&
a
GrOp
*
b
const
GrAppliedClip
*
bClip
const
DstTexture
*
bDstTexture
)
;
GrClearOp
*
fLastFullClearOp
=
nullptr
;
GrGpuResource
:
:
UniqueID
fLastFullClearResourceID
=
GrGpuResource
:
:
UniqueID
:
:
InvalidID
(
)
;
GrSurfaceProxy
:
:
UniqueID
fLastFullClearProxyID
=
GrSurfaceProxy
:
:
UniqueID
:
:
InvalidID
(
)
;
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
int
fMaxOpLookback
;
int
fMaxOpLookahead
;
std
:
:
unique_ptr
<
gr_instanced
:
:
InstancedRendering
>
fInstancedRendering
;
int32_t
fLastClipStackGenID
;
SkIRect
fLastDevClipBounds
;
SkSTArray
<
256
RecordedOp
true
>
fRecordedOps
;
char
fClipAllocatorStorage
[
4096
]
;
SkArenaAlloc
fClipAllocator
;
typedef
GrOpList
INHERITED
;
}
;
#
endif
