#
ifndef
GrPaint_DEFINED
#
define
GrPaint_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
SkBlendMode
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkRegion
.
h
"
#
include
"
SkTLazy
.
h
"
class
GrTextureProxy
;
class
GrXPFactory
;
class
GrPaint
{
public
:
GrPaint
(
)
=
default
;
explicit
GrPaint
(
const
GrPaint
&
)
=
default
;
~
GrPaint
(
)
=
default
;
void
setColor4f
(
const
GrColor4f
&
color
)
{
fColor
=
color
;
}
const
GrColor4f
&
getColor4f
(
)
const
{
return
fColor
;
}
GrColor
getColor
(
)
const
{
return
fColor
.
toGrColor
(
)
;
}
void
setDisableOutputConversionToSRGB
(
bool
srgb
)
{
fDisableOutputConversionToSRGB
=
srgb
;
}
bool
getDisableOutputConversionToSRGB
(
)
const
{
return
fDisableOutputConversionToSRGB
;
}
void
setAllowSRGBInputs
(
bool
allowSRGBInputs
)
{
fAllowSRGBInputs
=
allowSRGBInputs
;
}
bool
getAllowSRGBInputs
(
)
const
{
return
fAllowSRGBInputs
;
}
bool
usesDistanceVectorField
(
)
const
{
return
fUsesDistanceVectorField
;
}
void
setGammaCorrect
(
bool
gammaCorrect
)
{
setDisableOutputConversionToSRGB
(
!
gammaCorrect
)
;
setAllowSRGBInputs
(
gammaCorrect
)
;
}
void
setXPFactory
(
const
GrXPFactory
*
xpFactory
)
{
fXPFactory
=
xpFactory
;
}
void
setPorterDuffXPFactory
(
SkBlendMode
mode
)
;
void
setCoverageSetOpXPFactory
(
SkRegion
:
:
Op
bool
invertCoverage
=
false
)
;
void
addColorFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
fp
)
{
SkASSERT
(
fp
)
;
fUsesDistanceVectorField
|
=
fp
-
>
usesDistanceVectorField
(
)
;
fColorFragmentProcessors
.
push_back
(
std
:
:
move
(
fp
)
)
;
}
void
addCoverageFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
fp
)
{
SkASSERT
(
fp
)
;
fUsesDistanceVectorField
|
=
fp
-
>
usesDistanceVectorField
(
)
;
fCoverageFragmentProcessors
.
push_back
(
std
:
:
move
(
fp
)
)
;
}
void
addColorTextureProcessor
(
GrResourceProvider
*
sk_sp
<
GrTextureProxy
>
sk_sp
<
GrColorSpaceXform
>
const
SkMatrix
&
)
;
void
addColorTextureProcessor
(
GrResourceProvider
*
sk_sp
<
GrTextureProxy
>
sk_sp
<
GrColorSpaceXform
>
const
SkMatrix
&
const
GrSamplerParams
&
)
;
void
addCoverageTextureProcessor
(
GrResourceProvider
*
sk_sp
<
GrTextureProxy
>
const
SkMatrix
&
)
;
void
addCoverageTextureProcessor
(
GrResourceProvider
*
sk_sp
<
GrTextureProxy
>
const
SkMatrix
&
const
GrSamplerParams
&
)
;
int
numColorFragmentProcessors
(
)
const
{
return
fColorFragmentProcessors
.
count
(
)
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fCoverageFragmentProcessors
.
count
(
)
;
}
int
numTotalFragmentProcessors
(
)
const
{
return
this
-
>
numColorFragmentProcessors
(
)
+
this
-
>
numCoverageFragmentProcessors
(
)
;
}
const
GrXPFactory
*
getXPFactory
(
)
const
{
return
fXPFactory
;
}
GrFragmentProcessor
*
getColorFragmentProcessor
(
int
i
)
const
{
return
fColorFragmentProcessors
[
i
]
.
get
(
)
;
}
GrFragmentProcessor
*
getCoverageFragmentProcessor
(
int
i
)
const
{
return
fCoverageFragmentProcessors
[
i
]
.
get
(
)
;
}
bool
isConstantBlendedColor
(
GrColor
*
constantColor
)
const
;
private
:
template
<
bool
>
class
MoveOrImpl
;
public
:
using
MoveOrClone
=
MoveOrImpl
<
true
>
;
using
MoveOrNew
=
MoveOrImpl
<
false
>
;
private
:
GrPaint
&
operator
=
(
const
GrPaint
&
)
=
delete
;
friend
class
GrProcessorSet
;
const
GrXPFactory
*
fXPFactory
=
nullptr
;
SkSTArray
<
4
sk_sp
<
GrFragmentProcessor
>
>
fColorFragmentProcessors
;
SkSTArray
<
2
sk_sp
<
GrFragmentProcessor
>
>
fCoverageFragmentProcessors
;
bool
fDisableOutputConversionToSRGB
=
false
;
bool
fAllowSRGBInputs
=
false
;
bool
fUsesDistanceVectorField
=
false
;
GrColor4f
fColor
=
GrColor4f
:
:
OpaqueWhite
(
)
;
}
;
template
<
bool
COPY_IF_NEW
>
class
GrPaint
:
:
MoveOrImpl
{
public
:
MoveOrImpl
(
GrPaint
&
paint
bool
newPaint
)
{
if
(
newPaint
)
{
if
(
COPY_IF_NEW
)
{
fStorage
.
init
(
paint
)
;
}
else
{
fStorage
.
init
(
)
;
}
;
fPaint
=
fStorage
.
get
(
)
;
}
else
{
fPaint
=
&
paint
;
}
}
operator
GrPaint
&
&
(
)
&
&
{
return
std
:
:
move
(
*
fPaint
)
;
}
GrPaint
&
paint
(
)
{
return
*
fPaint
;
}
private
:
SkTLazy
<
GrPaint
>
fStorage
;
GrPaint
*
fPaint
;
}
;
#
endif
