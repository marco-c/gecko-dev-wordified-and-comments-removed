#
ifndef
GrGLSLProgramBuilder_DEFINED
#
define
GrGLSLProgramBuilder_DEFINED
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLGeometryShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLPrimitiveProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
glsl
/
GrGLSLTextureSampler
.
h
"
#
include
"
glsl
/
GrGLSLVertexShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLXferProcessor
.
h
"
class
GrGLSLCaps
;
class
GrGLSLShaderVar
;
class
GrGLSLVaryingHandler
;
typedef
SkSTArray
<
8
GrGLSLFragmentProcessor
*
true
>
GrGLSLFragProcs
;
class
GrGLSLProgramBuilder
{
public
:
typedef
GrGpu
:
:
DrawArgs
DrawArgs
;
typedef
GrGLSLUniformHandler
:
:
ShaderVisibility
ShaderVisibility
;
typedef
GrGLSLUniformHandler
:
:
UniformHandle
UniformHandle
;
virtual
~
GrGLSLProgramBuilder
(
)
{
}
virtual
const
GrCaps
*
caps
(
)
const
=
0
;
virtual
const
GrGLSLCaps
*
glslCaps
(
)
const
=
0
;
const
GrPrimitiveProcessor
&
primitiveProcessor
(
)
const
{
return
*
fArgs
.
fPrimitiveProcessor
;
}
const
GrPipeline
&
pipeline
(
)
const
{
return
*
fArgs
.
fPipeline
;
}
const
GrProgramDesc
&
desc
(
)
const
{
return
*
fArgs
.
fDesc
;
}
const
GrProgramDesc
:
:
KeyHeader
&
header
(
)
const
{
return
fArgs
.
fDesc
-
>
header
(
)
;
}
void
appendUniformDecls
(
ShaderVisibility
SkString
*
)
const
;
struct
BuiltinUniformHandles
{
UniformHandle
fRTAdjustmentUni
;
UniformHandle
fRTHeightUni
;
}
;
void
addRTAdjustmentUniform
(
GrSLPrecision
precision
const
char
*
name
const
char
*
*
outName
)
;
const
char
*
rtAdjustment
(
)
const
{
return
"
rtAdjustment
"
;
}
void
addRTHeightUniform
(
const
char
*
name
const
char
*
*
outName
)
;
void
nameVariable
(
SkString
*
out
char
prefix
const
char
*
name
bool
mangle
=
true
)
;
virtual
GrGLSLUniformHandler
*
uniformHandler
(
)
=
0
;
virtual
const
GrGLSLUniformHandler
*
uniformHandler
(
)
const
=
0
;
virtual
GrGLSLVaryingHandler
*
varyingHandler
(
)
=
0
;
static
const
int
kVarsPerBlock
;
GrGLSLVertexBuilder
fVS
;
GrGLSLGeometryBuilder
fGS
;
GrGLSLFragmentShaderBuilder
fFS
;
int
fStageIndex
;
const
DrawArgs
&
fArgs
;
BuiltinUniformHandles
fUniformHandles
;
GrGLSLPrimitiveProcessor
*
fGeometryProcessor
;
GrGLSLXferProcessor
*
fXferProcessor
;
GrGLSLFragProcs
fFragmentProcessors
;
protected
:
explicit
GrGLSLProgramBuilder
(
const
DrawArgs
&
args
)
;
bool
emitAndInstallProcs
(
GrGLSLExpr4
*
inputColor
GrGLSLExpr4
*
inputCoverage
int
maxTextures
)
;
void
cleanupFragmentProcessors
(
)
;
private
:
void
reset
(
)
{
this
-
>
addStage
(
)
;
fFS
.
reset
(
)
;
}
void
addStage
(
)
{
fStageIndex
+
+
;
}
class
AutoStageAdvance
{
public
:
AutoStageAdvance
(
GrGLSLProgramBuilder
*
pb
)
:
fPB
(
pb
)
{
fPB
-
>
reset
(
)
;
fPB
-
>
fFS
.
nextStage
(
)
;
}
~
AutoStageAdvance
(
)
{
}
private
:
GrGLSLProgramBuilder
*
fPB
;
}
;
void
nameExpression
(
GrGLSLExpr4
*
const
char
*
baseName
)
;
void
emitAndInstallPrimProc
(
const
GrPrimitiveProcessor
&
GrGLSLExpr4
*
outputColor
GrGLSLExpr4
*
outputCoverage
)
;
void
emitAndInstallFragProcs
(
int
procOffset
int
numProcs
GrGLSLExpr4
*
inOut
)
;
void
emitAndInstallFragProc
(
const
GrFragmentProcessor
&
int
index
const
GrGLSLExpr4
&
input
GrGLSLExpr4
*
output
)
;
void
emitAndInstallXferProc
(
const
GrXferProcessor
&
const
GrGLSLExpr4
&
colorIn
const
GrGLSLExpr4
&
coverageIn
bool
ignoresCoverage
)
;
void
emitFSOutputSwizzle
(
bool
hasSecondaryOutput
)
;
void
verify
(
const
GrPrimitiveProcessor
&
)
;
void
verify
(
const
GrXferProcessor
&
)
;
void
verify
(
const
GrFragmentProcessor
&
)
;
virtual
void
emitSamplers
(
const
GrProcessor
&
processor
GrGLSLTextureSampler
:
:
TextureSamplerArray
*
outSamplers
)
=
0
;
GrGLSLPrimitiveProcessor
:
:
TransformsIn
fCoordTransforms
;
GrGLSLPrimitiveProcessor
:
:
TransformsOut
fOutCoords
;
}
;
#
endif
