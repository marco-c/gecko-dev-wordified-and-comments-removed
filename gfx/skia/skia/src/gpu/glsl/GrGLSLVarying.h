#
ifndef
GrGLSLVarying_DEFINED
#
define
GrGLSLVarying_DEFINED
#
include
"
include
/
private
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
GrAllocator
.
h
"
#
include
"
src
/
gpu
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
GrShaderVar
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrGLSLProgramBuilder
;
#
ifdef
SK_DEBUG
static
bool
is_matrix
(
GrSLType
type
)
{
switch
(
type
)
{
case
kFloat2x2_GrSLType
:
case
kFloat3x3_GrSLType
:
case
kFloat4x4_GrSLType
:
case
kHalf2x2_GrSLType
:
case
kHalf3x3_GrSLType
:
case
kHalf4x4_GrSLType
:
return
true
;
default
:
return
false
;
}
}
#
endif
class
GrGLSLVarying
{
public
:
enum
class
Scope
{
kVertToFrag
kVertToGeo
kGeoToFrag
}
;
GrGLSLVarying
(
)
=
default
;
GrGLSLVarying
(
GrSLType
type
Scope
scope
=
Scope
:
:
kVertToFrag
)
:
fType
(
type
)
fScope
(
scope
)
{
SkASSERT
(
!
is_matrix
(
type
)
)
;
}
void
reset
(
GrSLType
type
Scope
scope
=
Scope
:
:
kVertToFrag
)
{
SkASSERT
(
!
is_matrix
(
type
)
)
;
*
this
=
GrGLSLVarying
(
)
;
fType
=
type
;
fScope
=
scope
;
}
GrSLType
type
(
)
const
{
return
fType
;
}
Scope
scope
(
)
const
{
return
fScope
;
}
bool
isInVertexShader
(
)
const
{
return
Scope
:
:
kGeoToFrag
!
=
fScope
;
}
bool
isInFragmentShader
(
)
const
{
return
Scope
:
:
kVertToGeo
!
=
fScope
;
}
const
char
*
vsOut
(
)
const
{
SkASSERT
(
this
-
>
isInVertexShader
(
)
)
;
return
fVsOut
;
}
const
char
*
gsIn
(
)
const
{
return
fGsIn
;
}
const
char
*
gsOut
(
)
const
{
return
fGsOut
;
}
const
char
*
fsIn
(
)
const
{
SkASSERT
(
this
-
>
isInFragmentShader
(
)
)
;
return
fFsIn
;
}
private
:
GrSLType
fType
=
kVoid_GrSLType
;
Scope
fScope
=
Scope
:
:
kVertToFrag
;
const
char
*
fVsOut
=
nullptr
;
const
char
*
fGsIn
=
nullptr
;
const
char
*
fGsOut
=
nullptr
;
const
char
*
fFsIn
=
nullptr
;
friend
class
GrGLSLVaryingHandler
;
}
;
static
const
int
kVaryingsPerBlock
=
8
;
class
GrGLSLVaryingHandler
{
public
:
explicit
GrGLSLVaryingHandler
(
GrGLSLProgramBuilder
*
program
)
:
fVaryings
(
kVaryingsPerBlock
)
fVertexInputs
(
kVaryingsPerBlock
)
fVertexOutputs
(
kVaryingsPerBlock
)
fGeomInputs
(
kVaryingsPerBlock
)
fGeomOutputs
(
kVaryingsPerBlock
)
fFragInputs
(
kVaryingsPerBlock
)
fFragOutputs
(
kVaryingsPerBlock
)
fProgramBuilder
(
program
)
fDefaultInterpolationModifier
(
nullptr
)
{
}
virtual
~
GrGLSLVaryingHandler
(
)
{
}
void
setNoPerspective
(
)
;
enum
class
Interpolation
{
kInterpolated
kCanBeFlat
kMustBeFlat
}
;
void
addVarying
(
const
char
*
name
GrGLSLVarying
*
varying
Interpolation
=
Interpolation
:
:
kInterpolated
)
;
void
addPassThroughAttribute
(
const
GrGeometryProcessor
:
:
Attribute
&
const
char
*
output
Interpolation
=
Interpolation
:
:
kInterpolated
)
;
void
emitAttributes
(
const
GrGeometryProcessor
&
gp
)
;
void
finalize
(
)
;
void
getVertexDecls
(
SkString
*
inputDecls
SkString
*
outputDecls
)
const
;
void
getGeomDecls
(
SkString
*
inputDecls
SkString
*
outputDecls
)
const
;
void
getFragDecls
(
SkString
*
inputDecls
SkString
*
outputDecls
)
const
;
protected
:
struct
VaryingInfo
{
GrSLType
fType
;
bool
fIsFlat
;
SkString
fVsOut
;
SkString
fGsOut
;
GrShaderFlags
fVisibility
;
}
;
typedef
GrTAllocator
<
VaryingInfo
>
VaryingList
;
typedef
GrTAllocator
<
GrShaderVar
>
VarArray
;
typedef
GrGLSLProgramDataManager
:
:
VaryingHandle
VaryingHandle
;
VaryingList
fVaryings
;
VarArray
fVertexInputs
;
VarArray
fVertexOutputs
;
VarArray
fGeomInputs
;
VarArray
fGeomOutputs
;
VarArray
fFragInputs
;
VarArray
fFragOutputs
;
GrGLSLProgramBuilder
*
fProgramBuilder
;
private
:
void
addAttribute
(
const
GrShaderVar
&
var
)
;
virtual
void
onFinalize
(
)
=
0
;
void
appendDecls
(
const
VarArray
&
vars
SkString
*
out
)
const
;
const
char
*
fDefaultInterpolationModifier
;
friend
class
GrGLSLProgramBuilder
;
}
;
#
endif
