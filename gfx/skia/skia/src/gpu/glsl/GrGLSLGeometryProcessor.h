#
ifndef
GrGLSLGeometryProcessor_DEFINED
#
define
GrGLSLGeometryProcessor_DEFINED
#
include
"
GrGLSLPrimitiveProcessor
.
h
"
class
GrGLSLGPBuilder
;
class
GrGLSLGeometryProcessor
:
public
GrGLSLPrimitiveProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
void
setTransformData
(
const
GrPrimitiveProcessor
&
const
GrGLSLProgramDataManager
&
pdman
int
index
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
transforms
)
override
{
this
-
>
setTransformDataMatrix
(
SkMatrix
:
:
I
(
)
pdman
index
transforms
)
;
}
template
<
class
GeometryProcessor
>
void
setTransformDataHelper
(
const
GrPrimitiveProcessor
&
primProc
const
GrGLSLProgramDataManager
&
pdman
int
index
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
transforms
)
{
const
GeometryProcessor
&
gp
=
primProc
.
cast
<
GeometryProcessor
>
(
)
;
this
-
>
setTransformDataMatrix
(
gp
.
localMatrix
(
)
pdman
index
transforms
)
;
}
protected
:
void
emitTransforms
(
GrGLSLVertexBuilder
*
vb
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderVar
&
posVar
const
char
*
localCoords
const
TransformsIn
&
tin
TransformsOut
*
tout
)
{
this
-
>
emitTransforms
(
vb
varyingHandler
uniformHandler
posVar
localCoords
SkMatrix
:
:
I
(
)
tin
tout
)
;
}
void
emitTransforms
(
GrGLSLVertexBuilder
*
GrGLSLVaryingHandler
*
GrGLSLUniformHandler
*
const
GrShaderVar
&
posVar
const
char
*
localCoords
const
SkMatrix
&
localMatrix
const
TransformsIn
&
TransformsOut
*
)
;
void
emitTransforms
(
GrGLSLVertexBuilder
*
GrGLSLVaryingHandler
*
const
char
*
localCoords
const
TransformsIn
&
tin
TransformsOut
*
tout
)
;
struct
GrGPArgs
{
GrShaderVar
fPositionVar
;
}
;
void
setupPosition
(
GrGLSLVertexBuilder
*
GrGPArgs
*
const
char
*
posName
)
;
void
setupPosition
(
GrGLSLVertexBuilder
*
GrGLSLUniformHandler
*
uniformHandler
GrGPArgs
*
const
char
*
posName
const
SkMatrix
&
mat
UniformHandle
*
viewMatrixUniform
)
;
static
uint32_t
ComputePosKey
(
const
SkMatrix
&
mat
)
{
if
(
mat
.
isIdentity
(
)
)
{
return
0x0
;
}
else
if
(
!
mat
.
hasPerspective
(
)
)
{
return
0x01
;
}
else
{
return
0x02
;
}
}
private
:
void
setTransformDataMatrix
(
const
SkMatrix
&
localMatrix
const
GrGLSLProgramDataManager
&
pdman
int
index
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
transforms
)
{
SkSTArray
<
2
Transform
true
>
&
procTransforms
=
fInstalledTransforms
[
index
]
;
int
numTransforms
=
transforms
.
count
(
)
;
for
(
int
t
=
0
;
t
<
numTransforms
;
+
+
t
)
{
SkASSERT
(
procTransforms
[
t
]
.
fHandle
.
isValid
(
)
)
;
const
SkMatrix
&
transform
=
GetTransformMatrix
(
localMatrix
*
transforms
[
t
]
)
;
if
(
!
procTransforms
[
t
]
.
fCurrentValue
.
cheapEqualTo
(
transform
)
)
{
pdman
.
setSkMatrix
(
procTransforms
[
t
]
.
fHandle
.
toIndex
(
)
transform
)
;
procTransforms
[
t
]
.
fCurrentValue
=
transform
;
}
}
}
virtual
void
onEmitCode
(
EmitArgs
&
GrGPArgs
*
)
=
0
;
typedef
GrGLSLPrimitiveProcessor
INHERITED
;
}
;
#
endif
