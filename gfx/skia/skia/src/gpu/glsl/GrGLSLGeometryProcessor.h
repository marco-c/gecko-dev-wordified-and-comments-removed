#
ifndef
GrGLSLGeometryProcessor_DEFINED
#
define
GrGLSLGeometryProcessor_DEFINED
#
include
"
GrGLSLPrimitiveProcessor
.
h
"
class
GrGLSLGPBuilder
;
class
GrGLSLGeometryProcessor
:
public
GrGLSLPrimitiveProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
protected
:
void
setTransformDataHelper
(
const
SkMatrix
&
localMatrix
const
GrGLSLProgramDataManager
&
pdman
FPCoordTransformIter
*
)
;
void
emitTransforms
(
GrGLSLVertexBuilder
*
vb
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderVar
&
posVar
const
char
*
localCoords
FPCoordTransformHandler
*
handler
)
{
this
-
>
emitTransforms
(
vb
varyingHandler
uniformHandler
posVar
localCoords
SkMatrix
:
:
I
(
)
handler
)
;
}
void
emitTransforms
(
GrGLSLVertexBuilder
*
GrGLSLVaryingHandler
*
GrGLSLUniformHandler
*
const
GrShaderVar
&
posVar
const
char
*
localCoords
const
SkMatrix
&
localMatrix
FPCoordTransformHandler
*
)
;
struct
GrGPArgs
{
GrShaderVar
fPositionVar
;
}
;
void
setupPosition
(
GrGLSLVertexBuilder
*
GrGPArgs
*
const
char
*
posName
)
;
void
setupPosition
(
GrGLSLVertexBuilder
*
GrGLSLUniformHandler
*
uniformHandler
GrGPArgs
*
const
char
*
posName
const
SkMatrix
&
mat
UniformHandle
*
viewMatrixUniform
)
;
static
uint32_t
ComputePosKey
(
const
SkMatrix
&
mat
)
{
if
(
mat
.
isIdentity
(
)
)
{
return
0x0
;
}
else
if
(
!
mat
.
hasPerspective
(
)
)
{
return
0x01
;
}
else
{
return
0x02
;
}
}
private
:
virtual
void
onEmitCode
(
EmitArgs
&
GrGPArgs
*
)
=
0
;
struct
TransformUniform
{
UniformHandle
fHandle
;
SkMatrix
fCurrentValue
=
SkMatrix
:
:
InvalidMatrix
(
)
;
}
;
SkTArray
<
TransformUniform
true
>
fInstalledTransforms
;
typedef
GrGLSLPrimitiveProcessor
INHERITED
;
}
;
#
endif
