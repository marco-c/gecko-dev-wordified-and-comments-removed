#
include
"
glsl
/
GrGLSLShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLCaps
.
h
"
#
include
"
glsl
/
GrGLSLShaderVar
.
h
"
#
include
"
glsl
/
GrGLSLTextureSampler
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
static
void
map_swizzle
(
const
char
*
swizzleMap
const
char
*
swizzle
char
*
mangledSwizzle
)
{
int
i
;
for
(
i
=
0
;
'
\
0
'
!
=
swizzle
[
i
]
;
+
+
i
)
{
switch
(
swizzle
[
i
]
)
{
case
'
r
'
:
mangledSwizzle
[
i
]
=
swizzleMap
[
0
]
;
break
;
case
'
g
'
:
mangledSwizzle
[
i
]
=
swizzleMap
[
1
]
;
break
;
case
'
b
'
:
mangledSwizzle
[
i
]
=
swizzleMap
[
2
]
;
break
;
case
'
a
'
:
mangledSwizzle
[
i
]
=
swizzleMap
[
3
]
;
break
;
default
:
SkFAIL
(
"
Unsupported
swizzle
"
)
;
}
}
mangledSwizzle
[
i
]
=
'
\
0
'
;
}
static
void
append_texture_lookup
(
SkString
*
out
const
GrGLSLCaps
*
glslCaps
const
char
*
samplerName
const
char
*
coordName
GrPixelConfig
config
const
char
*
swizzle
GrSLType
varyingType
=
kVec2f_GrSLType
)
{
SkASSERT
(
coordName
)
;
out
-
>
appendf
(
"
%
s
(
%
s
%
s
)
"
GrGLSLTexture2DFunctionName
(
varyingType
glslCaps
-
>
generation
(
)
)
samplerName
coordName
)
;
char
mangledSwizzle
[
5
]
;
if
(
glslCaps
-
>
mustSwizzleInShader
(
)
)
{
const
char
*
swizzleMap
=
glslCaps
-
>
getSwizzleMap
(
config
)
;
if
(
memcmp
(
swizzleMap
"
rgba
"
4
)
)
{
map_swizzle
(
swizzleMap
swizzle
mangledSwizzle
)
;
swizzle
=
mangledSwizzle
;
}
}
if
(
memcmp
(
swizzle
"
rgba
"
4
)
)
{
out
-
>
appendf
(
"
.
%
s
"
swizzle
)
;
}
}
GrGLSLShaderBuilder
:
:
GrGLSLShaderBuilder
(
GrGLSLProgramBuilder
*
program
)
:
fProgramBuilder
(
program
)
fInputs
(
GrGLSLProgramBuilder
:
:
kVarsPerBlock
)
fOutputs
(
GrGLSLProgramBuilder
:
:
kVarsPerBlock
)
fFeaturesAddedMask
(
0
)
fCodeIndex
(
kCode
)
fFinalized
(
false
)
{
for
(
int
i
=
0
;
i
<
=
kCode
;
i
+
+
)
{
fShaderStrings
.
push_back
(
)
;
fCompilerStrings
.
push_back
(
nullptr
)
;
fCompilerStringLengths
.
push_back
(
0
)
;
}
this
-
>
main
(
)
=
"
void
main
(
)
{
"
;
}
void
GrGLSLShaderBuilder
:
:
declAppend
(
const
GrGLSLShaderVar
&
var
)
{
SkString
tempDecl
;
var
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
&
tempDecl
)
;
this
-
>
codeAppendf
(
"
%
s
;
"
tempDecl
.
c_str
(
)
)
;
}
void
GrGLSLShaderBuilder
:
:
emitFunction
(
GrSLType
returnType
const
char
*
name
int
argCnt
const
GrGLSLShaderVar
*
args
const
char
*
body
SkString
*
outName
)
{
this
-
>
functions
(
)
.
append
(
GrGLSLTypeString
(
returnType
)
)
;
fProgramBuilder
-
>
nameVariable
(
outName
'
\
0
'
name
)
;
this
-
>
functions
(
)
.
appendf
(
"
%
s
"
outName
-
>
c_str
(
)
)
;
this
-
>
functions
(
)
.
append
(
"
(
"
)
;
for
(
int
i
=
0
;
i
<
argCnt
;
+
+
i
)
{
args
[
i
]
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
&
this
-
>
functions
(
)
)
;
if
(
i
<
argCnt
-
1
)
{
this
-
>
functions
(
)
.
append
(
"
"
)
;
}
}
this
-
>
functions
(
)
.
append
(
"
)
{
\
n
"
)
;
this
-
>
functions
(
)
.
append
(
body
)
;
this
-
>
functions
(
)
.
append
(
"
}
\
n
\
n
"
)
;
}
void
GrGLSLShaderBuilder
:
:
appendTextureLookup
(
SkString
*
out
const
GrGLSLTextureSampler
&
sampler
const
char
*
coordName
GrSLType
varyingType
)
const
{
append_texture_lookup
(
out
fProgramBuilder
-
>
glslCaps
(
)
fProgramBuilder
-
>
getUniformCStr
(
sampler
.
fSamplerUniform
)
coordName
sampler
.
config
(
)
sampler
.
swizzle
(
)
varyingType
)
;
}
void
GrGLSLShaderBuilder
:
:
appendTextureLookup
(
const
GrGLSLTextureSampler
&
sampler
const
char
*
coordName
GrSLType
varyingType
)
{
this
-
>
appendTextureLookup
(
&
this
-
>
code
(
)
sampler
coordName
varyingType
)
;
}
void
GrGLSLShaderBuilder
:
:
appendTextureLookupAndModulate
(
const
char
*
modulation
const
GrGLSLTextureSampler
&
sampler
const
char
*
coordName
GrSLType
varyingType
)
{
SkString
lookup
;
this
-
>
appendTextureLookup
(
&
lookup
sampler
coordName
varyingType
)
;
this
-
>
codeAppend
(
(
GrGLSLExpr4
(
modulation
)
*
GrGLSLExpr4
(
lookup
)
)
.
c_str
(
)
)
;
}
void
GrGLSLShaderBuilder
:
:
addFeature
(
uint32_t
featureBit
const
char
*
extensionName
)
{
if
(
!
(
featureBit
&
fFeaturesAddedMask
)
)
{
this
-
>
extensions
(
)
.
appendf
(
"
#
extension
%
s
:
require
\
n
"
extensionName
)
;
fFeaturesAddedMask
|
=
featureBit
;
}
}
void
GrGLSLShaderBuilder
:
:
appendDecls
(
const
VarArray
&
vars
SkString
*
out
)
const
{
for
(
int
i
=
0
;
i
<
vars
.
count
(
)
;
+
+
i
)
{
vars
[
i
]
.
appendDecl
(
fProgramBuilder
-
>
glslCaps
(
)
out
)
;
out
-
>
append
(
"
;
\
n
"
)
;
}
}
void
GrGLSLShaderBuilder
:
:
addLayoutQualifier
(
const
char
*
param
InterfaceQualifier
interface
)
{
SkASSERT
(
fProgramBuilder
-
>
glslCaps
(
)
-
>
generation
(
)
>
=
k330_GrGLSLGeneration
|
|
fProgramBuilder
-
>
glslCaps
(
)
-
>
mustEnableAdvBlendEqs
(
)
)
;
fLayoutParams
[
interface
]
.
push_back
(
)
=
param
;
}
void
GrGLSLShaderBuilder
:
:
compileAndAppendLayoutQualifiers
(
)
{
static
const
char
*
interfaceQualifierNames
[
]
=
{
"
out
"
}
;
for
(
int
interface
=
0
;
interface
<
=
kLastInterfaceQualifier
;
+
+
interface
)
{
const
SkTArray
<
SkString
>
&
params
=
fLayoutParams
[
interface
]
;
if
(
params
.
empty
(
)
)
{
continue
;
}
this
-
>
layoutQualifiers
(
)
.
appendf
(
"
layout
(
%
s
"
params
[
0
]
.
c_str
(
)
)
;
for
(
int
i
=
1
;
i
<
params
.
count
(
)
;
+
+
i
)
{
this
-
>
layoutQualifiers
(
)
.
appendf
(
"
%
s
"
params
[
i
]
.
c_str
(
)
)
;
}
this
-
>
layoutQualifiers
(
)
.
appendf
(
"
)
%
s
;
\
n
"
interfaceQualifierNames
[
interface
]
)
;
}
GR_STATIC_ASSERT
(
0
=
=
GrGLSLShaderBuilder
:
:
kOut_InterfaceQualifier
)
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
interfaceQualifierNames
)
=
=
kLastInterfaceQualifier
+
1
)
;
}
void
GrGLSLShaderBuilder
:
:
finalize
(
uint32_t
visibility
)
{
SkASSERT
(
!
fFinalized
)
;
this
-
>
versionDecl
(
)
=
fProgramBuilder
-
>
glslCaps
(
)
-
>
versionDeclString
(
)
;
this
-
>
compileAndAppendLayoutQualifiers
(
)
;
SkASSERT
(
visibility
)
;
fProgramBuilder
-
>
appendUniformDecls
(
(
GrGLSLProgramBuilder
:
:
ShaderVisibility
)
visibility
&
this
-
>
uniforms
(
)
)
;
this
-
>
appendDecls
(
fInputs
&
this
-
>
inputs
(
)
)
;
this
-
>
appendDecls
(
fOutputs
&
this
-
>
outputs
(
)
)
;
this
-
>
onFinalize
(
)
;
this
-
>
code
(
)
.
append
(
"
}
"
)
;
for
(
int
i
=
0
;
i
<
=
fCodeIndex
;
i
+
+
)
{
fCompilerStrings
[
i
]
=
fShaderStrings
[
i
]
.
c_str
(
)
;
fCompilerStringLengths
[
i
]
=
(
int
)
fShaderStrings
[
i
]
.
size
(
)
;
}
fFinalized
=
true
;
}
