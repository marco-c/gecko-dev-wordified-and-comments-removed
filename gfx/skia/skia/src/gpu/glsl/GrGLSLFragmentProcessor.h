#
ifndef
GrGLSLFragmentProcessor_DEFINED
#
define
GrGLSLFragmentProcessor_DEFINED
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
GrShaderVar
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLPrimitiveProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
src
/
sksl
/
SkSLString
.
h
"
class
GrProcessor
;
class
GrProcessorKeyBuilder
;
class
GrGLSLFPBuilder
;
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLFragmentProcessor
{
public
:
GrGLSLFragmentProcessor
(
)
{
}
virtual
~
GrGLSLFragmentProcessor
(
)
{
for
(
int
i
=
0
;
i
<
fChildProcessors
.
count
(
)
;
+
+
i
)
{
delete
fChildProcessors
[
i
]
;
}
}
using
UniformHandle
=
GrGLSLUniformHandler
:
:
UniformHandle
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
private
:
template
<
typename
T
int
(
GrFragmentProcessor
:
:
*
COUNT
)
(
)
const
>
class
BuilderInputProvider
{
public
:
BuilderInputProvider
(
const
GrFragmentProcessor
*
fp
const
T
*
ts
)
:
fFP
(
fp
)
fTs
(
ts
)
{
}
const
T
&
operator
[
]
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
&
&
i
<
(
fFP
-
>
*
COUNT
)
(
)
)
;
return
fTs
[
i
]
;
}
int
count
(
)
const
{
return
(
fFP
-
>
*
COUNT
)
(
)
;
}
BuilderInputProvider
childInputs
(
int
childIdx
)
const
{
const
GrFragmentProcessor
*
child
=
&
fFP
-
>
childProcessor
(
childIdx
)
;
GrFragmentProcessor
:
:
Iter
iter
(
fFP
)
;
int
numToSkip
=
0
;
while
(
true
)
{
const
GrFragmentProcessor
*
fp
=
iter
.
next
(
)
;
if
(
fp
=
=
child
)
{
return
BuilderInputProvider
(
child
fTs
+
numToSkip
)
;
}
numToSkip
+
=
(
fp
-
>
*
COUNT
)
(
)
;
}
}
private
:
const
GrFragmentProcessor
*
fFP
;
const
T
*
fTs
;
}
;
public
:
using
TransformedCoordVars
=
BuilderInputProvider
<
GrGLSLPrimitiveProcessor
:
:
TransformVar
&
GrFragmentProcessor
:
:
numCoordTransforms
>
;
using
TextureSamplers
=
BuilderInputProvider
<
SamplerHandle
&
GrFragmentProcessor
:
:
numTextureSamplers
>
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrFragmentProcessor
&
fp
const
char
*
outputColor
const
char
*
inputColor
const
TransformedCoordVars
&
transformedCoordVars
const
TextureSamplers
&
textureSamplers
)
:
fFragBuilder
(
fragBuilder
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fFp
(
fp
)
fOutputColor
(
outputColor
)
fInputColor
(
inputColor
?
inputColor
:
"
half4
(
1
.
0
)
"
)
fTransformedCoords
(
transformedCoordVars
)
fTexSamplers
(
textureSamplers
)
{
}
GrGLSLFPFragmentBuilder
*
fFragBuilder
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrFragmentProcessor
&
fFp
;
const
char
*
fOutputColor
;
const
char
*
fInputColor
;
const
TransformedCoordVars
&
fTransformedCoords
;
const
TextureSamplers
&
fTexSamplers
;
}
;
virtual
void
emitCode
(
EmitArgs
&
)
=
0
;
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
processor
)
;
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
count
(
)
;
}
GrGLSLFragmentProcessor
*
childProcessor
(
int
index
)
{
return
fChildProcessors
[
index
]
;
}
inline
void
invokeChild
(
int
childIndex
SkString
*
outputColor
EmitArgs
&
parentArgs
SkSL
:
:
String
skslCoords
=
"
"
)
{
this
-
>
invokeChild
(
childIndex
nullptr
outputColor
parentArgs
skslCoords
)
;
}
void
invokeChild
(
int
childIndex
const
char
*
inputColor
SkString
*
outputColor
EmitArgs
&
parentArgs
SkSL
:
:
String
skslCoords
=
"
"
)
;
inline
void
invokeChild
(
int
childIndex
EmitArgs
&
args
SkSL
:
:
String
skslCoords
=
"
"
)
{
this
-
>
invokeChild
(
childIndex
(
const
char
*
)
nullptr
args
skslCoords
)
;
}
void
invokeChild
(
int
childIndex
const
char
*
inputColor
EmitArgs
&
parentArgs
SkSL
:
:
String
skslCoords
=
"
"
)
;
class
Iter
:
public
SkNoncopyable
{
public
:
explicit
Iter
(
GrGLSLFragmentProcessor
*
fp
)
{
fFPStack
.
push_back
(
fp
)
;
}
explicit
Iter
(
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
fps
[
]
int
cnt
)
{
for
(
int
i
=
cnt
-
1
;
i
>
=
0
;
-
-
i
)
{
fFPStack
.
push_back
(
fps
[
i
]
.
get
(
)
)
;
}
}
GrGLSLFragmentProcessor
*
next
(
)
;
private
:
SkSTArray
<
4
GrGLSLFragmentProcessor
*
true
>
fFPStack
;
}
;
protected
:
virtual
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
{
}
private
:
void
writeChildCall
(
GrGLSLFPFragmentBuilder
*
fragBuilder
int
childIndex
TransformedCoordVars
coordVars
const
char
*
inputColor
const
char
*
outputColor
EmitArgs
&
args
SkSL
:
:
String
skslCoords
)
;
void
internalInvokeChild
(
int
const
char
*
const
char
*
EmitArgs
&
SkSL
:
:
String
)
;
SkTArray
<
SkString
>
fFunctionNames
;
SkTArray
<
GrGLSLFragmentProcessor
*
true
>
fChildProcessors
;
friend
class
GrFragmentProcessor
;
}
;
#
endif
