#
ifndef
GrGLSLPrimitiveProcessor_DEFINED
#
define
GrGLSLPrimitiveProcessor_DEFINED
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrPrimitiveProcessor
;
class
GrGLSLPPFragmentBuilder
;
class
GrGLSLGeometryBuilder
;
class
GrGLSLGPBuilder
;
class
GrGLSLVaryingHandler
;
class
GrGLSLVertexBuilder
;
class
GrShaderCaps
;
class
GrGLSLPrimitiveProcessor
{
public
:
using
FPCoordTransformIter
=
GrFragmentProcessor
:
:
CoordTransformIter
;
virtual
~
GrGLSLPrimitiveProcessor
(
)
{
}
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
using
ImageStorageHandle
=
GrGLSLUniformHandler
:
:
ImageStorageHandle
;
class
FPCoordTransformHandler
:
public
SkNoncopyable
{
public
:
FPCoordTransformHandler
(
const
GrPipeline
&
pipeline
SkTArray
<
GrShaderVar
>
*
transformedCoordVars
)
:
fIter
(
pipeline
)
fTransformedCoordVars
(
transformedCoordVars
)
{
}
~
FPCoordTransformHandler
(
)
{
SkASSERT
(
!
this
-
>
nextCoordTransform
(
)
)
;
}
const
GrCoordTransform
*
nextCoordTransform
(
)
;
template
<
typename
.
.
.
Args
>
void
specifyCoordsForCurrCoordTransform
(
Args
&
&
.
.
.
args
)
{
SkASSERT
(
!
fAddedCoord
)
;
fTransformedCoordVars
-
>
emplace_back
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
SkDEBUGCODE
(
fAddedCoord
=
true
;
)
}
private
:
GrFragmentProcessor
:
:
CoordTransformIter
fIter
;
SkDEBUGCODE
(
bool
fAddedCoord
=
false
;
)
SkDEBUGCODE
(
const
GrCoordTransform
*
fCurr
=
nullptr
;
)
SkTArray
<
GrShaderVar
>
*
fTransformedCoordVars
;
}
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLVertexBuilder
*
vertBuilder
GrGLSLGeometryBuilder
*
geomBuilder
GrGLSLPPFragmentBuilder
*
fragBuilder
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrPrimitiveProcessor
&
gp
const
char
*
outputColor
const
char
*
outputCoverage
const
char
*
distanceVectorName
const
char
*
rtAdjustName
const
SamplerHandle
*
texSamplers
const
SamplerHandle
*
bufferSamplers
const
ImageStorageHandle
*
imageStorages
FPCoordTransformHandler
*
transformHandler
)
:
fVertBuilder
(
vertBuilder
)
fGeomBuilder
(
geomBuilder
)
fFragBuilder
(
fragBuilder
)
fVaryingHandler
(
varyingHandler
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fGP
(
gp
)
fOutputColor
(
outputColor
)
fOutputCoverage
(
outputCoverage
)
fDistanceVectorName
(
distanceVectorName
)
fRTAdjustName
(
rtAdjustName
)
fTexSamplers
(
texSamplers
)
fBufferSamplers
(
bufferSamplers
)
fImageStorages
(
imageStorages
)
fFPCoordTransformHandler
(
transformHandler
)
{
}
GrGLSLVertexBuilder
*
fVertBuilder
;
GrGLSLGeometryBuilder
*
fGeomBuilder
;
GrGLSLPPFragmentBuilder
*
fFragBuilder
;
GrGLSLVaryingHandler
*
fVaryingHandler
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrPrimitiveProcessor
&
fGP
;
const
char
*
fOutputColor
;
const
char
*
fOutputCoverage
;
const
char
*
fDistanceVectorName
;
const
char
*
fRTAdjustName
;
const
SamplerHandle
*
fTexSamplers
;
const
SamplerHandle
*
fBufferSamplers
;
const
ImageStorageHandle
*
fImageStorages
;
FPCoordTransformHandler
*
fFPCoordTransformHandler
;
}
;
virtual
void
emitCode
(
EmitArgs
&
)
=
0
;
virtual
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
)
=
0
;
static
SkMatrix
GetTransformMatrix
(
const
SkMatrix
&
localMatrix
const
GrCoordTransform
&
)
;
protected
:
void
setupUniformColor
(
GrGLSLPPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
char
*
outputName
UniformHandle
*
colorUniform
)
;
}
;
#
endif
