#
ifndef
GrGLSLPrimitiveProcessor_DEFINED
#
define
GrGLSLPrimitiveProcessor_DEFINED
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
GrPrimitiveProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrPrimitiveProcessor
;
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLGeometryBuilder
;
class
GrGLSLGPBuilder
;
class
GrGLSLVaryingHandler
;
class
GrGLSLVertexBuilder
;
class
GrShaderCaps
;
class
GrGLSLPrimitiveProcessor
{
public
:
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
using
SamplerHandle
=
GrGLSLUniformHandler
:
:
SamplerHandle
;
using
FPCoordTransformIter
=
GrFragmentProcessor
:
:
CoordTransformIter
;
struct
TransformVar
{
TransformVar
(
)
=
default
;
TransformVar
(
SkString
matrixCode
UniformHandle
uniformMatrix
GrShaderVar
varyingPoint
)
:
fMatrixCode
(
std
:
:
move
(
matrixCode
)
)
fUniformMatrix
(
uniformMatrix
)
fVaryingPoint
(
varyingPoint
)
{
}
SkString
fMatrixCode
;
UniformHandle
fUniformMatrix
;
GrShaderVar
fVaryingPoint
;
}
;
virtual
~
GrGLSLPrimitiveProcessor
(
)
{
}
class
FPCoordTransformHandler
:
public
SkNoncopyable
{
public
:
FPCoordTransformHandler
(
const
GrPipeline
&
pipeline
SkTArray
<
TransformVar
>
*
transformedCoordVars
)
:
fIter
(
pipeline
)
fTransformedCoordVars
(
transformedCoordVars
)
{
}
~
FPCoordTransformHandler
(
)
{
SkASSERT
(
!
this
-
>
nextCoordTransform
(
)
)
;
}
const
GrCoordTransform
*
nextCoordTransform
(
)
;
template
<
typename
.
.
.
Args
>
void
specifyCoordsForCurrCoordTransform
(
Args
&
&
.
.
.
args
)
{
SkASSERT
(
!
fAddedCoord
)
;
fTransformedCoordVars
-
>
emplace_back
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
SkDEBUGCODE
(
fAddedCoord
=
true
;
)
}
private
:
GrFragmentProcessor
:
:
CoordTransformIter
fIter
;
SkDEBUGCODE
(
bool
fAddedCoord
=
false
;
)
SkDEBUGCODE
(
const
GrCoordTransform
*
fCurr
=
nullptr
;
)
SkTArray
<
TransformVar
>
*
fTransformedCoordVars
;
}
;
struct
EmitArgs
{
EmitArgs
(
GrGLSLVertexBuilder
*
vertBuilder
GrGLSLGeometryBuilder
*
geomBuilder
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
caps
const
GrPrimitiveProcessor
&
gp
const
char
*
outputColor
const
char
*
outputCoverage
const
char
*
rtAdjustName
const
SamplerHandle
*
texSamplers
FPCoordTransformHandler
*
transformHandler
)
:
fVertBuilder
(
vertBuilder
)
fGeomBuilder
(
geomBuilder
)
fFragBuilder
(
fragBuilder
)
fVaryingHandler
(
varyingHandler
)
fUniformHandler
(
uniformHandler
)
fShaderCaps
(
caps
)
fGP
(
gp
)
fOutputColor
(
outputColor
)
fOutputCoverage
(
outputCoverage
)
fRTAdjustName
(
rtAdjustName
)
fTexSamplers
(
texSamplers
)
fFPCoordTransformHandler
(
transformHandler
)
{
}
GrGLSLVertexBuilder
*
fVertBuilder
;
GrGLSLGeometryBuilder
*
fGeomBuilder
;
GrGLSLFPFragmentBuilder
*
fFragBuilder
;
GrGLSLVaryingHandler
*
fVaryingHandler
;
GrGLSLUniformHandler
*
fUniformHandler
;
const
GrShaderCaps
*
fShaderCaps
;
const
GrPrimitiveProcessor
&
fGP
;
const
char
*
fOutputColor
;
const
char
*
fOutputCoverage
;
const
char
*
fRTAdjustName
;
const
SamplerHandle
*
fTexSamplers
;
FPCoordTransformHandler
*
fFPCoordTransformHandler
;
}
;
virtual
void
emitCode
(
EmitArgs
&
)
=
0
;
virtual
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
)
=
0
;
static
SkMatrix
GetTransformMatrix
(
const
SkMatrix
&
localMatrix
const
GrCoordTransform
&
)
;
protected
:
void
setupUniformColor
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
char
*
outputName
UniformHandle
*
colorUniform
)
;
}
;
#
endif
