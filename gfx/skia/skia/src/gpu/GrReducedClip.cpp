#
include
"
GrReducedClip
.
h
"
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrDrawContextPriv
.
h
"
#
include
"
GrDrawingManager
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrUserStencilSettings
.
h
"
typedef
SkClipStack
:
:
Element
Element
;
GrReducedClip
:
:
GrReducedClip
(
const
SkClipStack
&
stack
const
SkRect
&
queryBounds
int
maxWindowRectangles
)
{
SkASSERT
(
!
queryBounds
.
isEmpty
(
)
)
;
fHasIBounds
=
false
;
if
(
stack
.
isWideOpen
(
)
)
{
fInitialState
=
InitialState
:
:
kAllIn
;
return
;
}
SkClipStack
:
:
BoundsType
stackBoundsType
;
SkRect
stackBounds
;
bool
iior
;
stack
.
getBounds
(
&
stackBounds
&
stackBoundsType
&
iior
)
;
if
(
stackBounds
.
isEmpty
(
)
|
|
GrClip
:
:
IsOutsideClip
(
stackBounds
queryBounds
)
)
{
bool
insideOut
=
SkClipStack
:
:
kInsideOut_BoundsType
=
=
stackBoundsType
;
fInitialState
=
insideOut
?
InitialState
:
:
kAllIn
:
InitialState
:
:
kAllOut
;
return
;
}
if
(
iior
)
{
SkASSERT
(
SkClipStack
:
:
kNormal_BoundsType
=
=
stackBoundsType
)
;
SkClipStack
:
:
Iter
iter
(
stack
SkClipStack
:
:
Iter
:
:
kTop_IterStart
)
;
if
(
!
iter
.
prev
(
)
-
>
isAA
(
)
|
|
GrClip
:
:
IsPixelAligned
(
stackBounds
)
)
{
stackBounds
.
round
(
&
fIBounds
)
;
fHasIBounds
=
true
;
fInitialState
=
fIBounds
.
isEmpty
(
)
?
InitialState
:
:
kAllOut
:
InitialState
:
:
kAllIn
;
return
;
}
if
(
GrClip
:
:
IsInsideClip
(
stackBounds
queryBounds
)
)
{
fInitialState
=
InitialState
:
:
kAllIn
;
return
;
}
SkRect
tightBounds
;
SkAssertResult
(
tightBounds
.
intersect
(
stackBounds
queryBounds
)
)
;
fIBounds
=
GrClip
:
:
GetPixelIBounds
(
tightBounds
)
;
SkASSERT
(
!
fIBounds
.
isEmpty
(
)
)
;
fHasIBounds
=
true
;
fElements
.
addToHead
(
stackBounds
SkCanvas
:
:
kReplace_Op
true
)
;
fElementsGenID
=
stack
.
getTopmostGenID
(
)
;
fRequiresAA
=
true
;
fInitialState
=
InitialState
:
:
kAllOut
;
return
;
}
SkRect
tighterQuery
=
queryBounds
;
if
(
SkClipStack
:
:
kNormal_BoundsType
=
=
stackBoundsType
)
{
SkAssertResult
(
tighterQuery
.
intersect
(
GrClip
:
:
GetPixelBounds
(
stackBounds
)
)
)
;
}
fIBounds
=
GrClip
:
:
GetPixelIBounds
(
tighterQuery
)
;
SkASSERT
(
!
fIBounds
.
isEmpty
(
)
)
;
fHasIBounds
=
true
;
this
-
>
walkStack
(
stack
tighterQuery
maxWindowRectangles
)
;
if
(
fWindowRects
.
count
(
)
<
maxWindowRectangles
)
{
this
-
>
addInteriorWindowRectangles
(
maxWindowRectangles
)
;
}
}
void
GrReducedClip
:
:
walkStack
(
const
SkClipStack
&
stack
const
SkRect
&
queryBounds
int
maxWindowRectangles
)
{
enum
class
InitialTriState
{
kUnknown
=
-
1
kAllIn
=
(
int
)
GrReducedClip
:
:
InitialState
:
:
kAllIn
kAllOut
=
(
int
)
GrReducedClip
:
:
InitialState
:
:
kAllOut
}
initialTriState
=
InitialTriState
:
:
kUnknown
;
bool
embiggens
=
false
;
bool
emsmallens
=
false
;
SkRect
relaxedQueryBounds
=
queryBounds
.
makeInset
(
GrClip
:
:
kBoundsTolerance
GrClip
:
:
kBoundsTolerance
)
;
SkClipStack
:
:
Iter
iter
(
stack
SkClipStack
:
:
Iter
:
:
kTop_IterStart
)
;
int
numAAElements
=
0
;
while
(
InitialTriState
:
:
kUnknown
=
=
initialTriState
)
{
const
Element
*
element
=
iter
.
prev
(
)
;
if
(
nullptr
=
=
element
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
break
;
}
if
(
SkClipStack
:
:
kEmptyGenID
=
=
element
-
>
getGenID
(
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
break
;
}
if
(
SkClipStack
:
:
kWideOpenGenID
=
=
element
-
>
getGenID
(
)
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
break
;
}
bool
skippable
=
false
;
bool
isFlip
=
false
;
switch
(
element
-
>
getOp
(
)
)
{
case
SkCanvas
:
:
kDifference_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
skippable
=
true
;
}
else
if
(
fWindowRects
.
count
(
)
<
maxWindowRectangles
&
&
!
embiggens
&
&
!
element
-
>
isAA
(
)
&
&
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
this
-
>
addWindowRectangle
(
element
-
>
getRect
(
)
false
)
;
skippable
=
true
;
}
}
if
(
!
skippable
)
{
emsmallens
=
true
;
}
break
;
case
SkCanvas
:
:
kIntersect_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
skippable
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
!
embiggens
&
&
!
element
-
>
isAA
(
)
&
&
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
SkIRect
nonaaRect
;
element
-
>
getRect
(
)
.
round
(
&
nonaaRect
)
;
if
(
!
this
-
>
intersectIBounds
(
nonaaRect
)
)
{
return
;
}
skippable
=
true
;
}
}
if
(
!
skippable
)
{
emsmallens
=
true
;
}
break
;
case
SkCanvas
:
:
kUnion_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
skippable
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
skippable
=
true
;
}
}
if
(
!
skippable
)
{
embiggens
=
true
;
}
break
;
case
SkCanvas
:
:
kXOR_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
isFlip
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
isFlip
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
skippable
=
true
;
}
}
if
(
!
skippable
)
{
emsmallens
=
embiggens
=
true
;
}
break
;
case
SkCanvas
:
:
kReverseDifference_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
isFlip
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
isFlip
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
}
if
(
!
skippable
)
{
emsmallens
=
embiggens
=
true
;
}
break
;
case
SkCanvas
:
:
kReplace_Op
:
if
(
element
-
>
isInverseFilled
(
)
)
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
skippable
=
true
;
}
}
else
{
if
(
element
-
>
contains
(
relaxedQueryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
skippable
=
true
;
}
else
if
(
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
skippable
=
true
;
}
else
if
(
!
embiggens
&
&
!
element
-
>
isAA
(
)
&
&
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
SkIRect
nonaaRect
;
element
-
>
getRect
(
)
.
round
(
&
nonaaRect
)
;
if
(
!
this
-
>
intersectIBounds
(
nonaaRect
)
)
{
return
;
}
initialTriState
=
InitialTriState
:
:
kAllIn
;
skippable
=
true
;
}
}
if
(
!
skippable
)
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
embiggens
=
emsmallens
=
true
;
}
break
;
default
:
SkDEBUGFAIL
(
"
Unexpected
op
.
"
)
;
break
;
}
if
(
!
skippable
)
{
if
(
0
=
=
fElements
.
count
(
)
)
{
fElementsGenID
=
element
-
>
getGenID
(
)
;
}
if
(
isFlip
)
{
SkASSERT
(
SkCanvas
:
:
kXOR_Op
=
=
element
-
>
getOp
(
)
|
|
SkCanvas
:
:
kReverseDifference_Op
=
=
element
-
>
getOp
(
)
)
;
fElements
.
addToHead
(
SkRect
:
:
Make
(
fIBounds
)
SkCanvas
:
:
kReverseDifference_Op
false
)
;
}
else
{
Element
*
newElement
=
fElements
.
addToHead
(
*
element
)
;
if
(
newElement
-
>
isAA
(
)
)
{
+
+
numAAElements
;
}
bool
isReplace
=
SkCanvas
:
:
kReplace_Op
=
=
newElement
-
>
getOp
(
)
;
if
(
newElement
-
>
isInverseFilled
(
)
&
&
(
SkCanvas
:
:
kIntersect_Op
=
=
newElement
-
>
getOp
(
)
|
|
isReplace
)
)
{
newElement
-
>
invertShapeFillType
(
)
;
newElement
-
>
setOp
(
SkCanvas
:
:
kDifference_Op
)
;
if
(
isReplace
)
{
SkASSERT
(
InitialTriState
:
:
kAllOut
=
=
initialTriState
)
;
initialTriState
=
InitialTriState
:
:
kAllIn
;
}
}
}
}
}
if
(
(
InitialTriState
:
:
kAllOut
=
=
initialTriState
&
&
!
embiggens
)
|
|
(
InitialTriState
:
:
kAllIn
=
=
initialTriState
&
&
!
emsmallens
)
)
{
fElements
.
reset
(
)
;
numAAElements
=
0
;
}
else
{
Element
*
element
=
fElements
.
headIter
(
)
.
get
(
)
;
while
(
element
)
{
bool
skippable
=
false
;
switch
(
element
-
>
getOp
(
)
)
{
case
SkCanvas
:
:
kDifference_Op
:
skippable
=
InitialTriState
:
:
kAllOut
=
=
initialTriState
;
break
;
case
SkCanvas
:
:
kIntersect_Op
:
if
(
InitialTriState
:
:
kAllOut
=
=
initialTriState
)
{
skippable
=
true
;
}
else
{
initialTriState
=
InitialTriState
:
:
kAllOut
;
element
-
>
setOp
(
SkCanvas
:
:
kReplace_Op
)
;
}
break
;
case
SkCanvas
:
:
kUnion_Op
:
if
(
InitialTriState
:
:
kAllIn
=
=
initialTriState
)
{
skippable
=
true
;
}
else
{
element
-
>
setOp
(
SkCanvas
:
:
kReplace_Op
)
;
}
break
;
case
SkCanvas
:
:
kXOR_Op
:
if
(
InitialTriState
:
:
kAllOut
=
=
initialTriState
)
{
element
-
>
setOp
(
SkCanvas
:
:
kReplace_Op
)
;
}
break
;
case
SkCanvas
:
:
kReverseDifference_Op
:
if
(
InitialTriState
:
:
kAllIn
=
=
initialTriState
)
{
skippable
=
true
;
initialTriState
=
InitialTriState
:
:
kAllOut
;
}
else
{
skippable
=
element
-
>
isInverseFilled
(
)
?
GrClip
:
:
IsOutsideClip
(
element
-
>
getBounds
(
)
queryBounds
)
:
element
-
>
contains
(
relaxedQueryBounds
)
;
if
(
skippable
)
{
initialTriState
=
InitialTriState
:
:
kAllIn
;
}
else
{
element
-
>
setOp
(
SkCanvas
:
:
kReplace_Op
)
;
}
}
break
;
case
SkCanvas
:
:
kReplace_Op
:
skippable
=
false
;
break
;
default
:
SkDEBUGFAIL
(
"
Unexpected
op
.
"
)
;
break
;
}
if
(
!
skippable
)
{
break
;
}
else
{
if
(
element
-
>
isAA
(
)
)
{
-
-
numAAElements
;
}
fElements
.
popHead
(
)
;
element
=
fElements
.
headIter
(
)
.
get
(
)
;
}
}
}
fRequiresAA
=
numAAElements
>
0
;
SkASSERT
(
InitialTriState
:
:
kUnknown
!
=
initialTriState
)
;
fInitialState
=
static_cast
<
GrReducedClip
:
:
InitialState
>
(
initialTriState
)
;
}
static
bool
element_is_pure_subtract
(
SkCanvas
:
:
ClipOp
op
)
{
SkASSERT
(
op
>
=
0
)
;
return
op
<
=
SkCanvas
:
:
kIntersect_Op
;
GR_STATIC_ASSERT
(
0
=
=
SkCanvas
:
:
kDifference_Op
)
;
GR_STATIC_ASSERT
(
1
=
=
SkCanvas
:
:
kIntersect_Op
)
;
}
void
GrReducedClip
:
:
addInteriorWindowRectangles
(
int
maxWindowRectangles
)
{
SkASSERT
(
fWindowRects
.
count
(
)
<
maxWindowRectangles
)
;
ElementList
:
:
Iter
iter
(
fElements
ElementList
:
:
Iter
:
:
kTail_IterStart
)
;
for
(
;
iter
.
get
(
)
&
&
element_is_pure_subtract
(
iter
.
get
(
)
-
>
getOp
(
)
)
;
iter
.
prev
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
if
(
SkCanvas
:
:
kDifference_Op
!
=
element
-
>
getOp
(
)
)
{
continue
;
}
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
SkASSERT
(
element
-
>
isAA
(
)
)
;
this
-
>
addWindowRectangle
(
element
-
>
getRect
(
)
true
)
;
if
(
fWindowRects
.
count
(
)
>
=
maxWindowRectangles
)
{
return
;
}
continue
;
}
if
(
Element
:
:
kRRect_Type
=
=
element
-
>
getType
(
)
)
{
const
SkRRect
&
clipRRect
=
element
-
>
getRRect
(
)
;
SkVector
insetTL
=
clipRRect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
;
SkVector
insetBR
=
clipRRect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
;
if
(
SkRRect
:
:
kComplex_Type
=
=
clipRRect
.
getType
(
)
)
{
const
SkVector
&
insetTR
=
clipRRect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
;
const
SkVector
&
insetBL
=
clipRRect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
;
insetTL
.
fX
=
SkTMax
(
insetTL
.
x
(
)
insetBL
.
x
(
)
)
;
insetTL
.
fY
=
SkTMax
(
insetTL
.
y
(
)
insetTR
.
y
(
)
)
;
insetBR
.
fX
=
SkTMax
(
insetBR
.
x
(
)
insetTR
.
x
(
)
)
;
insetBR
.
fY
=
SkTMax
(
insetBR
.
y
(
)
insetBL
.
y
(
)
)
;
}
const
SkRect
&
bounds
=
clipRRect
.
getBounds
(
)
;
if
(
insetTL
.
x
(
)
+
insetBR
.
x
(
)
>
=
bounds
.
width
(
)
|
|
insetTL
.
y
(
)
+
insetBR
.
y
(
)
>
=
bounds
.
height
(
)
)
{
continue
;
}
SkRect
horzRect
=
SkRect
:
:
MakeLTRB
(
bounds
.
left
(
)
bounds
.
top
(
)
+
insetTL
.
y
(
)
bounds
.
right
(
)
bounds
.
bottom
(
)
-
insetBR
.
y
(
)
)
;
this
-
>
addWindowRectangle
(
horzRect
element
-
>
isAA
(
)
)
;
if
(
fWindowRects
.
count
(
)
>
=
maxWindowRectangles
)
{
return
;
}
SkRect
vertRect
=
SkRect
:
:
MakeLTRB
(
bounds
.
left
(
)
+
insetTL
.
x
(
)
bounds
.
top
(
)
bounds
.
right
(
)
-
insetBR
.
x
(
)
bounds
.
bottom
(
)
)
;
this
-
>
addWindowRectangle
(
vertRect
element
-
>
isAA
(
)
)
;
if
(
fWindowRects
.
count
(
)
>
=
maxWindowRectangles
)
{
return
;
}
continue
;
}
}
}
inline
void
GrReducedClip
:
:
addWindowRectangle
(
const
SkRect
&
elementInteriorRect
bool
elementIsAA
)
{
SkIRect
window
;
if
(
!
elementIsAA
)
{
elementInteriorRect
.
round
(
&
window
)
;
}
else
{
elementInteriorRect
.
roundIn
(
&
window
)
;
}
if
(
!
window
.
isEmpty
(
)
)
{
fWindowRects
.
addWindow
(
window
)
;
}
}
inline
bool
GrReducedClip
:
:
intersectIBounds
(
const
SkIRect
&
irect
)
{
SkASSERT
(
fHasIBounds
)
;
if
(
!
fIBounds
.
intersect
(
irect
)
)
{
fHasIBounds
=
false
;
fWindowRects
.
reset
(
)
;
fElements
.
reset
(
)
;
fRequiresAA
=
false
;
fInitialState
=
InitialState
:
:
kAllOut
;
return
false
;
}
return
true
;
}
static
bool
stencil_element
(
GrDrawContext
*
dc
const
GrFixedClip
&
clip
const
GrUserStencilSettings
*
ss
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
{
switch
(
element
-
>
getType
(
)
)
{
case
Element
:
:
kEmpty_Type
:
SkDEBUGFAIL
(
"
Should
never
get
here
with
an
empty
element
.
"
)
;
break
;
case
Element
:
:
kRect_Type
:
return
dc
-
>
drawContextPriv
(
)
.
drawAndStencilRect
(
clip
ss
(
SkRegion
:
:
Op
)
element
-
>
getOp
(
)
element
-
>
isInverseFilled
(
)
element
-
>
isAA
(
)
viewMatrix
element
-
>
getRect
(
)
)
;
break
;
default
:
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
return
dc
-
>
drawContextPriv
(
)
.
drawAndStencilPath
(
clip
ss
(
SkRegion
:
:
Op
)
element
-
>
getOp
(
)
element
-
>
isInverseFilled
(
)
element
-
>
isAA
(
)
viewMatrix
path
)
;
break
;
}
}
return
false
;
}
static
void
draw_element
(
GrDrawContext
*
dc
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
{
switch
(
element
-
>
getType
(
)
)
{
case
Element
:
:
kEmpty_Type
:
SkDEBUGFAIL
(
"
Should
never
get
here
with
an
empty
element
.
"
)
;
break
;
case
Element
:
:
kRect_Type
:
dc
-
>
drawRect
(
clip
paint
viewMatrix
element
-
>
getRect
(
)
)
;
break
;
default
:
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
dc
-
>
drawPath
(
clip
paint
viewMatrix
path
GrStyle
:
:
SimpleFill
(
)
)
;
break
;
}
}
}
bool
GrReducedClip
:
:
drawAlphaClipMask
(
GrDrawContext
*
dc
)
const
{
GrFixedClip
clip
(
SkIRect
:
:
MakeWH
(
fIBounds
.
width
(
)
fIBounds
.
height
(
)
)
)
;
if
(
!
fWindowRects
.
empty
(
)
)
{
clip
.
setWindowRectangles
(
fWindowRects
{
fIBounds
.
left
(
)
fIBounds
.
top
(
)
}
GrWindowRectsState
:
:
Mode
:
:
kExclusive
)
;
}
GrColor
initialCoverage
=
InitialState
:
:
kAllIn
=
=
this
-
>
initialState
(
)
?
-
1
:
0
;
dc
-
>
drawContextPriv
(
)
.
clear
(
clip
initialCoverage
true
)
;
SkMatrix
translate
;
translate
.
setTranslate
(
SkIntToScalar
(
-
fIBounds
.
left
(
)
)
SkIntToScalar
(
-
fIBounds
.
top
(
)
)
)
;
for
(
ElementList
:
:
Iter
iter
(
fElements
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkRegion
:
:
Op
op
=
(
SkRegion
:
:
Op
)
element
-
>
getOp
(
)
;
bool
invert
=
element
-
>
isInverseFilled
(
)
;
if
(
invert
|
|
SkRegion
:
:
kIntersect_Op
=
=
op
|
|
SkRegion
:
:
kReverseDifference_Op
=
=
op
)
{
static
constexpr
GrUserStencilSettings
kStencilInElement
(
GrUserStencilSettings
:
:
StaticInit
<
0xffff
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kReplace
GrUserStencilOp
:
:
kReplace
0xffff
>
(
)
)
;
if
(
!
stencil_element
(
dc
clip
&
kStencilInElement
translate
element
)
)
{
return
false
;
}
static
constexpr
GrUserStencilSettings
kDrawOutsideElement
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kEqual
0xffff
GrUserStencilOp
:
:
kZero
GrUserStencilOp
:
:
kZero
0xffff
>
(
)
)
;
if
(
!
dc
-
>
drawContextPriv
(
)
.
drawAndStencilRect
(
clip
&
kDrawOutsideElement
op
!
invert
false
translate
SkRect
:
:
Make
(
fIBounds
)
)
)
{
return
false
;
}
}
else
{
GrPaint
paint
;
paint
.
setAntiAlias
(
element
-
>
isAA
(
)
)
;
paint
.
setCoverageSetOpXPFactory
(
op
false
)
;
draw_element
(
dc
clip
paint
translate
element
)
;
}
}
return
true
;
}
class
StencilClip
final
:
public
GrClip
{
public
:
StencilClip
(
const
SkIRect
&
scissorRect
)
:
fFixedClip
(
scissorRect
)
{
}
const
GrFixedClip
&
fixedClip
(
)
const
{
return
fFixedClip
;
}
void
setWindowRectangles
(
const
GrWindowRectangles
&
windows
const
SkIPoint
&
origin
GrWindowRectsState
:
:
Mode
mode
)
{
fFixedClip
.
setWindowRectangles
(
windows
origin
mode
)
;
}
private
:
bool
quickContains
(
const
SkRect
&
)
const
override
{
return
false
;
}
void
getConservativeBounds
(
int
width
int
height
SkIRect
*
bounds
bool
*
iior
)
const
override
{
fFixedClip
.
getConservativeBounds
(
width
height
bounds
iior
)
;
}
bool
isRRect
(
const
SkRect
&
rtBounds
SkRRect
*
rr
bool
*
aa
)
const
override
{
return
false
;
}
bool
apply
(
GrContext
*
context
GrDrawContext
*
drawContext
bool
useHWAA
bool
hasUserStencilSettings
GrAppliedClip
*
out
)
const
override
{
if
(
!
fFixedClip
.
apply
(
context
drawContext
useHWAA
hasUserStencilSettings
out
)
)
{
return
false
;
}
out
-
>
addStencilClip
(
)
;
return
true
;
}
GrFixedClip
fFixedClip
;
typedef
GrClip
INHERITED
;
}
;
bool
GrReducedClip
:
:
drawStencilClipMask
(
GrContext
*
context
GrDrawContext
*
drawContext
const
SkIPoint
&
clipOrigin
)
const
{
StencilClip
stencilClip
(
fIBounds
.
makeOffset
(
-
clipOrigin
.
x
(
)
-
clipOrigin
.
y
(
)
)
)
;
if
(
!
fWindowRects
.
empty
(
)
)
{
stencilClip
.
setWindowRectangles
(
fWindowRects
clipOrigin
GrWindowRectsState
:
:
Mode
:
:
kExclusive
)
;
}
bool
initialState
=
InitialState
:
:
kAllIn
=
=
this
-
>
initialState
(
)
;
drawContext
-
>
drawContextPriv
(
)
.
clearStencilClip
(
stencilClip
.
fixedClip
(
)
initialState
)
;
SkMatrix
viewMatrix
;
viewMatrix
.
setTranslate
(
SkIntToScalar
(
-
clipOrigin
.
x
(
)
)
SkIntToScalar
(
-
clipOrigin
.
y
(
)
)
)
;
for
(
ElementList
:
:
Iter
iter
(
fElements
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
bool
useHWAA
=
element
-
>
isAA
(
)
&
&
drawContext
-
>
isStencilBufferMultisampled
(
)
;
bool
fillInverted
=
false
;
GrPathRenderer
:
:
StencilSupport
stencilSupport
;
SkRegion
:
:
Op
op
=
(
SkRegion
:
:
Op
)
element
-
>
getOp
(
)
;
GrPathRenderer
*
pr
=
nullptr
;
SkPath
clipPath
;
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
stencilSupport
=
GrPathRenderer
:
:
kNoRestriction_StencilSupport
;
fillInverted
=
false
;
}
else
{
element
-
>
asPath
(
&
clipPath
)
;
fillInverted
=
clipPath
.
isInverseFillType
(
)
;
if
(
fillInverted
)
{
clipPath
.
toggleInverseFillType
(
)
;
}
GrShape
shape
(
clipPath
GrStyle
:
:
SimpleFill
(
)
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fShaderCaps
=
context
-
>
caps
(
)
-
>
shaderCaps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fAntiAlias
=
false
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
canDrawArgs
.
fIsStencilBufferMSAA
=
drawContext
-
>
isStencilBufferMultisampled
(
)
;
GrDrawingManager
*
dm
=
context
-
>
contextPriv
(
)
.
drawingManager
(
)
;
pr
=
dm
-
>
getPathRenderer
(
canDrawArgs
false
GrPathRendererChain
:
:
kStencilOnly_DrawType
&
stencilSupport
)
;
if
(
!
pr
)
{
return
false
;
}
}
bool
canRenderDirectToStencil
=
GrPathRenderer
:
:
kNoRestriction_StencilSupport
=
=
stencilSupport
;
bool
drawDirectToClip
;
GrUserStencilSettings
const
*
const
*
stencilPasses
=
GrStencilSettings
:
:
GetClipPasses
(
op
canRenderDirectToStencil
fillInverted
&
drawDirectToClip
)
;
if
(
!
drawDirectToClip
)
{
static
constexpr
GrUserStencilSettings
kDrawToStencil
(
GrUserStencilSettings
:
:
StaticInit
<
0x0000
GrUserStencilTest
:
:
kAlways
0xffff
GrUserStencilOp
:
:
kIncMaybeClamp
GrUserStencilOp
:
:
kIncMaybeClamp
0xffff
>
(
)
)
;
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
drawContext
-
>
drawContextPriv
(
)
.
stencilRect
(
stencilClip
.
fixedClip
(
)
&
kDrawToStencil
useHWAA
viewMatrix
element
-
>
getRect
(
)
)
;
}
else
{
if
(
!
clipPath
.
isEmpty
(
)
)
{
GrShape
shape
(
clipPath
GrStyle
:
:
SimpleFill
(
)
)
;
if
(
canRenderDirectToStencil
)
{
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Make
(
)
)
;
paint
.
setAntiAlias
(
element
-
>
isAA
(
)
)
;
GrPathRenderer
:
:
DrawPathArgs
args
;
args
.
fResourceProvider
=
context
-
>
resourceProvider
(
)
;
args
.
fPaint
=
&
paint
;
args
.
fUserStencilSettings
=
&
kDrawToStencil
;
args
.
fDrawContext
=
drawContext
;
args
.
fClip
=
&
stencilClip
.
fixedClip
(
)
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fShape
=
&
shape
;
args
.
fAntiAlias
=
false
;
args
.
fGammaCorrect
=
false
;
pr
-
>
drawPath
(
args
)
;
}
else
{
GrPathRenderer
:
:
StencilPathArgs
args
;
args
.
fResourceProvider
=
context
-
>
resourceProvider
(
)
;
args
.
fDrawContext
=
drawContext
;
args
.
fClip
=
&
stencilClip
.
fixedClip
(
)
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fIsAA
=
element
-
>
isAA
(
)
;
args
.
fShape
=
&
shape
;
pr
-
>
stencilPath
(
args
)
;
}
}
}
}
for
(
GrUserStencilSettings
const
*
const
*
pass
=
stencilPasses
;
*
pass
;
+
+
pass
)
{
if
(
drawDirectToClip
)
{
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
drawContext
-
>
drawContextPriv
(
)
.
stencilRect
(
stencilClip
*
pass
useHWAA
viewMatrix
element
-
>
getRect
(
)
)
;
}
else
{
GrShape
shape
(
clipPath
GrStyle
:
:
SimpleFill
(
)
)
;
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Make
(
)
)
;
paint
.
setAntiAlias
(
element
-
>
isAA
(
)
)
;
GrPathRenderer
:
:
DrawPathArgs
args
;
args
.
fResourceProvider
=
context
-
>
resourceProvider
(
)
;
args
.
fPaint
=
&
paint
;
args
.
fUserStencilSettings
=
*
pass
;
args
.
fDrawContext
=
drawContext
;
args
.
fClip
=
&
stencilClip
;
args
.
fViewMatrix
=
&
viewMatrix
;
args
.
fShape
=
&
shape
;
args
.
fAntiAlias
=
false
;
args
.
fGammaCorrect
=
false
;
pr
-
>
drawPath
(
args
)
;
}
}
else
{
drawContext
-
>
drawContextPriv
(
)
.
stencilRect
(
stencilClip
*
pass
false
viewMatrix
SkRect
:
:
Make
(
fIBounds
)
)
;
}
}
}
return
true
;
}
