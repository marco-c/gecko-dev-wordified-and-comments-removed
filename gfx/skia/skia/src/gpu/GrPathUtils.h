#
ifndef
GrPathUtils_DEFINED
#
define
GrPathUtils_DEFINED
#
include
"
SkGeometry
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkPathPriv
.
h
"
#
include
"
SkTArray
.
h
"
class
SkMatrix
;
namespace
GrPathUtils
{
SkScalar
scaleToleranceToSrc
(
SkScalar
devTol
const
SkMatrix
&
viewM
const
SkRect
&
pathBounds
)
;
int
worstCasePointCount
(
const
SkPath
&
int
*
subpaths
SkScalar
tol
)
;
uint32_t
quadraticPointCount
(
const
SkPoint
points
[
]
SkScalar
tol
)
;
uint32_t
generateQuadraticPoints
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
tolSqd
SkPoint
*
*
points
uint32_t
pointsLeft
)
;
uint32_t
cubicPointCount
(
const
SkPoint
points
[
]
SkScalar
tol
)
;
uint32_t
generateCubicPoints
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
SkScalar
tolSqd
SkPoint
*
*
points
uint32_t
pointsLeft
)
;
class
QuadUVMatrix
{
public
:
QuadUVMatrix
(
)
{
}
QuadUVMatrix
(
const
SkPoint
controlPts
[
3
]
)
{
this
-
>
set
(
controlPts
)
;
}
void
set
(
const
SkPoint
controlPts
[
3
]
)
;
void
apply
(
void
*
vertices
int
vertexCount
size_t
stride
size_t
uvOffset
)
const
{
intptr_t
xyPtr
=
reinterpret_cast
<
intptr_t
>
(
vertices
)
;
intptr_t
uvPtr
=
reinterpret_cast
<
intptr_t
>
(
vertices
)
+
uvOffset
;
float
sx
=
fM
[
0
]
;
float
kx
=
fM
[
1
]
;
float
tx
=
fM
[
2
]
;
float
ky
=
fM
[
3
]
;
float
sy
=
fM
[
4
]
;
float
ty
=
fM
[
5
]
;
for
(
int
i
=
0
;
i
<
vertexCount
;
+
+
i
)
{
const
SkPoint
*
xy
=
reinterpret_cast
<
const
SkPoint
*
>
(
xyPtr
)
;
SkPoint
*
uv
=
reinterpret_cast
<
SkPoint
*
>
(
uvPtr
)
;
uv
-
>
fX
=
sx
*
xy
-
>
fX
+
kx
*
xy
-
>
fY
+
tx
;
uv
-
>
fY
=
ky
*
xy
-
>
fX
+
sy
*
xy
-
>
fY
+
ty
;
xyPtr
+
=
stride
;
uvPtr
+
=
stride
;
}
}
private
:
float
fM
[
6
]
;
}
;
void
getConicKLM
(
const
SkPoint
p
[
3
]
const
SkScalar
weight
SkMatrix
*
klm
)
;
void
convertCubicToQuads
(
const
SkPoint
p
[
4
]
SkScalar
tolScale
SkTArray
<
SkPoint
true
>
*
quads
)
;
void
convertCubicToQuadsConstrainToTangents
(
const
SkPoint
p
[
4
]
SkScalar
tolScale
SkPathPriv
:
:
FirstDirection
dir
SkTArray
<
SkPoint
true
>
*
quads
)
;
enum
class
ExcludedTerm
{
kNonInvertible
kQuadraticTerm
kLinearTerm
}
;
ExcludedTerm
calcCubicInverseTransposePowerBasisMatrix
(
const
SkPoint
p
[
4
]
SkMatrix
*
out
)
;
SkCubicType
getCubicKLM
(
const
SkPoint
src
[
4
]
SkMatrix
*
klm
double
t
[
2
]
double
s
[
2
]
)
;
int
chopCubicAtLoopIntersection
(
const
SkPoint
src
[
4
]
SkPoint
dst
[
10
]
SkMatrix
*
klm
int
*
loopIndex
)
;
static
const
SkScalar
kDefaultTolerance
=
SkDoubleToScalar
(
0
.
25
)
;
static
const
int
kMaxPointsPerCurve
=
1
<
<
10
;
}
;
#
endif
