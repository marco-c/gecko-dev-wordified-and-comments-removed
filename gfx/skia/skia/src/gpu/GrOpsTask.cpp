#
include
"
src
/
gpu
/
GrOpsTask
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkExchange
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
gpu
/
GrAuditTrail
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetContext
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetPriv
.
h
"
#
include
"
src
/
gpu
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
GrStencilAttachment
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrRect
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrClearOp
.
h
"
static
const
int
kMaxOpMergeDistance
=
10
;
static
const
int
kMaxOpChainDistance
=
10
;
using
DstProxy
=
GrXferProcessor
:
:
DstProxy
;
static
inline
bool
can_reorder
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
!
GrRectsOverlap
(
a
b
)
;
}
inline
GrOpsTask
:
:
OpChain
:
:
List
:
:
List
(
std
:
:
unique_ptr
<
GrOp
>
op
)
:
fHead
(
std
:
:
move
(
op
)
)
fTail
(
fHead
.
get
(
)
)
{
this
-
>
validate
(
)
;
}
inline
GrOpsTask
:
:
OpChain
:
:
List
:
:
List
(
List
&
&
that
)
{
*
this
=
std
:
:
move
(
that
)
;
}
inline
GrOpsTask
:
:
OpChain
:
:
List
&
GrOpsTask
:
:
OpChain
:
:
List
:
:
operator
=
(
List
&
&
that
)
{
fHead
=
std
:
:
move
(
that
.
fHead
)
;
fTail
=
that
.
fTail
;
that
.
fTail
=
nullptr
;
this
-
>
validate
(
)
;
return
*
this
;
}
inline
std
:
:
unique_ptr
<
GrOp
>
GrOpsTask
:
:
OpChain
:
:
List
:
:
popHead
(
)
{
SkASSERT
(
fHead
)
;
auto
temp
=
fHead
-
>
cutChain
(
)
;
std
:
:
swap
(
temp
fHead
)
;
if
(
!
fHead
)
{
SkASSERT
(
fTail
=
=
temp
.
get
(
)
)
;
fTail
=
nullptr
;
}
return
temp
;
}
inline
std
:
:
unique_ptr
<
GrOp
>
GrOpsTask
:
:
OpChain
:
:
List
:
:
removeOp
(
GrOp
*
op
)
{
#
ifdef
SK_DEBUG
auto
head
=
op
;
while
(
head
-
>
prevInChain
(
)
)
{
head
=
head
-
>
prevInChain
(
)
;
}
SkASSERT
(
head
=
=
fHead
.
get
(
)
)
;
#
endif
auto
prev
=
op
-
>
prevInChain
(
)
;
if
(
!
prev
)
{
SkASSERT
(
op
=
=
fHead
.
get
(
)
)
;
return
this
-
>
popHead
(
)
;
}
auto
temp
=
prev
-
>
cutChain
(
)
;
if
(
auto
next
=
temp
-
>
cutChain
(
)
)
{
prev
-
>
chainConcat
(
std
:
:
move
(
next
)
)
;
}
else
{
SkASSERT
(
fTail
=
=
op
)
;
fTail
=
prev
;
}
this
-
>
validate
(
)
;
return
temp
;
}
inline
void
GrOpsTask
:
:
OpChain
:
:
List
:
:
pushHead
(
std
:
:
unique_ptr
<
GrOp
>
op
)
{
SkASSERT
(
op
)
;
SkASSERT
(
op
-
>
isChainHead
(
)
)
;
SkASSERT
(
op
-
>
isChainTail
(
)
)
;
if
(
fHead
)
{
op
-
>
chainConcat
(
std
:
:
move
(
fHead
)
)
;
fHead
=
std
:
:
move
(
op
)
;
}
else
{
fHead
=
std
:
:
move
(
op
)
;
fTail
=
fHead
.
get
(
)
;
}
}
inline
void
GrOpsTask
:
:
OpChain
:
:
List
:
:
pushTail
(
std
:
:
unique_ptr
<
GrOp
>
op
)
{
SkASSERT
(
op
-
>
isChainTail
(
)
)
;
fTail
-
>
chainConcat
(
std
:
:
move
(
op
)
)
;
fTail
=
fTail
-
>
nextInChain
(
)
;
}
inline
void
GrOpsTask
:
:
OpChain
:
:
List
:
:
validate
(
)
const
{
#
ifdef
SK_DEBUG
if
(
fHead
)
{
SkASSERT
(
fTail
)
;
fHead
-
>
validateChain
(
fTail
)
;
}
#
endif
}
GrOpsTask
:
:
OpChain
:
:
OpChain
(
std
:
:
unique_ptr
<
GrOp
>
op
GrProcessorSet
:
:
Analysis
processorAnalysis
GrAppliedClip
*
appliedClip
const
DstProxy
*
dstProxy
)
:
fList
{
std
:
:
move
(
op
)
}
fProcessorAnalysis
(
processorAnalysis
)
fAppliedClip
(
appliedClip
)
{
if
(
fProcessorAnalysis
.
requiresDstTexture
(
)
)
{
SkASSERT
(
dstProxy
&
&
dstProxy
-
>
proxy
(
)
)
;
fDstProxy
=
*
dstProxy
;
}
fBounds
=
fList
.
head
(
)
-
>
bounds
(
)
;
}
void
GrOpsTask
:
:
OpChain
:
:
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
func
)
const
{
if
(
fList
.
empty
(
)
)
{
return
;
}
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fList
.
head
(
)
)
)
{
op
.
visitProxies
(
func
)
;
}
if
(
fDstProxy
.
proxy
(
)
)
{
func
(
fDstProxy
.
proxy
(
)
GrMipMapped
:
:
kNo
)
;
}
if
(
fAppliedClip
)
{
fAppliedClip
-
>
visitProxies
(
func
)
;
}
}
void
GrOpsTask
:
:
OpChain
:
:
deleteOps
(
GrOpMemoryPool
*
pool
)
{
while
(
!
fList
.
empty
(
)
)
{
pool
-
>
release
(
fList
.
popHead
(
)
)
;
}
}
GrOpsTask
:
:
OpChain
:
:
List
GrOpsTask
:
:
OpChain
:
:
DoConcat
(
List
chainA
List
chainB
const
GrCaps
&
caps
GrOpMemoryPool
*
pool
GrAuditTrail
*
auditTrail
)
{
GrOp
*
origATail
=
chainA
.
tail
(
)
;
SkRect
skipBounds
=
SkRectPriv
:
:
MakeLargestInverted
(
)
;
do
{
int
numMergeChecks
=
0
;
bool
merged
=
false
;
bool
noSkip
=
(
origATail
=
=
chainA
.
tail
(
)
)
;
SkASSERT
(
noSkip
=
=
(
skipBounds
=
=
SkRectPriv
:
:
MakeLargestInverted
(
)
)
)
;
bool
canBackwardMerge
=
noSkip
|
|
can_reorder
(
chainB
.
head
(
)
-
>
bounds
(
)
skipBounds
)
;
SkRect
forwardMergeBounds
=
skipBounds
;
GrOp
*
a
=
origATail
;
while
(
a
)
{
bool
canForwardMerge
=
(
a
=
=
chainA
.
tail
(
)
)
|
|
can_reorder
(
a
-
>
bounds
(
)
forwardMergeBounds
)
;
if
(
canForwardMerge
|
|
canBackwardMerge
)
{
auto
result
=
a
-
>
combineIfPossible
(
chainB
.
head
(
)
caps
)
;
SkASSERT
(
result
!
=
GrOp
:
:
CombineResult
:
:
kCannotCombine
)
;
merged
=
(
result
=
=
GrOp
:
:
CombineResult
:
:
kMerged
)
;
GrOP_INFO
(
"
\
t
\
t
:
(
%
s
opID
:
%
u
)
-
>
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
chainB
.
head
(
)
-
>
name
(
)
chainB
.
head
(
)
-
>
uniqueID
(
)
a
-
>
name
(
)
a
-
>
uniqueID
(
)
)
;
}
if
(
merged
)
{
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
auditTrail
a
chainB
.
head
(
)
)
;
if
(
canBackwardMerge
)
{
pool
-
>
release
(
chainB
.
popHead
(
)
)
;
}
else
{
SkASSERT
(
canForwardMerge
)
;
if
(
a
=
=
origATail
)
{
origATail
=
a
-
>
prevInChain
(
)
;
}
std
:
:
unique_ptr
<
GrOp
>
detachedA
=
chainA
.
removeOp
(
a
)
;
pool
-
>
release
(
chainB
.
popHead
(
)
)
;
chainB
.
pushHead
(
std
:
:
move
(
detachedA
)
)
;
if
(
chainA
.
empty
(
)
)
{
return
chainB
;
}
}
break
;
}
else
{
if
(
+
+
numMergeChecks
=
=
kMaxOpMergeDistance
)
{
break
;
}
forwardMergeBounds
.
joinNonEmptyArg
(
a
-
>
bounds
(
)
)
;
canBackwardMerge
=
canBackwardMerge
&
&
can_reorder
(
chainB
.
head
(
)
-
>
bounds
(
)
a
-
>
bounds
(
)
)
;
a
=
a
-
>
prevInChain
(
)
;
}
}
if
(
!
merged
)
{
chainA
.
pushTail
(
chainB
.
popHead
(
)
)
;
skipBounds
.
joinNonEmptyArg
(
chainA
.
tail
(
)
-
>
bounds
(
)
)
;
}
}
while
(
!
chainB
.
empty
(
)
)
;
return
chainA
;
}
bool
GrOpsTask
:
:
OpChain
:
:
tryConcat
(
List
*
list
GrProcessorSet
:
:
Analysis
processorAnalysis
const
DstProxy
&
dstProxy
const
GrAppliedClip
*
appliedClip
const
SkRect
&
bounds
const
GrCaps
&
caps
GrOpMemoryPool
*
pool
GrAuditTrail
*
auditTrail
)
{
SkASSERT
(
!
fList
.
empty
(
)
)
;
SkASSERT
(
!
list
-
>
empty
(
)
)
;
SkASSERT
(
fProcessorAnalysis
.
requiresDstTexture
(
)
=
=
SkToBool
(
fDstProxy
.
proxy
(
)
)
)
;
SkASSERT
(
processorAnalysis
.
requiresDstTexture
(
)
=
=
SkToBool
(
dstProxy
.
proxy
(
)
)
)
;
if
(
fList
.
head
(
)
-
>
classID
(
)
!
=
list
-
>
head
(
)
-
>
classID
(
)
|
|
SkToBool
(
fAppliedClip
)
!
=
SkToBool
(
appliedClip
)
|
|
(
fAppliedClip
&
&
*
fAppliedClip
!
=
*
appliedClip
)
|
|
(
fProcessorAnalysis
.
requiresNonOverlappingDraws
(
)
!
=
processorAnalysis
.
requiresNonOverlappingDraws
(
)
)
|
|
(
fProcessorAnalysis
.
requiresNonOverlappingDraws
(
)
&
&
GrRectsTouchOrOverlap
(
fBounds
bounds
)
)
|
|
(
fProcessorAnalysis
.
requiresDstTexture
(
)
!
=
processorAnalysis
.
requiresDstTexture
(
)
)
|
|
(
fProcessorAnalysis
.
requiresDstTexture
(
)
&
&
fDstProxy
!
=
dstProxy
)
)
{
return
false
;
}
SkDEBUGCODE
(
bool
first
=
true
;
)
do
{
switch
(
fList
.
tail
(
)
-
>
combineIfPossible
(
list
-
>
head
(
)
caps
)
)
{
case
GrOp
:
:
CombineResult
:
:
kCannotCombine
:
SkASSERT
(
first
)
;
return
false
;
case
GrOp
:
:
CombineResult
:
:
kMayChain
:
fList
=
DoConcat
(
std
:
:
move
(
fList
)
skstd
:
:
exchange
(
*
list
List
(
)
)
caps
pool
auditTrail
)
;
SkASSERT
(
list
-
>
empty
(
)
)
;
break
;
case
GrOp
:
:
CombineResult
:
:
kMerged
:
{
GrOP_INFO
(
"
\
t
\
t
:
(
%
s
opID
:
%
u
)
-
>
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
list
-
>
tail
(
)
-
>
name
(
)
list
-
>
tail
(
)
-
>
uniqueID
(
)
list
-
>
head
(
)
-
>
name
(
)
list
-
>
head
(
)
-
>
uniqueID
(
)
)
;
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
auditTrail
fList
.
tail
(
)
list
-
>
head
(
)
)
;
pool
-
>
release
(
list
-
>
popHead
(
)
)
;
break
;
}
}
SkDEBUGCODE
(
first
=
false
)
;
}
while
(
!
list
-
>
empty
(
)
)
;
fBounds
.
joinPossiblyEmptyRect
(
bounds
)
;
return
true
;
}
bool
GrOpsTask
:
:
OpChain
:
:
prependChain
(
OpChain
*
that
const
GrCaps
&
caps
GrOpMemoryPool
*
pool
GrAuditTrail
*
auditTrail
)
{
if
(
!
that
-
>
tryConcat
(
&
fList
fProcessorAnalysis
fDstProxy
fAppliedClip
fBounds
caps
pool
auditTrail
)
)
{
this
-
>
validate
(
)
;
return
false
;
}
SkASSERT
(
fList
.
empty
(
)
)
;
fList
=
std
:
:
move
(
that
-
>
fList
)
;
fBounds
=
that
-
>
fBounds
;
that
-
>
fDstProxy
.
setProxy
(
nullptr
)
;
if
(
that
-
>
fAppliedClip
)
{
for
(
int
i
=
0
;
i
<
that
-
>
fAppliedClip
-
>
numClipCoverageFragmentProcessors
(
)
;
+
+
i
)
{
that
-
>
fAppliedClip
-
>
detachClipCoverageFragmentProcessor
(
i
)
;
}
}
this
-
>
validate
(
)
;
return
true
;
}
std
:
:
unique_ptr
<
GrOp
>
GrOpsTask
:
:
OpChain
:
:
appendOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrProcessorSet
:
:
Analysis
processorAnalysis
const
DstProxy
*
dstProxy
const
GrAppliedClip
*
appliedClip
const
GrCaps
&
caps
GrOpMemoryPool
*
pool
GrAuditTrail
*
auditTrail
)
{
const
GrXferProcessor
:
:
DstProxy
noDstProxy
;
if
(
!
dstProxy
)
{
dstProxy
=
&
noDstProxy
;
}
SkASSERT
(
op
-
>
isChainHead
(
)
&
&
op
-
>
isChainTail
(
)
)
;
SkRect
opBounds
=
op
-
>
bounds
(
)
;
List
chain
(
std
:
:
move
(
op
)
)
;
if
(
!
this
-
>
tryConcat
(
&
chain
processorAnalysis
*
dstProxy
appliedClip
opBounds
caps
pool
auditTrail
)
)
{
this
-
>
validate
(
)
;
return
chain
.
popHead
(
)
;
}
SkASSERT
(
chain
.
empty
(
)
)
;
this
-
>
validate
(
)
;
return
nullptr
;
}
inline
void
GrOpsTask
:
:
OpChain
:
:
validate
(
)
const
{
#
ifdef
SK_DEBUG
fList
.
validate
(
)
;
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fList
.
head
(
)
)
)
{
SkASSERT
(
fBounds
.
fLeft
<
=
op
.
bounds
(
)
.
fLeft
&
&
fBounds
.
fTop
<
=
op
.
bounds
(
)
.
fTop
&
&
fBounds
.
fRight
>
=
op
.
bounds
(
)
.
fRight
&
&
fBounds
.
fBottom
>
=
op
.
bounds
(
)
.
fBottom
)
;
}
#
endif
}
GrOpsTask
:
:
GrOpsTask
(
sk_sp
<
GrOpMemoryPool
>
opMemoryPool
sk_sp
<
GrRenderTargetProxy
>
rtProxy
GrAuditTrail
*
auditTrail
)
:
GrRenderTask
(
std
:
:
move
(
rtProxy
)
)
fOpMemoryPool
(
std
:
:
move
(
opMemoryPool
)
)
fAuditTrail
(
auditTrail
)
fLastClipStackGenID
(
SK_InvalidUniqueID
)
SkDEBUGCODE
(
fNumClips
(
0
)
)
{
SkASSERT
(
fOpMemoryPool
)
;
fTarget
-
>
setLastRenderTask
(
this
)
;
}
void
GrOpsTask
:
:
deleteOps
(
)
{
for
(
auto
&
chain
:
fOpChains
)
{
chain
.
deleteOps
(
fOpMemoryPool
.
get
(
)
)
;
}
fOpChains
.
reset
(
)
;
}
GrOpsTask
:
:
~
GrOpsTask
(
)
{
this
-
>
deleteOps
(
)
;
}
void
GrOpsTask
:
:
endFlush
(
)
{
fLastClipStackGenID
=
SK_InvalidUniqueID
;
this
-
>
deleteOps
(
)
;
fClipAllocator
.
reset
(
)
;
if
(
fTarget
&
&
this
=
=
fTarget
-
>
getLastRenderTask
(
)
)
{
fTarget
-
>
setLastRenderTask
(
nullptr
)
;
}
fTarget
.
reset
(
)
;
fDeferredProxies
.
reset
(
)
;
fSampledProxies
.
reset
(
)
;
fAuditTrail
=
nullptr
;
}
void
GrOpsTask
:
:
onPrePrepare
(
GrRecordingContext
*
context
)
{
SkASSERT
(
this
-
>
isClosed
(
)
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
#
endif
if
(
this
-
>
isNoOp
(
)
|
|
(
fClippedContentBounds
.
isEmpty
(
)
&
&
fColorLoadOp
!
=
GrLoadOp
:
:
kDiscard
)
)
{
return
;
}
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
chain
.
shouldExecute
(
)
)
{
chain
.
head
(
)
-
>
prePrepare
(
context
)
;
}
}
}
void
GrOpsTask
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
SkASSERT
(
fTarget
-
>
peekRenderTarget
(
)
)
;
SkASSERT
(
this
-
>
isClosed
(
)
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
#
endif
if
(
this
-
>
isNoOp
(
)
|
|
(
fClippedContentBounds
.
isEmpty
(
)
&
&
fColorLoadOp
!
=
GrLoadOp
:
:
kDiscard
)
)
{
return
;
}
flushState
-
>
setSampledProxyArray
(
&
fSampledProxies
)
;
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
chain
.
shouldExecute
(
)
)
{
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
.
gpu
"
chain
.
head
(
)
-
>
name
(
)
)
;
#
endif
GrOpFlushState
:
:
OpArgs
opArgs
(
chain
.
head
(
)
fTarget
-
>
asRenderTargetProxy
(
)
chain
.
appliedClip
(
)
chain
.
dstProxy
(
)
)
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
chain
.
head
(
)
-
>
prepare
(
flushState
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
}
flushState
-
>
setSampledProxyArray
(
nullptr
)
;
}
static
GrOpsRenderPass
*
create_render_pass
(
GrGpu
*
gpu
GrRenderTarget
*
rt
GrSurfaceOrigin
origin
const
SkIRect
&
bounds
GrLoadOp
colorLoadOp
const
SkPMColor4f
&
loadClearColor
GrLoadOp
stencilLoadOp
GrStoreOp
stencilStoreOp
const
SkTArray
<
GrTextureProxy
*
true
>
&
sampledProxies
)
{
const
GrOpsRenderPass
:
:
LoadAndStoreInfo
kColorLoadStoreInfo
{
colorLoadOp
GrStoreOp
:
:
kStore
loadClearColor
}
;
const
GrOpsRenderPass
:
:
StencilLoadAndStoreInfo
stencilLoadAndStoreInfo
{
stencilLoadOp
stencilStoreOp
}
;
return
gpu
-
>
getOpsRenderPass
(
rt
origin
bounds
kColorLoadStoreInfo
stencilLoadAndStoreInfo
sampledProxies
)
;
}
bool
GrOpsTask
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
if
(
this
-
>
isNoOp
(
)
|
|
(
fClippedContentBounds
.
isEmpty
(
)
&
&
fColorLoadOp
!
=
GrLoadOp
:
:
kDiscard
)
)
{
return
false
;
}
SkASSERT
(
fTarget
-
>
peekRenderTarget
(
)
)
;
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
SkASSERT
(
fColorLoadOp
!
=
GrLoadOp
:
:
kClear
|
|
!
flushState
-
>
gpu
(
)
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
;
const
GrCaps
&
caps
=
*
flushState
-
>
gpu
(
)
-
>
caps
(
)
;
GrRenderTarget
*
renderTarget
=
fTarget
.
get
(
)
-
>
peekRenderTarget
(
)
;
SkASSERT
(
renderTarget
)
;
GrStencilAttachment
*
stencil
=
renderTarget
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
GrLoadOp
stencilLoadOp
;
switch
(
fInitialStencilContent
)
{
case
StencilContent
:
:
kDontCare
:
stencilLoadOp
=
GrLoadOp
:
:
kDiscard
;
break
;
case
StencilContent
:
:
kUserBitsCleared
:
SkASSERT
(
!
caps
.
performStencilClearsAsDraws
(
)
)
;
SkASSERT
(
stencil
)
;
if
(
caps
.
discardStencilValuesAfterRenderPass
(
)
)
{
stencilLoadOp
=
GrLoadOp
:
:
kClear
;
break
;
}
if
(
!
stencil
-
>
hasPerformedInitialClear
(
)
)
{
stencilLoadOp
=
GrLoadOp
:
:
kClear
;
stencil
-
>
markHasPerformedInitialClear
(
)
;
break
;
}
case
StencilContent
:
:
kPreserved
:
SkASSERT
(
stencil
)
;
stencilLoadOp
=
GrLoadOp
:
:
kLoad
;
break
;
}
GrStoreOp
stencilStoreOp
=
(
caps
.
discardStencilValuesAfterRenderPass
(
)
&
&
!
fMustPreserveStencil
)
?
GrStoreOp
:
:
kDiscard
:
GrStoreOp
:
:
kStore
;
GrOpsRenderPass
*
renderPass
=
create_render_pass
(
flushState
-
>
gpu
(
)
fTarget
-
>
peekRenderTarget
(
)
fTarget
-
>
origin
(
)
fClippedContentBounds
fColorLoadOp
fLoadClearColor
stencilLoadOp
stencilStoreOp
fSampledProxies
)
;
flushState
-
>
setOpsRenderPass
(
renderPass
)
;
renderPass
-
>
begin
(
)
;
for
(
const
auto
&
chain
:
fOpChains
)
{
if
(
!
chain
.
shouldExecute
(
)
)
{
continue
;
}
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
.
gpu
"
chain
.
head
(
)
-
>
name
(
)
)
;
#
endif
GrOpFlushState
:
:
OpArgs
opArgs
(
chain
.
head
(
)
fTarget
-
>
asRenderTargetProxy
(
)
chain
.
appliedClip
(
)
chain
.
dstProxy
(
)
)
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
chain
.
head
(
)
-
>
execute
(
flushState
chain
.
bounds
(
)
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
renderPass
-
>
end
(
)
;
flushState
-
>
gpu
(
)
-
>
submit
(
renderPass
)
;
flushState
-
>
setOpsRenderPass
(
nullptr
)
;
return
true
;
}
void
GrOpsTask
:
:
setColorLoadOp
(
GrLoadOp
op
const
SkPMColor4f
&
color
)
{
fColorLoadOp
=
op
;
fLoadClearColor
=
color
;
if
(
GrLoadOp
:
:
kClear
=
=
fColorLoadOp
)
{
fTotalBounds
.
setWH
(
fTarget
-
>
width
(
)
fTarget
-
>
height
(
)
)
;
}
}
bool
GrOpsTask
:
:
resetForFullscreenClear
(
CanDiscardPreviousOps
canDiscardPreviousOps
)
{
if
(
fHasWaitOp
)
{
canDiscardPreviousOps
=
CanDiscardPreviousOps
:
:
kNo
;
}
if
(
CanDiscardPreviousOps
:
:
kYes
=
=
canDiscardPreviousOps
|
|
this
-
>
isEmpty
(
)
)
{
this
-
>
deleteOps
(
)
;
fDeferredProxies
.
reset
(
)
;
fSampledProxies
.
reset
(
)
;
return
!
fTarget
-
>
asRenderTargetProxy
(
)
-
>
wrapsVkSecondaryCB
(
)
;
}
return
false
;
}
void
GrOpsTask
:
:
discard
(
)
{
if
(
this
-
>
isEmpty
(
)
)
{
fColorLoadOp
=
GrLoadOp
:
:
kDiscard
;
fInitialStencilContent
=
StencilContent
:
:
kDontCare
;
fTotalBounds
.
setEmpty
(
)
;
}
}
#
ifdef
SK_DEBUG
void
GrOpsTask
:
:
dump
(
bool
printDependencies
)
const
{
GrRenderTask
:
:
dump
(
printDependencies
)
;
SkDebugf
(
"
fColorLoadOp
:
"
)
;
switch
(
fColorLoadOp
)
{
case
GrLoadOp
:
:
kLoad
:
SkDebugf
(
"
kLoad
\
n
"
)
;
break
;
case
GrLoadOp
:
:
kClear
:
SkDebugf
(
"
kClear
(
0x
%
x
)
\
n
"
fLoadClearColor
.
toBytes_RGBA
(
)
)
;
break
;
case
GrLoadOp
:
:
kDiscard
:
SkDebugf
(
"
kDiscard
\
n
"
)
;
break
;
}
SkDebugf
(
"
fInitialStencilContent
:
"
)
;
switch
(
fInitialStencilContent
)
{
case
StencilContent
:
:
kDontCare
:
SkDebugf
(
"
kDontCare
\
n
"
)
;
break
;
case
StencilContent
:
:
kUserBitsCleared
:
SkDebugf
(
"
kUserBitsCleared
\
n
"
)
;
break
;
case
StencilContent
:
:
kPreserved
:
SkDebugf
(
"
kPreserved
\
n
"
)
;
break
;
}
SkDebugf
(
"
ops
(
%
d
)
:
\
n
"
fOpChains
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpChains
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
;
if
(
!
fOpChains
[
i
]
.
head
(
)
)
{
SkDebugf
(
"
%
d
:
<
combined
forward
or
failed
instantiation
>
\
n
"
i
)
;
}
else
{
SkDebugf
(
"
%
d
:
%
s
\
n
"
i
fOpChains
[
i
]
.
head
(
)
-
>
name
(
)
)
;
SkRect
bounds
=
fOpChains
[
i
]
.
bounds
(
)
;
SkDebugf
(
"
ClippedBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
bounds
.
fLeft
bounds
.
fTop
bounds
.
fRight
bounds
.
fBottom
)
;
for
(
const
auto
&
op
:
GrOp
:
:
ChainRange
<
>
(
fOpChains
[
i
]
.
head
(
)
)
)
{
SkString
info
=
SkTabString
(
op
.
dumpInfo
(
)
1
)
;
SkDebugf
(
"
%
s
\
n
"
info
.
c_str
(
)
)
;
bounds
=
op
.
bounds
(
)
;
SkDebugf
(
"
\
tClippedBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
bounds
.
fLeft
bounds
.
fTop
bounds
.
fRight
bounds
.
fBottom
)
;
}
}
}
}
void
GrOpsTask
:
:
visitProxies_debugOnly
(
const
VisitSurfaceProxyFunc
&
func
)
const
{
auto
textureFunc
=
[
func
]
(
GrTextureProxy
*
tex
GrMipMapped
mipmapped
)
{
func
(
tex
mipmapped
)
;
}
;
for
(
const
OpChain
&
chain
:
fOpChains
)
{
chain
.
visitProxies
(
textureFunc
)
;
}
}
#
endif
bool
GrOpsTask
:
:
onIsUsed
(
GrSurfaceProxy
*
proxyToCheck
)
const
{
bool
used
=
false
;
auto
visit
=
[
proxyToCheck
&
used
]
(
GrSurfaceProxy
*
p
GrMipMapped
)
{
if
(
p
=
=
proxyToCheck
)
{
used
=
true
;
}
}
;
for
(
const
OpChain
&
recordedOp
:
fOpChains
)
{
recordedOp
.
visitProxies
(
visit
)
;
}
return
used
;
}
void
GrOpsTask
:
:
handleInternalAllocationFailure
(
)
{
bool
hasUninstantiatedProxy
=
false
;
auto
checkInstantiation
=
[
&
hasUninstantiatedProxy
]
(
GrSurfaceProxy
*
p
GrMipMapped
)
{
if
(
!
p
-
>
isInstantiated
(
)
)
{
hasUninstantiatedProxy
=
true
;
}
}
;
for
(
OpChain
&
recordedOp
:
fOpChains
)
{
hasUninstantiatedProxy
=
false
;
recordedOp
.
visitProxies
(
checkInstantiation
)
;
if
(
hasUninstantiatedProxy
)
{
recordedOp
.
setSkipExecuteFlag
(
)
;
}
}
}
void
GrOpsTask
:
:
gatherProxyIntervals
(
GrResourceAllocator
*
alloc
)
const
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
fDeferredProxies
[
i
]
-
>
isInstantiated
(
)
)
;
alloc
-
>
addInterval
(
fDeferredProxies
[
i
]
0
0
GrResourceAllocator
:
:
ActualUse
:
:
kNo
)
;
}
if
(
fOpChains
.
count
(
)
)
{
unsigned
int
cur
=
alloc
-
>
curOp
(
)
;
alloc
-
>
addInterval
(
fTarget
.
get
(
)
cur
cur
+
fOpChains
.
count
(
)
-
1
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
}
else
{
alloc
-
>
addInterval
(
fTarget
.
get
(
)
alloc
-
>
curOp
(
)
alloc
-
>
curOp
(
)
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
alloc
-
>
incOps
(
)
;
}
auto
gather
=
[
alloc
SkDEBUGCODE
(
this
)
]
(
GrSurfaceProxy
*
p
GrMipMapped
)
{
alloc
-
>
addInterval
(
p
alloc
-
>
curOp
(
)
alloc
-
>
curOp
(
)
GrResourceAllocator
:
:
ActualUse
:
:
kYes
SkDEBUGCODE
(
fTarget
.
get
(
)
=
=
p
)
)
;
}
;
for
(
const
OpChain
&
recordedOp
:
fOpChains
)
{
recordedOp
.
visitProxies
(
gather
)
;
alloc
-
>
incOps
(
)
;
}
}
void
GrOpsTask
:
:
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrProcessorSet
:
:
Analysis
processorAnalysis
GrAppliedClip
*
clip
const
DstProxy
*
dstProxy
const
GrCaps
&
caps
)
{
SkDEBUGCODE
(
op
-
>
validate
(
)
;
)
SkASSERT
(
processorAnalysis
.
requiresDstTexture
(
)
=
=
(
dstProxy
&
&
dstProxy
-
>
proxy
(
)
)
)
;
SkASSERT
(
fTarget
)
;
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
if
(
!
op
-
>
bounds
(
)
.
isFinite
(
)
)
{
fOpMemoryPool
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
fTotalBounds
.
join
(
op
-
>
bounds
(
)
)
;
GR_AUDIT_TRAIL_ADD_OP
(
fAuditTrail
op
.
get
(
)
fTarget
-
>
uniqueID
(
)
)
;
GrOP_INFO
(
"
opsTask
:
%
d
Recording
(
%
s
opID
:
%
u
)
\
n
"
"
\
tBounds
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
this
-
>
uniqueID
(
)
op
-
>
name
(
)
op
-
>
uniqueID
(
)
op
-
>
bounds
(
)
.
fLeft
op
-
>
bounds
(
)
.
fTop
op
-
>
bounds
(
)
.
fRight
op
-
>
bounds
(
)
.
fBottom
)
;
GrOP_INFO
(
SkTabString
(
op
-
>
dumpInfo
(
)
1
)
.
c_str
(
)
)
;
GrOP_INFO
(
"
\
tOutcome
:
\
n
"
)
;
int
maxCandidates
=
SkTMin
(
kMaxOpChainDistance
fOpChains
.
count
(
)
)
;
if
(
maxCandidates
)
{
int
i
=
0
;
while
(
true
)
{
OpChain
&
candidate
=
fOpChains
.
fromBack
(
i
)
;
op
=
candidate
.
appendOp
(
std
:
:
move
(
op
)
processorAnalysis
dstProxy
clip
caps
fOpMemoryPool
.
get
(
)
fAuditTrail
)
;
if
(
!
op
)
{
return
;
}
if
(
!
can_reorder
(
candidate
.
bounds
(
)
op
-
>
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Intersects
with
chain
(
%
s
head
opID
:
%
u
)
\
n
"
candidate
.
head
(
)
-
>
name
(
)
candidate
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
if
(
+
+
i
=
=
maxCandidates
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Reached
max
lookback
or
beginning
of
op
array
%
d
\
n
"
i
)
;
break
;
}
}
}
else
{
GrOP_INFO
(
"
\
t
\
tBackward
:
FirstOp
\
n
"
)
;
}
if
(
clip
)
{
clip
=
fClipAllocator
.
make
<
GrAppliedClip
>
(
std
:
:
move
(
*
clip
)
)
;
SkDEBUGCODE
(
fNumClips
+
+
;
)
}
fOpChains
.
emplace_back
(
std
:
:
move
(
op
)
processorAnalysis
clip
dstProxy
)
;
}
void
GrOpsTask
:
:
forwardCombine
(
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrOP_INFO
(
"
opsTask
:
%
d
ForwardCombine
%
d
ops
:
\
n
"
this
-
>
uniqueID
(
)
fOpChains
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fOpChains
.
count
(
)
-
1
;
+
+
i
)
{
OpChain
&
chain
=
fOpChains
[
i
]
;
int
maxCandidateIdx
=
SkTMin
(
i
+
kMaxOpChainDistance
fOpChains
.
count
(
)
-
1
)
;
int
j
=
i
+
1
;
while
(
true
)
{
OpChain
&
candidate
=
fOpChains
[
j
]
;
if
(
candidate
.
prependChain
(
&
chain
caps
fOpMemoryPool
.
get
(
)
fAuditTrail
)
)
{
break
;
}
if
(
!
can_reorder
(
chain
.
bounds
(
)
candidate
.
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
chain
(
%
s
head
opID
:
%
u
)
-
>
"
"
Intersects
with
chain
(
%
s
head
opID
:
%
u
)
\
n
"
i
chain
.
head
(
)
-
>
name
(
)
chain
.
head
(
)
-
>
uniqueID
(
)
candidate
.
head
(
)
-
>
name
(
)
candidate
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
if
(
+
+
j
>
maxCandidateIdx
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
chain
(
%
s
opID
:
%
u
)
-
>
Reached
max
lookahead
or
end
of
array
\
n
"
i
chain
.
head
(
)
-
>
name
(
)
chain
.
head
(
)
-
>
uniqueID
(
)
)
;
break
;
}
}
}
}
GrRenderTask
:
:
ExpectedOutcome
GrOpsTask
:
:
onMakeClosed
(
const
GrCaps
&
caps
SkIRect
*
targetUpdateBounds
)
{
this
-
>
forwardCombine
(
caps
)
;
if
(
!
this
-
>
isNoOp
(
)
)
{
SkRect
clippedContentBounds
=
SkRect
:
:
MakeIWH
(
fTarget
-
>
width
(
)
fTarget
-
>
height
(
)
)
;
if
(
clippedContentBounds
.
intersect
(
fTotalBounds
)
)
{
clippedContentBounds
.
roundOut
(
&
fClippedContentBounds
)
;
*
targetUpdateBounds
=
fClippedContentBounds
;
return
ExpectedOutcome
:
:
kTargetDirty
;
}
}
return
ExpectedOutcome
:
:
kTargetUnchanged
;
}
