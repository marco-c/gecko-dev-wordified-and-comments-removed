#
include
"
GrYUVProvider
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkCachedData
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkYUVPlanesCache
.
h
"
#
include
"
effects
/
GrNonlinearColorSpaceXformEffect
.
h
"
#
include
"
effects
/
GrSRGBEffect
.
h
"
#
include
"
effects
/
GrYUVtoRGBEffect
.
h
"
sk_sp
<
SkCachedData
>
init_provider
(
GrYUVProvider
*
provider
SkYUVPlanesCache
:
:
Info
*
yuvInfo
void
*
planes
[
3
]
)
{
sk_sp
<
SkCachedData
>
data
;
data
.
reset
(
SkYUVPlanesCache
:
:
FindAndRef
(
provider
-
>
onGetID
(
)
yuvInfo
)
)
;
if
(
data
.
get
(
)
)
{
planes
[
0
]
=
(
void
*
)
data
-
>
data
(
)
;
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
}
else
{
if
(
!
provider
-
>
onQueryYUV8
(
&
yuvInfo
-
>
fSizeInfo
&
yuvInfo
-
>
fColorSpace
)
)
{
return
nullptr
;
}
size_t
totalSize
(
0
)
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
totalSize
+
=
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
i
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
}
data
.
reset
(
SkResourceCache
:
:
NewCachedData
(
totalSize
)
)
;
planes
[
0
]
=
data
-
>
writable_data
(
)
;
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
if
(
!
provider
-
>
onGetYUV8Planes
(
yuvInfo
-
>
fSizeInfo
planes
)
)
{
return
nullptr
;
}
SkYUVPlanesCache
:
:
Add
(
provider
-
>
onGetID
(
)
data
.
get
(
)
yuvInfo
)
;
}
return
data
;
}
void
GrYUVProvider
:
:
YUVGen_DataReleaseProc
(
const
void
*
void
*
data
)
{
SkCachedData
*
cachedData
=
static_cast
<
SkCachedData
*
>
(
data
)
;
SkASSERT
(
cachedData
)
;
cachedData
-
>
unref
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrYUVProvider
:
:
refAsTextureProxy
(
GrContext
*
ctx
const
GrSurfaceDesc
&
desc
const
SkColorSpace
*
srcColorSpace
const
SkColorSpace
*
dstColorSpace
)
{
SkYUVPlanesCache
:
:
Info
yuvInfo
;
void
*
planes
[
3
]
;
sk_sp
<
SkCachedData
>
dataStorage
=
init_provider
(
this
&
yuvInfo
planes
)
;
if
(
!
dataStorage
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
yuvTextureProxies
[
3
]
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
int
componentWidth
=
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fWidth
;
int
componentHeight
=
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
SkBackingFit
fit
=
(
componentWidth
!
=
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
)
|
|
(
componentHeight
!
=
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
?
SkBackingFit
:
:
kExact
:
SkBackingFit
:
:
kApprox
;
SkImageInfo
imageInfo
=
SkImageInfo
:
:
MakeA8
(
componentWidth
componentHeight
)
;
SkPixmap
pixmap
(
imageInfo
planes
[
i
]
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
)
;
SkCachedData
*
dataStoragePtr
=
dataStorage
.
get
(
)
;
dataStoragePtr
-
>
ref
(
)
;
sk_sp
<
SkImage
>
yuvImage
=
SkImage
:
:
MakeFromRaster
(
pixmap
YUVGen_DataReleaseProc
dataStoragePtr
)
;
auto
proxyProvider
=
ctx
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
yuvTextureProxies
[
i
]
=
proxyProvider
-
>
createTextureProxy
(
yuvImage
kNone_GrSurfaceFlags
kTopLeft_GrSurfaceOrigin
1
SkBudgeted
:
:
kYes
fit
)
;
}
sk_sp
<
SkColorSpace
>
colorSpace
;
if
(
GrPixelConfigIsSRGB
(
desc
.
fConfig
)
)
{
colorSpace
=
SkColorSpace
:
:
MakeSRGB
(
)
;
}
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
(
ctx
-
>
makeDeferredRenderTargetContext
(
SkBackingFit
:
:
kExact
desc
.
fWidth
desc
.
fHeight
desc
.
fConfig
std
:
:
move
(
colorSpace
)
desc
.
fSampleCnt
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
GrPaint
paint
;
auto
yuvToRgbProcessor
=
GrYUVtoRGBEffect
:
:
Make
(
std
:
:
move
(
yuvTextureProxies
[
0
]
)
std
:
:
move
(
yuvTextureProxies
[
1
]
)
std
:
:
move
(
yuvTextureProxies
[
2
]
)
yuvInfo
.
fSizeInfo
.
fSizes
yuvInfo
.
fColorSpace
false
)
;
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
yuvToRgbProcessor
)
)
;
if
(
GrPixelConfigIsSRGB
(
desc
.
fConfig
)
)
{
if
(
ctx
-
>
caps
(
)
-
>
srgbWriteControl
(
)
)
{
paint
.
setDisableOutputConversionToSRGB
(
true
)
;
}
else
{
paint
.
addColorFragmentProcessor
(
GrSRGBEffect
:
:
Make
(
GrSRGBEffect
:
:
Mode
:
:
kSRGBToLinear
GrSRGBEffect
:
:
Alpha
:
:
kOpaque
)
)
;
}
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorConversionProcessor
=
GrNonlinearColorSpaceXformEffect
:
:
Make
(
srcColorSpace
dstColorSpace
)
;
if
(
colorConversionProcessor
)
{
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
colorConversionProcessor
)
)
;
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
const
SkRect
r
=
SkRect
:
:
MakeIWH
(
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
renderTargetContext
-
>
drawRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
)
;
return
renderTargetContext
-
>
asTextureProxyRef
(
)
;
}
