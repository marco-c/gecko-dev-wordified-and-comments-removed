#
include
"
GrYUVProvider
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRecordingContext
.
h
"
#
include
"
GrRecordingContextPriv
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkCachedData
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkYUVPlanesCache
.
h
"
#
include
"
SkYUVAIndex
.
h
"
#
include
"
effects
/
GrYUVtoRGBEffect
.
h
"
sk_sp
<
SkCachedData
>
GrYUVProvider
:
:
getPlanes
(
SkYUVASizeInfo
*
size
SkYUVAIndex
yuvaIndices
[
SkYUVAIndex
:
:
kIndexCount
]
SkYUVColorSpace
*
colorSpace
const
void
*
constPlanes
[
SkYUVASizeInfo
:
:
kMaxCount
]
)
{
sk_sp
<
SkCachedData
>
data
;
SkYUVPlanesCache
:
:
Info
yuvInfo
;
data
.
reset
(
SkYUVPlanesCache
:
:
FindAndRef
(
this
-
>
onGetID
(
)
&
yuvInfo
)
)
;
void
*
planes
[
SkYUVASizeInfo
:
:
kMaxCount
]
;
if
(
data
.
get
(
)
)
{
planes
[
0
]
=
(
void
*
)
data
-
>
data
(
)
;
for
(
int
i
=
1
;
i
<
SkYUVASizeInfo
:
:
kMaxCount
;
+
+
i
)
{
if
(
!
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
)
{
SkASSERT
(
!
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
&
&
!
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
)
;
planes
[
i
]
=
nullptr
;
continue
;
}
planes
[
i
]
=
(
uint8_t
*
)
planes
[
i
-
1
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
-
1
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
i
-
1
]
.
fHeight
)
;
}
}
else
{
if
(
!
this
-
>
onQueryYUVA8
(
&
yuvInfo
.
fSizeInfo
yuvInfo
.
fYUVAIndices
&
yuvInfo
.
fColorSpace
)
)
{
return
nullptr
;
}
size_t
totalSize
(
0
)
;
for
(
int
i
=
0
;
i
<
SkYUVASizeInfo
:
:
kMaxCount
;
i
+
+
)
{
SkASSERT
(
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
&
&
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
)
|
|
(
!
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
&
&
!
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
)
)
;
totalSize
+
=
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
}
data
.
reset
(
SkResourceCache
:
:
NewCachedData
(
totalSize
)
)
;
planes
[
0
]
=
data
-
>
writable_data
(
)
;
for
(
int
i
=
1
;
i
<
SkYUVASizeInfo
:
:
kMaxCount
;
+
+
i
)
{
if
(
!
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
)
{
SkASSERT
(
!
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
&
&
!
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
)
;
planes
[
i
]
=
nullptr
;
continue
;
}
planes
[
i
]
=
(
uint8_t
*
)
planes
[
i
-
1
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
-
1
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
i
-
1
]
.
fHeight
)
;
}
if
(
!
this
-
>
onGetYUVA8Planes
(
yuvInfo
.
fSizeInfo
yuvInfo
.
fYUVAIndices
planes
)
)
{
return
nullptr
;
}
SkYUVPlanesCache
:
:
Add
(
this
-
>
onGetID
(
)
data
.
get
(
)
&
yuvInfo
)
;
}
*
size
=
yuvInfo
.
fSizeInfo
;
memcpy
(
yuvaIndices
yuvInfo
.
fYUVAIndices
sizeof
(
yuvInfo
.
fYUVAIndices
)
)
;
*
colorSpace
=
yuvInfo
.
fColorSpace
;
constPlanes
[
0
]
=
planes
[
0
]
;
constPlanes
[
1
]
=
planes
[
1
]
;
constPlanes
[
2
]
=
planes
[
2
]
;
constPlanes
[
3
]
=
planes
[
3
]
;
return
data
;
}
void
GrYUVProvider
:
:
YUVGen_DataReleaseProc
(
const
void
*
void
*
data
)
{
SkCachedData
*
cachedData
=
static_cast
<
SkCachedData
*
>
(
data
)
;
SkASSERT
(
cachedData
)
;
cachedData
-
>
unref
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrYUVProvider
:
:
refAsTextureProxy
(
GrRecordingContext
*
ctx
const
GrBackendFormat
&
format
const
GrSurfaceDesc
&
desc
SkColorSpace
*
srcColorSpace
SkColorSpace
*
dstColorSpace
)
{
SkYUVASizeInfo
yuvSizeInfo
;
SkYUVAIndex
yuvaIndices
[
SkYUVAIndex
:
:
kIndexCount
]
;
SkYUVColorSpace
yuvColorSpace
;
const
void
*
planes
[
SkYUVASizeInfo
:
:
kMaxCount
]
;
sk_sp
<
SkCachedData
>
dataStorage
=
this
-
>
getPlanes
(
&
yuvSizeInfo
yuvaIndices
&
yuvColorSpace
planes
)
;
if
(
!
dataStorage
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
yuvTextureProxies
[
SkYUVASizeInfo
:
:
kMaxCount
]
;
for
(
int
i
=
0
;
i
<
SkYUVASizeInfo
:
:
kMaxCount
;
+
+
i
)
{
if
(
yuvSizeInfo
.
fSizes
[
i
]
.
isEmpty
(
)
)
{
SkASSERT
(
!
yuvSizeInfo
.
fWidthBytes
[
i
]
)
;
continue
;
}
int
componentWidth
=
yuvSizeInfo
.
fSizes
[
i
]
.
fWidth
;
int
componentHeight
=
yuvSizeInfo
.
fSizes
[
i
]
.
fHeight
;
SkBackingFit
fit
=
(
componentWidth
!
=
yuvSizeInfo
.
fSizes
[
0
]
.
fWidth
)
|
|
(
componentHeight
!
=
yuvSizeInfo
.
fSizes
[
0
]
.
fHeight
)
?
SkBackingFit
:
:
kExact
:
SkBackingFit
:
:
kApprox
;
SkImageInfo
imageInfo
=
SkImageInfo
:
:
MakeA8
(
componentWidth
componentHeight
)
;
SkPixmap
pixmap
(
imageInfo
planes
[
i
]
yuvSizeInfo
.
fWidthBytes
[
i
]
)
;
SkCachedData
*
dataStoragePtr
=
dataStorage
.
get
(
)
;
dataStoragePtr
-
>
ref
(
)
;
sk_sp
<
SkImage
>
yuvImage
=
SkImage
:
:
MakeFromRaster
(
pixmap
YUVGen_DataReleaseProc
dataStoragePtr
)
;
auto
proxyProvider
=
ctx
-
>
priv
(
)
.
proxyProvider
(
)
;
yuvTextureProxies
[
i
]
=
proxyProvider
-
>
createTextureProxy
(
yuvImage
kNone_GrSurfaceFlags
1
SkBudgeted
:
:
kYes
fit
)
;
SkASSERT
(
yuvTextureProxies
[
i
]
-
>
width
(
)
=
=
yuvSizeInfo
.
fSizes
[
i
]
.
fWidth
)
;
SkASSERT
(
yuvTextureProxies
[
i
]
-
>
height
(
)
=
=
yuvSizeInfo
.
fSizes
[
i
]
.
fHeight
)
;
}
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
(
ctx
-
>
priv
(
)
.
makeDeferredRenderTargetContext
(
format
SkBackingFit
:
:
kExact
desc
.
fWidth
desc
.
fHeight
desc
.
fConfig
nullptr
desc
.
fSampleCnt
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
GrPaint
paint
;
auto
yuvToRgbProcessor
=
GrYUVtoRGBEffect
:
:
Make
(
yuvTextureProxies
yuvaIndices
yuvColorSpace
GrSamplerState
:
:
Filter
:
:
kNearest
)
;
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
yuvToRgbProcessor
)
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorConversionProcessor
=
GrColorSpaceXformEffect
:
:
Make
(
srcColorSpace
kOpaque_SkAlphaType
dstColorSpace
kOpaque_SkAlphaType
)
;
if
(
colorConversionProcessor
)
{
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
colorConversionProcessor
)
)
;
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
const
SkRect
r
=
SkRect
:
:
MakeIWH
(
yuvSizeInfo
.
fSizes
[
0
]
.
fWidth
yuvSizeInfo
.
fSizes
[
0
]
.
fHeight
)
;
SkMatrix
m
=
SkEncodedOriginToMatrix
(
yuvSizeInfo
.
fOrigin
r
.
width
(
)
r
.
height
(
)
)
;
renderTargetContext
-
>
drawRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
m
r
)
;
return
renderTargetContext
-
>
asTextureProxyRef
(
)
;
}
