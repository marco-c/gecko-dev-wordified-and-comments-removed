#
include
"
GrYUVProvider
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkCachedData
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkYUVPlanesCache
.
h
"
#
include
"
effects
/
GrSRGBEffect
.
h
"
#
include
"
effects
/
GrYUVEffect
.
h
"
namespace
{
class
YUVScoper
{
public
:
bool
init
(
GrYUVProvider
*
SkYUVPlanesCache
:
:
Info
*
void
*
planes
[
3
]
bool
useCache
)
;
private
:
sk_sp
<
SkCachedData
>
fCachedData
;
SkAutoMalloc
fStorage
;
}
;
}
bool
YUVScoper
:
:
init
(
GrYUVProvider
*
provider
SkYUVPlanesCache
:
:
Info
*
yuvInfo
void
*
planes
[
3
]
bool
useCache
)
{
if
(
useCache
)
{
fCachedData
.
reset
(
SkYUVPlanesCache
:
:
FindAndRef
(
provider
-
>
onGetID
(
)
yuvInfo
)
)
;
}
if
(
fCachedData
.
get
(
)
)
{
planes
[
0
]
=
(
void
*
)
fCachedData
-
>
data
(
)
;
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
}
else
{
if
(
!
provider
-
>
onQueryYUV8
(
&
yuvInfo
-
>
fSizeInfo
&
yuvInfo
-
>
fColorSpace
)
)
{
return
false
;
}
size_t
totalSize
(
0
)
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
totalSize
+
=
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
i
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
}
if
(
useCache
)
{
fCachedData
.
reset
(
SkResourceCache
:
:
NewCachedData
(
totalSize
)
)
;
planes
[
0
]
=
fCachedData
-
>
writable_data
(
)
;
}
else
{
fStorage
.
reset
(
totalSize
)
;
planes
[
0
]
=
fStorage
.
get
(
)
;
}
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
-
>
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
-
>
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
if
(
!
provider
-
>
onGetYUV8Planes
(
yuvInfo
-
>
fSizeInfo
planes
)
)
{
return
false
;
}
if
(
useCache
)
{
SkYUVPlanesCache
:
:
Add
(
provider
-
>
onGetID
(
)
fCachedData
.
get
(
)
yuvInfo
)
;
}
}
return
true
;
}
sk_sp
<
GrTextureProxy
>
GrYUVProvider
:
:
refAsTextureProxy
(
GrContext
*
ctx
const
GrSurfaceDesc
&
desc
bool
useCache
)
{
SkYUVPlanesCache
:
:
Info
yuvInfo
;
void
*
planes
[
3
]
;
YUVScoper
scoper
;
if
(
!
scoper
.
init
(
this
&
yuvInfo
planes
useCache
)
)
{
return
nullptr
;
}
GrSurfaceDesc
yuvDesc
;
yuvDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
yuvDesc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
sk_sp
<
GrSurfaceContext
>
yuvTextureContexts
[
3
]
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
yuvDesc
.
fWidth
=
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fWidth
;
yuvDesc
.
fHeight
=
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
SkBackingFit
fit
=
(
yuvDesc
.
fWidth
!
=
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
)
|
|
(
yuvDesc
.
fHeight
!
=
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
?
SkBackingFit
:
:
kExact
:
SkBackingFit
:
:
kApprox
;
yuvTextureContexts
[
i
]
=
ctx
-
>
contextPriv
(
)
.
makeDeferredSurfaceContext
(
yuvDesc
fit
SkBudgeted
:
:
kYes
)
;
if
(
!
yuvTextureContexts
[
i
]
)
{
return
nullptr
;
}
const
SkImageInfo
ii
=
SkImageInfo
:
:
MakeA8
(
yuvDesc
.
fWidth
yuvDesc
.
fHeight
)
;
if
(
!
yuvTextureContexts
[
i
]
-
>
writePixels
(
ii
planes
[
i
]
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
0
0
)
)
{
return
nullptr
;
}
}
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
(
ctx
-
>
makeRenderTargetContext
(
SkBackingFit
:
:
kExact
desc
.
fWidth
desc
.
fHeight
desc
.
fConfig
nullptr
desc
.
fSampleCnt
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
GrPaint
paint
;
sk_sp
<
GrFragmentProcessor
>
yuvToRgbProcessor
(
GrYUVEffect
:
:
MakeYUVToRGB
(
ctx
-
>
resourceProvider
(
)
yuvTextureContexts
[
0
]
-
>
asTextureProxyRef
(
)
yuvTextureContexts
[
1
]
-
>
asTextureProxyRef
(
)
yuvTextureContexts
[
2
]
-
>
asTextureProxyRef
(
)
yuvInfo
.
fSizeInfo
.
fSizes
yuvInfo
.
fColorSpace
false
)
)
;
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
yuvToRgbProcessor
)
)
;
if
(
GrPixelConfigIsSRGB
(
desc
.
fConfig
)
)
{
if
(
ctx
-
>
caps
(
)
-
>
srgbWriteControl
(
)
)
{
paint
.
setDisableOutputConversionToSRGB
(
true
)
;
}
else
{
paint
.
addColorFragmentProcessor
(
GrSRGBEffect
:
:
Make
(
GrSRGBEffect
:
:
Mode
:
:
kSRGBToLinear
)
)
;
}
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
const
SkRect
r
=
SkRect
:
:
MakeIWH
(
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
renderTargetContext
-
>
drawRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
)
;
return
renderTargetContext
-
>
asTextureProxyRef
(
)
;
}
