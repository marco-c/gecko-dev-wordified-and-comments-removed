#
include
"
GrYUVProvider
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkCachedData
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkYUVPlanesCache
.
h
"
#
include
"
SkYUVAIndex
.
h
"
#
include
"
effects
/
GrYUVtoRGBEffect
.
h
"
sk_sp
<
SkCachedData
>
GrYUVProvider
:
:
getPlanes
(
SkYUVSizeInfo
*
size
SkYUVColorSpace
*
colorSpace
const
void
*
constPlanes
[
3
]
)
{
sk_sp
<
SkCachedData
>
data
;
SkYUVPlanesCache
:
:
Info
yuvInfo
;
data
.
reset
(
SkYUVPlanesCache
:
:
FindAndRef
(
this
-
>
onGetID
(
)
&
yuvInfo
)
)
;
void
*
planes
[
3
]
;
if
(
data
.
get
(
)
)
{
planes
[
0
]
=
(
void
*
)
data
-
>
data
(
)
;
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
}
else
{
if
(
!
this
-
>
onQueryYUV8
(
&
yuvInfo
.
fSizeInfo
&
yuvInfo
.
fColorSpace
)
)
{
return
nullptr
;
}
size_t
totalSize
(
0
)
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
totalSize
+
=
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
i
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
i
]
.
fHeight
;
}
data
.
reset
(
SkResourceCache
:
:
NewCachedData
(
totalSize
)
)
;
planes
[
0
]
=
data
-
>
writable_data
(
)
;
planes
[
1
]
=
(
uint8_t
*
)
planes
[
0
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kY
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
planes
[
2
]
=
(
uint8_t
*
)
planes
[
1
]
+
(
yuvInfo
.
fSizeInfo
.
fWidthBytes
[
SkYUVSizeInfo
:
:
kU
]
*
yuvInfo
.
fSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kU
]
.
fHeight
)
;
if
(
!
this
-
>
onGetYUV8Planes
(
yuvInfo
.
fSizeInfo
planes
)
)
{
return
nullptr
;
}
SkYUVPlanesCache
:
:
Add
(
this
-
>
onGetID
(
)
data
.
get
(
)
&
yuvInfo
)
;
}
*
size
=
yuvInfo
.
fSizeInfo
;
*
colorSpace
=
yuvInfo
.
fColorSpace
;
constPlanes
[
0
]
=
planes
[
0
]
;
constPlanes
[
1
]
=
planes
[
1
]
;
constPlanes
[
2
]
=
planes
[
2
]
;
return
data
;
}
void
GrYUVProvider
:
:
YUVGen_DataReleaseProc
(
const
void
*
void
*
data
)
{
SkCachedData
*
cachedData
=
static_cast
<
SkCachedData
*
>
(
data
)
;
SkASSERT
(
cachedData
)
;
cachedData
-
>
unref
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrYUVProvider
:
:
refAsTextureProxy
(
GrContext
*
ctx
const
GrSurfaceDesc
&
desc
SkColorSpace
*
srcColorSpace
SkColorSpace
*
dstColorSpace
)
{
SkYUVSizeInfo
yuvSizeInfo
;
SkYUVColorSpace
yuvColorSpace
;
const
void
*
planes
[
3
]
;
sk_sp
<
SkCachedData
>
dataStorage
=
this
-
>
getPlanes
(
&
yuvSizeInfo
&
yuvColorSpace
planes
)
;
if
(
!
dataStorage
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
yuvTextureProxies
[
3
]
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
int
componentWidth
=
yuvSizeInfo
.
fSizes
[
i
]
.
fWidth
;
int
componentHeight
=
yuvSizeInfo
.
fSizes
[
i
]
.
fHeight
;
SkBackingFit
fit
=
(
componentWidth
!
=
yuvSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
)
|
|
(
componentHeight
!
=
yuvSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
?
SkBackingFit
:
:
kExact
:
SkBackingFit
:
:
kApprox
;
SkImageInfo
imageInfo
=
SkImageInfo
:
:
MakeA8
(
componentWidth
componentHeight
)
;
SkPixmap
pixmap
(
imageInfo
planes
[
i
]
yuvSizeInfo
.
fWidthBytes
[
i
]
)
;
SkCachedData
*
dataStoragePtr
=
dataStorage
.
get
(
)
;
dataStoragePtr
-
>
ref
(
)
;
sk_sp
<
SkImage
>
yuvImage
=
SkImage
:
:
MakeFromRaster
(
pixmap
YUVGen_DataReleaseProc
dataStoragePtr
)
;
auto
proxyProvider
=
ctx
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
yuvTextureProxies
[
i
]
=
proxyProvider
-
>
createTextureProxy
(
yuvImage
kNone_GrSurfaceFlags
1
SkBudgeted
:
:
kYes
fit
)
;
SkASSERT
(
yuvTextureProxies
[
i
]
-
>
width
(
)
=
=
yuvSizeInfo
.
fSizes
[
i
]
.
fWidth
)
;
SkASSERT
(
yuvTextureProxies
[
i
]
-
>
height
(
)
=
=
yuvSizeInfo
.
fSizes
[
i
]
.
fHeight
)
;
}
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
(
ctx
-
>
contextPriv
(
)
.
makeDeferredRenderTargetContext
(
SkBackingFit
:
:
kExact
desc
.
fWidth
desc
.
fHeight
desc
.
fConfig
nullptr
desc
.
fSampleCnt
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
SkYUVAIndex
yuvaIndices
[
4
]
=
{
{
0
SkColorChannel
:
:
kA
}
{
1
SkColorChannel
:
:
kA
}
{
2
SkColorChannel
:
:
kA
}
{
-
1
SkColorChannel
:
:
kA
}
}
;
GrPaint
paint
;
auto
yuvToRgbProcessor
=
GrYUVtoRGBEffect
:
:
Make
(
yuvTextureProxies
yuvaIndices
yuvColorSpace
)
;
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
yuvToRgbProcessor
)
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorConversionProcessor
=
GrColorSpaceXformEffect
:
:
Make
(
srcColorSpace
kOpaque_SkAlphaType
dstColorSpace
kOpaque_SkAlphaType
)
;
if
(
colorConversionProcessor
)
{
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
colorConversionProcessor
)
)
;
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
const
SkRect
r
=
SkRect
:
:
MakeIWH
(
yuvSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fWidth
yuvSizeInfo
.
fSizes
[
SkYUVSizeInfo
:
:
kY
]
.
fHeight
)
;
renderTargetContext
-
>
drawRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
)
;
return
renderTargetContext
-
>
asTextureProxyRef
(
)
;
}
