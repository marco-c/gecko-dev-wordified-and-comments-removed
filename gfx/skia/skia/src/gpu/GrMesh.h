#
ifndef
GrMesh_DEFINED
#
define
GrMesh_DEFINED
#
include
"
GrBuffer
.
h
"
#
include
"
GrGpuResourceRef
.
h
"
class
GrNonInstancedMesh
{
public
:
GrPrimitiveType
primitiveType
(
)
const
{
return
fPrimitiveType
;
}
int
startVertex
(
)
const
{
return
fStartVertex
;
}
int
startIndex
(
)
const
{
return
fStartIndex
;
}
int
vertexCount
(
)
const
{
return
fVertexCount
;
}
int
indexCount
(
)
const
{
return
fIndexCount
;
}
bool
isIndexed
(
)
const
{
return
fIndexCount
>
0
;
}
const
GrBuffer
*
vertexBuffer
(
)
const
{
return
fVertexBuffer
.
get
(
)
;
}
const
GrBuffer
*
indexBuffer
(
)
const
{
return
fIndexBuffer
.
get
(
)
;
}
protected
:
GrPrimitiveType
fPrimitiveType
;
int
fStartVertex
;
int
fStartIndex
;
int
fVertexCount
;
int
fIndexCount
;
GrPendingIOResource
<
const
GrBuffer
kRead_GrIOType
>
fVertexBuffer
;
GrPendingIOResource
<
const
GrBuffer
kRead_GrIOType
>
fIndexBuffer
;
friend
class
GrMesh
;
}
;
class
GrMesh
:
public
GrNonInstancedMesh
{
public
:
GrMesh
(
)
{
}
GrMesh
(
const
GrMesh
&
di
)
{
(
*
this
)
=
di
;
}
GrMesh
&
operator
=
(
const
GrMesh
&
di
)
;
void
init
(
GrPrimitiveType
primType
const
GrBuffer
*
vertexBuffer
int
startVertex
int
vertexCount
)
{
SkASSERT
(
vertexBuffer
)
;
SkASSERT
(
vertexCount
)
;
SkASSERT
(
startVertex
>
=
0
)
;
fPrimitiveType
=
primType
;
fVertexBuffer
.
reset
(
vertexBuffer
)
;
fIndexBuffer
.
reset
(
nullptr
)
;
fStartVertex
=
startVertex
;
fStartIndex
=
0
;
fVertexCount
=
vertexCount
;
fIndexCount
=
0
;
fInstanceCount
=
0
;
fVerticesPerInstance
=
0
;
fIndicesPerInstance
=
0
;
fMaxInstancesPerDraw
=
0
;
}
void
initIndexed
(
GrPrimitiveType
primType
const
GrBuffer
*
vertexBuffer
const
GrBuffer
*
indexBuffer
int
startVertex
int
startIndex
int
vertexCount
int
indexCount
)
{
SkASSERT
(
indexBuffer
)
;
SkASSERT
(
vertexBuffer
)
;
SkASSERT
(
indexCount
)
;
SkASSERT
(
vertexCount
)
;
SkASSERT
(
startIndex
>
=
0
)
;
SkASSERT
(
startVertex
>
=
0
)
;
fPrimitiveType
=
primType
;
fVertexBuffer
.
reset
(
vertexBuffer
)
;
fIndexBuffer
.
reset
(
indexBuffer
)
;
fStartVertex
=
startVertex
;
fStartIndex
=
startIndex
;
fVertexCount
=
vertexCount
;
fIndexCount
=
indexCount
;
fInstanceCount
=
0
;
fVerticesPerInstance
=
0
;
fIndicesPerInstance
=
0
;
fMaxInstancesPerDraw
=
0
;
}
void
initInstanced
(
GrPrimitiveType
primType
const
GrBuffer
*
vertexBuffer
const
GrBuffer
*
indexBuffer
int
startVertex
int
verticesPerInstance
int
indicesPerInstance
int
instanceCount
int
maxInstancesPerDraw
)
{
SkASSERT
(
vertexBuffer
)
;
SkASSERT
(
indexBuffer
)
;
SkASSERT
(
instanceCount
)
;
SkASSERT
(
verticesPerInstance
)
;
SkASSERT
(
indicesPerInstance
)
;
SkASSERT
(
startVertex
>
=
0
)
;
fPrimitiveType
=
primType
;
fVertexBuffer
.
reset
(
vertexBuffer
)
;
fIndexBuffer
.
reset
(
indexBuffer
)
;
fStartVertex
=
startVertex
;
fStartIndex
=
0
;
fVerticesPerInstance
=
verticesPerInstance
;
fIndicesPerInstance
=
indicesPerInstance
;
fInstanceCount
=
instanceCount
;
fVertexCount
=
instanceCount
*
fVerticesPerInstance
;
fIndexCount
=
instanceCount
*
fIndicesPerInstance
;
fMaxInstancesPerDraw
=
maxInstancesPerDraw
;
}
int
verticesPerInstance
(
)
const
{
return
fVerticesPerInstance
;
}
int
indicesPerInstance
(
)
const
{
return
fIndicesPerInstance
;
}
int
instanceCount
(
)
const
{
return
fInstanceCount
;
}
bool
isInstanced
(
)
const
{
return
fInstanceCount
>
0
;
}
class
Iterator
{
public
:
const
GrNonInstancedMesh
*
init
(
const
GrMesh
&
mesh
)
{
fMesh
=
&
mesh
;
if
(
mesh
.
fInstanceCount
<
=
mesh
.
fMaxInstancesPerDraw
)
{
fInstancesRemaining
=
0
;
return
&
mesh
;
}
SkASSERT
(
mesh
.
isInstanced
(
)
)
;
fInstanceBatch
.
fIndexBuffer
.
reset
(
mesh
.
fIndexBuffer
.
get
(
)
)
;
fInstanceBatch
.
fVertexBuffer
.
reset
(
mesh
.
fVertexBuffer
.
get
(
)
)
;
fInstanceBatch
.
fIndexCount
=
mesh
.
fMaxInstancesPerDraw
*
mesh
.
fIndicesPerInstance
;
fInstanceBatch
.
fVertexCount
=
mesh
.
fMaxInstancesPerDraw
*
mesh
.
fVerticesPerInstance
;
fInstanceBatch
.
fPrimitiveType
=
mesh
.
fPrimitiveType
;
fInstanceBatch
.
fStartIndex
=
mesh
.
fStartIndex
;
fInstanceBatch
.
fStartVertex
=
mesh
.
fStartVertex
;
fInstancesRemaining
=
mesh
.
fInstanceCount
-
mesh
.
fMaxInstancesPerDraw
;
return
&
fInstanceBatch
;
}
const
GrNonInstancedMesh
*
next
(
)
{
if
(
!
fInstancesRemaining
)
{
return
nullptr
;
}
fInstanceBatch
.
fStartVertex
+
=
fInstanceBatch
.
fVertexCount
;
int
instances
=
SkTMin
(
fInstancesRemaining
fMesh
-
>
fMaxInstancesPerDraw
)
;
fInstanceBatch
.
fIndexCount
=
instances
*
fMesh
-
>
fIndicesPerInstance
;
fInstanceBatch
.
fVertexCount
=
instances
*
fMesh
-
>
fVerticesPerInstance
;
fInstancesRemaining
-
=
instances
;
return
&
fInstanceBatch
;
}
private
:
GrNonInstancedMesh
fInstanceBatch
;
const
GrMesh
*
fMesh
;
int
fInstancesRemaining
;
}
;
private
:
int
fInstanceCount
;
int
fVerticesPerInstance
;
int
fIndicesPerInstance
;
int
fMaxInstancesPerDraw
;
}
;
#
endif
