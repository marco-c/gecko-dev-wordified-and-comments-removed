#
ifndef
GrTextureDomainEffect_DEFINED
#
define
GrTextureDomainEffect_DEFINED
#
include
"
src
/
gpu
/
GrCoordTransform
.
h
"
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrGLProgramBuilder
;
class
GrGLSLShaderBuilder
;
class
GrInvariantOutput
;
class
GrGLSLUniformHandler
;
struct
SkRect
;
class
GrTextureDomain
{
public
:
enum
Mode
{
kIgnore_Mode
kClamp_Mode
kDecal_Mode
kRepeat_Mode
kLastMode
=
kRepeat_Mode
}
;
static
const
int
kModeCount
=
kLastMode
+
1
;
static
const
GrTextureDomain
&
IgnoredDomain
(
)
{
static
const
GrTextureDomain
gDomain
(
(
GrTextureProxy
*
)
nullptr
SkRect
:
:
MakeEmpty
(
)
kIgnore_Mode
kIgnore_Mode
)
;
return
gDomain
;
}
GrTextureDomain
(
GrTextureProxy
*
const
SkRect
&
domain
Mode
modeX
Mode
modeY
int
index
=
-
1
)
;
GrTextureDomain
(
const
GrTextureDomain
&
)
=
default
;
const
SkRect
&
domain
(
)
const
{
return
fDomain
;
}
Mode
modeX
(
)
const
{
return
fModeX
;
}
Mode
modeY
(
)
const
{
return
fModeY
;
}
static
const
SkRect
MakeTexelDomain
(
const
SkIRect
&
texelRect
Mode
mode
)
{
return
MakeTexelDomain
(
texelRect
mode
mode
)
;
}
static
const
SkRect
MakeTexelDomain
(
const
SkIRect
&
texelRect
Mode
modeX
Mode
modeY
)
{
SkScalar
insetX
=
(
(
modeX
=
=
kClamp_Mode
|
|
modeX
=
=
kDecal_Mode
)
&
&
texelRect
.
width
(
)
>
0
)
?
SK_ScalarHalf
:
0
;
SkScalar
insetY
=
(
(
modeY
=
=
kClamp_Mode
|
|
modeY
=
=
kDecal_Mode
)
&
&
texelRect
.
height
(
)
>
0
)
?
SK_ScalarHalf
:
0
;
return
SkRect
:
:
MakeLTRB
(
texelRect
.
fLeft
+
insetX
texelRect
.
fTop
+
insetY
texelRect
.
fRight
-
insetX
texelRect
.
fBottom
-
insetY
)
;
}
static
bool
IsDecalSampled
(
GrSamplerState
:
:
WrapMode
wrapX
GrSamplerState
:
:
WrapMode
wrapY
Mode
modeX
Mode
modeY
)
{
return
wrapX
=
=
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
|
|
wrapY
=
=
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
|
|
modeX
=
=
kDecal_Mode
|
|
modeY
=
=
kDecal_Mode
;
}
static
bool
IsDecalSampled
(
const
GrSamplerState
:
:
WrapMode
wraps
[
2
]
Mode
modeX
Mode
modeY
)
{
return
IsDecalSampled
(
wraps
[
0
]
wraps
[
1
]
modeX
modeY
)
;
}
static
bool
IsDecalSampled
(
const
GrSamplerState
&
sampler
Mode
modeX
Mode
modeY
)
{
return
IsDecalSampled
(
sampler
.
wrapModeX
(
)
sampler
.
wrapModeY
(
)
modeX
modeY
)
;
}
bool
operator
=
=
(
const
GrTextureDomain
&
that
)
const
{
return
fModeX
=
=
that
.
fModeX
&
&
fModeY
=
=
that
.
fModeY
&
&
(
kIgnore_Mode
=
=
fModeX
|
|
(
fDomain
.
fLeft
=
=
that
.
fDomain
.
fLeft
&
&
fDomain
.
fRight
=
=
that
.
fDomain
.
fRight
)
)
&
&
(
kIgnore_Mode
=
=
fModeY
|
|
(
fDomain
.
fTop
=
=
that
.
fDomain
.
fTop
&
&
fDomain
.
fBottom
=
=
that
.
fDomain
.
fBottom
)
)
;
}
class
GLDomain
{
public
:
GLDomain
(
)
{
for
(
int
i
=
0
;
i
<
kPrevDomainCount
;
i
+
+
)
{
fPrevDomain
[
i
]
=
SK_FloatNaN
;
}
}
void
sampleTexture
(
GrGLSLShaderBuilder
*
builder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
shaderCaps
const
GrTextureDomain
&
textureDomain
const
char
*
outColor
const
SkString
&
inCoords
GrGLSLFragmentProcessor
:
:
SamplerHandle
sampler
const
char
*
inModulateColor
=
nullptr
)
;
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrTextureDomain
&
GrTextureProxy
*
const
GrSamplerState
&
sampler
)
;
enum
{
kModeBits
=
2
kDomainKeyBits
=
4
}
;
static
uint32_t
DomainKey
(
const
GrTextureDomain
&
domain
)
{
GR_STATIC_ASSERT
(
kModeCount
<
=
(
1
<
<
kModeBits
)
)
;
return
domain
.
modeX
(
)
|
(
domain
.
modeY
(
)
<
<
kModeBits
)
;
}
private
:
static
const
int
kPrevDomainCount
=
4
;
SkDEBUGCODE
(
Mode
fModeX
;
)
SkDEBUGCODE
(
Mode
fModeY
;
)
SkDEBUGCODE
(
bool
fHasMode
=
false
;
)
GrGLSLProgramDataManager
:
:
UniformHandle
fDomainUni
;
SkString
fDomainName
;
GrGLSLProgramDataManager
:
:
UniformHandle
fDecalUni
;
SkString
fDecalName
;
float
fPrevDomain
[
kPrevDomainCount
]
;
}
;
protected
:
Mode
fModeX
;
Mode
fModeY
;
SkRect
fDomain
;
int
fIndex
;
}
;
class
GrTextureDomainEffect
:
public
GrFragmentProcessor
{
public
:
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
mode
GrSamplerState
:
:
Filter
filterMode
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
const
GrSamplerState
&
sampler
)
;
const
char
*
name
(
)
const
override
{
return
"
TextureDomain
"
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrTextureDomainEffect
(
*
this
)
)
;
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
#
endif
private
:
GrCoordTransform
fCoordTransform
;
GrTextureDomain
fTextureDomain
;
TextureSampler
fTextureSampler
;
GrTextureDomainEffect
(
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
const
GrSamplerState
&
)
;
explicit
GrTextureDomainEffect
(
const
GrTextureDomainEffect
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
class
GrDeviceSpaceTextureDecalFragmentProcessor
:
public
GrFragmentProcessor
{
public
:
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
const
SkIRect
&
subset
const
SkIPoint
&
deviceSpaceOffset
)
;
const
char
*
name
(
)
const
override
{
return
"
GrDeviceSpaceTextureDecalFragmentProcessor
"
;
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
Offset
:
[
%
d
%
d
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
fDeviceSpaceOffset
.
fX
fDeviceSpaceOffset
.
fY
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
#
endif
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
;
private
:
TextureSampler
fTextureSampler
;
GrTextureDomain
fTextureDomain
;
SkIPoint
fDeviceSpaceOffset
;
GrDeviceSpaceTextureDecalFragmentProcessor
(
sk_sp
<
GrTextureProxy
>
const
SkIRect
&
const
SkIPoint
&
)
;
GrDeviceSpaceTextureDecalFragmentProcessor
(
const
GrDeviceSpaceTextureDecalFragmentProcessor
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
{
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
fp
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
