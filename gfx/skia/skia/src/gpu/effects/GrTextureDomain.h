#
ifndef
GrTextureDomainEffect_DEFINED
#
define
GrTextureDomainEffect_DEFINED
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrGLProgramBuilder
;
class
GrGLSLShaderBuilder
;
class
GrInvariantOutput
;
class
GrGLSLUniformHandler
;
struct
SkRect
;
class
GrTextureDomain
{
public
:
enum
Mode
{
kIgnore_Mode
kClamp_Mode
kDecal_Mode
kRepeat_Mode
kLastMode
=
kRepeat_Mode
}
;
static
const
int
kModeCount
=
kLastMode
+
1
;
static
const
GrTextureDomain
&
IgnoredDomain
(
)
{
static
const
GrTextureDomain
gDomain
(
(
GrTextureProxy
*
)
nullptr
SkRect
:
:
MakeEmpty
(
)
kIgnore_Mode
)
;
return
gDomain
;
}
GrTextureDomain
(
GrTextureProxy
*
const
SkRect
&
domain
Mode
int
index
=
-
1
)
;
GrTextureDomain
(
const
GrTextureDomain
&
)
=
default
;
const
SkRect
&
domain
(
)
const
{
return
fDomain
;
}
Mode
mode
(
)
const
{
return
fMode
;
}
static
const
SkRect
MakeTexelDomain
(
const
SkIRect
&
texelRect
)
{
return
SkRect
:
:
Make
(
texelRect
)
;
}
static
const
SkRect
MakeTexelDomainForMode
(
const
SkIRect
&
texelRect
Mode
mode
)
{
SkScalar
inset
=
(
mode
=
=
kClamp_Mode
&
&
!
texelRect
.
isEmpty
(
)
)
?
SK_ScalarHalf
:
0
;
return
SkRect
:
:
MakeLTRB
(
texelRect
.
fLeft
+
inset
texelRect
.
fTop
+
inset
texelRect
.
fRight
-
inset
texelRect
.
fBottom
-
inset
)
;
}
bool
operator
=
=
(
const
GrTextureDomain
&
that
)
const
{
return
fMode
=
=
that
.
fMode
&
&
(
kIgnore_Mode
=
=
fMode
|
|
fDomain
=
=
that
.
fDomain
)
;
}
class
GLDomain
{
public
:
GLDomain
(
)
{
for
(
int
i
=
0
;
i
<
kPrevDomainCount
;
i
+
+
)
{
fPrevDomain
[
i
]
=
SK_FloatNaN
;
}
}
void
sampleTexture
(
GrGLSLShaderBuilder
*
builder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
shaderCaps
const
GrTextureDomain
&
textureDomain
const
char
*
outColor
const
SkString
&
inCoords
GrGLSLFragmentProcessor
:
:
SamplerHandle
sampler
const
char
*
inModulateColor
=
nullptr
)
;
void
setData
(
const
GrGLSLProgramDataManager
&
const
GrTextureDomain
&
GrSurfaceProxy
*
)
;
enum
{
kDomainKeyBits
=
2
}
;
static
uint32_t
DomainKey
(
const
GrTextureDomain
&
domain
)
{
GR_STATIC_ASSERT
(
kModeCount
<
=
(
1
<
<
kDomainKeyBits
)
)
;
return
domain
.
mode
(
)
;
}
private
:
static
const
int
kPrevDomainCount
=
4
;
SkDEBUGCODE
(
Mode
fMode
;
)
SkDEBUGCODE
(
bool
fHasMode
=
false
;
)
GrGLSLProgramDataManager
:
:
UniformHandle
fDomainUni
;
SkString
fDomainName
;
float
fPrevDomain
[
kPrevDomainCount
]
;
}
;
protected
:
Mode
fMode
;
SkRect
fDomain
;
int
fIndex
;
}
;
class
GrTextureDomainEffect
:
public
GrFragmentProcessor
{
public
:
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
GrSamplerState
:
:
Filter
filterMode
)
;
const
char
*
name
(
)
const
override
{
return
"
TextureDomain
"
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrTextureDomainEffect
(
*
this
)
)
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
private
:
GrCoordTransform
fCoordTransform
;
GrTextureDomain
fTextureDomain
;
TextureSampler
fTextureSampler
;
GrTextureDomainEffect
(
sk_sp
<
GrTextureProxy
>
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
GrSamplerState
:
:
Filter
)
;
explicit
GrTextureDomainEffect
(
const
GrTextureDomainEffect
&
)
;
static
OptimizationFlags
OptFlags
(
GrPixelConfig
config
GrTextureDomain
:
:
Mode
mode
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
class
GrDeviceSpaceTextureDecalFragmentProcessor
:
public
GrFragmentProcessor
{
public
:
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
const
SkIRect
&
subset
const
SkIPoint
&
deviceSpaceOffset
)
;
const
char
*
name
(
)
const
override
{
return
"
GrDeviceSpaceTextureDecalFragmentProcessor
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
Offset
:
[
%
d
%
d
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
fDeviceSpaceOffset
.
fX
fDeviceSpaceOffset
.
fY
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
;
private
:
TextureSampler
fTextureSampler
;
GrTextureDomain
fTextureDomain
;
SkIPoint
fDeviceSpaceOffset
;
GrDeviceSpaceTextureDecalFragmentProcessor
(
sk_sp
<
GrTextureProxy
>
const
SkIRect
&
const
SkIPoint
&
)
;
GrDeviceSpaceTextureDecalFragmentProcessor
(
const
GrDeviceSpaceTextureDecalFragmentProcessor
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
{
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
fp
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
