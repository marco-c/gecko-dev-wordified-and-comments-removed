#
ifndef
GrTextureDomainEffect_DEFINED
#
define
GrTextureDomainEffect_DEFINED
#
include
"
GrSingleTextureEffect
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrGLProgramBuilder
;
class
GrGLSLShaderBuilder
;
class
GrInvariantOutput
;
class
GrGLSLSampler
;
class
GrGLSLUniformHandler
;
struct
SkRect
;
class
GrTextureDomain
{
public
:
enum
Mode
{
kIgnore_Mode
kClamp_Mode
kDecal_Mode
kRepeat_Mode
kLastMode
=
kRepeat_Mode
}
;
static
const
int
kModeCount
=
kLastMode
+
1
;
static
const
GrTextureDomain
&
IgnoredDomain
(
)
{
static
const
SkRect
gDummyRect
=
{
0
0
0
0
}
;
static
const
GrTextureDomain
gDomain
(
gDummyRect
kIgnore_Mode
)
;
return
gDomain
;
}
GrTextureDomain
(
const
SkRect
&
domain
Mode
int
index
=
-
1
)
;
const
SkRect
&
domain
(
)
const
{
return
fDomain
;
}
Mode
mode
(
)
const
{
return
fMode
;
}
static
const
SkRect
MakeTexelDomain
(
const
GrTexture
*
texture
const
SkIRect
&
texelRect
)
{
SkScalar
wInv
=
SK_Scalar1
/
texture
-
>
width
(
)
;
SkScalar
hInv
=
SK_Scalar1
/
texture
-
>
height
(
)
;
SkRect
result
=
{
texelRect
.
fLeft
*
wInv
texelRect
.
fTop
*
hInv
texelRect
.
fRight
*
wInv
texelRect
.
fBottom
*
hInv
}
;
return
result
;
}
static
const
SkRect
MakeTexelDomainForMode
(
const
GrTexture
*
texture
const
SkIRect
&
texelRect
Mode
mode
)
{
SkScalar
wInv
=
SK_Scalar1
/
texture
-
>
width
(
)
;
SkScalar
hInv
=
SK_Scalar1
/
texture
-
>
height
(
)
;
SkScalar
inset
=
(
mode
=
=
kClamp_Mode
&
&
!
texelRect
.
isEmpty
(
)
)
?
SK_ScalarHalf
:
0
;
return
SkRect
:
:
MakeLTRB
(
(
texelRect
.
fLeft
+
inset
)
*
wInv
(
texelRect
.
fTop
+
inset
)
*
hInv
(
texelRect
.
fRight
-
inset
)
*
wInv
(
texelRect
.
fBottom
-
inset
)
*
hInv
)
;
}
bool
operator
=
=
(
const
GrTextureDomain
&
that
)
const
{
return
fMode
=
=
that
.
fMode
&
&
(
kIgnore_Mode
=
=
fMode
|
|
fDomain
=
=
that
.
fDomain
)
;
}
class
GLDomain
{
public
:
GLDomain
(
)
{
for
(
int
i
=
0
;
i
<
kPrevDomainCount
;
i
+
+
)
{
fPrevDomain
[
i
]
=
SK_FloatNaN
;
}
SkDEBUGCODE
(
fMode
=
(
Mode
)
-
1
;
)
}
void
sampleTexture
(
GrGLSLShaderBuilder
*
builder
GrGLSLUniformHandler
*
uniformHandler
const
GrGLSLCaps
*
glslCaps
const
GrTextureDomain
&
textureDomain
const
char
*
outColor
const
SkString
&
inCoords
GrGLSLFragmentProcessor
:
:
SamplerHandle
sampler
const
char
*
inModulateColor
=
nullptr
)
;
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrTextureDomain
&
textureDomain
GrSurfaceOrigin
textureOrigin
)
;
enum
{
kDomainKeyBits
=
2
}
;
static
uint32_t
DomainKey
(
const
GrTextureDomain
&
domain
)
{
GR_STATIC_ASSERT
(
kModeCount
<
=
(
1
<
<
kDomainKeyBits
)
)
;
return
domain
.
mode
(
)
;
}
private
:
static
const
int
kPrevDomainCount
=
4
;
SkDEBUGCODE
(
Mode
fMode
;
)
GrGLSLProgramDataManager
:
:
UniformHandle
fDomainUni
;
SkString
fDomainName
;
float
fPrevDomain
[
kPrevDomainCount
]
;
}
;
protected
:
Mode
fMode
;
SkRect
fDomain
;
int
fIndex
;
typedef
GrSingleTextureEffect
INHERITED
;
}
;
class
GrTextureDomainEffect
:
public
GrSingleTextureEffect
{
public
:
static
sk_sp
<
GrFragmentProcessor
>
Make
(
GrTexture
*
sk_sp
<
GrColorSpaceXform
>
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
GrTextureParams
:
:
FilterMode
filterMode
)
;
const
char
*
name
(
)
const
override
{
return
"
TextureDomain
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
private
:
GrTextureDomain
fTextureDomain
;
GrTextureDomainEffect
(
GrTexture
*
sk_sp
<
GrColorSpaceXform
>
const
SkMatrix
&
const
SkRect
&
domain
GrTextureDomain
:
:
Mode
GrTextureParams
:
:
FilterMode
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
void
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
override
;
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
;
typedef
GrSingleTextureEffect
INHERITED
;
}
;
class
GrDeviceSpaceTextureDecalFragmentProcessor
:
public
GrFragmentProcessor
{
public
:
static
sk_sp
<
GrFragmentProcessor
>
Make
(
GrTexture
*
const
SkIRect
&
subset
const
SkIPoint
&
deviceSpaceOffset
)
;
const
char
*
name
(
)
const
override
{
return
"
GrDeviceSpaceTextureDecalFragmentProcessor
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
Domain
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
Offset
:
[
%
d
%
d
]
"
fTextureDomain
.
domain
(
)
.
fLeft
fTextureDomain
.
domain
(
)
.
fTop
fTextureDomain
.
domain
(
)
.
fRight
fTextureDomain
.
domain
(
)
.
fBottom
fDeviceSpaceOffset
.
fX
fDeviceSpaceOffset
.
fY
)
;
str
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
str
;
}
private
:
GrTextureAccess
fTextureAccess
;
GrTextureDomain
fTextureDomain
;
SkIPoint
fDeviceSpaceOffset
;
GrDeviceSpaceTextureDecalFragmentProcessor
(
GrTexture
*
const
SkIRect
&
const
SkIPoint
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
)
const
override
{
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
fp
)
const
override
;
void
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
override
;
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
