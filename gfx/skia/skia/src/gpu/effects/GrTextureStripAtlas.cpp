#
include
"
GrTextureStripAtlas
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSurfaceContext
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkTSearch
.
h
"
#
ifdef
SK_DEBUG
#
define
VALIDATE
this
-
>
validate
(
)
#
else
#
define
VALIDATE
#
endif
class
GrTextureStripAtlas
:
:
Hash
:
public
SkTDynamicHash
<
GrTextureStripAtlas
:
:
AtlasEntry
GrTextureStripAtlas
:
:
Desc
>
{
}
;
int32_t
GrTextureStripAtlas
:
:
gCacheCount
=
0
;
GrTextureStripAtlas
:
:
Hash
*
GrTextureStripAtlas
:
:
gAtlasCache
=
nullptr
;
GrTextureStripAtlas
:
:
Hash
*
GrTextureStripAtlas
:
:
GetCache
(
)
{
if
(
nullptr
=
=
gAtlasCache
)
{
gAtlasCache
=
new
Hash
;
}
return
gAtlasCache
;
}
void
GrTextureStripAtlas
:
:
CleanUp
(
const
GrContext
*
void
*
info
)
{
SkASSERT
(
info
)
;
AtlasEntry
*
entry
=
static_cast
<
AtlasEntry
*
>
(
info
)
;
GetCache
(
)
-
>
remove
(
entry
-
>
fDesc
)
;
delete
entry
;
if
(
0
=
=
GetCache
(
)
-
>
count
(
)
)
{
delete
gAtlasCache
;
gAtlasCache
=
nullptr
;
}
}
GrTextureStripAtlas
*
GrTextureStripAtlas
:
:
GetAtlas
(
const
GrTextureStripAtlas
:
:
Desc
&
desc
)
{
AtlasEntry
*
entry
=
GetCache
(
)
-
>
find
(
desc
)
;
if
(
nullptr
=
=
entry
)
{
entry
=
new
AtlasEntry
;
entry
-
>
fAtlas
=
new
GrTextureStripAtlas
(
desc
)
;
entry
-
>
fDesc
=
desc
;
desc
.
fContext
-
>
addCleanUp
(
CleanUp
entry
)
;
GetCache
(
)
-
>
add
(
entry
)
;
}
return
entry
-
>
fAtlas
;
}
GrTextureStripAtlas
:
:
GrTextureStripAtlas
(
GrTextureStripAtlas
:
:
Desc
desc
)
:
fCacheKey
(
sk_atomic_inc
(
&
gCacheCount
)
)
fLockedRows
(
0
)
fDesc
(
desc
)
fNumRows
(
desc
.
fHeight
/
desc
.
fRowHeight
)
fRows
(
new
AtlasRow
[
fNumRows
]
)
fLRUFront
(
nullptr
)
fLRUBack
(
nullptr
)
{
SkASSERT
(
fNumRows
*
fDesc
.
fRowHeight
=
=
fDesc
.
fHeight
)
;
this
-
>
initLRU
(
)
;
fNormalizedYHeight
=
SK_Scalar1
/
fDesc
.
fHeight
;
VALIDATE
;
}
GrTextureStripAtlas
:
:
~
GrTextureStripAtlas
(
)
{
delete
[
]
fRows
;
}
int
GrTextureStripAtlas
:
:
lockRow
(
const
SkBitmap
&
bitmap
)
{
VALIDATE
;
if
(
0
=
=
fLockedRows
)
{
this
-
>
lockTexture
(
)
;
if
(
!
fTexContext
)
{
return
-
1
;
}
}
int
key
=
bitmap
.
getGenerationID
(
)
;
int
rowNumber
=
-
1
;
int
index
=
this
-
>
searchByKey
(
key
)
;
if
(
index
>
=
0
)
{
AtlasRow
*
row
=
fKeyTable
[
index
]
;
if
(
0
=
=
row
-
>
fLocks
)
{
this
-
>
removeFromLRU
(
row
)
;
}
+
+
row
-
>
fLocks
;
+
+
fLockedRows
;
rowNumber
=
static_cast
<
int
>
(
row
-
fRows
)
;
}
else
{
index
=
~
index
;
AtlasRow
*
row
=
this
-
>
getLRU
(
)
;
+
+
fLockedRows
;
if
(
nullptr
=
=
row
)
{
fDesc
.
fContext
-
>
contextPriv
(
)
.
flush
(
nullptr
)
;
row
=
this
-
>
getLRU
(
)
;
if
(
nullptr
=
=
row
)
{
-
-
fLockedRows
;
return
-
1
;
}
}
this
-
>
removeFromLRU
(
row
)
;
uint32_t
oldKey
=
row
-
>
fKey
;
if
(
oldKey
!
=
kEmptyAtlasRowKey
)
{
int
oldIndex
=
this
-
>
searchByKey
(
oldKey
)
;
if
(
oldIndex
<
index
)
{
-
-
index
;
}
fKeyTable
.
remove
(
oldIndex
)
;
}
row
-
>
fKey
=
key
;
row
-
>
fLocks
=
1
;
fKeyTable
.
insert
(
index
1
&
row
)
;
rowNumber
=
static_cast
<
int
>
(
row
-
fRows
)
;
SkAutoLockPixels
lock
(
bitmap
)
;
SkASSERT
(
bitmap
.
width
(
)
=
=
fDesc
.
fWidth
)
;
SkASSERT
(
bitmap
.
height
(
)
=
=
fDesc
.
fRowHeight
)
;
fTexContext
-
>
writePixels
(
bitmap
.
info
(
)
bitmap
.
getPixels
(
)
bitmap
.
rowBytes
(
)
0
rowNumber
*
fDesc
.
fRowHeight
GrContextPriv
:
:
kDontFlush_PixelOpsFlag
)
;
}
SkASSERT
(
rowNumber
>
=
0
)
;
VALIDATE
;
return
rowNumber
;
}
sk_sp
<
GrTextureProxy
>
GrTextureStripAtlas
:
:
asTextureProxyRef
(
)
const
{
return
fTexContext
-
>
asTextureProxyRef
(
)
;
}
void
GrTextureStripAtlas
:
:
unlockRow
(
int
row
)
{
VALIDATE
;
-
-
fRows
[
row
]
.
fLocks
;
-
-
fLockedRows
;
SkASSERT
(
fRows
[
row
]
.
fLocks
>
=
0
&
&
fLockedRows
>
=
0
)
;
if
(
0
=
=
fRows
[
row
]
.
fLocks
)
{
this
-
>
appendLRU
(
fRows
+
row
)
;
}
if
(
0
=
=
fLockedRows
)
{
this
-
>
unlockTexture
(
)
;
}
VALIDATE
;
}
GrTextureStripAtlas
:
:
AtlasRow
*
GrTextureStripAtlas
:
:
getLRU
(
)
{
AtlasRow
*
row
=
fLRUFront
;
return
row
;
}
void
GrTextureStripAtlas
:
:
lockTexture
(
)
{
GrSurfaceDesc
texDesc
;
texDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
texDesc
.
fWidth
=
fDesc
.
fWidth
;
texDesc
.
fHeight
=
fDesc
.
fHeight
;
texDesc
.
fConfig
=
fDesc
.
fConfig
;
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
key
;
GrUniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
)
;
builder
[
0
]
=
static_cast
<
uint32_t
>
(
fCacheKey
)
;
builder
.
finish
(
)
;
sk_sp
<
GrTextureProxy
>
proxy
=
fDesc
.
fContext
-
>
resourceProvider
(
)
-
>
findProxyByUniqueKey
(
key
)
;
if
(
!
proxy
)
{
proxy
=
GrSurfaceProxy
:
:
MakeDeferred
(
fDesc
.
fContext
-
>
resourceProvider
(
)
texDesc
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kYes
GrResourceProvider
:
:
kNoPendingIO_Flag
)
;
if
(
!
proxy
)
{
return
;
}
fDesc
.
fContext
-
>
resourceProvider
(
)
-
>
assignUniqueKeyToProxy
(
key
proxy
.
get
(
)
)
;
this
-
>
initLRU
(
)
;
fKeyTable
.
rewind
(
)
;
}
SkASSERT
(
proxy
)
;
fTexContext
=
fDesc
.
fContext
-
>
contextPriv
(
)
.
makeWrappedSurfaceContext
(
std
:
:
move
(
proxy
)
nullptr
)
;
}
void
GrTextureStripAtlas
:
:
unlockTexture
(
)
{
SkASSERT
(
fTexContext
&
&
0
=
=
fLockedRows
)
;
fTexContext
.
reset
(
)
;
}
void
GrTextureStripAtlas
:
:
initLRU
(
)
{
fLRUFront
=
nullptr
;
fLRUBack
=
nullptr
;
for
(
int
i
=
0
;
i
<
fNumRows
;
+
+
i
)
{
fRows
[
i
]
.
fKey
=
kEmptyAtlasRowKey
;
fRows
[
i
]
.
fNext
=
nullptr
;
fRows
[
i
]
.
fPrev
=
nullptr
;
this
-
>
appendLRU
(
fRows
+
i
)
;
}
SkASSERT
(
nullptr
=
=
fLRUFront
|
|
nullptr
=
=
fLRUFront
-
>
fPrev
)
;
SkASSERT
(
nullptr
=
=
fLRUBack
|
|
nullptr
=
=
fLRUBack
-
>
fNext
)
;
}
void
GrTextureStripAtlas
:
:
appendLRU
(
AtlasRow
*
row
)
{
SkASSERT
(
nullptr
=
=
row
-
>
fPrev
&
&
nullptr
=
=
row
-
>
fNext
)
;
if
(
nullptr
=
=
fLRUFront
&
&
nullptr
=
=
fLRUBack
)
{
fLRUFront
=
row
;
fLRUBack
=
row
;
}
else
{
row
-
>
fPrev
=
fLRUBack
;
fLRUBack
-
>
fNext
=
row
;
fLRUBack
=
row
;
}
}
void
GrTextureStripAtlas
:
:
removeFromLRU
(
AtlasRow
*
row
)
{
SkASSERT
(
row
)
;
if
(
row
-
>
fNext
&
&
row
-
>
fPrev
)
{
row
-
>
fPrev
-
>
fNext
=
row
-
>
fNext
;
row
-
>
fNext
-
>
fPrev
=
row
-
>
fPrev
;
}
else
{
if
(
nullptr
=
=
row
-
>
fNext
)
{
SkASSERT
(
row
=
=
fLRUBack
)
;
fLRUBack
=
row
-
>
fPrev
;
if
(
fLRUBack
)
{
fLRUBack
-
>
fNext
=
nullptr
;
}
}
if
(
nullptr
=
=
row
-
>
fPrev
)
{
SkASSERT
(
row
=
=
fLRUFront
)
;
fLRUFront
=
row
-
>
fNext
;
if
(
fLRUFront
)
{
fLRUFront
-
>
fPrev
=
nullptr
;
}
}
}
row
-
>
fNext
=
nullptr
;
row
-
>
fPrev
=
nullptr
;
}
int
GrTextureStripAtlas
:
:
searchByKey
(
uint32_t
key
)
{
AtlasRow
target
;
target
.
fKey
=
key
;
return
SkTSearch
<
const
AtlasRow
GrTextureStripAtlas
:
:
KeyLess
>
(
(
const
AtlasRow
*
*
)
fKeyTable
.
begin
(
)
fKeyTable
.
count
(
)
&
target
sizeof
(
AtlasRow
*
)
)
;
}
#
ifdef
SK_DEBUG
void
GrTextureStripAtlas
:
:
validate
(
)
{
uint32_t
prev
=
1
>
fKeyTable
.
count
(
)
?
0
:
fKeyTable
[
0
]
-
>
fKey
;
for
(
int
i
=
1
;
i
<
fKeyTable
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
prev
<
fKeyTable
[
i
]
-
>
fKey
)
;
SkASSERT
(
fKeyTable
[
i
]
-
>
fKey
!
=
kEmptyAtlasRowKey
)
;
prev
=
fKeyTable
[
i
]
-
>
fKey
;
}
int
lruCount
=
0
;
SkASSERT
(
nullptr
=
=
fLRUFront
|
|
nullptr
=
=
fLRUFront
-
>
fPrev
)
;
SkASSERT
(
nullptr
=
=
fLRUBack
|
|
nullptr
=
=
fLRUBack
-
>
fNext
)
;
for
(
AtlasRow
*
r
=
fLRUFront
;
r
!
=
nullptr
;
r
=
r
-
>
fNext
)
{
if
(
nullptr
=
=
r
-
>
fNext
)
{
SkASSERT
(
r
=
=
fLRUBack
)
;
}
else
{
SkASSERT
(
r
-
>
fNext
-
>
fPrev
=
=
r
)
;
}
+
+
lruCount
;
}
int
rowLocks
=
0
;
int
freeRows
=
0
;
for
(
int
i
=
0
;
i
<
fNumRows
;
+
+
i
)
{
rowLocks
+
=
fRows
[
i
]
.
fLocks
;
if
(
0
=
=
fRows
[
i
]
.
fLocks
)
{
+
+
freeRows
;
bool
inLRU
=
false
;
for
(
AtlasRow
*
r
=
fLRUFront
;
r
!
=
nullptr
;
r
=
r
-
>
fNext
)
{
if
(
r
=
=
&
fRows
[
i
]
)
{
inLRU
=
true
;
break
;
}
}
SkASSERT
(
inLRU
)
;
}
else
{
SkASSERT
(
kEmptyAtlasRowKey
!
=
fRows
[
i
]
.
fKey
)
;
}
SkASSERT
(
fRows
[
i
]
.
fKey
=
=
kEmptyAtlasRowKey
|
|
this
-
>
searchByKey
(
fRows
[
i
]
.
fKey
)
>
=
0
)
;
}
SkASSERT
(
rowLocks
=
=
fLockedRows
|
|
rowLocks
+
1
=
=
fLockedRows
)
;
SkASSERT
(
freeRows
=
=
lruCount
)
;
if
(
fLockedRows
=
=
0
)
{
SkASSERT
(
!
fTexContext
)
;
}
else
{
SkASSERT
(
fTexContext
)
;
}
}
#
endif
