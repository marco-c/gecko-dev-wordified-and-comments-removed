#
ifndef
GrGaussianConvolutionFragmentProcessor_DEFINED
#
define
GrGaussianConvolutionFragmentProcessor_DEFINED
#
include
"
src
/
gpu
/
GrCoordTransform
.
h
"
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrTextureDomain
.
h
"
class
GrGaussianConvolutionFragmentProcessor
:
public
GrFragmentProcessor
{
public
:
enum
class
Direction
{
kX
kY
}
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
Direction
dir
int
halfWidth
float
gaussianSigma
GrTextureDomain
:
:
Mode
mode
int
*
bounds
)
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrGaussianConvolutionFragmentProcessor
(
std
:
:
move
(
proxy
)
srcColorType
dir
halfWidth
gaussianSigma
mode
bounds
)
)
;
}
const
float
*
kernel
(
)
const
{
return
fKernel
;
}
const
int
*
bounds
(
)
const
{
return
fBounds
;
}
bool
useBounds
(
)
const
{
return
fMode
!
=
GrTextureDomain
:
:
kIgnore_Mode
;
}
int
radius
(
)
const
{
return
fRadius
;
}
int
width
(
)
const
{
return
2
*
fRadius
+
1
;
}
Direction
direction
(
)
const
{
return
fDirection
;
}
GrTextureDomain
:
:
Mode
mode
(
)
const
{
return
fMode
;
}
const
char
*
name
(
)
const
override
{
return
"
GaussianConvolution
"
;
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
override
{
SkString
str
;
str
.
appendf
(
"
dir
:
%
s
radius
:
%
d
bounds
:
[
%
d
%
d
]
"
Direction
:
:
kX
=
=
fDirection
?
"
X
"
:
"
Y
"
fRadius
fBounds
[
0
]
fBounds
[
1
]
)
;
return
str
;
}
#
endif
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrGaussianConvolutionFragmentProcessor
(
*
this
)
)
;
}
static
const
int
kMaxKernelRadius
=
12
;
static
const
int
kMaxKernelWidth
=
2
*
kMaxKernelRadius
+
1
;
private
:
GrGaussianConvolutionFragmentProcessor
(
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
Direction
int
halfWidth
float
gaussianSigma
GrTextureDomain
:
:
Mode
mode
int
bounds
[
2
]
)
;
explicit
GrGaussianConvolutionFragmentProcessor
(
const
GrGaussianConvolutionFragmentProcessor
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
GrCoordTransform
fCoordTransform
;
TextureSampler
fTextureSampler
;
float
fKernel
[
kMaxKernelWidth
]
;
int
fBounds
[
2
]
;
int
fRadius
;
Direction
fDirection
;
GrTextureDomain
:
:
Mode
fMode
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
