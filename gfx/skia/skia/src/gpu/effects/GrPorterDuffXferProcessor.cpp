#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
GrBlend
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrProcOptInfo
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
glsl
/
GrGLSLBlend
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
glsl
/
GrGLSLXferProcessor
.
h
"
#
include
<
utility
>
struct
BlendFormula
{
public
:
enum
OutputType
{
kNone_OutputType
kCoverage_OutputType
kModulate_OutputType
kSAModulate_OutputType
kISAModulate_OutputType
kISCModulate_OutputType
kLast_OutputType
=
kISCModulate_OutputType
}
;
enum
Properties
{
kModifiesDst_Property
=
1
kUsesDstColor_Property
=
1
<
<
1
kUsesInputColor_Property
=
1
<
<
2
kCanTweakAlphaForCoverage_Property
=
1
<
<
3
kLast_Property
=
kCanTweakAlphaForCoverage_Property
}
;
BlendFormula
&
operator
=
(
const
BlendFormula
&
other
)
{
fData
=
other
.
fData
;
return
*
this
;
}
bool
operator
=
=
(
const
BlendFormula
&
other
)
const
{
return
fData
=
=
other
.
fData
;
}
bool
hasSecondaryOutput
(
)
const
{
return
kNone_OutputType
!
=
fSecondaryOutputType
;
}
bool
modifiesDst
(
)
const
{
return
SkToBool
(
fProps
&
kModifiesDst_Property
)
;
}
bool
usesDstColor
(
)
const
{
return
SkToBool
(
fProps
&
kUsesDstColor_Property
)
;
}
bool
usesInputColor
(
)
const
{
return
SkToBool
(
fProps
&
kUsesInputColor_Property
)
;
}
bool
canTweakAlphaForCoverage
(
)
const
{
return
SkToBool
(
fProps
&
kCanTweakAlphaForCoverage_Property
)
;
}
template
<
OutputType
PrimaryOut
OutputType
SecondaryOut
GrBlendEquation
BlendEquation
GrBlendCoeff
SrcCoeff
GrBlendCoeff
DstCoeff
>
struct
get_properties
:
std
:
:
integral_constant
<
Properties
static_cast
<
Properties
>
(
(
GR_BLEND_MODIFIES_DST
(
BlendEquation
SrcCoeff
DstCoeff
)
?
kModifiesDst_Property
:
0
)
|
(
GR_BLEND_COEFFS_USE_DST_COLOR
(
SrcCoeff
DstCoeff
)
?
kUsesDstColor_Property
:
0
)
|
(
(
PrimaryOut
>
=
kModulate_OutputType
&
&
GR_BLEND_COEFFS_USE_SRC_COLOR
(
SrcCoeff
DstCoeff
)
)
|
|
(
SecondaryOut
>
=
kModulate_OutputType
&
&
GR_BLEND_COEFF_REFS_SRC2
(
DstCoeff
)
)
?
kUsesInputColor_Property
:
0
)
|
(
kModulate_OutputType
=
=
PrimaryOut
&
&
kNone_OutputType
=
=
SecondaryOut
&
&
GR_BLEND_CAN_TWEAK_ALPHA_FOR_COVERAGE
(
BlendEquation
SrcCoeff
DstCoeff
)
?
kCanTweakAlphaForCoverage_Property
:
0
)
)
>
{
GR_STATIC_ASSERT
(
(
kNone_OutputType
=
=
PrimaryOut
)
=
=
!
GR_BLEND_COEFFS_USE_SRC_COLOR
(
SrcCoeff
DstCoeff
)
)
;
GR_STATIC_ASSERT
(
!
GR_BLEND_COEFF_REFS_SRC2
(
SrcCoeff
)
)
;
GR_STATIC_ASSERT
(
(
kNone_OutputType
=
=
SecondaryOut
)
=
=
!
GR_BLEND_COEFF_REFS_SRC2
(
DstCoeff
)
)
;
GR_STATIC_ASSERT
(
PrimaryOut
!
=
SecondaryOut
|
|
kNone_OutputType
=
=
PrimaryOut
)
;
GR_STATIC_ASSERT
(
kNone_OutputType
!
=
PrimaryOut
|
|
kNone_OutputType
=
=
SecondaryOut
)
;
}
;
union
{
struct
{
OutputType
fPrimaryOutputType
:
4
;
OutputType
fSecondaryOutputType
:
4
;
GrBlendEquation
fBlendEquation
:
6
;
GrBlendCoeff
fSrcCoeff
:
6
;
GrBlendCoeff
fDstCoeff
:
6
;
Properties
fProps
:
32
-
(
4
+
4
+
6
+
6
+
6
)
;
}
;
uint32_t
fData
;
}
;
GR_STATIC_ASSERT
(
kLast_OutputType
<
(
1
<
<
3
)
)
;
GR_STATIC_ASSERT
(
kLast_GrBlendEquation
<
(
1
<
<
5
)
)
;
GR_STATIC_ASSERT
(
kLast_GrBlendCoeff
<
(
1
<
<
5
)
)
;
GR_STATIC_ASSERT
(
kLast_Property
<
(
1
<
<
6
)
)
;
}
;
GR_STATIC_ASSERT
(
4
=
=
sizeof
(
BlendFormula
)
)
;
GR_MAKE_BITFIELD_OPS
(
BlendFormula
:
:
Properties
)
;
#
define
INIT_BLEND_FORMULA
(
PRIMARY_OUT
SECONDARY_OUT
BLEND_EQUATION
SRC_COEFF
DST_COEFF
)
\
{
{
{
PRIMARY_OUT
\
SECONDARY_OUT
\
BLEND_EQUATION
SRC_COEFF
DST_COEFF
\
BlendFormula
:
:
get_properties
<
PRIMARY_OUT
SECONDARY_OUT
\
BLEND_EQUATION
SRC_COEFF
DST_COEFF
>
:
:
value
}
}
}
#
define
COEFF_FORMULA
(
SRC_COEFF
DST_COEFF
)
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kModulate_OutputType
\
BlendFormula
:
:
kNone_OutputType
\
kAdd_GrBlendEquation
SRC_COEFF
DST_COEFF
)
#
define
COEFF_FORMULA_SA_MODULATE
(
SRC_COEFF
DST_COEFF
)
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kSAModulate_OutputType
\
BlendFormula
:
:
kNone_OutputType
\
kAdd_GrBlendEquation
SRC_COEFF
DST_COEFF
)
#
define
DST_CLEAR_FORMULA
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kNone_OutputType
\
BlendFormula
:
:
kNone_OutputType
\
kAdd_GrBlendEquation
kZero_GrBlendCoeff
kZero_GrBlendCoeff
)
#
define
NO_DST_WRITE_FORMULA
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kNone_OutputType
\
BlendFormula
:
:
kNone_OutputType
\
kAdd_GrBlendEquation
kZero_GrBlendCoeff
kOne_GrBlendCoeff
)
#
define
COVERAGE_FORMULA
(
ONE_MINUS_DST_COEFF_MODULATE_OUTPUT
SRC_COEFF
)
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kModulate_OutputType
\
ONE_MINUS_DST_COEFF_MODULATE_OUTPUT
\
kAdd_GrBlendEquation
SRC_COEFF
kIS2C_GrBlendCoeff
)
#
define
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
ONE_MINUS_DST_COEFF_MODULATE_OUTPUT
)
\
INIT_BLEND_FORMULA
(
ONE_MINUS_DST_COEFF_MODULATE_OUTPUT
\
BlendFormula
:
:
kNone_OutputType
\
kReverseSubtract_GrBlendEquation
kDC_GrBlendCoeff
kOne_GrBlendCoeff
)
#
define
COVERAGE_DST_COEFF_ZERO_FORMULA
(
SRC_COEFF
)
\
INIT_BLEND_FORMULA
(
BlendFormula
:
:
kModulate_OutputType
\
BlendFormula
:
:
kCoverage_OutputType
\
kAdd_GrBlendEquation
SRC_COEFF
kIS2A_GrBlendCoeff
)
static
const
BlendFormula
gBlendTable
[
2
]
[
2
]
[
SkXfermode
:
:
kLastCoeffMode
+
1
]
=
{
{
{
DST_CLEAR_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kZero_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kZero_GrBlendCoeff
)
COEFF_FORMULA
(
kZero_GrBlendCoeff
kSA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kZero_GrBlendCoeff
)
COEFF_FORMULA
(
kZero_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kSA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kZero_GrBlendCoeff
kSC_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISC_GrBlendCoeff
)
}
{
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
)
COVERAGE_DST_COEFF_ZERO_FORMULA
(
kOne_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COVERAGE_DST_COEFF_ZERO_FORMULA
(
kDA_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kISAModulate_OutputType
)
COVERAGE_DST_COEFF_ZERO_FORMULA
(
kIDA_GrBlendCoeff
)
COEFF_FORMULA
(
kZero_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kISAModulate_OutputType
kIDA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kOne_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kISCModulate_OutputType
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISC_GrBlendCoeff
)
}
}
{
{
DST_CLEAR_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kZero_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kZero_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kZero_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kZero_GrBlendCoeff
)
DST_CLEAR_FORMULA
COEFF_FORMULA
(
kDA_GrBlendCoeff
kZero_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kZero_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kZero_GrBlendCoeff
kSC_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISC_GrBlendCoeff
)
}
{
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISA_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kISA_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
)
COEFF_FORMULA
(
kDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kISA_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kOne_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kISCModulate_OutputType
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISC_GrBlendCoeff
)
}
}
}
;
static
const
BlendFormula
gLCDBlendTable
[
SkXfermode
:
:
kLastCoeffMode
+
1
]
=
{
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
kOne_GrBlendCoeff
)
NO_DST_WRITE_FORMULA
COVERAGE_FORMULA
(
BlendFormula
:
:
kSAModulate_OutputType
kOne_GrBlendCoeff
)
COEFF_FORMULA
(
kIDA_GrBlendCoeff
kOne_GrBlendCoeff
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
kDA_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kISAModulate_OutputType
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kCoverage_OutputType
kIDA_GrBlendCoeff
)
COEFF_FORMULA_SA_MODULATE
(
kZero_GrBlendCoeff
kISC_GrBlendCoeff
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kSAModulate_OutputType
kDA_GrBlendCoeff
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kISAModulate_OutputType
kIDA_GrBlendCoeff
)
COVERAGE_FORMULA
(
BlendFormula
:
:
kSAModulate_OutputType
kIDA_GrBlendCoeff
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kOne_GrBlendCoeff
)
COVERAGE_SRC_COEFF_ZERO_FORMULA
(
BlendFormula
:
:
kISCModulate_OutputType
)
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISC_GrBlendCoeff
)
}
;
static
BlendFormula
get_blend_formula
(
const
GrProcOptInfo
&
colorPOI
const
GrProcOptInfo
&
coveragePOI
bool
hasMixedSamples
SkXfermode
:
:
Mode
xfermode
)
{
SkASSERT
(
xfermode
>
=
0
&
&
xfermode
<
=
SkXfermode
:
:
kLastCoeffMode
)
;
SkASSERT
(
!
coveragePOI
.
isFourChannelOutput
(
)
)
;
bool
conflatesCoverage
=
!
coveragePOI
.
isSolidWhite
(
)
|
|
hasMixedSamples
;
return
gBlendTable
[
colorPOI
.
isOpaque
(
)
]
[
conflatesCoverage
]
[
xfermode
]
;
}
static
BlendFormula
get_lcd_blend_formula
(
const
GrProcOptInfo
&
coveragePOI
SkXfermode
:
:
Mode
xfermode
)
{
SkASSERT
(
xfermode
>
=
0
&
&
xfermode
<
=
SkXfermode
:
:
kLastCoeffMode
)
;
SkASSERT
(
coveragePOI
.
isFourChannelOutput
(
)
)
;
return
gLCDBlendTable
[
xfermode
]
;
}
class
PorterDuffXferProcessor
:
public
GrXferProcessor
{
public
:
PorterDuffXferProcessor
(
BlendFormula
blendFormula
)
:
fBlendFormula
(
blendFormula
)
{
this
-
>
initClassID
<
PorterDuffXferProcessor
>
(
)
;
}
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
"
;
}
GrGLSLXferProcessor
*
createGLSLInstance
(
)
const
override
;
BlendFormula
getBlendFormula
(
)
const
{
return
fBlendFormula
;
}
private
:
GrXferProcessor
:
:
OptFlags
onGetOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
;
bool
onHasSecondaryOutput
(
)
const
override
{
return
fBlendFormula
.
hasSecondaryOutput
(
)
;
}
void
onGetBlendInfo
(
GrXferProcessor
:
:
BlendInfo
*
blendInfo
)
const
override
{
blendInfo
-
>
fEquation
=
fBlendFormula
.
fBlendEquation
;
blendInfo
-
>
fSrcBlend
=
fBlendFormula
.
fSrcCoeff
;
blendInfo
-
>
fDstBlend
=
fBlendFormula
.
fDstCoeff
;
blendInfo
-
>
fWriteColor
=
fBlendFormula
.
modifiesDst
(
)
;
}
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
PorterDuffXferProcessor
&
xp
=
xpBase
.
cast
<
PorterDuffXferProcessor
>
(
)
;
return
fBlendFormula
=
=
xp
.
fBlendFormula
;
}
const
BlendFormula
fBlendFormula
;
typedef
GrXferProcessor
INHERITED
;
}
;
static
void
append_color_output
(
const
PorterDuffXferProcessor
&
xp
GrGLSLXPFragmentBuilder
*
fragBuilder
BlendFormula
:
:
OutputType
outputType
const
char
*
output
const
char
*
inColor
const
char
*
inCoverage
)
{
switch
(
outputType
)
{
case
BlendFormula
:
:
kNone_OutputType
:
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
0
.
0
)
;
"
output
)
;
break
;
case
BlendFormula
:
:
kCoverage_OutputType
:
if
(
inCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
output
inCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
)
;
"
output
)
;
}
break
;
case
BlendFormula
:
:
kModulate_OutputType
:
if
(
inCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
;
"
output
inColor
inCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
output
inColor
)
;
}
break
;
case
BlendFormula
:
:
kSAModulate_OutputType
:
if
(
inCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
.
a
*
%
s
;
"
output
inColor
inCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
output
inColor
)
;
}
break
;
case
BlendFormula
:
:
kISAModulate_OutputType
:
if
(
inCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
(
1
.
0
-
%
s
.
a
)
*
%
s
;
"
output
inColor
inCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
-
%
s
.
a
)
;
"
output
inColor
)
;
}
break
;
case
BlendFormula
:
:
kISCModulate_OutputType
:
if
(
inCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
(
vec4
(
1
.
0
)
-
%
s
)
*
%
s
;
"
output
inColor
inCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
)
-
%
s
;
"
output
inColor
)
;
}
break
;
default
:
SkFAIL
(
"
Unsupported
output
type
.
"
)
;
break
;
}
}
class
GLPorterDuffXferProcessor
:
public
GrGLSLXferProcessor
{
public
:
static
void
GenKey
(
const
GrProcessor
&
processor
GrProcessorKeyBuilder
*
b
)
{
const
PorterDuffXferProcessor
&
xp
=
processor
.
cast
<
PorterDuffXferProcessor
>
(
)
;
b
-
>
add32
(
xp
.
getBlendFormula
(
)
.
fPrimaryOutputType
|
(
xp
.
getBlendFormula
(
)
.
fSecondaryOutputType
<
<
3
)
)
;
GR_STATIC_ASSERT
(
BlendFormula
:
:
kLast_OutputType
<
8
)
;
}
;
private
:
void
emitOutputsForBlendState
(
const
EmitArgs
&
args
)
override
{
const
PorterDuffXferProcessor
&
xp
=
args
.
fXP
.
cast
<
PorterDuffXferProcessor
>
(
)
;
GrGLSLXPFragmentBuilder
*
fragBuilder
=
args
.
fXPFragBuilder
;
BlendFormula
blendFormula
=
xp
.
getBlendFormula
(
)
;
if
(
blendFormula
.
hasSecondaryOutput
(
)
)
{
append_color_output
(
xp
fragBuilder
blendFormula
.
fSecondaryOutputType
args
.
fOutputSecondary
args
.
fInputColor
args
.
fInputCoverage
)
;
}
append_color_output
(
xp
fragBuilder
blendFormula
.
fPrimaryOutputType
args
.
fOutputPrimary
args
.
fInputColor
args
.
fInputCoverage
)
;
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrXferProcessor
&
)
override
{
}
typedef
GrGLSLXferProcessor
INHERITED
;
}
;
void
PorterDuffXferProcessor
:
:
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
const
{
GLPorterDuffXferProcessor
:
:
GenKey
(
*
this
b
)
;
}
GrGLSLXferProcessor
*
PorterDuffXferProcessor
:
:
createGLSLInstance
(
)
const
{
return
new
GLPorterDuffXferProcessor
;
}
GrXferProcessor
:
:
OptFlags
PorterDuffXferProcessor
:
:
onGetOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
{
GrXferProcessor
:
:
OptFlags
optFlags
=
GrXferProcessor
:
:
kNone_OptFlags
;
if
(
!
fBlendFormula
.
modifiesDst
(
)
)
{
if
(
!
doesStencilWrite
)
{
optFlags
|
=
GrXferProcessor
:
:
kSkipDraw_OptFlag
;
}
optFlags
|
=
(
GrXferProcessor
:
:
kIgnoreColor_OptFlag
|
GrXferProcessor
:
:
kIgnoreCoverage_OptFlag
|
GrXferProcessor
:
:
kCanTweakAlphaForCoverage_OptFlag
)
;
}
else
{
if
(
!
fBlendFormula
.
usesInputColor
(
)
)
{
optFlags
|
=
GrXferProcessor
:
:
kIgnoreColor_OptFlag
;
}
if
(
optimizations
.
fCoveragePOI
.
isSolidWhite
(
)
)
{
optFlags
|
=
GrXferProcessor
:
:
kIgnoreCoverage_OptFlag
;
}
if
(
optimizations
.
fColorPOI
.
allStagesMultiplyInput
(
)
&
&
fBlendFormula
.
canTweakAlphaForCoverage
(
)
&
&
!
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
)
{
optFlags
|
=
GrXferProcessor
:
:
kCanTweakAlphaForCoverage_OptFlag
;
}
}
return
optFlags
;
}
class
ShaderPDXferProcessor
:
public
GrXferProcessor
{
public
:
ShaderPDXferProcessor
(
const
DstTexture
*
dstTexture
bool
hasMixedSamples
SkXfermode
:
:
Mode
xfermode
)
:
INHERITED
(
dstTexture
true
hasMixedSamples
)
fXfermode
(
xfermode
)
{
this
-
>
initClassID
<
ShaderPDXferProcessor
>
(
)
;
}
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
Shader
"
;
}
GrGLSLXferProcessor
*
createGLSLInstance
(
)
const
override
;
SkXfermode
:
:
Mode
getXfermode
(
)
const
{
return
fXfermode
;
}
private
:
GrXferProcessor
:
:
OptFlags
onGetOptimizations
(
const
GrPipelineOptimizations
&
bool
GrColor
*
const
GrCaps
&
)
const
override
{
return
kNone_OptFlags
;
}
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
;
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
ShaderPDXferProcessor
&
xp
=
xpBase
.
cast
<
ShaderPDXferProcessor
>
(
)
;
return
fXfermode
=
=
xp
.
fXfermode
;
}
const
SkXfermode
:
:
Mode
fXfermode
;
typedef
GrXferProcessor
INHERITED
;
}
;
class
GLShaderPDXferProcessor
:
public
GrGLSLXferProcessor
{
public
:
static
void
GenKey
(
const
GrProcessor
&
processor
GrProcessorKeyBuilder
*
b
)
{
const
ShaderPDXferProcessor
&
xp
=
processor
.
cast
<
ShaderPDXferProcessor
>
(
)
;
b
-
>
add32
(
xp
.
getXfermode
(
)
)
;
}
private
:
void
emitBlendCodeForDstRead
(
GrGLSLXPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
char
*
srcColor
const
char
*
srcCoverage
const
char
*
dstColor
const
char
*
outColor
const
char
*
outColorSecondary
const
GrXferProcessor
&
proc
)
override
{
const
ShaderPDXferProcessor
&
xp
=
proc
.
cast
<
ShaderPDXferProcessor
>
(
)
;
GrGLSLBlend
:
:
AppendMode
(
fragBuilder
srcColor
dstColor
outColor
xp
.
getXfermode
(
)
)
;
if
(
xp
.
dstReadUsesMixedSamples
(
)
)
{
if
(
srcCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
*
=
%
s
;
"
outColor
srcCoverage
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outColorSecondary
srcCoverage
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
)
;
"
outColorSecondary
)
;
}
}
else
if
(
srcCoverage
)
{
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
+
(
vec4
(
1
.
0
)
-
%
s
)
*
%
s
;
"
outColor
srcCoverage
outColor
srcCoverage
dstColor
)
;
}
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrXferProcessor
&
)
override
{
}
typedef
GrGLSLXferProcessor
INHERITED
;
}
;
void
ShaderPDXferProcessor
:
:
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
const
{
GLShaderPDXferProcessor
:
:
GenKey
(
*
this
b
)
;
}
GrGLSLXferProcessor
*
ShaderPDXferProcessor
:
:
createGLSLInstance
(
)
const
{
return
new
GLShaderPDXferProcessor
;
}
class
PDLCDXferProcessor
:
public
GrXferProcessor
{
public
:
static
GrXferProcessor
*
Create
(
SkXfermode
:
:
Mode
xfermode
const
GrProcOptInfo
&
colorPOI
)
;
~
PDLCDXferProcessor
(
)
override
;
const
char
*
name
(
)
const
override
{
return
"
Porter
Duff
LCD
"
;
}
GrGLSLXferProcessor
*
createGLSLInstance
(
)
const
override
;
private
:
PDLCDXferProcessor
(
GrColor
blendConstant
uint8_t
alpha
)
;
GrXferProcessor
:
:
OptFlags
onGetOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
;
void
onGetBlendInfo
(
GrXferProcessor
:
:
BlendInfo
*
blendInfo
)
const
override
{
blendInfo
-
>
fSrcBlend
=
kConstC_GrBlendCoeff
;
blendInfo
-
>
fDstBlend
=
kISC_GrBlendCoeff
;
blendInfo
-
>
fBlendConstant
=
fBlendConstant
;
}
bool
onIsEqual
(
const
GrXferProcessor
&
xpBase
)
const
override
{
const
PDLCDXferProcessor
&
xp
=
xpBase
.
cast
<
PDLCDXferProcessor
>
(
)
;
if
(
fBlendConstant
!
=
xp
.
fBlendConstant
|
|
fAlpha
!
=
xp
.
fAlpha
)
{
return
false
;
}
return
true
;
}
GrColor
fBlendConstant
;
uint8_t
fAlpha
;
typedef
GrXferProcessor
INHERITED
;
}
;
class
GLPDLCDXferProcessor
:
public
GrGLSLXferProcessor
{
public
:
GLPDLCDXferProcessor
(
const
GrProcessor
&
)
{
}
virtual
~
GLPDLCDXferProcessor
(
)
{
}
static
void
GenKey
(
const
GrProcessor
&
processor
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
{
}
private
:
void
emitOutputsForBlendState
(
const
EmitArgs
&
args
)
override
{
GrGLSLXPFragmentBuilder
*
fragBuilder
=
args
.
fXPFragBuilder
;
SkASSERT
(
args
.
fInputCoverage
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
;
"
args
.
fOutputPrimary
args
.
fInputColor
args
.
fInputCoverage
)
;
}
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrXferProcessor
&
)
override
{
}
;
typedef
GrGLSLXferProcessor
INHERITED
;
}
;
PDLCDXferProcessor
:
:
PDLCDXferProcessor
(
GrColor
blendConstant
uint8_t
alpha
)
:
fBlendConstant
(
blendConstant
)
fAlpha
(
alpha
)
{
this
-
>
initClassID
<
PDLCDXferProcessor
>
(
)
;
}
GrXferProcessor
*
PDLCDXferProcessor
:
:
Create
(
SkXfermode
:
:
Mode
xfermode
const
GrProcOptInfo
&
colorPOI
)
{
if
(
SkXfermode
:
:
kSrcOver_Mode
!
=
xfermode
)
{
return
nullptr
;
}
if
(
kRGBA_GrColorComponentFlags
!
=
colorPOI
.
validFlags
(
)
)
{
return
nullptr
;
}
GrColor
blendConstant
=
GrUnpremulColor
(
colorPOI
.
color
(
)
)
;
uint8_t
alpha
=
GrColorUnpackA
(
blendConstant
)
;
blendConstant
|
=
(
0xff
<
<
GrColor_SHIFT_A
)
;
return
new
PDLCDXferProcessor
(
blendConstant
alpha
)
;
}
PDLCDXferProcessor
:
:
~
PDLCDXferProcessor
(
)
{
}
void
PDLCDXferProcessor
:
:
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
GLPDLCDXferProcessor
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLXferProcessor
*
PDLCDXferProcessor
:
:
createGLSLInstance
(
)
const
{
return
new
GLPDLCDXferProcessor
(
*
this
)
;
}
GrXferProcessor
:
:
OptFlags
PDLCDXferProcessor
:
:
onGetOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
{
*
overrideColor
=
GrColorPackRGBA
(
fAlpha
fAlpha
fAlpha
fAlpha
)
;
return
GrXferProcessor
:
:
kOverrideColor_OptFlag
;
}
GrPorterDuffXPFactory
:
:
GrPorterDuffXPFactory
(
SkXfermode
:
:
Mode
xfermode
)
:
fXfermode
(
xfermode
)
{
SkASSERT
(
fXfermode
<
=
SkXfermode
:
:
kLastCoeffMode
)
;
this
-
>
initClassID
<
GrPorterDuffXPFactory
>
(
)
;
}
GrXPFactory
*
GrPorterDuffXPFactory
:
:
Create
(
SkXfermode
:
:
Mode
xfermode
)
{
static
GrPorterDuffXPFactory
gClearPDXPF
(
SkXfermode
:
:
kClear_Mode
)
;
static
GrPorterDuffXPFactory
gSrcPDXPF
(
SkXfermode
:
:
kSrc_Mode
)
;
static
GrPorterDuffXPFactory
gDstPDXPF
(
SkXfermode
:
:
kDst_Mode
)
;
static
GrPorterDuffXPFactory
gSrcOverPDXPF
(
SkXfermode
:
:
kSrcOver_Mode
)
;
static
GrPorterDuffXPFactory
gDstOverPDXPF
(
SkXfermode
:
:
kDstOver_Mode
)
;
static
GrPorterDuffXPFactory
gSrcInPDXPF
(
SkXfermode
:
:
kSrcIn_Mode
)
;
static
GrPorterDuffXPFactory
gDstInPDXPF
(
SkXfermode
:
:
kDstIn_Mode
)
;
static
GrPorterDuffXPFactory
gSrcOutPDXPF
(
SkXfermode
:
:
kSrcOut_Mode
)
;
static
GrPorterDuffXPFactory
gDstOutPDXPF
(
SkXfermode
:
:
kDstOut_Mode
)
;
static
GrPorterDuffXPFactory
gSrcATopPDXPF
(
SkXfermode
:
:
kSrcATop_Mode
)
;
static
GrPorterDuffXPFactory
gDstATopPDXPF
(
SkXfermode
:
:
kDstATop_Mode
)
;
static
GrPorterDuffXPFactory
gXorPDXPF
(
SkXfermode
:
:
kXor_Mode
)
;
static
GrPorterDuffXPFactory
gPlusPDXPF
(
SkXfermode
:
:
kPlus_Mode
)
;
static
GrPorterDuffXPFactory
gModulatePDXPF
(
SkXfermode
:
:
kModulate_Mode
)
;
static
GrPorterDuffXPFactory
gScreenPDXPF
(
SkXfermode
:
:
kScreen_Mode
)
;
static
GrPorterDuffXPFactory
*
gFactories
[
]
=
{
&
gClearPDXPF
&
gSrcPDXPF
&
gDstPDXPF
&
gSrcOverPDXPF
&
gDstOverPDXPF
&
gSrcInPDXPF
&
gDstInPDXPF
&
gSrcOutPDXPF
&
gDstOutPDXPF
&
gSrcATopPDXPF
&
gDstATopPDXPF
&
gXorPDXPF
&
gPlusPDXPF
&
gModulatePDXPF
&
gScreenPDXPF
}
;
GR_STATIC_ASSERT
(
SK_ARRAY_COUNT
(
gFactories
)
=
=
SkXfermode
:
:
kLastCoeffMode
+
1
)
;
if
(
xfermode
<
0
|
|
xfermode
>
SkXfermode
:
:
kLastCoeffMode
)
{
return
nullptr
;
}
return
SkRef
(
gFactories
[
xfermode
]
)
;
}
GrXferProcessor
*
GrPorterDuffXPFactory
:
:
onCreateXferProcessor
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
const
DstTexture
*
dstTexture
)
const
{
BlendFormula
blendFormula
;
if
(
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
)
{
if
(
SkXfermode
:
:
kSrcOver_Mode
=
=
fXfermode
&
&
kRGBA_GrColorComponentFlags
=
=
optimizations
.
fColorPOI
.
validFlags
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dstReadInShaderSupport
(
)
)
{
SkASSERT
(
!
dstTexture
|
|
!
dstTexture
-
>
texture
(
)
)
;
return
PDLCDXferProcessor
:
:
Create
(
fXfermode
optimizations
.
fColorPOI
)
;
}
blendFormula
=
get_lcd_blend_formula
(
optimizations
.
fCoveragePOI
fXfermode
)
;
}
else
{
blendFormula
=
get_blend_formula
(
optimizations
.
fColorPOI
optimizations
.
fCoveragePOI
hasMixedSamples
fXfermode
)
;
}
if
(
blendFormula
.
hasSecondaryOutput
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
)
{
return
new
ShaderPDXferProcessor
(
dstTexture
hasMixedSamples
fXfermode
)
;
}
SkASSERT
(
!
dstTexture
|
|
!
dstTexture
-
>
texture
(
)
)
;
return
new
PorterDuffXferProcessor
(
blendFormula
)
;
}
void
GrPorterDuffXPFactory
:
:
getInvariantBlendedColor
(
const
GrProcOptInfo
&
colorPOI
InvariantBlendedColor
*
blendedColor
)
const
{
BlendFormula
colorFormula
=
gBlendTable
[
colorPOI
.
isOpaque
(
)
]
[
0
]
[
fXfermode
]
;
if
(
colorFormula
.
usesDstColor
(
)
)
{
blendedColor
-
>
fWillBlendWithDst
=
true
;
blendedColor
-
>
fKnownColorFlags
=
kNone_GrColorComponentFlags
;
return
;
}
blendedColor
-
>
fWillBlendWithDst
=
false
;
SkASSERT
(
kAdd_GrBlendEquation
=
=
colorFormula
.
fBlendEquation
)
;
switch
(
colorFormula
.
fSrcCoeff
)
{
case
kZero_GrBlendCoeff
:
blendedColor
-
>
fKnownColor
=
0
;
blendedColor
-
>
fKnownColorFlags
=
kRGBA_GrColorComponentFlags
;
return
;
case
kOne_GrBlendCoeff
:
blendedColor
-
>
fKnownColor
=
colorPOI
.
color
(
)
;
blendedColor
-
>
fKnownColorFlags
=
colorPOI
.
validFlags
(
)
;
return
;
default
:
blendedColor
-
>
fKnownColorFlags
=
kNone_GrColorComponentFlags
;
return
;
}
}
bool
GrPorterDuffXPFactory
:
:
willReadDstColor
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
)
const
{
if
(
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
)
{
return
false
;
}
if
(
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
)
{
if
(
SkXfermode
:
:
kSrcOver_Mode
=
=
fXfermode
&
&
kRGBA_GrColorComponentFlags
=
=
optimizations
.
fColorPOI
.
validFlags
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dstReadInShaderSupport
(
)
)
{
return
false
;
}
return
get_lcd_blend_formula
(
optimizations
.
fCoveragePOI
fXfermode
)
.
hasSecondaryOutput
(
)
;
}
return
get_blend_formula
(
optimizations
.
fColorPOI
optimizations
.
fCoveragePOI
hasMixedSamples
fXfermode
)
.
hasSecondaryOutput
(
)
;
}
GR_DEFINE_XP_FACTORY_TEST
(
GrPorterDuffXPFactory
)
;
const
GrXPFactory
*
GrPorterDuffXPFactory
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
SkXfermode
:
:
Mode
mode
=
SkXfermode
:
:
Mode
(
d
-
>
fRandom
-
>
nextULessThan
(
SkXfermode
:
:
kLastCoeffMode
)
)
;
return
GrPorterDuffXPFactory
:
:
Create
(
mode
)
;
}
void
GrPorterDuffXPFactory
:
:
TestGetXPOutputTypes
(
const
GrXferProcessor
*
xp
int
*
outPrimary
int
*
outSecondary
)
{
if
(
!
!
strcmp
(
xp
-
>
name
(
)
"
Porter
Duff
"
)
)
{
*
outPrimary
=
*
outSecondary
=
-
1
;
return
;
}
BlendFormula
blendFormula
=
static_cast
<
const
PorterDuffXferProcessor
*
>
(
xp
)
-
>
getBlendFormula
(
)
;
*
outPrimary
=
blendFormula
.
fPrimaryOutputType
;
*
outSecondary
=
blendFormula
.
fSecondaryOutputType
;
}
const
GrXferProcessor
&
GrPorterDuffXPFactory
:
:
SimpleSrcOverXP
(
)
{
static
BlendFormula
gSrcOverBlendFormula
=
COEFF_FORMULA
(
kOne_GrBlendCoeff
kISA_GrBlendCoeff
)
;
static
PorterDuffXferProcessor
gSrcOverXP
(
gSrcOverBlendFormula
)
;
return
gSrcOverXP
;
}
GrXferProcessor
*
GrPorterDuffXPFactory
:
:
CreateSrcOverXferProcessor
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
const
GrXferProcessor
:
:
DstTexture
*
dstTexture
)
{
if
(
!
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
&
&
!
(
optimizations
.
fCoveragePOI
.
isSolidWhite
(
)
&
&
!
hasMixedSamples
&
&
optimizations
.
fColorPOI
.
isOpaque
(
)
)
)
{
return
nullptr
;
}
BlendFormula
blendFormula
;
if
(
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
)
{
if
(
kRGBA_GrColorComponentFlags
=
=
optimizations
.
fColorPOI
.
validFlags
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dstReadInShaderSupport
(
)
)
{
SkASSERT
(
!
dstTexture
|
|
!
dstTexture
-
>
texture
(
)
)
;
return
PDLCDXferProcessor
:
:
Create
(
SkXfermode
:
:
kSrcOver_Mode
optimizations
.
fColorPOI
)
;
}
blendFormula
=
get_lcd_blend_formula
(
optimizations
.
fCoveragePOI
SkXfermode
:
:
kSrcOver_Mode
)
;
}
else
{
blendFormula
=
get_blend_formula
(
optimizations
.
fColorPOI
optimizations
.
fCoveragePOI
hasMixedSamples
SkXfermode
:
:
kSrcOver_Mode
)
;
}
if
(
blendFormula
.
hasSecondaryOutput
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
)
{
return
new
ShaderPDXferProcessor
(
dstTexture
hasMixedSamples
SkXfermode
:
:
kSrcOver_Mode
)
;
}
SkASSERT
(
!
dstTexture
|
|
!
dstTexture
-
>
texture
(
)
)
;
return
new
PorterDuffXferProcessor
(
blendFormula
)
;
}
bool
GrPorterDuffXPFactory
:
:
SrcOverWillNeedDstTexture
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
)
{
if
(
caps
.
shaderCaps
(
)
-
>
dstReadInShaderSupport
(
)
|
|
caps
.
shaderCaps
(
)
-
>
dualSourceBlendingSupport
(
)
)
{
return
false
;
}
if
(
optimizations
.
fCoveragePOI
.
isFourChannelOutput
(
)
)
{
if
(
kRGBA_GrColorComponentFlags
=
=
optimizations
.
fColorPOI
.
validFlags
(
)
&
&
!
caps
.
shaderCaps
(
)
-
>
dstReadInShaderSupport
(
)
)
{
return
false
;
}
return
get_lcd_blend_formula
(
optimizations
.
fCoveragePOI
SkXfermode
:
:
kSrcOver_Mode
)
.
hasSecondaryOutput
(
)
;
}
return
get_blend_formula
(
optimizations
.
fColorPOI
optimizations
.
fCoveragePOI
hasMixedSamples
SkXfermode
:
:
kSrcOver_Mode
)
.
hasSecondaryOutput
(
)
;
}
