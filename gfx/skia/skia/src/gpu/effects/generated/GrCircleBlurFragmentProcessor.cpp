#
include
"
GrCircleBlurFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
static
float
make_unnormalized_half_kernel
(
float
*
halfKernel
int
halfKernelSize
float
sigma
)
{
const
float
invSigma
=
1
.
f
/
sigma
;
const
float
b
=
-
0
.
5f
*
invSigma
*
invSigma
;
float
tot
=
0
.
0f
;
float
t
=
0
.
5f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
float
value
=
expf
(
t
*
t
*
b
)
;
tot
+
=
value
;
halfKernel
[
i
]
=
value
;
t
+
=
1
.
f
;
}
return
tot
;
}
static
void
make_half_kernel_and_summed_table
(
float
*
halfKernel
float
*
summedHalfKernel
int
halfKernelSize
float
sigma
)
{
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
i
]
/
=
tot
;
sum
+
=
halfKernel
[
i
]
;
summedHalfKernel
[
i
]
=
sum
;
}
}
void
apply_kernel_in_y
(
float
*
results
int
numSteps
float
firstX
float
circleR
int
halfKernelSize
const
float
*
summedHalfKernelTable
)
{
float
x
=
firstX
;
for
(
int
i
=
0
;
i
<
numSteps
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
results
[
i
]
=
0
;
continue
;
}
float
y
=
sqrtf
(
circleR
*
circleR
-
x
*
x
)
;
y
-
=
0
.
5f
;
int
yInt
=
SkScalarFloorToInt
(
y
)
;
SkASSERT
(
yInt
>
=
-
1
)
;
if
(
y
<
0
)
{
results
[
i
]
=
(
y
+
0
.
5f
)
*
summedHalfKernelTable
[
0
]
;
}
else
if
(
yInt
>
=
halfKernelSize
-
1
)
{
results
[
i
]
=
0
.
5f
;
}
else
{
float
yFrac
=
y
-
yInt
;
results
[
i
]
=
(
1
.
f
-
yFrac
)
*
summedHalfKernelTable
[
yInt
]
+
yFrac
*
summedHalfKernelTable
[
yInt
+
1
]
;
}
}
}
static
uint8_t
eval_at
(
float
evalX
float
circleR
const
float
*
halfKernel
int
halfKernelSize
const
float
*
yKernelEvaluations
)
{
float
acc
=
0
;
float
x
=
evalX
-
halfKernelSize
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
]
;
acc
+
=
verticalEval
*
halfKernel
[
halfKernelSize
-
i
-
1
]
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
+
halfKernelSize
]
;
acc
+
=
verticalEval
*
halfKernel
[
i
]
;
}
return
SkUnitScalarClampToByte
(
2
.
f
*
acc
)
;
}
static
void
create_circle_profile
(
uint8_t
*
weights
float
sigma
float
circleR
int
profileTextureWidth
)
{
const
int
numSteps
=
profileTextureWidth
;
int
halfKernelSize
=
SkScalarCeilToInt
(
6
.
0f
*
sigma
)
;
halfKernelSize
=
(
(
halfKernelSize
+
1
)
&
~
1
)
>
>
1
;
int
numYSteps
=
numSteps
+
2
*
halfKernelSize
;
SkAutoTArray
<
float
>
bulkAlloc
(
halfKernelSize
+
halfKernelSize
+
numYSteps
)
;
float
*
halfKernel
=
bulkAlloc
.
get
(
)
;
float
*
summedKernel
=
bulkAlloc
.
get
(
)
+
halfKernelSize
;
float
*
yEvals
=
bulkAlloc
.
get
(
)
+
2
*
halfKernelSize
;
make_half_kernel_and_summed_table
(
halfKernel
summedKernel
halfKernelSize
sigma
)
;
float
firstX
=
-
halfKernelSize
+
0
.
5f
;
apply_kernel_in_y
(
yEvals
numYSteps
firstX
circleR
halfKernelSize
summedKernel
)
;
for
(
int
i
=
0
;
i
<
numSteps
-
1
;
+
+
i
)
{
float
evalX
=
i
+
0
.
5f
;
weights
[
i
]
=
eval_at
(
evalX
circleR
halfKernel
halfKernelSize
yEvals
+
i
)
;
}
weights
[
numSteps
-
1
]
=
0
;
}
static
void
create_half_plane_profile
(
uint8_t
*
profile
int
profileWidth
)
{
SkASSERT
(
!
(
profileWidth
&
0x1
)
)
;
float
sigma
=
profileWidth
/
6
.
f
;
int
halfKernelSize
=
profileWidth
/
2
;
SkAutoTArray
<
float
>
halfKernel
(
halfKernelSize
)
;
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
.
get
(
)
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
halfKernelSize
-
i
-
1
]
/
=
tot
;
sum
+
=
halfKernel
[
halfKernelSize
-
i
-
1
]
;
profile
[
profileWidth
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
sum
+
=
halfKernel
[
i
]
;
profile
[
halfKernelSize
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
profile
[
profileWidth
-
1
]
=
0
;
}
static
sk_sp
<
GrTextureProxy
>
create_profile_texture
(
GrProxyProvider
*
proxyProvider
const
SkRect
&
circle
float
sigma
float
*
solidRadius
float
*
textureRadius
)
{
float
circleR
=
circle
.
width
(
)
/
2
.
0f
;
if
(
circleR
<
SK_ScalarNearlyZero
)
{
return
nullptr
;
}
SkScalar
sigmaToCircleRRatio
=
sigma
/
circleR
;
sigmaToCircleRRatio
=
SkTMin
(
sigmaToCircleRRatio
8
.
f
)
;
SkFixed
sigmaToCircleRRatioFixed
;
static
const
SkScalar
kHalfPlaneThreshold
=
0
.
1f
;
bool
useHalfPlaneApprox
=
false
;
if
(
sigmaToCircleRRatio
<
=
kHalfPlaneThreshold
)
{
useHalfPlaneApprox
=
true
;
sigmaToCircleRRatioFixed
=
0
;
*
solidRadius
=
circleR
-
3
*
sigma
;
*
textureRadius
=
6
*
sigma
;
}
else
{
sigmaToCircleRRatioFixed
=
SkScalarToFixed
(
sigmaToCircleRRatio
)
;
sigmaToCircleRRatioFixed
&
=
~
0xff
;
sigmaToCircleRRatio
=
SkFixedToScalar
(
sigmaToCircleRRatioFixed
)
;
sigma
=
circleR
*
sigmaToCircleRRatio
;
*
solidRadius
=
0
;
*
textureRadius
=
circleR
+
3
*
sigma
;
}
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
key
;
GrUniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
"
1
-
D
Circular
Blur
"
)
;
builder
[
0
]
=
sigmaToCircleRRatioFixed
;
builder
.
finish
(
)
;
sk_sp
<
GrTextureProxy
>
blurProfile
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
key
GrColorType
:
:
kAlpha_8
kTopLeft_GrSurfaceOrigin
)
;
if
(
!
blurProfile
)
{
static
constexpr
int
kProfileTextureWidth
=
512
;
SkBitmap
bm
;
if
(
!
bm
.
tryAllocPixels
(
SkImageInfo
:
:
MakeA8
(
kProfileTextureWidth
1
)
)
)
{
return
nullptr
;
}
if
(
useHalfPlaneApprox
)
{
create_half_plane_profile
(
bm
.
getAddr8
(
0
0
)
kProfileTextureWidth
)
;
}
else
{
SkScalar
scale
=
kProfileTextureWidth
/
*
textureRadius
;
create_circle_profile
(
bm
.
getAddr8
(
0
0
)
sigma
*
scale
circleR
*
scale
kProfileTextureWidth
)
;
}
bm
.
setImmutable
(
)
;
sk_sp
<
SkImage
>
image
=
SkImage
:
:
MakeFromBitmap
(
bm
)
;
blurProfile
=
proxyProvider
-
>
createTextureProxy
(
std
:
:
move
(
image
)
1
SkBudgeted
:
:
kYes
SkBackingFit
:
:
kExact
)
;
if
(
!
blurProfile
)
{
return
nullptr
;
}
SkASSERT
(
blurProfile
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
proxyProvider
-
>
assignUniqueKeyToProxy
(
key
blurProfile
.
get
(
)
)
;
}
return
blurProfile
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrCircleBlurFragmentProcessor
:
:
Make
(
GrProxyProvider
*
proxyProvider
const
SkRect
&
circle
float
sigma
)
{
float
solidRadius
;
float
textureRadius
;
sk_sp
<
GrTextureProxy
>
profile
(
create_profile_texture
(
proxyProvider
circle
sigma
&
solidRadius
&
textureRadius
)
)
;
if
(
!
profile
)
{
return
nullptr
;
}
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrCircleBlurFragmentProcessor
(
circle
textureRadius
solidRadius
std
:
:
move
(
profile
)
)
)
;
}
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
src
/
sksl
/
SkSLCPP
.
h
"
#
include
"
src
/
sksl
/
SkSLUtil
.
h
"
class
GrGLSLCircleBlurFragmentProcessor
:
public
GrGLSLFragmentProcessor
{
public
:
GrGLSLCircleBlurFragmentProcessor
(
)
{
}
void
emitCode
(
EmitArgs
&
args
)
override
{
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
const
GrCircleBlurFragmentProcessor
&
_outer
=
args
.
fFp
.
cast
<
GrCircleBlurFragmentProcessor
>
(
)
;
(
void
)
_outer
;
auto
circleRect
=
_outer
.
circleRect
;
(
void
)
circleRect
;
auto
textureRadius
=
_outer
.
textureRadius
;
(
void
)
textureRadius
;
auto
solidRadius
=
_outer
.
solidRadius
;
(
void
)
solidRadius
;
circleDataVar
=
args
.
fUniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kHalf4_GrSLType
"
circleData
"
)
;
fragBuilder
-
>
codeAppendf
(
"
half2
vec
=
half2
(
half
(
(
sk_FragCoord
.
x
-
float
(
%
s
.
x
)
)
*
float
(
%
s
.
w
)
)
"
"
half
(
(
sk_FragCoord
.
y
-
float
(
%
s
.
y
)
)
*
float
(
%
s
.
w
)
)
)
;
\
nhalf
dist
=
length
(
vec
)
+
"
"
(
0
.
5
-
%
s
.
z
)
*
%
s
.
w
;
\
n
%
s
=
%
s
*
sample
(
%
s
float2
(
half2
(
dist
0
.
5
)
)
)
.
%
s
.
w
;
\
n
"
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fUniformHandler
-
>
getUniformCStr
(
circleDataVar
)
args
.
fOutputColor
args
.
fInputColor
fragBuilder
-
>
getProgramBuilder
(
)
-
>
samplerVariable
(
args
.
fTexSamplers
[
0
]
)
fragBuilder
-
>
getProgramBuilder
(
)
-
>
samplerSwizzle
(
args
.
fTexSamplers
[
0
]
)
.
c_str
(
)
)
;
}
private
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
data
const
GrFragmentProcessor
&
_proc
)
override
{
const
GrCircleBlurFragmentProcessor
&
_outer
=
_proc
.
cast
<
GrCircleBlurFragmentProcessor
>
(
)
;
auto
circleRect
=
_outer
.
circleRect
;
(
void
)
circleRect
;
auto
textureRadius
=
_outer
.
textureRadius
;
(
void
)
textureRadius
;
auto
solidRadius
=
_outer
.
solidRadius
;
(
void
)
solidRadius
;
GrSurfaceProxy
&
blurProfileSamplerProxy
=
*
_outer
.
textureSampler
(
0
)
.
proxy
(
)
;
GrTexture
&
blurProfileSampler
=
*
blurProfileSamplerProxy
.
peekTexture
(
)
;
(
void
)
blurProfileSampler
;
UniformHandle
&
circleData
=
circleDataVar
;
(
void
)
circleData
;
data
.
set4f
(
circleData
circleRect
.
centerX
(
)
circleRect
.
centerY
(
)
solidRadius
1
.
f
/
textureRadius
)
;
}
UniformHandle
circleDataVar
;
}
;
GrGLSLFragmentProcessor
*
GrCircleBlurFragmentProcessor
:
:
onCreateGLSLInstance
(
)
const
{
return
new
GrGLSLCircleBlurFragmentProcessor
(
)
;
}
void
GrCircleBlurFragmentProcessor
:
:
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
}
bool
GrCircleBlurFragmentProcessor
:
:
onIsEqual
(
const
GrFragmentProcessor
&
other
)
const
{
const
GrCircleBlurFragmentProcessor
&
that
=
other
.
cast
<
GrCircleBlurFragmentProcessor
>
(
)
;
(
void
)
that
;
if
(
circleRect
!
=
that
.
circleRect
)
return
false
;
if
(
textureRadius
!
=
that
.
textureRadius
)
return
false
;
if
(
solidRadius
!
=
that
.
solidRadius
)
return
false
;
if
(
blurProfileSampler
!
=
that
.
blurProfileSampler
)
return
false
;
return
true
;
}
GrCircleBlurFragmentProcessor
:
:
GrCircleBlurFragmentProcessor
(
const
GrCircleBlurFragmentProcessor
&
src
)
:
INHERITED
(
kGrCircleBlurFragmentProcessor_ClassID
src
.
optimizationFlags
(
)
)
circleRect
(
src
.
circleRect
)
textureRadius
(
src
.
textureRadius
)
solidRadius
(
src
.
solidRadius
)
blurProfileSampler
(
src
.
blurProfileSampler
)
{
this
-
>
setTextureSamplerCnt
(
1
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrCircleBlurFragmentProcessor
:
:
clone
(
)
const
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrCircleBlurFragmentProcessor
(
*
this
)
)
;
}
const
GrFragmentProcessor
:
:
TextureSampler
&
GrCircleBlurFragmentProcessor
:
:
onTextureSampler
(
int
index
)
const
{
return
IthTextureSampler
(
index
blurProfileSampler
)
;
}
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrCircleBlurFragmentProcessor
)
;
#
if
GR_TEST_UTILS
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrCircleBlurFragmentProcessor
:
:
TestCreate
(
GrProcessorTestData
*
testData
)
{
SkScalar
wh
=
testData
-
>
fRandom
-
>
nextRangeScalar
(
100
.
f
1000
.
f
)
;
SkScalar
sigma
=
testData
-
>
fRandom
-
>
nextRangeF
(
1
.
f
10
.
f
)
;
SkRect
circle
=
SkRect
:
:
MakeWH
(
wh
wh
)
;
return
GrCircleBlurFragmentProcessor
:
:
Make
(
testData
-
>
proxyProvider
(
)
circle
sigma
)
;
}
#
endif
