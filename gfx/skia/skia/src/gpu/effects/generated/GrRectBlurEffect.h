#
ifndef
GrRectBlurEffect_DEFINED
#
define
GrRectBlurEffect_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
<
cmath
>
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
src
/
core
/
SkBlurMask
.
h
"
#
include
"
src
/
core
/
SkMathPriv
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
GrCoordTransform
.
h
"
#
include
"
src
/
gpu
/
GrFragmentProcessor
.
h
"
class
GrRectBlurEffect
:
public
GrFragmentProcessor
{
public
:
static
sk_sp
<
GrTextureProxy
>
CreateIntegralTexture
(
GrProxyProvider
*
proxyProvider
float
sixSigma
)
{
int
minWidth
=
2
*
sk_float_ceil2int
(
sixSigma
)
;
int
width
=
SkTMax
(
SkNextPow2
(
minWidth
)
32
)
;
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
key
;
GrUniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
"
Rect
Blur
Mask
"
)
;
builder
[
0
]
=
width
;
builder
.
finish
(
)
;
sk_sp
<
GrTextureProxy
>
proxy
(
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
key
GrColorType
:
:
kAlpha_8
kTopLeft_GrSurfaceOrigin
)
)
;
if
(
!
proxy
)
{
SkBitmap
bitmap
;
if
(
!
bitmap
.
tryAllocPixels
(
SkImageInfo
:
:
MakeA8
(
width
1
)
)
)
{
return
nullptr
;
}
*
bitmap
.
getAddr8
(
0
0
)
=
255
;
const
float
invWidth
=
1
.
f
/
width
;
for
(
int
i
=
1
;
i
<
width
-
1
;
+
+
i
)
{
float
x
=
(
i
+
0
.
5f
)
*
invWidth
;
x
=
(
-
6
*
x
+
3
)
*
SK_ScalarRoot2Over2
;
float
integral
=
0
.
5f
*
(
std
:
:
erf
(
x
)
+
1
.
f
)
;
*
bitmap
.
getAddr8
(
i
0
)
=
SkToU8
(
sk_float_round2int
(
255
.
f
*
integral
)
)
;
}
*
bitmap
.
getAddr8
(
width
-
1
0
)
=
0
;
bitmap
.
setImmutable
(
)
;
proxy
=
proxyProvider
-
>
createProxyFromBitmap
(
bitmap
GrMipMapped
:
:
kNo
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
SkASSERT
(
proxy
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
proxyProvider
-
>
assignUniqueKeyToProxy
(
key
proxy
.
get
(
)
)
;
}
return
proxy
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
GrProxyProvider
*
proxyProvider
const
GrShaderCaps
&
caps
const
SkRect
&
rect
float
sigma
)
{
SkASSERT
(
rect
.
isSorted
(
)
)
;
if
(
!
caps
.
floatIs32Bits
(
)
)
{
if
(
SkScalarAbs
(
rect
.
fLeft
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fTop
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fRight
)
>
16000
.
f
|
|
SkScalarAbs
(
rect
.
fBottom
)
>
16000
.
f
)
{
return
nullptr
;
}
}
const
float
sixSigma
=
6
*
sigma
;
auto
integral
=
CreateIntegralTexture
(
proxyProvider
sixSigma
)
;
if
(
!
integral
)
{
return
nullptr
;
}
float
threeSigma
=
sixSigma
/
2
;
SkRect
insetRect
=
{
rect
.
fLeft
+
threeSigma
rect
.
fTop
+
threeSigma
rect
.
fRight
-
threeSigma
rect
.
fBottom
-
threeSigma
}
;
bool
isFast
=
insetRect
.
isSorted
(
)
;
float
invSixSigma
=
1
.
f
/
sixSigma
;
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrRectBlurEffect
(
insetRect
std
:
:
move
(
integral
)
invSixSigma
isFast
GrSamplerState
:
:
ClampBilerp
(
)
)
)
;
}
GrRectBlurEffect
(
const
GrRectBlurEffect
&
src
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
;
const
char
*
name
(
)
const
override
{
return
"
RectBlurEffect
"
;
}
SkRect
rect
;
TextureSampler
integral
;
float
invSixSigma
;
bool
isFast
;
private
:
GrRectBlurEffect
(
SkRect
rect
sk_sp
<
GrTextureProxy
>
integral
float
invSixSigma
bool
isFast
GrSamplerState
samplerParams
)
:
INHERITED
(
kGrRectBlurEffect_ClassID
(
OptimizationFlags
)
kCompatibleWithCoverageAsAlpha_OptimizationFlag
)
rect
(
rect
)
integral
(
std
:
:
move
(
integral
)
samplerParams
)
invSixSigma
(
invSixSigma
)
isFast
(
isFast
)
{
this
-
>
setTextureSamplerCnt
(
1
)
;
}
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
;
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
