#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrBicubicEffect
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrGLBicubicEffect
:
public
GrGLSLFragmentProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
static
inline
void
GenKey
(
const
GrProcessor
&
effect
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
GrBicubicEffect
&
bicubicEffect
=
effect
.
cast
<
GrBicubicEffect
>
(
)
;
b
-
>
add32
(
GrTextureDomain
:
:
GLDomain
:
:
DomainKey
(
bicubicEffect
.
domain
(
)
)
)
;
uint32_t
bidir
=
bicubicEffect
.
direction
(
)
=
=
GrBicubicEffect
:
:
Direction
:
:
kXY
?
1
:
0
;
b
-
>
add32
(
bidir
|
(
bicubicEffect
.
alphaType
(
)
<
<
1
)
)
;
}
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
override
;
private
:
typedef
GrGLSLProgramDataManager
:
:
UniformHandle
UniformHandle
;
UniformHandle
fDimensions
;
GrTextureDomain
:
:
GLDomain
fDomain
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
void
GrGLBicubicEffect
:
:
emitCode
(
EmitArgs
&
args
)
{
const
GrBicubicEffect
&
bicubicEffect
=
args
.
fFp
.
cast
<
GrBicubicEffect
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
fDimensions
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kHalf4_GrSLType
"
Dimensions
"
)
;
const
char
*
dims
=
uniformHandler
-
>
getUniformCStr
(
fDimensions
)
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
SkString
coords2D
=
fragBuilder
-
>
ensureCoords2D
(
args
.
fTransformedCoords
[
0
]
.
fVaryingPoint
)
;
fragBuilder
-
>
codeAppend
(
"
half4x4
kMitchellCoefficients
=
half4x4
(
"
"
1
.
0
/
18
.
0
16
.
0
/
18
.
0
1
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
-
9
.
0
/
18
.
0
0
.
0
/
18
.
0
9
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
15
.
0
/
18
.
0
-
36
.
0
/
18
.
0
27
.
0
/
18
.
0
-
6
.
0
/
18
.
0
"
"
-
7
.
0
/
18
.
0
21
.
0
/
18
.
0
-
21
.
0
/
18
.
0
7
.
0
/
18
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
float2
coord
=
%
s
-
%
s
.
xy
*
float2
(
0
.
5
)
;
"
coords2D
.
c_str
(
)
dims
)
;
fragBuilder
-
>
codeAppendf
(
"
half2
f
=
half2
(
fract
(
coord
*
%
s
.
zw
)
)
;
"
dims
)
;
fragBuilder
-
>
codeAppendf
(
"
coord
=
coord
+
(
half2
(
0
.
5
)
-
f
)
*
%
s
.
xy
;
"
dims
)
;
if
(
bicubicEffect
.
direction
(
)
=
=
GrBicubicEffect
:
:
Direction
:
:
kXY
)
{
fragBuilder
-
>
codeAppend
(
"
half4
wx
=
kMitchellCoefficients
*
half4
(
1
.
0
f
.
x
f
.
x
*
f
.
x
f
.
x
*
f
.
x
*
f
.
x
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
wy
=
kMitchellCoefficients
*
half4
(
1
.
0
f
.
y
f
.
y
*
f
.
y
f
.
y
*
f
.
y
*
f
.
y
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
rowColors
[
4
]
;
"
)
;
for
(
int
y
=
0
;
y
<
4
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
4
;
+
+
x
)
{
SkString
coord
;
coord
.
printf
(
"
coord
+
%
s
.
xy
*
float2
(
%
d
%
d
)
"
dims
x
-
1
y
-
1
)
;
SkString
sampleVar
;
sampleVar
.
printf
(
"
rowColors
[
%
d
]
"
x
)
;
fDomain
.
sampleTexture
(
fragBuilder
args
.
fUniformHandler
args
.
fShaderCaps
bicubicEffect
.
domain
(
)
sampleVar
.
c_str
(
)
coord
args
.
fTexSamplers
[
0
]
)
;
}
fragBuilder
-
>
codeAppendf
(
"
half4
s
%
d
=
wx
.
x
*
rowColors
[
0
]
+
wx
.
y
*
rowColors
[
1
]
+
wx
.
z
*
rowColors
[
2
]
+
"
"
wx
.
w
*
rowColors
[
3
]
;
"
y
)
;
}
fragBuilder
-
>
codeAppend
(
"
half4
bicubicColor
=
wy
.
x
*
s0
+
wy
.
y
*
s1
+
wy
.
z
*
s2
+
wy
.
w
*
s3
;
"
)
;
}
else
{
fragBuilder
-
>
codeAppend
(
"
half
v
=
f
.
x
+
f
.
y
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half
v2
=
v
*
v
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
w
=
kMitchellCoefficients
*
half4
(
1
.
0
v
v2
v2
*
v
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
c
[
4
]
;
"
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
SkString
coord
;
coord
.
printf
(
"
coord
+
%
s
.
xy
*
half
(
%
d
)
"
dims
i
-
1
)
;
SkString
samplerVar
;
samplerVar
.
printf
(
"
c
[
%
d
]
"
i
)
;
fDomain
.
sampleTexture
(
fragBuilder
args
.
fUniformHandler
args
.
fShaderCaps
bicubicEffect
.
domain
(
)
samplerVar
.
c_str
(
)
coord
args
.
fTexSamplers
[
0
]
)
;
}
fragBuilder
-
>
codeAppend
(
"
half4
bicubicColor
=
c
[
0
]
*
w
.
x
+
c
[
1
]
*
w
.
y
+
c
[
2
]
*
w
.
z
+
c
[
3
]
*
w
.
w
;
"
)
;
}
if
(
kPremul_SkAlphaType
=
=
bicubicEffect
.
alphaType
(
)
)
{
fragBuilder
-
>
codeAppend
(
"
bicubicColor
.
a
=
saturate
(
bicubicColor
.
a
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
bicubicColor
.
rgb
=
max
(
half3
(
0
.
0
)
min
(
bicubicColor
.
rgb
bicubicColor
.
aaa
)
)
;
"
)
;
}
else
{
fragBuilder
-
>
codeAppend
(
"
bicubicColor
=
saturate
(
bicubicColor
)
;
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
%
s
=
bicubicColor
*
%
s
;
"
args
.
fOutputColor
args
.
fInputColor
)
;
}
void
GrGLBicubicEffect
:
:
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
processor
)
{
const
GrBicubicEffect
&
bicubicEffect
=
processor
.
cast
<
GrBicubicEffect
>
(
)
;
GrTextureProxy
*
proxy
=
processor
.
textureSampler
(
0
)
.
proxy
(
)
;
GrTexture
*
texture
=
proxy
-
>
peekTexture
(
)
;
float
dims
[
4
]
=
{
0
0
0
0
}
;
if
(
bicubicEffect
.
direction
(
)
!
=
GrBicubicEffect
:
:
Direction
:
:
kY
)
{
dims
[
0
]
=
1
.
0f
/
texture
-
>
width
(
)
;
dims
[
2
]
=
texture
-
>
width
(
)
;
}
if
(
bicubicEffect
.
direction
(
)
!
=
GrBicubicEffect
:
:
Direction
:
:
kX
)
{
dims
[
1
]
=
1
.
0f
/
texture
-
>
height
(
)
;
dims
[
3
]
=
texture
-
>
height
(
)
;
}
pdman
.
set4fv
(
fDimensions
1
dims
)
;
fDomain
.
setData
(
pdman
bicubicEffect
.
domain
(
)
proxy
processor
.
textureSampler
(
0
)
.
samplerState
(
)
)
;
}
GrBicubicEffect
:
:
GrBicubicEffect
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
const
SkMatrix
&
matrix
const
SkRect
&
domain
const
GrSamplerState
:
:
WrapMode
wrapModes
[
2
]
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
Direction
direction
SkAlphaType
alphaType
)
:
INHERITED
{
kGrBicubicEffect_ClassID
ModulateForSamplerOptFlags
(
srcColorType
GrTextureDomain
:
:
IsDecalSampled
(
wrapModes
modeX
modeY
)
)
}
fCoordTransform
(
matrix
proxy
.
get
(
)
)
fDomain
(
proxy
.
get
(
)
domain
modeX
modeY
)
fTextureSampler
(
std
:
:
move
(
proxy
)
GrSamplerState
(
wrapModes
GrSamplerState
:
:
Filter
:
:
kNearest
)
)
fAlphaType
(
alphaType
)
fDirection
(
direction
)
{
this
-
>
addCoordTransform
(
&
fCoordTransform
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
GrBicubicEffect
:
:
GrBicubicEffect
(
const
GrBicubicEffect
&
that
)
:
INHERITED
(
kGrBicubicEffect_ClassID
that
.
optimizationFlags
(
)
)
fCoordTransform
(
that
.
fCoordTransform
)
fDomain
(
that
.
fDomain
)
fTextureSampler
(
that
.
fTextureSampler
)
fAlphaType
(
that
.
fAlphaType
)
fDirection
(
that
.
fDirection
)
{
this
-
>
addCoordTransform
(
&
fCoordTransform
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
void
GrBicubicEffect
:
:
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
GrGLBicubicEffect
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLFragmentProcessor
*
GrBicubicEffect
:
:
onCreateGLSLInstance
(
)
const
{
return
new
GrGLBicubicEffect
;
}
bool
GrBicubicEffect
:
:
onIsEqual
(
const
GrFragmentProcessor
&
sBase
)
const
{
const
GrBicubicEffect
&
s
=
sBase
.
cast
<
GrBicubicEffect
>
(
)
;
return
fDomain
=
=
s
.
fDomain
&
&
fDirection
=
=
s
.
fDirection
&
&
fAlphaType
=
=
s
.
fAlphaType
;
}
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrBicubicEffect
)
;
#
if
GR_TEST_UTILS
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrBicubicEffect
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
int
texIdx
=
d
-
>
fRandom
-
>
nextBool
(
)
?
GrProcessorUnitTest
:
:
kSkiaPMTextureIdx
:
GrProcessorUnitTest
:
:
kAlphaTextureIdx
;
static
const
GrSamplerState
:
:
WrapMode
kClampClamp
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrSamplerState
:
:
WrapMode
:
:
kClamp
}
;
SkAlphaType
alphaType
=
d
-
>
fRandom
-
>
nextBool
(
)
?
kPremul_SkAlphaType
:
kUnpremul_SkAlphaType
;
Direction
direction
=
Direction
:
:
kX
;
switch
(
d
-
>
fRandom
-
>
nextULessThan
(
3
)
)
{
case
0
:
direction
=
Direction
:
:
kX
;
break
;
case
1
:
direction
=
Direction
:
:
kY
;
break
;
case
2
:
direction
=
Direction
:
:
kXY
;
break
;
}
return
GrBicubicEffect
:
:
Make
(
d
-
>
textureProxy
(
texIdx
)
d
-
>
textureProxyColorType
(
texIdx
)
SkMatrix
:
:
I
(
)
kClampClamp
direction
alphaType
)
;
}
#
endif
bool
GrBicubicEffect
:
:
ShouldUseBicubic
(
const
SkMatrix
&
matrix
GrSamplerState
:
:
Filter
*
filterMode
)
{
switch
(
SkMatrixPriv
:
:
AdjustHighQualityFilterLevel
(
matrix
)
)
{
case
kNone_SkFilterQuality
:
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
kLow_SkFilterQuality
:
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
case
kMedium_SkFilterQuality
:
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kMipMap
;
break
;
case
kHigh_SkFilterQuality
:
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
return
true
;
}
return
false
;
}
