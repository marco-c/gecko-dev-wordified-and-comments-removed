#
include
"
GrBicubicEffect
.
h
"
#
include
"
GrProxyMove
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
glsl
/
GrGLSLColorSpaceXformHelper
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
.
.
/
private
/
GrGLSL
.
h
"
class
GrGLBicubicEffect
:
public
GrGLSLFragmentProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
static
inline
void
GenKey
(
const
GrProcessor
&
effect
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
GrBicubicEffect
&
bicubicEffect
=
effect
.
cast
<
GrBicubicEffect
>
(
)
;
b
-
>
add32
(
GrTextureDomain
:
:
GLDomain
:
:
DomainKey
(
bicubicEffect
.
domain
(
)
)
)
;
b
-
>
add32
(
GrColorSpaceXform
:
:
XformKey
(
bicubicEffect
.
colorSpaceXform
(
)
)
)
;
}
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
override
;
private
:
typedef
GrGLSLProgramDataManager
:
:
UniformHandle
UniformHandle
;
UniformHandle
fImageIncrementUni
;
GrGLSLColorSpaceXformHelper
fColorSpaceHelper
;
GrTextureDomain
:
:
GLDomain
fDomain
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
void
GrGLBicubicEffect
:
:
emitCode
(
EmitArgs
&
args
)
{
const
GrBicubicEffect
&
bicubicEffect
=
args
.
fFp
.
cast
<
GrBicubicEffect
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
fImageIncrementUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kVec2f_GrSLType
kDefault_GrSLPrecision
"
ImageIncrement
"
)
;
const
char
*
imgInc
=
uniformHandler
-
>
getUniformCStr
(
fImageIncrementUni
)
;
fColorSpaceHelper
.
emitCode
(
uniformHandler
bicubicEffect
.
colorSpaceXform
(
)
)
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
SkString
coords2D
=
fragBuilder
-
>
ensureCoords2D
(
args
.
fTransformedCoords
[
0
]
)
;
fragBuilder
-
>
codeAppend
(
"
mat4
kMitchellCoefficients
=
mat4
(
"
"
1
.
0
/
18
.
0
16
.
0
/
18
.
0
1
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
-
9
.
0
/
18
.
0
0
.
0
/
18
.
0
9
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
15
.
0
/
18
.
0
-
36
.
0
/
18
.
0
27
.
0
/
18
.
0
-
6
.
0
/
18
.
0
"
"
-
7
.
0
/
18
.
0
21
.
0
/
18
.
0
-
21
.
0
/
18
.
0
7
.
0
/
18
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
coord
=
%
s
-
%
s
*
vec2
(
0
.
5
)
;
"
coords2D
.
c_str
(
)
imgInc
)
;
fragBuilder
-
>
codeAppendf
(
"
coord
/
=
%
s
;
"
imgInc
)
;
fragBuilder
-
>
codeAppend
(
"
vec2
f
=
fract
(
coord
)
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
coord
=
(
coord
-
f
+
vec2
(
0
.
5
)
)
*
%
s
;
"
imgInc
)
;
fragBuilder
-
>
codeAppend
(
"
vec4
wx
=
kMitchellCoefficients
*
vec4
(
1
.
0
f
.
x
f
.
x
*
f
.
x
f
.
x
*
f
.
x
*
f
.
x
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
vec4
wy
=
kMitchellCoefficients
*
vec4
(
1
.
0
f
.
y
f
.
y
*
f
.
y
f
.
y
*
f
.
y
*
f
.
y
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
vec4
rowColors
[
4
]
;
"
)
;
for
(
int
y
=
0
;
y
<
4
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
4
;
+
+
x
)
{
SkString
coord
;
coord
.
printf
(
"
coord
+
%
s
*
vec2
(
%
d
%
d
)
"
imgInc
x
-
1
y
-
1
)
;
SkString
sampleVar
;
sampleVar
.
printf
(
"
rowColors
[
%
d
]
"
x
)
;
fDomain
.
sampleTexture
(
fragBuilder
args
.
fUniformHandler
args
.
fShaderCaps
bicubicEffect
.
domain
(
)
sampleVar
.
c_str
(
)
coord
args
.
fTexSamplers
[
0
]
)
;
}
fragBuilder
-
>
codeAppendf
(
"
vec4
s
%
d
=
wx
.
x
*
rowColors
[
0
]
+
wx
.
y
*
rowColors
[
1
]
+
wx
.
z
*
rowColors
[
2
]
+
wx
.
w
*
rowColors
[
3
]
;
"
y
)
;
}
SkString
bicubicColor
(
"
(
wy
.
x
*
s0
+
wy
.
y
*
s1
+
wy
.
z
*
s2
+
wy
.
w
*
s3
)
"
)
;
if
(
fColorSpaceHelper
.
isValid
(
)
)
{
SkString
xformedColor
;
fragBuilder
-
>
appendColorGamutXform
(
&
xformedColor
bicubicColor
.
c_str
(
)
&
fColorSpaceHelper
)
;
bicubicColor
.
swap
(
xformedColor
)
;
}
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
args
.
fOutputColor
(
GrGLSLExpr4
(
bicubicColor
.
c_str
(
)
)
*
GrGLSLExpr4
(
args
.
fInputColor
)
)
.
c_str
(
)
)
;
}
void
GrGLBicubicEffect
:
:
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
processor
)
{
const
GrBicubicEffect
&
bicubicEffect
=
processor
.
cast
<
GrBicubicEffect
>
(
)
;
GrTexture
*
texture
=
processor
.
textureSampler
(
0
)
.
texture
(
)
;
float
imageIncrement
[
2
]
;
imageIncrement
[
0
]
=
1
.
0f
/
texture
-
>
width
(
)
;
imageIncrement
[
1
]
=
1
.
0f
/
texture
-
>
height
(
)
;
pdman
.
set2fv
(
fImageIncrementUni
1
imageIncrement
)
;
fDomain
.
setData
(
pdman
bicubicEffect
.
domain
(
)
texture
)
;
if
(
SkToBool
(
bicubicEffect
.
colorSpaceXform
(
)
)
)
{
fColorSpaceHelper
.
setData
(
pdman
bicubicEffect
.
colorSpaceXform
(
)
)
;
}
}
GrBicubicEffect
:
:
GrBicubicEffect
(
GrResourceProvider
*
resourceProvider
sk_sp
<
GrTextureProxy
>
proxy
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
const
SkMatrix
&
matrix
const
SkShader
:
:
TileMode
tileModes
[
2
]
)
:
INHERITED
{
resourceProvider
ModulationFlags
(
proxy
-
>
config
(
)
)
GR_PROXY_MOVE
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
matrix
GrSamplerParams
(
tileModes
GrSamplerParams
:
:
kNone_FilterMode
)
}
fDomain
(
GrTextureDomain
:
:
IgnoredDomain
(
)
)
{
this
-
>
initClassID
<
GrBicubicEffect
>
(
)
;
}
GrBicubicEffect
:
:
GrBicubicEffect
(
GrResourceProvider
*
resourceProvider
sk_sp
<
GrTextureProxy
>
proxy
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
const
SkMatrix
&
matrix
const
SkRect
&
domain
)
:
INHERITED
(
resourceProvider
ModulationFlags
(
proxy
-
>
config
(
)
)
proxy
std
:
:
move
(
colorSpaceXform
)
matrix
GrSamplerParams
(
SkShader
:
:
kClamp_TileMode
GrSamplerParams
:
:
kNone_FilterMode
)
)
fDomain
(
proxy
.
get
(
)
domain
GrTextureDomain
:
:
kClamp_Mode
)
{
this
-
>
initClassID
<
GrBicubicEffect
>
(
)
;
}
GrBicubicEffect
:
:
~
GrBicubicEffect
(
)
{
}
void
GrBicubicEffect
:
:
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
GrGLBicubicEffect
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLFragmentProcessor
*
GrBicubicEffect
:
:
onCreateGLSLInstance
(
)
const
{
return
new
GrGLBicubicEffect
;
}
bool
GrBicubicEffect
:
:
onIsEqual
(
const
GrFragmentProcessor
&
sBase
)
const
{
const
GrBicubicEffect
&
s
=
sBase
.
cast
<
GrBicubicEffect
>
(
)
;
return
fDomain
=
=
s
.
fDomain
;
}
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrBicubicEffect
)
;
#
if
GR_TEST_UTILS
sk_sp
<
GrFragmentProcessor
>
GrBicubicEffect
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
int
texIdx
=
d
-
>
fRandom
-
>
nextBool
(
)
?
GrProcessorUnitTest
:
:
kSkiaPMTextureIdx
:
GrProcessorUnitTest
:
:
kAlphaTextureIdx
;
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
=
GrTest
:
:
TestColorXform
(
d
-
>
fRandom
)
;
static
const
SkShader
:
:
TileMode
kClampClamp
[
]
=
{
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
}
;
return
GrBicubicEffect
:
:
Make
(
d
-
>
resourceProvider
(
)
d
-
>
textureProxy
(
texIdx
)
std
:
:
move
(
colorSpaceXform
)
SkMatrix
:
:
I
(
)
kClampClamp
)
;
}
#
endif
bool
GrBicubicEffect
:
:
ShouldUseBicubic
(
const
SkMatrix
&
matrix
GrSamplerParams
:
:
FilterMode
*
filterMode
)
{
if
(
matrix
.
isIdentity
(
)
)
{
*
filterMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
return
false
;
}
SkScalar
scales
[
2
]
;
if
(
!
matrix
.
getMinMaxScales
(
scales
)
|
|
scales
[
0
]
<
SK_Scalar1
)
{
*
filterMode
=
GrSamplerParams
:
:
kMipMap_FilterMode
;
return
false
;
}
if
(
scales
[
1
]
=
=
SK_Scalar1
)
{
if
(
matrix
.
rectStaysRect
(
)
&
&
SkScalarIsInt
(
matrix
.
getTranslateX
(
)
)
&
&
SkScalarIsInt
(
matrix
.
getTranslateY
(
)
)
)
{
*
filterMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
}
else
{
*
filterMode
=
GrSamplerParams
:
:
kBilerp_FilterMode
;
}
return
false
;
}
*
filterMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
return
true
;
}
