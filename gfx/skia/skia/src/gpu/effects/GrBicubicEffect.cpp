#
include
"
GrBicubicEffect
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
class
GrGLBicubicEffect
:
public
GrGLSLFragmentProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
static
inline
void
GenKey
(
const
GrProcessor
&
effect
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
GrBicubicEffect
&
bicubicEffect
=
effect
.
cast
<
GrBicubicEffect
>
(
)
;
b
-
>
add32
(
GrTextureDomain
:
:
GLDomain
:
:
DomainKey
(
bicubicEffect
.
domain
(
)
)
)
;
}
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
override
;
private
:
typedef
GrGLSLProgramDataManager
:
:
UniformHandle
UniformHandle
;
UniformHandle
fImageIncrementUni
;
GrTextureDomain
:
:
GLDomain
fDomain
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
void
GrGLBicubicEffect
:
:
emitCode
(
EmitArgs
&
args
)
{
const
GrBicubicEffect
&
bicubicEffect
=
args
.
fFp
.
cast
<
GrBicubicEffect
>
(
)
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
fImageIncrementUni
=
uniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kHalf2_GrSLType
"
ImageIncrement
"
)
;
const
char
*
imgInc
=
uniformHandler
-
>
getUniformCStr
(
fImageIncrementUni
)
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
SkString
coords2D
=
fragBuilder
-
>
ensureCoords2D
(
args
.
fTransformedCoords
[
0
]
)
;
fragBuilder
-
>
codeAppend
(
"
half4x4
kMitchellCoefficients
=
half4x4
(
"
"
1
.
0
/
18
.
0
16
.
0
/
18
.
0
1
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
-
9
.
0
/
18
.
0
0
.
0
/
18
.
0
9
.
0
/
18
.
0
0
.
0
/
18
.
0
"
"
15
.
0
/
18
.
0
-
36
.
0
/
18
.
0
27
.
0
/
18
.
0
-
6
.
0
/
18
.
0
"
"
-
7
.
0
/
18
.
0
21
.
0
/
18
.
0
-
21
.
0
/
18
.
0
7
.
0
/
18
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
float2
coord
=
%
s
-
%
s
*
float2
(
0
.
5
)
;
"
coords2D
.
c_str
(
)
imgInc
)
;
fragBuilder
-
>
codeAppendf
(
"
coord
/
=
%
s
;
"
imgInc
)
;
fragBuilder
-
>
codeAppend
(
"
half2
f
=
half2
(
fract
(
coord
)
)
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
coord
=
(
coord
-
f
+
half2
(
0
.
5
)
)
*
%
s
;
"
imgInc
)
;
fragBuilder
-
>
codeAppend
(
"
half4
wx
=
kMitchellCoefficients
*
half4
(
1
.
0
f
.
x
f
.
x
*
f
.
x
f
.
x
*
f
.
x
*
f
.
x
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
wy
=
kMitchellCoefficients
*
half4
(
1
.
0
f
.
y
f
.
y
*
f
.
y
f
.
y
*
f
.
y
*
f
.
y
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
half4
rowColors
[
4
]
;
"
)
;
for
(
int
y
=
0
;
y
<
4
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
4
;
+
+
x
)
{
SkString
coord
;
coord
.
printf
(
"
coord
+
%
s
*
float2
(
%
d
%
d
)
"
imgInc
x
-
1
y
-
1
)
;
SkString
sampleVar
;
sampleVar
.
printf
(
"
rowColors
[
%
d
]
"
x
)
;
fDomain
.
sampleTexture
(
fragBuilder
args
.
fUniformHandler
args
.
fShaderCaps
bicubicEffect
.
domain
(
)
sampleVar
.
c_str
(
)
coord
args
.
fTexSamplers
[
0
]
)
;
}
fragBuilder
-
>
codeAppendf
(
"
half4
s
%
d
=
wx
.
x
*
rowColors
[
0
]
+
wx
.
y
*
rowColors
[
1
]
+
wx
.
z
*
rowColors
[
2
]
+
wx
.
w
*
rowColors
[
3
]
;
"
y
)
;
}
SkString
bicubicColor
(
"
(
wy
.
x
*
s0
+
wy
.
y
*
s1
+
wy
.
z
*
s2
+
wy
.
w
*
s3
)
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
*
%
s
;
"
args
.
fOutputColor
bicubicColor
.
c_str
(
)
args
.
fInputColor
)
;
}
void
GrGLBicubicEffect
:
:
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrFragmentProcessor
&
processor
)
{
const
GrBicubicEffect
&
bicubicEffect
=
processor
.
cast
<
GrBicubicEffect
>
(
)
;
GrTextureProxy
*
proxy
=
processor
.
textureSampler
(
0
)
.
proxy
(
)
;
GrTexture
*
texture
=
proxy
-
>
peekTexture
(
)
;
float
imageIncrement
[
2
]
;
imageIncrement
[
0
]
=
1
.
0f
/
texture
-
>
width
(
)
;
imageIncrement
[
1
]
=
1
.
0f
/
texture
-
>
height
(
)
;
pdman
.
set2fv
(
fImageIncrementUni
1
imageIncrement
)
;
fDomain
.
setData
(
pdman
bicubicEffect
.
domain
(
)
proxy
processor
.
textureSampler
(
0
)
.
samplerState
(
)
)
;
}
GrBicubicEffect
:
:
GrBicubicEffect
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkMatrix
&
matrix
const
SkRect
&
domain
const
GrSamplerState
:
:
WrapMode
wrapModes
[
2
]
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
)
:
INHERITED
{
kGrBicubicEffect_ClassID
ModulateForSamplerOptFlags
(
proxy
-
>
config
(
)
GrTextureDomain
:
:
IsDecalSampled
(
wrapModes
modeX
modeY
)
)
}
fCoordTransform
(
matrix
proxy
.
get
(
)
)
fDomain
(
proxy
.
get
(
)
domain
modeX
modeY
)
fTextureSampler
(
std
:
:
move
(
proxy
)
GrSamplerState
(
wrapModes
GrSamplerState
:
:
Filter
:
:
kNearest
)
)
{
this
-
>
addCoordTransform
(
&
fCoordTransform
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
GrBicubicEffect
:
:
GrBicubicEffect
(
const
GrBicubicEffect
&
that
)
:
INHERITED
(
kGrBicubicEffect_ClassID
that
.
optimizationFlags
(
)
)
fCoordTransform
(
that
.
fCoordTransform
)
fDomain
(
that
.
fDomain
)
fTextureSampler
(
that
.
fTextureSampler
)
{
this
-
>
addCoordTransform
(
&
fCoordTransform
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
}
void
GrBicubicEffect
:
:
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
GrGLBicubicEffect
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLFragmentProcessor
*
GrBicubicEffect
:
:
onCreateGLSLInstance
(
)
const
{
return
new
GrGLBicubicEffect
;
}
bool
GrBicubicEffect
:
:
onIsEqual
(
const
GrFragmentProcessor
&
sBase
)
const
{
const
GrBicubicEffect
&
s
=
sBase
.
cast
<
GrBicubicEffect
>
(
)
;
return
fDomain
=
=
s
.
fDomain
;
}
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrBicubicEffect
)
;
#
if
GR_TEST_UTILS
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrBicubicEffect
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
int
texIdx
=
d
-
>
fRandom
-
>
nextBool
(
)
?
GrProcessorUnitTest
:
:
kSkiaPMTextureIdx
:
GrProcessorUnitTest
:
:
kAlphaTextureIdx
;
static
const
GrSamplerState
:
:
WrapMode
kClampClamp
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrSamplerState
:
:
WrapMode
:
:
kClamp
}
;
return
GrBicubicEffect
:
:
Make
(
d
-
>
textureProxy
(
texIdx
)
SkMatrix
:
:
I
(
)
kClampClamp
)
;
}
#
endif
bool
GrBicubicEffect
:
:
ShouldUseBicubic
(
const
SkMatrix
&
matrix
GrSamplerState
:
:
Filter
*
filterMode
)
{
if
(
matrix
.
isIdentity
(
)
)
{
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
return
false
;
}
SkScalar
scales
[
2
]
;
if
(
!
matrix
.
getMinMaxScales
(
scales
)
|
|
scales
[
0
]
<
SK_Scalar1
)
{
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kMipMap
;
return
false
;
}
if
(
scales
[
1
]
=
=
SK_Scalar1
)
{
if
(
matrix
.
rectStaysRect
(
)
&
&
SkScalarIsInt
(
matrix
.
getTranslateX
(
)
)
&
&
SkScalarIsInt
(
matrix
.
getTranslateY
(
)
)
)
{
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
}
else
{
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
}
return
false
;
}
*
filterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
return
true
;
}
