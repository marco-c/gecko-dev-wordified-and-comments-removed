#
ifndef
GrBicubicTextureEffect_DEFINED
#
define
GrBicubicTextureEffect_DEFINED
#
include
"
src
/
gpu
/
effects
/
GrTextureDomain
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentProcessor
.
h
"
class
GrInvariantOutput
;
class
GrBicubicEffect
:
public
GrFragmentProcessor
{
public
:
enum
{
kFilterTexelPad
=
2
}
;
enum
class
Direction
{
kX
kY
kXY
}
;
const
char
*
name
(
)
const
override
{
return
"
Bicubic
"
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrBicubicEffect
(
*
this
)
)
;
}
const
GrTextureDomain
&
domain
(
)
const
{
return
fDomain
;
}
Direction
direction
(
)
const
{
return
fDirection
;
}
SkAlphaType
alphaType
(
)
const
{
return
fAlphaType
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
const
SkMatrix
&
matrix
Direction
direction
SkAlphaType
alphaType
)
{
static
constexpr
GrSamplerState
:
:
WrapMode
kClampClamp
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrSamplerState
:
:
WrapMode
:
:
kClamp
}
;
return
Make
(
std
:
:
move
(
proxy
)
srcColorType
matrix
kClampClamp
GrTextureDomain
:
:
kIgnore_Mode
GrTextureDomain
:
:
kIgnore_Mode
direction
alphaType
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
const
SkMatrix
&
matrix
const
GrSamplerState
:
:
WrapMode
wrapModes
[
2
]
Direction
direction
SkAlphaType
alphaType
)
{
return
Make
(
std
:
:
move
(
proxy
)
srcColorType
matrix
wrapModes
GrTextureDomain
:
:
kIgnore_Mode
GrTextureDomain
:
:
kIgnore_Mode
direction
alphaType
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
const
SkMatrix
&
matrix
const
GrSamplerState
:
:
WrapMode
wrapModes
[
2
]
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
Direction
direction
SkAlphaType
alphaType
const
SkRect
*
domain
=
nullptr
)
{
SkRect
resolvedDomain
=
domain
?
*
domain
:
GrTextureDomain
:
:
MakeTexelDomain
(
SkIRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
modeX
modeY
)
;
return
std
:
:
unique_ptr
<
GrFragmentProcessor
>
(
new
GrBicubicEffect
(
std
:
:
move
(
proxy
)
srcColorType
matrix
resolvedDomain
wrapModes
modeX
modeY
direction
alphaType
)
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
Make
(
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
const
SkMatrix
&
matrix
const
SkRect
&
domain
Direction
direction
SkAlphaType
alphaType
)
{
static
const
GrSamplerState
:
:
WrapMode
kClampClamp
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrSamplerState
:
:
WrapMode
:
:
kClamp
}
;
return
Make
(
std
:
:
move
(
proxy
)
srcColorType
matrix
kClampClamp
GrTextureDomain
:
:
kClamp_Mode
GrTextureDomain
:
:
kClamp_Mode
direction
alphaType
&
domain
)
;
}
static
bool
ShouldUseBicubic
(
const
SkMatrix
&
localCoordsToDevice
GrSamplerState
:
:
Filter
*
filterMode
)
;
private
:
GrBicubicEffect
(
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
const
SkMatrix
&
matrix
const
SkRect
&
domain
const
GrSamplerState
:
:
WrapMode
wrapModes
[
2
]
GrTextureDomain
:
:
Mode
modeX
GrTextureDomain
:
:
Mode
modeY
Direction
direction
SkAlphaType
alphaType
)
;
explicit
GrBicubicEffect
(
const
GrBicubicEffect
&
)
;
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
;
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
TextureSampler
&
onTextureSampler
(
int
)
const
override
{
return
fTextureSampler
;
}
GrCoordTransform
fCoordTransform
;
GrTextureDomain
fDomain
;
TextureSampler
fTextureSampler
;
SkAlphaType
fAlphaType
;
Direction
fDirection
;
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
typedef
GrFragmentProcessor
INHERITED
;
}
;
#
endif
