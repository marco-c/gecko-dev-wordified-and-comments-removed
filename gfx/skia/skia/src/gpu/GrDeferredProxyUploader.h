#
ifndef
GrDeferredProxyUploader_DEFINED
#
define
GrDeferredProxyUploader_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkSemaphore
.
h
"
#
include
"
src
/
core
/
SkAutoPixmapStorage
.
h
"
#
include
"
src
/
core
/
SkMakeUnique
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxyPriv
.
h
"
class
GrDeferredProxyUploader
:
public
SkNoncopyable
{
public
:
GrDeferredProxyUploader
(
)
:
fScheduledUpload
(
false
)
fWaited
(
false
)
{
}
virtual
~
GrDeferredProxyUploader
(
)
{
this
-
>
wait
(
)
;
}
void
scheduleUpload
(
GrOpFlushState
*
flushState
GrTextureProxy
*
proxy
)
{
if
(
fScheduledUpload
)
{
return
;
}
auto
uploadMask
=
[
this
proxy
]
(
GrDeferredTextureUploadWritePixelsFn
&
writePixelsFn
)
{
this
-
>
wait
(
)
;
GrColorType
pixelColorType
=
SkColorTypeToGrColorType
(
this
-
>
fPixels
.
info
(
)
.
colorType
(
)
)
;
if
(
this
-
>
fPixels
.
addr
(
)
)
{
writePixelsFn
(
proxy
0
0
this
-
>
fPixels
.
width
(
)
this
-
>
fPixels
.
height
(
)
pixelColorType
this
-
>
fPixels
.
addr
(
)
this
-
>
fPixels
.
rowBytes
(
)
)
;
}
proxy
-
>
texPriv
(
)
.
resetDeferredUploader
(
)
;
}
;
flushState
-
>
addASAPUpload
(
std
:
:
move
(
uploadMask
)
)
;
fScheduledUpload
=
true
;
}
void
signalAndFreeData
(
)
{
this
-
>
freeData
(
)
;
fPixelsReady
.
signal
(
)
;
}
SkAutoPixmapStorage
*
getPixels
(
)
{
return
&
fPixels
;
}
protected
:
void
wait
(
)
{
if
(
!
fWaited
)
{
fPixelsReady
.
wait
(
)
;
fWaited
=
true
;
}
}
private
:
virtual
void
freeData
(
)
{
}
SkAutoPixmapStorage
fPixels
;
SkSemaphore
fPixelsReady
;
bool
fScheduledUpload
;
bool
fWaited
;
}
;
template
<
typename
T
>
class
GrTDeferredProxyUploader
:
public
GrDeferredProxyUploader
{
public
:
template
<
typename
.
.
.
Args
>
GrTDeferredProxyUploader
(
Args
&
&
.
.
.
args
)
:
fData
(
skstd
:
:
make_unique
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
{
}
~
GrTDeferredProxyUploader
(
)
override
{
this
-
>
wait
(
)
;
}
T
&
data
(
)
{
return
*
fData
;
}
private
:
void
freeData
(
)
override
{
fData
.
reset
(
)
;
}
std
:
:
unique_ptr
<
T
>
fData
;
}
;
#
endif
