#
include
"
GrBuffer
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrCaps
.
h
"
GrBuffer
*
GrBuffer
:
:
CreateCPUBacked
(
GrGpu
*
gpu
size_t
sizeInBytes
GrBufferType
intendedType
const
void
*
data
)
{
SkASSERT
(
GrBufferTypeIsVertexOrIndex
(
intendedType
)
)
;
void
*
cpuData
;
if
(
gpu
-
>
caps
(
)
-
>
mustClearUploadedBufferData
(
)
)
{
cpuData
=
sk_calloc_throw
(
sizeInBytes
)
;
}
else
{
cpuData
=
sk_malloc_flags
(
sizeInBytes
SK_MALLOC_THROW
)
;
}
if
(
data
)
{
memcpy
(
cpuData
data
sizeInBytes
)
;
}
return
new
GrBuffer
(
gpu
sizeInBytes
intendedType
cpuData
)
;
}
GrBuffer
:
:
GrBuffer
(
GrGpu
*
gpu
size_t
sizeInBytes
GrBufferType
type
void
*
cpuData
)
:
INHERITED
(
gpu
)
fMapPtr
(
nullptr
)
fSizeInBytes
(
sizeInBytes
)
fAccessPattern
(
kDynamic_GrAccessPattern
)
fCPUData
(
cpuData
)
fIntendedType
(
type
)
{
this
-
>
registerWithCache
(
SkBudgeted
:
:
kNo
)
;
}
GrBuffer
:
:
GrBuffer
(
GrGpu
*
gpu
size_t
sizeInBytes
GrBufferType
type
GrAccessPattern
pattern
)
:
INHERITED
(
gpu
)
fMapPtr
(
nullptr
)
fSizeInBytes
(
sizeInBytes
)
fAccessPattern
(
pattern
)
fCPUData
(
nullptr
)
fIntendedType
(
type
)
{
}
void
GrBuffer
:
:
ComputeScratchKeyForDynamicVBO
(
size_t
size
GrBufferType
intendedType
GrScratchKey
*
key
)
{
static
const
GrScratchKey
:
:
ResourceType
kType
=
GrScratchKey
:
:
GenerateResourceType
(
)
;
GrScratchKey
:
:
Builder
builder
(
key
kType
1
+
(
sizeof
(
size_t
)
+
3
)
/
4
)
;
builder
[
0
]
=
intendedType
;
builder
[
1
]
=
(
uint32_t
)
size
;
if
(
sizeof
(
size_t
)
>
4
)
{
builder
[
2
]
=
(
uint32_t
)
(
(
uint64_t
)
size
>
>
32
)
;
}
}
bool
GrBuffer
:
:
onUpdateData
(
const
void
*
src
size_t
srcSizeInBytes
)
{
SkASSERT
(
this
-
>
isCPUBacked
(
)
)
;
memcpy
(
fCPUData
src
srcSizeInBytes
)
;
return
true
;
}
void
GrBuffer
:
:
computeScratchKey
(
GrScratchKey
*
key
)
const
{
if
(
!
this
-
>
isCPUBacked
(
)
&
&
SkIsPow2
(
fSizeInBytes
)
&
&
kDynamic_GrAccessPattern
=
=
fAccessPattern
)
{
ComputeScratchKeyForDynamicVBO
(
fSizeInBytes
fIntendedType
key
)
;
}
}
