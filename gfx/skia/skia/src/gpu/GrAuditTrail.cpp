#
include
"
src
/
gpu
/
GrAuditTrail
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrOp
.
h
"
#
include
"
src
/
utils
/
SkJSONWriter
.
h
"
const
int
GrAuditTrail
:
:
kGrAuditTrailInvalidID
=
-
1
;
void
GrAuditTrail
:
:
addOp
(
const
GrOp
*
op
GrRenderTargetProxy
:
:
UniqueID
proxyID
)
{
SkASSERT
(
fEnabled
)
;
Op
*
auditOp
=
new
Op
;
fOpPool
.
emplace_back
(
auditOp
)
;
auditOp
-
>
fName
=
op
-
>
name
(
)
;
auditOp
-
>
fBounds
=
op
-
>
bounds
(
)
;
auditOp
-
>
fClientID
=
kGrAuditTrailInvalidID
;
auditOp
-
>
fOpsTaskID
=
kGrAuditTrailInvalidID
;
auditOp
-
>
fChildID
=
kGrAuditTrailInvalidID
;
auditOp
-
>
fStackTrace
=
fCurrentStackTrace
;
fCurrentStackTrace
.
reset
(
)
;
if
(
fClientID
!
=
kGrAuditTrailInvalidID
)
{
auditOp
-
>
fClientID
=
fClientID
;
Ops
*
*
opsLookup
=
fClientIDLookup
.
find
(
fClientID
)
;
Ops
*
ops
=
nullptr
;
if
(
!
opsLookup
)
{
ops
=
new
Ops
;
fClientIDLookup
.
set
(
fClientID
ops
)
;
}
else
{
ops
=
*
opsLookup
;
}
ops
-
>
push_back
(
auditOp
)
;
}
auditOp
-
>
fOpsTaskID
=
fOpsTask
.
count
(
)
;
auditOp
-
>
fChildID
=
0
;
fIDLookup
.
set
(
op
-
>
uniqueID
(
)
auditOp
-
>
fOpsTaskID
)
;
OpNode
*
opNode
=
new
OpNode
(
proxyID
)
;
opNode
-
>
fBounds
=
op
-
>
bounds
(
)
;
opNode
-
>
fChildren
.
push_back
(
auditOp
)
;
fOpsTask
.
emplace_back
(
opNode
)
;
}
void
GrAuditTrail
:
:
opsCombined
(
const
GrOp
*
consumer
const
GrOp
*
consumed
)
{
int
*
indexPtr
=
fIDLookup
.
find
(
consumer
-
>
uniqueID
(
)
)
;
SkASSERT
(
indexPtr
)
;
int
index
=
*
indexPtr
;
SkASSERT
(
index
<
fOpsTask
.
count
(
)
&
&
fOpsTask
[
index
]
)
;
OpNode
&
consumerOp
=
*
fOpsTask
[
index
]
;
int
*
consumedPtr
=
fIDLookup
.
find
(
consumed
-
>
uniqueID
(
)
)
;
SkASSERT
(
consumedPtr
)
;
int
consumedIndex
=
*
consumedPtr
;
SkASSERT
(
consumedIndex
<
fOpsTask
.
count
(
)
&
&
fOpsTask
[
consumedIndex
]
)
;
OpNode
&
consumedOp
=
*
fOpsTask
[
consumedIndex
]
;
for
(
int
i
=
0
;
i
<
consumedOp
.
fChildren
.
count
(
)
;
i
+
+
)
{
Op
*
childOp
=
consumedOp
.
fChildren
[
i
]
;
childOp
-
>
fOpsTaskID
=
index
;
childOp
-
>
fChildID
=
consumerOp
.
fChildren
.
count
(
)
;
consumerOp
.
fChildren
.
push_back
(
childOp
)
;
}
consumerOp
.
fBounds
=
consumer
-
>
bounds
(
)
;
fOpsTask
[
consumedIndex
]
.
reset
(
nullptr
)
;
fIDLookup
.
remove
(
consumed
-
>
uniqueID
(
)
)
;
}
void
GrAuditTrail
:
:
copyOutFromOpsTask
(
OpInfo
*
outOpInfo
int
opsTaskID
)
{
SkASSERT
(
opsTaskID
<
fOpsTask
.
count
(
)
)
;
const
OpNode
*
bn
=
fOpsTask
[
opsTaskID
]
.
get
(
)
;
SkASSERT
(
bn
)
;
outOpInfo
-
>
fBounds
=
bn
-
>
fBounds
;
outOpInfo
-
>
fProxyUniqueID
=
bn
-
>
fProxyUniqueID
;
for
(
int
j
=
0
;
j
<
bn
-
>
fChildren
.
count
(
)
;
j
+
+
)
{
OpInfo
:
:
Op
&
outOp
=
outOpInfo
-
>
fOps
.
push_back
(
)
;
const
Op
*
currentOp
=
bn
-
>
fChildren
[
j
]
;
outOp
.
fBounds
=
currentOp
-
>
fBounds
;
outOp
.
fClientID
=
currentOp
-
>
fClientID
;
}
}
void
GrAuditTrail
:
:
getBoundsByClientID
(
SkTArray
<
OpInfo
>
*
outInfo
int
clientID
)
{
Ops
*
*
opsLookup
=
fClientIDLookup
.
find
(
clientID
)
;
if
(
opsLookup
)
{
int
currentOpsTaskID
=
kGrAuditTrailInvalidID
;
for
(
int
i
=
0
;
i
<
(
*
opsLookup
)
-
>
count
(
)
;
i
+
+
)
{
const
Op
*
op
=
(
*
*
opsLookup
)
[
i
]
;
if
(
kGrAuditTrailInvalidID
=
=
currentOpsTaskID
|
|
op
-
>
fOpsTaskID
!
=
currentOpsTaskID
)
{
OpInfo
&
outOpInfo
=
outInfo
-
>
push_back
(
)
;
this
-
>
copyOutFromOpsTask
(
&
outOpInfo
op
-
>
fOpsTaskID
)
;
}
}
}
}
void
GrAuditTrail
:
:
getBoundsByOpsTaskID
(
OpInfo
*
outInfo
int
opsTaskID
)
{
this
-
>
copyOutFromOpsTask
(
outInfo
opsTaskID
)
;
}
void
GrAuditTrail
:
:
fullReset
(
)
{
SkASSERT
(
fEnabled
)
;
fOpsTask
.
reset
(
)
;
fIDLookup
.
reset
(
)
;
fClientIDLookup
.
foreach
(
[
]
(
const
int
&
Ops
*
*
ops
)
{
delete
*
ops
;
}
)
;
fClientIDLookup
.
reset
(
)
;
fOpPool
.
reset
(
)
;
}
template
<
typename
T
>
void
GrAuditTrail
:
:
JsonifyTArray
(
SkJSONWriter
&
writer
const
char
*
name
const
T
&
array
)
{
if
(
array
.
count
(
)
)
{
writer
.
beginArray
(
name
)
;
for
(
int
i
=
0
;
i
<
array
.
count
(
)
;
i
+
+
)
{
if
(
array
[
i
]
)
{
array
[
i
]
-
>
toJson
(
writer
)
;
}
}
writer
.
endArray
(
)
;
}
}
void
GrAuditTrail
:
:
toJson
(
SkJSONWriter
&
writer
)
const
{
writer
.
beginObject
(
)
;
JsonifyTArray
(
writer
"
Ops
"
fOpsTask
)
;
writer
.
endObject
(
)
;
}
void
GrAuditTrail
:
:
toJson
(
SkJSONWriter
&
writer
int
clientID
)
const
{
writer
.
beginObject
(
)
;
Ops
*
*
ops
=
fClientIDLookup
.
find
(
clientID
)
;
if
(
ops
)
{
JsonifyTArray
(
writer
"
Ops
"
*
*
ops
)
;
}
writer
.
endObject
(
)
;
}
static
void
skrect_to_json
(
SkJSONWriter
&
writer
const
char
*
name
const
SkRect
&
rect
)
{
writer
.
beginObject
(
name
)
;
writer
.
appendFloat
(
"
Left
"
rect
.
fLeft
)
;
writer
.
appendFloat
(
"
Right
"
rect
.
fRight
)
;
writer
.
appendFloat
(
"
Top
"
rect
.
fTop
)
;
writer
.
appendFloat
(
"
Bottom
"
rect
.
fBottom
)
;
writer
.
endObject
(
)
;
}
void
GrAuditTrail
:
:
Op
:
:
toJson
(
SkJSONWriter
&
writer
)
const
{
writer
.
beginObject
(
)
;
writer
.
appendString
(
"
Name
"
fName
.
c_str
(
)
)
;
writer
.
appendS32
(
"
ClientID
"
fClientID
)
;
writer
.
appendS32
(
"
OpsTaskID
"
fOpsTaskID
)
;
writer
.
appendS32
(
"
ChildID
"
fChildID
)
;
skrect_to_json
(
writer
"
Bounds
"
fBounds
)
;
if
(
fStackTrace
.
count
(
)
)
{
writer
.
beginArray
(
"
Stack
"
)
;
for
(
int
i
=
0
;
i
<
fStackTrace
.
count
(
)
;
i
+
+
)
{
writer
.
appendString
(
fStackTrace
[
i
]
.
c_str
(
)
)
;
}
writer
.
endArray
(
)
;
}
writer
.
endObject
(
)
;
}
void
GrAuditTrail
:
:
OpNode
:
:
toJson
(
SkJSONWriter
&
writer
)
const
{
writer
.
beginObject
(
)
;
writer
.
appendU32
(
"
ProxyID
"
fProxyUniqueID
.
asUInt
(
)
)
;
skrect_to_json
(
writer
"
Bounds
"
fBounds
)
;
JsonifyTArray
(
writer
"
Ops
"
fChildren
)
;
writer
.
endObject
(
)
;
}
