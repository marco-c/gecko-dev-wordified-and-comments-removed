#
ifndef
GrTextureProducer_DEFINED
#
define
GrTextureProducer_DEFINED
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
private
/
GrResourceKey
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
#
include
"
src
/
gpu
/
GrColorInfo
.
h
"
#
include
"
src
/
gpu
/
GrSamplerState
.
h
"
class
GrFragmentProcessor
;
class
GrRecordingContext
;
class
GrTexture
;
class
GrTextureProxy
;
class
SkColorSpace
;
class
SkMatrix
;
struct
SkRect
;
class
GrTextureProducer
:
public
SkNoncopyable
{
public
:
struct
CopyParams
{
GrSamplerState
:
:
Filter
fFilter
;
int
fWidth
;
int
fHeight
;
}
;
enum
FilterConstraint
{
kYes_FilterConstraint
kNo_FilterConstraint
}
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
)
=
0
;
sk_sp
<
GrTextureProxy
>
refTextureProxyForParams
(
const
GrSamplerState
&
SkScalar
scaleAdjust
[
2
]
)
;
sk_sp
<
GrTextureProxy
>
refTextureProxyForParams
(
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
SkScalar
scaleAdjust
[
2
]
)
;
sk_sp
<
GrTextureProxy
>
refTextureProxy
(
GrMipMapped
willNeedMips
)
;
virtual
~
GrTextureProducer
(
)
{
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
const
GrColorInfo
&
colorInfo
(
)
const
{
return
fColorInfo
;
}
GrColorType
colorType
(
)
const
{
return
fColorInfo
.
colorType
(
)
;
}
SkAlphaType
alphaType
(
)
const
{
return
fColorInfo
.
alphaType
(
)
;
}
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorInfo
.
colorSpace
(
)
;
}
bool
isAlphaOnly
(
)
const
{
return
GrColorTypeIsAlphaOnly
(
fColorInfo
.
colorType
(
)
)
;
}
bool
domainNeedsDecal
(
)
const
{
return
fDomainNeedsDecal
;
}
virtual
bool
hasMixedResolutions
(
)
const
{
return
false
;
}
protected
:
friend
class
GrTextureProducer_TestAccess
;
GrTextureProducer
(
GrRecordingContext
*
context
int
width
int
height
const
GrColorInfo
&
colorInfo
bool
domainNeedsDecal
)
:
fContext
(
context
)
fWidth
(
width
)
fHeight
(
height
)
fColorInfo
(
colorInfo
)
fDomainNeedsDecal
(
domainNeedsDecal
)
{
}
static
void
MakeCopyKeyFromOrigKey
(
const
GrUniqueKey
&
origKey
const
CopyParams
&
copyParams
GrUniqueKey
*
copyKey
)
{
SkASSERT
(
!
copyKey
-
>
isValid
(
)
)
;
if
(
origKey
.
isValid
(
)
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
copyKey
origKey
kDomain
3
)
;
builder
[
0
]
=
static_cast
<
uint32_t
>
(
copyParams
.
fFilter
)
;
builder
[
1
]
=
copyParams
.
fWidth
;
builder
[
2
]
=
copyParams
.
fHeight
;
}
}
virtual
void
makeCopyKey
(
const
CopyParams
&
GrUniqueKey
*
copyKey
)
=
0
;
virtual
void
didCacheCopy
(
const
GrUniqueKey
&
copyKey
uint32_t
contextUniqueID
)
=
0
;
enum
DomainMode
{
kNoDomain_DomainMode
kDomain_DomainMode
kTightCopy_DomainMode
}
;
static
sk_sp
<
GrTextureProxy
>
CopyOnGpu
(
GrRecordingContext
*
sk_sp
<
GrTextureProxy
>
inputProxy
GrColorType
const
CopyParams
&
copyParams
bool
dstWillRequireMipMaps
)
;
static
DomainMode
DetermineDomainMode
(
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
GrTextureProxy
*
const
GrSamplerState
:
:
Filter
*
filterModeOrNullForBicubic
SkRect
*
domainRect
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
createFragmentProcessorForDomainAndFilter
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkMatrix
&
textureMatrix
DomainMode
const
SkRect
&
domain
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
)
;
GrRecordingContext
*
context
(
)
const
{
return
fContext
;
}
private
:
virtual
sk_sp
<
GrTextureProxy
>
onRefTextureProxyForParams
(
const
GrSamplerState
&
bool
willBeMipped
SkScalar
scaleAdjust
[
2
]
)
=
0
;
GrRecordingContext
*
fContext
;
const
int
fWidth
;
const
int
fHeight
;
const
GrColorInfo
fColorInfo
;
const
bool
fDomainNeedsDecal
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
endif
