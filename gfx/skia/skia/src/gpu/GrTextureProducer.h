#
ifndef
GrTextureProducer_DEFINED
#
define
GrTextureProducer_DEFINED
#
include
"
GrResourceKey
.
h
"
#
include
"
GrSamplerState
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkNoncopyable
.
h
"
class
GrContext
;
class
GrFragmentProcessor
;
class
GrTexture
;
class
GrTextureProxy
;
class
SkColorSpace
;
class
SkMatrix
;
struct
SkRect
;
class
GrTextureProducer
:
public
SkNoncopyable
{
public
:
struct
CopyParams
{
GrSamplerState
:
:
Filter
fFilter
;
int
fWidth
;
int
fHeight
;
}
;
enum
FilterConstraint
{
kYes_FilterConstraint
kNo_FilterConstraint
}
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
SkColorSpace
*
dstColorSpace
)
=
0
;
sk_sp
<
GrTextureProxy
>
refTextureProxyForParams
(
const
GrSamplerState
&
SkColorSpace
*
dstColorSpace
sk_sp
<
SkColorSpace
>
*
proxyColorSpace
SkScalar
scaleAdjust
[
2
]
)
;
sk_sp
<
GrTextureProxy
>
refTextureProxyForParams
(
GrSamplerState
:
:
Filter
filter
SkColorSpace
*
dstColorSpace
sk_sp
<
SkColorSpace
>
*
proxyColorSpace
SkScalar
scaleAdjust
[
2
]
)
{
return
this
-
>
refTextureProxyForParams
(
GrSamplerState
(
GrSamplerState
:
:
WrapMode
:
:
kClamp
filter
)
dstColorSpace
proxyColorSpace
scaleAdjust
)
;
}
sk_sp
<
GrTextureProxy
>
refTextureProxy
(
GrMipMapped
willNeedMips
SkColorSpace
*
dstColorSpace
sk_sp
<
SkColorSpace
>
*
proxyColorSpace
)
;
virtual
~
GrTextureProducer
(
)
{
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
bool
isAlphaOnly
(
)
const
{
return
fIsAlphaOnly
;
}
virtual
SkAlphaType
alphaType
(
)
const
=
0
;
protected
:
friend
class
GrTextureProducer_TestAccess
;
GrTextureProducer
(
GrContext
*
context
int
width
int
height
bool
isAlphaOnly
)
:
fContext
(
context
)
fWidth
(
width
)
fHeight
(
height
)
fIsAlphaOnly
(
isAlphaOnly
)
{
}
static
void
MakeCopyKeyFromOrigKey
(
const
GrUniqueKey
&
origKey
const
CopyParams
&
copyParams
GrUniqueKey
*
copyKey
)
{
SkASSERT
(
!
copyKey
-
>
isValid
(
)
)
;
if
(
origKey
.
isValid
(
)
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
copyKey
origKey
kDomain
3
)
;
builder
[
0
]
=
static_cast
<
uint32_t
>
(
copyParams
.
fFilter
)
;
builder
[
1
]
=
copyParams
.
fWidth
;
builder
[
2
]
=
copyParams
.
fHeight
;
}
}
virtual
void
makeCopyKey
(
const
CopyParams
&
GrUniqueKey
*
copyKey
)
=
0
;
virtual
void
didCacheCopy
(
const
GrUniqueKey
&
copyKey
uint32_t
contextUniqueID
)
=
0
;
enum
DomainMode
{
kNoDomain_DomainMode
kDomain_DomainMode
kTightCopy_DomainMode
}
;
static
sk_sp
<
GrTextureProxy
>
CopyOnGpu
(
GrContext
*
sk_sp
<
GrTextureProxy
>
inputProxy
const
CopyParams
&
copyParams
bool
dstWillRequireMipMaps
)
;
static
DomainMode
DetermineDomainMode
(
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
GrTextureProxy
*
const
GrSamplerState
:
:
Filter
*
filterModeOrNullForBicubic
SkRect
*
domainRect
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
CreateFragmentProcessorForDomainAndFilter
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkMatrix
&
textureMatrix
DomainMode
const
SkRect
&
domain
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
)
;
GrContext
*
fContext
;
private
:
virtual
sk_sp
<
GrTextureProxy
>
onRefTextureProxyForParams
(
const
GrSamplerState
&
SkColorSpace
*
dstColorSpace
sk_sp
<
SkColorSpace
>
*
proxyColorSpace
bool
willBeMipped
SkScalar
scaleAdjust
[
2
]
)
=
0
;
const
int
fWidth
;
const
int
fHeight
;
const
bool
fIsAlphaOnly
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
endif
