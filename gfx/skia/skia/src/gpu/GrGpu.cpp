#
include
"
GrGpu
.
h
"
#
include
"
GrBackendSemaphore
.
h
"
#
include
"
GrBackendSurface
.
h
"
#
include
"
GrBuffer
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrMesh
.
h
"
#
include
"
GrPathRendering
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSemaphore
.
h
"
#
include
"
GrStencilAttachment
.
h
"
#
include
"
GrStencilSettings
.
h
"
#
include
"
GrSurfacePriv
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
SkJSONWriter
.
h
"
#
include
"
SkMathPriv
.
h
"
GrGpu
:
:
GrGpu
(
GrContext
*
context
)
:
fResetTimestamp
(
kExpiredTimestamp
+
1
)
fResetBits
(
kAll_GrBackendState
)
fContext
(
context
)
{
}
GrGpu
:
:
~
GrGpu
(
)
{
}
void
GrGpu
:
:
disconnect
(
DisconnectType
)
{
}
bool
GrGpu
:
:
isACopyNeededForTextureParams
(
int
width
int
height
const
GrSamplerState
&
textureParams
GrTextureProducer
:
:
CopyParams
*
copyParams
SkScalar
scaleAdjust
[
2
]
)
const
{
const
GrCaps
&
caps
=
*
this
-
>
caps
(
)
;
if
(
textureParams
.
isRepeated
(
)
&
&
!
caps
.
npotTextureTileSupport
(
)
&
&
(
!
SkIsPow2
(
width
)
|
|
!
SkIsPow2
(
height
)
)
)
{
SkASSERT
(
scaleAdjust
)
;
copyParams
-
>
fWidth
=
GrNextPow2
(
width
)
;
copyParams
-
>
fHeight
=
GrNextPow2
(
height
)
;
scaleAdjust
[
0
]
=
(
(
SkScalar
)
copyParams
-
>
fWidth
)
/
width
;
scaleAdjust
[
1
]
=
(
(
SkScalar
)
copyParams
-
>
fHeight
)
/
height
;
switch
(
textureParams
.
filter
(
)
)
{
case
GrSamplerState
:
:
Filter
:
:
kNearest
:
copyParams
-
>
fFilter
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
GrSamplerState
:
:
Filter
:
:
kBilerp
:
case
GrSamplerState
:
:
Filter
:
:
kMipMap
:
copyParams
-
>
fFilter
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
}
return
true
;
}
return
false
;
}
sk_sp
<
GrTexture
>
GrGpu
:
:
createTexture
(
const
GrSurfaceDesc
&
origDesc
SkBudgeted
budgeted
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrGpu
"
"
createTexture
"
fContext
)
;
GrSurfaceDesc
desc
=
origDesc
;
GrMipMapped
mipMapped
=
mipLevelCount
>
1
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
;
if
(
!
this
-
>
caps
(
)
-
>
validateSurfaceDesc
(
desc
mipMapped
)
)
{
return
nullptr
;
}
bool
isRT
=
desc
.
fFlags
&
kRenderTarget_GrSurfaceFlag
;
if
(
isRT
)
{
desc
.
fSampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
desc
.
fSampleCnt
desc
.
fConfig
)
;
}
SkASSERT
(
desc
.
fSampleCnt
>
0
&
&
desc
.
fSampleCnt
<
=
64
)
;
if
(
mipLevelCount
&
&
(
desc
.
fFlags
&
kPerformInitialClear_GrSurfaceFlag
)
)
{
return
nullptr
;
}
this
-
>
handleDirtyContext
(
)
;
sk_sp
<
GrTexture
>
tex
=
this
-
>
onCreateTexture
(
desc
budgeted
texels
mipLevelCount
)
;
if
(
tex
)
{
if
(
!
this
-
>
caps
(
)
-
>
reuseScratchTextures
(
)
&
&
!
isRT
)
{
tex
-
>
resourcePriv
(
)
.
removeScratchKey
(
)
;
}
fStats
.
incTextureCreates
(
)
;
if
(
mipLevelCount
)
{
if
(
texels
[
0
]
.
fPixels
)
{
fStats
.
incTextureUploads
(
)
;
}
}
}
return
tex
;
}
sk_sp
<
GrTexture
>
GrGpu
:
:
createTexture
(
const
GrSurfaceDesc
&
desc
SkBudgeted
budgeted
)
{
return
this
-
>
createTexture
(
desc
budgeted
nullptr
0
)
;
}
sk_sp
<
GrTexture
>
GrGpu
:
:
wrapBackendTexture
(
const
GrBackendTexture
&
backendTex
GrWrapOwnership
ownership
)
{
this
-
>
handleDirtyContext
(
)
;
if
(
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
backendTex
.
config
(
)
)
)
{
return
nullptr
;
}
if
(
backendTex
.
width
(
)
>
this
-
>
caps
(
)
-
>
maxTextureSize
(
)
|
|
backendTex
.
height
(
)
>
this
-
>
caps
(
)
-
>
maxTextureSize
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
tex
=
this
-
>
onWrapBackendTexture
(
backendTex
ownership
)
;
if
(
!
tex
)
{
return
nullptr
;
}
return
tex
;
}
sk_sp
<
GrTexture
>
GrGpu
:
:
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
backendTex
int
sampleCnt
GrWrapOwnership
ownership
)
{
this
-
>
handleDirtyContext
(
)
;
if
(
sampleCnt
<
1
)
{
return
nullptr
;
}
if
(
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
backendTex
.
config
(
)
)
|
|
!
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
backendTex
.
config
(
)
)
)
{
return
nullptr
;
}
if
(
backendTex
.
width
(
)
>
this
-
>
caps
(
)
-
>
maxRenderTargetSize
(
)
|
|
backendTex
.
height
(
)
>
this
-
>
caps
(
)
-
>
maxRenderTargetSize
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
tex
=
this
-
>
onWrapRenderableBackendTexture
(
backendTex
sampleCnt
ownership
)
;
if
(
!
tex
)
{
return
nullptr
;
}
SkASSERT
(
tex
-
>
asRenderTarget
(
)
)
;
return
tex
;
}
sk_sp
<
GrRenderTarget
>
GrGpu
:
:
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
backendRT
)
{
if
(
0
=
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
backendRT
.
sampleCnt
(
)
backendRT
.
config
(
)
)
)
{
return
nullptr
;
}
this
-
>
handleDirtyContext
(
)
;
return
this
-
>
onWrapBackendRenderTarget
(
backendRT
)
;
}
sk_sp
<
GrRenderTarget
>
GrGpu
:
:
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
tex
int
sampleCnt
)
{
if
(
0
=
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
tex
.
config
(
)
)
)
{
return
nullptr
;
}
int
maxSize
=
this
-
>
caps
(
)
-
>
maxTextureSize
(
)
;
if
(
tex
.
width
(
)
>
maxSize
|
|
tex
.
height
(
)
>
maxSize
)
{
return
nullptr
;
}
this
-
>
handleDirtyContext
(
)
;
return
this
-
>
onWrapBackendTextureAsRenderTarget
(
tex
sampleCnt
)
;
}
GrBuffer
*
GrGpu
:
:
createBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
accessPattern
const
void
*
data
)
{
this
-
>
handleDirtyContext
(
)
;
GrBuffer
*
buffer
=
this
-
>
onCreateBuffer
(
size
intendedType
accessPattern
data
)
;
if
(
!
this
-
>
caps
(
)
-
>
reuseScratchBuffers
(
)
)
{
buffer
-
>
resourcePriv
(
)
.
removeScratchKey
(
)
;
}
return
buffer
;
}
bool
GrGpu
:
:
copySurface
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrGpu
"
"
copySurface
"
fContext
)
;
SkASSERT
(
dst
&
&
src
)
;
this
-
>
handleDirtyContext
(
)
;
return
this
-
>
onCopySurface
(
dst
dstOrigin
src
srcOrigin
srcRect
dstPoint
)
;
}
bool
GrGpu
:
:
getReadPixelsInfo
(
GrSurface
*
srcSurface
GrSurfaceOrigin
srcOrigin
int
width
int
height
size_t
rowBytes
GrColorType
dstColorType
GrSRGBConversion
srgbConversion
DrawPreference
*
drawPreference
ReadPixelTempDrawInfo
*
tempDrawInfo
)
{
SkASSERT
(
drawPreference
)
;
SkASSERT
(
tempDrawInfo
)
;
SkASSERT
(
srcSurface
)
;
SkASSERT
(
kGpuPrefersDraw_DrawPreference
!
=
*
drawPreference
)
;
if
(
GrColorType
:
:
kRGB_565
=
=
dstColorType
|
|
GrColorType
:
:
kABGR_4444
=
=
dstColorType
)
{
return
false
;
}
GrPixelConfig
tempSurfaceConfig
=
kUnknown_GrPixelConfig
;
switch
(
srgbConversion
)
{
case
GrSRGBConversion
:
:
kNone
:
if
(
GrColorTypeIsAlphaOnly
(
dstColorType
)
)
{
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
dstColorType
GrSRGBEncoded
:
:
kNo
)
;
}
else
{
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
dstColorType
GrPixelConfigIsSRGBEncoded
(
srcSurface
-
>
config
(
)
)
)
;
}
break
;
case
GrSRGBConversion
:
:
kLinearToSRGB
:
SkASSERT
(
this
-
>
caps
(
)
-
>
srgbSupport
(
)
)
;
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
dstColorType
GrSRGBEncoded
:
:
kYes
)
;
if
(
GrPixelConfigIsSRGB
(
srcSurface
-
>
config
(
)
)
)
{
return
false
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
break
;
case
GrSRGBConversion
:
:
kSRGBToLinear
:
SkASSERT
(
this
-
>
caps
(
)
-
>
srgbSupport
(
)
)
;
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
dstColorType
GrSRGBEncoded
:
:
kNo
)
;
if
(
GrSRGBEncoded
:
:
kNo
=
=
GrPixelConfigIsSRGBEncoded
(
srcSurface
-
>
config
(
)
)
)
{
return
false
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
break
;
}
if
(
kUnknown_GrPixelConfig
=
=
tempSurfaceConfig
)
{
return
false
;
}
tempDrawInfo
-
>
fTempSurfaceDesc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fWidth
=
width
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fHeight
=
height
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fSampleCnt
=
1
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
=
tempSurfaceConfig
;
tempDrawInfo
-
>
fTempSurfaceFit
=
SkBackingFit
:
:
kApprox
;
tempDrawInfo
-
>
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
tempDrawInfo
-
>
fReadColorType
=
dstColorType
;
if
(
!
this
-
>
onGetReadPixelsInfo
(
srcSurface
srcOrigin
width
height
rowBytes
dstColorType
drawPreference
tempDrawInfo
)
)
{
return
false
;
}
if
(
!
srcSurface
-
>
asTexture
(
)
|
|
!
this
-
>
caps
(
)
-
>
isConfigRenderable
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
)
{
if
(
kRequireDraw_DrawPreference
=
=
*
drawPreference
)
{
return
false
;
}
*
drawPreference
=
kNoDraw_DrawPreference
;
}
return
true
;
}
bool
GrGpu
:
:
getWritePixelsInfo
(
GrSurface
*
dstSurface
GrSurfaceOrigin
dstOrigin
int
width
int
height
GrColorType
srcColorType
GrSRGBConversion
srgbConversion
DrawPreference
*
drawPreference
WritePixelTempDrawInfo
*
tempDrawInfo
)
{
SkASSERT
(
drawPreference
)
;
SkASSERT
(
tempDrawInfo
)
;
SkASSERT
(
dstSurface
)
;
SkASSERT
(
kGpuPrefersDraw_DrawPreference
!
=
*
drawPreference
)
;
GrPixelConfig
tempSurfaceConfig
=
kUnknown_GrPixelConfig
;
switch
(
srgbConversion
)
{
case
GrSRGBConversion
:
:
kNone
:
if
(
GrColorTypeIsAlphaOnly
(
srcColorType
)
)
{
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
srcColorType
GrSRGBEncoded
:
:
kNo
)
;
}
else
{
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
srcColorType
GrPixelConfigIsSRGBEncoded
(
dstSurface
-
>
config
(
)
)
)
;
}
break
;
case
GrSRGBConversion
:
:
kLinearToSRGB
:
SkASSERT
(
this
-
>
caps
(
)
-
>
srgbSupport
(
)
)
;
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
srcColorType
GrSRGBEncoded
:
:
kNo
)
;
if
(
!
GrPixelConfigIsSRGB
(
dstSurface
-
>
config
(
)
)
)
{
return
false
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
break
;
case
GrSRGBConversion
:
:
kSRGBToLinear
:
SkASSERT
(
this
-
>
caps
(
)
-
>
srgbSupport
(
)
)
;
tempSurfaceConfig
=
GrColorTypeToPixelConfig
(
srcColorType
GrSRGBEncoded
:
:
kYes
)
;
if
(
GrSRGBEncoded
:
:
kYes
=
=
GrPixelConfigIsSRGBEncoded
(
dstSurface
-
>
config
(
)
)
)
{
return
false
;
}
ElevateDrawPreference
(
drawPreference
kRequireDraw_DrawPreference
)
;
break
;
}
if
(
kUnknown_GrPixelConfig
=
=
tempSurfaceConfig
)
{
return
false
;
}
tempDrawInfo
-
>
fTempSurfaceDesc
.
fFlags
=
kNone_GrSurfaceFlags
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
=
tempSurfaceConfig
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fWidth
=
width
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fHeight
=
height
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fSampleCnt
=
1
;
tempDrawInfo
-
>
fTempSurfaceDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
tempDrawInfo
-
>
fSwizzle
=
GrSwizzle
:
:
RGBA
(
)
;
tempDrawInfo
-
>
fWriteColorType
=
srcColorType
;
if
(
!
this
-
>
onGetWritePixelsInfo
(
dstSurface
dstOrigin
width
height
srcColorType
drawPreference
tempDrawInfo
)
)
{
return
false
;
}
if
(
!
dstSurface
-
>
asRenderTarget
(
)
|
|
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
tempDrawInfo
-
>
fTempSurfaceDesc
.
fConfig
)
)
{
if
(
kRequireDraw_DrawPreference
=
=
*
drawPreference
)
{
return
false
;
}
*
drawPreference
=
kNoDraw_DrawPreference
;
}
return
true
;
}
bool
GrGpu
:
:
readPixels
(
GrSurface
*
surface
GrSurfaceOrigin
origin
int
left
int
top
int
width
int
height
GrColorType
dstColorType
void
*
buffer
size_t
rowBytes
)
{
SkASSERT
(
surface
)
;
int
bpp
=
GrColorTypeBytesPerPixel
(
dstColorType
)
;
if
(
!
GrSurfacePriv
:
:
AdjustReadPixelParams
(
surface
-
>
width
(
)
surface
-
>
height
(
)
bpp
&
left
&
top
&
width
&
height
&
buffer
&
rowBytes
)
)
{
return
false
;
}
this
-
>
handleDirtyContext
(
)
;
return
this
-
>
onReadPixels
(
surface
origin
left
top
width
height
dstColorType
buffer
rowBytes
)
;
}
bool
GrGpu
:
:
writePixels
(
GrSurface
*
surface
GrSurfaceOrigin
origin
int
left
int
top
int
width
int
height
GrColorType
srcColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
{
SkASSERT
(
surface
)
;
if
(
1
=
=
mipLevelCount
)
{
SkIRect
subRect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
surface
-
>
width
(
)
surface
-
>
height
(
)
)
;
if
(
!
bounds
.
contains
(
subRect
)
)
{
return
false
;
}
}
else
if
(
0
!
=
left
|
|
0
!
=
top
|
|
width
!
=
surface
-
>
width
(
)
|
|
height
!
=
surface
-
>
height
(
)
)
{
return
false
;
}
for
(
int
currentMipLevel
=
0
;
currentMipLevel
<
mipLevelCount
;
currentMipLevel
+
+
)
{
if
(
!
texels
[
currentMipLevel
]
.
fPixels
)
{
return
false
;
}
}
this
-
>
handleDirtyContext
(
)
;
if
(
this
-
>
onWritePixels
(
surface
origin
left
top
width
height
srcColorType
texels
mipLevelCount
)
)
{
SkIRect
rect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
this
-
>
didWriteToSurface
(
surface
origin
&
rect
mipLevelCount
)
;
fStats
.
incTextureUploads
(
)
;
return
true
;
}
return
false
;
}
bool
GrGpu
:
:
writePixels
(
GrSurface
*
surface
GrSurfaceOrigin
origin
int
left
int
top
int
width
int
height
GrColorType
srcColorType
const
void
*
buffer
size_t
rowBytes
)
{
GrMipLevel
mipLevel
=
{
buffer
rowBytes
}
;
return
this
-
>
writePixels
(
surface
origin
left
top
width
height
srcColorType
&
mipLevel
1
)
;
}
bool
GrGpu
:
:
transferPixels
(
GrTexture
*
texture
int
left
int
top
int
width
int
height
GrColorType
bufferColorType
GrBuffer
*
transferBuffer
size_t
offset
size_t
rowBytes
)
{
SkASSERT
(
transferBuffer
)
;
SkIRect
subRect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
;
if
(
!
bounds
.
contains
(
subRect
)
)
{
return
false
;
}
this
-
>
handleDirtyContext
(
)
;
if
(
this
-
>
onTransferPixels
(
texture
left
top
width
height
bufferColorType
transferBuffer
offset
rowBytes
)
)
{
SkIRect
rect
=
SkIRect
:
:
MakeXYWH
(
left
top
width
height
)
;
this
-
>
didWriteToSurface
(
texture
kTopLeft_GrSurfaceOrigin
&
rect
)
;
fStats
.
incTransfersToTexture
(
)
;
return
true
;
}
return
false
;
}
void
GrGpu
:
:
resolveRenderTarget
(
GrRenderTarget
*
target
)
{
SkASSERT
(
target
)
;
this
-
>
handleDirtyContext
(
)
;
this
-
>
onResolveRenderTarget
(
target
)
;
}
void
GrGpu
:
:
didWriteToSurface
(
GrSurface
*
surface
GrSurfaceOrigin
origin
const
SkIRect
*
bounds
uint32_t
mipLevels
)
const
{
SkASSERT
(
surface
)
;
if
(
nullptr
=
=
bounds
|
|
!
bounds
-
>
isEmpty
(
)
)
{
if
(
GrRenderTarget
*
target
=
surface
-
>
asRenderTarget
(
)
)
{
SkIRect
flippedBounds
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
origin
&
&
bounds
)
{
flippedBounds
=
{
bounds
-
>
fLeft
surface
-
>
height
(
)
-
bounds
-
>
fBottom
bounds
-
>
fRight
surface
-
>
height
(
)
-
bounds
-
>
fTop
}
;
bounds
=
&
flippedBounds
;
}
target
-
>
flagAsNeedingResolve
(
bounds
)
;
}
GrTexture
*
texture
=
surface
-
>
asTexture
(
)
;
if
(
texture
&
&
1
=
=
mipLevels
)
{
texture
-
>
texturePriv
(
)
.
markMipMapsDirty
(
)
;
}
}
}
GrSemaphoresSubmitted
GrGpu
:
:
finishFlush
(
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
{
GrResourceProvider
*
resourceProvider
=
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
;
if
(
this
-
>
caps
(
)
-
>
fenceSyncSupport
(
)
)
{
for
(
int
i
=
0
;
i
<
numSemaphores
;
+
+
i
)
{
sk_sp
<
GrSemaphore
>
semaphore
;
if
(
backendSemaphores
[
i
]
.
isInitialized
(
)
)
{
semaphore
=
resourceProvider
-
>
wrapBackendSemaphore
(
backendSemaphores
[
i
]
GrResourceProvider
:
:
SemaphoreWrapType
:
:
kWillSignal
kBorrow_GrWrapOwnership
)
;
}
else
{
semaphore
=
resourceProvider
-
>
makeSemaphore
(
false
)
;
}
this
-
>
insertSemaphore
(
semaphore
false
)
;
if
(
!
backendSemaphores
[
i
]
.
isInitialized
(
)
)
{
semaphore
-
>
setBackendSemaphore
(
&
backendSemaphores
[
i
]
)
;
}
}
}
this
-
>
onFinishFlush
(
(
numSemaphores
>
0
&
&
this
-
>
caps
(
)
-
>
fenceSyncSupport
(
)
)
)
;
return
this
-
>
caps
(
)
-
>
fenceSyncSupport
(
)
?
GrSemaphoresSubmitted
:
:
kYes
:
GrSemaphoresSubmitted
:
:
kNo
;
}
void
GrGpu
:
:
dumpJSON
(
SkJSONWriter
*
writer
)
const
{
writer
-
>
beginObject
(
)
;
this
-
>
onDumpJSON
(
writer
)
;
writer
-
>
endObject
(
)
;
}
