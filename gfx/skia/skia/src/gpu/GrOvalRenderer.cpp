#
include
"
GrOvalRenderer
.
h
"
#
include
"
GrBatchFlushState
.
h
"
#
include
"
GrBatchTest
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrInvariantOutput
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
SkRRect
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
batches
/
GrVertexBatch
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLVarying
.
h
"
#
include
"
glsl
/
GrGLSLVertexShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
glsl
/
GrGLSLUtil
.
h
"
namespace
{
struct
EllipseVertex
{
SkPoint
fPos
;
GrColor
fColor
;
SkPoint
fOffset
;
SkPoint
fOuterRadii
;
SkPoint
fInnerRadii
;
}
;
struct
DIEllipseVertex
{
SkPoint
fPos
;
GrColor
fColor
;
SkPoint
fOuterOffset
;
SkPoint
fInnerOffset
;
}
;
inline
bool
circle_stays_circle
(
const
SkMatrix
&
m
)
{
return
m
.
isSimilarity
(
)
;
}
}
class
CircleGeometryProcessor
:
public
GrGeometryProcessor
{
public
:
CircleGeometryProcessor
(
bool
stroke
bool
clipPlane
bool
isectPlane
bool
unionPlane
const
SkMatrix
&
localMatrix
)
:
fLocalMatrix
(
localMatrix
)
{
this
-
>
initClassID
<
CircleGeometryProcessor
>
(
)
;
fInPosition
=
&
this
-
>
addVertexAttrib
(
"
inPosition
"
kVec2f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
fInColor
=
&
this
-
>
addVertexAttrib
(
"
inColor
"
kVec4ub_GrVertexAttribType
)
;
fInCircleEdge
=
&
this
-
>
addVertexAttrib
(
"
inCircleEdge
"
kVec4f_GrVertexAttribType
)
;
if
(
clipPlane
)
{
fInClipPlane
=
&
this
-
>
addVertexAttrib
(
"
inClipPlane
"
kVec3f_GrVertexAttribType
)
;
}
else
{
fInClipPlane
=
nullptr
;
}
if
(
isectPlane
)
{
fInIsectPlane
=
&
this
-
>
addVertexAttrib
(
"
inIsectPlane
"
kVec3f_GrVertexAttribType
)
;
}
else
{
fInIsectPlane
=
nullptr
;
}
if
(
unionPlane
)
{
fInUnionPlane
=
&
this
-
>
addVertexAttrib
(
"
inUnionPlane
"
kVec3f_GrVertexAttribType
)
;
}
else
{
fInUnionPlane
=
nullptr
;
}
fStroke
=
stroke
;
}
bool
implementsDistanceVector
(
)
const
override
{
return
!
fInClipPlane
;
}
virtual
~
CircleGeometryProcessor
(
)
{
}
const
char
*
name
(
)
const
override
{
return
"
CircleEdge
"
;
}
void
getGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GLSLProcessor
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrGLSLCaps
&
)
const
override
{
return
new
GLSLProcessor
(
)
;
}
private
:
class
GLSLProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
GLSLProcessor
(
)
{
}
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
const
CircleGeometryProcessor
&
cgp
=
args
.
fGP
.
cast
<
CircleGeometryProcessor
>
(
)
;
GrGLSLVertexBuilder
*
vertBuilder
=
args
.
fVertBuilder
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
GrGLSLPPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
varyingHandler
-
>
emitAttributes
(
cgp
)
;
fragBuilder
-
>
codeAppend
(
"
vec4
circleEdge
;
"
)
;
varyingHandler
-
>
addPassThroughAttribute
(
cgp
.
fInCircleEdge
"
circleEdge
"
)
;
if
(
cgp
.
fInClipPlane
)
{
fragBuilder
-
>
codeAppend
(
"
vec3
clipPlane
;
"
)
;
varyingHandler
-
>
addPassThroughAttribute
(
cgp
.
fInClipPlane
"
clipPlane
"
)
;
}
if
(
cgp
.
fInIsectPlane
)
{
SkASSERT
(
cgp
.
fInClipPlane
)
;
fragBuilder
-
>
codeAppend
(
"
vec3
isectPlane
;
"
)
;
varyingHandler
-
>
addPassThroughAttribute
(
cgp
.
fInIsectPlane
"
isectPlane
"
)
;
}
if
(
cgp
.
fInUnionPlane
)
{
SkASSERT
(
cgp
.
fInClipPlane
)
;
fragBuilder
-
>
codeAppend
(
"
vec3
unionPlane
;
"
)
;
varyingHandler
-
>
addPassThroughAttribute
(
cgp
.
fInUnionPlane
"
unionPlane
"
)
;
}
varyingHandler
-
>
addPassThroughAttribute
(
cgp
.
fInColor
args
.
fOutputColor
)
;
this
-
>
setupPosition
(
vertBuilder
gpArgs
cgp
.
fInPosition
-
>
fName
)
;
this
-
>
emitTransforms
(
vertBuilder
varyingHandler
uniformHandler
gpArgs
-
>
fPositionVar
cgp
.
fInPosition
-
>
fName
cgp
.
fLocalMatrix
args
.
fFPCoordTransformHandler
)
;
fragBuilder
-
>
codeAppend
(
"
float
d
=
length
(
circleEdge
.
xy
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
distanceToOuterEdge
=
circleEdge
.
z
*
(
1
.
0
-
d
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
edgeAlpha
=
clamp
(
distanceToOuterEdge
0
.
0
1
.
0
)
;
"
)
;
if
(
cgp
.
fStroke
)
{
fragBuilder
-
>
codeAppend
(
"
float
distanceToInnerEdge
=
circleEdge
.
z
*
(
d
-
circleEdge
.
w
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
innerAlpha
=
clamp
(
distanceToInnerEdge
0
.
0
1
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
edgeAlpha
*
=
innerAlpha
;
"
)
;
}
if
(
args
.
fDistanceVectorName
)
{
const
char
*
innerEdgeDistance
=
cgp
.
fStroke
?
"
distanceToInnerEdge
"
:
"
0
.
0
"
;
fragBuilder
-
>
codeAppend
(
"
if
(
d
=
=
0
.
0
)
{
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
1
.
0
0
.
0
distanceToOuterEdge
"
"
%
s
)
;
"
args
.
fDistanceVectorName
innerEdgeDistance
)
;
fragBuilder
-
>
codeAppend
(
"
}
else
{
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
normalize
(
circleEdge
.
xy
)
distanceToOuterEdge
%
s
)
;
"
args
.
fDistanceVectorName
innerEdgeDistance
)
;
fragBuilder
-
>
codeAppend
(
"
}
"
)
;
}
if
(
cgp
.
fInClipPlane
)
{
fragBuilder
-
>
codeAppend
(
"
float
clip
=
clamp
(
circleEdge
.
z
*
dot
(
circleEdge
.
xy
clipPlane
.
xy
)
+
clipPlane
.
z
0
.
0
1
.
0
)
;
"
)
;
if
(
cgp
.
fInIsectPlane
)
{
fragBuilder
-
>
codeAppend
(
"
clip
*
=
clamp
(
circleEdge
.
z
*
dot
(
circleEdge
.
xy
isectPlane
.
xy
)
+
isectPlane
.
z
0
.
0
1
.
0
)
;
"
)
;
}
if
(
cgp
.
fInUnionPlane
)
{
fragBuilder
-
>
codeAppend
(
"
clip
+
=
(
1
.
0
-
clip
)
*
clamp
(
circleEdge
.
z
*
dot
(
circleEdge
.
xy
unionPlane
.
xy
)
+
unionPlane
.
z
0
.
0
1
.
0
)
;
"
)
;
}
fragBuilder
-
>
codeAppend
(
"
edgeAlpha
*
=
clip
;
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
edgeAlpha
)
;
"
args
.
fOutputCoverage
)
;
}
static
void
GenKey
(
const
GrGeometryProcessor
&
gp
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
CircleGeometryProcessor
&
cgp
=
gp
.
cast
<
CircleGeometryProcessor
>
(
)
;
uint16_t
key
;
key
=
cgp
.
fStroke
?
0x01
:
0x0
;
key
|
=
cgp
.
fLocalMatrix
.
hasPerspective
(
)
?
0x02
:
0x0
;
key
|
=
cgp
.
fInClipPlane
?
0x04
:
0x0
;
key
|
=
cgp
.
fInIsectPlane
?
0x08
:
0x0
;
key
|
=
cgp
.
fInUnionPlane
?
0x10
:
0x0
;
b
-
>
add32
(
key
)
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
primProc
FPCoordTransformIter
&
&
transformIter
)
override
{
this
-
>
setTransformDataHelper
(
primProc
.
cast
<
CircleGeometryProcessor
>
(
)
.
fLocalMatrix
pdman
&
transformIter
)
;
}
private
:
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
SkMatrix
fLocalMatrix
;
const
Attribute
*
fInPosition
;
const
Attribute
*
fInColor
;
const
Attribute
*
fInCircleEdge
;
const
Attribute
*
fInClipPlane
;
const
Attribute
*
fInIsectPlane
;
const
Attribute
*
fInUnionPlane
;
bool
fStroke
;
GR_DECLARE_GEOMETRY_PROCESSOR_TEST
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
GR_DEFINE_GEOMETRY_PROCESSOR_TEST
(
CircleGeometryProcessor
)
;
sk_sp
<
GrGeometryProcessor
>
CircleGeometryProcessor
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
return
sk_sp
<
GrGeometryProcessor
>
(
new
CircleGeometryProcessor
(
d
-
>
fRandom
-
>
nextBool
(
)
d
-
>
fRandom
-
>
nextBool
(
)
d
-
>
fRandom
-
>
nextBool
(
)
d
-
>
fRandom
-
>
nextBool
(
)
GrTest
:
:
TestMatrix
(
d
-
>
fRandom
)
)
)
;
}
class
EllipseGeometryProcessor
:
public
GrGeometryProcessor
{
public
:
EllipseGeometryProcessor
(
bool
stroke
const
SkMatrix
&
localMatrix
)
:
fLocalMatrix
(
localMatrix
)
{
this
-
>
initClassID
<
EllipseGeometryProcessor
>
(
)
;
fInPosition
=
&
this
-
>
addVertexAttrib
(
"
inPosition
"
kVec2f_GrVertexAttribType
)
;
fInColor
=
&
this
-
>
addVertexAttrib
(
"
inColor
"
kVec4ub_GrVertexAttribType
)
;
fInEllipseOffset
=
&
this
-
>
addVertexAttrib
(
"
inEllipseOffset
"
kVec2f_GrVertexAttribType
)
;
fInEllipseRadii
=
&
this
-
>
addVertexAttrib
(
"
inEllipseRadii
"
kVec4f_GrVertexAttribType
)
;
fStroke
=
stroke
;
}
virtual
~
EllipseGeometryProcessor
(
)
{
}
const
char
*
name
(
)
const
override
{
return
"
EllipseEdge
"
;
}
void
getGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GLSLProcessor
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrGLSLCaps
&
)
const
override
{
return
new
GLSLProcessor
(
)
;
}
private
:
class
GLSLProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
GLSLProcessor
(
)
{
}
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
const
EllipseGeometryProcessor
&
egp
=
args
.
fGP
.
cast
<
EllipseGeometryProcessor
>
(
)
;
GrGLSLVertexBuilder
*
vertBuilder
=
args
.
fVertBuilder
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
varyingHandler
-
>
emitAttributes
(
egp
)
;
GrGLSLVertToFrag
ellipseOffsets
(
kVec2f_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
EllipseOffsets
"
&
ellipseOffsets
)
;
vertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
ellipseOffsets
.
vsOut
(
)
egp
.
fInEllipseOffset
-
>
fName
)
;
GrGLSLVertToFrag
ellipseRadii
(
kVec4f_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
EllipseRadii
"
&
ellipseRadii
)
;
vertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
ellipseRadii
.
vsOut
(
)
egp
.
fInEllipseRadii
-
>
fName
)
;
GrGLSLPPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
varyingHandler
-
>
addPassThroughAttribute
(
egp
.
fInColor
args
.
fOutputColor
)
;
this
-
>
setupPosition
(
vertBuilder
gpArgs
egp
.
fInPosition
-
>
fName
)
;
this
-
>
emitTransforms
(
vertBuilder
varyingHandler
uniformHandler
gpArgs
-
>
fPositionVar
egp
.
fInPosition
-
>
fName
egp
.
fLocalMatrix
args
.
fFPCoordTransformHandler
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
scaledOffset
=
%
s
*
%
s
.
xy
;
"
ellipseOffsets
.
fsIn
(
)
ellipseRadii
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
float
test
=
dot
(
scaledOffset
scaledOffset
)
-
1
.
0
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
grad
=
2
.
0
*
scaledOffset
*
%
s
.
xy
;
"
ellipseRadii
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
float
grad_dot
=
dot
(
grad
grad
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
grad_dot
=
max
(
grad_dot
1
.
0e
-
4
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
invlen
=
inversesqrt
(
grad_dot
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
edgeAlpha
=
clamp
(
0
.
5
-
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
if
(
egp
.
fStroke
)
{
fragBuilder
-
>
codeAppendf
(
"
scaledOffset
=
%
s
*
%
s
.
zw
;
"
ellipseOffsets
.
fsIn
(
)
ellipseRadii
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
test
=
dot
(
scaledOffset
scaledOffset
)
-
1
.
0
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
grad
=
2
.
0
*
scaledOffset
*
%
s
.
zw
;
"
ellipseRadii
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
invlen
=
inversesqrt
(
dot
(
grad
grad
)
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
edgeAlpha
*
=
clamp
(
0
.
5
+
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
edgeAlpha
)
;
"
args
.
fOutputCoverage
)
;
}
static
void
GenKey
(
const
GrGeometryProcessor
&
gp
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
EllipseGeometryProcessor
&
egp
=
gp
.
cast
<
EllipseGeometryProcessor
>
(
)
;
uint16_t
key
=
egp
.
fStroke
?
0x1
:
0x0
;
key
|
=
egp
.
fLocalMatrix
.
hasPerspective
(
)
?
0x2
:
0x0
;
b
-
>
add32
(
key
)
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
primProc
FPCoordTransformIter
&
&
transformIter
)
override
{
const
EllipseGeometryProcessor
&
egp
=
primProc
.
cast
<
EllipseGeometryProcessor
>
(
)
;
this
-
>
setTransformDataHelper
(
egp
.
fLocalMatrix
pdman
&
transformIter
)
;
}
private
:
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
const
Attribute
*
fInPosition
;
const
Attribute
*
fInColor
;
const
Attribute
*
fInEllipseOffset
;
const
Attribute
*
fInEllipseRadii
;
SkMatrix
fLocalMatrix
;
bool
fStroke
;
GR_DECLARE_GEOMETRY_PROCESSOR_TEST
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
GR_DEFINE_GEOMETRY_PROCESSOR_TEST
(
EllipseGeometryProcessor
)
;
sk_sp
<
GrGeometryProcessor
>
EllipseGeometryProcessor
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
return
sk_sp
<
GrGeometryProcessor
>
(
new
EllipseGeometryProcessor
(
d
-
>
fRandom
-
>
nextBool
(
)
GrTest
:
:
TestMatrix
(
d
-
>
fRandom
)
)
)
;
}
enum
class
DIEllipseStyle
{
kStroke
=
0
kHairline
kFill
}
;
class
DIEllipseGeometryProcessor
:
public
GrGeometryProcessor
{
public
:
DIEllipseGeometryProcessor
(
const
SkMatrix
&
viewMatrix
DIEllipseStyle
style
)
:
fViewMatrix
(
viewMatrix
)
{
this
-
>
initClassID
<
DIEllipseGeometryProcessor
>
(
)
;
fInPosition
=
&
this
-
>
addVertexAttrib
(
"
inPosition
"
kVec2f_GrVertexAttribType
kHigh_GrSLPrecision
)
;
fInColor
=
&
this
-
>
addVertexAttrib
(
"
inColor
"
kVec4ub_GrVertexAttribType
)
;
fInEllipseOffsets0
=
&
this
-
>
addVertexAttrib
(
"
inEllipseOffsets0
"
kVec2f_GrVertexAttribType
)
;
fInEllipseOffsets1
=
&
this
-
>
addVertexAttrib
(
"
inEllipseOffsets1
"
kVec2f_GrVertexAttribType
)
;
fStyle
=
style
;
}
virtual
~
DIEllipseGeometryProcessor
(
)
{
}
const
char
*
name
(
)
const
override
{
return
"
DIEllipseEdge
"
;
}
void
getGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GLSLProcessor
:
:
GenKey
(
*
this
caps
b
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrGLSLCaps
&
)
const
override
{
return
new
GLSLProcessor
(
)
;
}
private
:
class
GLSLProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
GLSLProcessor
(
)
:
fViewMatrix
(
SkMatrix
:
:
InvalidMatrix
(
)
)
{
}
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
{
const
DIEllipseGeometryProcessor
&
diegp
=
args
.
fGP
.
cast
<
DIEllipseGeometryProcessor
>
(
)
;
GrGLSLVertexBuilder
*
vertBuilder
=
args
.
fVertBuilder
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
varyingHandler
-
>
emitAttributes
(
diegp
)
;
GrGLSLVertToFrag
offsets0
(
kVec2f_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
EllipseOffsets0
"
&
offsets0
)
;
vertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
offsets0
.
vsOut
(
)
diegp
.
fInEllipseOffsets0
-
>
fName
)
;
GrGLSLVertToFrag
offsets1
(
kVec2f_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
EllipseOffsets1
"
&
offsets1
)
;
vertBuilder
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
offsets1
.
vsOut
(
)
diegp
.
fInEllipseOffsets1
-
>
fName
)
;
GrGLSLPPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
varyingHandler
-
>
addPassThroughAttribute
(
diegp
.
fInColor
args
.
fOutputColor
)
;
this
-
>
setupPosition
(
vertBuilder
uniformHandler
gpArgs
diegp
.
fInPosition
-
>
fName
diegp
.
fViewMatrix
&
fViewMatrixUniform
)
;
this
-
>
emitTransforms
(
vertBuilder
varyingHandler
uniformHandler
gpArgs
-
>
fPositionVar
diegp
.
fInPosition
-
>
fName
args
.
fFPCoordTransformHandler
)
;
SkAssertResult
(
fragBuilder
-
>
enableFeature
(
GrGLSLFragmentShaderBuilder
:
:
kStandardDerivatives_GLSLFeature
)
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
scaledOffset
=
%
s
.
xy
;
"
offsets0
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
float
test
=
dot
(
scaledOffset
scaledOffset
)
-
1
.
0
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
duvdx
=
dFdx
(
%
s
)
;
"
offsets0
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
duvdy
=
dFdy
(
%
s
)
;
"
offsets0
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
vec2
grad
=
vec2
(
2
.
0
*
%
s
.
x
*
duvdx
.
x
+
2
.
0
*
%
s
.
y
*
duvdx
.
y
"
"
2
.
0
*
%
s
.
x
*
duvdy
.
x
+
2
.
0
*
%
s
.
y
*
duvdy
.
y
)
;
"
offsets0
.
fsIn
(
)
offsets0
.
fsIn
(
)
offsets0
.
fsIn
(
)
offsets0
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
float
grad_dot
=
dot
(
grad
grad
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
grad_dot
=
max
(
grad_dot
1
.
0e
-
4
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
invlen
=
inversesqrt
(
grad_dot
)
;
"
)
;
if
(
DIEllipseStyle
:
:
kHairline
=
=
diegp
.
fStyle
)
{
fragBuilder
-
>
codeAppend
(
"
float
edgeAlpha
=
clamp
(
1
.
0
-
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
edgeAlpha
*
=
clamp
(
1
.
0
+
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
}
else
{
fragBuilder
-
>
codeAppend
(
"
float
edgeAlpha
=
clamp
(
0
.
5
-
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
}
if
(
DIEllipseStyle
:
:
kStroke
=
=
diegp
.
fStyle
)
{
fragBuilder
-
>
codeAppendf
(
"
scaledOffset
=
%
s
.
xy
;
"
offsets1
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
test
=
dot
(
scaledOffset
scaledOffset
)
-
1
.
0
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
duvdx
=
dFdx
(
%
s
)
;
"
offsets1
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
duvdy
=
dFdy
(
%
s
)
;
"
offsets1
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppendf
(
"
grad
=
vec2
(
2
.
0
*
%
s
.
x
*
duvdx
.
x
+
2
.
0
*
%
s
.
y
*
duvdx
.
y
"
"
2
.
0
*
%
s
.
x
*
duvdy
.
x
+
2
.
0
*
%
s
.
y
*
duvdy
.
y
)
;
"
offsets1
.
fsIn
(
)
offsets1
.
fsIn
(
)
offsets1
.
fsIn
(
)
offsets1
.
fsIn
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
invlen
=
inversesqrt
(
dot
(
grad
grad
)
)
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
edgeAlpha
*
=
clamp
(
0
.
5
+
test
*
invlen
0
.
0
1
.
0
)
;
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
edgeAlpha
)
;
"
args
.
fOutputCoverage
)
;
}
static
void
GenKey
(
const
GrGeometryProcessor
&
gp
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
DIEllipseGeometryProcessor
&
diegp
=
gp
.
cast
<
DIEllipseGeometryProcessor
>
(
)
;
uint16_t
key
=
static_cast
<
uint16_t
>
(
diegp
.
fStyle
)
;
key
|
=
ComputePosKey
(
diegp
.
fViewMatrix
)
<
<
10
;
b
-
>
add32
(
key
)
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
gp
FPCoordTransformIter
&
&
transformIter
)
override
{
const
DIEllipseGeometryProcessor
&
diegp
=
gp
.
cast
<
DIEllipseGeometryProcessor
>
(
)
;
if
(
!
diegp
.
fViewMatrix
.
isIdentity
(
)
&
&
!
fViewMatrix
.
cheapEqualTo
(
diegp
.
fViewMatrix
)
)
{
fViewMatrix
=
diegp
.
fViewMatrix
;
float
viewMatrix
[
3
*
3
]
;
GrGLSLGetMatrix
<
3
>
(
viewMatrix
fViewMatrix
)
;
pdman
.
setMatrix3f
(
fViewMatrixUniform
viewMatrix
)
;
}
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
private
:
SkMatrix
fViewMatrix
;
UniformHandle
fViewMatrixUniform
;
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
const
Attribute
*
fInPosition
;
const
Attribute
*
fInColor
;
const
Attribute
*
fInEllipseOffsets0
;
const
Attribute
*
fInEllipseOffsets1
;
SkMatrix
fViewMatrix
;
DIEllipseStyle
fStyle
;
GR_DECLARE_GEOMETRY_PROCESSOR_TEST
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
GR_DEFINE_GEOMETRY_PROCESSOR_TEST
(
DIEllipseGeometryProcessor
)
;
sk_sp
<
GrGeometryProcessor
>
DIEllipseGeometryProcessor
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
return
sk_sp
<
GrGeometryProcessor
>
(
new
DIEllipseGeometryProcessor
(
GrTest
:
:
TestMatrix
(
d
-
>
fRandom
)
(
DIEllipseStyle
)
(
d
-
>
fRandom
-
>
nextRangeU
(
0
2
)
)
)
)
;
}
class
CircleBatch
:
public
GrVertexBatch
{
public
:
DEFINE_BATCH_CLASS_ID
struct
ArcParams
{
SkScalar
fStartAngleRadians
;
SkScalar
fSweepAngleRadians
;
bool
fUseCenter
;
}
;
static
GrDrawBatch
*
Create
(
GrColor
color
const
SkMatrix
&
viewMatrix
SkPoint
center
SkScalar
radius
const
GrStyle
&
style
const
ArcParams
*
arcParams
=
nullptr
)
{
SkASSERT
(
circle_stays_circle
(
viewMatrix
)
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
style
.
hasPathEffect
(
)
)
{
return
nullptr
;
}
SkStrokeRec
:
:
Style
recStyle
=
stroke
.
getStyle
(
)
;
if
(
arcParams
)
{
switch
(
recStyle
)
{
case
SkStrokeRec
:
:
kStrokeAndFill_Style
:
return
nullptr
;
case
SkStrokeRec
:
:
kFill_Style
:
break
;
case
SkStrokeRec
:
:
kStroke_Style
:
case
SkStrokeRec
:
:
kHairline_Style
:
if
(
arcParams
-
>
fUseCenter
|
|
stroke
.
getCap
(
)
!
=
SkPaint
:
:
kButt_Cap
)
{
return
nullptr
;
}
break
;
}
}
viewMatrix
.
mapPoints
(
&
center
1
)
;
radius
=
viewMatrix
.
mapRadius
(
radius
)
;
SkScalar
strokeWidth
=
viewMatrix
.
mapRadius
(
stroke
.
getWidth
(
)
)
;
bool
isStrokeOnly
=
SkStrokeRec
:
:
kStroke_Style
=
=
recStyle
|
|
SkStrokeRec
:
:
kHairline_Style
=
=
recStyle
;
bool
hasStroke
=
isStrokeOnly
|
|
SkStrokeRec
:
:
kStrokeAndFill_Style
=
=
recStyle
;
SkScalar
innerRadius
=
0
.
0f
;
SkScalar
outerRadius
=
radius
;
SkScalar
halfWidth
=
0
;
if
(
hasStroke
)
{
if
(
SkScalarNearlyZero
(
strokeWidth
)
)
{
halfWidth
=
SK_ScalarHalf
;
}
else
{
halfWidth
=
SkScalarHalf
(
strokeWidth
)
;
}
outerRadius
+
=
halfWidth
;
if
(
isStrokeOnly
)
{
innerRadius
=
radius
-
halfWidth
;
}
}
outerRadius
+
=
SK_ScalarHalf
;
innerRadius
-
=
SK_ScalarHalf
;
CircleBatch
*
batch
=
new
CircleBatch
(
)
;
batch
-
>
fViewMatrixIfUsingLocalCoords
=
viewMatrix
;
static
constexpr
SkScalar
kUnusedIsectPlane
[
]
=
{
0
.
f
0
.
f
1
.
f
}
;
static
constexpr
SkScalar
kUnusedUnionPlane
[
]
=
{
0
.
f
0
.
f
0
.
f
}
;
SkRect
devBounds
=
SkRect
:
:
MakeLTRB
(
center
.
fX
-
outerRadius
center
.
fY
-
outerRadius
center
.
fX
+
outerRadius
center
.
fY
+
outerRadius
)
;
if
(
arcParams
)
{
SkPoint
startPoint
stopPoint
;
startPoint
.
fY
=
SkScalarSinCos
(
arcParams
-
>
fStartAngleRadians
&
startPoint
.
fX
)
;
SkScalar
endAngle
=
arcParams
-
>
fStartAngleRadians
+
arcParams
-
>
fSweepAngleRadians
;
stopPoint
.
fY
=
SkScalarSinCos
(
endAngle
&
stopPoint
.
fX
)
;
bool
useCenter
=
(
arcParams
-
>
fUseCenter
|
|
isStrokeOnly
)
&
&
!
SkScalarNearlyEqual
(
SkScalarAbs
(
arcParams
-
>
fSweepAngleRadians
)
SK_ScalarPI
)
;
if
(
useCenter
)
{
SkVector
norm0
=
{
startPoint
.
fY
-
startPoint
.
fX
}
;
SkVector
norm1
=
{
stopPoint
.
fY
-
stopPoint
.
fX
}
;
if
(
arcParams
-
>
fSweepAngleRadians
>
0
)
{
norm0
.
negate
(
)
;
}
else
{
norm1
.
negate
(
)
;
}
batch
-
>
fClipPlane
=
true
;
if
(
SkScalarAbs
(
arcParams
-
>
fSweepAngleRadians
)
>
SK_ScalarPI
)
{
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
innerRadius
outerRadius
{
norm0
.
fX
norm0
.
fY
0
.
5f
}
{
kUnusedIsectPlane
[
0
]
kUnusedIsectPlane
[
1
]
kUnusedIsectPlane
[
2
]
}
{
norm1
.
fX
norm1
.
fY
0
.
5f
}
devBounds
}
)
;
batch
-
>
fClipPlaneIsect
=
false
;
batch
-
>
fClipPlaneUnion
=
true
;
}
else
{
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
innerRadius
outerRadius
{
norm0
.
fX
norm0
.
fY
0
.
5f
}
{
norm1
.
fX
norm1
.
fY
0
.
5f
}
{
kUnusedUnionPlane
[
0
]
kUnusedUnionPlane
[
1
]
kUnusedUnionPlane
[
2
]
}
devBounds
}
)
;
batch
-
>
fClipPlaneIsect
=
true
;
batch
-
>
fClipPlaneUnion
=
false
;
}
}
else
{
startPoint
.
scale
(
radius
)
;
stopPoint
.
scale
(
radius
)
;
SkVector
norm
=
{
startPoint
.
fY
-
stopPoint
.
fY
stopPoint
.
fX
-
startPoint
.
fX
}
;
norm
.
normalize
(
)
;
if
(
arcParams
-
>
fSweepAngleRadians
>
0
)
{
norm
.
negate
(
)
;
}
SkScalar
d
=
-
norm
.
dot
(
startPoint
)
+
0
.
5f
;
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
innerRadius
outerRadius
{
norm
.
fX
norm
.
fY
d
}
{
kUnusedIsectPlane
[
0
]
kUnusedIsectPlane
[
1
]
kUnusedIsectPlane
[
2
]
}
{
kUnusedUnionPlane
[
0
]
kUnusedUnionPlane
[
1
]
kUnusedUnionPlane
[
2
]
}
devBounds
}
)
;
batch
-
>
fClipPlane
=
true
;
batch
-
>
fClipPlaneIsect
=
false
;
batch
-
>
fClipPlaneUnion
=
false
;
}
}
else
{
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
innerRadius
outerRadius
{
kUnusedIsectPlane
[
0
]
kUnusedIsectPlane
[
1
]
kUnusedIsectPlane
[
2
]
}
{
kUnusedIsectPlane
[
0
]
kUnusedIsectPlane
[
1
]
kUnusedIsectPlane
[
2
]
}
{
kUnusedUnionPlane
[
0
]
kUnusedUnionPlane
[
1
]
kUnusedUnionPlane
[
2
]
}
devBounds
}
)
;
batch
-
>
fClipPlane
=
false
;
batch
-
>
fClipPlaneIsect
=
false
;
batch
-
>
fClipPlaneUnion
=
false
;
}
radius
+
=
halfWidth
;
batch
-
>
setBounds
(
{
center
.
fX
-
radius
center
.
fY
-
radius
center
.
fX
+
radius
center
.
fY
+
radius
}
HasAABloat
:
:
kYes
IsZeroArea
:
:
kNo
)
;
batch
-
>
fStroked
=
isStrokeOnly
&
&
innerRadius
>
0
;
return
batch
;
}
const
char
*
name
(
)
const
override
{
return
"
CircleBatch
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
string
;
for
(
int
i
=
0
;
i
<
fGeoData
.
count
(
)
;
+
+
i
)
{
string
.
appendf
(
"
Color
:
0x
%
08x
Rect
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
"
InnerRad
:
%
.
2f
OuterRad
:
%
.
2f
\
n
"
fGeoData
[
i
]
.
fColor
fGeoData
[
i
]
.
fDevBounds
.
fLeft
fGeoData
[
i
]
.
fDevBounds
.
fTop
fGeoData
[
i
]
.
fDevBounds
.
fRight
fGeoData
[
i
]
.
fDevBounds
.
fBottom
fGeoData
[
i
]
.
fInnerRadius
fGeoData
[
i
]
.
fOuterRadius
)
;
}
string
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
string
;
}
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
override
{
color
-
>
setKnownFourComponents
(
fGeoData
[
0
]
.
fColor
)
;
coverage
-
>
setUnknownSingleComponent
(
)
;
}
private
:
CircleBatch
(
)
:
INHERITED
(
ClassID
(
)
)
{
}
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
overrides
)
override
{
overrides
.
getOverrideColorIfSet
(
&
fGeoData
[
0
]
.
fColor
)
;
if
(
!
overrides
.
readsLocalCoords
(
)
)
{
fViewMatrixIfUsingLocalCoords
.
reset
(
)
;
}
}
void
onPrepareDraws
(
Target
*
target
)
const
override
{
SkMatrix
localMatrix
;
if
(
!
fViewMatrixIfUsingLocalCoords
.
invert
(
&
localMatrix
)
)
{
return
;
}
SkAutoTUnref
<
GrGeometryProcessor
>
gp
(
new
CircleGeometryProcessor
(
fStroked
fClipPlane
fClipPlaneIsect
fClipPlaneUnion
localMatrix
)
)
;
struct
CircleVertex
{
SkPoint
fPos
;
GrColor
fColor
;
SkPoint
fOffset
;
SkScalar
fOuterRadius
;
SkScalar
fInnerRadius
;
SkScalar
fHalfPlanes
[
3
]
[
3
]
;
}
;
int
instanceCount
=
fGeoData
.
count
(
)
;
size_t
vertexStride
=
gp
-
>
getVertexStride
(
)
;
SkASSERT
(
vertexStride
=
=
sizeof
(
CircleVertex
)
-
(
fClipPlane
?
0
:
3
*
sizeof
(
SkScalar
)
)
-
(
fClipPlaneIsect
?
0
:
3
*
sizeof
(
SkScalar
)
)
-
(
fClipPlaneUnion
?
0
:
3
*
sizeof
(
SkScalar
)
)
)
;
QuadHelper
helper
;
char
*
vertices
=
reinterpret_cast
<
char
*
>
(
helper
.
init
(
target
vertexStride
instanceCount
)
)
;
if
(
!
vertices
)
{
return
;
}
for
(
int
i
=
0
;
i
<
instanceCount
;
i
+
+
)
{
const
Geometry
&
geom
=
fGeoData
[
i
]
;
GrColor
color
=
geom
.
fColor
;
SkScalar
innerRadius
=
geom
.
fInnerRadius
;
SkScalar
outerRadius
=
geom
.
fOuterRadius
;
const
SkRect
&
bounds
=
geom
.
fDevBounds
;
CircleVertex
*
v0
=
reinterpret_cast
<
CircleVertex
*
>
(
vertices
+
(
4
*
i
+
0
)
*
vertexStride
)
;
CircleVertex
*
v1
=
reinterpret_cast
<
CircleVertex
*
>
(
vertices
+
(
4
*
i
+
1
)
*
vertexStride
)
;
CircleVertex
*
v2
=
reinterpret_cast
<
CircleVertex
*
>
(
vertices
+
(
4
*
i
+
2
)
*
vertexStride
)
;
CircleVertex
*
v3
=
reinterpret_cast
<
CircleVertex
*
>
(
vertices
+
(
4
*
i
+
3
)
*
vertexStride
)
;
innerRadius
=
innerRadius
/
outerRadius
;
v0
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fTop
)
;
v0
-
>
fColor
=
color
;
v0
-
>
fOffset
=
SkPoint
:
:
Make
(
-
1
-
1
)
;
v0
-
>
fOuterRadius
=
outerRadius
;
v0
-
>
fInnerRadius
=
innerRadius
;
v1
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fBottom
)
;
v1
-
>
fColor
=
color
;
v1
-
>
fOffset
=
SkPoint
:
:
Make
(
-
1
1
)
;
v1
-
>
fOuterRadius
=
outerRadius
;
v1
-
>
fInnerRadius
=
innerRadius
;
v2
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fBottom
)
;
v2
-
>
fColor
=
color
;
v2
-
>
fOffset
=
SkPoint
:
:
Make
(
1
1
)
;
v2
-
>
fOuterRadius
=
outerRadius
;
v2
-
>
fInnerRadius
=
innerRadius
;
v3
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fTop
)
;
v3
-
>
fColor
=
color
;
v3
-
>
fOffset
=
SkPoint
:
:
Make
(
1
-
1
)
;
v3
-
>
fOuterRadius
=
outerRadius
;
v3
-
>
fInnerRadius
=
innerRadius
;
if
(
fClipPlane
)
{
memcpy
(
v0
-
>
fHalfPlanes
[
0
]
geom
.
fClipPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v1
-
>
fHalfPlanes
[
0
]
geom
.
fClipPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v2
-
>
fHalfPlanes
[
0
]
geom
.
fClipPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v3
-
>
fHalfPlanes
[
0
]
geom
.
fClipPlane
3
*
sizeof
(
SkScalar
)
)
;
}
int
unionIdx
=
1
;
if
(
fClipPlaneIsect
)
{
memcpy
(
v0
-
>
fHalfPlanes
[
1
]
geom
.
fIsectPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v1
-
>
fHalfPlanes
[
1
]
geom
.
fIsectPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v2
-
>
fHalfPlanes
[
1
]
geom
.
fIsectPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v3
-
>
fHalfPlanes
[
1
]
geom
.
fIsectPlane
3
*
sizeof
(
SkScalar
)
)
;
unionIdx
=
2
;
}
if
(
fClipPlaneUnion
)
{
memcpy
(
v0
-
>
fHalfPlanes
[
unionIdx
]
geom
.
fUnionPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v1
-
>
fHalfPlanes
[
unionIdx
]
geom
.
fUnionPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v2
-
>
fHalfPlanes
[
unionIdx
]
geom
.
fUnionPlane
3
*
sizeof
(
SkScalar
)
)
;
memcpy
(
v3
-
>
fHalfPlanes
[
unionIdx
]
geom
.
fUnionPlane
3
*
sizeof
(
SkScalar
)
)
;
}
}
helper
.
recordDraw
(
target
gp
)
;
}
bool
onCombineIfPossible
(
GrBatch
*
t
const
GrCaps
&
caps
)
override
{
CircleBatch
*
that
=
t
-
>
cast
<
CircleBatch
>
(
)
;
if
(
!
GrPipeline
:
:
CanCombine
(
*
this
-
>
pipeline
(
)
this
-
>
bounds
(
)
*
that
-
>
pipeline
(
)
that
-
>
bounds
(
)
caps
)
)
{
return
false
;
}
if
(
this
-
>
fStroked
!
=
that
-
>
fStroked
)
{
return
false
;
}
fClipPlane
|
=
that
-
>
fClipPlane
;
fClipPlaneIsect
|
=
that
-
>
fClipPlaneIsect
;
fClipPlaneUnion
|
=
that
-
>
fClipPlaneUnion
;
if
(
!
fViewMatrixIfUsingLocalCoords
.
cheapEqualTo
(
that
-
>
fViewMatrixIfUsingLocalCoords
)
)
{
return
false
;
}
fGeoData
.
push_back_n
(
that
-
>
fGeoData
.
count
(
)
that
-
>
fGeoData
.
begin
(
)
)
;
this
-
>
joinBounds
(
*
that
)
;
return
true
;
}
struct
Geometry
{
GrColor
fColor
;
SkScalar
fInnerRadius
;
SkScalar
fOuterRadius
;
SkScalar
fClipPlane
[
3
]
;
SkScalar
fIsectPlane
[
3
]
;
SkScalar
fUnionPlane
[
3
]
;
SkRect
fDevBounds
;
}
;
bool
fStroked
;
bool
fClipPlane
;
bool
fClipPlaneIsect
;
bool
fClipPlaneUnion
;
SkMatrix
fViewMatrixIfUsingLocalCoords
;
SkSTArray
<
1
Geometry
true
>
fGeoData
;
typedef
GrVertexBatch
INHERITED
;
}
;
class
EllipseBatch
:
public
GrVertexBatch
{
public
:
DEFINE_BATCH_CLASS_ID
static
GrDrawBatch
*
Create
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
ellipse
const
SkStrokeRec
&
stroke
)
{
SkASSERT
(
viewMatrix
.
rectStaysRect
(
)
)
;
SkPoint
center
=
SkPoint
:
:
Make
(
ellipse
.
centerX
(
)
ellipse
.
centerY
(
)
)
;
viewMatrix
.
mapPoints
(
&
center
1
)
;
SkScalar
ellipseXRadius
=
SkScalarHalf
(
ellipse
.
width
(
)
)
;
SkScalar
ellipseYRadius
=
SkScalarHalf
(
ellipse
.
height
(
)
)
;
SkScalar
xRadius
=
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
*
ellipseXRadius
+
viewMatrix
[
SkMatrix
:
:
kMSkewY
]
*
ellipseYRadius
)
;
SkScalar
yRadius
=
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
*
ellipseXRadius
+
viewMatrix
[
SkMatrix
:
:
kMScaleY
]
*
ellipseYRadius
)
;
SkVector
scaledStroke
;
SkScalar
strokeWidth
=
stroke
.
getWidth
(
)
;
scaledStroke
.
fX
=
SkScalarAbs
(
strokeWidth
*
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
+
viewMatrix
[
SkMatrix
:
:
kMSkewY
]
)
)
;
scaledStroke
.
fY
=
SkScalarAbs
(
strokeWidth
*
(
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
+
viewMatrix
[
SkMatrix
:
:
kMScaleY
]
)
)
;
SkStrokeRec
:
:
Style
style
=
stroke
.
getStyle
(
)
;
bool
isStrokeOnly
=
SkStrokeRec
:
:
kStroke_Style
=
=
style
|
|
SkStrokeRec
:
:
kHairline_Style
=
=
style
;
bool
hasStroke
=
isStrokeOnly
|
|
SkStrokeRec
:
:
kStrokeAndFill_Style
=
=
style
;
SkScalar
innerXRadius
=
0
;
SkScalar
innerYRadius
=
0
;
if
(
hasStroke
)
{
if
(
SkScalarNearlyZero
(
scaledStroke
.
length
(
)
)
)
{
scaledStroke
.
set
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
else
{
scaledStroke
.
scale
(
SK_ScalarHalf
)
;
}
if
(
scaledStroke
.
length
(
)
>
SK_ScalarHalf
&
&
(
SK_ScalarHalf
*
xRadius
>
yRadius
|
|
SK_ScalarHalf
*
yRadius
>
xRadius
)
)
{
return
nullptr
;
}
if
(
scaledStroke
.
fX
*
(
yRadius
*
yRadius
)
<
(
scaledStroke
.
fY
*
scaledStroke
.
fY
)
*
xRadius
|
|
scaledStroke
.
fY
*
(
xRadius
*
xRadius
)
<
(
scaledStroke
.
fX
*
scaledStroke
.
fX
)
*
yRadius
)
{
return
nullptr
;
}
if
(
isStrokeOnly
)
{
innerXRadius
=
xRadius
-
scaledStroke
.
fX
;
innerYRadius
=
yRadius
-
scaledStroke
.
fY
;
}
xRadius
+
=
scaledStroke
.
fX
;
yRadius
+
=
scaledStroke
.
fY
;
}
EllipseBatch
*
batch
=
new
EllipseBatch
(
)
;
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
xRadius
yRadius
innerXRadius
innerYRadius
SkRect
:
:
MakeLTRB
(
center
.
fX
-
xRadius
center
.
fY
-
yRadius
center
.
fX
+
xRadius
center
.
fY
+
yRadius
)
}
)
;
batch
-
>
setBounds
(
batch
-
>
fGeoData
.
back
(
)
.
fDevBounds
HasAABloat
:
:
kYes
IsZeroArea
:
:
kNo
)
;
batch
-
>
fGeoData
[
0
]
.
fDevBounds
.
outset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
batch
-
>
fStroked
=
isStrokeOnly
&
&
innerXRadius
>
0
&
&
innerYRadius
>
0
;
batch
-
>
fViewMatrixIfUsingLocalCoords
=
viewMatrix
;
return
batch
;
}
const
char
*
name
(
)
const
override
{
return
"
EllipseBatch
"
;
}
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
override
{
color
-
>
setKnownFourComponents
(
fGeoData
[
0
]
.
fColor
)
;
coverage
-
>
setUnknownSingleComponent
(
)
;
}
private
:
EllipseBatch
(
)
:
INHERITED
(
ClassID
(
)
)
{
}
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
overrides
)
override
{
if
(
!
overrides
.
readsCoverage
(
)
)
{
fGeoData
[
0
]
.
fColor
=
GrColor_ILLEGAL
;
}
if
(
!
overrides
.
readsLocalCoords
(
)
)
{
fViewMatrixIfUsingLocalCoords
.
reset
(
)
;
}
}
void
onPrepareDraws
(
Target
*
target
)
const
override
{
SkMatrix
localMatrix
;
if
(
!
fViewMatrixIfUsingLocalCoords
.
invert
(
&
localMatrix
)
)
{
return
;
}
SkAutoTUnref
<
GrGeometryProcessor
>
gp
(
new
EllipseGeometryProcessor
(
fStroked
localMatrix
)
)
;
int
instanceCount
=
fGeoData
.
count
(
)
;
QuadHelper
helper
;
size_t
vertexStride
=
gp
-
>
getVertexStride
(
)
;
SkASSERT
(
vertexStride
=
=
sizeof
(
EllipseVertex
)
)
;
EllipseVertex
*
verts
=
reinterpret_cast
<
EllipseVertex
*
>
(
helper
.
init
(
target
vertexStride
instanceCount
)
)
;
if
(
!
verts
)
{
return
;
}
for
(
int
i
=
0
;
i
<
instanceCount
;
i
+
+
)
{
const
Geometry
&
geom
=
fGeoData
[
i
]
;
GrColor
color
=
geom
.
fColor
;
SkScalar
xRadius
=
geom
.
fXRadius
;
SkScalar
yRadius
=
geom
.
fYRadius
;
SkScalar
xRadRecip
=
SkScalarInvert
(
xRadius
)
;
SkScalar
yRadRecip
=
SkScalarInvert
(
yRadius
)
;
SkScalar
xInnerRadRecip
=
SkScalarInvert
(
geom
.
fInnerXRadius
)
;
SkScalar
yInnerRadRecip
=
SkScalarInvert
(
geom
.
fInnerYRadius
)
;
const
SkRect
&
bounds
=
geom
.
fDevBounds
;
SkScalar
xMaxOffset
=
xRadius
+
SK_ScalarHalf
;
SkScalar
yMaxOffset
=
yRadius
+
SK_ScalarHalf
;
verts
[
0
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fTop
)
;
verts
[
0
]
.
fColor
=
color
;
verts
[
0
]
.
fOffset
=
SkPoint
:
:
Make
(
-
xMaxOffset
-
yMaxOffset
)
;
verts
[
0
]
.
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
[
0
]
.
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
[
1
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fBottom
)
;
verts
[
1
]
.
fColor
=
color
;
verts
[
1
]
.
fOffset
=
SkPoint
:
:
Make
(
-
xMaxOffset
yMaxOffset
)
;
verts
[
1
]
.
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
[
1
]
.
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
[
2
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fBottom
)
;
verts
[
2
]
.
fColor
=
color
;
verts
[
2
]
.
fOffset
=
SkPoint
:
:
Make
(
xMaxOffset
yMaxOffset
)
;
verts
[
2
]
.
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
[
2
]
.
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
[
3
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fTop
)
;
verts
[
3
]
.
fColor
=
color
;
verts
[
3
]
.
fOffset
=
SkPoint
:
:
Make
(
xMaxOffset
-
yMaxOffset
)
;
verts
[
3
]
.
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
[
3
]
.
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
+
=
kVerticesPerQuad
;
}
helper
.
recordDraw
(
target
gp
)
;
}
bool
onCombineIfPossible
(
GrBatch
*
t
const
GrCaps
&
caps
)
override
{
EllipseBatch
*
that
=
t
-
>
cast
<
EllipseBatch
>
(
)
;
if
(
!
GrPipeline
:
:
CanCombine
(
*
this
-
>
pipeline
(
)
this
-
>
bounds
(
)
*
that
-
>
pipeline
(
)
that
-
>
bounds
(
)
caps
)
)
{
return
false
;
}
if
(
fStroked
!
=
that
-
>
fStroked
)
{
return
false
;
}
if
(
!
fViewMatrixIfUsingLocalCoords
.
cheapEqualTo
(
that
-
>
fViewMatrixIfUsingLocalCoords
)
)
{
return
false
;
}
fGeoData
.
push_back_n
(
that
-
>
fGeoData
.
count
(
)
that
-
>
fGeoData
.
begin
(
)
)
;
this
-
>
joinBounds
(
*
that
)
;
return
true
;
}
struct
Geometry
{
GrColor
fColor
;
SkScalar
fXRadius
;
SkScalar
fYRadius
;
SkScalar
fInnerXRadius
;
SkScalar
fInnerYRadius
;
SkRect
fDevBounds
;
}
;
bool
fStroked
;
SkMatrix
fViewMatrixIfUsingLocalCoords
;
SkSTArray
<
1
Geometry
true
>
fGeoData
;
typedef
GrVertexBatch
INHERITED
;
}
;
class
DIEllipseBatch
:
public
GrVertexBatch
{
public
:
DEFINE_BATCH_CLASS_ID
static
GrDrawBatch
*
Create
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
ellipse
const
SkStrokeRec
&
stroke
)
{
SkPoint
center
=
SkPoint
:
:
Make
(
ellipse
.
centerX
(
)
ellipse
.
centerY
(
)
)
;
SkScalar
xRadius
=
SkScalarHalf
(
ellipse
.
width
(
)
)
;
SkScalar
yRadius
=
SkScalarHalf
(
ellipse
.
height
(
)
)
;
SkStrokeRec
:
:
Style
style
=
stroke
.
getStyle
(
)
;
DIEllipseStyle
dieStyle
=
(
SkStrokeRec
:
:
kStroke_Style
=
=
style
)
?
DIEllipseStyle
:
:
kStroke
:
(
SkStrokeRec
:
:
kHairline_Style
=
=
style
)
?
DIEllipseStyle
:
:
kHairline
:
DIEllipseStyle
:
:
kFill
;
SkScalar
innerXRadius
=
0
;
SkScalar
innerYRadius
=
0
;
if
(
SkStrokeRec
:
:
kFill_Style
!
=
style
&
&
SkStrokeRec
:
:
kHairline_Style
!
=
style
)
{
SkScalar
strokeWidth
=
stroke
.
getWidth
(
)
;
if
(
SkScalarNearlyZero
(
strokeWidth
)
)
{
strokeWidth
=
SK_ScalarHalf
;
}
else
{
strokeWidth
*
=
SK_ScalarHalf
;
}
if
(
strokeWidth
>
SK_ScalarHalf
&
&
(
SK_ScalarHalf
*
xRadius
>
yRadius
|
|
SK_ScalarHalf
*
yRadius
>
xRadius
)
)
{
return
nullptr
;
}
if
(
strokeWidth
*
(
yRadius
*
yRadius
)
<
(
strokeWidth
*
strokeWidth
)
*
xRadius
|
|
strokeWidth
*
(
xRadius
*
xRadius
)
<
(
strokeWidth
*
strokeWidth
)
*
yRadius
)
{
return
nullptr
;
}
if
(
SkStrokeRec
:
:
kStroke_Style
=
=
style
)
{
innerXRadius
=
xRadius
-
strokeWidth
;
innerYRadius
=
yRadius
-
strokeWidth
;
}
xRadius
+
=
strokeWidth
;
yRadius
+
=
strokeWidth
;
}
if
(
DIEllipseStyle
:
:
kStroke
=
=
dieStyle
)
{
dieStyle
=
(
innerXRadius
>
0
&
&
innerYRadius
>
0
)
?
DIEllipseStyle
:
:
kStroke
:
DIEllipseStyle
:
:
kFill
;
}
SkScalar
a
=
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
;
SkScalar
b
=
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
;
SkScalar
c
=
viewMatrix
[
SkMatrix
:
:
kMSkewY
]
;
SkScalar
d
=
viewMatrix
[
SkMatrix
:
:
kMScaleY
]
;
SkScalar
geoDx
=
SK_ScalarHalf
/
SkScalarSqrt
(
a
*
a
+
c
*
c
)
;
SkScalar
geoDy
=
SK_ScalarHalf
/
SkScalarSqrt
(
b
*
b
+
d
*
d
)
;
DIEllipseBatch
*
batch
=
new
DIEllipseBatch
(
)
;
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
viewMatrix
color
xRadius
yRadius
innerXRadius
innerYRadius
geoDx
geoDy
dieStyle
SkRect
:
:
MakeLTRB
(
center
.
fX
-
xRadius
-
geoDx
center
.
fY
-
yRadius
-
geoDy
center
.
fX
+
xRadius
+
geoDx
center
.
fY
+
yRadius
+
geoDy
)
}
)
;
batch
-
>
setTransformedBounds
(
batch
-
>
fGeoData
[
0
]
.
fBounds
viewMatrix
HasAABloat
:
:
kYes
IsZeroArea
:
:
kNo
)
;
return
batch
;
}
const
char
*
name
(
)
const
override
{
return
"
DIEllipseBatch
"
;
}
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
override
{
color
-
>
setKnownFourComponents
(
fGeoData
[
0
]
.
fColor
)
;
coverage
-
>
setUnknownSingleComponent
(
)
;
}
private
:
DIEllipseBatch
(
)
:
INHERITED
(
ClassID
(
)
)
{
}
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
overrides
)
override
{
overrides
.
getOverrideColorIfSet
(
&
fGeoData
[
0
]
.
fColor
)
;
fUsesLocalCoords
=
overrides
.
readsLocalCoords
(
)
;
}
void
onPrepareDraws
(
Target
*
target
)
const
override
{
SkAutoTUnref
<
GrGeometryProcessor
>
gp
(
new
DIEllipseGeometryProcessor
(
this
-
>
viewMatrix
(
)
this
-
>
style
(
)
)
)
;
int
instanceCount
=
fGeoData
.
count
(
)
;
size_t
vertexStride
=
gp
-
>
getVertexStride
(
)
;
SkASSERT
(
vertexStride
=
=
sizeof
(
DIEllipseVertex
)
)
;
QuadHelper
helper
;
DIEllipseVertex
*
verts
=
reinterpret_cast
<
DIEllipseVertex
*
>
(
helper
.
init
(
target
vertexStride
instanceCount
)
)
;
if
(
!
verts
)
{
return
;
}
for
(
int
i
=
0
;
i
<
instanceCount
;
i
+
+
)
{
const
Geometry
&
geom
=
fGeoData
[
i
]
;
GrColor
color
=
geom
.
fColor
;
SkScalar
xRadius
=
geom
.
fXRadius
;
SkScalar
yRadius
=
geom
.
fYRadius
;
const
SkRect
&
bounds
=
geom
.
fBounds
;
SkScalar
offsetDx
=
geom
.
fGeoDx
/
xRadius
;
SkScalar
offsetDy
=
geom
.
fGeoDy
/
yRadius
;
SkScalar
innerRatioX
=
xRadius
/
geom
.
fInnerXRadius
;
SkScalar
innerRatioY
=
yRadius
/
geom
.
fInnerYRadius
;
verts
[
0
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fTop
)
;
verts
[
0
]
.
fColor
=
color
;
verts
[
0
]
.
fOuterOffset
=
SkPoint
:
:
Make
(
-
1
.
0f
-
offsetDx
-
1
.
0f
-
offsetDy
)
;
verts
[
0
]
.
fInnerOffset
=
SkPoint
:
:
Make
(
-
innerRatioX
-
offsetDx
-
innerRatioY
-
offsetDy
)
;
verts
[
1
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
bounds
.
fBottom
)
;
verts
[
1
]
.
fColor
=
color
;
verts
[
1
]
.
fOuterOffset
=
SkPoint
:
:
Make
(
-
1
.
0f
-
offsetDx
1
.
0f
+
offsetDy
)
;
verts
[
1
]
.
fInnerOffset
=
SkPoint
:
:
Make
(
-
innerRatioX
-
offsetDx
innerRatioY
+
offsetDy
)
;
verts
[
2
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fBottom
)
;
verts
[
2
]
.
fColor
=
color
;
verts
[
2
]
.
fOuterOffset
=
SkPoint
:
:
Make
(
1
.
0f
+
offsetDx
1
.
0f
+
offsetDy
)
;
verts
[
2
]
.
fInnerOffset
=
SkPoint
:
:
Make
(
innerRatioX
+
offsetDx
innerRatioY
+
offsetDy
)
;
verts
[
3
]
.
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
bounds
.
fTop
)
;
verts
[
3
]
.
fColor
=
color
;
verts
[
3
]
.
fOuterOffset
=
SkPoint
:
:
Make
(
1
.
0f
+
offsetDx
-
1
.
0f
-
offsetDy
)
;
verts
[
3
]
.
fInnerOffset
=
SkPoint
:
:
Make
(
innerRatioX
+
offsetDx
-
innerRatioY
-
offsetDy
)
;
verts
+
=
kVerticesPerQuad
;
}
helper
.
recordDraw
(
target
gp
)
;
}
bool
onCombineIfPossible
(
GrBatch
*
t
const
GrCaps
&
caps
)
override
{
DIEllipseBatch
*
that
=
t
-
>
cast
<
DIEllipseBatch
>
(
)
;
if
(
!
GrPipeline
:
:
CanCombine
(
*
this
-
>
pipeline
(
)
this
-
>
bounds
(
)
*
that
-
>
pipeline
(
)
that
-
>
bounds
(
)
caps
)
)
{
return
false
;
}
if
(
this
-
>
style
(
)
!
=
that
-
>
style
(
)
)
{
return
false
;
}
if
(
!
this
-
>
viewMatrix
(
)
.
cheapEqualTo
(
that
-
>
viewMatrix
(
)
)
)
{
return
false
;
}
fGeoData
.
push_back_n
(
that
-
>
fGeoData
.
count
(
)
that
-
>
fGeoData
.
begin
(
)
)
;
this
-
>
joinBounds
(
*
that
)
;
return
true
;
}
const
SkMatrix
&
viewMatrix
(
)
const
{
return
fGeoData
[
0
]
.
fViewMatrix
;
}
DIEllipseStyle
style
(
)
const
{
return
fGeoData
[
0
]
.
fStyle
;
}
struct
Geometry
{
SkMatrix
fViewMatrix
;
GrColor
fColor
;
SkScalar
fXRadius
;
SkScalar
fYRadius
;
SkScalar
fInnerXRadius
;
SkScalar
fInnerYRadius
;
SkScalar
fGeoDx
;
SkScalar
fGeoDy
;
DIEllipseStyle
fStyle
;
SkRect
fBounds
;
}
;
bool
fUsesLocalCoords
;
SkSTArray
<
1
Geometry
true
>
fGeoData
;
typedef
GrVertexBatch
INHERITED
;
}
;
static
const
uint16_t
gOverstrokeRRectIndices
[
]
=
{
16
17
19
16
19
18
19
17
23
19
23
21
21
23
22
21
22
20
22
16
18
22
18
20
0
1
5
0
5
4
2
3
7
2
7
6
8
9
13
8
13
12
10
11
15
10
15
14
1
2
6
1
6
5
4
5
9
4
9
8
6
7
11
6
11
10
9
10
14
9
14
13
5
6
10
5
10
9
}
;
static
const
uint16_t
*
gStandardRRectIndices
=
gOverstrokeRRectIndices
+
6
*
4
;
static
const
int
kIndicesPerOverstrokeRRect
=
SK_ARRAY_COUNT
(
gOverstrokeRRectIndices
)
-
6
;
static
const
int
kIndicesPerFillRRect
=
kIndicesPerOverstrokeRRect
-
6
*
4
+
6
;
static
const
int
kIndicesPerStrokeRRect
=
kIndicesPerFillRRect
-
6
;
static
const
int
kVertsPerStandardRRect
=
16
;
static
const
int
kVertsPerOverstrokeRRect
=
24
;
enum
RRectType
{
kFill_RRectType
kStroke_RRectType
kOverstroke_RRectType
}
;
static
int
rrect_type_to_vert_count
(
RRectType
type
)
{
static
const
int
kTypeToVertCount
[
]
=
{
kVertsPerStandardRRect
kVertsPerStandardRRect
kVertsPerOverstrokeRRect
}
;
return
kTypeToVertCount
[
type
]
;
}
static
int
rrect_type_to_index_count
(
RRectType
type
)
{
static
const
int
kTypeToIndexCount
[
]
=
{
kIndicesPerFillRRect
kIndicesPerStrokeRRect
kIndicesPerOverstrokeRRect
}
;
return
kTypeToIndexCount
[
type
]
;
}
static
const
uint16_t
*
rrect_type_to_indices
(
RRectType
type
)
{
static
const
uint16_t
*
kTypeToIndices
[
]
=
{
gStandardRRectIndices
gStandardRRectIndices
gOverstrokeRRectIndices
}
;
return
kTypeToIndices
[
type
]
;
}
class
RRectCircleRendererBatch
:
public
GrVertexBatch
{
public
:
DEFINE_BATCH_CLASS_ID
RRectCircleRendererBatch
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
devRect
float
devRadius
float
devStrokeWidth
bool
strokeOnly
)
:
INHERITED
(
ClassID
(
)
)
fViewMatrixIfUsingLocalCoords
(
viewMatrix
)
{
SkRect
bounds
=
devRect
;
SkASSERT
(
!
(
devStrokeWidth
<
=
0
&
&
strokeOnly
)
)
;
SkScalar
innerRadius
=
0
.
0f
;
SkScalar
outerRadius
=
devRadius
;
SkScalar
halfWidth
=
0
;
RRectType
type
=
kFill_RRectType
;
if
(
devStrokeWidth
>
0
)
{
if
(
SkScalarNearlyZero
(
devStrokeWidth
)
)
{
halfWidth
=
SK_ScalarHalf
;
}
else
{
halfWidth
=
SkScalarHalf
(
devStrokeWidth
)
;
}
if
(
strokeOnly
)
{
devStrokeWidth
+
=
0
.
25f
;
if
(
devStrokeWidth
<
=
devRect
.
width
(
)
&
&
devStrokeWidth
<
=
devRect
.
height
(
)
)
{
innerRadius
=
devRadius
-
halfWidth
;
type
=
(
innerRadius
>
=
0
)
?
kStroke_RRectType
:
kOverstroke_RRectType
;
}
}
outerRadius
+
=
halfWidth
;
bounds
.
outset
(
halfWidth
halfWidth
)
;
}
outerRadius
+
=
SK_ScalarHalf
;
innerRadius
-
=
SK_ScalarHalf
;
this
-
>
setBounds
(
bounds
HasAABloat
:
:
kYes
IsZeroArea
:
:
kNo
)
;
bounds
.
outset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
fGeoData
.
emplace_back
(
Geometry
{
color
innerRadius
outerRadius
bounds
type
}
)
;
fVertCount
=
rrect_type_to_vert_count
(
type
)
;
fIndexCount
=
rrect_type_to_index_count
(
type
)
;
fAllFill
=
(
kFill_RRectType
=
=
type
)
;
}
const
char
*
name
(
)
const
override
{
return
"
RRectCircleBatch
"
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
string
;
for
(
int
i
=
0
;
i
<
fGeoData
.
count
(
)
;
+
+
i
)
{
string
.
appendf
(
"
Color
:
0x
%
08x
Rect
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
"
"
InnerRad
:
%
.
2f
OuterRad
:
%
.
2f
\
n
"
fGeoData
[
i
]
.
fColor
fGeoData
[
i
]
.
fDevBounds
.
fLeft
fGeoData
[
i
]
.
fDevBounds
.
fTop
fGeoData
[
i
]
.
fDevBounds
.
fRight
fGeoData
[
i
]
.
fDevBounds
.
fBottom
fGeoData
[
i
]
.
fInnerRadius
fGeoData
[
i
]
.
fOuterRadius
)
;
}
string
.
append
(
INHERITED
:
:
dumpInfo
(
)
)
;
return
string
;
}
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
override
{
color
-
>
setKnownFourComponents
(
fGeoData
[
0
]
.
fColor
)
;
coverage
-
>
setUnknownSingleComponent
(
)
;
}
private
:
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
overrides
)
override
{
overrides
.
getOverrideColorIfSet
(
&
fGeoData
[
0
]
.
fColor
)
;
if
(
!
overrides
.
readsLocalCoords
(
)
)
{
fViewMatrixIfUsingLocalCoords
.
reset
(
)
;
}
}
void
onPrepareDraws
(
Target
*
target
)
const
override
{
SkMatrix
localMatrix
;
if
(
!
fViewMatrixIfUsingLocalCoords
.
invert
(
&
localMatrix
)
)
{
return
;
}
SkAutoTUnref
<
GrGeometryProcessor
>
gp
(
new
CircleGeometryProcessor
(
!
fAllFill
false
false
false
localMatrix
)
)
;
struct
CircleVertex
{
SkPoint
fPos
;
GrColor
fColor
;
SkPoint
fOffset
;
SkScalar
fOuterRadius
;
SkScalar
fInnerRadius
;
}
;
int
instanceCount
=
fGeoData
.
count
(
)
;
size_t
vertexStride
=
gp
-
>
getVertexStride
(
)
;
SkASSERT
(
sizeof
(
CircleVertex
)
=
=
vertexStride
)
;
const
GrBuffer
*
vertexBuffer
;
int
firstVertex
;
CircleVertex
*
verts
=
(
CircleVertex
*
)
target
-
>
makeVertexSpace
(
vertexStride
fVertCount
&
vertexBuffer
&
firstVertex
)
;
if
(
!
verts
)
{
SkDebugf
(
"
Could
not
allocate
vertices
\
n
"
)
;
return
;
}
const
GrBuffer
*
indexBuffer
=
nullptr
;
int
firstIndex
=
0
;
uint16_t
*
indices
=
target
-
>
makeIndexSpace
(
fIndexCount
&
indexBuffer
&
firstIndex
)
;
if
(
!
indices
)
{
SkDebugf
(
"
Could
not
allocate
indices
\
n
"
)
;
return
;
}
int
currStartVertex
=
0
;
for
(
int
i
=
0
;
i
<
instanceCount
;
i
+
+
)
{
const
Geometry
&
args
=
fGeoData
[
i
]
;
GrColor
color
=
args
.
fColor
;
SkScalar
outerRadius
=
args
.
fOuterRadius
;
const
SkRect
&
bounds
=
args
.
fDevBounds
;
SkScalar
yCoords
[
4
]
=
{
bounds
.
fTop
bounds
.
fTop
+
outerRadius
bounds
.
fBottom
-
outerRadius
bounds
.
fBottom
}
;
SkScalar
yOuterRadii
[
4
]
=
{
-
1
0
0
1
}
;
SkScalar
innerRadius
=
args
.
fType
!
=
kFill_RRectType
?
args
.
fInnerRadius
/
args
.
fOuterRadius
:
-
1
.
0f
/
args
.
fOuterRadius
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
-
1
yOuterRadii
[
i
]
)
;
verts
-
>
fOuterRadius
=
outerRadius
;
verts
-
>
fInnerRadius
=
innerRadius
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
outerRadius
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
yOuterRadii
[
i
]
)
;
verts
-
>
fOuterRadius
=
outerRadius
;
verts
-
>
fInnerRadius
=
innerRadius
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
outerRadius
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
yOuterRadii
[
i
]
)
;
verts
-
>
fOuterRadius
=
outerRadius
;
verts
-
>
fInnerRadius
=
innerRadius
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
1
yOuterRadii
[
i
]
)
;
verts
-
>
fOuterRadius
=
outerRadius
;
verts
-
>
fInnerRadius
=
innerRadius
;
verts
+
+
;
}
if
(
kOverstroke_RRectType
=
=
args
.
fType
)
{
SkScalar
overstrokeOuterRadius
=
outerRadius
-
args
.
fInnerRadius
;
SkScalar
maxOffset
=
-
args
.
fInnerRadius
/
overstrokeOuterRadius
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
outerRadius
yCoords
[
1
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
maxOffset
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
outerRadius
yCoords
[
1
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
maxOffset
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
overstrokeOuterRadius
bounds
.
fTop
+
overstrokeOuterRadius
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
overstrokeOuterRadius
bounds
.
fTop
+
overstrokeOuterRadius
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
overstrokeOuterRadius
bounds
.
fBottom
-
overstrokeOuterRadius
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
overstrokeOuterRadius
bounds
.
fBottom
-
overstrokeOuterRadius
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
0
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
outerRadius
yCoords
[
2
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
maxOffset
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
outerRadius
yCoords
[
2
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
maxOffset
0
)
;
verts
-
>
fOuterRadius
=
overstrokeOuterRadius
;
verts
-
>
fInnerRadius
=
0
;
verts
+
+
;
}
const
uint16_t
*
primIndices
=
rrect_type_to_indices
(
args
.
fType
)
;
const
int
primIndexCount
=
rrect_type_to_index_count
(
args
.
fType
)
;
for
(
int
i
=
0
;
i
<
primIndexCount
;
+
+
i
)
{
*
indices
+
+
=
primIndices
[
i
]
+
currStartVertex
;
}
currStartVertex
+
=
rrect_type_to_vert_count
(
args
.
fType
)
;
}
GrMesh
mesh
;
mesh
.
initIndexed
(
kTriangles_GrPrimitiveType
vertexBuffer
indexBuffer
firstVertex
firstIndex
fVertCount
fIndexCount
)
;
target
-
>
draw
(
gp
.
get
(
)
mesh
)
;
}
bool
onCombineIfPossible
(
GrBatch
*
t
const
GrCaps
&
caps
)
override
{
RRectCircleRendererBatch
*
that
=
t
-
>
cast
<
RRectCircleRendererBatch
>
(
)
;
if
(
!
GrPipeline
:
:
CanCombine
(
*
this
-
>
pipeline
(
)
this
-
>
bounds
(
)
*
that
-
>
pipeline
(
)
that
-
>
bounds
(
)
caps
)
)
{
return
false
;
}
if
(
!
fViewMatrixIfUsingLocalCoords
.
cheapEqualTo
(
that
-
>
fViewMatrixIfUsingLocalCoords
)
)
{
return
false
;
}
fGeoData
.
push_back_n
(
that
-
>
fGeoData
.
count
(
)
that
-
>
fGeoData
.
begin
(
)
)
;
this
-
>
joinBounds
(
*
that
)
;
fVertCount
+
=
that
-
>
fVertCount
;
fIndexCount
+
=
that
-
>
fIndexCount
;
fAllFill
=
fAllFill
&
&
that
-
>
fAllFill
;
return
true
;
}
struct
Geometry
{
GrColor
fColor
;
SkScalar
fInnerRadius
;
SkScalar
fOuterRadius
;
SkRect
fDevBounds
;
RRectType
fType
;
}
;
SkSTArray
<
1
Geometry
true
>
fGeoData
;
SkMatrix
fViewMatrixIfUsingLocalCoords
;
int
fVertCount
;
int
fIndexCount
;
bool
fAllFill
;
typedef
GrVertexBatch
INHERITED
;
}
;
static
const
int
kNumRRectsInIndexBuffer
=
256
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gStrokeRRectOnlyIndexBufferKey
)
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gRRectOnlyIndexBufferKey
)
;
static
const
GrBuffer
*
ref_rrect_index_buffer
(
RRectType
type
GrResourceProvider
*
resourceProvider
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gStrokeRRectOnlyIndexBufferKey
)
;
GR_DEFINE_STATIC_UNIQUE_KEY
(
gRRectOnlyIndexBufferKey
)
;
switch
(
type
)
{
case
kFill_RRectType
:
return
resourceProvider
-
>
findOrCreateInstancedIndexBuffer
(
gStandardRRectIndices
kIndicesPerFillRRect
kNumRRectsInIndexBuffer
kVertsPerStandardRRect
gRRectOnlyIndexBufferKey
)
;
case
kStroke_RRectType
:
return
resourceProvider
-
>
findOrCreateInstancedIndexBuffer
(
gStandardRRectIndices
kIndicesPerStrokeRRect
kNumRRectsInIndexBuffer
kVertsPerStandardRRect
gStrokeRRectOnlyIndexBufferKey
)
;
default
:
SkASSERT
(
false
)
;
return
nullptr
;
}
;
}
class
RRectEllipseRendererBatch
:
public
GrVertexBatch
{
public
:
DEFINE_BATCH_CLASS_ID
static
GrDrawBatch
*
Create
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
devRect
float
devXRadius
float
devYRadius
SkVector
devStrokeWidths
bool
strokeOnly
)
{
SkASSERT
(
devXRadius
>
0
.
5
)
;
SkASSERT
(
devYRadius
>
0
.
5
)
;
SkASSERT
(
(
devStrokeWidths
.
fX
>
0
)
=
=
(
devStrokeWidths
.
fY
>
0
)
)
;
SkASSERT
(
!
(
strokeOnly
&
&
devStrokeWidths
.
fX
<
=
0
)
)
;
SkScalar
innerXRadius
=
0
.
0f
;
SkScalar
innerYRadius
=
0
.
0f
;
SkRect
bounds
=
devRect
;
bool
stroked
=
false
;
if
(
devStrokeWidths
.
fX
>
0
)
{
if
(
SkScalarNearlyZero
(
devStrokeWidths
.
length
(
)
)
)
{
devStrokeWidths
.
set
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
else
{
devStrokeWidths
.
scale
(
SK_ScalarHalf
)
;
}
if
(
devStrokeWidths
.
length
(
)
>
SK_ScalarHalf
&
&
(
SK_ScalarHalf
*
devXRadius
>
devYRadius
|
|
SK_ScalarHalf
*
devYRadius
>
devXRadius
)
)
{
return
nullptr
;
}
if
(
devStrokeWidths
.
fX
*
(
devYRadius
*
devYRadius
)
<
(
devStrokeWidths
.
fY
*
devStrokeWidths
.
fY
)
*
devXRadius
)
{
return
nullptr
;
}
if
(
devStrokeWidths
.
fY
*
(
devXRadius
*
devXRadius
)
<
(
devStrokeWidths
.
fX
*
devStrokeWidths
.
fX
)
*
devYRadius
)
{
return
nullptr
;
}
if
(
strokeOnly
)
{
innerXRadius
=
devXRadius
-
devStrokeWidths
.
fX
;
innerYRadius
=
devYRadius
-
devStrokeWidths
.
fY
;
stroked
=
(
innerXRadius
>
=
0
&
&
innerYRadius
>
=
0
)
;
}
devXRadius
+
=
devStrokeWidths
.
fX
;
devYRadius
+
=
devStrokeWidths
.
fY
;
bounds
.
outset
(
devStrokeWidths
.
fX
devStrokeWidths
.
fY
)
;
}
RRectEllipseRendererBatch
*
batch
=
new
RRectEllipseRendererBatch
(
)
;
batch
-
>
fStroked
=
stroked
;
batch
-
>
fViewMatrixIfUsingLocalCoords
=
viewMatrix
;
batch
-
>
setBounds
(
bounds
HasAABloat
:
:
kYes
IsZeroArea
:
:
kNo
)
;
bounds
.
outset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
batch
-
>
fGeoData
.
emplace_back
(
Geometry
{
color
devXRadius
devYRadius
innerXRadius
innerYRadius
bounds
}
)
;
return
batch
;
}
const
char
*
name
(
)
const
override
{
return
"
RRectEllipseRendererBatch
"
;
}
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
override
{
color
-
>
setKnownFourComponents
(
fGeoData
[
0
]
.
fColor
)
;
coverage
-
>
setUnknownSingleComponent
(
)
;
}
private
:
RRectEllipseRendererBatch
(
)
:
INHERITED
(
ClassID
(
)
)
{
}
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
overrides
)
override
{
overrides
.
getOverrideColorIfSet
(
&
fGeoData
[
0
]
.
fColor
)
;
if
(
!
overrides
.
readsLocalCoords
(
)
)
{
fViewMatrixIfUsingLocalCoords
.
reset
(
)
;
}
}
void
onPrepareDraws
(
Target
*
target
)
const
override
{
SkMatrix
localMatrix
;
if
(
!
fViewMatrixIfUsingLocalCoords
.
invert
(
&
localMatrix
)
)
{
return
;
}
SkAutoTUnref
<
GrGeometryProcessor
>
gp
(
new
EllipseGeometryProcessor
(
fStroked
localMatrix
)
)
;
int
instanceCount
=
fGeoData
.
count
(
)
;
size_t
vertexStride
=
gp
-
>
getVertexStride
(
)
;
SkASSERT
(
vertexStride
=
=
sizeof
(
EllipseVertex
)
)
;
int
indicesPerInstance
=
fStroked
?
kIndicesPerStrokeRRect
:
kIndicesPerFillRRect
;
SkAutoTUnref
<
const
GrBuffer
>
indexBuffer
(
ref_rrect_index_buffer
(
fStroked
?
kStroke_RRectType
:
kFill_RRectType
target
-
>
resourceProvider
(
)
)
)
;
InstancedHelper
helper
;
EllipseVertex
*
verts
=
reinterpret_cast
<
EllipseVertex
*
>
(
helper
.
init
(
target
kTriangles_GrPrimitiveType
vertexStride
indexBuffer
kVertsPerStandardRRect
indicesPerInstance
instanceCount
)
)
;
if
(
!
verts
|
|
!
indexBuffer
)
{
SkDebugf
(
"
Could
not
allocate
vertices
\
n
"
)
;
return
;
}
for
(
int
i
=
0
;
i
<
instanceCount
;
i
+
+
)
{
const
Geometry
&
args
=
fGeoData
[
i
]
;
GrColor
color
=
args
.
fColor
;
SkScalar
xRadRecip
=
SkScalarInvert
(
args
.
fXRadius
)
;
SkScalar
yRadRecip
=
SkScalarInvert
(
args
.
fYRadius
)
;
SkScalar
xInnerRadRecip
=
SkScalarInvert
(
args
.
fInnerXRadius
)
;
SkScalar
yInnerRadRecip
=
SkScalarInvert
(
args
.
fInnerYRadius
)
;
SkScalar
xOuterRadius
=
args
.
fXRadius
+
SK_ScalarHalf
;
SkScalar
yOuterRadius
=
args
.
fYRadius
+
SK_ScalarHalf
;
const
SkRect
&
bounds
=
args
.
fDevBounds
;
SkScalar
yCoords
[
4
]
=
{
bounds
.
fTop
bounds
.
fTop
+
yOuterRadius
bounds
.
fBottom
-
yOuterRadius
bounds
.
fBottom
}
;
SkScalar
yOuterOffsets
[
4
]
=
{
yOuterRadius
SK_ScalarNearlyZero
SK_ScalarNearlyZero
yOuterRadius
}
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
xOuterRadius
yOuterOffsets
[
i
]
)
;
verts
-
>
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
-
>
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fLeft
+
xOuterRadius
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
SK_ScalarNearlyZero
yOuterOffsets
[
i
]
)
;
verts
-
>
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
-
>
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
-
xOuterRadius
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
SK_ScalarNearlyZero
yOuterOffsets
[
i
]
)
;
verts
-
>
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
-
>
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
+
+
;
verts
-
>
fPos
=
SkPoint
:
:
Make
(
bounds
.
fRight
yCoords
[
i
]
)
;
verts
-
>
fColor
=
color
;
verts
-
>
fOffset
=
SkPoint
:
:
Make
(
xOuterRadius
yOuterOffsets
[
i
]
)
;
verts
-
>
fOuterRadii
=
SkPoint
:
:
Make
(
xRadRecip
yRadRecip
)
;
verts
-
>
fInnerRadii
=
SkPoint
:
:
Make
(
xInnerRadRecip
yInnerRadRecip
)
;
verts
+
+
;
}
}
helper
.
recordDraw
(
target
gp
)
;
}
bool
onCombineIfPossible
(
GrBatch
*
t
const
GrCaps
&
caps
)
override
{
RRectEllipseRendererBatch
*
that
=
t
-
>
cast
<
RRectEllipseRendererBatch
>
(
)
;
if
(
!
GrPipeline
:
:
CanCombine
(
*
this
-
>
pipeline
(
)
this
-
>
bounds
(
)
*
that
-
>
pipeline
(
)
that
-
>
bounds
(
)
caps
)
)
{
return
false
;
}
if
(
fStroked
!
=
that
-
>
fStroked
)
{
return
false
;
}
if
(
!
fViewMatrixIfUsingLocalCoords
.
cheapEqualTo
(
that
-
>
fViewMatrixIfUsingLocalCoords
)
)
{
return
false
;
}
fGeoData
.
push_back_n
(
that
-
>
fGeoData
.
count
(
)
that
-
>
fGeoData
.
begin
(
)
)
;
this
-
>
joinBounds
(
*
that
)
;
return
true
;
}
struct
Geometry
{
GrColor
fColor
;
SkScalar
fXRadius
;
SkScalar
fYRadius
;
SkScalar
fInnerXRadius
;
SkScalar
fInnerYRadius
;
SkRect
fDevBounds
;
}
;
bool
fStroked
;
SkMatrix
fViewMatrixIfUsingLocalCoords
;
SkSTArray
<
1
Geometry
true
>
fGeoData
;
typedef
GrVertexBatch
INHERITED
;
}
;
static
GrDrawBatch
*
create_rrect_batch
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
SkStrokeRec
&
stroke
)
{
SkASSERT
(
viewMatrix
.
rectStaysRect
(
)
)
;
SkASSERT
(
rrect
.
isSimple
(
)
)
;
SkASSERT
(
!
rrect
.
isOval
(
)
)
;
const
SkRect
&
rrectBounds
=
rrect
.
getBounds
(
)
;
SkRect
bounds
;
viewMatrix
.
mapRect
(
&
bounds
rrectBounds
)
;
SkVector
radii
=
rrect
.
getSimpleRadii
(
)
;
SkScalar
xRadius
=
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
*
radii
.
fX
+
viewMatrix
[
SkMatrix
:
:
kMSkewY
]
*
radii
.
fY
)
;
SkScalar
yRadius
=
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
*
radii
.
fX
+
viewMatrix
[
SkMatrix
:
:
kMScaleY
]
*
radii
.
fY
)
;
SkStrokeRec
:
:
Style
style
=
stroke
.
getStyle
(
)
;
SkVector
scaledStroke
=
{
-
1
-
1
}
;
SkScalar
strokeWidth
=
stroke
.
getWidth
(
)
;
bool
isStrokeOnly
=
SkStrokeRec
:
:
kStroke_Style
=
=
style
|
|
SkStrokeRec
:
:
kHairline_Style
=
=
style
;
bool
hasStroke
=
isStrokeOnly
|
|
SkStrokeRec
:
:
kStrokeAndFill_Style
=
=
style
;
bool
isCircular
=
(
xRadius
=
=
yRadius
)
;
if
(
hasStroke
)
{
if
(
SkStrokeRec
:
:
kHairline_Style
=
=
style
)
{
scaledStroke
.
set
(
1
1
)
;
}
else
{
scaledStroke
.
fX
=
SkScalarAbs
(
strokeWidth
*
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
+
viewMatrix
[
SkMatrix
:
:
kMSkewY
]
)
)
;
scaledStroke
.
fY
=
SkScalarAbs
(
strokeWidth
*
(
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
+
viewMatrix
[
SkMatrix
:
:
kMScaleY
]
)
)
;
}
isCircular
=
isCircular
&
&
scaledStroke
.
fX
=
=
scaledStroke
.
fY
;
if
(
!
isCircular
&
&
(
SK_ScalarHalf
*
scaledStroke
.
fX
>
xRadius
|
|
SK_ScalarHalf
*
scaledStroke
.
fY
>
yRadius
)
)
{
return
nullptr
;
}
}
if
(
!
isStrokeOnly
&
&
(
SK_ScalarHalf
>
xRadius
|
|
SK_ScalarHalf
>
yRadius
)
)
{
return
nullptr
;
}
if
(
isCircular
)
{
return
new
RRectCircleRendererBatch
(
color
viewMatrix
bounds
xRadius
scaledStroke
.
fX
isStrokeOnly
)
;
}
else
{
return
RRectEllipseRendererBatch
:
:
Create
(
color
viewMatrix
bounds
xRadius
yRadius
scaledStroke
isStrokeOnly
)
;
}
}
GrDrawBatch
*
GrOvalRenderer
:
:
CreateRRectBatch
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
SkStrokeRec
&
stroke
const
GrShaderCaps
*
shaderCaps
)
{
if
(
rrect
.
isOval
(
)
)
{
return
CreateOvalBatch
(
color
viewMatrix
rrect
.
getBounds
(
)
stroke
shaderCaps
)
;
}
if
(
!
viewMatrix
.
rectStaysRect
(
)
|
|
!
rrect
.
isSimple
(
)
)
{
return
nullptr
;
}
return
create_rrect_batch
(
color
viewMatrix
rrect
stroke
)
;
}
GrDrawBatch
*
GrOvalRenderer
:
:
CreateOvalBatch
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
SkStrokeRec
&
stroke
const
GrShaderCaps
*
shaderCaps
)
{
SkScalar
width
=
oval
.
width
(
)
;
if
(
SkScalarNearlyEqual
(
width
oval
.
height
(
)
)
&
&
circle_stays_circle
(
viewMatrix
)
)
{
SkPoint
center
=
{
oval
.
centerX
(
)
oval
.
centerY
(
)
}
;
return
CircleBatch
:
:
Create
(
color
viewMatrix
center
width
/
2
.
f
GrStyle
(
stroke
nullptr
)
)
;
}
if
(
shaderCaps
-
>
shaderDerivativeSupport
(
)
)
{
return
DIEllipseBatch
:
:
Create
(
color
viewMatrix
oval
stroke
)
;
}
if
(
viewMatrix
.
rectStaysRect
(
)
)
{
return
EllipseBatch
:
:
Create
(
color
viewMatrix
oval
stroke
)
;
}
return
nullptr
;
}
GrDrawBatch
*
GrOvalRenderer
:
:
CreateArcBatch
(
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
const
GrShaderCaps
*
shaderCaps
)
{
SkASSERT
(
!
oval
.
isEmpty
(
)
)
;
SkASSERT
(
sweepAngle
)
;
SkScalar
width
=
oval
.
width
(
)
;
if
(
SkScalarAbs
(
sweepAngle
)
>
=
360
.
f
)
{
return
nullptr
;
}
if
(
!
SkScalarNearlyEqual
(
width
oval
.
height
(
)
)
|
|
!
circle_stays_circle
(
viewMatrix
)
)
{
return
nullptr
;
}
SkPoint
center
=
{
oval
.
centerX
(
)
oval
.
centerY
(
)
}
;
CircleBatch
:
:
ArcParams
arcParams
=
{
SkDegreesToRadians
(
startAngle
)
SkDegreesToRadians
(
sweepAngle
)
useCenter
}
;
return
CircleBatch
:
:
Create
(
color
viewMatrix
center
width
/
2
.
f
style
&
arcParams
)
;
}
#
ifdef
GR_TEST_UTILS
DRAW_BATCH_TEST_DEFINE
(
CircleBatch
)
{
do
{
SkScalar
rotate
=
random
-
>
nextSScalar1
(
)
*
360
.
f
;
SkScalar
translateX
=
random
-
>
nextSScalar1
(
)
*
1000
.
f
;
SkScalar
translateY
=
random
-
>
nextSScalar1
(
)
*
1000
.
f
;
SkScalar
scale
=
random
-
>
nextSScalar1
(
)
*
100
.
f
;
SkMatrix
viewMatrix
;
viewMatrix
.
setRotate
(
rotate
)
;
viewMatrix
.
postTranslate
(
translateX
translateY
)
;
viewMatrix
.
postScale
(
scale
scale
)
;
GrColor
color
=
GrRandomColor
(
random
)
;
SkRect
circle
=
GrTest
:
:
TestSquare
(
random
)
;
SkPoint
center
=
{
circle
.
centerX
(
)
circle
.
centerY
(
)
}
;
SkScalar
radius
=
circle
.
width
(
)
/
2
.
f
;
SkStrokeRec
stroke
=
GrTest
:
:
TestStrokeRec
(
random
)
;
CircleBatch
:
:
ArcParams
arcParamsTmp
;
const
CircleBatch
:
:
ArcParams
*
arcParams
=
nullptr
;
if
(
random
-
>
nextBool
(
)
)
{
arcParamsTmp
.
fStartAngleRadians
=
random
-
>
nextSScalar1
(
)
*
SK_ScalarPI
*
2
;
arcParamsTmp
.
fSweepAngleRadians
=
random
-
>
nextSScalar1
(
)
*
SK_ScalarPI
*
2
-
.
01f
;
arcParamsTmp
.
fUseCenter
=
random
-
>
nextBool
(
)
;
arcParams
=
&
arcParamsTmp
;
}
GrDrawBatch
*
batch
=
CircleBatch
:
:
Create
(
color
viewMatrix
center
radius
GrStyle
(
stroke
nullptr
)
arcParams
)
;
if
(
batch
)
{
return
batch
;
}
}
while
(
true
)
;
}
DRAW_BATCH_TEST_DEFINE
(
EllipseBatch
)
{
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrixRectStaysRect
(
random
)
;
GrColor
color
=
GrRandomColor
(
random
)
;
SkRect
ellipse
=
GrTest
:
:
TestSquare
(
random
)
;
return
EllipseBatch
:
:
Create
(
color
viewMatrix
ellipse
GrTest
:
:
TestStrokeRec
(
random
)
)
;
}
DRAW_BATCH_TEST_DEFINE
(
DIEllipseBatch
)
{
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrix
(
random
)
;
GrColor
color
=
GrRandomColor
(
random
)
;
SkRect
ellipse
=
GrTest
:
:
TestSquare
(
random
)
;
return
DIEllipseBatch
:
:
Create
(
color
viewMatrix
ellipse
GrTest
:
:
TestStrokeRec
(
random
)
)
;
}
DRAW_BATCH_TEST_DEFINE
(
RRectBatch
)
{
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrixRectStaysRect
(
random
)
;
GrColor
color
=
GrRandomColor
(
random
)
;
const
SkRRect
&
rrect
=
GrTest
:
:
TestRRectSimple
(
random
)
;
return
create_rrect_batch
(
color
viewMatrix
rrect
GrTest
:
:
TestStrokeRec
(
random
)
)
;
}
#
endif
