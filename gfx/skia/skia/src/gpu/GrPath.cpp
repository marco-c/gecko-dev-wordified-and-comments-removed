#
include
"
GrPath
.
h
"
namespace
{
static
const
int
kSimpleVolatilePathVerbLimit
=
10
;
inline
static
bool
compute_key_for_line_path
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
GrUniqueKey
*
key
)
{
SkPoint
pts
[
2
]
;
if
(
!
path
.
isLine
(
pts
)
)
{
return
false
;
}
static_assert
(
(
sizeof
(
pts
)
%
sizeof
(
uint32_t
)
)
=
=
0
&
&
sizeof
(
pts
)
>
sizeof
(
uint32_t
)
"
pts_needs_padding
"
)
;
const
int
kBaseData32Cnt
=
1
+
sizeof
(
pts
)
/
sizeof
(
uint32_t
)
;
int
strokeDataCnt
=
stroke
.
computeUniqueKeyFragmentData32Cnt
(
)
;
static
const
GrUniqueKey
:
:
Domain
kOvalPathDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kOvalPathDomain
kBaseData32Cnt
+
strokeDataCnt
)
;
builder
[
0
]
=
path
.
getFillType
(
)
;
memcpy
(
&
builder
[
1
]
&
pts
sizeof
(
pts
)
)
;
if
(
strokeDataCnt
>
0
)
{
stroke
.
asUniqueKeyFragment
(
&
builder
[
kBaseData32Cnt
]
)
;
}
return
true
;
}
inline
static
bool
compute_key_for_oval_path
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
GrUniqueKey
*
key
)
{
SkRect
rect
;
if
(
stroke
.
isDashed
(
)
|
|
!
path
.
isOval
(
&
rect
)
)
{
return
false
;
}
static_assert
(
(
sizeof
(
rect
)
%
sizeof
(
uint32_t
)
)
=
=
0
&
&
sizeof
(
rect
)
>
sizeof
(
uint32_t
)
"
rect_needs_padding
"
)
;
const
int
kBaseData32Cnt
=
1
+
sizeof
(
rect
)
/
sizeof
(
uint32_t
)
;
int
strokeDataCnt
=
stroke
.
computeUniqueKeyFragmentData32Cnt
(
)
;
static
const
GrUniqueKey
:
:
Domain
kOvalPathDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kOvalPathDomain
kBaseData32Cnt
+
strokeDataCnt
)
;
builder
[
0
]
=
path
.
getFillType
(
)
;
memcpy
(
&
builder
[
1
]
&
rect
sizeof
(
rect
)
)
;
if
(
strokeDataCnt
>
0
)
{
stroke
.
asUniqueKeyFragment
(
&
builder
[
kBaseData32Cnt
]
)
;
}
return
true
;
}
inline
static
bool
compute_key_for_simple_path
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
GrUniqueKey
*
key
)
{
if
(
!
path
.
isVolatile
(
)
)
{
return
false
;
}
const
int
verbCnt
=
path
.
countVerbs
(
)
;
if
(
verbCnt
>
kSimpleVolatilePathVerbLimit
)
{
return
false
;
}
static_assert
(
kSimpleVolatilePathVerbLimit
<
=
100
"
big_simple_volatile_path_verb_limit_may_cause_overflow
"
)
;
const
int
pointCnt
=
path
.
countPoints
(
)
;
if
(
pointCnt
<
0
)
{
SkASSERT
(
false
)
;
return
false
;
}
SkSTArray
<
16
SkScalar
true
>
conicWeights
(
16
)
;
if
(
(
path
.
getSegmentMasks
(
)
&
SkPath
:
:
kConic_SegmentMask
)
!
=
0
)
{
SkPath
:
:
RawIter
iter
(
path
)
;
SkPath
:
:
Verb
verb
;
SkPoint
points
[
4
]
;
while
(
(
verb
=
iter
.
next
(
points
)
)
!
=
SkPath
:
:
kDone_Verb
)
{
if
(
verb
=
=
SkPath
:
:
kConic_Verb
)
{
conicWeights
.
push_back
(
iter
.
conicWeight
(
)
)
;
}
}
}
const
int
conicWeightCnt
=
conicWeights
.
count
(
)
;
#
define
ARRAY_DATA32_COUNT
(
array_type
count
)
\
static_cast
<
int
>
(
(
(
(
count
)
*
sizeof
(
array_type
)
+
sizeof
(
uint32_t
)
-
1
)
/
sizeof
(
uint32_t
)
)
)
const
int
verbData32Cnt
=
ARRAY_DATA32_COUNT
(
uint8_t
verbCnt
)
;
const
int
pointData32Cnt
=
ARRAY_DATA32_COUNT
(
SkPoint
pointCnt
)
;
const
int
conicWeightData32Cnt
=
ARRAY_DATA32_COUNT
(
SkScalar
conicWeightCnt
)
;
#
undef
ARRAY_DATA32_COUNT
const
int
baseData32Cnt
=
2
+
verbData32Cnt
+
pointData32Cnt
+
conicWeightData32Cnt
;
const
int
strokeDataCnt
=
stroke
.
computeUniqueKeyFragmentData32Cnt
(
)
;
static
const
GrUniqueKey
:
:
Domain
kSimpleVolatilePathDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kSimpleVolatilePathDomain
baseData32Cnt
+
strokeDataCnt
)
;
int
i
=
0
;
builder
[
i
+
+
]
=
path
.
getFillType
(
)
;
builder
[
i
+
+
]
=
SkToU32
(
verbCnt
)
;
if
(
verbData32Cnt
!
=
static_cast
<
int
>
(
(
verbCnt
*
sizeof
(
uint8_t
)
/
sizeof
(
uint32_t
)
)
)
)
{
builder
[
i
+
verbData32Cnt
-
1
]
=
0
;
}
path
.
getVerbs
(
reinterpret_cast
<
uint8_t
*
>
(
&
builder
[
i
]
)
verbCnt
)
;
i
+
=
verbData32Cnt
;
static_assert
(
(
(
sizeof
(
SkPoint
)
%
sizeof
(
uint32_t
)
)
=
=
0
)
&
&
sizeof
(
SkPoint
)
>
sizeof
(
uint32_t
)
"
skpoint_array_needs_padding
"
)
;
path
.
getPoints
(
reinterpret_cast
<
SkPoint
*
>
(
&
builder
[
i
]
)
pointCnt
)
;
i
+
=
pointData32Cnt
;
if
(
conicWeightCnt
>
0
)
{
if
(
conicWeightData32Cnt
!
=
static_cast
<
int
>
(
(
conicWeightCnt
*
sizeof
(
SkScalar
)
/
sizeof
(
uint32_t
)
)
)
)
{
builder
[
i
+
conicWeightData32Cnt
-
1
]
=
0
;
}
memcpy
(
&
builder
[
i
]
conicWeights
.
begin
(
)
conicWeightCnt
*
sizeof
(
SkScalar
)
)
;
SkDEBUGCODE
(
i
+
=
conicWeightData32Cnt
)
;
}
SkASSERT
(
i
=
=
baseData32Cnt
)
;
if
(
strokeDataCnt
>
0
)
{
stroke
.
asUniqueKeyFragment
(
&
builder
[
baseData32Cnt
]
)
;
}
return
true
;
}
inline
static
void
compute_key_for_general_path
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
GrUniqueKey
*
key
)
{
const
int
kBaseData32Cnt
=
2
;
int
strokeDataCnt
=
stroke
.
computeUniqueKeyFragmentData32Cnt
(
)
;
static
const
GrUniqueKey
:
:
Domain
kGeneralPathDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kGeneralPathDomain
kBaseData32Cnt
+
strokeDataCnt
)
;
builder
[
0
]
=
path
.
getGenerationID
(
)
;
builder
[
1
]
=
path
.
getFillType
(
)
;
if
(
strokeDataCnt
>
0
)
{
stroke
.
asUniqueKeyFragment
(
&
builder
[
kBaseData32Cnt
]
)
;
}
}
}
void
GrPath
:
:
ComputeKey
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
GrUniqueKey
*
key
bool
*
outIsVolatile
)
{
if
(
compute_key_for_line_path
(
path
stroke
key
)
)
{
*
outIsVolatile
=
false
;
return
;
}
if
(
compute_key_for_oval_path
(
path
stroke
key
)
)
{
*
outIsVolatile
=
false
;
return
;
}
if
(
compute_key_for_simple_path
(
path
stroke
key
)
)
{
*
outIsVolatile
=
false
;
return
;
}
compute_key_for_general_path
(
path
stroke
key
)
;
*
outIsVolatile
=
path
.
isVolatile
(
)
;
}
#
ifdef
SK_DEBUG
bool
GrPath
:
:
isEqualTo
(
const
SkPath
&
path
const
GrStrokeInfo
&
stroke
)
const
{
if
(
!
fStroke
.
hasEqualEffect
(
stroke
)
)
{
return
false
;
}
SkRect
ovalBounds
;
if
(
!
fStroke
.
isDashed
(
)
&
&
fSkPath
.
isOval
(
&
ovalBounds
)
)
{
SkRect
otherOvalBounds
;
return
path
.
isOval
(
&
otherOvalBounds
)
&
&
ovalBounds
=
=
otherOvalBounds
;
}
return
fSkPath
=
=
path
;
}
#
endif
