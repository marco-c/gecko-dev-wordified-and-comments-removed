#
ifndef
GrPathRendering_DEFINED
#
define
GrPathRendering_DEFINED
#
include
"
SkPath
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrPathRange
.
h
"
#
include
"
GrPipeline
.
h
"
class
SkDescriptor
;
class
SkTypeface
;
class
GrPath
;
class
GrStencilSettings
;
class
GrStrokeInfo
;
class
GrPathRendering
{
public
:
virtual
~
GrPathRendering
(
)
{
}
typedef
GrPathRange
:
:
PathIndexType
PathIndexType
;
enum
PathTransformType
{
kNone_PathTransformType
kTranslateX_PathTransformType
kTranslateY_PathTransformType
kTranslate_PathTransformType
kAffine_PathTransformType
kLast_PathTransformType
=
kAffine_PathTransformType
}
;
static
inline
int
PathTransformSize
(
PathTransformType
type
)
{
switch
(
type
)
{
case
kNone_PathTransformType
:
return
0
;
case
kTranslateX_PathTransformType
:
case
kTranslateY_PathTransformType
:
return
1
;
case
kTranslate_PathTransformType
:
return
2
;
case
kAffine_PathTransformType
:
return
6
;
default
:
SkFAIL
(
"
Unknown
path
transform
type
"
)
;
return
0
;
}
}
enum
FillType
{
kWinding_FillType
kEvenOdd_FillType
}
;
virtual
GrPath
*
createPath
(
const
SkPath
&
const
GrStrokeInfo
&
)
=
0
;
virtual
GrPathRange
*
createPathRange
(
GrPathRange
:
:
PathGenerator
*
const
GrStrokeInfo
&
)
=
0
;
GrPathRange
*
createGlyphs
(
const
SkTypeface
*
const
SkDescriptor
*
const
GrStrokeInfo
&
)
;
struct
StencilPathArgs
{
StencilPathArgs
(
bool
useHWAA
GrRenderTarget
*
renderTarget
const
SkMatrix
*
viewMatrix
const
GrScissorState
*
scissor
const
GrStencilSettings
*
stencil
)
:
fUseHWAA
(
useHWAA
)
fRenderTarget
(
renderTarget
)
fViewMatrix
(
viewMatrix
)
fScissor
(
scissor
)
fStencil
(
stencil
)
{
}
bool
fUseHWAA
;
GrRenderTarget
*
fRenderTarget
;
const
SkMatrix
*
fViewMatrix
;
const
GrScissorState
*
fScissor
;
const
GrStencilSettings
*
fStencil
;
}
;
void
stencilPath
(
const
StencilPathArgs
&
args
const
GrPath
*
path
)
{
fGpu
-
>
handleDirtyContext
(
)
;
this
-
>
onStencilPath
(
args
path
)
;
}
void
drawPath
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
const
GrStencilSettings
&
stencil
const
GrPath
*
path
)
{
fGpu
-
>
handleDirtyContext
(
)
;
if
(
GrXferBarrierType
barrierType
=
pipeline
.
xferBarrierType
(
*
fGpu
-
>
caps
(
)
)
)
{
fGpu
-
>
xferBarrier
(
pipeline
.
getRenderTarget
(
)
barrierType
)
;
}
this
-
>
onDrawPath
(
pipeline
primProc
stencil
path
)
;
}
void
drawPaths
(
const
GrPipeline
&
pipeline
const
GrPrimitiveProcessor
&
primProc
const
GrStencilSettings
&
stencil
const
GrPathRange
*
pathRange
const
void
*
indices
PathIndexType
indexType
const
float
transformValues
[
]
PathTransformType
transformType
int
count
)
{
fGpu
-
>
handleDirtyContext
(
)
;
if
(
GrXferBarrierType
barrierType
=
pipeline
.
xferBarrierType
(
*
fGpu
-
>
caps
(
)
)
)
{
fGpu
-
>
xferBarrier
(
pipeline
.
getRenderTarget
(
)
barrierType
)
;
}
#
ifdef
SK_DEBUG
pathRange
-
>
assertPathsLoaded
(
indices
indexType
count
)
;
#
endif
this
-
>
onDrawPaths
(
pipeline
primProc
stencil
pathRange
indices
indexType
transformValues
transformType
count
)
;
}
protected
:
GrPathRendering
(
GrGpu
*
gpu
)
:
fGpu
(
gpu
)
{
}
virtual
void
onStencilPath
(
const
StencilPathArgs
&
const
GrPath
*
)
=
0
;
virtual
void
onDrawPath
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
const
GrStencilSettings
&
const
GrPath
*
)
=
0
;
virtual
void
onDrawPaths
(
const
GrPipeline
&
const
GrPrimitiveProcessor
&
const
GrStencilSettings
&
const
GrPathRange
*
const
void
*
indices
PathIndexType
const
float
transformValues
[
]
PathTransformType
int
count
)
=
0
;
GrGpu
*
fGpu
;
private
:
GrPathRendering
&
operator
=
(
const
GrPathRendering
&
)
;
}
;
#
endif
