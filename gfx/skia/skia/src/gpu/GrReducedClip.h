#
ifndef
GrReducedClip_DEFINED
#
define
GrReducedClip_DEFINED
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrWindowRectangles
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkTLList
.
h
"
class
GrCoverageCountingPathRenderer
;
class
GrRecordingContext
;
class
GrRenderTargetContext
;
class
SK_API
GrReducedClip
{
public
:
using
Element
=
SkClipStack
:
:
Element
;
using
ElementList
=
SkTLList
<
SkClipStack
:
:
Element
16
>
;
GrReducedClip
(
const
SkClipStack
&
const
SkRect
&
queryBounds
const
GrCaps
*
caps
int
maxWindowRectangles
=
0
int
maxAnalyticFPs
=
0
int
maxCCPRClipPaths
=
0
)
;
enum
class
InitialState
:
bool
{
kAllIn
kAllOut
}
;
InitialState
initialState
(
)
const
{
return
fInitialState
;
}
const
SkIRect
&
scissor
(
)
const
{
SkASSERT
(
fHasScissor
)
;
return
fScissor
;
}
int
left
(
)
const
{
return
this
-
>
scissor
(
)
.
left
(
)
;
}
int
top
(
)
const
{
return
this
-
>
scissor
(
)
.
top
(
)
;
}
int
width
(
)
const
{
return
this
-
>
scissor
(
)
.
width
(
)
;
}
int
height
(
)
const
{
return
this
-
>
scissor
(
)
.
height
(
)
;
}
bool
hasScissor
(
)
const
{
return
fHasScissor
;
}
const
GrWindowRectangles
&
windowRectangles
(
)
const
{
return
fWindowRects
;
}
const
ElementList
&
maskElements
(
)
const
{
return
fMaskElements
;
}
uint32_t
maskGenID
(
)
const
{
SkASSERT
(
!
fMaskElements
.
isEmpty
(
)
)
;
return
fMaskGenID
;
}
bool
maskRequiresAA
(
)
const
{
SkASSERT
(
!
fMaskElements
.
isEmpty
(
)
)
;
return
fMaskRequiresAA
;
}
bool
drawAlphaClipMask
(
GrRenderTargetContext
*
)
const
;
bool
drawStencilClipMask
(
GrRecordingContext
*
GrRenderTargetContext
*
)
const
;
int
numAnalyticFPs
(
)
const
{
return
fAnalyticFPs
.
count
(
)
+
fCCPRClipPaths
.
count
(
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
finishAndDetachAnalyticFPs
(
GrCoverageCountingPathRenderer
*
uint32_t
opListID
int
rtWidth
int
rtHeight
)
;
private
:
void
walkStack
(
const
SkClipStack
&
const
SkRect
&
queryBounds
)
;
enum
class
ClipResult
{
kNotClipped
kClipped
kMadeEmpty
}
;
ClipResult
clipInsideElement
(
const
Element
*
)
;
ClipResult
clipOutsideElement
(
const
Element
*
)
;
void
addWindowRectangle
(
const
SkRect
&
elementInteriorRect
bool
elementIsAA
)
;
enum
class
Invert
:
bool
{
kNo
=
false
kYes
=
true
}
;
static
GrClipEdgeType
GetClipEdgeType
(
Invert
GrAA
)
;
ClipResult
addAnalyticFP
(
const
SkRect
&
deviceSpaceRect
Invert
GrAA
)
;
ClipResult
addAnalyticFP
(
const
SkRRect
&
deviceSpaceRRect
Invert
GrAA
)
;
ClipResult
addAnalyticFP
(
const
SkPath
&
deviceSpacePath
Invert
GrAA
)
;
void
makeEmpty
(
)
;
const
GrCaps
*
fCaps
;
const
int
fMaxWindowRectangles
;
const
int
fMaxAnalyticFPs
;
const
int
fMaxCCPRClipPaths
;
InitialState
fInitialState
;
SkIRect
fScissor
;
bool
fHasScissor
;
SkRect
fAAClipRect
;
uint32_t
fAAClipRectGenID
;
GrWindowRectangles
fWindowRects
;
ElementList
fMaskElements
;
uint32_t
fMaskGenID
;
bool
fMaskRequiresAA
;
SkSTArray
<
4
std
:
:
unique_ptr
<
GrFragmentProcessor
>
>
fAnalyticFPs
;
SkSTArray
<
4
SkPath
>
fCCPRClipPaths
;
}
;
#
endif
