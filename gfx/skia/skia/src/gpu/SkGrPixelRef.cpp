#
include
"
SkGrPixelRef
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
SkBitmapCache
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkRect
.
h
"
SkROLockPixelsPixelRef
:
:
SkROLockPixelsPixelRef
(
const
SkImageInfo
&
info
)
:
INHERITED
(
info
)
{
}
SkROLockPixelsPixelRef
:
:
~
SkROLockPixelsPixelRef
(
)
{
}
bool
SkROLockPixelsPixelRef
:
:
onNewLockPixels
(
LockRec
*
rec
)
{
fBitmap
.
reset
(
)
;
if
(
!
this
-
>
onReadPixels
(
&
fBitmap
nullptr
)
)
{
SkDebugf
(
"
SkROLockPixelsPixelRef
:
:
onLockPixels
failed
!
\
n
"
)
;
return
false
;
}
fBitmap
.
lockPixels
(
)
;
if
(
nullptr
=
=
fBitmap
.
getPixels
(
)
)
{
return
false
;
}
rec
-
>
fPixels
=
fBitmap
.
getPixels
(
)
;
rec
-
>
fColorTable
=
nullptr
;
rec
-
>
fRowBytes
=
fBitmap
.
rowBytes
(
)
;
return
true
;
}
void
SkROLockPixelsPixelRef
:
:
onUnlockPixels
(
)
{
fBitmap
.
unlockPixels
(
)
;
}
bool
SkROLockPixelsPixelRef
:
:
onLockPixelsAreWritable
(
)
const
{
return
false
;
}
static
SkGrPixelRef
*
copy_to_new_texture_pixelref
(
GrTexture
*
texture
SkColorType
dstCT
SkColorProfileType
dstPT
const
SkIRect
*
subset
)
{
if
(
nullptr
=
=
texture
|
|
kUnknown_SkColorType
=
=
dstCT
)
{
return
nullptr
;
}
GrContext
*
context
=
texture
-
>
getContext
(
)
;
if
(
nullptr
=
=
context
)
{
return
nullptr
;
}
GrSurfaceDesc
desc
;
SkIRect
srcRect
;
if
(
!
subset
)
{
desc
.
fWidth
=
texture
-
>
width
(
)
;
desc
.
fHeight
=
texture
-
>
height
(
)
;
srcRect
=
SkIRect
:
:
MakeWH
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
;
}
else
{
SkASSERT
(
SkIRect
:
:
MakeWH
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
.
contains
(
*
subset
)
)
;
desc
.
fWidth
=
subset
-
>
width
(
)
;
desc
.
fHeight
=
subset
-
>
height
(
)
;
srcRect
=
*
subset
;
}
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fConfig
=
SkImageInfo2GrPixelConfig
(
dstCT
kPremul_SkAlphaType
dstPT
)
;
GrTexture
*
dst
=
context
-
>
textureProvider
(
)
-
>
createTexture
(
desc
false
nullptr
0
)
;
if
(
nullptr
=
=
dst
)
{
return
nullptr
;
}
context
-
>
copySurface
(
dst
-
>
asRenderTarget
(
)
texture
srcRect
SkIPoint
:
:
Make
(
0
0
)
GrContext
:
:
kFlushWrites_PixelOp
)
;
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
desc
.
fWidth
desc
.
fHeight
dstCT
kPremul_SkAlphaType
dstPT
)
;
SkGrPixelRef
*
pixelRef
=
new
SkGrPixelRef
(
info
dst
)
;
SkSafeUnref
(
dst
)
;
return
pixelRef
;
}
SkGrPixelRef
:
:
SkGrPixelRef
(
const
SkImageInfo
&
info
GrSurface
*
surface
)
:
INHERITED
(
info
)
{
fSurface
=
SkSafeRef
(
surface
-
>
asTexture
(
)
)
;
if
(
nullptr
=
=
fSurface
)
{
fSurface
=
SkSafeRef
(
surface
)
;
}
if
(
fSurface
)
{
SkASSERT
(
info
.
width
(
)
<
=
fSurface
-
>
width
(
)
)
;
SkASSERT
(
info
.
height
(
)
<
=
fSurface
-
>
height
(
)
)
;
}
}
SkGrPixelRef
:
:
~
SkGrPixelRef
(
)
{
SkSafeUnref
(
fSurface
)
;
}
GrTexture
*
SkGrPixelRef
:
:
getTexture
(
)
{
if
(
fSurface
)
{
return
fSurface
-
>
asTexture
(
)
;
}
return
nullptr
;
}
void
SkGrPixelRef
:
:
onNotifyPixelsChanged
(
)
{
GrTexture
*
texture
=
this
-
>
getTexture
(
)
;
if
(
texture
)
{
texture
-
>
texturePriv
(
)
.
dirtyMipMaps
(
true
)
;
}
}
SkPixelRef
*
SkGrPixelRef
:
:
deepCopy
(
SkColorType
dstCT
SkColorProfileType
dstPT
const
SkIRect
*
subset
)
{
if
(
nullptr
=
=
fSurface
)
{
return
nullptr
;
}
return
copy_to_new_texture_pixelref
(
fSurface
-
>
asTexture
(
)
dstCT
dstPT
subset
)
;
}
static
bool
tryAllocBitmapPixels
(
SkBitmap
*
bitmap
)
{
SkBitmap
:
:
Allocator
*
allocator
=
SkBitmapCache
:
:
GetAllocator
(
)
;
if
(
nullptr
!
=
allocator
)
{
return
allocator
-
>
allocPixelRef
(
bitmap
0
)
;
}
else
{
return
bitmap
-
>
tryAllocPixels
(
)
;
}
}
bool
SkGrPixelRef
:
:
onReadPixels
(
SkBitmap
*
dst
const
SkIRect
*
subset
)
{
if
(
nullptr
=
=
fSurface
|
|
fSurface
-
>
wasDestroyed
(
)
)
{
return
false
;
}
SkIRect
bounds
;
if
(
subset
)
{
bounds
=
*
subset
;
}
else
{
bounds
=
SkIRect
:
:
MakeWH
(
this
-
>
info
(
)
.
width
(
)
this
-
>
info
(
)
.
height
(
)
)
;
}
if
(
!
SkBitmapCache
:
:
Find
(
this
-
>
getGenerationID
(
)
bounds
dst
)
)
{
SkBitmap
cachedBitmap
;
cachedBitmap
.
setInfo
(
this
-
>
info
(
)
.
makeWH
(
bounds
.
width
(
)
bounds
.
height
(
)
)
)
;
if
(
!
tryAllocBitmapPixels
(
&
cachedBitmap
)
)
{
return
false
;
}
void
*
buffer
=
cachedBitmap
.
getPixels
(
)
;
bool
readPixelsOk
=
fSurface
-
>
readPixels
(
bounds
.
fLeft
bounds
.
fTop
bounds
.
width
(
)
bounds
.
height
(
)
kSkia8888_GrPixelConfig
buffer
cachedBitmap
.
rowBytes
(
)
)
;
if
(
!
readPixelsOk
)
{
return
false
;
}
cachedBitmap
.
setImmutable
(
)
;
SkBitmapCache
:
:
Add
(
this
bounds
cachedBitmap
)
;
dst
-
>
swap
(
cachedBitmap
)
;
}
return
true
;
}
