#
include
"
GrProcessor
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrInvariantOutput
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkSpinlock
.
h
"
#
if
SK_ALLOW_STATIC_GLOBAL_INITIALIZERS
class
GrFragmentProcessor
;
class
GrGeometryProcessor
;
template
<
>
SkTArray
<
GrProcessorTestFactory
<
GrFragmentProcessor
>
*
true
>
*
GrProcessorTestFactory
<
GrFragmentProcessor
>
:
:
GetFactories
(
)
{
static
SkTArray
<
GrProcessorTestFactory
<
GrFragmentProcessor
>
*
true
>
gFactories
;
return
&
gFactories
;
}
template
<
>
SkTArray
<
GrProcessorTestFactory
<
GrXPFactory
>
*
true
>
*
GrProcessorTestFactory
<
GrXPFactory
>
:
:
GetFactories
(
)
{
static
SkTArray
<
GrProcessorTestFactory
<
GrXPFactory
>
*
true
>
gFactories
;
return
&
gFactories
;
}
template
<
>
SkTArray
<
GrProcessorTestFactory
<
GrGeometryProcessor
>
*
true
>
*
GrProcessorTestFactory
<
GrGeometryProcessor
>
:
:
GetFactories
(
)
{
static
SkTArray
<
GrProcessorTestFactory
<
GrGeometryProcessor
>
*
true
>
gFactories
;
return
&
gFactories
;
}
static
const
int
kFPFactoryCount
=
41
;
static
const
int
kGPFactoryCount
=
14
;
static
const
int
kXPFactoryCount
=
6
;
template
<
>
void
GrProcessorTestFactory
<
GrFragmentProcessor
>
:
:
VerifyFactoryCount
(
)
{
if
(
kFPFactoryCount
!
=
GetFactories
(
)
-
>
count
(
)
)
{
SkFAIL
(
"
Wrong
number
of
fragment
processor
factories
!
"
)
;
}
}
template
<
>
void
GrProcessorTestFactory
<
GrGeometryProcessor
>
:
:
VerifyFactoryCount
(
)
{
if
(
kGPFactoryCount
!
=
GetFactories
(
)
-
>
count
(
)
)
{
SkFAIL
(
"
Wrong
number
of
geometry
processor
factories
!
"
)
;
}
}
template
<
>
void
GrProcessorTestFactory
<
GrXPFactory
>
:
:
VerifyFactoryCount
(
)
{
if
(
kXPFactoryCount
!
=
GetFactories
(
)
-
>
count
(
)
)
{
SkFAIL
(
"
Wrong
number
of
xp
factory
factories
!
"
)
;
}
}
#
endif
namespace
{
static
SkSpinlock
gProcessorSpinlock
;
class
MemoryPoolAccessor
{
public
:
#
if
defined
(
SK_BUILD_FOR_ANDROID_FRAMEWORK
)
MemoryPoolAccessor
(
)
{
}
~
MemoryPoolAccessor
(
)
{
}
#
else
MemoryPoolAccessor
(
)
{
gProcessorSpinlock
.
acquire
(
)
;
}
~
MemoryPoolAccessor
(
)
{
gProcessorSpinlock
.
release
(
)
;
}
#
endif
GrMemoryPool
*
pool
(
)
const
{
static
GrMemoryPool
gPool
(
4096
4096
)
;
return
&
gPool
;
}
}
;
}
int32_t
GrProcessor
:
:
gCurrProcessorClassID
=
GrProcessor
:
:
kIllegalProcessorClassID
;
GrProcessor
:
:
~
GrProcessor
(
)
{
}
void
GrProcessor
:
:
addTextureAccess
(
const
GrTextureAccess
*
access
)
{
fTextureAccesses
.
push_back
(
access
)
;
this
-
>
addGpuResource
(
access
-
>
getProgramTexture
(
)
)
;
}
void
GrProcessor
:
:
addBufferAccess
(
const
GrBufferAccess
*
access
)
{
fBufferAccesses
.
push_back
(
access
)
;
this
-
>
addGpuResource
(
access
-
>
getProgramBuffer
(
)
)
;
}
void
*
GrProcessor
:
:
operator
new
(
size_t
size
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
allocate
(
size
)
;
}
void
GrProcessor
:
:
operator
delete
(
void
*
target
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
release
(
target
)
;
}
bool
GrProcessor
:
:
hasSameSamplers
(
const
GrProcessor
&
that
)
const
{
if
(
this
-
>
numTextures
(
)
!
=
that
.
numTextures
(
)
|
|
this
-
>
numBuffers
(
)
!
=
that
.
numBuffers
(
)
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
this
-
>
numTextures
(
)
;
+
+
i
)
{
if
(
this
-
>
textureAccess
(
i
)
!
=
that
.
textureAccess
(
i
)
)
{
return
false
;
}
}
for
(
int
i
=
0
;
i
<
this
-
>
numBuffers
(
)
;
+
+
i
)
{
if
(
this
-
>
bufferAccess
(
i
)
!
=
that
.
bufferAccess
(
i
)
)
{
return
false
;
}
}
return
true
;
}
int32_t
GrXPFactory
:
:
gCurrXPFClassID
=
GrXPFactory
:
:
kIllegalXPFClassID
;
