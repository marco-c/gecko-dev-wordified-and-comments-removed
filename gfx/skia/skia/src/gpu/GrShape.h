#
ifndef
GrShape_DEFINED
#
define
GrShape_DEFINED
#
include
"
GrStyle
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkPathPriv
.
h
"
#
include
"
SkRRect
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTLazy
.
h
"
class
GrShape
{
public
:
static
constexpr
int
kMaxKeyFromDataVerbCnt
=
10
;
GrShape
(
)
{
this
-
>
initType
(
Type
:
:
kEmpty
)
;
}
explicit
GrShape
(
const
SkPath
&
path
)
:
GrShape
(
path
GrStyle
:
:
SimpleFill
(
)
)
{
}
explicit
GrShape
(
const
SkRRect
&
rrect
)
:
GrShape
(
rrect
GrStyle
:
:
SimpleFill
(
)
)
{
}
explicit
GrShape
(
const
SkRect
&
rect
)
:
GrShape
(
rect
GrStyle
:
:
SimpleFill
(
)
)
{
}
GrShape
(
const
SkPath
&
path
const
GrStyle
&
style
)
:
fStyle
(
style
)
{
this
-
>
initType
(
Type
:
:
kPath
&
path
)
;
this
-
>
attemptToSimplifyPath
(
)
;
}
GrShape
(
const
SkRRect
&
rrect
const
GrStyle
&
style
)
:
fStyle
(
style
)
{
this
-
>
initType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
rrect
;
fRRectData
.
fInverted
=
false
;
fRRectData
.
fStart
=
DefaultRRectDirAndStartIndex
(
rrect
style
.
hasPathEffect
(
)
&
fRRectData
.
fDir
)
;
this
-
>
attemptToSimplifyRRect
(
)
;
}
GrShape
(
const
SkRRect
&
rrect
SkPath
:
:
Direction
dir
unsigned
start
bool
inverted
const
GrStyle
&
style
)
:
fStyle
(
style
)
{
this
-
>
initType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
rrect
;
fRRectData
.
fInverted
=
inverted
;
if
(
style
.
pathEffect
(
)
)
{
fRRectData
.
fDir
=
dir
;
fRRectData
.
fStart
=
start
;
if
(
fRRectData
.
fRRect
.
getType
(
)
=
=
SkRRect
:
:
kRect_Type
)
{
fRRectData
.
fStart
=
(
fRRectData
.
fStart
+
1
)
&
0b110
;
}
else
if
(
fRRectData
.
fRRect
.
getType
(
)
=
=
SkRRect
:
:
kOval_Type
)
{
fRRectData
.
fStart
&
=
0b110
;
}
}
else
{
fRRectData
.
fStart
=
DefaultRRectDirAndStartIndex
(
rrect
false
&
fRRectData
.
fDir
)
;
}
this
-
>
attemptToSimplifyRRect
(
)
;
}
GrShape
(
const
SkRect
&
rect
const
GrStyle
&
style
)
:
fStyle
(
style
)
{
this
-
>
initType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
SkRRect
:
:
MakeRect
(
rect
)
;
fRRectData
.
fInverted
=
false
;
fRRectData
.
fStart
=
DefaultRectDirAndStartIndex
(
rect
style
.
hasPathEffect
(
)
&
fRRectData
.
fDir
)
;
this
-
>
attemptToSimplifyRRect
(
)
;
}
GrShape
(
const
SkPath
&
path
const
SkPaint
&
paint
)
:
fStyle
(
paint
)
{
this
-
>
initType
(
Type
:
:
kPath
&
path
)
;
this
-
>
attemptToSimplifyPath
(
)
;
}
GrShape
(
const
SkRRect
&
rrect
const
SkPaint
&
paint
)
:
fStyle
(
paint
)
{
this
-
>
initType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
rrect
;
fRRectData
.
fInverted
=
false
;
fRRectData
.
fStart
=
DefaultRRectDirAndStartIndex
(
rrect
fStyle
.
hasPathEffect
(
)
&
fRRectData
.
fDir
)
;
this
-
>
attemptToSimplifyRRect
(
)
;
}
GrShape
(
const
SkRect
&
rect
const
SkPaint
&
paint
)
:
fStyle
(
paint
)
{
this
-
>
initType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
SkRRect
:
:
MakeRect
(
rect
)
;
fRRectData
.
fInverted
=
false
;
fRRectData
.
fStart
=
DefaultRectDirAndStartIndex
(
rect
fStyle
.
hasPathEffect
(
)
&
fRRectData
.
fDir
)
;
this
-
>
attemptToSimplifyRRect
(
)
;
}
GrShape
(
const
GrShape
&
)
;
GrShape
&
operator
=
(
const
GrShape
&
that
)
;
~
GrShape
(
)
{
this
-
>
changeType
(
Type
:
:
kEmpty
)
;
}
enum
class
FillInversion
{
kPreserve
kFlip
kForceNoninverted
kForceInverted
}
;
static
GrShape
MakeFilled
(
const
GrShape
&
original
FillInversion
=
FillInversion
:
:
kPreserve
)
;
const
GrStyle
&
style
(
)
const
{
return
fStyle
;
}
GrShape
applyStyle
(
GrStyle
:
:
Apply
apply
SkScalar
scale
)
const
{
return
GrShape
(
*
this
apply
scale
)
;
}
bool
asRRect
(
SkRRect
*
rrect
SkPath
:
:
Direction
*
dir
unsigned
*
start
bool
*
inverted
)
const
{
if
(
Type
:
:
kRRect
!
=
fType
)
{
return
false
;
}
if
(
rrect
)
{
*
rrect
=
fRRectData
.
fRRect
;
}
if
(
dir
)
{
*
dir
=
fRRectData
.
fDir
;
}
if
(
start
)
{
*
start
=
fRRectData
.
fStart
;
}
if
(
inverted
)
{
*
inverted
=
fRRectData
.
fInverted
;
}
return
true
;
}
bool
asLine
(
SkPoint
pts
[
2
]
bool
*
inverted
)
const
{
if
(
fType
!
=
Type
:
:
kLine
)
{
return
false
;
}
if
(
pts
)
{
pts
[
0
]
=
fLineData
.
fPts
[
0
]
;
pts
[
1
]
=
fLineData
.
fPts
[
1
]
;
}
if
(
inverted
)
{
*
inverted
=
fLineData
.
fInverted
;
}
return
true
;
}
void
asPath
(
SkPath
*
out
)
const
{
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
out
-
>
reset
(
)
;
break
;
case
Type
:
:
kInvertedEmpty
:
out
-
>
reset
(
)
;
out
-
>
setFillType
(
kDefaultPathInverseFillType
)
;
break
;
case
Type
:
:
kRRect
:
out
-
>
reset
(
)
;
out
-
>
addRRect
(
fRRectData
.
fRRect
fRRectData
.
fDir
fRRectData
.
fStart
)
;
if
(
fRRectData
.
fInverted
)
{
out
-
>
setFillType
(
kDefaultPathInverseFillType
)
;
}
else
{
out
-
>
setFillType
(
kDefaultPathFillType
)
;
}
break
;
case
Type
:
:
kLine
:
out
-
>
reset
(
)
;
out
-
>
moveTo
(
fLineData
.
fPts
[
0
]
)
;
out
-
>
lineTo
(
fLineData
.
fPts
[
1
]
)
;
if
(
fLineData
.
fInverted
)
{
out
-
>
setFillType
(
kDefaultPathInverseFillType
)
;
}
else
{
out
-
>
setFillType
(
kDefaultPathFillType
)
;
}
break
;
case
Type
:
:
kPath
:
*
out
=
this
-
>
path
(
)
;
break
;
}
}
bool
isEmpty
(
)
const
{
return
Type
:
:
kEmpty
=
=
fType
|
|
Type
:
:
kInvertedEmpty
=
=
fType
;
}
SkRect
bounds
(
)
const
;
SkRect
styledBounds
(
)
const
;
bool
knownToBeConvex
(
)
const
{
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
return
true
;
case
Type
:
:
kInvertedEmpty
:
return
true
;
case
Type
:
:
kRRect
:
return
true
;
case
Type
:
:
kLine
:
return
true
;
case
Type
:
:
kPath
:
return
(
this
-
>
style
(
)
.
isSimpleFill
(
)
|
|
this
-
>
path
(
)
.
isLastContourClosed
(
)
)
&
&
this
-
>
path
(
)
.
isConvex
(
)
;
}
return
false
;
}
bool
inverseFilled
(
)
const
{
bool
ret
=
false
;
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
ret
=
false
;
break
;
case
Type
:
:
kInvertedEmpty
:
ret
=
true
;
break
;
case
Type
:
:
kRRect
:
ret
=
fRRectData
.
fInverted
;
break
;
case
Type
:
:
kLine
:
ret
=
fLineData
.
fInverted
;
break
;
case
Type
:
:
kPath
:
ret
=
this
-
>
path
(
)
.
isInverseFillType
(
)
;
break
;
}
SkASSERT
(
!
(
ret
&
&
this
-
>
style
(
)
.
isDashed
(
)
)
)
;
return
ret
;
}
bool
mayBeInverseFilledAfterStyling
(
)
const
{
if
(
this
-
>
style
(
)
.
hasNonDashPathEffect
(
)
)
{
return
true
;
}
return
this
-
>
inverseFilled
(
)
;
}
bool
knownToBeClosed
(
)
const
{
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
return
true
;
case
Type
:
:
kInvertedEmpty
:
return
true
;
case
Type
:
:
kRRect
:
return
true
;
case
Type
:
:
kLine
:
return
false
;
case
Type
:
:
kPath
:
return
SkPathPriv
:
:
IsClosedSingleContour
(
this
-
>
path
(
)
)
;
}
return
false
;
}
uint32_t
segmentMask
(
)
const
{
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
return
0
;
case
Type
:
:
kInvertedEmpty
:
return
0
;
case
Type
:
:
kRRect
:
if
(
fRRectData
.
fRRect
.
getType
(
)
=
=
SkRRect
:
:
kOval_Type
)
{
return
SkPath
:
:
kConic_SegmentMask
;
}
else
if
(
fRRectData
.
fRRect
.
getType
(
)
=
=
SkRRect
:
:
kRect_Type
|
|
fRRectData
.
fRRect
.
getType
(
)
=
=
SkRRect
:
:
kEmpty_Type
)
{
return
SkPath
:
:
kLine_SegmentMask
;
}
return
SkPath
:
:
kLine_SegmentMask
|
SkPath
:
:
kConic_SegmentMask
;
case
Type
:
:
kLine
:
return
SkPath
:
:
kLine_SegmentMask
;
case
Type
:
:
kPath
:
return
this
-
>
path
(
)
.
getSegmentMasks
(
)
;
}
return
0
;
}
int
unstyledKeySize
(
)
const
;
bool
hasUnstyledKey
(
)
const
{
return
this
-
>
unstyledKeySize
(
)
>
=
0
;
}
void
writeUnstyledKey
(
uint32_t
*
key
)
const
;
void
addGenIDChangeListener
(
SkPathRef
:
:
GenIDChangeListener
*
listener
)
const
;
uint32_t
testingOnly_getOriginalGenerationID
(
)
const
;
bool
testingOnly_isPath
(
)
const
;
bool
testingOnly_isNonVolatilePath
(
)
const
;
private
:
enum
class
Type
{
kEmpty
kInvertedEmpty
kRRect
kLine
kPath
}
;
void
initType
(
Type
type
const
SkPath
*
path
=
nullptr
)
{
fType
=
Type
:
:
kEmpty
;
this
-
>
changeType
(
type
path
)
;
}
void
changeType
(
Type
type
const
SkPath
*
path
=
nullptr
)
{
bool
wasPath
=
Type
:
:
kPath
=
=
fType
;
fType
=
type
;
bool
isPath
=
Type
:
:
kPath
=
=
type
;
SkASSERT
(
!
path
|
|
isPath
)
;
if
(
wasPath
&
&
!
isPath
)
{
fPathData
.
fPath
.
~
SkPath
(
)
;
}
else
if
(
!
wasPath
&
&
isPath
)
{
if
(
path
)
{
new
(
&
fPathData
.
fPath
)
SkPath
(
*
path
)
;
}
else
{
new
(
&
fPathData
.
fPath
)
SkPath
(
)
;
}
}
else
if
(
isPath
&
&
path
)
{
fPathData
.
fPath
=
*
path
;
}
fPathData
.
fGenID
=
0
;
}
SkPath
&
path
(
)
{
SkASSERT
(
Type
:
:
kPath
=
=
fType
)
;
return
fPathData
.
fPath
;
}
const
SkPath
&
path
(
)
const
{
SkASSERT
(
Type
:
:
kPath
=
=
fType
)
;
return
fPathData
.
fPath
;
}
GrShape
(
const
GrShape
&
parentShape
GrStyle
:
:
Apply
SkScalar
scale
)
;
void
setInheritedKey
(
const
GrShape
&
parentShape
GrStyle
:
:
Apply
SkScalar
scale
)
;
void
attemptToSimplifyPath
(
)
;
void
attemptToSimplifyRRect
(
)
;
void
attemptToSimplifyLine
(
)
;
bool
attemptToSimplifyStrokedLineToRRect
(
)
;
const
SkPath
*
originalPathForListeners
(
)
const
;
static
constexpr
SkPath
:
:
FillType
kDefaultPathFillType
=
SkPath
:
:
kEvenOdd_FillType
;
static
constexpr
SkPath
:
:
FillType
kDefaultPathInverseFillType
=
SkPath
:
:
kInverseEvenOdd_FillType
;
static
constexpr
SkPath
:
:
Direction
kDefaultRRectDir
=
SkPath
:
:
kCW_Direction
;
static
constexpr
unsigned
kDefaultRRectStart
=
0
;
static
unsigned
DefaultRectDirAndStartIndex
(
const
SkRect
&
rect
bool
hasPathEffect
SkPath
:
:
Direction
*
dir
)
{
*
dir
=
kDefaultRRectDir
;
if
(
!
hasPathEffect
)
{
return
kDefaultRRectStart
;
}
bool
swapX
=
rect
.
fLeft
>
rect
.
fRight
;
bool
swapY
=
rect
.
fTop
>
rect
.
fBottom
;
if
(
swapX
&
&
swapY
)
{
return
2
*
2
;
}
else
if
(
swapX
)
{
*
dir
=
SkPath
:
:
kCCW_Direction
;
return
2
*
1
;
}
else
if
(
swapY
)
{
*
dir
=
SkPath
:
:
kCCW_Direction
;
return
2
*
3
;
}
return
0
;
}
static
unsigned
DefaultRRectDirAndStartIndex
(
const
SkRRect
&
rrect
bool
hasPathEffect
SkPath
:
:
Direction
*
dir
)
{
static
constexpr
unsigned
kPathRRectStartIdx
=
6
;
*
dir
=
kDefaultRRectDir
;
if
(
!
hasPathEffect
)
{
return
kDefaultRRectStart
;
}
return
kPathRRectStartIdx
;
}
Type
fType
;
union
{
struct
{
SkRRect
fRRect
;
SkPath
:
:
Direction
fDir
;
unsigned
fStart
;
bool
fInverted
;
}
fRRectData
;
struct
{
SkPath
fPath
;
int32_t
fGenID
;
}
fPathData
;
struct
{
SkPoint
fPts
[
2
]
;
bool
fInverted
;
}
fLineData
;
}
;
GrStyle
fStyle
;
SkTLazy
<
SkPath
>
fInheritedPathForListeners
;
SkAutoSTArray
<
8
uint32_t
>
fInheritedKey
;
}
;
#
endif
