#
include
"
GrClipStackClip
.
h
"
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrDrawingManager
.
h
"
#
include
"
GrDrawContextPriv
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrStencilAttachment
.
h
"
#
include
"
GrSWMaskHelper
.
h
"
#
include
"
effects
/
GrConvexPolyEffect
.
h
"
#
include
"
effects
/
GrRRectEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
typedef
SkClipStack
:
:
Element
Element
;
typedef
GrReducedClip
:
:
InitialState
InitialState
;
typedef
GrReducedClip
:
:
ElementList
ElementList
;
static
const
int
kMaxAnalyticElements
=
4
;
bool
GrClipStackClip
:
:
quickContains
(
const
SkRect
&
rect
)
const
{
if
(
!
fStack
|
|
fStack
-
>
isWideOpen
(
)
)
{
return
true
;
}
return
fStack
-
>
quickContains
(
rect
.
makeOffset
(
SkIntToScalar
(
fOrigin
.
x
(
)
)
SkIntToScalar
(
fOrigin
.
y
(
)
)
)
)
;
}
bool
GrClipStackClip
:
:
quickContains
(
const
SkRRect
&
rrect
)
const
{
if
(
!
fStack
|
|
fStack
-
>
isWideOpen
(
)
)
{
return
true
;
}
return
fStack
-
>
quickContains
(
rrect
.
makeOffset
(
SkIntToScalar
(
fOrigin
.
fX
)
SkIntToScalar
(
fOrigin
.
fY
)
)
)
;
}
bool
GrClipStackClip
:
:
isRRect
(
const
SkRect
&
origRTBounds
SkRRect
*
rr
bool
*
aa
)
const
{
if
(
!
fStack
)
{
return
false
;
}
const
SkRect
*
rtBounds
=
&
origRTBounds
;
SkRect
tempRTBounds
;
bool
origin
=
fOrigin
.
fX
|
|
fOrigin
.
fY
;
if
(
origin
)
{
tempRTBounds
=
origRTBounds
;
tempRTBounds
.
offset
(
SkIntToScalar
(
fOrigin
.
fX
)
SkIntToScalar
(
fOrigin
.
fY
)
)
;
rtBounds
=
&
tempRTBounds
;
}
if
(
fStack
-
>
isRRect
(
*
rtBounds
rr
aa
)
)
{
if
(
origin
)
{
rr
-
>
offset
(
-
SkIntToScalar
(
fOrigin
.
fX
)
-
SkIntToScalar
(
fOrigin
.
fY
)
)
;
}
return
true
;
}
return
false
;
}
void
GrClipStackClip
:
:
getConservativeBounds
(
int
width
int
height
SkIRect
*
devResult
bool
*
isIntersectionOfRects
)
const
{
if
(
!
fStack
)
{
devResult
-
>
setXYWH
(
0
0
width
height
)
;
if
(
isIntersectionOfRects
)
{
*
isIntersectionOfRects
=
true
;
}
return
;
}
SkRect
devBounds
;
fStack
-
>
getConservativeBounds
(
-
fOrigin
.
x
(
)
-
fOrigin
.
y
(
)
width
height
&
devBounds
isIntersectionOfRects
)
;
devBounds
.
roundOut
(
devResult
)
;
}
static
sk_sp
<
GrFragmentProcessor
>
create_fp_for_mask
(
GrTexture
*
result
const
SkIRect
&
devBound
)
{
SkIRect
domainTexels
=
SkIRect
:
:
MakeWH
(
devBound
.
width
(
)
devBound
.
height
(
)
)
;
return
GrDeviceSpaceTextureDecalFragmentProcessor
:
:
Make
(
result
domainTexels
{
devBound
.
fLeft
devBound
.
fTop
}
)
;
}
bool
GrClipStackClip
:
:
PathNeedsSWRenderer
(
GrContext
*
context
bool
hasUserStencilSettings
const
GrDrawContext
*
drawContext
const
SkMatrix
&
viewMatrix
const
Element
*
element
GrPathRenderer
*
*
prOut
bool
needsStencil
)
{
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
if
(
prOut
)
{
*
prOut
=
nullptr
;
}
return
false
;
}
else
{
SkASSERT
(
Element
:
:
kEmpty_Type
!
=
element
-
>
getType
(
)
)
;
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
if
(
path
.
isInverseFillType
(
)
)
{
path
.
toggleInverseFillType
(
)
;
}
GrPathRendererChain
:
:
DrawType
type
;
if
(
needsStencil
)
{
type
=
element
-
>
isAA
(
)
?
GrPathRendererChain
:
:
kStencilAndColorAntiAlias_DrawType
:
GrPathRendererChain
:
:
kStencilAndColor_DrawType
;
}
else
{
type
=
element
-
>
isAA
(
)
?
GrPathRendererChain
:
:
kColorAntiAlias_DrawType
:
GrPathRendererChain
:
:
kColor_DrawType
;
}
GrShape
shape
(
path
GrStyle
:
:
SimpleFill
(
)
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fShaderCaps
=
context
-
>
caps
(
)
-
>
shaderCaps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fAntiAlias
=
element
-
>
isAA
(
)
;
canDrawArgs
.
fHasUserStencilSettings
=
hasUserStencilSettings
;
canDrawArgs
.
fIsStencilBufferMSAA
=
drawContext
-
>
isStencilBufferMultisampled
(
)
;
GrPathRenderer
*
pr
=
context
-
>
contextPriv
(
)
.
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
type
)
;
if
(
prOut
)
{
*
prOut
=
pr
;
}
return
SkToBool
(
!
pr
)
;
}
}
bool
GrClipStackClip
:
:
UseSWOnlyPath
(
GrContext
*
context
bool
hasUserStencilSettings
const
GrDrawContext
*
drawContext
const
GrReducedClip
&
reducedClip
)
{
SkMatrix
translate
;
translate
.
setTranslate
(
SkIntToScalar
(
-
reducedClip
.
left
(
)
)
SkIntToScalar
(
-
reducedClip
.
top
(
)
)
)
;
for
(
ElementList
:
:
Iter
iter
(
reducedClip
.
elements
(
)
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkCanvas
:
:
ClipOp
op
=
element
-
>
getOp
(
)
;
bool
invert
=
element
-
>
isInverseFilled
(
)
;
bool
needsStencil
=
invert
|
|
SkCanvas
:
:
kIntersect_Op
=
=
op
|
|
SkCanvas
:
:
kReverseDifference_Op
=
=
op
;
if
(
PathNeedsSWRenderer
(
context
hasUserStencilSettings
drawContext
translate
element
nullptr
needsStencil
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
get_analytic_clip_processor
(
const
ElementList
&
elements
bool
abortIfAA
const
SkVector
&
clipToRTOffset
const
SkRect
&
drawBounds
sk_sp
<
GrFragmentProcessor
>
*
resultFP
)
{
SkRect
boundsInClipSpace
;
boundsInClipSpace
=
drawBounds
.
makeOffset
(
-
clipToRTOffset
.
fX
-
clipToRTOffset
.
fY
)
;
SkASSERT
(
elements
.
count
(
)
<
=
kMaxAnalyticElements
)
;
SkSTArray
<
kMaxAnalyticElements
sk_sp
<
GrFragmentProcessor
>
>
fps
;
ElementList
:
:
Iter
iter
(
elements
)
;
while
(
iter
.
get
(
)
)
{
SkCanvas
:
:
ClipOp
op
=
iter
.
get
(
)
-
>
getOp
(
)
;
bool
invert
;
bool
skip
=
false
;
switch
(
op
)
{
case
SkRegion
:
:
kReplace_Op
:
SkASSERT
(
iter
.
get
(
)
=
=
elements
.
head
(
)
)
;
case
SkRegion
:
:
kIntersect_Op
:
invert
=
false
;
if
(
iter
.
get
(
)
-
>
contains
(
boundsInClipSpace
)
)
{
skip
=
true
;
}
break
;
case
SkRegion
:
:
kDifference_Op
:
invert
=
true
;
break
;
default
:
return
false
;
}
if
(
!
skip
)
{
GrPrimitiveEdgeType
edgeType
;
if
(
iter
.
get
(
)
-
>
isAA
(
)
)
{
if
(
abortIfAA
)
{
return
false
;
}
edgeType
=
invert
?
kInverseFillAA_GrProcessorEdgeType
:
kFillAA_GrProcessorEdgeType
;
}
else
{
edgeType
=
invert
?
kInverseFillBW_GrProcessorEdgeType
:
kFillBW_GrProcessorEdgeType
;
}
switch
(
iter
.
get
(
)
-
>
getType
(
)
)
{
case
SkClipStack
:
:
Element
:
:
kPath_Type
:
fps
.
emplace_back
(
GrConvexPolyEffect
:
:
Make
(
edgeType
iter
.
get
(
)
-
>
getPath
(
)
&
clipToRTOffset
)
)
;
break
;
case
SkClipStack
:
:
Element
:
:
kRRect_Type
:
{
SkRRect
rrect
=
iter
.
get
(
)
-
>
getRRect
(
)
;
rrect
.
offset
(
clipToRTOffset
.
fX
clipToRTOffset
.
fY
)
;
fps
.
emplace_back
(
GrRRectEffect
:
:
Make
(
edgeType
rrect
)
)
;
break
;
}
case
SkClipStack
:
:
Element
:
:
kRect_Type
:
{
SkRect
rect
=
iter
.
get
(
)
-
>
getRect
(
)
;
rect
.
offset
(
clipToRTOffset
.
fX
clipToRTOffset
.
fY
)
;
fps
.
emplace_back
(
GrConvexPolyEffect
:
:
Make
(
edgeType
rect
)
)
;
break
;
}
default
:
break
;
}
if
(
!
fps
.
back
(
)
)
{
return
false
;
}
}
iter
.
next
(
)
;
}
*
resultFP
=
nullptr
;
if
(
fps
.
count
(
)
)
{
*
resultFP
=
GrFragmentProcessor
:
:
RunInSeries
(
fps
.
begin
(
)
fps
.
count
(
)
)
;
}
return
true
;
}
bool
GrClipStackClip
:
:
apply
(
GrContext
*
context
GrDrawContext
*
drawContext
bool
useHWAA
bool
hasUserStencilSettings
GrAppliedClip
*
out
)
const
{
if
(
!
fStack
|
|
fStack
-
>
isWideOpen
(
)
)
{
return
true
;
}
SkRect
devBounds
=
SkRect
:
:
MakeIWH
(
drawContext
-
>
width
(
)
drawContext
-
>
height
(
)
)
;
if
(
!
devBounds
.
intersect
(
out
-
>
clippedDrawBounds
(
)
)
)
{
return
false
;
}
GrRenderTarget
*
rt
=
drawContext
-
>
accessRenderTarget
(
)
;
const
SkScalar
clipX
=
SkIntToScalar
(
fOrigin
.
x
(
)
)
clipY
=
SkIntToScalar
(
fOrigin
.
y
(
)
)
;
SkRect
clipSpaceDevBounds
=
devBounds
.
makeOffset
(
clipX
clipY
)
;
const
GrReducedClip
reducedClip
(
*
fStack
clipSpaceDevBounds
rt
-
>
renderTargetPriv
(
)
.
maxWindowRectangles
(
)
)
;
if
(
reducedClip
.
hasIBounds
(
)
&
&
!
GrClip
:
:
IsInsideClip
(
reducedClip
.
ibounds
(
)
clipSpaceDevBounds
)
)
{
SkIRect
scissorSpaceIBounds
(
reducedClip
.
ibounds
(
)
)
;
scissorSpaceIBounds
.
offset
(
-
fOrigin
)
;
out
-
>
addScissor
(
scissorSpaceIBounds
)
;
}
if
(
!
reducedClip
.
windowRectangles
(
)
.
empty
(
)
)
{
out
-
>
addWindowRectangles
(
reducedClip
.
windowRectangles
(
)
fOrigin
GrWindowRectsState
:
:
Mode
:
:
kExclusive
)
;
}
if
(
reducedClip
.
elements
(
)
.
isEmpty
(
)
)
{
return
InitialState
:
:
kAllIn
=
=
reducedClip
.
initialState
(
)
;
}
SkASSERT
(
reducedClip
.
hasIBounds
(
)
)
;
if
(
reducedClip
.
elements
(
)
.
count
(
)
<
=
kMaxAnalyticElements
)
{
bool
disallowAnalyticAA
=
drawContext
-
>
isStencilBufferMultisampled
(
)
;
if
(
disallowAnalyticAA
&
&
!
drawContext
-
>
numColorSamples
(
)
)
{
disallowAnalyticAA
=
useHWAA
|
|
hasUserStencilSettings
;
}
sk_sp
<
GrFragmentProcessor
>
clipFP
;
if
(
reducedClip
.
requiresAA
(
)
&
&
get_analytic_clip_processor
(
reducedClip
.
elements
(
)
disallowAnalyticAA
{
-
clipX
-
clipY
}
devBounds
&
clipFP
)
)
{
out
-
>
addCoverageFP
(
std
:
:
move
(
clipFP
)
)
;
return
true
;
}
}
if
(
!
drawContext
-
>
isStencilBufferMultisampled
(
)
&
&
reducedClip
.
requiresAA
(
)
)
{
sk_sp
<
GrTexture
>
result
;
if
(
UseSWOnlyPath
(
context
hasUserStencilSettings
drawContext
reducedClip
)
)
{
result
=
CreateSoftwareClipMask
(
context
-
>
textureProvider
(
)
reducedClip
)
;
}
else
{
result
=
CreateAlphaClipMask
(
context
reducedClip
)
;
SkASSERT
(
result
)
;
}
if
(
result
)
{
SkIRect
rtSpaceMaskBounds
=
reducedClip
.
ibounds
(
)
;
rtSpaceMaskBounds
.
offset
(
-
fOrigin
)
;
out
-
>
addCoverageFP
(
create_fp_for_mask
(
result
.
get
(
)
rtSpaceMaskBounds
)
)
;
return
true
;
}
}
GrStencilAttachment
*
stencilAttachment
=
context
-
>
resourceProvider
(
)
-
>
attachStencilAttachment
(
rt
)
;
if
(
nullptr
=
=
stencilAttachment
)
{
SkDebugf
(
"
WARNING
:
failed
to
attach
stencil
buffer
for
clip
mask
.
Clip
will
be
ignored
.
\
n
"
)
;
return
true
;
}
if
(
stencilAttachment
-
>
mustRenderClip
(
reducedClip
.
elementsGenID
(
)
reducedClip
.
ibounds
(
)
fOrigin
)
)
{
reducedClip
.
drawStencilClipMask
(
context
drawContext
fOrigin
)
;
stencilAttachment
-
>
setLastClip
(
reducedClip
.
elementsGenID
(
)
reducedClip
.
ibounds
(
)
fOrigin
)
;
}
out
-
>
addStencilClip
(
)
;
return
true
;
}
static
void
GetClipMaskKey
(
int32_t
clipGenID
const
SkIRect
&
bounds
GrUniqueKey
*
key
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kDomain
3
)
;
builder
[
0
]
=
clipGenID
;
builder
[
1
]
=
SkToU16
(
bounds
.
fLeft
)
|
(
SkToU16
(
bounds
.
fRight
)
<
<
16
)
;
builder
[
2
]
=
SkToU16
(
bounds
.
fTop
)
|
(
SkToU16
(
bounds
.
fBottom
)
<
<
16
)
;
}
sk_sp
<
GrTexture
>
GrClipStackClip
:
:
CreateAlphaClipMask
(
GrContext
*
context
const
GrReducedClip
&
reducedClip
)
{
GrResourceProvider
*
resourceProvider
=
context
-
>
resourceProvider
(
)
;
GrUniqueKey
key
;
GetClipMaskKey
(
reducedClip
.
elementsGenID
(
)
reducedClip
.
ibounds
(
)
&
key
)
;
if
(
GrTexture
*
texture
=
resourceProvider
-
>
findAndRefTextureByUniqueKey
(
key
)
)
{
return
sk_sp
<
GrTexture
>
(
texture
)
;
}
sk_sp
<
GrDrawContext
>
dc
(
context
-
>
makeDrawContextWithFallback
(
SkBackingFit
:
:
kApprox
reducedClip
.
width
(
)
reducedClip
.
height
(
)
kAlpha_8_GrPixelConfig
nullptr
)
)
;
if
(
!
dc
)
{
return
nullptr
;
}
if
(
!
reducedClip
.
drawAlphaClipMask
(
dc
.
get
(
)
)
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
texture
(
dc
-
>
asTexture
(
)
)
;
SkASSERT
(
texture
)
;
texture
-
>
resourcePriv
(
)
.
setUniqueKey
(
key
)
;
return
texture
;
}
sk_sp
<
GrTexture
>
GrClipStackClip
:
:
CreateSoftwareClipMask
(
GrTextureProvider
*
texProvider
const
GrReducedClip
&
reducedClip
)
{
GrUniqueKey
key
;
GetClipMaskKey
(
reducedClip
.
elementsGenID
(
)
reducedClip
.
ibounds
(
)
&
key
)
;
if
(
GrTexture
*
texture
=
texProvider
-
>
findAndRefTextureByUniqueKey
(
key
)
)
{
return
sk_sp
<
GrTexture
>
(
texture
)
;
}
SkIRect
maskSpaceIBounds
=
SkIRect
:
:
MakeWH
(
reducedClip
.
width
(
)
reducedClip
.
height
(
)
)
;
GrSWMaskHelper
helper
(
texProvider
)
;
SkMatrix
translate
;
translate
.
setTranslate
(
SkIntToScalar
(
-
reducedClip
.
left
(
)
)
SkIntToScalar
(
-
reducedClip
.
top
(
)
)
)
;
helper
.
init
(
maskSpaceIBounds
&
translate
)
;
helper
.
clear
(
InitialState
:
:
kAllIn
=
=
reducedClip
.
initialState
(
)
?
0xFF
:
0x00
)
;
for
(
ElementList
:
:
Iter
iter
(
reducedClip
.
elements
(
)
)
;
iter
.
get
(
)
;
iter
.
next
(
)
)
{
const
Element
*
element
=
iter
.
get
(
)
;
SkCanvas
:
:
ClipOp
op
=
element
-
>
getOp
(
)
;
if
(
SkCanvas
:
:
kIntersect_Op
=
=
op
|
|
SkCanvas
:
:
kReverseDifference_Op
=
=
op
)
{
if
(
SkCanvas
:
:
kReverseDifference_Op
=
=
op
)
{
SkRect
temp
=
SkRect
:
:
Make
(
reducedClip
.
ibounds
(
)
)
;
helper
.
drawRect
(
temp
SkRegion
:
:
kXOR_Op
false
0xFF
)
;
}
SkPath
clipPath
;
element
-
>
asPath
(
&
clipPath
)
;
clipPath
.
toggleInverseFillType
(
)
;
GrShape
shape
(
clipPath
GrStyle
:
:
SimpleFill
(
)
)
;
helper
.
drawShape
(
shape
SkRegion
:
:
kReplace_Op
element
-
>
isAA
(
)
0x00
)
;
continue
;
}
if
(
Element
:
:
kRect_Type
=
=
element
-
>
getType
(
)
)
{
helper
.
drawRect
(
element
-
>
getRect
(
)
(
SkRegion
:
:
Op
)
op
element
-
>
isAA
(
)
0xFF
)
;
}
else
{
SkPath
path
;
element
-
>
asPath
(
&
path
)
;
GrShape
shape
(
path
GrStyle
:
:
SimpleFill
(
)
)
;
helper
.
drawShape
(
shape
(
SkRegion
:
:
Op
)
op
element
-
>
isAA
(
)
0xFF
)
;
}
}
GrSurfaceDesc
desc
;
desc
.
fWidth
=
reducedClip
.
width
(
)
;
desc
.
fHeight
=
reducedClip
.
height
(
)
;
desc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
sk_sp
<
GrTexture
>
result
(
texProvider
-
>
createApproxTexture
(
desc
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
result
-
>
resourcePriv
(
)
.
setUniqueKey
(
key
)
;
helper
.
toTexture
(
result
.
get
(
)
)
;
return
result
;
}
