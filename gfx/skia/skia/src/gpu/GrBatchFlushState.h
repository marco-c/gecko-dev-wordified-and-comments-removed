#
ifndef
GrBatchBuffer_DEFINED
#
define
GrBatchBuffer_DEFINED
#
include
"
GrBufferAllocPool
.
h
"
#
include
"
batches
/
GrVertexBatch
.
h
"
class
GrResourceProvider
;
class
GrBatchFlushState
{
public
:
GrBatchFlushState
(
GrGpu
*
GrResourceProvider
*
)
;
~
GrBatchFlushState
(
)
{
this
-
>
reset
(
)
;
}
void
addASAPUpload
(
GrDrawBatch
:
:
DeferredUploadFn
&
&
upload
)
{
fAsapUploads
.
emplace_back
(
std
:
:
move
(
upload
)
)
;
}
const
GrCaps
&
caps
(
)
const
{
return
*
fGpu
-
>
caps
(
)
;
}
GrResourceProvider
*
resourceProvider
(
)
const
{
return
fResourceProvider
;
}
bool
hasDrawBeenFlushed
(
GrBatchDrawToken
token
)
const
{
return
token
.
fSequenceNumber
<
=
fLastFlushedToken
.
fSequenceNumber
;
}
GrBatchDrawToken
issueDrawToken
(
)
{
return
GrBatchDrawToken
(
+
+
fLastIssuedToken
.
fSequenceNumber
)
;
}
void
flushToken
(
)
{
+
+
fLastFlushedToken
.
fSequenceNumber
;
}
GrBatchDrawToken
nextDrawToken
(
)
const
{
return
GrBatchDrawToken
(
fLastIssuedToken
.
fSequenceNumber
+
1
)
;
}
GrBatchDrawToken
nextTokenToFlush
(
)
const
{
return
GrBatchDrawToken
(
fLastFlushedToken
.
fSequenceNumber
+
1
)
;
}
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
const
GrBuffer
*
*
buffer
int
*
startVertex
)
;
uint16_t
*
makeIndexSpace
(
int
indexCount
const
GrBuffer
*
*
buffer
int
*
startIndex
)
;
void
preIssueDraws
(
)
{
fVertexPool
.
unmap
(
)
;
fIndexPool
.
unmap
(
)
;
int
uploadCount
=
fAsapUploads
.
count
(
)
;
for
(
int
i
=
0
;
i
<
uploadCount
;
i
+
+
)
{
this
-
>
doUpload
(
fAsapUploads
[
i
]
)
;
}
fAsapUploads
.
reset
(
)
;
}
void
doUpload
(
GrDrawBatch
:
:
DeferredUploadFn
&
upload
)
{
GrDrawBatch
:
:
WritePixelsFn
wp
=
[
this
]
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
void
*
buffer
size_t
rowBytes
)
-
>
bool
{
return
this
-
>
fGpu
-
>
writePixels
(
surface
left
top
width
height
config
buffer
rowBytes
)
;
}
;
upload
(
wp
)
;
}
void
putBackIndices
(
size_t
indices
)
{
fIndexPool
.
putBack
(
indices
*
sizeof
(
uint16_t
)
)
;
}
void
putBackVertexSpace
(
size_t
sizeInBytes
)
{
fVertexPool
.
putBack
(
sizeInBytes
)
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
void
reset
(
)
{
fVertexPool
.
reset
(
)
;
fIndexPool
.
reset
(
)
;
}
private
:
GrGpu
*
fGpu
;
GrResourceProvider
*
fResourceProvider
;
GrVertexBufferAllocPool
fVertexPool
;
GrIndexBufferAllocPool
fIndexPool
;
SkSTArray
<
4
GrDrawBatch
:
:
DeferredUploadFn
>
fAsapUploads
;
GrBatchDrawToken
fLastIssuedToken
;
GrBatchDrawToken
fLastFlushedToken
;
}
;
class
GrDrawBatch
:
:
Target
{
public
:
Target
(
GrBatchFlushState
*
state
GrDrawBatch
*
batch
)
:
fState
(
state
)
fBatch
(
batch
)
{
}
GrBatchDrawToken
addInlineUpload
(
DeferredUploadFn
&
&
upload
)
{
fBatch
-
>
fInlineUploads
.
emplace_back
(
std
:
:
move
(
upload
)
fState
-
>
nextDrawToken
(
)
)
;
return
fBatch
-
>
fInlineUploads
.
back
(
)
.
fUploadBeforeToken
;
}
GrBatchDrawToken
addAsapUpload
(
DeferredUploadFn
&
&
upload
)
{
fState
-
>
addASAPUpload
(
std
:
:
move
(
upload
)
)
;
return
fState
-
>
nextTokenToFlush
(
)
;
}
bool
hasDrawBeenFlushed
(
GrBatchDrawToken
token
)
const
{
return
fState
-
>
hasDrawBeenFlushed
(
token
)
;
}
GrBatchDrawToken
nextDrawToken
(
)
const
{
return
fState
-
>
nextDrawToken
(
)
;
}
const
GrCaps
&
caps
(
)
const
{
return
fState
-
>
caps
(
)
;
}
GrResourceProvider
*
resourceProvider
(
)
const
{
return
fState
-
>
resourceProvider
(
)
;
}
protected
:
GrDrawBatch
*
batch
(
)
{
return
fBatch
;
}
GrBatchFlushState
*
state
(
)
{
return
fState
;
}
private
:
GrBatchFlushState
*
fState
;
GrDrawBatch
*
fBatch
;
}
;
class
GrVertexBatch
:
:
Target
:
public
GrDrawBatch
:
:
Target
{
public
:
Target
(
GrBatchFlushState
*
state
GrVertexBatch
*
batch
)
:
INHERITED
(
state
batch
)
{
}
void
draw
(
const
GrGeometryProcessor
*
gp
const
GrMesh
&
mesh
)
;
void
*
makeVertexSpace
(
size_t
vertexSize
int
vertexCount
const
GrBuffer
*
*
buffer
int
*
startVertex
)
{
return
this
-
>
state
(
)
-
>
makeVertexSpace
(
vertexSize
vertexCount
buffer
startVertex
)
;
}
uint16_t
*
makeIndexSpace
(
int
indexCount
const
GrBuffer
*
*
buffer
int
*
startIndex
)
{
return
this
-
>
state
(
)
-
>
makeIndexSpace
(
indexCount
buffer
startIndex
)
;
}
void
putBackIndices
(
int
indices
)
{
this
-
>
state
(
)
-
>
putBackIndices
(
indices
)
;
}
void
putBackVertices
(
int
vertices
size_t
vertexStride
)
{
this
-
>
state
(
)
-
>
putBackVertexSpace
(
vertices
*
vertexStride
)
;
}
private
:
GrVertexBatch
*
vertexBatch
(
)
{
return
static_cast
<
GrVertexBatch
*
>
(
this
-
>
batch
(
)
)
;
}
typedef
GrDrawBatch
:
:
Target
INHERITED
;
}
;
#
endif
