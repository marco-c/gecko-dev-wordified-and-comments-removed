#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrImageTextureMaker
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkImage_GpuYUVA
.
h
"
#
include
"
SkImage_Lazy
.
h
"
#
include
"
effects
/
GrYUVtoRGBEffect
.
h
"
GrImageTextureMaker
:
:
GrImageTextureMaker
(
GrRecordingContext
*
context
const
SkImage
*
client
SkImage
:
:
CachingHint
chint
bool
useDecal
)
:
INHERITED
(
context
client
-
>
width
(
)
client
-
>
height
(
)
client
-
>
isAlphaOnly
(
)
useDecal
)
fImage
(
static_cast
<
const
SkImage_Lazy
*
>
(
client
)
)
fCachingHint
(
chint
)
{
SkASSERT
(
client
-
>
isLazyGenerated
(
)
)
;
GrMakeKeyFromImageID
(
&
fOriginalKey
client
-
>
uniqueID
(
)
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrImageTextureMaker
:
:
refOriginalTextureProxy
(
bool
willBeMipped
AllowedTexGenType
onlyIfFast
)
{
return
fImage
-
>
lockTextureProxy
(
this
-
>
context
(
)
fOriginalKey
fCachingHint
willBeMipped
onlyIfFast
)
;
}
void
GrImageTextureMaker
:
:
makeCopyKey
(
const
CopyParams
&
stretch
GrUniqueKey
*
paramsCopyKey
)
{
if
(
fOriginalKey
.
isValid
(
)
&
&
SkImage
:
:
kAllow_CachingHint
=
=
fCachingHint
)
{
GrUniqueKey
cacheKey
;
fImage
-
>
makeCacheKeyFromOrigKey
(
fOriginalKey
&
cacheKey
)
;
MakeCopyKeyFromOrigKey
(
cacheKey
stretch
paramsCopyKey
)
;
}
}
SkAlphaType
GrImageTextureMaker
:
:
alphaType
(
)
const
{
return
fImage
-
>
alphaType
(
)
;
}
SkColorSpace
*
GrImageTextureMaker
:
:
colorSpace
(
)
const
{
return
fImage
-
>
colorSpace
(
)
;
}
GrYUVAImageTextureMaker
:
:
GrYUVAImageTextureMaker
(
GrContext
*
context
const
SkImage
*
client
bool
useDecal
)
:
INHERITED
(
context
client
-
>
width
(
)
client
-
>
height
(
)
client
-
>
isAlphaOnly
(
)
useDecal
)
fImage
(
static_cast
<
const
SkImage_GpuYUVA
*
>
(
client
)
)
{
SkASSERT
(
as_IB
(
client
)
-
>
isYUVA
(
)
)
;
GrMakeKeyFromImageID
(
&
fOriginalKey
client
-
>
uniqueID
(
)
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrYUVAImageTextureMaker
:
:
refOriginalTextureProxy
(
bool
willBeMipped
AllowedTexGenType
onlyIfFast
)
{
if
(
AllowedTexGenType
:
:
kCheap
=
=
onlyIfFast
)
{
return
nullptr
;
}
if
(
willBeMipped
)
{
return
fImage
-
>
asMippedTextureProxyRef
(
this
-
>
context
(
)
)
;
}
else
{
return
fImage
-
>
asTextureProxyRef
(
this
-
>
context
(
)
)
;
}
}
void
GrYUVAImageTextureMaker
:
:
makeCopyKey
(
const
CopyParams
&
stretch
GrUniqueKey
*
paramsCopyKey
)
{
if
(
fOriginalKey
.
isValid
(
)
)
{
GrUniqueKey
cacheKey
;
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
&
cacheKey
fOriginalKey
kDomain
0
"
Image
"
)
;
MakeCopyKeyFromOrigKey
(
cacheKey
stretch
paramsCopyKey
)
;
}
}
SkAlphaType
GrYUVAImageTextureMaker
:
:
alphaType
(
)
const
{
return
fImage
-
>
alphaType
(
)
;
}
SkColorSpace
*
GrYUVAImageTextureMaker
:
:
colorSpace
(
)
const
{
return
fImage
-
>
colorSpace
(
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrYUVAImageTextureMaker
:
:
createFragmentProcessor
(
const
SkMatrix
&
textureMatrix
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
)
{
if
(
!
textureMatrix
.
isIdentity
(
)
|
|
kNo_FilterConstraint
!
=
filterConstraint
|
|
!
coordsLimitedToConstraintRect
|
|
!
filterOrNullForBicubic
|
|
this
-
>
domainNeedsDecal
(
)
)
{
return
this
-
>
INHERITED
:
:
createFragmentProcessor
(
textureMatrix
constraintRect
filterConstraint
coordsLimitedToConstraintRect
filterOrNullForBicubic
)
;
}
GrSamplerState
:
:
Filter
filter
=
*
filterOrNullForBicubic
;
if
(
GrSamplerState
:
:
Filter
:
:
kMipMap
=
=
filter
&
&
!
fImage
-
>
setupMipmapsForPlanes
(
this
-
>
context
(
)
)
)
{
filter
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
}
auto
fp
=
GrYUVtoRGBEffect
:
:
Make
(
fImage
-
>
fProxies
fImage
-
>
fYUVAIndices
fImage
-
>
fYUVColorSpace
filter
)
;
if
(
fImage
-
>
fTargetColorSpace
)
{
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
fImage
-
>
fColorSpace
.
get
(
)
fImage
-
>
alphaType
(
)
fImage
-
>
fTargetColorSpace
.
get
(
)
)
;
}
return
fp
;
}
