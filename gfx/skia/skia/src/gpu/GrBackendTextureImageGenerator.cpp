#
include
"
include
/
gpu
/
GrContext
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
gpu
/
GrBackendTextureImageGenerator
.
h
"
#
include
"
src
/
gpu
/
GrContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetContext
.
h
"
#
include
"
src
/
gpu
/
GrResourceCache
.
h
"
#
include
"
src
/
gpu
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrResourceProviderPriv
.
h
"
#
include
"
src
/
gpu
/
GrSemaphore
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxyPriv
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
gl
/
GrGLTexture
.
h
"
GrBackendTextureImageGenerator
:
:
RefHelper
:
:
RefHelper
(
GrTexture
*
texture
uint32_t
owningContextID
)
:
fOriginalTexture
(
texture
)
fOwningContextID
(
owningContextID
)
fBorrowingContextReleaseProc
(
nullptr
)
fBorrowingContextID
(
SK_InvalidGenID
)
{
}
GrBackendTextureImageGenerator
:
:
RefHelper
:
:
~
RefHelper
(
)
{
SkASSERT
(
fBorrowingContextID
=
=
SK_InvalidUniqueID
)
;
GrTextureFreedMessage
msg
{
fOriginalTexture
fOwningContextID
}
;
SkMessageBus
<
GrTextureFreedMessage
>
:
:
Post
(
msg
)
;
}
std
:
:
unique_ptr
<
SkImageGenerator
>
GrBackendTextureImageGenerator
:
:
Make
(
sk_sp
<
GrTexture
>
texture
GrSurfaceOrigin
origin
sk_sp
<
GrSemaphore
>
semaphore
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
)
{
GrContext
*
context
=
texture
-
>
getContext
(
)
;
context
-
>
priv
(
)
.
getResourceCache
(
)
-
>
insertDelayedTextureUnref
(
texture
.
get
(
)
)
;
GrBackendTexture
backendTexture
=
texture
-
>
getBackendTexture
(
)
;
if
(
!
context
-
>
priv
(
)
.
caps
(
)
-
>
areColorTypeAndFormatCompatible
(
SkColorTypeToGrColorType
(
colorType
)
backendTexture
.
getBackendFormat
(
)
)
)
{
return
nullptr
;
}
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
texture
-
>
width
(
)
texture
-
>
height
(
)
colorType
alphaType
std
:
:
move
(
colorSpace
)
)
;
return
std
:
:
unique_ptr
<
SkImageGenerator
>
(
new
GrBackendTextureImageGenerator
(
info
texture
.
get
(
)
origin
context
-
>
priv
(
)
.
contextID
(
)
std
:
:
move
(
semaphore
)
backendTexture
)
)
;
}
GrBackendTextureImageGenerator
:
:
GrBackendTextureImageGenerator
(
const
SkImageInfo
&
info
GrTexture
*
texture
GrSurfaceOrigin
origin
uint32_t
owningContextID
sk_sp
<
GrSemaphore
>
semaphore
const
GrBackendTexture
&
backendTex
)
:
INHERITED
(
info
)
fRefHelper
(
new
RefHelper
(
texture
owningContextID
)
)
fSemaphore
(
std
:
:
move
(
semaphore
)
)
fBackendTexture
(
backendTex
)
fSurfaceOrigin
(
origin
)
{
}
GrBackendTextureImageGenerator
:
:
~
GrBackendTextureImageGenerator
(
)
{
fRefHelper
-
>
unref
(
)
;
}
void
GrBackendTextureImageGenerator
:
:
ReleaseRefHelper_TextureReleaseProc
(
void
*
ctx
)
{
RefHelper
*
refHelper
=
static_cast
<
RefHelper
*
>
(
ctx
)
;
SkASSERT
(
refHelper
)
;
refHelper
-
>
fBorrowingContextReleaseProc
=
nullptr
;
refHelper
-
>
fBorrowingContextID
=
SK_InvalidGenID
;
refHelper
-
>
unref
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrBackendTextureImageGenerator
:
:
onGenerateTexture
(
GrRecordingContext
*
context
const
SkImageInfo
&
info
const
SkIPoint
&
origin
bool
willNeedMipMaps
)
{
SkASSERT
(
context
)
;
if
(
context
-
>
backend
(
)
!
=
fBackendTexture
.
backend
(
)
)
{
return
nullptr
;
}
if
(
info
.
colorType
(
)
!
=
this
-
>
getInfo
(
)
.
colorType
(
)
)
{
return
nullptr
;
}
auto
proxyProvider
=
context
-
>
priv
(
)
.
proxyProvider
(
)
;
const
GrCaps
*
caps
=
context
-
>
priv
(
)
.
caps
(
)
;
fBorrowingMutex
.
acquire
(
)
;
sk_sp
<
GrRefCntedCallback
>
releaseProcHelper
;
if
(
SK_InvalidGenID
!
=
fRefHelper
-
>
fBorrowingContextID
)
{
if
(
fRefHelper
-
>
fBorrowingContextID
!
=
context
-
>
priv
(
)
.
contextID
(
)
)
{
fBorrowingMutex
.
release
(
)
;
return
nullptr
;
}
else
{
SkASSERT
(
fRefHelper
-
>
fBorrowingContextReleaseProc
)
;
releaseProcHelper
=
sk_ref_sp
(
fRefHelper
-
>
fBorrowingContextReleaseProc
)
;
}
}
else
{
SkASSERT
(
!
fRefHelper
-
>
fBorrowingContextReleaseProc
)
;
fRefHelper
-
>
ref
(
)
;
releaseProcHelper
.
reset
(
new
GrRefCntedCallback
(
ReleaseRefHelper_TextureReleaseProc
fRefHelper
)
)
;
fRefHelper
-
>
fBorrowingContextReleaseProc
=
releaseProcHelper
.
get
(
)
;
}
fRefHelper
-
>
fBorrowingContextID
=
context
-
>
priv
(
)
.
contextID
(
)
;
if
(
!
fRefHelper
-
>
fBorrowedTextureKey
.
isValid
(
)
)
{
static
const
auto
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
&
fRefHelper
-
>
fBorrowedTextureKey
kDomain
1
)
;
builder
[
0
]
=
this
-
>
uniqueID
(
)
;
}
fBorrowingMutex
.
release
(
)
;
SkASSERT
(
fRefHelper
-
>
fBorrowingContextID
=
=
context
-
>
priv
(
)
.
contextID
(
)
)
;
GrBackendFormat
backendFormat
=
fBackendTexture
.
getBackendFormat
(
)
;
SkASSERT
(
backendFormat
.
isValid
(
)
)
;
GrColorType
grColorType
=
SkColorTypeToGrColorType
(
info
.
colorType
(
)
)
;
GrPixelConfig
config
=
caps
-
>
getConfigFromBackendFormat
(
backendFormat
grColorType
)
;
if
(
kUnknown_GrPixelConfig
=
=
config
)
{
return
nullptr
;
}
GrSurfaceDesc
desc
;
desc
.
fWidth
=
fBackendTexture
.
width
(
)
;
desc
.
fHeight
=
fBackendTexture
.
height
(
)
;
desc
.
fConfig
=
config
;
GrMipMapped
mipMapped
=
fBackendTexture
.
hasMipMaps
(
)
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
;
GrMipMapsStatus
mipMapsStatus
=
fBackendTexture
.
hasMipMaps
(
)
?
GrMipMapsStatus
:
:
kValid
:
GrMipMapsStatus
:
:
kNotAllocated
;
sk_sp
<
GrTextureProxy
>
proxy
=
proxyProvider
-
>
createLazyProxy
(
[
refHelper
=
fRefHelper
releaseProcHelper
semaphore
=
fSemaphore
backendTexture
=
fBackendTexture
grColorType
]
(
GrResourceProvider
*
resourceProvider
)
-
>
GrSurfaceProxy
:
:
LazyCallbackResult
{
if
(
semaphore
)
{
resourceProvider
-
>
priv
(
)
.
gpu
(
)
-
>
waitSemaphore
(
semaphore
)
;
}
sk_sp
<
GrTexture
>
tex
;
SkASSERT
(
refHelper
-
>
fBorrowedTextureKey
.
isValid
(
)
)
;
auto
surf
=
resourceProvider
-
>
findByUniqueKey
<
GrSurface
>
(
refHelper
-
>
fBorrowedTextureKey
)
;
if
(
surf
)
{
SkASSERT
(
surf
-
>
asTexture
(
)
)
;
tex
=
sk_ref_sp
(
surf
-
>
asTexture
(
)
)
;
}
else
{
tex
=
resourceProvider
-
>
wrapBackendTexture
(
backendTexture
grColorType
kBorrow_GrWrapOwnership
GrWrapCacheable
:
:
kNo
kRead_GrIOType
)
;
if
(
!
tex
)
{
return
{
}
;
}
tex
-
>
setRelease
(
releaseProcHelper
)
;
tex
-
>
resourcePriv
(
)
.
setUniqueKey
(
refHelper
-
>
fBorrowedTextureKey
)
;
}
return
{
std
:
:
move
(
tex
)
true
GrSurfaceProxy
:
:
LazyInstantiationKeyMode
:
:
kUnsynced
}
;
}
backendFormat
desc
GrRenderable
:
:
kNo
1
fSurfaceOrigin
mipMapped
mipMapsStatus
GrInternalSurfaceFlags
:
:
kReadOnly
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kNo
GrProtected
:
:
kNo
GrSurfaceProxy
:
:
UseAllocator
:
:
kYes
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
if
(
0
=
=
origin
.
fX
&
&
0
=
=
origin
.
fY
&
&
info
.
width
(
)
=
=
fBackendTexture
.
width
(
)
&
&
info
.
height
(
)
=
=
fBackendTexture
.
height
(
)
&
&
(
!
willNeedMipMaps
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
)
{
return
proxy
;
}
else
{
GrMipMapped
mipMapped
=
willNeedMipMaps
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
;
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
origin
.
fX
origin
.
fY
info
.
width
(
)
info
.
height
(
)
)
;
return
GrSurfaceProxy
:
:
Copy
(
context
proxy
.
get
(
)
grColorType
mipMapped
subset
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kYes
)
;
}
}
