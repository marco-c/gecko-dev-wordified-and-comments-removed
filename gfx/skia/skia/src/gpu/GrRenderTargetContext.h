#
ifndef
GrRenderTargetContext_DEFINED
#
define
GrRenderTargetContext_DEFINED
#
include
"
.
.
/
private
/
GrRenderTargetProxy
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrSurfaceContext
.
h
"
#
include
"
GrTypesPriv
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
"
SkDrawable
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkSurfaceProps
.
h
"
#
include
"
text
/
GrTextTarget
.
h
"
class
GrBackendSemaphore
;
class
GrClip
;
class
GrColorSpaceXform
;
class
GrCoverageCountingPathRenderer
;
class
GrDrawingManager
;
class
GrDrawOp
;
class
GrFixedClip
;
class
GrOp
;
class
GrRenderTarget
;
class
GrRenderTargetContextPriv
;
class
GrRenderTargetOpList
;
class
GrShape
;
class
GrStyle
;
class
GrTextureProxy
;
struct
GrUserStencilSettings
;
struct
SkDrawShadowRec
;
class
SkGlyphRunList
;
struct
SkIPoint
;
struct
SkIRect
;
class
SkLatticeIter
;
class
SkMatrix
;
class
SkPaint
;
class
SkPath
;
struct
SkPoint
;
struct
SkRect
;
class
SkRegion
;
class
SkRRect
;
struct
SkRSXform
;
class
SkTextBlob
;
class
SkVertices
;
class
SK_API
GrRenderTargetContext
:
public
GrSurfaceContext
{
public
:
~
GrRenderTargetContext
(
)
override
;
virtual
void
drawGlyphRunList
(
const
GrClip
&
const
SkMatrix
&
viewMatrix
const
SkGlyphRunList
&
)
;
void
discard
(
)
;
enum
class
CanClearFullscreen
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
clear
(
const
SkIRect
*
rect
const
SkPMColor4f
&
color
CanClearFullscreen
)
;
void
drawPaint
(
const
GrClip
&
GrPaint
&
&
const
SkMatrix
&
viewMatrix
)
;
void
drawRect
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
const
GrStyle
*
style
=
nullptr
)
;
void
fillRectToRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rectToDraw
const
SkRect
&
localRect
)
{
this
-
>
fillRectWithEdgeAA
(
clip
std
:
:
move
(
paint
)
aa
aa
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
viewMatrix
rectToDraw
&
localRect
)
;
}
void
fillRectWithLocalMatrix
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkMatrix
&
localMatrix
)
;
void
fillRectWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkRect
*
optionalLocalRect
=
nullptr
)
;
void
fillQuadWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkPoint
quad
[
4
]
const
SkPoint
optionalLocalQuad
[
4
]
)
;
struct
QuadSetEntry
{
SkRect
fRect
;
SkPMColor4f
fColor
;
SkMatrix
fLocalMatrix
;
GrQuadAAFlags
fAAFlags
;
}
;
void
drawQuadSet
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
QuadSetEntry
[
]
int
cnt
)
;
void
drawTexture
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
GrSamplerState
:
:
Filter
SkBlendMode
mode
const
SkPMColor4f
&
const
SkRect
&
srcRect
const
SkRect
&
dstRect
GrAA
GrQuadAAFlags
SkCanvas
:
:
SrcRectConstraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
;
void
drawTextureQuad
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
GrSamplerState
:
:
Filter
SkBlendMode
mode
const
SkPMColor4f
&
const
SkPoint
srcQuad
[
4
]
const
SkPoint
dstQuad
[
4
]
GrAA
GrQuadAAFlags
const
SkRect
*
domain
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
;
struct
TextureSetEntry
{
sk_sp
<
GrTextureProxy
>
fProxy
;
SkRect
fSrcRect
;
SkRect
fDstRect
;
const
SkPoint
*
fDstClipQuad
;
const
SkMatrix
*
fPreViewMatrix
;
float
fAlpha
;
GrQuadAAFlags
fAAFlags
;
}
;
void
drawTextureSet
(
const
GrClip
&
const
TextureSetEntry
[
]
int
cnt
GrSamplerState
:
:
Filter
SkBlendMode
mode
GrAA
aa
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
;
void
drawRRect
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
;
bool
drawFastShadow
(
const
GrClip
&
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
;
void
drawDRRect
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
outer
const
SkRRect
&
inner
)
;
void
drawPath
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
const
GrStyle
&
)
;
void
drawShape
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
GrShape
&
)
;
void
drawVertices
(
const
GrClip
&
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
SkVertices
>
vertices
const
SkVertices
:
:
Bone
bones
[
]
int
boneCount
GrPrimitiveType
*
overridePrimType
=
nullptr
)
;
void
drawAtlas
(
const
GrClip
&
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
;
void
drawRegion
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
void
drawOval
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
;
void
drawArc
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
;
void
drawImageLattice
(
const
GrClip
&
GrPaint
&
&
const
SkMatrix
&
viewMatrix
sk_sp
<
GrTextureProxy
>
sk_sp
<
GrColorSpaceXform
>
GrSamplerState
:
:
Filter
std
:
:
unique_ptr
<
SkLatticeIter
>
const
SkRect
&
dst
)
;
void
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
const
SkRect
&
bounds
)
;
GrSemaphoresSubmitted
prepareForExternalIO
(
SkSurface
:
:
BackendSurfaceAccess
access
SkSurface
:
:
FlushFlags
flags
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
;
bool
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
)
;
void
insertEventMarker
(
const
SkString
&
)
;
GrFSAAType
fsaaType
(
)
const
{
return
fRenderTargetProxy
-
>
fsaaType
(
)
;
}
const
GrCaps
*
caps
(
)
const
;
int
width
(
)
const
{
return
fRenderTargetProxy
-
>
width
(
)
;
}
int
height
(
)
const
{
return
fRenderTargetProxy
-
>
height
(
)
;
}
int
numColorSamples
(
)
const
{
return
fRenderTargetProxy
-
>
numColorSamples
(
)
;
}
int
numStencilSamples
(
)
const
{
return
fRenderTargetProxy
-
>
numStencilSamples
(
)
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
GrSurfaceOrigin
origin
(
)
const
{
return
fRenderTargetProxy
-
>
origin
(
)
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
fRenderTargetProxy
-
>
wrapsVkSecondaryCB
(
)
;
}
GrMipMapped
mipMapped
(
)
const
;
void
setNeedsStencil
(
)
{
fRenderTargetProxy
-
>
setNeedsStencil
(
)
;
}
GrRenderTarget
*
accessRenderTarget
(
)
{
return
fRenderTargetProxy
-
>
peekRenderTarget
(
)
;
}
GrSurfaceProxy
*
asSurfaceProxy
(
)
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
const
GrSurfaceProxy
*
asSurfaceProxy
(
)
const
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
sk_sp
<
GrSurfaceProxy
>
asSurfaceProxyRef
(
)
override
{
return
fRenderTargetProxy
;
}
GrTextureProxy
*
asTextureProxy
(
)
override
;
const
GrTextureProxy
*
asTextureProxy
(
)
const
override
;
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
)
override
;
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
sk_sp
<
GrRenderTargetProxy
>
asRenderTargetProxyRef
(
)
override
{
return
fRenderTargetProxy
;
}
GrRenderTargetContext
*
asRenderTargetContext
(
)
override
{
return
this
;
}
GrRenderTargetContextPriv
priv
(
)
;
const
GrRenderTargetContextPriv
priv
(
)
const
;
GrTextTarget
*
textTarget
(
)
{
return
fTextTarget
.
get
(
)
;
}
bool
isWrapped_ForTesting
(
)
const
;
protected
:
GrRenderTargetContext
(
GrRecordingContext
*
sk_sp
<
GrRenderTargetProxy
>
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
bool
managedOpList
=
true
)
;
SkDEBUGCODE
(
void
validate
(
)
const
override
;
)
private
:
class
TextTarget
;
inline
GrAAType
chooseAAType
(
GrAA
aa
GrAllowMixedSamples
allowMixedSamples
)
{
return
GrChooseAAType
(
aa
this
-
>
fsaaType
(
)
allowMixedSamples
*
this
-
>
caps
(
)
)
;
}
friend
class
GrAtlasTextBlob
;
friend
class
GrClipStackClip
;
friend
class
GrDrawingManager
;
friend
class
GrRenderTargetContextPriv
;
friend
class
GrSoftwarePathRenderer
;
friend
class
GrAAConvexPathRenderer
;
friend
class
GrDashLinePathRenderer
;
friend
class
GrAAHairLinePathRenderer
;
friend
class
GrAALinearizingConvexPathRenderer
;
friend
class
GrSmallPathRenderer
;
friend
class
GrDefaultPathRenderer
;
friend
class
GrStencilAndCoverPathRenderer
;
friend
class
GrTessellatingPathRenderer
;
friend
class
GrCCPerFlushResources
;
friend
class
GrCoverageCountingPathRenderer
;
friend
void
test_draw_op
(
GrContext
*
GrRenderTargetContext
*
std
:
:
unique_ptr
<
GrFragmentProcessor
>
sk_sp
<
GrTextureProxy
>
)
;
void
internalClear
(
const
GrFixedClip
&
const
SkPMColor4f
&
CanClearFullscreen
)
;
void
internalStencilClear
(
const
GrFixedClip
&
bool
insideStencilMask
)
;
bool
drawFilledDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
origOuter
const
SkRRect
&
origInner
)
;
void
drawFilledRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
bool
drawFilledRectAsClear
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
;
void
drawShapeUsingPathRenderer
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
const
GrShape
&
)
;
using
WillAddOpFn
=
void
(
GrOp
*
uint32_t
opListID
)
;
void
addDrawOp
(
const
GrClip
&
std
:
:
unique_ptr
<
GrDrawOp
>
const
std
:
:
function
<
WillAddOpFn
>
&
=
std
:
:
function
<
WillAddOpFn
>
(
)
)
;
bool
SK_WARN_UNUSED_RESULT
setupDstProxy
(
GrRenderTargetProxy
*
const
GrClip
&
const
GrOp
&
op
GrXferProcessor
:
:
DstProxy
*
result
)
;
GrRenderTargetOpList
*
getRTOpList
(
)
;
GrOpList
*
getOpList
(
)
override
;
std
:
:
unique_ptr
<
GrTextTarget
>
fTextTarget
;
sk_sp
<
GrRenderTargetProxy
>
fRenderTargetProxy
;
sk_sp
<
GrRenderTargetOpList
>
fOpList
;
SkSurfaceProps
fSurfaceProps
;
bool
fManagedOpList
;
typedef
GrSurfaceContext
INHERITED
;
}
;
#
endif
