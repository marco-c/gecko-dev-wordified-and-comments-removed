#
ifndef
GrRenderTargetContext_DEFINED
#
define
GrRenderTargetContext_DEFINED
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkDrawable
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
private
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
GrOpsTask
.
h
"
#
include
"
src
/
gpu
/
GrPaint
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetProxy
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceContext
.
h
"
#
include
"
src
/
gpu
/
GrXferProcessor
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextTarget
.
h
"
class
GrBackendSemaphore
;
class
GrClip
;
class
GrColorSpaceXform
;
class
GrCoverageCountingPathRenderer
;
class
GrDrawingManager
;
class
GrDrawOp
;
class
GrFixedClip
;
class
GrOp
;
class
GrRenderTarget
;
class
GrRenderTargetContextPriv
;
class
GrShape
;
class
GrStyle
;
class
GrTextureProxy
;
struct
GrUserStencilSettings
;
struct
SkDrawShadowRec
;
class
SkGlyphRunList
;
struct
SkIPoint
;
struct
SkIRect
;
class
SkLatticeIter
;
class
SkMatrix
;
class
SkPaint
;
class
SkPath
;
struct
SkPoint
;
struct
SkRect
;
class
SkRegion
;
class
SkRRect
;
struct
SkRSXform
;
class
SkTextBlob
;
class
SkVertices
;
class
GrRenderTargetContext
:
public
GrSurfaceContext
{
public
:
~
GrRenderTargetContext
(
)
override
;
virtual
void
drawGlyphRunList
(
const
GrClip
&
const
SkMatrix
&
viewMatrix
const
SkGlyphRunList
&
)
;
void
discard
(
)
;
enum
class
CanClearFullscreen
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
clear
(
const
SkIRect
*
rect
const
SkPMColor4f
&
color
CanClearFullscreen
)
;
void
clear
(
const
SkPMColor4f
&
color
)
{
return
this
-
>
clear
(
nullptr
color
CanClearFullscreen
:
:
kYes
)
;
}
void
drawPaint
(
const
GrClip
&
GrPaint
&
&
const
SkMatrix
&
viewMatrix
)
;
void
drawRect
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
const
GrStyle
*
style
=
nullptr
)
;
void
fillRectToRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rectToDraw
const
SkRect
&
localRect
)
{
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
aa
aa
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
GrQuad
:
:
MakeFromRect
(
rectToDraw
viewMatrix
)
GrQuad
(
localRect
)
)
;
}
void
fillRectWithLocalMatrix
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkMatrix
&
localMatrix
)
{
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
aa
aa
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
:
:
MakeFromRect
(
rect
localMatrix
)
)
;
}
void
fillRectWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkRect
*
optionalLocalRect
=
nullptr
)
{
const
SkRect
&
localRect
=
optionalLocalRect
?
*
optionalLocalRect
:
rect
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
aa
edgeAA
GrQuad
:
:
MakeFromRect
(
rect
viewMatrix
)
GrQuad
(
localRect
)
)
;
}
void
fillQuadWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkPoint
quad
[
4
]
const
SkPoint
optionalLocalQuad
[
4
]
)
{
const
SkPoint
*
localQuad
=
optionalLocalQuad
?
optionalLocalQuad
:
quad
;
this
-
>
drawFilledQuad
(
clip
std
:
:
move
(
paint
)
aa
edgeAA
GrQuad
:
:
MakeFromSkQuad
(
quad
viewMatrix
)
GrQuad
:
:
MakeFromSkQuad
(
localQuad
SkMatrix
:
:
I
(
)
)
)
;
}
struct
QuadSetEntry
{
SkRect
fRect
;
SkPMColor4f
fColor
;
SkMatrix
fLocalMatrix
;
GrQuadAAFlags
fAAFlags
;
}
;
void
drawQuadSet
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
QuadSetEntry
[
]
int
cnt
)
;
void
drawTexture
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
const
SkPMColor4f
&
color
const
SkRect
&
srcRect
const
SkRect
&
dstRect
GrAA
aa
GrQuadAAFlags
edgeAA
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
const
SkRect
*
domain
=
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
;
this
-
>
drawTexturedQuad
(
clip
std
:
:
move
(
proxy
)
srcColorType
std
:
:
move
(
texXform
)
filter
color
mode
aa
edgeAA
GrQuad
:
:
MakeFromRect
(
dstRect
viewMatrix
)
GrQuad
(
srcRect
)
domain
)
;
}
void
drawTextureQuad
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
const
SkPMColor4f
&
color
const
SkPoint
srcQuad
[
4
]
const
SkPoint
dstQuad
[
4
]
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkRect
*
domain
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
this
-
>
drawTexturedQuad
(
clip
std
:
:
move
(
proxy
)
srcColorType
std
:
:
move
(
texXform
)
filter
color
mode
aa
edgeAA
GrQuad
:
:
MakeFromSkQuad
(
dstQuad
viewMatrix
)
GrQuad
:
:
MakeFromSkQuad
(
srcQuad
SkMatrix
:
:
I
(
)
)
domain
)
;
}
struct
TextureSetEntry
{
sk_sp
<
GrTextureProxy
>
fProxy
;
GrColorType
fSrcColorType
;
SkRect
fSrcRect
;
SkRect
fDstRect
;
const
SkPoint
*
fDstClipQuad
;
const
SkMatrix
*
fPreViewMatrix
;
float
fAlpha
;
GrQuadAAFlags
fAAFlags
;
}
;
void
drawTextureSet
(
const
GrClip
&
const
TextureSetEntry
[
]
int
cnt
GrSamplerState
:
:
Filter
SkBlendMode
mode
GrAA
aa
SkCanvas
:
:
SrcRectConstraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
;
void
drawRRect
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
;
bool
drawFastShadow
(
const
GrClip
&
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
;
void
drawDRRect
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
outer
const
SkRRect
&
inner
)
;
void
drawPath
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
const
GrStyle
&
)
;
void
drawShape
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
viewMatrix
const
GrShape
&
)
;
void
drawVertices
(
const
GrClip
&
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
SkVertices
>
vertices
const
SkVertices
:
:
Bone
bones
[
]
int
boneCount
GrPrimitiveType
*
overridePrimType
=
nullptr
)
;
void
drawAtlas
(
const
GrClip
&
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
;
void
drawRegion
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
void
drawOval
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
;
void
drawArc
(
const
GrClip
&
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
;
void
drawImageLattice
(
const
GrClip
&
GrPaint
&
&
const
SkMatrix
&
viewMatrix
sk_sp
<
GrTextureProxy
>
GrColorType
srcColorType
sk_sp
<
GrColorSpaceXform
>
GrSamplerState
:
:
Filter
std
:
:
unique_ptr
<
SkLatticeIter
>
const
SkRect
&
dst
)
;
bool
blitTexture
(
GrTextureProxy
*
src
GrColorType
srcColorType
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
void
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
const
SkRect
&
bounds
)
;
using
ReadPixelsCallback
=
SkSurface
:
:
ReadPixelsCallback
;
using
ReadPixelsContext
=
SkSurface
:
:
ReadPixelsContext
;
using
RescaleGamma
=
SkSurface
:
:
RescaleGamma
;
void
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
const
SkIRect
&
srcRect
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
GrSemaphoresSubmitted
flush
(
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
)
;
bool
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
)
;
void
insertEventMarker
(
const
SkString
&
)
;
const
GrRenderTargetProxy
*
proxy
(
)
const
{
return
fRenderTargetProxy
.
get
(
)
;
}
int
width
(
)
const
{
return
fRenderTargetProxy
-
>
width
(
)
;
}
int
height
(
)
const
{
return
fRenderTargetProxy
-
>
height
(
)
;
}
int
numSamples
(
)
const
{
return
fRenderTargetProxy
-
>
numSamples
(
)
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
GrSurfaceOrigin
origin
(
)
const
{
return
fRenderTargetProxy
-
>
origin
(
)
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
fRenderTargetProxy
-
>
wrapsVkSecondaryCB
(
)
;
}
GrMipMapped
mipMapped
(
)
const
;
GrRenderTarget
*
accessRenderTarget
(
)
{
return
fRenderTargetProxy
-
>
peekRenderTarget
(
)
;
}
GrSurfaceProxy
*
asSurfaceProxy
(
)
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
const
GrSurfaceProxy
*
asSurfaceProxy
(
)
const
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
sk_sp
<
GrSurfaceProxy
>
asSurfaceProxyRef
(
)
override
{
return
fRenderTargetProxy
;
}
GrTextureProxy
*
asTextureProxy
(
)
override
;
const
GrTextureProxy
*
asTextureProxy
(
)
const
override
;
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
)
override
;
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
override
{
return
fRenderTargetProxy
.
get
(
)
;
}
sk_sp
<
GrRenderTargetProxy
>
asRenderTargetProxyRef
(
)
override
{
return
fRenderTargetProxy
;
}
GrRenderTargetContext
*
asRenderTargetContext
(
)
override
{
return
this
;
}
GrRenderTargetContextPriv
priv
(
)
;
const
GrRenderTargetContextPriv
priv
(
)
const
;
GrTextTarget
*
textTarget
(
)
{
return
fTextTarget
.
get
(
)
;
}
#
if
GR_TEST_UTILS
bool
testingOnly_IsInstantiated
(
)
const
{
return
fRenderTargetProxy
-
>
isInstantiated
(
)
;
}
void
testingOnly_SetPreserveOpsOnFullClear
(
)
{
fPreserveOpsOnFullClear_TestingOnly
=
true
;
}
GrOpsTask
*
testingOnly_PeekLastOpsTask
(
)
{
return
fOpsTask
.
get
(
)
;
}
#
endif
protected
:
GrRenderTargetContext
(
GrRecordingContext
*
sk_sp
<
GrRenderTargetProxy
>
GrColorType
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
bool
managedOpsTask
=
true
)
;
SkDEBUGCODE
(
void
validate
(
)
const
override
;
)
private
:
class
TextTarget
;
enum
class
QuadOptimization
;
GrAAType
chooseAAType
(
GrAA
)
;
friend
class
GrAtlasTextBlob
;
friend
class
GrClipStackClip
;
friend
class
GrOnFlushResourceProvider
;
friend
class
GrDrawingManager
;
friend
class
GrRenderTargetContextPriv
;
friend
class
GrSoftwarePathRenderer
;
friend
class
GrAAConvexPathRenderer
;
friend
class
GrDashLinePathRenderer
;
friend
class
GrAAHairLinePathRenderer
;
friend
class
GrAALinearizingConvexPathRenderer
;
friend
class
GrSmallPathRenderer
;
friend
class
GrDefaultPathRenderer
;
friend
class
GrStencilAndCoverPathRenderer
;
friend
class
GrTessellatingPathRenderer
;
friend
class
GrCCPerFlushResources
;
friend
class
GrCoverageCountingPathRenderer
;
friend
void
test_draw_op
(
GrContext
*
GrRenderTargetContext
*
std
:
:
unique_ptr
<
GrFragmentProcessor
>
sk_sp
<
GrTextureProxy
>
GrColorType
)
;
GrOpsTask
:
:
CanDiscardPreviousOps
canDiscardPreviousOpsOnFullClear
(
)
const
;
void
setNeedsStencil
(
bool
useMixedSamplesIfNotMSAA
)
;
void
internalClear
(
const
GrFixedClip
&
const
SkPMColor4f
&
CanClearFullscreen
)
;
void
internalStencilClear
(
const
GrFixedClip
&
bool
insideStencilMask
)
;
bool
drawFilledDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
const
SkMatrix
&
viewMatrix
const
SkRRect
&
origOuter
const
SkRRect
&
origInner
)
;
QuadOptimization
attemptQuadOptimization
(
const
GrClip
&
clip
const
SkPMColor4f
*
constColor
const
GrUserStencilSettings
*
stencilSettings
GrAA
*
aa
GrQuadAAFlags
*
edgeFlags
GrQuad
*
deviceQuad
GrQuad
*
localQuad
)
;
void
drawFilledQuad
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeFlags
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
GrUserStencilSettings
*
ss
=
nullptr
)
;
void
drawTexturedQuad
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
sk_sp
<
GrColorSpaceXform
>
textureXform
GrSamplerState
:
:
Filter
filter
const
SkPMColor4f
&
color
SkBlendMode
blendMode
GrAA
aa
GrQuadAAFlags
edgeFlags
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
SkRect
*
domain
=
nullptr
)
;
void
drawShapeUsingPathRenderer
(
const
GrClip
&
GrPaint
&
&
GrAA
const
SkMatrix
&
const
GrShape
&
)
;
void
addOp
(
std
:
:
unique_ptr
<
GrOp
>
)
;
using
WillAddOpFn
=
void
(
GrOp
*
uint32_t
opsTaskID
)
;
void
addDrawOp
(
const
GrClip
&
std
:
:
unique_ptr
<
GrDrawOp
>
const
std
:
:
function
<
WillAddOpFn
>
&
=
std
:
:
function
<
WillAddOpFn
>
(
)
)
;
bool
SK_WARN_UNUSED_RESULT
setupDstProxy
(
const
GrClip
&
const
GrOp
&
op
GrXferProcessor
:
:
DstProxy
*
result
)
;
class
AsyncReadResult
;
void
asyncReadPixels
(
const
SkIRect
&
rect
SkColorType
colorType
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
GrOpsTask
*
getOpsTask
(
)
;
std
:
:
unique_ptr
<
GrTextTarget
>
fTextTarget
;
sk_sp
<
GrRenderTargetProxy
>
fRenderTargetProxy
;
sk_sp
<
GrOpsTask
>
fOpsTask
;
SkSurfaceProps
fSurfaceProps
;
bool
fManagedOpsTask
;
int
fNumStencilSamples
=
0
;
#
if
GR_TEST_UTILS
bool
fPreserveOpsOnFullClear_TestingOnly
=
false
;
#
endif
typedef
GrSurfaceContext
INHERITED
;
}
;
#
endif
