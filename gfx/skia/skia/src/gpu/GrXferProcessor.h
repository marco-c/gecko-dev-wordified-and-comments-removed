#
ifndef
GrXferProcessor_DEFINED
#
define
GrXferProcessor_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
src
/
gpu
/
GrBlend
.
h
"
#
include
"
src
/
gpu
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
GrProcessorAnalysis
.
h
"
class
GrGLSLXferProcessor
;
class
GrProcessorSet
;
class
GrShaderCaps
;
enum
GrXferBarrierType
{
kNone_GrXferBarrierType
=
0
kTexture_GrXferBarrierType
kBlend_GrXferBarrierType
}
;
GR_STATIC_ASSERT
(
SkToBool
(
kNone_GrXferBarrierType
)
=
=
false
)
;
class
GrXferProcessor
:
public
GrProcessor
public
GrNonAtomicRef
<
GrXferProcessor
>
{
public
:
class
DstProxy
{
public
:
DstProxy
(
)
{
fOffset
.
set
(
0
0
)
;
}
DstProxy
(
const
DstProxy
&
other
)
{
*
this
=
other
;
}
DstProxy
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkIPoint
&
offset
)
:
fProxy
(
std
:
:
move
(
proxy
)
)
{
if
(
fProxy
)
{
fOffset
=
offset
;
}
else
{
fOffset
.
set
(
0
0
)
;
}
}
DstProxy
&
operator
=
(
const
DstProxy
&
other
)
{
fProxy
=
other
.
fProxy
;
fOffset
=
other
.
fOffset
;
return
*
this
;
}
bool
operator
=
=
(
const
DstProxy
&
that
)
const
{
return
fProxy
=
=
that
.
fProxy
&
&
fOffset
=
=
that
.
fOffset
;
}
bool
operator
!
=
(
const
DstProxy
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
const
SkIPoint
&
offset
(
)
const
{
return
fOffset
;
}
void
setOffset
(
const
SkIPoint
&
offset
)
{
fOffset
=
offset
;
}
void
setOffset
(
int
ox
int
oy
)
{
fOffset
.
set
(
ox
oy
)
;
}
GrTextureProxy
*
proxy
(
)
const
{
return
fProxy
.
get
(
)
;
}
sk_sp
<
GrTextureProxy
>
refProxy
(
)
const
{
return
fProxy
;
}
void
setProxy
(
sk_sp
<
GrTextureProxy
>
proxy
)
{
fProxy
=
std
:
:
move
(
proxy
)
;
if
(
!
fProxy
)
{
fOffset
=
{
0
0
}
;
}
}
private
:
sk_sp
<
GrTextureProxy
>
fProxy
;
SkIPoint
fOffset
;
}
;
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
const
GrSurfaceOrigin
*
originIfDstTexture
)
const
;
virtual
GrGLSLXferProcessor
*
createGLSLInstance
(
)
const
=
0
;
virtual
GrXferBarrierType
xferBarrierType
(
const
GrCaps
&
caps
)
const
{
return
kNone_GrXferBarrierType
;
}
struct
BlendInfo
{
SkDEBUGCODE
(
SkString
dump
(
)
const
;
)
GrBlendEquation
fEquation
=
kAdd_GrBlendEquation
;
GrBlendCoeff
fSrcBlend
=
kOne_GrBlendCoeff
;
GrBlendCoeff
fDstBlend
=
kZero_GrBlendCoeff
;
SkPMColor4f
fBlendConstant
=
SK_PMColor4fTRANSPARENT
;
bool
fWriteColor
=
true
;
}
;
inline
BlendInfo
getBlendInfo
(
)
const
{
BlendInfo
blendInfo
;
if
(
!
this
-
>
willReadDstColor
(
)
)
{
this
-
>
onGetBlendInfo
(
&
blendInfo
)
;
}
else
if
(
this
-
>
dstReadUsesMixedSamples
(
)
)
{
blendInfo
.
fDstBlend
=
kIS2A_GrBlendCoeff
;
}
return
blendInfo
;
}
bool
willReadDstColor
(
)
const
{
return
fWillReadDstColor
;
}
bool
dstReadUsesMixedSamples
(
)
const
{
return
fDstReadUsesMixedSamples
;
}
bool
hasSecondaryOutput
(
)
const
;
bool
isLCD
(
)
const
{
return
fIsLCD
;
}
bool
isEqual
(
const
GrXferProcessor
&
that
)
const
{
if
(
this
-
>
classID
(
)
!
=
that
.
classID
(
)
)
{
return
false
;
}
if
(
this
-
>
fWillReadDstColor
!
=
that
.
fWillReadDstColor
)
{
return
false
;
}
if
(
this
-
>
fDstReadUsesMixedSamples
!
=
that
.
fDstReadUsesMixedSamples
)
{
return
false
;
}
if
(
fIsLCD
!
=
that
.
fIsLCD
)
{
return
false
;
}
return
this
-
>
onIsEqual
(
that
)
;
}
protected
:
GrXferProcessor
(
ClassID
classID
)
;
GrXferProcessor
(
ClassID
classID
bool
willReadDstColor
bool
hasMixedSamples
GrProcessorAnalysisCoverage
)
;
private
:
virtual
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
=
0
;
virtual
bool
onHasSecondaryOutput
(
)
const
{
return
false
;
}
virtual
void
onGetBlendInfo
(
BlendInfo
*
)
const
{
}
virtual
bool
onIsEqual
(
const
GrXferProcessor
&
)
const
=
0
;
bool
fWillReadDstColor
;
bool
fDstReadUsesMixedSamples
;
bool
fIsLCD
;
typedef
GrProcessor
INHERITED
;
}
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wnon
-
virtual
-
dtor
"
#
endif
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wnon
-
virtual
-
dtor
"
#
endif
class
GrXPFactory
{
public
:
typedef
GrXferProcessor
:
:
DstProxy
DstProxy
;
enum
class
AnalysisProperties
:
unsigned
{
kNone
=
0x0
kReadsDstInShader
=
0x1
kCompatibleWithCoverageAsAlpha
=
0x2
kIgnoresInputColor
=
0x4
kRequiresDstTexture
=
0x10
kRequiresNonOverlappingDraws
=
0x20
}
;
GR_DECL_BITFIELD_CLASS_OPS_FRIENDS
(
AnalysisProperties
)
;
static
sk_sp
<
const
GrXferProcessor
>
MakeXferProcessor
(
const
GrXPFactory
*
const
GrProcessorAnalysisColor
&
GrProcessorAnalysisCoverage
bool
hasMixedSamples
const
GrCaps
&
caps
GrClampType
)
;
static
AnalysisProperties
GetAnalysisProperties
(
const
GrXPFactory
*
const
GrProcessorAnalysisColor
&
const
GrProcessorAnalysisCoverage
&
const
GrCaps
&
GrClampType
)
;
protected
:
constexpr
GrXPFactory
(
)
{
}
private
:
virtual
sk_sp
<
const
GrXferProcessor
>
makeXferProcessor
(
const
GrProcessorAnalysisColor
&
GrProcessorAnalysisCoverage
bool
hasMixedSamples
const
GrCaps
&
GrClampType
)
const
=
0
;
virtual
AnalysisProperties
analysisProperties
(
const
GrProcessorAnalysisColor
&
const
GrProcessorAnalysisCoverage
&
const
GrCaps
&
GrClampType
)
const
=
0
;
}
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
pop
#
endif
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
GR_MAKE_BITFIELD_CLASS_OPS
(
GrXPFactory
:
:
AnalysisProperties
)
;
#
endif
