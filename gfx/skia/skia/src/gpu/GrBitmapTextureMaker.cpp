#
include
"
src
/
gpu
/
GrBitmapTextureMaker
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkPixelRef
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
src
/
core
/
SkMipMap
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceContext
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
GrBitmapTextureMaker
:
:
GrBitmapTextureMaker
(
GrRecordingContext
*
context
const
SkBitmap
&
bitmap
bool
useDecal
)
:
INHERITED
(
context
bitmap
.
width
(
)
bitmap
.
height
(
)
bitmap
.
info
(
)
.
colorInfo
(
)
useDecal
)
fBitmap
(
bitmap
)
{
if
(
!
bitmap
.
isVolatile
(
)
)
{
SkIPoint
origin
=
bitmap
.
pixelRefOrigin
(
)
;
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
origin
.
fX
origin
.
fY
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
GrMakeKeyFromImageID
(
&
fOriginalKey
bitmap
.
pixelRef
(
)
-
>
getGenerationID
(
)
subset
)
;
}
}
sk_sp
<
GrTextureProxy
>
GrBitmapTextureMaker
:
:
refOriginalTextureProxy
(
bool
willBeMipped
AllowedTexGenType
onlyIfFast
)
{
if
(
AllowedTexGenType
:
:
kCheap
=
=
onlyIfFast
)
{
return
nullptr
;
}
GrProxyProvider
*
proxyProvider
=
this
-
>
context
(
)
-
>
priv
(
)
.
proxyProvider
(
)
;
sk_sp
<
GrTextureProxy
>
proxy
;
if
(
fOriginalKey
.
isValid
(
)
)
{
auto
colorType
=
SkColorTypeToGrColorType
(
fBitmap
.
colorType
(
)
)
;
proxy
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
fOriginalKey
colorType
kTopLeft_GrSurfaceOrigin
)
;
if
(
proxy
&
&
(
!
willBeMipped
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
)
{
return
proxy
;
}
}
if
(
!
proxy
)
{
proxy
=
proxyProvider
-
>
createProxyFromBitmap
(
fBitmap
willBeMipped
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
)
;
if
(
proxy
)
{
if
(
fOriginalKey
.
isValid
(
)
)
{
proxyProvider
-
>
assignUniqueKeyToProxy
(
fOriginalKey
proxy
.
get
(
)
)
;
}
if
(
!
willBeMipped
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
{
SkASSERT
(
proxy
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
if
(
fOriginalKey
.
isValid
(
)
)
{
GrInstallBitmapUniqueKeyInvalidator
(
fOriginalKey
proxyProvider
-
>
contextID
(
)
fBitmap
.
pixelRef
(
)
)
;
}
return
proxy
;
}
}
}
if
(
proxy
)
{
SkASSERT
(
willBeMipped
)
;
SkASSERT
(
GrMipMapped
:
:
kNo
=
=
proxy
-
>
mipMapped
(
)
)
;
GrColorType
srcColorType
=
SkColorTypeToGrColorType
(
fBitmap
.
colorType
(
)
)
;
if
(
auto
mippedProxy
=
GrCopyBaseMipMapToTextureProxy
(
this
-
>
context
(
)
proxy
.
get
(
)
srcColorType
)
)
{
SkASSERT
(
mippedProxy
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
if
(
fOriginalKey
.
isValid
(
)
)
{
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
=
=
fOriginalKey
)
;
proxyProvider
-
>
removeUniqueKeyFromProxy
(
proxy
.
get
(
)
)
;
proxyProvider
-
>
assignUniqueKeyToProxy
(
fOriginalKey
mippedProxy
.
get
(
)
)
;
GrInstallBitmapUniqueKeyInvalidator
(
fOriginalKey
proxyProvider
-
>
contextID
(
)
fBitmap
.
pixelRef
(
)
)
;
}
return
mippedProxy
;
}
return
proxy
;
}
return
nullptr
;
}
void
GrBitmapTextureMaker
:
:
makeCopyKey
(
const
CopyParams
&
copyParams
GrUniqueKey
*
copyKey
)
{
if
(
fOriginalKey
.
isValid
(
)
)
{
MakeCopyKeyFromOrigKey
(
fOriginalKey
copyParams
copyKey
)
;
}
}
void
GrBitmapTextureMaker
:
:
didCacheCopy
(
const
GrUniqueKey
&
copyKey
uint32_t
contextUniqueID
)
{
GrInstallBitmapUniqueKeyInvalidator
(
copyKey
contextUniqueID
fBitmap
.
pixelRef
(
)
)
;
}
