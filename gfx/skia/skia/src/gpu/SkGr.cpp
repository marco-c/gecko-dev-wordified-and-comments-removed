#
include
"
SkGr
.
h
"
#
include
"
GrBitmapTextureMaker
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkBlendModePriv
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
"
SkColorFilter
.
h
"
#
include
"
SkConvertPixels
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkImage_Base
.
h
"
#
include
"
SkImageInfoPriv
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkPM4fPriv
.
h
"
#
include
"
SkPaintPriv
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkShaderBase
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTraceEvent
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrConstColorProcessor
.
h
"
#
include
"
effects
/
GrDitherEffect
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrXfermodeFragmentProcessor
.
h
"
GrSurfaceDesc
GrImageInfoToSurfaceDesc
(
const
SkImageInfo
&
info
const
GrCaps
&
caps
)
{
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kNone_GrSurfaceFlags
;
desc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
desc
.
fWidth
=
info
.
width
(
)
;
desc
.
fHeight
=
info
.
height
(
)
;
desc
.
fConfig
=
SkImageInfo2GrPixelConfig
(
info
caps
)
;
desc
.
fSampleCnt
=
1
;
return
desc
;
}
void
GrMakeKeyFromImageID
(
GrUniqueKey
*
key
uint32_t
imageID
const
SkIRect
&
imageBounds
)
{
SkASSERT
(
key
)
;
SkASSERT
(
imageID
)
;
SkASSERT
(
!
imageBounds
.
isEmpty
(
)
)
;
static
const
GrUniqueKey
:
:
Domain
kImageIDDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kImageIDDomain
5
)
;
builder
[
0
]
=
imageID
;
builder
[
1
]
=
imageBounds
.
fLeft
;
builder
[
2
]
=
imageBounds
.
fTop
;
builder
[
3
]
=
imageBounds
.
fRight
;
builder
[
4
]
=
imageBounds
.
fBottom
;
}
sk_sp
<
GrTextureProxy
>
GrUploadBitmapToTextureProxy
(
GrProxyProvider
*
proxyProvider
const
SkBitmap
&
bitmap
SkColorSpace
*
dstColorSpace
)
{
if
(
!
bitmap
.
peekPixels
(
nullptr
)
)
{
return
nullptr
;
}
SkDestinationSurfaceColorMode
colorMode
=
dstColorSpace
?
SkDestinationSurfaceColorMode
:
:
kGammaAndColorSpaceAware
:
SkDestinationSurfaceColorMode
:
:
kLegacy
;
if
(
!
SkImageInfoIsValid
(
bitmap
.
info
(
)
colorMode
)
)
{
return
nullptr
;
}
SkCopyPixelsMode
cpyMode
=
proxyProvider
-
>
mutableBitmapsNeedCopy
(
)
?
kIfMutable_SkCopyPixelsMode
:
kNever_SkCopyPixelsMode
;
sk_sp
<
SkImage
>
image
=
SkMakeImageFromRasterBitmap
(
bitmap
cpyMode
)
;
return
proxyProvider
-
>
createTextureProxy
(
std
:
:
move
(
image
)
kNone_GrSurfaceFlags
kTopLeft_GrSurfaceOrigin
1
SkBudgeted
:
:
kYes
SkBackingFit
:
:
kExact
)
;
}
void
GrInstallBitmapUniqueKeyInvalidator
(
const
GrUniqueKey
&
key
SkPixelRef
*
pixelRef
)
{
class
Invalidator
:
public
SkPixelRef
:
:
GenIDChangeListener
{
public
:
explicit
Invalidator
(
const
GrUniqueKey
&
key
)
:
fMsg
(
key
)
{
}
private
:
GrUniqueKeyInvalidatedMessage
fMsg
;
void
onChange
(
)
override
{
SkMessageBus
<
GrUniqueKeyInvalidatedMessage
>
:
:
Post
(
fMsg
)
;
}
}
;
pixelRef
-
>
addGenIDChangeListener
(
new
Invalidator
(
key
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrCopyBaseMipMapToTextureProxy
(
GrContext
*
ctx
GrTextureProxy
*
baseProxy
)
{
SkASSERT
(
baseProxy
)
;
if
(
!
ctx
-
>
caps
(
)
-
>
isConfigCopyable
(
baseProxy
-
>
config
(
)
)
)
{
return
nullptr
;
}
GrProxyProvider
*
proxyProvider
=
ctx
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kNone_GrSurfaceFlags
;
desc
.
fOrigin
=
baseProxy
-
>
origin
(
)
;
desc
.
fWidth
=
baseProxy
-
>
width
(
)
;
desc
.
fHeight
=
baseProxy
-
>
height
(
)
;
desc
.
fConfig
=
baseProxy
-
>
config
(
)
;
desc
.
fSampleCnt
=
1
;
sk_sp
<
GrTextureProxy
>
proxy
=
proxyProvider
-
>
createMipMapProxy
(
desc
SkBudgeted
:
:
kYes
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
sk_sp
<
SkColorSpace
>
colorSpace
;
if
(
GrPixelConfigIsSRGB
(
proxy
-
>
config
(
)
)
)
{
colorSpace
=
SkColorSpace
:
:
MakeSRGB
(
)
;
}
sk_sp
<
GrSurfaceContext
>
sContext
=
ctx
-
>
contextPriv
(
)
.
makeWrappedSurfaceContext
(
proxy
std
:
:
move
(
colorSpace
)
)
;
SkASSERT
(
sContext
)
;
SkAssertResult
(
sContext
-
>
copy
(
baseProxy
)
)
;
return
proxy
;
}
sk_sp
<
GrTextureProxy
>
GrRefCachedBitmapTextureProxy
(
GrContext
*
ctx
const
SkBitmap
&
bitmap
const
GrSamplerState
&
params
SkScalar
scaleAdjust
[
2
]
)
{
return
GrBitmapTextureMaker
(
ctx
bitmap
)
.
refTextureProxyForParams
(
params
nullptr
nullptr
scaleAdjust
)
;
}
sk_sp
<
GrTextureProxy
>
GrMakeCachedBitmapProxy
(
GrProxyProvider
*
proxyProvider
const
SkBitmap
&
bitmap
SkBackingFit
fit
)
{
if
(
!
bitmap
.
peekPixels
(
nullptr
)
)
{
return
nullptr
;
}
SkCopyPixelsMode
cpyMode
=
proxyProvider
-
>
mutableBitmapsNeedCopy
(
)
?
kIfMutable_SkCopyPixelsMode
:
kNever_SkCopyPixelsMode
;
sk_sp
<
SkImage
>
image
=
SkMakeImageFromRasterBitmap
(
bitmap
cpyMode
)
;
if
(
!
image
)
{
return
nullptr
;
}
return
GrMakeCachedImageProxy
(
proxyProvider
std
:
:
move
(
image
)
fit
)
;
}
static
void
create_unique_key_for_image
(
const
SkImage
*
image
GrUniqueKey
*
result
)
{
if
(
!
image
)
{
result
-
>
reset
(
)
;
return
;
}
if
(
const
SkBitmap
*
bm
=
as_IB
(
image
)
-
>
onPeekBitmap
(
)
)
{
SkIPoint
origin
=
bm
-
>
pixelRefOrigin
(
)
;
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
origin
.
fX
origin
.
fY
bm
-
>
width
(
)
bm
-
>
height
(
)
)
;
GrMakeKeyFromImageID
(
result
bm
-
>
getGenerationID
(
)
subset
)
;
return
;
}
GrMakeKeyFromImageID
(
result
image
-
>
uniqueID
(
)
image
-
>
bounds
(
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrMakeCachedImageProxy
(
GrProxyProvider
*
proxyProvider
sk_sp
<
SkImage
>
srcImage
SkBackingFit
fit
)
{
sk_sp
<
GrTextureProxy
>
proxy
;
GrUniqueKey
originalKey
;
create_unique_key_for_image
(
srcImage
.
get
(
)
&
originalKey
)
;
if
(
originalKey
.
isValid
(
)
)
{
proxy
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
originalKey
kTopLeft_GrSurfaceOrigin
)
;
}
if
(
!
proxy
)
{
proxy
=
proxyProvider
-
>
createTextureProxy
(
std
:
:
move
(
srcImage
)
kNone_GrSurfaceFlags
kTopLeft_GrSurfaceOrigin
1
SkBudgeted
:
:
kYes
fit
)
;
if
(
proxy
&
&
originalKey
.
isValid
(
)
)
{
proxyProvider
-
>
assignUniqueKeyToProxy
(
originalKey
proxy
.
get
(
)
)
;
}
}
return
proxy
;
}
GrColor4f
SkColorToPremulGrColor4f
(
SkColor
c
const
GrColorSpaceInfo
&
colorSpaceInfo
)
{
return
SkColorToUnpremulGrColor4f
(
c
colorSpaceInfo
)
.
premul
(
)
;
}
GrColor4f
SkColorToPremulGrColor4fLegacy
(
SkColor
c
)
{
return
GrColor4f
:
:
FromGrColor
(
SkColorToUnpremulGrColor
(
c
)
)
.
premul
(
)
;
}
GrColor4f
SkColorToUnpremulGrColor4f
(
SkColor
c
const
GrColorSpaceInfo
&
colorSpaceInfo
)
{
GrColor4f
color
;
if
(
colorSpaceInfo
.
colorSpace
(
)
)
{
color
=
GrColor4f
:
:
FromSkColor4f
(
SkColor4f
:
:
FromColor
(
c
)
)
;
}
else
{
color
=
GrColor4f
:
:
FromGrColor
(
SkColorToUnpremulGrColor
(
c
)
)
;
}
if
(
auto
*
xform
=
colorSpaceInfo
.
colorSpaceXformFromSRGB
(
)
)
{
color
=
xform
-
>
clampedXform
(
color
)
;
}
return
color
;
}
GrPixelConfig
SkImageInfo2GrPixelConfig
(
const
SkColorType
type
SkColorSpace
*
cs
const
GrCaps
&
caps
)
{
switch
(
type
)
{
case
kUnknown_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kAlpha_8_SkColorType
:
return
kAlpha_8_GrPixelConfig
;
case
kRGB_565_SkColorType
:
return
kRGB_565_GrPixelConfig
;
case
kARGB_4444_SkColorType
:
return
kRGBA_4444_GrPixelConfig
;
case
kRGBA_8888_SkColorType
:
return
(
caps
.
srgbSupport
(
)
&
&
cs
&
&
cs
-
>
gammaCloseToSRGB
(
)
)
?
kSRGBA_8888_GrPixelConfig
:
kRGBA_8888_GrPixelConfig
;
case
kRGB_888x_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kBGRA_8888_SkColorType
:
return
(
caps
.
srgbSupport
(
)
&
&
cs
&
&
cs
-
>
gammaCloseToSRGB
(
)
)
?
kSBGRA_8888_GrPixelConfig
:
kBGRA_8888_GrPixelConfig
;
case
kRGBA_1010102_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kRGB_101010x_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kGray_8_SkColorType
:
return
kGray_8_GrPixelConfig
;
case
kRGBA_F16_SkColorType
:
return
kRGBA_half_GrPixelConfig
;
}
SkASSERT
(
0
)
;
return
kUnknown_GrPixelConfig
;
}
GrPixelConfig
SkImageInfo2GrPixelConfig
(
const
SkImageInfo
&
info
const
GrCaps
&
caps
)
{
return
SkImageInfo2GrPixelConfig
(
info
.
colorType
(
)
info
.
colorSpace
(
)
caps
)
;
}
bool
GrPixelConfigToColorType
(
GrPixelConfig
config
SkColorType
*
ctOut
)
{
SkColorType
ct
;
switch
(
config
)
{
case
kAlpha_8_GrPixelConfig
:
case
kAlpha_8_as_Alpha_GrPixelConfig
:
case
kAlpha_8_as_Red_GrPixelConfig
:
ct
=
kAlpha_8_SkColorType
;
break
;
case
kGray_8_GrPixelConfig
:
case
kGray_8_as_Lum_GrPixelConfig
:
case
kGray_8_as_Red_GrPixelConfig
:
ct
=
kGray_8_SkColorType
;
break
;
case
kRGB_565_GrPixelConfig
:
ct
=
kRGB_565_SkColorType
;
break
;
case
kRGBA_4444_GrPixelConfig
:
ct
=
kARGB_4444_SkColorType
;
break
;
case
kRGBA_8888_GrPixelConfig
:
ct
=
kRGBA_8888_SkColorType
;
break
;
case
kBGRA_8888_GrPixelConfig
:
ct
=
kBGRA_8888_SkColorType
;
break
;
case
kSRGBA_8888_GrPixelConfig
:
ct
=
kRGBA_8888_SkColorType
;
break
;
case
kSBGRA_8888_GrPixelConfig
:
ct
=
kBGRA_8888_SkColorType
;
break
;
case
kRGBA_half_GrPixelConfig
:
ct
=
kRGBA_F16_SkColorType
;
break
;
default
:
return
false
;
}
if
(
ctOut
)
{
*
ctOut
=
ct
;
}
return
true
;
}
GrPixelConfig
GrRenderableConfigForColorSpace
(
const
SkColorSpace
*
colorSpace
)
{
if
(
!
colorSpace
)
{
return
kRGBA_8888_GrPixelConfig
;
}
else
if
(
colorSpace
-
>
gammaIsLinear
(
)
)
{
return
kRGBA_half_GrPixelConfig
;
}
else
if
(
colorSpace
-
>
gammaCloseToSRGB
(
)
)
{
return
kSRGBA_8888_GrPixelConfig
;
}
else
{
SkDEBUGFAIL
(
"
No
renderable
config
exists
for
color
space
with
strange
gamma
"
)
;
return
kUnknown_GrPixelConfig
;
}
}
static
inline
bool
blend_requires_shader
(
const
SkBlendMode
mode
)
{
return
SkBlendMode
:
:
kDst
!
=
mode
;
}
static
inline
bool
skpaint_to_grpaint_impl
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
std
:
:
unique_ptr
<
GrFragmentProcessor
>
*
shaderProcessor
SkBlendMode
*
primColorMode
GrPaint
*
grPaint
)
{
grPaint
-
>
setAllowSRGBInputs
(
colorSpaceInfo
.
isGammaCorrect
(
)
)
;
GrColor4f
origColor
=
SkColorToUnpremulGrColor4f
(
skPaint
.
getColor
(
)
colorSpaceInfo
)
;
const
GrFPArgs
fpArgs
(
context
&
viewM
skPaint
.
getFilterQuality
(
)
&
colorSpaceInfo
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
shaderFP
;
if
(
!
primColorMode
|
|
blend_requires_shader
(
*
primColorMode
)
)
{
if
(
shaderProcessor
)
{
shaderFP
=
std
:
:
move
(
*
shaderProcessor
)
;
}
else
if
(
const
auto
*
shader
=
as_SB
(
skPaint
.
getShader
(
)
)
)
{
shaderFP
=
shader
-
>
asFragmentProcessor
(
fpArgs
)
;
if
(
!
shaderFP
)
{
return
false
;
}
}
}
bool
applyColorFilterToPaintColor
=
false
;
if
(
shaderFP
)
{
if
(
primColorMode
)
{
GrColor4f
shaderInput
=
origColor
.
opaque
(
)
;
shaderFP
=
GrFragmentProcessor
:
:
OverrideInput
(
std
:
:
move
(
shaderFP
)
shaderInput
)
;
shaderFP
=
GrXfermodeFragmentProcessor
:
:
MakeFromSrcProcessor
(
std
:
:
move
(
shaderFP
)
*
primColorMode
)
;
if
(
shaderFP
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
shaderFP
)
)
;
}
GrColor
paintAlpha
=
SkColorAlphaToGrColor
(
skPaint
.
getColor
(
)
)
;
if
(
GrColor_WHITE
!
=
paintAlpha
)
{
grPaint
-
>
addColorFragmentProcessor
(
GrConstColorProcessor
:
:
Make
(
GrColor4f
:
:
FromGrColor
(
paintAlpha
)
GrConstColorProcessor
:
:
InputMode
:
:
kModulateRGBA
)
)
;
}
}
else
{
grPaint
-
>
setColor4f
(
origColor
)
;
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
shaderFP
)
)
;
}
}
else
{
if
(
primColorMode
)
{
auto
processor
=
GrConstColorProcessor
:
:
Make
(
origColor
.
opaque
(
)
GrConstColorProcessor
:
:
InputMode
:
:
kIgnore
)
;
processor
=
GrXfermodeFragmentProcessor
:
:
MakeFromSrcProcessor
(
std
:
:
move
(
processor
)
*
primColorMode
)
;
if
(
processor
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
processor
)
)
;
}
grPaint
-
>
setColor4f
(
origColor
.
opaque
(
)
)
;
GrColor
paintAlpha
=
SkColorAlphaToGrColor
(
skPaint
.
getColor
(
)
)
;
if
(
GrColor_WHITE
!
=
paintAlpha
)
{
grPaint
-
>
addColorFragmentProcessor
(
GrConstColorProcessor
:
:
Make
(
GrColor4f
:
:
FromGrColor
(
paintAlpha
)
GrConstColorProcessor
:
:
InputMode
:
:
kModulateRGBA
)
)
;
}
}
else
{
grPaint
-
>
setColor4f
(
origColor
.
premul
(
)
)
;
applyColorFilterToPaintColor
=
true
;
}
}
SkColorFilter
*
colorFilter
=
skPaint
.
getColorFilter
(
)
;
if
(
colorFilter
)
{
if
(
applyColorFilterToPaintColor
)
{
if
(
colorSpaceInfo
.
isGammaCorrect
(
)
)
{
grPaint
-
>
setColor4f
(
GrColor4f
:
:
FromSkColor4f
(
colorFilter
-
>
filterColor4f
(
origColor
.
toSkColor4f
(
)
)
)
.
premul
(
)
)
;
}
else
{
grPaint
-
>
setColor4f
(
SkColorToPremulGrColor4fLegacy
(
colorFilter
-
>
filterColor
(
skPaint
.
getColor
(
)
)
)
)
;
}
}
else
{
auto
cfFP
=
colorFilter
-
>
asFragmentProcessor
(
context
colorSpaceInfo
)
;
if
(
cfFP
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
cfFP
)
)
;
}
else
{
return
false
;
}
}
}
SkMaskFilterBase
*
maskFilter
=
as_MFB
(
skPaint
.
getMaskFilter
(
)
)
;
if
(
maskFilter
)
{
if
(
auto
mfFP
=
maskFilter
-
>
asFragmentProcessor
(
fpArgs
)
)
{
grPaint
-
>
addCoverageFragmentProcessor
(
std
:
:
move
(
mfFP
)
)
;
}
}
SkASSERT
(
!
grPaint
-
>
getXPFactory
(
)
)
;
if
(
!
skPaint
.
isSrcOver
(
)
)
{
grPaint
-
>
setXPFactory
(
SkBlendMode_AsXPFactory
(
skPaint
.
getBlendMode
(
)
)
)
;
}
#
ifndef
SK_IGNORE_GPU_DITHER
SkColorType
ct
=
SkColorType
:
:
kRGB_565_SkColorType
;
GrPixelConfigToColorType
(
colorSpaceInfo
.
config
(
)
&
ct
)
;
if
(
SkPaintPriv
:
:
ShouldDither
(
skPaint
ct
)
&
&
grPaint
-
>
numColorFragmentProcessors
(
)
>
0
&
&
!
colorSpaceInfo
.
isGammaCorrect
(
)
)
{
auto
ditherFP
=
GrDitherEffect
:
:
Make
(
colorSpaceInfo
.
config
(
)
)
;
if
(
ditherFP
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
ditherFP
)
)
;
}
}
#
endif
return
true
;
}
bool
SkPaintToGrPaint
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
colorSpaceInfo
skPaint
viewM
nullptr
nullptr
grPaint
)
;
}
bool
SkPaintToGrPaintReplaceShader
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
skPaint
std
:
:
unique_ptr
<
GrFragmentProcessor
>
shaderFP
GrPaint
*
grPaint
)
{
if
(
!
shaderFP
)
{
return
false
;
}
return
skpaint_to_grpaint_impl
(
context
colorSpaceInfo
skPaint
SkMatrix
:
:
I
(
)
&
shaderFP
nullptr
grPaint
)
;
}
bool
SkPaintToGrPaintNoShader
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
skPaint
GrPaint
*
grPaint
)
{
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
kNullShaderFP
(
nullptr
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
*
kIgnoreShader
=
&
kNullShaderFP
;
return
skpaint_to_grpaint_impl
(
context
colorSpaceInfo
skPaint
SkMatrix
:
:
I
(
)
kIgnoreShader
nullptr
grPaint
)
;
}
bool
SkPaintToGrPaintWithXfermode
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
SkBlendMode
primColorMode
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
colorSpaceInfo
skPaint
viewM
nullptr
&
primColorMode
grPaint
)
;
}
bool
SkPaintToGrPaintWithTexture
(
GrContext
*
context
const
GrColorSpaceInfo
&
colorSpaceInfo
const
SkPaint
&
paint
const
SkMatrix
&
viewM
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
bool
textureIsAlphaOnly
GrPaint
*
grPaint
)
{
std
:
:
unique_ptr
<
GrFragmentProcessor
>
shaderFP
;
if
(
textureIsAlphaOnly
)
{
if
(
const
auto
*
shader
=
as_SB
(
paint
.
getShader
(
)
)
)
{
shaderFP
=
shader
-
>
asFragmentProcessor
(
GrFPArgs
(
context
&
viewM
nullptr
paint
.
getFilterQuality
(
)
&
colorSpaceInfo
)
)
;
if
(
!
shaderFP
)
{
return
false
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fpSeries
[
]
=
{
std
:
:
move
(
shaderFP
)
std
:
:
move
(
fp
)
}
;
shaderFP
=
GrFragmentProcessor
:
:
RunInSeries
(
fpSeries
2
)
;
}
else
{
shaderFP
=
GrFragmentProcessor
:
:
MakeInputPremulAndMulByOutput
(
std
:
:
move
(
fp
)
)
;
}
}
else
{
shaderFP
=
GrFragmentProcessor
:
:
MulChildByInputAlpha
(
std
:
:
move
(
fp
)
)
;
}
return
SkPaintToGrPaintReplaceShader
(
context
colorSpaceInfo
paint
std
:
:
move
(
shaderFP
)
grPaint
)
;
}
GrSamplerState
:
:
Filter
GrSkFilterQualityToGrFilterMode
(
SkFilterQuality
paintFilterQuality
const
SkMatrix
&
viewM
const
SkMatrix
&
localM
bool
sharpenMipmappedTextures
bool
*
doBicubic
)
{
*
doBicubic
=
false
;
GrSamplerState
:
:
Filter
textureFilterMode
;
switch
(
paintFilterQuality
)
{
case
kNone_SkFilterQuality
:
textureFilterMode
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
kLow_SkFilterQuality
:
textureFilterMode
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
case
kMedium_SkFilterQuality
:
{
SkMatrix
matrix
;
matrix
.
setConcat
(
viewM
localM
)
;
SkScalar
mipScale
=
sharpenMipmappedTextures
?
SK_ScalarRoot2Over2
:
SK_Scalar1
;
if
(
matrix
.
getMinScale
(
)
<
mipScale
)
{
textureFilterMode
=
GrSamplerState
:
:
Filter
:
:
kMipMap
;
}
else
{
textureFilterMode
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
}
break
;
}
case
kHigh_SkFilterQuality
:
{
SkMatrix
matrix
;
matrix
.
setConcat
(
viewM
localM
)
;
*
doBicubic
=
GrBicubicEffect
:
:
ShouldUseBicubic
(
matrix
&
textureFilterMode
)
;
break
;
}
default
:
textureFilterMode
=
GrSamplerState
:
:
Filter
:
:
kMipMap
;
break
;
}
return
textureFilterMode
;
}
