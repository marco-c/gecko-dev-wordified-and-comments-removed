#
include
"
SkGr
.
h
"
#
include
"
GrBitmapTextureMaker
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkBlendModePriv
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
"
SkColorFilter
.
h
"
#
include
"
SkConvertPixels
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkImageInfoPriv
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkPM4fPriv
.
h
"
#
include
"
SkPixelRef
.
h
"
#
include
"
SkResourceCache
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrConstColorProcessor
.
h
"
#
include
"
effects
/
GrDitherEffect
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrXfermodeFragmentProcessor
.
h
"
#
ifndef
SK_IGNORE_ETC1_SUPPORT
#
include
"
etc1
.
h
"
#
endif
GrSurfaceDesc
GrImageInfoToSurfaceDesc
(
const
SkImageInfo
&
info
const
GrCaps
&
caps
)
{
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kNone_GrSurfaceFlags
;
desc
.
fWidth
=
info
.
width
(
)
;
desc
.
fHeight
=
info
.
height
(
)
;
desc
.
fConfig
=
SkImageInfo2GrPixelConfig
(
info
caps
)
;
desc
.
fSampleCnt
=
0
;
return
desc
;
}
void
GrMakeKeyFromImageID
(
GrUniqueKey
*
key
uint32_t
imageID
const
SkIRect
&
imageBounds
)
{
SkASSERT
(
key
)
;
SkASSERT
(
imageID
)
;
SkASSERT
(
!
imageBounds
.
isEmpty
(
)
)
;
static
const
GrUniqueKey
:
:
Domain
kImageIDDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
key
kImageIDDomain
5
)
;
builder
[
0
]
=
imageID
;
builder
[
1
]
=
imageBounds
.
fLeft
;
builder
[
2
]
=
imageBounds
.
fTop
;
builder
[
3
]
=
imageBounds
.
fRight
;
builder
[
4
]
=
imageBounds
.
fBottom
;
}
GrPixelConfig
GrIsCompressedTextureDataSupported
(
GrContext
*
ctx
SkData
*
data
int
expectedW
int
expectedH
const
void
*
*
outStartOfDataToUpload
)
{
*
outStartOfDataToUpload
=
nullptr
;
#
ifndef
SK_IGNORE_ETC1_SUPPORT
if
(
!
ctx
-
>
caps
(
)
-
>
isConfigTexturable
(
kETC1_GrPixelConfig
)
)
{
return
kUnknown_GrPixelConfig
;
}
const
uint8_t
*
bytes
=
data
-
>
bytes
(
)
;
if
(
data
-
>
size
(
)
>
ETC_PKM_HEADER_SIZE
&
&
etc1_pkm_is_valid
(
bytes
)
)
{
if
(
etc1_pkm_get_width
(
bytes
)
!
=
(
unsigned
)
expectedW
|
|
etc1_pkm_get_height
(
bytes
)
!
=
(
unsigned
)
expectedH
)
{
return
kUnknown_GrPixelConfig
;
}
*
outStartOfDataToUpload
=
bytes
+
ETC_PKM_HEADER_SIZE
;
return
kETC1_GrPixelConfig
;
}
#
endif
return
kUnknown_GrPixelConfig
;
}
sk_sp
<
GrTextureProxy
>
GrUploadBitmapToTextureProxy
(
GrResourceProvider
*
resourceProvider
const
SkBitmap
&
bitmap
)
{
SkAutoLockPixels
alp
(
bitmap
)
;
if
(
!
bitmap
.
readyToDraw
(
)
)
{
return
nullptr
;
}
SkPixmap
pixmap
;
if
(
!
bitmap
.
peekPixels
(
&
pixmap
)
)
{
return
nullptr
;
}
return
GrUploadPixmapToTextureProxy
(
resourceProvider
pixmap
SkBudgeted
:
:
kYes
)
;
}
static
const
SkPixmap
*
compute_desc
(
const
GrCaps
&
caps
const
SkPixmap
&
pixmap
GrSurfaceDesc
*
desc
SkBitmap
*
tmpBitmap
SkPixmap
*
tmpPixmap
)
{
const
SkPixmap
*
pmap
=
&
pixmap
;
*
desc
=
GrImageInfoToSurfaceDesc
(
pixmap
.
info
(
)
caps
)
;
SkColorSpace
*
colorSpace
=
pixmap
.
colorSpace
(
)
;
if
(
caps
.
srgbSupport
(
)
&
&
colorSpace
&
&
colorSpace
-
>
gammaCloseToSRGB
(
)
&
&
!
GrPixelConfigIsSRGB
(
desc
-
>
fConfig
)
)
{
SkImageInfo
linSrcInfo
=
SkImageInfo
:
:
Make
(
pixmap
.
width
(
)
pixmap
.
height
(
)
pixmap
.
colorType
(
)
pixmap
.
alphaType
(
)
)
;
SkPixmap
linSrcPixmap
(
linSrcInfo
pixmap
.
addr
(
)
pixmap
.
rowBytes
(
)
pixmap
.
ctable
(
)
)
;
SkImageInfo
dstInfo
=
SkImageInfo
:
:
Make
(
pixmap
.
width
(
)
pixmap
.
height
(
)
kN32_SkColorType
kPremul_SkAlphaType
pixmap
.
info
(
)
.
refColorSpace
(
)
)
;
tmpBitmap
-
>
allocPixels
(
dstInfo
)
;
SkImageInfo
linDstInfo
=
SkImageInfo
:
:
MakeN32Premul
(
pixmap
.
width
(
)
pixmap
.
height
(
)
)
;
if
(
!
linSrcPixmap
.
readPixels
(
linDstInfo
tmpBitmap
-
>
getPixels
(
)
tmpBitmap
-
>
rowBytes
(
)
)
)
{
return
nullptr
;
}
if
(
!
tmpBitmap
-
>
peekPixels
(
tmpPixmap
)
)
{
return
nullptr
;
}
pmap
=
tmpPixmap
;
*
desc
=
GrImageInfoToSurfaceDesc
(
pmap
-
>
info
(
)
caps
)
;
}
else
if
(
kIndex_8_SkColorType
=
=
pixmap
.
colorType
(
)
)
{
SkImageInfo
info
=
SkImageInfo
:
:
MakeN32Premul
(
pixmap
.
width
(
)
pixmap
.
height
(
)
)
;
tmpBitmap
-
>
allocPixels
(
info
)
;
if
(
!
pixmap
.
readPixels
(
info
tmpBitmap
-
>
getPixels
(
)
tmpBitmap
-
>
rowBytes
(
)
)
)
{
return
nullptr
;
}
if
(
!
tmpBitmap
-
>
peekPixels
(
tmpPixmap
)
)
{
return
nullptr
;
}
pmap
=
tmpPixmap
;
*
desc
=
GrImageInfoToSurfaceDesc
(
pmap
-
>
info
(
)
caps
)
;
}
return
pmap
;
}
sk_sp
<
GrTextureProxy
>
GrUploadPixmapToTextureProxyNoCheck
(
GrResourceProvider
*
resourceProvider
const
SkPixmap
&
pixmap
SkBudgeted
budgeted
)
{
SkBitmap
tmpBitmap
;
SkPixmap
tmpPixmap
;
GrSurfaceDesc
desc
;
if
(
const
SkPixmap
*
pmap
=
compute_desc
(
*
resourceProvider
-
>
caps
(
)
pixmap
&
desc
&
tmpBitmap
&
tmpPixmap
)
)
{
return
GrSurfaceProxy
:
:
MakeDeferred
(
resourceProvider
desc
budgeted
pmap
-
>
addr
(
)
pmap
-
>
rowBytes
(
)
)
;
}
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
GrUploadPixmapToTextureProxy
(
GrResourceProvider
*
resourceProvider
const
SkPixmap
&
pixmap
SkBudgeted
budgeted
)
{
if
(
!
SkImageInfoIsValid
(
pixmap
.
info
(
)
)
)
{
return
nullptr
;
}
return
GrUploadPixmapToTextureProxyNoCheck
(
resourceProvider
pixmap
budgeted
)
;
}
void
GrInstallBitmapUniqueKeyInvalidator
(
const
GrUniqueKey
&
key
SkPixelRef
*
pixelRef
)
{
class
Invalidator
:
public
SkPixelRef
:
:
GenIDChangeListener
{
public
:
explicit
Invalidator
(
const
GrUniqueKey
&
key
)
:
fMsg
(
key
)
{
}
private
:
GrUniqueKeyInvalidatedMessage
fMsg
;
void
onChange
(
)
override
{
SkMessageBus
<
GrUniqueKeyInvalidatedMessage
>
:
:
Post
(
fMsg
)
;
}
}
;
pixelRef
-
>
addGenIDChangeListener
(
new
Invalidator
(
key
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrGenerateMipMapsAndUploadToTextureProxy
(
GrContext
*
ctx
const
SkBitmap
&
bitmap
SkColorSpace
*
dstColorSpace
)
{
SkDestinationSurfaceColorMode
colorMode
=
dstColorSpace
?
SkDestinationSurfaceColorMode
:
:
kGammaAndColorSpaceAware
:
SkDestinationSurfaceColorMode
:
:
kLegacy
;
if
(
!
SkImageInfoIsValid
(
bitmap
.
info
(
)
)
)
{
return
nullptr
;
}
GrSurfaceDesc
desc
=
GrImageInfoToSurfaceDesc
(
bitmap
.
info
(
)
*
ctx
-
>
caps
(
)
)
;
SkAutoPixmapUnlock
srcUnlocker
;
if
(
!
bitmap
.
requestLock
(
&
srcUnlocker
)
)
{
return
nullptr
;
}
const
SkPixmap
&
pixmap
=
srcUnlocker
.
pixmap
(
)
;
if
(
nullptr
=
=
pixmap
.
addr
(
)
)
{
sk_throw
(
)
;
}
std
:
:
unique_ptr
<
SkMipMap
>
mipmaps
(
SkMipMap
:
:
Build
(
pixmap
colorMode
nullptr
)
)
;
if
(
!
mipmaps
)
{
return
nullptr
;
}
const
int
mipLevelCount
=
mipmaps
-
>
countLevels
(
)
+
1
;
if
(
mipLevelCount
<
1
)
{
return
nullptr
;
}
const
bool
isMipMapped
=
mipLevelCount
>
1
;
desc
.
fIsMipMapped
=
isMipMapped
;
std
:
:
unique_ptr
<
GrMipLevel
[
]
>
texels
(
new
GrMipLevel
[
mipLevelCount
]
)
;
texels
[
0
]
.
fPixels
=
pixmap
.
addr
(
)
;
texels
[
0
]
.
fRowBytes
=
pixmap
.
rowBytes
(
)
;
for
(
int
i
=
1
;
i
<
mipLevelCount
;
+
+
i
)
{
SkMipMap
:
:
Level
generatedMipLevel
;
mipmaps
-
>
getLevel
(
i
-
1
&
generatedMipLevel
)
;
texels
[
i
]
.
fPixels
=
generatedMipLevel
.
fPixmap
.
addr
(
)
;
texels
[
i
]
.
fRowBytes
=
generatedMipLevel
.
fPixmap
.
rowBytes
(
)
;
}
return
ctx
-
>
resourceProvider
(
)
-
>
createMipMappedTexture
(
desc
SkBudgeted
:
:
kYes
texels
.
get
(
)
mipLevelCount
0
colorMode
)
;
}
sk_sp
<
GrTextureProxy
>
GrUploadMipMapToTextureProxy
(
GrContext
*
ctx
const
SkImageInfo
&
info
const
GrMipLevel
*
texels
int
mipLevelCount
SkDestinationSurfaceColorMode
colorMode
)
{
if
(
!
SkImageInfoIsValid
(
info
)
)
{
return
nullptr
;
}
const
GrCaps
*
caps
=
ctx
-
>
caps
(
)
;
return
ctx
-
>
resourceProvider
(
)
-
>
createMipMappedTexture
(
GrImageInfoToSurfaceDesc
(
info
*
caps
)
SkBudgeted
:
:
kYes
texels
mipLevelCount
0
colorMode
)
;
}
sk_sp
<
GrTextureProxy
>
GrRefCachedBitmapTextureProxy
(
GrContext
*
ctx
const
SkBitmap
&
bitmap
const
GrSamplerParams
&
params
SkScalar
scaleAdjust
[
2
]
)
{
return
GrBitmapTextureMaker
(
ctx
bitmap
)
.
refTextureProxyForParams
(
params
nullptr
nullptr
scaleAdjust
)
;
}
sk_sp
<
GrTextureProxy
>
GrMakeCachedBitmapProxy
(
GrResourceProvider
*
resourceProvider
const
SkBitmap
&
bitmap
)
{
GrUniqueKey
originalKey
;
if
(
!
bitmap
.
isVolatile
(
)
)
{
SkIPoint
origin
=
bitmap
.
pixelRefOrigin
(
)
;
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
origin
.
fX
origin
.
fY
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
GrMakeKeyFromImageID
(
&
originalKey
bitmap
.
pixelRef
(
)
-
>
getGenerationID
(
)
subset
)
;
}
sk_sp
<
GrTextureProxy
>
proxy
;
if
(
originalKey
.
isValid
(
)
)
{
proxy
=
resourceProvider
-
>
findProxyByUniqueKey
(
originalKey
)
;
}
if
(
!
proxy
)
{
proxy
=
GrUploadBitmapToTextureProxy
(
resourceProvider
bitmap
)
;
if
(
proxy
&
&
originalKey
.
isValid
(
)
)
{
resourceProvider
-
>
assignUniqueKeyToProxy
(
originalKey
proxy
.
get
(
)
)
;
GrInstallBitmapUniqueKeyInvalidator
(
originalKey
bitmap
.
pixelRef
(
)
)
;
}
}
return
proxy
;
}
GrColor4f
SkColorToPremulGrColor4f
(
SkColor
c
SkColorSpace
*
dstColorSpace
)
{
return
SkColorToUnpremulGrColor4f
(
c
dstColorSpace
)
.
premul
(
)
;
}
GrColor4f
SkColorToUnpremulGrColor4f
(
SkColor
c
SkColorSpace
*
dstColorSpace
)
{
if
(
dstColorSpace
)
{
auto
srgbColorSpace
=
SkColorSpace
:
:
MakeSRGB
(
)
;
auto
gamutXform
=
GrColorSpaceXform
:
:
Make
(
srgbColorSpace
.
get
(
)
dstColorSpace
)
;
return
SkColorToUnpremulGrColor4f
(
c
dstColorSpace
gamutXform
.
get
(
)
)
;
}
else
{
return
SkColorToUnpremulGrColor4f
(
c
nullptr
nullptr
)
;
}
}
GrColor4f
SkColorToPremulGrColor4f
(
SkColor
c
SkColorSpace
*
dstColorSpace
GrColorSpaceXform
*
gamutXform
)
{
return
SkColorToUnpremulGrColor4f
(
c
dstColorSpace
gamutXform
)
.
premul
(
)
;
}
GrColor4f
SkColorToUnpremulGrColor4f
(
SkColor
c
SkColorSpace
*
dstColorSpace
GrColorSpaceXform
*
gamutXform
)
{
SkASSERT
(
dstColorSpace
|
|
!
gamutXform
)
;
GrColor4f
color
;
if
(
dstColorSpace
)
{
color
=
GrColor4f
:
:
FromSkColor4f
(
SkColor4f
:
:
FromColor
(
c
)
)
;
}
else
{
color
=
GrColor4f
:
:
FromGrColor
(
SkColorToUnpremulGrColor
(
c
)
)
;
}
if
(
gamutXform
)
{
color
=
gamutXform
-
>
apply
(
color
)
;
}
return
color
;
}
GrPixelConfig
SkImageInfo2GrPixelConfig
(
const
SkImageInfo
&
info
const
GrCaps
&
caps
)
{
SkColorSpace
*
cs
=
info
.
colorSpace
(
)
;
switch
(
info
.
colorType
(
)
)
{
case
kUnknown_SkColorType
:
return
kUnknown_GrPixelConfig
;
case
kAlpha_8_SkColorType
:
return
kAlpha_8_GrPixelConfig
;
case
kRGB_565_SkColorType
:
return
kRGB_565_GrPixelConfig
;
case
kARGB_4444_SkColorType
:
return
kRGBA_4444_GrPixelConfig
;
case
kRGBA_8888_SkColorType
:
return
(
caps
.
srgbSupport
(
)
&
&
cs
&
&
cs
-
>
gammaCloseToSRGB
(
)
)
?
kSRGBA_8888_GrPixelConfig
:
kRGBA_8888_GrPixelConfig
;
case
kBGRA_8888_SkColorType
:
return
(
caps
.
srgbSupport
(
)
&
&
cs
&
&
cs
-
>
gammaCloseToSRGB
(
)
)
?
kSBGRA_8888_GrPixelConfig
:
kBGRA_8888_GrPixelConfig
;
case
kIndex_8_SkColorType
:
return
kSkia8888_GrPixelConfig
;
case
kGray_8_SkColorType
:
return
kGray_8_GrPixelConfig
;
case
kRGBA_F16_SkColorType
:
return
kRGBA_half_GrPixelConfig
;
}
SkASSERT
(
0
)
;
return
kUnknown_GrPixelConfig
;
}
bool
GrPixelConfigToColorType
(
GrPixelConfig
config
SkColorType
*
ctOut
)
{
SkColorType
ct
;
switch
(
config
)
{
case
kAlpha_8_GrPixelConfig
:
ct
=
kAlpha_8_SkColorType
;
break
;
case
kGray_8_GrPixelConfig
:
ct
=
kGray_8_SkColorType
;
break
;
case
kRGB_565_GrPixelConfig
:
ct
=
kRGB_565_SkColorType
;
break
;
case
kRGBA_4444_GrPixelConfig
:
ct
=
kARGB_4444_SkColorType
;
break
;
case
kRGBA_8888_GrPixelConfig
:
ct
=
kRGBA_8888_SkColorType
;
break
;
case
kBGRA_8888_GrPixelConfig
:
ct
=
kBGRA_8888_SkColorType
;
break
;
case
kSRGBA_8888_GrPixelConfig
:
ct
=
kRGBA_8888_SkColorType
;
break
;
case
kSBGRA_8888_GrPixelConfig
:
ct
=
kBGRA_8888_SkColorType
;
break
;
case
kRGBA_half_GrPixelConfig
:
ct
=
kRGBA_F16_SkColorType
;
break
;
default
:
return
false
;
}
if
(
ctOut
)
{
*
ctOut
=
ct
;
}
return
true
;
}
GrPixelConfig
GrRenderableConfigForColorSpace
(
const
SkColorSpace
*
colorSpace
)
{
if
(
!
colorSpace
)
{
return
kRGBA_8888_GrPixelConfig
;
}
else
if
(
colorSpace
-
>
gammaIsLinear
(
)
)
{
return
kRGBA_half_GrPixelConfig
;
}
else
if
(
colorSpace
-
>
gammaCloseToSRGB
(
)
)
{
return
kSRGBA_8888_GrPixelConfig
;
}
else
{
SkDEBUGFAIL
(
"
No
renderable
config
exists
for
color
space
with
strange
gamma
"
)
;
return
kUnknown_GrPixelConfig
;
}
}
static
inline
bool
blend_requires_shader
(
const
SkBlendMode
mode
bool
primitiveIsSrc
)
{
if
(
primitiveIsSrc
)
{
return
SkBlendMode
:
:
kSrc
!
=
mode
;
}
else
{
return
SkBlendMode
:
:
kDst
!
=
mode
;
}
}
static
inline
bool
skpaint_to_grpaint_impl
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
sk_sp
<
GrFragmentProcessor
>
*
shaderProcessor
SkBlendMode
*
primColorMode
bool
primitiveIsSrc
GrPaint
*
grPaint
)
{
grPaint
-
>
setAllowSRGBInputs
(
rtc
-
>
isGammaCorrect
(
)
)
;
GrColor4f
origColor
=
SkColorToUnpremulGrColor4f
(
skPaint
.
getColor
(
)
rtc
-
>
getColorSpace
(
)
rtc
-
>
getColorXformFromSRGB
(
)
)
;
sk_sp
<
GrFragmentProcessor
>
shaderFP
;
if
(
!
primColorMode
|
|
blend_requires_shader
(
*
primColorMode
primitiveIsSrc
)
)
{
if
(
shaderProcessor
)
{
shaderFP
=
*
shaderProcessor
;
}
else
if
(
const
SkShader
*
shader
=
skPaint
.
getShader
(
)
)
{
shaderFP
=
shader
-
>
asFragmentProcessor
(
SkShader
:
:
AsFPArgs
(
context
&
viewM
nullptr
skPaint
.
getFilterQuality
(
)
rtc
-
>
getColorSpace
(
)
)
)
;
if
(
!
shaderFP
)
{
return
false
;
}
}
}
bool
applyColorFilterToPaintColor
=
false
;
if
(
shaderFP
)
{
if
(
primColorMode
)
{
GrColor4f
shaderInput
=
origColor
.
opaque
(
)
;
shaderFP
=
GrFragmentProcessor
:
:
OverrideInput
(
shaderFP
shaderInput
)
;
if
(
primitiveIsSrc
)
{
shaderFP
=
GrXfermodeFragmentProcessor
:
:
MakeFromDstProcessor
(
std
:
:
move
(
shaderFP
)
*
primColorMode
)
;
}
else
{
shaderFP
=
GrXfermodeFragmentProcessor
:
:
MakeFromSrcProcessor
(
std
:
:
move
(
shaderFP
)
*
primColorMode
)
;
}
if
(
shaderFP
)
{
grPaint
-
>
addColorFragmentProcessor
(
shaderFP
)
;
}
GrColor
paintAlpha
=
SkColorAlphaToGrColor
(
skPaint
.
getColor
(
)
)
;
if
(
GrColor_WHITE
!
=
paintAlpha
)
{
grPaint
-
>
addColorFragmentProcessor
(
GrConstColorProcessor
:
:
Make
(
GrColor4f
:
:
FromGrColor
(
paintAlpha
)
GrConstColorProcessor
:
:
kModulateRGBA_InputMode
)
)
;
}
}
else
{
grPaint
-
>
setColor4f
(
origColor
)
;
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
shaderFP
)
)
;
}
}
else
{
if
(
primColorMode
)
{
sk_sp
<
GrFragmentProcessor
>
processor
(
GrConstColorProcessor
:
:
Make
(
origColor
.
opaque
(
)
GrConstColorProcessor
:
:
kIgnore_InputMode
)
)
;
if
(
primitiveIsSrc
)
{
processor
=
GrXfermodeFragmentProcessor
:
:
MakeFromDstProcessor
(
std
:
:
move
(
processor
)
*
primColorMode
)
;
}
else
{
processor
=
GrXfermodeFragmentProcessor
:
:
MakeFromSrcProcessor
(
std
:
:
move
(
processor
)
*
primColorMode
)
;
}
if
(
processor
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
processor
)
)
;
}
grPaint
-
>
setColor4f
(
origColor
.
opaque
(
)
)
;
GrColor
paintAlpha
=
SkColorAlphaToGrColor
(
skPaint
.
getColor
(
)
)
;
if
(
GrColor_WHITE
!
=
paintAlpha
)
{
grPaint
-
>
addColorFragmentProcessor
(
GrConstColorProcessor
:
:
Make
(
GrColor4f
:
:
FromGrColor
(
paintAlpha
)
GrConstColorProcessor
:
:
kModulateRGBA_InputMode
)
)
;
}
}
else
{
grPaint
-
>
setColor4f
(
origColor
.
premul
(
)
)
;
applyColorFilterToPaintColor
=
true
;
}
}
SkColorFilter
*
colorFilter
=
skPaint
.
getColorFilter
(
)
;
if
(
colorFilter
)
{
if
(
applyColorFilterToPaintColor
)
{
if
(
rtc
-
>
isGammaCorrect
(
)
)
{
grPaint
-
>
setColor4f
(
GrColor4f
:
:
FromSkColor4f
(
colorFilter
-
>
filterColor4f
(
origColor
.
toSkColor4f
(
)
)
)
.
premul
(
)
)
;
}
else
{
grPaint
-
>
setColor4f
(
SkColorToPremulGrColor4f
(
colorFilter
-
>
filterColor
(
skPaint
.
getColor
(
)
)
nullptr
nullptr
)
)
;
}
}
else
{
sk_sp
<
GrFragmentProcessor
>
cfFP
(
colorFilter
-
>
asFragmentProcessor
(
context
rtc
-
>
getColorSpace
(
)
)
)
;
if
(
cfFP
)
{
grPaint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
cfFP
)
)
;
}
else
{
return
false
;
}
}
}
SkMaskFilter
*
maskFilter
=
skPaint
.
getMaskFilter
(
)
;
if
(
maskFilter
)
{
GrFragmentProcessor
*
mfFP
;
if
(
maskFilter
-
>
asFragmentProcessor
(
&
mfFP
nullptr
viewM
)
)
{
grPaint
-
>
addCoverageFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
(
mfFP
)
)
;
}
}
SkASSERT
(
!
grPaint
-
>
getXPFactory
(
)
)
;
if
(
!
skPaint
.
isSrcOver
(
)
)
{
grPaint
-
>
setXPFactory
(
SkBlendMode_AsXPFactory
(
skPaint
.
getBlendMode
(
)
)
)
;
}
#
ifndef
SK_IGNORE_GPU_DITHER
if
(
skPaint
.
isDither
(
)
&
&
grPaint
-
>
numColorFragmentProcessors
(
)
>
0
&
&
!
rtc
-
>
isGammaCorrect
(
)
)
{
grPaint
-
>
addColorFragmentProcessor
(
GrDitherEffect
:
:
Make
(
)
)
;
}
#
endif
return
true
;
}
bool
SkPaintToGrPaint
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
rtc
skPaint
viewM
nullptr
nullptr
false
grPaint
)
;
}
bool
SkPaintToGrPaintReplaceShader
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
sk_sp
<
GrFragmentProcessor
>
shaderFP
GrPaint
*
grPaint
)
{
if
(
!
shaderFP
)
{
return
false
;
}
return
skpaint_to_grpaint_impl
(
context
rtc
skPaint
SkMatrix
:
:
I
(
)
&
shaderFP
nullptr
false
grPaint
)
;
}
bool
SkPaintToGrPaintNoShader
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
GrPaint
*
grPaint
)
{
static
sk_sp
<
GrFragmentProcessor
>
kNullShaderFP
(
nullptr
)
;
static
sk_sp
<
GrFragmentProcessor
>
*
kIgnoreShader
=
&
kNullShaderFP
;
return
skpaint_to_grpaint_impl
(
context
rtc
skPaint
SkMatrix
:
:
I
(
)
kIgnoreShader
nullptr
false
grPaint
)
;
}
bool
SkPaintToGrPaintWithXfermode
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
const
SkMatrix
&
viewM
SkBlendMode
primColorMode
bool
primitiveIsSrc
GrPaint
*
grPaint
)
{
return
skpaint_to_grpaint_impl
(
context
rtc
skPaint
viewM
nullptr
&
primColorMode
primitiveIsSrc
grPaint
)
;
}
bool
SkPaintToGrPaintWithTexture
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
paint
const
SkMatrix
&
viewM
sk_sp
<
GrFragmentProcessor
>
fp
bool
textureIsAlphaOnly
GrPaint
*
grPaint
)
{
sk_sp
<
GrFragmentProcessor
>
shaderFP
;
if
(
textureIsAlphaOnly
)
{
if
(
const
SkShader
*
shader
=
paint
.
getShader
(
)
)
{
shaderFP
=
shader
-
>
asFragmentProcessor
(
SkShader
:
:
AsFPArgs
(
context
&
viewM
nullptr
paint
.
getFilterQuality
(
)
rtc
-
>
getColorSpace
(
)
)
)
;
if
(
!
shaderFP
)
{
return
false
;
}
sk_sp
<
GrFragmentProcessor
>
fpSeries
[
]
=
{
std
:
:
move
(
shaderFP
)
std
:
:
move
(
fp
)
}
;
shaderFP
=
GrFragmentProcessor
:
:
RunInSeries
(
fpSeries
2
)
;
}
else
{
shaderFP
=
GrFragmentProcessor
:
:
MakeInputPremulAndMulByOutput
(
fp
)
;
}
}
else
{
shaderFP
=
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
fp
)
;
}
return
SkPaintToGrPaintReplaceShader
(
context
rtc
paint
std
:
:
move
(
shaderFP
)
grPaint
)
;
}
GrSamplerParams
:
:
FilterMode
GrSkFilterQualityToGrFilterMode
(
SkFilterQuality
paintFilterQuality
const
SkMatrix
&
viewM
const
SkMatrix
&
localM
bool
*
doBicubic
)
{
*
doBicubic
=
false
;
GrSamplerParams
:
:
FilterMode
textureFilterMode
;
switch
(
paintFilterQuality
)
{
case
kNone_SkFilterQuality
:
textureFilterMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
break
;
case
kLow_SkFilterQuality
:
textureFilterMode
=
GrSamplerParams
:
:
kBilerp_FilterMode
;
break
;
case
kMedium_SkFilterQuality
:
{
SkMatrix
matrix
;
matrix
.
setConcat
(
viewM
localM
)
;
if
(
matrix
.
getMinScale
(
)
<
SK_Scalar1
)
{
textureFilterMode
=
GrSamplerParams
:
:
kMipMap_FilterMode
;
}
else
{
textureFilterMode
=
GrSamplerParams
:
:
kBilerp_FilterMode
;
}
break
;
}
case
kHigh_SkFilterQuality
:
{
SkMatrix
matrix
;
matrix
.
setConcat
(
viewM
localM
)
;
*
doBicubic
=
GrBicubicEffect
:
:
ShouldUseBicubic
(
matrix
&
textureFilterMode
)
;
break
;
}
default
:
textureFilterMode
=
GrSamplerParams
:
:
kMipMap_FilterMode
;
break
;
}
return
textureFilterMode
;
}
