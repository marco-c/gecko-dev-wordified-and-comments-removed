#
include
"
src
/
gpu
/
GrTextureResolveRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrGpu
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
GrResourceAllocator
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
GrTextureResolveRenderTask
:
:
~
GrTextureResolveRenderTask
(
)
{
for
(
const
auto
&
resolve
:
fResolves
)
{
resolve
.
fProxy
-
>
setLastRenderTask
(
nullptr
)
;
}
}
void
GrTextureResolveRenderTask
:
:
addProxy
(
sk_sp
<
GrSurfaceProxy
>
proxyHolder
GrSurfaceProxy
:
:
ResolveFlags
flags
const
GrCaps
&
caps
)
{
fResolves
.
emplace_back
(
std
:
:
move
(
proxyHolder
)
flags
)
;
GrSurfaceProxy
*
proxy
=
fResolves
.
back
(
)
.
fProxy
.
get
(
)
;
SkASSERT
(
!
proxy
-
>
getLastRenderTask
(
)
|
|
proxy
-
>
getLastRenderTask
(
)
-
>
isClosed
(
)
)
;
SkASSERT
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kNone
!
=
flags
)
;
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMSAA
&
flags
)
{
GrRenderTargetProxy
*
renderTargetProxy
=
proxy
-
>
asRenderTargetProxy
(
)
;
SkASSERT
(
renderTargetProxy
)
;
SkASSERT
(
renderTargetProxy
-
>
isMSAADirty
(
)
)
;
fResolves
.
back
(
)
.
fMSAAResolveRect
=
renderTargetProxy
-
>
msaaDirtyRect
(
)
;
renderTargetProxy
-
>
markMSAAResolved
(
)
;
}
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMipMaps
&
flags
)
{
GrTextureProxy
*
textureProxy
=
proxy
-
>
asTextureProxy
(
)
;
SkASSERT
(
GrMipMapped
:
:
kYes
=
=
textureProxy
-
>
mipMapped
(
)
)
;
SkASSERT
(
textureProxy
-
>
mipMapsAreDirty
(
)
)
;
textureProxy
-
>
markMipMapsClean
(
)
;
}
this
-
>
addDependency
(
proxy
GrMipMapped
:
:
kNo
GrTextureResolveManager
(
nullptr
)
caps
)
;
proxy
-
>
setLastRenderTask
(
this
)
;
}
void
GrTextureResolveRenderTask
:
:
gatherProxyIntervals
(
GrResourceAllocator
*
alloc
)
const
{
auto
fakeOp
=
alloc
-
>
curOp
(
)
;
for
(
const
auto
&
resolve
:
fResolves
)
{
alloc
-
>
addInterval
(
resolve
.
fProxy
.
get
(
)
fakeOp
fakeOp
GrResourceAllocator
:
:
ActualUse
:
:
kYes
)
;
}
alloc
-
>
incOps
(
)
;
}
bool
GrTextureResolveRenderTask
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
for
(
const
auto
&
resolve
:
fResolves
)
{
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMSAA
&
resolve
.
fFlags
)
{
if
(
GrRenderTarget
*
renderTarget
=
resolve
.
fProxy
-
>
peekRenderTarget
(
)
)
{
flushState
-
>
gpu
(
)
-
>
resolveRenderTarget
(
renderTarget
resolve
.
fMSAAResolveRect
resolve
.
fProxy
-
>
origin
(
)
GrGpu
:
:
ForExternalIO
:
:
kNo
)
;
}
}
}
for
(
const
auto
&
resolve
:
fResolves
)
{
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMipMaps
&
resolve
.
fFlags
)
{
GrTexture
*
texture
=
resolve
.
fProxy
-
>
peekTexture
(
)
;
if
(
texture
&
&
texture
-
>
texturePriv
(
)
.
mipMapsAreDirty
(
)
)
{
flushState
-
>
gpu
(
)
-
>
regenerateMipMapLevels
(
texture
)
;
SkASSERT
(
!
texture
-
>
texturePriv
(
)
.
mipMapsAreDirty
(
)
)
;
}
}
}
return
true
;
}
#
ifdef
SK_DEBUG
void
GrTextureResolveRenderTask
:
:
visitProxies_debugOnly
(
const
VisitSurfaceProxyFunc
&
fn
)
const
{
for
(
const
auto
&
resolve
:
fResolves
)
{
fn
(
resolve
.
fProxy
.
get
(
)
GrMipMapped
:
:
kNo
)
;
}
}
#
endif
