#
ifndef
GrDrawingManager_DEFINED
#
define
GrDrawingManager_DEFINED
#
include
<
set
>
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
src
/
gpu
/
GrBufferAllocPool
.
h
"
#
include
"
src
/
gpu
/
GrDeferredUpload
.
h
"
#
include
"
src
/
gpu
/
GrPathRenderer
.
h
"
#
include
"
src
/
gpu
/
GrPathRendererChain
.
h
"
#
include
"
src
/
gpu
/
GrResourceCache
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextContext
.
h
"
class
GrCoverageCountingPathRenderer
;
class
GrOnFlushCallbackObject
;
class
GrOpFlushState
;
class
GrOpsTask
;
class
GrRecordingContext
;
class
GrRenderTargetContext
;
class
GrRenderTargetProxy
;
class
GrSoftwarePathRenderer
;
class
GrTextureContext
;
class
GrTextureResolveRenderTask
;
class
SkDeferredDisplayList
;
class
GrDrawingManager
{
public
:
~
GrDrawingManager
(
)
;
void
freeGpuResources
(
)
;
std
:
:
unique_ptr
<
GrRenderTargetContext
>
makeRenderTargetContext
(
sk_sp
<
GrSurfaceProxy
>
GrColorType
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
bool
managedOpsTask
=
true
)
;
std
:
:
unique_ptr
<
GrTextureContext
>
makeTextureContext
(
sk_sp
<
GrSurfaceProxy
>
GrColorType
SkAlphaType
sk_sp
<
SkColorSpace
>
)
;
sk_sp
<
GrOpsTask
>
newOpsTask
(
sk_sp
<
GrRenderTargetProxy
>
bool
managedOpsTask
)
;
GrTextureResolveRenderTask
*
newTextureResolveRenderTask
(
const
GrCaps
&
)
;
void
newWaitRenderTask
(
sk_sp
<
GrSurfaceProxy
>
proxy
std
:
:
unique_ptr
<
sk_sp
<
GrSemaphore
>
[
]
>
int
numSemaphores
)
;
void
newTransferFromRenderTask
(
sk_sp
<
GrSurfaceProxy
>
srcProxy
const
SkIRect
&
srcRect
GrColorType
surfaceColorType
GrColorType
dstColorType
sk_sp
<
GrGpuBuffer
>
dstBuffer
size_t
dstOffset
)
;
bool
newCopyRenderTask
(
sk_sp
<
GrSurfaceProxy
>
srcProxy
const
SkIRect
&
srcRect
sk_sp
<
GrSurfaceProxy
>
dstProxy
const
SkIPoint
&
dstPoint
)
;
GrRecordingContext
*
getContext
(
)
{
return
fContext
;
}
GrTextContext
*
getTextContext
(
)
;
GrPathRenderer
*
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
=
nullptr
)
;
GrPathRenderer
*
getSoftwarePathRenderer
(
)
;
GrCoverageCountingPathRenderer
*
getCoverageCountingPathRenderer
(
)
;
void
flushIfNecessary
(
)
;
static
bool
ProgramUnitTest
(
GrContext
*
context
int
maxStages
int
maxLevels
)
;
GrSemaphoresSubmitted
flushSurfaces
(
GrSurfaceProxy
*
proxies
[
]
int
cnt
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
;
GrSemaphoresSubmitted
flushSurface
(
GrSurfaceProxy
*
proxy
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
{
return
this
-
>
flushSurfaces
(
&
proxy
1
access
info
)
;
}
void
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
if
GR_TEST_UTILS
void
testingOnly_removeOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
endif
void
moveRenderTasksToDDL
(
SkDeferredDisplayList
*
ddl
)
;
void
copyRenderTasksFromDDL
(
const
SkDeferredDisplayList
*
GrRenderTargetProxy
*
newDest
)
;
private
:
class
RenderTaskDAG
{
public
:
RenderTaskDAG
(
bool
sortRenderTasks
)
;
~
RenderTaskDAG
(
)
;
void
prepForFlush
(
)
;
void
closeAll
(
const
GrCaps
*
caps
)
;
void
cleanup
(
const
GrCaps
*
caps
)
;
void
gatherIDs
(
SkSTArray
<
8
uint32_t
true
>
*
idArray
)
const
;
void
reset
(
)
;
void
removeRenderTask
(
int
index
)
;
void
removeRenderTasks
(
int
startIndex
int
stopIndex
)
;
bool
empty
(
)
const
{
return
fRenderTasks
.
empty
(
)
;
}
int
numRenderTasks
(
)
const
{
return
fRenderTasks
.
count
(
)
;
}
bool
isUsed
(
GrSurfaceProxy
*
)
const
;
GrRenderTask
*
renderTask
(
int
index
)
{
return
fRenderTasks
[
index
]
.
get
(
)
;
}
const
GrRenderTask
*
renderTask
(
int
index
)
const
{
return
fRenderTasks
[
index
]
.
get
(
)
;
}
GrRenderTask
*
back
(
)
{
return
fRenderTasks
.
back
(
)
.
get
(
)
;
}
const
GrRenderTask
*
back
(
)
const
{
return
fRenderTasks
.
back
(
)
.
get
(
)
;
}
GrRenderTask
*
add
(
sk_sp
<
GrRenderTask
>
)
;
GrRenderTask
*
addBeforeLast
(
sk_sp
<
GrRenderTask
>
)
;
void
add
(
const
SkTArray
<
sk_sp
<
GrRenderTask
>
>
&
)
;
void
swap
(
SkTArray
<
sk_sp
<
GrRenderTask
>
>
*
renderTasks
)
;
bool
sortingRenderTasks
(
)
const
{
return
fSortRenderTasks
;
}
private
:
SkTArray
<
sk_sp
<
GrRenderTask
>
>
fRenderTasks
;
bool
fSortRenderTasks
;
}
;
GrDrawingManager
(
GrRecordingContext
*
const
GrPathRendererChain
:
:
Options
&
const
GrTextContext
:
:
Options
&
bool
sortRenderTasks
bool
reduceOpsTaskSplitting
)
;
bool
wasAbandoned
(
)
const
;
void
cleanup
(
)
;
void
closeRenderTasksForNewRenderTask
(
GrSurfaceProxy
*
target
)
;
bool
executeRenderTasks
(
int
startIndex
int
stopIndex
GrOpFlushState
*
int
*
numRenderTasksExecuted
)
;
GrSemaphoresSubmitted
flush
(
GrSurfaceProxy
*
proxies
[
]
int
numProxies
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
const
GrPrepareForExternalIORequests
&
)
;
SkDEBUGCODE
(
void
validate
(
)
const
)
;
friend
class
GrContext
;
friend
class
GrContextPriv
;
friend
class
GrOnFlushResourceProvider
;
friend
class
GrRecordingContext
;
friend
class
SkImage
;
static
const
int
kNumPixelGeometries
=
5
;
static
const
int
kNumDFTOptions
=
2
;
GrRecordingContext
*
fContext
;
GrPathRendererChain
:
:
Options
fOptionsForPathRendererChain
;
GrTextContext
:
:
Options
fOptionsForTextContext
;
sk_sp
<
GrBufferAllocPool
:
:
CpuBufferCache
>
fCpuBufferCache
;
RenderTaskDAG
fDAG
;
GrOpsTask
*
fActiveOpsTask
=
nullptr
;
SkSTArray
<
8
uint32_t
true
>
fFlushingRenderTaskIDs
;
SkSTArray
<
4
sk_sp
<
GrRenderTask
>
>
fOnFlushRenderTasks
;
std
:
:
unique_ptr
<
GrTextContext
>
fTextContext
;
std
:
:
unique_ptr
<
GrPathRendererChain
>
fPathRendererChain
;
sk_sp
<
GrSoftwarePathRenderer
>
fSoftwarePathRenderer
;
GrTokenTracker
fTokenTracker
;
bool
fFlushing
;
bool
fReduceOpsTaskSplitting
;
SkTArray
<
GrOnFlushCallbackObject
*
>
fOnFlushCBObjects
;
void
addDDLTarget
(
GrSurfaceProxy
*
proxy
)
{
fDDLTargets
.
insert
(
proxy
)
;
}
bool
isDDLTarget
(
GrSurfaceProxy
*
proxy
)
{
return
fDDLTargets
.
find
(
proxy
)
!
=
fDDLTargets
.
end
(
)
;
}
void
clearDDLTargets
(
)
{
fDDLTargets
.
clear
(
)
;
}
std
:
:
set
<
GrSurfaceProxy
*
>
fDDLTargets
;
}
;
#
endif
