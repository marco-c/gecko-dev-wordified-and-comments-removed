#
ifndef
GrDrawingManager_DEFINED
#
define
GrDrawingManager_DEFINED
#
include
"
GrBufferAllocPool
.
h
"
#
include
"
GrDeferredUpload
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
GrPathRendererChain
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
text
/
GrTextContext
.
h
"
class
GrCoverageCountingPathRenderer
;
class
GrOnFlushCallbackObject
;
class
GrOpFlushState
;
class
GrRecordingContext
;
class
GrRenderTargetContext
;
class
GrRenderTargetProxy
;
class
GrRenderTargetOpList
;
class
GrSoftwarePathRenderer
;
class
GrTextureContext
;
class
GrTextureOpList
;
class
SkDeferredDisplayList
;
class
GrDrawingManager
{
public
:
~
GrDrawingManager
(
)
;
void
freeGpuResources
(
)
;
sk_sp
<
GrRenderTargetContext
>
makeRenderTargetContext
(
sk_sp
<
GrSurfaceProxy
>
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
bool
managedOpList
=
true
)
;
sk_sp
<
GrTextureContext
>
makeTextureContext
(
sk_sp
<
GrSurfaceProxy
>
sk_sp
<
SkColorSpace
>
)
;
sk_sp
<
GrRenderTargetOpList
>
newRTOpList
(
GrRenderTargetProxy
*
rtp
bool
managedOpList
)
;
sk_sp
<
GrTextureOpList
>
newTextureOpList
(
GrTextureProxy
*
textureProxy
)
;
GrRecordingContext
*
getContext
(
)
{
return
fContext
;
}
GrTextContext
*
getTextContext
(
)
;
GrPathRenderer
*
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
=
nullptr
)
;
GrPathRenderer
*
getSoftwarePathRenderer
(
)
;
GrCoverageCountingPathRenderer
*
getCoverageCountingPathRenderer
(
)
;
void
flushIfNecessary
(
)
;
static
bool
ProgramUnitTest
(
GrContext
*
context
int
maxStages
int
maxLevels
)
;
GrSemaphoresSubmitted
prepareSurfaceForExternalIO
(
GrSurfaceProxy
*
SkSurface
:
:
BackendSurfaceAccess
access
SkSurface
:
:
FlushFlags
flags
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
;
void
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
if
GR_TEST_UTILS
void
testingOnly_removeOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
#
endif
void
moveOpListsToDDL
(
SkDeferredDisplayList
*
ddl
)
;
void
copyOpListsFromDDL
(
const
SkDeferredDisplayList
*
GrRenderTargetProxy
*
newDest
)
;
private
:
class
OpListDAG
{
public
:
OpListDAG
(
bool
explicitlyAllocating
GrContextOptions
:
:
Enable
sortOpLists
)
;
~
OpListDAG
(
)
;
void
prepForFlush
(
)
;
void
closeAll
(
const
GrCaps
*
caps
)
;
void
cleanup
(
const
GrCaps
*
caps
)
;
void
gatherIDs
(
SkSTArray
<
8
uint32_t
true
>
*
idArray
)
const
;
void
reset
(
)
;
void
removeOpList
(
int
index
)
;
void
removeOpLists
(
int
startIndex
int
stopIndex
)
;
bool
empty
(
)
const
{
return
fOpLists
.
empty
(
)
;
}
int
numOpLists
(
)
const
{
return
fOpLists
.
count
(
)
;
}
GrOpList
*
opList
(
int
index
)
{
return
fOpLists
[
index
]
.
get
(
)
;
}
const
GrOpList
*
opList
(
int
index
)
const
{
return
fOpLists
[
index
]
.
get
(
)
;
}
GrOpList
*
back
(
)
{
return
fOpLists
.
back
(
)
.
get
(
)
;
}
const
GrOpList
*
back
(
)
const
{
return
fOpLists
.
back
(
)
.
get
(
)
;
}
void
add
(
sk_sp
<
GrOpList
>
)
;
void
add
(
const
SkTArray
<
sk_sp
<
GrOpList
>
>
&
)
;
void
swap
(
SkTArray
<
sk_sp
<
GrOpList
>
>
*
opLists
)
;
bool
sortingOpLists
(
)
const
{
return
fSortOpLists
;
}
private
:
SkTArray
<
sk_sp
<
GrOpList
>
>
fOpLists
;
bool
fSortOpLists
;
}
;
GrDrawingManager
(
GrRecordingContext
*
const
GrPathRendererChain
:
:
Options
&
const
GrTextContext
:
:
Options
&
bool
explicitlyAllocating
GrContextOptions
:
:
Enable
sortRenderTargets
GrContextOptions
:
:
Enable
reduceOpListSplitting
)
;
bool
wasAbandoned
(
)
const
;
void
cleanup
(
)
;
bool
executeOpLists
(
int
startIndex
int
stopIndex
GrOpFlushState
*
int
*
numOpListsExecuted
)
;
GrSemaphoresSubmitted
flush
(
GrSurfaceProxy
*
proxy
SkSurface
:
:
BackendSurfaceAccess
access
SkSurface
:
:
FlushFlags
flags
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
;
SkDEBUGCODE
(
void
validate
(
)
const
)
;
friend
class
GrContext
;
friend
class
GrContextPriv
;
friend
class
GrOnFlushResourceProvider
;
friend
class
GrRecordingContext
;
friend
class
SkImage
;
static
const
int
kNumPixelGeometries
=
5
;
static
const
int
kNumDFTOptions
=
2
;
GrRecordingContext
*
fContext
;
GrPathRendererChain
:
:
Options
fOptionsForPathRendererChain
;
GrTextContext
:
:
Options
fOptionsForTextContext
;
sk_sp
<
GrBufferAllocPool
:
:
CpuBufferCache
>
fCpuBufferCache
;
OpListDAG
fDAG
;
GrOpList
*
fActiveOpList
=
nullptr
;
SkSTArray
<
8
uint32_t
true
>
fFlushingOpListIDs
;
SkSTArray
<
8
sk_sp
<
GrOpList
>
>
fOnFlushCBOpLists
;
std
:
:
unique_ptr
<
GrTextContext
>
fTextContext
;
std
:
:
unique_ptr
<
GrPathRendererChain
>
fPathRendererChain
;
sk_sp
<
GrSoftwarePathRenderer
>
fSoftwarePathRenderer
;
GrTokenTracker
fTokenTracker
;
bool
fFlushing
;
bool
fReduceOpListSplitting
;
SkTArray
<
GrOnFlushCallbackObject
*
>
fOnFlushCBObjects
;
}
;
#
endif
