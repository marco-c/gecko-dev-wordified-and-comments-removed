#
ifndef
GrDrawingManager_DEFINED
#
define
GrDrawingManager_DEFINED
#
include
"
GrDrawTarget
.
h
"
#
include
"
GrBatchFlushState
.
h
"
#
include
"
GrPathRendererChain
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
SkTDArray
.
h
"
class
GrContext
;
class
GrDrawContext
;
class
GrSoftwarePathRenderer
;
class
GrTextContext
;
class
GrDrawingManager
{
public
:
~
GrDrawingManager
(
)
;
bool
abandoned
(
)
const
{
return
fAbandoned
;
}
void
freeGpuResources
(
)
;
GrDrawContext
*
drawContext
(
GrRenderTarget
*
rt
const
SkSurfaceProps
*
surfaceProps
)
;
GrTextContext
*
textContext
(
const
SkSurfaceProps
&
props
GrRenderTarget
*
rt
)
;
GrDrawTarget
*
newDrawTarget
(
GrRenderTarget
*
rt
)
;
GrContext
*
getContext
(
)
{
return
fContext
;
}
GrPathRenderer
*
getPathRenderer
(
const
GrPathRenderer
:
:
CanDrawPathArgs
&
args
bool
allowSW
GrPathRendererChain
:
:
DrawType
drawType
GrPathRenderer
:
:
StencilSupport
*
stencilSupport
=
NULL
)
;
static
bool
ProgramUnitTest
(
GrContext
*
context
int
maxStages
)
;
private
:
GrDrawingManager
(
GrContext
*
context
const
GrDrawTarget
:
:
Options
&
optionsForDrawTargets
)
:
fContext
(
context
)
fOptionsForDrawTargets
(
optionsForDrawTargets
)
fAbandoned
(
false
)
fNVPRTextContext
(
nullptr
)
fPathRendererChain
(
nullptr
)
fSoftwarePathRenderer
(
nullptr
)
fFlushState
(
context
-
>
getGpu
(
)
context
-
>
resourceProvider
(
)
)
{
sk_bzero
(
fTextContexts
sizeof
(
fTextContexts
)
)
;
}
void
abandon
(
)
;
void
cleanup
(
)
;
void
reset
(
)
;
void
flush
(
)
;
friend
class
GrContext
;
static
const
int
kNumPixelGeometries
=
5
;
static
const
int
kNumDFTOptions
=
2
;
GrContext
*
fContext
;
GrDrawTarget
:
:
Options
fOptionsForDrawTargets
;
bool
fAbandoned
;
SkTDArray
<
GrDrawTarget
*
>
fDrawTargets
;
GrTextContext
*
fNVPRTextContext
;
GrTextContext
*
fTextContexts
[
kNumPixelGeometries
]
[
kNumDFTOptions
]
;
GrPathRendererChain
*
fPathRendererChain
;
GrSoftwarePathRenderer
*
fSoftwarePathRenderer
;
GrBatchFlushState
fFlushState
;
}
;
#
endif
