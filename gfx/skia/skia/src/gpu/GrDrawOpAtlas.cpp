#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrOnFlushResourceProvider
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrRectanizer
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrTracing
.
h
"
void
GrDrawOpAtlas
:
:
instantiate
(
GrOnFlushResourceProvider
*
onFlushResourceProvider
)
{
for
(
int
i
=
0
;
i
<
GrDrawOpAtlas
:
:
kMaxMultitexturePages
;
+
+
i
)
{
if
(
fProxies
[
i
]
&
&
!
fProxies
[
i
]
-
>
priv
(
)
.
isInstantiated
(
)
)
{
onFlushResourceProvider
-
>
instatiateProxy
(
fProxies
[
i
]
.
get
(
)
)
;
}
}
}
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
GrDrawOpAtlas
:
:
Make
(
GrContext
*
ctx
GrPixelConfig
config
int
width
int
height
int
numPlotsX
int
numPlotsY
AllowMultitexturing
allowMultitexturing
GrDrawOpAtlas
:
:
EvictionFunc
func
void
*
data
)
{
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
atlas
(
new
GrDrawOpAtlas
(
ctx
config
width
height
numPlotsX
numPlotsY
allowMultitexturing
)
)
;
if
(
!
atlas
-
>
getProxies
(
)
[
0
]
)
{
return
nullptr
;
}
atlas
-
>
registerEvictionCallback
(
func
data
)
;
return
atlas
;
}
#
ifdef
DUMP_ATLAS_DATA
static
bool
gDumpAtlasData
=
false
;
#
endif
GrDrawOpAtlas
:
:
Plot
:
:
Plot
(
int
pageIndex
int
plotIndex
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
:
fLastUpload
(
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
)
fLastUse
(
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
)
fFlushesSinceLastUse
(
0
)
fPageIndex
(
pageIndex
)
fPlotIndex
(
plotIndex
)
fGenID
(
genID
)
fID
(
CreateId
(
fPageIndex
fPlotIndex
fGenID
)
)
fData
(
nullptr
)
fWidth
(
width
)
fHeight
(
height
)
fX
(
offX
)
fY
(
offY
)
fRects
(
nullptr
)
fOffset
(
SkIPoint16
:
:
Make
(
fX
*
fWidth
fY
*
fHeight
)
)
fConfig
(
config
)
fBytesPerPixel
(
GrBytesPerPixel
(
config
)
)
#
ifdef
SK_DEBUG
fDirty
(
false
)
#
endif
{
SkASSERT
(
(
(
width
*
fBytesPerPixel
)
&
0x3
)
=
=
0
)
;
SkASSERT
(
fBytesPerPixel
!
=
3
&
&
fBytesPerPixel
<
=
4
)
;
fDirtyRect
.
setEmpty
(
)
;
}
GrDrawOpAtlas
:
:
Plot
:
:
~
Plot
(
)
{
sk_free
(
fData
)
;
delete
fRects
;
}
bool
GrDrawOpAtlas
:
:
Plot
:
:
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
SkASSERT
(
width
<
=
fWidth
&
&
height
<
=
fHeight
)
;
if
(
!
fRects
)
{
fRects
=
GrRectanizer
:
:
Factory
(
fWidth
fHeight
)
;
}
if
(
!
fRects
-
>
addRect
(
width
height
loc
)
)
{
return
false
;
}
if
(
!
fData
)
{
fData
=
reinterpret_cast
<
unsigned
char
*
>
(
sk_calloc_throw
(
fBytesPerPixel
*
fWidth
*
fHeight
)
)
;
}
size_t
rowBytes
=
width
*
fBytesPerPixel
;
const
unsigned
char
*
imagePtr
=
(
const
unsigned
char
*
)
image
;
unsigned
char
*
dataPtr
=
fData
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
*
loc
-
>
fY
;
dataPtr
+
=
fBytesPerPixel
*
loc
-
>
fX
;
if
(
4
=
=
fBytesPerPixel
&
&
kSkia8888_GrPixelConfig
=
=
kBGRA_8888_GrPixelConfig
)
{
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
SkOpts
:
:
RGBA_to_BGRA
(
reinterpret_cast
<
uint32_t
*
>
(
dataPtr
)
imagePtr
width
)
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
;
imagePtr
+
=
rowBytes
;
}
}
else
{
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
memcpy
(
dataPtr
imagePtr
rowBytes
)
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
;
imagePtr
+
=
rowBytes
;
}
}
fDirtyRect
.
join
(
loc
-
>
fX
loc
-
>
fY
loc
-
>
fX
+
width
loc
-
>
fY
+
height
)
;
loc
-
>
fX
+
=
fOffset
.
fX
;
loc
-
>
fY
+
=
fOffset
.
fY
;
SkDEBUGCODE
(
fDirty
=
true
;
)
return
true
;
}
void
GrDrawOpAtlas
:
:
Plot
:
:
uploadToTexture
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
GrTextureProxy
*
proxy
)
{
SkASSERT
(
fDirty
&
&
fData
&
&
proxy
&
&
proxy
-
>
priv
(
)
.
peekTexture
(
)
)
;
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
size_t
rowBytes
=
fBytesPerPixel
*
fWidth
;
const
unsigned
char
*
dataPtr
=
fData
;
unsigned
int
clearBits
=
0x3
/
fBytesPerPixel
;
fDirtyRect
.
fLeft
&
=
~
clearBits
;
fDirtyRect
.
fRight
+
=
clearBits
;
fDirtyRect
.
fRight
&
=
~
clearBits
;
SkASSERT
(
fDirtyRect
.
fRight
<
=
fWidth
)
;
dataPtr
+
=
rowBytes
*
fDirtyRect
.
fTop
;
dataPtr
+
=
fBytesPerPixel
*
fDirtyRect
.
fLeft
;
auto
colorType
=
GrPixelConfigToColorType
(
fConfig
)
;
writePixels
(
proxy
fOffset
.
fX
+
fDirtyRect
.
fLeft
fOffset
.
fY
+
fDirtyRect
.
fTop
fDirtyRect
.
width
(
)
fDirtyRect
.
height
(
)
colorType
dataPtr
rowBytes
)
;
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
void
GrDrawOpAtlas
:
:
Plot
:
:
resetRects
(
)
{
if
(
fRects
)
{
fRects
-
>
reset
(
)
;
}
fGenID
+
+
;
fID
=
CreateId
(
fPageIndex
fPlotIndex
fGenID
)
;
fLastUpload
=
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
;
fLastUse
=
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
;
if
(
fData
)
{
sk_bzero
(
fData
fBytesPerPixel
*
fWidth
*
fHeight
)
;
}
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
GrDrawOpAtlas
:
:
GrDrawOpAtlas
(
GrContext
*
context
GrPixelConfig
config
int
width
int
height
int
numPlotsX
int
numPlotsY
AllowMultitexturing
allowMultitexturing
)
:
fContext
(
context
)
fPixelConfig
(
config
)
fTextureWidth
(
width
)
fTextureHeight
(
height
)
fAtlasGeneration
(
kInvalidAtlasGeneration
+
1
)
fPrevFlushToken
(
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
)
fAllowMultitexturing
(
allowMultitexturing
)
fNumPages
(
0
)
{
fPlotWidth
=
fTextureWidth
/
numPlotsX
;
fPlotHeight
=
fTextureHeight
/
numPlotsY
;
SkASSERT
(
numPlotsX
*
numPlotsY
<
=
BulkUseTokenUpdater
:
:
kMaxPlots
)
;
SkASSERT
(
fPlotWidth
*
numPlotsX
=
=
fTextureWidth
)
;
SkASSERT
(
fPlotHeight
*
numPlotsY
=
=
fTextureHeight
)
;
fNumPlots
=
numPlotsX
*
numPlotsY
;
this
-
>
createNewPage
(
)
;
}
inline
void
GrDrawOpAtlas
:
:
processEviction
(
AtlasID
id
)
{
for
(
int
i
=
0
;
i
<
fEvictionCallbacks
.
count
(
)
;
i
+
+
)
{
(
*
fEvictionCallbacks
[
i
]
.
fFunc
)
(
id
fEvictionCallbacks
[
i
]
.
fData
)
;
}
+
+
fAtlasGeneration
;
}
inline
bool
GrDrawOpAtlas
:
:
updatePlot
(
GrDeferredUploadTarget
*
target
AtlasID
*
id
Plot
*
plot
)
{
int
pageIdx
=
GetPageIndexFromID
(
plot
-
>
id
(
)
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
if
(
plot
-
>
lastUploadToken
(
)
<
target
-
>
tokenTracker
(
)
-
>
nextTokenToFlush
(
)
)
{
sk_sp
<
Plot
>
plotsp
(
SkRef
(
plot
)
)
;
if
(
!
fProxies
[
pageIdx
]
-
>
instantiate
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
)
{
return
false
;
}
GrTextureProxy
*
proxy
=
fProxies
[
pageIdx
]
.
get
(
)
;
GrDeferredUploadToken
lastUploadToken
=
target
-
>
addASAPUpload
(
[
plotsp
proxy
]
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
proxy
)
;
}
)
;
plot
-
>
setLastUploadToken
(
lastUploadToken
)
;
}
*
id
=
plot
-
>
id
(
)
;
return
true
;
}
static
constexpr
auto
kRecentlyUsedCount
=
256
;
bool
GrDrawOpAtlas
:
:
addToAtlas
(
AtlasID
*
id
GrDeferredUploadTarget
*
target
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
if
(
width
>
fPlotWidth
|
|
height
>
fPlotHeight
)
{
return
false
;
}
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumPages
;
+
+
pageIdx
)
{
SkASSERT
(
fProxies
[
pageIdx
]
)
;
PlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPages
[
pageIdx
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
Plot
*
plot
;
while
(
(
plot
=
plotIter
.
get
(
)
)
)
{
SkASSERT
(
GrBytesPerPixel
(
fProxies
[
pageIdx
]
-
>
config
(
)
)
=
=
plot
-
>
bpp
(
)
)
;
if
(
plot
-
>
addSubImage
(
width
height
image
loc
)
)
{
return
this
-
>
updatePlot
(
target
id
plot
)
;
}
plotIter
.
next
(
)
;
}
}
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumPages
;
+
+
pageIdx
)
{
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotList
.
tail
(
)
;
SkASSERT
(
plot
)
;
if
(
(
fNumPages
=
=
this
-
>
maxPages
(
)
&
&
plot
-
>
lastUseToken
(
)
<
target
-
>
tokenTracker
(
)
-
>
nextTokenToFlush
(
)
)
|
|
plot
-
>
flushesSinceLastUsed
(
)
>
=
kRecentlyUsedCount
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
SkASSERT
(
GrBytesPerPixel
(
fProxies
[
pageIdx
]
-
>
config
(
)
)
=
=
plot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
plot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
if
(
!
this
-
>
updatePlot
(
target
id
plot
)
)
{
return
false
;
}
return
true
;
}
}
if
(
this
-
>
createNewPage
(
)
)
{
unsigned
int
pageIdx
=
fNumPages
-
1
;
SkASSERT
(
fProxies
[
pageIdx
]
)
;
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotList
.
head
(
)
;
SkASSERT
(
GrBytesPerPixel
(
fProxies
[
pageIdx
]
-
>
config
(
)
)
=
=
plot
-
>
bpp
(
)
)
;
if
(
plot
-
>
addSubImage
(
width
height
image
loc
)
)
{
return
this
-
>
updatePlot
(
target
id
plot
)
;
}
SkASSERT
(
false
)
;
return
false
;
}
Plot
*
plot
=
nullptr
;
for
(
int
pageIdx
=
(
int
)
(
fNumPages
-
1
)
;
pageIdx
>
=
0
;
-
-
pageIdx
)
{
Plot
*
currentPlot
=
fPages
[
pageIdx
]
.
fPlotList
.
tail
(
)
;
if
(
currentPlot
-
>
lastUseToken
(
)
!
=
target
-
>
tokenTracker
(
)
-
>
nextDrawToken
(
)
)
{
plot
=
currentPlot
;
break
;
}
}
if
(
!
plot
)
{
return
false
;
}
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
int
pageIdx
=
GetPageIndexFromID
(
plot
-
>
id
(
)
)
;
fPages
[
pageIdx
]
.
fPlotList
.
remove
(
plot
)
;
sk_sp
<
Plot
>
&
newPlot
=
fPages
[
pageIdx
]
.
fPlotArray
[
plot
-
>
index
(
)
]
;
newPlot
.
reset
(
plot
-
>
clone
(
)
)
;
fPages
[
pageIdx
]
.
fPlotList
.
addToHead
(
newPlot
.
get
(
)
)
;
SkASSERT
(
GrBytesPerPixel
(
fProxies
[
pageIdx
]
-
>
config
(
)
)
=
=
newPlot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
newPlot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
sk_sp
<
Plot
>
plotsp
(
SkRef
(
newPlot
.
get
(
)
)
)
;
if
(
!
fProxies
[
pageIdx
]
-
>
instantiate
(
fContext
-
>
contextPriv
(
)
.
resourceProvider
(
)
)
)
{
return
false
;
}
GrTextureProxy
*
proxy
=
fProxies
[
pageIdx
]
.
get
(
)
;
GrDeferredUploadToken
lastUploadToken
=
target
-
>
addInlineUpload
(
[
plotsp
proxy
]
(
GrDeferredTextureUploadWritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
proxy
)
;
}
)
;
newPlot
-
>
setLastUploadToken
(
lastUploadToken
)
;
*
id
=
newPlot
-
>
id
(
)
;
return
true
;
}
void
GrDrawOpAtlas
:
:
compact
(
GrDeferredUploadToken
startTokenForNextFlush
)
{
if
(
fNumPages
<
=
1
)
{
fPrevFlushToken
=
startTokenForNextFlush
;
return
;
}
PlotList
:
:
Iter
plotIter
;
bool
atlasUsedThisFlush
=
false
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
fNumPages
;
+
+
pageIndex
)
{
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
resetFlushesSinceLastUsed
(
)
;
atlasUsedThisFlush
=
true
;
}
plotIter
.
next
(
)
;
}
}
if
(
atlasUsedThisFlush
)
{
SkTArray
<
Plot
*
>
availablePlots
;
uint32_t
lastPageIndex
=
fNumPages
-
1
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
lastPageIndex
;
+
+
pageIndex
)
{
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
pageIndex
)
;
}
#
endif
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
#
endif
if
(
plot
-
>
flushesSinceLastUsed
(
)
>
kRecentlyUsedCount
)
{
availablePlots
.
push_back
(
)
=
plot
;
}
plotIter
.
next
(
)
;
}
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
#
endif
}
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
unsigned
int
usedPlots
=
0
;
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
lastPageIndex
)
;
}
#
endif
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
#
endif
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kRecentlyUsedCount
)
{
usedPlots
+
+
;
}
else
if
(
plot
-
>
lastUseToken
(
)
!
=
GrDeferredUploadToken
:
:
AlreadyFlushedToken
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
}
plotIter
.
next
(
)
;
}
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
#
endif
if
(
availablePlots
.
count
(
)
&
&
usedPlots
&
&
usedPlots
<
=
fNumPlots
/
4
)
{
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kRecentlyUsedCount
)
{
if
(
availablePlots
.
count
(
)
>
0
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
this
-
>
processEvictionAndResetRects
(
availablePlots
.
back
(
)
)
;
availablePlots
.
pop_back
(
)
;
-
-
usedPlots
;
}
if
(
!
usedPlots
|
|
!
availablePlots
.
count
(
)
)
{
break
;
}
}
plotIter
.
next
(
)
;
}
}
if
(
!
usedPlots
)
{
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
delete
%
d
\
n
"
fNumPages
-
1
)
;
}
#
endif
this
-
>
deleteLastPage
(
)
;
}
}
fPrevFlushToken
=
startTokenForNextFlush
;
}
bool
GrDrawOpAtlas
:
:
createNewPage
(
)
{
if
(
fNumPages
=
=
this
-
>
maxPages
(
)
)
{
return
false
;
}
GrProxyProvider
*
proxyProvider
=
fContext
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kNone_GrSurfaceFlags
;
desc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
desc
.
fWidth
=
fTextureWidth
;
desc
.
fHeight
=
fTextureHeight
;
desc
.
fConfig
=
fPixelConfig
;
SkASSERT
(
SkIsPow2
(
fTextureWidth
)
&
&
SkIsPow2
(
fTextureHeight
)
)
;
fProxies
[
fNumPages
]
=
proxyProvider
-
>
createProxy
(
desc
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kYes
GrResourceProvider
:
:
kNoPendingIO_Flag
)
;
if
(
!
fProxies
[
fNumPages
]
)
{
return
false
;
}
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
fPages
[
fNumPages
]
.
fPlotArray
.
reset
(
new
sk_sp
<
Plot
>
[
numPlotsX
*
numPlotsY
]
)
;
sk_sp
<
Plot
>
*
currPlot
=
fPages
[
fNumPages
]
.
fPlotArray
.
get
(
)
;
for
(
int
y
=
numPlotsY
-
1
r
=
0
;
y
>
=
0
;
-
-
y
+
+
r
)
{
for
(
int
x
=
numPlotsX
-
1
c
=
0
;
x
>
=
0
;
-
-
x
+
+
c
)
{
uint32_t
plotIndex
=
r
*
numPlotsX
+
c
;
currPlot
-
>
reset
(
new
Plot
(
fNumPages
plotIndex
1
x
y
fPlotWidth
fPlotHeight
fPixelConfig
)
)
;
fPages
[
fNumPages
]
.
fPlotList
.
addToHead
(
currPlot
-
>
get
(
)
)
;
+
+
currPlot
;
}
}
#
ifdef
DUMP_ATLAS_DATA
if
(
gDumpAtlasData
)
{
SkDebugf
(
"
created
%
d
\
n
"
fNumPages
)
;
}
#
endif
fNumPages
+
+
;
return
true
;
}
inline
void
GrDrawOpAtlas
:
:
deleteLastPage
(
)
{
uint32_t
lastPageIndex
=
fNumPages
-
1
;
fPages
[
lastPageIndex
]
.
fPlotList
.
reset
(
)
;
fPages
[
lastPageIndex
]
.
fPlotArray
.
reset
(
nullptr
)
;
fProxies
[
lastPageIndex
]
.
reset
(
nullptr
)
;
-
-
fNumPages
;
}
