#
include
"
GrDrawOpAtlas
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrRectanizer
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrTracing
.
h
"
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
GrDrawOpAtlas
:
:
Make
(
GrContext
*
ctx
GrPixelConfig
config
int
width
int
height
int
numPlotsX
int
numPlotsY
GrDrawOpAtlas
:
:
EvictionFunc
func
void
*
data
)
{
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kNone_GrSurfaceFlags
;
desc
.
fWidth
=
width
;
desc
.
fHeight
=
height
;
desc
.
fConfig
=
config
;
static
const
uint32_t
kFlags
=
GrResourceProvider
:
:
kNoPendingIO_Flag
;
sk_sp
<
GrTexture
>
texture
(
ctx
-
>
resourceProvider
(
)
-
>
createApproxTexture
(
desc
kFlags
)
)
;
if
(
!
texture
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
proxy
=
GrSurfaceProxy
:
:
MakeWrapped
(
std
:
:
move
(
texture
)
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
atlas
(
new
GrDrawOpAtlas
(
ctx
std
:
:
move
(
proxy
)
numPlotsX
numPlotsY
)
)
;
atlas
-
>
registerEvictionCallback
(
func
data
)
;
return
atlas
;
}
GrDrawOpAtlas
:
:
Plot
:
:
Plot
(
int
index
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
:
fLastUpload
(
GrDrawOpUploadToken
:
:
AlreadyFlushedToken
(
)
)
fLastUse
(
GrDrawOpUploadToken
:
:
AlreadyFlushedToken
(
)
)
fIndex
(
index
)
fGenID
(
genID
)
fID
(
CreateId
(
fIndex
fGenID
)
)
fData
(
nullptr
)
fWidth
(
width
)
fHeight
(
height
)
fX
(
offX
)
fY
(
offY
)
fRects
(
nullptr
)
fOffset
(
SkIPoint16
:
:
Make
(
fX
*
fWidth
fY
*
fHeight
)
)
fConfig
(
config
)
fBytesPerPixel
(
GrBytesPerPixel
(
config
)
)
#
ifdef
SK_DEBUG
fDirty
(
false
)
#
endif
{
fDirtyRect
.
setEmpty
(
)
;
}
GrDrawOpAtlas
:
:
Plot
:
:
~
Plot
(
)
{
sk_free
(
fData
)
;
delete
fRects
;
}
bool
GrDrawOpAtlas
:
:
Plot
:
:
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
SkASSERT
(
width
<
=
fWidth
&
&
height
<
=
fHeight
)
;
if
(
!
fRects
)
{
fRects
=
GrRectanizer
:
:
Factory
(
fWidth
fHeight
)
;
}
if
(
!
fRects
-
>
addRect
(
width
height
loc
)
)
{
return
false
;
}
if
(
!
fData
)
{
fData
=
reinterpret_cast
<
unsigned
char
*
>
(
sk_calloc_throw
(
fBytesPerPixel
*
fWidth
*
fHeight
)
)
;
}
size_t
rowBytes
=
width
*
fBytesPerPixel
;
const
unsigned
char
*
imagePtr
=
(
const
unsigned
char
*
)
image
;
unsigned
char
*
dataPtr
=
fData
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
*
loc
-
>
fY
;
dataPtr
+
=
fBytesPerPixel
*
loc
-
>
fX
;
if
(
4
=
=
fBytesPerPixel
&
&
kSkia8888_GrPixelConfig
=
=
kBGRA_8888_GrPixelConfig
)
{
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
SkOpts
:
:
RGBA_to_BGRA
(
reinterpret_cast
<
uint32_t
*
>
(
dataPtr
)
imagePtr
width
)
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
;
imagePtr
+
=
rowBytes
;
}
}
else
{
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
memcpy
(
dataPtr
imagePtr
rowBytes
)
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
;
imagePtr
+
=
rowBytes
;
}
}
fDirtyRect
.
join
(
loc
-
>
fX
loc
-
>
fY
loc
-
>
fX
+
width
loc
-
>
fY
+
height
)
;
loc
-
>
fX
+
=
fOffset
.
fX
;
loc
-
>
fY
+
=
fOffset
.
fY
;
SkDEBUGCODE
(
fDirty
=
true
;
)
return
true
;
}
void
GrDrawOpAtlas
:
:
Plot
:
:
uploadToTexture
(
GrDrawOp
:
:
WritePixelsFn
&
writePixels
GrTexture
*
texture
)
{
SkASSERT
(
fDirty
&
&
fData
&
&
texture
)
;
TRACE_EVENT0
(
TRACE_DISABLED_BY_DEFAULT
(
"
skia
.
gpu
"
)
"
GrDrawOpAtlas
:
:
Plot
:
:
uploadToTexture
"
)
;
size_t
rowBytes
=
fBytesPerPixel
*
fWidth
;
const
unsigned
char
*
dataPtr
=
fData
;
dataPtr
+
=
rowBytes
*
fDirtyRect
.
fTop
;
dataPtr
+
=
fBytesPerPixel
*
fDirtyRect
.
fLeft
;
writePixels
(
texture
fOffset
.
fX
+
fDirtyRect
.
fLeft
fOffset
.
fY
+
fDirtyRect
.
fTop
fDirtyRect
.
width
(
)
fDirtyRect
.
height
(
)
fConfig
dataPtr
rowBytes
)
;
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
void
GrDrawOpAtlas
:
:
Plot
:
:
resetRects
(
)
{
if
(
fRects
)
{
fRects
-
>
reset
(
)
;
}
fGenID
+
+
;
fID
=
CreateId
(
fIndex
fGenID
)
;
if
(
fData
)
{
sk_bzero
(
fData
fBytesPerPixel
*
fWidth
*
fHeight
)
;
}
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
GrDrawOpAtlas
:
:
GrDrawOpAtlas
(
GrContext
*
context
sk_sp
<
GrTextureProxy
>
proxy
int
numPlotsX
int
numPlotsY
)
:
fContext
(
context
)
fProxy
(
std
:
:
move
(
proxy
)
)
fAtlasGeneration
(
kInvalidAtlasGeneration
+
1
)
{
fPlotWidth
=
fProxy
-
>
width
(
)
/
numPlotsX
;
fPlotHeight
=
fProxy
-
>
height
(
)
/
numPlotsY
;
SkASSERT
(
numPlotsX
*
numPlotsY
<
=
BulkUseTokenUpdater
:
:
kMaxPlots
)
;
SkASSERT
(
fPlotWidth
*
numPlotsX
=
=
fProxy
-
>
width
(
)
)
;
SkASSERT
(
fPlotHeight
*
numPlotsY
=
=
fProxy
-
>
height
(
)
)
;
SkDEBUGCODE
(
fNumPlots
=
numPlotsX
*
numPlotsY
;
)
SkASSERT
(
!
GrPixelConfigIsCompressed
(
fProxy
-
>
desc
(
)
.
fConfig
)
)
;
fPlotArray
.
reset
(
new
sk_sp
<
Plot
>
[
numPlotsX
*
numPlotsY
]
)
;
sk_sp
<
Plot
>
*
currPlot
=
fPlotArray
.
get
(
)
;
for
(
int
y
=
numPlotsY
-
1
r
=
0
;
y
>
=
0
;
-
-
y
+
+
r
)
{
for
(
int
x
=
numPlotsX
-
1
c
=
0
;
x
>
=
0
;
-
-
x
+
+
c
)
{
uint32_t
index
=
r
*
numPlotsX
+
c
;
currPlot
-
>
reset
(
new
Plot
(
index
1
x
y
fPlotWidth
fPlotHeight
fProxy
-
>
desc
(
)
.
fConfig
)
)
;
fPlotList
.
addToHead
(
currPlot
-
>
get
(
)
)
;
+
+
currPlot
;
}
}
}
void
GrDrawOpAtlas
:
:
processEviction
(
AtlasID
id
)
{
for
(
int
i
=
0
;
i
<
fEvictionCallbacks
.
count
(
)
;
i
+
+
)
{
(
*
fEvictionCallbacks
[
i
]
.
fFunc
)
(
id
fEvictionCallbacks
[
i
]
.
fData
)
;
}
}
inline
bool
GrDrawOpAtlas
:
:
updatePlot
(
GrDrawOp
:
:
Target
*
target
AtlasID
*
id
Plot
*
plot
)
{
this
-
>
makeMRU
(
plot
)
;
if
(
target
-
>
hasDrawBeenFlushed
(
plot
-
>
lastUploadToken
(
)
)
)
{
sk_sp
<
Plot
>
plotsp
(
SkRef
(
plot
)
)
;
GrTexture
*
texture
=
fProxy
-
>
instantiate
(
fContext
-
>
resourceProvider
(
)
)
;
if
(
!
texture
)
{
return
false
;
}
GrDrawOpUploadToken
lastUploadToken
=
target
-
>
addAsapUpload
(
[
plotsp
texture
]
(
GrDrawOp
:
:
WritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
texture
)
;
}
)
;
plot
-
>
setLastUploadToken
(
lastUploadToken
)
;
}
*
id
=
plot
-
>
id
(
)
;
return
true
;
}
bool
GrDrawOpAtlas
:
:
addToAtlas
(
AtlasID
*
id
GrDrawOp
:
:
Target
*
target
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
SkASSERT
(
fProxy
)
;
if
(
width
>
fPlotWidth
|
|
height
>
fPlotHeight
)
{
return
false
;
}
PlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
Plot
*
plot
;
while
(
(
plot
=
plotIter
.
get
(
)
)
)
{
SkASSERT
(
GrBytesPerPixel
(
fProxy
-
>
desc
(
)
.
fConfig
)
=
=
plot
-
>
bpp
(
)
)
;
if
(
plot
-
>
addSubImage
(
width
height
image
loc
)
)
{
return
this
-
>
updatePlot
(
target
id
plot
)
;
}
plotIter
.
next
(
)
;
}
plot
=
fPlotList
.
tail
(
)
;
SkASSERT
(
plot
)
;
if
(
target
-
>
hasDrawBeenFlushed
(
plot
-
>
lastUseToken
(
)
)
)
{
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
plot
-
>
resetRects
(
)
;
SkASSERT
(
GrBytesPerPixel
(
fProxy
-
>
desc
(
)
.
fConfig
)
=
=
plot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
plot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
if
(
!
this
-
>
updatePlot
(
target
id
plot
)
)
{
return
false
;
}
fAtlasGeneration
+
+
;
return
true
;
}
if
(
plot
-
>
lastUseToken
(
)
=
=
target
-
>
nextDrawToken
(
)
)
{
return
false
;
}
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
fPlotList
.
remove
(
plot
)
;
sk_sp
<
Plot
>
&
newPlot
=
fPlotArray
[
plot
-
>
index
(
)
]
;
newPlot
.
reset
(
plot
-
>
clone
(
)
)
;
fPlotList
.
addToHead
(
newPlot
.
get
(
)
)
;
SkASSERT
(
GrBytesPerPixel
(
fProxy
-
>
desc
(
)
.
fConfig
)
=
=
newPlot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
newPlot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
sk_sp
<
Plot
>
plotsp
(
SkRef
(
newPlot
.
get
(
)
)
)
;
GrTexture
*
texture
=
fProxy
-
>
instantiate
(
fContext
-
>
resourceProvider
(
)
)
;
if
(
!
texture
)
{
return
false
;
}
GrDrawOpUploadToken
lastUploadToken
=
target
-
>
addInlineUpload
(
[
plotsp
texture
]
(
GrDrawOp
:
:
WritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
texture
)
;
}
)
;
newPlot
-
>
setLastUploadToken
(
lastUploadToken
)
;
*
id
=
newPlot
-
>
id
(
)
;
fAtlasGeneration
+
+
;
return
true
;
}
