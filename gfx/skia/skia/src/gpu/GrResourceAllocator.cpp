#
include
"
GrResourceAllocator
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSurfacePriv
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
if
GR_TRACK_INTERVAL_CREATION
#
include
<
atomic
>
uint32_t
GrResourceAllocator
:
:
Interval
:
:
CreateUniqueID
(
)
{
static
std
:
:
atomic
<
uint32_t
>
nextID
{
1
}
;
uint32_t
id
;
do
{
id
=
nextID
+
+
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
#
endif
void
GrResourceAllocator
:
:
Interval
:
:
assign
(
sk_sp
<
GrSurface
>
s
)
{
SkASSERT
(
!
fAssignedSurface
)
;
fAssignedSurface
=
s
;
fProxy
-
>
priv
(
)
.
assign
(
std
:
:
move
(
s
)
)
;
}
void
GrResourceAllocator
:
:
markEndOfOpList
(
int
opListIndex
)
{
SkASSERT
(
!
fAssigned
)
;
SkASSERT
(
fEndOfOpListOpIndices
.
count
(
)
=
=
opListIndex
)
;
if
(
!
fEndOfOpListOpIndices
.
empty
(
)
)
{
SkASSERT
(
fEndOfOpListOpIndices
.
back
(
)
<
this
-
>
curOp
(
)
)
;
}
fEndOfOpListOpIndices
.
push_back
(
this
-
>
curOp
(
)
)
;
}
GrResourceAllocator
:
:
~
GrResourceAllocator
(
)
{
SkASSERT
(
fIntvlList
.
empty
(
)
)
;
SkASSERT
(
fActiveIntvls
.
empty
(
)
)
;
SkASSERT
(
!
fIntvlHash
.
count
(
)
)
;
}
void
GrResourceAllocator
:
:
addInterval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
SkDEBUGCODE
(
bool
isDirectDstRead
)
)
{
SkASSERT
(
start
<
=
end
)
;
SkASSERT
(
!
fAssigned
)
;
if
(
proxy
-
>
readOnly
(
)
)
{
SkASSERT
(
proxy
-
>
isInstantiated
(
)
|
|
GrSurfaceProxy
:
:
LazyState
:
:
kNot
!
=
proxy
-
>
lazyInstantiationState
(
)
)
;
}
else
{
if
(
Interval
*
intvl
=
fIntvlHash
.
find
(
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
)
)
{
#
ifdef
SK_DEBUG
if
(
0
=
=
start
&
&
0
=
=
end
)
{
SkASSERT
(
0
=
=
intvl
-
>
start
(
)
)
;
}
else
if
(
isDirectDstRead
)
{
SkASSERT
(
intvl
-
>
start
(
)
<
=
start
&
&
intvl
-
>
end
(
)
>
=
end
)
;
}
else
{
SkASSERT
(
intvl
-
>
end
(
)
<
=
start
&
&
intvl
-
>
end
(
)
<
=
end
)
;
}
#
endif
intvl
-
>
extendEnd
(
end
)
;
return
;
}
Interval
*
newIntvl
;
if
(
fFreeIntervalList
)
{
newIntvl
=
fFreeIntervalList
;
fFreeIntervalList
=
newIntvl
-
>
next
(
)
;
newIntvl
-
>
setNext
(
nullptr
)
;
newIntvl
-
>
resetTo
(
proxy
start
end
)
;
}
else
{
newIntvl
=
fIntervalAllocator
.
make
<
Interval
>
(
proxy
start
end
)
;
}
fIntvlList
.
insertByIncreasingStart
(
newIntvl
)
;
fIntvlHash
.
add
(
newIntvl
)
;
}
if
(
proxy
-
>
readOnly
(
)
|
|
!
fResourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
if
(
GrSurfaceProxy
:
:
LazyState
:
:
kNot
!
=
proxy
-
>
lazyInstantiationState
(
)
)
{
proxy
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
;
}
}
}
GrResourceAllocator
:
:
Interval
*
GrResourceAllocator
:
:
IntervalList
:
:
popHead
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
Interval
*
temp
=
fHead
;
if
(
temp
)
{
fHead
=
temp
-
>
next
(
)
;
if
(
!
fHead
)
{
fTail
=
nullptr
;
}
temp
-
>
setNext
(
nullptr
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
return
temp
;
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingStart
(
Interval
*
intvl
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
!
intvl
-
>
next
(
)
)
;
if
(
!
fHead
)
{
fHead
=
fTail
=
intvl
;
}
else
if
(
intvl
-
>
start
(
)
<
=
fHead
-
>
start
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
if
(
fTail
-
>
start
(
)
<
=
intvl
-
>
start
(
)
)
{
fTail
-
>
setNext
(
intvl
)
;
fTail
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
intvl
-
>
start
(
)
>
next
-
>
start
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
SkASSERT
(
next
)
;
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingEnd
(
Interval
*
intvl
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
SkASSERT
(
!
intvl
-
>
next
(
)
)
;
if
(
!
fHead
)
{
fHead
=
fTail
=
intvl
;
}
else
if
(
intvl
-
>
end
(
)
<
=
fHead
-
>
end
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
if
(
fTail
-
>
end
(
)
<
=
intvl
-
>
end
(
)
)
{
fTail
-
>
setNext
(
intvl
)
;
fTail
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
intvl
-
>
end
(
)
>
next
-
>
end
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
SkASSERT
(
next
)
;
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
#
ifdef
SK_DEBUG
void
GrResourceAllocator
:
:
IntervalList
:
:
validate
(
)
const
{
SkASSERT
(
SkToBool
(
fHead
)
=
=
SkToBool
(
fTail
)
)
;
Interval
*
prev
=
nullptr
;
for
(
Interval
*
cur
=
fHead
;
cur
;
prev
=
cur
cur
=
cur
-
>
next
(
)
)
{
}
SkASSERT
(
fTail
=
=
prev
)
;
}
#
endif
GrResourceAllocator
:
:
Interval
*
GrResourceAllocator
:
:
IntervalList
:
:
detachAll
(
)
{
Interval
*
tmp
=
fHead
;
fHead
=
nullptr
;
fTail
=
nullptr
;
return
tmp
;
}
void
GrResourceAllocator
:
:
recycleSurface
(
sk_sp
<
GrSurface
>
surface
)
{
const
GrScratchKey
&
key
=
surface
-
>
resourcePriv
(
)
.
getScratchKey
(
)
;
if
(
!
key
.
isValid
(
)
)
{
return
;
}
if
(
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
return
;
}
#
if
GR_ALLOCATION_SPEW
SkDebugf
(
"
putting
surface
%
d
back
into
pool
\
n
"
surface
-
>
uniqueID
(
)
.
asUInt
(
)
)
;
#
endif
fFreePool
.
insert
(
key
surface
.
release
(
)
)
;
}
sk_sp
<
GrSurface
>
GrResourceAllocator
:
:
findSurfaceFor
(
const
GrSurfaceProxy
*
proxy
bool
needsStencil
)
{
if
(
proxy
-
>
asTextureProxy
(
)
&
&
proxy
-
>
asTextureProxy
(
)
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
sk_sp
<
GrSurface
>
surface
=
fResourceProvider
-
>
findByUniqueKey
<
GrSurface
>
(
proxy
-
>
asTextureProxy
(
)
-
>
getUniqueKey
(
)
)
;
if
(
surface
)
{
if
(
!
GrSurfaceProxyPriv
:
:
AttachStencilIfNeeded
(
fResourceProvider
surface
.
get
(
)
needsStencil
)
)
{
return
nullptr
;
}
return
surface
;
}
}
GrScratchKey
key
;
proxy
-
>
priv
(
)
.
computeScratchKey
(
&
key
)
;
auto
filter
=
[
&
]
(
const
GrSurface
*
s
)
{
return
!
proxy
-
>
priv
(
)
.
requiresNoPendingIO
(
)
|
|
!
s
-
>
surfacePriv
(
)
.
hasPendingIO
(
)
;
}
;
sk_sp
<
GrSurface
>
surface
(
fFreePool
.
findAndRemove
(
key
filter
)
)
;
if
(
surface
)
{
if
(
SkBudgeted
:
:
kYes
=
=
proxy
-
>
isBudgeted
(
)
&
&
GrBudgetedType
:
:
kBudgeted
!
=
surface
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
surface
-
>
resourcePriv
(
)
.
makeBudgeted
(
)
;
}
if
(
!
GrSurfaceProxyPriv
:
:
AttachStencilIfNeeded
(
fResourceProvider
surface
.
get
(
)
needsStencil
)
)
{
return
nullptr
;
}
SkASSERT
(
!
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
return
surface
;
}
return
proxy
-
>
priv
(
)
.
createSurface
(
fResourceProvider
)
;
}
void
GrResourceAllocator
:
:
expire
(
unsigned
int
curIndex
)
{
while
(
!
fActiveIntvls
.
empty
(
)
&
&
fActiveIntvls
.
peekHead
(
)
-
>
end
(
)
<
curIndex
)
{
Interval
*
temp
=
fActiveIntvls
.
popHead
(
)
;
SkASSERT
(
!
temp
-
>
next
(
)
)
;
if
(
temp
-
>
wasAssignedSurface
(
)
)
{
sk_sp
<
GrSurface
>
surface
=
temp
-
>
detachSurface
(
)
;
if
(
0
=
=
temp
-
>
proxy
(
)
-
>
priv
(
)
.
getProxyRefCnt
(
)
)
{
this
-
>
recycleSurface
(
std
:
:
move
(
surface
)
)
;
}
}
SkASSERT
(
!
temp
-
>
wasAssignedSurface
(
)
)
;
temp
-
>
setNext
(
fFreeIntervalList
)
;
fFreeIntervalList
=
temp
;
}
}
bool
GrResourceAllocator
:
:
assign
(
int
*
startIndex
int
*
stopIndex
AssignError
*
outError
)
{
SkASSERT
(
outError
)
;
*
outError
=
AssignError
:
:
kNoError
;
fIntvlHash
.
reset
(
)
;
if
(
fIntvlList
.
empty
(
)
)
{
return
false
;
}
*
startIndex
=
fCurOpListIndex
;
*
stopIndex
=
fEndOfOpListOpIndices
.
count
(
)
;
if
(
!
fResourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
fIntvlList
.
detachAll
(
)
;
return
true
;
}
SkDEBUGCODE
(
fAssigned
=
true
;
)
#
if
GR_ALLOCATION_SPEW
this
-
>
dumpIntervals
(
)
;
#
endif
while
(
Interval
*
cur
=
fIntvlList
.
popHead
(
)
)
{
if
(
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
cur
-
>
start
(
)
)
{
fCurOpListIndex
+
+
;
}
this
-
>
expire
(
cur
-
>
start
(
)
)
;
bool
needsStencil
=
cur
-
>
proxy
(
)
-
>
asRenderTargetProxy
(
)
?
cur
-
>
proxy
(
)
-
>
asRenderTargetProxy
(
)
-
>
needsStencil
(
)
:
false
;
if
(
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
)
{
if
(
!
GrSurfaceProxyPriv
:
:
AttachStencilIfNeeded
(
fResourceProvider
cur
-
>
proxy
(
)
-
>
peekSurface
(
)
needsStencil
)
)
{
*
outError
=
AssignError
:
:
kFailedProxyInstantiation
;
}
fActiveIntvls
.
insertByIncreasingEnd
(
cur
)
;
if
(
fResourceProvider
-
>
overBudget
(
)
)
{
if
(
!
fIntvlList
.
empty
(
)
&
&
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
fIntvlList
.
peekHead
(
)
-
>
start
(
)
)
{
*
stopIndex
=
fCurOpListIndex
+
1
;
if
(
const
Interval
*
tmp
=
fIntvlList
.
peekHead
(
)
)
{
this
-
>
expire
(
tmp
-
>
start
(
)
)
;
}
else
{
this
-
>
expire
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
)
;
}
return
true
;
}
}
continue
;
}
if
(
GrSurfaceProxy
:
:
LazyState
:
:
kNot
!
=
cur
-
>
proxy
(
)
-
>
lazyInstantiationState
(
)
)
{
if
(
!
cur
-
>
proxy
(
)
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
)
{
*
outError
=
AssignError
:
:
kFailedProxyInstantiation
;
}
}
else
if
(
sk_sp
<
GrSurface
>
surface
=
this
-
>
findSurfaceFor
(
cur
-
>
proxy
(
)
needsStencil
)
)
{
GrTextureProxy
*
texProxy
=
cur
-
>
proxy
(
)
-
>
asTextureProxy
(
)
;
if
(
texProxy
&
&
texProxy
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
if
(
!
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
fResourceProvider
-
>
assignUniqueKeyToResource
(
texProxy
-
>
getUniqueKey
(
)
surface
.
get
(
)
)
;
}
SkASSERT
(
surface
-
>
getUniqueKey
(
)
=
=
texProxy
-
>
getUniqueKey
(
)
)
;
}
#
if
GR_ALLOCATION_SPEW
SkDebugf
(
"
Assigning
%
d
to
%
d
\
n
"
surface
-
>
uniqueID
(
)
.
asUInt
(
)
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
)
;
#
endif
cur
-
>
assign
(
std
:
:
move
(
surface
)
)
;
}
else
{
SkASSERT
(
!
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
)
;
*
outError
=
AssignError
:
:
kFailedProxyInstantiation
;
}
fActiveIntvls
.
insertByIncreasingEnd
(
cur
)
;
if
(
fResourceProvider
-
>
overBudget
(
)
)
{
if
(
!
fIntvlList
.
empty
(
)
&
&
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
fIntvlList
.
peekHead
(
)
-
>
start
(
)
)
{
*
stopIndex
=
fCurOpListIndex
+
1
;
if
(
const
Interval
*
tmp
=
fIntvlList
.
peekHead
(
)
)
{
this
-
>
expire
(
tmp
-
>
start
(
)
)
;
}
else
{
this
-
>
expire
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
)
;
}
return
true
;
}
}
}
this
-
>
expire
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
)
;
return
true
;
}
#
if
GR_ALLOCATION_SPEW
void
GrResourceAllocator
:
:
dumpIntervals
(
)
{
unsigned
int
min
=
fNumOps
+
1
;
unsigned
int
max
=
0
;
for
(
const
Interval
*
cur
=
fIntvlList
.
peekHead
(
)
;
cur
;
cur
=
cur
-
>
next
(
)
)
{
SkDebugf
(
"
{
%
3d
%
3d
}
:
[
%
2d
%
2d
]
-
proxyRefs
:
%
d
surfaceRefs
:
%
d
R
:
%
d
W
:
%
d
\
n
"
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
?
cur
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
.
asUInt
(
)
:
-
1
cur
-
>
start
(
)
cur
-
>
end
(
)
cur
-
>
proxy
(
)
-
>
priv
(
)
.
getProxyRefCnt
(
)
cur
-
>
proxy
(
)
-
>
getBackingRefCnt_TestOnly
(
)
cur
-
>
proxy
(
)
-
>
getPendingReadCnt_TestOnly
(
)
cur
-
>
proxy
(
)
-
>
getPendingWriteCnt_TestOnly
(
)
)
;
min
=
SkTMin
(
min
cur
-
>
start
(
)
)
;
max
=
SkTMax
(
max
cur
-
>
end
(
)
)
;
}
for
(
const
Interval
*
cur
=
fIntvlList
.
peekHead
(
)
;
cur
;
cur
=
cur
-
>
next
(
)
)
{
SkDebugf
(
"
{
%
3d
%
3d
}
:
"
cur
-
>
proxy
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
cur
-
>
proxy
(
)
-
>
isInstantiated
(
)
?
cur
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
.
asUInt
(
)
:
-
1
)
;
for
(
unsigned
int
i
=
min
;
i
<
=
max
;
+
+
i
)
{
if
(
i
>
=
cur
-
>
start
(
)
&
&
i
<
=
cur
-
>
end
(
)
)
{
SkDebugf
(
"
x
"
)
;
}
else
{
SkDebugf
(
"
"
)
;
}
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
