#
include
"
GrResourceAllocator
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrRenderTargetProxy
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSurfacePriv
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTextureProxy
.
h
"
void
GrResourceAllocator
:
:
Interval
:
:
assign
(
sk_sp
<
GrSurface
>
s
)
{
SkASSERT
(
!
fAssignedSurface
)
;
fAssignedSurface
=
s
;
fProxy
-
>
priv
(
)
.
assign
(
std
:
:
move
(
s
)
)
;
}
void
GrResourceAllocator
:
:
markEndOfOpList
(
int
opListIndex
)
{
SkASSERT
(
!
fAssigned
)
;
SkASSERT
(
fEndOfOpListOpIndices
.
count
(
)
=
=
opListIndex
)
;
if
(
!
fEndOfOpListOpIndices
.
empty
(
)
)
{
SkASSERT
(
fEndOfOpListOpIndices
.
back
(
)
<
this
-
>
curOp
(
)
)
;
}
fEndOfOpListOpIndices
.
push_back
(
this
-
>
curOp
(
)
)
;
}
GrResourceAllocator
:
:
~
GrResourceAllocator
(
)
{
SkASSERT
(
fIntvlList
.
empty
(
)
)
;
SkASSERT
(
fActiveIntvls
.
empty
(
)
)
;
SkASSERT
(
!
fIntvlHash
.
count
(
)
)
;
}
void
GrResourceAllocator
:
:
addInterval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
SkDEBUGCODE
(
bool
isDirectDstRead
)
)
{
SkASSERT
(
start
<
=
end
)
;
SkASSERT
(
!
fAssigned
)
;
if
(
Interval
*
intvl
=
fIntvlHash
.
find
(
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
)
)
{
#
ifdef
SK_DEBUG
if
(
0
=
=
start
&
&
0
=
=
end
)
{
SkASSERT
(
0
=
=
intvl
-
>
start
(
)
)
;
}
else
if
(
isDirectDstRead
)
{
SkASSERT
(
intvl
-
>
start
(
)
<
=
start
&
&
intvl
-
>
end
(
)
>
=
end
)
;
}
else
{
SkASSERT
(
intvl
-
>
end
(
)
<
=
start
&
&
intvl
-
>
end
(
)
<
=
end
)
;
}
#
endif
intvl
-
>
extendEnd
(
end
)
;
return
;
}
Interval
*
newIntvl
;
if
(
fFreeIntervalList
)
{
newIntvl
=
fFreeIntervalList
;
fFreeIntervalList
=
newIntvl
-
>
next
(
)
;
newIntvl
-
>
resetTo
(
proxy
start
end
)
;
}
else
{
newIntvl
=
fIntervalAllocator
.
make
<
Interval
>
(
proxy
start
end
)
;
}
fIntvlList
.
insertByIncreasingStart
(
newIntvl
)
;
fIntvlHash
.
add
(
newIntvl
)
;
if
(
!
fResourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
if
(
GrSurfaceProxy
:
:
LazyState
:
:
kNot
!
=
proxy
-
>
lazyInstantiationState
(
)
)
{
proxy
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
;
}
}
}
GrResourceAllocator
:
:
Interval
*
GrResourceAllocator
:
:
IntervalList
:
:
popHead
(
)
{
Interval
*
temp
=
fHead
;
if
(
temp
)
{
fHead
=
temp
-
>
next
(
)
;
}
return
temp
;
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingStart
(
Interval
*
intvl
)
{
if
(
!
fHead
)
{
intvl
-
>
setNext
(
nullptr
)
;
fHead
=
intvl
;
}
else
if
(
intvl
-
>
start
(
)
<
=
fHead
-
>
start
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
next
&
&
intvl
-
>
start
(
)
>
next
-
>
start
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
}
void
GrResourceAllocator
:
:
IntervalList
:
:
insertByIncreasingEnd
(
Interval
*
intvl
)
{
if
(
!
fHead
)
{
intvl
-
>
setNext
(
nullptr
)
;
fHead
=
intvl
;
}
else
if
(
intvl
-
>
end
(
)
<
=
fHead
-
>
end
(
)
)
{
intvl
-
>
setNext
(
fHead
)
;
fHead
=
intvl
;
}
else
{
Interval
*
prev
=
fHead
;
Interval
*
next
=
prev
-
>
next
(
)
;
for
(
;
next
&
&
intvl
-
>
end
(
)
>
next
-
>
end
(
)
;
prev
=
next
next
=
next
-
>
next
(
)
)
{
}
intvl
-
>
setNext
(
next
)
;
prev
-
>
setNext
(
intvl
)
;
}
}
GrResourceAllocator
:
:
Interval
*
GrResourceAllocator
:
:
IntervalList
:
:
detachAll
(
)
{
Interval
*
tmp
=
fHead
;
fHead
=
nullptr
;
return
tmp
;
}
void
GrResourceAllocator
:
:
freeUpSurface
(
sk_sp
<
GrSurface
>
surface
)
{
const
GrScratchKey
&
key
=
surface
-
>
resourcePriv
(
)
.
getScratchKey
(
)
;
if
(
!
key
.
isValid
(
)
)
{
return
;
}
if
(
surface
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
return
;
}
fFreePool
.
insert
(
key
surface
.
release
(
)
)
;
}
sk_sp
<
GrSurface
>
GrResourceAllocator
:
:
findSurfaceFor
(
const
GrSurfaceProxy
*
proxy
bool
needsStencil
)
{
GrScratchKey
key
;
proxy
-
>
priv
(
)
.
computeScratchKey
(
&
key
)
;
auto
filter
=
[
&
]
(
const
GrSurface
*
s
)
{
return
!
proxy
-
>
priv
(
)
.
requiresNoPendingIO
(
)
|
|
!
s
-
>
surfacePriv
(
)
.
hasPendingIO
(
)
;
}
;
sk_sp
<
GrSurface
>
surface
(
fFreePool
.
findAndRemove
(
key
filter
)
)
;
if
(
surface
)
{
if
(
SkBudgeted
:
:
kYes
=
=
proxy
-
>
isBudgeted
(
)
&
&
SkBudgeted
:
:
kNo
=
=
surface
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
{
surface
-
>
resourcePriv
(
)
.
makeBudgeted
(
)
;
}
GrSurfaceProxyPriv
:
:
AttachStencilIfNeeded
(
fResourceProvider
surface
.
get
(
)
needsStencil
)
;
return
surface
;
}
return
proxy
-
>
priv
(
)
.
createSurface
(
fResourceProvider
)
;
}
void
GrResourceAllocator
:
:
expire
(
unsigned
int
curIndex
)
{
while
(
!
fActiveIntvls
.
empty
(
)
&
&
fActiveIntvls
.
peekHead
(
)
-
>
end
(
)
<
curIndex
)
{
Interval
*
temp
=
fActiveIntvls
.
popHead
(
)
;
if
(
temp
-
>
wasAssignedSurface
(
)
)
{
this
-
>
freeUpSurface
(
temp
-
>
detachSurface
(
)
)
;
}
temp
-
>
setNext
(
fFreeIntervalList
)
;
fFreeIntervalList
=
temp
;
}
}
bool
GrResourceAllocator
:
:
assign
(
int
*
startIndex
int
*
stopIndex
AssignError
*
outError
)
{
SkASSERT
(
outError
)
;
*
outError
=
AssignError
:
:
kNoError
;
fIntvlHash
.
reset
(
)
;
if
(
fIntvlList
.
empty
(
)
)
{
return
false
;
}
*
startIndex
=
fCurOpListIndex
;
*
stopIndex
=
fEndOfOpListOpIndices
.
count
(
)
;
if
(
!
fResourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
fIntvlList
.
detachAll
(
)
;
return
true
;
}
SkDEBUGCODE
(
fAssigned
=
true
;
)
while
(
Interval
*
cur
=
fIntvlList
.
popHead
(
)
)
{
if
(
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
cur
-
>
start
(
)
)
{
fCurOpListIndex
+
+
;
}
this
-
>
expire
(
cur
-
>
start
(
)
)
;
bool
needsStencil
=
cur
-
>
proxy
(
)
-
>
asRenderTargetProxy
(
)
?
cur
-
>
proxy
(
)
-
>
asRenderTargetProxy
(
)
-
>
needsStencil
(
)
:
false
;
if
(
cur
-
>
proxy
(
)
-
>
priv
(
)
.
isInstantiated
(
)
)
{
GrSurfaceProxyPriv
:
:
AttachStencilIfNeeded
(
fResourceProvider
cur
-
>
proxy
(
)
-
>
priv
(
)
.
peekSurface
(
)
needsStencil
)
;
fActiveIntvls
.
insertByIncreasingEnd
(
cur
)
;
if
(
fResourceProvider
-
>
overBudget
(
)
)
{
if
(
!
fIntvlList
.
empty
(
)
&
&
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
fIntvlList
.
peekHead
(
)
-
>
start
(
)
)
{
*
stopIndex
=
fCurOpListIndex
+
1
;
return
true
;
}
}
continue
;
}
if
(
GrSurfaceProxy
:
:
LazyState
:
:
kNot
!
=
cur
-
>
proxy
(
)
-
>
lazyInstantiationState
(
)
)
{
if
(
!
cur
-
>
proxy
(
)
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
)
{
*
outError
=
AssignError
:
:
kFailedProxyInstantiation
;
}
}
else
if
(
sk_sp
<
GrSurface
>
surface
=
this
-
>
findSurfaceFor
(
cur
-
>
proxy
(
)
needsStencil
)
)
{
GrTextureProxy
*
tex
=
cur
-
>
proxy
(
)
-
>
asTextureProxy
(
)
;
if
(
tex
&
&
tex
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
fResourceProvider
-
>
assignUniqueKeyToResource
(
tex
-
>
getUniqueKey
(
)
surface
.
get
(
)
)
;
SkASSERT
(
surface
-
>
getUniqueKey
(
)
=
=
tex
-
>
getUniqueKey
(
)
)
;
}
cur
-
>
assign
(
std
:
:
move
(
surface
)
)
;
}
else
{
SkASSERT
(
!
cur
-
>
proxy
(
)
-
>
priv
(
)
.
isInstantiated
(
)
)
;
*
outError
=
AssignError
:
:
kFailedProxyInstantiation
;
}
fActiveIntvls
.
insertByIncreasingEnd
(
cur
)
;
if
(
fResourceProvider
-
>
overBudget
(
)
)
{
if
(
!
fIntvlList
.
empty
(
)
&
&
fEndOfOpListOpIndices
[
fCurOpListIndex
]
<
fIntvlList
.
peekHead
(
)
-
>
start
(
)
)
{
*
stopIndex
=
fCurOpListIndex
+
1
;
return
true
;
}
}
}
this
-
>
expire
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
)
;
return
true
;
}
