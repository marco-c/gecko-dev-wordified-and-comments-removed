#
ifndef
GrBufferAllocPool_DEFINED
#
define
GrBufferAllocPool_DEFINED
#
include
"
SkTArray
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTypes
.
h
"
class
GrGeometryBuffer
;
class
GrGpu
;
class
GrBufferAllocPool
:
SkNoncopyable
{
public
:
void
unmap
(
)
;
void
reset
(
)
;
void
putBack
(
size_t
bytes
)
;
protected
:
enum
BufferType
{
kVertex_BufferType
kIndex_BufferType
}
;
GrBufferAllocPool
(
GrGpu
*
gpu
BufferType
bufferType
size_t
bufferSize
=
0
)
;
virtual
~
GrBufferAllocPool
(
)
;
void
*
makeSpace
(
size_t
size
size_t
alignment
const
GrGeometryBuffer
*
*
buffer
size_t
*
offset
)
;
GrGeometryBuffer
*
getBuffer
(
size_t
size
)
;
private
:
struct
BufferBlock
{
size_t
fBytesFree
;
GrGeometryBuffer
*
fBuffer
;
}
;
bool
createBlock
(
size_t
requestSize
)
;
void
destroyBlock
(
)
;
void
deleteBlocks
(
)
;
void
flushCpuData
(
const
BufferBlock
&
block
size_t
flushSize
)
;
void
*
resetCpuData
(
size_t
newSize
)
;
#
ifdef
SK_DEBUG
void
validate
(
bool
unusedBlockAllowed
=
false
)
const
;
#
endif
size_t
fBytesInUse
;
GrGpu
*
fGpu
;
size_t
fMinBlockSize
;
BufferType
fBufferType
;
SkTArray
<
BufferBlock
>
fBlocks
;
void
*
fCpuData
;
void
*
fBufferPtr
;
size_t
fGeometryBufferMapThreshold
;
}
;
class
GrVertexBuffer
;
class
GrVertexBufferAllocPool
:
public
GrBufferAllocPool
{
public
:
GrVertexBufferAllocPool
(
GrGpu
*
gpu
)
;
void
*
makeSpace
(
size_t
vertexSize
int
vertexCount
const
GrVertexBuffer
*
*
buffer
int
*
startVertex
)
;
private
:
typedef
GrBufferAllocPool
INHERITED
;
}
;
class
GrIndexBuffer
;
class
GrIndexBufferAllocPool
:
public
GrBufferAllocPool
{
public
:
GrIndexBufferAllocPool
(
GrGpu
*
gpu
)
;
void
*
makeSpace
(
int
indexCount
const
GrIndexBuffer
*
*
buffer
int
*
startIndex
)
;
private
:
typedef
GrBufferAllocPool
INHERITED
;
}
;
#
endif
