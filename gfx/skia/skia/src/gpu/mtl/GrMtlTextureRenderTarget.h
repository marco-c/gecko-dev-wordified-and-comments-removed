#
ifndef
GrMtlTextureRenderTarget_DEFINED
#
define
GrMtlTextureRenderTarget_DEFINED
#
include
"
GrMtlRenderTarget
.
h
"
#
include
"
GrMtlTexture
.
h
"
class
GrMtlTextureRenderTarget
:
public
GrMtlTexture
public
GrMtlRenderTarget
{
public
:
static
sk_sp
<
GrMtlTextureRenderTarget
>
CreateNewTextureRenderTarget
(
GrMtlGpu
*
SkBudgeted
const
GrSurfaceDesc
&
MTLTextureDescriptor
*
GrMipMapsStatus
)
;
static
sk_sp
<
GrMtlTextureRenderTarget
>
MakeWrappedTextureRenderTarget
(
GrMtlGpu
*
const
GrSurfaceDesc
&
id
<
MTLTexture
>
GrWrapCacheable
)
;
GrBackendFormat
backendFormat
(
)
const
override
{
return
GrMtlTexture
:
:
backendFormat
(
)
;
}
protected
:
void
onAbandon
(
)
override
{
GrMtlRenderTarget
:
:
onAbandon
(
)
;
GrMtlTexture
:
:
onAbandon
(
)
;
}
void
onRelease
(
)
override
{
GrMtlRenderTarget
:
:
onRelease
(
)
;
GrMtlTexture
:
:
onRelease
(
)
;
}
private
:
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
SkBudgeted
budgeted
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
renderTexture
id
<
MTLTexture
>
resolveTexture
GrMipMapsStatus
)
;
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
SkBudgeted
budgeted
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
renderTexture
GrMipMapsStatus
)
;
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
renderTexture
id
<
MTLTexture
>
resolveTexture
GrMipMapsStatus
)
;
GrMtlTextureRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
renderTexture
GrMipMapsStatus
GrWrapCacheable
cacheable
)
;
size_t
onGpuMemorySize
(
)
const
override
{
int
numColorSamples
=
this
-
>
numColorSamples
(
)
;
if
(
numColorSamples
>
1
)
{
+
+
numColorSamples
;
}
return
GrSurface
:
:
ComputeSize
(
this
-
>
config
(
)
this
-
>
width
(
)
this
-
>
height
(
)
numColorSamples
GrMipMapped
:
:
kNo
false
)
;
}
}
;
#
endif
