#
ifndef
GrMtlRenderTarget_DEFINED
#
define
GrMtlRenderTarget_DEFINED
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
src
/
gpu
/
GrGpu
.
h
"
#
import
<
Metal
/
Metal
.
h
>
class
GrMtlGpu
;
class
GrMtlRenderTarget
:
public
GrRenderTarget
{
public
:
static
sk_sp
<
GrMtlRenderTarget
>
MakeWrappedRenderTarget
(
GrMtlGpu
*
const
GrSurfaceDesc
&
int
sampleCnt
id
<
MTLTexture
>
)
;
~
GrMtlRenderTarget
(
)
override
;
bool
canAttemptStencilAttachment
(
)
const
override
{
return
true
;
}
id
<
MTLTexture
>
mtlColorTexture
(
)
const
{
return
fColorTexture
;
}
id
<
MTLTexture
>
mtlResolveTexture
(
)
const
{
return
fResolveTexture
;
}
GrBackendRenderTarget
getBackendRenderTarget
(
)
const
override
;
GrBackendFormat
backendFormat
(
)
const
override
;
protected
:
GrMtlRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
int
sampleCnt
id
<
MTLTexture
>
colorTexture
id
<
MTLTexture
>
resolveTexture
)
;
GrMtlRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
colorTexture
)
;
GrMtlGpu
*
getMtlGpu
(
)
const
;
void
onAbandon
(
)
override
;
void
onRelease
(
)
override
;
size_t
onGpuMemorySize
(
)
const
override
{
int
numColorSamples
=
this
-
>
numSamples
(
)
;
if
(
numColorSamples
>
1
)
{
+
+
numColorSamples
;
}
const
GrCaps
&
caps
=
*
this
-
>
getGpu
(
)
-
>
caps
(
)
;
return
GrSurface
:
:
ComputeSize
(
caps
this
-
>
backendFormat
(
)
this
-
>
width
(
)
this
-
>
height
(
)
numColorSamples
GrMipMapped
:
:
kNo
)
;
}
id
<
MTLTexture
>
fColorTexture
;
id
<
MTLTexture
>
fResolveTexture
;
private
:
enum
Wrapped
{
kWrapped
}
;
GrMtlRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
int
sampleCnt
id
<
MTLTexture
>
colorTexture
id
<
MTLTexture
>
resolveTexture
Wrapped
)
;
GrMtlRenderTarget
(
GrMtlGpu
*
gpu
const
GrSurfaceDesc
&
desc
id
<
MTLTexture
>
colorTexture
Wrapped
)
;
bool
completeStencilAttachment
(
)
override
;
typedef
GrRenderTarget
INHERITED
;
}
;
#
endif
