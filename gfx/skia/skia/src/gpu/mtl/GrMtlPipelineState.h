#
ifndef
GrMtlPipelineState_DEFINED
#
define
GrMtlPipelineState_DEFINED
#
include
"
GrMtlBuffer
.
h
"
#
include
"
GrMtlPipelineStateDataManager
.
h
"
#
include
"
GrStencilSettings
.
h
"
#
include
"
GrTypesPriv
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
import
<
metal
/
metal
.
h
>
class
GrMtlGpu
;
class
GrMtlPipelineStateDataManager
;
class
GrMtlSampler
;
class
GrMtlTexture
;
class
GrPipeline
;
class
GrMtlPipelineState
{
public
:
using
UniformInfoArray
=
GrMtlPipelineStateDataManager
:
:
UniformInfoArray
;
using
UniformHandle
=
GrGLSLProgramDataManager
:
:
UniformHandle
;
GrMtlPipelineState
(
GrMtlGpu
*
gpu
id
<
MTLRenderPipelineState
>
pipelineState
MTLPixelFormat
pixelFormat
const
GrGLSLBuiltinUniformHandles
&
builtinUniformHandles
const
UniformInfoArray
&
uniforms
GrMtlBuffer
*
geometryUniformBuffer
GrMtlBuffer
*
fragmentUniformBuffer
uint32_t
numSamplers
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
geometryProcessor
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
xferPRocessor
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fragmentProcessors
int
fFragmentProcessorCnt
)
;
id
<
MTLRenderPipelineState
>
mtlPipelineState
(
)
{
return
fPipelineState
;
}
void
setData
(
const
GrPrimitiveProcessor
&
primPRoc
const
GrPipeline
&
pipeline
const
GrTextureProxy
*
const
primProcTextures
[
]
)
;
void
bind
(
id
<
MTLRenderCommandEncoder
>
)
;
void
setBlendConstants
(
id
<
MTLRenderCommandEncoder
>
GrPixelConfig
const
GrXferProcessor
&
)
;
void
setDepthStencilState
(
id
<
MTLRenderCommandEncoder
>
renderCmdEncoder
)
;
private
:
struct
RenderTargetState
{
SkISize
fRenderTargetSize
;
GrSurfaceOrigin
fRenderTargetOrigin
;
RenderTargetState
(
)
{
this
-
>
invalidate
(
)
;
}
void
invalidate
(
)
{
fRenderTargetSize
.
fWidth
=
-
1
;
fRenderTargetSize
.
fHeight
=
-
1
;
fRenderTargetOrigin
=
(
GrSurfaceOrigin
)
-
1
;
}
void
getRTAdjustmentVec
(
float
*
destVec
)
{
destVec
[
0
]
=
2
.
f
/
fRenderTargetSize
.
fWidth
;
destVec
[
1
]
=
-
1
.
f
;
if
(
kBottomLeft_GrSurfaceOrigin
=
=
fRenderTargetOrigin
)
{
destVec
[
2
]
=
-
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
1
.
f
;
}
else
{
destVec
[
2
]
=
2
.
f
/
fRenderTargetSize
.
fHeight
;
destVec
[
3
]
=
-
1
.
f
;
}
}
}
;
void
setRenderTargetState
(
const
GrRenderTargetProxy
*
)
;
struct
SamplerBindings
{
id
<
MTLSamplerState
>
fSampler
;
id
<
MTLTexture
>
fTexture
;
SamplerBindings
(
const
GrSamplerState
&
state
GrTexture
*
texture
GrMtlGpu
*
)
;
}
;
GrMtlGpu
*
fGpu
;
id
<
MTLRenderPipelineState
>
fPipelineState
;
MTLPixelFormat
fPixelFormat
;
RenderTargetState
fRenderTargetState
;
GrGLSLBuiltinUniformHandles
fBuiltinUniformHandles
;
GrStencilSettings
fStencil
;
sk_sp
<
GrMtlBuffer
>
fGeometryUniformBuffer
;
sk_sp
<
GrMtlBuffer
>
fFragmentUniformBuffer
;
int
fNumSamplers
;
SkTArray
<
SamplerBindings
>
fSamplerBindings
;
std
:
:
unique_ptr
<
GrGLSLPrimitiveProcessor
>
fGeometryProcessor
;
std
:
:
unique_ptr
<
GrGLSLXferProcessor
>
fXferProcessor
;
std
:
:
unique_ptr
<
std
:
:
unique_ptr
<
GrGLSLFragmentProcessor
>
[
]
>
fFragmentProcessors
;
int
fFragmentProcessorCnt
;
GrMtlPipelineStateDataManager
fDataManager
;
}
;
#
endif
