#
ifndef
GrResourceAllocator_DEFINED
#
define
GrResourceAllocator_DEFINED
#
include
"
include
/
gpu
/
GrSurface
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkTDynamicHash
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
class
GrResourceProvider
;
#
define
GR_ALLOCATION_SPEW
0
#
define
GR_TRACK_INTERVAL_CREATION
0
class
GrResourceAllocator
{
public
:
GrResourceAllocator
(
GrResourceProvider
*
resourceProvider
SkDEBUGCODE
(
int
numOpsTasks
)
)
:
fResourceProvider
(
resourceProvider
)
SkDEBUGCODE
(
fNumOpsTasks
(
numOpsTasks
)
)
{
}
~
GrResourceAllocator
(
)
;
unsigned
int
curOp
(
)
const
{
return
fNumOps
;
}
void
incOps
(
)
{
fNumOps
+
+
;
}
enum
class
ActualUse
:
bool
{
kNo
=
false
kYes
=
true
}
;
void
addInterval
(
GrSurfaceProxy
*
unsigned
int
start
unsigned
int
end
ActualUse
actualUse
SkDEBUGCODE
(
bool
isDirectDstRead
=
false
)
)
;
enum
class
AssignError
{
kNoError
kFailedProxyInstantiation
}
;
bool
assign
(
int
*
startIndex
int
*
stopIndex
AssignError
*
outError
)
;
void
determineRecyclability
(
)
;
void
markEndOfOpsTask
(
int
opsTaskIndex
)
;
#
if
GR_ALLOCATION_SPEW
void
dumpIntervals
(
)
;
#
endif
private
:
class
Interval
;
void
expire
(
unsigned
int
curIndex
)
;
bool
onOpsTaskBoundary
(
)
const
;
void
forceIntermediateFlush
(
int
*
stopIndex
)
;
void
recycleSurface
(
sk_sp
<
GrSurface
>
surface
)
;
sk_sp
<
GrSurface
>
findSurfaceFor
(
const
GrSurfaceProxy
*
proxy
int
minStencilSampleCount
)
;
struct
FreePoolTraits
{
static
const
GrScratchKey
&
GetKey
(
const
GrSurface
&
s
)
{
return
s
.
resourcePriv
(
)
.
getScratchKey
(
)
;
}
static
uint32_t
Hash
(
const
GrScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
static
void
OnFree
(
GrSurface
*
s
)
{
s
-
>
unref
(
)
;
}
}
;
typedef
SkTMultiMap
<
GrSurface
GrScratchKey
FreePoolTraits
>
FreePoolMultiMap
;
typedef
SkTDynamicHash
<
Interval
unsigned
int
>
IntvlHash
;
class
Interval
{
public
:
Interval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
)
:
fProxy
(
proxy
)
fProxyID
(
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
)
fStart
(
start
)
fEnd
(
end
)
fNext
(
nullptr
)
{
SkASSERT
(
proxy
)
;
#
if
GR_TRACK_INTERVAL_CREATION
fUniqueID
=
CreateUniqueID
(
)
;
SkDebugf
(
"
New
intvl
%
d
:
proxyID
:
%
d
[
%
d
%
d
]
\
n
"
fUniqueID
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
start
end
)
;
#
endif
}
void
resetTo
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
)
{
SkASSERT
(
proxy
)
;
SkASSERT
(
!
fProxy
&
&
!
fNext
)
;
fUses
=
0
;
fProxy
=
proxy
;
fProxyID
=
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
;
fStart
=
start
;
fEnd
=
end
;
fNext
=
nullptr
;
#
if
GR_TRACK_INTERVAL_CREATION
fUniqueID
=
CreateUniqueID
(
)
;
SkDebugf
(
"
New
intvl
%
d
:
proxyID
:
%
d
[
%
d
%
d
]
\
n
"
fUniqueID
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
start
end
)
;
#
endif
}
~
Interval
(
)
{
SkASSERT
(
!
fAssignedSurface
)
;
}
const
GrSurfaceProxy
*
proxy
(
)
const
{
return
fProxy
;
}
GrSurfaceProxy
*
proxy
(
)
{
return
fProxy
;
}
unsigned
int
start
(
)
const
{
return
fStart
;
}
unsigned
int
end
(
)
const
{
return
fEnd
;
}
void
setNext
(
Interval
*
next
)
{
fNext
=
next
;
}
const
Interval
*
next
(
)
const
{
return
fNext
;
}
Interval
*
next
(
)
{
return
fNext
;
}
void
markAsRecyclable
(
)
{
fIsRecyclable
=
true
;
}
bool
isRecyclable
(
)
const
{
return
fIsRecyclable
;
}
void
addUse
(
)
{
fUses
+
+
;
}
int
uses
(
)
{
return
fUses
;
}
void
extendEnd
(
unsigned
int
newEnd
)
{
if
(
newEnd
>
fEnd
)
{
fEnd
=
newEnd
;
#
if
GR_TRACK_INTERVAL_CREATION
SkDebugf
(
"
intvl
%
d
:
extending
from
%
d
to
%
d
\
n
"
fUniqueID
fEnd
newEnd
)
;
#
endif
}
}
void
assign
(
sk_sp
<
GrSurface
>
)
;
bool
wasAssignedSurface
(
)
const
{
return
fAssignedSurface
!
=
nullptr
;
}
sk_sp
<
GrSurface
>
detachSurface
(
)
{
return
std
:
:
move
(
fAssignedSurface
)
;
}
static
const
uint32_t
&
GetKey
(
const
Interval
&
intvl
)
{
return
intvl
.
fProxyID
;
}
static
uint32_t
Hash
(
const
uint32_t
&
key
)
{
return
key
;
}
private
:
sk_sp
<
GrSurface
>
fAssignedSurface
;
GrSurfaceProxy
*
fProxy
;
uint32_t
fProxyID
;
unsigned
int
fStart
;
unsigned
int
fEnd
;
Interval
*
fNext
;
unsigned
int
fUses
=
0
;
bool
fIsRecyclable
=
false
;
#
if
GR_TRACK_INTERVAL_CREATION
uint32_t
fUniqueID
;
uint32_t
CreateUniqueID
(
)
;
#
endif
}
;
class
IntervalList
{
public
:
IntervalList
(
)
=
default
;
~
IntervalList
(
)
{
}
bool
empty
(
)
const
{
SkASSERT
(
SkToBool
(
fHead
)
=
=
SkToBool
(
fTail
)
)
;
return
!
SkToBool
(
fHead
)
;
}
const
Interval
*
peekHead
(
)
const
{
return
fHead
;
}
Interval
*
peekHead
(
)
{
return
fHead
;
}
Interval
*
popHead
(
)
;
void
insertByIncreasingStart
(
Interval
*
)
;
void
insertByIncreasingEnd
(
Interval
*
)
;
Interval
*
detachAll
(
)
;
private
:
SkDEBUGCODE
(
void
validate
(
)
const
;
)
Interval
*
fHead
=
nullptr
;
Interval
*
fTail
=
nullptr
;
}
;
static
const
int
kInitialArenaSize
=
128
*
sizeof
(
Interval
)
;
GrResourceProvider
*
fResourceProvider
;
FreePoolMultiMap
fFreePool
;
IntvlHash
fIntvlHash
;
IntervalList
fIntvlList
;
IntervalList
fActiveIntvls
;
unsigned
int
fNumOps
=
0
;
SkTArray
<
unsigned
int
>
fEndOfOpsTaskOpIndices
;
int
fCurOpsTaskIndex
=
0
;
SkDEBUGCODE
(
const
int
fNumOpsTasks
=
-
1
;
)
SkDEBUGCODE
(
bool
fAssigned
=
false
;
)
char
fStorage
[
kInitialArenaSize
]
;
SkArenaAlloc
fIntervalAllocator
{
fStorage
kInitialArenaSize
kInitialArenaSize
}
;
Interval
*
fFreeIntervalList
=
nullptr
;
bool
fLazyInstantiationError
=
false
;
}
;
#
endif
