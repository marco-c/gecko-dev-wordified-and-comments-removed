#
ifndef
GrResourceAllocator_DEFINED
#
define
GrResourceAllocator_DEFINED
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrSurface
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkTDynamicHash
.
h
"
#
include
"
SkTMultiMap
.
h
"
class
GrResourceProvider
;
class
GrUninstantiateProxyTracker
;
#
define
GR_ALLOCATION_SPEW
0
#
define
GR_TRACK_INTERVAL_CREATION
0
class
GrResourceAllocator
{
public
:
GrResourceAllocator
(
GrResourceProvider
*
resourceProvider
)
:
fResourceProvider
(
resourceProvider
)
{
}
~
GrResourceAllocator
(
)
;
unsigned
int
curOp
(
)
const
{
return
fNumOps
;
}
void
incOps
(
)
{
fNumOps
+
+
;
}
unsigned
int
numOps
(
)
const
{
return
fNumOps
;
}
void
addInterval
(
GrSurfaceProxy
*
unsigned
int
start
unsigned
int
end
SkDEBUGCODE
(
bool
isDirectDstRead
=
false
)
)
;
void
addInterval
(
GrSurfaceProxy
*
proxy
SkDEBUGCODE
(
bool
isDirectDstRead
=
false
)
)
{
this
-
>
addInterval
(
proxy
fNumOps
fNumOps
SkDEBUGCODE
(
isDirectDstRead
)
)
;
}
enum
class
AssignError
{
kNoError
kFailedProxyInstantiation
}
;
bool
assign
(
int
*
startIndex
int
*
stopIndex
GrUninstantiateProxyTracker
*
AssignError
*
outError
)
;
void
markEndOfOpList
(
int
opListIndex
)
;
#
if
GR_ALLOCATION_SPEW
void
dumpIntervals
(
)
;
#
endif
private
:
class
Interval
;
void
expire
(
unsigned
int
curIndex
)
;
void
recycleSurface
(
sk_sp
<
GrSurface
>
surface
)
;
sk_sp
<
GrSurface
>
findSurfaceFor
(
const
GrSurfaceProxy
*
proxy
bool
needsStencil
)
;
struct
FreePoolTraits
{
static
const
GrScratchKey
&
GetKey
(
const
GrSurface
&
s
)
{
return
s
.
resourcePriv
(
)
.
getScratchKey
(
)
;
}
static
uint32_t
Hash
(
const
GrScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
static
void
OnFree
(
GrSurface
*
s
)
{
s
-
>
unref
(
)
;
}
}
;
typedef
SkTMultiMap
<
GrSurface
GrScratchKey
FreePoolTraits
>
FreePoolMultiMap
;
typedef
SkTDynamicHash
<
Interval
unsigned
int
>
IntvlHash
;
class
Interval
{
public
:
Interval
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
)
:
fProxy
(
proxy
)
fProxyID
(
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
)
fStart
(
start
)
fEnd
(
end
)
fNext
(
nullptr
)
{
SkASSERT
(
proxy
)
;
#
if
GR_TRACK_INTERVAL_CREATION
fUniqueID
=
CreateUniqueID
(
)
;
SkDebugf
(
"
New
intvl
%
d
:
proxyID
:
%
d
[
%
d
%
d
]
\
n
"
fUniqueID
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
start
end
)
;
#
endif
}
void
resetTo
(
GrSurfaceProxy
*
proxy
unsigned
int
start
unsigned
int
end
)
{
SkASSERT
(
proxy
)
;
SkASSERT
(
!
fNext
)
;
fProxy
=
proxy
;
fProxyID
=
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
;
fStart
=
start
;
fEnd
=
end
;
fNext
=
nullptr
;
#
if
GR_TRACK_INTERVAL_CREATION
fUniqueID
=
CreateUniqueID
(
)
;
SkDebugf
(
"
New
intvl
%
d
:
proxyID
:
%
d
[
%
d
%
d
]
\
n
"
fUniqueID
proxy
-
>
uniqueID
(
)
.
asUInt
(
)
start
end
)
;
#
endif
}
~
Interval
(
)
{
SkASSERT
(
!
fAssignedSurface
)
;
}
const
GrSurfaceProxy
*
proxy
(
)
const
{
return
fProxy
;
}
GrSurfaceProxy
*
proxy
(
)
{
return
fProxy
;
}
unsigned
int
start
(
)
const
{
return
fStart
;
}
unsigned
int
end
(
)
const
{
return
fEnd
;
}
const
Interval
*
next
(
)
const
{
return
fNext
;
}
Interval
*
next
(
)
{
return
fNext
;
}
void
setNext
(
Interval
*
next
)
{
fNext
=
next
;
}
void
extendEnd
(
unsigned
int
newEnd
)
{
if
(
newEnd
>
fEnd
)
{
fEnd
=
newEnd
;
#
if
GR_TRACK_INTERVAL_CREATION
SkDebugf
(
"
intvl
%
d
:
extending
from
%
d
to
%
d
\
n
"
fUniqueID
fEnd
newEnd
)
;
#
endif
}
}
void
assign
(
sk_sp
<
GrSurface
>
)
;
bool
wasAssignedSurface
(
)
const
{
return
fAssignedSurface
!
=
nullptr
;
}
sk_sp
<
GrSurface
>
detachSurface
(
)
{
return
std
:
:
move
(
fAssignedSurface
)
;
}
static
const
uint32_t
&
GetKey
(
const
Interval
&
intvl
)
{
return
intvl
.
fProxyID
;
}
static
uint32_t
Hash
(
const
uint32_t
&
key
)
{
return
key
;
}
private
:
sk_sp
<
GrSurface
>
fAssignedSurface
;
GrSurfaceProxy
*
fProxy
;
uint32_t
fProxyID
;
unsigned
int
fStart
;
unsigned
int
fEnd
;
Interval
*
fNext
;
#
if
GR_TRACK_INTERVAL_CREATION
uint32_t
fUniqueID
;
uint32_t
CreateUniqueID
(
)
;
#
endif
}
;
class
IntervalList
{
public
:
IntervalList
(
)
=
default
;
~
IntervalList
(
)
{
}
bool
empty
(
)
const
{
SkASSERT
(
SkToBool
(
fHead
)
=
=
SkToBool
(
fTail
)
)
;
return
!
SkToBool
(
fHead
)
;
}
const
Interval
*
peekHead
(
)
const
{
return
fHead
;
}
Interval
*
popHead
(
)
;
void
insertByIncreasingStart
(
Interval
*
)
;
void
insertByIncreasingEnd
(
Interval
*
)
;
Interval
*
detachAll
(
)
;
private
:
SkDEBUGCODE
(
void
validate
(
)
const
;
)
Interval
*
fHead
=
nullptr
;
Interval
*
fTail
=
nullptr
;
}
;
static
const
int
kInitialArenaSize
=
12
*
sizeof
(
Interval
)
;
GrResourceProvider
*
fResourceProvider
;
FreePoolMultiMap
fFreePool
;
IntvlHash
fIntvlHash
;
IntervalList
fIntvlList
;
IntervalList
fActiveIntvls
;
unsigned
int
fNumOps
=
1
;
SkTArray
<
unsigned
int
>
fEndOfOpListOpIndices
;
int
fCurOpListIndex
=
0
;
SkDEBUGCODE
(
bool
fAssigned
=
false
;
)
char
fStorage
[
kInitialArenaSize
]
;
SkArenaAlloc
fIntervalAllocator
{
fStorage
kInitialArenaSize
0
}
;
Interval
*
fFreeIntervalList
=
nullptr
;
}
;
#
endif
