#
ifndef
GrFragmentProcessor_DEFINED
#
define
GrFragmentProcessor_DEFINED
#
include
"
GrProcessor
.
h
"
class
GrCoordTransform
;
class
GrGLSLFragmentProcessor
;
class
GrInvariantOutput
;
class
GrPipeline
;
class
GrProcessorKeyBuilder
;
class
GrShaderCaps
;
class
GrSwizzle
;
class
GrFragmentProcessor
:
public
GrResourceIOProcessor
{
public
:
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MulChildByInputAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MulInputByChildAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeInputPremulAndMulByOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
OverrideInput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrColor4f
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
PremulInput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
PremulOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
UnpremulOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
SwizzleOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
GrSwizzle
&
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
RunInSeries
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
*
int
cnt
)
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
=
0
;
GrGLSLFragmentProcessor
*
createGLSLInstance
(
)
const
;
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
this
-
>
onGetGLSLProcessorKey
(
caps
b
)
;
for
(
int
i
=
0
;
i
<
fChildProcessors
.
count
(
)
;
+
+
i
)
{
fChildProcessors
[
i
]
-
>
getGLSLProcessorKey
(
caps
b
)
;
}
}
int
numCoordTransforms
(
)
const
{
return
fCoordTransforms
.
count
(
)
;
}
const
GrCoordTransform
&
coordTransform
(
int
index
)
const
{
return
*
fCoordTransforms
[
index
]
;
}
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
coordTransforms
(
)
const
{
return
fCoordTransforms
;
}
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
count
(
)
;
}
const
GrFragmentProcessor
&
childProcessor
(
int
index
)
const
{
return
*
fChildProcessors
[
index
]
;
}
bool
instantiate
(
GrResourceProvider
*
)
const
;
void
markPendingExecution
(
)
const
;
bool
usesLocalCoords
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesLocalCoords_Flag
)
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
SkToBool
(
fFlags
&
kCompatibleWithCoverageAsAlpha_OptimizationFlag
)
;
}
bool
preservesOpaqueInput
(
)
const
{
return
SkToBool
(
fFlags
&
kPreservesOpaqueInput_OptimizationFlag
)
;
}
bool
hasConstantOutputForConstantInput
(
GrColor4f
inputColor
GrColor4f
*
outputColor
)
const
{
if
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
{
*
outputColor
=
this
-
>
constantOutputForConstantInput
(
inputColor
)
;
return
true
;
}
return
false
;
}
bool
hasConstantOutputForConstantInput
(
)
const
{
return
SkToBool
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
;
}
bool
isEqual
(
const
GrFragmentProcessor
&
that
)
const
;
class
Iter
:
public
SkNoncopyable
{
public
:
explicit
Iter
(
const
GrFragmentProcessor
*
fp
)
{
fFPStack
.
push_back
(
fp
)
;
}
explicit
Iter
(
const
GrPipeline
&
pipeline
)
;
const
GrFragmentProcessor
*
next
(
)
;
private
:
SkSTArray
<
4
const
GrFragmentProcessor
*
true
>
fFPStack
;
}
;
template
<
typename
T
typename
BASE
int
(
BASE
:
:
*
COUNT
)
(
)
const
const
T
&
(
BASE
:
:
*
GET
)
(
int
)
const
>
class
FPItemIter
:
public
SkNoncopyable
{
public
:
explicit
FPItemIter
(
const
GrFragmentProcessor
*
fp
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
fp
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
explicit
FPItemIter
(
const
GrPipeline
&
pipeline
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
pipeline
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
const
T
*
next
(
)
{
if
(
!
fCurrFP
)
{
return
nullptr
;
}
while
(
fCTIdx
=
=
(
fCurrFP
-
>
*
COUNT
)
(
)
)
{
fCTIdx
=
0
;
fCurrFP
=
fFPIter
.
next
(
)
;
if
(
!
fCurrFP
)
{
return
nullptr
;
}
}
return
&
(
fCurrFP
-
>
*
GET
)
(
fCTIdx
+
+
)
;
}
private
:
const
GrFragmentProcessor
*
fCurrFP
;
int
fCTIdx
;
GrFragmentProcessor
:
:
Iter
fFPIter
;
}
;
using
CoordTransformIter
=
FPItemIter
<
GrCoordTransform
GrFragmentProcessor
&
GrFragmentProcessor
:
:
numCoordTransforms
&
GrFragmentProcessor
:
:
coordTransform
>
;
using
TextureAccessIter
=
FPItemIter
<
TextureSampler
GrResourceIOProcessor
&
GrResourceIOProcessor
:
:
numTextureSamplers
&
GrResourceIOProcessor
:
:
textureSampler
>
;
void
visitProxies
(
const
std
:
:
function
<
void
(
GrSurfaceProxy
*
)
>
&
func
)
{
GrFragmentProcessor
:
:
TextureAccessIter
iter
(
this
)
;
while
(
const
GrResourceIOProcessor
:
:
TextureSampler
*
sampler
=
iter
.
next
(
)
)
{
func
(
sampler
-
>
proxy
(
)
)
;
}
}
protected
:
enum
OptimizationFlags
:
uint32_t
{
kNone_OptimizationFlags
kCompatibleWithCoverageAsAlpha_OptimizationFlag
=
0x1
kPreservesOpaqueInput_OptimizationFlag
=
0x2
kConstantOutputForConstantInput_OptimizationFlag
=
0x4
kAll_OptimizationFlags
=
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
|
kConstantOutputForConstantInput_OptimizationFlag
}
;
GR_DECL_BITFIELD_OPS_FRIENDS
(
OptimizationFlags
)
static
OptimizationFlags
ModulateByConfigOptimizationFlags
(
GrPixelConfig
config
)
{
if
(
GrPixelConfigIsOpaque
(
config
)
)
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
;
}
else
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
;
}
}
GrFragmentProcessor
(
ClassID
classID
OptimizationFlags
optimizationFlags
)
:
INHERITED
(
classID
)
fFlags
(
optimizationFlags
)
{
SkASSERT
(
(
fFlags
&
~
kAll_OptimizationFlags
)
=
=
0
)
;
}
OptimizationFlags
optimizationFlags
(
)
const
{
return
static_cast
<
OptimizationFlags
>
(
kAll_OptimizationFlags
&
fFlags
)
;
}
static
GrColor4f
ConstantOutputForConstantInput
(
const
GrFragmentProcessor
&
fp
GrColor4f
input
)
{
SkASSERT
(
fp
.
hasConstantOutputForConstantInput
(
)
)
;
return
fp
.
constantOutputForConstantInput
(
input
)
;
}
void
addCoordTransform
(
const
GrCoordTransform
*
)
;
int
registerChildProcessor
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
private
:
virtual
GrColor4f
constantOutputForConstantInput
(
GrColor4f
)
const
{
SK_ABORT
(
"
Subclass
must
override
this
if
advertising
this
optimization
.
"
)
;
return
GrColor4f
:
:
TransparentBlack
(
)
;
}
virtual
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
=
0
;
virtual
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
=
0
;
virtual
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
=
0
;
bool
hasSameTransforms
(
const
GrFragmentProcessor
&
)
const
;
enum
PrivateFlags
{
kFirstPrivateFlag
=
kAll_OptimizationFlags
+
1
kUsesLocalCoords_Flag
=
kFirstPrivateFlag
}
;
mutable
uint32_t
fFlags
=
0
;
SkSTArray
<
4
const
GrCoordTransform
*
true
>
fCoordTransforms
;
SkSTArray
<
1
std
:
:
unique_ptr
<
GrFragmentProcessor
>
true
>
fChildProcessors
;
typedef
GrResourceIOProcessor
INHERITED
;
}
;
GR_MAKE_BITFIELD_OPS
(
GrFragmentProcessor
:
:
OptimizationFlags
)
#
endif
