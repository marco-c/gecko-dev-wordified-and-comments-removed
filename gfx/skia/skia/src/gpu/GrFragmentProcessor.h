#
ifndef
GrFragmentProcessor_DEFINED
#
define
GrFragmentProcessor_DEFINED
#
include
"
src
/
gpu
/
GrCoordTransform
.
h
"
#
include
"
src
/
gpu
/
GrProcessor
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrOp
.
h
"
class
GrGLSLFragmentProcessor
;
class
GrPaint
;
class
GrPipeline
;
class
GrProcessorKeyBuilder
;
class
GrShaderCaps
;
class
GrSwizzle
;
class
GrFragmentProcessor
:
public
GrProcessor
{
public
:
class
TextureSampler
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MulChildByInputAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MulInputByChildAlpha
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeInputPremulAndMulByOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
OverrideInput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
SkPMColor4f
&
bool
useUniform
=
true
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
PremulInput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
SwizzleOutput
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
const
GrSwizzle
&
)
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
RunInSeries
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
*
int
cnt
)
;
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
clone
(
)
const
=
0
;
GrGLSLFragmentProcessor
*
createGLSLInstance
(
)
const
;
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
this
-
>
onGetGLSLProcessorKey
(
caps
b
)
;
for
(
int
i
=
0
;
i
<
fChildProcessors
.
count
(
)
;
+
+
i
)
{
fChildProcessors
[
i
]
-
>
getGLSLProcessorKey
(
caps
b
)
;
}
}
int
numTextureSamplers
(
)
const
{
return
fTextureSamplerCnt
;
}
const
TextureSampler
&
textureSampler
(
int
i
)
const
;
int
numCoordTransforms
(
)
const
{
return
fCoordTransforms
.
count
(
)
;
}
const
GrCoordTransform
&
coordTransform
(
int
index
)
const
{
return
*
fCoordTransforms
[
index
]
;
}
const
SkTArray
<
GrCoordTransform
*
true
>
&
coordTransforms
(
)
const
{
return
fCoordTransforms
;
}
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
count
(
)
;
}
const
GrFragmentProcessor
&
childProcessor
(
int
index
)
const
{
return
*
fChildProcessors
[
index
]
;
}
SkDEBUGCODE
(
bool
isInstantiated
(
)
const
;
)
bool
usesLocalCoords
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesLocalCoords_Flag
)
;
}
bool
computeLocalCoordsInVertexShader
(
)
const
{
return
SkToBool
(
fFlags
&
kComputeLocalCoordsInVertexShader_Flag
)
;
}
void
setComputeLocalCoordsInVertexShader
(
bool
value
)
const
{
if
(
value
)
{
fFlags
|
=
kComputeLocalCoordsInVertexShader_Flag
;
}
else
{
fFlags
&
=
~
kComputeLocalCoordsInVertexShader_Flag
;
}
for
(
GrCoordTransform
*
transform
:
fCoordTransforms
)
{
transform
-
>
setComputeInVertexShader
(
value
)
;
}
for
(
const
auto
&
child
:
fChildProcessors
)
{
child
-
>
setComputeLocalCoordsInVertexShader
(
value
)
;
}
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
SkToBool
(
fFlags
&
kCompatibleWithCoverageAsAlpha_OptimizationFlag
)
;
}
bool
preservesOpaqueInput
(
)
const
{
return
SkToBool
(
fFlags
&
kPreservesOpaqueInput_OptimizationFlag
)
;
}
bool
hasConstantOutputForConstantInput
(
SkPMColor4f
inputColor
SkPMColor4f
*
outputColor
)
const
{
if
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
{
*
outputColor
=
this
-
>
constantOutputForConstantInput
(
inputColor
)
;
return
true
;
}
return
false
;
}
bool
hasConstantOutputForConstantInput
(
)
const
{
return
SkToBool
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
;
}
bool
isEqual
(
const
GrFragmentProcessor
&
that
)
const
;
class
Iter
:
public
SkNoncopyable
{
public
:
explicit
Iter
(
const
GrFragmentProcessor
*
fp
)
{
fFPStack
.
push_back
(
fp
)
;
}
explicit
Iter
(
const
GrPipeline
&
pipeline
)
;
explicit
Iter
(
const
GrPaint
&
)
;
const
GrFragmentProcessor
*
next
(
)
;
private
:
SkSTArray
<
4
const
GrFragmentProcessor
*
true
>
fFPStack
;
}
;
template
<
typename
T
int
(
GrFragmentProcessor
:
:
*
COUNT
)
(
)
const
const
T
&
(
GrFragmentProcessor
:
:
*
GET
)
(
int
)
const
>
class
FPItemIter
:
public
SkNoncopyable
{
public
:
explicit
FPItemIter
(
const
GrFragmentProcessor
*
fp
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
fp
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
explicit
FPItemIter
(
const
GrPipeline
&
pipeline
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
pipeline
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
const
T
*
next
(
)
{
if
(
!
fCurrFP
)
{
return
nullptr
;
}
while
(
fCTIdx
=
=
(
fCurrFP
-
>
*
COUNT
)
(
)
)
{
fCTIdx
=
0
;
fCurrFP
=
fFPIter
.
next
(
)
;
if
(
!
fCurrFP
)
{
return
nullptr
;
}
}
return
&
(
fCurrFP
-
>
*
GET
)
(
fCTIdx
+
+
)
;
}
private
:
const
GrFragmentProcessor
*
fCurrFP
;
int
fCTIdx
;
GrFragmentProcessor
:
:
Iter
fFPIter
;
}
;
using
CoordTransformIter
=
FPItemIter
<
GrCoordTransform
&
GrFragmentProcessor
:
:
numCoordTransforms
&
GrFragmentProcessor
:
:
coordTransform
>
;
using
TextureAccessIter
=
FPItemIter
<
TextureSampler
&
GrFragmentProcessor
:
:
numTextureSamplers
&
GrFragmentProcessor
:
:
textureSampler
>
;
void
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
func
)
;
protected
:
enum
OptimizationFlags
:
uint32_t
{
kNone_OptimizationFlags
kCompatibleWithCoverageAsAlpha_OptimizationFlag
=
0x1
kPreservesOpaqueInput_OptimizationFlag
=
0x2
kConstantOutputForConstantInput_OptimizationFlag
=
0x4
kAll_OptimizationFlags
=
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
|
kConstantOutputForConstantInput_OptimizationFlag
}
;
GR_DECL_BITFIELD_OPS_FRIENDS
(
OptimizationFlags
)
static
OptimizationFlags
ModulateForSamplerOptFlags
(
GrColorType
colorType
bool
samplingDecal
)
{
if
(
samplingDecal
)
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
;
}
else
{
return
ModulateForClampedSamplerOptFlags
(
colorType
)
;
}
}
static
OptimizationFlags
ModulateForClampedSamplerOptFlags
(
GrColorType
colorType
)
{
if
(
!
GrColorTypeHasAlpha
(
colorType
)
)
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
;
}
else
{
return
kCompatibleWithCoverageAsAlpha_OptimizationFlag
;
}
}
GrFragmentProcessor
(
ClassID
classID
OptimizationFlags
optimizationFlags
)
:
INHERITED
(
classID
)
fFlags
(
optimizationFlags
|
kComputeLocalCoordsInVertexShader_Flag
)
{
SkASSERT
(
(
optimizationFlags
&
~
kAll_OptimizationFlags
)
=
=
0
)
;
}
OptimizationFlags
optimizationFlags
(
)
const
{
return
static_cast
<
OptimizationFlags
>
(
kAll_OptimizationFlags
&
fFlags
)
;
}
static
OptimizationFlags
ProcessorOptimizationFlags
(
const
GrFragmentProcessor
*
fp
)
{
return
fp
-
>
optimizationFlags
(
)
;
}
static
SkPMColor4f
ConstantOutputForConstantInput
(
const
GrFragmentProcessor
&
fp
const
SkPMColor4f
&
input
)
{
SkASSERT
(
fp
.
hasConstantOutputForConstantInput
(
)
)
;
return
fp
.
constantOutputForConstantInput
(
input
)
;
}
void
addCoordTransform
(
GrCoordTransform
*
)
;
int
registerChildProcessor
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
child
)
;
void
setTextureSamplerCnt
(
int
cnt
)
{
SkASSERT
(
cnt
>
=
0
)
;
fTextureSamplerCnt
=
cnt
;
}
template
<
typename
.
.
.
Args
>
static
const
TextureSampler
&
IthTextureSampler
(
int
i
const
TextureSampler
&
samp0
const
Args
&
.
.
.
samps
)
{
return
(
0
=
=
i
)
?
samp0
:
IthTextureSampler
(
i
-
1
samps
.
.
.
)
;
}
inline
static
const
TextureSampler
&
IthTextureSampler
(
int
i
)
;
private
:
virtual
SkPMColor4f
constantOutputForConstantInput
(
const
SkPMColor4f
&
)
const
{
SK_ABORT
(
"
Subclass
must
override
this
if
advertising
this
optimization
.
"
)
;
}
virtual
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
=
0
;
virtual
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
=
0
;
virtual
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
=
0
;
virtual
const
TextureSampler
&
onTextureSampler
(
int
)
const
{
return
IthTextureSampler
(
0
)
;
}
bool
hasSameTransforms
(
const
GrFragmentProcessor
&
)
const
;
enum
PrivateFlags
{
kFirstPrivateFlag
=
kAll_OptimizationFlags
+
1
kUsesLocalCoords_Flag
=
kFirstPrivateFlag
kComputeLocalCoordsInVertexShader_Flag
=
kFirstPrivateFlag
<
<
1
}
;
mutable
uint32_t
fFlags
=
kComputeLocalCoordsInVertexShader_Flag
;
int
fTextureSamplerCnt
=
0
;
SkSTArray
<
4
GrCoordTransform
*
true
>
fCoordTransforms
;
SkSTArray
<
1
std
:
:
unique_ptr
<
GrFragmentProcessor
>
true
>
fChildProcessors
;
typedef
GrProcessor
INHERITED
;
}
;
class
GrFragmentProcessor
:
:
TextureSampler
{
public
:
TextureSampler
(
)
=
default
;
explicit
TextureSampler
(
const
TextureSampler
&
that
)
:
fProxy
(
that
.
fProxy
)
fSamplerState
(
that
.
fSamplerState
)
{
}
TextureSampler
(
sk_sp
<
GrTextureProxy
>
const
GrSamplerState
&
=
GrSamplerState
:
:
ClampNearest
(
)
)
;
TextureSampler
&
operator
=
(
const
TextureSampler
&
)
=
delete
;
void
reset
(
sk_sp
<
GrTextureProxy
>
const
GrSamplerState
&
)
;
bool
operator
=
=
(
const
TextureSampler
&
that
)
const
{
return
this
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
=
=
that
.
proxy
(
)
-
>
underlyingUniqueID
(
)
&
&
fSamplerState
=
=
that
.
fSamplerState
;
}
bool
operator
!
=
(
const
TextureSampler
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
SkDEBUGCODE
(
bool
isInstantiated
(
)
const
{
return
fProxy
-
>
isInstantiated
(
)
;
}
)
GrTexture
*
peekTexture
(
)
const
{
SkASSERT
(
fProxy
-
>
isInstantiated
(
)
)
;
return
fProxy
-
>
peekTexture
(
)
;
}
GrTextureProxy
*
proxy
(
)
const
{
return
fProxy
.
get
(
)
;
}
const
GrSamplerState
&
samplerState
(
)
const
{
return
fSamplerState
;
}
const
GrSwizzle
&
swizzle
(
)
const
{
return
this
-
>
proxy
(
)
-
>
textureSwizzle
(
)
;
}
bool
isInitialized
(
)
const
{
return
SkToBool
(
fProxy
.
get
(
)
)
;
}
private
:
sk_sp
<
GrTextureProxy
>
fProxy
;
GrSamplerState
fSamplerState
;
}
;
const
GrFragmentProcessor
:
:
TextureSampler
&
GrFragmentProcessor
:
:
IthTextureSampler
(
int
i
)
{
SK_ABORT
(
"
Illegal
texture
sampler
index
"
)
;
static
const
TextureSampler
kBogus
;
return
kBogus
;
}
GR_MAKE_BITFIELD_OPS
(
GrFragmentProcessor
:
:
OptimizationFlags
)
#
endif
