#
ifndef
GrGpu_DEFINED
#
define
GrGpu_DEFINED
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrStencil
.
h
"
#
include
"
GrTextureParamsAdjuster
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkPath
.
h
"
class
GrBatchTracker
;
class
GrContext
;
class
GrGLContext
;
class
GrIndexBuffer
;
class
GrNonInstancedVertices
;
class
GrPath
;
class
GrPathRange
;
class
GrPathRenderer
;
class
GrPathRendererChain
;
class
GrPathRendering
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrRenderTarget
;
class
GrStencilAttachment
;
class
GrSurface
;
class
GrTexture
;
class
GrTransferBuffer
;
class
GrVertexBuffer
;
class
GrVertices
;
class
GrGpu
:
public
SkRefCnt
{
public
:
static
GrGpu
*
Create
(
GrBackend
GrBackendContext
const
GrContextOptions
&
GrContext
*
context
)
;
GrGpu
(
GrContext
*
context
)
;
~
GrGpu
(
)
override
;
GrContext
*
getContext
(
)
{
return
fContext
;
}
const
GrContext
*
getContext
(
)
const
{
return
fContext
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
GrPathRendering
*
pathRendering
(
)
{
return
fPathRendering
.
get
(
)
;
}
virtual
void
contextAbandoned
(
)
;
void
markContextDirty
(
uint32_t
state
=
kAll_GrBackendState
)
{
fResetBits
|
=
state
;
}
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
bool
budgeted
const
void
*
srcData
size_t
rowBytes
)
;
GrTexture
*
wrapBackendTexture
(
const
GrBackendTextureDesc
&
GrWrapOwnership
)
;
GrRenderTarget
*
wrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
GrWrapOwnership
)
;
GrVertexBuffer
*
createVertexBuffer
(
size_t
size
bool
dynamic
)
;
GrIndexBuffer
*
createIndexBuffer
(
size_t
size
bool
dynamic
)
;
GrTransferBuffer
*
createTransferBuffer
(
size_t
size
TransferType
type
)
;
void
resolveRenderTarget
(
GrRenderTarget
*
target
)
;
struct
ReadPixelTempDrawInfo
{
GrSurfaceDesc
fTempSurfaceDesc
;
bool
fUseExactScratch
;
bool
fSwapRAndB
;
}
;
enum
DrawPreference
{
kNoDraw_DrawPreference
kCallerPrefersDraw_DrawPreference
kGpuPrefersDraw_DrawPreference
kRequireDraw_DrawPreference
}
;
bool
getReadPixelsInfo
(
GrSurface
*
srcSurface
int
readWidth
int
readHeight
size_t
rowBytes
GrPixelConfig
readConfig
DrawPreference
*
ReadPixelTempDrawInfo
*
)
;
struct
WritePixelTempDrawInfo
{
GrSurfaceDesc
fTempSurfaceDesc
;
bool
fSwapRAndB
;
}
;
bool
getWritePixelsInfo
(
GrSurface
*
dstSurface
int
width
int
height
size_t
rowBytes
GrPixelConfig
srcConfig
DrawPreference
*
WritePixelTempDrawInfo
*
)
;
bool
readPixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
void
*
buffer
size_t
rowBytes
)
;
bool
writePixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
void
*
buffer
size_t
rowBytes
)
;
bool
transferPixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
GrTransferBuffer
*
buffer
size_t
offset
size_t
rowBytes
)
;
void
clear
(
const
SkIRect
&
rect
GrColor
color
GrRenderTarget
*
renderTarget
)
;
void
clearStencilClip
(
const
SkIRect
&
rect
bool
insideClip
GrRenderTarget
*
renderTarget
)
;
virtual
void
discard
(
GrRenderTarget
*
=
nullptr
)
=
0
;
virtual
bool
initCopySurfaceDstDesc
(
const
GrSurface
*
src
GrSurfaceDesc
*
desc
)
const
=
0
;
typedef
uint64_t
ResetTimestamp
;
static
const
ResetTimestamp
kExpiredTimestamp
=
0
;
ResetTimestamp
getResetTimestamp
(
)
const
{
return
fResetTimestamp
;
}
virtual
void
buildProgramDesc
(
GrProgramDesc
*
const
GrPrimitiveProcessor
&
const
GrPipeline
&
)
const
=
0
;
bool
copySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
;
struct
DrawArgs
{
DrawArgs
(
const
GrPrimitiveProcessor
*
primProc
const
GrPipeline
*
pipeline
const
GrProgramDesc
*
desc
)
:
fPrimitiveProcessor
(
primProc
)
fPipeline
(
pipeline
)
fDesc
(
desc
)
{
SkASSERT
(
primProc
&
&
pipeline
&
&
desc
)
;
}
const
GrPrimitiveProcessor
*
fPrimitiveProcessor
;
const
GrPipeline
*
fPipeline
;
const
GrProgramDesc
*
fDesc
;
}
;
void
draw
(
const
DrawArgs
&
const
GrVertices
&
)
;
class
Stats
{
public
:
#
if
GR_GPU_STATS
Stats
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fRenderTargetBinds
=
0
;
fShaderCompilations
=
0
;
fTextureCreates
=
0
;
fTextureUploads
=
0
;
fTransfersToTexture
=
0
;
fStencilAttachmentCreates
=
0
;
fNumDraws
=
0
;
}
int
renderTargetBinds
(
)
const
{
return
fRenderTargetBinds
;
}
void
incRenderTargetBinds
(
)
{
fRenderTargetBinds
+
+
;
}
int
shaderCompilations
(
)
const
{
return
fShaderCompilations
;
}
void
incShaderCompilations
(
)
{
fShaderCompilations
+
+
;
}
int
textureCreates
(
)
const
{
return
fTextureCreates
;
}
void
incTextureCreates
(
)
{
fTextureCreates
+
+
;
}
int
textureUploads
(
)
const
{
return
fTextureUploads
;
}
void
incTextureUploads
(
)
{
fTextureUploads
+
+
;
}
int
transfersToTexture
(
)
const
{
return
fTransfersToTexture
;
}
void
incTransfersToTexture
(
)
{
fTransfersToTexture
+
+
;
}
void
incStencilAttachmentCreates
(
)
{
fStencilAttachmentCreates
+
+
;
}
void
incNumDraws
(
)
{
fNumDraws
+
+
;
}
void
dump
(
SkString
*
)
;
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
;
private
:
int
fRenderTargetBinds
;
int
fShaderCompilations
;
int
fTextureCreates
;
int
fTextureUploads
;
int
fTransfersToTexture
;
int
fStencilAttachmentCreates
;
int
fNumDraws
;
#
else
void
dump
(
SkString
*
)
{
}
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
SkTArray
<
double
>
*
)
{
}
void
incRenderTargetBinds
(
)
{
}
void
incShaderCompilations
(
)
{
}
void
incTextureCreates
(
)
{
}
void
incTextureUploads
(
)
{
}
void
incTransfersToTexture
(
)
{
}
void
incStencilAttachmentCreates
(
)
{
}
void
incNumDraws
(
)
{
}
#
endif
}
;
Stats
*
stats
(
)
{
return
&
fStats
;
}
virtual
GrBackendObject
createTestingOnlyBackendTexture
(
void
*
pixels
int
w
int
h
GrPixelConfig
config
)
const
=
0
;
virtual
bool
isTestingOnlyBackendTexture
(
GrBackendObject
)
const
=
0
;
virtual
void
deleteTestingOnlyBackendTexture
(
GrBackendObject
bool
abandonTexture
=
false
)
const
=
0
;
virtual
GrStencilAttachment
*
createStencilAttachmentForRenderTarget
(
const
GrRenderTarget
*
int
width
int
height
)
=
0
;
virtual
void
clearStencil
(
GrRenderTarget
*
target
)
=
0
;
virtual
void
drawDebugWireRect
(
GrRenderTarget
*
const
SkIRect
&
GrColor
)
=
0
;
bool
makeCopyForTextureParams
(
int
width
int
height
const
GrTextureParams
&
GrTextureProducer
:
:
CopyParams
*
)
const
;
virtual
const
GrGLContext
*
glContextForTesting
(
)
const
{
return
nullptr
;
}
virtual
void
resetShaderCacheForTesting
(
)
const
{
}
protected
:
static
GrStencilFunc
ConvertStencilFunc
(
bool
stencilInClip
GrStencilFunc
func
)
;
static
void
ConvertStencilFuncAndMask
(
GrStencilFunc
func
bool
clipInStencil
unsigned
int
clipBit
unsigned
int
userBits
unsigned
int
*
ref
unsigned
int
*
mask
)
;
static
void
ElevateDrawPreference
(
GrGpu
:
:
DrawPreference
*
preference
GrGpu
:
:
DrawPreference
elevation
)
{
GR_STATIC_ASSERT
(
GrGpu
:
:
kCallerPrefersDraw_DrawPreference
>
GrGpu
:
:
kNoDraw_DrawPreference
)
;
GR_STATIC_ASSERT
(
GrGpu
:
:
kGpuPrefersDraw_DrawPreference
>
GrGpu
:
:
kCallerPrefersDraw_DrawPreference
)
;
GR_STATIC_ASSERT
(
GrGpu
:
:
kRequireDraw_DrawPreference
>
GrGpu
:
:
kGpuPrefersDraw_DrawPreference
)
;
*
preference
=
SkTMax
(
*
preference
elevation
)
;
}
void
handleDirtyContext
(
)
{
if
(
fResetBits
)
{
this
-
>
resetContext
(
)
;
}
}
Stats
fStats
;
SkAutoTDelete
<
GrPathRendering
>
fPathRendering
;
SkAutoTUnref
<
const
GrCaps
>
fCaps
;
private
:
virtual
void
onResetContext
(
uint32_t
resetBits
)
=
0
;
virtual
void
xferBarrier
(
GrRenderTarget
*
GrXferBarrierType
)
=
0
;
virtual
GrTexture
*
onCreateTexture
(
const
GrSurfaceDesc
&
desc
GrGpuResource
:
:
LifeCycle
lifeCycle
const
void
*
srcData
size_t
rowBytes
)
=
0
;
virtual
GrTexture
*
onCreateCompressedTexture
(
const
GrSurfaceDesc
&
desc
GrGpuResource
:
:
LifeCycle
lifeCycle
const
void
*
srcData
)
=
0
;
virtual
GrTexture
*
onWrapBackendTexture
(
const
GrBackendTextureDesc
&
GrWrapOwnership
)
=
0
;
virtual
GrRenderTarget
*
onWrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
GrWrapOwnership
)
=
0
;
virtual
GrVertexBuffer
*
onCreateVertexBuffer
(
size_t
size
bool
dynamic
)
=
0
;
virtual
GrIndexBuffer
*
onCreateIndexBuffer
(
size_t
size
bool
dynamic
)
=
0
;
virtual
GrTransferBuffer
*
onCreateTransferBuffer
(
size_t
size
TransferType
type
)
=
0
;
virtual
void
onClear
(
GrRenderTarget
*
const
SkIRect
&
rect
GrColor
color
)
=
0
;
virtual
void
onClearStencilClip
(
GrRenderTarget
*
const
SkIRect
&
rect
bool
insideClip
)
=
0
;
virtual
void
onDraw
(
const
DrawArgs
&
const
GrNonInstancedVertices
&
)
=
0
;
virtual
bool
onGetReadPixelsInfo
(
GrSurface
*
srcSurface
int
readWidth
int
readHeight
size_t
rowBytes
GrPixelConfig
readConfig
DrawPreference
*
ReadPixelTempDrawInfo
*
)
=
0
;
virtual
bool
onGetWritePixelsInfo
(
GrSurface
*
dstSurface
int
width
int
height
size_t
rowBytes
GrPixelConfig
srcConfig
DrawPreference
*
WritePixelTempDrawInfo
*
)
=
0
;
virtual
bool
onReadPixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
void
*
buffer
size_t
rowBytes
)
=
0
;
virtual
bool
onWritePixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
void
*
buffer
size_t
rowBytes
)
=
0
;
virtual
bool
onTransferPixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrPixelConfig
config
GrTransferBuffer
*
buffer
size_t
offset
size_t
rowBytes
)
=
0
;
virtual
void
onResolveRenderTarget
(
GrRenderTarget
*
target
)
=
0
;
virtual
bool
onCopySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
=
0
;
void
resetContext
(
)
{
this
-
>
onResetContext
(
fResetBits
)
;
fResetBits
=
0
;
+
+
fResetTimestamp
;
}
ResetTimestamp
fResetTimestamp
;
uint32_t
fResetBits
;
GrContext
*
fContext
;
friend
class
GrPathRendering
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
