#
ifndef
GrGpu_DEFINED
#
define
GrGpu_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrProgramDesc
.
h
"
#
include
"
GrSwizzle
.
h
"
#
include
"
GrAllocator
.
h
"
#
include
"
GrTextureProducer
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkTArray
.
h
"
#
include
<
map
>
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBuffer
;
class
GrContext
;
struct
GrContextOptions
;
class
GrGLContext
;
class
GrMesh
;
class
GrPath
;
class
GrPathRenderer
;
class
GrPathRendererChain
;
class
GrPathRendering
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
GrRenderTarget
;
class
GrSemaphore
;
class
GrStencilAttachment
;
class
GrStencilSettings
;
class
GrSurface
;
class
GrTexture
;
class
SkJSONWriter
;
class
GrGpu
:
public
SkRefCnt
{
public
:
GrGpu
(
GrContext
*
context
)
;
~
GrGpu
(
)
override
;
GrContext
*
getContext
(
)
{
return
fContext
;
}
const
GrContext
*
getContext
(
)
const
{
return
fContext
;
}
const
GrCaps
*
caps
(
)
const
{
return
fCaps
.
get
(
)
;
}
sk_sp
<
const
GrCaps
>
refCaps
(
)
const
{
return
fCaps
;
}
GrPathRendering
*
pathRendering
(
)
{
return
fPathRendering
.
get
(
)
;
}
enum
class
DisconnectType
{
kAbandon
kCleanup
}
;
virtual
void
disconnect
(
DisconnectType
)
;
void
markContextDirty
(
uint32_t
state
=
kAll_GrBackendState
)
{
fResetBits
|
=
state
;
}
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
SkBudgeted
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
;
sk_sp
<
GrTexture
>
createTexture
(
const
GrSurfaceDesc
&
desc
SkBudgeted
)
;
sk_sp
<
GrTexture
>
wrapBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
)
;
sk_sp
<
GrTexture
>
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
int
sampleCnt
GrWrapOwnership
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
;
sk_sp
<
GrRenderTarget
>
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
int
sampleCnt
)
;
GrBuffer
*
createBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
accessPattern
const
void
*
data
=
nullptr
)
;
void
resolveRenderTarget
(
GrRenderTarget
*
)
;
bool
regenerateMipMapLevels
(
GrTexture
*
)
;
bool
readPixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrColorType
dstColorType
void
*
buffer
size_t
rowBytes
)
;
bool
writePixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrColorType
srcColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
;
bool
writePixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrColorType
srcColorType
const
void
*
buffer
size_t
rowBytes
)
{
GrMipLevel
mipLevel
=
{
buffer
rowBytes
}
;
return
this
-
>
writePixels
(
surface
left
top
width
height
srcColorType
&
mipLevel
1
)
;
}
bool
transferPixels
(
GrTexture
*
texture
int
left
int
top
int
width
int
height
GrColorType
bufferColorType
GrBuffer
*
transferBuffer
size_t
offset
size_t
rowBytes
)
;
typedef
uint64_t
ResetTimestamp
;
static
const
ResetTimestamp
kExpiredTimestamp
=
0
;
ResetTimestamp
getResetTimestamp
(
)
const
{
return
fResetTimestamp
;
}
bool
copySurface
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
bool
canDiscardOutsideDstRect
=
false
)
;
virtual
GrGpuRTCommandBuffer
*
getCommandBuffer
(
GrRenderTarget
*
GrSurfaceOrigin
const
GrGpuRTCommandBuffer
:
:
LoadAndStoreInfo
&
const
GrGpuRTCommandBuffer
:
:
StencilLoadAndStoreInfo
&
)
=
0
;
virtual
GrGpuTextureCommandBuffer
*
getCommandBuffer
(
GrTexture
*
GrSurfaceOrigin
)
=
0
;
GrSemaphoresSubmitted
finishFlush
(
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
;
virtual
void
submit
(
GrGpuCommandBuffer
*
)
=
0
;
virtual
GrFence
SK_WARN_UNUSED_RESULT
insertFence
(
)
=
0
;
virtual
bool
waitFence
(
GrFence
uint64_t
timeout
=
1000
)
=
0
;
virtual
void
deleteFence
(
GrFence
)
const
=
0
;
virtual
sk_sp
<
GrSemaphore
>
SK_WARN_UNUSED_RESULT
makeSemaphore
(
bool
isOwned
=
true
)
=
0
;
virtual
sk_sp
<
GrSemaphore
>
wrapBackendSemaphore
(
const
GrBackendSemaphore
&
semaphore
GrResourceProvider
:
:
SemaphoreWrapType
wrapType
GrWrapOwnership
ownership
)
=
0
;
virtual
void
insertSemaphore
(
sk_sp
<
GrSemaphore
>
semaphore
bool
flush
=
false
)
=
0
;
virtual
void
waitSemaphore
(
sk_sp
<
GrSemaphore
>
semaphore
)
=
0
;
virtual
sk_sp
<
GrSemaphore
>
prepareTextureForCrossContextUsage
(
GrTexture
*
)
=
0
;
class
Stats
{
public
:
#
if
GR_GPU_STATS
Stats
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fRenderTargetBinds
=
0
;
fShaderCompilations
=
0
;
fTextureCreates
=
0
;
fTextureUploads
=
0
;
fTransfersToTexture
=
0
;
fStencilAttachmentCreates
=
0
;
fNumDraws
=
0
;
fNumFailedDraws
=
0
;
}
int
renderTargetBinds
(
)
const
{
return
fRenderTargetBinds
;
}
void
incRenderTargetBinds
(
)
{
fRenderTargetBinds
+
+
;
}
int
shaderCompilations
(
)
const
{
return
fShaderCompilations
;
}
void
incShaderCompilations
(
)
{
fShaderCompilations
+
+
;
}
int
textureCreates
(
)
const
{
return
fTextureCreates
;
}
void
incTextureCreates
(
)
{
fTextureCreates
+
+
;
}
int
textureUploads
(
)
const
{
return
fTextureUploads
;
}
void
incTextureUploads
(
)
{
fTextureUploads
+
+
;
}
int
transfersToTexture
(
)
const
{
return
fTransfersToTexture
;
}
void
incTransfersToTexture
(
)
{
fTransfersToTexture
+
+
;
}
void
incStencilAttachmentCreates
(
)
{
fStencilAttachmentCreates
+
+
;
}
void
incNumDraws
(
)
{
fNumDraws
+
+
;
}
void
incNumFailedDraws
(
)
{
+
+
fNumFailedDraws
;
}
void
dump
(
SkString
*
)
;
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
;
int
numDraws
(
)
const
{
return
fNumDraws
;
}
int
numFailedDraws
(
)
const
{
return
fNumFailedDraws
;
}
private
:
int
fRenderTargetBinds
;
int
fShaderCompilations
;
int
fTextureCreates
;
int
fTextureUploads
;
int
fTransfersToTexture
;
int
fStencilAttachmentCreates
;
int
fNumDraws
;
int
fNumFailedDraws
;
#
else
void
dump
(
SkString
*
)
{
}
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
SkTArray
<
double
>
*
)
{
}
void
incRenderTargetBinds
(
)
{
}
void
incShaderCompilations
(
)
{
}
void
incTextureCreates
(
)
{
}
void
incTextureUploads
(
)
{
}
void
incTransfersToTexture
(
)
{
}
void
incStencilAttachmentCreates
(
)
{
}
void
incNumDraws
(
)
{
}
void
incNumFailedDraws
(
)
{
}
#
endif
}
;
Stats
*
stats
(
)
{
return
&
fStats
;
}
void
dumpJSON
(
SkJSONWriter
*
)
const
;
#
if
GR_TEST_UTILS
GrBackendTexture
createTestingOnlyBackendTexture
(
const
void
*
pixels
int
w
int
h
SkColorType
bool
isRenderTarget
GrMipMapped
size_t
rowBytes
=
0
)
;
virtual
GrBackendTexture
createTestingOnlyBackendTexture
(
const
void
*
pixels
int
w
int
h
GrColorType
bool
isRenderTarget
GrMipMapped
size_t
rowBytes
=
0
)
=
0
;
virtual
bool
isTestingOnlyBackendTexture
(
const
GrBackendTexture
&
)
const
=
0
;
virtual
void
deleteTestingOnlyBackendTexture
(
const
GrBackendTexture
&
)
=
0
;
virtual
GrBackendRenderTarget
createTestingOnlyBackendRenderTarget
(
int
w
int
h
GrColorType
)
=
0
;
virtual
void
deleteTestingOnlyBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
=
0
;
virtual
const
GrGLContext
*
glContextForTesting
(
)
const
{
return
nullptr
;
}
virtual
void
resetShaderCacheForTesting
(
)
const
{
}
virtual
void
testingOnly_flushGpuAndSync
(
)
=
0
;
#
endif
virtual
GrStencilAttachment
*
createStencilAttachmentForRenderTarget
(
const
GrRenderTarget
*
int
width
int
height
)
=
0
;
static
bool
IsACopyNeededForRepeatWrapMode
(
const
GrCaps
*
GrTextureProxy
*
texProxy
int
width
int
height
GrSamplerState
:
:
Filter
GrTextureProducer
:
:
CopyParams
*
SkScalar
scaleAdjust
[
2
]
)
;
static
bool
IsACopyNeededForMips
(
const
GrCaps
*
caps
const
GrTextureProxy
*
texProxy
GrSamplerState
:
:
Filter
filter
GrTextureProducer
:
:
CopyParams
*
copyParams
)
;
void
handleDirtyContext
(
)
{
if
(
fResetBits
)
{
this
-
>
resetContext
(
)
;
}
}
protected
:
void
didWriteToSurface
(
GrSurface
*
surface
GrSurfaceOrigin
origin
const
SkIRect
*
bounds
uint32_t
mipLevels
=
1
)
const
;
Stats
fStats
;
std
:
:
unique_ptr
<
GrPathRendering
>
fPathRendering
;
sk_sp
<
const
GrCaps
>
fCaps
;
typedef
SkTArray
<
SkPoint
true
>
SamplePattern
;
private
:
virtual
void
onResetContext
(
uint32_t
resetBits
)
=
0
;
virtual
void
xferBarrier
(
GrRenderTarget
*
GrXferBarrierType
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onCreateTexture
(
const
GrSurfaceDesc
&
SkBudgeted
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onWrapBackendTexture
(
const
GrBackendTexture
&
GrWrapOwnership
)
=
0
;
virtual
sk_sp
<
GrTexture
>
onWrapRenderableBackendTexture
(
const
GrBackendTexture
&
int
sampleCnt
GrWrapOwnership
)
=
0
;
virtual
sk_sp
<
GrRenderTarget
>
onWrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
)
=
0
;
virtual
sk_sp
<
GrRenderTarget
>
onWrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
int
sampleCnt
)
=
0
;
virtual
GrBuffer
*
onCreateBuffer
(
size_t
size
GrBufferType
intendedType
GrAccessPattern
const
void
*
data
)
=
0
;
virtual
bool
onReadPixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrColorType
void
*
buffer
size_t
rowBytes
)
=
0
;
virtual
bool
onWritePixels
(
GrSurface
*
int
left
int
top
int
width
int
height
GrColorType
const
GrMipLevel
texels
[
]
int
mipLevelCount
)
=
0
;
virtual
bool
onTransferPixels
(
GrTexture
*
int
left
int
top
int
width
int
height
GrColorType
colorType
GrBuffer
*
transferBuffer
size_t
offset
size_t
rowBytes
)
=
0
;
virtual
void
onResolveRenderTarget
(
GrRenderTarget
*
target
)
=
0
;
virtual
bool
onRegenerateMipMapLevels
(
GrTexture
*
)
=
0
;
virtual
bool
onCopySurface
(
GrSurface
*
dst
GrSurfaceOrigin
dstOrigin
GrSurface
*
src
GrSurfaceOrigin
srcOrigin
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
bool
canDiscardOutsideDstRect
)
=
0
;
virtual
void
onFinishFlush
(
bool
insertedSemaphores
)
=
0
;
#
ifdef
SK_ENABLE_DUMP_GPU
virtual
void
onDumpJSON
(
SkJSONWriter
*
)
const
{
}
#
endif
void
resetContext
(
)
{
this
-
>
onResetContext
(
fResetBits
)
;
fResetBits
=
0
;
+
+
fResetTimestamp
;
}
ResetTimestamp
fResetTimestamp
;
uint32_t
fResetBits
;
GrContext
*
fContext
;
friend
class
GrPathRendering
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
