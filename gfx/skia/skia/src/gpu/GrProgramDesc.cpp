#
include
"
GrProgramDesc
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrPrimitiveProcessor
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
SkTo
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
enum
{
kSamplerOrImageTypeKeyBits
=
4
}
;
static
inline
uint16_t
texture_type_key
(
GrTextureType
type
)
{
int
value
=
UINT16_MAX
;
switch
(
type
)
{
case
GrTextureType
:
:
k2D
:
value
=
0
;
break
;
case
GrTextureType
:
:
kExternal
:
value
=
1
;
break
;
case
GrTextureType
:
:
kRectangle
:
value
=
2
;
break
;
}
SkASSERT
(
(
value
&
(
(
1
<
<
kSamplerOrImageTypeKeyBits
)
-
1
)
)
=
=
value
)
;
return
SkToU16
(
value
)
;
}
static
uint32_t
sampler_key
(
GrTextureType
textureType
GrPixelConfig
config
const
GrShaderCaps
&
caps
)
{
int
samplerTypeKey
=
texture_type_key
(
textureType
)
;
GR_STATIC_ASSERT
(
2
=
=
sizeof
(
caps
.
configTextureSwizzle
(
config
)
.
asKey
(
)
)
)
;
return
SkToU32
(
samplerTypeKey
|
caps
.
configTextureSwizzle
(
config
)
.
asKey
(
)
<
<
kSamplerOrImageTypeKeyBits
|
(
GrSLSamplerPrecision
(
config
)
<
<
(
16
+
kSamplerOrImageTypeKeyBits
)
)
)
;
}
static
void
add_sampler_keys
(
GrProcessorKeyBuilder
*
b
const
GrFragmentProcessor
&
fp
GrGpu
*
gpu
const
GrShaderCaps
&
caps
)
{
int
numTextureSamplers
=
fp
.
numTextureSamplers
(
)
;
if
(
!
numTextureSamplers
)
{
return
;
}
uint32_t
*
k32
=
b
-
>
add32n
(
numTextureSamplers
)
;
for
(
int
i
=
0
;
i
<
numTextureSamplers
;
+
+
i
)
{
const
GrFragmentProcessor
:
:
TextureSampler
&
sampler
=
fp
.
textureSampler
(
i
)
;
const
GrTexture
*
tex
=
sampler
.
peekTexture
(
)
;
k32
[
i
]
=
sampler_key
(
tex
-
>
texturePriv
(
)
.
textureType
(
)
tex
-
>
config
(
)
caps
)
;
uint32_t
extraSamplerKey
=
gpu
-
>
getExtraSamplerKeyForProgram
(
sampler
.
samplerState
(
)
sampler
.
proxy
(
)
-
>
backendFormat
(
)
)
;
if
(
extraSamplerKey
)
{
SkASSERT
(
sampler
.
proxy
(
)
-
>
textureType
(
)
=
=
GrTextureType
:
:
kExternal
)
;
SkASSERT
(
(
k32
[
i
]
&
(
1
<
<
31
)
)
=
=
0
)
;
k32
[
i
]
=
k32
[
i
]
|
(
1
<
<
31
)
;
b
-
>
add32
(
extraSamplerKey
)
;
}
}
}
static
void
add_sampler_keys
(
GrProcessorKeyBuilder
*
b
const
GrPrimitiveProcessor
&
pp
const
GrShaderCaps
&
caps
)
{
int
numTextureSamplers
=
pp
.
numTextureSamplers
(
)
;
if
(
!
numTextureSamplers
)
{
return
;
}
uint32_t
*
k32
=
b
-
>
add32n
(
numTextureSamplers
)
;
for
(
int
i
=
0
;
i
<
numTextureSamplers
;
+
+
i
)
{
const
GrPrimitiveProcessor
:
:
TextureSampler
&
sampler
=
pp
.
textureSampler
(
i
)
;
k32
[
i
]
=
sampler_key
(
sampler
.
textureType
(
)
sampler
.
config
(
)
caps
)
;
uint32_t
extraSamplerKey
=
sampler
.
extraSamplerKey
(
)
;
if
(
extraSamplerKey
)
{
SkASSERT
(
sampler
.
textureType
(
)
=
=
GrTextureType
:
:
kExternal
)
;
SkASSERT
(
(
k32
[
i
]
&
(
1
<
<
15
)
)
=
=
0
)
;
k32
[
i
]
=
k32
[
i
]
|
(
1
<
<
15
)
;
b
-
>
add32
(
extraSamplerKey
)
;
}
}
}
static
bool
gen_meta_key
(
const
GrFragmentProcessor
&
fp
GrGpu
*
gpu
const
GrShaderCaps
&
shaderCaps
uint32_t
transformKey
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
classID
=
fp
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
UINT16_MAX
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
add_sampler_keys
(
b
fp
gpu
shaderCaps
)
;
uint32_t
*
key
=
b
-
>
add32n
(
2
)
;
key
[
0
]
=
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
;
key
[
1
]
=
transformKey
;
return
true
;
}
static
bool
gen_meta_key
(
const
GrPrimitiveProcessor
&
pp
const
GrShaderCaps
&
shaderCaps
uint32_t
transformKey
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
classID
=
pp
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
UINT16_MAX
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
add_sampler_keys
(
b
pp
shaderCaps
)
;
uint32_t
*
key
=
b
-
>
add32n
(
2
)
;
key
[
0
]
=
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
;
key
[
1
]
=
transformKey
;
return
true
;
}
static
bool
gen_meta_key
(
const
GrXferProcessor
&
xp
const
GrShaderCaps
&
shaderCaps
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
classID
=
xp
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
UINT16_MAX
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
b
-
>
add32
(
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
)
;
return
true
;
}
static
bool
gen_frag_proc_and_meta_keys
(
const
GrPrimitiveProcessor
&
primProc
const
GrFragmentProcessor
&
fp
GrGpu
*
gpu
const
GrShaderCaps
&
shaderCaps
GrProcessorKeyBuilder
*
b
)
{
for
(
int
i
=
0
;
i
<
fp
.
numChildProcessors
(
)
;
+
+
i
)
{
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
.
childProcessor
(
i
)
gpu
shaderCaps
b
)
)
{
return
false
;
}
}
fp
.
getGLSLProcessorKey
(
shaderCaps
b
)
;
return
gen_meta_key
(
fp
gpu
shaderCaps
primProc
.
getTransformKey
(
fp
.
coordTransforms
(
)
fp
.
numCoordTransforms
(
)
)
b
)
;
}
bool
GrProgramDesc
:
:
Build
(
GrProgramDesc
*
desc
GrPixelConfig
config
const
GrPrimitiveProcessor
&
primProc
bool
hasPointSize
const
GrPipeline
&
pipeline
GrGpu
*
gpu
)
{
const
GrShaderCaps
&
shaderCaps
=
*
gpu
-
>
caps
(
)
-
>
shaderCaps
(
)
;
GR_STATIC_ASSERT
(
0
=
=
kProcessorKeysOffset
%
sizeof
(
uint32_t
)
)
;
desc
-
>
key
(
)
.
reset
(
)
;
desc
-
>
key
(
)
.
push_back_n
(
kProcessorKeysOffset
)
;
GrProcessorKeyBuilder
b
(
&
desc
-
>
key
(
)
)
;
primProc
.
getGLSLProcessorKey
(
shaderCaps
&
b
)
;
primProc
.
getAttributeKey
(
&
b
)
;
if
(
!
gen_meta_key
(
primProc
shaderCaps
0
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
pipeline
.
numFragmentProcessors
(
)
;
+
+
i
)
{
const
GrFragmentProcessor
&
fp
=
pipeline
.
getFragmentProcessor
(
i
)
;
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
gpu
shaderCaps
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
}
const
GrXferProcessor
&
xp
=
pipeline
.
getXferProcessor
(
)
;
const
GrSurfaceOrigin
*
originIfDstTexture
=
nullptr
;
GrSurfaceOrigin
origin
;
if
(
pipeline
.
dstTextureProxy
(
)
)
{
origin
=
pipeline
.
dstTextureProxy
(
)
-
>
origin
(
)
;
originIfDstTexture
=
&
origin
;
}
xp
.
getGLSLProcessorKey
(
shaderCaps
&
b
originIfDstTexture
)
;
if
(
!
gen_meta_key
(
xp
shaderCaps
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
KeyHeader
*
header
=
desc
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
memset
(
header
0
kHeaderSize
)
;
header
-
>
fOutputSwizzle
=
shaderCaps
.
configOutputSwizzle
(
config
)
.
asKey
(
)
;
header
-
>
fSnapVerticesToPixelCenters
=
pipeline
.
snapVerticesToPixelCenters
(
)
;
header
-
>
fColorFragmentProcessorCnt
=
pipeline
.
numColorFragmentProcessors
(
)
;
header
-
>
fCoverageFragmentProcessorCnt
=
pipeline
.
numCoverageFragmentProcessors
(
)
;
if
(
header
-
>
fColorFragmentProcessorCnt
!
=
pipeline
.
numColorFragmentProcessors
(
)
|
|
header
-
>
fCoverageFragmentProcessorCnt
!
=
pipeline
.
numCoverageFragmentProcessors
(
)
)
{
return
false
;
}
header
-
>
fHasPointSize
=
hasPointSize
?
1
:
0
;
return
true
;
}
