#
include
"
GrProgramDesc
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLCaps
.
h
"
static
uint16_t
sampler_key
(
GrSLType
samplerType
GrPixelConfig
config
GrShaderFlags
visibility
const
GrGLSLCaps
&
caps
)
{
enum
{
kFirstSamplerType
=
kTexture2DSampler_GrSLType
kLastSamplerType
=
kTextureBufferSampler_GrSLType
kSamplerTypeKeyBits
=
4
}
;
GR_STATIC_ASSERT
(
kLastSamplerType
-
kFirstSamplerType
<
(
1
<
<
kSamplerTypeKeyBits
)
)
;
SkASSERT
(
(
int
)
samplerType
>
=
kFirstSamplerType
&
&
(
int
)
samplerType
<
=
kLastSamplerType
)
;
int
samplerTypeKey
=
samplerType
-
kFirstSamplerType
;
return
SkToU16
(
caps
.
configTextureSwizzle
(
config
)
.
asKey
(
)
|
(
samplerTypeKey
<
<
8
)
|
(
caps
.
samplerPrecision
(
config
visibility
)
<
<
(
8
+
kSamplerTypeKeyBits
)
)
)
;
}
static
void
add_sampler_keys
(
GrProcessorKeyBuilder
*
b
const
GrProcessor
&
proc
const
GrGLSLCaps
&
caps
)
{
int
numTextures
=
proc
.
numTextures
(
)
;
int
numSamplers
=
numTextures
+
proc
.
numBuffers
(
)
;
int
word32Count
=
(
numSamplers
+
1
)
/
2
;
if
(
0
=
=
word32Count
)
{
return
;
}
uint16_t
*
k16
=
SkTCast
<
uint16_t
*
>
(
b
-
>
add32n
(
word32Count
)
)
;
int
i
=
0
;
for
(
;
i
<
numTextures
;
+
+
i
)
{
const
GrTextureAccess
&
access
=
proc
.
textureAccess
(
i
)
;
const
GrTexture
*
tex
=
access
.
getTexture
(
)
;
k16
[
i
]
=
sampler_key
(
tex
-
>
samplerType
(
)
tex
-
>
config
(
)
access
.
getVisibility
(
)
caps
)
;
}
for
(
;
i
<
numSamplers
;
+
+
i
)
{
const
GrBufferAccess
&
access
=
proc
.
bufferAccess
(
i
-
numTextures
)
;
k16
[
i
]
=
sampler_key
(
kTextureBufferSampler_GrSLType
access
.
texelConfig
(
)
access
.
visibility
(
)
caps
)
;
}
if
(
numSamplers
&
0x1
)
{
k16
[
numSamplers
]
=
0
;
}
}
static
bool
gen_meta_key
(
const
GrProcessor
&
proc
const
GrGLSLCaps
&
glslCaps
uint32_t
transformKey
GrProcessorKeyBuilder
*
b
)
{
size_t
processorKeySize
=
b
-
>
size
(
)
;
uint32_t
classID
=
proc
.
classID
(
)
;
static
const
uint32_t
kMetaKeyInvalidMask
=
~
(
(
uint32_t
)
SK_MaxU16
)
;
if
(
(
processorKeySize
|
classID
)
&
kMetaKeyInvalidMask
)
{
return
false
;
}
add_sampler_keys
(
b
proc
glslCaps
)
;
uint32_t
*
key
=
b
-
>
add32n
(
2
)
;
key
[
0
]
=
(
classID
<
<
16
)
|
SkToU32
(
processorKeySize
)
;
key
[
1
]
=
transformKey
;
return
true
;
}
static
bool
gen_frag_proc_and_meta_keys
(
const
GrPrimitiveProcessor
&
primProc
const
GrFragmentProcessor
&
fp
const
GrGLSLCaps
&
glslCaps
GrProcessorKeyBuilder
*
b
)
{
for
(
int
i
=
0
;
i
<
fp
.
numChildProcessors
(
)
;
+
+
i
)
{
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
.
childProcessor
(
i
)
glslCaps
b
)
)
{
return
false
;
}
}
fp
.
getGLSLProcessorKey
(
glslCaps
b
)
;
return
gen_meta_key
(
fp
glslCaps
primProc
.
getTransformKey
(
fp
.
coordTransforms
(
)
fp
.
numCoordTransforms
(
)
)
b
)
;
}
bool
GrProgramDesc
:
:
Build
(
GrProgramDesc
*
desc
const
GrPrimitiveProcessor
&
primProc
bool
hasPointSize
const
GrPipeline
&
pipeline
const
GrGLSLCaps
&
glslCaps
)
{
GR_STATIC_ASSERT
(
0
=
=
kProcessorKeysOffset
%
sizeof
(
uint32_t
)
)
;
desc
-
>
key
(
)
.
reset
(
)
;
desc
-
>
key
(
)
.
push_back_n
(
kProcessorKeysOffset
)
;
GrProcessorKeyBuilder
b
(
&
desc
-
>
key
(
)
)
;
primProc
.
getGLSLProcessorKey
(
glslCaps
&
b
)
;
if
(
!
gen_meta_key
(
primProc
glslCaps
0
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
GrProcessor
:
:
RequiredFeatures
requiredFeatures
=
primProc
.
requiredFeatures
(
)
;
for
(
int
i
=
0
;
i
<
pipeline
.
numFragmentProcessors
(
)
;
+
+
i
)
{
const
GrFragmentProcessor
&
fp
=
pipeline
.
getFragmentProcessor
(
i
)
;
if
(
!
gen_frag_proc_and_meta_keys
(
primProc
fp
glslCaps
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
requiredFeatures
|
=
fp
.
requiredFeatures
(
)
;
}
const
GrXferProcessor
&
xp
=
pipeline
.
getXferProcessor
(
)
;
xp
.
getGLSLProcessorKey
(
glslCaps
&
b
)
;
if
(
!
gen_meta_key
(
xp
glslCaps
0
&
b
)
)
{
desc
-
>
key
(
)
.
reset
(
)
;
return
false
;
}
requiredFeatures
|
=
xp
.
requiredFeatures
(
)
;
KeyHeader
*
header
=
desc
-
>
atOffset
<
KeyHeader
kHeaderOffset
>
(
)
;
memset
(
header
0
kHeaderSize
)
;
GrRenderTarget
*
rt
=
pipeline
.
getRenderTarget
(
)
;
if
(
requiredFeatures
&
(
GrProcessor
:
:
kFragmentPosition_RequiredFeature
|
GrProcessor
:
:
kSampleLocations_RequiredFeature
)
)
{
header
-
>
fSurfaceOriginKey
=
GrGLSLFragmentShaderBuilder
:
:
KeyForSurfaceOrigin
(
rt
-
>
origin
(
)
)
;
}
else
{
header
-
>
fSurfaceOriginKey
=
0
;
}
if
(
requiredFeatures
&
GrProcessor
:
:
kSampleLocations_RequiredFeature
)
{
SkASSERT
(
pipeline
.
isHWAntialiasState
(
)
)
;
header
-
>
fSamplePatternKey
=
rt
-
>
renderTargetPriv
(
)
.
getMultisampleSpecs
(
pipeline
.
getStencil
(
)
)
.
fUniqueID
;
}
else
{
header
-
>
fSamplePatternKey
=
0
;
}
header
-
>
fOutputSwizzle
=
glslCaps
.
configOutputSwizzle
(
rt
-
>
config
(
)
)
.
asKey
(
)
;
header
-
>
fIgnoresCoverage
=
pipeline
.
ignoresCoverage
(
)
?
1
:
0
;
header
-
>
fSnapVerticesToPixelCenters
=
pipeline
.
snapVerticesToPixelCenters
(
)
;
header
-
>
fColorFragmentProcessorCnt
=
pipeline
.
numColorFragmentProcessors
(
)
;
header
-
>
fCoverageFragmentProcessorCnt
=
pipeline
.
numCoverageFragmentProcessors
(
)
;
if
(
header
-
>
fColorFragmentProcessorCnt
!
=
pipeline
.
numColorFragmentProcessors
(
)
|
|
header
-
>
fCoverageFragmentProcessorCnt
!
=
pipeline
.
numCoverageFragmentProcessors
(
)
)
{
return
false
;
}
header
-
>
fHasPointSize
=
hasPointSize
?
1
:
0
;
return
true
;
}
