#
ifndef
GrSurfaceProxy_DEFINED
#
define
GrSurfaceProxy_DEFINED
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrGpuResource
.
h
"
#
include
"
include
/
gpu
/
GrSurface
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
include
/
private
/
SkNoncopyable
.
h
"
#
include
"
src
/
gpu
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
GrSwizzle
.
h
"
class
GrCaps
;
class
GrContext_Base
;
class
GrOpsTask
;
class
GrRecordingContext
;
class
GrRenderTargetProxy
;
class
GrRenderTask
;
class
GrResourceProvider
;
class
GrSurfaceContext
;
class
GrSurfaceProxyPriv
;
class
GrTextureProxy
;
class
GrSurfaceProxy
:
public
GrNonAtomicRef
<
GrSurfaceProxy
>
{
public
:
virtual
~
GrSurfaceProxy
(
)
;
enum
class
ResolveFlags
{
kNone
=
0
kMSAA
=
1
<
<
0
kMipMaps
=
1
<
<
1
}
;
enum
class
LazyInstantiationKeyMode
{
kUnsynced
kSynced
}
;
struct
LazyCallbackResult
{
LazyCallbackResult
(
)
=
default
;
LazyCallbackResult
(
const
LazyCallbackResult
&
)
=
default
;
LazyCallbackResult
(
LazyCallbackResult
&
&
that
)
=
default
;
LazyCallbackResult
(
sk_sp
<
GrSurface
>
surf
bool
releaseCallback
=
true
LazyInstantiationKeyMode
mode
=
LazyInstantiationKeyMode
:
:
kSynced
)
:
fSurface
(
std
:
:
move
(
surf
)
)
fKeyMode
(
mode
)
fReleaseCallback
(
releaseCallback
)
{
}
LazyCallbackResult
(
sk_sp
<
GrTexture
>
tex
)
:
LazyCallbackResult
(
sk_sp
<
GrSurface
>
(
std
:
:
move
(
tex
)
)
)
{
}
LazyCallbackResult
&
operator
=
(
const
LazyCallbackResult
&
)
=
default
;
LazyCallbackResult
&
operator
=
(
LazyCallbackResult
&
&
)
=
default
;
sk_sp
<
GrSurface
>
fSurface
;
LazyInstantiationKeyMode
fKeyMode
=
LazyInstantiationKeyMode
:
:
kSynced
;
bool
fReleaseCallback
=
true
;
}
;
using
LazyInstantiateCallback
=
std
:
:
function
<
LazyCallbackResult
(
GrResourceProvider
*
)
>
;
enum
class
UseAllocator
{
kNo
=
false
kYes
=
true
}
;
bool
isLazy
(
)
const
{
return
!
this
-
>
isInstantiated
(
)
&
&
SkToBool
(
fLazyInstantiateCallback
)
;
}
bool
isFullyLazy
(
)
const
{
bool
result
=
fHeight
<
0
;
SkASSERT
(
result
=
=
(
fWidth
<
0
)
)
;
SkASSERT
(
!
result
|
|
this
-
>
isLazy
(
)
)
;
return
result
;
}
GrPixelConfig
config
(
)
const
{
return
fConfig
;
}
int
width
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
return
fWidth
;
}
int
height
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
return
fHeight
;
}
SkISize
isize
(
)
const
{
return
{
fWidth
fHeight
}
;
}
int
worstCaseWidth
(
)
const
;
int
worstCaseHeight
(
)
const
;
SkRect
getBoundsRect
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
return
SkRect
:
:
MakeIWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
}
SkRect
getWorstCaseBoundsRect
(
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
return
SkRect
:
:
MakeIWH
(
this
-
>
worstCaseWidth
(
)
this
-
>
worstCaseHeight
(
)
)
;
}
GrSurfaceOrigin
origin
(
)
const
{
SkASSERT
(
kTopLeft_GrSurfaceOrigin
=
=
fOrigin
|
|
kBottomLeft_GrSurfaceOrigin
=
=
fOrigin
)
;
return
fOrigin
;
}
const
GrSwizzle
&
textureSwizzle
(
)
const
{
return
fTextureSwizzle
;
}
const
GrBackendFormat
&
backendFormat
(
)
const
{
return
fFormat
;
}
class
UniqueID
{
public
:
static
UniqueID
InvalidID
(
)
{
return
UniqueID
(
uint32_t
(
SK_InvalidUniqueID
)
)
;
}
explicit
UniqueID
(
const
GrGpuResource
:
:
UniqueID
&
id
)
:
fID
(
id
.
asUInt
(
)
)
{
}
UniqueID
(
)
:
fID
(
GrGpuResource
:
:
CreateUniqueID
(
)
)
{
}
uint32_t
asUInt
(
)
const
{
return
fID
;
}
bool
operator
=
=
(
const
UniqueID
&
other
)
const
{
return
fID
=
=
other
.
fID
;
}
bool
operator
!
=
(
const
UniqueID
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isInvalid
(
)
const
{
return
SK_InvalidUniqueID
=
=
fID
;
}
private
:
explicit
UniqueID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
fID
;
}
;
UniqueID
uniqueID
(
)
const
{
return
fUniqueID
;
}
UniqueID
underlyingUniqueID
(
)
const
{
if
(
fTarget
)
{
return
UniqueID
(
fTarget
-
>
uniqueID
(
)
)
;
}
return
fUniqueID
;
}
virtual
bool
instantiate
(
GrResourceProvider
*
)
=
0
;
void
deinstantiate
(
)
;
bool
canSkipResourceAllocator
(
)
const
;
virtual
GrTextureProxy
*
asTextureProxy
(
)
{
return
nullptr
;
}
virtual
const
GrTextureProxy
*
asTextureProxy
(
)
const
{
return
nullptr
;
}
virtual
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
{
return
nullptr
;
}
virtual
const
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
const
{
return
nullptr
;
}
bool
isInstantiated
(
)
const
{
return
SkToBool
(
fTarget
)
;
}
GrSurface
*
peekSurface
(
)
const
{
return
fTarget
.
get
(
)
;
}
GrTexture
*
peekTexture
(
)
const
{
return
fTarget
?
fTarget
-
>
asTexture
(
)
:
nullptr
;
}
GrRenderTarget
*
peekRenderTarget
(
)
const
{
return
fTarget
?
fTarget
-
>
asRenderTarget
(
)
:
nullptr
;
}
SkBudgeted
isBudgeted
(
)
const
{
return
fBudgeted
;
}
bool
readOnly
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kReadOnly
;
}
bool
requiresManualMSAAResolve
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kRequiresManualMSAAResolve
;
}
void
setLastRenderTask
(
GrRenderTask
*
)
;
GrRenderTask
*
getLastRenderTask
(
)
{
return
fLastRenderTask
;
}
GrOpsTask
*
getLastOpsTask
(
)
;
size_t
gpuMemorySize
(
const
GrCaps
&
caps
)
const
{
SkASSERT
(
!
this
-
>
isFullyLazy
(
)
)
;
if
(
fTarget
)
{
return
fTarget
-
>
gpuMemorySize
(
)
;
}
if
(
kInvalidGpuMemorySize
=
=
fGpuMemorySize
)
{
fGpuMemorySize
=
this
-
>
onUninstantiatedGpuMemorySize
(
caps
)
;
SkASSERT
(
kInvalidGpuMemorySize
!
=
fGpuMemorySize
)
;
}
return
fGpuMemorySize
;
}
enum
class
RectsMustMatch
:
bool
{
kNo
=
false
kYes
=
true
}
;
static
sk_sp
<
GrTextureProxy
>
Copy
(
GrRecordingContext
*
GrSurfaceProxy
*
src
GrColorType
srcColorType
GrMipMapped
SkIRect
srcRect
SkBackingFit
SkBudgeted
RectsMustMatch
=
RectsMustMatch
:
:
kNo
)
;
static
sk_sp
<
GrTextureProxy
>
Copy
(
GrRecordingContext
*
GrSurfaceProxy
*
src
GrColorType
srcColortype
GrMipMapped
SkBackingFit
SkBudgeted
)
;
#
if
GR_TEST_UTILS
int32_t
testingOnly_getBackingRefCnt
(
)
const
;
GrInternalSurfaceFlags
testingOnly_getFlags
(
)
const
;
#
endif
SkDEBUGCODE
(
void
validate
(
GrContext_Base
*
)
const
;
)
inline
GrSurfaceProxyPriv
priv
(
)
;
inline
const
GrSurfaceProxyPriv
priv
(
)
const
;
bool
isProtected
(
)
const
{
return
fIsProtected
=
=
GrProtected
:
:
kYes
;
}
protected
:
GrSurfaceProxy
(
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrRenderable
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
SkBackingFit
SkBudgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
)
;
GrSurfaceProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
GrRenderable
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
SkBackingFit
SkBudgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
)
;
GrSurfaceProxy
(
sk_sp
<
GrSurface
>
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
SkBackingFit
UseAllocator
)
;
friend
class
GrSurfaceProxyPriv
;
bool
ignoredByResourceAllocator
(
)
const
{
return
fIgnoredByResourceAllocator
;
}
void
setIgnoredByResourceAllocator
(
)
{
fIgnoredByResourceAllocator
=
true
;
}
void
computeScratchKey
(
GrScratchKey
*
)
const
;
virtual
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
=
0
;
void
assign
(
sk_sp
<
GrSurface
>
surface
)
;
sk_sp
<
GrSurface
>
createSurfaceImpl
(
GrResourceProvider
*
int
sampleCnt
int
minStencilSampleCount
GrRenderable
GrMipMapped
)
const
;
void
setLazySize
(
int
width
int
height
)
{
SkASSERT
(
this
-
>
isFullyLazy
(
)
)
;
SkASSERT
(
width
>
0
&
&
height
>
0
)
;
fWidth
=
width
;
fHeight
=
height
;
}
bool
instantiateImpl
(
GrResourceProvider
*
resourceProvider
int
sampleCnt
int
minStencilSampleCount
GrRenderable
GrMipMapped
const
GrUniqueKey
*
)
;
sk_sp
<
GrSurface
>
fTarget
;
GrInternalSurfaceFlags
fSurfaceFlags
;
private
:
const
GrBackendFormat
fFormat
;
const
GrPixelConfig
fConfig
;
int
fWidth
;
int
fHeight
;
const
GrSurfaceOrigin
fOrigin
;
const
GrSwizzle
fTextureSwizzle
;
SkBackingFit
fFit
;
mutable
SkBudgeted
fBudgeted
;
UseAllocator
fUseAllocator
;
const
UniqueID
fUniqueID
;
LazyInstantiateCallback
fLazyInstantiateCallback
;
SkDEBUGCODE
(
void
validateSurface
(
const
GrSurface
*
)
;
)
SkDEBUGCODE
(
virtual
void
onValidateSurface
(
const
GrSurface
*
)
=
0
;
)
static
const
size_t
kInvalidGpuMemorySize
=
~
static_cast
<
size_t
>
(
0
)
;
SkDEBUGCODE
(
size_t
getRawGpuMemorySize_debugOnly
(
)
const
{
return
fGpuMemorySize
;
}
)
virtual
size_t
onUninstantiatedGpuMemorySize
(
const
GrCaps
&
)
const
=
0
;
bool
fIgnoredByResourceAllocator
=
false
;
GrProtected
fIsProtected
;
mutable
size_t
fGpuMemorySize
;
GrRenderTask
*
fLastRenderTask
=
nullptr
;
}
;
GR_MAKE_BITFIELD_CLASS_OPS
(
GrSurfaceProxy
:
:
ResolveFlags
)
#
endif
