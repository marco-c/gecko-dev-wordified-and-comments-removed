#
ifndef
GrProcessorAnalysis_DEFINED
#
define
GrProcessorAnalysis_DEFINED
#
include
"
GrColor
.
h
"
class
GrDrawOp
;
class
GrFragmentProcessor
;
class
GrPrimitiveProcessor
;
class
GrProcessorAnalysisColor
{
public
:
enum
class
Opaque
{
kNo
kYes
}
;
GrProcessorAnalysisColor
(
Opaque
opaque
=
Opaque
:
:
kNo
)
:
fFlags
(
opaque
=
=
Opaque
:
:
kYes
?
kIsOpaque_Flag
:
0
)
{
}
GrProcessorAnalysisColor
(
GrColor
color
)
{
this
-
>
setToConstant
(
color
)
;
}
void
setToConstant
(
GrColor
color
)
{
fColor
=
color
;
if
(
GrColorIsOpaque
(
color
)
)
{
fFlags
=
kColorIsKnown_Flag
|
kIsOpaque_Flag
;
}
else
{
fFlags
=
kColorIsKnown_Flag
;
}
}
void
setToUnknown
(
)
{
fFlags
=
0
;
}
void
setToUnknownOpaque
(
)
{
fFlags
=
kIsOpaque_Flag
;
}
bool
isOpaque
(
)
const
{
return
SkToBool
(
kIsOpaque_Flag
&
fFlags
)
;
}
bool
isConstant
(
GrColor
*
color
=
nullptr
)
const
{
if
(
kColorIsKnown_Flag
&
fFlags
)
{
if
(
color
)
{
*
color
=
fColor
;
}
return
true
;
}
return
false
;
}
bool
operator
=
=
(
const
GrProcessorAnalysisColor
&
that
)
const
{
if
(
fFlags
!
=
that
.
fFlags
)
{
return
false
;
}
return
(
kColorIsKnown_Flag
&
fFlags
)
?
fColor
=
=
that
.
fColor
:
true
;
}
static
GrProcessorAnalysisColor
Combine
(
const
GrProcessorAnalysisColor
&
a
const
GrProcessorAnalysisColor
&
b
)
{
GrProcessorAnalysisColor
result
;
uint32_t
commonFlags
=
a
.
fFlags
&
b
.
fFlags
;
if
(
(
kColorIsKnown_Flag
&
commonFlags
)
&
&
a
.
fColor
=
=
b
.
fColor
)
{
result
.
fColor
=
a
.
fColor
;
result
.
fFlags
=
a
.
fFlags
;
}
else
if
(
kIsOpaque_Flag
&
commonFlags
)
{
result
.
fFlags
=
kIsOpaque_Flag
;
}
return
result
;
}
private
:
enum
Flags
{
kColorIsKnown_Flag
=
0x1
kIsOpaque_Flag
=
0x2
}
;
uint32_t
fFlags
;
GrColor
fColor
;
}
;
enum
class
GrProcessorAnalysisCoverage
{
kNone
kSingleChannel
kLCD
}
;
class
GrColorFragmentProcessorAnalysis
{
public
:
GrColorFragmentProcessorAnalysis
(
)
=
default
;
GrColorFragmentProcessorAnalysis
(
const
GrProcessorAnalysisColor
&
input
)
:
GrColorFragmentProcessorAnalysis
(
)
{
fAllProcessorsCompatibleWithCoverageAsAlpha
=
true
;
fIsOpaque
=
input
.
isOpaque
(
)
;
GrColor
color
;
if
(
input
.
isConstant
(
&
color
)
)
{
fLastKnownOutputColor
=
GrColor4f
:
:
FromGrColor
(
color
)
;
fProcessorsVisitedWithKnownOutput
=
0
;
}
}
void
reset
(
const
GrProcessorAnalysisColor
&
input
)
{
*
this
=
GrColorFragmentProcessorAnalysis
(
input
)
;
}
void
analyzeProcessors
(
const
GrFragmentProcessor
*
const
*
processors
int
cnt
)
;
bool
isOpaque
(
)
const
{
return
fIsOpaque
;
}
bool
allProcessorsCompatibleWithCoverageAsAlpha
(
)
const
{
return
fAllProcessorsCompatibleWithCoverageAsAlpha
;
}
bool
usesLocalCoords
(
)
const
{
return
fUsesLocalCoords
;
}
int
initialProcessorsToEliminate
(
GrColor
*
newPipelineInputColor
)
const
{
if
(
fProcessorsVisitedWithKnownOutput
>
0
)
{
*
newPipelineInputColor
=
fLastKnownOutputColor
.
toGrColor
(
)
;
}
return
SkTMax
(
0
fProcessorsVisitedWithKnownOutput
)
;
}
int
initialProcessorsToEliminate
(
GrColor4f
*
newPipelineInputColor
)
const
{
if
(
fProcessorsVisitedWithKnownOutput
>
0
)
{
*
newPipelineInputColor
=
fLastKnownOutputColor
;
}
return
SkTMax
(
0
fProcessorsVisitedWithKnownOutput
)
;
}
GrProcessorAnalysisColor
outputColor
(
)
const
{
if
(
fProcessorsVisitedWithKnownOutput
!
=
fTotalProcessorsVisited
)
{
return
GrProcessorAnalysisColor
(
fIsOpaque
?
GrProcessorAnalysisColor
:
:
Opaque
:
:
kYes
:
GrProcessorAnalysisColor
:
:
Opaque
:
:
kNo
)
;
}
return
GrProcessorAnalysisColor
(
fLastKnownOutputColor
.
toGrColor
(
)
)
;
}
private
:
int
fTotalProcessorsVisited
=
0
;
int
fProcessorsVisitedWithKnownOutput
=
-
1
;
bool
fIsOpaque
=
false
;
bool
fAllProcessorsCompatibleWithCoverageAsAlpha
=
true
;
bool
fUsesLocalCoords
=
false
;
GrColor4f
fLastKnownOutputColor
;
}
;
#
endif
