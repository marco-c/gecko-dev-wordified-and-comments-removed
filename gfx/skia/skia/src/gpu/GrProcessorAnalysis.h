#
ifndef
GrProcessorAnalysis_DEFINED
#
define
GrProcessorAnalysis_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
SkPM4f
.
h
"
class
GrDrawOp
;
class
GrFragmentProcessor
;
class
GrPrimitiveProcessor
;
class
GrProcessorAnalysisColor
{
public
:
enum
class
Opaque
{
kNo
kYes
}
;
constexpr
GrProcessorAnalysisColor
(
Opaque
opaque
=
Opaque
:
:
kNo
)
:
fFlags
(
opaque
=
=
Opaque
:
:
kYes
?
kIsOpaque_Flag
:
0
)
fColor
(
0
)
{
}
GrProcessorAnalysisColor
(
GrColor
color
)
{
this
-
>
setToConstant
(
color
)
;
}
void
setToConstant
(
GrColor
color
)
{
fColor
=
color
;
if
(
GrColorIsOpaque
(
color
)
)
{
fFlags
=
kColorIsKnown_Flag
|
kIsOpaque_Flag
;
}
else
{
fFlags
=
kColorIsKnown_Flag
;
}
}
void
setToUnknown
(
)
{
fFlags
=
0
;
}
void
setToUnknownOpaque
(
)
{
fFlags
=
kIsOpaque_Flag
;
}
bool
isOpaque
(
)
const
{
return
SkToBool
(
kIsOpaque_Flag
&
fFlags
)
;
}
bool
isConstant
(
GrColor
*
color
=
nullptr
)
const
{
if
(
kColorIsKnown_Flag
&
fFlags
)
{
if
(
color
)
{
*
color
=
fColor
;
}
return
true
;
}
return
false
;
}
bool
operator
=
=
(
const
GrProcessorAnalysisColor
&
that
)
const
{
if
(
fFlags
!
=
that
.
fFlags
)
{
return
false
;
}
return
(
kColorIsKnown_Flag
&
fFlags
)
?
fColor
=
=
that
.
fColor
:
true
;
}
static
GrProcessorAnalysisColor
Combine
(
const
GrProcessorAnalysisColor
&
a
const
GrProcessorAnalysisColor
&
b
)
{
GrProcessorAnalysisColor
result
;
uint32_t
commonFlags
=
a
.
fFlags
&
b
.
fFlags
;
if
(
(
kColorIsKnown_Flag
&
commonFlags
)
&
&
a
.
fColor
=
=
b
.
fColor
)
{
result
.
fColor
=
a
.
fColor
;
result
.
fFlags
=
a
.
fFlags
;
}
else
if
(
kIsOpaque_Flag
&
commonFlags
)
{
result
.
fFlags
=
kIsOpaque_Flag
;
}
return
result
;
}
private
:
enum
Flags
{
kColorIsKnown_Flag
=
0x1
kIsOpaque_Flag
=
0x2
}
;
uint32_t
fFlags
;
GrColor
fColor
;
}
;
enum
class
GrProcessorAnalysisCoverage
{
kNone
kSingleChannel
kLCD
}
;
class
GrColorFragmentProcessorAnalysis
{
public
:
GrColorFragmentProcessorAnalysis
(
)
=
delete
;
GrColorFragmentProcessorAnalysis
(
const
GrProcessorAnalysisColor
&
input
const
GrFragmentProcessor
*
const
*
processors
int
cnt
)
;
bool
isOpaque
(
)
const
{
return
fIsOpaque
;
}
bool
allProcessorsCompatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
bool
usesLocalCoords
(
)
const
{
return
fUsesLocalCoords
;
}
int
initialProcessorsToEliminate
(
GrColor
*
newPipelineInputColor
)
const
{
if
(
fProcessorsToEliminate
>
0
)
{
*
newPipelineInputColor
=
GrColor4f
:
:
FromRGBA4f
(
fLastKnownOutputColor
)
.
toGrColor
(
)
;
}
return
fProcessorsToEliminate
;
}
int
initialProcessorsToEliminate
(
SkPMColor4f
*
newPipelineInputColor
)
const
{
if
(
fProcessorsToEliminate
>
0
)
{
*
newPipelineInputColor
=
fLastKnownOutputColor
;
}
return
fProcessorsToEliminate
;
}
GrProcessorAnalysisColor
outputColor
(
)
const
{
if
(
fKnowOutputColor
)
{
return
GrColor4f
:
:
FromRGBA4f
(
fLastKnownOutputColor
)
.
toGrColor
(
)
;
}
return
fIsOpaque
?
GrProcessorAnalysisColor
:
:
Opaque
:
:
kYes
:
GrProcessorAnalysisColor
:
:
Opaque
:
:
kNo
;
}
private
:
bool
fIsOpaque
;
bool
fCompatibleWithCoverageAsAlpha
;
bool
fUsesLocalCoords
;
bool
fKnowOutputColor
;
int
fProcessorsToEliminate
;
SkPMColor4f
fLastKnownOutputColor
;
}
;
#
endif
