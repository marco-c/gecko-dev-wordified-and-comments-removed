#
include
"
src
/
gpu
/
GrRenderTask
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetPriv
.
h
"
#
include
"
src
/
gpu
/
GrStencilAttachment
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxyPriv
.
h
"
#
include
"
src
/
gpu
/
GrTextureResolveRenderTask
.
h
"
uint32_t
GrRenderTask
:
:
CreateUniqueID
(
)
{
static
std
:
:
atomic
<
uint32_t
>
nextID
{
1
}
;
uint32_t
id
;
do
{
id
=
nextID
+
+
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
GrRenderTask
:
:
GrRenderTask
(
sk_sp
<
GrSurfaceProxy
>
target
)
:
fTarget
(
std
:
:
move
(
target
)
)
fUniqueID
(
CreateUniqueID
(
)
)
fFlags
(
0
)
{
}
GrRenderTask
:
:
~
GrRenderTask
(
)
{
if
(
fTarget
&
&
this
=
=
fTarget
-
>
getLastRenderTask
(
)
)
{
fTarget
-
>
setLastRenderTask
(
nullptr
)
;
}
}
#
ifdef
SK_DEBUG
bool
GrRenderTask
:
:
deferredProxiesAreInstantiated
(
)
const
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
if
(
!
fDeferredProxies
[
i
]
-
>
isInstantiated
(
)
)
{
return
false
;
}
}
return
true
;
}
#
endif
void
GrRenderTask
:
:
makeClosed
(
const
GrCaps
&
caps
)
{
if
(
this
-
>
isClosed
(
)
)
{
return
;
}
SkIRect
targetUpdateBounds
;
if
(
ExpectedOutcome
:
:
kTargetDirty
=
=
this
-
>
onMakeClosed
(
caps
&
targetUpdateBounds
)
)
{
SkASSERT
(
SkIRect
:
:
MakeWH
(
fTarget
-
>
width
(
)
fTarget
-
>
height
(
)
)
.
contains
(
targetUpdateBounds
)
)
;
if
(
fTarget
-
>
requiresManualMSAAResolve
(
)
)
{
SkASSERT
(
fTarget
-
>
asRenderTargetProxy
(
)
)
;
fTarget
-
>
asRenderTargetProxy
(
)
-
>
markMSAADirty
(
targetUpdateBounds
)
;
}
GrTextureProxy
*
textureProxy
=
fTarget
-
>
asTextureProxy
(
)
;
if
(
textureProxy
&
&
GrMipMapped
:
:
kYes
=
=
textureProxy
-
>
mipMapped
(
)
)
{
textureProxy
-
>
markMipMapsDirty
(
)
;
}
}
if
(
fTextureResolveTask
)
{
this
-
>
addDependency
(
fTextureResolveTask
)
;
fTextureResolveTask
-
>
makeClosed
(
caps
)
;
fTextureResolveTask
=
nullptr
;
}
this
-
>
setFlag
(
kClosed_Flag
)
;
}
void
GrRenderTask
:
:
prepare
(
GrOpFlushState
*
flushState
)
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
fDeferredProxies
[
i
]
-
>
texPriv
(
)
.
scheduleUpload
(
flushState
)
;
}
this
-
>
onPrepare
(
flushState
)
;
}
void
GrRenderTask
:
:
addDependency
(
GrRenderTask
*
dependedOn
)
{
SkASSERT
(
!
dependedOn
-
>
dependsOn
(
this
)
)
;
SkASSERT
(
!
this
-
>
dependsOn
(
dependedOn
)
)
;
fDependencies
.
push_back
(
dependedOn
)
;
dependedOn
-
>
addDependent
(
this
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrRenderTask
:
:
addDependenciesFromOtherTask
(
GrRenderTask
*
otherTask
)
{
SkASSERT
(
otherTask
)
;
for
(
GrRenderTask
*
task
:
otherTask
-
>
fDependencies
)
{
SkASSERT
(
task
!
=
this
)
;
if
(
!
this
-
>
dependsOn
(
task
)
)
{
this
-
>
addDependency
(
task
)
;
}
}
}
void
GrRenderTask
:
:
addDependency
(
GrSurfaceProxy
*
dependedOn
GrMipMapped
mipMapped
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrRenderTask
*
dependedOnTask
=
dependedOn
-
>
getLastRenderTask
(
)
;
if
(
dependedOnTask
=
=
this
)
{
SkASSERT
(
GrMipMapped
:
:
kNo
=
=
mipMapped
)
;
SkASSERT
(
!
dependedOn
-
>
requiresManualMSAAResolve
(
)
)
;
SkASSERT
(
!
dependedOn
-
>
asTextureProxy
(
)
|
|
!
dependedOn
-
>
asTextureProxy
(
)
-
>
texPriv
(
)
.
isDeferred
(
)
)
;
return
;
}
if
(
dependedOnTask
)
{
if
(
this
-
>
dependsOn
(
dependedOnTask
)
|
|
fTextureResolveTask
=
=
dependedOnTask
)
{
return
;
}
dependedOnTask
-
>
makeClosed
(
caps
)
;
}
auto
resolveFlags
=
GrSurfaceProxy
:
:
ResolveFlags
:
:
kNone
;
if
(
dependedOn
-
>
requiresManualMSAAResolve
(
)
)
{
auto
*
renderTargetProxy
=
dependedOn
-
>
asRenderTargetProxy
(
)
;
SkASSERT
(
renderTargetProxy
)
;
if
(
renderTargetProxy
-
>
isMSAADirty
(
)
)
{
resolveFlags
|
=
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMSAA
;
}
}
GrTextureProxy
*
textureProxy
=
dependedOn
-
>
asTextureProxy
(
)
;
if
(
GrMipMapped
:
:
kYes
=
=
mipMapped
)
{
SkASSERT
(
textureProxy
)
;
if
(
GrMipMapped
:
:
kYes
!
=
textureProxy
-
>
mipMapped
(
)
)
{
mipMapped
=
GrMipMapped
:
:
kNo
;
}
else
if
(
textureProxy
-
>
mipMapsAreDirty
(
)
)
{
resolveFlags
|
=
GrSurfaceProxy
:
:
ResolveFlags
:
:
kMipMaps
;
}
}
if
(
GrSurfaceProxy
:
:
ResolveFlags
:
:
kNone
!
=
resolveFlags
)
{
if
(
!
fTextureResolveTask
)
{
fTextureResolveTask
=
textureResolveManager
.
newTextureResolveRenderTask
(
caps
)
;
}
fTextureResolveTask
-
>
addProxy
(
sk_ref_sp
(
dependedOn
)
resolveFlags
caps
)
;
SkASSERT
(
!
dependedOnTask
|
|
dependedOnTask
-
>
isClosed
(
)
)
;
SkASSERT
(
dependedOn
-
>
getLastRenderTask
(
)
=
=
fTextureResolveTask
)
;
#
ifdef
SK_DEBUG
if
(
dependedOnTask
)
{
SkASSERT
(
fTextureResolveTask
-
>
dependsOn
(
dependedOnTask
)
)
;
}
if
(
textureProxy
&
&
textureProxy
-
>
texPriv
(
)
.
isDeferred
(
)
)
{
SkASSERT
(
fTextureResolveTask
-
>
fDeferredProxies
.
back
(
)
=
=
textureProxy
)
;
}
if
(
GrRenderTargetProxy
*
renderTargetProxy
=
dependedOn
-
>
asRenderTargetProxy
(
)
)
{
SkASSERT
(
!
renderTargetProxy
-
>
isMSAADirty
(
)
)
;
}
if
(
textureProxy
)
{
SkASSERT
(
!
textureProxy
-
>
mipMapsAreDirty
(
)
)
;
}
SkASSERT
(
dependedOn
-
>
getLastRenderTask
(
)
=
=
fTextureResolveTask
)
;
#
endif
return
;
}
if
(
textureProxy
&
&
textureProxy
-
>
texPriv
(
)
.
isDeferred
(
)
)
{
fDeferredProxies
.
push_back
(
textureProxy
)
;
}
if
(
dependedOnTask
)
{
this
-
>
addDependency
(
dependedOnTask
)
;
}
}
bool
GrRenderTask
:
:
dependsOn
(
const
GrRenderTask
*
dependedOn
)
const
{
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
if
(
fDependencies
[
i
]
=
=
dependedOn
)
{
return
true
;
}
}
return
false
;
}
void
GrRenderTask
:
:
addDependent
(
GrRenderTask
*
dependent
)
{
fDependents
.
push_back
(
dependent
)
;
}
#
ifdef
SK_DEBUG
bool
GrRenderTask
:
:
isDependedent
(
const
GrRenderTask
*
dependent
)
const
{
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
if
(
fDependents
[
i
]
=
=
dependent
)
{
return
true
;
}
}
return
false
;
}
void
GrRenderTask
:
:
validate
(
)
const
{
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
fDependencies
[
i
]
-
>
isDependedent
(
this
)
)
;
}
}
#
endif
void
GrRenderTask
:
:
closeThoseWhoDependOnMe
(
const
GrCaps
&
caps
)
{
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
if
(
!
fDependents
[
i
]
-
>
isClosed
(
)
)
{
fDependents
[
i
]
-
>
makeClosed
(
caps
)
;
}
}
}
bool
GrRenderTask
:
:
isInstantiated
(
)
const
{
if
(
!
fTarget
)
{
return
true
;
}
if
(
!
fTarget
-
>
isInstantiated
(
)
)
{
return
false
;
}
int
minStencilSampleCount
=
(
fTarget
-
>
asRenderTargetProxy
(
)
)
?
fTarget
-
>
asRenderTargetProxy
(
)
-
>
numStencilSamples
(
)
:
0
;
if
(
minStencilSampleCount
)
{
GrRenderTarget
*
rt
=
fTarget
-
>
peekRenderTarget
(
)
;
SkASSERT
(
rt
)
;
GrStencilAttachment
*
stencil
=
rt
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
;
if
(
!
stencil
)
{
return
false
;
}
SkASSERT
(
stencil
-
>
numSamples
(
)
>
=
minStencilSampleCount
)
;
}
GrSurface
*
surface
=
fTarget
-
>
peekSurface
(
)
;
if
(
surface
-
>
wasDestroyed
(
)
)
{
return
false
;
}
return
true
;
}
#
ifdef
SK_DEBUG
void
GrRenderTask
:
:
dump
(
bool
printDependencies
)
const
{
SkDebugf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
SkDebugf
(
"
renderTaskID
:
%
d
-
proxyID
:
%
d
-
surfaceID
:
%
d
\
n
"
fUniqueID
fTarget
?
fTarget
-
>
uniqueID
(
)
.
asUInt
(
)
:
-
1
fTarget
&
&
fTarget
-
>
peekSurface
(
)
?
fTarget
-
>
peekSurface
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
:
-
1
)
;
if
(
printDependencies
)
{
SkDebugf
(
"
I
rely
On
(
%
d
)
:
"
fDependencies
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fDependencies
[
i
]
-
>
fUniqueID
)
;
}
SkDebugf
(
"
\
n
"
)
;
SkDebugf
(
"
(
%
d
)
Rely
On
Me
:
"
fDependents
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fDependents
[
i
]
-
>
fUniqueID
)
;
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
