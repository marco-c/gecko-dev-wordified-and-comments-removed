#
include
"
GrProxyProvider
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrResourceKey
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrTextureProxyCacheAccess
.
h
"
#
include
"
GrTextureRenderTargetProxy
.
h
"
#
include
"
.
.
/
private
/
GrSingleOwner
.
h
"
#
include
"
SkAutoPixmapStorage
.
h
"
#
include
"
SkBitmap
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkImage_Base
.
h
"
#
include
"
SkImageInfoPriv
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkTraceEvent
.
h
"
#
define
ASSERT_SINGLE_OWNER
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
fSingleOwner
)
;
)
GrProxyProvider
:
:
GrProxyProvider
(
GrResourceProvider
*
resourceProvider
GrResourceCache
*
resourceCache
sk_sp
<
const
GrCaps
>
caps
GrSingleOwner
*
owner
)
:
fResourceProvider
(
resourceProvider
)
fResourceCache
(
resourceCache
)
fAbandoned
(
false
)
fCaps
(
caps
)
fContextUniqueID
(
resourceCache
-
>
contextUniqueID
(
)
)
#
ifdef
SK_DEBUG
fSingleOwner
(
owner
)
#
endif
{
SkASSERT
(
fResourceProvider
)
;
SkASSERT
(
fResourceCache
)
;
SkASSERT
(
fCaps
)
;
SkASSERT
(
fSingleOwner
)
;
}
GrProxyProvider
:
:
GrProxyProvider
(
uint32_t
contextUniqueID
sk_sp
<
const
GrCaps
>
caps
GrSingleOwner
*
owner
)
:
fResourceProvider
(
nullptr
)
fResourceCache
(
nullptr
)
fAbandoned
(
false
)
fCaps
(
caps
)
fContextUniqueID
(
contextUniqueID
)
#
ifdef
SK_DEBUG
fSingleOwner
(
owner
)
#
endif
{
SkASSERT
(
fContextUniqueID
!
=
SK_InvalidUniqueID
)
;
SkASSERT
(
fCaps
)
;
SkASSERT
(
fSingleOwner
)
;
}
GrProxyProvider
:
:
~
GrProxyProvider
(
)
{
if
(
fResourceCache
)
{
SkASSERT
(
!
fUniquelyKeyedProxies
.
count
(
)
)
;
}
}
bool
GrProxyProvider
:
:
assignUniqueKeyToProxy
(
const
GrUniqueKey
&
key
GrTextureProxy
*
proxy
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
key
.
isValid
(
)
)
;
if
(
this
-
>
isAbandoned
(
)
|
|
!
proxy
)
{
return
false
;
}
SkASSERT
(
!
fResourceCache
|
|
!
fResourceCache
-
>
findAndRefUniqueResource
(
key
)
)
;
SkASSERT
(
!
fUniquelyKeyedProxies
.
find
(
key
)
)
;
proxy
-
>
cacheAccess
(
)
.
setUniqueKey
(
this
key
)
;
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
=
=
key
)
;
fUniquelyKeyedProxies
.
add
(
proxy
)
;
return
true
;
}
void
GrProxyProvider
:
:
adoptUniqueKeyFromSurface
(
GrTextureProxy
*
proxy
const
GrSurface
*
surf
)
{
SkASSERT
(
surf
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
proxy
-
>
cacheAccess
(
)
.
setUniqueKey
(
this
surf
-
>
getUniqueKey
(
)
)
;
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
=
=
surf
-
>
getUniqueKey
(
)
)
;
SkASSERT
(
!
fUniquelyKeyedProxies
.
find
(
surf
-
>
getUniqueKey
(
)
)
)
;
fUniquelyKeyedProxies
.
add
(
proxy
)
;
}
void
GrProxyProvider
:
:
removeUniqueKeyFromProxy
(
const
GrUniqueKey
&
key
GrTextureProxy
*
proxy
)
{
ASSERT_SINGLE_OWNER
if
(
this
-
>
isAbandoned
(
)
|
|
!
proxy
)
{
return
;
}
this
-
>
processInvalidProxyUniqueKey
(
key
proxy
true
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
findProxyByUniqueKey
(
const
GrUniqueKey
&
key
GrSurfaceOrigin
origin
)
{
ASSERT_SINGLE_OWNER
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
result
=
sk_ref_sp
(
fUniquelyKeyedProxies
.
find
(
key
)
)
;
if
(
result
)
{
SkASSERT
(
result
-
>
origin
(
)
=
=
origin
)
;
}
return
result
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createWrapped
(
sk_sp
<
GrTexture
>
tex
GrSurfaceOrigin
origin
)
{
#
ifdef
SK_DEBUG
if
(
tex
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
SkASSERT
(
!
this
-
>
findProxyByUniqueKey
(
tex
-
>
getUniqueKey
(
)
origin
)
)
;
}
#
endif
if
(
tex
-
>
asRenderTarget
(
)
)
{
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureRenderTargetProxy
(
std
:
:
move
(
tex
)
origin
)
)
;
}
else
{
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureProxy
(
std
:
:
move
(
tex
)
origin
)
)
;
}
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
findOrCreateProxyByUniqueKey
(
const
GrUniqueKey
&
key
GrSurfaceOrigin
origin
)
{
ASSERT_SINGLE_OWNER
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
result
=
this
-
>
findProxyByUniqueKey
(
key
origin
)
;
if
(
result
)
{
return
result
;
}
if
(
!
fResourceCache
)
{
return
nullptr
;
}
GrGpuResource
*
resource
=
fResourceCache
-
>
findAndRefUniqueResource
(
key
)
;
if
(
!
resource
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
texture
(
static_cast
<
GrSurface
*
>
(
resource
)
-
>
asTexture
(
)
)
;
SkASSERT
(
texture
)
;
result
=
this
-
>
createWrapped
(
std
:
:
move
(
texture
)
origin
)
;
SkASSERT
(
result
-
>
getUniqueKey
(
)
=
=
key
)
;
SkASSERT
(
fUniquelyKeyedProxies
.
find
(
key
)
)
;
return
result
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createTextureProxy
(
sk_sp
<
SkImage
>
srcImage
GrSurfaceDescFlags
descFlags
int
sampleCnt
SkBudgeted
budgeted
SkBackingFit
fit
GrInternalSurfaceFlags
surfaceFlags
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
srcImage
)
;
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
SkImageInfo
info
=
as_IB
(
srcImage
)
-
>
onImageInfo
(
)
;
GrPixelConfig
config
=
SkImageInfo2GrPixelConfig
(
info
)
;
if
(
kUnknown_GrPixelConfig
=
=
config
)
{
return
nullptr
;
}
if
(
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
config
)
)
{
SkBitmap
copy8888
;
if
(
!
copy8888
.
tryAllocPixels
(
info
.
makeColorType
(
kRGBA_8888_SkColorType
)
)
|
|
!
srcImage
-
>
readPixels
(
copy8888
.
pixmap
(
)
0
0
)
)
{
return
nullptr
;
}
copy8888
.
setImmutable
(
)
;
srcImage
=
SkMakeImageFromRasterBitmap
(
copy8888
kNever_SkCopyPixelsMode
)
;
config
=
kRGBA_8888_GrPixelConfig
;
}
if
(
SkToBool
(
descFlags
&
kRenderTarget_GrSurfaceFlag
)
)
{
sampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
config
)
;
if
(
!
sampleCnt
)
{
return
nullptr
;
}
}
if
(
SkToBool
(
descFlags
&
kRenderTarget_GrSurfaceFlag
)
)
{
if
(
fCaps
-
>
usesMixedSamples
(
)
&
&
sampleCnt
>
1
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kMixedSampled
;
}
if
(
fCaps
-
>
maxWindowRectangles
(
)
>
0
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kWindowRectsSupport
;
}
}
GrSurfaceDesc
desc
;
desc
.
fWidth
=
srcImage
-
>
width
(
)
;
desc
.
fHeight
=
srcImage
-
>
height
(
)
;
desc
.
fFlags
=
descFlags
;
desc
.
fSampleCnt
=
sampleCnt
;
desc
.
fConfig
=
config
;
sk_sp
<
GrTextureProxy
>
proxy
=
this
-
>
createLazyProxy
(
[
desc
budgeted
srcImage
fit
surfaceFlags
]
(
GrResourceProvider
*
resourceProvider
)
{
if
(
!
resourceProvider
)
{
return
sk_sp
<
GrTexture
>
(
)
;
}
SkPixmap
pixMap
;
SkAssertResult
(
srcImage
-
>
peekPixels
(
&
pixMap
)
)
;
GrMipLevel
mipLevel
=
{
pixMap
.
addr
(
)
pixMap
.
rowBytes
(
)
}
;
auto
resourceProviderFlags
=
GrResourceProvider
:
:
Flags
:
:
kNone
;
if
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kNoPendingIO
)
{
resourceProviderFlags
|
=
GrResourceProvider
:
:
Flags
:
:
kNoPendingIO
;
}
return
resourceProvider
-
>
createTexture
(
desc
budgeted
fit
mipLevel
resourceProviderFlags
)
;
}
desc
kTopLeft_GrSurfaceOrigin
GrMipMapped
:
:
kNo
GrTextureType
:
:
k2D
surfaceFlags
fit
budgeted
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
if
(
fResourceProvider
)
{
if
(
!
proxy
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
)
{
return
nullptr
;
}
}
SkASSERT
(
proxy
-
>
width
(
)
=
=
desc
.
fWidth
)
;
SkASSERT
(
proxy
-
>
height
(
)
=
=
desc
.
fHeight
)
;
return
proxy
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createMipMapProxy
(
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
SkBudgeted
budgeted
)
{
ASSERT_SINGLE_OWNER
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
return
this
-
>
createProxy
(
desc
origin
GrMipMapped
:
:
kYes
SkBackingFit
:
:
kExact
budgeted
GrInternalSurfaceFlags
:
:
kNone
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createMipMapProxyFromBitmap
(
const
SkBitmap
&
bitmap
)
{
if
(
!
SkImageInfoIsValid
(
bitmap
.
info
(
)
)
)
{
return
nullptr
;
}
ATRACE_ANDROID_FRAMEWORK
(
"
Upload
MipMap
Texture
[
%
ux
%
u
]
"
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
SkCopyPixelsMode
copyMode
=
this
-
>
recordingDDL
(
)
?
kIfMutable_SkCopyPixelsMode
:
kNever_SkCopyPixelsMode
;
sk_sp
<
SkImage
>
baseLevel
=
SkMakeImageFromRasterBitmap
(
bitmap
copyMode
)
;
if
(
!
baseLevel
)
{
return
nullptr
;
}
if
(
0
=
=
SkMipMap
:
:
ComputeLevelCount
(
baseLevel
-
>
width
(
)
baseLevel
-
>
height
(
)
)
)
{
return
this
-
>
createTextureProxy
(
baseLevel
kNone_GrSurfaceFlags
1
SkBudgeted
:
:
kYes
SkBackingFit
:
:
kExact
)
;
}
GrSurfaceDesc
desc
=
GrImageInfoToSurfaceDesc
(
bitmap
.
info
(
)
)
;
if
(
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
desc
.
fConfig
)
)
{
SkBitmap
copy8888
;
if
(
!
copy8888
.
tryAllocPixels
(
bitmap
.
info
(
)
.
makeColorType
(
kRGBA_8888_SkColorType
)
)
|
|
!
bitmap
.
readPixels
(
copy8888
.
pixmap
(
)
)
)
{
return
nullptr
;
}
copy8888
.
setImmutable
(
)
;
baseLevel
=
SkMakeImageFromRasterBitmap
(
copy8888
kNever_SkCopyPixelsMode
)
;
desc
.
fConfig
=
kRGBA_8888_GrPixelConfig
;
}
SkPixmap
pixmap
;
SkAssertResult
(
baseLevel
-
>
peekPixels
(
&
pixmap
)
)
;
sk_sp
<
SkMipMap
>
mipmaps
(
SkMipMap
:
:
Build
(
pixmap
nullptr
)
)
;
if
(
!
mipmaps
)
{
return
nullptr
;
}
sk_sp
<
GrTextureProxy
>
proxy
=
this
-
>
createLazyProxy
(
[
desc
baseLevel
mipmaps
]
(
GrResourceProvider
*
resourceProvider
)
{
if
(
!
resourceProvider
)
{
return
sk_sp
<
GrTexture
>
(
)
;
}
const
int
mipLevelCount
=
mipmaps
-
>
countLevels
(
)
+
1
;
std
:
:
unique_ptr
<
GrMipLevel
[
]
>
texels
(
new
GrMipLevel
[
mipLevelCount
]
)
;
SkPixmap
pixmap
;
SkAssertResult
(
baseLevel
-
>
peekPixels
(
&
pixmap
)
)
;
texels
[
0
]
.
fPixels
=
pixmap
.
addr
(
)
;
texels
[
0
]
.
fRowBytes
=
pixmap
.
rowBytes
(
)
;
for
(
int
i
=
1
;
i
<
mipLevelCount
;
+
+
i
)
{
SkMipMap
:
:
Level
generatedMipLevel
;
mipmaps
-
>
getLevel
(
i
-
1
&
generatedMipLevel
)
;
texels
[
i
]
.
fPixels
=
generatedMipLevel
.
fPixmap
.
addr
(
)
;
texels
[
i
]
.
fRowBytes
=
generatedMipLevel
.
fPixmap
.
rowBytes
(
)
;
SkASSERT
(
texels
[
i
]
.
fPixels
)
;
}
return
resourceProvider
-
>
createTexture
(
desc
SkBudgeted
:
:
kYes
texels
.
get
(
)
mipLevelCount
)
;
}
desc
kTopLeft_GrSurfaceOrigin
GrMipMapped
:
:
kYes
GrTextureType
:
:
k2D
SkBackingFit
:
:
kExact
SkBudgeted
:
:
kYes
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
if
(
fResourceProvider
)
{
if
(
!
proxy
-
>
priv
(
)
.
doLazyInstantiation
(
fResourceProvider
)
)
{
return
nullptr
;
}
}
return
proxy
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createProxy
(
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
GrMipMapped
mipMapped
SkBackingFit
fit
SkBudgeted
budgeted
GrInternalSurfaceFlags
surfaceFlags
)
{
if
(
GrMipMapped
:
:
kYes
=
=
mipMapped
)
{
int
mipCount
=
SkMipMap
:
:
ComputeLevelCount
(
desc
.
fWidth
desc
.
fHeight
)
+
1
;
if
(
1
=
=
mipCount
)
{
mipMapped
=
GrMipMapped
:
:
kNo
;
}
}
if
(
!
this
-
>
caps
(
)
-
>
validateSurfaceDesc
(
desc
mipMapped
)
)
{
return
nullptr
;
}
GrSurfaceDesc
copyDesc
=
desc
;
if
(
desc
.
fFlags
&
kRenderTarget_GrSurfaceFlag
)
{
copyDesc
.
fSampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
desc
.
fSampleCnt
desc
.
fConfig
)
;
}
if
(
copyDesc
.
fFlags
&
kRenderTarget_GrSurfaceFlag
)
{
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureRenderTargetProxy
(
*
this
-
>
caps
(
)
copyDesc
origin
mipMapped
GrTextureType
:
:
k2D
fit
budgeted
surfaceFlags
)
)
;
}
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureProxy
(
copyDesc
origin
mipMapped
GrTextureType
:
:
k2D
fit
budgeted
surfaceFlags
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
wrapBackendTexture
(
const
GrBackendTexture
&
backendTex
GrSurfaceOrigin
origin
GrWrapOwnership
ownership
ReleaseProc
releaseProc
ReleaseContext
releaseCtx
)
{
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
if
(
!
fResourceProvider
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
tex
=
fResourceProvider
-
>
wrapBackendTexture
(
backendTex
ownership
)
;
if
(
!
tex
)
{
return
nullptr
;
}
sk_sp
<
GrReleaseProcHelper
>
releaseHelper
;
if
(
releaseProc
)
{
releaseHelper
.
reset
(
new
GrReleaseProcHelper
(
releaseProc
releaseCtx
)
)
;
tex
-
>
setRelease
(
releaseHelper
)
;
}
SkASSERT
(
!
tex
-
>
asRenderTarget
(
)
)
;
SkASSERT
(
SkBudgeted
:
:
kNo
=
=
tex
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
;
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureProxy
(
std
:
:
move
(
tex
)
origin
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
wrapRenderableBackendTexture
(
const
GrBackendTexture
&
backendTex
GrSurfaceOrigin
origin
int
sampleCnt
GrWrapOwnership
ownership
)
{
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
if
(
!
fResourceProvider
)
{
return
nullptr
;
}
sampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
backendTex
.
config
(
)
)
;
if
(
!
sampleCnt
)
{
return
nullptr
;
}
sk_sp
<
GrTexture
>
tex
=
fResourceProvider
-
>
wrapRenderableBackendTexture
(
backendTex
sampleCnt
ownership
)
;
if
(
!
tex
)
{
return
nullptr
;
}
SkASSERT
(
tex
-
>
asRenderTarget
(
)
)
;
SkASSERT
(
SkBudgeted
:
:
kNo
=
=
tex
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
;
return
sk_sp
<
GrTextureProxy
>
(
new
GrTextureRenderTargetProxy
(
std
:
:
move
(
tex
)
origin
)
)
;
}
sk_sp
<
GrSurfaceProxy
>
GrProxyProvider
:
:
wrapBackendRenderTarget
(
const
GrBackendRenderTarget
&
backendRT
GrSurfaceOrigin
origin
)
{
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
if
(
!
fResourceProvider
)
{
return
nullptr
;
}
sk_sp
<
GrRenderTarget
>
rt
=
fResourceProvider
-
>
wrapBackendRenderTarget
(
backendRT
)
;
if
(
!
rt
)
{
return
nullptr
;
}
SkASSERT
(
!
rt
-
>
asTexture
(
)
)
;
SkASSERT
(
!
rt
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
SkASSERT
(
SkBudgeted
:
:
kNo
=
=
rt
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
;
return
sk_sp
<
GrRenderTargetProxy
>
(
new
GrRenderTargetProxy
(
std
:
:
move
(
rt
)
origin
)
)
;
}
sk_sp
<
GrSurfaceProxy
>
GrProxyProvider
:
:
wrapBackendTextureAsRenderTarget
(
const
GrBackendTexture
&
backendTex
GrSurfaceOrigin
origin
int
sampleCnt
)
{
if
(
this
-
>
isAbandoned
(
)
)
{
return
nullptr
;
}
if
(
!
fResourceProvider
)
{
return
nullptr
;
}
sk_sp
<
GrRenderTarget
>
rt
=
fResourceProvider
-
>
wrapBackendTextureAsRenderTarget
(
backendTex
sampleCnt
)
;
if
(
!
rt
)
{
return
nullptr
;
}
SkASSERT
(
!
rt
-
>
asTexture
(
)
)
;
SkASSERT
(
!
rt
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
SkASSERT
(
SkBudgeted
:
:
kNo
=
=
rt
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
;
return
sk_sp
<
GrSurfaceProxy
>
(
new
GrRenderTargetProxy
(
std
:
:
move
(
rt
)
origin
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createLazyProxy
(
LazyInstantiateCallback
&
&
callback
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
GrMipMapped
mipMapped
GrTextureType
textureType
SkBackingFit
fit
SkBudgeted
budgeted
)
{
return
this
-
>
createLazyProxy
(
std
:
:
move
(
callback
)
desc
origin
mipMapped
textureType
GrInternalSurfaceFlags
:
:
kNone
fit
budgeted
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createLazyProxy
(
LazyInstantiateCallback
&
&
callback
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
GrMipMapped
mipMapped
GrTextureType
textureType
GrInternalSurfaceFlags
surfaceFlags
SkBackingFit
fit
SkBudgeted
budgeted
)
{
LazyInstantiationType
lazyType
=
fResourceProvider
?
LazyInstantiationType
:
:
kSingleUse
:
LazyInstantiationType
:
:
kMultipleUse
;
return
this
-
>
createLazyProxy
(
std
:
:
move
(
callback
)
desc
origin
mipMapped
textureType
surfaceFlags
fit
budgeted
lazyType
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
createLazyProxy
(
LazyInstantiateCallback
&
&
callback
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
GrMipMapped
mipMapped
GrTextureType
textureType
GrInternalSurfaceFlags
surfaceFlags
SkBackingFit
fit
SkBudgeted
budgeted
LazyInstantiationType
lazyType
)
{
SkASSERT
(
(
desc
.
fWidth
<
=
0
&
&
desc
.
fHeight
<
=
0
)
|
|
(
desc
.
fWidth
>
0
&
&
desc
.
fHeight
>
0
)
)
;
if
(
desc
.
fWidth
>
fCaps
-
>
maxTextureSize
(
)
|
|
desc
.
fHeight
>
fCaps
-
>
maxTextureSize
(
)
)
{
return
nullptr
;
}
#
ifdef
SK_DEBUG
if
(
SkToBool
(
kRenderTarget_GrSurfaceFlag
&
desc
.
fFlags
)
)
{
if
(
SkToBool
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kMixedSampled
)
)
{
SkASSERT
(
fCaps
-
>
usesMixedSamples
(
)
&
&
desc
.
fSampleCnt
>
1
)
;
}
if
(
SkToBool
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kWindowRectsSupport
)
)
{
SkASSERT
(
fCaps
-
>
maxWindowRectangles
(
)
>
0
)
;
}
}
#
endif
return
sk_sp
<
GrTextureProxy
>
(
SkToBool
(
kRenderTarget_GrSurfaceFlag
&
desc
.
fFlags
)
?
new
GrTextureRenderTargetProxy
(
std
:
:
move
(
callback
)
lazyType
desc
origin
mipMapped
textureType
fit
budgeted
surfaceFlags
)
:
new
GrTextureProxy
(
std
:
:
move
(
callback
)
lazyType
desc
origin
mipMapped
textureType
fit
budgeted
surfaceFlags
)
)
;
}
sk_sp
<
GrRenderTargetProxy
>
GrProxyProvider
:
:
createLazyRenderTargetProxy
(
LazyInstantiateCallback
&
&
callback
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
GrInternalSurfaceFlags
surfaceFlags
const
TextureInfo
*
textureInfo
SkBackingFit
fit
SkBudgeted
budgeted
)
{
SkASSERT
(
(
desc
.
fWidth
<
=
0
&
&
desc
.
fHeight
<
=
0
)
|
|
(
desc
.
fWidth
>
0
&
&
desc
.
fHeight
>
0
)
)
;
if
(
desc
.
fWidth
>
fCaps
-
>
maxRenderTargetSize
(
)
|
|
desc
.
fHeight
>
fCaps
-
>
maxRenderTargetSize
(
)
)
{
return
nullptr
;
}
SkASSERT
(
SkToBool
(
kRenderTarget_GrSurfaceFlag
&
desc
.
fFlags
)
)
;
#
ifdef
SK_DEBUG
if
(
SkToBool
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kMixedSampled
)
)
{
SkASSERT
(
fCaps
-
>
usesMixedSamples
(
)
&
&
desc
.
fSampleCnt
>
1
)
;
}
if
(
SkToBool
(
surfaceFlags
&
GrInternalSurfaceFlags
:
:
kWindowRectsSupport
)
)
{
SkASSERT
(
fCaps
-
>
maxWindowRectangles
(
)
>
0
)
;
}
#
endif
using
LazyInstantiationType
=
GrSurfaceProxy
:
:
LazyInstantiationType
;
LazyInstantiationType
lazyType
=
fResourceProvider
?
LazyInstantiationType
:
:
kSingleUse
:
LazyInstantiationType
:
:
kMultipleUse
;
if
(
textureInfo
)
{
return
sk_sp
<
GrRenderTargetProxy
>
(
new
GrTextureRenderTargetProxy
(
std
:
:
move
(
callback
)
lazyType
desc
origin
textureInfo
-
>
fMipMapped
textureInfo
-
>
fTextureType
fit
budgeted
surfaceFlags
)
)
;
}
return
sk_sp
<
GrRenderTargetProxy
>
(
new
GrRenderTargetProxy
(
std
:
:
move
(
callback
)
lazyType
desc
origin
fit
budgeted
surfaceFlags
)
)
;
}
sk_sp
<
GrTextureProxy
>
GrProxyProvider
:
:
MakeFullyLazyProxy
(
LazyInstantiateCallback
&
&
callback
Renderable
renderable
GrSurfaceOrigin
origin
GrPixelConfig
config
const
GrCaps
&
caps
)
{
GrSurfaceDesc
desc
;
GrInternalSurfaceFlags
surfaceFlags
=
GrInternalSurfaceFlags
:
:
kNoPendingIO
;
if
(
Renderable
:
:
kYes
=
=
renderable
)
{
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
if
(
caps
.
maxWindowRectangles
(
)
>
0
)
{
surfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kWindowRectsSupport
;
}
}
desc
.
fWidth
=
-
1
;
desc
.
fHeight
=
-
1
;
desc
.
fConfig
=
config
;
desc
.
fSampleCnt
=
1
;
static
constexpr
auto
kTextureType
=
GrTextureType
:
:
k2D
;
return
sk_sp
<
GrTextureProxy
>
(
(
Renderable
:
:
kYes
=
=
renderable
)
?
new
GrTextureRenderTargetProxy
(
std
:
:
move
(
callback
)
LazyInstantiationType
:
:
kSingleUse
desc
origin
GrMipMapped
:
:
kNo
kTextureType
SkBackingFit
:
:
kApprox
SkBudgeted
:
:
kYes
surfaceFlags
)
:
new
GrTextureProxy
(
std
:
:
move
(
callback
)
LazyInstantiationType
:
:
kSingleUse
desc
origin
GrMipMapped
:
:
kNo
kTextureType
SkBackingFit
:
:
kApprox
SkBudgeted
:
:
kYes
surfaceFlags
)
)
;
}
bool
GrProxyProvider
:
:
IsFunctionallyExact
(
GrSurfaceProxy
*
proxy
)
{
const
bool
isInstantiated
=
proxy
-
>
isInstantiated
(
)
;
return
proxy
-
>
priv
(
)
.
isExact
(
)
|
|
(
!
isInstantiated
&
&
SkIsPow2
(
proxy
-
>
width
(
)
)
&
&
SkIsPow2
(
proxy
-
>
height
(
)
)
)
|
|
(
isInstantiated
&
&
proxy
-
>
worstCaseWidth
(
)
=
=
proxy
-
>
width
(
)
&
&
proxy
-
>
worstCaseHeight
(
)
=
=
proxy
-
>
height
(
)
)
;
}
void
GrProxyProvider
:
:
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
key
)
{
GrTextureProxy
*
proxy
=
fUniquelyKeyedProxies
.
find
(
key
)
;
if
(
proxy
)
{
this
-
>
processInvalidProxyUniqueKey
(
key
proxy
false
)
;
}
}
void
GrProxyProvider
:
:
processInvalidProxyUniqueKey
(
const
GrUniqueKey
&
key
GrTextureProxy
*
proxy
bool
invalidateSurface
)
{
SkASSERT
(
proxy
)
;
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
SkASSERT
(
proxy
-
>
getUniqueKey
(
)
=
=
key
)
;
fUniquelyKeyedProxies
.
remove
(
key
)
;
proxy
-
>
cacheAccess
(
)
.
clearUniqueKey
(
)
;
if
(
invalidateSurface
&
&
proxy
-
>
isInstantiated
(
)
)
{
GrSurface
*
surface
=
proxy
-
>
peekSurface
(
)
;
if
(
surface
)
{
surface
-
>
resourcePriv
(
)
.
removeUniqueKey
(
)
;
}
}
}
void
GrProxyProvider
:
:
orphanAllUniqueKeys
(
)
{
UniquelyKeyedProxyHash
:
:
Iter
iter
(
&
fUniquelyKeyedProxies
)
;
for
(
UniquelyKeyedProxyHash
:
:
Iter
iter
(
&
fUniquelyKeyedProxies
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
GrTextureProxy
&
tmp
=
*
iter
;
tmp
.
fProxyProvider
=
nullptr
;
}
}
void
GrProxyProvider
:
:
removeAllUniqueKeys
(
)
{
UniquelyKeyedProxyHash
:
:
Iter
iter
(
&
fUniquelyKeyedProxies
)
;
for
(
UniquelyKeyedProxyHash
:
:
Iter
iter
(
&
fUniquelyKeyedProxies
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
GrTextureProxy
&
tmp
=
*
iter
;
this
-
>
processInvalidProxyUniqueKey
(
tmp
.
getUniqueKey
(
)
&
tmp
false
)
;
}
SkASSERT
(
!
fUniquelyKeyedProxies
.
count
(
)
)
;
}
