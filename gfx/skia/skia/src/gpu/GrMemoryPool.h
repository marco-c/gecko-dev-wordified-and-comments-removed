#
ifndef
GrMemoryPool_DEFINED
#
define
GrMemoryPool_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
ifdef
SK_DEBUG
#
include
"
include
/
private
/
SkTHash
.
h
"
#
endif
class
GrMemoryPool
{
public
:
GrMemoryPool
(
size_t
preallocSize
size_t
minAllocSize
)
;
~
GrMemoryPool
(
)
;
void
*
allocate
(
size_t
size
)
;
void
release
(
void
*
p
)
;
bool
isEmpty
(
)
const
{
return
fTail
=
=
fHead
&
&
!
fHead
-
>
fLiveCount
;
}
size_t
size
(
)
const
{
return
fSize
;
}
size_t
preallocSize
(
)
const
{
return
fHead
-
>
fSize
;
}
constexpr
static
size_t
kSmallestMinAllocSize
=
1
<
<
10
;
private
:
struct
BlockHeader
;
static
BlockHeader
*
CreateBlock
(
size_t
size
)
;
static
void
DeleteBlock
(
BlockHeader
*
block
)
;
void
validate
(
)
;
struct
BlockHeader
{
#
ifdef
SK_DEBUG
uint32_t
fBlockSentinal
;
#
endif
BlockHeader
*
fNext
;
BlockHeader
*
fPrev
;
int
fLiveCount
;
intptr_t
fCurrPtr
;
intptr_t
fPrevPtr
;
size_t
fFreeSize
;
size_t
fSize
;
}
;
static
const
uint32_t
kAssignedMarker
=
0xCDCDCDCD
;
static
const
uint32_t
kFreedMarker
=
0xEFEFEFEF
;
struct
AllocHeader
{
#
ifdef
SK_DEBUG
uint32_t
fSentinal
;
int32_t
fID
;
#
endif
BlockHeader
*
fHeader
;
}
;
size_t
fSize
;
size_t
fMinAllocSize
;
BlockHeader
*
fHead
;
BlockHeader
*
fTail
;
#
ifdef
SK_DEBUG
int
fAllocationCnt
;
int
fAllocBlockCnt
;
SkTHashSet
<
int32_t
>
fAllocatedIDs
;
#
endif
protected
:
enum
{
kAlignment
=
8
kHeaderSize
=
GrSizeAlignUp
(
sizeof
(
BlockHeader
)
kAlignment
)
kPerAllocPad
=
GrSizeAlignUp
(
sizeof
(
AllocHeader
)
kAlignment
)
}
;
}
;
class
GrOp
;
class
GrOpMemoryPool
:
public
SkRefCnt
{
public
:
GrOpMemoryPool
(
size_t
preallocSize
size_t
minAllocSize
)
:
fMemoryPool
(
preallocSize
minAllocSize
)
{
}
template
<
typename
Op
typename
.
.
.
OpArgs
>
std
:
:
unique_ptr
<
Op
>
allocate
(
OpArgs
&
&
.
.
.
opArgs
)
{
char
*
mem
=
(
char
*
)
fMemoryPool
.
allocate
(
sizeof
(
Op
)
)
;
return
std
:
:
unique_ptr
<
Op
>
(
new
(
mem
)
Op
(
std
:
:
forward
<
OpArgs
>
(
opArgs
)
.
.
.
)
)
;
}
void
*
allocate
(
size_t
size
)
{
return
fMemoryPool
.
allocate
(
size
)
;
}
void
release
(
std
:
:
unique_ptr
<
GrOp
>
op
)
;
bool
isEmpty
(
)
const
{
return
fMemoryPool
.
isEmpty
(
)
;
}
private
:
GrMemoryPool
fMemoryPool
;
}
;
#
endif
