#
include
"
SkGpuDevice
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrFontScaler
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrImageIDTextureAdjuster
.
h
"
#
include
"
GrLayerHoister
.
h
"
#
include
"
GrRecordReplaceDraw
.
h
"
#
include
"
GrStrokeInfo
.
h
"
#
include
"
GrTextContext
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
SkCanvasPriv
.
h
"
#
include
"
SkErrorInternals
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkGrTexturePixelRef
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkGrPriv
.
h
"
#
include
"
SkImage_Base
.
h
"
#
include
"
SkImageFilter
.
h
"
#
include
"
SkLayerInfo
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkNinePatchIter
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkPicture
.
h
"
#
include
"
SkPictureData
.
h
"
#
include
"
SkRRect
.
h
"
#
include
"
SkRecord
.
h
"
#
include
"
SkStroke
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
SkVertState
.
h
"
#
include
"
SkXfermode
.
h
"
#
include
"
batches
/
GrRectBatchFactory
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrDashingEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
#
if
SK_SUPPORT_GPU
enum
{
kDefaultImageFilterCacheSize
=
32
*
1024
*
1024
}
;
#
if
0
extern
bool
(
*
gShouldDrawProc
)
(
)
;
#
define
CHECK_SHOULD_DRAW
(
draw
)
\
do
{
\
if
(
gShouldDrawProc
&
&
!
gShouldDrawProc
(
)
)
return
;
\
this
-
>
prepareDraw
(
draw
)
;
\
}
while
(
0
)
#
else
#
define
CHECK_SHOULD_DRAW
(
draw
)
this
-
>
prepareDraw
(
draw
)
#
endif
#
define
DO_DEFERRED_CLEAR
(
)
\
do
{
\
if
(
fNeedClear
)
{
\
this
-
>
clearAll
(
)
;
\
}
\
}
while
(
false
)
\
#
define
CHECK_FOR_ANNOTATION
(
paint
)
\
do
{
if
(
paint
.
getAnnotation
(
)
)
{
return
;
}
}
while
(
0
)
class
AutoBitmapTexture
:
public
SkNoncopyable
{
public
:
AutoBitmapTexture
(
)
{
}
AutoBitmapTexture
(
GrContext
*
context
const
SkBitmap
&
bitmap
const
GrTextureParams
&
params
GrTexture
*
*
texture
)
{
SkASSERT
(
texture
)
;
*
texture
=
this
-
>
set
(
context
bitmap
params
)
;
}
GrTexture
*
set
(
GrContext
*
context
const
SkBitmap
&
bitmap
const
GrTextureParams
&
params
)
{
if
(
GrTexture
*
bmpTexture
=
bitmap
.
getTexture
(
)
)
{
fTexture
.
reset
(
nullptr
)
;
return
bmpTexture
;
}
else
{
fTexture
.
reset
(
GrRefCachedBitmapTexture
(
context
bitmap
params
)
)
;
return
fTexture
.
get
(
)
;
}
}
private
:
SkAutoTUnref
<
GrTexture
>
fTexture
;
}
;
bool
SkGpuDevice
:
:
CheckAlphaTypeAndGetFlags
(
const
SkImageInfo
*
info
SkGpuDevice
:
:
InitContents
init
unsigned
*
flags
)
{
*
flags
=
0
;
if
(
info
)
{
switch
(
info
-
>
alphaType
(
)
)
{
case
kPremul_SkAlphaType
:
break
;
case
kOpaque_SkAlphaType
:
*
flags
|
=
SkGpuDevice
:
:
kIsOpaque_Flag
;
break
;
default
:
return
false
;
}
}
if
(
kClear_InitContents
=
=
init
)
{
*
flags
|
=
kNeedClear_Flag
;
}
return
true
;
}
SkGpuDevice
*
SkGpuDevice
:
:
Create
(
GrRenderTarget
*
rt
const
SkSurfaceProps
*
props
InitContents
init
)
{
return
SkGpuDevice
:
:
Create
(
rt
rt
-
>
width
(
)
rt
-
>
height
(
)
props
init
)
;
}
SkGpuDevice
*
SkGpuDevice
:
:
Create
(
GrRenderTarget
*
rt
int
width
int
height
const
SkSurfaceProps
*
props
InitContents
init
)
{
if
(
!
rt
|
|
rt
-
>
wasDestroyed
(
)
)
{
return
nullptr
;
}
unsigned
flags
;
if
(
!
CheckAlphaTypeAndGetFlags
(
nullptr
init
&
flags
)
)
{
return
nullptr
;
}
return
new
SkGpuDevice
(
rt
width
height
props
flags
)
;
}
SkGpuDevice
*
SkGpuDevice
:
:
Create
(
GrContext
*
context
SkSurface
:
:
Budgeted
budgeted
const
SkImageInfo
&
info
int
sampleCount
const
SkSurfaceProps
*
props
InitContents
init
)
{
unsigned
flags
;
if
(
!
CheckAlphaTypeAndGetFlags
(
&
info
init
&
flags
)
)
{
return
nullptr
;
}
SkAutoTUnref
<
GrRenderTarget
>
rt
(
CreateRenderTarget
(
context
budgeted
info
sampleCount
)
)
;
if
(
nullptr
=
=
rt
)
{
return
nullptr
;
}
return
new
SkGpuDevice
(
rt
info
.
width
(
)
info
.
height
(
)
props
flags
)
;
}
SkGpuDevice
:
:
SkGpuDevice
(
GrRenderTarget
*
rt
int
width
int
height
const
SkSurfaceProps
*
props
unsigned
flags
)
:
INHERITED
(
SkSurfacePropsCopyOrDefault
(
props
)
)
{
fContext
=
SkRef
(
rt
-
>
getContext
(
)
)
;
fNeedClear
=
SkToBool
(
flags
&
kNeedClear_Flag
)
;
fOpaque
=
SkToBool
(
flags
&
kIsOpaque_Flag
)
;
fRenderTarget
=
SkRef
(
rt
)
;
SkAlphaType
at
=
fOpaque
?
kOpaque_SkAlphaType
:
kPremul_SkAlphaType
;
SkImageInfo
info
=
rt
-
>
surfacePriv
(
)
.
info
(
at
)
.
makeWH
(
width
height
)
;
SkPixelRef
*
pr
=
new
SkGrPixelRef
(
info
rt
)
;
fLegacyBitmap
.
setInfo
(
info
)
;
fLegacyBitmap
.
setPixelRef
(
pr
)
-
>
unref
(
)
;
fDrawContext
.
reset
(
this
-
>
context
(
)
-
>
drawContext
(
rt
&
this
-
>
surfaceProps
(
)
)
)
;
}
GrRenderTarget
*
SkGpuDevice
:
:
CreateRenderTarget
(
GrContext
*
context
SkSurface
:
:
Budgeted
budgeted
const
SkImageInfo
&
origInfo
int
sampleCount
)
{
if
(
kUnknown_SkColorType
=
=
origInfo
.
colorType
(
)
|
|
origInfo
.
width
(
)
<
0
|
|
origInfo
.
height
(
)
<
0
)
{
return
nullptr
;
}
if
(
!
context
)
{
return
nullptr
;
}
SkColorType
ct
=
origInfo
.
colorType
(
)
;
SkAlphaType
at
=
origInfo
.
alphaType
(
)
;
if
(
kRGB_565_SkColorType
=
=
ct
)
{
at
=
kOpaque_SkAlphaType
;
}
else
if
(
ct
!
=
kBGRA_8888_SkColorType
&
&
ct
!
=
kRGBA_8888_SkColorType
)
{
ct
=
kN32_SkColorType
;
}
if
(
kOpaque_SkAlphaType
!
=
at
)
{
at
=
kPremul_SkAlphaType
;
}
const
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
origInfo
.
width
(
)
origInfo
.
height
(
)
ct
at
)
;
GrSurfaceDesc
desc
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fWidth
=
info
.
width
(
)
;
desc
.
fHeight
=
info
.
height
(
)
;
desc
.
fConfig
=
SkImageInfo2GrPixelConfig
(
info
)
;
desc
.
fSampleCnt
=
sampleCount
;
GrTexture
*
texture
=
context
-
>
textureProvider
(
)
-
>
createTexture
(
desc
SkToBool
(
budgeted
)
nullptr
0
)
;
if
(
nullptr
=
=
texture
)
{
return
nullptr
;
}
SkASSERT
(
nullptr
!
=
texture
-
>
asRenderTarget
(
)
)
;
return
texture
-
>
asRenderTarget
(
)
;
}
SkGpuDevice
:
:
~
SkGpuDevice
(
)
{
fRenderTarget
-
>
unref
(
)
;
fContext
-
>
unref
(
)
;
}
bool
SkGpuDevice
:
:
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
x
int
y
)
{
DO_DEFERRED_CLEAR
(
)
;
GrPixelConfig
config
=
SkImageInfo2GrPixelConfig
(
dstInfo
)
;
if
(
kUnknown_GrPixelConfig
=
=
config
)
{
return
false
;
}
uint32_t
flags
=
0
;
if
(
kUnpremul_SkAlphaType
=
=
dstInfo
.
alphaType
(
)
)
{
flags
=
GrContext
:
:
kUnpremul_PixelOpsFlag
;
}
return
fRenderTarget
-
>
readPixels
(
x
y
dstInfo
.
width
(
)
dstInfo
.
height
(
)
config
dstPixels
dstRowBytes
flags
)
;
}
bool
SkGpuDevice
:
:
onWritePixels
(
const
SkImageInfo
&
info
const
void
*
pixels
size_t
rowBytes
int
x
int
y
)
{
GrPixelConfig
config
=
SkImageInfo2GrPixelConfig
(
info
)
;
if
(
kUnknown_GrPixelConfig
=
=
config
)
{
return
false
;
}
uint32_t
flags
=
0
;
if
(
kUnpremul_SkAlphaType
=
=
info
.
alphaType
(
)
)
{
flags
=
GrContext
:
:
kUnpremul_PixelOpsFlag
;
}
fRenderTarget
-
>
writePixels
(
x
y
info
.
width
(
)
info
.
height
(
)
config
pixels
rowBytes
flags
)
;
fLegacyBitmap
.
notifyPixelsChanged
(
)
;
return
true
;
}
const
SkBitmap
&
SkGpuDevice
:
:
onAccessBitmap
(
)
{
DO_DEFERRED_CLEAR
(
)
;
return
fLegacyBitmap
;
}
bool
SkGpuDevice
:
:
onAccessPixels
(
SkPixmap
*
pmap
)
{
DO_DEFERRED_CLEAR
(
)
;
fLegacyBitmap
.
notifyPixelsChanged
(
)
;
return
false
;
}
void
SkGpuDevice
:
:
onAttachToCanvas
(
SkCanvas
*
canvas
)
{
INHERITED
:
:
onAttachToCanvas
(
canvas
)
;
fClipStack
.
reset
(
SkRef
(
canvas
-
>
getClipStack
(
)
)
)
;
}
void
SkGpuDevice
:
:
onDetachFromCanvas
(
)
{
INHERITED
:
:
onDetachFromCanvas
(
)
;
fClip
.
reset
(
)
;
fClipStack
.
reset
(
nullptr
)
;
}
void
SkGpuDevice
:
:
prepareDraw
(
const
SkDraw
&
draw
)
{
SkASSERT
(
fClipStack
.
get
(
)
)
;
SkASSERT
(
draw
.
fClipStack
&
&
draw
.
fClipStack
=
=
fClipStack
)
;
fClip
.
setClipStack
(
fClipStack
&
this
-
>
getOrigin
(
)
)
;
DO_DEFERRED_CLEAR
(
)
;
}
GrRenderTarget
*
SkGpuDevice
:
:
accessRenderTarget
(
)
{
DO_DEFERRED_CLEAR
(
)
;
return
fRenderTarget
;
}
void
SkGpuDevice
:
:
clearAll
(
)
{
GrColor
color
=
0
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
clearAll
"
fContext
)
;
SkIRect
rect
=
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
fDrawContext
-
>
clear
(
&
rect
color
true
)
;
fNeedClear
=
false
;
}
void
SkGpuDevice
:
:
replaceRenderTarget
(
bool
shouldRetainContent
)
{
SkASSERT
(
!
fNeedClear
)
;
SkSurface
:
:
Budgeted
budgeted
=
fRenderTarget
-
>
resourcePriv
(
)
.
isBudgeted
(
)
?
SkSurface
:
:
kYes_Budgeted
:
SkSurface
:
:
kNo_Budgeted
;
SkAutoTUnref
<
GrRenderTarget
>
newRT
(
CreateRenderTarget
(
this
-
>
context
(
)
budgeted
this
-
>
imageInfo
(
)
fRenderTarget
-
>
desc
(
)
.
fSampleCnt
)
)
;
if
(
nullptr
=
=
newRT
)
{
return
;
}
if
(
shouldRetainContent
)
{
if
(
fRenderTarget
-
>
wasDestroyed
(
)
)
{
return
;
}
this
-
>
context
(
)
-
>
copySurface
(
newRT
fRenderTarget
)
;
}
SkASSERT
(
fRenderTarget
!
=
newRT
)
;
fRenderTarget
-
>
unref
(
)
;
fRenderTarget
=
newRT
.
detach
(
)
;
#
ifdef
SK_DEBUG
SkImageInfo
info
=
fRenderTarget
-
>
surfacePriv
(
)
.
info
(
fOpaque
?
kOpaque_SkAlphaType
:
kPremul_SkAlphaType
)
;
SkASSERT
(
info
=
=
fLegacyBitmap
.
info
(
)
)
;
#
endif
SkPixelRef
*
pr
=
new
SkGrPixelRef
(
fLegacyBitmap
.
info
(
)
fRenderTarget
)
;
fLegacyBitmap
.
setPixelRef
(
pr
)
-
>
unref
(
)
;
fDrawContext
.
reset
(
this
-
>
context
(
)
-
>
drawContext
(
fRenderTarget
&
this
-
>
surfaceProps
(
)
)
)
;
}
void
SkGpuDevice
:
:
drawPaint
(
const
SkDraw
&
draw
const
SkPaint
&
paint
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawPaint
"
fContext
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
fDrawContext
-
>
drawPaint
(
fClip
grPaint
*
draw
.
fMatrix
)
;
}
static
const
GrPrimitiveType
gPointMode2PrimtiveType
[
]
=
{
kPoints_GrPrimitiveType
kLines_GrPrimitiveType
kLineStrip_GrPrimitiveType
}
;
static
bool
needs_antialiasing
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
)
{
if
(
mode
=
=
SkCanvas
:
:
PointMode
:
:
kPoints_PointMode
)
{
return
false
;
}
if
(
count
=
=
2
)
{
if
(
pts
[
0
]
.
fX
=
=
pts
[
1
]
.
fX
)
{
return
(
(
int
)
pts
[
0
]
.
fX
)
!
=
pts
[
0
]
.
fX
;
}
if
(
pts
[
0
]
.
fY
=
=
pts
[
1
]
.
fY
)
{
return
(
(
int
)
pts
[
0
]
.
fY
)
!
=
pts
[
0
]
.
fY
;
}
}
return
true
;
}
void
SkGpuDevice
:
:
drawPoints
(
const
SkDraw
&
draw
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
const
SkPaint
&
paint
)
{
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
SkScalar
width
=
paint
.
getStrokeWidth
(
)
;
if
(
width
<
0
)
{
return
;
}
if
(
paint
.
getPathEffect
(
)
&
&
2
=
=
count
&
&
SkCanvas
:
:
kLines_PointMode
=
=
mode
)
{
GrStrokeInfo
strokeInfo
(
paint
SkPaint
:
:
kStroke_Style
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
moveTo
(
pts
[
0
]
)
;
path
.
lineTo
(
pts
[
1
]
)
;
fDrawContext
-
>
drawPath
(
fClip
grPaint
*
draw
.
fMatrix
path
strokeInfo
)
;
return
;
}
if
(
width
>
0
|
|
paint
.
getPathEffect
(
)
|
|
paint
.
getMaskFilter
(
)
|
|
(
paint
.
isAntiAlias
(
)
&
&
needs_antialiasing
(
mode
count
pts
)
)
)
{
draw
.
drawPoints
(
mode
count
pts
paint
true
)
;
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
fDrawContext
-
>
drawVertices
(
fClip
grPaint
*
draw
.
fMatrix
gPointMode2PrimtiveType
[
mode
]
SkToS32
(
count
)
(
SkPoint
*
)
pts
nullptr
nullptr
nullptr
0
)
;
}
void
SkGpuDevice
:
:
drawRect
(
const
SkDraw
&
draw
const
SkRect
&
rect
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawRect
"
fContext
)
;
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
bool
doStroke
=
paint
.
getStyle
(
)
!
=
SkPaint
:
:
kFill_Style
;
SkScalar
width
=
paint
.
getStrokeWidth
(
)
;
bool
usePath
=
doStroke
&
&
width
>
0
&
&
(
paint
.
getStrokeJoin
(
)
=
=
SkPaint
:
:
kRound_Join
|
|
(
paint
.
getStrokeJoin
(
)
=
=
SkPaint
:
:
kBevel_Join
&
&
rect
.
isEmpty
(
)
)
)
;
if
(
paint
.
getMaskFilter
(
)
|
|
paint
.
getPathEffect
(
)
|
|
paint
.
getStyle
(
)
=
=
SkPaint
:
:
kStrokeAndFill_Style
)
{
usePath
=
true
;
}
if
(
!
usePath
&
&
paint
.
isAntiAlias
(
)
&
&
!
draw
.
fMatrix
-
>
rectStaysRect
(
)
)
{
usePath
=
true
;
}
if
(
usePath
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRect
(
rect
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
fDrawContext
fClip
path
paint
*
draw
.
fMatrix
nullptr
draw
.
fClip
-
>
getBounds
(
)
true
)
;
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
GrStrokeInfo
strokeInfo
(
paint
)
;
fDrawContext
-
>
drawRect
(
fClip
grPaint
*
draw
.
fMatrix
rect
&
strokeInfo
)
;
}
void
SkGpuDevice
:
:
drawRRect
(
const
SkDraw
&
draw
const
SkRRect
&
rect
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawRRect
"
fContext
)
;
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
GrStrokeInfo
strokeInfo
(
paint
)
;
if
(
paint
.
getMaskFilter
(
)
)
{
SkRRect
devRRect
;
if
(
rect
.
transform
(
*
draw
.
fMatrix
&
devRRect
)
)
{
if
(
devRRect
.
allCornersCircular
(
)
)
{
SkRect
maskRect
;
if
(
paint
.
getMaskFilter
(
)
-
>
canFilterMaskGPU
(
devRRect
draw
.
fClip
-
>
getBounds
(
)
*
draw
.
fMatrix
&
maskRect
)
)
{
SkIRect
finalIRect
;
maskRect
.
roundOut
(
&
finalIRect
)
;
if
(
draw
.
fClip
-
>
quickReject
(
finalIRect
)
)
{
return
;
}
if
(
paint
.
getMaskFilter
(
)
-
>
directFilterRRectMaskGPU
(
fContext
-
>
textureProvider
(
)
fDrawContext
&
grPaint
fClip
*
draw
.
fMatrix
strokeInfo
devRRect
)
)
{
return
;
}
}
}
}
}
if
(
paint
.
getMaskFilter
(
)
|
|
paint
.
getPathEffect
(
)
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
rect
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
fDrawContext
fClip
path
paint
*
draw
.
fMatrix
nullptr
draw
.
fClip
-
>
getBounds
(
)
true
)
;
return
;
}
SkASSERT
(
!
strokeInfo
.
isDashed
(
)
)
;
fDrawContext
-
>
drawRRect
(
fClip
grPaint
*
draw
.
fMatrix
rect
strokeInfo
)
;
}
void
SkGpuDevice
:
:
drawDRRect
(
const
SkDraw
&
draw
const
SkRRect
&
outer
const
SkRRect
&
inner
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawDRRect
"
fContext
)
;
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
SkStrokeRec
stroke
(
paint
)
;
if
(
stroke
.
isFillStyle
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getPathEffect
(
)
)
{
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
fDrawContext
-
>
drawDRRect
(
fClip
grPaint
*
draw
.
fMatrix
outer
inner
)
;
return
;
}
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
outer
)
;
path
.
addRRect
(
inner
)
;
path
.
setFillType
(
SkPath
:
:
kEvenOdd_FillType
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
fDrawContext
fClip
path
paint
*
draw
.
fMatrix
nullptr
draw
.
fClip
-
>
getBounds
(
)
true
)
;
}
void
SkGpuDevice
:
:
drawOval
(
const
SkDraw
&
draw
const
SkRect
&
oval
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawOval
"
fContext
)
;
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
if
(
paint
.
getPathEffect
(
)
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addOval
(
oval
)
;
this
-
>
drawPath
(
draw
path
paint
nullptr
true
)
;
return
;
}
if
(
paint
.
getMaskFilter
(
)
)
{
SkRRect
rr
=
SkRRect
:
:
MakeOval
(
oval
)
;
return
this
-
>
drawRRect
(
draw
rr
paint
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
GrStrokeInfo
strokeInfo
(
paint
)
;
SkASSERT
(
!
strokeInfo
.
isDashed
(
)
)
;
fDrawContext
-
>
drawOval
(
fClip
grPaint
*
draw
.
fMatrix
oval
strokeInfo
)
;
}
#
include
"
SkMaskFilter
.
h
"
static
SkBitmap
wrap_texture
(
GrTexture
*
texture
int
width
int
height
)
{
SkBitmap
result
;
result
.
setInfo
(
SkImageInfo
:
:
MakeN32Premul
(
width
height
)
)
;
result
.
setPixelRef
(
new
SkGrPixelRef
(
result
.
info
(
)
texture
)
)
-
>
unref
(
)
;
return
result
;
}
void
SkGpuDevice
:
:
drawPath
(
const
SkDraw
&
draw
const
SkPath
&
origSrcPath
const
SkPaint
&
paint
const
SkMatrix
*
prePathMatrix
bool
pathIsMutable
)
{
if
(
!
origSrcPath
.
isInverseFillType
(
)
&
&
!
paint
.
getPathEffect
(
)
&
&
!
prePathMatrix
)
{
bool
isClosed
;
SkRect
rect
;
if
(
origSrcPath
.
isRect
(
&
rect
&
isClosed
)
&
&
isClosed
)
{
this
-
>
drawRect
(
draw
rect
paint
)
;
return
;
}
if
(
origSrcPath
.
isOval
(
&
rect
)
)
{
this
-
>
drawOval
(
draw
rect
paint
)
;
return
;
}
SkRRect
rrect
;
if
(
origSrcPath
.
isRRect
(
&
rrect
)
)
{
this
-
>
drawRRect
(
draw
rrect
paint
)
;
return
;
}
}
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawPath
"
fContext
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
fDrawContext
fClip
origSrcPath
paint
*
draw
.
fMatrix
prePathMatrix
draw
.
fClip
-
>
getBounds
(
)
pathIsMutable
)
;
}
static
const
int
kBmpSmallTileSize
=
1
<
<
10
;
static
inline
int
get_tile_count
(
const
SkIRect
&
srcRect
int
tileSize
)
{
int
tilesX
=
(
srcRect
.
fRight
/
tileSize
)
-
(
srcRect
.
fLeft
/
tileSize
)
+
1
;
int
tilesY
=
(
srcRect
.
fBottom
/
tileSize
)
-
(
srcRect
.
fTop
/
tileSize
)
+
1
;
return
tilesX
*
tilesY
;
}
static
int
determine_tile_size
(
const
SkIRect
&
src
int
maxTileSize
)
{
if
(
maxTileSize
<
=
kBmpSmallTileSize
)
{
return
maxTileSize
;
}
size_t
maxTileTotalTileSize
=
get_tile_count
(
src
maxTileSize
)
;
size_t
smallTotalTileSize
=
get_tile_count
(
src
kBmpSmallTileSize
)
;
maxTileTotalTileSize
*
=
maxTileSize
*
maxTileSize
;
smallTotalTileSize
*
=
kBmpSmallTileSize
*
kBmpSmallTileSize
;
if
(
maxTileTotalTileSize
>
2
*
smallTotalTileSize
)
{
return
kBmpSmallTileSize
;
}
else
{
return
maxTileSize
;
}
}
static
void
determine_clipped_src_rect
(
const
GrRenderTarget
*
rt
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkISize
&
imageSize
const
SkRect
*
srcRectPtr
SkIRect
*
clippedSrcIRect
)
{
clip
.
getConservativeBounds
(
rt
-
>
width
(
)
rt
-
>
height
(
)
clippedSrcIRect
nullptr
)
;
SkMatrix
inv
;
if
(
!
viewMatrix
.
invert
(
&
inv
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
return
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
*
clippedSrcIRect
)
;
inv
.
mapRect
(
&
clippedSrcRect
)
;
if
(
srcRectPtr
)
{
clippedSrcRect
.
offset
(
srcRectPtr
-
>
fLeft
srcRectPtr
-
>
fTop
)
;
if
(
!
clippedSrcRect
.
intersect
(
*
srcRectPtr
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
return
;
}
}
clippedSrcRect
.
roundOut
(
clippedSrcIRect
)
;
SkIRect
bmpBounds
=
SkIRect
:
:
MakeSize
(
imageSize
)
;
if
(
!
clippedSrcIRect
-
>
intersect
(
bmpBounds
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
}
}
bool
SkGpuDevice
:
:
shouldTileImageID
(
uint32_t
imageID
const
SkIRect
&
imageRect
const
SkMatrix
&
viewMatrix
const
GrTextureParams
&
params
const
SkRect
*
srcRectPtr
int
maxTileSize
int
*
tileSize
SkIRect
*
clippedSubset
)
const
{
if
(
imageRect
.
width
(
)
>
maxTileSize
|
|
imageRect
.
height
(
)
>
maxTileSize
)
{
determine_clipped_src_rect
(
fRenderTarget
fClip
viewMatrix
imageRect
.
size
(
)
srcRectPtr
clippedSubset
)
;
*
tileSize
=
determine_tile_size
(
*
clippedSubset
maxTileSize
)
;
return
true
;
}
const
size_t
area
=
imageRect
.
width
(
)
*
imageRect
.
height
(
)
;
if
(
area
<
4
*
kBmpSmallTileSize
*
kBmpSmallTileSize
)
{
return
false
;
}
size_t
bmpSize
=
area
*
sizeof
(
SkPMColor
)
;
size_t
cacheSize
;
fContext
-
>
getResourceCacheLimits
(
nullptr
&
cacheSize
)
;
if
(
bmpSize
<
cacheSize
/
2
)
{
return
false
;
}
determine_clipped_src_rect
(
fRenderTarget
fClip
viewMatrix
imageRect
.
size
(
)
srcRectPtr
clippedSubset
)
;
*
tileSize
=
kBmpSmallTileSize
;
size_t
usedTileBytes
=
get_tile_count
(
*
clippedSubset
kBmpSmallTileSize
)
*
kBmpSmallTileSize
*
kBmpSmallTileSize
;
return
usedTileBytes
<
2
*
bmpSize
;
}
bool
SkGpuDevice
:
:
shouldTileBitmap
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
viewMatrix
const
GrTextureParams
&
params
const
SkRect
*
srcRectPtr
int
maxTileSize
int
*
tileSize
SkIRect
*
clippedSrcRect
)
const
{
if
(
bitmap
.
getTexture
(
)
)
{
return
false
;
}
return
this
-
>
shouldTileImageID
(
bitmap
.
getGenerationID
(
)
bitmap
.
getSubset
(
)
viewMatrix
params
srcRectPtr
maxTileSize
tileSize
clippedSrcRect
)
;
}
bool
SkGpuDevice
:
:
shouldTileImage
(
const
SkImage
*
image
const
SkRect
*
srcRectPtr
SkCanvas
:
:
SrcRectConstraint
constraint
SkFilterQuality
quality
const
SkMatrix
&
viewMatrix
)
const
{
if
(
as_IB
(
image
)
-
>
peekTexture
(
)
)
{
return
false
;
}
GrTextureParams
params
;
bool
doBicubic
;
GrTextureParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
quality
viewMatrix
SkMatrix
:
:
I
(
)
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrTextureParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
int
outTileSize
;
SkIRect
outClippedSrcRect
;
return
this
-
>
shouldTileImageID
(
image
-
>
unique
(
)
image
-
>
bounds
(
)
viewMatrix
params
srcRectPtr
maxTileSize
&
outTileSize
&
outClippedSrcRect
)
;
}
void
SkGpuDevice
:
:
drawBitmap
(
const
SkDraw
&
origDraw
const
SkBitmap
&
bitmap
const
SkMatrix
&
m
const
SkPaint
&
paint
)
{
CHECK_SHOULD_DRAW
(
origDraw
)
;
bool
alphaOnly
=
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
;
SkMatrix
viewMatrix
;
viewMatrix
.
setConcat
(
*
origDraw
.
fMatrix
m
)
;
if
(
bitmap
.
getTexture
(
)
)
{
GrBitmapTextureAdjuster
adjuster
(
&
bitmap
)
;
this
-
>
drawTextureProducer
(
&
adjuster
alphaOnly
nullptr
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
viewMatrix
fClip
paint
)
;
return
;
}
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
;
bool
drawAA
=
!
fRenderTarget
-
>
isUnifiedMultisampled
(
)
&
&
paint
.
isAntiAlias
(
)
&
&
bitmap
.
width
(
)
<
=
maxTileSize
&
&
bitmap
.
height
(
)
<
=
maxTileSize
;
bool
skipTileCheck
=
drawAA
|
|
paint
.
getMaskFilter
(
)
;
if
(
!
skipTileCheck
)
{
SkRect
srcRect
=
SkRect
:
:
MakeIWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
int
tileSize
;
SkIRect
clippedSrcRect
;
GrTextureParams
params
;
bool
doBicubic
;
GrTextureParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
viewMatrix
SkMatrix
:
:
I
(
)
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrTextureParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSizeForFilter
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
if
(
this
-
>
shouldTileBitmap
(
bitmap
viewMatrix
params
&
srcRect
maxTileSizeForFilter
&
tileSize
&
clippedSrcRect
)
)
{
this
-
>
drawTiledBitmap
(
bitmap
viewMatrix
srcRect
clippedSrcRect
params
paint
SkCanvas
:
:
kStrict_SrcRectConstraint
tileSize
doBicubic
)
;
return
;
}
}
GrBitmapTextureMaker
maker
(
fContext
bitmap
)
;
this
-
>
drawTextureProducer
(
&
maker
alphaOnly
nullptr
nullptr
SkCanvas
:
:
kStrict_SrcRectConstraint
viewMatrix
fClip
paint
)
;
}
static
inline
void
clamped_outset_with_offset
(
SkIRect
*
iRect
int
outset
SkPoint
*
offset
const
SkIRect
&
clamp
)
{
iRect
-
>
outset
(
outset
outset
)
;
int
leftClampDelta
=
clamp
.
fLeft
-
iRect
-
>
fLeft
;
if
(
leftClampDelta
>
0
)
{
offset
-
>
fX
-
=
outset
-
leftClampDelta
;
iRect
-
>
fLeft
=
clamp
.
fLeft
;
}
else
{
offset
-
>
fX
-
=
outset
;
}
int
topClampDelta
=
clamp
.
fTop
-
iRect
-
>
fTop
;
if
(
topClampDelta
>
0
)
{
offset
-
>
fY
-
=
outset
-
topClampDelta
;
iRect
-
>
fTop
=
clamp
.
fTop
;
}
else
{
offset
-
>
fY
-
=
outset
;
}
if
(
iRect
-
>
fRight
>
clamp
.
fRight
)
{
iRect
-
>
fRight
=
clamp
.
fRight
;
}
if
(
iRect
-
>
fBottom
>
clamp
.
fBottom
)
{
iRect
-
>
fBottom
=
clamp
.
fBottom
;
}
}
void
SkGpuDevice
:
:
drawTiledBitmap
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
viewMatrix
const
SkRect
&
srcRect
const
SkIRect
&
clippedSrcIRect
const
GrTextureParams
&
params
const
SkPaint
&
origPaint
SkCanvas
:
:
SrcRectConstraint
constraint
int
tileSize
bool
bicubic
)
{
SkAutoLockPixels
alp
(
bitmap
)
;
const
SkPaint
*
paint
=
&
origPaint
;
SkPaint
tempPaint
;
if
(
origPaint
.
isAntiAlias
(
)
&
&
!
fRenderTarget
-
>
isUnifiedMultisampled
(
)
)
{
tempPaint
=
origPaint
;
tempPaint
.
setAntiAlias
(
false
)
;
paint
=
&
tempPaint
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
clippedSrcIRect
)
;
int
nx
=
bitmap
.
width
(
)
/
tileSize
;
int
ny
=
bitmap
.
height
(
)
/
tileSize
;
for
(
int
x
=
0
;
x
<
=
nx
;
x
+
+
)
{
for
(
int
y
=
0
;
y
<
=
ny
;
y
+
+
)
{
SkRect
tileR
;
tileR
.
set
(
SkIntToScalar
(
x
*
tileSize
)
SkIntToScalar
(
y
*
tileSize
)
SkIntToScalar
(
(
x
+
1
)
*
tileSize
)
SkIntToScalar
(
(
y
+
1
)
*
tileSize
)
)
;
if
(
!
SkRect
:
:
Intersects
(
tileR
clippedSrcRect
)
)
{
continue
;
}
if
(
!
tileR
.
intersect
(
srcRect
)
)
{
continue
;
}
SkBitmap
tmpB
;
SkIRect
iTileR
;
tileR
.
roundOut
(
&
iTileR
)
;
SkPoint
offset
=
SkPoint
:
:
Make
(
SkIntToScalar
(
iTileR
.
fLeft
)
SkIntToScalar
(
iTileR
.
fTop
)
)
;
SkMatrix
viewM
=
viewMatrix
;
SkMatrix
tmpM
;
tmpM
.
setTranslate
(
offset
.
fX
-
srcRect
.
fLeft
offset
.
fY
-
srcRect
.
fTop
)
;
viewM
.
preConcat
(
tmpM
)
;
if
(
GrTextureParams
:
:
kNone_FilterMode
!
=
params
.
filterMode
(
)
|
|
bicubic
)
{
SkIRect
iClampRect
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
iClampRect
=
SkIRect
:
:
MakeWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
}
else
{
srcRect
.
roundOut
(
&
iClampRect
)
;
}
int
outset
=
bicubic
?
GrBicubicEffect
:
:
kFilterTexelPad
:
1
;
clamped_outset_with_offset
(
&
iTileR
outset
&
offset
iClampRect
)
;
}
if
(
bitmap
.
extractSubset
(
&
tmpB
iTileR
)
)
{
tileR
.
offset
(
-
offset
.
fX
-
offset
.
fY
)
;
GrTextureParams
paramsTemp
=
params
;
bool
needsTextureDomain
=
true
;
this
-
>
internalDrawBitmap
(
tmpB
viewM
tileR
paramsTemp
*
paint
constraint
bicubic
needsTextureDomain
)
;
}
}
}
}
void
SkGpuDevice
:
:
internalDrawBitmap
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
viewMatrix
const
SkRect
&
srcRect
const
GrTextureParams
&
params
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
bool
bicubic
bool
needsTextureDomain
)
{
SkASSERT
(
bitmap
.
width
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTextureSize
(
)
&
&
bitmap
.
height
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTextureSize
(
)
)
;
SkASSERT
(
bitmap
.
getTexture
(
)
|
|
(
bitmap
.
width
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
&
&
bitmap
.
height
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
)
)
;
GrTexture
*
texture
;
AutoBitmapTexture
abt
(
fContext
bitmap
params
&
texture
)
;
if
(
nullptr
=
=
texture
)
{
return
;
}
SkRect
dstRect
=
{
0
0
srcRect
.
width
(
)
srcRect
.
height
(
)
}
;
SkRect
paintRect
;
SkScalar
wInv
=
SkScalarInvert
(
SkIntToScalar
(
texture
-
>
width
(
)
)
)
;
SkScalar
hInv
=
SkScalarInvert
(
SkIntToScalar
(
texture
-
>
height
(
)
)
)
;
paintRect
.
setLTRB
(
SkScalarMul
(
srcRect
.
fLeft
wInv
)
SkScalarMul
(
srcRect
.
fTop
hInv
)
SkScalarMul
(
srcRect
.
fRight
wInv
)
SkScalarMul
(
srcRect
.
fBottom
hInv
)
)
;
SkMatrix
texMatrix
;
texMatrix
.
reset
(
)
;
if
(
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
&
&
paint
.
getShader
(
)
)
{
texMatrix
.
setScale
(
wInv
hInv
)
;
}
SkRect
textureDomain
=
SkRect
:
:
MakeEmpty
(
)
;
SkAutoTUnref
<
const
GrFragmentProcessor
>
fp
;
if
(
needsTextureDomain
&
&
(
SkCanvas
:
:
kStrict_SrcRectConstraint
=
=
constraint
)
)
{
SkScalar
left
top
right
bottom
;
if
(
srcRect
.
width
(
)
>
SK_Scalar1
)
{
SkScalar
border
=
SK_ScalarHalf
/
texture
-
>
width
(
)
;
left
=
paintRect
.
left
(
)
+
border
;
right
=
paintRect
.
right
(
)
-
border
;
}
else
{
left
=
right
=
SkScalarHalf
(
paintRect
.
left
(
)
+
paintRect
.
right
(
)
)
;
}
if
(
srcRect
.
height
(
)
>
SK_Scalar1
)
{
SkScalar
border
=
SK_ScalarHalf
/
texture
-
>
height
(
)
;
top
=
paintRect
.
top
(
)
+
border
;
bottom
=
paintRect
.
bottom
(
)
-
border
;
}
else
{
top
=
bottom
=
SkScalarHalf
(
paintRect
.
top
(
)
+
paintRect
.
bottom
(
)
)
;
}
textureDomain
.
setLTRB
(
left
top
right
bottom
)
;
if
(
bicubic
)
{
fp
.
reset
(
GrBicubicEffect
:
:
Create
(
texture
texMatrix
textureDomain
)
)
;
}
else
{
fp
.
reset
(
GrTextureDomainEffect
:
:
Create
(
texture
texMatrix
textureDomain
GrTextureDomain
:
:
kClamp_Mode
params
.
filterMode
(
)
)
)
;
}
}
else
if
(
bicubic
)
{
SkASSERT
(
GrTextureParams
:
:
kNone_FilterMode
=
=
params
.
filterMode
(
)
)
;
SkShader
:
:
TileMode
tileModes
[
2
]
=
{
params
.
getTileModeX
(
)
params
.
getTileModeY
(
)
}
;
fp
.
reset
(
GrBicubicEffect
:
:
Create
(
texture
texMatrix
tileModes
)
)
;
}
else
{
fp
.
reset
(
GrSimpleTextureEffect
:
:
Create
(
texture
texMatrix
params
)
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
this
-
>
context
(
)
paint
viewMatrix
fp
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
&
grPaint
)
)
{
return
;
}
if
(
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
&
&
paint
.
getShader
(
)
)
{
fDrawContext
-
>
drawRect
(
fClip
grPaint
viewMatrix
dstRect
)
;
}
else
{
fDrawContext
-
>
fillRectToRect
(
fClip
grPaint
viewMatrix
dstRect
paintRect
)
;
}
}
bool
SkGpuDevice
:
:
filterTexture
(
GrContext
*
context
GrTexture
*
texture
int
width
int
height
const
SkImageFilter
*
filter
const
SkImageFilter
:
:
Context
&
ctx
SkBitmap
*
result
SkIPoint
*
offset
)
{
SkASSERT
(
filter
)
;
SkImageFilter
:
:
DeviceProxy
proxy
(
this
)
;
if
(
filter
-
>
canFilterImageGPU
(
)
)
{
return
filter
-
>
filterImageGPU
(
&
proxy
wrap_texture
(
texture
width
height
)
ctx
result
offset
)
;
}
else
{
return
false
;
}
}
void
SkGpuDevice
:
:
drawSprite
(
const
SkDraw
&
draw
const
SkBitmap
&
bitmap
int
left
int
top
const
SkPaint
&
paint
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
SkAutoLockPixels
alp
(
bitmap
!
bitmap
.
getTexture
(
)
)
;
if
(
!
bitmap
.
getTexture
(
)
&
&
!
bitmap
.
readyToDraw
(
)
)
{
return
;
}
int
w
=
bitmap
.
width
(
)
;
int
h
=
bitmap
.
height
(
)
;
GrTexture
*
texture
;
AutoBitmapTexture
abt
(
fContext
bitmap
GrTextureParams
:
:
ClampNoFilter
(
)
&
texture
)
;
if
(
!
texture
)
{
return
;
}
bool
alphaOnly
=
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
;
SkImageFilter
*
filter
=
paint
.
getImageFilter
(
)
;
SkBitmap
filteredBitmap
;
if
(
filter
)
{
SkIPoint
offset
=
SkIPoint
:
:
Make
(
0
0
)
;
SkMatrix
matrix
(
*
draw
.
fMatrix
)
;
matrix
.
postTranslate
(
SkIntToScalar
(
-
left
)
SkIntToScalar
(
-
top
)
)
;
SkIRect
clipBounds
=
SkIRect
:
:
MakeWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
SkAutoTUnref
<
SkImageFilter
:
:
Cache
>
cache
(
getImageFilterCache
(
)
)
;
SkImageFilter
:
:
Context
ctx
(
matrix
clipBounds
cache
SkImageFilter
:
:
kApprox_SizeConstraint
)
;
if
(
this
-
>
filterTexture
(
fContext
texture
w
h
filter
ctx
&
filteredBitmap
&
offset
)
)
{
texture
=
(
GrTexture
*
)
filteredBitmap
.
getTexture
(
)
;
w
=
filteredBitmap
.
width
(
)
;
h
=
filteredBitmap
.
height
(
)
;
left
+
=
offset
.
x
(
)
;
top
+
=
offset
.
y
(
)
;
}
else
{
return
;
}
SkASSERT
(
!
GrPixelConfigIsAlphaOnly
(
texture
-
>
config
(
)
)
)
;
alphaOnly
=
false
;
}
GrPaint
grPaint
;
SkAutoTUnref
<
const
GrFragmentProcessor
>
fp
(
GrSimpleTextureEffect
:
:
Create
(
texture
SkMatrix
:
:
I
(
)
)
)
;
if
(
alphaOnly
)
{
fp
.
reset
(
GrFragmentProcessor
:
:
MulOutputByInputUnpremulColor
(
fp
)
)
;
}
else
{
fp
.
reset
(
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
fp
)
)
;
}
if
(
!
SkPaintToGrPaintReplaceShader
(
this
-
>
context
(
)
paint
fp
&
grPaint
)
)
{
return
;
}
fDrawContext
-
>
fillRectToRect
(
fClip
grPaint
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeXYWH
(
SkIntToScalar
(
left
)
SkIntToScalar
(
top
)
SkIntToScalar
(
w
)
SkIntToScalar
(
h
)
)
SkRect
:
:
MakeXYWH
(
0
0
SK_Scalar1
*
w
/
texture
-
>
width
(
)
SK_Scalar1
*
h
/
texture
-
>
height
(
)
)
)
;
}
void
SkGpuDevice
:
:
drawBitmapRect
(
const
SkDraw
&
draw
const
SkBitmap
&
bitmap
const
SkRect
*
src
const
SkRect
&
origDst
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
bool
alphaOnly
=
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
;
if
(
bitmap
.
getTexture
(
)
)
{
GrBitmapTextureAdjuster
adjuster
(
&
bitmap
)
;
this
-
>
drawTextureProducer
(
&
adjuster
alphaOnly
src
&
origDst
constraint
*
draw
.
fMatrix
fClip
paint
)
;
return
;
}
const
SkRect
*
dst
=
&
origDst
;
const
SkRect
bmpBounds
=
SkRect
:
:
MakeIWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
if
(
!
src
)
{
src
=
&
bmpBounds
;
}
SkMatrix
srcToDstMatrix
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
src
*
dst
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
SkRect
tmpSrc
tmpDst
;
if
(
src
!
=
&
bmpBounds
)
{
if
(
!
bmpBounds
.
contains
(
*
src
)
)
{
tmpSrc
=
*
src
;
if
(
!
tmpSrc
.
intersect
(
bmpBounds
)
)
{
return
;
}
src
=
&
tmpSrc
;
srcToDstMatrix
.
mapRect
(
&
tmpDst
*
src
)
;
dst
=
&
tmpDst
;
}
}
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
;
bool
drawAA
=
!
fRenderTarget
-
>
isUnifiedMultisampled
(
)
&
&
paint
.
isAntiAlias
(
)
&
&
bitmap
.
width
(
)
<
=
maxTileSize
&
&
bitmap
.
height
(
)
<
=
maxTileSize
;
bool
skipTileCheck
=
drawAA
|
|
paint
.
getMaskFilter
(
)
;
if
(
!
skipTileCheck
)
{
int
tileSize
;
SkIRect
clippedSrcRect
;
GrTextureParams
params
;
bool
doBicubic
;
GrTextureParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
*
draw
.
fMatrix
srcToDstMatrix
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrTextureParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSizeForFilter
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
SkMatrix
viewMatrix
=
*
draw
.
fMatrix
;
viewMatrix
.
preTranslate
(
dst
-
>
fLeft
dst
-
>
fTop
)
;
viewMatrix
.
preScale
(
dst
-
>
width
(
)
/
src
-
>
width
(
)
dst
-
>
height
(
)
/
src
-
>
height
(
)
)
;
if
(
this
-
>
shouldTileBitmap
(
bitmap
viewMatrix
params
src
maxTileSizeForFilter
&
tileSize
&
clippedSrcRect
)
)
{
this
-
>
drawTiledBitmap
(
bitmap
viewMatrix
*
src
clippedSrcRect
params
paint
constraint
tileSize
doBicubic
)
;
return
;
}
}
GrBitmapTextureMaker
maker
(
fContext
bitmap
)
;
this
-
>
drawTextureProducer
(
&
maker
alphaOnly
src
dst
constraint
*
draw
.
fMatrix
fClip
paint
)
;
}
void
SkGpuDevice
:
:
drawDevice
(
const
SkDraw
&
draw
SkBaseDevice
*
device
int
x
int
y
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawDevice
"
fContext
)
;
SkGpuDevice
*
dev
=
static_cast
<
SkGpuDevice
*
>
(
device
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
GrRenderTarget
*
devRT
=
dev
-
>
accessRenderTarget
(
)
;
GrTexture
*
devTex
;
if
(
nullptr
=
=
(
devTex
=
devRT
-
>
asTexture
(
)
)
)
{
return
;
}
const
SkImageInfo
ii
=
dev
-
>
imageInfo
(
)
;
int
w
=
ii
.
width
(
)
;
int
h
=
ii
.
height
(
)
;
SkImageFilter
*
filter
=
paint
.
getImageFilter
(
)
;
SkBitmap
filteredBitmap
;
if
(
filter
)
{
SkIPoint
offset
=
SkIPoint
:
:
Make
(
0
0
)
;
SkMatrix
matrix
(
*
draw
.
fMatrix
)
;
matrix
.
postTranslate
(
SkIntToScalar
(
-
x
)
SkIntToScalar
(
-
y
)
)
;
SkIRect
clipBounds
=
SkIRect
:
:
MakeWH
(
devTex
-
>
width
(
)
devTex
-
>
height
(
)
)
;
SkAutoTUnref
<
SkImageFilter
:
:
Cache
>
cache
(
getImageFilterCache
(
)
)
;
SkImageFilter
:
:
Context
ctx
(
matrix
clipBounds
cache
SkImageFilter
:
:
kApprox_SizeConstraint
)
;
if
(
this
-
>
filterTexture
(
fContext
devTex
device
-
>
width
(
)
device
-
>
height
(
)
filter
ctx
&
filteredBitmap
&
offset
)
)
{
devTex
=
filteredBitmap
.
getTexture
(
)
;
w
=
filteredBitmap
.
width
(
)
;
h
=
filteredBitmap
.
height
(
)
;
x
+
=
offset
.
fX
;
y
+
=
offset
.
fY
;
}
else
{
return
;
}
}
GrPaint
grPaint
;
SkAutoTUnref
<
const
GrFragmentProcessor
>
fp
(
GrSimpleTextureEffect
:
:
Create
(
devTex
SkMatrix
:
:
I
(
)
)
)
;
if
(
GrPixelConfigIsAlphaOnly
(
devTex
-
>
config
(
)
)
)
{
fp
.
reset
(
GrFragmentProcessor
:
:
MulOutputByInputUnpremulColor
(
fp
)
)
;
}
else
{
fp
.
reset
(
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
fp
)
)
;
}
if
(
!
SkPaintToGrPaintReplaceShader
(
this
-
>
context
(
)
paint
fp
&
grPaint
)
)
{
return
;
}
SkRect
dstRect
=
SkRect
:
:
MakeXYWH
(
SkIntToScalar
(
x
)
SkIntToScalar
(
y
)
SkIntToScalar
(
w
)
SkIntToScalar
(
h
)
)
;
SkRect
srcRect
=
SkRect
:
:
MakeWH
(
SK_Scalar1
*
w
/
devTex
-
>
width
(
)
SK_Scalar1
*
h
/
devTex
-
>
height
(
)
)
;
fDrawContext
-
>
fillRectToRect
(
fClip
grPaint
SkMatrix
:
:
I
(
)
dstRect
srcRect
)
;
}
bool
SkGpuDevice
:
:
canHandleImageFilter
(
const
SkImageFilter
*
filter
)
{
return
filter
-
>
canFilterImageGPU
(
)
;
}
bool
SkGpuDevice
:
:
filterImage
(
const
SkImageFilter
*
filter
const
SkBitmap
&
src
const
SkImageFilter
:
:
Context
&
ctx
SkBitmap
*
result
SkIPoint
*
offset
)
{
if
(
!
this
-
>
SkGpuDevice
:
:
canHandleImageFilter
(
filter
)
)
{
return
false
;
}
SkAutoLockPixels
alp
(
src
!
src
.
getTexture
(
)
)
;
if
(
!
src
.
getTexture
(
)
&
&
!
src
.
readyToDraw
(
)
)
{
return
false
;
}
GrTexture
*
texture
;
AutoBitmapTexture
abt
(
fContext
src
GrTextureParams
:
:
ClampNoFilter
(
)
&
texture
)
;
if
(
!
texture
)
{
return
false
;
}
return
this
-
>
filterTexture
(
fContext
texture
src
.
width
(
)
src
.
height
(
)
filter
ctx
result
offset
)
;
}
static
bool
wrap_as_bm
(
GrContext
*
ctx
const
SkImage
*
image
SkBitmap
*
bm
)
{
SkAutoTUnref
<
GrTexture
>
tex
(
as_IB
(
image
)
-
>
asTextureRef
(
ctx
GrTextureParams
:
:
ClampNoFilter
(
)
)
)
;
if
(
tex
)
{
GrWrapTextureInBitmap
(
tex
image
-
>
width
(
)
image
-
>
height
(
)
image
-
>
isOpaque
(
)
bm
)
;
return
true
;
}
else
{
return
as_IB
(
image
)
-
>
getROPixels
(
bm
)
;
}
}
void
SkGpuDevice
:
:
drawImage
(
const
SkDraw
&
draw
const
SkImage
*
image
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
SkBitmap
bm
;
if
(
GrTexture
*
tex
=
as_IB
(
image
)
-
>
peekTexture
(
)
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
SkMatrix
viewMatrix
=
*
draw
.
fMatrix
;
viewMatrix
.
preTranslate
(
x
y
)
;
bool
alphaOnly
=
GrPixelConfigIsAlphaOnly
(
tex
-
>
config
(
)
)
;
GrImageTextureAdjuster
adjuster
(
as_IB
(
image
)
)
;
this
-
>
drawTextureProducer
(
&
adjuster
alphaOnly
nullptr
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
viewMatrix
fClip
paint
)
;
return
;
}
else
{
if
(
this
-
>
shouldTileImage
(
image
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
paint
.
getFilterQuality
(
)
*
draw
.
fMatrix
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
return
;
}
}
else
{
if
(
!
wrap_as_bm
(
this
-
>
context
(
)
image
&
bm
)
)
{
return
;
}
}
}
this
-
>
drawBitmap
(
draw
bm
SkMatrix
:
:
MakeTrans
(
x
y
)
paint
)
;
}
void
SkGpuDevice
:
:
drawImageRect
(
const
SkDraw
&
draw
const
SkImage
*
image
const
SkRect
*
src
const
SkRect
&
dst
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
if
(
GrTexture
*
tex
=
as_IB
(
image
)
-
>
peekTexture
(
)
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
GrImageTextureAdjuster
adjuster
(
as_IB
(
image
)
)
;
bool
alphaOnly
=
GrPixelConfigIsAlphaOnly
(
tex
-
>
config
(
)
)
;
this
-
>
drawTextureProducer
(
&
adjuster
alphaOnly
src
&
dst
constraint
*
draw
.
fMatrix
fClip
paint
)
;
return
;
}
SkBitmap
bm
;
SkMatrix
viewMatrix
=
*
draw
.
fMatrix
;
viewMatrix
.
preScale
(
dst
.
width
(
)
/
(
src
?
src
-
>
width
(
)
:
image
-
>
width
(
)
)
dst
.
height
(
)
/
(
src
?
src
-
>
height
(
)
:
image
-
>
height
(
)
)
)
;
if
(
this
-
>
shouldTileImage
(
image
src
constraint
paint
.
getFilterQuality
(
)
viewMatrix
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
return
;
}
}
else
{
if
(
!
wrap_as_bm
(
this
-
>
context
(
)
image
&
bm
)
)
{
return
;
}
}
this
-
>
drawBitmapRect
(
draw
bm
src
dst
paint
constraint
)
;
}
void
SkGpuDevice
:
:
drawImageNine
(
const
SkDraw
&
draw
const
SkImage
*
image
const
SkIRect
&
center
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
SkBitmap
bitmap
;
if
(
!
wrap_as_bm
(
this
-
>
context
(
)
image
&
bitmap
)
)
{
return
;
}
return
this
-
>
drawBitmapNine
(
draw
bitmap
center
dst
paint
)
;
}
void
SkGpuDevice
:
:
drawBitmapNine
(
const
SkDraw
&
draw
const
SkBitmap
&
bitmap
const
SkIRect
&
center
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawBitmapNine
"
fContext
)
;
CHECK_FOR_ANNOTATION
(
paint
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
bool
useFallback
=
paint
.
getMaskFilter
(
)
|
|
paint
.
isAntiAlias
(
)
|
|
fRenderTarget
-
>
isUnifiedMultisampled
(
)
;
bool
doBicubic
;
GrTextureParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
*
draw
.
fMatrix
SkMatrix
:
:
I
(
)
&
doBicubic
)
;
if
(
useFallback
|
|
doBicubic
|
|
GrTextureParams
:
:
kNone_FilterMode
!
=
textureFilterMode
)
{
SkNinePatchIter
iter
(
bitmap
.
width
(
)
bitmap
.
height
(
)
center
dst
)
;
SkRect
srcR
dstR
;
while
(
iter
.
next
(
&
srcR
&
dstR
)
)
{
this
-
>
drawBitmapRect
(
draw
bitmap
&
srcR
dstR
paint
SkCanvas
:
:
kStrict_SrcRectConstraint
)
;
}
return
;
}
GrTextureParams
params
=
GrTextureParams
:
:
ClampNoFilter
(
)
;
SkAutoTUnref
<
GrTexture
>
texture
(
GrRefCachedBitmapTexture
(
this
-
>
context
(
)
bitmap
params
)
)
;
if
(
nullptr
=
=
texture
)
{
return
;
}
SkMatrix
texMatrix
;
texMatrix
.
setIDiv
(
texture
-
>
width
(
)
texture
-
>
height
(
)
)
;
SkAutoTUnref
<
const
GrFragmentProcessor
>
fp
(
GrSimpleTextureEffect
:
:
Create
(
texture
texMatrix
params
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
fp
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
&
grPaint
)
)
{
return
;
}
fDrawContext
-
>
drawImageNine
(
fClip
grPaint
*
draw
.
fMatrix
bitmap
.
width
(
)
bitmap
.
height
(
)
center
dst
)
;
}
static
const
GrPrimitiveType
gVertexMode2PrimitiveType
[
]
=
{
kTriangles_GrPrimitiveType
kTriangleStrip_GrPrimitiveType
kTriangleFan_GrPrimitiveType
}
;
void
SkGpuDevice
:
:
drawVertices
(
const
SkDraw
&
draw
SkCanvas
:
:
VertexMode
vmode
int
vertexCount
const
SkPoint
vertices
[
]
const
SkPoint
texs
[
]
const
SkColor
colors
[
]
SkXfermode
*
xmode
const
uint16_t
indices
[
]
int
indexCount
const
SkPaint
&
paint
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawVertices
"
fContext
)
;
if
(
(
nullptr
=
=
texs
|
|
nullptr
=
=
paint
.
getShader
(
)
)
&
&
nullptr
=
=
colors
)
{
texs
=
nullptr
;
SkPaint
copy
(
paint
)
;
copy
.
setStyle
(
SkPaint
:
:
kStroke_Style
)
;
copy
.
setStrokeWidth
(
0
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintNoShader
(
this
-
>
context
(
)
copy
&
grPaint
)
)
{
return
;
}
int
triangleCount
=
0
;
int
n
=
(
nullptr
=
=
indices
)
?
vertexCount
:
indexCount
;
switch
(
vmode
)
{
case
SkCanvas
:
:
kTriangles_VertexMode
:
triangleCount
=
n
/
3
;
break
;
case
SkCanvas
:
:
kTriangleStrip_VertexMode
:
case
SkCanvas
:
:
kTriangleFan_VertexMode
:
triangleCount
=
n
-
2
;
break
;
}
VertState
state
(
vertexCount
indices
indexCount
)
;
VertState
:
:
Proc
vertProc
=
state
.
chooseProc
(
vmode
)
;
indexCount
=
triangleCount
*
6
;
SkAutoTDeleteArray
<
uint16_t
>
lineIndices
(
new
uint16_t
[
indexCount
]
)
;
int
i
=
0
;
while
(
vertProc
(
&
state
)
)
{
lineIndices
[
i
]
=
state
.
f0
;
lineIndices
[
i
+
1
]
=
state
.
f1
;
lineIndices
[
i
+
2
]
=
state
.
f1
;
lineIndices
[
i
+
3
]
=
state
.
f2
;
lineIndices
[
i
+
4
]
=
state
.
f2
;
lineIndices
[
i
+
5
]
=
state
.
f0
;
i
+
=
6
;
}
fDrawContext
-
>
drawVertices
(
fClip
grPaint
*
draw
.
fMatrix
kLines_GrPrimitiveType
vertexCount
vertices
texs
colors
lineIndices
.
get
(
)
indexCount
)
;
return
;
}
GrPrimitiveType
primType
=
gVertexMode2PrimitiveType
[
vmode
]
;
SkAutoSTMalloc
<
128
GrColor
>
convertedColors
(
0
)
;
if
(
colors
)
{
convertedColors
.
reset
(
vertexCount
)
;
for
(
int
i
=
0
;
i
<
vertexCount
;
+
+
i
)
{
convertedColors
[
i
]
=
SkColorToPremulGrColor
(
colors
[
i
]
)
;
}
colors
=
convertedColors
.
get
(
)
;
}
GrPaint
grPaint
;
if
(
texs
&
&
paint
.
getShader
(
)
)
{
if
(
colors
)
{
SkXfermode
:
:
Mode
colorMode
;
if
(
xmode
)
{
if
(
!
xmode
-
>
asMode
(
&
colorMode
)
)
{
return
;
}
}
else
{
colorMode
=
SkXfermode
:
:
kModulate_Mode
;
}
if
(
!
SkPaintToGrPaintWithXfermode
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
colorMode
false
&
grPaint
)
)
{
return
;
}
}
else
{
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
}
}
else
{
if
(
colors
)
{
if
(
!
SkPaintToGrPaintWithPrimitiveColor
(
this
-
>
context
(
)
paint
&
grPaint
)
)
{
return
;
}
}
else
{
if
(
!
SkPaintToGrPaintNoShader
(
this
-
>
context
(
)
paint
&
grPaint
)
)
{
return
;
}
}
}
fDrawContext
-
>
drawVertices
(
fClip
grPaint
*
draw
.
fMatrix
primType
vertexCount
vertices
texs
colors
indices
indexCount
)
;
}
void
SkGpuDevice
:
:
drawAtlas
(
const
SkDraw
&
draw
const
SkImage
*
atlas
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
int
count
SkXfermode
:
:
Mode
mode
const
SkPaint
&
paint
)
{
if
(
paint
.
isAntiAlias
(
)
)
{
this
-
>
INHERITED
:
:
drawAtlas
(
draw
atlas
xform
texRect
colors
count
mode
paint
)
;
return
;
}
CHECK_SHOULD_DRAW
(
draw
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawText
"
fContext
)
;
SkPaint
p
(
paint
)
;
p
.
setShader
(
atlas
-
>
newShader
(
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
)
)
-
>
unref
(
)
;
GrPaint
grPaint
;
if
(
colors
)
{
if
(
!
SkPaintToGrPaintWithXfermode
(
this
-
>
context
(
)
p
*
draw
.
fMatrix
mode
true
&
grPaint
)
)
{
return
;
}
}
else
{
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
p
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fDrawContext
-
>
drawAtlas
(
fClip
grPaint
*
draw
.
fMatrix
count
xform
texRect
colors
)
;
}
void
SkGpuDevice
:
:
drawText
(
const
SkDraw
&
draw
const
void
*
text
size_t
byteLength
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
CHECK_SHOULD_DRAW
(
draw
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawText
"
fContext
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fDrawContext
-
>
drawText
(
fClip
grPaint
paint
*
draw
.
fMatrix
(
const
char
*
)
text
byteLength
x
y
draw
.
fClip
-
>
getBounds
(
)
)
;
}
void
SkGpuDevice
:
:
drawPosText
(
const
SkDraw
&
draw
const
void
*
text
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPos
const
SkPoint
&
offset
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawPosText
"
fContext
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
paint
*
draw
.
fMatrix
&
grPaint
)
)
{
return
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fDrawContext
-
>
drawPosText
(
fClip
grPaint
paint
*
draw
.
fMatrix
(
const
char
*
)
text
byteLength
pos
scalarsPerPos
offset
draw
.
fClip
-
>
getBounds
(
)
)
;
}
void
SkGpuDevice
:
:
drawTextBlob
(
const
SkDraw
&
draw
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
SkDrawFilter
*
drawFilter
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
:
:
drawTextBlob
"
fContext
)
;
CHECK_SHOULD_DRAW
(
draw
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fDrawContext
-
>
drawTextBlob
(
fClip
paint
*
draw
.
fMatrix
blob
x
y
drawFilter
draw
.
fClip
-
>
getBounds
(
)
)
;
}
bool
SkGpuDevice
:
:
onShouldDisableLCD
(
const
SkPaint
&
paint
)
const
{
return
GrTextContext
:
:
ShouldDisableLCD
(
paint
)
;
}
void
SkGpuDevice
:
:
flush
(
)
{
DO_DEFERRED_CLEAR
(
)
;
fRenderTarget
-
>
prepareForExternalIO
(
)
;
}
SkBaseDevice
*
SkGpuDevice
:
:
onCreateDevice
(
const
CreateInfo
&
cinfo
const
SkPaint
*
)
{
GrSurfaceDesc
desc
;
desc
.
fConfig
=
fRenderTarget
-
>
config
(
)
;
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fWidth
=
cinfo
.
fInfo
.
width
(
)
;
desc
.
fHeight
=
cinfo
.
fInfo
.
height
(
)
;
desc
.
fSampleCnt
=
fRenderTarget
-
>
desc
(
)
.
fSampleCnt
;
SkAutoTUnref
<
GrTexture
>
texture
;
InitContents
init
=
cinfo
.
fInfo
.
isOpaque
(
)
?
kUninit_InitContents
:
kClear_InitContents
;
if
(
kNever_TileUsage
=
=
cinfo
.
fTileUsage
)
{
texture
.
reset
(
fContext
-
>
textureProvider
(
)
-
>
createApproxTexture
(
desc
)
)
;
}
else
{
texture
.
reset
(
fContext
-
>
textureProvider
(
)
-
>
createTexture
(
desc
true
)
)
;
}
if
(
texture
)
{
SkSurfaceProps
props
(
this
-
>
surfaceProps
(
)
.
flags
(
)
cinfo
.
fPixelGeometry
)
;
return
SkGpuDevice
:
:
Create
(
texture
-
>
asRenderTarget
(
)
cinfo
.
fInfo
.
width
(
)
cinfo
.
fInfo
.
height
(
)
&
props
init
)
;
}
else
{
SkErrorInternals
:
:
SetError
(
kInternalError_SkError
"
-
-
-
-
failed
to
create
gpu
device
texture
[
%
d
%
d
]
\
n
"
cinfo
.
fInfo
.
width
(
)
cinfo
.
fInfo
.
height
(
)
)
;
return
nullptr
;
}
}
SkSurface
*
SkGpuDevice
:
:
newSurface
(
const
SkImageInfo
&
info
const
SkSurfaceProps
&
props
)
{
static
const
SkSurface
:
:
Budgeted
kBudgeted
=
SkSurface
:
:
kNo_Budgeted
;
return
SkSurface
:
:
NewRenderTarget
(
fContext
kBudgeted
info
fRenderTarget
-
>
desc
(
)
.
fSampleCnt
&
props
)
;
}
bool
SkGpuDevice
:
:
EXPERIMENTAL_drawPicture
(
SkCanvas
*
mainCanvas
const
SkPicture
*
mainPicture
const
SkMatrix
*
matrix
const
SkPaint
*
paint
)
{
#
ifndef
SK_IGNORE_GPU_LAYER_HOISTING
if
(
paint
)
{
return
false
;
}
const
SkBigPicture
:
:
AccelData
*
data
=
nullptr
;
if
(
const
SkBigPicture
*
bp
=
mainPicture
-
>
asSkBigPicture
(
)
)
{
data
=
bp
-
>
accelData
(
)
;
}
if
(
!
data
)
{
return
false
;
}
const
SkLayerInfo
*
gpuData
=
static_cast
<
const
SkLayerInfo
*
>
(
data
)
;
if
(
0
=
=
gpuData
-
>
numBlocks
(
)
)
{
return
false
;
}
SkTDArray
<
GrHoistedLayer
>
atlasedNeedRendering
atlasedRecycled
;
SkIRect
iBounds
;
if
(
!
mainCanvas
-
>
getClipDeviceBounds
(
&
iBounds
)
)
{
return
false
;
}
SkRect
clipBounds
=
SkRect
:
:
Make
(
iBounds
)
;
SkMatrix
initialMatrix
=
mainCanvas
-
>
getTotalMatrix
(
)
;
GrLayerHoister
:
:
Begin
(
fContext
)
;
GrLayerHoister
:
:
FindLayersToAtlas
(
fContext
mainPicture
initialMatrix
clipBounds
&
atlasedNeedRendering
&
atlasedRecycled
fRenderTarget
-
>
numColorSamples
(
)
)
;
GrLayerHoister
:
:
DrawLayersToAtlas
(
fContext
atlasedNeedRendering
)
;
SkTDArray
<
GrHoistedLayer
>
needRendering
recycled
;
SkAutoCanvasMatrixPaint
acmp
(
mainCanvas
matrix
paint
mainPicture
-
>
cullRect
(
)
)
;
GrLayerHoister
:
:
FindLayersToHoist
(
fContext
mainPicture
initialMatrix
clipBounds
&
needRendering
&
recycled
fRenderTarget
-
>
numColorSamples
(
)
)
;
GrLayerHoister
:
:
DrawLayers
(
fContext
needRendering
)
;
GrRecordReplaceDraw
(
mainPicture
mainCanvas
fContext
-
>
getLayerCache
(
)
initialMatrix
nullptr
)
;
GrLayerHoister
:
:
UnlockLayers
(
fContext
needRendering
)
;
GrLayerHoister
:
:
UnlockLayers
(
fContext
recycled
)
;
GrLayerHoister
:
:
UnlockLayers
(
fContext
atlasedNeedRendering
)
;
GrLayerHoister
:
:
UnlockLayers
(
fContext
atlasedRecycled
)
;
GrLayerHoister
:
:
End
(
fContext
)
;
return
true
;
#
else
return
false
;
#
endif
}
SkImageFilter
:
:
Cache
*
SkGpuDevice
:
:
NewImageFilterCache
(
)
{
return
SkImageFilter
:
:
Cache
:
:
Create
(
kDefaultImageFilterCacheSize
)
;
}
SkImageFilter
:
:
Cache
*
SkGpuDevice
:
:
getImageFilterCache
(
)
{
return
SkGpuDevice
:
:
NewImageFilterCache
(
)
;
}
#
endif
