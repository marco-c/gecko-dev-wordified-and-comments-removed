#
include
"
SkGpuDevice
.
h
"
#
include
"
GrBitmapTextureMaker
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrImageTextureMaker
.
h
"
#
include
"
GrRenderTargetContextPriv
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTextureAdjuster
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
SkCanvasPriv
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkImageCacherator
.
h
"
#
include
"
SkImageFilter
.
h
"
#
include
"
SkImageFilterCache
.
h
"
#
include
"
SkImageInfoPriv
.
h
"
#
include
"
SkImage_Base
.
h
"
#
include
"
SkLatticeIter
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkPicture
.
h
"
#
include
"
SkPictureData
.
h
"
#
include
"
SkRRect
.
h
"
#
include
"
SkRasterClip
.
h
"
#
include
"
SkReadPixelsRec
.
h
"
#
include
"
SkRecord
.
h
"
#
include
"
SkSpecialImage
.
h
"
#
include
"
SkStroke
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkTLazy
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
SkVertState
.
h
"
#
include
"
SkVertices
.
h
"
#
include
"
SkWritePixelsRec
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
#
include
"
text
/
GrTextUtils
.
h
"
#
if
SK_SUPPORT_GPU
#
define
ASSERT_SINGLE_OWNER
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
fContext
-
>
debugSingleOwner
(
)
)
;
)
#
if
0
extern
bool
(
*
gShouldDrawProc
)
(
)
;
#
define
CHECK_SHOULD_DRAW
(
)
\
do
{
\
if
(
gShouldDrawProc
&
&
!
gShouldDrawProc
(
)
)
return
;
\
}
while
(
0
)
#
else
#
define
CHECK_SHOULD_DRAW
(
)
#
endif
bool
SkGpuDevice
:
:
CheckAlphaTypeAndGetFlags
(
const
SkImageInfo
*
info
SkGpuDevice
:
:
InitContents
init
unsigned
*
flags
)
{
*
flags
=
0
;
if
(
info
)
{
switch
(
info
-
>
alphaType
(
)
)
{
case
kPremul_SkAlphaType
:
break
;
case
kOpaque_SkAlphaType
:
*
flags
|
=
SkGpuDevice
:
:
kIsOpaque_Flag
;
break
;
default
:
return
false
;
}
}
if
(
kClear_InitContents
=
=
init
)
{
*
flags
|
=
kNeedClear_Flag
;
}
return
true
;
}
sk_sp
<
SkGpuDevice
>
SkGpuDevice
:
:
Make
(
GrContext
*
context
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
int
width
int
height
InitContents
init
)
{
if
(
!
renderTargetContext
|
|
renderTargetContext
-
>
wasAbandoned
(
)
)
{
return
nullptr
;
}
unsigned
flags
;
if
(
!
CheckAlphaTypeAndGetFlags
(
nullptr
init
&
flags
)
)
{
return
nullptr
;
}
return
sk_sp
<
SkGpuDevice
>
(
new
SkGpuDevice
(
context
std
:
:
move
(
renderTargetContext
)
width
height
flags
)
)
;
}
sk_sp
<
SkGpuDevice
>
SkGpuDevice
:
:
Make
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
info
int
sampleCount
GrSurfaceOrigin
origin
const
SkSurfaceProps
*
props
InitContents
init
)
{
unsigned
flags
;
if
(
!
CheckAlphaTypeAndGetFlags
(
&
info
init
&
flags
)
)
{
return
nullptr
;
}
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
(
MakeRenderTargetContext
(
context
budgeted
info
sampleCount
origin
props
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
return
sk_sp
<
SkGpuDevice
>
(
new
SkGpuDevice
(
context
std
:
:
move
(
renderTargetContext
)
info
.
width
(
)
info
.
height
(
)
flags
)
)
;
}
static
SkImageInfo
make_info
(
GrRenderTargetContext
*
context
int
w
int
h
bool
opaque
)
{
SkColorType
colorType
;
if
(
!
GrPixelConfigToColorType
(
context
-
>
config
(
)
&
colorType
)
)
{
colorType
=
kUnknown_SkColorType
;
}
return
SkImageInfo
:
:
Make
(
w
h
colorType
opaque
?
kOpaque_SkAlphaType
:
kPremul_SkAlphaType
context
-
>
refColorSpace
(
)
)
;
}
SkGpuDevice
:
:
SkGpuDevice
(
GrContext
*
context
sk_sp
<
GrRenderTargetContext
>
renderTargetContext
int
width
int
height
unsigned
flags
)
:
INHERITED
(
make_info
(
renderTargetContext
.
get
(
)
width
height
SkToBool
(
flags
&
kIsOpaque_Flag
)
)
renderTargetContext
-
>
surfaceProps
(
)
)
fContext
(
SkRef
(
context
)
)
fRenderTargetContext
(
std
:
:
move
(
renderTargetContext
)
)
{
fSize
.
set
(
width
height
)
;
fOpaque
=
SkToBool
(
flags
&
kIsOpaque_Flag
)
;
if
(
flags
&
kNeedClear_Flag
)
{
this
-
>
clearAll
(
)
;
}
}
sk_sp
<
GrRenderTargetContext
>
SkGpuDevice
:
:
MakeRenderTargetContext
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
origInfo
int
sampleCount
GrSurfaceOrigin
origin
const
SkSurfaceProps
*
surfaceProps
)
{
if
(
kUnknown_SkColorType
=
=
origInfo
.
colorType
(
)
|
|
origInfo
.
width
(
)
<
0
|
|
origInfo
.
height
(
)
<
0
)
{
return
nullptr
;
}
if
(
!
context
)
{
return
nullptr
;
}
GrPixelConfig
config
=
SkImageInfo2GrPixelConfig
(
origInfo
*
context
-
>
caps
(
)
)
;
return
context
-
>
makeRenderTargetContext
(
SkBackingFit
:
:
kExact
origInfo
.
width
(
)
origInfo
.
height
(
)
config
origInfo
.
refColorSpace
(
)
sampleCount
origin
surfaceProps
budgeted
)
;
}
sk_sp
<
SkSpecialImage
>
SkGpuDevice
:
:
filterTexture
(
SkSpecialImage
*
srcImg
int
left
int
top
SkIPoint
*
offset
const
SkImageFilter
*
filter
)
{
SkASSERT
(
srcImg
-
>
isTextureBacked
(
)
)
;
SkASSERT
(
filter
)
;
SkMatrix
matrix
=
this
-
>
ctm
(
)
;
matrix
.
postTranslate
(
SkIntToScalar
(
-
left
)
SkIntToScalar
(
-
top
)
)
;
const
SkIRect
clipBounds
=
this
-
>
devClipBounds
(
)
.
makeOffset
(
-
left
-
top
)
;
sk_sp
<
SkImageFilterCache
>
cache
(
this
-
>
getImageFilterCache
(
)
)
;
SkImageFilter
:
:
OutputProperties
outputProperties
(
fRenderTargetContext
-
>
getColorSpace
(
)
)
;
SkImageFilter
:
:
Context
ctx
(
matrix
clipBounds
cache
.
get
(
)
outputProperties
)
;
return
filter
-
>
filterImage
(
srcImg
ctx
offset
)
;
}
bool
SkGpuDevice
:
:
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
x
int
y
)
{
ASSERT_SINGLE_OWNER
if
(
!
SkImageInfoValidConversion
(
dstInfo
this
-
>
imageInfo
(
)
)
)
{
return
false
;
}
SkReadPixelsRec
rec
(
dstInfo
dstPixels
dstRowBytes
x
y
)
;
if
(
!
rec
.
trim
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
{
return
false
;
}
return
fRenderTargetContext
-
>
readPixels
(
rec
.
fInfo
rec
.
fPixels
rec
.
fRowBytes
rec
.
fX
rec
.
fY
)
;
}
bool
SkGpuDevice
:
:
onWritePixels
(
const
SkImageInfo
&
srcInfo
const
void
*
srcPixels
size_t
srcRowBytes
int
x
int
y
)
{
ASSERT_SINGLE_OWNER
if
(
!
SkImageInfoValidConversion
(
this
-
>
imageInfo
(
)
srcInfo
)
)
{
return
false
;
}
SkWritePixelsRec
rec
(
srcInfo
srcPixels
srcRowBytes
x
y
)
;
if
(
!
rec
.
trim
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
{
return
false
;
}
return
fRenderTargetContext
-
>
writePixels
(
rec
.
fInfo
rec
.
fPixels
rec
.
fRowBytes
rec
.
fX
rec
.
fY
)
;
}
bool
SkGpuDevice
:
:
onAccessPixels
(
SkPixmap
*
pmap
)
{
ASSERT_SINGLE_OWNER
return
false
;
}
GrRenderTargetContext
*
SkGpuDevice
:
:
accessRenderTargetContext
(
)
{
ASSERT_SINGLE_OWNER
return
fRenderTargetContext
.
get
(
)
;
}
void
SkGpuDevice
:
:
clearAll
(
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
clearAll
"
fContext
.
get
(
)
)
;
SkIRect
rect
=
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
fRenderTargetContext
-
>
clear
(
&
rect
0x0
true
)
;
}
void
SkGpuDevice
:
:
replaceRenderTargetContext
(
bool
shouldRetainContent
)
{
ASSERT_SINGLE_OWNER
SkBudgeted
budgeted
=
fRenderTargetContext
-
>
priv
(
)
.
isBudgeted
(
)
;
sk_sp
<
GrRenderTargetContext
>
newRTC
(
MakeRenderTargetContext
(
this
-
>
context
(
)
budgeted
this
-
>
imageInfo
(
)
fRenderTargetContext
-
>
numColorSamples
(
)
fRenderTargetContext
-
>
origin
(
)
&
this
-
>
surfaceProps
(
)
)
)
;
if
(
!
newRTC
)
{
return
;
}
SkASSERT
(
newRTC
-
>
asSurfaceProxy
(
)
-
>
priv
(
)
.
isExact
(
)
)
;
if
(
shouldRetainContent
)
{
if
(
fRenderTargetContext
-
>
wasAbandoned
(
)
)
{
return
;
}
newRTC
-
>
copy
(
fRenderTargetContext
-
>
asSurfaceProxy
(
)
)
;
}
fRenderTargetContext
=
newRTC
;
}
void
SkGpuDevice
:
:
drawPaint
(
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawPaint
"
fContext
.
get
(
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawPaint
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
)
;
}
static
const
GrPrimitiveType
gPointMode2PrimitiveType
[
]
=
{
kPoints_GrPrimitiveType
kLines_GrPrimitiveType
kLineStrip_GrPrimitiveType
}
;
static
inline
bool
is_int
(
float
x
)
{
return
x
=
=
(
float
)
sk_float_round2int
(
x
)
;
}
static
bool
needs_antialiasing
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
const
SkMatrix
&
matrix
)
{
if
(
mode
=
=
SkCanvas
:
:
PointMode
:
:
kPoints_PointMode
)
{
return
false
;
}
if
(
count
=
=
2
)
{
if
(
!
matrix
.
isScaleTranslate
(
)
)
{
return
true
;
}
if
(
pts
[
0
]
.
fX
=
=
pts
[
1
]
.
fX
)
{
SkScalar
x
=
matrix
.
getScaleX
(
)
*
pts
[
0
]
.
fX
+
matrix
.
getTranslateX
(
)
;
return
!
is_int
(
x
+
0
.
5f
)
;
}
if
(
pts
[
0
]
.
fY
=
=
pts
[
1
]
.
fY
)
{
SkScalar
y
=
matrix
.
getScaleY
(
)
*
pts
[
0
]
.
fY
+
matrix
.
getTranslateY
(
)
;
return
!
is_int
(
y
+
0
.
5f
)
;
}
}
return
true
;
}
void
SkGpuDevice
:
:
drawPoints
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
pts
[
]
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawPoints
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
SkScalar
width
=
paint
.
getStrokeWidth
(
)
;
if
(
width
<
0
)
{
return
;
}
if
(
paint
.
getPathEffect
(
)
&
&
2
=
=
count
&
&
SkCanvas
:
:
kLines_PointMode
=
=
mode
)
{
GrStyle
style
(
paint
SkPaint
:
:
kStroke_Style
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
moveTo
(
pts
[
0
]
)
;
path
.
lineTo
(
pts
[
1
]
)
;
fRenderTargetContext
-
>
drawPath
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
path
style
)
;
return
;
}
SkScalar
scales
[
2
]
;
bool
isHairline
=
(
0
=
=
width
)
|
|
(
1
=
=
width
&
&
this
-
>
ctm
(
)
.
getMinMaxScales
(
scales
)
&
&
SkScalarNearlyEqual
(
scales
[
0
]
1
.
f
)
&
&
SkScalarNearlyEqual
(
scales
[
1
]
1
.
f
)
)
;
if
(
!
isHairline
|
|
paint
.
getPathEffect
(
)
|
|
paint
.
getMaskFilter
(
)
|
|
(
paint
.
isAntiAlias
(
)
&
&
needs_antialiasing
(
mode
count
pts
this
-
>
ctm
(
)
)
)
)
{
SkRasterClip
rc
(
this
-
>
devClipBounds
(
)
)
;
SkDraw
draw
;
draw
.
fDst
=
SkPixmap
(
SkImageInfo
:
:
MakeUnknown
(
this
-
>
width
(
)
this
-
>
height
(
)
)
nullptr
0
)
;
draw
.
fMatrix
=
&
this
-
>
ctm
(
)
;
draw
.
fRC
=
&
rc
;
draw
.
drawPoints
(
mode
count
pts
paint
this
)
;
return
;
}
GrPrimitiveType
primitiveType
=
gPointMode2PrimitiveType
[
mode
]
;
const
SkMatrix
*
viewMatrix
=
&
this
-
>
ctm
(
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkMatrix
tempMatrix
;
if
(
GrIsPrimTypeLines
(
primitiveType
)
|
|
kPoints_GrPrimitiveType
=
=
primitiveType
)
{
tempMatrix
=
*
viewMatrix
;
static
const
SkScalar
kOffset
=
0
.
063f
;
tempMatrix
.
postTranslate
(
kOffset
kOffset
)
;
viewMatrix
=
&
tempMatrix
;
}
#
endif
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
*
viewMatrix
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawVertices
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
*
viewMatrix
primitiveType
SkToS32
(
count
)
(
SkPoint
*
)
pts
nullptr
nullptr
nullptr
0
)
;
}
void
SkGpuDevice
:
:
drawRect
(
const
SkRect
&
rect
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawRect
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
if
(
paint
.
getMaskFilter
(
)
|
|
paint
.
getPathEffect
(
)
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRect
(
rect
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
path
paint
this
-
>
ctm
(
)
nullptr
this
-
>
devClipBounds
(
)
true
)
;
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
GrStyle
style
(
paint
)
;
fRenderTargetContext
-
>
drawRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
rect
&
style
)
;
}
void
SkGpuDevice
:
:
drawRRect
(
const
SkRRect
&
rrect
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawRRect
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
if
(
mf
&
&
mf
-
>
asFragmentProcessor
(
nullptr
nullptr
this
-
>
ctm
(
)
)
)
{
mf
=
nullptr
;
}
GrStyle
style
(
paint
)
;
if
(
mf
)
{
SkRRect
devRRect
;
if
(
rrect
.
transform
(
this
-
>
ctm
(
)
&
devRRect
)
)
{
if
(
devRRect
.
allCornersCircular
(
)
)
{
SkRect
maskRect
;
if
(
mf
-
>
canFilterMaskGPU
(
devRRect
this
-
>
devClipBounds
(
)
this
-
>
ctm
(
)
&
maskRect
)
)
{
SkIRect
finalIRect
;
maskRect
.
roundOut
(
&
finalIRect
)
;
if
(
mf
-
>
directFilterRRectMaskGPU
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
std
:
:
move
(
grPaint
)
this
-
>
clip
(
)
this
-
>
ctm
(
)
style
.
strokeRec
(
)
rrect
devRRect
)
)
{
return
;
}
}
}
}
}
if
(
mf
|
|
style
.
pathEffect
(
)
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
rrect
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
path
paint
this
-
>
ctm
(
)
nullptr
this
-
>
devClipBounds
(
)
true
)
;
return
;
}
SkASSERT
(
!
style
.
pathEffect
(
)
)
;
fRenderTargetContext
-
>
drawRRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
rrect
style
)
;
}
void
SkGpuDevice
:
:
drawDRRect
(
const
SkRRect
&
outer
const
SkRRect
&
inner
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawDRRect
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
if
(
outer
.
isEmpty
(
)
)
{
return
;
}
if
(
inner
.
isEmpty
(
)
)
{
return
this
-
>
drawRRect
(
outer
paint
)
;
}
SkStrokeRec
stroke
(
paint
)
;
if
(
stroke
.
isFillStyle
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getPathEffect
(
)
)
{
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawDRRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
outer
inner
)
;
return
;
}
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
outer
)
;
path
.
addRRect
(
inner
)
;
path
.
setFillType
(
SkPath
:
:
kEvenOdd_FillType
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
path
paint
this
-
>
ctm
(
)
nullptr
this
-
>
devClipBounds
(
)
true
)
;
}
void
SkGpuDevice
:
:
drawRegion
(
const
SkRegion
&
region
const
SkPaint
&
paint
)
{
if
(
paint
.
getMaskFilter
(
)
)
{
SkPath
path
;
region
.
getBoundaryPath
(
&
path
)
;
return
this
-
>
drawPath
(
path
paint
nullptr
false
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawRegion
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
region
GrStyle
(
paint
)
)
;
}
void
SkGpuDevice
:
:
drawOval
(
const
SkRect
&
oval
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawOval
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
if
(
paint
.
getPathEffect
(
)
)
{
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addOval
(
oval
)
;
this
-
>
drawPath
(
path
paint
nullptr
true
)
;
return
;
}
if
(
paint
.
getMaskFilter
(
)
)
{
SkRRect
rr
=
SkRRect
:
:
MakeOval
(
oval
)
;
return
this
-
>
drawRRect
(
rr
paint
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawOval
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
oval
GrStyle
(
paint
)
)
;
}
void
SkGpuDevice
:
:
drawArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawArc
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
if
(
paint
.
getMaskFilter
(
)
)
{
this
-
>
INHERITED
:
:
drawArc
(
oval
startAngle
sweepAngle
useCenter
paint
)
;
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawArc
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
this
-
>
ctm
(
)
oval
startAngle
sweepAngle
useCenter
GrStyle
(
paint
)
)
;
}
#
include
"
SkMaskFilter
.
h
"
void
SkGpuDevice
:
:
drawStrokedLine
(
const
SkPoint
points
[
2
]
const
SkPaint
&
origPaint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawStrokedLine
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
SkASSERT
(
SkPaint
:
:
kRound_Cap
!
=
origPaint
.
getStrokeCap
(
)
)
;
SkASSERT
(
SkPaint
:
:
kStroke_Style
=
=
origPaint
.
getStyle
(
)
)
;
SkASSERT
(
!
origPaint
.
getPathEffect
(
)
)
;
SkASSERT
(
!
origPaint
.
getMaskFilter
(
)
)
;
const
SkScalar
halfWidth
=
0
.
5f
*
origPaint
.
getStrokeWidth
(
)
;
SkASSERT
(
halfWidth
>
0
)
;
SkVector
v
=
points
[
1
]
-
points
[
0
]
;
SkScalar
length
=
SkPoint
:
:
Normalize
(
&
v
)
;
if
(
!
length
)
{
v
.
fX
=
1
.
0f
;
v
.
fY
=
0
.
0f
;
}
SkPaint
newPaint
(
origPaint
)
;
newPaint
.
setStyle
(
SkPaint
:
:
kFill_Style
)
;
SkScalar
xtraLength
=
0
.
0f
;
if
(
SkPaint
:
:
kButt_Cap
!
=
origPaint
.
getStrokeCap
(
)
)
{
xtraLength
=
halfWidth
;
}
SkPoint
mid
=
points
[
0
]
+
points
[
1
]
;
mid
.
scale
(
0
.
5f
)
;
SkRect
rect
=
SkRect
:
:
MakeLTRB
(
mid
.
fX
-
halfWidth
mid
.
fY
-
0
.
5f
*
length
-
xtraLength
mid
.
fX
+
halfWidth
mid
.
fY
+
0
.
5f
*
length
+
xtraLength
)
;
SkMatrix
m
;
m
.
setSinCos
(
v
.
fX
-
v
.
fY
mid
.
fX
mid
.
fY
)
;
SkMatrix
local
=
m
;
m
.
postConcat
(
this
-
>
ctm
(
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
newPaint
m
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
fillRectWithLocalMatrix
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
newPaint
.
isAntiAlias
(
)
)
m
rect
local
)
;
}
void
SkGpuDevice
:
:
drawPath
(
const
SkPath
&
origSrcPath
const
SkPaint
&
paint
const
SkMatrix
*
prePathMatrix
bool
pathIsMutable
)
{
ASSERT_SINGLE_OWNER
if
(
!
origSrcPath
.
isInverseFillType
(
)
&
&
!
paint
.
getPathEffect
(
)
&
&
!
prePathMatrix
)
{
SkPoint
points
[
2
]
;
if
(
SkPaint
:
:
kStroke_Style
=
=
paint
.
getStyle
(
)
&
&
paint
.
getStrokeWidth
(
)
>
0
&
&
!
paint
.
getMaskFilter
(
)
&
&
SkPaint
:
:
kRound_Cap
!
=
paint
.
getStrokeCap
(
)
&
&
this
-
>
ctm
(
)
.
preservesRightAngles
(
)
&
&
origSrcPath
.
isLine
(
points
)
)
{
SkScalar
strokeWidth
=
this
-
>
ctm
(
)
.
getMaxScale
(
)
*
paint
.
getStrokeWidth
(
)
;
if
(
strokeWidth
>
=
1
.
0f
)
{
this
-
>
drawStrokedLine
(
points
paint
)
;
return
;
}
}
bool
isClosed
;
SkRect
rect
;
if
(
origSrcPath
.
isRect
(
&
rect
&
isClosed
)
&
&
isClosed
)
{
this
-
>
drawRect
(
rect
paint
)
;
return
;
}
if
(
origSrcPath
.
isOval
(
&
rect
)
)
{
this
-
>
drawOval
(
rect
paint
)
;
return
;
}
SkRRect
rrect
;
if
(
origSrcPath
.
isRRect
(
&
rrect
)
)
{
this
-
>
drawRRect
(
rrect
paint
)
;
return
;
}
}
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawPath
"
fContext
.
get
(
)
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
origSrcPath
paint
this
-
>
ctm
(
)
prePathMatrix
this
-
>
devClipBounds
(
)
pathIsMutable
)
;
}
static
const
int
kBmpSmallTileSize
=
1
<
<
10
;
static
inline
int
get_tile_count
(
const
SkIRect
&
srcRect
int
tileSize
)
{
int
tilesX
=
(
srcRect
.
fRight
/
tileSize
)
-
(
srcRect
.
fLeft
/
tileSize
)
+
1
;
int
tilesY
=
(
srcRect
.
fBottom
/
tileSize
)
-
(
srcRect
.
fTop
/
tileSize
)
+
1
;
return
tilesX
*
tilesY
;
}
static
int
determine_tile_size
(
const
SkIRect
&
src
int
maxTileSize
)
{
if
(
maxTileSize
<
=
kBmpSmallTileSize
)
{
return
maxTileSize
;
}
size_t
maxTileTotalTileSize
=
get_tile_count
(
src
maxTileSize
)
;
size_t
smallTotalTileSize
=
get_tile_count
(
src
kBmpSmallTileSize
)
;
maxTileTotalTileSize
*
=
maxTileSize
*
maxTileSize
;
smallTotalTileSize
*
=
kBmpSmallTileSize
*
kBmpSmallTileSize
;
if
(
maxTileTotalTileSize
>
2
*
smallTotalTileSize
)
{
return
kBmpSmallTileSize
;
}
else
{
return
maxTileSize
;
}
}
static
void
determine_clipped_src_rect
(
int
width
int
height
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstRect
const
SkISize
&
imageSize
const
SkRect
*
srcRectPtr
SkIRect
*
clippedSrcIRect
)
{
clip
.
getConservativeBounds
(
width
height
clippedSrcIRect
nullptr
)
;
SkMatrix
inv
=
SkMatrix
:
:
Concat
(
viewMatrix
srcToDstRect
)
;
if
(
!
inv
.
invert
(
&
inv
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
return
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
*
clippedSrcIRect
)
;
inv
.
mapRect
(
&
clippedSrcRect
)
;
if
(
srcRectPtr
)
{
if
(
!
clippedSrcRect
.
intersect
(
*
srcRectPtr
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
return
;
}
}
clippedSrcRect
.
roundOut
(
clippedSrcIRect
)
;
SkIRect
bmpBounds
=
SkIRect
:
:
MakeSize
(
imageSize
)
;
if
(
!
clippedSrcIRect
-
>
intersect
(
bmpBounds
)
)
{
clippedSrcIRect
-
>
setEmpty
(
)
;
}
}
bool
SkGpuDevice
:
:
shouldTileImageID
(
uint32_t
imageID
const
SkIRect
&
imageRect
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstRect
const
GrSamplerParams
&
params
const
SkRect
*
srcRectPtr
int
maxTileSize
int
*
tileSize
SkIRect
*
clippedSubset
)
const
{
ASSERT_SINGLE_OWNER
if
(
imageRect
.
width
(
)
>
maxTileSize
|
|
imageRect
.
height
(
)
>
maxTileSize
)
{
determine_clipped_src_rect
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
this
-
>
clip
(
)
viewMatrix
srcToDstRect
imageRect
.
size
(
)
srcRectPtr
clippedSubset
)
;
*
tileSize
=
determine_tile_size
(
*
clippedSubset
maxTileSize
)
;
return
true
;
}
const
size_t
area
=
imageRect
.
width
(
)
*
imageRect
.
height
(
)
;
if
(
area
<
4
*
kBmpSmallTileSize
*
kBmpSmallTileSize
)
{
return
false
;
}
size_t
bmpSize
=
area
*
sizeof
(
SkPMColor
)
;
size_t
cacheSize
;
fContext
-
>
getResourceCacheLimits
(
nullptr
&
cacheSize
)
;
if
(
bmpSize
<
cacheSize
/
2
)
{
return
false
;
}
determine_clipped_src_rect
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
this
-
>
clip
(
)
viewMatrix
srcToDstRect
imageRect
.
size
(
)
srcRectPtr
clippedSubset
)
;
*
tileSize
=
kBmpSmallTileSize
;
size_t
usedTileBytes
=
get_tile_count
(
*
clippedSubset
kBmpSmallTileSize
)
*
kBmpSmallTileSize
*
kBmpSmallTileSize
*
sizeof
(
SkPMColor
)
;
return
usedTileBytes
*
2
<
bmpSize
;
}
bool
SkGpuDevice
:
:
shouldTileImage
(
const
SkImage
*
image
const
SkRect
*
srcRectPtr
SkCanvas
:
:
SrcRectConstraint
constraint
SkFilterQuality
quality
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstRect
)
const
{
ASSERT_SINGLE_OWNER
if
(
image
-
>
isTextureBacked
(
)
)
{
return
false
;
}
GrSamplerParams
params
;
bool
doBicubic
;
GrSamplerParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
quality
viewMatrix
srcToDstRect
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrSamplerParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
int
outTileSize
;
SkIRect
outClippedSrcRect
;
return
this
-
>
shouldTileImageID
(
image
-
>
unique
(
)
image
-
>
bounds
(
)
viewMatrix
srcToDstRect
params
srcRectPtr
maxTileSize
&
outTileSize
&
outClippedSrcRect
)
;
}
void
SkGpuDevice
:
:
drawBitmap
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
m
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
SkMatrix
viewMatrix
;
viewMatrix
.
setConcat
(
this
-
>
ctm
(
)
m
)
;
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
;
bool
drawAA
=
!
fRenderTargetContext
-
>
isUnifiedMultisampled
(
)
&
&
paint
.
isAntiAlias
(
)
&
&
bitmap
.
width
(
)
<
=
maxTileSize
&
&
bitmap
.
height
(
)
<
=
maxTileSize
;
bool
skipTileCheck
=
drawAA
|
|
paint
.
getMaskFilter
(
)
;
if
(
!
skipTileCheck
)
{
SkRect
srcRect
=
SkRect
:
:
MakeIWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
int
tileSize
;
SkIRect
clippedSrcRect
;
GrSamplerParams
params
;
bool
doBicubic
;
GrSamplerParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
viewMatrix
SkMatrix
:
:
I
(
)
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrSamplerParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSizeForFilter
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
if
(
this
-
>
shouldTileImageID
(
bitmap
.
getGenerationID
(
)
bitmap
.
getSubset
(
)
viewMatrix
SkMatrix
:
:
I
(
)
params
&
srcRect
maxTileSizeForFilter
&
tileSize
&
clippedSrcRect
)
)
{
this
-
>
drawTiledBitmap
(
bitmap
viewMatrix
SkMatrix
:
:
I
(
)
srcRect
clippedSrcRect
params
paint
SkCanvas
:
:
kStrict_SrcRectConstraint
tileSize
doBicubic
)
;
return
;
}
}
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bitmap
)
;
this
-
>
drawTextureProducer
(
&
maker
nullptr
nullptr
SkCanvas
:
:
kStrict_SrcRectConstraint
viewMatrix
this
-
>
clip
(
)
paint
)
;
}
static
inline
void
clamped_outset_with_offset
(
SkIRect
*
iRect
int
outset
SkPoint
*
offset
const
SkIRect
&
clamp
)
{
iRect
-
>
outset
(
outset
outset
)
;
int
leftClampDelta
=
clamp
.
fLeft
-
iRect
-
>
fLeft
;
if
(
leftClampDelta
>
0
)
{
offset
-
>
fX
-
=
outset
-
leftClampDelta
;
iRect
-
>
fLeft
=
clamp
.
fLeft
;
}
else
{
offset
-
>
fX
-
=
outset
;
}
int
topClampDelta
=
clamp
.
fTop
-
iRect
-
>
fTop
;
if
(
topClampDelta
>
0
)
{
offset
-
>
fY
-
=
outset
-
topClampDelta
;
iRect
-
>
fTop
=
clamp
.
fTop
;
}
else
{
offset
-
>
fY
-
=
outset
;
}
if
(
iRect
-
>
fRight
>
clamp
.
fRight
)
{
iRect
-
>
fRight
=
clamp
.
fRight
;
}
if
(
iRect
-
>
fBottom
>
clamp
.
fBottom
)
{
iRect
-
>
fBottom
=
clamp
.
fBottom
;
}
}
void
SkGpuDevice
:
:
drawTiledBitmap
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
dstMatrix
const
SkRect
&
srcRect
const
SkIRect
&
clippedSrcIRect
const
GrSamplerParams
&
params
const
SkPaint
&
origPaint
SkCanvas
:
:
SrcRectConstraint
constraint
int
tileSize
bool
bicubic
)
{
ASSERT_SINGLE_OWNER
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
true
)
;
LogDrawScaleFactor
(
viewMatrix
origPaint
.
getFilterQuality
(
)
)
;
SkAutoLockPixels
alp
(
bitmap
)
;
const
SkPaint
*
paint
=
&
origPaint
;
SkPaint
tempPaint
;
if
(
origPaint
.
isAntiAlias
(
)
&
&
!
fRenderTargetContext
-
>
isUnifiedMultisampled
(
)
)
{
tempPaint
=
origPaint
;
tempPaint
.
setAntiAlias
(
false
)
;
paint
=
&
tempPaint
;
}
SkRect
clippedSrcRect
=
SkRect
:
:
Make
(
clippedSrcIRect
)
;
int
nx
=
bitmap
.
width
(
)
/
tileSize
;
int
ny
=
bitmap
.
height
(
)
/
tileSize
;
for
(
int
x
=
0
;
x
<
=
nx
;
x
+
+
)
{
for
(
int
y
=
0
;
y
<
=
ny
;
y
+
+
)
{
SkRect
tileR
;
tileR
.
set
(
SkIntToScalar
(
x
*
tileSize
)
SkIntToScalar
(
y
*
tileSize
)
SkIntToScalar
(
(
x
+
1
)
*
tileSize
)
SkIntToScalar
(
(
y
+
1
)
*
tileSize
)
)
;
if
(
!
SkRect
:
:
Intersects
(
tileR
clippedSrcRect
)
)
{
continue
;
}
if
(
!
tileR
.
intersect
(
srcRect
)
)
{
continue
;
}
SkIRect
iTileR
;
tileR
.
roundOut
(
&
iTileR
)
;
SkVector
offset
=
SkPoint
:
:
Make
(
SkIntToScalar
(
iTileR
.
fLeft
)
SkIntToScalar
(
iTileR
.
fTop
)
)
;
SkRect
rectToDraw
=
tileR
;
dstMatrix
.
mapRect
(
&
rectToDraw
)
;
if
(
GrSamplerParams
:
:
kNone_FilterMode
!
=
params
.
filterMode
(
)
|
|
bicubic
)
{
SkIRect
iClampRect
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
iClampRect
=
SkIRect
:
:
MakeWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
}
else
{
srcRect
.
roundOut
(
&
iClampRect
)
;
}
int
outset
=
bicubic
?
GrBicubicEffect
:
:
kFilterTexelPad
:
1
;
clamped_outset_with_offset
(
&
iTileR
outset
&
offset
iClampRect
)
;
}
SkBitmap
tmpB
;
if
(
bitmap
.
extractSubset
(
&
tmpB
iTileR
)
)
{
tileR
.
offset
(
-
offset
.
fX
-
offset
.
fY
)
;
bool
needsTextureDomain
=
true
;
this
-
>
drawBitmapTile
(
tmpB
viewMatrix
rectToDraw
tileR
params
*
paint
constraint
bicubic
needsTextureDomain
)
;
}
}
}
}
void
SkGpuDevice
:
:
drawBitmapTile
(
const
SkBitmap
&
bitmap
const
SkMatrix
&
viewMatrix
const
SkRect
&
dstRect
const
SkRect
&
srcRect
const
GrSamplerParams
&
params
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
bool
bicubic
bool
needsTextureDomain
)
{
SkASSERT
(
bitmap
.
width
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTextureSize
(
)
&
&
bitmap
.
height
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTextureSize
(
)
)
;
SkASSERT
(
bitmap
.
width
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
&
&
bitmap
.
height
(
)
<
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
)
;
SkASSERT
(
SkShader
:
:
kClamp_TileMode
=
=
params
.
getTileModeX
(
)
&
&
SkShader
:
:
kClamp_TileMode
=
=
params
.
getTileModeY
(
)
)
;
sk_sp
<
GrTextureProxy
>
proxy
=
GrRefCachedBitmapTextureProxy
(
fContext
.
get
(
)
bitmap
params
nullptr
)
;
if
(
!
proxy
)
{
return
;
}
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
=
GrColorSpaceXform
:
:
Make
(
bitmap
.
colorSpace
(
)
fRenderTargetContext
-
>
getColorSpace
(
)
)
;
const
SkMatrix
texMatrix
=
SkMatrix
:
:
MakeRectToRect
(
dstRect
srcRect
SkMatrix
:
:
kFill_ScaleToFit
)
;
sk_sp
<
GrFragmentProcessor
>
fp
;
if
(
needsTextureDomain
&
&
(
SkCanvas
:
:
kStrict_SrcRectConstraint
=
=
constraint
)
)
{
SkRect
domain
;
if
(
srcRect
.
width
(
)
>
SK_Scalar1
)
{
domain
.
fLeft
=
srcRect
.
fLeft
+
0
.
5f
;
domain
.
fRight
=
srcRect
.
fRight
-
0
.
5f
;
}
else
{
domain
.
fLeft
=
domain
.
fRight
=
srcRect
.
centerX
(
)
;
}
if
(
srcRect
.
height
(
)
>
SK_Scalar1
)
{
domain
.
fTop
=
srcRect
.
fTop
+
0
.
5f
;
domain
.
fBottom
=
srcRect
.
fBottom
-
0
.
5f
;
}
else
{
domain
.
fTop
=
domain
.
fBottom
=
srcRect
.
centerY
(
)
;
}
if
(
bicubic
)
{
fp
=
GrBicubicEffect
:
:
Make
(
this
-
>
context
(
)
-
>
resourceProvider
(
)
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
texMatrix
domain
)
;
}
else
{
fp
=
GrTextureDomainEffect
:
:
Make
(
this
-
>
context
(
)
-
>
resourceProvider
(
)
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
texMatrix
domain
GrTextureDomain
:
:
kClamp_Mode
params
.
filterMode
(
)
)
;
}
}
else
if
(
bicubic
)
{
SkASSERT
(
GrSamplerParams
:
:
kNone_FilterMode
=
=
params
.
filterMode
(
)
)
;
SkShader
:
:
TileMode
tileModes
[
2
]
=
{
params
.
getTileModeX
(
)
params
.
getTileModeY
(
)
}
;
fp
=
GrBicubicEffect
:
:
Make
(
this
-
>
context
(
)
-
>
resourceProvider
(
)
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
texMatrix
tileModes
)
;
}
else
{
fp
=
GrSimpleTextureEffect
:
:
Make
(
this
-
>
context
(
)
-
>
resourceProvider
(
)
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
texMatrix
params
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
viewMatrix
std
:
:
move
(
fp
)
kAlpha_8_SkColorType
=
=
bitmap
.
colorType
(
)
&
grPaint
)
)
{
return
;
}
GrAA
aa
=
GrBoolToAA
(
paint
.
isAntiAlias
(
)
&
&
fRenderTargetContext
-
>
isStencilBufferMultisampled
(
)
)
;
fRenderTargetContext
-
>
drawRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
aa
viewMatrix
dstRect
)
;
}
void
SkGpuDevice
:
:
drawSprite
(
const
SkBitmap
&
bitmap
int
left
int
top
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawSprite
"
fContext
.
get
(
)
)
;
if
(
fContext
-
>
abandoned
(
)
)
{
return
;
}
sk_sp
<
SkSpecialImage
>
srcImg
=
this
-
>
makeSpecial
(
bitmap
)
;
if
(
!
srcImg
)
{
return
;
}
this
-
>
drawSpecial
(
srcImg
.
get
(
)
left
top
paint
)
;
}
void
SkGpuDevice
:
:
drawSpecial
(
SkSpecialImage
*
special1
int
left
int
top
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawSpecial
"
fContext
.
get
(
)
)
;
SkIPoint
offset
=
{
0
0
}
;
sk_sp
<
SkSpecialImage
>
result
;
if
(
paint
.
getImageFilter
(
)
)
{
result
=
this
-
>
filterTexture
(
special1
left
top
&
offset
paint
.
getImageFilter
(
)
)
;
if
(
!
result
)
{
return
;
}
}
else
{
result
=
sk_ref_sp
(
special1
)
;
}
SkASSERT
(
result
-
>
isTextureBacked
(
)
)
;
sk_sp
<
GrTextureProxy
>
proxy
=
result
-
>
asTextureProxyRef
(
this
-
>
context
(
)
)
;
if
(
!
proxy
)
{
return
;
}
const
GrPixelConfig
config
=
proxy
-
>
config
(
)
;
SkPaint
tmpUnfiltered
(
paint
)
;
tmpUnfiltered
.
setImageFilter
(
nullptr
)
;
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
=
GrColorSpaceXform
:
:
Make
(
result
-
>
getColorSpace
(
)
fRenderTargetContext
-
>
getColorSpace
(
)
)
;
sk_sp
<
GrFragmentProcessor
>
fp
(
GrSimpleTextureEffect
:
:
Make
(
this
-
>
context
(
)
-
>
resourceProvider
(
)
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
SkMatrix
:
:
I
(
)
)
)
;
if
(
GrPixelConfigIsAlphaOnly
(
config
)
)
{
fp
=
GrFragmentProcessor
:
:
MakeInputPremulAndMulByOutput
(
std
:
:
move
(
fp
)
)
;
}
else
{
fp
=
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
std
:
:
move
(
fp
)
)
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintReplaceShader
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
tmpUnfiltered
std
:
:
move
(
fp
)
&
grPaint
)
)
{
return
;
}
const
SkIRect
&
subset
=
result
-
>
subset
(
)
;
fRenderTargetContext
-
>
fillRectToRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
SkIRect
:
:
MakeXYWH
(
left
+
offset
.
fX
top
+
offset
.
fY
subset
.
width
(
)
subset
.
height
(
)
)
)
SkRect
:
:
Make
(
subset
)
)
;
}
void
SkGpuDevice
:
:
drawBitmapRect
(
const
SkBitmap
&
bitmap
const
SkRect
*
src
const
SkRect
&
origDst
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
const
SkRect
*
dst
=
&
origDst
;
const
SkRect
bmpBounds
=
SkRect
:
:
MakeIWH
(
bitmap
.
width
(
)
bitmap
.
height
(
)
)
;
if
(
!
src
)
{
src
=
&
bmpBounds
;
}
SkMatrix
srcToDstMatrix
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
src
*
dst
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
SkRect
tmpSrc
tmpDst
;
if
(
src
!
=
&
bmpBounds
)
{
if
(
!
bmpBounds
.
contains
(
*
src
)
)
{
tmpSrc
=
*
src
;
if
(
!
tmpSrc
.
intersect
(
bmpBounds
)
)
{
return
;
}
src
=
&
tmpSrc
;
srcToDstMatrix
.
mapRect
(
&
tmpDst
*
src
)
;
dst
=
&
tmpDst
;
}
}
int
maxTileSize
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
;
bool
drawAA
=
!
fRenderTargetContext
-
>
isUnifiedMultisampled
(
)
&
&
paint
.
isAntiAlias
(
)
&
&
bitmap
.
width
(
)
<
=
maxTileSize
&
&
bitmap
.
height
(
)
<
=
maxTileSize
;
bool
skipTileCheck
=
drawAA
|
|
paint
.
getMaskFilter
(
)
;
if
(
!
skipTileCheck
)
{
int
tileSize
;
SkIRect
clippedSrcRect
;
GrSamplerParams
params
;
bool
doBicubic
;
GrSamplerParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
this
-
>
ctm
(
)
srcToDstMatrix
&
doBicubic
)
;
int
tileFilterPad
;
if
(
doBicubic
)
{
tileFilterPad
=
GrBicubicEffect
:
:
kFilterTexelPad
;
}
else
if
(
GrSamplerParams
:
:
kNone_FilterMode
=
=
textureFilterMode
)
{
tileFilterPad
=
0
;
}
else
{
tileFilterPad
=
1
;
}
params
.
setFilterMode
(
textureFilterMode
)
;
int
maxTileSizeForFilter
=
fContext
-
>
caps
(
)
-
>
maxTileSize
(
)
-
2
*
tileFilterPad
;
if
(
this
-
>
shouldTileImageID
(
bitmap
.
getGenerationID
(
)
bitmap
.
getSubset
(
)
this
-
>
ctm
(
)
srcToDstMatrix
params
src
maxTileSizeForFilter
&
tileSize
&
clippedSrcRect
)
)
{
this
-
>
drawTiledBitmap
(
bitmap
this
-
>
ctm
(
)
srcToDstMatrix
*
src
clippedSrcRect
params
paint
constraint
tileSize
doBicubic
)
;
return
;
}
}
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bitmap
)
;
this
-
>
drawTextureProducer
(
&
maker
src
dst
constraint
this
-
>
ctm
(
)
this
-
>
clip
(
)
paint
)
;
}
sk_sp
<
SkSpecialImage
>
SkGpuDevice
:
:
makeSpecial
(
const
SkBitmap
&
bitmap
)
{
sk_sp
<
GrTextureProxy
>
proxy
=
GrMakeCachedBitmapProxy
(
fContext
-
>
resourceProvider
(
)
bitmap
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
const
SkIRect
rect
=
SkIRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
return
SkSpecialImage
:
:
MakeDeferredFromGpu
(
fContext
.
get
(
)
rect
bitmap
.
getGenerationID
(
)
std
:
:
move
(
proxy
)
bitmap
.
refColorSpace
(
)
&
this
-
>
surfaceProps
(
)
)
;
}
sk_sp
<
SkSpecialImage
>
SkGpuDevice
:
:
makeSpecial
(
const
SkImage
*
image
)
{
SkPixmap
pm
;
if
(
image
-
>
isTextureBacked
(
)
)
{
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
asTextureProxyRef
(
)
;
return
SkSpecialImage
:
:
MakeDeferredFromGpu
(
fContext
.
get
(
)
SkIRect
:
:
MakeWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
image
-
>
uniqueID
(
)
std
:
:
move
(
proxy
)
as_IB
(
image
)
-
>
onImageInfo
(
)
.
refColorSpace
(
)
&
this
-
>
surfaceProps
(
)
)
;
}
else
if
(
image
-
>
peekPixels
(
&
pm
)
)
{
SkBitmap
bm
;
bm
.
installPixels
(
pm
)
;
return
this
-
>
makeSpecial
(
bm
)
;
}
else
{
return
nullptr
;
}
}
sk_sp
<
SkSpecialImage
>
SkGpuDevice
:
:
snapSpecial
(
)
{
sk_sp
<
GrTextureProxy
>
proxy
(
this
-
>
accessRenderTargetContext
(
)
-
>
asTextureProxyRef
(
)
)
;
if
(
!
proxy
)
{
proxy
=
GrSurfaceProxy
:
:
Copy
(
fContext
.
get
(
)
this
-
>
accessRenderTargetContext
(
)
-
>
asSurfaceProxy
(
)
SkBudgeted
:
:
kYes
)
;
if
(
!
proxy
)
{
return
nullptr
;
}
}
const
SkImageInfo
ii
=
this
-
>
imageInfo
(
)
;
const
SkIRect
srcRect
=
SkIRect
:
:
MakeWH
(
ii
.
width
(
)
ii
.
height
(
)
)
;
SkASSERT
(
proxy
-
>
priv
(
)
.
isExact
(
)
)
;
return
SkSpecialImage
:
:
MakeDeferredFromGpu
(
fContext
.
get
(
)
srcRect
kNeedNewImageUniqueID_SpecialImage
std
:
:
move
(
proxy
)
ii
.
refColorSpace
(
)
&
this
-
>
surfaceProps
(
)
)
;
}
void
SkGpuDevice
:
:
drawDevice
(
SkBaseDevice
*
device
int
left
int
top
const
SkPaint
&
paint
)
{
SkASSERT
(
!
paint
.
getImageFilter
(
)
)
;
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawDevice
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
SkGpuDevice
*
dev
=
static_cast
<
SkGpuDevice
*
>
(
device
)
;
sk_sp
<
SkSpecialImage
>
srcImg
(
dev
-
>
snapSpecial
(
)
)
;
if
(
!
srcImg
)
{
return
;
}
this
-
>
drawSpecial
(
srcImg
.
get
(
)
left
top
paint
)
;
}
void
SkGpuDevice
:
:
drawImage
(
const
SkImage
*
image
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
SkMatrix
viewMatrix
=
this
-
>
ctm
(
)
;
viewMatrix
.
preTranslate
(
x
y
)
;
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
&
pinnedUniqueID
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrTextureAdjuster
adjuster
(
this
-
>
context
(
)
std
:
:
move
(
proxy
)
image
-
>
alphaType
(
)
image
-
>
bounds
(
)
pinnedUniqueID
as_IB
(
image
)
-
>
onImageInfo
(
)
.
colorSpace
(
)
)
;
this
-
>
drawTextureProducer
(
&
adjuster
nullptr
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
viewMatrix
this
-
>
clip
(
)
paint
)
;
return
;
}
else
{
SkBitmap
bm
;
if
(
this
-
>
shouldTileImage
(
image
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
paint
.
getFilterQuality
(
)
this
-
>
ctm
(
)
SkMatrix
:
:
I
(
)
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
return
;
}
this
-
>
drawBitmap
(
bm
SkMatrix
:
:
MakeTrans
(
x
y
)
paint
)
;
}
else
if
(
SkImageCacherator
*
cacher
=
as_IB
(
image
)
-
>
peekCacherator
(
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrImageTextureMaker
maker
(
fContext
.
get
(
)
cacher
image
SkImage
:
:
kAllow_CachingHint
)
;
this
-
>
drawTextureProducer
(
&
maker
nullptr
nullptr
SkCanvas
:
:
kFast_SrcRectConstraint
viewMatrix
this
-
>
clip
(
)
paint
)
;
}
else
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
this
-
>
drawBitmap
(
bm
SkMatrix
:
:
MakeTrans
(
x
y
)
paint
)
;
}
}
}
void
SkGpuDevice
:
:
drawImageRect
(
const
SkImage
*
image
const
SkRect
*
src
const
SkRect
&
dst
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
ASSERT_SINGLE_OWNER
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
&
pinnedUniqueID
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrTextureAdjuster
adjuster
(
this
-
>
context
(
)
std
:
:
move
(
proxy
)
image
-
>
alphaType
(
)
image
-
>
bounds
(
)
pinnedUniqueID
as_IB
(
image
)
-
>
onImageInfo
(
)
.
colorSpace
(
)
)
;
this
-
>
drawTextureProducer
(
&
adjuster
src
&
dst
constraint
this
-
>
ctm
(
)
this
-
>
clip
(
)
paint
)
;
return
;
}
SkBitmap
bm
;
SkMatrix
srcToDstRect
;
srcToDstRect
.
setRectToRect
(
(
src
?
*
src
:
SkRect
:
:
MakeIWH
(
image
-
>
width
(
)
image
-
>
height
(
)
)
)
dst
SkMatrix
:
:
kFill_ScaleToFit
)
;
if
(
this
-
>
shouldTileImage
(
image
src
constraint
paint
.
getFilterQuality
(
)
this
-
>
ctm
(
)
srcToDstRect
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
return
;
}
this
-
>
drawBitmapRect
(
bm
src
dst
paint
constraint
)
;
}
else
if
(
SkImageCacherator
*
cacher
=
as_IB
(
image
)
-
>
peekCacherator
(
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrImageTextureMaker
maker
(
fContext
.
get
(
)
cacher
image
SkImage
:
:
kAllow_CachingHint
)
;
this
-
>
drawTextureProducer
(
&
maker
src
&
dst
constraint
this
-
>
ctm
(
)
this
-
>
clip
(
)
paint
)
;
}
else
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
this
-
>
drawBitmapRect
(
bm
src
dst
paint
constraint
)
;
}
}
void
SkGpuDevice
:
:
drawProducerNine
(
GrTextureProducer
*
producer
const
SkIRect
&
center
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawProducerNine
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
bool
useFallback
=
paint
.
getMaskFilter
(
)
|
|
paint
.
isAntiAlias
(
)
|
|
fRenderTargetContext
-
>
isUnifiedMultisampled
(
)
;
bool
doBicubic
;
GrSamplerParams
:
:
FilterMode
textureFilterMode
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
this
-
>
ctm
(
)
SkMatrix
:
:
I
(
)
&
doBicubic
)
;
if
(
useFallback
|
|
doBicubic
|
|
GrSamplerParams
:
:
kNone_FilterMode
!
=
textureFilterMode
)
{
SkLatticeIter
iter
(
producer
-
>
width
(
)
producer
-
>
height
(
)
center
dst
)
;
SkRect
srcR
dstR
;
while
(
iter
.
next
(
&
srcR
&
dstR
)
)
{
this
-
>
drawTextureProducer
(
producer
&
srcR
&
dstR
SkCanvas
:
:
kStrict_SrcRectConstraint
this
-
>
ctm
(
)
this
-
>
clip
(
)
paint
)
;
}
return
;
}
static
const
GrSamplerParams
:
:
FilterMode
kMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
sk_sp
<
GrFragmentProcessor
>
fp
(
producer
-
>
createFragmentProcessor
(
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeIWH
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
GrTextureProducer
:
:
kNo_FilterConstraint
true
&
kMode
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
std
:
:
move
(
fp
)
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
std
:
:
unique_ptr
<
SkLatticeIter
>
iter
(
new
SkLatticeIter
(
producer
-
>
width
(
)
producer
-
>
height
(
)
center
dst
)
)
;
fRenderTargetContext
-
>
drawImageLattice
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
producer
-
>
width
(
)
producer
-
>
height
(
)
std
:
:
move
(
iter
)
dst
)
;
}
void
SkGpuDevice
:
:
drawImageNine
(
const
SkImage
*
image
const
SkIRect
&
center
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
&
pinnedUniqueID
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrTextureAdjuster
adjuster
(
this
-
>
context
(
)
std
:
:
move
(
proxy
)
image
-
>
alphaType
(
)
image
-
>
bounds
(
)
pinnedUniqueID
as_IB
(
image
)
-
>
onImageInfo
(
)
.
colorSpace
(
)
)
;
this
-
>
drawProducerNine
(
&
adjuster
center
dst
paint
)
;
}
else
{
SkBitmap
bm
;
if
(
SkImageCacherator
*
cacher
=
as_IB
(
image
)
-
>
peekCacherator
(
)
)
{
GrImageTextureMaker
maker
(
fContext
.
get
(
)
cacher
image
SkImage
:
:
kAllow_CachingHint
)
;
this
-
>
drawProducerNine
(
&
maker
center
dst
paint
)
;
}
else
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
this
-
>
drawBitmapNine
(
bm
center
dst
paint
)
;
}
}
}
void
SkGpuDevice
:
:
drawBitmapNine
(
const
SkBitmap
&
bitmap
const
SkIRect
&
center
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bitmap
)
;
this
-
>
drawProducerNine
(
&
maker
center
dst
paint
)
;
}
void
SkGpuDevice
:
:
drawProducerLattice
(
GrTextureProducer
*
producer
const
SkCanvas
:
:
Lattice
&
lattice
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawProducerLattice
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
static
const
GrSamplerParams
:
:
FilterMode
kMode
=
GrSamplerParams
:
:
kNone_FilterMode
;
sk_sp
<
GrFragmentProcessor
>
fp
(
producer
-
>
createFragmentProcessor
(
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeIWH
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
GrTextureProducer
:
:
kNo_FilterConstraint
true
&
kMode
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
std
:
:
move
(
fp
)
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
std
:
:
unique_ptr
<
SkLatticeIter
>
iter
(
new
SkLatticeIter
(
lattice
dst
)
)
;
fRenderTargetContext
-
>
drawImageLattice
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
producer
-
>
width
(
)
producer
-
>
height
(
)
std
:
:
move
(
iter
)
dst
)
;
}
void
SkGpuDevice
:
:
drawImageLattice
(
const
SkImage
*
image
const
SkCanvas
:
:
Lattice
&
lattice
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
&
pinnedUniqueID
)
)
{
CHECK_SHOULD_DRAW
(
)
;
GrTextureAdjuster
adjuster
(
this
-
>
context
(
)
std
:
:
move
(
proxy
)
image
-
>
alphaType
(
)
image
-
>
bounds
(
)
pinnedUniqueID
as_IB
(
image
)
-
>
onImageInfo
(
)
.
colorSpace
(
)
)
;
this
-
>
drawProducerLattice
(
&
adjuster
lattice
dst
paint
)
;
}
else
{
SkBitmap
bm
;
if
(
SkImageCacherator
*
cacher
=
as_IB
(
image
)
-
>
peekCacherator
(
)
)
{
GrImageTextureMaker
maker
(
fContext
.
get
(
)
cacher
image
SkImage
:
:
kAllow_CachingHint
)
;
this
-
>
drawProducerLattice
(
&
maker
lattice
dst
paint
)
;
}
else
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
{
this
-
>
drawBitmapLattice
(
bm
lattice
dst
paint
)
;
}
}
}
void
SkGpuDevice
:
:
drawBitmapLattice
(
const
SkBitmap
&
bitmap
const
SkCanvas
:
:
Lattice
&
lattice
const
SkRect
&
dst
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bitmap
)
;
this
-
>
drawProducerLattice
(
&
maker
lattice
dst
paint
)
;
}
static
bool
init_vertices_paint
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
SkPaint
&
skPaint
const
SkMatrix
&
matrix
SkBlendMode
bmode
bool
hasTexs
bool
hasColors
GrPaint
*
grPaint
)
{
if
(
hasTexs
&
&
skPaint
.
getShader
(
)
)
{
if
(
hasColors
)
{
return
SkPaintToGrPaintWithXfermode
(
context
rtc
skPaint
matrix
bmode
false
grPaint
)
;
}
else
{
return
SkPaintToGrPaint
(
context
rtc
skPaint
matrix
grPaint
)
;
}
}
else
{
if
(
hasColors
)
{
return
SkPaintToGrPaintWithPrimitiveColor
(
context
rtc
skPaint
grPaint
)
;
}
else
{
return
(
!
SkPaintToGrPaintNoShader
(
context
rtc
skPaint
grPaint
)
)
;
}
}
}
void
SkGpuDevice
:
:
wireframeVertices
(
SkVertices
:
:
VertexMode
vmode
int
vertexCount
const
SkPoint
vertices
[
]
SkBlendMode
bmode
const
uint16_t
indices
[
]
int
indexCount
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
wireframeVertices
"
fContext
.
get
(
)
)
;
SkPaint
copy
(
paint
)
;
copy
.
setStyle
(
SkPaint
:
:
kStroke_Style
)
;
copy
.
setStrokeWidth
(
0
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintNoShader
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
copy
&
grPaint
)
)
{
return
;
}
int
triangleCount
=
0
;
int
n
=
(
nullptr
=
=
indices
)
?
vertexCount
:
indexCount
;
switch
(
vmode
)
{
case
SkVertices
:
:
kTriangles_VertexMode
:
triangleCount
=
n
/
3
;
break
;
case
SkVertices
:
:
kTriangleStrip_VertexMode
:
case
SkVertices
:
:
kTriangleFan_VertexMode
:
triangleCount
=
n
-
2
;
break
;
}
VertState
state
(
vertexCount
indices
indexCount
)
;
VertState
:
:
Proc
vertProc
=
state
.
chooseProc
(
vmode
)
;
indexCount
=
triangleCount
*
6
;
std
:
:
unique_ptr
<
uint16_t
[
]
>
lineIndices
(
new
uint16_t
[
indexCount
]
)
;
int
i
=
0
;
while
(
vertProc
(
&
state
)
)
{
lineIndices
[
i
]
=
state
.
f0
;
lineIndices
[
i
+
1
]
=
state
.
f1
;
lineIndices
[
i
+
2
]
=
state
.
f1
;
lineIndices
[
i
+
3
]
=
state
.
f2
;
lineIndices
[
i
+
4
]
=
state
.
f2
;
lineIndices
[
i
+
5
]
=
state
.
f0
;
i
+
=
6
;
}
fRenderTargetContext
-
>
drawVertices
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
kLines_GrPrimitiveType
vertexCount
vertices
nullptr
nullptr
lineIndices
.
get
(
)
indexCount
)
;
}
void
SkGpuDevice
:
:
drawVertices
(
const
SkVertices
*
vertices
SkBlendMode
mode
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawVertices
"
fContext
.
get
(
)
)
;
SkASSERT
(
vertices
)
;
GrPaint
grPaint
;
bool
hasColors
=
vertices
-
>
hasColors
(
)
;
bool
hasTexs
=
vertices
-
>
hasTexCoords
(
)
;
if
(
!
hasTexs
&
&
!
hasColors
)
{
this
-
>
wireframeVertices
(
vertices
-
>
mode
(
)
vertices
-
>
vertexCount
(
)
vertices
-
>
positions
(
)
mode
vertices
-
>
indices
(
)
vertices
-
>
indexCount
(
)
paint
)
;
}
if
(
!
init_vertices_paint
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
paint
this
-
>
ctm
(
)
mode
hasTexs
hasColors
&
grPaint
)
)
{
return
;
}
fRenderTargetContext
-
>
drawVertices
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
sk_ref_sp
(
const_cast
<
SkVertices
*
>
(
vertices
)
)
)
;
}
void
SkGpuDevice
:
:
drawAtlas
(
const
SkImage
*
atlas
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
int
count
SkBlendMode
mode
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
if
(
paint
.
isAntiAlias
(
)
)
{
this
-
>
INHERITED
:
:
drawAtlas
(
atlas
xform
texRect
colors
count
mode
paint
)
;
return
;
}
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawText
"
fContext
.
get
(
)
)
;
SkPaint
p
(
paint
)
;
p
.
setShader
(
atlas
-
>
makeShader
(
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
)
)
;
GrPaint
grPaint
;
if
(
colors
)
{
if
(
!
SkPaintToGrPaintWithXfermode
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
p
this
-
>
ctm
(
)
(
SkBlendMode
)
mode
true
&
grPaint
)
)
{
return
;
}
}
else
{
if
(
!
SkPaintToGrPaint
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
p
this
-
>
ctm
(
)
&
grPaint
)
)
{
return
;
}
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fRenderTargetContext
-
>
drawAtlas
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
this
-
>
ctm
(
)
count
xform
texRect
colors
)
;
}
void
SkGpuDevice
:
:
drawText
(
const
void
*
text
size_t
byteLength
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
CHECK_SHOULD_DRAW
(
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawText
"
fContext
.
get
(
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fRenderTargetContext
-
>
drawText
(
this
-
>
clip
(
)
paint
this
-
>
ctm
(
)
(
const
char
*
)
text
byteLength
x
y
this
-
>
devClipBounds
(
)
)
;
}
void
SkGpuDevice
:
:
drawPosText
(
const
void
*
text
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPos
const
SkPoint
&
offset
const
SkPaint
&
paint
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawPosText
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fRenderTargetContext
-
>
drawPosText
(
this
-
>
clip
(
)
paint
this
-
>
ctm
(
)
(
const
char
*
)
text
byteLength
pos
scalarsPerPos
offset
this
-
>
devClipBounds
(
)
)
;
}
void
SkGpuDevice
:
:
drawTextBlob
(
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
const
SkPaint
&
paint
SkDrawFilter
*
drawFilter
)
{
ASSERT_SINGLE_OWNER
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
SkGpuDevice
"
"
drawTextBlob
"
fContext
.
get
(
)
)
;
CHECK_SHOULD_DRAW
(
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fRenderTargetContext
-
>
drawTextBlob
(
this
-
>
clip
(
)
paint
this
-
>
ctm
(
)
blob
x
y
drawFilter
this
-
>
devClipBounds
(
)
)
;
}
bool
SkGpuDevice
:
:
onShouldDisableLCD
(
const
SkPaint
&
paint
)
const
{
return
GrTextUtils
:
:
ShouldDisableLCD
(
paint
)
;
}
void
SkGpuDevice
:
:
flush
(
)
{
ASSERT_SINGLE_OWNER
fRenderTargetContext
-
>
prepareForExternalIO
(
)
;
}
SkBaseDevice
*
SkGpuDevice
:
:
onCreateDevice
(
const
CreateInfo
&
cinfo
const
SkPaint
*
)
{
ASSERT_SINGLE_OWNER
SkSurfaceProps
props
(
this
-
>
surfaceProps
(
)
.
flags
(
)
cinfo
.
fPixelGeometry
)
;
SkBackingFit
fit
=
kNever_TileUsage
=
=
cinfo
.
fTileUsage
?
SkBackingFit
:
:
kApprox
:
SkBackingFit
:
:
kExact
;
sk_sp
<
GrRenderTargetContext
>
rtc
(
fContext
-
>
makeRenderTargetContext
(
fit
cinfo
.
fInfo
.
width
(
)
cinfo
.
fInfo
.
height
(
)
fRenderTargetContext
-
>
config
(
)
fRenderTargetContext
-
>
refColorSpace
(
)
fRenderTargetContext
-
>
desc
(
)
.
fSampleCnt
kDefault_GrSurfaceOrigin
&
props
)
)
;
if
(
!
rtc
)
{
return
nullptr
;
}
InitContents
init
=
cinfo
.
fInfo
.
isOpaque
(
)
?
kUninit_InitContents
:
kClear_InitContents
;
return
SkGpuDevice
:
:
Make
(
fContext
.
get
(
)
std
:
:
move
(
rtc
)
cinfo
.
fInfo
.
width
(
)
cinfo
.
fInfo
.
height
(
)
init
)
.
release
(
)
;
}
sk_sp
<
SkSurface
>
SkGpuDevice
:
:
makeSurface
(
const
SkImageInfo
&
info
const
SkSurfaceProps
&
props
)
{
ASSERT_SINGLE_OWNER
static
const
SkBudgeted
kBudgeted
=
SkBudgeted
:
:
kNo
;
return
SkSurface
:
:
MakeRenderTarget
(
fContext
.
get
(
)
kBudgeted
info
fRenderTargetContext
-
>
desc
(
)
.
fSampleCnt
fRenderTargetContext
-
>
origin
(
)
&
props
)
;
}
SkImageFilterCache
*
SkGpuDevice
:
:
getImageFilterCache
(
)
{
ASSERT_SINGLE_OWNER
return
SkImageFilterCache
:
:
Create
(
SkImageFilterCache
:
:
kDefaultTransientSize
)
;
}
#
endif
