#
include
"
GrContextThreadSafeProxy
.
h
"
#
include
"
GrContextThreadSafeProxyPriv
.
h
"
#
include
"
GrBaseContextPriv
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrSkSLFPFactoryCache
.
h
"
#
include
"
SkSurface_Gpu
.
h
"
#
include
"
SkSurfaceCharacterization
.
h
"
GrContextThreadSafeProxy
:
:
GrContextThreadSafeProxy
(
GrBackendApi
backend
const
GrContextOptions
&
options
uint32_t
contextID
)
:
INHERITED
(
backend
options
contextID
)
{
}
GrContextThreadSafeProxy
:
:
~
GrContextThreadSafeProxy
(
)
=
default
;
bool
GrContextThreadSafeProxy
:
:
init
(
sk_sp
<
const
GrCaps
>
caps
sk_sp
<
GrSkSLFPFactoryCache
>
FPFactoryCache
)
{
return
INHERITED
:
:
init
(
std
:
:
move
(
caps
)
std
:
:
move
(
FPFactoryCache
)
)
;
}
SkSurfaceCharacterization
GrContextThreadSafeProxy
:
:
createCharacterization
(
size_t
cacheMaxResourceBytes
const
SkImageInfo
&
ii
const
GrBackendFormat
&
backendFormat
int
sampleCnt
GrSurfaceOrigin
origin
const
SkSurfaceProps
&
surfaceProps
bool
isMipMapped
bool
willUseGLFBO0
bool
isTextureable
)
{
if
(
!
backendFormat
.
isValid
(
)
)
{
return
SkSurfaceCharacterization
(
)
;
}
if
(
GrBackendApi
:
:
kOpenGL
!
=
backendFormat
.
backend
(
)
&
&
willUseGLFBO0
)
{
return
SkSurfaceCharacterization
(
)
;
}
if
(
!
this
-
>
caps
(
)
-
>
mipMapSupport
(
)
)
{
isMipMapped
=
false
;
}
GrPixelConfig
config
=
this
-
>
caps
(
)
-
>
getConfigFromBackendFormat
(
backendFormat
ii
.
colorType
(
)
)
;
if
(
config
=
=
kUnknown_GrPixelConfig
)
{
return
SkSurfaceCharacterization
(
)
;
}
if
(
!
SkSurface_Gpu
:
:
Valid
(
this
-
>
caps
(
)
config
ii
.
colorSpace
(
)
)
)
{
return
SkSurfaceCharacterization
(
)
;
}
sampleCnt
=
this
-
>
caps
(
)
-
>
getRenderTargetSampleCount
(
sampleCnt
config
)
;
if
(
!
sampleCnt
)
{
return
SkSurfaceCharacterization
(
)
;
}
GrFSAAType
FSAAType
=
GrFSAAType
:
:
kNone
;
if
(
sampleCnt
>
1
)
{
FSAAType
=
this
-
>
caps
(
)
-
>
usesMixedSamples
(
)
?
GrFSAAType
:
:
kMixedSamples
:
GrFSAAType
:
:
kUnifiedMSAA
;
}
if
(
willUseGLFBO0
&
&
isTextureable
)
{
return
SkSurfaceCharacterization
(
)
;
}
if
(
isTextureable
&
&
!
this
-
>
caps
(
)
-
>
isConfigTexturable
(
config
)
)
{
return
SkSurfaceCharacterization
(
)
;
}
return
SkSurfaceCharacterization
(
sk_ref_sp
<
GrContextThreadSafeProxy
>
(
this
)
cacheMaxResourceBytes
ii
origin
config
FSAAType
sampleCnt
SkSurfaceCharacterization
:
:
Textureable
(
isTextureable
)
SkSurfaceCharacterization
:
:
MipMapped
(
isMipMapped
)
SkSurfaceCharacterization
:
:
UsesGLFBO0
(
willUseGLFBO0
)
SkSurfaceCharacterization
:
:
VulkanSecondaryCBCompatible
(
false
)
surfaceProps
)
;
}
sk_sp
<
GrSkSLFPFactoryCache
>
GrContextThreadSafeProxyPriv
:
:
fpFactoryCache
(
)
{
return
fProxy
-
>
fpFactoryCache
(
)
;
}
sk_sp
<
GrContextThreadSafeProxy
>
GrContextThreadSafeProxyPriv
:
:
Make
(
GrBackendApi
backend
const
GrContextOptions
&
options
uint32_t
contextID
sk_sp
<
const
GrCaps
>
caps
sk_sp
<
GrSkSLFPFactoryCache
>
cache
)
{
sk_sp
<
GrContextThreadSafeProxy
>
proxy
(
new
GrContextThreadSafeProxy
(
backend
options
contextID
)
)
;
if
(
!
proxy
-
>
init
(
std
:
:
move
(
caps
)
std
:
:
move
(
cache
)
)
)
{
return
nullptr
;
}
return
proxy
;
}
