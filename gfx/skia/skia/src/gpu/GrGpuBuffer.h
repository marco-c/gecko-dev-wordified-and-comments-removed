#
ifndef
GrGpuBuffer_DEFINED
#
define
GrGpuBuffer_DEFINED
#
include
"
GrBuffer
.
h
"
#
include
"
GrGpuResource
.
h
"
class
GrGpu
;
class
GrGpuBuffer
:
public
GrGpuResource
public
GrBuffer
{
public
:
static
void
ComputeScratchKeyForDynamicVBO
(
size_t
size
GrGpuBufferType
GrScratchKey
*
)
;
GrAccessPattern
accessPattern
(
)
const
{
return
fAccessPattern
;
}
size_t
size
(
)
const
final
{
return
fSizeInBytes
;
}
void
ref
(
)
const
final
{
GrGpuResource
:
:
ref
(
)
;
}
void
unref
(
)
const
final
{
GrGpuResource
:
:
unref
(
)
;
}
void
*
map
(
)
{
if
(
!
fMapPtr
)
{
this
-
>
onMap
(
)
;
}
return
fMapPtr
;
}
void
unmap
(
)
{
SkASSERT
(
fMapPtr
)
;
this
-
>
onUnmap
(
)
;
fMapPtr
=
nullptr
;
}
bool
isMapped
(
)
const
{
return
SkToBool
(
fMapPtr
)
;
}
bool
isCpuBuffer
(
)
const
final
{
return
false
;
}
bool
updateData
(
const
void
*
src
size_t
srcSizeInBytes
)
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
SkASSERT
(
srcSizeInBytes
<
=
fSizeInBytes
)
;
return
this
-
>
onUpdateData
(
src
srcSizeInBytes
)
;
}
protected
:
GrGpuBuffer
(
GrGpu
*
size_t
sizeInBytes
GrGpuBufferType
GrAccessPattern
)
;
GrGpuBufferType
intendedType
(
)
const
{
return
fIntendedType
;
}
void
*
fMapPtr
;
private
:
virtual
void
onMap
(
)
=
0
;
virtual
void
onUnmap
(
)
=
0
;
virtual
bool
onUpdateData
(
const
void
*
src
size_t
srcSizeInBytes
)
=
0
;
size_t
onGpuMemorySize
(
)
const
override
{
return
fSizeInBytes
;
}
const
char
*
getResourceType
(
)
const
override
{
return
"
Buffer
Object
"
;
}
void
computeScratchKey
(
GrScratchKey
*
key
)
const
override
;
size_t
fSizeInBytes
;
GrAccessPattern
fAccessPattern
;
GrGpuBufferType
fIntendedType
;
}
;
#
endif
