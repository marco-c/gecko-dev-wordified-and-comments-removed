#
ifndef
GrPrimitiveProcessor_DEFINED
#
define
GrPrimitiveProcessor_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrProxyRef
.
h
"
#
include
"
GrShaderVar
.
h
"
class
GrCoordTransform
;
class
GrGLSLPrimitiveProcessor
;
class
GrPrimitiveProcessor
:
public
GrProcessor
public
GrNonAtomicRef
<
GrPrimitiveProcessor
>
{
public
:
class
TextureSampler
;
class
Attribute
{
public
:
constexpr
Attribute
(
)
=
default
;
constexpr
Attribute
(
const
char
*
name
GrVertexAttribType
cpuType
GrSLType
gpuType
)
:
fName
(
name
)
fCPUType
(
cpuType
)
fGPUType
(
gpuType
)
{
}
constexpr
Attribute
(
const
Attribute
&
)
=
default
;
Attribute
&
operator
=
(
const
Attribute
&
)
=
default
;
constexpr
bool
isInitialized
(
)
const
{
return
SkToBool
(
fName
)
;
}
constexpr
const
char
*
name
(
)
const
{
return
fName
;
}
constexpr
GrVertexAttribType
cpuType
(
)
const
{
return
fCPUType
;
}
constexpr
GrSLType
gpuType
(
)
const
{
return
fGPUType
;
}
inline
constexpr
size_t
size
(
)
const
;
constexpr
size_t
sizeAlign4
(
)
const
{
return
SkAlign4
(
this
-
>
size
(
)
)
;
}
GrShaderVar
asShaderVar
(
)
const
{
return
{
fName
fGPUType
GrShaderVar
:
:
kIn_TypeModifier
}
;
}
private
:
const
char
*
fName
=
nullptr
;
GrVertexAttribType
fCPUType
=
kFloat_GrVertexAttribType
;
GrSLType
fGPUType
=
kFloat_GrSLType
;
}
;
class
Iter
{
public
:
Iter
(
)
:
fCurr
(
nullptr
)
fRemaining
(
0
)
{
}
Iter
(
const
Iter
&
iter
)
:
fCurr
(
iter
.
fCurr
)
fRemaining
(
iter
.
fRemaining
)
{
}
Iter
&
operator
=
(
const
Iter
&
iter
)
{
fCurr
=
iter
.
fCurr
;
fRemaining
=
iter
.
fRemaining
;
return
*
this
;
}
Iter
(
const
Attribute
*
attrs
int
count
)
:
fCurr
(
attrs
)
fRemaining
(
count
)
{
this
-
>
skipUninitialized
(
)
;
}
bool
operator
!
=
(
const
Iter
&
that
)
const
{
return
fCurr
!
=
that
.
fCurr
;
}
const
Attribute
&
operator
*
(
)
const
{
return
*
fCurr
;
}
void
operator
+
+
(
)
{
if
(
fRemaining
)
{
fRemaining
-
-
;
fCurr
+
+
;
this
-
>
skipUninitialized
(
)
;
}
}
private
:
void
skipUninitialized
(
)
{
if
(
!
fRemaining
)
{
fCurr
=
nullptr
;
}
else
{
while
(
!
fCurr
-
>
isInitialized
(
)
)
{
+
+
fCurr
;
}
}
}
const
Attribute
*
fCurr
;
int
fRemaining
;
}
;
class
AttributeSet
{
public
:
Iter
begin
(
)
const
{
return
Iter
(
fAttributes
fCount
)
;
}
Iter
end
(
)
const
{
return
Iter
(
)
;
}
private
:
friend
class
GrPrimitiveProcessor
;
void
init
(
const
Attribute
*
attrs
int
count
)
{
fAttributes
=
attrs
;
fRawCount
=
count
;
fCount
=
0
;
fStride
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
attrs
[
i
]
.
isInitialized
(
)
)
{
fCount
+
+
;
fStride
+
=
attrs
[
i
]
.
sizeAlign4
(
)
;
}
}
}
const
Attribute
*
fAttributes
=
nullptr
;
int
fRawCount
=
0
;
int
fCount
=
0
;
size_t
fStride
=
0
;
}
;
GrPrimitiveProcessor
(
ClassID
)
;
int
numTextureSamplers
(
)
const
{
return
fTextureSamplerCnt
;
}
const
TextureSampler
&
textureSampler
(
int
index
)
const
;
int
numVertexAttributes
(
)
const
{
return
fVertexAttributes
.
fCount
;
}
const
AttributeSet
&
vertexAttributes
(
)
const
{
return
fVertexAttributes
;
}
int
numInstanceAttributes
(
)
const
{
return
fInstanceAttributes
.
fCount
;
}
const
AttributeSet
&
instanceAttributes
(
)
const
{
return
fInstanceAttributes
;
}
bool
hasVertexAttributes
(
)
const
{
return
SkToBool
(
fVertexAttributes
.
fCount
)
;
}
bool
hasInstanceAttributes
(
)
const
{
return
SkToBool
(
fInstanceAttributes
.
fCount
)
;
}
size_t
vertexStride
(
)
const
{
return
fVertexAttributes
.
fStride
;
}
size_t
instanceStride
(
)
const
{
return
fInstanceAttributes
.
fStride
;
}
virtual
bool
willUseGeoShader
(
)
const
=
0
;
uint32_t
getTransformKey
(
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
coords
int
numCoords
)
const
;
virtual
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
=
0
;
void
getAttributeKey
(
GrProcessorKeyBuilder
*
b
)
const
{
static_assert
(
kGrVertexAttribTypeCount
<
(
1
<
<
8
)
"
"
)
;
static_assert
(
kGrSLTypeCount
<
(
1
<
<
8
)
"
"
)
;
auto
add_attributes
=
[
=
]
(
const
Attribute
*
attrs
int
attrCount
)
{
for
(
int
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
b
-
>
add32
(
attrs
[
i
]
.
isInitialized
(
)
?
(
attrs
[
i
]
.
cpuType
(
)
<
<
16
)
|
attrs
[
i
]
.
gpuType
(
)
:
~
0
)
;
}
}
;
add_attributes
(
fVertexAttributes
.
fAttributes
fVertexAttributes
.
fRawCount
)
;
add_attributes
(
fInstanceAttributes
.
fAttributes
fInstanceAttributes
.
fRawCount
)
;
}
virtual
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrShaderCaps
&
)
const
=
0
;
virtual
bool
isPathRendering
(
)
const
{
return
false
;
}
protected
:
void
setVertexAttributes
(
const
Attribute
*
attrs
int
attrCount
)
{
fVertexAttributes
.
init
(
attrs
attrCount
)
;
}
void
setInstanceAttributes
(
const
Attribute
*
attrs
int
attrCount
)
{
SkASSERT
(
attrCount
>
=
0
)
;
fInstanceAttributes
.
init
(
attrs
attrCount
)
;
}
void
setTextureSamplerCnt
(
int
cnt
)
{
SkASSERT
(
cnt
>
=
0
)
;
fTextureSamplerCnt
=
cnt
;
}
template
<
typename
.
.
.
Args
>
static
const
TextureSampler
&
IthTextureSampler
(
int
i
const
TextureSampler
&
samp0
const
Args
&
.
.
.
samps
)
{
return
(
0
=
=
i
)
?
samp0
:
IthTextureSampler
(
i
-
1
samps
.
.
.
)
;
}
inline
static
const
TextureSampler
&
IthTextureSampler
(
int
i
)
;
private
:
virtual
const
TextureSampler
&
onTextureSampler
(
int
)
const
{
return
IthTextureSampler
(
0
)
;
}
AttributeSet
fVertexAttributes
;
AttributeSet
fInstanceAttributes
;
int
fTextureSamplerCnt
=
0
;
typedef
GrProcessor
INHERITED
;
}
;
class
GrPrimitiveProcessor
:
:
TextureSampler
{
public
:
TextureSampler
(
)
=
default
;
TextureSampler
(
GrTextureType
GrPixelConfig
const
GrSamplerState
&
uint32_t
extraSamplerKey
)
;
explicit
TextureSampler
(
GrTextureType
GrPixelConfig
GrSamplerState
:
:
Filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
GrSamplerState
:
:
WrapMode
wrapXAndY
=
GrSamplerState
:
:
WrapMode
:
:
kClamp
)
;
TextureSampler
(
const
TextureSampler
&
)
=
delete
;
TextureSampler
&
operator
=
(
const
TextureSampler
&
)
=
delete
;
void
reset
(
GrTextureType
GrPixelConfig
const
GrSamplerState
&
uint32_t
extraSamplerKey
=
0
)
;
void
reset
(
GrTextureType
GrPixelConfig
GrSamplerState
:
:
Filter
GrSamplerState
:
:
WrapMode
wrapXAndY
)
;
GrTextureType
textureType
(
)
const
{
return
fTextureType
;
}
GrPixelConfig
config
(
)
const
{
return
fConfig
;
}
const
GrSamplerState
&
samplerState
(
)
const
{
return
fSamplerState
;
}
uint32_t
extraSamplerKey
(
)
const
{
return
fExtraSamplerKey
;
}
bool
isInitialized
(
)
const
{
return
fConfig
!
=
kUnknown_GrPixelConfig
;
}
private
:
GrSamplerState
fSamplerState
;
GrTextureType
fTextureType
=
GrTextureType
:
:
k2D
;
GrPixelConfig
fConfig
=
kUnknown_GrPixelConfig
;
uint32_t
fExtraSamplerKey
=
0
;
}
;
const
GrPrimitiveProcessor
:
:
TextureSampler
&
GrPrimitiveProcessor
:
:
IthTextureSampler
(
int
i
)
{
SK_ABORT
(
"
Illegal
texture
sampler
index
"
)
;
static
const
TextureSampler
kBogus
;
return
kBogus
;
}
static
constexpr
inline
size_t
GrVertexAttribTypeSize
(
GrVertexAttribType
type
)
{
switch
(
type
)
{
case
kFloat_GrVertexAttribType
:
return
sizeof
(
float
)
;
case
kFloat2_GrVertexAttribType
:
return
2
*
sizeof
(
float
)
;
case
kFloat3_GrVertexAttribType
:
return
3
*
sizeof
(
float
)
;
case
kFloat4_GrVertexAttribType
:
return
4
*
sizeof
(
float
)
;
case
kHalf_GrVertexAttribType
:
return
sizeof
(
uint16_t
)
;
case
kHalf2_GrVertexAttribType
:
return
2
*
sizeof
(
uint16_t
)
;
case
kHalf3_GrVertexAttribType
:
return
3
*
sizeof
(
uint16_t
)
;
case
kHalf4_GrVertexAttribType
:
return
4
*
sizeof
(
uint16_t
)
;
case
kInt2_GrVertexAttribType
:
return
2
*
sizeof
(
int32_t
)
;
case
kInt3_GrVertexAttribType
:
return
3
*
sizeof
(
int32_t
)
;
case
kInt4_GrVertexAttribType
:
return
4
*
sizeof
(
int32_t
)
;
case
kByte_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kByte2_GrVertexAttribType
:
return
2
*
sizeof
(
char
)
;
case
kByte3_GrVertexAttribType
:
return
3
*
sizeof
(
char
)
;
case
kByte4_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kUByte_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kUByte2_GrVertexAttribType
:
return
2
*
sizeof
(
char
)
;
case
kUByte3_GrVertexAttribType
:
return
3
*
sizeof
(
char
)
;
case
kUByte4_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kUByte_norm_GrVertexAttribType
:
return
1
*
sizeof
(
char
)
;
case
kUByte4_norm_GrVertexAttribType
:
return
4
*
sizeof
(
char
)
;
case
kShort2_GrVertexAttribType
:
return
2
*
sizeof
(
int16_t
)
;
case
kShort4_GrVertexAttribType
:
return
4
*
sizeof
(
int16_t
)
;
case
kUShort2_GrVertexAttribType
:
case
kUShort2_norm_GrVertexAttribType
:
return
2
*
sizeof
(
uint16_t
)
;
case
kInt_GrVertexAttribType
:
return
sizeof
(
int32_t
)
;
case
kUint_GrVertexAttribType
:
return
sizeof
(
uint32_t
)
;
}
#
if
defined
(
__clang__
)
|
|
!
defined
(
__GNUC__
)
SK_ABORT
(
"
Unsupported
type
conversion
"
)
;
#
endif
return
0
;
}
constexpr
size_t
GrPrimitiveProcessor
:
:
Attribute
:
:
size
(
)
const
{
return
GrVertexAttribTypeSize
(
fCPUType
)
;
}
#
endif
