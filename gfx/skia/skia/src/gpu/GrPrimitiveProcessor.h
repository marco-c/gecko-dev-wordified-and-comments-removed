#
ifndef
GrPrimitiveProcessor_DEFINED
#
define
GrPrimitiveProcessor_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrShaderVar
.
h
"
class
GrGLSLCaps
;
class
GrGLSLPrimitiveProcessor
;
struct
GrInitInvariantOutput
;
class
GrXPOverridesForBatch
{
public
:
bool
readsColor
(
)
const
{
return
SkToBool
(
kReadsColor_Flag
&
fFlags
)
;
}
bool
readsCoverage
(
)
const
{
return
SkToBool
(
kReadsCoverage_Flag
&
fFlags
)
;
}
bool
readsLocalCoords
(
)
const
{
return
SkToBool
(
kReadsLocalCoords_Flag
&
fFlags
)
;
}
bool
canTweakAlphaForCoverage
(
)
const
{
return
SkToBool
(
kCanTweakAlphaForCoverage_Flag
&
fFlags
)
;
}
bool
getOverrideColorIfSet
(
GrColor
*
overrideColor
)
const
{
if
(
SkToBool
(
kUseOverrideColor_Flag
&
fFlags
)
)
{
SkASSERT
(
SkToBool
(
kReadsColor_Flag
&
fFlags
)
)
;
if
(
overrideColor
)
{
*
overrideColor
=
fOverrideColor
;
}
return
true
;
}
return
false
;
}
bool
willColorBlendWithDst
(
)
const
{
return
SkToBool
(
kWillColorBlendWithDst_Flag
&
fFlags
)
;
}
private
:
enum
{
kReadsColor_Flag
=
0x1
kReadsCoverage_Flag
=
0x2
kReadsLocalCoords_Flag
=
0x4
kCanTweakAlphaForCoverage_Flag
=
0x8
kUseOverrideColor_Flag
=
0x10
kWillColorBlendWithDst_Flag
=
0x20
}
;
uint32_t
fFlags
;
GrColor
fOverrideColor
;
friend
class
GrPipeline
;
}
;
class
GrPrimitiveProcessor
:
public
GrProcessor
{
public
:
virtual
bool
willUseGeoShader
(
)
const
=
0
;
static
const
int
kMaxVertexAttribs
=
6
;
struct
Attribute
{
Attribute
(
)
:
fName
(
nullptr
)
fType
(
kFloat_GrVertexAttribType
)
fOffset
(
0
)
{
}
Attribute
(
const
char
*
name
GrVertexAttribType
type
GrSLPrecision
precision
=
kDefault_GrSLPrecision
)
:
fName
(
name
)
fType
(
type
)
fOffset
(
SkAlign4
(
GrVertexAttribTypeSize
(
type
)
)
)
fPrecision
(
precision
)
{
}
const
char
*
fName
;
GrVertexAttribType
fType
;
size_t
fOffset
;
GrSLPrecision
fPrecision
;
}
;
int
numAttribs
(
)
const
{
return
fNumAttribs
;
}
const
Attribute
&
getAttrib
(
int
index
)
const
{
SkASSERT
(
index
<
fNumAttribs
)
;
return
fAttribs
[
index
]
;
}
size_t
getVertexStride
(
)
const
{
return
fVertexStride
;
}
uint32_t
getTransformKey
(
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
coords
int
numCoords
)
const
;
virtual
void
getGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
=
0
;
virtual
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrGLSLCaps
&
caps
)
const
=
0
;
bool
isPathRendering
(
)
const
{
return
fIsPathRendering
;
}
virtual
bool
hasTransformedLocalCoords
(
)
const
=
0
;
protected
:
GrPrimitiveProcessor
(
bool
isPathRendering
)
:
fNumAttribs
(
0
)
fVertexStride
(
0
)
fIsPathRendering
(
isPathRendering
)
{
}
Attribute
fAttribs
[
kMaxVertexAttribs
]
;
int
fNumAttribs
;
size_t
fVertexStride
;
private
:
void
notifyRefCntIsZero
(
)
const
final
{
}
;
virtual
bool
hasExplicitLocalCoords
(
)
const
=
0
;
bool
fIsPathRendering
;
typedef
GrProcessor
INHERITED
;
}
;
#
endif
