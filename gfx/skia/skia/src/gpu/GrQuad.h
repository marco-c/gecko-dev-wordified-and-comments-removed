#
ifndef
GrQuad_DEFINED
#
define
GrQuad_DEFINED
#
include
"
SkMatrix
.
h
"
#
include
"
SkNx
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkPoint3
.
h
"
#
include
"
SkTArray
.
h
"
enum
class
GrAAType
:
unsigned
;
enum
class
GrQuadAAFlags
;
enum
class
GrQuadType
{
kRect
kRectilinear
kStandard
kPerspective
kLast
=
kPerspective
}
;
static
const
int
kGrQuadTypeCount
=
static_cast
<
int
>
(
GrQuadType
:
:
kLast
)
+
1
;
GrQuadType
GrQuadTypeForTransformedRect
(
const
SkMatrix
&
matrix
)
;
template
<
typename
Q
>
void
GrResolveAATypeForQuad
(
GrAAType
requestedAAType
GrQuadAAFlags
requestedEdgeFlags
const
Q
&
quad
GrQuadType
knownQuadType
GrAAType
*
outAAtype
GrQuadAAFlags
*
outEdgeFlags
)
;
class
GrQuad
{
public
:
GrQuad
(
)
=
default
;
GrQuad
(
const
GrQuad
&
that
)
=
default
;
explicit
GrQuad
(
const
SkRect
&
rect
)
:
fX
{
rect
.
fLeft
rect
.
fLeft
rect
.
fRight
rect
.
fRight
}
fY
{
rect
.
fTop
rect
.
fBottom
rect
.
fTop
rect
.
fBottom
}
{
}
GrQuad
(
const
Sk4f
&
xs
const
Sk4f
&
ys
)
{
xs
.
store
(
fX
)
;
ys
.
store
(
fY
)
;
}
explicit
GrQuad
(
const
SkPoint
pts
[
4
]
)
:
fX
{
pts
[
0
]
.
fX
pts
[
1
]
.
fX
pts
[
2
]
.
fX
pts
[
3
]
.
fX
}
fY
{
pts
[
0
]
.
fY
pts
[
1
]
.
fY
pts
[
2
]
.
fY
pts
[
3
]
.
fY
}
{
}
static
GrQuad
MakeFromRect
(
const
SkRect
&
const
SkMatrix
&
)
;
static
GrQuad
MakeFromSkQuad
(
const
SkPoint
pts
[
4
]
const
SkMatrix
&
)
;
GrQuad
&
operator
=
(
const
GrQuad
&
that
)
=
default
;
SkPoint
point
(
int
i
)
const
{
return
{
fX
[
i
]
fY
[
i
]
}
;
}
SkRect
bounds
(
)
const
{
auto
x
=
this
-
>
x4f
(
)
y
=
this
-
>
y4f
(
)
;
return
{
x
.
min
(
)
y
.
min
(
)
x
.
max
(
)
y
.
max
(
)
}
;
}
float
x
(
int
i
)
const
{
return
fX
[
i
]
;
}
float
y
(
int
i
)
const
{
return
fY
[
i
]
;
}
Sk4f
x4f
(
)
const
{
return
Sk4f
:
:
Load
(
fX
)
;
}
Sk4f
y4f
(
)
const
{
return
Sk4f
:
:
Load
(
fY
)
;
}
bool
aaHasEffectOnRect
(
)
const
;
#
ifdef
SK_DEBUG
GrQuadType
quadType
(
)
const
;
#
endif
private
:
template
<
typename
T
>
friend
class
GrQuadListBase
;
float
fX
[
4
]
;
float
fY
[
4
]
;
}
;
class
GrPerspQuad
{
public
:
GrPerspQuad
(
)
=
default
;
explicit
GrPerspQuad
(
const
SkRect
&
rect
)
:
fX
{
rect
.
fLeft
rect
.
fLeft
rect
.
fRight
rect
.
fRight
}
fY
{
rect
.
fTop
rect
.
fBottom
rect
.
fTop
rect
.
fBottom
}
fW
{
1
.
f
1
.
f
1
.
f
1
.
f
}
{
}
GrPerspQuad
(
const
Sk4f
&
xs
const
Sk4f
&
ys
)
{
xs
.
store
(
fX
)
;
ys
.
store
(
fY
)
;
fW
[
0
]
=
fW
[
1
]
=
fW
[
2
]
=
fW
[
3
]
=
1
.
f
;
}
GrPerspQuad
(
const
Sk4f
&
xs
const
Sk4f
&
ys
const
Sk4f
&
ws
)
{
xs
.
store
(
fX
)
;
ys
.
store
(
fY
)
;
ws
.
store
(
fW
)
;
}
static
GrPerspQuad
MakeFromRect
(
const
SkRect
&
const
SkMatrix
&
)
;
static
GrPerspQuad
MakeFromSkQuad
(
const
SkPoint
pts
[
4
]
const
SkMatrix
&
)
;
GrPerspQuad
&
operator
=
(
const
GrPerspQuad
&
)
=
default
;
SkPoint3
point
(
int
i
)
const
{
return
{
fX
[
i
]
fY
[
i
]
fW
[
i
]
}
;
}
SkRect
bounds
(
GrQuadType
type
)
const
{
SkASSERT
(
this
-
>
quadType
(
)
<
=
type
)
;
Sk4f
x
=
this
-
>
x4f
(
)
;
Sk4f
y
=
this
-
>
y4f
(
)
;
if
(
type
=
=
GrQuadType
:
:
kPerspective
)
{
Sk4f
iw
=
this
-
>
iw4f
(
)
;
x
*
=
iw
;
y
*
=
iw
;
}
return
{
x
.
min
(
)
y
.
min
(
)
x
.
max
(
)
y
.
max
(
)
}
;
}
float
x
(
int
i
)
const
{
return
fX
[
i
]
;
}
float
y
(
int
i
)
const
{
return
fY
[
i
]
;
}
float
w
(
int
i
)
const
{
return
fW
[
i
]
;
}
float
iw
(
int
i
)
const
{
return
sk_ieee_float_divide
(
1
.
f
fW
[
i
]
)
;
}
Sk4f
x4f
(
)
const
{
return
Sk4f
:
:
Load
(
fX
)
;
}
Sk4f
y4f
(
)
const
{
return
Sk4f
:
:
Load
(
fY
)
;
}
Sk4f
w4f
(
)
const
{
return
Sk4f
:
:
Load
(
fW
)
;
}
Sk4f
iw4f
(
)
const
{
return
this
-
>
w4f
(
)
.
invert
(
)
;
}
bool
hasPerspective
(
)
const
{
return
(
w4f
(
)
!
=
Sk4f
(
1
.
f
)
)
.
anyTrue
(
)
;
}
bool
aaHasEffectOnRect
(
)
const
;
#
ifdef
SK_DEBUG
GrQuadType
quadType
(
)
const
;
#
endif
private
:
template
<
typename
T
>
friend
class
GrQuadListBase
;
GrPerspQuad
(
const
float
xs
[
4
]
const
float
ys
[
4
]
const
float
ws
[
4
]
)
;
float
fX
[
4
]
;
float
fY
[
4
]
;
float
fW
[
4
]
;
}
;
template
<
typename
T
>
struct
QuadData
{
float
fX
[
4
]
;
float
fY
[
4
]
;
T
fMetadata
;
}
;
template
<
>
struct
QuadData
<
void
>
{
float
fX
[
4
]
;
float
fY
[
4
]
;
}
;
template
<
typename
T
>
class
GrQuadListBase
{
public
:
int
count
(
)
const
{
return
fXYs
.
count
(
)
;
}
GrQuadType
quadType
(
)
const
{
return
fType
;
}
void
reserve
(
int
count
GrQuadType
forType
)
{
fXYs
.
reserve
(
count
)
;
if
(
forType
=
=
GrQuadType
:
:
kPerspective
|
|
fType
=
=
GrQuadType
:
:
kPerspective
)
{
fWs
.
reserve
(
4
*
count
)
;
}
}
GrPerspQuad
operator
[
]
(
int
i
)
const
{
SkASSERT
(
i
<
this
-
>
count
(
)
)
;
SkASSERT
(
i
>
=
0
)
;
const
QuadData
<
T
>
&
item
=
fXYs
[
i
]
;
if
(
fType
=
=
GrQuadType
:
:
kPerspective
)
{
return
GrPerspQuad
(
item
.
fX
item
.
fY
fWs
.
begin
(
)
+
4
*
i
)
;
}
else
{
static
constexpr
float
kNoPerspectiveWs
[
4
]
=
{
1
.
f
1
.
f
1
.
f
1
.
f
}
;
return
GrPerspQuad
(
item
.
fX
item
.
fY
kNoPerspectiveWs
)
;
}
}
protected
:
GrQuadListBase
(
)
:
fType
(
GrQuadType
:
:
kRect
)
{
}
void
concatImpl
(
const
GrQuadListBase
<
T
>
&
that
)
{
this
-
>
upgradeType
(
that
.
fType
)
;
fXYs
.
push_back_n
(
that
.
fXYs
.
count
(
)
that
.
fXYs
.
begin
(
)
)
;
if
(
fType
=
=
GrQuadType
:
:
kPerspective
)
{
if
(
that
.
fType
=
=
GrQuadType
:
:
kPerspective
)
{
fWs
.
push_back_n
(
that
.
fWs
.
count
(
)
that
.
fWs
.
begin
(
)
)
;
}
else
{
fWs
.
push_back_n
(
4
*
that
.
count
(
)
1
.
f
)
;
}
}
}
QuadData
<
T
>
&
pushBackImpl
(
const
GrQuad
&
quad
GrQuadType
type
)
{
SkASSERT
(
quad
.
quadType
(
)
<
=
type
)
;
this
-
>
upgradeType
(
type
)
;
QuadData
<
T
>
&
item
=
fXYs
.
push_back
(
)
;
memcpy
(
item
.
fX
quad
.
fX
4
*
sizeof
(
float
)
)
;
memcpy
(
item
.
fY
quad
.
fY
4
*
sizeof
(
float
)
)
;
if
(
fType
=
=
GrQuadType
:
:
kPerspective
)
{
fWs
.
push_back_n
(
4
1
.
f
)
;
}
return
item
;
}
QuadData
<
T
>
&
pushBackImpl
(
const
GrPerspQuad
&
quad
GrQuadType
type
)
{
SkASSERT
(
quad
.
quadType
(
)
<
=
type
)
;
this
-
>
upgradeType
(
type
)
;
QuadData
<
T
>
&
item
=
fXYs
.
push_back
(
)
;
memcpy
(
item
.
fX
quad
.
fX
4
*
sizeof
(
float
)
)
;
memcpy
(
item
.
fY
quad
.
fY
4
*
sizeof
(
float
)
)
;
if
(
fType
=
=
GrQuadType
:
:
kPerspective
)
{
fWs
.
push_back_n
(
4
quad
.
fW
)
;
}
return
item
;
}
const
QuadData
<
T
>
&
item
(
int
i
)
const
{
return
fXYs
[
i
]
;
}
QuadData
<
T
>
&
item
(
int
i
)
{
return
fXYs
[
i
]
;
}
private
:
void
upgradeType
(
GrQuadType
type
)
{
if
(
type
>
fType
)
{
fType
=
type
;
if
(
type
=
=
GrQuadType
:
:
kPerspective
)
{
fWs
.
push_back_n
(
4
*
this
-
>
count
(
)
1
.
f
)
;
}
}
}
SkSTArray
<
1
QuadData
<
T
>
true
>
fXYs
;
SkTArray
<
float
true
>
fWs
;
GrQuadType
fType
;
}
;
class
GrQuadList
:
public
GrQuadListBase
<
void
>
{
public
:
GrQuadList
(
)
:
INHERITED
(
)
{
}
void
concat
(
const
GrQuadList
&
that
)
{
this
-
>
concatImpl
(
that
)
;
}
void
push_back
(
const
GrQuad
&
quad
GrQuadType
type
)
{
this
-
>
pushBackImpl
(
quad
type
)
;
}
void
push_back
(
const
GrPerspQuad
&
quad
GrQuadType
type
)
{
this
-
>
pushBackImpl
(
quad
type
)
;
}
private
:
typedef
GrQuadListBase
<
void
>
INHERITED
;
}
;
template
<
typename
T
>
class
GrTQuadList
:
public
GrQuadListBase
<
T
>
{
public
:
GrTQuadList
(
)
:
INHERITED
(
)
{
}
void
concat
(
const
GrTQuadList
<
T
>
&
that
)
{
this
-
>
concatImpl
(
that
)
;
}
void
push_back
(
const
GrQuad
&
quad
GrQuadType
type
T
&
&
metadata
)
{
QuadData
<
T
>
&
item
=
this
-
>
pushBackImpl
(
quad
type
)
;
item
.
fMetadata
=
std
:
:
move
(
metadata
)
;
}
void
push_back
(
const
GrPerspQuad
&
quad
GrQuadType
type
T
&
&
metadata
)
{
QuadData
<
T
>
&
item
=
this
-
>
pushBackImpl
(
quad
type
)
;
item
.
fMetadata
=
std
:
:
move
(
metadata
)
;
}
const
T
&
metadata
(
int
i
)
const
{
return
this
-
>
item
(
i
)
.
fMetadata
;
}
T
&
metadata
(
int
i
)
{
return
this
-
>
item
(
i
)
.
fMetadata
;
}
private
:
typedef
GrQuadListBase
<
T
>
INHERITED
;
}
;
#
endif
