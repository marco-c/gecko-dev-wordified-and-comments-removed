#
ifndef
GrCCPerFlushResources_DEFINED
#
define
GrCCPerFlushResources_DEFINED
#
include
"
src
/
gpu
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCAtlas
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCFiller
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCPathProcessor
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCStroker
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrStencilAtlasOp
.
h
"
class
GrCCPathCache
;
class
GrCCPathCacheEntry
;
class
GrOctoBounds
;
class
GrOnFlushResourceProvider
;
class
GrShape
;
struct
GrCCRenderedPathStats
{
int
fMaxPointsPerPath
=
0
;
int
fNumTotalSkPoints
=
0
;
int
fNumTotalSkVerbs
=
0
;
int
fNumTotalConicWeights
=
0
;
void
statPath
(
const
SkPath
&
)
;
}
;
struct
GrCCPerFlushResourceSpecs
{
static
constexpr
int
kFillIdx
=
0
;
static
constexpr
int
kStrokeIdx
=
1
;
int
fNumCachedPaths
=
0
;
int
fNumCopiedPaths
[
2
]
=
{
0
0
}
;
GrCCRenderedPathStats
fCopyPathStats
[
2
]
;
GrCCAtlas
:
:
Specs
fCopyAtlasSpecs
;
int
fNumRenderedPaths
[
2
]
=
{
0
0
}
;
int
fNumClipPaths
=
0
;
GrCCRenderedPathStats
fRenderedPathStats
[
2
]
;
GrCCAtlas
:
:
Specs
fRenderedAtlasSpecs
;
bool
isEmpty
(
)
const
{
return
0
=
=
fNumCachedPaths
+
fNumCopiedPaths
[
kFillIdx
]
+
fNumCopiedPaths
[
kStrokeIdx
]
+
fNumRenderedPaths
[
kFillIdx
]
+
fNumRenderedPaths
[
kStrokeIdx
]
+
fNumClipPaths
;
}
void
cancelCopies
(
)
;
}
;
class
GrCCPerFlushResources
:
public
GrNonAtomicRef
<
GrCCPerFlushResources
>
{
public
:
GrCCPerFlushResources
(
GrOnFlushResourceProvider
*
GrCCAtlas
:
:
CoverageType
const
GrCCPerFlushResourceSpecs
&
)
;
bool
isMapped
(
)
const
{
return
SkToBool
(
fPathInstanceData
)
;
}
GrCCAtlas
:
:
CoverageType
renderedPathCoverageType
(
)
const
{
return
fRenderedAtlasStack
.
coverageType
(
)
;
}
void
upgradeEntryToLiteralCoverageAtlas
(
GrCCPathCache
*
GrOnFlushResourceProvider
*
GrCCPathCacheEntry
*
GrFillRule
)
;
GrCCAtlas
*
renderShapeInAtlas
(
const
SkIRect
&
clipIBounds
const
SkMatrix
&
const
GrShape
&
float
strokeDevWidth
GrOctoBounds
*
SkIRect
*
devIBounds
SkIVector
*
devToAtlasOffset
)
;
const
GrCCAtlas
*
renderDeviceSpacePathInAtlas
(
const
SkIRect
&
clipIBounds
const
SkPath
&
devPath
const
SkIRect
&
devPathIBounds
GrFillRule
fillRule
SkIVector
*
devToAtlasOffset
)
;
int
nextPathInstanceIdx
(
)
const
{
return
fNextPathInstanceIdx
;
}
GrCCPathProcessor
:
:
Instance
&
appendDrawPathInstance
(
)
{
SkASSERT
(
this
-
>
isMapped
(
)
)
;
SkASSERT
(
fNextPathInstanceIdx
<
fEndPathInstance
)
;
return
fPathInstanceData
[
fNextPathInstanceIdx
+
+
]
;
}
bool
finalize
(
GrOnFlushResourceProvider
*
)
;
const
GrCCFiller
&
filler
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fFiller
;
}
const
GrCCStroker
&
stroker
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fStroker
;
}
sk_sp
<
const
GrGpuBuffer
>
refIndexBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fIndexBuffer
;
}
sk_sp
<
const
GrGpuBuffer
>
refVertexBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fVertexBuffer
;
}
sk_sp
<
const
GrGpuBuffer
>
refInstanceBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fInstanceBuffer
;
}
sk_sp
<
const
GrGpuBuffer
>
refStencilResolveBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fStencilResolveBuffer
;
}
private
:
void
recordCopyPathInstance
(
const
GrCCPathCacheEntry
&
const
SkIVector
&
newAtlasOffset
GrFillRule
sk_sp
<
GrTextureProxy
>
srcProxy
)
;
void
placeRenderedPathInAtlas
(
const
SkIRect
&
clippedPathIBounds
GrScissorTest
SkIVector
*
devToAtlasOffset
)
;
void
recordStencilResolveInstance
(
const
SkIRect
&
clippedPathIBounds
const
SkIVector
&
devToAtlasOffset
GrFillRule
)
;
const
SkAutoSTArray
<
32
SkPoint
>
fLocalDevPtsBuffer
;
GrCCFiller
fFiller
;
GrCCStroker
fStroker
;
GrCCAtlasStack
fCopyAtlasStack
;
GrCCAtlasStack
fRenderedAtlasStack
;
const
sk_sp
<
const
GrGpuBuffer
>
fIndexBuffer
;
const
sk_sp
<
const
GrGpuBuffer
>
fVertexBuffer
;
const
sk_sp
<
GrGpuBuffer
>
fInstanceBuffer
;
GrCCPathProcessor
:
:
Instance
*
fPathInstanceData
=
nullptr
;
int
fNextCopyInstanceIdx
;
SkDEBUGCODE
(
int
fEndCopyInstance
)
;
int
fNextPathInstanceIdx
;
int
fBasePathInstanceIdx
;
SkDEBUGCODE
(
int
fEndPathInstance
)
;
struct
CopyPathRange
{
CopyPathRange
(
)
=
default
;
CopyPathRange
(
sk_sp
<
GrTextureProxy
>
srcProxy
int
count
)
:
fSrcProxy
(
std
:
:
move
(
srcProxy
)
)
fCount
(
count
)
{
}
sk_sp
<
GrTextureProxy
>
fSrcProxy
;
int
fCount
;
}
;
SkSTArray
<
4
CopyPathRange
>
fCopyPathRanges
;
int
fCurrCopyAtlasRangesIdx
=
0
;
SkSTArray
<
2
sk_sp
<
GrTexture
>
>
fRecyclableAtlasTextures
;
sk_sp
<
GrGpuBuffer
>
fStencilResolveBuffer
;
GrStencilAtlasOp
:
:
ResolveRectInstance
*
fStencilResolveInstanceData
=
nullptr
;
int
fNextStencilResolveInstanceIdx
=
0
;
SkDEBUGCODE
(
int
fEndStencilResolveInstance
)
;
public
:
#
ifdef
SK_DEBUG
void
debugOnly_didReuseRenderedPath
(
)
{
if
(
GrCCAtlas
:
:
CoverageType
:
:
kA8_Multisample
=
=
this
-
>
renderedPathCoverageType
(
)
)
{
-
-
fEndStencilResolveInstance
;
}
}
#
endif
const
GrTexture
*
testingOnly_frontCopyAtlasTexture
(
)
const
;
const
GrTexture
*
testingOnly_frontRenderedAtlasTexture
(
)
const
;
}
;
inline
void
GrCCRenderedPathStats
:
:
statPath
(
const
SkPath
&
path
)
{
fMaxPointsPerPath
=
SkTMax
(
fMaxPointsPerPath
path
.
countPoints
(
)
)
;
fNumTotalSkPoints
+
=
path
.
countPoints
(
)
;
fNumTotalSkVerbs
+
=
path
.
countVerbs
(
)
;
fNumTotalConicWeights
+
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
}
#
endif
