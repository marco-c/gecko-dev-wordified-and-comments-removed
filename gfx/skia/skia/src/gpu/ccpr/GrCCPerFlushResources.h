#
ifndef
GrCCPerFlushResources_DEFINED
#
define
GrCCPerFlushResources_DEFINED
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
ccpr
/
GrCCAtlas
.
h
"
#
include
"
ccpr
/
GrCCFiller
.
h
"
#
include
"
ccpr
/
GrCCStroker
.
h
"
#
include
"
ccpr
/
GrCCPathProcessor
.
h
"
class
GrCCPathCacheEntry
;
class
GrOnFlushResourceProvider
;
class
GrShape
;
struct
GrCCRenderedPathStats
{
int
fMaxPointsPerPath
=
0
;
int
fNumTotalSkPoints
=
0
;
int
fNumTotalSkVerbs
=
0
;
int
fNumTotalConicWeights
=
0
;
void
statPath
(
const
SkPath
&
)
;
}
;
struct
GrCCPerFlushResourceSpecs
{
static
constexpr
int
kFillIdx
=
0
;
static
constexpr
int
kStrokeIdx
=
1
;
int
fNumCachedPaths
=
0
;
int
fNumCopiedPaths
[
2
]
=
{
0
0
}
;
GrCCRenderedPathStats
fCopyPathStats
[
2
]
;
GrCCAtlas
:
:
Specs
fCopyAtlasSpecs
;
int
fNumRenderedPaths
[
2
]
=
{
0
0
}
;
int
fNumClipPaths
=
0
;
GrCCRenderedPathStats
fRenderedPathStats
[
2
]
;
GrCCAtlas
:
:
Specs
fRenderedAtlasSpecs
;
bool
isEmpty
(
)
const
{
return
0
=
=
fNumCachedPaths
+
fNumCopiedPaths
[
kFillIdx
]
+
fNumCopiedPaths
[
kStrokeIdx
]
+
fNumRenderedPaths
[
kFillIdx
]
+
fNumRenderedPaths
[
kStrokeIdx
]
+
fNumClipPaths
;
}
void
convertCopiesToRenders
(
)
;
}
;
class
GrCCPerFlushResources
:
public
GrNonAtomicRef
<
GrCCPerFlushResources
>
{
public
:
GrCCPerFlushResources
(
GrOnFlushResourceProvider
*
const
GrCCPerFlushResourceSpecs
&
)
;
bool
isMapped
(
)
const
{
return
SkToBool
(
fPathInstanceData
)
;
}
GrCCAtlas
*
copyPathToCachedAtlas
(
const
GrCCPathCacheEntry
&
GrCCPathProcessor
:
:
DoEvenOddFill
SkIVector
*
newAtlasOffset
)
;
const
GrCCAtlas
*
renderShapeInAtlas
(
const
SkIRect
&
clipIBounds
const
SkMatrix
&
const
GrShape
&
float
strokeDevWidth
SkRect
*
devBounds
SkRect
*
devBounds45
SkIRect
*
devIBounds
SkIVector
*
devToAtlasOffset
)
;
const
GrCCAtlas
*
renderDeviceSpacePathInAtlas
(
const
SkIRect
&
clipIBounds
const
SkPath
&
devPath
const
SkIRect
&
devPathIBounds
SkIVector
*
devToAtlasOffset
)
;
int
nextPathInstanceIdx
(
)
const
{
return
fNextPathInstanceIdx
;
}
GrCCPathProcessor
:
:
Instance
&
appendDrawPathInstance
(
)
{
SkASSERT
(
this
-
>
isMapped
(
)
)
;
SkASSERT
(
fNextPathInstanceIdx
<
fEndPathInstance
)
;
return
fPathInstanceData
[
fNextPathInstanceIdx
+
+
]
;
}
bool
finalize
(
GrOnFlushResourceProvider
*
sk_sp
<
GrTextureProxy
>
stashedAtlasProxy
SkTArray
<
sk_sp
<
GrRenderTargetContext
>
>
*
out
)
;
const
GrCCFiller
&
filler
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fFiller
;
}
const
GrCCStroker
&
stroker
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fStroker
;
}
const
GrBuffer
*
indexBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fIndexBuffer
.
get
(
)
;
}
const
GrBuffer
*
vertexBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fVertexBuffer
.
get
(
)
;
}
GrBuffer
*
instanceBuffer
(
)
const
{
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
return
fInstanceBuffer
.
get
(
)
;
}
GrCCAtlas
*
nextAtlasToStash
(
)
{
return
fRenderedAtlasStack
.
empty
(
)
?
nullptr
:
&
fRenderedAtlasStack
.
front
(
)
;
}
bool
hasStashedAtlas
(
)
const
{
return
!
fRenderedAtlasStack
.
empty
(
)
&
&
fRenderedAtlasStack
.
front
(
)
.
uniqueKey
(
)
.
isValid
(
)
;
}
const
GrUniqueKey
&
stashedAtlasKey
(
)
const
{
SkASSERT
(
this
-
>
hasStashedAtlas
(
)
)
;
return
fRenderedAtlasStack
.
front
(
)
.
uniqueKey
(
)
;
}
private
:
bool
placeRenderedPathInAtlas
(
const
SkIRect
&
clipIBounds
const
SkIRect
&
pathIBounds
GrScissorTest
*
SkIRect
*
clippedPathIBounds
SkIVector
*
devToAtlasOffset
)
;
const
SkAutoSTArray
<
32
SkPoint
>
fLocalDevPtsBuffer
;
GrCCFiller
fFiller
;
GrCCStroker
fStroker
;
GrCCAtlasStack
fCopyAtlasStack
;
GrCCAtlasStack
fRenderedAtlasStack
;
const
sk_sp
<
const
GrBuffer
>
fIndexBuffer
;
const
sk_sp
<
const
GrBuffer
>
fVertexBuffer
;
const
sk_sp
<
GrBuffer
>
fInstanceBuffer
;
GrCCPathProcessor
:
:
Instance
*
fPathInstanceData
=
nullptr
;
int
fNextCopyInstanceIdx
;
SkDEBUGCODE
(
int
fEndCopyInstance
)
;
int
fNextPathInstanceIdx
;
SkDEBUGCODE
(
int
fEndPathInstance
)
;
}
;
inline
void
GrCCRenderedPathStats
:
:
statPath
(
const
SkPath
&
path
)
{
fMaxPointsPerPath
=
SkTMax
(
fMaxPointsPerPath
path
.
countPoints
(
)
)
;
fNumTotalSkPoints
+
=
path
.
countPoints
(
)
;
fNumTotalSkVerbs
+
=
path
.
countVerbs
(
)
;
fNumTotalConicWeights
+
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
}
#
endif
