#
include
"
src
/
gpu
/
ccpr
/
GrCCCoverageProcessor
.
h
"
#
include
"
src
/
core
/
SkMakeUnique
.
h
"
#
include
"
src
/
gpu
/
GrOpFlushState
.
h
"
#
include
"
src
/
gpu
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
GrProgramInfo
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCConicShader
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCCubicShader
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCQuadraticShader
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
class
GrCCCoverageProcessor
:
:
TriangleShader
:
public
GrCCCoverageProcessor
:
:
Shader
{
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVarying
:
:
Scope
scope
SkString
*
code
const
char
*
position
const
char
*
coverage
const
char
*
cornerCoverage
const
char
*
)
override
{
if
(
!
cornerCoverage
)
{
fCoverages
.
reset
(
kHalf_GrSLType
scope
)
;
varyingHandler
-
>
addVarying
(
"
coverage
"
&
fCoverages
)
;
code
-
>
appendf
(
"
%
s
=
%
s
;
"
OutName
(
fCoverages
)
coverage
)
;
}
else
{
fCoverages
.
reset
(
kHalf3_GrSLType
scope
)
;
varyingHandler
-
>
addVarying
(
"
coverages
"
&
fCoverages
)
;
code
-
>
appendf
(
"
%
s
=
half3
(
%
s
%
s
)
;
"
OutName
(
fCoverages
)
coverage
cornerCoverage
)
;
}
}
void
emitFragmentCoverageCode
(
GrGLSLFPFragmentBuilder
*
f
const
char
*
outputCoverage
)
const
override
{
if
(
kHalf_GrSLType
=
=
fCoverages
.
type
(
)
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outputCoverage
fCoverages
.
fsIn
(
)
)
;
}
else
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
.
z
*
%
s
.
y
+
%
s
.
x
;
"
outputCoverage
fCoverages
.
fsIn
(
)
fCoverages
.
fsIn
(
)
fCoverages
.
fsIn
(
)
)
;
}
}
void
emitSampleMaskCode
(
GrGLSLFPFragmentBuilder
*
)
const
override
{
return
;
}
GrGLSLVarying
fCoverages
;
}
;
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcWind
(
const
GrCCCoverageProcessor
&
proc
GrGLSLVertexGeoBuilder
*
s
const
char
*
pts
const
char
*
outputWind
)
{
if
(
3
=
=
proc
.
numInputPoints
(
)
)
{
s
-
>
codeAppendf
(
"
float2
a
=
%
s
[
0
]
-
%
s
[
1
]
"
"
b
=
%
s
[
0
]
-
%
s
[
2
]
;
"
pts
pts
pts
pts
)
;
}
else
{
SkASSERT
(
4
=
=
proc
.
numInputPoints
(
)
)
;
s
-
>
codeAppendf
(
"
float2
p12
=
(
%
s
[
1
]
+
%
s
[
2
]
)
*
.
5
;
"
pts
pts
)
;
s
-
>
codeAppendf
(
"
float2
a
=
%
s
[
0
]
-
p12
"
"
b
=
%
s
[
0
]
-
%
s
[
3
]
;
"
pts
pts
pts
)
;
}
s
-
>
codeAppend
(
"
float
area_x2
=
determinant
(
float2x2
(
a
b
)
)
;
"
)
;
if
(
proc
.
isTriangles
(
)
)
{
s
-
>
codeAppend
(
"
float2
bbox_size
=
max
(
abs
(
a
)
abs
(
b
)
)
;
"
)
;
s
-
>
codeAppend
(
"
float
basewidth
=
max
(
bbox_size
.
x
+
bbox_size
.
y
1
)
;
"
)
;
s
-
>
codeAppendf
(
"
%
s
=
(
abs
(
area_x2
*
1024
)
>
basewidth
)
?
sign
(
half
(
area_x2
)
)
:
0
;
"
outputWind
)
;
}
else
{
s
-
>
codeAppendf
(
"
%
s
=
sign
(
half
(
area_x2
)
)
;
"
outputWind
)
;
}
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcEdgeCoverageAtBloatVertex
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftPt
const
char
*
rightPt
const
char
*
rasterVertexDir
const
char
*
outputCoverage
)
{
s
-
>
codeAppendf
(
"
float2
n
=
float2
(
%
s
.
y
-
%
s
.
y
%
s
.
x
-
%
s
.
x
)
;
"
rightPt
leftPt
leftPt
rightPt
)
;
s
-
>
codeAppend
(
"
float
nwidth
=
abs
(
n
.
x
)
+
abs
(
n
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
float
t
=
dot
(
%
s
n
)
;
"
rasterVertexDir
)
;
s
-
>
codeAppendf
(
"
%
s
=
half
(
abs
(
t
)
!
=
nwidth
?
t
/
nwidth
:
sign
(
t
)
)
*
-
.
5
-
.
5
;
"
outputCoverage
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcEdgeCoveragesAtBloatVertices
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftPt
const
char
*
rightPt
const
char
*
bloatDir1
const
char
*
bloatDir2
const
char
*
outputCoverages
)
{
s
-
>
codeAppendf
(
"
float2
n
=
float2
(
%
s
.
y
-
%
s
.
y
%
s
.
x
-
%
s
.
x
)
;
"
rightPt
leftPt
leftPt
rightPt
)
;
s
-
>
codeAppend
(
"
float
nwidth
=
abs
(
n
.
x
)
+
abs
(
n
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
float2
t
=
n
*
float2x2
(
%
s
%
s
)
;
"
bloatDir1
bloatDir2
)
;
s
-
>
codeAppendf
(
"
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
"
)
;
s
-
>
codeAppendf
(
"
%
s
[
i
]
=
half
(
abs
(
t
[
i
]
)
!
=
nwidth
?
t
[
i
]
/
nwidth
:
sign
(
t
[
i
]
)
)
*
-
.
5
-
.
5
;
"
outputCoverages
)
;
s
-
>
codeAppendf
(
"
}
"
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcCornerAttenuation
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftDir
const
char
*
rightDir
const
char
*
outputAttenuation
)
{
s
-
>
codeAppendf
(
"
half
obtuseness
=
max
(
half
(
dot
(
%
s
%
s
)
)
0
)
;
"
leftDir
rightDir
)
;
s
-
>
codeAppendf
(
"
half2
abs_bisect_maybe_transpose
=
abs
(
(
0
=
=
obtuseness
)
?
half2
(
%
s
-
%
s
)
:
"
"
half2
(
%
s
+
%
s
)
)
;
"
leftDir
rightDir
leftDir
rightDir
)
;
s
-
>
codeAppend
(
"
half
axis_alignedness
=
"
"
1
-
min
(
abs_bisect_maybe_transpose
.
y
abs_bisect_maybe_transpose
.
x
)
/
"
"
max
(
abs_bisect_maybe_transpose
.
x
abs_bisect_maybe_transpose
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
half
ninety_degreesness
=
determinant
(
half2x2
(
%
s
%
s
)
)
;
"
leftDir
rightDir
)
;
s
-
>
codeAppend
(
"
ninety_degreesness
=
ninety_degreesness
*
ninety_degreesness
;
"
)
;
s
-
>
codeAppendf
(
"
%
s
=
max
(
obtuseness
axis_alignedness
*
ninety_degreesness
)
;
"
outputAttenuation
)
;
}
GrGLSLPrimitiveProcessor
*
GrCCCoverageProcessor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
std
:
:
unique_ptr
<
Shader
>
shader
;
switch
(
fPrimitiveType
)
{
case
PrimitiveType
:
:
kTriangles
:
case
PrimitiveType
:
:
kWeightedTriangles
:
shader
=
skstd
:
:
make_unique
<
TriangleShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kQuadratics
:
shader
=
skstd
:
:
make_unique
<
GrCCQuadraticShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kCubics
:
shader
=
skstd
:
:
make_unique
<
GrCCCubicShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kConics
:
shader
=
skstd
:
:
make_unique
<
GrCCConicShader
>
(
)
;
break
;
}
return
this
-
>
onCreateGLSLInstance
(
std
:
:
move
(
shader
)
)
;
}
void
GrCCCoverageProcessor
:
:
draw
(
GrOpFlushState
*
flushState
const
GrPipeline
&
pipeline
const
SkIRect
scissorRects
[
]
const
GrMesh
meshes
[
]
int
meshCount
const
SkRect
&
drawBounds
)
const
{
GrPipeline
:
:
DynamicStateArrays
dynamicStateArrays
;
dynamicStateArrays
.
fScissorRects
=
scissorRects
;
GrOpsRenderPass
*
renderPass
=
flushState
-
>
opsRenderPass
(
)
;
GrProgramInfo
programInfo
(
flushState
-
>
drawOpArgs
(
)
.
numSamples
(
)
flushState
-
>
drawOpArgs
(
)
.
origin
(
)
pipeline
*
this
nullptr
&
dynamicStateArrays
0
)
;
renderPass
-
>
draw
(
programInfo
meshes
meshCount
drawBounds
)
;
}
