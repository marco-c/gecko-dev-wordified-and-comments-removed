#
include
"
GrCCCoverageProcessor
.
h
"
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
SkMakeUnique
.
h
"
#
include
"
ccpr
/
GrCCConicShader
.
h
"
#
include
"
ccpr
/
GrCCCubicShader
.
h
"
#
include
"
ccpr
/
GrCCQuadraticShader
.
h
"
#
include
"
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
class
GrCCCoverageProcessor
:
:
TriangleShader
:
public
GrCCCoverageProcessor
:
:
Shader
{
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVarying
:
:
Scope
scope
SkString
*
code
const
char
*
position
const
char
*
coverage
const
char
*
cornerCoverage
)
override
{
if
(
!
cornerCoverage
)
{
fCoverages
.
reset
(
kHalf_GrSLType
scope
)
;
varyingHandler
-
>
addVarying
(
"
coverage
"
&
fCoverages
)
;
code
-
>
appendf
(
"
%
s
=
%
s
;
"
OutName
(
fCoverages
)
coverage
)
;
}
else
{
fCoverages
.
reset
(
kHalf3_GrSLType
scope
)
;
varyingHandler
-
>
addVarying
(
"
coverages
"
&
fCoverages
)
;
code
-
>
appendf
(
"
%
s
=
half3
(
%
s
%
s
)
;
"
OutName
(
fCoverages
)
coverage
cornerCoverage
)
;
}
}
void
onEmitFragmentCode
(
GrGLSLFPFragmentBuilder
*
f
const
char
*
outputCoverage
)
const
override
{
if
(
kHalf_GrSLType
=
=
fCoverages
.
type
(
)
)
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
;
"
outputCoverage
fCoverages
.
fsIn
(
)
)
;
}
else
{
f
-
>
codeAppendf
(
"
%
s
=
%
s
.
z
*
%
s
.
y
+
%
s
.
x
;
"
outputCoverage
fCoverages
.
fsIn
(
)
fCoverages
.
fsIn
(
)
fCoverages
.
fsIn
(
)
)
;
}
}
GrGLSLVarying
fCoverages
;
}
;
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcWind
(
const
GrCCCoverageProcessor
&
proc
GrGLSLVertexGeoBuilder
*
s
const
char
*
pts
const
char
*
outputWind
)
{
if
(
3
=
=
proc
.
numInputPoints
(
)
)
{
s
-
>
codeAppendf
(
"
float2
a
=
%
s
[
0
]
-
%
s
[
1
]
"
"
b
=
%
s
[
0
]
-
%
s
[
2
]
;
"
pts
pts
pts
pts
)
;
}
else
{
SkASSERT
(
4
=
=
proc
.
numInputPoints
(
)
)
;
s
-
>
codeAppendf
(
"
float2
p12
=
(
%
s
[
1
]
+
%
s
[
2
]
)
*
.
5
;
"
pts
pts
)
;
s
-
>
codeAppendf
(
"
float2
a
=
%
s
[
0
]
-
p12
"
"
b
=
%
s
[
0
]
-
%
s
[
3
]
;
"
pts
pts
pts
)
;
}
s
-
>
codeAppend
(
"
float
area_x2
=
determinant
(
float2x2
(
a
b
)
)
;
"
)
;
if
(
proc
.
isTriangles
(
)
)
{
s
-
>
codeAppend
(
"
float2
bbox_size
=
max
(
abs
(
a
)
abs
(
b
)
)
;
"
)
;
s
-
>
codeAppend
(
"
float
basewidth
=
max
(
bbox_size
.
x
+
bbox_size
.
y
1
)
;
"
)
;
s
-
>
codeAppendf
(
"
%
s
=
(
abs
(
area_x2
*
1024
)
>
basewidth
)
?
sign
(
half
(
area_x2
)
)
:
0
;
"
outputWind
)
;
}
else
{
s
-
>
codeAppendf
(
"
%
s
=
sign
(
half
(
area_x2
)
)
;
"
outputWind
)
;
}
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
EmitEdgeDistanceEquation
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftPt
const
char
*
rightPt
const
char
*
outputDistanceEquation
)
{
s
-
>
codeAppendf
(
"
float2
n
=
float2
(
%
s
.
y
-
%
s
.
y
%
s
.
x
-
%
s
.
x
)
;
"
rightPt
leftPt
leftPt
rightPt
)
;
s
-
>
codeAppend
(
"
float
nwidth
=
(
abs
(
n
.
x
)
+
abs
(
n
.
y
)
)
*
(
bloat
*
2
)
;
"
)
;
s
-
>
codeAppend
(
"
n
/
=
(
0
!
=
nwidth
)
?
nwidth
:
1
;
"
)
;
s
-
>
codeAppendf
(
"
%
s
=
float3
(
-
n
dot
(
n
%
s
)
-
.
5
)
;
"
outputDistanceEquation
leftPt
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcEdgeCoverageAtBloatVertex
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftPt
const
char
*
rightPt
const
char
*
rasterVertexDir
const
char
*
outputCoverage
)
{
s
-
>
codeAppendf
(
"
float2
n
=
float2
(
%
s
.
y
-
%
s
.
y
%
s
.
x
-
%
s
.
x
)
;
"
rightPt
leftPt
leftPt
rightPt
)
;
s
-
>
codeAppend
(
"
float
nwidth
=
abs
(
n
.
x
)
+
abs
(
n
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
float
t
=
dot
(
%
s
n
)
;
"
rasterVertexDir
)
;
s
-
>
codeAppendf
(
"
%
s
=
half
(
abs
(
t
)
!
=
nwidth
?
t
/
nwidth
:
sign
(
t
)
)
*
-
.
5
-
.
5
;
"
outputCoverage
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcEdgeCoveragesAtBloatVertices
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftPt
const
char
*
rightPt
const
char
*
bloatDir1
const
char
*
bloatDir2
const
char
*
outputCoverages
)
{
s
-
>
codeAppendf
(
"
float2
n
=
float2
(
%
s
.
y
-
%
s
.
y
%
s
.
x
-
%
s
.
x
)
;
"
rightPt
leftPt
leftPt
rightPt
)
;
s
-
>
codeAppend
(
"
float
nwidth
=
abs
(
n
.
x
)
+
abs
(
n
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
float2
t
=
n
*
float2x2
(
%
s
%
s
)
;
"
bloatDir1
bloatDir2
)
;
s
-
>
codeAppendf
(
"
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
"
)
;
s
-
>
codeAppendf
(
"
%
s
[
i
]
=
half
(
abs
(
t
[
i
]
)
!
=
nwidth
?
t
[
i
]
/
nwidth
:
sign
(
t
[
i
]
)
)
*
-
.
5
-
.
5
;
"
outputCoverages
)
;
s
-
>
codeAppendf
(
"
}
"
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
CalcCornerAttenuation
(
GrGLSLVertexGeoBuilder
*
s
const
char
*
leftDir
const
char
*
rightDir
const
char
*
outputAttenuation
)
{
s
-
>
codeAppendf
(
"
half
obtuseness
=
max
(
half
(
dot
(
%
s
%
s
)
)
0
)
;
"
leftDir
rightDir
)
;
s
-
>
codeAppendf
(
"
half2
abs_bisect_maybe_transpose
=
abs
(
(
0
=
=
obtuseness
)
?
half2
(
%
s
-
%
s
)
:
"
"
half2
(
%
s
+
%
s
)
)
;
"
leftDir
rightDir
leftDir
rightDir
)
;
s
-
>
codeAppend
(
"
half
axis_alignedness
=
"
"
1
-
min
(
abs_bisect_maybe_transpose
.
y
abs_bisect_maybe_transpose
.
x
)
/
"
"
max
(
abs_bisect_maybe_transpose
.
x
abs_bisect_maybe_transpose
.
y
)
;
"
)
;
s
-
>
codeAppendf
(
"
half
ninety_degreesness
=
determinant
(
half2x2
(
%
s
%
s
)
)
;
"
leftDir
rightDir
)
;
s
-
>
codeAppend
(
"
ninety_degreesness
=
ninety_degreesness
*
ninety_degreesness
;
"
)
;
s
-
>
codeAppendf
(
"
%
s
=
max
(
obtuseness
axis_alignedness
*
ninety_degreesness
)
;
"
outputAttenuation
)
;
}
void
GrCCCoverageProcessor
:
:
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
const
{
int
key
=
(
int
)
fPrimitiveType
<
<
2
;
if
(
GSSubpass
:
:
kCorners
=
=
fGSSubpass
)
{
key
|
=
2
;
}
if
(
Impl
:
:
kVertexShader
=
=
fImpl
)
{
key
|
=
1
;
}
#
ifdef
SK_DEBUG
uint32_t
bloatBits
;
memcpy
(
&
bloatBits
&
fDebugBloat
4
)
;
b
-
>
add32
(
bloatBits
)
;
#
endif
b
-
>
add32
(
key
)
;
}
GrGLSLPrimitiveProcessor
*
GrCCCoverageProcessor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
std
:
:
unique_ptr
<
Shader
>
shader
;
switch
(
fPrimitiveType
)
{
case
PrimitiveType
:
:
kTriangles
:
case
PrimitiveType
:
:
kWeightedTriangles
:
shader
=
skstd
:
:
make_unique
<
TriangleShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kQuadratics
:
shader
=
skstd
:
:
make_unique
<
GrCCQuadraticShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kCubics
:
shader
=
skstd
:
:
make_unique
<
GrCCCubicShader
>
(
)
;
break
;
case
PrimitiveType
:
:
kConics
:
shader
=
skstd
:
:
make_unique
<
GrCCConicShader
>
(
)
;
break
;
}
return
Impl
:
:
kGeometryShader
=
=
fImpl
?
this
-
>
createGSImpl
(
std
:
:
move
(
shader
)
)
:
this
-
>
createVSImpl
(
std
:
:
move
(
shader
)
)
;
}
void
GrCCCoverageProcessor
:
:
Shader
:
:
emitFragmentCode
(
const
GrCCCoverageProcessor
&
proc
GrGLSLFPFragmentBuilder
*
f
const
char
*
skOutputColor
const
char
*
skOutputCoverage
)
const
{
f
-
>
codeAppendf
(
"
half
coverage
=
0
;
"
)
;
this
-
>
onEmitFragmentCode
(
f
"
coverage
"
)
;
f
-
>
codeAppendf
(
"
%
s
.
a
=
coverage
;
"
skOutputColor
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
1
)
;
"
skOutputCoverage
)
;
}
void
GrCCCoverageProcessor
:
:
draw
(
GrOpFlushState
*
flushState
const
GrPipeline
&
pipeline
const
SkIRect
scissorRects
[
]
const
GrMesh
meshes
[
]
int
meshCount
const
SkRect
&
drawBounds
)
const
{
GrPipeline
:
:
DynamicStateArrays
dynamicStateArrays
;
dynamicStateArrays
.
fScissorRects
=
scissorRects
;
GrGpuRTCommandBuffer
*
cmdBuff
=
flushState
-
>
rtCommandBuffer
(
)
;
cmdBuff
-
>
draw
(
*
this
pipeline
nullptr
&
dynamicStateArrays
meshes
meshCount
drawBounds
)
;
if
(
Impl
:
:
kGeometryShader
=
=
fImpl
)
{
SkASSERT
(
GSSubpass
:
:
kHulls
=
=
fGSSubpass
)
;
GrCCCoverageProcessor
cornerProc
(
*
this
GSSubpass
:
:
kCorners
)
;
cmdBuff
-
>
draw
(
cornerProc
pipeline
nullptr
&
dynamicStateArrays
meshes
meshCount
drawBounds
)
;
}
}
