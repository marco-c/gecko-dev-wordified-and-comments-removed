#
include
"
src
/
gpu
/
ccpr
/
GrGSCoverageProcessor
.
h
"
#
include
"
src
/
gpu
/
GrMesh
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVertexGeoBuilder
.
h
"
using
InputType
=
GrGLSLGeometryBuilder
:
:
InputType
;
using
OutputType
=
GrGLSLGeometryBuilder
:
:
OutputType
;
class
GrGSCoverageProcessor
:
:
Impl
:
public
GrGLSLGeometryProcessor
{
protected
:
Impl
(
std
:
:
unique_ptr
<
Shader
>
shader
)
:
fShader
(
std
:
:
move
(
shader
)
)
{
}
virtual
bool
hasCoverage
(
const
GrGSCoverageProcessor
&
proc
)
const
{
return
false
;
}
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
FPCoordTransformIter
&
&
transformIter
)
final
{
this
-
>
setTransformDataHelper
(
SkMatrix
:
:
I
(
)
pdman
&
transformIter
)
;
}
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
final
{
const
GrGSCoverageProcessor
&
proc
=
args
.
fGP
.
cast
<
GrGSCoverageProcessor
>
(
)
;
SkASSERT
(
1
=
=
proc
.
numVertexAttributes
(
)
)
;
gpArgs
-
>
fPositionVar
=
proc
.
fInputXOrYValues
.
asShaderVar
(
)
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
this
-
>
emitGeometryShader
(
proc
varyingHandler
args
.
fGeomBuilder
args
.
fRTAdjustName
)
;
varyingHandler
-
>
emitAttributes
(
proc
)
;
varyingHandler
-
>
setNoPerspective
(
)
;
SkASSERT
(
!
args
.
fFPCoordTransformHandler
-
>
nextCoordTransform
(
)
)
;
GrGLSLFPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
f
-
>
codeAppendf
(
"
half
coverage
;
"
)
;
fShader
-
>
emitFragmentCoverageCode
(
f
"
coverage
"
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
coverage
)
;
"
args
.
fOutputColor
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
1
)
;
"
args
.
fOutputCoverage
)
;
}
void
emitGeometryShader
(
const
GrGSCoverageProcessor
&
proc
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLGeometryBuilder
*
g
const
char
*
rtAdjust
)
const
{
int
numInputPoints
=
proc
.
numInputPoints
(
)
;
SkASSERT
(
3
=
=
numInputPoints
|
|
4
=
=
numInputPoints
)
;
int
inputWidth
=
(
4
=
=
numInputPoints
|
|
proc
.
hasInputWeight
(
)
)
?
4
:
3
;
const
char
*
posValues
=
(
4
=
=
inputWidth
)
?
"
sk_Position
"
:
"
sk_Position
.
xyz
"
;
g
-
>
codeAppendf
(
"
float
%
ix2
pts
=
transpose
(
float2x
%
i
(
sk_in
[
0
]
.
%
s
sk_in
[
1
]
.
%
s
)
)
;
"
inputWidth
inputWidth
posValues
posValues
)
;
GrShaderVar
wind
(
"
wind
"
kHalf_GrSLType
)
;
g
-
>
declareGlobal
(
wind
)
;
Shader
:
:
CalcWind
(
proc
g
"
pts
"
wind
.
c_str
(
)
)
;
if
(
PrimitiveType
:
:
kWeightedTriangles
=
=
proc
.
primitiveType
(
)
)
{
SkASSERT
(
3
=
=
numInputPoints
)
;
SkASSERT
(
kFloat4_GrVertexAttribType
=
=
proc
.
fInputXOrYValues
.
cpuType
(
)
)
;
g
-
>
codeAppendf
(
"
%
s
*
=
half
(
sk_in
[
0
]
.
sk_Position
.
w
)
;
"
wind
.
c_str
(
)
)
;
}
SkString
emitVertexFn
;
SkSTArray
<
3
GrShaderVar
>
emitArgs
;
const
char
*
corner
=
emitArgs
.
emplace_back
(
"
corner
"
kFloat2_GrSLType
)
.
c_str
(
)
;
const
char
*
bloatdir
=
emitArgs
.
emplace_back
(
"
bloatdir
"
kFloat2_GrSLType
)
.
c_str
(
)
;
const
char
*
inputCoverage
=
nullptr
;
if
(
this
-
>
hasCoverage
(
proc
)
)
{
inputCoverage
=
emitArgs
.
emplace_back
(
"
coverage
"
kHalf_GrSLType
)
.
c_str
(
)
;
}
const
char
*
cornerCoverage
=
nullptr
;
if
(
Subpass
:
:
kCorners
=
=
proc
.
fSubpass
)
{
cornerCoverage
=
emitArgs
.
emplace_back
(
"
corner_coverage
"
kHalf2_GrSLType
)
.
c_str
(
)
;
}
g
-
>
emitFunction
(
kVoid_GrSLType
"
emitVertex
"
emitArgs
.
count
(
)
emitArgs
.
begin
(
)
[
&
]
(
)
{
SkString
fnBody
;
fnBody
.
appendf
(
"
float2
vertexpos
=
fma
(
%
s
float2
(
bloat
)
%
s
)
;
"
bloatdir
corner
)
;
const
char
*
coverage
=
inputCoverage
;
if
(
!
coverage
)
{
if
(
!
fShader
-
>
calculatesOwnEdgeCoverage
(
)
)
{
fnBody
.
appendf
(
"
float
coverage
=
dot
(
float3
(
vertexpos
1
)
%
s
)
;
"
fEdgeDistanceEquation
.
c_str
(
)
)
;
}
else
{
fnBody
.
appendf
(
"
float
coverage
=
1
;
"
)
;
}
coverage
=
"
coverage
"
;
}
fnBody
.
appendf
(
"
%
s
*
=
%
s
;
"
coverage
wind
.
c_str
(
)
)
;
if
(
cornerCoverage
)
{
fnBody
.
appendf
(
"
%
s
.
x
*
=
%
s
;
"
cornerCoverage
wind
.
c_str
(
)
)
;
}
fShader
-
>
emitVaryings
(
varyingHandler
GrGLSLVarying
:
:
Scope
:
:
kGeoToFrag
&
fnBody
"
vertexpos
"
coverage
cornerCoverage
wind
.
c_str
(
)
)
;
g
-
>
emitVertex
(
&
fnBody
"
vertexpos
"
rtAdjust
)
;
return
fnBody
;
}
(
)
.
c_str
(
)
&
emitVertexFn
)
;
float
bloat
=
kAABloatRadius
;
#
ifdef
SK_DEBUG
if
(
proc
.
debugBloatEnabled
(
)
)
{
bloat
*
=
proc
.
debugBloat
(
)
;
}
#
endif
g
-
>
defineConstant
(
"
bloat
"
bloat
)
;
if
(
!
this
-
>
hasCoverage
(
proc
)
&
&
!
fShader
-
>
calculatesOwnEdgeCoverage
(
)
)
{
g
-
>
declareGlobal
(
fEdgeDistanceEquation
)
;
g
-
>
codeAppendf
(
"
float2
p0
=
pts
[
0
]
p1
=
pts
[
%
i
]
;
"
numInputPoints
-
1
)
;
g
-
>
codeAppendf
(
"
float2
n
=
float2
(
p0
.
y
-
p1
.
y
p1
.
x
-
p0
.
x
)
;
"
)
;
g
-
>
codeAppend
(
"
float
nwidth
=
bloat
*
2
*
(
abs
(
n
.
x
)
+
abs
(
n
.
y
)
)
;
"
)
;
g
-
>
codeAppend
(
"
n
/
=
(
0
!
=
nwidth
)
?
nwidth
:
1
;
"
)
;
g
-
>
codeAppendf
(
"
%
s
=
float3
(
-
n
dot
(
n
p0
)
-
.
5
*
sign
(
%
s
)
)
;
"
fEdgeDistanceEquation
.
c_str
(
)
wind
.
c_str
(
)
)
;
}
this
-
>
onEmitGeometryShader
(
proc
g
wind
emitVertexFn
.
c_str
(
)
)
;
}
virtual
void
onEmitGeometryShader
(
const
GrGSCoverageProcessor
&
GrGLSLGeometryBuilder
*
const
GrShaderVar
&
wind
const
char
*
emitVertexFn
)
const
=
0
;
const
std
:
:
unique_ptr
<
Shader
>
fShader
;
const
GrShaderVar
fEdgeDistanceEquation
{
"
edge_distance_equation
"
kFloat3_GrSLType
}
;
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
class
GrGSCoverageProcessor
:
:
TriangleHullImpl
:
public
GrGSCoverageProcessor
:
:
Impl
{
public
:
TriangleHullImpl
(
std
:
:
unique_ptr
<
Shader
>
shader
)
:
Impl
(
std
:
:
move
(
shader
)
)
{
}
bool
hasCoverage
(
const
GrGSCoverageProcessor
&
proc
)
const
override
{
return
true
;
}
void
onEmitGeometryShader
(
const
GrGSCoverageProcessor
&
GrGLSLGeometryBuilder
*
g
const
GrShaderVar
&
wind
const
char
*
emitVertexFn
)
const
override
{
fShader
-
>
emitSetupCode
(
g
"
pts
"
)
;
g
-
>
codeAppendf
(
"
int
i
=
(
%
s
>
0
?
sk_InvocationID
:
4
-
sk_InvocationID
)
%
%
3
;
"
wind
.
c_str
(
)
)
;
g
-
>
codeAppend
(
"
float2
top
=
pts
[
i
]
;
"
)
;
g
-
>
codeAppendf
(
"
float2
right
=
pts
[
(
i
+
(
%
s
>
0
?
1
:
2
)
)
%
%
3
]
;
"
wind
.
c_str
(
)
)
;
g
-
>
codeAppendf
(
"
float2
left
=
pts
[
(
i
+
(
%
s
>
0
?
2
:
1
)
)
%
%
3
]
;
"
wind
.
c_str
(
)
)
;
g
-
>
codeAppend
(
"
float2
leftbloat
=
sign
(
top
-
left
)
;
"
)
;
g
-
>
codeAppend
(
"
leftbloat
=
float2
(
0
!
=
leftbloat
.
y
?
leftbloat
.
y
:
leftbloat
.
x
"
"
0
!
=
leftbloat
.
x
?
-
leftbloat
.
x
:
-
leftbloat
.
y
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
rightbloat
=
sign
(
right
-
top
)
;
"
)
;
g
-
>
codeAppend
(
"
rightbloat
=
float2
(
0
!
=
rightbloat
.
y
?
rightbloat
.
y
:
rightbloat
.
x
"
"
0
!
=
rightbloat
.
x
?
-
rightbloat
.
x
:
-
rightbloat
.
y
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
downbloat
=
sign
(
left
-
right
)
;
"
)
;
g
-
>
codeAppend
(
"
downbloat
=
float2
(
0
!
=
downbloat
.
y
?
downbloat
.
y
:
downbloat
.
x
"
"
0
!
=
downbloat
.
x
?
-
downbloat
.
x
:
-
downbloat
.
y
)
;
"
)
;
g
-
>
codeAppend
(
"
half4
coverages
=
half4
(
+
1
)
;
"
)
;
g
-
>
codeAppend
(
"
if
(
sk_InvocationID
>
=
2
)
{
"
)
;
Shader
:
:
CalcEdgeCoverageAtBloatVertex
(
g
"
top
"
"
right
"
"
float2
(
+
rightbloat
.
y
-
rightbloat
.
x
)
"
"
coverages
[
0
]
"
)
;
g
-
>
codeAppend
(
"
coverages
.
yzw
=
half3
(
-
1
0
-
1
-
coverages
[
0
]
)
;
"
)
;
g
-
>
codeAppend
(
"
leftbloat
=
downbloat
=
-
rightbloat
;
"
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppendf
(
"
bool2
left_right_notequal
=
notEqual
(
leftbloat
rightbloat
)
;
"
)
;
g
-
>
codeAppend
(
"
if
(
all
(
left_right_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
top
float2
(
-
leftbloat
.
y
+
leftbloat
.
x
)
coverages
[
0
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppend
(
"
if
(
any
(
left_right_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
top
rightbloat
coverages
[
1
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
top
leftbloat
coverages
[
2
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
right
rightbloat
coverages
[
1
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
bool2
right_down_notequal
=
notEqual
(
rightbloat
downbloat
)
;
"
)
;
g
-
>
codeAppend
(
"
if
(
any
(
right_down_notequal
)
|
|
0
=
=
sk_InvocationID
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
(
0
=
=
sk_InvocationID
)
?
left
:
right
"
"
(
0
=
=
sk_InvocationID
)
?
leftbloat
:
downbloat
"
"
coverages
[
2
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppend
(
"
if
(
all
(
right_down_notequal
)
&
&
0
!
=
sk_InvocationID
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
right
float2
(
-
rightbloat
.
y
+
rightbloat
.
x
)
coverages
[
3
]
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
configure
(
InputType
:
:
kLines
OutputType
:
:
kTriangleStrip
6
5
)
;
}
}
;
class
GrGSCoverageProcessor
:
:
CurveHullImpl
:
public
GrGSCoverageProcessor
:
:
Impl
{
public
:
CurveHullImpl
(
std
:
:
unique_ptr
<
Shader
>
shader
)
:
Impl
(
std
:
:
move
(
shader
)
)
{
}
void
onEmitGeometryShader
(
const
GrGSCoverageProcessor
&
GrGLSLGeometryBuilder
*
g
const
GrShaderVar
&
wind
const
char
*
emitVertexFn
)
const
override
{
const
char
*
hullPts
=
"
pts
"
;
fShader
-
>
emitSetupCode
(
g
"
pts
"
&
hullPts
)
;
g
-
>
codeAppend
(
"
int
i
=
sk_InvocationID
*
2
;
"
)
;
g
-
>
codeAppendf
(
"
float2
topleft
=
%
s
[
i
]
;
"
hullPts
)
;
g
-
>
codeAppendf
(
"
float2
topright
=
%
s
[
%
s
>
0
?
i
+
1
:
3
-
i
]
;
"
hullPts
wind
.
c_str
(
)
)
;
g
-
>
codeAppendf
(
"
float2
bottomleft
=
%
s
[
%
s
>
0
?
3
-
i
:
i
+
1
]
;
"
hullPts
wind
.
c_str
(
)
)
;
g
-
>
codeAppendf
(
"
float2
bottomright
=
%
s
[
2
-
i
]
;
"
hullPts
)
;
g
-
>
codeAppend
(
"
float2
leftbloat
=
float2
(
topleft
.
y
>
bottomleft
.
y
?
+
1
:
-
1
"
"
topleft
.
x
>
bottomleft
.
x
?
-
1
:
+
1
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
upbloat
=
float2
(
topright
.
y
>
topleft
.
y
?
+
1
:
-
1
"
"
topright
.
x
>
topleft
.
x
?
-
1
:
+
1
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
rightbloat
=
float2
(
bottomright
.
y
>
topright
.
y
?
+
1
:
-
1
"
"
bottomright
.
x
>
topright
.
x
?
-
1
:
+
1
)
;
"
)
;
g
-
>
codeAppendf
(
"
bool2
left_up_notequal
=
notEqual
(
leftbloat
upbloat
)
;
"
)
;
g
-
>
codeAppend
(
"
if
(
all
(
left_up_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
topleft
float2
(
-
leftbloat
.
y
leftbloat
.
x
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppend
(
"
if
(
any
(
left_up_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
topleft
leftbloat
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
topleft
upbloat
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
bottomleft
leftbloat
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
topright
upbloat
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
bool2
up_right_notequal
=
notEqual
(
upbloat
rightbloat
)
;
"
)
;
g
-
>
codeAppend
(
"
if
(
any
(
up_right_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
topright
rightbloat
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppend
(
"
if
(
all
(
up_right_notequal
)
)
{
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
topright
float2
(
-
upbloat
.
y
upbloat
.
x
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
configure
(
InputType
:
:
kLines
OutputType
:
:
kTriangleStrip
7
2
)
;
}
}
;
class
GrGSCoverageProcessor
:
:
CornerImpl
:
public
GrGSCoverageProcessor
:
:
Impl
{
public
:
CornerImpl
(
std
:
:
unique_ptr
<
Shader
>
shader
)
:
Impl
(
std
:
:
move
(
shader
)
)
{
}
bool
hasCoverage
(
const
GrGSCoverageProcessor
&
proc
)
const
override
{
return
proc
.
isTriangles
(
)
;
}
void
onEmitGeometryShader
(
const
GrGSCoverageProcessor
&
proc
GrGLSLGeometryBuilder
*
g
const
GrShaderVar
&
wind
const
char
*
emitVertexFn
)
const
override
{
fShader
-
>
emitSetupCode
(
g
"
pts
"
)
;
g
-
>
codeAppendf
(
"
int
corneridx
=
sk_InvocationID
;
"
)
;
if
(
!
proc
.
isTriangles
(
)
)
{
g
-
>
codeAppendf
(
"
corneridx
*
=
%
i
;
"
proc
.
numInputPoints
(
)
-
1
)
;
}
g
-
>
codeAppendf
(
"
float2
corner
=
pts
[
corneridx
]
;
"
)
;
g
-
>
codeAppendf
(
"
float2
left
=
pts
[
(
corneridx
+
(
%
s
>
0
?
%
i
:
1
)
)
%
%
%
i
]
;
"
wind
.
c_str
(
)
proc
.
numInputPoints
(
)
-
1
proc
.
numInputPoints
(
)
)
;
g
-
>
codeAppendf
(
"
float2
right
=
pts
[
(
corneridx
+
(
%
s
>
0
?
1
:
%
i
)
)
%
%
%
i
]
;
"
wind
.
c_str
(
)
proc
.
numInputPoints
(
)
-
1
proc
.
numInputPoints
(
)
)
;
g
-
>
codeAppend
(
"
float2
leftdir
=
corner
-
left
;
"
)
;
g
-
>
codeAppend
(
"
leftdir
=
(
float2
(
0
)
!
=
leftdir
)
?
normalize
(
leftdir
)
:
float2
(
1
0
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
rightdir
=
right
-
corner
;
"
)
;
g
-
>
codeAppend
(
"
rightdir
=
(
float2
(
0
)
!
=
rightdir
)
?
normalize
(
rightdir
)
:
float2
(
1
0
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
outbloat
=
float2
(
leftdir
.
x
>
rightdir
.
x
?
+
1
:
-
1
"
"
leftdir
.
y
>
rightdir
.
y
?
+
1
:
-
1
)
;
"
)
;
g
-
>
codeAppend
(
"
float2
crossbloat
=
float2
(
-
outbloat
.
y
+
outbloat
.
x
)
;
"
)
;
g
-
>
codeAppend
(
"
half
attenuation
;
{
"
)
;
Shader
:
:
CalcCornerAttenuation
(
g
"
leftdir
"
"
rightdir
"
"
attenuation
"
)
;
g
-
>
codeAppend
(
"
}
"
)
;
if
(
proc
.
isTriangles
(
)
)
{
g
-
>
codeAppend
(
"
half2
left_coverages
;
{
"
)
;
Shader
:
:
CalcEdgeCoveragesAtBloatVertices
(
g
"
left
"
"
corner
"
"
-
outbloat
"
"
-
crossbloat
"
"
left_coverages
"
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppend
(
"
half2
right_coverages
;
{
"
)
;
Shader
:
:
CalcEdgeCoveragesAtBloatVertices
(
g
"
corner
"
"
right
"
"
-
outbloat
"
"
crossbloat
"
"
right_coverages
"
)
;
g
-
>
codeAppend
(
"
}
"
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
-
crossbloat
right_coverages
[
1
]
-
left_coverages
[
1
]
"
"
half2
(
1
+
left_coverages
[
1
]
1
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
outbloat
1
+
left_coverages
[
0
]
+
right_coverages
[
0
]
"
"
half2
(
0
attenuation
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
-
outbloat
-
1
-
left_coverages
[
0
]
-
right_coverages
[
0
]
"
"
half2
(
1
+
left_coverages
[
0
]
+
right_coverages
[
0
]
1
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
crossbloat
left_coverages
[
1
]
-
right_coverages
[
1
]
"
"
half2
(
1
+
right_coverages
[
1
]
1
)
)
;
"
emitVertexFn
)
;
}
else
{
g
-
>
codeAppendf
(
"
%
s
=
-
%
s
;
"
wind
.
c_str
(
)
wind
.
c_str
(
)
)
;
if
(
!
fShader
-
>
calculatesOwnEdgeCoverage
(
)
)
{
g
-
>
codeAppendf
(
"
%
s
=
-
%
s
;
"
fEdgeDistanceEquation
.
c_str
(
)
fEdgeDistanceEquation
.
c_str
(
)
)
;
}
g
-
>
codeAppendf
(
"
%
s
(
corner
-
crossbloat
half2
(
-
1
1
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
outbloat
half2
(
0
attenuation
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
-
outbloat
half2
(
-
1
1
)
)
;
"
emitVertexFn
)
;
g
-
>
codeAppendf
(
"
%
s
(
corner
crossbloat
half2
(
-
1
1
)
)
;
"
emitVertexFn
)
;
}
g
-
>
configure
(
InputType
:
:
kLines
OutputType
:
:
kTriangleStrip
4
proc
.
isTriangles
(
)
?
3
:
2
)
;
}
}
;
void
GrGSCoverageProcessor
:
:
reset
(
PrimitiveType
primitiveType
GrResourceProvider
*
)
{
fPrimitiveType
=
primitiveType
;
if
(
4
=
=
this
-
>
numInputPoints
(
)
|
|
this
-
>
hasInputWeight
(
)
)
{
fInputXOrYValues
=
{
"
x_or_y_values
"
kFloat4_GrVertexAttribType
kFloat4_GrSLType
}
;
GR_STATIC_ASSERT
(
sizeof
(
QuadPointInstance
)
=
=
2
*
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
)
;
GR_STATIC_ASSERT
(
offsetof
(
QuadPointInstance
fY
)
=
=
GrVertexAttribTypeSize
(
kFloat4_GrVertexAttribType
)
)
;
}
else
{
fInputXOrYValues
=
{
"
x_or_y_values
"
kFloat3_GrVertexAttribType
kFloat3_GrSLType
}
;
GR_STATIC_ASSERT
(
sizeof
(
TriPointInstance
)
=
=
2
*
GrVertexAttribTypeSize
(
kFloat3_GrVertexAttribType
)
)
;
}
this
-
>
setVertexAttributes
(
&
fInputXOrYValues
1
)
;
}
void
GrGSCoverageProcessor
:
:
appendMesh
(
sk_sp
<
const
GrGpuBuffer
>
instanceBuffer
int
instanceCount
int
baseInstance
SkTArray
<
GrMesh
>
*
out
)
const
{
GrMesh
&
mesh
=
out
-
>
emplace_back
(
GrPrimitiveType
:
:
kLines
)
;
mesh
.
setNonIndexedNonInstanced
(
instanceCount
*
2
)
;
mesh
.
setVertexData
(
std
:
:
move
(
instanceBuffer
)
baseInstance
*
2
)
;
}
void
GrGSCoverageProcessor
:
:
draw
(
GrOpFlushState
*
flushState
const
GrPipeline
&
pipeline
const
SkIRect
scissorRects
[
]
const
GrMesh
meshes
[
]
int
meshCount
const
SkRect
&
drawBounds
)
const
{
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
fSubpass
=
(
Subpass
)
i
;
this
-
>
GrCCCoverageProcessor
:
:
draw
(
flushState
pipeline
scissorRects
meshes
meshCount
drawBounds
)
;
}
}
GrGLSLPrimitiveProcessor
*
GrGSCoverageProcessor
:
:
onCreateGLSLInstance
(
std
:
:
unique_ptr
<
Shader
>
shader
)
const
{
if
(
Subpass
:
:
kHulls
=
=
fSubpass
)
{
return
this
-
>
isTriangles
(
)
?
(
Impl
*
)
new
TriangleHullImpl
(
std
:
:
move
(
shader
)
)
:
(
Impl
*
)
new
CurveHullImpl
(
std
:
:
move
(
shader
)
)
;
}
SkASSERT
(
Subpass
:
:
kCorners
=
=
fSubpass
)
;
return
new
CornerImpl
(
std
:
:
move
(
shader
)
)
;
}
