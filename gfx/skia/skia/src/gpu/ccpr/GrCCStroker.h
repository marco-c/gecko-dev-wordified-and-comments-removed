#
ifndef
GrCCStroker_DEFINED
#
define
GrCCStroker_DEFINED
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
src
/
gpu
/
GrAllocator
.
h
"
#
include
"
src
/
gpu
/
GrMesh
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCStrokeGeometry
.
h
"
class
GrGpuBuffer
;
class
GrCCCoverageProcessor
;
class
GrOnFlushResourceProvider
;
class
GrOpFlushState
;
class
GrPipeline
;
class
GrPrimitiveProcessor
;
class
SkMatrix
;
class
SkPath
;
class
SkStrokeRec
;
class
GrCCStroker
{
public
:
GrCCStroker
(
int
numPaths
int
numSkPoints
int
numSkVerbs
)
:
fGeometry
(
numSkPoints
numSkVerbs
)
fPathInfos
(
numPaths
)
{
}
void
parseDeviceSpaceStroke
(
const
SkPath
&
const
SkPoint
*
deviceSpacePts
const
SkStrokeRec
&
float
strokeDevWidth
GrScissorTest
const
SkIRect
&
clippedDevIBounds
const
SkIVector
&
devToAtlasOffset
)
;
using
BatchID
=
int
;
BatchID
closeCurrentBatch
(
)
;
bool
prepareToDraw
(
GrOnFlushResourceProvider
*
)
;
void
drawStrokes
(
GrOpFlushState
*
GrCCCoverageProcessor
*
BatchID
const
SkIRect
&
drawBounds
)
const
;
private
:
static
constexpr
int
kNumScissorModes
=
2
;
static
constexpr
BatchID
kEmptyBatchID
=
-
1
;
using
Verb
=
GrCCStrokeGeometry
:
:
Verb
;
using
InstanceTallies
=
GrCCStrokeGeometry
:
:
InstanceTallies
;
struct
PathInfo
{
SkIVector
fDevToAtlasOffset
;
float
fStrokeRadius
;
GrScissorTest
fScissorTest
;
}
;
struct
ScissorSubBatch
{
ScissorSubBatch
(
GrTAllocator
<
InstanceTallies
>
*
alloc
const
InstanceTallies
&
startIndices
const
SkIRect
&
scissor
)
:
fEndInstances
(
&
alloc
-
>
emplace_back
(
startIndices
)
)
fScissor
(
scissor
)
{
}
InstanceTallies
*
fEndInstances
;
SkIRect
fScissor
;
}
;
struct
Batch
{
Batch
(
GrTAllocator
<
InstanceTallies
>
*
alloc
const
InstanceTallies
&
startNonScissorIndices
int
startScissorSubBatch
)
:
fNonScissorEndInstances
(
&
alloc
-
>
emplace_back
(
startNonScissorIndices
)
)
fEndScissorSubBatch
(
startScissorSubBatch
)
{
}
InstanceTallies
*
fNonScissorEndInstances
;
int
fEndScissorSubBatch
;
}
;
class
InstanceBufferBuilder
;
void
appendStrokeMeshesToBuffers
(
int
numSegmentsLog2
const
Batch
&
const
InstanceTallies
*
startIndices
[
2
]
int
startScissorSubBatch
const
SkIRect
&
drawBounds
)
const
;
void
flushBufferedMeshesAsStrokes
(
const
GrPrimitiveProcessor
&
GrOpFlushState
*
const
GrPipeline
&
const
SkIRect
&
drawBounds
)
const
;
template
<
int
GrCCStrokeGeometry
:
:
InstanceTallies
:
:
*
InstanceType
>
void
drawConnectingGeometry
(
GrOpFlushState
*
const
GrPipeline
&
const
GrCCCoverageProcessor
&
const
Batch
&
const
InstanceTallies
*
startIndices
[
2
]
int
startScissorSubBatch
const
SkIRect
&
drawBounds
)
const
;
GrCCStrokeGeometry
fGeometry
;
SkSTArray
<
32
PathInfo
>
fPathInfos
;
SkSTArray
<
32
Batch
>
fBatches
;
SkSTArray
<
32
ScissorSubBatch
>
fScissorSubBatches
;
int
fMaxNumScissorSubBatches
=
0
;
bool
fHasOpenBatch
=
false
;
const
InstanceTallies
fZeroTallies
=
InstanceTallies
(
)
;
GrSTAllocator
<
128
InstanceTallies
>
fTalliesAllocator
;
const
InstanceTallies
*
fInstanceCounts
[
kNumScissorModes
]
=
{
&
fZeroTallies
&
fZeroTallies
}
;
sk_sp
<
GrGpuBuffer
>
fInstanceBuffer
;
InstanceTallies
fBaseInstances
[
kNumScissorModes
]
;
mutable
SkSTArray
<
32
GrMesh
>
fMeshesBuffer
;
mutable
SkSTArray
<
32
SkIRect
>
fScissorsBuffer
;
}
;
#
endif
