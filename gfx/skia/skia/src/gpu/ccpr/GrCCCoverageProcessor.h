#
ifndef
GrCCCoverageProcessor_DEFINED
#
define
GrCCCoverageProcessor_DEFINED
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
GrPipeline
.
h
"
#
include
"
src
/
gpu
/
GrShaderCaps
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVarying
.
h
"
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLVertexGeoBuilder
;
class
GrMesh
;
class
GrOpFlushState
;
class
GrCCCoverageProcessor
:
public
GrGeometryProcessor
{
public
:
enum
class
PrimitiveType
{
kTriangles
kWeightedTriangles
kQuadratics
kCubics
kConics
}
;
static
const
char
*
PrimitiveTypeName
(
PrimitiveType
)
;
struct
TriPointInstance
{
float
fValues
[
6
]
;
enum
class
Ordering
:
bool
{
kXYTransposed
kXYInterleaved
}
;
void
set
(
const
SkPoint
[
3
]
const
Sk2f
&
translate
Ordering
)
;
void
set
(
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
const
Sk2f
&
translate
Ordering
)
;
void
set
(
const
Sk2f
&
P0
const
Sk2f
&
P1
const
Sk2f
&
P2
const
Sk2f
&
translate
Ordering
)
;
}
;
struct
QuadPointInstance
{
float
fX
[
4
]
;
float
fY
[
4
]
;
void
set
(
const
SkPoint
[
4
]
float
dx
float
dy
)
;
void
setW
(
const
SkPoint
[
3
]
const
Sk2f
&
trans
float
w
)
;
void
setW
(
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
const
Sk2f
&
trans
float
w
)
;
void
setW
(
const
Sk2f
&
P0
const
Sk2f
&
P1
const
Sk2f
&
P2
const
Sk2f
&
trans
float
w
)
;
}
;
virtual
void
reset
(
PrimitiveType
GrResourceProvider
*
)
=
0
;
PrimitiveType
primitiveType
(
)
const
{
return
fPrimitiveType
;
}
int
numInputPoints
(
)
const
{
return
PrimitiveType
:
:
kCubics
=
=
fPrimitiveType
?
4
:
3
;
}
bool
isTriangles
(
)
const
{
return
PrimitiveType
:
:
kTriangles
=
=
fPrimitiveType
|
|
PrimitiveType
:
:
kWeightedTriangles
=
=
fPrimitiveType
;
}
int
hasInputWeight
(
)
const
{
return
PrimitiveType
:
:
kWeightedTriangles
=
=
fPrimitiveType
|
|
PrimitiveType
:
:
kConics
=
=
fPrimitiveType
;
}
const
char
*
name
(
)
const
override
{
return
PrimitiveTypeName
(
fPrimitiveType
)
;
}
#
ifdef
SK_DEBUG
SkString
dumpInfo
(
)
const
override
{
return
SkStringPrintf
(
"
%
s
\
n
%
s
"
this
-
>
name
(
)
this
-
>
INHERITED
:
:
dumpInfo
(
)
.
c_str
(
)
)
;
}
#
endif
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
b
)
const
override
{
SkDEBUGCODE
(
this
-
>
getDebugBloatKey
(
b
)
)
;
b
-
>
add32
(
(
int
)
fPrimitiveType
)
;
}
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrShaderCaps
&
)
const
final
;
#
ifdef
SK_DEBUG
void
enableDebugBloat
(
float
debugBloat
)
{
fDebugBloat
=
debugBloat
;
}
bool
debugBloatEnabled
(
)
const
{
return
fDebugBloat
>
0
;
}
float
debugBloat
(
)
const
{
SkASSERT
(
this
-
>
debugBloatEnabled
(
)
)
;
return
fDebugBloat
;
}
void
getDebugBloatKey
(
GrProcessorKeyBuilder
*
b
)
const
{
uint32_t
bloatBits
;
memcpy
(
&
bloatBits
&
fDebugBloat
4
)
;
b
-
>
add32
(
bloatBits
)
;
}
#
endif
virtual
void
appendMesh
(
sk_sp
<
const
GrGpuBuffer
>
instanceBuffer
int
instanceCount
int
baseInstance
SkTArray
<
GrMesh
>
*
out
)
const
=
0
;
virtual
void
draw
(
GrOpFlushState
*
const
GrPipeline
&
const
SkIRect
scissorRects
[
]
const
GrMesh
[
]
int
meshCount
const
SkRect
&
drawBounds
)
const
;
class
Shader
{
public
:
virtual
bool
calculatesOwnEdgeCoverage
(
)
const
{
return
false
;
}
virtual
void
emitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
*
outHull4
=
nullptr
)
const
{
SkASSERT
(
!
outHull4
)
;
}
void
emitVaryings
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVarying
:
:
Scope
scope
SkString
*
code
const
char
*
position
const
char
*
coverage
const
char
*
cornerCoverage
const
char
*
wind
)
{
SkASSERT
(
GrGLSLVarying
:
:
Scope
:
:
kVertToGeo
!
=
scope
)
;
this
-
>
onEmitVaryings
(
varyingHandler
scope
code
position
coverage
cornerCoverage
wind
)
;
}
virtual
void
emitFragmentCoverageCode
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
=
0
;
virtual
void
emitSampleMaskCode
(
GrGLSLFPFragmentBuilder
*
)
const
=
0
;
static
void
CalcWind
(
const
GrCCCoverageProcessor
&
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
outputWind
)
;
static
void
CalcEdgeCoverageAtBloatVertex
(
GrGLSLVertexGeoBuilder
*
const
char
*
leftPt
const
char
*
rightPt
const
char
*
rasterVertexDir
const
char
*
outputCoverage
)
;
static
void
CalcEdgeCoveragesAtBloatVertices
(
GrGLSLVertexGeoBuilder
*
const
char
*
leftPt
const
char
*
rightPt
const
char
*
bloatDir1
const
char
*
bloatDir2
const
char
*
outputCoverages
)
;
static
void
CalcCornerAttenuation
(
GrGLSLVertexGeoBuilder
*
const
char
*
leftDir
const
char
*
rightDir
const
char
*
outputAttenuation
)
;
virtual
~
Shader
(
)
{
}
protected
:
virtual
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
const
char
*
position
const
char
*
coverage
const
char
*
cornerCoverage
const
char
*
wind
)
=
0
;
const
char
*
OutName
(
const
GrGLSLVarying
&
varying
)
const
{
using
Scope
=
GrGLSLVarying
:
:
Scope
;
SkASSERT
(
Scope
:
:
kVertToGeo
!
=
varying
.
scope
(
)
)
;
return
Scope
:
:
kGeoToFrag
=
=
varying
.
scope
(
)
?
varying
.
gsOut
(
)
:
varying
.
vsOut
(
)
;
}
inline
static
SkString
&
AccessCodeString
(
GrGLSLShaderBuilder
*
s
)
{
return
s
-
>
code
(
)
;
}
}
;
protected
:
static
constexpr
float
kAABloatRadius
=
0
.
491111f
;
GrCCCoverageProcessor
(
ClassID
classID
)
:
INHERITED
(
classID
)
{
}
virtual
GrGLSLPrimitiveProcessor
*
onCreateGLSLInstance
(
std
:
:
unique_ptr
<
Shader
>
)
const
=
0
;
inline
static
SkString
&
AccessCodeString
(
GrGLSLShaderBuilder
*
s
)
{
return
s
-
>
code
(
)
;
}
PrimitiveType
fPrimitiveType
;
SkDEBUGCODE
(
float
fDebugBloat
=
0
)
;
class
TriangleShader
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
inline
const
char
*
GrCCCoverageProcessor
:
:
PrimitiveTypeName
(
PrimitiveType
type
)
{
switch
(
type
)
{
case
PrimitiveType
:
:
kTriangles
:
return
"
kTriangles
"
;
case
PrimitiveType
:
:
kWeightedTriangles
:
return
"
kWeightedTriangles
"
;
case
PrimitiveType
:
:
kQuadratics
:
return
"
kQuadratics
"
;
case
PrimitiveType
:
:
kCubics
:
return
"
kCubics
"
;
case
PrimitiveType
:
:
kConics
:
return
"
kConics
"
;
}
SK_ABORT
(
"
Invalid
PrimitiveType
"
)
;
}
inline
void
GrCCCoverageProcessor
:
:
TriPointInstance
:
:
set
(
const
SkPoint
p
[
3
]
const
Sk2f
&
translate
Ordering
ordering
)
{
this
-
>
set
(
p
[
0
]
p
[
1
]
p
[
2
]
translate
ordering
)
;
}
inline
void
GrCCCoverageProcessor
:
:
TriPointInstance
:
:
set
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
const
Sk2f
&
translate
Ordering
ordering
)
{
Sk2f
P0
=
Sk2f
:
:
Load
(
&
p0
)
;
Sk2f
P1
=
Sk2f
:
:
Load
(
&
p1
)
;
Sk2f
P2
=
Sk2f
:
:
Load
(
&
p2
)
;
this
-
>
set
(
P0
P1
P2
translate
ordering
)
;
}
inline
void
GrCCCoverageProcessor
:
:
TriPointInstance
:
:
set
(
const
Sk2f
&
P0
const
Sk2f
&
P1
const
Sk2f
&
P2
const
Sk2f
&
translate
Ordering
ordering
)
{
if
(
Ordering
:
:
kXYTransposed
=
=
ordering
)
{
Sk2f
:
:
Store3
(
fValues
P0
+
translate
P1
+
translate
P2
+
translate
)
;
}
else
{
(
P0
+
translate
)
.
store
(
fValues
)
;
(
P1
+
translate
)
.
store
(
fValues
+
2
)
;
(
P2
+
translate
)
.
store
(
fValues
+
4
)
;
}
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
set
(
const
SkPoint
p
[
4
]
float
dx
float
dy
)
{
Sk4f
X
Y
;
Sk4f
:
:
Load2
(
p
&
X
&
Y
)
;
(
X
+
dx
)
.
store
(
&
fX
)
;
(
Y
+
dy
)
.
store
(
&
fY
)
;
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
setW
(
const
SkPoint
p
[
3
]
const
Sk2f
&
trans
float
w
)
{
this
-
>
setW
(
p
[
0
]
p
[
1
]
p
[
2
]
trans
w
)
;
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
setW
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
const
Sk2f
&
trans
float
w
)
{
Sk2f
P0
=
Sk2f
:
:
Load
(
&
p0
)
;
Sk2f
P1
=
Sk2f
:
:
Load
(
&
p1
)
;
Sk2f
P2
=
Sk2f
:
:
Load
(
&
p2
)
;
this
-
>
setW
(
P0
P1
P2
trans
w
)
;
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
setW
(
const
Sk2f
&
P0
const
Sk2f
&
P1
const
Sk2f
&
P2
const
Sk2f
&
trans
float
w
)
{
Sk2f
W
=
Sk2f
(
w
)
;
Sk2f
:
:
Store4
(
this
P0
+
trans
P1
+
trans
P2
+
trans
W
)
;
}
#
endif
