#
ifndef
GrCCCoverageProcessor_DEFINED
#
define
GrCCCoverageProcessor_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrGeometryProcessor
.
h
"
#
include
"
GrShaderCaps
.
h
"
#
include
"
SkNx
.
h
"
#
include
"
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
glsl
/
GrGLSLVarying
.
h
"
class
GrGLSLFPFragmentBuilder
;
class
GrGLSLVertexGeoBuilder
;
class
GrMesh
;
class
GrCCCoverageProcessor
:
public
GrGeometryProcessor
{
public
:
struct
TriPointInstance
{
float
fX
[
3
]
;
float
fY
[
3
]
;
void
set
(
const
SkPoint
[
3
]
const
Sk2f
&
trans
)
;
void
set
(
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
const
Sk2f
&
trans
)
;
}
;
struct
QuadPointInstance
{
float
fX
[
4
]
;
float
fY
[
4
]
;
void
set
(
const
SkPoint
[
4
]
float
dx
float
dy
)
;
void
set
(
const
SkPoint
&
const
SkPoint
&
const
SkPoint
&
const
Sk2f
&
trans
float
w
)
;
}
;
enum
class
RenderPass
{
kTriangleHulls
kQuadraticHulls
kCubicHulls
kTriangleEdges
kTriangleCorners
kQuadraticCorners
kCubicCorners
}
;
static
bool
RenderPassIsCubic
(
RenderPass
)
;
static
const
char
*
RenderPassName
(
RenderPass
)
;
constexpr
static
bool
DoesRenderPass
(
RenderPass
renderPass
const
GrCaps
&
caps
)
{
return
RenderPass
:
:
kTriangleEdges
!
=
renderPass
|
|
caps
.
shaderCaps
(
)
-
>
geometryShaderSupport
(
)
;
}
enum
class
WindMethod
:
bool
{
kCrossProduct
kInstanceData
}
;
GrCCCoverageProcessor
(
GrResourceProvider
*
rp
RenderPass
pass
WindMethod
windMethod
)
:
INHERITED
(
kGrCCCoverageProcessor_ClassID
)
fRenderPass
(
pass
)
fWindMethod
(
windMethod
)
fImpl
(
rp
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
geometryShaderSupport
(
)
?
Impl
:
:
kGeometryShader
:
Impl
:
:
kVertexShader
)
{
SkASSERT
(
DoesRenderPass
(
pass
*
rp
-
>
caps
(
)
)
)
;
if
(
Impl
:
:
kGeometryShader
=
=
fImpl
)
{
this
-
>
initGS
(
)
;
}
else
{
this
-
>
initVS
(
rp
)
;
}
}
void
appendMesh
(
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
SkTArray
<
GrMesh
>
*
out
)
{
if
(
Impl
:
:
kGeometryShader
=
=
fImpl
)
{
this
-
>
appendGSMesh
(
instanceBuffer
instanceCount
baseInstance
out
)
;
}
else
{
this
-
>
appendVSMesh
(
instanceBuffer
instanceCount
baseInstance
out
)
;
}
}
const
char
*
name
(
)
const
override
{
return
RenderPassName
(
fRenderPass
)
;
}
SkString
dumpInfo
(
)
const
override
{
return
SkStringPrintf
(
"
%
s
\
n
%
s
"
this
-
>
name
(
)
this
-
>
INHERITED
:
:
dumpInfo
(
)
.
c_str
(
)
)
;
}
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
override
;
GrGLSLPrimitiveProcessor
*
createGLSLInstance
(
const
GrShaderCaps
&
)
const
override
;
#
ifdef
SK_DEBUG
void
enableDebugVisualizations
(
float
debugBloat
)
{
fDebugBloat
=
debugBloat
;
}
bool
debugVisualizationsEnabled
(
)
const
{
return
fDebugBloat
>
0
;
}
float
debugBloat
(
)
const
{
SkASSERT
(
this
-
>
debugVisualizationsEnabled
(
)
)
;
return
fDebugBloat
;
}
#
endif
class
Shader
{
public
:
union
GeometryVars
{
struct
{
const
char
*
fAlternatePoints
;
}
fHullVars
;
struct
{
const
char
*
fPoint
;
}
fCornerVars
;
GeometryVars
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
}
;
virtual
void
emitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
repetitionID
const
char
*
wind
GeometryVars
*
)
const
{
}
void
emitVaryings
(
GrGLSLVaryingHandler
*
varyingHandler
GrGLSLVarying
:
:
Scope
scope
SkString
*
code
const
char
*
position
const
char
*
inputCoverage
const
char
*
wind
)
{
SkASSERT
(
GrGLSLVarying
:
:
Scope
:
:
kVertToGeo
!
=
scope
)
;
this
-
>
onEmitVaryings
(
varyingHandler
scope
code
position
inputCoverage
wind
)
;
}
void
emitFragmentCode
(
const
GrCCCoverageProcessor
&
proc
GrGLSLFPFragmentBuilder
*
const
char
*
skOutputColor
const
char
*
skOutputCoverage
)
const
;
static
void
EmitEdgeDistanceEquation
(
GrGLSLVertexGeoBuilder
*
const
char
*
leftPt
const
char
*
rightPt
const
char
*
outputDistanceEquation
)
;
virtual
~
Shader
(
)
{
}
protected
:
virtual
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
const
char
*
position
const
char
*
inputCoverage
const
char
*
wind
)
=
0
;
virtual
void
onEmitFragmentCode
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
=
0
;
const
char
*
OutName
(
const
GrGLSLVarying
&
varying
)
const
{
using
Scope
=
GrGLSLVarying
:
:
Scope
;
SkASSERT
(
Scope
:
:
kVertToGeo
!
=
varying
.
scope
(
)
)
;
return
Scope
:
:
kGeoToFrag
=
=
varying
.
scope
(
)
?
varying
.
gsOut
(
)
:
varying
.
vsOut
(
)
;
}
static
int
DefineSoftSampleLocations
(
GrGLSLFPFragmentBuilder
*
f
const
char
*
samplesName
)
;
}
;
class
GSImpl
;
class
VSImpl
;
private
:
static
constexpr
float
kAABloatRadius
=
0
.
491111f
;
int
numInputPoints
(
)
const
{
return
RenderPassIsCubic
(
fRenderPass
)
?
4
:
3
;
}
enum
class
Impl
:
bool
{
kGeometryShader
kVertexShader
}
;
void
initGS
(
)
;
void
initVS
(
GrResourceProvider
*
)
;
void
appendGSMesh
(
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
SkTArray
<
GrMesh
>
*
out
)
const
;
void
appendVSMesh
(
GrBuffer
*
instanceBuffer
int
instanceCount
int
baseInstance
SkTArray
<
GrMesh
>
*
out
)
const
;
GrGLSLPrimitiveProcessor
*
createGSImpl
(
std
:
:
unique_ptr
<
Shader
>
)
const
;
GrGLSLPrimitiveProcessor
*
createVSImpl
(
std
:
:
unique_ptr
<
Shader
>
)
const
;
const
RenderPass
fRenderPass
;
const
WindMethod
fWindMethod
;
const
Impl
fImpl
;
SkDEBUGCODE
(
float
fDebugBloat
=
0
)
;
sk_sp
<
const
GrBuffer
>
fVertexBuffer
;
sk_sp
<
const
GrBuffer
>
fIndexBuffer
;
int
fNumIndicesPerInstance
;
GrPrimitiveType
fPrimitiveType
;
typedef
GrGeometryProcessor
INHERITED
;
}
;
inline
void
GrCCCoverageProcessor
:
:
TriPointInstance
:
:
set
(
const
SkPoint
p
[
3
]
const
Sk2f
&
trans
)
{
this
-
>
set
(
p
[
0
]
p
[
1
]
p
[
2
]
trans
)
;
}
inline
void
GrCCCoverageProcessor
:
:
TriPointInstance
:
:
set
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
const
Sk2f
&
trans
)
{
Sk2f
P0
=
Sk2f
:
:
Load
(
&
p0
)
+
trans
;
Sk2f
P1
=
Sk2f
:
:
Load
(
&
p1
)
+
trans
;
Sk2f
P2
=
Sk2f
:
:
Load
(
&
p2
)
+
trans
;
Sk2f
:
:
Store3
(
this
P0
P1
P2
)
;
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
set
(
const
SkPoint
p
[
4
]
float
dx
float
dy
)
{
Sk4f
X
Y
;
Sk4f
:
:
Load2
(
p
&
X
&
Y
)
;
(
X
+
dx
)
.
store
(
&
fX
)
;
(
Y
+
dy
)
.
store
(
&
fY
)
;
}
inline
void
GrCCCoverageProcessor
:
:
QuadPointInstance
:
:
set
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
const
Sk2f
&
trans
float
w
)
{
Sk2f
P0
=
Sk2f
:
:
Load
(
&
p0
)
+
trans
;
Sk2f
P1
=
Sk2f
:
:
Load
(
&
p1
)
+
trans
;
Sk2f
P2
=
Sk2f
:
:
Load
(
&
p2
)
+
trans
;
Sk2f
W
=
Sk2f
(
w
)
;
Sk2f
:
:
Store4
(
this
P0
P1
P2
W
)
;
}
inline
bool
GrCCCoverageProcessor
:
:
RenderPassIsCubic
(
RenderPass
pass
)
{
switch
(
pass
)
{
case
RenderPass
:
:
kTriangleHulls
:
case
RenderPass
:
:
kTriangleEdges
:
case
RenderPass
:
:
kTriangleCorners
:
case
RenderPass
:
:
kQuadraticHulls
:
case
RenderPass
:
:
kQuadraticCorners
:
return
false
;
case
RenderPass
:
:
kCubicHulls
:
case
RenderPass
:
:
kCubicCorners
:
return
true
;
}
SK_ABORT
(
"
Invalid
RenderPass
"
)
;
return
false
;
}
inline
const
char
*
GrCCCoverageProcessor
:
:
RenderPassName
(
RenderPass
pass
)
{
switch
(
pass
)
{
case
RenderPass
:
:
kTriangleHulls
:
return
"
kTriangleHulls
"
;
case
RenderPass
:
:
kTriangleEdges
:
return
"
kTriangleEdges
"
;
case
RenderPass
:
:
kTriangleCorners
:
return
"
kTriangleCorners
"
;
case
RenderPass
:
:
kQuadraticHulls
:
return
"
kQuadraticHulls
"
;
case
RenderPass
:
:
kQuadraticCorners
:
return
"
kQuadraticCorners
"
;
case
RenderPass
:
:
kCubicHulls
:
return
"
kCubicHulls
"
;
case
RenderPass
:
:
kCubicCorners
:
return
"
kCubicCorners
"
;
}
SK_ABORT
(
"
Invalid
RenderPass
"
)
;
return
"
"
;
}
#
endif
