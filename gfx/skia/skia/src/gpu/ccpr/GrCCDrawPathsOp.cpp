#
include
"
GrCCDrawPathsOp
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrOpFlushState
.
h
"
#
include
"
GrRecordingContext
.
h
"
#
include
"
GrRecordingContextPriv
.
h
"
#
include
"
ccpr
/
GrCCPathCache
.
h
"
#
include
"
ccpr
/
GrCCPerFlushResources
.
h
"
#
include
"
ccpr
/
GrCoverageCountingPathRenderer
.
h
"
static
bool
has_coord_transforms
(
const
GrPaint
&
paint
)
{
GrFragmentProcessor
:
:
Iter
iter
(
paint
)
;
while
(
const
GrFragmentProcessor
*
fp
=
iter
.
next
(
)
)
{
if
(
!
fp
-
>
coordTransforms
(
)
.
empty
(
)
)
{
return
true
;
}
}
return
false
;
}
std
:
:
unique_ptr
<
GrCCDrawPathsOp
>
GrCCDrawPathsOp
:
:
Make
(
GrRecordingContext
*
context
const
SkIRect
&
clipIBounds
const
SkMatrix
&
m
const
GrShape
&
shape
GrPaint
&
&
paint
)
{
SkRect
conservativeDevBounds
;
m
.
mapRect
(
&
conservativeDevBounds
shape
.
bounds
(
)
)
;
const
SkStrokeRec
&
stroke
=
shape
.
style
(
)
.
strokeRec
(
)
;
float
strokeDevWidth
=
0
;
float
conservativeInflationRadius
=
0
;
if
(
!
stroke
.
isFillStyle
(
)
)
{
strokeDevWidth
=
GrCoverageCountingPathRenderer
:
:
GetStrokeDevWidth
(
m
stroke
&
conservativeInflationRadius
)
;
conservativeDevBounds
.
outset
(
conservativeInflationRadius
conservativeInflationRadius
)
;
}
std
:
:
unique_ptr
<
GrCCDrawPathsOp
>
op
;
float
conservativeSize
=
SkTMax
(
conservativeDevBounds
.
height
(
)
conservativeDevBounds
.
width
(
)
)
;
if
(
conservativeSize
>
GrCoverageCountingPathRenderer
:
:
kPathCropThreshold
)
{
SkPath
croppedDevPath
;
shape
.
asPath
(
&
croppedDevPath
)
;
croppedDevPath
.
transform
(
m
&
croppedDevPath
)
;
SkIRect
cropBox
=
clipIBounds
;
GrShape
croppedDevShape
;
if
(
stroke
.
isFillStyle
(
)
)
{
GrCoverageCountingPathRenderer
:
:
CropPath
(
croppedDevPath
cropBox
&
croppedDevPath
)
;
croppedDevShape
=
GrShape
(
croppedDevPath
)
;
conservativeDevBounds
=
croppedDevShape
.
bounds
(
)
;
}
else
{
int
r
=
SkScalarCeilToInt
(
conservativeInflationRadius
)
;
cropBox
.
outset
(
r
r
)
;
GrCoverageCountingPathRenderer
:
:
CropPath
(
croppedDevPath
cropBox
&
croppedDevPath
)
;
SkStrokeRec
devStroke
=
stroke
;
devStroke
.
setStrokeStyle
(
strokeDevWidth
)
;
croppedDevShape
=
GrShape
(
croppedDevPath
GrStyle
(
devStroke
nullptr
)
)
;
conservativeDevBounds
=
croppedDevPath
.
getBounds
(
)
;
conservativeDevBounds
.
outset
(
conservativeInflationRadius
conservativeInflationRadius
)
;
}
return
InternalMake
(
context
clipIBounds
SkMatrix
:
:
I
(
)
croppedDevShape
strokeDevWidth
conservativeDevBounds
std
:
:
move
(
paint
)
)
;
}
return
InternalMake
(
context
clipIBounds
m
shape
strokeDevWidth
conservativeDevBounds
std
:
:
move
(
paint
)
)
;
}
std
:
:
unique_ptr
<
GrCCDrawPathsOp
>
GrCCDrawPathsOp
:
:
InternalMake
(
GrRecordingContext
*
context
const
SkIRect
&
clipIBounds
const
SkMatrix
&
m
const
GrShape
&
shape
float
strokeDevWidth
const
SkRect
&
conservativeDevBounds
GrPaint
&
&
paint
)
{
SkASSERT
(
SkTMax
(
conservativeDevBounds
.
height
(
)
conservativeDevBounds
.
width
(
)
)
<
GrCoverageCountingPathRenderer
:
:
kPathCropThreshold
+
GrCoverageCountingPathRenderer
:
:
kMaxBoundsInflationFromStroke
*
2
+
1
)
;
SkIRect
shapeConservativeIBounds
;
conservativeDevBounds
.
roundOut
(
&
shapeConservativeIBounds
)
;
SkIRect
maskDevIBounds
;
if
(
!
maskDevIBounds
.
intersect
(
clipIBounds
shapeConservativeIBounds
)
)
{
return
nullptr
;
}
GrOpMemoryPool
*
pool
=
context
-
>
priv
(
)
.
opMemoryPool
(
)
;
return
pool
-
>
allocate
<
GrCCDrawPathsOp
>
(
m
shape
strokeDevWidth
shapeConservativeIBounds
maskDevIBounds
conservativeDevBounds
std
:
:
move
(
paint
)
)
;
}
GrCCDrawPathsOp
:
:
GrCCDrawPathsOp
(
const
SkMatrix
&
m
const
GrShape
&
shape
float
strokeDevWidth
const
SkIRect
&
shapeConservativeIBounds
const
SkIRect
&
maskDevIBounds
const
SkRect
&
conservativeDevBounds
GrPaint
&
&
paint
)
:
GrDrawOp
(
ClassID
(
)
)
fViewMatrixIfUsingLocalCoords
(
has_coord_transforms
(
paint
)
?
m
:
SkMatrix
:
:
I
(
)
)
fDraws
(
m
shape
strokeDevWidth
shapeConservativeIBounds
maskDevIBounds
paint
.
getColor4f
(
)
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
SkDEBUGCODE
(
fBaseInstance
=
-
1
)
;
this
-
>
setBounds
(
conservativeDevBounds
GrOp
:
:
HasAABloat
:
:
kYes
GrOp
:
:
IsZeroArea
:
:
kNo
)
;
}
GrCCDrawPathsOp
:
:
~
GrCCDrawPathsOp
(
)
{
if
(
fOwningPerOpListPaths
)
{
fOwningPerOpListPaths
-
>
fDrawOps
.
remove
(
this
)
;
}
}
GrCCDrawPathsOp
:
:
SingleDraw
:
:
SingleDraw
(
const
SkMatrix
&
m
const
GrShape
&
shape
float
strokeDevWidth
const
SkIRect
&
shapeConservativeIBounds
const
SkIRect
&
maskDevIBounds
const
SkPMColor4f
&
color
)
:
fMatrix
(
m
)
fShape
(
shape
)
fStrokeDevWidth
(
strokeDevWidth
)
fShapeConservativeIBounds
(
shapeConservativeIBounds
)
fMaskDevIBounds
(
maskDevIBounds
)
fColor
(
color
)
{
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
if
(
fShape
.
hasUnstyledKey
(
)
)
{
fMatrix
.
setTranslateX
(
SkScalarRoundToScalar
(
fMatrix
.
getTranslateX
(
)
)
)
;
fMatrix
.
setTranslateY
(
SkScalarRoundToScalar
(
fMatrix
.
getTranslateY
(
)
)
)
;
}
#
endif
}
GrProcessorSet
:
:
Analysis
GrCCDrawPathsOp
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrFSAAType
fsaaType
)
{
SkASSERT
(
1
=
=
fNumDraws
)
;
return
fDraws
.
head
(
)
.
finalize
(
caps
clip
fsaaType
&
fProcessors
)
;
}
GrProcessorSet
:
:
Analysis
GrCCDrawPathsOp
:
:
SingleDraw
:
:
finalize
(
const
GrCaps
&
caps
const
GrAppliedClip
*
clip
GrFSAAType
fsaaType
GrProcessorSet
*
processors
)
{
const
GrProcessorSet
:
:
Analysis
&
analysis
=
processors
-
>
finalize
(
fColor
GrProcessorAnalysisCoverage
:
:
kSingleChannel
clip
&
GrUserStencilSettings
:
:
kUnused
fsaaType
caps
&
fColor
)
;
if
(
analysis
.
isCompatibleWithCoverageAsAlpha
(
)
&
&
!
fShape
.
style
(
)
.
strokeRec
(
)
.
isFillStyle
(
)
&
&
fStrokeDevWidth
<
1
)
{
SkASSERT
(
!
fCacheEntry
)
;
SkASSERT
(
SkStrokeRec
:
:
kStroke_Style
=
=
fShape
.
style
(
)
.
strokeRec
(
)
.
getStyle
(
)
)
;
SkPath
path
;
fShape
.
asPath
(
&
path
)
;
SkStrokeRec
hairlineStroke
=
fShape
.
style
(
)
.
strokeRec
(
)
;
hairlineStroke
.
setStrokeStyle
(
0
)
;
float
coverage
=
fStrokeDevWidth
;
fShape
=
GrShape
(
path
GrStyle
(
hairlineStroke
nullptr
)
)
;
fStrokeDevWidth
=
1
;
fColor
=
fColor
*
coverage
;
}
return
analysis
;
}
GrOp
:
:
CombineResult
GrCCDrawPathsOp
:
:
onCombineIfPossible
(
GrOp
*
op
const
GrCaps
&
)
{
GrCCDrawPathsOp
*
that
=
op
-
>
cast
<
GrCCDrawPathsOp
>
(
)
;
SkASSERT
(
fOwningPerOpListPaths
)
;
SkASSERT
(
fNumDraws
)
;
SkASSERT
(
!
that
-
>
fOwningPerOpListPaths
|
|
that
-
>
fOwningPerOpListPaths
=
=
fOwningPerOpListPaths
)
;
SkASSERT
(
that
-
>
fNumDraws
)
;
if
(
fProcessors
!
=
that
-
>
fProcessors
|
|
fViewMatrixIfUsingLocalCoords
!
=
that
-
>
fViewMatrixIfUsingLocalCoords
)
{
return
CombineResult
:
:
kCannotCombine
;
}
fDraws
.
append
(
std
:
:
move
(
that
-
>
fDraws
)
&
fOwningPerOpListPaths
-
>
fAllocator
)
;
SkDEBUGCODE
(
fNumDraws
+
=
that
-
>
fNumDraws
)
;
SkDEBUGCODE
(
that
-
>
fNumDraws
=
0
)
;
return
CombineResult
:
:
kMerged
;
}
void
GrCCDrawPathsOp
:
:
addToOwningPerOpListPaths
(
sk_sp
<
GrCCPerOpListPaths
>
owningPerOpListPaths
)
{
SkASSERT
(
1
=
=
fNumDraws
)
;
SkASSERT
(
!
fOwningPerOpListPaths
)
;
fOwningPerOpListPaths
=
std
:
:
move
(
owningPerOpListPaths
)
;
fOwningPerOpListPaths
-
>
fDrawOps
.
addToTail
(
this
)
;
}
void
GrCCDrawPathsOp
:
:
accountForOwnPaths
(
GrCCPathCache
*
pathCache
GrOnFlushResourceProvider
*
onFlushRP
GrCCPerFlushResourceSpecs
*
specs
)
{
for
(
SingleDraw
&
draw
:
fDraws
)
{
draw
.
accountForOwnPath
(
pathCache
onFlushRP
specs
)
;
}
}
void
GrCCDrawPathsOp
:
:
SingleDraw
:
:
accountForOwnPath
(
GrCCPathCache
*
pathCache
GrOnFlushResourceProvider
*
onFlushRP
GrCCPerFlushResourceSpecs
*
specs
)
{
using
CoverageType
=
GrCCAtlas
:
:
CoverageType
;
SkPath
path
;
fShape
.
asPath
(
&
path
)
;
SkASSERT
(
!
fCacheEntry
)
;
if
(
pathCache
)
{
fCacheEntry
=
pathCache
-
>
find
(
onFlushRP
fShape
fMaskDevIBounds
fMatrix
&
fCachedMaskShift
)
;
}
if
(
fCacheEntry
)
{
if
(
const
GrCCCachedAtlas
*
cachedAtlas
=
fCacheEntry
-
>
cachedAtlas
(
)
)
{
SkASSERT
(
cachedAtlas
-
>
getOnFlushProxy
(
)
)
;
if
(
CoverageType
:
:
kA8_LiteralCoverage
=
=
cachedAtlas
-
>
coverageType
(
)
)
{
+
+
specs
-
>
fNumCachedPaths
;
}
else
{
int
idx
=
(
fShape
.
style
(
)
.
strokeRec
(
)
.
isFillStyle
(
)
)
?
GrCCPerFlushResourceSpecs
:
:
kFillIdx
:
GrCCPerFlushResourceSpecs
:
:
kStrokeIdx
;
+
+
specs
-
>
fNumCopiedPaths
[
idx
]
;
specs
-
>
fCopyPathStats
[
idx
]
.
statPath
(
path
)
;
specs
-
>
fCopyAtlasSpecs
.
accountForSpace
(
fCacheEntry
-
>
width
(
)
fCacheEntry
-
>
height
(
)
)
;
fDoCopyToA8Coverage
=
true
;
}
return
;
}
if
(
this
-
>
shouldCachePathMask
(
onFlushRP
-
>
caps
(
)
-
>
maxRenderTargetSize
(
)
)
)
{
fDoCachePathMask
=
true
;
fMaskDevIBounds
=
fShapeConservativeIBounds
;
}
}
int
idx
=
(
fShape
.
style
(
)
.
strokeRec
(
)
.
isFillStyle
(
)
)
?
GrCCPerFlushResourceSpecs
:
:
kFillIdx
:
GrCCPerFlushResourceSpecs
:
:
kStrokeIdx
;
+
+
specs
-
>
fNumRenderedPaths
[
idx
]
;
specs
-
>
fRenderedPathStats
[
idx
]
.
statPath
(
path
)
;
specs
-
>
fRenderedAtlasSpecs
.
accountForSpace
(
fMaskDevIBounds
.
width
(
)
fMaskDevIBounds
.
height
(
)
)
;
}
bool
GrCCDrawPathsOp
:
:
SingleDraw
:
:
shouldCachePathMask
(
int
maxRenderTargetSize
)
const
{
SkASSERT
(
fCacheEntry
)
;
SkASSERT
(
!
fCacheEntry
-
>
cachedAtlas
(
)
)
;
if
(
fCacheEntry
-
>
hitCount
(
)
<
=
1
)
{
return
false
;
}
int
shapeMaxDimension
=
SkTMax
(
fShapeConservativeIBounds
.
height
(
)
fShapeConservativeIBounds
.
width
(
)
)
;
if
(
shapeMaxDimension
>
maxRenderTargetSize
)
{
return
false
;
}
int64_t
shapeArea
=
sk_64_mul
(
fShapeConservativeIBounds
.
height
(
)
fShapeConservativeIBounds
.
width
(
)
)
;
if
(
shapeArea
<
100
*
100
)
{
return
true
;
}
SkIRect
hitRect
=
fCacheEntry
-
>
hitRect
(
)
.
makeOffset
(
fCachedMaskShift
.
x
(
)
fCachedMaskShift
.
y
(
)
)
;
hitRect
.
intersect
(
fShapeConservativeIBounds
)
;
int64_t
hitArea
=
sk_64_mul
(
hitRect
.
height
(
)
hitRect
.
width
(
)
)
;
int64_t
drawArea
=
sk_64_mul
(
fMaskDevIBounds
.
height
(
)
fMaskDevIBounds
.
width
(
)
)
;
return
hitArea
*
2
>
=
shapeArea
&
&
drawArea
*
10
>
=
shapeArea
;
}
void
GrCCDrawPathsOp
:
:
setupResources
(
GrCCPathCache
*
pathCache
GrOnFlushResourceProvider
*
onFlushRP
GrCCPerFlushResources
*
resources
DoCopiesToA8Coverage
doCopies
)
{
SkASSERT
(
fNumDraws
>
0
)
;
SkASSERT
(
-
1
=
=
fBaseInstance
)
;
fBaseInstance
=
resources
-
>
nextPathInstanceIdx
(
)
;
for
(
SingleDraw
&
draw
:
fDraws
)
{
draw
.
setupResources
(
pathCache
onFlushRP
resources
doCopies
this
)
;
}
if
(
!
fInstanceRanges
.
empty
(
)
)
{
fInstanceRanges
.
back
(
)
.
fEndInstanceIdx
=
resources
-
>
nextPathInstanceIdx
(
)
;
}
}
void
GrCCDrawPathsOp
:
:
SingleDraw
:
:
setupResources
(
GrCCPathCache
*
pathCache
GrOnFlushResourceProvider
*
onFlushRP
GrCCPerFlushResources
*
resources
DoCopiesToA8Coverage
doCopies
GrCCDrawPathsOp
*
op
)
{
using
DoEvenOddFill
=
GrCCPathProcessor
:
:
DoEvenOddFill
;
SkPath
path
;
fShape
.
asPath
(
&
path
)
;
auto
doEvenOddFill
=
DoEvenOddFill
(
fShape
.
style
(
)
.
strokeRec
(
)
.
isFillStyle
(
)
&
&
SkPath
:
:
kEvenOdd_FillType
=
=
path
.
getFillType
(
)
)
;
SkASSERT
(
SkPath
:
:
kEvenOdd_FillType
=
=
path
.
getFillType
(
)
|
|
SkPath
:
:
kWinding_FillType
=
=
path
.
getFillType
(
)
)
;
if
(
fCacheEntry
)
{
if
(
fCacheEntry
-
>
cachedAtlas
(
)
)
{
SkASSERT
(
fCacheEntry
-
>
cachedAtlas
(
)
-
>
getOnFlushProxy
(
)
)
;
if
(
DoCopiesToA8Coverage
:
:
kYes
=
=
doCopies
&
&
fDoCopyToA8Coverage
)
{
resources
-
>
upgradeEntryToLiteralCoverageAtlas
(
pathCache
onFlushRP
fCacheEntry
.
get
(
)
doEvenOddFill
)
;
SkASSERT
(
fCacheEntry
-
>
cachedAtlas
(
)
)
;
SkASSERT
(
GrCCAtlas
:
:
CoverageType
:
:
kA8_LiteralCoverage
=
=
fCacheEntry
-
>
cachedAtlas
(
)
-
>
coverageType
(
)
)
;
SkASSERT
(
fCacheEntry
-
>
cachedAtlas
(
)
-
>
getOnFlushProxy
(
)
)
;
}
#
if
0
fColor
=
(
GrCCAtlas
:
:
CoverageType
:
:
kA8_LiteralCoverage
=
=
fCacheEntry
-
>
cachedAtlas
(
)
-
>
coverageType
(
)
)
?
SkPMColor4f
{
0
0
.
25
.
25
}
:
SkPMColor4f
{
0
.
25
0
.
25
}
;
#
endif
op
-
>
recordInstance
(
fCacheEntry
-
>
cachedAtlas
(
)
-
>
getOnFlushProxy
(
)
resources
-
>
nextPathInstanceIdx
(
)
)
;
resources
-
>
appendDrawPathInstance
(
)
.
set
(
*
fCacheEntry
fCachedMaskShift
SkPMColor4f_toFP16
(
fColor
)
)
;
return
;
}
}
SkRect
devBounds
devBounds45
;
SkIRect
devIBounds
;
SkIVector
devToAtlasOffset
;
if
(
auto
atlas
=
resources
-
>
renderShapeInAtlas
(
fMaskDevIBounds
fMatrix
fShape
fStrokeDevWidth
&
devBounds
&
devBounds45
&
devIBounds
&
devToAtlasOffset
)
)
{
op
-
>
recordInstance
(
atlas
-
>
textureProxy
(
)
resources
-
>
nextPathInstanceIdx
(
)
)
;
resources
-
>
appendDrawPathInstance
(
)
.
set
(
devBounds
devBounds45
devToAtlasOffset
SkPMColor4f_toFP16
(
fColor
)
doEvenOddFill
)
;
if
(
fDoCachePathMask
)
{
SkASSERT
(
fCacheEntry
)
;
SkASSERT
(
!
fCacheEntry
-
>
cachedAtlas
(
)
)
;
SkASSERT
(
fShapeConservativeIBounds
=
=
fMaskDevIBounds
)
;
fCacheEntry
-
>
setCoverageCountAtlas
(
onFlushRP
atlas
devToAtlasOffset
devBounds
devBounds45
devIBounds
fCachedMaskShift
)
;
}
}
}
inline
void
GrCCDrawPathsOp
:
:
recordInstance
(
GrTextureProxy
*
atlasProxy
int
instanceIdx
)
{
if
(
fInstanceRanges
.
empty
(
)
)
{
fInstanceRanges
.
push_back
(
{
atlasProxy
instanceIdx
}
)
;
return
;
}
if
(
fInstanceRanges
.
back
(
)
.
fAtlasProxy
!
=
atlasProxy
)
{
fInstanceRanges
.
back
(
)
.
fEndInstanceIdx
=
instanceIdx
;
fInstanceRanges
.
push_back
(
{
atlasProxy
instanceIdx
}
)
;
return
;
}
}
void
GrCCDrawPathsOp
:
:
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
{
SkASSERT
(
fOwningPerOpListPaths
)
;
const
GrCCPerFlushResources
*
resources
=
fOwningPerOpListPaths
-
>
fFlushResources
.
get
(
)
;
if
(
!
resources
)
{
return
;
}
GrPipeline
:
:
InitArgs
initArgs
;
initArgs
.
fCaps
=
&
flushState
-
>
caps
(
)
;
initArgs
.
fResourceProvider
=
flushState
-
>
resourceProvider
(
)
;
initArgs
.
fDstProxy
=
flushState
-
>
drawOpArgs
(
)
.
fDstProxy
;
auto
clip
=
flushState
-
>
detachAppliedClip
(
)
;
GrPipeline
:
:
FixedDynamicState
fixedDynamicState
(
clip
.
scissorState
(
)
.
rect
(
)
)
;
GrPipeline
pipeline
(
initArgs
std
:
:
move
(
fProcessors
)
std
:
:
move
(
clip
)
)
;
int
baseInstance
=
fBaseInstance
;
SkASSERT
(
baseInstance
>
=
0
)
;
for
(
const
InstanceRange
&
range
:
fInstanceRanges
)
{
SkASSERT
(
range
.
fEndInstanceIdx
>
baseInstance
)
;
GrCCPathProcessor
pathProc
(
range
.
fAtlasProxy
fViewMatrixIfUsingLocalCoords
)
;
GrTextureProxy
*
atlasProxy
=
range
.
fAtlasProxy
;
fixedDynamicState
.
fPrimitiveProcessorTextures
=
&
atlasProxy
;
pathProc
.
drawPaths
(
flushState
pipeline
&
fixedDynamicState
*
resources
baseInstance
range
.
fEndInstanceIdx
this
-
>
bounds
(
)
)
;
baseInstance
=
range
.
fEndInstanceIdx
;
}
}
