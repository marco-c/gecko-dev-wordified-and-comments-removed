#
ifndef
GrCCPathCache_DEFINED
#
define
GrCCPathCache_DEFINED
#
include
"
SkExchange
.
h
"
#
include
"
SkTHash
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
ccpr
/
GrCCAtlas
.
h
"
#
include
"
ccpr
/
GrCCPathProcessor
.
h
"
class
GrCCPathCacheEntry
;
class
GrShape
;
class
GrCCPathCache
{
public
:
#
ifdef
SK_DEBUG
~
GrCCPathCache
(
)
{
fHashTable
.
reset
(
)
;
SkASSERT
(
fLRU
.
isEmpty
(
)
)
;
}
#
endif
struct
MaskTransform
{
MaskTransform
(
const
SkMatrix
&
m
SkIVector
*
shift
)
;
float
fMatrix2x2
[
4
]
;
#
ifndef
SK_BUILD_FOR_ANDROID_FRAMEWORK
float
fSubpixelTranslate
[
2
]
;
#
endif
}
;
enum
class
CreateIfAbsent
:
bool
{
kNo
=
false
kYes
=
true
}
;
sk_sp
<
GrCCPathCacheEntry
>
find
(
const
GrShape
&
const
MaskTransform
&
CreateIfAbsent
=
CreateIfAbsent
:
:
kNo
)
;
void
evict
(
const
GrCCPathCacheEntry
*
)
;
private
:
struct
HashKey
{
const
uint32_t
*
fData
;
}
;
friend
bool
operator
=
=
(
const
HashKey
&
const
HashKey
&
)
;
class
HashNode
:
SkNoncopyable
{
public
:
static
HashKey
GetKey
(
const
HashNode
&
node
)
{
return
GetKey
(
node
.
fEntry
)
;
}
static
HashKey
GetKey
(
const
GrCCPathCacheEntry
*
)
;
static
uint32_t
Hash
(
HashKey
)
;
HashNode
(
)
=
default
;
HashNode
(
GrCCPathCache
*
const
MaskTransform
&
const
GrShape
&
)
;
HashNode
(
HashNode
&
&
node
)
{
fEntry
=
skstd
:
:
exchange
(
node
.
fEntry
nullptr
)
;
}
~
HashNode
(
)
;
HashNode
&
operator
=
(
HashNode
&
&
)
;
GrCCPathCacheEntry
*
entry
(
)
const
{
return
fEntry
;
}
private
:
GrCCPathCacheEntry
*
fEntry
=
nullptr
;
}
;
SkTHashTable
<
HashNode
HashKey
>
fHashTable
;
SkTInternalLList
<
GrCCPathCacheEntry
>
fLRU
;
}
;
class
GrCCPathCacheEntry
:
public
SkPathRef
:
:
GenIDChangeListener
{
public
:
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
GrCCPathCacheEntry
)
;
~
GrCCPathCacheEntry
(
)
override
;
int
hitCount
(
)
const
{
return
fHitCount
;
}
bool
hasCachedAtlas
(
)
const
{
return
SkToBool
(
fCachedAtlasInfo
)
;
}
const
SkIRect
&
devIBounds
(
)
const
{
return
fDevIBounds
;
}
int
width
(
)
const
{
return
fDevIBounds
.
width
(
)
;
}
int
height
(
)
const
{
return
fDevIBounds
.
height
(
)
;
}
void
initAsStashedAtlas
(
const
GrUniqueKey
&
atlasKey
uint32_t
contextUniqueID
const
SkIVector
&
atlasOffset
const
SkRect
&
devBounds
const
SkRect
&
devBounds45
const
SkIRect
&
devIBounds
const
SkIVector
&
maskShift
)
;
void
updateToCachedAtlas
(
const
GrUniqueKey
&
atlasKey
uint32_t
contextUniqueID
const
SkIVector
&
newAtlasOffset
sk_sp
<
GrCCAtlas
:
:
CachedAtlasInfo
>
)
;
const
GrUniqueKey
&
atlasKey
(
)
const
{
return
fAtlasKey
;
}
void
resetAtlasKeyAndInfo
(
)
{
fAtlasKey
.
reset
(
)
;
fCachedAtlasInfo
.
reset
(
)
;
}
void
setCurrFlushAtlas
(
const
GrCCAtlas
*
currFlushAtlas
)
{
SkASSERT
(
!
fCurrFlushAtlas
|
|
!
currFlushAtlas
)
;
fCurrFlushAtlas
=
currFlushAtlas
;
}
const
GrCCAtlas
*
currFlushAtlas
(
)
const
{
return
fCurrFlushAtlas
;
}
private
:
using
MaskTransform
=
GrCCPathCache
:
:
MaskTransform
;
GrCCPathCacheEntry
(
GrCCPathCache
*
cache
const
MaskTransform
&
m
)
:
fCacheWeakPtr
(
cache
)
fMaskTransform
(
m
)
{
}
void
invalidateAtlas
(
)
;
void
onChange
(
)
override
;
uint32_t
fContextUniqueID
;
GrCCPathCache
*
fCacheWeakPtr
;
MaskTransform
fMaskTransform
;
int
fHitCount
=
1
;
GrUniqueKey
fAtlasKey
;
SkIVector
fAtlasOffset
;
sk_sp
<
GrCCAtlas
:
:
CachedAtlasInfo
>
fCachedAtlasInfo
;
SkRect
fDevBounds
;
SkRect
fDevBounds45
;
SkIRect
fDevIBounds
;
const
GrCCAtlas
*
fCurrFlushAtlas
=
nullptr
;
friend
class
GrCCPathCache
;
friend
void
GrCCPathProcessor
:
:
Instance
:
:
set
(
const
GrCCPathCacheEntry
&
const
SkIVector
&
uint32_t
DoEvenOddFill
)
;
}
;
inline
void
GrCCPathProcessor
:
:
Instance
:
:
set
(
const
GrCCPathCacheEntry
&
entry
const
SkIVector
&
shift
GrColor
color
DoEvenOddFill
doEvenOddFill
)
{
float
dx
=
(
float
)
shift
.
fX
dy
=
(
float
)
shift
.
fY
;
this
-
>
set
(
entry
.
fDevBounds
.
makeOffset
(
dx
dy
)
MakeOffset45
(
entry
.
fDevBounds45
dx
dy
)
entry
.
fAtlasOffset
-
shift
color
doEvenOddFill
)
;
}
#
endif
