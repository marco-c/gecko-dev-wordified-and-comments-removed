#
ifndef
GrCoverageCountingPathRenderer_DEFINED
#
define
GrCoverageCountingPathRenderer_DEFINED
#
include
<
map
>
#
include
"
src
/
gpu
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrOpsTask
.
h
"
#
include
"
src
/
gpu
/
GrPathRenderer
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCPerFlushResources
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCPerOpsTaskPaths
.
h
"
class
GrCCDrawPathsOp
;
class
GrCCPathCache
;
class
GrCoverageCountingPathRenderer
:
public
GrPathRenderer
public
GrOnFlushCallbackObject
{
public
:
using
CoverageType
=
GrCCAtlas
:
:
CoverageType
;
static
bool
IsSupported
(
const
GrCaps
&
CoverageType
*
=
nullptr
)
;
enum
class
AllowCaching
:
bool
{
kNo
=
false
kYes
=
true
}
;
static
sk_sp
<
GrCoverageCountingPathRenderer
>
CreateIfSupported
(
const
GrCaps
&
AllowCaching
uint32_t
contextUniqueID
)
;
CoverageType
coverageType
(
)
const
{
return
fCoverageType
;
}
using
PendingPathsMap
=
std
:
:
map
<
uint32_t
sk_sp
<
GrCCPerOpsTaskPaths
>
>
;
PendingPathsMap
detachPendingPaths
(
)
{
return
std
:
:
move
(
fPendingPaths
)
;
}
void
mergePendingPaths
(
const
PendingPathsMap
&
paths
)
{
#
ifdef
SK_DEBUG
for
(
const
auto
&
it
:
paths
)
{
SkASSERT
(
!
fPendingPaths
.
count
(
it
.
first
)
)
;
}
#
endif
fPendingPaths
.
insert
(
paths
.
begin
(
)
paths
.
end
(
)
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
makeClipProcessor
(
uint32_t
oplistID
const
SkPath
&
deviceSpacePath
const
SkIRect
&
accessRect
const
GrCaps
&
)
;
void
preFlush
(
GrOnFlushResourceProvider
*
const
uint32_t
*
opsTaskIDs
int
numOpsTaskIDs
)
override
;
void
postFlush
(
GrDeferredUploadToken
const
uint32_t
*
opsTaskIDs
int
numOpsTaskIDs
)
override
;
void
purgeCacheEntriesOlderThan
(
GrProxyProvider
*
const
GrStdSteadyClock
:
:
time_point
&
)
;
static
constexpr
float
kPathCropThreshold
=
1
<
<
16
;
static
void
CropPath
(
const
SkPath
&
const
SkIRect
&
cropbox
SkPath
*
out
)
;
static
constexpr
float
kMaxBoundsInflationFromStroke
=
4096
;
static
float
GetStrokeDevWidth
(
const
SkMatrix
&
const
SkStrokeRec
&
float
*
inflationRadius
=
nullptr
)
;
private
:
GrCoverageCountingPathRenderer
(
CoverageType
AllowCaching
uint32_t
contextUniqueID
)
;
StencilSupport
onGetStencilSupport
(
const
GrShape
&
)
const
override
{
return
GrPathRenderer
:
:
kNoSupport_StencilSupport
;
}
CanDrawPath
onCanDrawPath
(
const
CanDrawPathArgs
&
)
const
override
;
bool
onDrawPath
(
const
DrawPathArgs
&
)
override
;
GrCCPerOpsTaskPaths
*
lookupPendingPaths
(
uint32_t
opsTaskID
)
;
void
recordOp
(
std
:
:
unique_ptr
<
GrCCDrawPathsOp
>
const
DrawPathArgs
&
)
;
const
CoverageType
fCoverageType
;
PendingPathsMap
fPendingPaths
;
SkSTArray
<
4
sk_sp
<
GrCCPerOpsTaskPaths
>
>
fFlushingPaths
;
std
:
:
unique_ptr
<
GrCCPathCache
>
fPathCache
;
SkDEBUGCODE
(
bool
fFlushing
=
false
)
;
public
:
void
testingOnly_drawPathDirectly
(
const
DrawPathArgs
&
)
;
const
GrCCPerFlushResources
*
testingOnly_getCurrentFlushResources
(
)
;
const
GrCCPathCache
*
testingOnly_getPathCache
(
)
const
;
}
;
#
endif
