#
ifndef
GrStencilAtlasOp_DEFINED
#
define
GrStencilAtlasOp_DEFINED
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCFiller
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCStroker
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawOp
.
h
"
class
GrCCPerFlushResources
;
class
GrStencilAtlasOp
:
public
GrDrawOp
{
public
:
DEFINE_OP_CLASS_ID
using
FillBatchID
=
GrCCFiller
:
:
BatchID
;
using
StrokeBatchID
=
GrCCStroker
:
:
BatchID
;
struct
ResolveRectInstance
{
int16_t
l
t
r
b
;
}
;
const
char
*
name
(
)
const
override
{
return
"
StencilAtlasOp
(
CCPR
)
"
;
}
FixedFunctionFlags
fixedFunctionFlags
(
)
const
override
{
return
FixedFunctionFlags
:
:
kUsesHWAA
|
FixedFunctionFlags
:
:
kUsesStencil
;
}
GrProcessorSet
:
:
Analysis
finalize
(
const
GrCaps
&
const
GrAppliedClip
*
bool
hasMixedSampledCoverage
GrClampType
)
override
{
return
GrProcessorSet
:
:
EmptySetAnalysis
(
)
;
}
CombineResult
onCombineIfPossible
(
GrOp
*
other
const
GrCaps
&
)
override
{
return
CombineResult
:
:
kCannotCombine
;
}
void
onPrepare
(
GrOpFlushState
*
)
override
{
}
static
std
:
:
unique_ptr
<
GrDrawOp
>
Make
(
GrRecordingContext
*
sk_sp
<
const
GrCCPerFlushResources
>
FillBatchID
StrokeBatchID
int
baseStencilResolveInstance
int
endStencilResolveInstance
const
SkISize
&
drawBounds
)
;
void
onExecute
(
GrOpFlushState
*
flushState
const
SkRect
&
chainBounds
)
override
;
private
:
friend
class
:
:
GrOpMemoryPool
;
GrStencilAtlasOp
(
sk_sp
<
const
GrCCPerFlushResources
>
resources
FillBatchID
fillBatchID
StrokeBatchID
strokeBatchID
int
baseStencilResolveInstance
int
endStencilResolveInstance
const
SkISize
&
drawBounds
)
:
GrDrawOp
(
ClassID
(
)
)
fResources
(
std
:
:
move
(
resources
)
)
fFillBatchID
(
fillBatchID
)
fStrokeBatchID
(
strokeBatchID
)
fBaseStencilResolveInstance
(
baseStencilResolveInstance
)
fEndStencilResolveInstance
(
endStencilResolveInstance
)
fDrawBounds
(
drawBounds
)
{
this
-
>
setBounds
(
SkRect
:
:
MakeIWH
(
fDrawBounds
.
width
(
)
fDrawBounds
.
height
(
)
)
GrOp
:
:
HasAABloat
:
:
kNo
GrOp
:
:
IsHairline
:
:
kNo
)
;
}
const
sk_sp
<
const
GrCCPerFlushResources
>
fResources
;
const
FillBatchID
fFillBatchID
;
const
StrokeBatchID
fStrokeBatchID
;
const
int
fBaseStencilResolveInstance
;
const
int
fEndStencilResolveInstance
;
const
SkISize
fDrawBounds
;
int
fResolveBaseVertex
;
}
;
#
endif
