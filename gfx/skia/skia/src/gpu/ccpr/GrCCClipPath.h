#
ifndef
GrCCClipPath_DEFINED
#
define
GrCCClipPath_DEFINED
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCAtlas
.
h
"
struct
GrCCPerFlushResourceSpecs
;
class
GrCCPerFlushResources
;
class
GrOnFlushResourceProvider
;
class
GrProxyProvider
;
class
GrCCClipPath
{
public
:
GrCCClipPath
(
)
=
default
;
GrCCClipPath
(
const
GrCCClipPath
&
)
=
delete
;
~
GrCCClipPath
(
)
{
SkASSERT
(
!
fAtlasLazyProxy
|
|
fAtlasLazyProxy
-
>
unique
(
)
)
;
}
bool
isInitialized
(
)
const
{
return
fAtlasLazyProxy
!
=
nullptr
;
}
void
init
(
const
SkPath
&
deviceSpacePath
const
SkIRect
&
accessRect
GrCCAtlas
:
:
CoverageType
atlasCoverageType
const
GrCaps
&
)
;
void
addAccess
(
const
SkIRect
&
accessRect
)
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
fAccessRect
.
join
(
accessRect
)
;
}
GrTextureProxy
*
atlasLazyProxy
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fAtlasLazyProxy
.
get
(
)
;
}
const
SkPath
&
deviceSpacePath
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fDeviceSpacePath
;
}
const
SkIRect
&
pathDevIBounds
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fPathDevIBounds
;
}
void
accountForOwnPath
(
GrCCPerFlushResourceSpecs
*
)
const
;
void
renderPathInAtlas
(
GrCCPerFlushResources
*
GrOnFlushResourceProvider
*
)
;
const
SkVector
&
atlasScale
(
)
const
{
SkASSERT
(
fHasAtlasTransform
)
;
return
fAtlasScale
;
}
const
SkVector
&
atlasTranslate
(
)
const
{
SkASSERT
(
fHasAtlasTransform
)
;
return
fAtlasTranslate
;
}
private
:
sk_sp
<
GrTextureProxy
>
fAtlasLazyProxy
;
SkPath
fDeviceSpacePath
;
SkIRect
fPathDevIBounds
;
SkIRect
fAccessRect
;
const
GrCCAtlas
*
fAtlas
=
nullptr
;
SkIVector
fDevToAtlasOffset
;
SkDEBUGCODE
(
bool
fHasAtlas
=
false
;
)
SkVector
fAtlasScale
;
SkVector
fAtlasTranslate
;
SkDEBUGCODE
(
bool
fHasAtlasTransform
=
false
;
)
}
;
#
endif
