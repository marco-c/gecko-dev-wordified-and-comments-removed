#
include
"
GrCCPathProcessor
.
h
"
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrOnFlushResourceProvider
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
ccpr
/
GrCCPerFlushResources
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
glsl
/
GrGLSLVarying
.
h
"
static
constexpr
float
kOctoEdgeNorms
[
8
*
4
]
=
{
-
1
0
-
1
+
1
-
1
0
-
1
-
1
0
-
1
-
1
-
1
0
-
1
+
1
-
1
+
1
0
+
1
-
1
+
1
0
+
1
+
1
0
+
1
+
1
+
1
0
+
1
-
1
+
1
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gVertexBufferKey
)
;
sk_sp
<
const
GrBuffer
>
GrCCPathProcessor
:
:
FindVertexBuffer
(
GrOnFlushResourceProvider
*
onFlushRP
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gVertexBufferKey
)
;
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
kVertex_GrBufferType
sizeof
(
kOctoEdgeNorms
)
kOctoEdgeNorms
gVertexBufferKey
)
;
}
static
constexpr
uint16_t
kRestartStrip
=
0xffff
;
static
constexpr
uint16_t
kOctoIndicesAsStrips
[
]
=
{
1
0
2
4
3
kRestartStrip
5
4
6
0
7
}
;
static
constexpr
uint16_t
kOctoIndicesAsTris
[
]
=
{
1
0
2
0
4
2
2
4
3
5
4
6
4
0
6
6
0
7
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gIndexBufferKey
)
;
constexpr
GrPrimitiveProcessor
:
:
Attribute
GrCCPathProcessor
:
:
kInstanceAttribs
[
]
;
constexpr
GrPrimitiveProcessor
:
:
Attribute
GrCCPathProcessor
:
:
kEdgeNormsAttrib
;
sk_sp
<
const
GrBuffer
>
GrCCPathProcessor
:
:
FindIndexBuffer
(
GrOnFlushResourceProvider
*
onFlushRP
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gIndexBufferKey
)
;
if
(
onFlushRP
-
>
caps
(
)
-
>
usePrimitiveRestart
(
)
)
{
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
kIndex_GrBufferType
sizeof
(
kOctoIndicesAsStrips
)
kOctoIndicesAsStrips
gIndexBufferKey
)
;
}
else
{
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
kIndex_GrBufferType
sizeof
(
kOctoIndicesAsTris
)
kOctoIndicesAsTris
gIndexBufferKey
)
;
}
}
GrCCPathProcessor
:
:
GrCCPathProcessor
(
const
GrTextureProxy
*
atlas
const
SkMatrix
&
viewMatrixIfUsingLocalCoords
)
:
INHERITED
(
kGrCCPathProcessor_ClassID
)
fAtlasAccess
(
atlas
-
>
textureType
(
)
atlas
-
>
config
(
)
GrSamplerState
:
:
Filter
:
:
kNearest
GrSamplerState
:
:
WrapMode
:
:
kClamp
)
fAtlasSize
(
atlas
-
>
isize
(
)
)
fAtlasOrigin
(
atlas
-
>
origin
(
)
)
{
this
-
>
setInstanceAttributeCnt
(
kNumInstanceAttribs
)
;
SkASSERT
(
!
strcmp
(
this
-
>
instanceAttribute
(
0
)
.
name
(
)
"
devbounds
"
)
)
;
SkASSERT
(
!
strcmp
(
this
-
>
instanceAttribute
(
1
)
.
name
(
)
"
devbounds45
"
)
)
;
SkASSERT
(
!
strcmp
(
this
-
>
instanceAttribute
(
2
)
.
name
(
)
"
dev_to_atlas_offset
"
)
)
;
SkASSERT
(
!
strcmp
(
this
-
>
instanceAttribute
(
3
)
.
name
(
)
"
color
"
)
)
;
SkASSERT
(
this
-
>
debugOnly_instanceAttributeOffset
(
0
)
=
=
offsetof
(
Instance
fDevBounds
)
)
;
SkASSERT
(
this
-
>
debugOnly_instanceAttributeOffset
(
1
)
=
=
offsetof
(
Instance
fDevBounds45
)
)
;
SkASSERT
(
this
-
>
debugOnly_instanceAttributeOffset
(
2
)
=
=
offsetof
(
Instance
fDevToAtlasOffset
)
)
;
SkASSERT
(
this
-
>
debugOnly_instanceAttributeOffset
(
3
)
=
=
offsetof
(
Instance
fColor
)
)
;
SkASSERT
(
this
-
>
debugOnly_instanceStride
(
)
=
=
sizeof
(
Instance
)
)
;
this
-
>
setVertexAttributeCnt
(
1
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
if
(
!
viewMatrixIfUsingLocalCoords
.
invert
(
&
fLocalMatrix
)
)
{
fLocalMatrix
.
setIdentity
(
)
;
}
}
class
GLSLPathProcessor
:
public
GrGLSLGeometryProcessor
{
public
:
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
;
private
:
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
primProc
FPCoordTransformIter
&
&
transformIter
)
override
{
const
GrCCPathProcessor
&
proc
=
primProc
.
cast
<
GrCCPathProcessor
>
(
)
;
pdman
.
set2f
(
fAtlasAdjustUniform
1
.
0f
/
proc
.
atlasSize
(
)
.
fWidth
1
.
0f
/
proc
.
atlasSize
(
)
.
fHeight
)
;
this
-
>
setTransformDataHelper
(
proc
.
localMatrix
(
)
pdman
&
transformIter
)
;
}
GrGLSLUniformHandler
:
:
UniformHandle
fAtlasAdjustUniform
;
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
GrGLSLPrimitiveProcessor
*
GrCCPathProcessor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
return
new
GLSLPathProcessor
(
)
;
}
void
GrCCPathProcessor
:
:
drawPaths
(
GrOpFlushState
*
flushState
const
GrPipeline
&
pipeline
const
GrPipeline
:
:
FixedDynamicState
*
fixedDynamicState
const
GrCCPerFlushResources
&
resources
int
baseInstance
int
endInstance
const
SkRect
&
bounds
)
const
{
const
GrCaps
&
caps
=
flushState
-
>
caps
(
)
;
GrPrimitiveType
primitiveType
=
caps
.
usePrimitiveRestart
(
)
?
GrPrimitiveType
:
:
kTriangleStrip
:
GrPrimitiveType
:
:
kTriangles
;
int
numIndicesPerInstance
=
caps
.
usePrimitiveRestart
(
)
?
SK_ARRAY_COUNT
(
kOctoIndicesAsStrips
)
:
SK_ARRAY_COUNT
(
kOctoIndicesAsTris
)
;
GrMesh
mesh
(
primitiveType
)
;
auto
enablePrimitiveRestart
=
GrPrimitiveRestart
(
flushState
-
>
caps
(
)
.
usePrimitiveRestart
(
)
)
;
mesh
.
setIndexedInstanced
(
resources
.
indexBuffer
(
)
numIndicesPerInstance
resources
.
instanceBuffer
(
)
endInstance
-
baseInstance
baseInstance
enablePrimitiveRestart
)
;
mesh
.
setVertexData
(
resources
.
vertexBuffer
(
)
)
;
flushState
-
>
rtCommandBuffer
(
)
-
>
draw
(
*
this
pipeline
fixedDynamicState
nullptr
&
mesh
1
bounds
)
;
}
void
GLSLPathProcessor
:
:
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
{
using
InstanceAttribs
=
GrCCPathProcessor
:
:
InstanceAttribs
;
using
Interpolation
=
GrGLSLVaryingHandler
:
:
Interpolation
;
const
GrCCPathProcessor
&
proc
=
args
.
fGP
.
cast
<
GrCCPathProcessor
>
(
)
;
GrGLSLUniformHandler
*
uniHandler
=
args
.
fUniformHandler
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
const
char
*
atlasAdjust
;
fAtlasAdjustUniform
=
uniHandler
-
>
addUniform
(
kVertex_GrShaderFlag
kFloat2_GrSLType
"
atlas_adjust
"
&
atlasAdjust
)
;
varyingHandler
-
>
emitAttributes
(
proc
)
;
GrGLSLVarying
texcoord
(
kFloat3_GrSLType
)
;
GrGLSLVarying
color
(
kHalf4_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
texcoord
"
&
texcoord
)
;
varyingHandler
-
>
addPassThroughAttribute
(
proc
.
getInstanceAttrib
(
InstanceAttribs
:
:
kColor
)
args
.
fOutputColor
Interpolation
:
:
kCanBeFlat
)
;
GrGLSLVertexBuilder
*
v
=
args
.
fVertBuilder
;
v
-
>
codeAppendf
(
"
float2x2
N
=
float2x2
(
%
s
.
xy
%
s
.
zw
)
;
"
proc
.
getEdgeNormsAttrib
(
)
.
name
(
)
proc
.
getEdgeNormsAttrib
(
)
.
name
(
)
)
;
v
-
>
codeAppendf
(
"
float4
devbounds
=
%
s
;
"
proc
.
getInstanceAttrib
(
InstanceAttribs
:
:
kDevBounds
)
.
name
(
)
)
;
v
-
>
codeAppend
(
"
float2
refpt
=
(
0
=
=
sk_VertexID
>
>
2
)
"
"
?
float2
(
min
(
devbounds
.
x
devbounds
.
z
)
devbounds
.
y
)
"
"
:
float2
(
max
(
devbounds
.
x
devbounds
.
z
)
devbounds
.
w
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
refpt45
=
(
0
=
=
(
(
sk_VertexID
+
1
)
&
(
1
<
<
2
)
)
)
?
%
s
.
xy
:
%
s
.
zw
;
"
proc
.
getInstanceAttrib
(
InstanceAttribs
:
:
kDevBounds45
)
.
name
(
)
proc
.
getInstanceAttrib
(
InstanceAttribs
:
:
kDevBounds45
)
.
name
(
)
)
;
v
-
>
codeAppendf
(
"
refpt45
*
=
float2x2
(
.
5
.
5
-
.
5
.
5
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
K
=
float2
(
dot
(
N
[
0
]
refpt
)
dot
(
N
[
1
]
refpt45
)
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
octocoord
=
K
*
inverse
(
N
)
;
"
)
;
v
-
>
codeAppend
(
"
float2
bloatdir
=
(
0
!
=
N
[
0
]
.
x
)
"
"
?
half2
(
N
[
0
]
.
x
N
[
1
]
.
y
)
:
half2
(
N
[
1
]
.
x
N
[
0
]
.
y
)
;
"
)
;
v
-
>
codeAppend
(
"
octocoord
=
(
ceil
(
octocoord
*
bloatdir
-
1e
-
4
)
+
0
.
25
)
*
bloatdir
;
"
)
;
gpArgs
-
>
fPositionVar
.
set
(
kFloat2_GrSLType
"
octocoord
"
)
;
v
-
>
codeAppendf
(
"
float2
atlascoord
=
octocoord
+
float2
(
%
s
)
;
"
proc
.
getInstanceAttrib
(
InstanceAttribs
:
:
kDevToAtlasOffset
)
.
name
(
)
)
;
if
(
kTopLeft_GrSurfaceOrigin
=
=
proc
.
atlasOrigin
(
)
)
{
v
-
>
codeAppendf
(
"
%
s
.
xy
=
atlascoord
*
%
s
;
"
texcoord
.
vsOut
(
)
atlasAdjust
)
;
}
else
{
SkASSERT
(
kBottomLeft_GrSurfaceOrigin
=
=
proc
.
atlasOrigin
(
)
)
;
v
-
>
codeAppendf
(
"
%
s
.
xy
=
float2
(
atlascoord
.
x
*
%
s
.
x
1
-
atlascoord
.
y
*
%
s
.
y
)
;
"
texcoord
.
vsOut
(
)
atlasAdjust
atlasAdjust
)
;
}
v
-
>
codeAppendf
(
"
%
s
.
z
=
sign
(
devbounds
.
z
-
devbounds
.
x
)
*
.
5
;
"
texcoord
.
vsOut
(
)
)
;
this
-
>
emitTransforms
(
v
varyingHandler
uniHandler
GrShaderVar
(
"
octocoord
"
kFloat2_GrSLType
)
proc
.
localMatrix
(
)
args
.
fFPCoordTransformHandler
)
;
GrGLSLFPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
f
-
>
codeAppend
(
"
half
coverage
=
"
)
;
f
-
>
appendTextureLookup
(
args
.
fTexSamplers
[
0
]
SkStringPrintf
(
"
%
s
.
xy
"
texcoord
.
fsIn
(
)
)
.
c_str
(
)
kFloat2_GrSLType
)
;
f
-
>
codeAppend
(
"
.
a
;
"
)
;
f
-
>
codeAppendf
(
"
coverage
=
min
(
abs
(
coverage
)
*
%
s
.
z
.
5
)
;
"
texcoord
.
fsIn
(
)
)
;
f
-
>
codeAppend
(
"
coverage
=
1
-
abs
(
fract
(
coverage
)
*
2
-
1
)
;
"
)
;
f
-
>
codeAppendf
(
"
%
s
=
half4
(
coverage
)
;
"
args
.
fOutputCoverage
)
;
}
