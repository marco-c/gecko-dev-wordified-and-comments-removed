#
include
"
src
/
gpu
/
ccpr
/
GrCCPathProcessor
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
src
/
gpu
/
GrOnFlushResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrOpsRenderPass
.
h
"
#
include
"
src
/
gpu
/
GrTexturePriv
.
h
"
#
include
"
src
/
gpu
/
ccpr
/
GrCCPerFlushResources
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLGeometryProcessor
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLProgramBuilder
.
h
"
#
include
"
src
/
gpu
/
glsl
/
GrGLSLVarying
.
h
"
static
constexpr
float
kOctoEdgeNorms
[
8
*
4
]
=
{
0
0
0
0
0
0
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
0
1
0
1
0
1
0
1
0
0
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gVertexBufferKey
)
;
sk_sp
<
const
GrGpuBuffer
>
GrCCPathProcessor
:
:
FindVertexBuffer
(
GrOnFlushResourceProvider
*
onFlushRP
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gVertexBufferKey
)
;
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kVertex
sizeof
(
kOctoEdgeNorms
)
kOctoEdgeNorms
gVertexBufferKey
)
;
}
static
constexpr
uint16_t
kRestartStrip
=
0xffff
;
static
constexpr
uint16_t
kOctoIndicesAsStrips
[
]
=
{
3
4
2
0
1
kRestartStrip
7
0
6
4
5
}
;
static
constexpr
uint16_t
kOctoIndicesAsTris
[
]
=
{
3
4
2
4
0
2
2
0
1
7
0
6
0
4
6
6
4
5
}
;
GR_DECLARE_STATIC_UNIQUE_KEY
(
gIndexBufferKey
)
;
constexpr
GrPrimitiveProcessor
:
:
Attribute
GrCCPathProcessor
:
:
kInstanceAttribs
[
]
;
constexpr
GrPrimitiveProcessor
:
:
Attribute
GrCCPathProcessor
:
:
kCornersAttrib
;
sk_sp
<
const
GrGpuBuffer
>
GrCCPathProcessor
:
:
FindIndexBuffer
(
GrOnFlushResourceProvider
*
onFlushRP
)
{
GR_DEFINE_STATIC_UNIQUE_KEY
(
gIndexBufferKey
)
;
if
(
onFlushRP
-
>
caps
(
)
-
>
usePrimitiveRestart
(
)
)
{
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kIndex
sizeof
(
kOctoIndicesAsStrips
)
kOctoIndicesAsStrips
gIndexBufferKey
)
;
}
else
{
return
onFlushRP
-
>
findOrMakeStaticBuffer
(
GrGpuBufferType
:
:
kIndex
sizeof
(
kOctoIndicesAsTris
)
kOctoIndicesAsTris
gIndexBufferKey
)
;
}
}
GrCCPathProcessor
:
:
GrCCPathProcessor
(
CoverageMode
coverageMode
const
GrTexture
*
atlasTexture
const
GrSwizzle
&
swizzle
GrSurfaceOrigin
atlasOrigin
const
SkMatrix
&
viewMatrixIfUsingLocalCoords
)
:
INHERITED
(
kGrCCPathProcessor_ClassID
)
fCoverageMode
(
coverageMode
)
fAtlasAccess
(
atlasTexture
-
>
texturePriv
(
)
.
textureType
(
)
GrSamplerState
:
:
ClampNearest
(
)
swizzle
)
fAtlasSize
(
SkISize
:
:
Make
(
atlasTexture
-
>
width
(
)
atlasTexture
-
>
height
(
)
)
)
fAtlasOrigin
(
atlasOrigin
)
{
this
-
>
setInstanceAttributes
(
kInstanceAttribs
SK_ARRAY_COUNT
(
kInstanceAttribs
)
)
;
SkASSERT
(
this
-
>
instanceStride
(
)
=
=
sizeof
(
Instance
)
)
;
this
-
>
setVertexAttributes
(
&
kCornersAttrib
1
)
;
this
-
>
setTextureSamplerCnt
(
1
)
;
if
(
!
viewMatrixIfUsingLocalCoords
.
invert
(
&
fLocalMatrix
)
)
{
fLocalMatrix
.
setIdentity
(
)
;
}
}
class
GrCCPathProcessor
:
:
Impl
:
public
GrGLSLGeometryProcessor
{
public
:
void
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
override
;
private
:
void
setData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrPrimitiveProcessor
&
primProc
FPCoordTransformIter
&
&
transformIter
)
override
{
const
auto
&
proc
=
primProc
.
cast
<
GrCCPathProcessor
>
(
)
;
pdman
.
set2f
(
fAtlasAdjustUniform
1
.
0f
/
proc
.
fAtlasSize
.
fWidth
1
.
0f
/
proc
.
fAtlasSize
.
fHeight
)
;
this
-
>
setTransformDataHelper
(
proc
.
fLocalMatrix
pdman
&
transformIter
)
;
}
GrGLSLUniformHandler
:
:
UniformHandle
fAtlasAdjustUniform
;
typedef
GrGLSLGeometryProcessor
INHERITED
;
}
;
GrGLSLPrimitiveProcessor
*
GrCCPathProcessor
:
:
createGLSLInstance
(
const
GrShaderCaps
&
)
const
{
return
new
Impl
(
)
;
}
void
GrCCPathProcessor
:
:
drawPaths
(
GrOpFlushState
*
flushState
const
GrPipeline
&
pipeline
const
GrPipeline
:
:
FixedDynamicState
*
fixedDynamicState
const
GrCCPerFlushResources
&
resources
int
baseInstance
int
endInstance
const
SkRect
&
bounds
)
const
{
const
GrCaps
&
caps
=
flushState
-
>
caps
(
)
;
GrPrimitiveType
primitiveType
=
caps
.
usePrimitiveRestart
(
)
?
GrPrimitiveType
:
:
kTriangleStrip
:
GrPrimitiveType
:
:
kTriangles
;
int
numIndicesPerInstance
=
caps
.
usePrimitiveRestart
(
)
?
SK_ARRAY_COUNT
(
kOctoIndicesAsStrips
)
:
SK_ARRAY_COUNT
(
kOctoIndicesAsTris
)
;
GrMesh
mesh
(
primitiveType
)
;
auto
enablePrimitiveRestart
=
GrPrimitiveRestart
(
flushState
-
>
caps
(
)
.
usePrimitiveRestart
(
)
)
;
mesh
.
setIndexedInstanced
(
resources
.
refIndexBuffer
(
)
numIndicesPerInstance
resources
.
refInstanceBuffer
(
)
endInstance
-
baseInstance
baseInstance
enablePrimitiveRestart
)
;
mesh
.
setVertexData
(
resources
.
refVertexBuffer
(
)
)
;
GrProgramInfo
programInfo
(
flushState
-
>
drawOpArgs
(
)
.
numSamples
(
)
flushState
-
>
drawOpArgs
(
)
.
origin
(
)
pipeline
*
this
fixedDynamicState
nullptr
0
)
;
flushState
-
>
opsRenderPass
(
)
-
>
draw
(
programInfo
&
mesh
1
bounds
)
;
}
void
GrCCPathProcessor
:
:
Impl
:
:
onEmitCode
(
EmitArgs
&
args
GrGPArgs
*
gpArgs
)
{
using
Interpolation
=
GrGLSLVaryingHandler
:
:
Interpolation
;
const
GrCCPathProcessor
&
proc
=
args
.
fGP
.
cast
<
GrCCPathProcessor
>
(
)
;
GrGLSLUniformHandler
*
uniHandler
=
args
.
fUniformHandler
;
GrGLSLVaryingHandler
*
varyingHandler
=
args
.
fVaryingHandler
;
bool
isCoverageCount
=
(
CoverageMode
:
:
kCoverageCount
=
=
proc
.
fCoverageMode
)
;
const
char
*
atlasAdjust
;
fAtlasAdjustUniform
=
uniHandler
-
>
addUniform
(
kVertex_GrShaderFlag
kFloat2_GrSLType
"
atlas_adjust
"
&
atlasAdjust
)
;
varyingHandler
-
>
emitAttributes
(
proc
)
;
GrGLSLVarying
texcoord
(
(
isCoverageCount
)
?
kFloat3_GrSLType
:
kFloat2_GrSLType
)
;
varyingHandler
-
>
addVarying
(
"
texcoord
"
&
texcoord
)
;
GrGLSLVarying
color
(
kHalf4_GrSLType
)
;
varyingHandler
-
>
addPassThroughAttribute
(
kInstanceAttribs
[
kColorAttribIdx
]
args
.
fOutputColor
Interpolation
:
:
kCanBeFlat
)
;
GrGLSLVertexBuilder
*
v
=
args
.
fVertBuilder
;
v
-
>
codeAppendf
(
"
float
wind
=
sign
(
devbounds
.
z
-
devbounds
.
x
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
refpt
=
mix
(
devbounds
.
xy
devbounds
.
zw
corners
.
xy
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
refpt45
=
mix
(
devbounds45
.
xy
devbounds45
.
zw
corners
.
zw
)
;
"
)
;
v
-
>
codeAppendf
(
"
refpt45
*
=
float2x2
(
+
1
+
1
-
wind
+
wind
)
*
.
5
;
"
)
;
v
-
>
codeAppendf
(
"
float2x2
N
=
float2x2
(
"
"
corners
.
z
+
corners
.
w
-
1
corners
.
w
-
corners
.
z
"
"
corners
.
xy
*
2
-
1
)
;
"
)
;
v
-
>
codeAppendf
(
"
N
=
float2x2
(
wind
0
0
1
)
*
N
;
"
)
;
v
-
>
codeAppendf
(
"
float2
K
=
float2
(
dot
(
N
[
0
]
refpt
)
dot
(
N
[
1
]
refpt45
)
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
octocoord
=
K
*
inverse
(
N
)
;
"
)
;
v
-
>
codeAppendf
(
"
float2
bloatdir
=
(
0
!
=
N
[
0
]
.
x
)
"
"
?
float2
(
N
[
0
]
.
x
N
[
1
]
.
y
)
"
"
:
float2
(
N
[
1
]
.
x
N
[
0
]
.
y
)
;
"
)
;
v
-
>
codeAppendf
(
"
octocoord
=
(
ceil
(
octocoord
*
bloatdir
-
1e
-
4
)
+
0
.
25
)
*
bloatdir
;
"
)
;
v
-
>
codeAppendf
(
"
float2
atlascoord
=
octocoord
+
float2
(
dev_to_atlas_offset
)
;
"
)
;
if
(
kTopLeft_GrSurfaceOrigin
=
=
proc
.
fAtlasOrigin
)
{
v
-
>
codeAppendf
(
"
%
s
.
xy
=
atlascoord
*
%
s
;
"
texcoord
.
vsOut
(
)
atlasAdjust
)
;
}
else
{
SkASSERT
(
kBottomLeft_GrSurfaceOrigin
=
=
proc
.
fAtlasOrigin
)
;
v
-
>
codeAppendf
(
"
%
s
.
xy
=
float2
(
atlascoord
.
x
*
%
s
.
x
1
-
atlascoord
.
y
*
%
s
.
y
)
;
"
texcoord
.
vsOut
(
)
atlasAdjust
atlasAdjust
)
;
}
if
(
isCoverageCount
)
{
v
-
>
codeAppendf
(
"
%
s
.
z
=
wind
*
.
5
;
"
texcoord
.
vsOut
(
)
)
;
}
gpArgs
-
>
fPositionVar
.
set
(
kFloat2_GrSLType
"
octocoord
"
)
;
this
-
>
emitTransforms
(
v
varyingHandler
uniHandler
gpArgs
-
>
fPositionVar
proc
.
fLocalMatrix
args
.
fFPCoordTransformHandler
)
;
GrGLSLFPFragmentBuilder
*
f
=
args
.
fFragBuilder
;
f
-
>
codeAppendf
(
"
half
coverage
=
"
)
;
f
-
>
appendTextureLookup
(
args
.
fTexSamplers
[
0
]
SkStringPrintf
(
"
%
s
.
xy
"
texcoord
.
fsIn
(
)
)
.
c_str
(
)
kFloat2_GrSLType
)
;
f
-
>
codeAppendf
(
"
.
a
;
"
)
;
if
(
isCoverageCount
)
{
f
-
>
codeAppendf
(
"
coverage
=
abs
(
coverage
)
;
"
)
;
f
-
>
codeAppendf
(
"
coverage
=
min
(
abs
(
coverage
)
*
half
(
%
s
.
z
)
.
5
)
;
"
texcoord
.
fsIn
(
)
)
;
f
-
>
codeAppend
(
"
coverage
=
1
-
abs
(
fract
(
coverage
)
*
2
-
1
)
;
"
)
;
}
f
-
>
codeAppendf
(
"
%
s
=
half4
(
coverage
)
;
"
args
.
fOutputCoverage
)
;
}
