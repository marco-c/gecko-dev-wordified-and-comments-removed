#
include
"
src
/
gpu
/
ccpr
/
GrCCStrokeGeometry
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
src
/
core
/
SkGeometry
.
h
"
#
include
"
src
/
core
/
SkMathPriv
.
h
"
static
constexpr
float
kMaxErrorFromLinearization
=
1
/
8
.
f
;
static
inline
float
length
(
const
Sk2f
&
n
)
{
Sk2f
nn
=
n
*
n
;
return
SkScalarSqrt
(
nn
[
0
]
+
nn
[
1
]
)
;
}
static
inline
Sk2f
normalize
(
const
Sk2f
&
v
)
{
Sk2f
vv
=
v
*
v
;
vv
+
=
SkNx_shuffle
<
1
0
>
(
vv
)
;
return
v
*
vv
.
rsqrt
(
)
;
}
static
inline
void
transpose
(
const
Sk2f
&
a
const
Sk2f
&
b
Sk2f
*
X
Sk2f
*
Y
)
{
float
transpose
[
4
]
;
a
.
store
(
transpose
)
;
b
.
store
(
transpose
+
2
)
;
Sk2f
:
:
Load2
(
transpose
X
Y
)
;
}
static
inline
void
normalize2
(
const
Sk2f
&
v0
const
Sk2f
&
v1
SkPoint
out
[
2
]
)
{
Sk2f
X
Y
;
transpose
(
v0
v1
&
X
&
Y
)
;
Sk2f
invlength
=
(
X
*
X
+
Y
*
Y
)
.
rsqrt
(
)
;
Sk2f
:
:
Store2
(
out
Y
*
invlength
-
X
*
invlength
)
;
}
static
inline
float
calc_curvature_costheta
(
const
Sk2f
&
leftTan
const
Sk2f
&
rightTan
)
{
Sk2f
X
Y
;
transpose
(
leftTan
rightTan
&
X
&
Y
)
;
Sk2f
invlength
=
(
X
*
X
+
Y
*
Y
)
.
rsqrt
(
)
;
Sk2f
dotprod
=
leftTan
*
rightTan
;
return
(
dotprod
[
0
]
+
dotprod
[
1
]
)
*
invlength
[
0
]
*
invlength
[
1
]
;
}
static
GrCCStrokeGeometry
:
:
Verb
join_verb_from_join
(
SkPaint
:
:
Join
join
)
{
using
Verb
=
GrCCStrokeGeometry
:
:
Verb
;
switch
(
join
)
{
case
SkPaint
:
:
kBevel_Join
:
return
Verb
:
:
kBevelJoin
;
case
SkPaint
:
:
kMiter_Join
:
return
Verb
:
:
kMiterJoin
;
case
SkPaint
:
:
kRound_Join
:
return
Verb
:
:
kRoundJoin
;
}
SK_ABORT
(
"
Invalid
SkPaint
:
:
Join
.
"
)
;
}
void
GrCCStrokeGeometry
:
:
beginPath
(
const
SkStrokeRec
&
stroke
float
strokeDevWidth
InstanceTallies
*
tallies
)
{
SkASSERT
(
!
fInsideContour
)
;
SkASSERT
(
strokeDevWidth
>
0
)
;
fCurrStrokeRadius
=
strokeDevWidth
/
2
;
fCurrStrokeJoinVerb
=
join_verb_from_join
(
stroke
.
getJoin
(
)
)
;
fCurrStrokeCapType
=
stroke
.
getCap
(
)
;
fCurrStrokeTallies
=
tallies
;
if
(
Verb
:
:
kMiterJoin
=
=
fCurrStrokeJoinVerb
)
{
float
m
=
stroke
.
getMiter
(
)
;
fMiterMaxCapHeightOverWidth
=
.
5f
*
SkScalarSqrt
(
m
*
m
-
1
)
;
}
float
r
=
SkTMax
(
1
-
kMaxErrorFromLinearization
/
fCurrStrokeRadius
0
.
f
)
;
fMaxCurvatureCosTheta
=
2
*
r
*
r
-
1
;
fCurrContourFirstPtIdx
=
-
1
;
fCurrContourFirstNormalIdx
=
-
1
;
fVerbs
.
push_back
(
Verb
:
:
kBeginPath
)
;
}
void
GrCCStrokeGeometry
:
:
moveTo
(
SkPoint
pt
)
{
SkASSERT
(
!
fInsideContour
)
;
fCurrContourFirstPtIdx
=
fPoints
.
count
(
)
;
fCurrContourFirstNormalIdx
=
fNormals
.
count
(
)
;
fPoints
.
push_back
(
pt
)
;
SkDEBUGCODE
(
fInsideContour
=
true
)
;
}
void
GrCCStrokeGeometry
:
:
lineTo
(
SkPoint
pt
)
{
SkASSERT
(
fInsideContour
)
;
this
-
>
lineTo
(
fCurrStrokeJoinVerb
pt
)
;
}
void
GrCCStrokeGeometry
:
:
lineTo
(
Verb
leftJoinVerb
SkPoint
pt
)
{
Sk2f
tan
=
Sk2f
:
:
Load
(
&
pt
)
-
Sk2f
:
:
Load
(
&
fPoints
.
back
(
)
)
;
if
(
(
tan
=
=
0
)
.
allTrue
(
)
)
{
return
;
}
tan
=
normalize
(
tan
)
;
SkVector
n
=
SkVector
:
:
Make
(
tan
[
1
]
-
tan
[
0
]
)
;
this
-
>
recordLeftJoinIfNotEmpty
(
leftJoinVerb
n
)
;
fNormals
.
push_back
(
n
)
;
this
-
>
recordStroke
(
Verb
:
:
kLinearStroke
0
)
;
fPoints
.
push_back
(
pt
)
;
}
void
GrCCStrokeGeometry
:
:
quadraticTo
(
const
SkPoint
P
[
3
]
)
{
SkASSERT
(
fInsideContour
)
;
this
-
>
quadraticTo
(
fCurrStrokeJoinVerb
P
SkFindQuadMaxCurvature
(
P
)
)
;
}
static
inline
float
wangs_formula_quadratic
(
const
Sk2f
&
p0
const
Sk2f
&
p1
const
Sk2f
&
p2
)
{
static
constexpr
float
k
=
2
/
(
8
*
kMaxErrorFromLinearization
)
;
float
f
=
SkScalarSqrt
(
k
*
length
(
p2
-
p1
*
2
+
p0
)
)
;
return
SkScalarCeilToInt
(
f
)
;
}
void
GrCCStrokeGeometry
:
:
quadraticTo
(
Verb
leftJoinVerb
const
SkPoint
P
[
3
]
float
maxCurvatureT
)
{
Sk2f
p0
=
Sk2f
:
:
Load
(
P
)
;
Sk2f
p1
=
Sk2f
:
:
Load
(
P
+
1
)
;
Sk2f
p2
=
Sk2f
:
:
Load
(
P
+
2
)
;
Sk2f
tan0
=
p1
-
p0
;
Sk2f
tan1
=
p2
-
p1
;
if
(
(
tan0
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
|
|
(
tan1
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
)
{
this
-
>
lineTo
(
leftJoinVerb
P
[
2
]
)
;
return
;
}
SkPoint
normals
[
2
]
;
normalize2
(
tan0
tan1
normals
)
;
int
numSegments
=
wangs_formula_quadratic
(
p0
p1
p2
)
;
numSegments
=
SkTMin
(
numSegments
1
<
<
kMaxNumLinearSegmentsLog2
)
;
if
(
numSegments
<
=
1
)
{
this
-
>
rotateTo
(
leftJoinVerb
normals
[
0
]
)
;
this
-
>
lineTo
(
Verb
:
:
kInternalRoundJoin
P
[
2
]
)
;
this
-
>
rotateTo
(
Verb
:
:
kInternalRoundJoin
normals
[
1
]
)
;
return
;
}
Sk2f
A
=
p0
-
p1
*
2
+
p2
;
Sk2f
B
=
p1
-
p0
;
float
segmentLength
=
SkScalarInvert
(
numSegments
)
;
float
leftT
=
maxCurvatureT
-
segmentLength
/
2
;
float
rightT
=
maxCurvatureT
+
segmentLength
/
2
;
Sk2f
leftTan
rightTan
;
if
(
leftT
<
=
0
)
{
leftT
=
0
;
leftTan
=
tan0
;
rightT
=
segmentLength
;
rightTan
=
A
*
rightT
+
B
;
}
else
if
(
rightT
>
=
1
)
{
leftT
=
1
-
segmentLength
;
leftTan
=
A
*
leftT
+
B
;
rightT
=
1
;
rightTan
=
tan1
;
}
else
{
leftTan
=
A
*
leftT
+
B
;
rightTan
=
A
*
rightT
+
B
;
}
bool
isCurvatureTooStrong
=
calc_curvature_costheta
(
leftTan
rightTan
)
<
fMaxCurvatureCosTheta
;
if
(
isCurvatureTooStrong
)
{
SkPoint
ptsBuffer
[
5
]
;
const
SkPoint
*
currQuadratic
=
P
;
if
(
leftT
>
0
)
{
SkChopQuadAt
(
currQuadratic
ptsBuffer
leftT
)
;
this
-
>
quadraticTo
(
leftJoinVerb
ptsBuffer
1
)
;
if
(
rightT
<
1
)
{
rightT
=
(
rightT
-
leftT
)
/
(
1
-
leftT
)
;
}
currQuadratic
=
ptsBuffer
+
2
;
}
else
{
this
-
>
rotateTo
(
leftJoinVerb
normals
[
0
]
)
;
}
if
(
rightT
<
1
)
{
SkChopQuadAt
(
currQuadratic
ptsBuffer
rightT
)
;
this
-
>
lineTo
(
Verb
:
:
kInternalRoundJoin
ptsBuffer
[
2
]
)
;
this
-
>
quadraticTo
(
Verb
:
:
kInternalRoundJoin
ptsBuffer
+
2
0
)
;
}
else
{
this
-
>
lineTo
(
Verb
:
:
kInternalRoundJoin
currQuadratic
[
2
]
)
;
this
-
>
rotateTo
(
Verb
:
:
kInternalRoundJoin
normals
[
1
]
)
;
}
return
;
}
this
-
>
recordLeftJoinIfNotEmpty
(
leftJoinVerb
normals
[
0
]
)
;
fNormals
.
push_back_n
(
2
normals
)
;
this
-
>
recordStroke
(
Verb
:
:
kQuadraticStroke
SkNextLog2
(
numSegments
)
)
;
p1
.
store
(
&
fPoints
.
push_back
(
)
)
;
p2
.
store
(
&
fPoints
.
push_back
(
)
)
;
}
void
GrCCStrokeGeometry
:
:
cubicTo
(
const
SkPoint
P
[
4
]
)
{
SkASSERT
(
fInsideContour
)
;
float
roots
[
3
]
;
int
numRoots
=
SkFindCubicMaxCurvature
(
P
roots
)
;
this
-
>
cubicTo
(
fCurrStrokeJoinVerb
P
numRoots
>
0
?
roots
[
numRoots
/
2
]
:
0
numRoots
>
1
?
roots
[
0
]
:
kLeftMaxCurvatureNone
numRoots
>
2
?
roots
[
2
]
:
kRightMaxCurvatureNone
)
;
}
static
inline
float
wangs_formula_cubic
(
const
Sk2f
&
p0
const
Sk2f
&
p1
const
Sk2f
&
p2
const
Sk2f
&
p3
)
{
static
constexpr
float
k
=
(
3
*
2
)
/
(
8
*
kMaxErrorFromLinearization
)
;
float
f
=
SkScalarSqrt
(
k
*
length
(
Sk2f
:
:
Max
(
(
p2
-
p1
*
2
+
p0
)
.
abs
(
)
(
p3
-
p2
*
2
+
p1
)
.
abs
(
)
)
)
)
;
return
SkScalarCeilToInt
(
f
)
;
}
void
GrCCStrokeGeometry
:
:
cubicTo
(
Verb
leftJoinVerb
const
SkPoint
P
[
4
]
float
maxCurvatureT
float
leftMaxCurvatureT
float
rightMaxCurvatureT
)
{
Sk2f
p0
=
Sk2f
:
:
Load
(
P
)
;
Sk2f
p1
=
Sk2f
:
:
Load
(
P
+
1
)
;
Sk2f
p2
=
Sk2f
:
:
Load
(
P
+
2
)
;
Sk2f
p3
=
Sk2f
:
:
Load
(
P
+
3
)
;
Sk2f
tan0
=
p1
-
p0
;
Sk2f
tan1
=
p3
-
p2
;
if
(
(
tan0
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
)
{
p1
=
p0
;
tan0
=
p2
-
p0
;
if
(
(
tan0
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
)
{
this
-
>
lineTo
(
leftJoinVerb
P
[
3
]
)
;
return
;
}
}
if
(
(
tan1
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
)
{
p2
=
p3
;
tan1
=
p3
-
p1
;
if
(
(
tan1
.
abs
(
)
<
SK_ScalarNearlyZero
)
.
allTrue
(
)
|
|
(
p0
=
=
p1
)
.
allTrue
(
)
)
{
this
-
>
lineTo
(
leftJoinVerb
P
[
3
]
)
;
return
;
}
}
SkPoint
normals
[
2
]
;
normalize2
(
tan0
tan1
normals
)
;
int
numSegments
=
wangs_formula_cubic
(
p0
p1
p2
p3
)
;
numSegments
=
SkTMin
(
numSegments
1
<
<
kMaxNumLinearSegmentsLog2
)
;
if
(
numSegments
<
=
1
)
{
this
-
>
rotateTo
(
leftJoinVerb
normals
[
0
]
)
;
this
-
>
lineTo
(
leftJoinVerb
P
[
3
]
)
;
this
-
>
rotateTo
(
Verb
:
:
kInternalRoundJoin
normals
[
1
]
)
;
return
;
}
Sk2f
A
=
p3
+
(
p1
-
p2
)
*
3
-
p0
;
Sk2f
B
=
(
p0
-
p1
*
2
+
p2
)
*
2
;
Sk2f
C
=
p1
-
p0
;
float
segmentLength
=
SkScalarInvert
(
numSegments
)
;
float
leftT
=
maxCurvatureT
-
segmentLength
/
2
;
float
rightT
=
maxCurvatureT
+
segmentLength
/
2
;
Sk2f
leftTan
rightTan
;
if
(
leftT
<
=
0
)
{
leftT
=
0
;
leftTan
=
tan0
;
rightT
=
segmentLength
;
rightTan
=
A
*
rightT
*
rightT
+
B
*
rightT
+
C
;
}
else
if
(
rightT
>
=
1
)
{
leftT
=
1
-
segmentLength
;
leftTan
=
A
*
leftT
*
leftT
+
B
*
leftT
+
C
;
rightT
=
1
;
rightTan
=
tan1
;
}
else
{
leftTan
=
A
*
leftT
*
leftT
+
B
*
leftT
+
C
;
rightTan
=
A
*
rightT
*
rightT
+
B
*
rightT
+
C
;
}
bool
isCurvatureTooStrong
=
calc_curvature_costheta
(
leftTan
rightTan
)
<
fMaxCurvatureCosTheta
;
if
(
isCurvatureTooStrong
)
{
SkPoint
ptsBuffer
[
7
]
;
p0
.
store
(
ptsBuffer
)
;
p1
.
store
(
ptsBuffer
+
1
)
;
p2
.
store
(
ptsBuffer
+
2
)
;
p3
.
store
(
ptsBuffer
+
3
)
;
const
SkPoint
*
currCubic
=
ptsBuffer
;
if
(
leftT
>
0
)
{
SkChopCubicAt
(
currCubic
ptsBuffer
leftT
)
;
this
-
>
cubicTo
(
leftJoinVerb
ptsBuffer
1
(
kLeftMaxCurvatureNone
!
=
leftMaxCurvatureT
)
?
leftMaxCurvatureT
/
leftT
:
kLeftMaxCurvatureNone
kRightMaxCurvatureNone
)
;
if
(
rightT
<
1
)
{
rightT
=
(
rightT
-
leftT
)
/
(
1
-
leftT
)
;
}
if
(
rightMaxCurvatureT
<
1
&
&
kRightMaxCurvatureNone
!
=
rightMaxCurvatureT
)
{
rightMaxCurvatureT
=
(
rightMaxCurvatureT
-
leftT
)
/
(
1
-
leftT
)
;
}
currCubic
=
ptsBuffer
+
3
;
}
else
{
this
-
>
rotateTo
(
leftJoinVerb
normals
[
0
]
)
;
}
if
(
rightT
<
1
)
{
SkChopCubicAt
(
currCubic
ptsBuffer
rightT
)
;
this
-
>
lineTo
(
Verb
:
:
kInternalRoundJoin
ptsBuffer
[
3
]
)
;
currCubic
=
ptsBuffer
+
3
;
this
-
>
cubicTo
(
Verb
:
:
kInternalRoundJoin
currCubic
0
kLeftMaxCurvatureNone
kRightMaxCurvatureNone
)
;
}
else
{
this
-
>
lineTo
(
Verb
:
:
kInternalRoundJoin
currCubic
[
3
]
)
;
this
-
>
rotateTo
(
Verb
:
:
kInternalRoundJoin
normals
[
1
]
)
;
}
return
;
}
if
(
kRightMaxCurvatureNone
!
=
rightMaxCurvatureT
)
{
this
-
>
cubicTo
(
leftJoinVerb
P
rightMaxCurvatureT
leftMaxCurvatureT
kRightMaxCurvatureNone
)
;
return
;
}
if
(
kLeftMaxCurvatureNone
!
=
leftMaxCurvatureT
)
{
SkASSERT
(
kRightMaxCurvatureNone
=
=
rightMaxCurvatureT
)
;
this
-
>
cubicTo
(
leftJoinVerb
P
leftMaxCurvatureT
kLeftMaxCurvatureNone
kRightMaxCurvatureNone
)
;
return
;
}
this
-
>
recordLeftJoinIfNotEmpty
(
leftJoinVerb
normals
[
0
]
)
;
fNormals
.
push_back_n
(
2
normals
)
;
this
-
>
recordStroke
(
Verb
:
:
kCubicStroke
SkNextLog2
(
numSegments
)
)
;
p1
.
store
(
&
fPoints
.
push_back
(
)
)
;
p2
.
store
(
&
fPoints
.
push_back
(
)
)
;
p3
.
store
(
&
fPoints
.
push_back
(
)
)
;
}
void
GrCCStrokeGeometry
:
:
recordStroke
(
Verb
verb
int
numSegmentsLog2
)
{
SkASSERT
(
Verb
:
:
kLinearStroke
!
=
verb
|
|
0
=
=
numSegmentsLog2
)
;
SkASSERT
(
numSegmentsLog2
<
=
kMaxNumLinearSegmentsLog2
)
;
fVerbs
.
push_back
(
verb
)
;
if
(
Verb
:
:
kLinearStroke
!
=
verb
)
{
SkASSERT
(
numSegmentsLog2
>
0
)
;
fParams
.
push_back
(
)
.
fNumLinearSegmentsLog2
=
numSegmentsLog2
;
}
+
+
fCurrStrokeTallies
-
>
fStrokes
[
numSegmentsLog2
]
;
}
void
GrCCStrokeGeometry
:
:
rotateTo
(
Verb
leftJoinVerb
SkVector
normal
)
{
this
-
>
recordLeftJoinIfNotEmpty
(
leftJoinVerb
normal
)
;
fNormals
.
push_back
(
normal
)
;
}
void
GrCCStrokeGeometry
:
:
recordLeftJoinIfNotEmpty
(
Verb
joinVerb
SkVector
nextNormal
)
{
if
(
fNormals
.
count
(
)
<
=
fCurrContourFirstNormalIdx
)
{
SkASSERT
(
fNormals
.
count
(
)
=
=
fCurrContourFirstNormalIdx
)
;
return
;
}
if
(
Verb
:
:
kBevelJoin
=
=
joinVerb
)
{
this
-
>
recordBevelJoin
(
Verb
:
:
kBevelJoin
)
;
return
;
}
Sk2f
n0
=
Sk2f
:
:
Load
(
&
fNormals
.
back
(
)
)
;
Sk2f
n1
=
Sk2f
:
:
Load
(
&
nextNormal
)
;
Sk2f
base
=
n1
-
n0
;
if
(
(
base
.
abs
(
)
*
fCurrStrokeRadius
<
kMaxErrorFromLinearization
)
.
allTrue
(
)
)
{
this
-
>
recordBevelJoin
(
joinVerb
)
;
return
;
}
Sk2f
cross
=
base
*
SkNx_shuffle
<
1
0
>
(
n0
)
;
Sk2f
dot
=
base
*
n0
;
float
miterCapHeight
=
SkScalarAbs
(
dot
[
0
]
+
dot
[
1
]
)
;
float
miterCapWidth
=
SkScalarAbs
(
cross
[
0
]
-
cross
[
1
]
)
*
2
;
if
(
Verb
:
:
kMiterJoin
=
=
joinVerb
)
{
if
(
miterCapHeight
>
fMiterMaxCapHeightOverWidth
*
miterCapWidth
)
{
this
-
>
recordBevelJoin
(
Verb
:
:
kMiterJoin
)
;
return
;
}
this
-
>
recordMiterJoin
(
miterCapHeight
/
miterCapWidth
)
;
return
;
}
SkASSERT
(
Verb
:
:
kRoundJoin
=
=
joinVerb
|
|
Verb
:
:
kInternalRoundJoin
=
=
joinVerb
)
;
static
constexpr
float
kAlmost180Degrees
=
32
;
if
(
miterCapHeight
>
kAlmost180Degrees
*
miterCapWidth
)
{
Sk2f
bisect
=
normalize
(
n0
-
n1
)
;
this
-
>
rotateTo
(
joinVerb
SkVector
:
:
Make
(
-
bisect
[
1
]
bisect
[
0
]
)
)
;
this
-
>
recordLeftJoinIfNotEmpty
(
joinVerb
nextNormal
)
;
return
;
}
float
miterCapHeightOverWidth
=
miterCapHeight
/
miterCapWidth
;
Sk2f
X
Y
;
transpose
(
base
*
base
n0
*
n1
&
X
&
Y
)
;
Sk2f
r
=
Sk2f
:
:
Max
(
X
+
Y
+
Sk2f
(
0
1
)
0
.
f
)
.
sqrt
(
)
;
Sk2f
heights
=
SkNx_fma
(
r
Sk2f
(
miterCapHeightOverWidth
-
SK_ScalarRoot2Over2
)
Sk2f
(
0
1
)
)
;
float
controlPointHeight
=
SkScalarAbs
(
heights
[
0
]
)
;
float
curveHeight
=
heights
[
1
]
;
if
(
curveHeight
*
fCurrStrokeRadius
<
kMaxErrorFromLinearization
)
{
this
-
>
recordBevelJoin
(
joinVerb
)
;
return
;
}
float
w
=
curveHeight
/
(
controlPointHeight
-
curveHeight
)
;
this
-
>
recordRoundJoin
(
joinVerb
miterCapHeightOverWidth
w
)
;
}
void
GrCCStrokeGeometry
:
:
recordBevelJoin
(
Verb
originalJoinVerb
)
{
if
(
!
IsInternalJoinVerb
(
originalJoinVerb
)
)
{
fVerbs
.
push_back
(
Verb
:
:
kBevelJoin
)
;
+
+
fCurrStrokeTallies
-
>
fTriangles
;
}
else
{
fVerbs
.
push_back
(
Verb
:
:
kInternalBevelJoin
)
;
fCurrStrokeTallies
-
>
fTriangles
+
=
2
;
}
}
void
GrCCStrokeGeometry
:
:
recordMiterJoin
(
float
miterCapHeightOverWidth
)
{
fVerbs
.
push_back
(
Verb
:
:
kMiterJoin
)
;
fParams
.
push_back
(
)
.
fMiterCapHeightOverWidth
=
miterCapHeightOverWidth
;
fCurrStrokeTallies
-
>
fTriangles
+
=
2
;
}
void
GrCCStrokeGeometry
:
:
recordRoundJoin
(
Verb
joinVerb
float
miterCapHeightOverWidth
float
conicWeight
)
{
fVerbs
.
push_back
(
joinVerb
)
;
fParams
.
push_back
(
)
.
fConicWeight
=
conicWeight
;
fParams
.
push_back
(
)
.
fMiterCapHeightOverWidth
=
miterCapHeightOverWidth
;
if
(
Verb
:
:
kRoundJoin
=
=
joinVerb
)
{
+
+
fCurrStrokeTallies
-
>
fTriangles
;
+
+
fCurrStrokeTallies
-
>
fConics
;
}
else
{
SkASSERT
(
Verb
:
:
kInternalRoundJoin
=
=
joinVerb
)
;
fCurrStrokeTallies
-
>
fTriangles
+
=
2
;
fCurrStrokeTallies
-
>
fConics
+
=
2
;
}
}
void
GrCCStrokeGeometry
:
:
closeContour
(
)
{
SkASSERT
(
fInsideContour
)
;
SkASSERT
(
fPoints
.
count
(
)
>
fCurrContourFirstPtIdx
)
;
if
(
fPoints
.
back
(
)
!
=
fPoints
[
fCurrContourFirstPtIdx
]
)
{
this
-
>
lineTo
(
fCurrStrokeJoinVerb
fPoints
[
fCurrContourFirstPtIdx
]
)
;
}
if
(
fNormals
.
count
(
)
>
fCurrContourFirstNormalIdx
)
{
this
-
>
rotateTo
(
fCurrStrokeJoinVerb
fNormals
[
fCurrContourFirstNormalIdx
]
)
;
}
else
{
SkASSERT
(
fNormals
.
count
(
)
=
=
fCurrContourFirstNormalIdx
)
;
fNormals
.
push_back
(
{
0
0
}
)
;
}
fVerbs
.
push_back
(
Verb
:
:
kEndContour
)
;
SkDEBUGCODE
(
fInsideContour
=
false
)
;
}
void
GrCCStrokeGeometry
:
:
capContourAndExit
(
)
{
SkASSERT
(
fInsideContour
)
;
if
(
fCurrContourFirstNormalIdx
>
=
fNormals
.
count
(
)
)
{
SkASSERT
(
fNormals
.
count
(
)
=
=
fCurrContourFirstNormalIdx
)
;
fNormals
.
push_back
(
{
1
0
}
)
;
}
this
-
>
recordCapsIfAny
(
)
;
fVerbs
.
push_back
(
Verb
:
:
kEndContour
)
;
SkDEBUGCODE
(
fInsideContour
=
false
)
;
}
void
GrCCStrokeGeometry
:
:
recordCapsIfAny
(
)
{
SkASSERT
(
fInsideContour
)
;
SkASSERT
(
fCurrContourFirstNormalIdx
<
fNormals
.
count
(
)
)
;
if
(
SkPaint
:
:
kButt_Cap
=
=
fCurrStrokeCapType
)
{
return
;
}
Verb
capVerb
;
if
(
SkPaint
:
:
kSquare_Cap
=
=
fCurrStrokeCapType
)
{
if
(
fCurrStrokeRadius
*
SK_ScalarRoot2Over2
<
kMaxErrorFromLinearization
)
{
return
;
}
capVerb
=
Verb
:
:
kSquareCap
;
fCurrStrokeTallies
-
>
fStrokes
[
0
]
+
=
2
;
}
else
{
SkASSERT
(
SkPaint
:
:
kRound_Cap
=
=
fCurrStrokeCapType
)
;
if
(
fCurrStrokeRadius
<
kMaxErrorFromLinearization
)
{
return
;
}
capVerb
=
Verb
:
:
kRoundCap
;
fCurrStrokeTallies
-
>
fTriangles
+
=
2
;
fCurrStrokeTallies
-
>
fConics
+
=
4
;
}
fVerbs
.
push_back
(
capVerb
)
;
fVerbs
.
push_back
(
Verb
:
:
kEndContour
)
;
fVerbs
.
push_back
(
capVerb
)
;
fPoints
.
reserve
(
fPoints
.
count
(
)
+
1
)
;
fPoints
.
push_back
(
fPoints
[
fCurrContourFirstPtIdx
]
)
;
fNormals
.
reserve
(
fNormals
.
count
(
)
+
1
)
;
fNormals
.
push_back
(
-
fNormals
[
fCurrContourFirstNormalIdx
]
)
;
}
