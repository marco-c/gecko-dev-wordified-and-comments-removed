#
ifndef
GrCCQuadraticShader_DEFINED
#
define
GrCCQuadraticShader_DEFINED
#
include
"
ccpr
/
GrCCCoverageProcessor
.
h
"
class
GrCCQuadraticShader
:
public
GrCCCoverageProcessor
:
:
Shader
{
protected
:
void
emitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
repetitionID
const
char
*
wind
GeometryVars
*
)
const
final
;
virtual
void
onEmitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
repetitionID
GeometryVars
*
)
const
=
0
;
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
const
char
*
position
const
char
*
inputCoverage
const
char
*
wind
)
final
;
virtual
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
)
{
}
void
onEmitFragmentCode
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
final
;
virtual
void
emitCoverage
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
=
0
;
const
GrShaderVar
fCanonicalMatrix
{
"
canonical_matrix
"
kFloat3x3_GrSLType
}
;
const
GrShaderVar
fEdgeDistanceEquation
{
"
edge_distance_equation
"
kFloat3_GrSLType
}
;
GrGLSLVarying
fXYDW
;
}
;
class
GrCCQuadraticHullShader
:
public
GrCCQuadraticShader
{
void
onEmitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
repetitionID
GeometryVars
*
)
const
override
;
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
)
override
;
void
emitCoverage
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
override
;
GrGLSLVarying
fGrad
;
}
;
class
GrCCQuadraticCornerShader
:
public
GrCCQuadraticShader
{
void
onEmitSetupCode
(
GrGLSLVertexGeoBuilder
*
const
char
*
pts
const
char
*
repetitionID
GeometryVars
*
)
const
override
;
void
onEmitVaryings
(
GrGLSLVaryingHandler
*
GrGLSLVarying
:
:
Scope
SkString
*
code
)
override
;
void
emitCoverage
(
GrGLSLFPFragmentBuilder
*
const
char
*
outputCoverage
)
const
override
;
GrGLSLVarying
fdXYDdx
;
GrGLSLVarying
fdXYDdy
;
}
;
#
endif
