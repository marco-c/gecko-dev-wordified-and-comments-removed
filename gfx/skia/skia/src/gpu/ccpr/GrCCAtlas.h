#
ifndef
GrCCAtlas_DEFINED
#
define
GrCCAtlas_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
include
/
private
/
GrResourceKey
.
h
"
#
include
"
src
/
gpu
/
GrAllocator
.
h
"
#
include
"
src
/
gpu
/
GrNonAtomicRef
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceProxy
.
h
"
class
GrCCCachedAtlas
;
class
GrOnFlushResourceProvider
;
class
GrRenderTargetContext
;
class
GrResourceProvider
;
class
GrTextureProxy
;
struct
SkIPoint16
;
struct
SkIRect
;
class
GrCCAtlas
{
public
:
static
constexpr
GrSurfaceOrigin
kTextureOrigin
=
kTopLeft_GrSurfaceOrigin
;
static
constexpr
int
kPadding
=
1
;
struct
Specs
{
int
fMaxPreferredTextureSize
=
0
;
int
fMinTextureSize
=
0
;
int
fMinWidth
=
0
;
int
fMinHeight
=
0
;
int
fApproxNumPixels
=
0
;
void
accountForSpace
(
int
width
int
height
)
;
}
;
enum
class
CoverageType
{
kFP16_CoverageCount
kA8_Multisample
kA8_LiteralCoverage
}
;
static
constexpr
GrColorType
CoverageTypeToColorType
(
CoverageType
coverageType
)
{
switch
(
coverageType
)
{
case
CoverageType
:
:
kFP16_CoverageCount
:
return
GrColorType
:
:
kAlpha_F16
;
case
CoverageType
:
:
kA8_Multisample
:
case
CoverageType
:
:
kA8_LiteralCoverage
:
return
GrColorType
:
:
kAlpha_8
;
}
SkUNREACHABLE
;
}
using
LazyInstantiateAtlasCallback
=
std
:
:
function
<
sk_sp
<
GrTexture
>
(
GrResourceProvider
*
GrPixelConfig
const
GrBackendFormat
&
int
sampleCount
)
>
;
static
sk_sp
<
GrTextureProxy
>
MakeLazyAtlasProxy
(
const
LazyInstantiateAtlasCallback
&
CoverageType
const
GrCaps
&
GrSurfaceProxy
:
:
UseAllocator
)
;
GrCCAtlas
(
CoverageType
const
Specs
&
const
GrCaps
&
)
;
~
GrCCAtlas
(
)
;
GrTextureProxy
*
textureProxy
(
)
const
{
return
fTextureProxy
.
get
(
)
;
}
int
currentWidth
(
)
const
{
return
fWidth
;
}
int
currentHeight
(
)
const
{
return
fHeight
;
}
bool
addRect
(
const
SkIRect
&
devIBounds
SkIVector
*
atlasOffset
)
;
const
SkISize
&
drawBounds
(
)
{
return
fDrawBounds
;
}
void
setFillBatchID
(
int
id
)
;
int
getFillBatchID
(
)
const
{
return
fFillBatchID
;
}
void
setStrokeBatchID
(
int
id
)
;
int
getStrokeBatchID
(
)
const
{
return
fStrokeBatchID
;
}
void
setEndStencilResolveInstance
(
int
idx
)
;
int
getEndStencilResolveInstance
(
)
const
{
return
fEndStencilResolveInstance
;
}
sk_sp
<
GrCCCachedAtlas
>
refOrMakeCachedAtlas
(
GrOnFlushResourceProvider
*
)
;
std
:
:
unique_ptr
<
GrRenderTargetContext
>
makeRenderTargetContext
(
GrOnFlushResourceProvider
*
sk_sp
<
GrTexture
>
backingTexture
=
nullptr
)
;
private
:
class
Node
;
bool
internalPlaceRect
(
int
w
int
h
SkIPoint16
*
loc
)
;
const
CoverageType
fCoverageType
;
const
int
fMaxTextureSize
;
int
fWidth
fHeight
;
std
:
:
unique_ptr
<
Node
>
fTopNode
;
SkISize
fDrawBounds
=
{
0
0
}
;
int
fFillBatchID
;
int
fStrokeBatchID
;
int
fEndStencilResolveInstance
;
sk_sp
<
GrCCCachedAtlas
>
fCachedAtlas
;
sk_sp
<
GrTextureProxy
>
fTextureProxy
;
sk_sp
<
GrTexture
>
fBackingTexture
;
}
;
class
GrCCAtlasStack
{
public
:
using
CoverageType
=
GrCCAtlas
:
:
CoverageType
;
GrCCAtlasStack
(
CoverageType
coverageType
const
GrCCAtlas
:
:
Specs
&
specs
const
GrCaps
*
caps
)
:
fCoverageType
(
coverageType
)
fSpecs
(
specs
)
fCaps
(
caps
)
{
}
CoverageType
coverageType
(
)
const
{
return
fCoverageType
;
}
bool
empty
(
)
const
{
return
fAtlases
.
empty
(
)
;
}
const
GrCCAtlas
&
front
(
)
const
{
SkASSERT
(
!
this
-
>
empty
(
)
)
;
return
fAtlases
.
front
(
)
;
}
GrCCAtlas
&
front
(
)
{
SkASSERT
(
!
this
-
>
empty
(
)
)
;
return
fAtlases
.
front
(
)
;
}
GrCCAtlas
&
current
(
)
{
SkASSERT
(
!
this
-
>
empty
(
)
)
;
return
fAtlases
.
back
(
)
;
}
class
Iter
{
public
:
Iter
(
GrCCAtlasStack
&
stack
)
:
fImpl
(
&
stack
.
fAtlases
)
{
}
bool
next
(
)
{
return
fImpl
.
next
(
)
;
}
GrCCAtlas
*
operator
-
>
(
)
const
{
return
fImpl
.
get
(
)
;
}
private
:
typename
GrTAllocator
<
GrCCAtlas
>
:
:
Iter
fImpl
;
}
;
GrCCAtlas
*
addRect
(
const
SkIRect
&
devIBounds
SkIVector
*
devToAtlasOffset
)
;
private
:
const
CoverageType
fCoverageType
;
const
GrCCAtlas
:
:
Specs
fSpecs
;
const
GrCaps
*
const
fCaps
;
GrSTAllocator
<
4
GrCCAtlas
>
fAtlases
;
}
;
inline
void
GrCCAtlas
:
:
Specs
:
:
accountForSpace
(
int
width
int
height
)
{
fMinWidth
=
SkTMax
(
width
fMinWidth
)
;
fMinHeight
=
SkTMax
(
height
fMinHeight
)
;
fApproxNumPixels
+
=
(
width
+
kPadding
)
*
(
height
+
kPadding
)
;
}
#
endif
