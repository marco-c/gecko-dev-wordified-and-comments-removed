#
ifndef
GrClipMaskManager_DEFINED
#
define
GrClipMaskManager_DEFINED
#
include
"
GrPipelineBuilder
.
h
"
#
include
"
GrReducedClip
.
h
"
#
include
"
GrStencil
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
SkClipStack
.
h
"
#
include
"
SkDeque
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTLList
.
h
"
#
include
"
SkTypes
.
h
"
class
GrDrawTarget
;
class
GrPathRenderer
;
class
GrPathRendererChain
;
class
GrResourceProvider
;
class
GrTexture
;
class
SkPath
;
class
GrAppliedClip
:
public
SkNoncopyable
{
public
:
GrAppliedClip
(
)
{
}
const
GrFragmentProcessor
*
clipCoverageFragmentProcessor
(
)
const
{
return
fClipCoverageFP
;
}
const
GrScissorState
&
scissorState
(
)
const
{
return
fScissorState
;
}
private
:
SkAutoTUnref
<
const
GrFragmentProcessor
>
fClipCoverageFP
;
GrScissorState
fScissorState
;
friend
class
GrClipMaskManager
;
typedef
SkNoncopyable
INHERITED
;
}
;
class
GrClipMaskManager
:
SkNoncopyable
{
public
:
GrClipMaskManager
(
GrDrawTarget
*
owner
bool
debugClipBatchToBounds
)
;
bool
setupClipping
(
const
GrPipelineBuilder
&
GrPipelineBuilder
:
:
AutoRestoreStencil
*
const
SkRect
*
devBounds
GrAppliedClip
*
)
;
bool
setupScissorClip
(
const
GrPipelineBuilder
&
pipelineBuilder
GrPipelineBuilder
:
:
AutoRestoreStencil
*
ars
const
SkIRect
&
scissor
const
SkRect
*
devBounds
GrAppliedClip
*
out
)
;
void
adjustPathStencilParams
(
const
GrStencilAttachment
*
GrStencilSettings
*
)
;
private
:
inline
GrContext
*
getContext
(
)
;
inline
const
GrCaps
*
caps
(
)
const
;
inline
GrResourceProvider
*
resourceProvider
(
)
;
static
bool
PathNeedsSWRenderer
(
GrContext
*
context
bool
isStencilDisabled
const
GrRenderTarget
*
rt
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
GrPathRenderer
*
*
prOut
bool
needsStencil
)
;
static
GrPathRenderer
*
GetPathRenderer
(
GrContext
*
context
GrTexture
*
texture
const
SkMatrix
&
viewMatrix
const
SkClipStack
:
:
Element
*
element
)
;
enum
StencilClipMode
{
kModifyClip_StencilClipMode
kRespectClip_StencilClipMode
kIgnoreClip_StencilClipMode
}
;
bool
getAnalyticClipProcessor
(
const
GrReducedClip
:
:
ElementList
&
bool
abortIfAA
SkVector
&
clipOffset
const
SkRect
*
devBounds
const
GrFragmentProcessor
*
*
fp
)
;
bool
createStencilClipMask
(
GrRenderTarget
*
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkIRect
&
clipSpaceIBounds
const
SkIPoint
&
clipSpaceToStencilOffset
)
;
static
GrTexture
*
CreateAlphaClipMask
(
GrContext
*
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkVector
&
clipToMaskOffset
const
SkIRect
&
clipSpaceIBounds
)
;
static
GrTexture
*
CreateSoftwareClipMask
(
GrContext
*
int32_t
elementsGenID
GrReducedClip
:
:
InitialState
initialState
const
GrReducedClip
:
:
ElementList
&
elements
const
SkVector
&
clipToMaskOffset
const
SkIRect
&
clipSpaceIBounds
)
;
static
bool
UseSWOnlyPath
(
GrContext
*
const
GrPipelineBuilder
&
const
GrRenderTarget
*
rt
const
SkVector
&
clipToMaskOffset
const
GrReducedClip
:
:
ElementList
&
elements
)
;
void
setPipelineBuilderStencil
(
const
GrPipelineBuilder
&
GrPipelineBuilder
:
:
AutoRestoreStencil
*
)
;
void
adjustStencilParams
(
GrStencilSettings
*
settings
StencilClipMode
mode
int
stencilBitCnt
)
;
GrTexture
*
createCachedMask
(
int
width
int
height
const
GrUniqueKey
&
key
bool
renderTarget
)
;
static
const
int
kMaxAnalyticElements
=
4
;
GrDrawTarget
*
fDrawTarget
;
StencilClipMode
fClipMode
;
bool
fDebugClipBatchToBounds
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
endif
