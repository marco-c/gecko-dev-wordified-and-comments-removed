#
include
"
GrRenderTargetOpList
.
h
"
#
include
"
GrAuditTrail
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrGpuCommandBuffer
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrRect
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrResourceAllocator
.
h
"
#
include
"
ops
/
GrClearOp
.
h
"
#
include
"
ops
/
GrCopySurfaceOp
.
h
"
#
include
"
SkTraceEvent
.
h
"
static
const
int
kMaxOpLookback
=
10
;
static
const
int
kMaxOpLookahead
=
10
;
GrRenderTargetOpList
:
:
GrRenderTargetOpList
(
GrResourceProvider
*
resourceProvider
sk_sp
<
GrOpMemoryPool
>
opMemoryPool
GrRenderTargetProxy
*
proxy
GrAuditTrail
*
auditTrail
)
:
INHERITED
(
resourceProvider
std
:
:
move
(
opMemoryPool
)
proxy
auditTrail
)
fLastClipStackGenID
(
SK_InvalidUniqueID
)
SkDEBUGCODE
(
fNumClips
(
0
)
)
{
}
void
GrRenderTargetOpList
:
:
RecordedOp
:
:
deleteOp
(
GrOpMemoryPool
*
opMemoryPool
)
{
opMemoryPool
-
>
release
(
std
:
:
move
(
fOp
)
)
;
}
void
GrRenderTargetOpList
:
:
deleteOps
(
)
{
for
(
int
i
=
0
;
i
<
fRecordedOps
.
count
(
)
;
+
+
i
)
{
if
(
fRecordedOps
[
i
]
.
fOp
)
{
fRecordedOps
[
i
]
.
deleteOp
(
fOpMemoryPool
.
get
(
)
)
;
}
}
fRecordedOps
.
reset
(
)
;
}
GrRenderTargetOpList
:
:
~
GrRenderTargetOpList
(
)
{
this
-
>
deleteOps
(
)
;
}
#
ifdef
SK_DEBUG
void
GrRenderTargetOpList
:
:
dump
(
bool
printDependencies
)
const
{
INHERITED
:
:
dump
(
printDependencies
)
;
SkDebugf
(
"
ops
(
%
d
)
:
\
n
"
fRecordedOps
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fRecordedOps
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
;
if
(
!
fRecordedOps
[
i
]
.
fOp
)
{
SkDebugf
(
"
%
d
:
<
combined
forward
or
failed
instantiation
>
\
n
"
i
)
;
}
else
{
SkDebugf
(
"
%
d
:
%
s
\
n
"
i
fRecordedOps
[
i
]
.
fOp
-
>
name
(
)
)
;
SkString
str
=
fRecordedOps
[
i
]
.
fOp
-
>
dumpInfo
(
)
;
SkDebugf
(
"
%
s
\
n
"
str
.
c_str
(
)
)
;
const
SkRect
&
bounds
=
fRecordedOps
[
i
]
.
fOp
-
>
bounds
(
)
;
SkDebugf
(
"
ClippedBounds
:
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
bounds
.
fLeft
bounds
.
fTop
bounds
.
fRight
bounds
.
fBottom
)
;
}
}
}
void
GrRenderTargetOpList
:
:
visitProxies_debugOnly
(
const
GrOp
:
:
VisitProxyFunc
&
func
)
const
{
for
(
const
RecordedOp
&
recordedOp
:
fRecordedOps
)
{
recordedOp
.
visitProxies
(
func
)
;
}
}
static
void
assert_chain_bounds
(
const
GrOp
*
op
)
{
SkASSERT
(
op
-
>
isChainHead
(
)
)
;
auto
headBounds
=
op
-
>
bounds
(
)
;
while
(
(
op
=
op
-
>
nextInChain
(
)
)
)
{
SkASSERT
(
headBounds
.
contains
(
op
-
>
bounds
(
)
)
)
;
}
}
#
endif
void
GrRenderTargetOpList
:
:
onPrepare
(
GrOpFlushState
*
flushState
)
{
SkASSERT
(
fTarget
.
get
(
)
-
>
peekRenderTarget
(
)
)
;
SkASSERT
(
this
-
>
isClosed
(
)
)
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
#
endif
for
(
int
i
=
0
;
i
<
fRecordedOps
.
count
(
)
;
+
+
i
)
{
if
(
fRecordedOps
[
i
]
.
fOp
&
&
fRecordedOps
[
i
]
.
fOp
-
>
isChainHead
(
)
)
{
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
"
fRecordedOps
[
i
]
.
fOp
-
>
name
(
)
)
;
#
endif
GrOpFlushState
:
:
OpArgs
opArgs
=
{
fRecordedOps
[
i
]
.
fOp
.
get
(
)
fTarget
.
get
(
)
-
>
asRenderTargetProxy
(
)
fRecordedOps
[
i
]
.
fAppliedClip
fRecordedOps
[
i
]
.
fDstProxy
}
;
SkDEBUGCODE
(
assert_chain_bounds
(
opArgs
.
fOp
)
)
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
fRecordedOps
[
i
]
.
fOp
-
>
prepare
(
flushState
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
}
}
static
GrGpuRTCommandBuffer
*
create_command_buffer
(
GrGpu
*
gpu
GrRenderTarget
*
rt
GrSurfaceOrigin
origin
GrLoadOp
colorLoadOp
GrColor
loadClearColor
GrLoadOp
stencilLoadOp
)
{
const
GrGpuRTCommandBuffer
:
:
LoadAndStoreInfo
kColorLoadStoreInfo
{
colorLoadOp
GrStoreOp
:
:
kStore
loadClearColor
}
;
const
GrGpuRTCommandBuffer
:
:
StencilLoadAndStoreInfo
stencilLoadAndStoreInfo
{
stencilLoadOp
GrStoreOp
:
:
kStore
}
;
return
gpu
-
>
getCommandBuffer
(
rt
origin
kColorLoadStoreInfo
stencilLoadAndStoreInfo
)
;
}
bool
GrRenderTargetOpList
:
:
onExecute
(
GrOpFlushState
*
flushState
)
{
if
(
0
=
=
fRecordedOps
.
count
(
)
&
&
GrLoadOp
:
:
kClear
!
=
fColorLoadOp
&
&
GrLoadOp
:
:
kDiscard
!
=
fColorLoadOp
)
{
return
false
;
}
SkASSERT
(
fTarget
.
get
(
)
-
>
peekRenderTarget
(
)
)
;
TRACE_EVENT0
(
"
skia
"
TRACE_FUNC
)
;
GrGpuRTCommandBuffer
*
commandBuffer
=
create_command_buffer
(
flushState
-
>
gpu
(
)
fTarget
.
get
(
)
-
>
peekRenderTarget
(
)
fTarget
.
get
(
)
-
>
origin
(
)
fColorLoadOp
fLoadClearColor
fStencilLoadOp
)
;
flushState
-
>
setCommandBuffer
(
commandBuffer
)
;
commandBuffer
-
>
begin
(
)
;
for
(
int
i
=
0
;
i
<
fRecordedOps
.
count
(
)
;
+
+
i
)
{
if
(
!
fRecordedOps
[
i
]
.
fOp
|
|
!
fRecordedOps
[
i
]
.
fOp
-
>
isChainHead
(
)
)
{
continue
;
}
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
TRACE_EVENT0
(
"
skia
"
fRecordedOps
[
i
]
.
fOp
-
>
name
(
)
)
;
#
endif
GrOpFlushState
:
:
OpArgs
opArgs
{
fRecordedOps
[
i
]
.
fOp
.
get
(
)
fTarget
.
get
(
)
-
>
asRenderTargetProxy
(
)
fRecordedOps
[
i
]
.
fAppliedClip
fRecordedOps
[
i
]
.
fDstProxy
}
;
flushState
-
>
setOpArgs
(
&
opArgs
)
;
fRecordedOps
[
i
]
.
fOp
-
>
execute
(
flushState
)
;
flushState
-
>
setOpArgs
(
nullptr
)
;
}
commandBuffer
-
>
end
(
)
;
flushState
-
>
gpu
(
)
-
>
submit
(
commandBuffer
)
;
flushState
-
>
setCommandBuffer
(
nullptr
)
;
return
true
;
}
void
GrRenderTargetOpList
:
:
endFlush
(
)
{
fLastClipStackGenID
=
SK_InvalidUniqueID
;
this
-
>
deleteOps
(
)
;
fClipAllocator
.
reset
(
)
;
INHERITED
:
:
endFlush
(
)
;
}
void
GrRenderTargetOpList
:
:
discard
(
)
{
if
(
this
-
>
isEmpty
(
)
)
{
fColorLoadOp
=
GrLoadOp
:
:
kDiscard
;
fStencilLoadOp
=
GrLoadOp
:
:
kDiscard
;
}
}
void
GrRenderTargetOpList
:
:
fullClear
(
GrContext
*
context
GrColor
color
)
{
if
(
this
-
>
isEmpty
(
)
|
|
!
fTarget
.
get
(
)
-
>
asRenderTargetProxy
(
)
-
>
needsStencil
(
)
)
{
this
-
>
deleteOps
(
)
;
fDeferredProxies
.
reset
(
)
;
fColorLoadOp
=
GrLoadOp
:
:
kClear
;
fLoadClearColor
=
color
;
return
;
}
std
:
:
unique_ptr
<
GrClearOp
>
op
(
GrClearOp
:
:
Make
(
context
GrFixedClip
:
:
Disabled
(
)
color
fTarget
.
get
(
)
)
)
;
if
(
!
op
)
{
return
;
}
this
-
>
recordOp
(
std
:
:
move
(
op
)
*
context
-
>
contextPriv
(
)
.
caps
(
)
)
;
}
bool
GrRenderTargetOpList
:
:
copySurface
(
GrContext
*
context
GrSurfaceProxy
*
dst
GrSurfaceProxy
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
SkASSERT
(
dst
-
>
asRenderTargetProxy
(
)
=
=
fTarget
.
get
(
)
)
;
std
:
:
unique_ptr
<
GrOp
>
op
=
GrCopySurfaceOp
:
:
Make
(
context
dst
src
srcRect
dstPoint
)
;
if
(
!
op
)
{
return
false
;
}
this
-
>
addOp
(
std
:
:
move
(
op
)
*
context
-
>
contextPriv
(
)
.
caps
(
)
)
;
return
true
;
}
void
GrRenderTargetOpList
:
:
purgeOpsWithUninstantiatedProxies
(
)
{
bool
hasUninstantiatedProxy
=
false
;
auto
checkInstantiation
=
[
&
hasUninstantiatedProxy
]
(
GrSurfaceProxy
*
p
)
{
if
(
!
p
-
>
isInstantiated
(
)
)
{
hasUninstantiatedProxy
=
true
;
}
}
;
for
(
RecordedOp
&
recordedOp
:
fRecordedOps
)
{
hasUninstantiatedProxy
=
false
;
if
(
recordedOp
.
fOp
)
{
recordedOp
.
visitProxies
(
checkInstantiation
)
;
}
if
(
hasUninstantiatedProxy
)
{
recordedOp
.
deleteOp
(
fOpMemoryPool
.
get
(
)
)
;
}
}
}
void
GrRenderTargetOpList
:
:
gatherProxyIntervals
(
GrResourceAllocator
*
alloc
)
const
{
unsigned
int
cur
=
alloc
-
>
numOps
(
)
;
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
fDeferredProxies
[
i
]
-
>
isInstantiated
(
)
)
;
alloc
-
>
addInterval
(
fDeferredProxies
[
i
]
0
0
)
;
}
if
(
fRecordedOps
.
count
(
)
)
{
alloc
-
>
addInterval
(
fTarget
.
get
(
)
cur
cur
+
fRecordedOps
.
count
(
)
-
1
)
;
}
else
{
alloc
-
>
addInterval
(
fTarget
.
get
(
)
)
;
alloc
-
>
incOps
(
)
;
}
auto
gather
=
[
alloc
SkDEBUGCODE
(
this
)
]
(
GrSurfaceProxy
*
p
)
{
alloc
-
>
addInterval
(
p
SkDEBUGCODE
(
fTarget
.
get
(
)
=
=
p
)
)
;
}
;
for
(
const
RecordedOp
&
recordedOp
:
fRecordedOps
)
{
recordedOp
.
visitProxies
(
gather
)
;
alloc
-
>
incOps
(
)
;
}
}
static
inline
bool
can_reorder
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
!
GrRectsOverlap
(
a
b
)
;
}
GrOp
:
:
CombineResult
GrRenderTargetOpList
:
:
combineIfPossible
(
const
RecordedOp
&
a
GrOp
*
b
const
GrAppliedClip
*
bClip
const
DstProxy
*
bDstProxy
const
GrCaps
&
caps
)
{
if
(
a
.
fAppliedClip
)
{
if
(
!
bClip
)
{
return
GrOp
:
:
CombineResult
:
:
kCannotCombine
;
}
if
(
*
a
.
fAppliedClip
!
=
*
bClip
)
{
return
GrOp
:
:
CombineResult
:
:
kCannotCombine
;
}
}
else
if
(
bClip
)
{
return
GrOp
:
:
CombineResult
:
:
kCannotCombine
;
}
if
(
bDstProxy
)
{
if
(
a
.
fDstProxy
!
=
*
bDstProxy
)
{
return
GrOp
:
:
CombineResult
:
:
kCannotCombine
;
}
}
else
if
(
a
.
fDstProxy
.
proxy
(
)
)
{
return
GrOp
:
:
CombineResult
:
:
kCannotCombine
;
}
return
a
.
fOp
-
>
combineIfPossible
(
b
caps
)
;
}
uint32_t
GrRenderTargetOpList
:
:
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
op
const
GrCaps
&
caps
GrAppliedClip
*
clip
const
DstProxy
*
dstProxy
)
{
SkASSERT
(
fTarget
.
get
(
)
)
;
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GR_AUDIT_TRAIL_ADD_OP
(
fAuditTrail
op
.
get
(
)
fTarget
.
get
(
)
-
>
uniqueID
(
)
)
;
GrOP_INFO
(
"
opList
:
%
d
Recording
(
%
s
opID
:
%
u
)
\
n
"
"
\
tBounds
[
L
:
%
.
2f
T
:
%
.
2f
R
:
%
.
2f
B
:
%
.
2f
]
\
n
"
this
-
>
uniqueID
(
)
op
-
>
name
(
)
op
-
>
uniqueID
(
)
op
-
>
bounds
(
)
.
fLeft
op
-
>
bounds
(
)
.
fTop
op
-
>
bounds
(
)
.
fRight
op
-
>
bounds
(
)
.
fBottom
)
;
GrOP_INFO
(
SkTabString
(
op
-
>
dumpInfo
(
)
1
)
.
c_str
(
)
)
;
GrOP_INFO
(
"
\
tOutcome
:
\
n
"
)
;
int
maxCandidates
=
SkTMin
(
kMaxOpLookback
fRecordedOps
.
count
(
)
)
;
if
(
maxCandidates
)
{
int
i
=
0
;
while
(
true
)
{
const
RecordedOp
&
candidate
=
fRecordedOps
.
fromBack
(
i
)
;
auto
combineResult
=
this
-
>
combineIfPossible
(
candidate
op
.
get
(
)
clip
dstProxy
caps
)
;
switch
(
combineResult
)
{
case
GrOp
:
:
CombineResult
:
:
kMayChain
:
break
;
case
GrOp
:
:
CombineResult
:
:
kMerged
:
GrOP_INFO
(
"
\
t
\
tBackward
:
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
candidate
.
fOp
-
>
name
(
)
candidate
.
fOp
-
>
uniqueID
(
)
)
;
GrOP_INFO
(
"
\
t
\
t
\
tBackward
:
Combined
op
info
:
\
n
"
)
;
GrOP_INFO
(
SkTabString
(
candidate
.
fOp
-
>
dumpInfo
(
)
4
)
.
c_str
(
)
)
;
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
fAuditTrail
candidate
.
fOp
.
get
(
)
op
.
get
(
)
)
;
fOpMemoryPool
-
>
release
(
std
:
:
move
(
op
)
)
;
return
SK_InvalidUniqueID
;
case
GrOp
:
:
CombineResult
:
:
kCannotCombine
:
break
;
}
if
(
!
can_reorder
(
candidate
.
fOp
-
>
bounds
(
)
op
-
>
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Intersects
with
(
%
s
opID
:
%
u
)
\
n
"
candidate
.
fOp
-
>
name
(
)
candidate
.
fOp
-
>
uniqueID
(
)
)
;
break
;
}
+
+
i
;
if
(
i
=
=
maxCandidates
)
{
GrOP_INFO
(
"
\
t
\
tBackward
:
Reached
max
lookback
or
beginning
of
op
array
%
d
\
n
"
i
)
;
break
;
}
}
}
else
{
GrOP_INFO
(
"
\
t
\
tBackward
:
FirstOp
\
n
"
)
;
}
GR_AUDIT_TRAIL_OP_RESULT_NEW
(
fAuditTrail
op
)
;
if
(
clip
)
{
clip
=
fClipAllocator
.
make
<
GrAppliedClip
>
(
std
:
:
move
(
*
clip
)
)
;
SkDEBUGCODE
(
fNumClips
+
+
;
)
}
fRecordedOps
.
emplace_back
(
std
:
:
move
(
op
)
clip
dstProxy
)
;
return
this
-
>
uniqueID
(
)
;
}
void
GrRenderTargetOpList
:
:
forwardCombine
(
const
GrCaps
&
caps
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrOP_INFO
(
"
opList
:
%
d
ForwardCombine
%
d
ops
:
\
n
"
this
-
>
uniqueID
(
)
fRecordedOps
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fRecordedOps
.
count
(
)
-
1
;
+
+
i
)
{
GrOp
*
op
=
fRecordedOps
[
i
]
.
fOp
.
get
(
)
;
int
maxCandidateIdx
=
SkTMin
(
i
+
kMaxOpLookahead
fRecordedOps
.
count
(
)
-
1
)
;
int
j
=
i
+
1
;
while
(
true
)
{
const
RecordedOp
&
candidate
=
fRecordedOps
[
j
]
;
auto
combineResult
=
this
-
>
combineIfPossible
(
fRecordedOps
[
i
]
candidate
.
fOp
.
get
(
)
candidate
.
fAppliedClip
&
candidate
.
fDstProxy
caps
)
;
switch
(
combineResult
)
{
case
GrOp
:
:
CombineResult
:
:
kMayChain
:
break
;
case
GrOp
:
:
CombineResult
:
:
kMerged
:
GrOP_INFO
(
"
\
t
\
t
%
d
:
(
%
s
opID
:
%
u
)
-
>
Combining
with
(
%
s
opID
:
%
u
)
\
n
"
i
op
-
>
name
(
)
op
-
>
uniqueID
(
)
candidate
.
fOp
-
>
name
(
)
candidate
.
fOp
-
>
uniqueID
(
)
)
;
GR_AUDIT_TRAIL_OPS_RESULT_COMBINED
(
fAuditTrail
op
candidate
.
fOp
.
get
(
)
)
;
fOpMemoryPool
-
>
release
(
std
:
:
move
(
fRecordedOps
[
j
]
.
fOp
)
)
;
fRecordedOps
[
j
]
.
fOp
=
std
:
:
move
(
fRecordedOps
[
i
]
.
fOp
)
;
break
;
case
GrOp
:
:
CombineResult
:
:
kCannotCombine
:
break
;
}
if
(
!
fRecordedOps
[
i
]
.
fOp
)
{
break
;
}
if
(
!
can_reorder
(
candidate
.
fOp
-
>
bounds
(
)
op
-
>
bounds
(
)
)
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
(
%
s
opID
:
%
u
)
-
>
Intersects
with
(
%
s
opID
:
%
u
)
\
n
"
i
op
-
>
name
(
)
op
-
>
uniqueID
(
)
candidate
.
fOp
-
>
name
(
)
candidate
.
fOp
-
>
uniqueID
(
)
)
;
break
;
}
if
(
+
+
j
>
maxCandidateIdx
)
{
GrOP_INFO
(
"
\
t
\
t
%
d
:
(
%
s
opID
:
%
u
)
-
>
Reached
max
lookahead
or
end
of
array
\
n
"
i
op
-
>
name
(
)
op
-
>
uniqueID
(
)
)
;
break
;
}
}
}
}
