#
ifndef
GrAADistanceFieldPathRenderer_DEFINED
#
define
GrAADistanceFieldPathRenderer_DEFINED
#
include
"
GrBatchAtlas
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
GrRect
.
h
"
#
include
"
SkChecksum
.
h
"
#
include
"
SkTDynamicHash
.
h
"
class
GrContext
;
class
GrAADistanceFieldPathRenderer
:
public
GrPathRenderer
{
public
:
GrAADistanceFieldPathRenderer
(
)
;
virtual
~
GrAADistanceFieldPathRenderer
(
)
;
private
:
StencilSupport
onGetStencilSupport
(
const
SkPath
&
const
GrStrokeInfo
&
)
const
override
{
return
GrPathRenderer
:
:
kNoSupport_StencilSupport
;
}
bool
onCanDrawPath
(
const
CanDrawPathArgs
&
)
const
override
;
bool
onDrawPath
(
const
DrawPathArgs
&
)
override
;
struct
PathData
{
class
Key
{
public
:
Key
(
)
:
fGenID
(
0
)
fDimension
(
0
)
fStroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
{
}
Key
(
uint32_t
genID
uint32_t
dim
const
SkStrokeRec
&
stroke
)
:
fGenID
(
genID
)
fDimension
(
dim
)
fStroke
(
stroke
)
{
}
bool
operator
=
=
(
const
Key
&
other
)
const
{
return
other
.
fGenID
=
=
fGenID
&
&
other
.
fDimension
=
=
fDimension
&
&
fStroke
.
hasEqualEffect
(
other
.
fStroke
)
;
}
private
:
uint32_t
fGenID
;
uint32_t
fDimension
;
SkStrokeRec
fStroke
;
}
;
Key
fKey
;
SkScalar
fScale
;
GrBatchAtlas
:
:
AtlasID
fID
;
SkRect
fBounds
;
SkIPoint16
fAtlasLocation
;
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
PathData
)
;
static
inline
const
Key
&
GetKey
(
const
PathData
&
data
)
{
return
data
.
fKey
;
}
static
inline
uint32_t
Hash
(
Key
key
)
{
return
SkChecksum
:
:
Murmur3
(
reinterpret_cast
<
const
uint32_t
*
>
(
&
key
)
sizeof
(
key
)
)
;
}
}
;
static
void
HandleEviction
(
GrBatchAtlas
:
:
AtlasID
void
*
)
;
typedef
SkTDynamicHash
<
PathData
PathData
:
:
Key
>
PathCache
;
typedef
SkTInternalLList
<
PathData
>
PathDataList
;
GrBatchAtlas
*
fAtlas
;
PathCache
fPathCache
;
PathDataList
fPathList
;
typedef
GrPathRenderer
INHERITED
;
friend
class
AADistanceFieldPathBatch
;
friend
struct
PathTestStruct
;
}
;
#
endif
