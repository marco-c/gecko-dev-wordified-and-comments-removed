#
ifndef
GrBatch_DEFINED
#
define
GrBatch_DEFINED
#
include
<
new
>
#
include
"
GrNonAtomicRef
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkString
.
h
"
class
GrCaps
;
class
GrBatchFlushState
;
class
GrRenderTarget
;
#
define
GR_BATCH_SPEW
0
#
if
GR_BATCH_SPEW
#
define
GrBATCH_INFO
(
.
.
.
)
SkDebugf
(
__VA_ARGS__
)
#
define
GrBATCH_SPEW
(
code
)
code
#
else
#
define
GrBATCH_SPEW
(
code
)
#
define
GrBATCH_INFO
(
.
.
.
)
#
endif
#
define
DEFINE_BATCH_CLASS_ID
\
static
uint32_t
ClassID
(
)
{
\
static
uint32_t
kClassID
=
GenBatchClassID
(
)
;
\
return
kClassID
;
\
}
class
GrBatch
:
public
GrNonAtomicRef
<
GrBatch
>
{
public
:
GrBatch
(
uint32_t
classID
)
;
virtual
~
GrBatch
(
)
;
virtual
const
char
*
name
(
)
const
=
0
;
bool
combineIfPossible
(
GrBatch
*
that
const
GrCaps
&
caps
)
{
if
(
this
-
>
classID
(
)
!
=
that
-
>
classID
(
)
)
{
return
false
;
}
return
this
-
>
onCombineIfPossible
(
that
caps
)
;
}
const
SkRect
&
bounds
(
)
const
{
return
fBounds
;
}
void
*
operator
new
(
size_t
size
)
;
void
operator
delete
(
void
*
target
)
;
void
*
operator
new
(
size_t
size
void
*
placement
)
{
return
:
:
operator
new
(
size
placement
)
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
template
<
typename
T
>
const
T
&
cast
(
)
const
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
template
<
typename
T
>
T
*
cast
(
)
{
SkASSERT
(
T
:
:
ClassID
(
)
=
=
this
-
>
classID
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
uint32_t
classID
(
)
const
{
SkASSERT
(
kIllegalBatchID
!
=
fClassID
)
;
return
fClassID
;
}
uint32_t
uniqueID
(
)
const
{
if
(
kIllegalBatchID
=
=
fUniqueID
)
{
fUniqueID
=
GenBatchID
(
)
;
}
return
fUniqueID
;
}
SkDEBUGCODE
(
bool
isUsed
(
)
const
{
return
fUsed
;
}
)
void
prepare
(
GrBatchFlushState
*
state
)
{
this
-
>
onPrepare
(
state
)
;
}
void
draw
(
GrBatchFlushState
*
state
)
{
this
-
>
onDraw
(
state
)
;
}
virtual
uint32_t
renderTargetUniqueID
(
)
const
=
0
;
virtual
SkString
dumpInfo
(
)
const
=
0
;
virtual
GrRenderTarget
*
renderTarget
(
)
const
=
0
;
protected
:
void
setBounds
(
const
SkRect
&
newBounds
)
{
fBounds
=
newBounds
;
}
void
joinBounds
(
const
SkRect
&
otherBounds
)
{
return
fBounds
.
joinPossiblyEmptyRect
(
otherBounds
)
;
}
static
uint32_t
GenBatchClassID
(
)
{
return
GenID
(
&
gCurrBatchClassID
)
;
}
SkRect
fBounds
;
private
:
virtual
bool
onCombineIfPossible
(
GrBatch
*
const
GrCaps
&
caps
)
=
0
;
virtual
void
onPrepare
(
GrBatchFlushState
*
)
=
0
;
virtual
void
onDraw
(
GrBatchFlushState
*
)
=
0
;
static
uint32_t
GenID
(
int32_t
*
idCounter
)
{
uint32_t
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
idCounter
)
)
+
1
;
if
(
!
id
)
{
SkFAIL
(
"
This
should
never
wrap
as
it
should
only
be
called
once
for
each
GrBatch
"
"
subclass
.
"
)
;
}
return
id
;
}
enum
{
kIllegalBatchID
=
0
}
;
SkDEBUGCODE
(
bool
fUsed
;
)
const
uint32_t
fClassID
;
static
uint32_t
GenBatchID
(
)
{
return
GenID
(
&
gCurrBatchUniqueID
)
;
}
mutable
uint32_t
fUniqueID
;
static
int32_t
gCurrBatchUniqueID
;
static
int32_t
gCurrBatchClassID
;
}
;
#
endif
