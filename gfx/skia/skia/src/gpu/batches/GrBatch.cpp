#
include
"
GrBatch
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
SkSpinlock
.
h
"
namespace
{
static
SkSpinlock
gBatchSpinlock
;
class
MemoryPoolAccessor
{
public
:
#
if
defined
(
SK_BUILD_FOR_ANDROID_FRAMEWORK
)
MemoryPoolAccessor
(
)
{
}
~
MemoryPoolAccessor
(
)
{
}
#
else
MemoryPoolAccessor
(
)
{
gBatchSpinlock
.
acquire
(
)
;
}
~
MemoryPoolAccessor
(
)
{
gBatchSpinlock
.
release
(
)
;
}
#
endif
GrMemoryPool
*
pool
(
)
const
{
static
GrMemoryPool
gPool
(
16384
16384
)
;
return
&
gPool
;
}
}
;
}
int32_t
GrBatch
:
:
gCurrBatchClassID
=
GrBatch
:
:
kIllegalBatchID
;
int32_t
GrBatch
:
:
gCurrBatchUniqueID
=
GrBatch
:
:
kIllegalBatchID
;
void
*
GrBatch
:
:
operator
new
(
size_t
size
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
allocate
(
size
)
;
}
void
GrBatch
:
:
operator
delete
(
void
*
target
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
release
(
target
)
;
}
GrBatch
:
:
GrBatch
(
uint32_t
classID
)
:
fClassID
(
classID
)
fUniqueID
(
kIllegalBatchID
)
{
SkASSERT
(
classID
=
=
SkToU32
(
fClassID
)
)
;
SkDEBUGCODE
(
fUsed
=
false
;
)
SkDEBUGCODE
(
fBoundsFlags
=
kUninitialized_BoundsFlag
)
;
}
GrBatch
:
:
~
GrBatch
(
)
{
}
