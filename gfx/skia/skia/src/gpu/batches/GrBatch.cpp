#
include
"
GrBatch
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
SkSpinlock
.
h
"
namespace
{
SK_DECLARE_STATIC_SPINLOCK
(
gBatchSpinlock
)
;
class
MemoryPoolAccessor
{
public
:
MemoryPoolAccessor
(
)
{
gBatchSpinlock
.
acquire
(
)
;
}
~
MemoryPoolAccessor
(
)
{
gBatchSpinlock
.
release
(
)
;
}
GrMemoryPool
*
pool
(
)
const
{
static
GrMemoryPool
gPool
(
16384
16384
)
;
return
&
gPool
;
}
}
;
}
int32_t
GrBatch
:
:
gCurrBatchClassID
=
GrBatch
:
:
kIllegalBatchID
;
GrBATCH_SPEW
(
int32_t
GrBatch
:
:
gCurrBatchUniqueID
=
GrBatch
:
:
kIllegalBatchID
;
)
void
*
GrBatch
:
:
operator
new
(
size_t
size
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
allocate
(
size
)
;
}
void
GrBatch
:
:
operator
delete
(
void
*
target
)
{
return
MemoryPoolAccessor
(
)
.
pool
(
)
-
>
release
(
target
)
;
}
GrBatch
:
:
GrBatch
(
uint32_t
classID
)
:
fClassID
(
classID
)
#
if
GR_BATCH_SPEW
fUniqueID
(
GenBatchID
(
)
)
#
endif
{
SkDEBUGCODE
(
fUsed
=
false
;
)
}
GrBatch
:
:
~
GrBatch
(
)
{
}
