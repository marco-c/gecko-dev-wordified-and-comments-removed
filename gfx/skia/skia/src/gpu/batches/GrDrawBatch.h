#
ifndef
GrDrawBatch_DEFINED
#
define
GrDrawBatch_DEFINED
#
include
<
functional
>
#
include
"
GrBatch
.
h
"
#
include
"
GrPipeline
.
h
"
struct
GrInitInvariantOutput
;
class
GrBatchDrawToken
{
public
:
static
GrBatchDrawToken
AlreadyFlushedToken
(
)
{
return
GrBatchDrawToken
(
0
)
;
}
GrBatchDrawToken
(
const
GrBatchDrawToken
&
that
)
:
fSequenceNumber
(
that
.
fSequenceNumber
)
{
}
GrBatchDrawToken
&
operator
=
(
const
GrBatchDrawToken
&
that
)
{
fSequenceNumber
=
that
.
fSequenceNumber
;
return
*
this
;
}
bool
operator
=
=
(
const
GrBatchDrawToken
&
that
)
const
{
return
fSequenceNumber
=
=
that
.
fSequenceNumber
;
}
bool
operator
!
=
(
const
GrBatchDrawToken
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
private
:
GrBatchDrawToken
(
)
;
explicit
GrBatchDrawToken
(
uint64_t
sequenceNumber
)
:
fSequenceNumber
(
sequenceNumber
)
{
}
friend
class
GrBatchFlushState
;
uint64_t
fSequenceNumber
;
}
;
class
GrDrawBatch
:
public
GrBatch
{
public
:
using
WritePixelsFn
=
std
:
:
function
<
bool
(
GrSurface
*
texture
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
void
*
buffer
size_t
rowBytes
)
>
;
using
DeferredUploadFn
=
std
:
:
function
<
void
(
WritePixelsFn
&
)
>
;
class
Target
;
GrDrawBatch
(
uint32_t
classID
)
;
~
GrDrawBatch
(
)
override
;
void
getPipelineOptimizations
(
GrPipelineOptimizations
*
override
)
const
;
const
GrPipeline
*
pipeline
(
)
const
{
SkASSERT
(
fPipelineInstalled
)
;
return
reinterpret_cast
<
const
GrPipeline
*
>
(
fPipelineStorage
.
get
(
)
)
;
}
bool
installPipeline
(
const
GrPipeline
:
:
CreateArgs
&
)
;
bool
willReadFragmentPosition
(
)
const
{
return
false
;
}
uint32_t
renderTargetUniqueID
(
)
const
final
{
SkASSERT
(
fPipelineInstalled
)
;
return
this
-
>
pipeline
(
)
-
>
getRenderTarget
(
)
-
>
getUniqueID
(
)
;
}
GrRenderTarget
*
renderTarget
(
)
const
final
{
SkASSERT
(
fPipelineInstalled
)
;
return
this
-
>
pipeline
(
)
-
>
getRenderTarget
(
)
;
}
SkString
dumpInfo
(
)
const
override
{
SkString
string
;
string
.
appendf
(
"
RT
:
%
d
\
n
"
this
-
>
renderTargetUniqueID
(
)
)
;
string
.
append
(
"
ColorStages
:
\
n
"
)
;
for
(
int
i
=
0
;
i
<
this
-
>
pipeline
(
)
-
>
numColorFragmentProcessors
(
)
;
i
+
+
)
{
string
.
appendf
(
"
\
t
\
t
%
s
\
n
\
t
\
t
%
s
\
n
"
this
-
>
pipeline
(
)
-
>
getColorFragmentProcessor
(
i
)
.
name
(
)
this
-
>
pipeline
(
)
-
>
getColorFragmentProcessor
(
i
)
.
dumpInfo
(
)
.
c_str
(
)
)
;
}
string
.
append
(
"
CoverageStages
:
\
n
"
)
;
for
(
int
i
=
0
;
i
<
this
-
>
pipeline
(
)
-
>
numCoverageFragmentProcessors
(
)
;
i
+
+
)
{
string
.
appendf
(
"
\
t
\
t
%
s
\
n
\
t
\
t
%
s
\
n
"
this
-
>
pipeline
(
)
-
>
getCoverageFragmentProcessor
(
i
)
.
name
(
)
this
-
>
pipeline
(
)
-
>
getCoverageFragmentProcessor
(
i
)
.
dumpInfo
(
)
.
c_str
(
)
)
;
}
string
.
appendf
(
"
XP
:
%
s
\
n
"
this
-
>
pipeline
(
)
-
>
getXferProcessor
(
)
.
name
(
)
)
;
return
string
;
}
protected
:
virtual
void
computePipelineOptimizations
(
GrInitInvariantOutput
*
color
GrInitInvariantOutput
*
coverage
GrBatchToXPOverrides
*
overrides
)
const
=
0
;
private
:
virtual
void
initBatchTracker
(
const
GrXPOverridesForBatch
&
)
=
0
;
protected
:
struct
QueuedUpload
{
QueuedUpload
(
DeferredUploadFn
&
&
upload
GrBatchDrawToken
token
)
:
fUpload
(
std
:
:
move
(
upload
)
)
fUploadBeforeToken
(
token
)
{
}
DeferredUploadFn
fUpload
;
GrBatchDrawToken
fUploadBeforeToken
;
}
;
SkTArray
<
QueuedUpload
>
fInlineUploads
;
private
:
SkAlignedSTStorage
<
1
GrPipeline
>
fPipelineStorage
;
bool
fPipelineInstalled
;
typedef
GrBatch
INHERITED
;
}
;
#
endif
