#
ifndef
GrAAConvexTessellator_DEFINED
#
define
GrAAConvexTessellator_DEFINED
#
include
"
SkColor
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkScalar
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTDArray
.
h
"
class
SkCanvas
;
class
SkMatrix
;
class
SkPath
;
static
const
SkScalar
kAntialiasingRadius
=
0
.
5f
;
class
GrAAConvexTessellator
;
class
GrAAConvexTessellator
{
public
:
GrAAConvexTessellator
(
SkStrokeRec
:
:
Style
style
=
SkStrokeRec
:
:
kFill_Style
SkScalar
strokeWidth
=
-
1
.
0f
SkPaint
:
:
Join
join
=
SkPaint
:
:
Join
:
:
kBevel_Join
SkScalar
miterLimit
=
0
.
0f
)
:
fSide
(
SkPoint
:
:
kOn_Side
)
fStrokeWidth
(
strokeWidth
)
fStyle
(
style
)
fJoin
(
join
)
fMiterLimit
(
miterLimit
)
{
}
SkPoint
:
:
Side
side
(
)
const
{
return
fSide
;
}
bool
tessellate
(
const
SkMatrix
&
m
const
SkPath
&
path
)
;
int
numPts
(
)
const
{
return
fPts
.
count
(
)
;
}
int
numIndices
(
)
const
{
return
fIndices
.
count
(
)
;
}
const
SkPoint
&
lastPoint
(
)
const
{
return
fPts
.
top
(
)
;
}
const
SkPoint
&
point
(
int
index
)
const
{
return
fPts
[
index
]
;
}
int
index
(
int
index
)
const
{
return
fIndices
[
index
]
;
}
SkScalar
coverage
(
int
index
)
const
{
return
fCoverages
[
index
]
;
}
#
if
GR_AA_CONVEX_TESSELLATOR_VIZ
void
draw
(
SkCanvas
*
canvas
)
const
;
#
endif
void
rewind
(
)
;
private
:
class
CandidateVerts
{
public
:
void
setReserve
(
int
numPts
)
{
fPts
.
setReserve
(
numPts
)
;
}
void
rewind
(
)
{
fPts
.
rewind
(
)
;
}
int
numPts
(
)
const
{
return
fPts
.
count
(
)
;
}
const
SkPoint
&
lastPoint
(
)
const
{
return
fPts
.
top
(
)
.
fPt
;
}
const
SkPoint
&
firstPoint
(
)
const
{
return
fPts
[
0
]
.
fPt
;
}
const
SkPoint
&
point
(
int
index
)
const
{
return
fPts
[
index
]
.
fPt
;
}
int
originatingIdx
(
int
index
)
const
{
return
fPts
[
index
]
.
fOriginatingIdx
;
}
int
origEdge
(
int
index
)
const
{
return
fPts
[
index
]
.
fOrigEdgeId
;
}
bool
needsToBeNew
(
int
index
)
const
{
return
fPts
[
index
]
.
fNeedsToBeNew
;
}
int
addNewPt
(
const
SkPoint
&
newPt
int
originatingIdx
int
origEdge
bool
needsToBeNew
)
{
struct
PointData
*
pt
=
fPts
.
push
(
)
;
pt
-
>
fPt
=
newPt
;
pt
-
>
fOrigEdgeId
=
origEdge
;
pt
-
>
fOriginatingIdx
=
originatingIdx
;
pt
-
>
fNeedsToBeNew
=
needsToBeNew
;
return
fPts
.
count
(
)
-
1
;
}
int
fuseWithPrior
(
int
origEdgeId
)
{
fPts
.
top
(
)
.
fOrigEdgeId
=
origEdgeId
;
fPts
.
top
(
)
.
fOriginatingIdx
=
-
1
;
fPts
.
top
(
)
.
fNeedsToBeNew
=
true
;
return
fPts
.
count
(
)
-
1
;
}
int
fuseWithNext
(
)
{
fPts
[
0
]
.
fOriginatingIdx
=
-
1
;
fPts
[
0
]
.
fNeedsToBeNew
=
true
;
return
0
;
}
int
fuseWithBoth
(
)
{
if
(
fPts
.
count
(
)
>
1
)
{
fPts
.
pop
(
)
;
}
fPts
[
0
]
.
fOriginatingIdx
=
-
1
;
fPts
[
0
]
.
fNeedsToBeNew
=
true
;
return
0
;
}
private
:
struct
PointData
{
SkPoint
fPt
;
int
fOriginatingIdx
;
int
fOrigEdgeId
;
bool
fNeedsToBeNew
;
}
;
SkTDArray
<
struct
PointData
>
fPts
;
}
;
class
Ring
{
public
:
void
setReserve
(
int
numPts
)
{
fPts
.
setReserve
(
numPts
)
;
}
void
rewind
(
)
{
fPts
.
rewind
(
)
;
}
int
numPts
(
)
const
{
return
fPts
.
count
(
)
;
}
void
addIdx
(
int
index
int
origEdgeId
)
{
struct
PointData
*
pt
=
fPts
.
push
(
)
;
pt
-
>
fIndex
=
index
;
pt
-
>
fOrigEdgeId
=
origEdgeId
;
}
void
makeOriginalRing
(
)
{
for
(
int
i
=
0
;
i
<
fPts
.
count
(
)
;
+
+
i
)
{
fPts
[
i
]
.
fOrigEdgeId
=
fPts
[
i
]
.
fIndex
;
}
}
void
init
(
const
GrAAConvexTessellator
&
tess
)
;
void
init
(
const
SkTDArray
<
SkVector
>
&
norms
const
SkTDArray
<
SkVector
>
&
bisectors
)
;
const
SkPoint
&
norm
(
int
index
)
const
{
return
fPts
[
index
]
.
fNorm
;
}
const
SkPoint
&
bisector
(
int
index
)
const
{
return
fPts
[
index
]
.
fBisector
;
}
int
index
(
int
index
)
const
{
return
fPts
[
index
]
.
fIndex
;
}
int
origEdgeID
(
int
index
)
const
{
return
fPts
[
index
]
.
fOrigEdgeId
;
}
void
setOrigEdgeId
(
int
index
int
id
)
{
fPts
[
index
]
.
fOrigEdgeId
=
id
;
}
#
if
GR_AA_CONVEX_TESSELLATOR_VIZ
void
draw
(
SkCanvas
*
canvas
const
GrAAConvexTessellator
&
tess
)
const
;
#
endif
private
:
void
computeNormals
(
const
GrAAConvexTessellator
&
result
)
;
void
computeBisectors
(
const
GrAAConvexTessellator
&
tess
)
;
SkDEBUGCODE
(
bool
isConvex
(
const
GrAAConvexTessellator
&
tess
)
const
;
)
struct
PointData
{
SkPoint
fNorm
;
SkPoint
fBisector
;
int
fIndex
;
int
fOrigEdgeId
;
}
;
SkTDArray
<
PointData
>
fPts
;
}
;
enum
CurveState
{
kSharp_CurveState
kIndeterminate_CurveState
kCurve_CurveState
}
;
bool
movable
(
int
index
)
const
{
return
fMovable
[
index
]
;
}
int
addPt
(
const
SkPoint
&
pt
SkScalar
depth
SkScalar
coverage
bool
movable
CurveState
curve
)
;
void
popLastPt
(
)
;
void
popFirstPtShuffle
(
)
;
void
updatePt
(
int
index
const
SkPoint
&
pt
SkScalar
depth
SkScalar
coverage
)
;
void
addTri
(
int
i0
int
i1
int
i2
)
;
void
reservePts
(
int
count
)
{
fPts
.
setReserve
(
count
)
;
fCoverages
.
setReserve
(
count
)
;
fMovable
.
setReserve
(
count
)
;
}
SkScalar
computeDepthFromEdge
(
int
edgeIdx
const
SkPoint
&
p
)
const
;
bool
computePtAlongBisector
(
int
startIdx
const
SkPoint
&
bisector
int
edgeIdx
SkScalar
desiredDepth
SkPoint
*
result
)
const
;
void
lineTo
(
const
SkPoint
&
p
CurveState
curve
)
;
void
lineTo
(
const
SkMatrix
&
m
SkPoint
p
CurveState
curve
)
;
void
quadTo
(
const
SkPoint
pts
[
3
]
)
;
void
quadTo
(
const
SkMatrix
&
m
SkPoint
pts
[
3
]
)
;
void
cubicTo
(
const
SkMatrix
&
m
SkPoint
pts
[
4
]
)
;
void
conicTo
(
const
SkMatrix
&
m
SkPoint
pts
[
3
]
SkScalar
w
)
;
void
terminate
(
const
Ring
&
lastRing
)
;
bool
extractFromPath
(
const
SkMatrix
&
m
const
SkPath
&
path
)
;
void
computeBisectors
(
)
;
void
fanRing
(
const
Ring
&
ring
)
;
Ring
*
getNextRing
(
Ring
*
lastRing
)
;
void
createOuterRing
(
const
Ring
&
previousRing
SkScalar
outset
SkScalar
coverage
Ring
*
nextRing
)
;
bool
createInsetRings
(
Ring
&
previousRing
SkScalar
initialDepth
SkScalar
initialCoverage
SkScalar
targetDepth
SkScalar
targetCoverage
Ring
*
*
finalRing
)
;
bool
createInsetRing
(
const
Ring
&
lastRing
Ring
*
nextRing
SkScalar
initialDepth
SkScalar
initialCoverage
SkScalar
targetDepth
SkScalar
targetCoverage
bool
forceNew
)
;
void
validate
(
)
const
;
SkTDArray
<
SkPoint
>
fPts
;
SkTDArray
<
SkScalar
>
fCoverages
;
SkTDArray
<
bool
>
fMovable
;
SkTDArray
<
CurveState
>
fCurveState
;
SkTDArray
<
SkVector
>
fNorms
;
SkTDArray
<
SkVector
>
fBisectors
;
SkPoint
:
:
Side
fSide
;
SkTDArray
<
int
>
fIndices
;
Ring
fInitialRing
;
#
if
GR_AA_CONVEX_TESSELLATOR_VIZ
SkTDArray
<
Ring
*
>
fRings
;
#
else
Ring
fRings
[
2
]
;
#
endif
CandidateVerts
fCandidateVerts
;
SkScalar
fStrokeWidth
;
SkStrokeRec
:
:
Style
fStyle
;
SkPaint
:
:
Join
fJoin
;
SkScalar
fMiterLimit
;
SkTDArray
<
SkPoint
>
fPointBuffer
;
}
;
#
endif
