#
include
"
GrBlurUtils
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrRenderTargetContextPriv
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
GrSoftwarePathRenderer
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkTLazy
.
h
"
static
bool
clip_bounds_quick_reject
(
const
SkIRect
&
clipBounds
const
SkIRect
&
rect
)
{
return
clipBounds
.
isEmpty
(
)
|
|
rect
.
isEmpty
(
)
|
|
!
SkIRect
:
:
Intersects
(
clipBounds
rect
)
;
}
static
bool
draw_mask
(
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
maskRect
GrPaint
&
&
paint
sk_sp
<
GrTextureProxy
>
mask
)
{
SkMatrix
inverse
;
if
(
!
viewMatrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
SkMatrix
matrix
=
SkMatrix
:
:
MakeTrans
(
-
SkIntToScalar
(
maskRect
.
fLeft
)
-
SkIntToScalar
(
maskRect
.
fTop
)
)
;
matrix
.
preConcat
(
viewMatrix
)
;
paint
.
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
std
:
:
move
(
mask
)
matrix
)
)
;
renderTargetContext
-
>
fillRectWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
maskRect
)
inverse
)
;
return
true
;
}
static
void
mask_release_proc
(
void
*
addr
void
*
)
{
SkMask
:
:
FreeImage
(
addr
)
;
}
static
bool
sw_draw_with_mask_filter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clipData
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
const
SkMaskFilter
*
filter
const
SkIRect
&
clipBounds
GrPaint
&
&
paint
const
GrUniqueKey
&
key
)
{
SkASSERT
(
filter
)
;
SkASSERT
(
!
shape
.
style
(
)
.
applies
(
)
)
;
auto
proxyProvider
=
context
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
sk_sp
<
GrTextureProxy
>
filteredMask
;
SkStrokeRec
:
:
InitStyle
fillOrHairline
=
shape
.
style
(
)
.
isSimpleHairline
(
)
?
SkStrokeRec
:
:
kHairline_InitStyle
:
SkStrokeRec
:
:
kFill_InitStyle
;
if
(
key
.
isValid
(
)
)
{
filteredMask
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
key
kTopLeft_GrSurfaceOrigin
)
;
}
SkIRect
drawRect
;
if
(
filteredMask
)
{
SkRect
devBounds
=
shape
.
bounds
(
)
;
viewMatrix
.
mapRect
(
&
devBounds
)
;
SkMask
srcM
dstM
;
if
(
!
SkDraw
:
:
ComputeMaskBounds
(
devBounds
&
clipBounds
filter
&
viewMatrix
&
srcM
.
fBounds
)
)
{
return
false
;
}
srcM
.
fFormat
=
SkMask
:
:
kA8_Format
;
if
(
!
as_MFB
(
filter
)
-
>
filterMask
(
&
dstM
srcM
viewMatrix
nullptr
)
)
{
return
false
;
}
drawRect
=
dstM
.
fBounds
;
}
else
{
SkPath
devPath
;
shape
.
asPath
(
&
devPath
)
;
devPath
.
transform
(
viewMatrix
)
;
SkMask
srcM
dstM
;
if
(
!
SkDraw
:
:
DrawToMask
(
devPath
&
clipBounds
filter
&
viewMatrix
&
srcM
SkMask
:
:
kComputeBoundsAndRenderImage_CreateMode
fillOrHairline
)
)
{
return
false
;
}
SkAutoMaskFreeImage
autoSrc
(
srcM
.
fImage
)
;
SkASSERT
(
SkMask
:
:
kA8_Format
=
=
srcM
.
fFormat
)
;
if
(
!
as_MFB
(
filter
)
-
>
filterMask
(
&
dstM
srcM
viewMatrix
nullptr
)
)
{
return
false
;
}
SkAutoMaskFreeImage
autoDst
(
dstM
.
fImage
)
;
if
(
clip_bounds_quick_reject
(
clipBounds
dstM
.
fBounds
)
)
{
return
false
;
}
SkBitmap
bm
;
if
(
!
bm
.
installPixels
(
SkImageInfo
:
:
MakeA8
(
dstM
.
fBounds
.
width
(
)
dstM
.
fBounds
.
height
(
)
)
autoDst
.
release
(
)
dstM
.
fRowBytes
mask_release_proc
nullptr
)
)
{
return
false
;
}
bm
.
setImmutable
(
)
;
sk_sp
<
SkImage
>
image
=
SkImage
:
:
MakeFromBitmap
(
bm
)
;
if
(
!
image
)
{
return
false
;
}
filteredMask
=
proxyProvider
-
>
createTextureProxy
(
std
:
:
move
(
image
)
kNone_GrSurfaceFlags
1
SkBudgeted
:
:
kYes
SkBackingFit
:
:
kApprox
)
;
if
(
!
filteredMask
)
{
return
false
;
}
SkASSERT
(
kTopLeft_GrSurfaceOrigin
=
=
filteredMask
-
>
origin
(
)
)
;
drawRect
=
dstM
.
fBounds
;
if
(
key
.
isValid
(
)
)
{
proxyProvider
-
>
assignUniqueKeyToProxy
(
key
filteredMask
.
get
(
)
)
;
}
}
return
draw_mask
(
renderTargetContext
clipData
viewMatrix
drawRect
std
:
:
move
(
paint
)
std
:
:
move
(
filteredMask
)
)
;
}
static
sk_sp
<
GrTextureProxy
>
create_mask_GPU
(
GrContext
*
context
const
SkIRect
&
maskRect
const
SkMatrix
&
origViewMatrix
const
GrShape
&
shape
int
sampleCnt
)
{
sk_sp
<
GrRenderTargetContext
>
rtContext
(
context
-
>
contextPriv
(
)
.
makeDeferredRenderTargetContextWithFallback
(
SkBackingFit
:
:
kApprox
maskRect
.
width
(
)
maskRect
.
height
(
)
kAlpha_8_GrPixelConfig
nullptr
sampleCnt
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
)
;
if
(
!
rtContext
)
{
return
nullptr
;
}
rtContext
-
>
priv
(
)
.
absClear
(
nullptr
0x0
)
;
GrPaint
maskPaint
;
maskPaint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kReplace_Op
)
;
const
SkIRect
clipRect
=
SkIRect
:
:
MakeWH
(
maskRect
.
width
(
)
maskRect
.
height
(
)
)
;
GrFixedClip
clip
(
clipRect
)
;
SkMatrix
viewMatrix
=
origViewMatrix
;
viewMatrix
.
postTranslate
(
-
SkIntToScalar
(
maskRect
.
fLeft
)
-
SkIntToScalar
(
maskRect
.
fTop
)
)
;
rtContext
-
>
drawShape
(
clip
std
:
:
move
(
maskPaint
)
GrAA
:
:
kYes
viewMatrix
shape
)
;
return
rtContext
-
>
asTextureProxyRef
(
)
;
}
static
bool
get_unclipped_shape_dev_bounds
(
const
GrShape
&
shape
const
SkMatrix
&
matrix
SkIRect
*
devBounds
)
{
SkRect
shapeBounds
=
shape
.
styledBounds
(
)
;
if
(
shapeBounds
.
isEmpty
(
)
)
{
return
false
;
}
SkRect
shapeDevBounds
;
matrix
.
mapRect
(
&
shapeDevBounds
shapeBounds
)
;
static
constexpr
int32_t
kMaxInt
=
2147483520
;
if
(
!
shapeDevBounds
.
intersect
(
SkRect
:
:
MakeLTRB
(
INT32_MIN
INT32_MIN
kMaxInt
kMaxInt
)
)
)
{
return
false
;
}
if
(
SkScalarRoundToInt
(
shapeDevBounds
.
width
(
)
)
>
kMaxInt
|
|
SkScalarRoundToInt
(
shapeDevBounds
.
height
(
)
)
>
kMaxInt
)
{
return
false
;
}
shapeDevBounds
.
roundOut
(
devBounds
)
;
return
true
;
}
static
bool
get_shape_and_clip_bounds
(
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
GrShape
&
shape
const
SkMatrix
&
matrix
SkIRect
*
unclippedDevShapeBounds
SkIRect
*
devClipBounds
)
{
clip
.
getConservativeBounds
(
renderTargetContext
-
>
width
(
)
renderTargetContext
-
>
height
(
)
devClipBounds
)
;
if
(
!
get_unclipped_shape_dev_bounds
(
shape
matrix
unclippedDevShapeBounds
)
)
{
*
unclippedDevShapeBounds
=
SkIRect
:
:
EmptyIRect
(
)
;
return
false
;
}
return
true
;
}
static
void
draw_shape_with_mask_filter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
SkMaskFilterBase
*
maskFilter
const
GrShape
&
origShape
)
{
SkASSERT
(
maskFilter
)
;
const
GrShape
*
shape
=
&
origShape
;
SkTLazy
<
GrShape
>
tmpShape
;
if
(
origShape
.
style
(
)
.
applies
(
)
)
{
SkScalar
styleScale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
0
=
=
styleScale
)
{
return
;
}
tmpShape
.
init
(
origShape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
styleScale
)
)
;
if
(
tmpShape
.
get
(
)
-
>
isEmpty
(
)
)
{
return
;
}
shape
=
tmpShape
.
get
(
)
;
}
if
(
maskFilter
-
>
directFilterMaskGPU
(
context
renderTargetContext
std
:
:
move
(
paint
)
clip
viewMatrix
*
shape
)
)
{
return
;
}
bool
inverseFilled
=
shape
-
>
inverseFilled
(
)
&
&
!
GrPathRenderer
:
:
IsStrokeHairlineOrEquivalent
(
shape
-
>
style
(
)
viewMatrix
nullptr
)
;
SkIRect
unclippedDevShapeBounds
devClipBounds
;
if
(
!
get_shape_and_clip_bounds
(
renderTargetContext
clip
*
shape
viewMatrix
&
unclippedDevShapeBounds
&
devClipBounds
)
)
{
if
(
!
inverseFilled
)
{
return
;
}
}
#
ifdef
SK_DISABLE_MASKFILTERED_MASK_CACHING
bool
useCache
=
false
;
#
else
bool
useCache
=
!
inverseFilled
&
&
viewMatrix
.
preservesAxisAlignment
(
)
&
&
shape
-
>
hasUnstyledKey
(
)
&
&
as_MFB
(
maskFilter
)
-
>
asABlur
(
nullptr
)
;
#
endif
const
SkIRect
*
boundsForClip
=
&
devClipBounds
;
if
(
useCache
)
{
SkIRect
clippedMaskRect
unClippedMaskRect
;
maskFilter
-
>
canFilterMaskGPU
(
*
shape
unclippedDevShapeBounds
devClipBounds
viewMatrix
&
clippedMaskRect
)
;
maskFilter
-
>
canFilterMaskGPU
(
*
shape
unclippedDevShapeBounds
unclippedDevShapeBounds
viewMatrix
&
unClippedMaskRect
)
;
if
(
clippedMaskRect
.
isEmpty
(
)
)
{
return
;
}
int
unclippedWidth
=
unClippedMaskRect
.
width
(
)
;
int
unclippedHeight
=
unClippedMaskRect
.
height
(
)
;
int64_t
unclippedArea
=
sk_64_mul
(
unclippedWidth
unclippedHeight
)
;
int64_t
clippedArea
=
sk_64_mul
(
clippedMaskRect
.
width
(
)
clippedMaskRect
.
height
(
)
)
;
int
maxTextureSize
=
renderTargetContext
-
>
caps
(
)
-
>
maxTextureSize
(
)
;
if
(
unclippedArea
>
2
*
clippedArea
|
|
unclippedWidth
>
maxTextureSize
|
|
unclippedHeight
>
maxTextureSize
)
{
useCache
=
false
;
}
else
{
boundsForClip
=
&
unclippedDevShapeBounds
;
}
}
GrUniqueKey
maskKey
;
if
(
useCache
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
&
maskKey
kDomain
5
+
2
+
shape
-
>
unstyledKeySize
(
)
"
Mask
Filtered
Masks
"
)
;
SkScalar
sx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMScaleX
)
;
SkScalar
sy
=
viewMatrix
.
get
(
SkMatrix
:
:
kMScaleY
)
;
SkScalar
kx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMSkewX
)
;
SkScalar
ky
=
viewMatrix
.
get
(
SkMatrix
:
:
kMSkewY
)
;
SkScalar
tx
=
viewMatrix
.
get
(
SkMatrix
:
:
kMTransX
)
;
SkScalar
ty
=
viewMatrix
.
get
(
SkMatrix
:
:
kMTransY
)
;
SkFixed
fracX
=
SkScalarToFixed
(
SkScalarFraction
(
tx
)
)
&
0x0000FF00
;
SkFixed
fracY
=
SkScalarToFixed
(
SkScalarFraction
(
ty
)
)
&
0x0000FF00
;
builder
[
0
]
=
SkFloat2Bits
(
sx
)
;
builder
[
1
]
=
SkFloat2Bits
(
sy
)
;
builder
[
2
]
=
SkFloat2Bits
(
kx
)
;
builder
[
3
]
=
SkFloat2Bits
(
ky
)
;
uint32_t
styleBits
=
shape
-
>
style
(
)
.
isSimpleHairline
(
)
?
(
(
shape
-
>
style
(
)
.
strokeRec
(
)
.
getCap
(
)
<
<
1
)
|
1
)
:
0
;
builder
[
4
]
=
fracX
|
(
fracY
>
>
8
)
|
(
styleBits
<
<
16
)
;
SkMaskFilterBase
:
:
BlurRec
rec
;
SkAssertResult
(
as_MFB
(
maskFilter
)
-
>
asABlur
(
&
rec
)
)
;
builder
[
5
]
=
rec
.
fStyle
;
builder
[
6
]
=
rec
.
fSigma
;
shape
-
>
writeUnstyledKey
(
&
builder
[
7
]
)
;
}
SkIRect
maskRect
;
if
(
maskFilter
-
>
canFilterMaskGPU
(
*
shape
unclippedDevShapeBounds
*
boundsForClip
viewMatrix
&
maskRect
)
)
{
if
(
clip_bounds_quick_reject
(
*
boundsForClip
maskRect
)
)
{
return
;
}
sk_sp
<
GrTextureProxy
>
filteredMask
;
GrProxyProvider
*
proxyProvider
=
context
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
if
(
maskKey
.
isValid
(
)
)
{
filteredMask
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
maskKey
kTopLeft_GrSurfaceOrigin
)
;
}
if
(
!
filteredMask
)
{
sk_sp
<
GrTextureProxy
>
maskProxy
(
create_mask_GPU
(
context
maskRect
viewMatrix
*
shape
renderTargetContext
-
>
numColorSamples
(
)
)
)
;
if
(
maskProxy
)
{
filteredMask
=
maskFilter
-
>
filterMaskGPU
(
context
std
:
:
move
(
maskProxy
)
viewMatrix
maskRect
)
;
SkASSERT
(
kTopLeft_GrSurfaceOrigin
=
=
filteredMask
-
>
origin
(
)
)
;
if
(
filteredMask
&
&
maskKey
.
isValid
(
)
)
{
proxyProvider
-
>
assignUniqueKeyToProxy
(
maskKey
filteredMask
.
get
(
)
)
;
}
}
}
if
(
filteredMask
)
{
if
(
draw_mask
(
renderTargetContext
clip
viewMatrix
maskRect
std
:
:
move
(
paint
)
std
:
:
move
(
filteredMask
)
)
)
{
return
;
}
}
}
sw_draw_with_mask_filter
(
context
renderTargetContext
clip
viewMatrix
*
shape
maskFilter
*
boundsForClip
std
:
:
move
(
paint
)
maskKey
)
;
}
void
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
GrShape
&
shape
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
const
SkMaskFilter
*
mf
)
{
draw_shape_with_mask_filter
(
context
renderTargetContext
clip
std
:
:
move
(
paint
)
viewMatrix
as_MFB
(
mf
)
shape
)
;
}
void
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
SkPaint
&
paint
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
{
if
(
context
-
>
abandoned
(
)
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
context
renderTargetContext
-
>
colorSpaceInfo
(
)
paint
viewMatrix
&
grPaint
)
)
{
return
;
}
SkMaskFilterBase
*
mf
=
as_MFB
(
paint
.
getMaskFilter
(
)
)
;
if
(
mf
&
&
!
mf
-
>
hasFragmentProcessor
(
)
)
{
draw_shape_with_mask_filter
(
context
renderTargetContext
clip
std
:
:
move
(
grPaint
)
viewMatrix
mf
shape
)
;
}
else
{
GrAA
aa
=
GrAA
(
paint
.
isAntiAlias
(
)
)
;
renderTargetContext
-
>
drawShape
(
clip
std
:
:
move
(
grPaint
)
aa
viewMatrix
shape
)
;
}
}
