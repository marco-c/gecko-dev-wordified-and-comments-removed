#
include
"
GrBlurUtils
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrRenderTargetContextPriv
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkTLazy
.
h
"
static
bool
clip_bounds_quick_reject
(
const
SkIRect
&
clipBounds
const
SkIRect
&
rect
)
{
return
clipBounds
.
isEmpty
(
)
|
|
rect
.
isEmpty
(
)
|
|
!
SkIRect
:
:
Intersects
(
clipBounds
rect
)
;
}
static
bool
draw_mask
(
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
maskRect
GrPaint
&
&
paint
sk_sp
<
GrTextureProxy
>
mask
)
{
SkMatrix
inverse
;
if
(
!
viewMatrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
SkMatrix
matrix
=
SkMatrix
:
:
MakeTrans
(
-
SkIntToScalar
(
maskRect
.
fLeft
)
-
SkIntToScalar
(
maskRect
.
fTop
)
)
;
matrix
.
preConcat
(
viewMatrix
)
;
paint
.
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
std
:
:
move
(
mask
)
matrix
)
)
;
renderTargetContext
-
>
fillRectWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
maskRect
)
inverse
)
;
return
true
;
}
static
bool
sw_draw_with_mask_filter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clipData
const
SkMatrix
&
viewMatrix
const
SkPath
&
devPath
const
SkMaskFilter
*
filter
const
SkIRect
&
clipBounds
GrPaint
&
&
paint
SkStrokeRec
:
:
InitStyle
fillOrHairline
)
{
SkMask
srcM
dstM
;
if
(
!
SkDraw
:
:
DrawToMask
(
devPath
&
clipBounds
filter
&
viewMatrix
&
srcM
SkMask
:
:
kComputeBoundsAndRenderImage_CreateMode
fillOrHairline
)
)
{
return
false
;
}
SkAutoMaskFreeImage
autoSrc
(
srcM
.
fImage
)
;
if
(
!
as_MFB
(
filter
)
-
>
filterMask
(
&
dstM
srcM
viewMatrix
nullptr
)
)
{
return
false
;
}
SkAutoMaskFreeImage
autoDst
(
dstM
.
fImage
)
;
if
(
clip_bounds_quick_reject
(
clipBounds
dstM
.
fBounds
)
)
{
return
false
;
}
GrSurfaceDesc
desc
;
desc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
desc
.
fWidth
=
dstM
.
fBounds
.
width
(
)
;
desc
.
fHeight
=
dstM
.
fBounds
.
height
(
)
;
desc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
sk_sp
<
GrSurfaceContext
>
sContext
=
context
-
>
contextPriv
(
)
.
makeDeferredSurfaceContext
(
desc
GrMipMapped
:
:
kNo
SkBackingFit
:
:
kApprox
SkBudgeted
:
:
kYes
)
;
if
(
!
sContext
)
{
return
false
;
}
SkImageInfo
ii
=
SkImageInfo
:
:
MakeA8
(
desc
.
fWidth
desc
.
fHeight
)
;
if
(
!
sContext
-
>
writePixels
(
ii
dstM
.
fImage
dstM
.
fRowBytes
0
0
)
)
{
return
false
;
}
return
draw_mask
(
renderTargetContext
clipData
viewMatrix
dstM
.
fBounds
std
:
:
move
(
paint
)
sContext
-
>
asTextureProxyRef
(
)
)
;
}
static
sk_sp
<
GrTextureProxy
>
create_mask_GPU
(
GrContext
*
context
const
SkIRect
&
maskRect
const
SkPath
&
devPath
SkStrokeRec
:
:
InitStyle
fillOrHairline
GrAA
aa
int
sampleCnt
)
{
if
(
GrAA
:
:
kNo
=
=
aa
)
{
sampleCnt
=
1
;
}
sk_sp
<
GrRenderTargetContext
>
rtContext
(
context
-
>
makeDeferredRenderTargetContextWithFallback
(
SkBackingFit
:
:
kApprox
maskRect
.
width
(
)
maskRect
.
height
(
)
kAlpha_8_GrPixelConfig
nullptr
sampleCnt
)
)
;
if
(
!
rtContext
)
{
return
nullptr
;
}
rtContext
-
>
priv
(
)
.
absClear
(
nullptr
0x0
)
;
GrPaint
maskPaint
;
maskPaint
.
setCoverageSetOpXPFactory
(
SkRegion
:
:
kReplace_Op
)
;
const
SkIRect
clipRect
=
SkIRect
:
:
MakeWH
(
maskRect
.
width
(
)
maskRect
.
height
(
)
)
;
GrFixedClip
clip
(
clipRect
)
;
SkMatrix
translate
;
translate
.
setTranslate
(
-
SkIntToScalar
(
maskRect
.
fLeft
)
-
SkIntToScalar
(
maskRect
.
fTop
)
)
;
rtContext
-
>
drawPath
(
clip
std
:
:
move
(
maskPaint
)
aa
translate
devPath
GrStyle
(
fillOrHairline
)
)
;
return
rtContext
-
>
asTextureProxyRef
(
)
;
}
static
void
draw_path_with_mask_filter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkMaskFilterBase
*
maskFilter
const
GrStyle
&
style
const
SkPath
*
path
bool
pathIsMutable
)
{
SkASSERT
(
maskFilter
)
;
SkIRect
clipBounds
;
clip
.
getConservativeBounds
(
renderTargetContext
-
>
width
(
)
renderTargetContext
-
>
height
(
)
&
clipBounds
)
;
SkTLazy
<
SkPath
>
tmpPath
;
SkStrokeRec
:
:
InitStyle
fillOrHairline
;
if
(
style
.
applies
(
)
)
{
SkScalar
scale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
0
=
=
scale
|
|
!
style
.
applyToPath
(
tmpPath
.
init
(
)
&
fillOrHairline
*
path
scale
)
)
{
return
;
}
pathIsMutable
=
true
;
path
=
tmpPath
.
get
(
)
;
}
else
if
(
style
.
isSimpleHairline
(
)
)
{
fillOrHairline
=
SkStrokeRec
:
:
kHairline_InitStyle
;
}
else
{
SkASSERT
(
style
.
isSimpleFill
(
)
)
;
fillOrHairline
=
SkStrokeRec
:
:
kFill_InitStyle
;
}
if
(
!
viewMatrix
.
isIdentity
(
)
)
{
SkPath
*
result
;
if
(
pathIsMutable
)
{
result
=
const_cast
<
SkPath
*
>
(
path
)
;
}
else
{
if
(
!
tmpPath
.
isValid
(
)
)
{
tmpPath
.
init
(
)
;
}
result
=
tmpPath
.
get
(
)
;
}
path
-
>
transform
(
viewMatrix
result
)
;
path
=
result
;
result
-
>
setIsVolatile
(
true
)
;
pathIsMutable
=
true
;
}
SkRect
maskRect
;
if
(
maskFilter
-
>
canFilterMaskGPU
(
SkRRect
:
:
MakeRect
(
path
-
>
getBounds
(
)
)
clipBounds
viewMatrix
&
maskRect
)
)
{
SkIRect
finalIRect
;
maskRect
.
roundOut
(
&
finalIRect
)
;
if
(
clip_bounds_quick_reject
(
clipBounds
finalIRect
)
)
{
return
;
}
if
(
maskFilter
-
>
directFilterMaskGPU
(
context
renderTargetContext
std
:
:
move
(
paint
)
clip
viewMatrix
SkStrokeRec
(
fillOrHairline
)
*
path
)
)
{
return
;
}
sk_sp
<
GrTextureProxy
>
maskProxy
(
create_mask_GPU
(
context
finalIRect
*
path
fillOrHairline
aa
renderTargetContext
-
>
numColorSamples
(
)
)
)
;
if
(
maskProxy
)
{
sk_sp
<
GrTextureProxy
>
filtered
=
maskFilter
-
>
filterMaskGPU
(
context
std
:
:
move
(
maskProxy
)
viewMatrix
finalIRect
)
;
if
(
filtered
)
{
if
(
draw_mask
(
renderTargetContext
clip
viewMatrix
finalIRect
std
:
:
move
(
paint
)
std
:
:
move
(
filtered
)
)
)
{
return
;
}
}
}
}
sw_draw_with_mask_filter
(
context
renderTargetContext
clip
viewMatrix
*
path
maskFilter
clipBounds
std
:
:
move
(
paint
)
fillOrHairline
)
;
}
void
GrBlurUtils
:
:
drawPathWithMaskFilter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
SkPath
&
path
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkMaskFilter
*
mf
const
GrStyle
&
style
bool
pathIsMutable
)
{
draw_path_with_mask_filter
(
context
renderTargetContext
clip
std
:
:
move
(
paint
)
aa
viewMatrix
as_MFB
(
mf
)
style
&
path
pathIsMutable
)
;
}
void
GrBlurUtils
:
:
drawPathWithMaskFilter
(
GrContext
*
context
GrRenderTargetContext
*
renderTargetContext
const
GrClip
&
clip
const
SkPath
&
origPath
const
SkPaint
&
paint
const
SkMatrix
&
origViewMatrix
const
SkMatrix
*
prePathMatrix
const
SkIRect
&
clipBounds
bool
pathIsMutable
)
{
SkASSERT
(
!
pathIsMutable
|
|
origPath
.
isVolatile
(
)
)
;
GrStyle
style
(
paint
)
;
const
SkPath
*
path
=
&
origPath
;
SkTLazy
<
SkPath
>
tmpPath
;
SkMatrix
viewMatrix
=
origViewMatrix
;
if
(
prePathMatrix
)
{
if
(
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getShader
(
)
&
&
!
style
.
applies
(
)
)
{
viewMatrix
.
preConcat
(
*
prePathMatrix
)
;
}
else
{
SkPath
*
result
=
pathIsMutable
?
const_cast
<
SkPath
*
>
(
path
)
:
tmpPath
.
init
(
)
;
pathIsMutable
=
true
;
path
-
>
transform
(
*
prePathMatrix
result
)
;
path
=
result
;
result
-
>
setIsVolatile
(
true
)
;
}
}
SkDEBUGCODE
(
prePathMatrix
=
(
const
SkMatrix
*
)
0x50FF8001
;
)
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
context
renderTargetContext
-
>
colorSpaceInfo
(
)
paint
viewMatrix
&
grPaint
)
)
{
return
;
}
GrAA
aa
=
GrAA
(
paint
.
isAntiAlias
(
)
)
;
SkMaskFilterBase
*
mf
=
as_MFB
(
paint
.
getMaskFilter
(
)
)
;
if
(
mf
&
&
!
mf
-
>
hasFragmentProcessor
(
)
)
{
draw_path_with_mask_filter
(
context
renderTargetContext
clip
std
:
:
move
(
grPaint
)
aa
viewMatrix
mf
style
path
pathIsMutable
)
;
}
else
{
renderTargetContext
-
>
drawPath
(
clip
std
:
:
move
(
grPaint
)
aa
viewMatrix
*
path
style
)
;
}
}
