#
include
"
src
/
gpu
/
GrRenderTargetContext
.
h
"
#
include
"
include
/
core
/
SkDrawable
.
h
"
#
include
"
include
/
gpu
/
GrBackendSemaphore
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
include
/
private
/
SkShadowFlags
.
h
"
#
include
"
include
/
utils
/
SkShadowUtils
.
h
"
#
include
"
src
/
core
/
SkAutoPixmapStorage
.
h
"
#
include
"
src
/
core
/
SkConvertPixels
.
h
"
#
include
"
src
/
core
/
SkDrawShadowInfo
.
h
"
#
include
"
src
/
core
/
SkGlyphRunPainter
.
h
"
#
include
"
src
/
core
/
SkLatticeIter
.
h
"
#
include
"
src
/
core
/
SkMakeUnique
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
core
/
SkSurfacePriv
.
h
"
#
include
"
src
/
gpu
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
GrAuditTrail
.
h
"
#
include
"
src
/
gpu
/
GrBlurUtils
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrClientMappedBufferManager
.
h
"
#
include
"
src
/
gpu
/
GrColor
.
h
"
#
include
"
src
/
gpu
/
GrContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrDataUtils
.
h
"
#
include
"
src
/
gpu
/
GrDrawingManager
.
h
"
#
include
"
src
/
gpu
/
GrFixedClip
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourcePriv
.
h
"
#
include
"
src
/
gpu
/
GrImageInfo
.
h
"
#
include
"
src
/
gpu
/
GrMemoryPool
.
h
"
#
include
"
src
/
gpu
/
GrPathRenderer
.
h
"
#
include
"
src
/
gpu
/
GrRecordingContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrRenderTarget
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrResourceProvider
.
h
"
#
include
"
src
/
gpu
/
GrStencilAttachment
.
h
"
#
include
"
src
/
gpu
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
GrTracing
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrBicubicEffect
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrRRectEffect
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrTextureDomain
.
h
"
#
include
"
src
/
gpu
/
effects
/
generated
/
GrColorMatrixFragmentProcessor
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuad
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrQuadUtils
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrShape
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrAtlasTextOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrClearOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrClearStencilClipOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDebugMarkerOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawAtlasOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawVerticesOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawableOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrFillRRectOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrFillRectOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrLatticeOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrOvalOpFactory
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrRegionOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrShadowRRectOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrStencilPathOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrStrokeRectOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrTextureOp
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextContext
.
h
"
#
include
"
src
/
gpu
/
text
/
GrTextTarget
.
h
"
class
GrRenderTargetContext
:
:
TextTarget
:
public
GrTextTarget
{
public
:
TextTarget
(
GrRenderTargetContext
*
renderTargetContext
)
:
GrTextTarget
(
renderTargetContext
-
>
width
(
)
renderTargetContext
-
>
height
(
)
renderTargetContext
-
>
colorInfo
(
)
)
fRenderTargetContext
(
renderTargetContext
)
fGlyphPainter
{
*
renderTargetContext
}
{
}
void
addDrawOp
(
const
GrClip
&
clip
std
:
:
unique_ptr
<
GrAtlasTextOp
>
op
)
override
{
fRenderTargetContext
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
drawShape
(
const
GrClip
&
clip
const
SkPaint
&
paint
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
override
{
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
fRenderTargetContext
-
>
fContext
fRenderTargetContext
clip
paint
viewMatrix
shape
)
;
}
void
makeGrPaint
(
GrMaskFormat
maskFormat
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
GrPaint
*
grPaint
)
override
{
auto
context
=
fRenderTargetContext
-
>
fContext
;
const
GrColorInfo
&
colorInfo
=
fRenderTargetContext
-
>
colorInfo
(
)
;
if
(
kARGB_GrMaskFormat
=
=
maskFormat
)
{
SkPaintToGrPaintWithPrimitiveColor
(
context
colorInfo
skPaint
grPaint
)
;
}
else
{
SkPaintToGrPaint
(
context
colorInfo
skPaint
viewMatrix
grPaint
)
;
}
}
GrRecordingContext
*
getContext
(
)
override
{
return
fRenderTargetContext
-
>
fContext
;
}
SkGlyphRunListPainter
*
glyphPainter
(
)
override
{
return
&
fGlyphPainter
;
}
private
:
GrRenderTargetContext
*
fRenderTargetContext
;
SkGlyphRunListPainter
fGlyphPainter
;
}
;
#
define
ASSERT_OWNED_RESOURCE
(
R
)
SkASSERT
(
!
(
R
)
|
|
(
R
)
-
>
getContext
(
)
=
=
this
-
>
drawingManager
(
)
-
>
getContext
(
)
)
#
define
ASSERT_SINGLE_OWNER
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
this
-
>
singleOwner
(
)
)
;
)
#
define
ASSERT_SINGLE_OWNER_PRIV
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
fRenderTargetContext
-
>
singleOwner
(
)
)
;
)
#
define
RETURN_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
;
}
#
define
RETURN_IF_ABANDONED_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
;
}
#
define
RETURN_FALSE_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
false
;
}
#
define
RETURN_FALSE_IF_ABANDONED_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
false
;
}
#
define
RETURN_NULL_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
nullptr
;
}
class
AutoCheckFlush
{
public
:
AutoCheckFlush
(
GrDrawingManager
*
drawingManager
)
:
fDrawingManager
(
drawingManager
)
{
SkASSERT
(
fDrawingManager
)
;
}
~
AutoCheckFlush
(
)
{
fDrawingManager
-
>
flushIfNecessary
(
)
;
}
private
:
GrDrawingManager
*
fDrawingManager
;
}
;
GrRenderTargetContext
:
:
GrRenderTargetContext
(
GrRecordingContext
*
context
sk_sp
<
GrRenderTargetProxy
>
rtp
GrColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
bool
managedOpsTask
)
:
GrSurfaceContext
(
context
colorType
kPremul_SkAlphaType
std
:
:
move
(
colorSpace
)
)
fRenderTargetProxy
(
std
:
:
move
(
rtp
)
)
fOpsTask
(
sk_ref_sp
(
fRenderTargetProxy
-
>
getLastOpsTask
(
)
)
)
fSurfaceProps
(
SkSurfacePropsCopyOrDefault
(
surfaceProps
)
)
fManagedOpsTask
(
managedOpsTask
)
{
fTextTarget
.
reset
(
new
TextTarget
(
this
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
#
ifdef
SK_DEBUG
void
GrRenderTargetContext
:
:
validate
(
)
const
{
SkASSERT
(
fRenderTargetProxy
)
;
fRenderTargetProxy
-
>
validate
(
fContext
)
;
SkASSERT
(
fContext
-
>
priv
(
)
.
caps
(
)
-
>
areColorTypeAndFormatCompatible
(
this
-
>
colorInfo
(
)
.
colorType
(
)
fRenderTargetProxy
-
>
backendFormat
(
)
)
)
;
if
(
fOpsTask
&
&
!
fOpsTask
-
>
isClosed
(
)
)
{
SkASSERT
(
fRenderTargetProxy
-
>
getLastRenderTask
(
)
=
=
fOpsTask
.
get
(
)
)
;
}
}
#
endif
GrRenderTargetContext
:
:
~
GrRenderTargetContext
(
)
{
ASSERT_SINGLE_OWNER
}
inline
GrAAType
GrRenderTargetContext
:
:
chooseAAType
(
GrAA
aa
)
{
if
(
GrAA
:
:
kNo
=
=
aa
)
{
if
(
this
-
>
numSamples
(
)
>
1
&
&
!
this
-
>
caps
(
)
-
>
multisampleDisableSupport
(
)
)
{
return
GrAAType
:
:
kMSAA
;
}
return
GrAAType
:
:
kNone
;
}
return
(
this
-
>
numSamples
(
)
>
1
)
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kCoverage
;
}
GrTextureProxy
*
GrRenderTargetContext
:
:
asTextureProxy
(
)
{
return
fRenderTargetProxy
-
>
asTextureProxy
(
)
;
}
const
GrTextureProxy
*
GrRenderTargetContext
:
:
asTextureProxy
(
)
const
{
return
fRenderTargetProxy
-
>
asTextureProxy
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrRenderTargetContext
:
:
asTextureProxyRef
(
)
{
return
sk_ref_sp
(
fRenderTargetProxy
-
>
asTextureProxy
(
)
)
;
}
GrMipMapped
GrRenderTargetContext
:
:
mipMapped
(
)
const
{
if
(
const
GrTextureProxy
*
proxy
=
this
-
>
asTextureProxy
(
)
)
{
return
proxy
-
>
mipMapped
(
)
;
}
return
GrMipMapped
:
:
kNo
;
}
GrOpsTask
*
GrRenderTargetContext
:
:
getOpsTask
(
)
{
ASSERT_SINGLE_OWNER
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
!
fOpsTask
|
|
fOpsTask
-
>
isClosed
(
)
)
{
sk_sp
<
GrOpsTask
>
newOpsTask
=
this
-
>
drawingManager
(
)
-
>
newOpsTask
(
fRenderTargetProxy
fManagedOpsTask
)
;
if
(
fOpsTask
&
&
fNumStencilSamples
>
0
)
{
fOpsTask
-
>
setMustPreserveStencil
(
)
;
newOpsTask
-
>
setInitialStencilContent
(
GrOpsTask
:
:
StencilContent
:
:
kPreserved
)
;
}
fOpsTask
=
std
:
:
move
(
newOpsTask
)
;
}
return
fOpsTask
.
get
(
)
;
}
void
GrRenderTargetContext
:
:
drawGlyphRunList
(
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkGlyphRunList
&
blob
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawGlyphRunList
"
fContext
)
;
if
(
this
-
>
wrapsVkSecondaryCB
(
)
)
{
return
;
}
GrTextContext
*
atlasTextContext
=
this
-
>
drawingManager
(
)
-
>
getTextContext
(
)
;
atlasTextContext
-
>
drawGlyphRunList
(
fContext
fTextTarget
.
get
(
)
clip
viewMatrix
fSurfaceProps
blob
)
;
}
void
GrRenderTargetContext
:
:
discard
(
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
discard
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
getOpsTask
(
)
-
>
discard
(
)
;
}
void
GrRenderTargetContext
:
:
clear
(
const
SkIRect
*
rect
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
clear
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
internalClear
(
rect
?
GrFixedClip
(
*
rect
)
:
GrFixedClip
:
:
Disabled
(
)
color
canClearFullscreen
)
;
}
void
GrRenderTargetContextPriv
:
:
clear
(
const
GrFixedClip
&
clip
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
clear
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
fRenderTargetContext
-
>
internalClear
(
clip
color
canClearFullscreen
)
;
}
static
void
clear_to_grpaint
(
const
SkPMColor4f
&
color
GrPaint
*
paint
)
{
paint
-
>
setColor4f
(
color
)
;
if
(
color
.
isOpaque
(
)
)
{
paint
-
>
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrcOver
)
;
}
else
{
paint
-
>
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
}
}
void
GrRenderTargetContext
:
:
internalClear
(
const
GrFixedClip
&
clip
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
bool
isFull
=
false
;
if
(
!
clip
.
hasWindowRectangles
(
)
)
{
isFull
=
!
clip
.
scissorEnabled
(
)
|
|
(
CanClearFullscreen
:
:
kYes
=
=
canClearFullscreen
&
&
(
this
-
>
caps
(
)
-
>
preferFullscreenClears
(
)
|
|
this
-
>
caps
(
)
-
>
shouldInitializeTextures
(
)
)
)
|
|
clip
.
scissorRect
(
)
.
contains
(
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
;
}
if
(
isFull
)
{
GrOpsTask
*
opsTask
=
this
-
>
getOpsTask
(
)
;
if
(
opsTask
-
>
resetForFullscreenClear
(
this
-
>
canDiscardPreviousOpsOnFullClear
(
)
)
&
&
!
this
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
{
opsTask
-
>
setColorLoadOp
(
GrLoadOp
:
:
kClear
color
)
;
return
;
}
else
{
opsTask
-
>
setColorLoadOp
(
GrLoadOp
:
:
kDiscard
)
;
}
if
(
this
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
{
SkRect
rtRect
=
SkRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
this
-
>
addDrawOp
(
GrFixedClip
:
:
Disabled
(
)
GrFillRectOp
:
:
MakeNonAARect
(
fContext
std
:
:
move
(
paint
)
SkMatrix
:
:
I
(
)
rtRect
)
)
;
}
else
{
this
-
>
addOp
(
GrClearOp
:
:
Make
(
fContext
SkIRect
:
:
MakeEmpty
(
)
color
true
)
)
;
}
}
else
{
if
(
this
-
>
caps
(
)
-
>
performPartialClearsAsDraws
(
)
)
{
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakeNonAARect
(
fContext
std
:
:
move
(
paint
)
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
)
)
;
}
else
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrClearOp
:
:
Make
(
fContext
clip
color
this
-
>
asSurfaceProxy
(
)
)
)
;
if
(
!
op
)
{
return
;
}
this
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
}
}
void
GrRenderTargetContext
:
:
drawPaint
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
)
{
SkRect
r
=
fRenderTargetProxy
-
>
getBoundsRect
(
)
;
if
(
!
paint
.
numTotalFragmentProcessors
(
)
)
{
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
r
)
;
}
else
{
SkMatrix
localMatrix
;
if
(
!
viewMatrix
.
invert
(
&
localMatrix
)
)
{
return
;
}
this
-
>
fillRectWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
r
localMatrix
)
;
}
}
enum
class
GrRenderTargetContext
:
:
QuadOptimization
{
kDiscarded
kSubmitted
kClipApplied
kCropped
}
;
static
bool
make_vertex_finite
(
float
*
value
)
{
if
(
SkScalarIsNaN
(
*
value
)
)
{
return
false
;
}
if
(
!
SkScalarIsFinite
(
*
value
)
)
{
static
constexpr
float
kNearInfinity
=
SK_ScalarMax
/
4
.
f
;
*
value
=
*
value
<
0
.
f
?
-
kNearInfinity
:
kNearInfinity
;
}
return
true
;
}
GrRenderTargetContext
:
:
QuadOptimization
GrRenderTargetContext
:
:
attemptQuadOptimization
(
const
GrClip
&
clip
const
SkPMColor4f
*
constColor
const
GrUserStencilSettings
*
stencilSettings
GrAA
*
aa
GrQuadAAFlags
*
edgeFlags
GrQuad
*
deviceQuad
GrQuad
*
localQuad
)
{
GrQuadAAFlags
newFlags
=
*
edgeFlags
;
SkRect
rtRect
;
if
(
stencilSettings
)
{
rtRect
=
SkRect
:
:
MakeWH
(
fRenderTargetProxy
-
>
worstCaseWidth
(
)
fRenderTargetProxy
-
>
worstCaseHeight
(
)
)
;
}
else
{
rtRect
=
SkRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
}
SkRect
drawBounds
=
deviceQuad
-
>
bounds
(
)
;
if
(
constColor
)
{
localQuad
=
nullptr
;
if
(
!
deviceQuad
-
>
isFinite
(
)
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
!
make_vertex_finite
(
deviceQuad
-
>
xs
(
)
+
i
)
|
|
!
make_vertex_finite
(
deviceQuad
-
>
ys
(
)
+
i
)
|
|
!
make_vertex_finite
(
deviceQuad
-
>
ws
(
)
+
i
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
}
SkASSERT
(
deviceQuad
-
>
isFinite
(
)
)
;
}
}
else
{
if
(
!
deviceQuad
-
>
isFinite
(
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
}
if
(
!
rtRect
.
intersects
(
drawBounds
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
SkRRect
clipRRect
=
SkRRect
:
:
MakeRect
(
rtRect
)
;
GrAA
clipAA
=
stencilSettings
?
*
aa
:
GrAA
:
:
kNo
;
bool
axisAlignedClip
=
true
;
if
(
!
clip
.
quickContains
(
rtRect
)
)
{
if
(
!
clip
.
isRRect
(
rtRect
&
clipRRect
&
clipAA
)
)
{
axisAlignedClip
=
false
;
}
}
if
(
axisAlignedClip
&
&
(
!
stencilSettings
|
|
clipAA
=
=
*
aa
)
)
{
SkRect
clipBounds
=
rtRect
;
if
(
!
clipBounds
.
intersect
(
clipRRect
.
rect
(
)
)
|
|
!
clipBounds
.
intersects
(
drawBounds
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
if
(
clipRRect
.
isRect
(
)
)
{
if
(
GrQuadUtils
:
:
CropToRect
(
clipBounds
clipAA
&
newFlags
deviceQuad
localQuad
)
)
{
if
(
constColor
&
&
deviceQuad
-
>
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
)
{
drawBounds
=
deviceQuad
-
>
bounds
(
)
;
if
(
drawBounds
.
contains
(
rtRect
)
)
{
this
-
>
clear
(
nullptr
*
constColor
CanClearFullscreen
:
:
kYes
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
else
if
(
GrClip
:
:
IsPixelAligned
(
drawBounds
)
&
&
drawBounds
.
width
(
)
>
256
&
&
drawBounds
.
height
(
)
>
256
)
{
SkIRect
scissorRect
;
drawBounds
.
round
(
&
scissorRect
)
;
this
-
>
clear
(
&
scissorRect
*
constColor
CanClearFullscreen
:
:
kNo
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
}
*
edgeFlags
=
newFlags
;
if
(
*
aa
=
=
GrAA
:
:
kNo
&
&
clipAA
=
=
GrAA
:
:
kYes
&
&
newFlags
!
=
GrQuadAAFlags
:
:
kNone
)
{
*
aa
=
GrAA
:
:
kYes
;
}
return
QuadOptimization
:
:
kClipApplied
;
}
else
{
return
QuadOptimization
:
:
kCropped
;
}
}
else
if
(
constColor
)
{
if
(
GrQuadUtils
:
:
CropToRect
(
clipBounds
clipAA
&
newFlags
deviceQuad
localQuad
)
&
&
deviceQuad
-
>
quadType
(
)
=
=
GrQuad
:
:
Type
:
:
kAxisAligned
&
&
deviceQuad
-
>
bounds
(
)
.
contains
(
clipBounds
)
)
{
GrPaint
paint
;
clear_to_grpaint
(
*
constColor
&
paint
)
;
this
-
>
drawRRect
(
GrFixedClip
:
:
Disabled
(
)
std
:
:
move
(
paint
)
clipAA
SkMatrix
:
:
I
(
)
clipRRect
GrStyle
:
:
SimpleFill
(
)
)
;
return
QuadOptimization
:
:
kSubmitted
;
}
else
{
return
QuadOptimization
:
:
kCropped
;
}
}
}
SkIRect
clipDevBounds
;
clip
.
getConservativeBounds
(
rtRect
.
width
(
)
rtRect
.
height
(
)
&
clipDevBounds
)
;
SkRect
clipBounds
=
SkRect
:
:
Make
(
clipDevBounds
)
;
if
(
!
clipBounds
.
intersects
(
drawBounds
)
)
{
return
QuadOptimization
:
:
kDiscarded
;
}
GrQuadUtils
:
:
CropToRect
(
clipBounds
clipAA
&
newFlags
deviceQuad
localQuad
)
;
return
QuadOptimization
:
:
kCropped
;
}
void
GrRenderTargetContext
:
:
drawFilledQuad
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeFlags
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
GrUserStencilSettings
*
ss
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawFilledQuad
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkPMColor4f
*
constColor
=
nullptr
;
SkPMColor4f
paintColor
;
if
(
!
ss
&
&
!
paint
.
numCoverageFragmentProcessors
(
)
&
&
paint
.
isConstantBlendedColor
(
&
paintColor
)
)
{
constColor
=
&
paintColor
;
}
GrQuad
croppedDeviceQuad
=
deviceQuad
;
GrQuad
croppedLocalQuad
=
localQuad
;
QuadOptimization
opt
=
this
-
>
attemptQuadOptimization
(
clip
constColor
ss
&
aa
&
edgeFlags
&
croppedDeviceQuad
&
croppedLocalQuad
)
;
if
(
opt
>
=
QuadOptimization
:
:
kClipApplied
)
{
const
GrClip
&
finalClip
=
opt
=
=
QuadOptimization
:
:
kClipApplied
?
GrFixedClip
:
:
Disabled
(
)
:
clip
;
GrAAType
aaType
=
ss
?
(
aa
=
=
GrAA
:
:
kYes
?
GrAAType
:
:
kMSAA
:
GrAAType
:
:
kNone
)
:
this
-
>
chooseAAType
(
aa
)
;
this
-
>
addDrawOp
(
finalClip
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
edgeFlags
croppedDeviceQuad
croppedLocalQuad
ss
)
)
;
}
}
void
GrRenderTargetContext
:
:
drawTexturedQuad
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrColorType
srcColorType
sk_sp
<
GrColorSpaceXform
>
textureXform
GrSamplerState
:
:
Filter
filter
const
SkPMColor4f
&
color
SkBlendMode
blendMode
GrAA
aa
GrQuadAAFlags
edgeFlags
const
GrQuad
&
deviceQuad
const
GrQuad
&
localQuad
const
SkRect
*
domain
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
proxy
)
;
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawTexturedQuad
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrQuad
croppedDeviceQuad
=
deviceQuad
;
GrQuad
croppedLocalQuad
=
localQuad
;
QuadOptimization
opt
=
this
-
>
attemptQuadOptimization
(
clip
nullptr
nullptr
&
aa
&
edgeFlags
&
croppedDeviceQuad
&
croppedLocalQuad
)
;
SkASSERT
(
opt
!
=
QuadOptimization
:
:
kSubmitted
)
;
if
(
opt
!
=
QuadOptimization
:
:
kDiscarded
)
{
const
GrClip
&
finalClip
=
opt
=
=
QuadOptimization
:
:
kClipApplied
?
GrFixedClip
:
:
Disabled
(
)
:
clip
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
auto
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
auto
saturate
=
clampType
=
=
GrClampType
:
:
kManual
?
GrTextureOp
:
:
Saturate
:
:
kYes
:
GrTextureOp
:
:
Saturate
:
:
kNo
;
this
-
>
addDrawOp
(
finalClip
GrTextureOp
:
:
Make
(
fContext
std
:
:
move
(
proxy
)
srcColorType
std
:
:
move
(
textureXform
)
filter
color
saturate
blendMode
aaType
edgeFlags
croppedDeviceQuad
croppedLocalQuad
domain
)
)
;
}
}
void
GrRenderTargetContext
:
:
drawRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
GrStyle
*
style
)
{
if
(
!
style
)
{
style
=
&
GrStyle
:
:
SimpleFill
(
)
;
}
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRect
"
fContext
)
;
SkASSERT
(
!
style
-
>
pathEffect
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
const
SkStrokeRec
&
stroke
=
style
-
>
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
this
-
>
fillRectToRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rect
rect
)
;
return
;
}
else
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kHairline_Style
)
{
if
(
(
!
rect
.
width
(
)
|
|
!
rect
.
height
(
)
)
&
&
SkStrokeRec
:
:
kHairline_Style
!
=
stroke
.
getStyle
(
)
)
{
SkScalar
r
=
stroke
.
getWidth
(
)
/
2
;
switch
(
stroke
.
getJoin
(
)
)
{
case
SkPaint
:
:
kMiter_Join
:
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
-
r
rect
.
fTop
-
r
rect
.
fRight
+
r
rect
.
fBottom
+
r
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
return
;
case
SkPaint
:
:
kRound_Join
:
if
(
rect
.
width
(
)
|
|
rect
.
height
(
)
)
{
SkRRect
rrect
=
SkRRect
:
:
MakeRectXY
(
rect
.
makeOutset
(
r
r
)
r
r
)
;
this
-
>
drawRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
GrStyle
:
:
SimpleFill
(
)
)
;
return
;
}
case
SkPaint
:
:
kBevel_Join
:
if
(
!
rect
.
width
(
)
)
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
-
r
rect
.
fTop
rect
.
fRight
+
r
rect
.
fBottom
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
}
else
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
rect
.
fTop
-
r
rect
.
fRight
rect
.
fBottom
+
r
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
}
return
;
}
}
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
op
=
GrStrokeRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
rect
stroke
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
rect
*
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawQuadSet
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
QuadSetEntry
quads
[
]
int
cnt
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakeSet
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
quads
cnt
)
)
;
}
int
GrRenderTargetContextPriv
:
:
maxWindowRectangles
(
)
const
{
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
maxWindowRectangles
(
*
fRenderTargetContext
-
>
caps
(
)
)
;
}
GrOpsTask
:
:
CanDiscardPreviousOps
GrRenderTargetContext
:
:
canDiscardPreviousOpsOnFullClear
(
)
const
{
#
if
GR_TEST_UTILS
if
(
fPreserveOpsOnFullClear_TestingOnly
)
{
return
GrOpsTask
:
:
CanDiscardPreviousOps
:
:
kNo
;
}
#
endif
return
GrOpsTask
:
:
CanDiscardPreviousOps
(
!
fNumStencilSamples
)
;
}
void
GrRenderTargetContext
:
:
setNeedsStencil
(
bool
useMixedSamplesIfNotMSAA
)
{
bool
hasInitializedStencil
=
fNumStencilSamples
>
0
;
int
numRequiredSamples
=
this
-
>
numSamples
(
)
;
if
(
useMixedSamplesIfNotMSAA
&
&
1
=
=
numRequiredSamples
)
{
SkASSERT
(
fRenderTargetProxy
-
>
canUseMixedSamples
(
*
this
-
>
caps
(
)
)
)
;
numRequiredSamples
=
this
-
>
caps
(
)
-
>
internalMultisampleCount
(
this
-
>
asSurfaceProxy
(
)
-
>
backendFormat
(
)
)
;
}
SkASSERT
(
numRequiredSamples
>
0
)
;
if
(
numRequiredSamples
>
fNumStencilSamples
)
{
fNumStencilSamples
=
numRequiredSamples
;
fRenderTargetProxy
-
>
setNeedsStencil
(
fNumStencilSamples
)
;
}
if
(
!
hasInitializedStencil
)
{
if
(
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
)
{
this
-
>
internalStencilClear
(
GrFixedClip
:
:
Disabled
(
)
false
)
;
}
else
{
this
-
>
getOpsTask
(
)
-
>
setInitialStencilContent
(
GrOpsTask
:
:
StencilContent
:
:
kUserBitsCleared
)
;
}
}
}
void
GrRenderTargetContextPriv
:
:
clearStencilClip
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
clearStencilClip
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
fRenderTargetContext
-
>
internalStencilClear
(
clip
insideStencilMask
)
;
}
void
GrRenderTargetContext
:
:
internalStencilClear
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
this
-
>
setNeedsStencil
(
false
)
;
if
(
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
)
{
const
GrUserStencilSettings
*
ss
=
GrStencilSettings
:
:
SetClipBitSettings
(
insideStencilMask
)
;
SkRect
rtRect
=
SkRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakeNonAARect
(
fContext
std
:
:
move
(
paint
)
SkMatrix
:
:
I
(
)
rtRect
ss
)
)
;
}
else
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrClearStencilClipOp
:
:
Make
(
fContext
clip
insideStencilMask
fRenderTargetProxy
.
get
(
)
)
)
;
if
(
!
op
)
{
return
;
}
this
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
}
void
GrRenderTargetContextPriv
:
:
stencilPath
(
const
GrHardClip
&
clip
GrAA
doStencilMSAA
const
SkMatrix
&
viewMatrix
sk_sp
<
const
GrPath
>
path
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
stencilPath
"
fRenderTargetContext
-
>
fContext
)
;
SkASSERT
(
path
)
;
SkASSERT
(
fRenderTargetContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
)
;
SkRect
bounds
=
SkRect
:
:
MakeIWH
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
)
;
GrAppliedHardClip
appliedClip
;
if
(
!
clip
.
apply
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
&
appliedClip
&
bounds
)
)
{
return
;
}
std
:
:
unique_ptr
<
GrOp
>
op
=
GrStencilPathOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
viewMatrix
GrAA
:
:
kYes
=
=
doStencilMSAA
appliedClip
.
hasStencilClip
(
)
appliedClip
.
scissorState
(
)
std
:
:
move
(
path
)
)
;
if
(
!
op
)
{
return
;
}
op
-
>
setClippedBounds
(
bounds
)
;
fRenderTargetContext
-
>
setNeedsStencil
(
GrAA
:
:
kYes
=
=
doStencilMSAA
)
;
fRenderTargetContext
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawTextureSet
(
const
GrClip
&
clip
const
TextureSetEntry
set
[
]
int
cnt
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
GrAA
aa
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawTextureSet
"
fContext
)
;
if
(
mode
!
=
SkBlendMode
:
:
kSrcOver
|
|
!
fContext
-
>
priv
(
)
.
caps
(
)
-
>
dynamicStateArrayGeometryProcessorTextureSupport
(
)
)
{
SkMatrix
ctm
;
for
(
int
i
=
0
;
i
<
cnt
;
+
+
i
)
{
float
alpha
=
set
[
i
]
.
fAlpha
;
ctm
=
viewMatrix
;
if
(
set
[
i
]
.
fPreViewMatrix
)
{
ctm
.
preConcat
(
*
set
[
i
]
.
fPreViewMatrix
)
;
}
GrQuad
quad
srcQuad
;
if
(
set
[
i
]
.
fDstClipQuad
)
{
quad
=
GrQuad
:
:
MakeFromSkQuad
(
set
[
i
]
.
fDstClipQuad
ctm
)
;
SkPoint
srcPts
[
4
]
;
GrMapRectPoints
(
set
[
i
]
.
fDstRect
set
[
i
]
.
fSrcRect
set
[
i
]
.
fDstClipQuad
srcPts
4
)
;
srcQuad
=
GrQuad
:
:
MakeFromSkQuad
(
srcPts
SkMatrix
:
:
I
(
)
)
;
}
else
{
quad
=
GrQuad
:
:
MakeFromRect
(
set
[
i
]
.
fDstRect
ctm
)
;
srcQuad
=
GrQuad
(
set
[
i
]
.
fSrcRect
)
;
}
const
SkRect
*
domain
=
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
set
[
i
]
.
fSrcRect
:
nullptr
;
this
-
>
drawTexturedQuad
(
clip
set
[
i
]
.
fProxy
set
[
i
]
.
fSrcColorType
texXform
filter
{
alpha
alpha
alpha
alpha
}
mode
aa
set
[
i
]
.
fAAFlags
quad
srcQuad
domain
)
;
}
}
else
{
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
auto
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
auto
saturate
=
clampType
=
=
GrClampType
:
:
kManual
?
GrTextureOp
:
:
Saturate
:
:
kYes
:
GrTextureOp
:
:
Saturate
:
:
kNo
;
auto
op
=
GrTextureOp
:
:
MakeSet
(
fContext
set
cnt
filter
saturate
aaType
constraint
viewMatrix
std
:
:
move
(
texXform
)
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
void
GrRenderTargetContext
:
:
drawVertices
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
SkVertices
>
vertices
const
SkVertices
:
:
Bone
bones
[
]
int
boneCount
GrPrimitiveType
*
overridePrimType
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawVertices
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkASSERT
(
vertices
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrDrawVerticesOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
std
:
:
move
(
vertices
)
bones
boneCount
viewMatrix
aaType
this
-
>
colorInfo
(
)
.
refColorSpaceXformFromSRGB
(
)
overridePrimType
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawAtlas
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawAtlas
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrDrawAtlasOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
aaType
spriteCount
xform
texRect
colors
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawRRect
(
const
GrClip
&
origClip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRRect
"
fContext
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
&
&
rrect
.
isEmpty
(
)
)
{
return
;
}
GrNoClip
noclip
;
const
GrClip
*
clip
=
&
origClip
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkRRect
devRRect
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
&
&
rrect
.
transform
(
viewMatrix
&
devRRect
)
&
&
clip
-
>
quickContains
(
devRRect
)
)
{
clip
=
&
noclip
;
}
#
endif
SkASSERT
(
!
style
.
pathEffect
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
rrect
.
isSimple
(
)
&
&
rrect
.
getSimpleRadii
(
)
.
fX
=
=
rrect
.
getSimpleRadii
(
)
.
fY
&
&
viewMatrix
.
rectStaysRect
(
)
&
&
viewMatrix
.
isSimilarity
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeCircularRRectOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rrect
stroke
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
!
op
&
&
style
.
isSimpleFill
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrFillRRectOp
:
:
Make
(
fContext
aaType
viewMatrix
rrect
*
this
-
>
caps
(
)
std
:
:
move
(
paint
)
)
;
}
if
(
!
op
&
&
GrAAType
:
:
kCoverage
=
=
aaType
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeRRectOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rrect
stroke
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
op
)
{
this
-
>
addDrawOp
(
*
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
*
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
rrect
style
)
)
;
}
static
SkPoint3
map
(
const
SkMatrix
&
m
const
SkPoint3
&
pt
)
{
SkPoint3
result
;
m
.
mapXY
(
pt
.
fX
pt
.
fY
(
SkPoint
*
)
&
result
.
fX
)
;
result
.
fZ
=
pt
.
fZ
;
return
result
;
}
bool
GrRenderTargetContext
:
:
drawFastShadow
(
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
true
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawFastShadow
"
fContext
)
;
bool
tiltZPlane
=
SkToBool
(
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fX
)
|
|
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fY
)
)
;
bool
skipAnalytic
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kGeometricOnly_ShadowFlag
)
;
if
(
tiltZPlane
|
|
skipAnalytic
|
|
!
viewMatrix
.
rectStaysRect
(
)
|
|
!
viewMatrix
.
isSimilarity
(
)
)
{
return
false
;
}
SkRRect
rrect
;
SkRect
rect
;
bool
isRRect
=
path
.
isRRect
(
&
rrect
)
&
&
SkRRectPriv
:
:
IsSimpleCircular
(
rrect
)
&
&
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fX
>
SK_ScalarNearlyZero
;
if
(
!
isRRect
&
&
path
.
isOval
(
&
rect
)
&
&
SkScalarNearlyEqual
(
rect
.
width
(
)
rect
.
height
(
)
)
&
&
rect
.
width
(
)
>
SK_ScalarNearlyZero
)
{
rrect
.
setOval
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
&
&
path
.
isRect
(
&
rect
)
)
{
rrect
.
setRect
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
)
{
return
false
;
}
if
(
rrect
.
isEmpty
(
)
)
{
return
true
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkPoint3
devLightPos
=
map
(
viewMatrix
rec
.
fLightPos
)
;
SkScalar
devToSrcScale
=
viewMatrix
.
isScaleTranslate
(
)
?
SkScalarInvert
(
SkScalarAbs
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
)
)
:
sk_float_rsqrt
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
*
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
+
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
*
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
)
;
SkScalar
occluderHeight
=
rec
.
fZPlaneParams
.
fZ
;
bool
transparent
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kTransparentOccluder_ShadowFlag
)
;
if
(
SkColorGetA
(
rec
.
fAmbientColor
)
>
0
)
{
SkScalar
devSpaceInsetWidth
=
SkDrawShadowMetrics
:
:
AmbientBlurRadius
(
occluderHeight
)
;
const
SkScalar
umbraRecipAlpha
=
SkDrawShadowMetrics
:
:
AmbientRecipAlpha
(
occluderHeight
)
;
const
SkScalar
devSpaceAmbientBlur
=
devSpaceInsetWidth
*
umbraRecipAlpha
;
SkScalar
ambientPathOutset
=
devSpaceInsetWidth
*
devToSrcScale
;
SkRRect
ambientRRect
;
SkRect
outsetRect
=
rrect
.
rect
(
)
.
makeOutset
(
ambientPathOutset
ambientPathOutset
)
;
if
(
rrect
.
isOval
(
)
)
{
ambientRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
+
ambientPathOutset
;
ambientRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
ambientColor
=
SkColorToPremulGrColor
(
rec
.
fAmbientColor
)
;
if
(
transparent
)
{
devSpaceInsetWidth
=
ambientRRect
.
width
(
)
;
}
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrShadowRRectOp
:
:
Make
(
fContext
ambientColor
viewMatrix
ambientRRect
devSpaceAmbientBlur
devSpaceInsetWidth
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
if
(
SkColorGetA
(
rec
.
fSpotColor
)
>
0
)
{
SkScalar
devSpaceSpotBlur
;
SkScalar
spotScale
;
SkVector
spotOffset
;
SkDrawShadowMetrics
:
:
GetSpotParams
(
occluderHeight
devLightPos
.
fX
devLightPos
.
fY
devLightPos
.
fZ
rec
.
fLightRadius
&
devSpaceSpotBlur
&
spotScale
&
spotOffset
)
;
const
SkScalar
srcSpaceSpotBlur
=
devSpaceSpotBlur
*
devToSrcScale
;
spotOffset
.
fX
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransX
]
;
spotOffset
.
fY
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransY
]
;
SkMatrix
ctmInverse
;
if
(
viewMatrix
.
invert
(
&
ctmInverse
)
)
{
ctmInverse
.
mapPoints
(
&
spotOffset
1
)
;
}
else
{
SkDebugf
(
"
Matrix
is
degenerate
.
Will
not
render
spot
shadow
correctly
!
\
n
"
)
;
SkASSERT
(
false
)
;
}
SkRRect
spotShadowRRect
;
SkMatrix
shadowTransform
;
shadowTransform
.
setScaleTranslate
(
spotScale
spotScale
spotOffset
.
fX
spotOffset
.
fY
)
;
rrect
.
transform
(
shadowTransform
&
spotShadowRRect
)
;
SkScalar
spotRadius
=
SkRRectPriv
:
:
GetSimpleRadii
(
spotShadowRRect
)
.
fX
;
SkScalar
blurOutset
=
srcSpaceSpotBlur
;
SkScalar
insetWidth
=
blurOutset
;
if
(
transparent
)
{
insetWidth
+
=
spotShadowRRect
.
width
(
)
;
}
else
{
SkScalar
maxOffset
;
if
(
rrect
.
isRect
(
)
)
{
maxOffset
=
SkTMax
(
SkTMax
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
)
)
SkTMax
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
)
)
)
;
}
else
{
SkScalar
dr
=
spotRadius
-
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
;
SkPoint
upperLeftOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
+
dr
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
+
dr
)
;
SkPoint
lowerRightOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
-
dr
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
-
dr
)
;
maxOffset
=
SkScalarSqrt
(
SkTMax
(
SkPointPriv
:
:
LengthSqd
(
upperLeftOffset
)
SkPointPriv
:
:
LengthSqd
(
lowerRightOffset
)
)
)
+
dr
;
}
insetWidth
+
=
SkTMax
(
blurOutset
maxOffset
)
;
}
SkRect
outsetRect
=
spotShadowRRect
.
rect
(
)
.
makeOutset
(
blurOutset
blurOutset
)
;
if
(
spotShadowRRect
.
isOval
(
)
)
{
spotShadowRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
spotRadius
+
blurOutset
;
spotShadowRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
spotColor
=
SkColorToPremulGrColor
(
rec
.
fSpotColor
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrShadowRRectOp
:
:
Make
(
fContext
spotColor
viewMatrix
spotShadowRRect
2
.
0f
*
devSpaceSpotBlur
insetWidth
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
return
true
;
}
bool
GrRenderTargetContext
:
:
drawFilledDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
origOuter
const
SkRRect
&
origInner
)
{
SkASSERT
(
!
origInner
.
isEmpty
(
)
)
;
SkASSERT
(
!
origOuter
.
isEmpty
(
)
)
;
SkTCopyOnFirstWrite
<
SkRRect
>
inner
(
origInner
)
outer
(
origOuter
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
if
(
GrAAType
:
:
kMSAA
=
=
aaType
)
{
return
false
;
}
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
SkRRectPriv
:
:
IsCircle
(
*
inner
)
&
&
SkRRectPriv
:
:
IsCircle
(
*
outer
)
)
{
auto
outerR
=
outer
-
>
width
(
)
/
2
.
f
;
auto
innerR
=
inner
-
>
width
(
)
/
2
.
f
;
auto
cx
=
outer
-
>
getBounds
(
)
.
fLeft
+
outerR
;
auto
cy
=
outer
-
>
getBounds
(
)
.
fTop
+
outerR
;
if
(
SkScalarNearlyEqual
(
cx
inner
-
>
getBounds
(
)
.
fLeft
+
innerR
)
&
&
SkScalarNearlyEqual
(
cy
inner
-
>
getBounds
(
)
.
fTop
+
innerR
)
)
{
auto
avgR
=
(
innerR
+
outerR
)
/
2
.
f
;
auto
circleBounds
=
SkRect
:
:
MakeLTRB
(
cx
-
avgR
cy
-
avgR
cx
+
avgR
cy
+
avgR
)
;
SkStrokeRec
stroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
stroke
.
setStrokeStyle
(
outerR
-
innerR
)
;
auto
op
=
GrOvalOpFactory
:
:
MakeOvalOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
circleBounds
GrStyle
(
stroke
nullptr
)
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
true
;
}
assert_alive
(
paint
)
;
}
}
GrClipEdgeType
innerEdgeType
outerEdgeType
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
innerEdgeType
=
GrClipEdgeType
:
:
kInverseFillAA
;
outerEdgeType
=
GrClipEdgeType
:
:
kFillAA
;
}
else
{
innerEdgeType
=
GrClipEdgeType
:
:
kInverseFillBW
;
outerEdgeType
=
GrClipEdgeType
:
:
kFillBW
;
}
SkMatrix
inverseVM
;
if
(
!
viewMatrix
.
isIdentity
(
)
)
{
if
(
!
origInner
.
transform
(
viewMatrix
inner
.
writable
(
)
)
)
{
return
false
;
}
if
(
!
origOuter
.
transform
(
viewMatrix
outer
.
writable
(
)
)
)
{
return
false
;
}
if
(
!
viewMatrix
.
invert
(
&
inverseVM
)
)
{
return
false
;
}
}
else
{
inverseVM
.
reset
(
)
;
}
const
auto
&
caps
=
*
this
-
>
caps
(
)
-
>
shaderCaps
(
)
;
auto
innerEffect
=
GrRRectEffect
:
:
Make
(
innerEdgeType
*
inner
caps
)
;
if
(
!
innerEffect
)
{
return
false
;
}
auto
outerEffect
=
GrRRectEffect
:
:
Make
(
outerEdgeType
*
outer
caps
)
;
if
(
!
outerEffect
)
{
return
false
;
}
paint
.
addCoverageFragmentProcessor
(
std
:
:
move
(
innerEffect
)
)
;
paint
.
addCoverageFragmentProcessor
(
std
:
:
move
(
outerEffect
)
)
;
SkRect
bounds
=
outer
-
>
getBounds
(
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
bounds
.
outset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
this
-
>
fillRectWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
bounds
inverseVM
)
;
return
true
;
}
void
GrRenderTargetContext
:
:
drawDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
outer
const
SkRRect
&
inner
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawDRRect
"
fContext
)
;
SkASSERT
(
!
outer
.
isEmpty
(
)
)
;
SkASSERT
(
!
inner
.
isEmpty
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
this
-
>
drawFilledDRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
outer
inner
)
)
{
return
;
}
assert_alive
(
paint
)
;
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
inner
)
;
path
.
addRRect
(
outer
)
;
path
.
setFillType
(
SkPath
:
:
kEvenOdd_FillType
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
path
)
)
;
}
void
GrRenderTargetContext
:
:
drawRegion
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRegion
"
fContext
)
;
if
(
GrAA
:
:
kYes
=
=
aa
)
{
if
(
!
SkToBool
(
viewMatrix
.
getType
(
)
&
~
(
SkMatrix
:
:
kTranslate_Mask
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateX
(
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateY
(
)
)
)
{
aa
=
GrAA
:
:
kNo
;
}
}
bool
complexStyle
=
!
style
.
isSimpleFill
(
)
;
if
(
complexStyle
|
|
GrAA
:
:
kYes
=
=
aa
)
{
SkPath
path
;
region
.
getBoundaryPath
(
&
path
)
;
path
.
setIsVolatile
(
true
)
;
return
this
-
>
drawPath
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
path
style
)
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrRegionOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
region
aaType
ss
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawOval
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawOval
"
fContext
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
oval
.
isEmpty
(
)
&
&
!
style
.
pathEffect
(
)
)
{
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
return
;
}
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
oval
&
style
)
;
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
oval
.
width
(
)
>
SK_ScalarNearlyZero
&
&
oval
.
width
(
)
=
=
oval
.
height
(
)
&
&
viewMatrix
.
isSimilarity
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeCircleOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
style
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
!
op
&
&
style
.
isSimpleFill
(
)
)
{
assert_alive
(
paint
)
;
op
=
GrFillRRectOp
:
:
Make
(
fContext
aaType
viewMatrix
SkRRect
:
:
MakeOval
(
oval
)
*
this
-
>
caps
(
)
std
:
:
move
(
paint
)
)
;
}
if
(
!
op
&
&
GrAAType
:
:
kCoverage
=
=
aaType
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeOvalOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
style
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
SkRRect
:
:
MakeOval
(
oval
)
SkPath
:
:
kCW_Direction
2
false
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawArc
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawArc
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
const
GrShaderCaps
*
shaderCaps
=
this
-
>
caps
(
)
-
>
shaderCaps
(
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrOvalOpFactory
:
:
MakeArcOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
startAngle
sweepAngle
useCenter
style
shaderCaps
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
}
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
:
:
MakeArc
(
oval
startAngle
sweepAngle
useCenter
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawImageLattice
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrTextureProxy
>
image
GrColorType
srcColorType
sk_sp
<
GrColorSpaceXform
>
csxf
GrSamplerState
:
:
Filter
filter
std
:
:
unique_ptr
<
SkLatticeIter
>
iter
const
SkRect
&
dst
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawImageLattice
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrLatticeOp
:
:
MakeNonAA
(
fContext
std
:
:
move
(
paint
)
viewMatrix
std
:
:
move
(
image
)
srcColorType
std
:
:
move
(
csxf
)
filter
std
:
:
move
(
iter
)
dst
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
drawable
const
SkRect
&
bounds
)
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrDrawableOp
:
:
Make
(
fContext
std
:
:
move
(
drawable
)
bounds
)
)
;
SkASSERT
(
op
)
;
this
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
const
SkIRect
&
srcRect
SkSurface
:
:
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
context
)
{
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
callback
(
context
nullptr
)
;
return
;
}
if
(
fRenderTargetProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
callback
(
context
nullptr
)
;
return
;
}
auto
dstCT
=
SkColorTypeToGrColorType
(
info
.
colorType
(
)
)
;
if
(
dstCT
=
=
GrColorType
:
:
kUnknown
|
|
GrColorTypeComponentFlags
(
dstCT
)
&
kGray_SkColorTypeComponentFlag
)
{
callback
(
context
nullptr
)
;
return
;
}
bool
needsRescale
=
srcRect
.
width
(
)
!
=
info
.
width
(
)
|
|
srcRect
.
height
(
)
!
=
info
.
height
(
)
;
auto
colorTypeOfFinalContext
=
this
-
>
colorInfo
(
)
.
colorType
(
)
;
auto
backendFormatOfFinalContext
=
fRenderTargetProxy
-
>
backendFormat
(
)
;
if
(
needsRescale
)
{
colorTypeOfFinalContext
=
dstCT
;
backendFormatOfFinalContext
=
this
-
>
caps
(
)
-
>
getDefaultBackendFormat
(
dstCT
GrRenderable
:
:
kYes
)
;
}
auto
readInfo
=
this
-
>
caps
(
)
-
>
supportedReadPixelsColorType
(
colorTypeOfFinalContext
backendFormatOfFinalContext
dstCT
)
;
if
(
readInfo
.
fColorType
=
=
GrColorType
:
:
kUnknown
)
{
callback
(
context
nullptr
)
;
return
;
}
uint32_t
dstComponents
=
GrColorTypeComponentFlags
(
dstCT
)
;
uint32_t
legalReadComponents
=
GrColorTypeComponentFlags
(
readInfo
.
fColorType
)
;
uint32_t
srcComponents
=
GrColorTypeComponentFlags
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
if
(
(
~
legalReadComponents
&
dstComponents
)
&
srcComponents
)
{
callback
(
context
nullptr
)
;
return
;
}
std
:
:
unique_ptr
<
GrRenderTargetContext
>
tempRTC
;
int
x
=
srcRect
.
fLeft
;
int
y
=
srcRect
.
fTop
;
if
(
needsRescale
)
{
tempRTC
=
this
-
>
rescale
(
info
srcRect
rescaleGamma
rescaleQuality
)
;
if
(
!
tempRTC
)
{
callback
(
context
nullptr
)
;
return
;
}
SkASSERT
(
SkColorSpace
:
:
Equals
(
tempRTC
-
>
colorInfo
(
)
.
colorSpace
(
)
info
.
colorSpace
(
)
)
)
;
SkASSERT
(
tempRTC
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
x
=
y
=
0
;
}
else
{
sk_sp
<
GrColorSpaceXform
>
xform
=
GrColorSpaceXform
:
:
Make
(
this
-
>
colorInfo
(
)
.
colorSpace
(
)
this
-
>
colorInfo
(
)
.
alphaType
(
)
info
.
colorSpace
(
)
info
.
alphaType
(
)
)
;
if
(
this
-
>
origin
(
)
=
=
kBottomLeft_GrSurfaceOrigin
|
|
xform
)
{
if
(
info
.
alphaType
(
)
=
=
kUnpremul_SkAlphaType
)
{
callback
(
context
nullptr
)
;
return
;
}
sk_sp
<
GrTextureProxy
>
texProxy
=
sk_ref_sp
(
fRenderTargetProxy
-
>
asTextureProxy
(
)
)
;
SkRect
srcRectToDraw
=
SkRect
:
:
Make
(
srcRect
)
;
if
(
!
texProxy
)
{
texProxy
=
GrSurfaceProxy
:
:
Copy
(
fContext
fRenderTargetProxy
.
get
(
)
this
-
>
colorInfo
(
)
.
colorType
(
)
GrMipMapped
:
:
kNo
srcRect
SkBackingFit
:
:
kApprox
SkBudgeted
:
:
kNo
)
;
if
(
!
texProxy
)
{
callback
(
context
nullptr
)
;
return
;
}
srcRectToDraw
=
SkRect
:
:
MakeWH
(
srcRect
.
width
(
)
srcRect
.
height
(
)
)
;
}
tempRTC
=
direct
-
>
priv
(
)
.
makeDeferredRenderTargetContext
(
SkBackingFit
:
:
kApprox
srcRect
.
width
(
)
srcRect
.
height
(
)
this
-
>
colorInfo
(
)
.
colorType
(
)
info
.
refColorSpace
(
)
1
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
;
if
(
!
tempRTC
)
{
callback
(
context
nullptr
)
;
return
;
}
tempRTC
-
>
drawTexture
(
GrNoClip
(
)
std
:
:
move
(
texProxy
)
this
-
>
colorInfo
(
)
.
colorType
(
)
GrSamplerState
:
:
Filter
:
:
kNearest
SkBlendMode
:
:
kSrc
SK_PMColor4fWHITE
srcRectToDraw
SkRect
:
:
MakeWH
(
srcRect
.
width
(
)
srcRect
.
height
(
)
)
GrAA
:
:
kNo
GrQuadAAFlags
:
:
kNone
SkCanvas
:
:
kFast_SrcRectConstraint
SkMatrix
:
:
I
(
)
std
:
:
move
(
xform
)
)
;
x
=
y
=
0
;
}
}
auto
rtc
=
tempRTC
?
tempRTC
.
get
(
)
:
this
;
return
rtc
-
>
asyncReadPixels
(
SkIRect
:
:
MakeXYWH
(
x
y
info
.
width
(
)
info
.
height
(
)
)
info
.
colorType
(
)
callback
context
)
;
}
class
GrRenderTargetContext
:
:
AsyncReadResult
:
public
SkSurface
:
:
AsyncReadResult
{
public
:
AsyncReadResult
(
uint32_t
inboxID
)
:
fInboxID
(
inboxID
)
{
}
~
AsyncReadResult
(
)
override
{
for
(
int
i
=
0
;
i
<
fPlanes
.
count
(
)
;
+
+
i
)
{
if
(
!
fPlanes
[
i
]
.
fMappedBuffer
)
{
delete
[
]
static_cast
<
const
char
*
>
(
fPlanes
[
i
]
.
fData
)
;
}
else
{
GrClientMappedBufferManager
:
:
BufferFinishedMessageBus
:
:
Post
(
{
std
:
:
move
(
fPlanes
[
i
]
.
fMappedBuffer
)
fInboxID
}
)
;
}
}
}
int
count
(
)
const
override
{
return
fPlanes
.
count
(
)
;
}
const
void
*
data
(
int
i
)
const
override
{
return
fPlanes
[
i
]
.
fData
;
}
size_t
rowBytes
(
int
i
)
const
override
{
return
fPlanes
[
i
]
.
fRowBytes
;
}
bool
addTransferResult
(
const
PixelTransferResult
&
result
SkISize
size
size_t
rowBytes
GrClientMappedBufferManager
*
manager
)
{
SkASSERT
(
!
result
.
fTransferBuffer
-
>
isMapped
(
)
)
;
const
void
*
mappedData
=
result
.
fTransferBuffer
-
>
map
(
)
;
if
(
!
mappedData
)
{
return
false
;
}
if
(
result
.
fPixelConverter
)
{
std
:
:
unique_ptr
<
char
[
]
>
convertedData
(
new
char
[
rowBytes
*
size
.
height
(
)
]
)
;
result
.
fPixelConverter
(
convertedData
.
get
(
)
mappedData
)
;
this
-
>
addCpuPlane
(
std
:
:
move
(
convertedData
)
rowBytes
)
;
result
.
fTransferBuffer
-
>
unmap
(
)
;
}
else
{
manager
-
>
insert
(
result
.
fTransferBuffer
)
;
this
-
>
addMappedPlane
(
mappedData
rowBytes
std
:
:
move
(
result
.
fTransferBuffer
)
)
;
}
return
true
;
}
void
addCpuPlane
(
std
:
:
unique_ptr
<
const
char
[
]
>
data
size_t
rowBytes
)
{
SkASSERT
(
data
)
;
SkASSERT
(
rowBytes
>
0
)
;
fPlanes
.
emplace_back
(
data
.
release
(
)
rowBytes
nullptr
)
;
}
private
:
void
addMappedPlane
(
const
void
*
data
size_t
rowBytes
sk_sp
<
GrGpuBuffer
>
mappedBuffer
)
{
SkASSERT
(
data
)
;
SkASSERT
(
rowBytes
>
0
)
;
SkASSERT
(
mappedBuffer
)
;
SkASSERT
(
mappedBuffer
-
>
isMapped
(
)
)
;
fPlanes
.
emplace_back
(
data
rowBytes
std
:
:
move
(
mappedBuffer
)
)
;
}
struct
Plane
{
Plane
(
const
void
*
data
size_t
rowBytes
sk_sp
<
GrGpuBuffer
>
buffer
)
:
fData
(
data
)
fRowBytes
(
rowBytes
)
fMappedBuffer
(
std
:
:
move
(
buffer
)
)
{
}
const
void
*
fData
;
size_t
fRowBytes
;
sk_sp
<
GrGpuBuffer
>
fMappedBuffer
;
}
;
SkSTArray
<
3
Plane
>
fPlanes
;
uint32_t
fInboxID
;
}
;
void
GrRenderTargetContext
:
:
asyncReadPixels
(
const
SkIRect
&
rect
SkColorType
colorType
ReadPixelsCallback
callback
ReadPixelsContext
context
)
{
SkASSERT
(
rect
.
fLeft
>
=
0
&
&
rect
.
fRight
<
=
this
-
>
width
(
)
)
;
SkASSERT
(
rect
.
fTop
>
=
0
&
&
rect
.
fBottom
<
=
this
-
>
height
(
)
)
;
auto
directContext
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
SkASSERT
(
directContext
)
;
auto
mappedBufferManager
=
directContext
-
>
priv
(
)
.
clientMappedBufferManager
(
)
;
auto
transferResult
=
this
-
>
transferPixels
(
SkColorTypeToGrColorType
(
colorType
)
rect
)
;
if
(
!
transferResult
.
fTransferBuffer
)
{
auto
ii
=
SkImageInfo
:
:
Make
(
rect
.
size
(
)
colorType
this
-
>
colorInfo
(
)
.
alphaType
(
)
this
-
>
colorInfo
(
)
.
refColorSpace
(
)
)
;
auto
result
=
skstd
:
:
make_unique
<
AsyncReadResult
>
(
0
)
;
std
:
:
unique_ptr
<
char
[
]
>
data
(
new
char
[
ii
.
computeMinByteSize
(
)
]
)
;
SkPixmap
pm
(
ii
data
.
get
(
)
ii
.
minRowBytes
(
)
)
;
result
-
>
addCpuPlane
(
std
:
:
move
(
data
)
pm
.
rowBytes
(
)
)
;
if
(
!
this
-
>
readPixels
(
ii
pm
.
writable_addr
(
)
pm
.
rowBytes
(
)
{
rect
.
fLeft
rect
.
fTop
}
)
)
{
callback
(
context
nullptr
)
;
}
callback
(
context
std
:
:
move
(
result
)
)
;
return
;
}
struct
FinishContext
{
ReadPixelsCallback
*
fClientCallback
;
ReadPixelsContext
fClientContext
;
SkISize
fSize
;
SkColorType
fColorType
;
GrClientMappedBufferManager
*
fMappedBufferManager
;
PixelTransferResult
fTransferResult
;
}
;
auto
*
finishContext
=
new
FinishContext
{
callback
context
rect
.
size
(
)
colorType
mappedBufferManager
std
:
:
move
(
transferResult
)
}
;
auto
finishCallback
=
[
]
(
GrGpuFinishedContext
c
)
{
const
auto
*
context
=
reinterpret_cast
<
const
FinishContext
*
>
(
c
)
;
auto
result
=
skstd
:
:
make_unique
<
AsyncReadResult
>
(
context
-
>
fMappedBufferManager
-
>
inboxID
(
)
)
;
size_t
rowBytes
=
context
-
>
fSize
.
width
(
)
*
SkColorTypeBytesPerPixel
(
context
-
>
fColorType
)
;
if
(
!
result
-
>
addTransferResult
(
context
-
>
fTransferResult
context
-
>
fSize
rowBytes
context
-
>
fMappedBufferManager
)
)
{
result
.
reset
(
)
;
}
(
*
context
-
>
fClientCallback
)
(
context
-
>
fClientContext
std
:
:
move
(
result
)
)
;
delete
context
;
}
;
GrFlushInfo
flushInfo
;
flushInfo
.
fFinishedContext
=
finishContext
;
flushInfo
.
fFinishedProc
=
finishCallback
;
this
-
>
flush
(
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
flushInfo
)
;
}
void
GrRenderTargetContext
:
:
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
context
)
{
SkASSERT
(
srcRect
.
fLeft
>
=
0
&
&
srcRect
.
fRight
<
=
this
-
>
width
(
)
)
;
SkASSERT
(
srcRect
.
fTop
>
=
0
&
&
srcRect
.
fBottom
<
=
this
-
>
height
(
)
)
;
SkASSERT
(
!
dstSize
.
isZero
(
)
)
;
SkASSERT
(
(
dstSize
.
width
(
)
%
2
=
=
0
)
&
&
(
dstSize
.
height
(
)
%
2
=
=
0
)
)
;
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
callback
(
context
nullptr
)
;
return
;
}
if
(
fRenderTargetProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
callback
(
context
nullptr
)
;
return
;
}
int
x
=
srcRect
.
fLeft
;
int
y
=
srcRect
.
fTop
;
std
:
:
unique_ptr
<
GrRenderTargetContext
>
tempRTC
;
bool
needsRescale
=
srcRect
.
size
(
)
!
=
dstSize
;
if
(
needsRescale
)
{
auto
info
=
SkImageInfo
:
:
Make
(
dstSize
kRGBA_8888_SkColorType
kPremul_SkAlphaType
dstColorSpace
)
;
tempRTC
=
this
-
>
rescale
(
info
srcRect
rescaleGamma
rescaleQuality
)
;
if
(
!
tempRTC
)
{
callback
(
context
nullptr
)
;
return
;
}
SkASSERT
(
SkColorSpace
:
:
Equals
(
tempRTC
-
>
colorInfo
(
)
.
colorSpace
(
)
info
.
colorSpace
(
)
)
)
;
SkASSERT
(
tempRTC
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
x
=
y
=
0
;
}
else
{
sk_sp
<
GrColorSpaceXform
>
xform
=
GrColorSpaceXform
:
:
Make
(
this
-
>
colorInfo
(
)
.
colorSpace
(
)
this
-
>
colorInfo
(
)
.
alphaType
(
)
dstColorSpace
.
get
(
)
kPremul_SkAlphaType
)
;
if
(
xform
)
{
sk_sp
<
GrTextureProxy
>
texProxy
=
this
-
>
asTextureProxyRef
(
)
;
if
(
!
texProxy
)
{
callback
(
context
nullptr
)
;
return
;
}
SkRect
srcRectToDraw
=
SkRect
:
:
Make
(
srcRect
)
;
tempRTC
=
direct
-
>
priv
(
)
.
makeDeferredRenderTargetContext
(
SkBackingFit
:
:
kApprox
dstSize
.
width
(
)
dstSize
.
height
(
)
this
-
>
colorInfo
(
)
.
colorType
(
)
dstColorSpace
1
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
;
if
(
!
tempRTC
)
{
callback
(
context
nullptr
)
;
return
;
}
tempRTC
-
>
drawTexture
(
GrNoClip
(
)
std
:
:
move
(
texProxy
)
this
-
>
colorInfo
(
)
.
colorType
(
)
GrSamplerState
:
:
Filter
:
:
kNearest
SkBlendMode
:
:
kSrc
SK_PMColor4fWHITE
srcRectToDraw
SkRect
:
:
MakeWH
(
srcRect
.
width
(
)
srcRect
.
height
(
)
)
GrAA
:
:
kNo
GrQuadAAFlags
:
:
kNone
SkCanvas
:
:
kFast_SrcRectConstraint
SkMatrix
:
:
I
(
)
std
:
:
move
(
xform
)
)
;
x
=
y
=
0
;
}
}
auto
srcProxy
=
tempRTC
?
tempRTC
-
>
asTextureProxyRef
(
)
:
this
-
>
asTextureProxyRef
(
)
;
if
(
!
srcProxy
)
{
callback
(
context
nullptr
)
;
return
;
}
GrColorType
srcColorType
=
tempRTC
?
tempRTC
-
>
colorInfo
(
)
.
colorType
(
)
:
this
-
>
colorInfo
(
)
.
colorType
(
)
;
auto
yRTC
=
direct
-
>
priv
(
)
.
makeDeferredRenderTargetContextWithFallback
(
SkBackingFit
:
:
kApprox
dstSize
.
width
(
)
dstSize
.
height
(
)
GrColorType
:
:
kAlpha_8
dstColorSpace
1
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
;
int
halfW
=
dstSize
.
width
(
)
/
2
;
int
halfH
=
dstSize
.
height
(
)
/
2
;
auto
uRTC
=
direct
-
>
priv
(
)
.
makeDeferredRenderTargetContextWithFallback
(
SkBackingFit
:
:
kApprox
halfW
halfH
GrColorType
:
:
kAlpha_8
dstColorSpace
1
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
;
auto
vRTC
=
direct
-
>
priv
(
)
.
makeDeferredRenderTargetContextWithFallback
(
SkBackingFit
:
:
kApprox
halfW
halfH
GrColorType
:
:
kAlpha_8
dstColorSpace
1
GrMipMapped
:
:
kNo
kTopLeft_GrSurfaceOrigin
)
;
if
(
!
yRTC
|
|
!
uRTC
|
|
!
vRTC
)
{
callback
(
context
nullptr
)
;
return
;
}
static
constexpr
float
kRec601M
[
]
{
65
.
481f
/
255
128
.
553f
/
255
24
.
966f
/
255
16
.
f
/
255
-
37
.
797f
/
255
-
74
.
203f
/
255
112
.
0f
/
255
128
.
f
/
255
112
.
f
/
255
-
93
.
786f
/
255
-
18
.
214f
/
255
128
.
f
/
255
}
;
static
constexpr
float
kRec709M
[
]
{
45
.
5594f
/
255
156
.
6288f
/
255
15
.
8118f
/
255
16
.
f
/
255
-
25
.
6642f
/
255
-
86
.
3358f
/
255
112
.
f
/
255
128
.
f
/
255
112
.
f
/
255
-
101
.
7303f
/
255
-
10
.
2697f
/
255
128
.
f
/
255
}
;
static
constexpr
float
kJpegM
[
]
{
0
.
299f
0
.
587f
0
.
114f
0
.
f
/
255
-
0
.
168736f
-
0
.
331264f
0
.
5f
128
.
f
/
255
0
.
5f
-
0
.
418688f
-
0
.
081312f
128
.
f
/
255
}
;
static
constexpr
float
kIM
[
]
{
1
.
f
0
.
f
0
.
f
0
.
f
0
.
f
1
.
f
0
.
f
0
.
f
0
.
f
0
.
f
1
.
f
0
.
f
}
;
const
float
*
baseM
=
kIM
;
switch
(
yuvColorSpace
)
{
case
kRec601_SkYUVColorSpace
:
baseM
=
kRec601M
;
break
;
case
kRec709_SkYUVColorSpace
:
baseM
=
kRec709M
;
break
;
case
kJPEG_SkYUVColorSpace
:
baseM
=
kJpegM
;
break
;
case
kIdentity_SkYUVColorSpace
:
baseM
=
kIM
;
break
;
}
auto
texMatrix
=
SkMatrix
:
:
MakeTrans
(
x
y
)
;
SkRect
dstRectY
=
SkRect
:
:
Make
(
dstSize
)
;
SkRect
dstRectUV
=
SkRect
:
:
MakeWH
(
halfW
halfH
)
;
float
yM
[
20
]
;
std
:
:
fill_n
(
yM
15
0
.
f
)
;
yM
[
15
]
=
baseM
[
0
]
;
yM
[
16
]
=
baseM
[
1
]
;
yM
[
17
]
=
baseM
[
2
]
;
yM
[
18
]
=
0
;
yM
[
19
]
=
baseM
[
3
]
;
GrPaint
yPaint
;
yPaint
.
addColorTextureProcessor
(
srcProxy
srcColorType
texMatrix
)
;
auto
yFP
=
GrColorMatrixFragmentProcessor
:
:
Make
(
yM
false
true
false
)
;
yPaint
.
addColorFragmentProcessor
(
std
:
:
move
(
yFP
)
)
;
yPaint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
yRTC
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
yPaint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
dstRectY
dstRectY
)
;
auto
yTransfer
=
yRTC
-
>
transferPixels
(
GrColorType
:
:
kAlpha_8
SkIRect
:
:
MakeWH
(
yRTC
-
>
width
(
)
yRTC
-
>
height
(
)
)
)
;
if
(
!
yTransfer
.
fTransferBuffer
)
{
callback
(
context
nullptr
)
;
return
;
}
texMatrix
.
preScale
(
2
.
f
2
.
f
)
;
float
uM
[
20
]
;
std
:
:
fill_n
(
uM
15
0
.
f
)
;
uM
[
15
]
=
baseM
[
4
]
;
uM
[
16
]
=
baseM
[
5
]
;
uM
[
17
]
=
baseM
[
6
]
;
uM
[
18
]
=
0
;
uM
[
19
]
=
baseM
[
7
]
;
GrPaint
uPaint
;
uPaint
.
addColorTextureProcessor
(
srcProxy
srcColorType
texMatrix
GrSamplerState
:
:
ClampBilerp
(
)
)
;
auto
uFP
=
GrColorMatrixFragmentProcessor
:
:
Make
(
uM
false
true
false
)
;
uPaint
.
addColorFragmentProcessor
(
std
:
:
move
(
uFP
)
)
;
uPaint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
uRTC
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
uPaint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
dstRectUV
dstRectUV
)
;
auto
uTransfer
=
uRTC
-
>
transferPixels
(
GrColorType
:
:
kAlpha_8
SkIRect
:
:
MakeWH
(
uRTC
-
>
width
(
)
uRTC
-
>
height
(
)
)
)
;
if
(
!
uTransfer
.
fTransferBuffer
)
{
callback
(
context
nullptr
)
;
return
;
}
float
vM
[
20
]
;
std
:
:
fill_n
(
vM
15
0
.
f
)
;
vM
[
15
]
=
baseM
[
8
]
;
vM
[
16
]
=
baseM
[
9
]
;
vM
[
17
]
=
baseM
[
10
]
;
vM
[
18
]
=
0
;
vM
[
19
]
=
baseM
[
11
]
;
GrPaint
vPaint
;
vPaint
.
addColorTextureProcessor
(
srcProxy
srcColorType
texMatrix
GrSamplerState
:
:
ClampBilerp
(
)
)
;
auto
vFP
=
GrColorMatrixFragmentProcessor
:
:
Make
(
vM
false
true
false
)
;
vPaint
.
addColorFragmentProcessor
(
std
:
:
move
(
vFP
)
)
;
vPaint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
vRTC
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
vPaint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
dstRectUV
dstRectUV
)
;
auto
vTransfer
=
vRTC
-
>
transferPixels
(
GrColorType
:
:
kAlpha_8
SkIRect
:
:
MakeWH
(
vRTC
-
>
width
(
)
vRTC
-
>
height
(
)
)
)
;
if
(
!
vTransfer
.
fTransferBuffer
)
{
callback
(
context
nullptr
)
;
return
;
}
struct
FinishContext
{
ReadPixelsCallback
*
fClientCallback
;
ReadPixelsContext
fClientContext
;
GrClientMappedBufferManager
*
fMappedBufferManager
;
SkISize
fSize
;
PixelTransferResult
fYTransfer
;
PixelTransferResult
fUTransfer
;
PixelTransferResult
fVTransfer
;
}
;
auto
*
finishContext
=
new
FinishContext
{
callback
context
direct
-
>
priv
(
)
.
clientMappedBufferManager
(
)
dstSize
std
:
:
move
(
yTransfer
)
std
:
:
move
(
uTransfer
)
std
:
:
move
(
vTransfer
)
}
;
auto
finishCallback
=
[
]
(
GrGpuFinishedContext
c
)
{
const
auto
*
context
=
reinterpret_cast
<
const
FinishContext
*
>
(
c
)
;
auto
result
=
skstd
:
:
make_unique
<
AsyncReadResult
>
(
context
-
>
fMappedBufferManager
-
>
inboxID
(
)
)
;
auto
manager
=
context
-
>
fMappedBufferManager
;
size_t
rowBytes
=
SkToSizeT
(
context
-
>
fSize
.
width
(
)
)
;
if
(
!
result
-
>
addTransferResult
(
context
-
>
fYTransfer
context
-
>
fSize
rowBytes
manager
)
)
{
(
*
context
-
>
fClientCallback
)
(
context
-
>
fClientContext
nullptr
)
;
delete
context
;
return
;
}
rowBytes
/
=
2
;
SkISize
uvSize
=
{
context
-
>
fSize
.
width
(
)
/
2
context
-
>
fSize
.
height
(
)
/
2
}
;
if
(
!
result
-
>
addTransferResult
(
context
-
>
fUTransfer
uvSize
rowBytes
manager
)
)
{
(
*
context
-
>
fClientCallback
)
(
context
-
>
fClientContext
nullptr
)
;
delete
context
;
return
;
}
if
(
!
result
-
>
addTransferResult
(
context
-
>
fVTransfer
uvSize
rowBytes
manager
)
)
{
(
*
context
-
>
fClientCallback
)
(
context
-
>
fClientContext
nullptr
)
;
delete
context
;
return
;
}
(
*
context
-
>
fClientCallback
)
(
context
-
>
fClientContext
std
:
:
move
(
result
)
)
;
delete
context
;
}
;
GrFlushInfo
flushInfo
;
flushInfo
.
fFinishedContext
=
finishContext
;
flushInfo
.
fFinishedProc
=
finishCallback
;
this
-
>
flush
(
SkSurface
:
:
BackendSurfaceAccess
:
:
kNoAccess
flushInfo
)
;
}
GrSemaphoresSubmitted
GrRenderTargetContext
:
:
flush
(
SkSurface
:
:
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
flush
"
fContext
)
;
return
this
-
>
drawingManager
(
)
-
>
flushSurface
(
fRenderTargetProxy
.
get
(
)
access
info
)
;
}
bool
GrRenderTargetContext
:
:
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
)
{
ASSERT_SINGLE_OWNER
RETURN_FALSE_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
waitOnSemaphores
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
numSemaphores
&
&
!
this
-
>
caps
(
)
-
>
semaphoreSupport
(
)
)
{
return
false
;
}
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
return
false
;
}
auto
resourceProvider
=
direct
-
>
priv
(
)
.
resourceProvider
(
)
;
std
:
:
unique_ptr
<
sk_sp
<
GrSemaphore
>
[
]
>
grSemaphores
(
new
sk_sp
<
GrSemaphore
>
[
numSemaphores
]
)
;
for
(
int
i
=
0
;
i
<
numSemaphores
;
+
+
i
)
{
grSemaphores
[
i
]
=
resourceProvider
-
>
wrapBackendSemaphore
(
waitSemaphores
[
i
]
GrResourceProvider
:
:
SemaphoreWrapType
:
:
kWillWait
kAdopt_GrWrapOwnership
)
;
}
this
-
>
drawingManager
(
)
-
>
newWaitRenderTask
(
this
-
>
asSurfaceProxyRef
(
)
std
:
:
move
(
grSemaphores
)
numSemaphores
)
;
return
true
;
}
void
GrRenderTargetContext
:
:
insertEventMarker
(
const
SkString
&
str
)
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrDebugMarkerOp
:
:
Make
(
fContext
fRenderTargetProxy
.
get
(
)
str
)
)
;
this
-
>
addOp
(
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawPath
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawPath
"
fContext
)
;
GrShape
shape
(
path
style
)
;
this
-
>
drawShape
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
shape
)
;
}
void
GrRenderTargetContext
:
:
drawShape
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawShape
"
fContext
)
;
if
(
shape
.
isEmpty
(
)
)
{
if
(
shape
.
inverseFilled
(
)
)
{
this
-
>
drawPaint
(
clip
std
:
:
move
(
paint
)
viewMatrix
)
;
}
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
!
shape
.
style
(
)
.
hasPathEffect
(
)
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
SkRRect
rrect
;
bool
inverted
;
if
(
shape
.
asRRect
(
&
rrect
nullptr
nullptr
&
inverted
)
&
&
!
inverted
)
{
if
(
rrect
.
isRect
(
)
)
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
.
rect
(
)
&
shape
.
style
(
)
)
;
return
;
}
else
if
(
rrect
.
isOval
(
)
)
{
this
-
>
drawOval
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
.
rect
(
)
shape
.
style
(
)
)
;
return
;
}
this
-
>
drawRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
shape
.
style
(
)
)
;
return
;
}
else
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
shape
.
style
(
)
.
isSimpleFill
(
)
&
&
viewMatrix
.
rectStaysRect
(
)
)
{
SkRect
rects
[
2
]
;
if
(
shape
.
asNestedRects
(
rects
)
)
{
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrStrokeRectOp
:
:
MakeNested
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rects
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
return
;
}
}
}
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
shape
)
;
}
bool
GrRenderTargetContextPriv
:
:
drawAndStencilPath
(
const
GrHardClip
&
clip
const
GrUserStencilSettings
*
ss
SkRegion
:
:
Op
op
bool
invert
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_FALSE_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
drawAndStencilPath
"
fRenderTargetContext
-
>
fContext
)
;
if
(
path
.
isEmpty
(
)
&
&
path
.
isInverseFillType
(
)
)
{
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
this
-
>
stencilRect
(
clip
ss
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeIWH
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
)
)
;
return
true
;
}
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
fRenderTargetContext
-
>
chooseAAType
(
aa
)
;
bool
hasUserStencilSettings
=
!
ss
-
>
isUnused
(
)
;
SkIRect
clipConservativeBounds
;
clip
.
getConservativeBounds
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
&
clipConservativeBounds
nullptr
)
;
GrShape
shape
(
path
GrStyle
:
:
SimpleFill
(
)
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
fRenderTargetContext
-
>
caps
(
)
;
canDrawArgs
.
fProxy
=
fRenderTargetContext
-
>
proxy
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fAAType
=
aaType
;
SkASSERT
(
!
fRenderTargetContext
-
>
wrapsVkSecondaryCB
(
)
)
;
canDrawArgs
.
fTargetIsWrappedVkSecondaryCB
=
false
;
canDrawArgs
.
fHasUserStencilSettings
=
hasUserStencilSettings
;
GrPathRenderer
*
pr
=
fRenderTargetContext
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
GrPathRendererChain
:
:
DrawType
:
:
kStencilAndColor
)
;
if
(
!
pr
)
{
return
false
;
}
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
GrPathRenderer
:
:
DrawPathArgs
args
{
fRenderTargetContext
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
ss
fRenderTargetContext
&
clip
&
clipConservativeBounds
&
viewMatrix
&
shape
aaType
fRenderTargetContext
-
>
colorInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
return
true
;
}
SkBudgeted
GrRenderTargetContextPriv
:
:
isBudgeted
(
)
const
{
ASSERT_SINGLE_OWNER_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
SkBudgeted
:
:
kNo
;
}
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
isBudgeted
(
)
;
}
void
GrRenderTargetContext
:
:
drawShapeUsingPathRenderer
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
GrShape
&
originalShape
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
internalDrawPath
"
fContext
)
;
if
(
!
viewMatrix
.
isFinite
(
)
|
|
!
originalShape
.
bounds
(
)
.
isFinite
(
)
)
{
return
;
}
SkIRect
clipConservativeBounds
;
clip
.
getConservativeBounds
(
this
-
>
width
(
)
this
-
>
height
(
)
&
clipConservativeBounds
nullptr
)
;
GrShape
tempShape
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
this
-
>
caps
(
)
;
canDrawArgs
.
fProxy
=
this
-
>
proxy
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
originalShape
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fTargetIsWrappedVkSecondaryCB
=
this
-
>
wrapsVkSecondaryCB
(
)
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
GrPathRenderer
*
pr
;
static
constexpr
GrPathRendererChain
:
:
DrawType
kType
=
GrPathRendererChain
:
:
DrawType
:
:
kColor
;
if
(
originalShape
.
isEmpty
(
)
&
&
!
originalShape
.
inverseFilled
(
)
)
{
return
;
}
canDrawArgs
.
fAAType
=
aaType
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
kType
)
;
SkScalar
styleScale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
!
pr
&
&
originalShape
.
style
(
)
.
pathEffect
(
)
)
{
tempShape
=
originalShape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectOnly
styleScale
)
;
if
(
tempShape
.
isEmpty
(
)
)
{
return
;
}
canDrawArgs
.
fShape
=
&
tempShape
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
kType
)
;
}
if
(
!
pr
)
{
if
(
canDrawArgs
.
fShape
-
>
style
(
)
.
applies
(
)
)
{
tempShape
=
canDrawArgs
.
fShape
-
>
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
styleScale
)
;
if
(
tempShape
.
isEmpty
(
)
)
{
return
;
}
canDrawArgs
.
fShape
=
&
tempShape
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
true
kType
)
;
}
else
{
pr
=
this
-
>
drawingManager
(
)
-
>
getSoftwarePathRenderer
(
)
;
}
}
if
(
!
pr
)
{
#
ifdef
SK_DEBUG
SkDebugf
(
"
Unable
to
find
path
renderer
compatible
with
path
.
\
n
"
)
;
#
endif
return
;
}
GrPathRenderer
:
:
DrawPathArgs
args
{
this
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
&
GrUserStencilSettings
:
:
kUnused
this
&
clip
&
clipConservativeBounds
&
viewMatrix
canDrawArgs
.
fShape
aaType
this
-
>
colorInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
}
static
void
op_bounds
(
SkRect
*
bounds
const
GrOp
*
op
)
{
*
bounds
=
op
-
>
bounds
(
)
;
if
(
op
-
>
hasZeroArea
(
)
)
{
if
(
op
-
>
hasAABloat
(
)
)
{
bounds
-
>
outset
(
0
.
5f
0
.
5f
)
;
}
else
{
SkRect
before
=
*
bounds
;
bounds
-
>
roundOut
(
bounds
)
;
if
(
bounds
-
>
fLeft
=
=
before
.
fLeft
)
{
bounds
-
>
fLeft
-
=
1
;
}
if
(
bounds
-
>
fTop
=
=
before
.
fTop
)
{
bounds
-
>
fTop
-
=
1
;
}
if
(
bounds
-
>
fRight
=
=
before
.
fRight
)
{
bounds
-
>
fRight
+
=
1
;
}
if
(
bounds
-
>
fBottom
=
=
before
.
fBottom
)
{
bounds
-
>
fBottom
+
=
1
;
}
}
}
}
void
GrRenderTargetContext
:
:
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
)
{
this
-
>
getOpsTask
(
)
-
>
addOp
(
std
:
:
move
(
op
)
GrTextureResolveManager
(
this
-
>
drawingManager
(
)
)
*
this
-
>
caps
(
)
)
;
}
void
GrRenderTargetContext
:
:
addDrawOp
(
const
GrClip
&
clip
std
:
:
unique_ptr
<
GrDrawOp
>
op
const
std
:
:
function
<
WillAddOpFn
>
&
willAddFn
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkDEBUGCODE
(
op
-
>
fAddDrawOpCalled
=
true
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
addDrawOp
"
fContext
)
;
SkRect
bounds
;
op_bounds
(
&
bounds
op
.
get
(
)
)
;
GrAppliedClip
appliedClip
;
GrDrawOp
:
:
FixedFunctionFlags
fixedFunctionFlags
=
op
-
>
fixedFunctionFlags
(
)
;
bool
usesHWAA
=
fixedFunctionFlags
&
GrDrawOp
:
:
FixedFunctionFlags
:
:
kUsesHWAA
;
bool
usesStencil
=
fixedFunctionFlags
&
GrDrawOp
:
:
FixedFunctionFlags
:
:
kUsesStencil
;
if
(
usesStencil
)
{
this
-
>
setNeedsStencil
(
usesHWAA
)
;
}
if
(
!
clip
.
apply
(
fContext
this
usesHWAA
usesStencil
&
appliedClip
&
bounds
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
SkASSERT
(
(
!
usesStencil
&
&
!
appliedClip
.
hasStencilClip
(
)
)
|
|
(
fNumStencilSamples
>
0
)
)
;
GrClampType
clampType
=
GrColorTypeClampType
(
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
bool
hasMixedSampledCoverage
=
(
usesHWAA
&
&
this
-
>
numSamples
(
)
<
=
1
)
;
#
ifdef
SK_DEBUG
if
(
hasMixedSampledCoverage
)
{
SkASSERT
(
usesStencil
)
;
SkASSERT
(
fRenderTargetProxy
-
>
canUseMixedSamples
(
*
this
-
>
caps
(
)
)
)
;
}
#
endif
GrProcessorSet
:
:
Analysis
analysis
=
op
-
>
finalize
(
*
this
-
>
caps
(
)
&
appliedClip
hasMixedSampledCoverage
clampType
)
;
GrXferProcessor
:
:
DstProxy
dstProxy
;
if
(
analysis
.
requiresDstTexture
(
)
)
{
if
(
!
this
-
>
setupDstProxy
(
clip
*
op
&
dstProxy
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
}
op
-
>
setClippedBounds
(
bounds
)
;
auto
opsTask
=
this
-
>
getOpsTask
(
)
;
if
(
willAddFn
)
{
willAddFn
(
op
.
get
(
)
opsTask
-
>
uniqueID
(
)
)
;
}
opsTask
-
>
addDrawOp
(
std
:
:
move
(
op
)
analysis
std
:
:
move
(
appliedClip
)
dstProxy
GrTextureResolveManager
(
this
-
>
drawingManager
(
)
)
*
this
-
>
caps
(
)
)
;
}
bool
GrRenderTargetContext
:
:
setupDstProxy
(
const
GrClip
&
clip
const
GrOp
&
op
GrXferProcessor
:
:
DstProxy
*
dstProxy
)
{
if
(
fRenderTargetProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
if
(
this
-
>
caps
(
)
-
>
textureBarrierSupport
(
)
&
&
!
fRenderTargetProxy
-
>
requiresManualMSAAResolve
(
)
)
{
if
(
GrTextureProxy
*
texProxy
=
fRenderTargetProxy
-
>
asTextureProxy
(
)
)
{
dstProxy
-
>
setProxy
(
sk_ref_sp
(
texProxy
)
)
;
dstProxy
-
>
setOffset
(
0
0
)
;
return
true
;
}
}
SkIRect
copyRect
=
SkIRect
:
:
MakeWH
(
fRenderTargetProxy
-
>
width
(
)
fRenderTargetProxy
-
>
height
(
)
)
;
SkIRect
clippedRect
;
clip
.
getConservativeBounds
(
fRenderTargetProxy
-
>
width
(
)
fRenderTargetProxy
-
>
height
(
)
&
clippedRect
)
;
SkRect
opBounds
=
op
.
bounds
(
)
;
if
(
op
.
hasAABloat
(
)
|
|
op
.
hasZeroArea
(
)
)
{
opBounds
.
outset
(
0
.
5f
0
.
5f
)
;
clippedRect
.
outset
(
1
1
)
;
clippedRect
.
intersect
(
SkIRect
:
:
MakeWH
(
fRenderTargetProxy
-
>
width
(
)
fRenderTargetProxy
-
>
height
(
)
)
)
;
}
SkIRect
opIBounds
;
opBounds
.
roundOut
(
&
opIBounds
)
;
if
(
!
clippedRect
.
intersect
(
opIBounds
)
)
{
#
ifdef
SK_DEBUG
GrCapsDebugf
(
this
-
>
caps
(
)
"
setupDstTexture
:
Missed
an
early
reject
bailing
on
draw
.
"
)
;
#
endif
return
false
;
}
GrCaps
:
:
DstCopyRestrictions
restrictions
=
this
-
>
caps
(
)
-
>
getDstCopyRestrictions
(
fRenderTargetProxy
.
get
(
)
this
-
>
colorInfo
(
)
.
colorType
(
)
)
;
if
(
!
restrictions
.
fMustCopyWholeSrc
)
{
copyRect
=
clippedRect
;
}
SkIPoint
dstOffset
;
SkBackingFit
fit
;
if
(
restrictions
.
fRectsMustMatch
=
=
GrSurfaceProxy
:
:
RectsMustMatch
:
:
kYes
)
{
dstOffset
=
{
0
0
}
;
fit
=
SkBackingFit
:
:
kExact
;
}
else
{
dstOffset
=
{
copyRect
.
fLeft
copyRect
.
fTop
}
;
fit
=
SkBackingFit
:
:
kApprox
;
}
sk_sp
<
GrTextureProxy
>
newProxy
=
GrSurfaceProxy
:
:
Copy
(
fContext
fRenderTargetProxy
.
get
(
)
this
-
>
colorInfo
(
)
.
colorType
(
)
GrMipMapped
:
:
kNo
copyRect
fit
SkBudgeted
:
:
kYes
restrictions
.
fRectsMustMatch
)
;
SkASSERT
(
newProxy
)
;
dstProxy
-
>
setProxy
(
std
:
:
move
(
newProxy
)
)
;
dstProxy
-
>
setOffset
(
dstOffset
)
;
return
true
;
}
bool
GrRenderTargetContext
:
:
blitTexture
(
GrTextureProxy
*
src
GrColorType
srcColorType
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
)
{
SkIRect
clippedSrcRect
;
SkIPoint
clippedDstPoint
;
if
(
!
GrClipSrcRectAndDstPoint
(
this
-
>
asSurfaceProxy
(
)
-
>
isize
(
)
src
-
>
isize
(
)
srcRect
dstPoint
&
clippedSrcRect
&
clippedDstPoint
)
)
{
return
false
;
}
GrPaint
paint
;
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
auto
fp
=
GrSimpleTextureEffect
:
:
Make
(
sk_ref_sp
(
src
)
srcColorType
SkMatrix
:
:
I
(
)
)
;
if
(
!
fp
)
{
return
false
;
}
paint
.
addColorFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
this
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeXYWH
(
clippedDstPoint
.
fX
clippedDstPoint
.
fY
clippedSrcRect
.
width
(
)
clippedSrcRect
.
height
(
)
)
SkRect
:
:
Make
(
clippedSrcRect
)
)
;
return
true
;
}
